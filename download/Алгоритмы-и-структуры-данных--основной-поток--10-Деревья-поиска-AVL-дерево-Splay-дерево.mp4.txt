[00:00.000 --> 00:12.400]  Мы переходим к блоку про деревья поиска, посмотрим
[00:12.400 --> 00:17.760]  много всяких разных реализаций, ну и посравниваем, какие
[00:17.760 --> 00:20.680]  бывают выгоднее, когда какие лучше использовать.
[00:20.680 --> 00:25.920]  Дерево поиска, как следует из названия, позволяет
[00:25.920 --> 00:30.760]  нам в каком-то смысле искать элементы в множестве.
[00:30.760 --> 00:33.840]  Мы будем хранить множество элементов и наконец-то
[00:33.840 --> 00:37.800]  научимся решать задачу о поиске элементов в множестве.
[00:37.800 --> 00:41.800]  Ну поиск тоже самое, проверка наличия или в каком-то смысле
[00:41.800 --> 00:44.640]  узнавание, где конкретный элемент лежит.
[00:44.640 --> 00:47.000]  Ну давайте формализуем.
[00:47.000 --> 00:54.200]  Мы хотим хранить, ну давайте напишем, что деревья поиска,
[00:55.000 --> 00:59.480]  значит мы хотим создать такую структуру данных,
[00:59.480 --> 01:07.760]  которая бы хранила множество s, к которому поступают следующие
[01:07.760 --> 01:08.760]  запросы.
[01:08.760 --> 01:11.560]  Ну первый самый простой, это как раз поиск, проверка
[01:11.560 --> 01:17.400]  наличия элементов в множестве, значит find x, это просто сказать
[01:17.400 --> 01:27.920]  да или нет, есть ли x в множестве, ответить на вопрос, есть
[01:27.920 --> 01:31.480]  ли x в множестве s.
[01:31.480 --> 01:36.280]  Ну и соответственно, если есть запросы поиска, то
[01:36.280 --> 01:39.320]  наверное надо как-то наше множество уметь изменять.
[01:39.320 --> 01:42.600]  Ну вот к множеству будут поступать запросы двух типов.
[01:42.840 --> 01:52.120]  Это insert, добавить x в s, ну то есть если его там не было,
[01:52.120 --> 01:54.800]  то положить, значит давайте считать, что у нас хранится
[01:54.800 --> 01:59.000]  именно множество, а не мульти множество, и дубликаты мы
[01:59.000 --> 02:01.960]  как бы игнорируем, если у нас два раза добавляется
[02:01.960 --> 02:05.320]  одно и то же число, там insert x, insert x, то мы второй
[02:05.320 --> 02:07.880]  insert будем игнорировать, ну потому что в множестве
[02:07.880 --> 02:10.200]  у меня дубликатов, дубликаты отсутствуют.
[02:10.200 --> 02:13.840]  Если надо, мы можем потом спокойно это модифицировать
[02:13.840 --> 02:16.280]  так, чтобы хранить именно мульти множество, ну например
[02:16.280 --> 02:19.000]  можно просто с каждым x хранить ассоциированное
[02:19.000 --> 02:21.280]  число раз, в которое он входит, и там сколько раз
[02:21.280 --> 02:24.200]  пришел insert, можно рядом с этим x всегда хранить сколько
[02:24.200 --> 02:25.840]  раз он в нашу структуру входит.
[02:25.840 --> 02:27.640]  Ну пока давайте считать, что это множество, дубликатов
[02:27.640 --> 02:28.640]  не бывает.
[02:28.640 --> 02:32.920]  Ну и обратная операция, это erase, это соответственно
[02:32.920 --> 02:44.840]  удалить xss, вот, значит это основные три операции,
[02:44.840 --> 02:47.520]  которые должны уметь поддерживать дерево поиска, есть еще
[02:47.520 --> 02:57.680]  опциональные, которые ну нужно не всегда и не все реализации
[02:57.680 --> 03:01.200]  дерево поиска с этими операциями хорошо справляются, значит
[03:01.200 --> 03:07.720]  это merge, похоже на то, что у нас уже было, когда мы
[03:07.720 --> 03:10.880]  про кучи говорили, мы вот раньше объединяли кучи,
[03:10.880 --> 03:13.440]  теперь то, что самое объединить нужно будет деревья, то есть
[03:13.440 --> 03:16.080]  представьте, у вас есть два множества с 1 и с 2, каждая
[03:16.080 --> 03:18.280]  из которых хранится в каком-то дереве поиска, ну вы хотите
[03:18.280 --> 03:21.180]  просто их склеить, объединить, вы хотите построить одно
[03:21.180 --> 03:28.840]  новое дерево поиска на объединении двух множества с 1 и с 2.
[03:28.840 --> 03:35.320]  Ну и обратная процедура, это разделение, split множество
[03:35.320 --> 03:41.240]  давайте s по ключу k, значит это процедура разделения
[03:41.240 --> 03:44.640]  множества s на 2 под множество, на те ключи, которые меньше
[03:44.640 --> 03:48.680]  либо равны k и на те ключи, которые больше, чем k, ну то
[03:48.680 --> 03:51.840]  есть вот если у нас были все элементы в s, мы их грубо
[03:51.840 --> 03:54.520]  говоря посортировали, все не большие k отнесли в
[03:54.520 --> 03:57.560]  лево, все большие k отнесли вправо, то есть здесь ну
[03:57.560 --> 04:01.840]  давайте я так напишу, мне нужно разбить, мне нужно
[04:01.840 --> 04:07.440]  найти все такие x из s, которые были меньше либо равны k,
[04:07.440 --> 04:11.400]  это будет первое множество, второе это все такие x из
[04:11.400 --> 04:17.720]  s, которые были больше, чем k, ну соответственно в каком
[04:17.720 --> 04:22.000]  смысле процедура обратная к merge, наоборот расплитить,
[04:22.000 --> 04:25.640]  разбить одно множество на два под множество по какому-то
[04:26.120 --> 04:37.120]  значению, по ключу k, можно, да, но хешмапы мы ближе
[04:37.120 --> 04:45.000]  к концу разберем, хешмапы они в каком-то смысле, давайте
[04:45.000 --> 04:50.400]  пока, это будет потом, сейчас у нас будут алгоритмы, которые
[04:50.400 --> 04:53.880]  честно работают без хеширования, честно отвечают на все
[04:53.880 --> 04:58.520]  эти операции, будет зал алгоритм, вот, это во многих
[04:58.520 --> 05:00.600]  ситуациях лучше хешмапы, давайте вот когда до хешмапа
[05:00.600 --> 05:04.440]  подойдем, тогда обсудим в чем отличие, вот, значит
[05:04.440 --> 05:08.640]  вообще говоря мы обычно будем в качестве s хранить
[05:08.640 --> 05:13.560]  множество целых чисел, ну там int или long, с точки зрения
[05:13.560 --> 05:16.000]  теории это важно только тем, что мы умеем элементы
[05:16.000 --> 05:18.360]  сравнивать между собой за единицу, скажем если
[05:18.360 --> 05:20.960]  у вас есть два целых числа, храняющиеся в каких-то
[05:20.960 --> 05:23.280]  стандартных типах данных, то вы можете их за одно
[05:23.780 --> 05:26.280]  действие, за значок меньше и больше, сравнить, узнать
[05:26.280 --> 05:28.100]  какой из них больше, но грубо говоря тогда понятно,
[05:28.100 --> 05:30.140]  что вот эти операции меньше равно больше, они легкие.
[05:30.140 --> 05:33.340]  Вообще говоря, можно в дереве поиска хранить более или
[05:33.340 --> 05:36.920]  менее любые, какие угодно объекты, также как на самом
[05:36.920 --> 05:38.780]  деле во всех предыдущих, в куче можно было их хранить,
[05:38.780 --> 05:43.300]  объекты любых типов, главное чтобы на них были определены
[05:43.300 --> 05:45.620]  вот эти операции больше и меньше, ну и желательно
[05:45.620 --> 05:50.200]  чтобы они за какое-то адекватное время подсчитывались, administrative
[05:50.200 --> 05:52.000]  , можно довольно легко понять какой из них больше,
[05:52.000 --> 06:06.000]  Я буду почти всегда неявно предполагать, что множество у меня хранятся числа, хотя на самом деле эта теория более общая и, конечно, можно хранить там более-менее что угодно, что можно сравнить между собой.
[06:06.000 --> 06:20.000]  Например, с их помощью можно хранить всякие базы данных, например, у вас есть какой-нибудь сайт, на котором вам надо хранить логин-пароли пользователей.
[06:20.000 --> 06:26.000]  Ну вот, соответственно, у вас есть множество с, множество пар, грубо говоря, какой пользователь, какой у него пароль.
[06:26.000 --> 06:32.000]  И тогда, когда потом приходит новый пользователь и пытается залогиниться в вашу систему, вам надо проверить, правильна ли у него пароль,
[06:32.000 --> 06:38.000]  ну вы просто смотрите на find, есть ли такой пользователь с таким паролем в системе.
[06:38.000 --> 06:46.000]  Ну и, соответственно, там говорите, что у вас либо ошибка в пароле, либо в логине, ну а иначе вы пользователя опускаете и говорите, вот он залогинился.
[06:46.000 --> 06:56.000]  Ну и, соответственно, erase, insert – это процедура, скажем, удаления аккаунта, это процедура добавления нового аккаунта на сайте.
[06:56.000 --> 06:59.000]  Так что вполне такая полезная штука есть.
[06:59.000 --> 07:10.000]  Merge, split – они такие с точки зрения практики более абстрактные, но в каких-то, опять же, в каких-то конкретных задачах, где дерево поиска используется как подзадача, они бывают очень нужны, мы тоже потом это посмотрим.
[07:10.000 --> 07:18.000]  Давайте сначала посмотрим на наивное дерево поиска.
[07:18.000 --> 07:26.000]  Это самая простая попытка реализовать все вот эти вот запросы.
[07:26.000 --> 07:32.000]  Мы будем хранить все наши элементы в виде бинарного корневого дерева.
[07:32.000 --> 07:41.000]  У нас будет некий корень, у каждой вершины будет максимум два сына.
[07:41.000 --> 07:44.000]  Ну давайте я вот что-нибудь такое нарисую.
[07:44.000 --> 07:47.000]  И мы, соответственно, будем различать левого и правого сына.
[07:47.000 --> 07:51.000]  Левый сын и правый сын – это именно разные вещи.
[07:51.000 --> 07:56.000]  Может быть, левый может не быть правого, может быть, наоборот, может быть, правый не быть левого, могут быть оба, может не быть никого.
[07:56.000 --> 07:59.000]  Ну вот, например, вот это корректно бинарное дерево.
[07:59.000 --> 08:03.000]  В каждой вершине у меня будут храниться элементы множества.
[08:09.000 --> 08:15.000]  То есть, по факту я на всех элементах S ввожу вот такую деревовидную структуру, подвешиваю за какой-то корень,
[08:15.000 --> 08:18.000]  и вот оно, соответственно, у меня ориентировано сверху вниз,
[08:18.000 --> 08:22.000]  то есть, тут такие стрелочки на самом деле стоят, ор assassin у меня сверху вниз,
[08:22.000 --> 08:26.000]  в каждой вершине лежат элементы, соответственно, вершин ровно столько же, сколько элементов.
[08:26.000 --> 08:31.560]  Вот здесь у меня вершин 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.
[08:31.560 --> 08:33.880]  Это дерево, представляющее какое-то десятиэлементное
[08:33.880 --> 08:34.880]  множество.
[08:34.880 --> 08:38.200]  Давайте я как-нибудь пример приведу, как оно может быть
[08:38.200 --> 08:39.200]  заполнено.
[08:39.200 --> 08:41.920]  Ну пусть здесь какое-нибудь число типа 20 состоит.
[08:41.920 --> 08:59.440]  Ну, например, что-то такое.
[08:59.440 --> 09:03.520]  Соответственно, S – это просто все вот эти числа, которые
[09:03.520 --> 09:06.520]  я записал в вершину.
[09:06.520 --> 09:09.880]  Значит, они здесь расположены не случайно, они расположены
[09:09.880 --> 09:11.040]  по следующему правилу.
[09:11.080 --> 09:13.000]  Смотрите, что если в вершине написано какое-то число
[09:13.000 --> 09:17.680]  X, то в дереве поиска у меня обязательно все, что находится
[09:17.680 --> 09:20.440]  в левом поддереве, все элементы, которые получаются
[09:20.440 --> 09:22.800]  в левом поддереве при спуске в левого сына.
[09:22.800 --> 09:27.240]  Вот здесь все числа всегда строго меньше, чем X.
[09:27.240 --> 09:30.440]  А справа, наоборот, если я спускаюсь в правое ребенко,
[09:30.440 --> 09:32.080]  то у меня, наоборот, здесь все числа строго больше,
[09:32.080 --> 09:33.080]  чем X.
[09:33.080 --> 09:35.960]  Ну вот на картинке вроде это как раз выполняется.
[09:35.960 --> 09:38.960]  Смотрите, вот, например, в корне у меня число 20.
[09:38.960 --> 09:41.400]  Давайте посмотрим на все левое поддерево корня.
[09:41.400 --> 09:42.400]  Тут какие числа?
[09:42.400 --> 09:45.600]  10, 5, 15, 3, 7, 14, 9.
[09:45.600 --> 09:48.400]  Эти все числа меньше, чем 20, поэтому они имеют право
[09:48.400 --> 09:50.360]  находиться в левом поддереве корня.
[09:50.360 --> 09:52.840]  Справа, наоборот, справа у меня 21, 23 – это числа
[09:52.840 --> 09:55.560]  больше, чем 20, они имеют право находиться справа.
[09:55.560 --> 09:59.080]  Наоборот, 15 вот сюда я поместить бы не мог, потому что здесь
[09:59.080 --> 10:02.640]  числа обязательно должны быть больше, чем 20.
[10:02.640 --> 10:05.320]  И более того, вот это правило про то, что слева меньше
[10:05.320 --> 10:07.840]  и справа больше, оно выполняется не только для корни, но
[10:07.920 --> 10:08.920]  и для всех вершин.
[10:08.920 --> 10:13.840]  Например, вот для этой десятки слева во всем левом поддереве
[10:13.840 --> 10:15.600]  числа могут быть только меньше, чем 10.
[10:15.600 --> 10:17.480]  Ну и здесь вроде у меня это верно.
[10:17.480 --> 10:19.920]  3, 5, 7, 9 – это все числа только меньше, чем 10.
[10:19.920 --> 10:23.480]  А в правом поддереве числа только больше, чем 10.
[10:23.480 --> 10:25.920]  14, 15 числа больше, чем 10.
[10:25.920 --> 10:29.080]  Вот, кстати говоря, вот на это дерево у меня накладывается
[10:29.080 --> 10:30.680]  как минимум два ограничения.
[10:30.680 --> 10:33.120]  Смотрите, они с одной стороны больше, чем 10, потому что
[10:33.120 --> 10:35.800]  лежат в правом поддереве десятки, с другой стороны
[10:35.800 --> 10:38.080]  все меньше, чем 20, потому что они лежат в левом поддереве
[10:38.080 --> 10:39.080]  двадцатки.
[10:39.080 --> 10:42.240]  Вообще говоря, каждое такое поддерево, оно в каком-то
[10:42.240 --> 10:45.000]  смысле ограничено и слева, и справа какими-то своими
[10:45.000 --> 10:46.000]  предками.
[10:46.000 --> 10:47.840]  Ограничено слева десятка, и справа двадцатка.
[10:47.840 --> 10:50.240]  Все значения в этом поддереве между десяткой и двадцаткой
[10:50.240 --> 10:51.240]  расположены.
[10:51.240 --> 10:57.760]  Ну, соответственно, тем самым, что такое дерево
[10:57.760 --> 10:58.760]  поиска?
[10:58.760 --> 11:00.560]  Дерево поиска – это бинарное корневое дерево.
[11:01.560 --> 11:11.240]  Ну, давайте я скажу удовлетворяющее вот этому свойству для
[11:11.240 --> 11:12.240]  любой вершины.
[11:12.240 --> 11:17.200]  Удовлетворяющее вот этому вот свойству для всех вершин.
[11:17.200 --> 11:27.600]  Вот, значит, это определение дерева поиска, определение,
[11:27.600 --> 11:28.600]  что такое дерево поиска.
[11:28.600 --> 11:42.840]  Вот, хорошо, значит, я утверждаю, что вот такая вот структура
[11:42.840 --> 11:47.920]  на элементах моего множества дает мне весьма большие
[11:47.920 --> 11:48.920]  преимущества.
[11:48.920 --> 11:50.880]  Ну, давайте, например, поймем, как реализовывать процедуру
[11:50.880 --> 11:58.920]  find x.
[11:58.920 --> 11:59.920]  Подсказывайте.
[11:59.920 --> 12:03.320]  Если х меньше, то спускаем снизу.
[12:03.320 --> 12:04.320]  Да, да, да.
[12:04.320 --> 12:05.320]  Абсолютно верно.
[12:05.320 --> 12:08.160]  Значит, давайте, вот у меня есть какое число х, давайте
[12:08.160 --> 12:09.840]  посмотрим на корень моего дерева.
[12:09.840 --> 12:10.840]  Корень.
[12:10.840 --> 12:13.280]  Ну, во-первых, понятно, что если здесь написано
[12:13.280 --> 12:14.880]  число х, то мы нашли число х.
[12:14.880 --> 12:17.120]  Вот оно вот здесь вот лежит, мы победили х в дереве.
[12:17.120 --> 12:19.640]  Даже более того, мы знаем, где конкретно оно лежит.
[12:19.640 --> 12:22.400]  Какая конкретная вершина соответствует числу х.
[12:22.400 --> 12:25.200]  А иначе мы однозначно понимаем, в какой из двух поддельев
[12:25.200 --> 12:26.200]  надо спускаться.
[12:26.200 --> 12:27.200]  Либо влево, либо вправо.
[12:27.200 --> 12:31.200]  Потому что, скажем, если здесь лежит число у, то
[12:31.200 --> 12:34.440]  по знаку сравнения х и у мы понимаем, куда надо
[12:34.440 --> 12:35.440]  идти.
[12:35.440 --> 12:37.520]  Да, если х меньше, чем у, то нам нужно в любом случае
[12:37.520 --> 12:40.840]  идти влево, потому что справа чисто только больше, чем
[12:40.840 --> 12:43.000]  у, и х там находиться точно не может.
[12:43.000 --> 12:44.960]  Х, если где-то и лежит, то только слева.
[12:44.960 --> 12:49.520]  Ну и наоборот, если х больше, чем у, то он обязан находиться
[12:49.520 --> 12:51.480]  справа, если где-то и находится, то он обязан находиться
[12:51.480 --> 12:54.400]  справа, потому что слева только числа меньше, чем
[12:54.400 --> 12:55.960]  у, а значит меньше, чем х.
[12:55.960 --> 12:56.960]  Поэтому их там искать бесполезно.
[12:56.960 --> 13:02.040]  Ну вот, и тем самым мы понимаем, в какую из двух веточек
[13:02.040 --> 13:03.040]  всегда нужно идти.
[13:03.040 --> 13:05.840]  У нас нет смысла раздваиваться идти и туда, и туда, как это
[13:05.840 --> 13:07.080]  было в дереве отрезков.
[13:07.080 --> 13:09.240]  Мы всегда понимаем, что мы, скажем, идем либо влево,
[13:09.240 --> 13:10.240]  либо вправо.
[13:10.240 --> 13:11.240]  Только в одно из двух направлений.
[13:11.240 --> 13:12.240]  Вот.
[13:12.240 --> 13:15.280]  Поэтому такой очень простой алгоритм поиска, мы понимаем,
[13:15.280 --> 13:16.280]  куда надо идти.
[13:16.280 --> 13:19.160]  И время работы будет очевидно от h, где h – это глубина
[13:19.160 --> 13:25.560]  Ну, потому что в худшем случае я просто от корня
[13:25.560 --> 13:28.160]  спускаюсь до какого-то листа.
[13:28.160 --> 13:31.520]  А если, скажем, х в дереве нет, то я иду-иду-иду, его
[13:31.520 --> 13:33.920]  ищу, в конце концов дохожу до такой вершины, откуда
[13:33.920 --> 13:34.920]  идти больше некуда.
[13:34.920 --> 13:35.920]  Это в точности лист.
[13:35.920 --> 13:37.520]  Лист – это вершина без детей.
[13:37.520 --> 13:40.600]  Ну и как раз h – это глубина, это максимальное расстояние
[13:40.600 --> 13:41.800]  от корня до какого-либо листа.
[13:41.800 --> 13:45.400]  Да, понятно же?
[13:45.400 --> 13:46.400]  Хорошо.
[13:47.240 --> 13:49.960]  Так, ну давайте тогда insert скажем, как можно реализовать.
[13:49.960 --> 13:52.960]  Insert x.
[13:52.960 --> 13:56.960]  Ну, во-первых, давайте сначала запустим процедуру find, и
[13:56.960 --> 13:59.040]  если х уже в дереве есть, то, наверное, его добавлять
[13:59.040 --> 14:00.040]  не нужно.
[14:00.040 --> 14:05.800]  А, значит, давайте я здесь буду считать, что х в дереве
[14:05.800 --> 14:06.800]  отсутствовал.
[14:06.800 --> 14:12.000]  Потому что, если что, можно предварительно проверить,
[14:12.000 --> 14:14.440]  есть он там или нет с помощью find, и если есть, то ничего
[14:14.440 --> 14:15.440]  не делать.
[14:15.480 --> 14:16.480]  Теперь считаем, что его нету.
[14:16.480 --> 14:20.800]  Ну, давайте тогда найдем место, куда было бы его
[14:20.800 --> 14:22.080]  логично разместить.
[14:22.080 --> 14:26.720]  Давайте будем спускаться аналогично find в поисках
[14:26.720 --> 14:27.720]  х.
[14:27.720 --> 14:29.960]  То есть, окей, мы считаем, что х нет, но давайте попробуем
[14:29.960 --> 14:32.160]  пойти по тому пути, где он как бы должен был бы
[14:32.160 --> 14:33.160]  быть.
[14:33.160 --> 14:34.880]  Делается точно так же.
[14:34.880 --> 14:38.960]  Если мы знаем, как х сравнивается с текущим значением вершины,
[14:38.960 --> 14:41.080]  то мы понимаем, в какого из двух сыновей идти – в
[14:41.080 --> 14:42.080]  левую или в правую.
[14:42.080 --> 14:44.920]  Ну, давайте так как-то пойдем.
[14:44.920 --> 14:48.600]  Найдем до листа, то есть вершины без детей.
[14:48.600 --> 14:53.800]  По идее, как бы вот куда-то сюда надо подвесить х.
[14:53.800 --> 14:57.240]  Ну, давайте тогда просто подвесим х в качестве соответствующего
[14:57.240 --> 14:59.280]  сына слева или справа к этому листу.
[14:59.280 --> 15:02.640]  Давайте, если здесь было написано число z, то подвесим
[15:02.640 --> 15:06.680]  х слева, если х меньше, чем z, ну и справа иначе.
[15:06.680 --> 15:09.700]  Давайте я нарисую картинку для х меньше z, и отдельно
[15:09.700 --> 15:13.480]  для х больше, чем z.
[15:14.040 --> 15:18.080]  Простите, пожалуйста, не логичнее запускать поиск,
[15:18.080 --> 15:19.080]  а сразу...
[15:19.080 --> 15:23.280]  Ну, на самом деле я ровно это и делаю.
[15:23.280 --> 15:26.840]  То есть я встаю в корень, сравниваю пошагово х с текущим
[15:26.840 --> 15:28.800]  значением вершины, куда-то спускаюсь.
[15:28.800 --> 15:31.040]  Рано или поздно я либо дошел до вершины равной х, тогда
[15:31.040 --> 15:34.520]  можно завершиться и ничего не делать, либо я дохожу
[15:34.520 --> 15:36.880]  до листа и подвешиваю с одной из двух сторон.
[15:36.880 --> 15:40.600]  А, это дерево может быть линейным.
[15:40.600 --> 15:41.600]  Да.
[15:41.600 --> 15:43.320]  Именно поэтому это наивное дерево поиск.
[15:43.400 --> 15:44.400]  Пока что я...
[15:44.400 --> 15:48.080]  Ну, то есть я это рассказываю затем, потому что мы это
[15:48.080 --> 15:50.720]  будем делать почти везде, просто обычно после того,
[15:50.720 --> 15:53.240]  как мы, скажем, подвесили куда-то х, мы будем запускать
[15:53.240 --> 15:55.960]  какую-то процедуру балансировки, чтобы дерево не разрасталось
[15:55.960 --> 16:00.080]  в длинную колбасу, чтобы оно было не очень глубокое.
[16:00.080 --> 16:01.920]  То есть я хочу поддерживать глубину не очень большую,
[16:01.920 --> 16:02.920]  чтобы файн быстро работал.
[16:02.920 --> 16:06.040]  Но пока давайте в тупую делать, просто хранить какое-то
[16:06.040 --> 16:07.040]  корректное дерево.
[16:07.040 --> 16:10.400]  Так, понятно, что такая процедура, инсерт корректно
[16:10.400 --> 16:11.400]  работает.
[16:12.080 --> 16:15.320]  Но она сохраняет все свойства дерева, потому что мы подвешиваем
[16:15.320 --> 16:16.320]  х туда, куда можно.
[16:16.320 --> 16:34.600]  Ещё раз, мы запускаем типа find, идём куда-то по какой-то
[16:34.600 --> 16:37.600]  ветке, всегда сравним х с текущим значением, понимаем,
[16:37.600 --> 16:38.600]  куда надо идти влево или вправо.
[16:39.000 --> 16:41.600]  Рано или поздно мы либо дойдём до х, и тогда ничего добавлять
[16:41.600 --> 16:42.600]  не нужно.
[16:42.600 --> 16:45.000]  Либо мы дойдём до вершины без детей, то есть до листа.
[16:45.000 --> 16:54.800]  И тогда надо подвесить х на то пустое место, как
[16:54.800 --> 16:55.800]  он соотносится с z.
[16:55.800 --> 17:01.800]  А если мы вставляем, например, в то дерево число 11?
[17:01.800 --> 17:04.800]  Вставляем в то дерево число 11.
[17:04.800 --> 17:07.200]  Ну, смотрите, давайте вставим 11, очень просто.
[17:07.600 --> 17:09.600]  11 меньше, чем 20 идём налево.
[17:09.600 --> 17:11.600]  11 больше, чем 10 идём направо.
[17:11.600 --> 17:13.600]  11 меньше, чем 15 идём налево.
[17:13.600 --> 17:16.600]  11 меньше, чем 14 идём налево.
[17:16.600 --> 17:19.600]  Поэтому 11 должно быть вот здесь, вот левее, чем 14.
[17:21.600 --> 17:22.600]  Вот.
[17:22.600 --> 17:24.600]  Ну всё, получается, что инсерт мы тоже реализовали
[17:24.600 --> 17:25.600]  за олаташ.
[17:28.600 --> 17:29.600]  Так, хорошо.
[17:29.600 --> 17:32.600]  Ну и последнее, надо сказать, как работает erase.
[17:33.600 --> 17:34.600]  Erase х.
[17:35.000 --> 17:38.000]  Ну, давайте опять считать, что х на этот раз, наоборот,
[17:38.000 --> 17:40.500]  в дереве присутствует, потому что иначе надо удалить
[17:40.500 --> 17:42.500]  элемент, которого нету в дереве, можно ничего не
[17:42.500 --> 17:43.500]  делать просто.
[17:43.500 --> 17:45.500]  Давайте считать, что х в дереве присутствует.
[17:50.500 --> 17:51.500]  Вот.
[17:51.500 --> 17:54.500]  Давайте сначала его в дереве локализуем.
[17:54.500 --> 17:56.500]  Найдём, где он лежит.
[17:56.500 --> 17:59.500]  Спустимся от корня, найдём его позицию в дереве х.
[18:00.400 --> 18:05.400]  Значит, тут есть один простой случай.
[18:05.400 --> 18:11.400]  Значит, если х – это лист, или, скажем, у него есть всего
[18:11.400 --> 18:12.400]  один из двух детей.
[18:12.400 --> 18:14.400]  Ну, например, ну не знаю, давайте правый сын у него
[18:14.400 --> 18:15.400]  есть.
[18:15.400 --> 18:17.400]  Вот у него есть правый сын, и там что-то ещё в его
[18:17.400 --> 18:18.400]  поддереве что-то находится.
[18:18.400 --> 18:21.400]  А левого сына, например, нету.
[18:21.400 --> 18:23.400]  Ну тогда можно сделать очень простую вещь.
[18:23.400 --> 18:26.400]  Можно просто вот то, что было в поддереве, скажем,
[18:26.400 --> 18:28.400]  всё правое поддерево х, просто взять и переподвесить
[18:29.300 --> 18:30.300]  на место х.
[18:30.300 --> 18:33.300]  То есть я х высекаю из моего дерева, и на его место подвешиваю
[18:33.300 --> 18:34.300]  то, что лежало ниже него.
[18:34.300 --> 18:38.300]  То есть я вот этот путь сохраняю, и дальше вместо х подвешиваю
[18:38.300 --> 18:40.300]  целиком всё это под дерево t.
[18:40.300 --> 18:42.460]  Вот на место х я просто по факту всё это поднимаю
[18:42.460 --> 18:43.460]  вместо х.
[18:43.460 --> 18:48.460]  Вот, значит, например, здесь…
[18:53.460 --> 18:54.460]  Так, ну тут…
[18:54.460 --> 18:57.460]  Ну, например, если меня просят удалить 15, я могу
[18:57.520 --> 19:00.520]  просто 14 поднять вот сюда вот, и забыть про существование
[19:00.520 --> 19:01.520]  14.
[19:01.520 --> 19:03.520]  Ну то есть, на самом деле, я забыл сначала про 15,
[19:03.520 --> 19:06.520]  на его место поднимаю 14, у меня будет просто 10 стрелка
[19:06.520 --> 19:07.520]  14.
[19:07.520 --> 19:10.520]  А вот этого всего уже нет, потому что я это поднял.
[19:10.520 --> 19:12.520]  Значит, это простой случай.
[19:12.520 --> 19:15.520]  Если у меня было 0 детей или 1 сын.
[19:15.520 --> 19:18.520]  Если 0 детей, то можно просто х удалить, и дерево останется
[19:18.520 --> 19:19.520]  хорошим.
[19:19.520 --> 19:24.520]  Значит, это случай, когда у меня не больше, чем 1 ребёнок.
[19:25.520 --> 19:26.520]  Вот.
[19:26.520 --> 19:29.520]  Значит, что делать, если у меня 2 сына?
[19:29.520 --> 19:33.520]  Представьте, я нашёл х в дереве, и у него, к несчастью,
[19:33.520 --> 19:37.520]  есть оба сына, левый и правый.
[19:37.520 --> 19:40.520]  2 под дерево, левый и правый.
[19:50.520 --> 19:53.520]  Значит, здесь я сделаю следующее.
[19:53.520 --> 19:57.520]  Например, я могу сделать такую вещь.
[19:57.520 --> 20:01.520]  Давайте мы в этом правом под дереве, в праве х всё,
[20:01.520 --> 20:05.520]  что находится, и ниже, давайте найдём в этом под дереве самое
[20:05.520 --> 20:08.520]  маленькое число, самый маленький элемент.
[20:08.520 --> 20:11.520]  Давайте я его назову какой-нибудь m.
[20:11.520 --> 20:16.520]  Пусть m это минимум в правом под дереве х.
[20:23.520 --> 20:26.520]  Во-первых, как найти минимум?
[20:26.520 --> 20:29.520]  Давайте, если я сюда вот встал, как найти в этом под дереве
[20:29.520 --> 20:32.520]  минимальное число, минимальное элемент?
[20:32.520 --> 20:35.520]  Да, надо просто идти влево, пока есть левый сын.
[20:35.520 --> 20:39.520]  Потому что мы знаем, что при спуске влево, то есть в сторону,
[20:39.520 --> 20:42.520]  на этой картинке влево я когда иду, у меня всегда значение
[20:42.520 --> 20:44.520]  уменьшается, а если я иду направо, то увеличивается.
[20:44.520 --> 20:47.520]  Поэтому единственный способ уменьшать текущее значение,
[20:47.520 --> 20:48.520]  это идти влево.
[20:48.520 --> 20:51.520]  Так вот, давайте из этой вершины будем просто идти влево, влево, влево,
[20:51.520 --> 20:54.520]  пока левый сын есть, до тех пор, пока не найдется вершина,
[20:54.520 --> 20:56.520]  у которой нет левого сына.
[20:56.520 --> 20:59.520]  Вот я отужаю, что она обязательно будет минимальной.
[20:59.520 --> 21:02.520]  Ну понятно, потому что если я в какой-то момент отсветляюсь направо,
[21:02.520 --> 21:05.520]  то я увеличиваю свое значение по сравнению с предыдущим значением.
[21:05.520 --> 21:08.520]  Поэтому минимум может быть только вот этой вот вершиной,
[21:08.520 --> 21:11.520]  которая получается, когда мы шли все время влево.
[21:11.520 --> 21:13.520]  Вот, значит, хорошо.
[21:13.520 --> 21:15.520]  Давайте я дерево так нарисую.
[21:15.520 --> 21:18.520]  Мы нашли вершину m, минимальную вершину в правом под дереве,
[21:18.520 --> 21:20.520]  и у нее в частности нет левого сына.
[21:20.520 --> 21:23.520]  Потому что, будь у нее левый сын, она была бы не минимальной,
[21:23.520 --> 21:26.520]  можно было бы спуститься и получить значение еще поменьше.
[21:26.520 --> 21:29.520]  Значит, у m нет левого сына.
[21:31.520 --> 21:33.520]  У m нет левого сына.
[21:34.520 --> 21:37.520]  Тогда я могу сделать пример на следующий.
[21:37.520 --> 21:40.520]  Я могу сделать erase m,
[21:40.520 --> 21:43.520]  и значение m написать вместо x.
[21:45.520 --> 21:47.520]  Ну смотрите, erase m я делать уже умею,
[21:47.520 --> 21:49.520]  потому что раз у m нет левого сына,
[21:49.520 --> 21:52.520]  то мне нужно просто все правое под дерево m-ки
[21:52.520 --> 21:55.520]  переподвесить на место m.
[21:55.520 --> 21:58.520]  То есть давайте виртуально сделаем erase m.
[21:58.520 --> 22:00.520]  Erase m я делать умею.
[22:00.520 --> 22:03.520]  Я нахожу m, вот она у меня, вершина m.
[22:03.520 --> 22:06.520]  Левого сына нет, а правое возможно есть,
[22:06.520 --> 22:09.520]  я все это правое под дерево вершины m подвешу на место m,
[22:09.520 --> 22:11.520]  а m как бы оттуда высекаю.
[22:11.520 --> 22:14.520]  А потом давайте вот то m, который я высек,
[22:14.520 --> 22:17.520]  давайте я его поставлю на место x.
[22:19.520 --> 22:22.520]  Тогда с одной стороны я избавлюсь от x
[22:22.520 --> 22:25.520]  и реализую тот самый erase x.
[22:25.520 --> 22:28.520]  С другой стороны у меня сохранится вариант дерева поиска.
[22:28.520 --> 22:30.520]  Потому что, ну вот представьте,
[22:30.520 --> 22:33.520]  по факту что я сделал, я просто вместо x написал здесь m,
[22:33.520 --> 22:36.520]  и вот это правое под дерево поднял на место m.
[22:36.520 --> 22:39.520]  Я утверждаю, что это корректное дерево поиска теперь будет.
[22:39.520 --> 22:43.520]  Ну почему? Потому что все, что было левее, оно было меньше x,
[22:43.520 --> 22:45.520]  einem было больше x, значит тем более меньше, чем m,
[22:45.520 --> 22:48.520]  потому что поскольку m лежало в правом под деревье x,
[22:48.520 --> 22:51.520]  то, конечно же, м больше, чем x,
[22:51.520 --> 22:53.520]  потому что m лежало в правом под дереве x.
[22:53.520 --> 22:55.520]  Тут был x, тут m, m больше, чем x.
[22:55.520 --> 22:57.520]  Поэтому, когда я его сюда поднимаю,
[22:57.520 --> 22:59.520]  левое под дерево будет по прежнему меньше, чем m,
[22:59.520 --> 23:01.520]  здесь все будет хорошо,
[23:01.520 --> 23:03.520]  и с правым, под деревом тоже неравность в ней нарушится,
[23:03.520 --> 23:06.520]  потому что я отсюда взял специально самый маленький элемент,
[23:06.520 --> 23:08.980]  поднял его сюда, значит он об Lang
[23:08.980 --> 23:10.520]  меньше, чем все остальные,
[23:10.520 --> 23:12.520]  потому что он был там самый маленький,
[23:12.520 --> 23:17.120]  вот туда поднял, значит, этот элемент меньше, чем все, что осталось здесь.
[23:17.120 --> 23:25.120]  Ну давайте я схематично напишу, что я как бы делаю erase m и заменяю x на m.
[23:25.120 --> 23:31.520]  Замена x на m. Вот.
[23:31.520 --> 23:35.920]  Так мы будем делать в случае, когда у удаляемой вершины x два ребенка.
[23:35.920 --> 23:39.120]  То есть по факту я свел случай двух детей к одному ребенку.
[23:39.120 --> 23:41.520]  Вот как раз я нахожу вершину m, у которого один ребенок,
[23:41.520 --> 23:48.520]  поднимаю этого одного ребенка на его место, и m поднимаю на место удаляемой вершины x.
[23:48.520 --> 23:51.520]  Вот. Все. Да.
[23:51.520 --> 23:54.520]  А мы можем аналогично взять из левого потерянного?
[23:54.520 --> 23:56.520]  Да. Абсолютно аналогично.
[23:56.520 --> 23:57.520]  Можно было бы сделать то же самое.
[23:57.520 --> 24:00.520]  Можно было бы в левом сыне найти максимальный элемент.
[24:00.520 --> 24:02.520]  Этот самый максимальный элемент как бы удалить,
[24:02.520 --> 24:06.520]  потому что у него нет правого сына, значит, его можно удалить с помощью вот этой процедуры.
[24:06.520 --> 24:08.520]  И этот максимальный элемент поднять на место x.
[24:08.520 --> 24:09.520]  Можно делать то же самое.
[24:09.520 --> 24:10.520]  То же самое неважно.
[24:10.520 --> 24:12.520]  Если у вас есть оба сына, можно делать и то, и то.
[24:14.520 --> 24:15.520]  Окей?
[24:19.520 --> 24:23.520]  Сейчас мы потихоньку будем переходить к тому, как делать по-человечески.
[24:26.520 --> 24:31.520]  Значит, это корректно, но это долго.
[24:31.520 --> 24:35.520]  Как минимум потому, что давайте представим, как у нас будет работать последователь операций
[24:35.520 --> 24:38.520]  insert 1, insert 2, insert 3 и так далее.
[24:38.520 --> 24:40.520]  Если я вставляю числа в порядке возрастания.
[24:40.520 --> 24:44.520]  Но по факту у меня просто будут они вставляться вот в такую правую ветку.
[24:44.520 --> 24:49.520]  Сначала 1 будет корнем, потом 2 подвержется справа, 3 справа, 4 справа и так далее.
[24:49.520 --> 24:52.520]  У меня будет такая ветка правых детей вниз.
[24:55.520 --> 24:56.520]  Окей.
[24:56.520 --> 25:01.520]  Давайте тогда перейдем к более осмысленной структуре.
[25:01.520 --> 25:02.520]  Это называется AVL-дерево.
[25:05.520 --> 25:07.520]  AVL это просто фамилия авторов.
[25:09.520 --> 25:12.520]  Там нет какой-то тайны, что это такое.
[25:13.520 --> 25:19.520]  И давайте мы попробуем что-то сделать с нашим деревом так, чтобы оно не вырождалось
[25:19.520 --> 25:21.520]  в такую длинную петлю направо.
[25:21.520 --> 25:23.520]  Ну или там какую-либо.
[25:26.520 --> 25:28.520]  Мы хотим, чтобы оно было сбалансированным.
[25:32.520 --> 25:35.520]  Дерево поиска.
[25:38.520 --> 25:41.520]  Сбалансированное значит, что у него будет глубина всегда порядка логарифма.
[25:45.520 --> 25:47.520]  Глубина будет всегда порядка логарифма.
[25:48.520 --> 25:49.520]  Вот.
[25:49.520 --> 25:50.520]  Ну определение.
[25:52.520 --> 25:56.520]  Значит, бинарное дерево поиска.
[26:02.520 --> 26:05.520]  Называется AVL-дерево.
[26:12.520 --> 26:17.520]  Если для любой вершины В выполняется следующее соотношение.
[26:18.520 --> 26:20.520]  Значит, вот есть вершина В.
[26:21.520 --> 26:25.520]  Есть у нее левый сын, левое поддерево и правое поддерево.
[26:26.520 --> 26:28.520]  Давайте я их обозначу буквами L и R.
[26:29.520 --> 26:37.520]  Так вот, мне необходимо, чтобы разность глубин деревьев L и R была не очень большой.
[26:38.520 --> 26:44.520]  А именно, модуль разности h от L минус h от R должен не предстоить единицу.
[26:45.520 --> 26:50.520]  На где h от T, это глубина дерева T.
[26:58.520 --> 27:06.520]  Ну вот скажите, пожалуйста, например, вот это AVL-дерево или нет?
[27:07.520 --> 27:08.520]  Почему?
[27:09.520 --> 27:17.520]  Ну да, потому что, смотрите, если мы в качестве В возьмем корень, то у меня левое поддерево имеет глубину 1, 2, 3, 4.
[27:18.520 --> 27:20.520]  Вот он самый длинный путь в левом поддереве.
[27:21.520 --> 27:25.520]  4, а здесь 2. 4а2 отличается больше чем на единицу, это не AVL-дерево.
[27:25.520 --> 27:34.520]  Но кажется, если бы я стер вот эту девятку и рассмотрел такое дерево, то это похоже на AVL, потому что здесь глубина становится 3 и здесь 2, это нормально.
[27:35.520 --> 27:36.680]  Для этой вершины условие выполнено.
[27:37.520 --> 27:40.520]  Также, мне нужно не только для кор CopyW dice, но вообще для всех вершин дерева проверить.
[27:41.520 --> 27:46.520]  Давайте и здесь проверим, здесь вообще хорошо. Здесь и с левого глубина 2, а и с правого глубина 2.
[27:47.520 --> 27:48.520]  Поэтому для этой вершины вообще все отлично.
[27:49.520 --> 27:51.520]  Для этой вершины тоже нормально, потому что с левой глубины 0.
[27:51.520 --> 27:54.800]  нормально, потому что слева глубина 0, левого сына нету, здесь глубина 0,
[27:54.800 --> 28:00.160]  но справа 1. 0 и 1 отличаются не больше на 1, здесь все хорошо. Вот, ну и здесь тоже
[28:00.160 --> 28:03.600]  тривиально, здесь вообще одинаковые глубины, здесь отличаются на 1. Короче, все
[28:03.600 --> 28:08.560]  хорошо. Это вот это уже овель-дерево. Мне нужно, чтобы у каждой вершины, для каждого
[28:08.560 --> 28:11.440]  вы, обратите внимание, для каждой вершины, не только для корни, а вообще для всех,
[28:11.440 --> 28:15.760]  для всех вершин разность глубин левого и правого по деревьев
[28:15.760 --> 28:24.800]  здесь отличается максимум на 1. Вот. Хорошо. Значит, вот такое странное с неба взявшееся
[28:24.800 --> 28:31.480]  условие. Оказывается, что при нем глубина обязательно будет логарифмической. Это
[28:31.480 --> 28:38.040]  во-первых. Во-вторых, это свойство не очень сложно поддерживать при ответе на
[28:38.040 --> 28:42.440]  все вот эти запросы типа insert и erase. То есть нам нужно сделать две вещи. Нам
[28:42.440 --> 28:46.640]  нужно, во-первых, доказать, что в таком определении глубина будет небольшая,
[28:46.640 --> 28:51.400]  всегда логарифмическая на самом деле. Во-вторых, показать, как поддерживать вот эти
[28:51.400 --> 28:57.120]  вот условия про разность глубин детей при вставке и удалении вершин. Потому что,
[28:57.120 --> 29:01.160]  понятно, когда мы что-то вставляем, у меня глубины могут испортиться. Ну, если я вот
[29:01.160 --> 29:04.840]  здесь, например, девятку добавлю просто, обратно добавлю ее, тогда у меня вот для
[29:04.840 --> 29:08.000]  этой вершины что-то сломается, надо что-то делать, потому что это уже не корректно
[29:08.000 --> 29:15.160]  в L-дерево. Вот. Но надо понять, как с этим жить. Ну что, давайте для начала докажем,
[29:15.160 --> 29:25.680]  что L-дерево на N-вершинах имеет глубину от логарифма N.
[29:25.680 --> 29:43.040]  Доказательства. Давайте, так же, как мы уже когда-то делали, ведем обратную функцию и, наоборот,
[29:43.040 --> 29:48.720]  для каждого h, для каждой глубины h, посчитаем минимальное количество вершин в правильном
[29:48.720 --> 30:00.640]  овл-дереве глубины h. Значит, s от h – это минимальное количество вершин в овл-дереве глубины h.
[30:00.640 --> 30:16.560]  Глубины h. Так, ну, s0, я считаю, что это 0. Я считаю, что дерево глубины 0 – это пустое дерево без
[30:16.560 --> 30:21.320]  вершин. Пустое дерево является корректным овл-деревом, здесь нет вершин, поэтому оставляется 0.
[30:21.320 --> 30:31.640]  s от единицы – это 1, потому что просто одна вершина, тут пустое дерево, здесь просто дерево из одной
[30:31.640 --> 30:45.360]  вершины. Это корректный овл-дерево. У него глубина 1. Ну и вроде все хорошо. А дальше давайте построим
[30:45.360 --> 30:49.360]  какое-нибудь рекуррентное соотношение на то, как вот эти s растут с ростом h.
[30:49.360 --> 31:04.440]  Ну давайте нарисуем. Вот пусть у меня есть какой-то овл-дерево глубины h. У него есть какие-то дети –
[31:04.440 --> 31:15.120]  левая и правая. Ну, смотрите, если все дерево имеет глубину h, то у меня дети точно имеют глубину
[31:15.120 --> 31:22.120]  не больше, чем h-1. Ну потому что если здесь h, то здесь глубина, она на единичку поменьше, потому что
[31:22.120 --> 31:27.480]  у меня одна вершина отрезалась. Более того, хотя бы один из сыновей обязательно должен иметь
[31:27.480 --> 31:33.760]  глубину h-1. Потому что раз здесь глубина h, то есть есть какой-то путь длины h, после отрезания первой
[31:33.760 --> 31:39.680]  вершины у меня остается путь длины h-1 в поддереве. Поэтому хотя бы один сын глубины h-1 точно быть
[31:39.680 --> 31:47.560]  должен. Ну тогда у нас на самом деле есть понимание, к какой минимальной глубины должен быть другой сын.
[31:47.560 --> 31:59.040]  Какой? h-2. Потому что мы знаем, что глубины отличаются максимум на 1, значит здесь не может быть
[31:59.040 --> 32:05.600]  меньше, чем h-2, потому что иначе было бы некорректно овл-дерево. Все. Отсюда автоматически можно
[32:05.600 --> 32:11.560]  написать, что sh-то больше либо равно, на самом деле просто равно, потому что такую картинку можно
[32:11.560 --> 32:22.520]  всегда нарисовать, просто равно 1 плюс s от h-2 плюс s от h-1. Я всегда могу нарисовать, я всегда могу
[32:22.520 --> 32:28.120]  здесь нарисовать дерево глубины h-1, здесь дерево глубины h-2, правильный корректный вл-дереве,
[32:28.120 --> 32:37.880]  вот так вот их склеить, получится дерево глубины h. Ну вот, а что-то такое мы уже с вами видели. Да,
[32:37.880 --> 32:43.240]  линейные рекурренты, причем сумма двух предыдущих по факту здесь написана. Но они растет как чисто
[32:43.240 --> 32:49.160]  фиба начи. Давайте напишем несколько первых слагаемых, поэтому убедимся. Значит s-2 это 1
[32:49.160 --> 32:57.520]  плюс сумма двух предыдущих, то есть 2. s-3 это 1 плюс сумма двух предыдущих, то есть 4. Ну не
[32:57.520 --> 33:14.320]  совсем чисто фиба начи, но что-то похожее. Значит s-4 7, s-5 12, 20. Да, да, это видимо чисто
[33:14.320 --> 33:22.320]  фиба начи минус 1. Давайте вспомним, что f-0 это 0, f-1 это 1, а f-n это сумма двух предыдущих,
[33:22.320 --> 33:31.920]  чисто фиба начи. Вот, ну тогда видимо можно заметить, что s-h это... Так, сейчас, я порефлексирую
[33:31.920 --> 33:41.280]  секунду. Быстрее. Но это, не, мне все-таки хочется точно, ну как бы чтобы доказать,
[33:41.280 --> 33:45.240]  что они как-то соотносятся, мне нужно точную оценку, потом уже можно сказать, что они быстрее. Сейчас
[33:45.240 --> 33:52.600]  пол секунды. 0, 1, 1, 2, 3, 5, 5.
[33:52.600 --> 34:08.680]  Давайте ведем последовательность типа f-r равно s-h-1. Заметим, что f-r это число фиба начи. Заметим,
[34:08.680 --> 34:18.080]  что s-h растет не медленнее, чем какая-то показательная функция. Ну это сложно. Заметим,
[34:18.080 --> 34:26.760]  что? Надо доказать, откуда мы это заметим? Все, вот, короче, я утверждаю, что вот это вот будет
[34:26.760 --> 34:34.600]  решением нашей рекурренты. Вот. Значит, почему? Давайте докажем. Я утверждаю, что если у меня
[34:34.600 --> 34:43.720]  s-0, s-1 вот такие, s-h-t равно вот такому, то я утверждаю, что s-h-t это вот такое всегда. Но для
[34:43.720 --> 34:50.040]  любого h хотя бы ноль. Значит, ну, то есть, смотрите, мы знаем уже про s много чего, мы знаем два стартовых
[34:50.040 --> 34:54.320]  значений, мы знаем ее вооружение через два предыдущих. Давайте докажем индукции по h,
[34:54.320 --> 35:00.120]  чтобы выполнять такое соотношение, где f это число фиба начи. Значит, почему? Ну, давайте, давайте
[35:00.120 --> 35:07.080]  индукции. h равно 0, h равно 1. Вроде понятно, потому что h, когда h равно 0, 2 число фиба начи
[35:07.080 --> 35:19.800]  как раз 1, 1-1 будет, ну давайте, h равно 0, f2 это 1, 1-1 как раз будет 0, h равно 1, 3 число
[35:19.800 --> 35:27.200]  фиба начи это 2, 2-1 как раз будет 1. База сошлась, но переход тривиален. Что давайте я сотру.
[35:30.120 --> 35:42.680]  Если я знаю, что s-h-t это 1 плюс два предыдущих, дальше по предположению индукции расписываю вот
[35:42.680 --> 35:53.720]  эти две s-ки как f-ки. Значит, это будет f-h-t минус 1, это будет f-h плюс 1 минус 1. Две f-ки склеились
[35:53.720 --> 36:05.320]  в одну f-h плюс вторую и минус 1-ки сократились до минус 1-ки. Вот так прям супер точно. Все,
[36:05.320 --> 36:11.400]  ну а мораль такая, как бы это я формализм навел просто, мораль такая, что s растут так же быстро,
[36:11.400 --> 36:18.120]  как число фиба начи, ну там, на двойку сдвинутым индексом, неважно. Значит, они растут экспоненциально
[36:18.120 --> 36:23.040]  быстро. Мы помним, что n-ное число фиба начи это примерно phi в степени n, где phi это золотое
[36:23.040 --> 36:30.360]  сечение. На самом деле, просто экспоненциально быстро растет. То есть, можно написать, что s-h-t равно
[36:30.360 --> 36:34.920]  с точки зрения t-t просто phi в степени h, где phi это золотое сечение. Там 1, то, скорее всего,
[36:34.920 --> 36:43.320]  и пополам. Вот. Ну, на самом деле, мы знаем, что мы доказали исходное утверждение. Мы хотели
[36:43.320 --> 36:50.000]  доказать, что максимальная глубина в дереве на n-вершинах, она логарифмическая. Но если мы
[36:50.000 --> 36:55.600]  доказали, что чтобы в дереве была глубина h, в ней должно быть хотя бы столько вершин, значит,
[36:55.600 --> 37:01.280]  наоборот, если у меня n-вершин, то глубина максимум логарифм по основанию phi от n. То есть,
[37:01.280 --> 37:15.920]  отсюда следует, что глубина дерева на n-вершинах не больше, чем o от логарифма n, по основанию phi
[37:15.920 --> 37:21.400]  уже напишу, растут экспоненты по основанию phi, то здесь логарифм будет по основанию phi. То есть,
[37:21.400 --> 37:28.720]  если минимальный размер дерева по глубине растет экспоненциально, то глубина по размеру,
[37:28.720 --> 37:37.640]  наоборот, логарифмическая. Потому что это обратная функция. Вот. Доказали? Норм?
[37:37.640 --> 37:50.800]  Хорошо. Так, ну теперь нам осталось научиться как-то это поддерживать. Как-то понять, как можно в
[37:50.800 --> 37:58.720]  наивном дереве поиска так все подкрутить, чтобы у меня всегда было верно вот это условие про
[37:58.720 --> 38:05.200]  глубины двух детей, что левый и правый по дереву отличается максимум на единичку по глубине. Хорошо.
[38:05.200 --> 38:10.400]  Значит, для этого мне нужно будет такая простая вспомогательная процедура, которая называется
[38:10.400 --> 38:29.400]  вращение. Давайте картинку нарисуем. Представьте себе такое дерево. Вот там сверху что-то находится,
[38:29.400 --> 38:33.320]  там где-то сверху корень, вот как-то, грубо говоря, мы дошли там, может он где-то там,
[38:33.320 --> 38:42.120]  короче, как-то от корня дошли до вершины П. Пусть у него есть сын Х. Что такое вращение вдоль этого
[38:42.120 --> 38:50.120]  ребра? Давайте еще вот эти поддеревья как-нибудь назову, А, Б, С. Тогда вращение это следующий
[38:50.120 --> 38:54.760]  прикол. Вот представьте буквально, что у вас здесь стоят какие-то шарнирщики, и вы берете,
[38:54.760 --> 38:58.160]  и вот это вот ребро вот так вот прокручиваете. Вот в направлении стрелки вот так вот берете
[38:58.160 --> 39:06.360]  и поворачиваете. В частности, у вас Х поднимется наверх, а П спустится вниз. И тогда мы на самом
[39:06.360 --> 39:11.480]  деле получаем следующее дерево. У нас Х становится новым корнем этого всего поддерева, П переходит
[39:11.480 --> 39:16.680]  вправо, то есть вот это вот ребро я прокрутил, и оно стало вот таким вот, а оставшиеся поддеревья
[39:16.680 --> 39:31.480]  подвешиваются вот единственным естественным образом. Здесь А, здесь Б, здесь С. Вот,
[39:31.480 --> 39:42.600]  что поменялось? Ну, Х стало корнем, Х поднялось на единичку вверх. Ну, там мы повозимся еще с этим.
[39:42.600 --> 39:46.480]  Когда будем применять, да, здесь что-то происходит за глубиной, то есть на самом деле в
[39:46.480 --> 39:51.240]  каком-то смысле, смотрите, если у меня А было очень глубокое, то я чуть-чуть его поднял. То есть я
[39:51.240 --> 39:57.640]  поднял головину А на единичку, ну и А тоже на один соответственно поднялось. Ну, там С как-то опустилось,
[39:57.640 --> 40:02.360]  но неважно, будем еще разбираться с этим. Вот, но главное здесь, что надо понять, это то, что у меня
[40:02.360 --> 40:07.000]  сохраняются все инварианты. Что если это было деревом поиска, то это тоже остается деревом поиска.
[40:07.000 --> 40:14.200]  Значит, надо просто помедитировать, понять почему это так. Что все неравенства у меня сохраняются.
[40:14.200 --> 40:19.760]  Ну, например, смотрите, что такое В. В лежала вправее Ха, но левее П. То есть он должен быть больше
[40:19.760 --> 40:26.860]  чем Х но меньше чем П. Где оно здесь? Оно вправее Ха, левее П. Больше Ха, меньше чем П. Х лежала
[40:26.860 --> 40:32.680]  левее П, то есть Х меньше чем П. Здесь X левее чем П, Х меньше чем П, все хорошо. Короче, если вы на все
[40:32.680 --> 40:36.500]  объекты посмотрите, посмотрите как они здесь относились, как highlighter здесь, то у drugs
[40:36.500 --> 40:41.760]  Enlightenment останутся такими же, как были здесь вот. Поэтому, значит, инвариант дерева поиска
[40:41.760 --> 40:54.480]  сохраняется. Давайте. Какое? Авэль строится. Ну можно Зейн-Луген построить. Быстрее, наверное,
[40:54.480 --> 41:02.960]  нельзя, потому что сортировка нужна. Да, ну Зейн-Луген можно. Так, ладно, давайте это сотру уже. Вот.
[41:02.960 --> 41:10.240]  Значит, это было вращение направо. Ну, симметрично можно рисовать вращение налево. Давайте здесь
[41:10.240 --> 41:19.360]  попробуем меститься. Представьте, что у вас была п, у него еще все-таки. Была вершина п, у него был
[41:19.360 --> 41:31.840]  правый сын х. Значит, что такое вращение влево? Ну, то же самое. Представьте, что здесь шарнирчик. Вы вот
[41:31.840 --> 41:37.160]  так вот вращаете его по направлению стрелки. У вас х поднимается, становится новым корнем этого
[41:37.160 --> 41:42.120]  дерева, п спускается влево, ну и все под деревья подвешиваются единственным возможным способом.
[41:42.120 --> 41:50.040]  Вот. Значит, это правая вращение. Наоборот, левая, да? У меня проблемы с ориентацией. Ну, как бы,
[41:50.040 --> 41:58.480]  короче, что вращение левого ребра? Это вращение как бы правого ребра налево. Неважно. Вот. Ну,
[41:58.480 --> 42:05.920]  тоже можно заметить, что все неранее сохраняются. Если то было деревом поиска, то это тоже остается.
[42:05.920 --> 42:23.680]  Это можно поверить? Хорошо. Ну ладно. Тогда давайте теперь разберемся, как с помощью этих вращений
[42:23.680 --> 42:31.680]  мы можем добиться того, чтобы у меня всегда было вл дерева. Ну вот, первый шаг такой. Там,
[42:32.040 --> 42:37.840]  пусть пришла операция инцет или рейс. Давайте мы сначала ее сделаем так, как выполняла бы эту
[42:37.840 --> 42:44.640]  операцию обычная наивная дерево поиска. То есть там дойдем докуда-то, подвесим или что-то удалим,
[42:44.640 --> 42:51.000]  ну кроме того же самое, что было раньше. Значит, теперь у меня что-то может сломаться. А именно,
[42:51.000 --> 42:59.160]  давайте я обозначу, что вот если у меня была вершина В, у нее были под деревья LR, давайте я
[42:59.160 --> 43:07.520]  через дельту от V обозначу h левая минус h правая. Вот. Та самая разность между глубинами детей.
[43:07.520 --> 43:19.880]  hL-hR. Правильные значения для дельты это минус 1, 0 и 1. Вот если дельта всегда в
[43:19.880 --> 43:26.720]  этом диапазоне, то у меня все хорошо. Проблема, когда она вылезает из этого диапазона. Можно
[43:26.720 --> 43:32.400]  легко заметить, что когда мы делаем инцет или рейс, у меня на самом деле дельта изменяется
[43:32.400 --> 43:38.360]  максимум на единичку. Она может выпасть из этого диапазона только либо на минус 1 сюда,
[43:38.360 --> 43:43.400]  либо на плюс 1 сюда. Ну скажем, что в инцерте происходит. По факту вы просто идете по пути и
[43:43.400 --> 43:48.880]  к какому-то листу довешиваете еще одну вершину. Ну у нее дельта максимум на 1 увеличилась. Из-за
[43:48.880 --> 43:52.840]  того, что у вас глубина одного из сыновей увеличилась на 1, у вас дельта здесь увеличилась
[43:52.840 --> 44:00.240]  максимум на 1 или там уменьшилась на 1. То же самое с рейсом. Там была какая-то такая картинка,
[44:00.240 --> 44:06.360]  вы вместо m подвесили вот этого правого сына. Ну тогда здесь глубина уменьшилась на 1, потому
[44:06.360 --> 44:11.840]  что я высек m и на его место подвесил правое под дерево. Глубина уменьшилась на 1, ну значит дельты
[44:11.840 --> 44:19.640]  все тоже изменились максимум на 1. Это когда я вместо вершины высекаю m и подвесил правое
[44:19.640 --> 44:27.000]  под дерево. Это и рейс. Поэтому мне достаточно починить ситуации, когда дельта это плюс или
[44:27.000 --> 44:39.560]  минус 2. Плохие ситуации. Дельта равно плюс-минус 2. Тройка она никогда не будет, потому что дельта
[44:39.560 --> 44:44.320]  всегда изменяется максимум на 1. Если у меня было корректное well дерево, потом я одну вершину
[44:44.320 --> 44:54.760]  вставил или удалил, теперь неправильно дельта только плюс-минус 2. Мы все будем вращать. Тут будет
[44:54.760 --> 45:01.680]  много вращений на самом деле. Давайте мы из симметрии, поскольку у меня, ну там можно было
[45:01.680 --> 45:06.160]  бы всегда поменять местами l и r, и собственно у меня вот эти штуки тоже симметричны, левые правые
[45:06.160 --> 45:13.000]  вращения. Давайте рассмотрим только случай, когда дельта от какой-то вершины равно минус 2. Давайте
[45:13.000 --> 45:21.760]  поймем, что делать, если мы нашли какую-то вершину с дельты равно минус 2. Что это значит? Значит,
[45:21.760 --> 45:26.240]  что скажем, в ее дереве что-то такое произошло. Например, из левого под дерева кто-то удалился,
[45:26.240 --> 45:31.920]  что глубина левого под дерева уменьшилась, а дельта и так была равна минус 1, стала минус 2.
[45:31.920 --> 45:43.400]  Ну короче, в общем, дельта испортилась. Вот это а. Вот было какое-то левое под дерево, было какое-то
[45:43.400 --> 45:51.040]  правое под дерево, причем правое оно именно сильно глубже, чем левое, хотя бы на 2 глубже,
[45:51.040 --> 45:55.840]  чем левое. На картинка какая-то такая, у меня перекос вправо, левое минус правое минус 2,
[45:55.840 --> 46:05.520]  у меня перекос вправо. Давайте разберем какой-нибудь случай, чему равно дельта от
[46:05.520 --> 46:17.280]  b. Например, пусть дельта от b равно 0. Нам придется повращать. Смотрите, пусть здесь глубина была h,
[46:17.280 --> 46:28.840]  то есть глубина вот этого всего под дерева это h. Тогда я утверждаю, что здесь h-1, здесь h-3. Ну тут h-1,
[46:28.840 --> 46:33.640]  потому что оно не больше, чем h-1, но должно быть хотя бы h-1, потому что должен быть
[46:33.640 --> 46:39.360]  поделенный h. Поэтому здесь обязательно h-1. Здесь на 2 меньше, здесь h-3. И здесь,
[46:39.360 --> 46:44.160]  если здесь h-1 и дельта здесь нулевая, то здесь глубина h-2, h-2.
[46:44.160 --> 46:51.280]  Давайте тогда, ну смотрите, в h у меня проблема. Я знаю, что в a у меня дельта равно минус 2,
[46:51.280 --> 46:56.520]  мне надо что-то здесь починить. Давайте вот так вот провращаем. Давайте вызовем вращение вот этого
[46:56.520 --> 47:09.480]  ребра a, b. Посмотрим, что произойдет с глубинами. Так, давайте я их опять как-то назову a, b, c. Ну я
[47:09.480 --> 47:20.800]  просто пересовываю вот эту картинку, вращение вот этого вот правого ребра налево. И выставляю
[47:20.800 --> 47:29.840]  обратно все высоты. Значит у a большого была глубина h-3, у b h-2, у c h-2. Значит какая теперь
[47:29.840 --> 47:37.000]  глубина у a? Ну раз у него 2 сына h-3, h-2, то здесь глубина h-1, потому что нужно выбрать максимум
[47:37.000 --> 47:47.320]  и добавить 1. Здесь h-1, h-2, поэтому здесь глубина h. И более того, я починил все дельты в этом поддереве,
[47:47.320 --> 47:54.920]  потому что для этой вершины дельта стала равна минус 1, вот эти отличаются на 1. И для этой вершины
[47:54.920 --> 48:02.400]  дельта стала равна 1, потому что это отличается от этого на 1. Значит я починил дельту в этой
[48:02.400 --> 48:25.600]  точке. Правда? Ну вот. Это уже хорошо. Еще раз? Не, мы будем наверх подниматься. Чуть позже скажу.
[48:25.600 --> 48:30.000]  Значит давайте сначала все случаи здесь разберем. Это было дельта равно нулю справа, теперь пусть
[48:30.000 --> 48:43.360]  будет дельта от b равно минус 1. Ну там на самом деле то же самое будет. Так, тут h, здесь по-прежнему
[48:43.360 --> 48:51.680]  h-3, h-1. И раз дельта от b равно минус 1, то есть правый глубже на 1, поэтому здесь вот такие вот глубины.
[48:51.680 --> 49:00.160]  Опять делаю то же самое вращение того же самого ребра, и даже при этом предположении,
[49:00.160 --> 49:01.880]  что дельта равно минус 1, у меня все равно все получится.
[49:22.280 --> 49:28.920]  Ну вроде реально получилось. Я здесь аккуратно проставил все высоты. После поворота я тоже эти
[49:28.920 --> 49:33.680]  высоты все написал. Здесь поскольку у меня a большое, b большое было глубиной h-3, они остались,
[49:33.680 --> 49:39.520]  c большое было глубиной h-2. Дальше я считаю глубины a маленького. a маленького у него два сына глубины
[49:39.520 --> 49:47.520]  h-3, поэтому здесь h-2. b у него два сына h-2, h-2, поэтому здесь глубина h-1. Все, получается я опять,
[49:47.520 --> 49:51.240]  я в этом подделье починил все дельты. И здесь, и здесь дельта стала нулевой, все хорошо.
[49:51.240 --> 49:56.800]  Остался последний противный случай, когда у меня дельта от b равно 1.
[49:56.800 --> 50:12.880]  Вы имеете в виду как насчитывать правильно значение дельты?
[50:12.880 --> 50:24.280]  Ну смотрите, не по каждой, потому что вот в этих трех, вот в этих деревьях ничего не меняется.
[50:24.280 --> 50:29.360]  У нас дельта, ну как бы у нас здесь высоты не поменялись, поэтому и дельты там не поменялись.
[50:29.360 --> 50:33.720]  У нас дельты меняются только в a и b, но если мы знаем ашки в каждой точке,
[50:33.720 --> 50:36.040]  то мы и дельты можем за единицу посчитать.
[50:36.040 --> 50:44.440]  Так, ну последний противный случай, когда дельта от b равно единице.
[50:44.440 --> 50:48.680]  Значит смотрите, если дельта от b равно единице, то у меня перекос влево идет в этом поддельве,
[50:48.680 --> 50:54.120]  в поддельве b. Причем оно глубина 1 побольше. Тут есть какая-то высина c.
[50:54.120 --> 51:12.000]  Вот, значит тогда тут придется сделать два вращения. Значит сначала вот это вот первое,
[51:12.000 --> 51:22.120]  потом вот это второе. Если их аккуратненько произвести, то в конце получится такая картина.
[51:22.360 --> 51:42.840]  Здесь будет c, оно туда уходит. И здесь будет b. Вот, значит я утверждаю, что если сделать два таких
[51:42.840 --> 51:46.840]  вращения, вот этого ребра вправо, вот этого ребра влево, то получится ровно такая картинка.
[51:46.840 --> 51:51.600]  Ну потому что здесь c вылезет в корень вот этого поддельма, c будет сверху,
[51:51.600 --> 51:56.720]  потом оно поднимется еще в корень, вытеснет a, а спутится влево. Ну как раз c в корне,
[51:56.720 --> 52:01.400]  а слева b справа. Ну и под деревья как-то вот эти a, b, c большие тоже как-то подвесились.
[52:01.400 --> 52:09.040]  Вот, давайте опять с высотами разбираться. Если здесь была h, то по-прежнему слева h-3,
[52:09.040 --> 52:15.000]  справа h-1, потому что у меня перекос вправо на 2. Значит тут h-1. Дальше, дельта от b равно единице,
[52:15.160 --> 52:25.280]  значит у меня максимум достигается слева h-2, а справа на 1 меньше h-3. Вот, ну у b и c глубины
[52:25.280 --> 52:30.280]  непонятно какие, но смотрите, если у c все было хорошо с дельтой, если у утверждения все было
[52:30.280 --> 52:36.760]  хорошо с дельтой, она была плюс-минус 1 или 0, тогда обе вот эти глубины обязательно h-3 или h-4.
[52:36.760 --> 52:43.760]  Причем хотя бы одна из них обязательно h-3, чтобы здесь была глубина h-2.
[52:43.760 --> 52:58.440]  Так, хорошо, здесь h-3, здесь h-3 или h-4, здесь h-3 или h-4, здесь h-3. Ну тогда у этой h-ки глубина
[52:58.440 --> 53:02.880]  обязательно h-2, потому что неважно какая глубина здесь, максимально из них плюс-один,
[53:02.880 --> 53:08.320]  все равно h-2. Тут тоже самая глубина будет h-2, отсюда придет и здесь будет глубина h-1.
[53:08.320 --> 53:17.320]  И опять победа, у меня все дельты починились. У меня здесь дельты отличаются максимум на единицу,
[53:17.320 --> 53:22.600]  в худшем случае здесь h-3, здесь h-4, здесь то же самое, максимум на единицу они отличаются,
[53:22.600 --> 53:27.320]  для c вообще эти глубины равны обоих сыновей, поэтому здесь будет дельта нулевая.
[53:27.320 --> 53:34.000]  Вот, ну можно проверить, что скажем, одного вот такого поворота мне бы не хватило,
[53:34.000 --> 53:37.760]  то есть мне реально здесь надо два поворота сделать, одного поворота вот этого ребра a b
[53:37.760 --> 53:41.640]  мне бы уже не хватило в этом случае, поэтому здесь придется чуть больше повозиться.
[53:41.640 --> 53:51.680]  Смотрите, потому что у c h-2, вот эта вершина h-2, откуда она берется, значит,
[53:51.680 --> 53:58.360]  что в каком-то из детей хотя бы h-3. Ну чтобы здесь было h-2, мне нужно построить путь глубины
[53:58.360 --> 54:04.280]  h-3 в одном из детей и плюс-один сделать, поэтому хотя бы где-то h-3. Но если хотя бы где-то h-3,
[54:04.280 --> 54:08.560]  а здесь дельта была правильная, то есть я считаю, что у меня вот в этом по дереве все дельты были
[54:08.560 --> 54:13.040]  правильные, плюс-минус один или ноль, кроме этой вершины, значит здесь дельта была плюс-минус
[54:13.040 --> 54:19.880]  один или ноль, но если один из них h-3, то какое может быть другое? Ну тоже либо h-3, либо h-4,
[54:19.880 --> 54:25.840]  потому что нельзя быть больше, чем h-3, вот, и нельзя быть меньше, чем h-4, потому что они отличаются
[54:25.840 --> 54:33.280]  максимумом на единицу. Вот, и того опять все равно победа я смог так или иначе сделать так,
[54:33.280 --> 54:44.560]  чтобы все дельты у меня починились, стали маленькими по модулю. Да, понятно? Все, значит мы научились
[54:44.560 --> 54:49.920]  чинить дельту в случае, если она была минус двойкой, мы разобрали три разных случая, сказали, что нужно
[54:49.920 --> 54:54.760]  повернуть так, чтобы все починить. Причем, заметьте, вращение всегда от одного, здесь вообще одно вращение,
[54:54.760 --> 55:00.240]  но здесь два вращения, не очень страшно. Аналогично абсолютно симметричная картинка в случае дельты
[55:00.240 --> 55:06.200]  равно двойке, там, наоборот, перекос был влево, ну, я буду вращать там какое-то левое ребро, чтобы все починить.
[55:06.200 --> 55:18.160]  Еще раз? Только один сын, но смотрите, если у него дельта равно минус двойке, то это обязательно правый сын.
[55:18.160 --> 55:27.000]  И, окей, это не страшно, а большое может быть пустым, это нормально, тогда оно просто пустое,
[55:27.040 --> 55:35.680]  и везде h-3 равно нулю, и это ничему не мешает. Вот, все, значит мы научились чинить дельты равные плюс-минус двойке.
[55:35.680 --> 55:47.000]  Ну а дальше, смотрите, как, да? Хорошо вопрос. Ну, примерно так же, как можно хранить, скажем,
[55:47.000 --> 55:51.840]  неявное дерево отрезков. У нас есть вершина, она ссылается на левого сына, на правого сына.
[55:51.840 --> 55:58.160]  Она хранит указатели на левого сына, на правого сына. Ну и информацию о том, что лежит в этой вершине о числе х.
[55:58.160 --> 56:05.400]  Вот, ну, видимо, нужны еще вот эти вот технические вспомогательные штуки, типа какая h в этой вершине и
[56:05.400 --> 56:12.040]  какая дельта в этой вершине. Вот, чтобы их потом так можно было хорошо пересчитывать и понимать,
[56:12.040 --> 56:18.800]  какой из там трех случаев у нас реализовался. Но основное это ссылки на левого правого сына и значения,
[56:18.800 --> 56:31.600]  остальное техническое. На все листья? На листья не нужны ссылки. Сейчас вот я как раз это скажу.
[56:31.600 --> 56:36.760]  Значит, смотрите, мы научились чинить одну вершину. Теперь как починить все дерево? Вот представьте,
[56:36.760 --> 56:42.680]  у вас была корректная вельдерева, вы как-то его испортили, что-то там к нему подвесив, скажем,
[56:42.680 --> 56:47.920]  ну или что-то удалив. Например, подвесили вершинку с помощью инсерта. Тогда как теперь починить?
[56:47.920 --> 56:53.520]  Ну, смотрите, сломаться мог только вот этот вот путь. Путь от той вершины, которую вы сейчас
[56:53.520 --> 56:59.440]  там добавили или удалили, и только на этом пути что-то поменялось в поддеревьях, могли поменяться
[56:59.440 --> 57:03.800]  глубины поддеревьев. Тогда давайте сделаем так, давайте просто по этому пути пойдем снизу вверх и
[57:03.800 --> 57:10.480]  будем чинить все дельты, пока не починится. Вот иду снизу вверх, вижу плохую дельту, то есть
[57:10.480 --> 57:15.240]  равную двойке или минус двойке, ну поверну там как надо, оно починится все. То есть я иду снизу
[57:15.240 --> 57:20.840]  вверх, чиню все, что плохо. Когда я чиню, у меня все это по дереву сразу становится хорошим, в нем все
[57:20.840 --> 57:26.640]  дельты становятся нужными. Поднимаюсь наверх, если тут плохо, опять что-то вращаю, от единицы
[57:26.640 --> 57:30.520]  вращения делаю, у меня опять все по дереву чинится, ну и так далее. Поднимаюсь наверх,
[57:30.520 --> 57:34.840]  каждый раз, когда встречаю дельту равную плюс двойке или минус двойке, делаю вращение и чиню.
[57:34.840 --> 57:43.400]  Поэтому, окей, поэтому надо хранить еще ссылку на родителя, видимо, чтобы уметь подниматься вверх,
[57:43.400 --> 57:47.040]  то есть я, скажем, вот эту вершину добавил, теперь надо подняться к родителю и понять,
[57:47.040 --> 57:54.320]  а вот у него дельта какая, плохая или неплохая, если плохая, надо что-то поворочать. То есть после
[57:54.320 --> 58:00.760]  того, как я сделал insert или сделал erase, я от вот той вершины, в которой что-то поменялось, просто
[58:00.760 --> 58:06.440]  поднимаюсь наверх вплоть до корня и каждый раз, когда встречаю плохую дельту, выполняю повороты так,
[58:06.440 --> 58:10.840]  чтобы все починилось. В итоге я поднялся до корня, все починил, у меня все по дереву стало правильным
[58:10.840 --> 58:21.960]  овл-деревом и, значит, у него глубиналогарифмическая победа. Кайф. Почему что? Ну, давайте подумаем
[58:21.960 --> 58:28.160]  вот на этой картинке, что такое вращение. Да, по факту мне надо свопнуть какие-то указатели,
[58:28.160 --> 58:34.600]  потому что раньше, ну, давайте, что такое дети p, дети p, левый сын был a, правый сын был x, теперь надо
[58:34.600 --> 58:39.000]  у него левый сына ставить, а в правый, конечно, правый сын написать b, это там при присвоении указателя.
[58:39.000 --> 58:45.680]  Что такое дети x, а? Слева был b, справа c. Надо теперь b в качестве правого сына подвесить,
[58:45.680 --> 58:51.960]  а, наоборот, надо b удалить, надо вместо b поставить p, c оставить на месте. Опять перенаправление
[58:51.960 --> 58:57.080]  указателя. Раньше показывали на b, теперь надо показывать на p. Все. То есть по факту все,
[58:57.080 --> 59:01.680]  что мы делаем, это перенаправление каких-то стрелочек. Это, конечно, вот единица, потому что
[59:01.680 --> 59:11.280]  здесь объектов от единицы. Все. А в L дерево кончилось. Ну, то есть поддерживая это свойство,
[59:11.280 --> 59:16.000]  мы можем на все запросы отвечать за логарифм. Да.
[59:16.000 --> 59:42.080]  Вы придумали новую структуру. Давайте обсудим. Я думаю, что там у вас что-то скорее всего не
[59:42.080 --> 59:47.640]  работает. Иначе как раз не было бы так сложно. Так, есть вопросы еще, Павел?
[59:47.640 --> 59:55.160]  Окей, давайте тогда еще одно дерево посмотрим. У нас в ближайшие три лекции будет обзор просто
[59:55.160 --> 01:00:02.080]  разных возможностей реализации как раз этого самого дерева поиска. Их бывает много разных,
[01:00:02.080 --> 01:00:06.760]  и они как раз полезны в разных обстоятельствах. Про это еще поговорим, когда какой лучше использовать.
[01:00:06.760 --> 01:00:25.480]  Сейчас давайте посмотрим сплей дерева. Так. Ну, давайте тоже определение, наверное, дадим.
[01:00:25.480 --> 01:00:48.600]  Сплей дерева это тоже бинарное дерево поиска. Такое что? Элемент, к которому последним приходил
[01:00:48.600 --> 01:00:53.120]  запрос, то есть, элемент, который мы последним запрашивали, находится в корне дерева.
[01:00:53.120 --> 01:01:22.760]  Последний в плане, ну, типа вот в каждом моменте времени. То есть, у меня пришел запрос, скажем,
[01:01:22.760 --> 01:01:28.200]  find x. Так, вот после этого запроса x должен вынестся в корень, подняться в корень дерева.
[01:01:28.200 --> 01:01:35.120]  Пришел запрос insert y, после этого запроса y в корне. Пришел запрос Eraser z. Ну, там какой-то
[01:01:35.120 --> 01:01:37.960]  элемент рядом z, он должен подняться в корень. То есть, я вот z удаляю,
[01:01:37.960 --> 01:01:44.040]  на его место стоит кто-то m, и я этот m поднимаю в корень. Вот тот элемент, который последним вот
[01:01:44.040 --> 01:01:50.200]  после очередного запроса потрогался в дереве, добавился или нашелся в дереве, я его должен
[01:01:50.200 --> 01:01:52.200]  поднять в корень. После каждого запроса
[01:01:52.200 --> 01:01:54.200]  элемент должен быть в корне.
[01:01:56.200 --> 01:01:58.200]  Вот.
[01:02:02.200 --> 01:02:04.200]  Да, мы ровно так будем делать.
[01:02:06.200 --> 01:02:08.200]  Мы сейчас каждый элемент с помощью
[01:02:08.200 --> 01:02:10.200]  поворотов таких научимся поднимать
[01:02:10.200 --> 01:02:12.200]  в корень.
[01:02:12.200 --> 01:02:14.200]  Для этого есть три
[01:02:14.200 --> 01:02:16.200]  вспомогательные процедуры, которые
[01:02:16.200 --> 01:02:18.200]  называются очень глупо, но как-то вот так
[01:02:18.200 --> 01:02:20.200]  привычно, типа, исторически сложилось,
[01:02:20.200 --> 01:02:22.200]  не спрашивайте.
[01:02:22.200 --> 01:02:24.200]  Есть процедура зиг,
[01:02:24.200 --> 01:02:26.200]  которая работает
[01:02:26.200 --> 01:02:28.200]  для х,
[01:02:28.200 --> 01:02:30.200]  которая работает в случае, если х
[01:02:30.200 --> 01:02:32.200]  это корень корня. Извините,
[01:02:32.200 --> 01:02:34.200]  сын корня. Сын корня.
[01:02:36.200 --> 01:02:38.200]  х это сын корня.
[01:02:40.200 --> 01:02:42.200]  И это просто правильный поворот
[01:02:42.200 --> 01:02:44.200]  в правильную сторону.
[01:02:44.200 --> 01:02:46.200]  Если х был левым сыном корня,
[01:02:46.200 --> 01:02:48.200]  то это просто вот такой вот правый поворот,
[01:02:48.200 --> 01:02:50.200]  в результате которого х становится
[01:02:50.200 --> 01:02:52.200]  новым корнем. Ну, мы рисовали уже такие
[01:02:52.200 --> 01:02:54.200]  повороты, у меня как раз шарничек вращается,
[01:02:54.200 --> 01:02:56.200]  х поднимается наверх, а становится
[01:02:56.200 --> 01:02:58.200]  новым корнем. Значит, это случай,
[01:02:58.200 --> 01:03:00.200]  если х был левым сыном. В случае,
[01:03:00.200 --> 01:03:02.200]  если х был правым сыном корня,
[01:03:02.200 --> 01:03:04.200]  то все аналогично, только вращение идет
[01:03:04.200 --> 01:03:06.200]  наоборот направо.
[01:03:06.200 --> 01:03:08.200]  Сорри, налево, да, и х поднимается
[01:03:08.200 --> 01:03:10.200]  вверх.
[01:03:12.200 --> 01:03:14.200]  Значит, это зиг, когда у меня
[01:03:14.200 --> 01:03:16.200]  х был сыном корня.
[01:03:16.200 --> 01:03:18.200]  Теперь зиг-зиг.
[01:03:20.200 --> 01:03:22.200]  Опять для вершины х.
[01:03:22.200 --> 01:03:24.200]  Это когда х уже
[01:03:24.200 --> 01:03:26.200]  не сын корня, то есть у него
[01:03:26.200 --> 01:03:28.200]  есть хотя бы два предка, есть
[01:03:28.200 --> 01:03:30.200]  родитель и есть дедушка.
[01:03:30.200 --> 01:03:32.200]  И зиг-зиг работает в том случае,
[01:03:32.200 --> 01:03:34.200]  когда родитель и дедушка находятся
[01:03:34.200 --> 01:03:36.200]  по одну сторону
[01:03:36.200 --> 01:03:38.200]  от своих родителей.
[01:03:38.200 --> 01:03:40.200]  Ну, вот такая картинка,
[01:03:40.200 --> 01:03:42.200]  у меня есть дедушка G,
[01:03:42.200 --> 01:03:44.200]  у меня есть родитель P,
[01:03:44.200 --> 01:03:46.200]  у меня есть вершина Х.
[01:03:46.200 --> 01:03:48.200]  Вот они именно что по
[01:03:48.200 --> 01:03:50.200]  одну сторону, они оба либо влево,
[01:03:50.200 --> 01:03:52.200]  либо вправо, картинка будет симметрична.
[01:04:02.200 --> 01:04:04.200]  Значит, тогда здесь вращение такое,
[01:04:04.200 --> 01:04:06.200]  сначала вот это вот ребро, потом
[01:04:06.200 --> 01:04:08.200]  вот это вот.
[01:04:12.200 --> 01:04:14.200]  Так.
[01:04:16.200 --> 01:04:18.200]  После первого у меня
[01:04:18.200 --> 01:04:20.200]  P станет корнем,
[01:04:20.200 --> 01:04:22.200]  после второго х станет
[01:04:22.200 --> 01:04:24.200]  корнем, P станет его правым сыном.
[01:04:24.200 --> 01:04:26.200]  А здесь останется G справа.
[01:04:32.200 --> 01:04:34.200]  Ну опять, мы все эти процедуры
[01:04:34.200 --> 01:04:36.200]  нацелены на то, чтобы х, заданный,
[01:04:36.200 --> 01:04:38.200]  поднимать все выше и выше.
[01:04:38.200 --> 01:04:40.200]  Вот сейчас мы подняли его сразу на два уровня
[01:04:40.200 --> 01:04:42.200]  вверх. Мы поменяли его с родителем
[01:04:42.200 --> 01:04:44.200]  и с дедушкой, мы сразу его на
[01:04:44.200 --> 01:04:46.200]  две единицы вверх подняли.
[01:04:48.200 --> 01:04:50.200]  Так, значит, это зиг-зиг, но остался зиг-заг.
[01:04:50.200 --> 01:04:52.200]  Это когда наоборот
[01:04:52.200 --> 01:04:54.200]  у меня, ну вот как бы
[01:04:54.200 --> 01:04:56.200]  P и х
[01:04:56.200 --> 01:04:58.200]  по разные стороны от своих родителей.
[01:04:58.200 --> 01:05:00.200]  То есть здесь было налево-налево, сейчас
[01:05:00.200 --> 01:05:02.200]  будет там налево-направо, например.
[01:05:02.200 --> 01:05:04.200]  Значит, зиг-заг
[01:05:06.200 --> 01:05:08.200]  от х.
[01:05:08.200 --> 01:05:10.200]  А это случай, когда
[01:05:10.200 --> 01:05:12.200]  P и х находятся по разные
[01:05:12.200 --> 01:05:14.200]  стороны от своих родителей.
[01:05:14.200 --> 01:05:16.200]  Здесь были по одну, оба влево, или оба вправо,
[01:05:16.200 --> 01:05:18.200]  картинка была бы симметричная. Здесь
[01:05:18.200 --> 01:05:20.200]  скажем налево-направо.
[01:05:26.200 --> 01:05:28.200]  Так, ну здесь тоже.
[01:05:32.200 --> 01:05:34.200]  Здесь снизу, да, наоборот.
[01:05:34.200 --> 01:05:36.200]  Здесь сначала вот это, потом вот это.
[01:05:38.200 --> 01:05:40.200]  Так.
[01:05:54.200 --> 01:05:56.200]  Цель та же самая. Я х поднимаю вверх
[01:05:56.200 --> 01:05:58.200]  ближе к корню, опять на два уровня вверх поднял.
[01:06:00.200 --> 01:06:02.200]  Вот, значит, это три вспомогательные
[01:06:02.200 --> 01:06:04.200]  процедуры, которые у меня используются.
[01:06:04.200 --> 01:06:06.200]  Значит, они используются в
[01:06:06.200 --> 01:06:08.200]  одной большой процедуре сплей.
[01:06:08.200 --> 01:06:10.200]  Сплей от х.
[01:06:10.200 --> 01:06:12.200]  Это комбинация
[01:06:14.200 --> 01:06:16.200]  вот этих самых зиг-зигов, зиг-загов и,
[01:06:16.200 --> 01:06:18.200]  возможно, одного зига.
[01:06:18.200 --> 01:06:20.200]  Значит,
[01:06:20.200 --> 01:06:22.200]  зиг-зиг
[01:06:22.200 --> 01:06:24.200]  и зиг-заг.
[01:06:24.200 --> 01:06:26.200]  Комбинация. Ну, в общем, как надо,
[01:06:26.200 --> 01:06:28.200]  какие надо операции, такие и делаем.
[01:06:28.200 --> 01:06:30.200]  То есть смотрим на х родителя и дедушку,
[01:06:30.200 --> 01:06:32.200]  если не по одну сторону запускаем зиг-зиг,
[01:06:32.200 --> 01:06:34.200]  иначе, если по-разному, запускаем зиг-заг.
[01:06:34.200 --> 01:06:36.200]  И в конце, возможно, максимум один зиг.
[01:06:36.200 --> 01:06:38.200]  В случае, если вот
[01:06:38.200 --> 01:06:40.200]  после этих операций у меня х не корень,
[01:06:40.200 --> 01:06:42.200]  возможно, нужно сделать еще один зиг,
[01:06:42.200 --> 01:06:44.200]  и он поднимется в корень.
[01:06:44.200 --> 01:06:46.200]  Да?
[01:06:46.200 --> 01:06:48.200]  Вот это сплей. Он поднимает
[01:06:48.200 --> 01:06:50.200]  х в корень с помощью вот этих странных операций.
[01:06:52.200 --> 01:06:54.200]  Вот.
[01:06:54.200 --> 01:06:56.200]  Ну, извините, пожалуйста.
[01:06:56.200 --> 01:06:58.200]  Вот оно так...
[01:06:58.200 --> 01:07:00.200]  Я сам клинжую.
[01:07:04.200 --> 01:07:06.200]  Вот.
[01:07:06.200 --> 01:07:08.200]  Хорошо.
[01:07:08.200 --> 01:07:10.200]  Все. Вот такой сплей.
[01:07:10.200 --> 01:07:12.200]  Это просто какая-то реализация подъема
[01:07:12.200 --> 01:07:14.200]  х в корень с помощью каких-то
[01:07:14.200 --> 01:07:16.200]  поворотов.
[01:07:16.200 --> 01:07:18.200]  Теперь...
[01:07:18.200 --> 01:07:20.200]  Зачем нам это?
[01:07:20.200 --> 01:07:22.200]  Теперь
[01:07:22.200 --> 01:07:24.200]  все операции
[01:07:24.200 --> 01:07:26.200]  будут сопровождаться в конце
[01:07:26.200 --> 01:07:28.200]  вызовом сплая, потому что я хочу,
[01:07:28.200 --> 01:07:30.200]  у меня по определению мне нужно вот тот х,
[01:07:30.200 --> 01:07:32.200]  к которому только что произошел
[01:07:32.200 --> 01:07:34.200]  доступ, я его хочу поднять в корень.
[01:07:34.200 --> 01:07:36.200]  Соответственно, у меня все процедуры
[01:07:36.200 --> 01:07:38.200]  переписываются так. Вот был у меня файнд х.
[01:07:38.200 --> 01:07:40.200]  Как работает файнд х? Он работает так же,
[01:07:40.200 --> 01:07:42.200]  как в наивном дереве поиска.
[01:07:42.200 --> 01:07:44.200]  Мы идем и ищем х.
[01:07:44.200 --> 01:07:46.200]  И вот та последняя
[01:07:46.200 --> 01:07:48.200]  вершина, которую мы потрогали,
[01:07:48.200 --> 01:07:50.200]  это х в случае, если он там нашелся,
[01:07:50.200 --> 01:07:52.200]  ну или какой-то лист, из которого мы
[01:07:52.200 --> 01:07:54.200]  попробовали найти х, но его не было.
[01:07:54.200 --> 01:07:56.200]  Вот та самая последняя вершина, которую
[01:07:56.200 --> 01:07:58.200]  мы потрогали, в которой мы оказались,
[01:07:58.200 --> 01:08:00.200]  вот от нее вызываем сплей.
[01:08:00.200 --> 01:08:02.200]  После отработки файнда,
[01:08:02.200 --> 01:08:04.200]  после того, как он нашел ответ, там,
[01:08:04.200 --> 01:08:06.200]  true или false, есть х или нет,
[01:08:06.200 --> 01:08:08.200]  после этого вызываем сплей
[01:08:08.200 --> 01:08:10.200]  от самой низкой потроганной вершины.
[01:08:10.200 --> 01:08:12.200]  Значит, сплей
[01:08:12.200 --> 01:08:14.200]  от
[01:08:14.200 --> 01:08:16.200]  самой
[01:08:16.200 --> 01:08:18.200]  низкой
[01:08:18.200 --> 01:08:20.200]  посещенной вершины.
[01:08:24.200 --> 01:08:26.200]  В случае, если х был
[01:08:26.200 --> 01:08:28.200]  в дереве, то я его сначала нашел, потом
[01:08:28.200 --> 01:08:30.200]  его поднял в корень.
[01:08:30.200 --> 01:08:32.200]  В случае, если его не было,
[01:08:32.200 --> 01:08:34.200]  то я дохожу до какой-то вершинки, понимаю, что х нет,
[01:08:34.200 --> 01:08:36.200]  но все равно сплей давайте вызовем
[01:08:36.200 --> 01:08:38.200]  от той вершины, где я понял, что х нет,
[01:08:38.200 --> 01:08:40.200]  то есть мне кого-то же надо поднять в корень,
[01:08:40.200 --> 01:08:42.200]  вот ту самую последнюю посещенную вершину я поднимаю в корень.
[01:08:42.200 --> 01:08:44.200]  Ну, аналогично
[01:08:44.200 --> 01:08:46.200]  для инсерта и
[01:08:46.200 --> 01:08:48.200]  рейза,
[01:08:48.200 --> 01:08:50.200]  я после них вызываю сплей
[01:08:50.200 --> 01:08:52.200]  от последней посещенной вершины,
[01:08:52.200 --> 01:08:54.200]  то же самое абсолютно.
[01:08:58.200 --> 01:09:00.200]  Ау?
[01:09:00.200 --> 01:09:02.200]  Для чего?
[01:09:02.200 --> 01:09:04.200]  А,
[01:09:04.200 --> 01:09:06.200]  чтобы работало быстро.
[01:09:06.200 --> 01:09:08.200]  Да,
[01:09:08.200 --> 01:09:10.200]  наверное, я пропустил момент мотивации.
[01:09:10.200 --> 01:09:12.200]  Почему это может быть естественно?
[01:09:14.200 --> 01:09:16.200]  Это может быть полезно,
[01:09:16.200 --> 01:09:18.200]  если у вас, ну, не знаю,
[01:09:18.200 --> 01:09:20.200]  вы пишете какой-то сервер,
[01:09:20.200 --> 01:09:22.200]  которым какие-то люди пользуются
[01:09:22.200 --> 01:09:24.200]  очень часто, и вам хотелось бы, чтобы
[01:09:24.200 --> 01:09:26.200]  запросы от них обрабатывались быстро.
[01:09:26.200 --> 01:09:28.200]  А какие-то приходят очень редко,
[01:09:28.200 --> 01:09:30.200]  не знаю, раз в год, и вам, в принципе,
[01:09:30.200 --> 01:09:32.200]  не очень важно, насколько быстро вы их обслуживаете,
[01:09:32.200 --> 01:09:34.200]  насколько быстро обрабатываются их запросы.
[01:09:34.200 --> 01:09:36.200]  Тогда вам хотелось бы, чтобы вот те запросы,
[01:09:36.200 --> 01:09:38.200]  которые были недавно, как бы, от пользователей,
[01:09:38.200 --> 01:09:40.200]  которые часто делают запросы,
[01:09:40.200 --> 01:09:42.200]  чтобы они были повыше к корню. Потому что
[01:09:42.200 --> 01:09:44.200]  на самом деле время ответа на запрос,
[01:09:44.200 --> 01:09:46.200]  ну, не всегда глубина дерева,
[01:09:46.200 --> 01:09:48.200]  возможно, просто расстояние от корня до х.
[01:09:48.200 --> 01:09:50.200]  Если х близко к корню, то вы быстро ответите
[01:09:50.200 --> 01:09:52.200]  на запрос. Там, если, не знаю, х на втором уровне,
[01:09:52.200 --> 01:09:54.200]  то вы его найдете за два шага всего.
[01:09:54.200 --> 01:09:56.200]  Поэтому, как бы, если у вас есть
[01:09:56.200 --> 01:09:58.200]  какие-то золотые пользователи,
[01:09:58.200 --> 01:10:00.200]  которые часто делают запросы,
[01:10:00.200 --> 01:10:02.200]  вы хотите их быстро обслуживать,
[01:10:02.200 --> 01:10:04.200]  то вам хотелось бы, чтобы вот эти объекты,
[01:10:04.200 --> 01:10:06.200]  к которым они обращаются, лежали ближе к корню.
[01:10:06.200 --> 01:10:08.200]  Ну, вот ровно это мы и делаем. Вот те, которые
[01:10:08.200 --> 01:10:10.200]  последние использованы, они всегда будут
[01:10:10.200 --> 01:10:12.200]  очень высоко.
[01:10:12.200 --> 01:10:14.200]  И оказывается, оказывается,
[01:10:14.200 --> 01:10:16.200]  суждение, которое мы сейчас
[01:10:16.200 --> 01:10:18.200]  будем доказывать,
[01:10:18.200 --> 01:10:20.200]  что теперь
[01:10:20.200 --> 01:10:22.200]  учетное время всех этих
[01:10:22.200 --> 01:10:24.200]  операций будет тоже логарифм.
[01:10:24.200 --> 01:10:26.200]  Значит, амортизированное
[01:10:30.200 --> 01:10:32.200]  время
[01:10:32.200 --> 01:10:34.200]  обработки
[01:10:34.200 --> 01:10:36.200]  каждого запроса
[01:10:40.200 --> 01:10:42.200]  есть
[01:10:42.200 --> 01:10:44.200]  от логарифма.
[01:10:44.200 --> 01:10:46.200]  Ну, звездочка, например, значит, как раз
[01:10:46.200 --> 01:10:48.200]  амортизированная.
[01:10:48.200 --> 01:10:50.200]  Амортизированная, как обычно, значит,
[01:10:50.200 --> 01:10:52.200]  что каждая конкретная может работать и долго,
[01:10:52.200 --> 01:10:54.200]  но суммарно они работают так,
[01:10:54.200 --> 01:10:56.200]  как если бы каждый работал за логарифм по времени.
[01:10:58.200 --> 01:11:00.200]  Вот.
[01:11:00.200 --> 01:11:02.200]  Сейчас будем доказывать.
[01:11:06.200 --> 01:11:08.200]  Так.
[01:11:08.200 --> 01:11:10.200]  Скажите, пожалуйста, мета потенциалов
[01:11:10.200 --> 01:11:12.200]  на семинарах разбирался?
[01:11:16.200 --> 01:11:18.200]  Хорошо.
[01:11:20.200 --> 01:11:22.200]  Давайте быстренько скажу, что это.
[01:11:22.200 --> 01:11:24.200]  Значит, у нас был метод
[01:11:24.200 --> 01:11:26.200]  бухучета
[01:11:26.200 --> 01:11:28.200]  для оценки как раз амортизированных
[01:11:28.200 --> 01:11:30.200]  стоимости. Это очень похожая вещь,
[01:11:30.200 --> 01:11:32.200]  чуть более формализованная.
[01:11:32.200 --> 01:11:34.200]  Значит, давайте скажем, что у меня есть в каждом
[01:11:34.200 --> 01:11:36.200]  моменте времени какой-то потенциал
[01:11:36.200 --> 01:11:38.200]  от текущего состояния структуры.
[01:11:38.200 --> 01:11:40.200]  Вот какой-то потенциал Фи.
[01:11:40.200 --> 01:11:42.200]  Это какая-то функция
[01:11:42.200 --> 01:11:44.200]  от внутреннего состояния, да, от внутренней жизни
[01:11:44.200 --> 01:11:46.200]  структуры.
[01:11:46.200 --> 01:11:48.200]  С каждым запросом этот потенциал как-то меняется.
[01:11:48.200 --> 01:11:50.200]  Что-то переподвешивается, что-то добавляется,
[01:11:50.200 --> 01:11:52.200]  как-то меняется внутренняя структура дерева.
[01:11:52.200 --> 01:11:54.200]  Соответственно, как-то меняется его потенциал.
[01:11:54.200 --> 01:11:56.200]  Как бы мы его там не определяли.
[01:11:56.200 --> 01:11:58.200]  Значит, пусть,
[01:11:58.200 --> 01:12:00.200]  ну давайте скажем, что ФиИТ
[01:12:00.200 --> 01:12:02.200]  это потенциал после ИТ-го запроса.
[01:12:02.200 --> 01:12:04.200]  Потенциал после
[01:12:04.200 --> 01:12:06.200]  после
[01:12:06.200 --> 01:12:08.200]  ИТ-го запроса.
[01:12:08.200 --> 01:12:10.200]  Ну и давайте, как обычно,
[01:12:10.200 --> 01:12:12.200]  ТИТ это реальное время выполнения
[01:12:12.200 --> 01:12:14.200]  ИТ-го запроса.
[01:12:14.200 --> 01:12:16.200]  Значит, реальное
[01:12:16.200 --> 01:12:18.200]  время
[01:12:18.200 --> 01:12:20.200]  выполнения
[01:12:20.200 --> 01:12:22.200]  ИТ-го запроса.
[01:12:26.200 --> 01:12:28.200]  Значит, тогда
[01:12:28.200 --> 01:12:30.200]  если я вот таким вот образом
[01:12:30.200 --> 01:12:32.200]  веду учетные стоимости А
[01:12:32.200 --> 01:12:34.200]  как
[01:12:34.200 --> 01:12:36.200]  реальное время работы
[01:12:36.200 --> 01:12:38.200]  плюс потенциал
[01:12:38.200 --> 01:12:40.200]  после ИТ-го запроса
[01:12:40.200 --> 01:12:42.200]  минус потенциал до этого запроса,
[01:12:42.200 --> 01:12:44.200]  то есть на предыдущем шаге.
[01:12:44.200 --> 01:12:46.200]  Так вот, тогда такие штуки можно считать
[01:12:46.200 --> 01:12:48.200]  учетными стоимостьми. Учетные они же
[01:12:48.200 --> 01:12:50.200]  амортизированные.
[01:12:50.200 --> 01:12:52.200]  Учетная
[01:12:52.200 --> 01:12:54.200]  slash амортизированная
[01:12:54.200 --> 01:12:56.200]  стоимость.
[01:13:00.200 --> 01:13:02.200]  Вот. Ну и утверждение
[01:13:02.200 --> 01:13:04.200]  формально, если это
[01:13:04.200 --> 01:13:06.200]  хочется.
[01:13:06.200 --> 01:13:08.200]  Следующее, что
[01:13:08.200 --> 01:13:10.200]  если у вас потенциал в начале 0,
[01:13:10.200 --> 01:13:12.200]  если у вас
[01:13:12.200 --> 01:13:14.200]  потенциал всегда не отрицателен,
[01:13:14.200 --> 01:13:16.200]  то тогда А
[01:13:16.200 --> 01:13:18.200]  определяемой вот такой формулой
[01:13:18.200 --> 01:13:20.200]  является учетными стоимостьми.
[01:13:22.200 --> 01:13:24.200]  Вот такой вот А.
[01:13:24.200 --> 01:13:26.200]  Давайте я напишу так. Т плюс дельта фи.
[01:13:26.200 --> 01:13:28.200]  То есть Т плюс изменение потенциала структуры
[01:13:28.200 --> 01:13:30.200]  конечная минус начальная.
[01:13:30.200 --> 01:13:32.200]  Фи после шага, минус предыдущая.
[01:13:32.200 --> 01:13:34.200]  Это учетные стоимости.
[01:13:36.200 --> 01:13:38.200]  Доказательства проводятся ровно так же, как было
[01:13:38.200 --> 01:13:40.200]  в методе монеток. Что такое учетные
[01:13:40.200 --> 01:13:42.200]  стоимости? Учетные стоимости это такие,
[01:13:42.200 --> 01:13:44.200]  что их сумма сверху ограничивает
[01:13:44.200 --> 01:13:46.200]  сумму Т.
[01:13:46.200 --> 01:13:48.200]  Ну давайте посчитаем сумму аитых.
[01:13:48.200 --> 01:13:50.200]  Сумма аитых, по определению,
[01:13:50.200 --> 01:13:52.200]  это сумма теитых,
[01:13:52.200 --> 01:13:54.200]  плюс сумма фиитых, минус сумму
[01:13:54.200 --> 01:13:56.200]  фи минус первых. Давайте я сразу
[01:13:56.200 --> 01:13:58.200]  сокращу. Фи первое
[01:13:58.200 --> 01:14:00.200]  минус фи первое, фи второе минус фи второе.
[01:14:00.200 --> 01:14:02.200]  Останется у меня фи последнее
[01:14:02.200 --> 01:14:04.200]  минус фи нулевое.
[01:14:04.200 --> 01:14:06.200]  Ну вот, а это уже сразу
[01:14:06.200 --> 01:14:08.200]  больше собравно, чем сумма теитых.
[01:14:16.200 --> 01:14:18.200]  Вот. Мораль.
[01:14:18.200 --> 01:14:20.200]  Если я придумываю какой-то потенциал
[01:14:20.200 --> 01:14:22.200]  фи для моей структуры,
[01:14:22.200 --> 01:14:24.200]  если он удовлетворяет вот этим свойствам,
[01:14:24.200 --> 01:14:26.200]  что он в начале ноль и в конце
[01:14:26.200 --> 01:14:28.200]  и всегда не отрицателен,
[01:14:28.200 --> 01:14:30.200]  тогда вот такое вот
[01:14:30.200 --> 01:14:32.200]  обозначение для
[01:14:32.200 --> 01:14:34.200]  учетных стоимости, для ашек,
[01:14:34.200 --> 01:14:36.200]  является корректными учетными стоимости.
[01:14:36.200 --> 01:14:38.200]  Это реально можно рассматривать как вот
[01:14:38.200 --> 01:14:40.200]  то самое о звездочке.
[01:14:40.200 --> 01:14:42.200]  Вот.
[01:14:42.200 --> 01:14:44.200]  Ну и мы такой сейчас потенциал ведем
[01:14:44.200 --> 01:14:46.200]  и будем с ним работать.
[01:14:50.200 --> 01:14:52.200]  Так, понятная идея.
[01:14:52.200 --> 01:14:54.200]  Это как метамонеток,
[01:14:54.200 --> 01:14:56.200]  ну типа вот здесь вот сколько монеток
[01:14:56.200 --> 01:14:58.200]  положили, минус сколько сняли.
[01:14:58.200 --> 01:15:00.200]  Почти то же самое, только в других терминах, скажем так.
[01:15:00.200 --> 01:15:02.200]  Вот. Хорошо.
[01:15:02.200 --> 01:15:04.200]  Хорошо.
[01:15:04.200 --> 01:15:06.200]  Ну давайте доказывать вот то утверждение.
[01:15:06.200 --> 01:15:08.200]  Вот то вот.
[01:15:08.200 --> 01:15:10.200]  Давайте ведем следующий потенциал.
[01:15:10.200 --> 01:15:12.200]  Значит, сначала для каждой вершины
[01:15:14.200 --> 01:15:16.200]  X.
[01:15:16.200 --> 01:15:18.200]  S от X пусть будет размер его под дерево.
[01:15:20.200 --> 01:15:22.200]  Размер под дерево
[01:15:22.200 --> 01:15:24.200]  вершин X.
[01:15:26.200 --> 01:15:28.200]  Вершин X.
[01:15:28.200 --> 01:15:30.200]  Вершины X.
[01:15:30.200 --> 01:15:32.200]  То есть это сколько вершин
[01:15:32.200 --> 01:15:34.200]  находится в его под дереве, включая X.
[01:15:34.200 --> 01:15:36.200]  То есть вот X и все его дети,
[01:15:36.200 --> 01:15:38.200]  все что в под дереве, их количество
[01:15:38.200 --> 01:15:40.200]  равно S от X.
[01:15:40.200 --> 01:15:42.200]  Вот. А потенциал это сумма логарифмов...
[01:15:42.200 --> 01:15:44.200]  Sorry. Сначала я веду R
[01:15:44.200 --> 01:15:46.200]  как двоичный логарифм S.
[01:15:48.200 --> 01:15:50.200]  Вот. И после этого phi это
[01:15:50.200 --> 01:15:52.200]  сумма рангов по всем вершинам.
[01:15:52.200 --> 01:15:54.200]  Значит, сумма вот этих R по всем вершинам.
[01:15:58.200 --> 01:16:00.200]  Сумма двоичных логарифмов
[01:16:00.200 --> 01:16:02.200]  размеров всех под деревьев
[01:16:02.200 --> 01:16:04.200]  по всем вершинам.
[01:16:04.200 --> 01:16:06.200]  Опять.
[01:16:06.200 --> 01:16:08.200]  Взялось с потолка.
[01:16:08.200 --> 01:16:10.200]  С этим, вот с таким потенциалом,
[01:16:10.200 --> 01:16:12.200]  докажем, что все работает.
[01:16:12.200 --> 01:16:14.200]  Ну то есть понятно, что phi в нуле это ноль,
[01:16:14.200 --> 01:16:16.200]  потому что изначально дерево пустое, вершин нет,
[01:16:16.200 --> 01:16:18.200]  сумма пустая. Всегда не отрицательно,
[01:16:18.200 --> 01:16:20.200]  потому что все S всегда, ну как бы,
[01:16:20.200 --> 01:16:22.200]  присутствующие в сумме слагаемые,
[01:16:22.200 --> 01:16:24.200]  все S хотя бы один, потому что
[01:16:24.200 --> 01:16:26.200]  X есть в своем под дереве, поэтому это всегда один.
[01:16:26.200 --> 01:16:28.200]  Логарифм, значит, всегда не отрицательный,
[01:16:28.200 --> 01:16:30.200]  phi всегда не отрицательный.
[01:16:30.200 --> 01:16:32.200]  И вот если с этим потенциалом не получится доказать,
[01:16:32.200 --> 01:16:34.200]  что A определяемое по такому соотношению
[01:16:34.200 --> 01:16:36.200]  всегда от логарифма,
[01:16:36.200 --> 01:16:38.200]  то мы победим.
[01:16:38.200 --> 01:16:40.200]  А можно считать, что учетные стоимости логарифмические.
[01:16:42.200 --> 01:16:44.200]  Вот.
[01:16:44.200 --> 01:16:46.200]  Хорошо.
[01:16:46.200 --> 01:16:48.200]  Ну, смотрите, как бы мы поняли,
[01:16:48.200 --> 01:16:50.200]  что в каком-то смысле у меня все операции,
[01:16:50.200 --> 01:16:52.200]  find, erase и insert,
[01:16:52.200 --> 01:16:54.200]  сводятся к splu. То есть мы в любом случае
[01:16:54.200 --> 01:16:56.200]  после каждой нормальной операции вызываем
[01:16:56.200 --> 01:16:58.200]  вот наш spli, который поднимает X в корень.
[01:16:58.200 --> 01:17:00.200]  Давайте сначала проанализируем время работы
[01:17:00.200 --> 01:17:02.200]  splia. Давайте поймем,
[01:17:02.200 --> 01:17:04.200]  чему равно учетное время работы процедуры
[01:17:04.200 --> 01:17:06.200]  spli.
[01:17:08.200 --> 01:17:10.200]  Учетное, вот в том самом смысле, реальное время
[01:17:10.200 --> 01:17:12.200]  плюс разных потенциалов. Чему равно
[01:17:12.200 --> 01:17:14.200]  учетное время работы spli.
[01:17:14.200 --> 01:17:16.200]  Ну, что такое spli? Мы знаем, это комбинация
[01:17:16.200 --> 01:17:18.200]  вот этих вот стрёмных трех процедур.
[01:17:18.200 --> 01:17:20.200]  Давайте с ними по очереди разбираться.
[01:17:20.200 --> 01:17:22.200]  Так.
[01:17:22.200 --> 01:17:24.200]  Ну, давайте, давайте.
[01:17:24.200 --> 01:17:26.200]  Lemma я, наверное, это назову.
[01:17:26.200 --> 01:17:28.200]  Lemma.
[01:17:30.200 --> 01:17:32.200]  Давайте так.
[01:17:32.200 --> 01:17:34.200]  A от spli от X
[01:17:34.200 --> 01:17:36.200]  равно
[01:17:36.200 --> 01:17:38.200]  не больше чем
[01:17:40.200 --> 01:17:42.200]  Я это сформулирую.
[01:17:42.200 --> 01:17:44.200]  Потом мы это будем доказывать.
[01:17:44.200 --> 01:17:46.200]  R' от X
[01:17:46.200 --> 01:17:48.200]  минус R от X.
[01:17:50.200 --> 01:17:52.200]  То есть, если spli вызвался
[01:17:52.200 --> 01:17:54.200]  от вершины X, то учетное время
[01:17:54.200 --> 01:17:56.200]  я утверждаю этой процедуры
[01:17:56.200 --> 01:17:58.200]  splia работает за
[01:17:58.200 --> 01:18:00.200]  один плюс утройная разность рангов
[01:18:00.200 --> 01:18:02.200]  это конечный ранг. Вот это ранг
[01:18:02.200 --> 01:18:04.200]  X после spli.
[01:18:04.200 --> 01:18:06.200]  Это ранг X до выполнения spli.
[01:18:06.200 --> 01:18:08.200]  То есть, это R' от X в исходном дереве.
[01:18:08.200 --> 01:18:10.200]  Это R' от X, новый ранг
[01:18:10.200 --> 01:18:12.200]  в дереве после выполнения spli. Это конечный
[01:18:12.200 --> 01:18:14.200]  этот начальный ранг.
[01:18:14.200 --> 01:18:16.200]  Вот я утверждаю, что spli всегда вот такой.
[01:18:16.200 --> 01:18:20.200]  Чего?
[01:18:20.200 --> 01:18:22.200]  Еще раз, еще раз.
[01:18:22.200 --> 01:18:24.200]  Какой ранг у листа, скажите, пожалуйста?
[01:18:24.200 --> 01:18:26.200]  S от X
[01:18:26.200 --> 01:18:28.200]  1.
[01:18:28.200 --> 01:18:30.200]  Мы считаем, что
[01:18:30.200 --> 01:18:32.200]  вершина X сама в свое поддерево
[01:18:32.200 --> 01:18:34.200]  входит.
[01:18:34.200 --> 01:18:36.200]  То есть, вот есть X, вот есть его какие-то
[01:18:36.200 --> 01:18:38.200]  левое правое поддерево,
[01:18:38.200 --> 01:18:40.200]  все вот в этом списке входит в S от X.
[01:18:40.200 --> 01:18:42.200]  В частности, X.
[01:18:42.200 --> 01:18:44.200]  Поэтому я написал, что S всегда хотя бы 1.
[01:18:44.200 --> 01:18:46.200]  То есть, X входит в свое поддерево.
[01:18:52.200 --> 01:18:54.200]  Так, ну хорошо.
[01:18:54.200 --> 01:18:56.200]  Давайте доказывать.
[01:18:56.200 --> 01:18:58.200]  Давайте начнем
[01:18:58.200 --> 01:19:00.200]  с процедуры zig. Она самая простая.
[01:19:00.200 --> 01:19:02.200]  Давайте поймем,
[01:19:02.200 --> 01:19:04.200]  что такое учетное время процедуры zig.
[01:19:04.200 --> 01:19:06.200]  Надо мне
[01:19:06.200 --> 01:19:08.200]  восстановить картинку.
[01:19:14.200 --> 01:19:16.200]  Jig, напоминаю, работает в случае,
[01:19:16.200 --> 01:19:18.200]  когда X это сын корня.
[01:19:18.200 --> 01:19:20.200]  Я делаю одно вращение,
[01:19:20.200 --> 01:19:22.200]  и X становится новым корнем.
[01:19:26.200 --> 01:19:28.200]  Так.
[01:19:28.200 --> 01:19:30.200]  Хорошо. Давайте посчитаем
[01:19:30.200 --> 01:19:32.200]  учетное время такой процедуры
[01:19:32.200 --> 01:19:34.200]  в терминах метода потенциалов.
[01:19:34.200 --> 01:19:36.200]  Учетное время это реальное время,
[01:19:36.200 --> 01:19:38.200]  плюс разность потенциалов.
[01:19:38.200 --> 01:19:40.200]  Что такое реальное время?
[01:19:40.200 --> 01:19:42.200]  Давайте я для удобства буду считать,
[01:19:42.200 --> 01:19:46.200]  что время равно числу поворотов.
[01:19:46.200 --> 01:19:48.200]  Ну, на самом деле,
[01:19:48.200 --> 01:19:50.200]  это надо написать от единицы,
[01:19:50.200 --> 01:19:52.200]  потому что мы понимаем, что каждый поворот
[01:19:52.200 --> 01:19:54.200]  это от единицы переприсвоения указателей.
[01:19:54.200 --> 01:19:56.200]  Ну, тогда мне надо было бы
[01:19:56.200 --> 01:19:58.200]  вот здесь написать,
[01:19:58.200 --> 01:20:00.200]  если там 5 переприсвоения указателей,
[01:20:00.200 --> 01:20:02.200]  то здесь вылезла бы константа 5.
[01:20:02.200 --> 01:20:04.200]  Это бы ни на что не повлияло,
[01:20:04.200 --> 01:20:06.200]  но для простоты я считаю,
[01:20:06.200 --> 01:20:08.200]  что один поворот работает за один такт,
[01:20:08.200 --> 01:20:10.200]  ну, короче, за одну операцию.
[01:20:10.200 --> 01:20:12.200]  Процессоры, грубо говоря.
[01:20:12.200 --> 01:20:14.200]  Поворот – это один реального времени.
[01:20:14.200 --> 01:20:16.200]  Вот.
[01:20:16.200 --> 01:20:18.200]  Теперь надо понять, что происходит с рангами,
[01:20:18.200 --> 01:20:20.200]  с потенциалом точнее.
[01:20:20.200 --> 01:20:22.200]  Ну, потенциал – это сумма рангов по всем вершинам.
[01:20:22.200 --> 01:20:24.200]  Как у меня меняются ранги
[01:20:24.200 --> 01:20:26.200]  всех вершин?
[01:20:26.200 --> 01:20:28.200]  Ну, смотрите, в под деревьях A, B, C ничего не произошло,
[01:20:28.200 --> 01:20:30.200]  их структура осталась так же, как была.
[01:20:30.200 --> 01:20:32.200]  Поэтому в них все размеры под деревья
[01:20:32.200 --> 01:20:34.200]  все ранги сохранились,
[01:20:34.200 --> 01:20:36.200]  поэтому A, B, C остались такими, как были.
[01:20:36.200 --> 01:20:38.200]  Поменялись только ранги у икса
[01:20:38.200 --> 01:20:40.200]  и у пешки.
[01:20:40.200 --> 01:20:42.200]  Значит, поэтому я пишу
[01:20:42.200 --> 01:20:44.200]  плюс r штрих от x минус r от x
[01:20:44.200 --> 01:20:46.200]  плюс r штрих от p
[01:20:46.200 --> 01:20:48.200]  минус r от p.
[01:20:48.200 --> 01:20:50.200]  r штрих – это новый ранг
[01:20:50.200 --> 01:20:52.200]  после поворота,
[01:20:52.200 --> 01:20:54.200]  r – это старый ранг до поворота.
[01:20:58.200 --> 01:21:00.200]  Хорошо.
[01:21:00.200 --> 01:21:02.200]  Будьте здоровы.
[01:21:02.200 --> 01:21:04.200]  Я хочу заметить,
[01:21:04.200 --> 01:21:06.200]  что r штрих от p
[01:21:06.200 --> 01:21:08.200]  меньше ли равно
[01:21:08.200 --> 01:21:10.200]  наоборот
[01:21:16.200 --> 01:21:18.200]  Да, не, все правильно.
[01:21:18.200 --> 01:21:20.200]  r штрих от p меньше ли равно r от p.
[01:21:20.200 --> 01:21:22.200]  Все правильно, все правильно написал.
[01:21:22.200 --> 01:21:24.200]  Меньше r от p.
[01:21:24.200 --> 01:21:26.200]  Почему? Ну, очень просто.
[01:21:26.200 --> 01:21:28.200]  Что такое r штрих от p?
[01:21:28.200 --> 01:21:30.200]  Это двоичный logarithm вот этого вот размера.
[01:21:30.200 --> 01:21:32.200]  Вот это вот это r штрих от p.
[01:21:32.200 --> 01:21:34.200]  А r от p – это двоичный logarithm вот этого вот всего.
[01:21:34.200 --> 01:21:36.200]  Вот это r от p.
[01:21:36.200 --> 01:21:38.200]  Ясно, что это меньше, чем это.
[01:21:38.200 --> 01:21:40.200]  Потому что здесь было
[01:21:40.200 --> 01:21:42.200]  вообще все дерево,
[01:21:42.200 --> 01:21:44.200]  а здесь только вот это его часть.
[01:21:44.200 --> 01:21:46.200]  На самом деле, здесь даже строго неравенство,
[01:21:46.200 --> 01:21:48.200]  но, бог с ним, мне не строго хватит.
[01:21:48.200 --> 01:21:50.200]  Значит, r штрих для p
[01:21:50.200 --> 01:21:52.200]  не больше, чем r от p.
[01:21:52.200 --> 01:21:54.200]  Поэтому я могу вот здесь неравенство продолжить
[01:21:54.200 --> 01:21:56.200]  и написать, что это не больше, чем
[01:21:56.200 --> 01:21:58.200]  1 плюс, то есть я вот это могу оценить нулем,
[01:21:58.200 --> 01:22:00.200]  потому что это меньше, чем это,
[01:22:00.200 --> 01:22:02.200]  они с разными знаками сокращаются.
[01:22:02.200 --> 01:22:04.200]  Остается r штрих от x
[01:22:04.200 --> 01:22:06.200]  минус r от x.
[01:22:06.200 --> 01:22:08.200]  Ну, еще давайте я
[01:22:08.200 --> 01:22:10.200]  для красоты сверху вот таким вот
[01:22:10.200 --> 01:22:12.200]  неинтеллектуальным выражением оценю.
[01:22:14.200 --> 01:22:16.200]  Просто тройку сверху накину.
[01:22:16.200 --> 01:22:18.200]  Вот к этой разности
[01:22:18.200 --> 01:22:20.200]  сверху накину тройку.
[01:22:20.200 --> 01:22:22.200]  Вот.
[01:22:22.200 --> 01:22:24.200]  Ну, так можно сделать, потому что
[01:22:24.200 --> 01:22:26.200]  тут выполняется наоборот
[01:22:26.200 --> 01:22:28.200]  отношение, что r штрих от x
[01:22:28.200 --> 01:22:30.200]  больше или равно r от x.
[01:22:32.200 --> 01:22:34.200]  То есть вот это вот слагаемое
[01:22:34.200 --> 01:22:36.200]  не отрицательно, поэтому при умножении его
[01:22:36.200 --> 01:22:38.200]  на тройку значение может только вырасти,
[01:22:38.200 --> 01:22:40.200]  поэтому это неравенство верное.
[01:22:40.200 --> 01:22:42.200]  Ну, r штрих от x больше, но r от x опять
[01:22:42.200 --> 01:22:44.200]  по тем же причинам, потому что r штрих от x
[01:22:44.200 --> 01:22:46.200]  это двоичный грифом всего дерева,
[01:22:46.200 --> 01:22:48.200]  а r от x это двоичный грифом только вот этого
[01:22:48.200 --> 01:22:50.200]  маленького по дереву x, a и b.
[01:22:50.200 --> 01:22:52.200]  Поэтому верно вот это, и соответственно
[01:22:52.200 --> 01:22:54.200]  верна вот эта оценочка.
[01:22:54.200 --> 01:22:56.200]  Согласны?
[01:22:56.200 --> 01:22:58.200]  Так, ну все, времени больше не остается.
[01:22:58.200 --> 01:23:00.200]  В следующей
[01:23:00.200 --> 01:23:02.200]  лекции мы разберемся с остальными
[01:23:02.200 --> 01:23:04.200]  операциями, зиг-зиг-зигзаг,
[01:23:04.200 --> 01:23:06.200]  сложим и как раз получим вот такую оценку,
[01:23:06.200 --> 01:23:08.200]  поймем, почему это логарифм. Спасибо.
