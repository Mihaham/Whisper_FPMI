[00:00.000 --> 00:20.000]  Мы в прошлый раз наконец-то поняли, как устроены выражения new и delete в языке C++. Давайте вспомним, что происходит, когда мы пишем в программе код наподобие такого.
[00:21.000 --> 00:33.000]  Ответ, который бы нас устроил еще недели две назад, заключается в том, что операция new просто-напросто выделяет динамическую память и создает нужный объект t.
[00:33.000 --> 00:40.000]  Сегодня же мы скажем более формально, и данное выражение new приводит к двум вещам.
[00:40.000 --> 00:46.000]  Первое, действительно выделяется динамическая память. Но динамическая память выделяется особенным образом.
[00:46.000 --> 01:01.000]  В частности, если выражение new мы передаем в список аргументов, а выражение new можно передать в список аргументов, то память выделяется с помощью специальной функции, которая имеет следующую сигнатуру.
[01:01.000 --> 01:11.000]  Вызывается функция operator new, которая возвращает указатель на void и принимает тот самый набор параметров, которые передали выражение new.
[01:11.000 --> 01:17.000]  Это возвращаемое значение как раз-таки интерпретируется тем самым местным в памяти, по которому будет создан объект.
[01:17.000 --> 01:24.000]  То есть операция new, точнее функция operator new, выделяет память и возвращает указатель на выделенный блок памяти.
[01:24.000 --> 01:29.000]  Что дальше происходит с этим блоком памяти, на который указывает возвращенный указатель?
[01:29.000 --> 01:39.000]  Дальше, на втором этапе, вот по этому месту в памяти, появляется объект типа T, переданный конструктор параметрами.
[01:39.000 --> 01:47.000]  Каждый раз, когда мы вызываем new, происходит две вещи. Первый вызов какой-то версии функции operator new,
[01:47.000 --> 01:58.000]  и по возвращенной памяти, которую выделяет или не выделяет, но самое главное, что operator new возвращает нам указатель по какому-то месту в памяти, в котором можно создать объект.
[01:58.000 --> 02:02.000]  В этом месте в памяти мы создаем объект с нужными нам параметрами.
[02:04.000 --> 02:12.000]  Дальше, что происходит, когда мы вызываем delete от какого-то указателя ptr?
[02:12.000 --> 02:23.000]  Снова происходит две вещи. Как и раньше, мы с вами говорили, что вызов выражения delete приводит к тому, что, во-первых, вызывается деструктор для объекта, который лежит под этим указателем,
[02:23.000 --> 02:31.000]  во-вторых, память освобождается и возвращается обратно либо в пул памяти, либо в операционной системе, в зависимости от того, как память была выделена.
[02:31.000 --> 02:36.000]  Так или иначе, первым делом вызывается деструктор.
[02:36.000 --> 02:45.000]  Если под указателем лежит какой-то объект, то для этого объекта вызывается деструктор.
[02:45.000 --> 02:55.000]  Ну и второе. Происходит вызов функции оператор delete от этого указателя.
[02:55.000 --> 03:07.000]  Эта функция оператора delete просто-напросто освобождает память, в том смысле, что она просто-напросто возвращает ресурсы, которые были выделены ранее операционной системе или пул памяти, который вы используете.
[03:07.000 --> 03:14.000]  Про что тут еще в этом контексте стоит поговорить?
[03:14.000 --> 03:23.000]  Тут осталось поговорить еще про то, что существует несколько различных форм.
[03:23.000 --> 03:30.000]  Функция оператор new. Самая часть, которую мы используем, это функция оператор new, которая просто-напросто принимает...
[03:30.000 --> 03:34.000]  Кстати, тут не совсем корректно.
[03:34.000 --> 03:46.000]  То есть функция оператор new всегда принимает size t, то есть первым параметром она принимает количество байт, которые нужно выделить, а дальше все остальные аргументы она берет вот отсюда из того, что мы ей передали в круглые скобки.
[03:46.000 --> 03:52.000]  Если мы ей в круглые скобки ничего не передаем, то, соответственно, операция new принимает просто size t.
[03:52.000 --> 03:59.000]  Соответственно, мы с вами сказали, что существует несколько стандартных функций оператор new, которые могут быть использованы.
[03:59.000 --> 04:06.000]  Например, первая самая стандартная функция оператор new – это та функция, которая используется, когда мы выделяем память с помощью new без каких-либо параметров.
[04:06.000 --> 04:08.000]  Это самая первая стандартная форма.
[04:08.000 --> 04:13.000]  Вторая форма вызывается в случае, если мы передаем в new параметр no throw.
[04:13.000 --> 04:16.000]  Эта форма new является так называемой необрацающей формой.
[04:16.000 --> 04:27.000]  В том смысле, что обычный new, если ему не хватает памяти для того, чтобы выделить ваш объект, то он просто завершает аварийную работу вашей программы.
[04:27.000 --> 04:33.000]  В ближайших лекциях мы подробнее поговорим про схему с тем, что на самом деле происходит.
[04:33.000 --> 04:42.000]  А вот эта форма new, если что-то пошло не так, то есть в случае, если память была выделена некорректно, то эта форма new просто вернет нулевой указатель.
[04:42.000 --> 04:51.000]  Программа аварии не завершится, просто нам вернется нулевой указатель, и вы сможете проверить верно ли что указатель нулевой, не нулевой, верно ли что память выделилась корректно.
[04:51.000 --> 04:58.000]  Ну и последняя форма, как называемая размещающая форма, имеет следующий вид.
[04:58.000 --> 05:03.000]  new, ptr и дальше t с какими-то аргументами.
[05:04.000 --> 05:15.000]  Ключевая особенность этой формы заключается в том, что вот в этой форме, вот эта самая функция оператора new, которая вторым параметром принимает указатель, она не выделяет память.
[05:15.000 --> 05:20.000]  Она предполагает, что тут указатель, который вы в нее передали, и есть тот самый указатель на уже заранее выделенную память.
[05:20.000 --> 05:28.000]  Поэтому можно считать, что вот эта форма, все что она делает, так это пункт 2, то есть просто вызывает конструктор t.
[05:28.000 --> 05:36.000]  Если у вас есть уже какая-то выделенная память, сырая, в которой нет никакого объекта, то с помощью такого синксиса можете просто вызвать конструктор и создать объект сразу же в нужном месте памяти.
[05:36.000 --> 05:39.000]  Про что мы с вами еще в этом контексте не поговорили?
[05:39.000 --> 05:47.000]  Мы с вами не поговорили про то, что на самом деле вот тем предыдущим набором стандартных функций оператора new дело не ограничивается.
[05:47.000 --> 05:51.000]  На самом деле вы можете вводить язык в свои собственные версии операции new.
[05:51.000 --> 05:55.000]  То есть вы можете самостоятельно перегружать операции new, то есть вводить новые функции,
[05:55.000 --> 05:59.000]  и таким образом использовать свои собственные версии выражения new.
[05:59.000 --> 06:02.000]  Более того, вы можете даже переопределять стандартные формы операции new.
[06:02.000 --> 06:07.000]  Давайте посмотрим на примеры.
[06:07.000 --> 06:14.000]  Первый пример показывает, как можно, например, перегрузить стандартную операцию new.
[06:14.000 --> 06:16.000]  Как это происходит?
[06:16.000 --> 06:22.000]  Смотрите, мы знаем, что стандартная операция new, точнее стандартная функция оператора new, она принимает количество байт, которое нужно выделить.
[06:22.000 --> 06:31.000]  Давайте переопределим функцию оператора new, которая также называется, которая возвращает void со звездой и тоже принимает количество байт, которое нужно выделить.
[06:31.000 --> 06:38.000]  Отличие нашей функции оператора new будет заключаться в том, что она будет сообщать нам о том, сколько памяти она выделила.
[06:38.000 --> 06:39.000]  Во-первых.
[06:39.000 --> 06:46.000]  Во-вторых, мы будем выделять память с помощью malloc, а не с помощью стандартной функции new.
[06:46.000 --> 06:50.000]  Тут мы выделили память с помощью new, проверили, что malloc вернул нам не нулевой указатель.
[06:50.000 --> 06:53.000]  Если он вернул не нулевой указатель, то возвращаем ответ.
[06:53.000 --> 06:58.000]  Если malloc вернул нам нулевой указатель, то мы сообщаем об ошибке.
[06:58.000 --> 07:06.000]  И даже переопределяем стандартную версию операции new с квадратными скобками, которая будет вызывать глобальную версию операции new, то есть нашу операцию new.
[07:06.000 --> 07:10.000]  И перегружаем функцию оператора delete.
[07:10.000 --> 07:15.000]  Оператор delete принимает указатель, водится звездой, ничего не возвращает.
[07:15.000 --> 07:18.000]  Ну и точно так же действует операция delete с квадратными скобками.
[07:18.000 --> 07:23.000]  Но операция delete с квадратными скобками просто-напросто вызывает обычную операцию delete.
[07:23.000 --> 07:27.000]  Давайте посмотрим, к чему это приведет.
[07:27.000 --> 07:37.000]  Тут у меня есть пример, в котором функция main выделяет память для одного объекта типа A и выделяет память для массива объектов A из пяти элементов.
[07:37.000 --> 07:42.000]  Давайте посмотрим, к чему это приведет.
[07:42.000 --> 07:49.000]  Соответственно, когда я выделял память для объекта типа A, у меня выделилось 4 байта.
[07:49.000 --> 07:56.000]  Сама функция оператора new, которую я перегрузил, написала мне о том, что она попыталась выделить 4 байта.
[07:56.000 --> 07:58.000]  Так как программа не упала, видимо, все прошло успешно.
[07:58.000 --> 08:04.000]  И когда я выделял память для пяти элементов типа A, у меня выделилось 28 байтов.
[08:04.000 --> 08:12.000]  Вопрос. Почему, когда я выделял память для пяти элементов типа A, у меня выделилось 28 байтов?
[08:12.000 --> 08:15.000]  Хотя структура A занимает в памяти 4 байта.
[08:15.000 --> 08:17.000]  Смотрите, у меня структура A хранит себе просто int.
[08:17.000 --> 08:19.000]  Int на моей системе занимает 4 байта.
[08:19.000 --> 08:25.000]  Я выделяю 5 элементов типа A, и кажется, что 5 элементов типа A должны помещаться в 20 байтов.
[08:25.000 --> 08:28.000]  При этом моя версия операции new выделила 28 байтов.
[08:28.000 --> 08:30.000]  Давайте с нее посмотрим.
[08:30.000 --> 08:32.000]  Тут вроде как никаких приколов нет.
[08:32.000 --> 08:34.000]  Сколько памяти нужно, столько она выделяет.
[08:34.000 --> 08:42.000]  Смотрите, мы с вами говорили о том, что в чем отличие формы new от формы new с квадратными скобками.
[08:42.000 --> 08:49.000]  В форме new с квадратными скобками, то есть, смотрите, обычному new и обычному delete всегда понимаешь, что он работает только с одним объектом.
[08:49.000 --> 08:56.000]  Если обычный new и обычный delete работают ровно с одним объектом, то ему всегда понятно, что ему нужно вызвать ровно один конструктор и ровно один деструктор.
[08:56.000 --> 08:58.000]  В чем проблема с new с квадратными скобками?
[08:58.000 --> 09:00.000]  New с квадратными скобками проблема в следующем.
[09:00.000 --> 09:07.000]  Когда вызываете delete, delete каким-то образом нужно узнать, а сколько элементов под этим самоуказателем лежит.
[09:07.000 --> 09:10.000]  Ему нужно понять, сколько элементов ему нужно удалять.
[09:10.000 --> 09:12.000]  Вопрос, как это сделать?
[09:12.000 --> 09:14.000]  Происходит это следующим образом.
[09:14.000 --> 09:30.000]  Если нужно выделить память для пяти элементов типа a, то чтобы delete в будущем смог узнать, сколько элементов нужно будет удалить, для каких элементов нужно будет вызвать деструктор,
[09:30.000 --> 09:45.000]  выражение new с квадратными скобками фиктивно выделяет дополнительные 8 байт, в котором хранится количество элементов, которые выделено.
[09:45.000 --> 09:49.000]  Но при этом new возвращает непосредственно указатель на начало самого массива.
[09:49.000 --> 09:57.000]  Поэтому эти лишние 8 байт взялись из-за того, что new заранее выделил дополнительные 8 байт, чтобы тут сохранить информацию о том, сколько элементов было выделено.
[09:57.000 --> 10:05.000]  Об этом думать не нужно, это деталь реализации, о которой компилятор разберется самостоятельно.
[10:05.000 --> 10:15.000]  Когда я вызывал delete для object, то у меня вызвалась версия операции delete.
[10:15.000 --> 10:19.000]  Я написал две версии операции delete.
[10:19.000 --> 10:25.000]  Когда вы реализуете свои собственные версии операции new и операции delete, вы можете поступить двумя путями.
[10:25.000 --> 10:37.000]  При реализации delete вы можете реализовать обычный delete, который принимает просто обычный указатель, либо вы можете перегрузить операцию delete, который принимает дополнительный размер выделенной памяти.
[10:37.000 --> 10:39.000]  Для чего это может быть нужно?
[10:39.000 --> 10:44.000]  Это может быть нужно, например, если вы пишете свой собственный менеджер памяти.
[10:44.000 --> 10:50.000]  Когда мы работаем с памятью, которая выделяет операционную систему, она сама знает, сколько памяти она выделила.
[10:50.000 --> 10:59.000]  По данному месту в памяти сколько элементов было отправлено в вашу программу, и поэтому операционная система сама разбирается, сколько памяти ей нужно забрать, сколько ей нужно отдать.
[10:59.000 --> 11:08.000]  Если вы пишете свой собственный менеджер памяти, то, вообще говоря, зачастую вам информация о том, куда указывает указатель, недостаточно.
[11:08.000 --> 11:14.000]  Вам еще дополнительно нужно знать, сколько элементов было выделено.
[11:14.000 --> 11:22.000]  Поэтому существует дополнительная версия операции delete, которую вы можете по желанию перегрузить, которые дополнительно еще принимают размер выделенной памяти.
[11:23.000 --> 11:29.000]  Как каким-то образом использовать эту информацию для распределения ваших ресурсов.
[11:31.000 --> 11:40.000]  Тут компилятор нашел версию операции delete, которая принимает дополнительно еще и количество выделенной памяти, и поэтому у меня получилось напечатать еще и количество памяти, которое было освобождено.
[11:40.000 --> 11:45.000]  Если этих операций не будет, то будет вызываться только первая версия.
[11:45.000 --> 12:03.000]  Тут я написал операцию new, которая перекрывается со стандартной существующей версией операции new.
[12:03.000 --> 12:08.000]  Если вы написали свою версию операции new, то она действительно будет перекрывать уже существующую.
[12:08.000 --> 12:14.000]  В данной программе вообще нет никакой возможности обратиться к уже существующей версии операции new.
[12:14.000 --> 12:26.000]  Если вы перегрузили функцию операции new, которая уже существует в C++, то существующая версия просто удаляется и используется только ваша.
[12:26.000 --> 12:34.000]  И вот в этом заключается проблема. На самом деле перегружать глобальную версию операции new крайне не рекомендуется.
[12:34.000 --> 12:41.000]  Почему? Потому что если вы перегрузили глобальную версию операции new, то эта глобальная версия операции new будет перегружена во всей программе.
[12:41.000 --> 12:51.000]  И если кто-то, разработчик, который работает вместе с вами, полагается на стандартное поведение операции new, то его будет ждать приятный сюрприз.
[12:51.000 --> 12:56.000]  В виде того, что будет вызывать не стандартная версия операции new, а будет вызываться та версия new, которая написана у вас.
[12:56.000 --> 13:03.000]  Более того, мы с вами знаем, что операцию new вызывают всякие контейнеры типа Vector, DEC и т.д.
[13:03.000 --> 13:07.000]  И все эти контейнеры тоже будут использовать вашу собственную версию операции new.
[13:07.000 --> 13:13.000]  Поэтому если вы этого не хотите, то крайне не рекомендуется перегружать глобальные версии операции new.
[13:13.000 --> 13:16.000]  Точнее, крайне не рекомендуется переписывать старые версии операции new.
[13:16.000 --> 13:20.000]  При этом такая возможность есть.
[13:23.000 --> 13:27.000]  Допустим, мы договорились о том, что стандартные версии операции new мы не перегружаем.
[13:27.000 --> 13:33.000]  Если есть стандартная версия операции new, которая принимает только количество байт, то пусть она существует сама по себе.
[13:33.000 --> 13:35.000]  Какие есть еще варианты?
[13:35.000 --> 13:39.000]  На самом деле есть еще вариант написать свою собственную версию операции new.
[13:39.000 --> 13:42.000]  То есть такую версию операции new, которую в программе пока нет.
[13:42.000 --> 13:51.000]  Смотрите, на одном из слайдов я показал несколько стандартных форм операции new, которые уже в языке C++ существуют.
[13:51.000 --> 13:54.000]  В частности, это обычная версия, которая принимает только размер.
[13:54.000 --> 13:57.000]  Это версия, которая принимает дополнительный параметр null throw.
[13:57.000 --> 14:00.000]  И это версия, которая принимает дополнительный указатель.
[14:00.000 --> 14:05.000]  То есть вместо того, чтобы выделять память, эта версия операции new просто вернет указатель, который вы передали.
[14:05.000 --> 14:10.000]  То есть я хочу написать свою собственную версию операции new, которая тоже ведет себя каким-то особенным образом.
[14:10.000 --> 14:14.000]  Хорошая ность заключается в том, что это сделать возможно.
[14:14.000 --> 14:16.000]  И вот как.
[14:16.000 --> 14:22.000]  Допустим, я хочу написать свою версию операции new, которым дополнительным параметром принимает bool.
[14:22.000 --> 14:24.000]  Что она может делать?
[14:24.000 --> 14:26.000]  Она может либо печатать информацию на экране или нет.
[14:26.000 --> 14:29.000]  Давайте напишем, что если...
[14:29.000 --> 14:32.000]  Давайте параметры verbose.
[14:32.000 --> 14:41.000]  Если verbose, то давайте печатать сообщение на экран.
[14:41.000 --> 14:43.000]  Ну и тут тоже самое.
[14:43.000 --> 14:45.000]  Давайте пока delete оставим.
[14:45.000 --> 14:48.000]  Delete, чуть позже поговорим.
[14:48.000 --> 14:57.000]  Хочу собственную версию операции new, в которую я дополнительно могу передать, допустим, bool.
[14:57.000 --> 15:02.000]  Которая мне просто-напросто скажет, нужно ли печатать на экран сообщение или не нужно.
[15:02.000 --> 15:04.000]  Спечатать на экран сообщения.
[15:04.000 --> 15:06.000]  Вот.
[15:06.000 --> 15:09.000]  Соответственно, вот у меня есть операция new, которая дополнительно может принимать bool.
[15:09.000 --> 15:13.000]  Раньше такой версии в языке C++ не существовала, теперь она будет существовать.
[15:13.000 --> 15:15.000]  То есть теперь я могу ее спокойно вызывать.
[15:15.000 --> 15:20.000]  У меня есть структура A, и я выделяю просто-напросто память для одного элемента A.
[15:20.000 --> 15:24.000]  При этом заметьте, что так как у меня в языке C++ появилась дополнительная версия операции new,
[15:24.000 --> 15:27.000]  которая принимает bool, я могу в new передать значение bool, либо true, либо false.
[15:27.000 --> 15:33.000]  И в зависимости от этого у меня операция new будет вести себя тем или иным способом.
[15:33.000 --> 15:36.000]  Давайте еще посмотрим на эту реализацию.
[15:36.000 --> 15:37.000]  Что тут происходит?
[15:37.000 --> 15:41.000]  Тут я использую параметр verbose, либо печатаю, либо не печатаю сообщение на экран.
[15:41.000 --> 15:45.000]  Ну и дальше возвращаю выход из стандартной версии операции new.
[15:45.000 --> 15:50.000]  Вот эта двойная двойточь означает, что я хочу использовать глобальную функцию оператора new.
[15:50.000 --> 15:55.000]  И глобальная версия операции new просто-напросто принимает количество выделенных byte count.
[15:55.000 --> 15:58.000]  То есть вот эта операция new ведет себя так же, как и обычная операция new,
[15:58.000 --> 16:01.000]  просто-напросто дополнительно печатает сообщение на экран.
[16:01.000 --> 16:05.000]  Ну, давайте посмотрим, как она сработает.
[16:05.000 --> 16:10.000]  Так, custom new, out.
[16:10.000 --> 16:15.000]  И соответственно я вижу, что действительно я вызвал new с параметром true,
[16:15.000 --> 16:18.000]  и на экране появилось сообщение оператора new bool.
[16:18.000 --> 16:25.000]  Если я вызову с параметром false, то никакого сообщения на экране видно не будет.
[16:25.000 --> 16:27.000]  Да.
[16:27.000 --> 16:32.000]  А зачем нам указать?
[16:32.000 --> 16:36.000]  Ну смотрите, у меня new сам понимает, сколько памяти нужно выделить.
[16:36.000 --> 16:39.000]  То есть я тут говорю new, то есть мне нужно выделить память для хранения элемента типа A.
[16:39.000 --> 16:42.000]  Сколько byte в памяти занимает элемент типа A?
[16:48.000 --> 16:50.000]  Еще раз, вот тут зачем мы передаем?
[16:50.000 --> 16:53.000]  Ну потому что, смотрите, мы перегружаем функцию операции new,
[16:53.000 --> 16:57.000]  и функция операции new сама по себе должна знать, сколько byte ей нужно выделить памяти.
[16:57.000 --> 16:58.000]  Вот.
[16:58.000 --> 17:03.000]  Ну смотрите, вот тут, давайте я тут, может быть, не так прописал.
[17:03.000 --> 17:08.000]  В общем, смотрите, когда я вызываю какую-то произвольную версию операции new,
[17:08.000 --> 17:12.000]  в аргумент new передаются следующие параметры.
[17:12.000 --> 17:20.000]  В new передается size of t и arcs.
[17:21.000 --> 17:22.000]  Вот.
[17:22.000 --> 17:26.000]  То есть вот этот параметр count содержит size of выделяемого элемента.
[17:26.000 --> 17:27.000]  Понятно?
[17:27.000 --> 17:30.000]  Ну так я операцию new могу применять к типу t, к типу A, к типу B и так далее,
[17:30.000 --> 17:34.000]  то первый аргумент является параметром, он не является константой.
[17:34.000 --> 17:35.000]  Да?
[17:35.000 --> 17:40.000]  То есть я могу выделять элемент размером 8 byte, могу выделять элемент размером 16 byte и так далее.
[17:40.000 --> 17:45.000]  И вот этот count как раз таки хранит информацию о том, сколько byte нужно выделить для данного объекта.
[17:45.000 --> 17:50.000]  Нет, а какое значение по умолчанию должно быть?
[17:50.000 --> 17:53.000]  Вот я вам говорю, нужно выделить память для объекта.
[17:53.000 --> 17:56.000]  Какое значение по умолчанию должно быть?
[17:56.000 --> 17:58.000]  Size of чего?
[17:58.000 --> 18:00.000]  А какого объекта?
[18:00.000 --> 18:03.000]  Я же не знаю, какой объект я буду выделять.
[18:03.000 --> 18:09.000]  Я могу выделить память для объекта размера 16 byte, могу выделить память для объекта 28 byte и так далее.
[18:10.000 --> 18:18.000]  То есть еще раз, когда компилятор видит эту строчку, он вместо этой строчки подставляет вот эти две строчки.
[18:18.000 --> 18:23.000]  Первая строчка это вызов функции оператора new с первым параметром size of t, вторым параметром args.
[18:23.000 --> 18:25.000]  И наконец вызов конструктора.
[18:25.000 --> 18:28.000]  Вот этот size of t зависит от конкретного типа t.
[18:28.000 --> 18:30.000]  То есть это не константа.
[18:30.000 --> 18:36.000]  То есть в зависимости от того, для какого типа я выделяю память, там будет либо одно, либо второе, либо третье значение.
[18:36.000 --> 18:38.000]  Поэтому это параметр функции.
[18:38.000 --> 18:40.000]  Окей?
[18:40.000 --> 18:44.000]  Ключевой вопрос, который меня тут интересует, состоит в следующем.
[18:44.000 --> 18:48.000]  Ну смотрите, я написал версию операции new, которая принимает bool.
[18:48.000 --> 18:52.000]  Ну прекрасно, могу с ней играться, могу передавать true, могу передавать false и так далее.
[18:52.000 --> 18:53.000]  Все замечательно.
[18:53.000 --> 19:00.000]  Вопрос, зачем я написал функцию оператора delete, и вопрос, каким образом в операцию delete я могу передать аргумент.
[19:00.000 --> 19:02.000]  Кажется, что таким образом...
[19:02.000 --> 19:06.000]  Кстати, сейчас что-то засомневался, но кажется, таким образом я передавать ничего не могу.
[19:06.000 --> 19:11.000]  Да, смотрите, операция, точнее выражение delete не может принимать никаких аргументов.
[19:11.000 --> 19:14.000]  То есть в delete я не могу передавать никаких параметров.
[19:14.000 --> 19:18.000]  Но при этом возможность создавать свои собственные версии оператора delete существует.
[19:18.000 --> 19:20.000]  Вопрос, зачем?
[19:20.000 --> 19:24.000]  И ответ заключается в следующем.
[19:24.000 --> 19:29.000]  Свои версии операции delete нужны для того, чтобы решать довольно специфические проблемы.
[19:29.000 --> 19:35.000]  Давайте я исправлю этот код и напишу тут что-то наподобие такого.
[19:36.000 --> 19:41.000]  Подробно про оператора throw мы с вами не говорили, но так или иначе его встречали в заданиях.
[19:41.000 --> 19:46.000]  Оператор throw просто говорит в том, что в данном месте нужно вызвать ошибку.
[19:46.000 --> 19:48.000]  Короче, в чем пример?
[19:48.000 --> 19:53.000]  Пример состоит в том, что если у меня в процессе вызова конструктора произошла какая-то ошибка.
[19:53.000 --> 19:56.000]  Давайте посмотрим, что произойдет.
[19:56.000 --> 20:02.000]  Я вызываю new для элемента a.
[20:02.000 --> 20:06.000]  Вызывается функция оператора new, которая просто-напросто выделяет память.
[20:06.000 --> 20:08.000]  На этом этапе ничего плохого пока не происходит.
[20:08.000 --> 20:11.000]  Если у нас памяти достаточно, то на этом этапе ничего плохого не происходит.
[20:11.000 --> 20:13.000]  Согласны?
[20:13.000 --> 20:18.000]  Теперь опять функция оператора new выделила память.
[20:18.000 --> 20:24.000]  И дальше по этому месту в памяти компилятор пытается создать объект.
[20:24.000 --> 20:28.000]  Создать объект, естественно, с помощью того самого конструктора.
[20:28.000 --> 20:32.000]  Но в процессе создания объекта возникла проблема.
[20:32.000 --> 20:34.000]  Что это означает?
[20:34.000 --> 20:38.000]  Это означает, что вызов поражения new совершился неуспешно.
[20:42.000 --> 20:44.000]  И какая проблема у нас возникла?
[20:50.000 --> 20:52.000]  Да, утечка памяти.
[20:52.000 --> 20:54.000]  Смотрите, у меня объект не создался.
[20:54.000 --> 20:56.000]  Возникла какая-то ошибка.
[20:56.000 --> 21:01.000]  Допустим, эту ошибку я как-то смог погасить, а как-то смог ее обработать.
[21:01.000 --> 21:04.000]  Но вопрос заключается в следующем.
[21:04.000 --> 21:06.000]  Смотрите, выражение new завершилось неуспешно.
[21:06.000 --> 21:10.000]  Если выражение new завершилось неуспешно, то значит оно не вернуло никакого значения.
[21:10.000 --> 21:16.000]  А если оно не вернуло никакого значения, то я не смог получить указатель для этой функции.
[21:16.000 --> 21:17.000]  Согласны?
[21:17.000 --> 21:19.000]  Точнее, которая получена из этой функции.
[21:19.000 --> 21:22.000]  То есть, функция оператора new отработала корректно.
[21:22.000 --> 21:24.000]  Вот, выделилась память.
[21:24.000 --> 21:26.000]  На нее есть какой-то указатель.
[21:26.000 --> 21:31.000]  Я попытался создать элемент t тут, но все прошло неуспешно.
[21:31.000 --> 21:34.000]  Раз все прошло неуспешно, то выражение new прошло неуспешно.
[21:34.000 --> 21:36.000]  Значит, выражение new ничего не вернуло.
[21:36.000 --> 21:40.000]  Но раз выражение new ничего не вернуло, то я не смогу освободить вот эту самую память.
[21:40.000 --> 21:42.000]  Понятно?
[21:42.000 --> 21:47.000]  И вот тут, в общем, возникает следующий момент.
[21:47.000 --> 21:55.000]  Тут возникает единственное место в C++, когда C++ сам самостоятельно вызывает операцию delete.
[21:55.000 --> 21:57.000]  Правило такое.
[21:57.000 --> 22:20.000]  Если вызов конструктора завершился неуспешно, то память, выделенная
[22:20.000 --> 22:39.000]  на первом шаге, освобождается автоматически.
[22:39.000 --> 22:43.000]  То есть, вызвалась функция операции new.
[22:43.000 --> 22:49.000]  И если на втором шаге возникла проблема, то компилятор естественно понимает,
[22:49.000 --> 22:53.000]  что если на втором шаге возникла проблема, то у нас самостоятельно не будет никакой возможности
[22:53.000 --> 22:56.000]  получить этот указатель и освободить эту память.
[22:56.000 --> 23:02.000]  И поэтому вот тут и вот только тут компилятор самостоятельно вызовет функцию operator delete.
[23:02.000 --> 23:08.000]  То есть он вызовет функцию operator delete.
[23:08.000 --> 23:11.000]  Вопрос, какую функцию operator delete вызовет компилятор?
[23:11.000 --> 23:13.000]  И ответ заключается в следующем.
[23:13.000 --> 23:15.000]  Смотрите.
[23:15.000 --> 23:18.000]  Давайте еще раз я скомпилирую программу.
[23:18.000 --> 23:20.000]  Так, только...
[23:20.000 --> 23:22.000]  Ладно, спойлер.
[23:22.000 --> 23:24.000]  Прошу прощения.
[23:24.000 --> 23:26.000]  Вот, смотрите.
[23:26.000 --> 23:29.000]  Когда у меня все проходит отлично, когда у меня все проходит хорошо,
[23:29.000 --> 23:33.000]  без каких-либо ошибок, у меня тут компилятор вызывает функцию operator news,
[23:33.000 --> 23:35.000]  которая принимает Bool.
[23:35.000 --> 23:38.000]  Тут компилятор вызывает функцию operator delete, которая не принимает Bool.
[23:38.000 --> 23:41.000]  Тут он вызывает стандартную функцию operator delete.
[23:41.000 --> 23:46.000]  Но если второй шаг пошел не по плану, то компилятор вызовет operator delete,
[23:46.000 --> 23:51.000]  который принимает PTR и исходный набор аргументов,
[23:51.000 --> 23:54.000]  которые вы передавали ему new.
[23:54.000 --> 23:56.000]  Окей?
[23:58.000 --> 24:02.000]  То есть компилятор будет пытаться искать функцию operator delete,
[24:02.000 --> 24:05.000]  который принимает ровно такой же набор параметров,
[24:05.000 --> 24:07.000]  то исходный new.
[24:07.000 --> 24:09.000]  Для чего это нужно?
[24:09.000 --> 24:13.000]  Ну, смотрите, если вы написали какую-то нестандартную версию операции new,
[24:13.000 --> 24:17.000]  то, скорее всего, она каким-то нестандартным образом выделяет память.
[24:17.000 --> 24:20.000]  А раз она каким-то нестандартным образом выделяет память,
[24:20.000 --> 24:22.000]  то, соответственно, при очищении памяти компилятор думает,
[24:22.000 --> 24:25.000]  что ее тоже нужно ощущать нестандартным образом.
[24:25.000 --> 24:29.000]  Поэтому он будет искать именно вот эту версию функции operator delete.
[24:29.000 --> 24:31.000]  Ну, давайте посмотрим.
[24:31.000 --> 24:34.000]  Вот если у меня конструктор завершился неуспешно,
[24:34.000 --> 24:36.000]  row 1,
[24:38.000 --> 24:40.000]  то что произошло?
[24:40.000 --> 24:42.000]  Я бы пытался выделить память с помощью new.
[24:42.000 --> 24:45.000]  Отработал operator new, который работает с bool.
[24:45.000 --> 24:48.000]  Дальше при создании объекта a у меня возникла ошибка.
[24:48.000 --> 24:51.000]  Компилятор понял, что на втором этапе возникла ошибка,
[24:51.000 --> 24:53.000]  и ему нужно каким-то образом выделять,
[24:53.000 --> 24:55.000]  которая ранее была выделена под этот объект.
[24:55.000 --> 24:58.000]  И тут, именно в этот момент, он вызвал функцию operator delete,
[24:58.000 --> 25:00.000]  которая принимает bool.
[25:00.000 --> 25:03.000]  Причем функцию, которая принимает true,
[25:03.000 --> 25:05.000]  потому что в исходный new я передавал true.
[25:05.000 --> 25:07.000]  Понятно?
[25:07.000 --> 25:09.000]  Если в исходный new я буду передавать false,
[25:09.000 --> 25:14.000]  то в исходный delete тоже будет передаваться false.
[25:14.000 --> 25:16.000]  То есть все пусто.
[25:23.000 --> 25:25.000]  Поэтому правило.
[25:25.000 --> 25:29.000]  Если вы реализовали свою собственную версию операции new
[25:29.000 --> 25:31.000]  со своим собственным набором параметров,
[25:31.000 --> 25:34.000]  то вы обязаны реализовать свою собственную версию операции delete
[25:34.000 --> 25:36.000]  с тем же набором параметров.
[25:36.000 --> 25:38.000]  Почему?
[25:38.000 --> 25:41.000]  Потому что если вдруг при вызове вашей версии операции new
[25:41.000 --> 25:44.000]  кто-то в конструкторе пойдет не так,
[25:44.000 --> 25:47.000]  то компилятор просто не сможет очистить эту самую память,
[25:47.000 --> 25:49.000]  которая была выделена ранее.
[25:49.000 --> 25:51.000]  Понятно?
[25:51.000 --> 25:55.000]  Это для каскадной операции.
[25:55.000 --> 25:57.000]  То есть если выделяем объект,
[25:57.000 --> 26:00.000]  кто-то начинает создавать первое bool
[26:00.000 --> 26:02.000]  по новому конструктору.
[26:02.000 --> 26:04.000]  И получается...
[26:04.000 --> 26:07.000]  Если вообще что-то тут пошло не так,
[26:07.000 --> 26:10.000]  то если второй этап завершился неуспешно,
[26:10.000 --> 26:12.000]  то все откатывается назад.
[26:12.000 --> 26:14.000]  То есть мы пытаемся очистить выделенную память.
[26:14.000 --> 26:17.000]  И весь new считается, что он завершился неуспешно.
[26:17.000 --> 26:20.000]  То есть он ничего не выделял, ничего не создавал.
[26:20.000 --> 26:23.000]  То есть даже если получается один new был другой new,
[26:23.000 --> 26:25.000]  и потом все эти new...
[26:25.000 --> 26:28.000]  Самое главное, что если во втором шаге пошло что-то не так,
[26:28.000 --> 26:30.000]  то не важно в самом конструкторе
[26:30.000 --> 26:32.000]  или функции, которые вызывал конструктор,
[26:32.000 --> 26:34.000]  которые вызывал там функцию и так далее.
[26:34.000 --> 26:36.000]  Это все равно считается ошибкой,
[26:36.000 --> 26:38.000]  что ошибка произошла здесь.
[26:38.000 --> 26:40.000]  Да.
[26:44.000 --> 26:46.000]  Так, ну...
[26:46.000 --> 26:48.000]  Я подозреваю, что просто-напросто
[26:48.000 --> 26:50.000]  ничего не должно скомпилироваться.
[26:50.000 --> 26:52.000]  Нет, компилируется.
[26:52.000 --> 26:54.000]  Ну, скорее всего просто-напросто
[26:54.000 --> 26:56.000]  не вызовется delete.
[26:56.000 --> 26:58.000]  И все.
[26:58.000 --> 27:00.000]  Короче, если компилятор не найдет
[27:00.000 --> 27:02.000]  следующую версию операции delete,
[27:02.000 --> 27:04.000]  он просто-напросто его не вызовет.
[27:04.000 --> 27:06.000]  Да.
[27:14.000 --> 27:16.000]  Если вы задаете объект на стеке,
[27:16.000 --> 27:18.000]  что произойдет при вызове исключения в конструкторе?
[27:18.000 --> 27:20.000]  Про это мы буквально через несколько минут
[27:20.000 --> 27:22.000]  перейдем к исключениям.
[27:22.000 --> 27:24.000]  Про это поговорим.
[27:26.000 --> 27:28.000]  Так, есть ли еще вопросы?
[27:28.000 --> 27:30.000]  Да.
[27:42.000 --> 27:44.000]  Нет, он size of t принимает
[27:44.000 --> 27:46.000]  всегда...
[27:46.000 --> 27:48.000]  Нет, он всегда принимает size of t.
[27:48.000 --> 27:50.000]  То есть new всегда принимает как минимум
[27:50.000 --> 27:52.000]  один аргумент, и это размер
[27:52.000 --> 27:54.000]  самого элемента. Нет, это размер вы можете
[27:54.000 --> 27:56.000]  проигнорировать. То есть вы можете написать size of size t
[27:56.000 --> 27:58.000]  и никак не использовать этот параметр.
[27:58.000 --> 28:00.000]  Но с size of t он всегда принимает.
[28:00.000 --> 28:02.000]  Ровно как и оператор delete, всегда принимает указатель
[28:02.000 --> 28:04.000]  к первому аргументу.
[28:14.000 --> 28:16.000]  В смысле, вот так?
[28:16.000 --> 28:18.000]  Если вот это убрать...
[28:20.000 --> 28:22.000]  Нет, он просто скажет, что такую версию оператора new
[28:22.000 --> 28:24.000]  существовать не может. Оператор new всегда
[28:24.000 --> 28:26.000]  принимает в качестве первого параметра.
[28:32.000 --> 28:34.000]  Ну и последний способ.
[28:34.000 --> 28:36.000]  Смотрите, вот в первом примере
[28:36.000 --> 28:38.000]  я показал, что можно перегрузить глобальную версию
[28:38.000 --> 28:40.000]  операции new, но сказал, что
[28:40.000 --> 28:42.000]  этого делать не стоит, потому что если вы перегрузите
[28:42.000 --> 28:44.000]  глобальную версию операции new,
[28:44.000 --> 28:46.000]  то она изменится во всей программе, и скорее всего
[28:46.000 --> 28:48.000]  это приведет к нежелательным эффектам.
[28:48.000 --> 28:50.000]  В общем, в той программе,
[28:50.000 --> 28:52.000]  которую я демонстрировал, которая просто нам запечатает сообщение
[28:52.000 --> 28:54.000]  на экран, скорее всего вы при работе с
[28:54.000 --> 28:56.000]  вектором будете видеть кучу сообщений,
[28:56.000 --> 28:58.000]  по типу того, что вектор выделил память, там вектор очистил память,
[28:58.000 --> 29:00.000]  вектор выделил память, и так далее, и так далее.
[29:02.000 --> 29:04.000]  Первый способ, поэтому первый способ
[29:04.000 --> 29:06.000]  глобально не подходит. Второй способ
[29:06.000 --> 29:08.000]  это написать свою версию операции new и вызывать его тогда,
[29:08.000 --> 29:10.000]  когда вам нужно какое-то особенное поведение
[29:10.000 --> 29:12.000]  для функции операции new.
[29:12.000 --> 29:14.000]  И наконец, третий способ, как можно перегрузить
[29:14.000 --> 29:16.000]  операцию new, это перегрузить операцию
[29:16.000 --> 29:18.000]  new для конкретного типа.
[29:18.000 --> 29:20.000]  То есть представьте себе, что
[29:20.000 --> 29:22.000]  у вас есть собственный класс, и вы хотите,
[29:22.000 --> 29:24.000]  чтобы объекты этого класса, то есть, когда я выделяю память
[29:24.000 --> 29:26.000]  с помощью new для обьектов этого класса
[29:26.000 --> 29:28.000]  я хочу, чтобы они выделялись каким-то особенным образом.
[29:28.000 --> 29:30.000]  То есть ну не знаю, я хочу сохранять информацию
[29:30.000 --> 29:32.000]  в каком-то журнале, в компентros.reet, мол, ну что
[29:32.000 --> 29:34.000]  пылесос на эти элементы,
[29:34.000 --> 29:36.000]  ну не знаю, либо я хочу, чтобы память
[29:36.000 --> 29:38.000]  для этих объектов выделялась каким-то особенным образом,
[29:38.000 --> 29:40.000]  например, хочу, чтобы для этих элементов выделялась
[29:40.000 --> 29:42.000]  чуть больше памяти, чем нужно.
[29:42.000 --> 29:44.000]  Либо просто Sue
[29:44.000 --> 29:46.000]  хочу запретить создавать данных объектов
[29:46.000 --> 29:48.620]  динамической памяти. Вот как это можно сделать.
[29:48.620 --> 29:52.300]  Смотрите, чтобы перегрузить операцию new для конкретного
[29:52.300 --> 29:57.740]  типа, я должен в структуре или классе написать статический
[29:57.740 --> 30:01.340]  метод operator new или operator delete, в зависимости от того,
[30:01.340 --> 30:04.700]  что вы хотите перегрузить. В данной структуре A я написал
[30:04.700 --> 30:07.900]  статический метод operator new, который принимает CisT, возвращает
[30:07.900 --> 30:12.020]  вводится за звездой, и соответствующий operator new с квадратными скобками,
[30:12.020 --> 30:14.660]  и написал равно delete. На самом деле, я мог написать
[30:14.660 --> 30:16.640]  произвольную реализацию, тут я привожу пример, как
[30:16.640 --> 30:19.600]  запретить выделять динамическую память для своего собственного
[30:19.600 --> 30:25.520]  класса. Я реализовал операции new и операции delete, просто
[30:25.520 --> 30:27.600]  операции new и операции new с квадратными скобками,
[30:27.600 --> 30:30.800]  но определил их как удаленные. К чему это приведет? Это
[30:30.800 --> 30:32.840]  приведет к тому, что компилятор попытается... Компилятор,
[30:32.840 --> 30:35.200]  во-первых, увидит, что для своего собственного класса
[30:35.200 --> 30:39.440]  A перегружена своя версия операции new, он попытается
[30:39.440 --> 30:41.560]  ее вызвать, но когда он будет ее пытаться вызывать,
[30:41.560 --> 30:44.000]  он увидит, что эта версия функции удаленной, и поэтому
[30:44.000 --> 30:47.300]  он скажет, что такую версию функции просто вызывать
[30:47.300 --> 30:54.300]  нельзя. Думаю, пример более-менее понятен. Я пытаюсь компилировать
[30:54.300 --> 30:56.180]  эту программу, и программа не компилируется. Почему?
[30:56.180 --> 31:03.780]  Потому что я запретил выделять объекты типа A в динамической
[31:03.780 --> 31:12.560]  памяти. Можно привести другой пример, показать, что, если
[31:12.560 --> 31:15.600]  по-нормальному их реализовать, то все сработает. Давайте
[31:15.600 --> 31:32.920]  просто тоже выведем информацию о том, что класс A выделил
[31:32.920 --> 31:46.020]  аккаунт памяти. В качестве выделителя памяти воспользуемся
[31:46.020 --> 32:05.520]  глобальной версией оператора new.
[32:05.520 --> 32:23.540]  Тут я сказал, что нужно использовать глобальную версию операции
[32:23.540 --> 32:26.340]  new. В операции new с квадратным скопом я сказал, что воспользуйся
[32:27.340 --> 32:38.320]  операцией new, которая определена внутри структуры A. Для объекта
[32:38.320 --> 32:42.700]  типа A был выделен 1 байт памяти, и для объекта типа A был выделено
[32:42.700 --> 32:52.160]  10 байт памяти. Кстати, когда я вызывал new с квадратными
[32:52.160 --> 32:55.060]  скопками, почему компилятор не стал добавлять лишние
[32:55.060 --> 32:58.560]  8 байт? Ответ заключается в том, что компилятор добавляет
[32:58.560 --> 33:00.840]  лишние 8 байт только для классов и структур, у которых нетривиальный
[33:00.840 --> 33:05.680]  конструктор, который что-то делает. У меня тут обычная
[33:05.680 --> 33:10.580]  структура, у нее ничего в диструктуре нетривиального
[33:10.580 --> 33:13.760]  делать не нужно, поэтому new с квадратными скопками не
[33:13.760 --> 33:16.100]  сохраняет эту информацию, просто отчищает память.
[33:16.100 --> 33:33.820]  Если вы хотите запретить создавать ваши объекты в динамической
[33:33.820 --> 33:34.820]  памяти.
[33:34.820 --> 33:46.140]  Например, вы хотите просто гарантировать, что объекты
[33:46.140 --> 33:51.500]  создают каким-то особенным образом. Например, вы хотите
[33:51.500 --> 33:53.820]  написать какой-нибудь особенный сингл тон, который должен
[33:53.820 --> 33:58.440]  обязательно храниться на стэке или в глобальной области,
[33:58.440 --> 34:01.420]  и вы хотите не дать никакой возможности создавать элементы
[34:01.420 --> 34:03.620]  в динамической памяти. Почему это может быть нужно?
[34:04.420 --> 34:08.420]  Вы можете написать как защиту от дурака. Объект можно
[34:08.420 --> 34:11.380]  создать на стэке в глобальной области и в динамической
[34:11.380 --> 34:14.020]  памяти, но при этом вы хотите явно подчеркнуть, что в
[34:14.020 --> 34:16.500]  динамической памяти этот объект создавать просто
[34:16.500 --> 34:20.940]  не стоит, потому что этот объект обладает высоким
[34:20.940 --> 34:22.780]  требованием по эффективности, а обращаться к динамической
[34:22.780 --> 34:25.180]  памяти в этом случае будет довольно-таки долго. Поэтому
[34:25.180 --> 34:27.980]  вы можете просто явно в коде прописать, что имеет
[34:27.980 --> 34:30.020]  смысл создавать только на стэке. Вот, например,
[34:30.020 --> 34:42.260]  таким образом. Нет, смотрите, вот тут мы сохраняли размер
[34:42.260 --> 34:48.540]  только для того, чтобы дилит понял, сколько деструкторов
[34:48.540 --> 34:51.380]  ему нужно вызвать. При этом естественная информация
[34:51.380 --> 34:54.380]  о количестве выделенных байт, она ему доступна.
[34:54.780 --> 35:00.780]  Это мы показывали в той версии. Сейчас, может, прокрутим.
[35:02.780 --> 35:06.780]  В одной из версий функций я показывал, что операция
[35:06.780 --> 35:09.780]  дилит может принимать дополнительный параметр count,
[35:09.780 --> 35:11.780]  и в этот параметр count будет передаваться количество
[35:11.780 --> 35:14.780]  байт, которое было заранее выделено. Но так как тут
[35:14.780 --> 35:17.780]  ничего, кроме того, чтобы просто очищать память, не
[35:17.780 --> 35:19.780]  нужно делать, поэтому эта информация просто не
[35:19.780 --> 35:24.780]  сохраняется. Есть ли еще вопросы?
[35:24.780 --> 35:25.780]  Да.
[35:25.780 --> 35:38.780]  Ну, тривиальный конструктор... Ну, смотрите, вообще говоря,
[35:38.780 --> 35:40.780]  если вы написали что-то типа...
[35:40.780 --> 35:49.780]  то компилятор вполне себе может определить этот деструктор
[35:49.780 --> 35:52.780]  как тривиальный. Не тривиальным деструктором считается
[35:52.780 --> 35:57.780]  деструктор, который имеет какое-то тело, пусть даже
[35:57.780 --> 36:00.780]  пустое. Если у конструктора, если у деструктора есть
[36:00.780 --> 36:05.780]  тело, даже пустое, то деструктор перестает считаться
[36:05.780 --> 36:10.780]  тривиальным. То есть тривиальным деструктор может объявить
[36:10.780 --> 36:14.780]  только компилятор. То есть либо так, либо если вы совсем
[36:14.780 --> 36:20.780]  не написали деструктор. Ну и то, если деструктор действительно
[36:20.780 --> 36:24.780]  ничего не делает. Есть один пункт, про который хотелось
[36:24.780 --> 36:27.780]  поговорить, причем достаточно давно. Давайте поговорим
[36:27.780 --> 36:32.780]  сейчас. Поговорим про некоторые странности-оптимизации,
[36:32.780 --> 36:37.780]  которая делает компилятор. Давай посмотрим на следующий
[36:37.780 --> 36:42.780]  код. Код очень простой. Есть структура А, которая просто
[36:42.780 --> 36:45.780]  лагирует информацию о том, что она делает. Вызывается
[36:45.780 --> 36:48.780]  дефолтный конструктор, она печатает дефолт-конструктор.
[36:48.780 --> 36:50.780]  Если вызывается конструктор копирования, она говорит
[36:50.780 --> 36:52.780]  конструктор копирования. Если вызывается перемещающий
[36:52.780 --> 36:55.780]  пресвам cerca aiming, значит и так далее…
[36:55.780 --> 36:59.780]  Давайте посмотрим на то, как выглядит мэйн. Что происходит?
[36:59.780 --> 37:07.780]  Тут, в общем, код разделён на несколько блоков, значит, в первом блоке у меня происходит следующее, вроде как должно происходить.
[37:07.780 --> 37:14.780]  Вызывается дефолтный конструктор, потом вызывается копирующий конструктор, AB равно A, тут создаётся копия.
[37:14.780 --> 37:18.780]  И когда я пишу A равно B, тоже вызывается копирущее присваивание.
[37:18.780 --> 37:21.780]  Значит, смотрим, что происходит на экране, действительно, всё так и происходит.
[37:21.780 --> 37:23.780]  Ну, ничего интересного пока.
[37:23.780 --> 37:30.780]  Дальше, смотрим на первый блок, в нём вызывается дефолтный конструктор, в нём вызывается конструктор перемещения, в нём вызывается перемещающее присваивание.
[37:30.780 --> 37:33.780]  Вот, тоже всё отлично, никаких приколов нет.
[37:33.780 --> 37:35.780]  Теперь идём в пункт номер два.
[37:35.780 --> 37:39.780]  И вот тут начинаются некоторые странности.
[37:39.780 --> 37:43.780]  Смотрите, что происходит в 53-й строчке.
[37:43.780 --> 37:50.780]  Вот, вообще говоря, если действовать строго по букве закона C++, то тут должно происходить следующее.
[37:50.780 --> 37:55.780]  Сначала... Ну, то есть тут создаётся объект типа A.
[37:55.780 --> 38:00.780]  Но при этом, перед этим сначала справа создаётся временный объект A с помощью дефолтного конструктора.
[38:00.780 --> 38:01.780]  Согласны?
[38:01.780 --> 38:05.780]  То есть, справа создаётся объект с помощью дефолтного конструктора, то есть вызывается дефолтный конструктор.
[38:06.780 --> 38:11.780]  Затем создаётся объект A, и так как объект A видит, что справа от знака равно стоит временный объект,
[38:11.780 --> 38:16.780]  то этот временный объект перемещается в создаваемый объект A.
[38:16.780 --> 38:19.780]  То есть в этой строчке должен вызываться дефолтный конструктор,
[38:19.780 --> 38:22.780]  конструктор перемещения. Согласны?
[38:22.780 --> 38:25.780]  Что должно происходить в 54 строчке?
[38:25.780 --> 38:28.780]  В 54 строчке примерно то же самое с точностью того, что конструктор
[38:28.780 --> 38:31.780]  заменяется на вызов операции присваивания.
[38:31.780 --> 38:35.780]  Давайте посмотрим, что на самом деле происходит.
[38:35.780 --> 38:38.780]  На самом деле мы видим, что вызывается
[38:38.780 --> 38:42.780]  два дефолтных конструктора
[38:42.780 --> 38:45.780]  и всего лишь одно перемещающее присваивание.
[38:45.780 --> 38:51.780]  То есть куда-то делается перемещающий конструктор.
[38:51.780 --> 38:54.780]  То есть в этой программе всего лишь один раз
[38:54.780 --> 38:57.780]  был создан дефолтный объект.
[38:57.780 --> 39:00.780]  Точнее, был создан дефолтный объект вот тут,
[39:00.780 --> 39:03.780]  был создан дефолтный объект тут, и затем было перемещение.
[39:03.780 --> 39:06.780]  Давайте пойдем дальше.
[39:06.780 --> 39:09.780]  Посмотрим на группу №3.
[39:09.780 --> 39:12.780]  Тут у меня есть функция f, которая просто возвращает объект типа a.
[39:12.780 --> 39:15.780]  Функция f возвращает объект типа a,
[39:15.780 --> 39:18.780]  создает его в ретерн-операторе и его возвращает.
[39:18.780 --> 39:21.780]  Что тут происходит? Я пишу a равно f.
[39:21.780 --> 39:24.780]  То есть я создаю a, с помощью резидента вызову функции f.
[39:24.780 --> 39:27.780]  Что должно происходить?
[39:27.780 --> 39:30.780]  Тут, скорее всего, должно происходить следующее.
[39:30.780 --> 39:33.780]  Функция f создает временный объект, и дальше этот временный объект
[39:33.780 --> 39:36.780]  должен переместиться в объект типа a. Согласны?
[39:36.780 --> 39:39.780]  Как в первой, так и во второй строчке.
[39:39.780 --> 39:42.780]  В первой строчке №59 вызывается только один дефолтный конструктор,
[39:42.780 --> 39:45.780]  при этом никакого перемещения не происходит.
[39:45.780 --> 39:48.780]  Тоже какая-то странность.
[39:48.780 --> 39:51.780]  То есть куда-то делась дополнительная операция,
[39:51.780 --> 39:54.780]  которую мы вроде как ожидали.
[39:54.780 --> 39:57.780]  В строчке №4 странности еще больше.
[39:57.780 --> 40:00.780]  Давайте посмотрим на определение функции g.
[40:00.780 --> 40:03.780]  Как устроена функция g?
[40:03.780 --> 40:06.780]  Функция g устроена следующим образом.
[40:06.780 --> 40:09.780]  И потом возвращает его наружу.
[40:09.780 --> 40:12.780]  Как выглядит внешний код?
[40:12.780 --> 40:15.780]  Внешний код выглядит так. Я вызываю функцию g,
[40:15.780 --> 40:18.780]  и результат вызова функции g сохраняю в переменную a.
[40:18.780 --> 40:21.780]  Что тут должно происходить? Сначала вызывается функция g.
[40:21.780 --> 40:24.780]  Когда вызывается функция g,
[40:24.780 --> 40:27.780]  внутри нее создается объект a с помощью дефолтного конструктора.
[40:27.780 --> 40:30.780]  Согласны?
[40:30.780 --> 40:33.780]  Вот функция g. Согласны?
[40:33.780 --> 40:36.780]  Значит вызывается функция g, создается а с помощью дефолтного конструктора.
[40:36.780 --> 40:39.780]  Что происходит дальше?
[40:39.780 --> 40:42.780]  Этот объект возвращается наружу.
[40:42.780 --> 40:45.780]  Раз это объект возвращается наружу,
[40:45.780 --> 40:48.780]  то этот объект возвращается наружу
[40:48.780 --> 40:51.780]  с помощью перемещения.
[40:51.780 --> 40:54.780]  Из функции g объект должен переместиться сюда
[40:54.780 --> 40:57.780]  с помощью перемещения.
[40:57.780 --> 41:00.780]  А вот этот временный объект, который образовался здесь,
[41:00.780 --> 41:06.580]  на самом деле происходит. А на самом деле произошло следующее. На самом деле, так, не тот
[41:06.580 --> 41:10.380]  пример, на самом деле тут снова всего лишь был вызван только один дефолтный
[41:10.380 --> 41:14.700]  конструктор. То есть при создании объекта типа A был вызван
[41:14.700 --> 41:18.420]  всего лишь один дефолтный конструктор. Но, погодите, кажется, что тут должно было
[41:18.420 --> 41:22.260]  быть как минимум три конструктора. Почему? Потому что, смотрите, функция g
[41:22.260 --> 41:26.860]  создает элемент. Вот этот вызов функции g создает элемент.
[41:27.740 --> 41:32.300]  Вот, то есть элемент должен быть создаться здесь, элемент должен создаться здесь, и
[41:32.300 --> 41:35.240]  элемент должен быть создаться здесь либо с помощью копирования, либо с помощью
[41:35.240 --> 41:38.100]  перемещения. Но, при этом, я вижу, что в примере номер четыре, всего было
[41:38.100 --> 41:44.980]  вызвано всего лишь два дефолтных конструктора. Вот. Вопрос, как так? Куда
[41:44.980 --> 41:48.100]  деваются вот эти самые дополнительные перемещения, куда деваются дополнительные
[41:48.100 --> 41:54.260]  копирования? И вот тут ответом на вопрос, служат словосочетания, копии и
[41:54.260 --> 42:01.620]  служит в словосочетании копия и лижен. Что такое копия и лижен? Смотрите, копия и
[42:01.620 --> 42:06.020]  лижен — это особая оптимизация компилятора, которая позволяет в некоторых
[42:06.020 --> 42:12.420]  ситуациях избежать лишних копирований или перемещений. Вот. В каких случаях, в каких
[42:12.420 --> 42:16.620]  случаях может применяться копия и лижен? Ну, смотрите.
[42:18.300 --> 42:22.780]  Вот когда я написал вот так, еще раз повторю, что с точки зрения там буквы
[42:22.780 --> 42:27.180]  закона C++, тут должно происходить следующее. Сначала создается временный объект,
[42:30.580 --> 42:34.380]  а потом этот временный объект должен использоваться в качестве аргумента для
[42:34.380 --> 42:38.580]  конструктора перемещения А. Смотрите. Объект типа A создается на основу
[42:38.580 --> 42:41.640]  временного объекта. То есть, у меня сначала должен создаться временный объект,
[42:41.640 --> 42:45.840]  а потом переместиться в А. Но, согласитесь, это довольно странно, что я создаю
[42:45.840 --> 42:49.420]  временный объект, а потом его перемещаю. Тут бы было гораздо более разумно
[42:49.420 --> 42:55.500]  сразу создать нужный элемент, вопременный a. И ровно это и происходит, ровно этим
[42:55.500 --> 42:59.900]  занимается копия elision. То есть копия elision приводит к тому, что вот это вот лишнее
[42:59.900 --> 43:03.380]  копирование или лишнее перемещение просто не происходит. То есть вот этот вот временный
[43:03.380 --> 43:12.060]  объект создается сразу в нужном месте программы. Понятно? Что еще подходит под
[43:12.060 --> 43:19.340]  определение копии elision. Под определение копии elision подходит следующее. Представь себе, что у
[43:19.340 --> 43:32.060]  меня есть пункция f, которая возвращает временный объект. Ну казалось бы, что тут должно происходить.
[43:32.060 --> 43:35.100]  Так как у меня вызывается пункция f, так как она создает временный объект, то я должен сначала
[43:35.100 --> 43:40.180]  создать этот самый временный объект. Этот временный объект должен каким-то образом очутиться
[43:40.180 --> 43:43.940]  вот тут, ну не важно, с помощью копирования или перемещения. И дальше объект типа a должен
[43:43.940 --> 43:52.100]  создаться на основе вот этого самого временного объекта. То есть компилятор должен вызвать
[43:52.100 --> 43:59.260]  дефолтный конструктор, дальше либо копирование, либо перемещение, и дальше тут перемещение. Но при
[43:59.260 --> 44:03.700]  этом мы с вами понимаем, что гораздо разумнее было бы поступить так. Смотрите, мы с вами понимаем,
[44:03.700 --> 44:08.100]  что a создается на основе временного объекта из f. Поэтому было бы разумнее пропустить второй шаг и
[44:09.020 --> 44:15.740]  просто-напросто пункция f сразу же вернуть объект с помощью копирования или перемещения в a. Это
[44:15.740 --> 44:19.500]  первая оптимизация. А вторая оптимизация заключается в следующем. Смотрите, зачем мне брать
[44:19.500 --> 44:25.020]  вот этот вот временный объект и, соответственно, создавать его где-то вот во временном месте в
[44:25.020 --> 44:29.660]  памяти? Если я могу взять вот этот вот объект и сразу же создать в нужном месте в памяти там,
[44:29.660 --> 44:36.180]  где находится a, согласны? Поэтому тут в этом контексте тоже будет вызван только один дефолтный
[44:36.180 --> 44:39.820]  конструктор. И все, больше никаких конструкторов вызваний не будет. Это тоже копия и лишен. То есть
[44:39.820 --> 44:46.820]  компилятор избавляется от лишних копирований и от лишних перемещений. Окей? И теперь, наконец,
[44:46.820 --> 44:53.140]  третий пример. Самый мозговоносящий. Смотрите, вот у меня есть объект a, точнее у меня есть
[44:53.140 --> 45:00.260]  функция g, которая внутри себя создает объект типа a. Она создает a, дальше с ним как-то работает,
[45:00.260 --> 45:15.780]  происходит, и в конце делает return a. Вот. И где-то в мэне я пишу следующий код. Аа равно g. Опять же,
[45:15.780 --> 45:21.780]  то тут вроде как должно происходить. Смотрите, если я вызываю функцию g, то у меня должна
[45:21.780 --> 45:25.980]  создаться объект типа a, потом я с ним как-то работаю, работаю, работаю, и потом вот этот
[45:25.980 --> 45:30.060]  объект типа a, который я создал тут, должен вернуться. Соответственно, тут первый вызывается
[45:30.060 --> 45:34.740]  дефолтный конструктор, дальше этот объект типа a я должен вернуть вместо вызова функции g каким-то
[45:34.740 --> 45:38.940]  образом, либо копированием, перемещением. А дальше вот этот объект a должен создаться на основе
[45:38.940 --> 45:43.820]  временного объекта, который вернулся из g. То есть третий. То есть у меня должно вызваться как минимум
[45:43.820 --> 45:48.140]  три конструктора. Конструктор, который вызывается внутри g, конструктор, который переместит вот
[45:48.140 --> 45:52.700]  этот объект a вместо вызова g, и соответственно конструктор, который из этого объекта, который
[45:52.700 --> 45:59.420]  вернул g, создаст a. Вот. Но что сделает компилятор? Компилятор выполнит следующую оптимизацию,
[45:59.420 --> 46:04.140]  скорее всего. Скорее всего, компилятор выполнит следующую оптимизацию. Он просто-напросто скажет,
[46:04.140 --> 46:08.860]  а зачем мне городить вот эти вот лишние создания, ну точнее вот эти вот лишние создания 2 и 3,
[46:08.860 --> 46:15.500]  если я могу просто-напросто взять вот этот вот объект и в качестве вот этого объекта использовать
[46:15.500 --> 46:25.540]  вот этот объект. То есть что сделает компилятор? Смотрите, у меня вот эта переменная a находится в
[46:25.540 --> 46:31.220]  функции main. Вот эта переменная a находится в функции g. Но для оптимизации компилятор может сказать,
[46:31.220 --> 46:36.780]  а давайте я буду считать, что вот этот объект и вот этот объект это одно и то же. То есть на самом
[46:36.780 --> 46:43.180]  деле функция g внутри себя будет использовать вот эту вот область памяти в качестве хранения
[46:43.180 --> 46:49.860]  результата. И вместо этого return a, функция g просто нам завершит работу, и вот в этом месте памяти
[46:49.860 --> 46:53.980]  уже будет храниться готовый объект. Понятно? Да.
[46:53.980 --> 47:00.620]  Получается, будет после вот всех выдавал функций, ну на стеке станет компилятор. То есть получается,
[47:00.620 --> 47:07.020]  там создается этот объект a, потом вызывает функция, ну получается стек отодвигается,
[47:07.020 --> 47:11.980]  потом происходит что-то там, ну он приоритически заполняется, потом стек выдавается, да, отодвигается,
[47:11.980 --> 47:17.340]  но все что было в функции почистилось. Или наоборот, он, функция выдавается, начинает создаваться,
[47:17.340 --> 47:25.220]  и он создает, получается, за тем местом, где будет, по сути, консервировать тековый фрейм.
[47:25.220 --> 47:30.060]  Нет, ну тут как все происходит? Тут скорее произойдет все так, что, ну смотрите, у меня тут
[47:30.060 --> 47:36.060]  создается переменная a, то есть у меня как бы есть стек, то есть тут есть переменная x, y, там z, t,
[47:36.060 --> 47:43.300]  и вот переменная a. Вот. Дальше вызывается функция g, создается тековый фрейм для функции g. Но функция g,
[47:43.300 --> 47:47.980]  когда будет обращаться к вот этой переменной a, она будет обращаться не к своему стековому
[47:47.980 --> 47:57.060]  фрейму, а к вот этому. То есть так как функция g знает, что ее, ну как бы, вот ее стек находится
[47:57.060 --> 48:04.180]  сразу же за стеком функции main, она знает смещение вот для этой переменной a. Ну и поэтому функция g
[48:04.180 --> 48:12.140]  сразу же напрямую может обращаться к элементу a. То есть смотрите, какая странная ситуация возникает.
[48:12.140 --> 48:23.460]  Вот мы с вами до этого говорили о том, что... Давайте вот тут обозначу по-другому. Пусть тут x,
[48:23.460 --> 48:30.300]  а вот эта переменная называется y. Ну смотрите, мы с вами говорили о том, что когда вызывается
[48:30.300 --> 48:37.740]  функция, вот у меня есть функция f, точнее вот функция main, в ней есть переменная y, и есть функция g,
[48:38.420 --> 48:43.180]  и функция g, и есть переменная x. Вот раньше мы говорили, что когда вызывается функция,
[48:43.180 --> 48:46.960]  переменные, которые находятся в функции g, никак не влияют на переменные
[48:46.960 --> 48:49.540]  которые находятся в других функциях, например функции main.
[48:49.540 --> 48:58.640]  Но тут вот в данной ситуации компилятор понимает, что единственное назначение вот этой переменной,
[48:58.640 --> 49:03.260]  в итоге оказаться в качестве значения вот этой переменной. И поэтому компилятор просто
[49:03.260 --> 49:06.800] łbyственно делает следующее. Он скажет, что а зачем мне в функции g создавать дополнительную
[49:06.800 --> 49:11.180]  если я могу воспользоваться, то есть если я могу создать переменную у вот эту и
[49:11.180 --> 49:16.720]  сразу же работать с ней и когда завершится в функции g, по завершении
[49:16.720 --> 49:21.200]  функции g у Main уже будет готовая перемена у, которая уже хранит тебе то самое значение,
[49:21.200 --> 49:28.960]  которое нужно. Понятно? То есть ресурсы на возврат значения из функции никакие не
[49:28.960 --> 49:33.360]  тратятся. Вот эти все оптимизации, которые избавляются от лишних перемещений
[49:33.360 --> 49:38.960]  копирований, в общем, вот эта оптимизация называется copy-elision.
[49:38.960 --> 49:42.320]  Вот. Более того, copy-elision, давайте посмотрим на такой пример,
[49:42.320 --> 49:48.160]  copy-elision работает даже тогда, когда у вас, у класса отсутствуют напрочь
[49:48.160 --> 49:50.320]  конструкторы копирования и конструктор перемещения.
[49:50.320 --> 49:56.120]  Смотрите, давайте приведу такие примеры. Вот у меня есть a, я создам a на
[49:56.240 --> 50:06.000]  основе вызова функции f. И дальше, допустим, сделаю вызов функции g. Вот a.
[50:06.000 --> 50:09.280]  Смотрите, у меня у класса напрочь отсутствуют конструкторы копирования и
[50:09.280 --> 50:14.920]  конструктор и при сваивании.50
[50:14.920 --> 50:18.100]  Но при этом, давайте, то есть снова, у меня отсутствует конструктор
[50:18.100 --> 50:25.680]  копирования и конструктор перемещения.
[50:25.680 --> 50:32.440]  Но при этом у меня получается, у меня есть возможность воспользоваться результатом вызова функции f и сохранить его в переменную a.
[50:46.680 --> 50:50.680]  Программа компилируется и программа работает.
[50:50.680 --> 51:01.680]  Даже несмотря на то, что функция f из себя возвращает временный объект, этот временный объект как-то из функции f должен оказаться в переменной a.
[51:01.680 --> 51:07.680]  Вопрос, как он там может оказаться? Либо копированием, либо перемещением. Копирование у нас запрещено, перемещение у нас запрещено.
[51:07.680 --> 51:11.680]  Как он там оказывается? Непонятно. Ответ – оптимизация компилятора.
[51:11.680 --> 51:19.680]  То есть компилятор избавляется от копирования перемещений и делает все возможное, чтобы объект в итоге переместился из одного места в другое место.
[51:19.680 --> 51:27.680]  И то же самое в функции g. Функция g принимает a по значению u. То есть я каким-то образом должен суметь передать в g аргумент типа a.
[51:27.680 --> 51:32.680]  Но смотрите, у a у меня отсутствует и конструктор копирования, и конструктор перемещения.
[51:32.680 --> 51:39.680]  Если у a у меня отсутствует и конструктор копирования и перемещения, кажется, что я не могу передавать параметры a в функцию по значению. Согласны?
[51:39.680 --> 51:44.680]  Потому что передать какой-то элемент по значению, он должен быть либо скопирован, либо перемещен.
[51:45.680 --> 51:53.680]  Но в случае, если я работаю со временным объектом, то есть я вызываю функцию g от временного объекта, то что должно происходить?
[51:53.680 --> 51:59.680]  То есть тут должен создаться временный объект, а потом этот временный объект должен переместиться в качестве параметра аргумента функции g.
[51:59.680 --> 52:07.680]  Но компилятор умный, и он понимает, что зачем мне делать эти лишние перемещения, если я могу взять вот этот временный объект и сразу же создать его в нужном месте.
[52:07.680 --> 52:15.680]  Поэтому вот тут компилятор воспринимает эту строчку так, что нужно создать аргумент g с помощью конструктора по умолчанию, и все. Никаких перемещений, никаких копирований делать не нужно.
[52:16.680 --> 52:18.680]  Понятно? Да.
[52:25.680 --> 52:34.680]  Я могу сделать a от a от a от a от f, наверное, могу. Да, вот.
[52:34.680 --> 52:46.680]  То есть, казалось бы, тут должно произойти следующее. Вызывается функция f, на основе вызова функции f создается a, на основе создания a создается другой a, на основе этого создается a, и в итоге воссоздается аргумент a.
[52:46.680 --> 52:55.680]  Но компилятор умный, он понимает, зачем мне вот это все городить, если в итоге получается так, что результат вызова функции f должен оказаться в аргументе функции g.
[52:55.680 --> 53:02.680]  И давайте проверим, что все компилируется. Все компилируется, даже несмотря на то, что у меня отсутствует и копирование, и перемещение.
[53:02.680 --> 53:13.680]  То есть, копия лижен говорит о следующем. Если у вас есть временный объект, и какая-то цепочка перемещений и копирований, которые приводят его в другой объект, то вот эта цепочка происходить не будет.
[53:13.680 --> 53:20.680]  Создание вот этого объекта сразу же будет происходить в том месте, где он требуется.
[53:20.680 --> 53:23.680]  Так, вопрос? Да.
[53:23.680 --> 53:41.680]  Смотрите, если цепочка работает, то она будет работать произвольно длиной. Тут есть вопрос в том, когда это на самом деле работает. Это тонкий момент, про это я проговорю.
[53:41.680 --> 53:55.680]  Если на о0? Нет, тут не зависит от уровня оптимизации. Я тоже могу поставить минус o g для дебага. В общем, все будет работать.
[53:55.680 --> 54:00.680]  Чтобы это отключить, нужно использовать другие флаги.
[54:00.680 --> 54:11.680]  Сейчас возникли вопросы, когда это работает, когда это не работает. Давайте перейдем к обсуждению этого. Смотрите, с этим копия лижен довольно интересная и долгая история.
[54:11.680 --> 54:20.680]  Дело в том, что этот копия лижен появился в языке C++ не сразу. Точнее, он появился более-менее сразу, но не в стандарте языка C++.
[54:20.680 --> 54:31.680]  Создатели компиляторов практически сразу поняли, что когда происходит создание временного объекта, потом его перемещение в другой временный объект, что-то происходит не так.
[54:31.680 --> 54:43.680]  Явно мы тратим лишние ресурсы на создание дополнительных временных объектов. Создатели компиляторов довольно быстро внедрили оптимизацию копии лижен в свои компиляторы.
[54:43.680 --> 54:51.680]  Проблема в том, что эти оптимизации не очень поматчились со стандартами языка C++.
[54:51.680 --> 54:58.680]  Потому что стандарт языка C++ предписывает создавать временный объект и потом его перемещать в A. Или создавать временный объект и перемещать его в A.
[54:58.680 --> 55:07.680]  Или создавать X, потом возвращать его сюда и так далее. То есть происходит несоответствие языка программирования C++, точнее стандарта, и оптимизация компилятора.
[55:07.680 --> 55:16.680]  Ну, можно проверить следующим образом. Давайте я скомпилирую C++11. А, вот C++11 уже не работает.
[55:16.680 --> 55:24.680]  Давайте C++14, может. Тоже не работает.
[55:24.680 --> 55:32.680]  Так, давайте попробуем вот так.
[55:32.680 --> 55:42.680]  Так, давайте вот так сделаем.
[55:42.680 --> 55:52.680]  Так, давайте вот так сделаем.
[55:52.680 --> 56:10.680]  В общем, история следующая. В общем, видно, что когда я переключаюсь на старые стандарты, на старые стандарты C++, все перестает работать.
[56:10.680 --> 56:24.680]  Вопрос, почему? Дело в том, что до стандарта C++11 вот этот вот копия и режим вообще никак не присутствовал в тексте языка C++.
[56:24.680 --> 56:29.680]  То есть вообще, строго говоря, C++ ничего об этом не знал.
[56:29.680 --> 56:47.680]  Но в стандарте C++11 копия и режим был включен в стандарт, но со следующей формулировкой, что компиляторы могут такое делать, но вообще говоря, не факт.
[56:47.680 --> 56:54.680]  То есть стандарт потихоньку начал признавать, что такое возможно, но может да, может нет.
[56:54.680 --> 56:59.680]  То есть формировка называется нон-мондатори копия и режим, то есть не обязательно копия и режим.
[56:59.680 --> 57:03.680]  То есть копия и режим может происходить, но вообще говоря, программы не обязаны его поддерживать.
[57:03.680 --> 57:11.680]  А начиная со стандарта C++17, начиная со стандарта C++17, копия и режим во многих ситуациях стал обязательным.
[57:11.680 --> 57:18.680]  В частности, копия и режим стал обязательным вот в этой ситуации, когда вы создаете объект на основе чисто временного объекта.
[57:18.680 --> 57:27.680]  И вот в этой ситуации, когда вы возвращаете из функции временный объект, то есть когда вы в ретерне пишете тут временный объект,
[57:27.680 --> 57:33.680]  вот в этом случае гарантируется, что вот этот вот временный объект сразу же окажется в том месте, где он в итоге понадобится.
[57:35.680 --> 57:39.680]  Вот это теперь строго гарантируется компилятором, то есть это будет происходить всегда.
[57:39.680 --> 57:43.680]  Не важно, есть у вас конструктор перемещения или нет у вас конструктора перемещения.
[57:43.680 --> 57:54.680]  Что стандарты C++ вам не гарантируют, так это то, что будет происходить вот эта вещь.
[57:54.680 --> 57:58.680]  Внутри функции будет создаваться объект ровно такой же, как и здесь.
[57:58.680 --> 58:08.680]  Эта оптимизация называется return value optimization.
[58:08.680 --> 58:28.680]  А вот эта оптимизация называется nrvo.
[58:28.680 --> 58:36.680]  В чем отличие rvo от nrvo? Здесь возвращается временный объект, безымянный.
[58:36.680 --> 58:45.680]  Тут возвращается именованный объект, который больше не понадобится, поэтому named return value optimization.
[58:45.680 --> 58:52.680]  И в чем ключевое отличие? rvo гарантируется, начиная со стандарта C++17,
[58:52.680 --> 58:57.680]  nrvo не гарантируется даже в стандарте C++17, но скорее всего будет происходить.
[58:57.680 --> 59:16.680]  Еще один пункт. В старых стандартах C++ это можно было отключить с помощью специального флага компиляции FNovaLiteConstructor.
[59:16.680 --> 59:20.680]  В этом случае CopyEleasion может не происходить.
[59:20.680 --> 59:26.680]  В современных стандартах C++, начиная с C++17, даже эта опция не спасет вас от CopyEleasion.
[59:26.680 --> 59:30.680]  Работайте с оптимизированной версией компилятора.
[59:30.680 --> 59:34.680]  Есть ли вопросы?
[59:34.680 --> 59:38.680]  Да.
[59:38.680 --> 59:45.680]  Может легче говорить о ситуации, когда нам нужно наоборот затормозить программу, чтобы на сколько нужно не работать?
[59:45.680 --> 59:52.680]  Сознательно затормозить программу...
[59:52.680 --> 59:58.680]  Не знаю, зачем это нужно, но...
[59:58.680 --> 01:00:03.680]  Смотрите, бывают ситуации, для чего это может быть нужно.
[01:00:03.680 --> 01:00:05.680]  Для чего это раньше было нужно.
[01:00:05.680 --> 01:00:10.680]  Вот смотрите, я написал вот такой код.
[01:00:10.680 --> 01:00:13.680]  И у меня есть следующее понимание.
[01:00:13.680 --> 01:00:19.680]  У меня есть понимание того, что я хочу, чтобы это работало ровно так, как описано в стандарте C++.
[01:00:19.680 --> 01:00:22.680]  Я хочу, чтобы тут создавался объект, первый пункт.
[01:00:22.680 --> 01:00:25.680]  Я хочу, чтобы этот объект перемещался сюда.
[01:00:25.680 --> 01:00:28.680]  И наконец, я хочу, чтобы вызывался деструктор этого объекта.
[01:00:28.680 --> 01:00:32.680]  Допустим, я полагаюсь на то, что тут обязательно будет вызван деструктор для A.
[01:00:32.680 --> 01:00:38.680]  Но если происходит Copy&Vision, то второй и третий пункт просто канут в небытие.
[01:00:38.680 --> 01:00:40.680]  И тут будет создание одного объекта.
[01:00:40.680 --> 01:00:46.680]  Если я хочу, чтобы все работало ровно так, как предписывает стандарт, то я пишу этот флаг.
[01:00:46.680 --> 01:00:50.680]  Скорее всего, если вы пишете этот флаг, то вам нужно просто следование стандарта.
[01:00:50.680 --> 01:00:55.680]  То есть вам по какой-то причине нужно то, чтобы вот тут вызывался деструктор созданного объекта.
[01:00:55.680 --> 01:00:58.680]  То есть вы тут действительно полагаетесь на то, что тут создается временный объект,
[01:00:58.680 --> 01:01:01.680]  потом он перемещается, потом он вызывает деструктор.
[01:01:01.680 --> 01:01:04.680]  Каких-то причин, зачем замедлить программу, я не вижу.
[01:01:05.680 --> 01:01:07.680]  Особенно посылать в context.
[01:01:14.680 --> 01:01:16.680]  Вот, последний пункт.
[01:01:27.680 --> 01:01:29.680]  Остались ли вопросы?
[01:01:31.680 --> 01:01:33.680]  Окей.
[01:01:35.680 --> 01:01:39.680]  Так, ну хорошо, я закрыл свой дештальт.
[01:01:40.680 --> 01:01:43.680]  Давно хотел про это рассказать, и наконец рассказал.
[01:01:43.680 --> 01:01:47.680]  Давайте, в целом мы погрузиться в новую тему не успеем.
[01:01:47.680 --> 01:01:52.680]  Давайте хотя бы затронем проблематику, поговорим про проблемы,
[01:01:52.680 --> 01:01:57.680]  и начнем их подробно обсуждать уже на следующем занятии.
[01:01:57.680 --> 01:02:03.680]  Мы начнем говорить про исключение, но если говорить более глобально, про обработку ошибок в языке C++.
[01:02:03.680 --> 01:02:11.680]  Я надеюсь, наш курс за эти полтора семестра уже успел вас приучить, что программы не всегда работают.
[01:02:11.680 --> 01:02:17.680]  Даже если программа работает у вас локально, то она может не работать где-то еще.
[01:02:17.680 --> 01:02:22.680]  Или если программа работает у вас, то у кого-то другого она может не работать.
[01:02:22.680 --> 01:02:27.680]  Причем причины могут быть разные, начиная от ошибки при программировании,
[01:02:27.680 --> 01:02:31.680]  заканчивая ошибки в логике программы и так далее.
[01:02:31.680 --> 01:02:38.680]  Понятное дело, что в реальной практике, в реальной разработке тоже встречаются, скажем так, нештатные ситуации.
[01:02:38.680 --> 01:02:41.680]  Что я имею ввиду под нештатной ситуацией.
[01:02:41.680 --> 01:02:47.680]  Например, все время до этого мы с вами программировали в парадигме,
[01:02:47.680 --> 01:02:51.680]  что всякий раз, когда мы выделяем память, памяти всегда хватает.
[01:02:51.680 --> 01:02:56.680]  Если в задаче сказано, что на вход подается массив из миллиона элементов,
[01:02:56.680 --> 01:03:01.680]  если вы сделаете new миллион элементов, то миллион элементов у вас обязательно идет.
[01:03:01.680 --> 01:03:07.680]  При этом, на самом деле, понятное дело, что на практике это не всегда так.
[01:03:07.680 --> 01:03:10.680]  Если у вас программа работает в какой-то высоконагруженной среде,
[01:03:10.680 --> 01:03:14.680]  или программы заранее не знают, сколько памяти нужно выделить,
[01:03:14.680 --> 01:03:20.680]  понятное дело, что в какой-то момент может произойти такая история, что new вам скажет нет.
[01:03:20.680 --> 01:03:24.680]  То есть new, на самом деле, может отказать, как бы это странно ни звучало.
[01:03:24.680 --> 01:03:29.680]  То есть new может сказать, что нет, столько памяти нет, и вопрос в том, как с этим бороться.
[01:03:29.680 --> 01:03:33.680]  То есть вопрос в том, можно ли как-то узнать, что new завершилось неуспешно.
[01:03:33.680 --> 01:03:41.680]  Если new завершилось неуспешно, можно ли как-то эту ситуацию обработать так, чтобы программа не завершалась, не крашилась.
[01:03:41.680 --> 01:03:45.680]  И, наконец, третий вопрос, а что делать, если действительно какая-то нештатная ситуация произошла?
[01:03:45.680 --> 01:03:50.680]  Как правильным образом завершить работу функцию, как правильным образом завершить работу программы?
[01:03:50.680 --> 01:03:56.680]  В целом история про это. Мы с вами понимаем, что в программе есть основная логика программы,
[01:03:56.680 --> 01:04:03.680]  которая работает в том случае, если программа работает в идеальном мире, когда ничего плохого не происходит.
[01:04:03.680 --> 01:04:07.680]  И, возможно, в нештатной ситуации хотелось бы понимать, как об этих нештатных ситуациях сообщать,
[01:04:07.680 --> 01:04:12.680]  как об этих нештатных ситуациях узнавать и, собственно, как с этими нештатными ситуациями справляться.
[01:04:12.680 --> 01:04:16.680]  Про это мы поговорим на ближайших занятиях.
[01:04:16.680 --> 01:04:19.680]  Ну и давайте начнем отвечать на первый вопрос.
[01:04:19.680 --> 01:04:23.680]  Вот представьте себе, что вы пишете какую-то функцию.
[01:04:23.680 --> 01:04:27.680]  Допустим, простая функция, которая просто берет два числа и делит одно на другое.
[01:04:27.680 --> 01:04:30.680]  Самая простая функция, которую тут можно придумать.
[01:04:30.680 --> 01:04:33.680]  Что может плохого произойти при делении одного числа на другое?
[01:04:34.680 --> 01:04:38.680]  Понятное дело, что если у вас второе число представляет из себя ноль,
[01:04:38.680 --> 01:04:43.680]  то деление целого числа на ноль приводит к неожиданным последствиям.
[01:04:43.680 --> 01:04:46.680]  Ну в языке C++ это неопределенное поведение.
[01:04:46.680 --> 01:04:49.680]  Естественно, мы не хотим допускать в нашей программе неопределенного поведения.
[01:04:49.680 --> 01:04:52.680]  Мы хотим каким-то образом уметь сообщать пользователю,
[01:04:52.680 --> 01:04:55.680]  ну пользователю имеет в виду тому, кто пользует наши функции,
[01:04:55.680 --> 01:04:59.680]  что погоди, брат, ты подал в функцию что-то не то.
[01:04:59.680 --> 01:05:02.680]  Тебе нужно как-то исправиться, подумать над своим поведением.
[01:05:02.680 --> 01:05:05.680]  Как вот этому самому пользователю сообщить о том, что он неправ,
[01:05:05.680 --> 01:05:08.680]  не закрывая его программу целиком?
[01:05:08.680 --> 01:05:12.680]  Возможно, несколько вариантов.
[01:05:12.680 --> 01:05:15.680]  Вопрос, какие? Какие варианты вы можете предложить?
[01:05:18.680 --> 01:05:20.680]  Вот представьте себе, что вам нужно написать функцию,
[01:05:20.680 --> 01:05:22.680]  которая делит одно число на другое,
[01:05:22.680 --> 01:05:25.680]  и в случае, если что-то пошло не так,
[01:05:25.680 --> 01:05:27.680]  она должна как-то об этом корректно сообщить.
[01:05:27.680 --> 01:05:31.680]  Вопрос, как функция может сообщить корректно о том, что что-то пошло не так?
[01:05:32.680 --> 01:05:35.680]  Давайте какие-нибудь идеи, как?
[01:05:36.680 --> 01:05:38.680]  Ну Сиаут, смотрите, почему Сиаут плохо?
[01:05:38.680 --> 01:05:40.680]  Потому что, ну вообще говоря,
[01:05:40.680 --> 01:05:43.680]  у пользователя может не быть доступа к консоли.
[01:05:43.680 --> 01:05:45.680]  Это во-первых. Во-вторых, ну хорошо,
[01:05:45.680 --> 01:05:48.680]  допустим, я запустил программу, сижу пью чаю и вдруг вижу,
[01:05:48.680 --> 01:05:51.680]  у себя деление на ноль. Что делать?
[01:05:51.680 --> 01:05:55.680]  Я же хочу, чтобы сама программа как-то с этой ситуацией справлялась.
[01:05:55.680 --> 01:05:59.680]  Я не хочу, допустим, я видел сообщение, что Y равен нулю,
[01:05:59.680 --> 01:06:03.680]  давай-ка я перезапущу программу и как-то ее исправлю.
[01:06:03.680 --> 01:06:08.680]  Я хочу, чтобы одна функция могла сообщать другой функции
[01:06:08.680 --> 01:06:10.680]  о том, что во мне что-то пошло не так,
[01:06:10.680 --> 01:06:12.680]  со мной что-то не так.
[01:06:12.680 --> 01:06:14.680]  Понятно?
[01:06:17.680 --> 01:06:20.680]  Так, ну, все это отлично,
[01:06:20.680 --> 01:06:23.680]  но на самом деле самый простой способ это ничего не делать.
[01:06:23.680 --> 01:06:28.680]  То есть, ну, на самом деле простой и стандартный способ.
[01:06:28.680 --> 01:06:30.680]  Первый способ это просто предполагать,
[01:06:30.680 --> 01:06:32.680]  что ничего плохого не произойдет.
[01:06:32.680 --> 01:06:35.680]  Если мы предполагаем, что ничего плохого не произойдет,
[01:06:35.680 --> 01:06:38.680]  то мы просто перекладываем ответственность на все плохое на пользователя.
[01:06:38.680 --> 01:06:41.680]  То есть мы просто наговорим, что вот если там ты
[01:06:41.680 --> 01:06:45.680]  передал на вход в качестве Y значение равное нулю,
[01:06:45.680 --> 01:06:47.680]  то ты сам виноват.
[01:06:47.680 --> 01:06:50.680]  Мы ничего не гарантируем, мы ничего тебе об этом не скажем.
[01:06:50.680 --> 01:06:52.680]  Но, естественно, это не самый хороший способ.
[01:06:52.680 --> 01:06:53.680]  Почему?
[01:06:53.680 --> 01:06:56.680]  Потому что, ну, все-таки в нестатной ситуации
[01:06:56.680 --> 01:06:58.680]  они всегда могут зависеть от пользователя.
[01:06:58.680 --> 01:07:01.680]  Ну, опять же, представьте себе, что мы пишем свой собственный вектор.
[01:07:01.680 --> 01:07:03.680]  То есть как бы мы говорим пользователю,
[01:07:03.680 --> 01:07:06.680]  что вот мы тебе предоставляем класс Вектор,
[01:07:06.680 --> 01:07:09.680]  и, скажем, если ты выделяешь памяти для n байт,
[01:07:09.680 --> 01:07:13.680]  точнее для n элементов, то мы тебе создадим вектор на n элементов.
[01:07:13.680 --> 01:07:15.680]  Но при этом у вектора в какой-то момент, не знаю,
[01:07:15.680 --> 01:07:18.680]  может просто-напросто не выделиться память и так далее.
[01:07:18.680 --> 01:07:21.680]  Понятное дело, что это все не обязательно зависит от пользователя.
[01:07:21.680 --> 01:07:24.680]  То есть мы пользователю все-таки хотим как-то уметь сообщать о том,
[01:07:24.680 --> 01:07:26.680]  что что-то пошло не так, возможно, не по твоей причине.
[01:07:26.680 --> 01:07:29.680]  То есть мы хотим дать понять пользователю,
[01:07:29.680 --> 01:07:32.680]  что то, что он хочет сделать, выполнить не получится.
[01:07:32.680 --> 01:07:35.680]  Поэтому второй способ, как вы правильно сказали,
[01:07:35.680 --> 01:07:37.680]  можно вернуть в специальное значение.
[01:07:37.680 --> 01:07:39.680]  Давайте поступим так.
[01:07:39.680 --> 01:07:42.680]  Если у нас x разделился на y,
[01:07:42.680 --> 01:07:44.680]  то мы вернем результат деления x на y.
[01:07:44.680 --> 01:07:46.680]  Если x на y не разделился,
[01:07:46.680 --> 01:07:49.680]  то давайте вернем какое-то вот специально заранее выбранное значение.
[01:07:49.680 --> 01:07:51.680]  В чем проблема?
[01:07:55.680 --> 01:07:57.680]  Да, вопрос.
[01:07:57.680 --> 01:08:00.680]  Что должно являться специальным значением в случае деления x на y?
[01:08:00.680 --> 01:08:02.680]  Ну хорошо, допустим, в качестве деления x на y
[01:08:02.680 --> 01:08:04.680]  я выиграл специальное значение минус единица.
[01:08:04.680 --> 01:08:07.680]  Вопрос, как понять, вот эта минус единица получена в результате вычисления,
[01:08:07.680 --> 01:08:10.680]  x зеленая на y, или в результате вот этой самой ошибки?
[01:08:10.680 --> 01:08:12.680]  Непонятно.
[01:08:12.680 --> 01:08:14.680]  То есть любое значение, на самом деле, корректное,
[01:08:14.680 --> 01:08:16.680]  и результат деления x на y. Согласны?
[01:08:16.680 --> 01:08:18.680]  То есть специальное значение хорошо,
[01:08:18.680 --> 01:08:20.680]  то есть если у меня есть какое-то специальное выделенное значение,
[01:08:20.680 --> 01:08:22.680]  то я могу просто взять и проверить,
[01:08:22.680 --> 01:08:24.680]  верно ли, что функция вернула это самое специальное значение.
[01:08:24.680 --> 01:08:26.680]  Если да, то функция завершилась неуспешно.
[01:08:26.680 --> 01:08:28.680]  Если нет, то функция завершилась успешно.
[01:08:28.680 --> 01:08:31.680]  Но проблема в том, что не всегда это специальное значение можно выбрать.
[01:08:33.680 --> 01:08:35.680]  Какие еще варианты возможны?
[01:08:36.680 --> 01:08:38.680]  Что еще можете предложить?
[01:08:40.680 --> 01:08:42.680]  Что?
[01:08:42.680 --> 01:08:44.680]  Для нитов нет бесконечности, к сожалению.
[01:08:44.680 --> 01:08:46.680]  Нет, хорошо.
[01:08:46.680 --> 01:08:48.680]  Если я передаю int и в int делю int на int.
[01:08:48.680 --> 01:08:50.680]  То есть у меня функция шаблонная,
[01:08:50.680 --> 01:08:52.680]  но в качестве параметра шаблона я передаю int.
[01:08:52.680 --> 01:08:54.680]  Что делать?
[01:08:54.680 --> 01:08:56.680]  Непонятно.
[01:08:56.680 --> 01:08:58.680]  То есть понятное дело, что если мы делим float на float
[01:08:58.680 --> 01:09:00.680]  или double на double, то там есть специальное значение,
[01:09:00.680 --> 01:09:02.680]  типа none, int и так далее.
[01:09:02.680 --> 01:09:04.680]  Есть такого значения нет.
[01:09:04.680 --> 01:09:06.680]  Что делать?
[01:09:06.680 --> 01:09:08.680]  Например, делим int на int.
[01:09:08.680 --> 01:09:10.680]  Кого-то отдельного выделенного значения,
[01:09:10.680 --> 01:09:12.680]  который бы говорил нам о том, что результат некорректен, нет.
[01:09:12.680 --> 01:09:14.680]  Ну, смотрите.
[01:09:14.680 --> 01:09:16.680]  А если я возьму
[01:09:16.680 --> 01:09:18.680]  max-1
[01:09:18.680 --> 01:09:20.680]  и разделю на 1?
[01:09:20.680 --> 01:09:22.680]  Ну, мне кажется...
[01:09:22.680 --> 01:09:24.680]  Вы так пишете программы в контест?
[01:09:24.680 --> 01:09:26.680]  Вероятно, с того, что будет в A,
[01:09:26.680 --> 01:09:28.680]  очень маленькая.
[01:09:28.680 --> 01:09:30.680]  Да.
[01:09:30.680 --> 01:09:32.680]  Вот какой-то кодический флаг,
[01:09:32.680 --> 01:09:34.680]  который плачет,
[01:09:34.680 --> 01:09:36.680]  который плачет,
[01:09:36.680 --> 01:09:38.680]  который плачет,
[01:09:38.680 --> 01:09:40.680]  который плачет,
[01:09:40.680 --> 01:09:42.680]  тут будет кодический флаг в телу,
[01:09:42.680 --> 01:09:44.680]  который плачет, мы можем его
[01:09:44.680 --> 01:09:46.680]  каждый раз проверять.
[01:09:46.680 --> 01:09:48.680]  Да, вот.
[01:09:48.680 --> 01:09:50.680]  Идея, которую вы описали,
[01:09:50.680 --> 01:09:52.680]  звучит так. Действительно, давайте воспользуемся
[01:09:52.680 --> 01:09:54.680]  какой-нибудь специальной отдельной переменной.
[01:09:54.680 --> 01:09:56.680]  В языке Ic есть специальная переменная
[01:09:56.680 --> 01:09:58.680]  Erno,
[01:09:58.680 --> 01:10:00.680]  в которую, в общем, если вызываете функцию,
[01:10:00.680 --> 01:10:02.680]  то в эту переменную Erno
[01:10:02.680 --> 01:10:04.680]  записывается результат кода ошибки
[01:10:04.680 --> 01:10:06.680]  последней вызванной функции.
[01:10:06.680 --> 01:10:08.680]  Если Erno равно 0, значит, последняя функция завершилась успешно.
[01:10:08.680 --> 01:10:12.080]  если rn не равно 0, то значит последняя пункция завершилась неуспешно.
[01:10:12.080 --> 01:10:18.240]  Давайте заведем какую-нибудь глобальную переменную rn, в которой будем хранить код ошибки.
[01:10:18.240 --> 01:10:21.580]  Если код ошибки не равен 0, значит функция завершилась неуспешно.
[01:10:21.580 --> 01:10:24.280]  Если код ошибки равен 0, то функция завершилась успешно.
[01:10:24.280 --> 01:10:30.080]  В чем проблема? Проблем куча. И все они связаны с использованием глобальных перемен.
[01:10:30.080 --> 01:10:36.180]  Начиная от того, что глобальную перемену нужно всегда проверять.
[01:10:36.180 --> 01:10:40.420]  Это глобальная переменная должна зацарять нашу область видимости, заканчивая тем, что если вдруг мы
[01:10:41.380 --> 01:10:47.660]  пишем многопоточные программы, то есть программы, которые работают параллельно, то функция может создаваться в одном потоке, во втором потоке, в третьем потоке,
[01:10:47.660 --> 01:10:50.560]  и непонятно, какой из потоков записал в эту самую переменную.
[01:10:51.140 --> 01:10:57.140]  Непонятно, какая из функций на самом деле привел к ошибочному результату.
[01:10:57.900 --> 01:10:59.900]  Окей?
[01:11:00.780 --> 01:11:11.940]  Есть еще один способ, который был и есть основным в языке C.
[01:11:11.940 --> 01:11:16.780]  Это просто-напросто использовать возвращаемое значение функций не по назначению.
[01:11:17.460 --> 01:11:24.060]  Давайте скажем следующее. Давайте скажем, что у меня функция возвращает не результат, а у меня функция возвращает код ошибки.
[01:11:24.980 --> 01:11:26.060]  Окей?
[01:11:26.060 --> 01:11:32.580]  То есть возвращаемое значение функции хранит не результат деления х на у, а возвращаемое значение функции хранит
[01:11:34.380 --> 01:11:40.240]  код ошибки, то есть если 0, то нет ошибки, если единицы, двоик или любой не нулевой значения, значит ошибка есть.
[01:11:40.500 --> 01:11:46.580]  А сам результат вызова этой функции буду сохранять в отдельную переменную, которую я передаю третьим параметрам.
[01:11:46.580 --> 01:11:52.540]  Ну, в данном случае, я передаю третьим параметрам аргумент по указателю, но могу третье параметр передавать по ссылке,
[01:11:52.540 --> 01:11:58.540]  и тогда результат вызывает функцию, могут сохранять вот эту самую переменную по ссылке или по указателю. Согласны?
[01:11:58.540 --> 01:12:00.540]  Вот. Ну в чем проблема?
[01:12:02.540 --> 01:12:06.540]  Ну проблема в том, что если вы хотите вызвать функцию divide и при этом никуда не сохранить результат,
[01:12:06.540 --> 01:12:10.540]  то вам придется создать лишнюю переменную для того, чтобы все-таки этот результат сохранить
[01:12:10.540 --> 01:12:12.540]  и при этом никак не использовать. Это первое.
[01:12:12.540 --> 01:12:20.540]  Второе, ну нарушается, скажем так, привычное понимание, наше с вами понимание работы функции.
[01:12:20.540 --> 01:12:29.540]  Ну, когда мы говорим про функцию, в математическом смысле или в смысле программирования, мы предполагаем, что функция возвращает результат.
[01:12:29.540 --> 01:12:33.540]  Но это было бы странно, если бы вы математиками такие. Так. Давайте изучим tangents.
[01:12:33.540 --> 01:12:39.540]  Вот. Tangents от x возвращает 1 или 0. Если tangents можно вычислить, он вернет 1.
[01:12:39.540 --> 01:12:43.540]  Если tangents равен, если нельзя вычислить, то... это не наоборот. Если tangents можно вычислить, он вернет 0.
[01:12:43.540 --> 01:12:45.540]  Если tangents нельзя вычислить, то он вернет 1.
[01:12:45.540 --> 01:12:51.380]  Адентат вычисления тангенса будем хранить в перемен y, вот. Не очень удобно, вот.
[01:12:53.340 --> 01:12:59.220]  Здесь ровно то же самое. Все-таки мы с вами привыкли, что если пункты что-то возвращают, то этот результат мы хотим использовать, то, собственно, в качестве там
[01:12:59.940 --> 01:13:01.940]  каких-то составных выражениях и так далее.
[01:13:02.860 --> 01:13:05.100]  Вот. В общем, все варианты
[01:13:05.860 --> 01:13:07.860]  одновременно и хороши и плохи.
[01:13:08.620 --> 01:13:15.020]  Ну, собственно, как я уже сказал, в языке C чаще всего используется подход с возвратом кода ошибки, и поэтому код выглядит примерно, любой код на языке C
[01:13:15.100 --> 01:13:16.420]  выглядит примерно так.
[01:13:16.420 --> 01:13:21.340]  Вызываем функцию G, проверяем код ошибки, вызываем функцию H, проверяем код ошибки, и так далее. Вот.
[01:13:22.140 --> 01:13:23.340]  Собственно,
[01:13:23.340 --> 01:13:25.740]  куча недостатков, то есть, во-первых, мы теряем
[01:13:26.320 --> 01:13:28.720]  интуитивность, во-вторых, у нас код состоит из кучи проверок.
[01:13:29.020 --> 01:13:34.860]  То есть, завершилось ли функция успешно, завершился функция успешно и так далее, вот. А все-таки хочется читать код, ну как бы
[01:13:35.460 --> 01:13:38.780]  согласитесь, что хотелось бы просто читать код. То есть, вызов
[01:13:39.940 --> 01:13:41.580]  функции F, B, J и так далее.
[01:13:41.580 --> 01:13:46.260]  а уже всякие ошибочные ситуации мы хотели, чтобы они существовали где-то вот в отдельности, в отдельной стране от кода.
[01:13:47.400 --> 01:13:54.040]  Ну, все-таки, когда мы с вами пишем код, ну, как вот сказал молодой человек, мы все-таки предполагаем, что вероятность ошибки крайне мала.
[01:13:54.360 --> 01:13:59.060]  Вот. А зачем, если у нас вероятность ошибки крайне мала, зачем нам городить код, который состоит из кучи проверок?
[01:14:00.840 --> 01:14:04.560]  Ну, и, собственно, в C++ в качестве стандартного способы используется
[01:14:05.640 --> 01:14:07.480]  бросание и отключение.
[01:14:07.480 --> 01:14:14.200]  Значит, ну, к сожалению, лекция закончилась. В следующий раз, как раз-таки подробно поговорим про то, как устроена обработка ошибок в C++ и так далее.
[01:14:14.200 --> 01:14:19.960]  Значит, кратко скажу, что чтобы в C++ сообщить о наличии ошибки, мы используем специальный оператор,
[01:14:20.320 --> 01:14:22.320]  который называется оператор throw.
[01:14:22.320 --> 01:14:29.640]  Вот. Если кратко, то когда у нас работает функция, чтобы сказать о том, что функция завершилась успешно, мы используем оператор return.
[01:14:29.800 --> 01:14:33.980]  И оператор return возвращает нужное значение, которое вычислился в результате вызова функции.
[01:14:34.460 --> 01:14:38.620]  А оператор throw это такой, можно сказать, специальный оператор, который используется тогда,
[01:14:39.300 --> 01:14:43.260]  который используется в тех ситуациях, когда мне нужно сообщить, что функция завершилась неуспешно.
[01:14:43.260 --> 01:14:49.740]  Таким образом, из функции я могу выйти двумя способами. Первый способ это стандартный, то есть получу return. Второй способ нестандартный, то есть получу throw.
[01:14:50.140 --> 01:14:54.300]  Ну, подробнее поговорим на следующей неделе в следующий раз. На сегодня все, всем спасибо.
