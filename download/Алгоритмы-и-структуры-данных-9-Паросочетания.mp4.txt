[00:00.000 --> 00:20.280]  Так, давайте начинать. Мы сегодня поговорим про просочетание, в частности, в
[00:20.280 --> 00:24.960]  двудольных графах. Давайте сразу начинать. Во-первых, что такое двудольный граф?
[00:24.960 --> 00:37.400]  Интуитивно это такой неориентированный граф, в котором все вершины можно разбить на две группы,
[00:37.400 --> 00:43.600]  левую и правую, таким образом, что ребра будут только между группами. Внутри группы ребра не
[00:43.600 --> 00:47.800]  может быть, а могут быть только между группами. То есть все вершины можно разбить на два множества.
[00:48.520 --> 00:53.440]  Такие, что ребра у меня находятся только вот между группами. Не может быть ребер внутри R,
[00:53.440 --> 00:59.160]  не может быть ребер внутри L, могут быть только между ними. Ну, значит, двудольный граф это такой
[00:59.160 --> 01:08.640]  граф, на что существует какие-то множества LR, такие, что V представляется в виде дезинктного
[01:08.640 --> 01:14.360]  объединения LR, да, ну и, соответственно, каждое ребро одним из концов лежит в L, другим лежит в R.
[01:14.360 --> 01:38.080]  Один из концов, концов E в L, другой в R. Вот. Ну, альтернативно, да, альтернативно можно было
[01:38.080 --> 01:42.400]  бы сказать, что двудольный граф это то же самое, что граф с хроматическим числом не больше, чем два.
[01:42.400 --> 01:57.040]  Ну, потому что как раз хроматическое число не больше, чем два, значит, можно весь граф разбить
[01:57.040 --> 02:01.960]  на не более, чем два независимых множества. На вот как раз L это независимое множество и R это
[02:01.960 --> 02:06.280]  независимое множество. Так что ребра только между ними, но не внутри самих этих множеств.
[02:06.280 --> 02:14.560]  Да, понятно? Вот. Ну, сегодня мы будем работать в основном только с двудольными,
[02:14.560 --> 02:21.760]  но вообще говоря, понятие по рассчитанию определяется в произвольном графе. Значит,
[02:21.760 --> 02:32.120]  определение пусть G это какой-то граф, пусть M это какое-то подношство его ребер,
[02:32.120 --> 02:46.920]  значит, тогда M называется по рассочетаниям. Я, возможно, для краткости буду говорить или
[02:46.920 --> 03:03.000]  писать по рассочам, чтобы меньше букв писать. По рассочетаниям, если, если ребра из M попарно
[03:03.000 --> 03:08.720]  дезюмпны, то есть любые два ребра не имеют общих концов, то есть не бывает вот таких вот картинок,
[03:08.720 --> 03:13.320]  когда когда два ребра имеют зацеплены по вершине, любые два ребра, они именно что вообще не
[03:13.320 --> 03:25.080]  пересекаются, у них нет общих концов. Значит, если, напишу так, никакие два ребра из M не имеют
[03:25.080 --> 03:40.960]  общих концов. Да, ну то есть скажем вот такой вот набор ребер, это просочетания, вот ребро,
[03:40.960 --> 03:47.760]  вот ребро и вот ребро, они хоть они на рисунке пересекаются, но по концам они не пересекаются,
[03:47.760 --> 03:53.800]  у них нет общих концов. Значит, это просочь, а например, что-нибудь вот такое, это уже не просочь,
[03:53.800 --> 04:01.000]  потому что вот эти два ребра пересекаются по вершинке, это уже не просочетание. Ну и задача,
[04:01.000 --> 04:07.720]  которую мы будем решать, следующая, надо найти просочетание максимального размера в вдольном
[04:07.720 --> 04:21.680]  графе. Задача найти просочетание максимального размера, то есть с наибольшим количеством
[04:21.960 --> 04:35.800]  ребер в вдвудольном графе. Вот, значит, повторюсь, вообще говоря, эту задачу можно также за
[04:35.800 --> 04:41.760]  полидональное время решать и в обычном, в произвольном, неориентированном графе,
[04:41.760 --> 04:46.360]  не обязательно вдвудольном, но там более сложный алгоритм, мы, наверное, его не будем рассматривать,
[04:46.360 --> 04:54.400]  ну может быть, но не факт. Вот, мы концентрируемся на специфическом случае, когда граф,
[04:54.400 --> 04:57.120]  который мы рассматриваем вдвудольный, вот именно в вдвудольном нам надо найти максимальное
[04:57.120 --> 05:03.400]  просочетание. Вот, ну зачем это может быть нужно? Самый такой фольклорный пример, это вот представьте,
[05:03.400 --> 05:10.400]  у вас есть такой вдвудольный граф, есть так называемая задача на значениях. Значит,
[05:10.400 --> 05:18.720]  представьте, что у вас есть n человек и n каких-нибудь, ну там, заданий, и вам нужно
[05:18.720 --> 05:24.080]  распределить, какой человек делает какое задание, так чтобы каждое задание кем-то делалось,
[05:24.080 --> 05:29.360]  но при этом, ну как бы, никакой человек не делал два задания. То есть в этом смысле вам нужно как
[05:29.360 --> 05:33.960]  раз найти перестановку, ну биекцию, по факту, между людьми и заданиями, это в точности по
[05:33.960 --> 05:37.800]  просочетанию. То есть вы говорите, что этот человек делает это задание, этот вот это,
[05:37.800 --> 05:42.720]  а этот вот этот и так далее. То есть это взаимнооднозначное соответствие между вершинами
[05:42.720 --> 05:47.140]  левой и правой долей, то есть это как раз просочетание, что никакие два ребра не пересекаются,
[05:47.140 --> 05:55.840]  они зацеплены. Ну вот. Ну вот, что-то такое нам надо сделать. В термах этой задачи, там некоторые
[05:55.840 --> 05:59.840]  люди умеют делать некоторые задания, надо выбрать какое-то просочетание, так чтобы как можно
[05:59.840 --> 06:04.840]  больше заданий было выполнено. То есть как раз парсуще максимального размера.
[06:04.840 --> 06:14.840]  Вот. Так, ну хорошо. Значит, у нас, на самом деле, алгоритм, который будет искать
[06:14.840 --> 06:19.680]  максимальное просочетание, он будет такой очень жадный, ну и довольно наивный. Он
[06:19.680 --> 06:24.000]  будет делать примерно следующее. Вот он имеет какой-то двудольный граф, в нём уже
[06:24.000 --> 06:28.080]  построено какое-то просочетание, ну найдено там несколько образующих
[06:28.080 --> 06:32.080]  просочетания. Он будет пытаться это просочетание увеличивать итеративно, будет
[06:32.080 --> 06:38.920]  пытаться добавлять к нему какое-нибудь новое ребро. Ну, например, представьте, что
[06:38.920 --> 06:47.680]  у вас есть какое-нибудь вот такое просочетание. Давайте сплошными ребрами я
[06:47.680 --> 06:52.720]  сейчас изображаю ребра просочетания, а пунктирными я изображу просто ребра,
[06:52.720 --> 06:56.280]  которые ещё, в принципе, есть в графе.
[07:00.400 --> 07:05.280]  Сплошные ребра это ребра парсоча, пунктирные это как бы не использованные
[07:05.280 --> 07:11.040]  ребра, которые есть в графе, но не использованы в парсочи. Вот. Тогда, ну видно, что,
[07:11.040 --> 07:15.440]  вот, например, вдоль вот этого пути, который чередуется как раз пунктирные
[07:15.440 --> 07:21.800]  сплошные ребра, можно выполнить чередование. То есть можно, наоборот, взять в
[07:21.800 --> 07:25.320]  парсочи все неиспользованные ребра на этом пути и удалить все использованные.
[07:25.320 --> 07:29.640]  То есть я просто давайте поменяю типы ребер на всем этом пути. У меня тогда вот это
[07:29.640 --> 07:33.280]  ребро попадет в парсочетание, это будет из него удалено, но останется в графе.
[07:33.280 --> 07:39.720]  Дальше я беру вот это ребро, удаляю вот это, беру вот это. Ну, собственно, я произвел
[07:39.720 --> 07:46.720]  чередование на чередование. Ну и видно, что размер парсочи не увеличился. У меня
[07:46.720 --> 07:52.320]  было два ребра в парсочи, стало три. Ну и давайте вот так вот и будем делать. То
[07:52.320 --> 07:56.320]  есть у нас будет более-менее одна простая операция увеличения парсочетания. Это
[07:56.320 --> 08:01.400]  выбор какого-то вот такого вот пути, на котором типы ребер чередуются, ну и
[08:01.400 --> 08:05.240]  собственно, чередование вдоль него. Тогда у меня как раз, ну вот в этом случае у меня
[08:05.240 --> 08:08.480]  два ребра удаляется из парсочи, а три добавляется, соответственно, размер
[08:08.480 --> 08:12.120]  увеличивается на единичку. Вот. Но это будет наша элементарная операция, с
[08:12.120 --> 08:16.840]  помощью которой мы и будем искать максимальное парсочетание. Давайте я
[08:16.840 --> 08:20.080]  формально определю, что мне нужно от этой картинки, чтобы можно было
[08:20.080 --> 08:26.560]  осуществлять чередование. Так, для этого еще одно вспомогательное пределение в
[08:26.560 --> 08:30.360]  виду. Значит, пусть M это парсочетание.
[08:33.880 --> 08:39.280]  Значит, тогда у меня все вершины поделятся на два типа, насыщенные и
[08:39.280 --> 08:43.480]  не насыщенные. Насыщенные это те, которые являются концами хотя бы одного из
[08:43.480 --> 08:47.800]  ребер. То есть, вот эти вот вершинки будут насыщенные, а все остальные не
[08:47.800 --> 08:54.520]  насыщенные. Ну, интуитивно, очень просто. Как бы насыщенный парсочетанием
[08:54.520 --> 08:56.880]  используется лифт парсочетания данной вершины.
[08:56.880 --> 09:12.120]  Значит, тогда вершина V называется насыщенной, если она является концом одного
[09:12.120 --> 09:14.960]  из ребер про сочетания.
[09:27.080 --> 09:30.960]  Но в противном случае вершина называется ненасыщенной, если она ни в каком
[09:30.960 --> 09:35.680]  ребере не задействована, как вот эти вершинки, которые никак в парсочи не
[09:35.680 --> 09:42.960]  участвуют. Они, соответственно, не насыщенные. Так, хорошо. Ну и теперь, наконец, я
[09:42.960 --> 09:47.320]  могу определить, что такое величающий путь. Опять-таки, пусть M это какое-то
[09:47.320 --> 09:59.240]  парсочетание. Пусть P это какой-то путь в графе G.
[09:59.240 --> 10:20.440]  Значит, тогда P называется увеличивающим относительно M, если выполнено сразу
[10:20.440 --> 10:27.320]  следующие все условия. Значит, во-первых, путь достаточно длинный, а именно в нем
[10:27.320 --> 10:33.200]  есть хотя бы одно ребро. Ну я напишу это так, что длина P хотя бы один. И
[10:33.200 --> 10:40.280]  подразумеваю, что длину пути я измеряю в количестве ребер. Во-вторых, смотрите,
[10:40.280 --> 10:45.680]  что мне вот здесь было важно? Мне важно, чтобы концы пути были ненасыщенные. Мне
[10:45.680 --> 10:49.400]  важно, чтобы первые и последние вершины пути были именно, что вообще никак не
[10:49.400 --> 10:53.200]  задействованы в парсочетании, чтобы я имел возможность к ним вот эти вот ребра
[10:53.200 --> 10:56.440]  подсоединить. Вот это ребро и вот это ребро. Чтобы их можно было добавить в
[10:56.440 --> 11:01.280]  парсоч, мне нужно, чтобы крайние вершины были изначально ненасыщенные. Ну
[11:01.280 --> 11:10.240]  соответственно, второе требование, концы P ненасыщены относительно пространя M.
[11:14.080 --> 11:22.000]  И третье, это собственно то, что вдоль пути можно сделать чередование,
[11:22.000 --> 11:26.040]  то есть что типа ребра чередуются. А именно, что первое ребро на пути не лежит в M,
[11:26.040 --> 11:32.960]  второе лежит в M, третье не лежит в M, четвертое лежит в M и так далее. То есть типа ребер
[11:32.960 --> 11:44.680]  в P чередуются. Сначала ребро, не лежащее в M, потом лежащее в M, потом не лежащее в M,
[11:44.680 --> 11:55.320]  ну и так далее по очереди. Еще раз? Ну что такое путь? Путь это формальная
[11:55.320 --> 12:00.000]  последовательность вершин просто. Раз, два, три, четыре, пять, шесть. Концы соответственно первые
[12:00.000 --> 12:12.480]  и последние вершины на пути. Так, нормально? Ну вот, тогда я утверждаю, что если есть увеличивающий
[12:12.480 --> 12:17.480]  путь относительно данного просчитания, то вдоль него можно выполнить вот такое вот чередование и
[12:17.480 --> 12:24.240]  размер парсоч увеличится. Ну понятно, я могу это сделать как раз за счет того, что у меня концы
[12:24.280 --> 12:29.080]  не насыщенные, значит я вот эти вот ребра могу добавить в парсоч. Потом я меняю здесь вот,
[12:29.080 --> 12:32.880]  я чередую здесь везде типы ребер, то есть те, которые были, я удаляю, те, которых не было,
[12:32.880 --> 12:41.560]  добавляю. Ну и тогда понятно как раз, что у меня добавится больше, чем удалится. За счет того,
[12:41.560 --> 12:48.000]  что у меня концы вне M, а по пути все чередуется, то у меня обязательно как бы на один больше будет
[12:48.000 --> 12:52.680]  тех ребер, которые не в M по сравнению с теми, которые были в M. Значит размер обязательно увеличится.
[12:52.680 --> 13:06.880]  Ну вот. И на самом деле верно следующее. Верна следующая теорема, теорема Бержа. Она утверждает
[13:06.880 --> 13:12.200]  следующее, что M максимальное парсочетание, то есть просчитание максимального размера,
[13:12.200 --> 13:19.160]  если и только если относительно него вот таких вот путей нету. То есть мне достаточно избавиться,
[13:19.160 --> 13:24.280]  выполнить чередование вдоль всех увеличивающих путей, и тогда сразу автоматически парсочетание
[13:24.280 --> 13:33.960]  максимально. Парсочетание M максимально, ну то есть имеет максимальный размер,
[13:33.960 --> 13:40.360]  если и только если относительно него нет увеличивающих путей.
[13:40.360 --> 13:58.760]  В одну сторону мы вроде уже доказали. Скажите в какую?
[13:58.760 --> 14:11.960]  Слева направо вроде бы. Потому что если M максимально, но при этом относительно него
[14:11.960 --> 14:16.040]  есть увеличивающие пути, то можно выполнить чередование и парсочи еще увеличить.
[14:16.040 --> 14:25.800]  Значит если есть увеличивающий путь, то можно выполнить чередование и увеличить парсочи.
[14:25.800 --> 14:45.440]  Так, хорошо, теперь обратно. В обратную сторону, конечно, более содержательное утверждение. То есть
[14:45.440 --> 14:51.960]  смотрите, что мы сделали. Мы сказали, что чтобы найти парсоч, мы будем просто многократно искать
[14:51.960 --> 14:56.120]  увеличивающий путь и выполнять чередование вдоль собственного увеличивающего пути. И больше
[14:56.120 --> 15:00.360]  ничего делать не будем. Никаких других преобразований делать не будем. Вот оказывается, что этого достаточно.
[15:00.360 --> 15:05.800]  Достаточно прочередовать вдоль всех увеличивающих путей, тогда парсочи автоматически максимальны.
[15:05.800 --> 15:16.880]  Ну давайте доказывать. Для этого я веду какие-нибудь обозначения. Пусть M это вот то самое, давайте пойдем
[15:16.880 --> 15:22.520]  от противного. Значит пусть M не максимально, но относительно него нет увеличивающих путей.
[15:22.520 --> 15:35.960]  Не максимально, но относительно M нет увеличивающих путей. Вот, и давайте скажем,
[15:35.960 --> 15:49.400]  пусть M это настоящее максимальное просчитание. Ну то есть M это наше, а M настоящее максимальное.
[15:49.400 --> 16:03.440]  Тогда давайте я рассмотрю следующий граф. Я рассмотрю граф, в котором оставлю только ребра,
[16:03.440 --> 16:10.040]  принадлежащие асимметричной разности множеств M и M'. Ну напоминаю, M и M' это формальное множество
[16:10.040 --> 16:15.560]  ребер. Асимметричная разность этих множеств это только те ребра, которые лежат ровно в одном из них.
[16:15.560 --> 16:28.320]  То есть либо в M, либо в M', но не в обоих одновременно. Давайте рассмотрим пока что такой граф. Я утверждаю,
[16:28.320 --> 16:48.200]  что в нем каждая вершина имеет степень не больше, чем два. Ну вроде понятно. Давайте возьмем какую-нибудь
[16:48.200 --> 16:56.840]  вершинку. Если внезапно у нее степень хотя бы три, то есть по крайней мере три ребра, лежат в этом
[16:56.840 --> 17:02.240]  множестве. Тогда понятно, что хотя бы какие-то два из них пришли из одного множества, скажем вот из M
[17:02.240 --> 17:07.760]  и из M'. Но тогда получается, что M это не про сочетание, потому что вот два ребра имеющие общий конец.
[17:07.760 --> 17:15.960]  Значит три больше ребра сходить из вершинки не может, поэтому их не больше, чем два. Понятно?
[17:15.960 --> 17:26.720]  Ну хорошо. В этом графе степень всех вершин не больше, чем два. Давайте докажем такую вспоминательную
[17:26.720 --> 17:33.680]  лимку, которая говорит нам вообще про устройство таких графов, в которых все вершины имеют степень
[17:33.680 --> 17:45.120]  не больше, чем два. Значит пусть H это граф с этим свойством, граф, в котором все степени не
[17:45.120 --> 17:55.080]  происходят двойки. Тогда я утверждаю, что он представляется в следующем виде. Ну вот если
[17:55.080 --> 18:00.920]  я рассмотрю компоненты связанности в H, то каждая компонент это либо простой путь, либо цикл. Больше
[18:00.920 --> 18:17.080]  ничего в нем быть не может. Тогда каждая компонента связанности H – путь или цикл.
[18:30.920 --> 18:49.520]  Так, ну вообще говоря, должно быть более-менее очевидно, почему это так.
[18:49.520 --> 19:01.360]  Ну вот давайте, например, рассмотрим, ну понятно, давайте сначала отбросим все вершины степени 0,
[19:01.360 --> 19:05.680]  потому что если вершина имеет степень 0, то она изолированная, она сама по себе является
[19:05.680 --> 19:11.680]  отдельной компонентой связанности. Дальше, если я вижу какую-то вершину степени 1, то значит да,
[19:11.680 --> 19:16.480]  из нее исходит ровно одно ребро. Ну давайте посмотрим на это ребро, оно куда-то ведет. Если оно
[19:16.560 --> 19:21.360]  ведет в вершину степени 1, то это ребро – это отдельная компонент связанности, больше ребер,
[19:21.360 --> 19:27.280]  как бы, исходящих из них нет. Если здесь степень 2, то значит есть еще одно какое-то, ровно одно
[19:27.280 --> 19:32.800]  ребро, еще неиспользованное ребро, ведущее из этой вершинки, вот куда-то сюда оно ведет. Опять,
[19:32.800 --> 19:37.480]  если здесь степень 1, то значит компонента закончилась, иначе здесь степень 2. Значит,
[19:37.480 --> 19:42.600]  опять есть какое-то новое ребро, ведущее в какую-то новую вершинку. Ну и так далее. Вот, значит,
[19:42.600 --> 19:48.800]  ребра ведущего назад быть не может, потому что, ну как бы, для всех предыдущих вершинок мы уже все
[19:48.800 --> 19:54.160]  ребра рассмотрели. Мы как бы идем слева направо, и каждый, когда мы рассматриваем очередную вершину,
[19:54.160 --> 19:58.440]  мы видим, что в нее пришло одно ребро, выходит одно ребро, значит больше никаких здесь быть не
[19:58.440 --> 20:04.560]  может. Поэтому рано или поздно мы обязаны завершиться в какой-то очередной вершине степени 1. Мы так идем
[20:04.560 --> 20:11.240]  слева направо. Вот, назад идти не можем, рано или поздно закончимся. Закончиться мы можем только
[20:11.240 --> 20:16.040]  вершины степени 1. Значит, вот, пожалуйста, отдельная компонента связанности, никаких других
[20:16.040 --> 20:23.520]  ребер сюда не входит. Понятно? Вот, то есть еще раз, если у нас есть вершина степени 1, то мы можем
[20:23.520 --> 20:29.040]  просто идти по ребрам, как бы, ну по ребрам вдоль вот этой пути идти, и поймем, что мы обойдем
[20:29.040 --> 20:34.080]  целиком компоненту связанности. Т.е. тем самым мы избавились от всех вершин степени 1. Вот мы их
[20:34.080 --> 20:38.120]  давайте выкинули, остались только вершины степени 2. Ну давайте рассмотрим вершину степени 2.
[20:38.200 --> 20:44.200]  Тогда, у него есть где-то два соседа. Давайте пойдем... Не, давайте я также буду рисовать. Вот 여기 есть
[20:44.200 --> 20:49.160]  вершина степени 2. У нее есть там какое-то ребро, и вот давайте выберем одного из соседей этой
[20:49.160 --> 20:58.320]  вершинки. Пойдем сюда. Все вершины имеют теперь степень 2. Но опять одно ребро уже нарисовано.
[20:58.320 --> 21:02.640]  Осталось какое-то второе неиспользовано. Здесь одно ребро нарисовано, осталось какое-то
[21:02.640 --> 21:06.840]  одно неиспользовано. Ну и так далее. Мы рано или поздно должны зациклиться. Потому что
[21:06.840 --> 21:08.840]  потому что у нас каждая вершина добавляет новое ребро,
[21:08.840 --> 21:10.840]  бесконечно долго ходить мы не можем,
[21:10.840 --> 21:12.840]  значит, мы рано или поздно должны зациклиться вот по этой цепочке.
[21:12.840 --> 21:14.840]  Но зациклиться вот сюда мы не можем,
[21:14.840 --> 21:16.840]  потому что здесь вершина степени 2,
[21:16.840 --> 21:18.840]  у нее и так уже оба ребра просмотрены.
[21:18.840 --> 21:20.840]  Мы можем зациклиться только в самое начало,
[21:20.840 --> 21:22.840]  как раз задействовав то самое ребро,
[21:22.840 --> 21:24.840]  которое мы здесь не использовали.
[21:24.840 --> 21:26.840]  Ну, значит, вся компонента
[21:26.840 --> 21:28.840]  это вот такую простую циклу.
[21:30.840 --> 21:32.840]  Понятно?
[21:32.840 --> 21:34.840]  Так.
[21:34.840 --> 21:36.840]  Можно считать, что Лемма доказана?
[21:38.840 --> 21:40.840]  Хорошо.
[21:40.840 --> 21:42.840]  Ну все, тогда давайте возвращаться вот сюда вот.
[21:42.840 --> 21:44.840]  Давайте в резку мы сделали, доказали.
[21:44.840 --> 21:46.840]  Теперь давайте возвращаться к графу H,
[21:46.840 --> 21:48.840]  который у нас получен как симметрическая разность
[21:48.840 --> 21:50.840]  ММ-штрих.
[21:54.840 --> 21:56.840]  Вот, давайте посмотрим на компонент связности.
[21:58.840 --> 22:00.840]  В H.
[22:02.840 --> 22:04.840]  В H могут быть такие компоненты связности.
[22:04.840 --> 22:06.840]  Давайте я разбью циклы
[22:06.840 --> 22:08.840]  и пути вот здесь
[22:08.840 --> 22:10.840]  по чётности их длины,
[22:10.840 --> 22:12.840]  чётные и нечётные.
[22:12.840 --> 22:14.840]  В H могут быть следующие компоненты.
[22:14.840 --> 22:16.840]  Во-первых, чётные пути,
[22:20.840 --> 22:22.840]  во-вторых, чётные циклы.
[22:24.840 --> 22:26.840]  Чётная в плане количества ребер на них.
[22:26.840 --> 22:28.840]  То есть, чётное количество ребер в пути,
[22:28.840 --> 22:30.840]  чётное количество ребер в цикле,
[22:30.840 --> 22:45.840]  Нечетное количество ребер в пути и то же самое нечетное количество ребер в цикле.
[22:45.840 --> 22:48.840]  Я понимаю, что каждый компонент это либо путь, либо цикл.
[22:48.840 --> 22:52.840]  Давайте их подразобьем по четности количества ребер в них.
[22:52.840 --> 22:57.840]  Я утверждаю, что вот такого не бывает.
[22:57.840 --> 23:04.840]  В графяш не может быть нечетных циклов.
[23:04.840 --> 23:16.840]  Скажите, почему?
[23:16.840 --> 23:18.840]  Давайте какой-нибудь примерчик нарисую.
[23:18.840 --> 23:21.840]  Вот, например, цикл длины 5.
[23:21.840 --> 23:26.840]  Почему в графяш не может быть цикл из 5 ребер?
[23:26.840 --> 23:34.840]  Важно, что каждое ребро в графяш пришло либо из M, либо из M'.
[23:34.840 --> 23:38.840]  При этом два соседних ребра не могли прийти из одного просочетания,
[23:38.840 --> 23:40.840]  потому что ее так устроено.
[23:40.840 --> 23:43.840]  Нельзя было, чтобы два рубра инцидентные пришли из одного просочетания.
[23:43.840 --> 23:46.840]  Скажем, если это пришло из M, то это пришло из М'.
[23:46.840 --> 23:48.840]  Это пришло из M, это пришло из M'.
[23:48.840 --> 23:50.840]  Опять пришло из M.
[23:50.840 --> 23:54.840]  В противоречии у меня все равно два ребра обязательно из одного просочу.
[23:54.840 --> 24:03.960]  Ну и так будет с каждым циклом нечетной длины, что нельзя чередоваться так, чтобы любые два
[24:03.960 --> 24:09.180]  соседа были различные при нечетной длине. Поэтому такого не бывает, у меня есть либо вот это,
[24:09.180 --> 24:15.680]  либо вот это, ну либо еще нечетные пути. При этом, смотрите, что еще надо заметить,
[24:15.680 --> 24:23.020]  вот в этом графе количество ребер, пришедших из m' обязательно строго больше, чем число
[24:23.020 --> 24:28.060]  ребер, пришедших из m. Ну потому что вообще говоря, да, изначально я вот это предполагал,
[24:28.060 --> 24:32.740]  изначально я знаю, что m' больше, чем m, потому что это максимально, это не максимально,
[24:32.740 --> 24:37.460]  по предположению. А дальше, смотрите, в этом графе по факту что я сделал, я объединил эти два
[24:37.460 --> 24:42.900]  множества и выкинул их пересечения, выкинул те ребра, которые были и там, и там. Поэтому здесь
[24:42.900 --> 24:48.820]  у меня разность между ними сохранилась, потому что я из обоих множеств выкинул ребра,
[24:48.820 --> 24:53.340]  присутствующие и там, и там, значит у меня разность сохранилась. Поэтому у меня обязательно должно
[24:53.340 --> 25:01.260]  быть такое, что в этом графе ребер из m' больше, чем ребер из m. Но это автоматически значит,
[25:01.260 --> 25:07.460]  что должен быть хотя бы один нечетный путь, на котором ребер из m' больше, чем ребер из m. То есть
[25:07.460 --> 25:15.540]  у меня должен быть обязательно вот такой вот путь, такой, что на нем типы ребер чередуются,
[25:15.540 --> 25:24.700]  и ребер из m' больше, чем ребер из m. Вот как, например, здесь. Потому что на четных путях и
[25:24.700 --> 25:29.980]  четных циклах там чередование, там поровну ребер обоих типов, из m и из m'. То есть вот эти
[25:29.980 --> 25:38.180]  привносят поровну ребер из двух просочетаний. Нечетный путь на одно больше приносит одного
[25:38.180 --> 25:43.340]  образца, чем другого. Значит, должен быть хотя бы один такой нечетный путь. Давайте это напишем.
[25:43.340 --> 26:07.340]  В h число ребер из m' должно быть больше числа ребер из m. Значит, обязательно существует вот
[26:07.340 --> 26:16.020]  такой нечетный путь, на котором типы ребер чередуются, и на нем m' больше, чем m. Значит,
[26:16.020 --> 26:31.780]  есть такой путь. Значит, есть такой нечетный путь. Вот такой вот. Так, хорошо.
[26:37.340 --> 27:04.700]  Вот, но я утверждаю, что этот путь будет как раз увеличивающим для m'.
[27:04.700 --> 27:15.660]  Потому что для него все выполнено. Во-первых, здесь типы ребер реально чередуются. Каждое
[27:15.660 --> 27:22.700]  четное ребро из m, каждое нечетное, наоборот, из m' значит не из m. Потому что здесь как раз я
[27:22.700 --> 27:27.660]  взял симметрическую разность. Значит, если ребро пришло из m', то оно точно не из m'. Поэтому
[27:27.660 --> 27:33.620]  типы ребер действительно чередуются. Дальше. Длина этого пути хотя бы один, ну потому что на
[27:33.620 --> 27:37.820]  нем ребер одного типа больше, чем другого, значит путь точно не из одной вершины состоит. Здесь есть
[27:37.820 --> 27:47.180]  хотя бы одно ребро. Ну и наконец надо показать, что концы этого пути не насыщены для m'. Вот,
[27:47.180 --> 27:53.100]  ну как-то сделать. Но будь они насыщены, что это значит? Значит, что вот здесь вот есть какое-то
[27:53.100 --> 27:58.660]  ребро из m'. Но тогда это не компонента связанности. Тогда эту компоненту связанности нужно было бы
[27:58.660 --> 28:06.300]  продлить на это ребро. А я предполагаю, что этот путь это как раз компонента. Противоречие. Ну вот,
[28:06.300 --> 28:12.700]  значит противоречие и с исходным предположением, что относительно m нет увеличивших путей. Давайте
[28:12.700 --> 28:30.340]  запишем тогда этот путь и будет увеличившим путем относительно m. Да, значит, почему его длина
[28:30.340 --> 28:39.740]  больше и равно одного? Потому что есть хотя бы одно ребро в нем. Типы ребер чередуются.
[28:39.740 --> 28:53.500]  Ну и наконец концы не насыщены относительно m. Потому что иначе, если бы было какое-то
[28:53.500 --> 28:58.220]  ребро, то значит это не компонента связанности, ее можно продлить какой-то каким-то другим ребром.
[28:58.220 --> 29:12.700]  Концы не насыщены относительно m. Иначе путь не является компонентом связанности.
[29:12.700 --> 29:32.220]  Ну все, противоречие. Ну еще раз, смотрите, вот пусть эта вершина насыщена. Это что значит?
[29:32.220 --> 29:38.940]  Значит из нее торчит ребро m. Какое-то вот такое. Но тогда это же ребро лежит ваше. А значит,
[29:38.940 --> 29:54.420]  путь должен быть покой как минимум. Нет, смотрите, если это ребро, исходящее отсюда,
[29:54.420 --> 29:59.780]  которое лежит в m, если оно не совпадает с этим, то оно гарантированно лежит ваше, потому что вот
[29:59.780 --> 30:06.020]  это лежит ваше, но вообще это должно лежать ваше. То есть это не может быть в m'. Если же это ребро
[30:06.020 --> 30:12.620]  m совпадает вот с этим, тогда это ребро не должно быть ваше. Ну тогда, опять же, тогда вообще этого
[30:12.620 --> 30:31.100]  ребра нету ваше. Ну как-то так. Ну да, да, да. Так, вроде доказал. Вопросы? Хорошо. Все, получается,
[30:31.100 --> 30:36.900]  мы доказали теорему Бержа, которая как раз говорит нам, что достаточно всего лишь прочередовать
[30:36.900 --> 30:44.420]  вдоль всех увеличивающих путей. Ну, собственно, мы так и будем делать. Причем, заметьте,
[30:44.420 --> 30:48.060]  эта теорема, вообще говоря, верна для произвольного графа. Я здесь нигде не
[30:48.060 --> 30:52.340]  пользовался двудольностью g. То есть, вообще говоря, все это рассуждение верно и для
[30:52.340 --> 30:58.260]  произвольного графа. Вот. Но алгоритм, нормальный, ну как бы, простой алгоритм получается только для
[30:58.260 --> 31:05.780]  двудольного графа. В общем случае, тоже есть, но более сложный. Так, хорошо. Значит, теперь как мы
[31:05.780 --> 31:16.540]  будем это делать? На самом деле, чтобы вот визуализировать, как мы будем находить увеличивающие
[31:16.540 --> 31:22.700]  пути, давайте я сделаю следующее. Давайте я в нашем исходном графе все ребра про сочетание ориентирую
[31:22.700 --> 31:29.060]  справа налево, а все остальные ориентирую слева направо. То есть, вот, там есть двудольный граф.
[31:29.060 --> 31:34.740]  Давайте все ребра про сочи я ориентирую справа налево, да, ну а все остальные слева направо.
[31:34.740 --> 31:47.020]  Тогда, что по факту я хочу найти? Что такое увеличивающий путь вот в этих терминах? По факту
[31:47.020 --> 31:55.580]  мне нужно просто найти какой-то путь из левой доли вправую, который начинается и заканчивается в
[31:55.580 --> 32:04.380]  ненасыщенной вершине. Вот если это ненасыщенная и это ненасыщенная, то любой путь в таком ориентированном
[32:04.380 --> 32:09.060]  графе отсюда-сюда, это как раз увеличивающий путь. Потому что начинается и заканчивается в
[32:09.060 --> 32:14.180]  ненасыщенной, длина больше либо равна одного, потому что это путь между разными долями,
[32:14.660 --> 32:19.260]  хотя бы одно ребро я использую. Ну и дальше, почему чередование выполняется. Я буду ходить
[32:19.260 --> 32:23.860]  слева направо, справа налево, и так далее, вот так вот прыгать между долями. Понятно, что первое
[32:23.860 --> 32:29.300]  ребро оно не из m, потому что слева направо. Второе из m потому что справа налево, потом опять не из
[32:29.300 --> 32:33.740]  m потому что слева направо. Ну и так далее... Я как раз буду чередоваться, чередуется направление,
[32:33.740 --> 32:41.000]  значит чередуется тип ребра из m, не из m. Поэтому, в таких терминах, вот после ориентации по
[32:41.000 --> 32:43.000]  В суть я просто буду искать путь.
[32:43.000 --> 32:49.000]  Мне в таком ориентированном графе надо найти какой-нибудь путь из ненасыщенной в ненасыщенную.
[32:49.000 --> 32:51.000]  Но это мы умеем делать с помощью DFS.
[32:51.000 --> 32:54.000]  Чтобы проверить, есть ли какой-то путь, можно пустить DFS
[32:54.000 --> 32:59.000]  и проверить, достижим ли какая-нибудь ненасыщенная правая доля из какой-то вершины левой доли.
[32:59.000 --> 33:01.000]  Вот так и будем делать.
[33:01.000 --> 33:07.000]  Для этого давайте я напишу что-то типа кода.
[33:07.000 --> 33:19.000]  Давайте я для каждой вершины правой доли буду хранить ту вершину, с которой она в парсочи.
[33:19.000 --> 33:21.000]  А если такая есть? Давайте назову match.
[33:21.000 --> 33:26.000]  match от u.
[33:26.000 --> 33:31.000]  Это для каждой вершины правой доли мы поддерживаем, с кем она соединена в парсочи слева.
[33:32.000 --> 33:34.000]  Давайте напишу так.
[33:34.000 --> 33:43.000]  Либо это минус один, либо v такая что v у это ребро взятое в m.
[33:47.000 --> 33:50.000]  Я храню того соседа, с кем она соединена в парсочи.
[33:52.000 --> 33:56.000]  Либо минус один, если такого соседа нет, если она не взята в парсочи.
[33:57.000 --> 34:03.000]  Давайте я заведу граф g, который как раз хранит все ребра слева направо.
[34:03.000 --> 34:11.000]  Как обычно у меня будет вектор векторов, который для каждой вершины левой доли хранит всех ее соседей справа.
[34:11.000 --> 34:15.000]  g для каждой вершины v.
[34:15.000 --> 34:20.000]  Если v у меня где-то слева, то g у v это список всех соседей справа.
[34:20.000 --> 34:24.000]  Список всех соседей справа.
[34:24.000 --> 34:29.000]  Всех соседей вершины v в правой доле.
[34:34.000 --> 34:37.000]  Еще мне нужен будет массив used.
[34:37.000 --> 34:41.000]  В DFS у меня есть какие-то пометочки использованности вершин.
[34:41.000 --> 34:43.000]  У меня в ориентированном случае был color, но не важно.
[34:43.000 --> 34:49.000]  Я заведу пометочки used, которые для каждой вершины левой доли говорят, был я там уже или нет.
[34:49.000 --> 34:52.000]  Если был, то нет смысла запускаться еще раз.
[34:54.000 --> 34:56.000]  Да.
[35:03.000 --> 35:07.000]  Давайте считать, что это список в исходном графе.
[35:07.000 --> 35:09.000]  И тех, и тех.
[35:09.000 --> 35:14.000]  Все неориентированные ребра, которые торчат, все эти концы я буду там хранить.
[35:14.000 --> 35:19.000]  В конце концов у меня может быть только одно плохое ребро, но я его всегда смогу отловить по этому условию.
[35:19.000 --> 35:22.000]  Если match от уровна v, то значит ребро ориентировано справа налево.
[35:22.000 --> 35:23.000]  Еще раз.
[35:23.000 --> 35:25.000]  У меня есть какая-то v.
[35:25.000 --> 35:27.000]  В исходном графе из нее исходило сколько-то ребер.
[35:27.000 --> 35:31.000]  Все эти концы добавляю в G от v.
[35:31.000 --> 35:33.000]  Что происходит?
[35:33.000 --> 35:36.000]  Почти все из них ориентированы слева направо.
[35:36.000 --> 35:40.000]  Может быть только максимум одно ориентировано справа налево, если это ребро взятое в просочетании.
[35:40.000 --> 35:45.000]  Если мы хотим его игнорировать, то надо будет проверить, не правда ли что match от этого равно этому.
[35:45.000 --> 35:49.000]  Если равно, то это ребро ориентировано справа налево, его можно игнорировать.
[35:53.000 --> 35:55.000]  Match только для вершин правой доли.
[35:55.000 --> 35:59.000]  Я как бы мог бы для обеих долей хранить, но мне только для правой достаточно.
[35:59.000 --> 36:01.000]  Match только для правой доли.
[36:01.000 --> 36:04.000]  Match для правой, G для левой.
[36:04.000 --> 36:06.000]  Ну и just.
[36:06.000 --> 36:11.000]  Да, это просто какой-то булливский флаг для всех вершин левой доли.
[36:11.000 --> 36:14.000]  Булливский флаг посещенности.
[36:14.000 --> 36:16.000]  Для вершин левой доли.
[36:29.000 --> 36:32.000]  Ну хорошо, давайте на эту процедурку.
[36:32.000 --> 36:36.000]  Процедура будет у меня называться augment.
[36:36.000 --> 36:38.000]  Увеличение.
[36:38.000 --> 36:42.000]  Давайте я напишу вершину V.
[36:42.000 --> 36:51.000]  Это какая-то вершина левой доли, из которой я буду пытаться найти путь до ненасыщенной вершины правой доли.
[36:51.000 --> 36:59.000]  Во-первых, если я здесь уже был и не преуспел, то можно завершиться.
[36:59.000 --> 37:03.000]  Если я здесь уже был, эту вершину пометил использованной.
[37:03.000 --> 37:07.000]  Грубо говоря, уже пытался найти путь из этой вершинки.
[37:07.000 --> 37:09.000]  То заново делать это не нужно.
[37:09.000 --> 37:11.000]  Я говорю, чтоб увеличить не получилось.
[37:11.000 --> 37:13.000]  Return false.
[37:13.000 --> 37:19.000]  Иначе сразу же помечаю ее использованной, чтобы в будущем не проходить несколько раз.
[37:19.000 --> 37:25.000]  И вот, если я уже был и не преуспел, то можно завершиться.
[37:25.000 --> 37:30.000]  И сразу же помечаю ее использованной, чтобы в будущем не проходить несколько раз.
[37:30.000 --> 37:34.000]  Теперь перебираю все ребра, исходящие из V.
[37:38.000 --> 37:43.000]  Как раз я перебираю какое-нибудь ребро из V в ту.
[37:46.000 --> 37:53.000]  Идеальный случай, это если бы вершина ту была ненасыщенной, и тогда у меня бы уже путь нашелся.
[37:53.000 --> 37:56.000]  Как раз я ищу путь до ненасыщенной правой доли.
[37:56.000 --> 38:02.000]  Если ту ненасыщен, то есть если match от ту равно минус один, то я уже нашел такой путь.
[38:09.000 --> 38:16.000]  Либо же, второй случай, это что я иду вдоль какого-то ребра.
[38:16.000 --> 38:18.000]  Так, давайте кончим.
[38:19.000 --> 38:24.000]  Вот у меня есть V, вот у меня есть ребро в ту.
[38:24.000 --> 38:30.000]  И это еще не конец, это только начало, грубо говоря, начало моего увеличивающего пути.
[38:30.000 --> 38:36.000]  Но если я взял ребро слева направо, то дальше, чтобы продолжить путь, мне обязательно нужно идти справа налево.
[38:36.000 --> 38:40.000]  И это ребро у меня только одно, это ребро в match от тус.
[38:40.000 --> 38:43.000]  Вот здесь лежит match от ту.
[38:43.000 --> 38:46.000]  Ну и тогда я просто возьму и запущусь DFS отсюда.
[38:46.000 --> 38:48.000]  Ну не DFS, а вот этим моим augment.
[38:48.000 --> 38:52.000]  То есть я, чтобы найти путь отсюда, я пытаюсь найти путь отсюда.
[38:52.000 --> 38:57.000]  Если получилось, то значит я его вот так вот доклеиваю, и получается как раз увеличивающий путь из V.
[38:57.000 --> 39:07.000]  Ну значит я просто пишу, или при рекруссивном запуске augment от match от ту у меня случился успех.
[39:08.000 --> 39:16.000]  То есть либо я сразу это ребро мог добавить в путь, либо мог взять его, прыгнуть справа налево,
[39:16.000 --> 39:21.000]  и потом дойти из этой вершинки с помощью augment до какой-то ненасыщенной вершины правой доли.
[39:21.000 --> 39:25.000]  Вот в любом из этих двух случаев получается, что я нашел увеличивающий путь.
[39:25.000 --> 39:32.000]  То есть либо сразу вот это ребро, либо через такое начало, и потом еще где-то рекурсивно он там нашелся.
[39:32.000 --> 39:35.000]  В любом из этих двух случаев я нашел увеличивающий путь.
[39:35.000 --> 39:39.000]  Мне нужно будет вернуть true, то есть у меня успех произошел.
[39:43.000 --> 39:49.000]  Ну и давайте считать, что у меня не только булистский флаг возвращается, нашелся путь или нет,
[39:49.000 --> 39:54.000]  но еще и сразу давайте выполним чередование, потому что мне же нет смысла просто пути находить,
[39:54.000 --> 39:58.000]  мне нужно найти и сразу сделать чередование вдоль него, чтобы парсочи увеличить.
[39:58.000 --> 40:03.000]  Ну тогда если я увеличиваю парсочи вдоль вот этого пути, то что происходит?
[40:03.000 --> 40:07.000]  По факту у меня просто вот этот матч сдвигается отсюда вот сюда вот.
[40:07.000 --> 40:10.000]  То есть у меня новым матчем для вершинки true становится v.
[40:10.000 --> 40:13.000]  Потому что это было ребром простания, а это не было.
[40:13.000 --> 40:17.000]  У меня наоборот все меняется, у меня это становится ребром простания, а это как бы пропадает.
[40:17.000 --> 40:20.000]  Значит мне можно просто переприсвоить матч от уровну v,
[40:20.000 --> 40:24.000]  а там рекурсивно все это тоже прочередуется.
[40:24.000 --> 40:27.000]  Поэтому если я здесь просто напишу матч от уровну v,
[40:27.000 --> 40:30.000]  я как раз выполню вот здесь вот чередование,
[40:30.000 --> 40:33.000]  ну а дальше все рекурсивно тоже почередуется.
[40:33.000 --> 40:35.000]  Так, ну все.
[40:35.000 --> 40:38.000]  Вот это я сделал для всех ребер.
[40:38.000 --> 40:41.000]  Если ни для одного не получилось, то return false.
[40:44.000 --> 40:46.000]  Вот такой агмент.
[40:46.000 --> 40:49.000]  Так, вопросы по коду есть?
[40:55.000 --> 40:58.000]  Смотрите, этого можно не делать.
[40:58.000 --> 41:02.000]  Я мог бы это сюда вписать для какого-то более адекватного разбора,
[41:02.000 --> 41:05.000]  но на самом деле можно этого не делать.
[41:05.000 --> 41:08.000]  Потому что если вот, смотрите, до конца,
[41:08.000 --> 41:11.000]  когда я делаю код, я делаю код, я делаю код,
[41:11.000 --> 41:14.000]  я делаю код, я делаю код.
[41:14.000 --> 41:17.000]  Или можно этого и не делать.
[41:17.000 --> 41:20.000]  Когда я перебираю, скажем, пусть это ребро ориентировано справа налево.
[41:20.000 --> 41:22.000]  Вы про этот случай, да?
[41:22.000 --> 41:25.000]  Но даже если оно такое, то что происходит?
[41:25.000 --> 41:28.000]  Это значит, что агмент запускается опять от v,
[41:28.000 --> 41:31.000]  то есть это неверно, запустится агмент от v,
[41:31.000 --> 41:34.000]  но вершина v уже помещена useDom, поэтому она автоматически будет false,
[41:34.000 --> 41:37.000]  и это tu просто проигнорируется.
[41:37.000 --> 41:40.000]  Поэтому от того, что tu лежит у меня в списке,
[41:40.000 --> 41:43.000]  у меня ни на что не влияет.
[41:43.000 --> 41:46.000]  Ну вот.
[41:48.000 --> 41:51.000]  Еще раз?
[41:52.000 --> 41:55.000]  Зачем?
[42:07.000 --> 42:10.000]  Вы про то, что не можем ли мы два ребра вот таких взять в порсоч?
[42:14.000 --> 42:17.000]  Ну да, да, да.
[42:25.000 --> 42:28.000]  Ну еще раз, если мы взяли просто первый ребро,
[42:28.000 --> 42:31.000]  то у меня граф сейчас вот такой.
[42:31.000 --> 42:34.000]  Так, что потом происходит?
[42:34.000 --> 42:37.000]  От этой же?
[42:38.000 --> 42:41.000]  Да.
[42:41.000 --> 42:44.000]  Вот.
[42:44.000 --> 42:47.000]  Про то, что не может ли два ребра быть взяты одновременно?
[42:47.000 --> 42:50.000]  Но на самом деле нет,
[42:50.000 --> 42:53.000]  потому что тут надо, я как бы этого еще не говорил,
[42:53.000 --> 42:56.000]  надо еще проговорить, как мы этот агмент запускаем.
[42:56.000 --> 42:59.000]  То есть то, что вы говорите,
[42:59.000 --> 43:02.000]  это то, что нельзя запускать агмент от уже насыщенной вершины.
[43:02.000 --> 43:05.000]  Нет, а если она не насыщенная,
[43:05.000 --> 43:08.000]  как раз все хорошо, потому что что такое агмент?
[43:08.000 --> 43:11.000]  Что по факту делает эта штука?
[43:11.000 --> 43:14.000]  Если мы ее запустим вот не насыщенной,
[43:14.000 --> 43:17.000]  она что делает? Она как раз ходит по ребрам нашего графа.
[43:17.000 --> 43:20.000]  И завершается успехом только если она нашла вершинку
[43:20.000 --> 43:23.000]  с 매ча tu равно минус один.
[43:23.000 --> 43:26.000]  То есть как раз если она дошла до не насыщенной.
[43:26.000 --> 43:29.000]  И потом чередует вдоль пути.
[43:32.000 --> 43:35.000]  Ну конечно, но это же парсочетание.
[43:35.000 --> 43:38.000]  Все нормально, нет, все хорошо.
[43:38.000 --> 43:41.000]  Еще раз, мораль агмента такая,
[43:41.000 --> 43:44.000]  если агмент запустить от не насыщенной вершины левой доли,
[43:44.000 --> 43:47.000]  то он завершится успехом, то есть он вернет true,
[43:47.000 --> 43:50.000]  если и только если он дойдет до какой-то не насыщенной вершины правой доли,
[43:50.000 --> 43:53.000]  и выпустит агмент.
[43:53.000 --> 43:56.000]  То есть если у вас нет агмента,
[43:56.000 --> 43:59.000]  то вы можете запустить агмент,
[43:59.000 --> 44:02.000]  если он дойдет до какой-то не насыщенной вершины правой доли,
[44:02.000 --> 44:05.000]  и выполнить чередование вдоль этого пути.
[44:05.000 --> 44:08.000]  То есть как раз true, если получился увеличивший путь,
[44:08.000 --> 44:11.000]  false, если не получился.
[44:11.000 --> 44:14.000]  Так, давайте тогда перерыв небольшой.
[44:14.000 --> 44:17.000]  Так, давайте продолжать.
[44:17.000 --> 44:20.000]  Смотрите, augment, это такая просто процедурка,
[44:20.000 --> 44:23.000]  которая по сути ищет путь из данной вершины
[44:23.000 --> 44:26.000]  до какой-нибудь не насыщенной вершины правой доли.
[44:26.000 --> 44:29.000]  Агаритм куна,
[44:29.000 --> 44:32.000]  непосредственно уже алгоритм поиска максимального просчитания.
[44:32.000 --> 44:35.000]  Если мы написали augment,
[44:35.000 --> 44:38.000]  то алгоритм очень короткий.
[44:38.000 --> 44:41.000]  Ну, во-первых, я used заполняю false.
[44:41.000 --> 44:44.000]  Так, давайте вот так напишу,
[44:44.000 --> 44:47.000]  массив, состоящий из false.
[44:47.000 --> 44:50.000]  То есть изначально все вершины не посещены.
[44:50.000 --> 44:53.000]  Дальше я перебираю все вершины левой доли,
[44:53.000 --> 44:56.000]  давайте я вот так напишу, v от 0 до n-1.
[44:56.000 --> 44:59.000]  Если v от вершины левой доли,
[44:59.000 --> 45:02.000]  они там пронумерованы, 0, 1, 2 и так далее,
[45:02.000 --> 45:05.000]  просто иду в этом порядке.
[45:05.000 --> 45:08.000]  Запускаю augment от v.
[45:08.000 --> 45:11.000]  Если он успешен,
[45:11.000 --> 45:14.000]  значит алгоритм смог найти какой-то
[45:14.000 --> 45:17.000]  увеличивший путь, начинающийся в v.
[45:17.000 --> 45:20.000]  И более того, он выполнил чередовать
[45:20.000 --> 45:23.000]  в доле этого пути.
[45:23.000 --> 45:26.000]  То есть там он какой-то путь нашел,
[45:26.000 --> 45:29.000]  сделал чередование, парсоль увеличился.
[45:29.000 --> 45:32.000]  Но давайте тогда в этот момент,
[45:32.000 --> 45:35.000]  поскольку у меня изменился весь граф,
[45:35.000 --> 45:38.000]  у меня сменилась ориентация ребер некоторых.
[45:38.000 --> 45:41.000]  У меня поменялось направление у тех ребер,
[45:41.000 --> 45:44.000]  которые прочередовались.
[45:44.000 --> 45:47.000]  Поэтому у меня граф,
[45:47.000 --> 45:50.000]  и значит есть смысл сбросить опять все метки юст,
[45:50.000 --> 45:53.000]  потому что у меня граф перестроился,
[45:53.000 --> 45:56.000]  и новый DFS уже будет обработан на новом графе,
[45:56.000 --> 45:59.000]  поэтому мне нужно стереть все вот эти метки.
[46:02.000 --> 46:05.000]  А если бы он завершился безуспешно,
[46:05.000 --> 46:08.000]  значит мы что-то попытались найти,
[46:08.000 --> 46:11.000]  искали какой-то путь, не нашли, но при этом граф остался тем же самым.
[46:11.000 --> 46:14.000]  Тогда эти юзды можно было бы не стирать,
[46:14.000 --> 46:17.000]  но можно было бы эту информацию использовать дальше.
[46:17.000 --> 46:20.000]  То есть если я уже из каких-то вершин пытался найти путь,
[46:20.000 --> 46:23.000]  не нашел и пытаюсь еще раз от других,
[46:23.000 --> 46:26.000]  то возвращаться туда, где я уже был, можно не возвращаться.
[46:26.000 --> 46:29.000]  Вот, ну все, конец, алгоритм Куна.
[46:29.000 --> 46:32.000]  Это правильный вопрос.
[46:32.000 --> 46:35.000]  Сейчас я буду доказывать корректность этого алгоритма.
[46:35.000 --> 46:38.000]  Но...
[46:38.000 --> 46:41.000]  Так, хорошо.
[46:41.000 --> 46:44.000]  Раз вопрос есть, давайте я сформулирую такое утверждение.
[46:44.000 --> 46:47.000]  И, наверное, вместе с ним корректность этого алгоритма
[46:47.000 --> 46:50.000]  у нас будет как-то так,
[46:50.000 --> 46:53.000]  как-то так, как-то так,
[46:53.000 --> 46:56.000]  как-то так, как-то так, как-то так,
[46:56.000 --> 47:01.000]  и, наверное, вместе с ним корректность алгоритма будет ясна.
[47:01.000 --> 47:04.000]  Надеюсь.
[47:04.000 --> 47:07.000]  Отверждение.
[47:07.000 --> 47:10.000]  Пусть m' получено из m
[47:10.000 --> 47:13.000]  чередованием вдоль увеличивающего пути.
[47:20.000 --> 47:23.000]  Пусть v
[47:24.000 --> 47:27.000]  такова,
[47:27.000 --> 47:30.000]  что из v
[47:30.000 --> 47:33.000]  нет, как бы...
[47:33.000 --> 47:36.000]  Давайте напишем, что так.
[47:36.000 --> 47:40.000]  Не было увеличивающего пути относительно m.
[47:45.000 --> 47:50.000]  Тогда из v нет увеличивающего пути относительно m'.
[47:53.000 --> 47:56.000]  Так.
[48:07.000 --> 48:10.000]  Так, если я докажу это утверждение,
[48:10.000 --> 48:13.000]  это ответит на ваш вопрос?
[48:13.000 --> 48:16.000]  Супер.
[48:16.000 --> 48:19.000]  Значит, по модулю этого утверждения что происходит?
[48:19.000 --> 48:22.000]  Здесь весь мой граф двудольный.
[48:22.000 --> 48:25.000]  Что делает алгоритм Куна?
[48:25.000 --> 48:28.000]  Он просто идет вот в этом порядке по всем вершинам левой доли
[48:28.000 --> 48:31.000]  и пытается запускать augment.
[48:31.000 --> 48:34.000]  Значит, наблюдение первое.
[48:34.000 --> 48:37.000]  Augment запускается только от ненасыщенной вершины левой доли.
[48:37.000 --> 48:40.000]  Ну, потому что даже когда я позапускал
[48:40.000 --> 48:43.000]  уже несколько augment здесь,
[48:43.000 --> 48:46.000]  у меня насыщенными могут быть только вот эти вершинки.
[48:46.000 --> 48:49.000]  Потому что я до этого момента рассматривал только их.
[48:49.000 --> 48:52.000]  И если у меня augments были только отсюда,
[48:52.000 --> 48:55.000]  то эти вершины я еще вообще как бы не видел.
[48:55.000 --> 48:58.000]  Потому что до них я никак не мог дойти.
[48:58.000 --> 49:01.000]  В них не идет вот таких вот ребер.
[49:01.000 --> 49:04.000]  Ну, потому что они еще не рассмотрены, таких ребер не добавлено.
[49:04.000 --> 49:07.000]  Значит, они не будут рассмотрены до момента,
[49:07.000 --> 49:10.000]  пока у меня вот этот форик до сюда не дойдет.
[49:10.000 --> 49:13.000]  Поэтому augment у меня запускается только вот вообще не рассмотренных еще вершин.
[49:16.000 --> 49:19.000]  Порсочи изначально.
[49:19.000 --> 49:22.000]  Изначально порсочи пустой.
[49:22.000 --> 49:25.000]  Это, наверное, можно было бы прописать.
[49:25.000 --> 49:28.000]  Изначально match я заполняю минусоединечками.
[49:28.000 --> 49:31.000]  Давайте вот это тоже здесь впишу.
[49:31.000 --> 49:34.000]  Значит, изначально match это массив, состоящий из минусоединиц.
[49:34.000 --> 49:37.000]  Это значит, что изначально никакое ребро не взято в просочитание.
[49:37.000 --> 49:40.000]  Все ребра ориентированы слева направо.
[49:40.000 --> 49:43.000]  Соответственно, никто ни с кем не соединен в порсочи.
[49:43.000 --> 49:46.000]  Вот. Ну, хорошо.
[49:46.000 --> 49:49.000]  Значит, augment у меня запускается только от ненасыщенных вершин.
[49:49.000 --> 49:53.000]  Если augment завершился как бы плохо, с false,
[49:53.000 --> 49:56.000]  то значит, он попытался что-то найти, но не смог.
[49:56.000 --> 49:59.000]  Ну, тогда понятно, что граф не перестроился.
[49:59.000 --> 50:02.000]  Граф остался таким же, как был.
[50:02.000 --> 50:05.000]  Ориентация всех ребер сохранилась.
[50:05.000 --> 50:08.000]  И юзды можно было бы не сбрасывать.
[50:08.000 --> 50:11.000]  Если не augment от v, тогда юзды можно не сбрасывать,
[50:12.000 --> 50:17.000]  А вопрос, мне кажется, он запускается от очевидной вершины.
[50:17.000 --> 50:19.000]  Да.
[50:19.000 --> 50:24.000]  Вниз мы можем залезть еще раз.
[50:24.000 --> 50:27.000]  Ну, наверх залезть можем, конечно, да.
[50:27.000 --> 50:30.000]  А вот вниз не можем.
[50:30.000 --> 50:33.000]  Потому что, ну, еще раз, смотрите, как мы можем попасть в какую-то долю?
[50:33.000 --> 50:36.000]  Мы можем попасть в левую долю только с помощью ребра справа налево.
[50:36.000 --> 50:39.000]  Но если эти вершины я еще вообще ни разу не трогал,
[50:39.000 --> 50:44.000]  то в них не может входить никакого ребро справа налево.
[50:44.000 --> 50:47.000]  Потому что ребро входит, то есть, смотрите, match,
[50:47.000 --> 50:50.000]  когда у меня вообще в какую-то вершину слева появляется ребро,
[50:50.000 --> 50:53.000]  только в этой строчке.
[50:53.000 --> 50:58.000]  Ну, а значит, у меня augment от вершины уже запущен.
[51:02.000 --> 51:05.000]  Хорошо, давайте другими словами скажу.
[51:06.000 --> 51:09.000]  Значит, изначально граф у меня такой.
[51:09.000 --> 51:13.000]  Изначально все ребра только слева направо.
[51:13.000 --> 51:16.000]  Согласны? Потому что match пустой.
[51:16.000 --> 51:19.000]  Дальше я запускаю augment от нулевой вершинки.
[51:19.000 --> 51:22.000]  Что может произойти?
[51:22.000 --> 51:25.000]  Может найти какой-то увеличивающий путь.
[51:25.000 --> 51:28.000]  А, можно еще, вот что можно сказать.
[51:28.000 --> 51:30.000]  Как работает увеличивающий путь?
[51:30.000 --> 51:33.000]  Он начинается слева в ненасыщенной,
[51:33.000 --> 51:37.000]  ходит по насыщенным и заканчивается справа в ненасыщенной.
[51:37.000 --> 51:40.000]  Поэтому все вот эти промежуточные уже тоже насыщенные,
[51:40.000 --> 51:43.000]  а значит, как бы уже рассмотрены ранее.
[51:43.000 --> 51:47.000]  Вот эти все, то есть, на самом деле любой augment работает как-то так.
[51:47.000 --> 51:49.000]  Он, наоборот, как бы наверх идет.
[51:49.000 --> 51:52.000]  То есть, вот эти вершины должны быть насыщенными.
[51:59.000 --> 52:01.000]  Что у меня происходит?
[52:01.000 --> 52:04.000]  Какое-то ребро могло быть ориентировано справа налево в нулевую вершинку.
[52:04.000 --> 52:06.000]  Дальше я запускаю augment от одного.
[52:06.000 --> 52:09.000]  Он опять как-то ходит, и все, что он может сделать,
[52:09.000 --> 52:12.000]  это ориентировать какое-то ребро.
[52:12.000 --> 52:14.000]  Вот сюда попасть ниже он не может,
[52:14.000 --> 52:17.000]  потому что туда нет никаких ребер справа налево.
[52:17.000 --> 52:27.000]  Единственное, что он может сделать, это какое-то ребро перенаправить в единицу.
[52:27.000 --> 52:30.000]  Все вершинки с большими номерами будут по-прежнему неиспользованы.
[52:30.000 --> 52:32.000]  Мы от них даже не запустимся.
[52:36.000 --> 52:38.000]  То есть, получается, что...
[52:38.000 --> 52:40.000]  Вернусь, где я был.
[52:40.000 --> 52:42.000]  Я пытаюсь найти увеличущий путь.
[52:42.000 --> 52:45.000]  Если получилось, то я перестраиваю граф и сбрасываю все метки,
[52:45.000 --> 52:48.000]  потому что, возможно, появились какие-то новые пути.
[52:48.000 --> 52:52.000]  Если не получилось, то значит как раз я запустил сотни насыщенной.
[52:52.000 --> 52:56.000]  Она не дала никакого успеха, она не дала никакого пути.
[52:56.000 --> 52:58.000]  Значит, по этому утверждению,
[52:58.000 --> 53:02.000]  как бы у меня ни менялось впоследствии парасочетания,
[53:02.000 --> 53:04.000]  это V уже бесполезно.
[53:04.000 --> 53:07.000]  Я из нее больше ничего не найду,
[53:07.000 --> 53:09.000]  и можно заново от нее не запускаться.
[53:09.000 --> 53:11.000]  Можно ее игнорировать, как будто бы нет.
[53:11.000 --> 53:13.000]  В графе она ничего не дает.
[53:13.000 --> 53:16.000]  Можно просто в этом порядке пройти сверху вниз
[53:16.000 --> 53:19.000]  и запускаться только в этом порядке по вершинам.
[53:23.000 --> 53:25.000]  Вопросы, может быть.
[53:27.000 --> 53:28.000]  Хорошо.
[53:28.000 --> 53:30.000]  Сейчас я докажу это утверждение,
[53:30.000 --> 53:32.000]  только асимптотику скажу сначала.
[53:32.000 --> 53:35.000]  Асимптотика алгоритма Куна будет такая.
[53:35.000 --> 53:38.000]  Я напишу ее как E умножить на ответ.
[53:44.000 --> 53:48.000]  Я, как обычно, предполагаю, что E больше, чем V,
[53:48.000 --> 53:52.000]  потому что иначе можно в каждой компанией связанность решать независимо.
[53:52.000 --> 53:54.000]  E откуда?
[53:54.000 --> 53:57.000]  Это по факту просто DFS по графу нашему.
[53:57.000 --> 54:01.000]  ans – это размер максимального просочетания.
[54:01.000 --> 54:03.000]  Почему E на ans?
[54:03.000 --> 54:06.000]  Потому что количество сбрасываний меток юст
[54:06.000 --> 54:09.000]  примерно равно ans.
[54:09.000 --> 54:13.000]  И между двумя последователями сбрасываний у меня граф фиксирован.
[54:13.000 --> 54:15.000]  Метки юст никуда не исчезают.
[54:15.000 --> 54:18.000]  Значит, суммарное количество обхода всех вершин и всех ребер
[54:18.000 --> 54:20.000]  примерно E плюс V.
[54:20.000 --> 54:24.000]  Я юзды сбрасываю только между успешными агментами.
[54:24.000 --> 54:27.000]  Соответственно, между успешными агментами граф фиксирован.
[54:27.000 --> 54:29.000]  Юзды я не сбрасываю.
[54:29.000 --> 54:32.000]  Я запускаю агменты просто каких-то вершин.
[54:32.000 --> 54:34.000]  Если там был юст, то я ее просто игнорирую.
[54:34.000 --> 54:38.000]  Если не юст, то обхожу и два раза ничего не обхожу.
[54:38.000 --> 54:43.000]  Поэтому суммарно у меня столько раз запускается DFS.
[54:43.000 --> 54:49.000]  Понятно, что это не больше, чем просто E умножить на V,
[54:49.000 --> 54:55.000]  потому что ребер в парсочи максимум V.
[54:55.000 --> 54:59.000]  Потому что каждая вершина левой доли дает максимум одну ребро.
[54:59.000 --> 55:04.000]  Теперь осталось вот это утверждение доказать.
[55:04.000 --> 55:07.000]  Отверждение.
[55:07.000 --> 55:09.000]  Давайте скажем следующее.
[55:09.000 --> 55:14.000]  Пусть m штрих, полученный из m,
[55:14.000 --> 55:18.000]  чередованием вдоль какого-нибудь пути x, y.
[55:30.000 --> 55:32.000]  Что это значит?
[55:44.000 --> 55:49.000]  У меня был вот такой путь, в котором тип и ребер чередуются.
[55:49.000 --> 55:53.000]  m штрих m, m штрих m, m штрих.
[55:53.000 --> 55:56.000]  И при этом крайние вершины были не насыщены относительно m.
[55:56.000 --> 56:01.000]  Тогда как раз я могу выполнить чередование и получить больше и больше парсочек.
[56:01.000 --> 56:05.000]  Теперь вот вершина V.
[56:05.000 --> 56:10.000]  Пусть вершина V такова, что из V не было увеличивающей пути относительно m.
[56:15.000 --> 56:22.000]  Тогда понятно, что V отлична от x и y, потому что из x есть путь и из y есть путь.
[56:22.000 --> 56:26.000]  Более того, я буду считать, что V не насыщена относительно m.
[56:26.000 --> 56:34.000]  Потому что если она насыщена относительно m, то из нее вообще никакого увеличивающей пути быть не может, потому что она насыщена.
[56:34.000 --> 56:40.000]  V не насыщена, поэтому она обязательно лежит не на этом пути, потому что здесь все насыщены.
[56:40.000 --> 56:43.000]  Вот V где-то здесь.
[56:43.000 --> 56:46.000]  V не насыщены вершины, лежащие вне этого пути.
[56:46.000 --> 56:52.000]  И давайте пойдем от противного. Пусть есть какой-то увеличивающий путь из V относительно m штрих.
[56:52.000 --> 56:56.000]  Ну какой-то такой путь.
[56:56.000 --> 56:59.000]  Тогда утверждаю, что он обязательно пересекается вот с этим путем.
[56:59.000 --> 57:04.000]  Но потому что если внезапно этот путь никак не пересекается с этим путем,
[57:04.000 --> 57:11.000]  то то, что здесь было чередованием относительно m штрих, будет также чередованием относительно m.
[57:11.000 --> 57:13.000]  Потому что у меня m и m штрих отличаются только вдоль этого пути, значит то, что здесь увеличивает относительно m штрих, то же самое относительно m.
[57:13.000 --> 57:18.000]  Раз я вообще вот эти ребер никак не задеваю, то вне этого пути m и m штриха одно и то же.
[57:18.000 --> 57:33.000]  Поэтому если это увеличивающий путь относительно m штрих, то и относительно m это тоже увеличивающий путь.
[57:33.000 --> 57:35.840]  обязательно пересекается вот с этим вот путем.
[57:35.840 --> 57:38.840]  Ну и давайте рассмотрим первый момент такого пересечения.
[57:38.840 --> 57:43.840]  Что-нибудь такое я нарисую, да.
[57:43.840 --> 57:49.840]  Ну как-нибудь так.
[57:49.840 --> 57:51.840]  Вот, да.
[57:51.840 --> 58:08.840]  Ну еще раз, если есть какой-то путь вне этого пути, увеличивший
[58:08.840 --> 58:12.240]  относительно m штрих, то он же будет увеличившим относительно
[58:12.240 --> 58:17.240]  m, потому что с точки зрения всего, кроме этого пути,
[58:17.240 --> 58:20.240]  вот этого вот x и y, у меня m и m штрих это одно и то же,
[58:20.640 --> 58:22.640]  потому что чередование только вдоль него произошло.
[58:22.640 --> 58:27.640]  Значит у меня это было бы увеличившим путем м, противоречие.
[58:27.640 --> 58:36.640]  Так, значит еще раз, вот есть какой-то путь вот такой.
[58:36.640 --> 58:39.640]  И дальше он куда-то ведет, я рассматриваю первую вершину
[58:39.640 --> 58:42.640]  на этом пути, которая попала на путь x и y, пусть это вершинка
[58:42.640 --> 58:46.640]  u.
[58:46.640 --> 58:49.640]  Вот, раз это увеличивший путь относительно m штрих,
[58:50.040 --> 58:51.040]  то ребра чередуются.
[58:51.040 --> 58:56.040]  Это не из m штрих, как бы не m штрих, это m штрих, это
[58:56.040 --> 59:00.040]  не m штрих, это m штрих.
[59:00.040 --> 59:01.040]  Вот.
[59:01.040 --> 59:03.040]  Ну конкретно такой картинке быть не может, потому что
[59:03.040 --> 59:06.040]  еще раз, вне вот этого пути m штрих и m это одно и то же,
[59:06.040 --> 59:11.040]  значит получается у вершинки u два соседа одновременно
[59:11.040 --> 59:14.040]  лежали в m, да, два инцидента ребра лежат в m.
[59:14.040 --> 59:17.040]  Поэтому такого быть не может, и получается, что последнее
[59:17.440 --> 59:20.440]  ребро вот на этом пути обязательно наоборот не из m штрих.
[59:20.440 --> 59:23.440]  Так, значит такого не бывает, да, вот такого не бывает.
[59:26.440 --> 59:28.440]  Значит последнее ребро вот это тоже пунктированное
[59:28.440 --> 59:31.440]  должно быть, не из m штрих.
[59:47.440 --> 59:49.440]  Ну вот как-то так.
[59:52.440 --> 59:53.440]  Вот.
[59:53.440 --> 59:56.440]  Ну тогда я утверждаю, что здесь очень легко заметить
[59:56.440 --> 59:59.440]  путь, увеличивший относительно m.
[01:00:03.440 --> 01:00:06.440]  Можно просто вот так вот, например, пойти, и это
[01:00:06.440 --> 01:00:09.440]  будет путь, увеличивший относительно m.
[01:00:09.440 --> 01:00:12.440]  Да, потому что как раз у меня будет чередовый путь,
[01:00:12.840 --> 01:00:14.840]  и это будет путь, увеличивший относительно m.
[01:00:14.840 --> 01:00:17.840]  Да, потому что как раз у меня будет чередование,
[01:00:17.840 --> 01:00:19.840]  вот здесь m и m штриха одно и то же, поэтому здесь
[01:00:19.840 --> 01:00:24.840]  как раз не из m, из m, не из m, из m, не из m.
[01:00:24.840 --> 01:00:29.840]  Путь, чередование ребер есть, концы не насыщенные,
[01:00:29.840 --> 01:00:32.840]  ну и длина его больше одном, потому что v вне этого
[01:00:32.840 --> 01:00:35.840]  пути, значит хотя бы одно ребро мне понадобилось.
[01:00:35.840 --> 01:00:38.840]  Значит вот этот путь, увеличивающий относительно m.
[01:00:39.240 --> 01:00:44.240]  Она увеличивающий относительно m.
[01:00:44.240 --> 01:00:46.240]  Ну противоречие.
[01:00:54.240 --> 01:00:56.240]  Так, что-то понятно?
[01:01:03.240 --> 01:01:04.240]  Да.
[01:01:04.240 --> 01:01:06.240]  Ну это не то, что я предполагаю.
[01:01:06.640 --> 01:01:09.640]  Я говорю, что можно считать что?
[01:01:09.640 --> 01:01:16.640]  Потому что если v насыщенная, то значит очевидно из
[01:01:16.640 --> 01:01:19.640]  нее нет увеличившей пути, потому что из насыщенных
[01:01:19.640 --> 01:01:20.640]  не бывает.
[01:01:20.640 --> 01:01:23.640]  Дальше, если она лежит на пути, то она либо x, либо
[01:01:23.640 --> 01:01:27.640]  y, но тогда вот это неверно, потому что из x и из y есть
[01:01:27.640 --> 01:01:28.640]  увеличивший путь.
[01:01:28.640 --> 01:01:31.640]  Поэтому можно считать, что v не насыщенная, не
[01:01:31.640 --> 01:01:32.640]  лежащая на этом пути.
[01:01:33.040 --> 01:01:35.040]  Так, вопрос есть по доказательству?
[01:01:38.040 --> 01:01:39.040]  Окей, мораль.
[01:01:39.040 --> 01:01:42.040]  Еще раз утверждение по модулю технического разбора
[01:01:42.040 --> 01:01:43.040]  случаев.
[01:01:43.040 --> 01:01:45.040]  Утверждение говорит в следующее, что если вершина
[01:01:45.040 --> 01:01:48.040]  один раз бесполезна, если мы один раз из нее не смогли
[01:01:48.040 --> 01:01:51.040]  найти увеличивший путь, то дальше пытаться из нее
[01:01:51.040 --> 01:01:54.040]  еще раз искать увеличивший путь бессмысленно.
[01:01:55.040 --> 01:01:57.040]  Вот, там какое-то доказательство.
[01:01:57.040 --> 01:02:00.040]  Но смысл такой, что вот если я один раз запустил
[01:02:00.440 --> 01:02:03.440]  с аугментом от v и как бы провалился, то нет смысла
[01:02:03.440 --> 01:02:04.440]  делать это еще раз.
[01:02:04.440 --> 01:02:06.440]  Ну все, поэтому как раз достаточно просто один
[01:02:06.440 --> 01:02:08.440]  раз перебрать вершину в этом порядке.
[01:02:08.440 --> 01:02:12.440]  И нет смысла заново кучу раз запускать здесь аугмент,
[01:02:12.440 --> 01:02:14.440]  потому что если один раз не получилось, то больше
[01:02:14.440 --> 01:02:15.440]  никогда не получится.
[01:02:15.440 --> 01:02:16.440]  Ну все.
[01:02:20.440 --> 01:02:23.440]  Так, тогда вроде бы кун закончился.
[01:02:23.840 --> 01:02:26.840]  Дальше едем?
[01:02:26.840 --> 01:02:37.840]  Ладно.
[01:02:37.840 --> 01:02:42.840]  Так теперь, значит, смотрите, я хочу еще...
[01:02:42.840 --> 01:02:44.840]  В общем, вот в доводовольных графах какие-то задачи решаются
[01:02:44.840 --> 01:02:46.840]  проще, чем в произвольных.
[01:02:46.840 --> 01:02:48.840]  Например, парсо чищеца не заново не будет.
[01:02:48.840 --> 01:02:52.840]  но в дудольных графах какие-то задачи решаются проще, чем в произвольных.
[01:02:52.840 --> 01:02:55.840]  Например, парсочи ищется относительно несложно.
[01:02:55.840 --> 01:02:58.840]  То есть по модуле вот этих утверждений код очень простой.
[01:02:58.840 --> 01:03:02.840]  Агмент был на доску, и там сам кун несколько строчек общий.
[01:03:02.840 --> 01:03:06.840]  Более того, оказывается, что в дудольных графах можно искать
[01:03:06.840 --> 01:03:11.840]  не только парсочи эффективно, но и, например, максимальное независимое множество.
[01:03:11.840 --> 01:03:14.840]  Если помните, где-то в начале семестра мы разбирали алгоритм,
[01:03:14.840 --> 01:03:19.840]  который находит максимальную клику в графе за два в степени напополам.
[01:03:19.840 --> 01:03:23.840]  Можно показать, что в произвольном графе эта задача реально сложная,
[01:03:23.840 --> 01:03:27.840]  и пока что никто не умеет ее решать быстрее, чем за какой-то экспонент.
[01:03:27.840 --> 01:03:31.840]  А в дудольном случае это можно делать довольно быстро.
[01:03:31.840 --> 01:03:37.840]  Давайте я быстренько веду пару определений на всякий случай.
[01:03:37.840 --> 01:03:43.840]  Во-первых, пусть g это граф.
[01:03:43.840 --> 01:03:51.840]  Тогда под множеством множества вершин называется независимым множеством.
[01:03:51.840 --> 01:03:55.840]  Наверное, здесь сразу уже определял, но ну и ладно.
[01:03:55.840 --> 01:04:06.840]  Независимым множеством, если никакие две вершины из I не соединены ребром.
[01:04:06.840 --> 01:04:15.840]  Для любых u, v из I, u, v это не ребро.
[01:04:15.840 --> 01:04:34.840]  Далее, c как под множество v называется вершинным покрытием.
[01:04:34.840 --> 01:04:44.840]  Если любое ребро хотя бы одним из своих концов лежит в c.
[01:04:44.840 --> 01:04:55.840]  То есть если любое ребро нашего графа хотя бы u или v лежит в c.
[01:04:55.840 --> 01:05:09.840]  То есть хотя бы одна из вершин u, v лежит в c.
[01:05:09.840 --> 01:05:16.840]  Это такое множество вершин, что любое ребро либо вообще целиком здесь внутри c лежит.
[01:05:16.840 --> 01:05:18.840]  То есть оба конца могут быть внутри c.
[01:05:18.840 --> 01:05:22.840]  Либо один конец в c, а другой вне c.
[01:05:22.840 --> 01:05:30.840]  И других ребр нет.
[01:05:30.840 --> 01:05:39.840]  Значит, простое замечание, что I это независимое множество,
[01:05:39.840 --> 01:05:56.840]  если и только если дополнение к нему на v-I. Это вершинное покрытие.
[01:05:56.840 --> 01:05:59.840]  Ну вроде понятно. Вот как раз давайте вот на этой картинке посмотрим.
[01:05:59.840 --> 01:06:01.840]  Что такое вершинное покрытие?
[01:06:01.840 --> 01:06:07.840]  Это такое множество, что любое ребро либо внутри целиком, либо одним концом внутри, а другим вне.
[01:06:07.840 --> 01:06:13.840]  Значит все остальные вершинки, v без c, это как раз независимое множество,
[01:06:13.840 --> 01:06:15.840]  потому что здесь ребра быть не может.
[01:06:15.840 --> 01:06:18.840]  Будь здесь ребро, это противоречило бы определению вершинного покрытия.
[01:06:18.840 --> 01:06:24.840]  Ну и наоборот, если вот это независимое, значит все ребра максимум одним концом лежат здесь.
[01:06:24.840 --> 01:06:30.840]  Ну как раз дополнение это вершинное покрытие.
[01:06:30.840 --> 01:06:35.840]  Получается у нас есть такая двойственность между независимым множеством вершинным покрытиями.
[01:06:35.840 --> 01:06:39.840]  Значит в частности, если бы я хотел найти максимальное независимое,
[01:06:39.840 --> 01:06:42.840]  то дополнение к нему это всегда минимальное вершинное покрытие.
[01:06:42.840 --> 01:06:49.840]  Если они друг другу соответствуют, то максимизирую одно, я минимизирую другое.
[01:06:49.840 --> 01:06:51.840]  Ну не буду это писать.
[01:06:51.840 --> 01:06:54.840]  Если мне хочется найти максимальное независимое,
[01:06:54.840 --> 01:07:00.840]  то это тоже самое, что найти минимальное вершинное покрытие и взять дополнение.
[01:07:00.840 --> 01:07:06.840]  Ну и теперь давайте научимся в вдвольном графе находить максимальное независимое и минимальное вершинное покрытие.
[01:07:06.840 --> 01:07:10.840]  Напоминаю, что в произвольном случае, в случае произвольного графа,
[01:07:10.840 --> 01:07:16.840]  вот эта вот задача NP-трудная, то есть пока что никто не умеет решать быстрее, чем закрыть экспонент.
[01:07:16.840 --> 01:07:18.840]  И поскольку между ними есть такое простое соответствие,
[01:07:18.840 --> 01:07:21.840]  то значит и минимальное вершинное покрытие тоже никто не умеет быстро решать,
[01:07:21.840 --> 01:07:23.840]  потому что они друг через друга выражаются.
[01:07:23.840 --> 01:07:26.840]  А в вдвольном случае это делается довольно просто.
[01:07:26.840 --> 01:07:30.840]  Теорема Кёнига.
[01:07:30.840 --> 01:07:50.840]  В вдвольном графе размер минимального вершинного покрытия равен размеру максимального просчитания.
[01:07:57.840 --> 01:08:05.840]  То есть сколько ребер в парсочи, столько вершин в покрытии.
[01:08:05.840 --> 01:08:11.840]  И тем самым, если мы найдем максимальное просчитание, то мы найдем, собственно, минимальное вершинное покрытие.
[01:08:11.840 --> 01:08:15.840]  Так, ну доказательства.
[01:08:15.840 --> 01:08:21.840]  Давайте я сначала построю конструктивный алгоритм для поиска вот этого самого минимального вершинного покрытия.
[01:08:21.840 --> 01:08:25.840]  Алгоритм.
[01:08:25.840 --> 01:08:30.840]  Во-первых, ну собственно, найдем максимальное просчитание.
[01:08:30.840 --> 01:08:35.840]  Пусть М это максимальное просчитание.
[01:08:35.840 --> 01:08:46.840]  Во-вторых, так же как и раньше, я ориентирую все ребра нашего графа так, что ребра из парсочи торчат справа налево, все остальные слева направо.
[01:08:46.840 --> 01:08:51.840]  Ориентируем ребра так же как раньше.
[01:08:51.840 --> 01:08:56.840]  То есть справа налево те, которые были в М, слева направо те, которые не были в М.
[01:08:56.840 --> 01:08:59.840]  Так же как раньше.
[01:08:59.840 --> 01:09:01.840]  Третье.
[01:09:01.840 --> 01:09:10.840]  Давайте запустим какой-нибудь обход DFS, BFS, не важно, какой-нибудь обход графа из всех ненасыщенных вершин левой доли.
[01:09:10.840 --> 01:09:25.840]  Запустим, давайте скажем, DFS из всех ненасыщенных вершин левой доли.
[01:09:25.840 --> 01:09:30.840]  Значит, тогда весь граф у меня разобьется на четыре вот таких облачка.
[01:09:30.840 --> 01:09:36.840]  L плюс, L минус, R плюс, R минус.
[01:09:36.840 --> 01:09:42.840]  Это, соответственно, посещенные слева, непосещенные слева, посещенные справа, непосещенные справа.
[01:09:42.840 --> 01:09:44.840]  Вот после вот этого обхода.
[01:09:44.840 --> 01:09:48.840]  То есть у меня в левой доле есть несколько ненасыщенных вершин.
[01:09:48.840 --> 01:09:50.840]  Я просто запускаю из них из всех DFS.
[01:09:50.840 --> 01:09:52.840]  Все, что посетилось, это L плюс, R плюс.
[01:09:52.840 --> 01:09:55.840]  То, что не посетилось, это L минус, R минус.
[01:09:55.840 --> 01:10:03.840]  Значит, тогда утверждается, что L плюс в объединении с R минус это максимально независимое множество.
[01:10:07.840 --> 01:10:14.840]  Ну а дополнение, то есть все остальное, получается L минус в объединении с R плюс, это минимальное вершины покрытия.
[01:10:18.840 --> 01:10:20.840]  Сейчас это докажем.
[01:10:25.840 --> 01:10:29.840]  Так, ну картинка.
[01:10:37.840 --> 01:10:41.840]  Значит, это вот разбиение всех вершин на четыре категории.
[01:10:41.840 --> 01:10:45.840]  Я утверждаю, что в этом графе, я напоминаю, сейчас граф ориентированный,
[01:10:45.840 --> 01:10:49.840]  вот на втором шаге я все ребра ориентировал в одну из двух сторон,
[01:10:49.840 --> 01:10:53.840]  давайте докажем, что каких-то ребер в этом графе нет.
[01:10:53.840 --> 01:10:55.840]  Ну например, вот таких вот ребер.
[01:10:55.840 --> 01:10:59.840]  И вот таких вот ребер я буду есть.
[01:10:59.840 --> 01:11:04.840]  Вот здесь тоже сейчас всё утверждаю, что 여기 есть ребра,
[01:11:04.840 --> 01:11:07.840]  и теперь я собираю больше ребра.
[01:11:07.840 --> 01:11:13.840]  Ну, например, вот таких вот ребер и вот таких вот ребер в нашем графе тривиальным образом быть не
[01:11:13.840 --> 01:11:24.280]  может. Почему? Ну да, потому что если есть ребро из плюсов в минус, значит DFS, находясь вот здесь,
[01:11:24.280 --> 01:11:29.760]  должен был бы пройти по этому ребру и посетить эту вершину тоже. То же самое здесь. Если бы он
[01:11:29.760 --> 01:11:34.240]  был здесь, то он обязан был бы быть здесь. Значит, ребер из плюсов в минус не бывает,
[01:11:34.240 --> 01:11:41.120]  потому что так работает DFS. Ну и еще я утверждаю, что не бывает вот таких вот ребер из R минуса в L
[01:11:41.120 --> 01:11:52.400]  плюс. Почему не бывает ребер из R минуса в L плюс? Ну пусть есть. Да, пусть есть какое-то вот такое
[01:11:52.400 --> 01:11:59.640]  ребро из R минуса в L плюс. Ну что это значит? Это ребро справа налево, значит это ребро
[01:11:59.640 --> 01:12:08.960]  про сочетание. Значит, эта вершина насыщенная. Значит, из нее непосредственно DFS не запускался.
[01:12:08.960 --> 01:12:14.920]  DFS мог только в нее каким-то образом прийти из ненасыщенной. То есть DFS должен был бы как-то
[01:12:14.920 --> 01:12:21.280]  начаться в ненасыщенной, как-то походить по графу и сюда прийти. Но никаким другим образом,
[01:12:21.280 --> 01:12:25.380]  кроме как с помощью этого ребра, мы прийти в эту вершину не можем. Потому что в нее никаких
[01:12:25.380 --> 01:12:32.580]  других входящих ребер нет. Значит, эту вершину мы просто не могли бы посетить. Поэтому в этой
[01:12:32.580 --> 01:12:44.900]  вершине не может быть L плюс. Да, давайте пару слов напишу здесь. Нет ребер из R минуса в L плюс,
[01:12:44.900 --> 01:12:56.140]  но так как, давайте это назову V, так как никаким другим способом V попасть нельзя. Никаким другим
[01:12:56.140 --> 01:13:13.720]  способом, кроме как с помощью этого ребра попасть в V нельзя. А если я попадаю сюда с помощью этого
[01:13:13.720 --> 01:13:19.180]  ребра и эта посещена, значит, эта тоже должна была быть посещена, чтобы я по этому ребру мог
[01:13:19.180 --> 01:13:28.600]  пройти. Ну вот, значит, у меня уже получилось, что вот это вот это независимое множество. Как раз L
[01:13:28.600 --> 01:13:34.180]  плюс в объединении с R минусом это независимое множество. Потому что нет ребер внутри вот этих
[01:13:34.180 --> 01:13:43.340]  ходоболочков и нет ребер между ними. И автоматически значит, что дополнение это вершины покрытия. Теперь
[01:13:43.340 --> 01:13:48.480]  надо показать, что это соответственно экстремальные в своем классе. То есть, что L плюс и R минус это
[01:13:48.480 --> 01:13:54.220]  максимально независимое множество. Или что то, что R плюс в объединении с L минус это минимальное
[01:13:54.220 --> 01:14:09.240]  вершины покрытия. Докажем, что вот это вот, это минимальное вершины покрытия. То есть мы доказали,
[01:14:09.240 --> 01:14:17.240]  То есть это просто вершинное покрытие, но я утверждаю, что оно еще и минимально, то есть нет никакого другого меньшего размера.
[01:14:17.240 --> 01:14:27.240]  Так. Ну, замечание первое. Вот здесь вот лежат только насыщенные вершины.
[01:14:27.240 --> 01:14:31.240]  А вот в этих вот множествах могут быть только насыщенные вершинки.
[01:14:31.240 --> 01:14:38.240]  Ну понятно, в L- понятно только насыщенные, потому что из ненасыщенных мы запустили DFS, и все ненасыщенные автоматически здесь.
[01:14:38.240 --> 01:14:42.240]  Поэтому здесь могут быть только ненасыщенные в L-.
[01:14:42.240 --> 01:14:48.240]  Почему в R-плюс только, извините, здесь только насыщенные?
[01:14:48.240 --> 01:14:52.240]  Потому что все ненасыщенные здесь, значит насыщенные могут быть только здесь.
[01:14:52.240 --> 01:14:55.240]  Почему здесь все насыщенные?
[01:14:59.240 --> 01:15:00.240]  И что?
[01:15:03.240 --> 01:15:06.240]  Насыщенные те, которые в парсоте участвуют.
[01:15:08.240 --> 01:15:16.240]  Ну, если они находятся в середине парсотча... А, сейчас.
[01:15:16.240 --> 01:15:20.240]  А почему это не может быть последнее ребро вот в этом пути?
[01:15:20.240 --> 01:15:24.240]  То есть, например, я начал в ненасыщенной, шел-шел по ребрам и закончил тоже в ненасыщенной.
[01:15:24.240 --> 01:15:26.240]  Если это последнее ребро.
[01:15:26.240 --> 01:15:28.240]  А если это последнее ребро?
[01:15:28.240 --> 01:15:31.240]  Потому что, когда я иначе, это был бы увеличивающий путь просто.
[01:15:31.240 --> 01:15:36.240]  То есть если бы здесь была какая-то ненасыщенная, и она лежит в R-плюсе,
[01:15:36.240 --> 01:15:38.240]  что значит она лежит в R-плюсе?
[01:15:38.240 --> 01:15:44.240]  Значит, я до нее дошел из какой-то ненасыщенной вершины левой доли.
[01:15:44.240 --> 01:15:50.240]  А все еще plankton здесь, эти ненасыщенные, эти не насыщенные, которые находятся в R-плюсе.
[01:15:50.240 --> 01:15:52.240]  Что значит не насыщенные?
[01:15:52.240 --> 01:15:55.240]  что значит, что она лежит в r-плюсе,
[01:15:55.240 --> 01:15:58.240]  я до нее дошел из какой-то ненасыщенной вершины левой доли.
[01:15:58.240 --> 01:16:01.240]  То есть есть какой-то путь отсюда до сюда,
[01:16:01.240 --> 01:16:03.240]  как раз чередующие типы с лево-направо-справо,
[01:16:03.240 --> 01:16:05.240]  с лево-направо-справо, с лево-направо-справо,
[01:16:05.240 --> 01:16:08.240]  и так далее, начинающий и заканчивающий в ненасыщенной.
[01:16:08.240 --> 01:16:10.240]  Значит, исход на m не максимальный,
[01:16:10.240 --> 01:16:13.240]  а я взял максимальное прочитание.
[01:16:13.240 --> 01:16:18.240]  Поэтому в r-плюсе тоже могут быть только насыщенные.
[01:16:18.240 --> 01:16:25.240]  В r-плюс и l-минус лежат только насыщенные вершинки.
[01:16:32.240 --> 01:16:34.240]  При этом мы с вами доказали,
[01:16:34.240 --> 01:16:37.240]  что ребер из r-плюса в l-минус не бывает,
[01:16:37.240 --> 01:16:39.240]  таких вот ребер быть не может.
[01:16:39.240 --> 01:16:50.240]  Значит, ни для какого ребра парасочетания
[01:16:50.240 --> 01:16:55.240]  оба его конца не могут лежать одновременно вот здесь и вот здесь.
[01:16:55.240 --> 01:16:57.240]  Потому что как раз такое ребро означало бы,
[01:16:57.240 --> 01:16:59.240]  что это ребро из r-плюса в l-минус.
[01:16:59.240 --> 01:17:02.240]  Это значит, что любое ребро парасочетания
[01:17:02.240 --> 01:17:07.240]  максимум только одним своим концом лежит вот в этом множестве.
[01:17:07.240 --> 01:17:11.240]  Второе наблюдение, что любое ребро парасочетания,
[01:17:11.240 --> 01:17:15.240]  любое ребро m,
[01:17:15.240 --> 01:17:24.240]  только одним своим концом
[01:17:24.240 --> 01:17:34.240]  может лежать в этом вот нашем r-плюс в объединении с l-минус.
[01:17:34.240 --> 01:17:36.240]  Потому что если оба конца, то значит,
[01:17:36.240 --> 01:17:38.240]  это вот такое ребро справа налево,
[01:17:38.240 --> 01:17:40.240]  а мы докажем, что их не бывает.
[01:17:40.240 --> 01:17:42.240]  Но отсюда автоматически следует,
[01:17:42.240 --> 01:17:46.240]  что размер этого множества не больше,
[01:17:46.240 --> 01:17:49.240]  чем всего ребер в парасочетании.
[01:17:49.240 --> 01:17:53.240]  Раз каждый ребро парасочетания максимум одну вершинку добавляет,
[01:17:53.240 --> 01:18:01.240]  значит, суммарный размер этой штуки не больше, чем m.
[01:18:01.240 --> 01:18:06.240]  А потому что ребра из парасочетания справа налево всегда.
[01:18:06.240 --> 01:18:08.240]  Единственная шанса быть вот так вот,
[01:18:08.240 --> 01:18:14.240]  а таких ребер мы знаем, что нет.
[01:18:14.240 --> 01:18:18.240]  Еще раз.
[01:18:18.240 --> 01:18:20.240]  Смотрите, в этот момент у меня уже никаких чередований нет.
[01:18:20.240 --> 01:18:24.240]  Это просто тот граф, который получим после всех агментов.
[01:18:24.240 --> 01:18:26.240]  И там автоматически все ребра из парасочетания справа налево,
[01:18:26.240 --> 01:18:28.240]  все ребра не из парасочетания слева направо.
[01:18:28.240 --> 01:18:32.240]  Поэтому такое значит автоматически из парасочетания.
[01:18:32.240 --> 01:18:35.240]  Ну все, получается, что мы построили вершинное покрытие,
[01:18:35.240 --> 01:18:38.240]  размер которого не больше, чем m.
[01:18:38.240 --> 01:18:41.240]  С другой стороны, я утверждаю,
[01:18:41.240 --> 01:18:46.240]  что размер любого вершинного покрытия всегда больше и равен, чем m.
[01:18:46.240 --> 01:18:52.240]  Размер любого вершинного покрытия всегда больше и равен, чем m,
[01:18:52.240 --> 01:18:54.240]  потому что что такое m?
[01:18:54.240 --> 01:18:57.240]  Это несколько дизъюнктных ребер.
[01:18:57.240 --> 01:19:01.240]  Чтобы их покрыть, понятное дело, что мне, по факту,
[01:19:01.240 --> 01:19:04.240]  обязательно нужно выбрать хотя бы один из двух концов каждого ребра.
[01:19:04.240 --> 01:19:07.240]  Вершинное покрытие такое множество, что у каждого ребра
[01:19:07.240 --> 01:19:10.240]  хотя бы один из концов выбран.
[01:19:10.240 --> 01:19:12.240]  Я должен из этих двух концов выбрать хотя бы один, скажем вот это.
[01:19:12.240 --> 01:19:15.240]  Из этих двух хотя бы один, из этих двух хотя бы один,
[01:19:15.240 --> 01:19:17.240]  из этих двух хотя бы один.
[01:19:17.240 --> 01:19:19.240]  Как ни старайся, чтобы покрыть все ребра парасоча,
[01:19:19.240 --> 01:19:23.240]  нужно выбрать вершин хотя бы столько, сколько в нем ребер.
[01:19:23.240 --> 01:19:25.240]  Ну а здесь нераняс Angels в обратную сторону,
[01:19:25.240 --> 01:19:32.240]  Значит, автоматически получу, что r±l± — это в точности m.
[01:19:32.240 --> 01:19:36.240]  И это минимально возможное вершинное покрытие,
[01:19:36.240 --> 01:19:40.240]  потому что любое покрытие имеет размер хотя бы m.
[01:19:40.240 --> 01:19:43.240]  А мы получили равно m.
[01:19:43.240 --> 01:19:46.240]  Мы получили равенство и доказали теорему,
[01:19:46.240 --> 01:19:50.240]  что существует вершинное покрытие размера, равное m,
[01:19:50.240 --> 01:19:53.240]  и оно минимальное, потому что любое вершинное покрытие
[01:19:53.240 --> 01:19:57.240]  имеет размер хотя бы m, а это минимально.
[01:19:57.240 --> 01:19:59.240]  То есть получается, что если мы нашли максимальное
[01:19:59.240 --> 01:20:01.240]  просчитание в этом графе,
[01:20:01.240 --> 01:20:04.240]  то дальше дело техники, нужно просто все ребра ориентировать,
[01:20:04.240 --> 01:20:06.240]  правильным образом запустить DFS,
[01:20:06.240 --> 01:20:08.240]  разбить все на четыре категории,
[01:20:08.240 --> 01:20:10.240]  и дальше объединение такое или такое —
[01:20:10.240 --> 01:20:13.240]  это будет, соответственно, вершинное покрытие минимальное
[01:20:13.240 --> 01:20:16.240]  или максимальное здесь множество.
[01:20:16.240 --> 01:20:18.240]  Все, спасибо.
