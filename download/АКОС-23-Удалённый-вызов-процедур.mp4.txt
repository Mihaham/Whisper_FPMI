[00:00.000 --> 00:15.000]  Тема сегодняшнего занятия это межпроцессное взаимодействие, а именно удаленный вызов процедур.
[00:15.000 --> 00:24.000]  Вы уже изучили много всего хорошего и интересного, то как все устроено, уровни.
[00:24.000 --> 00:31.000]  И в частности была такая замечательная штука под названием сокеты.
[00:31.000 --> 00:41.000]  Итак, сокеты. Напомню, что это такое. Это некоторые файловые дискрипторы, которые вы можете одновременно и читать, и писать.
[00:41.000 --> 00:48.000]  То есть они двусторонние. И в отличие от всяких других примитивов, таких как каналы, еще что-нибудь.
[00:48.000 --> 00:58.000]  Особенность сокетов в том, что это механизм межпроцессного взаимодействия, где явным образом выделяется некоторый сервер.
[00:58.000 --> 01:06.000]  То есть процесс, который анонсирует себя по какому-то имени, и отдельно выделяется клиент.
[01:06.000 --> 01:18.000]  Соответственно, возможность взаимодействия либо через некоторые локальные файлы, которые имеют специальный тип, либо по сети.
[01:18.000 --> 01:25.000]  То есть именем является пара значений имя хаста, либо IP-адрес, плюс номер порта.
[01:25.000 --> 01:35.000]  И такой механизм очень удобно использовать в качестве механизма межпроцессного взаимодействия, хотя здесь не решаются некоторые проблемы.
[01:35.000 --> 01:48.000]  Например, как можно найти какой-то другой процесс. То есть нужно иметь очень строгую договоренность о том, как называются какие-то локальные файлы в UNIX-системе.
[01:48.000 --> 01:57.000]  Либо иметь строго определенное назначение каких-то портов на определенном хасте.
[01:57.000 --> 02:11.000]  И для межпроцессного взаимодействия удобно иметь некоторую общую шину, куда сваливаются все имена подключенных сервисов, и точно также к этим сервисам подключаться.
[02:11.000 --> 02:21.000]  Одним из таких механизмов является сервис под названием DBAS, который является стандартом для open-source UNIX-систем.
[02:22.000 --> 02:28.000]  Но на самом деле не только open-source. В Mac тоже есть система DBAS, которая ставится через бью.
[02:28.000 --> 02:35.000]  Что это такое? Это механизм межпроцессного взаимодействия, который ориентирован на обмен сообщений.
[02:35.000 --> 02:44.000]  И может быть использован для того, чтобы организовать межпроцессные взаимодействия и удаленный вызов в процеду.
[02:44.000 --> 02:52.000]  Что под называется высокоуровневое взаимодействие? Это означает, что вы регистрируете какие-то сервисы.
[02:52.000 --> 02:58.000]  У этих сервисов есть какие-то осмысленные имена, и эти сервисы реализуют определенные интерфейсы.
[02:58.000 --> 03:08.000]  Что означает определенные интерфейсы? Это значит, что строго гарантируется какая-то сигнатура методов и возвращаемое значение.
[03:08.000 --> 03:19.000]  Причем сервисы работают осинхронным образом. С сервисами могут быть произвольные приложения, которые делают еще что-нибудь,
[03:19.000 --> 03:24.000]  помимо своей основной деятельности, того что они являются DBAS-сервисами.
[03:24.000 --> 03:34.000]  И просто они периодически получают какие-то события, и можно программным образом управлять.
[03:34.000 --> 03:50.000]  Существует два двумя шины для DBAS. Посмотрим, как это делается под Linux. Как посмотреть список всех процессов?
[03:54.000 --> 03:59.000]  Кто помнит название команды? Посмотреть список всех процессов.
[04:00.000 --> 04:07.000]  PS3 – это один из вариантов. Вариант PS.
[04:07.000 --> 04:18.000]  И есть еще, если у вас есть какие-то системные сервисы. Другая удобная команда – это SystemD. Что-нибудь видно на экране, шифт не мелкий.
[04:18.000 --> 04:38.000]  SystemD через Defiz CG-LS. Что-то очень похожее на PS3, но дополнительно еще отображается, какие процессы относятся к каким системным сервисам,
[04:38.000 --> 04:44.000]  которые в свою очередь объединяются в некоторые группы, скопы. Все это делится на слайсы.
[04:44.000 --> 04:57.000]  Что такое контрольные группы? Помните Cgroups? Конец прошлого семестра. Управление ресурсами. Если не помните, посмотрите лекции прошлого семестра.
[04:57.000 --> 05:16.000]  Дополнительная группировка по группам. Можно найти в запущенной системе с графическим интерфейсом. Я не зря сегодня запустил, хотя обычно это не делаю, полноценное десктопное окружение.
[05:16.000 --> 05:34.000]  Можно найти минимум два экземпляра сервиса D-Bus. Один находится в User Service, запущен из-под обычного пользователя. Называется D-Bus Demon. Это так называемая сессионная шина.
[05:34.000 --> 05:53.000]  И еще один экземпляр, который запущен через SystemD с правами Root. Где-то тут можно найти еще один D-Bus Service, который является системной шиной.
[05:53.000 --> 06:17.000]  Для чего это все нужно и как это можно использовать на практике? В чем заключается общая идея межпроцессного взаимодействия через D-Bus? У вас есть одна или несколько шин. У вас есть определенное количество сервисов, которые могут реализовать определенные интерфейсы и какое-то количество клиентов.
[06:17.000 --> 06:30.000]  Когда вы запускаете процесс, который является сервисом? Он подключается к одной из шин, регистрирует свое название, свои интерфейсы, свою инвентарию методов поддерживаемых.
[06:30.000 --> 06:49.000]  И в качестве побочного эффекта может выполнять определенные действия, свои основные значения, и при этом дополнительно прослушивает все входящие события, которые возникают на этой шине, адресованные определенному сервису.
[06:49.000 --> 07:06.000]  При этом сами сервисы не являются серверами. Они не прослушивают никакие порты, никакие сокеты. Они сами являются клиентами с точки зрения UNIX-системы. Как это реализуется на высоком уровне?
[07:06.000 --> 07:25.000]  Название D-Bas это сокращение от Desktop-Bas. Основное назначение это все-таки десктопные системы. Если вы запускаете какое-то графическое приложение, то оно подключается как минимум еще к одному сокету.
[07:25.000 --> 07:45.000]  Это сокет X-сервера, откуда приложение читает события вот с клавиатуры, события окон системы, то есть там resize окон и так далее. И сами по себе отправляют в эти сокеты запросы на адресовку чего-либо.
[07:45.000 --> 08:11.000]  И организуется некоторая единая очередь обработки событий, которая в том числе прослушивает сокет, связанный с D-Bas, и может выполнять какие-то определенные действия. На низком уровне это может быть реализовано с помощью библиотеки X, но на практике ни того не делает. Обычно используют более высокого уровня библиотеки, либо QT, либо GTK, совместно с библиотекой Gallip.
[08:12.000 --> 08:21.000]  Итак, пример межпроцессного взаимодействия, который взят из библиотеки QT.
[08:21.000 --> 08:50.000]  Некоторый пример, который написан не мной, а найден совместно в библиотеке, это вот такая машинка. Машинка – это отдельное приложение, отдельный процесс, что оно умеет делать.
[08:51.000 --> 08:59.000]  Оно умеет ускоряться, затормаживать, ехать в обратную сторону, поворачивать налево, поворачивать направо. Это один процесс.
[08:59.000 --> 09:24.000]  Отдельно можно запустить еще один процесс, который реализует контрольную панель с кнопочками. Это отдельное приложение. Обратите внимание, что я запустил два этих программы, не указывая никаких параметров подключения.
[09:29.000 --> 09:39.000]  Поехала. Никакого практического смысла в этой программе нет. Это просто стандартный экзампл из поставки библиотеки QT.
[09:39.000 --> 09:51.000]  Более интересно посмотреть на реализацию всего этого безобразия.
[09:51.000 --> 10:00.000]  Реализация. На самом деле тут не обязательно знать все подробности, как это устроено на низком уровне.
[10:00.000 --> 10:15.000]  Самое интересное здесь в том, что реализация заключается в вызове всего лишь трех вещей.
[10:15.000 --> 10:34.000]  После того, как создана машинка, нужно открыть системную шину, зарегистрировать некоторый объект и зарегистрировать сервис. Все остальное делается в графической библиотеке.
[10:34.000 --> 10:44.000]  Что здесь регистрируется? Нас регистрируется некоторый сервис, в котором может быть несколько объектов.
[10:44.000 --> 10:55.000]  В данном случае он называется объект slashcar, хотя любое приложение может создавать много разных экзампляров с разными именами.
[10:55.000 --> 11:03.000]  Как теперь можно управлять этой машинкой, не пользуясь кнопочками? Машинка у меня есть, она осталась в каком-то состоянии.
[11:03.000 --> 11:09.000]  Машинка это просто модель какой-то реальной программы, с которой вы можете взаимодействовать.
[11:09.000 --> 11:37.000]  У каждой машинки может быть свое имя, если вы запускаете с одним фиксированным именем, но просто у вас не получится этот объект зарегистрировать.
[11:37.000 --> 12:00.000]  Теперь я запущу вот такую штуку и сделаю управлять этой машинкой каким-то программным образом, как будто мы управляем реальным приложением.
[12:00.000 --> 12:10.000]  Для этого можно использовать модуль D-Bus.
[12:10.000 --> 12:24.000]  Импортируем сессионную шину, подключаемся к шине. Что такое шина? Это как раз один экземпляр, который запущен вместе с сеансом рабочего стола.
[12:24.000 --> 12:43.000]  Затем, зная название сервиса и конкретного экземпляра, мы можем найти какой-то объект по его имени.
[12:43.000 --> 12:52.000]  Вот название сервиса и конкретный экземпляр. В данном случае он всего один, хотя может быть несколько.
[12:52.000 --> 13:02.000]  Это некоторая машинка, какой-то объект, который в свою очередь реализует некоторые методы.
[13:02.000 --> 13:17.000]  Можно получить полный список любого D-Bus интерфейса в виде XML строки. Как же ужасно все-таки пользоваться нестандартными экранами.
[13:17.000 --> 13:32.000]  Это обычная XML. У машинки есть некоторые экспортированные методы. Могут быть разные интерфейсы. В частности, Accelerate, Dexlerate, Left, Turn Right.
[13:32.000 --> 13:47.000]  Давайте теперь вызовем.
[13:47.000 --> 13:59.000]  Для этого у каждой машинки должно быть свое уникальное имя. Есть некоторый сервис, который называется OrgExampleCarExample.
[13:59.000 --> 14:09.000]  Этот сервис может регистрировать несколько разных имен. Точно так же, как разные объекты в URL кодируются в браузере.
[14:09.000 --> 14:15.000]  Разные имена соответствуют разным экземплярам. В ней могут иметь какие-то числовые параметры и так далее.
[14:15.000 --> 14:23.000]  В частности, это используется, например, порядковыми номерами сетевых интерфейсов Network Manager.
[14:23.000 --> 14:44.000]  Возвращаясь к машинке, мы заставили машинку двигаться в обратную сторону. При этом никто не мешает запустить контроллер, который тоже будет отправлять какие-то команды.
[14:44.000 --> 14:50.000]  В данном случае у нас есть один процесс, к нему могут подключаться другие процессы и как-то им управлять.
[14:50.000 --> 15:03.000]  Какой в этом практически смысл? Машинка это всего лишь модель. В реальной жизни, естественно, вы будете пользоваться чем-то другим взаимодействием не с какими-то машинками.
[15:03.000 --> 15:12.000]  Здесь выделяются разные уровни. Во-первых, это то, чем может управлять обычный пользователь, не обладая правами администратора.
[15:12.000 --> 15:21.000]  Любовь взаимодействия с рабочим столом. Какое может вам потребоваться взаимодействие? Например, вывести какой-нибудь notification в иконке.
[15:21.000 --> 15:37.000]  Может быть взаимодействие с иконной системой, если у вас окружение рабочего стола это позволяет заставить какое-то окошко показаться на самом верху, либо наоборот, скрыться.
[15:37.000 --> 15:48.000]  Какие-то общие парольные менеджеры или, возможно, доступ к контактным данным. В линуксе это, конечно, не очень распространено.
[15:48.000 --> 16:03.000]  Есть две независимые системы. Одна называется Evolution Server, другая Канадия. Одна из них это в составе GNOME, другая в составе KDE, которые позволяют обращаться к вашим почтовым ящикам, контактам, календарям.
[16:03.000 --> 16:14.000]  Почему в линукс дектопных это не очень распространено? Потому что изначально технологии они были в первую очередь не оритированы на мобильные устройства еще до Android.
[16:14.000 --> 16:22.000]  Ну и кроме того, с чем может взаимодействовать пользователь с сессионной шиной, есть еще и системная шина.
[16:22.000 --> 16:33.000]  И можно дергать разные события и обращаться к сервисам, например, для того, чтобы узнать состояние батареи, насколько она у вас заряжена, для чего это может понадобиться на практике.
[16:33.000 --> 16:47.000]  Например, приложение Adject Brains. У них есть Power Safe Mode, когда отключаются всякоиндексации. Как может приложение понять, что нужно принудительно переключиться в Power Safe Mode?
[16:47.000 --> 17:06.000]  Кстати, у Яндекс браузера тоже есть. Можно просто обратиться через dbus к системной службе мониторинга батареи и запросить, сколько у нас осталось времени на работу, либо оценить самостоятельно и принять какое-то решение.
[17:06.000 --> 17:19.000]  Ну и кроме того, управление сетью. Что делает вот эта кнопочка сетью? У меня вай-фай настоящих нет, поскольку это виртуальная машина.
[17:19.000 --> 17:28.000]  На самом деле, вот этот апплет – это просто маленькое графическое приложение, которое взаимодействует через интерфейс dbus с системным менеджером управления сетью.
[17:28.000 --> 17:39.000]  То же самое управление звуком, подключение новых устройств. Некоторые такие действия могут потребовать уже права администратора.
[17:39.000 --> 17:57.000]  Так, ну практически пример, когда это может быть полезно. Шина у меня уже подключена. Есть разные сторонние приложения, которые позволяют... Так, все, машинка мне не интересна, я ее закрываю, потому что мы сейчас другим развлекаться будем.
[17:57.000 --> 18:21.000]  Так, есть разные инструменты, которые позволяют исследовать, что у вас вообще есть в шине dbus. Это либо qdbus-viewer для среды KDE, либо в гноме есть еще инструмент по названиям dfeed.
[18:21.000 --> 18:26.000]  Вот так пишется d-feed. Делает примерно то же самое.
[18:26.000 --> 18:41.000]  В плане поразвлекаться, самый наглядный пример – это Notification Area, которая доступна по сервису org-free-desktop-notifications.
[18:41.000 --> 18:55.000]  Так, сервис называется org-free-desktop-notifications. Вот у меня уже открыт спитон. Шина у меня уже есть, пересоздавать ее нет никакого смысла.
[18:55.000 --> 19:10.000]  Давайте подключимся к desktop.notifications.
[19:10.000 --> 19:28.000]  И там есть объект, который существует ровно в одном экземпляре. Как правило, в опенсорсных средах для объектов, которые существуют ровно в одном экземпляре, название экземпляра примерно совпадает с названием самого сервиса.
[19:28.000 --> 19:47.000]  Так, есть какой-то сервис. Давайте посмотрим, какие есть у сервиса возможности.
[19:47.000 --> 19:57.900]  И кто этот сервис вообще реализует. У нас есть некоторые стандартные интерфейсы. В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализации
[19:57.900 --> 20:07.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:07.900 --> 20:17.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:17.900 --> 20:19.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:19.900 --> 20:21.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:21.900 --> 20:23.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:23.900 --> 20:25.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:25.900 --> 20:27.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:27.900 --> 20:29.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:29.900 --> 20:31.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:31.900 --> 20:33.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:33.900 --> 20:35.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:35.900 --> 20:37.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:37.900 --> 20:39.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:39.900 --> 20:41.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:41.900 --> 20:43.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:43.900 --> 20:45.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:45.900 --> 20:47.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:47.900 --> 20:49.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:49.900 --> 20:51.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:51.900 --> 20:53.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:53.900 --> 20:55.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:55.900 --> 20:57.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:57.900 --> 20:59.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[20:59.900 --> 21:01.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:01.900 --> 21:03.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:03.900 --> 21:05.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:05.900 --> 21:07.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:07.900 --> 21:09.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:09.900 --> 21:11.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:11.900 --> 21:13.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:13.900 --> 21:15.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:15.900 --> 21:17.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:17.900 --> 21:19.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:19.900 --> 21:21.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:21.900 --> 21:23.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:23.900 --> 21:25.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:25.900 --> 21:27.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:27.900 --> 21:29.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:29.900 --> 21:31.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:31.900 --> 21:33.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:33.900 --> 21:35.900]  В частности, интерфейс, который предназначен для реализации всплывающих уведомлений и реализовать интерфейс могут разные сервисы, в зависимости от того, какой тип у вас рабочего стола.
[21:35.900 --> 21:39.900]  Давайте выведем какое-нибудь уведомление, что нам для этого нужно.
[21:39.900 --> 21:41.900]  Давайте выведем какое-нибудь уведомление, что нам для этого нужно.
[21:41.900 --> 21:43.900]  Давайте выведем какое-нибудь уведомление, что нам для этого нужно.
[21:43.900 --> 21:45.900]  Первый параметр называется Notify.
[21:45.900 --> 21:47.900]  Первый параметр называется Notify.
[21:47.900 --> 21:49.900]  Первый параметр называется Notify.
[21:49.900 --> 21:51.900]  Первый параметр называется Notify.
[21:51.900 --> 21:53.900]  Первый параметр называется Notify.
[21:53.900 --> 21:55.900]  Первый параметр называется Notify.
[21:55.900 --> 21:57.900]  Первый параметр называется Notify.
[21:57.900 --> 21:59.900]  Первый параметр называется Notify.
[21:59.900 --> 22:01.900]  Первый параметр называется Notify.
[22:01.900 --> 22:03.900]  Первый параметр называется Notify.
[22:03.900 --> 22:05.900]  Первый параметр называется Notify.
[22:05.900 --> 22:07.900]  Первый параметр называется Notify.
[22:07.900 --> 22:09.900]  Первый параметр называется Notify.
[22:09.900 --> 22:11.900]  Если у нас было какое-то уже существующее открытое уведомление, то не может быть ID.
[22:11.900 --> 22:13.900]  Если у нас было какое-то уже существующее открытое уведомление, то не может быть ID.
[22:13.900 --> 22:15.900]  Если у нас было какое-то уже существующее открытое уведомление, то не может быть ID.
[22:15.900 --> 22:17.900]  Если у нас было какое-то уже существующее открытое уведомление, то не может быть ID.
[22:17.900 --> 22:19.900]  Иконка, которая будет отображена.
[22:19.900 --> 22:21.900]  Иконка, которая будет отображена.
[22:21.900 --> 22:23.900]  Иконка, которая будет отображена.
[22:23.900 --> 22:25.900]  Иконка, которая будет отображена.
[22:25.900 --> 22:27.900]  Иконка, которая будет отображена.
[22:27.900 --> 22:29.900]  Иконка, которая будет отображена.
[22:29.900 --> 22:31.900]  Иконка, которая будет отображена.
[22:31.900 --> 22:33.900]  Иконка, которая будет отображена.
[22:33.900 --> 22:35.900]  Иконка, которая будет отображена.
[22:35.900 --> 22:37.900]  ЦСД Color. Красивая иконка.
[22:39.900 --> 22:41.900]  ЦСД Color.
[22:41.900 --> 22:43.900]  ЦСД Color.
[22:43.900 --> 22:45.900]  ЦСД Color.
[22:45.900 --> 22:47.900]  Самый короткий текст.
[22:47.900 --> 22:49.900]  Самый короткий текст.
[22:57.900 --> 22:59.900]  Что там еще по интерфейсу нужно?
[22:59.900 --> 23:01.900]  Что там еще по интерфейсу нужно?
[23:01.900 --> 23:03.900]  Массив строк. Какие-то действия.
[23:03.900 --> 23:05.900]  медка.
[23:05.900 --> 23:07.900]  медка.
[23:07.900 --> 23:09.900]  медка.
[23:09.900 --> 23:11.900]  Медка.
[23:11.900 --> 23:13.900]  Медка.
[23:13.900 --> 23:19.900]  Медка, over pretty software,
[23:19.900 --> 23:21.900]  Медка, over pretty software,
[23:21.900 --> 23:23.900]  Медка.
[23:23.900 --> 23:25.900]  Медка, over pretty software,
[23:25.900 --> 23:27.900]  Медка, over pretty software,
[23:27.900 --> 23:29.900]  Медка, over pretty software,
[23:29.900 --> 23:31.900]  Медка, over pretty software,
[23:31.900 --> 23:37.900]  Теперь про системные шины. Что можно вытворять?
[23:37.900 --> 23:47.900]  Яркость экрана, кстати, да, можно, если у вас система поддерживает настройку яркости экрана.
[23:47.900 --> 23:55.900]  Они плохо портируются, поэтому в основном это сделано под...
[23:55.900 --> 23:59.900]  На самом деле, в чем смысл этой штуки?
[23:59.900 --> 24:06.900]  Если, например, у вас есть система не Linux, а FreeBSD или OpenBSD, то есть не на базе ядра Linux,
[24:06.900 --> 24:10.900]  у вас может быть реализовано какое-то другое взаимодействие с железом.
[24:10.900 --> 24:17.900]  Но при этом вы хотите использовать возможности тех же рабочих столов, что и Linux, те же KDE, те же GNOME.
[24:17.900 --> 24:22.900]  То есть вам нужно написать под FreeBSD сервис, который будет реализовывать тот же самый интерфейс.
[24:22.900 --> 24:29.900]  Этот сервис, соответственно, запускается и точно так же прослушивает события.
[24:29.900 --> 24:35.900]  И с точки зрения рабочего стола нет никакого различия, на какой системе вы работаете.
[24:39.900 --> 24:46.900]  XOR и Wayland да, но они отвечают только за взаимодействие с клавиатурой, мышью и экраном. Все.
[24:46.900 --> 24:50.900]  Все остальное это уже за пределами возможности XOR и Wayland.
[24:50.900 --> 24:55.900]  Так, ну вот, например, системный сервис, org-free-desktop-accounts.
[24:55.900 --> 25:00.900]  Для того, чтобы к нему подключиться мне уже нужна другая шина.
[25:00.900 --> 25:03.900]  Так, я, наверное, даже не импортировал.
[25:03.900 --> 25:08.900]  Пайди-бас, импорт, который называется System-Bas.
[25:13.900 --> 25:15.900]  Пересоздам эту шину.
[25:17.900 --> 25:19.900]  И найду объект.
[25:21.900 --> 25:25.900]  Который отвечает, например, за управление аккаунтами пользователей.
[25:25.900 --> 25:32.900]  Так, org-free-desktop-accounts.
[25:34.900 --> 25:39.900]  И можно застучаться до определенного аккаунта определенного пользователя,
[25:39.900 --> 25:42.900]  либо сделать какие-то общесистемные действия.
[25:42.900 --> 25:46.900]  Например, может попытаться сделать нового пользователя.
[25:46.900 --> 25:51.900]  Обратите внимание, что я все это запускаю из-под обычного пользователя, не из-под рута.
[25:51.900 --> 26:00.900]  Так, org-free-desktop-accounts.
[26:01.900 --> 26:04.900]  Так, вот у нас какой-то есть сервис.
[26:10.900 --> 26:15.900]  Потому что я просто подключаюсь к какой-то шине, просто нахожу какой-то объект.
[26:15.900 --> 26:20.900]  Пока нам никто не мешает.
[26:20.900 --> 26:22.900]  И что я теперь, например, хочу сделать?
[26:22.900 --> 26:25.900]  Например, я хочу сделать нового пользователя.
[26:27.900 --> 26:30.900]  Так, что нам нужно для создания нового пользователя?
[26:32.900 --> 26:40.900]  Для создания нового пользователя мне нужно указать его имя, полное имя и тип аккаунта,
[26:40.900 --> 26:45.900]  просто болевый флаг, один либо ноль, админ либо не админ.
[26:45.900 --> 26:57.900]  Так, ну ладно, пусть будет пользователь Вован, которого зовут Вова Пу, например, китаец.
[27:01.900 --> 27:03.900]  Может быть.
[27:04.900 --> 27:10.900]  Так, обратите внимание, что пользователя у меня только один сейчас в системе, все честно.
[27:10.900 --> 27:13.900]  Ну и пусть он не будет с админом.
[27:13.900 --> 27:19.900]  Понятно, что создание нового пользователя это какая-то операция, которая требует администраторских прав.
[27:19.900 --> 27:23.900]  Я это запускаю из-под обычного пользователя.
[27:23.900 --> 27:32.900]  Бабах. Ну теперь у нас откуда-то выскакивает окошко, которое требует вести пароль администратора.
[27:32.900 --> 27:34.900]  Кто создает это окошко?
[27:35.900 --> 27:41.900]  Тот сервис, который запущен с правами рута и отвечает за управление аккаунтом.
[27:41.900 --> 27:49.900]  То есть это на самом деле не тот самый процесс, в котором запущен питом из-под обычного пользователя.
[27:49.900 --> 27:57.900]  Ну теперь я могу вести пароль, если он честный, то, видимо, будет создан какой-то аккаунт,
[27:57.900 --> 28:00.900]  действительно появился новый каталог пользователя.
[28:03.900 --> 28:09.900]  У него есть некоторый новый user ID, то есть прямо честная операция в создании нового пользователя.
[28:09.900 --> 28:11.900]  То же самое можно сделать и с удалением поиска.
[28:13.900 --> 28:23.900]  Так, ну это все, что относится к сервису под названием debas, который ориентирует в первую очередь на десктопное применение.
[28:23.900 --> 28:30.900]  На самом деле все, что здесь я вам показал, это может быть исполнено не только на десктопах, но и на серверах,
[28:30.900 --> 28:37.900]  которые без графического интерфейса. Все, что здесь нужно сделать, это просто реализовать подключение к шине
[28:37.900 --> 28:41.900]  и прослушивать периодически какие-то события, на них реагируют.
[28:41.900 --> 28:47.900]  При этом все сервисы debas, поскольку они исходно ориентированы на локальное применение,
[28:47.900 --> 28:52.900]  работают поверх локальных Unix Sockets. Штуковые локальные Unix Sockets, помните?
[28:52.900 --> 28:58.900]  Это файлы специального типа, которые адрес вами Unix.
[28:58.900 --> 29:04.900]  Кстати, что еще отличает их от обычных файлов? Максимальная длина пути.
[29:04.900 --> 29:12.900]  То есть для обычных файлов это 4096 байт, для Unix Sockets это всего лишь 108 байт.
[29:12.900 --> 29:19.900]  Так, ну и главный недостаток локальных Unix Sockets, то, что недоступлено вам только локально.
[29:19.900 --> 29:24.900]  При этом на самом деле вы можете файловые системы монтировать дистанционно,
[29:24.900 --> 29:29.900]  используя SSHFS, Network File System и так далее.
[29:29.900 --> 29:34.900]  Но локальные Unix Sockets, даже будучи подмонтированными удаленно,
[29:34.900 --> 29:39.900]  удаленные файловые системы все равно не доступны для взаимодействия.
[29:39.900 --> 29:45.900]  Поэтому здесь, если вы хотите использовать удаленный вызов-процедур,
[29:45.900 --> 29:50.900]  с какими-то параметрами получать результаты от соседнего компьютера,
[29:50.900 --> 29:54.900]  либо какой-то произвольного компьютера, локальные Sockets вам не подойдут.
[29:54.900 --> 29:59.900]  Нужно использовать Address Family Internet, либо Address Family Internet 6.
[29:59.900 --> 30:09.900]  Так, ну и на самом деле идея не новая. Существовала еще в 90-е годы, существует до сих пор.
[30:09.900 --> 30:17.900]  Общая идея. У нас есть какой-то интерфейс, есть класс, который реализует этот интерфейс,
[30:17.900 --> 30:22.900]  класс-клиент и класс, который реализует тот же самый интерфейс, класс-сервер.
[30:22.900 --> 30:28.900]  Как это выглядит в реальной жизни? Сейчас будет много всякого кода.
[30:28.900 --> 30:35.900]  На самом деле, вникать во все подробности кода, запоминать что-то не особо обязательно,
[30:35.900 --> 30:42.900]  потому что я это все выложу на GitHub. Весь код, конечно, на экране показать невозможно.
[30:42.900 --> 30:47.900]  Итак, есть некоторый интерфейс. Не пугайтесь, что я вам показываю
[30:47.900 --> 30:52.900]  какой-то мало знакомый язык программирования Java, он похож на C++.
[30:52.900 --> 30:55.900]  На самом деле, сегодня я буду показывать на разных языках программирование код,
[30:55.900 --> 31:01.900]  который вполне себе читабельный. Что означает слово Public Interface?
[31:01.900 --> 31:08.900]  Это означает, переводя на язык C++, просто полностью абстрактный класс,
[31:08.900 --> 31:12.900]  который подразумевает, что должен быть реализован
[31:12.900 --> 31:16.900]  некоторый метод, под названием GetMessage, который возвращает строку.
[31:16.900 --> 31:23.900]  Этот интерфейс реализован каким-то конкретным классом,
[31:23.900 --> 31:29.900]  который можно запустить в отдельном процессе.
[31:29.900 --> 31:41.900]  И есть еще один процесс, который хочет использовать данный интерфейс,
[31:41.900 --> 31:45.900]  но при этом подключиться к какому-то сервису.
[31:45.900 --> 31:51.900]  Сервис, в свою очередь, работает на обычном IP-порту,
[31:51.900 --> 31:57.900]  по умолчанию порт 1.0.99 можно задать какое-то имя сервиса,
[31:57.900 --> 32:01.900]  потом в клиенте это имя сервиса найти, для того чтобы потом
[32:01.900 --> 32:05.900]  вызвать какой-то произвольный метод, получить его результат.
[32:05.900 --> 32:10.900]  Запустили отдельно сервер, отдельно запускаем клиент,
[32:10.900 --> 32:13.900]  который запускается, получается строчку Hello.
[32:13.900 --> 32:15.900]  Что у нас при этом происходит в сети?
[32:15.900 --> 32:19.900]  Для этого у нас есть Wireshark, ознакомим вам уже.
[32:19.900 --> 32:23.900]  Давайте посмотрим, что у нас тут будет происходить.
[32:23.900 --> 32:26.900]  Подключаемся к Localhost.
[32:26.900 --> 32:34.900]  Стандартный порт данном случае это 1.0.99.
[32:34.900 --> 32:38.900]  Запускаем клиента еще раз.
[32:38.900 --> 32:41.900]  Смотрим, что у нас тут поймалось.
[32:41.900 --> 32:44.900]  Поймалось много всего интересного.
[32:44.900 --> 32:51.900]  В частности, где-то у нас тут есть, среди TCP безобразия,
[32:51.900 --> 32:57.900]  запрос на Java RMI, вот у нас ReturnData,
[32:57.900 --> 33:03.900]  и здесь что-то связанное с сервизацией Java,
[33:03.900 --> 33:07.900]  определенной версии в незашифрованном виде.
[33:07.900 --> 33:12.900]  Можно перехватить трафик и узнать, кто у кого что вызывает.
[33:12.900 --> 33:16.900]  И это является одним из главных недостатков
[33:16.900 --> 33:21.900]  Java Remote Invocation.
[33:21.900 --> 33:24.900]  Поэтому в реальной жизни сейчас им никто не пользуется.
[33:24.900 --> 33:27.900]  Но сама идея достаточно красивая.
[33:27.900 --> 33:31.900]  Когда вы один и тот же интерфейс реализуете и на сервере,
[33:31.900 --> 33:34.900]  и подразумеваете, используя на клиенте,
[33:34.900 --> 33:42.900]  и объект у вас создается, просто подключившись к какой-то шине.
[33:42.900 --> 33:47.900]  Главный недостаток все-таки помимо того, что отсутствует шифрование.
[33:47.900 --> 33:51.900]  Шифрование – это ладно. Вы можете сделать отдельную подсеть
[33:51.900 --> 33:54.900]  только для доверенных серверов,
[33:54.900 --> 34:00.900]  разбить огромный сервис на микросервисы в локальной защищенной сети.
[34:00.900 --> 34:06.900]  Это еще полбеды. Другое важное ограничение – это Java.
[34:06.900 --> 34:09.900]  Чем плоха Java?
[34:09.900 --> 34:12.900]  На самом деле хороший язык программирования.
[34:12.900 --> 34:16.900]  Но, кроме Java, существует много других языков программирования.
[34:16.900 --> 34:20.900]  Да, имею в виду семейства языков Java.
[34:20.900 --> 34:23.900]  Это Kotlin, Java, Scala.
[34:23.900 --> 34:29.900]  Но все, это то, чем ограничено использование этого способа.
[34:29.900 --> 34:34.900]  Поэтому не очень хорошо и распространение не получил.
[34:34.900 --> 34:40.900]  Чуть более универсальным, но уже историческим способом
[34:40.900 --> 34:44.900]  является использование формата XML и обычного HTTP-сервера.
[34:44.900 --> 34:47.900]  В чем заключается этот подход?
[34:47.900 --> 34:51.900]  Вы понимаете обычный Web-сервер.
[34:51.900 --> 34:53.900]  В чем преимущество Web-сервера?
[34:53.900 --> 34:57.900]  Вы можете его запустить на любом произвольном порту.
[34:57.900 --> 35:00.900]  Он легко проксируется чем угодно.
[35:00.900 --> 35:06.900]  Есть средства для безопасности в виде отдельного слоя Secure Second Player.
[35:06.900 --> 35:11.900]  И отправлять туда запросы в формате XML.
[35:11.900 --> 35:14.900]  Что такое язык XML? Я думаю, пояснять не нужно.
[35:14.900 --> 35:16.900]  HTML вы все знаете.
[35:16.900 --> 35:24.900]  XML – это более строгая форма того, что вы привыкли назвать HTML.
[35:24.900 --> 35:29.900]  Отправляете какие-то структурированные запросы,
[35:29.900 --> 35:34.900]  которые содержат аргументы вызываемых методов и получаете ответ.
[35:34.900 --> 35:38.900]  Этот способ был популярен в конце 90-х, начале нулевых.
[35:38.900 --> 35:42.900]  Сейчас не используется по одной простой причине.
[35:42.900 --> 35:45.900]  Формат XML очень многословный.
[35:45.900 --> 35:49.900]  Получается очень дикий безумный оверхед.
[35:49.900 --> 35:54.900]  Сейчас в основном используется другой подход под названием REST.
[35:54.900 --> 35:58.900]  Тоже поверх протокола HTTP.
[35:58.900 --> 36:03.900]  Но используя различные команды этого протокола.
[36:03.900 --> 36:07.900]  Команды GET и POST вы уже смотрели на семинарах.
[36:07.900 --> 36:10.900]  Даже задачки делали. Как, кстати, успешно?
[36:10.900 --> 36:13.900]  Даже успешно.
[36:13.900 --> 36:16.900]  Да, там все сейчас работает.
[36:16.900 --> 36:18.900]  Кроме команд GET и POST,
[36:18.900 --> 36:21.900]  команды могут быть совершенно произвольные текстовыми.
[36:21.900 --> 36:23.900]  Этому будут любые литералы.
[36:23.900 --> 36:27.900]  Есть часть команд, определенные разными стандартами.
[36:27.900 --> 36:30.900]  Например, команды PUT, DELETE, HEAD.
[36:30.900 --> 36:33.900]  Но в общем случае, поскольку протокол является текстовым,
[36:33.900 --> 36:38.900]  вы можете задавать произвольные команды вплоть до названия методов.
[36:38.900 --> 36:43.900]  Хотя на самом деле название методов в REST обычно кодируется как часть пути.
[36:43.900 --> 36:52.900]  В том числе не только методы, но и какие-то конкретные объекты.
[36:52.900 --> 37:01.900]  В заголовках можно указывать в запросе в заголовках accept,
[37:01.900 --> 37:04.900]  что вы готовы данные какого формата получать.
[37:04.900 --> 37:07.900]  Сервер в свою очередь может по своему усмотрению
[37:07.900 --> 37:13.900]  либо реализовывать достаточно широкий спектр форматов.
[37:13.900 --> 37:18.900]  Это может быть либо JSON, либо XML, либо plain text, либо бинарные данные.
[37:19.900 --> 37:23.900]  Как правило используется только JSON, хотя некоторые веб-фреймворки,
[37:23.900 --> 37:27.900]  например, есть такой N2O, который на Ирланге сделан,
[37:27.900 --> 37:31.900]  позволяет легко делать поддержку произвольных типов данных.
[37:31.900 --> 37:35.900]  И где это используется на практике?
[37:35.900 --> 37:37.900]  Возьмите хотя бы Яндекс.Погоду.
[37:37.900 --> 37:40.900]  Слово Яндекс.Погода вам, наверное, известно.
[37:40.900 --> 37:43.900]  Кроме Яндекс.Погоды есть еще другие сервисы,
[37:43.900 --> 37:45.900]  и с погодой связанные, и с финансами,
[37:45.900 --> 37:49.900]  которые предоставляют открытые программные интерфейсы.
[37:49.900 --> 37:53.900]  Открытые в том плане, что пользуется им может практически кто угодно,
[37:53.900 --> 37:56.900]  но для этого нужно получить некоторый ключ.
[37:56.900 --> 37:59.900]  Поэтому сейчас я вам показывать не буду,
[37:59.900 --> 38:01.900]  как это на практике делается.
[38:01.900 --> 38:04.900]  Просто пример из документации.
[38:04.900 --> 38:06.900]  Отправляйте некоторые запросы.
[38:06.900 --> 38:09.900]  Параметры запроса могут быть сформированы
[38:09.900 --> 38:11.900]  либо как аргументы GAT-запроса,
[38:11.900 --> 38:14.900]  либо являются частью заголовков.
[38:14.900 --> 38:18.900]  И получаете ответ в формате JSON,
[38:18.900 --> 38:20.900]  который дальше можете использовать.
[38:20.900 --> 38:23.900]  Вот такой простой удаленный вызов
[38:23.900 --> 38:26.900]  какого-то API на стороннем сервере.
[38:26.900 --> 38:29.900]  Преимущество такого подхода в том,
[38:29.900 --> 38:34.900]  что сам по себе протокол HTTP он очень простой.
[38:34.900 --> 38:38.900]  Он понимается любыми браузерами,
[38:38.900 --> 38:42.900]  поэтому можно сделать это не только в приложении,
[38:42.900 --> 38:45.900]  но и в стране JavaScript.
[38:45.900 --> 38:50.900]  Из недостатков здесь JSON по сравнению с XML
[38:50.900 --> 38:52.900]  все-таки более компактный формат.
[38:52.900 --> 38:56.900]  В то же время JSON это человекочитабельный формат.
[38:56.900 --> 38:58.900]  Он хорош для человека.
[38:58.900 --> 39:01.900]  Вы смотрите на вывод, вам все понятно как-то распарсить,
[39:01.900 --> 39:05.900]  но на парсинг все-таки требуется время, требуются ресурсы.
[39:05.900 --> 39:08.900]  Если у вас сервис не очень сильно нагружен,
[39:08.900 --> 39:10.900]  то ничего страшного в этом нет.
[39:10.900 --> 39:14.900]  Если у вас сервис имеет большое количество одновременных подключений,
[39:14.900 --> 39:17.900]  большое количество пользователей,
[39:17.900 --> 39:21.900]  то парсинг JSON уже может занимать значительное время.
[39:21.900 --> 39:24.900]  Не только парсинг, но еще и генерация.
[39:24.900 --> 39:29.900]  Вообще говоря, многие программисты и бэкэнд-разработчики,
[39:29.900 --> 39:31.900]  знаете чем занимаются в реальной жизни?
[39:31.900 --> 39:33.900]  Они не решают прикладные задачи.
[39:33.900 --> 39:37.900]  Очень значительную часть времени они занимаются тем, что перекладывают JSON.
[39:45.900 --> 39:49.900]  Аналитики частят данные от мусора,
[39:49.900 --> 39:53.900]  программисты и бэкэнд-разработчики перекладывают JSON.
[39:53.900 --> 39:59.900]  Программа JSON в том, что он не совсем однозначный.
[39:59.900 --> 40:05.900]  Как можно договориться о том, что данные у вас имеют определенный формат?
[40:05.900 --> 40:07.900]  Только прописать это в документации.
[40:07.900 --> 40:09.900]  Эту документацию нужно строго следовать.
[40:09.900 --> 40:12.900]  И это не только к формату данных,
[40:12.900 --> 40:18.900]  но и к тому, какие из команд запросов за что отвечают.
[40:18.900 --> 40:25.900]  Нет строгого определения, что является пост-запросом, что является пут-запросом.
[40:25.900 --> 40:27.900]  Как договоритесь, так и будет.
[40:27.900 --> 40:31.900]  Никакой четкой договоренности, никаких четких интерфейсов.
[40:31.900 --> 40:36.900]  Это по сути не обозначенная грамотика.
[40:36.900 --> 40:44.900]  Это является главным недостатком рест-интерфейса,
[40:44.900 --> 40:49.900]  то, что вам приходится курить документацию на каждый сервис.
[40:49.900 --> 40:58.900]  Более современным решением, хотя тоже не самым идеальным,
[40:58.900 --> 41:06.900]  является использование штуки Google Remote Processor Calls.
[41:06.900 --> 41:13.900]  Это специальный механизм для того, чтобы обеспечить межпроцессное взаимодействие,
[41:13.900 --> 41:17.900]  в том числе между разными узлами сети,
[41:17.900 --> 41:21.900]  в том числе с использованием самых разных языков программирования.
[41:21.900 --> 41:28.900]  И при этом, во-первых, гарантировать строгое соблюдение интерфейсов, которые четко описаны,
[41:28.900 --> 41:33.900]  соблюдение которых контролируется компилятором.
[41:33.900 --> 41:41.900]  Ну и основан этот протокол на базе протокола HTTP-2 версии.
[41:41.900 --> 41:47.900]  Про HTTP-2 версии я чуть позже скажу, что он из себя представляет.
[41:47.900 --> 41:53.900]  Он представляет из себя описание каких-то структур в определенном формате,
[41:53.900 --> 41:57.900]  универсальном по отношению ко всем остальным языкам программирования,
[41:57.900 --> 42:03.900]  и описанию каких-то методов определенных сервисов.
[42:03.900 --> 42:05.900]  Что могут из себя представлять методы?
[42:05.900 --> 42:10.900]  Методы могут быть какие-то обычные функции, которые вы передаете аргументу и получаете результат.
[42:10.900 --> 42:17.900]  Это будут методы, которым вы передаете какие-то аргументы и получаете непрерывный поток данных,
[42:17.900 --> 42:24.900]  который может обрабатываться последовательно, в том числе по мере генерации.
[42:24.900 --> 42:28.900]  Совершенно не обязательно они сразу завершаться, они могут работать по несколько минут.
[42:28.900 --> 42:35.900]  И клиенты могут получать данные частями, ну и плюс то же самое возможно еще и в обе стороны,
[42:35.900 --> 42:41.900]  когда клиенты постепенно отправляют какие-то данные, ну и получают данные тоже по мере готовности.
[42:41.900 --> 42:49.900]  Что представляет собой протокол JRPC?
[42:49.900 --> 42:54.900]  Ключевой момент здесь это файл описания, который называется протокол буфер,
[42:54.900 --> 42:59.900]  в котором описываются различные структуры под названием сообщения.
[42:59.900 --> 43:06.900]  Сообщение это как раз тот кусок данных, который является атомарным с точки зрения какого-то вызова.
[43:06.900 --> 43:12.900]  То есть у вас любой аргумент должен быть объявлен как какое-то сообщение,
[43:12.900 --> 43:19.900]  вы можете дальше возвращать либо сообщение, либо поток этих сообщений.
[43:19.900 --> 43:25.900]  В сообщениях могут быть самые обычные скалярные типы, которые есть во всех языках программирования.
[43:25.900 --> 43:34.900]  Это разные инты, знаковые, безнаковые с разрядностью, фолтингпоинт, фиксированные точки, строки, булевые объекты и так далее.
[43:34.900 --> 43:39.900]  Как можно организовать структуры?
[43:39.900 --> 43:44.900]  Точно так же как и в обычных все подобных языках программирования,
[43:44.900 --> 43:51.900]  у вас одни сообщения могут включать в качестве типов данных, а другие сообщения, то есть запускается вложенность.
[43:51.900 --> 44:04.900]  Такую штуку на самом деле можно преобразовать по стандартным алгоритмам формат JSON, если вдруг это вам понадобится.
[44:04.900 --> 44:13.900]  А теперь достаточно большой кусок демонстрашек всяких разных кодов.
[44:13.900 --> 44:18.900]  На самом деле это было бы очень долго, нам бы пары не хватило.
[44:18.900 --> 44:26.900]  Разберем на примере какой-нибудь практической задачи.
[44:26.900 --> 44:29.900]  Например, вы хотите сделать свою соцсеть.
[44:29.900 --> 44:35.900]  Фейсбук, она же морда книга, это запрещенная организация экстремистская.
[44:35.900 --> 44:38.900]  Надо сдерживать свое православное.
[44:38.900 --> 44:40.900]  Что такое социальная сеть?
[44:40.900 --> 44:45.900]  На самом деле это совокупность каких-то отдельных сервисов, их еще называют микросервисы.
[44:45.900 --> 44:56.900]  Разные части могут располагаться на разных серверах, могут быть реализованы на разных языках программирования.
[44:56.900 --> 45:04.900]  Итак, давайте рассмотрим создание с нуля социальной сети, которая что умеет делать.
[45:05.900 --> 45:19.900]  Во-первых, она умеет выдавать по пользователю какой-то профиль, фамилия, имя, возраст, рост, пол, телефоны и так далее.
[45:19.900 --> 45:22.900]  Что означает описание?
[45:22.900 --> 45:31.900]  Синтакс равняется Proto 3, некоторая магическая строчка, по аналогии как в CMake листе, CMake minimum required.
[45:31.900 --> 45:37.900]  Proto 3 означает третью версию протокола протобуфер, которая уже много лет как-то не менялась.
[45:37.900 --> 45:42.900]  Фактически это уже стабильный интерфейс для описания.
[45:42.900 --> 45:46.900]  Каждая структура называется message.
[45:46.900 --> 45:51.900]  Как и в обычных структурах у нас есть поля определенного типа данных.
[45:51.900 --> 46:01.900]  Название очень похоже на то, что вы встречали в языке C, либо в языке C++, либо еще где-нибудь в стримке Win64.
[46:01.900 --> 46:08.900]  Понятно, что такое? Если написать подчеркивание T, получаете название стандартного типа в языках C и C++.
[46:08.900 --> 46:11.900]  Есть янамы.
[46:11.900 --> 46:23.900]  Важным отличием от структур и классов в обычных языках программирования является то, что обязательно после имени поля является еще какое-то число.
[46:23.900 --> 46:25.900]  Для чего это нужно?
[46:25.900 --> 46:30.900]  Представьте себе, что вы реализовали какой-то сервер, реализовали каких-то клиентов,
[46:30.900 --> 46:38.900]  и потом вам нужно внести какие-то изменения в структуру взаимодействия.
[46:38.900 --> 46:43.900]  Например, вы хотите добавить новые поля, убрать какие-то уже ненужные вам.
[46:43.900 --> 46:51.900]  Для того, чтобы не поломать совместимость уже с существующими клиентами, вы можете договориться, что когда вы добавляете новую функциональность в определенной версии,
[46:51.900 --> 46:56.900]  вы используете номера с определенного диапазона, они не обязательно должны идти последовательно.
[46:56.900 --> 47:02.900]  Просто они фиксируют, что данное поле имеет такое-то имя, такое-то тип.
[47:02.900 --> 47:13.900]  Некоторые поля могут быть опциональными, то есть их указание не обязательно должно иметь дефолтное значение.
[47:13.900 --> 47:16.900]  На что еще обратить внимание?
[47:16.900 --> 47:24.900]  Поля могут повторяться, то есть быть реализованными либо как списки для тех языков, где у вас есть тип-лист,
[47:24.900 --> 47:29.900]  либо если это язык C++, они могут транслироваться в обычный вектор,
[47:29.900 --> 47:34.900]  когда вы получаете сообщение, количество элементов в нем уже известно и фиксировано.
[47:34.900 --> 47:41.900]  Кроме типов структур, а не же месседж, вы можете объявить какой-то сервис.
[47:41.900 --> 47:46.900]  Да, сервисов может быть тоже несколько, не обязательно одни.
[47:46.900 --> 47:52.900]  По сути, сервис – это некоторый интерфейс, который потом превращается в класс.
[47:52.900 --> 47:59.900]  В каждом классе могут быть свои методы, которые принимают аргументы и возвращают какие-то значения.
[47:59.900 --> 48:03.900]  Что с этим файлом потом можем сделать?
[48:03.900 --> 48:10.900]  Затем этот файл нужно превратить во что-то осмысленное и желательно сделать это автоматическим образом.
[48:10.900 --> 48:20.900]  Симейк-листs, add custom command, add custom target, помните такой из технологий программирования?
[48:20.900 --> 48:23.900]  Кодогенерацию.
[48:23.900 --> 48:26.900]  Что дальше можно сделать с этим портофайлом?
[48:26.900 --> 48:30.900]  Портофайл – это некоторый прототип для вашего кода.
[48:30.900 --> 48:38.900]  Из него дальше можно сгенерировать обычный исходный код на каких-то языках программирования,
[48:38.900 --> 48:42.900]  причем этих языков программирования может быть много.
[48:42.900 --> 48:51.900]  Команда входит в поставку многих Linux-дистрибутивов, называется protoseed,
[48:51.900 --> 48:56.900]  которая обрабатывает эти самые портофайлы и генерирует по ним исходные тексты.
[48:56.900 --> 49:04.900]  Проблема в том, что protoseed является компилятором только фронтендом этого самого языка протоописания.
[49:04.900 --> 49:12.900]  И не в каждом дистрибутиве, тем более не в каждом макии в Homebrew, есть кодогенераторы.
[49:12.900 --> 49:16.900]  Кодогенераторы, как правило, ставятся отдельно.
[49:16.900 --> 49:20.900]  Они могут входить в поставку дистрибутивов, либо могут не входить.
[49:20.900 --> 49:25.900]  Под каждый язык программирования может быть свой кодогенератор, который называется plugin.
[49:25.900 --> 49:30.900]  Вот их надо отдельно прописывать, если вы используете что-то нестандартное.
[49:30.900 --> 49:36.900]  Здесь у меня реализована поддержка четырех языков программирования.
[49:36.900 --> 49:41.900]  Это C++, Python, Dart и GoLang.
[49:41.900 --> 49:47.900]  Последним аргументом является сам протофайл.
[49:47.900 --> 49:52.900]  Собираем, что мы получаем.
[49:52.900 --> 49:56.900]  У нас генерируется куча всяких файлов.
[49:56.900 --> 50:02.900]  В частности, вот такие страшные файлы.
[50:02.900 --> 50:06.900]  Огромные.
[50:06.900 --> 50:11.900]  Которые являются временными, их лучше не редактировать, они все равно будут перегенированы.
[50:11.900 --> 50:16.900]  Я надеюсь, вам в технологиях программирования рассказывали, что в системе контроля версий
[50:16.900 --> 50:22.900]  такие файлы нужно прописывать gitignore, чтобы они ни в коем случае не попадали.
[50:22.900 --> 50:27.900]  Они являются выводимыми из какого-то другого файла.
[50:27.900 --> 50:32.900]  Возвращаемся к нашим баранам. Зачем все это нужно?
[50:32.900 --> 50:39.900]  У нас есть некоторый класс, сервис, интерфейс, под названием ProfileManager.
[50:39.900 --> 50:44.900]  Который нужно реализовать.
[50:44.900 --> 50:50.900]  Реализуется следующим образом, что у нас есть некоторый сгенерированный
[50:50.900 --> 50:55.900]  интерфейс, абстрактный класс, который можно унаследовать
[50:55.900 --> 51:02.900]  и написать уже точную реализацию метода, например, по названию GetUserProfi.
[51:02.900 --> 51:08.900]  То есть, как реализуется что-то на gRPC. Вы сделали какой-то протофайл,
[51:08.900 --> 51:14.900]  сгенерировали дальше абстрактные классы, их наследуете и выполняете их реализация.
[51:14.900 --> 51:19.900]  Тем самым вы реализуете функциональность ваших серверов.
[51:19.900 --> 51:25.900]  Переопределяем нужный вам метод. Метод достаточно простой.
[51:25.900 --> 51:29.900]  Это не реальный код, это просто демонстрация.
[51:29.900 --> 51:35.900]  Поэтому за хардкоженые два имени, по которым нужно выдать какую-то информацию.
[51:35.900 --> 51:41.900]  Типа данных самые простые, соответствующие определенному языку программирования.
[51:41.900 --> 51:47.900]  То есть, если у нас язык C++ и поле указано как строковое,
[51:47.900 --> 51:53.900]  то используется обычный класс std string.
[51:53.900 --> 51:57.900]  В питоне, соответственно, обычная питонская строка.
[51:57.900 --> 52:03.900]  То есть, код генерировался так, чтобы быть максимально родным для текущего языка программирования.
[52:03.900 --> 52:09.900]  Вот реализовали какой-то сервис. Что мы с ним можем сделать?
[52:09.900 --> 52:17.900]  Мы можем объявить некоторый сервер, который привязан либо ко всем интерфейсам, либо только к Localhost.
[52:17.900 --> 52:25.900]  К этому серверу на один порт подключить один либо несколько сервисов,
[52:25.900 --> 52:31.900]  которые реализуют конкретные классы, и запустить очередь на обработку.
[52:31.900 --> 52:33.900]  Вот вся реализация.
[52:33.900 --> 52:36.900]  Ладно, это то, что касается реализации сервера.
[52:36.900 --> 52:38.900]  Теперь насчет клиента.
[52:38.900 --> 52:44.900]  Клиент давайте для разнообразия пусть будет не на плюсах, а на питоне.
[52:48.900 --> 52:58.900]  Для этого мы генерируем какой-то код, складываем его в какой-то каталог для питона.
[52:58.900 --> 53:05.900]  Дальше этот код, который выглядит опять же страшным образом, но нам совершенно не обязательно его смотреть.
[53:05.900 --> 53:08.900]  Зачем нам это все узнать?
[53:08.900 --> 53:13.900]  Это все генерируется автоматически. Мы это просто импортируем и используем.
[53:13.900 --> 53:22.900]  Итак, у нас есть некоторый сервер. Мы знаем имя хоста, мы знаем порт для этого сервера.
[53:22.900 --> 53:25.900]  Хорошо подключаемся.
[53:25.900 --> 53:28.900]  Дальше загружаем какой-то интерфейс.
[53:28.900 --> 53:34.900]  Получение профиля означает, что нам нужно сформировать какое-то сообщение,
[53:34.900 --> 53:39.900]  передать его в качестве аргумента, получить результат и радоваться жизни.
[53:41.900 --> 53:49.900]  В этом файле у меня реализованы только функции, поэтому я открою отдельный терминал.
[53:52.900 --> 53:59.900]  Запущу питон в интерактивном режиме.
[53:59.900 --> 54:05.900]  Опция "-i", это означает, что нужно выполнить какой-то файл.
[54:05.900 --> 54:11.900]  После этого не завершать работу, а использовать обычный концов.
[54:11.900 --> 54:19.900]  Итак, метод получения профиля подразумевает, что нужно указать имя,
[54:19.900 --> 54:24.900]  который потом сконвертирует нужное сообщение и вызовет то, что нам нужно.
[54:24.900 --> 54:33.900]  У меня реализованы два товарища. Один называется Ваван, который...
[54:33.900 --> 54:35.900]  Вот мы получаем строку.
[54:35.900 --> 54:41.900]  First name, last name. Соответственно, здесь просто Shell нам экранирует русские буквы,
[54:41.900 --> 54:48.900]  но можно получить... Все хорошо, все замечательно.
[54:48.900 --> 54:55.900]  Что при этом происходит опять же с точки зрения того, что у нас происходит по сети.
[54:55.900 --> 55:00.900]  Так, порт был... Порт, порт...
[55:00.900 --> 55:10.900]  Порт 1.9.0.1. Давайте посмотрим, что там теперь у нас происходит.
[55:10.900 --> 55:12.900]  9.0.1.
[55:12.900 --> 55:17.900]  Я отправляю какой-то запрос. Что мы видим в R-шарке?
[55:17.900 --> 55:22.900]  В R-шарке мы видим какие-то TCP-соединения. В общем, какой-то мусор.
[55:22.900 --> 55:26.900]  Это про то, что я явно образом отключил шифрование.
[55:26.900 --> 55:32.900]  Во-первых, чтобы можно было как-то продемонстрировать то, что у нас гоняется по сети.
[55:32.900 --> 55:36.900]  Во-вторых, чтобы не заморачиваться с подключением сертификатов.
[55:36.900 --> 55:39.900]  Так, какие-то бинарные данные.
[55:39.900 --> 55:46.900]  Но на самом деле это протокол TCP-2, который при этом является тоже бинарным.
[55:46.900 --> 55:50.900]  Так, в R-шарке для этого мы можем сделать некоторую подсказку.
[55:50.900 --> 55:54.900]  Меню Analyze. Дальше Decode S.
[55:54.900 --> 56:04.900]  И можно сказать, что все, что у нас попадает на порт 1.9.0.1, нужно трактовать как протокол.
[56:04.900 --> 56:11.900]  Выбираем из списка того, что поддерживает R-шарк, что он умеет распознавать TCP-2.
[56:11.900 --> 56:13.900]  Так, окей.
[56:13.900 --> 56:16.900]  Вывод стал чуть более осмысленным.
[56:16.900 --> 56:21.900]  Итак, что такое протокол HTTP-2, который у нас тут используется под капотом?
[56:21.900 --> 56:23.900]  А, ну, сначала gRPC.
[56:23.900 --> 56:25.900]  Вот полный степ протоколов.
[56:25.900 --> 56:30.900]  Протокол IPv6 вместо IPv4. Интересно, ну ладно.
[56:30.900 --> 56:33.900]  По верхнему дальше идет TCP, как транспортный.
[56:33.900 --> 56:37.900]  Дальше идет следующий уровень HTTP-2,
[56:37.900 --> 56:43.900]  в котором закодировано какое-то gRPC-сообщение, доступ к профиль-менеджер slash getUserProfile,
[56:43.900 --> 56:51.900]  получить реквест, который в свою очередь содержит запрос под названием messageUser,
[56:51.900 --> 56:58.900]  логин Ваван и где-то у нас есть в обратную сторону gRPC.
[56:58.900 --> 57:00.900]  Ответ.
[57:00.900 --> 57:06.900]  Откуда вообще R-шарк знает, как нужно парсить вот эти все структуры?
[57:06.900 --> 57:10.900]  Опять же, R-шарк по молчанию ничего не знает.
[57:10.900 --> 57:16.900]  Для этого нужно залезть в настройки, дальше выбрать протокол с,
[57:16.900 --> 57:21.900]  найти здесь protobuf где-то в списке огромном
[57:21.900 --> 57:27.900]  и в настройках уже этого протобуфа указать каталог, где валяются ваши протофайлы,
[57:27.900 --> 57:31.900]  чтобы R-шарк искал нужные вам описания.
[57:31.900 --> 57:37.900]  Вот я это один раз прописал, теперь R-шарк может мне подробно все отображать.
[57:37.900 --> 57:41.900]  Ну ладно, это не самое на самом деле интересное.
[57:41.900 --> 57:51.900]  Чуть более интересное это, что именно у нас передается в рамках протокола HTTP-2 на каждый запрос.
[57:51.900 --> 57:58.900]  В протоколе HTTP-2 у нас перейдются бинарные данные, которые вполне себе осмыслены
[57:58.900 --> 58:02.900]  и они содержат...
[58:02.900 --> 58:06.900]  Ладно, покажу отдельную картинку лучше.
[58:06.900 --> 58:10.900]  В общем, у нас есть jfpc, который кодирует HTTP-2.
[58:10.900 --> 58:15.900]  Эти данные перейдут через обычный TCP.
[58:15.900 --> 58:23.900]  Кроме того, что мы можем делать обычные запросы, связанные с передачей аргументов
[58:23.900 --> 58:28.900]  и получением результатов, мы можем еще делать запросы,
[58:28.900 --> 58:34.900]  которые отправляют некоторый поток данных.
[58:34.900 --> 58:38.900]  Опять же, я подробно не буду вдаваться в этот код.
[58:38.900 --> 58:43.900]  Потом посмотрите на GitHub.
[58:43.900 --> 58:49.900]  То же самое можно сделать на языке Go, запустить еще один сервис.
[58:49.900 --> 59:01.900]  Используя тот же самый Python, помимо получения профилей, еще и так.
[59:07.900 --> 59:17.900]  Открыть одну вкладку, например, и начать получать сообщение.
[59:17.900 --> 59:22.900]  Часть соцсети это все-таки messenger.
[59:22.900 --> 59:34.900]  Откроем еще одну вкладку и отправим сообщение
[59:34.900 --> 59:42.900]  от юзера Ion-пользователю WoWan.
[59:49.900 --> 59:53.900]  Вот сообщение доставлено.
[59:53.900 --> 01:00:02.900]  Более интересное, что такое себя представляет протокол HTTP-2, который мы наблюдали в Airshark.
[01:00:02.900 --> 01:00:11.900]  Это более современная реализация протокола HTTP.
[01:00:11.900 --> 01:00:17.900]  Если первая версия была текстовая, зачем нужна бинарная версия протокола?
[01:00:17.900 --> 01:00:21.900]  Наверное, для того чтобы экономить байтики.
[01:00:21.900 --> 01:00:25.900]  Все-таки плейнтекст не очень оптимален с точки зрения передачи данных.
[01:00:25.900 --> 01:00:31.900]  При этом протокол HTTP-2 может использовать те же самые порты, что и обычный протокол,
[01:00:31.900 --> 01:00:37.900]  то есть 80-ый для незашифрона и 443-ий с использованием SSL.
[01:00:37.900 --> 01:00:43.900]  Как можно переключиться с первого на второй?
[01:00:43.900 --> 01:00:50.900]  Вы делаете запрос в какой-то странице, используя протокол HTTP 1.1, все стандартно,
[01:00:50.900 --> 01:00:57.900]  и прописать заголовок Connection Upgrade и плюс заголовок Upgrade до какого протокола.
[01:00:57.900 --> 01:01:06.900]  Если сервер поддерживает вторую версию HTTP, то он выполнит статус 101 Connection Upgrade
[01:01:06.900 --> 01:01:09.900]  и после этого уже возможно взаимодействие протокола HTTP-2.
[01:01:09.900 --> 01:01:15.900]  Если сервер не поддерживает, он этот заголовок просто проигнорирует, ничего плохого при этом не произойдет.
[01:01:15.900 --> 01:01:18.900]  В чем особенность этого протокола?
[01:01:18.900 --> 01:01:21.900]  Помимо того, что он является бинарным.
[01:01:21.900 --> 01:01:24.900]  Шифрование также как и для первого протокола является опциональным,
[01:01:24.900 --> 01:01:30.900]  хотя во многих серверах EngineX требуется обязательно сертификатики указывать.
[01:01:30.900 --> 01:01:35.900]  Самое главное, что он позволяет двунаправленное взаимодействие,
[01:01:35.900 --> 01:01:39.900]  то есть не просто запрос-ответ, но и взаимодействие в реальном времени,
[01:01:39.900 --> 01:01:44.900]  и при этом позволяет на один запрос отправлять сразу несколько файлов,
[01:01:44.900 --> 01:01:47.900]  используя при этом всего лишь один socket.
[01:01:47.900 --> 01:01:49.900]  Как это работает?
[01:01:49.900 --> 01:01:54.900]  У нас весь поток данных, либо несколько потоков данных,
[01:01:54.900 --> 01:01:58.900]  бьется на некоторые части, которые называются фреймы.
[01:01:58.900 --> 01:02:03.900]  Фрейм – это небольшой кусок данных размером от 16 кб до 16 мб.
[01:02:03.900 --> 01:02:06.900]  В общем случае его размер может варьироваться,
[01:02:06.900 --> 01:02:10.900]  для этого нужно отправлять специальные фреймы на их перенастройку.
[01:02:10.900 --> 01:02:12.900]  Фреймы могут иметь разные типы.
[01:02:12.900 --> 01:02:17.900]  Это могут быть либо фреймы с заголовками, либо фреймы с данными,
[01:02:17.900 --> 01:02:19.900]  либо специальные фреймы типа PING,
[01:02:19.900 --> 01:02:22.900]  для того чтобы проверять, действительно ли соединение у нас есть.
[01:02:22.900 --> 01:02:28.900]  И каждый независимый файл, либо каждый независимый запрос
[01:02:28.900 --> 01:02:30.900]  оформляется в виде последовательности фреймов,
[01:02:30.900 --> 01:02:36.900]  которые имеют некоторые общие уникальные ID этого потока.
[01:02:36.900 --> 01:02:42.900]  В чем главное преимущество с использованием протокола HTTP2?
[01:02:42.900 --> 01:02:47.900]  Если вы не заморачиваетесь со всяким межпроцессным взаимодействием,
[01:02:47.900 --> 01:02:52.900]  просто хотите использовать этот протокол для выдачи веб-страниц.
[01:02:52.900 --> 01:02:55.900]  В среднем получается все быстрее,
[01:02:55.900 --> 01:02:58.900]  потому что вам не нужно последовательно ждать,
[01:02:58.900 --> 01:03:00.900]  когда у вас закончится что-то предыдущее.
[01:03:00.900 --> 01:03:04.900]  У вас все фрагменты разбиваются на какие-то маленькие части
[01:03:04.900 --> 01:03:07.900]  и отправляются по очередной.
[01:03:07.900 --> 01:03:11.900]  При этом возможна приоритизация каких-то отдельных потоков,
[01:03:11.900 --> 01:03:13.900]  каких-то отдельных файлов.
[01:03:13.900 --> 01:03:18.900]  И важной особенностью протокола HTTP2 является то,
[01:03:18.900 --> 01:03:23.900]  что вы можете отправить один запрос, например, получить главную страницу.
[01:03:23.900 --> 01:03:27.900]  Что помимо главной страницы, а что эмолки, у вас может еще загружаться.
[01:03:27.900 --> 01:03:31.900]  Картинки, CSS-файлы, Джаваскрипты.
[01:03:31.900 --> 01:03:34.900]  Как для этого нужно делать в обычном HTTP 1.1?
[01:03:34.900 --> 01:03:39.900]  Вам нужно последовательно отправлять запросы и загружать какие-то файлы.
[01:03:39.900 --> 01:03:42.900]  В случае с HTTP2, если веб-сервер знает,
[01:03:42.900 --> 01:03:46.900]  что с какой-то страницей связано несколько ресурсов,
[01:03:46.900 --> 01:03:52.900]  то сервер может сделать упреждающую отправку сразу всех данных.
[01:03:52.900 --> 01:03:57.900]  И это получается без дополнительных запросов, намного быстрее.
[01:03:58.900 --> 01:04:02.900]  Какое отношение это все-таки имеет к gRPC?
[01:04:02.900 --> 01:04:08.900]  Если у нас есть что-то, что работает поверх чего-то с названием HTTP,
[01:04:08.900 --> 01:04:13.900]  то, наверное, эта штука должна работать из обычных браузеров.
[01:04:13.900 --> 01:04:19.900]  Обычный ремонт процедур calls можно использовать из обычного Джаваскрипта,
[01:04:19.900 --> 01:04:24.900]  либо из чего-то, что транслируется в Джаваскрипт.
[01:04:24.900 --> 01:04:29.900]  То есть мы можем теперь те же самые методы получения профиля, чата,
[01:04:29.900 --> 01:04:32.900]  вызвать из обычного браузера.
[01:04:32.900 --> 01:04:36.900]  Давайте попробуем, получится у нас это или не получится.
[01:04:36.900 --> 01:04:40.900]  Так, отдельный проект.
[01:04:48.900 --> 01:04:54.900]  Небольшое приложение, которое загружает профили,
[01:04:54.900 --> 01:04:57.900]  выглядит следующим образом.
[01:04:57.900 --> 01:05:02.900]  Так, port 1.9.0.1, здесь было для профилей.
[01:05:02.900 --> 01:05:06.900]  Так, запускаем в Google Chrome.
[01:05:14.900 --> 01:05:17.900]  Да, Google Chrome запускается долго.
[01:05:17.900 --> 01:05:20.900]  Еще чуть-чуть там качается.
[01:05:20.900 --> 01:05:24.900]  Так, сразу немножко про веб-разработку.
[01:05:24.900 --> 01:05:27.900]  Совершенно не обязательно писать все на Джаваскрипте.
[01:05:27.900 --> 01:05:30.900]  Я имею в виду клиентскую часть.
[01:05:30.900 --> 01:05:33.900]  Когда-то давно можно было писать на Джаве.
[01:05:33.900 --> 01:05:36.900]  Еще можно писать на TypeScript.
[01:05:36.900 --> 01:05:39.900]  Еще можно писать на языке Dart.
[01:05:39.900 --> 01:05:42.900]  Кто еще какие языки для веб-разработки знает?
[01:05:42.900 --> 01:05:45.900]  В TypeScript я его перечисливаю.
[01:05:45.900 --> 01:05:48.900]  Что еще?
[01:05:48.900 --> 01:05:51.900]  Раст, кстати, да, тоже возможно.
[01:05:51.900 --> 01:05:54.900]  Но такое извращение.
[01:05:54.900 --> 01:05:58.900]  В общем, некоторые коды, которые позволяют что-то загрузить.
[01:05:58.900 --> 01:06:01.900]  Браузер меня запустился.
[01:06:01.900 --> 01:06:04.900]  Оно вроде даже работает.
[01:06:04.900 --> 01:06:07.900]  Так, ладно, отправим.
[01:06:07.900 --> 01:06:12.900]  Запрос. Мы знаем, что у нас есть пользователь по названию Vovan.
[01:06:12.900 --> 01:06:17.900]  Отправка идет следующим образом.
[01:06:17.900 --> 01:06:20.900]  У нас есть какой-то канал,
[01:06:20.900 --> 01:06:23.900]  который реализовал, есть интерфейс,
[01:06:23.900 --> 01:06:26.900]  который опять же сгенерирован из ProtoFile.
[01:06:26.900 --> 01:06:29.900]  И если вы что-то в ProtoFile поменяете,
[01:06:29.900 --> 01:06:32.900]  вам придется перекомпилировать то и другое.
[01:06:32.900 --> 01:06:35.900]  Так, загрузка профиля.
[01:06:35.900 --> 01:06:38.900]  Следующим образом,
[01:06:38.900 --> 01:06:41.900]  создаете сообщение,
[01:06:41.900 --> 01:06:44.900]  типа user, объект класса.
[01:06:44.900 --> 01:06:47.900]  Вызываете метод getUserProfile
[01:06:47.900 --> 01:06:50.900]  и получаете из него все, что вам нужно.
[01:06:50.900 --> 01:06:53.900]  Ничего особенного.
[01:06:53.900 --> 01:06:56.900]  Так, ну и теперь из браузера
[01:06:56.900 --> 01:06:59.900]  отправляем на сервер.
[01:06:59.900 --> 01:07:02.900]  И получаем в бабах какую-то ошибку.
[01:07:02.900 --> 01:07:05.900]  Так, о том, что...
[01:07:05.900 --> 01:07:08.900]  Внимательно не читаем текст ошибки.
[01:07:08.900 --> 01:07:11.900]  На самом деле, ProPotentialCourseIssue можно проигнорировать.
[01:07:11.900 --> 01:07:14.900]  Он отключен.
[01:07:14.900 --> 01:07:17.900]  Запрос завершен без статуса.
[01:07:17.900 --> 01:07:20.900]  И вообще какая-то ошибка,
[01:07:20.900 --> 01:07:23.900]  связанная с тем, что у нас
[01:07:23.900 --> 01:07:26.900]  браузер не получил какой-то осмысленный HTTP ответ.
[01:07:26.900 --> 01:07:29.900]  С чем это связано?
[01:07:29.900 --> 01:07:32.900]  Как вообще браузеры отправляют какие-то запросы?
[01:07:32.900 --> 01:07:35.900]  Например, к внешним API.
[01:07:35.900 --> 01:07:38.900]  Штука, которая называется
[01:07:38.900 --> 01:07:41.900]  абраторией hxhr,
[01:07:41.900 --> 01:07:44.900]  исходно называлась XMLHTPRequest,
[01:07:44.900 --> 01:07:47.900]  которая позволяла создавать новые подключения
[01:07:47.900 --> 01:07:50.900]  к JavaScript.
[01:07:50.900 --> 01:07:53.900]  На самом деле, никакому языку XML это уже давно
[01:07:53.900 --> 01:07:56.900]  отношение не имеет, но так исторически сложилось
[01:07:56.900 --> 01:07:59.900]  именно такое название hxhr.
[01:07:59.900 --> 01:08:02.900]  То есть создается новое подключение,
[01:08:02.900 --> 01:08:05.900]  HTTP, которое дергает какие-то данные,
[01:08:05.900 --> 01:08:08.900]  и дальше эти данные можно распарсить уже средством языка JavaScript
[01:08:08.900 --> 01:08:11.900]  с той страницы,
[01:08:11.900 --> 01:08:14.900]  которой этот запрос инициировал.
[01:08:15.900 --> 01:08:18.900]  Во-первых, можно использовать только тот же самый протокол,
[01:08:18.900 --> 01:08:21.900]  который использовался для загрузки исходной страницы.
[01:08:21.900 --> 01:08:24.900]  Если браузер загрузил страницу
[01:08:24.900 --> 01:08:27.900]  через протокол HTTP1,
[01:08:27.900 --> 01:08:30.900]  то он отправлять может только HTTP1.1,
[01:08:30.900 --> 01:08:33.900]  но не HTTP2.
[01:08:33.900 --> 01:08:36.900]  А он является обязательным для gRPC.
[01:08:36.900 --> 01:08:39.900]  Второе ограничение связано с тем,
[01:08:39.900 --> 01:08:42.900]  что браузер подразумевает, что сначала должны быть все заголовки,
[01:08:42.900 --> 01:08:45.900]  а потом идут данные.
[01:08:45.900 --> 01:08:48.900]  В то же время, поскольку протокол HTTP2
[01:08:48.900 --> 01:08:51.900]  очень гибко бьется на фреймы,
[01:08:51.900 --> 01:08:54.900]  и в gRPC последний фрейм
[01:08:54.900 --> 01:08:57.900]  обычно используется для того, чтобы вернуть
[01:08:57.900 --> 01:09:00.900]  код возврата, который у вас получился
[01:09:00.900 --> 01:09:03.900]  статус возврата из gRPC функции.
[01:09:03.900 --> 01:09:06.900]  И это тоже не очень совместимо с тем,
[01:09:06.900 --> 01:09:09.900]  что ожидает увидеть браузер.
[01:09:09.900 --> 01:09:12.900]  Используйте gRPC даже в том случае,
[01:09:12.900 --> 01:09:15.900]  если вы полностью перешли на протокол HTTP2.
[01:09:15.900 --> 01:09:18.900]  У кого-то есть свой сервер,
[01:09:18.900 --> 01:09:21.900]  у которого болтает свой сайт.
[01:09:21.900 --> 01:09:24.900]  Можно на хостинге.
[01:09:29.900 --> 01:09:32.900]  Попробуйте в качестве эксперимента
[01:09:32.900 --> 01:09:35.900]  просто в настройках nginx переключить с HTTP1 на HTTP2,
[01:09:35.900 --> 01:09:38.900]  и вы приятно будете удивлены,
[01:09:38.900 --> 01:09:41.900]  потому что протокол HTTP2
[01:09:41.900 --> 01:09:44.900]  все более распространен как средство
[01:09:44.900 --> 01:09:47.900]  для выдачи контента.
[01:09:47.900 --> 01:09:50.900]  Но тем не менее, эта маленькая особенность
[01:09:50.900 --> 01:09:53.900]  то, что gRPC самым последним фреймом
[01:09:53.900 --> 01:09:56.900]  выдает код возврата, который сам по себе
[01:09:56.900 --> 01:09:59.900]  является заголовком. Он уже не совместим с браузером.
[01:09:59.900 --> 01:10:02.900]  А как же все-таки можно использовать gRPC,
[01:10:02.900 --> 01:10:05.900]  чтобы не создавать прослойки
[01:10:05.900 --> 01:10:08.900]  в виде перекладывания JSON,
[01:10:08.900 --> 01:10:11.900]  в виде дополнительных действий.
[01:10:11.900 --> 01:10:14.900]  Можно использовать
[01:10:14.900 --> 01:10:17.900]  некоторое подмножество gRPC.
[01:10:17.900 --> 01:10:20.900]  Еще один протокол,
[01:10:20.900 --> 01:10:23.900]  который называется gRPC Web,
[01:10:23.900 --> 01:10:26.900]  это два разных протокола.
[01:10:26.900 --> 01:10:29.900]  Если вы будете где-то в сети встречать протокол gRPC Web,
[01:10:29.900 --> 01:10:32.900]  то это вовсе не gRPC, а протокол,
[01:10:32.900 --> 01:10:35.900]  который назначен как раз для использования
[01:10:35.900 --> 01:10:38.900]  браузерами, то есть его использование
[01:10:38.900 --> 01:10:41.900]  помимо браузеров не очень осмысленно.
[01:10:41.900 --> 01:10:44.900]  Когда-то для него существовал плагин для Nginx,
[01:10:44.900 --> 01:10:47.900]  который потом уже перестал развиваться,
[01:10:47.900 --> 01:10:50.900]  поддерживаться, его выкинули.
[01:10:50.900 --> 01:10:53.900]  Но есть другие прокси-серверы, либо
[01:10:53.900 --> 01:10:56.900]  юнвой-сервер, либо есть пакет еще для Гоуланга.
[01:10:56.900 --> 01:10:59.900]  В чем заключается проксирование?
[01:10:59.900 --> 01:11:02.900]  Для того, чтобы транслировать запросы,
[01:11:02.900 --> 01:11:05.900]  которые может сформировать браузер,
[01:11:05.900 --> 01:11:08.900]  в обычный полноценный gRPC, чтобы вам не приходилось
[01:11:08.900 --> 01:11:11.900]  переписывать код. В обратную сторону ответы,
[01:11:11.900 --> 01:11:14.900]  транслировать во что-то, что браузер
[01:11:14.900 --> 01:11:17.900]  сможет понимать.
[01:11:17.900 --> 01:11:20.900]  Небольшая правка в коде.
[01:11:20.900 --> 01:11:23.900]  И плюс запускаем еще внешний прокси-сервер.
[01:11:24.900 --> 01:11:27.900]  Так, сервис у меня работает.
[01:11:27.900 --> 01:11:30.900]  Осталось запустить
[01:11:30.900 --> 01:11:33.900]  что-то, что работает.
[01:11:33.900 --> 01:11:36.900]  Что такое прокси-сервер? Это штука, которая
[01:11:36.900 --> 01:11:39.900]  цепляется в качестве клиента к серверу,
[01:11:39.900 --> 01:11:42.900]  при этом создает еще свой сервер,
[01:11:42.900 --> 01:11:45.900]  который работает на другом порту,
[01:11:45.900 --> 01:11:48.900]  и к нему уже клиенты могут подключаться.
[01:11:48.900 --> 01:11:51.900]  В исходном тексте мне нужно поменять
[01:11:51.900 --> 01:11:54.900]  номер порта.
[01:11:54.900 --> 01:11:57.900]  8081.
[01:11:57.900 --> 01:12:00.900]  Запускаю заново.
[01:12:03.900 --> 01:12:06.900]  При этом нужно, естественно,
[01:12:06.900 --> 01:12:09.900]  в аэршарке поменять
[01:12:09.900 --> 01:12:12.900]  номер порта, если мы хотим за этим
[01:12:12.900 --> 01:12:15.900]  наблюдать.
[01:12:15.900 --> 01:12:18.900]  Пока запускается Chrome, есть у вас вопросы.
[01:12:19.900 --> 01:12:22.900]  Тогда ждем, пока запустится Chrome.
[01:12:22.900 --> 01:12:25.900]  Запустился.
[01:12:25.900 --> 01:12:28.900]  Так.
[01:12:28.900 --> 01:12:31.900]  Запускаем.
[01:12:31.900 --> 01:12:34.900]  Ищем профиль Вавана.
[01:12:34.900 --> 01:12:37.900]  Все работает. Это обычный браузер,
[01:12:37.900 --> 01:12:40.900]  обычный джаваскрипт.
[01:12:40.900 --> 01:12:43.900]  Точнее, код, который был транслирован джаваскриптом,
[01:12:43.900 --> 01:12:46.900]  все равно выполняется обычным джаваскриптом.
[01:12:46.900 --> 01:12:49.900]  При этом я не вносил никаких изменений
[01:12:49.900 --> 01:12:52.900]  в тот сервер на C++,
[01:12:52.900 --> 01:12:55.900]  который нам это все выдал.
[01:12:55.900 --> 01:12:58.900]  Ну и что у нас реально передавалось по сети?
[01:12:58.900 --> 01:13:01.900]  Вот у нас есть обычный HTTP пост-запрос,
[01:13:04.900 --> 01:13:07.900]  который содержит URL
[01:13:07.900 --> 01:13:10.900]  примерно такой же, как в HTTP2,
[01:13:10.900 --> 01:13:13.900]  Content Type Application,
[01:13:13.900 --> 01:13:16.900]  gRPC, web с proto-файлом.
[01:13:16.900 --> 01:13:19.900]  И в этом запросе у нас
[01:13:19.900 --> 01:13:22.900]  есть контент, который
[01:13:22.900 --> 01:13:25.900]  уже является бинарным, тот самый
[01:13:25.900 --> 01:13:28.900]  протобуфер. То есть протобуфер описывает только формат
[01:13:28.900 --> 01:13:31.900]  сообщений, а не запрос.
[01:13:31.900 --> 01:13:34.900]  И мы получаем ответ, который сформирован
[01:13:34.900 --> 01:13:37.900]  уже проксисервером,
[01:13:37.900 --> 01:13:40.900]  на основании тех данных, которые он получил от настоящего сервера.
[01:13:40.900 --> 01:13:43.900]  Он просто поделил
[01:13:43.900 --> 01:13:46.900]  все фреймы, запихал их
[01:13:46.900 --> 01:13:49.900]  в некоторые отдельные части
[01:13:52.900 --> 01:13:55.900]  последовательные.
[01:13:55.900 --> 01:13:58.900]  Текстовый протокол в HTTP тоже позволяет.
[01:13:58.900 --> 01:14:01.900]  Ну и несколько кусков,
[01:14:01.900 --> 01:14:04.900]  которые потом склеиваются
[01:14:04.900 --> 01:14:07.900]  и соединяются
[01:14:07.900 --> 01:14:10.900]  в одно большое протобуфер сообщений.
[01:14:17.900 --> 01:14:20.900]  Помимо протокола HTTP2,
[01:14:20.900 --> 01:14:23.900]  сейчас уже 22-й год
[01:14:23.900 --> 01:14:26.900]  существует в формате драфта
[01:14:26.900 --> 01:14:29.900]  следующий стандарт.
[01:14:29.900 --> 01:14:32.900]  Второй HTTP был не настолько популярным,
[01:14:32.900 --> 01:14:35.900]  даже сейчас, сколько лет прошло,
[01:14:35.900 --> 01:14:38.900]  2016-2015 год появился.
[01:14:38.900 --> 01:14:41.900]  До сих пор это еще не мейнстрим,
[01:14:41.900 --> 01:14:44.900]  поскольку не обладал
[01:14:44.900 --> 01:14:47.900]  существенными преимуществами
[01:14:47.900 --> 01:14:50.900]  в ущерб читабельности.
[01:14:50.900 --> 01:14:53.900]  Сейчас разрабатывается новый протокол HTTP
[01:14:53.900 --> 01:14:56.900]  на базе протокола Google Quick.
[01:14:56.900 --> 01:14:59.900]  Тут уже будут более существенные улучшения.
[01:14:59.900 --> 01:15:02.900]  Во-первых, будет использоваться UDP
[01:15:02.900 --> 01:15:05.900]  Удп не дает никаких гарантий,
[01:15:05.900 --> 01:15:08.900]  поэтому как раз используется
[01:15:08.900 --> 01:15:11.900]  чуть более высокоуровневый механизм,
[01:15:11.900 --> 01:15:14.900]  который будет отдельно
[01:15:14.900 --> 01:15:17.900]  в польском пространстве,
[01:15:17.900 --> 01:15:20.900]  а не в ядре,
[01:15:20.900 --> 01:15:23.900]  считать,
[01:15:23.900 --> 01:15:26.900]  какие пакеты у вас дошли
[01:15:26.900 --> 01:15:29.900]  и в каком порядке составлять
[01:15:29.900 --> 01:15:32.900]  UDP сообщения в правильном порядке
[01:15:32.900 --> 01:15:35.900]  и дальше их интерпретировать.
[01:15:35.900 --> 01:15:38.900]  Здесь дальнейшее развитие идеи
[01:15:38.900 --> 01:15:41.900]  с фреймами, что у нас данные передаются
[01:15:41.900 --> 01:15:44.900]  небольшими кусочками.
[01:15:44.900 --> 01:15:47.900]  В отличие от второго HTTP
[01:15:47.900 --> 01:15:50.900]  шифрование будет обязательным.
[01:15:50.900 --> 01:15:53.900]  Главная пользовательская фича
[01:15:53.900 --> 01:15:56.900]  в том, что можно будет делать
[01:15:56.900 --> 01:15:59.900]  из одной сети в другую.
[01:15:59.900 --> 01:16:02.900]  Это имеет смысл, если вы пользоваетесь
[01:16:02.900 --> 01:16:05.900]  смартфонами, ноутбуками,
[01:16:05.900 --> 01:16:08.900]  переключаетесь между Wi-Fi сетями
[01:16:08.900 --> 01:16:11.900]  либо с Wi-Fi в мобильную сеть,
[01:16:11.900 --> 01:16:14.900]  разрыва связи у вас происходить не будет.
[01:16:14.900 --> 01:16:17.900]  Потому что у вас нету такого
[01:16:17.900 --> 01:16:20.900]  постоянного TCP-соединения,
[01:16:20.900 --> 01:16:23.900]  которое нужно переустанавливать.
[01:16:23.900 --> 01:16:27.900]  Содержательных вопросов нет.
