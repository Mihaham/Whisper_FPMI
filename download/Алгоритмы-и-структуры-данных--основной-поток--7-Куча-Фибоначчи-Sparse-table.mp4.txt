[00:00.000 --> 00:13.880]  Всем добрый вечер. Давайте начинать. Продолжаем разговор про кучи. Давайте красненько напомним,
[00:13.880 --> 00:18.720]  что было в прошлый раз. В прошлый раз мы говорили про, в частности, говорили про биномиальную кучу.
[00:18.720 --> 00:27.320]  Это куча, которая, в отличие от бинарной, позволяет нам еще быстро их сливать. Если есть две
[00:27.320 --> 00:32.960]  корректные биномиальные кучи, мы хотели бы научиться объединять элементы, которые лежат хотя бы в одном
[00:32.960 --> 00:37.000]  из них, в одну большую кучу. То есть два множества объединить в одно. Два мультимножества точно.
[00:37.000 --> 00:44.520]  Теперь давайте научимся делать все то же самое, только быстрее, с помощью фибоначевой кучи.
[00:44.520 --> 00:59.720]  Фибоначи его куча. Она же куча фибоначи. Как хотите, так и называйте. Сразу дисклеймер,
[00:59.720 --> 01:05.760]  что она умеет делать и за какие симптотики. Инсерт. Она умеет делать за чистую единицу.
[01:05.760 --> 01:23.960]  Гетмин, как обычно, тоже за чистую единицу. Мёрдж, внезапно, тоже за единицу. Декриски
[01:23.960 --> 01:34.400]  за амортизированную единицу. Она же учетная. Это то, что было в прошлый раз,
[01:34.400 --> 01:39.600]  про амортизированную стоимость в этом самом смысле. Со звездочки, то есть учетная стоимость
[01:39.600 --> 01:46.200]  равна единице. Напоминаю кратко, что это значит, что на самом деле выполнение каждого конкретного
[01:46.200 --> 01:52.560]  декриски может быть довольно долгим по времени, но если вы будете считать, что это работает за единицу,
[01:52.560 --> 01:57.560]  сложите верхние оценки на все вот эти вот функции, то это будет верхняя оценка на реальное время работы.
[01:57.560 --> 02:02.840]  То есть каждое конкретное возможно работать дольше, но суммарно, как если бы здесь была единица.
[02:02.840 --> 02:10.520]  Так, ну и последний экстракт-мин остался. Экстракт-мин работает за сколько бы вы думали.
[02:10.520 --> 02:16.080]  Могу ли я здесь написать единицу, например? Единица здесь очень вряд ли, потому что мы
[02:16.080 --> 02:21.280]  доказывали простой факт, что если у нас в куче и инсерт, и экстракт-мин работают за единицу,
[02:21.280 --> 02:27.080]  то мы умеем сортировать за отен. Чего мы, скорее всего, не умеем на самом деле. Точнее, мы точно не
[02:27.080 --> 02:33.520]  умеем, коль скоро куча на сравнениях. Вопрос какой-то? Да, значит здесь будет амортизированный логарифм.
[02:33.520 --> 02:40.680]  Единицы, к сожалению, не получится, но ас логарифмом получится. Вот смотрите, ну ничего,
[02:40.680 --> 02:45.360]  довольно хорошо по сравнению со всем, что было раньше. По крайней мере дикризки точно быстрее.
[02:45.360 --> 02:50.680]  Дикризки точно быстрее, потому что раньше мы умели только с помощью сифтапа это делать,
[02:50.680 --> 02:55.640]  что в бинарный, что в биномиальный. Для дикриза мне нужно было от вершинки дойти вверх до корня,
[02:55.640 --> 03:00.720]  возможно, в худшем случае, все их там просвопать. Ну а фибоначи умеют за единицу в среднем,
[03:00.720 --> 03:13.480]  точнее учетно, амортизированно. Так, хорошо, ну давайте приступим. Во многом структура будет
[03:13.480 --> 03:18.800]  похожа на биномиальное дерево, на биномиальную кучу. Также у нас куча будет представляться набором
[03:18.800 --> 03:30.480]  нескольких деревьев. Куча — это набор деревьев. Ну как обычно, деревья будут удовлетворять
[03:30.480 --> 03:34.640]  требованию кучи, чтобы корень всегда лежал в корне, пардон, минимум всегда лежал в корне,
[03:34.640 --> 03:41.720]  что-то я загораю сегодня. Минимум дерева всегда лежит в корне, ну и корни всех деревьев соединены
[03:41.720 --> 03:58.680]  в список двусвязной. На корне деревьев. Деревьев в двусвязном списке. Вот, дальше давайте я скажу,
[03:58.680 --> 04:07.960]  что рангом вершины я буду называть количество ее детей. Ранг вершины — это количество ее детей.
[04:07.960 --> 04:17.680]  Ну, например, в биномиальной куче ровно это под рангом и подразумевалось. Если вспомнить,
[04:17.680 --> 04:23.480]  что такое биномиальное дерево ранга K, то это вершина, которой сначала подвешено дерево ранга
[04:23.480 --> 04:28.080]  0, потом 1, потом 2, потом 3 и так далее, вплоть до K-1. Мы доказывали, что биномиальное дерево
[04:28.080 --> 04:32.600]  ровно такую структуру имеет, значит, если ранг K, то ровно K детей. У нас так это и было
[04:32.600 --> 04:37.240]  для биномиальных деревьев, вот мы это сейчас сохраняем. Только теперь у меня деревья уже будут
[04:37.240 --> 04:41.360]  совсем не обязательно биномиальные, потому что биномиальные деревья — они обязательно фиксированы
[04:41.360 --> 04:46.360]  структуры. Вот там я описывал, что чтобы получить дерево ранга K-1, нужно взять два
[04:46.360 --> 04:51.000]  дерева меньшего ранга, фиксированные структуры, их объединить тоже фиксированным образом,
[04:51.000 --> 04:57.120]  что меньше к большему, наоборот, больший ключ к меньшему, больший корень к меньшему подвесить,
[04:57.120 --> 05:01.960]  получится биномиальное дерево следующего ранга. А здесь мы хотим избавиться от того,
[05:01.960 --> 05:07.360]  что у нас такая жесткая структура деревьев, мы позволим себе, чтобы они были довольно
[05:07.360 --> 05:14.800]  разнообразны, что у них структура всякая разная может быть. Так, ну хорошо, ранг вершины
[05:14.800 --> 05:19.680]  количества детей, давайте в каждой вершине будем хранить это количество детей. Как у меня будет
[05:19.680 --> 05:27.320]  характеризоваться вершина? Мне у вершины нужно знать, давайте я проговорю все, что мне нужно знать
[05:27.320 --> 05:35.040]  для вершины. Это, во-первых, указатель на родителя, если это не корневая вершина дерева, то мне
[05:35.040 --> 05:41.440]  нужна ссылка на родителя, указатель на родителя, кто является вот предком этой вершины. А дальше
[05:41.440 --> 05:48.680]  вот вершина может быть много детей, ну а так же, как и в биномиальной куче, может быть много детей. Но давайте
[05:48.680 --> 05:55.440]  я буду хранить всех детей в виде списка, я не буду их хранить как массив или там как вектор указателей
[05:55.440 --> 06:06.720]  на детей, а скорее я все их свяжу списком двусвязным и буду из этой вершины хранить на указатель
[06:06.720 --> 06:15.200]  самый левый, самый правый. Давайте пунктируем, указатель на самого левого сына и указатель на
[06:15.200 --> 06:22.080]  самого правого сына. Соответственно, если эта вершина также не является корнем, если у нее есть
[06:22.080 --> 06:27.480]  родитель, то у нее определенная ссылка на левого брата и на правого брата. То есть теперь у меня
[06:27.480 --> 06:31.640]  вот вершины, являющиеся детьми одной и той же вершины, то есть на самом деле у меня вот такие есть
[06:31.640 --> 06:37.600]  ребра в моем дереве, но я эти ребра, ну я не создаю таких связей, я не говорю, что это ссылается сюда,
[06:37.600 --> 06:43.320]  сюда, сюда, сюда, сюда, я говорю, что она просто ссылается на самый левый, самую правую. Чем мне это
[06:43.320 --> 06:49.040]  может быть полезно, например? Например, тем, что я умею теперь удалять заод единицы, если мне
[06:49.040 --> 06:54.440]  нужно, я вот эту вот вершину могу отсюда вырезать заод единицы, потому что из списка мы удалять
[06:54.440 --> 07:00.600]  умеем. Если мы знаем эту вершину, мы знаем соседа справа, соседа слева, эту высекаем, вырезаем отсюда,
[07:00.600 --> 07:05.520]  ну и здесь стрелочки перенаправляем. Поскольку удалять из списка я умею за единицу, то вот
[07:05.520 --> 07:13.200]  мне такая конструкция, такая реализация вершины мне позволит ровно это делать. Удалять из списка,
[07:13.200 --> 07:22.680]  из произвольного места списка за единицу. Ну вот, у нее есть какие-то дети, я их вырежу,
[07:22.680 --> 07:29.000]  то есть вот эта вершина является корнем какого-то поддерева. Что я буду на самом деле делать,
[07:29.000 --> 07:34.480]  это я буду выносить вот это поддерево в список корней, обрубаю все связи, то есть я вот это
[07:34.480 --> 07:39.200]  полностью вырезаю и переношу все это дерево вот сюда в список корней. Ну и здесь, раз у меня были
[07:39.200 --> 07:44.160]  ссылки на левый и на правого детей, они у меня здесь сохраняются. То есть я все что сделаю,
[07:44.160 --> 07:49.960]  это высек полностью поддерева этой вершины из большого списка. Ну примерно что-то такое я
[07:49.960 --> 07:58.280]  буду делать. Так, еще давайте пропишем, что мне нужно будет хранить int deg, это степень, она же
[07:58.280 --> 08:14.920]  ранг вершины. И еще я ввожу буллевский флаг, ну я его называю mark. Это буллевский флаг,
[08:14.920 --> 08:24.360]  правда ли, что у вершины высекался хотя бы один из детей? То есть это просто 0 или 1, true или false.
[08:24.360 --> 08:38.720]  Правда ли, что у вершины вырезался один из сыновей? Давайте.
[08:38.720 --> 09:00.320]  Это неверное утверждение. Ну окей, встроенные вы имеете в виду какие-то? Ну не знаю, не эксперт,
[09:00.320 --> 09:08.040]  но по умолчанию в списке нет операции найти размер. Ну в конце концов почему бы не хранить,
[09:08.040 --> 09:13.080]  ну если она и так есть, ну ничего страшного, мы не проиграем, если будем хранить в любом случае.
[09:13.080 --> 09:25.200]  Корни в списке и множество детей каждой вершины тоже в двухвязанном списке, чтобы я мог удалять
[09:25.200 --> 09:31.880]  любого сына. Ну чуть позже поймем, когда начнем удалять, мы поймем зачем это нужно. Значит еще раз,
[09:31.880 --> 09:37.160]  у вершины я храню количество детей и флаг того, удалялся ли у нее хоть кто-то. То есть вот теперь,
[09:37.360 --> 09:43.200]  если я разрешаю себе вырезать каких-то детей и выносить их в список корней, то, возможно,
[09:43.200 --> 09:47.720]  мне придется как-то помечать. Я когда вот это выношу, вот это вот по дереву буду вырезать в список
[09:47.720 --> 09:52.760]  корней и выносить, я у этой вершинки буду помечать марк и буду помечать ее звездочкой, чтобы
[09:52.760 --> 09:58.800]  отображать, что на ней лежит марк, я говорю, что в ней звездочка стоит. Ну давайте теперь попробуем
[09:58.800 --> 10:09.560]  какие-то операции реализовать. Ну как сделать инсерт, например, икса за единицу. Ну так же,
[10:09.560 --> 10:14.800]  как в биноменальной куче, только не будем запускать процедуру мерч. Да, давайте просто,
[10:14.800 --> 10:21.600]  вот у меня есть список корней деревьев, вот как-то там они друг на друга ссылаются, мне нужно добавить
[10:21.600 --> 10:27.000]  икс. Давайте я создам новое тривиальное дерево, состоящее только из этого икса. Ну и вот так вот
[10:27.000 --> 10:31.840]  прокину ссылочку, что предыдущий последний корень ссылается на этот икс, ну и он обратно
[10:31.840 --> 10:36.320]  на него ссылается. Если список высвязан, то мне нужно две стрелки прокинуть. Ну тривиально,
[10:36.320 --> 10:44.280]  завожу новое дерево, то есть это новое дерево, и просто забрасываю в конец списка, надо добавлять
[10:44.280 --> 10:55.800]  в конец списка, мы умеем. Вот, честная единица. Так, get mean. Записываем в конец список корней,
[10:55.800 --> 11:05.840]  да, корней. Вот у меня есть список корней, к нему в конец я добавляю новое дерево. Отлично, на самом
[11:05.840 --> 11:11.040]  деле так и будет, и это нормально. Если мы просто сделаем много раз инсерт, у меня все вытянется в
[11:11.040 --> 11:16.360]  одну большую цепочку, но потом, когда мне захочется, я начну это причёсывать, и у меня структура станет
[11:16.360 --> 11:20.160]  покрасивее. Но в худшем случае, да, она может спокойно выражаться в цепочку. Если много инсертов
[11:20.160 --> 11:27.160]  сделали, то так и будет, и нам это пока нормально. Значит, get mean. Ну, с get mean мы тоже прорабатывали,
[11:27.160 --> 11:31.400]  что если просто хранить указатель на минимальный корень, то за единицу мы сможем находить ответ.
[11:31.400 --> 11:47.760]  А тоже за единицу, если хранить указатель на минимальный корень. Вот. Хорошо, давайте теперь
[11:47.760 --> 11:53.760]  зафиксируем себе, что нужно не только выполнить операцию, но и сохранить вот этот указатель. То
[11:53.760 --> 11:57.440]  есть у меня помимо всех этих деревьев есть еще один конкретный указатель, показывающий в один
[11:57.440 --> 12:01.680]  из корней, да, в минимальный корень. Поэтому дальше во всех операциях, которые я буду делать,
[12:01.680 --> 12:06.760]  нужно не забывать этот указатель всегда обновлять. В частности, вот здесь надо вернуться и понять,
[12:06.760 --> 12:12.960]  как здесь меняется указатель на минимум. Тут, благо, несложно. Если мы знали, где вот здесь находился
[12:12.960 --> 12:19.720]  минимум, скажем, где-то вот здесь, я добавляю новое дерево, как понять, где минимум. Ну понятно,
[12:19.720 --> 12:23.840]  либо здесь, либо здесь. Надо просто два числа сравнить, если нужно указатель перенаправить.
[12:23.840 --> 12:30.680]  Если х меньше, чем это, то нужно указатель перенаправить. Понятно? Вот. Хорошо. Ну тем не менее,
[12:30.680 --> 12:35.960]  вот за указателем теперь будем следить. Так, что дальше? Merge тоже за единицу очень просто
[12:35.960 --> 12:53.400]  реализуется. Давайте. Где лежит минимальный элемент дерева? Ну вот есть дерево,
[12:53.400 --> 13:00.680]  где его минимальный элемент? Всегда в корне, потому что требование куча. Значит,
[13:00.680 --> 13:10.960]  достаточно среди корней выбирать минимум. Так, как сделать Merge за единицу? Ну не дерево,
[13:10.960 --> 13:15.920]  а два списка слить. Ну вот представьте, у меня есть одна куча, в которой есть такой-то список
[13:15.920 --> 13:21.080]  деревьев, другая куча, в которой такой-то список деревьев. В конец одной добавляем,
[13:21.120 --> 13:25.280]  начало другое. Все правильно. Мы берём конец первого списка, прокидываем ссылочку на
[13:25.280 --> 13:29.360]  начало второго, и отсюда прокидываем ссылочку на connection до конца первого. Ну из-за одной
[13:29.360 --> 13:33.400]  не забываем пересчитать указатель на начало и на конец. Об единение списков тоже работает за
[13:33.400 --> 13:39.140]  единицу. Просто начало первого соединяем с концу второго. И этот указатель на минимум
[13:39.140 --> 13:43.420]  тоже тривиально подсчитывается. Если мы знали указатель на минимум здесь и указатель на
[13:43.420 --> 13:49.040]  минимум здесь, то нужно взять кто из них меньше, и переставить один общий указатель,
[13:49.040 --> 13:52.360]  указатель, что в этой объединенной куче у меня минимум либо
[13:52.360 --> 13:53.600]  здесь, либо здесь.
[13:53.600 --> 13:55.720]  Опять-таки сравниваю, кто из корней меньше, и перенаправляю
[13:55.720 --> 13:56.720]  указатель.
[13:56.720 --> 14:01.640]  Так, хорошо.
[14:01.640 --> 14:05.200]  Давайте с экстрактом посмотрим, что происходит.
[14:05.200 --> 14:12.960]  Мне нужно найти минимальное число и удалить его из кучи.
[14:12.960 --> 14:15.000]  Но первый шаг уже есть, у меня всегда хранится указатель
[14:15.000 --> 14:16.000]  на минимум.
[14:16.000 --> 14:22.720]  Например, вот здесь вот минимальный элемент.
[14:22.720 --> 14:25.960]  Поступим так же, как в биномиальной куче.
[14:25.960 --> 14:30.840]  Давайте мы всех детей вот этого корня вырежем, склеим
[14:30.840 --> 14:33.760]  в одну новую кучу и объединим две кучи.
[14:33.760 --> 14:40.240]  Значит, вот давайте, у меня здесь были какие-то поддеревья,
[14:40.240 --> 14:42.040]  там первое, второе, третье.
[14:42.040 --> 14:45.560]  Вот здесь много всяких поддеревьев, ну точнее, детей корня.
[14:45.560 --> 14:48.160]  Вот такое дерево у меня здесь было.
[14:48.160 --> 14:49.160]  Давайте я их все вырежу.
[14:49.160 --> 14:54.560]  Поскольку они у меня и так уже прошиты в список двусвязный,
[14:54.560 --> 14:58.200]  вот здесь они друг на друга ссылают в том порядке, в котором
[14:58.200 --> 14:59.200]  они идут здесь.
[14:59.200 --> 15:01.680]  То есть здесь есть и так уже список, я этот список
[15:01.680 --> 15:04.600]  объявляю списком для новой кучи, говорю, что вот это
[15:04.600 --> 15:07.960]  вот куча номер два, а вот все, что здесь осталось,
[15:07.960 --> 15:08.960]  это куча номер один.
[15:08.960 --> 15:11.680]  Но надо не забыть еще вот здесь вот указатель перепрокинуть,
[15:11.800 --> 15:16.680]  чтобы соседние от минимального корня друг на друга ссылались.
[15:16.680 --> 15:20.680]  То есть я буквально удаляю этот элемент из списка,
[15:20.680 --> 15:24.440]  получается список деревьев всех, кроме этого, и новый
[15:24.440 --> 15:27.040]  список – это список всех детей удаляемой вершины.
[15:27.040 --> 15:32.040]  Есть два списка, и дальше я их мержу, мердж списков.
[15:32.040 --> 15:33.040]  Согласны?
[15:33.040 --> 15:34.040]  Да.
[15:34.040 --> 15:39.760]  Они указатели на первый корень или на последний корень?
[15:39.840 --> 15:42.280]  Ну конечно, в списке мы обязаны, если у меня есть структура
[15:42.280 --> 15:44.360]  данных список, у меня есть указатель на начало, на
[15:44.360 --> 15:45.360]  конец.
[15:45.360 --> 15:46.360]  Это всегда есть, да.
[15:46.360 --> 15:49.360]  Получается, минимум на 1.
[15:49.360 --> 15:50.360]  Вот.
[15:50.360 --> 15:51.360]  Да, отлично.
[15:51.360 --> 15:54.280]  Если бы я на этом закончил, у меня бы это работало за
[15:54.280 --> 15:59.120]  1, потому что, ну что я сделал, у меня это и так уже в списке,
[15:59.120 --> 16:02.360]  это все в списке, я удалил за 1, склеил два списка за
[16:02.360 --> 16:06.400]  1, но мне нужно хранить указатель, иначе у меня гитмин не за
[16:06.400 --> 16:07.400]  1 будет работать.
[16:07.640 --> 16:10.720]  И вот теперь-то я начну заниматься тем, чтобы мою
[16:10.720 --> 16:13.440]  кучу как-то привести в нормальный вид, потому что пока что
[16:13.440 --> 16:15.840]  в худшем случае это был просто список из элементов,
[16:15.840 --> 16:17.680]  по одному элементу в дереве.
[16:17.680 --> 16:21.520]  И вот здесь, поскольку мне нужно обновить указатель
[16:21.520 --> 16:24.600]  на минимум, мне очень и очень, ну по крайней мере, по этим
[16:24.600 --> 16:27.400]  вершинам всем придется пройти, потому что я не знаю, где
[16:27.400 --> 16:29.440]  минимум, возможно где-то здесь, или где-то здесь,
[16:29.440 --> 16:30.440]  мне придется сейчас по ним проходить.
[16:30.440 --> 16:34.840]  И вот давайте в этот момент я вызову процедуру, которая
[16:34.840 --> 16:37.360]  кажется классичкой, называется consolidate, но это неважно.
[16:37.360 --> 16:41.640]  Это, собственно, причёсывание кучи.
[16:41.640 --> 16:44.000]  Вот теперь, когда я объединил список всех этих деревьев
[16:44.000 --> 16:46.320]  в один большой список, в одну большую кучу, вот теперь
[16:46.320 --> 16:49.080]  давайте я его сначала причешу, ну а потом и указатель на
[16:49.080 --> 16:50.080]  минимум тоже найду.
[16:50.080 --> 16:52.600]  Да, это значит, причёсывание кучи.
[16:58.600 --> 17:00.000]  Вот, то есть, давайте.
[17:00.160 --> 17:03.360]  Причём нам причёсывать кучу, мы же когда мержим, пока
[17:03.360 --> 17:06.360]  мы мержим, можем обновлять этот указатель.
[17:06.360 --> 17:09.600]  Нет, смотрите, мерж мы делаем за единицу, в мерже мне нужно
[17:09.600 --> 17:13.040]  указатель на начало здесь, на конец здесь и на конец
[17:13.040 --> 17:16.360]  здесь, я просто это подвешиваю сюда и объявляю это концом,
[17:16.360 --> 17:17.360]  это всё за единицу работает.
[17:17.360 --> 17:20.520]  В мерже я не прохожу всех этих вершин и всех вот этих
[17:20.520 --> 17:23.200]  корней, поэтому я не узнаю указатель на минимум, а
[17:23.200 --> 17:24.200]  мне нужно его хранить.
[17:24.200 --> 17:28.400]  А я его здесь не прохожу, мерж не проходит по всем
[17:28.800 --> 17:30.480]  корням, а мне в каком-то смысле нужно это сделать.
[17:30.480 --> 17:32.960]  Поэтому, чтобы найти указатель на минимум, я вызываю процедуру
[17:32.960 --> 17:33.960]  причёсывания.
[17:33.960 --> 17:35.400]  Значит, как это работает?
[17:35.400 --> 17:38.920]  Работает по существу так же, как мерж биномиальный.
[17:38.920 --> 17:46.440]  Я буду склеивать деревья одинакового ранга в одно
[17:46.440 --> 17:48.040]  дерево ранга на один побольше.
[17:48.040 --> 17:53.760]  Если у меня есть два дерева ранга К, то я сравниваю значение
[17:53.840 --> 17:59.360]  их корней и к тому дереву, в котором значение в корне
[17:59.360 --> 18:01.440]  меньше, подвешиваю другое.
[18:01.440 --> 18:04.080]  Ну, так же, как было в биномиальной куче.
[18:04.080 --> 18:07.200]  Если есть два дерева одинакового ранга, в данном случае рангом,
[18:07.200 --> 18:09.920]  напоминаю, является степень вершины, а не то, что было
[18:09.920 --> 18:10.920]  раньше.
[18:10.920 --> 18:11.920]  Вот если есть два дерева одинакового ранга, я их
[18:11.920 --> 18:14.080]  сливаю в одно большое дерево, соответственно, ранга уже
[18:14.080 --> 18:15.080]  К плюс один.
[18:15.080 --> 18:18.080]  Потому что если у этого был ранг К, то при подвешивании
[18:18.080 --> 18:19.880]  новой получается здесь ранг К плюс один.
[18:19.880 --> 18:21.880]  Увеличивает число детей, поэтому ранг увеличивается.
[18:22.880 --> 18:24.480]  Ну, поэтому давайте сделаем следующее.
[18:24.480 --> 18:30.480]  Ранг корня, да, да, да.
[18:39.480 --> 18:42.480]  Так, значит, консолидейт.
[18:46.480 --> 18:48.200]  Смотри, давайте веду такое обозначение.
[18:48.520 --> 18:53.520]  Пусть d большое от n, это максимально возможный ранг
[19:00.520 --> 19:03.520]  в куче на n элементах.
[19:06.520 --> 19:07.520]  Вот.
[19:07.520 --> 19:10.000]  Значит, позднее мы поймем, почему это не очень большая
[19:10.000 --> 19:11.000]  величина.
[19:11.000 --> 19:13.520]  Позднее мы докажем, что d на самом деле это от логарифма.
[19:13.840 --> 19:20.840]  Вот, пока давайте просто вот zd обозначим максимально
[19:20.840 --> 19:24.840]  возможную степень корня какого-либо дерева в кучу.
[19:24.840 --> 19:26.840]  Да, то есть максимально возможный ранг.
[19:26.840 --> 19:27.840]  Вот.
[19:27.840 --> 19:28.840]  Тогда как работает консолидейт?
[19:28.840 --> 19:38.840]  Значит, мы заводим массив вот такой, где будем хранить,
[19:38.840 --> 19:40.840]  каких рангов у меня уже есть куча.
[19:40.840 --> 19:42.840]  Ну, давайте пример какой-нибудь сделаю.
[19:43.160 --> 19:46.160]  Вот представьте, что у меня было какое-нибудь такое
[19:46.160 --> 19:47.160]  дерево.
[19:47.160 --> 19:49.160]  Так, давайте я что-нибудь нарисую.
[19:49.160 --> 19:53.360]  Это было дерево ранга 0, затем дерево ранга 1, дерево
[19:53.360 --> 19:59.360]  ранга 0, дерево ранга 3, дерево ранга 1, дерево ранга 2.
[19:59.360 --> 20:01.360]  Вот представьте, что у меня был такой список корней.
[20:01.360 --> 20:04.360]  Здесь указаны ранги, корней.
[20:04.360 --> 20:08.840]  Давайте по этому списку пройдем и будем их сохранять
[20:08.840 --> 20:11.360]  вот в этом массиве размера d от n.
[20:11.880 --> 20:13.880]  Ну, например, вижу дерево ранга 0.
[20:13.880 --> 20:15.880]  Давайте я как-нибудь назову a.
[20:15.880 --> 20:17.880]  Смотрю в мой списочек.
[20:17.880 --> 20:19.880]  Давайте я его как-нибудь в общем список.
[20:19.880 --> 20:21.880]  Занумирую его.
[20:21.880 --> 20:23.880]  И так далее.
[20:23.880 --> 20:26.880]  У меня пока что в списке не дерево ранга 0.
[20:26.880 --> 20:28.880]  Если бы оно было, мне бы пришлось их объединять.
[20:28.880 --> 20:31.880]  Но пока что их нет, я просто сюда кладу дерево a.
[20:31.880 --> 20:33.880]  Дальше вижу дерево ранга 1.
[20:33.880 --> 20:36.880]  Окей, у меня дерево ранга 1 пока что еще не было,
[20:36.880 --> 20:38.880]  я его записываю в мой списочек.
[20:38.880 --> 20:40.880]  Дальше вижу дерево ранга 0.
[20:40.880 --> 20:44.880]  у меня в массиве сохранена ссылка на вот это вот дерево А.
[20:44.880 --> 20:48.880]  То есть я не все дерево копирую, а только указатель на корень,
[20:48.880 --> 20:50.880]  чтобы понимать, откуда это дерево начинается.
[20:50.880 --> 20:53.880]  Теперь вижу, пришло дерево того же ранга, что уже было.
[20:53.880 --> 20:55.880]  Значит, мне их нужно склеить.
[20:55.880 --> 20:58.880]  Но я знаю, где оно было. Что это за дерево? Это дерево А.
[20:58.880 --> 21:02.880]  Теперь я сравниваю, у кого у А или у С корень меньше,
[21:02.880 --> 21:05.880]  назначение в корне меньше, и подвешиваю правильным образом.
[21:05.880 --> 21:07.880]  То есть у меня было дерево А какое-то вот такое,
[21:07.880 --> 21:09.880]  дерево Б какое-то вот такое,
[21:09.880 --> 21:11.880]  но раз у них ранг 0, то детей у них нет.
[21:11.880 --> 21:15.880]  Я просто сравню в них значения и провожу такое ребро.
[21:15.880 --> 21:20.880]  Что это значит? Это значит, что я в список детей А добавляю справа С.
[21:20.880 --> 21:23.880]  Надо добавить список, я умею.
[21:23.880 --> 21:25.880]  Ну и становится дерево ранга 1.
[21:25.880 --> 21:30.880]  Отсюда оно стирается, и вот здесь вот я как бы сюда еще хочу добавить дерево,
[21:30.880 --> 21:33.880]  вот это вот новое А в объединение с С.
[21:33.880 --> 21:35.880]  Но дерево ранга 1 у меня уже опять есть,
[21:35.880 --> 21:37.880]  поэтому мне их придется склеить.
[21:37.880 --> 21:39.880]  Мне нельзя иметь деревья одинаковых рангов.
[21:39.880 --> 21:43.880]  Мне нужно теперь склеить вот это вот и Б.
[21:43.880 --> 21:47.880]  Ну я умею склеивать деревья, я смотрю на корень здесь и на корень здесь,
[21:47.880 --> 21:49.880]  смотрю кто из них меньше.
[21:49.880 --> 21:52.880]  И склеиваю в правильном порядке.
[21:52.880 --> 21:54.880]  У меня было одно дерево, у меня было другое дерево.
[21:54.880 --> 21:58.880]  Я смотрю где корень меньше, например вот здесь вот в Б-шке был корень меньше,
[21:58.880 --> 22:00.880]  провожу такое ребро.
[22:00.880 --> 22:02.880]  Ну опять же провести ребро значит добавить элемент в список,
[22:02.880 --> 22:06.880]  добавить вот эту вершину в список детей этой вершины.
[22:06.880 --> 22:08.980]  Дерево Ранга 2.
[22:08.980 --> 22:12.900]  Здесь я указательность 제�еляю, и говорю, что все это не одно большое,
[22:12.900 --> 22:13.960]  Дерево Ранга 2.
[22:13.960 --> 22:16.200]  На него я ссылаюсь.
[22:16.200 --> 22:17.980]  Это Дерево Ранга 2.
[22:17.980 --> 22:19.340]  Иду дальше по сп Goku.
[22:19.340 --> 22:22.240]  Я объединил Дерево Ранга 2, не было и его сюда записал.
[22:22.240 --> 22:24.220]  Иду дальше, вижу Дерево Ранга 3.
[22:24.220 --> 22:27.420]  Его не было, провожу указательный на него.
[22:27.420 --> 22:31.760]  Дерево Ранга 1 у нас сейчас не в списке, в массиве у нас錯.
[22:31.760 --> 22:33.640]  Я провожу указательный на него.
[22:33.640 --> 22:35.780]  Теперь двойка пришла.
[22:35.780 --> 22:39.780]  Но объединяю вот эту двойку с той, которая у меня в памяти лежит.
[22:39.780 --> 22:43.780]  Опять есть одно дерево, есть другое. Я знаю, к чему надо подвесить.
[22:43.780 --> 22:47.780]  Они превращаются в дерево ранга 3. Но поскольку тройка у меня уже опять есть,
[22:47.780 --> 22:52.780]  у меня есть два дерева одинакового ранга, я их склеиваю и получаю дерево ранга 4.
[22:52.780 --> 22:58.780]  Конец. На этом мы прошли весь список и добились того, что в массиве вот этих вот чисел,
[22:58.780 --> 23:03.780]  точнее массиве этих указателей, нет двух деревьев одинакового ранга.
[23:03.780 --> 23:13.780]  Понятно? Ну отлично. И сделали мы это за количество корней плюс детен.
[23:13.780 --> 23:26.780]  Давайте напишем, что время работы это количество корней плюс детен.
[23:26.780 --> 23:30.780]  Количество корней, потому что я прохожусь по всему этому списку,
[23:30.780 --> 23:32.780]  и возможно еще какие-то из них объединяю.
[23:32.780 --> 23:36.780]  Суммарное количество объединений, понятно, будет не больше, чем количество корней в этом списке,
[23:36.780 --> 23:39.780]  потому что каждое объединение уменьшает количество корней на один.
[23:39.780 --> 23:45.780]  Значит, объединений будет максимум столько, сколько корней, ну и плюс дн для того, чтобы этот массив создать.
[23:45.780 --> 23:51.780]  Напоминаю, д это какая-то верхняя граница на ранг дерева в куче с n элементами,
[23:51.780 --> 23:56.780]  и значит мне в этом массиве нет смысла рассматривать ячейки с номерами больше, чем d от n.
[23:56.780 --> 24:03.780]  У меня просто ни при каких обстоятельствах, то есть d это такая граница какая-то вселенская от n зависящая,
[24:03.780 --> 24:07.780]  что если у меня в куче всего n элементов, то мне не нужны ячейки с номерами больше, чем d.
[24:07.780 --> 24:10.780]  Поэтому мне достаточно только такого массива.
[24:10.780 --> 24:17.780]  Извините, мы когда мы идем по списку корней, мы строим датплот.
[24:17.780 --> 24:18.780]  Да.
[24:18.780 --> 24:24.780]  А если мы встретили в какой-то момент вершину, которая меньше остается?
[24:24.780 --> 24:26.780]  Ну, как вот здесь было, смотрите, здесь все было нормально.
[24:26.780 --> 24:31.780]  Вот, например, в этот момент у меня была здесь тройка, потом я видел единицу, ничего страшного,
[24:31.780 --> 24:33.780]  просто я сохраняю на нее указатель.
[24:33.780 --> 24:36.780]  Но потом мы должны будем снова идти и мерчить.
[24:36.780 --> 24:39.780]  Но если будет еще единица, то я их, конечно, склеиваю, да.
[24:39.780 --> 24:43.780]  Массив как раз тем и хорош, что он поддерживает указатели на те деревья,
[24:43.780 --> 24:45.780]  рамки которых у вас есть.
[24:45.780 --> 24:47.780]  Ну, там просто какие-то рамки есть.
[24:47.780 --> 24:50.780]  Если пришло новое число, и его рамка не было, то вы просто вставляете,
[24:50.780 --> 24:53.780]  а если не было, то объединяете до тех пор, пока все коллизии не разрешатся.
[24:53.780 --> 24:57.780]  Например, если бы вот у вас сейчас, смотрите, у вас есть 3 и есть 4.
[24:57.780 --> 25:01.780]  Да, я просто думаю, что это не линия, то есть мы делаем какие-то повторения.
[25:01.780 --> 25:05.780]  Да, да, то есть каждый конкретный корень обрабатывается за несколько операций.
[25:05.780 --> 25:08.780]  Но суммарно это работает за столько, сколько всего было объединений,
[25:08.780 --> 25:11.780]  а всего объединений не больше, чем количество корней.
[25:11.780 --> 25:13.780]  Значит, время работы по-прежнему такое.
[25:13.780 --> 25:14.780]  Супер.
[25:14.780 --> 25:18.780]  Какой будет рамк дерева, выучившийся в результате заменения
[25:18.780 --> 25:20.780]  был деревьев с одним и тем же рамкой?
[25:20.780 --> 25:22.780]  На один побольше.
[25:22.780 --> 25:25.780]  Потому что вот картинка, смотрите, если у вас было дерево рамка K
[25:25.780 --> 25:27.780]  и дерево рамка K, что такое рамк?
[25:27.780 --> 25:29.780]  Вспоминаете, это количество детей у корня.
[25:29.780 --> 25:32.780]  Но если здесь было K детей, вы подвесили к нему одного нового,
[25:32.780 --> 25:34.780]  стал очевидно рамк K плюс 1.
[25:34.780 --> 25:36.780]  Поэтому когда два дерева одного рамка сливаются,
[25:36.780 --> 25:38.780]  и вы только одного рамка деревя сливаете,
[25:38.780 --> 25:40.780]  то получается дерево рамка донит побольше.
[25:42.780 --> 25:43.780]  Так, ну хорошо.
[25:43.780 --> 25:45.780]  Значит, смотрите, мы консолидейт сделали,
[25:45.780 --> 25:47.780]  мы причесали нашу кучу, добились того,
[25:47.780 --> 25:49.780]  что все рамки попарно различны.
[25:49.780 --> 25:51.780]  И заодно, смотрите, мы по всем корням прошлись.
[25:51.780 --> 25:54.780]  Мы прошлись по вообще всем корням в нашем списке корней.
[25:54.780 --> 25:58.780]  Значит, в частности, указательный минимальный корень
[25:58.780 --> 26:00.780]  уж как-нибудь мы сделаем.
[26:00.780 --> 26:02.780]  Мы когда вот это вот все объединяем,
[26:02.780 --> 26:04.780]  мы, конечно же, мы можем просто знать,
[26:04.780 --> 26:06.780]  какой из этих корней минимальный.
[26:06.780 --> 26:08.780]  Мы так или иначе по ним по всем проходимся.
[26:08.780 --> 26:10.780]  Если увидим корень, значение которого меньше,
[26:10.780 --> 26:12.780]  чем все, что мы видели раньше,
[26:12.780 --> 26:14.780]  то на него вводим указатель.
[26:14.780 --> 26:16.780]  Ну и так, в общем, по всем пройдя, мы знаем минимум.
[26:16.780 --> 26:20.780]  Просто минимум в массиве за линейное время от его размера.
[26:21.780 --> 26:23.780]  Так, хорошо.
[26:27.780 --> 26:29.780]  Ну, теперь переходим к дикриске.
[26:29.780 --> 26:33.780]  Собственно, то, где самая сложность основная и зарыта.
[26:35.780 --> 26:37.780]  Так, давайте вернемся к маркам.
[26:37.780 --> 26:41.780]  Напоминаю, в вершине у меня есть ранг и марк.
[26:41.780 --> 26:43.780]  Буллевский флаг удалялся ли у нее кто-то из детей.
[26:43.780 --> 26:45.780]  Пока что мы этим не пользовались.
[26:45.780 --> 26:48.780]  Пока что мы вообще детей пока что нигде не удаляли.
[26:48.780 --> 26:49.780]  Мы только сливали.
[26:49.780 --> 26:51.780]  Пока что все, что мы делали с деревьями,
[26:51.780 --> 26:54.780]  это подвешиваем дерево одного ранга к дереву того же ранга.
[26:54.780 --> 26:56.780]  Ка-ка.
[26:56.780 --> 26:57.780]  Окей.
[26:57.780 --> 27:01.780]  Давайте договоримся, что будет у меня с марками происходить.
[27:01.780 --> 27:06.780]  Первое, что я говорю, это у корней деревьев.
[27:06.780 --> 27:08.780]  Деревьев.
[27:08.780 --> 27:10.780]  Деревьев.
[27:10.780 --> 27:12.780]  Марк всегда false.
[27:14.780 --> 27:17.780]  То есть у корня можно вырезать сколько угодно детей.
[27:17.780 --> 27:21.780]  И мы не заботимся о том, сколько детей у корня вырезано.
[27:21.780 --> 27:23.780]  То есть мы их можем спокойно удалять.
[27:23.780 --> 27:25.780]  Мы эту марку для корня не обновляем.
[27:25.780 --> 27:27.780]  То есть даже если у вас была вот такая картинка,
[27:27.780 --> 27:30.780]  здесь было много каких-то детей под деревьев.
[27:30.780 --> 27:33.780]  И вы там скажем сначала первый из них вырезали,
[27:33.780 --> 27:35.780]  перенесли список корней второго вырезали,
[27:35.780 --> 27:36.780]  третьего вырезали.
[27:36.780 --> 27:38.780]  Все равно марк здесь будет false.
[27:38.780 --> 27:40.780]  В корне всегда марк false.
[27:40.780 --> 27:43.780]  Ну а второй, соответственно, напоминаю,
[27:43.780 --> 27:46.780]  как вообще выставляется марк равно true.
[27:46.780 --> 27:52.780]  Выставляем марк равно true.
[27:53.780 --> 27:59.780]  В случае, если вершина это не корень,
[27:59.780 --> 28:02.780]  и у нее вырезается какой-то из детей.
[28:02.780 --> 28:06.780]  Не корень.
[28:06.780 --> 28:14.780]  У нее вырезается один из детей.
[28:23.780 --> 28:25.780]  Так, ну и все.
[28:25.780 --> 28:30.780]  Теперь, значит, как мы будем делать дикриски тогда?
[28:30.780 --> 28:37.780]  Как делать дикриски?
[28:37.780 --> 28:39.780]  Значит, да.
[28:39.780 --> 28:43.780]  Деревни в корне тоже есть везде.
[28:43.780 --> 28:44.780]  Конечно.
[28:44.780 --> 28:46.780]  Почему у нас марк всегда на false,
[28:46.780 --> 28:47.780]  если марки выключаются?
[28:47.780 --> 28:49.780]  Ну вот для корней по-особенному работают.
[28:49.780 --> 28:51.780]  Для корней я специально отдельным пунктом выношу.
[28:51.780 --> 28:53.780]  У корней марк всегда false,
[28:53.780 --> 28:55.780]  а у остальных вершин марк это что-то содержательное.
[28:55.780 --> 28:56.780]  Марк это указатель того,
[28:56.780 --> 28:58.780]  удаляли ли сыновей у вершины.
[28:58.780 --> 29:01.780]  Но для корней мы эти марки не помечаем.
[29:01.780 --> 29:04.780]  Вот в корнях всегда false.
[29:04.780 --> 29:06.780]  Итак, значит, как работают дикриски?
[29:06.780 --> 29:09.780]  Напоминаю, что в дикриски мы подразумеваем,
[29:09.780 --> 29:11.780]  что нам дается указатель на ту вершину,
[29:11.780 --> 29:12.780]  которую надо уменьшить,
[29:12.780 --> 29:14.780]  на то значение, которое надо сделать поменьше.
[29:14.780 --> 29:15.780]  То есть вот представьте,
[29:15.780 --> 29:17.780]  было какое-то большое дерево.
[29:17.780 --> 29:19.780]  Меня тыкнули носом в какой-то элемент,
[29:19.780 --> 29:21.780]  сказали, сделай его поменьше.
[29:21.780 --> 29:23.780]  Ну и проблема может быть в том,
[29:23.780 --> 29:26.780]  что, возможно, нарушилось неравенство с отцом,
[29:26.780 --> 29:27.780]  с родителем.
[29:27.780 --> 29:29.780]  Что если я это сделал поменьше,
[29:29.780 --> 29:31.780]  то, возможно, здесь значение стало меньше,
[29:31.780 --> 29:32.780]  чем в родителе.
[29:32.780 --> 29:34.780]  Это противоречит требованию кучи,
[29:34.780 --> 29:36.780]  и нам надо срочно это исправлять.
[29:36.780 --> 29:39.780]  Так вот, я не буду сифтапать.
[29:39.780 --> 29:41.780]  Я просто этого сына вырежу
[29:41.780 --> 29:44.780]  и добавлю в список корней.
[29:44.780 --> 29:47.780]  Я не буду исправлять неравенство.
[29:47.780 --> 29:50.780]  Я просто возьму, удалю эту вершину
[29:50.780 --> 29:52.780]  из списка детей родителя.
[29:52.780 --> 29:54.780]  Благо, я умею списку удалять за единицу.
[29:54.780 --> 29:57.780]  И все это дерево целиком вынесу в список корней.
[29:57.780 --> 30:00.780]  Все, что здесь было, давайте назову это А.
[30:00.780 --> 30:02.780]  Я его сюда в список корней добавил.
[30:02.780 --> 30:04.780]  Благо, у меня все корни прошиты в список.
[30:04.780 --> 30:07.780]  Я в список могу еще один элемент добавить.
[30:07.780 --> 30:08.780]  Разрываю эту связь,
[30:08.780 --> 30:11.780]  удаляю этот элемент из списка родителя.
[30:11.780 --> 30:14.780]  И тем самым я починил
[30:14.780 --> 30:17.780]  потенциально нарушившееся неравенство.
[30:17.780 --> 30:19.780]  Согласны же?
[30:19.780 --> 30:21.780]  Все, что могло нарушиться, это вот это неравенство.
[30:21.780 --> 30:22.780]  Если я это число уменьшил,
[30:22.780 --> 30:24.780]  то у меня могло нарушиться неравенство на этом ребре.
[30:24.780 --> 30:25.780]  Вот я его тогда вырежу,
[30:25.780 --> 30:27.780]  чтобы этого ребра не существовало,
[30:27.780 --> 30:29.780]  чтобы не было требований на этом ребре никакого.
[30:29.780 --> 30:32.780]  Просто добавлю список корней.
[30:32.780 --> 30:33.780]  Вот.
[30:33.780 --> 30:35.780]  — Не надо консоли дейт делать просто?
[30:35.780 --> 30:37.780]  — Пока нет.
[30:37.780 --> 30:40.780]  Нет, в дикориске консоли дейт мы не делаем.
[30:40.780 --> 30:42.780]  Тут есть другая проблема.
[30:43.780 --> 30:45.780]  Да, нужно разобраться с марками
[30:45.780 --> 30:46.780]  и особенно понять, что делать,
[30:46.780 --> 30:48.780]  а если у родителя уже было маркер внутри.
[30:51.780 --> 30:52.780]  Еще раз?
[30:57.780 --> 31:00.780]  Ну, в экстракт-мин надо иметь марки
[31:00.780 --> 31:02.780]  в том смысле, что если вершина стала корнем,
[31:02.780 --> 31:04.780]  то у него марк снимается, это правда.
[31:04.780 --> 31:07.780]  Но это как бы автоматически в каком-то смысле предусмотрено.
[31:07.780 --> 31:08.780]  Потому что если вершина стала корнем,
[31:08.780 --> 31:10.780]  то у него марк автоматически снилось.
[31:12.780 --> 31:14.780]  — Можно посчитать минимальное?
[31:14.780 --> 31:16.780]  — Да, но это легко сделать,
[31:16.780 --> 31:17.780]  потому что у меня, ну как бы,
[31:17.780 --> 31:19.780]  за D от N я просто по этому списку.
[31:21.780 --> 31:22.780]  Значит, еще раз, смотрите,
[31:22.780 --> 31:24.780]  вот здесь дикорисский яйт в вершине уменьшил,
[31:24.780 --> 31:25.780]  если произошла проблема,
[31:25.780 --> 31:26.780]  я вынес его в список корней.
[31:26.780 --> 31:27.780]  Что дальше делать?
[31:27.780 --> 31:29.780]  Какая проблема осталась?
[31:34.780 --> 31:37.780]  — Наверное, будем опять консоли дейт делать?
[31:37.780 --> 31:38.780]  — Не, консоли дейт не буду.
[31:38.780 --> 31:39.780]  Консоли дейт долго у меня работает.
[31:39.780 --> 31:41.780]  Консоли дейт работает за D от N,
[31:41.780 --> 31:42.780]  а D от N у меня логарифмическая.
[31:42.780 --> 31:44.780]  А я хочу здесь единицу получить.
[31:46.780 --> 31:48.780]  Ранку вершины храним, конечно, да.
[31:49.780 --> 31:50.780]  Да, справедливо,
[31:50.780 --> 31:52.780]  надо в эту вершину уменьшить ранг, это правда.
[31:52.780 --> 31:53.780]  Уменьшили, да.
[31:55.780 --> 31:57.780]  У корней A здесь делать марк равно false,
[31:57.780 --> 31:58.780]  тоже верно, да.
[32:01.780 --> 32:03.780]  Потому что в корнях у нас марк всегда будет false.
[32:07.780 --> 32:08.780]  Справедливо, да.
[32:08.780 --> 32:09.780]  Давайте еще,
[32:09.780 --> 32:11.780]  я минимум чуть попозже себе запишу,
[32:11.780 --> 32:13.780]  но что еще нужно сделать?
[32:13.780 --> 32:14.780]  Надо разобраться с тем,
[32:14.780 --> 32:16.780]  что если вот эта вершина уже была марк равно true,
[32:16.780 --> 32:18.780]  то есть у нее уже когда-то раньше
[32:18.780 --> 32:20.780]  один из детей удалился,
[32:20.780 --> 32:22.780]  вырезался и добавился в список корней,
[32:22.780 --> 32:24.780]  и в ней стояла марк равно true,
[32:27.780 --> 32:29.780]  тогда я делаю как бы что-то незаконное.
[32:29.780 --> 32:31.780]  Я не разрешал себе никогда удалять двух сыновей.
[32:31.780 --> 32:33.780]  Если это не корень,
[32:33.780 --> 32:35.780]  я двух детей удалить не могу.
[32:35.780 --> 32:37.780]  У кого я могу удалять два,
[32:37.780 --> 32:39.780]  двух детей более?
[32:39.780 --> 32:40.780]  У корня.
[32:40.780 --> 32:42.780]  Давайте эту вершину делаем корнем.
[32:42.780 --> 32:44.780]  Давайте все оставшееся ее под дерево,
[32:44.780 --> 32:46.780]  вот все, что здесь есть, так или иначе,
[32:46.780 --> 32:48.780]  давайте это опять вынесу в список корней.
[32:52.780 --> 32:54.780]  Да, и это, и если здесь была марк true,
[32:54.780 --> 32:56.780]  и это тоже выношу.
[32:56.780 --> 32:58.780]  Более того, я теперь вырезал эту вершину,
[32:58.780 --> 33:00.780]  и если у ее родителя тоже было марк равно true,
[33:00.780 --> 33:02.780]  то мне придется и под дерево
[33:02.780 --> 33:04.780]  этой вершины тоже вынести
[33:04.780 --> 33:06.780]  и добавить список корней.
[33:08.780 --> 33:10.780]  Итак, дикриски работают следующим образом.
[33:10.780 --> 33:12.780]  Мы уменьшаем значение в вершине,
[33:12.780 --> 33:14.780]  которое мне сказали,
[33:14.780 --> 33:16.780]  и дальше, пока у родителя этой вершины марк было равно true,
[33:16.780 --> 33:18.780]  я вырезаю его, выношу список корней,
[33:18.780 --> 33:20.780]  и делаю то же самое с родителем.
[33:20.780 --> 33:22.780]  То есть пока в родителе
[33:22.780 --> 33:24.780]  было марк равно true,
[33:24.780 --> 33:26.780]  мне придется, поскольку я хочу вырезать его сына,
[33:26.780 --> 33:28.780]  то мне придется эту вершину тоже вырезать.
[33:28.780 --> 33:30.780]  Я ее вырезаю и заношу список корней.
[33:30.780 --> 33:32.780]  Ну и так поднимаюсь,
[33:32.780 --> 33:34.780]  пока все марки были true.
[33:34.780 --> 33:36.780]  Здесь марк true выношу и снимаю ее,
[33:36.780 --> 33:38.780]  потому что в корне марк всегда false.
[33:38.780 --> 33:40.780]  Ну и так далее, поднимаюсь, поднимаюсь.
[33:40.780 --> 33:42.780]  В конце концов я либо дойду до корня,
[33:42.780 --> 33:44.780]  у которого можно спокойно удалять все, что хотите,
[33:44.780 --> 33:46.780]  либо я дойду до некорневой вершины,
[33:46.780 --> 33:48.780]  где было марк равно false,
[33:48.780 --> 33:50.780]  и там я ей представляю марк равно true.
[33:52.780 --> 33:54.780]  Еще раз?
[33:54.780 --> 33:56.780]  Ну вот правило такое.
[33:56.780 --> 33:58.780]  Я говорю, что марк, это флаг,
[33:58.780 --> 34:00.780]  удалили мы сына или нет.
[34:00.780 --> 34:02.780]  Чтобы у меня все было хорошо с этим точкой,
[34:02.780 --> 34:04.780]  я запрещаю себя удалять
[34:04.780 --> 34:06.780]  больше одного сына.
[34:06.780 --> 34:08.780]  Потому что если вы позволите удалять
[34:08.780 --> 34:10.780]  всех сыновей, например...
[34:10.780 --> 34:12.780]  Так, что будет?
[34:12.780 --> 34:14.780]  Дайте я подумаю секунду.
[34:14.780 --> 34:16.780]  Почему?
[34:24.780 --> 34:26.780]  Ну короче, я сходу сказать не могу,
[34:26.780 --> 34:28.780]  но упражнение, что
[34:28.780 --> 34:30.780]  понять, что происходит, если мы можем удалять
[34:30.780 --> 34:32.780]  любое число детей.
[34:32.780 --> 34:34.780]  Сейчас, одну секунду.
[34:42.780 --> 34:44.780]  Сейчас все сделаем, да.
[34:44.780 --> 34:46.780]  Но с минимумом как раз нет проблемы.
[34:46.780 --> 34:48.780]  Любое число детей.
[34:48.780 --> 34:50.780]  Так, у вас вопрос еще был?
[34:50.780 --> 34:52.780]  У вас было сейчас...
[34:52.780 --> 34:54.780]  Сейчас, сейчас.
[34:54.780 --> 34:56.780]  А можно было в небольшом примере
[34:56.780 --> 34:58.780]  понять, что происходит?
[34:58.780 --> 35:00.780]  Ну давайте попробуем чуть-чуть нарисовать.
[35:06.780 --> 35:08.780]  Так, я слушаю вас тогда пока.
[35:08.780 --> 35:10.780]  Там деревья...
[35:10.780 --> 35:12.780]  Нет.
[35:12.780 --> 35:14.780]  Уже любые. В момент, когда я
[35:14.780 --> 35:16.780]  ввожу вот эту процедуру вырезания,
[35:16.780 --> 35:18.780]  у меня дерево теряет свою структуру,
[35:18.780 --> 35:20.780]  и оно уже не обязательно биномиальное.
[35:20.780 --> 35:22.780]  Изначально они биномиальные?
[35:22.780 --> 35:24.780]  Изначально, да. Пока вы не вызвали дикарески,
[35:24.780 --> 35:26.780]  но если не было ни одного дикарески,
[35:26.780 --> 35:28.780]  то у вас все биномиальные.
[35:28.780 --> 35:30.780]  Но в момент, когда происходит дикарес,
[35:30.780 --> 35:32.780]  у вас уже какое-то вырезание.
[35:36.780 --> 35:38.780]  Ну она в любом случае нарушается.
[35:38.780 --> 35:40.780]  Она, конечно, нарушится.
[35:40.780 --> 35:42.780]  Вопрос привести в последовательство операции
[35:42.780 --> 35:44.780]  такую, что у вас вырождается
[35:44.780 --> 35:46.780]  в какую-нибудь асимботику линейную.
[35:46.780 --> 35:48.780]  Структура в любом случае нарушается.
[35:48.780 --> 35:50.780]  Вопрос, насколько плохо.
[35:50.780 --> 35:52.780]  Вот я утверждаю, что в такой реализации
[35:52.780 --> 35:54.780]  она испортится, но все равно
[35:54.780 --> 35:56.780]  логарифмическая асимботика будет на экстракт.
[35:56.780 --> 35:58.780]  Так, пример.
[35:58.780 --> 36:00.780]  Давайте кого-нибудь быстренького.
[36:00.780 --> 36:02.780]  Вот представьте, у вас был такой дерево.
[36:02.780 --> 36:04.780]  Это корень, root я его назову.
[36:04.780 --> 36:06.780]  В нем марк было false в частности.
[36:06.780 --> 36:08.780]  Тут были какие-то дети, я их не рисую.
[36:08.780 --> 36:10.780]  Есть какие-то еще посторонние ветки.
[36:10.780 --> 36:12.780]  Здесь есть какие-то ветки все, я их не рисую.
[36:12.780 --> 36:14.780]  Вот здесь пришел дикарески.
[36:14.780 --> 36:16.780]  Вот этот х, который надо было дикаризнуть.
[36:16.780 --> 36:18.780]  Но я уменьшаю его значение
[36:18.780 --> 36:20.780]  и хочу вырезать все его по дереву,
[36:20.780 --> 36:22.780]  то есть все корни.
[36:22.780 --> 36:24.780]  Я вот это выношу сюда.
[36:24.780 --> 36:26.780]  Вот этот х выношу сюда.
[36:30.780 --> 36:32.780]  В какой-то момент тут может быть true,
[36:32.780 --> 36:34.780]  в какой-то момент может быть false.
[36:34.780 --> 36:36.780]  Я рассматриваю, в какой-то момент времени
[36:36.780 --> 36:38.780]  могло быть так.
[36:38.780 --> 36:40.780]  Смотрите, у этой вершины уже и так
[36:40.780 --> 36:42.780]  было true равно false, я у нее уже и так
[36:42.780 --> 36:44.780]  что-то вырезал. Вырезай нового.
[36:44.780 --> 36:46.780]  Но я такого не хочу себе позволять.
[36:46.780 --> 36:48.780]  Единственная вершина, у которой я хочу
[36:48.780 --> 36:50.780]  себе удалять больше, чем одну вершину,
[36:50.780 --> 36:52.780]  больше, чем одного сына, это корень.
[36:52.780 --> 36:54.780]  Поэтому я беру все, что осталось
[36:54.780 --> 36:56.780]  от этой вершины, все, что здесь осталось,
[36:56.780 --> 36:58.780]  выношу этот список корней сюда.
[36:58.780 --> 37:00.780]  Вот это вот добавляю сюда.
[37:00.780 --> 37:02.780]  Ну и снимаю марк. Здесь было true,
[37:02.780 --> 37:04.780]  здесь станет false.
[37:04.780 --> 37:06.780]  Теперь у родителя этой вершины
[37:06.780 --> 37:08.780]  та же самая проблема. У него был марк
[37:08.780 --> 37:10.780]  равно true, то есть кого-то из детей
[37:10.780 --> 37:12.780]  я когда-то раньше уже удалил.
[37:12.780 --> 37:14.780]  И теперь удаляю еще одного.
[37:14.780 --> 37:16.780]  Значит, надо опять это все
[37:16.780 --> 37:18.780]  вынести вот сюда. Опять скажешь,
[37:18.780 --> 37:20.780]  что все, что здесь осталось,
[37:20.780 --> 37:22.780]  это новое дерево.
[37:22.780 --> 37:24.780]  И снять здесь марку, поставить,
[37:24.780 --> 37:26.780]  что здесь марка false.
[37:26.780 --> 37:28.780]  Теперь у родителя марка была false,
[37:28.780 --> 37:30.780]  я просто спокойно ставлю здесь true
[37:30.780 --> 37:32.780]  и завершаю выполнение, потому что
[37:32.780 --> 37:34.780]  раньше у нее никто не удалялся, а теперь
[37:34.780 --> 37:36.780]  удалился один сын. Все, вот здесь
[37:36.780 --> 37:38.780]  помещаю true и побеждаю. На этом дикарески
[37:38.780 --> 37:40.780]  заканчиваются.
[37:40.780 --> 37:42.780]  Так, ну вот.
[37:42.780 --> 37:44.780]  Да.
[37:54.780 --> 37:56.780]  Из N деревьев ранга ноль.
[38:00.780 --> 38:02.780]  Ну да.
[38:02.780 --> 38:04.780]  У меня здесь учетная стоимость.
[38:04.780 --> 38:06.780]  Со симдотикой я еще разберусь пока.
[38:06.780 --> 38:08.780]  Я, в смысле, позже разберусь.
[38:08.780 --> 38:10.780]  Итак,
[38:10.780 --> 38:12.780]  я делаю ровно вот это.
[38:12.780 --> 38:14.780]  Теперь давайте разбираться со временем
[38:14.780 --> 38:16.780]  работы, за сколько все будет работать.
[38:32.780 --> 38:34.780]  Я не буду повторять. Я вырезаю все
[38:34.780 --> 38:36.780]  вот эти вершины, у которых марка была true.
[38:36.780 --> 38:38.780]  Везде, где бывает проблема
[38:38.780 --> 38:40.780]  с тем, что я удалил уже сына,
[38:40.780 --> 38:42.780]  я вырезаю вот это и заношу в общий список.
[38:42.780 --> 38:44.780]  Здесь была true, вынес. Здесь была true, вынес.
[38:44.780 --> 38:46.780]  Все вот эти, где были проблемы, я вынес.
[38:46.780 --> 38:48.780]  Итак,
[38:48.780 --> 38:50.780]  давайте анализировать асимптотику.
[38:50.780 --> 38:52.780]  Поскольку у меня
[38:52.780 --> 38:54.780]  учетная асимптотика вот здесь,
[38:54.780 --> 38:56.780]  что в дикареске, что в экстракте,
[38:56.780 --> 38:58.780]  я методом монеток опять воспользуюсь.
[38:58.780 --> 39:00.780]  Давайте скажу следующее,
[39:00.780 --> 39:02.780]  что на каждом корне
[39:02.780 --> 39:04.780]  лежит по монетке.
[39:06.780 --> 39:08.780]  А на каждой вершине
[39:08.780 --> 39:10.780]  с марка внутри лежит по две монетки.
[39:32.780 --> 39:34.780]  Давайте сделаем так.
[39:34.780 --> 39:36.780]  Ну, теперь давайте
[39:36.780 --> 39:38.780]  с точки зрения вот этого вот
[39:38.780 --> 39:40.780]  бюджета нашего
[39:40.780 --> 39:42.780]  проанализируем, за сколько работает консолидейт.
[39:42.780 --> 39:44.780]  То есть, на самом деле, где у нас
[39:44.780 --> 39:46.780]  связывается консолидейт? Консолидейт только внутри
[39:46.780 --> 39:48.780]  экстракт-мина есть.
[39:48.780 --> 39:50.780]  За сколько работает консолидейт?
[39:50.780 --> 39:52.780]  Ну, смотрите, вот пусть здесь, везде
[39:52.780 --> 39:54.780]  на всех корнях лежали монетки.
[39:54.780 --> 39:56.780]  Что я делаю?
[39:56.780 --> 39:58.780]  Я прохожусь по всем этим корням
[39:58.780 --> 40:00.780]  и как их там сливаю?
[40:00.780 --> 40:02.780]  Я прохожусь по всем этим корням
[40:02.780 --> 40:04.780]  и как их там сливаю?
[40:04.780 --> 40:06.780]  Но смотрите, что мне нужно оставить?
[40:06.780 --> 40:08.780]  Мне нужно, чтобы вот на этих результирующих корнях
[40:08.780 --> 40:10.780]  были, на этих результирующих деревьев
[40:10.780 --> 40:12.780]  в корнях тоже было по монетке.
[40:12.780 --> 40:14.780]  Но как раз тогда
[40:14.780 --> 40:16.780]  мне хватает монет на то, чтобы провести
[40:16.780 --> 40:18.780]  все вот эти вот ребра. Потому что, если у меня есть два дерева,
[40:18.780 --> 40:20.780]  в корнях,
[40:20.780 --> 40:22.780]  в которых есть монеты,
[40:22.780 --> 40:24.780]  я провожу ребро,
[40:24.780 --> 40:26.780]  делаю это за единицу,
[40:26.780 --> 40:28.780]  за одно действие, и снимаю
[40:28.780 --> 40:30.780]  монету с того дерева, который
[40:30.780 --> 40:32.780]  я подвесил. А на меньшем дереве,
[40:32.780 --> 40:34.780]  то есть на том, где корень был
[40:34.780 --> 40:36.780]  меньше, я монету оставляю.
[40:36.780 --> 40:38.780]  То есть у меня было две монеты, я одной из них
[40:38.780 --> 40:40.780]  расплатился за эту операцию,
[40:40.780 --> 40:42.780]  и оставил монету в корне получившегося
[40:42.780 --> 40:44.780]  дерева. То есть я монетой
[40:44.780 --> 40:46.780]  расплатился за подвешивание.
[40:46.780 --> 40:48.780]  Поэтому вот это вот все, количество корней,
[40:48.780 --> 40:50.780]  работает
[40:50.780 --> 40:52.780]  в каком-то смысле за ноль.
[40:52.780 --> 40:54.780]  То есть я
[40:54.780 --> 40:56.780]  переподвешивание выполняю за те монеты, которые
[40:56.780 --> 40:58.780]  у меня уже есть. Если у меня раньше на всех
[40:58.780 --> 41:00.780]  корнях были монетки, то теперь
[41:00.780 --> 41:02.780]  все вот эти подвешивания работают как бы за ноль.
[41:02.780 --> 41:04.780]  Учетная стоимость, реальное время,
[41:04.780 --> 41:06.780]  минус число снятох монеток, это будет ноль.
[41:06.780 --> 41:08.780]  Но поэтому это учетно будет ноль,
[41:08.780 --> 41:10.780]  и остается dead end.
[41:10.780 --> 41:12.780]  Поэтому
[41:12.780 --> 41:14.780]  учетное время консолидейта это
[41:14.780 --> 41:16.780]  dead end.
[41:20.780 --> 41:22.780]  Теперь давайте вернемся, проанализируем
[41:22.780 --> 41:24.780]  простые функции.
[41:24.780 --> 41:26.780]  Значит, что с инсертом? За сколько
[41:26.780 --> 41:28.780]  работает инсерт? Вспоминаем инсерт. Это что такое?
[41:28.780 --> 41:30.780]  У меня был один список, я добавляю
[41:30.780 --> 41:32.780]  новое дерево из одной вершины и склеиваю
[41:32.780 --> 41:34.780]  два списка в один.
[41:34.780 --> 41:36.780]  Что я при этом сделал? Я в частности добавляю
[41:36.780 --> 41:38.780]  монету на новый корень. То есть я
[41:38.780 --> 41:40.780]  добавил новый х, оно стало
[41:40.780 --> 41:42.780]  корнем, значит я потратил одну монету
[41:42.780 --> 41:44.780]  в этот момент. Ну и сделал там
[41:44.780 --> 41:46.780]  типа два действия. Прокинул одну ссылку,
[41:46.780 --> 41:48.780]  прокинул другую ссылку.
[41:48.780 --> 41:50.780]  Это единица.
[41:50.780 --> 41:52.780]  Как чистая, так и учетная. То есть я сделал
[41:52.780 --> 41:54.780]  единицы действий, и с точки зрения
[41:54.780 --> 41:56.780]  монеток я положил всего одну монетку, поэтому
[41:56.780 --> 41:58.780]  это тоже законно. Здесь остается единица.
[41:58.780 --> 42:00.780]  С гитмином, ну гитмин у меня всегда хранится
[42:00.780 --> 42:02.780]  указатель, здесь вообще ничего не происходит, я просто увожу ответ.
[42:02.780 --> 42:04.780]  Чистые единицы.
[42:04.780 --> 42:06.780]  Merge, это просто соединить два списка, это там
[42:06.780 --> 42:08.780]  тоже два действия.
[42:08.780 --> 42:10.780]  Без монеток здесь все честно за чистую единицу.
[42:10.780 --> 42:12.780]  Значит, экстракт мина, мы поняли, что
[42:12.780 --> 42:14.780]  экстракт мин работает на самом деле за
[42:14.780 --> 42:16.780]  у звездочку D.
[42:16.780 --> 42:18.780]  Чуть позже докажем,
[42:18.780 --> 42:20.780]  в конце докажем, почему D это логарифм.
[42:20.780 --> 42:22.780]  Ну теперь декрестки.
[42:22.780 --> 42:24.780]  Декрестки тоже все хорошо за счет
[42:24.780 --> 42:26.780]  вот этих монеток, которые у меня
[42:26.780 --> 42:28.780]  на вершинах с маркером
[42:28.780 --> 42:30.780]  нутру лежат.
[42:30.780 --> 42:32.780]  Ну вот представьте, смотрите,
[42:32.780 --> 42:34.780]  за сколько я вот это все делал на этой картинке.
[42:34.780 --> 42:36.780]  Я вырезаю вот этого чувака, вот этого и вот этого.
[42:38.780 --> 42:40.780]  Что я делаю в этот момент?
[42:40.780 --> 42:42.780]  Смотрите, вырезать вершину по факту,
[42:42.780 --> 42:44.780]  если честно вырезать вершину, добавить список
[42:44.780 --> 42:46.780]  корней, это от единицы.
[42:46.780 --> 42:48.780]  Потому что мне нужно удалить ее из списка
[42:48.780 --> 42:50.780]  детей и родителей, а из списка я умею
[42:50.780 --> 42:52.780]  за единицу удалять.
[42:52.780 --> 42:54.780]  Ну и плюс нужно добавить вот это все дерево
[42:54.780 --> 42:56.780]  в конец общего списка корней.
[42:56.780 --> 42:58.780]  Это тоже за единицу делается.
[42:58.780 --> 43:00.780]  Поэтому здесь как бы единица действий,
[43:00.780 --> 43:02.780]  но еще мне нужно еще монетку сюда положить.
[43:02.780 --> 43:04.780]  Три действия. Вырезали отсюда,
[43:04.780 --> 43:06.780]  добавили сюда, положили монетку.
[43:06.780 --> 43:08.780]  Три действия пока что.
[43:08.780 --> 43:10.780]  Далее мы поднимаемся в родителя в родителя
[43:10.780 --> 43:12.780]  многократно, пока здесь стоит маркер нутру.
[43:12.780 --> 43:14.780]  Но здесь есть по две монетки.
[43:14.780 --> 43:16.780]  А мне нужно всего лишь взять
[43:16.780 --> 43:18.780]  и вырезать вот этого дерева и вставить сюда.
[43:18.780 --> 43:20.780]  Я вырезаю за счет той монетки,
[43:20.780 --> 43:22.780]  которая тут есть,
[43:22.780 --> 43:24.780]  вставляю сюда и оставляю на нем
[43:24.780 --> 43:26.780]  одну монетку. То есть у меня за счет того,
[43:26.780 --> 43:28.780]  что здесь есть две монеты, я могу вынести,
[43:28.780 --> 43:30.780]  вырезать все это по дереву и вставить сюда.
[43:30.780 --> 43:32.780]  И оставить на корне
[43:32.780 --> 43:34.780]  одну монету. Как бы за бесплатно.
[43:34.780 --> 43:36.780]  Потому что я делаю какое-то действие
[43:36.780 --> 43:38.780]  и оплачиваю его той монетой,
[43:38.780 --> 43:40.780]  которой у меня уже есть.
[43:40.780 --> 43:42.780]  Ну и так далее. По всем этим вершинам прохожу.
[43:42.780 --> 43:44.780]  За счет того, что здесь достаточно много денег,
[43:44.780 --> 43:46.780]  то есть есть две монеты, то я одну из них
[43:46.780 --> 43:48.780]  стараюсь вырезать и положить сюда,
[43:48.780 --> 43:50.780]  и вторую остается,
[43:50.780 --> 43:52.780]  потому что это корень.
[43:52.780 --> 43:54.780]  В конце мне нужно в худшем случае
[43:54.780 --> 43:56.780]  у этой вершины, которая была родителем
[43:56.780 --> 43:58.780]  с маркером нутру, выставить true,
[43:58.780 --> 44:00.780]  значит мне нужно еще сюда две монеты
[44:00.780 --> 44:02.780]  положить.
[44:02.780 --> 44:04.780]  Но это еще плюс два ко времени работы.
[44:04.780 --> 44:06.780]  Получается, что все это работает за
[44:06.780 --> 44:08.780]  единицу.
[44:08.780 --> 44:10.780]  Потому что вот эти все промежуточные
[44:10.780 --> 44:12.780]  операции работали как бы за ноль,
[44:12.780 --> 44:14.780]  потому что я вырезаю за счет той
[44:14.780 --> 44:16.780]  монеты, которая здесь лежит.
[44:16.780 --> 44:18.780]  Здесь там я сделал сколько-то действий,
[44:18.780 --> 44:20.780]  положил монетку на этот корень.
[44:20.780 --> 44:22.780]  И здесь положил две монетки, но это все суммарно вот единицы.
[44:22.780 --> 44:24.780]  Напоминаю, что как у меня
[44:24.780 --> 44:26.780]  вообще учетная стоимость работает.
[44:26.780 --> 44:28.780]  Это реальное время, плюс
[44:28.780 --> 44:30.780]  сколько монеток я положил, минус сколько я снял.
[44:32.780 --> 44:34.780]  Ну вот здесь как раз вот время
[44:34.780 --> 44:36.780]  и W очень хорошо
[44:36.780 --> 44:38.780]  сокращаются, потому что все вот эти вот
[44:38.780 --> 44:40.780]  промежуточные вершины, которые я вырезаю,
[44:40.780 --> 44:42.780]  добавляю в список, ну я за них расплачиваюсь
[44:42.780 --> 44:44.780]  монетками. И вот это вот T-W как раз сокращаются.
[44:46.780 --> 44:48.780]  Получается, здесь опять-таки вот
[44:48.780 --> 44:50.780]  единица учетная.
[44:52.780 --> 44:54.780]  Считается, что мы
[44:54.780 --> 44:56.780]  вырезаем
[44:56.780 --> 44:58.780]  какое-то
[44:58.780 --> 45:00.780]  дерево,
[45:00.780 --> 45:02.780]  не другую кучу. Здесь вставляем
[45:02.780 --> 45:04.780]  список за одно действие. Да, да, да.
[45:04.780 --> 45:06.780]  Ну иначе надо было сказать,
[45:06.780 --> 45:08.780]  что здесь три монетки. Ну ничего бы не
[45:08.780 --> 45:10.780]  сломалось. Да, все то же самое, конечно.
[45:10.780 --> 45:12.780]  Но я считаю, что это одно действие.
[45:12.780 --> 45:14.780]  Так, есть вопросы?
[45:16.780 --> 45:18.780]  Ну вот, значит мы вроде бы честно
[45:18.780 --> 45:20.780]  доказали, что здесь учетная единичка, осталось понять,
[45:20.780 --> 45:22.780]  что такое D от N.
[45:24.780 --> 45:26.780]  Так, тогда вот это можно стереть.
[45:26.780 --> 45:28.780]  Давайте обращу задачу.
[45:28.780 --> 45:30.780]  Смотрите, D от N – это
[45:30.780 --> 45:32.780]  максимальный возможный ранг корня,
[45:32.780 --> 45:34.780]  если всего в куче N вершин.
[45:34.780 --> 45:36.780]  Давайте решу обратную задачу.
[45:36.780 --> 45:38.780]  По рангу найду
[45:38.780 --> 45:40.780]  минимально возможное количество вершин.
[45:40.780 --> 45:42.780]  Значит, пусть
[45:42.780 --> 45:44.780]  S от K
[45:44.780 --> 45:46.780]  это
[45:46.780 --> 45:48.780]  D от N.
[45:48.780 --> 45:50.780]  Ну вот,
[45:50.780 --> 45:52.780]  вот так вот.
[45:52.780 --> 45:54.780]  Ну вот,
[45:54.780 --> 45:56.780]  S от K – это
[45:56.780 --> 45:58.780]  минимальное число
[45:58.780 --> 46:00.780]  вершин
[46:00.780 --> 46:02.780]  в дереве,
[46:02.780 --> 46:04.780]  пардон,
[46:04.780 --> 46:06.780]  извините, минимальный ранг,
[46:06.780 --> 46:08.780]  минимальный ранг,
[46:08.780 --> 46:10.780]  минимальный ранг
[46:10.780 --> 46:12.780]  корня дерева,
[46:16.780 --> 46:18.780]  в котором лежит хотя бы K вершин.
[46:24.780 --> 46:26.780]  Так,
[46:26.780 --> 46:28.780]  что я делаю? Я то же самое
[46:28.780 --> 46:30.780]  написал, извините. У меня D от N
[46:30.780 --> 46:32.780]  было как раз ограничение на ранг.
[46:32.780 --> 46:34.780]  Извините, пожалуйста,
[46:34.780 --> 46:36.780]  вершины, все правильно было.
[46:48.780 --> 46:50.780]  Вот так сделаю, да,
[46:50.780 --> 46:52.780]  извините, вот так нормально.
[46:52.780 --> 46:54.780]  То есть, еще раз, я зафиксировал ранг корня,
[46:54.780 --> 46:56.780]  хочу посчитать, какое минимальное количество вершин
[46:56.780 --> 46:58.780]  в нем может быть. Вот так.
[46:58.780 --> 47:00.780]  Ну, например,
[47:00.780 --> 47:02.780]  что такое S от нуля?
[47:06.780 --> 47:08.780]  Вершина одна, да, это единица,
[47:08.780 --> 47:10.780]  потому что если ранг ноль, значит, у меня есть
[47:10.780 --> 47:12.780]  корень дерева, у которого ноль детей.
[47:12.780 --> 47:14.780]  Понятно, что здесь всего одна вершина.
[47:14.780 --> 47:16.780]  Дальше, S от
[47:16.780 --> 47:18.780]  единицы.
[47:18.780 --> 47:20.780]  Это что значит? Есть корень, у него есть
[47:20.780 --> 47:22.780]  по крайней мере один сын,
[47:22.780 --> 47:24.780]  ну и, наверное, можно ожидать, что здесь у него ноль детей.
[47:24.780 --> 47:26.780]  Тут будет двойка.
[47:26.780 --> 47:28.780]  Это будет корректное
[47:28.780 --> 47:30.780]  дерево.
[47:30.780 --> 47:32.780]  Значит, дальше давайте смотреть.
[47:32.780 --> 47:34.780]  Давайте представим
[47:34.780 --> 47:36.780]  себе вершину, у которой сейчас
[47:36.780 --> 47:38.780]  ранг K.
[47:38.780 --> 47:40.780]  Пусть это будет вершина V.
[47:40.780 --> 47:42.780]  Что значит, что у нее сейчас ранг K?
[47:42.780 --> 47:44.780]  Это значит, что у нее есть K детей.
[47:44.780 --> 47:46.780]  У ноль,
[47:46.780 --> 47:48.780]  у один,
[47:48.780 --> 47:50.780]  и так далее у K минус один.
[47:50.780 --> 47:52.780]  Значит, давайте я упорядочу
[47:52.780 --> 47:54.780]  эти вершины
[47:54.780 --> 47:56.780]  в порядке возрастания
[47:56.780 --> 47:58.780]  времени добавления,
[47:58.780 --> 48:00.780]  в порядке возрастания времени подвешивания
[48:00.780 --> 48:02.780]  к V.
[48:02.780 --> 48:04.780]  Значит, у И упорядочены
[48:04.780 --> 48:06.780]  в порядке
[48:08.780 --> 48:10.780]  подвешивания к V.
[48:14.780 --> 48:16.780]  Потому что
[48:16.780 --> 48:18.780]  откуда появляются эти ребра?
[48:18.780 --> 48:20.780]  Ребра появляются только в момент
[48:20.780 --> 48:22.780]  подвешивания одного дерева ранга K
[48:22.780 --> 48:24.780]  к другому дереву ранга K.
[48:24.780 --> 48:26.780]  Только в этот момент у меня появляются такие ребра.
[48:26.780 --> 48:28.780]  Ну, давайте рассмотрим те моменты,
[48:28.780 --> 48:30.780]  в которые это дерево подвесилось сюда,
[48:30.780 --> 48:32.780]  потом это, потом это и так далее, вплоть до последнего.
[48:32.780 --> 48:34.780]  И упорядочу их слева направо,
[48:34.780 --> 48:36.780]  что это подвесилось самым первым, это вторым, это третьим и так далее.
[48:40.780 --> 48:42.780]  Вот.
[48:42.780 --> 48:44.780]  Смотрите,
[48:44.780 --> 48:46.780]  в момент подвешивания
[48:52.780 --> 48:54.780]  я утверждаю, что вершина УИ
[48:54.780 --> 48:56.780]  имела ранг хотя бы И.
[49:00.780 --> 49:02.780]  Вершина УИ
[49:02.780 --> 49:04.780]  имела ранг
[49:06.780 --> 49:08.780]  хотя бы И.
[49:12.780 --> 49:14.780]  Почему?
[49:14.780 --> 49:16.780]  Скажите, пожалуйста.
[49:22.780 --> 49:24.780]  Ну да.
[49:24.780 --> 49:26.780]  Потому что что значит...
[49:26.780 --> 49:28.780]  Смотрите, мы
[49:28.780 --> 49:30.780]  подливали сначала это сюда,
[49:30.780 --> 49:32.780]  потом это сюда, потом это сюда и так далее.
[49:32.780 --> 49:34.780]  Возможно, в промежутке мы еще
[49:34.780 --> 49:36.780]  что-то туда подливали.
[49:36.780 --> 49:38.780]  Возможно, они просто потом вырезались.
[49:38.780 --> 49:40.780]  Но, смотрите, если это
[49:40.780 --> 49:42.780]  была подвешена сюда einer
[49:42.780 --> 49:44.780]  была подвешена сюда после этой,
[49:44.780 --> 49:46.780]  значит в момент подвешивания здесь был ранг хотя бы один.
[49:46.780 --> 49:48.780]  Потому что здесьDB ранг хотя бы один.
[49:48.780 --> 49:50.780]  У нее был один сын уже.
[49:50.780 --> 49:52.780]  И значит, здесь тоже ранг хотя бы один,
[49:52.780 --> 49:54.780]  потому что мы сливаем только деревья
[49:54.780 --> 49:56.780]  одинакового ранга.
[49:56.780 --> 49:58.780]  Затем У2, она добавилась в момент,
[49:58.780 --> 50:00.780]  когда и эта и эта была.
[50:00.780 --> 50:02.780]  Значит, здесь ранг хотя бы два,
[50:02.780 --> 50:04.780]  значит и здесь ранг хотя бы два,
[50:04.780 --> 50:06.780]  потому что я объединяю только деревья одинакого ранга.
[50:06.780 --> 50:08.780]  И так далее.
[50:08.780 --> 50:17.660]  Согласны? А какой у них ранг теперь, скажите, пожалуйста? Не меньше, чем и минус один,
[50:17.660 --> 50:22.020]  потому что ранг может уменьшиться максимум на единицу из-за нашего свойства с марками.
[50:22.020 --> 50:27.740]  Вот здесь играет роль, что я не позволяю себе очень сильно уменьшать степень вершины,
[50:27.740 --> 50:39.620]  только максимум на единицу. А теперь ранг вершины у и хотя бы и минус один,
[50:39.620 --> 50:47.740]  потому что ранг мог уменьшиться только на единицу за счет выражения какого-то из детей.
[50:47.740 --> 50:54.060]  Двух и более детей я удалить не могу. Понятно? Это самый главный момент,
[50:54.060 --> 50:59.860]  почему у нас получается такая симпатика, что у каждой из них, это уже не корни дерева,
[50:59.860 --> 51:04.500]  удалить из них я могу максимум только одного сына. Если удаляю двух и более,
[51:04.500 --> 51:08.860]  то я тогда обязан был бы это вынести в список корней, и это уже не могли бы быть детьми В.
[51:08.860 --> 51:14.300]  А если они еще дети, то у них удалился максимум один Ц, значит ранг хотя бы и минус один.
[51:15.060 --> 51:23.980]  Вот, ну значит картинка такая. Здесь ранг К, здесь ранг 0, хотя бы 0, здесь ранг хотя бы 0,
[51:23.980 --> 51:36.860]  здесь ранг хотя бы 1 и так далее, здесь ранг хотя бы К-2. То есть это 0, это 1-1, тоже 0. Тут будет 2-1-1 и так далее К-2.
[51:36.860 --> 51:43.820]  То есть теперь если у меня корень имеет ранг К, то здесь эти товарищи рангов хотя бы 0,0,1,2,3 и так далее К-1.
[51:43.820 --> 51:52.820]  Получается, что sk, заведомо, больше либо равно, чем 1, давайте я напишу 2, вот эти вот я учту отдельно,
[51:52.820 --> 51:58.820]  а дальше сумма i от 0 до k-2, s и t.
[51:58.820 --> 52:07.820]  Потому что если здесь rank хотя бы i, вот этих всех товарищей rank хотя бы будет i,
[52:07.820 --> 52:09.820]  ну значит в них минимальней, что вершины тесы.
[52:09.820 --> 52:17.820]  Ну все, отчет сфибоначи.
[52:17.820 --> 52:21.820]  Да.
[52:21.820 --> 52:27.820]  Еще раз?
[52:27.820 --> 52:35.820]  Почему здесь не один?
[52:35.820 --> 52:40.820]  Потому что вот это вот, потому что i-1 хотя бы.
[52:40.820 --> 52:50.820]  Потому что здесь rank k-1, здесь rank хотя бы k-1, после удаления хотя бы k-2.
[52:50.820 --> 52:53.820]  Потому что мы одного сына могли удалить.
[52:53.820 --> 53:00.820]  Ну, давайте напишу, ну вот галочки, вот этот и этот, все остальные суммы вошли.
[53:01.820 --> 53:06.820]  Значит давайте напишу первые несколько значений, s0, s1 мы посчитали, давайте s2 напишу, что такое s2.
[53:06.820 --> 53:13.820]  Это 2 плюс s0, это 3.
[53:13.820 --> 53:19.820]  s3, это 2 плюс s0, s1.
[53:19.820 --> 53:24.820]  Это 5.
[53:24.820 --> 53:34.820]  Ну да, давайте напишем просто здесь равенство честное, потому что такое могло произойти.
[53:34.820 --> 53:36.820]  Да, это правда.
[53:36.820 --> 53:40.820]  Ну или там, если бы я написал большое равно, то было больше 0 чем 5.
[53:40.820 --> 53:42.820]  Это не особо важно.
[53:42.820 --> 53:44.820]  Давайте я оставлю все-таки большее равно.
[53:44.820 --> 53:47.820]  Окей, тогда здесь просто будет большее равно, но это не на что не повлияет.
[53:47.820 --> 53:51.820]  Ну и так далее, если я посчитаю, s4 получится, что бы вы думали, 8.
[53:51.820 --> 53:55.820]  Если бы мы посчитали, s5 будет больше 0, 13.
[53:55.820 --> 53:57.820]  Ну и так далее, в точности чисто фибоначи.
[53:57.820 --> 53:59.820]  Вот.
[54:03.820 --> 54:07.820]  Ну здесь 0, вы согласны, что здесь степень 0?
[54:07.820 --> 54:11.820]  А здесь была 1, а стало 0.
[54:11.820 --> 54:13.820]  Ну вот и два нуля.
[54:15.820 --> 54:18.820]  Так, значит почему это действительно фибоначи?
[54:21.820 --> 54:23.820]  Ну это может по индукции доказать.
[54:23.820 --> 54:25.820]  Почему действительно чисто фибоначи?
[54:25.820 --> 54:28.820]  Напомню или определю для тех, кто внезапно не знает.
[54:28.820 --> 54:30.820]  Значит, что такое чисто фибоначи?
[54:30.820 --> 54:33.820]  Это такая последовательность, что f от 0 это 0.
[54:33.820 --> 54:36.820]  Так, у меня здесь будет не совсем они, ну ладно.
[54:36.820 --> 54:40.820]  Значит, f от 1 это 1, а fn это сумма двух предыдущих.
[54:40.820 --> 54:41.820]  Вот.
[54:41.820 --> 54:43.820]  Такая последовательность.
[54:43.820 --> 54:49.820]  Ну давайте докажем по индукции, что s от k, это f, видимо, k плюс 1.
[54:52.820 --> 54:53.820]  Больше собравну.
[54:53.820 --> 54:55.820]  Больше собравну, да.
[54:58.820 --> 55:02.820]  Вот, ну потому что с от k, с от k, с от k, с от k,
[55:02.820 --> 55:06.820]  с от k, с от k, с от k, с от k, с от k.
[55:06.820 --> 55:08.820]  Вот, ну база очевидна.
[55:08.820 --> 55:10.820]  k равно 0, k равно 1 выполняется,
[55:10.820 --> 55:13.820]  потому что 1 фибоначи это 1, а 2 это 2.
[55:13.820 --> 55:15.820]  На базе очевидно.
[55:15.820 --> 55:16.820]  Ну переход.
[55:16.820 --> 55:19.820]  Давайте считать, что для с, для всех меньших это верно.
[55:19.820 --> 55:21.820]  Давайте запишем вот это вот неравенство для sk.
[55:21.820 --> 55:23.820]  sk это хотя бы 2 плюс сумма,
[55:23.820 --> 55:25.820]  и от 0 до k минус 2.
[55:25.820 --> 55:27.820]  s и t.
[55:27.820 --> 55:31.820]  Каждое с и мы оцениваем снизу как f и плюс первое.
[55:31.820 --> 55:33.820]  Получаем 2 плюс,
[55:33.820 --> 55:36.820]  давайте так напишу, f1 плюс f2,
[55:36.820 --> 55:39.820]  плюс так далее, плюс fk минус 1.
[55:48.820 --> 55:50.820]  Так, или не хочу я так сделать.
[55:53.820 --> 55:55.820]  Давайте по-другому.
[55:55.820 --> 55:57.820]  Чуть покороче просто сделаем.
[55:57.820 --> 55:59.820]  Я вот так это напишу.
[55:59.820 --> 56:01.820]  Это равно просто на 1,
[56:01.820 --> 56:03.820]  sk минус 1,
[56:03.820 --> 56:05.820]  плюс sk минус 2.
[56:05.820 --> 56:07.820]  Вот так.
[56:08.820 --> 56:09.820]  Почему?
[56:09.820 --> 56:11.820]  Потому что, смотрите, в этой сумме я отщепляю
[56:11.820 --> 56:13.820]  все кроме последнего слагаемого.
[56:13.820 --> 56:15.820]  Последнее слагаемое ушло сюда.
[56:15.820 --> 56:17.820]  Тут осталось 2 плюс сумма,
[56:17.820 --> 56:19.820]  и от 0 до k минус 3, s и t.
[56:19.820 --> 56:23.820]  Но 2 плюс сумма от 0 до k минус 3, s и t,
[56:23.820 --> 56:25.820]  это оценка на sk минус 1.
[56:25.820 --> 56:27.820]  Вот просто вот эта вот штука.
[56:27.820 --> 56:29.820]  Давайте напишу, что это 2 плюс
[56:29.820 --> 56:31.820]  сумма
[56:31.820 --> 56:33.820]  s и t.
[56:33.820 --> 56:35.820]  То есть я все слагаемые кроме последнего
[56:35.820 --> 56:37.820]  вынес сюда, а последнее
[56:37.820 --> 56:39.820]  оставил отдельно.
[56:39.820 --> 56:41.820]  Ну и все, если мы знаем, что это чисто
[56:41.820 --> 56:43.820]  Fibonacci, то это fk просто.
[56:43.820 --> 56:45.820]  Точнее не так, что давайте все-таки
[56:45.820 --> 56:47.820]  равенство буду доказывать.
[56:47.820 --> 56:49.820]  И если мы будем доказывать,
[56:49.820 --> 56:51.820]  что это чисто Fibonacci,
[56:51.820 --> 56:53.820]  то это fk просто.
[56:53.820 --> 56:55.820]  Я все-таки равенство буду доказывать,
[56:55.820 --> 56:57.820]  и здесь тоже равенство считать, мне так удобно.
[56:57.820 --> 56:59.820]  Sorry.
[56:59.820 --> 57:01.820]  Это неважно все.
[57:01.820 --> 57:03.820]  Ну и там тоже равно.
[57:03.820 --> 57:05.820]  Не сломаемся.
[57:05.820 --> 57:07.820]  Вот.
[57:07.820 --> 57:09.820]  Все такое sk минус 1.
[57:09.820 --> 57:11.820]  Это fk,
[57:11.820 --> 57:13.820]  sk минус 2, это fk минус 1.
[57:13.820 --> 57:15.820]  Ну вот, эта сумма уже есть как раз
[57:15.820 --> 57:17.820]  число Fibonacci.
[57:19.820 --> 57:21.820]  Вот.
[57:21.820 --> 57:23.820]  Ну все.
[57:27.820 --> 57:29.820]  Так, нам осталось понять,
[57:29.820 --> 57:31.820]  как быстро растучится чисто Fibonacci.
[57:31.820 --> 57:33.820]  По экспоненте, да.
[57:33.820 --> 57:35.820]  Значит, есть какая-то формула.
[57:35.820 --> 57:37.820]  Что я начал Fibonacci?
[57:37.820 --> 57:39.820]  Ну давайте я напишу формулу.
[57:39.820 --> 57:41.820]  Да.
[57:55.820 --> 57:57.820]  Ну, неважно.
[57:57.820 --> 57:59.820]  Тут и так написано экспоненты.
[57:59.820 --> 58:01.820]  Это не обязательно доказывать.
[58:01.820 --> 58:03.820]  В общем,
[58:03.820 --> 58:05.820]  можно доказать эту формулу.
[58:05.820 --> 58:07.820]  Я бы сказал, что доказать такую формулу проще,
[58:07.820 --> 58:09.820]  потому что здесь написано явное выражение.
[58:09.820 --> 58:11.820]  Это легко по индукции доказать.
[58:11.820 --> 58:13.820]  Что если вы выражаете fn плюс 2
[58:13.820 --> 58:15.820]  через fn плюс 1, fn и fn,
[58:15.820 --> 58:17.820]  то как раз эти суммы складываете,
[58:17.820 --> 58:19.820]  получается то, что нужно для n плюс 2.
[58:19.820 --> 58:21.820]  А здесь по индукции вообще доказывать нечего.
[58:21.820 --> 58:23.820]  Ну и все.
[58:23.820 --> 58:25.820]  Смотрите, минус phi в степени минус n.
[58:25.820 --> 58:27.820]  Это что-то экспоненциально убывающее,
[58:27.820 --> 58:29.820]  потому что здесь минус n.
[58:29.820 --> 58:31.820]  Остается главное слагаемое phi в степени n.
[58:31.820 --> 58:33.820]  Поэтому с точки зрения тетты,
[58:33.820 --> 58:35.820]  давайте напишу, что это тетта от phi в степени n.
[58:35.820 --> 58:37.820]  Где phi – это какое-то число больше единицы.
[58:37.820 --> 58:39.820]  Значит, это растет экспоненциально быстро.
[58:39.820 --> 58:41.820]  Значит, и наша s тоже растет экспоненциально быстро.
[58:41.820 --> 58:43.820]  И мы на самом деле получили все, что хотели.
[58:43.820 --> 58:45.820]  Смотрите, мы при фиксированной степени корня k
[58:45.820 --> 58:47.820]  показали, что тогда вершин хотя бы phi в степени k.
[58:47.820 --> 58:49.820]  Ну, с точки зрения,
[58:49.820 --> 58:51.820]  с точности до мультипликильной константы.
[58:51.820 --> 58:53.820]  Значит, наоборот,
[58:53.820 --> 58:55.820]  если у нас всего n вершин,
[58:55.820 --> 58:57.820]  то степень не больше чем логарифм по основанию phi.
[58:57.820 --> 58:59.820]  Значит, из этого всего следует
[58:59.820 --> 59:01.820]  из этого всего следует
[59:01.820 --> 59:03.820]  из этого всего следует
[59:03.820 --> 59:05.820]  Значит, из этого всего следует,
[59:05.820 --> 59:07.820]  что d от n
[59:07.820 --> 59:09.820]  имеет порядок
[59:09.820 --> 59:11.820]  логарифм по основанию phi от n.
[59:11.820 --> 59:13.820]  Ну, основание можно не писать,
[59:13.820 --> 59:15.820]  но я уточняю,
[59:15.820 --> 59:17.820]  что если у меня s растет как экспонент
[59:17.820 --> 59:19.820]  от phi, то есть phi в степени n,
[59:19.820 --> 59:21.820]  то логарифм у меня как бы обратная функция
[59:21.820 --> 59:23.820]  будет логарифм по основанию phi.
[59:25.820 --> 59:27.820]  Вот так вот.
[59:27.820 --> 59:29.820]  Так, вопросы есть?
[59:29.820 --> 59:31.820]  Так, вопросы есть?
[59:31.820 --> 59:33.820]  Так, вопросы есть?
[59:33.820 --> 59:35.820]  Вот написано.
[59:39.820 --> 59:41.820]  Значит, если не верите,
[59:41.820 --> 59:43.820]  можете загуглить через Фибоначчо,
[59:43.820 --> 59:45.820]  это, конечно, называется формула Бене.
[59:45.820 --> 59:47.820]  Можете руками пробовать доказать,
[59:47.820 --> 59:49.820]  тогда поймете, почему это верно.
[59:49.820 --> 59:51.820]  Это совсем просто по индукции доказывается.
[59:51.820 --> 59:53.820]  Так, еще вопросы?
[59:57.820 --> 59:59.820]  По формуле.
[59:59.820 --> 01:00:01.820]  По формуле.
[01:00:05.820 --> 01:00:07.820]  Каравну 2 подставляете,
[01:00:07.820 --> 01:00:09.820]  получаете то, что надо.
[01:00:11.820 --> 01:00:13.820]  Да.
[01:00:17.820 --> 01:00:19.820]  Да, конечно.
[01:00:19.820 --> 01:00:21.820]  На самом деле
[01:00:21.820 --> 01:00:23.820]  вот эти стартовые значения,
[01:00:23.820 --> 01:00:25.820]  то есть чисто Фибоначчо определяются
[01:00:25.820 --> 01:00:27.820]  в значении вот так.
[01:00:27.820 --> 01:00:29.820]  Если вы здесь поставите любые другие числа,
[01:00:29.820 --> 01:00:31.820]  ну, положительные, хотя об одной из которых,
[01:00:31.820 --> 01:00:33.820]  скажу так,
[01:00:33.820 --> 01:00:35.820]  если вот здесь не нули, короче,
[01:00:35.820 --> 01:00:37.820]  то оно в любом случае экспенсионально быстро растет.
[01:00:37.820 --> 01:00:39.820]  Поэтому стартовое значение,
[01:00:39.820 --> 01:00:41.820]  хоть там у меня было стояло там 100, 200,
[01:00:41.820 --> 01:00:43.820]  хоть, не знаю, 0, 1, или 1, 0, это неважно.
[01:00:43.820 --> 01:00:45.820]  Главное, чтобы не нули там стояли,
[01:00:45.820 --> 01:00:47.820]  тогда оно в любом случае экспенсионально быстро растет.
[01:00:49.820 --> 01:00:51.820]  Так.
[01:00:51.820 --> 01:00:53.820]  Откуда у нас еще раз получается оценка
[01:00:53.820 --> 01:00:55.820]  Фибоначчо?
[01:00:55.820 --> 01:00:57.820]  Ну, потому что надо вспомнить, что такое С.
[01:00:57.820 --> 01:00:59.820]  С это минимальная, вот у вас было
[01:00:59.820 --> 01:01:01.820]  дерево ранга К.
[01:01:01.820 --> 01:01:03.820]  В нем тогда примерно Фи в степени
[01:01:03.820 --> 01:01:05.820]  К вершин. Очень грубо, в нем Фи в степени
[01:01:05.820 --> 01:01:07.820]  К вершин.
[01:01:07.820 --> 01:01:09.820]  Теперь что такое было Д?
[01:01:09.820 --> 01:01:11.820]  Д это, наоборот, степень, максимально возможная
[01:01:11.820 --> 01:01:13.820]  степень, если у вас в дереве
[01:01:13.820 --> 01:01:15.820]  Н вершин.
[01:01:15.820 --> 01:01:17.820]  Ну, вот это возьмите за Н,
[01:01:17.820 --> 01:01:19.820]  тогда К
[01:01:19.820 --> 01:01:21.820]  это логарифм от Н по основанию
[01:01:21.820 --> 01:01:23.820]  Фи. То есть, если вы знаете,
[01:01:23.820 --> 01:01:25.820]  то здесь мы по рангу считали количество
[01:01:25.820 --> 01:01:27.820]  вершин, а если делать наоборот,
[01:01:27.820 --> 01:01:29.820]  по человеку вершин считать ранг, ну нужно делать логарифм
[01:01:29.820 --> 01:01:31.820]  наоборот, обратная функция просто.
[01:01:33.820 --> 01:01:35.820]  Вот, такие дела.
[01:01:37.820 --> 01:01:39.820]  Так, ну что?
[01:01:41.820 --> 01:01:43.820]  Давайте тогда пойдем дальше.
[01:01:47.820 --> 01:01:49.820]  Ну, два слова. Это в целом
[01:01:49.820 --> 01:01:51.820]  очень круто с точки зрения теории,
[01:01:51.820 --> 01:01:53.820]  что у нас все операции кроме экстракта
[01:01:53.820 --> 01:01:55.820]  за единицу работают, возможно, за учетную.
[01:01:55.820 --> 01:01:57.820]  Это круто, но
[01:01:57.820 --> 01:01:59.820]  на практике, чтобы все это сыграло,
[01:01:59.820 --> 01:02:01.820]  чтобы это работало быстрее, чем
[01:02:01.820 --> 01:02:03.820]  та же бинарная или биномиальная, нужны
[01:02:03.820 --> 01:02:05.820]  очень большие объемы данных, миллиарды,
[01:02:05.820 --> 01:02:07.820]  грубо говоря, потому что здесь большая константа,
[01:02:07.820 --> 01:02:09.820]  все вот эти вырезания, хранение списков.
[01:02:09.820 --> 01:02:11.820]  Из-за того, что у нас в списке
[01:02:11.820 --> 01:02:13.820]  мы очень сильно скачем по памяти.
[01:02:13.820 --> 01:02:15.820]  Короче, это все с точки зрения константа очень не оптимально.
[01:02:15.820 --> 01:02:17.820]  Ну и плюс здесь
[01:02:17.820 --> 01:02:19.820]  учетная стоимость, а не обычная, нормальная,
[01:02:19.820 --> 01:02:21.820]  честная.
[01:02:21.820 --> 01:02:23.820]  Поэтому это, повторю, работает
[01:02:23.820 --> 01:02:25.820]  только на очень больших объемах данных.
[01:02:25.820 --> 01:02:27.820]  Скорее всего, на каких-то таких более-менее
[01:02:27.820 --> 01:02:29.820]  человеческих задачах это не почувствуется.
[01:02:29.820 --> 01:02:31.820]  Может быть даже будет хуже.
[01:02:31.820 --> 01:02:33.820]  Но теоретически
[01:02:33.820 --> 01:02:35.820]  очень даже.
[01:02:35.820 --> 01:02:37.820]  Ну нет, конечно.
[01:02:37.820 --> 01:02:39.820]  В смысле, конечно, бывают задачи, где
[01:02:39.820 --> 01:02:41.820]  реально большие объемы данных. Я про то, что
[01:02:41.820 --> 01:02:43.820]  это редко возникает в каких-то
[01:02:43.820 --> 01:02:45.820]  скажем так.
[01:02:45.820 --> 01:02:47.820]  В общем случае, скорее всего,
[01:02:47.820 --> 01:02:49.820]  у вас не будет таких объемов данных.
[01:02:49.820 --> 01:02:51.820]  Но если вы специально
[01:02:51.820 --> 01:02:53.820]  занимаетесь
[01:02:53.820 --> 01:02:55.820]  большими графами, большими структурами,
[01:02:55.820 --> 01:02:57.820]  там весь интернет хотите
[01:02:57.820 --> 01:02:59.820]  анализировать,
[01:02:59.820 --> 01:03:01.820]  всех пользователей какой-нибудь социальной сети,
[01:03:01.820 --> 01:03:03.820]  тогда, пожалуйста, это актуально.
[01:03:03.820 --> 01:03:05.820]  Но если у вас магазины в городе,
[01:03:05.820 --> 01:03:07.820]  то это не актуально.
[01:03:07.820 --> 01:03:09.820]  Просто от масштаба зависит.
[01:03:09.820 --> 01:03:11.820]  Так, хорошо.
[01:03:11.820 --> 01:03:13.820]  Я расскажу
[01:03:13.820 --> 01:03:15.820]  быстренько еще одну структуру.
[01:03:17.820 --> 01:03:19.820]  Спарстейбл называется.
[01:03:21.820 --> 01:03:23.820]  Все, уже кучу проехали.
[01:03:23.820 --> 01:03:25.820]  Давайте быстро в спарстейбл.
[01:03:25.820 --> 01:03:27.820]  Задача, которую мы хотим научиться решать.
[01:03:29.820 --> 01:03:31.820]  Следующая.
[01:03:31.820 --> 01:03:33.820]  Пусть у нас есть массив,
[01:03:37.820 --> 01:03:39.820]  который меняться не будет.
[01:03:39.820 --> 01:03:41.820]  И у нас поступает к нему запрос
[01:03:41.820 --> 01:03:43.820]  одного следующего типа.
[01:03:43.820 --> 01:03:45.820]  Нужно по числам L и R
[01:03:45.820 --> 01:03:47.820]  найти минимум на отрезке с L по R.
[01:03:47.820 --> 01:03:49.820]  То есть нужно найти минимум
[01:03:49.820 --> 01:03:51.820]  среди элементов aL и так далее aR.
[01:03:55.820 --> 01:03:57.820]  Минимум на подотреске.
[01:03:59.820 --> 01:04:01.820]  Все, и больше других запросов нет.
[01:04:01.820 --> 01:04:03.820]  Только минимум на отрезке.
[01:04:05.820 --> 01:04:07.820]  Мы научимся
[01:04:07.820 --> 01:04:09.820]  отвечать на такие запросы
[01:04:09.820 --> 01:04:11.820]  за 1.
[01:04:13.820 --> 01:04:15.820]  Идея следующая.
[01:04:15.820 --> 01:04:17.820]  Давайте мы предпочитаем ответы
[01:04:17.820 --> 01:04:19.820]  на всех отрезках, длина которых
[01:04:19.820 --> 01:04:21.820]  от степень двойки.
[01:04:21.820 --> 01:04:23.820]  1, 2, 4, 8 и так далее.
[01:04:23.820 --> 01:04:25.820]  Первый шаг.
[01:04:25.820 --> 01:04:27.820]  Найдем ответы
[01:04:29.820 --> 01:04:31.820]  для всех отрезков
[01:04:35.820 --> 01:04:37.820]  длины.
[01:04:37.820 --> 01:04:39.820]  Давайте так напишу.
[01:04:39.820 --> 01:04:41.820]  1, 2, 4, 8, 16 и так далее.
[01:04:41.820 --> 01:04:43.820]  Для всех степеней двойки
[01:04:43.820 --> 01:04:45.820]  найду все ответы.
[01:04:45.820 --> 01:04:47.820]  Это не очень страшно,
[01:04:47.820 --> 01:04:49.820]  потому что сколько здесь разных
[01:04:49.820 --> 01:04:51.820]  степеней двоек?
[01:04:51.820 --> 01:04:53.820]  Примерно логарифам.
[01:04:53.820 --> 01:04:55.820]  Понятно, у меня нет подотресков длины
[01:04:55.820 --> 01:04:57.820]  больше, чем 2 в степени логарифам.
[01:04:57.820 --> 01:04:59.820]  Поэтому здесь примерно
[01:04:59.820 --> 01:05:01.820]  логарифмическое количество длин.
[01:05:03.820 --> 01:05:05.820]  Дальше, для каждой длины,
[01:05:05.820 --> 01:05:07.820]  что логарифм длин,
[01:05:07.820 --> 01:05:09.820]  то у меня всего примерно n логн подотресков,
[01:05:09.820 --> 01:05:11.820]  потому что отрезков фиксированной длины
[01:05:11.820 --> 01:05:13.820]  их максимум n.
[01:05:13.820 --> 01:05:15.820]  И для каждого из них
[01:05:15.820 --> 01:05:17.820]  это посильная задача
[01:05:17.820 --> 01:05:19.820]  посчитать ответ на всех таких отрезков.
[01:05:19.820 --> 01:05:21.820]  Как это можно делать?
[01:05:21.820 --> 01:05:23.820]  Например, можно идти
[01:05:23.820 --> 01:05:25.820]  очередью фиксированной длины
[01:05:25.820 --> 01:05:27.820]  и хранить минимум в окошке.
[01:05:27.820 --> 01:05:29.820]  Давайте зафиксируем число 8.
[01:05:29.820 --> 01:05:31.820]  Я рассматриваю первые 8 элементов,
[01:05:31.820 --> 01:05:33.820]  добавил их в очередь и знаю минимум.
[01:05:33.820 --> 01:05:35.820]  Затем мне нужно на 1 вправо расшириться
[01:05:35.820 --> 01:05:37.820]  и на 1 слева сократиться.
[01:05:37.820 --> 01:05:39.820]  То есть по факту мне нужно
[01:05:39.820 --> 01:05:41.820]  один элемент в конец учителей добавить
[01:05:41.820 --> 01:05:43.820]  и один из начала удалить.
[01:05:43.820 --> 01:05:45.820]  И при этом узнать опять минимум.
[01:05:45.820 --> 01:05:47.820]  Но минимум в очередь я хранить умею.
[01:05:47.820 --> 01:05:49.820]  И так я линейным проходом,
[01:05:49.820 --> 01:05:51.820]  просто вот этим окошком,
[01:05:51.820 --> 01:05:53.820]  скользящим окном я дойду до конца,
[01:05:53.820 --> 01:05:55.820]  на каждом отрезке посчитаю минимум.
[01:05:55.820 --> 01:05:57.820]  Если что, можно так посчитать минимум.
[01:05:57.820 --> 01:05:59.820]  А дальше,
[01:05:59.820 --> 01:06:01.820]  если у меня есть ответ на всех отрезках
[01:06:01.820 --> 01:06:03.820]  длины степень двойки,
[01:06:03.820 --> 01:06:05.820]  то как найти ответ на запрос с l по r?
[01:06:07.820 --> 01:06:09.820]  Давайте я найду такую максимальную степень двойки,
[01:06:09.820 --> 01:06:11.820]  которая сюда умещается.
[01:06:11.820 --> 01:06:13.820]  Давайте найдем максимальное k,
[01:06:13.820 --> 01:06:15.820]  такое, что 2 вкатый
[01:06:15.820 --> 01:06:17.820]  меньше либо равно, чем длина этого отрезка.
[01:06:17.820 --> 01:06:19.820]  r минус l плюс 1.
[01:06:23.820 --> 01:06:25.820]  И приложим 2 отрезка такой длины
[01:06:25.820 --> 01:06:27.820]  слева и справа.
[01:06:27.820 --> 01:06:29.820]  То есть вот здесь вот приложу отрезок длины 2 в степень k,
[01:06:29.820 --> 01:06:31.820]  а здесь приложу отрезок длины 2 в степень k.
[01:06:33.820 --> 01:06:35.820]  Я утверждаю, что они обязательно пересекутся,
[01:06:35.820 --> 01:06:37.820]  потому что если бы они не пересекались,
[01:06:37.820 --> 01:06:39.820]  картинка была какая-то вот такая,
[01:06:39.820 --> 01:06:41.820]  тогда если бы я степенью двойки
[01:06:41.820 --> 01:06:43.820]  увеличил на единицу,
[01:06:43.820 --> 01:06:45.820]  то есть этот отрезок расширил бы вдвое,
[01:06:45.820 --> 01:06:47.820]  он бы все еще помещался в этот отрезок.
[01:06:47.820 --> 01:06:49.820]  Поэтому не пересекаться они не могут,
[01:06:49.820 --> 01:06:51.820]  иначе k можно было бы увеличить.
[01:06:51.820 --> 01:06:53.820]  Ну а раз они пересекаются, то значит они суммарно покрывают весь отрезок.
[01:06:53.820 --> 01:06:55.820]  И если я узнаю минимум
[01:06:55.820 --> 01:06:57.820]  на левой половине
[01:06:57.820 --> 01:06:59.820]  и на правой половине,
[01:06:59.820 --> 01:07:01.820]  то минимум из них
[01:07:01.820 --> 01:07:03.820]  будет минимум на отрезке.
[01:07:05.820 --> 01:07:07.820]  Причем мне даже не страшно,
[01:07:07.820 --> 01:07:09.820]  что они пересекаются по какому-то куску,
[01:07:09.820 --> 01:07:11.820]  потому что если я беру минимум
[01:07:11.820 --> 01:07:13.820]  от того, что у меня некоторые числа в минимуме
[01:07:13.820 --> 01:07:15.820]  учтутся дважды,
[01:07:15.820 --> 01:07:17.820]  от этого минимум, конечно, не изменится.
[01:07:17.820 --> 01:07:19.820]  Я просто беру минимум здесь,
[01:07:19.820 --> 01:07:21.820]  выбираю из них минимальное значение и побеждаю.
[01:07:23.820 --> 01:07:25.820]  Концепция такая.
[01:07:25.820 --> 01:07:27.820]  Ну потому что если я k
[01:07:27.820 --> 01:07:29.820]  как-то найду за единицу,
[01:07:29.820 --> 01:07:31.820]  то дальше мне нужно просто взять
[01:07:31.820 --> 01:07:33.820]  минимум из двух чисел,
[01:07:33.820 --> 01:07:35.820]  а на этих-то отрезках у меня ответы уже посчитаны.
[01:07:35.820 --> 01:07:37.820]  Это степень двойки,
[01:07:37.820 --> 01:07:39.820]  на них у меня ответы уже где-то лежат,
[01:07:39.820 --> 01:07:41.820]  я просто достаю эти числа из массива,
[01:07:41.820 --> 01:07:43.820]  который где-то посчитан,
[01:07:43.820 --> 01:07:45.820]  нахожу из них минимум.
[01:07:45.820 --> 01:07:47.820]  Это обращение к памяти и минимум из двух чисел.
[01:07:47.820 --> 01:07:49.820]  Попробуем.
[01:07:59.820 --> 01:08:01.820]  Да, ну первый шаг я не говорил,
[01:08:01.820 --> 01:08:03.820]  за сколько работает,
[01:08:03.820 --> 01:08:05.820]  ну по крайней мере не писал.
[01:08:05.820 --> 01:08:07.820]  Первый шаг будет работать за n-логен, да.
[01:08:07.820 --> 01:08:09.820]  Ну ничего страшного, зато вот это за единицу.
[01:08:09.820 --> 01:08:11.820]  Так, ну хорошо, давайте это
[01:08:11.820 --> 01:08:13.820]  как-нибудь что-нибудь напишем, смотрите.
[01:08:13.820 --> 01:08:15.820]  Давайте первый шаг сначала сделаем.
[01:08:15.820 --> 01:08:17.820]  Давайте посчитаем ответы
[01:08:17.820 --> 01:08:19.820]  для всех отрезков длины степень двойки.
[01:08:19.820 --> 01:08:21.820]  Я не буду делать вот эту вот штуку с окном,
[01:08:21.820 --> 01:08:23.820]  это потенциально можно сделать,
[01:08:23.820 --> 01:08:25.820]  но это не быстро. Давайте я совсем просто это сделаю.
[01:08:25.820 --> 01:08:27.820]  Давайте как-нибудь обозначим,
[01:08:27.820 --> 01:08:29.820]  что пусть
[01:08:29.820 --> 01:08:31.820]  sparse
[01:08:31.820 --> 01:08:33.820]  sparse
[01:08:33.820 --> 01:08:35.820]  sparse
[01:08:35.820 --> 01:08:37.820]  sparse
[01:08:37.820 --> 01:08:39.820]  it
[01:08:39.820 --> 01:08:41.820]  it, нет, не так.
[01:08:41.820 --> 01:08:43.820]  ну k пусть будет, ладно,
[01:08:43.820 --> 01:08:45.820]  kt it
[01:08:45.820 --> 01:08:47.820]  это минимум
[01:08:47.820 --> 01:08:49.820]  на отрезка длины 2 степенька,
[01:08:49.820 --> 01:08:51.820]  который начинается в точке i.
[01:08:51.820 --> 01:08:53.820]  То есть это вот
[01:08:53.820 --> 01:08:55.820]  к точке i я прикладываю отрезок
[01:08:55.820 --> 01:08:57.820]  длины 2 степенька, и вот здесь вот считаю
[01:08:57.820 --> 01:08:59.820]  минимум.
[01:08:59.820 --> 01:09:01.820]  Вот на таком отрезке длины 2 степенька.
[01:09:01.820 --> 01:09:03.820]  Формально это просто минимум
[01:09:03.820 --> 01:09:05.820]  из
[01:09:05.820 --> 01:09:09.820]  ну я вот так напишу,
[01:09:09.820 --> 01:09:11.820]  j от i
[01:09:11.820 --> 01:09:13.820]  до i плюс 2 вкатой
[01:09:13.820 --> 01:09:15.820]  минус 1, а jt.
[01:09:15.820 --> 01:09:17.820]  Потому что если начало
[01:09:17.820 --> 01:09:19.820]  у меня это точка i,
[01:09:19.820 --> 01:09:21.820]  длина 2 вкатой, то конец это
[01:09:21.820 --> 01:09:23.820]  i плюс 2 вкатой минус 1.
[01:09:23.820 --> 01:09:25.820]  Если я на отрезках живу, я живу на отрезках сегодня.
[01:09:25.820 --> 01:09:27.820]  Да.
[01:09:27.820 --> 01:09:29.820]  sparse k и
[01:09:29.820 --> 01:09:31.820]  с двумя параметрами k и i.
[01:09:31.820 --> 01:09:33.820]  Это следующее, это минимум
[01:09:33.820 --> 01:09:35.820]  отрезка длины 2 в степени k,
[01:09:35.820 --> 01:09:37.820]  то есть k это то, в какой степени я беру 2,
[01:09:37.820 --> 01:09:39.820]  с началом в точке i.
[01:09:39.820 --> 01:09:41.820]  То есть вот есть у меня
[01:09:41.820 --> 01:09:43.820]  мой большой массив, я фиксирую
[01:09:43.820 --> 01:09:45.820]  начало точку i, фиксирую конец на расстоянии
[01:09:45.820 --> 01:09:47.820]  2 вкатой от него,
[01:09:47.820 --> 01:09:49.820]  ну и считаю минимум на этом, вот в этом окне.
[01:09:49.820 --> 01:09:51.820]  Минимум всех чисел
[01:09:51.820 --> 01:09:53.820]  вот с этого, с этого по вот это.
[01:09:53.820 --> 01:09:55.820]  Ну там i плюс 2 вкатой
[01:09:55.820 --> 01:09:57.820]  минус 1 у него номер будет.
[01:09:57.820 --> 01:09:59.820]  Да, сейчас, одну секунду,
[01:09:59.820 --> 01:10:01.820]  давайте я скажу, что если я внезапно вылезаю
[01:10:01.820 --> 01:10:03.820]  за пределы массива, то
[01:10:03.820 --> 01:10:05.820]  ну я просто считаю минимум среди тех элементов,
[01:10:05.820 --> 01:10:07.820]  которые есть. То есть вот здесь, если я внезапно
[01:10:07.820 --> 01:10:09.820]  переваливаю за n, то
[01:10:09.820 --> 01:10:11.820]  ну я их просто не рассматриваю.
[01:10:11.820 --> 01:10:13.820]  Да.
[01:10:13.820 --> 01:10:15.820]  Как мы выстроим этот вкат,
[01:10:15.820 --> 01:10:17.820]  который у нас есть?
[01:10:17.820 --> 01:10:19.820]  Вы торопитесь, я еще первый этаж шаг не раскал,
[01:10:19.820 --> 01:10:21.820]  вы уже во второй идете. Давайте сначала, давайте по порядку.
[01:10:21.820 --> 01:10:23.820]  Давайте я это сделаю.
[01:10:23.820 --> 01:10:25.820]  Так, ну давайте посчитаем.
[01:10:25.820 --> 01:10:27.820]  Смотрите, давайте я это буду насчитывать
[01:10:27.820 --> 01:10:29.820]  в порядке возрастания k.
[01:10:29.820 --> 01:10:31.820]  Давайте сначала это сделаем для k равно 0.
[01:10:31.820 --> 01:10:33.820]  Чему равно sparse
[01:10:33.820 --> 01:10:35.820]  нулевое i,
[01:10:35.820 --> 01:10:37.820]  для любого i?
[01:10:39.820 --> 01:10:41.820]  i,
[01:10:41.820 --> 01:10:43.820]  потому что что это такое?
[01:10:43.820 --> 01:10:45.820]  Это минимум на отрезке длины 2
[01:10:45.820 --> 01:10:47.820]  в степени 0, то есть на отрезке длины 1
[01:10:47.820 --> 01:10:49.820]  из одного элемента, который начинается в точке i.
[01:10:49.820 --> 01:10:51.820]  Но это только i.
[01:10:51.820 --> 01:10:53.820]  Там одно число, минимум из него, это оно само.
[01:10:53.820 --> 01:10:55.820]  Так, теперь давайте
[01:10:55.820 --> 01:10:57.820]  будем делать переход
[01:10:57.820 --> 01:10:59.820]  k, k плюс 1.
[01:10:59.820 --> 01:11:01.820]  Давайте я буду считать, что у меня все sparse
[01:11:01.820 --> 01:11:03.820]  с фиксированным индексом 1
[01:11:03.820 --> 01:11:05.820]  посчитаны, сделаю переход к следующему.
[01:11:05.820 --> 01:11:07.820]  Формально у меня будет такой цикл.
[01:11:07.820 --> 01:11:09.820]  k от 0 до, там скажем,
[01:11:09.820 --> 01:11:11.820]  логарифмы.
[01:11:11.820 --> 01:11:13.820]  Я считаю, что все sparse
[01:11:13.820 --> 01:11:15.820]  с первым индексом k посчитаны, хочу посчитать
[01:11:15.820 --> 01:11:17.820]  sparse k плюс 1.
[01:11:27.820 --> 01:11:29.820]  Так, картинка.
[01:11:29.820 --> 01:11:31.820]  Давайте сразу фор
[01:11:31.820 --> 01:11:33.820]  еще один по i я сделаю.
[01:11:33.820 --> 01:11:35.820]  От 1 до n.
[01:11:35.820 --> 01:11:37.820]  Вот здесь я хочу посчитать sparse
[01:11:37.820 --> 01:11:39.820]  k плюс 1i.
[01:11:39.820 --> 01:11:41.820]  Что такое sparse k плюс 1i?
[01:11:41.820 --> 01:11:43.820]  Значит я беру элемент с номером i,
[01:11:43.820 --> 01:11:45.820]  рисую от него
[01:11:45.820 --> 01:11:47.820]  окошко длины 2 в степени k плюс 1.
[01:11:47.820 --> 01:11:49.820]  Вот здесь я хочу посчитать sparse k
[01:11:49.820 --> 01:11:51.820]  плюс 1i.
[01:11:51.820 --> 01:11:53.820]  Что такое sparse k плюс 1i?
[01:11:53.820 --> 01:11:55.820]  Значит я беру элемент с номером i,
[01:11:55.820 --> 01:11:57.820]  окошко длины 2 в степени k плюс 1
[01:11:57.820 --> 01:11:59.820]  и считаю минимум
[01:11:59.820 --> 01:12:01.820]  среди всех этих элементов.
[01:12:01.820 --> 01:12:03.820]  Но у меня
[01:12:03.820 --> 01:12:05.820]  уже посчитаны минимумы на всех отрезках
[01:12:05.820 --> 01:12:07.820]  меньшей длины. На всех отрезках
[01:12:07.820 --> 01:12:09.820]  степени 2 меньше длины.
[01:12:09.820 --> 01:12:11.820]  Тогда я просто могу
[01:12:11.820 --> 01:12:13.820]  этот большой отрезок поделить пополам.
[01:12:13.820 --> 01:12:15.820]  Здесь длины будут как раз по 2 в катой.
[01:12:15.820 --> 01:12:17.820]  И минимумы на них я уже знаю.
[01:12:17.820 --> 01:12:19.820]  Потому что это sparse
[01:12:19.820 --> 01:12:21.820]  с катого слоя.
[01:12:21.820 --> 01:12:23.820]  Я знаю минимум здесь и минимум здесь.
[01:12:23.820 --> 01:12:25.820]  Я выбираю из них минимальное число
[01:12:25.820 --> 01:12:27.820]  и кладу в sparse k плюс 1i.
[01:12:27.820 --> 01:12:29.820]  Поэтому здесь
[01:12:29.820 --> 01:12:31.820]  можно написать так. Давайте напишем,
[01:12:31.820 --> 01:12:33.820]  что j это минимум из
[01:12:37.820 --> 01:12:39.820]  n и
[01:12:39.820 --> 01:12:41.820]  i плюс 2 в катой.
[01:12:41.820 --> 01:12:43.820]  Потому что если здесь
[01:12:43.820 --> 01:12:45.820]  индекс i, то здесь индекс.
[01:12:45.820 --> 01:12:47.820]  Вот этот первый, начальный индекс
[01:12:47.820 --> 01:12:49.820]  второго блока.
[01:12:49.820 --> 01:12:51.820]  Ну какая разница? Можно от 0.
[01:12:51.820 --> 01:12:53.820]  У меня просто массив от 1.
[01:12:53.820 --> 01:12:55.820]  Если вам приятнее от 0,
[01:12:55.820 --> 01:12:57.820]  то сделайте в 0 индексация.
[01:12:57.820 --> 01:12:59.820]  Неважно.
[01:12:59.820 --> 01:13:01.820]  Если у меня здесь начинается
[01:13:01.820 --> 01:13:03.820]  в точке i, то здесь по идее начинается в точке
[01:13:03.820 --> 01:13:05.820]  i плюс 2 в катой. Но если внезапно
[01:13:05.820 --> 01:13:07.820]  оно вылезает за n, то нужно еще обрубиться
[01:13:07.820 --> 01:13:09.820]  и сказать, что оно n.
[01:13:09.820 --> 01:13:11.820]  Здесь написано i плюс 2 в катой.
[01:13:11.820 --> 01:13:13.820]  И тогда
[01:13:13.820 --> 01:13:15.820]  sparse
[01:13:15.820 --> 01:13:17.820]  k плюс 1i
[01:13:17.820 --> 01:13:19.820]  это просто
[01:13:19.820 --> 01:13:21.820]  минимум из
[01:13:21.820 --> 01:13:23.820]  вот этого блока
[01:13:23.820 --> 01:13:25.820]  и вот этого.
[01:13:25.820 --> 01:13:27.820]  Это sparse cataite, это sparse cataigite.
[01:13:27.820 --> 01:13:29.820]  Ну вот здесь это
[01:13:29.820 --> 01:13:31.820]  и напишем.
[01:13:31.820 --> 01:13:33.820]  Минимум из sparse cataite
[01:13:35.820 --> 01:13:37.820]  sparse
[01:13:37.820 --> 01:13:39.820]  cataigite.
[01:13:43.820 --> 01:13:45.820]  Все.
[01:13:49.820 --> 01:13:51.820]  Первый шаг какой-то уже сделан.
[01:13:51.820 --> 01:13:53.820]  Еще раз.
[01:13:53.820 --> 01:13:55.820]  Я иду в порядке возрастания k.
[01:13:55.820 --> 01:13:57.820]  Вот у меня k перебивается от 0 до логарифма в порядке
[01:13:57.820 --> 01:13:59.820]  возрастания.
[01:13:59.820 --> 01:14:01.820]  Я считаю, что на всех отрезках длины 2 в катой
[01:14:01.820 --> 01:14:03.820]  ответ уже посчитан.
[01:14:03.820 --> 01:14:05.820]  Теперь я хочу посчитать ответ
[01:14:05.820 --> 01:14:07.820]  на отрезки длины 2 в степени k плюс 1.
[01:14:07.820 --> 01:14:09.820]  Это делается очень просто.
[01:14:09.820 --> 01:14:11.820]  Я разбиваю мой большой отрезок
[01:14:11.820 --> 01:14:13.820]  на два равных длины 2 в катой
[01:14:13.820 --> 01:14:15.820]  с левой справа.
[01:14:15.820 --> 01:14:17.820]  И поскольку на них ответ уже посчитан,
[01:14:17.820 --> 01:14:19.820]  это 2 в катой,
[01:14:19.820 --> 01:14:21.820]  на них минимум уже известно.
[01:14:21.820 --> 01:14:23.820]  Это sparse cataite, sparse cataigite.
[01:14:23.820 --> 01:14:25.820]  То мне нужно просто взять минимум отсюда,
[01:14:25.820 --> 01:14:27.820]  и взять из них минимальное.
[01:14:27.820 --> 01:14:29.820]  Ровно это я и делаю.
[01:14:29.820 --> 01:14:31.820]  Я нахожу позицию,
[01:14:31.820 --> 01:14:33.820]  где находится начало второго отрезка,
[01:14:33.820 --> 01:14:35.820]  то есть левая половина начинается в точке i,
[01:14:35.820 --> 01:14:37.820]  правая начинается в точке i плюс 2 в катой.
[01:14:37.820 --> 01:14:39.820]  Я беру из них sparse,
[01:14:39.820 --> 01:14:41.820]  которые уже посчитаны,
[01:14:41.820 --> 01:14:43.820]  выбираю минимальное значение,
[01:14:43.820 --> 01:14:45.820]  и возвращаю в качестве ответа.
[01:14:47.820 --> 01:14:49.820]  Согласны?
[01:14:49.820 --> 01:14:51.820]  Ну и видно тогда, что это работает за n log n.
[01:14:53.820 --> 01:14:55.820]  Потому что здесь у меня цикл логарифмический,
[01:14:55.820 --> 01:14:57.820]  здесь линейный,
[01:14:57.820 --> 01:14:59.820]  а дальше там вот единица внутри.
[01:14:59.820 --> 01:15:01.820]  Поэтому смарная n log n.
[01:15:03.820 --> 01:15:05.820]  Единственное, давайте вот эту 2 в катой
[01:15:05.820 --> 01:15:07.820]  еще как-то напишем.
[01:15:07.820 --> 01:15:09.820]  К сожалению, мы в языке проигрываем,
[01:15:09.820 --> 01:15:11.820]  не можем писать 2 в катой.
[01:15:11.820 --> 01:15:13.820]  Можно писать вот так.
[01:15:13.820 --> 01:15:15.820]  1 меньше меньше k.
[01:15:15.820 --> 01:15:19.820]  Это будет считаться как 2 в степеника.
[01:15:19.820 --> 01:15:21.820]  Что это такое?
[01:15:21.820 --> 01:15:23.820]  Это битовый сдвиг.
[01:15:23.820 --> 01:15:25.820]  Представьте, вы написали единицу,
[01:15:25.820 --> 01:15:27.820]  представьте регистр,
[01:15:27.820 --> 01:15:29.820]  32 или 64 битика,
[01:15:29.820 --> 01:15:31.820]  как хранится единица?
[01:15:31.820 --> 01:15:33.820]  Это 0,0,0,0 и в конце единица.
[01:15:33.820 --> 01:15:35.820]  Теперь представьте, что вы это сдвигаете влево.
[01:15:35.820 --> 01:15:37.820]  Вот у вас было 0,0,0,0,0,0,0,1.
[01:15:39.820 --> 01:15:41.820]  Вы сдвинули это влево.
[01:15:41.820 --> 01:15:43.820]  Причем здесь у вас граница регистра.
[01:15:43.820 --> 01:15:47.820]  Понятно, что тогда единица станет как раз на катое место.
[01:15:47.820 --> 01:15:49.820]  Ну и по умолчанию, при сдвиге считается,
[01:15:49.820 --> 01:15:51.820]  что все, что было правее, станет нулями.
[01:15:51.820 --> 01:15:53.820]  По умолчанию заполняется нулями.
[01:15:53.820 --> 01:15:55.820]  Ну и слева все останутся нули.
[01:15:55.820 --> 01:15:57.820]  Поэтому как раз в дуэйчной системе
[01:15:57.820 --> 01:15:59.820]  счастливения это сдвиг единицы с нулевой позиции
[01:15:59.820 --> 01:16:01.820]  на катую.
[01:16:01.820 --> 01:16:03.820]  Это как раз 2 в катой.
[01:16:03.820 --> 01:16:05.820]  Поэтому если писать 1 меньше меньше k,
[01:16:05.820 --> 01:16:07.820]  то это будет то, что нужно.
[01:16:07.820 --> 01:16:09.820]  Ровно 2 в катой.
[01:16:09.820 --> 01:16:11.820]  Так, хорошо.
[01:16:11.820 --> 01:16:13.820]  Ну все, первым шагом разобрались.
[01:16:13.820 --> 01:16:15.820]  Теперь давайте второй.
[01:16:15.820 --> 01:16:17.820]  Тут проблема только одна.
[01:16:17.820 --> 01:16:19.820]  Как найти вот это максимальное k,
[01:16:19.820 --> 01:16:21.820]  не превосходящие длины отрезка?
[01:16:21.820 --> 01:16:23.820]  Потому что все остальное это просто
[01:16:23.820 --> 01:16:25.820]  обращение к спарсу.
[01:16:25.820 --> 01:16:27.820]  Мы знаем k, мы знаем начало здесь,
[01:16:27.820 --> 01:16:29.820]  мы знаем начало здесь, ну как-нибудь высчитаем.
[01:16:29.820 --> 01:16:31.820]  Это r-2 в катой плюс 1.
[01:16:31.820 --> 01:16:33.820]  Вот эта вот точка.
[01:16:33.820 --> 01:16:35.820]  Начало этой вот половины.
[01:16:35.820 --> 01:16:37.820]  Как-нибудь посчитаем.
[01:16:37.820 --> 01:16:39.820]  Ну дальше спарс вот отсюда берем, спарс вот отсюда.
[01:16:39.820 --> 01:16:41.820]  И минимум из них это ответ.
[01:16:41.820 --> 01:16:43.820]  Поэтому тут проблем нет. Самое сложное
[01:16:43.820 --> 01:16:45.820]  в каком-то смысле это вот эта вот штука.
[01:17:07.820 --> 01:17:09.820]  Так, хорошо.
[01:17:09.820 --> 01:17:11.820]  Ну вообще говоря,
[01:17:11.820 --> 01:17:13.820]  в плюсах
[01:17:13.820 --> 01:17:15.820]  на некоторых компиляторах
[01:17:15.820 --> 01:17:17.820]  есть какие-то встроенные функции,
[01:17:17.820 --> 01:17:19.820]  которые вам позволяют находить вот такое.
[01:17:19.820 --> 01:17:21.820]  Без лишнего кода.
[01:17:21.820 --> 01:17:23.820]  Это что-то типа там builtint,
[01:17:23.820 --> 01:17:25.820]  ktl, ktlz,
[01:17:25.820 --> 01:17:27.820]  что-то вот такое вот.
[01:17:27.820 --> 01:17:29.820]  Потому что по факту, что такое вот это вот число.
[01:17:29.820 --> 01:17:31.820]  Смотрите, давайте я как-нибудь обозначу,
[01:17:31.820 --> 01:17:33.820]  что пусть t это r-l плюс 1.
[01:17:33.820 --> 01:17:35.820]  Давайте t напишем
[01:17:35.820 --> 01:17:37.820]  в двоечном системе числения опять.
[01:17:37.820 --> 01:17:39.820]  Ну там она это сначала кучу нулей,
[01:17:39.820 --> 01:17:41.820]  потом что-то вот такое, например.
[01:17:41.820 --> 01:17:43.820]  Вот что это тут tele.
[01:17:43.820 --> 01:17:45.820]  Тогда что по факту такое
[01:17:45.820 --> 01:17:47.820]  максимальная степень двойки,
[01:17:47.820 --> 01:17:49.820]  не превосходящая t?
[01:17:49.820 --> 01:17:51.820]  Ну это вот самая левая единица.
[01:17:51.820 --> 01:17:53.820]  Это вот эта вот единица, а дальше все нулями.
[01:17:53.820 --> 01:17:55.820]  Потому что что такое
[01:17:55.820 --> 01:17:59.820]  Потому что что такое максимальная степень двойки, не происходящая t?
[01:17:59.820 --> 01:18:01.820]  Здесь единицу ставить нельзя, потому что было бы больше.
[01:18:01.820 --> 01:18:03.820]  Если вы поставите здесь единицу, а здесь все нулями,
[01:18:03.820 --> 01:18:05.820]  то это как раз степень двойки, не происходящая t.
[01:18:05.820 --> 01:18:13.820]  Чтобы найти максимальное k, вам достаточно просто в числе найти самую левую единицу.
[01:18:13.820 --> 01:18:15.820]  В некоторых эмпиляторах это и так уже есть.
[01:18:15.820 --> 01:18:21.820]  Если вам интересно внутренними функциями воспользоваться, которые уже есть,
[01:18:21.820 --> 01:18:25.820]  то погуглите, что это самая, получается, позиция самой старшей единицы.
[01:18:25.820 --> 01:18:29.820]  Позиция старшего бита.
[01:18:31.820 --> 01:18:37.820]  Потому что если я знаю, что эта единица стоит на седьмом месте,
[01:18:37.820 --> 01:18:39.820]  то значит k равно 7.
[01:18:41.820 --> 01:18:44.820]  Ну хорошо, давайте считать, что у нас там нет такого в компиляторе,
[01:18:44.820 --> 01:18:46.820]  давайте это руками считаем.
[01:18:46.820 --> 01:18:49.820]  Давайте мы просто заведем какой-нибудь массив,
[01:18:49.820 --> 01:18:51.820]  пауэр я его назову.
[01:18:51.820 --> 01:18:55.820]  Значит пусть пауэр от t это то самое максимальное k,
[01:18:55.820 --> 01:18:57.820]  что 2 в ката не превосходит t.
[01:18:57.820 --> 01:18:59.820]  Давайте просто все это предпосчитаем.
[01:19:03.820 --> 01:19:07.820]  Поэтому можно взять логарифм и целую часть вниз.
[01:19:07.820 --> 01:19:09.820]  Можно.
[01:19:09.820 --> 01:19:11.820]  Ну на ваш страх и риск, скажем так.
[01:19:11.820 --> 01:19:15.820]  Потому что логарифм, это функция уже не целый число, это дабл.
[01:19:15.820 --> 01:19:17.820]  Там куда он округлится, бог его знает.
[01:19:17.820 --> 01:19:21.820]  Можно, но не совсем безопасно, скажу так.
[01:19:21.820 --> 01:19:25.820]  Побитовый сдвиг влево, сдвиг на 2.
[01:19:25.820 --> 01:19:27.820]  Практически оставляем на 3 ничего.
[01:19:27.820 --> 01:19:29.820]  Не понял, побитовый сдвиг...
[01:19:29.820 --> 01:19:31.820]  Чего?
[01:19:31.820 --> 01:19:33.820]  У нас есть тест.
[01:19:33.820 --> 01:19:35.820]  Да.
[01:19:35.820 --> 01:19:37.820]  Побитовый сдвигает.
[01:19:37.820 --> 01:19:39.820]  Влево на 1?
[01:19:39.820 --> 01:19:41.820]  Ну окей, у вас будет вот такое число.
[01:19:41.820 --> 01:19:43.820]  Зачем?
[01:19:43.820 --> 01:19:45.820]  Не-не-не.
[01:19:45.820 --> 01:19:47.820]  Сдвигается то, что...
[01:19:47.820 --> 01:19:49.820]  Вы вот это сдвинули, это все сохранилось,
[01:19:49.820 --> 01:19:51.820]  и только та часть, которая не было.
[01:19:51.820 --> 01:19:53.820]  Вам же нужно вот эти последние биты как-то заполнить.
[01:19:53.820 --> 01:19:55.820]  Только те, которых не было, заполняются нулями.
[01:19:55.820 --> 01:19:57.820]  Вот.
[01:19:57.820 --> 01:19:59.820]  Давайте предпосчитаем просто.
[01:19:59.820 --> 01:20:01.820]  Смотрите, у меня вот эта вот t, это длина отрезка.
[01:20:01.820 --> 01:20:03.820]  Вот эта вот t, это длина отрезка.
[01:20:03.820 --> 01:20:05.820]  С l по r.
[01:20:05.820 --> 01:20:07.820]  Но разных длин у меня всего n.
[01:20:07.820 --> 01:20:09.820]  1, 2 и так далее n.
[01:20:09.820 --> 01:20:11.820]  Давайте для всех предпосчитаем и победим.
[01:20:13.820 --> 01:20:15.820]  Вот.
[01:20:15.820 --> 01:20:17.820]  Ну начало какое?
[01:20:17.820 --> 01:20:19.820]  Если t единица,
[01:20:19.820 --> 01:20:21.820]  то k это ноль.
[01:20:21.820 --> 01:20:23.820]  Максимальная степень двойки, не предпочитающая единица,
[01:20:23.820 --> 01:20:25.820]  это нулевая степень двойки.
[01:20:25.820 --> 01:20:27.820]  Вот.
[01:20:27.820 --> 01:20:29.820]  Ну а дальше давайте идти в цикле
[01:20:29.820 --> 01:20:31.820]  по t от 2 до n
[01:20:31.820 --> 01:20:33.820]  и считать, какой будет правильная pv от t.
[01:20:33.820 --> 01:20:35.820]  Значит, t от 2 до n.
[01:20:35.820 --> 01:20:37.820]  Вот.
[01:20:37.820 --> 01:20:39.820]  Чему равно pv от t, вопрос.
[01:20:39.820 --> 01:20:41.820]  Здесь я хочу посчитать, чему равно pv от t.
[01:20:45.820 --> 01:20:47.820]  Вот.
[01:20:47.820 --> 01:20:49.820]  Ну можно сделать опять таки многими способами.
[01:20:49.820 --> 01:20:51.820]  Вопрос, а когда pv от t отличается
[01:20:51.820 --> 01:20:53.820]  от pv от t-1?
[01:20:53.820 --> 01:20:55.820]  Когда мы пришли
[01:20:55.820 --> 01:20:57.820]  к очередной степени двойки.
[01:20:57.820 --> 01:20:59.820]  То есть почти всегда у меня работала бы такая штука.
[01:20:59.820 --> 01:21:01.820]  Давайте ее прямо сразу напишу.
[01:21:01.820 --> 01:21:03.820]  pvt это pvt-1.
[01:21:03.820 --> 01:21:05.820]  Потому что, если у меня
[01:21:05.820 --> 01:21:07.820]  при переходе от t-1 к t
[01:21:07.820 --> 01:21:09.820]  я не перешел за новую степень двойки,
[01:21:09.820 --> 01:21:11.820]  у меня не поменялся старший бит,
[01:21:11.820 --> 01:21:13.820]  вот эта единица была как была, здесь так и осталась,
[01:21:13.820 --> 01:21:15.820]  то у меня k осталось таким же, как было.
[01:21:15.820 --> 01:21:17.820]  Поэтому мне почти всегда можно просто взять предыдущий ответ.
[01:21:17.820 --> 01:21:19.820]  Единственный случай, когда она увеличится
[01:21:19.820 --> 01:21:21.820]  на единицу, это когда t это новая степень двойки.
[01:21:21.820 --> 01:21:23.820]  Значит, я здесь должен написать следующее.
[01:21:23.820 --> 01:21:25.820]  Если t это степень двойки,
[01:21:25.820 --> 01:21:27.820]  то вот это вот надо увеличить на единицу.
[01:21:29.820 --> 01:21:31.820]  Значит, как проверить, что t это степень двойки?
[01:21:31.820 --> 01:21:33.820]  Ну давайте я напишу универсальный рецепт,
[01:21:33.820 --> 01:21:35.820]  значит, потом мы его разберем.
[01:21:49.820 --> 01:21:51.820]  Вот.
[01:21:51.820 --> 01:21:53.820]  Давайте перепишу, криво как-то вышло.
[01:21:53.820 --> 01:21:55.820]  Восхищательный знак,
[01:21:55.820 --> 01:21:57.820]  и здесь конъюнкция t и t-1.
[01:21:57.820 --> 01:21:59.820]  Побитывая i,
[01:21:59.820 --> 01:22:01.820]  t и t-1.
[01:22:01.820 --> 01:22:03.820]  Вот.
[01:22:03.820 --> 01:22:05.820]  Ну давайте поймем, почему это работает.
[01:22:05.820 --> 01:22:07.820]  Давайте, например, степень двойки.
[01:22:07.820 --> 01:22:09.820]  Представьте, что t это степень двойки.
[01:22:09.820 --> 01:22:11.820]  Пусть t это степень двойки,
[01:22:11.820 --> 01:22:13.820]  значит, его битовая запись это 1
[01:22:13.820 --> 01:22:15.820]  и куча нулей справа.
[01:22:15.820 --> 01:22:17.820]  Ну, старшие нули тоже есть.
[01:22:17.820 --> 01:22:19.820]  Что такое t-1 тогда?
[01:22:19.820 --> 01:22:21.820]  Это, наоборот,
[01:22:21.820 --> 01:22:23.820]  куча единиц вот здесь.
[01:22:23.820 --> 01:22:25.820]  t-1, это когда у вас
[01:22:25.820 --> 01:22:27.820]  старшая единица зануляется,
[01:22:27.820 --> 01:22:29.820]  а здесь будет куча единиц.
[01:22:29.820 --> 01:22:31.820]  Но если вы их побитого сандите,
[01:22:31.820 --> 01:22:33.820]  то есть возьмете побитовое i,
[01:22:33.820 --> 01:22:35.820]  у вас побитовое i будет нулем.
[01:22:35.820 --> 01:22:37.820]  Здесь нули, здесь 1 нуль,
[01:22:37.820 --> 01:22:39.820]  это 0, здесь тоже 0 будет побитовое i.
[01:22:39.820 --> 01:22:41.820]  Как раз восхищательный знак проверит,
[01:22:41.820 --> 01:22:43.820]  что это 0.
[01:22:43.820 --> 01:22:45.820]  Ну или можно было написать вот это вот равно 0,
[01:22:45.820 --> 01:22:47.820]  что вот это побитовое i равно 0.
[01:22:47.820 --> 01:22:49.820]  То есть если t это степень двойки,
[01:22:49.820 --> 01:22:51.820]  t равно 0.
[01:22:53.820 --> 01:22:55.820]  Но если t это не степень двойки,
[01:22:55.820 --> 01:22:57.820]  значит у нее есть хотя бы две единицы
[01:22:57.820 --> 01:22:59.820]  в двоичной записи.
[01:22:59.820 --> 01:23:01.820]  Вот здесь единица и здесь единица.
[01:23:01.820 --> 01:23:03.820]  Когда вы вычтите,
[01:23:03.820 --> 01:23:05.820]  у вас, по крайней мере,
[01:23:05.820 --> 01:23:07.820]  старшая останется на месте.
[01:23:07.820 --> 01:23:09.820]  То есть вы вычитаете единичку,
[01:23:09.820 --> 01:23:11.820]  у вас вот здесь что-то уменьшится,
[01:23:11.820 --> 01:23:13.820]  возможно эта единица превратится в 0,
[01:23:13.820 --> 01:23:15.820]  но старшая останется на месте.
[01:23:15.820 --> 01:23:17.820]  И значит в их конъюнкции эта старшая единица
[01:23:17.820 --> 01:23:19.820]  превратится в 0.
[01:23:19.820 --> 01:23:21.820]  И будет неверно,
[01:23:21.820 --> 01:23:23.820]  что у них эта штука 0.
[01:23:23.820 --> 01:23:25.820]  То есть здесь их конъюнкция
[01:23:25.820 --> 01:23:27.820]  будет не нулем.
[01:23:27.820 --> 01:23:29.820]  А я увеличу на единицу
[01:23:29.820 --> 01:23:31.820]  только в случае нуля.
[01:23:31.820 --> 01:23:33.820]  Ну и все, и дальше я вот здесь вот в этом втором
[01:23:33.820 --> 01:23:35.820]  при ответе на запрос
[01:23:35.820 --> 01:23:37.820]  я считаю k как pv от t,
[01:23:37.820 --> 01:23:39.820]  ну и беру с парсу двух штук.
[01:23:39.820 --> 01:23:41.820]  Все, спасибо.
