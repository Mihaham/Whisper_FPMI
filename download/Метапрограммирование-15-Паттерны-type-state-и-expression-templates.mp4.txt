[00:00.000 --> 00:13.240]  Итак, всем привет. Спасибо, что пришли попозже. Там очень важные вопросы обсуждались на предыдущей
[00:13.240 --> 00:25.960]  пары, отличие барокко от классицизма. Линия прямая, волнистая. Барокко – она волнистая, а прямая – это
[00:25.960 --> 00:34.360]  классицизма. Но от культуры к науке сегодня я вам наконец-то расскажу полезные паттерны. Вот прям
[00:34.360 --> 00:41.000]  такие метапрожные паттерны, которые можно использовать на практике. Это даст вам даже пользу
[00:41.000 --> 00:50.840]  какую-то. Но паттерны невозможно понять в вакууме. Да и, блин, по-моему, у них нету даже никакого
[00:50.840 --> 00:57.280]  описания нормального. Это просто такая штука, которая в народе обсуждается. Вот что-то мы там
[00:57.280 --> 01:04.880]  называем type-statem, что-то называем expression-template. Ну ничего не понятно. Поэтому предлагаю идти от
[01:04.880 --> 01:10.720]  частного к общему, уловить какую-то общую связь между всем происходящим, понять, что все это вот
[01:10.720 --> 01:16.840]  на самом деле – это вот оно. И еще, что это примерно одно и то же на самом деле. Различия тут какие-то
[01:17.320 --> 01:26.720]  косметические. Итак, первым нашим кейсом будут ранжи. Ранжи мы уже видели, уже как бы понимаем,
[01:26.720 --> 01:32.520]  что там происходит. Правда ведь? Происходит что-то вот такое. Берем какой-то контейнер,
[01:32.520 --> 01:40.160]  какие-то юхи навешиваем, получаем какой-то став. Ну и что будет, если мы… Ну вот это вот
[01:40.160 --> 01:45.840]  притефункшн использует и строку возвращает функция. Что будет, если мы посмотрим на тип?
[01:45.840 --> 01:52.800]  Мы уже знаем, что мы внезапно увидим, что мы запомнили всю историю изменений. Начали с
[01:52.800 --> 01:57.880]  вектора. Тут ну какой-то маленький костыль, с которым мы так до конца не разобрались, ну бог с
[01:57.880 --> 02:05.080]  ним. И take view. Ну вот он take был. Дальше фильтр навесили. Ну вот он фильтр. Ну и лямбда тоже
[02:05.080 --> 02:13.720]  сохранилась. Прямо в типе получилась такая матрешка из того, что происходило. Окей? Кейс два.
[02:13.720 --> 02:20.360]  Черт, возможно это будет очень короткая лекция. Вот я хотел заранее сказать. Обычно лекции
[02:20.360 --> 02:25.920]  прошлогодние, поэтому с ними более-менее все понятно по таймингу и по содержанию. Это оригинальная,
[02:25.920 --> 02:34.120]  вчера за пару часов накиданная. Возможно сейчас будет не очень хорошо. Но пока идем бодро. Второй
[02:34.120 --> 02:40.600]  кейс. Фоли. Помните такую? Да, на конкарнсе вам про него Липовский скорее всего что-то
[02:40.600 --> 02:45.840]  говорил, если у вас было конкарнсе, что мол от Фейсбуке ребята сделали себе вместо стандартной
[02:45.840 --> 02:53.680]  библиотеки кастомную. Среди прочего в ней есть свои фьючи, которые там гораздо лучше стандартных,
[02:53.680 --> 03:00.560]  тем что это фьючи, а не какая-то костыльная фигня. Юнифекс тоже от Фейсбука, но он похоронен.
[03:00.560 --> 03:09.120]  И там не фьючи, а по-другому. Сейчас дойдем до всего. Да-да-да. Ну вот есть Промес. Поднимите
[03:09.120 --> 03:17.600]  руку, если вы не умеете работать со фьючами. Это плохо. Короче, фьючи — это такой смешной канал
[03:17.600 --> 03:27.440]  от одного потока к другому. И по этому каналу можно посылать ровно один объект. Промес — это
[03:27.440 --> 03:34.720]  входная дырка, а фьюча — пока здесь ее нет. Вот некоторые фьючи — это выходная дырка, из которой
[03:34.720 --> 03:40.600]  прилетают нам данные. В Промес один раз послали Инт, из фьючи один раз получили Инт. В стандарте
[03:40.600 --> 03:49.600]  они тоже есть. Но проблема в том, что стандартный фьюч необходимо сидеть и реально ждать потоку,
[03:49.600 --> 04:01.080]  пока не прилетит Инт. И это бывает очень неудобно. Тут сложно в двух словах объяснить, но вот практика
[04:01.080 --> 04:08.080]  показала, что неэффективно сидеть и в трыде, ждать, пока нам прилетят данные. Там есть такой синхронное
[04:08.080 --> 04:15.160]  ожидание. Поэтому придумали... Ну на самом деле фьючи и стандарты — это урезанные нормальные
[04:15.160 --> 04:20.800]  фьючи. Вот нормальные фьючи придумали ребята из Твиттера, и весь Твиттер на них работает. И их
[04:20.800 --> 04:26.240]  суть не в том, что можно дождаться результата, который вам прилетит из фьюча, из этого выхода,
[04:26.240 --> 04:33.280]  а в том, что можно повесить колбэк на момент, когда прилетит результат. Такое синхронное
[04:33.280 --> 04:40.200]  программирование, колбэки лучше там активных... Или там даже ну просто ожиданий. И вот это как бы
[04:40.600 --> 04:48.760]  общая шняга, о которой постоянно говорят последние много лет в любых языках программирования. На
[04:48.760 --> 04:55.600]  самом деле все, конечно, не так просто, но вот — фу, это колбэк. И вот здесь вешают какой-то колбэк
[04:55.600 --> 05:02.400]  на значение, которое потом прилетит фьючу. То есть вот это вот via возвращает фьючу. Почему
[05:02.400 --> 05:09.440]  пока не понятно — ну ладно. И эту фьючу мы превращаем в другую фьючу, навесив колбэк. Вот
[05:09.440 --> 05:15.360]  фу, Инд, который прилетит, обработает как-то, ну в квадрат, например, возведет, или скастит
[05:15.360 --> 05:20.320]  к флоту. И мы получим новую фьючу, которая уже что-то другое возвращает. И вот можно так колбэки
[05:20.320 --> 05:25.960]  навешивать, навешивать, навешивать и такую цепочку вычислений получить. Вот за три минуты что такое
[05:25.960 --> 05:36.400]  фьюча? Какая проблема у вас с этой идеей есть? Вот один поток отправляет данные в промисс, посылает
[05:36.400 --> 05:42.640]  их. А кто-то другой совсем потом в другом месте пытается дождаться уже там после всех колбэков
[05:42.640 --> 05:50.120]  обработанного результата. Вопрос — какой поток будет выполнять колбэк? Вот этот фу, вот который
[05:50.120 --> 05:56.440]  отправил или который хочет принять? Ну вот вообще говоря непонятно. Поэтому ввели понятие экзекютера
[05:56.440 --> 06:05.680]  тот, кто будет запускать колбэк, грубо говоря. И вот сказали, что мы хотим взять промисс получить
[06:05.680 --> 06:13.800]  фьючу и сразу ей указать экзекютер, на котором мы будем исполняться. Что вот мы хотим, чтобы колбэки,
[06:13.800 --> 06:19.520]  которые мы потом выдадим, они вот на этом потоке исполнялись. Ну конечно нельзя просто на потоке
[06:19.520 --> 06:24.640]  что-то исполнить, там трэдпулы на самом деле, но неважно. Короче указываем, где исполнять вот этот
[06:24.640 --> 06:31.600]  колбэк. В общем и целом проблематика понятна. Вот мы хотим указать, где исполнять вот этот колбэк.
[06:31.600 --> 06:37.920]  В целом больше здесь ничего понимать не надо. Вот. Ну для кого-то это все было повторение. Но мы же
[06:37.920 --> 06:42.560]  можем вот так написать. Ну то есть синтаксис вот такой в целом и фьюч. Вот вы взяли промисс,
[06:42.560 --> 06:49.040]  получили фьючу. Там такой как бы билдер, навесили экзекютер, навесили колбэк. Но
[06:49.040 --> 06:55.240]  можем поменять местами эти строчки. И что в такой ситуации делать? Если мы уже повесили колбэк,
[06:55.240 --> 07:02.360]  то есть другого потока уже могло прилететь значение. И у нас уже есть значение и колбэк. И мы как бы
[07:02.360 --> 07:09.080]  уже хотим исполнять колбэк, но еще не можем, потому что не знаем экзекютера. И начинаются всякие вот
[07:09.080 --> 07:15.120]  нестыковки. Начинаются костыли, какая-то синхронизация дополнительная типа давайте подождем пока
[07:15.120 --> 07:26.040]  выставят экзекютер. Можно проще. Фейсбу... черт. Да, окей, ладно, пусть так будет. Фейсбуки
[07:26.040 --> 07:31.360]  придумали вот такую хитрую схему. Вместо того, чтобы испромисли доставать просто фьючу,
[07:31.360 --> 07:37.960]  мы достаем некую псевдофьючу, семифьючу. Вот у семифьючи нельзя навесить колбэк.
[07:37.960 --> 07:42.840]  Единственное, что с ней можно сделать, это навесить экзекютер. То есть вот это вот via
[07:42.840 --> 07:48.600]  экзекютер вызвать. И вот как только мы экзекютер навесили, мы получим уже настоящую фьючу,
[07:48.600 --> 07:56.640]  на которую можно повесить колбэк. То есть get семифьючу, возвращает семифьючу, via уже фьючу.
[07:56.640 --> 08:04.240]  Колбэк навесили, все еще фьюча, но может уже другого типа. Почему это круто? Потому что если мы
[08:04.240 --> 08:09.320]  опять накосячим и пытаемся местами поменять или вообще забудем эту строчку с via, нам сразу ошибку
[08:09.320 --> 08:16.280]  выдадут. Что вот этого метода then value его нету в семифьюча. То есть мы на уровне системы типов
[08:16.280 --> 08:24.520]  предостерегаем себя от некоторых ошибок. Вот такой кейс. Почувствовал кто-то связь вот этого с
[08:24.520 --> 08:40.560]  предыдущим. С рэнжами. Вот рэнжи был ли кейс, вот фьюча в фейсбуке. Ну как бы да. Но тут ничего не
[08:40.560 --> 08:54.040]  обращивается типами. Тут просто два разных типа. Семифьюча есть и есть фьюча. Вот их два. Ну да,
[08:54.040 --> 09:09.600]  можно и тут пайп навесить. Тип. Это тупые фьючи, никаких концептов. Все на стэке хранится без
[09:09.600 --> 09:20.600]  пендрежа. Они не ленивые. На куче в смысле. Все не ленивое, все активное. Вот тупой вариант. Ну окей,
[09:20.600 --> 09:27.240]  чтобы лучше прочувствовать нам нужен третий кейс, хотя он конечно не поможет нам наверное. Да. Ну
[09:27.240 --> 09:33.920]  стандарт хотят запихнуть наконец-то что-то вроде фьюч, которое стандартизирует наконец-то всякое
[09:33.920 --> 09:39.840]  многопоточное программирование. Прям вот нормально стандартизирует. И код на этой штуке выглядит вот
[09:39.840 --> 09:51.920]  примерно вот так. Я знаю ничего не понятно. Да, может даже кому-то не нравится. Да, тут много чего
[09:51.920 --> 09:57.040]  можно по-другому писать, но в целом это должно казаться вам похожим на самом деле на рэнжи.
[09:57.040 --> 10:11.760]  Потому что авторы у этих штук одни и те же. На что? Может быть. Может быть. Но это везде теперь есть.
[10:11.760 --> 10:17.680]  Это и в фьючах, которые в твиттере придумали изначально. Там тоже венол был. Но что происходит?
[10:17.680 --> 10:23.320]  Вот какой-то конструктор зовется, чтобы что-то получить. Потом он куда-то пайпается. То есть такой
[10:23.320 --> 10:29.120]  поток данных. Потом эти данные. Вот это вот он. Это как бы тот же самый via, который мы только что
[10:29.120 --> 10:35.720]  видели. Вот via и какой-то, via и executor. Вот этот он, это то же самое. Только тут переменовали
[10:35.720 --> 10:41.360]  executor в scheduler. Потом там какой-то венол еще комбинируется несколько значений. То есть это
[10:41.360 --> 10:47.800]  в принципе те же самые фьючи, только более статические, более оптимальные. Ну что значит
[10:47.800 --> 10:56.240]  более статические? То же самое, что и для рэнжей значит. Что зашивается в принципе вся цепочка
[10:56.240 --> 11:02.280]  вычислений в тип вот этого значения. То есть вот это это как бы такая фьюча значения в будущем. И
[11:02.280 --> 11:08.600]  там зашито все вот это. Я вот очень хотел вам показать, как оно зашито. Но, к сожалению,
[11:08.600 --> 11:16.600]  к сожалению, текущая имплементация вот как бы вот этого пропозала std exec. Вот в ней тут все
[11:16.600 --> 11:24.920]  очень мудрено сделано. Очень мудрено. Тут все вот эти вот цепочка, она вот внутри какой-то лямды
[11:24.920 --> 11:34.320]  зашита и через тип возвращаемого значения лямды как-то там восстанавливается. Возможно. Скорее
[11:34.320 --> 11:39.360]  всего. Потому что, конечно, когда вот такие вот огромные вещи строятся, там все тормозит.
[11:39.360 --> 11:53.640]  Короче, да. Предлагаю вам поверить мне, что здесь на самом деле ситуация такая же как с рэнжами. Мы
[11:53.640 --> 11:59.520]  накапливаем, накапливаем, накапливаем какую-то вот последовательность операций, которые были
[11:59.520 --> 12:06.320]  раньше. А потом их все схлопываем. Давайте к следующему кейсу перейдем, который мне
[12:06.320 --> 12:11.720]  гораздо ближе к сердцу. Вы, конечно, не знаете, что это такое. Можете по ссылке догадаться,
[12:11.720 --> 12:28.160]  о чем сейчас речь пойдет. Такой кусок кода. В двух словах. Что здесь происходит? Все. Что происходит?
[12:28.160 --> 12:35.600]  Мы хотим специализировать или даже издалека зайти? Наверное, нет. В общем, в какой-то момент мы
[12:35.600 --> 12:43.360]  хотим в коде декларативно задать, какие ресурсы мы запрашиваем из какой-то там абстрактной среды.
[12:43.360 --> 12:49.360]  Мы ее просим, дай нам такие-такие-такие ресурсы. Мы с ними собрались делать это, это и это. И за
[12:49.360 --> 12:55.360]  нас какой-то runtime волшебным образом все делает. Ну и код вот этого запроса ресурсов выглядит
[12:55.360 --> 13:01.440]  примерно вот так. Что мы там говорим? Реестер мы хотим прочитать текстуру с именем вот таким.
[13:01.440 --> 13:08.520]  Использовать ее будем в пиксельном шейдере, если кому-то это о чем-то говорит. Ну короче,
[13:08.520 --> 13:15.680]  будем где-то там использовать в специальном месте. Ну и вот это вот использование, его обязательно
[13:15.680 --> 13:23.080]  там нужно указывать. И как использовать? Да, это вот где использовать? А как прицепить какой-то
[13:23.080 --> 13:28.440]  переменной? То есть там как бы отдельный язык, к нему нужно такой интроп прикручивать,
[13:28.440 --> 13:33.560]  прокидывать всякие данные. И вот мы говорим, что через вот такую переменную, объявленную вот в
[13:33.560 --> 13:39.960]  другом языке, мы собираемся работать с вот этой текстурой. Текстура слова не вызывает вопросов.
[13:39.960 --> 13:44.600]  Да, сейчас я могу очень сильно бежать, пожалуйста задайте вопросы про все слова,
[13:44.600 --> 13:51.160]  которые вы не понимаете. Потому что тут конечно много специфики, но трюк. Текстура это картинка,
[13:51.240 --> 13:59.360]  вот картинка из пикселей. Вот подряд идут пикселя и вот. Что? Бывают 3D текстуры. Ну то есть это конечно
[13:59.360 --> 14:05.880]  странная такая штука, но вот вообще изначально словом текстура назывались картинки, которые
[14:05.880 --> 14:14.920]  налепливаются поверх моделей путем развертки. А сейчас наступила деградация и слова картинки и
[14:14.920 --> 14:22.840]  текстуры стали синонимами. Это конечно вот печально, но вот так вот. То есть это как пиксель,
[14:22.840 --> 14:28.000]  фрагмент и тексель. Вот вообще говорят все разные слова. Ну вы наверное только слово пиксель знаете,
[14:28.000 --> 14:44.200]  да? Ну вот да, это вот в эту сторону различия, но еще там есть фрагмент отдельно. Ну вот как бы
[14:44.200 --> 14:49.360]  шейдеры изначально назывались фрагментными, потому что работали на фрагментах, а не на пикселях,
[14:49.360 --> 14:55.720]  а потом пришли Microsoft и такие да все же одно и то же и назвали пиксельными. И теперь всех путаницы
[14:55.720 --> 15:01.640]  и все слова слились в одно единое и никто не различает. Ну ладно, что-то это в сторону отошел.
[15:01.640 --> 15:22.520]  Вот это отличный вопрос, про него нужно тоже обязательно сказать. Я хотел даже слайд вставить,
[15:22.520 --> 15:31.080]  но не успел честно говоря. Значит к такому интерфейсу мы пришли далеко не сразу. Изначально
[15:31.080 --> 15:39.000]  действительно был просто метод ReadTexture, куда вот эти вот вещи прокидывались параметрами. Потом
[15:39.000 --> 15:46.720]  внезапно оказалось, что на самом деле есть куча нюансов, что вообще-то есть еще всякие конфиги,
[15:46.720 --> 15:55.520]  запросы, что можно сделать опциональный запрос, можно там насильно переключить как мы используем
[15:55.520 --> 16:03.840]  детали. В общем, вот здесь еще на самом деле куча разных опций есть, что дописывать. Это
[16:03.840 --> 16:09.760]  A, то есть можно дописать точку optional, можно дописать точку handle, ну дальше я там покажу.
[16:09.760 --> 16:20.400]  Много разных комбинаций того, как можно читать текстуру. И вот метод стал ReadTexture просто каким-то
[16:20.400 --> 16:26.680]  диким монстром, у которого куча дефолтных параметров, некоторые из которых вообще були какие-то.
[16:26.680 --> 16:32.080]  И ты видишь вот такое типа ReadTexture, две строки, вот такая строка и такая. И ты типа,
[16:32.080 --> 16:39.320]  вот к чем отличается FarDownSampledDepth от DownSampledFarDepth? Вот они просто в аргументы методу
[16:39.320 --> 16:48.960]  кидаются и как бы пф. А дальше еще четыре буля и какие-то вот такие вот енамчики. И типа невозможно
[16:48.960 --> 16:55.880]  с этим работать. Плюс невозможно это расширять, потому что вот эта вся система, она постоянно
[16:55.880 --> 17:04.200]  меняется, мы ее дорабатываем, улучшаем, что-то добавляем и... Да, как только мы что-то решили
[17:04.200 --> 17:10.880]  добавить, в метод прилетает еще один аргумент и еще один аргумент. И в какой-то момент надоело
[17:10.880 --> 17:17.280]  ходить и править код при добавлении нового аргумента. И людям, просто читающим этот код,
[17:17.280 --> 17:24.720]  нифига не понятно, что происходит. Поэтому переделали на Builder. Вот это вот какой-то вопрос был.
[17:24.720 --> 17:35.320]  Да, про это дальше сейчас пойдет речь, что таки некоторые конфигурации невалидные. Вот в этом
[17:35.320 --> 17:59.680]  еще проблема. И получился pattern builder. И пока что... Да? Отличный вопрос, про это поговорим дальше.
[17:59.680 --> 18:18.520]  Нет, ну ты на неправильных вещах концентрируешься. Потому что когда я закрою вот эти вот все вещи
[18:18.520 --> 18:26.200]  руками, и ты увидишь просто вот там две строки, еще там другие штуки сейчас будут, ты ни черта не
[18:26.200 --> 18:31.560]  поймешь, что происходит, что этот метод делает на самом деле. Можно потом все вот эти вот строки
[18:31.560 --> 18:37.760]  в одну слепить, в одну сигнатуру метода, и тогда будет в принципе понятно. Но еще нужно на сами
[18:37.760 --> 18:43.240]  аргументы посмотреть, чтобы понять, какая строка к чему отвечает. Какая строка это название ресурса,
[18:43.240 --> 18:50.840]  а какая название там переменной какой-то. Для этого я слышал, что делает, например, у нас что текще,
[18:50.840 --> 18:56.160]  что bind to shader var это все строк получается, а можно сделать как бы для них специальные,
[18:56.160 --> 19:07.440]  как они называются, пусть есть... Strong type def, да. Чтобы это были разные типы. Ну ты не поверишь,
[19:07.440 --> 19:14.600]  здесь примерно это и происходит, но это альтернативный выбор, да, можно. Мы решили пойти не по этому пути,
[19:14.600 --> 19:20.360]  потому что помимо bind to shader var есть еще 10 разных вариантов, что можно сделать. Ладно,
[19:20.360 --> 19:31.560]  не 10, 4. Ну все равно там немало вариантов. И для каждого из этих вариантов, что мы можем сделать с
[19:31.560 --> 19:38.680]  текстурой, какие-то свои опции. И вот эти опции, как их прокидывать в один метод? Ну окей, ладно,
[19:38.680 --> 19:49.560]  не будем, это же глупо, в один метод давайте разные методы сделаем. Возможно. У нас, к сожалению,
[19:49.560 --> 19:56.280]  сейчас C++17, если бы был 20, то можно было бы со структурами сделать. И там указывать всякие,
[19:56.280 --> 20:05.440]  ну как стракчер, дизигнейт, это не шалайзер, вот. Слышал про такие. Ладно, ну сейчас покажу попозже
[20:05.440 --> 20:13.560]  тогда. Ну вот с такими трюками можно. Вариантов много, но мы остановились вот на этом и сейчас
[20:13.560 --> 20:20.560]  я буду пытаться вам продать. Почему? Это здорово на самом деле. Вот такая штука. Вот если мы этот
[20:20.560 --> 20:28.480]  stage не указали, должна быть ошибка. Вот это некорректно. Ну почему? Потому что на GPU есть
[20:28.480 --> 20:33.080]  разные кэши, которые некагерентные, их руками надо флашить. И в общем, если вот это не указать,
[20:33.080 --> 20:41.240]  то мы не знаем, какой кэш флашить. О, приходите программировать GPU, ребята. Да, то есть это
[20:41.240 --> 20:49.040]  проблема. Хочется это валидировать как-то. Еще вот такой пример есть. Еще к вопросу, почему мы такой
[20:49.040 --> 20:58.240]  решили взять. Потому что внезапно есть legacy, которое надо поддерживать. Вот тут я вот так вот сделал,
[20:58.240 --> 21:04.200]  типа bin to shader var и все работает. А есть вот такие куски кода, там по тысяче-две тысячи строк,
[21:04.200 --> 21:09.000]  где там какой-то ресурс, только этой переменной цепляется, только той, только десятой, и все это
[21:09.000 --> 21:15.320]  написано руками. И с этим тоже нужно как-то работать. Поэтому мы там сделали способ увернуться от вот этой
[21:15.320 --> 21:22.440]  всей системы запросов и получить прям handle на ресурс, который уже можно руками дальше куда-то
[21:22.440 --> 21:28.760]  закидывать, куда тебе надо. Ну и в таком случае нам там нужно явно указать, как мы его будем
[21:28.760 --> 21:34.160]  дальше использовать, чтобы опять же кэши там правильно пофлашить. Аля там вот здесь вот эта штука
[21:34.160 --> 21:38.920]  не явно говорила, как мы будем использовать. А здесь нужно явно, потому что мы не понимаем,
[21:38.920 --> 21:44.360]  какое будет использование. И если вот это вот убрать, ну опять же, нужно выдать ошибку. Что вот
[21:44.360 --> 21:50.560]  нельзя получить handle, пока ты не указал, как будешь использовать. Но при этом еще вот такая
[21:50.560 --> 21:55.560]  комбинация должна работать. Вот как бы с методами я не очень себе представляю, как все такие комбинации
[21:55.560 --> 22:01.840]  перебрать. Что мы могли и просто заменить shader var, и еще там взять handle, и как бы понести его куда-то
[22:01.840 --> 22:09.320]  дальше, что-то с ним хитрое делать. А почему тут очевидно, а до этого не очевидно было? Потому что
[22:09.320 --> 22:17.880]  bind to shader var написано. Вот use as явно говорит, как ты будешь использовать. Bind to shader var это
[22:17.880 --> 22:25.640]  один из способов использовать. Вот просто есть yinam вот этот вот, и вот в нем есть прямо элемент
[22:25.640 --> 22:31.880]  yinam usage shader var. Вот про это речь. То есть тут как бы куча таких разных хитрых комбинаций,
[22:31.880 --> 22:40.680]  которые вот без такого билдера как-то не особо рассматривались. Он возвращает handle, из которого
[22:40.680 --> 22:46.920]  можно ресурс руками достать и работать с legacy кодом. То есть идея вот этого всего автоматизировать,
[22:46.920 --> 22:54.320]  все такие вот запросы типа вот bind to shader var, можно как бы это проще, чем то, что там было до этого
[22:54.320 --> 22:58.960]  по хитрым техническим причинам, сейчас не буду вдаваться. А есть legacy, но которые переписывать
[22:58.960 --> 23:06.720]  пока сил нету просто. Там очень сложно, там очень мудренно, напутано все. И для вот этого кейса legacy
[23:06.720 --> 23:15.320]  нужно прям достать сырой handle и прям с ним ручками что-то поделать. Ну вот, и как бы мотивировка.
[23:15.320 --> 23:20.160]  Почему такой билдер? Потому что куча разных комбинаций. Вот методов получалось слишком много. У нас
[23:20.160 --> 23:24.920]  были методы изначально. Простые, казалось бы, понятные методы. Их стало слишком много, с ними
[23:24.920 --> 23:31.560]  стало мне неудобно работать. А еще вот я тут read показал. Помимо read есть еще там modify, rename и create,
[23:31.560 --> 23:39.280]  а еще register. И вот там как-то очень много комбинаций получалось, очень много методов и... А, еще есть
[23:39.280 --> 23:46.280]  буферы, кроме текстур. То есть ну там совсем взрыв мозга был, поэтому мы сделали так. И вот все
[23:46.320 --> 23:52.160]  вот эти вот ошибки, которые надо валидировать, мы конечно же валидируем прямо на этапе компиляции.
[23:52.160 --> 23:58.800]  Вы уже должны догадаться как. Нет, ну какой свинае? Ну ты прав, конечно, что там есть свинае,
[23:58.800 --> 24:08.800]  потому что у нас C++20 нет. Да, куча дополнительных типов. Я, наверное, даже вам их покажу. Да,
[24:08.800 --> 24:13.720]  камеру придется... Не знаю, просто пусть экран будет видно, мою говорящую голову-то вообще не
[24:14.600 --> 24:23.400]  может. Так, давайте только за временем слететь. У нас еще час. У нас еще час. Слишком быстро идем.
[24:23.400 --> 24:37.240]  Можно еще проборок? Можно. Мы хотим уловить общую связь между всеми вот этими вот кисами,
[24:37.240 --> 24:56.640]  которые я показываю на самом деле. Ну в каком-то смысле. Не тот файлик. Нужен вот этот файлик.
[24:56.640 --> 25:05.600]  Ну вот файлик. В нем есть куча всяких разных методов типа read.
[25:05.600 --> 25:15.920]  Причем две версии. Какой-то history, modify, rename, еще что-то. Ну и остатки старых методов это
[25:15.920 --> 25:23.600]  неинтересно. И вот они как раз возвращают некоторый virtual resource semi-request. По-моему,
[25:23.600 --> 25:29.480]  это отличное имя, но лучше я не придумал. Значит, нам нужен virtual resource semi-request.
[25:29.480 --> 25:39.920]  Потому что это не настоящие ресурсы на самом деле. Да, там некоторая абстракция
[25:39.920 --> 25:49.520]  поверх настоящих ресурсов. Нет. Виртуальность значит не напрямую. Типа индирекция какая-то
[25:49.520 --> 25:55.240]  в моей голове, по крайней мере. Ну вот тут такой смешной класс, и он какой-то ресурс-реквест
[25:55.240 --> 26:00.760]  policy принимает. Наверное, стоит уже несколько вкладок начать открывать, потому что мы тут офигеем.
[26:00.760 --> 26:22.400]  Ну я control-кликнуть вообще хочу, но...
[26:22.400 --> 26:49.760]  Сейчас. Вероятно, мне стоило заранее все эти вкладки открыть. Я тупанул. Ну вот, я открыл то,
[26:49.760 --> 26:54.960]  что нужно. Смешной енам. В нем есть какие-то битовые флаги, которые описывают свойства
[26:54.960 --> 27:05.400]  реквеста. Что там, он был read-only, опциональный, запрос истории, имеется ли одно, имеется ли другое.
[27:05.400 --> 27:16.800]  И вот этот semi-request, у него прямо в тип зашито, аргументом шаблона, элемент этого енама. Ну,
[27:16.800 --> 27:24.600]  произвольные флаги, которые описывают... Вот бесит GitHub, а? Зачем он мне это открывает? Почему
[27:24.600 --> 27:34.880]  не пропадает этот? Веб-технологии были ошибкой. Да. То есть прям в типе хранятся какие-то флаги по
[27:34.880 --> 27:41.760]  поводу того, что происходило. Ну и здесь там выбор текстуры или буфер, и пока что эти флаги
[27:41.760 --> 27:50.000]  просто прокидываются без изменений, что не очень интересно. К вопросу про что будет,
[27:50.000 --> 27:56.440]  если что-то там недовызвать. Ну вот здесь будет нехорошо, конечно. Вопрос, как сделать хорошо,
[27:56.440 --> 28:11.200]  очень просто. NoDiscard дописать. Атрибут NoDiscard. Да. Я его не написал, не знаю почему,
[28:11.760 --> 28:16.640]  потому что в моей голове полгода или год назад это было не сильно большой проблемой. Вот такой
[28:16.640 --> 28:22.280]  атрибут есть, который можно повесить на класс или функцию. Если повесить его на класс, то объект
[28:22.280 --> 28:29.200]  этого класса нельзя будет просто выкидывать, не использовав. Если повесить на функцию, то
[28:29.200 --> 28:34.400]  и возвращаемое значение функции нельзя будет выкидывать, не использовав. Вот этот атрибут бы здесь
[28:34.400 --> 28:41.600]  проставить и очень много где. Я, наверное, даже этим займусь в понедельник. Очень хорошее замечание было.
[29:04.400 --> 29:22.920]  Ну вот это часть паттерна. Если у тебя типа всей цепочки известная, то ты можешь не на куче
[29:22.920 --> 29:30.840]  хранить, а прям внутри своего объекта, как поле хранить, без локации. В этом и смысл RNG и вот этого
[29:30.840 --> 29:49.440]  execution, который я показал. Нет, проще смотреть вот на это. Ну вот ты пишешь класс FilterView и тебе
[29:49.440 --> 29:57.760]  что нужно? Тебе нужна какая-то лямбда, какая-то функция, и нужен какой-то другой view. Что ты
[29:57.760 --> 30:07.440]  сделал бы в OP-мире? Ты бы завел интерфейс iView, какой-то интерфейс iFunction и хранил указатели на два
[30:07.440 --> 30:15.000]  объекта на стеке, ну какие-нибудь уникпоинтеры. И мы расходуем память, расходуем perf на индирекцию
[30:15.000 --> 30:22.520]  и на то, что на куче выделяем память. Плохо. А здесь-то мы внутри класса FilterView, мы знаем,
[30:22.520 --> 30:28.440]  какой нам view прислали. Вот этот. Не какой-то там, а вот конкретно этот тип. И знаем,
[30:28.440 --> 30:36.120]  какую лямбду прислали. То есть мы это все в своем типе храним? Да, мы храним всю цепочку внутри типа
[30:36.120 --> 30:43.120]  посредством аргументов, а в самом инстансе объекта мы прям по значению можем сохранить
[30:43.120 --> 31:01.920]  вот эти вот вещи. В начале цепочки, в смысле где-то где вектор, например, да? Ну здесь мы пока не
[31:01.920 --> 31:14.480]  знаем, куда нас засунут. А зачем нам? Ну как бы цепочка состоит из вызовов каких-то функций. Вот
[31:14.480 --> 31:21.920]  ты вызываешь функцию Take и она должна конструировать новый объект, в котором как-то должны сохраниться старые
[31:21.920 --> 31:28.920]  объекты. Но старые здесь это вот этот вектор или там ссылку сохранить и цифра 3. Ну ты сделай
[31:28.920 --> 31:36.040]  структурку, в которой лежит ссылка на вектор и int. Причем ссылка на какой вектор ты знаешь,
[31:36.040 --> 31:55.960]  вот у тебя тут тип есть. То есть это прям вот просто структурка. Да, да. Да, а потом эту матрешку как-то
[31:55.960 --> 32:02.920]  схлопываем. То есть если ты начнешь, ну в самом конце, в прошлый раз я range 100 показал, помнишь его?
[32:02.920 --> 32:08.320]  Вот он как раз схлопывает матрешку, перекладывая ее в какой-то конкретный контейнер. Ну или если
[32:08.320 --> 32:14.480]  даже ты просто проитерируешь какой-то view, то ты тоже как бы схлопнешь матрешку, когда begin вызовешь,
[32:14.480 --> 32:19.840]  он там по всей ней пройдется и накопит все, что там необходимо знать.
[32:19.840 --> 32:37.400]  Ну с type-листом да, здесь аналогий конечно много, но я их не продумывал. То есть в задачи type-листы вы
[32:37.400 --> 32:42.240]  примерно то же самое делали. Вы в итоге вот наворачивали такую матрешку, где все старые типы,
[32:42.400 --> 32:50.320]  друг к другу как-то хранятся просто за счет того, что как бы лист это и есть алгоритм, который
[32:50.320 --> 33:01.360]  отработал. Вы же все такие трюки использовали, что не делать через cons, а прямо структуру,
[33:01.360 --> 33:11.360]  которая реализует алгоритм, становится хранителем head и tail. Вот такие вещи. Ладно, кажется вопрос
[33:11.360 --> 33:18.880]  понятен. К самому интересному, что вот virtual resource request, у него есть эта прекрасная полиция,
[33:18.880 --> 33:26.760]  ну еще там какой-то тип, но это не суть важно. А дальше начинаются методы, которые bin to
[33:26.760 --> 33:35.280]  shader var. Ой да, когда я говорил, что у нас много вариаций, я не шутил, у нас тут еще и матрицы
[33:35.280 --> 33:44.840]  через эту систему, прокидываются и view, и проекции, и там, а вот, собственно, use as, и at stage,
[33:44.840 --> 33:56.680]  который я, а где at stage, а вот он. Вот, и комбинаций много, и вот давайте на at stage внимательно
[33:56.680 --> 34:04.680]  посмотрим, потому что тут вся суть возвращается как бы тот же шаблон, но с другими шаблонными
[34:04.680 --> 34:14.880]  аргументами. А если в фоли прям два отдельных класса было, semi-future и future, то вот здесь вызов
[34:14.880 --> 34:24.040]  at stage вернет как бы другую специализацию того же шаблона класса, у которой там аргумент один
[34:24.040 --> 34:30.040]  шаблонный просто прокидывается, а вот второй прокидывается хитрым образом. Ну, тут у меня
[34:30.040 --> 34:39.360]  не очевидно написано, но вот этот flip policy, он берет ту policy, которая была раньше, где она? Вот она.
[34:39.360 --> 34:53.680]  Берет ту, которая была раньше, и какой-то битик меняет на true. Ну, то есть суть был экземпляр такого
[34:53.680 --> 35:01.480]  класса, у которого в типе было написано policy, в которой не было, как же я потерялся в этом коде,
[35:01.480 --> 35:07.560]  где в типе не было вот этого битика, а как только мы at stage вызвали, битик появился в типе, тип
[35:07.560 --> 35:18.680]  поменялся и битик другой, а вот method handle, он внезапно требует. Ну, представьте, что это requires,
[35:18.680 --> 35:25.280]  а не какой-то жуткий macro со свина с спиратоном внутри, но мы просто requires пишем, что мы требуем,
[35:25.280 --> 35:31.840]  чтобы была policy has usage stage, has usage type. Единственный способ их там выставить, это вызвать
[35:31.840 --> 35:38.520]  at stage use as. Таким образом, в обратном порядке не скомпилируется, потому что тип другой,
[35:38.520 --> 35:45.800]  там пока не выставлен битик. Надеюсь, вы примерно поняли вот эти трюки мои с policy, и это, по сути,
[35:45.800 --> 35:56.480]  вот есть основная идея. В шаблонах типа хранится некоторое состояние, которое ограничивает,
[35:56.480 --> 36:06.440]  что вы можете делать с текущей специализацией нашего класса. По этому коду, по унывающим
[36:06.440 --> 36:16.640]  лицам, вижу вопросов нету. Да, requires это жуткий макрос, который тут там еще закостылин под
[36:16.640 --> 36:31.400]  doxygen и потом за undeflin. Ну, в смысле, нужно ли где-то еще свиная в коде, да, нужно, но я предпочитаю
[36:31.400 --> 36:37.960]  каждый раз заново такие хаки делать, не давать распространяться грязным хаком по всей кодбазе.
[36:37.960 --> 36:44.280]  Ну, то есть, как бы, обновиться на C++ 20 — это вопрос нескольких месяцев для нас сейчас. Вроде там
[36:44.280 --> 36:56.040]  все готово более-менее. Ну, вот надо просто сесть и сделать. Да, просто вот requires, оно здесь не
[36:56.040 --> 37:03.800]  зря называется requires, я просто напишу прям обычный requires с C++ 20. А что еще здесь хорошо посмотреть?
[37:03.800 --> 37:20.160]  Мне нужен код. Не знаю, что тут у меня. Смешная проблема может возникнуть. Ни фига не видно, да? Сейчас.
[37:20.160 --> 37:38.160]  Вот я что-то такое писал, да. А, собственно, почему дискарты меня не волнуют, сейчас я и покажу.
[37:38.160 --> 37:43.360]  Вот такой код написали и решили дальше продолжить.
[37:50.800 --> 38:02.560]  Блин, ну, наверное, как-то так, да, на таком примере. Вот такой код нас не очень устраивает и вообще это
[38:02.560 --> 38:08.000]  что-то странное. Ну, как бы, просто вот этот вот билдер, он был сделан исключительно для того, чтобы
[38:08.000 --> 38:13.000]  декомпозировать сложный метод с кучей аргументов на маленькие кусочки, где аргументы постепенно
[38:13.000 --> 38:18.400]  указываются. Вот мы не хотим, чтобы люди умничали и вот такие какие-то вещи, а еще, не дай бог,
[38:18.640 --> 38:24.480]  вот этот вот объект промежуточный, какой-то там реквест, сохранят куда-то в поле и начнут куда-то
[38:24.480 --> 38:34.240]  прокидывать его, это будет полная дичь. Поэтому от этого нас сохраняет и спасает вот так. Вот такая
[38:34.240 --> 38:44.040]  смешная штука, два амперсанда. Да, ну, я уверен, что кто-то здесь не знает точно, что это такое. Ну,
[38:44.040 --> 38:52.960]  вот это вот, это то же самое, что и конст в конце, то есть конст после метода. Это значит, что аргумент
[38:52.960 --> 38:59.760]  this, то есть текущий объект, он должен прилететь через value expression. Иначе говоря, вот такой код
[38:59.760 --> 39:08.880]  тупо не скомпилируется. Почему? Потому что вот это, какая категория? l, это переменная, имя переменной,
[39:09.840 --> 39:18.320]  можно написать move, но это уже заставит человека задуматься, что это он странное такое делает,
[39:18.320 --> 39:26.280]  да? Видим вот такой код и как-то уже неловко, что мы два раза move-нули и, ну, наверное, что-то не то.
[39:26.280 --> 39:41.560]  Вот, окей. Что? Конст? Если бы вот так написали, да, это не сработало, потому что тут указано,
[39:41.560 --> 39:47.360]  что не конст должен быть. Но, если честно, над конст-семантикой тут вообще не думал,
[39:47.360 --> 39:55.080]  потому что не задумано так делать. Задумано не умничать, писать просто и радоваться жизни.
[39:55.080 --> 40:10.840]  Нет, конечно. Все это придумано абсолютно не мной. Если мы загуглим type state, да, это прям вот,
[40:10.840 --> 40:19.680]  мне кажется, это что-то не то. Ну, какая-то первая ссылка, да, какая-то первая ссылка из Гугла.
[40:19.680 --> 40:26.440]  Покажите пример кода. Я, по-моему, ее открывал, и здесь был пример кода.
[40:26.440 --> 40:45.280]  Ну, вот тут какой-то пример кода, вопрос только. Ну, вот, кстати, да, насчет машины
[40:45.280 --> 40:52.840]  состояний, в принципе, да, вот то, что у меня тут написано, это машина состояний, по сути.
[40:52.840 --> 41:04.160]  Нет. Ну, в смысле, это во всяком случае стоит машина, потому что вот у нас есть вот это полисе
[41:04.160 --> 41:11.240]  смешное. Вот полисе. Это текущее состояние. А дальше есть какие-то переходы между состояниями.
[41:11.240 --> 41:17.800]  Блин, картинку даже можно нарисовать. На следующий год нарисую обязательно. Ну, вам приходится терпеть.
[41:17.800 --> 41:24.080]  Так, ну и вот тут у ребят какая-то картинка есть, что вот тортует с пустого билдера,
[41:24.080 --> 41:30.640]  дальше header добавляет много раз, body и build и все. Ну и, кажется, эта библиотека как-то что-то
[41:30.640 --> 41:36.560]  позволяет делать, и меня смущает, что они тут не показывают, да. Давайте экземпл откроем.
[41:36.560 --> 41:47.040]  А ну вот, R-value ссылки. То есть это частая такая техника, идиому можно сказать.
[41:47.040 --> 41:57.760]  CC это странное... Да, как бы у всех свои расширения.
[41:57.760 --> 42:15.480]  Да, ну... Возможно слит, если написать. Надо слит написать, да. Тут есть прекрасная лекция,
[42:15.480 --> 42:21.200]  вот где подробно рассказывают про этот паттерн. Если вы чуть-чуть видите хотя бы,
[42:21.200 --> 42:28.640]  вот тут тоже самые R-value ссылки используются. И вот тут, и вот тут. То есть нет, это супер частая
[42:28.640 --> 42:37.200]  штука. Вот, я, конечно же, ее не сам придумал, я вам рассказываю только. Давайте пойдем к следующему
[42:37.200 --> 42:44.720]  кейсу. Хватит хвастаться моими достижениями. Ну вот, надеюсь, я как-то немножко прорекламировал,
[42:44.720 --> 42:49.440]  что вот эта штука конкретную задачу решает. И вот она не просто где-то там в вакууме чуваки
[42:49.520 --> 42:54.120]  на гитхабе библиотеки пишут, а прямо сейчас в проде крутится вот это все.
[42:54.120 --> 43:14.280]  Eigen. Eigen. Что-то на немецком. Да, собственная, ну библиотека собственной, она про матрицы. Вот
[43:14.280 --> 43:20.560]  какой-то отрывок кода. Ну какую-то матрицу создали. Ну, наверное, пока посижу, там уже немного слайдов
[43:20.560 --> 43:30.480]  осталось. Да, кстати, тут тоже есть метапроженный трюк, на который я даже так не посмотрел особо,
[43:30.480 --> 43:43.920]  наверное. Давайте подумаем, что происходит во второй строчке. Нет. Но не вектор, а матрица. Да,
[43:43.920 --> 43:49.400]  вот тут матрица 3f. Это значит, матрица 3 на 3 из флотов. И вот у нас тут 9 значений этой
[43:49.400 --> 43:55.000]  матрицы забиваются. Но какого черта это работает и как? Потому что, видовость двига возвращает
[43:55.000 --> 44:03.560]  другой тип. Не матриц 3f, а что-то еще. Вот, по-моему, ты прав. По-моему, там именно как-то так,
[44:03.560 --> 44:08.680]  что-то такое схитрили. И у них приопределен оператор запитает для какого-то их типа,
[44:08.680 --> 44:15.320]  возвращаем его отсюда и чисел. То есть, вы как бы единичку, да? Вот это кажется, что парсить надо,
[44:15.320 --> 44:20.240]  что вот этот список с запятыми вдвигается в матрицу. На самом деле, нет. На самом деле,
[44:20.240 --> 44:24.440]  здесь единичка вдвигается, а дальше через запятую перечислено все остальное.
[44:24.440 --> 44:37.440]  Ну, а в чем проблема? Инты кастятся к флотам? Ну, как-то это работает, в общем. Я проверял,
[44:37.440 --> 44:42.360]  этот код компилируется. Ну, дальше мы берем матрицу, саму на себя умножаем, вот третьей строчки.
[44:42.360 --> 44:51.480]  Берем два вектора, тоже какие-то вводим, вектор наперемножаем друг на друга, и вот ту матрицу
[44:51.480 --> 44:59.200]  умножаем на итоговый вектор. И хотим посмотреть на тип. Ну, я думаю, уже можно догадаться,
[44:59.200 --> 45:07.800]  что мы увидим там то же самое, что и в ренджах. Ну, тут совсем все понятно должно быть, даже понять
[45:07.800 --> 45:17.280]  нечем в ренджах, правда? Вот у нас какой-то эйгенпродакт двух матриц. Вот там матрица 3 на 3,
[45:17.280 --> 45:24.400]  матрица 3 на 3. А дальше все это вместе еще раз продукт на матрицу 3 на 1. Ну, потому что вектор
[45:24.400 --> 45:32.480]  это тоже матрица. Ну, и векторное произведение скушалось внезапно, а вот там произведение матриц,
[45:32.480 --> 45:52.960]  они отложились вот в такую некоторую цепочку тоже. Зачем? Там есть оптимайзер.
[45:52.960 --> 46:02.160]  Бэк пропагейшн тоже через эту технику можно устроить в плюсах. Но тут это сделано не для
[46:02.160 --> 46:11.000]  бэк пропагейшна, тут это сделано, по-моему, чтобы все-таки заоптимизировать. То есть вот почему они
[46:11.000 --> 46:16.760]  сразу не перемножают матрицы? А потому что у них есть опять же великое множество комбинаций. Спарс
[46:16.760 --> 46:28.640]  матрицы, такие матрицы, там косолинейные, криволинейные. Да, и они сначала строят вот
[46:28.640 --> 46:41.200]  это все дурацкое дерево. Это же дерево, по сути. И в ренджах было дерево. Да, фильтр. Да, оно все
[46:41.200 --> 46:46.360]  откладывает в вычисления. А в конце, когда ты уже попросишь, ну все, я числа хочу, дай мне матрицу,
[46:46.360 --> 46:51.360]  оно возьмет и запустит некоторую такую хитрую машинку, которая будет по этому дереву ходить и
[46:51.360 --> 46:58.920]  пытаться оптимально вычислить по скорости и там, наверное, по памяти, по потере точности, например.
[46:58.920 --> 47:05.120]  То есть вот такие хитрые фокусы, так как у них дерево, они могут делать. Теоретически в ренджах
[47:05.120 --> 47:18.240]  возможно то же самое, практически нет. Ну вот, кажется, это последний кейс. Теоретически у тебя в
[47:18.240 --> 47:23.200]  ренджах есть целое вот это вот дерево из типов, и ты можешь написать какой-то хитроумный код,
[47:23.200 --> 47:29.400]  который знает все про все вьюхи и может их как-то схлопнуть, приордерить и как-то заптимайзить.
[47:29.400 --> 47:39.400]  Оно локально происходит, а речь не об этом, речь о глобальном каком-то. Вот в Эйгене,
[47:39.400 --> 47:43.520]  насколько я знаю, некоторые глобально есть взгляды, они прям вот глобально оптимизят.
[47:43.520 --> 48:01.000]  У этого, конечно, у всего есть некоторая проблема, что когда вы пишете вот такой смешной код,
[48:01.000 --> 48:08.440]  как я, автор равно m2 на v3, немножко не ожидайте увидеть там какой-то дурацкий Эйген-продукт от
[48:09.400 --> 48:14.200]  и так далее и так далее. Но кажется, что матрицу множили, должны матрицу получить. Вот если хотите
[48:14.200 --> 48:20.000]  матрицу получить, вы вместо авто обязаны теперь матрицу писать прямо. Вот это может быть неудобно.
[48:20.000 --> 48:32.800]  Вот этот продукт автоматически кастится к матрице. Ну то есть можно написать вот здесь вместо авто
[48:32.800 --> 48:50.440]  matrix3f и там есть implicitCast, который форсирует все вычисления. Ну, кстати, да. В NumPy все привыкли,
[48:50.440 --> 48:54.920]  Python можно творить что угодно, но то, что в плюсах то же самое творят, это для меня было немножко
[48:54.920 --> 49:01.800]  сюрпризом, когда я узнал. Вот, ну это все кейсы, которые у меня есть на сегодня, давайте общую
[49:01.800 --> 49:19.120]  идею обсудим. У них есть некоторая волшебная коробка, которая умеет более оптимально сложные
[49:19.120 --> 49:24.760]  матрешки вычислять. Вот она прям смотрит, видит полную матрешку и понимает, что тут
[49:24.760 --> 49:29.160]  можно переставить местами, вычислить в другом порядке и будет быстрее, лучше, круче.
[49:29.160 --> 49:53.000]  Может быть. Тут такая же идея примерно. И в ренджах-то примерно та же идея,
[49:53.000 --> 50:03.760]  что будет быстрее, если вот эти вот ленивые вычисления сделать, будет быстрее. В Эдине,
[50:03.760 --> 50:08.400]  кажется, даже умнее, чем просто ленивые вычисления, но не факт. Вот я не влезал,
[50:08.400 --> 50:15.040]  честно говоря, в коробку, эту черную. По-моему, там очень умно сделано все, писали очень умные люди.
[50:15.040 --> 50:35.800]  Да, это просто есть айген. Прикол в том, что линал реализуется одним способом в одном месте,
[50:35.800 --> 50:50.240]  через бласс. Тут есть сайтик, вы можете подробно почитать. Если вам когда-то в жизни понадобится
[50:50.240 --> 50:55.280]  какой-то линал считать быстро и круто, я вам крайне рекомендую айген. С ним работать прикольно,
[50:55.280 --> 51:04.680]  и он все многомерные кейсы покрывает вообще. Матрикс 3F, вы видели, что это на самом деле никакой
[51:04.680 --> 51:12.920]  не Матрикс 3F, а Матрикс Flow 3.3. Здесь любые числа могут быть, а еще есть Спарс-матрица и прочее.
[51:12.920 --> 51:25.120]  В общем, я уже забыл, в чем вопрос был. Наверное, надо тогда дальше идти. У нас остается 25 минут,
[51:25.120 --> 51:31.720]  давайте поговорим про общий вид паттерна. По всем этим кейсам они более-менее на две категории
[51:31.720 --> 52:01.000]  развалились. Какие? Нет, это общая идея всего. Ну, фактически, да. Я бы сказал даже,
[52:01.240 --> 52:11.800]  просто по признаку того, что мы храним в аргументах шаблонных, параметрах шаблонных типа. Либо мы храним
[52:11.800 --> 52:19.720]  всю предыдущую историю, либо мы храним какое-то короткое представление, что сейчас происходит.
[52:19.720 --> 52:27.200]  Вот в примере моем, там вот одного янама с флажками хватает. Можно было вместо этого тоже всю историю
[52:27.200 --> 52:33.360]  хранить как там в айгене, но это было не нужно. Это слишком сложно, тут обошлись меньше крови. Во
[52:33.360 --> 52:43.440]  фьючах фейсбука то же самое. Вот они могли бы начать городить как в стд экзекьюшн, но им это все
[52:43.440 --> 52:48.360]  не нужно, потому что у них там фьючер все на куче хранит и вот это вот статическое, но слишком
[52:48.360 --> 52:55.320]  сложно. Они обошлись по сути одним битом информации. Либо у вас сэмифьючер, либо фьючер. Это тоже,
[52:55.480 --> 53:02.800]  как бы состояние. Сэмифьючер и фьючер в общем-то для пользователей примерно одно и то же, но одно из
[53:02.800 --> 53:07.960]  них как бы полноценное, другое нет. У одного есть колбэки, у другого нет методов для колбэков.
[53:07.960 --> 53:18.240]  Вот, ну и кейс, когда мы целое дерево того, что раньше происходило строем, он в общем случае
[53:18.240 --> 53:44.160]  expression templates называется. Что смешного? Тут все серьезно. Нет, енто не монады.
[53:48.240 --> 54:04.680]  Вот набежали блин со своими монадами. Сидели никому не мешали. В этом шутка, Андрей. Нет,
[54:04.680 --> 54:10.720]  ну монады тут где-то близко топчутся, потому что и RNG это монады, и матрицы с какой-то точки зрения
[54:10.720 --> 54:17.400]  это монады, и фьючи это монады, и вот эти вот из execution хитрые там сендеры какие-то это монады.
[54:17.400 --> 54:22.240]  Вот только то, что у меня там написано, это не монада. Это вот простой рабочий крестьянский
[54:22.240 --> 54:27.160]  прикладной код, когда надо сбилдить кучу информации, некоторые комбинации некорректные,
[54:27.160 --> 54:36.800]  некоторые там еще что-то, и мы тупо вот защищаем от дурака. Ну кстати, слово дурак оно обидное,
[54:36.800 --> 54:42.880]  а защита от дурака оно вот ни разу не должно быть обидным, потому что дурак это вы сам всегда,
[54:42.880 --> 54:50.600]  да? В три ночи усталый, глаза уже слепятся, написал не то. Вот если вы себя защитили от этого,
[54:50.600 --> 54:59.880]  то вы молодцы. Ну вот если у вас на уровне системы типов реджектятся тупые ошибки,
[54:59.880 --> 55:04.160]  то вы защищаетесь не от какого-то абстрактного Ваньки дурака, который и дурак, а вы-то умный,
[55:04.400 --> 55:10.160]  нет, вы защищаете себя от самого себя. Да? Дурак это вы в три ночи, не выспавшийся,
[55:10.160 --> 55:16.600]  голодный, усталый, злой, вот в этот момент вы совершаете эти тупые ошибки. Можно ли
[55:16.600 --> 55:21.880]  вас дураком назвать? Наверное нет. Ну надо себя как-то любить все-таки, да? То есть мы как бы с
[55:21.880 --> 55:30.520]  абстрактной точки зрения дураки, с прикладной нет. Но да, это отступление. Давайте рецепту все-таки
[55:30.520 --> 55:37.680]  прочитаем, от Монада отойдем. У нас вот это вот expression templates это чисто плюсовый трюк про то,
[55:37.680 --> 55:43.840]  что ну как работают шаблоны в плюсах. Я не уверен можно ли такой трюк сделать с другими
[55:43.840 --> 55:51.840]  системами дженериков и про в какой-то степени pattern composite, наверное. Но давайте читать,
[55:51.840 --> 55:59.440]  что вот у нас есть набор операций. Наверное встать мне надо, я привык прыгать. Да, надо встать,
[55:59.440 --> 56:05.520]  чтобы привлекать внимание, чтобы вы не заснули. Что общий рецепт такой, что есть набор операций и
[56:05.520 --> 56:13.080]  какие-то данные, над которыми мы работаем. Вот были матрицы, были ранжи, были сэндеры
[56:13.080 --> 56:19.600]  асинхронные, непонятные, неважно даже. Мне кажется еще можно всякого придумать, если постараться.
[56:19.600 --> 56:37.440]  Это все в одно. Но это не совсем функциональный дизайн. Возможно. Просто дизайн как слово,
[56:37.440 --> 56:40.920]  оно там покрывает столько всего и там столько всяких разных вещей. Вот слово
[56:40.920 --> 56:45.160]  функциональный дизайн, я если честно не видел, чтобы оно как-то формализованно вводилось тоже.
[56:45.160 --> 56:50.320]  И какого-то представления, что люди говорят, когда имеют в виду функциональный дизайн,
[56:50.320 --> 56:57.880]  у меня пока нет. Ну, монады, наверное, функторы, вот это все, оно здесь не очень близко по моим
[56:57.880 --> 57:05.720]  ощущениям. Ладно, все, хватит меня отвлекать. Давайте пройдемся по пунктикам, что мы зачем
[57:05.720 --> 57:10.800]  занимаемся всем этим, что вот есть эти вычисления над данными и мы хотим одно из трех вещей делать.
[57:10.800 --> 57:16.400]  Либо защищать себя от тупых ошибок, вот инварианты какие-то, enforce it. Либо хотим
[57:16.400 --> 57:23.280]  откладывать вычисления, либо хотим, ну как-то ленивые, но это одно и то же. Вот ленивые отложенные
[57:23.280 --> 57:29.600]  в этом контексте неважно. В случае с ренджами вы откладываете вычисления до момента, когда их
[57:29.600 --> 57:36.680]  вот прям необходимо, когда Bigin позвали. В случае с фьючами, ну вы откладываете вычисления до момента,
[57:36.680 --> 57:42.800]  когда там что-то произойдет в будущем и с точки зрения вот этого вот паттерна, это все одно и то же
[57:42.800 --> 57:50.080]  или там функционального программирования. Итак, берем, что мы делаем? Берем наваливаем историю
[57:50.080 --> 57:55.760]  всего происходившего внутри типа, возможно не всего. Некоторые ветки, возможно, стоит выкидывать,
[57:55.760 --> 58:01.360]  да, видели там cross-product в вегане, он выкинулся. Ну, видимо, потому что с ним никаких оптимизаций
[58:01.360 --> 58:08.160]  не придумаешь и как бы это ну вот так. Возможно, там есть какой-то не... возможно есть другой метод,
[58:08.160 --> 58:12.280]  который ленивый и который нормально делает. Возможно, я просто не тот метод вызвал.
[58:12.280 --> 58:23.400]  Стандартный это тип внутри типа, внутри типа и так далее. И каждая вот эта вот функция или операция,
[58:23.400 --> 58:29.720]  которая обрабатывает, она возвращает новый тип, новую обертку над тем, что было. Ну, конечно,
[58:29.720 --> 58:34.280]  это такой общий рецепт. На практике мы можем и сворачивать в какой-то другой тип матрешку
[58:34.280 --> 58:42.120]  по ходу дела. Иногда это бывает полезно и нужно. Вот если... хотя, да, вы уже большие, в ваш год Рома
[58:42.120 --> 58:50.880]  еще этого не придумал и не рассказал. Вот Аркадий, разве что, с Андреем могут знать. До бесконечности
[58:50.880 --> 58:57.680]  растягивать вот эти вот ленивые вычисления бывает плохо. Бывает, что это не оптимально по памяти,
[58:58.160 --> 59:04.040]  по другим параметрам. Иногда хочется взять и прямо запустить эти вычисления прямо сейчас. То есть
[59:04.040 --> 59:10.760]  иногда имеет смысл пользователю прямо выдать руками инструмент, который матрешку сворачивает,
[59:10.760 --> 59:17.280]  несмотря на то, что технически нужды нету сворачивать эту матрешку. Просто может быть объект уже очень
[59:17.280 --> 59:22.520]  большой. Если у вас какая-нибудь асинхронная операция, которая уже килобайт занимает из своих
[59:22.520 --> 59:29.720]  под кусочков, возможно стоит как бы оборвать и дальше где-то в другом месте пойти. Вот и
[59:29.720 --> 59:36.760]  некоторым функциям можно забанить, принимать некоторые типы, то есть инварианты тоже в таких
[59:36.760 --> 59:43.280]  схемах с ранжами, они работают. Какие, кстати, мы видели на прошлой лекции инварианты, которые с
[59:43.280 --> 59:57.920]  помощью типа фэнфорсятся в ранжах? Ну вот что-то такое-то. Да, с помощью типа ранжа из-за
[59:57.920 --> 01:00:03.920]  счет того, что у нас не какой-то там опэшный интерфейс iView или iRange, мы можем прямо в тип вшить
[01:00:03.920 --> 01:00:09.000]  какую-то информацию о том, что с ним можно делать. Например, является ли он бормранжом? Это тоже как
[01:00:09.000 --> 01:00:22.640]  бы type-state в каком-то смысле, состояние внутри типа. Ну и все, сворачиваем бутерброд. Да, такое делают,
[01:00:22.640 --> 01:00:42.840]  всякое делают. Sentinel-4 в смысле... Ну конкретизируй, в любом ранже можно сравнивать Sentinel с
[01:00:42.840 --> 01:00:54.680]  итератором. Ну типа, является ли Sentinel итератором, вот это как раз type-state, мне кажется. Потому что в
[01:00:54.680 --> 01:01:00.360]  зависимости от этого ты можешь там по-разному запрещать сюда передавать, запрещать туда передавать. То есть
[01:01:00.360 --> 01:01:05.680]  как бы type-state он не всегда может быть совсем явным, он может быть таким запрятанным за другими
[01:01:05.680 --> 01:01:16.040]  какими-то свойствами типов и оберток. И type-state, но это немножко из другой идеи пришло. Да, type-state это
[01:01:16.040 --> 01:01:27.920]  скорее вот то, что мое детище я показывал. И что еще? И future. Ну там через точку как билдер мы
[01:01:27.920 --> 01:01:34.000]  настраиваем какой-то объект. То есть имеется вариация паттерна билдера и мы хотим ловить какие-то
[01:01:34.000 --> 01:01:42.280]  ошибки, enforce it in варианты опять же. Но мы какой-то state сохраним прямо внутри аргументов шаблона типа,
[01:01:42.280 --> 01:01:49.200]  не типовые шаблоны аргументы или ну просто разные типы можно завести, когда это удобней.
[01:01:49.200 --> 01:02:18.960]  Нет, потому что ты CPO начинаешь придумывать, когда через палку пишешь или через свободную
[01:02:18.960 --> 01:02:38.600]  функцию. А через точку ничего придумать не надо. Ну сделай, сделай твоя сущность подчеркивания
[01:02:38.600 --> 01:02:48.000]  интерфейс, который с RTP, который закидывает все, что нужно с дефолтами. Ну да. Ну view interface
[01:02:48.000 --> 01:02:57.560]  помните? Показывал. Вот аналог этого делаем и все, проблема решена. Ну то есть. Зови тот кейс,
[01:02:57.560 --> 01:03:02.880]  конечно. Если у тебя супер много операций и на каждом объекте нужно уметь как бы теоретически
[01:03:02.880 --> 01:03:08.000]  делать каждую, кроме каких-то маленьких запретов, вот очень маленькое количество запретов,
[01:03:08.000 --> 01:03:14.920]  то тебе, конечно, через методы будет тяжеловато. Очень много методов, будет очень много кода,
[01:03:14.920 --> 01:03:21.560]  не знаю. Кажется, что это не самая хорошая идея. В таком случае, наверное, свободные функции лучше.
[01:03:21.560 --> 01:03:30.200]  Там еще есть, наверное, более тонкая разница, что если мы работаем с методами через точку,
[01:03:30.200 --> 01:03:37.160]  то мы можем из доступных перегрузок только в базе скаститься, если мы пишем типа A точку метод,
[01:03:37.160 --> 01:03:45.640]  а если мы пишем через свободную, то мы можем намного больше войти. Я не очень понял о чем-то. Ну
[01:03:45.640 --> 01:03:53.560]  вот, например, у меня есть какой-то тип, да, там не знаю, тип foo, да, есть тип bar, у которого есть,
[01:03:53.560 --> 01:04:04.320]  к сожалению, implicit constructor от foo. Вот. И тогда, если мы работаем с методами класса, то тогда у нас
[01:04:04.320 --> 01:04:15.620]  не будет, кажется, доступным иметь у bar метод какой-нибудь баз и написать у объекта типа foo точка
[01:04:15.620 --> 01:04:23.040]  баз. Ну, я все равно не воспринял на слух пример, но, кажется, ты хочешь сказать, что система с
[01:04:23.040 --> 01:04:28.200]  свободными функциями, цепочками и прочим, она более расширяемая и больше кейсов покрывает странно.
[01:04:28.200 --> 01:04:47.480]  А, ну, окей, да, ну. Надо на самом деле, на самом деле и то и другое, пока что в зарождении таком находится,
[01:04:47.480 --> 01:04:53.480]  да, вот там ранжи совсем недавно выкатили, execution тоже пока пекут, и мы, как человечество,
[01:04:53.480 --> 01:05:02.560]  пока не особо понимаем, каким последствием это все приведет через 10 лет. Да, все нормально будет,
[01:05:02.560 --> 01:05:07.960]  придумают как это решить, это техническая штука, но вот какие-то дизайнерские последствия этих
[01:05:07.960 --> 01:05:14.880]  решений, они пока очень неочевидны, и там, ну, через пять лет, наверное, будет уже понятно в
[01:05:14.880 --> 01:05:20.240]  ретроспективе, что мы все сделали неправильно, опять все ошиблись, давайте заново все переделывать.
[01:05:20.240 --> 01:05:28.880]  Да, до нотации монады, то, о чем я мечтаю. Ну, короче, тут примерно то же самое написано,
[01:05:28.880 --> 01:05:34.960]  вот просто вы могли в каких-нибудь презентажках, с каких-нибудь конференций наткнуться, что есть вот
[01:05:34.960 --> 01:05:41.080]  такая штука, наткнуться, что есть вот такая штука. Я утверждаю, что это одно и то же, то есть expression
[01:05:41.080 --> 01:05:48.480]  это частный случай type state, просто в качестве вот этого состояния вы храните предыдущую историю,
[01:05:48.480 --> 01:05:59.280]  ну, вполне себе состояние. Ну, в моих глазах отличий между этими вещами нету и, ну да,
[01:05:59.280 --> 01:06:09.480]  втащим-то у меня на этом все. Нас десять минут до конца, мы можем поговорить про жизнь,
[01:06:09.480 --> 01:06:16.160]  про барокко, про задачи, про какие-то вопросы по этому материалу, но мне кажется, я и так уже
[01:06:16.160 --> 01:06:25.960]  каждую мысль по два раза повторил и надо будет ужимать в следующем году. Ну что, ни у кого никаких
[01:06:25.960 --> 01:06:40.400]  вопросов, проблем, чего-то волнующего. Я говорю, что это частный случай, это я сам вчера ночью
[01:06:40.400 --> 01:06:47.480]  придумал, но мне кажется, это очевидно. Согласны ли со мной вы? Ну, то есть вот если говорить,
[01:06:47.480 --> 01:06:51.800]  что type state это такая общая штука, что храним состояние внутри типа и в зависимости от этого
[01:06:51.800 --> 01:06:59.800]  ограничиваем кого кто может вызывать, тем самым варианты in force, то это ничем не отличается от
[01:06:59.800 --> 01:07:05.360]  вот этого примерно, что там. Ну, окей, в expression template их еще отложенные учисления можно сделать.
[01:07:05.360 --> 01:07:14.400]  Ну, здесь тоже в принципе можно, если честно, в type state, да, как бы, ну. У меня вопрос, если мы
[01:07:14.400 --> 01:07:29.960]  начинаем умножать, ну, вот у нас была библиотека Eigen, в общем, там мы исключительно со тиралами
[01:07:29.960 --> 01:07:37.040]  работали, если мы начинаем резко вводить числа из консоли, то у нас это все перестает работать.
[01:07:37.040 --> 01:07:43.920]  Если ты вводишь, в смысле, нет, значение вот эти вот, нет, все работает. У тебя в тип зашито
[01:07:43.920 --> 01:07:53.560]  только размеры матриц. Ну, если так фундаментально посмотреть, то у тебя зашито сюда там ранги и
[01:07:53.560 --> 01:08:00.280]  размерности тензоров. По-моему, тензоры тоже в Eigen есть в каком-то виде в расширении, но только
[01:08:00.280 --> 01:08:08.480]  фигойнки, по-моему. Я пытался с ними работать, ничего не вышло. Ну, окей, давай вот эту информацию
[01:08:08.480 --> 01:08:16.000]  выкинем из типа. Если вот нам нужно в нашем кейсе, то выкинем. Как? Ну, в спане мы справились с этим.
[01:08:16.000 --> 01:08:25.440]  Динамик Extend пишем по какой-то оси или по еще чему-то. Вот если ранг тензора должен быть динамический,
[01:08:25.440 --> 01:08:32.200]  то это вообще, пиши пропало, тут ноль информации будет, и валидировать статически, что размерности
[01:08:32.200 --> 01:08:37.960]  при умножении матриц совпадают, а Eigen это делает, да? К вопросу инвариантов, вот я тут этого не
[01:08:37.960 --> 01:08:42.560]  подчеркнул, но тут они есть. Когда вы делаете продукт, Eigen проверяет, что у вас размерности
[01:08:42.560 --> 01:08:46.840]  совпадают. Ну, вот если они динамическими станут, то эти проверки отправятся в ранг тайм.
[01:08:46.840 --> 01:08:58.560]  И, ну... А, тут еще, как бы, в карте истории можно добавить, что у нас есть все еще интерфейсы,
[01:08:58.560 --> 01:09:05.360]  и у нас эти объекты, которые там стоят и наставляют, они, как правило, что-то полезное делают,
[01:09:05.360 --> 01:09:29.880]  ну нет, не обязательно. Они могут не просто копить стейп. Ну да, могут. Ну вот да, на самом деле,
[01:09:29.880 --> 01:09:37.400]  этот паттерн еще с TypeRaiser дружит, потому что, если вы хотите, вы можете обернуть вот эту всю шнягу
[01:09:37.400 --> 01:09:48.200]  в TypeRaisedMatrix. Ну, Matrix, TypeRaisedMatrix размера 1, что-нибудь такое. Ну, вот это все вместе,
[01:09:48.200 --> 01:09:55.560]  по-моему, это будет то же самое, что и Matrix 1 на 1, да? И можно взять и... А, нет, стоп, это вектор,
[01:09:55.560 --> 01:10:03.320]  это вектор. Можно вот эту информацию, как бы, прокинуть через ранг тайм, и... Ну, это такое
[01:10:03.320 --> 01:10:13.200]  уже усложнение, которое, мне кажется, на детали не влияет, и... Как, ну, идешь рекурсивно и
[01:10:13.200 --> 01:10:24.480]  разворачиваешь. Ну, switch по типам — это когда ты метод вызываешь, и он в разном классе, по-разному
[01:10:24.480 --> 01:10:33.400]  реализован. Ну, вот так, например. Ну, или... Ну, то есть, тут вариантов много, я верю, вы придумаете.
[01:10:33.400 --> 01:10:40.240]  Просто мой вопрос был по тому, что кажется, что у нас спан был, и вот, по поводу слайса,
[01:10:40.240 --> 01:10:47.800]  там не очень сильно менялся функционал, если нам известно или неизвестно. А тут? Сильно, да.
[01:10:47.800 --> 01:11:02.520]  Много копипасты, много болей, много страданий. Ну, вот, теоретически, тут все параметры можно
[01:11:02.520 --> 01:11:07.680]  взять и отправить в ранг тайм. Можно даже тип значений, которые мы храним, отправить в ранг тайм и
[01:11:07.680 --> 01:11:15.160]  сказать, что это там big integer, там какого-то или еще что-нибудь. Ну, в общем, все можно отправлять в
[01:11:15.160 --> 01:11:20.200]  ранг тайм. Вопрос, на что вы готовы, как автор библиотеки, пойти? Ну, авторы библиотеки Айген,
[01:11:20.200 --> 01:11:26.600]  по-моему, только вот размеры. То есть, ранг нельзя, только размеры матриц менять можно в ранг тайм
[01:11:26.600 --> 01:11:31.160]  и через динамик экстенд. Ну и, собственно, в задачах спан и слайс вы должны были научиться,
[01:11:31.160 --> 01:11:42.120]  как там минимизировать копипасту до какой-то степени. Ну да, то есть, вполне себе неплохое
[01:11:42.120 --> 01:11:46.360]  упражнение, если кому-то из вас совсем нечем заняться накануне за четные недели, это написать
[01:11:46.360 --> 01:11:55.840]  вот свой аналог Айгена с вот этими вот матрицами, еще поддержкой ранг тайма. Ну, наверное, хорошая
[01:11:55.840 --> 01:12:09.320]  идея, наверное. Ну, она нудная просто будет. Да, то есть, ну, не знаю. Я бы сказал, я бы сказал,
[01:12:09.320 --> 01:12:17.400]  что самый классный пример здесь вот тот, что мой, не потому что он мой, не поэтому, потому что это
[01:12:17.400 --> 01:12:23.280]  просто обычный билдер, вот этот классический паттерн-билдер, где мы просто постепенно накладываем
[01:12:23.280 --> 01:12:30.480]  какую-то информацию, вместо метода build здесь вот этот handle. Ну, как бы, я это не проговорил явно,
[01:12:30.480 --> 01:12:37.040]  но вот этот handle он как бы сворачивает, в каком-то смысле, бутерброд и билдит итоговый объект. Нам
[01:12:37.040 --> 01:12:43.280]  понадобились варианты enforce. Какой у вас пример билдера был на технологиях программирования?
[01:12:43.280 --> 01:12:54.720]  Бургер. Сет котлета, сет это, сет то. Ну, давайте enforce, что там нельзя больше, чем две котлеты
[01:12:54.720 --> 01:13:07.000]  класть. Как это сделать? Вот у вас есть метод от котлета. Как? Да, просто в счетчике классно,
[01:13:07.000 --> 01:13:13.760]  сохраним количество котлет, от котлета возвращает билдер нового типа, новую специализацию, где счетчик
[01:13:13.760 --> 01:13:20.440]  конкрименчен. Как только он два, у вас метод от котлета пропадает. Ну, то есть вот это, мне кажется,
[01:13:20.440 --> 01:13:28.520]  самое такое прикладное. Что? Да, requires, через requires метод пропадает. Если у вас нет requires,
[01:13:28.520 --> 01:13:50.040]  вы пишите SFINAE сами. Ну, лучше... Ну, можно подумать насчет моделирования процесса поедания
[01:13:50.040 --> 01:13:56.640]  бургеров как monad, но в свободное время, а лучше, закрывшись дома в ванной. На этом предлагаю
[01:13:56.640 --> 01:14:01.360]  закончить. Теперь время совсем вышло. Всем спасибо, что пришли. Все свободны.
