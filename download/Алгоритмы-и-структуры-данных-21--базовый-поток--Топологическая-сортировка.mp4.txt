[00:00.000 --> 00:12.240]  О чем у нас была прошлая лекция, кто помнит? DFS, а до этого BFS. Но сегодня мы будем продолжать
[00:12.240 --> 00:18.200]  DFS. Я надеюсь, вы его плюс-минус поняли, сможете его применять и с ним работать.
[00:18.200 --> 00:25.840]  Сегодня мы увидим еще одно применение на самом деле DFS, хотя само по себе все будет
[00:25.840 --> 00:29.600]  называться как топологическая сортировка. Работа с этой сортировкой. Посмотрим,
[00:29.600 --> 00:34.680]  что она вообще умеет делать и для чего она нам вообще нужна. Вот какие задачи может
[00:34.680 --> 00:39.000]  решать вообще топологическая сортировка. Ну представьте примерно следующее. Вам нужно построить
[00:39.000 --> 00:44.640]  какой-нибудь автомат, грубо говоря, действий для того, чтобы получить какой-то результат.
[00:44.640 --> 00:49.480]  Вот вы складываете, не знаю, пять чисел. Какие числа вначале будет складывать? Сначала, с конца.
[00:49.480 --> 01:01.760]  От скобочек. Ну вот скобочек нету. Неважно. Хорошо. Вот. А если с точки зрения плюсов,
[01:01.760 --> 01:08.960]  типа вот вы как будете это делать? С конца. Вот. Ну грубо говоря, вам нужен какой-то понятный
[01:08.960 --> 01:14.440]  механизм того результата, как вы будете это все находить. Вот. Может быть, не знаю, вы любите
[01:14.440 --> 01:21.760]  играть в игрушки, и вам необходимо открывать какие-нибудь новые уровни для того, чтобы у вас что-то
[01:21.760 --> 01:28.160]  новое открывалось. И там тоже есть какая-то своя зависимость между всеми объектами, которые есть.
[01:28.160 --> 01:32.960]  То есть, у вас есть какое-то первоначальное условие, к которому вы должны перейти. То есть,
[01:32.960 --> 01:39.920]  если мы сопоставим вот эту вот зависимость в виде каких-то ребер, то мы получим, что у нас из более
[01:39.920 --> 01:45.920]  младших таких вот элементов должно переходить что-то в более старший. Это касается там и результата
[01:45.920 --> 01:55.480]  в каких-нибудь вычислениях, и касается вот, не знаю, в Minecraft давно играли или нет. Вот. Но я давно.
[01:55.480 --> 02:04.440]  Ну была у нас такая тема, да. А когда во время сессии уже делать нечего, вот. Делали свой сервак.
[02:04.440 --> 02:08.840]  Ну короче, да, для того, чтобы там чего-то достичь, вам необходимо там создать какие-нибудь
[02:08.840 --> 02:13.920]  первоначальные предметы, после этого из них что-нибудь еще сделать и так далее. Вот. Это все
[02:13.920 --> 02:19.360]  некоторые зависимости сами по себе, которые вы можете выстраивать в, представить в виде какого-нибудь
[02:19.360 --> 02:29.640]  графа. И вот вообще, топологическая сортировка, это первое, с чем мы сталкиваемся, это сортировка
[02:29.640 --> 02:35.440]  для ациклического графа. Это не совсем сортировка в том понимании, которое вы представляете.
[02:35.440 --> 02:41.320]  Сортировка, которую мы до этого делали с вами. Топологическая сортировка хочет сделать
[02:41.320 --> 02:50.000]  перестановку ваших вершин таким образом, чтобы фактически все ребра в вашем графе шли слева
[02:50.000 --> 02:57.040]  направо. То есть у вас не было никогда ребра справа налево. Поэтому топологическая сортировка
[02:57.040 --> 03:02.280]  чаще всего делается для ациклических графов. Потому что если вдруг у вас есть цикл, то у вас
[03:02.280 --> 03:08.840]  обязательно будет ребро назад. Иначе как вы шли по этому циклу. Поэтому здесь важно понимать,
[03:08.840 --> 03:15.000]  что эта сортировка нам поможет вот изобразить, грубо говоря, какую-то последовательность действий,
[03:16.000 --> 03:22.080]  от которой будет начинаться. И мы понимаем, что дальше от нее что-то будет зависеть. Естественно,
[03:22.080 --> 03:26.440]  из определений топологической сортировки мы получаем таких перестановок может быть вообще
[03:26.440 --> 03:34.600]  сколько угодно. Ну не бесконечное число, у нас все-таки количество вершин ограничено. Но точно больше
[03:34.600 --> 03:42.560]  одной, к примеру, для большинства графов вы найдете. Для цикличных графов. Поэтому топологическая
[03:42.560 --> 03:47.400]  сортировка может быть в любом виде. Главное, чтобы у вас те самые ребра шли слева направо.
[03:47.400 --> 03:53.600]  Вот здесь вот у нас изображен небольшой граф. Видите, как он здесь сделан. Ну и грубо говоря,
[03:53.600 --> 04:02.400]  из 4 у нас выходит только два ребра в 0 и 1. Из 2 у нас выходит ребро только в 0. Из 0 в 0 входит
[04:02.400 --> 04:08.720]  4 и 2, поэтому они находятся левее. А вот из него выходит ребро в тройку. Ну аналогично про единицу
[04:08.720 --> 04:13.760]  и тройку можно сказать. То есть фактически мы взяли, расположили как-то вершины, сказали,
[04:13.760 --> 04:24.880]  что это есть наша топологическая сортировка. Да. А для какого из графов? Для цикличного? Да.
[04:24.880 --> 04:39.400]  А в плане ориентированно-неориентированный граф, грубо говоря? А это уже тогда цикл.
[04:39.400 --> 04:49.640]  То есть если у нас есть вершины, есть вершина, которая одна сюда, одна сюда, то это все-таки цикл.
[04:49.640 --> 04:58.720]  Вот. Поэтому для ориентированного графа делаются логические сортировки, где у нас нет тех самых циклов.
[04:58.720 --> 05:09.480]  Окей. Если у вас вдруг есть петля, это тоже цикл. А понятно сама суть, что здесь хочется сделать?
[05:09.480 --> 05:18.440]  Отлично. Каков план нахождения данной топологической сортировки? Вот здесь вот он написан, что мы
[05:18.440 --> 05:25.960]  просто берем, запускаем DFS, ну и в принципе все. Давайте с вами разбираться, а что у нас может
[05:25.960 --> 05:31.480]  происходить на каждом из этапов DFS. Представим следующую картину. Вот мы идем нашим DFS,
[05:31.480 --> 05:39.520]  только первый раз запустили. Я пришел в какую-то вершину, из которой я никуда не могу прийти.
[05:39.520 --> 05:45.880]  Ну то есть это вот эта самая последняя вершинка, не знаю, какая-нибудь X, из которой я не могу
[05:45.880 --> 05:54.160]  никуда пойти дальше на моим DFS. Что означает, что не могу никуда пойти дальше? Почему?
[05:54.160 --> 06:05.160]  С точки зрения DFS, а что означает, что мы в вершине никуда не можем пойти?
[06:05.160 --> 06:20.840]  Не совсем. В какие вершины можно смотреть данное? Только в черные, не в серые. Вот это вершинка X.
[06:20.840 --> 06:25.760]  У меня DFS на ней заканчивается. Ну то есть не заканчивается, он не может продвинуться дальше,
[06:25.760 --> 06:31.280]  он должен будет откатываться. Что это означает для вершины X? Что мы можем на ней сказать?
[06:31.280 --> 06:41.360]  Нет белых. Что это по факту означает? По факту означает, первый вариант, что у нас просто нет
[06:41.360 --> 06:50.960]  ребер. Согласна? То есть она просто конечная сама по себе. Второй вариант какой? У нас есть ребров
[06:50.960 --> 07:00.880]  в серую вершинку и третий вариант у нас есть ребро в черную вершину. Возможно ли второй-третий
[07:00.880 --> 07:09.520]  вариант? Почему? Потому что граф ациклический. Отлично, то есть второго варианта в принципе не
[07:09.520 --> 07:26.280]  существует. Третий вариант здесь возможен? Это первый запуск DFS. В первый запуск DFS ничего не
[07:26.280 --> 07:32.800]  может такого произойти. Вот это вот первая вершина, где зашел в тупик. У нее нет ребер.
[07:32.800 --> 07:41.440]  Значит в серую мы прийти не могли, черных еще не существует. То есть я когда шел по моему DFS вот
[07:41.440 --> 07:47.680]  эти все вершины стали серые, остальные остаются белыми, а вот эта вершина просто у нее нет ребер.
[07:47.680 --> 08:03.640]  Окей, понятно почему? Встали в тупик. Ну это первая итерация, где мы встали в тупик, да. Вот,
[08:03.640 --> 08:12.080]  поэтому грубо говоря, если я положу это в конец моего списка, ничего не произойдет. Согласна? Ну
[08:12.080 --> 08:17.160]  потому что из нее нет вершин, но окей. Теперь я перейду к соседней вершине и скажу, что тут
[08:17.160 --> 08:24.320]  я дошел до новой вершины Y. Какие вершины она может смотреть? Какие у нее случаи есть из этих всех?
[08:24.320 --> 08:31.880]  Черное отсутствие ребер. Если у нас отсутствует ребра, я положу ее вот сюда,
[08:31.880 --> 08:38.360]  ничего не произойдет. Правда? Ну плохого для моей этапологической сортировки. А если у меня
[08:38.360 --> 08:45.360]  были ребра в черной вершины, что может быть черными вершинами? Только та X, которая у нас есть.
[08:45.360 --> 08:51.680]  И так далее. То есть вот раскручивая вот такой же механизм, мы с вами получим, что если мы кладем
[08:51.680 --> 08:57.120]  просто вершинки вот в таком формате, грубо говоря, push front делаем постоянный, но в действительности это
[08:57.120 --> 09:03.000]  не очень хорошо. Просто будем делать push back, потом reverse. Если мы делаем в таком вот виде, то у нас
[09:03.000 --> 09:09.640]  ребра будут смотреть только вот в ту сторону. Серых ребер из белого в серое не существует,
[09:09.640 --> 09:16.240]  существует только черные вершинки. Черные вершинки мы уже все просмотрели, все хорошо. Понятно?
[09:16.240 --> 09:28.760]  Вопросы? Вот. Благодаря этому мы с вами получим некоторый массив, и он будет топологически
[09:28.760 --> 09:39.320]  отсортирован. Вот и все. Это план того, как это выглядит. Фактически это называется алгоритмом
[09:39.320 --> 09:47.560]  тарьяна. Все, что здесь происходит. Вот у вас есть здесь топсорт DFS. Что такое топсорт DFS? Ну,
[09:47.560 --> 09:52.680]  фактически это тот самый DFS. Единственное, что там добавляется, что если вдруг мы нашли с вами
[09:52.680 --> 09:59.320]  серую вершину, то в этом случае мы делаем false. Почему? Потому что мы нашли цикл. Мы нашли из белой
[09:59.320 --> 10:07.600]  вершины в серую. Значит, у нас появился цикл. С циклами мы работать не будем. Вот. И дальше мы с
[10:07.600 --> 10:14.880]  вами просто push-batch-им наши вот эти топсортed вершинки. В массив топсортed. И в конце мы делаем
[10:14.880 --> 10:30.280]  просто reverse. Вот и все. В начало закидывать, тогда вам использовать нужно что? Дек. Правильно или
[10:30.280 --> 10:40.760]  использовать дек? Какой лист? Ну, здесь это написано листом, потому что это написано на
[10:40.760 --> 10:55.080]  питоне. Фактически для вас вектор. Что лучше, дек или вектор? Задача. Ну, у нас никакой здесь
[10:55.080 --> 11:02.720]  инвалидации сывок не бывает, инвалидации итераторов не бывает, поэтому можно и запить. Вот. Да,
[11:02.720 --> 11:08.040]  в действительности как бы здесь можно просто взять, развернуть, все здесь получится. Вот.
[11:08.040 --> 11:16.520]  Алгоритм Тарьяна достаточно понятный, простой и работающий. За сколько работает? Ну, фактически
[11:16.520 --> 11:24.240]  это время работы DFS. Да. Он работает за столько, за сколько DFS. DFS работает за O от V плюс E в случае
[11:24.360 --> 11:37.440]  если мы делаем на чем? На списках смежности. А если на матрице смежности? В в квадрате. Хорошо.
[11:37.440 --> 11:46.840]  Давайте вспоминаем прошлую лекцию и работаем с этой. Окей. Давайте докажем, что это корректно.
[11:46.840 --> 11:56.480]  Есть какие-нибудь идеи, как это можно сделать? Очевидно, что люблю такое. Нет,
[11:56.480 --> 12:01.320]  действительности это не совсем так. Ну, первое утверждение относительно циклов. Мы с вами знаем,
[12:01.320 --> 12:06.840]  что если мы найдем с вами из белой вершины в серую, то мы находим цикл, все он выводит false,
[12:06.840 --> 12:13.320]  алгоритм корректен. Согласны? Вот. Пусть циклы нет, тогда, да, действительности по индукции
[12:13.320 --> 12:24.080]  покажем, что у нас нету ребер, которые идут с права налево. Вот. Изначально он пуст наш
[12:24.080 --> 12:30.440]  массивтик топ сорта, значит у нас все хорошо. Пусть на каком-то очередном шаге мы с вами
[12:30.440 --> 12:40.360]  положили какую-то вершину V и вот здесь вот у нас уже есть какие-то там вершинки. Отлично. У нас
[12:40.360 --> 12:47.960]  для этих всех вершин мы точно знаем, что у них там ребра идут только справа налево. Ну как не так?
[12:47.960 --> 13:04.600]  Вот. Чудно. Какие все вот эти вершины? А? Черные сами по себе, да? Значит, мы их уже рассмотрели.
[13:04.600 --> 13:14.320]  А из черной вершины мы не могли прийти никак V, потому что иначе бы мы это сделали, она белая.
[13:14.320 --> 13:20.740]  Значит, иначе бы у нас был путь к ней и тогда бы DFS не заканчивался сам по себе. Значит,
[13:20.740 --> 13:32.520]  у нас никакого ребра справа налево нет. Понятно механика рассуждений? Смотрите. Данная вершина
[13:32.520 --> 13:43.560]  V, когда мы ее кладем, она какого цвета должна быть? Когда мы кладем ее, она уже черная. Вот. Но до
[13:43.560 --> 13:50.320]  этого момента она была там серой, а мы знаем, что из, что мы в серую вершину прийти просто так
[13:50.320 --> 13:59.120]  не могли. Правильно? Это первое. Второе. А если бы у нас было ребро в обратную сторону,
[13:59.120 --> 14:13.560]  что бы это означало? Мы из черной пришли в серую. А у нас вообще такое возможно? Нет. Кроме того,
[14:13.800 --> 14:20.840]  если бы у нас была обследована сама по себе вершинка, то мы бы ее должны были закинуть в DFS и
[14:20.840 --> 14:33.000]  не заканчивать с той вершины, которая здесь. Понятно механизм? Вот. Все просто. Правда? Коррекцион
[14:33.000 --> 14:42.080]  алгоритм. Хорошо работает. Вот это является как раз таки топологической сортировкой. Вопросы
[14:42.080 --> 14:52.280]  к ней есть? Что такое лучший вариант? За E плюс V. А как еще ты хочешь быстрее найти
[14:52.280 --> 14:59.240]  топологически? Ты можешь быстрее, чем за V это сделать? Точно нет. У тебя все-таки V вершинок.
[14:59.240 --> 15:13.840]  Вот. А ты можешь сделать это быстрее, чем за E? Нужно ребра посмотреть хотя бы. Вот. Как-то так.
[15:13.840 --> 15:22.760]  Окей. Переходим с вами к компонентам сильной связанности. Эта тема непрерывно тоже связана
[15:22.760 --> 15:29.200]  с топологической сортировкой со всем DFS, что у нас вообще есть. И мы с вами будем это смотреть.
[15:29.200 --> 15:35.080]  Что такое сильная связанность? На всякий случай напомню с прошлой лекции. Ориентированный граф сам
[15:35.080 --> 15:42.720]  по себе называется сильным связанным, если из любой вершины существует путь в любую другую вершину.
[15:42.720 --> 15:50.920]  Вот. То есть мы с вами смотрим, что у нас есть путь из вершины V в U, из U в V, к примеру, и так
[15:50.920 --> 15:58.000]  далее. И компоненты сильной связанности в графе называются максимальные по включению сильно связанные
[15:58.000 --> 16:03.480]  под граф. То есть мы взяли оттуда все ребра, взяли все вершины, которые можно. Вот. Выбрали
[16:03.480 --> 16:08.920]  необходимую нам компоненту и смотрим. Ага. В этой компоненте мы можем от одной вершины добраться
[16:08.920 --> 16:14.520]  до любой другой. И так далее. И вот это является компонентой сильной связанности. Вот. В данном
[16:14.520 --> 16:18.240]  графе. А как вы думаете, что будет являться компонентой сильной связанности? Давайте я его
[16:18.240 --> 16:29.160]  пририсую. Смотрите. Давайте по чуть-чуть. Вот это является компонентой сильной связанности? Да.
[16:29.160 --> 16:35.160]  Потому что я из любой вершины, вот здесь у меня цикл появляется, все хорошо. Они между собой связаны,
[16:35.160 --> 16:41.600]  я от одной вершины к другой могу сделать. Могу ли я добавить в эту компоненту еще что-нибудь? Нет.
[16:41.600 --> 16:50.680]  Из этой компоненты все ребра выходят, в нее войти нельзя. Грубо говоря, добавлю я шесть,
[16:50.680 --> 16:58.160]  я из шести не могу прийти к нулю. Вот. Добавлю пять из пяти, не могу прийти к единичке. И так далее.
[16:58.160 --> 17:06.080]  Поэтому это максимальная компонента, которая у меня сейчас есть. Вторая компонент это три-четыре.
[17:06.080 --> 17:12.400]  Согласна? Они тоже цикличные, друг к дружку ходить умеют. Добавить сюда шесть я тоже не могу,
[17:12.400 --> 17:19.400]  потому что из шести я туда попасть никак не могу. Нет обратного ребра. Поэтому у меня еще шесть и
[17:19.400 --> 17:30.680]  пять. Поэтому в этом графе четыре компоненты связанности. 0, 1, 2, 3, 4, 6 и 5. Ага. Понятно,
[17:30.680 --> 17:38.840]  как выглядит компоненты связанности? Вот. Это и есть то, что нам необходимо. Как мы будем с ними
[17:38.840 --> 17:44.680]  работать? А мы будем работать с ними через конденсацию графа. Что такое конденсация ориентированного
[17:44.680 --> 17:50.280]  графа? Вот эта полная компонента сильной связанности, грубо говоря, сжимается до одной такой большой
[17:50.280 --> 17:59.360]  вершинки, назовем это так. Поэтому здесь мы с вами... Осторожно. У нас есть компоненты А, в которые
[17:59.360 --> 18:11.280]  лежат вершины 0, 1, 2. У нас есть компоненты В, которые лежат 3, 4. У нас есть С и у нас есть Д. Здесь 5,
[18:11.280 --> 18:19.760]  здесь 6 вершин. Вот. И дальше мы смотрим лишь на те ребра, которые лежат между этими компонентами.
[18:19.760 --> 18:26.600]  Мы не смотрим внутри. Почему? Почему нам не интересно внутри? Потому что в этом случае у меня от любой
[18:26.600 --> 18:31.440]  вершины можно добраться к любой вершине. Вот эта компонента мы просто сжимаем. Такое вот моментико.
[18:31.440 --> 18:44.200]  И с вами получаем здесь что? Что из А можно в В, можно в С, можно в D, а из В в С. Всё. Вот. Это
[18:44.200 --> 18:52.680]  называется конденсацией графа. Поэтому просто мы вот объединяем вот необходимые нам компоненты,
[18:52.680 --> 19:00.160]  формируем их и получаем то, что нам нужно. Вот это есть такая штука. Понятно с конденсацией?
[19:00.160 --> 19:19.160]  Хорошо. А утверждение? Конденсация графа нет циклов. Почему? Иначе бы они были в одной компоненте
[19:19.160 --> 19:26.760]  связности. Да. То есть если мы допускаем с вами, что цикл у нас есть, то из одной вершины одной
[19:26.760 --> 19:32.440]  компоненты можно добраться до любой другой вершины другой компоненты. А значит это всё должно быть одной
[19:32.440 --> 19:37.920]  большой компоненты сильной связности. А компоненты сильной связности, она максимальная по включению
[19:37.920 --> 19:46.600]  этих вершинок. Противоречие мы получаем с вами здесь, которое у нас есть. Так что да, у нас нет
[19:46.600 --> 19:59.040]  никаких циклов. Ага. Вроде это понятно. Правда? Чудно. И вот здесь, и вот здесь, у нас будет
[19:59.040 --> 20:05.520]  применение той самой топологической сортировки, вот эта вот лемма, которая нам понадобится в
[20:05.520 --> 20:11.240]  дальнейшем. Звучит она так. Давайте будем партией с вами слова, и вы должны объяснить,
[20:12.240 --> 20:20.280]  смысл её или нет. У нас A и B компоненты сильной связности в графа G. У нас есть ребро какое-то из
[20:20.280 --> 20:28.360]  A в B. Если мы запустим алгоритм топологической сортировки на графе G, но без проверки на цикличность,
[20:28.360 --> 20:35.760]  то найдётся какая-то вершина A, которая будет располагаться любой другой вершины из B.
[20:35.760 --> 20:45.720]  Смотрите, суть какая. Да, у нас есть A, и здесь есть какая-нибудь маленькая вершинка A. У нас есть
[20:45.720 --> 20:59.720]  какое-то ребро из A в B. Вот. И в этом B у нас тоже какие-то вершинки есть. В чём суть? Суть в
[20:59.720 --> 21:08.040]  следующем. При топологической сортировке, забивая на циклы сами по себе. То есть,
[21:08.040 --> 21:12.040]  если мы не будем делать return, то есть в каком-то виде всё равно топологическая
[21:12.040 --> 21:16.640]  сортировка сработает и покажет нам какой-то массивчик. Согласны? Ну, может, правильно,
[21:16.640 --> 21:22.280]  может, нет. Будем смотреть. Вот. А что происходит в этом случае? Происходит следующее, что у нас
[21:22.280 --> 21:30.280]  вот эта вершина A, которая находится в A, она будет лежать левее, чем вот эти все вершинки. Возможно,
[21:30.280 --> 21:35.280]  там ещё какие-то добавляются вершинки, не суть важна. Но лежит левее, чем все вершины из B.
[21:35.280 --> 21:50.280]  Вот это там B1, B2 и так далее. Понятно? Вот что подразумевает эта лемма. Если это лемма,
[21:50.280 --> 21:57.400]  то, наверное, это правда. А кто представляет, как это можно доказать? Ну, сутьевая часть правда. На
[21:57.400 --> 22:04.040]  самом деле, вот примерно такой логики я всегда и придерживался здесь. Что важно, если мы берём с
[22:04.040 --> 22:11.400]  вами вершину A какую-то, у нас DFS для всего графа A и B не обязательно самый первый, где идёт DFS.
[22:11.400 --> 22:17.720]  Какие два варианта есть? Первый вариант, я захожу DFS в A большое, второй вариант, я захожу DFS в B
[22:17.720 --> 22:24.920]  большое. В случае первого варианта у меня есть маленькая вершина какая-нибудь, не знаю, вот здесь
[22:24.920 --> 22:35.080]  вот лежащая, и для неё это первая вершина из A большого, в которую я зашёл в DFS. То есть это прям первая
[22:35.080 --> 22:42.640]  вершина, для которой это существует. Я в неё захожу. Все остальные вершины из A и B какие цветом?
[22:42.640 --> 22:48.200]  Белые. А что нам говорит Лемма о белых путях?
[22:48.200 --> 22:58.960]  Кто говорит Лемма о белых путях?
[22:58.960 --> 23:09.480]  Почти. Ну, по сути, своя да. То есть если у нас есть какой-то белый путь сам по себе,
[23:09.480 --> 23:18.040]  то мы обязательно это сделаем в нашем DFS. У нас все вершины белые. Значит, я все вершины
[23:18.040 --> 23:27.320]  B посещу. Согласны? Они станут чёрными, потому что они внутри вот здесь существуют. Когда мы
[23:27.320 --> 23:36.680]  зашли в эту вершинку, то она будет левее. Понятно? Потому что из неё мы ещё не вышли. То есть из неё
[23:36.680 --> 23:42.400]  я точно могу добраться до всех вершинок B. Они там вместе все станут чёрными. Я только потом вернусь
[23:42.400 --> 23:57.080]  в A. Ясно? Да. Если мы начинаем DFS и зашли в A большое, в какую-то вершину A маленькая. Возможно,
[23:57.080 --> 24:04.280]  обратная ситуация, когда я захожу в B. Вот смотрите, я зайду в B. Я его весь по Лемме о белых
[24:04.280 --> 24:11.480]  путях пройду. Правильно? Положу куда-нибудь в топологическую сортировку. Могу ли я попасть
[24:11.480 --> 24:19.320]  куда-то в A? Нет, у нас нет ребра такого. Значит, потом когда-нибудь я зайду в A. Но если я потом
[24:19.320 --> 24:25.880]  когда-нибудь зайду в A, то оно будет, естественно, лежать левее. Логика такая. Это и есть доказательство
[24:25.880 --> 24:33.560]  этой Леммы. Само по себе чуть более формально описанное. С тем, что мы объединяем множество
[24:33.560 --> 24:41.560]  A и B, смотрим, какую вершину там встретили, вот эту вершину A и так далее. И как бы здесь мы с вами это
[24:41.560 --> 24:54.280]  все делаем. Так что как-то так. Доказательство понятное? Вопросы есть? Не обязательно есть путь.
[24:54.280 --> 25:02.200]  Если что-то лежит слева и справа, то нет. И слева никогда не всегда есть путь вправо. Окей?
[25:02.200 --> 25:17.760]  Вопросов нет. Его понятно. Чудеса. Хорошо. Ладно. А что еще важно знать? Важно знать следующее.
[25:17.760 --> 25:21.640]  Транспонирование графа. Что это такое? Транспонирование графа, это когда мы просто
[25:21.640 --> 25:29.120]  перенаправляем с вами ребра. Берем это и переделаем, а вершина остается. Те же самые. Ребра просто идут
[25:29.120 --> 25:44.400]  в обратном порядке. Скажите, все ли могут доказать эту лему? Внутри, как было из одной вершины в другую,
[25:44.400 --> 25:50.960]  можно добраться. Так и осталось. Правильно? Вот. А вовне, ну как бы ничего не произойдет. Ну,
[25:50.960 --> 26:02.080]  да. Так что да. Надеюсь, вы это самостоятельно сможете, если что, доказать на экзамен. Правда?
[26:02.080 --> 26:14.080]  Какой-то нервный смех. Это не очень хорошо. Ладно. А какой же алгоритм вообще поиска компонент
[26:14.080 --> 26:19.840]  сильных связанностей? То есть мы хотим найти все компоненты сильной связанности в нашем графе.
[26:19.840 --> 26:28.280]  Алгоритм примерно следующий. Давайте я возьму, запущу DFS, построю топ-сорт. У меня будут расположены
[26:28.280 --> 26:34.640]  как-то вершинки. Транспонирую граф и запущу DFS в том порядке, в котором они были в топ-сорт.
[26:34.640 --> 26:46.080]  Начнем с вершины ровно в том порядке. То есть не с нулевой, грубо говоря, начинаем DFS, а с других.
[26:46.080 --> 27:04.000]  Смотрите, у нас топ-сорт и не исток, и не исход. Давайте с вами сделаем на примере,
[27:04.320 --> 27:16.200]  вы поймете, что я имею в виду. Хорошо? Вот этот же пример возьмем. С какой вершины хотите начать?
[27:16.200 --> 27:29.600]  С третьей. Давайте с вами смотреть. С третьей я могу попасть в четыре, правильно? И с четыре
[27:29.600 --> 27:35.840]  я могу попасть в шесть. Другого варианта нет. В шесть я остаюсь, у меня ничего не получается.
[27:35.840 --> 27:45.480]  В шесть я записываю. А возвращаюсь в четыре. И с четыре я куда-нибудь могу попасть? Ну в три я уже был.
[27:45.480 --> 27:53.480]  Ну а в серый вершины заново не захожу. Вот, поэтому никуда по сути еще попасть не могу,
[27:53.480 --> 28:04.560]  только в белые. Поэтому четыре, три. Чудесно. Какую следующую вершину возьму? Пять? И с пять
[28:04.560 --> 28:11.320]  я никуда не могу попасть, поэтому просто ее вношу. Хорошо, давайте дальше. Один из один в два,
[28:11.320 --> 28:18.120]  из два в ноль, из ноль никуда. Вот эти все уже обработаны, они черные. Отсюда никуда не могу
[28:18.120 --> 28:28.120]  попасть. Поэтому сюда ставлю ноль, потом два, потом один. Вот у меня топ-сорт. Согласны?
[28:28.120 --> 28:39.400]  Я специально писал в ту сторону, а не в ту. Я не пушбэчил. Ну давайте на всякий случай. Из один в два,
[28:39.400 --> 28:52.240]  из один пять. Кто там? Из нуля один есть, но это наш цикл как раз-таки, который нам будет мешать именно
[28:52.240 --> 29:02.080]  для топ-сорта топ-сорта. Из два у меня есть в нолик, из два у меня есть в шесть, из три в четыре,
[29:02.080 --> 29:09.120]  из четыре в три, из пяти никуда, из четырех в шесть. То есть у меня вот циклы только появились.
[29:09.120 --> 29:18.640]  Но я пока забил на эти циклы, только они мне мешают для топ-сорта. Хорошо, разворачиваю все
[29:18.640 --> 29:27.080]  ребра, которые у меня есть. Как будет выглядеть граф с развернутыми ребрами? Давайте нарисуем ноль,
[29:27.080 --> 29:44.200]  один, два. Сейчас я нарисую, потом ребр проведу. Пять, четыре, три. Разворачиваю ребра, у меня получается
[29:44.200 --> 29:59.080]  вот так, вот так, вот так, вот так, из шести вот так, четырех вот так. Ну а здесь остается то же самое.
[29:59.080 --> 30:11.480]  А и еще вот тут. Развернул. И теперь я буду запускать DFS согласно той последовательности,
[30:11.560 --> 30:19.680]  которой здесь есть. Я опять все говорю, что они все белые, эти вершины. Давайте запустим DFS единички.
[30:19.680 --> 30:32.080]  Что сделает единичка в этом случае? Какие вершины? Ноль в два и все. Ноль в два и все. И в этом случае
[30:32.080 --> 30:38.800]  я что получаю? Вот я запустил свой DFS и получил вот эту компоненту обязанности. То есть у меня
[30:38.800 --> 30:58.560]  будет один, ноль, два. Первая компонент. Согласны? Что на третьем шаге происходит? Да, вот этот DFS
[30:58.560 --> 31:04.280]  будет возвращать последовательств вершин. Ну вот один, ноль, два. Больше он никуда прийти не может.
[31:04.280 --> 31:12.520]  Дальше. Что у нас есть еще? Дальше мы идем вот тут один, два, ноль. Мы уже были, правильно? Пять заходим.
[31:12.520 --> 31:17.160]  Пять. Мы можем прийти только в черные уже вершины. Мы туда не заходим, поэтому остается
[31:17.160 --> 31:26.920]  просто компонента пять. Согласны? Три, четыре. Мы идем в три. Смотрим, что из нее можно попасть в
[31:26.920 --> 31:33.280]  четыре. И в ноль мы пойти не можем, потому что он уже черный. Только вернуться в три. Поэтому у меня
[31:33.280 --> 31:43.640]  компонент получается три, четыре. Согласны? Ну и последний компонент будет шесть. Почему это работает?
[31:43.640 --> 31:51.160]  Смотрите. Работает это примерно по следующей схеме. У нас с вами была конденсация графа.
[31:51.160 --> 32:07.840]  Была вот такая вот конденсация. А мы, когда начали с вами, вот с чего мы там начали,
[32:07.840 --> 32:13.840]  с какой вершины? С трех мы начали, к примеру. Мы с вами начали отсюда, пришли вот сюда,
[32:13.840 --> 32:19.480]  смотрели, как эти компоненты связаны между собой. А теперь смотрите, если из компоненты,
[32:19.600 --> 32:24.240]  я из какой компонент связанности мог прийти в какую-то другую? Только в случае,
[32:24.240 --> 32:31.320]  если у меня были вот такие ребра. Согласны? Если я сюда так пришел, то вот эти компоненты,
[32:31.320 --> 32:40.760]  где лежат относительно вообще моего существования, грубо говоря, в топологической сортировке? Слева,
[32:40.840 --> 32:52.480]  справа, справа от вот этой. Согласны? Почти всегда. Вот именно эта лемма, которую мы с вами
[32:52.480 --> 32:59.120]  доказали только недавно, говорит о том, что есть вершинка одна, что если у нас есть ребро,
[32:59.120 --> 33:07.920]  то она в топологической сортировке лежит левее. Согласны? Есть такое. То есть, по сути своей,
[33:08.240 --> 33:15.640]  если я с вами разверну все ребра, целютно все, то все вот эти связки B1, B4 и так далее,
[33:15.640 --> 33:22.960]  они не смогут прийти в А. Никак. Я из А не смогу к ним прийти. Почему? Потому что я вот это ребро
[33:22.960 --> 33:31.760]  разверну. А так как я иду слева направо, то я вначале найду эту вершину А, а только потом
[33:31.760 --> 33:41.160]  компоненту B. Согласны? Потому что я все развернул здесь. А значит, я обработаю всю свою компоненту,
[33:41.160 --> 33:47.160]  которая у меня есть. Потому что у меня как была здесь сильно связана, так и осталась. Согласны?
[33:47.160 --> 33:57.520]  Вот суть примерно такая. Сейчас более формально с вами посмотрим. Но с точки зрения алгоритма,
[33:57.520 --> 34:04.280]  ну как работает этот алгоритм. Ну это пофактически два DFS. Вы говорите, у нас есть colors,
[34:04.280 --> 34:11.520]  у нас есть компоненты. Вот, а в этом вашем DFS вы просто смотрите, мы смотрим на белую вершинку,
[34:11.520 --> 34:21.360]  запишем ее в новые компоненты связанности, все хорошо. Вот именно сам DFS. И чудесно. А с точки
[34:21.360 --> 34:27.640]  зрения компоненты сильной связанности, вы сначала сделаете топ-сорт. Делаете топ-сорт,
[34:27.640 --> 34:33.000]  смотрите какой у вас порядок. И в зависимости от этого порядка делаете ваш вот этот DFS. Вот этот
[34:33.000 --> 34:38.960]  DFS он отличается вот тем, что у нас 4 way in order. То есть мы задаем определенный порядок, в котором
[34:38.960 --> 34:53.160]  обходим все вершины. Вот и все. Ну как бы все понятно. Кого? DFS как сделать? Ну вот смотри,
[34:53.160 --> 35:04.560]  у меня g.t написан. Транспонированный. Да. Вы когда будете делать задачки, на самом деле хранить,
[35:04.560 --> 35:19.280]  хранить будете. Ага, еще вопрос. Сам алгоритм понятно написан? Окей. Время работы, ну как бы
[35:19.280 --> 35:28.800]  v плюс e, 2 DFS, ничего страшного здесь нет. Корректность. Почему все это корректно? Ну смотрите,
[35:28.800 --> 35:36.520]  по лемме 1 мы отсортировали компоненты сильной связанности топологически. То есть присутствует
[35:36.520 --> 35:42.080]  вершина, которая лежит левее, чем правая. Вот возвращаемся ровно к тому, что мы сейчас говорили
[35:42.080 --> 35:51.800]  с вами. Это первое. Оно отсортировано, все чудесно. После второго шага по лемме 2, напомню лемма 2 это
[35:51.800 --> 36:00.560]  то, что мы с вами говорили, что в транспонированном графе у нас все компоненты остаются на своем же
[36:00.560 --> 36:07.320]  месте. Остались у нас компоненты сильной связанности такие же. И вот на третьем шаге, когда мы уже с вами
[36:07.320 --> 36:15.160]  развернули и делаем DFS, то по лемме 1 в начале ордер лежит вершина, которая принадлежит компоненту,
[36:15.160 --> 36:21.720]  в которую после транспонирования, возможно, входит большинство ребер, но ничего не выходит. То есть
[36:21.720 --> 36:28.800]  вот эта компонента, которая лежит в самом начале транспонированной графе, в нее все ребра только
[36:28.800 --> 36:36.400]  будут ходить. Понятно? Поэтому там у нас ничего не происходит, мы только лишь по этой компоненте и
[36:36.400 --> 36:45.400]  ходим. И по ленью белых путях мы все это прошли, всю компоненту поняли, как она выглядит. У нас все
[36:45.400 --> 36:50.560]  вершины стали черными, все чудесно. Переходим к следующей компоненте и так далее. То есть мы
[36:50.560 --> 36:56.120]  каждый раз это видим таким вот образом, что у нас в самом начале лежит компоненты, из которой все
[36:56.120 --> 37:01.440]  выходит, но ничего не входит. А в следующий раз у нас будет компонента, в которую, быть может,
[37:01.440 --> 37:08.440]  заходила предыдущая компонента, но не более. И все остальные вершины входят. Понятно? Ну то есть
[37:08.440 --> 37:15.080]  из нее ребро входит. Вот так что это можно делать. Все это хорошо. Называется это алгоритм касараю.
[37:15.080 --> 37:33.720]  Приятный достаточно алгоритм. Ага. Есть вопросы? Какие-то полумертвые. Чего такое? Март, весна, красиво.
[37:33.720 --> 37:54.840]  Грустная история. Ладно, хорошо. В общем-то, это все, что касается топологической ассортировки и
[37:54.840 --> 38:00.120]  компонент сильно связан. Надеюсь, теперь вы сможете решить эти задачки. Они достаточно просты,
[38:00.120 --> 38:05.800]  ничего сложного в них нет. Еще про что хотелось бы сегодня с вами поговорить. Про эйлеровость.
[38:05.800 --> 38:22.320]  Кто знает, что такое эйлеровграф? А вы все из мат-группы, да, или нет? Понял, принял, осознал. А? Да,
[38:22.320 --> 38:28.040]  это правда. Каждое ребро необходимо обойти. Существует эйлеровый граф, полуэйлеровый граф.
[38:28.040 --> 38:32.760]  Смотрите, что такое эйлеровпуть. Эйлеровпуть — это путь, в котором мы проходим по каждому
[38:32.760 --> 38:39.160]  ребру. Полуэйлеровграф — это где у нас есть эйлеровпуть. Эйлеровцикл — это замкнутый эйлеровпуть,
[38:39.160 --> 38:45.880]  то есть мы вернули в самое начало и можем это сделать. И тогда такой граф, в котором есть эйлеровцикл,
[38:45.880 --> 38:51.280]  называется эйлеровым графом. Вот тот граф, который здесь представлен, ну каким является?
[38:51.280 --> 38:59.280]  Точно не эйлеровым. Полуэйлеровым — да, но здесь это достаточно просто показать,
[38:59.280 --> 39:12.120]  или не просто? Просто. Какой путь должен быть? Все верно. Да, то есть здесь мы с вами пройти
[39:12.120 --> 39:19.400]  достаточно просто сможем, и это будет полуэйлеровграф. Какие есть критерии эйлеровости? Ну,
[39:19.400 --> 39:26.080]  мы с вами говорим, что наш граф эйлеров, если он содержит не более одной компоненты связанности
[39:26.080 --> 39:33.040]  с ребрами и степени вершины все четные, здесь граф, на всякий случай, неориентированный. Вот.
[39:33.040 --> 39:43.080]  Я это подсвечу. Что подразумевается здесь под высказыванием, что у нас не более одной
[39:43.080 --> 39:55.160]  компоненты связанности с ребрами? Возможно, ситуация примерно следующая. У вас есть
[39:55.160 --> 40:00.720]  некоторая компонента, где у вас действительно лежат там какие-то связанности сами по себе,
[40:00.720 --> 40:08.400]  там что-то происходит в этом графе. А тут еще вот такие вот обособленные просто вершинки без ребер.
[40:08.400 --> 40:17.520]  То есть вот это все должно быть связано, а вот это вот может существовать. Окей? Если у
[40:17.520 --> 40:24.000]  вас присутствует более одной компоненты связанности, то это не работает. Вот. И степень
[40:24.000 --> 40:35.600]  всех вершин четная. Понятно? Просто знаете такое или не знали еще такое? Было? Где было?
[40:35.600 --> 40:48.880]  Хорошо. Отлично. Вам от группы было? Мало ли? На всякий случай. А, в программе не было? Хорошо.
[40:48.880 --> 40:57.600]  Ну в школе было, видимо. А, понял. Хорошо. Окей. Как это доказывается? Смотрите, ну в одну сторону
[40:57.600 --> 41:05.360]  достаточно просто про эйлеровость. Что у нас есть замкнутый путь, если граф эйлеров, значит,
[41:05.360 --> 41:12.280]  мы можем зайти в каждую вершину и выйти из нее. Значит, у каждой степени вершины четно. Ну и,
[41:12.280 --> 41:18.760]  в принципе, все. И как бы все связано, потому что у нас есть вот этот вот обход по всем ребрам.
[41:18.760 --> 41:24.080]  В обратную сторону мы просто построим алгоритм и скажем, что вот в этом случае все эйлерово.
[41:24.080 --> 41:39.480]  Поэтому мы будем исходить из другого. Да, не бывает таких вопросов. Бывает в неориентированном.
[41:39.480 --> 41:51.280]  Граф неориентированный в этом случае. Вот, что касается критерия полуэйлеровости. Она аналогична
[41:51.280 --> 41:56.960]  эйлеровости, кроме одного, что у нас степень вершины всегда четная, кроме, быть может, двух вершин.
[41:56.960 --> 42:06.000]  Начально и конечное. Все верно. То есть фактически вам говорят следующее. У вас вот есть какие-то две
[42:06.000 --> 42:13.760]  вершинки, у которых там есть ребра, все такое. Вот у них нечетное. Как доказать, что в этом случае
[42:13.760 --> 42:21.320]  вот это все полуэйлерово. То есть из полуэйлеровости там будет что-то следовать. Давайте соединим их.
[42:21.320 --> 42:31.840]  В этом случае степень у всех вершин будут четные. У нас одна компонента связанности с ребрами.
[42:31.840 --> 42:43.000]  Ну и в этом случае этот граф эйлеров. Выкинем вершину полуэйлеров. Понятно? То есть грубо
[42:43.000 --> 42:51.680]  говоря, что значит эйлеровость? Что у вас есть цикл. Если я уберу это ребро, то у нас цикл перестанет быть.
[42:51.680 --> 42:58.440]  Но мы дойти до этой вершины дойдем? Дойдем. То есть вы разомкнули эту цепь. Поэтому это все работает.
[42:58.440 --> 43:10.680]  Понятно? Критерий полуэйлеровости понятен. Для ориентированных графов степень полузахода и
[43:10.680 --> 43:19.360]  полувыхода они одинаковы. Для полуэйлеровости аналогично с тем, что было в эйлеровости. Здесь
[43:19.360 --> 43:33.120]  вообще нет никакой разницы. Все очень просто. Это понятно? Все достаточно легко. Что здесь важно?
[43:33.120 --> 43:39.840]  Как искать вот эту эйлеровость? То есть мы захотим построить эйлеров цикл. Но для начала нужно
[43:39.840 --> 43:46.600]  проверить, что он подходит к необходимой нам со степенями вершины. Потому что без степени вершины
[43:46.600 --> 43:52.480]  у вас будет проблема. То есть мы должны сначала проверить, что у нас действительно степень вершины
[43:52.480 --> 44:01.560]  всех четная, если мы хотим проверить эйлеров цикл. Вот это первое. Дальше мы делаем рекурсивный
[44:01.560 --> 44:10.040]  ДФС. То есть запускаем ДФС, потом еще ДФС, ДФС, ДФС. А что мы будем с вами делать? Мы будем делать
[44:10.040 --> 44:17.960]  с вами следующее. Что мы будем помечать не вершины, а ребра. Мы раньше с вами ребра помечали,
[44:17.960 --> 44:23.040]  теперь мы будем, о господи, вершины помечали в серые цвета и так далее. А здесь мы будем помечать
[44:23.040 --> 44:30.360]  ребра. Если мы прошли по ребру, то его выкидываем. Просто само по себе. И под завершение обработки
[44:30.760 --> 44:37.800]  всего этого мы добавляем ее в начало массива пути. Как бы все это хорошо, все это нормально, выглядит вот
[44:37.800 --> 44:47.720]  так. Это не сложно. Это все, что нужно для проверки эйлеровой. Ну кроме того условия, что у вас степень вершины
[44:47.720 --> 44:54.720]  корректна. И это поможет вам найти необходимые вам вершины. То есть это фактически тот же самый ДФС.
[44:54.720 --> 45:03.680]  Просто вы не делаете ничего с точки зрения цвета. Вы добавляете здесь то, что вы выкидываете какие-то
[45:03.680 --> 45:13.440]  ребра и запускаете ДФС заново. Рекурсивно просто идете с этим ДФСом. После этого у вас будет эйлеров
[45:13.440 --> 45:25.520]  цикл. Да. Радить. Хороший вопрос. Это связано с тем, чтобы мы ребро правильно посчитали. То есть откуда мы
[45:25.520 --> 45:32.760]  пришли в данную вершину. Иначе мы ребра не сможем считать. То есть у нас эйлеров цикл, он из чего
[45:32.760 --> 45:40.880]  состоит? Он состоит из ребра. Ребра откуда, куда пришли. Вот. Вот видишь там push front написано и PV
[45:41.560 --> 45:57.160]  вот это и есть ребро. Понятно? Вопросы есть? Нет. Вот так можно найти эйлеров цикл сам по себе. Почему это
[45:57.160 --> 46:04.760]  корректно? Ну смотрите. Каждое ребро в массиве эйлеров цикл содержится один раз. Ну почему? Потому
[46:04.760 --> 46:14.800]  что у нас алгоритм так выглядит, что мы выкидываем из V в U вершину. Из V в U ребро. Отлично. А в момент
[46:14.800 --> 46:23.160]  выписывания ребра все степени вершин чётные. То есть вот я его когда записываю оно должно быть чётным. Почему?
[46:23.160 --> 46:36.600]  Ставим следующую картинку. Вот у меня есть вершинка S. Вот я от неё хожу. Что-то там делаю. И вот я
[46:36.600 --> 46:43.800]  могу здесь остановиться? Почему? Почему мой DFS здесь не может остановиться?
[46:43.800 --> 46:57.200]  Вдруг? Нет. Есть.
[46:57.200 --> 47:17.240]  Хорошо. Это мне нравится больше. Да, в действительности это так. Окей, это правда. То есть просто остановиться
[47:17.240 --> 47:31.680]  здесь не могу. А зайти в другую вершину я мог? Вот так. Да. То есть у нас должно быть продолжение и
[47:31.680 --> 47:38.000]  останавливаться весь у нас DFS только в случае S. Потому что у нас здесь когда мы вышли у нас степень
[47:38.000 --> 47:43.080]  вершины была грубо говоря не чётная. Мы должны ещё до туда дойти, чтобы она была тоже чётная.
[47:43.080 --> 47:49.440]  Значит у нас ничего работать здесь не будет. Поэтому в любой момент времени у нас в серебрах даже
[47:49.440 --> 47:54.280]  когда мы их выписываем у нас всё должно быть чётным. Здесь вот написано более формально по
[47:54.280 --> 47:59.720]  поводу того как это должно выглядеть, что здесь происходит, как мы это добавляем. То есть вот эти
[47:59.720 --> 48:07.760]  вот серебры и так далее. Но суть опять же плюс-минус в том же, что у нас есть чётная степень и мы от них
[48:07.760 --> 48:18.440]  отталкиваемся. Окей. Мы считаем критерии что да выполнены, поэтому мы ищем путь уже да.
[48:18.440 --> 48:35.880]  Точнее не путь, а цикл. Вот чудненько мы говорим, что последовательность выписанных вершин образует
[48:35.880 --> 48:54.760]  наш путь. Почему это правда? Сейчас ещё раз мы идём. Мы делаем от родителей к ребёнку. И чего?
[48:54.760 --> 49:11.680]  Ну грубо говоря представим следующее. Вот мы выписываем ребра. X, Y, A, B, Z, T. Почему Y это A, Z это B?
[49:11.680 --> 49:23.440]  Вернуть алгоритм?
[49:23.440 --> 49:45.640]  Зваем рекурсию. То есть мы фактически идём по вот этому вот всему, вот этой вот всей части.
[49:45.640 --> 49:59.560]  В какой момент мы вернёмся в вершину S? Хорошо, давайте так. Когда цикл найдёмся и здесь какая-то
[49:59.560 --> 50:09.000]  вершина будет там. И добавим это всё. Теперь у PATS мы как могли тут ходить? Мы могли ходить вот
[50:09.000 --> 50:18.880]  как-то вот так ещё. Согласны? Обязательно тоже бы в неё вернулись. И там должны были прийти ещё в PATS.
[50:18.880 --> 50:29.880]  Мы там тоже ходили. И так далее. То есть если смотреть глобально, ну грубо говоря, мы когда из
[50:29.880 --> 50:36.520]  любой вершины выходим, мы её прихватываем всегда с собой. Вот. И она формирует именно таким вот
[50:36.520 --> 50:45.960]  способом путь. Вот. Что здесь подразумевается? То есть смотрите, мы выписали какое-то ребро УВ,
[50:45.960 --> 50:52.600]  и в этот момент в степени вершины всех чётные. Мы с вами говорили об этом. И алгоритм продолжает
[50:52.600 --> 50:59.880]  делать обход вершине У. То есть УВ мы с вами выписали. Вот У, он продолжает делать обход вот этой
[50:59.880 --> 51:05.240]  вершинки PS, грубо говоря. И в следующий момент он должен всё равно вернуться в неё, иначе у него
[51:05.240 --> 51:11.560]  ничего не получится. Поэтому он её выпишет в следующий. И так далее. И в зависимости от этого,
[51:11.560 --> 51:18.600]  то есть будет формироваться вот такая вот путь сам по себе, которая обойдёт абсолютно все наши
[51:18.600 --> 51:26.000]  ребра. Ну и как бы все эти утверждения складываются в одно большое и говорят, что наш алгоритм по
[51:26.000 --> 51:38.360]  строению левоцикла правильный. Вот. Мы образовали некоторый путь. У нас всё чудесно. У нас каждое
[51:38.360 --> 51:50.240]  ребро содержится один раз. И фактически мы с вами доказали вот этот вот критерий. То есть мы
[51:50.240 --> 51:58.280]  отталкивали с того, что степень вершин у нас В, компонент среднесвязанности 1 с ребрами. И мы
[51:58.280 --> 52:10.400]  показали, что есть путь, фактически есть цикл. Значит у нас всё хорошо. Понятно? Ну и последнее,
[52:10.400 --> 52:19.720]  опять чуть раньше закончилось. Что ж такое? Это вообще беда. Грустная история. И последнее,
[52:19.720 --> 52:26.760]  о чём бы я хотел с вами вам сказать. Кроме эйлеровости, что существует? Да, существует
[52:26.760 --> 52:34.640]  гамильтонов граф, гамильтонов путь. Это всё. Кажется, задача очень похожа сама по себе.
[52:34.640 --> 52:50.780]  Есть у меня некоторые нюансы. Вот. Кто-нибудь знает, какой? Да, это правда. А ещё? По сути
[52:50.780 --> 52:55.920]  своей это правда. На самом деле задача о гамильтоновом пути, о гамильтоновом графе является ли
[52:55.920 --> 53:02.040]  граф гамильтоновым? Это НП полная задача. НП полная задача означает, что она не решается
[53:02.040 --> 53:10.800]  за полином. Всё правильно. Вот. А у неё нет какого-то эффективного алгоритма, считается само по себе,
[53:10.800 --> 53:18.200]  поэтому это очень такая хитрая задача. И самое интересное про НП полные задачи, но я думаю,
[53:18.200 --> 53:24.680]  где-нибудь вам это отдельно расскажут. НП полные задачи, они образуют такое семейство. Если вы
[53:24.680 --> 53:31.000]  решите хотя бы одну НП полную задачу, то после этого вы решите все остальные. Вот. Вдруг у вас
[53:31.000 --> 53:43.720]  получится. А вы сделайте сначала, а дальше посмотрим. Вот. Посмотрим, что это будет. В
[53:43.720 --> 53:47.800]  действительности задача на поиск гамильтонового пути это проблема. Конечно же у вас будут
[53:47.800 --> 54:01.480]  определённые условия на это всё. Шаг не подходит. Ой, с точностью это вероятностный алгоритм,
[54:01.480 --> 54:07.320]  да, не существует, но не очень тут подходит тоже. Ты должен просто перебрать абсолютно всё возможное.
[54:07.320 --> 54:17.320]  Вот. И в этом случае что-то заработает. Или не заработает, там же пойдёт. Поэтому, кажется,
[54:17.320 --> 54:24.120]  задача похожая, задача одинаковая, а фактически одна решаемая, а другая не очень. Как есть.
[54:24.120 --> 54:30.120]  А, в принципе, на сегодня всё. Если нет вопросов, вот. Хорошего вам вечера.
