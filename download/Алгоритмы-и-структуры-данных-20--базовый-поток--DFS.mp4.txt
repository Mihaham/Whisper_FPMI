[00:00.000 --> 00:11.560]  Всё, отлично, окей, что же, давайте сегодня будем
[00:11.560 --> 00:14.640]  с вами продолжать все те темы, которые у нас были,
[00:14.640 --> 00:18.540]  мы продолжаем с вами графы, я это напомню, и сегодня
[00:18.540 --> 00:23.360]  мы с вами будем говорить про обход графа в глубину.
[00:23.360 --> 00:26.640]  На прошлой лекции мы с вами говорили про обход графа
[00:26.640 --> 00:29.960]  в ширину, сейчас мы будем говорить обход графа в
[00:29.960 --> 00:33.800]  глубину, зачем это нужно, как вообще с этим можно
[00:33.800 --> 00:38.960]  что-то делать, и в зависимости от этого мы будем уже что-то
[00:38.960 --> 00:42.920]  использовать как-то, использовать те алгоритмы на графах,
[00:42.920 --> 00:50.080]  которые у нас есть, ой-ой, ой-ой, почему он это делает,
[00:50.080 --> 00:53.280]  интересно, ну ладно.
[00:53.280 --> 00:58.240]  Что такое обход графа, в принципе, чисто так напомню,
[00:58.240 --> 01:01.040]  что задача любого обхода графа, будь то в ширину
[01:01.040 --> 01:04.240]  или в глубину, которая есть сейчас, заключается в обходе
[01:04.240 --> 01:08.520]  всех вершин и ребер в некотором порядке с учетом структуры
[01:08.520 --> 01:10.960]  графа, с учетом структуры, которая занимается что-то
[01:10.960 --> 01:14.880]  связанными, что-то несвязанными, как-то с этим нужно считаться.
[01:14.880 --> 01:21.320]  Идея обхода графа в глубину, то есть DFS, она примерно
[01:21.320 --> 01:24.280]  следующая, что берем стартовую вершину S и будем двигаться
[01:24.280 --> 01:26.480]  в глубину в произвольном направлении, до тех пор
[01:26.480 --> 01:29.920]  пока можем, если не можем, вернемся и откатимся на
[01:29.920 --> 01:33.880]  шаг назад и пойдем в какую-нибудь другую сторону, то есть мы
[01:33.880 --> 01:37.960]  не будем волнами ходить, как это было в BFS, мы будем
[01:37.960 --> 01:41.040]  конкретно по одному пути идти, пока можем, как только
[01:41.040 --> 01:45.960]  не можем, вернемся обратно, в этом пока что сама суть
[01:45.960 --> 01:48.840]  DFS.
[01:48.840 --> 01:53.080]  Какие две причины могут помешать тому, чтобы DFS продолжился?
[01:53.560 --> 01:56.640]  Первое, из очередной какой-то вершины нет ребер, какие-то
[01:56.640 --> 02:02.480]  новые вершины, и это будет означать, что у нас просто
[02:02.480 --> 02:05.720]  нет ребер, то есть вершина сама по себе тупиковая, то
[02:05.720 --> 02:09.320]  есть мы пришли в какую-то вершину и из нее нет ничего.
[02:09.320 --> 02:13.600]  И второе, это когда все ребра ведут уже в просмотренные
[02:13.600 --> 02:15.920]  вершины, то есть у меня был какой-нибудь вот такой
[02:16.520 --> 02:23.240]  граф, давайте я сейчас придумаю, как тут же сделать, вот
[02:23.240 --> 02:26.200]  например, вот так и вот так, и предположим, что я уже
[02:26.200 --> 02:31.240]  посетил вот эту вершину, вот эту вершину, а теперь
[02:31.240 --> 02:34.000]  я прихожу вот в эту вершину, из нее все посещены.
[02:34.000 --> 02:37.840]  То есть две вот такие вот причины, которые могут
[02:37.840 --> 02:42.120]  означать, что у нас граф сейчас, мы уже не можем
[02:42.120 --> 02:45.880]  дальше двигаться, то есть вот это вот те причины, по
[02:45.880 --> 02:48.600]  которым мы не можем с вами что-то продолжать.
[02:48.600 --> 02:50.200]  Как выглядит алгоритм DFS?
[02:50.200 --> 02:51.720]  Ну, он достаточно прост.
[02:51.720 --> 02:55.600]  Берем какую-то вершину, проходим из нее по ребру
[02:55.600 --> 02:59.160]  в произвольном направлении, если мы еще не посещали
[02:59.160 --> 03:04.240]  какую-то конкретно вершину, если у нас из очередной
[03:04.240 --> 03:07.720]  вершины некуда идти, то возвращаемся к предыдущему
[03:07.720 --> 03:12.840]  шагу и продолжаем обход по какому-то новому пути,
[03:12.840 --> 03:13.840]  который нам необходим.
[03:13.840 --> 03:17.480]  И если по итогу мы возвращаемся в стартовую вершину и из
[03:17.480 --> 03:22.480]  нее идти некуда, тогда в этом случае мы просто заканчиваем
[03:22.480 --> 03:23.480]  наш DFS.
[03:23.480 --> 03:27.040]  А как мы можем это все делать?
[03:27.040 --> 03:30.520]  Здесь нам в действительности понадобятся различные
[03:30.520 --> 03:35.560]  вещи, связанные с цветами, и еще мы ведем такое понятие,
[03:35.560 --> 03:37.120]  как таймин и таймамп.
[03:37.120 --> 03:43.480]  Для того, чтобы осуществлять вот этот просмотр вершины
[03:43.480 --> 03:47.160]  посещена или не посещена, мы ведем цвета.
[03:47.160 --> 03:50.680]  Это белый, серый, черный.
[03:50.680 --> 03:54.360]  Белый будет означать, что у нас вершина данная не
[03:54.360 --> 03:56.040]  была посещена.
[03:56.040 --> 04:00.160]  Серый будет означать, что из вершины осуществляется
[04:00.160 --> 04:02.600]  обход в глубину, но он еще не закончен, то есть мы
[04:02.600 --> 04:05.200]  можем вернуться к этой вершине и пойти по какому-то
[04:05.200 --> 04:09.800]  другому пути, например, а черный означает, что вершина
[04:09.800 --> 04:13.080]  была обнаружена, то есть мы уже все через нее прошли
[04:13.080 --> 04:16.000]  и никаких доступных путей нет, и теперь эта черная
[04:16.000 --> 04:18.600]  вершина просто существует, то есть ничего мы сделать
[04:18.600 --> 04:20.600]  с этим не можем.
[04:20.600 --> 04:23.120]  Кроме того, мы ведем таймин и таймаут.
[04:23.120 --> 04:25.480]  Таймин – это момент первого обнаружения вершины, то
[04:25.480 --> 04:27.920]  есть когда мы первый раз в нее зашли и из белого
[04:27.920 --> 04:28.920]  покрасили в серый.
[04:28.920 --> 04:34.400]  Таймаут – когда мы оттуда вышли, то есть когда мы вышли
[04:34.400 --> 04:38.560]  из той или иной вершинки.
[04:38.560 --> 04:40.800]  Давайте подумаем, как это сделать.
[04:40.800 --> 04:44.800]  Поэтому легче всего сделать весь наш ДФС в виде рекурсии,
[04:44.800 --> 04:47.680]  потому что с помощью рекурсии мы обратно сможем откатываться
[04:47.680 --> 04:53.040]  к предыдущим вершинкам и возвращаться куда-то.
[04:53.040 --> 04:54.040]  Какова суть?
[04:54.040 --> 04:58.280]  Ну смотрите, у нас будет какой-то массив color, массив
[04:58.280 --> 05:02.200]  таймин, массив таймаут и время на данный момент.
[05:02.200 --> 05:03.200]  Вначале нулевое.
[05:03.200 --> 05:07.400]  И дальше мы с вами просто делаем ДФС визит.
[05:07.400 --> 05:09.280]  Что это означает?
[05:09.280 --> 05:11.960]  Смотрите, как только я прихожу в какую-то новую
[05:11.960 --> 05:15.120]  вершину, вот в эту вершину, например, где я галочку
[05:15.120 --> 05:16.120]  сейчас поставил.
[05:16.120 --> 05:17.120]  Что я должен сделать?
[05:17.120 --> 05:20.320]  Я должен вначале сказать, что я начал с нее делать
[05:20.320 --> 05:28.040]  обход в глубину, поэтому я из белого крашу ее в серый.
[05:28.040 --> 05:31.160]  Потом я говорю, что время входа в данную вершину равно
[05:31.160 --> 05:32.160]  плюс плюс тайм.
[05:32.160 --> 05:34.440]  То есть время, которое сейчас, и сделать плюс один для
[05:34.440 --> 05:37.400]  того, чтобы к следующей вершине уже подготовиться.
[05:37.400 --> 05:41.640]  После этого я должен посмотреть всех ее соседей и у каждого
[05:41.640 --> 05:44.800]  из соседей запустить рекурсивно ДФС.
[05:44.800 --> 05:47.240]  Почему я у каждого должен рекурсивно запустить?
[05:47.240 --> 05:49.800]  Ну потому что у одного с помощью этого ДФС я пройдусь
[05:49.800 --> 05:53.920]  тут, у другого так, у третьего, ну не знаю, может он так-так
[05:53.920 --> 05:54.920]  связан.
[05:54.920 --> 05:55.920]  Вот.
[05:55.920 --> 06:00.200]  Я опять же буду с помощью этого посещать абсолютно
[06:00.200 --> 06:01.200]  все вершины.
[06:01.200 --> 06:05.280]  После этого, когда я закончил посещать все вершины из
[06:05.360 --> 06:08.480]  моих соседей, то есть вот эти все вершинки, которые
[06:08.480 --> 06:12.360]  сейчас обвел, я могу сказать, что, ага, все обнаружено,
[06:12.360 --> 06:16.600]  все сделано, я не могу больше найти никакого пути, поэтому
[06:16.600 --> 06:20.360]  покрашу данную вершину уже прям в черный.
[06:20.360 --> 06:23.800]  Вот делаю черный, ну и тайм-аут я тоже делаю в плюс плюс
[06:23.800 --> 06:24.800]  тайм.
[06:24.800 --> 06:31.040]  Понятно ли вам сутьевая часть обхода графа в глубину?
[06:31.040 --> 06:33.040]  Можете написать в чатик плюсик и минусик.
[06:33.040 --> 06:41.600]  Плюсик, плюсик, вижу.
[06:41.600 --> 06:45.200]  А для чего нам вообще серый цвет тут нужен?
[06:45.200 --> 06:48.760]  А для чего нам нужен будет серый цвет?
[06:48.760 --> 06:51.640]  Серый цвет нам понадобится чуть подальше, он будет
[06:51.640 --> 06:53.120]  необходим для циклов.
[06:53.120 --> 06:54.120]  Вот.
[06:54.120 --> 06:55.120]  Хорошо.
[06:55.120 --> 07:00.160]  Можно, в общем виде можно сделать так, что да, первоначально
[07:00.160 --> 07:08.120]  можно красить в белый и в черный.
[07:08.120 --> 07:09.120]  Окей.
[07:09.120 --> 07:11.560]  Вижу только плюсики, ни одного минуса не вижу, хотя
[07:11.560 --> 07:14.280]  плюсов всего четыре.
[07:14.280 --> 07:16.280]  Если какие-то у вас вопросы, давайте так.
[07:16.280 --> 07:19.280]  Нету вопросов.
[07:19.280 --> 07:24.680]  Хорошо, тогда у меня вопрос к вам, какое время работы?
[07:24.680 --> 07:27.440]  Вот у нас есть В и Ж.
[07:27.440 --> 07:31.480]  Пишите, пожалуйста, в чат ваше предположение времени
[07:31.480 --> 07:32.480]  работы.
[07:32.480 --> 07:37.320]  Ой, В и Е, прошу прощения, Ж.
[07:37.320 --> 07:55.000]  Какое время работы у этого ДФСа будет?
[07:55.000 --> 08:07.200]  В плюс Е.
[08:07.200 --> 08:08.520]  Илья нам так говорит.
[08:08.520 --> 08:14.440]  Почему В плюс Е, Илья?
[08:14.440 --> 08:15.680]  Можно голосом ответить.
[08:15.680 --> 08:18.120]  Или не хочется.
[08:18.120 --> 08:24.160]  Возможно, не хочется.
[08:24.160 --> 08:27.960]  Ладно, в действительности да, В плюс Е, но это только
[08:27.960 --> 08:30.520]  в случае, если мы используем списки смежности.
[08:30.520 --> 08:31.520]  Что нам нужно сделать?
[08:31.520 --> 08:34.480]  Нам для каждой вершины нужно пройтись по соседам.
[08:35.320 --> 08:41.720]  Если я хожу по всем соседям моей вершинки, то я просматриваю
[08:41.720 --> 08:43.280]  всю строчку, которая у меня есть.
[08:43.280 --> 08:46.400]  Всего строчек В, и в каждой строчке будет суммарно
[08:46.400 --> 08:49.840]  всего Е таких переходов, потому что у меня есть Е
[08:49.840 --> 08:50.840]  соседей.
[08:50.840 --> 08:53.240]  Каждая вершина обходится один раз, но в действительности
[08:53.240 --> 08:55.640]  мы сначала в неё входим, потом выходим, но по сути
[08:55.640 --> 08:56.640]  своя да.
[08:56.640 --> 09:01.320]  Но если мы говорим про матрицы смежности, то в этом
[09:01.320 --> 09:03.640]  случае будет В квадрат, потому что вы должны пройтись
[09:03.640 --> 09:06.360]  по всем вершинам, абсолютно для каждой вершины понять,
[09:06.360 --> 09:09.080]  кто является её соседом.
[09:09.080 --> 09:12.320]  Вот и всё.
[09:12.320 --> 09:13.320]  Как-то так.
[09:13.320 --> 09:18.320]  Теперь, в общем-то, можно придать какой-то конкретный
[09:18.320 --> 09:21.200]  смысл цветам в DFS, которые нам необходимы.
[09:21.200 --> 09:25.880]  Белая вершина будет означать, что из неё, из данной вершины
[09:25.880 --> 09:31.000]  белой, не был запущен ещё ни один DFS-визит.
[09:31.000 --> 09:34.520]  Серая вершина означает, что вызов DFS-визит был,
[09:34.520 --> 09:35.880]  но он ещё не завершился.
[09:35.880 --> 09:38.120]  Чёрная означает, что он завершился.
[09:38.120 --> 09:43.640]  А серые вершины сами по себе всегда образуют путь.
[09:43.640 --> 09:46.360]  Это вот такое вот интересное наблюдение, то есть если
[09:46.360 --> 09:48.880]  вы возьмёте серые вершины друг за дружкой, они получат
[09:48.880 --> 09:50.440]  вам путь в вашем графе.
[09:50.440 --> 09:51.440]  Почему так?
[09:51.440 --> 09:54.240]  Ну потому что это действительно путь, который сейчас на данный
[09:54.240 --> 09:55.240]  момент проложен.
[09:55.240 --> 09:56.240]  Вот.
[09:56.240 --> 09:57.840]  И от этого мы исходим.
[09:58.680 --> 10:01.800]  А в действительности, если нам необходимо будет
[10:01.800 --> 10:04.560]  посетить абсолютно все вершины, а не только лишь
[10:04.560 --> 10:08.400]  достижимые из данной, которые вот мы сделаем, то дополнительно
[10:08.400 --> 10:10.880]  пишется просто цикл, что мы проходимся абсолютно
[10:10.880 --> 10:11.880]  по всем вершинам.
[10:11.880 --> 10:15.120]  В каждой вершине запускаем DFS-визит в случае, если у
[10:15.120 --> 10:16.920]  меня цвет белый.
[10:16.920 --> 10:17.920]  Ну грубо говоря.
[10:17.920 --> 10:18.920]  Вот.
[10:18.920 --> 10:21.640]  Я иду по всем вершинам, вот у меня есть вершина
[10:21.640 --> 10:23.200]  там нулевая какая-то.
[10:23.200 --> 10:25.840]  Я прохожусь по всем вершинам, которые достигаемые из
[10:25.840 --> 10:26.840]  этой вершины.
[10:26.840 --> 10:30.160]  А вот какую-то одну я не набрал.
[10:30.160 --> 10:32.560]  Ну там, не знаю, пятую.
[10:32.560 --> 10:34.440]  Вот это все у меня покрасится в серый.
[10:34.440 --> 10:38.040]  А вот это будет еще белое.
[10:38.040 --> 10:40.800]  Для того, чтобы пройти ее до конца, мне необходимо
[10:40.800 --> 10:45.640]  всегда взять и сделать здесь DFS-визит.
[10:45.640 --> 10:49.880]  В этом случае мы пройдемся абсолютно по всему графу
[10:49.880 --> 10:51.440]  и перекрасим его.
[10:51.440 --> 10:57.000]  Что нам вообще здесь DFS позволяет?
[10:57.000 --> 10:59.920]  Ну первое, что есть, это тестительность и классификация
[10:59.920 --> 11:02.640]  ребер при обходе графа глубину.
[11:02.640 --> 11:05.800]  Это полезное знание, которое вам подскажет, как вообще
[11:05.800 --> 11:07.840]  вглубит ваш граф.
[11:07.840 --> 11:10.240]  Мы будем использовать эти факты в дальнейшем, когда
[11:10.240 --> 11:14.080]  будем рассматривать, например, мосты и точки сочленения.
[11:14.080 --> 11:17.800]  Пока что вам нужно их просто привыкнуть, что мы их будем
[11:17.800 --> 11:18.800]  им называть так.
[11:18.800 --> 11:25.020]  Первое, что нужно понимать, что если у нас есть какой-то
[11:25.020 --> 11:29.600]  граф неориентированный, то деревом в этом графе мы
[11:29.600 --> 11:30.920]  называем граф без циклов.
[11:30.920 --> 11:35.680]  Деревом в ориентированном же графе называется граф
[11:35.680 --> 11:39.240]  без циклов, в котором у всех вершин полустепень
[11:39.240 --> 11:43.040]  захода равна единице, кроме одной, у которой полустепень
[11:43.040 --> 11:44.640]  захода равна нулю.
[11:44.720 --> 11:48.600]  Ну то есть, грубо говоря, дерево – это вот такое вот
[11:48.600 --> 11:54.760]  чудо, вот это дерево в ориентированном графе.
[11:54.760 --> 11:59.000]  Полузаход у всех единичка, кроме корня, к корню никто
[11:59.000 --> 12:00.000]  не заходит.
[12:00.000 --> 12:07.680]  И если вдруг вы оставите только лишь посещенные ребра,
[12:07.680 --> 12:10.680]  то есть только те, по которым мы ходили, и ориентируем
[12:10.680 --> 12:14.560]  их в том порядке, в котором нам необходимо, то DFS-визит
[12:14.560 --> 12:16.920]  образует дерево обхода.
[12:16.920 --> 12:21.520]  Если вдруг вам будет несколько DFS-визитов, то в этом случае
[12:21.520 --> 12:24.800]  у вас будет не дерево обхода, а уже лес обхода.
[12:24.800 --> 12:26.920]  Но мы будем рассматривать одно конкретное дерево
[12:26.920 --> 12:29.200]  и по нему говорить о каких-то вещах.
[12:29.200 --> 12:37.360]  И что вообще там происходит у нас само по себе.
[12:37.360 --> 12:38.360]  Как-то так.
[12:38.360 --> 12:42.080]  Какие существуют ребра, классификация некоторых
[12:42.080 --> 12:43.080]  ребер.
[12:43.080 --> 12:48.440]  Рёбра бывают ребрами деревьев, обратными ребрами, прямыми
[12:48.440 --> 12:50.800]  ребрами и перекрёстными ребрами.
[12:50.800 --> 12:53.400]  Что означает каждый из них?
[12:53.400 --> 12:57.560]  Первое, ребро дерева – это ребро, которое принадлежит
[12:57.560 --> 13:00.400]  к какому-то обходу дерева.
[13:00.400 --> 13:03.800]  То есть если мы запустили DFS, прошлись по нему, то у
[13:03.800 --> 13:06.760]  нас получается ребро дерева.
[13:06.760 --> 13:10.600]  Обратное ребро – это ребро, ведущее из потомка в предка
[13:10.600 --> 13:14.560]  в некотором дереве обхода, которое у вас есть.
[13:14.560 --> 13:19.360]  Прямое же ребро – это ребро, ведущее из предка в потомка,
[13:19.360 --> 13:21.960]  не являющийся его сыном.
[13:21.960 --> 13:27.600]  Ну и перекрёстное ребро – это когда соединяются любые
[13:27.600 --> 13:30.200]  вершины, которые вообще никак не связаны с понятием
[13:30.200 --> 13:32.000]  предок и потом.
[13:32.000 --> 13:33.800]  Представим следующую картину.
[13:33.800 --> 13:40.920]  Вот я делаю здесь, ну давайте, я хожу по вершинкам, красненьким
[13:40.920 --> 13:41.920]  буду выделять.
[13:41.920 --> 13:45.000]  Вот у меня есть нулевая вершина, от неё я пошёл потом
[13:45.000 --> 13:50.640]  во вторую, потом я пошёл в первую, третью и четвёртую
[13:50.640 --> 13:51.640]  вершины.
[13:51.640 --> 13:55.360]  То есть я вначале сходил по вот этому, потом сюда,
[13:55.360 --> 13:57.480]  потом сюда, потом сюда.
[13:57.480 --> 14:00.680]  Скажите мне, то, что я выделил сейчас красным, чем является?
[14:00.680 --> 14:01.680]  Каким ребром?
[14:01.680 --> 14:02.680]  Ребро дерева.
[14:02.680 --> 14:03.680]  А?
[14:03.680 --> 14:04.680]  Ребро дерева.
[14:04.680 --> 14:05.680]  Ребро дерева.
[14:05.680 --> 14:09.680]  То есть это то, как я ходил с вами в ДФС.
[14:09.680 --> 14:14.680]  Теперь, ой, сейчас, было красно, встало не красно, нужно
[14:14.680 --> 14:15.680]  как-нибудь готово.
[14:15.680 --> 14:20.680]  Хорошо, давайте теперь выделим зелёное.
[14:20.680 --> 14:23.680]  Вот это обратное из 3 в 0.
[14:23.680 --> 14:26.680]  Это какое ребро?
[14:26.680 --> 14:28.680]  Вы сами сказали.
[14:28.680 --> 14:29.680]  Какое?
[14:29.680 --> 14:30.680]  Обратное.
[14:30.680 --> 14:31.680]  Понял, хорошо.
[14:31.680 --> 14:34.680]  Да, это действительно обратное ребро.
[14:34.680 --> 14:37.680]  Окей, давайте следующий вопрос.
[14:37.680 --> 14:40.680]  Предположим, вот это 4,2.
[14:40.680 --> 14:45.680]  Это какое ребро?
[14:45.680 --> 14:50.680]  Из 4,2.
[14:50.680 --> 14:53.680]  Прямое?
[14:53.680 --> 14:56.680]  Прямое ребро.
[14:56.680 --> 15:06.680]  Прямое... Ещё кто? Какое сказал? Перекрёстное. Перекрёстное. Ещё... Или всё.
[15:11.680 --> 15:16.680]  А что мы вообще называем в данном контексте тогда предками и потомками?
[15:17.680 --> 15:24.680]  Хороший вопрос. Вот давайте тогда с этим разбираться. Не зря здесь просто так этот пример.
[15:24.680 --> 15:34.680]  Давайте смотреть. Вот это корень. 0 это корень. У корня есть потомок 1, потомок 1.
[15:35.680 --> 15:40.680]  Ну, первого поколения, грубо говоря. У потомка первого поколения есть потомок 2, потомок 2.
[15:44.680 --> 15:46.680]  Вот. Который относится к единичке.
[15:46.680 --> 15:56.680]  Вот. А является ли 4 потомком или предком двойки?
[15:59.680 --> 16:04.680]  Нет. Нет. Потому что заход один только.
[16:05.680 --> 16:13.680]  Да, то есть смотрите, оно не входит в это понимание. Для 4 является предком 1, а для 1 является предком 0.
[16:13.680 --> 16:17.680]  Вот. А у двойки не является 4 потомком.
[16:18.680 --> 16:20.680]  Поэтому здесь это действительно перекрёстное ребро.
[16:21.680 --> 16:27.680]  Потому что у нас нет никакого отношения предок потомок. Мы никак с этим не работаем.
[16:28.680 --> 16:32.680]  Окей. Ну и последнее ребро, которое у нас здесь осталось.
[16:33.680 --> 16:38.680]  Ну давайте каким цветом-то выделить это всё. Давайте пусть будет синеньким.
[16:38.680 --> 16:41.680]  Вот это вот 0,4. Это какое ребро?
[16:46.680 --> 16:48.680]  А, друзья.
[16:51.680 --> 16:57.680]  Давайте я вас верю. 0,4 это прямое.
[16:58.680 --> 17:04.680]  Прямое ребро. Потому что у нас есть предок, есть потомок. Просто они не связаны с пониманием сына.
[17:05.680 --> 17:10.680]  Да. А у меня тут немножко цвета отличаются, но суть всё равно остаётся такая же.
[17:11.680 --> 17:15.680]  Давайте я где-нибудь здесь на всякий случай нарисую, что прямое вот это синенькое.
[17:16.680 --> 17:22.680]  Дальше у меня здесь красненькое. Это у меня ребро такое.
[17:24.680 --> 17:27.680]  А что у меня тут зелёное? Это обратное.
[17:27.680 --> 17:34.680]  Это обратное. Ну и последнее это у нас фиолетовое.
[17:37.680 --> 17:39.680]  Вот. Как-то так.
[17:40.680 --> 17:43.680]  Такая вот классификация ребер.
[17:48.680 --> 17:50.680]  Это классификация ребра.
[17:51.680 --> 17:54.680]  Как определить вообще тип ребра во время ДФС? Как вы думаете?
[17:58.680 --> 18:02.680]  Вот с помощью всего того, что мы с вами говорили, а что у нас есть?
[18:03.680 --> 18:06.680]  Свет и у нас есть время входа, время выхода.
[18:07.680 --> 18:11.680]  Как нам определить, что это вообще такое?
[18:14.680 --> 18:21.680]  Если оба серые, то можно понять это либо обратное, либо прямое, либо ребро дерево там, по времени.
[18:22.680 --> 18:28.680]  Если о серых, то по времени понять. Как это понять?
[18:29.680 --> 18:35.680]  Ну если у одного, если ребро идёт из меньшего времени в большее время, то это...
[18:36.680 --> 18:44.680]  И разница больше единицы, то это прямое. Если равна единице, то это ребро дерева. Если меньше нуля, то это обратное.
[18:45.680 --> 18:51.680]  Ну, почти, но окей. Да, в действительности, похоже на правду, есть просто некоторые нюансы.
[18:52.680 --> 18:59.680]  В действительности ребро дерева это всегда какое ребро? А в какую вершину всё это будет вести? Цвета.
[19:03.680 --> 19:11.680]  Ну то есть я нахожусь в какой-то вершинке серый, и вот я иду в новую вершину. В какого цвета эта вершина?
[19:14.680 --> 19:16.680]  Белая.
[19:18.680 --> 19:24.680]  Может ли хоть одно ребро вести тоже в белую вершину?
[19:26.680 --> 19:34.680]  Вроде бы нет, потому что обратные ребра, прямые ребра и перекрёстные ребра, они уже связаны между собой, и там они уже были посещены.
[19:35.680 --> 19:40.680]  Поэтому ребро дерева это в белую вершину.
[19:44.680 --> 19:49.680]  Что такое обратное ребро? В какую вершину смотрим мы здесь?
[19:52.680 --> 19:54.680]  В серую.
[19:55.680 --> 19:58.680]  В серую. Можем ли мы смотреть в чёрную?
[20:01.680 --> 20:02.680]  Нет.
[20:03.680 --> 20:04.680]  Нет. Почему?
[20:05.680 --> 20:06.680]  Потому что обход не завершился.
[20:06.680 --> 20:13.680]  Потому что обход в действительности не завершился. То есть мы смотрим на какого-то нашего предка.
[20:14.680 --> 20:22.680]  И осталось прямое и перекрёстное ребро. Вот прямое и перекрёстное ребро, каждый из них смотрит в чёрную вершину и в чёрную вершину.
[20:23.680 --> 20:26.680]  И вот здесь нам на помощь приходит время тайм-ин и тайм-аут.
[20:27.680 --> 20:30.680]  Чем отличается прямое ребро и перекрёстное ребро?
[20:31.680 --> 20:36.680]  В прямом ребре как связано? Ну пусть у меня ребро ВУ.
[20:37.680 --> 20:41.680]  Оно должно быть прямым, например.
[20:42.680 --> 20:54.680]  Как связано тайм-ин В и тайм-ин У?
[20:55.680 --> 20:57.680]  Вот как это связано между собой?
[21:00.680 --> 21:12.680]  Время входа в вершину В и время входа в вершину У.
[21:13.680 --> 21:18.680]  Что такое прямое ребро? На всякий случай, когда у нас вот такая вот концепция есть.
[21:18.680 --> 21:28.680]  Вот это ребро.
[21:29.680 --> 21:37.680]  Вот здесь у нас получается В, вот здесь У.
[21:38.680 --> 21:43.680]  Так чего?
[21:44.680 --> 21:51.680]  Какое это ребро?
[21:52.680 --> 21:56.680]  Ну тайм-ин меньше УВ, если прямое.
[21:57.680 --> 22:03.680]  Тайм-ин меньше УВ. А у перекрёстного как это будет связано?
[22:04.680 --> 22:07.680]  Ну видимо наоборот, тайм-ин УВ больше.
[22:08.680 --> 22:10.680]  Почему?
[22:10.680 --> 22:14.680]  Иначе это прямое.
[22:15.680 --> 22:20.680]  А вдруг не по тайм-ину? Мы должны сравнивать.
[22:21.680 --> 22:27.680]  Давайте чуть более подробно. Почему так?
[22:28.680 --> 22:36.680]  В действительности дата у таймина В будет меньше, здесь у таймина В будет больше.
[22:36.680 --> 22:43.680]  Правда так, никто не спорит.
[22:44.680 --> 22:46.680]  Что же здесь происходит? Почему так?
[22:47.680 --> 22:55.680]  Ну смотрите, что такое прямое ребро? Прямое ребро это когда мы дошли до потомка какого-то, с которым мы будем опять же связаны.
[22:56.680 --> 23:01.680]  Значит мы не могли прийти в этого потомка раньше, чем мы находимся в родителе.
[23:01.680 --> 23:10.680]  Поэтому тайм-время входа в родителя гораздо меньше, ну не гораздо, а просто меньше, чем время входа в потомка.
[23:11.680 --> 23:22.680]  Если мы говорим с вами про перекрёстное ребро, то мы уже должны были обойти вершину У и всё, что с ней связано, и только потом прийти к вершине В.
[23:23.680 --> 23:28.680]  Поэтому естественно время входа в вершину У будет меньше.
[23:28.680 --> 23:33.680]  Вот, как-то так это выглядит. Я надеюсь, что вы это представляете.
[23:34.680 --> 23:47.680]  Естественно, классификация ребер есть ещё и в неориентированных графах, но в неориентированных графах я утверждаю, что есть только древесные и обратные ребра, других нет.
[23:51.680 --> 23:52.680]  Понятно ли это почему?
[23:52.680 --> 23:54.680]  Да, вы молчите, мне страшно.
[23:57.680 --> 24:05.680]  Ну, потому что у нас не может быть чёрной вершины, в которую мы ведём, потому что мы должны были её, как бы, из этой вершины обойти.
[24:06.680 --> 24:10.680]  Да, у нас не может быть конкретно чёрной вершинки.
[24:10.680 --> 24:18.680]  По той причине, что мы в действительности бы оказались в этой вершине, будь у нас неориентированный граф, потому что оно связано в две стороны.
[24:19.680 --> 24:20.680]  Именно так.
[24:21.680 --> 24:28.680]  Окей, теперь нужно немножко поговорить про корректность данных алгоритмов, корректность ДФСа, что вообще с ним происходит.
[24:29.680 --> 24:31.680]  Давайте докажем несколько утверждений.
[24:31.680 --> 24:38.680]  Окей, теперь нужно немножко поговорить про корректность данных алгоритмов, корректность ДФСа, что вообще с ним происходит.
[24:39.680 --> 24:40.680]  Давайте докажем несколько утверждений.
[24:41.680 --> 24:42.680]  Первое утверждение о ДФС.
[24:43.680 --> 24:49.680]  Ни в один момент времени не может быть ребра из чёрной вершины в белую.
[24:50.680 --> 24:51.680]  Почему?
[24:52.680 --> 24:56.680]  Если мы сказали, что вершина чёрная, значит мы обошли всех её соседей.
[24:57.680 --> 24:58.680]  Да.
[24:58.680 --> 25:10.680]  А если у нас, к примеру, есть такая вершина, ну, предположим, что-нибудь обратное, и у нас есть из чёрной в белую, тогда рассмотрим момент, когда вершина В стала чёрной,
[25:11.680 --> 25:15.680]  а этому предшествовал как раз таки цикл по всем соседям нашей вершины В.
[25:16.680 --> 25:22.680]  В этом цикле встречалась белая вершина У, и значит она была просто пропущена этим циклом.
[25:23.680 --> 25:26.680]  Поэтому у нас противоречие с нашим алгоритмом.
[25:26.680 --> 25:33.680]  Возможно ли все остальные варианты, то есть из серой в белую, из белой в белую и так далее?
[25:34.680 --> 25:36.680]  Вот вам нужно об этом подумать.
[25:37.680 --> 25:41.680]  Как сказать, что это можно? Привести пример на каждый из этих вариантов.
[25:42.680 --> 25:47.680]  И существует так называемая лемма о белых путях, которая звучит так.
[25:47.680 --> 25:54.680]  Вершина У будет посещена в процессе DFS-визита тогда и только тогда,
[25:55.680 --> 26:03.680]  в процессе вызова от вершины В, тогда и только тогда, когда в момент вызова DFS-визита в вершине В
[26:04.680 --> 26:09.680]  существует путь из В в У, состоящий только из белых вершин.
[26:09.680 --> 26:10.680]  Вершин.
[26:12.680 --> 26:17.680]  Согласны ли вы с данной темой? Понятно ли, что здесь сказано?
[26:21.680 --> 26:25.680]  Давайте еще раз, напишите плюсики, если понятно, что написано в теории.
[26:26.680 --> 26:29.680]  Надеюсь, вы напишете их все-таки побольше, чем четыре штучки.
[26:32.680 --> 26:34.680]  Вас тут все-таки двадцать.
[26:35.680 --> 26:41.680]  Один плюсик вижу, все остальные понимаете ли вы, что происходит?
[26:42.680 --> 26:46.680]  Два вижу, три, четыре нет.
[26:47.680 --> 26:49.680]  Илья, что именно непонятно?
[26:50.680 --> 26:52.680]  Какой момент смущает?
[26:59.680 --> 27:01.680]  Илья?
[27:04.680 --> 27:18.680]  Илья не хочет отвечать, ему просто не нравится. Окей.
[27:21.680 --> 27:25.680]  В общем-то, что у нас касается этого момента?
[27:26.680 --> 27:31.680]  В действительности здесь Лемма о белых путях говорит нам следующее.
[27:31.680 --> 27:41.680]  Говорит нам о том, что у нас есть вершина В, откуда мы запускаем, есть какая-то вершина У.
[27:42.680 --> 27:52.680]  И вот этот вот путь существует в эту вершину только в случае, если на пути к этой вершине У у нас будут встречаться только лишь белые вершинки.
[27:53.680 --> 28:00.680]  В другом случае у нас не будет никакого пути, то есть мы мало ли запускали еще где-то ДФС, там уже все было сделано.
[28:01.680 --> 28:05.680]  Данная теорема доказывается. Доказывается достаточно просто.
[28:06.680 --> 28:11.680]  Рассмотрим сначала в одну сторону. Вершина У будет посещена в процессе вызова ДФС визит.
[28:12.680 --> 28:17.680]  Тогда в момент вызова ДФС визит существует путь из В в У, состоящий из белых вершин.
[28:18.680 --> 28:29.680]  Но это логично. Если мы вызываем ДФС визит от вершины В, тогда в этом случае просто посещая чисто эти белые вершины, которые есть в пути, в которые нам говорится о том, что есть.
[28:30.680 --> 28:39.680]  Мы доберемся до вершины У, значит у нас существует путь из В в У по белым вершинам.
[28:40.680 --> 28:47.680]  Это логично. Если мы посещаем нашу вершинку, то означает, что был такой путь по белым вершинам.
[28:48.680 --> 28:50.680]  Как-то же мы пришли, значит все хорошо.
[28:50.680 --> 28:52.680]  Теперь в обратную сторону.
[28:53.680 --> 29:04.680]  Нам нужно доказать, что если у нас существует путь из В в У, состоящий из белых вершин, то вершина У будет обязательно посещена в процессе вызова ДФС визит.
[29:05.680 --> 29:08.680]  Как это доказывается? Доказывается следующим образом.
[29:09.680 --> 29:12.680]  Давайте рассмотрим какой-нибудь белый путь из В в У.
[29:12.680 --> 29:16.680]  Из В, потом до вершины В1, В2 и так далее, до У.
[29:17.680 --> 29:27.680]  В момент завершения ДФС визит, вершина В черная. То есть в момент, когда мы завершаем наш ДФС, она черная.
[29:28.680 --> 29:37.680]  А на рассматриваемом пути сами по себе нет серых вершин, потому что все рекурсивные вызовы завершились.
[29:37.680 --> 29:45.680]  То есть не может быть такого, чтобы у нас из черной было в серую в данный момент времени, потому что мы всю рекурсию закончили.
[29:46.680 --> 29:49.680]  Значит не одна вершина, она либо белая, либо черная.
[29:50.680 --> 29:58.680]  Вот. По утверждению один, на этом пути нет черно-белых переходов.
[29:59.680 --> 30:01.680]  Значит есть только черно-черный.
[30:02.680 --> 30:10.680]  Значит все вершины на этом пути стали черными. То есть они были посещены.
[30:11.680 --> 30:14.680]  Поэтому вершина У тоже была посещена.
[30:15.680 --> 30:19.680]  Понятен ли механизм рассуждения здесь?
[30:27.680 --> 30:30.680]  Друзья, если вы будете молчать, это будет только хуже.
[30:32.680 --> 30:34.680]  Один плюсик вижу.
[30:37.680 --> 30:38.680]  От Степана.
[30:39.680 --> 30:41.680]  Есть ли еще что-то?
[30:46.680 --> 30:47.680]  Или нет?
[30:48.680 --> 30:51.680]  Еще один вижу. Еще один вижу. Отлично.
[30:52.680 --> 30:53.680]  Хорошо.
[30:54.680 --> 30:56.680]  Окей. Поехали дальше.
[30:56.680 --> 30:58.680]  Дальше. Вот у нас DFS есть.
[30:59.680 --> 31:03.680]  Какие вообще есть применения у DFS само по себе?
[31:04.680 --> 31:05.680]  Смотрите.
[31:08.680 --> 31:12.680]  У нас существуют компоненты связности и достижимые вершины.
[31:13.680 --> 31:25.680]  Излемы вообще о белых путях следуют, что при запуске DFS Visit мы можем посетить только вершины,
[31:26.680 --> 31:30.680]  в режимы из В. То есть все вершины мы посетить прям не сможем,
[31:31.680 --> 31:36.680]  но все возможные вершины, до которых мы можем добраться, они же все являются белыми в самом начале,
[31:37.680 --> 31:40.680]  то до всех вершин мы с помощью этого DFS дойдем.
[31:41.680 --> 31:43.680]  И это чудесно.
[31:44.680 --> 31:45.680]  А как это можно сделать?
[31:46.680 --> 31:49.680]  Ну смотрите. Вы просто запускаете DFS Visit и смотрите.
[31:50.680 --> 31:52.680]  Ага, вот до этих вершин дошел, вот до этих нет.
[31:52.680 --> 31:54.680]  Что означает, что вы не дошли до вершины?
[31:55.680 --> 31:57.680]  Означает, что нет такого пути из В в У.
[31:58.680 --> 32:02.680]  И это может говорить о компонентах связности.
[32:03.680 --> 32:07.680]  Компоненты связности, вот если мы говорим будем про инертированный граф,
[32:08.680 --> 32:14.680]  то компонент связности инертированного графа это максимальный по включению связанный под граф.
[32:15.680 --> 32:18.680]  Ну то есть компонент связности это максимум того, что мы можем свяжать.
[32:19.680 --> 32:27.680]  И запуск DFS Visit в любой точке В на полностью белом графе найдет эту компоненту связности,
[32:28.680 --> 32:32.680]  который принадлежит В, именно в неориентированном графе.
[32:33.680 --> 32:38.680]  Почему? Ну потому что в этом случае мы просто посетим все вершины, доступные из нашей вершинки В.
[32:39.680 --> 32:40.680]  И все будет хорошо.
[32:41.680 --> 32:48.680]  И вот здесь можно будет проверить еще иоцикличность с помощью DFS.
[32:49.680 --> 32:59.680]  Я утверждаю, что в графе G есть цикл тогда и только тогда, когда при обходе в глубину была найдена серая вершина.
[33:00.680 --> 33:09.680]  То есть грубо говоря, вот мы зашли в наш вот этот вот восхитительный граф.
[33:15.680 --> 33:19.680]  И в какой-то момент мы встретили вот из серой вершины в серую вершину.
[33:20.680 --> 33:24.680]  И говорим, ага, это значит, что у нас есть цикл.
[33:25.680 --> 33:27.680]  И будем отталкиваться именно от этого.
[33:27.680 --> 33:28.680]  Как это доказывается?
[33:29.680 --> 33:36.680]  Ну смотрите, доказательства в левую сторону, что у нас при обходе была найдена серая вершина, значит графия из цикла достаточно простая.
[33:37.680 --> 33:41.680]  А серые вершины – это у нас индикатор обратных ребер.
[33:42.680 --> 33:47.680]  Обратное ребро ведет в предка в обходе дерева.
[33:48.680 --> 33:52.680]  То есть у нас в дереве обхода есть цикл.
[33:52.680 --> 33:59.680]  Но если у нас в дереве обхода есть цикл, то у нас и в графе тоже есть цикл.
[34:00.680 --> 34:03.680]  Прямо заметьте, дерево обхода само по себе – это цикличный граф.
[34:04.680 --> 34:09.680]  Но в том случае, когда мы добавляем все остальные ребра, он может не быть цикличным графом.
[34:10.680 --> 34:12.680]  Поэтому с серыми вершинами достаточно все просто.
[34:13.680 --> 34:18.680]  То есть грубо говоря, по белым мы прошлись в одну сторону, серые из серого означают, что есть обратное ребро.
[34:18.680 --> 34:25.680]  Значит мы по этому обратному ребру можем вернуться к нашему предку и заново пройтись по этому же пути и опять вернуться.
[34:26.680 --> 34:27.680]  Поэтому здесь цикл есть.
[34:28.680 --> 34:30.680]  Посмотрим по обратную сторону.
[34:31.680 --> 34:32.680]  У нас есть цикл.
[34:33.680 --> 34:38.680]  Нужно сказать, что при обходе графа в глубину мы найдем серую из серой вершины.
[34:39.680 --> 34:41.680]  Давайте рассмотрим какой-нибудь цикл.
[34:42.680 --> 34:45.680]  В0, В1 и так далее. Вн равный В0.
[34:45.680 --> 34:48.680]  То есть последняя вершинка – это В0. То есть мы зациклились между собой.
[34:49.680 --> 34:56.680]  Пусть без ограничения общности В0 – это первая вершина в этом цикле, которая была посещена во время обхода.
[34:57.680 --> 35:01.680]  То есть первая вершина, в которую мы вошли в данном конкретном цикле.
[35:02.680 --> 35:09.680]  Тогда по лемме о белых путях в процессе посещения В0 была посещена вершина ИВН-1.
[35:10.680 --> 35:13.680]  Но это же связанный цикл.
[35:14.680 --> 35:17.680]  Значит посетить эту вершину ВН-1 можно.
[35:18.680 --> 35:28.680]  А так как из этой вершины вело ревро в серую вершину В0, то в этом случае мы получаем наш цикл.
[35:29.680 --> 35:35.680]  То есть мы пришли из серой вершины в серую, значит у нас все плохо.
[35:35.680 --> 35:43.680]  То есть цикл есть, и с циклом мы получили, что мы получим все-таки в случае, когда мы придем из серой вершины в серую.
[35:44.680 --> 35:47.680]  Есть ли тут вопросы с проверкой на цикличность?
[35:51.680 --> 35:53.680]  Нет, да, да, нет.
[35:56.680 --> 36:01.680]  Вы чего-то сегодня очень общительные, я понял. В онлайне вы не любите общаться, видимо.
[36:02.680 --> 36:03.680]  Хорошо.
[36:03.680 --> 36:04.680]  Ладно, ой.
[36:05.680 --> 36:08.680]  Ну как это описать, всю эту проверку на цикличность?
[36:09.680 --> 36:14.680]  Ну давайте просто напишем нашу функцию hasCycleDFS.
[36:15.680 --> 36:19.680]  Ну и что мы делаем? Мы говорим, что colorV у нас равен gray в самом начале.
[36:20.680 --> 36:22.680]  Все так же они были в начале, все white и так далее.
[36:23.680 --> 36:26.680]  Но мы не делаем никаких таймынов, тайм-аутов, они здесь бесполезны.
[36:27.680 --> 36:29.680]  И как мы делаем?
[36:29.680 --> 36:30.680]  Как мы делаем?
[36:31.680 --> 36:32.680]  Мы говорим, что color и все white.
[36:33.680 --> 36:35.680]  Для всех вершин из нашего графа мы проходимся по ним.
[36:36.680 --> 36:40.680]  И если у нас цвет white, тогда в этом случае я запускаю это DFS.
[36:41.680 --> 36:46.680]  Дальше это DFS делает серую вершину, проходится по всем соседям.
[36:47.680 --> 36:48.680]  Вот все соседи, которые есть.
[36:49.680 --> 36:55.680]  Если вдруг мы встречаем серую вершину согласно той теории, которую мы только что доказали, то мы возвращаем true.
[36:56.680 --> 36:57.680]  То есть у нас есть цикл.
[36:57.680 --> 37:00.680]  Иначе, если мы находим белую вершину, то опять запускаем цикл.
[37:01.680 --> 37:02.680]  То есть это все тот же самый DFS.
[37:03.680 --> 37:07.680]  Просто вот именно чисто с белыми, серыми, черными вершинками.
[37:08.680 --> 37:13.680]  Ну и дальше мы просто идем по этому нашему циклу.
[37:14.680 --> 37:17.680]  И смотрим, что у нас там происходит.
[37:18.680 --> 37:23.680]  Дальше у нас здесь colorV равен black и return false.
[37:24.680 --> 37:29.680]  Прямо заметьте, вот в этом if-e для того, чтобы завершить все рекурсии корректно.
[37:30.680 --> 37:34.680]  У меня if-cycle DFS, тогда в этом случае true.
[37:35.680 --> 37:36.680]  То есть он по умолчанию возвращает false.
[37:37.680 --> 37:40.680]  Но если вдруг он нашел цикл, то он вернет, что он нашел цикл в предыдущий.
[37:41.680 --> 37:45.680]  И так далее ко всем предыдущим нашим рекурсивным вызовам.
[37:46.680 --> 37:47.680]  Вот.
[37:48.680 --> 37:53.680]  Какие есть задания еще, что может понадобиться?
[37:54.680 --> 37:57.680]  Может быть понадобится восстановление цикла.
[37:58.680 --> 38:00.680]  Тогда это можно сделать с помощью parent.
[38:01.680 --> 38:03.680]  То есть откуда я пришел в какую-то точку.
[38:04.680 --> 38:05.680]  А как это сделать?
[38:06.680 --> 38:07.680]  Ну смотрите, вот у нас есть этот цикл.
[38:07.680 --> 38:08.680]  Вот.
[38:09.680 --> 38:15.680]  И я, к примеру, знаю, что я пришел с нулевой, первой, второй, третьей, четвертой вершины, пятой.
[38:16.680 --> 38:35.680]  Я знаю, что для нуля у меня parent получается минус один, для единицы ноль, для двойки единицы, для тройки двойка, для четверки тройка, для пятерки четверка, четвертая вершина.
[38:35.680 --> 38:37.680]  Четвертая вершина, если что.
[38:38.680 --> 38:44.680]  Четверка, а дальше я попадаю опять, ой, опять в ту вершину, которая уже была посещена.
[38:45.680 --> 38:49.680]  Тогда давайте я раскручу данный стэк обратно, к примеру, по посещению.
[38:50.680 --> 38:56.680]  Тогда у меня получится пять, четыре, три, два, один и все.
[38:57.680 --> 39:00.680]  То есть я должен дойти до той вершины, на которую я указывал.
[39:00.680 --> 39:08.680]  Дальше я могу развернуть, могу не разворачивать этот цикл, как вам удобнее, но вообще лучше развернуть, особенно если у вас ориентированный граф.
[39:09.680 --> 39:12.680]  То есть получится цикл один, два, три, четыре, пять.
[39:13.680 --> 39:16.680]  Можно делать таким вот образом.
[39:17.680 --> 39:22.680]  Проблема цикличности еще в неориентированных графах.
[39:23.680 --> 39:26.680]  Почему в неориентированных графах здесь возникает проблема?
[39:27.680 --> 39:28.680]  Как вы думаете?
[39:28.680 --> 39:33.680]  Что вам не нравится?
[39:34.680 --> 39:36.680]  Или нравится?
[39:37.680 --> 39:41.680]  Может быть цикл из двух вершин?
[39:42.680 --> 39:44.680]  Цикл из двух вершин, да.
[39:45.680 --> 39:53.680]  То есть в неориентированном графе в действительности, когда у вас связаны вершинки между собой просто одним ребром, вы можете ходить в одну сторону, в другую сторону.
[39:54.680 --> 39:56.680]  И вот у вас появляется цикл.
[39:56.680 --> 40:03.680]  Здесь нужно чуть-чуть аккуратнее это все смотреть и не использовать какие-нибудь определенные ребра.
[40:04.680 --> 40:05.680]  Вот.
[40:06.680 --> 40:15.680]  Чтобы вот этого не происходило, то есть мы должны в действительности отдельно рассматривать случаи, когда у нас сосед родитель деревья обходу.
[40:16.680 --> 40:22.680]  В этом случае нужно удалять эти вершины, эти, грубо говоря, ребра.
[40:22.680 --> 40:25.680]  Какие есть еще проблемы?
[40:26.680 --> 40:27.680]  Здесь.
[40:28.680 --> 40:33.680]  Ну смотрите, в случае кратных ребер у нас будет беда с пунктом два.
[40:34.680 --> 40:37.680]  Потому что родитель может вести в другое ребро.
[40:38.680 --> 40:40.680]  Что нам с этим делать?
[40:41.680 --> 40:42.680]  Как вы думаете?
[40:53.680 --> 40:54.680]  Беда.
[40:55.680 --> 40:58.680]  Так, вы точно понимали, что я сейчас рассказываю?
[41:01.680 --> 41:03.680]  Да, нет, не знаю.
[41:10.680 --> 41:16.680]  Я не понимаю, ну как бы я второй пункт понимаю, а в чем суть третьего замечания нет?
[41:17.680 --> 41:18.680]  Можете пояснить?
[41:19.680 --> 41:24.680]  Представим, что у меня есть кратные ребра.
[41:25.680 --> 41:26.680]  Вот.
[41:30.680 --> 41:34.680]  И что означает, что в родителе может вести другое ребро?
[41:35.680 --> 41:40.680]  Ну представьте, что у меня вот раз ребро, а это ребро другое, вот это первое, вот это второе.
[41:41.680 --> 41:46.680]  Второе ребро другое, для него мне смотреть сложно отдельно.
[41:46.680 --> 41:47.680]  Отдельно.
[41:48.680 --> 41:51.680]  То есть это же для меня новое, полностью новое ребро.
[41:52.680 --> 41:53.680]  Согласны?
[41:55.680 --> 41:56.680]  Да.
[41:57.680 --> 41:58.680]  Вот, из-за этого.
[41:59.680 --> 42:04.680]  А правда, мы не увидим со старым ребром, что там уже серая вершина и какая там будет вершина.
[42:05.680 --> 42:06.680]  И не надо идти туда.
[42:07.680 --> 42:10.680]  Ну, здесь, смотрите, здесь есть нюанс.
[42:11.680 --> 42:12.680]  То есть с одной стороны это правда.
[42:12.680 --> 42:19.680]  С другой стороны, а что делать, к примеру, может ли быть такое, что у нас просто есть из серой в серую вершину?
[42:23.680 --> 42:28.680]  Ну если у нас есть кратные ребра, то это же сразу цикличный граф.
[42:29.680 --> 42:32.680]  Ну оно и без кратных ребер сразу цикличное.
[42:35.680 --> 42:37.680]  Мы считаем цикличные ребра за цикл?
[42:38.680 --> 42:39.680]  Кратные ребра за цикл.
[42:40.680 --> 42:41.680]  Кратные ребра за цикл.
[42:42.680 --> 42:48.680]  Вот это хороший вопрос, ровно так же, как мы считаем, что неориентированный граф всегда цикличный или нет.
[42:52.680 --> 42:53.680]  Цикличный ли вот это?
[42:57.680 --> 42:58.680]  С одной стороны, да.
[42:59.680 --> 43:00.680]  С другой стороны, нет.
[43:01.680 --> 43:02.680]  Вот.
[43:03.680 --> 43:19.680]  В общем-то в действительности с этим всем у нас есть суть примерно следующая, что если вы увидите хоть одно в действительности повторяющееся ребро, то в этом случае вы гарантированно получите цикл.
[43:20.680 --> 43:31.680]  То есть, если вы хотя бы вот такой случай можете отдельно обработать с одним конкретным, то в случае, когда у вас есть вот так ребро и есть вот так, то в этом случае вы ничего сделать не сможете.
[43:32.680 --> 43:34.680]  У вас точно есть цикл.
[43:35.680 --> 43:41.680]  То есть, мы будем считать именно таким вот образом, что если у нас просто одно ребро, то цикла еще не будет.
[43:42.680 --> 43:45.680]  Но если у нас есть 2 кратных ребра, то цикл уже будет.
[43:45.680 --> 43:46.680]  Будет.
[43:46.680 --> 43:49.680]  Смотрите, мы очень быстро сами прошлись по DFS-у.
[43:49.680 --> 43:52.680]  Меня это немножко смущает, но, возможно, это потому,
[43:52.680 --> 43:53.680]  что это всё в онлайне.
[43:53.680 --> 43:54.680]  Вот.
[43:54.680 --> 43:58.680]  И я не вижу ваших лиц, и от этого непонятно, точно
[43:58.680 --> 44:00.680]  ли вы понимаете, что происходит.
[44:00.680 --> 44:06.680]  Понимаете ли вы, что сейчас было?
[44:06.680 --> 44:07.680]  Да.
[44:07.680 --> 44:09.680]  Всё понятно.
[44:09.680 --> 44:12.680]  Напишите алгоритм DFS-а просто вот так.
[44:12.680 --> 44:13.680]  Правильно?
[44:13.680 --> 44:19.680]  Ну, не вот так там, но, по крайней мере, понятно,
[44:19.680 --> 44:20.680]  что делать.
[44:20.680 --> 44:21.680]  Понятно, что делать.
[44:21.680 --> 44:24.680]  Посидеть придётся немного.
[44:24.680 --> 44:28.680]  Лучше всего позадавайте какие-нибудь вопросы на этот
[44:28.680 --> 44:29.680]  счёт.
[44:29.680 --> 44:32.680]  Но последнее, что на сегодня вообще в действительности
[44:32.680 --> 44:36.680]  хотел бы вам сказать, это про сильную и слабую связанность
[44:36.680 --> 44:37.680]  вообще в графах.
[44:37.680 --> 44:39.680]  Что это такое, как это происходит?
[44:39.680 --> 44:42.680]  Мы как-то поднимали с вами вопрос на прошлой лекции.
[44:42.680 --> 44:46.680]  Мы будем это делать ещё на следующих лекциях.
[44:46.680 --> 44:51.680]  Но вообще неориентированный граф связанный, ну, когда
[44:51.680 --> 44:54.680]  мы можем из любой вершины попасть в любую другую.
[44:54.680 --> 44:57.680]  Ориентированный граф же подразделяется на слабосвязанный
[44:57.680 --> 44:59.680]  и сильно связанный.
[44:59.680 --> 45:04.680]  Слабосвязанный граф – это если мы его, все ребра, которые
[45:04.680 --> 45:06.680]  ориентированы, сделаем неориентированными ребрами
[45:06.680 --> 45:09.680]  и посмотрим, будет ли связан граф.
[45:09.680 --> 45:12.680]  В этом случае граф будет называться слабосвязанным.
[45:12.680 --> 45:16.680]  То есть если у него в действительности после того, как мы заменили
[45:16.680 --> 45:19.680]  все ориентированные ребра на неориентированные, связанность
[45:19.680 --> 45:20.680]  есть.
[45:20.680 --> 45:24.680]  Ориентированный же граф сильно связан, если из любой
[45:24.680 --> 45:27.680]  другой вершины, из любой вершины в любую другую можно
[45:27.680 --> 45:28.680]  добраться.
[45:28.680 --> 45:32.680]  С помощью этого можно в действительности находить
[45:32.680 --> 45:34.680]  компоненты сильной связанности.
[45:34.680 --> 45:36.680]  Можно находить это с помощью DFS.
[45:36.680 --> 45:45.200]  Фэса. Этот алгоритм мы рассмотрим уже в следующий раз. Вот, мы очень быстро с вами идем, тогда я,
[45:45.200 --> 45:57.520]  наверное, следующую лекцию чуть больше поднагружу, чтобы все было понятно. Хорошо? Как-то у нас
[45:57.520 --> 46:05.600]  действительно очень быстро получилось. Есть ли у вас вопросы? Ладненько, тогда давайте считать,
[46:05.600 --> 46:12.440]  что фактически это все на сегодня. Мы с вами поговорили про DFS, посмотрели, что это такое,
[46:12.440 --> 46:22.880]  как с этим работать, как с этим жить. В принципе, следующие уже лекции будут посложнее,
[46:22.880 --> 46:29.440]  побольше по качеству. Назову это так. У нас будут уже алгоритмы с типологическими сортировками,
[46:29.440 --> 46:37.840]  скорее всего, но я еще точно об этом попозже вам скажу. Хорошо? Все тогда, хорошего всем вечера!
