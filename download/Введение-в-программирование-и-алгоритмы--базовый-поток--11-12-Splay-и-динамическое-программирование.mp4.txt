[00:00.000 --> 00:14.160]  сплей дерево это самобалансирующая бинарное дерево поиска давайте так теперь поставлю это
[00:14.160 --> 00:20.280]  самобалансирующая
[00:20.280 --> 00:43.360]  бинарное дерево поиска что подразумевается под самосбалансируем вообще деревом поиска
[00:43.360 --> 00:55.440]  так так так сейчас это подключится а то немножко сбивает на самом деле звук подключения ну ладно
[00:55.440 --> 01:02.960]  что подразумевается вообще под самосбалансированный дерево что ребят выключите микрофон если вы не
[01:02.960 --> 01:11.840]  задаете вопрос пожалуйста очень сильно бьет их самосбалансированный самосбалансирующая дерево
[01:11.840 --> 01:22.440]  поиска то есть оно будет менять свое состояние при любых операциях будь то даже просто поиск то
[01:22.440 --> 01:28.920]  есть мы будем каждый раз изменять его состояние изменять то как оно выглядит изменять то что
[01:28.920 --> 01:35.720]  находится в корне при помощи одной простой операции это так называемые ивристики ивристика
[01:35.720 --> 01:48.600]  называется move to root давайте я напишу за счет ивристики
[01:52.840 --> 02:03.640]  move to root что это означает это означает что каждый раз когда у нас приходит запрос на поиск вставку
[02:03.640 --> 02:12.480]  или чего-то еще какого-либо элемента мы берем и специально переделываем дерево так чтобы оно
[02:12.480 --> 02:20.400]  лежало в корне и мы могли получить ответ именно как раз с корня и вот этой ивристикой будет такая
[02:20.400 --> 02:25.800]  за счет чего будет складываться такая ивристика ну представьте что у меня есть какое-то дерево
[02:25.800 --> 02:41.880]  ну вот к примеру пример вот такое вот так ну здесь что-нибудь и вот здесь вот а в с д тут
[02:41.880 --> 02:51.080]  ивристика переноса в корень нашего самого значения а который к примеру мы хотим найти
[02:51.240 --> 02:58.600]  вот это вот значение будет выглядеть следующим образом мы с вами уже проходили очень много
[02:58.600 --> 03:05.400]  всяких поворот и так далее и мы с вами получим как раз таки что мы хотим на вершину поставить
[03:05.400 --> 03:22.120]  корень а наше дерево примет вид следующий вот и тут я то есть она развернется таким вот образом
[03:22.120 --> 03:27.720]  хорошо ли это с точки зрения остальных вершин мало ли мы следующий будет запрос там к примеру
[03:27.720 --> 03:34.720]  вершины и мы захотим ее уже поставить на корень возможно нехорошо но мы с вами покажем в конце
[03:35.040 --> 03:42.200]  лекции о том что в действительности этого достаточно чтобы у нас все происходило как нам
[03:42.200 --> 03:50.440]  необходимо вот для того чтобы это выглядело правильно и выглядело хорошо будет несколько
[03:50.440 --> 03:57.440]  понятий но для того чтобы вообще первоначально уже с этим работать давайте просто еще раз
[03:57.440 --> 04:04.360]  опишем того то как выглядит у нас узел и две дополнительные вещи введем чтобы
[04:04.360 --> 04:10.840]  могли описать красиво код с плей дерева ну описание узла
[04:18.760 --> 04:24.000]  ну я думаю ни для кого не секрет что описание узла выглядит примерно следующим образом что
[04:24.000 --> 04:33.640]  у нас в ноде хранятся я пишу если что псевдо кодом на всякий случай я думаю вы к этому
[04:33.640 --> 04:44.400]  уже привыкли но мало ли что вот в ноде у нас хранятся указатель налевую а вершинку указатель
[04:44.400 --> 04:49.640]  на правой в ребенка то есть левый правый ребенок указатель на
[04:49.640 --> 05:02.960]  родителя и само значение которое мы хотим что нас выполняет роль ключа роль ключа может быть все
[05:02.960 --> 05:10.480]  что угодно но мы будем исходить из того что пока просто хранить какой-нибудь вот и две
[05:10.480 --> 05:15.960]  вспомогательные функции которые мне понадобится в принципе чтобы очень часто не писать однообразный
[05:15.960 --> 05:24.840]  вот мы с вами сделаем следующее что у нас будет установка родители для какой-то вершины просто
[05:24.840 --> 05:32.240]  выглядящая следующим образом что если у меня тут есть ну да что же такой час
[05:40.000 --> 05:45.240]  мы сюда передадим ребенка и предполагаем в родителя который мы хотим поставить и
[05:45.240 --> 05:51.560]  здесь же будем выполнять ну то есть чисто с точки зрения того чтобы у нас код выглядел хорошо что
[05:51.560 --> 05:57.640]  если у нас ребенок не является
[06:00.560 --> 06:07.920]  ну то есть нулевым указателем то в этом случае мы скажем что у ребенка его родитель
[06:07.920 --> 06:20.520]  это сам родитель который мы с вами передали вот и помимо этого нам еще понадобится чисто
[06:20.520 --> 06:31.160]  вспомогательная вещь тоже это то что мы будем какой-то вершине к вершине будем назначать ее
[06:31.160 --> 06:42.080]  родителем то есть мы назовем это кип пример от вершины какой-нибудь в в от слова вертекс если
[06:42.080 --> 06:50.520]  что на всякий случай вот и здесь она просто будет вызывать внутри то что мы устанавливаем
[06:50.520 --> 07:05.000]  для ее детей родителям то есть мы установим до левого ребенка и мы установим с вами для правого
[07:05.000 --> 07:14.040]  ребенка тоже просто чтобы не было много повторяющихся вещей вот ну пока вроде бы все понятно здесь
[07:14.040 --> 07:33.680]  ничего сложного нет ничего вопрос а вопроса я не слышу но ладно надеюсь мне его зададут тогда
[07:34.280 --> 07:47.760]  что еще раз так еще раз какой вопрос
[07:47.760 --> 08:01.320]  но видимо нет третий вопрос зачем нам устанавливать детей что он родитель ну вот зачем на функциях
[08:01.800 --> 08:09.880]  потому что мы когда будем пересвязывать вершины вы увидите для чего это сделано то есть мы когда
[08:09.880 --> 08:13.720]  будем кидать что-то в корень у нас будут два раздельных дерева для них нужно установить
[08:13.720 --> 08:19.800]  будет родители ну это с точки зрения удобства реализации просто того чтобы вы понимали что
[08:19.800 --> 08:26.320]  эти методы делают конечно можем писать отдельно ну то есть вообще не писать лучше разделять
[08:26.320 --> 08:35.320]  просто в силу удобства и написание тогда понятно все что происходит вот и как вообще
[08:35.320 --> 08:41.760]  работает с плей дерева с плей дерева это что что еще раз
[08:45.760 --> 08:54.120]  окей как работает с плей дерева смотрите мы с вами с вами проходили в вл дереве что у нас есть так
[08:54.120 --> 09:00.000]  называемый правый так называемый левый поворот вот который у нас с вами уже был и выглядел он
[09:00.000 --> 09:05.840]  следующим образом у нас был с вами давайте я нарисую правый поворот
[09:10.200 --> 09:14.400]  который делал следующее из вот такого вот
[09:14.400 --> 09:18.600]  вот дерево
[09:18.600 --> 09:28.040]  вот это а это б это с это там было по и ку и наоборот
[09:28.040 --> 09:41.880]  правый поворот делал следующее он вершину ку делал на наш корень здесь у нас оставалось
[09:41.880 --> 09:53.360]  дерево а а сюда переходила вершина где у нас здесь и сохранялся весь нам необходимый порядок это
[09:53.360 --> 09:56.240]  был правый поворот помимо этого у нас еще был левый поворот
[09:56.240 --> 10:12.280]  вот и левый поворот у нас заключался в следующем что если у нас есть вершина
[10:12.280 --> 10:21.920]  у нее является правым сыном вершина ку здесь у нас есть под дерево а здесь у нас есть под
[10:21.920 --> 10:29.520]  дерево б здесь у нас есть под дерево с то мы с вами получали следующее что у нас есть вершина ку
[10:29.520 --> 10:42.240]  на нашем корне а здесь у нас получалось по которым как раз таки находились все необходимые нам от
[10:42.240 --> 10:51.240]  деревья вот мы сами разбирали как это работает надеюсь здесь много пояснять этого не надо
[10:51.240 --> 10:58.480]  то есть мы просто разворачивали с вами представьте следующее что у меня пришел запрос на сплей дерево
[10:58.480 --> 11:04.320]  всегда стремится и всегда делает так чтобы наши вершины от которой запрос стало корнем чтобы
[11:04.320 --> 11:11.320]  запрос заключался в следующем просто посмотреть значение ключа там в корне к примеру вот и для
[11:11.320 --> 11:18.440]  того чтобы это работало а первый первое что нам необходимо это по факту как раз таки вот этот
[11:18.440 --> 11:30.160]  вот поворот и называется он зиг вот то есть если мы с вами поворачиваем либо одну либо
[11:30.160 --> 11:34.840]  просто правым поворотом либо левым поворотом это называется операция зиг и все зависит от
[11:34.840 --> 11:43.680]  того просто является ли у нас там является ли у нас там вершина к примеру необходимая нам
[11:43.680 --> 11:51.480]  слева или справа которую мы ищем и это первая операция которая нам будет необходимой здесь вот
[11:51.480 --> 12:04.440]  я думаю ну описывается она достаточно просто мы с вами говорим что сюда передается по факту
[12:04.440 --> 12:18.280]  эту вершину мы с вами передадим родителям и ребенка после чего определимся мою эту
[12:18.280 --> 12:26.440]  функцию следующим образом у нас с вами есть grandparent дедушка который является там родителем
[12:26.440 --> 12:43.880]  родителя вот после чего мы перепроверим если у нас если у нас нам необходимо переделать как раз
[12:43.880 --> 12:50.560]  таки новых родителей поставить ой тщене нового ребенка для этого grandparent и в зависимости от того
[12:50.560 --> 12:56.080]  являлся ли parent левым или правым сыном то есть вот это вот п являлась вот где-то она
[12:56.120 --> 13:03.600]  левым или правым примерно здесь в зависимости от этого нам необходимо будет переподвесить данную
[13:03.600 --> 13:09.440]  вершину ху и сказать что вот теперь она находится здесь это сделать достаточно просто мы сравниваем
[13:09.440 --> 13:20.560]  с вами как раз таки нашу вершину то есть если она является левым ребенком на
[13:21.240 --> 13:31.760]  то в этом случае мы с вами получим там например получается что
[13:31.760 --> 13:46.880]  ребенком для этого выступает теперь в начале аналогично в другую сторону я думаю вы здесь
[13:46.880 --> 13:54.800]  сможете написать ну то есть здесь сама суть в том что мы переподвесили нашу вершину после
[13:54.800 --> 14:04.080]  чего нам необходимо взять и поменять местами наши вершины наши вершины по и кум друг с другом
[14:04.080 --> 14:19.400]  а вот и для того чтобы это сделать ну необходимо написать плюс правый поворот правый поворот
[14:24.080 --> 14:25.280]  или левый поворот
[14:25.280 --> 14:37.920]  то есть мы должны переподвесить наши вершины но здесь все тоже достаточно просто я думаю вы
[14:37.920 --> 14:47.560]  помните как они пишутся там всего было 3-4 строчки вот без фиксации какого-то родителей
[14:48.560 --> 14:56.280]  понять как это выглядит внутри и после чего мы с вами могли можем здесь написать последнюю
[14:56.280 --> 15:07.000]  оставшуюся строчку не несколько о том что нам нужно зафиксировать зафиксировать родителей
[15:07.000 --> 15:16.920]  для зафиксировать родители для ребенка потому что он поменял свое место зафиксировать родителям
[15:16.920 --> 15:26.520]  нашего родителя которого мы переподвесили вот и сказать что
[15:26.520 --> 15:32.360]  например там сет перрент
[15:32.360 --> 15:44.520]  вот получается мы должны теперь сказать что для нашего ребенка является родителем теперь
[15:44.520 --> 15:52.200]  наш дедушка который был дедушкой вот и чтобы это произошло нам необходимо написать последнее
[15:52.200 --> 15:57.960]  нам необходимо написать там последнюю функцию я думаю вы понимаете что она выглядит ровно как
[15:57.960 --> 16:12.280]  сет перрент от получается чайл ты чайл и гранд вот то есть смотрите зиг это по факту именно тот
[16:12.280 --> 16:19.480]  самый правый и левый поворот который у нас с вами были в овл дерево то есть мы просто берем и
[16:19.480 --> 16:28.400]  поворачиваем наше дерево в зависимости от того как оно выглядело и с этим всем работаем это первое
[16:28.400 --> 16:37.720]  что нам понадобится сама хитрость на самом деле вот вся суть типа вл дерево в том что кроме вот
[16:37.720 --> 16:44.260]  этой операции зип используется еще две операции то есть когда мы будем с вами переподвешивать наши
[16:44.260 --> 16:50.360]  вершины мы будем пытаться сократить наши дерева с точки зрения высоты то есть это выглядит не
[16:50.360 --> 16:58.080]  совсем как та самая ивристика которая муф ту рут которая там была то есть мы к ней добавим еще
[16:58.080 --> 17:05.800]  одно действие а еще одно действие будет заключаться в следующем мы с вами проходили большой левый поворот
[17:05.800 --> 17:14.560]  и большой правый поворот здесь почти что будет аналогично смотрите что я хочу я хочу уменьшать
[17:14.560 --> 17:22.440]  высоту дерева после каждого каждого его использования в принципе после каждого момента когда я беру
[17:22.440 --> 17:39.960]  можно вопрос там вот на прошлом слайде был написано и гран-пэр я понял а теперь давайте
[17:39.960 --> 17:48.600]  смотреть вообще что мы хотим то есть представьте следующую картину так у кого-то микрофон включен
[17:48.600 --> 17:56.040]  теперь давайте с вами разбираться с тем вообще что у нас происходит и первое чем мы разберемся это
[17:56.040 --> 18:10.280]  ну давайте это назовем zig zig так оно и называется в оригинале что такое zig zig представьте следующую
[18:10.280 --> 18:17.360]  следующий момент вот у меня есть вершина там давайте буду обозначать буквы g это grand
[18:17.360 --> 18:25.040]  parent здесь у меня parent здесь у меня child вот и здесь у меня есть у него под деревья а
[18:25.040 --> 18:36.840]  под деревья б здесь у меня под дерево с и здесь у меня под дерево д я хочу сделать с корнем но
[18:36.840 --> 18:45.800]  так чтобы моё дерево было ну оно переподвесилось как раз таки наверх и оно выглядело по сути примерно
[18:45.800 --> 18:53.400]  так же то есть мы хотя бы здесь не увеличим высоту если так в общем брать что обцд примерно
[18:53.400 --> 19:01.760]  ровно операция zig zig делает следующее она поворачивает сначала п сюда после чего мы
[19:01.760 --> 19:07.680]  поворачиваем ц то есть это просто два поворота направо два поворота направо относительно этой
[19:07.680 --> 19:16.480]  вершинки вот то есть мы с вами хотим получить по итогу после первого поворота мы получим с
[19:16.480 --> 19:34.840]  вами здесь п здесь g здесь c здесь у нас будет а тут b тут c и тут d после чего я разворачиваю как
[19:34.840 --> 19:41.600]  раз таки ц чтобы оно стало корнем я получу с вами вот такую вот картину здесь ц здесь ой ц
[19:41.600 --> 19:56.760]  да все правильно ц а после чего у меня идет п здесь у меня будет b здесь у меня будет вершина g
[19:56.760 --> 20:06.880]  который будет два по дерево ц и вот операция zig zig заключается вот в этом то есть смотрите
[20:06.880 --> 20:12.600]  мы просто переносим нашу вершину child которую мы пытаемся найти прям вот наверх на корень для
[20:12.600 --> 20:18.280]  того чтобы если мы там искали данную вершину смотрели на нее что-то с ней делали она просто
[20:18.280 --> 20:26.040]  там была и все было хорошо вот это то что касается операции zig zig она просто берет все и поворачивает
[20:26.040 --> 20:38.360]  здесь не очень сложно я думаю вы поняли да вот а теперь операция zigzag последняя которая нам
[20:38.360 --> 20:53.280]  понадобится в чем вообще плюс этого всего на самом деле zip у нас есть с вами операция zigzag
[20:53.280 --> 21:03.680]  операция zigzag она выглядит как большой правый поворот по сути либо большой левый то что мы как
[21:03.680 --> 21:09.520]  раз таки с вами тоже видели представьте следующий у меня вот здесь вершина g вот здесь у меня будет
[21:09.520 --> 21:19.920]  parent а здесь будет child вот и также проставим наши под деревья эти под деревья могут быть пустые
[21:19.920 --> 21:27.440]  могут быть не пустые нам это не сильно играет роли тогда я вначале беру и делаю правый поворот
[21:27.440 --> 21:40.760]  относительно ой правый поворот этого неправда вначале я делаю левый поворот с после чего
[21:40.760 --> 21:47.720]  делаю правый поворот вот то есть после этого я выстрою себе следующую картину после первого
[21:47.720 --> 21:56.440]  поворота что у меня будет вот здесь вот сэн а вот здесь вот будет наш перн и вот в этом подделье
[21:56.440 --> 22:08.000]  будет а вот в этом подделье будет б здесь сэн и здесь после чего я захочу хочу цепь перенести как
[22:08.000 --> 22:15.480]  раз таки в корень тогда я делаю ее корнем справа у меня будет этот grandparent слева у меня будет
[22:15.480 --> 22:33.520]  parent здесь будет а б с и д вот то есть смотрите авель дерево внутри себя использует вот такие вот
[22:33.520 --> 22:39.920]  моменты то есть самая главная операция здесь естественно будет zig zig zigzag и просто zig вот
[22:39.920 --> 22:46.520]  эти три операции они позволяют нам постоянно изменять изменять структуру нашего дерева и
[22:46.520 --> 22:51.320]  благодаря измене структуры нашего дерева и то что всегда будет на вершине стоять та вершина
[22:51.320 --> 22:58.640]  которой мы обращаемся то будет все очень хорошо в силу того что мы будем постоянно
[22:58.640 --> 23:07.920]  перебалансировать наши дерева хотя сбалансированным его назвать в прямом смысле слова нельзя так
[23:08.000 --> 23:15.240]  как иногда там некоторые операции действительно будут работать к примеру за о отн вот все это
[23:15.240 --> 23:23.920]  вместе объединяется в так называемую операцию сплей что такое сплей сплей это операция как раз
[23:23.920 --> 23:33.440]  таки вот этих переподвешиваний в зависимости от того как выглядит наша вершина то есть она
[23:33.440 --> 23:40.240]  берет и переподвешивает наш запрос который у нас есть вершины на корень после чего мы
[23:40.240 --> 23:45.000]  можем обработать как раз таки запрос то есть перед любым запросом и будем сначала делать
[23:45.000 --> 23:51.640]  сплея только после этого что-то там подвешивать или находить и так далее вот в этом случае мы
[23:51.640 --> 23:59.760]  с вами давайте опишем вообще в принципе как у нас выглядит наша операция сплей для какой-нибудь
[23:59.960 --> 24:06.360]  вершинки понятна сама суть сплея что произойдет давайте вопросы пока на этом этапе
[24:12.240 --> 24:19.960]  а можете еще раз зиг зиг показать зиг зиг вот например такой естественно может быть и с другой
[24:19.960 --> 24:30.960]  стороны спасибо а мы по помощи зиг зиг зиг зиг закала как раз делаем чтобы це стало наверх да
[24:30.960 --> 24:38.800]  а в каком случае надо делать что бы состав на вер просто зиг когда у нас у перрента нету
[24:38.800 --> 24:48.560]  никого в принципе сверху мы сейчас сплея это увидим как раз вот вопрос а в чем смысл этого
[24:48.560 --> 24:54.440]  действия если мы пытаемся поставить цена вверх то есть мы уже знаем где находится ц
[24:56.440 --> 25:07.840]  с одной стороны это правда вот но есть другой вопрос в том что как часто мы будем за счет
[25:07.840 --> 25:15.840]  таких операций мы с вами будем постоянно изменять конфигурацию дерева из-за этих изменений мы с
[25:15.840 --> 25:24.120]  вами это докажем у нас дерево ну точнее любой запрос с плей именно будет работать за логарифом
[25:24.120 --> 25:29.320]  амортизационно то есть средне он может отработать за от единички если мы будем
[25:29.320 --> 25:35.040]  постоянно искать один тот же элемент например правда ну то есть он всегда в корне а может
[25:35.040 --> 25:42.200]  отработать за отн в зависимости от того как оно там выстроилась первоначально чем преимущество
[25:42.200 --> 25:50.920]  этого перед обычным поиском который тоже за логариф бинарное дерево поиска не всегда работает
[25:50.920 --> 25:59.520]  за логариф ну хорошо а вот сбалансировано блогу или сбалансированное дерево работает за логариф
[25:59.520 --> 26:08.040]  в чем плюс этого дерева да смотрите на некоторых повторяющихся операций а смотрите чем больше
[26:08.040 --> 26:13.800]  у вас повторяющихся операций тем лучше с плей дерева потому что повторяющиеся операции я имею
[26:13.800 --> 26:21.560]  в виду повторяющиеся с одним и тем же элементом он все выше корнем а если он все выше корня ваши
[26:21.560 --> 26:27.880]  запросы как можно быстрее обработать то есть вам не нужно будет переходить по указателю то есть
[26:27.880 --> 26:35.800]  как вы типа вот если мы один раз ищем ц мы его поставили в корень если мы потом будем еще 5 раз
[26:35.960 --> 26:45.600]  просто брать корень в общем случае да именно так или к примеру мы постоянно будем вставлять
[26:45.600 --> 26:54.600]  какой-то ключ близки к ц близки к ц мы напишем как это будет выглядеть и за счет чего это будет
[26:54.600 --> 27:01.440]  складываться но вообще весь самый главный плюс классности по сплее дерева в том что мы
[27:01.440 --> 27:07.200]  в действительности используем просто с повторяющимся запросами очень-очень быстро мы
[27:07.200 --> 27:19.080]  можем найти ответ гораздо быстрее чем в некоторых других деревьях вот а симпатически так это тоже
[27:19.080 --> 27:30.400]  мы с вами докажем окей еще есть вопросы нет хорошо тогда давайте с вами продолжим давайте
[27:30.400 --> 27:50.840]  опишем с вами функцию сплей и давайте сейчас я я здесь назвал это зиг да давайте это не совсем
[27:50.840 --> 27:58.960]  зиг это зиг это вправо зак это в другую то есть это не совсем зиг это просто некоторые ротэйт
[27:58.960 --> 28:07.040]  в зависимости от того левый это или правый поворот то есть если у меня находится кью слева то нам
[28:07.040 --> 28:14.120]  необходим правый поворот если нам необходим кью справа то это левый поворот прошу прощения вот
[28:14.120 --> 28:25.560]  окей а давайте с вами напишем функцию сплей нам сплей необходимо чтобы он он поднял вершину в
[28:25.560 --> 28:32.920]  корень до какого-то момента но так как у нас все операции рекурсивно внутри то нам достаточно
[28:32.920 --> 28:38.840]  писать сплей в зависимости от конфигурации дерева сейчас которая переподвесит какие-то вершинки вот
[28:38.840 --> 28:44.720]  именно сейчас то есть примет либо зиг либо зиг зиг либо зигзаг одну из этих операций поэтому
[28:44.720 --> 28:54.320]  операция сплей от какой-то вершины в будет выглядеть следующим образом но это но да вот мы
[28:54.320 --> 29:10.160]  говорим что есть ли у нас parent в неопределен неопределен равен а то в этом случае мы вернем
[29:10.160 --> 29:21.880]  просто наш корень то есть в следующий момент после этого ну мы сделали условия этой остановки
[29:21.880 --> 29:26.440]  рекурсии а после чего мы можем играть как раз таки работать абсолютно совсем давайте
[29:26.440 --> 29:37.200]  ведем как раз таки наши вершины parent и grandparent то есть они равны там web parent и grandparent
[29:37.200 --> 29:46.080]  у меня равен parent от parent
[29:51.800 --> 29:58.000]  но это дедушка бабушка как хотите назовите эту вершину вот но это та которая является
[29:59.000 --> 30:09.080]  предком для нашего родителя вот после чего мы с вами говорим что если у нас нету
[30:13.840 --> 30:24.960]  если у нас нету дедушки то есть у этой вершины нету в общем если нету у родителя у родителя то в
[30:24.960 --> 30:35.600]  этом случае мы с вами говорим следующее мы просто делаем rotate от вершины ну rotate parent
[30:35.600 --> 30:42.840]  и мы просто берем и как раз таки поворачиваем необходимую нам вершину в нужную нам сторону либо
[30:42.920 --> 30:50.160]  это значит что мы нашли корень если grandparent равен а то parent являлся
[30:50.160 --> 31:05.880]  вот и здесь возвращаем после чего мы с вами говорим что иначе давайте обсудим следующее
[31:05.880 --> 31:22.920]  в каком случае нас что происходит у нас зиг зиг зиг зиг вызывается в случае если grandparent
[31:22.920 --> 31:34.920]  parent является левым ребенком от grandparent и сам ребенок является тоже левым ребенком
[31:34.960 --> 31:46.000]  поэтому в этом случае нам достаточно сделать следующее иначе мы проверяем если grandparent
[31:53.120 --> 31:58.920]  grandparent left равно parent
[32:05.360 --> 32:15.120]  grandparent left равно
[32:17.960 --> 32:27.160]  нашей вершине в то в этом случае мы с вами делаем просто два наших rotate вот то есть мы
[32:27.160 --> 32:39.880]  берем и просто поворачиваем сначала мы поворачиваем нашу вершину с parent но то есть
[32:39.880 --> 32:50.960]  корень который был у того под деревом после чего мы с вами берем и поворачиваем поворачиваем
[32:50.960 --> 32:59.360]  grandparent и вот так это просто зиг зиг мы же по идее можем зиг зиг зиг заг получается
[32:59.360 --> 33:05.240]  заг заг и заг зиг вывести в распредельные функции их вызывать смотрите в тому со суть что нам
[33:05.240 --> 33:13.520]  необходимо только зиг зиг и зиг заг да забавный факт такой что нам он будет только лишь это
[33:13.520 --> 33:21.400]  необходимо вот сейчас я допишу я объясню хорошо вот иначе мы делаем с вами операции
[33:21.400 --> 33:29.840]  zigzag вот что делает zigzag zigzag просто поворачивает в начале в начале нам необходимо повернуть
[33:29.840 --> 33:37.680]  grandparent и в после чего нам необходимо повернуть
[33:37.680 --> 33:54.640]  grandparent и в вот после чего нам достаточно вернуть в этом все
[33:54.640 --> 34:01.040]  так как мы делаем рекурсивно мы с вами делаем здесь return
[34:07.680 --> 34:20.040]  return splay от v почему потому что в этом случае у нас так или иначе v стало корнем вот и тогда
[34:20.040 --> 34:27.640]  нам этого достаточно чтобы что-то произошло почему нам достаточно операции zig zig и zigzag
[34:27.640 --> 34:35.440]  и просто по факту zig или zag вот потому что если у нас оно является просто правым сыном то мы
[34:35.440 --> 34:44.080]  будем постоянно перекидывать ну то есть если оно находится правым сыном постоянно с такой правой
[34:44.080 --> 34:53.280]  ветки то мы просто будем перекидывать наверх делая наш заг если находится слева то мы делаем
[34:53.280 --> 35:00.280]  zig zig zig zig zig и так далее то есть мы тоже вернемся ровно к этому же моменту но то есть вернемся
[35:00.280 --> 35:08.120]  вот к такому же моменту что эта операция произойдет вот в ту же сторону потому что ну если мы
[35:08.120 --> 35:16.360]  к примеру grandparent вызываем от него splay у меня zig с ней zag наоборот будет постоянно увеличивать
[35:16.360 --> 35:21.800]  ее пока не дойдет до корня вот самое главное что нам нужно определиться что делать когда ты правый
[35:21.800 --> 35:29.320]  сын а потом стал левый если ты просто правый сын а потом правый сын то все хорошо если ты левый
[35:29.320 --> 35:34.040]  сын а потом правый сын то у тебя тоже все хорошо потому что они будут в нужном порядке то есть нам
[35:34.040 --> 35:40.360]  нужно было переопределить только лишь одну штуку вот и все это применяется с помощью вот как раз
[35:40.360 --> 35:45.200]  таки одного rotate который поворачивает либо налево либо направо и нам нужно было обработать
[35:45.200 --> 35:57.840]  вот именно вот эту вот штуку по факту все остальное похоже именно на то как это и было вот мы просто
[35:57.840 --> 36:09.480]  все ситуации приводим к zig zig zig zag и zig or zag да да все правильно то есть все ситуации мы
[36:09.480 --> 36:22.520]  приводим к одной одной из этих трех вот если у нас grandparent потом направо parent и направо child
[36:22.520 --> 36:35.000]  так и тогда пока комнат будет сейчас еще раз можно ну а точно также как zig zig только все
[36:35.000 --> 36:55.520]  направо просто будет все время подъем через zag или как так да давайте еще раз в данном случае
[36:55.520 --> 37:01.680]  мы с вами рассматриваем то что у нас просто будет подниматься данная вершина и вот будет
[37:01.680 --> 37:08.360]  происходить грубо говоря вот этот вот левый поворот постоянно если по правой вот идет кусочек
[37:08.360 --> 37:17.760]  ясно вот этого нам достаточно если вдруг она будет правым и левым ну сначала она
[37:17.760 --> 37:22.080]  буду правым потом после поворота стало левым то здесь мы уже применяем как раз таки zig zag
[37:22.080 --> 37:35.000]  нам главное все свести к zig. Зачем надо было отдельно прописывать zig zig? Ну чтобы вы понимали
[37:35.000 --> 37:41.480]  как это выглядит то есть у нас возможны такие случаи вот я с вами их показал посмотрел как
[37:42.480 --> 37:52.280]  вопросы есть вот то есть именно так задавалась сама структура первоначально того как она
[37:52.280 --> 38:00.920]  выглядела я правильно понимаю что в принципе мы вообще можем не павиться там с zig zig и zig
[38:00.920 --> 38:11.080]  загом а просто ну условно каждый раз поднимать просто ротейпом да ну не совсем да ну смотрите
[38:11.080 --> 38:22.840]  здесь вся будет проблема в чем когда мы здесь делаем ротейти вот zig zag и zig zig смотрите в одном
[38:22.840 --> 38:31.840]  случае мы сначала должны повернуть grandparent и parent вот в котором как раз таки вот вот в этом
[38:31.840 --> 38:39.640]  случае а только потом child иначе мы получим с вами немного другое дерево если мы захотим
[38:39.640 --> 38:46.960]  сделать наоборот сейчас я не понимаю немного вот ситуация когда у нас parent слева child слева и
[38:46.960 --> 38:53.920]  когда они оба справа они же как бы симметрично почему мы видим мы хотим рассмотреть пока
[38:53.920 --> 39:06.880]  достаточно будет одного случая они симметрично я не спорю но да суть спа и дерева в том что мы
[39:06.880 --> 39:11.640]  ограничимся вот этими функциями по факту данным нужен один ротейт который мы применяем везде
[39:11.640 --> 39:19.560]  где можно вот zig zig zig zag это немножко раздельные ситуации которые нужно рассмотреть отдельно вот
[39:19.560 --> 39:25.280]  все остальное вместе здесь у нас получается так что оно позволяет нам перекинуть главное в корень
[39:25.280 --> 39:30.160]  то есть мы соблюдаем саму туевристику который у нас есть который мы первоначально пытаемся
[39:30.160 --> 39:38.560]  добиться но вся суть в том что при таких операциях мы будем достигать вот просто там есть удивительный
[39:38.560 --> 39:46.440]  факт который мы сейчас разберемся что при таких вот операциях мы с вами достигнем следующего что
[39:46.440 --> 39:58.160]  запросы работают за логарифм при таких достаточно ну скудных знаниях грубо говоря дерево когда
[39:58.160 --> 40:06.920]  мы будем перебрасывать все наверх понятно то есть у нас есть zig zig zag zig zig zig zig zig zig
[40:06.920 --> 40:18.560]  вот этих трех операций достаточно данном случае то есть только они определены считаем так вот что
[40:18.560 --> 40:25.560]  касается самого сплея сплей выглядит вот таким вот образом и мы сейчас будем с ним разбираться но
[40:25.560 --> 40:37.560]  почему это удобно а это удобно по следующему принципу давайте с вами напишем функцию поиска
[40:37.560 --> 40:50.040]  то есть нам необходимо найти какой-то ключ в нашем дереве ну не обязательно в дереве полным может
[40:50.040 --> 40:56.840]  быть в каком-то по дереве поэтому мы сделаем с вами функцию find которая принимает там вершину
[40:56.840 --> 41:08.760]  в и ключ после чего мы с вами говорим что ну если у нас там к примеру такое условие остановки если
[41:08.760 --> 41:19.520]  в ровно там на то вернем минус один пример ну здесь зависит от того какие ключи здесь
[41:19.520 --> 41:24.880]  уже вам необходимо подумать что можно вернуть условия такой остановки критической остановки у
[41:24.880 --> 41:37.800]  рекурсии вот после чего мы с вами делаем следующее что если у нас хотя не нам давайте пусть у нас
[41:37.800 --> 41:45.760]  это будет файн он возвращать будет саму ноду пусть у нас будет возвращать налp tr ну просто на вот
[41:45.880 --> 42:01.720]  если у нас ключ равен ключу нашей вершины то в этом случае мы возвращаем так как мы хотим добиться
[42:01.720 --> 42:12.480]  чтобы у нас лежало все в корне то мы возвращаем с вами сплей иначе после чего мы с вами говорим
[42:12.480 --> 42:26.720]  что иначе если у нас ключ меньше чем там ключ который есть в нашей вершине вы то по просто
[42:26.720 --> 42:34.520]  свойства бинарного дерева поиска мы с вами идем налево вот то есть ключ находится где-то слева то
[42:34.520 --> 42:42.400]  есть у структуры ноды ключ это ее значение или или как ну когда вы когда написали кейвер сказали
[42:42.400 --> 42:49.520]  потом расскажите что такое кей на кей это ключ ключ это какое-то значение просто он может
[42:49.520 --> 42:57.200]  нынче по значению получается да ну конечно ключом может быть любая структура данных на самом деле
[42:57.200 --> 43:02.720]  который вы все понял вот но в данном случае мы говорим о том что это просто какие-то интенты
[43:02.720 --> 43:12.040]  чтобы вам было понятнее и легче как-то хорошо то есть если у нас ключ находится слева то мы
[43:12.040 --> 43:17.000]  можем пойти влево единственное что нужно понимать мы там примеры вообще можем так прийти
[43:17.000 --> 43:22.280]  или нет если вы говорите о том что в дереве все есть то окей вы просто здесь возвращаете
[43:22.280 --> 43:47.720]  вот если у вас если у вас ключ будет больше чем
[43:47.720 --> 44:06.680]  то в этом случае мы возвращаем дощаем поиск вот и ключа ну то есть мы пошли направо там
[44:06.680 --> 44:15.560]  пример и в принципе сам по себе файн в чем плюс его в том что мы в конце еще раз делаем сплэк
[44:15.560 --> 44:27.080]  вот то есть смотрите она не сильно процедура файн ты не сильно отличается стандартной
[44:27.080 --> 44:34.000]  процедуры вообще в принципе как просто мы тянем эту вершину вверх и делаем порн через там через
[44:34.000 --> 44:39.480]  процедуру сплей по факту то есть мы хотим чтобы эта вершина оказалась там почему у меня в конце
[44:40.480 --> 44:48.160]  написан сплей в случае к примеру если вы говорите о том что вы можете искать в дереве что-то меньшее
[44:48.160 --> 44:53.560]  неравное ключу и так далее то в этом случае можно написать следующее здесь например
[44:53.560 --> 45:12.640]  и вот здесь аналогично и не равно то есть мы вызываем функцию find в случае если у нас
[45:12.640 --> 45:19.440]  слева нет ничего если ну грубо говоря представьте следующее бинарное дерево поиска у нас с вами
[45:19.440 --> 45:36.240]  есть тут 5 здесь 4 здесь у него здесь ничего не может быть ну давайте не 5 6 6 4 вот здесь у
[45:36.240 --> 45:44.040]  него ничего нет здесь там два я ищу элемент 5 он у меня должен по-хорошему вывести 4 вот но
[45:44.040 --> 45:50.040]  у него нету правого сына то есть вот у нас нам но так как запрос обратился по факту к этой вершине
[45:50.040 --> 45:56.680]  на последний раз в последний момент то я хочу чтобы это четверка перевелась в наш корень и
[45:56.680 --> 46:04.880]  у нас получилось следующее дерево 4 2 6 поэтому я вызываю сплей в конце еще раз если же я ключ
[46:04.880 --> 46:13.880]  нашел то я просто вызвать понятно в первой вариации когда мы еще не дописали дополнительные условия
[46:13.880 --> 46:23.280]  в и у нас по идее последний ретурн функции никогда не зашла вот в этот сплей не зашла бы она
[46:23.280 --> 46:29.720]  бы зашла вот сюда и был бы на всегда и мы бы ничего с этим больше не делали вот разы сначала
[46:29.720 --> 46:38.520]  не в двойке обратимся мы сразу сплэй сделали что еще раз почему мы сразу сплэй сделали мы
[46:38.520 --> 46:47.040]  разве не должны в двойку пойти почему у нас 5 мы ищем 5 да так если 5 мы ищем то мы нашли четверку
[46:47.040 --> 46:54.320]  идем вправо никакой их не сработает дополнять никакой их не сработает да вот то есть мы хотим
[46:54.320 --> 46:59.440]  с вами как раз таки исходить из того что мы даже если запрос плюс минус неудачный но мы
[46:59.440 --> 47:06.120]  почему-то приходим возможно нас интересует данные вот на конкретном отрезке пример там от 10 до
[47:06.120 --> 47:14.320]  тысячи а вот все что вовне очень редкие запросы когда мне нужно там миллион найти и вот я хочу
[47:14.320 --> 47:21.400]  чтобы вот все что было рядышком находилось как можно выше к моему корню вот поэтому в этом
[47:21.400 --> 47:33.560]  случае сплэй дерево достаточно классно и крутой вот смотрите что касается вставки и удаления
[47:33.560 --> 47:39.880]  вставка удаления работает следующим образом для того чтобы мы вставляли элемент или удаляли
[47:39.880 --> 47:46.400]  элементы нам понадобится две дополнительные функции сплит и мерч сплит будет разрезать дерево
[47:46.400 --> 47:54.240]  по данному ключу то есть что это означает представьте следующее что делает сплит то есть
[47:54.240 --> 48:01.200]  файн мы с вами нашли сплит для того чтобы у меня сплит работал но у меня было там дерево к
[48:01.200 --> 48:10.200]  примеру следующее давайте на примерах 8 здесь у меня будет 6 здесь у меня будет 10 сюда пойдет
[48:10.200 --> 48:22.800]  7 4 здесь там 11 и я хочу разбить свое дерево по ключу 10 например то есть я сплите хочу
[48:22.800 --> 48:37.320]  получить следующее чтобы у меня было следующее дерево 8 6 7 4 а здесь 10 и 11 и для чего мне
[48:37.320 --> 48:44.000]  нужен этот сплит представьте я хочу вставить сюда 9 вот хочу вставить в дерево свое девятку
[48:44.000 --> 48:53.400]  давайте 9 поставим его самое место куда ему необходимо тогда в этом случае 9 должно если
[48:53.400 --> 49:02.280]  смотреть на вот это дерево 9 вот должно быть вот здесь вот правда так как я разъединил убрал
[49:02.280 --> 49:11.040]  грубо говоря вот это вот ребро то в этом случае я получил два дерева 8 и 10 с корнями 8 и 10 и
[49:11.040 --> 49:19.400]  теперь могу 9 поставить сюда и я все еще получил бинарное дерево поиска то есть сплит по ключу
[49:19.400 --> 49:26.640]  берет и разделяет наше дерево на два под дерево после чего для того чтобы вставить какой-то
[49:26.640 --> 49:32.400]  элемент мы объединяем их говорим что левым ребенком от сплита ну то есть дерево которое меньше
[49:32.400 --> 49:40.160]  это левый ребенок для этой вершины новый а правый ребенок это вот новая наша вершина ну то есть
[49:40.160 --> 49:45.740]  не правый ребенок это другое дерево который объект точно больше то есть сплит у нас будет
[49:45.740 --> 49:52.040]  работать следующим образом сам по себе он просто будет делить два дерева и получать вот эти вот
[49:52.040 --> 49:59.880]  кусочки а когда мы уже получим вот эти вот кусочки нам будет достаточно просто вставить как
[49:59.880 --> 50:08.800]  корень наш новый ключ который мы хотим добавить что будет еще рассказать когда девятка станет
[50:08.800 --> 50:14.920]  если мы не будем разделять это звенит слева от десятки она станет слева от десятки но нас
[50:14.920 --> 50:20.640]  это не устраивает мы же делаем когда запрос какому-то смотрите еще сплей дерево работает
[50:21.000 --> 50:29.400]  любой запрос делает так что эта вершина который у нас есть запрос становится корнем я хочу поставить
[50:29.400 --> 50:35.440]  в корень для того чтобы поставить корень давайте я разъединю два дерева и скажу теперь это под
[50:35.440 --> 50:42.400]  деревья девятки все что правее ну то есть мы разделим так что все что правее оно больше все
[50:42.400 --> 50:48.800]  что левее оно меньше правда правда а значит основное свойство бинарного дерева выполняется
[50:48.800 --> 50:58.320]  окей намного дольше разве дольше будет если мы просто поставим девятку потом мы сделаем поворот
[50:58.320 --> 51:08.800]  это здесь можно так сделать а дальше ну в плане у нас у нас понимаем его до корня это не очень
[51:08.800 --> 51:17.200]  выгодно с точки зрения времени почему потому что мы будем добавлять элементы постоянно куда-то в
[51:17.200 --> 51:23.360]  даль то есть смотрите мы будем ставить не на их место где они могут быть по факту а мы их
[51:23.360 --> 51:29.000]  пытаемся в листы запихать и вот первоначально когда мы с вами говорили мы это и делали то есть
[51:29.000 --> 51:34.000]  мы всегда добавляли в листы после чего там либо либо просто в обычном бинарном дереве поиска
[51:34.000 --> 51:41.160]  ничего не делали либо мы пытались что-то с этим делать как ввл дереве и перебалансировали здесь
[51:41.160 --> 51:51.280]  же другая ситуация давайте будем вставлять сюда вершины в нужное им место хорошо вот тогда в
[51:51.280 --> 52:00.040]  этом случае ну сам по себе сплит будет работать очень очень быстро по сути мы с вами говорим
[52:00.040 --> 52:05.800]  следующее он тоже рекурсивный здесь будет три случая когда у нас корень больше меньше или
[52:05.800 --> 52:12.280]  или равен как раз-таки необходимы нам дерево давайте их просто распишем и условия остановки рекурсии
[52:12.280 --> 52:19.720]  у меня здесь будет код эти вот ну как это снизу вверх ну то есть скакать немножко но здесь будет
[52:19.720 --> 52:27.520]  отдельный случай первый случай если бы у девятки было там левое под дерево еще то как бы мы поделили
[52:27.520 --> 52:34.760]  дерево а где у девятки левое если бы оно было у нее или мы бы в принципе не использовали когда
[52:35.160 --> 52:45.240]  у нас девятки в принципе нет мы пытаемся найти ее место если в десятке было левое по дереву там
[52:45.240 --> 52:54.200]  должно было быть все больше чем дейм если бы в восьмерке был бы родители допустим 12 куда куда
[52:54.200 --> 53:01.840]  подожди куда я вставлю твое ну в смысле вот сюда ну да если был бы родители тогда сплит будет
[53:02.200 --> 53:11.600]  он разделит эти деревья все равно каким образом то есть какое дерево у нас будет в итоге у нас
[53:11.600 --> 53:25.280]  будет 12 10 и 11 понятно то есть она 12 вот есть 11 но вообще в этом случае в этом случае он
[53:25.280 --> 53:37.440]  ставится не сюда а вот сюда девятка встанет сюда вместо 11 будет 12 мы захотим ставить 11
[53:37.440 --> 53:47.160]  что еще раз если вместо 11 у нас будет 12 мы захотим ставить один то есть у нас при разделении
[53:47.160 --> 53:58.080]  ну у нас не положили такой идеальной ситуации что вот она одна да и мы хотим ставить 11 тогда
[53:58.080 --> 54:12.800]  в этом случае у нас будет следующее у нас будет 10 8 7 6 4 12 11 соединяем получаем вот так и такое
[54:12.880 --> 54:19.760]  предполагаю что мы будем делать с помощью сплей еще раз разделение будет приходить
[54:19.760 --> 54:29.200]  помещу сплит не с помощью сплэй ну в смысле чтобы сделать вот эту ветвь от 8 к 10 и чтобы 10 стало
[54:29.200 --> 54:37.800]  баррентом чтобы 10 стало корнем будем использовать видимо сплэй да ну ладно зачем нам 10 корнем если
[54:37.800 --> 54:47.640]  я вставляю 11 но так у нас сейчас получается что 10 это ну она не корень если просто соединим
[54:47.640 --> 54:57.320]  12 у нас 10 получается не корень а ой я понял почему все это да ссоре я неправильно здесь нарисовал
[54:57.320 --> 55:14.240]  вот вот но в этом случае я а что что что не так то есть мы будем условно говоря выпрямлять
[55:14.240 --> 55:23.360]  10 или мы просто к 8 все я понял какой вопрос все хорошо нет мы будем просто делить деревья так
[55:23.360 --> 55:30.320]  чтобы мы могли вот встать нужное нам место то есть смотрите мы оставляем корнем то что тут было
[55:30.320 --> 55:39.200]  просто вот всю часть которая слева мы отдаем все также восьмерки а все что является корнем вот
[55:39.200 --> 55:46.280]  этого правого кусочка говорим что новое дерево любое дерево когда мы вот так вот его рисуем
[55:46.280 --> 55:59.440]  можно спустить на этот на прямую правда все согласны да вот я думаю вы к этому уже привыкли
[55:59.440 --> 56:11.080]  представьте следующее вот и что мы будем делать когда мы делаем сплит когда мы делаем сплит то
[56:11.080 --> 56:16.440]  мы к примеру вот хотим ставить сюда тогда мы оставляем вот этот корень и вот этот новый
[56:16.440 --> 56:23.480]  корень у правого по дереву то есть мы начинаем разъединять деревья в случае если мы можем
[56:23.480 --> 56:29.480]  ставить но вот это вот грубо говоря ребро вот сюда нашу вершинку и вместо одного ребра сделать
[56:29.480 --> 56:36.440]  вот так два понятно вот так работает сплит он вернет мне два корня и мне нужно будет их только
[56:36.440 --> 56:52.560]  подсоединить если в моем примере он вернет 12 8 да я понял окей давайте с вами опишем
[56:52.560 --> 56:59.920]  общий сплит как это выглядит просто рекурсивно это достаточно просто если чтобы быть у меня есть
[56:59.920 --> 57:07.360]  функция сплит все что в нее передается это корень и ключ по которому мы хотим разъединить
[57:07.360 --> 57:16.560]  наше дерево вот условия ну когда у нас будет корень нулевой то в этом случае мне нужно вернуть
[57:16.560 --> 57:27.040]  нулевой и нулевой как реализовывается с помощью плюсов ну реализуйте структуру где будут храниться
[57:27.040 --> 57:40.560]  два корни вот после чего мы с вами говорим что корень у нас будет равен найти корень но найти
[57:40.560 --> 57:48.640]  в нашем дереве вообще где должен лежать наш ключ вот после чего мы говорим что если у нас
[57:48.640 --> 57:57.640]  рут рут за счет того мы что мы все там уже перебросили внутри у нас файндижестой работал
[57:57.640 --> 58:05.920]  а вот а ой да кстати я понял вислав я понял что вы имели в виду видимо опять
[58:05.920 --> 58:18.600]  правильный ли я имею ввиду а что вернет сплит вот здесь правильно 8 или 10 да смотрите при
[58:18.600 --> 58:26.120]  условии когда у нас будет работать сплит мы будем говорить следующее что если у нас там рут ну корень
[58:26.120 --> 58:37.160]  рута равен самому ключу то в этом случае мы будем устанавливать давайте так объясню
[58:37.160 --> 58:45.160]  сет перинт но здесь мы просто зафиксируем сейчас давайте я расскажу и объясню тогда уже до конца
[58:45.160 --> 59:08.960]  что происходило сет перинт от рута левт и там нал сет перинт отрут и нал ну то есть мы просто
[59:08.960 --> 59:15.280]  фиксируем что здесь нулевое и после чего мы возвращаем с вами возвращаем рут
[59:15.280 --> 59:31.040]  левт и рут рут левый правый его по дереве то есть когда мы будем сплитить по данной по данному
[59:31.040 --> 59:37.040]  ключу мы говорим о том что мы просто разъединяем если у нас ключ равен тогда мы говорим что все
[59:37.120 --> 59:43.280]  корень нам больше такой не нужен у нас есть левый есть правый это пример у границы здесь
[59:43.280 --> 59:54.920]  левт вот если же у нас корень ну ключ корни будет меньше чем ключ сам корень вот этого нового
[59:54.920 --> 01:00:18.760]  дерева то в этом случае мы говорим о том что давайте так райд ровно рут райт рут райт
[01:00:18.760 --> 01:00:35.120]  правен но то есть мы отсоединяем этот правый кусочек пример то есть если мы ключ на ключ
[01:00:35.120 --> 01:00:44.080]  там меньше то мы отсоединяем наш правый кусочек говорим что зафиксируем там родителей для правого
[01:00:44.080 --> 01:00:58.440]  по дереву как нау и возвращаем получается корень и правый кусочек то есть смотрите
[01:00:58.440 --> 01:01:08.600]  первоначально мы с вами что делаем мы с вами ищем ищем туда где вообще должен стать наш ключ
[01:01:08.600 --> 01:01:16.360]  место куда он должен это ну в какое место ему необходимо встать из-за того что мы ищем ключ у
[01:01:16.360 --> 01:01:22.320]  нас работает естественно файн дисплей то есть он переболен ну перефиксирует как-то наше дерево
[01:01:22.320 --> 01:01:30.320]  после чего мы с вами уже как раз таки все начинаем делить здесь благодаря файду вот все что у нас
[01:01:30.320 --> 01:01:37.040]  было оно перенесется в корень то есть все те кусочки которые там меньше больше на чем мы
[01:01:37.040 --> 01:01:46.480]  остановились разве руки не должен быть больше чем кей для того чтобы вернули правую сторону для
[01:01:46.480 --> 01:01:54.000]  того чтобы отделяли мы же смотрите смотрите правое под дерево больше чем кей правильно
[01:01:54.000 --> 01:02:03.840]  а ключ то есть смотрите что я имею ввиду после операции find у нас появилось вот такое вот дерево
[01:02:03.840 --> 01:02:17.480]  да ну вот я так нашел его правда и вот тут вот девятку мне вот 10 здесь 11
[01:02:17.480 --> 01:02:28.200]  девятка у меня становится на вот это вот место правда когда мне необходимо его разделить я
[01:02:28.200 --> 01:02:41.160]  говорю о том что левый правый кусочек рутрайт раин рутрайт то есть все что находится справа а
[01:02:41.160 --> 01:02:49.320]  все что является с корнем 8 когда мы 9 вставляем оно является уже как раз таки необходимым не
[01:02:49.320 --> 01:03:02.040]  дерево сейчас когда ключ корня будет меньше чем девят ну меньше чем необходимое нам число то
[01:03:02.040 --> 01:03:10.840]  мы должны разделить как рут и право его под дерево взять его значениями если наоборот будет
[01:03:10.840 --> 01:03:16.560]  ситуация сейчас мы тоже напишем то там просто наоборот то есть если бы я хотел ставить ну
[01:03:16.560 --> 01:03:23.040]  предположим здесь было бы не 7 просто здесь не было бы ничего я хотел бы ставить 7 то мои бы
[01:03:23.040 --> 01:03:37.320]  возвращаемые сплетом значения были бы 8 и 6 понятно какой еще вопрос а вот мы как писали вот этот
[01:03:37.320 --> 01:03:47.440]  сплей так что он делает только слева ну короче вот почему-то написали все для левой ветки а
[01:03:47.440 --> 01:03:54.480]  для правой не писали практически для правой ретейт у нас есть да да а мы это но а почему именно так
[01:03:54.480 --> 01:04:02.120]  мы делали это чтобы у нас вставала на вот этот корень вершина которая уточни значение которое
[01:04:02.120 --> 01:04:11.960]  самое близкое снизу к нужным или как сейчас я не понял вопроса но короче я так и не
[01:04:11.960 --> 01:04:16.760]  поняла почему вы написали все для левой ветки а для правой написали достаточно ли это для
[01:04:16.760 --> 01:04:28.480]  того чтобы нам найти ответ а вот скажи мне я не ало я лиля ссори да ссори лиля да я знаю достаточно
[01:04:28.480 --> 01:04:35.160]  потому что мы с помощью этих операций можем прийти к вершине сверху правда можем тогда давайте
[01:04:35.160 --> 01:04:40.920]  так и делать и будем некоторые усовершенствования не то что нужно просто поворачивать еще в какой-то
[01:04:40.920 --> 01:04:46.000]  момент поворачивать несколько раз и по-другому сделан для того чтобы у нас дерево как раз таки
[01:04:46.000 --> 01:04:56.840]  пыталась поддержать логарифмическую высоту вот это просто сама так структура вы видите вот
[01:04:56.840 --> 01:05:06.440]  почему так мы сейчас с вами разберемся хорошо окей так давайте допишем сплит у нас к сожалению
[01:05:06.440 --> 01:05:18.040]  мало времени очень грустно все давайте можете пожалуйста пояснить вот запись ретурн и через
[01:05:18.520 --> 01:05:25.280]  я сплит возвращает два дерева все в докладе я напишу т1 т2 если хотите
[01:05:29.000 --> 01:05:33.240]  по факту два указатель он должен вернуть если он хочет вернуть два указатель достаточно
[01:05:33.240 --> 01:05:39.440]  написать структуру которая будет это принимать понятно а как этим последствиям пользоваться
[01:05:39.440 --> 01:05:50.200]  а как нельзя обратиться к полю структуры а ну ладно хорошо спасибо вот у нас
[01:05:50.200 --> 01:05:58.080]  операция find вот где рут равна find отрут и запятая к ей она не может на лп тр и вернуть
[01:05:58.080 --> 01:06:06.200]  она может вернуть на лп тр только в случае когда у нас вершины такой нет
[01:06:06.200 --> 01:06:14.200]  ну смысле вот когда вершина равна нулевой но этот случай мы отдельно рассматривали ну то есть
[01:06:14.200 --> 01:06:20.560]  почему мы специально писали в эфе что мы не пойдем влево если там ничего нет потому что мы
[01:06:20.560 --> 01:06:29.840]  хотим вернуть вершина ближайшую к необходимым нам она может вернуть нау никто не спорит но это
[01:06:29.840 --> 01:06:38.400]  только в случае если я передам вот find рут равный нау который я обработал выше то есть
[01:06:38.400 --> 01:06:45.760]  если у меня дерево пусто пусто то как бы расплитив его я получу два пустых это понятно
[01:06:45.760 --> 01:06:56.640]  на всех остальных случаях вот мы рассматриваем это все а зачем нам else после ретерна потому что
[01:06:56.640 --> 01:07:03.560]  мы не рассмотрели абсолютно все случаи но еще вот сейчас не дописали его что будет когда у нас
[01:07:03.560 --> 01:07:09.480]  ключ корня будет больше нам необходимо вернуть как раз таки левую часть и правую часть поэтому
[01:07:09.480 --> 01:07:26.000]  в этом случае мы говорим что левая пусть у нас там левый равен рут левт и рут левт равняется нау
[01:07:27.520 --> 01:07:31.880]  после чего мы с вами фиксируем наших родителей
[01:07:31.880 --> 01:07:35.120]  до левого
[01:07:35.120 --> 01:07:46.680]  как нау вот и возвращаем левая
[01:07:46.680 --> 01:08:08.880]  левая и корень вот это то что касается сплита понятно ли что это делается что происходит надеюсь
[01:08:08.880 --> 01:08:17.440]  что понятно можно еще раз почему у нас не может быть файн возвращайте но где там приведите
[01:08:17.440 --> 01:08:27.960]  пример какой-то несуществующий элемент который ищем вот все несуществующий элемент тогда в
[01:08:27.960 --> 01:08:36.160]  этом случае он будет делать find find до момента вот какого-нибудь из вот этого и тогда в этом
[01:08:36.160 --> 01:08:40.560]  случае не зайдет return find и у нас останется только лишь с плей мы сделаем с плей в и
[01:08:40.560 --> 01:08:46.160]  закончим типа и начнем раскручивать стек в обратную сторону понятно
[01:08:46.160 --> 01:08:56.920]  спасибо вот таким образом мы с вами получили два дерева мы их расплитили и нам осталось понять
[01:08:56.920 --> 01:09:07.480]  то как работает insert но insert работа достаточно простая давайте сделаем следующее вот у меня
[01:09:07.480 --> 01:09:16.800]  было дерево я его расплитил и получил из них два дерева ну вот у меня было а и б
[01:09:16.800 --> 01:09:28.400]  мы с вами знаю вот здесь я получил два таких дерева я их разбил по ключу кей то есть у меня
[01:09:28.400 --> 01:09:35.560]  получается в левом все меньше ключа кей в правом все больше ключа кей тогда для того чтобы здесь
[01:09:35.560 --> 01:09:44.920]  что-то получить мне достаточно сделать ключом свой корень и тогда у меня будет верное дерево
[01:09:44.920 --> 01:09:55.200]  поиска бинарная то есть в этом случае мы с вами говорим о том что мы insert делаем ну от нашего
[01:09:55.200 --> 01:10:03.600]  корня там и кого-то ключа вот мы хотим ключ вставить вот мы с вами делаем следующее что у нас
[01:10:03.600 --> 01:10:19.120]  левая и правая под дерево равно split от корня и ключа то есть мы разбили на эти
[01:10:19.120 --> 01:10:25.720]  деревья после чего нам необходимо добавить вот этот вот то самый корень и для того чтобы добавить
[01:10:25.720 --> 01:10:35.840]  вот тот самый корень давайте сделаем так что рут но это но да давайте сейчас так сделаем
[01:10:35.840 --> 01:10:50.920]  чуть-чуть по плюсовому напишу что но да рут равна у нее есть там у нас по моему левый правый то
[01:10:50.920 --> 01:11:01.960]  есть для него левый ребенок это левый правый это правый здесь нал а здесь ключ ну просто чтобы
[01:11:01.960 --> 01:11:07.720]  вы поняли что мы делаем корень у которого есть левый кусочек правый кусочек в нем лежит ключ кей
[01:11:07.720 --> 01:11:23.960]  вот после чего мы с вами делаем кипер от корня и возвращаем наш корень то есть смотрите при вставке
[01:11:23.960 --> 01:11:31.360]  мы сделаем так что элемент будет являться корнем вот и все вот таким образом выглядит
[01:11:31.480 --> 01:11:37.720]  есть вопросы консерту а тут получается будет конфликт у нас мы в insert
[01:11:37.720 --> 01:11:51.640]  передаем рут потом мы объявляем новый рут тут как как это пофиксить будет не рут хорошо ладно
[01:11:51.640 --> 01:12:00.880]  все в декот вам явно не нравится окей ну не рутом сделай вот так что мы вот этот
[01:12:00.880 --> 01:12:07.760]  рут который передавали в insert мы после мы после спита не используем не используем ну так почему
[01:12:07.760 --> 01:12:15.080]  мы в него просто его нельзя сконструировать ну по-новому то никак не используем смотрите дело в
[01:12:15.080 --> 01:12:21.600]  том что мы можем вернуть сам корень то есть помните вот ситуацию с восьмеркой вот восьмерка
[01:12:21.600 --> 01:12:29.160]  являлась корнем трогайте вопрос так нельзя она является корнем теперь левого под дерево ну так
[01:12:29.160 --> 01:12:40.520]  мы же перезаписали в лест получается но здесь да здесь правда вот здесь можно так сделать ну как
[01:12:40.520 --> 01:12:48.720]  хотите можно так ну то есть можете здесь просто написать но да не просто рут равно вот это хорошо
[01:12:48.720 --> 01:13:04.920]  если вопросы к вставке нет теперь смотрите а помимо того чтобы разделять деревья иногда их
[01:13:04.920 --> 01:13:12.240]  хорошо бы склеивать между собой это так называемый мерч мерч работает это того что мы берем одно
[01:13:12.240 --> 01:13:20.000]  дерево второе дерево и склеиваем их просто в какой-то вот кусочек как это работает если у нас мы
[01:13:20.000 --> 01:13:31.200]  знаем что у нас в левом ход дерева но у нас есть левый кусок есть правый кусочек а и б то есть
[01:13:31.200 --> 01:13:40.280]  левая и правая для нашей корректной работы ключи дерева левт они меньше чем ключи дерева
[01:13:40.280 --> 01:13:52.760]  вот после чего мы будем брать вершину с наименьшим ключом правого под дерево и тянуть ее наверх вот
[01:13:52.760 --> 01:13:59.440]  и после этого мы скажем мы будем соединять деревья то есть смотрите в этом дереве я нахожу
[01:13:59.440 --> 01:14:15.320]  минимум грубо говоря я нахожу минимум вот после чего я с вами ну нашел этот минимум говорю что
[01:14:15.320 --> 01:14:26.480]  теперь она будет являться корнем для этих двух от деревьев то есть это похоже на то самое удаление
[01:14:26.480 --> 01:14:33.200]  которое нас было там в том же овельдере и в том же обычном бинарном дереве поиска мы находим
[01:14:33.200 --> 01:14:39.040]  минимум мы вставляем его наверх и он будет являться корнем для этих сам по себе мерч пишется еще
[01:14:39.040 --> 01:14:52.080]  быстрее представьте что у нас есть левая и правая под дерево и мы делаем следующее что если у меня
[01:14:52.080 --> 01:15:05.880]  правая равно нулю ну то есть это пустое дерево то в этом случае я верну левая если у меня левая равна
[01:15:11.440 --> 01:15:12.240]  то я верну
[01:15:12.240 --> 01:15:24.040]  после чего мне нужно понять где находится минимум ну минимум достаточно просто можно и
[01:15:24.040 --> 01:15:35.640]  тоже рекурсивно просто вызвать каким образом смотрите мы знаем что вот здесь вот вот здесь
[01:15:35.640 --> 01:15:41.880]  вот все элементы а меньше чем бы поэтому для того чтобы найти вершину а куда нам вообще что
[01:15:41.880 --> 01:15:47.960]  является минимальный здесь можно не писать функцию find минимум который у нас есть а просто написать что
[01:15:53.480 --> 01:16:07.680]  просто написать что райд равно файнт от правого и примеру левт точка техи ключ
[01:16:08.440 --> 01:16:14.280]  поэтому find у нас всегда уйдет самый дальний уголок и найдет как раз таки тот самый минимум
[01:16:14.280 --> 01:16:24.320]  помимо этого find сам по себе что делает он берет увеличивает постоянно ну он сделает так в конце что
[01:16:24.320 --> 01:16:30.720]  у нас сверху будет лежать именно та самая вершинка то есть благодаря зиг зигом зиг загом и просто
[01:16:31.600 --> 01:16:37.480]  у нас все с вами получается так что минимальный элемент стал корнем нашего дерева
[01:16:37.480 --> 01:16:44.580]  prosecut если он минимальный элемент то у него левого дерева нет а если у него левого дерева
[01:16:44.580 --> 01:16:52.100]  нет ну awak кусочка то в этом случае ka потому что нашу самую минимальное ключ тут мило ещё встала
[01:16:52.100 --> 01:16:57.900]  в корень то есть у нас она妳 strains this tree in this case, we can say that we have
[01:16:57.900 --> 01:17:16.900]  У нас для правого дерева левым ребенком станет left.
[01:17:16.900 --> 01:17:23.900]  Ну и после чего тут можно написать set parent.
[01:17:23.900 --> 01:17:29.900]  Parent является right, child является left.
[01:17:29.900 --> 01:17:37.900]  Вот. И вернуть корень нашего под дерево это теперь right.
[01:17:37.900 --> 01:17:41.900]  Вопросы к merge есть какие-нибудь?
[01:17:41.900 --> 01:17:44.900]  Когда мы его используем, ну просто...
[01:17:44.900 --> 01:17:47.900]  Тогда нам понадобится merge, а теперь просто очень забавный факт.
[01:17:47.900 --> 01:17:51.900]  Для того, чтобы у нас все работало и все было хорошо,
[01:17:51.900 --> 01:17:56.900]  и удалялись вершинки каким-то образом, нам достаточно взять,
[01:17:56.900 --> 01:18:00.900]  удалить вершину посередине,
[01:18:00.900 --> 01:18:05.900]  получить распличенные два дерева, после чего их соединить.
[01:18:05.900 --> 01:18:08.900]  Вот. Что в принципе логично.
[01:18:08.900 --> 01:18:12.900]  Поэтому в этом случае достаточно сделать следующее.
[01:18:12.900 --> 01:18:17.900]  Как выглядит erase?
[01:18:17.900 --> 01:18:23.900]  Erase какого-то элемента с корнем и ключом.
[01:18:23.900 --> 01:18:25.900]  Что мне достаточно сделать?
[01:18:25.900 --> 01:18:28.900]  Давайте сделаем следующее, что я делаю root.
[01:18:28.900 --> 01:18:36.900]  равно find от корня и ключа.
[01:18:36.900 --> 01:18:40.900]  После того, как я нашел свой корень,
[01:18:40.900 --> 01:18:43.900]  ну нашел свой ключ, искал свой ключ,
[01:18:43.900 --> 01:18:48.900]  я его поставил в корень своего дерева.
[01:18:48.900 --> 01:18:51.900]  Но он действительно является корнем.
[01:18:51.900 --> 01:18:54.900]  Вот. Потому что в принципе сплей так работает,
[01:18:54.900 --> 01:18:58.900]  что он берет и выкидывает абсолютно все вершинки, корни.
[01:18:58.900 --> 01:19:00.900]  Поэтому дальше можно написать, что...
[01:19:00.900 --> 01:19:14.900]  Давайте я сделаю, что set parent от root left равно нулевому.
[01:19:14.900 --> 01:19:26.900]  set parent от root правого равно нулевому.
[01:19:26.900 --> 01:19:28.900]  А после чего мне необходимо просто...
[01:19:28.900 --> 01:19:32.900]  Ну то есть смотрите, я избавился от корня, так как я нашел ключ.
[01:19:32.900 --> 01:19:34.900]  Я избавился от этого корня.
[01:19:34.900 --> 01:19:38.900]  После чего я делаю вернуть...
[01:19:38.900 --> 01:19:41.900]  Ну то есть у меня erase должен вернуть какой-то корень.
[01:19:41.900 --> 01:19:53.900]  Вернуть merge от root left и root right.
[01:19:53.900 --> 01:19:56.900]  Единственное, что нужно понять, как с памятью работать,
[01:19:56.900 --> 01:19:59.900]  как вы почистите и так далее, я думаю, вы здесь справитесь.
[01:19:59.900 --> 01:20:04.900]  Вот. Ну то есть смотрите, здесь ничего сложного в этом плане нет.
[01:20:04.900 --> 01:20:07.900]  Нам достаточно просто взять, разъединить,
[01:20:07.900 --> 01:20:12.900]  ну точнее вывести сначала нашу вершину к корню,
[01:20:12.900 --> 01:20:15.900]  разъединить по этому корню,
[01:20:15.900 --> 01:20:19.900]  после чего убить у нее родителей.
[01:20:19.900 --> 01:20:22.900]  Ну сказать, что все, ты больше не являешься родителем для своих детей,
[01:20:22.900 --> 01:20:25.900]  хоть ты на них указываешь, они тебя больше не принимают.
[01:20:25.900 --> 01:20:29.900]  То есть мы разделили это дерево и замерзли эти два кусочка.
[01:20:29.900 --> 01:20:32.900]  То есть разделили, замерзли, получили.
[01:20:32.900 --> 01:20:35.900]  Смотрите, сейчас будет 10 минут перерыва.
[01:20:35.900 --> 01:20:38.900]  Продолжение, давайте, 18.07.
[01:20:38.900 --> 01:20:40.900]  Я сейчас посидел, подумал.
[01:20:40.900 --> 01:20:43.900]  Я прошу прощения.
[01:20:43.900 --> 01:20:48.900]  Операция zigzag и операция zigzag, она аналогична в обе стороны.
[01:20:48.900 --> 01:20:50.900]  Вот.
[01:20:50.900 --> 01:20:54.900]  Да, то есть смотрите, если у нас справа, то мы...
[01:20:54.900 --> 01:20:56.900]  Справа дважды идет.
[01:20:56.900 --> 01:20:59.900]  То мы дважды делаем грубо разик-зик.
[01:20:59.900 --> 01:21:04.900]  Если у нас справа сначала правый син, потом левый син,
[01:21:04.900 --> 01:21:06.900]  то это операция zigzag.
[01:21:06.900 --> 01:21:11.900]  То есть я неправильно, некорректно все это сказал в первоначале.
[01:21:11.900 --> 01:21:15.900]  Поэтому просто поймите, что вот эти вот операции
[01:21:15.900 --> 01:21:19.900]  в другую сторону работают аналогично.
[01:21:19.900 --> 01:21:24.900]  То есть zigzag, если бы у меня было другое дерево...
[01:21:24.900 --> 01:21:28.900]  Я правда прошу прощения об этом.
[01:21:28.900 --> 01:21:34.900]  То есть у меня могло быть такой случай.
[01:21:34.900 --> 01:21:40.900]  Ну и тут деревья.
[01:21:40.900 --> 01:21:44.900]  То в этом случае, да, у меня бы тоже получилось, что здесь C сверху.
[01:21:44.900 --> 01:21:46.900]  Вот.
[01:21:46.900 --> 01:21:48.900]  Просто единственное, что в этом случае...
[01:21:48.900 --> 01:21:50.900]  Тут раз, тут два.
[01:21:50.900 --> 01:21:54.900]  Справу у нас получается что будет?
[01:21:54.900 --> 01:21:56.900]  G.
[01:21:56.900 --> 01:21:58.900]  А слева?
[01:21:58.900 --> 01:22:00.900]  Справа C.
[01:22:00.900 --> 01:22:03.900]  Нет, после выполнения всего.
[01:22:03.900 --> 01:22:07.900]  То есть мы сначала должны, смотрите, развернуть это вот сюда,
[01:22:07.900 --> 01:22:09.900]  потом вот сюда.
[01:22:09.900 --> 01:22:12.900]  Поэтому справа у меня будет сначала P, а здесь G.
[01:22:12.900 --> 01:22:14.900]  Такие вот кусочки.
[01:22:14.900 --> 01:22:16.900]  Вот.
[01:22:16.900 --> 01:22:18.900]  Основополагающий, на самом деле, вершин.
[01:22:18.900 --> 01:22:21.900]  Основополагающая штука является как раз таки zigzag.
[01:22:21.900 --> 01:22:26.900]  Почему? Потому что он...
[01:22:26.900 --> 01:22:29.900]  То есть он, грубо говоря, выправляет вот эти вот кусочки.
[01:22:29.900 --> 01:22:31.900]  То есть у нас было здесь как-то много всего.
[01:22:31.900 --> 01:22:35.900]  Он сделал так, чтобы вроде бы плюс-минус похож.
[01:22:35.900 --> 01:22:39.900]  Окей, давайте с вами оценивать вообще время работы.
[01:22:39.900 --> 01:22:41.900]  Смотрите.
[01:22:41.900 --> 01:22:47.900]  В операции raise у нас с вами есть find.
[01:22:47.900 --> 01:22:49.900]  Все остальное за U от единички работает.
[01:22:49.900 --> 01:22:53.900]  Потому что merge сам по себе внутри использует тоже только find.
[01:22:53.900 --> 01:22:55.900]  Все остальное за U от единички.
[01:22:55.900 --> 01:22:57.900]  Правда?
[01:22:57.900 --> 01:23:01.900]  В операции insert у нас есть split.
[01:23:01.900 --> 01:23:07.900]  А split сам по себе внутри использует операцию find только.
[01:23:07.900 --> 01:23:11.900]  Все остальное за U от единички.
[01:23:11.900 --> 01:23:15.900]  Ну, то есть здесь возвращается сразу понятно, что...
[01:23:15.900 --> 01:23:19.900]  Таким образом, нам нужно оценить по факту только лишь find.
[01:23:19.900 --> 01:23:24.900]  Но find внутри себя использует только лишь операцию split.
[01:23:24.900 --> 01:23:29.900]  А сам по себе он работает логарифмически относительно коллектива вершин.
[01:23:29.900 --> 01:23:32.900]  Ну, точнее не логарифмически, а от высоты зависит.
[01:23:32.900 --> 01:23:33.900]  Вот.
[01:23:33.900 --> 01:23:35.900]  И split зависит аналогично.
[01:23:35.900 --> 01:23:37.900]  И таким образом нам необходимо...
[01:23:37.900 --> 01:23:41.900]  Если мы оценим splay, мы оценим абсолютно все.
[01:23:41.900 --> 01:23:42.900]  Вот.
[01:23:42.900 --> 01:23:45.900]  То есть find работает пропорционально глубине.
[01:23:45.900 --> 01:23:47.900]  Splay работает пропорционально глубине.
[01:23:47.900 --> 01:23:50.900]  А все остальное работает за счет этих операций.
[01:23:50.900 --> 01:23:54.900]  Все остальные максимум дают какое-то однообразное...
[01:23:54.900 --> 01:23:57.900]  У от единицы мы можем там все посчитать.
[01:23:57.900 --> 01:23:58.900]  Поэтому нам нужно...
[01:23:58.900 --> 01:24:01.900]  Главное, что оценить, это splay.
[01:24:01.900 --> 01:24:06.900]  Для этого введем понятие ранга и будем работать с методом потенциалов.
[01:24:08.900 --> 01:24:10.900]  Ранг вершины v...
[01:24:10.900 --> 01:24:12.900]  Давайте я буду писать r.
[01:24:12.900 --> 01:24:14.900]  Так легче будет.
[01:24:14.900 --> 01:24:16.900]  r от v.
[01:24:16.900 --> 01:24:20.900]  По факту он равен логарифму...
[01:24:20.900 --> 01:24:25.900]  Количество вершин в поддереве, где корень является v.
[01:24:25.900 --> 01:24:27.900]  c от v...
[01:24:27.900 --> 01:24:49.900]  Количество вершин в поддереве с корнем v.
[01:24:49.900 --> 01:24:51.900]  Это первый момент.
[01:24:51.900 --> 01:24:53.900]  Я надеюсь, там все вернулись?
[01:24:53.900 --> 01:24:54.900]  Да?
[01:24:54.900 --> 01:24:55.900]  Вроде бы да.
[01:24:55.900 --> 01:24:59.900]  Это количество вершин в поддереве с корнем v.
[01:24:59.900 --> 01:25:01.900]  Это первый момент.
[01:25:01.900 --> 01:25:08.900]  А вообще потенциалом нашего дерева t будет являться сумма всех рангов.
[01:25:08.900 --> 01:25:10.900]  По всем вершинам.
[01:25:12.900 --> 01:25:13.900]  Понятно?
[01:25:13.900 --> 01:25:19.900]  То есть, грубо говоря, мы сложим все ранги, вот будет мой потенциал дерева.
[01:25:19.900 --> 01:25:22.900]  У дерева может меняться потенциал каким-либо образом.
[01:25:22.900 --> 01:25:24.900]  Вот.
[01:25:24.900 --> 01:25:28.900]  А что такое v от t?
[01:25:28.900 --> 01:25:30.900]  f от t.
[01:25:30.900 --> 01:25:32.900]  Нет, там сумма...
[01:25:32.900 --> 01:25:37.900]  v от t, v это вершины в дереве t.
[01:25:37.900 --> 01:25:39.900]  Ну, просто вершинки.
[01:25:39.900 --> 01:25:43.900]  Ну, граф g это v и e.
[01:25:43.900 --> 01:25:46.900]  Вот это вот v, это и есть количество вершин.
[01:25:46.900 --> 01:25:47.900]  Понятно?
[01:25:47.900 --> 01:25:51.900]  Просто вершины все, которые входят в это дерево.
[01:25:51.900 --> 01:25:52.900]  Окей.
[01:25:56.900 --> 01:25:57.900]  Вот.
[01:25:57.900 --> 01:26:00.900]  Это то, что мы говорим об этом.
[01:26:00.900 --> 01:26:03.900]  Фактически операция splay работает за высоту.
[01:26:03.900 --> 01:26:08.900]  Потому что она просто вызывается рекурсивно друг от друга, от детей и так далее.
[01:26:08.900 --> 01:26:09.900]  Вот.
[01:26:13.900 --> 01:26:20.900]  И по факту это равно количеству элементарных поворотов, которые будут выполнены в ходе процедуры.
[01:26:20.900 --> 01:26:27.900]  То есть смотрите, когда мы смотрим на высоту, чем ниже лежит вершина, тем больше поворотов мы сделаем.
[01:26:27.900 --> 01:26:30.900]  Элементарные повороты я имею в виду вот именно zig.
[01:26:30.900 --> 01:26:33.900]  То есть просто повернуть лево или просто повернуть право.
[01:26:33.900 --> 01:26:35.900]  То есть left rotate, right rotate.
[01:26:35.900 --> 01:26:37.900]  Просто чтобы вам было понятно.
[01:26:37.900 --> 01:26:39.900]  Вот.
[01:26:39.900 --> 01:26:42.900]  И мы сейчас докажем с вами следующее утверждение.
[01:26:42.900 --> 01:26:44.900]  Утверждение.
[01:26:46.900 --> 01:26:48.900]  Амортизационное.
[01:26:51.900 --> 01:26:52.900]  Цонная.
[01:26:52.900 --> 01:26:54.900]  Сложность.
[01:26:57.900 --> 01:27:02.900]  Операция splay.
[01:27:06.900 --> 01:27:09.900]  От вершины V.
[01:27:13.900 --> 01:27:14.900]  В.
[01:27:14.900 --> 01:27:15.900]  В дереве.
[01:27:16.900 --> 01:27:17.900]  T.
[01:27:18.900 --> 01:27:19.900]  С корнем.
[01:27:23.900 --> 01:27:24.900]  С корнем.
[01:27:26.900 --> 01:27:27.900]  Здесь.
[01:27:27.900 --> 01:27:28.900]  Сейчас я подумаю.
[01:27:28.900 --> 01:27:29.900]  С корнем.
[01:27:29.900 --> 01:27:30.900]  Ну давайте root.
[01:27:30.900 --> 01:27:31.900]  Прям так и напишем.
[01:27:31.900 --> 01:27:32.900]  Root.
[01:27:33.900 --> 01:27:34.900]  Составляет.
[01:27:34.900 --> 01:27:35.900]  Составляет.
[01:27:42.900 --> 01:27:45.900]  Три умножить на R от root.
[01:27:46.900 --> 01:27:48.900]  Минус R на V.
[01:27:49.900 --> 01:27:50.900]  Плюс один.
[01:27:53.900 --> 01:27:54.900]  Смотрите.
[01:27:54.900 --> 01:27:56.900]  Если мы с вами это докажем, то у нас все хорошо.
[01:27:56.900 --> 01:27:57.900]  Почему?
[01:27:57.900 --> 01:28:00.900]  Потому что вот это есть логарифм.
[01:28:00.900 --> 01:28:03.900]  Двоичный от количества вершин N.
[01:28:03.900 --> 01:28:05.900]  Это есть логарифм.
[01:28:06.900 --> 01:28:09.900]  Двоичный от количества вершин V.
[01:28:09.900 --> 01:28:14.900]  Но даже если мы выкинем логарифм двоичный от количества вершин V.
[01:28:14.900 --> 01:28:16.900]  То есть просто не будем учитывать.
[01:28:16.900 --> 01:28:19.900]  То в этом случае мы получим, что это три логарифма плюс один.
[01:28:19.900 --> 01:28:21.900]  А это есть O от логарифма.
[01:28:21.900 --> 01:28:25.900]  То есть у нас амортизационно будет работать все очень быстро.
[01:28:25.900 --> 01:28:27.900]  То есть логарифмически.
[01:28:29.900 --> 01:28:32.900]  И давайте сейчас обсуждать вообще почему так.
[01:28:34.900 --> 01:28:35.900]  Первое.
[01:28:36.900 --> 01:28:38.900]  Из чего складывается доказательство.
[01:28:38.900 --> 01:28:41.900]  Рассмотрим с вами операцию зиг.
[01:28:41.900 --> 01:28:42.900]  Вот.
[01:28:42.900 --> 01:28:45.900]  Я думаю вам не стоит напоминать.
[01:28:45.900 --> 01:28:46.900]  Ну или стоит напоминать.
[01:28:46.900 --> 01:28:47.900]  Давайте скажу.
[01:28:47.900 --> 01:28:51.900]  Что если у нас меняются.
[01:28:54.900 --> 01:28:56.900]  Сейчас скажу как это правильно.
[01:28:56.900 --> 01:29:00.900]  Если у нас с вами меняются потенциалы.
[01:29:00.900 --> 01:29:04.900]  То для нас самое важное начальное и конечное состояние.
[01:29:04.900 --> 01:29:06.900]  А не как то, что было в середине.
[01:29:06.900 --> 01:29:09.900]  То есть то, что было в середине не является для нас необходимостью.
[01:29:09.900 --> 01:29:11.900]  Потому что у нас потенциалы так вычисляются.
[01:29:11.900 --> 01:29:12.900]  То есть у нас есть потенциал.
[01:29:12.900 --> 01:29:14.900]  Начало, потенциал конца.
[01:29:14.900 --> 01:29:17.900]  Вот мы его так подберем, что у нас все будет хорошо.
[01:29:18.900 --> 01:29:19.900]  Вот.
[01:29:19.900 --> 01:29:23.900]  Если вдруг кто не помнит, то обязательно посмотрите лекцию про амортизационный анализ еще раз.
[01:29:24.900 --> 01:29:26.900]  Вот. Разберем каждый поворот.
[01:29:26.900 --> 01:29:27.900]  Начнем зиг.
[01:29:27.900 --> 01:29:29.900]  А что делает зиг?
[01:29:29.900 --> 01:29:31.900]  Вот у нас есть там вершины.
[01:29:31.900 --> 01:29:33.900]  Например, root.
[01:29:35.900 --> 01:29:37.900]  У нас от нее есть v.
[01:29:38.900 --> 01:29:40.900]  И вот здесь вот у нас там есть a.
[01:29:42.900 --> 01:29:43.900]  b.
[01:29:44.900 --> 01:29:45.900]  Здесь вот c.
[01:29:46.900 --> 01:29:48.900]  Вот. И я с вами получаю v'.
[01:29:48.900 --> 01:29:51.900]  Ну я просто так сделаю, чтобы у нас было легче.
[01:29:51.900 --> 01:29:52.900]  root'.
[01:29:53.900 --> 01:29:54.900]  Здесь у нас будет a.
[01:29:55.900 --> 01:29:56.900]  Здесь будет b.
[01:29:57.900 --> 01:29:58.900]  Здесь будет c.
[01:29:59.900 --> 01:30:01.900]  Давайте просто посчитаем потенциалы.
[01:30:02.900 --> 01:30:04.900]  С тем, что у нас с вами вообще было здесь.
[01:30:07.900 --> 01:30:08.900]  Время.
[01:30:09.900 --> 01:30:10.900]  Давайте a.
[01:30:11.900 --> 01:30:12.900]  Оно равно единичке.
[01:30:13.900 --> 01:30:14.900]  Почему единичке?
[01:30:14.900 --> 01:30:15.900]  Потому что зиг занимает один поворот.
[01:30:15.900 --> 01:30:17.900]  Поворот это от единицы.
[01:30:18.900 --> 01:30:19.900]  Это значит будет единица.
[01:30:20.900 --> 01:30:21.900]  Плюс.
[01:30:22.900 --> 01:30:24.900]  Как у нас изменился ранг после этого?
[01:30:26.900 --> 01:30:28.900]  У нас стал ранг всего дерева.
[01:30:29.900 --> 01:30:32.900]  Разность вот этих потенциалов.
[01:30:32.900 --> 01:30:33.900]  Смотрите.
[01:30:33.900 --> 01:30:35.900]  Ранг a как-нибудь изменился.
[01:30:35.900 --> 01:30:38.900]  Потенциал под дерева a как-нибудь изменился.
[01:30:38.900 --> 01:30:39.900]  Как ты думаешь, Антоним?
[01:30:44.900 --> 01:30:45.900]  Думаю, да.
[01:30:45.900 --> 01:30:46.900]  Почему?
[01:30:46.900 --> 01:30:48.900]  Потому что он поднялся вверх.
[01:30:48.900 --> 01:30:49.900]  И что?
[01:30:50.900 --> 01:30:51.900]  Что такое ранг?
[01:30:51.900 --> 01:30:53.900]  Ой, что такое потенциал дерева?
[01:30:56.900 --> 01:30:57.900]  Потенциал дерева?
[01:30:57.900 --> 01:30:58.900]  Не знаю.
[01:30:58.900 --> 01:31:01.900]  Мы только что вводили, что такое потенциал дерева.
[01:31:02.900 --> 01:31:03.900]  Не в основном.
[01:31:05.900 --> 01:31:06.900]  Смотрите, еще раз.
[01:31:06.900 --> 01:31:09.900]  Потенциал дерева – это сумма всех рангов внутри.
[01:31:11.900 --> 01:31:17.900]  Так как у нас количество вершин внутри дерева a никак не изменилось,
[01:31:18.900 --> 01:31:20.900]  то потенциал дерева тоже никак не изменился.
[01:31:23.900 --> 01:31:24.900]  Это понятно?
[01:31:25.900 --> 01:31:27.900]  Сколько было там вершин, столько и осталось.
[01:31:27.900 --> 01:31:28.900]  Для нас это неважно.
[01:31:29.900 --> 01:31:31.900]  Аналогично для b и аналогично для c.
[01:31:33.900 --> 01:31:35.900]  Единственное, что у нас изменило потенциалы,
[01:31:35.900 --> 01:31:38.900]  это вот эти две вершины root и v'.
[01:31:40.900 --> 01:31:41.900]  Поэтому мне достаточно сказать,
[01:31:41.900 --> 01:31:44.900]  что разность потенциалов вот этих двух деревьев,
[01:31:44.900 --> 01:31:46.900]  она будет заключаться в следующем.
[01:31:46.900 --> 01:31:52.900]  Что это ранг от v' плюс ранг от root'
[01:31:53.900 --> 01:31:55.900]  минус ранг от v,
[01:31:56.900 --> 01:32:08.900]  минус ранг от r, получается.
[01:32:09.900 --> 01:32:10.900]  Что-то я от root.
[01:32:13.900 --> 01:32:14.900]  Ранг от root.
[01:32:15.900 --> 01:32:17.900]  То есть смотрите, конечное состояние складывается
[01:32:17.900 --> 01:32:20.900]  из потенциала a, потенциала b, потенциала c
[01:32:21.900 --> 01:32:25.900]  плюс ранг root' и ранг v'.
[01:32:26.900 --> 01:32:29.900]  А первоначальное было из потенциала a,
[01:32:29.900 --> 01:32:33.900]  потенциала b, потенциала c и ранга v и ранга корня.
[01:32:34.900 --> 01:32:36.900]  Ну, потенциала a, b и c они сокращаются.
[01:32:37.900 --> 01:32:39.900]  Получается, у нас изменение потенциала заключено
[01:32:39.900 --> 01:32:41.900]  только лишь вот в этих вот вершинках.
[01:32:42.900 --> 01:32:43.900]  Правильно?
[01:32:43.900 --> 01:32:44.900]  Откуда единичка?
[01:32:45.900 --> 01:32:49.900]  Единичка от того, что мы говорим, что у нас
[01:32:49.900 --> 01:32:51.900]  операция сама по себе занимает какое-то время.
[01:32:51.900 --> 01:32:52.900]  Одно.
[01:32:52.900 --> 01:32:54.900]  Оно работает от единиц.
[01:32:54.900 --> 01:32:56.900]  Нам нужно оценить лишь только find внутри.
[01:33:00.900 --> 01:33:01.900]  Спасибо.
[01:33:01.900 --> 01:33:02.900]  Вот.
[01:33:02.900 --> 01:33:03.900]  Нам нужно оценить.
[01:33:03.900 --> 01:33:05.900]  Ну, то есть сам зиг работает.
[01:33:05.900 --> 01:33:07.900]  Ну, мы перевесили вершины, все хорошо.
[01:33:07.900 --> 01:33:09.900]  Нам интересно, как изменился потенциал.
[01:33:11.900 --> 01:33:13.900]  Единица как раз таки именно от этого.
[01:33:14.900 --> 01:33:15.900]  Окей.
[01:33:15.900 --> 01:33:20.900]  Тогда в этом случае скажите мне, что я могу сократить?
[01:33:20.900 --> 01:33:23.900]  Давайте я спрошу кого-нибудь.
[01:33:23.900 --> 01:33:25.900]  Вот Кирилл Кузнецов.
[01:33:29.900 --> 01:33:33.900]  Сократить в каком смысле?
[01:33:33.900 --> 01:33:35.900]  То есть сократить с минусом имеется?
[01:33:35.900 --> 01:33:38.900]  Ну да, вот у чего-то здесь есть равные ранги?
[01:33:38.900 --> 01:33:47.900]  Ну, вроде как, который root с штрих и v просто.
[01:33:47.900 --> 01:33:48.900]  Разве нет?
[01:33:48.900 --> 01:33:49.900]  Нет.
[01:33:49.900 --> 01:33:52.900]  B и C имеют различное количество вершин.
[01:33:54.900 --> 01:33:55.900]  Смотрите.
[01:33:55.900 --> 01:33:56.900]  Root и v-штрих.
[01:33:56.900 --> 01:33:57.900]  Что еще раз?
[01:33:57.900 --> 01:33:58.900]  Root и v-штрих.
[01:33:58.900 --> 01:34:03.900]  Root и v-штрих, потому что, смотрите, моё дерево не прибавило в количестве.
[01:34:03.900 --> 01:34:07.900]  Здесь количество вершин, то есть C от root.
[01:34:07.900 --> 01:34:08.900]  Чему равно?
[01:34:08.900 --> 01:34:17.900]  Оно равно количество вершин в A плюс B плюс C плюс единичка, которая от V.
[01:34:17.900 --> 01:34:18.900]  V-штрих аналогичный.
[01:34:18.900 --> 01:34:21.900]  Это количество вершин A, B и C плюс root-штрих.
[01:34:21.900 --> 01:34:22.900]  Спасибо.
[01:34:22.900 --> 01:34:23.900]  Вот.
[01:34:23.900 --> 01:34:27.900]  Таким образом мы можем взять и сократить вот эти вот штрихы.
[01:34:27.900 --> 01:34:37.900]  После чего мы с вами получаем, что у нас A и T равно 1 плюс ранг от root-штрих-ранг от v.
[01:34:37.900 --> 01:34:39.900]  А теперь вопрос.
[01:34:39.900 --> 01:34:42.900]  Как-то связаны ранги с рамками?
[01:34:42.900 --> 01:34:43.900]  Ни разу.
[01:34:43.900 --> 01:35:01.900]  А теперь вопрос. Как-то связаны ранги root штрих и v штрих?
[01:35:01.900 --> 01:35:17.300]  связано рангом а или что-то рангом рангом боизвиняюсь вот рангом рангом бы
[01:35:17.300 --> 01:35:28.820]  ну смотрите да первоначально у v штрих сейчас ну то есть не как v штрих больше вершин чем было
[01:35:28.820 --> 01:35:38.260]  чем у root штрих правильно то есть мы можем сказать что вот в этом случае у нас вот вот здесь вот
[01:35:38.260 --> 01:35:47.020]  это меньше либо равно чем ранг от v штрих ну количество вершин просто меньше у r штрих правда
[01:35:47.020 --> 01:36:01.020]  ребята вот отлично хорошо хоть один человек услышал и понял вот таким образом у нас получается
[01:36:01.020 --> 01:36:10.780]  что у нас это меньше либо равно чем ранг от v минус ранг точнее v штрих минус ранг от v что же такое то
[01:36:10.780 --> 01:36:17.340]  что ранг от v это понятно
[01:36:17.340 --> 01:36:26.780]  да а получается что в этом случае мы доказали вот ту самую штуку что аито меньше либо равно чем
[01:36:26.780 --> 01:36:37.780]  3 умножить на ранг v штрих минус ранг v плюс один так
[01:36:40.780 --> 01:36:47.020]  ну мы просто на 3 умножили разность разность точно не отрицательный количество вершин только
[01:36:47.020 --> 01:36:56.020]  увеличилось это понятно чудно тогда давайте дальше теперь проверим с вами зиг зиг
[01:36:56.020 --> 01:37:04.860]  здесь будет уже немного посложнее давайте рассмотрим с вами какой-нибудь дерево
[01:37:04.860 --> 01:37:27.580]  вот пусть у меня есть g потом есть p потом есть v у него здесь а здесь b здесь c здесь d
[01:37:27.580 --> 01:37:35.060]  мы с вами берем зиг зиг что делает он переносит в наверх у нас получится v штрих
[01:37:35.060 --> 01:37:42.340]  v штрих g штрих d c
[01:37:45.540 --> 01:37:55.100]  b и а давайте теперь рассматривать с вами как выглядит как выглядит вообще теперь вот это
[01:37:55.100 --> 01:38:00.380]  самый потенциал так как зиг зиг состоит из двух поворотов то его амортизационная стоимость
[01:38:00.380 --> 01:38:07.860]  это там 2 плюс что-то потому что ой да из двух поворотов мы считаем что поворот один работает
[01:38:07.860 --> 01:38:13.100]  за вот единичку на есть два поворота ну на эти два поворота за два ну каких-то два условных
[01:38:13.100 --> 01:38:23.180]  времени вот поэтому мы можем сказать что аито равно смотрите опять же потенциал под деревьев
[01:38:23.180 --> 01:38:29.500]  а б цд никак не меняется вот ну никак поэтому их мы можем сразу исключить поэтому пишем два
[01:38:29.500 --> 01:38:44.820]  плюс ранг от v штрих плюс ранг от п штрих плюс ранг от п штрих плюс ранг от g штрих
[01:38:44.900 --> 01:38:56.820]  минус ранг от g минус ранг от f минус ранг от v здесь появилось слово
[01:38:56.820 --> 01:39:02.580]  хорошо теперь вопрос что мы опять можем сократить скажи мне пожалуйста миша ри
[01:39:02.580 --> 01:39:20.800]  же и в штрих лично у тебя что-то голос какой-то грустный да мы можем сократить
[01:39:20.800 --> 01:39:29.940]  в штрих и же это мы с вами сократили вот после чего мы с вами можем сказать что еще оценить
[01:39:29.940 --> 01:39:39.220]  некоторые ранки мы с вами знаем что ранг по штрих по штрих меньше либо равен чем ранг
[01:39:39.220 --> 01:39:49.020]  в штрих правильно ну давайте сейчас меньше либо равен чем р от в штрих но потому что в штрих
[01:39:49.020 --> 01:39:58.460]  просто больше у нас вещей вот а здесь минус ранг от п этот ранг от п он больше либо равен
[01:39:58.460 --> 01:40:07.060]  чем ранг от вы но мы его вычитаем поэтому здесь нам достаточно с вами показ мы с вами получаем
[01:40:07.060 --> 01:40:18.300]  что а это будет меньше либо равно меньше либо равно чем получается два плюс ранг от в штрих
[01:40:18.300 --> 01:40:31.980]  плюс ранг от ж штрих минус два ранга от в так может быть ранг в штрих равен рангу по
[01:40:31.980 --> 01:40:41.780]  штрих рангу по штрих да у нас меньше равно написано ну никак но мы можем писать ну как бы
[01:40:41.780 --> 01:40:52.460]  не сильно это убивает равенство хорошо вот это очень большой подгон нам и не нужно сказать что
[01:40:52.460 --> 01:40:59.860]  прям строго меньше нам достаточно показать в другой сторону вот и осталось с вами показать
[01:40:59.860 --> 01:41:07.940]  что вот это для того чтобы мы с вами могли получить ту самую оценку которую мы хотим а
[01:41:07.940 --> 01:41:15.300]  мы с вами хотим получить я все еще напомним следующее что а и т меньше либо равно чем 3
[01:41:17.300 --> 01:41:26.140]  на ранг на ранг получается в штрих минус ранг от в
[01:41:28.900 --> 01:41:36.620]  вот мы хотим все еще получить вот эту вот штуку так как мы все еще хотим вот это вот получить то
[01:41:36.620 --> 01:41:45.900]  давайте с вами докажем что 0 меньше либо равен
[01:41:49.540 --> 01:42:04.300]  минус 2 плюс 2 ранга от ваш 3 минус ранг от ж штрих и минус ранг от в смотрите сложив эти два
[01:42:04.300 --> 01:42:09.380]  неравенства я с вами получу необходимое мне неравенство правда я же могу их сложить просто
[01:42:09.380 --> 01:42:16.660]  я получу 0 здесь 3 здесь 0 здесь 3 вот получу все что нужно давайте докажем вот этот вот кусочек
[01:42:16.660 --> 01:42:28.740]  который мне необходим поехали дальше просто пока все перенесем получим что ранг же штрих у нас
[01:42:28.740 --> 01:42:41.460]  будет ну плюс ранг от вы минус там 2 ранга от в штрих меньше либо равен минус 2 сам по себе ранг
[01:42:41.460 --> 01:42:46.660]  это логарифм от количества если это логарифм от количества то я говорю что вот это у меня
[01:42:46.660 --> 01:43:04.420]  логарифм вот это у меня логарифм от с от в вот это у меня логарифм двоичный от с от в штрих
[01:43:04.420 --> 01:43:14.980]  но количество вершин вот увидев все это мы можем сказать следующее а давайте мы так это и представим
[01:43:14.980 --> 01:43:27.420]  после чего вычтем р в штрих у каждого из этих что такая разность логарифм это да все правильно
[01:43:27.420 --> 01:43:39.220]  таким образом мы с вами получим следующее что у меня будет логарифм логарифм двойки от получается
[01:43:39.220 --> 01:43:55.180]  с ж штрих делить на ц в штрих минус ой плюс логарифм логарифм от ц в штрих делить на ц в штрих
[01:43:55.180 --> 01:44:01.700]  да вот мне нужно показать что это меньше либо равно минус 2
[01:44:01.700 --> 01:44:15.500]  вот а теперь скажите мне очевидно ли вам что с от в штрих больше либо равно чем с от ж штрих
[01:44:15.500 --> 01:44:30.500]  плюс ц от в можете картинку назвать давайте еще смотрите ц от в штрих вот оно вот это оно
[01:44:30.500 --> 01:44:37.580]  содержит в себе все по деревья оба цд в содержит в себе только по деревья оба а ж штрих содержит
[01:44:37.580 --> 01:44:44.140]  только ц и д то есть логично что количество вершин в штрих больше либо равно учитывая что
[01:44:44.140 --> 01:44:52.220]  у него еще еще есть п тоже можно сказать что больше это понятно сейчас стало ясно отлично тогда
[01:44:52.220 --> 01:45:04.500]  мы можем сказать что под логарифмами у нас ну если мы их сложим даже в чем суть а можно сказать
[01:45:04.500 --> 01:45:22.140]  следующее что сейчас момент следующий удивительный факт давайте факт логарифм двоичный от x плюс
[01:45:22.140 --> 01:45:34.740]  логарифм плюс логарифм двоичный от игре меньше либо равен минус 2 если
[01:45:34.740 --> 01:45:50.580]  икс плюс игре меньше либо равно единица икс игре положить вот
[01:45:53.260 --> 01:45:55.620]  давайте так понятен ли этот факт
[01:46:00.220 --> 01:46:03.820]  или непонятен откуда это произошло интуитивно понятен
[01:46:03.820 --> 01:46:09.460]  интуитивно понятен они интуитивно можно строго доказать например рассказав что
[01:46:09.460 --> 01:46:16.500]  икс игре там не больше половины и а произведение их максимально как раз если они по половине вот
[01:46:16.500 --> 01:46:22.420]  ну это почти что да это просто неравенство среднем то есть смотрите для того чтобы
[01:46:22.420 --> 01:46:32.180]  доказать этот факт ну кто-то говорил давайте мы можем что ну мы можем возвести двойку в обе
[01:46:32.180 --> 01:46:39.620]  части этого выражения и получить как раз точности неравенства среднем по сути своей это правда но
[01:46:39.620 --> 01:46:45.580]  я сделал чуть-чуть по-другому я просто возьму занесу это вот так вот икс игре здесь меньше
[01:46:45.580 --> 01:46:50.860]  либо равно минус 2 икс плюс игрек меньше либо равно единице мы знаем о неравенстве
[01:46:50.860 --> 01:46:58.580]  а среднем что мы знаем следующее что а плюс б пополам больше либо равно чем корень из обы
[01:46:58.580 --> 01:47:10.580]  правда а плюс б у нас меньше либо равно единицы следовательно корень ну давайте из икс игрек чтобы
[01:47:10.580 --> 01:47:18.940]  вам легче было икс плюс игрек меньше либо больше либо равно чем икс игрек следовательно
[01:47:18.940 --> 01:47:26.780]  корень от икс игрека будет меньше либо равен чем 1 вторая но возведем в квадрат получим 1 четвертую
[01:47:26.780 --> 01:47:35.620]  сумма логарифмов это логарифм от произведения получаем одну ну 1 четвертый это 2 в степени
[01:47:35.620 --> 01:47:45.020]  минус 2 конец забавный факт закончился таким образом мы с вами получили что просто представив
[01:47:45.020 --> 01:47:50.380]  это уже логарифм и так далее мы с вами получили как раз таки то что нам необходимо было здесь
[01:47:50.380 --> 01:47:59.540]  мы доказали с вами факт что вот это вот это корректно я галочки поставил давайте красный
[01:48:00.060 --> 01:48:08.460]  этот факт коррект а если этот факт корректен то у нас корректен и факт когда мы их сложим то
[01:48:08.460 --> 01:48:26.060]  есть у меня получается что действительности а и т а и т меньше либо равно чем 3 3 умножить на
[01:48:26.060 --> 01:48:39.220]  р от в штрих минус р от в да отлично и остался последний момент который нам
[01:48:39.220 --> 01:48:51.580]  необходимо это zigzag zigzag zigzag примерно также доказывается сейчас мы с вами это быстро сделаем
[01:48:51.580 --> 01:49:00.220]  я надеюсь пусть у меня есть же у него есть п у него есть в здесь у меня там а здесь у меня
[01:49:00.220 --> 01:49:12.180]  бы здесь здесь д финальное что я с вами получаю я получаю следующее в штрих здесь у меня будет
[01:49:12.180 --> 01:49:27.500]  п штрих здесь же штрих здесь а в с и д давайте рассмотрим аналогично тому что мы уже с вами
[01:49:27.500 --> 01:49:33.660]  делали просто разность потенциалов то есть а и т равно 2 2 так как мы делаем два поворота каждый
[01:49:33.660 --> 01:49:46.620]  поворот за от единицу 2 плюс плюс к этому всему получается ранг от в штрих плюс ранг от
[01:49:46.620 --> 01:50:04.300]  ж штрих плюс ранг вот п штрих минус ранг от в минус ранг от п и минус ранг от же но мы сразу
[01:50:04.300 --> 01:50:13.340]  можем сказать что вот это сокращается эти ранги нам больше не нужны так как они являются корнями
[01:50:13.340 --> 01:50:21.820]  у них количество вершин как бы не изменилось в этом плане а теперь давайте посмотрим следующее
[01:50:21.820 --> 01:50:37.260]  у меня ранг п ранг п сам по себе ранг п больше либо равен чем ранг в силу того что у меня
[01:50:37.260 --> 01:50:47.820]  п было корнем в родителем поэтому я говорю что у меня а и т равная 2 плюс ранг от п штрих
[01:50:47.820 --> 01:50:59.740]  плюс ранг от ж штрих меньше либо равно не меньше либо равна ранг от ж штрих минус два ранга от
[01:50:59.740 --> 01:51:10.820]  м вот ну а это доказывается все аналогично тому что было в предыдущем моменте ну то есть то что
[01:51:10.820 --> 01:51:17.380]  у вас было в предыдущем вот аналогично сделайте также 0 меньше либо равно чего-то представьте это
[01:51:17.380 --> 01:51:25.020]  виде лабиритм вы получите то что вам необходимо вот в этом будет вся разница на самом деле то есть
[01:51:25.020 --> 01:51:34.060]  здесь не будет чего-то очень-очень сложного для вас это понятно да чего бы лабы по обществу
[01:51:34.060 --> 01:51:44.300]  субподогнал потенциалы так и работают что они для чего-то выбираются вот и таким образом мы
[01:51:44.300 --> 01:51:52.220]  с вами доказываем что у нас операция с плей сама по себе сама по себе ну ранг любой вершины
[01:51:52.220 --> 01:52:00.740]  ограничен логарифмом размера дерева из этого исследует следующая теорема что ну так как ранг
[01:52:00.740 --> 01:52:10.980]  ограничен что операция с плей амортизационно работает за логарифм понятно то есть логика
[01:52:10.980 --> 01:52:17.340]  здесь следующий мы оценили все операции получили с вами что работает за амортизационно зависит
[01:52:17.340 --> 01:52:24.820]  от ранга ранг зависит от логарифма а значит с плей сам зависит от логарифм можно не учить
[01:52:24.820 --> 01:52:35.820]  все это доказательства в плане написать что осталось заметить что или как что-то типа
[01:52:35.820 --> 01:52:49.540]  хорошо можно вообще не выводить ассимтотики хочет к сожалению к сожалению или к счастью
[01:52:49.540 --> 01:52:54.620]  алгоритмы на то алгоритмы что они должны быть эффективны иначе это будет очень-очень грустно
[01:52:54.620 --> 01:53:09.260]  что практически все за либо логарифм либо смотрите а завершить доказательства можно
[01:53:09.260 --> 01:53:27.460]  следующие образы хорошо осталось заметить осталось заметить что ранг любой вершины
[01:53:34.460 --> 01:53:36.140]  ограничен логарифмом дерева
[01:53:40.260 --> 01:53:43.660]  логарифм размера
[01:53:49.340 --> 01:53:53.980]  дерево следовательно с плей
[01:53:53.980 --> 01:53:58.500]  амортизационно
[01:54:04.380 --> 01:54:06.420]  выполняется
[01:54:10.260 --> 01:54:14.860]  за логарифм
[01:54:17.260 --> 01:54:18.060]  логарифмы
[01:54:20.220 --> 01:54:29.380]  вот это смотрите если вам нужно более четко здесь слово оно работает следующим образом
[01:54:29.380 --> 01:54:36.420]  первоначальный потенциал нашей вершины равен там логарифм двоичный ац и икс правильным
[01:54:36.420 --> 01:54:44.980]  первоначальный потенциал конечный потенциал у нас равен когда она стала вершиной стал равен
[01:54:44.980 --> 01:54:54.700]  логарифм двоичный от n где n это количество вершины что касается количества смотрите
[01:54:54.700 --> 01:55:03.660]  zigzag и zigzag внутри себя ограничены как раз таки вот лишь вот три умножить на
[01:55:03.660 --> 01:55:16.740]  сейчас где это момент они ограничены вот этим но внутри себя ограничен если они ограничены вот этим
[01:55:16.740 --> 01:55:23.260]  то каждый раз когда мы полняем zigzag или zigzag то мы можем сказать что нам играет роль только
[01:55:23.260 --> 01:55:28.500]  начальные конечные значения нас даже не прибавляется здесь никакой плюс единички представьте
[01:55:28.500 --> 01:55:35.180]  я сделал zigzag потом zigzag от этой вершины в этом случае у меня будет 3 на потенциал v 2 штриха
[01:55:35.180 --> 01:55:47.940]  минус 3 потенциал потенциал ранг v штриха плюс 3 потенциал ранг v штрих минус 3 ранга в это означает
[01:55:47.940 --> 01:55:54.380]  что нам играет роль только начальные конечные помимо этого помимо этого наша операция zig просто
[01:55:54.380 --> 01:56:01.220]  она ограничена сверху еще плюс единичкой ну просто плюс единичкой то есть она также три ранга
[01:56:01.220 --> 01:56:12.380]  плюс единичка но операция zig в дереве выполняется единожды максимум один раз а так иногда и 0 а из-за
[01:56:12.380 --> 01:56:18.460]  того что она выполняется один или ноль раз у нас вот эта единица максимум один раз появится в том
[01:56:18.460 --> 01:56:25.300]  когда мы будем складывать поэтому здесь если четко писать то мы получим с вами что test player
[01:56:25.300 --> 01:56:38.180]  равна ну то есть нам по-хорошему нужно вычесть из потенциала начала потенциала конца после
[01:56:38.180 --> 01:56:51.260]  там как давайте конкурс как минус потенциал началом или вон вот так как у нас последнее самое
[01:56:51.260 --> 01:56:59.300]  большое что может увеличить потенциал это равно как раз таки нашему zig потому что на плюс 1 а там
[01:56:59.300 --> 01:57:11.740]  без этого было плюс 1 то мы можем сказать что это три логарифма двоичного от н плюс 1 плюс там
[01:57:11.740 --> 01:57:18.860]  какое-то состояние какое-то которое есть у всех остальных вершин но она будет аналогично тому
[01:57:18.860 --> 01:57:25.260]  что будет феном ну то есть мы вычитаем лишь только то что произошло с нашей вершиной вы минус три
[01:57:25.260 --> 01:57:36.860]  логарифма двоичного от с от нет ну вот все вот то есть если четко то вот таким вот образом
[01:57:36.860 --> 01:57:43.940]  рассуждаются вот он лагерин эмортизационный действительно с плодей он работает так если
[01:57:43.940 --> 01:57:52.540]  к этому всему вопросу как-то по мастерте время быстренько оценить сказать что по
[01:57:52.620 --> 01:58:06.700]  быстренько оценить по мастерте ремы время как-то это нет пожалуйста еще сейчас давай еще раз что
[01:58:06.700 --> 01:58:16.460]  ты хочешь мастер те реме но там есть мастер с которой для для оценки времени работал
[01:58:16.460 --> 01:58:23.420]  не все так работает к сожалению здесь легче всего вести потенциал нелегче я бы сказал
[01:58:23.420 --> 01:58:31.260]  легче ну действительно легче то есть ну просто понять как с ним работать и все я понимаю что
[01:58:31.260 --> 01:58:35.500]  это математическая составляющий алгоритм но алгоритма они действительно в себе ночи такой
[01:58:35.500 --> 01:58:42.220]  характер иначе мы я вам буду говорить но она так работает вот такие да потом придется на
[01:58:42.220 --> 01:58:49.900]  работу начнет что-то писать у вас не работает и вы такие не работает вот так что здесь нужно
[01:58:49.900 --> 01:58:54.980]  оценивать в любом случае что-то с этим делать тоже большая большая наука вот но мы сейчас
[01:58:54.980 --> 01:59:03.060]  переходим достаточно интересным темам давайте перерыв минут пять чтобы вы отошли от
[01:59:03.060 --> 01:59:10.020]  сплей деревьев нас с вами осталось не так много осталось последняя тема считать
[01:59:14.260 --> 01:59:17.260]  и этот блок называется динамическое
[01:59:22.460 --> 01:59:23.260]  программирую
[01:59:23.260 --> 01:59:33.060]  кто из вас вообще представляет что такое он знает
[01:59:33.060 --> 01:59:45.700]  ну я знаю примерно так ну то есть это вот у вас какая-то структура у вас будет начальное
[01:59:45.700 --> 01:59:53.540]  положение и на каждом ну начальное положение там сдается каким-то элементом и на каждом
[01:59:53.540 --> 01:59:58.420]  следующем шаге мы следующий шаг получаем результатом какого-нибудь следующего
[01:59:58.420 --> 02:00:07.700]  получаем там за счет каких-то значений смотрите да динамическое программирование примерно в
[02:00:07.700 --> 02:00:16.340]  этом заключается но на самом деле у динамики есть различные ее виды и то как строится она тоже
[02:00:16.340 --> 02:00:24.380]  бывает по-разному вопрос следующим давайте вопрос такой даже у нас есть динамическое
[02:00:24.380 --> 02:00:30.700]  программирование нам необходимо понять вообще что происходит в принципе задача есть классное
[02:00:30.700 --> 02:00:36.580]  вообще о динамическом программировании можете запомнить и вы поймете в чем тогда его суть
[02:00:36.580 --> 02:00:43.380]  о том что в принципе динамическое программирование это когда у вас есть какая-то есть задача
[02:00:43.380 --> 02:00:49.460]  которая непонятно как решать и мы разбиваем эту задачу на мелкие под задачи которые тоже
[02:00:49.460 --> 02:00:55.100]  непонятно как решать вот примерно в этом суть сама динамического программирования в ней есть
[02:00:55.100 --> 02:01:04.260]  оптимальные решения и в ней есть и в ней есть то как мы их можем применять в принципе
[02:01:04.260 --> 02:01:13.940]  в принципе для какого-то подсчета то есть есть перекрывающиеся дач то есть то что нам необходимо
[02:01:13.940 --> 02:01:23.660]  в динамическом программировании вообще это первая оптимальность решения оптимальность
[02:01:25.100 --> 02:01:35.700]  решение что так что подразумевается под оптимальностью решения то что у нас в принципе
[02:01:35.700 --> 02:01:44.820]  сама по себе задача решается подсчетом из других оптимальных под задачу вот оптимальные имеется
[02:01:44.820 --> 02:01:52.620]  в виду то есть здесь стоит такая некоторая задача оптимизации назовем назовем так о том что должно
[02:01:52.660 --> 02:01:59.940]  все работать быстро классно круто и так далее но более формально формально то что
[02:01:59.940 --> 02:02:17.860]  оптимальное решение оптимальное решение но звучит она так что оптимальное решение решение содержит
[02:02:17.860 --> 02:02:27.340]  содержит оптимальное решение
[02:02:34.020 --> 02:02:34.700]  решение
[02:02:34.700 --> 02:02:49.220]  вот задача вот это вообще принцип оптимального решения помимо этого
[02:02:49.220 --> 02:02:56.740]  если мы рассматриваем рекурсивные чаще всего динамическое программирование это больше про
[02:02:56.740 --> 02:03:03.900]  рекурсию обращение к предыдущим элементам и так далее то в этом случае у такой вот
[02:03:03.900 --> 02:03:09.180]  некоторые задачи подсчета имеются перекрывающейся задачи и вот если у нас
[02:03:09.180 --> 02:03:17.260]  есть перекрывающих задач то мы должны сохранять предыдущие значения то есть второе это перекрывающиеся
[02:03:17.260 --> 02:03:32.900]  задачи это первое что нужно понять про динамику следующие что нужно знать про динамику это виды
[02:03:32.900 --> 02:03:48.780]  виды динамики существует три вида динамики мы сейчас их все рассмотрим первый вид первый вид
[02:03:48.780 --> 02:03:55.260]  динамики это прямая динамика ну порядок пересчета так называем это не то что виды динамики хорошо
[02:03:55.260 --> 02:03:57.940]  скобочках порядок пересчет
[02:04:03.500 --> 02:04:08.900]  сейчас мы поймем это на примере какой-нибудь очень-очень простой задачки первое это прямой
[02:04:08.900 --> 02:04:21.180]  порядок прямой порядок второе это обратный
[02:04:29.620 --> 02:04:35.060]  и последний который есть от ленивый ленивая динамика
[02:04:38.900 --> 02:04:48.780]  мне скажет самую простую задачу на динамику наверное с ленивый динамик
[02:04:48.780 --> 02:05:01.220]  самую простую саму задачу бы постановка задачи найти какое-то число фибоначи да то есть смотрите
[02:05:01.220 --> 02:05:12.620]  числа фибоначи числа фибоначи это прямой посыл к тому что не нужно сделать просто так
[02:05:12.620 --> 02:05:17.740]  рекурсию вы с вами точно с вами разбирали на рекурсиях на функциях о том что делать так
[02:05:17.740 --> 02:05:24.220]  плохо и так делать нельзя вот вообще как выглядит прямой порядок давайте вот сейчас
[02:05:24.220 --> 02:05:28.500]  будем решать числа фибоначи с помощью типа вот всех всех порядков пересчета вы поймете в
[02:05:28.500 --> 02:05:33.780]  чем их разница прямой порядок говорить следующее вот у меня были предыдущие какие-то значения и
[02:05:33.780 --> 02:05:48.220]  я их ставил свое новое то есть это старые старые значения это новое что под этим подразумевается
[02:05:48.220 --> 02:05:54.100]  тогда в этом случае прямой порядок с точки зрения чисел фибоначи будет выглядеть следующим
[02:05:54.100 --> 02:06:03.300]  образом ну пусть у меня там есть массив какой-то f и так далее я скажу что f от нуля к примеру
[02:06:03.300 --> 02:06:18.220]  равен нулю f от единицы равен хотя давайте ну хотя так будет f от единицы равен единице после чего
[02:06:18.220 --> 02:06:30.340]  мы с вами просто напишем цикл for и равная нулю и меньше там и и равная 2 и меньше чем там какое-то
[02:06:30.340 --> 02:06:39.220]  число n до которого мы хотим найти число фибоначи и в этом случае мы скажем что f от и равно f от
[02:06:39.220 --> 02:06:49.420]  и минус 1 плюс f от и минус 2 обычный подсчет числа фибоначи вот то есть обычный вид то как это
[02:06:49.420 --> 02:06:56.500]  выглядит в принципе что такое обратный порядок обратный порядок это когда у меня есть какое-то
[02:06:56.500 --> 02:07:05.380]  значение и оно обновляет очень много там различных предыдущих значений не предыдущих а просто оно
[02:07:05.380 --> 02:07:12.540]  влияет на них как это выглядит с точки зрения чисел фибоначи вот вы сейчас поймете в чем будет
[02:07:12.540 --> 02:07:22.300]  принципиальная разница пусть у меня также f от нуля равно нулю f от единицы равно единицы после
[02:07:22.300 --> 02:07:34.020]  чего мы говорим for и равная 2 и меньше n плюс плюс и а здесь кстати мне здесь надо с нуля
[02:07:34.020 --> 02:07:54.780]  ссоре мы говорим следующее что у меня f от и плюс 1 f от и плюс 1 равно ну плюс равно f от
[02:07:54.780 --> 02:08:06.540]  и и f от и плюс 2 равно плюс равно f то есть смотрите я как бы когда получил какое-то свое значение
[02:08:06.540 --> 02:08:12.380]  сразу его закидываю дальше то есть сразу беру и считаю то есть есть первый способ когда я просто
[02:08:12.380 --> 02:08:17.700]  на основе предыдущих есть второй способ когда мы делаем вот таким вот образом и последний
[02:08:17.700 --> 02:08:23.220]  способ это ленивая динамика ленивая динамика заключается чаще всего в рекурсии и выглядит
[02:08:23.220 --> 02:08:32.340]  следующим образом пусть у меня есть там какая-нибудь функция фи фибоначи от и мы говорим следующее что если
[02:08:32.340 --> 02:08:47.900]  и меньше равно ладно давайте так равно нулю то вернуть ноль если и равно единицы то вернуть
[02:08:47.900 --> 02:09:02.140]  то вернуть один я сейчас продолжу тут писать после чего мы сделаем еще одну вот это вот
[02:09:02.140 --> 02:09:08.740]  ленивая штука которая как раз таки нам спасет что у нас есть все-таки массив f где-то ну пусть
[02:09:08.740 --> 02:09:22.780]  глобально я напишу что если у меня в массиве f от и равно оно равно точнее да равно равно не
[02:09:22.780 --> 02:09:28.980]  равно sorry минус 1 то есть мы посчитали у нас все заполнено минус единичек мы первоначально мы
[02:09:28.980 --> 02:09:42.180]  не посчитали это все то я верну число фибоначи от и а иначе я говорю что f от и равно фибоначи
[02:09:42.180 --> 02:09:58.020]  от и минус 1 плюс фибоначи от и минус 2 вот это у меня формула подсчета ну и вернуть надо
[02:09:58.060 --> 02:10:06.140]  то есть смотрите вот вся ленивый здесь заключена в следующем мы не хотим думать когда нам нужно
[02:10:06.140 --> 02:10:12.620]  считать так далее вот она ленивый я называю это в кавычках ленивостью но это так называемая
[02:10:12.620 --> 02:10:20.660]  ленивая динамика которая действительно это понятно вот разница обратно прямого порядка
[02:10:21.260 --> 02:10:30.660]  да новые новые мы меняем на основе того что мы только что узнали о старом
[02:10:30.660 --> 02:10:39.860]  а новые меняем только когда пришли к ним а здесь я наоборот да давайте еще раз пас
[02:10:39.860 --> 02:10:48.020]  ленивую как именно тем что мы рекурсии использовали что тем что смотрите я не хочу задуматься когда
[02:10:48.020 --> 02:10:54.100]  мы начнем считать что-то там и так далее но то есть у меня здесь цикл я явно начинаю считать
[02:10:54.100 --> 02:11:03.580]  чего-то правда ну прям явно и ты я понимаю когда а здесь я не знаю типа что у меня подсчитано
[02:11:03.580 --> 02:11:08.780]  что не почитано с какой стороны подсчитано и так далее я написал установки рекурсии написал
[02:11:08.780 --> 02:11:14.980]  саму формулу подсчета но так как я не могу идти полностью в рекурсию так как вы знаете что там
[02:11:14.980 --> 02:11:21.180]  будет иначе все плохо я скажу что если мы еще не подсчитали предыдущий шаг тогда подсчитаем если
[02:11:21.180 --> 02:11:31.900]  мы его уже считали тогда не буду считать понятно это неформальный вообще такая штука есть то есть
[02:11:31.900 --> 02:11:37.740]  как ленивая динамика действительно есть вот просто она не то чтобы прям очень часто типа вот
[02:11:37.740 --> 02:11:45.100]  прям формально мы с ней будем работать понятно а получается в обратном порядке у нас как бы
[02:11:45.100 --> 02:11:55.180]  из нового следует старая как бы из нового из в обратном порядке мы сразу же кидаем в новое то
[02:11:55.180 --> 02:11:59.940]  есть смотрите я не говорю о том что я не знаю что там будет впереди и минус первое наступит нет
[02:11:59.940 --> 02:12:10.220]  но я все равно кидаю сразу сбрасываю вперед ну просто поймите в чем разница то есть я на
[02:12:10.220 --> 02:12:18.700]  этом шаге здесь сразу прокидываю это вперед а там я не не трогаю и ты шаги которые до этого будет
[02:12:18.700 --> 02:12:29.740]  понятно да вот это первая такая вот задачка на ней я думаю вы понимаете что оптимальность
[02:12:29.740 --> 02:12:36.420]  решение заключается в том чтобы первое хранить значение все предыдущие вот и мы используем как
[02:12:36.420 --> 02:12:41.820]  раз таки эти значения которые были посчитаны предыдущих шагов вот она задача вот она сама
[02:12:41.820 --> 02:12:50.140]  динамика которая нам говорит да это действительно динамик это понятно пока что давайте тогда
[02:12:50.140 --> 02:12:56.260]  разберемся со следующей задачей следующая задача скорее всего вам известная это черепашка
[02:12:56.260 --> 02:13:05.980]  черепашка прям так называется эта задача в чем она заключается задача заключается в следующем
[02:13:05.980 --> 02:13:23.380]  представьте у меня есть какое-то поле какое-то поле и у меня черепашка не знаю умеет ходить
[02:13:23.380 --> 02:13:30.220]  только вниз и вправо скорее всего если кто-нибудь занимался что-то вроде олимпиадной
[02:13:30.220 --> 02:13:40.140]  прогой он с таким вот сталкиваться то есть наверное может быть вот во всей табличке там
[02:13:40.140 --> 02:13:51.780]  расставлены какие-то числа 3 4 5 8 0 1 3 4 ну и так далее черепашка может двигаться только вниз и
[02:13:51.780 --> 02:14:06.420]  вправо она находится первоначально вот здесь вот а вот ей нужно добраться до конца вот и задача
[02:14:06.420 --> 02:14:12.380]  иногда заключается по-разному либо минимальный либо найти путь при котором там будет минимальные
[02:14:12.380 --> 02:14:19.780]  проблемы либо наоборот максимальные сумма чисел которые мы собирали то есть грубо говоря если
[02:14:19.780 --> 02:14:25.220]  черепашка золотоискатель то она будет собирать монетки по максимуме если у нас черепашка
[02:14:25.220 --> 02:14:31.060]  боится там не знаю других черепашек то и нужно пройти по пути на три пашка социофоб например
[02:14:31.060 --> 02:14:36.860]  не знаю то она будет проходить по клеточкам где будет меньше людей типа суммарно чтобы
[02:14:36.860 --> 02:14:43.260]  меньше с кем-то видеться вот ну может там боится вот зависимости от этого будет задача к примеру
[02:14:43.260 --> 02:14:49.260]  по-разному и как эта задача решается нам нужно понять в конце к примеру сколько монеток этот
[02:14:49.260 --> 02:14:58.860]  черепашка соберет вот кто понимает как это можно решать точнее какой первый случай как это
[02:14:58.860 --> 02:15:11.420]  вообще выглядит это выглядит тем что это выглядит тем что у нас в принципе эта задача включена в
[02:15:11.420 --> 02:15:18.220]  каком-то диком переборе что не очень круто но здесь можно использовать как раз таки то что мы
[02:15:18.220 --> 02:15:25.380]  возьмем и будем динамически что-то строить так как мы можем ходить только вправо и вниз то мы
[02:15:25.380 --> 02:15:32.460]  никогда не вернемся к предыдущим клеточкам я думаю вы это прекрасно понимаете то есть нельзя
[02:15:32.460 --> 02:15:39.620]  вернуть там вверх именно поэтому эта задача как раз таки а перекрестных вот таких вот подзадачах
[02:15:39.620 --> 02:15:45.220]  которые мы будем брать за основу но никак следующее не будет влиять на предыдущий то есть
[02:15:45.380 --> 02:15:54.020]  один раз посчитали то все давайте пусть у нас будет задачка где мы будем как раз таки искать
[02:15:54.020 --> 02:16:02.060]  минимальный путь минимальную стоимость пути что мы сделаем мы с вами возьмем и построим аналогичную
[02:16:02.060 --> 02:16:15.140]  табличку аналогично табличку вот и давайте здесь сейчас что-нибудь еще до запомним до конца
[02:16:15.140 --> 02:16:32.780]  4 здесь два один один вот раз два три четыре пять шесть здесь
[02:16:32.780 --> 02:16:45.900]  вот мы с вами получили вот такую вот там табличку первоначально мы говорим что ну
[02:16:45.900 --> 02:16:54.420]  черепашка ну кого-либо встретила например а вот она может двигаться только направо и вниз поэтому
[02:16:54.420 --> 02:16:59.780]  здесь мы можем точно сказать что делать если мы хотим попасть вот в эту точку мы можем идти
[02:16:59.780 --> 02:17:07.820]  только направо то есть заполним верхний наш массивчик это будут наши начальные условия то
[02:17:07.820 --> 02:17:14.900]  есть здесь будет 5 потом будет 5 мы хотим найти стоимость пути минимальная здесь будет 9 здесь
[02:17:14.900 --> 02:17:28.580]  будет 12 здесь будет 16 если что перепроверяйте меня на всякий случай здесь нас будет 3 5 6 7 ну то
[02:17:28.580 --> 02:17:35.260]  есть вправо мы можем только лишь пойти вправо вниз мы можем только вниз пойти а теперь смотрите
[02:17:35.260 --> 02:17:41.900]  я могу попасть в эту клетку вот в эту клетку которая у меня сейчас такой бордовой звездочкой
[02:17:41.900 --> 02:17:56.500]  только лишь сверху или слева правильно вы согласны с этим надеюсь согласны вот поэтому мы будем
[02:17:56.500 --> 02:18:04.420]  выбирать ту клетку где у нас было меньше ну та клетка где у нас суммарная стоимость была меньше
[02:18:04.420 --> 02:18:10.180]  это слева поэтому мы пойдем слева и когда придем в эту клетку нам все равно придется
[02:18:10.180 --> 02:18:14.620]  добавлять ту стоимость которая есть в этой клетке поэтому здесь у нас будет написано уже 7
[02:18:14.620 --> 02:18:24.020]  аналогично заполняем другую клетку здесь у нас 7 и 5 нам легче прийти из 5 сверху но здесь
[02:18:24.020 --> 02:18:32.820]  там стоимость там 8 поэтому здесь будет 13 и так далее мы заполняем вот так вот построчно все
[02:18:32.820 --> 02:18:38.700]  что у нас с вами есть и если нам нужно дойти до конца то суммарная стоимость будет лежать вот
[02:18:38.700 --> 02:18:52.460]  в этой красной клетке есть ли к этому вопроса а это как бы в любом случае в любом обходе так
[02:18:52.460 --> 02:19:03.300]  будет в смысле в любом обходе мы как мы мы считаем клетку как сумму в левой и верхней правильно либо
[02:19:03.300 --> 02:19:09.300]  левой либо верхней плюс самую ее то есть смотрите формула для заполнения все этой
[02:19:09.300 --> 02:19:25.100]  таблички следующая что у нас а там и та житая равно минимум из а и минус первая житая то есть
[02:19:25.100 --> 02:19:32.140]  когда мы на строчку вышли то есть сверху пришли либо а от и та но же минус первая
[02:19:32.140 --> 02:19:44.780]  плюс плюс а и та житая ой ну не а хорошо вот это массив а вот этот массив стоимости ц хорошо
[02:19:44.780 --> 02:20:02.900]  плюс ц и та житая понятно вот ну то есть мы приходим с одной из двух сторон отлично кто
[02:20:02.900 --> 02:20:12.700]  понимает как можно восстановить путь ну можно запоминать в каждой клетке из какого мы пришли
[02:20:13.260 --> 02:20:27.340]  а можно без этого как-то вы читайте потом искать клетку с полученным значением можно так но скажите
[02:20:27.340 --> 02:20:37.340]  я же в любом случае приду либо отсюда либо отсюда да не в то читать минимальный да достаточно
[02:20:37.340 --> 02:20:43.660]  здесь просто посчитать минимальные элементы с двух и мы туда пойдем то есть здесь даже не
[02:20:43.660 --> 02:20:48.220]  нужно ничего вы читать или что-то делать здесь достаточно просто вот так вот пройтись по минимумам
[02:20:48.220 --> 02:20:56.860]  понятно вот но обязательно с конца потому что если пойдете сначала не факт что придете вообще к концу
[02:20:56.860 --> 02:21:03.820]  правильной вот поэтому как-то так то есть мы начинаем раскручиваться с конца мы пришли с
[02:21:03.820 --> 02:21:10.300]  минимальной клетки ну к примеру вот отсюда если мы пришли с нее тогда мы могли прийти к примеру
[02:21:10.300 --> 02:21:16.820]  вот отсюда вот так мы сходили потом вот так ну и так далее рано или поздно все равно придете
[02:21:16.820 --> 02:21:27.220]  здесь к началу ясно как это работает ой я здесь неправильно нарисовал но да
[02:21:33.220 --> 02:21:40.580]  вот именно так работает наша черепашка это пока тоже самая простая задача и видимо
[02:21:40.580 --> 02:21:50.340]  сегодня мы с вами разберем еще одну одну задачу наверное если мы успеем задача звучит
[02:21:50.340 --> 02:22:04.900]  следующим образом давайте что-нибудь сотру пример вот это дача звучит следующим образом требуется
[02:22:04.900 --> 02:22:16.380]  требуется найти количество разложений
[02:22:20.940 --> 02:22:22.460]  количество разложений числа
[02:22:24.780 --> 02:22:28.460]  n на различные
[02:22:33.340 --> 02:22:34.140]  слагаемые
[02:22:34.900 --> 02:22:47.140]  вот что под этой задачей подразумевается например если у меня число n равно 7 то я
[02:22:47.140 --> 02:23:01.900]  7 могу представить в следующем виде 7 3 плюс 4 там 2 плюс 5 1 1 плюс 6 и 1 плюс 2 плюс 4
[02:23:05.900 --> 02:23:16.220]  и вот мне нужно что еще раз звучит как комбинаторная задача неправда она динамическая тут ведь не все
[02:23:16.220 --> 02:23:22.300]  разложение написано а с точностью до перестановок хорошо так скажу
[02:23:22.300 --> 02:23:33.020]  а все я понял вот насколько слагаемых как бы на любое количество тогда почему-то
[02:23:33.020 --> 02:23:42.140]  нету например семи единиц я так понимаю месяц различные слагаемые различные но это
[02:23:42.140 --> 02:23:51.140]  можно с помощью таблички там сделать 1 2 3 4 5 6 7 плюс единицы и переходить считать сумму как-то так она
[02:23:51.140 --> 02:23:59.380]  делает примерно как-то так смотрите там есть два способа расскажу один второй я наверное попрошу
[02:23:59.380 --> 02:24:06.340]  чтобы вам рассказали на семинаре пусть у меня есть состояние динамики состояние динамики
[02:24:06.340 --> 02:24:16.460]  следующая dp от n как это количество количество разложений
[02:24:16.460 --> 02:24:23.300]  разложений числа n
[02:24:26.300 --> 02:24:27.060]  на числа
[02:24:31.420 --> 02:24:35.740]  меньше либо равные как вот
[02:24:36.340 --> 02:24:43.780]  давайте с вами сделаем эту динамику смотрите первое что есть нам необходимо
[02:24:43.780 --> 02:24:47.300]  начальное состояние динамики начальное состояние
[02:24:51.740 --> 02:25:01.140]  начальное состояние достаточно простой как я могу разложить число один из одного элемента
[02:25:01.140 --> 02:25:10.580]  ну не больше чем к числа не больше чем к одним способом один это один нули у нас нет вот
[02:25:10.580 --> 02:25:14.300]  а разложить это
[02:25:16.940 --> 02:25:24.980]  другим способом то есть у нас здесь без повторений считается dp от n и и от единицы и и sorry единицы
[02:25:24.980 --> 02:25:34.500]  это количество получить предыдущий элемент плюс еще единицы это нули но здесь смотрите
[02:25:34.500 --> 02:25:41.940]  в этом случае но вот это наши начальные значения тогда формула подсчета выглядит следующим
[02:25:41.940 --> 02:25:52.500]  образом я сделаю там for и равная единицы и меньше чем к плюс один
[02:25:52.500 --> 02:26:08.060]  плюс плюс и я скажу что dp от n как это равно dp
[02:26:08.180 --> 02:26:23.940]  вот n минус и на и формула подсчета я имею ввиду для n того числа не то что она
[02:26:23.940 --> 02:26:33.420]  заполняет все все все а вот просто для n того числа я напишу формула формула подсчета
[02:26:38.060 --> 02:26:43.260]  то есть смотрите для того чтобы посчитать для n того числа разложение к вот
[02:26:43.260 --> 02:26:53.980]  прошу прощения для того чтобы написать разложение числа n того на к мы можем
[02:26:53.980 --> 02:27:02.100]  сказать что а давайте мы будем использовать количество разложения этого числа что будет
[02:27:02.100 --> 02:27:07.860]  если мы будем его использовать это число тогда у нас останется n минус и чисел правда
[02:27:07.860 --> 02:27:14.740]  точнее сумма их n минус и вот это именно здесь и написано я возьму число и оно может раскладываться
[02:27:14.740 --> 02:27:20.860]  по разному число и там количество у них может быть разным там один ну если это число 3 то это
[02:27:20.860 --> 02:27:28.980]  1 2 к примеру и просто 3 это уже два способа и так далее но я эти разложения прибавлю просто к
[02:27:28.980 --> 02:27:39.020]  своим от n минус и вот и все понятно как это считается или ничего не понятно не совсем что
[02:27:39.020 --> 02:27:48.940]  именно непонятно по сути последняя строчка еще раз как мы разбиваем и конкретно суммиру ну смотрите
[02:27:51.260 --> 02:27:57.900]  сейчас вы согласны с тем что вот у меня есть число 8 к примеру я его могу представить как
[02:27:57.900 --> 02:28:13.620]  3 плюс 5 правда да да я могу сказать что дп от 8 и там к примеру 5 ну так все сутрировано
[02:28:13.620 --> 02:28:24.900]  а это равно чему это равно дп смотрите вот той по той же форме ли подсчет дп n минус и
[02:28:24.900 --> 02:28:44.780]  если я и возьму 5 8 минус 5 а нет давайте тройку 8 минус 5 что я под этим подразумеваю я под этим
[02:28:44.780 --> 02:28:51.740]  подразумеваю следующее что в данном случае у меня вот есть динамика какая-то я хочу там
[02:28:51.740 --> 02:29:04.180]  разбить на числа не больше чем 5 давайте я посмотрю просто а чему 8 минус 8 минус 8 минус что
[02:29:04.180 --> 02:29:19.180]  ж такое то 8 что я хочу я могу сказать что а это то же самое что разбить число 5
[02:29:19.180 --> 02:29:23.500]  на числа не меньше чем 3
[02:29:29.140 --> 02:29:39.100]  тут точнее плюс ровно прошу прощения то есть еще раз n это количество разложений числа и на
[02:29:39.100 --> 02:29:47.380]  числа меньше либо равный как количество разложений числа n минус и на числа не больше чем и
[02:29:47.380 --> 02:29:55.940]  этого достаточно в данном случае формула подсчета будет выглядеть именно так вот и если
[02:29:55.940 --> 02:30:00.900]  просто порасписывать как это выглядит там не знаю до семерки давайте вот распишем для семерки
[02:30:00.900 --> 02:30:07.620]  к примеру можно просто не проще допустим у нас количество способов получается из того что если
[02:30:07.620 --> 02:30:14.260]  допустим 8 это у нас получается из количества способов разложить 7 плюс единица и плюс
[02:30:14.260 --> 02:30:21.220]  количество разложить шестерка плюс двойка плюс количество разложить пятерку плюс ну то есть это
[02:30:21.220 --> 02:30:27.340]  просто количество способов разложить шестерку семерку шестерку пятерку и так далее а теперь
[02:30:27.340 --> 02:30:36.420]  вопрос до какого это делать момента потому что мне не нужно повторяющийся элемент так у нас
[02:30:36.420 --> 02:30:46.940]  получается что повторяющийся мне нельзя в этом вся проблема если просто количества согласен
[02:30:46.940 --> 02:30:54.700]  но здесь есть проблема с повторяющимся элементом там есть действительно действительно случаи
[02:30:54.700 --> 02:31:02.940]  когда-то можно сделать полегче но есть второе решение которое вам действительно покажут это
[02:31:02.940 --> 02:31:08.060]  решение будет заключаться следующим то есть давайте я сейчас быстро отвлекусь немножко у нас
[02:31:08.060 --> 02:31:14.620]  три минуты все равно осталось я могу представить разложение числа в виде так называемых диаграмм
[02:31:14.620 --> 02:31:26.940]  юнга вот ну к примеру как-то так такие ступеньки и тут вот ну там как бы квадратики всякие есть
[02:31:26.940 --> 02:31:39.380]  вот и здесь будет один здесь 3 здесь 8 ну вот я разложу там 12 и что я могу делать этими
[02:31:39.380 --> 02:31:44.860]  диаграммами юнга по факту для того чтобы получить какое-то новое число а так можно
[02:31:44.860 --> 02:31:50.140]  разложить любое число ну то есть мы так и будем раскладывать чтобы порядок возрастания там был
[02:31:50.740 --> 02:32:03.580]  чтобы не повторяются я могу лишь добавить новую строчку с чем-то могу добавить число 1 разложение
[02:32:03.580 --> 02:32:16.060]  грубо говоря либо-либо могу поставить сюда столбец вот сюда вот в этот край для того чтобы
[02:32:16.060 --> 02:32:21.820]  получить какое-то новое число если я добавляю столбец то я что делаю я прибавляю единичку ко
[02:32:21.820 --> 02:32:29.140]  всем числам правда вот и поэтому я могу на единичку еще поставить сверху ну то есть я
[02:32:29.140 --> 02:32:36.420]  буду считать с конца вот грубо говоря то есть я могу вот добавить везде единицы и поставить
[02:32:36.420 --> 02:32:42.740]  еще единичку сверху добавить новый элемент так сказать и вот с помощью этого как-то все
[02:32:43.380 --> 02:32:51.860]  вот то есть я могу либо увеличить все имеющиеся числа там на один либо увеличить все имеющиеся
[02:32:51.860 --> 02:33:00.500]  числа на один и добавить еще один разложение вот один из двух способов я умею так делать все вот
[02:33:00.500 --> 02:33:06.900]  то есть это будет второй способ который я прошу с вами разобрать смотрите что касается динамики
[02:33:06.900 --> 02:33:12.700]  к сожалению нас еще очень много тем по динамике надеюсь что мы успеем за следующую лекцию есть
[02:33:12.700 --> 02:33:19.780]  ли вдруг мы не успеем то возможно контрольный перенесу вам на зачетную неделю не знаю увидим то
[02:33:19.780 --> 02:33:24.820]  есть здесь как получится хорошо потому что нам предстоит еще задача он и больше возрастающие
[02:33:24.820 --> 02:33:31.700]  подпоследовательности наибольшей общей подпоследовательности и задача рюкзаки вот это
[02:33:31.700 --> 02:33:36.820]  очень главные задачи действительно очень важные задачи которые необходимо знать на этом в принципе
[02:33:36.820 --> 02:33:40.460]  все всем большое спасибо всем удачи
