[00:00.000 --> 00:11.440]  Смотрите, сегодня мы с вами поговорим про основу теории графов, поговорим немножко про
[00:11.440 --> 00:18.480]  BFS. Теперь мы переходим к большому такому блоку, связанных с графами. Все, что у вас будет дальше,
[00:18.480 --> 00:24.480]  это будет все связано с графами. Единственное исключение будет это сегодня, если мы успеем
[00:24.480 --> 00:30.720]  все-таки вернуться к амортизационному анализу, но это не точно, потому что на прошлой лекции мы не
[00:30.720 --> 00:36.520]  успели это все-таки сделать. Попробуем совместить сейчас, хотя, может быть, вы видели у Булата,
[00:36.520 --> 00:44.040]  но мы рассмотрим какие-нибудь основные быстрые вещи и поймем, как это все работает. Вот, как-то
[00:44.040 --> 00:53.200]  так. Давайте начнем говорить теперь про графы. Что вы знаете про графы? Так,
[00:53.200 --> 01:03.000]  что вы знаете про графы? Да, по сути своей правды. Нужно просто понимать, как их теперь хранить
[01:03.000 --> 01:09.880]  внутри нашего компьютера. Да, для нас граф это будет пара множеств, множество вершин, множество
[01:09.880 --> 01:17.960]  ребер, и у нас могут быть ориентированные графы, могут быть неориентированные графы. В зависимости
[01:17.960 --> 01:22.520]  от этого, как бы, можно по-разному на них смотреть и смотреть на то, какие у нас есть ребра, каких
[01:22.520 --> 01:29.560]  ребер нет и так далее. Вот. Вроде бы ничего сложного, я надеюсь, вы все это прекрасно и так осознаете.
[01:29.560 --> 01:38.900]  Иначе бы очень странно, что вы были бы во втором семестре. Но ладно. Мульти графы. Есть мульти
[01:38.900 --> 01:49.360]  ор графы, есть мульти псевдографы. Это тоже, по-моему, достаточно понятно. Правда? Мульти множества,
[01:49.360 --> 01:56.120]  когда у нас есть множество ребер, мульти множество, это даже называется, что оно может повторяться.
[01:56.120 --> 02:10.280]  Вот. Да. Мульти графы, да. Ну здесь, здесь в одну и ту же сторону. Вот, то есть у нас
[02:10.280 --> 02:23.680]  один в два. Вот два ребра есть одинаковых. Что еще раз? Да, это по сути не простой граф. Мульти граф,
[02:23.680 --> 02:29.120]  когда у нас есть повторяющиеся ребра. Это нам нужно, это нам важно будет дальше, а по одной простой
[02:29.120 --> 02:34.680]  причине, потому что, ну грубо говоря, представьте, у этих ребер будут разные веса. Когда мы начнем
[02:34.680 --> 02:41.640]  делать веса у ребер, нам нужно это оценивать корректно. Понятно? Вот. Такое возможно. Что же тут
[02:41.640 --> 02:50.240]  поделать? Ну псевдограф, ну как бы, все то же самое понятно. Вот. Просто будет неориентированно.
[02:50.240 --> 03:01.440]  Степень вершины. Вам, я надеюсь, знакомы, что это число просто инцидентных ребер. Полустепень
[03:01.440 --> 03:08.400]  исхода и полустепень захода вершины тоже понятно. То, что входит, то, что выходит в любую вершину. Да.
[03:08.400 --> 03:19.880]  Степень вершины связан с данной вершиной. Вот. Ну как бы, основное утверждение, что у нас сумма всех
[03:19.880 --> 03:28.720]  степеней вершин в неориентированных графах – это двое. Ну а в ориентированных графах мы знаем,
[03:28.720 --> 03:34.800]  что у нас сумма входящих равна сумма исходящих ребер, и это равно просто сумме ребер. Ну,
[03:34.800 --> 03:41.400]  количеству ребер. Вроде бы не должно быть сложно. Если что, останавливайте, спрашивайте.
[03:41.400 --> 03:48.760]  А дополнительное определение связанное с тем, что такое путь. Путь у нас просто это последовательные
[03:48.760 --> 03:54.760]  вершины ребер, где каждый реброс соединяет соседние вершины в последовательность. То есть,
[03:54.760 --> 03:59.080]  мы можем выстроить какую-то последовательную, вот вам будет путь. Простой путь – это где у нас не
[03:59.080 --> 04:04.840]  будет повторяющихся вершин, а цикл – это какой-то замкнутый путь, где начало совпадает с концом.
[04:04.840 --> 04:12.960]  Всё понятно, всё достаточно просто. Здесь должно быть. Вот теперь переходим к чему-то более
[04:12.960 --> 04:20.240]  такому содержательному, нематематическому, содержательному беда. Вот. Будем смотреть,
[04:20.440 --> 04:28.440]  как мы можем хранить графы в памяти компьютера, какие есть способы и что мы будем делать.
[04:28.440 --> 04:36.840]  Первое – предположим, что у нас есть вершина. В вершина мы будем давать номера. Номера от нуля
[04:36.840 --> 04:45.160]  до v-1. Всё понятно, всё просто. Дальше, для того, чтобы нам было легче писать и легче на всё это
[04:45.160 --> 04:50.520]  смотреть, вместо модуля v и модуля e, то есть вместо множества, сколько там находится, мы будем
[04:50.520 --> 04:58.480]  просто писать v и e. А там в оценках графов и так далее, в оценке времени работы. Поэтому здесь
[04:58.480 --> 05:04.600]  всё будет понятно, что это будет там число. Я не буду это писать прямо постоянно. Поэтому,
[05:04.600 --> 05:10.720]  если вдруг увидите такую ошибку, знаете, это не ошибка. Просто иногда лень писать. Всё просто.
[05:10.720 --> 05:23.880]  V множество, а модуль v – это мощность множества. Ну да. Ну, не знаю, вот вы взяли граф на
[05:23.880 --> 05:31.720]  пяти вершинах. Вот 5 вершин, число 5 – это у вас как раз-таки мощность вашего множества. А как
[05:31.720 --> 05:37.360]  эти 5 вершин вы обозначаете буквами, цифрами, как хотите. Вот. Это само множество составит.
[05:37.360 --> 05:58.000]  В нём будет 5 элементов. Да. Мы смотрим только на конечные. Мы приводим это в реальную жизнь. В
[05:58.000 --> 06:05.360]  реальной жизни я не видел бесконечных. Вот. Есть такая вот проблемка. Поэтому да, конечные именно.
[06:05.360 --> 06:15.440]  Окей. Первый самый простой способ хранить наш граф – это можно просто представить его списком
[06:15.440 --> 06:21.960]  ребер. У нас будут номера вершин. Мы знаем, что там вершин какое-то количество v. Значит,
[06:21.960 --> 06:27.960]  если я представлю весь список ребер, согласны ли вы, что он задаёт мой граф единственным способом?
[06:27.960 --> 06:40.920]  Существуют точки. Я знаю все точки. Ещё раз. У меня не только список ребер есть. У меня есть
[06:40.920 --> 06:51.280]  ещё номера всех вершин. Ещё. Согласны. Всё-таки. Хорошо. Вот. Это самый простой, самый первый способ,
[06:51.560 --> 06:58.160]  как нам сохранить вообще граф с помощью списка ребер. Но в этом случае у меня вопросы к вам.
[06:58.160 --> 07:19.480]  Сколько памяти будет задействовано? Сколько? Квадрат чего? Нет. Ответ неважно. Ну,
[07:19.560 --> 07:24.560]  ещё раз. У меня есть v и есть e. Ограничение буквками вот этими поставьте. E. Ну,
[07:24.560 --> 07:35.440]  как бы список ребер, логично, что e. Кто такое сказал? Ну, хорошо, если мульти. А ещё,
[07:35.440 --> 07:40.040]  если у меня разреженный граф, то это будет o от n скорее. Я должен ограничивать всё-таки
[07:40.040 --> 07:49.120]  минимальным таким числом. Вот. Окей. Память понятна. Обход всех ребер за сколько будет? Обход.
[07:49.120 --> 07:55.680]  Но мне надо просто пройтись по ребрам. Обход всех ребер подразумевается, что я могу просмотреть все
[07:55.680 --> 08:03.600]  ребра и выбрать нужное мне. За e. Ну, я просто пройдусь по всем ребрам. А поиск ребра? Тоже за
[08:03.600 --> 08:10.640]  e. А получение соседней вершины? Вот у меня есть какая-нибудь вершинка v. Я хочу найти вершинку,
[08:10.640 --> 08:20.360]  которая является его соседом. E. Хорошо. Окей. Да, а всё это связано с тем, что ну как у нас хранится
[08:20.360 --> 08:30.760]  вообще вот этот весь список ребер. Можно ли как-то улучшить список ребер? Нет, давайте ещё раз,
[08:30.760 --> 08:38.640]  просто список ребер. Я хочу оставить список ребер. Вот у вас есть вот такой список. Можно ли
[08:38.680 --> 08:47.520]  что-нибудь с ним придумать такое, чтобы было полегче в некоторых вещах? Можно хранить как-то.
[08:47.520 --> 08:56.280]  Что-то сложное, давайте проще. Отсортировать. Если мы лексикографически вот это всё отсортируем,
[08:56.280 --> 09:04.000]  что у нас будет происходить с поиском ребер и получение соседних вершин? Можно использовать
[09:04.880 --> 09:14.520]  это самое важное здесь. Да, если мы отсортировываем их вот грубо говоря по началу нашего, ну откуда
[09:14.520 --> 09:21.200]  грубо говоря идёт ребро, то в этом случае мы можем спокойно бинпоиском найти необходимые нам
[09:21.200 --> 09:30.640]  соседей. Логично? Логично. Для ориентированного графа. Вот. За логарифм всё просто. В середину
[09:30.640 --> 09:34.040]  смотрим, дальше влево-вправо. А получение соседних вершин за сколько?
[09:39.560 --> 09:47.080]  Вот у меня есть вершинка В. Я хочу найти соседей. Е? Не е.
[09:47.080 --> 10:07.120]  Логарифм, но не совсем. И не е. Давайте все остальные тоже. В целом. Мы храним список ребер.
[10:07.120 --> 10:17.400]  Это перебор. Е квадрат прям перебор здесь будет. Давайте ещё.
[10:17.400 --> 10:34.480]  Лог Е плюс В. Почти. Почти получилось. Смотрите. Ну ещё раз. Вот у меня есть вот мой
[10:34.960 --> 10:41.560]  список ребер. Я с помощью бинпоиска согласна, что могу найти вот где начинается мое В. И где
[10:41.560 --> 10:48.160]  заканчивается мое В. Ну как бы бинпоиском это находится. Это будет логарифм от количества
[10:48.160 --> 11:00.480]  моих ребер. Да? Сколько вот этого вот? Так. Подождите. Праздники ещё не наступили. Вот сейчас
[11:00.480 --> 11:06.760]  лекция будет, потом будут праздники. Давайте. Сколько у нас может быть? Ну то есть смотрите,
[11:06.760 --> 11:14.160]  мне нужно вывести всех соседей. Сколько у меня здесь может быть? В чём максимум? Точное число.
[11:14.160 --> 11:24.640]  Вот мы вводили с вами В, Е. Были ещё какие-то вещи. Степени вершины были. Что я должен прибавить?
[11:30.480 --> 11:45.920]  Понятно откуда это произошло. То есть ещё раз. Это все вершины, которые имеют начало В. Всё. Вот.
[11:45.920 --> 11:58.840]  Это достаточно просто и понятно. Отчего? Мне нужно вывести всех соседей. Ну тут один.
[11:58.840 --> 12:16.560]  Два. Ой, Н. Ну у тебя есть все. Подожди. Ещё раз. Я хочу соседей, куда я могу прийти. Вот. А, хорошо.
[12:16.560 --> 12:22.920]  Извините. Всё. Я понял. Да. Соседи. Соседние вершины мне считаются именно те, куда мы можем прийти.
[12:23.120 --> 12:49.960]  Да. Вот это? Нет. Почему? Кто тебе такое сказал? Да. Подожди. Больше, чем ребер или больше,
[12:49.960 --> 13:11.440]  чем лог, Е. На всякий случай для всех остальных. Вот моя солнышко. Тут логарифм. А? Кто такое сказал?
[13:19.960 --> 13:36.920]  Чего? А, ну в этом плане, конечно, да. Ограничено всё Е квадрат. Ну нет. Давайте мыслить максимально
[13:36.920 --> 13:43.720]  ближайшим числом, которое нам необходимо. Давайте не рассуждать. В пространство уходить. Всё работает
[13:43.720 --> 13:48.120]  с бесконечностью. Зачем нам всё это изучать? Ну нет. Давайте не будем таким образом делать.
[13:48.120 --> 13:55.280]  Мы будем смотреть вот эту верхнюю границу почти точно и пытаться её оценить. Окей? Вот. Да.
[13:55.280 --> 14:13.080]  Откуда Е лог Е? Откуда вы это берёте? Подождите. Я сейчас свернусь в первый семестер. Откуда Е лог Е?
[14:13.080 --> 14:20.040]  А, в этом плане. Нет. Мы сразу хранить их будем сортированными в списке и предположим,
[14:20.040 --> 14:29.400]  что это был предподсчёт. Вот. То есть вот та сортировка это был предподсчёт. У вас всегда в
[14:29.400 --> 14:35.760]  задачах, у вас почти никогда не будет добавления чего-то. Вам будет дан сначала граф. Вы его
[14:35.760 --> 14:42.880]  считываете, вы его обрабатываете, а после этого отвечаете на запросы. Вот. Поэтому это считайте
[14:42.880 --> 14:58.200]  предподсчётом таким. Ещё вопросы? Вот. Сейчас. Почему? Хорошо. Ещё раз. У вас может быть граф,
[14:58.200 --> 15:08.200]  какой-то там, не знаю, в котором Е и в котором В. Вы отсортировали за Е лог Е, да? А потом вам
[15:08.200 --> 15:22.160]  приходит Е квадрат запросов на то для конкретных там вершин. Вы с таким и столкнетесь. Ну либо всё
[15:22.160 --> 15:28.760]  просто. Ну, Е квадрат запросов, В квадрат даже запросов, это тоже будет сильно больше, потому что
[15:28.760 --> 15:38.680]  возможно такое, что у вас, не знаю, вот у вас есть какой-нибудь граф, и когда вы соединяете там
[15:38.680 --> 15:43.640]  вот примерно вот так, у вас Е примерно В, у вас граф представляется разреженным. То есть у вас не
[15:43.640 --> 15:49.520]  полный граф, не почти полный граф, ничего такого. Вот. В квадрат запросов почему бы не сделать?
[15:49.520 --> 15:57.080]  Повторяющихся. К вам приходят пользователи гуглят одно и то же, к примеру. Ну типа, ну да,
[15:57.080 --> 16:02.680]  вот этот человек там гуглит какое-нибудь аниме, этот гуглит то же самое, и другой человек такое же
[16:02.680 --> 16:09.800]  аниме смотрит. Ну извините, такова жизнь. Вот. Ну или все вы хотите купить билеты, не знаю, на
[16:09.800 --> 16:18.720]  Дюну-2, к примеру. Позже же гуглите, гуглите. Вот. Так что как-то так. Второй вариант, то, что там сказали
[16:18.720 --> 16:28.000]  уже про табличку, это называется матрица смежности. Заводится таблица В на В, где в ячейке Иты-Житы будет
[16:28.000 --> 16:36.240]  хранится метка наличия или отсутствие ребра. Либо количество ребер, либо вес этих ребер. До весов
[16:36.240 --> 16:46.000]  мы попозже дойдем. Вот. И в этой таблике очень легко смотреть, соединено Ита или Житое ребро. По памяти
[16:46.000 --> 16:53.920]  это, естественно, занимает сразу В квадрат. Вот. А что касается обхода всех ребер, поиск
[16:53.920 --> 17:10.040]  ребра и получение соседних вершин? Обход В квадрат. Так, поиск. Откуда получился лог-квадрат?
[17:10.040 --> 17:29.440]  В ячейке Иты-Житы лежит есть ребро или нет ребра? Ну да. А что ты подразумевала тогда под табличкой?
[17:29.440 --> 17:41.000]  Откуда получился квадрат, я тогда пока не понял. Ладно. Хорошо. В действительности, да. В этой
[17:41.000 --> 17:49.440]  таблице достаточно просто смотреть, есть ребро или нет ребра. Мы можем пойти с Иты-Житой в ячейку
[17:49.440 --> 17:55.160]  и посмотреть, есть там нолик, нет там нолика, есть единичка, нет единички. В зависимости от этого дать
[17:55.160 --> 18:00.840]  какой-то ответ. Есть ребро между ними или нет. И значит, что у нас все будет связано. Вот здесь
[18:00.840 --> 18:04.880]  вот написано о матрице смежности для ориентированного графа. Как вы думаете,
[18:04.880 --> 18:13.040]  какой матрицей смежности должен быть для неориентированного графа? Нет. Симметричный.
[18:13.040 --> 18:23.000]  Для неориентированного графа она всегда... А? У вас все равно в квадрат памяти. Ну да,
[18:23.000 --> 18:27.680]  если вы там будете рассчитывать, чтобы вам в два раза скостить, и вам выглядело хорошо,
[18:27.680 --> 18:33.680]  то да. Но этого почти никогда не произойдет. Я больше того скажу, что матрицы смежности и
[18:33.680 --> 18:46.880]  списком ребер вы будете крайне редко пользоваться. Да. Сегодня очень интересные вопросы, я скажу.
[18:46.880 --> 19:01.280]  Хорошо. А получение соседей вершины за сколько будет? У от чего? В. Почему В? Да. То есть,
[19:01.280 --> 19:05.560]  нам необходимо пройтись по всей строке или по всему столбцу, в зависимости от того,
[19:05.560 --> 19:13.840]  как хотите. Но мы рассчитываем, что в итой здесь мы ставим ребро, если с итого по житой оно есть.
[19:13.840 --> 19:20.440]  То есть, жита это строка, жита это столбец. Поэтому да, нам достаточно пройтись по одной строке и
[19:20.440 --> 19:26.440]  рассмотреть, есть там единичка, нету, тогда мы выведем или не выведем данного соседа,
[19:26.440 --> 19:34.880]  и получим всех наших соседей. Пока понятно, что происходит. Как вы думаете, какой еще есть вариант?
[19:34.880 --> 19:56.720]  Ой, нет. Вершина хоронить, куда они могут перейти? Неприкольно. Бинарное дерево,
[19:56.720 --> 20:06.000]  что-нибудь простое, но достаточно. Похоже на матрицу смежности чем-то. Я надеюсь,
[20:06.000 --> 20:17.400]  вы там обсуждаете именно этот вопрос. И какой итог вы получили? Да что ж такое это? Ладно,
[20:17.400 --> 20:26.040]  а нордерецет не надо. Смотрите, это списки смежности. Смежности хранится следующее. А у вас
[20:26.040 --> 20:34.160]  есть, грубо говоря, массив. На самом деле, это вектор векторов, где вы просто сохраняете,
[20:34.160 --> 20:39.600]  не знаю, для нулевого элемента всех его соседей. То есть, для того графа, который там выше,
[20:39.600 --> 20:48.760]  это у нас получается один, ну давайте я запишу там два, один. Ну то есть, тут будет массивчик. Для
[20:48.760 --> 20:58.840]  первого и для второго. Для первого у нас получается два. Вот. У вас будет такой вот вектор векторов,
[20:58.840 --> 21:06.400]  сейчас это расскажу и отвечу. Будет такой вектор векторов, и память у вас будет храниться в плюс
[21:06.400 --> 21:17.520]  е. Почему в плюс е? Да, не больше чем е мы можем запушить этих вершин. А теперь вопрос по поводу
[21:17.520 --> 21:45.600]  обхода ребер. Так, поиск ребра. Нет. Давайте еще раз. У меня здесь хранится, я знаю,
[21:45.600 --> 21:57.720]  что отсюда начинается. Я хочу вам найти ребро 1, 2. Вот это представил. Представил.
[21:57.720 --> 22:10.240]  Вот е. Всегда. Или степень вершины. Степень вершины, видимо. Хорошо.
[22:10.240 --> 22:18.600]  Ну степень вершины не всегда равна е. Хорошо. А получение соседей вершин за сколько?
[22:18.600 --> 22:31.640]  Хорошо. Да, в действительности это так почти кроме последнего момента. Последний момент,
[22:31.640 --> 22:46.400]  у вас же есть уже сам вектор. Вектор из всех ваших соседей. Еще раз, для нас соседями мы будем
[22:46.400 --> 22:52.160]  считать, вот именно для ориентированных графов, это то, куда мы идем, куда мы можем прийти.
[22:52.160 --> 23:02.240]  Ага, мув, семантику проходили. СТД мув, знаете, как делать. Ну вот, если что, у вас есть вариант.
[23:02.240 --> 23:09.640]  В общем-то, на самом деле со списками смежности все просто. Ну как бы у вас есть список такой
[23:09.640 --> 23:16.320]  поквартирный, вы смотрите на каждую вершину и думаете, что происходит. Вот этот вариант почти
[23:16.320 --> 23:23.400]  всегда чуть больше предпочитают, чем все остальные. Но иногда бывает такое, что нужен либо тот вариант,
[23:23.400 --> 23:29.400]  либо другой вариант, в зависимости от алгоритмов вам понадобится тот или иной. Вот, есть алгоритмы,
[23:29.400 --> 23:35.240]  которые полностью построены на списках ребер, есть алгоритмы, которым лучше всего будет матрица
[23:35.240 --> 23:41.680]  смежности и так далее. Мы будем каждый раз на это все смотреть, будем оценивать, будем думать,
[23:41.680 --> 23:47.600]  лучше или не лучше, и у нас очень много различных асимптотик появится в этом семестре. И вы должны
[23:47.600 --> 23:53.360]  в зависимости от задачи понимать, какую задачу вы, во-первых, решаете от тех условий, которые были,
[23:53.360 --> 24:00.680]  плюсом, какой алгоритм использовать. Вот, потому что не всегда подходят один и тот же алгоритм.
[24:00.680 --> 24:14.160]  Что важно? Важно, что вместо каких-то массивов и списков, списков смежности можно хранить либо
[24:14.160 --> 24:21.800]  бинарное дерево поиска, если вы очень хотите повеселиться, либо хэш таблицы. Потому что в
[24:21.800 --> 24:28.160]  этом случае вы сможете отвечать очень быстро есть такое там число или нет. Понятно? Вот,
[24:28.160 --> 24:32.480]  тогда у вас время поиска ребра будет действительно быстрее симпатически,
[24:32.480 --> 24:43.760]  но на хранение будет уходить больше времени. Да. Никак, по порядку просто их кидаем. Если в
[24:43.760 --> 24:53.040]  векторе делаете так. Если у вас будет вектор unordered set, то это у вас само как-то существует.
[24:53.040 --> 25:07.800]  А зачем? Здесь другой вопрос. Если это нужно, то храни просто с помощью бинарного дерева поиска
[25:08.160 --> 25:16.120]  просто. Вот. Если тебе нужно быстро понимать, есть ли там что-то, то можно хэшами. Вот. Прям сортировать
[25:16.120 --> 25:25.960]  это смысла нет. Вот. Легче использовать какой-нибудь другой. Что ж вы там такое обсуждаете? Предложите
[25:25.960 --> 25:31.680]  еще вариант. Вот есть бинарное дерево поиска, есть unordered set хэш таблицы. Что еще предложите?
[25:31.680 --> 25:51.440]  А где ты увидел поиск ребра зовут единица? Ну, у тебя есть вот этот вектор? Ну вот,
[25:51.440 --> 26:08.280]  это и есть все твои соседи. Еще раз. У тебя есть целый вектор. Кто сказал? Передай его по ссылке и все.
[26:08.280 --> 26:17.040]  Передав вектор этой ссылки, получите. Если не хотите менять по константной ссылке,
[26:17.040 --> 26:22.680]  если хотите типа полностью избавиться от вашего графа, возьмите и по R-value ссылки передайте.
[26:22.680 --> 26:37.720]  Ага. Еще вопросы. У вас сегодня очень странная лекция. Получается, если честно, да. Соседом,
[26:37.720 --> 26:42.800]  да, мы будем считать такое, но в действительности можно считать по-разному, в зависимости от того,
[26:42.800 --> 26:49.840]  как вы это хотите сделать. В общем-то, важный момент здесь такой. Если вдруг вы встретите
[26:49.840 --> 26:53.760]  неориентированный граф, вы будете просто считать, что он ориентированный и проводить
[26:53.760 --> 27:00.440]  ребро в одну сторону и в другую, например. А если говорить про соседей в общем виде,
[27:00.440 --> 27:07.120]  что это еще те, кто к нам приходят, то здесь уже, да, нужно будет проходиться по всему вашему
[27:07.120 --> 27:18.720]  списку смежности. Другого варианта у вас не будет. Ага. Окей. Теперь, надеюсь, когда мы поняли,
[27:18.720 --> 27:25.780]  как можно хранить граф, мы переходим к первому базовому алгоритму, называющемуся BFS. Слышали
[27:25.780 --> 27:35.480]  такое? Нигде не слышали. Это обход графа в ширину. И это самый первый, самый базовый, самый понятный
[27:35.480 --> 27:45.120]  алгоритм, который потом, в дальнейшем, ляжет в основу остальных. Существуют две вещи BFS и DFS.
[27:45.120 --> 27:50.360]  Все правильно. Вот. Это очень любят спрашивать на собеседованиях. Такое периодически случается,
[27:50.360 --> 27:56.960]  потому что дальше смотреть не так интересно. Ну, в общем-то, что такое обход графа в ширину? Для
[27:56.960 --> 28:01.440]  начала нужно понять, что такое обход графа. Обход графа — это просто процесс посещения всех вершин и
[28:01.440 --> 28:09.360]  ребер. Мы должны пройтись по всему, что нам необходимо. Как правило, сами обходы осуществляются в какой-то
[28:09.360 --> 28:16.080]  определенной последовательности с учетом структуры графа и с целью выяснить какие-то определенные
[28:16.080 --> 28:24.760]  свойства. Эти обходы могут выглядеть по-разному. Вы можете делать их каким угодно способом.
[28:24.760 --> 28:32.960]  Что такое обход графа в ширину? Обход в графе ширину работает так. Вот мы находимся в какой-то вершине.
[28:32.960 --> 28:40.080]  Давайте пойдем ко всем соседям, которые у меня есть. От них пойдем ко всем соседям, которые есть у этих
[28:40.080 --> 28:47.040]  соседей и так далее. И у вас будет такое наслоение друг на друга. У вас будут слоями просто происходить.
[28:47.040 --> 28:56.520]  Что можно отсюда извлечь интересного? Посетили или не посетили все вершины? Хорошо, да. Еще.
[28:56.520 --> 29:12.080]  Вершины, у которых нет исходящих ребер. По сути, это близко к связности. Просто вопрос,
[29:12.080 --> 29:30.800]  вы какую связность хотите? Сильную, слабую? Вот. Еще. А? Цикл. Ну ладно. Что еще раз? Нет.
[29:30.800 --> 29:41.720]  Если я посещал соседей, я не хочу больше посещать. Зачем мне идти в одно место еще раз? Еще.
[29:41.720 --> 30:00.040]  До реализации мы дойдем. Вопрос флагов. Что именно не оптимально для тебя?
[30:00.040 --> 30:24.480]  Какую структуру? Нет. Нет. Ну у нас будет отдельный массив какой-нибудь. Предположим,
[30:24.480 --> 30:30.720]  да. Можно использовать массив. Были мы или нет. Еще раз. Привыкните к тому, что все вершины графа
[30:30.720 --> 30:37.600]  это чиселки. А если это чиселки, вы просто их храните в массиве. И если вам достаточно
[30:37.600 --> 30:42.240]  массива юст, ну то есть было использовано, не было использовано конкретная вершина, то в этом
[30:42.240 --> 30:49.040]  случае вы легко ответите на вопрос. Посетили мы не посетили эту вершину? Ага. Давайте поговорим о том,
[30:49.040 --> 30:57.280]  что тут можно делать и вообще как с этим жить. Но вы мне не назвали очень важный момент здесь. Да.
[30:57.280 --> 31:12.320]  Что ты подразумеваешь под подвесить?
[31:12.320 --> 31:32.840]  В действительности то, что ты сейчас сказал, очень похоже на то, что мы как раз разбили по слоям и
[31:32.840 --> 31:41.240]  сказали типа кто в каком находится. И в действительности это кратчайшие пути. Если у вас ребра не имеют веса,
[31:41.360 --> 31:47.160]  а просто вы считаете количеством, грубо говоря, какой путь, то этого достаточно. Мы, во-первых,
[31:47.160 --> 31:53.520]  про связанность вы сказали, но фактически это достижения из этой вершины каких-то других. Не
[31:53.520 --> 32:01.800]  всегда связанность означает это одно и то же с достижением какой-то другой вершины. Вот. Это
[32:01.800 --> 32:08.280]  первое. Второе, это те самые кратчайшие пути, потому что находясь в одной вершине, это расстояние
[32:08.280 --> 32:14.360]  0, все соседи расстояние 1, соседи-соседи это расстояние 2 и так далее. Ну понятно,
[32:14.360 --> 32:25.600]  как это расходится. Да? Нет? Да? Да, кивают. Хорошо. В каком смысле? Если мы говорим про
[32:25.600 --> 32:31.360]  урграф и сильную связанность, то это означает, что для любой пары вершин вы из вершины В доходите в
[32:31.360 --> 32:37.280]  У и из У в В. Вот это сильная связанность. Связанность с неориентированным графиком,
[32:37.280 --> 32:46.880]  что у вас есть путь из В в У для любой пары вершин. Да. Вот. Если брать связанность и сильную связанность,
[32:46.880 --> 32:52.360]  назовем это так. Окей. Понятно с кратчайшими путями, что я хочу делать. И действительно,
[32:52.360 --> 32:59.360]  все алгоритмы БФС это кратчайшие пути. Как это выглядеть? Вот давайте теперь смотреть на это все.
[32:59.360 --> 33:07.280]  Смотрите, у меня есть нулевая вершина. Ну, я ее обозначил нулевая, вам скажут,
[33:07.280 --> 33:11.800]  не знаю, там от пятой вершины нужно посчитать. Я возьму ее просто как нулевой, вы можете делать
[33:11.800 --> 33:25.480]  все что угодно. Вот. У меня есть соседи, к которым мы придем. А вначале у меня будет массив Дист,
[33:25.480 --> 33:36.400]  а от 0 до n-1 равный бесконечности. Скажите, когда я нахожусь в этой вершине, какое расстояние до нее?
[33:36.400 --> 33:48.200]  Ноль. Отлично. Вот. Поэтому я говорю, что Дист там вот этого равно ноль. И начинаю стартовать именно
[33:48.200 --> 33:55.840]  с этой вершины. Заметьте, заметьте, мне здесь не нужен никакой массив использованной или не
[33:55.840 --> 34:07.920]  использованной вершинки. Почему? Да. Согласны, что я уменьшить не могу, если общищаю всех. А теперь
[34:07.920 --> 34:16.200]  смотрите, для всего этого я буду использовать очередь. Я же хожу ко всем по очереди. Вот.
[34:16.200 --> 34:34.880]  Что будет гарантироваться в этой очереди? Смотрите, я в эту очередь складываю просто
[34:34.880 --> 34:41.200]  все вершины своих соседей. Ну, то есть я вот встаю в вершине, положил всех соседей вот у своих
[34:41.200 --> 34:47.840]  соседних вершин. Потом пришел в другую вершину, положил всех соседей этой вершины в данную очередь.
[34:47.840 --> 34:54.760]  Потом пришел в другую вершину, опять положил всех соседей в данную очередь. И так далее. Я вот продолжаю
[34:54.760 --> 35:00.120]  вот это все время делать. И когда я прихожу в новую вершину, я хожу к ним вот именно по этой
[35:00.120 --> 35:06.600]  самой очереди. И смотрю, доступна мне эта вершина или нет, был я в ней или нет. Если был,
[35:06.600 --> 35:15.280]  то ничего не делаю. Если не был, то я опять беру всех соседей. Все просто. На руках понятно?
[35:15.280 --> 35:28.760]  Ну так, на словах. Что я сейчас делал? Страшно. А? Еще раз.
[35:28.760 --> 35:44.320]  Ну смотрите, я нахожусь в нулевой вершине и такой, ага, вот это положу, вот это положу. Нет,
[35:44.320 --> 35:51.360]  мы кладем по одной вершинке. По одной вершине я кладу все остальные. А что я делаю здесь? Смотрите,
[35:51.360 --> 35:58.280]  хоть алгоритм вам написан, я боюсь, что вы можете сразу... Нет, вам не понравится,
[35:58.280 --> 36:13.920]  что здесь происходит. Давайте, я тот же начало возьму оттуда. Вот моя нулевая. Я говорю,
[36:13.920 --> 36:20.560]  что в моей очереди Q будет лежать в начале нулевой вот этот элементик. После этого,
[36:20.560 --> 36:26.200]  когда я в нее зашел, вот в этой вершине нахожусь, я что делаю? Я добавляю всех его соседей. Ну,
[36:26.200 --> 36:44.480]  а 1, 4, 6. И выхожу из этой вершины. Я ее посетил. И когда я выхожу из нее, я говорю,
[36:44.480 --> 36:57.040]  что dist 0 равен 0. Ага, ну как бы, вот я сделал так. А когда я буду класть свои вершины сюда,
[36:57.040 --> 37:04.560]  а вот dist 0 равный 0, он был в самом начале. Скажите, сколько у меня расстояние будет до соседей
[37:04.560 --> 37:12.120]  моей нулевой вершины? 1. На 1 больше, чем я был в этой вершине, согласны? Ровно так же,
[37:12.120 --> 37:18.920]  что для этих соседей будет на 1 больше, чем у них. Согласны? Я делаю всегда плюс 1,
[37:18.920 --> 37:28.360]  поэтому тут D это единичка, единичка, единичка. Окей? Теперь смотрите дальше.
[37:28.360 --> 37:51.720]  2, 3, 5, 8, 7. А давайте тут вообще ничего не будет. Что у нас происходит дальше? Дальше я
[37:51.720 --> 38:00.600]  иду по этой очереди и достаю новую вершину. 1. Расстояние ее 1. До следующих вершин 2, 3, 5,
[38:00.600 --> 38:13.280]  сколько расстояния будет? 2. Я сразу это прописываю. У меня тут 2, у меня тут 3, у меня тут 5.
[38:13.280 --> 38:25.880]  Расстояние до этих двух. 2. Я их все посетил, все посмотрел и выкидываю. А теперь представьте,
[38:25.880 --> 38:37.800]  еще не знаю, что у меня из пусть будет, сейчас я думаю, из 5 пусть будет 8. Вот так до конца доведем
[38:37.800 --> 38:50.040]  эту всю штуку. Что происходит дальше? Вот я посетил единичку, давайте я вот здесь вот их подкрашу.
[38:50.040 --> 39:06.440]  Дальше я буду идти в 4 и добавлю восьмую вершинку, которая пришел. Согласны? 8. Ну,
[39:06.480 --> 39:13.400]  у шести никого нет, я просто на нее забью. Вот, и я их вычеркиваю. Вот скажите мне 8,
[39:13.400 --> 39:20.360]  там будет 3. А у меня вопрос, ой два, прошу прощения, да. У меня вопрос, вы видите,
[39:20.360 --> 39:27.680]  что происходит с расстоянием? Что происходит в этой очереди дальше? Ну вот у меня 3, 5,
[39:27.680 --> 39:38.160]  8. Предположим, вот сделаю 2, 3, у них ничего. Сделаю 5 и вижу опять 8. Я иду как будто бы 8,
[39:38.160 --> 39:46.720]  но приду ли я туда? Нет, у меня уже 10 равен 2. А теперь вопрос, согласны ли вы с тем, что в этой
[39:46.720 --> 39:55.880]  очереди каждый шаг, каждая итерация вот того, когда я добавляю, всегда будет хранится какое-то
[39:55.880 --> 40:05.040]  расстояние х в начале и не более чем х плюс 1 у всех остальных. То есть моя вся очередь,
[40:05.040 --> 40:11.880]  она фактически будет разбиваться вот как-то вот так. Я не могу поставить там х плюс 2 никогда,
[40:11.880 --> 40:19.320]  потому что я рассматриваю все элементы сначала и от них добавляю что-то в конец. Теперь давайте
[40:19.320 --> 40:26.520]  смотреть на сам весь этот алгоритм. Ну у меня есть Дист, у меня есть... Как?
[40:26.520 --> 40:45.000]  Не может быть, плюс 2. Плюс 2 не бывает. Вот. Отлично. Смотрите, мы с вами храним два массива Дист,
[40:45.600 --> 40:50.600]  если вдруг вам нужно восстановить путь, то есть откуда вы пришли, из какой вершины, но это не
[40:50.600 --> 40:56.080]  всегда надо, здесь в зависимости от того как необходимо. Дальше я делаю очередь и говорю,
[40:56.080 --> 41:03.520]  что Дист со своей стартовой вершины Source у меня ноль. Но после чего я делаю до тех пор,
[41:03.520 --> 41:11.480]  пока моя очередь не пустая, беру вершину из моей очереди, смотрю всех ее соседей,
[41:11.480 --> 41:16.760]  всем соседям, если мы их не посещали, то есть если Дист у меня это бесконечность,
[41:16.760 --> 41:23.080]  всем соседям делаю Дист равный плюс 1 от той вершины, где я сейчас нахожусь, говорю,
[41:23.080 --> 41:29.720]  что там parent у меня, я пришел из вершины В, которая у меня написана, и пушу в очередь. Окей,
[41:29.720 --> 41:39.160]  понятно. Понятно, как работает BFS. Что произойдет после того, как я его закончу?
[41:39.160 --> 41:51.160]  У меня ко всем вершинам будут расстояния от данной конкретной вершинки. Согласны? Сколько это работает?
[41:58.160 --> 42:03.200]  Вот В, так. А? Вот В.
[42:09.160 --> 42:32.400]  Вот В, хорошо. Еще есть варианты? А? А сумма степени вершины чему равна? В плюс Е,
[42:32.480 --> 42:47.120]  почему В плюс Е? И смотрим соседей. Вот это правда. Вот В плюс Е, если мы идем с помощью списка
[42:47.120 --> 42:54.000]  смежности. Почему? Потому что мы ходим по всем своим соседям. Мы должны пройтись по каждому
[42:54.000 --> 42:59.240]  соседу, и неважно, был он или нет, мы все равно должны проверить, вот этот их должен сработать,
[42:59.240 --> 43:05.960]  который после фора идет. Понятно? Нельзя рассуждать только с мыслью о том, что у меня есть что-то внутри
[43:05.960 --> 43:16.280]  или нет. А если вдруг у вас нету списка смежности, а у вас матрица смежности, тогда будет В квадрат.
[43:16.280 --> 43:24.520]  Ну, вы просто постоянно для каждой вершины проходите по всем ее соседям и смотрите есть
[43:24.520 --> 43:33.720]  сосед, нет соседа, есть сосед, нет соседа, поэтому будет В квадрат. Понятно время работы? За В плюс
[43:33.720 --> 43:44.840]  Е звездочку получаешь. Вот, отлично. Хорошо, давайте докажем корректность данного алгоритма. Потому
[43:44.840 --> 43:50.480]  что без этого уже никуда, нам нужно доказывать, что действительно что-то работает, а не просто на
[43:50.480 --> 43:58.040]  словах это делать. Давайте покажем, что в массиве Дист у нас действительно хранятся кратчайшие пути.
[43:58.040 --> 44:04.520]  Первая лемма это то, что мы с вами в самом начале рассматривали, что у нас в очереди все вершины
[44:04.520 --> 44:10.240]  расположены по неубыванию Дист и их расстояния различаются не более чем на единичку. Ну как бы,
[44:10.240 --> 44:16.880]  как эту лему сделать? Мы с вами это показали, в действительности это можно сделать по индукции,
[44:16.880 --> 44:25.760]  где по индукции в самом начале пути у нас что? Находится одна вершина и для нее все это верно,
[44:25.760 --> 44:33.840]  согласны? У нас неубывающая последовательность из одного. Вот, дальше переход следующий. Мы делаем
[44:33.840 --> 44:41.440]  для какой-то итерации К, тогда в начале очереди расположены вершины со значением Х, Д, как хотите.
[44:41.440 --> 44:46.920]  Вот, в конце с значением D плюс 1, но так как мы вытаскиваем первые вершины, то мы добавим в
[44:46.920 --> 44:59.120]  конец нашего списка, в конец нашей очереди элемент с со значением D плюс 1. То есть опять в начале
[44:59.120 --> 45:05.000]  у нас идет какое-то количество D, может быть нулевое уже к этому моменту, после него D плюс 1.
[45:05.000 --> 45:20.200]  Переход корректен, база есть, итог получили. Понятно? Точно? Хорошо. Ладно, теперь смотрите. Нам
[45:20.200 --> 45:26.360]  нужно доказать, что там действительно хранятся необходимые нам расстояния. То есть для любой вершины
[45:26.360 --> 45:34.560]  В, расстояние В, давайте сначала докажем, что оно больше либо равно, чем ρ от S до V, где S это
[45:34.560 --> 45:43.320]  расстояние от S до V. То есть числа, которые хранятся в 10, они больше либо равны этому числу. Почему?
[45:43.320 --> 46:00.720]  Окей. Ой. Да, но в действительности я опять здесь просто сделал по индукции, но можно ровно таким
[46:00.720 --> 46:11.800]  же способом сделать. Ну то есть просто расписав через плюс 1. Окей? Вот. Так как у нас есть какие-то
[46:11.800 --> 46:19.600]  расстояния, все достаточно просто. А теперь теорема самой корректности, что после работы вашего
[46:19.600 --> 46:29.400]  BFS для любой вершинки V у вас в действительности D равен расстоянию, к кратчайшему пути. Необходимо
[46:29.400 --> 46:35.920]  это доказать. Как это доказывается? Доказывается это от противного. Пусть существует какая-то вершина
[46:35.920 --> 46:47.880]  X, где у нас расстояние D, расстояние до вершинки этой X будет меньше, чем D, который мы нашли.
[46:47.880 --> 47:04.040]  Пусть V – это минимальный аргумент от РОСХ, это как раз-таки где ДИСТХ больше, чем РОСХ. Понятно,
[47:04.040 --> 47:15.200]  что я здесь сказал? Отлично. Вот. Пусть у него есть parent, у него есть родитель. А родитель этой
[47:15.200 --> 47:22.720]  вершинки V. А P, ну как бы предок, истинный, это вершина V. Ну что подразумевается? Смотрите.
[47:22.720 --> 47:32.160]  Как будто бы вот в этом случае мы должны сказать следующее. Вот у меня есть вершинка V, и выглядит
[47:32.160 --> 47:42.840]  это так, что я пришел в нее из U, и это проблема. А правильно было бы прийти из P. Вот что там сказано.
[47:42.840 --> 47:51.520]  Окей? А что происходит в этом случае? Я говорю, что в этом случае у меня расстояние до V. С одной
[47:51.520 --> 47:59.120]  стороны, по моему алгоритму DIST V равен DIST U плюс 1. Согласны? Это тот родитель, который есть. А с
[47:59.120 --> 48:16.040]  другой стороны, RU от SV равен RU от SV плюс 1. Ну то есть расстояние до этой вершины. Отлично.
[48:16.040 --> 48:26.160]  Тогда, и кроме того, мы имеем, что DIST от V больше, чем RU от SV. Но это наше предположение,
[48:26.640 --> 48:39.600]  что такая вершина еще существует. Ага. Понятно. Вот. Чудненько. Тогда в этом случае у нас DIST U больше,
[48:39.600 --> 48:47.760]  чем RU от SP. То есть расстояние до вершины этой U должно быть больше, чем расстояние до этой
[48:47.760 --> 48:56.400]  вершины P. Согласны? А тогда в этом случае мы получаем противоречие, потому что мы сказали,
[48:56.400 --> 49:06.200]  что в нашей очереди все хранятся по неубыванию расстояний. Это первое. А значит,
[49:06.200 --> 49:14.280]  мы вершину U обработали раньше, чем вершину P. Представьте, что у меня здесь, не знаю,
[49:14.280 --> 49:22.680]  значение 5, а здесь значение 6. Мы с вами сказали, что в нашей очереди все значения всегда идут по
[49:22.680 --> 49:29.880]  неубыванию и отличаются не более чем на единичку. Мог ли я в начале обработать U, а только потом P?
[49:29.880 --> 49:39.200]  Нет. Потому что у меня так очередь устроена. В начале лежат все-таки меньше. Вот. А в то же
[49:39.200 --> 49:47.240]  время я говорю, что вершина V минимальная по аргументу RU от SV. RU от SX, точнее. Минимальная из всех таких.
[49:47.240 --> 50:02.960]  Значит, для всех вот этих она верна. Согласны? То есть вот здесь подразумевается, что D от P равно RU от SP.
[50:03.760 --> 50:08.240]  Мы говорим о том, что в этой вершине это вернул, потому что V я взял минимальную такую.
[50:08.240 --> 50:18.520]  Ну а как бы мы не могли сделать такого? Мы не могли не в том порядке их взять. Значит,
[50:18.520 --> 50:26.080]  у вас где-то бага только. Но именно в алгоритме DX ничего не изменяется. Поэтому это неверно. Мы
[50:26.080 --> 50:37.400]  пришли к такому противоречию. Понятно ли вам противоречия? Кому непонятно. Да. Ой,
[50:37.400 --> 50:45.600]  господи, БФС, простите, пожалуйста. У меня влаги уже просто к концу вечера. Я имею 30 работ.
[50:45.600 --> 50:58.000]  Проблема. Это БФС. DX это другое, мы пройдем его попозже. Понятно с БФС, что мы сделали?
[50:58.000 --> 51:12.840]  Понятно, как мы доказали, что это корректно. Все смогут это сделать. Конечно. Ну без доказательства
[51:12.840 --> 51:20.760]  я скажу, что ты не знаешь, что алгоритм вообще корректен. Ты мне будешь писать его,
[51:20.760 --> 51:27.400]  во-первых, на листике. Для того, чтобы проверить, что ты умеешь писать код, у тебя будет контест.
[51:27.400 --> 51:34.520]  Вот. На контестах ты показываешь свое умение писать код. А все-таки теоретическая база алгоритмов
[51:34.520 --> 51:40.600]  тоже тебе нужна. Вот. И тебе нужно доказать, что это работает корректно. Иначе потом в дальнейшем
[51:40.600 --> 51:45.480]  ты не сможешь доказывать, что у тебя корректно вообще работает что-либо. Что тоже не очень хорошо.
[51:45.480 --> 51:51.640]  Конечно, сейчас это решается тем, что миллион тестов у вас существует. Вы напрот пока не
[51:51.640 --> 51:57.840]  протестируете, ничего не выкатите. Но это тоже работает не всегда. Нужно видеть. Но часть всего
[51:57.840 --> 52:06.840]  баги просто именно с точки зрения архитектуры какие-нибудь есть. С точки зрения кода. С БФС все ясно.
[52:06.840 --> 52:17.320]  Хорошо. Тогда давайте усложнять задачу. Смотреть, что у нас есть. Давайте возьмем
[52:17.320 --> 52:24.000]  взвешенные графы. Что такое взвешенные графы? Это значит, у каждого ребра у нас есть какой-то вес.
[52:24.000 --> 52:32.480]  Вот. И от этого будем отталкиваться. Первое рассмотрим 0 как граф. Ой, 0,1 граф. Значит, у вас
[52:32.480 --> 52:37.880]  каждое ребро имеет вес либо 0, либо 1. Ну, грубо говоря, у вас есть либо телепортация, либо вы
[52:37.880 --> 52:47.680]  ножками ходите. Ну, как бы, что поделать. Здесь нужно понять, а что нам делать.
[52:47.680 --> 53:00.960]  Да? Ты уверен? Представим следующее.
[53:00.960 --> 53:12.520]  Проверять это еще раз, а тогда мы должны класть все ребра постоянно.
[53:17.680 --> 53:29.760]  Ну, это не совсем мне нравится идея. Ну вот представим такое. У меня была вот эта вот
[53:29.760 --> 53:52.120]  нулевая вершинка. 1, 2, 3. Нулевая 0. 1, 1, 2, 3. 0, 0. Что-то не так. Должно быть везде по нулям.
[53:52.120 --> 53:58.720]  Согласен? Вот. Находить минимум не всегда корректно. Просто ты будешь обрывать абсолютно
[53:58.720 --> 54:06.960]  всех тогда. А представь еще, тем более, следующую картину. Что ты пришел вот в эту единичку,
[54:06.960 --> 54:15.120]  поставил неверное, а у тебя здесь еще одна вершина была. И ты сказал, что до нее расстояние
[54:15.120 --> 54:21.440]  осталось 2. Вот я, предположим, после единички там что-нибудь поставил бы. Мог я так? Ну,
[54:21.440 --> 54:25.400]  точнее, не после единички, а вот после двоечки бы это выглядело так, что здесь было бы не 3,
[54:25.400 --> 54:33.400]  а давай здесь 5 номер. Ты бы сделал здесь 5, потому что я в единицу-то пошел, смотрю на ее соседей,
[54:33.400 --> 54:56.720]  ставлю здесь 2, а здесь у меня станет уже 3. Как? Что значит сначала по нулям?
[55:04.120 --> 55:14.520]  Так, как это достичь? А как мне этого достичь?
[55:14.520 --> 55:22.840]  Циклом прохожусь по всем соседям. У меня там все единички.
[55:22.840 --> 55:30.640]  Ну нет, еще раз.
[55:30.640 --> 55:41.800]  Я вначале обработаю это, станет 2.
[55:41.800 --> 55:54.880]  Куда добавлять? А? Я их так добавляю.
[55:54.880 --> 56:11.920]  Ничего не понял. Добавляем.
[56:11.920 --> 56:21.880]  Ну, они опять будут стоять всех после всех.
[56:21.880 --> 56:38.240]  Сейчас, подождите, BFS у меня все-таки работает вот так, вот так, а потом вот это и вот это. Да? Ну,
[56:38.240 --> 56:55.840]  в чем противоречит твоя логика сейчас? Мы так не можем, это не BFS. BFS ходит по всем соседям.
[56:55.840 --> 57:07.240]  Хорошо, ладно, но это больше похоже на DFS. Узнаем попозже? Еще есть идеи?
[57:07.240 --> 57:17.280]  Тоже не поможет. Вот аналогичный пример здесь.
[57:17.280 --> 57:38.600]  Еще. У нас есть очередь, есть еще. Давайте подумаем о деке. Что мы можем сделать такого в деке,
[57:38.600 --> 57:45.560]  что не можем делать в очереди? Отлично. А теперь смотрите, что я должен сделать с нулевыми,
[57:45.560 --> 57:54.680]  чтобы они выглядели правильно. Правда, будет выглядеть не как BFS, что мы слоями ходим,
[57:54.680 --> 58:02.720]  но в то же время, если мы будем добавлять сначала, мы не рушим всю логику того, что у нас как бы в
[58:02.720 --> 58:17.080]  начале идет расстояние coin D, потом D plus 1. Логика остается ровно такая же. Да? Он построен не
[58:17.080 --> 58:22.400]  совсем на массивых указателях, он построен на циклическом буфере. У вас есть реализованный дек?
[58:22.400 --> 58:35.080]  У вас есть STD-дек? Все зависит от того, успеть было от к вам контейнеры рассказать или нет. Это
[58:35.080 --> 58:47.000]  другой вопросик. Ну он успеет вам рассказать? Ну тогда, думаю, да. Мы подумаем еще, но думаю,
[58:47.000 --> 58:56.440]  да. Смотрите, суть именно в этом, что вы нулевые вершины ставите в начало, единичные ставите в
[58:56.440 --> 59:02.360]  конец, нулевые грубо говоря, приоритетно рассматриваете. И тогда ходите действительно по нулевым.
[59:02.360 --> 59:09.160]  Просто их нельзя именно в той кучке, как ты сказала, что мы смотрим на нулевую и от нее все нулевой
[59:09.160 --> 59:21.040]  смотрим. Что если будет еще разветвление? Можем. Проблема в том, что будет у нас вот так еще нулевое и еще нулевое.
[59:21.040 --> 59:31.520]  А как мы их запишем? Как мы пройдемся? Я же потом должен раскрутиться по твоей логике назад и идти обратно.
[59:39.160 --> 59:53.480]  Я не понял тогда. Да. Хорошо, если напишешь, типа, тогда в этом случае ты можешь, напиши мне в ВЛС просто,
[59:53.480 --> 01:00:00.960]  тогда и скинь типа посылку. Мне интересно понять, что ты хочешь. Может быть, я не понимаю. Ну или просто
[01:00:00.960 --> 01:00:16.400]  после подойдем. Вот. Ну и как бы здесь мы это все с вами делаем. Вот. Окей? Понятно? Что не понял?
[01:00:16.400 --> 01:00:46.320]  Какой вопрос? Что не понятно? Какой из шагов? Давайте еще раз. Еще раз у нас есть 0,1 градусов.
[01:00:46.320 --> 01:00:55.920]  Мы решаем аналогично БФС, ровно так, как было. Единственное, что мы будем использовать не очередь, а дек.
[01:00:55.920 --> 01:01:04.680]  И все вершины, до которых нам идти через нулевые ребра, мы кладем в начало. А все вершины, до которых нам нужно идти
[01:01:04.680 --> 01:01:24.480]  с расстоянием 1, мы кладем в конец. Да. Самое начало дека, по сути своей. Вы когда будете доставать,
[01:01:24.480 --> 01:01:31.200]  смотрите, когда вы рассматриваете какую-то вершину В, вы достаете ее сначала, из самого начала. То есть
[01:01:31.200 --> 01:01:38.560]  еще раз. У вас есть какая-то вот эта вот очередь. Вот твоя вершина В. Ты сначала ее достал, а после этого
[01:01:38.560 --> 01:01:46.880]  ты смотришь на всех соседей данной вершинки и говоришь, ага, вот до этой вершины у меня 0 и до этой
[01:01:46.880 --> 01:01:51.680]  0. Значит вот эту нулевую я ставлю сюда, вот эту нулевую оставлю сюда, а вот эту единицу ставлю сюда.
[01:01:51.680 --> 01:02:03.440]  Понятно? Будем сразу обрабатывать, да. Ну как только мы свои закончили, да, мы сразу будем обрабатывать их.
[01:02:03.440 --> 01:02:10.240]  Но в этом нет никаких противоречий. По сути нулевые вершины, нулевые ребра, что означает, что это все
[01:02:10.240 --> 01:02:15.800]  склеивается между собой? Понятно? Поэтому это ровно то же самое, что нам необходимо.
[01:02:15.800 --> 01:02:33.080]  Но в любом случае получится пути только в случае, если вы закончите весь БФС. Что-то ты смеешься, я боюсь, что ты что-то не понял.
[01:02:33.080 --> 01:02:58.760]  Да, но почти наверное у тебя никогда не будет чисто нулевого пути. У тебя будет где-нибудь единичка по серединке.
[01:02:58.760 --> 01:03:05.080]  Мы хотим найти расстояние от одной вершины до всех остальных.
[01:03:05.080 --> 01:03:21.720]  Смотря что ты хочешь. Еще раз. У тебя может быть граф 0,1. Может быть невзвешенный граф, мы считаем,
[01:03:21.720 --> 01:03:28.400]  что все ребра имеют вес 1. Может быть граф 0,1. Тогда в этом случае вам необходимо говорить о том,
[01:03:28.400 --> 01:03:34.720]  что вам нужно как-то переобработать это все, потому что вы должны сказать, что до этой вершины расстояние
[01:03:34.720 --> 01:03:53.720]  все-таки 0, а не 1. Давайте перечерчу. Если бы мы делали просто БФС, то вот в этом бы случае у нас было бы так,
[01:03:53.720 --> 01:03:59.160]  что вот из этой нулевой вершины здесь расстояние 1, здесь расстояние 0, здесь расстояние 0, все.
[01:03:59.160 --> 01:04:08.520]  Потому что я бы смотрел вот это, вот это, вот это. И это была бы проблема. Мне нужно сначала вот так пройтись.
[01:04:08.520 --> 01:04:21.000]  Вот это 0, вот это единичка. У меня здесь расстояние, ну типа вот 0,1 граф.
[01:04:21.000 --> 01:04:32.760]  Я пытаюсь понять вопросики. Еще один. Хороший вопрос. А как ты думаешь, почему?
[01:04:32.760 --> 01:04:46.440]  Ну смотрите, в начале же, в начале же мы говорили, что у нас массив расстояние, вот этот D,
[01:04:46.440 --> 01:04:57.960]  он бесконечностями заполнен. Да? И мы говорили о том, что если мы не посетили вершину, то мы, а означает, что там лежит бесконечность.
[01:04:57.960 --> 01:05:10.760]  Теперь я говорю нет. Нужно сделать что-то другое. И мы делаем следующее, что мы говорим, что Dу плюс вес нашего ребра,
[01:05:11.720 --> 01:05:23.800]  давайте так, dv, vu, он должен быть меньше, чем Dу. Что из этого, что означает?
[01:05:26.840 --> 01:05:37.960]  Это расстояние от той вершины, где я иду. Вот это принимает значение, какое? 0,1. А вот это, ну какое-нибудь.
[01:05:38.920 --> 01:05:43.960]  Если я нашел путь меньше, то я должен переделать. Почему это здесь важно?
[01:05:43.960 --> 01:06:09.880]  Ну в действительности у вас будет ровно вот этот же пример. Смотрите, почему это нужно?
[01:06:09.880 --> 01:06:24.920]  А я же как делаю DFS? Ой, ну я делаю BFS, прошу прощения. Я иду просто по соседним вершинам. Мне же никто не говорит,
[01:06:24.920 --> 01:06:31.760]  какой порядок соседних вершин, правильно? Представим, что у меня вот есть нулевая вершинка. Вот 0 здесь есть,
[01:06:31.760 --> 01:06:41.800]  да? Я обрабатываю всех его соседей, ну расстояние 0. Я обрабатываю вершину 1 сначала, вершине 1 какое
[01:06:41.800 --> 01:07:03.960]  расстояние будет? 1. А вершине 2? 0. Ой, да. Вот 0, 0 я отсюда убираю, по сути. У меня здесь становится 2,
[01:07:03.960 --> 01:07:15.400]  с состоянием 0. И из 2 я должен прийти куда? В 3. Ну то есть у меня 2 здесь заменится на 3, будет опять 0. А из 3 я куда должен прийти?
[01:07:15.400 --> 01:07:29.200]  А у меня там уже есть единичка. Понятно? То есть из-за этого порядка у нас может быть баг. Вот и все. Теперь
[01:07:29.200 --> 01:07:50.360]  понятно на вопрос почему? Еще вопросы есть? 0.1 BFS понятно? Что еще раз? Тебе как ответить,
[01:07:50.360 --> 01:08:02.320]  формально или нет? Формально тогда тут написано не очень правильно. Эта весовая функция, она идет из пар,
[01:08:02.320 --> 01:08:11.920]  ну из ребра в число. Вот, это функция просто. Но здесь написано вывод, по-хорошему нужно две скобки
[01:08:11.920 --> 01:08:21.440]  указать. Тогда это будет от ребра куда-то. Вот, чтобы математики не ругались. То есть да, в действительности как бы,
[01:08:21.440 --> 01:08:33.720]  ну если ты хочешь прям вот прям полностью, тогда должно быть записано вот так. Ну это по сути из множества
[01:08:33.720 --> 01:08:56.640]  ребер чиселки 0.1. Вот это есть функция. Да, он либо 0, либо 1. Вопросы еще есть? Либо я как-то непонятно
[01:08:56.640 --> 01:09:06.480]  рассказываю, либо это новенькое. Презентацию я, кстати, за день выложил. Она вчера появилась. Кто-нибудь видел ее?
[01:09:06.480 --> 01:09:22.120]  Ну вот, понимаю. Ладно, это не конец. Представьте, что у меня не 0.1 граф, а 0.k граф. Как жить? К число, то есть у вас
[01:09:22.120 --> 01:09:34.720]  0.k означает, что у вас все целые числа. До к, да. А как вставлять в серединку-то?
[01:09:34.720 --> 01:09:52.360]  У нас даже на 0.1 тогда так не сработает, если ты в конец вставляешь. Нужно какое-нибудь гениально
[01:09:52.360 --> 01:10:10.760]  простое решение. Первый способ вы должны придумать. Ладно, второй. Так, отлично. На какие? Да, если вдруг
[01:10:10.760 --> 01:10:20.760]  вы встречаете ребро с весом больше чем единичка, то есть 2-3 до к, давайте каждое это ребро закинем
[01:10:20.760 --> 01:10:41.960]  туда, а фиктивные вершины. Я это ребро превращу в следующее. Давайте еще порисуем. Возможно,
[01:10:41.960 --> 01:10:52.440]  я сегодня, конечно, много вопросов вам просто задаю, но представьте, что у меня из в в у ребро
[01:10:52.440 --> 01:11:00.920]  весом к. Что я должен сделать? Я хочу сделать примерно следующее. Если у меня здесь к, сколько
[01:11:00.920 --> 01:11:21.000]  здесь должно быть вершин? К-1. Вот я введу какие-нибудь вершинки, ну не знаю там, т0, т1,
[01:11:21.000 --> 01:11:34.320]  т, что у нас там, к-2. И скажу, что все эти ребра имеют вес 1. Тогда какой задачи я свел?
[01:11:34.320 --> 01:11:45.920]  Предыдущий к 0.1 bfs. Вопрос, а за сколько это работает? Ой, тут все-таки написано, я это,
[01:11:45.920 --> 01:11:59.240]  я уже этого не помню. За сколько работает? Не совсем. Сумма ребер плюс сумма вершин.
[01:11:59.240 --> 01:12:07.200]  Ну, по сути своей да, но только, ну, давайте сверху уж оценим, скажем, что это к,
[01:12:07.280 --> 01:12:13.600]  плюс в. А почему это так? Ну, как бы мы говорим о том, что каждое ребро мы разбьем не более чем
[01:12:13.600 --> 01:12:22.400]  к минус, ну, не больше, чем на к минус одну вершинку. Ну, к-1e. Плюс у меня еще было в
[01:12:22.400 --> 01:12:33.960]  дополнительно, но это как бы к. Ну, в принципе, можно. Проблема в том, что сумма длин ребер,
[01:12:33.960 --> 01:12:44.360]  ну ладно, ну так. Тебе очень не нравится, видимо, то, что я когда-то сказал, что мне нужны степени
[01:12:44.360 --> 01:12:50.240]  вершины. Хорошо. Ну, в действительности, да, сложности к, плюс в этого достаточно. То есть,
[01:12:50.240 --> 01:12:57.320]  в такой случае достижим сам по себе и мы с ним можем работать. Окей? Понятно, как мы это сделаем?
[01:12:57.320 --> 01:13:09.480]  Давайте придумаем второй способ. Да. Извините. Второй способ не нужен. Я хочу быстрее. к,
[01:13:09.480 --> 01:13:19.480]  плюс в это достаточно долго. Я надеюсь, вы это понимаете. Если у меня большие-большие ребра.
[01:13:27.320 --> 01:13:43.560]  Смотри, что-то хочет делать рекурсии, но нет. Это уже DFS-сет не работает.
[01:13:43.560 --> 01:14:00.920]  Я, давайте, дам подсказку. Нужно создать несколько очередей.
[01:14:00.920 --> 01:14:15.960]  Если ты сразу скажешь, как сделать с к очередями, то, считай, я тебе поставлю плюс один балл на экзамене.
[01:14:15.960 --> 01:14:43.760]  Скажешь? Сразу. Ты мне скажи смысл. Видимо, нет. Хорошо, ладно. Давайте вернемся к задаче.
[01:14:43.760 --> 01:15:12.560]  Да. Да, по сути, это первый вариант.
[01:15:12.560 --> 01:15:21.440]  Давайте мы сделаем примерно следующее. Вот самое начало. Пусть у меня будет kv-1 очередь.
[01:15:21.440 --> 01:15:33.840]  Почему kv-1? Это максимальное расстояние, которое возможно. И пусть у меня очереди нулевая,
[01:15:33.840 --> 01:15:47.240]  первая, первая, и так далее. Вот. И в случае, когда мы берем какую-то и-ту вершинку с расстоянием,
[01:15:47.240 --> 01:15:59.760]  там, не знаю, равное какой-нибудь c, и смотрю на всех ее соседей, на всех соседей вершины и,
[01:16:00.360 --> 01:16:09.120]  ну, какую-нибудь вершину у. И до нее расстояние пусть будет t. Тогда я добавлю эту вершину у
[01:16:09.120 --> 01:16:26.280]  в очередь от c плюс t. Почему так? Потому что благодаря этому я буду смотреть. А дальше,
[01:16:26.280 --> 01:16:31.800]  как я смотрю на все эти очереди? Я смотрю на все эти очереди по очереди. Здесь как бы другого
[01:16:31.800 --> 01:16:36.360]  варианта не будет. То есть вы смотрите сначала на нулевое, потом на все первое, на второе,
[01:16:36.360 --> 01:16:46.760]  и так далее. У вас все идет вниз. И тогда согласны, что я вершину у рассмотрю после того,
[01:16:46.760 --> 01:16:55.320]  как у меня расстояние, ну, вот всех предыдущих, у них расстояние будет меньше, чем у. Согласны?
[01:16:55.320 --> 01:17:09.000]  То есть оно вставится вот куда-нибудь вот сюда. Максимальный путь какой? Максимальное расстояние
[01:17:09.000 --> 01:17:31.360]  у графа. Почти. А есть ли у меня граф взвешенный? Так. Вопрос еще есть? Какой? Давайте еще раз.
[01:17:31.360 --> 01:17:42.040]  Я вставляю в очередь равную длины пути. Это максимальный путь, который возможен. То есть
[01:17:42.040 --> 01:17:53.920]  невозможно расстояние больше. Ну, смотрите, я превратил k e плюс v в k v плюс e скорость алгоритма.
[01:17:53.920 --> 01:18:14.480]  Хорошо. Или какой вопрос? Как очереди используем? Очереди. Я только что объяснил. В очередь с
[01:18:14.480 --> 01:18:22.160]  индексом равным расстоянию до моей новой вершинки, вот до соседа у, к примеру. Пусть у меня расстояние
[01:18:22.160 --> 01:18:32.560]  до вершины и, до вершины и равно c, у нее есть сосед, до которого расстояние t от вершины и. То
[01:18:32.560 --> 01:18:38.800]  есть расстояние до у c плюс t здесь считается, правильно? Я говорю, давайте я в очередь с индексом
[01:18:38.800 --> 01:18:50.440]  c плюс t добавлю свою вершину у. Вот. Тогда я до этой вершины, я буду обрабатывать очереди в порядке
[01:18:50.600 --> 01:18:57.680]  индексов и вот рассматриваю полностью, что там происходит. Тогда в этом случае рассматривая их
[01:18:57.680 --> 01:19:07.000]  в порядке очереди, я скажу, что я обработаю до моей вершины у те вершины, у которых расстояние меньше.
[01:19:07.000 --> 01:19:15.480]  Почему я делаю таким образом? Потому что, если у меня расстояние до вершины меньше, до у, к
[01:19:15.480 --> 01:19:20.480]  примеру, и у меня есть какие-то еще вершины, до которых расстояние было меньше, я должен рассматривать
[01:19:20.480 --> 01:19:27.160]  здесь вот какой-нибудь вот такой вот крючок. То есть, предположим, что у меня здесь c плюс t,
[01:19:27.160 --> 01:19:33.360]  а здесь у меня расстояние, не знаю, там c плюс 1, а t больше единички. Я должен рассмотреть эту вершину
[01:19:33.360 --> 01:19:49.720]  раньше. Ну подожди, когда ты рассматриваешь отелей, ты ставишь дист, правильно? Массив дистов у тебя
[01:19:49.720 --> 01:20:00.160]  будет в итоге? Так, массиве дистов будет хранить с расстояния? Вершина от какой-то конкретной?
[01:20:00.160 --> 01:20:20.680]  Да, и запихиваем в очередь ее. Почему? А вот здесь вот на самом деле, когда вы будете обрабатывать всю
[01:20:20.680 --> 01:20:27.240]  очередь, вы не можете заранее сказать, есть у вас такая вершина в очереди или нет. Такого варианта,
[01:20:27.240 --> 01:20:32.880]  к сожалению, здесь нет. Вы просто их записываете в очередь и смотрите расстояние у них получается
[01:20:32.880 --> 01:20:40.600]  нужно или нет. То есть, одна вершина может быть хранится там, не знаю, в пяти очередях. Может
[01:20:40.600 --> 01:21:07.840]  быть такое? Может быть. Так, а дальше как? Я пришел, не знаю, в вершину с весом 5,
[01:21:07.840 --> 01:21:18.640]  к у меня 7. От этой вершины 5 существует еще одна вершина с расстоянием 5. Куда я добавить ее должен?
[01:21:18.640 --> 01:21:28.080]  Пятую? Пятую, тогда я обработаю сразу же. Что неправильно? Какую из очередей из семьи я должен
[01:21:28.080 --> 01:21:48.520]  добавить? Но ты близок, да. Элементик, да. Мы идем по всем этим очередям и смотрим. Если у меня,
[01:21:48.520 --> 01:21:55.920]  я достаю элементы из этой очереди, смотрю, ага, расстояние здесь С плюс Т до этой вершины У. Я
[01:21:55.920 --> 01:22:01.400]  смотрю, а расстояние до этого было меньше или нет? Если меньше, то я пропускаю просто этот шаг.
[01:22:01.400 --> 01:22:13.560]  Если оно было таким же или большим, тогда я записываю это С плюс Т в расстояние У. Чем что?
[01:22:13.560 --> 01:22:26.720]  Еще раз, предыдущая работала за сколько? За КЕ плюс В, правильно? Сколько у меня здесь
[01:22:26.720 --> 01:22:44.280]  очередей? Сколько раз я добавлю сюда элементики? Сколько всего? Почему? Знаю. Один элемент может
[01:22:44.280 --> 01:22:50.040]  быть добавлен несколько раз, да, я не спорю, но сколько раз он может быть добавлен? Степень вершинки,
[01:22:50.040 --> 01:23:00.360]  правильно? Сумма входящих степеней вершин. Сумма входящих степеней вершин чему равна? Сумма всех.
[01:23:00.360 --> 01:23:15.480]  Е. Е. Просто Е. Сколько, если я добавляю все вершины, а если сумма всех степеней Е,
[01:23:15.480 --> 01:23:22.560]  то сколько раз я добавлю все вершины? Сюда, в очереди. Е. Теперь смотри, я каждую вершину
[01:23:22.560 --> 01:23:30.920]  обрабатываю и обрабатываю за от единички. Да, мне сложно. Согласен? Отлично. Все должны пройтись.
[01:23:30.920 --> 01:23:40.960]  По КВ минус одной очереди, всего вершин Е, получая свою симптотику КВ, ну, минус один, хорошо, плюс Е.
[01:23:40.960 --> 01:23:50.240]  Е это количество, вот здесь вот элементы возможные.
[01:23:50.240 --> 01:24:10.280]  Опять не успели обрабатывать. Что ж такое? И вниз, и влево. Ну, влево, ой, и вправо,
[01:24:10.280 --> 01:24:19.680]  сколько раз я вправо схожу? Е раз. Согласен? Давай еще раз. А что мы должны с этим сделать?
[01:24:19.680 --> 01:24:26.720]  Почему? Я не в каждой очереди храню Е штучек.
[01:24:26.720 --> 01:24:44.040]  Да, смотри, давай еще раз. Я иду в любую очередь. Хорошо, я иду в любую очередь. Я
[01:24:44.880 --> 01:24:49.740]  убираю этот элемент, смотрю на следующий, убираю этот элемент,rolling этот элемент. Иду
[01:24:49.740 --> 01:24:57.360]  дальше. Обратите по индексу я могу быстро? Иду дальше, убираю эти элементы. Я убираю за вот единички.
[01:25:00.200 --> 01:25:09.040]  Сколько раз уберу элементы? Е раз. Согласен? Сколько раз по индексам должен сходить? Хожу
[01:25:09.040 --> 01:25:18.080]  индексам завод единицы. Сколько раз ты должен сходить по индексам? KV-1. Все. Смотрите, есть
[01:25:18.080 --> 01:25:23.720]  улучшение. Sorry, что чуть-чуть задерживаю. Улучшение, которое говоришь ты, только чуть-чуть другого
[01:25:23.720 --> 01:25:32.040]  характера. Давайте мы не будем хранить KV-очередей. Вот, мы попробуем улучшить память, но не улучшить
[01:25:32.040 --> 01:25:43.960]  время, потому что KV-очередей много. Давайте мы будем хранить K-очередей, но если я нахожусь в
[01:25:43.960 --> 01:25:56.440]  моменте х, ну не знаю, вот 5 я как раз дал. 1, 2, 3, 4, 5, 6, 7. Вот, я нахожусь вот в пятерочке. 0, 1, 2, 3,
[01:25:56.440 --> 01:26:08.360]  нет. 4, 5. Вот. Вот, я нахожусь вот на пятой своей очереди, расстояние 5, к примеру. Я прихожу
[01:26:08.360 --> 01:26:15.920]  к вершине, какой-то U, которая здесь находится, и говорю от этой вершины U до какой-то вершины T
[01:26:15.920 --> 01:26:26.880]  расстояние 5. Куда мне добавить эту вершину T? В действительности, смотрите, согласны ли вы с
[01:26:26.880 --> 01:26:34.280]  тем, что от вершины U я не могу уйти больше, чем на K? То есть, я не могу вернуться в эту же ячейку,
[01:26:34.600 --> 01:26:45.360]  например. Да? Но я могу помещать их вот ниже и потом выше делать. Давайте я буду остатки
[01:26:45.360 --> 01:26:54.320]  отсмотреть от K. То есть, я от каждой вершины все равно не уйду дальше, не приду в тот же остаток,
[01:26:54.320 --> 01:27:01.040]  как минимум. Другие могу, согласны? И чем ближе остаток с точки зрения числа именно вверх идти,
[01:27:01.040 --> 01:27:06.960]  тем это число будет ближе. Согласны? То есть, я не выхожу за его границу. Поэтому,
[01:27:06.960 --> 01:27:22.560]  когда у меня будет 5, а здесь будет 0K6, то что я сделаю? Я сделаю 5 плюс 5 и возьму от этого
[01:27:22.560 --> 01:27:38.640]  остатка деления на 6. Что я получу? 4. Куда я поставлю этот элемент T? Сюда. Вот. А теперь,
[01:27:38.640 --> 01:27:47.520]  смотрите, я должен не просто сделать на 6, я должен на 6 плюс 1. Почему? Потому что если бы я прибавил
[01:27:47.520 --> 01:27:53.240]  6, то я бы попал ровно в эту же ячейку. Согласны? Я должен чуть-чуть расширить и сделать K плюс
[01:27:53.240 --> 01:28:01.440]  одну очередь. Поэтому их будет вот так. Я чуть-чуть расширяю воронку. Потому что сколько у меня
[01:28:01.440 --> 01:28:11.120]  возможно остатка деления на K? K. А мне нужно сделать так, чтобы я не попал в одно и то же.
[01:28:11.120 --> 01:28:29.640]  Да? Сейчас. Раз, два, три, четыре, пять, шесть. А, да. Извините. Шесть. Вот. Вот это вот максимальное
[01:28:29.640 --> 01:28:38.960]  расстояние, которое у меня возможно для 0.6 графа. Это вам нужно будет написать в контест,
[01:28:39.000 --> 01:28:50.640]  если вы хотите получить хорошую оценку. Реализовать это нужно. Если вы хотите оценку. Ну да, ладно.
[01:28:50.640 --> 01:29:03.200]  Хорошо. Относительно, правда. Ну, с точки зрения весов не могу точно сказать. Да, вроде бы так же.
[01:29:03.440 --> 01:29:13.160]  Да, но в этом году у вас еще и будет экзамен по плюсам, по-моему. Вот. Кто-то радостный,
[01:29:13.160 --> 01:29:19.520]  кто-то нет. Сделаем фото. Готово. Ладненько. И я вас отпускаю.
