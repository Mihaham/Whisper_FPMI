[00:00.000 --> 00:18.680]  Всем добрый день. Давайте продолжим разговор про геометрию, которую мы начали разбирать в прошлый раз.
[00:18.680 --> 00:24.920]  Давайте я напомню, что мы занимаемся вычислительной геометрией. В прошлый раз мы рассмотрели большой
[00:24.920 --> 00:34.960]  набор задач, связанный с различными примитивами. Там точки, лучи, линии, отрезки. Немного рассмотрели
[00:34.960 --> 00:40.920]  многоугольники и тому подобное. Я надеюсь, поняли философию того, чего на самом деле мы хотим,
[00:40.920 --> 00:48.840]  и что если вы живете в целом мире, в мире со счастливыми координатами, то в целом
[00:48.840 --> 00:59.280]  вы можете решать большинство задач абсолютно точно. То есть те, которые вам не нужно привлекать
[00:59.280 --> 01:05.760]  с вашим иррациональным вычлением и тому подобное. Мы показали, что большинство задач на самом деле
[01:05.760 --> 01:14.640]  можно решить без всяких приближений, абсолютно точно, даже не используя классы для рациональных
[01:14.640 --> 01:19.760]  чисел и тому подобное. Сегодня в целом мы продолжим заниматься тем же самым, но сегодня у нас будет
[01:19.760 --> 01:28.600]  довольно специфическая тема, потому что сегодня мы занимаемся выпуклыми многоугольниками.
[01:28.600 --> 01:38.640]  Рассмотрим несколько вопросов, связанных с ними. Во-первых, сначала посмотрим на то,
[01:38.640 --> 01:43.400]  как вообще проверить произвольный многоугольник на выпуклу, за какое время это можно сделать.
[01:43.400 --> 01:48.520]  Дальше немного поговорим про то, а зачем вообще это нужно, как можно применять знания о том,
[01:48.520 --> 01:56.640]  что многоугольник выпуклый или нет. И в последней части поговорим про построение выпуклых оболочек.
[01:56.640 --> 02:07.640]  Тоже одна из ключевых задач по алгоритмах. Давайте начнем. Наверное, я не буду открывать
[02:07.640 --> 02:12.080]  какую-то Америку, говорить про то, что такое многоугольник. В общем, на самом деле вполне себе
[02:12.080 --> 02:24.200]  достаточно школьного понимания, что многоугольник называется выпуклым, если при проведении
[02:24.200 --> 02:29.760]  какой-либо прямой вдоль некоторой стороны, если возьмете произвольную сторону, проведете вдоль
[02:30.360 --> 02:36.080]  и так окажется, что все остальные вершины этого многоугольника находятся по одну сторону от данной
[02:36.080 --> 02:43.520]  прямой, то соответственно данный многоугольник мы будем называть выпуклым.
[02:43.520 --> 02:49.200]  Наверное, из этого определения свойства факта про выпуклые многоугольники, наверное, сразу же можно
[02:49.200 --> 02:54.000]  придумать довольно незамысловатый алгоритм того, как можно проверять многоугольник на выпуклость.
[02:54.000 --> 02:59.280]  Действительно, давайте просто-напросто что сделаем. Давайте возьмем произвольную сторону,
[02:59.280 --> 03:10.320]  под тема ConvexityTest, то есть проверка на выпуклость.
[03:10.320 --> 03:23.400]  Ну и первый алгоритм, который мы рассмотрим, это алгоритм, назовем его условно наивный,
[03:23.400 --> 03:33.960]  наивный алгоритм от n², где n предполагается количество вершин многоугольника.
[03:33.960 --> 03:39.040]  Давайте еще, наверное, нужно сказать про то, напомню, как мы представляем многоугольники в памяти,
[03:39.040 --> 03:46.720]  значит памяти мы многоугольники храним в виде набора точек, по 0, по 1, по 2, по 3 и так далее, по 4, по n-1.
[03:46.720 --> 03:52.240]  И при этом предполагаем, ну давайте сначала будем делать такое разумное предположение, что у нас
[03:52.240 --> 03:57.280]  в принципе все точки, они отсортированы, скажем, либо в порядке от подобного уголника по часовой
[03:57.280 --> 04:01.600]  стрелке, либо против часовой стрелки, это на самом деле не важно. Когда будем говорить про выпуклые
[04:01.600 --> 04:07.920]  оболочки, на самом деле мы поймем, что даже если вам данного многоугольника с произвольными, ну если вам
[04:07.920 --> 04:12.760]  данные вершины в произвольном порядке, то их всегда можно упорядочить с помощью довольно простого алгоритма.
[04:12.760 --> 04:23.280]  Так вот, значит, наивный подход заключается в следующем. Ну, собственно, вот как я сказал,
[04:23.280 --> 04:28.400]  по одному из определений выпуклого многоугольника мы говорим, что если мы проведем прямую через
[04:28.400 --> 04:33.040]  произвольного сторону, то все вершины этого многоугольника окажутся по одну сторону. Ну,
[04:33.800 --> 04:39.340]  мы умеем это делать. И мы умеем узнавать какую сторону от прямой находится та или иная точка.
[04:39.340 --> 04:42.500]  Собственно, этим мы занимались прошлый раз. То есть условно мы говорили, что
[04:42.500 --> 04:46.680]  в зависимости от того, куда вам направил Rider норм 스�емер нормnothing, у вас тогда соответственно при
[04:46.680 --> 04:51.080]  постановке точки в уравнении прямой будет либо положительное число, точнее, неотрицательное число,
[04:51.080 --> 04:54.080]  а либо не положительное число. И вот если для всех точек выполняется это свойство,
[04:54.080 --> 04:59.040]  что при постановке точек в уравнение прямой все значения будут неотрицательные и
[04:59.040 --> 05:02.040]  или неоположительный, то тогда, соответственно, это прямоугольный выплой.
[05:02.040 --> 05:06.040]  Собственно, алгоритм очень простой.
[05:06.040 --> 05:10.040]  Для каждой...
[05:10.040 --> 05:16.040]  Давайте проведем прямую
[05:16.040 --> 05:21.040]  через каждую вершину,
[05:21.040 --> 05:25.040]  через каждую сторону,
[05:25.040 --> 05:30.040]  и проверим,
[05:30.040 --> 05:35.040]  что все вершины
[05:35.040 --> 05:41.040]  находятся в одной
[05:41.040 --> 05:46.040]  полуплоскости
[05:46.040 --> 05:51.040]  относительно
[05:51.040 --> 05:56.040]  этой прямой.
[05:56.040 --> 06:01.040]  Ну, собственно, просто воспользовались определениями.
[06:01.040 --> 06:05.040]  Я думаю, понятно, почему этот алгоритм работает за этот квадрат,
[06:05.040 --> 06:09.040]  потому что у вас, грубо говоря, если сделать набросы к алгоритму,
[06:09.040 --> 06:13.040]  то вы, по сути, перебираете
[06:13.040 --> 06:17.040]  for h in полигон,
[06:17.040 --> 06:20.040]  то я так условно подпишу, что у вас есть некоторый многоугольник,
[06:20.040 --> 06:23.040]  вы перебираете каждую его сторону, каждое его ребро,
[06:23.040 --> 06:29.040]  и дальше, собственно, перебираете for vertex
[06:29.040 --> 06:34.040]  полигон, проверяете, что
[06:34.040 --> 06:38.040]  все вершины
[06:38.040 --> 06:43.040]  находятся по одному сторону
[06:43.040 --> 06:48.040]  от прямой h.
[06:48.040 --> 06:52.040]  Соответственно, я думаю, понятно, что мы перебираем все стороны, перебираем все вершины,
[06:52.040 --> 06:56.040]  и, соответственно, получается двойный цикл, который даёт краски,
[06:56.040 --> 06:59.040]  который краски даёт нам ассиплотику n².
[06:59.040 --> 07:02.040]  Но это, наверное, не очень интересный алгоритм,
[07:02.040 --> 07:05.040]  то есть мы умеем проверять за преднамеренное время
[07:05.040 --> 07:08.040]  выкуплость многугольника, но, наверное, хочется чего-то быстрее,
[07:08.040 --> 07:11.040]  то есть вряд ли, если вам
[07:11.040 --> 07:14.040]  многугольник с, условно, тысячу вершин,
[07:14.040 --> 07:17.040]  хочется тратить миллионы операций на то, чтобы просто проверить выкуплованный или нет.
[07:17.040 --> 07:20.040]  Поэтому давайте подумаем чуть больше
[07:20.040 --> 07:23.040]  и, соответственно, изобретем
[07:23.040 --> 07:26.040]  более хороший алгоритм.
[07:26.040 --> 07:29.040]  Давайте, на самом деле, воспользуемся просто набросом другим определением
[07:29.040 --> 07:32.040]  выкуплости, ну, точнее другим свойствам, да,
[07:32.040 --> 07:35.040]  выкуплости, которое говорит следующее, что
[07:35.040 --> 07:38.040]  многугольник выпуклый
[07:38.040 --> 07:41.040]  тогда и только тогда,
[07:41.040 --> 07:44.040]  когда все внутренние углы...
[07:51.040 --> 07:54.040]  Ну, давайте напишу так,
[07:54.040 --> 07:57.040]  многугольник, сколько хочу, строго выпуклый,
[07:57.040 --> 08:00.040]  если внутренние углы строго меньше,
[08:00.040 --> 08:03.040]  или меньше либо равны, чем 180 градусов.
[08:03.040 --> 08:06.040]  Если все углы строго меньше,
[08:06.040 --> 08:09.040]  180 градусов, многугольник будем называть строго выпуклым,
[08:09.040 --> 08:12.040]  а иначе будем называть его нестрого выпуклым.
[08:12.040 --> 08:15.040]  Точнее, если у него какие-то углы,
[08:15.040 --> 08:18.040]  если есть какой-то развернутый угол,
[08:18.040 --> 08:21.040]  то будем считать, чтобы многугольник нестрого выпуклый.
[08:21.040 --> 08:24.040]  Чем это определение лучше?
[08:24.040 --> 08:27.040]  Лучше оно тем, что, на самом деле, мы таким образом можем
[08:27.040 --> 08:30.040]  провести задачу не к проверке,
[08:30.040 --> 08:33.040]  что мы через сторону проводим прямую и даже смотрим для всех точек,
[08:33.040 --> 08:36.040]  а мы можем ориентироваться только по конкретной вершине,
[08:36.040 --> 08:39.040]  посмотреть на конкретную вершину и, грубо говоря,
[08:39.040 --> 08:42.040]  понимать угол, который она образует с двумя сторонами,
[08:42.040 --> 08:45.040]  он меньше 180 градусов или больше 180 градусов и так далее.
[08:45.040 --> 08:48.040]  Давайте посмотрим формально на то,
[08:48.040 --> 08:51.040]  что я хочу сказать.
[08:51.040 --> 08:54.040]  У вас есть какой-то многоугольник.
[08:54.040 --> 08:57.040]  Что означает, что у него все внутренние углы меньше 180 градусов?
[08:57.040 --> 09:00.040]  Мы начинаем с какой-нибудь стороны, например,
[09:00.040 --> 09:03.040]  по 0 по 1.
[09:03.040 --> 09:06.040]  Рассмотрим эту сторону, даже на самом деле можно смотреть этот вектор.
[09:06.040 --> 09:09.040]  Давайте рассмотрим следующий вектор, следующую сторону,
[09:09.040 --> 09:12.040]  по 1 по 2. Что можно сказать про этот угол?
[09:12.040 --> 09:15.040]  Мы можем сказать про него то, что поворот
[09:15.040 --> 09:18.040]  от вектора по 0 по 1 к вектору по 1 по 2
[09:18.040 --> 09:21.040]  осуществляется в положительном направлении.
[09:21.040 --> 09:24.040]  Внутренний угол меньше 180 градусов,
[09:24.040 --> 09:27.040]  поэтому при повороте от вектора по 0 по 1 к вектору по 1 по 2
[09:27.040 --> 09:30.040]  я получу положительный поворот в терминах ориентирных углов.
[09:30.040 --> 09:33.040]  Что я могу сказать про следующий поворот?
[09:33.040 --> 09:36.040]  Если у меня дан вектор по 1 по 2, я рассмотрю следующий вектор
[09:36.040 --> 09:39.040]  по очереди по 2 по 3.
[09:39.040 --> 09:42.040]  Снова, так как этот угол по определению выпустости должен быть
[09:42.040 --> 09:45.040]  меньше 180 градусов, то снова этот поворот,
[09:45.040 --> 09:48.040]  который я осуществляю от одного вектора к другому,
[09:48.040 --> 09:51.040]  в том самом направлении.
[09:51.040 --> 09:54.040]  Грубо говоря, всякий раз, когда я прохожусь вдоль моего многоугольника,
[09:54.040 --> 09:57.040]  я каждый раз осуществляю поворот в данном случае против шестовой стоялки.
[09:57.040 --> 10:00.040]  Это и означает, что у меня все внутренние углы
[10:00.040 --> 10:03.040]  меньше, чем 180 градусов.
[10:03.040 --> 10:06.040]  Например, давайте я чуть поменяю
[10:06.040 --> 10:09.040]  и сделаю вот такую вот штуку.
[10:09.040 --> 10:12.040]  Допустим, у меня вот такой невыпшенный многоугольник.
[10:12.040 --> 10:15.040]  Вот этот внутренний угол больше 180 градусов.
[10:15.040 --> 10:18.040]  Как я это понимаю? Я это понимаю просто тем, что
[10:18.040 --> 10:21.040]  до этого у меня все повороты осуществлялись против шестовой стрелки,
[10:21.040 --> 10:24.040]  а теперь от вектора по 2 по 3 к вектору по 3 по 4
[10:24.040 --> 10:27.040]  у меня поворот осуществляется против
[10:27.040 --> 10:30.040]  по шестовой стрелки.
[10:30.040 --> 10:33.040]  То есть поворот у меня в терминах ориентированных углов
[10:33.040 --> 10:36.040]  становится отрицательным.
[10:36.040 --> 10:39.040]  Поэтому вот этот просто-напросто вот этот обход
[10:39.040 --> 10:42.040]  вдоль многоугольника
[10:42.040 --> 10:45.040]  может сразу сказать, выпуклый у меня многоугольник или нет.
[10:45.040 --> 10:48.040]  Давайте подведем итог.
[10:48.040 --> 10:51.040]  Алгоритм.
[10:51.040 --> 10:54.040]  Алгоритм.
[10:54.040 --> 10:57.040]  Смотрим
[10:57.040 --> 11:00.040]  на углы
[11:00.040 --> 11:03.040]  ориентированные.
[11:03.040 --> 11:06.040]  Смотрим на ориентированные углы
[11:06.040 --> 11:09.040]  между векторами по 0, по 1,
[11:09.040 --> 11:12.040]  по 2,
[11:12.040 --> 11:15.040]  дальше по 1, по 2,
[11:15.040 --> 11:18.040]  по 2, по 3
[11:18.040 --> 11:21.040]  и так далее.
[11:21.040 --> 11:24.040]  Последнюю что у нас будет?
[11:24.040 --> 11:27.040]  N-2,
[11:27.040 --> 11:30.040]  дальше у нас в конце будет PN-2PN-1
[11:30.040 --> 11:33.040]  и PN-1P0
[11:33.040 --> 11:36.040]  вернемся обратно.
[11:37.040 --> 11:40.040]  То есть просто-напросто посмотрим на последовательные углы,
[11:40.040 --> 11:43.040]  которые образованы каждой из вершин.
[11:43.040 --> 11:46.040]  Посмотрим на последовательные векторочки.
[11:46.040 --> 11:49.040]  И соответственно, если
[11:49.040 --> 11:52.040]  все знаки
[11:52.040 --> 11:55.040]  давайте скажем больше
[11:58.040 --> 12:01.040]  все ориентированные углы
[12:02.040 --> 12:05.040]  одного знака
[12:05.040 --> 12:08.040]  одного знака
[12:08.040 --> 12:11.040]  то выпукует.
[12:11.040 --> 12:14.040]  Иначе
[12:14.040 --> 12:17.040]  иначе нет.
[12:17.040 --> 12:20.040]  То есть все довольно просто
[12:20.040 --> 12:23.040]  и прозаично.
[12:23.040 --> 12:26.040]  Просто-напросто смотрим на значение,
[12:26.040 --> 12:29.040]  на величину, точнее на знак угла
[12:29.040 --> 12:32.040]  между последовательными вершинами,
[12:32.040 --> 12:35.040]  точнее между векторами, образованные последовательными.
[12:35.040 --> 12:38.040]  Вопрос, мы должны заранее знать,
[12:38.040 --> 12:41.040]  что самопересечений нет в этом случае?
[12:41.040 --> 12:44.040]  Опять же мы предлагаем,
[12:44.040 --> 12:47.040]  что многоугольники у нас идут без самопересечений
[12:47.040 --> 12:50.040]  и кажется, что кругляк многоугольники простые.
[12:50.040 --> 12:53.040]  В нашем контесте тоже речь идет
[12:53.040 --> 12:56.040]  про простые многоугольники.
[12:56.040 --> 12:59.040]  И да, нет.
[12:59.040 --> 13:02.040]  Мы рассматриваем только простые многоугольники.
[13:02.040 --> 13:05.040]  Тут соответственно возникает два вопроса.
[13:05.040 --> 13:08.040]  Алгоритм простой,
[13:08.040 --> 13:11.040]  но есть два вопроса.
[13:11.040 --> 13:14.040]  Первый вопрос заключается в следующем.
[13:14.040 --> 13:17.040]  Как узнать знак поворота,
[13:17.040 --> 13:20.040]  который образован двумя сторонами?
[13:20.040 --> 13:23.040]  Это скорее вопрос в предыдущей лекции.
[13:23.040 --> 13:26.040]  Как мы определяем знак ориентированного угла?
[13:43.040 --> 13:46.040]  Векторное произведение.
[13:46.040 --> 13:49.040]  Тут не нужно прибегать никаким арксинусам,
[13:49.040 --> 13:52.040]  рактангенсам и тому подобное.
[13:52.040 --> 13:55.040]  Вот.
[13:55.040 --> 13:58.040]  Вот.
[13:58.040 --> 14:01.040]  Смотрим на знак этого самого векторного произведения.
[14:01.040 --> 14:04.040]  И соответственно понимаем,
[14:04.040 --> 14:07.040]  что у нас все повороты либо положительные, либо отрицательные.
[14:07.040 --> 14:10.040]  И еще один момент нужно сказать,
[14:10.040 --> 14:13.040]  что если у вас вдруг какой-то поворот оказался нулевым,
[14:13.040 --> 14:16.040]  то векторы стали коллинеарны,
[14:16.040 --> 14:19.040]  то тут уже зависит от задачи.
[14:19.040 --> 14:22.040]  И если вектор не стал равно нулю,
[14:22.040 --> 14:25.040]  то если от вас требуют строгую выпуклость,
[14:25.040 --> 14:28.040]  то ответ нет.
[14:28.040 --> 14:31.040]  Ответ все еще да.
[14:31.040 --> 14:34.040]  Это первый момент.
[14:34.040 --> 14:37.040]  Второй момент, естественно,
[14:37.040 --> 14:40.040]  со сколько это все работает.
[14:40.040 --> 14:43.040]  Я думаю, вы понимаете, что сложить этого алгоритма
[14:43.040 --> 14:46.040]  просто от N работает за чистую линию.
[14:46.040 --> 14:49.040]  У нас есть многоугольник, у которого N-вершин.
[14:49.040 --> 14:52.040]  На самом деле кажется, что это наиболее эффективный алгоритм,
[14:52.040 --> 14:55.040]  потому что сложно ожидать,
[14:55.040 --> 14:58.040]  что у вас найдется какой-то алгоритм,
[14:58.040 --> 15:01.040]  который по произвольному многоугольнику скажет вам,
[15:01.040 --> 15:04.040]  что у него выпукло или нет,
[15:04.040 --> 15:07.040]  просто не посмотрев на все стороны или на все вершины.
[15:07.040 --> 15:10.040]  Вот такой простой алгоритм
[15:10.040 --> 15:13.040]  проверки многоугольника на выпуклость.
[15:13.040 --> 15:16.040]  Нет вопросов, правильно понимаю?
[15:16.040 --> 15:19.040]  Можем идти дальше.
[15:26.040 --> 15:29.040]  Давайте пойдем дальше.
[15:29.040 --> 15:32.040]  Следующим пунктом давайте коротко поговорим про то,
[15:32.040 --> 15:35.040]  где вообще можно применять
[15:35.040 --> 15:38.040]  выпуклые многоугольники.
[15:38.040 --> 15:41.040]  Отлично, мы умеем проверять многоугольник на выпуклость,
[15:41.040 --> 15:44.040]  но зачем это может быть нужно?
[15:44.040 --> 15:47.040]  Я думаю, вы понимаете,
[15:47.040 --> 15:50.040]  что многие алгоритмы,
[15:50.040 --> 15:53.040]  в частности, мы в прошлый раз это обсуждали,
[15:53.040 --> 15:56.040]  что некоторые алгоритмы можно записать гораздо проще
[15:56.040 --> 15:59.040]  и работать гораздо быстрее,
[15:59.040 --> 16:02.040]  если мы точно знаем, что многоугольник не просто простой,
[16:02.040 --> 16:05.040]  но еще и выпуклый.
[16:05.040 --> 16:08.040]  Не нужно рассматривать всякие противные случаи
[16:08.040 --> 16:11.040]  с тупыми углами,
[16:11.040 --> 16:14.040]  и тому подобное, и тому подобное.
[16:14.040 --> 16:17.040]  Точнее, с углами больше, чем 180 градусов.
[16:17.040 --> 16:20.040]  Давайте в качестве примера я приведу классическую задачу,
[16:20.040 --> 16:23.040]  которую мы рассматривали в прошлый раз.
[16:23.040 --> 16:26.040]  Мы рассмотрели в прошлый раз ее решение
[16:26.040 --> 16:29.040]  за линейное время.
[16:29.040 --> 16:32.040]  Давайте я сейчас покажу ту же самую задачу решить
[16:32.040 --> 16:35.040]  в предположении, что у нас многоугольник выпуклый,
[16:35.040 --> 16:38.040]  гораздо более приятное время.
[16:38.040 --> 16:41.040]  Речь идет про задачу проверки
[16:41.040 --> 16:44.040]  проверка
[16:44.040 --> 16:47.040]  принадлежности
[16:50.040 --> 16:53.040]  точки
[16:53.040 --> 16:56.040]  внутренности
[16:56.040 --> 16:59.040]  выпуклого
[16:59.040 --> 17:02.040]  многоугольника.
[17:02.040 --> 17:05.040]  Мы в прошлый раз в конце лекции
[17:05.040 --> 17:08.040]  рассмотрели задачу проверки
[17:08.040 --> 17:11.040]  принадлежности точки
[17:11.040 --> 17:14.040]  просто произволивая многоугольник.
[17:14.040 --> 17:17.040]  Давайте я кратко напомню, что мы делали.
[17:17.040 --> 17:20.040]  Мы просто брали точку и пускали луч
[17:20.040 --> 17:23.040]  в произвольном направлении,
[17:23.040 --> 17:26.040]  дали его в горизонтальном направлении,
[17:26.040 --> 17:29.040]  не было каких-то противных случаев.
[17:29.040 --> 17:32.040]  Считали просто количество пересечений с прямой.
[17:32.040 --> 17:35.040]  Мы в прошлый раз не обсудили этот вопрос,
[17:35.040 --> 17:38.040]  но, я думаю, всем понятно, что этот алгоритм,
[17:38.040 --> 17:41.040]  который мы рассматривали в прошлый раз, работает за линейное время
[17:41.040 --> 17:44.040]  от размера многоугольника.
[17:44.040 --> 17:47.040]  Потому что мы смотрим на луч,
[17:47.040 --> 17:50.040]  и для каждой стороны смотрим, пересекает ли этот луч
[17:50.040 --> 17:53.040]  сторону конкретную или нет.
[17:53.040 --> 17:56.040]  То есть при пересечении луча и отрезка
[17:56.040 --> 17:59.040]  мы можем сделать за о от единицы.
[17:59.040 --> 18:02.040]  Это требует одного векторного
[18:02.040 --> 18:05.040]  и одного скалянного произведения.
[18:05.040 --> 18:08.040]  Тоже рассматривали в прошлый раз.
[18:08.040 --> 18:11.040]  А вот теперь другая задача.
[18:11.040 --> 18:14.040]  Гарантированно нам дан выпуклый многоугольник,
[18:14.040 --> 18:17.040]  и нам нужно проверить, принадлежит ли точка внутренности
[18:17.040 --> 18:20.040]  такого многоугольника или нет.
[18:20.040 --> 18:23.040]  Это линейное время.
[18:23.040 --> 18:26.040]  Значит, как я это буду делать?
[18:26.040 --> 18:29.040]  История такая.
[18:29.040 --> 18:32.040]  Давайте изобразим какой-нибудь выпуклый многоугольник.
[18:32.040 --> 18:35.040]  И возьмем какую-нибудь произвольную точку.
[18:35.040 --> 18:38.040]  Просто можно взять первую точку,
[18:38.040 --> 18:41.040]  которая лежит в массиве вершин.
[18:41.040 --> 18:44.040]  По 1, по 2, по 3, по 4, по 5.
[18:44.040 --> 18:47.040]  Возьмем произвольную точку,
[18:47.040 --> 18:50.040]  например, точку по 0.
[18:50.040 --> 18:53.040]  И давайте мысленно проведем вектора
[18:53.040 --> 18:56.040]  от этой точки до всех остальных вершин.
[18:56.040 --> 18:59.040]  Проведем вектор по 0 по 1, по 0 по 2, по 0 по 3,
[18:59.040 --> 19:02.040]  по 0 по 4, и по 0 по 5.
[19:02.040 --> 19:05.040]  Вот такие вектора.
[19:05.040 --> 19:08.040]  Что можно сказать про эти вектора?
[19:08.040 --> 19:11.040]  Что можно сказать про последовательность этих векторочков?
[19:11.040 --> 19:14.040]  По 0 по 2.
[19:14.040 --> 19:17.040]  По 0 по 1.
[19:17.040 --> 19:20.040]  По 1 по 2.
[19:20.040 --> 19:23.040]  По 2 по 3.
[19:23.040 --> 19:26.040]  Ну там, по n-1.
[19:26.040 --> 19:29.040]  Что я пишу?
[19:29.040 --> 19:32.040]  По 0 по 2.
[19:32.040 --> 19:35.040]  По 0 по 3.
[19:35.040 --> 19:38.040]  По 0 по n-1.
[19:38.040 --> 19:41.040]  Вот есть ли в этой последовательности векторок
[19:41.040 --> 19:44.040]  какое-нибудь хорошее свойство?
[19:44.040 --> 19:47.040]  Замечаете вы его или нет?
[20:01.040 --> 20:04.040]  Ну, например, не знаю,
[20:04.040 --> 20:07.040]  что можно сказать по углу,
[20:07.040 --> 20:10.040]  который образуют эти вектора
[20:10.040 --> 20:13.040]  с направлением вектора по 0 по 1.
[20:19.040 --> 20:22.040]  Может, они все лежат в одной полуплоскости?
[20:22.040 --> 20:25.040]  Они лежат в одной полуплоскости, это да,
[20:25.040 --> 20:28.040]  потому что угольник выпуклый.
[20:28.040 --> 20:31.040]  Давайте в терминах углов.
[20:31.040 --> 20:34.040]  Я смотрю на угол, который образует вектор по 0 по 1,
[20:34.040 --> 20:37.040]  с прямой, которая содержит этот вектор.
[20:37.040 --> 20:40.040]  Дальше смотрю на вектор по 0 по 2, по 0 по 3,
[20:40.040 --> 20:43.040]  именно в таком порядке.
[20:43.040 --> 20:46.040]  Полярный угол увеличивается.
[20:46.040 --> 20:49.040]  Давайте заметим следующую вещь.
[20:49.040 --> 20:52.040]  Мы предполагаем,
[20:52.040 --> 20:55.040]  что так у меня все точки,
[20:55.040 --> 20:58.040]  все вершины многоугольнику упорядочны
[20:58.040 --> 21:01.040]  вдоль какого-то обхода.
[21:01.040 --> 21:04.040]  В данном случае я изобразил
[21:04.040 --> 21:07.040]  против числовой стрелки положительное направление.
[21:07.040 --> 21:10.040]  В принципе, может быть такое,
[21:10.040 --> 21:13.040]  что и в отрицательном направлении.
[21:13.040 --> 21:16.040]  И плюс тот факт, который вы назвали,
[21:16.040 --> 21:19.040]  что у меня все точки находятся в одной полуплоскости,
[21:19.040 --> 21:22.040]  краски дают мне понять то,
[21:22.040 --> 21:25.040]  что все эти вектора
[21:25.040 --> 21:28.040]  уже ассортированы по величине полярного угла
[21:28.040 --> 21:31.040]  относительно вектора по 0 по 1.
[21:31.040 --> 21:34.040]  Заметьте, что все величины углов увеличиваются.
[21:34.040 --> 21:37.040]  Это нам пригодится.
[21:37.040 --> 21:40.040]  Вот это хорошее наблюдение.
[21:40.040 --> 21:43.040]  Давайте запишем отдельно.
[21:43.040 --> 21:46.040]  Вектора
[21:46.040 --> 21:49.040]  расположены
[21:49.040 --> 21:52.040]  в порядке.
[21:55.040 --> 21:58.040]  Возрастание
[21:58.040 --> 22:01.040]  предназначение
[22:04.040 --> 22:07.040]  или еще, может быть, убывание
[22:12.040 --> 22:15.040]  ориентированного угла
[22:15.040 --> 22:18.040]  относительно
[22:18.040 --> 22:21.040]  вектора по 0 по 1.
[22:21.040 --> 22:24.040]  Отлично.
[22:24.040 --> 22:27.040]  Разобрались. Теперь давайте, наконец,
[22:27.040 --> 22:30.040]  посмотрим точку, которая представляет для нас интерес.
[22:30.040 --> 22:33.040]  Давайте возьмем точку,
[22:33.040 --> 22:36.040]  которая лежит где-нибудь здесь.
[22:39.040 --> 22:42.040]  В данном случае она находится внутри многоугольника.
[22:42.040 --> 22:45.040]  Давайте еще раз.
[22:45.040 --> 22:48.040]  Изображу ее здесь.
[22:48.040 --> 22:51.040]  Точка лежит внутри многоугольника
[22:51.040 --> 22:54.040]  или вне многоугольника.
[22:55.040 --> 22:58.040]  Это первый шаг.
[22:58.040 --> 23:01.040]  Второй шаг.
[23:01.040 --> 23:04.040]  Проведем
[23:04.040 --> 23:07.040]  вектор
[23:07.040 --> 23:10.040]  по штриху.
[23:14.040 --> 23:17.040]  Проведем вектор от 0
[23:17.040 --> 23:20.040]  по штриху.
[23:20.040 --> 23:23.040]  Короче говоря, сформируем вектор по 0 по штриху.
[23:23.040 --> 23:26.040]  Смотрите, что я могу сказать.
[23:26.040 --> 23:29.040]  Во-первых, эта точка...
[23:29.040 --> 23:32.040]  Давайте сначала определимся с относительным положением
[23:32.040 --> 23:35.040]  этого самого вектора относительно других векторов.
[23:35.040 --> 23:38.040]  А именно давайте сделаем следующую вещь.
[23:38.040 --> 23:41.040]  Давайте определим... Третий шаг.
[23:43.040 --> 23:46.040]  Определим
[23:46.040 --> 23:49.040]  между какими
[23:50.040 --> 23:53.040]  направлениями...
[23:57.040 --> 24:00.040]  Направлениями я имею ввиду
[24:00.040 --> 24:03.040]  вектора по 0 по 1, по 0 по 2
[24:03.040 --> 24:06.040]  между какими направлениями
[24:06.040 --> 24:09.040]  расположен
[24:09.040 --> 24:12.040]  вектор по 0 по штриху.
[24:12.040 --> 24:15.040]  Снова вопрос вам.
[24:15.040 --> 24:18.040]  Понимаете ли вы, как это можно сделать?
[24:18.040 --> 24:21.040]  Как можно... Смотрите, для точки по штриху
[24:21.040 --> 24:24.040]  я могу сказать, что
[24:24.040 --> 24:27.040]  вектор по 0 по штрих находится между векторами по 0 по 3 и по 0 по 4.
[24:27.040 --> 24:30.040]  Для точки по 2 штриха
[24:30.040 --> 24:33.040]  он находится между векторами по 0 по 2 и по 0 по 3.
[24:33.040 --> 24:36.040]  В целом, если точка находится где-то вот здесь,
[24:36.040 --> 24:39.040]  то я могу сказать, что она находится дальше,
[24:39.040 --> 24:42.040]  чем вектор по 0 по 5.
[24:42.040 --> 24:45.040]  Если точка находится здесь, então unbelievable, что находится дальше, чем по 0 по 1.
[24:45.040 --> 24:50.040]  что это можно сделать эффективным способом, если нам на уголик выпадать.
[24:50.040 --> 24:53.040]  Да, правильно в чате пишут, отлично, действительно bin поиск.
[24:53.040 --> 25:11.040]  Смотрите, из первого пункта следует, что направления отсортированы.
[25:11.040 --> 25:20.040]  А из этого следует, что можно воспользоваться либо lower bound,
[25:20.040 --> 25:26.040]  то есть, по сути, бинарным поиском, либо lower bound и upper bound.
[25:26.040 --> 25:40.040]  Если мы найдем lower bound или upper bound, то по сути мы найдем векторы,
[25:40.040 --> 25:47.040]  которые находятся в смысле ориентированного угла ближе всего к моему вектору.
[25:47.040 --> 25:52.040]  Если я запущу бинарный поиск на этих направлениях для вектора по ноль по штрих,
[25:52.040 --> 25:56.040]  то я получу вектор по ноль по четыре.
[25:56.040 --> 26:01.040]  Я буду понимать, что вектор по ноль по штрих находится между векторами по ноль по четыре и по ноль по три.
[26:01.040 --> 26:07.040]  Потому что по определению upper bound и lower bound, upper bound возьмет, что по ноль по четыре это первый вектор,
[26:07.040 --> 26:10.040]  у которого угол больше, чем по ноль по штрих.
[26:10.040 --> 26:13.040]  То же самое могу сказать про по ноль по два штриха.
[26:13.040 --> 26:19.040]  Отлично. Вроде как разобрались, что мы теперь эффективно...
[26:19.040 --> 26:25.040]  Давайте напишем, что это работает за от log n.
[26:25.040 --> 26:29.040]  До этого первый и второй пункты мы проделали мысленно,
[26:29.040 --> 26:36.040]  а третий пункт мы делали полезную работу, выполнили бинарный поиск.
[26:36.040 --> 26:39.040]  И наконец финальный вопрос.
[26:39.040 --> 26:50.040]  Допустим, мы умеем определять, между какими векторами у меня находится вектор по ноль по штрих.
[26:50.040 --> 26:58.040]  А теперь вопрос, а как понять, лежит ли точка по штрих внутри многоугольника или нет?
[26:58.040 --> 27:04.040]  Как понять, что точка по штрихе лежит внутри многоугольника, а по ноль по два штриха нет?
[27:14.040 --> 27:17.040]  Все, отлично. Проверили, принадлежит треугольнику. Отлично.
[27:17.040 --> 27:33.040]  Четвертое. В пункте три, ну последний пункт, говорим, что в пункте три нашли pi и pi плюс один.
[27:33.040 --> 27:47.040]  Соответственно, из этого следует проверяем принадлежность по штрих треугольнику,
[27:47.040 --> 27:53.040]  по ноль, по и, по и плюс один. Естественно, это занимает от единицы.
[27:53.040 --> 27:57.040]  Я думаю, проверить принадлежность треугольнику вы все можете.
[27:57.040 --> 28:07.040]  Если по ноль по штрих пересекает по три по четыре, то лежит, иначе нет.
[28:07.040 --> 28:15.040]  В целом можно и так проверить пересечение двух отрезков, согласен.
[28:15.040 --> 28:23.040]  Если посмотрим на отрезок по ноль по штрих и отрезок по четыре по три, то если они пересекаются,
[28:23.040 --> 28:29.040]  правда это или нет, ну кажется, что да, если они пересекаются, то соответственно не принадлежит,
[28:29.040 --> 28:35.040]  хотя может лежит на границе, ну это уже зависимость от задачи.
[28:35.040 --> 28:41.040]  А если не пересекаются, то соответственно точка лежит внутри.
[28:41.040 --> 28:45.040]  Можно проверить принадлежность треугольника.
[28:45.040 --> 28:50.040]  Так или иначе, каким бы способом вы не воспользуете, я думаю, вы понимаете, что в данном случае мы свели задачу,
[28:50.040 --> 28:56.040]  к заданию на большом многоугольнике, к заданию на маленьком многоугольнике, ну часто на треугольнике.
[28:56.040 --> 29:06.040]  По сути свели задачу к одному педагогному поиску и поиску и определению принадлежности точки треугольнику.
[29:06.040 --> 29:14.040]  Суммарно алгоритм работает за О от логай.
[29:14.040 --> 29:28.040]  Так, есть ли вопросы по этому алгоритму? Да, надо не забыть, что одно замечание стоит, давайте пока.
[29:28.040 --> 29:37.040]  Ну вроде вопросов нет, тогда у меня к вам есть, тогда есть вопрос у меня к вам, смотрите.
[29:37.040 --> 29:44.040]  Замечание.
[29:44.040 --> 29:55.040]  Ну, смотрите, в бинарном поиске, да, в бинпоиске.
[29:55.040 --> 30:07.040]  А вам необходимо сравнивать,
[30:07.040 --> 30:13.040]  сравнивать углы между собой.
[30:13.040 --> 30:20.040]  Ну, давайте я поясню, что я имею в виду. Вот у меня есть, вот у меня есть вектор по 0 по 1.
[30:20.040 --> 30:29.040]  И понятное дело, чтобы понять, какой из углов больше, то есть условно у меня есть по 0 по штрих,
[30:29.040 --> 30:33.040]  и у меня есть какой-нибудь по 0 по i.
[30:33.040 --> 30:39.040]  Я хочу понять, какой из этих двух углов у меня больше.
[30:39.040 --> 30:49.040]  Ну, давайте если посмотрим на третий пункт, определим между какими направлениями расположен по 0 по штрих.
[30:49.040 --> 30:57.040]  Ну и как бы, когда я сравню, то есть я хочу сравнить ориентированные углы между собой.
[30:57.040 --> 31:04.040]  То есть я хочу сравнить ориентированный угол между 0 по 1 и 0 по штрих, и между 0 по 1 и 0 по i.
[31:04.040 --> 31:11.040]  Давайте обозначу. Я хочу сравнить вот этот угол и вот этот угол между собой.
[31:11.040 --> 31:14.040]  И вот тут смотрите, какой вопрос.
[31:14.040 --> 31:22.040]  Кажется, что когда мы говорили про ориентированные углы, мы всего лишь говорили про то, как определить знак ориентированного угла.
[31:22.040 --> 31:26.040]  То есть мы умеем определять знак ориентированного угла с помощью векторного произведения абсолютно точно.
[31:26.040 --> 31:32.040]  А вот тут мы попадаем в ситуацию, при которой нам нужно сравнить непосредственно сами углы, то есть сами значения углов.
[31:32.040 --> 31:40.040]  И вот тут возникает вопрос. Получается, в этом случае нам нужно уметь вычислять какие-нибудь арксинусы, арктангенсы, углов,
[31:40.040 --> 31:44.040]  соответственно, получать их какое-нибудь радианное представление.
[31:44.040 --> 31:52.040]  И в итоге мы приходим к речью с тем, что я сказал до этого, что все алгоритмы наши стремимся к тому, чтобы все алгоритмы работали абсолютно точно.
[31:52.040 --> 32:02.040]  Вот вопрос. Понимаете ли вы, что углы на самом деле можно сравнивать тоже абсолютно точно, не прибегая к всяким иррациональным вычислениям,
[32:02.040 --> 32:06.040]  арксинусам, аркосинусам, арктангенсам и тому подобное?
[32:06.040 --> 32:14.040]  Понимаете ли вы, как по данной картинке, не по картинке, конечно, как каким-нибудь алгоритмам проверить,
[32:14.040 --> 32:22.040]  что угол, образованный по 0 по 1 по i, угол по 0 по 1 по i, он больше, чем угол по 0 по 1 по штрих.
[32:22.040 --> 32:28.040]  Нужно посмотреть на знак попарного произведения последовательных векторов.
[32:28.040 --> 32:36.040]  Знак попарного произведения, я не совсем понимаю, что вы говорите, но на знак векторного произведения действительно нужно будет посмотреть.
[32:36.040 --> 32:38.040]  Но вот на знак какого произведения?
[32:44.040 --> 32:58.040]  Знак какого векторного произведения даст мне ответ на вопрос, какой из углов больше?
[32:58.040 --> 33:06.040]  П1 по штрих и по штрих по i.
[33:06.040 --> 33:10.040]  Я на самом деле не согласен.
[33:10.040 --> 33:22.040]  Скорее всего надо посмотреть на угол между P0 по i и разностью векторов P0 по i и P0 по штрих.
[33:22.040 --> 33:28.040]  Вот это может сработать.
[33:28.040 --> 33:30.040]  Давайте сейчас к этому вернемся.
[33:30.040 --> 33:34.040]  Почему мне не нравится вот такой угол?
[33:34.040 --> 33:38.040]  P1 по штрих и по штрих по i.
[33:38.040 --> 33:46.040]  Просто потому что вы предлагаете вот такие углы, вот такие вот вектора рассмотреть.
[33:46.040 --> 33:54.040]  Но в целом ничто не мешает вот этому вектору P0 по i быть очень длинным.
[33:54.040 --> 33:56.040]  И тогда он окажется здесь.
[33:56.040 --> 34:00.040]  И соответственно угол уже будет в данном случае отрицательным.
[34:00.040 --> 34:04.040]  Хотя мы понимаем, что от длины вектора направление не должно зависеть.
[34:04.040 --> 34:06.040]  Тут у вас получается, что зависит.
[34:06.040 --> 34:14.040]  Поэтому такой план не подойдет.
[34:14.040 --> 34:28.040]  То, что сказал Голос, видимо, посмотреть на знак между P0 по i и разностью по i по штрих.
[34:28.040 --> 34:34.040]  По-моему, тут такая же ситуация, кажется.
[34:34.040 --> 34:40.040]  Вот это, кстати, может подойдет.
[34:40.040 --> 34:42.040]  Надо подумать.
[34:42.040 --> 34:50.040]  Сейчас P1 по 0, P4 по 0, P4 по 0, P1 по i по 0.
[34:50.040 --> 34:52.040]  Давайте упростим задачу.
[34:52.040 --> 34:56.040]  Давайте я скажу, как это проще всего сделать.
[34:56.040 --> 35:00.040]  Проще всего посмотреть всего лишь на одно векторное произведение.
[35:00.040 --> 35:10.040]  Векторное произведение P0 по штрих и P0 по i.
[35:10.040 --> 35:16.040]  То есть, грубо говоря, достаточно посмотреть на знак вот этого угла.
[35:16.040 --> 35:24.040]  Вы согласны, что если я знаю знак угла между P0 по штрих и P0 по i, я знаю, какой направлений у меня больше.
[35:24.040 --> 35:32.040]  Если поворот рассчитывается в положительном направлении, то, соответственно, P0 по i находится дальше, чем P0 по штрих.
[35:32.040 --> 35:34.040]  А если знак будет отрицательный?
[35:34.040 --> 35:38.040]  Давайте я просто другую картинку нарисую.
[35:38.040 --> 35:54.040]  Если у меня ситуация будет какая-то такая, P0 по 1, тут P i, а тут P штрих, то, соответственно, знак поворота от P0 по штрих до P0 по i будет отрицательным.
[35:54.040 --> 36:06.040]  И это будет означать, что на самом деле у меня угол P0 по i находится меньше, чем угол, который образует вектор P0 по штрих.
[36:06.040 --> 36:08.040]  Убедил? Понятно.
[36:13.040 --> 36:24.040]  Ну, надеюсь. Давайте нормально пропишу, что смотрим на знак этого произведения.
[36:24.040 --> 36:48.040]  И если обход многоугольника осуществляется в положительном направлении и знак...
[36:48.040 --> 37:16.040]  Давайте так скажем, что если знак обхода многоугольника совпадает со знаком произведения,
[37:16.040 --> 37:25.040]  то мы говорим, что P0 по i больше, чем P0 по штрих.
[37:25.040 --> 37:29.040]  Ну, все, а иначе меньше.
[37:29.040 --> 37:35.040]  Ну, меньше ли дровно, в зависимости от того, 0 или 0.
[37:35.040 --> 37:38.040]  Ну, что значит знак обхода?
[37:38.040 --> 37:45.040]  То есть тут я везде предполагал, что у меня обход многоугольника осуществляется в положительном направлении, то есть против числовой стрелки.
[37:45.040 --> 37:55.040]  Ну, естественно, вы понимаете, что если вдруг у меня вершина многоугольника отсортирована по числовой стрелке, то тогда у меня знаки поворота будут отрицательными.
[37:55.040 --> 38:02.040]  И соответственно, в этом случае мне нужно будет смотреть на отрицательный знак.
[38:06.040 --> 38:09.040]  Все понятно?
[38:09.040 --> 38:11.040]  Ну да, понятно.
[38:11.040 --> 38:13.040]  Отлично. Замечательно.
[38:14.040 --> 38:20.040]  Так, давайте подведем небольшой промежуточный итог и, соответственно, пойдем на 5-минутный перерыв.
[38:20.040 --> 38:29.040]  Мы коротко вспомнили про то, что такое многоугольники, рассмотрели простейший алгоритм проверки на выпуклость, но простейший и эффективнейший на самом деле.
[38:29.040 --> 38:41.040]  Ну и, надеюсь, я сейчас убедил, что выпуклость играет роль, то есть если вдруг у вас многоугольник выпуклый, то вы какие-то задачи можете решать гораздо эффективнее.
[38:41.040 --> 38:49.040]  Например, проверять принадлежность к точке многоугольника вместо линейного алгоритма, можно применить алгоритм, который работает за log n.
[38:49.040 --> 39:02.040]  Ну и заодно обсудили, я надеюсь, поняли то, что направление, точнее, величину углов между векторами можно сравнивать, опять же, не прибегая к артинусам и артангенсам.
[39:02.040 --> 39:07.040]  То есть можно тоже смотреть чисто на векторные произведения.
[39:08.040 --> 39:13.040]  Вот, значит, после перерыва поговорим про выпуклые оболочки, ну а пока давайте отдохнем 5 минут.
[39:17.040 --> 39:25.040]  Давайте продолжим. Как и планировали, давайте поговорим про выпуклые оболочки.
[39:25.040 --> 39:29.040]  Для начала традиционно, что это такое?
[39:30.040 --> 39:39.040]  Выпуклые оболочки.
[39:40.040 --> 40:07.040]  Начну. Выпуклые оболочки, или ВО, называется минимальная, давайте так, выпуклые оболочки, множество точек S, называется минимальная,
[40:08.040 --> 40:17.040]  по включению выпуклое множество.
[40:20.040 --> 40:25.040]  Выпуклое множество. Ну тут, наверное, надо пояснить, что такое выпуклое множество.
[40:25.040 --> 40:48.040]  Ну то есть это множество, которое, давайте так скажем, которое с любой парой точек содержит все промежуточные.
[40:48.040 --> 41:07.040]  Промежуточные. Ну то есть если вам известно, что вашему множеству выпуклые принадлежит точка A и принадлежит точка B, то выпуклые множества гарантируются, что все эти точки между ними тоже содержат.
[41:07.040 --> 41:13.040]  То есть если содержат две точки, то соответственно весь этот отрезок тоже содержит.
[41:13.040 --> 41:26.040]  Ну то есть, грубо говоря, интуитивное понимание такое, что вот это множество не выпуклое, потому что я могу взять вот эти две точки и могу провести вот такую линию, которая в центре не принадлежит множеству.
[41:26.040 --> 41:37.040]  В то же время, если я возьму такую фигуру, то соответственно понятно, что какие бы я две точки не взял, то любой отрезок, который соединяет эти две точки, он тоже будет лежать на третьем множестве.
[41:37.040 --> 41:45.040]  Называется минимальное по включению выпуклое множество. Ну собственно, содержащее.
[41:45.040 --> 41:50.040]  Содержащее.
[41:50.040 --> 41:53.040]  Давайте просто так. Содержащее S.
[41:53.040 --> 41:58.040]  Обозначается, как он S.
[41:59.040 --> 42:03.040]  В целом задача построения выпуклой оболочки.
[42:03.040 --> 42:09.040]  Если возьмем какое-нибудь абстрактное множество, то в принципе выпуклая оболочка тоже может выглядеть практически произвольным образом.
[42:09.040 --> 42:14.040]  То есть может представлять себя произвольную выпуклую фигуру.
[42:14.040 --> 42:19.040]  Например, если я возьму, представьте, что я взял большое количество.
[42:19.040 --> 42:23.040]  Ну что значит большое количество? Просто счетное количество точек, которые расположены по окружности.
[42:23.040 --> 42:28.040]  То я думаю, вы понимаете, что выпуклая оболочка такого множества будет являться вот этой самой окружностью.
[42:28.040 --> 42:34.040]  То есть окружность, которая, точнее круг множества.
[42:34.040 --> 42:40.040]  Круг, который краски проходят через все эти счетные точки.
[42:40.040 --> 42:50.040]  Это значит в счетном случае, если число точек счетно.
[42:50.040 --> 42:55.040]  А теперь давайте рассмотрим ту же самую постановку.
[42:55.040 --> 43:00.040]  Теперь я возьму конечное число точек, которые расположены по окружности.
[43:00.040 --> 43:09.040]  Конечное число точек.
[43:09.040 --> 43:13.040]  Ну что я могу сказать? Во-первых, понятное дело, что если я возьму круг,
[43:13.040 --> 43:26.040]  у которого в качестве окружности выступают окружности, который содержит все эти точки.
[43:26.040 --> 43:30.040]  Это будет выпукло множество, которое содержит все эти точки.
[43:30.040 --> 43:37.040]  Но при этом, для выпуклы оболочки важно, чтобы это было не просто произвольное выпукло множество,
[43:37.040 --> 43:41.840]  минимальное подключение, чтобы еще никак сильнее, грубо говоря, его уменьшить нельзя было бы.
[43:41.840 --> 43:47.200]  Поэтому, если у меня есть какие-то точки, которые расположены, которые лежат на одной окружности,
[43:47.200 --> 43:52.400]  то уже минимальная оболочка в этом случае будет вот такой вот многоугольничкой. То есть я просто
[43:52.400 --> 43:57.360]  провожу отрезки между ними и, соответственно, получаю вот такую вот выпуклую оболочку.
[43:57.360 --> 44:02.240]  Я думаю, вы понимаете, что никаким образом дальше сильнее ужать это я вообще не смогу,
[44:02.240 --> 44:07.200]  потому что, скажем, если я проведу прямую какую-то линию между ними вот так, то, соответственно,
[44:07.200 --> 44:15.160]  я потеряю вот эту связанность. И, соответственно, аналогично с другими. Если я проведу как-то вот
[44:15.160 --> 44:20.120]  так, то, соответственно, эта оболочка уже не будет, точнее, эта ночь уже не будет минимальна,
[44:20.120 --> 44:24.840]  и так далее. Но, вообще говоря, можно в качестве замечания написать следующую вещь. Замечание.
[44:24.840 --> 44:31.520]  Значит, доказывать этого утверждения я не буду, но интуитивно, я думаю, оно понятно, что если
[44:31.520 --> 44:52.560]  s конечно, то con от s это многоугольник с вершинами из s.
[44:52.560 --> 45:12.920]  Если у вас количество точек во множестве s бесконечное число, то, в принципе, у вас
[45:12.920 --> 45:18.520]  выпуклая оболочка может являться, ну, вообще говоря, какая угодно выпуклая фигура. Вот я привел пример,
[45:18.520 --> 45:22.960]  когда есть окружность. А если у вас конечное число точек, то, в принципе, вы всегда можете,
[45:22.960 --> 45:27.600]  то всегда выпуклая оболочка в множестве точек является многоугольник. Ну, почему? Ну, не знаю,
[45:27.600 --> 45:32.840]  просто-напросто можно перебрать всевозможные многоугольники, которые образованы этими
[45:32.840 --> 45:36.880]  самыми точками, и пересечь их все вместе. Так как вы берете пересечение, то вы гарантированы,
[45:36.880 --> 45:40.840]  ну, во-первых, все многоугольники являются выпуклыми, во-вторых, когда вы берете пересечение,
[45:40.840 --> 45:46.360]  то уже выпуклость сохраняется, ну и, соответственно, за счет того, что вы берете всевозможные пересечения,
[45:46.360 --> 45:49.800]  да, эти пересечения конечны, у вас получается, как раз, во-первых, многоугольник, а во-вторых,
[45:49.800 --> 45:53.800]  соответственно, вы достигаете минимальность таким образом, потому что эта фигура, это,
[45:53.800 --> 46:03.360]  во-приворе, будет минимальной по включению. Соответственно, главный вопрос, хорошо,
[46:03.360 --> 46:08.080]  мы умеем работать с многоугольниками, вы посмотрели это на первой половине лекции, соответственно,
[46:08.080 --> 46:12.640]  в прошлый раз осталось только понятие, как, собственно, вот по данному набору точек построить
[46:12.640 --> 46:17.760]  ее выпуклую оболочку. Ну и для этого у меня для вас есть, не знаю, в зависимости от того,
[46:17.760 --> 46:26.200]  что успеем, либо два, либо три алгоритма. Давайте рассмотрим их по порядку.
[46:26.200 --> 46:28.680]  Первый по порядку у нас будет алгоритм Джарриса.
[46:28.680 --> 46:51.600]  Иногда его еще называют алгоритм заворачивания подарка.
[46:51.600 --> 47:04.400]  Ну и действительно он похож на процесс какой-то запаковки и так далее, и эффективно довольно
[47:04.400 --> 47:10.600]  понятен. Что мы сделаем? Давайте набросаем какое-нибудь произвольное количество точек.
[47:10.600 --> 47:19.440]  И, соответственно, по данному мнению точек нужно построить выпуклую оболочку, то есть построить
[47:19.440 --> 47:24.280]  минимальный многоугольник, который содержит внутри себя все вот эти самые, все вот эти самые
[47:24.280 --> 47:30.000]  точки. Там минимальный, естественно, выпуклый многоугольник. Что мы будем делать?
[47:30.000 --> 47:38.520]  Первый шаг простой. Давайте найдем точку, которая гарантированно войдет в нашу выпуклую оболочку.
[47:38.520 --> 47:55.440]  Давайте я добавлю еще одну точку. Найдем точку по 0, которая гарантированно
[48:00.840 --> 48:07.880]  будет частью выпуклой оболочки. Вершиной давайте.
[48:07.880 --> 48:18.600]  Понимаете ли вы, что можно взять в качестве такой точки?
[48:18.600 --> 48:31.520]  Точка с минимальной обсысой, либо с минимальной x координатой, либо с минимальной y координатой.
[48:31.520 --> 48:39.640]  Я думаю, это понятно, что если у вас точка находится левее всех, то она гарантированно должна быть
[48:39.640 --> 48:44.040]  вершиной многоугольника. Иначе вы построите многоугольник только по правым точкам, естественно,
[48:44.040 --> 48:51.040]  левая точка никуда не войдет. Отлично. Еще надо дополнительно рассказать, что если вы берете точку
[48:51.040 --> 48:55.440]  с минимальной обсысой, с минимальной x координатой или минимальной y координатой, и таких точек
[48:55.440 --> 48:59.800]  несколько, то, соответственно, мы еще выбираем либо самый левый из них, либо самый правый из них.
[48:59.800 --> 49:07.480]  Просто грубо говоря, берем самую крайнюю точку. Давайте для определенности скажем, в качестве такой
[49:10.280 --> 49:14.280]  можно взять
[49:14.280 --> 49:28.160]  аргумент по y среди всех p из s. Если таких несколько,
[49:32.960 --> 49:38.440]  несколько с минимальной x координатой.
[49:38.440 --> 49:48.280]  В данном случае у меня в качестве такой точки выступает вот эта точка. Давайте ее обозначим
[49:48.280 --> 49:59.040]  как по ноль. Первый пункт простой. Следующие пункты тоже простые. Смотрите, почему алгоритм
[49:59.040 --> 50:02.600]  называется алгоритм заворачивания под арк? Представьте себе, что эти точки это не точки,
[50:02.600 --> 50:08.320]  а просто какие-то гвоздики, которые забиты в дощечку. И вот мы нашли минимальную точку,
[50:08.320 --> 50:14.160]  и давайте за нее зацепим какую-нибудь веревочку. Зацепили веревочку, и соответственно протянули ее
[50:14.160 --> 50:20.680]  далеко. И что делаем? Просто берем и заворачиваем эту веревочку вокруг нашего
[50:20.680 --> 50:25.880]  множества гвоздиков. Что мы сделаем? Когда мы будем поднимать эту веревочку наверх,
[50:25.880 --> 50:32.440]  мы столкнемся с каким-то гвоздиком. И уже будем оборачивать этот подарок,
[50:32.440 --> 50:37.720]  вот эту упаковку и веревочку вокруг этого гвоздика. Поднимаем потихоньку наверх,
[50:37.720 --> 50:43.280]  и мы встречаем вот эту самую точку. Дальше у нас веревочка цепляется за эту точку,
[50:43.280 --> 50:51.320]  и соответственно мы продолжаем заворачивать упаковку, подарок, не важно что, вокруг уже этой
[50:51.320 --> 50:59.400]  точке. И следующим встречаем вот эту точку. И так далее. Просто берем веревочку и соответственно
[50:59.400 --> 51:08.600]  оборачиваем вокруг всех остальных точек. Вопрос заключается в следующем. На таком
[51:08.600 --> 51:13.240]  идейном уровне все понятно, все замечательно, но хочется на формальном алгоритмическом
[51:13.240 --> 51:17.880]  или математическом уровне понять, что это такая точка, за которую мы зацепимся в следующий раз.
[51:17.880 --> 51:25.800]  Понимаете ли вы, каким свойством обладает точка, на которой мы упрямся в следующий раз.
[51:25.800 --> 51:29.960]  То есть, грубо говоря, какую точку нам в следующий нужно добавить вот в нашу выплывную оболочку.
[51:29.960 --> 51:40.680]  Как добавить следующую?
[51:40.680 --> 51:57.800]  Например, давайте в этом случае рассмотрим. Мы понимаем, что следующая точка, которая будет
[51:57.800 --> 52:07.600]  добавлена, это будет вот эта точка. Следующим пунктом нашей выплывной оболочки будет
[52:08.080 --> 52:13.840]  эта сторона. Вопрос, а каким таким свойством хорошим она обладает, что мы ее выделяем среди
[52:13.840 --> 52:17.600]  всех остальных? Опять же, с точки зрения алгоритма по математике. С минимально положительным углом.
[52:17.600 --> 52:22.960]  Да, можно сказать, что с минимально положительным углом. То есть, если вы обход делаете в положенном
[52:22.960 --> 52:27.280]  направлении, то да. Действительно, тут достаточно посмотреть на величину угла, на величину угла
[52:27.280 --> 52:35.320]  между текущим вектором. Давайте обозначим, не знаю, по 1, по 2 и по 3. То есть, действительно, давайте
[52:35.320 --> 52:43.640]  посмотрим на угол между вектором по 1, по 2 и по 2, по 3. Заметим, что этот угол является, во-первых,
[52:43.640 --> 52:48.000]  положительным. На самом деле можно не уточнять, что минимальный положительный угол, наверное.
[52:48.000 --> 52:54.160]  Да, можно не уточнять, что минимальный положительный, потому что у вас в любом случае может и будет
[52:54.160 --> 53:01.040]  получаться выпуклым. Все точки будут находиться в положительной стороне. Но самое главное,
[53:01.040 --> 53:03.040]  самое главное, что этот угол минимальный.
[53:03.040 --> 53:05.040]  Например, если я смотрю вот какой-нибудь такой угол,
[53:05.040 --> 53:07.040]  точнее вот такое вот направление,
[53:07.040 --> 53:09.040]  то он уже не будет минимальным, но будет больше, чем вот то,
[53:09.040 --> 53:11.040]  которое я смотрел сейчас, чем p2, p3.
[53:11.040 --> 53:13.040]  Соответственно, действительно,
[53:13.040 --> 53:15.040]  давайте просто-напросто найдем
[53:15.040 --> 53:17.040]  вектор, который
[53:17.040 --> 53:19.040]  будет обладать минимальным углом
[53:19.040 --> 53:21.040]  среди всех точек, которые еще не добавлены
[53:21.040 --> 53:23.040]  в выпуклую оболочку.
[53:23.040 --> 53:25.040]  Как добавить следующую?
[53:25.040 --> 53:27.040]  Найдем...
[53:28.040 --> 53:30.040]  Ну, давайте так напишем.
[53:33.040 --> 53:35.040]  Пусть
[53:35.040 --> 53:37.040]  последняя...
[53:37.040 --> 53:39.040]  Так, тут я забыл давать...
[53:39.040 --> 53:41.040]  Ну, я сейчас напишу пункт 1 штрих,
[53:41.040 --> 53:43.040]  что
[53:43.040 --> 53:45.040]  добавим
[53:47.040 --> 53:49.040]  p1,
[53:49.040 --> 53:51.040]  которая...
[53:51.040 --> 53:53.040]  Ну, p1,
[53:53.040 --> 53:55.040]  такую что...
[53:57.040 --> 53:59.040]  Пусть что...
[53:59.040 --> 54:01.040]  p0, p1
[54:01.040 --> 54:03.040]  образует
[54:05.040 --> 54:07.040]  мин угол
[54:07.040 --> 54:09.040]  с горизонталью.
[54:09.040 --> 54:11.040]  Горизонталью.
[54:13.040 --> 54:15.040]  Ну, сейчас я хочу просто делать индуктивный переход,
[54:15.040 --> 54:17.040]  в котором мне нужно две последние точки.
[54:17.040 --> 54:19.040]  То есть, условно, первую точку p0 мы берем
[54:19.040 --> 54:21.040]  с минимальной координатой.
[54:21.040 --> 54:23.040]  p0, p1 мы берем тоже по углу,
[54:23.040 --> 54:25.040]  но смотрим уже на угол относительно горизонтали.
[54:25.040 --> 54:27.040]  Надо вот тут вот...
[54:27.040 --> 54:29.040]  У меня штриховка обозначена горизонталью, соответственно,
[54:29.040 --> 54:31.040]  p0, p1 имеет наименьший угол
[54:31.040 --> 54:33.040]  относительно этой самой горизонтали.
[54:33.040 --> 54:35.040]  Вот. Соответственно, пункт 2.
[54:35.040 --> 54:37.040]  Вот он, пункт 2.
[54:37.040 --> 54:39.040]  Пусть последние
[54:39.040 --> 54:41.040]  добавленные
[54:41.040 --> 54:43.040]  добавленные
[54:43.040 --> 54:45.040]  точки
[54:45.040 --> 54:47.040]  это p-1,
[54:47.040 --> 54:49.040]  p-i.
[54:51.040 --> 54:53.040]  Просто найдем
[54:53.040 --> 54:55.040]  найдем p-i
[54:55.040 --> 54:57.040]  плюс один,
[54:57.040 --> 54:59.040]  как
[54:59.040 --> 55:01.040]  аргмин
[55:01.040 --> 55:03.040]  величины угла, ну, собственно, вот того,
[55:03.040 --> 55:05.040]  который я сказал, который вы сказали,
[55:05.040 --> 55:07.040]  p-i,
[55:07.040 --> 55:09.040]  p-i плюс один,
[55:09.040 --> 55:11.040]  вот так.
[55:11.040 --> 55:13.040]  Ну, аргмин по p-i плюс один, естественно.
[55:13.040 --> 55:15.040]  Вот.
[55:17.040 --> 55:19.040]  Соответственно, еще раз
[55:19.040 --> 55:21.040]  давайте вернемся к замечанию,
[55:21.040 --> 55:23.040]  которое обсуждали вот здесь,
[55:23.040 --> 55:25.040]  что величину угла,
[55:25.040 --> 55:27.040]  величину угла, ну, точнее,
[55:27.040 --> 55:29.040]  сравниваем углы, сравниваем углы,
[55:29.040 --> 55:31.040]  мы как раз таки, опять же, с помощью векторного произведения,
[55:31.040 --> 55:33.040]  то есть не нужно вычитывать их напрямую.
[55:33.040 --> 55:35.040]  То есть мы в качестве базового вектора
[55:35.040 --> 55:37.040]  берем вот этот вот самый вектор,
[55:37.040 --> 55:39.040]  p-1, p-i, и дальше для всех остальных точек
[55:39.040 --> 55:41.040]  проверяем вот это вот самое векторное произведение,
[55:41.040 --> 55:43.040]  точнее,
[55:43.040 --> 55:45.040]  ну, короче говоря, сравниваем,
[55:45.040 --> 55:47.040]  короче, берем минимум вот по этому самому
[55:47.040 --> 55:49.040]  векторному произведению.
[55:49.040 --> 55:51.040]  То есть если мы выбрали какого-то кандидата,
[55:51.040 --> 55:53.040]  скажем, если у нас есть кандидат
[55:53.040 --> 55:55.040]  p-,
[55:55.040 --> 55:57.040]  и мы смотрим на произведение,
[55:59.040 --> 56:01.040]  если у нас есть кандидат
[56:01.040 --> 56:03.040]  p-, и так оказалось,
[56:03.040 --> 56:05.040]  что
[56:05.040 --> 56:07.040]  p-
[56:07.040 --> 56:09.040]  p-2-
[56:09.040 --> 56:11.040]  сейчас
[56:13.040 --> 56:15.040]  вот здесь p-i
[56:15.040 --> 56:17.040]  минус 1,
[56:17.040 --> 56:19.040]  здесь p-i
[56:23.040 --> 56:25.040]  p-i минус 1
[56:25.040 --> 56:27.040]  и вот у меня есть две точки, скажем,
[56:27.040 --> 56:29.040]  p-
[56:29.040 --> 56:31.040]  и p-2-
[56:31.040 --> 56:33.040]  Вот как мне понять,
[56:33.040 --> 56:35.040]  что точка p- лучше,
[56:35.040 --> 56:37.040]  чем точка p-2-?
[56:37.040 --> 56:39.040]  И достаточно посмотреть на
[56:39.040 --> 56:41.040]  произведение p-i
[56:41.040 --> 56:43.040]  и p-i
[56:43.040 --> 56:45.040]  p-2-
[56:45.040 --> 56:47.040]  Если поворота осуществляется в положительном направлении,
[56:47.040 --> 56:49.040]  то значит, что точка p-
[56:49.040 --> 56:51.040]  что угол для нее меньше,
[56:51.040 --> 56:53.040]  соответственно, p- лучше,
[56:53.040 --> 56:55.040]  ну, p- меньше,
[56:55.040 --> 56:57.040]  чем p-2-
[56:57.040 --> 56:59.040]  А если знак наоборот
[56:59.040 --> 57:01.040]  отрицательный, то соответственно,
[57:01.040 --> 57:03.040]  p-2- лучше, чем точка p-3-
[57:03.040 --> 57:05.040]  Вот таким вот образом мы
[57:05.040 --> 57:07.040]  проверяем вот этот вот самый аргумент
[57:07.040 --> 57:09.040]  Вот
[57:09.040 --> 57:11.040]  Идея, я думаю,
[57:11.040 --> 57:13.040]  понятна
[57:13.040 --> 57:15.040]  в стиле реализации
[57:15.040 --> 57:17.040]  можно на семинарах обсудить
[57:17.040 --> 57:19.040]  Идейно просто
[57:19.040 --> 57:21.040]  выбираем действительно угол
[57:21.040 --> 57:23.040]  выбираем минимальный угол относительно
[57:23.040 --> 57:25.040]  вот секущего направления
[57:25.040 --> 57:27.040]  Давайте закончим
[57:27.040 --> 57:29.040]  строение, тут минимальный угол,
[57:29.040 --> 57:31.040]  соответственно, будет вот этот угол, дальше тут минимальный угол,
[57:31.040 --> 57:33.040]  вот этот угол, ну и в конце мы
[57:33.040 --> 57:35.040]  к начанию точки вот
[57:35.040 --> 57:37.040]  строили вот такую вот
[57:37.040 --> 57:39.040]  вот такую вот оболочку
[57:39.040 --> 57:41.040]  По сути все
[57:41.040 --> 57:43.040]  1 пункт 1 штрих
[57:43.040 --> 57:45.040]  и пункт 2
[57:49.040 --> 57:51.040]  Что я хотел еще сказать
[57:51.040 --> 57:53.040]  Найдем точку p-0
[57:53.040 --> 57:55.040]  Найдем p-1
[57:55.040 --> 57:57.040]  добавим следующую
[57:57.040 --> 57:59.040]  Ну и то, как мы выбираем минимум, я тоже
[57:59.040 --> 58:01.040]  обсудил вроде как
[58:01.040 --> 58:03.040]  Есть ли вопросы по этому алгоритму?
[58:03.040 --> 58:05.040]  Сейчас мы обсудим его сложность
[58:05.040 --> 58:07.040]  А пока давайте просто идею
[58:11.040 --> 58:13.040]  Понятно ли, что мы сделали?
[58:21.040 --> 58:23.040]  Окей, хорошо
[58:23.040 --> 58:25.040]  Теперь давайте обсудим
[58:25.040 --> 58:27.040]  сложность
[58:31.040 --> 58:33.040]  Какая у этого самого алгоритма сложность?
[58:33.040 --> 58:35.040]  Ну давайте пообсуждаем
[58:35.040 --> 58:37.040]  Соответственно, пункты 1 и 1 штрих
[58:37.040 --> 58:39.040]  мы учитывать не будем, они выполнены
[58:39.040 --> 58:41.040]  за вот единицы
[58:41.040 --> 58:43.040]  А, тут важный момент, понятное дело,
[58:43.040 --> 58:45.040]  что нужно третий пункт написать
[58:45.040 --> 58:47.040]  То есть в какой момент мы должны остановиться
[58:49.040 --> 58:51.040]  Давайте допишем, что
[58:51.040 --> 58:53.040]  Повторяем
[58:55.040 --> 58:57.040]  Повторяем пункт 2
[58:57.040 --> 58:59.040]  Пока p-1
[58:59.040 --> 59:01.040]  не равно 0
[59:01.040 --> 59:03.040]  То есть пока мы не вернулись
[59:03.040 --> 59:05.040]  к сводную точку, то
[59:05.040 --> 59:07.040]  мы продолжаем строить нашу кладоволочку
[59:07.040 --> 59:09.040]  На этом я думаю понятно
[59:09.040 --> 59:11.040]  Теперь давайте обсудим сложность
[59:11.040 --> 59:13.040]  Давайте обсудим сложность пункта 2
[59:13.040 --> 59:15.040]  И соответственно сколько итераций
[59:15.040 --> 59:17.040]  точнее сколько раз мы этот пункт 2 выполнили
[59:17.040 --> 59:19.040]  Тут как бы у нас стоит цикл while
[59:19.040 --> 59:21.040]  то есть while p-1 не равно p-0
[59:21.040 --> 59:23.040]  То есть пока точка, которую мы добавили
[59:23.040 --> 59:25.040]  не равна точке по 0, мы повторяем пункт 2
[59:25.040 --> 59:27.040]  За сколько выполняется пункт 2?
[59:27.040 --> 59:29.040]  За сколько мы можем найти минимум
[59:29.040 --> 59:31.040]  вот этого самого
[59:31.040 --> 59:33.040]  угла между направлением
[59:33.040 --> 59:35.040]  pi-1 pi и pi-1
[59:35.040 --> 59:37.040]  точнее, вот за сколько мы можем найти
[59:37.040 --> 59:39.040]  вот эту точку pi-1?
[59:41.040 --> 59:43.040]  За сколько мы ищем минимум?
[59:43.040 --> 59:45.040]  За отn, да, действительно
[59:45.040 --> 59:47.040]  Действительно, пункт 2
[59:47.040 --> 59:49.040]  выполняется за
[59:49.040 --> 59:51.040]  Давайте вот это отдельно напишу
[59:55.040 --> 59:57.040]  Значит, пункт 2
[59:57.040 --> 59:59.040]  выполняется за отn
[59:59.040 --> 01:00:01.040]  То есть мы ничего умнее
[01:00:01.040 --> 01:00:03.040]  чем минимум за линейное время
[01:00:03.040 --> 01:00:05.040]  придумать не можем
[01:00:05.040 --> 01:00:07.040]  потому что, опять же, вам исходно дан набор точек произвольный
[01:00:07.040 --> 01:00:09.040]  он никак не отсортирован и так далее
[01:00:09.040 --> 01:00:11.040]  Поэтому никаких динарных поисков
[01:00:11.040 --> 01:00:13.040]  и так далее, к сожалению, применить не получится
[01:00:13.040 --> 01:00:15.040]  Поэтому, соответственно, используем
[01:00:15.040 --> 01:00:17.040]  отn
[01:00:17.040 --> 01:00:19.040]  Поэтому минимум ищем за отn
[01:00:19.040 --> 01:00:21.040]  И вопрос, сколько итераций?
[01:00:21.040 --> 01:00:23.040]  Сколько?
[01:00:23.040 --> 01:00:25.040]  Итераций
[01:00:29.040 --> 01:00:31.040]  Сколько итераций поиска минимума мы сделаем?
[01:00:31.040 --> 01:00:33.040]  Мы сделаем
[01:00:41.040 --> 01:00:43.040]  Ну, смотрите, пункт 2 мы повторяем
[01:00:43.040 --> 01:00:45.040]  до тех пор, пока не построим
[01:00:45.040 --> 01:00:47.040]  Да, n это пессимистичный оценок
[01:00:47.040 --> 01:00:49.040]  Сейчас мы к ней придем
[01:00:49.040 --> 01:00:51.040]  Пункт 2 мы выполняем до тех пор, пока не построим
[01:00:51.040 --> 01:00:53.040]  выкуплую оболочку
[01:00:53.040 --> 01:00:55.040]  Но выкуплая оболочка, если давайте обозначим
[01:00:55.040 --> 01:00:57.040]  что модуль
[01:00:57.040 --> 01:00:59.040]  с, то есть количество вершин
[01:00:59.040 --> 01:01:01.040]  в выкуплой оболочке равно h
[01:01:01.040 --> 01:01:03.040]  соответственно, число итераций будет
[01:01:03.040 --> 01:01:05.040]  как раз таки h
[01:01:05.040 --> 01:01:07.040]  И поэтому итоговая сложность у нас получается
[01:01:07.040 --> 01:01:09.040]  отn умножить на h
[01:01:09.040 --> 01:01:11.040]  Давайте еще упечатну, что h это
[01:01:11.040 --> 01:01:13.040]  количество вершин
[01:01:15.040 --> 01:01:17.040]  в выкуплой оболочке
[01:01:19.040 --> 01:01:21.040]  То есть сложность алгоритма за o от n h
[01:01:21.040 --> 01:01:23.040]  Да, действительно, в худшем случае
[01:01:23.040 --> 01:01:25.040]  все точки будут в выкуплой оболочке
[01:01:25.040 --> 01:01:27.040]  Пример мы уже приводили, когда все точки лежат
[01:01:27.040 --> 01:01:29.040]  примерно на однойок polishing
[01:01:29.040 --> 01:01:31.040]  Достаточно рассмотреть ситуацию, когда у меня
[01:01:31.040 --> 01:01:33.040]  почти все точки принадлежат выкуплой оболочке
[01:01:33.040 --> 01:01:35.040]  То есть действительно
[01:01:35.040 --> 01:01:37.040]  в худшем случае
[01:01:37.040 --> 01:01:39.040]  алгоритм работает за o отn2
[01:01:41.040 --> 01:01:43.040]  В худшем случае
[01:01:43.040 --> 01:01:45.040]  алгоритм работает за o отn
[01:01:45.040 --> 01:01:47.040]  То есть, если
[01:01:47.040 --> 01:01:51.040]  если вдруг так повезло, что у вас выплыва оболочка это всего лишь какой-нибудь треугольник,
[01:01:51.040 --> 01:01:57.040]  внутри которого расположено много точек, то в принципе вы справляетесь за линейное время.
[01:01:57.040 --> 01:02:02.040]  Но хуже, в случае действительно o от m квадрат, и это не очень приятно.
[01:02:02.040 --> 01:02:09.040]  Это по сути означает, что множество из 10 тысяч точек вы будете обрабатывать примерно секунду.
[01:02:09.040 --> 01:02:16.040]  Скажем, вам множество из 100 тысяч точек или даже множество из миллиона точек вы за разумное время,
[01:02:16.040 --> 01:02:21.040]  вы не обработаете. Печально.
[01:02:21.040 --> 01:02:30.040]  Преимущество алгоритма Джарриса заключается в том, что он простой, что у него есть довольно хороший и лучший случай.
[01:02:30.040 --> 01:02:35.040]  И плюс, если вдруг так получилось, что вы заранее знаете число точек выплыва оболочки,
[01:02:35.040 --> 01:02:43.040]  по каким-то своим соображениям, вы знаете, что в центре скоплено много точек, а на периферии точек мало,
[01:02:43.040 --> 01:02:50.040]  тогда алгоритм Джарриса можно применить. Но в общем случае действительно он может давать довольно плохой результат.
[01:02:50.040 --> 01:02:55.040]  Перед чем перейдем к более эффективному алгоритму, более эффективному опять же в терминах худшего случая,
[01:02:55.040 --> 01:02:59.040]  наверное было бы интересно обсудить следующий вопрос.
[01:02:59.040 --> 01:03:06.040]  А насколько вообще быстро и эффективно можно построить выплывную оболочку в теории?
[01:03:06.040 --> 01:03:23.040]  И вот тут еще небольшой пункт. Нижняя оценка на скорость
[01:03:26.040 --> 01:03:33.040]  построения выплывной оболочки.
[01:03:33.040 --> 01:03:44.040]  Ну давайте я еще напишу дополнительное замечание, что так называется в алгебраической модели.
[01:03:44.040 --> 01:03:51.040]  Сейчас поясню, что это такое в алгебраической модели.
[01:03:51.040 --> 01:03:57.040]  Ну смотрите, на одной из первых лекций, на второй лекции, когда мы обсуждали с вами Фибоначью Пирамиду,
[01:03:57.040 --> 01:04:02.040]  мы с вами пришли к выводу, что Фибоначья Пирамида почти все операции имеет выполнять за 1 единицей.
[01:04:02.040 --> 01:04:08.040]  Например, операция у Декриске выполняет за отлагарифм в амортизированном смысле.
[01:04:08.040 --> 01:04:13.040]  И мы с вами обсудили, что в принципе даже в теории в общем случае нельзя построить структуру данных,
[01:04:13.040 --> 01:04:16.040]  типа пирамида, которая бы все операции могла выполнять за единицей.
[01:04:16.040 --> 01:04:22.040]  Потому что иначе это бы противоречило теорияме, которая утверждает, что сортировку быстрее, чем зеленый логен, построить нельзя.
[01:04:22.040 --> 01:04:24.040]  Вот тут на самом деле та же самая история.
[01:04:24.040 --> 01:04:31.040]  На самом деле оказывается, что задачу сортировки можно свести к заданию построения выплывной оболочки.
[01:04:31.040 --> 01:04:34.040]  Довольно интересным образом. Сейчас я к этому перейду.
[01:04:34.040 --> 01:04:38.040]  На самом деле оказывается, что если вы умеете строить выплывную оболочку за линейное время,
[01:04:38.040 --> 01:04:41.040]  то по сути вы умеете сортировать тоже за линейное время.
[01:04:41.040 --> 01:04:43.040]  Но чего, естественно, невозможно.
[01:04:43.040 --> 01:04:46.040]  Давайте приведу пример такого сведения.
[01:04:46.040 --> 01:04:50.040]  Как можно свести задачу сортировки к задаче строения выплывной оболочки.
[01:04:50.040 --> 01:04:59.040]  Допустим, вам данные числа x1, x2, x3 и так далее.
[01:04:59.040 --> 01:05:03.040]  Давайте x0, xm-1.
[01:05:03.040 --> 01:05:05.040]  Их нужно отсортировать.
[01:05:05.040 --> 01:05:07.040]  Как мы это сделаем?
[01:05:07.040 --> 01:05:13.040]  Давайте я представлю, что x0, x1, x2, x3 и так далее это координаты x.
[01:05:13.040 --> 01:05:18.040]  А координаты y, грубо говоря, из этих чисел составлю следующие точки.
[01:05:18.040 --> 01:05:25.040]  x0, x0 в квадрате, x1, x1 в квадрате и так далее.
[01:05:25.040 --> 01:05:28.040]  xm-1, xm-1 в квадрате.
[01:05:28.040 --> 01:05:33.040]  Грубо говоря, у меня была прямая, на которой были какие-то точки.
[01:05:33.040 --> 01:05:37.040]  А я просто-напросто построил на них параболу.
[01:05:43.040 --> 01:05:47.040]  x0, x1, xm-1.
[01:05:47.040 --> 01:05:51.040]  Здесь, соответственно, xm-1 в квадрате и так далее.
[01:05:51.040 --> 01:05:55.040]  Соответственно, точки лежат у меня на параболе.
[01:05:55.040 --> 01:05:59.040]  А теперь я сделаю следующую вещь.
[01:05:59.040 --> 01:06:01.040]  Давайте я просто на этом множестве точек.
[01:06:01.040 --> 01:06:04.040]  Первый пункт, второй пункт, третий.
[01:06:04.040 --> 01:06:12.040]  Построим ВО на пункте 2.
[01:06:13.040 --> 01:06:14.040]  Вот.
[01:06:14.040 --> 01:06:25.040]  Соответственно, если построили ВО быстрее, чем...
[01:06:25.040 --> 01:06:30.040]  быстрее, чем за n лог n.
[01:06:30.040 --> 01:06:34.040]  Давайте напишем ω от n лог n.
[01:06:34.040 --> 01:06:57.040]  То и отсортировали, то и отсортировали быстрее, чем за ω от n лог n.
[01:06:57.040 --> 01:07:01.040]  Почему это так?
[01:07:01.040 --> 01:07:08.040]  Потому что задача построения выпуклого блокчика, по сути, заключается в том, что вы находите вершины выпуклого многоугольника.
[01:07:08.040 --> 01:07:16.040]  Мы договорились, что у нас многоугольники, естественно, все вершины упорядочены вдоль какого-то обхода, вдоль обхода по числою следов, или по числою следов.
[01:07:16.040 --> 01:07:25.040]  Соответственно, когда вы построите многоугольник, то вы заодно и построите, грубо говоря, некоторые упорядочения этих самых вершин.
[01:07:25.040 --> 01:07:35.040]  Но, соответственно, упорядоченные этих вершин как раз таки, вдоль параболы, в одном направлении параболы или в другом направлении параболы, как раз таки даст вам сортировку.
[01:07:35.040 --> 01:07:39.040]  Поэтому кажется так, что точки будут отсортированы.
[01:07:39.040 --> 01:07:48.040]  На самом деле, эта модель не совсем та, которую мы рассматривали в первом семестре, или рассматривали, когда обсуждали пирамиду.
[01:07:48.040 --> 01:07:55.040]  То есть там все-таки модель была такая, что нам разрешено делать только операции сравнения, то есть для сортировок, которые основаны только на сравнениях.
[01:07:55.040 --> 01:07:58.040]  Верно, что быстрее, чем взаимодействовать, сортировать нельзя.
[01:07:58.040 --> 01:08:04.040]  А тут кажется, что мы знаем точно, что мы сортируем числа, и тут мы можем применять какую-то алгебру.
[01:08:04.040 --> 01:08:09.040]  Но на самом деле оказывается, что алгебра тоже, по сути, ничего хорошего не дает.
[01:08:09.040 --> 01:08:18.040]  То есть на самом деле, если вы никаких свойств чисел не знаете, то есть не знаете, что это целые числа, или не знаете, что это какие-то равномерно распределенные дробные числа,
[01:08:18.040 --> 01:08:28.040]  числа с вещественной числа, то, соответственно, тоже в общем случае быстрее, чем взаимодействовать, сортировать не получится.
[01:08:28.040 --> 01:08:35.040]  Такое небольшое обоснование, почему выпуклую оболочку быстрее, чем взаимодействовать, тоже строить довольно сложно.
[01:08:35.040 --> 01:08:42.040]  Хотя есть алгоритмы, которые строят выпуклую оболочку из-за линейного времени, опять же, при условии каких-то хороших предположений о множестве.
[01:08:42.040 --> 01:08:46.040]  Ну это так, небольшой офф топ, просто интересный факт.
[01:08:46.040 --> 01:08:52.040]  Давайте, собственно, от этого слайда перейдем к алгоритму, который действительно...
[01:08:52.040 --> 01:08:58.040]  То есть мы поняли, что у нас есть нижняя оценка на скорость построения выпуклой оболочки, это n log n.
[01:08:58.040 --> 01:09:03.040]  Ну и, соответственно, давайте перейдем к примеру алгоритма, который умеет строить выпуклую оболочку за этот самый n log n.
[01:09:03.040 --> 01:09:06.040]  И этот алгоритм называется алгоритмом Грехома.
[01:09:06.040 --> 01:09:31.040]  Ну, история у него такая же, как и у алгоритма Джарвиса, ну, по крайней мере, первые 2 пункта, 1 и 1 шлик совпадают.
[01:09:31.040 --> 01:09:41.040]  То есть находим по 0, давайте я пропущу, как в Джарвисе.
[01:09:41.040 --> 01:09:54.040]  1 штрих находим по 1, тоже как в Джарвисе.
[01:09:54.040 --> 01:09:59.040]  Давайте я поясню сейчас, что значит в Джарвисе.
[01:09:59.040 --> 01:10:02.040]  Вот набор точек.
[01:10:02.040 --> 01:10:08.040]  Находим точку с минимальной y-координатой, а дальше находим эту по 0.
[01:10:08.040 --> 01:10:12.040]  И находим p1, который образует минимальный угол с горизонталью.
[01:10:12.040 --> 01:10:15.040]  Построили первые две точки.
[01:10:15.040 --> 01:10:19.040]  Что делаем дальше?
[01:10:19.040 --> 01:10:30.040]  Давайте напишу отдельно.
[01:10:30.040 --> 01:10:48.040]  Добавленные точки будем хранить в стеке.
[01:10:48.040 --> 01:10:55.040]  То есть в данный момент у меня в стеке находится точка по 0 и точка по 1.
[01:10:55.040 --> 01:10:59.040]  А, блин, я забыл за важный момент сказать.
[01:10:59.040 --> 01:11:03.040]  Чем алгоритмом Грехом отличается от алгоритма Джарвиса?
[01:11:03.040 --> 01:11:09.040]  Отличается он тем, что...
[01:11:09.040 --> 01:11:12.040]  Второй пункт.
[01:11:12.040 --> 01:11:21.040]  Отсортируем все точки.
[01:11:21.040 --> 01:11:35.040]  По величине угла относительно вектора по 0 по 1.
[01:11:35.040 --> 01:11:37.040]  Естественно, это занимает n лога.
[01:11:37.040 --> 01:11:41.040]  И спойлер, этот пункт занимает большую часть времени.
[01:11:41.040 --> 01:11:45.040]  Все остальное мы сделаем за линию.
[01:11:45.040 --> 01:11:48.040]  Соответственно, выбрали направление по 0 по 1.
[01:11:48.040 --> 01:11:52.040]  То есть первые две точки выбрать в логике довольно несложно.
[01:11:52.040 --> 01:11:57.040]  Ну а все остальные точки мы отсортируем по взрастанию этого самого угла.
[01:11:57.040 --> 01:12:06.040]  То есть это будет первая точка, вторая, третья, четвертая, пятая, шестая, восьмая, девятая, десятая, одиннадцатая.
[01:12:06.040 --> 01:12:10.040]  По величине угла, по взрастанию отсортируем все точки.
[01:12:10.040 --> 01:12:33.040]  Ну и давайте еще отдельно напишем, что если у точек одинаковый угол, то у взрастания длины вектора.
[01:12:34.040 --> 01:12:50.040]  Если точка расположена на одной прямой, скажем АВ, то А будет меньше, чем В.
[01:12:50.040 --> 01:12:52.040]  Отсортировали.
[01:12:52.040 --> 01:12:54.040]  Дальше делаем следующую вещь.
[01:12:54.040 --> 01:12:57.040]  Как я уже сказал, мы добавлены точки, будем хранить в стеке.
[01:12:57.040 --> 01:13:01.040]  В третьем пункте будем делать так.
[01:13:01.040 --> 01:13:20.040]  Возьмем, перебираем точки в порядке взрастания, который получен на пункте 2.
[01:13:20.040 --> 01:13:41.040]  Возьмем, перебираем точки в порядке взрастания, и если ПК минус 1, ПК угол, ПК, ПИ,
[01:13:41.040 --> 01:14:01.040]  то значит точки ПК минус 1, ПК, это последние две точки, стеки, ПИ, текущая точка.
[01:14:01.040 --> 01:14:16.040]  И если смотреть вот этот угол, давайте вот так сображу.
[01:14:16.040 --> 01:14:18.040]  Давайте сделаем так.
[01:14:18.040 --> 01:14:20.040]  ПК2.
[01:14:20.040 --> 01:14:28.040]  И вот тут пусть будет ПК3.
[01:14:28.040 --> 01:14:33.040]  И если вот этот угол меньше нуля, то есть что это означает?
[01:14:33.040 --> 01:14:38.040]  У меня уже в стеке есть какие-то точки, и если я рассматриваю очередную точку,
[01:14:38.040 --> 01:14:45.040]  и этот угол у меня получается развернутым, то есть внутренний угол получается больше, чем 180 градусов,
[01:14:45.040 --> 01:14:56.040]  то есть поворот осуществляется в отрицательном направлении, то это означает, что у меня что-то идет не так.
[01:14:56.040 --> 01:15:07.040]  То есть если у меня получилась вот такая ситуация, то это означает, что в данный момент у меня выплывала оболочка,
[01:15:07.040 --> 01:15:09.040]  построенная неправильно.
[01:15:09.040 --> 01:15:11.040]  Что я в этом случае делаю?
[01:15:11.040 --> 01:15:32.040]  И если вот так, то удаляю последние точки из стека,
[01:15:32.040 --> 01:15:52.040]  удаляю по одной, пока вот этот угол, ПК-1 ПК, ПКПИ не станет положительным, не станет больше нуля.
[01:15:52.040 --> 01:15:54.040]  То есть грубо говоря, что я делаю?
[01:15:54.040 --> 01:15:59.040]  Смотрите, я заметил, что вот этот угол получился такой, вот этот вот угол конкретный.
[01:15:59.040 --> 01:16:00.040]  Что я делаю?
[01:16:00.040 --> 01:16:06.040]  Я удаляю тогда точку П2 из рассмотрения, из моей выплывой оболочки, и рассматриваю теперь вот такую ситуацию.
[01:16:06.040 --> 01:16:15.040]  П2 у меня остался здесь, и соответственно теперь я говорю, что буду рассматривать точку П0, точку П1 и точку П3.
[01:16:15.040 --> 01:16:33.040]  Вот этот угол стал положительным, поэтому я оставляю так как есть, и добавляю ПИ стек.
[01:16:33.040 --> 01:16:39.040]  Давайте более красиво напишу на картинке, что я делаю.
[01:16:39.040 --> 01:16:52.040]  Ну вот, представьте, что у меня уже построена какая-то выплывая оболочка, вот так, вот так, вот так, вот так, вот так.
[01:16:52.040 --> 01:17:00.040]  Ну и тут какие-то точки лежат, вот очередная точка здесь.
[01:17:00.040 --> 01:17:08.040]  То есть тут П0, П1, П2, П3, П4, П5, П6.
[01:17:08.040 --> 01:17:12.040]  Все точки я рассматриваю по возрастанию этого самого угла.
[01:17:12.040 --> 01:17:14.040]  Ну и теперь очередь дошла до точки П4.
[01:17:14.040 --> 01:17:18.040]  Все вот эти точки расположены в стеке.
[01:17:18.040 --> 01:17:29.040]  П0, П1, П2, П3, П4, П5, П6.
[01:17:29.040 --> 01:17:39.040]  Соответственно, на текущей итерации я рассматриваю вот этот вектор и вот этот вот вектор П.
[01:17:39.040 --> 01:17:43.040]  Что я вижу? Смотрите, я вижу, что в данном случае, в данной ситуации,
[01:17:43.040 --> 01:17:50.040]  у меня угол, который образует вектора П5, П6 и П6, П3, он отрицательный.
[01:17:50.040 --> 01:17:56.040]  Что это означает? Это означает, что у меня не получается в данный момент построить выплывую оболочку.
[01:17:56.040 --> 01:18:00.040]  Точнее, что у меня фигура в данный момент многоугольник получается не выплывой.
[01:18:00.040 --> 01:18:06.040]  Ну, я в этот момент не отчаиваюсь, я просто-напросто говорю, что давайте я выкину точку П6, и стек тоже я выкину.
[01:18:06.040 --> 01:18:16.040]  Соответственно, буду проверять теперь угол относительно вектора П4, П5 и П5, П3.
[01:18:16.040 --> 01:18:18.040]  А про П6 я просто-напросто забываю.
[01:18:18.040 --> 01:18:25.040]  Снова смотрю и вижу, что поворот от вектора П4, П5 до вектора П5, П4 осуществляется в отрицательном направлении.
[01:18:25.040 --> 01:18:27.040]  Но снова меня это не устраивает.
[01:18:27.040 --> 01:18:30.040]  Получается, что у меня в данный момент многоугольник получается не выплывой.
[01:18:30.040 --> 01:18:32.040]  Чтобы гарантировать, что он будет выплывой, мне достаточно что сделать.
[01:18:32.040 --> 01:18:39.040]  Мне достаточно просто-напросто удалить по 5, ну и из стека тоже удаляю по 5.
[01:18:39.040 --> 01:18:44.040]  И, соответственно, теперь я проверяю вектора П3 по 4 и по 4 по штрих.
[01:18:44.040 --> 01:18:50.040]  Все, смотрите, я вижу, что в этот момент у меня многоугольник остался выплылым.
[01:18:50.040 --> 01:18:57.040]  И, соответственно, я спокойно-душом могу добавить по штриху в стек и продолжить алгоритм дальше.
[01:18:57.040 --> 01:19:01.040]  Вот такая вот история.
[01:19:01.040 --> 01:19:05.040]  Давайте кратко обсудим, почему это работает.
[01:19:05.040 --> 01:19:09.040]  На самом деле это довольно понятно.
[01:19:09.040 --> 01:19:11.040]  Можно рассуждать по индукции.
[01:19:11.040 --> 01:19:16.040]  Индукция заключается в том, что на каждой итерации, после каждого добавления точки стек,
[01:19:16.040 --> 01:19:21.040]  у вас построена выплылая оболочка для всех точек, которые вы уже рассмотрели.
[01:19:21.040 --> 01:19:23.040]  Давайте в этом убедимся.
[01:19:23.040 --> 01:19:29.040]  По предположению индукции у вас построена корректная выплылая оболочка для этого множества точек.
[01:19:29.040 --> 01:19:32.040]  Тут есть какие-то точки, и для них вы построили корректную выплылую оболочку.
[01:19:32.040 --> 01:19:34.040]  Вот она.
[01:19:34.040 --> 01:19:36.040]  По 0, по 1, по 2, по 3, по 4.
[01:19:36.040 --> 01:19:38.040]  Что можно сказать дальше?
[01:19:38.040 --> 01:19:42.040]  На текущей итерации я рассматривал точку по штрих.
[01:19:42.040 --> 01:19:46.040]  Что я знаю про направление по 0 по штрих?
[01:19:46.040 --> 01:19:50.040]  Я знаю, что все точки, которые находятся правее, я уже рассмотрел.
[01:19:50.040 --> 01:19:57.040]  Все точки, которые находятся правее, находятся правее, чем по 0 по штрих.
[01:19:57.040 --> 01:20:02.040]  В этом смысле сторона по 0 по штрих сохраняет выплылость моего многоугольника.
[01:20:02.040 --> 01:20:05.040]  Все вершины находятся правее нее.
[01:20:05.040 --> 01:20:09.040]  Это следует из-за того, что я все углы рассматриваю в порядке взрастания.
[01:20:09.040 --> 01:20:16.040]  Наконец, осталось понять, действительно ли все точки, которые находятся внутри треугольника по 0 по 4,
[01:20:16.040 --> 01:20:26.040]  действительно ли все эти точки находятся внутри этого треугольника?
[01:20:26.040 --> 01:20:29.040]  Это тоже действительно так.
[01:20:29.040 --> 01:20:33.040]  Я избавился от точек по 6 по 5.
[01:20:33.040 --> 01:20:42.040]  Вектор по 4 по штрих явно находится выше, чем направление на по 4 по 5 или направление на по 4 по 6.
[01:20:42.040 --> 01:20:46.040]  Соответственно, это означает, что все точки, которые находятся...
[01:20:46.040 --> 01:20:50.040]  На самом деле тут точек быть не может.
[01:20:50.040 --> 01:20:59.040]  Все точки, которые находятся вот здесь, они гарантированно находятся ниже, чем эта сторона по 4 по штрих.
[01:20:59.040 --> 01:21:01.040]  Соответственно, что я получил?
[01:21:01.040 --> 01:21:06.040]  Я получил, что у меня фигура гарантирована в букле по строению.
[01:21:06.040 --> 01:21:10.040]  Я гарантировал, что все углы у меня образуют положительный поворот.
[01:21:10.040 --> 01:21:19.040]  Во-вторых, я убедился в том, что у меня все рассмотренные на текущий момент точки, они гарантированно находятся внутри этого самого многоугольника.
[01:21:19.040 --> 01:21:25.040]  Это краткое обоснование, почему это работает.
[01:21:31.040 --> 01:21:34.040]  Есть ли вопрос по работе алгоритма?
[01:21:34.040 --> 01:21:39.040]  Пора бы закончить, перейти к следующей лекции.
[01:21:44.040 --> 01:21:47.040]  Понятно ли, что сейчас произошло или есть вопрос?
[01:21:54.040 --> 01:21:56.040]  То есть в целом история простая.
[01:21:56.040 --> 01:22:01.040]  Сортировку написать все могут, отсортировать по углу это просто.
[01:22:01.040 --> 01:22:06.040]  А дальше просто заводим stack, в котором храним точки, которые образуют мою выпуклую оболочку.
[01:22:06.040 --> 01:22:13.040]  Когда берем очередную точку в порядке возрастания, смотрим на знак угла, который образует последние две точки,
[01:22:13.040 --> 01:22:18.040]  то есть пока-минус-один-пока и текущий вектор, пока-пи.
[01:22:18.040 --> 01:22:20.040]  Если этот угол отрицательный, то все плохо.
[01:22:20.040 --> 01:22:22.040]  Нужно последнюю точку из stack удалить.
[01:22:22.040 --> 01:22:25.040]  Снова проверяем. Если новый угол отрицательный, снова удаляем последнюю точку из stack.
[01:22:25.040 --> 01:22:29.040]  Ну и так далее, пока мы не найдем этот самый нужный положительный угол.
[01:22:29.040 --> 01:22:33.040]  Как только угол стал положительным, и все, отлично мы победили, кладем очередную точку в stack.
[01:22:33.040 --> 01:22:34.040]  И все.
[01:22:34.040 --> 01:22:37.040]  Ну и продолжаем, понятное дело, до тех пор, пока не переберем все точки.
[01:22:39.040 --> 01:22:44.040]  Вопросов вроде нет, поэтому давайте, собственно, обсудим сложность алгоритма.
[01:22:45.040 --> 01:22:47.040]  И закончим на этом.
[01:22:49.040 --> 01:22:50.040]  Сложность.
[01:22:51.040 --> 01:22:53.040]  Сортировка.
[01:22:53.040 --> 01:22:55.040]  Сортировка, как мы сказали, работает за nlog n.
[01:22:58.040 --> 01:23:00.040]  Вот это пункт 2.
[01:23:00.040 --> 01:23:02.040]  А пункт 3.
[01:23:02.040 --> 01:23:04.040]  Вот с пунктом 3 интересно.
[01:23:04.040 --> 01:23:08.040]  Смотрите, мы вроде как, sdstack и sdsort можно тут будет использовать.
[01:23:08.040 --> 01:23:10.040]  Ну sort, естественно, stack.
[01:23:10.040 --> 01:23:16.040]  Но sdstack вас не получится использовать, потому что вам нужно смотреть на последние две точки.
[01:23:17.040 --> 01:23:19.040]  Понимаете, да?
[01:23:19.040 --> 01:23:21.040]  Пк и pk-1.
[01:23:21.040 --> 01:23:27.040]  sdstack позволяет вам посмотреть на верхнюю точку, а на предпоследнюю не получится.
[01:23:27.040 --> 01:23:29.040]  Вот это плохая новость.
[01:23:29.040 --> 01:23:31.040]  А хорошая новость, ну, использовать sdvector.
[01:23:31.040 --> 01:23:37.040]  Я надеюсь, вы понимаете, как sdvector превратить в stack, у которого можно посмотреть две последние точки.
[01:23:41.040 --> 01:23:43.040]  Да.
[01:23:43.040 --> 01:23:45.040]  Соответственно, на чем я остановился?
[01:23:45.040 --> 01:23:46.040]  А, да, третий пункт.
[01:23:46.040 --> 01:23:50.040]  Ну, смотрите, кажется, что третий пункт теоретически работает долго.
[01:23:50.040 --> 01:23:51.040]  Почему?
[01:23:51.040 --> 01:23:58.040]  Потому что, смотрите, на каждой итерации вы добавляете точку и плюс еще удаляете какое-то неопределенное количество других точек.
[01:23:58.040 --> 01:24:04.040]  Но на самом деле я хочу сказать, что пункт 3 тоже выполняется за oatn.
[01:24:04.040 --> 01:24:09.040]  Выполняется за oatn.
[01:24:09.040 --> 01:24:11.040]  Почему?
[01:24:11.040 --> 01:24:13.040]  Сам себе знаю вопрос.
[01:24:14.040 --> 01:24:41.040]  Смотрите, в пункте 3 на каждой итерации добавляем ровно одну точку в выпуклую оболочку.
[01:24:41.040 --> 01:24:47.040]  И удаляем несколько.
[01:24:47.040 --> 01:24:53.040]  Позвольте, остальное я просто вслух поговорю.
[01:24:53.040 --> 01:24:55.040]  Значит, не буду писать.
[01:24:55.040 --> 01:24:59.040]  В общем, смотрите, теперь давайте посмотрим просто на каждую отдельную точку, на ее жизнь.
[01:24:59.040 --> 01:25:01.040]  Как выглядит жизнь любой точки.
[01:25:01.040 --> 01:25:03.040]  Жизнь любой точки довольно прозаично.
[01:25:03.040 --> 01:25:09.040]  Она один раз ровно один раз добавляется stack, и, возможно, один раз удаляется из stack.
[01:25:09.040 --> 01:25:15.040]  Смотрите, после того, как я удалил точку из stack, к ней я больше никогда не вернусь.
[01:25:15.040 --> 01:25:19.040]  Жизнь любой точки состоит из двух вещей.
[01:25:19.040 --> 01:25:22.040]  Во-первых, она гарантированно будет добавлена в stack в какой-то момент.
[01:25:22.040 --> 01:25:24.040]  А во-вторых, возможно, она когда-то будет из него удалена.
[01:25:24.040 --> 01:25:31.040]  Все мои действия сводятся к тому, что я один раз добавляю точку и один раз удаляю ее.
[01:25:31.040 --> 01:25:32.040]  Все, других действий у меня нет.
[01:25:32.040 --> 01:25:37.040]  Но, соответственно, а так как всего точек у меня n, то и, соответственно, действия я тоже сделаю не больше, чем 2n.
[01:25:37.040 --> 01:25:45.040]  Из этого следует не больше, чем 2n действий.
[01:25:47.040 --> 01:25:50.040]  Пункт два, сортировка, занимает n log n.
[01:25:50.040 --> 01:25:54.040]  Ну а пункт три, все эти махинации со stack-ом, суммарно занимают линейное время.
[01:25:54.040 --> 01:25:57.040]  Поэтому построили алгоритм Грехма, который работает за n log n.
[01:25:57.040 --> 01:25:59.040]  Можно временно удалить верхнюю и посмотреть вторую.
[01:25:59.040 --> 01:26:01.040]  Ну, можно и так.
[01:26:01.040 --> 01:26:03.040]  Зачем?
[01:26:06.040 --> 01:26:09.040]  Мне кажется, вектор будет гораздо проще воспользоваться.
[01:26:09.040 --> 01:26:12.040]  Ну, не знаю. Развлекайтесь, как хотите.
[01:26:13.040 --> 01:26:15.040]  Так, время. Что у нас там по времени?
[01:26:15.040 --> 01:26:21.040]  Да, надо будет сделать перерыв. У нас еще разговор про наследование запланирован.
[01:26:23.040 --> 01:26:25.040]  Так, есть ли вопросы?
[01:26:31.040 --> 01:26:37.040]  В общем-то, детали реализации вы еще дополнительно, естественно, обсудите на семинарах.
[01:26:37.040 --> 01:26:41.040]  Ну и в целом, на этом, наверное, с геометрией мы закончим.
[01:26:41.040 --> 01:26:46.040]  В следующий раз будем обсуждать другую тему.
[01:26:46.040 --> 01:26:48.040]  Вопросов нет. Отлично.
[01:26:48.040 --> 01:26:51.040]  Тогда предлагаю лекцию по алгоритму завершить на сегодня.
[01:26:51.040 --> 01:26:55.040]  Давайте сделаем перерыв 10 минут.
[01:26:55.040 --> 01:26:57.040]  Большой перерыв.
[01:26:57.040 --> 01:26:59.040]  Через 10 минут, когда поговорим про плюсы.
