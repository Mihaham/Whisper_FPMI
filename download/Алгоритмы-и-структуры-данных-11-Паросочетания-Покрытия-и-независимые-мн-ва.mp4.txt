[00:00.000 --> 00:08.760]  Итак, мы сегодня поговорим про просочетания, что это
[00:08.760 --> 00:14.000]  вообще такое, как их искать в двудольных графах, и
[00:14.000 --> 00:18.360]  с их помощью докажем терму Кионига, и тем самым найдем
[00:18.360 --> 00:21.000]  алгоритм, как находить в двудольном графе максимально
[00:21.000 --> 00:23.600]  независимое множество и минимально вершинное покрытие.
[00:23.600 --> 00:24.600]  До этого еще дойдем.
[00:25.600 --> 00:31.280]  То есть, определение пусть уже это неориентированный
[00:31.280 --> 00:42.560]  граф, тогда под множество, множество его ребер называется
[00:42.560 --> 00:43.560]  просочетанием.
[00:43.560 --> 00:55.800]  Если никакие два его ребра, никакие два ребра из m не
[00:55.800 --> 00:56.800]  имеют общих вершин.
[00:56.800 --> 01:11.480]  Никакие два ребра множества m не имеют общих вершин.
[01:11.480 --> 01:19.080]  Ну, пример какой-то такой.
[01:19.080 --> 01:34.080]  Нарисую такой квадратик, и тогда можно будет вот
[01:34.080 --> 01:38.320]  эти два ребра выбрать и искать, что это просочетание,
[01:38.320 --> 01:42.240]  потому что это ребра исходного графа, множество m из этих
[01:42.240 --> 01:45.520]  двух ребер лежит в множестве ребер исходного графа, и
[01:45.520 --> 01:48.760]  при этом они не пересекаются по, ну, не имеют общих концов,
[01:48.760 --> 01:49.760]  не имеют общих вершин.
[01:49.760 --> 01:53.720]  Тут можно еще говорить, что они не пересекаются
[01:53.720 --> 01:56.280]  по вершинам, что значит не имеют общих вершин, ну,
[01:56.280 --> 01:58.520]  не пересекаются по вершинам, мы помним, что ребра это по
[01:58.520 --> 02:01.360]  сути пары вершинок, может быть, что вот эти пары не
[02:01.360 --> 02:04.120]  пересекаются, ну, собственно, просто, да, как множество.
[02:04.120 --> 02:07.560]  Но если вы графически изображаете ребра, то они вполне спокойно
[02:07.560 --> 02:10.160]  могут пересекаться, главное, что у них нет общих концов,
[02:10.160 --> 02:11.160]  не пересекаются по концам именно.
[02:11.160 --> 02:17.800]  Вот, по-другому можно сформулировать вот так, да, иными словами.
[02:17.800 --> 02:28.440]  Значит, граф v запятая m должен иметь степени всех вершин
[02:28.440 --> 02:44.440]  не больше чем один, должен иметь степени всех вершин,
[02:44.440 --> 02:45.440]  не больше единицы.
[02:45.440 --> 02:49.120]  Степень, напоминаю, это число ребр, которые из вершины
[02:49.120 --> 02:52.720]  торчат нас, сколько ребр исходит из данной вершинки.
[02:52.720 --> 02:55.320]  Ну, вот, например, на этой картинке у всех четырех
[02:55.320 --> 02:58.200]  вершин степень ровно один, если мы оставляем только
[02:58.220 --> 03:00.440]  ребра про сочетания.
[03:00.440 --> 03:03.840]  Этот ребро дают плюс и д投ичку сюда и сюда.
[03:03.860 --> 03:05.220]  Поэтому всех вершин остается один.
[03:05.220 --> 03:08.860]  И в этом новом графе, когда мы вместо реб três ax, оставляем
[03:08.860 --> 03:10.100]  Wales rapper сочетания.
[03:10.100 --> 03:12.800]  Тогда у всех вершин степени ровно единичка.
[03:12.800 --> 03:15.360]  Ну, понятно, может быть степень М, какая deutsche
[03:15.360 --> 03:18.580]  вершина, которая не входит в поросочетании и понятно,
[03:18.580 --> 03:20.380]  что не может быть два, потому что если уhov у вершин
[03:20.380 --> 03:23.240]  ст Adrianva значит из нее торчит два ребра по сочетания, значит
[03:23.240 --> 03:25.700]  нет, очевидны, пересекаются ровно по этой вершинке степней
[03:25.700 --> 03:27.500]  два у нас быть не может.
[03:27.500 --> 03:31.500]  Вот, ну то есть какой-то такой подграф, где у каждой вершины степень максимум 1.
[03:34.500 --> 03:42.500]  Хорошо. Ну и наша глобальная цель была бы научиться находить наибольшее по размеру, по рассчитанию в произвольном графе.
[03:42.500 --> 03:46.500]  То есть это можно делать, но мы ограничимся только случаем двудольного графа.
[03:47.500 --> 03:54.500]  Значит наша цель по данному, в удольному графу
[04:03.500 --> 04:05.500]  найти максимальное по рассчитанию.
[04:05.500 --> 04:07.500]  Ну то есть по рассчитанию максимальной мощности.
[04:08.500 --> 04:11.500]  То есть нужно максимизировать мощность тем.
[04:12.500 --> 04:15.500]  Вот, и повторюсь, мы ограничимся только случаем двудольного графа.
[04:16.500 --> 04:20.500]  Где? Значит напомню, кажется у нас не было двудольного, в семинаре только был.
[04:20.500 --> 04:24.500]  Значит граф уже называется двудольным.
[04:25.500 --> 04:31.500]  Ну например так, если все его вершины можно разбить на две доли, на два множества, так что ребра у нас только между долями.
[04:34.500 --> 04:38.500]  Значит если существует такие множества l и l, то может быть 2down.
[04:43.500 --> 04:47.500]  Если только есть 2.
[04:47.500 --> 04:52.900]  два множества, так что ребра у нас только между долями.
[04:52.900 --> 04:56.220]  Если существует такие множества L и R, то множество вершин
[04:56.220 --> 05:00.380]  это их дизюмптное объединение, то есть объединить L и R получится
[05:00.380 --> 05:04.300]  V, при этом L и R не пересекаются, и при этом любое ребро из
[05:04.300 --> 05:11.620]  E, оно одним концом лежит в L, другим концом лежит в R.
[05:11.620 --> 05:15.980]  При этом любая пара у V, лежащая в E, удовлетворяет такому
[05:15.980 --> 05:28.460]  условию, либо U в L, A в V в R, или наоборот, U в R, V в L.
[05:28.460 --> 05:31.460]  Формальное определение более даже громоздкое, чем
[05:31.460 --> 05:32.580]  интуитивное понимание.
[05:32.580 --> 05:34.460]  Есть несколько вершин X слева, есть несколько вершин
[05:34.460 --> 05:37.220]  X справа, L и R, соответственно, и ребра могут быть только
[05:37.220 --> 05:38.900]  между долями, но не внутри доли.
[05:46.460 --> 05:50.140]  M это всегда, пар соч, это всегда под множество ребер.
[05:50.140 --> 05:54.860]  В паросочетании вершины не выделяются, только ребра.
[05:54.860 --> 05:57.460]  Ну а вершины, интуитивно можно ощущать, что все вершины
[05:57.460 --> 06:00.700]  остаются, главное, чтобы у них степень была не больше
[06:00.700 --> 06:01.700]  чем один.
[06:01.700 --> 06:03.660]  То есть на вершины мы как бы не смотрим, когда определяем
[06:03.660 --> 06:05.420]  паросочетание, только на ребра.
[06:05.420 --> 06:09.420]  Хорошо.
[06:09.420 --> 06:19.020]  Так, ну и давайте тогда сделаем следующее, наблюдение тоже
[06:19.020 --> 06:23.740]  еще одно определение, как можно было бы искать паросочетание.
[06:23.740 --> 06:42.220]  Ну вот пусть M это какое-то паросочетание в графе G,
[06:42.220 --> 06:57.260]  когда путь в G называется увеличивающим путем или
[06:57.260 --> 07:00.180]  увеличивающей цепью, что то же самое.
[07:12.660 --> 07:13.660]  Так, опять поторопился.
[07:13.660 --> 07:16.900]  Ладно, значит, если первые и последние вершины этого
[07:16.900 --> 07:22.420]  пути не насыщены паросочетанием, то есть в терминах степени
[07:22.420 --> 07:25.820]  имеют степень ноль, никакое ребро паросочетания им
[07:25.820 --> 07:28.940]  не смежно, первые и последние как бы не лежат в паросочетании,
[07:28.940 --> 07:33.020]  не насыщены ребром паросочетания, а на пути происходит чередование.
[07:33.980 --> 07:41.100]  Значит, давайте напишем, первая и последняя вершины
[07:41.100 --> 07:51.820]  пути не насыщены M, не насыщены, значит, что нет ни одного
[07:51.820 --> 07:55.820]  ребра паросочетания, которое бы торчало из этих вершин.
[07:55.820 --> 07:58.500]  Вот, и дальше на пути у нас должно быть чередование
[07:58.500 --> 07:59.500]  типов ребер.
[07:59.500 --> 08:02.300]  Первое ребро должно быть не из M, второе из M, третье
[08:02.300 --> 08:03.940]  не из M, четвертое из M и так далее.
[08:03.940 --> 08:11.260]  Я буду это называть типами ребер, типы ребер на пути
[08:11.260 --> 08:14.260]  чередуются.
[08:14.260 --> 08:19.140]  Ну и картинка.
[08:19.140 --> 08:22.980]  Значит, первая вершина должна быть не насыщена
[08:22.980 --> 08:27.260]  паросочетанием, дальше должно идти ребро не из паросочетания,
[08:27.260 --> 08:28.260]  не M.
[08:29.220 --> 08:32.980]  Дальше должно идти ребро из паросочетания M, потом
[08:32.980 --> 08:39.020]  опять не из M, потом из M, потом не из M и должно закончиться
[08:39.020 --> 08:41.620]  опять вершины не насыщены паросочетанием.
[08:41.620 --> 08:45.900]  Значит, первая и последняя должны быть не насыщены
[08:45.900 --> 08:46.900]  паросочетанием.
[08:46.900 --> 08:52.140]  Где, повторюсь, насыщенность означает, что хотя бы одно
[08:52.140 --> 08:55.100]  ребро из этой вершинки торчит, которое лежало бы в паросочетании.
[08:55.940 --> 08:58.740]  То есть в терминах вот того графа в M степень должна
[08:58.740 --> 09:02.460]  быть ровной единицей, чтобы быть насыщенной.
[09:02.460 --> 09:05.460]  Понятно определение?
[09:05.460 --> 09:10.740]  Вот, зачем оно нам надо?
[09:10.740 --> 09:12.060]  Ответ очень простой.
[09:12.060 --> 09:15.780]  Если относительно M есть какая-то увеличивающая цепь,
[09:15.780 --> 09:22.700]  то M можно очень легко увеличить, выполнив чередование вдоль
[09:22.700 --> 09:23.700]  пути.
[09:23.700 --> 09:29.700]  Значит, что такое чередование?
[09:29.700 --> 09:32.340]  Доль увеличивающего пути.
[09:32.340 --> 09:37.820]  Ну, это просто нужно инвертировать типы ребер, которые на
[09:37.820 --> 09:38.820]  этом пути находятся.
[09:38.820 --> 09:41.540]  Те ребра, которые были не в M, нужно добавить в M, а
[09:41.540 --> 09:44.220]  те, которые, наоборот, были в M, надо оттуда удалить.
[09:44.220 --> 09:46.140]  Давайте на примере двухдольного графа я нарисую.
[09:46.140 --> 09:49.620]  Вот представьте, что у меня был вот такой увеличивающий
[09:49.620 --> 09:50.620]  путь.
[09:50.980 --> 09:55.900]  Пунктиры это не из М, сплошные это из М.
[09:55.900 --> 10:00.140]  Я инвертирую типы всех ребер.
[10:00.140 --> 10:03.180]  То есть, я удаляю их в парасосочетании вот эти два ребра,
[10:03.180 --> 10:05.300]  а добавляю вот эти три.
[10:05.300 --> 10:06.700]  Тога картинка будет такой.
[10:06.700 --> 10:08.920]  Значит, это ребро теперь в парасосочетании, это
[10:08.920 --> 10:11.860]  не в парасосочетании, это в парасосочетании, это
[10:11.860 --> 10:14.540]  не в парасосочетании, это в парасосочетании.
[10:14.540 --> 10:15.540]  Вот.
[10:15.540 --> 10:17.940]  Ну, легко видеть, что число ребер в парасосочетании,
[10:17.940 --> 10:23.640] Show pewper в М увеличилась ровно на единичку. Минус 2 г付 3, это ровно плюс 1
[10:23.660 --> 10:27.540]  Ну и при этом если исходное у нас было по прочитанию, то оно и прощанием останется
[10:28.060 --> 10:31.100]  потому что чтобы это было по прочитанию мне нужно что бы степени всех вышин
[10:31.120 --> 10:31.160]  Потому что чтобы это было по прочитанию мне нужно чтобы степень всех вышин
[10:31.180 --> 10:32.600]  были максимум единичка
[10:33.000 --> 10:37.200]  Ну понятно для этих вышин ничего не поменялось, у них как была степень один так и осталось степень один
[10:37.560 --> 10:39.540]  на ровно по одному либо про посчитания их из них исходит
[10:40.220 --> 10:42.720]  А для этих вышин была степень ноль, а теперь осталось степень один
[10:47.940 --> 11:06.060]  первые и последние не совпадают, сейчас, секунду, да, да, наверное, это правильное
[11:06.060 --> 11:11.260]  замечание, в общем случае, да, если у нас граф не обязательно двудольный, то есть
[11:11.260 --> 11:15.100]  в двудольной все равно такого не будет, вот, но давайте добавим, да, действительно, что
[11:15.100 --> 11:21.820]  наш путь простой, так, где это было, простой путь, простой, значит, в частности, в нем все
[11:21.820 --> 11:30.660]  ребра совершенно различны, я вот так сделаю, ну вот, значит, давайте запишу, что все ребра,
[11:30.660 --> 11:46.980]  не лежавшие в М, добавляем в М, все ребра, лежавшие в М, и, наоборот, оттуда удаляем,
[11:46.980 --> 12:10.340]  удаляем из М, получим просочетание большего размера, получим просочетание большего размера,
[12:17.580 --> 12:22.520]  вот, такой простой наблюдение, что если einem есть такой вот увеличивающий путь, то можно сделать
[12:22.520 --> 12:28.460]  чередование и, собственно, ответ, увеличить размер просочек, работает ли это в обратную
[12:28.460 --> 12:32.940]  сторону, то есть правда ли, что достаточно искать только такие увеличивающие пути, чтобы всегда
[12:32.940 --> 12:38.860]  находить максимальное просчитание, оказывается, да, и наш алгоритм, собственно, ровно так и будет
[12:38.860 --> 12:43.060]  работать, он будет пытаться находить такие увеличивающие пути, пока они есть, если хотя
[12:43.060 --> 12:44.780]  обоин есть, то он делает чередование вдоль него
[12:44.780 --> 12:46.500]  и пытается найти опять.
[12:46.500 --> 12:48.180]  Если в какой-то момент он не смог найти ни одного
[12:48.180 --> 13:00.980]  такого пути, значит он завершается наше просчитание максимально.
[13:00.980 --> 13:09.340]  Корректность этого — это теорема Бержа.
[13:09.340 --> 13:12.280]  Она утверждает следующее, что в графе G просчитание
[13:12.280 --> 13:14.760]  максимально, если и только если относительно него
[13:14.760 --> 13:16.440]  нету увеличивающих путей.
[13:16.440 --> 13:35.640]  В графе G просочетание M максимально, если и только
[13:35.640 --> 13:37.800]  если относительно него нету увеличивающих путей
[13:37.800 --> 13:39.320]  в том самом понимании, как в определении.
[13:39.320 --> 13:55.320]  Скажите, пожалуйста, в каком из двух сторон мы уже
[13:55.320 --> 13:56.320]  это утверждение доказали.
[13:56.320 --> 14:04.560]  Да, слева направо, что если оно максимально, то нету
[14:04.560 --> 14:06.400]  увеличивающих, потому что если бы были, то можно было
[14:06.400 --> 14:07.400]  бы увеличить.
[14:07.400 --> 14:11.600]  Это вот мы здесь доказали.
[14:11.600 --> 14:20.960]  Если M максимально, но есть увеличивающий путь, то
[14:20.960 --> 14:23.440]  можно выполнить чередование и получить просоч большего
[14:23.440 --> 14:24.440]  размера противоречия.
[14:24.440 --> 14:33.040]  То после чередования будет просочетание большего
[14:33.040 --> 14:34.040]  размера.
[14:34.040 --> 14:48.160]  Большего размера противоречия, мы предположили, что M максимально
[14:48.160 --> 14:49.160]  получили еще больше.
[14:49.160 --> 14:52.360]  Вот, а обратную сторону чуть похитрее, тут нам придется
[14:52.360 --> 14:53.360]  повозиться.
[14:53.360 --> 14:56.040]  И начнем из такой леммы.
[14:56.040 --> 15:05.440]  Пропроизвольный граф, здесь на самом деле мы нигде в
[15:05.440 --> 15:07.680]  удовольствии не будем пользоваться, я это еще отдельно отмечу.
[15:07.680 --> 15:12.480]  Лемма такая, пусть у нас есть некоторый ориентированный,
[15:12.480 --> 15:15.560]  не ориентированный граф, в той степени вершин, в
[15:15.560 --> 15:16.560]  котором не больше, чем два.
[15:16.560 --> 15:20.960]  Тогда, как он выглядит, он выглядит как объединение
[15:20.960 --> 15:21.960]  путей и циклов.
[15:21.960 --> 15:34.400]  Лемма, пусть H неориентированный граф, в той степени вершин,
[15:34.400 --> 15:47.040]  в котором не происходят двойки, либо 0, либо 1, либо
[15:47.040 --> 15:48.040]  2.
[15:48.040 --> 15:50.560]  Тогда, любая компонента связанности графа H, это
[15:50.560 --> 15:51.840]  либо путь, либо цикл.
[16:20.560 --> 16:32.640]  Ну, доказательство очень простое.
[16:32.640 --> 16:36.960]  Значит, давайте сначала избавимся от вершин к степени
[16:36.960 --> 16:37.960]  0.
[16:37.960 --> 16:42.360]  Если в графе H есть вершины степени 0, то это просто
[16:42.360 --> 16:44.920]  такие изолированные точечки, которые ни с кем не соединены,
[16:44.920 --> 16:46.800]  но можно считать, что это отдельные компоненты связанности,
[16:46.800 --> 16:48.800]  скажем, пути длины 0.
[16:48.800 --> 16:49.800]  Окей.
[16:50.160 --> 16:53.160]  Удалили все вершины степени 0.
[16:53.160 --> 16:56.640]  Вершины степени 0, но это изолированные, мы их просто
[16:56.640 --> 16:57.640]  удаляем.
[16:57.640 --> 17:00.480]  Это компоненты пути длины 0.
[17:00.480 --> 17:03.200]  Дальше, пусть есть вершины степени 1.
[17:03.200 --> 17:04.680]  Ну, давайте какой-нибудь из них посмотрим.
[17:04.680 --> 17:08.920]  Здесь вершиновые степени 1.
[17:08.920 --> 17:09.920]  Степени 1.
[17:09.920 --> 17:11.880]  Значит, из нее исходит ровно одно ребро.
[17:11.880 --> 17:13.320]  Ну, вот куда-то оно исходит.
[17:13.320 --> 17:14.320]  Какой-то другой вершин.
[17:14.320 --> 17:18.960]  Если это вершины степени 1, то это компоненты связанности.
[17:19.120 --> 17:20.800]  Есть две вершины, они соединены, больше никаких ребер из них
[17:20.800 --> 17:21.800]  нет.
[17:21.800 --> 17:23.720]  Если это степени 1, то больше ничего здесь нет.
[17:23.720 --> 17:25.840]  Это ребро, это отдельный компонент связанности,
[17:25.840 --> 17:27.360]  больше, оно ни с кем не соединено.
[17:27.360 --> 17:30.680]  Если степень 2, то соответственно из этой вершинки кто-то еще
[17:30.680 --> 17:31.680]  исходит.
[17:31.680 --> 17:33.080]  Есть такое второе ребро.
[17:33.080 --> 17:34.080]  Отлично.
[17:34.080 --> 17:35.800]  От этого то есть не ледущие в эту вершину.
[17:35.800 --> 17:38.480]  Ну вот куда-то сюда оно ведет.
[17:38.480 --> 17:38.840]  И то же самое.
[17:38.840 --> 17:41.400]  Если у этой вершинки степень 1, то значит, мы целиком
[17:41.400 --> 17:43.280]  нарисовали эту компоненту связанности, потому что
[17:43.280 --> 17:46.200]  больше никаких ребер, исходящих из этих вершин, нету.
[17:46.200 --> 17:48.040]  Поэтому это отдельная компонента.
[17:48.040 --> 17:55.480]  Иначе, если степень 2, то из нее исходит опять какое-то ребро, причем не отвержается обязательно в новую вершину, потому что никуда назад, скажем, вот сюда вот,
[17:55.480 --> 18:02.340]  оно вести не могло, потому что тогда вот в этой вершине степень бы увеличилась. Вот сюда не может вести ребро, потому что здесь была бы тогда степень 2.
[18:02.340 --> 18:08.240]  На все обязательно новая вершина. Ну и опять, если тут 1, то это конец, да, конец компонент связанности.
[18:08.240 --> 18:11.640]  Если степень 2, то обязательно новая вершина должна быть.
[18:12.440 --> 18:17.740]  Вот, и так, понятное дело, бесконечно долго мы идти не можем, обязательно мы рано или поздно дойдем до вершины степени 1.
[18:18.940 --> 18:20.740]  Вот вам, пожалуйста, компонент связанности и путь.
[18:24.340 --> 18:28.540]  Значит, тем самым мы избавились от всех вершин степени 1 или 0.
[18:30.140 --> 18:35.740]  0 отдельно, если начали в 1, то закончили в 1 и отпустили путь, да, компонент, который является путем.
[18:36.140 --> 18:39.640]  Значит, теперь остались только вершины степени 2, давайте рассмотрим какую-нибудь из них.
[18:40.340 --> 18:41.540]  Вот здесь вершина степени 2.
[18:43.240 --> 18:45.740]  Из нее есть хоть два ребра, давайте рассмотрим какую-нибудь одну из них.
[18:46.540 --> 18:56.540]  Ну, дальше тоже самый аргумент, если это вершина степени 2, то значит есть какое-то ребро из нее, либо, ну, сюда оно вести не может, значит, куда-то в какую-то новую вершину.
[18:56.940 --> 19:06.440]  Это опять вершина степени 2, 1 ребро уже учтено, значит, либо это куда-то ребро в новую вершину, либо куда-то в одну из старых, но давайте пока что в новую.
[19:07.240 --> 19:09.440]  Значит, и так мы будем идти, идти, идти в какой-то момент.
[19:10.040 --> 19:19.540]  Второе ребро из очередной вершины будет вести уже в одну из посещенных, но тогда она обязательно идет именно в начальную вершину, потому что иначе у нас была бы вершина степени 3.
[19:19.940 --> 19:25.440]  Если бы очередное ребро вело было в одну из посещенных, кроме начальной, то у меня была бы вершина степени 3.
[19:25.940 --> 19:31.340]  Поэтому единственный момент, когда мой вот этот путь может зациклиться, только когда я возвращаюсь в стартовую вершину.
[19:32.240 --> 19:37.240]  Тем самым я получил вот такой цикл, с вершиной на нем имеют в степени ровно 2, поэтому это отдельная компонента.
[19:38.240 --> 19:39.240]  Ну, кажется, все.
[19:41.240 --> 19:48.840]  То есть, если мы начинаем с вершины степени 1, то мы откушаем путь, если с вершины степени 2 и при этом с вершины степени 1 уже откушены, то это обязательно цикл.
[19:49.040 --> 19:49.540]  Ну, все.
[19:51.040 --> 19:51.540]  Согласны?
[19:59.040 --> 20:00.240]  Так, зачем нам эта лимба?
[20:01.340 --> 20:14.240]  Ну, продолжим вот это доказательство справа-налево.
[20:16.240 --> 20:25.240]  Предполагаем противное, то есть, что есть какое-то прощание m, относительно которого нет увеличивающих путей, но при этом оно не максимально.
[20:26.240 --> 20:29.240]  Пусть m не максимально.
[20:32.240 --> 20:34.240]  Но относительно него нет увеличивающих путей.
[20:43.240 --> 20:45.240]  Ну окей, если m не максимально, давайте рассмотрим какое-то максимальное.
[20:48.240 --> 20:52.240]  Пусть m' максимальное прощание.
[20:59.240 --> 21:01.240]  Пусть m' максимальное прощание.
[21:02.240 --> 21:05.240]  Мы знаем, что его мощность точно больше, чем m, по предположению.
[21:07.240 --> 21:11.240]  Раз m не максимально, а m' максимальное, то есть такое неравенство на размеры этих множеств.
[21:13.240 --> 21:14.240]  Вот, и я рассмотрю такой граф.
[21:15.240 --> 21:25.240]  Значит, если у меня g это было ve, то я рассмотрю h, v запятая m, симметрическая разность m'.
[21:26.140 --> 21:36.140]  Здесь симметрическая разность, если у меня есть два множества, то симметрическая разность, вот этот треугольничек, это все, что попадает ровно в одно из них.
[21:37.040 --> 22:04.040]  Я оставлю только такие ребра, которые входят ровно в одно из двух по рассчитания, либо только в m, либо только в m', но не в оба одновременно.
[22:04.940 --> 22:08.940]  Те, которые лежали и там, и там, то есть, например, какое-то ребро могло быть взято и в m, и в m'.
[22:09.940 --> 22:13.940]  Вот такие я не включаю в h, такие я удаляю, потому что они лежат в этом пересечении, я их не включаю в h.
[22:16.940 --> 22:18.940]  Так вот, тогда h удовлетворяет условию леммы.
[22:19.940 --> 22:21.940]  В нем каждая вершина, очевидно, имеет степень не больше, чем 2.
[22:22.940 --> 22:30.940]  Ну, потому что, скажем, сколько может быть ребер инцидентных в какой-то вершине из графа h?
[22:31.840 --> 22:33.840]  Вот есть какая-то вершина, какие ребра из нее могут торчать?
[22:34.840 --> 22:36.840]  Ну, понятное дело, максимум одно ребро из m и максимум одно ребро из m'.
[22:37.840 --> 22:39.840]  Значит, его степень не больше, чем 2.
[22:41.840 --> 22:50.840]  Для любой вершины степень с индексом h от v, то есть в графе h, не больше, чем 2.
[22:51.740 --> 22:58.740]  Ну, потому что, еще раз, у каждой вершины v я оставляю только ребра, лежащие либо в m, либо в m',
[22:59.740 --> 23:02.740]  поэтому максимум какая может быть у нее степень?
[23:03.740 --> 23:05.740]  Это одно ребро отсюда, одно ребро отсюда, не может быть два ребра, скажем, из m,
[23:06.740 --> 23:08.740]  потому что из вершины не может торчать два ребра из одного по расчетанию.
[23:09.740 --> 23:10.740]  Если это оба из m, то это не по расчетанию.
[23:11.740 --> 23:14.740]  Значит, максимум одно ребро из m, одно ребро из m', значит, степень максимум 2.
[23:16.740 --> 23:20.740]  Поэтому h распадается на пути циклы.
[23:20.840 --> 23:22.840]  Там каждый компонент это путь или цикл.
[23:30.840 --> 23:36.840]  H распадается на пути цикла.
[23:40.840 --> 23:42.840]  Хорошо.
[23:45.840 --> 23:49.840]  Давайте докажем, что среди этих компонентов нет ни одного цикла нищенной длины.
[23:50.840 --> 24:14.840]  Так, ну как может выглядеть цикл нищетной длины?
[24:14.840 --> 24:16.840]  Вот есть какая-то вершина в H.
[24:16.840 --> 24:18.840]  И исходящая степень 2.
[24:18.840 --> 24:20.840]  Есть какие-то два ребра, которые из нее торчат.
[24:20.840 --> 24:24.840]  Что вообще значит, что из вершины есть два ребра в графе H?
[24:24.840 --> 24:28.840]  Это значит, что одно из них пришло из M, а другое из M'.
[24:28.840 --> 24:32.840]  Мы понимаем, что из каждого прочитания могло прийти максимум одно ребро, потому что иначе было бы не прочитание.
[24:32.840 --> 24:35.840]  Значит, одно из них скажем из M, другое из M'.
[24:35.840 --> 24:39.840]  Это вот так однозначно можно определить, какое откуда.
[24:39.840 --> 24:41.840]  Дальше. Ну вот следующая вершина.
[24:42.840 --> 24:44.840]  Мы понимаем, что у нее опять степень 2.
[24:44.840 --> 24:46.840]  Раз это цикл, то у всех вершин степень 2.
[24:46.840 --> 24:49.840]  Одно ребро обязано из M прийти, другое из M'.
[24:49.840 --> 24:52.840]  Ну значит, вот как-то так мы должны продолжить наш цикл.
[24:52.840 --> 24:54.840]  Следующая вершинка.
[24:54.840 --> 24:57.840]  У нее одно ребро из M', второе должно быть из M.
[24:57.840 --> 25:00.840]  Для этого одно из M, другое из M', ну и так далее.
[25:00.840 --> 25:04.840]  Короче, у меня происходит чередование того, откуда пришло очередное ребро.
[25:04.840 --> 25:07.840]  Из M, из M', M', и так далее, и так далее.
[25:07.840 --> 25:11.840]  Ну понятно, что если у меня есть чередование, то у меня не может быть нечетная длина.
[25:11.840 --> 25:14.840]  Например, если у меня вот есть вот это как бы цикл...
[25:14.840 --> 25:16.840]  Ладно, раз, два, три, четыре, пять.
[25:16.840 --> 25:18.840]  Вот из цикла длины 5, давайте чередовать.
[25:18.840 --> 25:22.840]  M, M', M', M'.
[25:22.840 --> 25:23.840]  Противоречие.
[25:23.840 --> 25:27.840]  Не может быть два ребра, которые в одной вершинке встречаются.
[25:27.840 --> 25:30.840]  Итак, вот всегда, если у меня есть нечетная длина цикла,
[25:30.840 --> 25:36.840]  и я пытаюсь чередовать M' и M', то у меня обязательно в этой первой вершинке будет противоречие.
[25:37.840 --> 25:39.840]  Вот.
[25:41.840 --> 25:44.840]  Так, ну даже не знаю, что здесь записать.
[25:44.840 --> 25:49.840]  Значит, тут главное, что будут чередоваться...
[25:54.840 --> 26:04.840]  Значит, M', откуда пришли ребра?
[26:05.840 --> 26:08.840]  А что? Очередное ребро, значит, приходит из нового прочитания.
[26:08.840 --> 26:11.840]  Сначала M', потом M', и так по циклу.
[26:11.840 --> 26:14.840]  Хорошо, значит, нечетных циклов нет.
[26:14.840 --> 26:18.840]  Кстати, игра вот здесь, можно было бы сразу сказать, что почему нету циклов нечетной длины.
[26:18.840 --> 26:22.840]  Если бы мы жили в двудольном графе, то это было бы сразу очевидно,
[26:22.840 --> 26:28.840]  потому что одна из характеристик двудольного графа, это что в нем нет циклов нечетной длины.
[26:28.840 --> 26:32.840]  Поэтому если бы я в условии теоремы сразу говорил, что граф же двудольный,
[26:32.840 --> 26:35.840]  то это можно бы не доказывать, потому что H очевидно это под граф G,
[26:35.840 --> 26:38.840]  потому что там остаются только какие-то ребра графа G.
[26:38.840 --> 26:43.840]  Значит, циклов нечетной длины там ниоткуда взяться не могли.
[26:43.840 --> 26:47.840]  Вот, поэтому в случае двудольного графа этот случай можно даже не рассматривать.
[26:47.840 --> 27:02.840]  Хорошо. Мы поняли, что нету циклов нечетной длины.
[27:02.840 --> 27:10.840]  Значит, что у нас остается? У нас остаются циклы чётной длины,
[27:10.840 --> 27:16.840]  пути чётной длины
[27:16.840 --> 27:25.840]  и пути нечётной длины.
[27:25.840 --> 27:29.840]  Так, идея следующая. Смотрите, понятное дело, что каждый цикл чётной длины
[27:29.840 --> 27:33.840]  и каждый путь чётной длины, они вносят поровну ребер из M и M штрих.
[27:33.840 --> 27:36.840]  Потому что, опять, на них та же самая идея работает.
[27:36.840 --> 27:39.840]  Там чередуется то, откуда приходит каждое ребро.
[27:39.840 --> 27:42.840]  Если первое ребро из M, то второе обязательно из M штрих, третье из M и так далее.
[27:42.840 --> 27:47.840]  Значит, каждый цикл и путь вносят поровну ребер из M и M штрих.
[27:47.840 --> 27:51.840]  Но поскольку мы же поняли, что M штрих больше чем M,
[27:51.840 --> 28:03.840]  значит, я утверждаю, что обязательно должен быть хотя бы один нечётный путь,
[28:03.840 --> 28:27.840]  на котором ребер из M штрих больше чем ребер из M.
[28:27.840 --> 28:32.840]  Ну потому что, ещё раз, вот эти вот товарищи вносят поровну ребер из M и M штриха.
[28:32.840 --> 28:37.840]  А этот, соответственно, какого-то, ну что больше, либо M штрих, либо M.
[28:37.840 --> 28:40.840]  Но при условии, что M штрих больше чем M, да, у меня, понятно,
[28:40.840 --> 28:43.840]  должно быть хотя бы один цикл, хотя бы один путь нечётной длины,
[28:43.840 --> 28:46.840]  на котором M штрихов больше чем M.
[28:46.840 --> 28:49.840]  Значит, он как-то вот так вот выглядит.
[28:49.840 --> 28:58.840]  M штрих, M, M штрих, M, M штрих. Вот что-то такое.
[28:58.840 --> 29:01.840]  Тогда утверждаю, что вот этот путь, который я нашёл,
[29:01.840 --> 29:04.840]  компонента связанности в графе H, вот с таким свойством,
[29:04.840 --> 29:08.840]  она на самом деле является увеличивающим путём относительно M, который мы искали.
[29:12.840 --> 29:23.840]  Докажем, что этот путь, он на самом деле увеличивающий относительно M.
[29:29.840 --> 29:32.840]  Если это верно, то вы пришли к противоречию,
[29:32.840 --> 29:35.840]  потому что мы изначально предположили, что M не максимально,
[29:35.840 --> 29:38.840]  но путей относительно него увеличивающих нету.
[29:38.840 --> 29:40.840]  А вот сейчас мы его явно построили.
[29:40.840 --> 29:56.840]  Так, ну тут всё просто.
[29:56.840 --> 29:58.840]  Значит, почему это увеличивающий путь?
[29:58.840 --> 30:00.840]  Ну, вспоминаем определение.
[30:00.840 --> 30:03.840]  У нас, во-первых, первые и последние вершины должны быть,
[30:03.840 --> 30:06.840]  ну это понятно, простой путь, потому что это компонент связанности.
[30:06.840 --> 30:07.840]  Дальше.
[30:07.840 --> 30:09.840]  Первые и последние вершины должны быть ненасыщены
[30:09.840 --> 30:11.840]  по расширениям M.
[30:11.840 --> 30:12.840]  Это надо проверить.
[30:12.840 --> 30:14.840]  Почему они ненасыщены по расширениям M?
[30:14.840 --> 30:17.840]  Ещё нужно проверить, что у меня чередуются типы ребер.
[30:17.840 --> 30:20.840]  Что сначала должно идти ребро не из M, потом ребро из M.
[30:20.840 --> 30:22.840]  Не из M, из M, не из M.
[30:22.840 --> 30:24.840]  Ну, это чередование, очевидно, есть,
[30:24.840 --> 30:27.840]  потому что каждое второе ребро лежит в M,
[30:27.840 --> 30:33.840]  а все остальные лежат в M штрих и при этом лежат в H.
[30:33.840 --> 30:35.840]  Значит, точно в M они не лежат.
[30:35.840 --> 30:37.840]  Потому что если какое-то ребро из M штрих пришло в H,
[30:37.840 --> 30:39.840]  значит в M оно не лежало.
[30:39.840 --> 30:41.840]  Мы помним, что в H у нас есть только ребра,
[30:41.840 --> 30:43.840]  ну, лежащие в одном из двух прочитаний,
[30:43.840 --> 30:45.840]  и если в M штрих, то не в M.
[30:45.840 --> 30:47.840]  Поэтому с чередованием всё хорошо.
[30:47.840 --> 30:51.840]  Значит, давайте отметим, что типы ребер действительно чередуются так, как нам нужно.
[30:57.840 --> 30:59.840]  Так, как нам нужно.
[30:59.840 --> 31:02.840]  И надо ещё проверить, что первые и последние вершины,
[31:02.840 --> 31:04.840]  они не насыщены прочитанием.
[31:07.840 --> 31:09.840]  Почему первые и последние
[31:12.840 --> 31:14.840]  не насыщены?
[31:18.840 --> 31:20.840]  Ну, давайте
[31:20.840 --> 31:22.840]  схематически нарешим, вот это наш путь.
[31:22.840 --> 31:25.840]  Если бы эта вершина была насыщена прочитанием M,
[31:25.840 --> 31:26.840]  что это значит?
[31:26.840 --> 31:29.840]  Значит, что из неё торчит какое-то ребро M.
[31:29.840 --> 31:33.840]  Но, извините, значит мы знаем, что вот это было甚麼 ребро из M штрих.
[31:33.840 --> 31:35.840]  Это ребро из M.
[31:35.840 --> 31:38.840]  Значит, тогда в частности это ребр О должно было быть войти в H,
[31:39.840 --> 31:41.840]  потому что это ребро точно не лежит в M штрих,
[31:41.840 --> 31:43.840]  потому что иначе M штрих было бы не по прочитаниям,
[31:44.840 --> 31:47.840]  поэтому это ребро, на самом деле, обязанно было бы лежать в H.
[31:47.840 --> 31:49.840]  Значит, тогда мы неправильно нашли компоненту связности.
[31:50.840 --> 31:53.840]  Ну, мы компоненту связностью нашли так, что большинских ребер
[31:53.840 --> 31:56.840]  quantity M interactiveamura
[31:56.840 --> 31:58.840]  так называют их coldன.
[31:58.840 --> 32:01.540]  никаких ребер инцидентных в какой-либо вершине отсюда
[32:01.540 --> 32:05.540]  нету. А если есть какое-то такое ребро, значит, соответственно,
[32:05.540 --> 32:09.900]  есть ребро, которое инцидентно относится к вершине. Поэтому
[32:09.900 --> 32:14.100]  таких ребер быть не может, значит, первые и последние
[32:14.100 --> 32:28.380]  вершины не насыщены в m. Если насыщены, то в h не учли
[32:28.380 --> 32:34.120]  в какой-то ребро. Ну, то есть, как бы мы там неправильно
[32:34.120 --> 32:37.680]  построили h, это противоречит тому, что мы делали до этого
[32:37.680 --> 32:48.560]  момента. Так, вопросы? Ну, значит, мы все доказали.
[32:48.560 --> 32:52.080]  Мы доказали, что если у нас исходно было m, относительно
[32:52.080 --> 32:54.200]  которого нету увеличивших путей, то он обязательно
[32:54.200 --> 32:57.080]  максимально, потому что если было побольше, то мы
[32:57.100 --> 33:02.740]  бы нашли увеличивший путь. Отлично. И теперь с использованием
[33:02.740 --> 33:09.220]  этого, этой теоремы мы можем написать основную идею алгоритма,
[33:09.220 --> 33:12.580]  как мы будем искать максимальное прочитание в графе. Значит,
[33:12.580 --> 33:18.620]  алгоритм такой. Изначально говорим, что m – это пустое
[33:18.620 --> 33:22.140]  множество. А дальше, пока относительно m есть увеличивший
[33:22.280 --> 33:29.280]  путь, находим его и выполняем чередование. Пока в g есть
[33:29.280 --> 33:40.280]  увеличивший путь относительно m, мы выполняем чередование
[33:40.280 --> 33:57.220]  вдоль этого пути. И в момент, когда мы не сможем больше
[33:57.220 --> 33:59.820]  найти увеличивший путь, значит, мы нашли максимальное
[33:59.820 --> 34:19.520]  прочитание, что и требовалось. Так, ну теперь как это алгоритм
[34:19.520 --> 34:34.620]  реализовать? Значит, конкретная реализация – это алгоритм
[34:34.620 --> 34:41.700]  куна. Давайте считать, что у меня теперь g двудольный.
[34:41.700 --> 34:47.660]  То есть, на самом деле, до этого момента рассуждения
[34:47.660 --> 34:50.600]  они были применены к любому графу, мы нигде двудольность
[34:50.600 --> 34:53.560]  не пользовались. А теперь будем ее активно пользоваться.
[34:53.560 --> 34:57.480]  Значит, смотрите, я буду считать, что у меня вот такой
[34:57.480 --> 35:02.640]  какой-то граф, левая доля, правая доля. Значит, дальше
[35:02.640 --> 35:06.840]  для удобства я нумерую все вершинки левой доли независимо
[35:06.840 --> 35:09.640]  номерами 0, 1 и так далее, и справа у меня будет номера
[35:09.640 --> 35:11.480]  0, 1 и так далее. То есть, вот здесь скажем, будут номера
[35:11.480 --> 35:20.900]  от 0 до n-1, а здесь 0 до k-1. И дальше я заведу как обычно
[35:20.900 --> 35:26.740]  вектор-векторов. Для каждой вершины левой доли храню
[35:26.740 --> 35:28.740]  список вершин из правой доли, с кем она соединена.
[35:28.740 --> 35:38.920]  То есть, я по сути буду по графу только слева направо
[35:38.920 --> 35:41.880]  ходить, поэтому мне нужны только для каждой вершины
[35:41.880 --> 35:44.920]  левой доли список вершин из соседей справа, а в обратную
[35:44.920 --> 35:47.360]  сторону не нужно. Значит, g только для вершины левой
[35:47.360 --> 35:52.440]  доли определено. Ну, дальше вспомогательный массив
[35:52.440 --> 36:08.000]  меток у меня будет used размера n. И вектор еще match, я его
[36:08.000 --> 36:14.100]  назову размера k. Ну, used понятно, мы будем делать что-то
[36:14.100 --> 36:17.480]  наподобие DFS, потому что понятно, что нам надо искать
[36:17.480 --> 36:20.080]  пути, это мы будем делать чем-то наподобие DFS. Нам
[36:20.080 --> 36:23.840]  нужны какие-то пометки для вершин. А match – это для
[36:23.840 --> 36:26.440]  каждой вершины правой доли мы будем сохранять, с кем
[36:26.440 --> 36:29.720]  она в данный момент в просчитании находится. То есть, для каждой
[36:29.720 --> 36:32.920]  вершины правой доли мы запоминаем либо номер вершины
[36:32.920 --> 36:35.360]  слева, с кем она сейчас находится в просчитании, с кем она
[36:35.360 --> 36:38.760]  соединяя ребром в просчитании, либо минус один, если она
[36:38.760 --> 36:43.960]  ни с кем не соединяя. Я тут еще раз подаду указ, означает,
[36:43.960 --> 36:47.560]  что это определено для правой доли, и мы храним, собственно,
[36:47.560 --> 36:49.960]  с кем она в просчитании, с кем она match-ится. Либо
[36:49.960 --> 36:52.400]  с вершинкой левой доли, либо с минус 1, если она ни
[36:52.400 --> 36:58.360]  с кем не соединяя. Окей, тогда вот такая процедурка
[36:58.360 --> 37:02.840]  у нас будет первая. Процедура поиска увеличивающего пути
[37:02.840 --> 37:08.080]  и augment, от слова увеличение, расширение. Процедура
[37:08.080 --> 37:12.120]  такая, принимается на вершину и пытается найти увеличивающий
[37:12.120 --> 37:21.200]  путь, который бы начался в вершинке В. Давайте мы
[37:21.200 --> 37:26.920]  скажем, что юст у меня true для тех вершинок, для которых
[37:26.920 --> 37:29.840]  я уже пытался это сделать, и у меня не получилось,
[37:29.840 --> 37:35.560]  поэтому надо не пытаться заново. Если юст от В, тогда
[37:35.560 --> 37:41.080]  return false. Что если я уже из этой вершинки пытался
[37:41.080 --> 37:42.800]  и пытаюсь еще раз, то у меня ничего не получится.
[37:42.800 --> 37:53.800]  Иначе мы помечаем ее использованной. Юст от В равно true. А дальше
[37:53.800 --> 37:59.440]  следующее. Мы проходимся по всем ее соседям, которые
[37:59.440 --> 38:03.640]  напоминают, лежат в правой доле нашего графа. По всем
[38:03.640 --> 38:06.400]  вершинам смежным В, которые лежат в правой доле, мы
[38:06.400 --> 38:10.960]  сделаем следующее. Смотрите, здесь следующая идея. Вот
[38:10.960 --> 38:14.440]  у меня есть В слева, и есть какая-то true, с ней соединена
[38:14.440 --> 38:18.920]  ребром справа. Значит, тогда, если match от true это минус
[38:18.920 --> 38:22.320]  и единица, то есть по сути, Т не насыщенна по рассчитаниям.
[38:22.320 --> 38:26.000]  Если она ни с кем в паре не стоит, тогда мы по сути
[38:26.000 --> 38:29.240]  уже нашли увеличивающий путь. То есть, как будет
[38:29.240 --> 38:34.000]  работать Augment? Он будет ходить по графу. Так мне не хватает.
[38:34.000 --> 38:35.680]  Сейчас давайте я восстановлю какой-нибудь увеличивающий
[38:35.680 --> 38:40.960]  путь. Значит, он выглядит вот так всегда. Вот, как
[38:40.960 --> 38:45.040]  будет работать Augment? Он встал сюда, попытался пойти сюда-сюда-сюда-сюда-сюда,
[38:45.040 --> 38:48.040]  и вот в момент, когда он может закончиться в ненасыщенной
[38:48.040 --> 38:51.360]  вершинке, он говорит, ага, я нашел, я закончил увеличивающий
[38:51.360 --> 38:54.880]  путь вот этим ребром. Поэтому мы сразу говорим, что мы
[38:54.920 --> 38:58.280]  закончили поиск увеличивающих пути, мы его нашли, соответственно,
[38:58.280 --> 39:00.720]  надо будет вернуть true. Но еще при этом мы можем сразу
[39:00.720 --> 39:03.640]  положить, что match от этой вершинки последней равно
[39:03.640 --> 39:05.720]  вот этому V, потому что я все равно потом выполняю
[39:05.720 --> 39:08.560]  чередование и, соответственно, могу сразу сказать, что
[39:08.560 --> 39:11.880]  это ребро лежит в парсочи. То есть, в случае, когда
[39:11.880 --> 39:17.640]  match от true это минус и единичка, я напишу, что match от true это
[39:17.640 --> 39:24.520]  V и return true. То есть, я закончил поиск увеличивающих
[39:24.520 --> 39:27.720]  пути, он удался, и при этом я сразу выполняю чередование.
[39:27.720 --> 39:30.520]  То есть, augment, он не только разрешает true или false, нашел
[39:30.520 --> 39:33.120]  или не нашел увеличивший путь, но еще и выполняет
[39:33.120 --> 39:36.320]  чередование вдоль этого пути, если нашел. Соответственно,
[39:36.320 --> 39:38.000]  вот на последнем шаге мне нужно будет просто это
[39:38.000 --> 39:43.440]  ребро назначить в парсочи. Но есть еще второй случай,
[39:43.440 --> 39:46.720]  когда true была необязательно не посещенной, то есть,
[39:46.720 --> 39:48.520]  она, возможно, с кем-то была в паре, вот, например,
[39:48.520 --> 39:51.920]  как здесь. Мы начали отсюда, перешли вершину, которая
[39:52.320 --> 39:55.680]  в паре стоит, то есть, она насыщена. Тогда мне нужно
[39:55.680 --> 39:59.160]  просто запустить augment вот отсюда, если он успешен,
[39:59.160 --> 40:01.720]  то есть, я, по сути, прохожусь по этому ребру, запускаю
[40:01.720 --> 40:06.520]  augment отсюда, и если он успешен, значит, я смог найти увеличивший
[40:06.520 --> 40:10.520]  путь. То есть, тогда здесь будет такой код, что если
[40:10.520 --> 40:18.920]  match от true равно минус 1. Так, давайте все-таки на
[40:18.920 --> 40:22.120]  другую доску перейду, мне тут не поместится.
[40:48.920 --> 40:58.320]  Если эта вершина не насыщена или насыщена, но я могу
[40:58.320 --> 41:02.320]  augment от ее, как бы, смежной вершинки от нее запуститься,
[41:02.320 --> 41:05.360]  и он будет успешен, то есть, вот этот augment вернет true,
[41:05.360 --> 41:09.200]  тогда нужно сделать вот это преобразование. Match
[41:09.200 --> 41:21.200]  от true равно v, и return true. Ну а в конце, если у меня
[41:21.200 --> 41:23.200]  ничего не получилось, то нужно сделать return false.
[41:23.200 --> 41:38.200]  Итак, давайте еще раз пройдемся, что мы здесь делаем. Augment
[41:38.200 --> 41:41.440]  для вершины левой доли. Пытается как бы найти продолжение
[41:41.440 --> 41:44.200]  увеличившего пути, которое бы начиналось в, и соответственно
[41:44.200 --> 41:48.200]  вот так вот ходило слева направо справа налево,
[41:48.200 --> 41:51.200]  вот так чередуясь по ребрам из порсочи и не из порсочи,
[41:51.200 --> 41:53.360]  и которое бы заканчивалось в вершине не насыщенной
[41:53.360 --> 41:58.200]  вот здесь справа. Итак, есть два случая. Либо мы сразу
[41:58.200 --> 42:02.700]  из вершинки v видим ее соседа справа, вершинку true, которая
[42:02.700 --> 42:06.200]  не насыщена по рассчитаниям. Это случай вот этот последний,
[42:06.200 --> 42:09.200]  когда вот здесь v, а здесь true. Тогда все очень просто.
[42:09.200 --> 42:12.200]  Значит, раз мы до v дошли, то мы как-то вот так шли
[42:12.200 --> 42:15.200]  чередуясь, и теперь можем закончить этот путь переходом
[42:15.200 --> 42:18.200]  в не насыщенную вершинку true. Тогда мы это просто делаем.
[42:18.200 --> 42:22.200]  Заодно выполняем чередование, и вот это ребро добавляем
[42:22.200 --> 42:26.200]  в порсочистание, и возвращаем true. То есть что мы сделали,
[42:26.200 --> 42:29.200]  собственно, это, ну, нашли увеличивший путь. И дальше,
[42:29.200 --> 42:31.200]  когда у меня рекурсия эта раскроется, соответственно,
[42:31.200 --> 42:34.200]  я выполнил вот это чередование и вернул true.
[42:34.200 --> 42:37.200]  Для этой вершинки, когда я запустился рекурсивно,
[42:37.200 --> 42:41.200]  пройдя вот такой пудленый 2 от v, у меня вершинка v
[42:41.200 --> 42:44.200]  вернет true, augment от v вернет true. Значит, я сделаю
[42:44.200 --> 42:46.200]  чередование еще от этой вершинки, у меня будет вот
[42:46.200 --> 42:48.200]  это ребро добавлено в порсочи, а это, соответственно,
[42:48.200 --> 42:52.200]  удалено. То же самое для этого. Я запустился из этой
[42:52.200 --> 42:55.200]  вершинки, ну, то есть когда был здесь, запустился отсюда,
[42:55.200 --> 42:58.200]  тогда я выполняю опять чередование для этой вершины,
[42:58.200 --> 43:01.200]  и вот это ребро добавляю, а это удаляется из порсочи.
[43:01.200 --> 43:03.200]  То есть тем самым при разворачивании курс у меня как раз
[43:03.200 --> 43:05.200]  все чередование произойдет.
[43:06.200 --> 43:09.200]  Вот, значит, это первый случай, когда из v есть просто ребро
[43:09.200 --> 43:13.200]  вненасущенную true. Ну, а если по-другому, да, если match
[43:13.200 --> 43:16.200]  at 2 не минус 1, она с кем-то соединена, то я могу просто
[43:16.200 --> 43:18.200]  рекурсивно запустить с аугументом вот этого самого
[43:18.200 --> 43:21.200]  конца, то есть вот скажем здесь v, здесь true, тогда вот
[43:21.200 --> 43:22.200]  это вот match at 2.
[43:24.200 --> 43:27.200]  Тогда вот это match at 2. Я отсюда запускаюсь рекурсивно.
[43:27.200 --> 43:30.200]  Если я смог рекурсивно найти продолжение, увеличивший
[43:30.200 --> 43:33.200]  пути, вот какое-то такое, то я соответственно говорю,
[43:33.200 --> 43:36.200]  что окей, я нашел весь увеличивший путь, выполняю
[43:36.200 --> 43:38.200]  чередование вот этой участки, что это ребро переключаю
[43:38.200 --> 43:40.200]  сюда, ну и вывышаю true.
[43:42.200 --> 43:44.200]  Вот, если же я ничего такого не нашел, то есть после вот
[43:44.200 --> 43:47.200]  этого цикла по 2 я должен вернуть false как знак того,
[43:47.200 --> 43:49.200]  что я не смог найти такой путь.
[43:53.200 --> 43:54.200]  Так, вопросы?
[44:00.200 --> 44:10.200]  Ладно, значит вот такая процедура, которая пытается
[44:10.200 --> 44:12.200]  найти увеличивший путь из вершинки.
[44:12.200 --> 44:17.200]  Дальше в мейне, ну или там собственно, там короче,
[44:17.200 --> 44:19.200]  как это запускать?
[44:19.200 --> 44:26.200]  Во-первых, мы делаем used assign n false.
[44:27.200 --> 44:37.200]  Во-вторых, мы делаем match assign k-1.
[44:37.200 --> 44:40.200]  Для каждой вершины правой доли она изначально ни
[44:40.200 --> 44:42.200]  с кем не соединена.
[44:42.200 --> 44:46.200]  Ну и наконец, в-третьих, мы проходим по всем вершинам
[44:46.200 --> 44:58.200]  левой доли, по всем вершинам левой доли и пытаемся запустить
[44:58.200 --> 45:00.200]  augment.
[45:00.200 --> 45:05.200]  И если он успешен, если augment от v успешен, то есть мы
[45:05.200 --> 45:08.200]  попытались найти увеличивший путь и нашли и сделали
[45:08.200 --> 45:13.200]  чередование, то давайте сбросим меточки used.
[45:13.200 --> 45:16.200]  Used assign опять n false.
[45:23.200 --> 45:25.200]  Все, весь код на доске.
[45:29.200 --> 45:31.200]  Значит, как это работает?
[45:31.200 --> 45:35.200]  Ну смотрите, у нас вот есть изначально наш граф, изначально
[45:35.200 --> 45:38.200]  нет никакого прощания, прощание пустое, и все вершины
[45:38.200 --> 45:42.200]  левой доли у меня отмечены unused, неиспользованные.
[45:42.200 --> 45:45.200]  Теперь я иду по вершинкам v слева направо, в смысле в порядке
[45:45.200 --> 45:48.200]  возрастания номеров в левой доле, и пытаюсь сделать
[45:48.200 --> 45:50.200]  augment.
[45:50.200 --> 45:53.200]  Значит, вот пусть какой-то augment завершился неуспешно,
[45:53.200 --> 45:56.200]  то есть я попытался запустить augment, но он равен false, и
[45:56.200 --> 45:58.200]  тогда, соответственно, условия не срабатывают.
[45:58.200 --> 46:00.200]  Вот пусть augment равен false.
[46:00.200 --> 46:03.200]  Значит, я в текущем графе попробовал найти увеличивший
[46:03.200 --> 46:05.200]  путь, но не смог.
[46:05.200 --> 46:07.200]  При этом, понятно, делал какие-то вершинки, там я
[46:07.200 --> 46:08.200]  отметил used.
[46:08.200 --> 46:11.200]  Везде, где я побывал, они все отмечены used.
[46:11.200 --> 46:14.200]  Это значит, что я попытался из них найти, но не смог.
[46:14.200 --> 46:17.200]  Поэтому, понятное дело, что до тех пор, пока парасочетание
[46:17.200 --> 46:21.200]  не перестроится, нет смысла эти пометки сбрасывать,
[46:21.200 --> 46:24.200]  нет смысла опять пытаться запускать augment из них,
[46:24.200 --> 46:27.200]  потому что я уже когда-то запускал, граф до этого
[46:27.200 --> 46:30.200]  момента не перестроился, значит, эти метки, значит,
[46:30.200 --> 46:33.200]  что от них можно не запускаться заново.
[46:33.200 --> 46:37.200]  И только если какой-то там последующий augment вот отсюда
[46:37.200 --> 46:40.200]  завершился успешно и перестроил парасочетание, то есть
[46:40.200 --> 46:45.200]  у меня, ну, по сути, изменились мэтчи в том вот алгоритме,
[46:45.200 --> 46:46.200]  в том augmentе.
[46:46.200 --> 46:49.200]  Только в этом случае есть смысл все пометки сбросить.
[46:49.200 --> 46:52.200]  Граф перестроился, мэтчи изменились, значит, у меня
[46:52.200 --> 46:55.200]  возможно появились какие-то новые увеличившие пути,
[46:55.200 --> 46:58.200]  использующие какие-то из этих предыдущих фишин, которые
[46:58.200 --> 47:00.200]  раньше были помещены плохими.
[47:00.200 --> 47:04.200]  Только в этом случае есть смысл сбросить все эти метки.
[47:04.200 --> 47:07.200]  Иначе, повторюсь, граф не менялся, мы когда-то не смогли,
[47:07.200 --> 47:09.200]  значит, мы никогда не сможем, пока граф не изменится,
[47:09.200 --> 47:11.200]  пока, собственно, парасоч не изменится.
[47:13.200 --> 47:14.200]  Так, вот.
[47:14.200 --> 47:17.200]  Получается симптотика такая,
[47:17.200 --> 47:20.200]  симптотика такая,
[47:20.200 --> 47:24.200]  величина ответа на n плюс m.
[47:24.200 --> 47:27.200]  Значит, величина ответа это, собственно, размер парасоча,
[47:27.200 --> 47:30.200]  который мы ищем, размер максимального парасчитания,
[47:30.200 --> 47:31.200]  число ребер в нем.
[47:31.200 --> 47:34.200]  Ну, а n плюс m — это время работы ДФСа,
[47:34.200 --> 47:37.200]  потому что, собственно, между двумя
[47:37.200 --> 47:40.200]  соседними успешными агументами
[47:40.200 --> 47:43.200]  от каждой вершины я, по сути, запущусь максимум один раз.
[47:43.200 --> 47:46.200]  Ну, точнее, каждый ребро просмотрится максимум один раз
[47:46.200 --> 47:49.200]  из-за как раз этих меточек, которые я не снимаю.
[47:49.200 --> 47:51.200]  То есть, соответственно, суммарно вот столько раз
[47:51.200 --> 47:53.200]  рассмотреться за каждой вершиной и каждое ребро.
[47:53.200 --> 47:55.200]  Поэтому симптотика такая.
[47:55.200 --> 48:00.200]  Да.
[48:00.200 --> 48:06.200]  Да, это хороший вопрос, мы сейчас его докажем.
[48:06.200 --> 48:11.200]  Если кинчу вопросы.
[48:19.200 --> 48:20.200]  Хорошо.
[48:20.200 --> 48:24.200]  Значит, да, действительно, здесь есть одна небольшая тонкость.
[48:24.200 --> 48:27.200]  Потому что вспомним, как работал наш алгоритм,
[48:27.200 --> 48:29.200]  здесь на псевдокоде написанный.
[48:29.200 --> 48:32.200]  Пока есть увеличущий путь найти и сделать чередование.
[48:32.200 --> 48:33.200]  Вот вопрос.
[48:33.200 --> 48:36.200]  Почему, когда мы один раз всего лишь проходим по всем вершинам
[48:36.200 --> 48:38.200]  в порядке разрастания номеров,
[48:38.200 --> 48:41.200]  почему все увеличущие пути мы найдем?
[48:41.200 --> 48:44.200]  То есть нет смысла несколько раз в этот цикл, грубо говоря, запустить.
[48:44.200 --> 48:48.200]  Или, например, если мы нашли augment.v,
[48:48.200 --> 48:51.200]  то почему мы не сбрасываем v опять до нуля?
[48:51.200 --> 48:52.200]  То есть мы нашли какой-то путь.
[48:52.200 --> 48:54.200]  Давайте опять его с нуля попытаемся найти.
[48:54.200 --> 48:56.200]  То есть почему вот здесь мы там не пишем, скажем,
[48:56.200 --> 49:00.200]  v равно минус 1, чтобы вот отсюда оно было опять нулю равно.
[49:00.200 --> 49:02.200]  Вот почему.
[49:06.200 --> 49:08.200]  Так, пусть
[49:18.200 --> 49:20.200]  не существует
[49:23.200 --> 49:25.200]  увеличивающего пути
[49:27.200 --> 49:29.200]  начинающегося
[49:32.200 --> 49:34.200]  в некой поверхности x
[49:36.200 --> 49:39.200]  относительно некоторого прочитания m.
[49:41.200 --> 49:43.200]  Пусть m'
[49:45.200 --> 49:47.200]  получено из m
[49:48.200 --> 49:50.200]  чередование
[49:52.200 --> 49:54.200]  вдоль какого-то увеличившего пути.
[50:02.200 --> 50:04.200]  Так вот, тогда
[50:04.200 --> 50:07.200]  не существует увеличивающего пути начинающегося в x
[50:07.200 --> 50:09.200]  относительно m'.
[50:09.200 --> 50:11.200]  То есть это как раз ответ на тот самый вопрос,
[50:11.200 --> 50:14.200]  что если мы когда-то попытались из x найти путь
[50:14.200 --> 50:17.200]  относительно m, а потом m перестроили,
[50:17.200 --> 50:20.200]  то заново из x нет смысла искать этот самый увеличивающий путь.
[50:20.200 --> 50:22.200]  Только из других вышинок.
[50:24.200 --> 50:26.200]  Тогда не существует
[50:30.200 --> 50:32.200]  увеличивающего пути
[50:34.200 --> 50:36.200]  начинающегося в x
[50:36.200 --> 50:38.200]  относительно m'.
[50:40.200 --> 50:42.200]  И если мы это докажем,
[50:42.200 --> 50:44.200]  то мы целиком докажем корректность нашего алгоритма.
[50:44.200 --> 50:47.200]  Потому что вот там, да, если у меня, скажем, какой-то,
[50:47.200 --> 50:49.200]  то есть если вот было v
[50:49.200 --> 50:51.200]  и у меня augment от v провалился,
[50:51.200 --> 50:53.200]  то есть равен false,
[50:53.200 --> 50:56.200]  тогда это значит, что мы попытались из v найти
[50:56.200 --> 50:58.200]  увеличивающий путь, но не смогли.
[50:58.200 --> 51:00.200]  Но тогда в дальнейшем нет смысла опять вызывать
[51:00.200 --> 51:02.200]  augment от этой самой вершинки v,
[51:02.200 --> 51:04.200]  а как раз вот там v равно x.
[51:04.200 --> 51:06.200]  Вот, значит, просто достаточно один раз прочесть по всем вершинкам,
[51:06.200 --> 51:08.200]  то запускать augmente,
[51:08.200 --> 51:10.200]  и, собственно, это будет, да,
[51:10.200 --> 51:12.200]  мы все увеличивающие пути найдем, все какие могли быть.
[51:14.200 --> 51:16.200]  Так, ну доказательства тут следующие.
[51:17.200 --> 51:19.200]  Пусть m' получается из m,
[51:19.200 --> 51:21.200]  чередование вдоль какого-то конкретного пути.
[51:21.200 --> 51:23.200]  Но давайте я его нарисую.
[51:31.200 --> 51:33.200]  Пусть это будет вершинки a и b.
[51:35.200 --> 51:37.200]  m' получается из m,
[51:37.200 --> 51:39.200]  чередование вдоль вот этого пути.
[51:41.200 --> 51:43.200]  Тогда, значит, как выглядит x?
[51:43.200 --> 51:45.200]  Вспоминаем, что из x-а нет
[51:45.200 --> 51:47.200]  увеличивших путей, которые бы...
[51:47.200 --> 51:49.200]  ну, увеличивших путей относительно m,
[51:49.200 --> 51:51.200]  но давайте от противного, да,
[51:51.200 --> 51:53.200]  доказательства от противного,
[51:53.200 --> 51:55.200]  пусть из x-а нет
[51:55.200 --> 51:57.200]  увеличивших путей относительно m,
[51:57.200 --> 51:59.200]  но появились относительно m-şтрих,
[51:59.200 --> 52:01.200]  то есть раньше не было, теперь есть.
[52:01.200 --> 52:03.200]  Так вот как они могут выглядеть?
[52:03.200 --> 52:05.200]  Как может выглядеть увеличивающий путь из x-а
[52:05.200 --> 52:07.200]  относительно m-штрих?
[52:07.200 --> 52:09.200]  Ну, понятно, что он должен как-то этот путь
[52:09.200 --> 52:11.200]  пересекать, потому что я этот путь
[52:11.200 --> 52:26.200]  никак не взаимодействуют с путем из А в Б, то, ну, собственно, все остальные ребра, как бы, типы ребра не поменялись, те, которые были в М, они остались в М штрих, и наоборот, то есть если бы этот путь был хоть такой, то, собственно, он был бы путем относительно М, потому что на эти ребра никак этот путь не влияет.
[52:27.200 --> 52:31.200]  Значит, обязательно вот этот путь относительно М штрих, он как-то пересекается с путем А в Б.
[52:32.200 --> 52:35.200]  Ну, как-то пересекается. Давайте рассмотрим первую вершинку пересечения.
[52:37.200 --> 52:39.200]  Вот как-то он так идет, например.
[52:40.200 --> 52:42.200]  Ну, вот я что-нибудь такое нарисую.
[52:43.200 --> 52:50.200]  Вот пусть П это первая вершина на том самом увеличивающем пути относительно М штрих, которая лежит на пути А в Б.
[52:56.200 --> 52:59.200]  Первая вершина увеличивающей пути.
[53:01.200 --> 53:06.200]  Ну, тогда отсюда можно построить на самом деле увеличивающий путь относительно сталого пересечения М.
[53:06.200 --> 53:11.200]  Потому что, смотрите, в такой картинке я могу рассмотреть путь из Х в А вот такой.
[53:14.200 --> 53:16.200]  Значит, почему он будет хороший?
[53:17.200 --> 53:19.200]  Я утверждаю, что это тогда будет увеличивающий путь относительно М.
[53:20.200 --> 53:24.200]  Тогда мы, собственно, придем к противоречию, потому что мы предположили, что относительно М нет таких путей.
[53:25.200 --> 53:27.200]  Значит, почему это увеличивающий путь относительно М?
[53:28.200 --> 53:32.200]  Надо доказать, что эти вершинки ненасыщены относительно М, и что типы ребр чередуются.
[53:32.200 --> 53:33.200]  И что типы ребр чередуются.
[53:34.200 --> 53:40.200]  Но что типы ребр чередуются, это очевидно, потому что вот здесь вот на этом как бы префиксе пути, на начале пути,
[53:41.200 --> 53:46.200]  ребра, лежащие в М, это то же самое, что ребра, лежащие в М штрих, потому что вне пути А Б у меня ничего не поменялось.
[53:47.200 --> 53:50.200]  Это плохая, кстати, картинка, это не может лежать в М.
[53:51.200 --> 53:53.200]  Я перерисую, извините.
[53:57.200 --> 53:58.200]  Вот так.
[53:58.200 --> 53:58.700]  Пр ate тысяче штрихов.
[54:01.200 --> 54:06.200]  Раз это был увеличивающий путь относительно м штрих, то первое результат не лежало в м штрих, значит, не лежало в м.
[54:07.200 --> 54:10.200]  Следующее лежало в м штрих, то есть лежит в М, то опять лежит в М.
[54:11.200 --> 54:14.200]  А дальше, потому что вне пути А Б, у меня М равно м штрих.
[54:15.200 --> 54:21.200]  Изменения происходят только вдоль этого пути, значит, здесь происходит чередование.
[54:22.200 --> 54:26.200]  Я иду в ту сторону, так что бы здесь летать было, чтобы чередование было, потому что тут у меня типы ребра чередовались из m м штрих и из м м штрих и так далее.
[54:26.200 --> 54:31.000]  здесь происходит опять то самое чередование, что у нас, как раз, каждый второй ровень лежит в m.
[54:31.000 --> 54:36.400]  Так, ну и наконец, соответственно, первая и последняя вершины не насыщены прочитанием m,
[54:36.400 --> 54:42.480]  потому что a не насыщена, поскольку ab это увеличивающий путь относительно m, и x тоже не насыщена,
[54:42.480 --> 54:50.960]  потому что она вообще не насыщена относительно m', то есть даже большего прочитания мы не
[54:50.960 --> 54:56.600]  насыщены, значит, тем более мы не насыщены относительно меньшего прочитания m. Значит,
[54:56.600 --> 55:02.280]  все выполняется, мы нашли увеличивающий путь относительно m противоречия. Вот второй случай,
[55:02.280 --> 55:11.560]  когда вот это вот последнее ребро, ну тут нужна вторая картинка, два ребра из m в p ведут.
[55:11.560 --> 55:27.600]  Good question, сейчас, момент. Невозможно, да. Да, хорошее замечание, действительно,
[55:27.600 --> 55:30.720]  то есть на самом деле такого быть не может, давайте перерисуем картинку правильно.
[55:30.720 --> 55:57.400]  Картинка тогда такая. Вот это вот будет p, а здесь вот тот самый путь ab. Да, действительно,
[55:57.400 --> 56:01.360]  то есть вот этого быть не может, потому что у меня бы тогда вершинка p сойдет над
[56:01.360 --> 56:06.160]  двум ребром по расчетанию m, что невозможно, поэтому обязательно картинка какая-то такая,
[56:06.160 --> 56:11.200]  что вот это последнее ребро не лежит в m. Ну значит, наоборот, мне нужно было бы идти,
[56:11.200 --> 56:17.760]  ну то есть здесь в зависимости от того, где у p лежит ребро справа или слева, то есть, возможно,
[56:17.760 --> 56:22.120]  мы там могли бы вот сюда идти, тогда нам нужно было бы идти в a. Если мы сюда, то нам нужно идти в b.
[56:22.120 --> 56:25.840]  В общем, в любом случае нам нужно идти в одну из двух сторон, чтобы получить чередующийся путь.
[56:25.840 --> 56:41.640]  Вот, значит, если из x есть увеличащий путь относительно m штрих, то соответственно мы
[56:41.640 --> 56:44.440]  построили увеличащий путь относительно m противоречия.
[56:55.840 --> 57:24.440]  Да, да. Ну давайте поразбираем, да. Значит, мог ли x прийти в a или в b? В принципе,
[57:24.440 --> 57:32.040]  мог, ничего бы не мешало. А почему? Ну вот смотрите, вот если у меня была такая картинка,
[57:32.040 --> 57:40.280]  что бы в этом плохого? Ну так нам не надо, мы просто до нее доходим и все. Ну то есть,
[57:40.280 --> 57:49.280]  как бы мы из b идем в b, пустой путь. Так, в случае, если x равно a или x равно b, быть не может,
[57:49.280 --> 57:53.960]  потому что а и b становятся насыщенными относительно прощания m штрих. Поэтому
[57:53.960 --> 58:00.600]  не может быть не из a, не из b опять увеличивающий путь относительно m штрих. Потому,
[58:00.600 --> 58:08.460]  что они уже насыщены относительно m штрих. Почему x не может лежать на пути? То же самое,
[58:08.460 --> 58:14.460]  потому что после чередования все вершины на этом пути становятся насыщенными относительно m
[58:14.460 --> 58:19.260]  штрих потому что ну то есть когда сделать чередование у меня будет вот
[58:19.260 --> 58:24.160]  такой вот m штрих то есть каждой вершины этого пути инцидентно ну ребру из m
[58:24.160 --> 58:27.160]  штрих поэтому не все насыщено
[58:33.160 --> 58:36.160]  еще раз
[58:45.160 --> 58:51.320]  смотрите здесь пунктирные и сплошные это все относительно м значит
[58:51.880 --> 58:58.380]  пунктирные не лежащие в М есть сплошные это лежащие в m, пунктирные не лежащие в m
[58:58.380 --> 59:03.080]  чем обличается m и m-штрих только тем что вот на этом пути меняются пунктирные
[59:03.080 --> 59:06.080]  и сплошные то есть вот эти вот становится в м штрихе
[59:06.080 --> 59:09.080]  это становится Не в м штрихе а в остальных местах то есть везде кроме
[59:09.080 --> 59:14.080]  этого пути у меня не меняются ну как бы сплошные и пунктирные относительно м
[59:14.080 --> 59:17.920]  мшрих то же самое поэтому если х лизжит вм persistentinteractive вне пути то
[59:17.920 --> 59:23.760]  не на пути АВ, значит М штрих и М это одно и то же вне этого пути.
[59:23.760 --> 59:26.760]  Ещё?
[59:47.920 --> 59:55.520]  Сейчас, ещё раз. Почему Х не может лежать на АВ?
[59:55.520 --> 01:00:03.360]  Почему Х не может лежать на АВ? Потому что в прочесании М штрих все вершины на
[01:00:03.360 --> 01:00:08.800]  этом пути насыщены. Вы про типа то, когда я следующие
[01:00:08.800 --> 01:00:13.840]  прочесания беру. Смотрите, этого не нужно. Мы доказали, что если Х один раз не
[01:00:13.840 --> 01:00:19.360]  лежит, то нет пути из Х относительно М, то на следующем шаге тоже не лежит.
[01:00:19.360 --> 01:00:23.300]  Значит, на следующем после следующего тоже не лежит. Если вместо М взять М
[01:00:23.300 --> 01:00:27.880]  штрих, вместо М штрих и М2 штриха, то получится то, что это все
[01:00:27.880 --> 01:00:32.400]  корректно. Мы доказали, что если на одном шаге мы запустили агмент от
[01:00:32.400 --> 01:00:37.400]  вершины, и он не успешен, то на следующем шаге его опять нет смысла запускать.
[01:00:37.400 --> 01:00:40.320]  То есть нет увеличения в пути относительно М штрих. Но тогда, если нет
[01:00:40.320 --> 01:00:45.000]  относительно пути относительно М штрих, то нету относительно М2 штриха.
[01:00:54.720 --> 01:01:00.880]  Нет, нет, нет, нет. Мы это не использовали. Мы предположили противное. То есть есть
[01:01:00.880 --> 01:01:06.280]  увеличивший путь. Значит, он обязательно сам по себе не использованный.
[01:01:07.200 --> 01:01:10.360]  Так, дальше идем.
[01:01:10.640 --> 01:01:17.080]  Вот, значит, повторюсь, такой, не знаю, ну с точки зрения контестов, вот эти
[01:01:17.080 --> 01:01:20.280]  доказательства, они по сути не очень полезны, потому что код укладывается, ну там
[01:01:20.280 --> 01:01:23.800]  не знаю, в 30 строчек. Его можно просто переписать и сдавать задачу. То есть вот
[01:01:23.800 --> 01:01:30.120]  это вот, это все, ну чтобы просто понять, почему это работает. Что в общем-то
[01:01:30.840 --> 01:01:34.400]  для решения задач не всегда нужно.
[01:01:35.400 --> 01:01:42.160]  Так, ну теперь последний фрагмент про вот максимально независимое и минимально
[01:01:42.160 --> 01:01:45.600]  покрывающее множество.
[01:01:46.200 --> 01:01:59.800]  Значит, определение пусть, у меня есть какой-то граф, тогда множество его вершин, ну
[01:01:59.800 --> 01:02:10.200]  какой-то поднос, что ве называется независимым, называется независимым, если
[01:02:10.200 --> 01:02:13.880]  никакие две вершины не соединены ребром.
[01:02:13.880 --> 01:02:29.960]  Никакие две вершины этого множества не соединили ребром. То есть у нас было
[01:02:29.960 --> 01:02:33.760]  похоже определение для клики, когда, наоборот, любые две вершины должны быть
[01:02:33.760 --> 01:02:37.120]  соединили ребром графа. Тут, наоборот, каждые два ребра не соединили ребром
[01:02:37.120 --> 01:02:43.440]  графа. Двоесть на определение,
[01:02:46.480 --> 01:02:56.960]  если сколько-то граф, тогда множество его вершин называется вершинным покрытием,
[01:02:57.320 --> 01:03:00.920]  называется вершинным покрытием.
[01:03:07.840 --> 01:03:14.880]  Если каждое ребро графа, то есть любое ребро, хотя бы одним своим концом лежит в
[01:03:14.880 --> 01:03:26.360]  с, если до любого ребра графа, либо у лежит в с, либо вы лежит в с, ну хотя бы одно из них.
[01:03:26.360 --> 01:03:36.560]  То есть это такое множество вершин, что каждое ребро хотя бы одним концом лежит в этом самом множестве с.
[01:03:44.880 --> 01:03:50.160]  Например, какой-нибудь нарисуем,
[01:03:50.160 --> 01:04:02.280]  ну, какой-нибудь такой граф. Какое тут можно выбрать независимое множество? Ну, например,
[01:04:02.280 --> 01:04:09.320]  вот эти три вершинки можно взять. Вот эти три вершины выделены образуют независимое множество,
[01:04:09.360 --> 01:04:14.000]  потому что между ними нет ребер, нет такого ребра, нет такого ребра, нет такого ребра.
[01:04:14.000 --> 01:04:22.140]  Можно взять вот эти две вершины множество, рассмотреть вот эти две вершины, тогда они
[01:04:22.140 --> 01:04:26.640]  образуют вершинное покрытие. Вот если я возьму эти две вершины, то действительно каждое ребро
[01:04:26.640 --> 01:04:32.560]  хотя бы одним из концов лежит в этом квадратике, либо тут, либо тут. Это ребро лежит здесь в квадратике,
[01:04:32.560 --> 01:04:35.520]  и это ребро здесь, это ребро вообще-то двумя концами
[01:04:35.520 --> 01:04:40.000]  покрыто, это здесь, это здесь, это тоже здесь, а вот вершинное
[01:04:40.000 --> 01:04:46.560]  покрытие у меня квадратики, кружочки, это независимое
[01:04:46.560 --> 01:04:53.800]  множество. Ну и отсюда видно, давайте оставим это в
[01:04:53.800 --> 01:04:57.720]  качестве упражнения, простое замечание, что вершинное
[01:04:57.720 --> 01:04:59.360]  покрытие и независимое множество всегда дополняют
[01:04:59.360 --> 01:05:01.800]  друг друга. То есть если у меня есть какое-то множество
[01:05:01.800 --> 01:05:12.000]  I, скажем независимое множество, то тогда его дополнение V-I
[01:05:12.000 --> 01:05:18.040]  это гарантированное вершинное покрытие. Ну и соответственно
[01:05:18.040 --> 01:05:19.920]  наоборот, если есть какое-то множество, являющее вершиной
[01:05:19.920 --> 01:05:22.760]  покрытием, то его дополнение это обязательно независимое
[01:05:22.760 --> 01:05:25.760]  множество. Значит доказывается очень просто, если есть
[01:05:25.760 --> 01:05:29.280]  какое-то независимое, значит внутри него нет ребер, то
[01:05:29.280 --> 01:05:31.480]  есть все ребра либо вне него, либо одним концом только
[01:05:31.480 --> 01:05:34.000]  в нём лежат. Значит как раз всё остальное это вершинное
[01:05:34.000 --> 01:05:46.120]  покрытие. Вот, значит вспомним, я когда-то говорил, что задача
[01:05:46.120 --> 01:05:50.120]  поиска клики максимальной в графе, она непрудная,
[01:05:50.120 --> 01:05:52.080]  и у нас там был алгоритм за что типа два в степени
[01:05:52.080 --> 01:05:56.080]  пополам, который по данному графу находил максимальную
[01:05:56.080 --> 01:06:00.000]  клику. Вот, и ну там сильно быстрее чем какая-то экспонента
[01:06:00.000 --> 01:06:03.200]  нельзя, то есть там можно бороться вот с этим показателем
[01:06:03.200 --> 01:06:06.080]  экспоненты, но всё равно это будет сверхполинальный
[01:06:06.080 --> 01:06:09.760]  время работы, больше чем там N в пятой, N в десятой.
[01:06:09.760 --> 01:06:13.440]  Значит, ну тоже самое понятное дело должно быть для независимого
[01:06:13.440 --> 01:06:15.920]  множества, потому что независимое множество от клики отличается
[01:06:15.920 --> 01:06:19.240]  только тем, что я ребра заменил на антирёбра, на несуществующие
[01:06:20.120 --> 01:06:22.520]  Поэтому понятное дело, что эта задача столь же сложная,
[01:06:22.520 --> 01:06:24.800]  задача поиска максимального независимого множества,
[01:06:24.800 --> 01:06:28.840]  столь же сложная, как задача поиска максимальной клики.
[01:06:28.840 --> 01:06:32.000]  Но оказывается, что в двудольных графах, если мы будем рассматривать
[01:06:32.000 --> 01:06:34.800]  непрозвольные, а только двудольные графы, эта задача
[01:06:34.800 --> 01:06:42.600]  становится сильно проще. Значит, найдём максимальное,
[01:06:42.760 --> 01:06:55.760]  по мощности, независимое множество, и минимальное,
[01:06:55.760 --> 01:07:02.480]  опять-таки, по мощности, вершинное покрытие в двудольном графе.
[01:07:02.480 --> 01:07:12.520]  Ну, вообще, часто такое бывает, что если в общем случае,
[01:07:12.520 --> 01:07:15.640]  если граф произвольный или какой-то объект произвольный,
[01:07:15.640 --> 01:07:18.760]  задача может быть трудной, не решаться за полином,
[01:07:18.760 --> 01:07:21.480]  по крайней мере, в текущем человеческом знании. Но
[01:07:21.480 --> 01:07:23.720]  вот если вы рассматриваете какие-то специфические
[01:07:23.720 --> 01:07:27.800]  графы, какие-то специфические объекты, то в них уже эта
[01:07:27.800 --> 01:07:31.840]  задача может как-то быстро решаться. Так вот, пусть
[01:07:31.840 --> 01:07:35.760]  есть у меня двудольный граф G, я хочу найти в нём максимальное,
[01:07:35.760 --> 01:07:38.120]  независимое множество и минимальное вершинное
[01:07:38.120 --> 01:07:43.760]  покрытие. Вот G граф, двудольный, давайте скажем, что в нём
[01:07:43.760 --> 01:07:51.160]  M это максимальное просчитание. Максимальное просчитание
[01:07:51.160 --> 01:08:07.840]  в G. Дальше мы построим ориентированный граф. Строим ориентированный
[01:08:07.840 --> 01:08:12.720]  граф D следующим образом. Начну множество вершин мы
[01:08:12.720 --> 01:08:16.920]  оставляем, только мы ориентируем все ребра исходного графа.
[01:08:16.920 --> 01:08:32.400]  Вот так. Рёбра из M ориентируем справа налево, ребра не
[01:08:33.400 --> 01:08:55.840]  направо. Тоже давайте какой-нибудь пример нарисую. То есть у меня
[01:08:55.840 --> 01:08:59.360]  есть такой граф, например, я могу взять вот такое просчитание,
[01:08:59.360 --> 01:09:02.560]  максимальное, тогда его ребра я ориентирую справа
[01:09:02.560 --> 01:09:05.720]  налево, подрисовываю стрелочки, а все остальные ориентирую
[01:09:05.720 --> 01:09:09.400]  слева направо. То есть всё, ребра просчитания справа
[01:09:09.400 --> 01:09:32.880]  налево, остальные слева направо. Далее запустим
[01:09:32.880 --> 01:09:51.720]  обход D из всех ненасыщенных вершин левой доли. То есть
[01:09:51.720 --> 01:09:55.440]  вот мы нашли максимальное просчитание, относительно
[01:09:55.440 --> 01:09:58.400]  него какие-то вершинки насыщенные, какие-то ненасыщенные,
[01:09:58.400 --> 01:10:01.200]  и вот мы запускаем обход только из ненасыщенных вершин
[01:10:01.200 --> 01:10:08.080]  левой доли. Тогда у меня будет картинка такая. Давайте
[01:10:08.080 --> 01:10:13.200]  я разобью множество вершин на четыре множества, обзову
[01:10:13.200 --> 01:10:20.720]  их L+, L-, R+, R-. Это те вершинки, которые я посетил в процессе
[01:10:20.720 --> 01:10:23.760]  обхода слева. Это те, которые я не посетил. Ну, плюсик
[01:10:23.760 --> 01:10:26.720]  посетил, минусик не посетил. Дальше, это те, которые
[01:10:26.720 --> 01:10:30.000]  я посетил в правой доле в процессе обхода, это те,
[01:10:30.080 --> 01:10:33.040]  которые я не посетил в процессе обхода. То есть еще
[01:10:33.040 --> 01:10:35.720]  от всех какой-то граф конкретный, вот я задаю его ориентацию
[01:10:35.720 --> 01:10:39.200]  всех ребер, есть граф. Дальше, я выбираю все ненасыщенные
[01:10:39.200 --> 01:10:42.040]  слева, запускаю обход. Ну, вот здесь вот это будет
[01:10:42.040 --> 01:10:43.920]  единственное ненасыщенное, я запускаю обход. Все,
[01:10:43.920 --> 01:10:47.240]  что из нее достижимо, там, вот какой-то такой путь,
[01:10:47.240 --> 01:10:50.760]  все, что из нее достижимо, я помечаю плюсиками. Достижимый.
[01:10:50.760 --> 01:10:54.160]  Соответственно, складываю в L+, R+, тех, которые я достиг.
[01:10:54.160 --> 01:10:57.680]  Все остальные лежат в L-, R+.
[01:10:57.680 --> 01:11:04.680]  Так и вот тогда, алгоритм такой, L+, в объединении с R-,
[01:11:04.680 --> 01:11:12.000]  это максимально независимое множество, а L- в объединении
[01:11:12.000 --> 01:11:19.160]  с R+, это минимальное вершинное покрытие, минимальное вершинное
[01:11:19.160 --> 01:11:20.160]  покрытие.
[01:11:20.160 --> 01:11:28.280]  Ну, и так, если это не доказывать, то алгоритм очень простой.
[01:11:28.280 --> 01:11:31.280]  Нашли максимальное просчитание, ориентировали ребра графа
[01:11:31.280 --> 01:11:33.840]  правильным образом, слева направо и справа налево,
[01:11:33.840 --> 01:11:36.960]  так как нужно. Затем запустили обход, ну, какой-нибудь там,
[01:11:36.960 --> 01:11:40.360]  DFS, BFS, что угодно, главное обойти все, что достижимо.
[01:11:40.360 --> 01:11:42.880]  Разбили все вершины на четыре группки и сказали, что
[01:11:42.880 --> 01:11:45.600]  вот такое объединение это независимое, а вот такое
[01:11:46.400 --> 01:11:51.400]  вершинное покрытие. Вот, осталось это доказать.
[01:11:51.400 --> 01:12:08.400]  И на этом, собственно, еще раз. Ну, мы же в нее встали,
[01:12:08.400 --> 01:12:11.400]  мы ее посетили, пометили посещенно, значит, L+, конечно.
[01:12:11.400 --> 01:12:13.680]  Ну, смотрите еще раз, стартование обязательно одна, их может
[01:12:13.680 --> 01:12:16.920]  быть несколько. От каждой непосещенной слева свой
[01:12:16.920 --> 01:12:19.920]  обход. И все, что я хотя бы от одной посетил, я помечаю
[01:12:19.920 --> 01:12:26.680]  плюсиками и кидаю либо в L+, либо в R+. Вот. Хорошо,
[01:12:26.680 --> 01:12:30.720]  давайте мы вот в этом графе точно отметим ребра, которые
[01:12:30.720 --> 01:12:34.480]  не могут быть в графе D. Ну, смотрите, понятно я, что
[01:12:34.480 --> 01:12:37.680]  вот таких вот ребер и вот таких вот ребер не бывает.
[01:12:37.680 --> 01:12:43.040]  То есть из L+, в R- и из R+, в L-, ребер точно быть не может.
[01:12:43.040 --> 01:12:50.920]  Почему? Ну, конечно, да, если это отмечено плюсиком,
[01:12:50.920 --> 01:12:53.880]  то, ну, поскольку мы запускаем обход типа DFS, мы должны были
[01:12:53.880 --> 01:12:56.040]  бы пройти по такому ребру и ее отметить плюсиком.
[01:12:56.040 --> 01:12:59.280]  Да, ну, вообще, не может быть ребра из посещенной в непосещенной.
[01:12:59.280 --> 01:13:03.680]  Дальше, чтобы, например, доказать, что вот это вот,
[01:13:03.680 --> 01:13:06.120]  это независимое множество, надо еще доказать нет обратных
[01:13:07.000 --> 01:13:22.120]  ребер. Почему нет таких ребер? Но давайте подумаем, вообще
[01:13:22.120 --> 01:13:25.320]  что значит, что ребро ведет справа налево? Это значит,
[01:13:25.320 --> 01:13:27.640]  что это ребро по рассочетанию. Да, вспоминаем, что слева
[01:13:27.640 --> 01:13:30.120]  направо у нас ребра не по рассочетанию, справа налево
[01:13:30.120 --> 01:13:33.400]  ребра по рассочетанию. Значит, если такое ребро и есть,
[01:13:33.400 --> 01:13:39.600]  это обязательно ребро просочетания, а вот это какое-то УВ и, соответственно, УВ это
[01:13:39.600 --> 01:13:54.160]  ребро просочетания. Значит, в частности, У насыщено. У насыщено нашим просчитанием М. Но тогда,
[01:13:54.160 --> 01:14:00.080]  извините, как мы могли попасть в У, если мы все обходы начинаем только из ненасыщенных? Вот
[01:14:00.080 --> 01:14:04.000]  представьте, что мы как-то до У дошли, а начинались мы только в каких-то ненасыщенных,
[01:14:04.000 --> 01:14:08.960]  то есть мы могли стартовать где-то здесь, как-то петляли по графу и дошли до У. Но понятно,
[01:14:08.960 --> 01:14:13.640]  что дойти до У мы могли только через В, потому что единственное ребро, входящее в У, это вот это
[01:14:13.640 --> 01:14:20.640]  самое ребро УВ. Никакое другое ребро в У не торчит, никакое другое ребро в У не смотрит.
[01:14:20.640 --> 01:14:27.320]  Значит, чтобы попасть из ненасыщенной в У, мне нужно было пройти через это ребро. Значит, В
[01:14:27.320 --> 01:14:43.480]  обязан должно было быть в Р+, на противоречие. Попасть в У из ненасыщенной можно только с помощью
[01:14:43.480 --> 01:15:00.360]  л2 в У. Ну все, значит, если это так, и мы попали сюда, значит, мы должны были попасть сюда,
[01:15:00.360 --> 01:15:06.760]  поэтому это должно быть в Р+. Хорошо, то есть мы как минимум уже доказали, что L+, в объединении с R-,
[01:15:06.760 --> 01:15:18.720]  это независимое множество. Давайте посмотрим сюда. Ясно дело, что внутри L+, ребер нету,
[01:15:18.720 --> 01:15:24.320]  потому что все вершины левой доли нет ребер внутри доли. Внутри R-, ребер тоже нету. И более того,
[01:15:24.320 --> 01:15:28.080]  нет ребер ни с левой направо, ни с правой налево между ними. Мы это только что доказали. Значит,
[01:15:28.160 --> 01:15:37.320]  независимое множество. И отсюда сразу следует, что дополнение к нашему множеству, то есть L- в объединении
[01:15:37.320 --> 01:15:46.240]  с R+, это наоборот вершинное покрытие. Потому что дополнение к независимому всегда покрытие.
[01:15:58.080 --> 01:16:11.440]  Значит, остается доказать, что это вот экстремальное множество, то есть то максимально независимое,
[01:16:11.440 --> 01:16:18.800]  а то минимальное вершинное покрытие. Мы докажем, что L- в объединении с R+, это минимальное вершинное
[01:16:18.800 --> 01:16:34.640]  покрытие. Значит, мы сделаем два этапа. Во-первых, мы докажем, что у нашего множества размер не
[01:16:34.640 --> 01:16:43.160]  больше, чем размер просчитания, а во-вторых, мы покажем, что в произвольном графе размер
[01:16:43.160 --> 01:16:51.240]  вершинного покрытия должен быть хотя бы размер максимального просчитания. Нет-нет,
[01:16:51.240 --> 01:16:55.360]  просто количество ребер. Вспоминаем, M- это множество ребер. Размер множества – это просто
[01:16:55.360 --> 01:17:06.200]  количество ребер в нем. В любом графе размер вершинного покрытия больше или
[01:17:06.200 --> 01:17:15.560]  меньше равен размер максимального просчитания. Ну, если мы это докажем, то есть, что мы вообще
[01:17:15.560 --> 01:17:19.960]  всегда покрыли должно быть хотя бы такой же мощности, как просчитания, как человечество в просчитании,
[01:17:19.960 --> 01:17:24.320]  и при этом мы нашли какое-то покрытие размером не больше, чем по рассчитания. Ну, значит,
[01:17:24.320 --> 01:17:27.760]  достигается равенство, и это, собственно, есть минимально возможное покрытие.
[01:17:36.200 --> 01:17:56.120]  Так, первое. Ну, здесь следующее работает. Значит, в L- есть только насыщенные вершины.
[01:17:56.120 --> 01:18:09.080]  В L- только насыщенные. Ну, понятно, потому что из ненасыщенных мы запускаем обход,
[01:18:09.080 --> 01:18:14.440]  значит, мы их посещаем в процессе нашего DFS, и поэтому они все лежат в L+. Все ненасыщенные
[01:18:14.440 --> 01:18:23.040]  здесь, значит, насыщенные могут быть только в L-. Во-вторых, в R+, тоже, только насыщенные.
[01:18:23.040 --> 01:18:37.560]  Почему в R+, только насыщенные могут быть? Если в R- есть какая-то ненасыщенная, то на самом деле
[01:18:37.560 --> 01:18:43.200]  у меня есть увеличивающий путь, потому что смотрите, что значит, что у меня какая-то в R+, есть
[01:18:43.200 --> 01:18:49.520]  ненасыщенные вершины, пусть она ненасыщенная. Тогда это значит, что я мог стартовать в какой-то
[01:18:49.520 --> 01:18:55.280]  ненасыщенной вершине левой доли, и в нашем графе D, как-то вот так вот ходя, закончиться могу
[01:18:55.280 --> 01:19:00.400]  в опять ненасыщенной вершине правой доли. То есть, по сути, я нашел увеличивающий путь,
[01:19:00.400 --> 01:19:05.360]  начинающийся и заканчивающийся в ненасыщенных вершинах. Ну, и поскольку я иду слева-направо,
[01:19:05.360 --> 01:19:09.320]  справа-налево, каждый раз меняясь, ребро не есть по расчитанию, ребро есть по расчитанию,
[01:19:09.320 --> 01:19:14.080]  чередуясь, то я, по сути, нахожу увеличивающий путь. А это противоречит тому, что наше исходное
[01:19:14.080 --> 01:19:25.840]  расчетание максимально. Иначе есть увеличивающий путь, да, но это противоречит тому, что исходное
[01:19:25.840 --> 01:19:34.840]  расчетание максимально, которое мы берем. Вот, ну, и наконец третье. Стоит заметить,
[01:19:34.840 --> 01:19:56.680]  что для любого ребра просочетания не больше одной вершины УВ. Ну, короче, не больше, чем одна из них
[01:19:56.680 --> 01:20:10.720]  лежит в этом самом L-минус в объединении с R+. Потому что если бы обе вершины какого-то
[01:20:10.720 --> 01:20:15.240]  ребра просочетания лежали бы в L-минус в R+, L-минус в объединении с R+, значит у меня есть
[01:20:15.240 --> 01:20:20.960]  какое-то такое ребро в графе, да, и в насыщенные вершины, в насыщенную, то есть оно справа-налево,
[01:20:20.960 --> 01:20:27.680]  и при этом идет из R+, в L-минус, а мы доказываем, что таких не бывает. Значит, давайте напишем,
[01:20:27.680 --> 01:20:40.360]  иначе было бы ребро R+, L-, а мы знаем, что из плюсиков в L-минус никогда ребро вести не может.
[01:20:40.360 --> 01:20:48.040]  Итого, смотрите, что мы доказали. Мы доказали, что вот это множество, вот в этом, есть только
[01:20:48.040 --> 01:20:52.880]  насыщенные вершины, но при этом каждое ребро просочетания привносит максимум одну вершину в
[01:20:52.880 --> 01:21:00.960]  этом множество. Значит, размер этого множества не больше, чем размер просочетания. То есть,
[01:21:00.960 --> 01:21:06.800]  каждое ребро отсюда, каждое ребро у V из просочетания M, привносит в моем множестве максимум одну
[01:21:06.800 --> 01:21:11.640]  вершину. Не может две привносить, потому что мы доказали, что не больше чем одна лежит в множестве.
[01:21:11.640 --> 01:21:15.880]  Значит, каждое ребро дает максимум сюда одну вершину, и при этом никаких других вершин тут нету,
[01:21:15.880 --> 01:21:20.680]  все насыщенные обязательно. Что здесь могли быть только те вершины, которые прошли по рассчитаниям.
[01:21:20.680 --> 01:21:34.360]  Значит, здесь вершины не больше, чем здесь ребер. Согласны? Так, ну первое доказали. Второе проще.
[01:21:46.680 --> 01:21:54.760]  Нужно доказать, что в его графе размер высшинного покрытия хотя бы размер максимального просчитания.
[01:21:54.760 --> 01:22:04.600]  Ну это просто, давайте рассмотрим произвольное максимальное просчитание. Мы знаем, что все эти
[01:22:04.600 --> 01:22:10.320]  ребра не имеют общих концов. Значит, я должен взять хотя бы одну вершину из этого ребра в покрытие.
[01:22:10.320 --> 01:22:14.680]  Чтобы покрыть ребро, мне нужно взять хотя бы один из концов по рассчитанию. Дальше, хотя бы одну из
[01:22:14.760 --> 01:22:18.940]  них взять из этих двух, хотя бы одну из этих двух взять, хотя бы одну из этих двух взять. При
[01:22:18.940 --> 01:22:22.680]  при этом все эти ребра не пересекаются, то есть я должен из каждого дву элемента взять хотя
[01:22:22.680 --> 01:22:30.240]  бы одну вершину, и все ни另 не пересекаются. Значит, из каждого ребра надо взять хотя бы одну вершину.
[01:22:34.120 --> 01:22:42.000]  Надо взять хотя бы одну вершину. Ну все, поэтому размер высшинного покрытия
[01:22:44.680 --> 01:22:47.660]  вынужден быть хотя бы размер максимального
[01:22:47.660 --> 01:22:48.660]  прочитания.
[01:22:48.660 --> 01:22:55.500]  А первое вместе со вторым означает, что мы нашли
[01:22:55.500 --> 01:22:58.440]  минимально возможное гипотетически душиное покрытие.
[01:22:58.440 --> 01:23:10.260]  Минимальное душиное покрытие, и более того, его мощность
[01:23:10.260 --> 01:23:13.900]  в точности равна мощности максимального прочитания.
[01:23:14.900 --> 01:23:15.900]  Мощности М.
[01:23:15.900 --> 01:23:18.900]  То есть, оно не больше и не меньше, мы доказали.
[01:23:18.900 --> 01:23:19.900]  Значит, срочность равно.
[01:23:19.900 --> 01:23:24.900]  Так, последнее, что скажу, это вот этот результат
[01:23:24.900 --> 01:23:25.900]  называется серия Макьонига.
[01:23:25.900 --> 01:23:31.580]  Мы ее доказали, и тем самым научились в вдвульном графе
[01:23:31.580 --> 01:23:34.300]  находить максимально независимое и минимально покрывающее
[01:23:34.300 --> 01:23:35.300]  множество.
[01:23:35.300 --> 01:23:35.940]  Все, спасибо.
