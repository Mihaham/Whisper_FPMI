[00:00.000 --> 00:05.000]  Ну, тогда еще раз всем добрый вечер.
[00:05.000 --> 00:10.000]  У нас сегодня по плану разговор о полноценном юзерспейсе,
[00:10.000 --> 00:14.000]  т.е. так как мы с вами уже победили полностью
[00:14.000 --> 00:19.000]  настройку виртуальной памяти в операционной системе,
[00:19.000 --> 00:27.000]  то наше ближайшее будущее лежит в организации способностей
[00:27.000 --> 00:34.000]  в организации способов обмена между пользовательским пространством
[00:34.000 --> 00:38.000]  и, соответственно, ядерным пространством.
[00:38.000 --> 00:44.000]  Поэтому сегодня мы поговорим, как вообще перейти
[00:44.000 --> 00:50.000]  на пользовательский уровень, соответственно, в юзерспейс на x86.
[00:50.000 --> 00:55.000]  Поговорим о том, как работают прерывания,
[00:55.000 --> 01:01.000]  как работают системные вызовы, т.е. один из механизмов обмена данными
[01:01.000 --> 01:04.000]  между пользователем и ядром.
[01:04.000 --> 01:09.000]  Поговорим о том, какие есть дополнительные механизмы,
[01:09.000 --> 01:17.000]  которые позволяют нам защитить ядро от пользовательского пространства.
[01:17.000 --> 01:25.000]  И также поговорим про то, какие методы динамического инструментирования
[01:25.000 --> 01:30.000]  существуют, которые также позволяют находить ошибки
[01:30.000 --> 01:37.000]  в коде операционной системы и используются в том числе
[01:37.000 --> 01:46.000]  для проверки на границах юзерспейса и кернелспейса,
[01:46.000 --> 01:50.000]  т.е. такие вещи, как фазинг системных вызовов.
[01:50.000 --> 01:53.000]  Об этом мы сегодня тоже поговорим.
[01:53.000 --> 01:58.000]  Итак, соответственно, юзерспейс.
[01:58.000 --> 02:06.000]  В x86 юзерспейс или пользовательский уровень привилегий,
[02:06.000 --> 02:11.000]  как мы уже знаем, определяется маршами битами сегментного регистра.
[02:11.000 --> 02:21.000]  В младших двух битах кодируется значение привилегий или CPL.
[02:21.000 --> 02:28.000]  Если там сохранено значение 3, то текущий уровень привилегий юзера.
[02:28.000 --> 02:32.000]  Если значение 0, то уровень привилегий керна.
[02:32.000 --> 02:38.000]  Стандартный механизм отображения пользовательской памяти
[02:38.000 --> 02:44.000]  заключается в том, что в таблице страниц,
[02:44.000 --> 02:49.000]  в те области памяти, которые видны пользователю,
[02:49.000 --> 02:52.000]  устанавливается bitU, он же user.
[02:52.000 --> 03:00.000]  И в этом случае при установке привилегий в режим user
[03:00.000 --> 03:03.000]  вы можете получить доступ к этой памяти.
[03:03.000 --> 03:09.000]  При этом все страницы ядра у вас также находятся в этой таблице страниц,
[03:09.000 --> 03:16.000]  но так как у них bitUser не установлен, то прав доступа вы к ним не имелите.
[03:16.000 --> 03:23.000]  Также из предыдущей лекции вы знаете, что существуют различные атаки
[03:23.000 --> 03:28.000]  микроархитектурного типа, например, такие как meltdown,
[03:28.000 --> 03:36.000]  по причине которых сейчас в современных операционных системах
[03:36.000 --> 03:43.000]  часто не отображают большую часть памяти ядра в таблице страниц
[03:43.000 --> 03:46.000]  потому что существуют некоторые механизмы,
[03:46.000 --> 03:51.000]  позволяющие прочитать вот эту память в обход
[03:51.000 --> 04:01.000]  этих установленных битов привилегий из-за ошибок в микроархитектуре процессора.
[04:01.000 --> 04:06.000]  Но мы все-таки с вами рассматриваем достаточно стандартную схему,
[04:06.000 --> 04:09.000]  где это условно не так.
[04:09.000 --> 04:14.000]  В неприлегированном режиме или в пользовательском режиме
[04:14.000 --> 04:19.000]  у процессор выполняется не то чтобы в песочнице,
[04:19.000 --> 04:25.000]  но в некотором специальном подрежеме, где часть инструкций,
[04:25.000 --> 04:29.000]  например, такие инструкции как включение-отключение прерываний
[04:29.000 --> 04:33.000]  или чтение машин specific регистров,
[04:33.000 --> 04:39.000]  соответственно, доступ к отдельным регистрам, например, запись сегментной регистры,
[04:39.000 --> 04:42.000]  он невозможен.
[04:42.000 --> 04:52.000]  И это предназначено для того, чтобы пользователь не мог повлиять
[04:52.000 --> 04:59.000]  на выполняющиеся другие программы на данном оборудовании,
[04:59.000 --> 05:04.000]  и тем самым неприлегионный режим позволяет выполнить
[05:04.000 --> 05:12.000]  самую базовую задачу любой многозадачной ОС,
[05:12.000 --> 05:22.000]  такую как защита ядра от программы и другой программы в неприлегированном режиме.
[05:22.000 --> 05:32.000]  Как именно происходит переход из kernel space в user space?
[05:32.000 --> 05:37.000]  В разных процессорах понятно, что это делается немножко по-разному,
[05:37.000 --> 05:42.000]  но в целом схема, которая присутствует в x86,
[05:42.000 --> 05:47.000]  она очень хорошо похожа и на схемы других процессоров.
[05:47.000 --> 05:52.000]  В x86 существует некоторая специальная структура,
[05:52.000 --> 05:59.000]  с которой вы уже познакомились, она у вас использовалась при переключении контекста
[05:59.000 --> 06:06.000]  без изменения режима с ядерного на пользовательский в третьей лабораторной работе.
[06:06.000 --> 06:13.000]  В этой структуре лежат такие регистры как RIP,
[06:13.000 --> 06:22.000]  Instruction Pointer, Code Segment, RSP, Stack Segment,
[06:22.000 --> 06:27.000]  Register Flags, Airflags.
[06:27.000 --> 06:32.000]  И записав фактически на стэк вот эту структуру,
[06:32.000 --> 06:36.000]  вы можете воспользоваться специальной инструкцией IRED,
[06:36.000 --> 06:42.000]  ну или IRED-Q, как ее кодируют в ассемблере AT&T для 64-битного режима,
[06:42.000 --> 06:48.000]  которая, собственно, восстановит этот контекст из стэка
[06:48.000 --> 06:52.000]  и, соответственно, обновит значение этих регистров,
[06:52.000 --> 06:56.000]  то есть тем самым перейдет фактически в пользовательский режим
[06:56.000 --> 06:59.000]  посредством обновления кодового сегмента,
[06:59.000 --> 07:04.000]  текущего указателя на инструкцию кода,
[07:04.000 --> 07:08.000]  соответственно, обновит стэк,
[07:08.000 --> 07:12.000]  и вы сможете в дальнейшем выполнять пользовательский код.
[07:12.000 --> 07:17.000]  То есть, в принципе, для этого также можно было бы использовать фар инструкции,
[07:17.000 --> 07:20.000]  но так, во-первых, никто не делает,
[07:20.000 --> 07:24.000]  во-вторых, у них есть там больше ограничений,
[07:24.000 --> 07:29.000]  поэтому основной механизм все-таки это вот именно IRED-Q,
[07:29.000 --> 07:33.000]  но в случае, например, не x86-процессоров,
[07:33.000 --> 07:41.000]  то вполне могут быть вот конструкции типа Jump, Far точно так же.
[07:41.000 --> 07:45.000]  Каким образом мы можем вернуться?
[07:45.000 --> 07:48.000]  То есть понятно, что большая часть времени
[07:48.000 --> 07:51.000]  операционная система должна заниматься тем, чтобы выполнять
[07:51.000 --> 07:54.000]  действительно пользовательский код.
[07:54.000 --> 08:00.000]  Но так как мы время от времени должны выполнять
[08:00.000 --> 08:04.000]  какую-то другую задачу, у нас операционная система многозадачная,
[08:04.000 --> 08:07.000]  или в какой-то момент мы должны выполнять
[08:07.000 --> 08:11.000]  функции, которые не могут обойтись без функционирования ядра,
[08:11.000 --> 08:16.000]  ну, например, там какое-нибудь выделение памяти,
[08:16.000 --> 08:20.000]  заранее не выделенный на пользовательский процесс,
[08:20.000 --> 08:23.000]  или, например, обращение к какому-нибудь устройству,
[08:23.000 --> 08:26.000]  которым управляет ядро.
[08:26.000 --> 08:30.000]  Поэтому время от времени мы должны все-таки возвращаться
[08:30.000 --> 08:33.000]  к тому, что мы делаем.
[08:33.000 --> 08:37.000]  Поэтому время от времени мы должны все-таки возвращаться
[08:37.000 --> 08:40.000]  в ядерное пространство.
[08:40.000 --> 08:44.000]  И для этого используются два механизма.
[08:44.000 --> 08:49.000]  Ну, соответственно, первый механизм — это механизм прерываний.
[08:49.000 --> 08:56.000]  В частности, у нас могут возникать прерывания, например, от устройств.
[08:56.000 --> 08:59.000]  Ну, простой пример, прерывания от таймера,
[08:59.000 --> 09:03.000]  которые могут вызывать планировщик и тем самым, соответственно,
[09:03.000 --> 09:10.000]  переключать управление с пользовательского режима на ядерный,
[09:10.000 --> 09:13.000]  и, соответственно, возврат из этого прерывания
[09:13.000 --> 09:16.000]  вернется обратно в пользовательский режим.
[09:16.000 --> 09:19.000]  А также системные вызовы.
[09:19.000 --> 09:23.000]  Ну, соответственно, системные вызовы — это один из механизмов,
[09:23.000 --> 09:26.000]  ну, как мы помним из второй, кажется, лекции,
[09:26.000 --> 09:30.000]  общения между пользователем и ядром,
[09:30.000 --> 09:34.000]  когда, соответственно, пользователь формирует специальным образом
[09:34.000 --> 09:38.000]  некоторые наборы аргументов и говорит ядру, собственно,
[09:38.000 --> 09:41.000]  что мне нужно выполнить вот такую вот задачу.
[09:41.000 --> 09:44.000]  То есть на ядро проверяет, что пользователь действительно
[09:44.000 --> 09:48.000]  имеет право выполнить эту задачу и ее, соответственно, выполняет.
[09:49.000 --> 09:57.000]  В x86 возникает некоторый там вопрос,
[09:57.000 --> 10:04.000]  а на каком, например, стеке вы должны работать в ядре
[10:04.000 --> 10:08.000]  в тот момент, когда, соответственно, возникло, например, прерывание
[10:08.000 --> 10:13.000]  во время работы пользовательского процесса?
[10:13.000 --> 10:19.000]  И ответ на этот вопрос звучит в том, что это происходит, ну, там,
[10:19.000 --> 10:24.000]  плюс-минус аппаратно, то есть есть такая структура
[10:24.000 --> 10:29.000]  под названием, соответственно, task state segment,
[10:29.000 --> 10:33.000]  и именно, собственно, эта структура определяет,
[10:33.000 --> 10:39.000]  как именно будет, как бы, воссоздан ядерный контекст
[10:39.000 --> 10:42.000]  в момент возникновения прерывания.
[10:42.000 --> 10:49.000]  В случае с системными вызовами, то есть если вы используете
[10:49.000 --> 10:53.000]  не механизм прерываний, то есть вполне нормально реализовать
[10:53.000 --> 10:57.000]  поддержку системных вызовов просто с помощью прерываний.
[10:57.000 --> 11:02.000]  Но так как мы хотим получить достаточно высокую производительность
[11:02.000 --> 11:06.000]  при работе этих системных вызовов, то очень часто в современных
[11:06.000 --> 11:11.000]  процессорах существуют механизмы, которые позволяют этот
[11:11.000 --> 11:15.000]  процесс ускорить, то есть некоторые там специальные расширения,
[11:15.000 --> 11:21.000]  и вот, собственно, они, например, позволяют нам меньше сохранять
[11:21.000 --> 11:25.000]  регистров при переключении между контекстами, что, естественно,
[11:25.000 --> 11:30.000]  увеличивает скорость работы системных вызовов.
[11:30.000 --> 11:38.000]  Task state segment – это некоторая структура в памяти,
[11:38.000 --> 11:43.000]  на которую указывает специальный регистр под названием TR.
[11:43.000 --> 11:52.000]  Он очень похож на сегментные регистры типа CS, SS и подобные,
[11:52.000 --> 11:59.000]  но для обновления используется специальная инструкция типа LTR,
[11:59.000 --> 12:03.000]  в отличие от сегментных регистров, которые можно менять
[12:03.000 --> 12:08.000]  с помощью инструкции MOV.
[12:08.000 --> 12:13.000]  Но идея, в общем-то, ровно та же самая.
[12:13.000 --> 12:21.000]  В GDT прописывается некоторый адрес этой самой структуры,
[12:21.000 --> 12:28.000]  в которой содержатся две основные вещи, которые нам интересны.
[12:28.000 --> 12:33.000]  Это, соответственно, адрес стека, то есть RSP,
[12:33.000 --> 12:36.000]  для соответствующего уровня привилегий.
[12:36.000 --> 12:43.000]  И ICT стеки для прерываний – это дополнительное расширение
[12:43.000 --> 12:51.000]  в режиме x8664, которое позволяет вам для некоторых отдельных прерываний
[12:51.000 --> 12:54.000]  установить собственные стеки, чтобы можно было часть прерываний
[12:54.000 --> 12:56.000]  обрабатывать параллельно.
[12:56.000 --> 13:01.000]  То есть как параллельно, в смысле не отключать прерывания глобально,
[13:01.000 --> 13:06.000]  а отключать их локально для группы прерываний.
[13:06.000 --> 13:14.000]  Соответственно, task-stake-сегмент чисто гипотетически позволяет
[13:14.000 --> 13:18.000]  делать аппаратное переключение между задачами,
[13:18.000 --> 13:26.000]  потому что вы можете сделать несколько TSS-сегментов
[13:26.000 --> 13:29.000]  и их все расположить в GDT.
[13:29.000 --> 13:34.000]  Но в связи с тем, что у вас задачи чаще всего гораздо больше,
[13:34.000 --> 13:40.000]  чем размер таблицы GDT, то этот механизм практически никто не использует.
[13:40.000 --> 13:43.000]  Но, тем не менее, он действительно есть.
[13:43.000 --> 13:50.000]  С точки зрения терминологии x86, существует вообще два вида прерываний.
[13:50.000 --> 13:56.000]  Здесь стоит оговориться, что терминология x86 применяется не везде.
[13:56.000 --> 14:04.000]  И очень нередко, когда в новую архитектуру вы приходите,
[14:04.000 --> 14:10.000]  вы столкнетесь с тем, что словами exception, interrupt
[14:10.000 --> 14:13.000]  называют совершенно разные вещи.
[14:13.000 --> 14:19.000]  Потом появляются вещи типа critical interrupt, особо critical interrupt.
[14:19.000 --> 14:31.000]  Но здесь скорее идея в том, что прерываний существует, скажем, много.
[14:31.000 --> 14:37.000]  И эти прерывания делятся на так называемом уровне.
[14:37.000 --> 14:42.000]  Есть, грубо говоря, менее привилегированные прерывания, более привилегированные,
[14:42.000 --> 14:45.000]  еще более привилегированные прерывания.
[14:45.000 --> 14:52.000]  Например, на x86 различают стандартно два уровня прерываний.
[14:52.000 --> 14:57.000]  Асинхронные прерывания, они же interrupt.
[14:57.000 --> 15:02.000]  Эти прерывания являются маскируемыми.
[15:02.000 --> 15:07.000]  То есть маскируемые означают, что их можно отключить.
[15:07.000 --> 15:10.000]  То есть выставляется специальный флаг AF.
[15:10.000 --> 15:18.000]  Ну, вы с ним уже знакомы, потому что видели инструкции STI, CLI в ранних лабораторных работах.
[15:18.000 --> 15:20.000]  И на асинхронные.
[15:20.000 --> 15:27.000]  Это exception или же не маскируемые прерывания, то есть их нельзя отключить.
[15:27.000 --> 15:32.000]  Кроме этого, у вас в принципе существует множество других прерываний.
[15:32.000 --> 15:39.000]  Например, прерывания inter-processor interrupt, то есть прерывания между ядрами.
[15:39.000 --> 15:43.000]  Существует SMI System Management Mode Interrupt.
[15:43.000 --> 15:49.000]  То есть это прерывания, по которому процессор заходит в режим System Management Mode.
[15:49.000 --> 15:52.000]  И на самом деле там много других.
[15:52.000 --> 15:58.000]  К счастью, в операционных системах вам не всегда нужно о них знать.
[15:58.000 --> 16:05.000]  Кроме этого, у устройств могут быть реализованы собственные прерывания.
[16:05.000 --> 16:10.000]  Например, для тех, кто возьмет задание с PCI-шиной.
[16:10.000 --> 16:15.000]  Ему придется познакомиться с MSI прерываниями.
[16:15.000 --> 16:22.000]  И выяснить фактически, что поверх имеющихся прерываний в рамках какой-то отдельно взятой архитектуры.
[16:22.000 --> 16:24.000]  Например, x86.
[16:24.000 --> 16:33.000]  Другие устройства могут выстраивать свою схему прерываний на полупрограммном, полуаппаратном образе.
[16:33.000 --> 16:41.000]  Возвращаясь к нам, в x86 основные виды прерываний.
[16:41.000 --> 16:47.000]  Синхронное прерывание это некоторый результат выполнения текущей инструкции.
[16:47.000 --> 16:53.000]  Но представьте, что в инструкции у вас происходит целочисленное деление.
[16:53.000 --> 16:58.000]  И в результате этого деления вы разделили на ноль.
[16:58.000 --> 17:04.000]  В этот момент у вас будет синхронное прерывание, вы не можете его никак заблокировать.
[17:04.000 --> 17:13.000]  Кроме этого, к синхронным видам прерывания относятся такие прерывания, как неправильная работа с указателями.
[17:13.000 --> 17:20.940]  Например, у вас отсутствует страница в оперативной тему, которая не может быть в
[17:20.940 --> 17:25.940]  Или страница недоступна на запись, недоступна на исполнение.
[17:25.940 --> 17:27.940]  У вас пейчфолд возникнет.
[17:27.940 --> 17:34.940]  Кроме этого, прерывания можно вызвать вручную.
[17:34.940 --> 17:36.940]  Например, на x86.
[17:36.940 --> 17:42.940]  Возвращаясь к нам, в x86 основные виды прерываний.
[17:42.940 --> 17:49.940]  Кроме этого, прерывания можно вызвать вручную.
[17:49.940 --> 17:55.940]  Например, на x86 есть специальная инструкция, называется int,
[17:55.940 --> 17:59.940]  куда записывается номер прерывания.
[17:59.940 --> 18:11.940]  Один из способов использования этой инструкции это генерация прерывания breakpoint.
[18:11.940 --> 18:23.940]  Когда вы ставите breakpoint в дебагере, то, соответственно, можно увидеть, что дебагер подменяет какую-либо инструкцию на int3.
[18:23.940 --> 18:30.940]  Соответственно, вот эта инструкция используется для срабатывания breakpoint на участке кода.
[18:30.940 --> 18:31.940]  Вопрос.
[18:31.940 --> 18:32.940]  Да, давайте.
[18:32.940 --> 18:37.940]  Чем тогда идейно отличаются прерывания от syscalls, если и то, и другое?
[18:37.940 --> 18:41.940]  Это попросить операционку сделать что-то в ядре.
[18:41.940 --> 18:50.940]  На самом деле вы как раз задали вопрос, который я хотел только что задать зрителям.
[18:50.940 --> 18:56.940]  Собственно, вопрос, который хотел задать я, звучал следующим образом.
[18:56.940 --> 19:03.940]  Как можно реализовать syscalls, обладая знанием, которое есть на этом слайде?
[19:03.940 --> 19:07.940]  Взять int80 и порадоваться.
[19:07.940 --> 19:14.940]  Ну, соответственно, на самом деле здесь неважно.
[19:14.940 --> 19:20.940]  Сразу видно тех, кто пользовался UNIX, тех, кто пользовался DOS.
[19:20.940 --> 19:26.940]  Действительно, инструкция int, то есть генерировать некоторое прерывание,
[19:26.940 --> 19:30.940]  это один из наиболее простых способов реализовать сyscalls.
[19:30.940 --> 19:36.940]  То есть вы, выбрав некоторое прерывание и договорившись с ядром,
[19:36.940 --> 19:41.940]  что, соответственно, обработчик этого прерывания будет обработчиком syscalls,
[19:41.940 --> 19:50.940]  можете организовать некоторое соглашение при обработке прерываний.
[19:50.940 --> 19:57.940]  Например, на 21h или int80h, или int40h, неважно,
[19:57.940 --> 20:01.940]  у вас будет обработчик системных вызовов,
[20:01.940 --> 20:08.940]  и он позволит общаться пользователю с ядром.
[20:08.940 --> 20:17.940]  Именно так прерывания достаточно долго были реализованы в операционных системах,
[20:17.940 --> 20:20.940]  и в DOS они так реализованы до сих пор.
[20:20.940 --> 20:25.940]  Это простой портативный вариант реализации системных вызовов.
[20:25.940 --> 20:34.940]  Проблема с таким подходом связана с тем, что любое переключение контекста,
[20:34.940 --> 20:40.940]  вход в ядро – это переключение контекста,
[20:40.940 --> 20:44.940]  это дополнительные накладные расходы,
[20:44.940 --> 20:48.940]  и мы хотели бы эти накладные расходы уменьшить.
[20:48.940 --> 20:54.940]  Мы понимаем, что когда мы переключаемся на ядро,
[20:54.940 --> 20:58.940]  если мы выполняем, например, прерывание по таймеру,
[20:58.940 --> 21:04.940]  то нам нужно как минимум убедиться, что пользователь ничего об этом не узнает.
[21:04.940 --> 21:19.940]  То есть фактически нам нужно обеспечить сохранение всех регистров, которые у нас есть,
[21:19.940 --> 21:25.940]  и затем их восстановление в момент, когда мы вернемся в пользовательский овер.
[21:25.940 --> 21:35.940]  В случае с системными вызовами они отличаются от асинхронных прерываний,
[21:35.940 --> 21:43.940]  от прерываний, возникших внешним образом к текущему исполнению процесса.
[21:43.940 --> 21:47.940]  То есть они отличаются тем, что пользователь знает о том,
[21:47.940 --> 21:51.940]  что он в данный момент хочет выполнить системный вызов.
[21:51.940 --> 21:56.940]  И соответственно нам не обязательно сохранять все регистры.
[21:56.940 --> 21:58.940]  Чувствуете, да?
[21:58.940 --> 22:06.940]  То есть нам не обязательно помнить все состояние пользовательского процесса
[22:06.940 --> 22:08.940]  для того, чтобы обработать системный вызов.
[22:08.940 --> 22:14.940]  На самом деле многие регистры, например, пользователь может сохранить сам.
[22:14.940 --> 22:21.940]  Мы даже помним колли-конвеншн, в результате которой часть регистров, например, колли-презерв,
[22:21.940 --> 22:24.940]  то есть их должен сохранить вызывающий.
[22:24.940 --> 22:29.940]  То есть пользователь даже сам не ждет, что мы какие-то регистры будем сохранять.
[22:29.940 --> 22:39.940]  И здесь возникает возможность оптимизации, которая позволяет нам часть регистров не сохранять
[22:39.940 --> 22:44.940]  и тем самым сэкономить время на обработку системного вызова.
[22:44.940 --> 22:49.940]  В связи с этим в процессорах, в том числе в современном x86,
[22:49.940 --> 22:57.940]  существуют специальные механизмы, которые позволяют реализовывать системные вызовы
[22:57.940 --> 23:03.940]  более быстрым способом, чем простой вызов синхронного прерывания
[23:03.940 --> 23:06.940]  с помощью классической инструкции на.
[23:06.940 --> 23:08.940]  Ответил на вопрос?
[23:08.940 --> 23:11.940]  Ну да, в целом понятно.
[23:11.940 --> 23:13.940]  Хорошо.
[23:13.940 --> 23:20.940]  Соответственно, про синхронные прерывания, то, что к таким прерываниям относится,
[23:20.940 --> 23:25.940]  например, прерывания от таймера, от других устройств, я только что сказал.
[23:25.940 --> 23:32.940]  Поэтому как эти прерывания описать?
[23:32.940 --> 23:38.940]  Есть такая структура под названием interruptDescriptorTable.
[23:38.940 --> 23:44.940]  Поверхностно вы с ней уже познакомились, но делали это достаточно неглубоко,
[23:44.940 --> 23:48.940]  поэтому я все-таки остановлюсь на этом снова.
[23:48.940 --> 23:54.940]  И скажу, что это 256-слотовая структура.
[23:54.940 --> 24:01.940]  При этом первые 32 записи зарезервированы Intel под некоторые системные исключения.
[24:01.940 --> 24:09.940]  В процессе отладки вам наиболее актуальные исключения 13 и 14.
[24:09.940 --> 24:13.940]  Первая это General Protection Fold.
[24:13.940 --> 24:18.940]  Чаще всего возникает, когда вы пытаетесь выполнить что-то
[24:18.940 --> 24:21.940]  и у вас нет прав на это действие.
[24:21.940 --> 24:26.940]  Например, пытаетесь выполнить инструкцию, которую вы не можете выполнять в этом режиме.
[24:26.940 --> 24:29.940]  Или что-то подобное.
[24:29.940 --> 24:34.940]  Второе 14-е прерывание это PageFold.
[24:34.940 --> 24:40.940]  PageFold возникает, когда вы пытаетесь обратиться к памяти,
[24:40.940 --> 24:45.940]  которая вам в данном режиме недоступна.
[24:45.940 --> 24:53.940]  У PageFold существует две полезных вещи.
[24:53.940 --> 25:01.940]  Это адрес CR2, который вам говорит,
[25:01.940 --> 25:07.940]  к какому адресу вы пытались обратиться, и у вас возникло исключение.
[25:07.940 --> 25:15.940]  И код PageFold, который вам пушится вместе с контекстом,
[25:15.940 --> 25:19.940]  в котором записано действие, которое вы пытались выполнить.
[25:19.940 --> 25:25.940]  Например, там есть BitPresent в коде.
[25:25.940 --> 25:30.940]  То есть была ли страница в памяти, когда вы пытались обратиться к ней.
[25:30.940 --> 25:33.940]  Там BitWrite.
[25:33.940 --> 25:37.940]  То есть пытались ли вы записать в эту память.
[25:37.940 --> 25:39.940]  Или пытались прочитать.
[25:39.940 --> 25:45.940]  BitUser, который говорит вам о том, что возник PageFold в пользовательском адресном пространстве.
[25:45.940 --> 25:48.940]  Или в ядерном.
[25:48.940 --> 25:52.940]  BitIF, то есть InstructionFetch.
[25:52.940 --> 25:55.940]  То есть пытались ли вы исполнить какую-то память.
[25:55.940 --> 25:58.940]  Или это была операция чтения или записи.
[25:58.940 --> 26:01.940]  И, соответственно, эта информация вам может дать очень много
[26:01.940 --> 26:04.940]  в процессе отлаживания вашей программы.
[26:04.940 --> 26:07.940]  Особенно, когда вы пытаетесь обратиться к ней.
[26:07.940 --> 26:13.940]  То есть довольно нередко у вас может упасть ваша хостовая операционная система.
[26:13.940 --> 26:18.940]  Ну, там, не знаю, винда, там, Linux, Mac.
[26:18.940 --> 26:22.940]  И у вас будет некоторый краш репорт, на который вы посмотрите.
[26:22.940 --> 26:25.940]  И будете пытаться понять, что вообще произошло.
[26:25.940 --> 26:32.940]  Вот наличие Stack Tracer и наличие, соответственно, вот этих дополнительных данных закодированных в регистре.
[26:32.940 --> 26:36.940]  Они вам неплохо могут упростить задачу понимания проблемы.
[26:36.940 --> 26:41.940]  А что же, собственно, произошло в данной точке.
[26:41.940 --> 26:48.940]  На таблицу IDT указывает специальный регистр IDTR.
[26:48.940 --> 26:54.940]  Ну, вы, соответственно, его помните по инструкции LIDT.
[26:54.940 --> 26:59.940]  И, ну, как я уже говорил, в этом таблице.
[27:00.940 --> 27:09.940]  И, ну, каждый слот в таблице IDT выглядит достаточно там понятным, очевидным образом.
[27:09.940 --> 27:17.940]  То есть там есть, соответственно, кодовый сегмент и, соответственно, адрес RIP.
[27:17.940 --> 27:21.940]  Куда нужно перейти в момент возникновения прерываний.
[27:21.940 --> 27:30.940]  Уровень привилегий, с какими привилегиями нужно, собственно, обрабатывать данные прерываний.
[27:30.940 --> 27:32.940]  Ну, понятно, что там всегда 0 пишется.
[27:32.940 --> 27:39.940]  Потому что обрабатывать прерывания в пользовательском адресном пространстве, ну, практически всегда слишком небезопасно.
[27:39.940 --> 27:45.940]  И сейчас, наверное, нет ни одной операционной системы, которая бы делала в не нулевом.
[27:45.940 --> 27:48.940]  Тесно бит презент.
[27:48.940 --> 27:55.940]  А можно ли, ну, то есть давай использовать, ну, какой-нибудь диапазон прерываний свободный.
[27:55.940 --> 27:59.940]  Ну, то есть с правом пользователя обрабатывать, чтобы он мог пользоваться.
[27:59.940 --> 28:11.940]  Технически можно практически, вот, честно говоря, не знаю, ни одной операционной системы, которая бы так делала.
[28:11.940 --> 28:15.940]  Пользы от этого, если честно, тоже непонятно.
[28:15.940 --> 28:21.940]  Вреда чаще всего много, потому что там на векторе может сидеть какое-нибудь устройство.
[28:21.940 --> 28:24.940]  И в векторах и так тесно.
[28:24.940 --> 28:32.940]  А, соответственно, просто обрабатывать голые прерывания от устройства прямо в режиме пользователей Aziz,
[28:32.940 --> 28:36.940]  чаще всего чревато.
[28:36.940 --> 28:40.940]  Вот, есть еще gate type.
[28:40.940 --> 28:45.940]  Кому интересно, в принципе, могут прочитать, вот там есть ссылка специально.
[28:45.940 --> 28:55.940]  Но основная, как бы вам, важность этого gate type, она заключается в том, что будут ли включены прерывания в момент входа в обработчик или не будут.
[28:55.940 --> 29:05.940]  Собственно, механизм позволяет стереализовать прерывания, тем самым уменьшить количество, то есть уменьшить потребление стека в гидре,
[29:05.940 --> 29:09.940]  тогда, когда прерывания обрабатываются.
[29:09.940 --> 29:17.940]  Ну и, соответственно, IST, это там фишка x8664, это, соответственно, номер стека в TSS.
[29:17.940 --> 29:24.940]  Таким образом, вы, соответственно, можете выбрать несколько стеков для обработки разных прерываний, устройств разных типов.
[29:24.940 --> 29:28.940]  Например, там есть просто устройства, которые генируют много быстрых прерываний.
[29:28.940 --> 29:38.940]  И вы, например, хотите их обрабатывать быстрее, и для этого, соответственно, используете специальный стек для этих прерываний.
[29:39.940 --> 29:48.940]  Что касается, соответственно, самих системных вызовов, мы об этом уже немного поговорили.
[29:48.940 --> 29:57.940]  Но, в общем-то, системные вызовы состоят из фактически двух частей.
[29:57.940 --> 30:03.940]  То есть первая часть – это, собственно, ABI системных вызовов.
[30:03.940 --> 30:13.940]  Если в случае кода генерации, например, хищного кода, у нас есть сложившаяся ABI.
[30:13.940 --> 30:22.940]  Например, мы видели Microsoft x64 ABI, которая используется в UFI коде, или она в Windows также используется.
[30:22.940 --> 30:31.940]  А также мы видели ABI System 5, которая используется во всех UNIX совместимых системах,
[30:31.940 --> 30:36.940]  и она в том числе используется в JOS, определяющей, собственно, calling conventions,
[30:36.940 --> 30:41.940]  или соглашение о вызове для функций.
[30:41.940 --> 30:50.940]  То в случае с системными вызовами также существует ABI, но этот механизм является
[30:50.940 --> 30:54.940]  специфичным для каждой отдельно взятой операционной системы,
[30:54.940 --> 31:00.940]  и вот каждая операционная система определяет его по-своему.
[31:00.940 --> 31:09.940]  Чаще всего при организации системных вызовов пользовательский код старается сохранить все аргументы
[31:09.940 --> 31:14.940]  в некоторые регистры в определенном порядке,
[31:14.940 --> 31:23.940]  и в дальнейшем из каких-то регистров получить результаты, которые ядро предоставит.
[31:23.940 --> 31:36.940]  При этом, если необходимо обращаться к памяти, то у ядра одна из важных задач при обработке системных вызовов
[31:36.940 --> 31:44.940]  появляется проверка, а можно ли писать или читать в ту или иную память,
[31:44.940 --> 31:47.940]  которую передает пользователь.
[31:47.940 --> 31:54.940]  Поэтому один из немаловажных моментов, который, как ни странно, также добавляет
[31:54.940 --> 32:00.940]  оверхед при обработке системных вызовов, заключается в проверке прав доступа,
[32:00.940 --> 32:09.940]  чтобы не возникла ситуация, когда вы выполнили какой-нибудь системный вызов с кодом записи,
[32:09.940 --> 32:16.940]  с операцией, которая выполняет какую-то запись данных из ядра, например, в user space,
[32:16.940 --> 32:22.940]  передали не свой указатель, а ядерный, и в результате ядро что-то перезаписало,
[32:22.940 --> 32:29.940]  и тем самым, соответственно, отработало некорректно, и, например, произвело какую-то проблему в безопасности.
[32:29.940 --> 32:39.940]  Как ни странно, вот проблемы такого типа достаточно часто возникают в операционных системах,
[32:39.940 --> 32:50.940]  поэтому проверка, что в системном вызове нет возможности скомпрометировать операционные системы,
[32:50.940 --> 32:57.940]  это одна из важных задач при разработке операционных систем,
[32:57.940 --> 33:06.940]  и для этого строятся разные инструменты, о которых мы немножко позднее тоже поговорим.
[33:06.940 --> 33:17.940]  В свою очередь в Jaws используется инструкция INT для генерации прерываний системных вызовов,
[33:17.940 --> 33:27.940]  в частности INT30H, но в рамках индивидуального задания вам будет предложено реализовать специальные механизмы
[33:27.940 --> 33:34.940]  для реализации системных вызовов, которые позволяют эти системные вызовы ускорить.
[33:34.940 --> 33:47.940]  В X86 существует три основных пары организаций ускоренных системных вызовов.
[33:47.940 --> 34:00.940]  Для 64-битных приложений есть стандартный механизм, который общий и для AMD, и для Intel.
[34:00.940 --> 34:03.940]  Это, соответственно, функция syscall и sysret.
[34:03.940 --> 34:13.940]  Когда вы выполняете функцию syscall, у вас не изменяется текущее значение RSP,
[34:13.940 --> 34:21.940]  но при этом адрес RIP загружается из специального MSR-регистра.
[34:21.940 --> 34:36.940]  Вот пример одного из MSR-регистров, который также является стандартным для процессоров разных производителей.
[34:36.940 --> 34:45.940]  В частности, его поддерживают и AMD, и Intel, в отличие от специфичного для отдельного вентера регистра.
[34:45.940 --> 34:48.940]  То есть он является частью ISA.
[34:48.940 --> 34:53.940]  В свою очередь пользовательский RIP сохраняется в регистре RCX,
[34:53.940 --> 34:59.940]  и когда вы выполните инструкцию sysret, он по этому регистру перейдет.
[34:59.940 --> 35:05.940]  В случае с флагами у вас есть некоторая маска,
[35:05.940 --> 35:17.940]  и в рамках этой маски вы удаляете те биты, которые вы бы не хотели, чтобы стояли при обработке системного вызова.
[35:17.940 --> 35:26.940]  Например, флаг обработки прерываний, когда вы не хотите, чтобы в случае возникновения системного вызова у вас прервал таймер.
[35:26.940 --> 35:38.940]  Что касается 32-битных приложений, то здесь есть некоторое разделение в зависимости от поддерживаемых архитектур.
[35:38.940 --> 35:52.940]  В частности, у Intel есть механизм sysenter-sysexit, который не использует точно так же стэк,
[35:52.940 --> 36:00.940]  но USP при этом меняется на значение, сохраненное в специальном MSR регистре.
[36:00.940 --> 36:19.940]  Он также теряет значение RIP, потому что его перезаписывает на другое значение из MSR регистры.
[36:19.940 --> 36:29.940]  При этом прервание маскируется безусловно, а остальные флаги остаются неизменными, что не очень удобно.
[36:29.940 --> 36:38.940]  Это legacy-механизм, недостатки которого здесь видны, и они были учтены при разработке механизма syscall-sysred.
[36:38.940 --> 36:49.940]  В случае с AMD, обычно AMD не поддерживает sysenter-sysexit, хотя вроде бы было несколько процессоров, которые этот набор инструкций поддерживали.
[36:49.940 --> 37:03.940]  И там используется syscall-sysred, работающий в похожем режиме, то есть похожем на 6-3-убитный режим, но в 3-100-убитном режиме.
[37:03.940 --> 37:08.940]  Что? Вопрос?
[37:08.940 --> 37:09.940]  Вопрос.
[37:09.940 --> 37:17.940]  У sysenter-sysexit не используется стэк, а для чего меняется ESP?
[37:17.940 --> 37:23.940]  Чтобы можно было выполнять ядерный код на ядерном стэке.
[37:28.940 --> 37:37.940]  Ну, у вас как бы при входе в обработчик системных вызовов можно сразу стишу на функцию написать.
[37:42.940 --> 37:45.940]  Так, а как мы с адресом возврата живем?
[37:45.940 --> 37:51.940]  Адрес возврата нужно сохранять через регистры или, соответственно, через память.
[37:51.940 --> 37:55.940]  Ну, то есть адрес возврата нужно каким-то образом передать.
[37:55.940 --> 37:58.940]  Потому что вот тут же, да, сказано, что EMI теряется.
[37:58.940 --> 38:03.940]  Да, он теряется, да. Его нужно передавать через другие регистры или через память.
[38:07.940 --> 38:09.940]  Вот такое вот неудобство.
[38:10.940 --> 38:19.940]  Хорошо. Соответственно, когда мы обрабатываем системные вызовы,
[38:19.940 --> 38:25.940]  мы меньше всего хотим, чтобы системный вызов себя вел неправильно.
[38:25.940 --> 38:31.940]  Ну, или скорее привел к ситуации, которая может каким-то образом скомпрометировать наше ядро.
[38:32.940 --> 38:40.940]  Как мы и помним, существуют специальные механизмы в таблице страниц,
[38:40.940 --> 38:45.940]  которые предупрощают непреднамеренный доступ к памяти.
[38:45.940 --> 38:52.940]  Вот мет такой как, собственно, исполнение страниц с данными,
[38:52.940 --> 38:54.940]  тот же самый NX bit.
[38:54.940 --> 39:04.940]  При этом X86, они по историческим причинам не зависят от текущего уровня привилегий.
[39:04.940 --> 39:12.940]  Если, например, посмотреть на ММУ, используемое в каких-нибудь PowerPC букье,
[39:12.940 --> 39:21.940]  то в данном ММУ устанавливаются раздельные наборы привилегий для пользователя и для ядра.
[39:21.940 --> 39:28.940]  То есть, грубо говоря, память, которая доступна для чтения или для записи в пространстве пользователя,
[39:28.940 --> 39:34.940]  она может быть целиком недоступна ни для чтения, ни для записи в пространстве ядра.
[39:36.940 --> 39:46.940]  А в X86 так сложилось, что права соответственно пользователя действуют и в пространстве ядра.
[39:46.940 --> 39:52.940]  То есть за единственным исключением, что пользователь не может получить доступ к ядру,
[39:52.940 --> 39:57.940]  а вот ядро как раз может получить доступ к ядру целиком и полностью.
[39:57.940 --> 40:06.940]  Дорешая эту проблему, в X86 добавили в CR4 специальные два бита,
[40:06.940 --> 40:14.940]  называемые как раз SMAP и SMAP. Они же соответственно Supervisor Mode Access Prevention
[40:14.940 --> 40:17.940]  и Supervisor Mode Execution Prevention.
[40:17.940 --> 40:24.940]  SMAP просто запрещает исполнять всю память, которая доступна пользователю,
[40:24.940 --> 40:32.940]  или имеет соответственно bit.u в таблице страниц.
[40:32.940 --> 40:39.940]  SMAP в свою очередь запрещает любой доступ к памяти пользователя в ядре.
[40:39.940 --> 40:46.940]  Соответственно это можно отключить, временно установив bit.ac в Airflux.
[40:46.940 --> 40:53.940]  Сюда вопрос, допустим, что вы не хотите отключать SMAP,
[40:53.940 --> 41:00.940]  как бы вы могли вернуть пользователю, например, какой-то память,
[41:00.940 --> 41:06.940]  записав ему какие-нибудь данные через системный вызов?
[41:06.940 --> 41:09.940]  Вопрос на понимание.
[41:09.940 --> 41:12.940]  Ну, через регистры всегда можно.
[41:12.940 --> 41:18.940]  Ну да, но допустим вам нужно вернуть пользователю очень большое количество памяти,
[41:18.940 --> 41:25.940]  скажем, 2 мегабайт. Через регистры будет долго, очень долго.
[41:25.940 --> 41:32.940]  Ну, в принципе, по-моему, есть кусочек памяти, который доступен пользователю только для чтения.
[41:32.940 --> 41:35.940]  И что?
[41:35.940 --> 41:38.940]  Ну, можно куда-нибудь туда попробовать записать.
[41:38.940 --> 41:42.940]  Запрещает любой доступ к памяти пользователя в ядре.
[41:42.940 --> 41:48.940]  Если у пользователя в ядре означает, что если в странице есть bit.u, то, соответственно,
[41:48.940 --> 41:52.940]  пользователя она будет, то есть ядро она будет полностью недоступна.
[41:52.940 --> 41:57.940]  Не важно, для чтения она, для записи, для исполнения, не важно.
[41:57.940 --> 42:03.940]  Любая пользовательская страница будет недоступна для ядра.
[42:03.940 --> 42:07.940]  Так, а если мы, Ватюм, какую-нибудь страничку снимем, с нее bit.u,
[42:07.940 --> 42:13.940]  запишем, просто проигнорируем ее, содержаем ее, запишем что-то новое и установим bit.u?
[42:13.940 --> 42:18.940]  Ну, это уже ближе. Так работать действительно будет, но спрашивается,
[42:18.940 --> 42:25.940]  зачем с какой-то конкретной странички снимать bit.u, если можно просто сделать еще одно отображение
[42:25.940 --> 42:29.940]  по какому-то другому адресу?
[42:29.940 --> 42:33.940]  Ну, то есть вам никто не запретит, то есть если у вас есть отображение
[42:33.940 --> 42:37.940]  на некоторой пользовательской странице, на какой-то физический адрес,
[42:37.940 --> 42:43.940]  то вам никто не запрещает, соответственно, дать доступ
[42:43.940 --> 42:49.940]  из другого адреса, который замапит чисто для ядра,
[42:49.940 --> 42:55.940]  в этот же самый физический адрес и через него, собственно, записать.
[42:55.940 --> 42:59.940]  Вот, понятная идея, да?
[42:59.940 --> 43:03.940]  Точно с ума не сойдем, если начнем такие фокусы делать.
[43:03.940 --> 43:07.940]  Ну, большинство современных операционных систем именно так работают.
[43:07.940 --> 43:13.940]  То есть есть специальные вызовы, типа там vm-map в ядре,
[43:13.940 --> 43:22.940]  которые вот как раз и реализуют всякие там функции, типа vm-write, vm-read и подобные.
[43:22.940 --> 43:27.940]  То есть они делают там временное, например, отображение в адресном пространстве ядра
[43:27.940 --> 43:31.940]  и таким образом, собственно, записывают.
[43:31.940 --> 43:38.940]  С ума пока еще никогда не сошел, но действительно такой механизм
[43:38.940 --> 43:44.940]  накладывает дополнительные ограничения на драйвер ММУ.
[43:44.940 --> 43:48.940]  То есть вы, например, уже не можете использовать статическую конфигурацию памяти
[43:48.940 --> 43:53.940]  в операционной системе или можете, но там достаточно ограничено.
[43:53.940 --> 43:59.940]  И также, собственно, добавляет дополнительный overhead,
[43:59.940 --> 44:03.940]  потому что вам приходится изменять состояние таблицы страниц
[44:03.940 --> 44:10.940]  если не каждый, но, по крайней мере, при многих задачах доступа к памяти.
[44:10.940 --> 44:13.940]  Но, тем не менее, безопасность требует жертв,
[44:13.940 --> 44:17.940]  и на современных процессорах overhead он очень маленький,
[44:17.940 --> 44:20.940]  поэтому в современных процессорах смап,
[44:20.940 --> 44:24.940]  в современных операционных системах, на современных процессорах
[44:24.940 --> 44:29.940]  вы вполне можете увидеть включенный смап в вашей операционной системе.
[44:29.940 --> 44:36.940]  Вот. К сожалению или к счастью, вот такой механизм
[44:36.940 --> 44:44.940]  он, скажем так, не всегда, не находит там все проблемы
[44:44.940 --> 44:49.940]  на стадии, когда эти проблемы можно исправить.
[44:49.940 --> 44:55.940]  То есть, как вы знаете, у вас нередко может произойти какое-нибудь повреждение,
[44:55.940 --> 45:02.940]  например, памяти, но при этом, в тот момент, когда операционная система уже крашнется,
[45:02.940 --> 45:05.940]  то есть генерирует какое-то сообщение об ошибке,
[45:05.940 --> 45:11.940]  у вас уже может не быть тех данных, которые позволяют идентифицировать,
[45:11.940 --> 45:16.940]  по какой причине, собственно, операционная система крашнулась.
[45:16.940 --> 45:18.940]  Бывали у вас такие ситуации?
[45:18.940 --> 45:29.940]  Ну, типа у нас в процессе выполнения там седьмой лавы крашился Джоз,
[45:29.940 --> 45:33.940]  и еще он крашил Куэму заодно, причем без сообщения об ошибках.
[45:33.940 --> 45:35.940]  Так что да, наверное.
[45:35.940 --> 45:40.940]  Это у некоторых людей с некоторыми версиями Куэму.
[45:40.940 --> 45:47.940]  Ну, здесь, конечно, пример из жизни немножко не тот, про который я говорил,
[45:47.940 --> 45:53.940]  но, по крайней мере, у всех там что-то похожее в любом случае было,
[45:53.940 --> 45:56.940]  то есть когда возникает некоторая ошибка,
[45:56.940 --> 46:03.940]  и мы не можем фактически понять, а где конкретно эта ошибка произошла,
[46:03.940 --> 46:07.940]  потому что, грубо говоря, момент краша, например,
[46:07.940 --> 46:11.940]  и момент возникновения ошибки, они разнесены по времени,
[46:11.940 --> 46:15.940]  и тем самым вы просто не можете установить,
[46:15.940 --> 46:22.940]  собственно, какое изменение или какое действие повело к тому,
[46:22.940 --> 46:24.940]  что такая проблема возникла.
[46:24.940 --> 46:30.940]  Именно по этой причине в операционную систему,
[46:30.940 --> 46:33.940]  по крайней мере в отладочную ее версию,
[46:33.940 --> 46:39.940]  стараются внедрить максимальное количество проверок выполняемых в динамике,
[46:39.940 --> 46:43.940]  которые, собственно, мониторят состояние операционной системы
[46:43.940 --> 46:48.940]  или состояние программ, которые работают в этой операционной системе.
[46:48.940 --> 46:51.940]  И в момент нарушения какого-то инварианта,
[46:51.940 --> 46:55.940]  то есть в момент обнаружения, что операционная система работает некорректно,
[46:55.940 --> 46:58.940]  стараются ее уронить максимально рано,
[46:58.940 --> 47:03.940]  при этом собрать максимальное количество информации
[47:03.940 --> 47:11.940]  о операционной системе в том месте, где этот вариант был нарушен.
[47:11.940 --> 47:19.940]  Один из способов как раз выявить такие проблемы
[47:19.940 --> 47:24.940]  это способы динамического инструментирования.
[47:24.940 --> 47:28.940]  Динамическое инструментирование применяется много где,
[47:28.940 --> 47:37.940]  и, наверное, два основных направления развития в нем есть.
[47:37.940 --> 47:43.940]  Первое направление развития – это сбор метрик,
[47:43.940 --> 47:47.940]  и он появился даже сильно раньше.
[47:47.940 --> 47:54.940]  Например, слышали, наверное, про то, что должно быть полное покрытие кода тестами.
[47:54.940 --> 47:57.940]  Слышали что-нибудь про такое?
[47:57.940 --> 47:59.940]  Ну да.
[47:59.940 --> 48:02.940]  Ну вот, мы, соответственно, примерно представляете,
[48:02.940 --> 48:07.940]  как, наверное, работает механизм сбора покрытия в классическом виде.
[48:07.940 --> 48:12.940]  Не очень, там слишком большое разветление дерева,
[48:12.940 --> 48:14.940]  и реально это очень сложно посчитать.
[48:14.940 --> 48:21.940]  Ну, в случае с разветлением дерева
[48:21.940 --> 48:28.940]  действительно честный сбор покрытия посчитать очень сложно,
[48:28.940 --> 48:31.940]  поэтому используют приближенные методы,
[48:31.940 --> 48:35.940]  то есть такие как, например, покрытие по строкам
[48:35.940 --> 48:41.940]  или покрытие по веткам, если брать классические способы сбора покрытия.
[48:41.940 --> 48:46.940]  Есть там более интересные способы сбора покрытия типа MCDC,
[48:46.940 --> 48:55.940]  то есть тогда, когда вы проверяете условно, что каждый, грубо говоря,
[48:55.940 --> 49:02.940]  конъюнкт в дизюнкции был проверен как в состоянии единицы
[49:02.940 --> 49:04.940]  независимо от всех остальных конъюнктов,
[49:04.940 --> 49:09.940]  но это уже как бы такие более продвинутые способы сбора покрытия,
[49:09.940 --> 49:14.940]  применяемые в специализированном Сейфти Критику программном обеспечении.
[49:14.940 --> 49:19.940]  Но технически нам важно именно, как это происходит технически.
[49:19.940 --> 49:24.940]  Для сбора покрытия преобразуется программный код
[49:24.940 --> 49:29.940]  либо на уровне исходного языка, программирования что реже,
[49:29.940 --> 49:36.940]  либо на уровне компилятора или эмулятора, в котором происходит исполнение.
[49:36.940 --> 49:39.940]  Второй механизм чаще используется.
[49:39.940 --> 49:43.940]  Таким образом, что в программе,
[49:43.940 --> 49:47.940]  которую можно представить как некоторый Control Flow Graph,
[49:47.940 --> 49:50.940]  все знают, наверное, из курса компиляторов,
[49:50.940 --> 49:54.940]  что у вас есть некоторый граф потока управления,
[49:54.940 --> 50:01.940]  в котором, грубо говоря, каждое условие это порождение
[50:01.940 --> 50:06.940]  фактически двух базовых блоков, по которым может пойти программа.
[50:06.940 --> 50:10.940]  У нас компиляторов пока не было, но, думаю, многие знают.
[50:10.940 --> 50:13.940]  Да, ну вот, хорошо, значит, будете...
[50:13.940 --> 50:15.940]  А, да, у вас следующий, наверное, семестр.
[50:15.940 --> 50:19.940]  Окей, ну вот, вам на всякий случай про это расскажут,
[50:19.940 --> 50:26.940]  но вещь достаточно известная, что у вас есть фактически набор базовых блоков,
[50:26.940 --> 50:30.940]  и, соответственно, они являются, соответственно,
[50:30.940 --> 50:32.940]  части у графа потока управления.
[50:32.940 --> 50:35.940]  То есть в момент, когда у вас появляются условия,
[50:35.940 --> 50:39.940]  то есть у вас происходит расщепление вот этого графа.
[50:39.940 --> 50:44.940]  И для того, чтобы, например, собрать простейшее покрытие по строкам,
[50:44.940 --> 50:51.940]  вам достаточно добавить каунтеры во все базовые блоки.
[50:51.940 --> 50:56.940]  И в момент, собственно, когда вы выполнили какую-то программу,
[50:56.940 --> 51:02.940]  просто посмотреть, что мы действительно там прошли по всем блокам,
[51:02.940 --> 51:05.940]  просто проверив эти каунтеры и отобразив там в отчете,
[51:05.940 --> 51:10.940]  что соответствующий конкретным строкам, например,
[51:10.940 --> 51:14.940]  на C каунтере установлены в единицу.
[51:14.940 --> 51:19.940]  Если да, то тогда покрытие этого блока произошло.
[51:19.940 --> 51:23.940]  Вторым направлением развития динамического инструментирования
[51:23.940 --> 51:27.940]  является направление с поиском ошибок.
[51:27.940 --> 51:32.940]  И там поиск ошибок — это, ну, например,
[51:32.940 --> 51:35.940]  некоторая там трансформация, скажем так, программы,
[51:35.940 --> 51:42.940]  таким образом, чтобы в момент, когда там программа что-то делает,
[51:42.940 --> 51:44.940]  проверять, ну, что происходит,
[51:44.940 --> 51:48.940]  чтобы в момент, когда там программа что-то делает,
[51:48.940 --> 51:51.940]  проверялись дополнительные структуры,
[51:51.940 --> 51:53.940]  дополнительные какие-то особенности,
[51:53.940 --> 52:00.940]  позволяющие вам выявить ошибку, например, на более раннем уровне.
[52:00.940 --> 52:05.940]  Простейший пример, который я, кажется, ранее уже приводил на защите.
[52:05.940 --> 52:12.940]  Вот представьте, что у вас есть процессор 1, процессор 2.
[52:12.940 --> 52:16.940]  В программе происходит целочисленное деление на ноль.
[52:16.940 --> 52:20.940]  Вы знаете, что деление на ноль,
[52:20.940 --> 52:23.940]  с точки зрения языка оси, это неопределенное поведение.
[52:23.940 --> 52:27.940]  Но вот так сложилось, что вы не уследили за своей программой
[52:27.940 --> 52:30.940]  и все-таки на ноль разделили.
[52:30.940 --> 52:35.940]  Вот, допустим, интеловский процессор хороший,
[52:35.940 --> 52:41.940]  он сгенирует исключения в момент, когда вы на ноль разделите.
[52:41.940 --> 52:47.940]  Однако другие процессоры могут быть далеко не такими хорошими.
[52:47.940 --> 52:51.940]  Например, на PowerPC разделили на ноль, получили ноль.
[52:51.940 --> 52:53.940]  Ну вот так.
[52:53.940 --> 53:00.940]  И самый простой пример динамического инструментирования для поиска ошибок.
[53:00.940 --> 53:05.940]  А давайте на уровне компилятора вставим проверку перед инструкцией деления,
[53:05.940 --> 53:09.940]  что делитель не равен нулю.
[53:09.940 --> 53:11.940]  Если, соответственно, делитель равен нулю,
[53:11.940 --> 53:14.940]  то всегда будем генерировать какое-нибудь сообщение об ошибке
[53:14.940 --> 53:16.940]  и ронять программу.
[53:17.940 --> 53:22.940]  Это простой пример, который вам позволит найти ошибки
[53:22.940 --> 53:26.940]  независимо от того, какая архитектура у вас используется.
[53:28.940 --> 53:33.940]  Именно по этому пути идут вещи типа санитайзеров LLVM,
[53:33.940 --> 53:35.940]  которыми вы начали использовать
[53:35.940 --> 53:40.940]  и которые, собственно, начиная как раз с восьмой лабораторной работы,
[53:40.940 --> 53:43.940]  у вас будут действовать в расширенном режиме,
[53:43.940 --> 53:48.940]  то есть у вас появятся санитайзеры и в пользовательском адресном пространстве,
[53:48.940 --> 53:50.940]  и в ядре.
[53:52.940 --> 53:58.940]  Соответственно, само по себе инструментирование может выполняться
[53:58.940 --> 54:02.940]  как внутри программного обеспечения,
[54:02.940 --> 54:07.940]  например, посредством добавления кода некоторым компиляторам,
[54:07.940 --> 54:11.940]  так и в изолированной среде.
[54:11.940 --> 54:15.940]  Например, это может быть виртуальная машина Quay.
[54:15.940 --> 54:21.940]  Кто-нибудь может сказать, когда второй способ инструментирования предпочтительнее?
[54:28.940 --> 54:30.940]  Тут вариантов много.
[54:30.940 --> 54:35.940]  Например, в Valgrind используется что-то больше похожее на второй способ,
[54:35.940 --> 54:38.940]  потому что ему надо к теневой памяти играться.
[54:38.940 --> 54:41.940]  Но при этом адрес санитайзер также использует теневую память
[54:41.940 --> 54:44.940]  и работает внутри программы.
[54:44.940 --> 54:47.940]  Может, когда у нас нет исходного кода?
[54:47.940 --> 54:54.940]  Да, вот это один из примеров ситуации, когда в изолированной среде работать удобнее.
[54:54.940 --> 54:57.940]  Если у нас нет исходного кода к программе,
[54:57.940 --> 55:02.940]  то ее можно инструментировать с помощью эмулятора.
[55:02.940 --> 55:06.940]  Так работают некоторые файзеры.
[55:06.940 --> 55:10.940]  Кроме этого, еще возникают ситуации,
[55:10.940 --> 55:17.940]  когда у вас, например, может быть в целевой машине
[55:17.940 --> 55:22.940]  достаточно малое количество оперативной памяти
[55:22.940 --> 55:27.940]  и вы просто не можете разместить ваш инструмент
[55:27.940 --> 55:31.940]  на целевом устройстве,
[55:31.940 --> 55:36.940]  внутри вот этого вот программного пакета.
[55:36.940 --> 55:39.940]  Но при этом вы можете написать эмулятор этого целевого устройства
[55:39.940 --> 55:44.940]  и уже в эмуляторе инспектировать состояние вашего кода.
[55:44.940 --> 55:47.940]  То есть такой механизм тоже вполне себе работает.
[55:47.940 --> 55:50.940]  Итак, санитайзеры LVM.
[55:50.940 --> 55:56.940]  Санитайзеры изначально были проектом Google,
[55:56.940 --> 56:02.940]  который можно найти на нашей странице на вики,
[56:02.940 --> 56:05.940]  где есть достаточно подробное описание.
[56:05.940 --> 56:10.940]  Идея у этих санитайзеров заключается в том,
[56:10.940 --> 56:15.940]  что в программу добавляются специальные санитайзеры,
[56:15.940 --> 56:18.940]  добавляются специальные конструкции,
[56:18.940 --> 56:21.940]  автоматические на этапе компиляции,
[56:21.940 --> 56:29.940]  максимально бесплатно предоставляемые проверки,
[56:29.940 --> 56:32.940]  при условии, что у вас есть компилятор Clang
[56:32.940 --> 56:36.940]  или с некоторыми исключениями компилятор GCC.
[56:36.940 --> 56:39.940]  Там санитайзеры есть, но они добавляются медленнее,
[56:39.940 --> 56:41.940]  и соответственно не все,
[56:41.940 --> 56:44.940]  потому что в первую очередь санитайзеры
[56:44.940 --> 56:48.940]  довалились как фича в компилятор LVM.
[56:48.940 --> 56:54.940]  Вот на слайде есть примеры санитайзеров,
[56:54.940 --> 57:00.940]  которые каждый направлен на выявление определённых классов ошибок.
[57:00.940 --> 57:05.940]  Например, адрес санитайзер – это инструмент,
[57:05.940 --> 57:11.940]  который ищет ошибки при обращении к оперативной памяти.
[57:11.940 --> 57:16.940]  То есть представьте, что у вас есть, грубо говоря, адрес,
[57:16.940 --> 57:19.940]  и вы хотите проверить,
[57:19.940 --> 57:22.940]  что могу ли я к этому адресу обращаться или нет.
[57:22.940 --> 57:25.940]  Адрес санитайзер вам на этот вопрос ответит
[57:25.940 --> 57:28.940]  за счёт достаточно простого механизма
[57:28.940 --> 57:32.940]  под названием «теневая память».
[57:32.940 --> 57:35.940]  Читали уже такое «теневая память»?
[57:37.940 --> 57:41.940]  Ну, по крайней мере, на вики написано было у нас.
[57:45.940 --> 57:50.940]  Не читали, но это вроде как какие-то свои аллокаторы делают.
[57:50.940 --> 57:53.940]  Ну, не совсем.
[57:53.940 --> 57:57.940]  То есть идея заключается в следующем.
[57:57.940 --> 58:00.940]  То есть у вас есть основная оперативная память,
[58:00.940 --> 58:02.940]  она же Origin.
[58:02.940 --> 58:05.940]  Но когда вы работаете с обычной оперативной памятью,
[58:05.940 --> 58:10.940]  вам, собственно, есть доступ к вашей памяти,
[58:10.940 --> 58:14.940]  с которой вы непосредственно читаете, пишете,
[58:14.940 --> 58:17.940]  к стеку доступ, к куче доступ,
[58:17.940 --> 58:20.940]  к глобальным переменным доступам и так далее.
[58:22.940 --> 58:26.940]  Мы можем вот эту память
[58:26.940 --> 58:31.940]  отобразить некоторым образом на другую память,
[58:31.940 --> 58:33.940]  так называемую «теневую».
[58:33.940 --> 58:35.940]  Отображение происходит
[58:35.940 --> 58:38.940]  посредством простой арифметической операции,
[58:38.940 --> 58:41.940]  в частности сдвиг и смещения.
[58:41.940 --> 58:44.940]  То есть взяли, грубо говоря, адрес,
[58:44.940 --> 58:46.940]  сдвинули его на три
[58:46.940 --> 58:49.940]  и прибавили некоторое число именуемое
[58:49.940 --> 58:52.940]  на базовым адресом теневой памяти.
[58:52.940 --> 58:55.940]  Получили некоторый другой адрес.
[58:55.940 --> 59:00.940]  И вот мы считаем, что в этой теневой памяти
[59:00.940 --> 59:08.940]  у нас хранится статус доступности памяти Origin.
[59:10.940 --> 59:13.940]  То есть если, например, вот так вот,
[59:13.940 --> 59:15.940]  сформировав адрес тени,
[59:15.940 --> 59:17.940]  мы получим адрес,
[59:17.940 --> 59:20.940]  в котором будет, например, лежать единичка,
[59:20.940 --> 59:23.940]  то это означает, что мы получили адрес,
[59:23.940 --> 59:25.940]  в котором обращаться нельзя.
[59:25.940 --> 59:28.940]  А если мы получили адрес тени,
[59:28.940 --> 59:30.940]  в котором лежит нолик,
[59:30.940 --> 59:33.940]  то это означает, что, соответственно,
[59:33.940 --> 59:35.940]  к этому адресу обращаться можно.
[59:37.940 --> 59:39.940]  Соответственно, задача инструмента
[59:39.940 --> 59:42.940]  заключается в том, чтобы построить
[59:42.940 --> 59:45.940]  вот как раз эту карту адресов
[59:45.940 --> 59:47.940]  в теневой памяти,
[59:47.940 --> 59:50.940]  к которым можно и нельзя обращаться,
[59:50.940 --> 59:53.940]  и поддерживать ее, соответственно,
[59:53.940 --> 59:55.940]  в актуальном состоянии.
[59:55.940 --> 59:57.940]  А также, соответственно,
[59:57.940 --> 01:00:00.940]  при обращении к любому адресу
[01:00:00.940 --> 01:00:02.940]  в вашей программе
[01:00:02.940 --> 01:00:04.940]  организовать проверки,
[01:00:04.940 --> 01:00:08.940]  что вот по соответствующим адресам,
[01:00:08.940 --> 01:00:10.940]  действительно там,
[01:00:10.940 --> 01:00:12.940]  по соответствующим адресам,
[01:00:12.940 --> 01:00:14.940]  теневым адресам,
[01:00:14.940 --> 01:00:16.940]  действительно находятся там нолики.
[01:00:16.940 --> 01:00:18.940]  То есть мы имеем полное право
[01:00:18.940 --> 01:00:21.940]  к этой памяти обращаться.
[01:00:21.940 --> 01:00:23.940]  Понятен механизм?
[01:00:29.940 --> 01:00:30.940]  Ну да.
[01:00:30.940 --> 01:00:32.940]  То есть это по типу как
[01:00:32.940 --> 01:00:34.940]  битва и вектора доступности
[01:00:34.940 --> 01:00:36.940]  всех этих обходов,
[01:00:36.940 --> 01:00:38.940]  DFS, например, где-нибудь.
[01:00:38.940 --> 01:00:39.940]  Ну да.
[01:00:39.940 --> 01:00:41.940]  То есть идея в том, чтобы просто
[01:00:41.940 --> 01:00:44.940]  это запихать, соответственно,
[01:00:44.940 --> 01:00:46.940]  в генерируемый инструмент,
[01:00:46.940 --> 01:00:50.940]  в генерируемый компилятором код
[01:00:50.940 --> 01:00:52.940]  без каких-то внешних программ,
[01:00:52.940 --> 01:00:54.940]  фактически.
[01:00:54.940 --> 01:00:56.940]  Соответственно, например, у вас там есть
[01:00:56.940 --> 01:00:58.940]  глобальная переменная.
[01:00:58.940 --> 01:01:00.940]  Эта глобальная переменная может, например,
[01:01:00.940 --> 01:01:02.940]  быть типа sizeT,
[01:01:02.940 --> 01:01:04.940]  например, занимать 8 байт
[01:01:04.940 --> 01:01:07.940]  на архитектуре Intel x86-64.
[01:01:07.940 --> 01:01:11.940]  Мы берем и отступаем
[01:01:11.940 --> 01:01:14.940]  от этой глобальной переменной
[01:01:14.940 --> 01:01:17.940]  по 8 байт, например, слева и справа.
[01:01:17.940 --> 01:01:19.940]  Тем самым сформируем некоторые
[01:01:19.940 --> 01:01:21.940]  красные зоны,
[01:01:21.940 --> 01:01:23.940]  в попадание в которые, соответственно,
[01:01:23.940 --> 01:01:25.940]  будет у нас считаться ошибкой
[01:01:25.940 --> 01:01:27.940]  доступа к памяти.
[01:01:27.940 --> 01:01:29.940]  Соответственно, в теневой памяти
[01:01:29.940 --> 01:01:31.940]  мы можем взять, например,
[01:01:31.940 --> 01:01:33.940]  по 3 байта.
[01:01:33.940 --> 01:01:35.940]  То есть 3 байта там.
[01:01:35.940 --> 01:01:37.940]  Соответственно, 1 байт
[01:01:37.940 --> 01:01:40.940]  будет полностью забиться единицами
[01:01:40.940 --> 01:01:42.940]  перед этой переменной,
[01:01:42.940 --> 01:01:44.940]  потом следующей забит нулями
[01:01:44.940 --> 01:01:46.940]  и потом опять единицами.
[01:01:46.940 --> 01:01:48.940]  И тем самым, если мы обратимся
[01:01:48.940 --> 01:01:50.940]  по адресу следующему
[01:01:50.940 --> 01:01:52.940]  за этой переменной,
[01:01:52.940 --> 01:01:54.940]  то инструмент сгенерирует ошибку,
[01:01:54.940 --> 01:01:56.940]  а если, соответственно, по адресу перед,
[01:01:56.940 --> 01:01:58.940]  если по адресу этой переменной,
[01:01:58.940 --> 01:02:00.940]  то, соответственно, ошибки не будет.
[01:02:00.940 --> 01:02:02.940]  По
[01:02:02.940 --> 01:02:04.940]  такому же принципу работают,
[01:02:04.940 --> 01:02:06.940]  например, аллокаторы.
[01:02:06.940 --> 01:02:08.940]  То есть, если у вас есть аллокатор
[01:02:08.940 --> 01:02:10.940]  с, например, Free,
[01:02:10.940 --> 01:02:12.940]  то можно
[01:02:12.940 --> 01:02:14.940]  пометить ту память,
[01:02:14.940 --> 01:02:16.940]  которую мы только что освободили,
[01:02:16.940 --> 01:02:18.940]  как Poisoned
[01:02:18.940 --> 01:02:20.940]  и потом, соответственно, стараться
[01:02:20.940 --> 01:02:22.940]  максимально
[01:02:22.940 --> 01:02:24.940]  долго эту память не переиспользовать
[01:02:24.940 --> 01:02:26.940]  под следующей аллокацией.
[01:02:26.940 --> 01:02:28.940]  Тем самым, если мы разуменуем
[01:02:28.940 --> 01:02:30.940]  указатель, который
[01:02:30.940 --> 01:02:32.940]  уже был освобожден,
[01:02:32.940 --> 01:02:34.940]  то, соответственно, инструмент сообщит об ошибке,
[01:02:34.940 --> 01:02:36.940]  что у вас типа User-to-Free.
[01:02:36.940 --> 01:02:38.940]  В зависимости от того,
[01:02:38.940 --> 01:02:40.940]  как организована
[01:02:40.940 --> 01:02:42.940]  там операционная система,
[01:02:42.940 --> 01:02:44.940]  у вас адрес-санитайзер может
[01:02:44.940 --> 01:02:46.940]  работать либо в режиме там черного списка,
[01:02:46.940 --> 01:02:48.940]  либо в режиме
[01:02:48.940 --> 01:02:50.940]  белого списка.
[01:02:50.940 --> 01:02:52.940]  Режим белого списка
[01:02:52.940 --> 01:02:54.940]  означает, что инструмент
[01:02:54.940 --> 01:02:56.940]  знает обо всех адресах, которые
[01:02:56.940 --> 01:02:58.940]  доступны для
[01:02:58.940 --> 01:03:00.940]  обращения
[01:03:00.940 --> 01:03:02.940]  и разрешает
[01:03:02.940 --> 01:03:04.940]  доступ только по ним.
[01:03:04.940 --> 01:03:06.940]  Соответственно, режим
[01:03:06.940 --> 01:03:08.940]  черного списка
[01:03:08.940 --> 01:03:10.940]  работает
[01:03:10.940 --> 01:03:12.940]  в большинстве
[01:03:12.940 --> 01:03:14.940]  операционных систем
[01:03:14.940 --> 01:03:16.940]  общего назначения
[01:03:16.940 --> 01:03:18.940]  в ситуации, когда вы разрешаете доступ
[01:03:18.940 --> 01:03:20.940]  ко всей памяти, за исключением
[01:03:20.940 --> 01:03:22.940]  тех адресов, которые
[01:03:22.940 --> 01:03:24.940]  вы явно пометили как недоступными,
[01:03:24.940 --> 01:03:26.940]  ну, то есть, такими как RedZone,
[01:03:26.940 --> 01:03:28.940]  соответственно, освобожденная память
[01:03:28.940 --> 01:03:30.940]  и так далее.
[01:03:30.940 --> 01:03:32.940]  Понятно, что при добавлении
[01:03:32.940 --> 01:03:34.940]  инструмента в операционную систему
[01:03:34.940 --> 01:03:36.940]  начинать нужно там
[01:03:36.940 --> 01:03:38.940]  чаще всего с режима черного
[01:03:38.940 --> 01:03:40.940]  списка, но
[01:03:40.940 --> 01:03:42.940]  при развитии
[01:03:42.940 --> 01:03:44.940]  операционной системы или программы
[01:03:44.940 --> 01:03:46.940]  можно и
[01:03:46.940 --> 01:03:48.940]  достичь там, например, вполне себе белого списка,
[01:03:48.940 --> 01:03:50.940]  то есть, как в джойсе, например, сделано.
[01:03:50.940 --> 01:03:52.940]  Memory-санитайзер
[01:03:52.940 --> 01:03:54.940]  работает точно
[01:03:54.940 --> 01:03:56.940]  так же, как адрес-санитайзер,
[01:03:56.940 --> 01:03:58.940]  но он
[01:03:58.940 --> 01:04:00.940]  говорит не о том,
[01:04:00.940 --> 01:04:02.940]  какая память доступна,
[01:04:02.940 --> 01:04:04.940]  какая, собственно, недоступна,
[01:04:04.940 --> 01:04:06.940]  а проверяет статус инициализации.
[01:04:06.940 --> 01:04:08.940]  То есть, вот скажите мне
[01:04:08.940 --> 01:04:10.940]  обращение к
[01:04:10.940 --> 01:04:12.940]  неинициализированной памяти
[01:04:12.940 --> 01:04:14.940]  является неопределенным поведением
[01:04:14.940 --> 01:04:16.940]  с точки зрения языка C или C++?
[01:04:16.940 --> 01:04:18.940]  Ну,
[01:04:18.940 --> 01:04:20.940]  если речь идет о глобальной переменной,
[01:04:20.940 --> 01:04:22.940]  то по стандарту не обязана быть
[01:04:22.940 --> 01:04:24.940]  инициализированной в автоматическом времени.
[01:04:24.940 --> 01:04:26.940]  Да, допустим,
[01:04:26.940 --> 01:04:28.940]  соответственно, эта переменная
[01:04:28.940 --> 01:04:30.940]  в куче или на стеке.
[01:04:30.940 --> 01:04:32.940]  Да, это является
[01:04:32.940 --> 01:04:34.940]  по стандарту
[01:04:34.940 --> 01:04:36.940]  неопределенным поведением.
[01:04:36.940 --> 01:04:38.940]  Нет, я с вами не согласен.
[01:04:40.940 --> 01:04:42.940]  Я про неопределенное поведение
[01:04:42.940 --> 01:04:44.940]  отвечал на вопросы там, был про это.
[01:04:44.940 --> 01:04:46.940]  Ну ладно.
[01:04:46.940 --> 01:04:48.940]  Ну, смотрите, не всякое обращение
[01:04:48.940 --> 01:04:50.940]  к неинициализированной памяти
[01:04:50.940 --> 01:04:52.940]  является неопределенным поведением.
[01:04:52.940 --> 01:04:54.940]  Например, если я просто...
[01:04:54.940 --> 01:04:56.940]  А, на ручейне надо опять полнеопределенное вроде, да?
[01:04:56.940 --> 01:04:58.940]  Это тоже,
[01:04:58.940 --> 01:05:00.940]  но я имел в виду чтение.
[01:05:00.940 --> 01:05:02.940]  Например, если вы просто скопируете
[01:05:02.940 --> 01:05:04.940]  неинициализированную память
[01:05:04.940 --> 01:05:06.940]  в другую там память,
[01:05:06.940 --> 01:05:08.940]  это не является неопределенным поведением.
[01:05:10.940 --> 01:05:12.940]  У вас там может быть паддинг
[01:05:12.940 --> 01:05:14.940]  какой-нибудь неинициализированной,
[01:05:14.940 --> 01:05:16.940]  или просто неинициализированная еще переменная.
[01:05:16.940 --> 01:05:18.940]  Проблемы
[01:05:18.940 --> 01:05:20.940]  возникают, когда вы, например,
[01:05:20.940 --> 01:05:22.940]  начинаете витвиться
[01:05:22.940 --> 01:05:24.940]  по значению
[01:05:24.940 --> 01:05:26.940]  вот этой вот, собственно,
[01:05:26.940 --> 01:05:28.940]  неинициализированной переменной.
[01:05:28.940 --> 01:05:30.940]  Или когда вы пытаетесь, например, перейти
[01:05:30.940 --> 01:05:32.940]  по указателю, который неинициализирован.
[01:05:32.940 --> 01:05:34.940]  Или когда вы, например,
[01:05:34.940 --> 01:05:36.940]  начинаете передавать
[01:05:36.940 --> 01:05:38.940]  значение неинициализированной памяти
[01:05:38.940 --> 01:05:40.940]  в системные вызовы.
[01:05:42.940 --> 01:05:44.940]  То есть вот проблемы начинаются здесь.
[01:05:44.940 --> 01:05:46.940]  А просто там
[01:05:46.940 --> 01:05:48.940]  скопировать память это совершенно нормально.
[01:05:50.940 --> 01:05:52.940]  Нормально, потому что у вас может быть, например,
[01:05:52.940 --> 01:05:54.940]  часть байт в буфере неинициализированной.
[01:05:54.940 --> 01:05:56.940]  Представьте, что у вас там, например,
[01:05:56.940 --> 01:05:58.940]  256 байт
[01:05:58.940 --> 01:06:00.940]  используется, например,
[01:06:00.940 --> 01:06:02.940]  для строки с названием. У вас
[01:06:02.940 --> 01:06:04.940]  строка заполнена в первые 16,
[01:06:04.940 --> 01:06:06.940]  а, соответственно, 17
[01:06:06.940 --> 01:06:08.940]  нулевой.
[01:06:08.940 --> 01:06:10.940]  И вы, соответственно, mem.spy
[01:06:10.940 --> 01:06:12.940]  копируете все 256 байт.
[01:06:12.940 --> 01:06:14.940]  Это поведение вполне себе
[01:06:14.940 --> 01:06:16.940]  определено, оно вполне нормальное.
[01:06:18.940 --> 01:06:20.940]  Поэтому Memory Sanitizer
[01:06:20.940 --> 01:06:22.940]  как инструмент
[01:06:22.940 --> 01:06:24.940]  он проверяет
[01:06:24.940 --> 01:06:26.940]  статусы
[01:06:26.940 --> 01:06:28.940]  инициализации памяти
[01:06:28.940 --> 01:06:30.940]  именно в тех случаях,
[01:06:30.940 --> 01:06:32.940]  когда обращение к ней является
[01:06:32.940 --> 01:06:34.940]  неопределенным поведением.
[01:06:34.940 --> 01:06:36.940]  Например, ветвление в программе.
[01:06:36.940 --> 01:06:38.940]  И кроме этого, он также
[01:06:38.940 --> 01:06:40.940]  имеет функцию пропагейта.
[01:06:40.940 --> 01:06:42.940]  То есть когда вы,
[01:06:42.940 --> 01:06:44.940]  например, копируете
[01:06:44.940 --> 01:06:46.940]  неинициализированную память
[01:06:46.940 --> 01:06:48.940]  в какой-то участок
[01:06:48.940 --> 01:06:50.940]  в программе, то у вас также
[01:06:50.940 --> 01:06:52.940]  обновляется теневая память
[01:06:52.940 --> 01:06:54.940]  нового участка,
[01:06:54.940 --> 01:06:56.940]  ну, то есть,
[01:06:56.940 --> 01:06:58.940]  куда вы скопировали,
[01:06:58.940 --> 01:07:00.940]  сохраняя, соответственно, статус
[01:07:00.940 --> 01:07:02.940]  неинициализированной памяти
[01:07:02.940 --> 01:07:04.940]  от той, из которой вы изначально
[01:07:04.940 --> 01:07:06.940]  копируете.
[01:07:06.940 --> 01:07:08.940]  Кроме этого,
[01:07:08.940 --> 01:07:10.940]  существует
[01:07:10.940 --> 01:07:12.940]  такой инструмент, как
[01:07:12.940 --> 01:07:14.940]  Undefined Behavior Sanitizer.
[01:07:14.940 --> 01:07:16.940]  Он у вас также есть в джосе
[01:07:16.940 --> 01:07:18.940]  и в его задачи, соответственно,
[01:07:18.940 --> 01:07:20.940]  входит поиск неопределенного поведения,
[01:07:20.940 --> 01:07:22.940]  например, за сдвиговыми операциями,
[01:07:22.940 --> 01:07:24.940]  с операциями с плавающей
[01:07:24.940 --> 01:07:26.940]  точкой,
[01:07:26.940 --> 01:07:28.940]  с операциями
[01:07:28.940 --> 01:07:30.940]  арифметики,
[01:07:30.940 --> 01:07:32.940]  деления на ноль
[01:07:32.940 --> 01:07:34.940]  и так далее.
[01:07:34.940 --> 01:07:36.940]  Соответственно, он наиболее
[01:07:36.940 --> 01:07:38.940]  простой
[01:07:38.940 --> 01:07:40.940]  из тех, которые
[01:07:40.940 --> 01:07:42.940]  можно поддержать
[01:07:42.940 --> 01:07:44.940]  в операционной системе,
[01:07:44.940 --> 01:07:46.940]  потому что он не требует
[01:07:46.940 --> 01:07:48.940]  теневой памяти,
[01:07:48.940 --> 01:07:50.940]  но при этом достаточно
[01:07:50.940 --> 01:07:52.940]  полезный, например,
[01:07:52.940 --> 01:07:54.940]  он также еще позволяет определить
[01:07:54.940 --> 01:07:56.940]  обращения по невыровненным указателям,
[01:07:56.940 --> 01:07:58.940]  которые в
[01:07:58.940 --> 01:08:00.940]  ином случае были бы
[01:08:00.940 --> 01:08:02.940]  не обнаружены, потому что
[01:08:02.940 --> 01:08:04.940]  далеко не все процессоры
[01:08:04.940 --> 01:08:06.940]  могут обнаруживать
[01:08:06.940 --> 01:08:08.940]  даже, не говоря
[01:08:08.940 --> 01:08:10.940]  про то, что не поддерживают
[01:08:10.940 --> 01:08:12.940]  обращения к
[01:08:12.940 --> 01:08:14.940]  невыровненным указателям,
[01:08:14.940 --> 01:08:16.940]  хотя такие процессоры есть
[01:08:16.940 --> 01:08:18.940]  и, соответственно, отлаживать ваш код
[01:08:18.940 --> 01:08:20.940]  без undefinedBehaviourSanitizer
[01:08:20.940 --> 01:08:22.940]  на предмет невыровненных указателей
[01:08:22.940 --> 01:08:24.940]  не то, чтобы тревя.
[01:08:24.940 --> 01:08:26.940]  Есть также
[01:08:26.940 --> 01:08:28.940]  такие инструменты,
[01:08:28.940 --> 01:08:30.940]  как ThreadSanitizer,
[01:08:30.940 --> 01:08:32.940]  который позволяет находить
[01:08:32.940 --> 01:08:34.940]  гонки, то есть, когда вы пытаетесь
[01:08:34.940 --> 01:08:36.940]  обратиться к данным
[01:08:36.940 --> 01:08:38.940]  из двух потоков
[01:08:38.940 --> 01:08:40.940]  и не обеспечиваете при этом
[01:08:40.940 --> 01:08:42.940]  экстранизацию.
[01:08:42.940 --> 01:08:44.940]  LeakSanitizer, позволяющий
[01:08:44.940 --> 01:08:46.940]  найти утечки
[01:08:46.940 --> 01:08:48.940]  оперативной памяти
[01:08:48.940 --> 01:08:50.940]  при использовании
[01:08:50.940 --> 01:08:52.940]  кучи.
[01:08:52.940 --> 01:08:54.940]  SafeStack, то есть, скажем так,
[01:08:54.940 --> 01:08:56.940]  минифицированная версия
[01:08:56.940 --> 01:08:58.940]  адрес санитайзера,
[01:08:58.940 --> 01:09:00.940]  проверяющая, соответственно,
[01:09:00.940 --> 01:09:02.940]  на переполнение
[01:09:04.940 --> 01:09:06.940]  данных на стэки и, соответственно,
[01:09:06.940 --> 01:09:08.940]  предвращающий эксплуатацию
[01:09:08.940 --> 01:09:10.940]  некоторых уязвимостей,
[01:09:10.940 --> 01:09:12.940]  собственно, несколько
[01:09:12.940 --> 01:09:14.940]  выбивающихся из всех этих инструментов,
[01:09:14.940 --> 01:09:16.940]  потому что, в первую очередь,
[01:09:16.940 --> 01:09:18.940]  эти инструменты предназначены для работы
[01:09:18.940 --> 01:09:20.940]  в отладочном режиме
[01:09:20.940 --> 01:09:22.940]  программы, когда же SafeStack
[01:09:22.940 --> 01:09:24.940]  предназначен
[01:09:24.940 --> 01:09:26.940]  для использования в боевом режиме.
[01:09:26.940 --> 01:09:28.940]  EfficientSanitizer,
[01:09:28.940 --> 01:09:30.940]  то есть, инструмент, который
[01:09:30.940 --> 01:09:32.940]  ищет использование
[01:09:32.940 --> 01:09:34.940]  не очень удачных
[01:09:34.940 --> 01:09:36.940]  конструкций
[01:09:36.940 --> 01:09:38.940]  в вашем коде, который можно было бы
[01:09:38.940 --> 01:09:40.940]  переписать иным способом
[01:09:40.940 --> 01:09:42.940]  для повышения прообразовательности
[01:09:42.940 --> 01:09:44.940]  вашей программы.
[01:09:44.940 --> 01:09:46.940]  Липфазер, то есть, фазер,
[01:09:46.940 --> 01:09:48.940]  который используется
[01:09:48.940 --> 01:09:50.940]  в связке со всеми
[01:09:50.940 --> 01:09:52.940]  инструментами для
[01:09:52.940 --> 01:09:54.940]  построения некоторых входных
[01:09:54.940 --> 01:09:56.940]  данных, которые
[01:09:56.940 --> 01:09:58.940]  бы позволили вам
[01:09:58.940 --> 01:10:00.940]  находить ошибки
[01:10:00.940 --> 01:10:02.940]  в вашей программе, говорим чуть позже.
[01:10:02.940 --> 01:10:04.940]  Как вообще
[01:10:04.940 --> 01:10:06.940]  реализовать
[01:10:06.940 --> 01:10:08.940]  Sanitizer
[01:10:08.940 --> 01:10:10.940]  в операционной системе?
[01:10:10.940 --> 01:10:12.940]  Здесь есть
[01:10:12.940 --> 01:10:14.940]  некоторая тройка.
[01:10:14.940 --> 01:10:16.940]  То есть, первая часть
[01:10:16.940 --> 01:10:18.940]  это кодогенерация.
[01:10:18.940 --> 01:10:20.940]  То есть, ваш компилятор
[01:10:20.940 --> 01:10:22.940]  должен поддерживать
[01:10:22.940 --> 01:10:24.940]  генерацию
[01:10:24.940 --> 01:10:26.940]  инструментированного кода, который
[01:10:26.940 --> 01:10:28.940]  будет лезть, например, в теневую память,
[01:10:28.940 --> 01:10:30.940]  который будет вставлять
[01:10:30.940 --> 01:10:32.940]  проверки на деление
[01:10:32.940 --> 01:10:34.940]  на ноль, например,
[01:10:34.940 --> 01:10:36.940]  или на неправильную работу
[01:10:36.940 --> 01:10:38.940]  с издигами.
[01:10:38.940 --> 01:10:40.940]  Второй момент
[01:10:40.940 --> 01:10:42.940]  это поддержка
[01:10:42.940 --> 01:10:44.940]  на уровне следы
[01:10:44.940 --> 01:10:46.940]  выполнения, то есть, на уровне рантайма.
[01:10:46.940 --> 01:10:48.940]  Здесь можно
[01:10:48.940 --> 01:10:50.940]  пойти несколькими
[01:10:50.940 --> 01:10:52.940]  путями. Например,
[01:10:52.940 --> 01:10:54.940]  в LLVM есть
[01:10:54.940 --> 01:10:56.940]  библиотечка CompilerRT,
[01:10:56.940 --> 01:10:58.940]  она же библиотечка built-in,
[01:10:58.940 --> 01:11:00.940]  предоставляющая
[01:11:00.940 --> 01:11:02.940]  сервисы
[01:11:02.940 --> 01:11:04.940]  для работы
[01:11:04.940 --> 01:11:06.940]  скомпилированных
[01:11:06.940 --> 01:11:08.940]  с помощью LLVM Clang
[01:11:08.940 --> 01:11:10.940]  программ,
[01:11:10.940 --> 01:11:12.940]  типа программного деления
[01:11:12.940 --> 01:11:14.940]  и так далее.
[01:11:14.940 --> 01:11:16.940]  Она, соответственно, также предоставляет
[01:11:16.940 --> 01:11:18.940]  и рантайм для работы
[01:11:18.940 --> 01:11:20.940]  Sanitizer, основной задачей
[01:11:20.940 --> 01:11:22.940]  которого это вывод
[01:11:22.940 --> 01:11:24.940]  человека понятных
[01:11:24.940 --> 01:11:26.940]  ошибок и инициализация
[01:11:26.940 --> 01:11:28.940]  инструмента
[01:11:28.940 --> 01:11:30.940]  на конкретной
[01:11:30.940 --> 01:11:32.940]  операционной системе.
[01:11:32.940 --> 01:11:34.940]  Можно пойти
[01:11:34.940 --> 01:11:36.940]  другим путем
[01:11:36.940 --> 01:11:38.940]  и реализовать
[01:11:38.940 --> 01:11:40.940]  для операционной системы,
[01:11:40.940 --> 01:11:42.940]  например, для ядра Linux
[01:11:42.940 --> 01:11:44.940]  или для ядра Mac
[01:11:44.940 --> 01:11:46.940]  некоторый свой рантайм специфичный
[01:11:46.940 --> 01:11:48.940]  для данной
[01:11:48.940 --> 01:11:50.940]  операционной системы.
[01:11:50.940 --> 01:11:52.940]  Например,
[01:11:52.940 --> 01:11:54.940]  в JOS
[01:11:54.940 --> 01:11:56.940]  используется
[01:11:56.940 --> 01:11:58.940]  некоторый гибрид
[01:11:58.940 --> 01:12:00.940]  для поддержки адрес Sanitizer
[01:12:00.940 --> 01:12:02.940]  и undefined behavior Sanitizer
[01:12:02.940 --> 01:12:04.940]  из BSD системы,
[01:12:04.940 --> 01:12:06.940]  в частности, из Mac
[01:12:06.940 --> 01:12:08.940]  и из NetBSD
[01:12:08.940 --> 01:12:10.940]  используется адаптированный рантайм.
[01:12:10.940 --> 01:12:12.940]  И, соответственно,
[01:12:12.940 --> 01:12:14.940]  третий момент
[01:12:14.940 --> 01:12:16.940]  это добавление
[01:12:16.940 --> 01:12:18.940]  поддержки на уровне исходного кода
[01:12:18.940 --> 01:12:20.940]  в вашего
[01:12:20.940 --> 01:12:22.940]  конкретного взятого
[01:12:22.940 --> 01:12:24.940]  проекта,
[01:12:24.940 --> 01:12:26.940]  потому что
[01:12:26.940 --> 01:12:28.940]  когда вы инициализируете, например,
[01:12:28.940 --> 01:12:30.940]  пользовательскую программу,
[01:12:30.940 --> 01:12:32.940]  в целом можно подстроить
[01:12:32.940 --> 01:12:34.940]  инициализацию операционной системы
[01:12:34.940 --> 01:12:36.940]  так, чтобы
[01:12:36.940 --> 01:12:38.940]  Sanitizer можно было
[01:12:38.940 --> 01:12:40.940]  использовать сразу же.
[01:12:40.940 --> 01:12:42.940]  Однако, если речь идет
[01:12:42.940 --> 01:12:44.940]  о санитайзинге
[01:12:44.940 --> 01:12:46.940]  прелегированного кода,
[01:12:46.940 --> 01:12:48.940]  то есть кодом является ядро
[01:12:48.940 --> 01:12:50.940]  операционной системы,
[01:12:50.940 --> 01:12:52.940]  в самом начале
[01:12:52.940 --> 01:12:54.940]  у вас может не быть
[01:12:54.940 --> 01:12:56.940]  таких базовых вещей, как
[01:12:56.940 --> 01:12:58.940]  аллокатора, возможности отображать
[01:12:58.940 --> 01:13:00.940]  какую-то оперативную память,
[01:13:00.940 --> 01:13:02.940]  у вас
[01:13:02.940 --> 01:13:04.940]  вообще может не быть
[01:13:04.940 --> 01:13:06.940]  даже принтфа условно
[01:13:06.940 --> 01:13:08.940]  для того, чтобы вывести какую-то информацию
[01:13:08.940 --> 01:13:10.940]  на экран
[01:13:10.940 --> 01:13:12.940]  или в serial port.
[01:13:12.940 --> 01:13:14.940]  Поэтому
[01:13:14.940 --> 01:13:16.940]  операционная система обычно делится,
[01:13:16.940 --> 01:13:18.940]  так сказать, на две стадии.
[01:13:18.940 --> 01:13:21.940]  Стадия до инициализации инструмента
[01:13:21.940 --> 01:13:23.940]  и стадия после
[01:13:23.940 --> 01:13:25.940]  инициализации инструмента.
[01:13:25.940 --> 01:13:27.940]  И, соответственно, нужно
[01:13:27.940 --> 01:13:29.940]  во-первых
[01:13:29.940 --> 01:13:31.940]  подправить систему сборки,
[01:13:31.940 --> 01:13:33.940]  чтобы код,
[01:13:33.940 --> 01:13:35.940]  выполняющийся на начальном
[01:13:35.940 --> 01:13:37.940]  стадии инициализации, не выполнялся
[01:13:37.940 --> 01:13:39.940]  под
[01:13:39.940 --> 01:13:41.940]  санитайзером,
[01:13:41.940 --> 01:13:43.940]  если речь идет о санитайзере Halloween.
[01:13:43.940 --> 01:13:45.940]  И, соответственно, подправить сам код
[01:13:45.940 --> 01:13:47.940]  таким образом, чтобы
[01:13:47.940 --> 01:13:49.940]  санитайзер инициализировался
[01:13:49.940 --> 01:13:51.940]  максимально рано.
[01:13:51.940 --> 01:13:53.940]  При этом
[01:13:53.940 --> 01:13:55.940]  также могут быть полезные
[01:13:55.940 --> 01:13:57.940]  аннотации
[01:13:57.940 --> 01:13:59.940]  для отдельных функций
[01:13:59.940 --> 01:14:01.940]  и отдельных инструментов.
[01:14:01.940 --> 01:14:03.940]  Например,
[01:14:03.940 --> 01:14:05.940]  мы этим достаточно регулярно
[01:14:05.940 --> 01:14:07.940]  пользуемся, мы аннотируем
[01:14:07.940 --> 01:14:09.940]  системные вызовы
[01:14:09.940 --> 01:14:11.940]  в операционные системы
[01:14:11.940 --> 01:14:13.940]  для того, чтобы
[01:14:13.940 --> 01:14:15.940]  поймать
[01:14:15.940 --> 01:14:17.940]  неправомерное
[01:14:17.940 --> 01:14:19.940]  использование этих
[01:14:19.940 --> 01:14:21.940]  системных вызовов
[01:14:21.940 --> 01:14:23.940]  с какими-то некорректными данными
[01:14:23.940 --> 01:14:25.940]  на более ранних этапах
[01:14:25.940 --> 01:14:27.940]  и
[01:14:27.940 --> 01:14:29.940]  тем самым пользователи
[01:14:29.940 --> 01:14:31.940]  об этом сообщить
[01:14:31.940 --> 01:14:33.940]  в более понятном виде.
[01:14:35.940 --> 01:14:37.940]  Соответственно,
[01:14:37.940 --> 01:14:39.940]  если говорить
[01:14:39.940 --> 01:14:41.940]  об использовании
[01:14:41.940 --> 01:14:43.940]  инструментов, то вот есть
[01:14:43.940 --> 01:14:45.940]  некоторая такая карта.
[01:14:45.940 --> 01:14:47.940]  У вас в
[01:14:47.940 --> 01:14:49.940]  джосе реализованы
[01:14:49.940 --> 01:14:51.940]  первые два.
[01:14:51.940 --> 01:14:53.940]  Убесан и
[01:14:53.940 --> 01:14:55.940]  асан у вас сейчас
[01:14:55.940 --> 01:14:57.940]  появились как в пользовательском адресном
[01:14:57.940 --> 01:14:59.940]  пространстве, так и
[01:14:59.940 --> 01:15:01.940]  в юзерском.
[01:15:01.940 --> 01:15:03.940]  О механизмах их работы
[01:15:03.940 --> 01:15:05.940]  можно почитать у нас на вики,
[01:15:05.940 --> 01:15:07.940]  можно почитать
[01:15:07.940 --> 01:15:09.940]  на страничке Google санитайзер.
[01:15:09.940 --> 01:15:11.940]  Там же, соответственно, есть
[01:15:11.940 --> 01:15:13.940]  пейперы, которые описывают
[01:15:13.940 --> 01:15:15.940]  такие вещи,
[01:15:15.940 --> 01:15:17.940]  как безопасный stack
[01:15:17.940 --> 01:15:19.940]  при использовании
[01:15:19.940 --> 01:15:21.940]  санитайзеров.
[01:15:21.940 --> 01:15:23.940]  Что касается
[01:15:23.940 --> 01:15:25.940]  memory санитайзера и thread санитайзера,
[01:15:25.940 --> 01:15:27.940]  то это
[01:15:27.940 --> 01:15:29.940]  индивидуальные задания,
[01:15:29.940 --> 01:15:31.940]  можно их взять
[01:15:31.940 --> 01:15:33.940]  и реализовать
[01:15:33.940 --> 01:15:35.940]  в джосе
[01:15:35.940 --> 01:15:37.940]  их поддержку
[01:15:37.940 --> 01:15:39.940]  в индивидуальном порядке.
[01:15:43.940 --> 01:15:45.940]  В двух словах,
[01:15:45.940 --> 01:15:47.940]  чем должен заниматься thread санитайзер?
[01:15:47.940 --> 01:15:49.940]  Смотреть, что пользовательский процесс
[01:15:49.940 --> 01:15:51.940]  отдает thread?
[01:15:51.940 --> 01:15:53.940]  Если
[01:15:53.940 --> 01:15:55.940]  очень вкратце,
[01:15:55.940 --> 01:15:57.940]  то у вас, грубо говоря,
[01:15:57.940 --> 01:15:59.940]  есть такое понятие, условно,
[01:15:59.940 --> 01:16:01.940]  happens before, happens after.
[01:16:01.940 --> 01:16:03.940]  И thread санитайзер
[01:16:03.940 --> 01:16:05.940]  проверяет
[01:16:05.940 --> 01:16:07.940]  фактически, что
[01:16:07.940 --> 01:16:09.940]  не было
[01:16:09.940 --> 01:16:11.940]  обращений
[01:16:11.940 --> 01:16:13.940]  к отдельному участку
[01:16:13.940 --> 01:16:15.940]  памяти
[01:16:15.940 --> 01:16:17.940]  из
[01:16:17.940 --> 01:16:19.940]  параллельного потока
[01:16:19.940 --> 01:16:21.940]  в конкретный момент
[01:16:21.940 --> 01:16:23.940]  времени.
[01:16:23.940 --> 01:16:25.940]  Если по существу,
[01:16:25.940 --> 01:16:27.940]  то
[01:16:27.940 --> 01:16:29.940]  thread санитайзер работает
[01:16:29.940 --> 01:16:31.940]  наиболее хорошо, когда у вас
[01:16:31.940 --> 01:16:33.940]  большое количество ядер.
[01:16:33.940 --> 01:16:35.940]  В отличие от
[01:16:35.940 --> 01:16:37.940]  убесана, асана и эмсана,
[01:16:37.940 --> 01:16:39.940]  которые гарантированно находят ошибку,
[01:16:39.940 --> 01:16:41.940]  если она есть,
[01:16:41.940 --> 01:16:43.940]  и если, соответственно, код через нее пройдет,
[01:16:43.940 --> 01:16:45.940]  то thread сан имеет
[01:16:45.940 --> 01:16:47.940]  достаточно
[01:16:47.940 --> 01:16:49.940]  предикативный
[01:16:49.940 --> 01:16:51.940]  механизм работы,
[01:16:51.940 --> 01:16:53.940]  когда
[01:16:53.940 --> 01:16:55.940]  вы узнаете о проблеме,
[01:16:55.940 --> 01:16:57.940]  например, если у вас программа работает
[01:16:57.940 --> 01:16:59.940]  на четырех физических ядрах,
[01:16:59.940 --> 01:17:01.940]  а если на двух физических ядрах,
[01:17:01.940 --> 01:17:03.940]  то, возможно, вы и не увидите проблемы.
[01:17:09.940 --> 01:17:11.940]  Что касается файзинга,
[01:17:11.940 --> 01:17:13.940]  то
[01:17:13.940 --> 01:17:15.940]  файзинг на самом деле является
[01:17:15.940 --> 01:17:17.940]  некоторым развитием
[01:17:17.940 --> 01:17:19.940]  динамического инструментирования,
[01:17:19.940 --> 01:17:21.940]  связанный
[01:17:21.940 --> 01:17:23.940]  с тем, что
[01:17:23.940 --> 01:17:25.940]  когда мы
[01:17:25.940 --> 01:17:27.940]  сделали нашу программу наиболее
[01:17:27.940 --> 01:17:29.940]  восприимчивой к тому, чтобы тайна
[01:17:29.940 --> 01:17:31.940]  становилась явным,
[01:17:31.940 --> 01:17:33.940]  то есть мы
[01:17:33.940 --> 01:17:35.940]  переделали нашу программу,
[01:17:35.940 --> 01:17:37.940]  таким образом, что в ней
[01:17:37.940 --> 01:17:39.940]  появилось больше инвариантов
[01:17:39.940 --> 01:17:41.940]  и, соответственно,
[01:17:41.940 --> 01:17:43.940]  в больших случаях программа может
[01:17:43.940 --> 01:17:45.940]  сообщить о том, что что-то произошло не так,
[01:17:45.940 --> 01:17:47.940]  мы ее
[01:17:47.940 --> 01:17:49.940]  автоматически хотим
[01:17:49.940 --> 01:17:51.940]  также иметь возможность
[01:17:51.940 --> 01:17:53.940]  воспроизвести эти ситуации,
[01:17:53.940 --> 01:17:55.940]  потому что, в отличие
[01:17:55.940 --> 01:17:57.940]  от статического анализа, который
[01:17:57.940 --> 01:17:59.940]  происходит с программой без ее запуска,
[01:17:59.940 --> 01:18:01.940]  динамический анализ
[01:18:01.940 --> 01:18:03.940]  имеет одну большую слабость.
[01:18:03.940 --> 01:18:05.940]  Чтобы выявить какую-то
[01:18:05.940 --> 01:18:07.940]  проблему,
[01:18:07.940 --> 01:18:09.940]  вам необходимо действительно
[01:18:09.940 --> 01:18:11.940]  эту проблему
[01:18:11.940 --> 01:18:13.940]  выполнить в самой программе,
[01:18:13.940 --> 01:18:15.940]  то есть фактически
[01:18:15.940 --> 01:18:17.940]  нужно, чтобы программа
[01:18:17.940 --> 01:18:19.940]  прошла по конкретному пути
[01:18:19.940 --> 01:18:21.940]  возникновения этой проблемы,
[01:18:23.940 --> 01:18:25.940]  при этом там данные, которые
[01:18:25.940 --> 01:18:27.940]  при этом порождаются,
[01:18:27.940 --> 01:18:29.940]  действительно должны вызывать
[01:18:29.940 --> 01:18:31.940]  так называемое
[01:18:31.940 --> 01:18:33.940]  интересное поведение программы.
[01:18:33.940 --> 01:18:35.940]  Термин
[01:18:35.940 --> 01:18:37.940]  из файзинга
[01:18:37.940 --> 01:18:39.940]  интересное поведение
[01:18:39.940 --> 01:18:41.940]  программы может быть как условно краж
[01:18:41.940 --> 01:18:43.940]  этой программы,
[01:18:43.940 --> 01:18:45.940]  так срабатывание инструмента,
[01:18:45.940 --> 01:18:47.940]  так и, например, зависание программы
[01:18:47.940 --> 01:18:49.940]  или просто какое-то
[01:18:49.940 --> 01:18:51.940]  неожиданное ее поведение,
[01:18:51.940 --> 01:18:53.940]  неожиданный ответ.
[01:18:53.940 --> 01:18:55.940]  Интересное поведение программы
[01:18:55.940 --> 01:18:57.940]  может по-разному фиксироваться,
[01:18:57.940 --> 01:18:59.940]  то есть наиболее простой способ
[01:18:59.940 --> 01:19:01.940]  это действительно просто фиксировать краши.
[01:19:01.940 --> 01:19:03.940]  Но в случае,
[01:19:03.940 --> 01:19:05.940]  например, какого-нибудь
[01:19:05.940 --> 01:19:07.940]  Model Checking,
[01:19:07.940 --> 01:19:09.940]  то можно определить, что интересное поведение
[01:19:09.940 --> 01:19:11.940]  программы – это выдача
[01:19:11.940 --> 01:19:13.940]  какого-либо кода ответа
[01:19:13.940 --> 01:19:15.940]  за исключением
[01:19:15.940 --> 01:19:17.940]  вот такого-то, такого-то и такого-то.
[01:19:17.940 --> 01:19:19.940]  То есть программа может и не упала,
[01:19:19.940 --> 01:19:21.940]  но вернула что-то неожиданное.
[01:19:21.940 --> 01:19:23.940]  Соответственно, сам по себе
[01:19:23.940 --> 01:19:25.940]  фазинг
[01:19:25.940 --> 01:19:27.940]  заключается в том,
[01:19:27.940 --> 01:19:29.940]  что мы можем генерировать
[01:19:29.940 --> 01:19:31.940]  некоторые
[01:19:31.940 --> 01:19:33.940]  псевдослучайные входные данные
[01:19:35.940 --> 01:19:37.940]  собственно
[01:19:37.940 --> 01:19:39.940]  с самой целью
[01:19:39.940 --> 01:19:41.940]  вызвать вот это интересное поведение.
[01:19:41.940 --> 01:19:43.940]  То есть
[01:19:43.940 --> 01:19:45.940]  генерация
[01:19:45.940 --> 01:19:47.940]  она может осуществляться
[01:19:47.940 --> 01:19:49.940]  разным способом,
[01:19:49.940 --> 01:19:51.940]  и в этом как раз лежит классификация фазингов.
[01:19:51.940 --> 01:19:53.940]  То есть, например,
[01:19:53.940 --> 01:19:55.940]  бывает фазинг
[01:19:55.940 --> 01:19:57.940]  генерационный.
[01:19:57.940 --> 01:19:59.940]  Генерационный фазинг, или фазинг,
[01:19:59.940 --> 01:20:01.940]  часто еще его называют фазинг по грамматикам
[01:20:01.940 --> 01:20:03.940]  выполняется тогда, когда у вас есть
[01:20:03.940 --> 01:20:05.940]  некоторый
[01:20:05.940 --> 01:20:07.940]  известный
[01:20:07.940 --> 01:20:09.940]  фактически
[01:20:09.940 --> 01:20:11.940]  формат, грубо говоря, данных.
[01:20:11.940 --> 01:20:13.940]  Например, сказано, что у вас
[01:20:13.940 --> 01:20:15.940]  есть
[01:20:15.940 --> 01:20:17.940]  картинка с таким-то
[01:20:17.940 --> 01:20:19.940]  заголовком.
[01:20:19.940 --> 01:20:21.940]  И, соответственно, фазер
[01:20:21.940 --> 01:20:23.940]  будет порождать
[01:20:23.940 --> 01:20:25.940]  только картинки,
[01:20:25.940 --> 01:20:27.940]  даже не только картинки,
[01:20:27.940 --> 01:20:29.940]  а только данные,
[01:20:29.940 --> 01:20:31.940]  которые будут содержать некоторые
[01:20:31.940 --> 01:20:33.940]  из заголовок, и тем самым
[01:20:33.940 --> 01:20:35.940]  соответственно сможет пройти
[01:20:35.940 --> 01:20:37.940]  часть проверок
[01:20:37.940 --> 01:20:39.940]  в программе, которые отсекают
[01:20:39.940 --> 01:20:41.940]  данные,
[01:20:43.940 --> 01:20:45.940]  то есть отсекают некорректные
[01:20:45.940 --> 01:20:47.940]  входные данные, позволяет
[01:20:47.940 --> 01:20:49.940]  войти
[01:20:49.940 --> 01:20:51.940]  в более интересные места в программе.
[01:20:51.940 --> 01:20:53.940]  Вариант второй
[01:20:53.940 --> 01:20:55.940]  это, например, мутационный фазинг,
[01:20:55.940 --> 01:20:57.940]  то есть тогда, когда у вас есть
[01:20:57.940 --> 01:20:59.940]  некоторый корпус данных,
[01:20:59.940 --> 01:21:01.940]  например,
[01:21:01.940 --> 01:21:03.940]  вот эти самые картинки,
[01:21:03.940 --> 01:21:05.940]  и вы просто псевдослучайным образом
[01:21:05.940 --> 01:21:07.940]  меняете
[01:21:07.940 --> 01:21:09.940]  определенные последовательности байт
[01:21:09.940 --> 01:21:11.940]  на другие и проверяете,
[01:21:11.940 --> 01:21:13.940]  как на них будет реагировать
[01:21:13.940 --> 01:21:15.940]  ваша программа.
[01:21:15.940 --> 01:21:17.940]  Можно все это смешивать
[01:21:17.940 --> 01:21:19.940]  и получится,
[01:21:19.940 --> 01:21:21.940]  например, эволюционирующий
[01:21:21.940 --> 01:21:23.940]  фазинг, тогда,
[01:21:23.940 --> 01:21:25.940]  когда у вас
[01:21:25.940 --> 01:21:27.940]  поведение
[01:21:27.940 --> 01:21:29.940]  программы,
[01:21:29.940 --> 01:21:31.940]  например, сбор покрытия
[01:21:31.940 --> 01:21:33.940]  говорит о том, что
[01:21:33.940 --> 01:21:35.940]  соответственно
[01:21:35.940 --> 01:21:37.940]  по прогону
[01:21:37.940 --> 01:21:39.940]  получившегося
[01:21:39.940 --> 01:21:41.940]  объекта входных данных
[01:21:41.940 --> 01:21:43.940]  у вас улучшилось покрытие
[01:21:43.940 --> 01:21:45.940]  в
[01:21:45.940 --> 01:21:47.940]  вашей программе.
[01:21:47.940 --> 01:21:49.940]  Соответственно, значит, что
[01:21:49.940 --> 01:21:51.940]  нужно пробовать мутировать,
[01:21:51.940 --> 01:21:53.940]  например, этот новый вариант,
[01:21:53.940 --> 01:21:55.940]  и, возможно, он позволит пойти
[01:21:55.940 --> 01:21:57.940]  в еще более новые места.
[01:21:57.940 --> 01:21:59.940]  Соответственно, вот как раз
[01:21:59.940 --> 01:22:01.940]  липфайзер это пример
[01:22:01.940 --> 01:22:03.940]  мутационного эволюционирующего
[01:22:03.940 --> 01:22:05.940]  файзера.
[01:22:05.940 --> 01:22:07.940]  При этом файзеры
[01:22:07.940 --> 01:22:09.940]  работать могут бесконечно
[01:22:09.940 --> 01:22:11.940]  долго.
[01:22:11.940 --> 01:22:13.940]  И, скажем так,
[01:22:13.940 --> 01:22:15.940]  идея
[01:22:15.940 --> 01:22:17.940]  фазинга, она заключается
[01:22:17.940 --> 01:22:19.940]  в том, что вы, например, выпустили
[01:22:19.940 --> 01:22:21.940]  некоторый программный продукт,
[01:22:21.940 --> 01:22:23.940]  и после
[01:22:23.940 --> 01:22:25.940]  этого ваш продукт
[01:22:25.940 --> 01:22:27.940]  бесконечно долго фазится,
[01:22:27.940 --> 01:22:29.940]  и когда, соответственно, он
[01:22:29.940 --> 01:22:31.940]  находит, например, какое-нибудь падение,
[01:22:31.940 --> 01:22:33.940]  то вполне возможно, что
[01:22:33.940 --> 01:22:35.940]  в вашей программе есть проблемы
[01:22:35.940 --> 01:22:37.940]  безопасности. Не обязательно
[01:22:37.940 --> 01:22:39.940]  безопасности, но какие-то проблемы.
[01:22:41.940 --> 01:22:43.940]  Соответственно, также фазеры
[01:22:43.940 --> 01:22:45.940]  бывают
[01:22:45.940 --> 01:22:47.940]  умными
[01:22:47.940 --> 01:22:49.940]  или глупыми.
[01:22:49.940 --> 01:22:51.940]  Соответственно,
[01:22:51.940 --> 01:22:53.940]  умный файзер
[01:22:53.940 --> 01:22:55.940]  он либо знает,
[01:22:55.940 --> 01:22:57.940]  структуру входных данных
[01:22:57.940 --> 01:22:59.940]  либо ее не знает.
[01:22:59.940 --> 01:23:01.940]  Например,
[01:23:01.940 --> 01:23:03.940]  как раз
[01:23:03.940 --> 01:23:05.940]  построение входных данных,
[01:23:05.940 --> 01:23:07.940]  то файзеры они чаще всего умные,
[01:23:07.940 --> 01:23:09.940]  потому что они знают, в каком формате
[01:23:09.940 --> 01:23:11.940]  нужно выдавать входные данные.
[01:23:11.940 --> 01:23:13.940]  В свою очередь там, например, ли файзер,
[01:23:13.940 --> 01:23:15.940]  это глупый файзер, который
[01:23:15.940 --> 01:23:17.940]  просто генирует какой-то последователь,
[01:23:17.940 --> 01:23:19.940]  какой-то набор байт,
[01:23:19.940 --> 01:23:21.940]  не зная о том, что он именно генирует.
[01:23:21.940 --> 01:23:23.940]  И, соответственно, файзеры
[01:23:23.940 --> 01:23:25.940]  могут быть белого или черного ящика,
[01:23:25.940 --> 01:23:27.940]  то есть они могут либо знать
[01:23:27.940 --> 01:23:29.940]  о
[01:23:29.940 --> 01:23:31.940]  структуре программы,
[01:23:31.940 --> 01:23:33.940]  либо, собственно, ее не знать.
[01:23:33.940 --> 01:23:35.940]  То есть когда
[01:23:35.940 --> 01:23:37.940]  соответственно, файзер ничего
[01:23:37.940 --> 01:23:39.940]  не знает о
[01:23:39.940 --> 01:23:41.940]  структуре программы, это черный ящик,
[01:23:41.940 --> 01:23:43.940]  то есть он просто подает на какие-то
[01:23:43.940 --> 01:23:45.940]  входные данные и смотрит, как эту программу
[01:23:45.940 --> 01:23:47.940]  поведет.
[01:23:47.940 --> 01:23:49.940]  Если файзер
[01:23:49.940 --> 01:23:51.940]  специально, нацеленно
[01:23:51.940 --> 01:23:53.940]  подает какие-то входные данные,
[01:23:53.940 --> 01:23:55.940]  ну, например, за счет анализа
[01:23:57.940 --> 01:23:59.940]  с помощью солвера
[01:23:59.940 --> 01:24:01.940]  некоторого потока управления в программе,
[01:24:01.940 --> 01:24:03.940]  и выявив, что
[01:24:03.940 --> 01:24:05.940]  подав такие данные, он действительно
[01:24:05.940 --> 01:24:07.940]  дойдет до какого-то там отдельного
[01:24:07.940 --> 01:24:09.940]  блока, который ему кажется интересен,
[01:24:09.940 --> 01:24:11.940]  то это файзер соответственно
[01:24:11.940 --> 01:24:13.940]  белого ящика.
[01:24:13.940 --> 01:24:15.940]  Более подробно
[01:24:15.940 --> 01:24:17.940]  есть в книжке,
[01:24:17.940 --> 01:24:19.940]  которая доступна по ссылке,
[01:24:19.940 --> 01:24:21.940]  я рекомендую, по крайней мере,
[01:24:21.940 --> 01:24:23.940]  прочесть введение.
[01:24:23.940 --> 01:24:25.940]  Оно позволит,
[01:24:25.940 --> 01:24:27.940]  по крайней мере, понять,
[01:24:27.940 --> 01:24:29.940]  как вообще
[01:24:29.940 --> 01:24:31.940]  файзеры используются,
[01:24:31.940 --> 01:24:33.940]  и
[01:24:33.940 --> 01:24:35.940]  на самом деле можно попробовать там
[01:24:35.940 --> 01:24:37.940]  почитать документацию
[01:24:37.940 --> 01:24:39.940]  на лифт файзер
[01:24:39.940 --> 01:24:41.940]  на странице
[01:24:41.940 --> 01:24:43.940]  LLVM,
[01:24:43.940 --> 01:24:45.940]  по крайней мере, будет понятно там
[01:24:45.940 --> 01:24:47.940]  условный quick start guide,
[01:24:47.940 --> 01:24:49.940]  как можно легко проверить
[01:24:49.940 --> 01:24:51.940]  свой код на предмет
[01:24:51.940 --> 01:24:53.940]  ошибок, например, работы с памятью.
[01:24:55.940 --> 01:24:57.940]  На этом
[01:24:57.940 --> 01:24:59.940]  у меня все.
[01:24:59.940 --> 01:25:01.940]  Если еще есть какие-то вопросы,
[01:25:01.940 --> 01:25:03.940]  то готов на них ответить.
[01:25:03.940 --> 01:25:05.940]  Спасибо.
[01:25:07.940 --> 01:25:09.940]  Спасибо, но тут
[01:25:09.940 --> 01:25:11.940]  комментарии есть, просто я чуть-чуть
[01:25:11.940 --> 01:25:13.940]  про файзеры смотрел, еще есть серые
[01:25:13.940 --> 01:25:15.940]  в ящиках файзеры.
[01:25:15.940 --> 01:25:17.940]  Да, серые в ящиках файзеры это что-то
[01:25:17.940 --> 01:25:19.940]  среднее между белыми
[01:25:19.940 --> 01:25:21.940]  и серыми, но чаще всего
[01:25:21.940 --> 01:25:23.940]  про серые говорят,
[01:25:23.940 --> 01:25:25.940]  что это вот те, которые с покрытием.
[01:25:25.940 --> 01:25:27.940]  Ну, то есть,
[01:25:27.940 --> 01:25:29.940]  когда
[01:25:29.940 --> 01:25:31.940]  грубо говоря, у вас
[01:25:31.940 --> 01:25:33.940]  либо там есть
[01:25:33.940 --> 01:25:35.940]  некоторый фидбэк
[01:25:35.940 --> 01:25:37.940]  на основе покрытия,
[01:25:37.940 --> 01:25:39.940]  либо там
[01:25:39.940 --> 01:25:41.940]  когда у вас
[01:25:41.940 --> 01:25:43.940]  симбиоз
[01:25:43.940 --> 01:25:45.940]  solver
[01:25:45.940 --> 01:25:47.940]  и, соответственно, не solver.
[01:25:47.940 --> 01:25:49.940]  То есть, когда solver не справляется,
[01:25:49.940 --> 01:25:51.940]  то просто работает файзер черного ящика.
[01:25:51.940 --> 01:25:53.940]  Когда solver что-то нашел,
[01:25:53.940 --> 01:25:55.940]  от него данные
[01:25:55.940 --> 01:25:57.940]  приходят.
[01:25:57.940 --> 01:25:59.940]  Ну, там вроде что-то по типу
[01:25:59.940 --> 01:26:01.940]  мы знаем, что когда n
[01:26:01.940 --> 01:26:03.940]  больше тысячи, программа ведет себя не так,
[01:26:03.940 --> 01:26:05.940]  как n меньше тысячи.
[01:26:05.940 --> 01:26:07.940]  Как конкретно не знаем, но, возможно,
[01:26:07.940 --> 01:26:09.940]  стоит генерить и такие-такие тесты.
[01:26:09.940 --> 01:26:11.940]  Это вроде серый ящик получается.
[01:26:11.940 --> 01:26:13.940]  Ну,
[01:26:13.940 --> 01:26:15.940]  не обязательно,
[01:26:15.940 --> 01:26:17.940]  но, в принципе, надо смотреть в отдельные
[01:26:17.940 --> 01:26:19.940]  случаи.
[01:26:19.940 --> 01:26:21.940]  То есть, вот откуда пришло
[01:26:21.940 --> 01:26:23.940]  название n больше тысячи?
[01:26:23.940 --> 01:26:25.940]  Если оно пришло, грубо говоря,
[01:26:25.940 --> 01:26:27.940]  от solver,
[01:26:27.940 --> 01:26:29.940]  то тогда возможно.
[01:26:29.940 --> 01:26:31.940]  А если
[01:26:31.940 --> 01:26:33.940]  это просто какое-то интересное значение,
[01:26:33.940 --> 01:26:35.940]  то
[01:26:35.940 --> 01:26:37.940]  скорее это файзер
[01:26:37.940 --> 01:26:39.940]  черного ящика.
[01:26:39.940 --> 01:26:41.940]  То есть,
[01:26:41.940 --> 01:26:43.940]  грубо говоря, интересные значения, например,
[01:26:43.940 --> 01:26:45.940]  когда у вас происходит мутационный файзинг,
[01:26:45.940 --> 01:26:47.940]  то
[01:26:47.940 --> 01:26:49.940]  интересными значениями являются 0,
[01:26:49.940 --> 01:26:51.940]  f, f, f, f,
[01:26:51.940 --> 01:26:53.940]  и, то есть, такие подобные значения,
[01:26:53.940 --> 01:26:55.940]  которые чаще приводят к крашам.
[01:26:55.940 --> 01:26:57.940]  То есть, они были выявлены, грубо говоря,
[01:26:57.940 --> 01:26:59.940]  на статистическом
[01:26:59.940 --> 01:27:01.940]  каком-то тестировании, и, соответственно, файзеры их
[01:27:01.940 --> 01:27:03.940]  вставляются
[01:27:03.940 --> 01:27:05.940]  при мутациях использовать в первую очередь.
[01:27:09.940 --> 01:27:11.940]  Но вообще сейчас
[01:27:11.940 --> 01:27:13.940]  большую часть файзеров можно привести
[01:27:13.940 --> 01:27:15.940]  к категории серого ящика.
[01:27:15.940 --> 01:27:17.940]  То есть, скорее белый-серый
[01:27:17.940 --> 01:27:19.940]  и вообще все примеры
[01:27:19.940 --> 01:27:21.940]  из предыдущего слайда
[01:27:21.940 --> 01:27:23.940]  это такие границы,
[01:27:25.940 --> 01:27:27.940]  которые
[01:27:27.940 --> 01:27:29.940]  можно определить на плоскости
[01:27:29.940 --> 01:27:31.940]  или на каком-то
[01:27:31.940 --> 01:27:33.940]  многомерном пространстве. И, соответственно,
[01:27:33.940 --> 01:27:35.940]  каждый отдельно взятый файзер
[01:27:35.940 --> 01:27:37.940]  будет ближе к тому-то,
[01:27:37.940 --> 01:27:39.940]  ближе к тому-то,
[01:27:39.940 --> 01:27:41.940]  как и любой другой инструмент.
[01:27:43.940 --> 01:27:45.940]  Потому что хороший файзер
[01:27:45.940 --> 01:27:47.940]  использует большое количество
[01:27:47.940 --> 01:27:49.940]  параметров.
[01:27:49.940 --> 01:27:51.940]  Можете сходить
[01:27:51.940 --> 01:27:53.940]  к ребятам
[01:27:53.940 --> 01:27:55.940]  с первого этажа
[01:27:55.940 --> 01:27:57.940]  мы студии системного программирования,
[01:27:57.940 --> 01:27:59.940]  когда будете в гостях
[01:27:59.940 --> 01:28:01.940]  в Испе.
[01:28:01.940 --> 01:28:03.940]  Они там много расскажут про
[01:28:03.940 --> 01:28:05.940]  Испфайзер
[01:28:05.940 --> 01:28:07.940]  и не только про него.
[01:28:11.940 --> 01:28:13.940]  На этом, я думаю, можно
[01:28:13.940 --> 01:28:15.940]  заканчивать и потихоньку
[01:28:15.940 --> 01:28:17.940]  переходить
[01:28:17.940 --> 01:28:19.940]  к защите.
