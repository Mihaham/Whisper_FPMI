[00:00.000 --> 00:13.680]  так короче у нас тема умные указатели прошлый раз мы нет лямбда функции пока нет
[00:13.680 --> 00:19.380]  сейчас мы закончим разговор про умные указатели сначала а лямбда функции это будет отдельно тема
[00:19.380 --> 00:27.500]  не связанная ну получается те так а маркер то нормально пишет ну так не очень да значит smart
[00:27.500 --> 00:38.220]  pointers как я уже говорил я в прошлый раз заспойлерил кучу всего но как я уже говорил мы не сразу
[00:38.220 --> 00:43.580]  решим все проблемы в реализации smart pointers мы сейчас как-то их решим а потом еще вернемся к
[00:43.580 --> 00:52.180]  этой теме и дорешаем вот а вам-то надо будет все имплементировать но мы уже обсудили как устроен
[00:52.180 --> 00:59.780]  shared ptr минималистичный вот давайте я напомню что-нибудь быстренько но мы сначала обсудили
[00:59.780 --> 01:12.740]  unique ptr да потом судили минималистичный shared ptr а что там было там был давайте даже напишу это
[01:12.740 --> 01:32.940]  там был значит shared ptr там у нас в полях как мы поняли должен храниться собственно указатель
[01:32.940 --> 01:48.940]  на вот этого t а еще прям на t она что ну пока что на t если ты если ты о том о чем я думаю то
[01:48.940 --> 01:57.180]  пока еще мы эту проблему не решили но вероятно ты не о ней да ну хорошо ну вот еще count
[01:57.180 --> 02:19.980]  ну да ладно ну size t так почему да ну нет я эту часть мы я не буду повторять извините ну мы
[02:19.980 --> 02:24.980]  выяснили в прошлый раз что нужен указатель на счетчик они просто счетчик иначе нам непонятно
[02:24.980 --> 02:33.380]  как его вот ну и понятно как работает конструктор диструктор оператор присваивания не очень
[02:33.380 --> 02:41.140]  интересно что статик не подойдет да вот ну все такой минималистичный shared ptr но тут еще
[02:41.140 --> 02:48.020]  якобы написано конструктор диструктор ассенвент оператор который мы тоже реализовали и в принципе
[02:48.020 --> 02:54.700]  все понятно вот смотрите какая какую проблему решим следующий хотелось бы следующий решить
[02:54.700 --> 03:01.260]  проблему что у меня нету нормально пишущего маркера может быть из какой-нибудь аудитории
[03:01.260 --> 03:15.220]  позаимствовать ну вот я не знаю я забыл вот я просто как-то мне не нравится они все пишут
[03:15.220 --> 03:27.820]  так себе вроде что-то пишут но не очень хорошо ну да ладно следующий пункт значит это будет
[03:27.820 --> 03:44.300]  параграф не 11 уже 12 точка 3 будет называться функции make shared и make unique make shared появилась
[03:44.300 --> 03:59.300]  тогда же когда и собственно shared ptr c++11 make unique появилась только c++14 значит что мы что нас
[03:59.300 --> 04:07.620]  не устраивает в shared ptr сейчас но вот нас не устраивает примерно та проблема что если не
[04:07.620 --> 04:16.420]  аккуратно сделать нею а потом 2 shared ptr на этот сишный pointer то получится что будет двойное
[04:16.420 --> 04:23.500]  удаление мы это обсуждали да получится что у вас две так сказать линейки shared ptr указывающих
[04:23.500 --> 04:27.340]  на одно и то же каждый будет думать что он ответственный удаление получается двойное удаление
[04:27.820 --> 04:40.540]  вот это раз ну хотелось бы написать какую-то функцию которая бы избавил нас от необходимости
[04:40.540 --> 04:48.500]  писать нею вообще ну вот функция make shared она на самом деле как раз так устроена она позволяет
[04:48.500 --> 04:59.740]  вам не ну я вот этот промежуточную стадию голова стика такого сразу получить или как это
[04:59.740 --> 05:06.620]  лягушку ну то есть не надо делать отдельно сишный ptr потом из него конструировать shared ptr это все
[05:06.620 --> 05:11.380]  обернуто функцию make shared вы ее вызываете вот функции make shared вы как раз вызываете
[05:11.380 --> 05:27.220]  от аргументов конструктора ну если у вас есть сишный ptr в какой-то момент то это уже опасно
[05:33.220 --> 05:40.540]  нет нет ты если завел сишный ptr если ты в программе завел вручную сишный ptr
[05:40.540 --> 05:50.860]  а потом завел у него shared ptr то это чревато ошибкой что ты либо заведешь еще один shared
[05:50.860 --> 05:57.500]  ptr на то же самое либо потом напишешь delete хотя не должен был потому что у тебя уже есть shared
[05:57.500 --> 06:05.500]  ptr и короче кажется что хотелось бы миновать наличие вообще сишных ptr в коде если у тебя
[06:05.500 --> 06:12.100]  есть shared ptr то есть наша цель перестать писать нею вообще использует только shared ptr но это
[06:12.100 --> 06:17.020]  пока не единственная проблема а вторую проблему сейчас озвучу но сначала я напишу как выглядит
[06:17.020 --> 06:25.500]  сигнатура мы их shared какая у нее будет сигнатура она принимает аргументы конструктора виноват
[06:25.500 --> 06:40.700]  сначала t потом arcs то есть вот у нее есть шаблонный параметр t еще arcs и возвращает
[06:40.700 --> 06:57.700]  на shared ptr на t называется make shared и принимает что да arc с двойной амперсант конечно потому
[06:57.700 --> 07:04.060]  что это универсальная ссылка теперь мы уже понимаем что это такое почему двойной амперсант
[07:04.060 --> 07:15.620]  понимаем же да все понимают думаю что нет но ну ладно вот ну привыкайте да привыкайте так
[07:15.620 --> 07:24.700]  вот ну мы ее сейчас реализуем но перед этим я вот еще о чем хочу предложить вам подумать смотрите
[07:24.700 --> 07:33.660]  в shared ptr если вы вспомните его реализацию который мы написали тут вот ее не написано
[07:33.660 --> 07:48.620]  ну подразумевается что вы были на прошлой лекции так что да так вот вот кто-то спрашивал там чате
[07:48.620 --> 07:55.700]  а можно ли стека локаторе использовать shared ptr я сказал нельзя но он там и не нужен но нельзя
[07:55.700 --> 08:03.100]  вот почему потому что shared ptr он внезапно использует сам вызов new в себе дополнительный как можно
[08:03.100 --> 08:14.900]  понять из того что мы написали это ты слишком далеко вперед забежал но вообще этого мы то это
[08:14.900 --> 08:25.580]  мы тоже хотим да нет подождите подождите подождите не так быстро не так быстро раньше
[08:25.580 --> 08:34.740]  рано еще паниковать я начал говорить про стека локатор потому что shared ptr неподходящий
[08:34.740 --> 08:40.020]  класс для реализации стека локатора потому что shared ptr стека локатор подразумевается что я
[08:40.020 --> 08:45.500]  не хочу использовать динамическую память вообще а shared ptr даже если осоздал shared ptr вот
[08:45.500 --> 08:54.380]  какой-то вещи освобождение которой представляет из себя не освобождение динамической памяти как
[08:54.380 --> 09:01.260]  другое действие сам shared ptr обращается к оператору new для внутренних нужд то есть shared ptr он
[09:01.260 --> 09:06.140]  внутри себя замаскированно содержит вызов оператора new о котором вы можете не подозревать вот
[09:06.140 --> 09:12.540]  если вы пользуетесь shared ptr как как юзер и не знаете о внутренней реализации то вы можете даже не
[09:12.540 --> 09:19.540]  подозревать что на самом деле создание shared ptr это лишний вызов new на на in на на каунт да
[09:19.540 --> 09:25.500]  именно нужно же вот эту фигню положить динамическую память то есть shared ptr вызывает new под
[09:25.500 --> 09:34.660]  капотом для того чтобы каунт положить и получается следующая ситуация вот вы написали там не знаю
[09:34.660 --> 09:46.980]  int звездочка p равно new int ну вот если вспоминать использование shared ptr ну старая да в старом
[09:46.980 --> 10:00.580]  варианте а потом написали shared ptr от int там sp от p получилось что у вас вот тут вызвалось new и
[10:00.580 --> 10:08.260]  вот тут вызвалось new то есть у вас два вызова new то есть у вас получится что вот этот вот ptr и
[10:08.260 --> 10:16.900]  вот этот вот каунтер ну они оба динамически выделенные вещи но они отдельно разными операторами
[10:16.900 --> 10:26.700]  new выделены и лежать еще будут в разном не рядом так вот предлагается сделать следующую вещь почему
[10:26.700 --> 10:35.860]  бы мы если не создаем shared ptr сразу из документов конструктора без промежуточного вот этого почему
[10:35.860 --> 10:45.540]  бы нам не сделать сразу new на t и счетчик вместе ну то есть чтобы вызов new был 1 а не 2 и чтобы
[10:45.540 --> 11:06.900]  они рядом лежали то есть я здесь сделаю вот как я напишу что я хочу выделить значит
[11:06.900 --> 11:31.060]  так ну мне нужно byte как size of t плюс size of size t
[11:37.780 --> 11:51.340]  вот и после этого я могу shared ptr свой сразу а что кстати сделать то сразу надо нет ну во
[11:51.340 --> 11:57.220]  первых надо конструктор надо вызвать еще вот это то есть надо сказать вот этот вот ptr
[11:57.220 --> 12:10.500]  ну вот я сделал такое а потом мне надо сделать такое это правильный вопрос но пока я не думаю
[12:10.500 --> 12:25.380]  об этом значит значит потом я делаю вот так ну я создал я выделил короче кусок памяти где
[12:25.380 --> 12:37.860]  лежит т звездочка и счетчик этот и и что и конструктор надо вызвать на то место куда я положил
[12:37.860 --> 12:52.300]  это все нет не будет потому что new он он выравнивает по max align t а не будет ли без
[12:52.300 --> 13:02.460]  alignment int да хорошо просто хорошо просто если меня ты этот чар например да то получится что
[13:02.460 --> 13:09.820]  я положил int ну да это правда но окей тут еще нужно предусмотреть правильный alignment to do
[13:09.820 --> 13:29.420]  нет если мы выделим 9 байт то первый из них он выравнивает по размеру там по 16 а это тогда
[13:29.420 --> 13:44.220]  да и тут останется не выровненный да стандартный new выравнивает по max align t что не странно
[13:44.220 --> 13:48.260]  потому что если бы он так не делал то каждый при каждом использовании new вам нужно было бы
[13:48.260 --> 13:54.900]  а не забыл я выровнять это сайну этой line of long double условно говоря
[13:54.900 --> 14:09.380]  что-то с каждой парой у нас возникает у нас темп все замедляется потому что количество вопросов
[14:09.380 --> 14:16.060]  напомните что это такое каждый растет мы так мы так скоро совсем вперед перестанем двигаться
[14:16.060 --> 14:27.260]  да в конце конец семестра будет о том что мы снова вспомним как работает стандартная
[14:27.260 --> 14:35.340]  пера то есть это такая на самом деле курс вперед туда и обратно c плюс плюс туда и обратно
[14:35.340 --> 14:41.020]  ну так вот ну да здесь надо еще про alignment подумать ну давайте я не буду сейчас думать
[14:41.020 --> 14:53.140]  понятно что это тоже надо правильно написать так вот я пишу new ptr t вот чего от std forward
[14:53.140 --> 15:08.820]  std forward с шаблонным параметром arcs от arcs многоточие. вот это я положил
[15:08.820 --> 15:20.380]  значит объект типа t по этому адресу вот а теперь я хочу создать собственно
[15:20.380 --> 15:31.900]  shared ptr из этого всего дела а как это сделать положить один наверное потому что shared ptr
[15:31.900 --> 15:45.460]  а shared ptr как создать из этого да нужно другой конструктор shared ptr от какой-то специальной
[15:45.460 --> 15:56.780]  вещи на самом-то деле вот эта функция это будет friend ну вот короче friend shared ptr
[15:56.780 --> 16:12.860]  make shared ну тут понятно там надо шаблон написать еще что это там
[16:12.860 --> 16:27.820]  ну понятно тут вот и должен быть конструктор приватный приватный конструктор от какого-то
[16:27.820 --> 16:34.540]  тега специального говорящего что мы через make shared вызываем сейчас ну или не от тега просто
[16:34.540 --> 16:43.420]  от поинтера ну там может будет несколько приватных конструкторов и один из них ну
[16:43.420 --> 16:49.900]  чтобы между ними различать ну короче да нам нужен приватный конструктор от чего ну от
[16:49.900 --> 17:01.460]  ну наверное от да просто я могу действительно сделать какой-нибудь там тег make shared тег
[17:01.460 --> 17:16.740]  и вот звездочка ну все я попаду сюда и в этом конструкторе я проинциализирую правильно уже
[17:16.740 --> 17:29.860]  и это и это просто фейк да просто фейковый тип такой который пустой но за счет него
[17:29.860 --> 17:40.740]  попадаем в эту версию конструктора так ну понятно что тут надо написать да и понятно что там еще
[17:40.740 --> 17:48.140]  надо написать ну то есть тут надо ну надо сказать что вот этот вот каунтер
[17:48.140 --> 18:00.620]  давайте наверное здесь ну здесь просто наверное скажу shared ptr return shared ptr
[18:00.620 --> 18:26.220]  от make shared тег и еще ну make shared тег по умолчанию и что там и вот этот ptr ну и все а тут
[18:26.220 --> 18:39.420]  тогда я каунтер проинциализирую у нас много проблем будет да а где второе он началось да
[18:39.420 --> 18:45.780]  хорошо ну ладно еще раз повторим что было раньше это копии лижен я напомню это значит пункт 10
[18:45.780 --> 18:54.220]  точка забыл какой пункт но в общем да это это ultimate копии лижен c++ 17 гарантированная которая
[18:54.220 --> 19:03.300]  которая точно не приведет к копированию такой ситуации этот shared ptr он сразу же будет
[19:03.300 --> 19:15.500]  этим shared ptr этот случай мы обсуждали вот так ну хорошо но тут ну я не буду писать что тут
[19:15.500 --> 19:23.860]  понятно каунтер проинциализировали вот ну теперь какие у нас у нас проблемы какие у нас проблемы да
[19:23.860 --> 19:36.340]  как delete делать если мы так это все написали то теперь нам нужно да нам нужно помнить создались
[19:36.340 --> 19:49.420]  мы через make shared или не через make shared потому что ну да нет это на самом деле не только во первых
[19:49.420 --> 19:55.820]  нет смотри во первых для того чтобы не работать с ишными пойтерами вообще пользовательском коде
[19:55.820 --> 20:03.140]  во вторых чтобы у тебя был всего один вызов new в третьих чтобы счетчик и объект лежали рядом
[20:03.140 --> 20:09.500]  они в отдельных где-то в разных местах ну чтобы грубо говоря у тебя обращение к счетчику
[20:09.500 --> 20:21.980]  обращение к объекту было почти одной операции одной загрузкой в память а вот
[20:33.140 --> 20:54.740]  но это будет достаточно достаточно неудобно проверять каждый то есть тебе на самом деле
[20:54.740 --> 21:06.860]  довольно много раз надо будет и фать это на самом деле устроено дело так давайте я
[21:06.860 --> 21:16.900]  заведу такую еще структуру которая называется control блок не не не значит есть такая структура
[21:16.900 --> 21:24.580]  внутренняя для shared птр она называется control блок ну она считайте тут объявлена и она содержит в себе
[21:24.580 --> 21:45.980]  counter и объект и хранить нам надо лишь поинтер на эту структуру но
[21:45.980 --> 22:11.820]  я буду хранить сейчас у меня есть действительно проблемка проблемка проблемка ну наверное можно
[22:12.660 --> 22:17.860]  сделать бейс контрол блок и просто контрол блок как обычно да ну то есть у меня будет
[22:17.860 --> 22:24.820]  бейс контрол блок которая хранит просто сайс т и контрол блок который хранит сайс т и т и тогда
[22:24.820 --> 22:39.180]  вот этот указатель будет указателем на ну да этот указатель будет указателем на бейс контрол блок
[22:39.180 --> 22:47.220]  у меня будет указатель вот на такую вещь бейс контрол блок блин мне нельзя пользоваться
[22:47.220 --> 22:54.300]  тряпкой больше она очень портит маркер потом после нее маркер не пишет я буду хранить указатель
[22:54.300 --> 23:19.340]  на бейс контрол блок и еще на т да смотри какая фишка я вот что сделаю я чтобы ефать меньше
[23:19.340 --> 23:27.860]  в деструкторе но я не хочу в дополнительной буль заводить я не хочу чтобы было дополнительной
[23:27.860 --> 23:36.340]  буль в полях и разумеется я не хочу заниматься вот этим вот чем вы предложили с ненужным битом
[23:36.340 --> 23:43.980]  что как зачем но буль нужен тебе в деструкторе ну ты на прошлой паре не был ты естественно не
[23:43.980 --> 23:50.580]  понимаешь а ну ну жаль ну тебе нужен деструктор шерп тр как-то реализовать как ты его реализуешь
[23:50.580 --> 23:59.580]  деструкторе шерп тр тебе нужно делать delete counter и delete t delete вот этот птр который был так кто
[23:59.580 --> 24:07.860]  понимает буль зачем нужен дополнительных в полях сейчас классно а не нормально давай уточни так
[24:07.860 --> 24:22.700]  ну типа да если высадить если мы следом через функцию мэйк шеред то у нас нужно один раз
[24:22.700 --> 24:27.820]  оператор delete вызвать они два нормально в минималистичном варианте шерп тр у нас
[24:27.820 --> 24:34.340]  было в диструкторе написано delete птр delete count а теперь нам нужно сделать не это а просто delete
[24:34.340 --> 24:40.620]  один лишь птр причем даже не delete а оператор delete ну то есть нужно вручную вызвать диструктор
[24:40.620 --> 24:46.780]  там а оператор delete вызвать вот таким способом как какой-то звездочки это если мы через мэйк
[24:46.780 --> 24:56.220]  шеред создались а не через мэйк шеред создались то нужно по-прежнему сделать да ну вообще хотим
[24:56.220 --> 25:03.420]  да но никто не ну мы не не запрещаем в принципе пользователю создаваться через не через мэйк
[25:03.420 --> 25:23.020]  шеред нет они появились 11 оба вот мэйк юник появился позже чем
[25:23.020 --> 25:31.900]  короче что предлагается сделать это это хак на самом деле такой некоторый на самом деле я
[25:31.900 --> 25:42.740]  наверное пере в общем идея в том что вместо того чтобы проверять буль ли у меня ну там true или
[25:42.740 --> 25:50.300]  false какой-то буль я буду проверять вот эти указатели они на одно и то же или нет есть
[25:50.420 --> 25:55.580]  указатель на t и есть указатель на base control блок я буду проверять а указатель на t он
[25:55.580 --> 26:04.820]  но надо поменять местами да только тогда с base control блоком будет проблема
[26:04.820 --> 26:10.900]  ну сейчас возможно
[26:10.900 --> 26:27.460]  ну просто ну идея в следующем если эти указатели указывают на одну и ту же штуку то значит мы
[26:27.460 --> 26:42.180]  через мэйк шерд создавались а иначе они отдельно лежат если у нас не через мэйк шерд то это
[26:42.180 --> 26:56.580]  указатель на какую-то одну вещь это указатель какую-то другую вещь а ты чего предлагаешь
[27:12.180 --> 27:26.700]  а можно кстати да можно просто сказать что я и что у нас будет каунтер это ну да нет а как
[27:26.700 --> 27:33.700]  ты тогда будешь хранить блок в котором нету а я понял типа ты хочешь сделать контрол блок
[27:33.700 --> 27:42.900]  в котором обязательно есть t и возможно еще каунт нет у тебя каунт либо в полях либо в блоке
[27:42.900 --> 27:52.340]  если у тебя ты создался через мэйк шерд то у тебя каунт будет в блоке а по сути это кажется то
[27:52.340 --> 27:58.580]  же самое как если бы проверять это указатель на одно и то же или нет короче если у тебя о о о
[27:58.580 --> 28:08.060]  вот что если у нас вот у меня будет base control блок состоять просто из t тогда а
[28:08.060 --> 28:15.940]  контрол блок будет состоять из из него и еще дополнительно каунта и я буду хранить указатель
[28:15.940 --> 28:24.380]  на base control блок которую кстати я могу просто при интерпрет кастом получить из из t если
[28:24.380 --> 28:30.300]  мне дали готовый t это это легально если у меня есть такая структура просто то я могу
[28:30.300 --> 28:39.260]  интерпрет кастнуть сказать что вот а каунтер либо у меня есть структура контрол блок которая
[28:39.260 --> 28:47.860]  наследница этой которой добавлено еще поля каунтер и если я создался не через шерд птр то я не
[28:47.860 --> 28:54.980]  создаю просто контрол блок я создаю только base control блок а каунтер отдельно а если я создался
[28:54.980 --> 29:02.820]  через мэйк шерд не у меня понятно что у меня два указателя в полях они один нет два указателя все
[29:02.820 --> 29:12.780]  указатель на контрол блок и указатель на каунтер отдельно со ст звездочка каунтер
[29:12.780 --> 29:25.740]  вот и получается либо у меня каунтер на лп тр и тогда значит каунтер надо искать здесь
[29:25.740 --> 29:32.660]  контрол блоке рядом с этим t либо каунтер не на лп тр и тогда на него надо смотреть
[29:32.660 --> 29:41.660]  вот ну и по этому же признаку я понимаю осознался через мэйк шерд или не через
[29:41.660 --> 29:45.860]  мэйк шерд соответственно в деструкторе я либо делаю delete каунтер delete delete то
[29:45.860 --> 29:54.860]  delete все отдельно либо вот так ну и на самом-то деле вот здесь я могу писать не двоеточие
[29:54.860 --> 30:00.620]  оператор new я могу написать new контрол блок вот бла бла бла бла бла потому что ведь по факту
[30:00.620 --> 30:07.180]  мне создать нужно конкретно уже объект контрол блок вот здесь я могу написать и проблемы
[30:07.180 --> 30:12.140]  сравниваем заодно решилась потому что поля уже сами по себе будут нормально выровнены вот здесь
[30:12.140 --> 30:20.500]  мне не нужно вот это все делать вручную а могу просто создать контрол блок ну короче все понятно
[30:20.500 --> 30:31.980]  у кого контрол блока нет зачем это же структура plane но она просто aggregate initialization сделается то
[30:31.980 --> 30:46.500]  есть я просто вот вот здесь я да я просто сделаю сейчас контрол блок звездочка птр new
[30:46.500 --> 31:03.660]  контрол блок бла бла бла ну давайте сейчас подумаем вот не контрол блок от чего
[31:03.660 --> 31:11.060]  ну да непонятно
[31:11.060 --> 31:21.420]  это будет какой-то move что ли нет мне это не нравится
[31:21.420 --> 31:44.020]  ну я наверное могу сказать вот так ты от std forward ну и один
[31:44.020 --> 31:56.180]  так std forward arcs вот arcs многоточие 1
[31:56.180 --> 32:17.620]  t вот такой 1 и закрылась фигурная скобка а это pair value и поэтому copy elision у
[32:17.620 --> 32:21.980]  меня не будет создан временный t а сразу создастся там нужный t из-за copy elision опять же
[32:21.980 --> 32:32.860]  ну хорошо но у меня как видите проектора нет компилятора нет проверить негде поэтому
[32:32.860 --> 32:47.500]  вам придется верить согласен но ноута нет тут никак не решишь проблему нет если хотите
[32:47.500 --> 32:53.100]  можете кто-нибудь подключить ноут проекту но я пока буду дальше рассказывать ну все короче
[32:53.100 --> 33:06.100]  понятно так с моих шеродом понятно контрол блок это структура внутри шерд птр приватная потому
[33:06.100 --> 33:14.020]  что она ну то есть надо написать да вот вот типа шерд птр от т на самом деле контрол блок ну для
[33:14.020 --> 33:27.700]  разных шерд птр разный контрол блок 1 вот я проинцелизировал здесь ну это мы в этом
[33:27.700 --> 33:31.820]  конструкторе уже сделаем если пришли сюда то мы поймем что каунтон аутэром проинцелизирует
[33:31.820 --> 33:39.580]  ну да да да то есть а то есть на самом деле будет то есть можно на самом деле убрать тег и
[33:39.580 --> 33:43.700]  сказать что мы просто от контрол блока от указателя на контрол блок создаемся если мы
[33:43.700 --> 33:54.220]  создаемся от указатель на контрол блок то мы сразу понимаем все что произошло ну вот
[33:54.220 --> 34:07.580]  ну например так окей дальше так давайте дальше кто понял проблему ее решение про моих шерд
[34:07.580 --> 34:20.300]  ага да да вот текущая все к моменту что нет и структура мы разобрали ну в смысле мы
[34:20.300 --> 34:34.060]  мы не написали но понятно как его написать если нал птр то одно да ну тогда и этот будет нал
[34:34.060 --> 34:42.020]  птр если оба нал птр если этот нал птр то ничего делать не надо а если этот нал птр этот не нал
[34:42.020 --> 34:48.660]  птр значит это было через мэйк шерд и тогда шерд тэр по умолчанию то мог создать и вообще ничего не
[34:48.660 --> 34:59.700]  будет лежать тогда хорошо так теперь мэйк юник мэйк юник она отличается от мэйк шерд тем
[34:59.700 --> 35:07.540]  что она просто создает уник птр без всякого контрол блока и в общем легкое упражнение
[35:07.540 --> 35:13.740]  реализовать мэйк юник самостоятельно что написать надо просто сказать ретерн и уник птр от стд
[35:13.740 --> 35:21.420]  форвард аркс аркс она появилась и плюс 14 а это все плюс 11 почему мэйк уник появилась позже потому
[35:21.600 --> 35:36.540]  потому что потому что мэйк юник она не союз мэйк шерд и ребят в комитете подумали что мэйк
[35:36.540 --> 35:43.860]  шерд это полезная функция мэйк юник в принципе зачем ну мэйк шерд позволяет оптимизировать
[35:43.860 --> 35:49.060]  шерд птр не создавать лишний раз там и не вызывать лишний раз не а prolongtgunner ну что она позволяет
[35:49.060 --> 35:55.660]  в принципе зачем непонятно но потом они поняли спустя три года что облажались на самом деле есть
[35:55.660 --> 36:01.380]  еще одна проблема вот помимо всех упомянутых есть еще одна проблема из-за которой функция
[36:01.380 --> 36:08.260]  makeShert и makeUnique необходимы и поэтому все плюсы 14 они добавили функции makeUnique смотрите допустим
[36:08.260 --> 36:27.900]  я решаю в какой-то момент использовать Unique PTR так вот у меня есть функция которая да вот
[36:27.900 --> 36:35.860]  у меня есть какая-нибудь функция которая принимает Unique PTR и я решаю это передать Unique PTR вручную
[36:35.860 --> 36:58.060]  созданные я говорю Unique PTR там от int от new int да ну это все вызов функции я передаю но это не все
[36:58.060 --> 37:07.460]  а еще эта функция принимает какой-то другой параметр ну например другое число вот c++ 11
[37:07.460 --> 37:18.100]  догадайтесь что может пойти не так нет тут не особо что-то может пойти не так я число
[37:18.100 --> 37:24.340]  получаю как вызов другой функции вот догадайтесь что может пойти не так что может пойти не так
[37:24.340 --> 37:35.700]  ну нет а что не так-то будет даже выбросить исключения но и казалось бы и что ну выбросила
[37:35.700 --> 37:46.860]  и выбросила но вот в чем проблема c++ 11 вычисления порядка аргумент вычисления аргументов функции
[37:46.860 --> 37:56.620]  не не упорядочено это unspecified behavior но хуже того не гарантируется даже что каждый
[37:56.620 --> 38:00.020]  аргумент должен быть полностью вычислены вычислены только насчет вычисляться другой
[38:00.020 --> 38:05.700]  поэтому теоретически возможно следующая ситуация что вы сделаете new int потом сделать
[38:05.700 --> 38:16.300]  ложе а потом Unique PTR от того и если же выбросить исключения то у нас будет течка памяти потому
[38:16.300 --> 38:25.380]  что Unique PTR еще не успел взять владение а new уже отработал нет компилятор имеет право вычислять
[38:25.380 --> 38:30.340]  аргументы функции в любом удобном умопорядке в том числе что-то параллель он может вычислить
[38:30.340 --> 38:39.180]  часть потом вычислить это потом вычислить это ну что-то параллельно нет ну например компилятор
[38:39.180 --> 38:45.620]  решит что тут и тут есть какое-то одинаковое выражение которое он может соптимизировать
[38:45.620 --> 38:50.500]  посчитали какое длинное рефметическое выражение написано а тут такое же но он просто его посчитает
[38:50.500 --> 38:57.740]  не знаю и сюда же подставит его а потом вычислить до вычислить это до вычислить это ну к примеру так
[38:57.740 --> 39:04.020]  вот функция make Unique избавляет от этой проблемы потому что если вы напишете make Unique вот если
[39:04.020 --> 39:15.580]  не так напишем а make Unique с шаблонным параметром int то мы обезопасились и такого уже не произойдет
[39:15.580 --> 39:26.340]  ну потому что если уж вычислиться make Unique от int то будет InU и UniquePtr конструктор сделаны
[39:26.340 --> 39:33.220]  гарантированно а не может вычисление g прервать вычисление другой функции
[39:33.220 --> 39:41.180]  ну до этого у меня был expression он состоял из вычисления вот этого потом вычисления вот этого
[39:41.180 --> 39:50.700]  от этого а тут у меня один вызов функции его нельзя прервать вот ну и еще одна такая уж совсем
[39:50.700 --> 40:07.420]  минорная проблема когда упорядочен оно не стало никогда а c++ 17 запретили то что вот я сказал то
[40:07.420 --> 40:13.420]  есть вот эта проблема добавили make Unique чтобы решить эту проблему в том числе c++14 но
[40:13.420 --> 40:18.140]  c++17 просто запретили компилятору прервать вычисление одного аргумента чтобы вычислить
[40:18.140 --> 40:23.860]  другой вот начиная c++17 гарантируется что здесь это exception safe потому что вот этот
[40:23.860 --> 40:28.780]  аргумент должен быть вычислен полностью причем это начнется поэтому эта проблема уже не актуальна
[40:29.780 --> 40:37.340]  ну вот но еще одна совсем маленькая проблема это что когда вы пользуетесь Unique Ptr явно
[40:37.340 --> 40:43.580]  конструктором вам тип нужно дважды повторять если у вас тип очень длинный и сложный то вы опять
[40:43.580 --> 40:48.220]  понятно можете чуть-чуть ошибиться в названии типа то есть я сейчас делаю new что-то там вот очень
[40:48.220 --> 40:55.940]  длинное std unordered map от std blah blah blah my hash my allocator от std вот это вот все а потом
[40:55.940 --> 41:03.460]  таки а теперь пожалуйста Unique Ptr с шаблонным параметром вот это вот все то же самое от
[41:03.460 --> 41:10.580]  моего п вот чтобы вам два раза не повторять этот длинный тип вам Unique Ptr может make Unique вам
[41:10.580 --> 41:21.780]  только один раз но она работает начиная с 17 но нет она не работает еще потому мы же кстати на
[41:21.780 --> 41:26.180]  прошлый паре как раз выясняли что она не работает как раз у меня не сработала же я пытался компилирует
[41:26.180 --> 41:30.820]  потому что shard ptr можно конструировать не только от т от указатель на т а еще это указатель на
[41:30.820 --> 41:37.380]  родителя т ой на наследника т и поэтому он не знает что подставить и поэтому вам придется
[41:37.380 --> 41:44.420]  вручную повторять тип несмотря на то что ct ad появилось ну вот make shard make Unique короче
[41:44.420 --> 41:50.460]  мораль новый пункт код стайла всегда пользуетесь во первых всегда пользуетесь умными указателями
[41:50.460 --> 41:55.180]  когда это возможно а не сишенами во вторых не вызывайте их конструктор напрямую а вызывайте
[41:55.180 --> 42:13.940]  через make shard make Unique на самом деле а кто кто у вас ведет паше охтямов но на самом деле когда на
[42:13.940 --> 42:19.980]  самом деле мы с паше охтямовым как раз обсуждали эту проблему потому что он хейтил курс по плюсам и
[42:19.980 --> 42:24.260]  говорил что почему люди приходят во второй семестр и пишут на си пишут сишные указатели
[42:24.260 --> 42:29.260]  они умеют политься умею ну блин у нас вот такая программа мы только в марте успеваем указатель
[42:29.260 --> 42:33.460]  протянутку а ну ладно ладно я понял ну тогда давайте вы побыстрее хотим ну короче все вы
[42:33.460 --> 42:40.660]  теперь уже прошли теперь нет оправдания вот ну короче да да все теперь мы прошли умные указатели
[42:40.660 --> 42:54.540]  теперь теперь у вас нет оправданий перед паше охтямовым я перед собой да не ну а что нормально
[42:54.540 --> 43:04.020]  удобные умные указатели очень очень хорошие так вот не ну пользоваться ты им уже можешь
[43:04.020 --> 43:10.940]  реализовать еще пока не можешь но сейчас сейчас сможешь скоро так идем дальше следующий пункт это
[43:10.940 --> 43:25.860]  вик птр я это сотру сейчас именно следующий пункт о них вик птр называется сейчас мы будем
[43:25.860 --> 43:34.980]  решать проблему возможных циклических зависимости shared птр вик птр это еще один умный указатель
[43:34.980 --> 43:46.620]  который как раз решает эту проблему нет нет все хитрее сейчас узнаете значит ну смотрите
[43:46.620 --> 43:55.020]  ну проблему я уже озвучивал представьте что у вас есть объект и в нем есть поле указатель
[43:55.020 --> 43:59.900]  который указывает на другой такой объект в котором есть поле указатель а но указывает на
[43:59.900 --> 44:07.260]  первый такой объект если оба эти указатели shared птр и то такая конструкция никогда не
[44:07.260 --> 44:15.340]  будет удалена ну если вы вот ну если вы строите дерево например на shared птр и
[44:15.340 --> 44:22.380]  родитель помнит ребенка ребенок помнит родителя вот такую штуку сконструировали а потом если вы
[44:22.540 --> 44:30.860]  вот эту вот вершину отцепили ну то есть вы казалось бы вы сказали типа ну все я вы же на вы
[44:30.860 --> 44:35.300]  же на умных указателях пишете вы не хотите delete ручную делаете вы типа отцепляете вот это и
[44:35.300 --> 44:43.380]  такие все вот вот этот родитель теперь на лп тр и казалось бы это должен уничтожиться сам но нет мы
[44:43.380 --> 44:50.620]  не хотите вручную делать вы хотите отцепили под дерево оно будет что-то но так не получится вот
[44:50.620 --> 45:12.880]  вам придется ну вам придется вручную получается вот это что ну вот в случае
[45:12.880 --> 45:29.880]  дерево ну короче сейчас я думаю
[45:42.880 --> 45:47.200]  ну вот представим что это не дерево а просто какая-нибудь структура в которой
[45:47.200 --> 45:52.360]  одно из полей указатель на другую такую же структуру ну или даже на
[45:52.360 --> 45:58.840]  несколько ну то есть не несколько указатель на другие такие структуры
[45:58.840 --> 46:06.240]  да вот и вы вот у вас у тебя есть такая структура в которой там несколько вещей
[46:06.240 --> 46:11.920]  слазит друг на друга и ты типа а что я тебе рассказываю твоя структура вышла из
[46:12.000 --> 46:17.880]  области видимости вот что должно произойти вот у тебя есть вот это вот
[46:17.880 --> 46:23.040]  штука типа ноут вот она вышла из области видимости а в ней есть shared
[46:23.040 --> 46:29.520]  птр на другую ноут а что должно случиться когда она из области видимости вышла
[46:29.520 --> 46:33.560]  казалось бы но допустим у тебя ноут содержит всего лишь ин и shared птр тебе
[46:33.560 --> 46:37.520]  казалось бы никакой не тривиальный деструктор не нужен если у тебя такая вот
[46:37.520 --> 46:45.400]  структура ноут с интом и shared ptr на другое вышла из области видимости такой ну классно все удалится а
[46:45.400 --> 46:51.720]  нет потому что у тебя две ноуты ссылались одна на другую и shared ptr казалось бы должен освободить
[46:51.720 --> 46:58.760]  но нет потому что он еще думает что кто-то на ту же ссылает вот и все короче так не сработает и
[46:58.760 --> 47:11.480]  поэтому мы сейчас изобретем еще одну еще одного монстра weak ptr это все проблема которая родственна
[47:11.480 --> 47:19.160]  проблеме сборки мусора в языках поддержащих сборку мусора в джаве я уже говорил что ну там
[47:19.160 --> 47:26.280]  джаве и питоне в шарпе там где еще и сборка мусора она страдает такой же правил почему
[47:26.280 --> 47:31.880]  сборка мусора это не тривиальная алгоритмический вещь потому что потому что у вас могут быть
[47:31.880 --> 47:38.180]  циклические ссылки вот ровно по этой причине и там каждый каждый язык программирования там решает
[47:38.180 --> 47:44.040]  это по-своему там есть целые какие-то целые теории о том целые какие-то алгоритмы как это делается
[47:44.040 --> 47:51.760]  там вот питоне например есть такие то поколение там 1 1 2 поколение объектов что-то такое вот ну то
[47:51.760 --> 47:56.560]  есть вам нужно понимать на какие объекты уже нет ссылок на какие есть а если циклические ссылки
[47:56.560 --> 48:09.520]  нужно чтобы уничтожить их ну вот а я shared ptr сам по себе не будет решать стд shared ptr не
[48:09.520 --> 48:14.800]  будет решать и ваш shared ptr не будет решать эту проблему и чтобы эту проблему решать то есть
[48:14.800 --> 48:22.720]  если у вас если у вас такие циклические зависимости возможны то вам надо использовать
[48:22.720 --> 48:36.760]  weak ptr что такое weak ptr это слабый указатель что такое слабый указатель почему он слабый кто
[48:36.760 --> 48:49.000]  развалится ну он слабый потому что он ничего не контролирует вот я бы так сказал он слабый
[48:49.000 --> 48:58.080]  потому что он не может за себя постоять что ли я не знаю вот как-то так он не может а не вот он
[48:58.080 --> 49:03.680]  слабый потому что он не может защитить то что под ним лежит от удаления кем-то другим вот так вот
[49:03.680 --> 49:12.320]  короче weak ptr это такой ptr который базово поддерживает две операции создать shared ptr из себя на то
[49:12.320 --> 49:21.000]  же самое а еще посмотреть не уничтожилось ли уже то что подо мной лежит базовая операция две посмотреть
[49:21.000 --> 49:29.120]  не удалил ли уже кто-то то на что я смотрю а второе это если не удалил то создать shared ptr на него новый
[49:29.120 --> 49:44.680]  как предполагается это использовать когда вы берете когда у вас есть циклические зависимости
[49:44.680 --> 49:54.080]  вам достаточно просто один из ptr сделать weak вот если у вас есть ну например ссылка туда обратно
[49:54.080 --> 49:59.640]  вот если у вас есть указатель на ребенка и на родителя то достаточно решить для себя в какую
[49:59.640 --> 50:04.160]  сторону ссылка будет слабой вот в одну сторону ссылка будет сильной то есть она будет как бы
[50:04.160 --> 50:12.600]  владеть а в обратную сторону ссылка будет таким наблюдателем вот допустим ну стандартный подход
[50:12.600 --> 50:22.160]  это что указатель вверх он слабый ну я пунктирчиком нарисую то есть вы заводите shared ptr на сына но
[50:22.240 --> 50:31.120]  weak ptr на родителя и прикол weak ptr в том что его мнение не учитывается при удалении то что
[50:31.120 --> 50:38.560]  weak ptr указывает на что-то это неважно оно все равно удалится да понятно то есть вот если у вас
[50:38.560 --> 50:49.600]  одна из один из указателей в цикле weak ptr то цикл правильно разрушится вам нужно просто решить в
[50:49.600 --> 50:56.400]  какую сторону указатель weak ptr будет shared ptr должны образовывать такое ориентированное дерево
[50:56.400 --> 51:01.200]  направленное а если у вас циклы возникают то вот стрелки в обратную сторону нужно weak ptr делать
[51:01.200 --> 51:08.480]  тогда такая конструкция будет корректно разрушена потому что лишь shared ptr она будет как бы снизу
[51:08.480 --> 51:15.200]  вверх разрушена так потому что сначала умру там нет нет сверху вниз сначала умрет вот этот он
[51:15.200 --> 51:25.600]  умер умрут его дети потом умрут их дети ну и так далее ну если у себя если у тебя вся эта
[51:25.600 --> 51:33.120]  вот конструкция вышла из области видимости допустим ты потерял указатель на нее уничтожается на
[51:33.120 --> 51:44.440]  эту штуку уже нет ни одного shared ptr она уничтожается но у тебя был по всей видимости shared ptr на нее
[51:44.920 --> 51:52.080]  когда его не стало shared ptr такой ага я был последним на эту указатель значит ее сейчас уничтожу
[51:52.080 --> 51:58.400]  она уничтожается ее уничтожение величез собой уничтожение shared ptr на вот эти вещи потому
[51:58.400 --> 52:11.960]  что они были в ее полябе эти shared ptr эти shared ptr что ну похоже что да
[52:14.440 --> 52:24.120]  слушай это какой-то интересный вопрос ну блин не должно же так быть
[52:24.120 --> 52:31.320]  ну возможно
[52:39.640 --> 52:43.200]  так ну в общем вот это уничтожится потом уничтожится эти ну и так далее вся эта
[52:43.200 --> 52:48.920]  конструкция уничтожится а то что вик птр и были снизу вверх это неважно потому что вик птр
[52:48.920 --> 52:57.720]  что их самое главное свойство они их наличие не влияет на тот счетчик соответственно у вик птр
[52:57.720 --> 53:06.240]  какие есть методы как пользоваться вик птр но вот у него есть метод expired bool expired
[53:06.240 --> 53:15.920]  это метод который позволяет проверить умер уже тот кто под нами лежит или нет
[53:15.920 --> 53:26.280]  ты молодец и правильные вопросы задаешь это непонятно пока это нужно кое-что изобрести
[53:26.280 --> 53:36.800]  еще будешь чтобы это работала не будет еще один инт но сейчас сейчас узнаете так а еще
[53:36.800 --> 53:51.240]  у меня есть вот такая функция shared ptr от t которая называется о господи а как она называется
[53:51.440 --> 53:58.440]  вот это прикол я забыл как называется метод вик птр откройте кто-нибудь и переференз вик птр как
[53:58.440 --> 54:06.480]  называется штука которая shared ptr лог что ли она называется да значит это лог да да да да это
[54:06.480 --> 54:17.880]  она это shared ptr лог вот и она тоже конст по моему она же конст ну казалось бы да точно
[54:18.760 --> 54:32.800]  вот это две главные функции два главных метода shared ptr ой вик птр то есть expired и лог
[54:32.800 --> 54:48.880]  посмотреть не умерли объект ну прежде чем обратиться лог сделать ну ты у тебя нет
[54:48.880 --> 55:01.120]  разыменования вик птр как операции если что а потому что если у тебя объект умер ты уб получишь
[55:01.120 --> 55:13.760]  при такой операции как в чем проблема так так для сишном указатель ты можешь проверить
[55:13.760 --> 55:32.720]  пустой ли он а для вик птр как проверить тебе нужна функция expired почему почему ты не почему
[55:32.720 --> 55:37.200]  у тебя нету просто оператор звездочка да кстати мы не сказали самое главное про shared ptr
[55:37.200 --> 55:49.040]  у них же оператор звездочка стрелочка еще перегружена но это я думаю понятно да про
[55:49.040 --> 55:57.960]  стрелочку по моему говорили ну если не говорили прочитать стрелочка чуть сложнее звездочки там
[55:57.960 --> 56:03.600]  нетривиально есть там костыль такой тоже языковое что стрелочка должна возвращать
[56:03.600 --> 56:13.200]  сишный поинтер к которому автоматически описывается стрелочка еще одна в общем
[56:13.200 --> 56:17.760]  у shared ptr и вик птр понятно есть оператор звездочка и стрелочка оператор звездочка у
[56:17.760 --> 56:26.560]  нарная возвращает ссылку на вот эту вещь а оператор стрелочка возвращает указатель который там
[56:26.560 --> 56:32.880]  потом да вот а если бы у оператора вик птр был бы оператор звездочка то чтобы она возвращала
[56:32.880 --> 56:45.480]  ну в норме должен возвращаться темперсант а тут что будет возвращаться а если нет ну темперсант
[56:45.480 --> 56:55.040]  звездочка возвращает темперсант конечно что ну конечно вот как бы реализовать как бы мы
[56:55.040 --> 57:03.080]  реализовали звездочку у вик птр объекта может не быть ну то есть грубо говоря в контрол блоке
[57:03.080 --> 57:14.280]  лежит нал птр там нет уже объекта ну и что мы будем делать а что будет делать звездочка бросать
[57:14.280 --> 57:22.000]  исключение тогда значит умирать ну надо ссылку на те вернуть где ты возьмешь ссылку на те хоть
[57:22.000 --> 57:32.760]  на какой-нибудь будет ce ну как ты вернешь ссылку на те от нал под ссылку они указатель на те это
[57:32.760 --> 57:48.320]  должно вернуть что такое звездочка п на контрол блок то есть ты хочешь то есть ты хочешь вернуть
[57:48.920 --> 57:54.160]  то есть ты хочешь забить на то что это может быть нал птр сказать блок стрелочка объект и вот его и вернуть
[57:54.160 --> 58:12.320]  ну короче ладно ну давайте в общем этот вопрос оставим почему у вик птр нет звездочки но
[58:12.320 --> 58:19.040]  ну наверное можно было бы реализовать куда который был делала убе если бы там был
[58:19.040 --> 58:30.720]  expired но типа подразумевается что вик птр вы не так должны пользоваться вы вик птр
[58:30.720 --> 58:37.480]  пользуетесь только для того чтобы посмотреть жив ли он еще пациент там и если жив то
[58:37.480 --> 58:59.880]  шерп птр можно создать ты говоришь лог а дальше стрелочка что-то там нет подожди это не курс по
[58:59.880 --> 59:12.360]  многопоточности да теперь у меня есть шерп птр на родители в смысле обратно так вик птр никуда не
[59:12.360 --> 59:24.240]  делся просто кроме шерп птр кроме вид птр ты создал шерп птр шерп птр да так давайте обсудим как
[59:24.240 --> 59:29.280]  expired работок это дискуссионный вопрос почему нет звездочка есть только лог но у нас в любом
[59:29.280 --> 59:35.640]  случае понятно что функция expired должна быть в каком-то виде как она реализована как мне
[59:35.640 --> 59:44.480]  вик птр понять у меня объект умер уничтожен уже или нет шерп птр ну начнем с того что шерп начнем
[59:44.480 --> 59:50.040]  с того что вик птр может существовать только тогда когда есть уже хоть один шерп птр на то
[59:50.040 --> 01:00:03.720]  же самое нельзя создать вик птр на что-то не имея шерп птр на это потому что вик птр не
[01:00:03.720 --> 01:00:09.640]  уничтожает объект когда умирает сам вик птр не владеет объектом если ты создаешь вик птр
[01:00:09.640 --> 01:00:15.960]  подразумевается что ты наблюдаешь за тем кем уже кто-то кем уже кто-то владеет вот шерп птр
[01:00:15.960 --> 01:00:21.640]  может владеть объектом а вик птр такой создался такой ну я посмотрю но пока нету
[01:00:21.640 --> 01:00:29.640]  шерп птр который владеет объектом нельзя сказать вик птр да вик птр создается от шерп
[01:00:29.640 --> 01:00:55.000]  птр ну и от другого вик птр ну примерно конструктор вик птр он от шерп птр там
[01:00:55.000 --> 01:01:04.240]  еще какие-то наверное есть но но не от сишного поинтера тот же звездочка это какое у нас
[01:01:04.240 --> 01:01:18.120]  вот этот каунт а если там через мэйк шерп было
[01:01:34.240 --> 01:01:40.520]  значит ну вик птр
[01:01:40.520 --> 01:01:53.600]  хорошо значит у нас будет хранится base control блок звездочка блок да
[01:01:53.600 --> 01:02:17.960]  ну да да да да да ты понял главную проблему а ты понял главную проблему главная проблема
[01:02:17.960 --> 01:02:25.800]  не в этом главная проблема вот в чем у нас шерп птр когда умирает последний он уничтожает за
[01:02:25.800 --> 01:02:33.600]  собой весь контролл блок включая счетчик а допустим еще вик птр и существовали на это если
[01:02:33.600 --> 01:02:39.240]  после этого я у того вик птр спрашиваю умерли объект он должен сказать умер но уже удален
[01:02:39.240 --> 01:02:44.040]  счетчик как он поймет что он то есть казалось бы вик птр должен здесь просмотреть на каунтер
[01:02:44.600 --> 01:02:48.840]  сказать ну или нет но проблема в том что он никогда не может быть 0 просто что был бы
[01:02:48.840 --> 01:03:03.440]  0 он бы был удален вместе с объектом нам нужно не удалять счетчик когда мы удаляем объект если
[01:03:03.440 --> 01:03:12.720]  еще есть живые вик птр и потому что вик птр и могут еще смотреть объекта они уже к объекту но они
[01:03:12.760 --> 01:03:17.200]  не запрещают объекта удаления но счетчиком они еще могут пользоваться поэтому когда шерп
[01:03:17.200 --> 01:03:24.000]  тр удаляет объект свой видишь то каунт 0 он должен еще проверить а если вик птр и если есть
[01:03:24.000 --> 01:03:31.520]  вик птр и то счетчик он не удаляет удаляет только объект правильно нам нужен еще один счетчик
[01:03:31.520 --> 01:03:49.080]  который называется вик каунт нет все эти из вик птр уже ну это уже не смысл значит на самом
[01:03:49.080 --> 01:03:57.320]  деле у меня в контролл блоке будет лежать два счетчика шерп каунт и вик каунт вот
[01:03:57.320 --> 01:04:08.880]  мне опять не нравится то что мы сделали с этими контролл блоками потому что я не хочу хранить
[01:04:08.880 --> 01:04:19.120]  дополнительно указать я хочу один хранить всего лишь да хочу хранить нам нужен все-таки
[01:04:19.120 --> 01:04:38.840]  значит смотрите предлагаю вот что сделать давайте я все-таки сделаю контролл блок в котором
[01:04:38.840 --> 01:04:47.600]  лежат сначала два числа потом т и буду хранить два указателя один из которых ну я буду хранить
[01:04:47.600 --> 01:04:54.760]  два указателя которые в случае если создавался через мэйк шерет просто будут указывать на этот
[01:04:54.760 --> 01:05:00.040]  самый контролл блок один и тот же просто на одно и то же место в памяти на начало этого контролл
[01:05:00.040 --> 01:05:12.360]  блока а если если я создавался не через мэйк шерет то у меня будет указатель на т указать в
[01:05:12.360 --> 01:05:22.280]  другое место и так я пойму что у меня в контролл блоке нет т есть только счетчики у меня все-таки
[01:05:22.280 --> 01:05:27.720]  указатель на т будет отдельно они указатель на счетчик я хочу у меня в контролл блоке либо
[01:05:27.980 --> 01:05:33.860]  или нет я создаю контролл блок в котором либо есть только счетчики если ты уже создан был либо
[01:05:33.860 --> 01:05:39.100]  есть счетчики те и как я буду понимать контролл блок у меня с т или без него а я
[01:05:39.100 --> 01:05:44.640]  буду просто либо этот указатель который указатель на те будет он будет указать и
[01:05:44.640 --> 01:05:53.120]  другое место либо вот указать на тоже самое место если он на то же самое место
[01:05:53.120 --> 01:05:59.120]  Если указать, буду просто плюс делать, плюс два счетчика, это не страшно.
[01:05:59.120 --> 01:06:02.120]  Вот, короче, такая идея.
[01:06:02.120 --> 01:06:05.120]  А иначе контрол блок у нас на месте, то что будет?
[01:06:05.120 --> 01:06:08.120]  Бейс контрол блок будет хранить два счетчика.
[01:06:08.120 --> 01:06:15.120]  Значит, тут будет shared count и weak count.
[01:06:15.120 --> 01:06:18.120]  shared count.
[01:06:18.120 --> 01:06:22.120]  То есть на самом деле надо два счетчика.
[01:06:22.120 --> 01:06:25.120]  And weak count.
[01:06:25.120 --> 01:06:28.120]  Вот.
[01:06:28.120 --> 01:06:33.120]  Control блок, это будет наследник base control блок,
[01:06:33.120 --> 01:06:37.120]  который еще дополнительно хранит T.
[01:06:37.120 --> 01:06:41.120]  И у меня будет указатель на...
[01:06:41.120 --> 01:06:43.120]  А...
[01:06:49.120 --> 01:06:52.120]  Может, можете наследование замутить здесь?
[01:06:52.120 --> 01:06:58.120]  Ну, я имею в виду, что здесь должен быть указатель, видимо, на T.
[01:07:02.120 --> 01:07:05.120]  На base control блок и на T, да?
[01:07:05.120 --> 01:07:08.120]  Блин, не нравится мне это.
[01:07:09.120 --> 01:07:14.120]  Нет, я не хочу на base control блок и на T, потому что...
[01:07:14.120 --> 01:07:18.120]  Ну, потому что вдруг так случайно получилось, что они просто рядом оказались,
[01:07:18.120 --> 01:07:23.120]  но не потому что я их создал одновременно, а просто потому что рядом оказались.
[01:07:23.120 --> 01:07:27.120]  Да, я хочу, чтобы у меня именно равны были вот эти указатели как числа,
[01:07:27.120 --> 01:07:30.120]  если я их создавал одновременно.
[01:07:30.120 --> 01:07:33.120]  То есть у меня будет указатель на base control блок
[01:07:33.120 --> 01:07:39.120]  и указатель еще на какую-нибудь штуку, которая является...
[01:07:42.120 --> 01:07:45.120]  Которая может быть либо T, либо...
[01:07:45.120 --> 01:07:48.120]  Либо указателем просто на T, либо...
[01:07:50.120 --> 01:07:54.120]  Либо указателем на то же самое.
[01:07:58.120 --> 01:08:01.120]  Да, сейчас, что-то я не понимаю.
[01:08:04.120 --> 01:08:09.120]  Нет, ну я понимаю, но я думаю, как это сделать, чтобы...
[01:08:11.120 --> 01:08:15.120]  Чего? На CPU сейчас не написано, как это реализовано, конечно. Ты чего?
[01:08:20.120 --> 01:08:22.120]  Ну да, в ST.
[01:08:25.120 --> 01:08:28.120]  Ну давайте, я не знаю, сделаем...
[01:08:33.120 --> 01:08:37.120]  Ну давайте сделаем T звездочку, действительно.
[01:08:39.120 --> 01:08:41.120]  PTR все-таки.
[01:08:42.120 --> 01:08:45.120]  Которая будет либо... Мы просто будем проверять,
[01:08:45.120 --> 01:08:50.120]  либо действительно здесь, либо действительно она с этим control блоком рядом,
[01:08:50.120 --> 01:08:53.120]  либо... либо нет.
[01:08:58.120 --> 01:09:02.120]  То есть у меня будет T звездочка, которая...
[01:09:04.120 --> 01:09:07.120]  Сейчас, а почему я вообще сделал... Почему я их поменял местами?
[01:09:07.120 --> 01:09:10.120]  Я что-то уже перестал... Я что-то уже запутался.
[01:09:10.120 --> 01:09:15.120]  Почему я поменял местами T и control блок?
[01:09:15.120 --> 01:09:19.120]  А, потому что T может быть не всегда там. У меня обязательно должны быть два счетчика,
[01:09:19.120 --> 01:09:23.120]  но не обязательно T, да. Ну то есть у меня, короче, есть указатель на control блок,
[01:09:23.120 --> 01:09:26.120]  который начинается с двух чисел в любом случае.
[01:09:26.120 --> 01:09:29.120]  А дальше там либо лежит T, либо не лежит T.
[01:09:29.120 --> 01:09:34.120]  Вот этот указатель на T, он будет либо вот вести на область памяти
[01:09:34.120 --> 01:09:38.120]  сразу после этого control блок, либо куда-то в другое место.
[01:09:38.120 --> 01:09:43.120]  И так я буду понимать, я через make-shared или не через make-shared создался.
[01:09:45.120 --> 01:09:47.120]  Звучит как убыть.
[01:09:50.120 --> 01:09:55.120]  В материале поместили их подряд просто в памяти с помощью...
[01:09:55.120 --> 01:09:59.120]  У нас есть памяти локатеров, по которым мы знаем об убедении.
[01:09:59.120 --> 01:10:03.120]  Например, наш стеклокатер, который честно кладет друг за другом.
[01:10:03.120 --> 01:10:06.120]  Вызвали два подряд, получили проблему.
[01:10:06.120 --> 01:10:09.120]  Сначала T, а потом T.
[01:10:11.120 --> 01:10:15.120]  У нас есть стеклокатер, который зачем стоит по обратном порядке.
[01:10:17.120 --> 01:10:20.120]  Стеклокатеры в этом порядке?
[01:10:20.120 --> 01:10:23.120]  В смысле, который с конца...
[01:10:25.120 --> 01:10:28.120]  У нас есть подряд, как будто это одна общая control блок,
[01:10:28.120 --> 01:10:31.120]  и мы дальше сможем сделать...
[01:10:43.120 --> 01:10:45.120]  Сейчас, подождите.
[01:10:49.120 --> 01:10:51.120]  Да-да-да, конечно, конечно.
[01:10:51.120 --> 01:10:55.120]  Нет, понятно, что можно bool добавить, но я не хочу bool добавлять.
[01:10:55.120 --> 01:10:57.120]  Понятно, что если бы мы добавили bool, то все решилось бы.
[01:10:57.120 --> 01:10:59.120]  Я хочу красиво сделать.
[01:11:03.120 --> 01:11:05.120]  Можно сделать вот так.
[01:11:05.120 --> 01:11:07.120]  Как?
[01:11:07.120 --> 01:11:11.120]  CD, ray, variant.
[01:11:19.120 --> 01:11:22.120]  Ну да, тип, который равен либо тому, либо другому,
[01:11:22.120 --> 01:11:25.120]  его можно пронициализировать как этим, так и другим.
[01:11:25.120 --> 01:11:27.120]  А там будет храниться типа?
[01:11:27.120 --> 01:11:30.120]  Да, но это не очень правильно, потому что мы все равно ничего не соптимизировали.
[01:11:30.120 --> 01:11:34.120]  Там будет храниться, скорее всего, дополнительная штука.
[01:11:36.120 --> 01:11:38.120]  А...
[01:11:45.120 --> 01:11:51.120]  Ну как обойтись двумя полями, чтобы не хранить bool дополнительный?
[01:11:53.120 --> 01:11:57.120]  Понятно, ты сконструировался через makeshared или не через makeshared?
[01:11:59.120 --> 01:12:02.120]  А потом появился weak count еще.
[01:12:02.120 --> 01:12:05.120]  Понятно, что мне надо либо еще один int хранить тут, либо...
[01:12:05.120 --> 01:12:08.120]  либо указательно еще один int хранить, либо...
[01:12:08.120 --> 01:12:10.120]  Да.
[01:12:15.120 --> 01:12:17.120]  Base control block.
[01:12:17.120 --> 01:12:19.120]  У меня base control block начинался с T.
[01:12:19.120 --> 01:12:21.120]  А давайте еще один base control block делаем.
[01:12:21.120 --> 01:12:23.120]  Давайте добавим стандартный...
[01:12:23.120 --> 01:12:25.120]  Сейчас.
[01:12:27.120 --> 01:12:30.120]  Почему не работает то решение, которое было, когда мы weak count добавили?
[01:12:30.120 --> 01:12:33.120]  У меня был base control block, который хранил только T,
[01:12:33.120 --> 01:12:37.120]  а их control block хранил его еще счетчик.
[01:12:37.120 --> 01:12:39.120]  И у меня было, получается...
[01:12:39.120 --> 01:12:41.120]  У меня был этот либо налпы...
[01:12:41.120 --> 01:12:43.120]  Ну это еще счетчик, а структуру счетчик.
[01:12:45.120 --> 01:12:47.120]  И теперь мы будем хранить счетчик звездочка.
[01:12:47.120 --> 01:12:49.120]  Да, структуру счетчик.
[01:12:49.120 --> 01:12:51.120]  Да, структура counter.
[01:12:51.120 --> 01:12:53.120]  Структура counter.
[01:12:53.120 --> 01:12:55.120]  Да, да, да, да.
[01:12:55.120 --> 01:12:57.120]  Кажется, вот так.
[01:12:57.120 --> 01:12:59.120]  И кажется, что-то я наворотил совершенно зря.
[01:12:59.120 --> 01:13:01.120]  Можно просто сказать, что...
[01:13:01.120 --> 01:13:03.120]  Давайте скажем, что структура называется counter.
[01:13:05.120 --> 01:13:07.120]  Смотрите, структура counter.
[01:13:09.120 --> 01:13:12.120]  И мы храним указатель на counter.
[01:13:18.120 --> 01:13:20.120]  Base control block выглядит как...
[01:13:20.120 --> 01:13:22.120]  Просто T.
[01:13:24.120 --> 01:13:27.120]  А control block выглядит как T и еще counter.
[01:13:29.120 --> 01:13:39.120]  Да, мы храним указатель на...
[01:13:39.120 --> 01:13:41.120]  Да, все, все, все, извините.
[01:13:41.120 --> 01:13:43.120]  Все получилось, все хорошо, да.
[01:13:43.120 --> 01:13:45.120]  Все сработало.
[01:13:47.120 --> 01:13:49.120]  Да, все, давайте дальше.
[01:13:51.120 --> 01:13:53.120]  Ну давайте еще раз.
[01:13:53.120 --> 01:13:55.120]  Я уже понимаю, что, наверное, никто ничего не понимает.
[01:13:55.120 --> 01:13:57.120]  Ну просто 3 раза...
[01:13:59.120 --> 01:14:01.120]  Ну, я просто...
[01:14:01.120 --> 01:14:03.120]  Я просто зачем-то начал менять местами поля этой штуки.
[01:14:03.120 --> 01:14:05.120]  И это была плохой идеей.
[01:14:05.120 --> 01:14:07.120]  Надо вернуть как раньше.
[01:14:11.120 --> 01:14:13.120]  Давайте я просто напишу полностью.
[01:14:13.120 --> 01:14:15.120]  Давайте я просто напишу полностью, что у меня есть.
[01:14:15.120 --> 01:14:17.120]  В чем шутка?
[01:14:17.120 --> 01:14:19.120]  Нам не жалко для одного объекта,
[01:14:19.120 --> 01:14:21.120]  на который мы собираемся создавать 10 тысяч SHFQR,
[01:14:21.120 --> 01:14:23.120]  создать несколько лишних инток.
[01:14:25.120 --> 01:14:27.120]  Один объект один раз.
[01:14:27.120 --> 01:14:29.120]  А в каждом SHFQR хочется хранить как можно меньше.
[01:14:29.120 --> 01:14:31.120]  Понятное дело.
[01:14:31.120 --> 01:14:33.120]  Структура base control block
[01:14:37.120 --> 01:14:39.120]  будет хранить просто T.
[01:14:49.120 --> 01:14:51.120]  Вот.
[01:14:51.120 --> 01:14:53.120]  А структура control block
[01:14:55.120 --> 01:14:57.120]  будет наследницей
[01:14:57.120 --> 01:14:59.120]  base control block.
[01:15:09.120 --> 01:15:11.120]  И будет хранить
[01:15:11.120 --> 01:15:13.120]  еще дополнительно
[01:15:13.120 --> 01:15:15.120]  counter.
[01:15:21.120 --> 01:15:23.120]  Тогда как это работает?
[01:15:23.120 --> 01:15:25.120]  Если мы создались
[01:15:25.120 --> 01:15:27.120]  через make shared,
[01:15:27.120 --> 01:15:29.120]  то у нас хранится структура
[01:15:29.120 --> 01:15:31.120]  control block, в которой хранится
[01:15:31.120 --> 01:15:33.120]  object и counter. Все нормально.
[01:15:33.120 --> 01:15:35.120]  И вот этот counter
[01:15:35.120 --> 01:15:37.120]  он на LPTR, да?
[01:15:37.120 --> 01:15:39.120]  Он на LPTR, потому что
[01:15:39.120 --> 01:15:41.120]  мы так договаривались раньше.
[01:15:41.120 --> 01:15:43.120]  Мы понимаем, что если он на LPTR,
[01:15:43.120 --> 01:15:45.120]  значит мы через make shared создались.
[01:15:45.120 --> 01:15:47.120]  А если мы создались не через make shared,
[01:15:47.120 --> 01:15:49.120]  то у нас есть лишь
[01:15:49.120 --> 01:15:51.120]  base control block,
[01:15:51.120 --> 01:15:53.120]  он настоящий base control block,
[01:15:53.120 --> 01:15:55.120]  в котором лежит...
[01:15:57.120 --> 01:15:59.120]  Мы пронициализируем
[01:16:01.120 --> 01:16:03.120]  тем объектом, который
[01:16:03.120 --> 01:16:05.120]  указатель на который нам дали...
[01:16:19.120 --> 01:16:21.120]  Ну да, reinterpret cast,
[01:16:21.120 --> 01:16:23.120]  наверное, просто.
[01:16:23.120 --> 01:16:25.120]  Reinterpret cast, да.
[01:16:25.120 --> 01:16:27.120]  Я просто скажу, что тот указатель, который
[01:16:27.120 --> 01:16:29.120]  мне дали, это и есть указатель на base control block.
[01:16:29.120 --> 01:16:31.120]  И это будет корректно, потому что
[01:16:31.120 --> 01:16:33.120]  base control block это plain структура,
[01:16:33.120 --> 01:16:35.120]  которая просто поле типа T и все.
[01:16:35.120 --> 01:16:37.120]  Это нормально, это не UB даже.
[01:16:37.120 --> 01:16:39.120]  Даже не UB.
[01:16:41.120 --> 01:16:43.120]  Ты чему радуешься?
[01:16:43.120 --> 01:16:45.120]  Проблема в том, что вы этому радуете.
[01:16:47.120 --> 01:16:49.120]  Так, все работает, нормально.
[01:16:51.120 --> 01:16:53.120]  Отлично.
[01:16:53.120 --> 01:16:55.120]  А тут не T, а значит object?
[01:16:55.120 --> 01:16:57.120]  Нет, именно T, object.
[01:16:57.120 --> 01:16:59.120]  Потому что когда мы сделали
[01:16:59.120 --> 01:17:01.120]  make shared, мы реально на ней
[01:17:01.120 --> 01:17:03.120]  создали объект.
[01:17:03.120 --> 01:17:05.120]  Короче, по второму смысле,
[01:17:05.120 --> 01:17:07.120]  это указатель.
[01:17:07.120 --> 01:17:09.120]  Так, кто понял
[01:17:09.120 --> 01:17:11.120]  проблему и ее решение?
[01:17:11.120 --> 01:17:13.120]  Хорошо.
[01:17:13.120 --> 01:17:15.120]  Что непонятно?
[01:17:15.120 --> 01:17:17.120]  Как работает expired?
[01:17:17.120 --> 01:17:19.120]  Ну как?
[01:17:19.120 --> 01:17:21.120]  В wik.ptr хранит то же самое,
[01:17:21.120 --> 01:17:23.120]  что и shared.ptr.
[01:17:23.120 --> 01:17:25.120]  На самом деле в wik.ptr хранит...
[01:17:25.120 --> 01:17:27.120]  Да, вопрос такой,
[01:17:27.120 --> 01:17:29.120]  когда мы удаляем счетчики наконец?
[01:17:29.120 --> 01:17:31.120]  А, в деструктуре wik.ptr, конечно.
[01:17:31.120 --> 01:17:33.120]  Ну то есть в деструктуре
[01:17:33.120 --> 01:17:35.120]  shared.ptr теперь мы не удаляем счетчик,
[01:17:35.120 --> 01:17:37.120]  если еще был wik.ptr.
[01:17:37.120 --> 01:17:39.120]  В деструктуре shared.ptr теперь мы делаем
[01:17:39.120 --> 01:17:41.120]  еще дополнительную проверку.
[01:17:41.120 --> 01:17:43.120]  Если ты последний wik.ptr,
[01:17:43.120 --> 01:17:45.120]  ты удаляешь control block.
[01:17:47.120 --> 01:17:49.120]  А если это было все через make shared
[01:17:49.120 --> 01:17:51.120]  создано, то ты удаляешь всю эту штуку.
[01:17:53.120 --> 01:17:55.120]  Когда уничтожается shared.ptr?
[01:17:55.120 --> 01:17:57.120]  Он должен проверить.
[01:17:57.120 --> 01:17:59.120]  Есть ли еще wik.ptr?
[01:17:59.120 --> 01:18:01.120]  Если есть wik.ptr, то он просто вызывает
[01:18:01.120 --> 01:18:03.120]  в деструктуре t,
[01:18:03.120 --> 01:18:05.120]  а память не освобождает.
[01:18:05.120 --> 01:18:07.120]  Вообще не освобождает?
[01:18:07.120 --> 01:18:09.120]  Конечно. А как?
[01:18:09.120 --> 01:18:11.120]  Если он был выделен через make shared,
[01:18:11.120 --> 01:18:13.120]  то он выделен одним куском.
[01:18:13.120 --> 01:18:15.120]  И это, кстати, недостаток функции make shared.
[01:18:15.120 --> 01:18:17.120]  Это та причина, по которой
[01:18:17.120 --> 01:18:19.120]  некоторые считают, что функции make shared
[01:18:19.120 --> 01:18:21.120]  все-таки не стоит пользоваться иногда.
[01:18:21.120 --> 01:18:23.120]  Потому что функция make shared
[01:18:23.120 --> 01:18:25.120]  обладает следующим недостатком.
[01:18:25.120 --> 01:18:27.120]  Если у тебя есть wik.ptr
[01:18:27.120 --> 01:18:29.120]  и ты уничтожил последний shared.ptr,
[01:18:29.120 --> 01:18:31.120]  то все равно будет выделен лежать.
[01:18:31.120 --> 01:18:33.120]  Но если t большой
[01:18:33.120 --> 01:18:35.120]  и у тебя wik.ptr переживают
[01:18:35.120 --> 01:18:37.120]  shared.ptr постоянно, то у тебя будет лишняя память
[01:18:37.120 --> 01:18:39.120]  использоваться.
[01:18:39.120 --> 01:18:41.120]  Но деструктур t будет вызван shared.ptr.
[01:18:41.120 --> 01:18:43.120]  А вот память будет не освобождена
[01:18:43.120 --> 01:18:45.120]  и счетчики будут еще храниться.
[01:18:45.120 --> 01:18:47.120]  Если же у тебя wik.ptr
[01:18:47.120 --> 01:18:49.120]  нет, то ты полностью удаляешь все.
[01:18:49.120 --> 01:18:51.120]  А вот wik.ptr
[01:18:51.120 --> 01:18:53.120]  это важно.
[01:18:53.120 --> 01:18:55.120]  Очень часто люди ошибаются в этом.
[01:18:55.120 --> 01:18:57.120]  Как устроен
[01:18:57.120 --> 01:18:59.120]  деструктур wik.ptr?
[01:18:59.120 --> 01:19:01.120]  Деструктур wik.ptr
[01:19:01.120 --> 01:19:03.120]  никогда не удаляет
[01:19:03.120 --> 01:19:05.120]  t.
[01:19:07.120 --> 01:19:09.120]  Он поэтому и wik.
[01:19:09.120 --> 01:19:11.120]  Он удаляет разве что в счетчике.
[01:19:11.120 --> 01:19:13.120]  То есть wik.ptr смотрит
[01:19:13.120 --> 01:19:15.120]  на деструктур wik.ptr
[01:19:15.120 --> 01:19:17.120]  смотрит, есть ли еще
[01:19:19.120 --> 01:19:21.120]  есть ли еще хоть что-то
[01:19:21.120 --> 01:19:23.120]  shared count или wik count.
[01:19:23.120 --> 01:19:25.120]  Если это есть, то он ничего не делает.
[01:19:27.120 --> 01:19:29.120]  И если
[01:19:29.120 --> 01:19:31.120]  только деструктур wik.ptr
[01:19:31.120 --> 01:19:33.120]  обнаруживает, что нет ни shared
[01:19:33.120 --> 01:19:35.120]  count и wik.count
[01:19:35.120 --> 01:19:37.120]  то wik.ptr
[01:19:37.120 --> 01:19:39.120]  диалоцирует память под
[01:19:39.120 --> 01:19:41.120]  это все, но деструктур t
[01:19:41.120 --> 01:19:43.120]  не вызывает уже, потому что деструктур t
[01:19:43.120 --> 01:19:45.120]  вызван shared.ptr. Только shared.ptr
[01:19:45.120 --> 01:19:47.120]  ответственно за то, чтобы уничтожать t.
[01:19:47.120 --> 01:19:49.120]  Wik.ptr отделал удалить счетчики.
[01:19:49.120 --> 01:19:51.120]  Все, так работает wik.ptr.
[01:19:51.120 --> 01:19:53.120]  Соответственно, как работает expired, мы просто
[01:19:53.120 --> 01:19:55.120]  смотрим на shared count.
[01:19:57.120 --> 01:19:59.120]  Как работает log, мы просто
[01:19:59.120 --> 01:20:01.120]  смотрим, если shared count, опять же
[01:20:01.120 --> 01:20:03.120]  не ноль, если это ноль, то мы кажется
[01:20:03.120 --> 01:20:05.120]  бросаем исключение, наверное, bad wik.ptr
[01:20:05.120 --> 01:20:07.120]  какой-нибудь.
[01:20:07.120 --> 01:20:09.120]  А если не ноль,
[01:20:09.120 --> 01:20:11.120]  то создаем
[01:20:11.120 --> 01:20:13.120]  shared.ptr на него. И это дешевая
[01:20:13.120 --> 01:20:15.120]  операция, потому что создание нового
[01:20:15.120 --> 01:20:17.120]  shared.ptr не привлечет к созданию
[01:20:17.120 --> 01:20:19.120]  ну, это очень дешевая операция.
[01:20:21.120 --> 01:20:23.120]  Да, мы просто создаем shared.ptr,
[01:20:23.120 --> 01:20:25.120]  который хранит те же
[01:20:25.120 --> 01:20:27.120]  два счетчика, те же структуру.
[01:20:27.120 --> 01:20:29.120]  Никого нового выделения памяти не происходит, потому что
[01:20:29.120 --> 01:20:31.120]  log может отработать только
[01:20:31.120 --> 01:20:33.120]  когда shared.ptr уже был. Не то же самое.
[01:20:35.120 --> 01:20:37.120]  Да.
[01:20:39.120 --> 01:20:41.120]  То же самое, что и shared.ptr, да.
[01:20:43.120 --> 01:20:45.120]  Делает не то же самое, что и shared.ptr.
[01:20:45.120 --> 01:20:47.120]  У него
[01:20:47.120 --> 01:20:49.120]  дофига различия, у него нет почти ничего,
[01:20:49.120 --> 01:20:51.120]  что есть в shared.ptr.
[01:20:51.120 --> 01:20:53.120]  У него нет звездочки, нет
[01:20:53.120 --> 01:20:55.120]  стрелочки, у него нет useCount.
[01:20:55.120 --> 01:20:57.120]  UseCount, кстати, может и есть.
[01:20:57.120 --> 01:20:59.120]  UseCount — это сколько еще shared.ptr
[01:20:59.120 --> 01:21:01.120]  на то же самое указывают.
[01:21:01.120 --> 01:21:03.120]  Главное различие — его нельзя разоменовать.
[01:21:03.120 --> 01:21:05.120]  Вот это две главные его операции — expire и log.
