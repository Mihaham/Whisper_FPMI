[00:00.000 --> 00:10.480]  Вот, давайте начнем третью лекцию. Точнее четвертую, но третью лекцию мы до конца не довели,
[00:10.480 --> 00:17.280]  поэтому мы с вами посмотрим на такую штуку к интерьеру Meetability. У нас есть такие вот примитивы
[00:17.280 --> 00:25.200]  separate RFSL, которые мы сейчас посмотрим. Смотрите, у нас есть правило memory-safety, главное в расте,
[00:25.200 --> 00:32.040]  которое говорит, что мы в любой момент либо имеем сколько-то немутабельных ссылок. Забегая
[00:32.040 --> 00:37.560]  наперед, скажу, уже, наверное, вам можно говорить об этом. На самом деле, когда мы говорим мутабельная
[00:37.560 --> 00:43.280]  ссылка и немутабельная ссылка, мы чуть-чуть вверх, потому что в рамках RASTA это только интуиция.
[00:43.280 --> 00:49.560]  На самом деле, немутабельная ссылка означает shard-ссылка, а мутабельная ссылка — это unique-ссылка,
[00:49.560 --> 00:55.120]  то есть она только одна. И в этом смысле она чуть более правильна, чем мутабельная и немутабельная.
[00:55.120 --> 01:00.120]  Ну, вы можете оставаться в мыслях о том, что это мутабельная и немутабельная ссылка,
[01:00.120 --> 01:06.720]  я думаю, вы почти, наверное, не сломаете ни в какой момент себя понимание. Вот у нас может быть либо
[01:06.720 --> 01:12.600]  несколько немутабельных ссылок, либо одна мутабельная. Но иногда бывает такое, что нам
[01:12.600 --> 01:17.800]  хочется мутировать объекты при том, что мы имеем только обычную ссылку.
[01:17.800 --> 01:30.000]  Плохо, конечно, что я не успел посмотреть слайды. Так, давайте посмотрим. Так как у нас RASTA не
[01:30.000 --> 01:35.240]  должен ломать свои фундаментальные свойства safety, то в таком случае то, что мы сейчас будем делать,
[01:35.240 --> 01:40.200]  я заранее предупреждаю, оно будет иметь какой-то overhead в runtime. Он не может это проверить
[01:40.200 --> 01:44.760]  compile-time, поэтому для того, чтобы safety сохранялась, он проиграет это в runtime.
[01:44.760 --> 01:53.360]  Тот паттерн, которому будем говорить, называется Interior Metability. В RASTA он очень явно возникает,
[01:53.360 --> 01:57.080]  в плюсах и подобных языках на самом деле тоже возникает, но вы его просто не видите,
[01:57.080 --> 02:01.400]  потому что он не формализован в этих языках.
[02:01.400 --> 02:19.560]  Смотри, вот есть чисто RASTA пример изменения чего-то внутри RSI. RSI у нас внутри не мутабелен.
[02:19.560 --> 02:26.680]  Есть некоторая причина, которую мы на этой лекции объяснять не будем, почему внутри мы не можем
[02:26.680 --> 02:31.560]  заменять объект. Для того, чтобы что-то мутировать внутри, нам нужно будет использовать
[02:31.560 --> 02:38.840]  RASTA Interior Metability. Чуть более конкретно, помните ли вы Atomic или Mutex? Думаю, конечно, помните,
[02:38.840 --> 02:44.200]  я прихожу, вы разговариваете про конкарнти. Как минимум один ассистент, как минимум один семионарист,
[02:44.200 --> 02:50.760]  поэтому ситуация другая. Да, ну в общем, какая ситуация у нас? Atomic это, когда вы пользуетесь
[02:50.760 --> 02:56.520]  RASTA Atomic, у вас несколько потоков имеет ссылку на него. Вот это собственно Interior Metability,
[02:56.520 --> 03:02.760]  это мутабельность через обычную ссылку, через шарот-ссылку. Для того, чтобы это работало, вам
[03:02.760 --> 03:07.800]  нужно давать какие-то гарантии, потому что если вы будете мутировать это из нескольких потоков,
[03:07.800 --> 03:12.520]  или как мы увидим дальше, даже однопоточно что-то мутировать неправильно, то вы можете получить
[03:13.480 --> 03:21.400]  и в плюсах. Ну то есть в плюсах ты не увидишь это, потому что в RASTA, опять же, очень-очень хорошо
[03:21.400 --> 03:28.400]  все формализовано, и ты увидишь просто. Очень явно. А в плюсах это сложно найти. Вот. Ну вот,
[03:28.400 --> 03:35.160]  Atomic, Mutex, Ravalloc и вообще любая мутация через обыкновенную ссылку. Мы на этой лекции не будем
[03:35.160 --> 03:40.600]  говорить про многопоточную модификацию, будем только про однопоточную. В какой-то момент мы вернемся
[03:40.600 --> 03:45.520]  к Atomic, Mutex, Ravalloc и прочему, когда мы будем говорить про многопоточную страсть.
[03:45.520 --> 03:56.240]  Давайте начнем с такой абстракции, которая называется CEL. Вот. У нас CEL содержит какой-то тип T,
[03:56.240 --> 04:03.920]  и как он решает проблему того, что у нас может несколько потоков, например, ну,
[04:04.760 --> 04:10.560]  давайте не про потоки, как он решает проблему того, что у нас может модифицироваться значение
[04:10.560 --> 04:16.680]  внутри него. Он его просто либо пресваивает в этом значении, либо когда мы достаём оттуда значение,
[04:16.680 --> 04:24.480]  то он его просто копирует, он не возвращает ссылку. Вот. И более того, обратите, пожалуйста,
[04:24.480 --> 04:31.120]  внимание на то, что мы от T требуем, чтобы он был копия. Мы сейчас поговорим, почему это именно копия,
[04:31.120 --> 04:39.560]  а не клоун, например. Вот. У него достаточно немного самых важных функций, там есть еще
[04:39.560 --> 04:45.800]  некоторые, но нам важны эти три. Создать новый CEL, записать какое-то значение и взять значение.
[04:45.800 --> 04:51.840]  Ну, как видите, сет у нас просто моет на три значения, а get у нас достает именно копию.
[04:51.840 --> 04:57.720]  Причем более того, вы можете создать CEL даже когда у вас T не копия, но get у вас будет работать
[04:57.720 --> 05:08.640]  только тогда, когда T именно копит. Вот. Там вот так вот это устроено. Вот. Ну, с этим, я думаю, понятно.
[05:08.640 --> 05:16.880]  Ну, в принципе, да. Это, наверное, создано для того, чтобы для каких-то типов, которые копии не
[05:16.880 --> 05:22.640]  имплементируются, CEL все равно можно было создать. Ну, я не знаю, зачем. Вы будете это использовать
[05:22.640 --> 05:39.800]  в основном для всяких интов, например. Что еще? Так. Ну, опять же, например, если у тебя RCE32,
[05:39.800 --> 05:44.480]  то ты не сможешь RCE32 менять. Тебе захочется закономерно иногда через шар отсылку его менять.
[05:44.480 --> 05:50.040]  Ну, RCE, да, это шар отсылка просто. Вот. И, соответственно, тебе захочется сделать RCE CEL.
[05:50.040 --> 05:55.440]  RCE CEL, потому что у тебя внутри тип INT. Он легковесный, он просто копии, поэтому
[05:55.440 --> 05:59.960]  мы можем воспользоваться CELом. Ref CEL, забегай наперед, это то, что возвращает именно ссылки,
[05:59.960 --> 06:09.760]  считает хронотайны. Вот. У нас есть такой вот важный вопрос, почему мы запросили копии, а не клоун.
[06:09.760 --> 06:16.600]  Дело в том, что у нас клоун может быть фигней, который делает какую-то произвольную логику внутри.
[06:16.600 --> 06:21.960]  Копии — это именно копирование байтиков строго, а клоун — это то, что может имплементировать
[06:21.960 --> 06:29.480]  user, выводить что-то на экран, каким-то образом очень хитрым копировать и так далее. Так что
[06:29.480 --> 06:37.240]  давайте мы посмотрим вот на такой примерчик. Давайте мы сделаем bad clone, внутри которого
[06:37.240 --> 06:44.360]  будет какой-то дейта, это i32, и указатель, который представляет ссылку на какой-то CEL.
[06:44.360 --> 06:54.760]  Ссылку на CEL, которая внутри option на точно такую же структуру. Вот так вот. Примерно запомнили, если что, вернемся к слову.
[06:54.760 --> 07:04.840]  Это lifetime. Можешь пока что считать, что lifetime мы здесь написали просто потому, что нас компилятор попросил.
[07:04.840 --> 07:11.160]  Ну и вернемся к lifetime, буквально через лекцию две, и будем уже очень подробно говорить про то,
[07:11.160 --> 07:16.920]  почему это в расти необходимо. Это время жизни переменной, и конкретно время жизни ссылки.
[07:16.920 --> 07:23.240]  То есть ссылка не может пережить объект. Поэтому мы вынуждены это написать и на структуре повесить тоже такое ограничение.
[07:23.240 --> 07:38.120]  Ну пока что вот конкретно здесь ничего плохого нет. Если что, мы предполагаем, что у нас CEL на данный момент
[07:38.120 --> 07:42.840]  стандарт библиотеки стал на некоторое время именно clone. То есть просит именно clone, а не copy.
[07:42.840 --> 07:49.360]  Этим и отличается. Ну и давайте мы имплементируем clone для bad clone.
[07:49.360 --> 08:00.000]  Ну что мы делаем, мы берем ссылку на наш же дейта, выводим, ну просто выводим для наших целей,
[08:00.000 --> 08:10.960]  чтобы мы увидели какой будет результат дейта на экран. Потом мы, заметьте, мы очищаем наш текущий указатель, наш текущий, наш текущую ссылку.
[08:10.960 --> 08:20.880]  Вот. Давайте я даже убежусь, да. У нас ссылка на CEL здесь, если что, да? Вот ссылка на CEL и option.
[08:20.880 --> 08:28.400]  Вот я говорю, что этому CEL нужно установить pointer в now. То есть у нас там сейчас внутри нет никакого значения.
[08:28.400 --> 08:36.240]  Ну и после этого мы вводим какое-то новое значение. Ну и возвращаем новый bad clone.
[08:37.200 --> 08:42.800]  Вот такое вот хитрое что-то происходит. Давайте мы посмотрим, как это можно сломать.
[08:42.800 --> 08:49.120]  Если что, мы будем пересматривать слайды, если нам будет плохо понятно, так что не волнуйтесь.
[08:49.120 --> 08:58.800]  Вот. Создаю какой-то CEL, потом я создаю, ну делаю, устанавливаю значение CEL set сам bad clone.
[08:58.800 --> 09:06.160]  Ну и создаю bad clone соответственно. Какое-то значение у дейта есть и ссылка, это просто ссылка на текущий CEL.
[09:06.160 --> 09:15.280]  То есть по сути у меня на данный момент CEL указывает сам на себя, так. А потом я делаю CEL get.
[09:15.280 --> 09:23.760]  Когда я делаю CEL get, то в таком случае у нас происходит clone внутри.
[09:23.760 --> 09:30.560]  Потому что мы запросили теперь вместо copy clone. И соответственно получается, что у нас начали эти выводы работать, так.
[09:30.960 --> 09:33.920]  Мы пришли к этому коду, когда сделали get. Понимаете, да?
[09:36.160 --> 09:41.440]  Итак, у нас сейчас в дейте написано какое-то значение, а указатель — это нас же текущий CEL.
[09:45.200 --> 09:49.600]  Итак, и вот теперь мы берем какое-то, дейта — это ссылка на наша текущая данная,
[09:49.600 --> 09:54.800]  выводим наша текущая данная, которая у нас есть, там 1, 2, 3, 4, 5, 6, 7, 8.
[09:55.760 --> 09:59.360]  Потом говорим, что наш текущий CEL мы убираем просто, за нуляем.
[10:00.960 --> 10:04.400]  И после этого выводим его заново. Но дело в том, что он сам на себя указывал.
[10:05.680 --> 10:09.840]  И получается, тем самым вот user имплементировал такой от clone
[10:10.720 --> 10:14.320]  и получил undefinedBehaviour. Это один из возможных только выводов.
[10:16.080 --> 10:20.960]  Ну вот, например, ноль может вывестись. Соответственно, если у нас CEL будет с clone,
[10:20.960 --> 10:28.000]  то тогда это будет unsound. Unsound, напоминаю, означает то, что наша абстракция не является safe.
[10:32.640 --> 10:36.560]  Ну ты очистил CEL, который содержит дейт.
[10:50.960 --> 11:01.600]  А если бы мы свой CEL реализовали, то тогда что бы у нас вышло при запуске?
[11:01.600 --> 11:03.600]  У нас там паника была или что?
[11:03.600 --> 11:06.320]  Если бы мы реализовали свой CEL с clonem?
[11:06.320 --> 11:07.280]  Да.
[11:07.280 --> 11:10.560]  Ну вообще у нас это было бы safe, на самом деле.
[11:10.560 --> 11:13.280]  Мы сейчас увидим, как это работает.
[11:13.280 --> 11:18.560]  Там внутри CEL используется такая штука, называется unsafeCel.
[11:18.640 --> 11:21.920]  UnsafeCel – это просто то, что направо и налево нам раздают указатели.
[11:21.920 --> 11:23.920]  Она просто ничего не проверяет.
[11:23.920 --> 11:28.640]  Короче, проблема в том, что когда мы сделали CEL, ну у нас вот эти CEL поменялся незаметно.
[11:28.640 --> 11:32.640]  Да, у нас поменялся CEL, и соответственно, то, что мы дальше делаем, просто не валитно.
[11:36.640 --> 11:40.000]  Поэтому очень тяжело разрабатывать раз бывает.
[11:40.000 --> 11:42.880]  Ну не разрабатывать на раз, а разрабатывать именно раз,
[11:42.880 --> 11:47.920]  потому что вам нужно подумать о том, как сделать вашу абстракцию обязательно sound.
[11:48.000 --> 11:50.000]  Давайте чуть-чуть точним.
[11:50.000 --> 11:54.960]  Если вы пишете только safeCode и пользуетесь тем кодом, который safe,
[11:54.960 --> 11:59.040]  то в таком случае у вас любая абстракция будет sound,
[11:59.040 --> 12:01.040]  потому что вы использовались safeCode.
[12:01.040 --> 12:03.040]  Если вы пользуетесь unsafeCode,
[12:03.040 --> 12:07.120]  то вы должны убедиться в том, что ваша абстракция вокруг unsafeCode – sound.
[12:07.120 --> 12:09.760]  То есть то, что она безопасна и то, что она при любом импуте,
[12:09.760 --> 12:12.240]  не будет давать вам memory, unsafety, undefinedBehaviour.
[12:12.960 --> 12:19.040]  Это пример того, как можно было бы сделать unsound на стандартной библиотеке.
[12:19.040 --> 12:21.840]  Просто вы запросили forCell вместо copyClone.
[12:21.840 --> 12:26.320]  Теперь юзер может сделать себе undefinedBehaviour, просто что-то неправильно написано.
[12:26.320 --> 12:29.840]  Ну вот непонятно, зачем людей на нём ссавят вообще.
[12:29.840 --> 12:31.840]  Как его можно использовать?
[12:31.840 --> 12:33.840]  Мне кажется, вещи просто выкатывали или нет?
[12:33.840 --> 12:35.840]  Да, мы сейчас увидим это.
[12:35.840 --> 12:40.880]  Вообще вы, например, можете это увидеть в задачах домашних, в MPC, например.
[12:40.880 --> 12:46.880]  Там используется refcell для того, чтобы какой-то shard состояния поддерживать.
[12:46.880 --> 12:52.880]  Мы его хотим мутировать, и для того, чтобы это было безопасно, нам нужно использовать refcell.
[12:52.880 --> 12:59.280]  Я не буду спорить с тем, что на самом деле interiorMetability в однопоточном Rust-е – это overhead.
[12:59.280 --> 13:05.680]  То есть это вынужденная, скажем так, боль, которая появляется из-за того,
[13:05.680 --> 13:08.080]  что он хочет с одной стороны что-то через ссылку менять,
[13:08.080 --> 13:10.080]  и с другой стороны Rust хочет оставаться safe.
[13:10.080 --> 13:16.080]  Поэтому появляется вот такой вот компромисс в виде cell и refcell вынужденной.
[13:19.080 --> 13:24.080]  Поэтому это, наверное, та вещь, которая закономерного может не понравиться, действительно, в Rust.
[13:27.080 --> 13:29.080]  Вот, есть ещё refcell.
[13:29.080 --> 13:34.080]  Кстати говоря, вам же всё понятно, что мы сами себя убили только что.
[13:34.080 --> 13:38.080]  Получается, когда мы вот такой вот код исполнили, pointer set.
[13:40.080 --> 13:44.080]  Ну если что, посмотрите ещё, пересмотрите дома.
[13:44.080 --> 13:48.080]  Рисуйте и увидите, что там очищается.
[13:48.080 --> 13:50.080]  Вот.
[13:50.080 --> 13:54.080]  Refcell отличается от cell тем, что он возвращает ссылки.
[13:54.080 --> 14:00.080]  То есть он, если мы обновляем объект, он действительно туда моет объект,
[14:00.080 --> 14:06.080]  а если мы делаем get, то он вернёт ссылку, а get.mute вернёт, соответственно, табельную ссылку.
[14:06.080 --> 14:10.080]  Ну, на самом деле это, конечно, не get, а get.mute называется, а чуть по-другому.
[14:10.080 --> 14:16.080]  Ну и, соответственно, там внутри мутабельной и немутабельной ссылки подсчитывается,
[14:16.080 --> 14:20.080]  чтобы вы не сделали две мутабельные ссылки и, соответственно, не сломали фундаментальной гарантией Rust.
[14:20.080 --> 14:22.080]  А, да.
[14:22.080 --> 14:24.080]  Это варантейна, после которой происходит проверка тегажей гарантии?
[14:24.080 --> 14:26.080]  Да.
[14:26.080 --> 14:28.080]  Очень хорошо.
[14:28.080 --> 14:30.080]  Коператор просто не может проверить то, как ты пользуешься refcell,
[14:30.080 --> 14:36.080]  и приходится идти на такой к нам промес.
[14:36.080 --> 14:42.080]  У нас есть тут get и get.mute, а borrow, borrow.mute, которые возвращают какие-то ссылки на внутренний объект.
[14:42.080 --> 14:46.080]  Как вы можете заметить, это какие-то обёртки, не просто ссылки,
[14:46.080 --> 14:52.080]  а ref и ref.mute, которые при дропе будут что-то менять в сейдле, то есть счётчик внутренний.
[14:52.080 --> 14:58.080]  А get.mute это делает?
[14:58.080 --> 15:00.080]  Get.mute возвращает мутабельную ссылку,
[15:00.080 --> 15:04.080]  но он спаникует, если у тебя уже есть мутабельная ссылка, либо шаред-ссылка.
[15:06.080 --> 15:10.080]  Сейчас, можно вопросить про cell?
[15:10.080 --> 15:16.080]  Как мы вообще будем изменить int, например, если у нас rc или cell int, да?
[15:16.080 --> 15:18.080]  Я хочу его изменить.
[15:18.080 --> 15:22.080]  Ну, просто напишешь rc set и внутри поменяешь int.
[15:22.080 --> 15:24.080]  А, там не изменится set, окей.
[15:24.080 --> 15:28.080]  Просто такой вопрос, почему не всегда использовать ref cell?
[15:28.080 --> 15:33.080]  Ну, cell просто бывает эффективнее, когда у тебя небольшой копия типов.
[15:33.080 --> 15:35.080]  Ref cell именно ссылку возвращает.
[15:35.080 --> 15:39.080]  Тебе, возможно, не захочется ходить по ссылке лишний раз.
[15:39.080 --> 15:43.080]  Конечно, компилятор это соптимизирует с большой вероятностью, я не проверял, честно.
[15:43.080 --> 15:49.080]  Но кажется, что если вы в ref cell запихнёте int, то тогда он будет работать как просто cell.
[15:49.080 --> 15:51.080]  Просто потому что.
[15:51.080 --> 15:55.080]  Хотя по ссылке же всё равно, нет, он не соптимизирует это.
[15:55.080 --> 15:59.080]  То есть cell просто бывает эффективнее.
[16:09.080 --> 16:14.080]  Да, get mute, он проверяет, что ты действительно можешь сейчас получить мутабельную ссылочку.
[16:15.080 --> 16:19.080]  Ну, boro mute возвращает какую-то обёрточку ref.
[16:19.080 --> 16:22.080]  Она работает точно так же, как обычная ссылка.
[16:22.080 --> 16:26.080]  Но когда ref выйдет за свой scope, то есть drop произойдёт,
[16:26.080 --> 16:30.080]  оно тогда сделает минус в кантере внутренней ссылки.
[16:30.080 --> 16:35.080]  Boro mute, соответственно, сделает то же самое, только если boro считает shard ссылки,
[16:35.080 --> 16:39.080]  то это будет unique ссылки считать, mutable ссылки.
[16:39.080 --> 16:40.080]  Нет, не можешь.
[16:40.080 --> 16:44.080]  Если ты сделаешь второй раз boro mute, то в таком случае ты спаникуешь.
[16:44.080 --> 16:48.080]  А, там же ещё ref mute, оно может завершиться.
[16:48.080 --> 16:54.080]  А, да, оно спаникует, а там ещё есть try boro, try boro mute, которые возвращают ошибку.
[16:54.080 --> 16:57.080]  То есть не паникуют, а именно ошибку возвращают.
[17:00.080 --> 17:03.080]  Get mute и boro mute, в чем заключается?
[17:03.080 --> 17:07.080]  Ну, get mute, он именно проверяет то, что у тебя вообще ничего другого нет
[17:07.080 --> 17:09.080]  и паникует в случае, если не получилось.
[17:12.080 --> 17:14.080]  Не, погоди.
[17:18.080 --> 17:22.080]  Здесь видишь mutable и boro самого селфа происходят ещё внутри.
[17:22.080 --> 17:23.080]  Get mute.
[17:23.080 --> 17:24.080]  А где?
[17:24.080 --> 17:25.080]  А где?
[17:25.080 --> 17:26.080]  А где?
[17:26.080 --> 17:27.080]  А где?
[17:27.080 --> 17:28.080]  А где?
[17:28.080 --> 17:32.080]  Вот именно и boro самого селфа происходит ещё внутри get mute.
[17:32.080 --> 17:35.080]  А здесь происходит обычный boro селфа.
[17:37.080 --> 17:39.080]  То есть компилятор может на этом уровне ещё проверить.
[17:47.080 --> 17:52.080]  Так, просто, зачем мне вообще get mute когда-то использовать?
[17:52.080 --> 17:53.080]  get mute когда-то?
[17:53.080 --> 17:55.080]  Может, когда-то захочется.
[17:55.080 --> 18:00.080]  ты просто знаешь, что у тебя сейчас гарантированно
[18:00.080 --> 18:03.080]  один экземпляр, ну то есть нет вообще никаких экземпляров ссылок
[18:03.080 --> 18:06.080]  возможно тебе GetMute будет полезно сделать, чтобы
[18:06.080 --> 18:09.080]  иметь полный доступ
[18:09.080 --> 18:12.080]  ну да, GetMute эффективнее, потому что вместо счетчика ссылок
[18:12.080 --> 18:15.080]  у тебя компилятор есть
[18:21.080 --> 18:24.080]  ну и как я говорю, что достаточно такой распространенный паттерн
[18:24.080 --> 18:27.080]  использует cell и refcell вместе с rc
[18:27.080 --> 18:30.080]  rc для того, чтобы у нас
[18:30.080 --> 18:32.080]  rc сам по себе был safe
[18:32.080 --> 18:35.080]  ну, sound, abstraction, то он внутри
[18:35.080 --> 18:38.080]  делает немутабельными объекты
[18:38.080 --> 18:41.080]  свои, а для того, чтобы их мутировать, вам нужно
[18:41.080 --> 18:43.080]  использовать cell либо refcell
[18:43.080 --> 18:46.080]  очень отдаленно напоминает ключевое слово mutable в плюсах
[18:46.080 --> 18:49.080]  но на самом деле это не так, конечно
[18:49.080 --> 18:52.080]  как-то так
[18:52.080 --> 18:55.080]  вот, это здесь можно видеть пример
[18:55.080 --> 18:58.080]  того, как можно внутри листа
[18:58.080 --> 19:01.080]  ну, то есть как можно имплементировать лист
[19:01.080 --> 19:04.080]  на rc и refcell
[19:10.080 --> 19:13.080]  только он будет неэффективный, лучше так не делать
[19:13.080 --> 19:16.080]  то есть вообще в расте, писать в safe.raste
[19:16.080 --> 19:19.080]  любые структуры, которые друг другом владеют
[19:19.080 --> 19:22.080]  то есть здесь по сути две ноды будут друг другом владеть
[19:22.080 --> 19:25.080]  плохо, не надо так делать
[19:38.080 --> 19:41.080]  дерево?
[19:41.080 --> 19:44.080]  нет, у нас еще объестий нет
[19:44.080 --> 19:47.080]  объестий не нужно писать
[19:50.080 --> 19:53.080]  там бор, там не нужно
[19:53.080 --> 19:56.080]  ну, Боря, там эксклюзивное владение
[19:56.080 --> 19:59.080]  на все, а здесь получается друг другом владеют
[19:59.080 --> 20:02.080]  и соответственно получается, что нужно
[20:02.080 --> 20:05.080]  чтобы ты в runtime пересчитал все эти ссылки
[20:05.080 --> 20:08.080]  раз, к сожалению, можешь проверить это в compile time
[20:08.080 --> 20:11.080]  и заставлять тебя проверять это в runtime
[20:11.080 --> 20:14.080]  да, но они же друг другом не владеют
[20:14.080 --> 20:17.080]  ребенок не владеет родителем, например
[20:17.080 --> 20:20.080]  я буду исключительно вниз
[20:24.080 --> 20:27.080]  как же внутри работает refcell?
[20:27.080 --> 20:30.080]  как я уже сказал, там внутри используется unsafe code
[20:30.080 --> 20:33.080]  там есть такая штука, называется unsafe cell
[20:33.080 --> 20:36.080]  это будет такая небезопасная структура, которая
[20:36.080 --> 20:39.080]  не будет вообще ничего проверять, она будет просто нам
[20:39.080 --> 20:42.080]  строго возвращать какие-то указатели, ссылочки
[20:42.080 --> 20:45.080]  по нашему желанию
[20:45.080 --> 20:48.080]  это будут наши безопасные обертки вокруг этой структуры
[20:51.080 --> 20:54.080]  сейчас вот то, что мы посмотрим
[20:54.080 --> 20:57.080]  в домашней не используйте unsafe cell, во-первых, вы не сможете
[20:57.080 --> 21:00.080]  нормально попользоваться, потому что она unsafe
[21:00.080 --> 21:03.080]  во-вторых, в общем, пожалуйста, не пытайтесь
[21:03.080 --> 21:06.080]  это я просто вам показываю на данный момент для развития
[21:06.080 --> 21:09.080]  вот, unsafe cell выглядит так, максимально глупо
[21:09.080 --> 21:12.080]  там внутри просто значение какое-то, типа T
[21:12.080 --> 21:15.080]  а еще вопрос, а почему в стандартной библиотеке
[21:15.080 --> 21:18.080]  это связанный список не реализован?
[21:18.080 --> 21:21.080]  он реализован в стандартной библиотеке
[21:21.080 --> 21:24.080]  двухсвязанный, там же вроде двухсвязанный есть
[21:24.080 --> 21:27.080]  как раз там даже в библиотеке лист, который
[21:27.080 --> 21:30.080]  есть двухсвязанный
[21:35.080 --> 21:38.080]  у нас есть такие вот функции, которые возвращают
[21:38.080 --> 21:41.080]  либо pointer, либо ссылку
[21:41.080 --> 21:44.080]  на T
[21:44.080 --> 21:47.080]  ну и, соответственно, они
[21:47.080 --> 21:50.080]  являются все небезопасными, поэтому вы не сможете
[21:50.080 --> 21:53.080]  нормально попользоваться этим всем делом без unsafe кода
[21:53.080 --> 21:56.080]  для этого вам нужно, в общем, гарантировать
[21:56.080 --> 21:59.080]  гарантии REST, а давать самостоятельно своими руками
[22:02.080 --> 22:05.080]  соответственно, правильное определение cell и ref cell
[22:05.080 --> 22:08.080]  это выглядит примерно вот так
[22:08.080 --> 22:11.080]  cell, соответственно, внутри просто содержит это же значение
[22:11.080 --> 22:14.080]  с помощью unsafe cell, ну и его заменяет
[22:14.080 --> 22:17.080]  ref cell, как вы можете заметить, вот имеет какой-то
[22:17.080 --> 22:20.080]  boro flag и внутри unsafe cell
[22:20.080 --> 22:23.080]  интересно, почему здесь вот у boro есть
[22:23.080 --> 22:26.080]  сам используется cell внутри ref cell
[22:29.080 --> 22:32.080]  как вы думаете, почему так?
[22:38.080 --> 22:41.080]  а почему
[22:41.080 --> 22:44.080]  не просто boro flag?
[22:44.080 --> 22:47.080]  ну смотри, boro flag, наверное, где-то есть
[22:47.080 --> 22:50.080]  а нет, ну в общем, boro flag может считать, что там
[22:50.080 --> 22:53.080]  это просто yinam, на самом деле это не yinam
[22:53.080 --> 22:56.080]  в стандартной библиотеке, но это неважно, это означает
[22:56.080 --> 22:59.080]  одно и то же, внутри написано либо то, что
[22:59.080 --> 23:02.080]  нет никаких ссылок, либо какое-то
[23:02.080 --> 23:05.080]  количество shared ссылок какое-то указано
[23:05.080 --> 23:08.080]  либо mutable ссылка одна
[23:08.080 --> 23:11.080]  ну то есть там три варианта yinuma, с двумя понятно
[23:11.080 --> 23:14.080]  и у shared ссылки там еще число сколько shared ссылок
[23:31.080 --> 23:34.080]  ну, я не очень понял, что ты сказал
[23:34.080 --> 23:37.080]  все дело в том, что
[23:37.080 --> 23:40.080]  когда имеешь несколько ссылок, то
[23:40.080 --> 23:43.080]  для того, чтобы сам вообще вот этот вот
[23:43.080 --> 23:46.080]  вот этот вот флажок boro поменять, нужно через ссылку пройти
[23:46.080 --> 23:49.080]  то есть у вас interior rentability идет сам ref cell
[23:49.080 --> 23:52.080]  в данном случае
[23:52.080 --> 23:55.080]  поэтому приходится здесь тоже фигачить cell
[23:57.080 --> 24:00.080]  ну давайте сам еще раз
[24:00.080 --> 24:03.080]  так как мы не можем проверить наши варианты компиляторам
[24:03.080 --> 24:06.080]  и все это сдвинуть в runtime
[24:06.080 --> 24:09.080]  проверять в runtime
[24:09.080 --> 24:12.080]  в случае cell мы просто копируем значение
[24:12.080 --> 24:15.080]  ну и заметили то, что мы не можем использовать clone
[24:15.080 --> 24:18.080]  потому что это небезопасно
[24:18.080 --> 24:21.080]  в случае ref cell мы просто даем какую-то ссылку
[24:21.080 --> 24:24.080]  и считаем в runtime, чтобы все было безопасно
[24:24.080 --> 24:27.080]  а вот C++ у нас
[24:27.080 --> 24:30.080]  ну мы все равно должны подчиняться орднершупу
[24:30.080 --> 24:33.080]  потому что если мы не будем им подчиняться
[24:33.080 --> 24:36.080]  то у нас либо будет совсем не поддерживаемый код
[24:36.080 --> 24:39.080]  либо у нас будут какие-то баги
[24:42.080 --> 24:45.080]  ну в общем-то в плюсах вы это должны руками поддерживать
[24:45.080 --> 24:48.080]  то, что вы правильно модифицируете через ссылку
[24:48.080 --> 24:51.080]  и у вас ничего не ломается
[24:51.080 --> 24:54.080]  несмотря на то, что вы можете сделать ошибку, это на самом деле быстрее
[24:54.080 --> 24:57.080]  и использовать меньше памяти
[24:57.080 --> 25:00.080]  то есть если вы хотите использовать такой же в плюсах
[25:00.080 --> 25:03.080]  то вам нужно будет использовать unsafe код
[25:03.080 --> 25:06.080]  то есть если вы, например, захотите написать тот же самый лист
[25:06.080 --> 25:09.080]  вам нужно использовать unsafe код, потому что там есть
[25:09.080 --> 25:12.080]  ноды, которые владеют друг другу
[25:15.080 --> 25:18.080]  ну и вот такая вот общая фраза
[25:18.080 --> 25:21.080]  unsafe дает вам силу и ответственность C++
[25:21.080 --> 25:24.080]  вот это конклюзион нашей третьей лекции
[25:24.080 --> 25:27.080]  изучили, что такое трейты
[25:27.080 --> 25:30.080]  что такое Exotic Size Types
[25:30.080 --> 25:33.080]  ну подробно не опускались, но изучили, по крайней мере, что такое действие
[25:33.080 --> 25:36.080]  знали какое-то количество трейтов стандартной библиотеки
[25:36.080 --> 25:39.080]  сравнились с плюсами
[25:39.080 --> 25:42.080]  и, надеюсь, поняли, что такое интервью табилитики
[25:42.080 --> 25:45.080]  это правда, и я надеюсь, что вам понравилось
[25:45.080 --> 25:48.080]  и я надеюсь, что вам понравилось
[25:48.080 --> 25:51.080]  ну и вот и все, что у нас было
[25:51.080 --> 25:54.080]  надеюсь, поняли, что такое интервью табилитики
[25:54.080 --> 25:57.080]  это правда, или нет? Что-нибудь нужно рассказать?
[26:05.080 --> 26:08.080]  в таком случае давайте перейдем к следующей лекции
[26:08.080 --> 26:11.080]  на этой лекции мы изучим, что такое Cargo
[26:11.080 --> 26:14.080]  и что такое модуля
[26:14.080 --> 26:17.080]  научимся писать Rast code теперь уже не в одном файлике
[26:17.080 --> 26:23.400]  познакомиться с Cargo и с тем, как он управляет пакетами, но только на
[26:23.400 --> 26:26.080]  каком-то необходимом минимуме, а мы прям подробно искать не имеем.
[26:26.080 --> 26:29.080]  Будем сравнивать с системой сборки из мира плясов?
[26:29.080 --> 26:33.080]  Так, что ты сказал еще раз?
[26:33.080 --> 26:36.080]  Будем сравнивать с системой сборки из мира плясов?
[26:36.080 --> 26:41.080]  Это имеет мало смысла как-то. Ну посмотрим сейчас, увидим.
[26:41.080 --> 26:46.080]  В принципе нам понравится, я думаю, Cargo, это одна из самых крутейших фичей
[26:46.080 --> 26:51.080]  Раста. После овершипа, наверное, собственно, потому что он дает нам
[26:51.080 --> 26:54.080]  безопасность Раста. Без безопасности Раст бы, наверное, был примерно
[26:54.080 --> 26:58.080]  бесполезен, потому что какой смысл иметь язык, который все так же не
[26:58.080 --> 27:01.080]  безопасен, и все, что у него есть, это пакетный менеджер.
[27:01.080 --> 27:04.080]  Ну таких на самом деле уже много.
[27:04.080 --> 27:08.080]  Ну это на самом деле дополнительная фича, которая делает Раст
[27:08.080 --> 27:12.080]  крутым. Вот. Ну еще в конце, надеюсь, мы успеем
[27:12.080 --> 27:16.080]  полностью поставить на иператоры.
[27:16.080 --> 27:19.080]  На самом деле мы должны успеть, потому что Cargo это достаточно
[27:19.080 --> 27:22.080]  простая и быстрая тема.
[27:22.080 --> 27:27.080]  Вот. Cargo это пакетный менеджер Раста.
[27:27.080 --> 27:31.080]  В C и C++ таких нет. Абсолютно вообще нет никаких стандартизированных
[27:31.080 --> 27:36.080]  решений, там есть только какие-то разрозненные имплементации.
[27:36.080 --> 27:40.080]  Пакетных менеджер так вообще очень мало, систем сборки еще какие-то есть,
[27:40.080 --> 27:43.080]  но очень мало. Вот.
[27:43.080 --> 27:47.080]  То, что делает Cargo, это качает ваши зависимости.
[27:47.080 --> 27:51.080]  То есть, например, если вы какой-то крейт используете внешне,
[27:51.080 --> 27:55.080]  то есть читаете внешнюю библиотеку в своем проекте, то вам достаточно
[27:55.080 --> 27:59.080]  написать одну строчку в манифест Cargo, как мы сейчас увидим.
[27:59.080 --> 28:03.080]  Компилирует пакеты за вас, то есть он вызывает за вас
[28:03.080 --> 28:06.080]  компилятор Rasti.
[28:06.080 --> 28:09.080]  Капит, собственно, ваши пакеты, ну, как сказать, распространяемые,
[28:09.080 --> 28:12.080]  то есть публичными, заливает их на крейтсилу.
[28:12.080 --> 28:15.080]  То есть, чтобы им мог воспользоваться любой желающей.
[28:15.080 --> 28:19.080]  Ну и всякие другие вещи. Там есть, например, conditional compilation.
[28:19.080 --> 28:23.080]  Там можно писать произвольные скрипты для сборки, build scripts.
[28:23.080 --> 28:27.080]  Можно прикручивать другие языки, например, C.
[28:27.080 --> 28:32.080]  Вот. Ну, это мы все когда-нибудь посмотрим.
[28:32.080 --> 28:36.080]  Так, у меня чуть-чуть съехал, вот здесь вот мои нарсировали.
[28:36.080 --> 28:38.080]  Вот.
[28:38.080 --> 28:43.080]  Crate – это compilation unit Rasti, то есть это единицка компиляции.
[28:43.080 --> 28:46.080]  Это примерно то же самое, что и пакет в других языках.
[28:46.080 --> 28:50.080]  Ну, вы, наверное, слышали, что такое пакет, там, кого-нибудь Go.
[28:50.080 --> 28:52.080]  Это похоже.
[28:52.080 --> 28:55.080]  Вот это вот то, что можно сделать с помощью команды Cargo New Bean.
[28:55.080 --> 28:57.080]  Example.
[28:57.080 --> 29:01.080]  И получается примерно вот такой вот.
[29:01.080 --> 29:05.080]  Вот такого вида папочка.
[29:05.080 --> 29:07.080]  Если что, внутри Cargo Log по умолчанию не будет.
[29:07.080 --> 29:09.080]  Я вам показал, чтобы вы заранее обратили внимание,
[29:09.080 --> 29:14.080]  что когда вы что-то собираете, у вас еще появляются файлы Cargo Log.
[29:14.080 --> 29:16.080]  Мы посмотрим, зачем он нужен.
[29:16.080 --> 29:18.080]  Если он именно после сборки появляется.
[29:18.080 --> 29:23.080]  Да, после того, как ты первый раз собираешь пакет.
[29:23.080 --> 29:27.080]  Пакеты могут быть наши, ну, крейты, загружены на Crate SEAL.
[29:27.080 --> 29:30.080]  Это то, что поддерживается в комьюнити Rasta.
[29:30.080 --> 29:32.080]  Это Crate Registry.
[29:32.080 --> 29:35.080]  И в нем доступны все самые популярные пакеты.
[29:35.080 --> 29:41.080]  Ну, там, например, будем в какой-то момент изучать всякие от Tokio, Cert.
[29:41.080 --> 29:44.080]  Что там еще интересного есть.
[29:44.080 --> 29:47.080]  Хочу сказать, это что-то, что делают параллельные тераторы район.
[29:47.080 --> 29:49.080]  Вот вспомним о зоне.
[29:49.080 --> 29:51.080]  Мы будем смотреть на такие вот прикольные крейты,
[29:51.080 --> 29:53.080]  которые на самом деле настолько крутые,
[29:53.080 --> 29:57.080]  что в итоге даже увеличивают число платформ,
[29:57.080 --> 29:59.080]  на которых можно исполнять код.
[29:59.080 --> 30:03.080]  Я подробнее объясню, что это значит на соответствующей лекции.
[30:03.080 --> 30:05.080]  Там просто есть интересная статья в этом.
[30:10.080 --> 30:13.080]  Так, ну, вот примерно так выглядит файл Cargo ToML.
[30:13.080 --> 30:15.080]  Наверное, вы когда-нибудь у него заглядывали,
[30:15.080 --> 30:17.080]  когда делали домашку, что это такое.
[30:17.080 --> 30:20.080]  Как видите, ToML-формат
[30:20.080 --> 30:22.080]  это какой-то очень простой формат.
[30:22.080 --> 30:24.080]  Если вы знакомы с форматом имя,
[30:24.080 --> 30:26.080]  то это практически то же самое,
[30:26.080 --> 30:30.080]  но стандартизированное и, в общем-то,
[30:30.080 --> 30:32.080]  такой простой, хороший формат,
[30:32.080 --> 30:34.080]  в котором можно описать какие-то зависимости.
[30:36.080 --> 30:40.080]  Вот у нас есть такой вот package.
[30:40.080 --> 30:42.080]  Это как оно называется?
[30:42.080 --> 30:44.080]  В общем, entry.
[30:44.080 --> 30:48.080]  Есть entry-package, есть entry-dependencies.
[30:48.080 --> 30:50.080]  У нас здесь указано имя пакета,
[30:50.080 --> 30:52.080]  версия нашего пакета,
[30:52.080 --> 30:54.080]  edition пакета, мы сейчас узнаем, что это.
[30:54.080 --> 30:58.080]  И в dependencies я указал, для примера,
[30:58.080 --> 31:00.080]  пакет clap называется,
[31:00.080 --> 31:02.080]  который предназначен для того,
[31:02.080 --> 31:04.080]  чтобы парсить аргументы с командной строки.
[31:04.080 --> 31:08.080]  Например, на нем написан ровер.
[31:12.080 --> 31:14.080]  Вот, так.
[31:14.080 --> 31:17.080]  Cargo ToML содержит в себе несколько entry.
[31:17.080 --> 31:20.080]  Это некоторая часть из них.
[31:20.080 --> 31:22.080]  Package может быть имя пакета,
[31:22.080 --> 31:24.080]  версия пакета,
[31:24.080 --> 31:26.080]  указано списком автора пакета,
[31:26.080 --> 31:30.080]  edition само Rasta,
[31:30.080 --> 31:33.080]  версия компилятора минимальная для сборки,
[31:33.080 --> 31:35.080]  билд скрипты и прочее.
[31:35.080 --> 31:38.080]  Ну скрипты, они тоже на Rasti даже пишутся,
[31:38.080 --> 31:41.080]  и там можно собирать произвольный код,
[31:41.080 --> 31:43.080]  который даже не растовый.
[31:44.080 --> 31:47.080]  Потом есть dependencies, понятно,
[31:47.080 --> 31:49.080]  всякие версии пакетов,
[31:49.080 --> 31:51.080]  необходимые фичи,
[31:51.080 --> 31:53.080]  что такое фичи, тоже посмотрим.
[31:53.080 --> 31:55.080]  А фичи,
[31:55.080 --> 31:57.080]  сам entry у нас фичей означает
[31:57.080 --> 31:59.080]  какие-то дополнительные возможности
[31:59.080 --> 32:02.080]  нашего корыка пакета.
[32:02.080 --> 32:04.080]  Ну, например,
[32:04.080 --> 32:07.080]  давайте дальше по лекции покажу.
[32:07.080 --> 32:10.080]  У нас есть целая глава про фичи, посмотрим.
[32:10.080 --> 32:11.080]  Вот.
[32:11.080 --> 32:14.080]  Можно всякие написать,
[32:14.080 --> 32:18.080]  для dev, release, test и bench
[32:18.080 --> 32:19.080]  профайлов,
[32:19.080 --> 32:21.080]  написать то, как их компилировать.
[32:21.080 --> 32:23.080]  Например, сделать так, чтобы у вас
[32:23.080 --> 32:26.080]  всегда на O3 компилировался
[32:26.080 --> 32:28.080]  профайл dev,
[32:28.080 --> 32:31.080]  то есть это ровно означает debug.
[32:31.080 --> 32:33.080]  То есть, если у него пишется профайл dev,
[32:33.080 --> 32:35.080]  внутри укажете, что вы хотите,
[32:35.080 --> 32:36.080]  чтобы он компилировался
[32:36.080 --> 32:38.080]  с максимальной оптимизацией,
[32:38.080 --> 32:40.080]  то карга это сделает.
[32:40.080 --> 32:42.080]  По умолчанию, если что,
[32:42.080 --> 32:44.080]  там оптимизации нет никакой.
[32:44.080 --> 32:47.080]  То есть, вы можете указать для каждого профайла,
[32:47.080 --> 32:49.080]  как он компилируется
[32:49.080 --> 32:53.080]  и указывать даже новые какие-то профайлы.
[32:53.080 --> 32:55.080]  Вот.
[32:55.080 --> 32:58.080]  У крейтов есть несколько типов крейтов.
[32:58.080 --> 33:00.080]  Во-первых, bin – это, соответственно,
[33:00.080 --> 33:02.080]  просто приложение,
[33:02.080 --> 33:04.080]  runnable, executable
[33:04.080 --> 33:07.080]  и lib – это compiler recommended trust library.
[33:07.080 --> 33:09.080]  Оно имеет тип
[33:09.080 --> 33:11.080]  одной из следующих библиотек,
[33:11.080 --> 33:13.080]  которые четыре снизу указаны.
[33:13.080 --> 33:15.080]  Компиляторы выбирают среди них
[33:15.080 --> 33:16.080]  в зависимости от того,
[33:16.080 --> 33:17.080]  что вы компилируете,
[33:17.080 --> 33:18.080]  как вы компилируете,
[33:18.080 --> 33:21.080]  под какой платформе и все такое.
[33:21.080 --> 33:23.080]  Вот.
[33:23.080 --> 33:25.080]  Есть динамическая библиотека RAST.
[33:25.080 --> 33:27.080]  Это какой-то растовый формат,
[33:27.080 --> 33:31.080]  в котором динамически линкуется.
[33:31.080 --> 33:33.080]  Кстати, lib – это уже статическое
[33:33.080 --> 33:36.080]  системная библиотека.
[33:36.080 --> 33:38.080]  cdlib – это, соответственно,
[33:38.080 --> 33:39.080]  растовый код,
[33:39.080 --> 33:41.080]  компилируется в какой-то библиотеку,
[33:41.080 --> 33:42.080]  которая может быть вызвана
[33:42.080 --> 33:45.080]  даже си, не динамическую.
[33:45.080 --> 33:47.080]  rlib – это такая статическая
[33:47.080 --> 33:48.080]  растовая библиотека,
[33:48.080 --> 33:49.080]  которую вы можете переликовать
[33:49.080 --> 33:52.080]  в своей программе.
[33:52.080 --> 33:53.080]  Вот.
[33:53.080 --> 33:55.080]  Ну и, соответственно, bin…
[33:55.080 --> 33:57.080]  процмакро еще есть тип.
[33:57.080 --> 33:59.080]  Мы с ним познакомимся буквально
[33:59.080 --> 34:01.080]  примерно на следующей лекции,
[34:01.080 --> 34:04.080]  узнаем, что такое макросы процедурные,
[34:04.080 --> 34:07.080]  и будем их писать.
[34:07.080 --> 34:08.080]  Вообще предполагается,
[34:08.080 --> 34:09.080]  что bin и lib
[34:09.080 --> 34:10.080]  будут хватать примерно
[34:10.080 --> 34:13.080]  для всех ваших типов проектов.
[34:13.080 --> 34:14.080]  Но если вам захочется,
[34:14.080 --> 34:15.080]  то вы можете указывать
[34:15.080 --> 34:16.080]  более конкретно,
[34:16.080 --> 34:17.080]  как вы хотите,
[34:17.080 --> 34:19.080]  чтобы ваш проект компилировался.
[34:19.080 --> 34:20.080]  То есть вот эти все типы,
[34:20.080 --> 34:21.080]  они вам нужны
[34:21.080 --> 34:22.080]  только тогда,
[34:22.080 --> 34:23.080]  когда вы хотите
[34:23.080 --> 34:28.080]  что-то ручками очень точно поменять.
[34:28.080 --> 34:29.080]  Вот.
[34:29.080 --> 34:31.080]  Версии в Cargo.
[34:31.080 --> 34:32.080]  Вот мы видели версию
[34:32.080 --> 34:33.080]  нашего пакета,
[34:33.080 --> 34:34.080]  версии наших зависимости.
[34:34.080 --> 34:35.080]  Они все изменяются
[34:35.080 --> 34:36.080]  согласно такой штуке
[34:36.080 --> 34:38.080]  «назвать всем вер».
[34:38.080 --> 34:41.080]  Вы слышали о ней?
[34:41.080 --> 34:42.080]  Ну, вот так вот,
[34:42.080 --> 34:43.080]  примерно слышали, да.
[34:43.080 --> 34:44.080]  На самом деле,
[34:44.080 --> 34:45.080]  это такой индустриальный формат,
[34:45.080 --> 34:46.080]  который используется
[34:46.080 --> 34:48.080]  во многих пакетных менеджерах.
[34:48.080 --> 34:51.080]  Например, в npm используется.
[34:51.080 --> 34:52.080]  Вот.
[34:52.080 --> 34:53.080]  Он выглядит так.
[34:53.080 --> 34:54.080]  Там есть…
[34:54.080 --> 34:55.080]  Ну, на самом деле,
[34:55.080 --> 34:56.080]  я рассказываю его вариацию
[34:56.080 --> 34:57.080]  для Cargo конкретно
[34:57.080 --> 35:00.080]  в немножко упрощенном виде.
[35:00.080 --> 35:01.080]  Вот.
[35:01.080 --> 35:02.080]  Там есть такие вот
[35:02.080 --> 35:03.080]  три циферки,
[35:03.080 --> 35:04.080]  три числа.
[35:04.080 --> 35:05.080]  Мажор,
[35:05.080 --> 35:06.080]  минор и патч.
[35:06.080 --> 35:07.080]  Мажор – это
[35:07.080 --> 35:08.080]  мажорная версия.
[35:08.080 --> 35:09.080]  Она показывает,
[35:09.080 --> 35:12.080]  что вы сделали какое-то
[35:12.080 --> 35:13.080]  изменение API,
[35:13.080 --> 35:14.080]  которое, в общем-то,
[35:14.080 --> 35:15.080]  изменяет тотальное поведение
[35:15.080 --> 35:16.080]  вашей библиотеки.
[35:16.080 --> 35:17.080]  Например,
[35:17.080 --> 35:18.080]  поудаляли какие-то
[35:18.080 --> 35:21.080]  публичные функции,
[35:21.080 --> 35:22.080]  добавили там,
[35:22.080 --> 35:23.080]  не знаю,
[35:23.080 --> 35:24.080]  полностью переработали
[35:24.080 --> 35:25.080]  то, как у вас
[35:25.080 --> 35:26.080]  это работает,
[35:26.080 --> 35:27.080]  и так далее.
[35:27.080 --> 35:31.080]  Минорно – это когда вы
[35:31.080 --> 35:32.080]  добавляете какой-то
[35:32.080 --> 35:33.080]  функционал,
[35:33.080 --> 35:34.080]  и это обратно совместимо.
[35:34.080 --> 35:35.080]  Ну, то есть, например,
[35:35.080 --> 35:36.080]  добавили новую
[35:36.080 --> 35:37.080]  публичную функцию,
[35:37.080 --> 35:38.080]  в которую он добавляет
[35:38.080 --> 35:39.080]  каких-то фичей,
[35:39.080 --> 35:41.080]  но при этом не ломает то,
[35:41.080 --> 35:42.080]  что у вас уже есть.
[35:42.080 --> 35:43.080]  И патч – это, соответственно,
[35:43.080 --> 35:44.080]  когда вы делаете
[35:44.080 --> 35:45.080]  какие-то багфиксы.
[35:45.080 --> 35:46.080]  Вот.
[35:46.080 --> 35:49.080]  А что значит must be changed?
[35:49.080 --> 35:54.080]  Вот это хороший вопрос.
[35:54.080 --> 35:55.080]  Потому что кажется,
[35:55.080 --> 35:56.080]  что ничто не мешает
[35:56.080 --> 35:59.080]  версионировать как дату.
[35:59.080 --> 36:00.080]  Нет, смотри,
[36:00.080 --> 36:01.080]  на самом деле мешает.
[36:01.080 --> 36:02.080]  Да, и что?
[36:02.080 --> 36:03.080]  Во-первых,
[36:03.080 --> 36:04.080]  потому что,
[36:04.080 --> 36:05.080]  ну,
[36:05.080 --> 36:06.080]  вот это вот
[36:06.080 --> 36:07.080]  cal-ver,
[36:07.080 --> 36:08.080]  по-моему, называется,
[36:08.080 --> 36:09.080]  когда ты как календарик
[36:09.080 --> 36:10.080]  это меняешь,
[36:10.080 --> 36:11.080]  это на самом деле
[36:11.080 --> 36:12.080]  не соответствует тому,
[36:12.080 --> 36:13.080]  как устроено вообще,
[36:13.080 --> 36:14.080]  в общем,
[36:14.080 --> 36:15.080]  как устроено
[36:15.080 --> 36:16.080]  версионирование пакетов
[36:16.080 --> 36:17.080]  всем вере,
[36:17.080 --> 36:18.080]  то есть они не совместимы.
[36:18.080 --> 36:19.080]  Это, во-первых,
[36:19.080 --> 36:20.080]  во-вторых,
[36:20.080 --> 36:21.080]  cargo,
[36:21.080 --> 36:22.080]  он, соответственно,
[36:22.080 --> 36:23.080]  выбирает версии
[36:23.080 --> 36:24.080]  ваших зависимости.
[36:24.080 --> 36:25.080]  Ну, мы там посмотрим
[36:25.080 --> 36:26.080]  буквально на следующем слайде,
[36:26.080 --> 36:27.080]  как он будет менять
[36:27.080 --> 36:28.080]  эти вот,
[36:28.080 --> 36:29.080]  выбирать эти зависимости.
[36:29.080 --> 36:30.080]  Это не соответствует
[36:30.080 --> 36:31.080]  тому,
[36:31.080 --> 36:32.080]  как выбирает
[36:32.080 --> 36:33.080]  и резолвет
[36:33.080 --> 36:34.080]  зависимости cargo,
[36:34.080 --> 36:35.080]  соответственно,
[36:35.080 --> 36:36.080]  сломается компиляция,
[36:36.080 --> 36:37.080]  если ты видишь,
[36:37.080 --> 36:38.080]  как cal-ver.
[36:38.080 --> 36:39.080]  Ну, это так,
[36:39.080 --> 36:40.080]  небольшая проблема.
[36:40.080 --> 36:41.080]  Ну, ты можешь, конечно,
[36:41.080 --> 36:42.080]  это делать
[36:42.080 --> 36:43.080]  для какого-нибудь
[36:43.080 --> 36:44.080]  своего бинарника,
[36:44.080 --> 36:45.080]  потому что бинарник
[36:45.080 --> 36:46.080]  он только для тебя,
[36:46.080 --> 36:47.080]  грубо говоря,
[36:47.080 --> 36:48.080]  никакие зависимости
[36:48.080 --> 36:49.080]  ему не пользуются.
[36:49.080 --> 36:50.080]  Ну, тут такое дело,
[36:50.080 --> 36:51.080]  что если ты пишешь
[36:51.080 --> 36:52.080]  в библиотеку,
[36:52.080 --> 36:53.080]  строго следует всем веру,
[36:53.080 --> 36:54.080]  потому что
[36:54.080 --> 36:55.080]  это, по сути,
[36:55.080 --> 36:56.080]  единственный недостаток
[36:56.080 --> 36:57.080]  всем веры,
[36:57.080 --> 36:58.080]  то, что люди
[36:58.080 --> 36:59.080]  вынуждены ему следовать.
[36:59.080 --> 37:00.080]  Если они
[37:00.080 --> 37:01.080]  что-то ломают,
[37:01.080 --> 37:02.080]  например,
[37:02.080 --> 37:03.080]  меняют
[37:03.080 --> 37:04.080]  мажорную версию,
[37:04.080 --> 37:05.080]  когда они сделали
[37:05.080 --> 37:06.080]  backfix
[37:06.080 --> 37:07.080]  или, например,
[37:07.080 --> 37:08.080]  сделали backfix
[37:08.080 --> 37:09.080]  и,
[37:09.080 --> 37:10.080]  не так,
[37:10.080 --> 37:11.080]  давайте поменяли
[37:11.080 --> 37:12.080]  там, допустим,
[37:12.080 --> 37:13.080]  API,
[37:13.080 --> 37:14.080]  при этом
[37:14.080 --> 37:15.080]  поменяли
[37:15.080 --> 37:16.080]  мажорную версию.
[37:16.080 --> 37:17.080]  И в таком случае
[37:17.080 --> 37:18.080]  cargo, он считает,
[37:18.080 --> 37:19.080]  у него есть контракт,
[37:19.080 --> 37:20.080]  что вы всем верам следуете,
[37:20.080 --> 37:21.080]  он поменяет
[37:21.080 --> 37:22.080]  образом версии
[37:22.080 --> 37:23.080]  и у вас ничего
[37:23.080 --> 37:24.080]  не скомпилируется.
[37:24.080 --> 37:25.080]  Все.
[37:25.080 --> 37:26.080]  Ну, то есть,
[37:26.080 --> 37:27.080]  это очень-очень важно,
[37:27.080 --> 37:28.080]  следовать именно
[37:28.080 --> 37:29.080]  строго всем веру.
[37:29.080 --> 37:30.080]  Это его
[37:30.080 --> 37:31.080]  серьезный недостаток,
[37:31.080 --> 37:32.080]  потому что,
[37:32.080 --> 37:33.080]  если вы от него
[37:33.080 --> 37:34.080]  отходите,
[37:34.080 --> 37:35.080]  то в таком случае
[37:35.080 --> 37:36.080]  все начинает ломаться.
[37:36.080 --> 37:37.080]  В остальном,
[37:37.080 --> 37:38.080]  всем веры – это прекрасная вещь.
[37:38.080 --> 37:39.080]  Вот.
[37:39.080 --> 37:40.080]  Так.
[37:40.080 --> 37:41.080]  У нас есть
[37:41.080 --> 37:42.080]  ну,
[37:42.080 --> 37:43.080]  примеры того,
[37:43.080 --> 37:44.080]  как у нас
[37:44.080 --> 37:45.080]  должна меняться версия.
[37:45.080 --> 37:46.080]  Например,
[37:46.080 --> 37:47.080]  у нас была
[37:47.080 --> 37:48.080]  версия 1.3.7,
[37:48.080 --> 37:49.080]  мы сделали какой-то
[37:49.080 --> 37:50.080]  backfix,
[37:50.080 --> 37:51.080]  стало 1.3.8.
[37:51.080 --> 37:52.080]  Была версия 1.5.5,
[37:52.080 --> 37:53.080]  добавили какие-то
[37:53.080 --> 37:54.080]  новые функции,
[37:54.080 --> 37:55.080]  стало 1.6.0.
[37:55.080 --> 37:56.080]  То есть,
[37:56.080 --> 37:57.080]  зановили версию патча
[37:57.080 --> 37:58.080]  и поменяли
[37:58.080 --> 37:59.080]  минорную версию.
[37:59.080 --> 38:00.080]  Ну, соответственно,
[38:00.080 --> 38:01.080]  мажорный там апдейд,
[38:01.080 --> 38:02.080]  там очень сильно
[38:02.080 --> 38:03.080]  все поменяли
[38:03.080 --> 38:04.080]  и поменяли версию
[38:04.080 --> 38:05.080]  1.7.2 в 2.0.
[38:05.080 --> 38:06.080]  Как-то раз вот,
[38:06.080 --> 38:07.080]  не помню,
[38:07.080 --> 38:08.080]  какая библиотека была,
[38:08.080 --> 38:09.080]  но было такое,
[38:09.080 --> 38:10.080]  что они поменяли
[38:10.080 --> 38:11.080]  версию на 2.0,
[38:11.080 --> 38:12.080]  но было очень много
[38:12.080 --> 38:13.080]  пользователей,
[38:13.080 --> 38:14.080]  которые оставались
[38:14.080 --> 38:15.080]  на 1.x,
[38:15.080 --> 38:16.080]  в общем,
[38:16.080 --> 38:17.080]  дальше в версии.
[38:17.080 --> 38:18.080]  Для того,
[38:18.080 --> 38:19.080]  чтобы такого не было,
[38:19.080 --> 38:20.080]  что они поддерживают
[38:20.080 --> 38:21.080]  код из старой и новой,
[38:21.080 --> 38:22.080]  они сделали так,
[38:22.080 --> 38:23.080]  что следующая версия
[38:23.080 --> 38:24.080]  1.x,
[38:24.080 --> 38:25.080]  она просто
[38:25.080 --> 38:26.080]  оборачивала
[38:26.080 --> 38:27.080]  вокруг себя
[38:27.080 --> 38:28.080]  API 2.0 версии.
[38:28.080 --> 38:29.080]  То есть,
[38:29.080 --> 38:30.080]  таким образом,
[38:30.080 --> 38:31.080]  они продолжали
[38:31.080 --> 38:32.080]  поддерживать только
[38:32.080 --> 38:33.080]  новую версию API,
[38:33.080 --> 38:34.080]  но при этом
[38:34.080 --> 38:35.080]  старые пользователи
[38:35.080 --> 38:36.080]  продолжали пользоваться
[38:36.080 --> 38:37.080]  кодом в том виде,
[38:37.080 --> 38:38.080]  в котором они
[38:38.080 --> 38:39.080]  пользовались им до этого.
[38:39.080 --> 38:40.080]  Так,
[38:40.080 --> 38:41.080]  ну,
[38:41.080 --> 38:42.080]  ну,
[38:42.080 --> 38:43.080]  ну,
[38:43.080 --> 38:44.080]  ну,
[38:44.080 --> 38:45.080]  ну,
[38:45.080 --> 38:46.080]  ну,
[38:46.080 --> 38:47.080]  ну,
[38:47.080 --> 38:48.080]  ну,
[38:48.080 --> 38:49.080]  ну,
[38:49.080 --> 38:50.080]  ну,
[38:50.080 --> 38:51.080]  ну,
[38:51.080 --> 38:52.080]  ну,
[38:52.080 --> 38:53.080]  ну,
[38:53.080 --> 38:54.080]  chaos,
[38:54.080 --> 38:55.080]  chaos,
[38:55.080 --> 38:56.080]  onu,
[38:56.080 --> 38:57.080]  ой вот это
[38:57.080 --> 38:58.080]  ой вот это
[38:58.080 --> 38:59.080]  ой вот это
[38:59.080 --> 39:00.080]  ой вот это
[39:00.080 --> 39:01.080]  ой
[39:01.080 --> 39:02.080]  ой вот это
[39:02.080 --> 39:03.080]  ой вот это
[39:03.080 --> 39:04.080]  ой вот это
[39:04.080 --> 39:05.080]  ой вот это
[39:05.080 --> 39:06.080]  ой вот это
[39:06.080 --> 39:10.080]  хо
[39:10.080 --> 39:11.080]  пе
[39:11.080 --> 39:12.080]  пе
[39:12.080 --> 39:13.080]  ой
[39:13.080 --> 39:14.080]  про
[39:14.080 --> 39:15.080]  ид
[39:15.080 --> 39:21.320]  релиз поэтому версия мажорная часто нулём является в рамках раз-то ну если
[39:21.320 --> 39:26.080]  вы будете смотреть на карито и в этом случае у карга есть специальное правило что если
[39:26.080 --> 39:30.320]  у вас мажорная версия ноль то в таком случае minor то есть вторая циферка это
[39:30.320 --> 39:33.920]  мажор а патч это minor
[39:36.520 --> 39:41.280]  ну смотри ты только-только сделал свою прекрасную библиотеку она у тебя не
[39:41.280 --> 39:45.480]  финально ты будешь каждый день там менять и полностью ломать в ней аппи как
[39:45.480 --> 39:52.560]  хочешь но ты хочешь ставить мажорную версию нулём потому что если ты сделаешь
[39:52.560 --> 39:56.160]  единичкой то в следующем релизе понадобится сделать согласно симвера уже
[39:56.160 --> 40:00.320]  двоечкой потому что ты там серьезно что-то поменял
[40:00.320 --> 40:11.360]  да то есть карга этому соглашению следует в таких случая кстати говоря
[40:11.360 --> 40:17.240]  советуют выкладывать свои библиотеки на гитхаб то есть там можно написать из
[40:17.240 --> 40:23.080]  какого репозитория из какой ревизии вы качаете свой пакет собирайте ну то есть
[40:23.080 --> 40:29.120]  использовать именно ну в общем гит репозитория не заливать на крейтс его
[40:29.120 --> 40:32.680]  потому что иначе в таких случаях людей может быть не предсказуемый спецэффекты
[40:32.680 --> 40:38.000]  что у них обновилась версия и вы там все сломали вот когда все часто меняется
[40:38.000 --> 40:46.800]  там начальных этапах достаточно сложно у нас тут что-то сломалось да это это
[40:46.800 --> 41:01.080]  должна была быть вот это вот это да она что-то уехала так карга то мл если вы
[41:01.080 --> 41:05.560]  будете писать не просто версию напишите то есть если вы напишите версию то карга
[41:05.560 --> 41:10.000]  будет выбирать любую совместимую то есть по сути это то же самое что вы
[41:10.000 --> 41:14.400]  напишете вот эту вот галочку семер компейт будет то есть соответственно
[41:14.400 --> 41:19.640]  если вы напишите 1 2 3 то в таком случае карга выберет любую версию которая
[41:19.640 --> 41:28.080]  меньше 2 0 потому что они подходят потом если вы напишите тильду который тут не
[41:28.080 --> 41:32.440]  видно то в таком случае он будет выбирать по последней только циферки то есть под
[41:32.440 --> 41:35.240]  циферки бак фиксов
[41:35.240 --> 41:47.880]  может погромче смотри здесь ведь dependences здесь можно написать конкретную
[41:47.880 --> 41:52.360]  версию либо крышечку и конкретную версию в таком случае у тебя карга
[41:52.360 --> 41:56.560]  будет выбирать любую версию меньше чем 4 0 то есть он скачает любую там
[41:56.560 --> 42:02.160]  последнюю которая есть на крейтс его и будет именно с ней комплирует твой
[42:02.160 --> 42:04.160]  пакет
[42:07.440 --> 42:13.080]  вот ну то же самое стиль да и у нас будет изменяться только минорная версия
[42:13.080 --> 42:18.720]  абсолютно аналогично вот со звездочкой любая любая минорная может написать
[42:18.720 --> 42:22.040]  больше ли бы равно 1 2 тогда карга уберет вообще любую версию который больше
[42:22.040 --> 42:25.440]  либо ровно текущий вот
[42:35.440 --> 42:38.760]  нас кстати говоря всех задачах написано больше либо равно не знаю на
[42:38.760 --> 42:43.360]  сколько это хорошо но я подумал для вас что лучше если вдруг серьезно
[42:43.360 --> 42:49.320]  поменяться библиотека я это прямо знаю и прям починю что-то в задаче чем если
[42:49.320 --> 42:53.640]  она будет постоянно одной версии когда я буду во второй раз проводить курс у
[42:53.640 --> 42:57.440]  нас там неожиданно сломать половину задачи
[43:05.840 --> 43:11.080]  теперь давайте выясним что такое карга тмл и карга лог то мл он объясняет
[43:11.080 --> 43:15.720]  какова зависимости на так в общем смысле например указываете что я там хочу
[43:15.720 --> 43:20.160]  версию 3 0 да и в таком случае карга будет соответствующий всем вер версию
[43:20.160 --> 43:26.680]  меньше четырех выбирать карга лог это уже соответственно карга как пакетный
[43:26.680 --> 43:30.280]  менеджер он же рисовывает прям зависимости какие там нужно пакеты
[43:30.280 --> 43:36.120]  прелинковать что как скомпилировать и карга лог содержит конкретно какую
[43:36.120 --> 43:42.720]  версию нужно скачать и к чему я нужно присобачить то есть это уже результат
[43:42.720 --> 43:54.720]  какой-то работы карга это не нужно руками изменить вот вот как раз узнаем
[43:54.720 --> 44:03.480]  сейчас вообще цель карга лог это объяснить указать какие были версии
[44:03.480 --> 44:10.360]  зависимости в последний момент когда у вас пакет успешно собрался но это очень
[44:10.360 --> 44:17.080]  ну в общем-то очень хорошо хорошо добавлять например в гид этот файл
[44:17.080 --> 44:22.000]  и карга лог когда вы например бинарник какой-то собираете вот если чтобы у вас
[44:22.000 --> 44:26.480]  пользователь просто скачал ваш библиотеку просто собрал то есть там
[44:26.480 --> 44:29.840]  зависимости вы зарисовывались точно так же как у вас точно также собралась
[44:29.840 --> 44:34.280]  библиотека и все ура с теми же зависимости
[44:34.280 --> 44:42.280]  это неправда это в гид игнор не нужно добавлять в случае бинарников а вот
[44:42.280 --> 44:47.120]  в случае библиотеку как раз лучше добавить потому что библиотека от нее как
[44:47.120 --> 44:52.960]  раз зависит пакет то есть у нее есть какие-то даун стрим пакеты которая ей
[44:52.960 --> 44:57.960]  пользуется соответственно если вы укажете там карга лог в таком случае у
[44:57.960 --> 45:03.400]  карга карга будет не очень хорошо когда он увидит этот блок файл он будет
[45:03.400 --> 45:08.520]  вынужден использовать какие-то дополнительные дополнительные пакет
[45:08.520 --> 45:12.580]  скажем так библиотека просто не видит всей ситуации и хочется видеть
[45:12.580 --> 45:18.480]  конкретно в общем лучше чтобы именно бинарник создавал вот этот весь лог
[45:18.480 --> 45:25.360]  файл вот потому что он видит всю ситуацию какие у него зависимости какие
[45:25.360 --> 45:28.480]  зависимости у зависимости там все рисовывается и создается конкретный
[45:28.480 --> 45:33.160]  файл а вот в случае библиотеки это уже неправда потому что она знает только
[45:33.160 --> 45:37.960]  там не дальше своего носа что чем она пользуется тем она максимум
[45:37.960 --> 45:43.720]  руководствуется поэтому лучше всего не добавлять карга лог файлик карга лог
[45:43.720 --> 45:50.040]  в гитагнор в случае библиотеки это понятно
[46:00.720 --> 46:09.360]  это просто то что в конце сделает карга во что скомпилировать не по сути ты
[46:09.360 --> 46:15.920]  выбираешь только либо бин либо лип ты можешь выбрать конечно и там ди лип
[46:15.920 --> 46:23.520]  да тебе большинство ситуации либо бин либо лип хватит это просто для общего
[46:23.520 --> 46:26.000]  развития показал
[46:30.800 --> 46:38.280]  так есть еще такой такой бинарник карга эдит вы можете его поставить с помощью
[46:38.280 --> 46:43.600]  карга инстал карга эдит и сможете модифицировать свой файлик карга то мэль
[46:43.600 --> 46:49.120]  может обновлять в библиотеке в карга то мэль то есть сам парсит ваш файлик то
[46:49.120 --> 46:54.160]  мэль и ходит на крейс и усмотреть какие последние версии пакетов и заменяет их
[46:54.160 --> 46:59.200]  просто иногда бывает полезно воспользоваться тем бинарником он за вас меняет
[46:59.200 --> 47:01.320]  версии
[47:02.440 --> 47:08.240]  например upgrade еще все все зависимости на последний меняет версию
[47:08.240 --> 47:20.920]  так интересно вот у раз тоже тоже есть версии вот последняя стабильная 1.59 и на
[47:20.920 --> 47:32.160]  самом деле тоже 1.59 но в случае nightly там 1.61 кажется то есть это только для
[47:32.760 --> 47:42.560]  раз на самом деле тоже меняет свои версии согласно всем веру до версии 1.0 раз
[47:42.560 --> 47:47.120]  точно также как и вообще любое любая библиотека любое приложение она очень
[47:47.120 --> 47:52.160]  часто менялась очень сильно меняется любое приложение и раз тоже менялся ему
[47:52.160 --> 47:56.400]  было сложно дать какие-то гарантии пользователям там плыть до того что если
[47:56.400 --> 47:59.560]  вы посмотрите какие-то ранние версии раз-то совсем не похоже по синтаксису
[47:59.560 --> 48:04.840]  разве что только по идее что хочется в конце иметь ну после того как раз
[48:04.840 --> 48:08.320]  дошел до 1.0 ему нужно было принять решение как же дальше
[48:08.320 --> 48:12.000]  будут меняться версии чтобы дать пользователям гарантии что у нас код
[48:12.000 --> 48:17.120]  будет хорошо компилироваться то есть вы написали например программу что она
[48:17.120 --> 48:21.480]  вас компилируется на каких-то более поздних версиях компилятора
[48:22.040 --> 48:29.320]  вот для этого они перешли вот на такую штуку которая называется она вот модель
[48:29.320 --> 48:35.320]  стабильность без голодания
[48:39.320 --> 48:45.520]  простой на стабильность просто это модель была впервые появилась в веб
[48:45.520 --> 48:51.040]  браузерах и используется конкретная модификация для именно компилятора самого
[48:51.040 --> 48:56.760]  вот это наверное так все чтобы вы не сделали ну то есть все что не делается в
[48:56.760 --> 49:04.160]  компиляторе раз-то оно сразу же приземляется так в мастер бранч сразу что
[49:04.160 --> 49:10.800]  да мерзится и все каждую ночь каждый день ночь не знаю по какому времени это
[49:10.800 --> 49:14.960]  происходит но в общем-то мастер превращается в на это и релиз как вы
[49:14.960 --> 49:18.400]  понимаете если что-то только закомитилась там может потенциально
[49:18.400 --> 49:24.320]  например что-то сломаться поэтому на эти это небезопасная штука и на ней но ее
[49:24.320 --> 49:32.720]  нужно выбирать осознанно чтобы у вас если что-то сломать то сам виноват в
[49:32.720 --> 49:36.600]  общем-то вот только стейбл вам дает какие-то гарантии
[49:36.600 --> 49:44.880]  каждые 6 недель создается бета из текущего состояния мастера и ну то есть
[49:44.880 --> 49:48.560]  для того чтобы найти оно постепенно тестируется там какие-то бакфиксы
[49:48.560 --> 49:52.000]  происходят в том раз 6 недель об давайте создадим из текущего на эти
[49:52.000 --> 49:56.480]  релизы назовем его бэдкой потому что у нас появились за эти 6 недель новая
[49:56.480 --> 49:58.960]  коммита новая фичи давайте мы сделаем новую версию
[49:58.960 --> 50:08.200]  зима бета вот и и в общем-то другая прошлая бета то есть раз 6 недель тоже
[50:08.200 --> 50:12.760]  происходит прошлая бета становится стабильным релизом раз то есть раз по
[50:12.760 --> 50:15.840]  сути обновляется раз в 6 недель
[50:15.840 --> 50:19.840]  вот так что каждый день выходит
[50:20.840 --> 50:27.840]  это на это но у него же тоже есть версии ну да
[50:29.840 --> 50:34.920]  точно также как и вообще у раз то есть например следующая стабильный релиз раз
[50:34.920 --> 50:44.760]  то по моему должен быть 1 61 что-то вроде бы не вроде бы 1 61
[50:46.120 --> 50:50.200]  ну то есть найти он версионируется а потом в какой-то момент просто
[50:50.200 --> 50:56.960]  становится один из релизов стейбом как-то так примерно также работает во
[50:56.960 --> 51:02.560]  браузере свое версионируем то есть вообще вкратце у вас есть три канала это
[51:02.560 --> 51:06.080]  найти бета и стейбом найти это прям совсем нестабильно только вот работа
[51:06.080 --> 51:10.800]  вышла и меньше суток бета это что-то что уже по крайней мере плюс-минус
[51:10.800 --> 51:17.000]  опробировалась и прямо сейчас она является релиз кандидейт и стейбл это то
[51:17.000 --> 51:20.400]  что уже пробировал с пользователем по крайней мере 6 недель всем все понравилось
[51:20.400 --> 51:28.320]  и вот стейбл успешно работает вот ну и как вы понимаете раз в 6 недель у нас
[51:28.320 --> 51:33.480]  раз раз 6 недель у нас какой-то апдейт в таком случае раз у нас на месте не
[51:33.480 --> 51:42.200]  стоит и постоянно обновляется вот ну и соответственно некоторые возможности
[51:42.200 --> 51:46.080]  которые только только появляются компилятор и на самом начало обозначаются
[51:46.080 --> 51:51.360]  какими-то там обозначениями что это находится только на этли ну то есть это
[51:51.360 --> 51:57.320]  анстейбл вот и для того чтобы у вас все работал то есть чтобы скомпилировался
[51:57.320 --> 52:01.320]  какой-то код который есть только в на этли то он нужно осознанно указать что
[52:01.320 --> 52:05.480]  я хочу включить вот это вот фичу то есть примерно также вы можете увидеть
[52:05.480 --> 52:11.880]  это в задаче try там у нас есть в файле либо rc мы там включаем фичу который
[52:11.880 --> 52:17.760]  собственно гад включает гад это generic associated types это то с чем вы
[52:17.760 --> 52:21.200]  познакомитесь в этой задаче отдельно
[52:21.960 --> 52:27.000]  иногда бывает такое что вам нужно обновить язык таким образом что какие-то
[52:27.000 --> 52:34.320]  вещи просто ломаются то есть они не обратно совместимы например в 2018 году
[52:34.320 --> 52:39.760]  добавляли ключевые слова асинка и вейт естественно код в котором были
[52:39.760 --> 52:43.560]  переменные асинка и вейт он перестанет компилироваться потому что это ключевые
[52:43.560 --> 52:50.080]  слова как же мы поступим с этим у нас же тогда сломается если мы просто выкатим
[52:50.080 --> 52:56.520]  очередной раз релиз компиляция очень многих проектов для этого существует
[52:56.520 --> 53:04.800]  такая версия называется editions это пример я сказал вот появляется такая
[53:04.800 --> 53:13.120]  штука называется edition edition это по сути ну вот знаете c++ 20 c++ 17 14 вот
[53:13.120 --> 53:18.560]  примерно точно также раз 2015 2018 2021
[53:19.560 --> 53:24.440]  когда вы включаете определенный edition то в таком случае у вас во первых вы
[53:24.440 --> 53:30.480]  можете edition столько вверх менять вниз не можете это по логичному причину на
[53:30.480 --> 53:34.680]  самом деле потому что если вы так делаете то это breaking change потому что вы
[53:34.680 --> 53:40.440]  перестали пользоваться каким-то новыми фичами на которые в общем сейчас
[53:40.440 --> 53:46.040]  посмотрим пример хотя можно даже наверное сейчас ходить прийти например
[53:46.040 --> 53:50.160]  если у вас функция какая-то публичная интерфейс и использовала синг потом вы
[53:50.160 --> 53:55.200]  перестали ну в общем она перестала быть осин кто в таком случае у вас сломать
[53:55.200 --> 54:00.720]  компиляция проектов других производителей вот ну как работает
[54:00.720 --> 54:03.800]  editions когда вы включаете edition то у вас включается дополнительная
[54:03.800 --> 54:08.360]  возможность и у раз-то какие-то слова становятся ключевыми какие-то появляются
[54:08.360 --> 54:15.040]  новые возможности этот ну в общем этот выбор вы должны сделать осознан в карга
[54:15.040 --> 54:19.520]  то мл по умолчанию все проекты убирают самый последний edition который доступен
[54:19.520 --> 54:25.280]  в данный момент у нас я проектом прежде 2021 в 2021 вышел буквально вот этой осенью
[54:25.280 --> 54:34.720]  то есть он совсем молодой вот ну и соответственно вы можете даже
[54:34.720 --> 54:39.400]  компилироваться у вас может быть такое что у вас текущая версия компилятора
[54:39.400 --> 54:45.320]  ну ваш текущий проект edition 2015 собирается ваша зависимость 2021 на
[54:45.400 --> 54:53.240]  зависимость зависимости 2015 никому ничего не мешает так компилироваться просто если
[54:53.240 --> 54:57.120]  вы не включите нужный edition то в таком случае у вас не будут доступны какие-то
[54:57.120 --> 55:03.400]  возможности вот и все то есть получается что мы ничего не ломаем
[55:03.400 --> 55:06.240]  пользователей с другой стороны добавляем какие-то серьезные новости
[55:06.240 --> 55:14.040]  которые потенциально ломают язык если что наверное нужно это обмозговать и
[55:14.040 --> 55:18.800]  потом спросить еще в чате но если есть какие-то вопросы прям сейчас спросить
[55:18.800 --> 55:29.440]  ну да как стандарт плюсов
[55:29.440 --> 55:38.200]  не когда выходит новый edition то все в новом edition
[55:38.200 --> 55:41.720]  то есть это от дитев такая вещь
[55:41.720 --> 55:51.640]  ты можешь сидеть на старом это правда не очень хорошо вот чтобы автоматизировать
[55:51.640 --> 55:56.000]  эту миграцию на новый edition rast сделал так чтобы вам это было проще сделать
[55:56.000 --> 56:01.760]  появляется команда cargo fix с edition который за вас фиксит большинство
[56:01.760 --> 56:09.640]  проблем связанных с переходом на какой-то новый на какую-то новую версию да там
[56:09.640 --> 56:17.880]  есть вот дальше пример там есть в расе есть row identifiers то есть после них
[56:17.880 --> 56:21.920]  можно писать даже ключевые слова можете их писать в том числе
[56:21.920 --> 56:26.240]  если вы стоите на только делать это не надо это скорее в таких вот случаях
[56:26.240 --> 56:31.720]  по сути это единственный наверное случай когда он нужен row identifier
[56:42.080 --> 56:50.240]  ну в общем это все делается абсолютно автоматически и удобно ну правда все
[56:50.240 --> 56:55.080]  проблемы карга за вас не пофиксит есть некоторые вещи которые он не может
[56:55.080 --> 56:57.840]  все-таки сделать и в таком случае вам придется все-таки руками
[56:57.840 --> 57:14.400]  но это я конкретно про edition сейчас говорю fix edition то есть он фиксит
[57:14.400 --> 57:23.200]  именно edition но новый так есть фичи ну то есть например вы можете сделать так
[57:23.200 --> 57:27.240]  чтобы у вас появлялись какие-то новые возможности вашем крейте если кто-то
[57:27.240 --> 57:35.000]  укажет грубо говоря как вы хотите чтобы комплировался ваш крейт вот ну это
[57:35.000 --> 57:42.280]  например здесь вот у вас есть фича bmp bng iso и default точнее нет у вас есть фичи
[57:42.280 --> 57:50.960]  bmp bng iso да после этого если у вас пользователь выбирает default то в
[57:50.960 --> 57:58.880]  таком случае включается только iso в общем фича вот наверное не очень понятно
[57:58.880 --> 58:09.560]  объяснил да смотри у тебя есть фичи называется bmp bng они пустые потому что они
[58:09.560 --> 58:15.200]  просто что-то включают ну вот смотри у тебя есть ну пусть здесь будет bmp
[58:15.200 --> 58:22.440]  написано и оно включит какой-нибудь bmp и начнет комплироваться ну соответственно
[58:22.440 --> 58:26.320]  это какие-то скажем так root фичи вот это вот это уже над множество то есть ты
[58:26.320 --> 58:30.680]  можешь включить фичу она включает под набор какой-то фичей необходимый для того
[58:30.680 --> 58:38.080]  чтобы она работала ну да не аддитивно
[58:38.200 --> 58:47.280]  так мы будем это обсуждать сейчас у нас будут модели дальше было бы лучше
[58:47.280 --> 58:50.960]  наверное если бы я здесь написал кумить функцию включается функция при
[58:50.960 --> 58:54.160]  условии какой-то фичи
[58:57.920 --> 59:06.580]  ну да это это да больше похоже на и в дефа там есть лучше кфг ив такой в общем
[59:07.140 --> 59:14.260]  мы им собственно и пользуемся но это чуть попозже обсудим когда будем именно
[59:14.260 --> 59:21.500]  conditional compilation заниматься вот смотрите у нас есть такие вот фичи в
[59:21.500 --> 59:26.420]  request библиотеке если что это прям строчка из ровера
[59:26.420 --> 59:30.780]  request это каблиотека ну по названию можно догадаться что это как request
[59:30.980 --> 59:41.420]  только с другим названием вот и здесь смотрите я включил какие-то выбрал
[59:41.420 --> 59:44.340]  версию включил какие-то две фичи называется блокинг и мультипарт
[59:44.340 --> 59:48.660]  блокинг мне включила по получению реквеста на синхронная библиотека она
[59:48.660 --> 59:52.500]  написана на токио токио это такой считайте асио только на самом деле круче
[59:52.500 --> 01:00:00.420]  токио умеет больше вот блокинг это включает блокирующие взаимодействия с
[01:00:00.420 --> 01:00:05.220]  блокирующей отправлять запрос мне просто не нужно было писать их
[01:00:05.220 --> 01:00:09.380]  синхронно в ровере поэтому я включил блокинг потому что ну так гораздо проще
[01:00:09.380 --> 01:00:13.140]  код писать ну и мультипарт это возможность
[01:00:13.140 --> 01:00:17.500]  какие-то джессоны от проводить то есть там можно бы скомпоновать запросы
[01:00:17.500 --> 01:00:21.500]  отправить соответственно мне появились фичи там появились два модуля блокинг
[01:00:21.500 --> 01:00:26.500]  мультипарт которые позволяют мне собрать запрос и отправить его
[01:00:26.500 --> 01:00:31.780]  блокирующим указом без этого оно просто не скомпилируется скажет что
[01:00:31.780 --> 01:00:39.660]  нужно включить фичу какой-то вот когда крейд комплируется он собирается со
[01:00:39.660 --> 01:00:45.860]  всеми фичами которые нужны всем зависимостим его так и очень важный
[01:00:45.860 --> 01:00:52.100]  вопрос есть но фичи аддитивно и как вы думаете что может пойти не так если бы
[01:00:52.100 --> 01:00:58.820]  фичи были не дити ну то есть если бы я мог один крейд скомпилируется одним
[01:00:58.820 --> 01:01:08.860]  набором фичей другой с другим ну не так вот ну смотрите я компилирую все фичи
[01:01:08.860 --> 01:01:14.460]  со всеми необходимыми фичами и что произойдет если я допустим возьму
[01:01:14.460 --> 01:01:21.380]  какую-то фичу и как бы как бы сказать наверное лучше просто сразу к примеру
[01:01:21.380 --> 01:01:25.860]  перейти что-то объяснить
[01:01:29.380 --> 01:01:36.900]  вопрос конечно хорошо построил вот смотрите давайте к примеру уже перейдем
[01:01:36.900 --> 01:01:40.340]  нас раз частенько используется для эмбедд программирования
[01:01:40.340 --> 01:01:47.180]  ну и некоторые крейд у нас содержит себе фичу новой стд такой которая
[01:01:47.180 --> 01:01:52.020]  разрешает ну раз можно без стандартной библиотеки компилирует просто нужно для
[01:01:52.020 --> 01:01:56.580]  эмбедд разработки и соответственно крейд и некоторые
[01:01:56.580 --> 01:02:02.820]  предоставляли предоставляют если они не обновлены но стд фичу что же может
[01:02:02.820 --> 01:02:09.500]  пойти не так из-за того что такая фича была вообще как вы думаете
[01:02:11.780 --> 01:02:16.420]  ну ладно давайте отвечу у нас изначально ну стд это естественно на
[01:02:16.420 --> 01:02:19.740]  множество новости и то есть новости где-то отсутствия стд когда вы
[01:02:19.740 --> 01:02:22.980]  добавляете стд в таком случае у вас появляются какие-то новые возможности
[01:02:22.980 --> 01:02:30.820]  правильно аддитивно соответственно если вы добавили фичу новой стд в таком
[01:02:30.820 --> 01:02:37.860]  случае если вы фичу добавляете это у вас убавляются возможности незаконно да
[01:02:38.860 --> 01:02:45.060]  а проблема в том что представь себе такую ситуацию у тебя есть два крейта
[01:02:45.260 --> 01:02:51.600]  один использует твой креит который ты написал снова стд он использует фичу
[01:02:51.600 --> 01:02:57.300]  новости д-2 крейт использует в честь иди карга считают что эти фичи не
[01:02:57.300 --> 01:03:02.980]  аддитивно а дитина и соответственно он думает ага но я добавлю новость и д это
[01:03:02.980 --> 01:03:06.700]  же только добавит возможности не удалит добавят новости здесь соответственно
[01:03:06.700 --> 01:03:11.100]  крейт которые снова сидеть и скомпилируется и на ура а тот который требует стд то
[01:03:11.100 --> 01:03:17.880]  он сломается просто потому что он требовал библиотеку и стеде мы ее отрубили только что
[01:03:17.880 --> 01:03:25.980]  добавив новую фичу я думаю всех запутал
[01:03:25.980 --> 01:03:37.660]  а зачем тебе отключать, может понадобится фичу?
[01:03:37.660 --> 01:03:51.460]  Нет, лучше в данном случае нужно так сделать, нужно добавить фичу не новой стд, а и стд и по умолчанию включить сборку
[01:03:52.460 --> 01:03:59.820]  в таком случае для всех пользователей будет собираться библиотека с стд а когда кто-то
[01:03:59.820 --> 01:04:03.940]  потребует новой стд тогда он просто отключит эту фичу, соответственно в данном
[01:04:03.940 --> 01:04:08.460]  случае крейт и оба скомпилируются на ура потому что у нас есть и с стд фичой и
[01:04:08.460 --> 01:04:12.980]  с новой стд, они как бы друг друга дополняют два кусочка и у нас
[01:04:12.980 --> 01:04:22.380]  скомпилируется оба крейта. Смотри, то что каждая следующая фича не убавляет
[01:04:22.380 --> 01:04:29.780]  возможности, а добавляет. Это фича новой стд, это ошибка некоторых людей которые
[01:04:29.780 --> 01:04:35.020]  раньше добавляли ее в крейт, то есть какие-то крейты вот люди неправильно
[01:04:35.020 --> 01:04:38.820]  дизайнировали у них была фича новой стд, которая подразумевается просто по
[01:04:38.820 --> 01:04:46.620]  названию, она не аддитивна, потому что она убирает стд и не добавляет, соответственно
[01:04:46.620 --> 01:04:53.060]  карга думает, но они же аддитивны, подключу новой стд и все сломалось просто, вот так вот
[01:04:53.060 --> 01:04:58.420]  ну это как раз то что объяснил
[01:04:58.420 --> 01:05:10.300]  есть такая вот практика чтобы имплементировать какие-то дополнительные фичи как
[01:05:10.300 --> 01:05:19.260]  фичи крейта. Например есть такое официальное Rasta API guidelines как писать код на Rasta, то есть
[01:05:19.260 --> 01:05:28.300]  как дизайнить API. Ну и в общем-то там советуется что для своих типов пожалуйста сделайте фичу
[01:05:28.300 --> 01:05:35.500]  который называется CRD и в которой появляются для ваших типов serialize и deserialize. Что делает этот крейт?
[01:05:35.500 --> 01:05:43.380]  Ну возможно вы проходили курс по распределенным системам, вы наверное вспомните такую вещь
[01:05:43.380 --> 01:05:49.020]  что вам для того чтобы посылать что-то по сети, вам нужно это в общем-то серилизовать, а потом когда
[01:05:49.020 --> 01:05:55.020]  оно из сети вышло, десерилизовать. Вот CRD как раз то и делает, какие-то популярные форматы умеют
[01:05:55.020 --> 01:06:04.540]  серилизовать и десерилизовать. В частности JSON, где-то YAML и подобное. Ну и Rasta API guidelines настолько этот крейт
[01:06:04.540 --> 01:06:09.380]  популярен часто используется, что советую этому в общем-то добавьте пожалуйста себе эту фичу чтобы
[01:06:09.380 --> 01:06:17.460]  пользователь при желании мог воспользоваться тем что у вас для типов имплементировано serialize
[01:06:17.460 --> 01:06:36.420]  и deserialize. Так, в общем такая фича дает возможность пользователю как-то условно либо выбирать между тем
[01:06:36.420 --> 01:06:42.860]  хотят ли они включить какую-то фичу и соответственно компилировать что-то или не компилировать. Как-то так.
[01:06:42.860 --> 01:06:58.100]  Ладно давайте пойдем, это наверное последний слайд этой части. Мы все это время разговаривали
[01:06:58.100 --> 01:07:05.460]  и просто взяли и забыли про Rasta API, даже ни разу не сказали про него. И знаете это на самом деле хорошо,
[01:07:05.460 --> 01:07:10.260]  потому что мы все это время пользовались Kargo и даже не заметили то, что под низом там вообще-то
[01:07:10.260 --> 01:07:15.540]  RASC валяется, который все компилирует. Вот если вы например пользуетесь C или C++,
[01:07:15.540 --> 01:07:26.020]  вот не скажу конечно, что там вы не видите никогда GCC и Client какой-нибудь. Ну то есть,
[01:07:26.020 --> 01:07:35.900]  ну это зависит от системы сборки, ну вообще в целом это в общем недостаток плюсов,
[01:07:35.900 --> 01:07:38.980]  что вы постоянно должны знать о том, каким вы компилятором пользуетесь.
[01:07:56.020 --> 01:07:59.460]  Да, примерно так бывает.
[01:07:59.460 --> 01:08:14.740]  Есть ли у нас вопросы какие-нибудь по Kargo?
[01:08:14.740 --> 01:08:20.980]  Ну наверное Kargo Ship, что-то такое типа Crate.
[01:08:20.980 --> 01:08:33.540]  Это корабль, который ввозит, я себе представляю Overgreen корабль, как он называется.
[01:08:33.540 --> 01:08:42.740]  Наверное примерно по этой причине. Ну и Rasta, знаете, там типа ржавчина,
[01:08:42.740 --> 01:08:46.620]  как то ассоциируется с тем, что какие-то из Crate.
[01:08:46.620 --> 01:08:55.420]  Теперь мы научимся разделять область видимости и писать все в нескольких пайлах.
[01:08:55.420 --> 01:09:03.300]  Поднимите руки те, кому приходилось писать достаточно большие проекты на C.
[01:09:03.300 --> 01:09:10.620]  На C писал только два человека, три.
[01:09:10.620 --> 01:09:21.820]  Скажите, вы же сталкивались с тем, что у вас был namespace-палюша.
[01:09:21.820 --> 01:09:26.220]  То есть вы несколько функций, одно название было у них.
[01:09:26.220 --> 01:09:31.100]  Например, там вы брали две структуры данных, какой-нибудь лист писали и писали еще что-нибудь,
[01:09:31.100 --> 01:09:39.500]  хештаблицу, у обеих есть какой-нибудь метод emit, и в итоге, когда вы импортируете два заголовочных пайла,
[01:09:39.500 --> 01:09:45.180]  то в итоге у вас получается конфликт просто имена, в случае с C.
[01:09:45.180 --> 01:09:49.900]  Вам, естественно, хочется иногда написать одинаковые имена, но для этого нужно как-то
[01:09:49.900 --> 01:09:53.420]  разграничить область видимости. Например, сказать, что это относится к листу,
[01:09:53.420 --> 01:09:56.380]  это относится к хештаблице и все такое.
[01:09:56.620 --> 01:10:01.660]  В начале ты пишешь им модуль, и потом только в функции.
[01:10:01.660 --> 01:10:06.460]  Модуль файбер, файбер и прочее, это работает.
[01:10:06.460 --> 01:10:09.660]  То есть там есть что-то типа namespace?
[01:10:09.660 --> 01:10:16.700]  Там есть namespace, но это не то, что убивает.
[01:10:16.700 --> 01:10:20.220]  Я работаю там, где пишу только на C.
[01:10:20.860 --> 01:10:22.860]  Ну вы, наверное, разбирайтесь, как это делать.
[01:10:22.860 --> 01:10:27.420]  Я в любом случае знаю то, что в языке нет никаких напрямую возможностей.
[01:10:27.420 --> 01:10:29.420]  То есть как вот я написал с Лизой.
[01:10:29.420 --> 01:10:31.420]  У нас все были наследования.
[01:10:31.420 --> 01:10:34.460]  Наследования все, это все.
[01:10:38.460 --> 01:10:42.860]  У нас индекс B3, он написан на C шаблонный, он Define.
[01:10:43.500 --> 01:10:49.500]  Он был написан на C шаблонный, его перебисали на C.
[01:10:49.500 --> 01:10:51.500]  Короче, там все вот эти штуки.
[01:10:51.500 --> 01:10:53.500]  Это жестко.
[01:10:53.500 --> 01:10:57.500]  Так, давайте тогда продолжим пока что.
[01:10:59.500 --> 01:11:03.500]  Ну, в общем, получается, я тогда немножко соврал,
[01:11:03.500 --> 01:11:05.500]  что нет вообще никаких хороших способов решить эту проблему.
[01:11:05.500 --> 01:11:07.500]  Все-таки, наверное, есть.
[01:11:07.500 --> 01:11:09.500]  Он один, и он любит культуры коды.
[01:11:09.500 --> 01:11:11.500]  Да.
[01:11:12.140 --> 01:11:14.140]  Вот, в плюсах есть Namespace.
[01:11:14.140 --> 01:11:18.140]  Namespace это, в принципе, достаточно простое.
[01:11:18.140 --> 01:11:20.140]  И, в принципе, такой practical solution.
[01:11:20.140 --> 01:11:22.140]  В принципе, к ним особо вопросов нет.
[01:11:22.140 --> 01:11:26.140]  А что мы будем делать в расе для того,
[01:11:26.140 --> 01:11:30.140]  чтобы запревенцировать Namespace в получении?
[01:11:30.140 --> 01:11:34.140]  Ну, для этого есть такая штука, называется module.
[01:11:34.140 --> 01:11:38.140]  Смотрите, визуально напоминает кого-то мы какие-то Namespace написали.
[01:11:38.780 --> 01:11:42.780]  Еще было не очевидно, что эту модулю можно заплатить.
[01:11:42.780 --> 01:11:46.780]  Вот, ну это, в принципе, можете считать, что это и есть Namespace пока что.
[01:11:46.780 --> 01:11:50.780]  Оказывается, потому что это шире, чем Namespace.
[01:11:50.780 --> 01:11:54.780]  Но конкретно на этом слайде оно именно так и работает.
[01:11:54.780 --> 01:11:58.780]  Ну, например, ufu полное имя, соответственно, one nested nested 2fu
[01:11:58.780 --> 01:12:00.780]  через двойные двое точек.
[01:12:00.780 --> 01:12:02.780]  Это должно быть достаточно быстрая часть лекции,
[01:12:02.780 --> 01:12:04.780]  потому что она простая.
[01:12:05.420 --> 01:12:07.420]  Вот.
[01:12:07.420 --> 01:12:09.420]  Ну, давайте попробуем воспользоваться useme.
[01:12:09.420 --> 01:12:11.420]  useme вот, напоминаю, в модуле 2 находится.
[01:12:11.420 --> 01:12:13.420]  Вот 2 useme.
[01:12:13.420 --> 01:12:15.420]  Ну, давайте воспользуемся.
[01:12:15.420 --> 01:12:17.420]  Упс.
[01:12:17.420 --> 01:12:19.420]  Как же так вышло?
[01:12:19.420 --> 01:12:21.420]  Приватная функция внутри.
[01:12:21.420 --> 01:12:25.420]  Знаете, в плюсах, например, у нас были бы Namespace
[01:12:25.420 --> 01:12:27.420]  и в Namespace все публично.
[01:12:27.420 --> 01:12:29.420]  А здесь у нас приватная функция.
[01:12:29.420 --> 01:12:31.420]  Нам прям так и пожаловались.
[01:12:32.060 --> 01:12:34.060]  Давайте воспользуемся ключевым словом pub.
[01:12:34.060 --> 01:12:36.060]  Pub, собственно, вот означает ровно это.
[01:12:36.060 --> 01:12:40.060]  Сделай это публичным для всех parent modules,
[01:12:40.060 --> 01:12:42.060]  ну, для всех модулей, которые сверху.
[01:12:42.060 --> 01:12:44.060]  Вот.
[01:12:44.060 --> 01:12:46.060]  То есть, например, если бы я написал pub struct fu,
[01:12:46.060 --> 01:12:48.060]  то в таком случае я бы стал публичным
[01:12:48.060 --> 01:12:50.060]  и в nested, и в one, и в corny.
[01:12:50.060 --> 01:12:52.060]  Так.
[01:12:52.060 --> 01:12:54.060]  Здесь я, соответственно, стал публичным в corny.
[01:12:54.060 --> 01:12:56.060]  Вот.
[01:12:56.060 --> 01:12:58.060]  Вот.
[01:12:58.060 --> 01:13:00.060]  Вот.
[01:13:00.060 --> 01:13:02.060]  Я, соответственно, стал публичным в corny только.
[01:13:02.060 --> 01:13:04.060]  Заметьте, что в модуле 2
[01:13:04.060 --> 01:13:06.060]  мне не нужно становиться публичным,
[01:13:06.060 --> 01:13:08.060]  потому что это и есть мой модуль,
[01:13:08.060 --> 01:13:10.060]  и внутри него я все вижу.
[01:13:12.060 --> 01:13:14.060]  Вот.
[01:13:14.060 --> 01:13:16.060]  Ну, давайте объявим структуру fu.
[01:13:16.060 --> 01:13:18.060]  То есть вот one nested nested fu.
[01:13:18.060 --> 01:13:20.060]  И теперь выясним, что у нас
[01:13:20.060 --> 01:13:22.060]  модуль приватный.
[01:13:22.060 --> 01:13:24.060]  Поехали вот эти вот штуки.
[01:13:24.060 --> 01:13:26.060]  Здесь у нас должен приватный модуль, и вот здесь.
[01:13:26.060 --> 01:13:28.060]  Ну, он должен показывать на nest.
[01:13:28.060 --> 01:13:30.060]  Ну, он должен показывать на nest.
[01:13:30.060 --> 01:13:32.060]  Ну, он должен показывать на nest.
[01:13:32.060 --> 01:13:34.060]  Вот тут.
[01:13:36.060 --> 01:13:38.060]  Ну, для того, чтобы сделать
[01:13:38.060 --> 01:13:40.060]  своего публичного, нужно, естественно,
[01:13:40.060 --> 01:13:42.060]  написать ключевое слово pub.
[01:13:42.060 --> 01:13:44.060]  То есть получается, что
[01:13:44.060 --> 01:13:46.060]  не так как C++, у нас
[01:13:46.060 --> 01:13:48.060]  и модули, и все, что внутри,
[01:13:48.060 --> 01:13:50.060]  оно по умолчанию приватно.
[01:13:50.060 --> 01:13:52.060]  Ну, интересно,
[01:13:52.060 --> 01:13:54.060]  почему так получилось, что он
[01:13:54.060 --> 01:13:56.060]  взял и попросил у нас не one сделать
[01:13:56.060 --> 01:13:58.060]  публичным, и не два,
[01:13:58.060 --> 01:14:00.060]  как в прошлом случае.
[01:14:00.060 --> 01:14:02.060]  А именно nested.
[01:14:02.060 --> 01:14:04.060]  Как вы думаете, почему так происходит?
[01:14:10.060 --> 01:14:12.060]  Ну, грубо говоря, да, первое препятствие.
[01:14:12.060 --> 01:14:14.060]  Потому что у нас модуль, который лежит
[01:14:14.060 --> 01:14:16.060]  внутри нашего модуля, он для нас публичен.
[01:14:18.060 --> 01:14:20.060]  То есть сам по себе модуль, само имя
[01:14:20.060 --> 01:14:22.060]  для нас публичен,
[01:14:22.060 --> 01:14:24.060]  а то, что внутри, уже нет.
[01:14:24.060 --> 01:14:26.060]  Точно так же, если бы у нас была структурка,
[01:14:28.060 --> 01:14:30.060]  структурка была бы публична здесь.
[01:14:30.060 --> 01:14:32.060]  Если бы я здесь снизу написал структурку.
[01:14:38.060 --> 01:14:40.060]  1 и 2
[01:14:40.060 --> 01:14:42.060]  это такие модули, которые находятся
[01:14:42.060 --> 01:14:44.060]  в root-module. Это, собственно, то, что я сказал,
[01:14:44.060 --> 01:14:46.060]  в корнях.
[01:14:46.060 --> 01:14:48.060]  Нам не нужны никакие права для того,
[01:14:48.060 --> 01:14:50.060]  чтобы иметь доступ
[01:14:50.060 --> 01:14:52.060]  к чему-то, что внутри текущего модуля
[01:14:52.060 --> 01:14:54.060]  находится. У нас всё публичное.
[01:14:56.060 --> 01:14:58.060]  То, как раз о чём я уже сказал.
[01:14:58.060 --> 01:15:00.060]  Давайте сделаем nested публичным,
[01:15:00.060 --> 01:15:02.060]  допишем пап, там ключевое слово.
[01:15:02.060 --> 01:15:04.060]  Потом, если мы попробуем это ещё раз комплектовать,
[01:15:04.060 --> 01:15:06.060]  он скажет nested2 приватно.
[01:15:06.060 --> 01:15:08.060]  Нам нужны, естественно, nested2 и
[01:15:08.060 --> 01:15:10.060]  фу, сделав публичным.
[01:15:10.060 --> 01:15:12.060]  По понятным причинам, они для нас приватны,
[01:15:12.060 --> 01:15:14.060]  вот точно так же.
[01:15:14.060 --> 01:15:16.060]  Как-то так это выглядит.
[01:15:20.060 --> 01:15:22.060]  Обратите внимание на то,
[01:15:22.060 --> 01:15:24.060]  что фу...
[01:15:28.060 --> 01:15:30.060]  В общем, если мы
[01:15:30.060 --> 01:15:32.060]  не допишем пап в nested2,
[01:15:32.060 --> 01:15:34.060]  то в таком случае
[01:15:34.060 --> 01:15:36.060]  это не сделает
[01:15:36.060 --> 01:15:38.060]  публичным,
[01:15:38.060 --> 01:15:40.060]  потому что у нас есть препятствие
[01:15:40.060 --> 01:15:42.060]  в виде модуля nested2, который для нас приватен.
[01:15:44.060 --> 01:15:46.060]  Понятно ли это?
[01:15:50.060 --> 01:15:52.060]  Так.
[01:15:54.060 --> 01:15:56.060]  Ну, теперь давайте попробуем добавить
[01:15:56.060 --> 01:15:58.060]  поле bar. Вот здесь вот.
[01:15:58.060 --> 01:16:00.060]  Bar находится вот тут, в модуле 2.
[01:16:00.060 --> 01:16:02.060]  Вот он писал 2 bar, да?
[01:16:02.060 --> 01:16:04.060]  Попытаюсь это скомпилировать.
[01:16:06.060 --> 01:16:08.060]  Здесь опять, конечно, съехало всё.
[01:16:08.060 --> 01:16:10.060]  Не знаю, почему так происходит.
[01:16:10.060 --> 01:16:12.060]  Здесь должен быть 2.
[01:16:14.060 --> 01:16:16.060]  Он говорит, что я не знаю
[01:16:16.060 --> 01:16:18.060]  такого модуля.
[01:16:18.060 --> 01:16:20.060]  А всё почему?
[01:16:20.060 --> 01:16:22.060]  Потому что у нас в пути относительно.
[01:16:22.060 --> 01:16:24.060]  То есть, если мы написали 2 bar,
[01:16:24.060 --> 01:16:26.060]  то мы ожидаем, что здесь внутри nested2
[01:16:26.060 --> 01:16:28.060]  есть какой-то модуль 2,
[01:16:28.060 --> 01:16:30.060]  а внутри него есть, собственно, bar,
[01:16:30.060 --> 01:16:32.060]  который мы ожидаем увидеть.
[01:16:32.060 --> 01:16:34.060]  Если вы хотите, чтобы мы
[01:16:34.060 --> 01:16:36.060]  смогли воспользоваться 2 bar,
[01:16:36.060 --> 01:16:38.060]  то нам в таком случае нужно воспользоваться
[01:16:38.060 --> 01:16:40.060]  ключевым словом create.
[01:16:40.060 --> 01:16:42.060]  Ну, читайте это.
[01:16:42.060 --> 01:16:44.060]  В общем, slash — это
[01:16:44.060 --> 01:16:46.060]  корневая папочка, как в системах Unix.
[01:16:46.060 --> 01:16:48.060]  В таком случае мы начнём
[01:16:48.060 --> 01:16:50.060]  с root-модуля,
[01:16:50.060 --> 01:16:52.060]  а не с текущего.
[01:16:52.060 --> 01:16:54.060]  То есть, если он писал create
[01:16:54.060 --> 01:16:56.060]  2 bar, то в таком случае я
[01:16:56.060 --> 01:16:58.060]  сначала перепрыгну сюда,
[01:16:58.060 --> 01:17:00.060]  потом зайду сюда.
[01:17:00.060 --> 01:17:02.060]  Понятно?
[01:17:02.060 --> 01:17:04.060]  Мы можем строить вот такие
[01:17:04.060 --> 01:17:06.060]  fully-qualified names
[01:17:06.060 --> 01:17:08.060]  либо относительно корня
[01:17:08.060 --> 01:17:10.060]  от коневого модуля, либо
[01:17:10.060 --> 01:17:12.060]  от текущего.
[01:17:12.060 --> 01:17:14.060]  Ну, мы либо от текущего
[01:17:14.060 --> 01:17:16.060]  относительным путём идём.
[01:17:16.060 --> 01:17:18.060]  Ну, мы сейчас увидим, там ещё есть ключевое слово super
[01:17:18.060 --> 01:17:20.060]  для того, чтобы к родителям ходить.
[01:17:20.060 --> 01:17:22.060]  Вот.
[01:17:22.060 --> 01:17:24.060]  А create — это строго в начало нас принесёт.
[01:17:26.060 --> 01:17:28.060]  Так.
[01:17:28.060 --> 01:17:30.060]  Блин, что-то не понимаю. Всё посъезжало,
[01:17:30.060 --> 01:17:32.060]  хотя вроде нормально вставило.
[01:17:32.060 --> 01:17:34.060]  Вот. Ну, он нам говорит, что вот это вот
[01:17:34.060 --> 01:17:36.060]  поле приватное теперь.
[01:17:36.060 --> 01:17:38.060]  Вот, видите, вот пробуем скомпилировать, говорит, нам bar приватно.
[01:17:40.060 --> 01:17:42.060]  Если...
[01:17:42.060 --> 01:17:44.060]  Вот мы попытались сконструировать full
[01:17:44.060 --> 01:17:46.060]  и получили такую ошибку.
[01:17:46.060 --> 01:17:48.060]  Ну, всё почему? Потому что у нас
[01:17:48.060 --> 01:17:50.060]  собственно, поле bar приватное,
[01:17:50.060 --> 01:17:52.060]  и нам нужно его сделать публичным.
[01:17:52.060 --> 01:17:54.060]  У нас в получении структура
[01:17:54.060 --> 01:17:56.060]  все поля приватные.
[01:17:56.060 --> 01:17:58.060]  Это, например, правда ли
[01:17:58.060 --> 01:18:00.060]  кого-нибудь вектора? Ну, вы помните, например,
[01:18:00.060 --> 01:18:02.060]  что в вектор вы не можете заглянуть
[01:18:02.060 --> 01:18:04.060]  в указатель внутри, потому что там всё
[01:18:04.060 --> 01:18:06.060]  в получении приватное. Если вы хотите сделать
[01:18:06.060 --> 01:18:08.060]  какое-то поле структуры публичным,
[01:18:08.060 --> 01:18:10.060]  то вам нужно написать ключевое слово pub.
[01:18:10.060 --> 01:18:12.060]  Постарайтесь это не делать лишний раз.
[01:18:12.060 --> 01:18:14.060]  Ну, то есть, если у вас есть причина,
[01:18:14.060 --> 01:18:16.060]  то в таком случае pub дописывайте.
[01:18:16.060 --> 01:18:18.060]  А если нет, то лучше напишите там getter,
[01:18:18.060 --> 01:18:20.060]  setter и какие-нибудь конструкторы
[01:18:20.060 --> 01:18:22.060]  и так далее. То есть, не нужно открывать
[01:18:22.060 --> 01:18:24.060]  пользователю внутри
[01:18:24.060 --> 01:18:26.060]  свои поля. Ну, всё, в принципе,
[01:18:26.060 --> 01:18:28.060]  точно так же, как и все плюс-плюс логически.
[01:18:28.060 --> 01:18:30.060]  Так, и нам калом теперь поехал.
[01:18:30.060 --> 01:18:32.060]  Влево.
[01:18:34.060 --> 01:18:36.060]  Вот, смотрите, я написал pub перед bar.
[01:18:36.060 --> 01:18:38.060]  И у нас теперь всё компилируется.
[01:18:38.060 --> 01:18:40.060]  Давайте, наверное, ещё нужно будет
[01:18:40.060 --> 01:18:42.060]  про отдых подумать.
[01:18:42.060 --> 01:18:44.060]  Чуть-чуть.
[01:18:46.060 --> 01:18:48.060]  Ну ладно.
[01:18:50.060 --> 01:18:52.060]  Чтобы поле стало публичным,
[01:18:52.060 --> 01:18:54.060]  иначе я не могу сконструировать, собственно, тип.
[01:18:56.060 --> 01:18:58.060]  Ну, смотри, вот bar я использую здесь.
[01:18:58.060 --> 01:19:00.060]  Так? Ну, я его сделал.
[01:19:02.060 --> 01:19:04.060]  Да, вот я попытался создать
[01:19:04.060 --> 01:19:06.060]  два bar.
[01:19:06.060 --> 01:19:08.060]  То есть, создать foo, и мне, соответственно,
[01:19:08.060 --> 01:19:10.060]  нужно bar передать.
[01:19:10.060 --> 01:19:12.060]  Так как у меня вообще поле bar
[01:19:12.060 --> 01:19:14.060]  приватно, то в таком случае не могу это сделать.
[01:19:14.060 --> 01:19:16.060]  Мне пришлось pub дописать.
[01:19:20.060 --> 01:19:22.060]  Так, ну давайте тогда отдохнём чуть-чуть.
[01:19:24.060 --> 01:19:26.060]  Давайте добавим теперь
[01:19:26.060 --> 01:19:28.060]  в наш инамчик вот такой вот вариант.
[01:19:28.060 --> 01:19:30.060]  Example nest2 foo.
[01:19:30.060 --> 01:19:32.060]  Ну что ж, как это будет работать?
[01:19:36.060 --> 01:19:38.060]  Итак, ну вот,
[01:19:38.060 --> 01:19:40.060]  получается мы создали bar,
[01:19:40.060 --> 01:19:42.060]  потом foo,
[01:19:42.060 --> 01:19:44.060]  и экземпла
[01:19:44.060 --> 01:19:46.060]  сделали. Ну, естественно,
[01:19:46.060 --> 01:19:48.060]  t будет one nested count.
[01:19:48.060 --> 01:19:50.060]  Знаете, тут не так,
[01:19:50.060 --> 01:19:52.060]  как в структуре.
[01:19:52.060 --> 01:19:54.060]  То есть, в структуре нам нужно поля делать
[01:19:54.060 --> 01:19:56.060]  публичными.
[01:19:56.060 --> 01:19:58.060]  Как мы это делали в прошлом примере.
[01:19:58.060 --> 01:20:00.060]  А
[01:20:00.060 --> 01:20:02.060]  конкретно в этом примере
[01:20:02.060 --> 01:20:04.060]  нам не нужно делать никакие
[01:20:04.060 --> 01:20:06.060]  enumeration варианты публичными.
[01:20:06.060 --> 01:20:08.060]  Потому что если он доступен сам enum,
[01:20:08.060 --> 01:20:10.060]  то нам доступны все его варианты.
[01:20:12.060 --> 01:20:14.060]  Теперь давайте попробуем
[01:20:14.060 --> 01:20:16.060]  имплементировать mytrade для foo.
[01:20:16.060 --> 01:20:18.060]  Это достаточно легко
[01:20:18.060 --> 01:20:20.060]  так вот делается. Я пишу
[01:20:20.060 --> 01:20:22.060]  impo create one mytrade
[01:20:22.060 --> 01:20:24.060]  для текущего foo.
[01:20:24.060 --> 01:20:26.060]  В расе нам не нужно
[01:20:26.060 --> 01:20:28.060]  чтобы объект был pub.
[01:20:30.060 --> 01:20:32.060]  Когда он
[01:20:32.060 --> 01:20:34.060]  объявлен в одном из
[01:20:34.060 --> 01:20:36.060]  родительских модулей.
[01:20:36.060 --> 01:20:38.060]  Ну, то есть, соответственно,
[01:20:38.060 --> 01:20:40.060]  mytrade, как вы видите, несмотря на то,
[01:20:40.060 --> 01:20:42.060]  что перед ним нет ключевого слова pub,
[01:20:42.060 --> 01:20:44.060]  я к нему могу иметь доступ.
[01:20:44.060 --> 01:20:46.060]  Понятно, да?
[01:20:48.060 --> 01:20:50.060]  Потому что он находится в одном из родительских модулей.
[01:20:50.060 --> 01:20:52.060]  Теперь смотрите, как можно написать.
[01:20:56.060 --> 01:20:58.060]  Помните вот это вот два двоеточия?
[01:20:58.060 --> 01:21:00.060]  Это бывает полезно, например, если у вас
[01:21:00.060 --> 01:21:02.060]  это в родительском модуле.
[01:21:02.060 --> 01:21:04.060]  Когда вот так вот три модуля, то, конечно, лучше написать create two bar.
[01:21:04.060 --> 01:21:06.060]  Ну, чисто для примера,
[01:21:06.060 --> 01:21:08.060]  вот смотрите, можно
[01:21:08.060 --> 01:21:10.060]  n раз написать super вначале.
[01:21:10.060 --> 01:21:12.060]  Для того, чтобы куда-то уйти.
[01:21:12.060 --> 01:21:14.060]  Это, по сути, то же самое, что
[01:21:14.060 --> 01:21:16.060]  двоеточие, когда вы пишете в консоли.
[01:21:16.060 --> 01:21:18.060]  В терминале.
[01:21:20.060 --> 01:21:22.060]  Это будет работать абсолютно точно так же.
[01:21:22.060 --> 01:21:24.060]  Обратите внимание, вот create тоже
[01:21:24.060 --> 01:21:26.060]  супер-супер написал там, супер-супер-супер
[01:21:26.060 --> 01:21:28.060]  два бар. Все отлично работает.
[01:21:28.060 --> 01:21:30.060]  Теперь давайте я имплир
[01:21:30.060 --> 01:21:32.060]  напишу в каком-то вообще другом месте.
[01:21:32.060 --> 01:21:34.060]  То есть, не рядом со структуркой foo.
[01:21:34.060 --> 01:21:36.060]  Мы так тоже можем делать.
[01:21:36.060 --> 01:21:38.060]  Я не советую так делать.
[01:21:38.060 --> 01:21:40.060]  Ну, раз нам это разрешает сделать.
[01:21:42.060 --> 01:21:44.060]  То есть, смотрите, у нас
[01:21:44.060 --> 01:21:46.060]  simple create one my trade
[01:21:46.060 --> 01:21:48.060]  for nested foo. Неста два foo.
[01:21:48.060 --> 01:21:50.060]  И вот оно отлично работает.
[01:21:50.060 --> 01:21:52.060]  Ну, и сам foo можно имплиментировать в произвольном месте.
[01:21:54.060 --> 01:21:56.060]  И нам ничего не нужно дописывать.
[01:21:56.060 --> 01:21:58.060]  Кстати, здесь добавил self.
[01:22:00.060 --> 01:22:02.060]  Тут есть ключевое слово self.
[01:22:02.060 --> 01:22:04.060]  Давайте пока что прикинем, что его тут нет.
[01:22:04.060 --> 01:22:06.060]  Потому что случайно здесь появился.
[01:22:12.060 --> 01:22:14.060]  Если бы my trade был dev.
[01:22:14.060 --> 01:22:16.060]  Да, да.
[01:22:16.060 --> 01:22:18.060]  Потому что он был тогда не в родительском модуле.
[01:22:24.060 --> 01:22:26.060]  Нет никакой.
[01:22:28.060 --> 01:22:30.060]  Да, он все понимает, что
[01:22:30.060 --> 01:22:32.060]  один импл на весь крейт должен быть.
[01:22:32.060 --> 01:22:34.060]  Мы сейчас как раз об этом поговорим.
[01:22:36.060 --> 01:22:38.060]  Да, может где угодно импл написать.
[01:22:40.060 --> 01:22:42.060]  Окей, я хочу сделать несколько имплов.
[01:22:42.060 --> 01:22:44.060]  Я такой хитрый, сделаю несколько имплов.
[01:22:46.060 --> 01:22:48.060]  Мне что-то подсказывает, что
[01:22:48.060 --> 01:22:50.060]  self я все-таки должен был в каком-то моменте объяснить.
[01:22:50.060 --> 01:22:52.060]  И, возможно, что-то потерял случайно.
[01:22:52.060 --> 01:22:54.060]  Давайте я на всякий случай скажу.
[01:22:54.060 --> 01:22:56.060]  Если self здесь написано
[01:22:56.060 --> 01:22:58.060]  в скобочках, то это означает то, что у вас видимость.
[01:22:58.060 --> 01:23:00.060]  Вот папа говорит,
[01:23:00.060 --> 01:23:02.060]  всем потомкам я виден.
[01:23:02.060 --> 01:23:04.060]  А self говорит, я виден только своему родителю.
[01:23:04.060 --> 01:23:06.060]  То есть я буду виден только внутри nested.
[01:23:08.060 --> 01:23:10.060]  А внутри one я уже не буду виден.
[01:23:10.060 --> 01:23:12.060]  И внутри родительского тоже не буду не виден.
[01:23:12.060 --> 01:23:14.060]  Исключительно внутри
[01:23:14.060 --> 01:23:16.060]  этого модуля и родительского модуля.
[01:23:18.060 --> 01:23:20.060]  Так, ну давай сделаем несколько имплементаций.
[01:23:20.060 --> 01:23:22.060]  Ну имплементация одного это уже трейта.
[01:23:22.060 --> 01:23:24.060]  Для одного это уже фу.
[01:23:26.060 --> 01:23:28.060]  Вот так вот.
[01:23:30.060 --> 01:23:32.060]  Говорит, что
[01:23:32.060 --> 01:23:34.060]  две конфликтующие имплементации.
[01:23:36.060 --> 01:23:38.060]  Есть такая штука, называется coherence.
[01:23:38.060 --> 01:23:40.060]  Что она говорит?
[01:23:40.060 --> 01:23:42.060]  Она говорит о том, что у нас в любой момент времени
[01:23:42.060 --> 01:23:44.060]  в крейте должна быть только одна имплементация.
[01:23:44.060 --> 01:23:46.060]  То есть раз должен знать,
[01:23:46.060 --> 01:23:48.060]  какую имплементацию он использует.
[01:23:48.060 --> 01:23:50.060]  И там должна быть только одна, вообще
[01:23:50.060 --> 01:23:52.060]  на весь крейт.
[01:23:54.060 --> 01:23:56.060]  То есть более конкретно, вот
[01:23:56.060 --> 01:23:58.060]  прям написано, что
[01:23:58.060 --> 01:24:00.060]  for any given type of method
[01:24:00.060 --> 01:24:02.060]  and method.
[01:24:02.060 --> 01:24:04.060]  Что-что?
[01:24:08.060 --> 01:24:10.060]  Теперь давайте прикинем,
[01:24:12.060 --> 01:24:14.060]  что было бы, если бы я попробовал имплементировать
[01:24:14.060 --> 01:24:16.060]  трейт-дисплей для типа boop
[01:24:16.060 --> 01:24:18.060]  в библиотеке.
[01:24:18.060 --> 01:24:20.060]  Помните такой для вывода?
[01:24:20.060 --> 01:24:22.060]  Вот, а я теперь имплементирую его
[01:24:22.060 --> 01:24:24.060]  для типа boop
[01:24:24.060 --> 01:24:26.060]  самостоятельно.
[01:24:26.060 --> 01:24:28.060]  Да, он уже есть, там уже выводится true
[01:24:28.060 --> 01:24:30.060]  либо false с помощью дисплей.
[01:24:30.060 --> 01:24:32.060]  Соответственно, раз такой
[01:24:32.060 --> 01:24:34.060]  на это посмотрит, ты поймешь,
[01:24:34.060 --> 01:24:36.060]  что вообще-то и в библиотеке есть
[01:24:36.060 --> 01:24:38.060]  имплементации, и здесь.
[01:24:38.060 --> 01:24:40.060]  И он, в общем-то, не может
[01:24:40.060 --> 01:24:42.060]  выбирать рандомно. Он должен выбрать
[01:24:42.060 --> 01:24:44.060]  какую-то конкретную имплементацию.
[01:24:44.060 --> 01:24:46.060]  И мы должны как-то это все уравновесить для того,
[01:24:46.060 --> 01:24:48.060]  чтобы у нас была в любой момент
[01:24:48.060 --> 01:24:50.060]  одна имплементация, у нас ничего просто так не ломалось
[01:24:50.060 --> 01:24:52.060]  в коде, да, и
[01:24:52.060 --> 01:24:54.060]  в зависящем от нас в коде.
[01:24:54.060 --> 01:24:56.060]  Давайте мы попробуем посмотреть на всякие примеры
[01:24:56.060 --> 01:24:58.060]  того, как мы будем
[01:24:58.060 --> 01:25:00.060]  разрешать имплементировать имплы.
[01:25:00.060 --> 01:25:02.060]  То есть, в каких местах.
[01:25:02.060 --> 01:25:04.060]  Как-то странно дважды повторились.
[01:25:08.060 --> 01:25:10.060]  Очень странно. Я помню даже,
[01:25:10.060 --> 01:25:12.060]  как писал. Здесь пример.
[01:25:12.060 --> 01:25:14.060]  Ну ладно.
[01:25:16.060 --> 01:25:18.060]  Я вообще ничего не понимаю.
[01:25:18.060 --> 01:25:20.060]  Здесь абсолютно точно был пример.
[01:25:20.060 --> 01:25:22.060]  Давайте тогда посмотрим
[01:25:22.060 --> 01:25:24.060]  на этот сразу.
[01:25:24.060 --> 01:25:26.060]  Смотрите, давайте
[01:25:26.060 --> 01:25:28.060]  прикинем, что у нас есть два крейта.
[01:25:28.060 --> 01:25:30.060]  Два крейта, один
[01:25:30.060 --> 01:25:32.060]  содержит в себе.
[01:25:32.060 --> 01:25:34.060]  Вот
[01:25:34.060 --> 01:25:36.060]  два крейта, один содержит в себе трейт, это
[01:25:36.060 --> 01:25:38.060]  крейт A. Крейт B содержит
[01:25:38.060 --> 01:25:40.060]  в себе внутри структурку.
[01:25:40.060 --> 01:25:42.060]  Давайте мы
[01:25:42.060 --> 01:25:44.060]  в крейтах D и C
[01:25:44.060 --> 01:25:46.060]  попробуем поимплементировать
[01:25:46.060 --> 01:25:48.060]  этот трейт для этой структурки.
[01:25:48.060 --> 01:25:50.060]  Если имплементирую
[01:25:50.060 --> 01:25:52.060]  и в D и в C его,
[01:25:52.060 --> 01:25:54.060]  в таком случае там будут какие-то разные имплементации.
[01:25:54.060 --> 01:25:56.060]  В крейте I, который зависит
[01:25:56.060 --> 01:25:58.060]  от D и C, у меня
[01:25:58.060 --> 01:26:00.060]  все сломается компиляция, потому что у меня есть
[01:26:00.060 --> 01:26:02.060]  две комплектующие имплементации.
[01:26:02.060 --> 01:26:04.060]  И смотрите, эти крейты друг от друга
[01:26:04.060 --> 01:26:06.060]  независимы. У нас по-прежнему одна
[01:26:06.060 --> 01:26:08.060]  имплементация.
[01:26:08.060 --> 01:26:10.060]  Одна имплементация вроде бы все правильно, но при этом у нас
[01:26:10.060 --> 01:26:12.060]  сломалась компиляция. Мы не хотим, чтобы
[01:26:12.060 --> 01:26:14.060]  так было. Поэтому нам нужно сделать
[01:26:14.060 --> 01:26:16.060]  так, чтобы у нас
[01:26:16.060 --> 01:26:18.060]  как-то разрешали имплементации
[01:26:18.060 --> 01:26:20.060]  только крейты строго либо A, либо B
[01:26:20.060 --> 01:26:22.060]  для структуры
[01:26:22.060 --> 01:26:24.060]  и для трейта.
[01:26:26.060 --> 01:26:28.060]  Это как раз
[01:26:28.060 --> 01:26:30.060]  о чем я сказал.
[01:26:32.060 --> 01:26:34.060]  Ну, знаете, здесь
[01:26:34.060 --> 01:26:36.060]  для того, чтобы это пофиксить, у нас
[01:26:36.060 --> 01:26:38.060]  будет вот такое вот правило.
[01:26:40.060 --> 01:26:42.060]  Для начала давайте в простом виде
[01:26:42.060 --> 01:26:44.060]  на него посмотрим.
[01:26:44.060 --> 01:26:46.060]  В простом виде она говорит о B.
[01:26:46.060 --> 01:26:48.060]  А в следующем, что мы можем сделать
[01:26:48.060 --> 01:26:50.060]  имплементацию для трейта.
[01:26:50.060 --> 01:26:52.060]  Имплементацию трейта для структуры
[01:26:52.060 --> 01:26:54.060]  только там, где либо объявлен
[01:26:54.060 --> 01:26:56.060]  трейт, либо где объявлена структура.
[01:26:56.060 --> 01:26:58.060]  Только в этом крейте, либо в этом
[01:26:58.060 --> 01:27:00.060]  крейте.
[01:27:00.060 --> 01:27:02.060]  Если это один и тот же крейт, то в таком случае
[01:27:02.060 --> 01:27:04.060]  мы можем имплементировать
[01:27:04.060 --> 01:27:06.060]  трейт для структуры только в этом крейте.
[01:27:10.060 --> 01:27:12.060]  Верно понятно?
[01:27:18.060 --> 01:27:20.060]  Смотрите, здесь
[01:27:20.060 --> 01:27:22.060]  NoteModule написано в скобочках.
[01:27:22.060 --> 01:27:24.060]  Это как раз
[01:27:24.060 --> 01:27:26.060]  о том, о чем мы говорим, что без разницы,
[01:27:26.060 --> 01:27:28.060]  где вы имплементируете, главное, чтобы
[01:27:28.060 --> 01:27:30.060]  это было локально для вашего крейта.
[01:27:30.060 --> 01:27:32.060]  То есть конкретно
[01:27:32.060 --> 01:27:34.060]  в данном случае мы могли
[01:27:34.060 --> 01:27:36.060]  имплементировать
[01:27:36.060 --> 01:27:38.060]  трейт только в
[01:27:38.060 --> 01:27:40.060]  крейте B, потому что крейт A
[01:27:40.060 --> 01:27:42.060]  ничего не знает о структурке, которая объявлена
[01:27:42.060 --> 01:27:44.060]  в B, а B знает и о том трейте
[01:27:44.060 --> 01:27:46.060]  и структурке. Он же имплементирует.
[01:27:46.060 --> 01:27:48.060]  Если бы мы разрешили имплементировать
[01:27:48.060 --> 01:27:50.060]  это еще для D и для C, то тогда бы у нас
[01:27:50.060 --> 01:27:52.060]  сломались компиляции.
[01:27:54.060 --> 01:27:56.060]  Поэтому с таким
[01:27:56.060 --> 01:27:58.060]  правилом понятно. Только где объявлен
[01:27:58.060 --> 01:28:00.060]  трейт, либо там, где объявлена структурка.
[01:28:00.060 --> 01:28:02.060]  Трейт нужно имплементировать
[01:28:02.060 --> 01:28:04.060]  для структурки. Понятно?
[01:28:08.060 --> 01:28:10.060]  У нас есть такая штука, называется Blanket
[01:28:10.060 --> 01:28:12.060]  Implementation. Это как раз то,
[01:28:12.060 --> 01:28:14.060]  что мы изучали на прошлой лекции.
[01:28:14.060 --> 01:28:16.060]  То, как имплементировать какой-то трейт
[01:28:16.060 --> 01:28:18.060]  для всех типов.
[01:28:20.060 --> 01:28:22.060]  Во-первых, мы сейчас
[01:28:22.060 --> 01:28:24.060]  посмотрим на всякие exceptions,
[01:28:24.060 --> 01:28:26.060]  исключение из правил
[01:28:26.060 --> 01:28:28.060]  этого простого.
[01:28:28.060 --> 01:28:30.060]  Только трейт, который может имплементировать
[01:28:30.060 --> 01:28:32.060]  трейт, может имплементировать
[01:28:32.060 --> 01:28:34.060]  такой Blanket Implementation.
[01:28:34.060 --> 01:28:36.060]  Им уже не нужны никакие структуры,
[01:28:36.060 --> 01:28:38.060]  никакие типы специальные, чтобы сделать импл
[01:28:38.060 --> 01:28:40.060]  вот такой вот.
[01:28:40.060 --> 01:28:42.060]  И, собственно, если бы мы разрешили
[01:28:42.060 --> 01:28:44.060]  так делать,
[01:28:44.060 --> 01:28:46.060]  то в таком случае у нас бы были
[01:28:46.060 --> 01:28:48.060]  для разных типов, у нас же там
[01:28:48.060 --> 01:28:50.060]  по всем типам пробегают, которые выполняют
[01:28:50.060 --> 01:28:52.060]  какие-то условия. В конкретном данном случае у нас условий
[01:28:52.060 --> 01:28:54.060]  нет, любой T подходит для моей
[01:28:54.060 --> 01:28:56.060]  трейта. То есть, если бы там была написана
[01:28:56.060 --> 01:28:58.060]  тема и копия, то в таком случае
[01:28:58.060 --> 01:29:00.060]  мы бы имплементировали
[01:29:00.060 --> 01:29:02.060]  mytrade для всех копий типов.
[01:29:02.060 --> 01:29:04.060]  Если бы мы разрешили не только в нашем
[01:29:04.060 --> 01:29:06.060]  крейте Blanket Implementation
[01:29:06.060 --> 01:29:08.060]  писать, то в таком случае у нас
[01:29:08.060 --> 01:29:10.060]  бы могло случиться
[01:29:10.060 --> 01:29:12.060]  в третьем крейте, что
[01:29:12.060 --> 01:29:14.060]  два Blanket Implementation подходят и опять
[01:29:14.060 --> 01:29:16.060]  конфликт имплементации.
[01:29:16.060 --> 01:29:18.060]  Выясняется.
[01:29:18.060 --> 01:29:20.060]  Нам это не нравится.
[01:29:20.060 --> 01:29:22.060]  Вот.
[01:29:22.060 --> 01:29:24.060]  Поэтому мы...
[01:29:24.060 --> 01:29:26.060]  Это правило 1. Blanket Implementation
[01:29:26.060 --> 01:29:28.060]  можно писать только там,
[01:29:28.060 --> 01:29:30.060]  где крейт... собственно, сам трейт
[01:29:30.060 --> 01:29:32.060]  объявляет. Только крейт, который
[01:29:32.060 --> 01:29:34.060]  объявляет трейт.
[01:29:34.060 --> 01:29:36.060]  Во-вторых, есть фундаментальные
[01:29:36.060 --> 01:29:38.060]  типы, для которых все равно хочется
[01:29:38.060 --> 01:29:40.060]  имплементировать какие-то трейты,
[01:29:40.060 --> 01:29:42.060]  даже несмотря на то, что они стандартные
[01:29:42.060 --> 01:29:44.060]  библиотеки. Ну, ссылка
[01:29:44.060 --> 01:29:46.060]  и ссылка на mute, наверное, даже
[01:29:46.060 --> 01:29:48.060]  не так очевидна, как с боксом.
[01:29:48.060 --> 01:29:50.060]  Ссылка и ссылка на объекты, это если вы сделаете ссылку
[01:29:50.060 --> 01:29:52.060]  на T, это считается типом стандартной
[01:29:52.060 --> 01:29:54.060]  библиотеки.
[01:29:54.060 --> 01:29:56.060]  Ну, это же логично, потому что вы взяли...
[01:29:56.060 --> 01:29:58.060]  Например, если вы сделаете век T,
[01:29:58.060 --> 01:30:00.060]  это же тоже тип
[01:30:00.060 --> 01:30:02.060]  стандартной библиотеки.
[01:30:02.060 --> 01:30:04.060]  Даже если T это
[01:30:04.060 --> 01:30:06.060]  ваш локальный тип.
[01:30:08.060 --> 01:30:10.060]  Поэтому получается, что нам нужно какие-то
[01:30:10.060 --> 01:30:12.060]  особенные правила для этого вести.
[01:30:12.060 --> 01:30:14.060]  Ну, с боксом тут даже было бы понятнее,
[01:30:14.060 --> 01:30:16.060]  чем с ссылкой. Ну, с ссылкой тоже,
[01:30:16.060 --> 01:30:18.060]  как это пойдет. Вот, мы хотим имплементировать
[01:30:18.060 --> 01:30:20.060]  такой трейд, который мы вскоре узнаем,
[01:30:20.060 --> 01:30:22.060]  что это такое.
[01:30:22.060 --> 01:30:24.060]  Называется intIterator
[01:30:24.060 --> 01:30:26.060]  для myType, для ссылки
[01:30:26.060 --> 01:30:28.060]  на myType.
[01:30:28.060 --> 01:30:30.060]  Так как оба идут в стандартной библиотеке
[01:30:30.060 --> 01:30:32.060]  и intIterator, и ссылка,
[01:30:32.060 --> 01:30:34.060]  то в таком случае у нас бы
[01:30:34.060 --> 01:30:36.060]  по нашим правилам,
[01:30:36.060 --> 01:30:38.060]  ну, по нашему orphan rule старому,
[01:30:38.060 --> 01:30:40.060]  который мы посмотрели на простенький, это бы не прошло.
[01:30:42.060 --> 01:30:44.060]  Но так как мы
[01:30:44.060 --> 01:30:46.060]  разрешили специально
[01:30:46.060 --> 01:30:48.060]  имплементировать
[01:30:48.060 --> 01:30:50.060]  для нашей ссылки на T,
[01:30:50.060 --> 01:30:52.060]  где T это наш локальный тип,
[01:30:52.060 --> 01:30:54.060]  в таком случае
[01:30:54.060 --> 01:30:56.060]  все заработает, потому что myType,
[01:30:56.060 --> 01:30:58.060]  в таком случае, ну, ссылка на myType считается
[01:30:58.060 --> 01:31:00.060]  локальным типом.
[01:31:00.060 --> 01:31:02.060]  Ну, более конкретно, здесь компилятор
[01:31:02.060 --> 01:31:04.060]  делает так, он просто стирает тип
[01:31:04.060 --> 01:31:06.060]  перед тем, как это проверить.
[01:31:06.060 --> 01:31:08.060]  То есть, стирает ссылочку,
[01:31:08.060 --> 01:31:10.060]  для него это локальный тип здесь.
[01:31:10.060 --> 01:31:12.060]  Вот, как-то так.
[01:31:12.060 --> 01:31:14.060]  Я надеюсь, вы поняли, почему
[01:31:14.060 --> 01:31:16.060]  ссылка, ссылка
[01:31:16.060 --> 01:31:18.060]  myTypeBox, во-первых, делает
[01:31:18.060 --> 01:31:20.060]  тип стандартной библиотеки
[01:31:20.060 --> 01:31:22.060]  из нашего локального типа,
[01:31:22.060 --> 01:31:24.060]  потому что мы оборачиваем.
[01:31:24.060 --> 01:31:26.060]  Почему мы хотим это имплементировать?
[01:31:26.060 --> 01:31:28.060]  Потому что, если
[01:31:28.060 --> 01:31:30.060]  мы не имплементируем, то в таком случае
[01:31:30.060 --> 01:31:32.060]  мы, ну, в общем,
[01:31:32.060 --> 01:31:34.060]  это слишком фундаментальный тип, чтобы не дать
[01:31:34.060 --> 01:31:36.060]  возможность имплементировать для них что-то.
[01:31:36.060 --> 01:31:38.060]  Вот, и какие у нас проблемы
[01:31:38.060 --> 01:31:40.060]  возникают с базовым
[01:31:40.060 --> 01:31:42.060]  орфандром.
[01:31:42.060 --> 01:31:44.060]  Вот.
[01:31:44.060 --> 01:31:46.060]  Также есть
[01:31:46.060 --> 01:31:48.060]  какие-то такие
[01:31:48.060 --> 01:31:50.060]  лимитированные случаи, когда нам хочется
[01:31:50.060 --> 01:31:52.060]  для какого-то foreign type
[01:31:52.060 --> 01:31:54.060]  имплементировать
[01:31:54.060 --> 01:31:56.060]  наш trait.
[01:31:56.060 --> 01:31:58.060]  Ну, вот есть from, который из стандартной библиотеки
[01:31:58.060 --> 01:32:00.060]  myType, такой это наш локальный тип
[01:32:00.060 --> 01:32:02.060]  для вектора i32.
[01:32:04.060 --> 01:32:06.060]  Ну, и смотрите, здесь получается
[01:32:06.060 --> 01:32:08.060]  from из стандартной библиотеки вектора,
[01:32:08.060 --> 01:32:10.060]  из стандартной библиотеки i32, из стандартной библиотеки
[01:32:10.060 --> 01:32:12.060]  под стандартным нашим правилом ничего не работает.
[01:32:12.060 --> 01:32:14.060]  У нас ничего не локально.
[01:32:14.060 --> 01:32:16.060]  Мы, тем не менее, понимаем, что
[01:32:16.060 --> 01:32:18.060]  имплементировать это безопасно.
[01:32:18.060 --> 01:32:20.060]  Потому что myType, он локаден для нас.
[01:32:20.060 --> 01:32:22.060]  И мы хотим ввести какие-то специальные правила, чтобы
[01:32:22.060 --> 01:32:24.060]  это работало.
[01:32:24.060 --> 01:32:26.060]  Вот есть такой специальный правил.
[01:32:26.060 --> 01:32:28.060]  Если у нас есть импл по...
[01:32:28.060 --> 01:32:30.060]  Ну, это, наверное, будет не очень просто
[01:32:30.060 --> 01:32:32.060]  понимать. Ну, если вы прошлого правила не поняли,
[01:32:32.060 --> 01:32:34.060]  то, наверное, с этим еще тяжелее будет.
[01:32:34.060 --> 01:32:36.060]  Здесь импл...
[01:32:36.060 --> 01:32:38.060]  Вот, допустим, мы
[01:32:38.060 --> 01:32:40.060]  генерик по какому-то списку аргументов.
[01:32:40.060 --> 01:32:42.060]  Фарейн трейд тоже какой-то
[01:32:42.060 --> 01:32:44.060]  список аргументов.
[01:32:44.060 --> 01:32:46.060]  Ну, и для какого-то там t0 имплементируем.
[01:32:46.060 --> 01:32:48.060]  Это можно сделать только в том случае,
[01:32:48.060 --> 01:32:50.060]  если, по крайней мере,
[01:32:50.060 --> 01:32:52.060]  1t и ti это локальный тип.
[01:32:52.060 --> 01:32:54.060]  То есть, вот в этом списке
[01:32:54.060 --> 01:32:56.060]  есть какой-то локальный тип.
[01:32:56.060 --> 01:32:58.060]  И ни 1t
[01:32:58.060 --> 01:33:00.060]  до этого ti
[01:33:00.060 --> 01:33:02.060]  не является...
[01:33:02.060 --> 01:33:04.060]  не является ни одним из этих
[01:33:04.060 --> 01:33:06.060]  генериков.
[01:33:06.060 --> 01:33:08.060]  Очень сложные правила. Его,
[01:33:08.060 --> 01:33:10.060]  наверное, достаточно сложно было придумать.
[01:33:10.060 --> 01:33:12.060]  Ну, то есть,
[01:33:12.060 --> 01:33:14.060]  сам по себе правило, наверное, не сложное, но
[01:33:14.060 --> 01:33:16.060]  придумать даже не знаю, как это можно было додуматься.
[01:33:16.060 --> 01:33:18.060]  Но оно действительно работает.
[01:33:20.060 --> 01:33:22.060]  Генерики можно
[01:33:22.060 --> 01:33:24.060]  использовать в t0.ti
[01:33:24.060 --> 01:33:26.060]  до тех пор, пока они covered
[01:33:26.060 --> 01:33:28.060]  by intermediate type. Ну, что такое
[01:33:28.060 --> 01:33:30.060]  covered типа, это если
[01:33:30.060 --> 01:33:32.060]  они обернуты в какой-нибудь век t, например.
[01:33:34.060 --> 01:33:36.060]  Как-то так.
[01:33:38.060 --> 01:33:40.060]  Давайте посмотрим какой-нибудь
[01:33:40.060 --> 01:33:42.060]  примерчик.
[01:33:42.060 --> 01:33:44.060]  Вот у нас какие-то x, y,
[01:33:44.060 --> 01:33:46.060]  и т.д., z это какие-то генерики,
[01:33:46.060 --> 01:33:48.060]  по которому, в общем,
[01:33:48.060 --> 01:33:50.060]  и a, b, и т.д.,
[01:33:50.060 --> 01:33:52.060]  c это какие-то локальные по отношению к нам
[01:33:52.060 --> 01:33:54.060]  типы. Вот
[01:33:54.060 --> 01:33:56.060]  импл до x, y, z
[01:33:56.060 --> 01:33:58.060]  написали for int rate. И смотрите, у нас
[01:33:58.060 --> 01:34:00.060]  первый локальный тип где находится? Он
[01:34:00.060 --> 01:34:02.060]  на второй позиции.
[01:34:02.060 --> 01:34:04.060]  До этого у него не встречаются
[01:34:04.060 --> 01:34:06.060]  никакие из этого списка генериков объекта.
[01:34:06.060 --> 01:34:08.060]  Все хорошо, соответственно.
[01:34:08.060 --> 01:34:10.060]  А дальше мы можем писать все, что захотим.
[01:34:10.060 --> 01:34:12.060]  Вот b по отношению к нам
[01:34:12.060 --> 01:34:14.060]  локален, c локален, век x можно
[01:34:14.060 --> 01:34:16.060]  использовать, во-первых, потому что x уже можно
[01:34:16.060 --> 01:34:18.060]  использовать. У нас локальный тип до этого
[01:34:18.060 --> 01:34:20.060]  встретился, во-вторых, потому что век x это
[01:34:20.060 --> 01:34:22.060]  covered type, то есть и то, и то.
[01:34:22.060 --> 01:34:24.060]  Более того, вы можете написать век
[01:34:24.060 --> 01:34:26.060]  x даже вот тут, то есть до h.
[01:34:26.060 --> 01:34:28.060]  Потому что это был бы covered type.
[01:34:30.060 --> 01:34:32.060]  Вот это такое правило, с которым
[01:34:32.060 --> 01:34:34.060]  наверное вам редко придется
[01:34:34.060 --> 01:34:36.060]  жить, но оно бывает полезно.
[01:34:42.060 --> 01:34:44.060]  Так.
[01:34:44.060 --> 01:34:46.060]  Давайте обратим внимание на то, что
[01:34:46.060 --> 01:34:48.060]  имприментация вот такая вот,
[01:34:48.060 --> 01:34:50.060]  то есть локал type для t
[01:34:50.060 --> 01:34:52.060]  валидна, а вот t для локал type
[01:34:52.060 --> 01:34:54.060]  не валидна. То есть
[01:34:54.060 --> 01:34:56.060]  обратить внимание, здесь правило нарушается,
[01:34:56.060 --> 01:34:58.060]  то что у нас локальный тип, а до него
[01:34:58.060 --> 01:35:00.060]  есть какой-то generic из этого списка.
[01:35:00.060 --> 01:35:02.060]  Чтобы было понятно,
[01:35:02.060 --> 01:35:04.060]  почему это ломается, давайте посмотрим
[01:35:04.060 --> 01:35:06.060]  вот на
[01:35:06.060 --> 01:35:08.060]  такой вот пример.
[01:35:10.060 --> 01:35:12.060]  Пусть у нас есть вот такая вот имплементация
[01:35:12.060 --> 01:35:14.060]  в одном крейте, а
[01:35:14.060 --> 01:35:16.060]  во втором крейте мы написали вот такую вот имплементацию.
[01:35:16.060 --> 01:35:18.060]  Обратите внимание,
[01:35:18.060 --> 01:35:20.060]  что у нас здесь вот their type,
[01:35:20.060 --> 01:35:22.060]  ну это хоть и наш
[01:35:22.060 --> 01:35:24.060]  локальный какой-то, но он же
[01:35:24.060 --> 01:35:26.060]  вот здесь мой generic по нему, поэтому
[01:35:26.060 --> 01:35:28.060]  their type может попасть сюда,
[01:35:28.060 --> 01:35:30.060]  здесь вот мой generic по t,
[01:35:30.060 --> 01:35:32.060]  соответственно, локал type может попасть сюда.
[01:35:32.060 --> 01:35:34.060]  И мы получили, что у нас одинаково
[01:35:34.060 --> 01:35:36.060]  для para-interade совпадает
[01:35:36.060 --> 01:35:38.060]  в общем-то
[01:35:38.060 --> 01:35:40.060]  имплементация. Все generic совпали,
[01:35:40.060 --> 01:35:42.060]  соответственно, конфликтует имплементация.
[01:35:46.060 --> 01:35:48.060]  Он как-то так очень хитро.
[01:35:52.060 --> 01:35:54.060]  А здесь вообще полностью поехал форматирование.
[01:35:56.060 --> 01:35:58.060]  Я вообще не понял, конечно,
[01:35:58.060 --> 01:36:00.060]  я чинил, есть такое чувство, что
[01:36:00.060 --> 01:36:02.060]  можно
[01:36:02.060 --> 01:36:04.060]  по-быстрому это перекомпилировать, возможно.
[01:36:14.060 --> 01:36:16.060]  Просто там, по идее, должно быть все уже нормально.
[01:36:22.060 --> 01:36:24.060]  И что-то подсказывает, что это
[01:36:24.060 --> 01:36:26.060]  подчинит нам все.
[01:36:30.060 --> 01:36:32.060]  Еще можно на всякий случай.
[01:36:38.060 --> 01:36:40.060]  Ну это, конечно, сильно.
[01:36:46.060 --> 01:36:48.060]  В общем,
[01:36:48.060 --> 01:36:50.060]  вот, по-моему, он подчинился, да?
[01:36:50.060 --> 01:36:52.060]  То есть мы все это время жили просто
[01:36:52.060 --> 01:36:54.060]  со слайдами, которые почему-то не обновились.
[01:36:54.060 --> 01:36:56.060]  Ну ладно.
[01:36:58.060 --> 01:37:00.060]  Там, кстати, возможно, еще есть примерчик,
[01:37:00.060 --> 01:37:02.060]  который я хотел вначально.
[01:37:02.060 --> 01:37:04.060]  Нет, это все-таки какой-то косяк, ладно.
[01:37:06.060 --> 01:37:08.060]  Все, вернулись обратно.
[01:37:12.060 --> 01:37:14.060]  Ну вот,
[01:37:14.060 --> 01:37:16.060]  все, вернулись обратно.
[01:37:20.060 --> 01:37:22.060]  Представьте, что мы это все поместили в LibRC
[01:37:22.060 --> 01:37:24.060]  и опубликовали наш крейт.
[01:37:26.060 --> 01:37:28.060]  Так как мы поместили pub до
[01:37:28.060 --> 01:37:30.060]  one,
[01:37:30.060 --> 01:37:32.060]  и one находится у нас в нашем root module,
[01:37:32.060 --> 01:37:34.060]  то в таком случае у нас
[01:37:34.060 --> 01:37:36.060]  все стало публичным,
[01:37:36.060 --> 01:37:38.060]  то, что внутри находится.
[01:37:38.060 --> 01:37:40.060]  То есть обратите внимание, если у нас это находится
[01:37:40.060 --> 01:37:42.060]  в LibRC, LibRC
[01:37:42.060 --> 01:37:44.060]  находится, ну, сам по себе является
[01:37:44.060 --> 01:37:46.060]  корневым модулем.
[01:37:46.060 --> 01:37:48.060]  И в таком случае,
[01:37:48.060 --> 01:37:50.060]  раз уж мы написали pubmod,
[01:37:50.060 --> 01:37:52.060]  то в таком случае мы стали доступными другим
[01:37:52.060 --> 01:37:54.060]  крейтом, который нас импортирует.
[01:37:54.060 --> 01:37:56.060]  Соответственно, другой крейт,
[01:37:56.060 --> 01:37:58.060]  который от нас зависит, он бы мог
[01:37:58.060 --> 01:38:00.060]  просто взять и, например,
[01:38:00.060 --> 01:38:02.060]  дойти до
[01:38:02.060 --> 01:38:04.060]  ну, до какой-нибудь, в общем, публичной
[01:38:04.060 --> 01:38:06.060]  имплементации. Здесь конкретно
[01:38:06.060 --> 01:38:08.060]  везде написано self-crate, и
[01:38:08.060 --> 01:38:10.060]  в общем-то нам ничего не будет доступно.
[01:38:10.060 --> 01:38:12.060]  Если бы здесь было pub, то в таком случае можно было бы импортировать
[01:38:12.060 --> 01:38:14.060]  one-my-crate
[01:38:14.060 --> 01:38:16.060]  из нашего крейта.
[01:38:16.060 --> 01:38:18.060]  То есть это pub перед модулем
[01:38:18.060 --> 01:38:20.060]  в данном случае, раз уж он
[01:38:20.060 --> 01:38:22.060]  находится в корне, означает то, что
[01:38:22.060 --> 01:38:24.060]  мы станем доступными другим крейтом.
[01:38:28.060 --> 01:38:30.060]  Так.
[01:38:30.060 --> 01:38:32.060]  В том числе, если мы не
[01:38:32.060 --> 01:38:34.060]  используем foo, ну, это как раз
[01:38:34.060 --> 01:38:36.060]  то, что я говорил, и здесь
[01:38:36.060 --> 01:38:38.060]  можно супер дописать для того, чтобы
[01:38:38.060 --> 01:38:40.060]  сделать, ну, мы стали публичными
[01:38:40.060 --> 01:38:42.060]  только в нашем
[01:38:42.060 --> 01:38:44.060]  и родительском модуле.
[01:38:44.060 --> 01:38:46.060]  Да, и self
[01:38:46.060 --> 01:38:48.060]  как раз означает
[01:38:48.060 --> 01:38:50.060]  то, что только в этом модуле, вот.
[01:38:50.060 --> 01:38:52.060]  Self означает то, что мы только в этом
[01:38:52.060 --> 01:38:54.060]  модуле и родительском публичном.
[01:38:54.060 --> 01:38:56.060]  А, сейчас, что-то я запутался.
[01:38:58.060 --> 01:39:00.060]  Сейчас у меня, наверное, тут на красном слайде.
[01:39:02.060 --> 01:39:04.060]  Что-то я не понял.
[01:39:04.060 --> 01:39:06.060]  А, наверное, потому что все понял.
[01:39:06.060 --> 01:39:08.060]  Супер, просто дело для нас
[01:39:08.060 --> 01:39:10.060]  публичными на всю.
[01:39:12.060 --> 01:39:14.060]  Ладно, короче, я уже
[01:39:14.060 --> 01:39:16.060]  сам запутался как-нибудь.
[01:39:18.060 --> 01:39:20.060]  Self должен в текущем модуле
[01:39:20.060 --> 01:39:22.060]  сделать нас публичными.
[01:39:24.060 --> 01:39:26.060]  Наверное, я, наверное, догадываюсь в чем
[01:39:26.060 --> 01:39:28.060]  дело.
[01:39:30.060 --> 01:39:32.060]  Не, не, не, не бессмысленно. Там, наверное,
[01:39:32.060 --> 01:39:34.060]  просто в родительских модулях мы перестанем быть
[01:39:34.060 --> 01:39:36.060]  видны. Я просто помню, что это тестировал,
[01:39:36.060 --> 01:39:38.060]  я подзабыл, что там было.
[01:39:38.060 --> 01:39:40.060]  Там у всего есть различия.
[01:39:40.060 --> 01:39:42.060]  Вот, давайте я потом
[01:39:42.060 --> 01:39:44.060]  в чате напишу.
[01:39:44.060 --> 01:39:46.060]  Кроме того, у меня где-то есть пример.
[01:39:46.060 --> 01:39:48.060]  Чтобы, ну, я к этой лекции
[01:39:48.060 --> 01:39:50.060]  собирался вам скинуть прям пример крейта,
[01:39:50.060 --> 01:39:52.060]  чтобы вы, вот это вот, все, вот, ровно то,
[01:39:52.060 --> 01:39:54.060]  что мы на лекции с one nested могли
[01:39:54.060 --> 01:39:56.060]  на это посмотреть и потыкаться.
[01:39:56.060 --> 01:39:58.060]  Вот. Еще можно
[01:39:58.060 --> 01:40:00.060]  с pubinpaf.
[01:40:00.060 --> 01:40:02.060]  Ну, то есть, есть такой вот
[01:40:02.060 --> 01:40:04.060]  in и какой-то путь.
[01:40:04.060 --> 01:40:06.060]  Смотрите, путь должен быть обязательно
[01:40:06.060 --> 01:40:08.060]  каким-то родителем.
[01:40:08.060 --> 01:40:10.060]  То есть, я не могу написать там in
[01:40:10.060 --> 01:40:12.060]  crate 2.
[01:40:12.060 --> 01:40:14.060]  Я обязательно должен написать
[01:40:14.060 --> 01:40:16.060]  один из подпутей моих.
[01:40:16.060 --> 01:40:18.060]  То есть, in crate one nested.
[01:40:18.060 --> 01:40:20.060]  И в таком случае я
[01:40:20.060 --> 01:40:22.060]  стану для всех виден потомков,
[01:40:22.060 --> 01:40:24.060]  которые не дальше,
[01:40:24.060 --> 01:40:26.060]  чем этот crate,
[01:40:26.060 --> 01:40:28.060]  не дальше, чем этот модуль.
[01:40:28.060 --> 01:40:30.060]  То есть, таким образом я буду не виден в
[01:40:30.060 --> 01:40:32.060]  корневом модуле,
[01:40:32.060 --> 01:40:34.060]  не буду виден в корневом модуле,
[01:40:34.060 --> 01:40:36.060]  но буду виден в модуле nested.
[01:40:36.060 --> 01:40:38.060]  Ну, и точно, в том числе nested2 и
[01:40:38.060 --> 01:40:40.060]  так далее.
[01:40:40.060 --> 01:40:42.060]  Примерно понятно?
[01:40:46.060 --> 01:40:48.060]  Так. У нас есть еще
[01:40:48.060 --> 01:40:50.060]  keyword use.
[01:40:50.060 --> 01:40:52.060]  И мы тоже пользовались.
[01:40:52.060 --> 01:40:54.060]  Он предназначен для того,
[01:40:54.060 --> 01:40:56.060]  чтобы какие-то имена импортировать.
[01:40:56.060 --> 01:40:58.060]  Вот.
[01:40:58.060 --> 01:41:00.060]  Ну, как это делается?
[01:41:00.060 --> 01:41:02.060]  Например, давайте вот такую фигню
[01:41:02.060 --> 01:41:04.060]  посмотрим.
[01:41:04.060 --> 01:41:06.060]  Странно, кстати, что
[01:41:06.060 --> 01:41:08.060]  у меня сразу же идет пример.
[01:41:08.060 --> 01:41:10.060]  Ладно, use предназначен для того,
[01:41:10.060 --> 01:41:12.060]  чтобы импортировать имена.
[01:41:12.060 --> 01:41:14.060]  Вы уже пользовались им однозначно в домашке
[01:41:14.060 --> 01:41:16.060]  и видели там, например, use, nested,
[01:41:16.060 --> 01:41:18.060]  rc, rc.
[01:41:18.060 --> 01:41:20.060]  Примерно такое.
[01:41:20.060 --> 01:41:22.060]  Вот, смотрите, в этом вот конкретном
[01:41:22.060 --> 01:41:24.060]  примере у нас есть
[01:41:24.060 --> 01:41:26.060]  ля, внутри есть модуль b.
[01:41:26.060 --> 01:41:28.060]  У нас тут есть енамчик какой-то,
[01:41:28.060 --> 01:41:30.060]  функция, еще один енам
[01:41:30.060 --> 01:41:32.060]  и структура. Везде, заметьте,
[01:41:32.060 --> 01:41:34.060]  вот это вот приватное, здесь есть какие-то приватные
[01:41:34.060 --> 01:41:36.060]  поля. То есть функция
[01:41:36.060 --> 01:41:38.060]  поднимает на вход приватную.
[01:41:38.060 --> 01:41:40.060]  Приватный элемент, енами приватная,
[01:41:40.060 --> 01:41:42.060]  здесь вот структурка,
[01:41:42.060 --> 01:41:44.060]  и в структурке здесь вот приватный,
[01:41:44.060 --> 01:41:46.060]  приватное поле.
[01:41:48.060 --> 01:41:50.060]  Ну, то есть поле публично,
[01:41:50.060 --> 01:41:52.060]  оно сам тип приватный.
[01:41:52.060 --> 01:41:54.060]  Если вы это попробуете компилировать,
[01:41:54.060 --> 01:41:56.060]  то тогда раз вам не даст
[01:41:56.060 --> 01:41:58.060]  тип,
[01:41:58.060 --> 01:42:00.060]  который приватный,
[01:42:00.060 --> 01:42:02.060]  вынести за пределы скопа.
[01:42:02.060 --> 01:42:04.060]  Например, в плюсах,
[01:42:04.060 --> 01:42:06.060]  если бы вы сделали внутри класса,
[01:42:06.060 --> 01:42:08.060]  внутри private, объявили
[01:42:08.060 --> 01:42:10.060]  какую-нибудь структурку, как мы сейчас
[01:42:10.060 --> 01:42:12.060]  посмотрим, то
[01:42:12.060 --> 01:42:14.060]  можно было бы с помощью публичной функции эту структурку
[01:42:14.060 --> 01:42:16.060]  достать, потому что
[01:42:16.060 --> 01:42:18.060]  доступность типа имени не одно и то же.
[01:42:18.060 --> 01:42:20.060]  Обратите это одно и то же.
[01:42:22.060 --> 01:42:24.060]  Вот.
[01:42:24.060 --> 01:42:26.060]  Ну, здесь две такие ошибки,
[01:42:26.060 --> 01:42:28.060]  и обратите внимание, здесь нет енама
[01:42:28.060 --> 01:42:30.060]  в этих ошибках, а все потому, что он здесь.
[01:42:30.060 --> 01:42:32.060]  Он в варнинге.
[01:42:32.060 --> 01:42:34.060]  В отличие от структурки и функции,
[01:42:36.060 --> 01:42:38.060]  в енамах можно использовать приватные
[01:42:38.060 --> 01:42:40.060]  типы
[01:42:40.060 --> 01:42:42.060]  внутри енама.
[01:42:42.060 --> 01:42:44.060]  Но это пока что, потому что в дальнейшем
[01:42:44.060 --> 01:42:46.060]  это уже будет
[01:42:46.060 --> 01:42:48.060]  hard error, то есть уже
[01:42:48.060 --> 01:42:50.060]  не варнинг, а именно ошибка.
[01:42:50.060 --> 01:42:52.060]  Тут такое вот стоит у Rasta.
[01:42:52.060 --> 01:42:54.060]  Была такая вот ошибка, и сейчас ее фиксит.
[01:42:58.060 --> 01:43:00.060]  Как-то так.
[01:43:00.060 --> 01:43:02.060]  Ну, это все плюс-плюс, как раз такой пример.
[01:43:04.060 --> 01:43:06.060]  У Example будет, соответственно, тип
[01:43:06.060 --> 01:43:08.060]  экзамп.
[01:43:08.060 --> 01:43:10.060]  Так.
[01:43:10.060 --> 01:43:12.060]  Теперь модули и файлы.
[01:43:12.060 --> 01:43:14.060]  Вот смотрите, у нас была вот такая структура,
[01:43:14.060 --> 01:43:16.060]  какая-то хитра.
[01:43:16.060 --> 01:43:18.060]  И это было очень похоже на какие-то
[01:43:18.060 --> 01:43:20.060]  Unix веб-путины, то есть Scranet это был
[01:43:20.060 --> 01:43:22.060]  какой-то краневой путь, а Super
[01:43:22.060 --> 01:43:24.060]  это был к родителю.
[01:43:24.060 --> 01:43:26.060]  Это на самом деле не совпадение.
[01:43:26.060 --> 01:43:28.060]  Это так и работает,
[01:43:28.060 --> 01:43:30.060]  как бы,
[01:43:30.060 --> 01:43:32.060]  как бы.
[01:43:32.060 --> 01:43:34.060]  Но, в общем, это все
[01:43:34.060 --> 01:43:36.060]  просто.
[01:43:36.060 --> 01:43:38.060]  Это не совпадение.
[01:43:38.060 --> 01:43:40.060]  Это так и работает.
[01:43:40.060 --> 01:43:42.060]  Ну и прямо сейчас превратим вот это все добро
[01:43:42.060 --> 01:43:44.060]  вот в это.
[01:43:46.060 --> 01:43:48.060]  То есть все модули, модуль каждый
[01:43:48.060 --> 01:43:50.060]  из себя представляет какие-то файлы.
[01:43:50.060 --> 01:43:52.060]  На самом деле. То есть вы можете писать
[01:43:52.060 --> 01:43:54.060]  внутри файла модуля, а можете
[01:43:54.060 --> 01:43:56.060]  в качестве модуля использовать папку
[01:43:56.060 --> 01:43:58.060]  либо файл. Ну сейчас посмотрим, как это работает.
[01:44:00.060 --> 01:44:02.060]  Каждый файл, во-первых, является
[01:44:02.060 --> 01:44:04.060]  модулем.
[01:44:04.060 --> 01:44:06.060]  И путь до него, это собственно
[01:44:06.060 --> 01:44:08.060]  включая его имя,
[01:44:08.060 --> 01:44:10.060]  это и есть путь
[01:44:10.060 --> 01:44:12.060]  до него, как
[01:44:12.060 --> 01:44:14.060]  до модуля в программе.
[01:44:14.060 --> 01:44:16.060]  Исключение это только MainRC
[01:44:16.060 --> 01:44:18.060]  либо RC и ModRC.
[01:44:18.060 --> 01:44:20.060]  Они свое имя игнорируют.
[01:44:20.060 --> 01:44:22.060]  Скажем так.
[01:44:22.060 --> 01:44:24.060]  То есть ModRC либо RC, вы находитесь
[01:44:24.060 --> 01:44:26.060]  по умолчанию, если вы пишете код, вы находитесь
[01:44:26.060 --> 01:44:28.060]  в корневом модуле. В ModRC
[01:44:28.060 --> 01:44:30.060]  вы находитесь в модуле, который соответствует
[01:44:30.060 --> 01:44:32.060]  тому, в каких папочках вы находитесь.
[01:44:32.060 --> 01:44:34.060]  Где?
[01:44:36.060 --> 01:44:38.060]  Да, ну смотри,
[01:44:38.060 --> 01:44:40.060]  у нас есть такая вот файловая система.
[01:44:40.060 --> 01:44:42.060]  Ну ты примерно помнишь, что там
[01:44:42.060 --> 01:44:44.060]  one, nested, nested2,
[01:44:44.060 --> 01:44:46.060]  вот это вот было.
[01:44:46.060 --> 01:44:48.060]  Смотрите, у нас вот здесь либо RC,
[01:44:48.060 --> 01:44:50.060]  внутри, если мы пишем код либо RC,
[01:44:50.060 --> 01:44:52.060]  то мы находимся в корневом модуле.
[01:44:52.060 --> 01:44:54.060]  Если мы пишем код в 2RC,
[01:44:54.060 --> 01:44:56.060]  который вот здесь вот,
[01:44:56.060 --> 01:44:58.060]  то мы находимся в модуле 2.
[01:44:58.060 --> 01:45:00.060]  Так?
[01:45:00.060 --> 01:45:02.060]  Соответственно, смотрите, вот здесь вот папочка,
[01:45:02.060 --> 01:45:04.060]  а внутри папочки у нас ModRC.
[01:45:04.060 --> 01:45:06.060]  Соответственно, то,
[01:45:06.060 --> 01:45:08.060]  что находится внутри ModRC, имеет
[01:45:08.060 --> 01:45:10.060]  путь просто one,
[01:45:10.060 --> 01:45:12.060]  модуль one.
[01:45:12.060 --> 01:45:14.060]  Если бы здесь был какой-нибудь файлик, там не знаю,
[01:45:14.060 --> 01:45:16.060]  exampleRC, в таком случае
[01:45:16.060 --> 01:45:18.060]  до него бы был путь
[01:45:18.060 --> 01:45:20.060]  one, exampleRC внутри файла.
[01:45:20.060 --> 01:45:22.060]  Если бы внутри
[01:45:22.060 --> 01:45:24.060]  exampleRC писали был какой-то код,
[01:45:26.060 --> 01:45:28.060]  то получилось бы примерно так.
[01:45:28.060 --> 01:45:30.060]  Вот.
[01:45:30.060 --> 01:45:32.060]  Ну и, соответственно,
[01:45:32.060 --> 01:45:34.060]  почему мы вообще сделали папку?
[01:45:34.060 --> 01:45:36.060]  Потому что мы хотим, чтобы у нас был модуль,
[01:45:36.060 --> 01:45:38.060]  и внутри модуля был и код,
[01:45:38.060 --> 01:45:40.060]  и, соответственно, другой модуль.
[01:45:40.060 --> 01:45:42.060]  Вот.
[01:45:42.060 --> 01:45:44.060]  Но если у вас внутри модуля только код,
[01:45:44.060 --> 01:45:46.060]  то вы можете ограничиться файлом.
[01:45:46.060 --> 01:45:48.060]  Даже не можете ограничиться файлом.
[01:45:48.060 --> 01:45:50.060]  А если вы хотите внутри модуля сделать
[01:45:50.060 --> 01:45:52.060]  другой модуль и еще файлы,
[01:45:52.060 --> 01:45:54.060]  то вам нужно сделать папочку,
[01:45:54.060 --> 01:45:56.060]  внутри нее ModRC,
[01:45:56.060 --> 01:45:58.060]  соответственно, по модулям либо файлы,
[01:45:58.060 --> 01:46:00.060]  либо еще папочки.
[01:46:00.060 --> 01:46:02.060]  Я думаю, что будет нагляднее, если вы
[01:46:02.060 --> 01:46:04.060]  потом после лекции посмотрите прямо
[01:46:04.060 --> 01:46:06.060]  на вот этот же код,
[01:46:06.060 --> 01:46:08.060]  который расфасован по файликам,
[01:46:08.060 --> 01:46:10.060]  и увидите, как оно работает.
[01:46:10.060 --> 01:46:12.060]  То есть я скину прямо,
[01:46:12.060 --> 01:46:14.060]  оно будет рядом с лекцией лежать код.
[01:46:16.060 --> 01:46:18.060]  Вот, как я сказал, 2RC есть
[01:46:18.060 --> 01:46:20.060]  путь CrateFoo,
[01:46:20.060 --> 01:46:22.060]  Crate2, соответственно,
[01:46:22.060 --> 01:46:24.060]  полный. И у nested2RC, соответственно,
[01:46:24.060 --> 01:46:26.060]  Crate1, nested, nested2,
[01:46:26.060 --> 01:46:28.060]  как можно увидеть.
[01:46:28.060 --> 01:46:30.060]  Соответственно, вот наш Crate,
[01:46:30.060 --> 01:46:32.060]  Crate1, nested, ну и соответственно
[01:46:32.060 --> 01:46:34.060]  название файла nested2.
[01:46:36.060 --> 01:46:38.060]  Как-то так.
[01:46:38.060 --> 01:46:40.060]  Когда у вас, у вашего модуля
[01:46:40.060 --> 01:46:42.060]  не только код и другие модули,
[01:46:42.060 --> 01:46:44.060]  но, как я сказал, нужно создать папочку
[01:46:44.060 --> 01:46:46.060]  и внутреннюю ModRC положить.
[01:46:46.060 --> 01:46:48.060]  Например, внутри модуля
[01:46:48.060 --> 01:46:50.060]  RC,
[01:46:50.060 --> 01:46:52.060]  но ModRC в nested будет путь
[01:46:52.060 --> 01:46:54.060]  Crate1, nested,
[01:46:54.060 --> 01:46:56.060]  и не будет
[01:46:56.060 --> 01:46:58.060]  двоеточие мод,
[01:46:58.060 --> 01:47:00.060]  как в случае файлика.
[01:47:02.060 --> 01:47:04.060]  Модули недоступны для всей программы
[01:47:04.060 --> 01:47:06.060]  по дефолту.
[01:47:06.060 --> 01:47:08.060]  Чтобы
[01:47:08.060 --> 01:47:10.060]  включить модуль
[01:47:10.060 --> 01:47:12.060]  в всю программу, то вам нужно использовать
[01:47:12.060 --> 01:47:14.060]  PubMod.
[01:47:14.060 --> 01:47:16.060]  Ну то есть, если вы хотите
[01:47:16.060 --> 01:47:18.060]  CRC1ModRC,
[01:47:18.060 --> 01:47:20.060]  то есть добавить еще один какой-то
[01:47:20.060 --> 01:47:22.060]  модуль, чтобы у вас был путь
[01:47:22.060 --> 01:47:24.060]  Crate1, nested,
[01:47:24.060 --> 01:47:26.060]  то вам нужно сделать PubMod, nested.
[01:47:26.060 --> 01:47:28.060]  И тут обратить внимание, у нас MyTrade
[01:47:28.060 --> 01:47:30.060]  сидит, потому что мы хотим, чтобы у нас
[01:47:30.060 --> 01:47:32.060]  в Crate1
[01:47:32.060 --> 01:47:34.060]  был еще
[01:47:34.060 --> 01:47:36.060]  MyTrade
[01:47:36.060 --> 01:47:38.060]  соответствующий нашему коду.
[01:47:42.060 --> 01:47:44.060]  Так, ну...
[01:47:44.060 --> 01:47:46.060]  Соответственно, каждый модуль
[01:47:46.060 --> 01:47:48.060]  один раз подключает
[01:47:48.060 --> 01:47:50.060]  и дублирует.
[01:47:50.060 --> 01:47:52.060]  Да, он только один раз подключает.
[01:47:52.060 --> 01:47:54.060]  Более того, вообще, на самом деле, SlowMod работает
[01:47:54.060 --> 01:47:56.060]  по сути так же, как и Include.
[01:47:56.060 --> 01:47:58.060]  За все compilation unit здоровый,
[01:47:58.060 --> 01:48:00.060]  поэтому он просто это все поставляет
[01:48:00.060 --> 01:48:02.060]  и скопилирует все как один пайл.
[01:48:02.060 --> 01:48:04.060]  В смысле, Include уже может
[01:48:04.060 --> 01:48:06.060]  копировать?
[01:48:06.060 --> 01:48:08.060]  Ну, Include копирует, но если ты напишешь
[01:48:08.060 --> 01:48:10.060]  второй раз Mod, я даже не помню, что
[01:48:10.060 --> 01:48:12.060]  сделает Rust.
[01:48:12.060 --> 01:48:14.060]  Я не про то, что если
[01:48:14.060 --> 01:48:16.060]  два багата одинаковых, а если вот
[01:48:16.060 --> 01:48:18.060]  мы импортируем
[01:48:18.060 --> 01:48:20.060]  какой-то модуль, а в нем импортируется
[01:48:20.060 --> 01:48:22.060]  второй модуль.
[01:48:22.060 --> 01:48:24.060]  И, соответственно, на верхнем уровне
[01:48:24.060 --> 01:48:26.060]  мы отдельно еще раз
[01:48:26.060 --> 01:48:28.060]  с самого начала этот модуль
[01:48:28.060 --> 01:48:30.060]  импортирует модуль. С самого начала этот модуль
[01:48:30.060 --> 01:48:32.060]  попадет в этот модуль, а потом вот сюда
[01:48:32.060 --> 01:48:34.060]  вниз еще. Соответственно, получится
[01:48:34.060 --> 01:48:36.060]  есть трех файлов.
[01:48:36.060 --> 01:48:38.060]  Ну вот у нас три модуля,
[01:48:38.060 --> 01:48:40.060]  три файла. Один, два, три.
[01:48:40.060 --> 01:48:42.060]  В первом написано
[01:48:42.060 --> 01:48:44.060]  будет BobMod2
[01:48:44.060 --> 01:48:46.060]  и BobMod3.
[01:48:46.060 --> 01:48:48.060]  А в третьем написано BobMod2.
[01:48:48.060 --> 01:48:50.060]  А, не будет ли второй раз
[01:48:50.060 --> 01:48:52.060]  импортироваться? Нет, не будет.
[01:48:52.060 --> 01:48:54.060]  Ну, считай Pragmalance написано.
[01:48:54.060 --> 01:48:56.060]  Более того,
[01:48:56.060 --> 01:48:58.060]  Rust, как мы уже видели,
[01:48:58.060 --> 01:49:00.060]  в каком порядке у вас идут
[01:49:00.060 --> 01:49:02.060]  декларации структуры. То есть, может сначала
[01:49:02.060 --> 01:49:04.060]  пользоваться структуру и потом написать ее
[01:49:04.060 --> 01:49:06.060]  декларацию. Это легально.
[01:49:06.060 --> 01:49:08.060]  Потому что в Rust есть гарантия
[01:49:08.060 --> 01:49:10.060]  на то, что у вас одна декларация структуры,
[01:49:10.060 --> 01:49:12.060]  одна декларация функции
[01:49:12.060 --> 01:49:14.060]  и так далее.
[01:49:14.060 --> 01:49:16.060]  Поэтому он может себе такое позволить.
[01:49:18.060 --> 01:49:20.060]  Ну вот, собственно, RC.
[01:49:20.060 --> 01:49:22.060]  С примером с RC use.
[01:49:22.060 --> 01:49:24.060]  Не знаю, как use попал куда-то наверх,
[01:49:24.060 --> 01:49:26.060]  но как есть.
[01:49:26.060 --> 01:49:28.060]  Вот.
[01:49:28.060 --> 01:49:30.060]  use std rc rc. И после этого
[01:49:30.060 --> 01:49:32.060]  мы создаем rc new.
[01:49:32.060 --> 01:49:34.060]  Обратите внимание, что за счет того,
[01:49:34.060 --> 01:49:36.060]  что я сделал use, то в таком случае
[01:49:36.060 --> 01:49:38.060]  у меня сразу же доступно имя.
[01:49:38.060 --> 01:49:40.060]  Мне не нужно писать полностью std rc rc.
[01:49:40.060 --> 01:49:42.060]  Хотя бы я мог это сделать.
[01:49:42.060 --> 01:49:44.060]  То есть, я бы мог без use написать просто
[01:49:44.060 --> 01:49:46.060]  полностью имя, и в таком случае у меня бы все работало.
[01:49:46.060 --> 01:49:48.060]  Просто, что это удобно.
[01:49:50.060 --> 01:49:52.060]  Более того, мы можем дать alias.
[01:49:52.060 --> 01:49:54.060]  Вот такое вот. То есть, вот с нашим
[01:49:54.060 --> 01:49:56.060]  примером 1.1.2.foo
[01:49:56.060 --> 01:49:58.060]  вместо того, чтобы это писать, можно написать
[01:49:58.060 --> 01:50:00.060]  stest и после этого пользоваться
[01:50:00.060 --> 01:50:02.060]  foo как тест. И все.
[01:50:04.060 --> 01:50:06.060]  Примерно похоже на Python.
[01:50:06.060 --> 01:50:08.060]  Но,
[01:50:08.060 --> 01:50:10.060]  более того, импл блоки.
[01:50:10.060 --> 01:50:12.060]  Если у вас импл блок
[01:50:12.060 --> 01:50:14.060]  для структуры просто, то он доступен
[01:50:14.060 --> 01:50:16.060]  у него публичисть
[01:50:16.060 --> 01:50:18.060]  ровно такая же, как, собственно, у самой
[01:50:18.060 --> 01:50:20.060]  структуры. А если у вас импл
[01:50:20.060 --> 01:50:22.060]  блок trade для структуры,
[01:50:22.060 --> 01:50:24.060]  тогда у вас публичность минимальная
[01:50:24.060 --> 01:50:26.060]  из доступности трейта и структуры.
[01:50:28.060 --> 01:50:30.060]  То есть, соответственно, структуры,
[01:50:30.060 --> 01:50:32.060]  потому что вы не сможете создать структуру,
[01:50:32.060 --> 01:50:34.060]  и, соответственно, воспользоваться трейтом.
[01:50:34.060 --> 01:50:41.060]  А для того, чтобы воспользоваться функциями трейта, нужно импортировать сам трейт, как мы это могли видеть, например, в домашней комме.
[01:50:41.060 --> 01:50:47.060]  А для того, чтобы пользоваться функциями write, нужно было имплементировать traitWrite.
[01:50:47.060 --> 01:50:54.060]  И обратите внимание, что я к тому же ему еще дал такое вот приватное имя, underscope.
[01:50:54.060 --> 01:50:59.060]  Это означает то, что мы импортируем методы трейта, но сам трейт не импортируем.
[01:50:59.060 --> 01:51:04.060]  То есть это нам позволяет в текущем скопе создать, например, свой traitWrite.
[01:51:04.060 --> 01:51:06.060]  Почему бы и нет? Второе имя.
[01:51:06.060 --> 01:51:10.060]  А если бы мы так не сделали, тогда бы write постоянно думал, но у нас write уже есть в скопе.
[01:51:10.060 --> 01:51:12.060]  Мы его импортировали.
[01:51:12.060 --> 01:51:17.060]  То есть это достаточно удобно для того, чтобы не засорять в лишний раз на импспейс.
[01:51:17.060 --> 01:51:18.060]  Иногда бывает.
[01:51:18.060 --> 01:51:22.060]  Сейчас если чем нам импортировать write из скопы?
[01:51:22.060 --> 01:51:23.060]  Помню.
[01:51:23.060 --> 01:51:26.060]  Ну еще раз underscope вы сказали, мы использовали...
[01:51:26.060 --> 01:51:33.060]  Underscope говорит, что ты заимпорцировал trait, но не само его имя.
[01:51:33.060 --> 01:51:38.060]  То есть тебе дадут доступные методы trait, но не сам trait по имени.
[01:51:45.060 --> 01:51:48.060]  Потом у нас есть такое ключевое слово use называется.
[01:51:48.060 --> 01:51:50.060]  Как я уже сказал несколько раз.
[01:51:50.060 --> 01:51:52.060]  Потому что в томате считаю.
[01:51:56.060 --> 01:51:59.060]  Ну смотрите, у нас здесь можно еще воспользоваться ключевым словом self.
[01:51:59.060 --> 01:52:02.060]  Оно и заимплементирует только текущий модуль.
[01:52:02.060 --> 01:52:04.060]  Ну заимпортирует.
[01:52:04.060 --> 01:52:07.060]  Смотрите, у нас в std-collections сидит hashMap.
[01:52:07.060 --> 01:52:12.060]  Соответственно, если я сделаю use std-collections self, тогда у меня заимпортируется hashMap.
[01:52:12.060 --> 01:52:14.060]  Соответственно, если я попробую...
[01:52:14.060 --> 01:52:20.060]  Ну в std-collections hashMap defaultHasher, здесь сидит defaultHasher, который мы уже знаем с прошлой лекции.
[01:52:20.060 --> 01:52:23.060]  Если я так заимпортирую, то это не скомпилируется.
[01:52:23.060 --> 01:52:28.060]  Вот если бы я заимпортировал std-collections, просто use std-collections,
[01:52:28.060 --> 01:52:31.060]  то тогда бы здесь мог написать collections hashMap,
[01:52:31.060 --> 01:52:35.060]  а здесь мог написать collections hashMap только с маленькими буквами.
[01:52:44.060 --> 01:52:47.060]  Ну смотри, это означает импортировать все имена в этом модуле.
[01:52:47.060 --> 01:52:50.060]  Все, что внутри модулы std-collections.
[01:52:51.060 --> 01:52:54.060]  Вот он тогда заимплантирует hashMap.
[01:52:54.060 --> 01:53:00.060]  DefaultHasher находится не в самом std-collections, а в std-collections hashMap с маленькими буквами,
[01:53:00.060 --> 01:53:02.060]  а потом уже defaultHasher.
[01:53:03.060 --> 01:53:08.060]  То есть по факту он заимпортирует вот этот hash нижнее подчеркивание map.
[01:53:08.060 --> 01:53:15.060]  Только так как модуль сам по себе нет смысла импортировать, то это не скомпилируется.
[01:53:15.060 --> 01:53:21.060]  Вот как раз по иерархии не пойдет.
[01:53:21.060 --> 01:53:24.060]  Тут есть пример, когда мы пойдем по иерархии вниз.
[01:53:24.060 --> 01:53:27.060]  Смотри, есть звездочка.
[01:53:27.060 --> 01:53:29.060]  Звездочка это все имена импортировать.
[01:53:29.060 --> 01:53:32.060]  Не нужно их злоупотреблять, конечно.
[01:53:36.060 --> 01:53:39.060]  Self только внутри текущего модуля.
[01:53:39.060 --> 01:53:42.060]  Дальше не идет.
[01:53:42.060 --> 01:53:46.060]  Звездочка она импортирует все имена дальше.
[01:53:46.060 --> 01:53:50.060]  Вот у нас, например, modA, modB, enumC.
[01:53:50.060 --> 01:53:53.060]  И после этого я пишу useA, два две точки, звездочка.
[01:53:53.060 --> 01:53:55.060]  И после этого я могу написать b, c и x.
[01:53:55.060 --> 01:53:57.060]  Потому что b импортировал, дальше c и x.
[01:53:57.060 --> 01:53:59.060]  Потому что они тоже импортируют.
[01:54:03.060 --> 01:54:08.060]  Если бы ты написал a self, то в таком случае у тебя бы ничего за ней не заимпортилось.
[01:54:12.060 --> 01:54:14.060]  Да.
[01:54:14.060 --> 01:54:17.060]  Сама modA ничего нет, поэтому ничего не заимпортится.
[01:54:21.060 --> 01:54:23.060]  Еще можно...
[01:54:23.060 --> 01:54:25.060]  Здесь пропало два двое точек.
[01:54:28.060 --> 01:54:31.060]  Если вы хотите заимпортить все варианты enum,
[01:54:31.060 --> 01:54:33.060]  то в таком случае вы можете написать нод,
[01:54:33.060 --> 01:54:37.060]  как здесь написано a, b, c, 2, 2 и точка, звездочка.
[01:54:37.060 --> 01:54:41.060]  В таком случае вы сможете воспользоваться напрямую вариантом enum.
[01:54:41.060 --> 01:54:44.060]  Именно так сделано в собственном стандартной библиотеке.
[01:54:44.060 --> 01:54:48.060]  То, что вы можете написать сам и нам в коде,
[01:54:48.060 --> 01:54:51.060]  это заслуга того, что там импортированы все варианты enum.
[01:54:51.060 --> 01:54:53.060]  В код.
[01:54:53.060 --> 01:54:55.060]  Да, в прелюде.
[01:54:55.060 --> 01:54:57.060]  Про прелюд мы сейчас поговорим, но для начала...
[01:54:57.060 --> 01:54:59.060]  А, знаешь, сразу про прелюд.
[01:54:59.060 --> 01:55:01.060]  Так.
[01:55:01.060 --> 01:55:04.060]  Стиди, это тоже крейт.
[01:55:04.060 --> 01:55:10.060]  Естественно, как и все, она так задизайнена в расти.
[01:55:10.060 --> 01:55:14.060]  Его версия зависит от версии вашего компилятора.
[01:55:14.060 --> 01:55:17.060]  Когда мы пишем программу на расти,
[01:55:17.060 --> 01:55:19.060]  вы не должны...
[01:55:19.060 --> 01:55:23.060]  В общем, вам не приходится писать полностью имена.
[01:55:23.060 --> 01:55:27.060]  Стиди, век, век или use, cd, box, box.
[01:55:27.060 --> 01:55:30.060]  Потому что это уже за вас сделано.
[01:55:30.060 --> 01:55:32.060]  Это сделано в модуле cd-прелюд.
[01:55:32.060 --> 01:55:36.060]  cd-прелюд – это тот модуль, который неявно добавляется в ваш код.
[01:55:37.060 --> 01:55:41.060]  Ну, то есть там написано use, cd, прелюд, звездочка,
[01:55:41.060 --> 01:55:43.060]  и все из прелюда импортируется.
[01:55:43.060 --> 01:55:46.060]  А сам прелюд, в свою очередь, в другие юзы имеет.
[01:55:46.060 --> 01:55:50.060]  То есть, например, внутри имеет pub, use, cd, век, век.
[01:55:50.060 --> 01:55:55.060]  И, соответственно, вон выступен вектор в вашем коде.
[01:55:55.060 --> 01:55:57.060]  Вот.
[01:55:57.060 --> 01:55:59.060]  От прелюда можно отказаться.
[01:55:59.060 --> 01:56:01.060]  Наверное, не нужно.
[01:56:01.060 --> 01:56:06.060]  Он в целом никаких отрицательных, скажем так, черту у него,
[01:56:06.060 --> 01:56:08.060]  того, что он компилируется, нет.
[01:56:10.060 --> 01:56:12.060]  Вот.
[01:56:12.060 --> 01:56:14.060]  Ну, это, кажется, все.
[01:56:14.060 --> 01:56:16.060]  Что прелюд.
[01:56:18.060 --> 01:56:21.060]  Так, импортируем крейт как приватный какой-то модуль.
[01:56:21.060 --> 01:56:23.060]  Для начала.
[01:56:23.060 --> 01:56:25.060]  Ну, это какой-то мод крейт.
[01:56:25.060 --> 01:56:27.060]  Потом мы...
[01:56:27.060 --> 01:56:29.060]  Сейчас, еще секундочку.
[01:56:32.060 --> 01:56:34.060]  А ну да.
[01:56:36.060 --> 01:56:38.060]  Это то, как мы...
[01:56:38.060 --> 01:56:41.060]  Ну, смотрите, у нас есть какой-то модуль MyCrate.
[01:56:41.060 --> 01:56:43.060]  Обратите внимание, что он приватный.
[01:56:43.060 --> 01:56:47.060]  Ну, то есть, вдруг мне захочется из чего-то приватного
[01:56:47.060 --> 01:56:50.060]  достать какое-то имя.
[01:56:50.060 --> 01:56:53.060]  Один из вариантов это сделать вот такой вот pub, use.
[01:56:55.060 --> 01:56:58.060]  Вы пишете pub, use, и в таком случае вам доступно имя foo
[01:56:58.060 --> 01:57:00.060]  в другом крейте.
[01:57:00.060 --> 01:57:02.060]  MyCrate foo.
[01:57:04.060 --> 01:57:07.060]  Ну, то есть, use – это примерно как using gifc++.
[01:57:07.060 --> 01:57:10.060]  Ну, using gifc++ имеет другое, более широкое значение,
[01:57:10.060 --> 01:57:14.060]  а use в Rust используется только для того, чтобы импортировать имена.
[01:57:14.060 --> 01:57:16.060]  Как-то так.
[01:57:23.060 --> 01:57:25.060]  Так, ну и с этим понятно.
[01:57:25.060 --> 01:57:27.060]  Так, ну и важное такое замечание.
[01:57:27.060 --> 01:57:31.060]  Std – это такая библиотека, которая старается быть максимально маленькой.
[01:57:31.060 --> 01:57:35.060]  Ну, то есть, она предоставляет вам только самое необходимое крейте.
[01:57:35.060 --> 01:57:37.060]  И самые необходимые функции.
[01:57:37.060 --> 01:57:39.060]  Ну, это, знаете, такой Unix way.
[01:57:39.060 --> 01:57:43.060]  У нас там есть какое-то минимальное окружение, которое работоспособно.
[01:57:43.060 --> 01:57:46.060]  А после этого все, что хотите, докидываете в пакеты.
[01:57:46.060 --> 01:57:49.060]  Вот как в Linux это, например, устроено.
[01:57:49.060 --> 01:57:52.060]  Это потому, что у нас есть какой-то минимальное окружение,
[01:57:52.060 --> 01:57:54.060]  например, устроено.
[01:57:54.060 --> 01:57:57.060]  Это потому, что очень сильно упрощает поддержку.
[01:58:00.060 --> 01:58:06.060]  Ну и вообще, это хорошее разделение ответственности.
[01:58:09.060 --> 01:58:11.060]  Ну, например, хешмапы есть примерно в каждой программе,
[01:58:11.060 --> 01:58:14.060]  поэтому стд библиотека имплементирует какую-то свою хешмапу.
[01:58:14.060 --> 01:58:18.060]  А вот, например, еще есть такой пример.
[01:58:18.060 --> 01:58:21.060]  Есть вещи, которые нет в каждой программе.
[01:58:21.060 --> 01:58:23.060]  Например, какой-то асинхронный код.
[01:58:23.060 --> 01:58:29.060]  Но тем не менее, так как асинхронные рентаймы можно написать очень по-разному.
[01:58:29.060 --> 01:58:36.060]  И Rust очень хочет сделать так, чтобы у всех асинхронных рентаймов
[01:58:36.060 --> 01:58:38.060]  было примерно одинаково...
[01:58:38.060 --> 01:58:40.060]  В общем, им можно было примерно одинаково пользоваться
[01:58:40.060 --> 01:58:42.060]  с точки зрения пользователей.
[01:58:42.060 --> 01:58:45.060]  Поэтому Rust предоставляет такие трейты как future,
[01:58:45.060 --> 01:58:49.060]  ключевое слово async и await, macros и join и select.
[01:58:49.060 --> 01:58:51.060]  Об этом мы попозже познакомимся.
[01:58:51.060 --> 01:58:53.060]  Но то, о чем я вам хочу сказать,
[01:58:53.060 --> 01:58:55.060]  это то, что это все предназначено для того,
[01:58:55.060 --> 01:58:59.060]  чтобы как-то весь зоопарк асинхронных крейтов,
[01:58:59.060 --> 01:59:03.060]  крейтов, связанных с асинхронностью,
[01:59:03.060 --> 01:59:06.060]  как-то стандартизовалась в стандартной библиотеке.
[01:59:06.060 --> 01:59:08.060]  То есть чтобы они через стандартную библиотеку,
[01:59:08.060 --> 01:59:10.060]  через строительство стандарта библиотеки работали.
[01:59:10.060 --> 01:59:12.060]  Соответственно, есть, например, ключевые слова await,
[01:59:12.060 --> 01:59:14.060]  которые работают вне зависимости от того,
[01:59:14.060 --> 01:59:18.060]  какой библиотекой асинхронности вы пользуетесь.
[01:59:18.060 --> 01:59:21.060]  Например, async STD или Tokyo.
[01:59:21.060 --> 01:59:26.060]  В первом случае мы добавили хэшмапу,
[01:59:26.060 --> 01:59:28.060]  потому что он примерно в каждой программе,
[01:59:28.060 --> 01:59:30.060]  и это необходимо добавить.
[01:59:30.060 --> 01:59:32.060]  А здесь мы хотим так сделать,
[01:59:32.060 --> 01:59:36.060]  потому что мы хотим зоопарк как-то стандартизировать.
[01:59:36.060 --> 01:59:38.060]  Понятная идея.
[01:59:38.060 --> 01:59:41.060]  То есть в Раффите, скажем так,
[01:59:41.060 --> 01:59:43.060]  стандартизация работает на уровне крейтов,
[01:59:43.060 --> 01:59:45.060]  в отличие от плюсов?
[01:59:45.060 --> 01:59:46.060]  Да, на крейтов.
[01:59:46.060 --> 01:59:48.060]  Она работает на уровне имплементации?
[01:59:48.060 --> 01:59:50.060]  Да, тут крейты есть, есть trade future,
[01:59:50.060 --> 01:59:52.060]  там всякие контексты, полы,
[01:59:52.060 --> 01:59:54.060]  мы с ним попожим.
[01:59:54.060 --> 01:59:57.060]  Так, мы закончили как раз
[01:59:57.060 --> 01:59:59.060]  со всем связанным с модулем,
[01:59:59.060 --> 02:00:01.060]  если какие-то вопросы.
[02:00:01.060 --> 02:00:04.060]  Мы действительно, кстати, быстро прошли.
[02:00:08.060 --> 02:00:10.060]  Наверное, пойдем дальше.
[02:00:12.060 --> 02:00:14.060]  Я думаю, мы, кстати,
[02:00:14.060 --> 02:00:16.060]  уже через 15 минут может закончим.
[02:00:22.060 --> 02:00:26.060]  Ну, там меньше 40 слайдов.
[02:00:28.060 --> 02:00:30.060]  Мы уже прошли что-то типа 140,
[02:00:30.060 --> 02:00:32.060]  поэтому нет.
[02:00:38.060 --> 02:00:40.060]  Ну, хорошо, у нас есть такая,
[02:00:40.060 --> 02:00:43.060]  ну, в общем, в отличие от плюсов,
[02:00:43.060 --> 02:00:46.060]  итератор такая неспецифичная структура,
[02:00:46.060 --> 02:00:48.060]  не конкретная структура,
[02:00:48.060 --> 02:00:50.060]  это trade.
[02:00:50.060 --> 02:00:52.060]  Как мы уже поняли,
[02:00:52.060 --> 02:00:54.060]  в раффите есть имплементации.
[02:00:54.060 --> 02:00:56.060]  Нет, ну почему?
[02:00:56.060 --> 02:00:58.060]  Есть имплементации для вектора,
[02:00:58.060 --> 02:01:00.060]  для слайса, для хэш-мап,
[02:01:00.060 --> 02:01:02.060]  хэш-сетов, ве-три-мэп,
[02:01:02.060 --> 02:01:04.060]  там итераторы можно даже из опшена сделать,
[02:01:04.060 --> 02:01:06.060]  ну, очень много чего.
[02:01:06.060 --> 02:01:08.060]  На шоу трейдов
[02:01:08.060 --> 02:01:10.060]  в стадилибе
[02:01:10.060 --> 02:01:12.060]  раффер все равно повыше,
[02:01:12.060 --> 02:01:14.060]  чем подобными это фигни.
[02:01:16.060 --> 02:01:18.060]  Так, окей.
[02:01:18.060 --> 02:01:20.060]  Ну, у нас
[02:01:20.060 --> 02:01:22.060]  вы, наверное, уже успели
[02:01:22.060 --> 02:01:24.060]  попользоваться итераторами в домашке.
[02:01:24.060 --> 02:01:26.060]  Мы как-то к ним
[02:01:26.060 --> 02:01:28.060]  подошли достаточно поздно.
[02:01:28.060 --> 02:01:30.060]  Итератор достаточно простенький
[02:01:30.060 --> 02:01:32.060]  с виду трейд,
[02:01:32.060 --> 02:01:34.060]  безобидный.
[02:01:34.060 --> 02:01:36.060]  Итератор с айтом
[02:01:36.060 --> 02:01:38.060]  это то, что мы возвращаем
[02:01:38.060 --> 02:01:40.060]  next, которое возвращает опшен
[02:01:40.060 --> 02:01:42.060]  с self-item.
[02:01:42.060 --> 02:01:44.060]  Ну, и мутирует соответственно итератор,
[02:01:44.060 --> 02:01:46.060]  потому что итератор должен как-то меняться,
[02:01:46.060 --> 02:01:48.060]  когда вы из него уберете элемент.
[02:01:48.060 --> 02:01:50.060]  Ну, и еще важный вопрос,
[02:01:50.060 --> 02:01:52.060]  ну, важное такое замечание.
[02:01:52.060 --> 02:01:54.060]  Если возвращается наун,
[02:01:54.060 --> 02:01:56.060]  то мы по умолчанию считаем,
[02:01:56.060 --> 02:01:58.060]  что итератор закончился.
[02:01:58.060 --> 02:02:00.060]  На самом деле
[02:02:00.060 --> 02:02:02.060]  вам никто не запрещает
[02:02:02.060 --> 02:02:04.060]  возвращать какие-то самы,
[02:02:04.060 --> 02:02:06.060]  возвращать опять наун и так далее.
[02:02:06.060 --> 02:02:08.060]  Но большая часть имплементации
[02:02:08.060 --> 02:02:10.060]  трейд в стандартной библиотеке
[02:02:10.060 --> 02:02:12.060]  все же полагается на то,
[02:02:12.060 --> 02:02:14.060]  что вы после наун больше ничего не возвращаете.
[02:02:14.060 --> 02:02:16.060]  Ну, и соответственно,
[02:02:16.060 --> 02:02:18.060]  не удивляйтесь,
[02:02:18.060 --> 02:02:20.060]  если у вас, например,
[02:02:20.060 --> 02:02:22.060]  итерация закончится раньше времени
[02:02:22.060 --> 02:02:24.060]  из-за того, что у вас не подряд
[02:02:24.060 --> 02:02:26.060]  возвращаете элементы. Нормально.
[02:02:26.060 --> 02:02:28.060]  То после этого момента
[02:02:28.060 --> 02:02:30.060]  большая часть имплементации
[02:02:30.060 --> 02:02:32.060]  в пункте стандартной библиотеки
[02:02:32.060 --> 02:02:34.060]  считает, что дальше ничего не будет.
[02:02:34.060 --> 02:02:36.060]  Все будет на.
[02:02:40.060 --> 02:02:42.060]  Не, ну, тебя никто не мешает
[02:02:42.060 --> 02:02:44.060]  сделать так, чтобы next поочередно
[02:02:44.060 --> 02:02:46.060]  возвращал сам что-то там, но
[02:02:46.060 --> 02:02:48.060]  сам что-то там.
[02:02:56.060 --> 02:02:58.060]  Возвращает next,
[02:02:58.060 --> 02:03:00.060]  а предследующий сейчас еще раз.
[02:03:12.060 --> 02:03:14.060]  Нет.
[02:03:14.060 --> 02:03:16.060]  Она не вызывает еще раз после науны.
[02:03:16.060 --> 02:03:18.060]  Там даже есть такой
[02:03:18.060 --> 02:03:20.060]  итератор fuse метод,
[02:03:20.060 --> 02:03:22.060]  с ним будешь познакомиться в домашке
[02:03:22.060 --> 02:03:24.060]  интертулс.
[02:03:24.060 --> 02:03:26.060]  Он просто оборачивает итератор так,
[02:03:26.060 --> 02:03:28.060]  что если он увидел наун, то он после этого
[02:03:28.060 --> 02:03:30.060]  перестает даже обращаться к итератору.
[02:03:30.060 --> 02:03:32.060]  Он просто автоматически наун возвращает.
[02:03:32.060 --> 02:03:34.060]  Это удобно, потому что мы тогда
[02:03:34.060 --> 02:03:36.060]  не продолжаем истощать итератор.
[02:03:38.060 --> 02:03:40.060]  Это не все методы.
[02:03:40.060 --> 02:03:42.060]  На самом деле 71 штука.
[02:03:42.060 --> 02:03:44.060]  Просто у них есть дефолтная имплементация
[02:03:44.060 --> 02:03:46.060]  у итератора.
[02:03:46.060 --> 02:03:48.060]  Кроме next, есть еще
[02:03:48.060 --> 02:03:50.060]  более-менее простой сайд скинутый last.
[02:03:50.060 --> 02:03:52.060]  После этого там мэпы,
[02:03:52.060 --> 02:03:54.060]  flatten, pickable
[02:03:54.060 --> 02:03:56.060]  и так далее.
[02:03:56.060 --> 02:03:58.060]  То есть всякие удобные обертки.
[02:03:58.060 --> 02:04:00.060]  Сейчас обсудим.
[02:04:00.060 --> 02:04:02.060]  Как раз у нас будет.
[02:04:04.060 --> 02:04:06.060]  По сравнению с плюсами
[02:04:06.060 --> 02:04:08.060]  это вообще input итератор.
[02:04:10.060 --> 02:04:12.060]  Мы с плюсами
[02:04:12.060 --> 02:04:14.060]  тоже чуть-чуть поговорим.
[02:04:16.060 --> 02:04:18.060]  Прежде чем мы продолжим,
[02:04:18.060 --> 02:04:20.060]  давайте сначала обозначим
[02:04:20.060 --> 02:04:22.060]  две вещи. Во-первых, в раше все
[02:04:22.060 --> 02:04:24.060]  итераторы ленивые.
[02:04:24.060 --> 02:04:26.060]  Во-вторых, как вы могли заметить,
[02:04:26.060 --> 02:04:28.060]  у нас возвращается не ссылка на item,
[02:04:28.060 --> 02:04:30.060]  не мутабельная ссылка на item,
[02:04:30.060 --> 02:04:32.060]  а сам item, то есть нам передается владение элементом.
[02:04:32.060 --> 02:04:34.060]  Это очень важно для того,
[02:04:34.060 --> 02:04:36.060]  как мы будем имплементировать дальше
[02:04:36.060 --> 02:04:38.060]  какие-то методы итератора.
[02:04:40.060 --> 02:04:42.060]  Давайте поговорим сначала
[02:04:42.060 --> 02:04:44.060]  про методы ссылки на self.
[02:04:44.060 --> 02:04:46.060]  На самом деле этот метод только один.
[02:04:46.060 --> 02:04:48.060]  Это sizeHint.
[02:04:48.060 --> 02:04:50.060]  Он дает lower и upper bound.
[02:04:50.060 --> 02:04:52.060]  То есть дает пару
[02:04:52.060 --> 02:04:54.060]  не меньше скольки элементов
[02:04:54.060 --> 02:04:56.060]  в итераторе и не больше скольки
[02:04:56.060 --> 02:04:58.060]  элементов в итераторе. По умолчанию
[02:04:58.060 --> 02:05:00.060]  возвращает ноль бесконечности.
[02:05:00.060 --> 02:05:02.060]  То есть там дефолтная такая имплементация.
[02:05:02.060 --> 02:05:04.060]  Естественно, как вы понимаете,
[02:05:04.060 --> 02:05:06.060]  вы можете
[02:05:06.060 --> 02:05:08.060]  имплементировать это так, что даже
[02:05:08.060 --> 02:05:10.060]  будет возвращаться для вашего итератора
[02:05:10.060 --> 02:05:12.060]  перегрузить имплементацию.
[02:05:12.060 --> 02:05:14.060]  Сделать так, что
[02:05:14.060 --> 02:05:16.060]  там возвращается какое-то совсем неправильное значение.
[02:05:16.060 --> 02:05:18.060]  Поэтому
[02:05:18.060 --> 02:05:20.060]  если вы пишете unsafe code,
[02:05:20.060 --> 02:05:22.060]  будете когда-то писать unsafe code,
[02:05:22.060 --> 02:05:24.060]  то в общем-то
[02:05:24.060 --> 02:05:26.060]  не используйте это для проверки границ.
[02:05:28.060 --> 02:05:30.060]  Это не то,
[02:05:30.060 --> 02:05:32.060]  к чему вы должны доверять.
[02:05:32.060 --> 02:05:34.060]  Это просто какое-то значение, чтобы
[02:05:34.060 --> 02:05:36.060]  выделить память заранее.
[02:05:36.060 --> 02:05:38.060]  Например, вы хотите сделать
[02:05:38.060 --> 02:05:40.060]  коллект вектор, в таком случае sizeHint
[02:05:40.060 --> 02:05:42.060]  удобно использовать для того, чтобы заранее
[02:05:42.060 --> 02:05:44.060]  выделить нужную память вектор.
[02:05:46.060 --> 02:05:48.060]  А может быть lower bound
[02:05:48.060 --> 02:05:50.060]  можно доверять?
[02:05:50.060 --> 02:05:52.060]  Ну lower нет.
[02:05:52.060 --> 02:05:54.060]  А почему можем?
[02:05:56.060 --> 02:05:58.060]  Ну lower можем дать больше,
[02:05:58.060 --> 02:06:00.060]  чем реальное число элементов в итераторе.
[02:06:00.060 --> 02:06:02.060]  Например, lower bound и upper bound
[02:06:02.060 --> 02:06:04.060]  это 10 и 10, ну там 10 и 11 точно.
[02:06:06.060 --> 02:06:08.060]  И все, там реально
[02:06:08.060 --> 02:06:10.060]  один элемент в итераторе.
[02:06:10.060 --> 02:06:12.060]  Соответственно, мы не можем доверять lower bound.
[02:06:12.060 --> 02:06:14.060]  Ну тут нет
[02:06:14.060 --> 02:06:16.060]  никакого контракта, вы просто
[02:06:16.060 --> 02:06:18.060]  не можете этому доверять на самом деле.
[02:06:18.060 --> 02:06:20.060]  Это просто, ну как есть.
[02:06:20.060 --> 02:06:22.060]  То есть вы можете...
[02:06:22.060 --> 02:06:24.060]  Например, для выделения памяти
[02:06:24.060 --> 02:06:26.060]  заранее векториком.
[02:06:26.060 --> 02:06:28.060]  Если вы коллектите что-то вектор,
[02:06:28.060 --> 02:06:30.060]  например, вы там
[02:06:30.060 --> 02:06:32.060]  в итератором как-то обрабатываете элемент,
[02:06:32.060 --> 02:06:34.060]  кладете вектор. Эффективно до вектора
[02:06:34.060 --> 02:06:36.060]  заранее память нужно выделить.
[02:06:36.060 --> 02:06:38.060]  Берете там под upper bound
[02:06:38.060 --> 02:06:40.060]  какой-нибудь оба, выделяете сколько
[02:06:40.060 --> 02:06:42.060]  выделите.
[02:06:50.060 --> 02:06:52.060]  Ну там есть, если что,
[02:06:52.060 --> 02:06:54.060]  во-первых, мы сейчас
[02:06:54.060 --> 02:06:56.060]  посмотрим еще на exact size
[02:06:56.060 --> 02:06:58.060]  итератор, который знает свой точный размер.
[02:06:58.060 --> 02:07:00.060]  Но это все равно вещь, о которой мы не можем доверять.
[02:07:00.060 --> 02:07:02.060]  А потом есть еще
[02:07:02.060 --> 02:07:04.060]  один trusted land итератор. Это уже
[02:07:04.060 --> 02:07:06.060]  unsafe trade.
[02:07:06.060 --> 02:07:08.060]  И вот этой вот штуке можно доверять.
[02:07:08.060 --> 02:07:10.060]  Если пользователь неправильно
[02:07:10.060 --> 02:07:12.060]  имплементирует ее, то в таком случае
[02:07:12.060 --> 02:07:14.060]  вы можете этому доверять в unsafe
[02:07:14.060 --> 02:07:16.060]  коде, и если пользователь неправильно имплементировал
[02:07:16.060 --> 02:07:18.060]  unsafe trade, то он сам себя обналишил с братьями.
[02:07:18.060 --> 02:07:20.060]  Вы просто забиваете на это.
[02:07:20.060 --> 02:07:22.060]  Потому что это unsafe trade,
[02:07:22.060 --> 02:07:24.060]  у вас контракт. Это все.
[02:07:24.060 --> 02:07:26.060]  Так, давайте
[02:07:26.060 --> 02:07:28.060]  на методы self посмотрим. Это самые
[02:07:28.060 --> 02:07:30.060]  интересные методы, потому что они поглощают
[02:07:30.060 --> 02:07:32.060]  итераторы и превращают их в какой-то
[02:07:32.060 --> 02:07:34.060]  другой объект либо другой итератор.
[02:07:34.060 --> 02:07:36.060]  Last, это самое простое.
[02:07:36.060 --> 02:07:38.060]  Он просто будет вытягивать элементы из
[02:07:38.060 --> 02:07:40.060]  итератора до тех пор, пока не поймет, что
[02:07:40.060 --> 02:07:42.060]  ему вернули наут. Если вернули наут,
[02:07:42.060 --> 02:07:44.060]  возвращаю последний элемент, который
[02:07:44.060 --> 02:07:46.060]  видел и закончил.
[02:07:46.060 --> 02:07:48.060]  Это просто функция, которая в цикле что-то делает.
[02:07:48.060 --> 02:07:50.060]  Обратите внимание,
[02:07:50.060 --> 02:07:52.060]  что это не lazy функция. То есть если вы
[02:07:52.060 --> 02:07:54.060]  вызываете last, то в таком случае, прямо в месте,
[02:07:54.060 --> 02:07:56.060]  где вы вызывали last, у вас полностью
[02:07:56.060 --> 02:07:58.060]  итератор истощится.
[02:08:02.060 --> 02:08:04.060]  Потом есть enumerate.
[02:08:06.060 --> 02:08:08.060]  Enumerate это такая штука,
[02:08:08.060 --> 02:08:10.060]  которая делает из нашего итератора
[02:08:10.060 --> 02:08:12.060]  другой итератор, который
[02:08:12.060 --> 02:08:14.060]  возвращает пары и значения.
[02:08:14.060 --> 02:08:16.060]  И это индекс какой-то.
[02:08:16.060 --> 02:08:18.060]  Он будет 0, 1, 2 и так далее,
[02:08:18.060 --> 02:08:20.060]  ну и значения соответствующие.
[02:08:20.060 --> 02:08:22.060]  То есть мы просто по сути возвращаем пары
[02:08:22.060 --> 02:08:24.060]  номер элемента и
[02:08:24.060 --> 02:08:26.060]  сам элемент. Для этого нам нужно
[02:08:26.060 --> 02:08:28.060]  создать новый итератор,
[02:08:28.060 --> 02:08:30.060]  который будет содержать в себе какой-то счетчик.
[02:08:30.060 --> 02:08:32.060]  Потом pickable.
[02:08:32.060 --> 02:08:34.060]  Pickable это соответственно
[02:08:34.060 --> 02:08:36.060]  там у нас будет буфер из одного элемента.
[02:08:36.060 --> 02:08:38.060]  Когда будем создавать
[02:08:38.060 --> 02:08:40.060]  pickable итератор,
[02:08:40.060 --> 02:08:42.060]  то в таком случае мы будем
[02:08:42.060 --> 02:08:44.060]  брать один элемент из нашего
[02:08:44.060 --> 02:08:46.060]  текущего итератора и класть его в буфер.
[02:08:46.060 --> 02:08:48.060]  Когда
[02:08:48.060 --> 02:08:50.060]  нас будут просить pick и сделать pick,
[02:08:50.060 --> 02:08:52.060]  это если что посмотреть на первый элемент
[02:08:52.060 --> 02:08:54.060]  текущий, но не забрать его.
[02:08:54.060 --> 02:08:56.060]  Нам будет возвращаться ссылка
[02:08:56.060 --> 02:08:58.060]  в описании.
[02:08:58.060 --> 02:09:00.060]  Нам будет возвращаться ссылка
[02:09:00.060 --> 02:09:02.060]  на текущий айтем.
[02:09:02.060 --> 02:09:04.060]  То есть это итератор,
[02:09:04.060 --> 02:09:06.060]  который умеет в пик.
[02:09:08.060 --> 02:09:10.060]  Есть count, который тоже не ленивый,
[02:09:10.060 --> 02:09:12.060]  просто считает число элементов внутри
[02:09:12.060 --> 02:09:14.060]  итератора.
[02:09:14.060 --> 02:09:16.060]  Если мы в пик,
[02:09:16.060 --> 02:09:18.060]  то второй раз вызываем, то он
[02:09:18.060 --> 02:09:20.060]  тот же элемент.
[02:09:22.060 --> 02:09:24.060]  Так.
[02:09:24.060 --> 02:09:26.060]  Вот count не lazy, такая штука.
[02:09:26.060 --> 02:09:28.060]  Очень простая, просто донал,
[02:09:28.060 --> 02:09:30.060]  что читает.
[02:09:30.060 --> 02:09:32.060]  LTE это, собственно, перегрузка
[02:09:32.060 --> 02:09:34.060]  для того, чтобы сравнивать итераторы.
[02:09:36.060 --> 02:09:38.060]  Это, естественно, не ленивая операция,
[02:09:38.060 --> 02:09:40.060]  потому что она будет их сравнивать на меньше
[02:09:40.060 --> 02:09:42.060]  и должна пройтись по всему итератору,
[02:09:42.060 --> 02:09:44.060]  чтобы выяснить, какой из них
[02:09:44.060 --> 02:09:46.060]  меньше какого.
[02:09:48.060 --> 02:09:50.060]  Еще один интересный вариант,
[02:09:50.060 --> 02:09:52.060]  такой фильтр.
[02:09:52.060 --> 02:09:54.060]  Пусть у вас есть
[02:09:54.060 --> 02:09:56.060]  итератор итераторов.
[02:09:56.060 --> 02:09:58.060]  То есть итератор,tonel, который возвращает
[02:09:58.060 --> 02:10:00.060]  в качестве элемента другое итератор.
[02:10:00.060 --> 02:10:02.060]  Вы можете
[02:10:02.060 --> 02:10:04.060]  его превратить в подряд идущие итераторы.
[02:10:04.060 --> 02:10:08.060]  Если у вас был вектор
[02:10:08.060 --> 02:10:10.060]  векторов,
[02:10:10.060 --> 02:10:12.060]  каждому из векторов
[02:10:12.060 --> 02:10:14.060]  написано 1, 2, 3.
[02:10:14.060 --> 02:10:16.060]  Если вы каждый вектор превратите
[02:10:16.060 --> 02:10:18.060]  в итератор, а потом
[02:10:18.060 --> 02:10:20.060] 是的 этаée в profitability,
[02:10:20.060 --> 02:10:22.060]  вы получите итераторы, итераторы.
[02:10:22.060 --> 02:10:34.060]  А, кстати, здесь не фильтр должен быть, а флэтм, флэтм, да, я очень накосячил, это должен быть флэтм, конечно.
[02:10:34.060 --> 02:10:41.060]  Вот. Ну, он будет работать, если что, лениво, флэтм.
[02:10:41.060 --> 02:10:47.060]  Он будет просто доставать элементы из итератора.
[02:10:47.060 --> 02:10:55.060]  Когда он перейдет к тому, что у одного итератора нет элемента, то в таком случае достанет следующий итератор из исходного и будет его истощать.
[02:11:03.060 --> 02:11:11.060]  Да, потому что это будет ссылка на сам, собственно, pickable, потому что у нас такие правила владения.
[02:11:12.060 --> 02:11:19.060]  Так, потом у нас есть еще методы, которые мутируют self.
[02:11:19.060 --> 02:11:21.060]  В-первых, map.
[02:11:21.060 --> 02:11:28.060]  Он возвращает итератор, который маппится ко всем элементам, ну, маппит все элементы из него типа в другой.
[02:11:28.060 --> 02:11:36.060]  Это ленивая операция, то есть вам не нужно полностью обходить весь итератор, класть какие-то элементы в буфер, создавать новый итератор.
[02:11:36.060 --> 02:11:42.060]  Вы просто будете каждый раз, когда он вызывается next, будете применять функцию.
[02:11:42.060 --> 02:11:44.060]  Ну, то есть, собственно, так работает итератор map.
[02:11:44.060 --> 02:11:50.060]  Он создает какой-то новый итератор, который содержит внутри себя функцию, которую вы собираетесь вызвать, и исходный итератор.
[02:11:50.060 --> 02:11:59.060]  И каждый раз, когда вызывается next, применяет к next функцию и возвращает значение.
[02:11:59.060 --> 02:12:02.060]  Ну, или none, да, если мы уже закончили.
[02:12:02.060 --> 02:12:06.060]  Вот есть такая вещь, про которую не все знают.
[02:12:06.060 --> 02:12:07.060]  Это biref.
[02:12:07.060 --> 02:12:12.060]  С ее помощью, кстати, можно очень-очень легким образом решить задачу cycle в домашке.
[02:12:12.060 --> 02:12:21.060]  Ну, там у IterTools есть часть задачи, называется cycle, где нужно сделать ленивый какой-то, lazy cycle.
[02:12:21.060 --> 02:12:26.060]  Где там нужно лениво повторять итератор.
[02:12:26.060 --> 02:12:30.060]  Вот biref там очень сильно помогает сделать короткое, красивое решение.
[02:12:30.060 --> 02:12:34.060]  Она возвращает мьют ссылку на селф.
[02:12:34.060 --> 02:12:45.060]  И в таком случае, когда вы будете нажимать next, то в таком случае у вас не будет исходный итератор как-то съедаться.
[02:12:45.060 --> 02:12:50.060]  Ну, это удобно, например, как сказать.
[02:12:51.060 --> 02:12:52.060]  Как сказать?
[02:12:52.060 --> 02:12:58.060]  Смотрите, вы, например, взяли Iter, да, потом написали точку biref,
[02:12:58.060 --> 02:13:05.060]  потом вы можете написать точку take10 и потом точку collect.
[02:13:05.060 --> 02:13:11.060]  В таком случае вы получите первые 10 элементов итератора в каком-то векторе, допустим.
[02:13:11.060 --> 02:13:14.060]  А исходный итератор не умрет от этого.
[02:13:14.060 --> 02:13:19.060]  А если бы вы сделали take, collect без biref, то в таком случае у вас исходный итератор бы съелся.
[02:13:19.060 --> 02:13:21.060]  Вот такая вот идея.
[02:13:28.060 --> 02:13:30.060]  Да, он так и делает.
[02:13:30.060 --> 02:13:33.060]  Не, просто исходный итератор тоже пройдет вперед.
[02:13:33.060 --> 02:13:36.060]  То есть если ты сделаешь Iter, то этот collect получишь вектор.
[02:13:36.060 --> 02:13:43.060]  То после этого, если ты будешь продолжать использовать Iter, то он будет с десятью уже съеденными элементами.
[02:13:43.060 --> 02:13:48.060]  То есть это вместо того, чтобы писать какой-нибудь for, это просто удобно, чтобы продолжать использовать функции итератора.
[02:13:48.060 --> 02:13:52.060]  Просто помутировать итератор вместо того, чтобы у вас есть.
[02:13:52.060 --> 02:13:54.060]  Вот так вот.
[02:13:54.060 --> 02:13:59.060]  Так, есть n. Возвращает n на элементы итератора.
[02:13:59.060 --> 02:14:04.060]  Ну, просто едает итератор и возвращает n на n.
[02:14:04.060 --> 02:14:10.060]  А, мьюцелл возвращает n на n, соответственно, все элементы до n его съедает.
[02:14:10.060 --> 02:14:17.060]  Вот. Ну и all там проверяет, чтобы какой-то предикат выполняется на всяких элементах.
[02:14:17.060 --> 02:14:20.060]  Соответственно, не ленивая операция.
[02:14:20.060 --> 02:14:22.060]  Так.
[02:14:22.060 --> 02:14:24.060]  Есть еще такой trait.
[02:14:24.060 --> 02:14:28.060]  Ну, давайте с итератором понятно, как он работает, как он устроен,
[02:14:28.060 --> 02:14:32.060]  как примерно выглядят его методы, 71 метод.
[02:14:32.060 --> 02:14:34.060]  Они просто делают разные вещи.
[02:14:34.060 --> 02:14:37.060]  На самом деле, идеи на ничем не отличаются от того, что я показал.
[02:14:37.060 --> 02:14:42.060]  Тоже создается какой-то итератор с какими-то там, возможно, буферами или что-нибудь такое флажками.
[02:14:42.060 --> 02:14:45.060]  И какую-то функцию выполняют.
[02:14:45.060 --> 02:14:49.060]  Понятно это примерно?
[02:14:49.060 --> 02:14:53.060]  Вот. Есть еще trait intoIterator.
[02:14:53.060 --> 02:14:55.060]  Он отвечает на следующий вопрос.
[02:14:55.060 --> 02:15:03.060]  Если у вас коллекция имплементирует intoIterator, то означает, что ее можно превратить в итератор.
[02:15:03.060 --> 02:15:07.060]  Соответственно, если у вас есть итератор, то он автоматически имплементирует intoIterator,
[02:15:07.060 --> 02:15:09.060]  потому что итератор уже является итератором.
[02:15:09.060 --> 02:15:11.060]  Просто возвращаем self.
[02:15:11.060 --> 02:15:13.060]  Так.
[02:15:13.060 --> 02:15:15.060]  Это очень часто обузится в стандартной библиотеке,
[02:15:15.060 --> 02:15:21.060]  поэтому если будете смотреть методы, которые у итератора,
[02:15:21.060 --> 02:15:23.060]  там будет очень часто вместо итератора написано intoIterator,
[02:15:23.060 --> 02:15:26.060]  потому что удобно будет иногда засунуть вектор,
[02:15:26.060 --> 02:15:29.060]  просто сразу вместо того, чтобы писать вектор intoIter.
[02:15:29.060 --> 02:15:33.060]  Вот как раз intoIter это та функция, которая, смотрите, следает нашу коллекцию
[02:15:33.060 --> 02:15:37.060]  и превращает ее в итератор.
[02:15:37.060 --> 02:15:38.060]  Например, вот тут.
[02:15:38.060 --> 02:15:40.060]  Смотрите, у нас вектор 1, 2, 3.
[02:15:40.060 --> 02:15:45.060]  Берем intoIterator и превращаем вектор в итератор.
[02:15:45.060 --> 02:15:48.060]  Обратите внимание, что если я попробую воспользоваться вектором,
[02:15:48.060 --> 02:15:52.060]  это не скомпилируется, потому что я только что именно что сделал в итераторе,
[02:15:52.060 --> 02:15:54.060]  превратил свой вектор в итератор.
[02:15:54.060 --> 02:15:57.060]  Исходного вектора у меня нет больше.
[02:15:57.060 --> 02:16:02.060]  У меня есть итератор, владеющий всеми элементами вектора.
[02:16:02.060 --> 02:16:07.060]  А вот если вы напишете vec.iter, то в таком случае вы не съедите вектор,
[02:16:07.060 --> 02:16:12.060]  вы получите итератор по ссылкам на вектор.
[02:16:12.060 --> 02:16:15.060]  Iter это уже не концепция стандартной библиотеки,
[02:16:15.060 --> 02:16:19.060]  это просто отдельная функция вектора, которая возвращает именно ссылки на элементы,
[02:16:19.060 --> 02:16:22.060]  а не элементы по значению.
[02:16:22.060 --> 02:16:26.060]  Как-то так.
[02:16:26.060 --> 02:16:32.060]  So, intoIterator это, по сути, перегрузка для того, чтобы использовать что-то в форе.
[02:16:32.060 --> 02:16:36.060]  То есть до этого мы перегружали операторы плюс, минус, битовые сдвиги.
[02:16:36.060 --> 02:16:40.060]  А теперь мы можем даже перегрузить в цикл for.
[02:16:40.060 --> 02:16:44.060]  То есть у нас все работает через итератор, и все, что может быть превращено в итератор,
[02:16:44.060 --> 02:16:46.060]  может использоваться в цикле for.
[02:16:46.060 --> 02:16:49.060]  Примерно вот так вот оно обессахаривается.
[02:16:49.060 --> 02:16:54.060]  Был у нас какой-то вектор, и вместо этого мы внутри компилятора сделал какой-то
[02:16:54.060 --> 02:16:56.060]  интератор, а после этого while'ом воспользовался.
[02:16:56.060 --> 02:16:59.060]  Здесь не должно быть этого 3D.
[02:16:59.060 --> 02:17:03.060]  Не должно быть тапчика.
[02:17:03.060 --> 02:17:05.060]  Тут понятно, да?
[02:17:05.060 --> 02:17:13.060]  Да, если ты сделаешь for по вектору, то у тебя его не будет.
[02:17:13.060 --> 02:17:16.060]  В конкретном данном случае у тебя for съедает.
[02:17:16.060 --> 02:17:19.060]  А, смотри.
[02:17:19.060 --> 02:17:21.060]  Там будет примерчик.
[02:17:21.060 --> 02:17:24.060]  Там будет еще ссылка и ссылка на Mute на VEC.
[02:17:24.060 --> 02:17:25.060]  Посмотрим.
[02:17:25.060 --> 02:17:34.060]  Так.
[02:17:34.060 --> 02:17:40.060]  Да, и тут написано то, что это как итератор, в том числе является интер-итератор,
[02:17:40.060 --> 02:17:44.060]  потому что он сам в себя превращается легко, то он может быть использован в форе.
[02:17:44.060 --> 02:17:50.060]  Теперь вопросы, как это работает?
[02:17:50.060 --> 02:17:56.060]  Да, правильно.
[02:17:56.060 --> 02:18:00.060]  Здесь имплементация для ссылки на VEC и ссылки Mute на VEC.
[02:18:00.060 --> 02:18:06.060]  Там возвращается итератор по ссылкам и итератор по амутабельным ссылкам.
[02:18:06.060 --> 02:18:10.060]  Соответственно, это то, как работает итер и итер Mute.
[02:18:10.060 --> 02:18:15.060]  Да, тут у нас именно по ссылке.
[02:18:15.060 --> 02:18:20.060]  Потому что у нас внутри получается так, что мы от ссылки на VEC делаем inte-итератор.
[02:18:20.060 --> 02:18:24.060]  Это не пожирает наш итератор, это пожирает ссылку на VEC.
[02:18:24.060 --> 02:18:26.060]  Просто семантически.
[02:18:26.060 --> 02:18:30.060]  Соответственно, у нас получается итератор, просто обычный по ссылкам.
[02:18:30.060 --> 02:18:34.060]  Потому что у нас так написан код.
[02:18:34.060 --> 02:18:40.060]  Соответственно, когда вы писали range, на самом деле они тоже являются итераторами.
[02:18:40.060 --> 02:18:44.060]  Здесь оно так работает, что у нас есть синтаксис от A до B.
[02:18:44.060 --> 02:18:49.060]  На самом деле это синтактический сахар для range, range from, range to и range from.
[02:18:49.060 --> 02:18:52.060]  Ну, смотрите.
[02:18:52.060 --> 02:18:56.060]  Вот вы можете написать, например, for e, от 0 до 10 выйдет какой-то код.
[02:18:56.060 --> 02:18:59.060]  И там от 0 до 9 у вас будет итерация.
[02:18:59.060 --> 02:19:05.060]  Если вы напишите от 10 до чего-то там, то в таком случае вы тоже будете итерироваться, просто у вас конца нет.
[02:19:05.060 --> 02:19:10.060]  В первом случае у вас создается range, а в втором случае у вас создается range from.
[02:19:10.060 --> 02:19:13.060]  Есть еще range to и range from.
[02:19:13.060 --> 02:19:16.060]  Range to – это когда у вас нет левой границы, есть правая.
[02:19:16.060 --> 02:19:20.060]  Range full – это когда нет ни того, ни другого, просто две точки.
[02:19:20.060 --> 02:19:22.060]  А как без левой границы?
[02:19:22.060 --> 02:19:24.060]  Отход начинается.
[02:19:24.060 --> 02:19:26.060]  Без левой границы как вообще?
[02:19:26.060 --> 02:19:28.060]  Итерироваться не получится без левой границы.
[02:19:28.060 --> 02:19:30.060]  Они не являются итераторами.
[02:19:30.060 --> 02:19:32.060]  А для чего это?
[02:19:32.060 --> 02:19:34.060]  А это нужно, например, в матчах.
[02:19:34.060 --> 02:19:39.060]  Если ты хочешь поматчить числа от минус бесконечности до нуля и от нуля до плюс бесконечности,
[02:19:39.060 --> 02:19:42.060]  то можно сделать это с помощью красот этих рейнджей.
[02:19:42.060 --> 02:19:45.060]  То есть range to и range full – они для матчей используются?
[02:19:45.060 --> 02:19:48.060]  Да, они такие вот синтактические, чистые вещи.
[02:19:48.060 --> 02:19:50.060]  А по range from получается итерировать?
[02:19:50.060 --> 02:19:53.060]  Да, по range и range from уже можно итерироваться.
[02:19:53.060 --> 02:19:55.060]  Это range – это range from, просто синтактический сад.
[02:19:55.060 --> 02:19:57.060]  А range from получается до бесконечности?
[02:19:57.060 --> 02:19:59.060]  Да, до бесконечности.
[02:19:59.060 --> 02:20:02.060]  Цикл, если там внутри нет брейка, никогда не останется.
[02:20:02.060 --> 02:20:06.060]  Просто и будет. У меня 11, 12, 100, 500 и так далее.
[02:20:06.060 --> 02:20:08.060]  А при переполнении, по-моему, это неконечно?
[02:20:08.060 --> 02:20:10.060]  Не при переполнении, а там паника, скорее всего.
[02:20:10.060 --> 02:20:13.060]  Я не проверял, но вы вряд ли дойдете до этого момента.
[02:20:13.060 --> 02:20:15.060]  Давайте по правде.
[02:20:15.060 --> 02:20:18.060]  Не, ну получается, он тогда закончится.
[02:20:18.060 --> 02:20:20.060]  Ну, как сказать?
[02:20:20.060 --> 02:20:22.060]  Я думаю, никогда не в нашей жизни.
[02:20:22.060 --> 02:20:24.060]  Почему не заметишь, что он плакет?
[02:20:24.060 --> 02:20:26.060]  Говори так.
[02:20:31.060 --> 02:20:34.060]  Кстати, в шаде была забавная вещь.
[02:20:34.060 --> 02:20:41.060]  Люди жаловались на то, что вектор паниковал, когда он пытался выделить 2 в 64-1 памяти.
[02:20:41.060 --> 02:20:44.060]  То есть, когда кончался U-size внутри.
[02:20:44.060 --> 02:20:49.060]  Я не совсем понимаю, в чем претензия попробовать выделить столько памяти на компьютер.
[02:20:58.060 --> 02:21:01.060]  Ну, в плане, что U-size переполнился.
[02:21:01.060 --> 02:21:04.060]  Все-таки это как раз еще не переполнение.
[02:21:04.060 --> 02:21:08.060]  Это как раз максимально невозможное значение.
[02:21:08.060 --> 02:21:10.060]  Которое можно...
[02:21:10.060 --> 02:21:15.060]  Ну, для этого иметь в виду, что пуш может запаниковать, когда он пытается запушить.
[02:21:15.060 --> 02:21:18.060]  А там уже пытаешься еще больше, чем это.
[02:21:18.060 --> 02:21:20.060]  Ну да.
[02:21:20.060 --> 02:21:27.060]  Ну, не знаю, конечно, почему люди жаловались.
[02:21:27.060 --> 02:21:32.060]  Ну, смотрите, когда вы замастерите с контакт-итераторы, вы сможете писать примерно такой вот код.
[02:21:32.060 --> 02:21:37.060]  Например, здесь вы сделали итератор по пифогоровым тройкам.
[02:21:37.060 --> 02:21:39.060]  Это же вообще не читает.
[02:21:39.060 --> 02:21:41.060]  А что это за моды?
[02:21:49.060 --> 02:21:50.060]  Так.
[02:21:50.060 --> 02:21:52.060]  Ну, смотрите, у нас triplet.
[02:21:52.060 --> 02:21:56.060]  Вот это вот, как мы уже обсудили, range по U32.
[02:21:56.060 --> 02:21:58.060]  Потом у нас flatmap.
[02:21:58.060 --> 02:22:00.060]  Ну, flatmap что делает?
[02:22:00.060 --> 02:22:02.060]  Он одновременно...
[02:22:02.060 --> 02:22:07.060]  Он ожидает, что у вас внутри будет в качестве возвращаемого значения итератор.
[02:22:07.060 --> 02:22:09.060]  То есть если бы вы сделали просто map,
[02:22:09.060 --> 02:22:14.060]  ну, тогда бы у вас получился после этих вот первых двух строчек просто итератор итераторов.
[02:22:14.060 --> 02:22:18.060]  А flatmap он еще делает flat.
[02:22:18.060 --> 02:22:22.060]  То есть flatmap это по сути map flat.
[02:22:22.060 --> 02:22:24.060]  Вот.
[02:22:24.060 --> 02:22:28.060]  Ну, и по сути после второй строчки у вас получится
[02:22:28.060 --> 02:22:30.060]  массив-парк, где
[02:22:30.060 --> 02:22:33.060]  ну, в общем, бесконечный итератор парк,
[02:22:33.060 --> 02:22:35.060]  где у вас есть какое-то первое число
[02:22:35.060 --> 02:22:37.060]  и второе меньше строго, чем первое.
[02:22:37.060 --> 02:22:40.060]  Ну, там типа будет один, получается,
[02:22:40.060 --> 02:22:42.060]  один-один,
[02:22:42.060 --> 02:22:46.060]  два-один, два-два и так далее.
[02:22:46.060 --> 02:22:50.060]  Сейчас, а почему triplet вообще закончит
[02:22:50.060 --> 02:22:52.060]  исполнение?
[02:22:52.060 --> 02:22:54.060]  Triplet не закончит, это бесконечный итератор какой-то.
[02:22:54.060 --> 02:22:57.060]  Ну, настолько бесконечный, насколько U32 просто валяет, конечно.
[02:22:57.060 --> 02:22:59.060]  Сейчас.
[02:22:59.060 --> 02:23:01.060]  Сейчас это второй, поэтому там один-один,
[02:23:01.060 --> 02:23:03.060]  один-два, два-два.
[02:23:03.060 --> 02:23:05.060]  Ну, не важно.
[02:23:05.060 --> 02:23:07.060]  В общем, как-то примерно так.
[02:23:07.060 --> 02:23:09.060]  Да.
[02:23:09.060 --> 02:23:11.060]  Да, в второй строчке мы добавляем уже третье число,
[02:23:11.060 --> 02:23:15.060]  то есть которое меньше либо равно, чем второе.
[02:23:15.060 --> 02:23:17.060]  Вот.
[02:23:17.060 --> 02:23:19.060]  Вот.
[02:23:19.060 --> 02:23:21.060]  Я, конечно, очень хотел на эту лекцию обсудить и closures,
[02:23:21.060 --> 02:23:23.060]  но кажется, что мы не успеем.
[02:23:23.060 --> 02:23:25.060]  Я поэтому не добавлял.
[02:23:25.060 --> 02:23:27.060]  Я так не понял.
[02:23:27.060 --> 02:23:29.060]  Если этот под копировать полностью,
[02:23:29.060 --> 02:23:31.060]  он не будет исполняться?
[02:23:31.060 --> 02:23:33.060]  В плане.
[02:23:33.060 --> 02:23:35.060]  Ну, здесь вот ты в этой строчке
[02:23:35.060 --> 02:23:37.060]  сделаешь бесконечный итератор
[02:23:37.060 --> 02:23:39.060]  пифагоровых triplet.
[02:23:39.060 --> 02:23:41.060]  А здесь мы уберем из этого бесконечного итератора
[02:23:41.060 --> 02:23:43.060]  пифагоровых triplet первые десять элементов.
[02:23:43.060 --> 02:23:45.060]  То есть он не будет просто все их подсчитывать?
[02:23:45.060 --> 02:23:47.060]  Да, он не будет ничего считать, пока это не ленивая операция.
[02:23:47.060 --> 02:23:49.060]  Да, они все ленивые.
[02:23:49.060 --> 02:23:51.060]  У нас в расе все ленивое,
[02:23:51.060 --> 02:23:53.060]  поэтому это будет лениво все подсчитываться.
[02:23:53.060 --> 02:23:55.060]  Поедем на deadline.
[02:23:59.060 --> 02:24:01.060]  Так.
[02:24:01.060 --> 02:24:03.060]  Ну, соответственно, фильтр, там все подходящие отроки
[02:24:03.060 --> 02:24:05.060]  фильтруем и все работает.
[02:24:07.060 --> 02:24:09.060]  В общем, если вам понравится
[02:24:09.060 --> 02:24:11.060]  функциональное программирование,
[02:24:11.060 --> 02:24:13.060]  раз функциональный язык
[02:24:13.060 --> 02:24:15.060]  без ГЦ приходите.
[02:24:17.060 --> 02:24:19.060]  Да.
[02:24:19.060 --> 02:24:21.060]  Так. Потом мы можем
[02:24:21.060 --> 02:24:23.060]  сконвертировать не только в итератор,
[02:24:23.060 --> 02:24:25.060]  а из итератора тоже.
[02:24:25.060 --> 02:24:27.060]  То есть у нас есть from итератор,
[02:24:27.060 --> 02:24:29.060]  это что-то,
[02:24:29.060 --> 02:24:31.060]  что принимает на вход,
[02:24:31.060 --> 02:24:33.060]  ну, у нас есть функция, которая принимает на вход
[02:24:33.060 --> 02:24:35.060]  T, где T это какой-то интейтератор.
[02:24:39.060 --> 02:24:41.060]  Ну, всякие итераторы, если что,
[02:24:41.060 --> 02:24:43.060]  являются итераторами.
[02:24:43.060 --> 02:24:45.060]  То есть у нас просто еще можно
[02:24:45.060 --> 02:24:47.060]  с помощью вектора, то есть по сути мы можем написать
[02:24:47.060 --> 02:24:49.060]  там не знаю, hash map,
[02:24:49.060 --> 02:24:51.060]  from it,
[02:24:51.060 --> 02:24:53.060]  и там внутри век
[02:24:53.060 --> 02:24:55.060]  из 1, 2, 3.
[02:24:55.060 --> 02:24:57.060]  Ну ладно, не 1, 2, 3, а там парки.
[02:24:57.060 --> 02:24:59.060]  Потому что
[02:25:01.060 --> 02:25:03.060]  он имплементирует интейтератор
[02:25:03.060 --> 02:25:05.060]  вектор, а hash map
[02:25:05.060 --> 02:25:07.060]  имплементирует из итератора пар.
[02:25:07.060 --> 02:25:09.060]  Все, ну, то есть такое вот.
[02:25:09.060 --> 02:25:11.060]  Не, подождите, сейчас будет
[02:25:11.060 --> 02:25:13.060]  такой прикольный синтоксический сахар.
[02:25:13.060 --> 02:25:15.060]  У нас еще 10 минут, кстати.
[02:25:19.060 --> 02:25:21.060]  Вот примерно вот так вот, да.
[02:25:23.060 --> 02:25:25.060]  Ну, это по сути то,
[02:25:25.060 --> 02:25:27.060]  как работает коллект.
[02:25:27.060 --> 02:25:29.060]  То, что мы много раз
[02:25:29.060 --> 02:25:31.060]  им пользовались, не совсем понимали как,
[02:25:31.060 --> 02:25:33.060]  но коллект он ожидает на вход,
[02:25:33.060 --> 02:25:35.060]  ну, вы пишете точечку, он ожидает
[02:25:35.060 --> 02:25:37.060]  то, что вы ему в качестве
[02:25:37.060 --> 02:25:39.060]  коллект ожидает,
[02:25:39.060 --> 02:25:41.060]  то, что вы соберетесь в какую-то
[02:25:41.060 --> 02:25:43.060]  фигню, которая из этого
[02:25:43.060 --> 02:25:45.060]  итератора текущего собирается.
[02:25:49.060 --> 02:25:51.060]  Вот полиморфная такая фигня получается.
[02:25:53.060 --> 02:25:55.060]  А теперь совсем неожиданно.
[02:25:55.060 --> 02:25:57.060]  У нас интейтератор внезапно для result
[02:25:57.060 --> 02:25:59.060]  option и unit
[02:25:59.060 --> 02:26:01.060]  имплементирован.
[02:26:01.060 --> 02:26:03.060]  Как же это работает?
[02:26:05.060 --> 02:26:07.060]  Ну, смотрите.
[02:26:07.060 --> 02:26:09.060]  Давайте use case.
[02:26:09.060 --> 02:26:11.060]  Вот, например, в Rover это используется
[02:26:11.060 --> 02:26:13.060]  для result.
[02:26:13.060 --> 02:26:15.060]  Просто бывает такое, что у вас есть
[02:26:15.060 --> 02:26:17.060]  ну, например,
[02:26:17.060 --> 02:26:19.060]  итератор, который
[02:26:19.060 --> 02:26:21.060]  возвращает там либо
[02:26:21.060 --> 02:26:23.060]  ошибку, ну, то есть итератор
[02:26:23.060 --> 02:26:25.060]  либо ошибка, либо значения, да?
[02:26:27.060 --> 02:26:29.060]  На первой ошибке у нас получается?
[02:26:29.060 --> 02:26:31.060]  Да, на первой ошибке.
[02:26:31.060 --> 02:26:33.060]  Суть в том, что мы хотим как раз
[02:26:33.060 --> 02:26:35.060]  вместо того,
[02:26:35.060 --> 02:26:37.060]  чтобы итерироваться и ручками
[02:26:37.060 --> 02:26:39.060]  проверять была ли ошибка, просто сделать
[02:26:39.060 --> 02:26:41.060]  коллект, и в таком случае у нас либо
[02:26:41.060 --> 02:26:43.060]  вернется вектор каких-то значений,
[02:26:43.060 --> 02:26:45.060]  допустим, вектор, можно и в хашмап,
[02:26:45.060 --> 02:26:47.060]  и все, что хочешь, все, что from
[02:26:47.060 --> 02:26:49.060]  inter работает.
[02:26:49.060 --> 02:26:51.060]  Либо ошибка первая.
[02:26:51.060 --> 02:26:53.060]  То есть это удобно. В Rover это
[02:26:53.060 --> 02:26:55.060]  используется в нескольких местах.
[02:26:55.060 --> 02:26:57.060]  Вот это optional result показывает, кажется,
[02:26:57.060 --> 02:26:59.060]  transposed или что-то подобное.
[02:26:59.060 --> 02:27:01.060]  Вот это, по сути, оно, да?
[02:27:01.060 --> 02:27:03.060]  Не-не, transposed это именно делает
[02:27:03.060 --> 02:27:05.060]  option result либо result option,
[02:27:05.060 --> 02:27:07.060]  представляет местами, а здесь
[02:27:07.060 --> 02:27:09.060]  а здесь как бы итератор этой фигни
[02:27:09.060 --> 02:27:11.060]  вносится внутрь.
[02:27:11.060 --> 02:27:13.060]  Ну, я в этом, типа, пробился внутрь
[02:27:13.060 --> 02:27:15.060]  что-то типа того, похоже
[02:27:15.060 --> 02:27:17.060]  на transposed.
[02:27:17.060 --> 02:27:19.060]  Но давайте разберем
[02:27:19.060 --> 02:27:21.060]  пример, чтобы было понятно. Вот у нас
[02:27:21.060 --> 02:27:23.060]  как имплеметируем from итератор для
[02:27:23.060 --> 02:27:25.060]  result,
[02:27:25.060 --> 02:27:27.060]  как вы можете заметить, v это какая-то
[02:27:27.060 --> 02:27:29.060]  коллекция, в которой мы хотим собраться.
[02:27:29.060 --> 02:27:31.060]  a это элементы
[02:27:31.060 --> 02:27:33.060]  нашего итератора. То есть у нас
[02:27:33.060 --> 02:27:35.060]  итератор item имеет
[02:27:35.060 --> 02:27:37.060]  result ae, то есть
[02:27:37.060 --> 02:27:39.060]  у нас итератор по значениям a
[02:27:39.060 --> 02:27:41.060]  и ошибкам e, а мы хотим превратить
[02:27:41.060 --> 02:27:43.060]  его в result из какого-то собранного
[02:27:43.060 --> 02:27:45.060]  собранной коллекции, допустим,
[02:27:45.060 --> 02:27:47.060]  вектора и ошибки.
[02:27:47.060 --> 02:27:49.060]  Вот.
[02:27:49.060 --> 02:27:51.060]  Примерно такая вот декларация.
[02:27:51.060 --> 02:27:53.060]  И работает оно так. У нас есть какие-то
[02:27:53.060 --> 02:27:55.060]  integers, вот.
[02:27:55.060 --> 02:27:57.060]  И мы хотим их распарщить.
[02:27:57.060 --> 02:27:59.060]  Вот пишем integers
[02:27:59.060 --> 02:28:01.060]  intuiter, то есть превратили вектор в итератор.
[02:28:01.060 --> 02:28:03.060]  Потом делаем
[02:28:03.060 --> 02:28:05.060]  map,
[02:28:05.060 --> 02:28:07.060]  exparse, ну и получили
[02:28:07.060 --> 02:28:09.060]  соответственно какую-то фигню, которую
[02:28:09.060 --> 02:28:11.060]  имитирует итератор, где item
[02:28:11.060 --> 02:28:13.060]  это result из u32
[02:28:13.060 --> 02:28:15.060]  и parsing error.
[02:28:15.060 --> 02:28:17.060]  То есть ошибка
[02:28:17.060 --> 02:28:19.060]  parsing int.
[02:28:19.060 --> 02:28:21.060]  После этого мы коллектим. И вот к чему это
[02:28:21.060 --> 02:28:23.060]  приколлектится. То есть видите вот этот
[02:28:23.060 --> 02:28:25.060]  вот тип.
[02:28:25.060 --> 02:28:27.060]  Итератор вот по этому фигне
[02:28:27.060 --> 02:28:29.060]  превращается вот в это вот.
[02:28:31.060 --> 02:28:33.060]  Это очень красиво, это я, кстати, узнал
[02:28:33.060 --> 02:28:35.060]  тоже на конференции, когда был.
[02:28:35.060 --> 02:28:37.060]  Было прикольно.
[02:28:39.060 --> 02:28:41.060]  Ну вот как видите это заколлектилось
[02:28:41.060 --> 02:28:43.060]  в OK из вектора 0.17.242.
[02:28:47.060 --> 02:28:49.060]  Вот, еще есть
[02:28:49.060 --> 02:28:51.060]  то же самое для option.
[02:28:51.060 --> 02:28:53.060]  Ну работает идеально точно так же. У вас там есть
[02:28:53.060 --> 02:28:55.060]  итератор по option и
[02:28:55.060 --> 02:28:57.060]  собственно какая-то коллекция. То есть
[02:28:57.060 --> 02:28:59.060]  вы хотим в общем коллекцию это собрать.
[02:28:59.060 --> 02:29:01.060]  Ну точно так же
[02:29:01.060 --> 02:29:03.060]  вот, например, вектор из 1, 2,
[02:29:03.060 --> 02:29:05.060]  11, 12, если мы попробуем сделать
[02:29:05.060 --> 02:29:07.060]  в цикле check sub
[02:29:07.060 --> 02:29:09.060]  и заколлектить,
[02:29:09.060 --> 02:29:11.060]  то в таком случае, ну здесь, кстати,
[02:29:11.060 --> 02:29:13.060]  очень важно писать.
[02:29:13.060 --> 02:29:15.060]  Если ты можешь
[02:29:15.060 --> 02:29:17.060]  отнять, то в таком случае ты возвращаешь
[02:29:17.060 --> 02:29:19.060]  сам, что получилось.
[02:29:19.060 --> 02:29:21.060]  А если ты не можешь, ну то есть
[02:29:21.060 --> 02:29:23.060]  там, например, тип у32.
[02:29:23.060 --> 02:29:25.060]  То есть ты не можешь от нуля отнять
[02:29:25.060 --> 02:29:27.060]  еще
[02:29:27.060 --> 02:29:29.060]  единичку. В таком случае наум
[02:29:29.060 --> 02:29:31.060]  возвращается. Вот.
[02:29:31.060 --> 02:29:33.060]  У меня раз был хотя бы один нам,
[02:29:33.060 --> 02:29:35.060]  то веще вектор
[02:29:35.060 --> 02:29:37.060]  пролетелся в трубу. Точнее там
[02:29:37.060 --> 02:29:39.060]  ну в банках.
[02:29:39.060 --> 02:29:41.060]  Ну да.
[02:29:47.060 --> 02:29:49.060]  Если бы check sub вообще вывезал,
[02:29:49.060 --> 02:29:51.060]  что вы не смог, тогда нет.
[02:29:51.060 --> 02:29:53.060]  Так тут же check sub на
[02:29:53.060 --> 02:29:55.060]  элементы. Здесь check sub
[02:29:55.060 --> 02:29:57.060]  на каждый элемент, соответственно,
[02:29:57.060 --> 02:29:59.060]  возвращается саму 32.
[02:29:59.060 --> 02:30:01.060]  Ну да. Ну то есть мы не смогли
[02:30:01.060 --> 02:30:03.060]  отнять такого на уме.
[02:30:03.060 --> 02:30:05.060]  Да, но это ошибка. Да, это все
[02:30:05.060 --> 02:30:07.060]  возвращает ошибку. Первую ошибку возвращает.
[02:30:07.060 --> 02:30:09.060]  То же самое
[02:30:09.060 --> 02:30:11.060]  есть для юнита.
[02:30:11.060 --> 02:30:13.060]  Ой, боже. Если у нас есть
[02:30:13.060 --> 02:30:15.060]  титаратор по юнитам, то мы можем его склопнуть
[02:30:15.060 --> 02:30:17.060]  в юнит. Ну это бывает удобно, например,
[02:30:17.060 --> 02:30:19.060]  когда вам хочется
[02:30:19.060 --> 02:30:21.060]  либо вывести
[02:30:21.060 --> 02:30:23.060]  ошибку, либо просто ничего не сделать.
[02:30:25.060 --> 02:30:27.060]  Ну то есть вывести OK и все.
[02:30:27.060 --> 02:30:29.060]  Вот, например, у нас в WriteLn
[02:30:29.060 --> 02:30:31.060]  возвращает result unit
[02:30:31.060 --> 02:30:33.060]  в данном случае.
[02:30:33.060 --> 02:30:35.060]  Если у нас
[02:30:35.060 --> 02:30:37.060]  успешная запись, тогда просто unit.
[02:30:37.060 --> 02:30:39.060]  Если не успешная, тогда OK unit.
[02:30:39.060 --> 02:30:41.060]  А если не успешная, тогда error.
[02:30:41.060 --> 02:30:43.060]  Ну и там, соответственно, ошибка записи.
[02:30:43.060 --> 02:30:45.060]  STD его result.
[02:30:45.060 --> 02:30:47.060]  Вот.
[02:30:47.060 --> 02:30:49.060]  Ну и когда мы делаем коллект,
[02:30:49.060 --> 02:30:51.060]  то мы, соответственно, итератор по
[02:30:51.060 --> 02:30:53.060]  result unit
[02:30:53.060 --> 02:30:55.060]  превращаем просто в result unit.
[02:30:55.060 --> 02:30:57.060]  Где будет либо первая ошибка,
[02:30:57.060 --> 02:30:59.060]  либо OK unit.
[02:30:59.060 --> 02:31:01.060]  То есть по сути мы дважды применили
[02:31:01.060 --> 02:31:03.060]  промотератор и в один раз зарезалки,
[02:31:03.060 --> 02:31:05.060]  в второй раз для юнит. Да.
[02:31:05.060 --> 02:31:07.060]  Красиво.
[02:31:07.060 --> 02:31:09.060]  Сейчас, то есть тут мы еще раз
[02:31:09.060 --> 02:31:11.060]  записываем, а дальше просто
[02:31:11.060 --> 02:31:13.060]  выводим итоговое значение
[02:31:13.060 --> 02:31:15.060]  либо все хорошо, либо
[02:31:15.060 --> 02:31:17.060]  где-то случилось... Да. Здесь это assert
[02:31:17.060 --> 02:31:19.060]  провалится, если в итоге что-то не получится
[02:31:19.060 --> 02:31:21.060]  записать.
[02:31:21.060 --> 02:31:23.060]  Там будет какая-то ошибка.
[02:31:25.060 --> 02:31:27.060]  Так.
[02:31:27.060 --> 02:31:29.060]  Есть у нас еще exact size итератор.
[02:31:29.060 --> 02:31:31.060]  Ну, так он работает,
[02:31:31.060 --> 02:31:33.060]  что...
[02:31:33.060 --> 02:31:35.060]  В общем, он означает то, что итератор точно
[02:31:35.060 --> 02:31:37.060]  знает свой размер. В таком случае
[02:31:37.060 --> 02:31:39.060]  у вас и size skin
[02:31:39.060 --> 02:31:41.060]  должен возвращать точно
[02:31:41.060 --> 02:31:43.060]  правильный upper lower bound.
[02:31:47.060 --> 02:31:49.060]  К сожалению, так как это пользовательская
[02:31:49.060 --> 02:31:51.060]  имплементация,
[02:31:51.060 --> 02:31:53.060]  мы не можем гарантировать то, что
[02:31:53.060 --> 02:31:55.060]  он правильно этим воспользовался, и, соответственно,
[02:31:55.060 --> 02:31:57.060]  мы не можем
[02:31:57.060 --> 02:31:59.060]  полагаться на это в unsafe code.
[02:31:59.060 --> 02:32:01.060]  Ну, к счастью,
[02:32:01.060 --> 02:32:03.060]  как я говорил, есть такой еще trade
[02:32:03.060 --> 02:32:05.060]  trusted land. Он unsafe trade.
[02:32:05.060 --> 02:32:07.060]  Для того, чтобы имплементировать unsafe trade,
[02:32:07.060 --> 02:32:09.060]  нужно вообще ключевое слово unsafe.
[02:32:09.060 --> 02:32:11.060]  Соответственно, человек сам подписывается на то,
[02:32:11.060 --> 02:32:13.060]  что он правильно имплементировал этот
[02:32:13.060 --> 02:32:15.060]  итератор. Ну, этот trade.
[02:32:17.060 --> 02:32:19.060]  Если вдруг что.
[02:32:19.060 --> 02:32:21.060]  Вот.
[02:32:21.060 --> 02:32:23.060]  Еще есть double-ended
[02:32:23.060 --> 02:32:25.060]  итератор.
[02:32:25.060 --> 02:32:27.060]  Итератор двухсторонний.
[02:32:27.060 --> 02:32:29.060]  Но это итератор, который, ну, он, во-первых,
[02:32:29.060 --> 02:32:31.060]  умеет то же самое, что итератор, во-вторых, он умеет
[02:32:31.060 --> 02:32:33.060]  все что-то сзади делать.
[02:32:33.060 --> 02:32:35.060]  Ну, он умеет сзади там что-то ходить,
[02:32:35.060 --> 02:32:37.060]  fold, find,
[02:32:37.060 --> 02:32:39.060]  такие вот вещи.
[02:32:41.060 --> 02:32:43.060]  Ну, потому что next есть
[02:32:43.060 --> 02:32:45.060]  в итераторе.
[02:32:45.060 --> 02:32:47.060]  Ну, смотри, мы же видишь
[02:32:47.060 --> 02:32:49.060]  супер по отношению к
[02:32:49.060 --> 02:32:51.060]  итератору.
[02:32:57.060 --> 02:32:59.060]  Next это первый.
[02:32:59.060 --> 02:33:01.060]  Смотри, у нас одновременно,
[02:33:01.060 --> 02:33:03.060]  если объект имплементирует double-ended итератор,
[02:33:03.060 --> 02:33:05.060]  то он и итератор имплементирует.
[02:33:05.060 --> 02:33:07.060]  Соответственно, там есть next и next-back.
[02:33:07.060 --> 02:33:09.060]  Next он двигает с этой стороны, next-back с этой.
[02:33:09.060 --> 02:33:11.060]  И более конкретно.
[02:33:11.060 --> 02:33:13.060]  Например,
[02:33:13.060 --> 02:33:15.060]  вектор 1, 2, 3.
[02:33:15.060 --> 02:33:17.060]  Ну, и мы делаем какой-то итератор.
[02:33:17.060 --> 02:33:19.060]  Ну, и смотрите,
[02:33:19.060 --> 02:33:21.060]  у нас next возвращает 1,
[02:33:21.060 --> 02:33:23.060]  next еще раз возвращает 2,
[02:33:23.060 --> 02:33:25.060]  а next-back возвращает 3.
[02:33:25.060 --> 02:33:27.060]  Он пошел с другой стороны.
[02:33:31.060 --> 02:33:33.060]  Второй ассерт закомменит так и что?
[02:33:35.060 --> 02:33:37.060]  Ну, в плане, если вот этот вот
[02:33:37.060 --> 02:33:39.060]  раз комменит, то второй закомменит.
[02:33:39.060 --> 02:33:41.060]  Вообще, да, будет
[02:33:41.060 --> 02:33:43.060]  корректно. Оно точно так же даже
[02:33:43.060 --> 02:33:45.060]  пройдет, там же 1 и 3.
[02:33:45.060 --> 02:33:47.060]  Ну, типа у тебя 2 указателя, по сути, будет.
[02:33:47.060 --> 02:33:49.060]  Ну, вот да, вот просто
[02:33:49.060 --> 02:33:51.060]  название next-back.
[02:33:51.060 --> 02:33:53.060]  Соответственно, вы,
[02:33:53.060 --> 02:33:55.060]  ну, раз уж, как я говорил,
[02:33:55.060 --> 02:33:57.060]  итератор возвращает какие-то владеющие
[02:33:57.060 --> 02:33:59.060]  значения. В данном случае,
[02:33:59.060 --> 02:34:01.060]  конечно, у нас владеющие ссылки, но
[02:34:01.060 --> 02:34:03.060]  об этом итератор не знает, конечно.
[02:34:03.060 --> 02:34:05.060]  Соответственно, мы не можем
[02:34:05.060 --> 02:34:07.060]  дважды вернуть один и тот же элемент,
[02:34:07.060 --> 02:34:09.060]  если у нас закончился
[02:34:09.060 --> 02:34:11.060]  итератор. Вот, если я сделаю
[02:34:11.060 --> 02:34:13.060]  next-back еще раз, то я получу, конечно же,
[02:34:13.060 --> 02:34:15.060]  не тройку, не двойку, а
[02:34:15.060 --> 02:34:17.060]  просто сэршен фейли будет, потому что
[02:34:17.060 --> 02:34:19.060]  на он вернется.
[02:34:19.060 --> 02:34:21.060]  Вот.
[02:34:21.060 --> 02:34:23.060]  Давайте про клярфон с поговорим, кстати, сколько там?
[02:34:23.060 --> 02:34:25.060]  А, ну еще пять слабых.
[02:34:25.060 --> 02:34:27.060]  Как раз спим.
[02:34:27.060 --> 02:34:29.060]  Я надеюсь,
[02:34:29.060 --> 02:34:31.060]  что кто-то из вас делал
[02:34:31.060 --> 02:34:33.060]  домашнюю по
[02:34:33.060 --> 02:34:35.060]  итераторам.
[02:34:35.060 --> 02:34:37.060]  Пятая какая?
[02:34:37.060 --> 02:34:39.060]  Нет, которая четвертая.
[02:34:39.060 --> 02:34:41.060]  Вот. Как мы заметили
[02:34:41.060 --> 02:34:43.060]  на лекции, как увидели
[02:34:43.060 --> 02:34:45.060]  в домашке, ну, тут написано Will C,
[02:34:45.060 --> 02:34:47.060]  для кого как,
[02:34:47.060 --> 02:34:49.060]  достаточно сложно написать тип итератора.
[02:34:49.060 --> 02:34:51.060]  То есть, если вы делали, то у вас наверно
[02:34:51.060 --> 02:34:53.060]  там возникали всякие
[02:34:53.060 --> 02:34:55.060]  fuse, там generic
[02:34:55.060 --> 02:34:57.060]  chain, внутри еще какой-нибудь
[02:34:57.060 --> 02:34:59.060]  там map и так далее.
[02:34:59.060 --> 02:35:01.060]  Потому что итераторы,
[02:35:01.060 --> 02:35:03.060]  для того чтобы вернуть
[02:35:03.060 --> 02:35:05.060]  итератор, для того чтобы какую-нибудь дополнительную
[02:35:05.060 --> 02:35:07.060]  к нему фичу дать, вам нужно
[02:35:07.060 --> 02:35:09.060]  при случае pick
[02:35:09.060 --> 02:35:11.060]  иметь какой-нибудь буфер из одного элемента.
[02:35:11.060 --> 02:35:13.060]  Вот. И, соответственно, у вас
[02:35:13.060 --> 02:35:15.060]  получается какой-нибудь
[02:35:15.060 --> 02:35:17.060]  pickable структурка,
[02:35:17.060 --> 02:35:19.060]  которая, так,
[02:35:19.060 --> 02:35:21.060]  выберете исходный итератор,
[02:35:21.060 --> 02:35:23.060]  кладите pickable и там еще
[02:35:23.060 --> 02:35:25.060]  pickable содержите буфер.
[02:35:25.060 --> 02:35:27.060]  Так.
[02:35:27.060 --> 02:35:29.060]  Примерно такое.
[02:35:31.060 --> 02:35:33.060]  Ну и, соответственно, size of
[02:35:33.060 --> 02:35:35.060]  complex strator и size
[02:35:35.060 --> 02:35:37.060]  of its parts.
[02:35:37.060 --> 02:35:39.060]  Вот. Ну, как я и говорю,
[02:35:39.060 --> 02:35:41.060]  там может быть такой сложный
[02:35:41.060 --> 02:35:43.060]  тип
[02:35:43.060 --> 02:35:45.060]  и, в общем-то, size of это фигне,
[02:35:45.060 --> 02:35:47.060]  это size of частей.
[02:35:47.060 --> 02:35:49.060]  Кстати, я вот сейчас
[02:35:49.060 --> 02:35:51.060]  подумал, я, наверное, вам в этой
[02:35:51.060 --> 02:35:53.060]  строчке мог набрать, потому что у нас все-таки
[02:35:53.060 --> 02:35:55.060]  раз со своей
[02:35:55.060 --> 02:35:57.060]  моделью того, как он
[02:35:57.060 --> 02:35:59.060]  кладет все в памяти, он может в итоге
[02:35:59.060 --> 02:36:01.060]  сделать так, что size of окажется меньше.
[02:36:01.060 --> 02:36:03.060]  Ну, не больше точно, конечно, не меньше может
[02:36:03.060 --> 02:36:05.060]  быть.
[02:36:05.060 --> 02:36:07.060]  Хотя может и больше
[02:36:07.060 --> 02:36:09.060]  оказаться, если там будет.
[02:36:09.060 --> 02:36:11.060]  Да, там может и больше даже
[02:36:11.060 --> 02:36:13.060]  оказаться, если у вас, например, итератор
[02:36:13.060 --> 02:36:15.060]  имеет 8 байт, там какой-нибудь
[02:36:15.060 --> 02:36:17.060]  64 внутри.
[02:36:17.060 --> 02:36:19.060]  То, что вы содержите дополнительно,
[02:36:19.060 --> 02:36:21.060]  это какой-нибудь бул.
[02:36:21.060 --> 02:36:23.060]  Да, и тогда у вас
[02:36:23.060 --> 02:36:25.060]  будет еще
[02:36:25.060 --> 02:36:27.060]  страйт в конце.
[02:36:27.060 --> 02:36:29.060]  Так.
[02:36:29.060 --> 02:36:31.060]  В общем-то, всякие состояния,
[02:36:31.060 --> 02:36:33.060]  просто флаги на стеке.
[02:36:33.060 --> 02:36:35.060]  Там буферы на стеке и так далее.
[02:36:35.060 --> 02:36:37.060]  Потому что итератор просто какая-то небольшая
[02:36:37.060 --> 02:36:39.060]  структурка зачастую.
[02:36:39.060 --> 02:36:41.060]  Ну и вот.
[02:36:41.060 --> 02:36:43.060]  Так как компилятор знает,
[02:36:43.060 --> 02:36:45.060]  кем мы функции вызываем, вы, конечно,
[02:36:45.060 --> 02:36:47.060]  типов не видите, но компилятор
[02:36:47.060 --> 02:36:49.060]  их знает, он знает, кем функции вывозить.
[02:36:49.060 --> 02:36:51.060]  Соответственно, он делает
[02:36:51.060 --> 02:36:53.060]  активные inline вызовы и даже
[02:36:53.060 --> 02:36:55.060]  делает всякие
[02:36:55.060 --> 02:36:57.060]  викторизации. Например, есть
[02:36:57.060 --> 02:36:59.060]  флетом,
[02:36:59.060 --> 02:37:01.060]  который викторизуется.
[02:37:01.060 --> 02:37:03.060]  То есть там викторизуется каждый отдельный
[02:37:03.060 --> 02:37:05.060]  итератор эффективно.
[02:37:05.060 --> 02:37:07.060]  И все это быстро работает.
[02:37:07.060 --> 02:37:09.060]  Что это значит?
[02:37:09.060 --> 02:37:11.060]  Что значит викторизация?
[02:37:11.060 --> 02:37:13.060]  Про симд ты помнишь?
[02:37:13.060 --> 02:37:15.060]  Симд инструкция, помнишь?
[02:37:15.060 --> 02:37:17.060]  Попрос.
[02:37:17.060 --> 02:37:19.060]  Это как класса был?
[02:37:19.060 --> 02:37:21.060]  Так.
[02:37:21.060 --> 02:37:23.060]  В первую очередь вместо как класса должны были
[02:37:23.060 --> 02:37:25.060]  что-то там по умножению на адресы инструкции.
[02:37:25.060 --> 02:37:27.060]  Ну, например,
[02:37:27.060 --> 02:37:29.060]  если ты делаешь какой-нибудь мэп,
[02:37:29.060 --> 02:37:31.060]  а мэп у тебя внутри делает
[02:37:31.060 --> 02:37:33.060]  плюс один.
[02:37:33.060 --> 02:37:35.060]  А потом у тебя, не знаю,
[02:37:35.060 --> 02:37:37.060]  флетом.
[02:37:37.060 --> 02:37:39.060]  Если ты хочешь сделать флетом,
[02:37:39.060 --> 02:37:41.060]  в таком случае тебя может быть эффективно
[02:37:41.060 --> 02:37:43.060]  симд инструкция использовать.
[02:37:43.060 --> 02:37:45.060]  Ну, компилятор где нужно,
[02:37:45.060 --> 02:37:47.060]  их вставит.
[02:37:47.060 --> 02:37:49.060]  Там даже вплоть до того, что
[02:37:49.060 --> 02:37:51.060]  флетом специально так написано, чтобы это максимально быстро работал.
[02:37:55.060 --> 02:37:57.060]  Так.
[02:37:57.060 --> 02:37:59.060]  Знакомая картиночка.
[02:38:03.060 --> 02:38:05.060]  Да, это из плюсов.
[02:38:05.060 --> 02:38:07.060]  Еще как.
[02:38:13.060 --> 02:38:15.060]  Ну, как вы понимаете,
[02:38:15.060 --> 02:38:17.060]  в плюсах сколько там?
[02:38:17.060 --> 02:38:19.060]  Пять типов, шесть типов?
[02:38:21.060 --> 02:38:23.060]  А, замечательно.
[02:38:23.060 --> 02:38:25.060]  Ну, это просто первая ссылочка в интернете,
[02:38:25.060 --> 02:38:27.060]  которая нашлась, когда я делал.
[02:38:29.060 --> 02:38:31.060]  А так, да.
[02:38:31.060 --> 02:38:33.060]  Ну, да.
[02:38:35.060 --> 02:38:37.060]  Да, ну вот
[02:38:37.060 --> 02:38:39.060]  random access умеет там какие-то
[02:38:39.060 --> 02:38:41.060]  случайные значения двигаться.
[02:38:41.060 --> 02:38:43.060]  B-directional в две стороны
[02:38:43.060 --> 02:38:45.060]  там как хочет бегает.
[02:38:45.060 --> 02:38:47.060]  И, в общем, такая вот
[02:38:47.060 --> 02:38:49.060]  сложность появляется.
[02:38:53.060 --> 02:38:55.060]  Да, ну, в общем,
[02:38:55.060 --> 02:38:57.060]  такая вот сложность есть
[02:38:57.060 --> 02:38:59.060]  со всем этим. Дело в том, что это все
[02:38:59.060 --> 02:39:01.060]  кроме input итератора,
[02:39:01.060 --> 02:39:03.060]  по сути, под определение итератора
[02:39:03.060 --> 02:39:05.060]  не особо попадает.
[02:39:05.060 --> 02:39:07.060]  Особенно, какие-нибудь random access
[02:39:07.060 --> 02:39:09.060]  итераторы, потому что
[02:39:09.060 --> 02:39:11.060]  ну, блин.
[02:39:11.060 --> 02:39:13.060]  Ну, это не очень
[02:39:13.060 --> 02:39:15.060]  адекватно, когда вы можете, например,
[02:39:15.060 --> 02:39:17.060]  двигаться на какое-то произвольное значение вперед.
[02:39:19.060 --> 02:39:21.060]  Не, ну, это может проинтерироваться
[02:39:21.060 --> 02:39:23.060]  вперед, но это не очень хорошо,
[02:39:23.060 --> 02:39:25.060]  когда ты используешь итераторы для того,
[02:39:25.060 --> 02:39:27.060]  чтобы индексироваться.
[02:39:27.060 --> 02:39:29.060]  Это итератор должен
[02:39:29.060 --> 02:39:31.060]  интерироваться, не индексироваться.
[02:39:31.060 --> 02:39:33.060]  Поэтому это не очень логично.
[02:39:33.060 --> 02:39:35.060]  Более того, это, наверное, еще не очень удобно,
[02:39:35.060 --> 02:39:37.060]  то, что в плюсах есть одновременно
[02:39:37.060 --> 02:39:39.060]  и begin и end.
[02:39:39.060 --> 02:39:41.060]  То есть во всех языках,
[02:39:41.060 --> 02:39:43.060]  в которых только можно, там в питоне,
[02:39:43.060 --> 02:39:45.060]  в джава есть
[02:39:45.060 --> 02:39:47.060]  какой-то next.
[02:39:47.060 --> 02:39:49.060]  В джаве есть еще has next, я знаю.
[02:39:49.060 --> 02:39:51.060]  В общем-то, итераторы работают так,
[02:39:51.060 --> 02:39:53.060]  что они просто идут куда-то вперед.
[02:39:53.060 --> 02:39:55.060]  А в плюсах это и правда
[02:39:55.060 --> 02:39:57.060]  только для input итераторов,
[02:39:57.060 --> 02:39:59.060]  самого минимального, он же имеет смысл
[02:39:59.060 --> 02:40:01.060]  как итератор.
[02:40:01.060 --> 02:40:03.060]  Вообще
[02:40:03.060 --> 02:40:05.060]  нужно, конечно, чуть-чуть встать на защиту плюсов.
[02:40:05.060 --> 02:40:07.060]  Это все сделано не просто так, это сделано...
[02:40:07.060 --> 02:40:09.060]  Ну, когда делали, я не знаю,
[02:40:09.060 --> 02:40:11.060]  закладывали ли они такой смысл, но сейчас,
[02:40:11.060 --> 02:40:13.060]  по крайней мере, можно с помощью концептов сделать
[02:40:13.060 --> 02:40:15.060]  какие-нибудь специальные,
[02:40:15.060 --> 02:40:17.060]  специфичные для итератора
[02:40:17.060 --> 02:40:19.060]  иллюминизации. Если у вас continuous итератор,
[02:40:19.060 --> 02:40:21.060]  то вы знаете, что у вас все беспрерывно в памяти,
[02:40:21.060 --> 02:40:23.060]  а я все очень быстро.
[02:40:23.060 --> 02:40:25.060]  Еще одна мысль, это то, что
[02:40:25.060 --> 02:40:27.060]  вообще говоря, сравнение,
[02:40:27.060 --> 02:40:29.060]  как бы, вот это разделение работы
[02:40:29.060 --> 02:40:31.060]  с рейнджами на отдельный begin,
[02:40:31.060 --> 02:40:33.060]  отдельный end, в результате можно использовать
[02:40:33.060 --> 02:40:35.060]  для того, чтобы абстрагировать.
[02:40:35.060 --> 02:40:37.060]  А что такое сравнить begin с end?
[02:40:37.060 --> 02:40:39.060]  Вот вся идея рейнджей в том,
[02:40:39.060 --> 02:40:41.060]  что сравнить begin с end, это вообще говоря
[02:40:41.060 --> 02:40:43.060]  достаточно абстрактная
[02:40:43.060 --> 02:40:45.060]  операция, которая может вести только
[02:40:45.060 --> 02:40:47.060]  иллюминизацию,
[02:40:47.060 --> 02:40:49.060]  как бы реализовывать все эти
[02:40:49.060 --> 02:40:51.060]  веселые гнивы операции в терминах,
[02:40:51.060 --> 02:40:53.060]  вот сравнить begin с end
[02:40:53.060 --> 02:40:55.060]  и прикроить итератор.
[02:40:55.060 --> 02:40:57.060]  В плюсах есть
[02:40:57.060 --> 02:40:59.060]  какие-то, возможно, преимущества
[02:40:59.060 --> 02:41:01.060]  такого дизайна,
[02:41:01.060 --> 02:41:03.060]  но как итератор
[02:41:03.060 --> 02:41:05.060]  имеет смысл только input иterator.
[02:41:05.060 --> 02:41:07.060]  Почему мы не хотим
[02:41:07.060 --> 02:41:09.060]  это иметь в расе?
[02:41:09.060 --> 02:41:11.060]  Они такие универсальные, классные,
[02:41:11.060 --> 02:41:13.060]  но на самом деле только input иterator,
[02:41:13.060 --> 02:41:15.060]  как раз говорю, имеет смысл
[02:41:15.060 --> 02:41:17.060]  как итератор.
[02:41:17.060 --> 02:41:19.060]  C++ это небезопасный язык,
[02:41:19.060 --> 02:41:21.060]  поэтому, например, если у вас есть
[02:41:21.060 --> 02:41:23.060]  в расте, вы, как я уже говорил,
[02:41:23.060 --> 02:41:25.060]  итератор всегда забирает владение над объектом,
[02:41:25.060 --> 02:41:27.060]  там item владеющий.
[02:41:27.060 --> 02:41:29.060]  Поэтому если бы то же самое было бы в расте,
[02:41:29.060 --> 02:41:31.060]  то чтобы он мешал, например, в случае bidirectional
[02:41:31.060 --> 02:41:33.060]  итератора, забрать элемент, двинуться вперед,
[02:41:33.060 --> 02:41:35.060]  двинуться назад, забрать элементы и так далее.
[02:41:35.060 --> 02:41:37.060]  Ну и тогда бы
[02:41:37.060 --> 02:41:39.060]  получалось, что какие-то очень-очень
[02:41:39.060 --> 02:41:41.060]  странные проверки получаются, и это вообще
[02:41:41.060 --> 02:41:43.060]  не итератор.
[02:41:43.060 --> 02:41:45.060]  В плюсах мы вынуждены возвращать ссылки.
[02:41:45.060 --> 02:41:47.060]  В принципе, вы можете там
[02:41:47.060 --> 02:41:49.060]  умывать объекты всякие, при случае вектора
[02:41:49.060 --> 02:41:51.060]  взять и по итератору
[02:41:51.060 --> 02:41:53.060]  умывать объект, но это небезопасно.
[02:41:53.060 --> 02:41:55.060]  В какую-то произвольную позицию
[02:41:55.060 --> 02:41:57.060]  оставляете просто дырку,
[02:41:57.060 --> 02:41:59.060]  которая в любой момент может
[02:41:59.060 --> 02:42:01.060]  как-то сломать вам
[02:42:01.060 --> 02:42:03.060]  остальные программы.
[02:42:05.060 --> 02:42:07.060]  В общем, еще есть проблема то,
[02:42:07.060 --> 02:42:09.060]  что в плюсах
[02:42:09.060 --> 02:42:11.060]  итератор предназначался
[02:42:11.060 --> 02:42:13.060]  как какой-то адаптер для того, чтобы
[02:42:13.060 --> 02:42:15.060]  спрятать детали
[02:42:15.060 --> 02:42:17.060]  реализации
[02:42:17.060 --> 02:42:19.060]  за вами.
[02:42:19.060 --> 02:42:21.060]  В плюсах, если используется
[02:42:21.060 --> 02:42:23.060]  continuous итератор, то
[02:42:23.060 --> 02:42:25.060]  как сказать...
[02:42:25.060 --> 02:42:27.060]  В общем, вам
[02:42:27.060 --> 02:42:29.060]  выпячивает то,
[02:42:29.060 --> 02:42:31.060]  что у вас этот объект
[02:42:31.060 --> 02:42:33.060]  обязательно continuous что-то сохраняет.
[02:42:33.060 --> 02:42:35.060]  А если вы захотите
[02:42:35.060 --> 02:42:37.060]  прям беспрерывно памяти,
[02:42:37.060 --> 02:42:39.060]  если вы захотите что-то изменить,
[02:42:39.060 --> 02:42:41.060]  в таком случае в API, то тогда это
[02:42:41.060 --> 02:42:43.060]  будет breaking change, потому что
[02:42:43.060 --> 02:42:45.060]  пользователи могли что-то
[02:42:45.060 --> 02:42:47.060]  на это полагаться.
[02:42:47.060 --> 02:42:49.060]  В случае REST так не получится,
[02:42:49.060 --> 02:42:51.060]  потому что если у вас есть итератор,
[02:42:51.060 --> 02:42:53.060]  то это строго какая-то абстрактная вещь,
[02:42:53.060 --> 02:42:55.060]  которая возвращает какой-то элемент,
[02:42:55.060 --> 02:42:57.060]  вы просто итерируетесь.
[02:42:57.060 --> 02:42:59.060]  Поэтому на самом деле в плюсах,
[02:42:59.060 --> 02:43:01.060]  в том числе, есть проблема с тем, что
[02:43:01.060 --> 02:43:03.060]  вместо того, чтобы прятать
[02:43:03.060 --> 02:43:05.060]  детали реализации, вы их показываете.
[02:43:05.060 --> 02:43:07.060]  Вот, как-то так.
[02:43:11.060 --> 02:43:13.060]  Например, в плюсах
[02:43:13.060 --> 02:43:15.060]  примерно такой код скомпилируется.
[02:43:15.060 --> 02:43:17.060]  У вас есть randomIteratorBegin,
[02:43:17.060 --> 02:43:19.060]  end и вы можете
[02:43:19.060 --> 02:43:21.060]  зафигачить стд-сорт.
[02:43:21.060 --> 02:43:23.060]  А что если бы
[02:43:23.060 --> 02:43:25.060]  randomIterator имплементировал для листа?
[02:43:25.060 --> 02:43:27.060]  Я же могу.
[02:43:27.060 --> 02:43:29.060]  Он будет не эффективным,
[02:43:29.060 --> 02:43:31.060]  и стд-сорт скомпилируется.
[02:43:31.060 --> 02:43:33.060]  Это, конечно, скорее придирка,
[02:43:33.060 --> 02:43:35.060]  вот этот слайд,
[02:43:35.060 --> 02:43:37.060]  как есть.
[02:43:37.060 --> 02:43:39.060]  Такой будет работать.
[02:43:49.060 --> 02:43:51.060]  Там же есть,
[02:43:51.060 --> 02:43:53.060]  мы же поговорили с итератором,
[02:43:53.060 --> 02:43:55.060]  есть bidirection.
[02:43:59.060 --> 02:44:01.060]  Только он не будет прям ходить в две стороны,
[02:44:01.060 --> 02:44:03.060]  в плюсах это какой-то один указатель,
[02:44:03.060 --> 02:44:05.060]  а в Rasty он поток.
[02:44:05.060 --> 02:44:07.060]  Просто мы знаем, что у потока есть конец
[02:44:07.060 --> 02:44:09.060]  и двигаемся в другую сторону.
[02:44:13.060 --> 02:44:15.060]  Еще очень важный момент.
[02:44:15.060 --> 02:44:17.060]  В Rasty, если вы хотите, например,
[02:44:17.060 --> 02:44:19.060]  n-ый элемент взять, как в случае random access
[02:44:19.060 --> 02:44:21.060]  итератор, то вам нужно обязательно
[02:44:21.060 --> 02:44:23.060]  передать
[02:44:23.060 --> 02:44:25.060]  саму коллекцию.
[02:44:25.060 --> 02:44:27.060]  Если вы не знаете коллекцию,
[02:44:27.060 --> 02:44:29.060]  в случае плюсов вы смогли
[02:44:29.060 --> 02:44:31.060]  воспользоваться этим,
[02:44:31.060 --> 02:44:33.060]  как раз кейс слайда.
[02:44:33.060 --> 02:44:35.060]  В плюсах вы могли
[02:44:35.060 --> 02:44:37.060]  воспользоваться тем, что у вас
[02:44:37.060 --> 02:44:39.060]  random access итератор,
[02:44:39.060 --> 02:44:41.060]  а в случае Rasty вы будете точно
[02:44:41.060 --> 02:44:43.060]  видеть, какую структуру вы используете.
[02:44:43.060 --> 02:44:45.060]  Соответственно, вы получаете
[02:44:45.060 --> 02:44:47.060]  те гарантии, которых вы ожидаете
[02:44:47.060 --> 02:44:49.060]  от именно этой структуры.
[02:44:49.060 --> 02:44:51.060]  Вот.
[02:44:55.060 --> 02:44:57.060]  Примерно так.
[02:44:57.060 --> 02:44:59.060]  Если вопрос...
[02:45:05.060 --> 02:45:07.060]  Кажется, что нет.
[02:45:07.060 --> 02:45:09.060]  В таком случае лекция закончилась.
[02:45:09.060 --> 02:45:11.060]  Всем спасибо.
[02:45:11.060 --> 02:45:13.060]  Всем пока.
