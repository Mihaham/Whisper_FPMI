[00:00.000 --> 00:12.560]  Мы с вами прошли бинарное дерево поиска. В его стандартном виде, который нас плюс-минус устраивает,
[00:12.560 --> 00:17.040]  но как бы не очень. Об этом мы поговорим позже. Сегодня мы поговорим о другой структуре данных,
[00:17.040 --> 00:24.560]  которая называется, именно на этой лекции, о другой структуре данных, которая называется пирамида.
[00:24.560 --> 00:39.360]  В англоязычных источниках это всегда хиппи. Но вот русские переводят данную структуру еще
[00:39.360 --> 00:45.720]  иногда как куча, что не является корректным по отношению к данной структуре в принципе. Потому
[00:45.720 --> 00:52.480]  что куча родилась из всяких языков джава и так далее, где сборщик мусора, и вот там вот тоже его
[00:52.480 --> 00:58.840]  назвали хиппи такие. Ну это просто куча, так как там просто мусор как бы он собирает. По факту давайте
[00:58.840 --> 01:07.280]  называть это, ну академически достаточно понятно, это пирамида. Вот поэтому это и будет у нас потом
[01:07.280 --> 01:13.240]  пирамидальная сортировка, которая у вас есть в задании. Что касается самой пирамида. Пирамида
[01:13.240 --> 01:42.720]  это некоторый объект массив, который может рассматриваться
[01:42.720 --> 01:59.160]  как, выключите пожалуйста микрофон, это вы когда что-то кликаете или что-то делаете, то вас слышно.
[01:59.160 --> 02:22.760]  Вот, который может рассматриваться как почти полное, почти полное, бинарное дерево. Вот, то есть все наши
[02:22.760 --> 02:28.280]  страдания с бинарным деревом не напрасны, потому что пирамида очень красиво представляется с точки
[02:28.280 --> 02:35.480]  зрения бинарного дерева. У нее есть главное свойство, как у бинарного дерева поиска было главное
[02:35.480 --> 02:41.160]  свойство, что все что левее у него ключ меньше, а все что правее у него ключ больше, у пирамида есть
[02:41.160 --> 02:51.680]  другое свойство, что каждый родитель больше, чем его дети в любом поддереве, в любом месте. То есть
[02:51.680 --> 03:16.040]  у него следующее свойство, давайте запишем это, свойство пирамиды. Любой узел, для любого узла давайте так, для любого
[03:16.040 --> 03:40.840]  узла. Верно. Что? Родитель, если мы представляем это как массив, ну давайте так, слишком слабое
[03:40.840 --> 04:01.240]  ограничение. Все, сори. А для любого узла верно что? Верно следующее, что у нас значение родителя оно
[04:01.240 --> 04:10.800]  больше либо равно, то есть мы строим пирамиду сейчас по неубуванию, больше либо равно, чем значение
[04:11.160 --> 04:33.120]  левого ребенка и значение родителя больше либо равно, чем значение правого ребенка. Мы потом перепишем
[04:33.120 --> 04:41.120]  немного это свойство после некоторых операций, после того мы вообще как поймем как выглядит это
[04:41.120 --> 04:49.960]  дерево. Надеюсь все записать. Если мы представляем пирамиду, давайте с вами нарисуем какую-нибудь
[04:49.960 --> 04:58.840]  пирамиду и скажем что это вообще такое. Выглядит она примерно следующее, если я буду брать вершины
[04:58.840 --> 05:11.080]  и буду ее строить. К примеру, ну давайте возьмем такую вот пирамиду. 8, тут 7, здесь 1, здесь 2, здесь
[05:11.080 --> 05:24.240]  4, ну а здесь там 9 и 3. Первое, что нужно заметить по этой пирамиде, то что это почти полное бинарное
[05:24.240 --> 05:32.480]  дерево. Если это почти полное бинарное дерево, то нам нужно в этом случае понимать, что все слои у
[05:32.480 --> 05:40.240]  этого дерева заполнены полностью, кроме быть может последнего, то есть если у нас нету где-то
[05:40.240 --> 05:46.400]  вершин в этом бинарном дереве для того чтобы она была полная, нету только некоторых листов,
[05:46.400 --> 05:52.880]  причем именно слева направо. Это связано с тем, что мы будем строить наше бинарное дерево,
[05:52.880 --> 05:59.720]  ой нашу пирамиду по факту, из массива и будем использовать по факту массив, но представлять
[05:59.720 --> 06:08.240]  его в виде вот такой вот структуру данных как бинарное дерево. Если мы хотим записать массиве,
[06:08.240 --> 06:16.720]  мы будем говорить о том, что у нас индексация. Индексация здесь будет с единички. Мы будем
[06:16.720 --> 06:25.800]  рассматривать, что первый самый главный элемент у него индекс будет равен единице. У его детей тогда
[06:25.800 --> 06:34.280]  будет индексы в два раза больше, это будет 2i и 2i плюс 1. Мы сейчас это с вами и запишем. То есть
[06:34.280 --> 06:40.960]  что мы хотим с вами сделать, чтобы мы могли представить данную структуру в виде массива,
[06:40.960 --> 06:50.440]  и могли очень легко обращаться ко всем детям и родителям в этой структуре, чтобы это было
[06:50.440 --> 06:58.720]  удобно для нас. Так как у нас массив работает, ну индексация от единички, то в этом случае мы
[06:58.720 --> 07:05.440]  как раз-таки можем очень быстро находить всех родителей и всех детей относительно какой-то вершины,
[07:05.440 --> 07:15.720]  а не работая с указателями, как это было в бинарном дереве поиска. Мы хотим сделать следующее,
[07:15.720 --> 07:27.200]  чтобы у нас родитель, давайте напишем это прям как функции такие некоторые. Что ж такое? У нас
[07:27.200 --> 07:41.520]  родитель, то есть от некоторого индекса мы хотим найти индекс родителя. У нас будет функция левого
[07:41.520 --> 07:58.440]  ребенка от и и некоторая функция правого ребенка. Вообще как пирамида представляется в нашем массиве?
[07:58.440 --> 08:05.480]  Она представляется следующим видом, на примере это будет гораздо легче показать. Первоначально
[08:05.480 --> 08:13.800]  записывается само число, которое стоит сверху. Дальше мы идем по факту слева направо. То есть мы
[08:13.800 --> 08:20.080]  делаем обход следующим образом. Мы по каждому слою идем слева направо, для того чтобы хранить его
[08:20.080 --> 08:29.160]  в массиве. Тогда в этом случае мы получим с вами вот такую конструкцию в нашем массиве. 8, 7, 9,
[08:29.160 --> 08:42.400]  3, 2, 4 и 1. Здесь необходимо понять как обращаться по индексам. Если я первоначально говорил,
[08:42.400 --> 08:56.440]  что мы будем индексировать здесь начиная с единички. Поэтому здесь у нас будет первый индекс,
[08:56.440 --> 09:17.880]  2, 3, 4, 5, 6, 7, 8, 9, 10. Смотрите, кто является сыновьями для нашего числа 16? Даша Решетникова,
[09:17.880 --> 09:27.200]  скажи пожалуйста, как ты считаешь? Сыновьями 14 и 10. 14 и 10. И у них индексы какие в нашем массиве?
[09:27.200 --> 09:37.480]  2 и 3. 2 и 3. По факту здесь если соединить, то это будет выглядеть вот таким вот образом. Если
[09:37.480 --> 09:51.880]  мы с вами соединим индексы для 14, то у нас будет еще 8 и 7. Для 10 у нас будет 10 и 3. Кто видит
[09:51.880 --> 10:05.280]  взаимосвязь индексов и наших отношений с точки зрения детей? Вы уже говорили,
[10:05.280 --> 10:14.840]  что если индекс родителей и, то индексы детей 2 и и 2 и плюс 1. Да, действительно, это именно так.
[10:14.840 --> 10:24.000]  То есть смотрите, правый ребенок у нас будет равен, 10 это является правым ребенком, и это у нас
[10:24.000 --> 10:37.760]  будет функция по факту возвращать 2 умножить на и плюс 1. Левый ребенок это у нас будет возвращать
[10:37.760 --> 10:51.040]  2 умножить на и. А что будет являться родителем для нашего какого-то ребенка? То есть смотрите,
[10:51.120 --> 10:58.480]  для 10 мы, к примеру, хотим построить отношения. Кто является родителем для этой десятки?
[10:58.480 --> 11:08.160]  И пополам. Да, то есть здесь достаточно взять обычное целочисленное деление.
[11:08.160 --> 11:18.840]  В этом вся суть отношения здесь. Мы можем сказать, что у нас есть массив, и по нему мы
[11:18.840 --> 11:27.400]  можем построить наше дерево, которое нам необходимо. И благодаря этому у нас как раз таки все с вами и
[11:27.400 --> 11:33.240]  получится. Если вы будете индексировать ваше дерево, то есть иногда его индексируют с нуля,
[11:33.240 --> 11:40.240]  тогда в этом случае отношения родитель-ребенок и родитель-правый ребенок-левый ребенок немного
[11:40.240 --> 11:47.000]  другие. Там я напишу сейчас только в этом случае. Дальше типа как перестроить все остальные конструкции,
[11:47.000 --> 11:54.080]  думаю вы догадаетесь. В этом случае у вас будет что родитель это и-1 пополам, а левый ребенок это
[11:54.080 --> 12:11.200]  2 на и плюс 1, а правый ребенок будет 2 на и плюс 2. Вот, если индексация у нас с нуля. Вот, если у нас
[12:11.200 --> 12:16.320]  индексация с единички, то так. То есть нашим корнем дерева является вот этот вот максимальный
[12:16.320 --> 12:26.000]  элемент. Смотрите, самое классное, что у нас дает эта пирамида, что у нас наверху находится максимальный
[12:26.000 --> 12:32.640]  элемент от всех, потому что он больше своих детей, а его дети больше, чем их дети и так далее. То есть
[12:32.640 --> 12:38.280]  с точки зрения вот такой вот рекурсивного рассмотрения у нас 16 больше, чем 14 и больше,
[12:38.280 --> 12:47.440]  чем 10. 14 больше, чем 8 и больше, чем 7. Ну и так далее. То есть здесь мы понимаем, что на вершине этой
[12:47.440 --> 12:52.440]  пирамиды стоит самый-самый большой элемент. Естественно эту пирамиду можно перестроить по
[12:52.440 --> 13:02.320]  минимуму, здесь просто необходимо вести будет другое отношение этих элементов. Вот. Смотрите,
[13:02.320 --> 13:08.600]  чему будет равна высота в данной пирамиде. Так как мы заполняем по факту здесь все слои,
[13:08.600 --> 13:21.760]  кроме быть может последнего, то у нас высота, высота, высота h нашего, нашей пирамиды,
[13:21.760 --> 13:32.400]  она равна тетти от логарифмы. Потому что мы заполняем абсолютно все слои, которые у нас есть,
[13:32.400 --> 13:38.800]  кроме быть может последнего. То есть мы максимально берем степени двойки. Вот. Поэтому мы всегда
[13:38.800 --> 13:44.760]  увеличиваем два раза и так далее и получаем, что у нас будет высота пирамиды, это логарифм. Это
[13:44.760 --> 13:54.520]  свойство нам очень-очень понадобится. Теперь давайте с вами кое-что разберем следующее. Такой
[13:54.520 --> 14:02.520]  подзаголовок. Давайте так, есть ли вопросы к пирамиде, как она выглядит в принципе, на всякий случай?
[14:02.520 --> 14:17.720]  Видимо нет. Окей, тогда... Секунду вернуть к определению пирамиды. Да. Спасибо. Вот, подзаголовок
[14:17.720 --> 14:22.800]  следующий. У меня высота получилась еще раз. Что еще раз? Почему именно так высоту записали?
[14:22.800 --> 14:34.440]  Неявная формула. Почему? Что подразумевается подъявной формулой? Ну можно взять ограничение,
[14:34.440 --> 14:37.920]  просто сверху дал логарифм, сверху ограничил, там плюс один сделал.
[14:37.920 --> 14:45.920]  Ну так же у нас низы сверху ограничивают. Если мы просто округлим вверх, то этого будет
[14:45.920 --> 14:54.960]  достаточно и все. Вот она будет высота пирамиды. У нас самое большое количество элементов будет,
[14:54.960 --> 15:00.560]  если будет полная пирамида, то есть полное бинарное дерево. Это по факту сколько? Это степень
[15:00.560 --> 15:09.520]  двойки минус один, правильно? Верно. Тогда мы должны округлить вверх и плюс единичку добавить,
[15:09.520 --> 15:33.280]  у нас будет высота. Вот. Окей. Поддержка, свойства, пирамиды. Смотрите.
[15:33.280 --> 15:39.360]  Когда еще раз мы добавили единицу, вы сказали, что когда мы считаем высоту,
[15:39.360 --> 15:44.880]  то нужно добавить еще единицу. Посчитайте количество элементов,
[15:44.880 --> 15:52.480]  сколько у нас в двоичном дереве и сколько у нас будет высота. Просто количество элементов,
[15:52.480 --> 15:55.360]  степень двойки возьмите, типа по максимуму забейте пирамиду.
[15:55.360 --> 15:59.160]  Это я поняла. А когда мы именно единицу добавляем?
[15:59.160 --> 16:10.600]  Еще раз. Попробуйте, посчитайте. Вы поймете. Это вопрос такой. Там сейчас важная симпатическая
[16:10.600 --> 16:17.560]  сторона, но по факту там будет всегда. Вот. Одержка, свойств нашей пирамиды.
[16:17.560 --> 16:25.080]  Что касается поддержания, свойств пирамиды. Давайте перепишем наше свойство немного
[16:25.080 --> 16:40.160]  следующим образом. Для любого узла с индексом И, мы говорим следующее.
[16:40.160 --> 16:50.520]  Для любого узла с индексом И, мы говорим следующее. Что А от И, А это массив наш,
[16:50.520 --> 17:07.680]  будет меньше либо равен, чем А от Parent и Parent от Ника. Вот. То есть немножко переформулировали
[17:07.680 --> 17:13.520]  наше свойство. Чтобы у нас не было два неравенства, мы сделали одно. Вот. Оно достаточно
[17:13.520 --> 17:22.240]  понятное. Откуда оно выходит тоже понятно. Вот. Это то свойство, которое нам необходимо
[17:22.240 --> 17:33.920]  поддерживать. Представьте следующее. У нас в пирамиде могут меняться элементы. Каким-то
[17:33.920 --> 17:41.840]  образом. Пусть у меня будет следующее. Вот у меня была та пирамида, но она немножко другого вида
[17:41.840 --> 17:54.120]  сейчас будет. 16 там. И, к примеру, на место 14 будет здесь 4, здесь будет 10, здесь будет 7, 14,
[17:54.120 --> 18:12.920]  2, 8, 1, здесь 9, там и 3. Вот. А для поддержания свойств пирамиды эта четверка должна пойти куда?
[18:12.920 --> 18:23.880]  Ниже или выше? Как вы считаете? Ниже. Ниже. Ниже. Потому что ее действие меньше. Но для того,
[18:23.880 --> 18:30.200]  чтобы эта пирамида сохраняла свое свойство, должен на ее место встать какой из детей? Левый
[18:30.200 --> 18:36.360]  или правый? Ну можно и левый. Самый большой. Ну типа если мы поставим левый элемент, то мы
[18:36.360 --> 18:41.720]  должны будем второй раз это же свойство применить. Ну а если правый элемент ставим, то один раз
[18:41.720 --> 18:48.440]  если мы поменяем, то есть 4,7, то пирамида уже... А нет, наоборот, левый должен встать в место
[18:48.440 --> 18:53.960]  самый большой элемент. Да. То есть смотрите, должен встанавливаться на это место самый большой
[18:53.960 --> 18:59.000]  элемент. Если мы будем вставить любой из элементов, то возможно нам необходимо повторять
[18:59.000 --> 19:05.040]  операцию, а по факту мы просто поменяем и поставим опять самый большой. Поэтому в этом плане нам
[19:05.040 --> 19:13.240]  необходимо сделать следующее. Нам необходимо, это называется просеиванием вниз, нам необходимо
[19:13.240 --> 19:22.760]  просеять вниз элемент 4, который у нас с вами не на своем месте. Здесь мы получим вот так, вот так.
[19:22.760 --> 19:30.520]  Так как 4 просеялось вниз и поменялось местами с 14, то 4 окажется вот здесь. Здесь окажется 7,
[19:30.520 --> 19:39.280]  то есть оно останется на своем месте. 1, здесь 8, здесь 2. То есть мы должны выбрать максимум из
[19:39.280 --> 19:46.600]  правого и левого по дереву от четверки, ну корней. Мы должны выбрать максимум из правого и левого
[19:46.600 --> 19:54.800]  ребенка, да. Вот. И с ним поменять местами. Потому что в таком случае мы сохраним наше свойство для
[19:54.800 --> 20:02.760]  всего нашего дерева, для всей нашей пирамиды. Так как у нас будет самый большой элемент наверху,
[20:02.760 --> 20:11.760]  то он будет явно больше и другого сына тоже, помимо самого родителя, который был родителем. Сейчас
[20:11.760 --> 20:17.920]  мы с вами это поменяли. И теперь нам необходимо взять и еще раз просеять этот элемент. То есть,
[20:17.920 --> 20:24.240]  смотрите, я в начале просею вот эту четверку, потом у меня четверка оказалась здесь. Мне необходимо
[20:24.240 --> 20:29.880]  проверить, а может ли она спуститься еще ниже, потому что мало ли, свойство наше не выполняется.
[20:29.880 --> 20:36.280]  Тогда в этом случае, ну мы видим, что оно не выполняется, потому что 4 меньше 8. Нам необходимо
[20:36.280 --> 20:49.520]  взять и просеять элемент еще ниже. И получить следующую пирамиду. 16, 14, 10. Здесь 4 поменяется
[20:49.520 --> 21:01.800]  местами с восьмеркой. Здесь будет 2, здесь будет 4, здесь 7 и 1, здесь 9 и 3. Вот. То есть,
[21:01.800 --> 21:08.560]  вот после таких итераций, как только 4 у меня дошло до низа, мы можем остановиться. Либо мы можем
[21:08.560 --> 21:17.560]  остановиться, если у нас все сыновья меньше, чем это само, само, сам этот элемент в нашем дереве,
[21:17.560 --> 21:27.560]  нашей этой пирамиде. Поэтому важно здесь научиться как раз-таки просеивать вниз. И вот то,
[21:27.560 --> 21:36.160]  что мы сейчас сделали, это и называется просеиванием вниз. Вот. Давайте с вами запишем код этого
[21:36.160 --> 21:42.880]  просеивания. Есть ли вопрос, как оно вообще в принципе выглядит? И почему мы его должны делать?
[21:42.880 --> 21:51.880]  Есть вопрос, когда мы его делаем? Когда вводим число новое или когда? Там функция change есть,
[21:51.880 --> 21:59.640]  типа поменять значение. Смотрите, мы с вами его делаем в случае либо изменения элемента,
[21:59.640 --> 22:08.320]  либо по факту изменения элемента. Да. Потому что добавление мы будем делать немного по-другому.
[22:08.320 --> 22:17.360]  Понятно? Вот. Мы именно просеиваем вниз. В случае, если у нас как-то изменилось наше число в нашей
[22:17.360 --> 22:23.520]  пирамиде, нам необходимо его просеять вниз. У нас нарушилось правило, нарушилось свойство
[22:23.520 --> 22:29.600]  самой пирамиды. Поэтому нам необходимо взять его и поменять места. Вот. Ну грубо говоря,
[22:29.600 --> 22:34.280]  типа для того, чтобы представить, что такое просеивание вниз, представьте следующее. Вот был
[22:34.280 --> 22:40.040]  какой-нибудь очень богатый человек, вот там Илон Маск был. Вот. Он написал что-то в Твиттере,
[22:40.040 --> 22:47.440]  можно ли я продам 10% своих акций? Акции рухнули. И вот все, вот как бы денег у него стало меньше.
[22:47.440 --> 22:53.360]  И с точки зрения рейтинга там Forbes, например, он должен был бы просеяться вниз, но у него все
[22:53.360 --> 22:59.320]  еще много денег. Вот как бы оно иногда надо, но иногда и не надо. Нам необходимо будет проверить,
[22:59.320 --> 23:04.280]  сохранено ли свойство. Если не сохранено, то мы должны просеять вниз. То есть рейтинг немножко
[23:04.280 --> 23:10.920]  там упадет, к примеру, с точки зрения количества его денег, которое там оценивается миллиардами.
[23:10.920 --> 23:19.840]  Вот. А если там кто-то банкротился, ну или что-нибудь такое, то есть здесь с точки зрения того,
[23:19.840 --> 23:26.800]  что у нас видо изменилось что-то в самой пирамиде. Если оно уменьшилось, именно уменьшилось,
[23:26.800 --> 23:35.240]  то нам необходимо будет просеивать вниз. Вот. Давайте с вами напишем этот код. Просеивание вниз,
[23:35.240 --> 23:50.080]  функция называется shift, shift down, то есть просеять вниз. Мы сюда с вами передаем наш массив A,
[23:50.080 --> 23:56.200]  в котором построена наша пирамида и в котором есть все наши элементы. Индекс того самого
[23:56.200 --> 24:02.880]  видоизмененного элемента, который мог уменьшиться, к примеру. И быть может,
[24:02.880 --> 24:07.000]  ну точнее не быть может, если вы будете реализовывать, нам необходим еще вообще
[24:07.000 --> 24:20.520]  размер массива сам по себе. Вот. То есть, ну я думаю, вы поняли, где что. Окей. А как мы это делаем?
[24:20.520 --> 24:26.440]  Мы говорим, что у этого элемента есть левый ребенок и правый ребенок. Давайте его посчитаем.
[24:26.440 --> 24:36.920]  Левый равен, ну мы будем, я буду здесь использовать функцию в зависимости от того,
[24:36.920 --> 24:54.520]  как вы будете реализовывать. Лев чайл там от и. Правый ребенок у нас равен правый ребенок.
[24:56.520 --> 25:02.160]  Правый ребенок действительно, левый это 2 и, правый это 2 и плюс 1. Действительность и так.
[25:02.160 --> 25:09.440]  Правый ребенок тоже у нас задан. Теперь нам необходимо сказать, пусть у нас самый
[25:09.440 --> 25:14.600]  большой элемент первоначально равен и. Нам необходимо найти элементы равные.
[25:14.600 --> 25:31.400]  Дальше я сравниваю, если у нас левая граница меньше либо равна, чем size, это очень важно,
[25:31.400 --> 25:48.360]  и а от левт больше, чем а от и, то есть больше, чем наш элемент, то в этом случае я говорю,
[25:48.360 --> 25:57.520]  что наибольший элемент, точнее наибольший индекс, где хранится, индекс, где хранится
[25:57.520 --> 26:05.080]  наибольший элемент, а равен левому ребенку. Важный вопрос, скажите мне,
[26:05.080 --> 26:10.400]  если я поменяю эти два условия местами, будет ли работать корректно моя программа?
[26:10.400 --> 26:13.360]  Нет. Сергей Александрович, а можно вопрос,
[26:13.360 --> 26:19.760]  может быть не от и, а от largest? Ой, да, ну здесь без разницы, конечно,
[26:19.760 --> 26:26.880]  но да, чтобы у нас был одинаковый формат. Возможно выход за пределы массива.
[26:26.880 --> 26:31.960]  Да, а благодаря чему вот здесь не будет выхода, как мы и написали?
[26:31.960 --> 26:35.680]  Потому что вначале проявляется левт меньше либо равна.
[26:35.680 --> 26:36.560]  Короткая логика.
[26:36.560 --> 26:41.000]  Короткая логика, благодаря короткой логике вот здесь вот мы можем так писать,
[26:41.000 --> 26:45.600]  иначе нам нужно было бы делать вложенные ифы. Это важно понимать.
[26:45.600 --> 26:52.080]  Вот, окей, да, действительно здесь largest лучше писать, наибольший элемент.
[26:52.080 --> 26:56.360]  Дальше нам необходимо еще проверить с правым элементом, что если у нас правый,
[26:56.360 --> 27:08.960]  меньше либо равен, чем size, а от правого элемента больше.
[27:08.960 --> 27:13.600]  Еще меньше равно, потому что нумерация соединится, да?
[27:13.600 --> 27:17.560]  Да, если бы у нас была нумерация с нуля, то было бы просто меньше.
[27:17.560 --> 27:19.880]  Спасибо.
[27:19.880 --> 27:27.360]  Вот, и здесь больше, чем наш наибольший элемент. Мы не знаем какой там индекс,
[27:27.360 --> 27:32.880]  может быть и, может быть, и left. Ну, то есть это поиск просто индекса максимального элемента,
[27:32.880 --> 27:41.800]  максимальный индекс. Вот, то в этом случае мы говорим, что наибольший равен правому.
[27:41.800 --> 27:48.840]  После этого мы по факту с вами определили, где находится наибольший элемент. Это либо
[27:48.880 --> 27:57.880]  наш родитель, либо один из детей. Если это у нас с вами не является родителем, то есть,
[27:57.880 --> 28:05.600]  точнее давайте так, если это родитель, то мы должны остановить наше просеивание вниз.
[28:05.600 --> 28:09.880]  Ну, то есть если у нас наибольший элемент является родителем, мы свойства пирамиды
[28:09.880 --> 28:16.600]  удовлетворили, мы его сделали. Все круто классно, поэтому давайте с вами скажем следующее,
[28:16.600 --> 28:24.440]  что да, действительно у нас наибольший элемент, тогда если и, то мы останавливаемся. А вот,
[28:24.440 --> 28:36.840]  если он не равен и, то в этом случае мы должны поменять местами наше аи т и а наибольшее,
[28:36.960 --> 28:50.000]  после чего мы должны еще раз просеять наш элемент вниз, то есть написать своп, ой своп,
[28:50.000 --> 29:05.720]  сивдалм, извините, сивдалм, вот а. Теперь смотрите, так как мы поменяли местами аи т и а л, то есть
[29:05.720 --> 29:11.440]  наибольший элемент, то теперь у нас вот этот вот и-то элемент, который был, он теперь находится
[29:11.440 --> 29:24.760]  в массиве под индексом наибольшего, поэтому мы должны сивдалм, даун, а, наибольший и все так же сайз.
[29:24.760 --> 29:36.000]  Вопрос, а мы разве не должны писать, что левт и райт строго меньше сайза?
[29:36.000 --> 29:44.840]  Еще раз, если у нас индексация с единицы, мы же индексацию с единицы с вами сначала приняли,
[29:44.840 --> 29:52.880]  то в этом случае у нас именно меньше либо равно, если у нас индексация с нуля, вы приняли так,
[29:52.880 --> 30:00.080]  что там будет меньше. Именно поэтому я пишу левт чайлд и райт чайлд, потому что все зависит от
[30:00.080 --> 30:09.360]  реализации, то как вы хотите. В данном случае я подразумеваю следующее, что это 2 умножить на и и
[30:09.360 --> 30:21.440]  2 умножить на и плюс 1. Вот, вы можете реализовать и так, и так, здесь уже ваше право, как вам удобно.
[30:21.440 --> 30:30.240]  Это понятно? Если вопросы к просеиванию... Можете, пожалуйста, еще раз повторить с момента,
[30:31.240 --> 30:42.400]  еще раз, нам необходимо просеять наши элементы, просеять наш элемент, вот эту четверку. Эту четверку
[30:42.400 --> 30:52.720]  мы должны поставить на место 14, а 14 на место четверки. Тогда мы должны взять и поменять их
[30:52.720 --> 31:01.400]  местами. Я их меняю местами. Да, спасибо. После чего я должен еще раз просеять свою четверку.
[31:01.400 --> 31:09.240]  Да, спасибо, поняла. А что значит в зависимости от того, как мы реализуем, если массивы с нуля
[31:09.240 --> 31:18.640]  нумеруются? Вы можете просто не трогать нулевой элемент. Спасибо, понимаю. Просто выделить там
[31:18.640 --> 31:27.120]  n плюс 1 память, например. В этом нет никакой проблемы. А вот еще такой вопрос. Разве перед вторым
[31:27.120 --> 31:34.240]  ифом не нужно else описать? Зачем? У нас первый иф может выполниться, а потом... А потом второй
[31:34.240 --> 31:44.520]  выполнится, да. Но представьте следующее, что у меня вот здесь вот был бы не 14, а 7,14. Я пришел в
[31:44.520 --> 31:51.960]  левого ребенка. Хорошо, спасибо. А мне нужно все наибольшее. Мне нужно найти наибольшее среди трех
[31:51.960 --> 32:01.040]  чисел. Поэтому здесь так. Еще вопросы? Если мы будем реализовывать ifLargest равно равно и. Нельзя
[32:01.040 --> 32:12.920]  взять просто ifLargest равно равно и, тогда return, ну, потом swap it, aLargest, shift down, aLargest size.
[32:12.920 --> 32:24.320]  В том принципиальная разница. Ну, вы добавили один return. С return не будет работать программа быстрее.
[32:24.320 --> 32:35.000]  А какая разница-то? Вот вы в конце напишете здесь return, например. Я так понимаю, вы наоборот
[32:35.000 --> 32:41.200]  хотите return записать if и тут написать ifLargest равно if. Ну да. А какая разница? У вас все равно
[32:41.200 --> 32:54.200]  сравнение произойдет. Еще вопросы? Нету. Получается нигде вот индекс элементов
[32:54.200 --> 33:01.100]  там просто вот, если конкретно говорить о задаче, там было еще, что мы сохраняли номер,
[33:01.100 --> 33:08.840]  под которым он ввелся. Это вам нужно понять, как реализовать. Это нужно вам понять,
[33:08.840 --> 33:21.040]  как реализовать просто. Окей. Давайте оценим время работы нашего ifDown. Смотрите, когда я
[33:21.040 --> 33:28.920]  делаю просеивание вниз, я могу рекуррентно кое-что обнаружить. Представьте следующее. У меня вот
[33:28.920 --> 33:36.120]  есть элемент, и вот здесь вот у меня тоже есть элементы, и я вот делаю просеивание вниз вот
[33:36.120 --> 33:43.320]  этого вот, вот этой вот штуки. Так как я делаю просеивание вниз, у меня здесь тоже может быть
[33:43.320 --> 33:54.080]  что-то, к примеру, и так далее. Вопрос. Как связано время работы с временем работы,
[33:54.080 --> 34:06.800]  если я просеял влево? Кто-нибудь представляет или нет? На каждом шагу вы будете сравнивать
[34:06.800 --> 34:16.520]  элемент с двумя оставшимися, ну с его двумя детьми. Время работы не будет, два log n, то есть log n в итоге.
[34:16.520 --> 34:23.080]  Смотрите, вот я хочу рекурсивно это сделать чуть-чуть по-другому. Смотрите, когда я делаю
[34:23.080 --> 34:30.040]  просеивание вниз, само просеивание вниз работает за это от единицы, правильно? Ну потому что у меня
[34:30.040 --> 34:37.720]  в нем ничего не делается, что-то кроме рекурсии, быть может, правильно? Все остальное за вот единички
[34:37.720 --> 34:45.760]  работает. Здесь не поиска, нет ничего. Это вот как раз таки оценка. А вот в какое дерево оно может
[34:45.760 --> 34:52.360]  пойти? Сколько там может быть элементов? Я утверждаю, что в этом другом дереве не больше,
[34:52.360 --> 34:59.920]  чем 2n делить на три элемента. Почему это так? Ну то есть у меня первоначально было n элементов,
[34:59.920 --> 35:08.840]  стало это 2n на 3. Потому что один кусок нашей пирамиды может быть полный, а другой не полный,
[35:08.840 --> 35:14.920]  вот как, к примеру, здесь. У нас слева находятся вот листья, у нас вот этими являются, а здесь
[35:14.920 --> 35:20.720]  всего лишь один элемент, у него нет детей. Если мы продолжим эту аналогию, так как у нас заполняется
[35:20.720 --> 35:27.480]  все по слоям, то мы можем здесь вести еще два ребенка, а вот у этих тоже есть подвое детей,
[35:27.480 --> 35:35.720]  а вот у этих нету, к примеру. И так далее. То есть так или иначе мы будем говорить о том,
[35:35.720 --> 35:41.480]  что в каждом вот в левом по дереве меньше либо равно, чем 2n делить на три элемента.
[35:41.840 --> 35:50.680]  Меньше либо равно. Здесь тоже меньше либо равно, чем 2n делить на три. Вообще здесь меньше,
[35:50.680 --> 36:02.840]  чем n пополам. То есть можно написать как n пополам. Вот. Почему так? Потому что у нас,
[36:02.840 --> 36:09.960]  если у нас здесь есть дети, вот такие, то в левом по дереве у нас тоже обязательно есть дети.
[36:09.960 --> 36:19.800]  А вот для правого, если там, к примеру, нет детей, в левом может быть, а может и не быть. И вот этот
[36:19.800 --> 36:25.800]  вот слой, если мы просто возьмем и оценим, то суммарно здесь будет не больше 2n на три элемента.
[36:25.800 --> 36:33.680]  То есть мы все время уменьшаемся на две трети. Вот каждый шаг у нас уменьшает на две трети. А это
[36:33.680 --> 36:42.960]  по факту основание логарифма. И тогда в этом случае у нас работа равна о большое от логарифма.
[36:42.960 --> 36:54.000]  Так как мы постоянно уменьшаем количество на три вторых в полтора раза, то мы можем говорить о том,
[36:54.000 --> 37:02.800]  что у нас работает севердаун за логарифм. Вот и все. Можете повторить, пожалуйста,
[37:02.800 --> 37:09.480]  откуда две трети взялось? Взялось две трети. Смотрите, предположим, у нас было здесь n элементов.
[37:09.480 --> 37:20.280]  Вот здесь вот. Вот мы верхний делаем севердаун, и здесь у нас n элементов. Худший случай, это когда
[37:20.280 --> 37:28.520]  он пойдет в левое под дерево, оно будет полное, полное как бинарное такое под дерево. Видите,
[37:28.520 --> 37:34.280]  у него все листы есть, все заполнено по максимуму. А в правом не будет ничего.
[37:34.280 --> 37:44.480]  Тогда у нас будет как здесь выглядеть. Вот здесь вот. Вот эти два слоя будут одинаковы по количеству
[37:44.480 --> 37:49.440]  элементов. И единственный слой, на котором у нас будут различия, это нижний слой. Правильно?
[37:49.440 --> 37:57.800]  Смотрите, так уж получается, что вот здесь вот количество листов на один больше,
[37:57.800 --> 38:04.520]  чем количество элементов здесь. Просто в силу дерева бинарного. И тогда получается,
[38:04.520 --> 38:12.440]  если мы возьмем и скажем, что это n, это тоже n, это тоже n. Но я так утрированно сейчас взял.
[38:12.440 --> 38:18.920]  Там надо просто плюс-минус единички сделать еще, на самом деле. Вот. Если здесь мы возьмем
[38:18.920 --> 38:26.400]  n-3-минус единицы, к примеру. Тогда в этом случае здесь у нас ограничение 2n-3. Все.
[38:26.400 --> 38:33.120]  А почему не можем сказать, что мы просто в худшем случае пройдем всю высоту дерева
[38:33.120 --> 38:41.080]  и этого грифа тоже самое? Можно так. Я просто решил по-другому. В худшем случае,
[38:41.080 --> 38:45.720]  действительно, мы пройдем всю высоту дерева. Высота дерева у нас, у грифа. Мы это тоже уже
[38:45.720 --> 38:54.440]  сказали. Вот. Это то, что касается этого момента. Смотрите. Есть ли еще вопросы к сейвдауну?
[38:54.440 --> 39:01.600]  Да, можно вопрос еще? Получается, откуда взялось... Ну, вот вы сейчас объясняли про две третьи. Тут же
[39:01.600 --> 39:12.040]  про одну треть понятно, а две третьи почему? Ну, 1 треть сверху, 1 треть снизу, 1 треть справа. А тогда
[39:12.040 --> 39:19.120]  почему справа меньше либо равняется, чем n пополам, а не n на 3? Потому что у нас может быть
[39:19.120 --> 39:25.880]  такой случай, что здесь заполнено абсолютно все. Тогда в этом случае эти два поддерева равны.
[39:25.880 --> 39:40.760]  Так, хорошо. Давайте двигаться дальше. Теперь, что касается другого момента. Представьте,
[39:40.760 --> 39:48.080]  что нам необходимо. Мы изменили элемент, но он стал больше. То есть мы его не уменьшили,
[39:48.080 --> 39:53.480]  а увеличили. Ну, кто-то там, не знаю, купил золотые акции типа Apple, вот они подорожали,
[39:53.720 --> 40:00.120]  iPhone 13 вышел. Все рады, все довольны. Поэтому там увеличивается стоимость. Ну, или кто там
[40:00.120 --> 40:08.440]  лотерею, например. В этом случае нам необходимо сделать так называемое просеивание вверх. Давайте
[40:08.440 --> 40:20.600]  с вами это тоже нарисуем и поймем, как это делать. Это делать еще легче. Вот у меня было 16, а здесь
[40:20.600 --> 40:39.320]  там 14, здесь 10, здесь там 8, 7, здесь 2, 4. И вот здесь вот я сделаю 15. Не один, а 15 стал.
[40:39.320 --> 40:49.400]  К примеру, здесь 9 и 3. Мне необходимо этот элемент просеять вниз. То есть он увеличил свое состояние,
[40:49.400 --> 40:54.680]  он увеличился. Тогда мне необходимо просеять его вверх. То есть мне нужно просто сравнить его
[40:54.680 --> 41:02.320]  с родителем. Если вдруг его родитель меньше, то поставить его на свое место. Почему это работает
[41:02.320 --> 41:09.080]  корректно тоже? Потому что если здесь, так как мы изменили всего один элемент, мы говорим о том,
[41:09.080 --> 41:15.280]  что по факту почти во всей пирамиде сохранено наше свойство. А если оно сохранено, то даже
[41:15.280 --> 41:22.080]  если у него есть какой-то еще ребенок, то родитель больше этого другого ребенка, но меньше,
[41:22.080 --> 41:26.320]  чем этот. Значит, если мы поставим элемент больший, то свойство все равно сохраняется.
[41:26.320 --> 41:34.880]  То, что мы хотим получить из этого, мы получаем следующее. 16, 14 после первой
[41:34.880 --> 41:44.760]  итерации просеивания вверх. 16, 14, здесь 8, здесь у нас уже будет 15, здесь 2, 4, а 7 мы просеяли,
[41:44.760 --> 41:52.600]  то есть они поменялись местами. Здесь там 9 и 3. Теперь нам необходимо 15 еще раз просеять вверх,
[41:52.600 --> 41:58.120]  потому что не факт, что оно встало на свое место. И действительно 14 будет меньше 15. Поэтому мы
[41:58.120 --> 42:05.800]  должны его взять и просеять еще раз вверх. Поэтому в этом случае мы с вами получим 16,
[42:05.800 --> 42:20.880]  15, 10, тут 9, тут 3, тут 8, тут 14, тут 7, здесь 4 и 2. Очень важные свойства пирамиды. Не забывайте,
[42:20.880 --> 42:27.720]  главное, что вот если оно заполняется, то оно заполняется слева направо. Вот таким вот образом
[42:27.800 --> 42:33.360]  мы с вами взяли и получили. Сифтап работает еще легче, он пишется еще круче.
[42:33.360 --> 42:44.040]  А если бы мы не 15 двигали, а 18, например? 18 где? Ну как вот, вместо 15 мы бы двигали
[42:44.040 --> 42:49.040]  18. Тогда бы оно поменялось с корнем. И все. Да. А вот оно и сохранилось.
[42:49.040 --> 42:56.000]  Конечно, потому что корень, смотрите еще раз, корень, представьте, здесь было бы 18. Давайте
[42:56.000 --> 43:06.760]  я сейчас нарисую. Здесь было 15. А я вот сделаю 18. Ну вот я напишу зелененьким, чтобы вы не путались.
[43:06.760 --> 43:14.480]  А 18 больше 16. Но так как я менял всего один элемент, я знаю, что вот эта десятка меньше 16,
[43:14.480 --> 43:22.040]  тоже правильно? Если она меньше 16, то она меньше и 18. Поэтому если я поменяю местами,
[43:22.040 --> 43:30.080]  у меня ничего не произойдет. Понятно, спасибо. Как работает вообще сифтап? Сифтап.
[43:30.080 --> 43:43.040]  Просеивание вверх. Мы также передаем А, индекс И, который мы просеиваем. И здесь нам,
[43:43.040 --> 43:49.760]  в принципе, размер массива уже не нужен. Почему не нужен? А потому что, ну, а зачем он нам нужен
[43:49.760 --> 43:56.000]  здесь, в принципе? Мы же идем вверх, а вверх — это в начало массива. И мы говорим следующее,
[43:56.000 --> 44:11.320]  что у меня родитель равен родителю. После чего, если у меня И больше либо равно одному,
[44:11.320 --> 44:38.120]  и А от Parent меньше, чем А от И, то есть не выполняется это свойство, что родитель должен
[44:38.120 --> 44:54.600]  быть больше либо равен, то в этом случае мы просто запускаем сифтап. Мы делаем свап.
[44:54.600 --> 45:13.920]  После чего мы делаем еще один сифтап. То есть мы еще раз просеиваем сифтап от А и Parent.
[45:13.920 --> 45:27.200]  Все. Это весь сифтап. Ой-ой. Случайно я нарисовал эту линию. А эта реализация на нулевой индексации
[45:27.200 --> 45:38.320]  или на единичной? На единичной и на нулевой. Если на единичной, то когда мы дошли до самого
[45:38.320 --> 45:51.400]  вверх, мы все равно будем проверять. Это правда. В этом случае — да. Хорошо. Больше единицы. Нет
[45:51.400 --> 45:59.920]  смысла проверять вверх. Для нулевой будет больше либо равно? Можно вопрос задать? Да. Не
[45:59.920 --> 46:07.000]  легче сделать вайлом, то есть вместо рекурсивной функции вайлу? Можно сделать вайлом, пожалуйста.
[46:07.000 --> 46:13.320]  А что будет быстрее работать? И то, и то за логен? Оно все работает за логен,
[46:13.320 --> 46:23.120]  просто рекурсия не забивает стек. Можно сделать вайлом, пожалуйста. Просто так выглядит понятнее
[46:23.120 --> 46:30.320]  с точки зрения того, что если у нас есть, мы еще можем просеять вверх, мы просеиваем вверх.
[46:30.320 --> 46:37.520]  В случае того, когда мы поменяли местами наш элемент, мы просеиваем вверх. Вот это все просеивание
[46:37.520 --> 46:51.520]  вверх. Работает оно тоже естественно за УАТАЖ. Можно еще вопрос? Да. А если бы в изначальном
[46:51.520 --> 47:02.800]  дереве, там где 8 стояло 9, а там где 15-8, то получается, если бы поменяли 8 и 7 сначала местами,
[47:02.800 --> 47:13.160]  получилось бы, что слева стоит 9, а справа 8. И от этого не ломается все? Сейчас еще раз. Если
[47:13.160 --> 47:23.840]  бы изначально на месте восьмерки стояло 9, а там где 15 стояло 8. Так у меня бы 8 не просеялось бы выше
[47:23.840 --> 47:36.240]  14. 14-то больше. Ничего бы не просеялось. 8 бы встало на место семерки и все. А это разве
[47:36.240 --> 47:46.760]  не будет неправильно, что слева стоит 9 больше 8? Это не дерево. Это не бинарное дерево поиска.
[47:46.760 --> 47:53.800]  Еще раз, давайте так. Это пирамида. У пирамиды главное, что родитель больше его детей. И все.
[47:53.800 --> 48:02.000]  Просто больше. Неважно, где какое больше, справа или слева. Здесь без разницы. Понятно? То есть не
[48:02.000 --> 48:06.520]  соединяйте пока пирамиду и бинарное дерево поиска. Вы потом это будете сделать, видимо, в следующем
[48:06.520 --> 48:14.720]  семестре. Поймете, что это вообще такое будет. Сифтап работает таким вот образом. Тоже
[48:14.720 --> 48:29.560]  достаточно понятная структура. Есть ли к ней какие-то вопросы? Видимо, нет. Хорошо. Теперь,
[48:29.560 --> 48:35.160]  что касается построения пирамиды. Как вы думаете, за сколько можно построить пирамиду? Давайте,
[48:35.160 --> 48:57.760]  ваше предположение. За линию. За ООТН, по-моему. За ООТН, так. На Энлоген, наверное. Так,
[48:57.800 --> 49:04.960]  смотрите. Ну, за КУПА это что-то странное, учитывая, что у нас есть сифтапы просто, которые мы можем
[49:04.960 --> 49:13.000]  поднимать элементы. И все. Откуда КУПА возьмется, я не понял. Что касается построения пирамиды.
[49:13.000 --> 49:21.360]  В действительности, у нее есть построение за ООТН. Мы с вами это докажем сейчас. Первоначально,
[49:21.360 --> 49:27.400]  по виду, будет казаться, что это не за ООТН, а за Энлоген. Мы с вами это докажем. Смотрите,
[49:27.400 --> 49:44.840]  давайте сделайте себе подзаголовок. Построение пирамиды. Что касается этого момента. Код здесь
[49:44.840 --> 49:57.200]  достаточно простой. Смотрите. Начиная с Н пополам, если я возьму свой массив. Вот у меня был массив.
[49:57.200 --> 50:24.720]  16, 14, 10, 8, 7, 9, 3, 2, 4 и 1. Здесь немножко слиплись. 4 и 1. Я утверждаю следующее.
[50:24.720 --> 50:39.520]  Н пополам элементов. Начиная с Н пополам. То есть у меня здесь сколько? 1, 2, 3, 4, 5, 6, 7, 8,
[50:39.520 --> 50:50.200]  9, 10. Начиная с шестого элемента. Все является листьями. Начиная вот отсюда.
[50:50.200 --> 51:01.480]  То есть вы взяли ближайшую сумму арифметической прогрессии с шагом 1. Что еще раз? Вы взяли
[51:01.480 --> 51:10.160]  ближайшую сумму арифметической прогрессии, где А1 равно 1 и разность равно 1. На ближайшую
[51:10.160 --> 51:26.520]  сумму это 6 и вычлые из 10 и 6. Я понял. Там не арифметическая прогрессия. Там в степени
[51:26.520 --> 51:36.360]  двойки. Это именно так и делается. Это правда. В действительности это именно так и происходит.
[51:36.640 --> 51:47.440]  Это утверждение корректно, что у нас Н пополам последних элементов. Начиная с Н пополам плюс 1.
[51:47.440 --> 52:05.640]  Последних элементов являются листьями. Исходя из этого, можно кое-что получить. Мы с вами
[52:06.120 --> 52:17.560]  давайте построим пирамиду. Исходя из этого утверждения. Строение пирамиды. На основе
[52:17.560 --> 52:24.960]  уже какого-то массива, не отсортированного с точки зрения пирамиды. Ничего. По массиву А размером
[52:24.960 --> 52:42.240]  там size. Мы говорим следующее, что for и равное от size пополам. Может кто-то из вас помнит такое.
[52:42.240 --> 52:59.480]  То есть просто по минус единички мы все время вычитаем shift down. А и size. Там, наверное, просто и size пополам.
[52:59.480 --> 53:21.600]  Вы просто и присваиваете. Тогда в этом случае мы с вами получаем построенную пирамиду.
[53:21.600 --> 53:29.200]  Почему? Давайте сначала ответим почему. Для того, чтобы доказать корректность, мы скажем следующее.
[53:29.200 --> 53:48.520]  У нас сохраняется следующий инвариант. Мы говорим, что инвариант нашего алгоритма следующий. В начале
[53:48.520 --> 54:18.360]  каждой итерации цикла for. Узлы и плюс один и плюс два и так далее до
[54:18.360 --> 54:45.160]  size. Являются корнями не возрастающей пирамиды.
[54:48.360 --> 54:57.040]  Вот почему этот вариант сохраняется. Инвариант сохраняется следующим образом.
[54:57.040 --> 55:02.560]  Первоначально мы говорим о том, что все начиная с size пополам плюс один у нас все является листьями.
[55:02.560 --> 55:10.080]  Лист сам по себе, то есть одна вершинка является невозрастающей пирамидой. Ну из одного элемента.
[55:10.080 --> 55:20.160]  Логично. Когда мы с вами запускаем сивдаун, на каждом шаге мы запускаем сивдаун этого цикла,
[55:20.160 --> 55:26.960]  то есть мы начинаем просеивание. Грубо говоря, мы добавляем один элемент, он может быть больше,
[55:26.960 --> 55:32.520]  может быть меньше, но мы берем и просеиваем, потому что это корень. Если это корень,
[55:32.520 --> 55:38.480]  то мы можем просеять только вниз. А когда мы начинаем просеивать вниз, добавляя всего один
[55:38.480 --> 55:46.800]  элемент в нашу пирамиду, мы восстанавливаем наше свойство, свойство пирамиды, то есть мы его
[55:46.800 --> 55:55.120]  поддерживаем. Благодаря этому мы говорим о том, что у нас этот вариант сохраняется. Если он
[55:55.120 --> 56:03.440]  сохраняется, то в конце, когда мы закончим наш цикл, у нас пирамида будет для все, все индексы
[56:03.440 --> 56:10.200]  будут являться корнями невозрастающей пирамиды, в том числе для индекса равного один, для нашего
[56:10.200 --> 56:17.760]  корня. Таким образом мы говорим о том, что мы получили пирамиду. Вот и все. Понятна логика
[56:17.760 --> 56:26.400]  рассуждений? За линию работает, почему сейчас разберемся. Вы сейчас говорили, что у нас пирамида
[56:26.400 --> 56:33.440]  по неубыванию или по невозрастанию? По неубыванию.
[56:33.440 --> 56:48.560]  Сейчас. Мы отсекаем скажем половину. По невозрастанию, извините, по невозрастанию.
[56:48.560 --> 56:54.560]  То есть вниз у нас идут элементы меньше. Еще раз, да, какой вопрос был?
[56:54.560 --> 57:08.320]  Или не было вопросов? Что касается простой оценки данного алгоритма, простая оценка, давайте.
[57:08.320 --> 57:18.920]  Простая оценка данного алгоритма следующая. Мы говорим о том, что севдаун работает за логарифт,
[57:18.920 --> 57:32.320]  мы делаем n пополам раз, тогда работает алгоритм за o от n лога. Это неправда. Почему? По следующей причине.
[57:32.320 --> 57:56.040]  Смотрите. Ведем с вами понятие высоты узла. Что такое высота узла? Высота узла. В пирамиде.
[57:56.040 --> 58:24.240]  Это число ребер. Число ребер. В самом, самом длинном, простом пути,
[58:24.240 --> 58:44.360]  нисходящим пути, давайте, нисходящим, нисходящим пути от узла в каком-то из листях.
[58:44.360 --> 59:00.480]  Вот, то есть мы говорим о том, что это просто количество ребер до какого-то узла нисходящего.
[59:00.480 --> 59:11.600]  Тогда из этого мы можем сказать следующее, так как мы знаем такой вот факт. У нас высота равна по
[59:11.600 --> 59:18.160]  факту. А, так как мы говорим о том, что это число ребер, то это будет вот так. Логарифт двоичный от n.
[59:18.160 --> 59:28.120]  Так как это число ребер. Вот. Смотрите, высоту просто периодически объявляют как число ребер или
[59:28.120 --> 59:35.040]  количество вершин, в зависимости от этого плюс-минус единичка. Я думаю, вы это знаете. Вот. Ну,
[59:35.040 --> 59:41.640]  то есть здесь все зависит от того, каково было определение первоначально. Вот. Высота у нас такая.
[59:41.640 --> 01:00:03.800]  Утверждение следующее. Утверждение на любом, на любом уровне, на высоте.
[01:00:05.400 --> 01:00:16.000]  Аш содержится не более
[01:00:23.520 --> 01:00:28.280]  n на 2h плюс один элементов.
[01:00:28.280 --> 01:00:42.400]  Это степень аж плюс один? Да, это степень аж плюс один. Два в степени аж плюс один.
[01:00:42.400 --> 01:00:52.240]  Почему это утверждение верно? Это утверждение верно в силу просто построения дерева. Так как у
[01:00:52.240 --> 01:00:58.880]  нас есть максимальный, ну, мы говорим о том, что у нас есть там максимальный,
[01:00:58.880 --> 01:01:08.920]  прошу прощения, у нас есть, мы заполняем когда дерево, мы получаем почти полное бинарное дерево,
[01:01:08.920 --> 01:01:16.480]  заполняем его слева направо. Если мы его заполняем слева направо, то у нас высота как бы отличается
[01:01:16.480 --> 01:01:22.240]  у всех элементов на плюс-минус единичку. Вот. То есть там у некоторых там высота,
[01:01:22.240 --> 01:01:29.120]  к примеру, на одном уровне, а один у других ноль. Ну, например. Вот. И в зависимости от этого мы
[01:01:29.120 --> 01:01:35.040]  можем что-то считать. Но так как от каждого листа мы строим с вами какую-то одну новую вершину,
[01:01:35.040 --> 01:01:42.440]  то в этом случае мы говорим о том, что на некоторой высоте, на некоторой высоте находится вот такое
[01:01:42.680 --> 01:01:51.240]  количество узлов. Давайте еще раз. Почему так? Вот, для примера, для листьев. Для листьев мы говорили
[01:01:51.240 --> 01:01:58.320]  не более n пополам узлов. Мы это получили с вами. Если мы подставим h равной нулю, мы получим с
[01:01:58.320 --> 01:02:06.200]  вами n пополам узлов. Для каждого из листьев вверх идет, для двух листьев есть одна вершина сверху.
[01:02:06.200 --> 01:02:13.760]  То есть мы уменьшаем еще в два раза это количество. Поэтому у нас получается n делить на 4.
[01:02:13.760 --> 01:02:20.200]  Для каждого из этих полученных вершин мы говорим о том, что там еще в два раза уменьшается,
[01:02:20.200 --> 01:02:26.560]  потому что для каждых двух вершин вверх идет одна вершина, один узел, и у него высота увеличивается
[01:02:26.560 --> 01:02:31.960]  на единицу. Там уже будет n на 8, потому что n на 4 разделить на 2 и так далее. То есть рассуждения
[01:02:31.960 --> 01:02:36.960]  здесь именно такие. Поэтому мы говорим о том, что у нас на любом уровне на высоте h содержится
[01:02:36.960 --> 01:02:44.400]  не более чем n делить на 2 h плюс 1 узлов. Тогда, в этом случае давайте посчитаем количество наших
[01:02:44.400 --> 01:02:52.200]  действий. Сколько у нас будет работать там сифтап? Ну вот все вот это вот вместе. Мы знаем, что сифтап
[01:02:52.200 --> 01:02:58.040]  работает за o от h. Ой, сифтап, извините, сифтап работает за o от h. Поэтому, суммарное время,
[01:02:58.040 --> 01:03:13.000]  суммарное время t равно сумме от h равного нуля до нашей максимальной высоты, это логарифм двоечный,
[01:03:13.000 --> 01:03:30.240]  от n, n делить на 2 h плюс 1. И работа самого сифтап, сифтдауна от h. А почему у нас сумма
[01:03:30.240 --> 01:03:41.480]  идет по n и логарифм тоже от n? Это h. А, хорошо. h. Это, а здесь логарифм от n. Ну высота от нуля до
[01:03:41.480 --> 01:03:55.040]  логарифма. Хорошо? Вот здесь вот у меня тоже h. Вот, я могу внести в o вот эту вот всю сумму. Тогда
[01:03:55.040 --> 01:04:03.320]  я получу с вами o. Вот, давайте одну двоечку я вынесу за сумму. Я получу n пополам, потому что n не
[01:04:03.320 --> 01:04:14.720]  входит в сумму мою в принципе. Логарифм там всегда определен по факту. Вот. Сумма от h делить на 2 в
[01:04:14.720 --> 01:04:30.840]  степени h. От h равного нуля до логарифма. Вот. В силу разложения рядов я могу вам сказать следующее,
[01:04:30.960 --> 01:04:42.160]  что может быть кто-то из вас знает, что x делить на 2 в степени x в бесконечности от x равного нуля,
[01:04:42.160 --> 01:04:57.080]  то по факту будет 2. Сумма бесконечного ряда. Вот. Если более подробно, то это считается как 1
[01:04:57.080 --> 01:05:04.320]  вторая. Там есть по факту формула для этого всего. 1 вторая на 1 минус 1 вторая в квадрате.
[01:05:06.320 --> 01:05:15.480]  Вот. Поэтому здесь мы говорим о том, что это o от n пополам умножить на 2.
[01:05:15.480 --> 01:05:21.240]  Именно поэтому такое построение работает за o от n.
[01:05:26.560 --> 01:05:31.120]  Так как мы асимпатически смотрим, вот этот логарифм, логарифм от n, он у нас стремится
[01:05:31.120 --> 01:05:37.440]  к бесконечности. Поэтому мы сумму ограничиваем бесконечностью сверху. Понятно? Давайте тут
[01:05:37.440 --> 01:05:54.880]  каши написано. Сумма здесь. Логарифм двоичный от n. Вот. Таким образом мы получили, что мы
[01:05:54.880 --> 01:06:06.640]  построим нашу пирамиду за o от n. Есть ли к этому вопроса? Откуда n пополам отдельную
[01:06:06.640 --> 01:06:12.960]  сумму? Смотрите, у нас было в сумме n. n делится 2h плюс 1. То есть количество узлов на такой
[01:06:12.960 --> 01:06:23.480]  высоте. Правильно? n я выношу за сумму. Вот. И двоечку одну выношу за сумму. Все. Вопросы?
[01:06:23.480 --> 01:06:40.800]  Здесь мы будем поднимать элемент. Получается, за n лог n работает? Да. Ну, там, если не ошибаюсь,
[01:06:40.800 --> 01:06:50.960]  то да, по-моему, да. Можно вопрос? То есть вы вынесли n и заменили на h? Нет. Где я заменил на h?
[01:06:50.960 --> 01:07:00.680]  Что я заменил на h? Это n тоже? Или это все-таки h? Еще раз, вот это o от h. Я внес под o. Я внес h умножить на эту
[01:07:00.680 --> 01:07:09.120]  сумму. Значит, я h могу под сумму внести по факту. Поэтому o от h у меня оставил под суммой. Ну, o от h это
[01:07:09.120 --> 01:07:24.000]  выполнение нашего издауна. Вот. Поэтому я внес. Высоту заглавной писать? Ну, давайте я здесь исправлю,
[01:07:24.000 --> 01:07:41.280]  для того чтобы, да, вы не запутались. h. h. h. h. Здесь у меня h. Большое. Ну, то есть те, у кого маленькое,
[01:07:41.280 --> 01:07:54.840]  и вы поняли, где что находится. Смотрите. Здесь у меня тоже h. Вот здесь вот у меня h. Все. Ну,
[01:07:54.840 --> 01:08:10.680]  вот здесь вот у меня h. Понятно стало, почему за o от n? Спасибо. Вот. Извините, пожалуйста,
[01:08:10.680 --> 01:08:21.960]  можно вопрос про сифтап? Да. Он же за o от log n работает, а не за n log n? За log n, да. За log n,
[01:08:21.960 --> 01:08:32.080]  спасибо. N log n имелось в виду построение сифтапов. А, спасибо большое. Извините, у вас там написано
[01:08:32.080 --> 01:08:39.960]  высота узла в пирамиде. Это число ребер в самом длинном простом нисходящем пути от узла какого-то
[01:08:40.000 --> 01:08:49.000]  из листьев. Да. А почему, можете объяснить, почему формула тогда высоты h log n? Ну, h равно log n.
[01:08:49.000 --> 01:09:00.600]  Ну, давайте нарисуем. Я думал, это будет понятно. Ну, высота вот этого узла чему равно? Одному,
[01:09:00.720 --> 01:09:10.320]  правильно? Здесь n имеется в виду количество узлов, которые находятся под этим узлом?
[01:09:10.320 --> 01:09:19.240]  Да, если мы считаем, что этот узел у корень. А, все. Так, стало понятно. Еще вопросы есть?
[01:09:19.240 --> 01:09:25.600]  Как сделать быстрее, чем построение за линию? Быстрее, чем построение за линию нет. Но оно
[01:09:25.600 --> 01:09:31.600]  не понадобится, потому что нам необходимо кое-что сделать еще. В приоритетной очереди не
[01:09:31.600 --> 01:09:43.840]  заходит за линию. Я перепроверю. А, ладно. Что касается, давайте теперь последнее,
[01:09:43.840 --> 01:09:48.400]  что нам осталось взять от пирамиды. Я перепроверю насчет приоритетной очереди,
[01:09:49.040 --> 01:10:00.600]  что касается пирамиды. Последнее, что нам осталось, это алгоритм сортировки.
[01:10:00.600 --> 01:10:15.480]  Давайте сделаем следующее. У меня с вами была пирамида. Здесь вот было 16, там 14. Предположим,
[01:10:15.480 --> 01:10:27.920]  она у меня построена. 10, здесь 8, здесь 7, здесь 1, здесь 2, здесь 4, здесь 9, здесь 3. У меня есть
[01:10:27.920 --> 01:10:35.160]  вот такая пирамида. Я хочу отсортировать этот массив данных. У меня же это как массив,
[01:10:35.160 --> 01:10:53.240]  представляется. Давайте я запишу еще массив. 16, 14, 10, 8, 7, 9, 3, 2, 4 и 1. Для того,
[01:10:53.240 --> 01:11:01.040]  чтобы отсортировать массив, у меня сверху лежит элемент наибольший. Я хочу отсортировать по минимуму.
[01:11:01.040 --> 01:11:09.960]  Давайте я с вами сделаю просто следующее. Поменяю местами 6 и самый последний элемент,
[01:11:09.960 --> 01:11:21.620]  который находится внизу. 16 точнее. Я вот сюда поставлю 16. Сюда поставлю 16, сюда 1 и сделаю
[01:11:22.140 --> 01:11:31.380]  То есть я вначале получу с вами 1. Дальше у меня все останется на своих местах будет 1,
[01:11:31.380 --> 01:11:47.020]  14, 10, 8, 7, 9, 3, 2, 4. А здесь 16 и я, грубо говоря, уменьшаю размер своего дерева. Вот
[01:11:47.620 --> 01:11:51.900]  этой пирамиды уменьшаю. То есть я нарушаю вот эту связь. У меня здесь будет просто 16,
[01:11:51.900 --> 01:12:11.980]  как чиселка валяться. Мне нужно еще и сайс уменьшать. 1 я выбрал как самый последний элемент.
[01:12:11.980 --> 01:12:30.100]  У меня вот здесь 0 может быть. Просто еще раз. Я, грубо говоря, уменьшаю свою пирамиду на 1,
[01:12:30.100 --> 01:12:37.140]  вот этот элемент больше не входит в пирамиду. Оставлю наверх пирамиды просто любой элемент,
[01:12:37.140 --> 01:12:42.620]  лучше маленький, ну просто минимальный, потому что я в конец 16 запихал, я просто своп сделал
[01:12:42.620 --> 01:12:49.420]  между собой элементы. Когда я его сделал между собой этот своп, то в этом случае я говорю о том,
[01:12:49.420 --> 01:12:56.780]  что у меня на 1 элемент, то есть, грубо говоря, верхний, он уменьшился, точно уменьшился. А значит,
[01:12:56.780 --> 01:13:02.500]  для того чтобы поставить его на свое место, мне нужно будет делать всего лишь сивдаун. Один же
[01:13:02.500 --> 01:13:08.340]  элемент уменьшился, один. Для поддержания свойства пирамиды мне будет достаточно делать сивдаун.
[01:13:08.340 --> 01:13:20.060]  Понятно? Таким образом, мы с вами получим 16 в конце, потом мы уменьшим единицу и поставим
[01:13:20.060 --> 01:13:33.620]  ее на свое место. Единица встанет 14, 8 сюда, единица встанет вот сюда. Вот. И дальше,
[01:13:33.620 --> 01:13:41.700]  мы когда так сделали, наверху окажется 14, и в конец я помещу 14. И вот эту единицу,
[01:13:41.700 --> 01:13:45.980]  грубо говоря, опять запихаю наверх. Ну просто так вышло, что единица здесь у меня, вот именно
[01:13:45.980 --> 01:13:53.180]  здесь она будет. Так уж получилось. И так далее. То есть, я в конец буду записывать все элементы
[01:13:53.180 --> 01:14:00.860]  меньше. И вот у меня будет 14, 16, 10, потом у меня будет следующий элемент, самый наибольший будет
[01:14:00.860 --> 01:14:10.780]  9 в оставшейся пирамиде, потом 8, потом 7 и так далее. Благодаря этому мы с вами и получим нашу
[01:14:10.780 --> 01:14:18.100]  сортировку. То есть, что касается сортировки, она выглядит тоже очень-очень просто.
[01:14:18.100 --> 01:14:21.780]  Как мне будет посмотреть, как будет выглядеть пирамида в конце?
[01:14:21.780 --> 01:14:25.540]  Никак. Как один элемент единицы?
[01:14:25.540 --> 01:14:30.820]  Как один элемент единицы, да. То есть, это все, что там будет. Ну, то есть, это не пирамида по факту.
[01:14:30.820 --> 01:14:35.180]  А, все понятно. То есть, мы нарушаем связи. Как только мы здесь убрали
[01:14:35.180 --> 01:14:38.660]  элемент, мы тоже его нарушили, связь здесь. Да, какой вопрос?
[01:14:38.660 --> 01:14:46.900]  Тут не будет работать сортировка слияния, если мы возьмем как массив 2, 8, 14, 16, 4, 8, 14, 16.
[01:14:46.900 --> 01:14:54.460]  Получается 1, 7, 14, 16, 9, 10, 16 и 3, 10, 16. Если мы просто будем сортировку слияния применять.
[01:14:54.460 --> 01:15:00.860]  2, 8, 14, 16. Потом 4, 8, 14, 16. Мы сделали
[01:15:00.860 --> 01:15:06.500]  сортировку слиянием, получили массив. 3, 8, 2 раза повторяется, 14 повторяется, 2 раза.
[01:15:06.500 --> 01:15:12.300]  Ну, а никак нельзя реализовать в плане тут слияния?
[01:15:12.300 --> 01:15:15.540]  Я, к сожалению, такого не знаю. Понял, спасибо.
[01:15:15.540 --> 01:15:22.340]  Что касается самого алгоритма сортировки, типа именно HipSort.
[01:15:22.340 --> 01:15:29.420]  Просто HipSort, HipSort, который передается наш массив A и размер.
[01:15:29.420 --> 01:15:41.140]  Вот, что делается? Делается следующее, что у нас строится пирамида BuildHip,
[01:15:41.140 --> 01:15:52.060]  у нас BuildHip работает, то есть от A и size. После чего мы делаем следующее,
[01:15:52.060 --> 01:16:13.220]  4 и равное сразу down to A2. Мы делаем swap от A1 и A2.
[01:16:13.220 --> 01:16:20.980]  Уменьшаем размер нашего массива, то есть размер нашей пирамиды по факту.
[01:16:20.980 --> 01:16:37.620]  И shift down от A1. Все. То есть мы каждый раз просто меняем элементы с последним,
[01:16:37.620 --> 01:16:44.860]  забываем про последний, уменьшаем размер нашей пирамиды и делаем shift down.
[01:16:44.860 --> 01:16:49.500]  Конец. Ой, ну у нас shift down там еще size передавался, извините.
[01:16:49.500 --> 01:16:56.460]  Ну, это за сколько работает? Это же дольше, чем за nLogin.
[01:16:56.460 --> 01:16:57.020]  Почему?
[01:16:57.020 --> 01:16:58.140]  Нет.
[01:16:58.140 --> 01:17:04.180]  За сколько работает Build? Давайте оценим с вами. Build работает за O от n, да?
[01:17:04.180 --> 01:17:04.620]  Да.
[01:17:04.620 --> 01:17:09.340]  Shift down работает на O от логарика n.
[01:17:09.340 --> 01:17:10.460]  Блин, красиво.
[01:17:10.460 --> 01:17:17.020]  А вот for здесь, ну это O от n, грубо говоря. То есть O от n умножить на log n.
[01:17:17.020 --> 01:17:27.020]  Получается, сортировка работает за O от n log n. Вот так вот работает пирамидальная сортовка.
[01:17:27.020 --> 01:17:34.820]  Можно еще раз, как мы выбираем следующее. Вот мы выбрали какой-то, ну, в примере с графом,
[01:17:35.300 --> 01:17:40.100]  в примере с деревом мы выбрали единичку. Затем, когда мы поменяли, сделали shift down,
[01:17:40.100 --> 01:17:41.420]  как мы выбираем следующее?
[01:17:41.420 --> 01:17:44.660]  Следующий тоже самый последний элемент в нашей пирамиде.
[01:17:44.660 --> 01:17:48.620]  Получается 7. Ой, 4.
[01:17:48.620 --> 01:17:53.620]  Нет, нет, не 4. Мы сначала единицу должны про shift down. Так уж получится здесь,
[01:17:53.620 --> 01:17:59.620]  что когда мы единицу будем shift down, она перейдет сначала сюда, 14 встанет на верхнее место.
[01:17:59.620 --> 01:18:04.020]  Потом пятерка встанет, а единица сюда встанет, а четверка сюда.
[01:18:04.020 --> 01:18:08.420]  То есть мы опять единицу кидаем наверху.
[01:18:08.420 --> 01:18:14.900]  Так уж получилось, но это не всегда так работает. Если бы здесь была единица, а пятерка, например.
[01:18:14.900 --> 01:18:18.220]  А то она где-нибудь застряла и нам пришлось бы другую.
[01:18:18.220 --> 01:18:23.460]  Пятерка бы осталась вот здесь. Ну представьте здесь пятерку. Давайте с вами,
[01:18:23.460 --> 01:18:29.300]  ну да, я надеюсь вы можете представить, здесь пятерка, которая у меня была вот здесь.
[01:18:29.300 --> 01:18:33.620]  Не единица, а пятерка. Тогда пятерка бы просеялась вот до сюда.
[01:18:33.620 --> 01:18:37.540]  И тогда бы мы действительно четверку меняли бы.
[01:18:37.540 --> 01:18:43.580]  А на что бы место она встала? Пятерку.
[01:18:43.580 --> 01:18:46.900]  Восьмерку, а восьмерка вот сюда, а 14 вот сюда.
[01:18:46.900 --> 01:18:53.940]  Давайте с вами распишем. Хорошо, давайте распишем, после этого у нас будет перерыв.
[01:18:54.100 --> 01:19:15.060]  16. 4. 10. 9. 3.
[01:19:15.060 --> 01:19:21.740]  Ой, ой, ой, не правильно, напишу.
[01:19:21.740 --> 01:19:39.260]  14 8 7 здесь у меня был бы 5 здесь у меня 2 и 4 когда я первый раз поменял местами 5 и 16 и забыл
[01:19:39.260 --> 01:19:46.220]  про то что вообще это существует у нас какое-то новое ребро вот это вот последнего элемента я
[01:19:46.220 --> 01:19:53.260]  бы получил следующую картину у меня была бы здесь пятерка здесь было бы 14 здесь было бы
[01:19:53.260 --> 01:20:05.300]  10 здесь 9 здесь 3 здесь 8 здесь 7 здесь 2 здесь 4 а здесь вот обособлено стоит 16 которая не
[01:20:05.300 --> 01:20:11.840]  входит в нашу пирамиду больше массив она входит в старый но вот в сайсы но больше не входит ну так
[01:20:12.480 --> 01:20:19.120]  это просто обособленная такая вершина пирамида все что зеленая теперь я пятерку делаю всегда
[01:20:19.120 --> 01:20:28.000]  а когда я делаю не всегда он давайте я один раз это распишу прям по полным полностью я получу
[01:20:28.000 --> 01:20:38.440]  следующее здесь вот я нарисую я вначале получу 14 5 10 14 потому что это самый большой из детей вот
[01:20:38.440 --> 01:20:49.560]  здесь 8 здесь 7 здесь 2 здесь 4 здесь 9 здесь 3 после чего я делаю всегда он пятерки еще раз
[01:20:49.560 --> 01:21:06.320]  самый большой 8 из детей поэтому у меня будет 14 8 5 7 2 4 здесь 10 здесь 9 есть 3 ну и вот это 16
[01:21:06.320 --> 01:21:14.680]  все также путешествует то есть где-то она там аморфно существует мы больше не трогаем все мы
[01:21:14.680 --> 01:21:20.560]  просили даунили теперь мы повторяем наш алгоритм нашего типа наши пирамидальные сортировки мы
[01:21:20.560 --> 01:21:32.520]  опять меняем 4 и 14 самый последний элемент самым первым тогда у меня уже после этого будет сейчас
[01:21:32.520 --> 01:21:48.560]  я один раз это тоже нарисую тогда у меня будет 4 8 10 9 3 5 2 7 и вот где-то в вакууме существует
[01:21:48.560 --> 01:21:58.760]  14 и 16 они никак не связаны уже с моей пирамии но они стоят в самом конце причем в начале 16 потом
[01:21:58.760 --> 01:22:07.760]  14 сам в конце 16 и предпоследний 14 правильно да да да да да ну в силу нашего массива потому
[01:22:07.760 --> 01:22:14.000]  что пирамида в начале была из n элементов потом n-1 элемент а мы в самый конец запихиваем максимальный
[01:22:14.000 --> 01:22:21.840]  элемент вот и так далее и теперь мы здесь берем и опускаем опять делаем всегда он для 4 мы его опять
[01:22:21.840 --> 01:22:31.680]  опускаем он опустится вот сюда вот вот вот вот сюда он 4 опустится семерочку а нет извините тут
[01:22:31.680 --> 01:22:42.320]  10 будет больше поэтому всегда он идет вот сюда вот и так далее то есть понятно сама суть алгоритма
[01:22:42.320 --> 01:22:52.520]  как он выглядит не делать его он просто каждый раз искать максимально среди кучей удалять его
[01:22:52.520 --> 01:23:05.400]  а что а что встанет на его вершинку ну какой-нибудь большой маленькое число какое
[01:23:05.400 --> 01:23:18.000]  и что чтобы мы не как чтобы мы туда больше никогда не приходили чтобы мы что чтобы мы
[01:23:18.000 --> 01:23:23.120]  туда больше никогда не приходили так у вас не сохраняется тогда условия пирамиды я не пойму
[01:23:23.120 --> 01:23:30.960]  просто смысл ну то есть если вы ставите очень маленькое число наверх тогда пирамида нет вот
[01:23:30.960 --> 01:23:41.600]  и все еще вопросы так работает пирамидальная сортировка небольшое уточнение по поводу пирамида
[01:23:41.600 --> 01:23:54.480]  у вас есть такая задача как как приоритетная очередь давайте я немножко просто поговорю
[01:23:54.480 --> 01:24:00.360]  именно про приоритетную очередь скажу вообще что это такое приоритетная очередь представьте
[01:24:00.360 --> 01:24:06.360]  следующее я не знаю может кто-нибудь из вас когда-нибудь ходил в мпц может быть нет вот там
[01:24:06.360 --> 01:24:13.320]  такие талончики выбиваются вот и когда вам выбиваются всякие талончики у вас есть место в
[01:24:13.320 --> 01:24:19.320]  очередь вот представьте что аппарат сошел с ума и выдает какие-нибудь рандомные не знаю там числа
[01:24:19.320 --> 01:24:26.760]  вот просто ну вот вы там вам повезло у вас там первый не повезло там 99 и так далее а что
[01:24:26.760 --> 01:24:33.360]  такое приоритетная очередь приоритетная очередь это когда у вас есть грубо говоря пирамида
[01:24:33.360 --> 01:24:44.120]  который есть ключ по которому вы строите эту пирамиду то есть я как человек стою в очереди
[01:24:44.600 --> 01:24:50.080]  но меня ограничивают мой приоритет в виде вот этого ключа видит талончик который мне вот
[01:24:50.080 --> 01:24:59.880]  далее в мпц не знаю например вот или где-нибудь еще а просто с точки зрения вообще структуру
[01:24:59.880 --> 01:25:09.120]  данных приоритетная очередь это та же самая пирамида построенная по ключам все что вас просят
[01:25:09.240 --> 01:25:14.380]  задача про приоритетную очередь я это как раз таки просто построить пирамида sort steering
[01:25:14.380 --> 01:25:20.000]  там добавление элемента и удаление элемента к примеру или там изменение
[01:25:20.000 --> 01:25:25.960]  элементы в случае изменение приоритет он может изменяться вверх или вниз если он изменяется
[01:25:25.960 --> 01:25:32.860]  вверх то элемент стал вышен а к необходимо делать там fluent а если он изменяется вне
[01:25:32.860 --> 01:25:39.700]  севдаун то есть в зависимости от изменения приоритета вот это вот приоритет ну мало ли
[01:25:39.700 --> 01:25:47.940]  вот подошла ко мне женщина тетенька как раз это лончик вас неверный 899 номер там 17 вот исправила
[01:25:47.940 --> 01:25:57.860]  вот идите по идите под номером 17 тогда в этом случае я грубо говоря понижаюсь в очереди или
[01:25:58.140 --> 01:26:03.140]  вовísimo вот вместо того как я строю пирамиду по максиму или по минимуму если по и Kim then
[01:26:03.140 --> 01:26:08.560]  повышают то есть в зависимости от вот этих вот вещей вам необходимо построить embaixo приоритет
[01:26:08.560 --> 01:26:14.980]  мне очередь приоритетная очередь она просто заключена в этих ключа и все вы старает Studio
[01:26:14.980 --> 01:26:24.220]  пирамиду по этим ключа этого достаточно это и есть приоритетная очередь и она работает.
[01:26:24.220 --> 01:26:34.660]  По факту так. Есть ли вопросы к тому, что такое приоритетная очередь? Понятно ли я объяснил словами?
[01:26:34.660 --> 01:26:50.380]  В этом задании мне очень понятно, почему при команде 1, то есть вывести максимум, выводится 2-9.
[01:26:50.380 --> 01:27:00.940]  Давайте так, я скажу семинаристам, они с вами объяснятся, как это именно конкретно работает.
[01:27:00.940 --> 01:27:11.700]  Хорошо? Можете спросить, я это сделаю. Можно это определение приоритетного очереди,
[01:27:11.700 --> 01:27:16.940]  просто я отошел поесть и не успел. Но это плохо. Извиняюсь.
[01:27:16.940 --> 01:27:22.260]  Смотрите, если что, Миша, это спойлер, там выводится не 2-9 на одну единичку,
[01:27:22.260 --> 01:27:26.220]  там на несколько единичек так выводится. На каждую единичку одно число.
[01:27:26.220 --> 01:27:34.940]  Про приоритетную очередь. Приоритетная очередь, это просто когда у нас есть некий ключ,
[01:27:34.940 --> 01:27:40.820]  который является нашим приоритетом. И по этим ключам строится пирамида. Все.
[01:27:40.820 --> 01:27:41.980]  Спасибо.
[01:27:41.980 --> 01:27:48.140]  Остальное, что у нас есть в структуре, мы никак не используем, они просто есть у нас некий приоритет.
[01:27:48.140 --> 01:28:07.580]  Окей, давайте тогда перейдем к новой теме. И мы возвращаемся к нашим бинарным деревьям поиска.
[01:28:07.580 --> 01:28:12.340]  И сейчас у нас будет первое бинарное дерево поиска.
[01:28:12.340 --> 01:28:22.660]  И мы возвращаемся к сбалансированным. Мы уже говорим о сбалансированных.
[01:28:22.660 --> 01:28:44.100]  Сбалансированные бинарные деревья поиска.
[01:28:44.100 --> 01:28:48.220]  И первое дерево, с которым мы сегодня познакомимся, второе мы скорее всего не успеем,
[01:28:49.100 --> 01:28:53.740]  это АВЛ-дерево.
[01:28:53.740 --> 01:29:03.220]  Для того, чтобы говорить о сбалансированности, здесь необходимо кое-что понимать,
[01:29:03.220 --> 01:29:10.140]  что сбалансированность иногда говорится по-разному, что подразумевается под сбалансированностью.
[01:29:10.140 --> 01:29:16.940]  На всякий случай, АВЛ-дерево названо по фамилиям ученых, которые его открыли,
[01:29:16.980 --> 01:29:26.620]  программистов. Это были советские ученые, поэтому можно писать это на русском. АВЛ это тоже будет
[01:29:26.620 --> 01:29:38.300]  корректно. То есть никакого внутри такого смысла, почему АВЛ нет. Что касается АВЛ-дерево?
[01:29:38.300 --> 01:29:42.260]  А здесь подразумевается сбалансированность в следующем смысле.
[01:29:42.260 --> 01:30:10.740]  АВЛ-дерево сбалансировано в следующем смысле.
[01:30:10.740 --> 01:30:27.860]  В следующем смысле. Для любого узла дерева,
[01:30:27.860 --> 01:30:56.380]  высота его правого под дерево отличается от высоты
[01:30:58.860 --> 01:31:18.860]  левого под дерево не более чем на единицу. То есть смотрите, у нас же в бинарных деревьях
[01:31:18.860 --> 01:31:24.620]  как у нас есть левое и правое под дерево, и нам необходимо так, чтобы они были примерно одинаковые.
[01:31:24.620 --> 01:31:32.460]  Сбалансированность в таком смысле нам позволит следующее, что высота нашего дерева будет не
[01:31:32.460 --> 01:31:39.500]  более чем логарифм. То есть мы сможем делать все эти операции, которые мы делали с вами с
[01:31:39.500 --> 01:31:45.220]  бинарными деревьями за логарифм, благодаря сбалансированности в случае АВЛ-дерево.
[01:31:45.220 --> 01:31:52.900]  Для того, чтобы доказать вообще, что у нас АВЛ-деревья такие хорошие, такие классные,
[01:31:52.900 --> 01:32:00.300]  давайте введем некоторые еще понятия. А вот если у нас одно из деревьев пустое,
[01:32:00.300 --> 01:32:03.340]  то его высота минус один? Ну, из одной из под деревьев.
[01:32:03.340 --> 01:32:10.740]  Вот смотрите, в этом смысле, наверное, я был неправ, когда вводил вам с точки зрения высот.
[01:32:10.740 --> 01:32:23.980]  По сути, своя, да? Вот, если мы будем брать тот смысл, который есть, который предполагается
[01:32:23.980 --> 01:32:32.220]  здесь. Поэтому давайте договоримся, ну, прошу прощения, что я так сделал. Высота,
[01:32:32.220 --> 01:32:43.140]  это количество вершин для АВЛ-дерево. Кстати, в контесте задача про высоту
[01:32:43.140 --> 01:32:46.980]  подразумевает именно путь. Да, здесь смотрите, количество,
[01:32:46.980 --> 01:32:55.700]  высота в АВЛ-дереве. Давайте договоримся. Количество вершин на простом пути,
[01:32:55.700 --> 01:33:07.140]  простом и нисходящем пути. А разве не количество вершин?
[01:33:07.140 --> 01:33:16.100]  Смотрите, я именно поэтому здесь делаю уточнение для вас, что мы будем говорить здесь в АВЛ-дереве
[01:33:16.100 --> 01:33:20.980]  немножко по-другому. Прошу прощения за то, что так сделал.
[01:33:20.980 --> 01:33:30.820]  По факту, с точки зрения реализации, будет без разницы, если вы будете просто
[01:33:30.820 --> 01:33:36.980]  минус 1, грубо говоря. В этом не будет ничего страшного. Просто вы будете предполагать,
[01:33:36.980 --> 01:33:43.540]  что в пустых деревьях там минус 1, например, высота. Ну и так далее. Нисходящего пути.
[01:33:43.540 --> 01:33:51.420]  Поэтому, чтобы внести какую-то конкретику, здесь сделаем такую высоту. Я подумаю,
[01:33:51.420 --> 01:33:57.020]  что с этим делать. Я вам скажу на следующей лекции, как правило, мы ведем все хорошо.
[01:33:57.020 --> 01:34:01.780]  Если что, мы что-то поменяем. Но в контесте не будет ничего меняться. Вы можете там просто
[01:34:01.780 --> 01:34:11.620]  минус 1 сделать с высоты. А на простом нисходящем пути от узла к листу.
[01:34:13.540 --> 01:34:26.780]  Тут максимальное количество вышло. Это то, что касается АВЛ-дерева. Для того,
[01:34:26.780 --> 01:34:33.180]  чтобы у нас АВЛ-дерево было корректно, докажем вообще, что оно будет плюс-минус корректно.
[01:34:33.180 --> 01:34:37.060]  В таком случае, когда мы говорим о сбалансированности наших деревьев.
[01:34:37.060 --> 01:34:56.540]  Давайте ведем некоторые понятия. Высота в узле, мы уже с вами говорили,
[01:34:56.540 --> 01:35:11.660]  что это высота его под деревом. Мы говорим о том, что высота в нашем любом узле,
[01:35:11.660 --> 01:35:20.260]  это высота, которая у него достигается. Если его взять корнем, то вниз идти до листов выбрать
[01:35:20.260 --> 01:35:27.580]  максимальный, это будет и высота. Что касается еще некоторых определений. Еще одно определение,
[01:35:27.580 --> 01:35:37.300]  которое нам понадобится. Это так называемый баланс-фактор. Мы его назовем b-фактор,
[01:35:37.300 --> 01:36:03.140]  б-фактор. Он сам по себе равен от какого-то узла х, он равен высоте его правого под дерево,
[01:36:03.140 --> 01:36:18.860]  к примеру, минус высота его левого под деревом. Понятно? Мы ведем вот этот фактор. Если он,
[01:36:18.860 --> 01:36:27.500]  грубо говоря, меньше единицы по модулю, то в этом случае мы говорим о том, что у нас этот фактор
[01:36:27.500 --> 01:36:34.740]  выполнен для wl-деревы. В этом случае у нас wl-дерево является сбалансированным в том смысле,
[01:36:34.740 --> 01:36:48.020]  в котором оно предполагается. Мы вводим такую величину. У нас есть такой вот фактор дерева.
[01:36:48.020 --> 01:37:01.140]  Wl-дерево — это как раз то, что нам необходимо. Теперь такая штука, что утверждение,
[01:37:01.140 --> 01:37:31.020]  утверждение. Минимальная число вершин в wl-дереве. Глубины, глубины, то есть высоты, давайте,
[01:37:31.020 --> 01:37:53.580]  высоты h являются n от h равное число фибоначи от n плюс 2 минус 1.
[01:37:53.580 --> 01:38:19.220]  Здесь все достаточно просто. А здесь фибоначи задается с 0 единицей или единицей единицы?
[01:38:19.220 --> 01:38:32.580]  Здесь единицы. То есть смотрите, если мы берем, это доказывается по индукции. Есть база индукции,
[01:38:32.580 --> 01:38:43.100]  давайте сейчас сделаем это доказательством. База индукции. Если у меня n равно единичке,
[01:38:43.220 --> 01:39:03.500]  то в этом случае у меня оно равно как раз таки f от 3 минус 1. Это с точки зрения базы индукции.
[01:39:03.500 --> 01:39:16.980]  Если мы говорим о переходе, то мы говорим, что n к плюс 1 равно, если мы говорим с высоты
[01:39:16.980 --> 01:39:24.460]  и точки зрения добавления вершины. У меня было какое-нибудь дерево, давайте его нарисуем,
[01:39:24.460 --> 01:39:31.900]  вот такое дерево. У меня вот здесь вот, и вот здесь вот, там есть какие-то у него поддеревья.
[01:39:31.900 --> 01:39:39.820]  Здесь вот высота у меня будет k плюс 1. Если я говорю, что у меня это avl дерево с минимальным
[01:39:39.820 --> 01:39:47.340]  числом вершин, то в одном из поддеревьев я могу сказать, что у него в одном будет k,
[01:39:47.340 --> 01:39:54.380]  но это логично, потому что я добавил одну вершину, иначе бы не было. А если это минимальное
[01:39:54.380 --> 01:39:58.460]  количество вершин, то мы постараемся сделать здесь по минимуму, так как это avl дерево,
[01:39:58.460 --> 01:40:04.900]  то у нас разница должна быть не более единицы, поэтому k минус 1. То есть n от k плюс 1 равно
[01:40:04.900 --> 01:40:17.100]  n от k плюс n от k минус 1 и плюс 1, это сама вершина, у нас добавляет. То есть если мы берем
[01:40:17.100 --> 01:40:22.460]  количество вершин, а здесь уже высоты, мы как бы знаем. Тогда в этом случае мы говорим, что это
[01:40:22.460 --> 01:40:35.380]  1 плюс фибоначевое число от k плюс 2 плюс фибоначевое число от k плюс 1. Ну то есть я добавил подводчик.
[01:40:35.380 --> 01:40:47.620]  Тогда я получаю, что у меня это равно, ну здесь сумма двух чисел фибоначи, тогда это получается,
[01:40:47.620 --> 01:40:54.220]  а естественно я забыл, да, я забыл по минус единицы, я же предположение индукции сделал,
[01:40:54.220 --> 01:41:02.700]  что у меня фибоначи минус 1. Тогда я получаю здесь, что у меня это f от k плюс 3 минус 1.
[01:41:02.700 --> 01:41:19.140]  Вот. Что касается, то есть мы когда посчитали количество элементов, все круто и классно. Что
[01:41:19.140 --> 01:41:25.580]  это означает вообще для нас? Это означает следующее, что если мы ограничиваем число вершин числом
[01:41:25.580 --> 01:41:35.780]  фибоначи, число фибоначи считается как, как бы это сказать, ну я думаю может кто-то из вас
[01:41:35.780 --> 01:41:42.620]  видел формулу числа фибоначи, это 1 плюс корень из 5 делить там на корень на 2, там вот это в степени n,
[01:41:42.620 --> 01:41:49.780]  минус там 1 минус корень из 5 в степени n делить на корень на 2. Вот. Исходя из этого мы можем
[01:41:49.780 --> 01:42:00.700]  сказать, что высота нашего дерева, высота нашего дерева, она будет аж там от n, она будет флагорифмическая,
[01:42:00.700 --> 01:42:19.460]  так как мы ограничим, ограничим наши вещи. Вот. То есть там если посчитать в действительности,
[01:42:19.700 --> 01:42:35.460]  ну как это считается? Давайте так. Это считается просто следующим образом, что ну там n больше
[01:42:35.460 --> 01:42:43.860]  либо равно, чем n от h, h, да мы договорились, что h у нас большая буква, больше либо равно,
[01:42:43.860 --> 01:43:00.660]  чем n от h, там равное число этому фибоначи от h плюс там 2 минус 1. Вот. От h плюс 1.
[01:43:00.660 --> 01:43:13.940]  Число фибоначи, так как у нас там оно есть, оно, грубо говоря, там 1 плюс корень из 5 на 2 в степени n,
[01:43:13.940 --> 01:43:27.620]  минус там 1 минус корень из 5 в степени n, а тут n это h. Тогда если взять здесь,
[01:43:27.860 --> 01:43:40.900]  то мы получим, что у нас h это будет от некоторого флагорифма от h. Если мы возьмем и ограничим,
[01:43:40.900 --> 01:43:47.820]  то здесь будет вот из этого мы с вами получим, что у нас там флагорифм, n больше либо равен,
[01:43:47.820 --> 01:44:00.460]  чем h, плюс 2, к примеру. Вот. А если мы возьмем и добавим еще одну вершину, то мы с вами
[01:44:00.460 --> 01:44:08.500]  получим неравенство, которое ограничит сверху, и там получится как раз таки логарифм. Или непонятно,
[01:44:08.500 --> 01:44:18.980]  что происходит. Что еще раз написать? Ну вот вы сказали, если мы прибавляем еще одну вершину.
[01:44:18.980 --> 01:44:33.900]  Мы прибавили одну вершину. А где это мы прибавили? В смысле? Что подразумевается под прибавили? Я,
[01:44:34.900 --> 01:44:40.180]  наверное, не совсем поняла вас. Вы имеете в виду при переход индукции, что ли? Где k плюс 1, вот это?
[01:44:40.180 --> 01:44:54.660]  Смотрите, если мы прибавили вершину, то да, вот здесь. Смотрите, мы ограничили h вот здесь,
[01:44:54.660 --> 01:45:03.340]  вот исходя из этой формы. Вот она, ограничение. То есть h меньше либо равно, чем логарифм.
[01:45:03.340 --> 01:45:16.020]  Логарифм от n минус 2. Ну, значит, h это o большое от логарифма. Правда?
[01:45:16.020 --> 01:45:28.700]  Да. Все. Мы получили вот это. Вот. То есть мы доказали то, что в нашем овл-дереве,
[01:45:28.700 --> 01:45:38.340]  вот с таким вот свойством, будет наше дерево иметь всегда логарифмическую высоту. А если оно имеет
[01:45:38.340 --> 01:45:44.500]  логарифмическую высоту, все очень хорошо. Потому что тогда наши операции, работающие за оатаж,
[01:45:44.900 --> 01:45:54.420]  работают за от логарифма. Правильно? Стал понять, зачем мы вообще это делаем?
[01:45:54.420 --> 01:46:06.500]  Или не понятно? Понятно. Можно вопрос по определению? На предыдущем слайде было написано то,
[01:46:06.500 --> 01:46:12.980]  что простой нисходящий путь. Что значит простой путь? Простой в том, что мы через одну вершину
[01:46:13.220 --> 01:46:21.380]  не проходим несколько раз. Ага. Спасибо. Вот. Смотрите, как достигается балансировка
[01:46:21.380 --> 01:46:27.740]  как раз-таки в нашем дереве. Здесь все будет как раз-таки зависеть от нашего вот этого вот
[01:46:27.740 --> 01:46:38.660]  баланс-фактора. Какие возможны случаи? Представьте следующее. Вот у меня есть некоторые дерева.
[01:46:38.660 --> 01:46:48.660]  Вот здесь вот у меня вершина, не знаю, там П, к примеру. У него есть два подделия каких-то. Там А и
[01:46:48.660 --> 01:46:57.860]  Б. Правильно? Вот. В случае, если я добавлю сюда вот вершинку какую-то, ну вот обычным инсертом,
[01:46:57.860 --> 01:47:07.580]  мне необходимо сказать, что у меня изменится как-то баланс-фактор. Правильно? Сбалансировка как-то по
[01:47:07.580 --> 01:47:18.980]  другому вся произойдет. Правильно? Ребята. Да. То есть, смотрите, у нас здесь высота может
[01:47:18.980 --> 01:47:25.540]  измениться. Если она изменится, то нам необходимо перебалансировать дерево, потому что правая его
[01:47:25.540 --> 01:47:32.060]  часть стала слишком тяжелой в отличие от левой. Значит, там необходимо что-то передвинуть. Вот. И
[01:47:32.060 --> 01:47:47.420]  тогда в этом случае существует так называемый поворот. Прошу прощения. Вот. Стоит так называемый
[01:47:47.420 --> 01:47:56.100]  поворот. Стоит левый и правый поворот. Представьте следующую картину. Вот. Сейчас я тут
[01:47:56.580 --> 01:48:09.780]  нарисую чуть более подробно. Пусть у меня есть некоторая вершина. Вот здесь вот, не знаю там,
[01:48:09.780 --> 01:48:21.260]  как раз таки П. Вот здесь вот у него есть поддерево А. У П есть слева Y. Нет, давайте Q. Скажем,
[01:48:21.260 --> 01:48:33.380]  что это Q. У них лежат там X и Y. Здесь у меня там B поддерево. Здесь у меня там поддерево C.
[01:48:33.380 --> 01:48:44.180]  Вот. Я хочу сказать следующее, что у меня вот здесь вот пусть у меня разбалансировка происходит,
[01:48:44.180 --> 01:48:49.060]  так как мы добавляем одну вершину или там удаляем одну вершину. Мы поговорим об этом чуть попозже.
[01:48:49.060 --> 01:48:55.100]  У меня происходит на плюс-минус единицу. То есть у меня будет баланс-фактор отличаться от единицы
[01:48:55.100 --> 01:49:04.180]  по модулю. Не сильно. Вот. То есть это будет два. Если я скажу, что у меня в левом поддереве будет,
[01:49:04.180 --> 01:49:21.340]  грубо говоря, высота там h-3. Вот. Вот в этом дереве, к примеру, тоже h-3 или h-2.
[01:49:21.340 --> 01:49:41.700]  Плохо видно. Прошу прощения. Сейчас. h-2 либо h-3. Вот. А в этом дереве h-2. Вот. Высота тогда
[01:49:41.700 --> 01:49:50.340]  вот этого поддерева и его правого равна h-1. Ну, потому что у меня здесь h-2. Добавил еще одну
[01:49:50.340 --> 01:50:00.380]  вершину. Получил h-1. Вот. Тогда баланс-фактор. Вот этот вот для вершины p баланс-фактор.
[01:50:00.380 --> 01:50:14.220]  Чему равен? Скажи, пожалуйста, Владислав. Вот как ты думаешь? Вершины p? Да. Получается
[01:50:14.220 --> 01:50:25.940]  минус два. Почему минус два? Мы вычитаем из какого? Какого? А, значит, два. Из правого. Мы говорим
[01:50:25.940 --> 01:50:29.940]  о том, что мы вычитаем из правого левого. Ну, кто-то говорит из левого правого. Здесь как бы
[01:50:29.940 --> 01:50:41.620]  без разницы. Вот. В этом случае у нас баланс-фактор равен два. А вот для баланс-фактора у, когда вот
[01:50:41.620 --> 01:50:49.580]  мы добавили, у него, ну, точнее у q, у q баланс-фактор так и остался плюс-минус один. Правильно? Когда мы
[01:50:49.580 --> 01:50:54.500]  добавили там какую-нибудь вершину, например. Если мы добавили и у нас получилось вот то,
[01:50:54.500 --> 01:50:59.980]  что у нас с правым там по дереве, все так хорошо. То есть у нас здесь баланс-фактор равен два,
[01:50:59.980 --> 01:51:16.660]  а и баланс-фактор от q равен либо 0, либо 1. Один из этих случаев. Смотрите, дерево у нас не
[01:51:16.660 --> 01:51:24.380]  сбалансировано. И оно имеет такой перевес на правую сторону. Что было бы классно сделать? Как
[01:51:24.460 --> 01:51:31.380]  вы думаете? Ну, вот давайте я кого-нибудь спрошу. Вот София Труфана. Вот как ты думаешь,
[01:51:31.380 --> 01:51:36.620]  что можно сделать здесь такого, не сильно меняя само дерево, чтобы у нас что-то получилось?
[01:51:36.620 --> 01:51:45.180]  Сделать корнем y или q, она называется q. Да, то есть смотрите, действительно,
[01:51:45.180 --> 01:51:49.580]  да, спасибо большое. Это правильно. То есть если мы возьмем здесь и сделаем,
[01:51:49.580 --> 01:52:00.220]  к примеру, корнем q, то у нас с вами все получится. То есть мы возьмем и перебалансируем это дерево.
[01:52:00.220 --> 01:52:11.540]  То есть мы его переведем в дерево такое, что у меня здесь будет q с y. А вот теперь вопрос,
[01:52:11.540 --> 01:52:24.620]  где должен стоять q? Давайте я спрошу, спрошу Антон. Антон меня не слышит, поэтому я прошу пан.
[01:52:24.620 --> 01:52:37.500]  Антон, хорошо? Я или Антон? Ну, q в левой части. В левой части, вот здесь у меня будет стоять q. А теперь
[01:52:37.500 --> 01:52:48.260]  вопрос, что будет с новьями у п? А. А еще? Ну, все. Все. А теперь вопрос. Смотрите,
[01:52:48.260 --> 01:52:57.860]  помните, мы с вами опускали на нашу, грубо говоря... Разве не b? Разве b не должно прийти от q?
[01:52:57.860 --> 01:53:05.260]  А, оно же должно к чему-то крепиться, находится как раз между q и p. Да, то есть смотрите, помните,
[01:53:05.340 --> 01:53:10.340]  мы с вами опускали на числовую прямую. Вот здесь, вот если мы опустим, у нас здесь будет a,
[01:53:10.340 --> 01:53:23.220]  здесь будет p, здесь будет b, здесь будет q, а здесь будет c. То есть, грубо говоря,
[01:53:23.220 --> 01:53:34.260]  мы можем сказать a меньше p, меньше b, меньше q, меньше c. Поэтому здесь, когда мы делаем,
[01:53:34.260 --> 01:53:41.580]  мы в q не можем сделать левого сцена. Мы делаем в p правого сцена, вот здесь. Вот мы делаем здесь
[01:53:41.580 --> 01:53:52.620]  b при такой балансировке. И у q мы оставляем в этом случае c. Можно еще раз мы какую балансировку
[01:53:52.620 --> 01:53:59.340]  делаем, чтобы чего добиться? Чтобы добиться того, чтобы у нас фактор от корня был единичка.
[01:53:59.340 --> 01:54:11.860]  А здесь разве не было такого же? Смотрите, у нас для b не было. Теперь давайте с вами посчитаем,
[01:54:11.860 --> 01:54:20.700]  вообще, что у нас произошло. Для a у нас была высота h-3, для b у нас была высота либо h-2,
[01:54:20.700 --> 01:54:32.940]  либо h-3. То есть, в худшем случае у нас в p лежит высота либо h-1, либо h-2. Мы в p добавили.
[01:54:32.940 --> 01:54:43.700]  В c у нас высота h-2. Видите, мы вернули наш баланс-фактор к исходному, к вот этой вот
[01:54:43.700 --> 01:54:50.780]  самой плюс-минус единичке или нулю. Таким вот поворотом. То есть, нам необходимо перецепить
[01:54:50.780 --> 01:54:59.900]  вот это вот под дерево b и взять и повернуть все это дерево. Это называется левый поворот.
[01:54:59.900 --> 01:55:26.300]  Давайте я сделаю вот здесь оголовок. Вот, то есть, здесь у нас не сломаются условия того,
[01:55:26.300 --> 01:55:33.900]  что... Это же димбинарное дерево поиска? Да. А от этого не станет то, что мы перекинули b,
[01:55:33.900 --> 01:55:43.220]  а оно ведь должно быть... Но оно там не стояло. Еще раз, b оно стояло справа к у. Правильно? То есть,
[01:55:43.220 --> 01:55:50.980]  оно было все больше это под дерево. Нет, все меньше. Ой, все меньше, да. Извините. Да, все меньше.
[01:55:50.980 --> 01:56:01.700]  Если оно находится слева к у, то оно все равно все меньше. Все правильно. Есть ли еще вопросы к
[01:56:01.700 --> 01:56:09.260]  тому, как мы взяли и развернулись здесь? Да, почему мы именно b меняем? Чего еще раз? Почему мы
[01:56:09.260 --> 01:56:18.100]  именно b меняем? По дереву b? А что мы еще можем поменять? Вот смотрите, мы спроецировали это на
[01:56:18.100 --> 01:56:25.340]  вот такую вот ось. У нас а меньше, п меньше, q меньше, c меньше. q мы подцепить не можем,
[01:56:25.340 --> 01:56:39.140]  потому что у него уже сын b. Правильно? У q левый сын это p. Так, но b-то должно стоять между p и q?
[01:56:39.140 --> 01:56:48.420]  Ну, значит, где оно должно стоять? В правом сыне p. То есть, оно больше, чем p, но меньше,
[01:56:48.420 --> 01:57:06.060]  чем q. Еще есть вопросы? Нет. Хорошо. Мы получили с вами левую такую вот операцию. Теперь правая
[01:57:06.060 --> 01:57:23.980]  операция. В каком случае, что происходит? Представьте следующее. Это по факту, если бы у нас вот
[01:57:23.980 --> 01:57:41.780]  здесь стояла бы наша вершина q, у него были a, было b, а здесь было бы c. И вот оно бы разбалансировалось
[01:57:41.780 --> 01:58:04.220]  другую сторону. Вот этот вот фактор балансировки от p был бы равен минус 2 уже, а фактор балансировки q
[01:58:04.220 --> 01:58:12.900]  был бы равен 0 или минус 1. То есть, a и b по факту с теми же высотами. Почти что да.
[01:58:12.900 --> 01:58:39.060]  Понятно, что я говорю или нет? Да что ж такое-то у меня сегодня со Стивусом. Смотрите, в этом случае,
[01:58:39.060 --> 01:58:47.220]  когда у нас вот есть такая вот штука, то есть, если здесь минус 2, то у нас аналогично тому,
[01:58:47.220 --> 01:58:52.260]  что у нас с вами уже и было. То есть, мы говорим, что вот здесь вот высота у нас там, к примеру,
[01:58:52.260 --> 01:59:02.780]  h минус 3, вот здесь вот там у b это h минус 2 или h минус 3, к примеру, а вот здесь вот высота там h
[01:59:03.300 --> 01:59:16.180]  минус 2. Случай аналогичный, только нам теперь надо q сделать нашим верхним, нашим корнем. Тогда
[01:59:16.180 --> 01:59:20.780]  в этом случае мы должны взять и переделать это следующим образом. Здесь у нас будет q,
[01:59:20.780 --> 01:59:33.500]  здесь у нас останется a, здесь у нас уже будет p, вот здесь у нас будет b, а здесь будет нашу цепь.
[01:59:33.500 --> 01:59:45.980]  Прям точно симметричное это получается. Да, это абсолютно симметричное действие. Левый поворот и
[01:59:45.980 --> 02:00:00.820]  правый поворот. Понятно? Мы применяем поворот после добавления какого-то листа нового. Мы
[02:00:00.820 --> 02:00:05.060]  применяем повороты в случае балансировки. Балансировка может быть при удалении или при
[02:00:05.060 --> 02:00:11.300]  добавлении элементов. Мы сейчас рассматриваем в случае, что вообще возможно получить, то есть,
[02:00:11.420 --> 02:00:16.380]  что такое разбалансированность в нашем случае. Так как мы меняем один элемент, у нас вот этот
[02:00:16.380 --> 02:00:23.580]  фактор может увеличиться, уменьшиться на единичку. Если он равен минус 1, 0, 1, нас вполне это устраивает.
[02:00:23.580 --> 02:00:29.660]  Вл дерева это и нужно. Если он равен минус 2 или 2, то в этом случае нам необходимо перебалансировать
[02:00:29.660 --> 02:00:40.900]  дерево. И вот здесь вот я беру и разворачиваю это уже наоборот. Ясно? То есть это называется
[02:00:40.900 --> 02:00:45.900]  правый поворот. Где-то это называется малый правый поворот, где-то это просто правый поворот.
[02:00:45.900 --> 02:00:55.940]  Потому что сейчас у нас появится большой. Представьте следующую картину. Здесь у нас станет уже чуть-чуть
[02:00:55.940 --> 02:01:23.300]  побольше. Следующую картину. Пусть у меня фактор от P равен 2. Фактор
[02:01:25.940 --> 02:01:37.140]  от Q равен минус 1. То есть смотрите, мы с вами рассмотрели здесь случай, что произойдет,
[02:01:37.140 --> 02:01:44.700]  если у нас здесь изменится фактор вот именно таким вот образом. Правильно? Но мы не рассмотрели,
[02:01:44.700 --> 02:01:50.020]  а что будет если минус 1? То есть оно вставится вот в этот кусок под дерево, который левее. Вот
[02:01:50.020 --> 02:01:58.020]  этот вот в B. В этом случае нам необходимо рассмотреть еще кое-какой вариант. То есть у нас в случае,
[02:01:58.020 --> 02:02:03.700]  когда 2, здесь минус 1. Давайте нарисуем сначала это дерево. Здесь рисовать очень полезно,
[02:02:03.700 --> 02:02:09.060]  тогда становится абсолютно все понятно. Вот у меня есть P, пусть у него какой-то ключ X. Вот у
[02:02:09.060 --> 02:02:15.780]  меня есть Q, у него ключ какой-нибудь Y. И вот я рассмотрю еще вот этот теперь кусок отдельно.
[02:02:15.780 --> 02:02:32.620]  Пусть у меня тут Z, но не знаю там PQL, например. У него есть первое под дерево. У P вот здесь вот
[02:02:32.620 --> 02:02:42.100]  тоже есть какое-то под дерево. У Z здесь есть какое-то под дерево C. Сейчас я их все назову D,
[02:02:42.100 --> 02:02:52.740]  A и B. Всего этого есть какие-то под деревья. Вот я говорю о том, что если у меня фактор равен
[02:02:52.740 --> 02:02:59.300]  минус 1, так как я вычитал из правого левого, то в левом у меня произошло вот этот вот дисбаланс.
[02:02:59.300 --> 02:03:05.260]  Что ж такое-то? Сегодня оно слишком чувствительное.
[02:03:05.260 --> 02:03:20.420]  Так, момент. Что я хочу видеть в этом случае? Я хочу видеть в этом случае
[02:03:20.860 --> 02:03:31.500]  Следующее. Пусть у меня вот здесь вот высота h-3. Так как у меня фактор равен 2, то у меня вот
[02:03:31.500 --> 02:03:39.020]  здесь вот будет h-3. Что ж такое-то? Прошу прощения. То вот здесь вот слева у меня будет высота h-3,
[02:03:39.020 --> 02:03:59.980]  а справа у меня будет высота этого всего. Какая? H-1. Если здесь высота h-1, давайте дальше
[02:03:59.980 --> 02:04:14.060]  раскидывать. Если у меня вот здесь вот D и B и C. Так как у меня фактор равен минус 1,
[02:04:14.060 --> 02:04:35.740]  вот здесь вот высота у меня какая? H-2. Нет. H-3. Смотрите, у нас в принципе это плюс-минус
[02:04:35.740 --> 02:04:41.900]  балансированное дерево. Если здесь высота h-3, то высота вот этих всех h-1. Мы это уже сказали.
[02:04:41.900 --> 02:04:48.860]  Если высота этого h-1, мы говорим, что у меня фактор q равен минус единичке. Отличаться они не
[02:04:48.860 --> 02:04:53.740]  могут друг от друга сильно. Иначе бы у меня здесь не было баланса фактора 2. Правильно?
[02:04:53.740 --> 02:05:08.420]  Высуждайте. Мы знаем, что фактор q это минус 1. Как мы получили, что h-3 высота D. Но мы знаем,
[02:05:08.420 --> 02:05:22.500]  что с q это h-1 высота. Без q здесь высота h-2 в каком-то из-под деревьев. Так как у меня баланс
[02:05:22.500 --> 02:05:35.420]  фактор. Вот здесь вот h-1. Надо понять как из них больше. Вот это у меня будет h-2. Потому что без q.
[02:05:35.420 --> 02:05:41.860]  Надо просто понять. Так как у меня баланс фактор говорит о том, что там минус, то есть получается,
[02:05:41.860 --> 02:05:48.860]  что вправо мне хватает относительно левого. Так как высота h-1, то влево у нас высота h-2. А так
[02:05:48.860 --> 02:05:58.660]  как вправо на 1 меньше, то h-3. Стало понятно? На 1 больше. Влево на 1 больше. А вправо на 1
[02:05:58.660 --> 02:06:13.460]  меньше. Мы с вами это получили. Все чудно. Чудно, круто, классно. Что-то реально сегодня что-то
[02:06:13.460 --> 02:06:25.140]  не то. Так, ладно. Вот это мы с вами получили. Все, что нам нужно... Сейчас момент я переподключу.
[02:06:25.140 --> 02:06:37.780]  Что-то я не могу уже писать дальше. Все, вроде бы сейчас стало получше. Ну и все,
[02:06:37.780 --> 02:06:43.020]  что нам нужно еще знать про высоту деревьев B и C, они точно меньше либо равны тем h-3.
[02:06:44.660 --> 02:06:54.500]  Ну что-то из них равно h-3. Правильно? Да что же это такое?
[02:06:55.140 --> 02:07:05.620]  Так, хорошо. Мы с вами это получили. Нет, это кошмар какой-то. Я не понимаю,
[02:07:05.620 --> 02:07:14.220]  что происходит с моментом. А если какой-то из них h-3, а второе либо h-3, либо h-2?
[02:07:14.220 --> 02:07:21.900]  Здесь нам не важен фактор Z. То есть мы знаем, что там AVL деревьев.
[02:07:21.900 --> 02:07:32.180]  Да, тогда вот уточнение для определения сбалансированного AVL дерева. Нам нужно,
[02:07:32.180 --> 02:07:38.660]  чтобы для каждого под дерево выполнялось такое или как-то в целом для дерева.
[02:07:38.660 --> 02:07:41.340]  Для карты, да? То есть получается,
[02:07:41.380 --> 02:07:51.060]  если какой-то из B и C имеет высоту h-3, то, например, одна из них имеет h-3, это обязательно,
[02:07:51.060 --> 02:07:58.500]  а вторая может быть вообще любой. H-4, h-3 или h-2. Одна из трех.
[02:07:58.500 --> 02:08:07.340]  Да, но тогда ведь если будет h-, например… Мы считаем, что это сбалансированная уже часть.
[02:08:07.340 --> 02:08:13.420]  Ага. Ну, она должна, когда… Ее высота должна отвечаться… А, нет, мы уже всё, я понял.
[02:08:13.420 --> 02:08:21.660]  Вот, окей. Тогда в этом случае… Смотрите, вы понимаете, что в этом случае нам левый поворот
[02:08:21.660 --> 02:08:35.060]  не спасает нас? Вот, ну никак. Или не понимаете? Смотрите, если мы возьмём и развернём здесь налево,
[02:08:35.060 --> 02:08:54.020]  ну вот был у нас левый поворот, правда? У нас был с вами левый поворот, вот этот вот.
[02:08:54.020 --> 02:09:02.700]  В этом левом повороте, что мы делали? Мы просто вот эту вершину Q перетаскивали наверх. Если в
[02:09:02.740 --> 02:09:08.380]  этом случае я перетащу вершину Q наверх, то в этом случае у меня будет слева высота h-2,
[02:09:08.380 --> 02:09:16.620]  здесь будет h-1, но будет ли это… Ну, типа получится ли у нас, что здесь у нас будет всё корректно?
[02:09:16.620 --> 02:09:27.620]  Не получится. Почему? Потому что когда мы вот эти вот вершины L, вот эту вот вершину L соединим
[02:09:27.620 --> 02:09:38.700]  с P, здесь станет высота у P h-1, а справа у Q вот эта вот D, вот эта вот D, которая вот здесь вот,
[02:09:38.700 --> 02:09:47.340]  у которой высота h-3. Тогда у нас с вами получается, что нету никакой сбалансированности, и у нас
[02:09:47.340 --> 02:09:55.220]  опять бы фактор сталавин 2. Для того, чтобы этого избежать, можно сделать достаточно простую вещь.
[02:09:55.340 --> 02:10:06.340]  Давайте с вами сделаем так, что мы вначале повернем направо, а потом повернем налево. То есть мы
[02:10:06.340 --> 02:10:13.180]  возьмем, развернем вот это вот L сюда, а потом то, что будет здесь, развернем сюда налево.
[02:10:15.460 --> 02:10:20.460]  Тогда в этом случае… Смотрите, что у меня произойдет тогда в этом случае. Вот это h-1
[02:10:20.460 --> 02:10:34.780]  сотру, напишу ниже. Тогда в этом случае я с вами получу что… Прошу прощения сейчас, момент.
[02:10:34.780 --> 02:10:48.260]  Тогда в этом случае я с вами получу следующее. После первого поворота, я здесь нарисую поменьше
[02:10:48.260 --> 02:11:01.660]  эти штучки. У меня будет вершина P, у нее будет уже сын L, а у сына L будет здесь B,
[02:11:01.660 --> 02:11:13.260]  ой, давайте так, у меня будет здесь Q, у Q будет вот здесь вот D, да, все правильно,
[02:11:13.740 --> 02:11:20.380]  вот здесь вот у меня будет B, я совершаю правый поворот пока мало. Здесь у меня… Не могу я
[02:11:20.380 --> 02:11:27.900]  вставить, поэтому я вставляю его Q, у меня вот здесь вот будет C, а здесь будет A.
[02:11:33.700 --> 02:11:38.340]  Я совершил правый поворот для вот этого левого поддерева.
[02:11:38.340 --> 02:11:52.420]  Тогда в этом случае я говорю о том, что… Тогда в этом случае я говорю о том, что у меня высота
[02:11:52.420 --> 02:12:03.460]  вот этого левого куска относительно L, вот этого, стала равна… Давайте сейчас черный возьму,
[02:12:03.460 --> 02:12:17.500]  вот у этого кусочка. Высота стала равна чему? H-2. Высота вот этого кусочка у меня либо H-3,
[02:12:17.500 --> 02:12:30.860]  либо H-2, да? А тогда вопрос, этот случай похож на вот этот? Он и является по факту вот этим
[02:12:30.860 --> 02:12:40.860]  левым поворотом. То есть вот здесь вот у меня слева H-3, либо H-2. Тогда я беру и здесь поворачиваю
[02:12:40.860 --> 02:12:51.940]  налево, налево, потому что вот этого все еще H-3. А вот здесь вот у этого большого куска, у левого,
[02:12:51.940 --> 02:13:00.220]  все также осталось H-1. Я его как бы повернул, но ничего сильно не изменилось, высота-то осталась
[02:13:00.220 --> 02:13:08.100]  одна и та же у дерева. Я просто перебалансировал его. Тогда в этом случае я с вами и получаю как раз
[02:13:08.100 --> 02:13:24.740]  то, что мне необходимо. И здесь я начинаю делать левый поворот. Тогда я получу следующее. Так как я
[02:13:24.740 --> 02:13:36.060]  делаю левый поворот, то у меня вот эта вершина L станет вот здесь. У нее здесь все также будет
[02:13:36.060 --> 02:13:51.580]  вершина P. У вершины P будет вот здесь под дерево A. Здесь будет под дерево B. Здесь у нас станет Q
[02:13:51.580 --> 02:14:01.780]  с под деревом C и с под деревом D. И тогда я с вами получил сбалансированный такой кусочек.
[02:14:01.780 --> 02:14:14.060]  Фактор P минус 1, да, получится? Плюс один. Вот правый минус слева. Смотрите,
[02:14:14.060 --> 02:14:20.220]  справа у нас будет высота H-2, а слева высота будет какая? Тоже H-2.
[02:14:20.220 --> 02:14:34.980]  Либо H-1. Поэтому будет либо 0, либо минус 1 у нас бы фактор. Понятно, как это получилось. То есть
[02:14:34.980 --> 02:14:42.140]  мы просто развернули сначала один кусочек, потом еще один кусочек. Есть ли вопрос, как это вышло?
[02:14:42.140 --> 02:14:51.340]  Можно еще раз коротко посмотреть, пожалуйста? Еще раз. Нам сначала нужно перебалансировать кусок
[02:14:51.340 --> 02:14:57.660]  следующий. Нам необходимо перебалансировать, давайте возьму розовый. Вот этот вот кусочек нам
[02:14:57.660 --> 02:15:05.060]  нужно перебалансировать для того, чтобы свести к левому повороту, который у нас и должен быть
[02:15:05.060 --> 02:15:10.780]  здесь. Для того, чтобы его перебалансировать, мы повернем его направо. Если мы повернем его
[02:15:10.780 --> 02:15:16.620]  направо, мы получим именно тот случай, который нам подходит для левого поворота. После этого я
[02:15:16.620 --> 02:15:33.300]  беру и делаю левый поворот. Понятно? Кратко это звучит так. Есть ли вопросы?
[02:15:40.780 --> 02:15:55.580]  Друзья? Нет? Нет. Хорошо. У нас с вами осталась еще одна штука. Эта вот вещь называется на самом деле
[02:15:55.580 --> 02:16:06.260]  большой левый поворот. Сейчас напишу. Остался большой правый? Остался большой правый. Все
[02:16:06.260 --> 02:16:18.980]  правильно. Он симметричный. Называется большой левый поворот. Смотрите, конкретно его делать
[02:16:18.980 --> 02:16:30.700]  особо... отдельно я имею в виду. Делать его смысла нету. Конкретно его. Почему? Потому что
[02:16:30.940 --> 02:16:36.820]  он складывается из двух поворотов по факту. Из левого поворота? Да что ж такое-то?
[02:16:36.820 --> 02:16:58.940]  Не нужно. Папе с доски. Плохо делается. Вот все. Вроде все стало нормально. А нет, не стало.
[02:17:01.220 --> 02:17:12.620]  Вот теперь все хорошо. Вот это то, что касается вот этого поворота. Теперь нам остался один
[02:17:12.620 --> 02:17:17.620]  последний поворот, который нам необходим. Он называется большим правым поворотом. И он
[02:17:17.620 --> 02:17:24.940]  аналогичен тому ровно, что мы с вами делали. Мы просто говорим, что в этом случае у нас б-фактор
[02:17:24.940 --> 02:17:51.180]  от p равен минус 2, а б-фактор от q у нас равен 1. То есть это по факту те самые случаи,
[02:17:51.180 --> 02:17:59.940]  которые мы с вами недорассмотрели в нашем варианте, который был до этого. То есть смотрите,
[02:17:59.940 --> 02:18:04.700]  вот здесь вот, когда мы с вами рассматривали правый поворот, у нас был б-фактор минус 2.
[02:18:04.700 --> 02:18:14.100]  Но б-фактор q был 0 или минус 1. Теперь нам необходимо его переделать в то, чтобы у нас был
[02:18:14.100 --> 02:18:21.700]  б-фактор как раз таки 1. То есть это возможный случай, когда мы добавили вершину, например,
[02:18:21.700 --> 02:18:29.660]  или там удалили. Возможный случай. Тогда нам необходимо взять что-то переделать. Для этого мы
[02:18:29.660 --> 02:18:36.940]  с вами как раз таки и описываем наш правый поворот. Большой правый поворот. Он делается
[02:18:36.940 --> 02:18:45.420]  симметрично. То есть у нас здесь есть вершина p, здесь у нас есть под дерево d, здесь у нас там
[02:18:45.420 --> 02:19:03.540]  есть вершина q, у нее вот здесь вот вершина z. Нет, вершина l. У него здесь b, здесь c, здесь a. Я
[02:19:03.660 --> 02:19:11.860]  его хочу развернуть так, чтобы у меня было. Да что ж такое? У меня здесь было. А у нас
[02:19:11.860 --> 02:19:26.140]  вроде бы фактор p должен быть минус 2. Так, а почему? А, да, да, извиняюсь. Фактор p, да,
[02:19:26.140 --> 02:19:30.820]  действительно, да, минус 2. Да, все правильно. То есть случай аналогичный, симметричный,
[02:19:30.820 --> 02:19:47.420]  потому что у нас с вами было. Вот, тогда в этом случае мы... Так, сейчас, момент. У меня тут
[02:19:47.420 --> 02:19:55.020]  с этим стилусом проблемы. Тогда в этом случае нам необходимо взять и просто...
[02:19:55.020 --> 02:20:20.620]  Сейчас давайте я кое-что сделаю. Нет, ему прям явно не нравится то, что я делаю. Так,
[02:20:20.980 --> 02:20:26.220]  постараюсь, чтобы написать. Тогда в этом случае мы хотим повелчить здесь вершину l,
[02:20:26.220 --> 02:20:36.220]  здесь мы хотим с вами получить одну вершину, а здесь там вторую вершину. Вот здесь вот у меня
[02:20:36.220 --> 02:20:46.380]  будет p, вот здесь вот у меня будет q, здесь у меня будет под дерево a, вот здесь под дерево b,
[02:20:46.380 --> 02:20:57.540]  вот здесь под дерево c, и здесь под дерево d. Это называется большой правый поворот. То есть
[02:20:57.540 --> 02:21:06.380]  он симметричен тому случаю, который был. То есть он сложится из... Из каких поворотов? Из поворота
[02:21:06.380 --> 02:21:18.300]  левого, а потом сюда правого, да? Вот, то есть он складывается из таких вот вещей. Это
[02:21:18.300 --> 02:21:40.860]  называется большой правый поворот. Big right rotate, извините. То есть он складывается из левого
[02:21:40.860 --> 02:21:56.020]  поворота, плюс правого поворота. Таким вот образом мы с вами получаем вот такие вот штуки,
[02:21:56.020 --> 02:22:05.860]  которые нам и понадобятся в задании. То есть таким вот образом мы можем сбалансировать наше
[02:22:06.420 --> 02:22:17.860]  овель дерево. Что касается того, как это пишется. Если у вас вопрос по тому, как это переписать,
[02:22:17.860 --> 02:22:21.500]  то смотрите, здесь просто происходит переподвешивание некоторые, которые нам
[02:22:21.500 --> 02:22:32.380]  необходимы. Вот, и в общем виде, грубо говоря, если взять здесь и реализовать тот же rotate.
[02:22:32.380 --> 02:22:46.420]  Right, например, правый поворот, куда я передаю вершину p, указатель на эту вершину. То есть это
[02:22:46.420 --> 02:23:03.820]  правый поворот вокруг. Если мы смотрим этот правый поворот, то он будет выглядеть следующим
[02:23:03.820 --> 02:23:21.580]  образом. Что мы делаем? Мы говорим, что у нас вершина q, это есть левый цин. Да что ж такое-то?
[02:23:21.580 --> 02:23:38.020]  Сейчас если он сейчас не заработает нормально, буду писать словами. Вот, мы говорим о том,
[02:23:38.020 --> 02:23:44.540]  что у нас q, это есть левый цин в нашем правом повороте. И теперь нам необходимо просто
[02:23:44.540 --> 02:23:55.700]  переподвесить наши какие-то вершинки. Тогда в этом случае мы говорим о том, что нам нужно сказать,
[02:23:55.700 --> 02:24:04.820]  что левый цин теперь у p, это есть правое под дерево q. Давайте если я точку иначе писать,
[02:24:04.820 --> 02:24:20.580]  то будем точкой. P left равно q, right. А правым сыном у q является теперь p. И все, что нужно
[02:24:20.580 --> 02:24:30.460]  сейчас еще дополнительно сделать, это... Нет, оно, видимо, не хочет работать самое большее.
[02:24:30.900 --> 02:24:42.820]  Я что-нибудь с этим придумал к следующей лекции. И все, что мне нужно к этому всему добавить,
[02:24:42.820 --> 02:24:51.500]  это то, что я должен скорректировать высоты. Высоты у своих под деревьев. Но для того,
[02:24:51.500 --> 02:24:56.860]  чтобы их скорректировать, мне необходимо написать какую-нибудь функцию по типу
[02:24:56.860 --> 02:25:04.540]  fix высоты. Что такое fix высоты? Он просто берет и говорит, что высота теперь моего нового
[02:25:04.540 --> 02:25:12.460]  дерева в высоте, так как мы меняем только p и q, в них высота изменяется и равна на высоте
[02:25:12.460 --> 02:25:18.420]  левого и правого под дерево плюс один. То есть для того, чтобы это у нас работало,
[02:25:18.420 --> 02:25:37.140]  мы с вами сделаем там функцию fix от вершины какой-нибудь, от любой ноды, например,
[02:25:37.140 --> 02:25:56.100]  x. Что оно делает? Оно возвращает следующее, что... Кто что говорить пытается? Понял. Понял,
[02:25:56.100 --> 02:26:19.900]  кто это был? Ладно. Тут, видимо, штуки запали. Да, конец не очень получается. Когда мы с вами будем...
[02:26:19.900 --> 02:26:28.020]  Давайте я просто напишу текст. Мне кажется, вам так легче будет на самом деле. Давайте текст черный.
[02:26:28.020 --> 02:26:40.900]  Здесь вот я напишу. Я хочу с вами реализовать вершины, реализовать некий rotate. Для этого я
[02:26:40.900 --> 02:26:56.220]  буду просто говорить, что у меня rotate, right rotate, правый поворот. Вот некоторые вершины q. Это
[02:26:56.220 --> 02:27:03.540]  указатель на нашу ноду. Мы говорим о том, что он у нас равен следующему, что мы говорим,
[02:27:03.540 --> 02:27:15.020]  что q это левый его сын. То есть q это у меня p.left. Это левый сын. Мы, видимо, передаем p все-таки.
[02:27:15.020 --> 02:27:26.140]  Ой, да, спасибо. Левый ее сын. Тогда в этом случае мы переподвешиваем наше дерево согласно тому,
[02:27:26.140 --> 02:27:30.780]  как у нас работает правый поворот. Мы сейчас к нему вернемся. Мы говорим, что q у нас равно...
[02:27:30.780 --> 02:27:43.660]  ой... p.left, левый сын теперь у p, равен q.right. То есть мы переподвешиваем то самое дерево.
[02:27:43.660 --> 02:27:57.100]  После этого мы делаем, что q.right равно... теперь нашему p. То есть теперь p стал правым сыном нашего q.
[02:27:57.100 --> 02:28:02.620]  Вот. Помимо этого, если у нас есть дерево, реализованное в виде структуры, то нам необходимо
[02:28:02.620 --> 02:28:07.660]  еще и корень, в случае чего, менять. Здесь немножко сложнее. Здесь нужно просто вам будет подумать,
[02:28:07.660 --> 02:28:17.900]  как это именно сделать. Вот. Чудесно. Мы с вами это получили. После чего нам необходимо просто
[02:28:17.900 --> 02:28:36.380]  пофиксить нашу длину. То есть вызвать там функцию fix высоты у узла p и fix высоты у узла q. Вот.
[02:28:36.380 --> 02:28:42.820]  И когда мы это сделали, это в принципе все. Что такое fix высоты? Давайте сначала разберемся,
[02:28:42.820 --> 02:28:47.980]  все ли понятно с правым поворотом. Если мы откроем вот здесь вот правый поворот. Вот он у
[02:28:47.980 --> 02:28:57.740]  меня был. Смотрите, я должен переподвесить b. Чуть-чуть мышкой порисую. Я должен переподвесить
[02:29:00.780 --> 02:29:10.380]  вот это вот b, которое у меня есть, а вот из q в p. В левого сына p. Вот я это ровно и делаю. Это все,
[02:29:10.420 --> 02:29:18.140]  что там делается. И то, что правый сын q теперь стал p. Я просто беру все и переподвешиваю. Вот оно все
[02:29:18.140 --> 02:29:25.260]  переподвесилось. Что такое fix высоты? То есть так как мы переподвесили деревья, нам необходимо
[02:29:25.260 --> 02:29:32.060]  взять и перепиксировать высоту. Для того, чтобы это произошло, нам необходимо сделать просто
[02:29:32.060 --> 02:29:46.740]  следующее fix q. Что у нас делает вот эта вот штука, что просто берет и возвращает высоту нового
[02:29:46.740 --> 02:29:55.220]  по дереву? Так как у нас a, b и c никак не менялись в нашем коде, то в этом случае у нас высота
[02:29:55.220 --> 02:30:08.460]  меняется просто следующим образом, что это... Давайте сделаем так. Высота правого...
[02:30:08.460 --> 02:30:31.580]  Пусть у нас есть высота правого, она равна q.right.h. То есть у нас в поле появилась высота. У каждого
[02:30:31.580 --> 02:30:48.980]  объекта, каждой ноды есть еще и высота. Под высотой ноды мы говорили о том, что такая высота
[02:30:48.980 --> 02:30:58.140]  узла. Вот высота узла это просто вот этот вот нисходящий путь, сколько в нем вершины. А высота
[02:30:58.140 --> 02:31:13.860]  left равна q.left. Высота. Вот, когда мы с вами это получили, мы говорим о том, что у нас q, высота,
[02:31:13.860 --> 02:31:25.380]  равна... Чему? Равна максимальному значению из этих двух высот плюс один.
[02:31:25.380 --> 02:31:44.180]  H left плюс один. Единственное, что надо понимать, что если мы вызываем вот так вот высоту,
[02:31:44.180 --> 02:31:49.660]  и это не функция, к примеру, если бы это была функция, то все нормально. А здесь у нас возможен
[02:31:50.660 --> 02:31:57.020]  на самом деле. Поэтому лучше всего это обернуть следующим образом, что у нас здесь будет высота
[02:31:57.020 --> 02:32:06.580]  вызываться как функция. Вот значение. И эта функция внутри проверяет. Если это nullptr,
[02:32:06.580 --> 02:32:18.860]  то возвращает ноль. Иначе просто высоту, которая у нас хранится в ноде самой. Понятно? Вот. Все.
[02:32:19.100 --> 02:32:25.900]  Мы с вами взяли, пофиксили всю высоту, все сделали. Это все, что нужно здесь сделать.
[02:32:25.900 --> 02:32:36.300]  Что касается левого поворота. Я думаю, для вас не секрет, как будет выглядеть левый поворот.
[02:32:36.300 --> 02:32:47.740]  Можно вопрос? Да. Еще раз, а почему изменили h right и h left? Кого изменили? Ну, там до этого было
[02:32:47.740 --> 02:32:58.420]  q.right. Мы изменили, потому что может быть правый или левый сын, он может быть нулевой nullptr.
[02:32:58.420 --> 02:33:07.100]  Да, и получается... От nullptr нельзя ничего взять. А если мы делаем как функцию, то эта
[02:33:07.100 --> 02:33:13.340]  функция проверит в себе внутри. Если это nullptr вернет ноль, иначе высоту. Да, спасибо.
[02:33:13.340 --> 02:33:19.140]  Что касается правого поворота. Правый поворот от вершины какой-нибудь p,
[02:33:19.140 --> 02:33:25.300]  он будет выглядеть аналогичный просто с точностью до перестановок. То есть мы говорим о том,
[02:33:25.300 --> 02:33:33.620]  что если у нас правый поворот, то что у нас q, это будет p.right.
[02:33:33.620 --> 02:33:57.740]  То, что у нас будет p.right, правый сын теперь у нас будет q.left, q.left равно p. Ну и дальше
[02:33:58.060 --> 02:34:05.260]  пофиксить высоту. Почему мы фиксируем высоту и у нас все хорошо с вами получается? Да все потому,
[02:34:05.260 --> 02:34:22.980]  что когда мы это с вами делаем, мы говорим о следующем, что у нас а, b и c, которые у нас были
[02:34:22.980 --> 02:34:30.060]  в левых и правых поворотах, они сами по себе уже внутри несут правильную информацию относительно
[02:34:30.060 --> 02:34:35.260]  высоты. А если не несут правильную информацию о высоте, то нам нужно обновить только f и q. Этого
[02:34:35.260 --> 02:34:43.060]  достаточно. Что касается вообще всей балансировки. Смотрите, большой правый поворот и большой левый
[02:34:43.060 --> 02:34:50.020]  поворот особого смысла описывать отдельно нет. Для того, чтобы его сделать, можно просто сделать
[02:34:50.020 --> 02:34:58.260]  следующее. Давайте сейчас напишем. Напишем, как выглядит вообще функция балансировки. И потом
[02:34:58.260 --> 02:35:04.380]  я в конце скажу, когда это вообще балансировка выглядит. Когда она вызывается. Если мы с вами
[02:35:04.380 --> 02:35:13.100]  вызываем балансировку относительно какой-то вершинки, пусть будет p, как у нас и было,
[02:35:13.220 --> 02:35:32.060]  то в этом случае мы говорим, что если у нас этот б-фактор от p будет равен 2. И если у нас наш
[02:35:32.060 --> 02:35:45.140]  б-фактор от правого под дерево, то есть смотрите, большой правый поворот происходит в каком случае,
[02:35:45.140 --> 02:35:50.700]  когда у нас там отрицательная штука появляется в б-факторе. То есть если у меня б-фактор от
[02:35:50.700 --> 02:36:12.180]  p-right будет меньше нуля, то в этом случае я говорю, что у меня p-right
[02:36:12.180 --> 02:36:27.380]  ровно. То есть его правый должен стать корнем. И вообще по-хорошему right rotate и left rotate должны
[02:36:27.380 --> 02:36:34.660]  возвращать как раз таки саму. Мы сейчас это допишем чуть-чуть попозже. Сначала допишу здесь. Просто
[02:36:34.660 --> 02:36:52.100]  здесь нельзя просто переключаться между текстом в зоны. Он равен right rotate от чего? От p-right. То
[02:36:52.100 --> 02:37:05.860]  есть мы делаем большой правый поворот. Ой, левый поворот, sorry. После чего, это левый поворот,
[02:37:05.860 --> 02:37:12.380]  да. После чего, если у нас не было бы этого б-фактора, то есть нам не нужен был бы большой левый поворот,
[02:37:12.380 --> 02:37:17.860]  обычный левый поворот, то в этом случае мы говорим, что мы берем и возвращаем здесь,
[02:37:17.860 --> 02:37:39.540]  к примеру. Right rotate возвращает p. То есть мы p изменили, он вернет p.
[02:37:47.860 --> 02:38:01.660]  Он возвращает наш корень. Хорошо, давайте так. А почему нельзя сделать функцию void,
[02:38:01.660 --> 02:38:15.700]  но передавать туда не указатель, а ссылку? Можно. Можно. Смотрите, здесь ваша реализация,
[02:38:15.700 --> 02:38:21.300]  как вы хотите сделать. Но все, что здесь нужно понять, что здесь в случае чего,
[02:38:21.300 --> 02:38:28.740]  я просто сейчас объясняю, как выглядит балансировка наша. В этом случае мы делаем
[02:38:28.740 --> 02:38:42.220]  rotate left от p. И в п получается, записываем rotate left. В этой реализации. В п записываем
[02:38:42.220 --> 02:38:50.900]  rotate left. Да, в принципе, можем. Можем сделать так, что это будет возвращать просто наш корень.
[02:38:50.900 --> 02:39:01.460]  Вот, то есть смотрите, с точки зрения балансировки, балансировка действительно работает так,
[02:39:01.460 --> 02:39:10.540]  что мы будем здесь хранить различные структуры такие. Что касается большого левого поворота,
[02:39:10.540 --> 02:39:16.380]  большой левый поворот будет происходить, ой, большой правый поворот, извините, большой правый
[02:39:16.380 --> 02:39:22.220]  поворот будет происходить аналогично, только просто у нас поменяется местами ратейт. Райт ратейт и
[02:39:22.220 --> 02:39:42.540]  левт ратейт. Это то, что касается овл дерева, в принципе. То есть смотрите, это происходит так.
[02:39:42.540 --> 02:39:47.580]  И последнее, что, так как, ну, я думаю, вы сможете дописать симметричный случай,
[02:39:47.580 --> 02:40:03.020]  это не очень сложно. Вот. Что касается вообще самой задачи постановки балансировки? В каком
[02:40:03.020 --> 02:40:09.980]  случае нам нужна балансировка? Это последнее, что я делаю и типа отпускаю вас, все, я понимаю,
[02:40:09.980 --> 02:40:17.900]  что вам уже сложно. Когда мы с вами взяли и вставили элемент, вот мы взяли и вставили куда-то
[02:40:17.900 --> 02:40:31.340]  элемент. Вот так, не знаю там. Вот у меня было такое бинарное дерево. Я вставил вот этот вот
[02:40:31.340 --> 02:40:41.780]  элемент. Мне нужно перебалансировать все его, всех его родителей. То есть для того, чтобы у меня был
[02:40:41.780 --> 02:40:48.340]  новый баланс, ну, то есть перебалансировать свое дерево, я должен взять и сбалансировать его
[02:40:48.340 --> 02:40:55.900]  родители, родители этого родителя и родители этого родителя. Короче, предков. Да. Всех предков
[02:40:55.900 --> 02:41:01.900]  необходимо взять и перебалансировать. Благодаря этому у нас обновится высота,
[02:41:01.900 --> 02:41:07.340]  во-первых, потому что мы, благодаря тому, что там есть различные ротейты и так далее, если они
[02:41:07.340 --> 02:41:13.740]  будут происходить, то мы будем обновлять высоту. Вот. И высоты тоже мы можем обновить при инсерте,
[02:41:13.740 --> 02:41:20.980]  к примеру, даже. Вот. И так далее. То есть нам необходимо обновить все у предков. Теперь вопрос,
[02:41:20.980 --> 02:41:27.460]  что происходит при удалении вершин? При удалении вершин, если мы удаляем лист или дерево,
[02:41:27.460 --> 02:41:33.580]  ой, лист или вершину, которая у нас там переподвешивается, ну, то есть у него один ребенок,
[02:41:33.580 --> 02:41:39.860]  я думаю, вы понимаете, что в этом случае нам необходимо просто запустить балансировку тоже
[02:41:39.860 --> 02:41:48.740]  от всех предков. Вот. Просто запускаем балансировку от всех предков, все получается. Что происходит,
[02:41:48.740 --> 02:42:04.100]  когда у нас это не лист и ни один у него ребенок? Тогда в этом случае нам нужно удалять здесь
[02:42:04.100 --> 02:42:12.780]  вершину, когда мы с вами, помните, ищем здесь там минимальный элемент. Если это лист, то мы
[02:42:12.780 --> 02:42:18.260]  просто должны перебалансировать вот здесь вот все. Ну, то есть нам бы фактор должен быть другой,
[02:42:18.260 --> 02:42:23.580]  потому что у нас иначе высоты могут быть другие. То есть здесь необходимо также пойти по всем
[02:42:23.580 --> 02:42:30.420]  предкам, когда мы первоначально, грубо говоря, удаляем эту вершину. То есть мы ее отцепляем,
[02:42:30.420 --> 02:42:36.300]  а потом мы берем и вставляем ее вот сюда, то есть перецепляем эту вершину сюда.
[02:42:36.300 --> 02:42:48.140]  С точки зрения высот у вас ничего не изменилось, потому что вы просто вставили эту вершину. Если вы
[02:42:48.140 --> 02:42:54.980]  вставили, вам необходимо только лишь в этой вершине взять и обновить высоту. Но перебалансировки
[02:42:54.980 --> 02:43:03.740]  здесь никакой не может быть. Все, что нужно сделать из перебалансировок, это только опять пройтись
[02:43:03.740 --> 02:43:10.580]  вот по этим родителям в случае, когда вы взяли и удалили отсюда этот кусочек. Понятно?
[02:43:12.940 --> 02:43:19.540]  То есть все равно у нас будет вся идея в том, что мы идем по предкам, а по факту удаляем мы всегда
[02:43:19.540 --> 02:43:26.620]  узел именно тот, у которого либо один ребенок, либо вообще нет детей. Ясно?
[02:43:26.620 --> 02:43:33.940]  Нет, надо еще раз. Что именно непонятно?
[02:43:33.940 --> 02:43:42.460]  Про удаление. Почему по факту всегда перебираем всех предков? Потому что мы
[02:43:42.460 --> 02:43:47.660]  изменили здесь, вот здесь мы изменили нас высоту, мы убрали одну вершину. Правильно?
[02:43:47.660 --> 02:43:51.900]  Да. Если мы убрали одну вершину, у нас изменилась высота,
[02:43:51.980 --> 02:44:00.460]  значит, что здесь у нас везде могло поменяться высота под дерево. Правильно?
[02:44:00.460 --> 02:44:05.980]  Да. Могла. Поэтому нам необходимо взять и перебалансировать абсолютно всех предков.
[02:44:05.980 --> 02:44:13.460]  Хорошо. То есть вам необходимо дописать в реализации не то чтобы много,
[02:44:13.460 --> 02:44:21.500]  вам необходимо просто ротейты написать. В принципе, на этом наследие заканчивается,
[02:44:21.500 --> 02:44:26.700]  большое спасибо, что вы пришли. Буду ждать вас снова через неделю.
