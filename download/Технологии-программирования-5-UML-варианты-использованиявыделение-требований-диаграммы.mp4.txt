[00:00.000 --> 00:09.920]  Всем доброго дня! Мы с вами продолжаем изучение нашего курса и сегодня мы детальнее будем
[00:09.920 --> 00:18.080]  говорить про UML и просмотрим все виды диаграмм, которые могут быть полезны. Это, так сказать,
[00:18.080 --> 00:23.240]  наша лекция предурочена к тому, что через неделю уже сдавать первую итерацию проекта,
[00:23.240 --> 00:29.320]  поэтому нужно детальнее разобрать некоторые части, которые, возможно, вы уже сами нашли,
[00:29.320 --> 00:34.000]  но нужно каким-то образом это дополнить. В прошлый раз мы с вами начали с того,
[00:34.000 --> 00:39.840]  что мы посмотрели два способа выделения классов. Давайте еще раз их напомню. Первый способ это
[00:39.840 --> 00:46.840]  CRC-карточки, то есть это мы делаем небольшие карточки, они обычно определенного объема. У нас
[00:46.840 --> 00:54.840]  выделяется какой-то объект, который мы выделяем в класс, и после этого мы пытаемся определить имя
[00:54.840 --> 01:00.040]  класса, его ответственности и кто с ним взаимосвязан. После этого, на самом деле,
[01:00.040 --> 01:08.720]  когда вы имеете такой объект, вы можете уже легко на самом деле составить не только диаграмму
[01:08.720 --> 01:13.520]  классов, но и диаграмму объектов, то есть когда вы показываете именно взаимодействие между конкретными
[01:13.520 --> 01:19.320]  экземпляров класса. Вот, допустим, здесь у нас на примере есть CRC-карточки для продажи, то есть
[01:19.320 --> 01:28.160]  за что у нас отвечает продажа, то есть он отвечает за знания, за поведение, за промоушн. Это скорее
[01:28.160 --> 01:33.960]  всего именно продавец. Кто у него коллаборатор, это у него партнера и это клиент. То есть у нас
[01:33.960 --> 01:41.000]  сразу, если мы говорим про EML-диаграмму, у нас у класса Sales появляется связь с классами партнера
[01:41.000 --> 01:47.040]  клиента. Если мы говорим про транзакцию, собственно, здесь у нас методы MinyTransfer и Audit,
[01:47.040 --> 01:56.920]  значит коллаборатор это у нас тоже клиенты, то есть у нас получается уже, дайте-ка, EML найду.
[01:56.920 --> 02:12.320]  Взаимосвязь, то есть у нас есть класс Sales, значит он взаимодействует с партнером,
[02:12.320 --> 02:30.440]  и с клиентами. Мы не понимаем какое вид связи, это нужно детальнее уже рассматривать. Дополнительно
[02:30.440 --> 02:38.880]  у нас с вами есть заказ. Заказ взаимодействует с Customers и видно, что у заказа прямо есть
[02:38.880 --> 02:44.160]  некоторая ответственность. Значит смотрите, как здесь можно определять какие у нас поля класса,
[02:44.160 --> 02:51.920]  а какие у нас методы класса. Вот давайте поймем. Вот у нас есть price, у нас и stock, есть valid
[02:51.920 --> 03:01.520]  payment. Что из этого скорее всего будет методом, а что полями? Да, price, stock,
[03:01.520 --> 03:11.760]  то что мы можем сказать в русском языке называется как-то, не отглагольный существительный,
[03:11.760 --> 03:22.760]  какой-то другой термин, то есть существительный, который выделяет некоторые действия. Вот,
[03:22.760 --> 03:27.640]  то тогда мы можем сказать, что это метод, то есть скорее всего у заказа будет метод validate
[03:27.640 --> 03:34.840]  payment. И дополнительно мы видим с вами, что у нас допустим у того же класса delivery, доставка.
[03:34.840 --> 03:43.520]  Опять же это не конкретные объекты классов, они могут у нас уточняться с течением времени. То есть
[03:43.520 --> 03:49.480]  мы с вами уже по крайней мере по двум классам выявили какие связи между ними есть. Дополнительно
[03:49.480 --> 04:02.080]  у нас с вами у класса транзакции тоже есть ссылка на клиента. Значит, смотрите, здесь сразу нужно
[04:02.080 --> 04:11.200]  сказать, кто такой клиент. Это либо объект-экземпляр класса, либо это некоторое действующее лицо. То есть
[04:11.200 --> 04:17.560]  возможно, что это не экземпляр класса, это просто такой человечек его обычно обозначают, который
[04:17.560 --> 04:23.640]  будет взаимодействовать со всем остальным миром. Он сидит перед компьютером и выполняет какие-то
[04:23.640 --> 04:31.120]  действия. То есть здесь мы выделяем несколько суставных частей. То есть скорее всего это
[04:31.120 --> 04:36.120]  будут у нас классы. Возможно, что, кстати, sales это тоже некоторое действующее лицо, которое сидит
[04:36.120 --> 04:46.480]  по ту сторону системы и тоже пытается работать с нашей системой. Так, это что касается CRC-карточек.
[04:46.480 --> 04:52.400]  Теперь давайте вспомним, в чем заключается метатаббот. Мы выделяем существительные, объединяем
[04:52.400 --> 04:57.960]  некоторые синонимы, исключаем числительные или существительные, которые обозначают количество,
[04:57.960 --> 05:03.640]  исключаем эфемерные слова, данные информации и дополнительно мы исключаем слова, не подходящие к
[05:03.640 --> 05:10.960]  предметной области. Понятно, что последняя сфера, последний пункт отвечает за то, что нам действительно
[05:10.960 --> 05:17.200]  нужно пойти к человеку, который работает в этой предметной области, выяснить действительно
[05:17.200 --> 05:24.200]  ли нужны эти существительные или нет. Давайте вспомним вот этот пример. Значит, у нас, кажется,
[05:24.200 --> 05:31.640]  мы с вами уже выписывали все существительные и пытались выделить классы. Так, давайте подумаем.
[05:31.640 --> 05:40.360]  Давайте еще раз повторим это. Какие у нас есть существительные? У нас есть служба. Что еще? Давайте
[05:40.360 --> 06:08.680]  перечислять. Клиент. Да, еще что? Транспорт. Маршрут. Там, кажется, еще история есть.
[06:08.680 --> 06:26.720]  Что еще? Плечо. Значит, виды транспортов мы определили с вами, что у нас есть тип,
[06:26.720 --> 06:36.600]  тип маршрута, тип плеча, и мы скорее всего поняли, что это у нас будет енам. Опять же,
[06:36.640 --> 06:42.040]  нужно будет посмотреть, является это енамом или является это активным классом, который
[06:42.040 --> 06:48.120]  будет менять свое состояние. Так, еще есть такая вещь, как доставка и получение.
[06:48.120 --> 07:09.080]  Так, что еще? Да вроде все из таких основных моментов. О, путь.
[07:09.080 --> 07:28.420]  Так, хорошо. Давайте поймем, где здесь синонима. Здесь скорее всего есть синонима. Путь и маршрут,
[07:28.420 --> 07:35.800]  да, это синонима, поэтому оставляем только одно из них. Скорее всего лучше сказать,
[07:35.800 --> 07:55.400]  что это маршрут. Класс Путина у нас уходит. Служба класс нам нужен. Да, это что-то все облемающее,
[07:55.400 --> 08:13.240]  поэтому в прошлый раз сказали, что этого нам не надо. Хорошо. Клиент. Можно его сделать частью
[08:13.240 --> 08:18.280]  заказа, но в принципе, если мы хотим, чтобы клиент был в нашей системе как отдельное лицо,
[08:18.280 --> 08:23.720]  то скорее всего лучше сделать его уже классом. Вы заходите на сайт. Да, но смотрите, здесь,
[08:23.760 --> 08:28.920]  если мы говорим про систему, то скорее всего клиент будет играть в двух апостасиях. Во-первых,
[08:28.920 --> 08:34.680]  это собственно экземпляр класса, и скорее всего это уже будет не клиент, а какой-то
[08:34.680 --> 08:41.600]  пользователь нашей системы, а сам клиент будет скорее всего действующим лицом, актором.
[08:41.600 --> 09:01.720]  Вот, значит, история. Кажется, еще один момент. Является ли история классом? Да, это запись. Это
[09:01.720 --> 09:06.840]  некоторая запись действия. В принципе, ее можно оставить для того, чтобы явно обеспечить,
[09:06.840 --> 09:13.440]  что у заказа есть какая-то история перемещения. Тут вопрос будет состоять в том, хранить ли это
[09:13.440 --> 09:22.560]  все в маршруте или нет. Хорошо. И давайте теперь последний момент. Доставка и получение. Будут ли
[09:22.560 --> 09:35.760]  это экземплярами классов? Ой, будет ли это классом? Да, это некоторое действие. Поэтому,
[09:35.760 --> 09:44.080]  скорее всего, это перейдет в методы нашего класса. Все. То есть у нас получается с вами остаются классы
[09:44.080 --> 09:53.960]  клиент, заказ, транспорт, маршрут, либо история, плечо, тип плеча, ну и все. Значит, смотрите,
[09:53.960 --> 10:03.320]  теперь давайте посмотрим. Служба выполняет доставки заказов клиенту. Значит, доставка
[10:03.320 --> 10:14.240]  заказа шляется по маршруту. То есть получается, что у нас с вами? У заказа есть какой-то маршрут.
[10:14.240 --> 10:29.640]  Дальше. Значит, маршрут состоит из последними соединенных плеч. Скорее всего, это будет у нас
[10:29.800 --> 10:42.760]  какая-нибудь ассоциация. Почему плечо является ассоциацией не композиции? Ровно по той причине,
[10:42.760 --> 10:50.120]  что плечо может быть такое же у другого маршрута. Просто у нас есть какой-то перевалочный пункт,
[10:50.120 --> 10:58.800]  по которому у нас доставка идет. И для каждого плеча у нас есть атрибут. Какой-нибудь плюс транспорт.
[10:58.800 --> 11:11.000]  Понятно, что мы не специфицируем транспорт. И здесь нам нужно принять следующее решение. Мы
[11:11.000 --> 11:16.080]  отвечаем за транспортировку или кто-то внешне отвечает за транспортировку. Если значит,
[11:16.080 --> 11:23.760]  за транспортировку отвечаем мы, то есть мы вообще компания по перевозу там занимаемся именно
[11:23.760 --> 11:29.800]  перевозками. Но тогда нам нужно будет описывать вот эту вот часть деталей. Если нет, то оставляем
[11:29.800 --> 11:38.920]  это за пределы системы и выносим это в другую сущность. Так, значит, заказ у нас есть. Начальное
[11:38.920 --> 11:44.080]  плечо, это передача в доставку, конечное его получение. То есть, это именно описание деятельности.
[11:44.080 --> 11:54.880]  Значит, служба ведет историю заказов для каждого клиента. У нас есть, наверное,
[11:54.880 --> 12:03.600]  какой-нибудь history storage. Ну, storage мы не будем писать. Лучше его называть. У нас служба ведет
[12:03.600 --> 12:13.840]  историю заказов для каждого клиента. Тут скорее всего будет связь. У нас с вами это будет
[12:13.840 --> 12:22.200]  клиент. Значит, получается история. У нас связывается с клиентом. Тут надо решить,
[12:22.200 --> 12:30.000]  что это такое. То есть, возможно, что здесь у нас будет список заказов. То есть, это делается
[12:30.000 --> 12:37.920]  по соотношению 1 к звездочке. А клиент будет иметь свою собственную историю. Здесь нужно будет
[12:37.920 --> 12:42.400]  определить. Это у нас 1 к 1 отношение будет, то есть у каждого клиента ровно одна история.
[12:42.400 --> 12:51.400]  Либо может быть так, что у нас один экземпляр клиента может иметь несколько историй. Почему
[12:51.400 --> 12:56.280]  такое может быть? Потому что клиент может попытаться идентифицировать себя разными способами.
[12:56.280 --> 13:02.080]  То есть, сначала он, допустим, авторизовался по номеру телефона, потом он ввел почту. На самом
[13:02.080 --> 13:07.160]  деле это может быть один и тот же клиент. Просто потом нужно будет сделать так, чтобы все эти
[13:07.240 --> 13:17.520]  аккаунты соединились в один у нашего пользователя. Такая процедура, возможно, должна быть предусмотрена
[13:17.520 --> 13:28.160]  в системе. В целом получается вот такая базовая диаграмма классов. Опять же, они тут у нас очень
[13:28.160 --> 13:38.840]  даже просто взаимосвязаны. Паятель это пример. Мы по факту делаем следующее. Мы выделяем
[13:38.840 --> 13:45.400]  существительное, мы выделяем действие и смотрим какое следующее существительное с ним завязано.
[13:45.400 --> 13:51.920]  Здесь как раз мы применили композицию метода ABOTA плюс метод CRC-карточка, когда я рассказал про это
[13:51.920 --> 13:59.320]  взаимодействие. Тут еще доставка и получение. Это мы можем делать специальный идентификатор
[13:59.320 --> 14:10.080]  про заказ. Это можно оставить. Тут если выкинуть все эфемерные слова, то получается следующее.
[14:10.080 --> 14:21.440]  Заказы, маршруты, плечо, путь. Плечо, маршруты, в принципе, эфемерные. Заказы, маршруты, плечо, путь.
[14:21.440 --> 14:28.640]  Мы еще выделили с вами клиенты и историю. Здесь у нас как раз некоторое соответствие есть другое.
[14:28.640 --> 14:34.200]  Так, давайте теперь мы отмотаемся обратно, потому что на самом деле про классы нужно поговорить еще
[14:34.200 --> 14:41.200]  детальнее. Перейдем в поведенческую роль. И здесь нам очень важно будет рассказать, что же такое
[14:41.200 --> 14:45.760]  варианты использования. Что такое варианты использования? Это сценарий взаимодействия наших
[14:45.760 --> 14:53.160]  клиентов с программным обеспечением. При этом нам здесь нужно выделить очень важные границы
[14:53.160 --> 15:01.440]  нашей системы. То есть, что должна делать система, а что должны делать мы как клиенты. Обычно есть
[15:01.440 --> 15:10.200]  специальная диаграмма вариантов использования. И они обозначаются вот таким образом. Здесь мы
[15:10.200 --> 15:15.000]  стараемся как раз максимально четко выделить требования к нашей системе. Именно функциональные
[15:15.000 --> 15:22.900]  требования, которые выполняют определенную роль. Смотрите, из чего состоит диаграмма. Видите
[15:22.900 --> 15:31.120]  человечков в этой диаграмме? Это действующие лица, то есть кто есть в нашей системе. У нас с вами
[15:31.120 --> 15:39.600]  в нашей системе по одну сторону есть официант, клиент, и кэшер это кассир, а с другой стороны у
[15:39.600 --> 15:46.120]  нас есть шеф. При этом у нас есть с вами, вот смотрите, здесь главное не углубляться в деталях,
[15:46.120 --> 15:52.360]  а прописать вот основные сценарии поведения вашей системы. То есть, что у нас может сделать клиент?
[15:52.360 --> 16:04.040]  Он может заказать некоторую еду, съесть эту еду, у нас же все-таки ресторан, и заплатить за еду.
[16:04.040 --> 16:11.400]  То есть, в принципе, даже видно в каком порядке они идут. Да, можно заплатить за еду до, если у вас
[16:11.400 --> 16:18.240]  допустим онлайн заказ. Дополнительно, что здесь мы видим с вами? Здесь есть несколько вариантов
[16:18.240 --> 16:27.200]  расширения этого всего дела. Сразу скажу, что в отличие от основных диаграмм классов, у нас в
[16:27.200 --> 16:34.080]  диаграмме классов есть только наследование, по факту, и есть какая-то взаимосвязь между ними. Здесь
[16:34.080 --> 16:43.720]  есть два атрибута. Первый атрибут взаимоотношения между двумя вариантами использования это отношение
[16:43.720 --> 16:52.960]  include. Значит, что она означает? Если у нас есть вариант использования A, есть вариант использования B,
[16:52.960 --> 17:03.000]  то мы можем сказать, что один из них включает другой. То есть, у нас есть некоторые шаги
[17:03.000 --> 17:10.400]  варианта использования B. То есть, шаг 1, шаг 2. Дальше мы говорим, что у нас включается вариант
[17:10.400 --> 17:25.800]  использования A, 3 и 4. То есть, это как раз именно включение этих пунктов. Давайте пример. Какое-нибудь...
[17:25.800 --> 17:37.840]  Сейчас, сходу попробую придумать. Когда у нас какое-то действие включает себя в другое.
[17:37.840 --> 17:54.880]  Ну да, допустим, если мы говорим про оплату какого-то заказа, то, в принципе, он себя включает,
[17:54.880 --> 18:01.720]  так сказать, добавление товара в корзину. Потому что, как бы, без добавления товара в корзину мы
[18:01.720 --> 18:07.600]  действительно не оплатим заказ. То есть, у нас сначала идет вариант A, потом у нас идет, в зависимости
[18:07.600 --> 18:16.760]  от него, вариант B. Есть второй способ. Это расширение. Он обозначается так. У нас есть вариант
[18:16.760 --> 18:22.000]  использования A, и вариант использования B расширяет вариант использования A при наступлении
[18:22.000 --> 18:33.880]  определенного условия. К примеру, вариант использования посетить, пройти медосмотр.
[18:33.880 --> 18:48.520]  Медосмотр. Здесь, не поверите, напрашивается очень простое расширение.
[18:48.520 --> 19:05.520]  Причем два варианта расширения в зависимости от пола. Смотрите, если клиент у нас,
[19:05.520 --> 19:23.200]  это человек мужского пола, то у него будет одно расширение. А если перед нами клиент
[19:23.200 --> 19:35.200]  женского пола, то мы идем в другое место. Все достаточно просто. То есть, как бы, при наступлении
[19:35.200 --> 19:44.720]  условия, мы с вами посещаем разных врачей. А с другой стороны, у нас тоже есть как раз действующие
[19:44.920 --> 19:56.680]  Значит, это у нас один врач, а это у нас другой врач. Вот, то есть, вот такие вот варианты. Главное,
[19:56.680 --> 20:03.240]  что нам нужно будет здесь определить границы системы. И здесь важно как раз, когда мы говорим
[20:03.240 --> 20:09.760]  про варианты использования, четко прописать с каждой стороны, что именно делается, что делают
[20:09.760 --> 20:18.560]  клиенты, что делают акторы, а что делает система в этот момент времени. То есть, допустим, если мы
[20:18.560 --> 20:27.360]  говорим про медосмотр, давайте поговорим про посещение врача, то в чем у нас будет заключаться
[20:27.360 --> 20:41.800]  последовательность действий. Ну да, ну давайте для медосмотра. Значит, первое, клиент заходит к врачу.
[20:41.800 --> 21:00.920]  Второе, ну клиент заходит к врачу. Дальше что делает врач? Врач делает запрос в систему
[21:00.920 --> 21:21.440]  о клиенте. Значит, третье, значит, если запрос у нас успешен, а мы полагаем, что запрос у нас
[21:21.440 --> 21:46.960]  успешен. Значит, врач опрашивает клиента и вносит записи. Дальше, значит, врач нажимает на кнопку
[21:46.960 --> 22:05.200]  «сохранить». Система должна синхронизировать данные, ну и выдаёт вердикт. То есть, печатает
[22:05.200 --> 22:26.080]  бланк заключения. Ну вот, такой вот пример. Значит, что здесь может пойти не так? Ну, во-первых,
[22:26.080 --> 22:30.760]  первое, что делает запрос системы может быть неуспешным. Тогда мы делаем альтернативный
[22:30.760 --> 22:36.360]  сценарий. Говорим, что если на шаге два у нас что-то пошло не так, то шаг 3.1 будет
[22:36.360 --> 22:43.520]  заключаться в том, что врач скажет, что у вас нет системы. Увы, я не могу вас принять. Это
[22:43.520 --> 22:50.040]  первый сценарий. Второй сценарий, если система выдала ошибку, допустим, на время запроса,
[22:50.040 --> 22:54.400]  то тогда в роль включает системный администратор и мы переходим, допустим, в вариант использования
[22:55.040 --> 23:04.080]  «разберись с проблемами в системе», образно говоря, там устранение ошибки в софтеризации. Значит,
[23:04.080 --> 23:11.120]  здесь, опять же, врач опрашивает клиента и вносит запись в систему при сохранении
[23:11.120 --> 23:16.160]  синхронизации данных. У нас, опять же, может произойти ошибка синхронизации данных. И это
[23:16.160 --> 23:21.200]  у нас будет ещё один вариант сценария 5.1, альтернативный, который мы с вами описываем.
[23:21.200 --> 23:29.160]  Собственно, это я сейчас показал на примере, и каким образом описывается у нас сценарий use
[23:29.160 --> 23:33.560]  case. У нас с вами есть название, варианты использования, дальше действующие лица,
[23:33.560 --> 23:39.080]  после этого у нас есть основной сценарий и дальше есть альтернативный сценарий. Я как раз подготовил
[23:39.080 --> 23:46.360]  пример, чтобы не было это всё эфемерно. Давайте я его как раз открою. Наверное,
[23:46.360 --> 23:55.760]  я этим поделюсь с вами этими примерами. Это, собственно, некоторые варианты использования,
[23:55.760 --> 24:01.880]  которые были в системе Ahchak. Правда, сразу скажу, что эти варианты использовались где-то уже год
[24:01.880 --> 24:09.280]  с лишним. Смотрите, первый вариант использования. Назначить студенту преподавателя. Это происходит
[24:09.280 --> 24:18.160]  по время регистрации в системе. У нас есть ущельица, администратор и система. Здесь у нас нету
[24:18.160 --> 24:23.720]  ни студентов, ни препадавателей. По факту именно администратор действует системой. Администратор
[24:23.720 --> 24:28.360]  заправляет запрос системы, которая состоит из студента-припадавателя курса. Система проверяет,
[24:28.360 --> 24:32.320]  что преподавателе-студент зарегистрирован на курсе. Если у нас они не регистрированы,
[24:32.320 --> 24:37.680]  то должен быть альтернативный сценарий. Система создает запись базы данных, состоящую из трёх
[24:37.680 --> 24:44.600]  полей. Студент-тичер-курс. Система проверяет, что для курса и студента нету назначенного
[24:44.600 --> 24:50.880]  преподавателя. Там это поле уникальное, чтобы для студента и преподавателя у нас ровно одна
[24:50.880 --> 24:57.280]  связь была. Хотя, скорее всего, с учетом того, что мы будем проверять проекты, это немного поменяется.
[24:57.280 --> 25:03.480]  Вот альтернативы и сценарий здесь нету. Пример. Второй. Получить список заданий на проверку.
[25:03.480 --> 25:07.960]  Собственно, действующие лица здесь. Это преподаватель и система. Основной сценарий.
[25:07.960 --> 25:12.200]  Преподаватель нажимает на кнопку проверка заданий. Система отправляет запрос баз данных.
[25:12.200 --> 25:19.400]  Вот. Третий вариант. Значит и система возвращает список submission для клиентов. То есть видите,
[25:19.400 --> 25:25.720]  эти сценарии не прописаны четко. То есть они зачастую именно определяют бизнес требования,
[25:25.720 --> 25:33.840]  которые у нас должны быть. В общем, я пришлю здесь этот вариант, чтобы вы поняли. А вот,
[25:33.840 --> 25:39.000]  кстати, кнопочка отправить задания на проверку ревью преподавателя. Значит,
[25:39.000 --> 25:45.560]  в случае нарушения условия 2 основного сценария системы удавляет пользоваться, что не может
[25:45.560 --> 25:52.120]  отправить задания на проверку. То есть вот такие вот базовые вещи. Здесь мы явно прописываем.
[25:52.120 --> 25:55.960]  Смотрите, у нас есть какие-то требования. Они могут быть функциональными, то есть по функции,
[25:55.960 --> 26:01.680]  а могут быть не функциональными. И вот, чтобы вы как раз это понимали, какие требования бывают
[26:01.680 --> 26:07.680]  функциональными или не функциональными, я нашел отличный слайд, который это показывает. Так,
[26:07.680 --> 26:15.200]  мне кажется, тут со светом плохо, да? Блин. Ладно, давайте я прочитаю тогда. Значит, обычно
[26:15.200 --> 26:20.400]  требования, которые мы предъявляем, они делятся на несколько основных частей. Первое, это бизнес
[26:20.920 --> 26:26.220]  требования. Второе, это требования пользовательские. И третье, это системные требования. Значит,
[26:26.220 --> 26:32.480]  если мы говорим про бизнес требования, это то, что важно именно с точки зрения бизнеса. almonds
[26:32.480 --> 26:36.300]  són пользовательские это как раз с точки зрения клиента, который пользуется нашей системой,
[26:36.300 --> 26:42.060]  а системные требования это те требования, которые важны именно с точки зрения ПО,
[26:42.060 --> 26:50.020]  О, которое мы обеспечиваем. И вот смотрите, в чем особенность. Сразу скажу, что чтобы понять,
[26:50.020 --> 26:56.300]  какое у нас требование перед нами функциональное и не функциональное, нужно понять на какой вопрос
[26:56.300 --> 27:02.100]  мы отвечаем. Если мы говорим про функциональные требования, то мы отвечаем на вопрос «что». Если
[27:02.100 --> 27:08.940]  не функциональное, то вопрос «как». Давайте пример. Функционально ограничить доступ
[27:08.940 --> 27:17.340]  помещения нам нужно. Как? Система не должна организовывать скопление пользователей. То есть,
[27:17.340 --> 27:23.020]  как мы говорим, следующее, что ограничить доступ помещения — это наша основная цель. А вот не
[27:23.020 --> 27:28.860]  функционально, допустим, для того чтобы не организовывать скопление народов, нам нужно
[27:28.860 --> 27:37.100]  между людьми соблюдать дистанцию полтора метра. Тем самым мы не ограничим, точнее, как сказать,
[27:37.100 --> 27:44.540]  ограничим количество пользователей. Следующий пример. Про полицкие требования. Пользователь,
[27:44.540 --> 27:48.220]  имеющий право доступа, имеет возможность войти. Пользователь, не имеющий права доступа,
[27:48.220 --> 27:56.140]  не может войти. Опять же раскладываем, уже декомпозируем нашу задачу. А как сценарий
[27:56.140 --> 28:03.900]  проходит в помещение должен занимать не более двух секунд? Что это означает, что этот сценарий
[28:03.940 --> 28:11.780]  должен занимать не более чем две секунды? Можем ли мы поставить человека на фейс-контроле,
[28:11.780 --> 28:22.180]  чтобы этот сценарий у нас занимал не более двух секунд? Человек нет, поэтому нам нужна пропускная
[28:22.180 --> 28:27.980]  система, которая, если что, нас свернет в альтернативный сценарий, который говорит проверить
[28:27.980 --> 28:34.060]  пользователя по базе. Третье. Системные. Помещение должно иметь дверь со следующими
[28:34.060 --> 28:40.220]  функциями. То есть, видите, уже спускаемся на реализацию, и оказывается, что реализация это
[28:40.220 --> 28:45.780]  дверь. Значит, у нее должна быть функция открытие-закрытие, запирание-отпирание. То есть,
[28:45.780 --> 28:51.500]  запирание-отпирание это означает следующее, что у вас дверь просто автоматически, просто вы
[28:51.500 --> 28:59.300]  дергаете за дверь, у вас она не открывается. И дверь должна иметь... А дальше вот нефункциональные
[28:59.300 --> 29:08.820]  требования к двери, к самой, что дверь должна иметь не более чем 70 сантиметров, а ключ должен
[29:08.820 --> 29:15.380]  отпирать замок не менее чем за один оборот. Если у нас, допустим, будет три или четыре оборота,
[29:15.380 --> 29:21.420]  то, скорее всего, если мы говорим про автоматическую систему, то вряд ли мы ее откроем
[29:21.420 --> 29:26.100]  за две-три секунды. Да, то есть, мы прям декомпозировали это все на функциональные
[29:26.100 --> 29:34.340]  и нефункциональные требования. Это вот на одном примере, связанных с проходом помещения. Так,
[29:34.340 --> 29:43.780]  поняли ли этот слайд? Хорошо. И теперь давайте как раз поговорим про то, к чему же это все
[29:43.780 --> 29:49.940]  вносится. Собственно, когда мы с вами специфицируем требования к ПО, то у нас есть некоторые бизнес
[29:49.940 --> 29:55.060]  требования, которые мы можем предъявлять в системе, и у нас могут быть некоторые бизнес-правила.
[29:55.060 --> 30:04.420]  То есть, это правила хорошего тона, которые у нас могут быть. Дальше из бизнес-стребований как раз у
[30:04.420 --> 30:12.100]  нас определяются границы нашей системы. Вот как раз, что мы делаем, а что мы не делаем. Если мы
[30:12.100 --> 30:20.580]  говорим в концепциях скрама, которые мы говорили с вами, то это так называемый продукт-реквайернц,
[30:20.580 --> 30:34.580]  это требование к нашему продукту. Зачем он делается? Как вы думаете? Зачем мы должны
[30:34.660 --> 30:49.940]  описать требования к нашему продукту? Заранее договориться о них. Чтобы не рисовать красных
[30:49.940 --> 30:55.420]  единорогов посередине проекта, когда это захотелось заказчику. То есть, по факту,
[30:55.420 --> 31:00.860]  это документ-граница, который позволяет нам сказать, что мы вот этого не делаем. После этого
[31:00.860 --> 31:08.060]  уже как раз исходя из бизнес-правил и концепции границ, у нас возникают пользовательские требования.
[31:08.060 --> 31:14.740]  То есть, допустим, что у нас тут должна появиться система, которая открывает наши двери. Дальше у
[31:14.740 --> 31:21.460]  нас появляется документ пользовательских требований и по факту, где-то вот здесь вот по различным
[31:21.460 --> 31:26.540]  спецификациям возникают варианты использования. То есть, как раз документ пользовательских
[31:26.540 --> 31:32.780]  требований иногда еще называют документом о вариантах использования. Это все будет влиять
[31:32.780 --> 31:37.260]  на функциональные требования к нашей системе. То есть, дальше мы уже будем спускаться на
[31:37.260 --> 31:44.180]  архитектурный уровень. И как раз здесь уже для функциональных требований нам могут помочь
[31:44.180 --> 31:49.980]  некоторые атрибуты качества, которые можно замерить. Система должна быть там гибкая,
[31:49.980 --> 31:53.820]  адаптируемая и так далее. То есть, мы специально тоже их прописываем для того,
[31:53.960 --> 31:58.640]  что получить наши требования. Дополнительно системные требования тоже могут влиять на
[31:58.640 --> 32:03.680]  функциональные требования. Опять же главное, тут отделить функциональные и не функциональные
[32:03.680 --> 32:10.960]  требования. И дополнительно у нас как раз могут появиться ограничения с нашей системы. То есть,
[32:10.960 --> 32:17.320]  какие-то законодательные, регламентирующие, сертифицирующие. И мы получаем спецификацию
[32:17.320 --> 32:21.580]  требований к программному обеспечению. То есть, по факту мы можем проработать дальнейшим
[32:21.580 --> 32:25.180]  наши варианты использования для того, чтобы уже оставить
[32:25.180 --> 32:27.020]  какие-то основные вещи.
[32:27.020 --> 32:30.500]  Самое главное, не делите минимально вариант.
[32:30.500 --> 32:33.100]  То есть, образно говоря, если у вас есть какая-то
[32:33.100 --> 32:38.460]  игра, то вы в качестве игры можете сказать следующее,
[32:38.460 --> 32:41.340]  изменить настройки уровней, уровней, настройки игры
[32:41.340 --> 32:43.260]  — это вариант использования.
[32:43.260 --> 32:46.460]  А вот изменить громкость игры — это уже не совсем
[32:46.460 --> 32:49.740]  вариант использования, это уже некоторые реализации
[32:49.740 --> 32:52.540]  варианты использования, связанные с тем, что изменяем
[32:52.540 --> 32:53.540]  настройки игры.
[32:53.540 --> 32:55.980]  То есть, крупными мазками все делаем.
[32:55.980 --> 33:00.660]  Так, хорошо.
[33:00.660 --> 33:01.900]  Давайте вопрос по этой части.
[33:01.900 --> 33:08.260]  Тут и стоит задавать, можно даже глупые вопросы задавать.
[33:08.260 --> 33:13.260]  Молчок.
[33:13.260 --> 33:18.500]  Хорошо.
[33:18.500 --> 33:21.980]  Давайте тогда мы поедем дальше, поговорим не про
[33:21.980 --> 33:24.540]  некоторые поведенческие диаграммы, которые позволяют
[33:24.540 --> 33:27.260]  описать связь наших объектов.
[33:27.260 --> 33:30.300]  Первый из диаграмм, который очень часто используется
[33:30.300 --> 33:33.460]  и вам понадобится по жизни — это диаграмма последовательности.
[33:33.460 --> 33:34.860]  Значит, что мы с ней сделаем?
[33:34.860 --> 33:37.940]  Мы с вами по факту из нашей системы, после того, как
[33:37.940 --> 33:41.740]  выделили варианты использования, мы как раз попытаемся реализовать
[33:41.740 --> 33:45.060]  один из вариантов использования, которые здесь есть.
[33:45.060 --> 33:47.340]  Их можно реализовать несколькими способами.
[33:48.020 --> 33:51.500]  Первый способ реализации — это диаграмма последовательности.
[33:51.500 --> 33:54.460]  Второй из способов — это диаграмма активности.
[33:54.460 --> 33:58.100]  А третий из способов — это диаграмма состояния.
[33:58.100 --> 34:01.460]  Поговорим с вами сначала про диаграмму последовательности.
[34:01.460 --> 34:03.420]  В чем ее суть?
[34:03.420 --> 34:07.260]  Ее суть — показать в течение времени, как происходит
[34:07.260 --> 34:08.260]  процесс.
[34:08.260 --> 34:09.260]  Что происходит?
[34:09.260 --> 34:14.020]  Мы с вами из акторов и из нашего клиента, из нашей
[34:14.020 --> 34:18.620]  системы выделяем, во-первых, действующее лицо, раз, а
[34:18.620 --> 34:22.940]  во-вторых, выделяем по экземпляру наших объектов.
[34:22.940 --> 34:25.940]  То есть у нас ордер, двоеточие, ордер.
[34:25.940 --> 34:27.540]  То есть это конкретный экземпляр.
[34:27.540 --> 34:32.420]  И дальше мы с вами показываем на, так сказать, линейной
[34:32.420 --> 34:36.140]  шкале, на шкале времени, что происходит.
[34:36.140 --> 34:38.660]  Значит, смотрите пример.
[34:38.740 --> 34:45.180]  У нас с вами, допустим, есть система с банкоматом,
[34:45.180 --> 34:47.380]  и у нас здесь есть действующее лицо.
[34:47.380 --> 34:49.780]  Это клиент нашего ATM.
[34:49.780 --> 34:52.300]  Дополнительно у нас с вами есть, смотрите, важно, что
[34:52.300 --> 34:56.020]  это не класс, это не класс ATM и класс банк-сервер.
[34:56.020 --> 34:59.300]  Это именно экземпляры класса банкомат и экземпляры
[34:59.300 --> 35:00.580]  класса банковский сервер.
[35:00.580 --> 35:02.780]  Что мы делаем?
[35:02.780 --> 35:05.420]  Значит, здесь бывают следующие методы.
[35:05.420 --> 35:06.420]  Очень важно.
[35:07.420 --> 35:13.180]  Опять же, небольшой технический заброс на будущее.
[35:13.180 --> 35:14.900]  Бывают методы синхронные.
[35:14.900 --> 35:18.340]  Что означает синхронный метод?
[35:18.340 --> 35:21.020]  Вы по факту так вызываете любую функцию.
[35:21.020 --> 35:24.460]  То есть вы вызываете функцию, ожидаете результат его исполнения.
[35:24.460 --> 35:26.340]  Бывают функции асинхронные.
[35:26.340 --> 35:28.900]  Что означает функция асинхронная?
[35:28.900 --> 35:32.260]  Вы отправили какой-то запрос, и результат вам сразу не
[35:32.260 --> 35:33.740]  приходит.
[35:33.740 --> 35:35.820]  Вы можете делать действия в дальнейшем.
[35:35.900 --> 35:36.900]  Классический пример.
[35:36.900 --> 35:44.860]  Вы заходите на госуслуги, нет, вы заказываете какую-то
[35:44.860 --> 35:45.860]  справку.
[35:45.860 --> 35:52.180]  Вам же справку сразу не выдают, вам отдают справку
[35:52.180 --> 35:56.900]  только через некоторое время, и то в отдельном письме.
[35:56.900 --> 36:01.140]  То есть вы получаете ответ на ваш запрос при помощи
[36:01.140 --> 36:03.900]  некоторого ответного действия.
[36:03.900 --> 36:07.620]  Допустим, функцию, которую вы должны вызвать после
[36:07.620 --> 36:09.460]  того, как ваша функция отработает.
[36:09.460 --> 36:11.860]  Это называется колбэк.
[36:11.860 --> 36:18.780]  И на диаграмме последности это тоже можно продемонстрировать
[36:18.780 --> 36:19.780]  при желании.
[36:19.780 --> 36:20.780]  Система.
[36:20.780 --> 36:23.780]  Что здесь прописывается?
[36:23.780 --> 36:27.460]  Здесь прописывается вариант использования авторизации
[36:27.460 --> 36:28.860]  в банкомате.
[36:28.940 --> 36:29.940]  Действующие лица.
[36:29.940 --> 36:33.820]  Это клиент, это ATM и это банк-сервер.
[36:33.820 --> 36:36.260]  Что делает ATM customer?
[36:36.260 --> 36:37.260]  Он вставляет карту.
[36:37.260 --> 36:43.500]  Это асихронное действие в данном случае.
[36:43.500 --> 36:45.140]  Дальше, что у нас происходит?
[36:45.140 --> 36:48.980]  У нас с вами ATM запрашивает информацию у банковского
[36:48.980 --> 36:51.820]  сервера, можем ли мы верифицировать карту.
[36:51.820 --> 36:54.500]  А дальше в зависимости от ответа у нас возникают
[36:54.500 --> 36:56.460]  два альтернативных варианта.
[36:56.500 --> 37:00.540]  Первый вариант альтернативный, это если у нас карта окей,
[37:00.540 --> 37:04.380]  тогда мы клиенту отправляем запрос введите пароль.
[37:04.380 --> 37:05.940]  Этот запрос будет синхронным.
[37:05.940 --> 37:10.700]  То есть мы ждем пока клиент введет пароль и возвращаем
[37:10.700 --> 37:11.700]  результат.
[37:11.700 --> 37:13.940]  Значит, стрелочки это возвращение результата.
[37:13.940 --> 37:17.900]  А если у нас карта неволидная, то мы переходим на другой
[37:17.900 --> 37:19.460]  альтернативный сценарий.
[37:19.460 --> 37:23.620]  То есть тут видно прямо при помощи кнопки alt, при
[37:23.660 --> 37:26.260]  помощи действия alt, вот там вот alt написано, что карта
[37:26.260 --> 37:27.940]  неволидная и мы хотим вернуть карту.
[37:27.940 --> 37:31.860]  Все, вариант использования заканчивается.
[37:31.860 --> 37:36.140]  То есть здесь прямо по пунктам можно прямо прописать
[37:36.140 --> 37:38.620]  из вариантов использования какие шаги мы с вами делаем.
[37:38.620 --> 37:48.180]  Так, с этим примером, разобрались или нет?
[37:48.180 --> 37:50.380]  Там сейчас будет еще один пример.
[37:50.380 --> 37:51.380]  Он будет страшнее.
[37:52.340 --> 37:53.340]  Все готовы?
[37:59.940 --> 38:01.620]  Вот такой вариант использования.
[38:01.620 --> 38:05.460]  Значит, что мы здесь делаем?
[38:05.460 --> 38:10.580]  Это форма определения комментариев.
[38:10.580 --> 38:13.740]  Собственно, здесь прямо прописан код взаимодействия
[38:13.740 --> 38:16.780]  сервера и клиента.
[38:16.780 --> 38:20.500]  Значит, у нас есть клиент, он может перейти в какой-то
[38:20.540 --> 38:21.540]  другой вариант использования.
[38:21.540 --> 38:22.540]  Это ворота.
[38:22.540 --> 38:26.340]  Мы отправляем сообщение, значит, message validate.
[38:26.340 --> 38:30.740]  Дальше, значит, окно у нас отправляется еще один
[38:30.740 --> 38:32.180]  раз все в коммент.
[38:32.180 --> 38:35.660]  И дальше здесь есть специальная вещь, что мы называем конструктор
[38:35.660 --> 38:36.660]  класса.
[38:36.660 --> 38:40.740]  Здесь идет запрос вида Ajax, то есть мы идем на сервер
[38:40.740 --> 38:44.260]  и создаем этот экземпляр и отправляем запрос.
[38:44.260 --> 38:47.420]  Видно, что он является асинхронным, то есть результата ожиданий
[38:47.420 --> 38:48.420]  у нас нет.
[38:48.660 --> 38:51.980]  У нас Proxy присылает все на сервер и дополнительно
[38:51.980 --> 38:55.700]  в одном из методов validate мы с вами получаем копчу.
[38:55.700 --> 38:57.860]  То есть нам нужно проверить на копчу.
[38:57.860 --> 39:01.420]  Дальше у нас есть ошибки, ошибки, ошибки и возвращается
[39:01.420 --> 39:04.180]  метод callback, что нам нужно сделать.
[39:04.180 --> 39:08.900]  И дополнительно мы с вами по факту производим сеанс
[39:08.900 --> 39:13.500]  верификации и дальше мы с вами уже отправляем комментарии,
[39:13.500 --> 39:14.500]  которые нам нужны.
[39:14.500 --> 39:17.820]  То есть здесь асинхронные запросы как раз происходят
[39:17.820 --> 39:19.140]  при помощи метода Ajax.
[39:19.140 --> 39:26.180]  Вот, то есть это уже реальный пример диаграмма по сенсии.
[39:26.180 --> 39:30.820]  Тут даже больше вещь состоит не в том, чтобы вы могли
[39:30.820 --> 39:34.340]  эти диаграммы рисовать, а их читать, потому что они
[39:34.340 --> 39:37.420]  явно показывают в каком порядке действует система.
[39:37.420 --> 39:40.740]  Вот код, который бы это было написано, он был бы ужасный.
[39:40.740 --> 39:45.220]  А на диаграмме сразу все видно.
[39:45.220 --> 39:47.980]  Что у нас происходит.
[39:47.980 --> 39:54.940]  Особенно, кстати, частенько диаграммы последовательности
[39:54.940 --> 39:59.060]  используются для всяких проектов, связанных с мобильными
[39:59.060 --> 40:01.900]  устройствами или с графическими интерфейсами, когда необходимо
[40:01.900 --> 40:04.260]  прописать все возможные варианты взаимодействий.
[40:04.260 --> 40:12.700]  Так, хорошо, понятно ли вот эта вещь, вот эта диаграмма?
[40:13.700 --> 40:15.980]  То есть здесь опять же в качестве упражнения можно
[40:15.980 --> 40:17.820]  попробовать как раз отрисовать.
[40:17.820 --> 40:19.780]  Клиент отправляет заказ и так далее.
[40:19.780 --> 40:23.780]  Я вам отправлю пример диаграмм варианта использования,
[40:23.780 --> 40:27.180]  диаграмма последовательств для этого проекта, для вот
[40:27.180 --> 40:28.180]  этих примеров.
[40:28.180 --> 40:33.300]  Так, с этим разобрались?
[40:33.300 --> 40:34.300]  Хорошо.
[40:34.300 --> 40:38.180]  Следующая диаграмма, это диаграмма состояния.
[40:38.660 --> 40:42.740]  И здесь, как ни странно, мы встретим с вами еще один
[40:42.740 --> 40:46.980]  паттерн, потому что есть как раз паттерн под названием
[40:46.980 --> 40:47.980]  состояние.
[40:47.980 --> 40:51.860]  В чем он состоит?
[40:51.860 --> 40:54.460]  Нам нужны некоторые активные объекты.
[40:54.460 --> 40:56.260]  Что это означает?
[40:56.260 --> 40:59.180]  Это означает, что этот объект может сам управлять
[40:59.180 --> 41:01.260]  своим жизненным циклом.
[41:01.260 --> 41:05.020]  То есть он, во-первых, может управлять другими объектами
[41:05.020 --> 41:08.100]  и у него есть свой собственный поток управления.
[41:08.100 --> 41:13.100]  Пример очень простой такой системы, это холодильник.
[41:13.100 --> 41:18.620]  Значит, он может сам нагреваться, может сам охлаждаться.
[41:18.620 --> 41:22.540]  И при этом еще у него есть взаимодействие с другими
[41:22.540 --> 41:23.540]  объектами.
[41:23.540 --> 41:24.540]  То есть его может кто-то открыть.
[41:24.540 --> 41:28.020]  То есть вот такие вот автономные объекты, которые не управляются
[41:28.020 --> 41:31.100]  изне, мы называем активными объектами.
[41:31.100 --> 41:33.500]  Может ли кто-то еще попробовать привести примеры активных
[41:33.500 --> 41:37.700]  объектов нашей жизни?
[41:37.700 --> 41:40.860]  Вы не поверите, с некоторыми активными объектами вы действуете
[41:40.860 --> 41:41.860]  как по...
[41:41.860 --> 41:48.180]  Это слишком большой объект, это прям система.
[41:48.180 --> 42:00.020]  Я бы скажу так, процесс запуска демонов в сервере,
[42:00.020 --> 42:02.460]  демоны, которые находятся в сервере, то есть не программы,
[42:02.460 --> 42:04.140]  которые мы запускаем, а которые контролируются
[42:04.140 --> 42:05.140]  сервером.
[42:05.980 --> 42:07.220]  Так, давайте жизненные примеры.
[42:07.220 --> 42:16.500]  Вы поверите, каждый день с ним взаимодействуете.
[42:16.500 --> 42:24.140]  Светафор, конечно же, он же сам переключает практически
[42:24.140 --> 42:25.140]  ветки.
[42:25.140 --> 42:30.140]  То есть в зависимости от того, в какое время суток
[42:30.140 --> 42:32.660]  вы переходите и в какое время вы пришли, у вас автоматически
[42:32.660 --> 42:33.660]  идет переключение.
[42:34.180 --> 42:35.180]  Светафора.
[42:35.180 --> 42:38.180]  Причем он сам меняет свое состояние.
[42:38.180 --> 42:40.620]  Для одних он желтый, для других он красный, для третьих
[42:40.620 --> 42:41.620]  он зеленый.
[42:41.620 --> 42:43.980]  То есть он показывает разные цвета.
[42:43.980 --> 42:44.980]  Вот.
[42:44.980 --> 42:46.780]  И вот вот пример.
[42:46.780 --> 42:52.540]  Тут как раз банковский тоже АТМ-пример, в нем есть несколько
[42:52.540 --> 42:53.540]  состояний.
[42:53.540 --> 42:56.940]  Значит он изначально выключен, и дополнительно значит есть
[42:56.940 --> 42:59.780]  некоторые кнопки, которые могут переключить его состояние.
[42:59.780 --> 43:02.420]  То есть он либо сам при некоторых условиях может перейти
[43:02.420 --> 43:04.020]  с одного состояния в другое.
[43:04.020 --> 43:11.740]  Либо он сам его, либо кто-то выполняет какой-то триггер.
[43:11.740 --> 43:14.980]  Значит смотрите, у нас автомат выключен, это у нас состояние.
[43:14.980 --> 43:19.620]  Дальше при действии turn-off мы делаем, а это наоборот.
[43:19.620 --> 43:22.620]  Значит смотрите, при нажатии кнопки turn-on или вызовем
[43:22.620 --> 43:25.380]  этот стартап, мы начинаем само тестирование нашей
[43:25.380 --> 43:26.380]  системы.
[43:26.380 --> 43:30.180]  Значит если при этом тестирование системы происходит неуспешно,
[43:30.180 --> 43:33.100]  то мы выходим с вами в out of service.
[43:33.100 --> 43:36.420]  То есть у нас автомат не работает.
[43:36.420 --> 43:39.620]  А если у нас все окей, мы переходим в состояние idle.
[43:39.620 --> 43:40.620]  Что означает это состояние?
[43:40.620 --> 43:42.820]  Idle это состояние ожидания запросов.
[43:42.820 --> 43:49.220]  Дальше, когда мы вставляем карту в банкомат, у нас срабатывает
[43:49.220 --> 43:53.460]  еще одно действие, и мы переходим в большое состояние, связанное
[43:53.460 --> 43:55.300]  с взаимодействием пользователей.
[43:55.300 --> 43:59.860]  То есть у нас одно состояние, которое может быть, может
[44:00.020 --> 44:03.620]  быть структурным, и в нем есть тоже некоторые варианты
[44:03.620 --> 44:04.620]  использования.
[44:04.620 --> 44:06.980]  Ой, не варианты использования, а некоторые состояния.
[44:06.980 --> 44:10.780]  Собственно, когда мы заходим в этот момент, мы прописываем,
[44:10.780 --> 44:13.700]  что мы заходим тогда, когда мы прочитываем карту.
[44:13.700 --> 44:17.420]  А выходим тогда, когда мы вынимаем карту.
[44:17.420 --> 44:21.340]  То есть видите, здесь как раз диаграмма состояний
[44:21.340 --> 44:24.900]  в банковской ячейке у нас с вами находится.
[44:24.900 --> 44:29.140]  Примеры такие же есть, если вы включите компьютер,
[44:29.140 --> 44:32.060]  компьютер по факту тоже является автономным объектом.
[44:32.060 --> 44:36.740]  Он дополнительно еще может вызывать действия, связанные
[44:36.740 --> 44:39.260]  с проверкой обновления операционной системы.
[44:39.260 --> 44:43.340]  Причем триггеры могут быть не явные, явные могут быть
[44:43.340 --> 44:46.180]  с наступлением по какому-то временному масштабу.
[44:46.180 --> 44:48.540]  То есть мы можем отправить так называемое сообщение
[44:48.540 --> 44:52.060]  для того, чтобы у нас сервер начал свою работу.
[44:52.060 --> 44:57.740]  То есть у нас есть некоторые переключения либо по внешнему
[44:57.780 --> 44:59.220]  действию, либо самостоятельно.
[44:59.220 --> 45:01.940]  И вот нам надо это каким-то образом реализовывать.
[45:01.940 --> 45:04.220]  И вот как раз для того, чтобы это реализовать, существует
[45:04.220 --> 45:05.220]  паттерн состояния.
[45:05.220 --> 45:10.700]  Значит, нам необходимо реализовывать переключение
[45:10.700 --> 45:12.860]  между состоянием таким образом, чтобы не приходилось
[45:12.860 --> 45:15.140]  выполнять сложную функциональность при этом переключения.
[45:15.140 --> 45:20.220]  Примеры, кстати, светофор, как мы сказали, или отслеживание
[45:20.220 --> 45:21.420]  доставки товаров.
[45:21.420 --> 45:25.820]  То есть у нас с вами автоматический, так сказать, заказ должен
[45:25.820 --> 45:27.700]  переключать свое собственное состояние.
[45:27.700 --> 45:31.100]  Три перехождения из одного ключа в другое.
[45:31.100 --> 45:34.260]  То есть у нас есть, допустим, мы только собираем заказ.
[45:34.260 --> 45:37.220]  Дальше, значит, кто-то по действию либо его переключает,
[45:37.220 --> 45:40.860]  либо соответственно автоматическая система, которая, допустим,
[45:40.860 --> 45:44.860]  у вас есть геолокация на вашем товаре, и вы определяете,
[45:44.860 --> 45:45.860]  где ваш товар находится.
[45:45.860 --> 45:48.860]  Сейчас текущий момент времени.
[45:48.860 --> 45:49.860]  Вот.
[45:49.860 --> 45:52.260]  И нам это необходимо как раз реализовать.
[45:52.260 --> 45:56.220]  Допустим, нам нужно больное действие.
[45:56.220 --> 45:58.300]  Нужно пройти код-ревью преподавателя.
[45:58.300 --> 46:02.180]  Собственно, для этого нам необходимо двустороннее
[46:02.180 --> 46:05.260]  взаимодействие по каждой заданче, преподаватель
[46:05.260 --> 46:11.300]  должен посмотреть код, отправить комментарии, а студент должен
[46:11.300 --> 46:13.940]  исправить эти замечания или ответить на вопросы.
[46:13.940 --> 46:19.420]  Некоторые вещи должны происходить автоматически.
[46:19.420 --> 46:23.380]  То есть сама система должна менять состояние, а некоторые
[46:23.380 --> 46:25.940]  вещи не должны происходить автоматически, а должны
[46:25.940 --> 46:27.220]  ожидать какого-то триггера.
[46:27.220 --> 46:28.220]  Вот.
[46:28.220 --> 46:31.100]  И вопрос здесь состоит, как это все совершить.
[46:31.100 --> 46:34.620]  И здесь есть достаточно элегантное решение с точки
[46:34.620 --> 46:37.380]  зрения объектно-ориентированного программирования.
[46:37.380 --> 46:39.820]  Оно будет заключаться в том, что давайте мы выделим
[46:39.820 --> 46:43.860]  класс, который занимается активным объектом, и под
[46:43.860 --> 46:46.580]  классы, которые будут отвечать за каждое из этих состояний.
[46:46.580 --> 46:50.300]  Сейчас я поясню на примере.
[46:50.300 --> 46:55.780]  Цель, собственно, паттерн состояние является обеспечением
[46:55.780 --> 46:58.100]  поведения объектов в зависимости от его состояния.
[46:58.100 --> 47:01.100]  Пример паттерна следующий.
[47:01.100 --> 47:03.300]  То есть смотрите, у нас есть клиент, у него и у нас
[47:03.300 --> 47:04.300]  есть контекст.
[47:04.300 --> 47:07.260]  Значит, в данном случае контекст это будет светофор.
[47:07.260 --> 47:08.260]  Есть заказ.
[47:08.260 --> 47:12.460]  И у него есть ссылка на определенный интерфейс под
[47:12.460 --> 47:14.300]  названием состояние.
[47:14.300 --> 47:16.420]  У него есть три состояния.
[47:16.420 --> 47:19.340]  Красный, желтый, зеленый.
[47:19.380 --> 47:24.580]  И у каждого из состояния есть метод перейти в следующее
[47:24.580 --> 47:29.100]  состояние, которое должен вернуть как раз это состояние.
[47:29.100 --> 47:34.100]  То есть у нас получается у состояния три реализации
[47:34.100 --> 47:35.980]  красный, желтый, зеленый.
[47:35.980 --> 47:39.700]  Значит, у красного состояния, куда он должен переходить?
[47:39.700 --> 47:45.340]  У желтого в зеленый и наоборот.
[47:45.340 --> 47:48.120]  Единственное, что возможно, что у нас еще контекст должен
[47:48.120 --> 47:50.280]  хранить, в каком направлении мы это все делаем.
[47:50.280 --> 47:53.680]  И в итоге код у нас будет следующий.
[47:53.680 --> 47:54.680]  Переключение светофора.
[47:54.680 --> 48:00.560]  Мы просто говорим, значит, светофор переключайся 20
[48:00.560 --> 48:01.560]  раз.
[48:01.560 --> 48:05.320]  Что делается при переключении светофора 20 раз?
[48:05.320 --> 48:08.920]  Значит, он берет состояние, которое у него есть сейчас
[48:08.920 --> 48:13.520]  на текущий момент, и вызывает у него метод getNext.
[48:13.520 --> 48:16.400]  Давайте я как раз попробую нарисовать.
[48:16.400 --> 48:28.280]  Это состояние, то есть что у нас получается?
[48:28.280 --> 48:30.160]  Представьте себе, что у нас есть светофор.
[48:30.160 --> 48:36.680]  У него состояние красное.
[48:36.680 --> 48:47.160]  Значит, когда мы вызываем метод goNext, а у нас у светофора
[48:47.160 --> 48:55.680]  делает следующее k goNext, значит, красный goNext вернет
[48:55.680 --> 48:56.680]  желтый.
[48:56.680 --> 48:58.880]  И сделает следующее.
[48:58.880 --> 49:05.720]  Пожалуйста, светофор, установи состояние на
[49:05.720 --> 49:06.720]  желтый.
[49:06.720 --> 49:10.960]  То есть вот такая реализация будет у красного.
[49:10.960 --> 49:14.600]  То есть реализация goNext заключается в том, что мы создаем конструктор
[49:14.600 --> 49:17.160]  класса желтый и подставляем его сюда.
[49:17.160 --> 49:20.160]  То есть после завершения этого действия у нас вот
[49:20.160 --> 49:22.240]  этот объект пропадает, у нас появляется объект
[49:22.240 --> 49:23.240]  желтый.
[49:23.240 --> 49:26.480]  Дальше мы еще раз вызываем goNext.
[49:26.480 --> 49:31.360]  Значит, теперь у нас идет желтый goNext и в зависимости
[49:31.360 --> 49:34.640]  от контекста, который мы можем установить в вызове
[49:34.640 --> 49:40.280]  конструктора, допустим, g здесь в кубочках z, мы говорим,
[49:40.280 --> 49:43.520]  окей, у желтого стоит контекст в зеленый, поэтому мы вызываем
[49:43.520 --> 49:50.280]  конструктор зеленого и дальше устанавливаем setState на зеленый.
[49:50.280 --> 49:54.840]  Вот, и теперь у нас здесь стоит зеленый.
[49:54.840 --> 50:01.240]  То есть мы скрываем детали перехода из одного состояния
[50:01.240 --> 50:02.760]  в другое внутри нашего класса.
[50:02.760 --> 50:03.760]  Да?
[50:03.760 --> 50:17.160]  Ну конечно же, типа у нас получается, я бы сказал
[50:17.160 --> 50:19.880]  так, это основано даже на композиции, то есть что
[50:19.880 --> 50:23.640]  у нас вот этот вот объект, внутренний, делегируемый
[50:23.640 --> 50:26.560]  объект, он не виден, не может существовать без контекста,
[50:26.560 --> 50:27.560]  который мы с вами поставили.
[50:27.560 --> 50:31.200]  Ну а так здесь, да, конечно же, механизм виртуальных
[50:31.200 --> 50:33.960]  функций используется, потому что мы используем наследование
[50:33.960 --> 50:38.160]  одним из классов, в зависимости просто от того, что написано
[50:38.160 --> 50:40.560]  в реализации каждого из классов, мы переключаемся
[50:40.560 --> 50:41.560]  на другой класс.
[50:41.560 --> 50:43.880]  То есть у красного одна логика, у желтого вторая логика,
[50:43.880 --> 50:45.600]  у зеленого другая логика, третья логика.
[50:45.600 --> 50:50.240]  Вот, дополнительно можно еще поставить какие-нибудь
[50:50.240 --> 50:52.320]  триггеры, которые будут переключать состояние.
[50:52.320 --> 50:55.240]  То есть мы все-таки разрешаем у контекста установить
[50:55.240 --> 50:56.240]  определенное состояние.
[50:56.240 --> 51:00.880]  Более того, если внимательно подумать и расширить этот
[51:00.880 --> 51:03.440]  процесс, вы можете, наоборот, запретить некоторые переходы
[51:03.440 --> 51:06.920]  внешние при желании.
[51:06.920 --> 51:12.040]  То есть как раз там, если говорить про систему, в которую
[51:12.040 --> 51:14.920]  мы задаем домашнее задание, там как раз так и сделано.
[51:14.920 --> 51:17.360]  То есть там просто проверяет список возможных состояний,
[51:17.360 --> 51:19.920]  в которые вы можете перейти, и они возвращаются.
[51:19.920 --> 51:24.320]  Так, значит, когда это можно применять?
[51:24.320 --> 51:27.600]  Это применяется тогда, когда объект, к поведению которого
[51:27.600 --> 51:30.800]  действительно может меняться кардинально от состояния,
[51:30.800 --> 51:34.000]  то есть, допустим, если у нас заказ доставлен, то
[51:34.000 --> 51:37.520]  обратно мы, то следующее состояние, которое у нас
[51:37.520 --> 51:40.000]  может быть для этого заказа, это только вернуть его в
[51:40.000 --> 51:42.120]  изначальную точку, если его не забрали в течение
[51:42.120 --> 51:43.120]  какого-то времени.
[51:43.120 --> 51:48.880]  Вот, и у нас возможно, что в этом коде, как ни странно,
[51:48.880 --> 51:52.360]  ИФОВ будет минимальное количество, потому что обычно
[51:52.360 --> 51:53.920]  что бы мы сделали?
[51:53.920 --> 51:57.800]  Если цвет желтый впереди в зеленый, если цвет зеленый
[51:57.800 --> 52:02.680]  впереди в красный, здесь ИФОВ не будет в этой реализации,
[52:02.680 --> 52:05.480]  а один ИФОВ будет, когда нам нужно сделать какую-то
[52:05.480 --> 52:06.480]  развилку.
[52:06.480 --> 52:12.680]  Вот, и, значит, плюс и минус.
[52:12.680 --> 52:16.520]  Избегаем много ИФОВ, значит, концентрация кода у нас
[52:16.520 --> 52:19.680]  в одному состоянию, бизнес-логика на каждом состоянии у нас
[52:19.680 --> 52:21.960]  отделяется от бизнес-логики светофора, то есть мы с
[52:21.960 --> 52:27.520]  вами как бы уменьшаем связанность класса, и причем
[52:27.520 --> 52:29.400]  увеличиваем к ахижам.
[52:29.400 --> 52:33.280]  Вот, но сразу скажу, что опять же у нас принцип какой
[52:33.280 --> 52:38.480]  основной до тех пор, пока мы применяем паттерны.
[52:38.480 --> 52:45.320]  Давайте вспоминать, какие аббревиатуры мы с вами проходили.
[52:45.320 --> 52:51.000]  Да, здесь кис, keep it simple-stupid, и что говорит keep it simple-stupid,
[52:51.000 --> 52:54.320]  говорит, что не надо делать паттерн состояния, когда
[52:54.320 --> 52:55.600]  условия совсем простые.
[52:56.600 --> 53:03.760]  И, кстати, есть еще одна концепция, примеру использования
[53:03.760 --> 53:07.180]  кис, есть анти-паттерн один.
[53:07.180 --> 53:10.180]  Он называется, знаете как?
[53:10.180 --> 53:14.320]  Он очень интересный называется, называется чрезмерное использование
[53:14.320 --> 53:19.340]  паттернов, то есть анти-паттерн против чрезмерного использования
[53:19.340 --> 53:20.340]  паттернов.
[53:20.340 --> 53:22.200]  Ну, то есть не надо, если вы можете какие-то простые
[53:22.200 --> 53:25.240]  концепции использовать, то почему, зачем вам использовать
[53:25.240 --> 53:26.240]  паттерны?
[53:26.240 --> 53:30.880]  У вас как бы янам вполне для хранения типов транспорта
[53:30.880 --> 53:32.920]  здесь вот в нашем примере нужны.
[53:32.920 --> 53:37.200]  Так, понятен ли паттерн состояние?
[53:37.200 --> 53:48.260]  Да, скорее всего, если у вас там светофор не на
[53:48.260 --> 53:51.060]  какую-нибудь сковородку с кучей развилок.
[53:51.060 --> 53:58.980]  А если уже светофор сложный, то лучше, конечно же, переключать
[53:58.980 --> 53:59.980]  состояние.
[53:59.980 --> 54:01.700]  Особенно, если он там регулируем в зависимости от времени
[54:01.700 --> 54:02.700]  суток.
[54:02.700 --> 54:07.620]  Вот, хорошо, значит, про диаграмму состояний.
[54:07.620 --> 54:13.460]  То есть, это визуальная таблица переходов.
[54:13.460 --> 54:24.180]  И последняя диаграмма, как ни странно, вы с ней
[54:24.180 --> 54:25.180]  очень сильно знакомы.
[54:25.180 --> 54:32.060]  Выходили в школу на уроки информатики?
[54:32.060 --> 54:35.060]  Рисовали блок схемы?
[54:35.060 --> 54:40.420]  Ладно, алгоритмы в виде блок схем, типа громбики,
[54:40.420 --> 54:41.940]  кругляшки и так далее.
[54:41.940 --> 54:47.140]  В общем, это организация рабочего процесса.
[54:47.140 --> 54:49.900]  То есть, если вам нужно описать, допустим, что происходит
[54:49.900 --> 54:54.180]  в определенном состоянии, либо прописать конкретную
[54:54.180 --> 54:57.340]  последовательность шагов, в которые мы можем что-то
[54:57.340 --> 55:00.180]  делать для этого, хорошо подходит диаграмма деятельности.
[55:00.180 --> 55:02.180]  Она еще называется Activity Diagram.
[55:02.180 --> 55:06.820]  Здесь пример использования диаграмм деятельности
[55:06.820 --> 55:08.580]  для определенного состояния.
[55:09.380 --> 55:13.580]  Значит, громбик обозначает условия в нашем случае.
[55:13.580 --> 55:18.420]  То есть, если у нас есть неопытные участники в группе, то мы
[55:18.420 --> 55:20.860]  делаем разминку, так сказать.
[55:20.860 --> 55:25.700]  Объясняем проблему, представляем правила игры, вызываем идеи.
[55:25.700 --> 55:31.380]  Если у нас есть идеи, которые можно обработать, тогда мы
[55:31.380 --> 55:33.860]  говорим это, двигаемся дальше.
[55:33.860 --> 55:35.700]  Иначе, типа, предлагаем мысль.
[55:36.380 --> 55:39.060]  Дальше, значит, идея Available.
[55:39.060 --> 55:42.460]  Если у нас несколько идей, то мы записываем их.
[55:42.460 --> 55:47.100]  Если идея одна, то мы делаем вот такой вот штопор.
[55:47.100 --> 55:52.540]  Значит, что здесь обозначает вот эти вот две горизонтальных черточки?
[55:56.820 --> 55:59.780]  Здесь у нас идет презент идея и рекорда идея.
[56:02.340 --> 56:04.500]  Это, как ни странно, параллельное исполнение.
[56:04.900 --> 56:07.740]  То есть, вы параллельно можете записывать идеи и представлять
[56:07.740 --> 56:08.740]  свои идеи.
[56:09.860 --> 56:12.140]  То есть, оно показывает, какие шаги действительно
[56:12.140 --> 56:13.420]  могут быть распараллельны.
[56:13.420 --> 56:16.380]  И это очень удобно для организации процесса.
[56:16.380 --> 56:19.020]  Во-первых, для того, чтобы ускорить работу программы.
[56:19.020 --> 56:21.500]  А во-вторых, для того, чтобы, если вы хотите рабочий
[56:21.500 --> 56:24.700]  процесс наладить, и что-то, если можно распараллелить,
[56:24.700 --> 56:26.660]  то почему бы их не распараллеливать.
[56:26.660 --> 56:29.980]  Вот такая вот вещь здесь, это как раз для конкретного
[56:29.980 --> 56:30.980]  состояния.
[56:30.980 --> 56:32.980]  То есть, можно использовать для организации рабочего
[56:32.980 --> 56:33.980]  процесса.
[56:34.460 --> 56:38.900]  Опять же, после максимальной атомизации всего этого
[56:38.900 --> 56:42.220]  процесса все эти действия превращаются в функции.
[56:44.220 --> 56:48.260]  Если мы говорим про пользователей, то здесь мы можем сделать
[56:48.260 --> 56:49.260]  другую вещь.
[56:49.260 --> 56:51.540]  То есть, как бы сказать, что мы приходим в стартовое
[56:51.540 --> 56:54.940]  состояние какое-то и описываем действие.
[56:54.940 --> 56:58.540]  Если у нас есть что-то, то мы делаем определенный
[56:58.540 --> 56:59.540]  переход.
[57:00.100 --> 57:04.220]  Как раз, опять же, есть эти, либо экземпляры объектов,
[57:04.220 --> 57:08.060]  либо как раз, собственно, действующие лица в вариантах
[57:08.060 --> 57:09.060]  использования.
[57:09.060 --> 57:13.860]  То есть, как раз, мы текстово описываем просто бизнес
[57:13.860 --> 57:16.700]  требования, а здесь мы уже по факту описываем функциональные
[57:16.700 --> 57:19.260]  требования, которые у нас есть в нашем продукте.
[57:19.260 --> 57:23.460]  Вот так выглядят диаграммы деятельности.
[57:23.460 --> 57:26.740]  То есть, если вам сложно разобраться в каком-то
[57:26.740 --> 57:32.060]  процессе, можно вычленить, нарисовать несколько столбиков
[57:32.060 --> 57:34.340]  и попытаться понять, как это происходит.
[57:34.340 --> 57:40.420]  Более того, если мы говорим про большие проекты, то мы
[57:40.420 --> 57:42.980]  можем использовать еще и другие диаграммы.
[57:42.980 --> 57:48.140]  Они обычно называются дорожные карты или диаграммы ГАНТа.
[57:48.140 --> 57:51.300]  Собственно, давайте тоже про это расскажу.
[57:51.300 --> 57:55.740]  Представьте себе, что у вас какой-то есть очень сложный
[57:55.740 --> 57:59.820]  проект, который должен идти долгое время, и тогда
[57:59.820 --> 58:01.100]  вы что делать?
[58:01.100 --> 58:09.500]  Вы разбиваете ваш проект на команду, на определенные
[58:09.500 --> 58:10.500]  стадии.
[58:10.500 --> 58:15.820]  Это такая временная диаграмма, а дальше вы по оси Т делаете
[58:15.820 --> 58:19.820]  следующее.
[58:19.820 --> 58:22.020]  Прописываете, допустим, какие варианты использования
[58:22.020 --> 58:24.540]  вы будете реализовывать со временем.
[58:24.540 --> 58:30.620]  И закрашиваете, допустим, это у нас аналитики, это
[58:30.620 --> 58:38.740]  у нас разработка, допустим, это бэк-энд, это у нас фронт-энд,
[58:38.740 --> 58:42.100]  а это у нас с вами тестирование.
[58:42.100 --> 58:49.540]  И дальше вы обрисовываете, закрашиваете определенные
[58:49.540 --> 58:52.020]  части, когда та или иная команда будет работать.
[58:52.020 --> 58:56.860]  Допустим, сначала мы пишем бэк-энд, потом мы подключаем
[58:56.860 --> 59:00.420]  работу фронт-энда, ну и наконец мы там параллельно начинаем
[59:00.420 --> 59:01.900]  тестировать.
[59:01.900 --> 59:04.620]  Первая процедура, вторая процедура, третья процедура.
[59:04.620 --> 59:08.140]  То есть у вас получается по временной шкале, типа
[59:08.140 --> 59:13.620]  такой а-ля календарь получается, в котором вы можете спокойно
[59:13.620 --> 59:16.300]  ориентироваться и понимать, проходите ли вы сроки или
[59:16.300 --> 59:17.300]  нет.
[59:17.300 --> 59:20.180]  То есть обычно для этих диаграмм даже есть временная шкала,
[59:20.180 --> 59:23.340]  в которой можно отслеживать, где мы находимся на текущий
[59:23.340 --> 59:24.500]  момент и все ли мы успели.
[59:24.500 --> 59:33.740]  Так, понятно это или нет, вот эта диаграмма.
[59:33.740 --> 59:36.420]  То есть вы можете прямо для своего проекта взять
[59:36.420 --> 59:39.780]  и нарисовать такую диаграмму и понять, успеваете ли вы
[59:39.780 --> 59:40.780]  в срок.
[59:40.780 --> 59:43.620]  Или про обучение можете попробовать нарисовать,
[59:43.620 --> 59:47.660]  у вас есть там задание по мотану и вот эту там по
[59:47.660 --> 59:50.420]  мотану, по ТП и так далее, и вот эту временную шкалу
[59:50.420 --> 59:53.180]  нарисовать и понять, типа успеваете ли вы в сроке
[59:53.180 --> 59:55.900]  или у вас есть некоторые проблемы.
[59:55.900 --> 01:00:04.180]  В смысле, а, понял, типа или мы не успеем.
[01:00:04.180 --> 01:00:08.020]  Ну опять же всегда для любого задания есть некоторый процент
[01:00:08.020 --> 01:00:09.020]  выполнения.
[01:00:09.020 --> 01:00:11.140]  То есть если понятно, что начинать все делать на
[01:00:11.140 --> 01:00:15.900]  сто процентов, то конечно же нас отчислят, если попробовать
[01:00:15.900 --> 01:00:17.980]  допустим делать не все на сто процентов, то скорее
[01:00:17.980 --> 01:00:19.780]  всего возможно и нет.
[01:00:19.780 --> 01:00:21.860]  Мы получим более низкую оценку.
[01:00:21.860 --> 01:00:25.260]  Так, давайте следующий диаграмм перейдем, диаграмм
[01:00:25.260 --> 01:00:26.260]  пакетов.
[01:00:26.260 --> 01:00:28.220]  Значит, что такое пакет?
[01:00:28.220 --> 01:00:31.420]  Это набор классов, объединенных по логической сущности.
[01:00:31.420 --> 01:00:35.740]  Значит, пример, кстати, вот здесь вот есть и на нем
[01:00:35.740 --> 01:00:38.340]  видно явно следующая вещь.
[01:00:38.340 --> 01:00:41.780]  У нас структура пакетов здесь и оказывается, что
[01:00:41.780 --> 01:00:48.780]  у вас пакеты, которые есть, допустим, класс COM-A-Бизнес
[01:00:48.780 --> 01:00:52.820]  и есть банк, который взаимодействует с аккаунтингом, ordering,
[01:00:52.820 --> 01:00:56.260]  который вызывает зависимость класса системы аккаунтинг.
[01:00:56.260 --> 01:01:00.300]  И видите, у нас есть шипинг COM-A-Бизнес и шипинг Data
[01:01:00.300 --> 01:01:01.300]  Management.
[01:01:01.300 --> 01:01:04.260]  И видно, что у нас есть стрелочки из одной стороны
[01:01:04.260 --> 01:01:05.260]  в другую.
[01:01:06.020 --> 01:01:08.940]  И здесь у нас возникает в коде так называемая циклическая
[01:01:08.940 --> 01:01:11.260]  зависимость, что компонент A зависит от компонента
[01:01:11.260 --> 01:01:15.540]  B, а компонент B, пакет B зависит от пакета A.
[01:01:15.540 --> 01:01:21.180]  В чем проблема будет этого всего?
[01:01:21.180 --> 01:01:22.180]  Чудо.
[01:01:22.180 --> 01:01:23.180]  А?
[01:01:23.180 --> 01:01:27.740]  Да, будет сложно расширять, все-таки нужно выбрать
[01:01:27.740 --> 01:01:30.020]  более главного действующего лица.
[01:01:30.020 --> 01:01:32.660]  Ладно, если это в одном компоненте происходит, это еще не особо
[01:01:32.660 --> 01:01:33.660]  страшно.
[01:01:33.820 --> 01:01:36.140]  Когда у вас происходит интеграция между этими
[01:01:36.140 --> 01:01:39.340]  компонентами, вам нужно будет закрывать заглушки
[01:01:39.340 --> 01:01:43.540]  в двух местах, то есть два канала информации.
[01:01:43.540 --> 01:01:46.860]  Возможно, что здесь как раз можно переорганизовать.
[01:01:46.860 --> 01:01:52.020]  Смотрите, ordering и шипинг, возможно, что нужно именно
[01:01:52.020 --> 01:01:55.580]  делать запросы на изменение данных, а не использовать
[01:01:55.580 --> 01:01:57.820]  бизнес-логику, то есть не потягивать бизнес-логику.
[01:01:57.820 --> 01:02:01.300]  То есть я бы на этом месте убрал бы стрелки из снизу
[01:02:01.300 --> 01:02:03.460]  вверх, а делал их только сверху вниз.
[01:02:03.460 --> 01:02:08.140]  То есть как бы у нас бизнес управляет данными, а не данные
[01:02:08.140 --> 01:02:09.140]  бизнеса.
[01:02:09.140 --> 01:02:12.500]  А действия все происходят по запросу.
[01:02:12.500 --> 01:02:16.460]  То есть по факту, как ее построить, вы берете ваш
[01:02:16.460 --> 01:02:19.500]  проект, берете структуру директории, которая у вас
[01:02:19.500 --> 01:02:22.700]  есть, и классы, которые в ней есть, и пытаетесь нанести
[01:02:22.700 --> 01:02:23.700]  на диаграммы.
[01:02:23.700 --> 01:02:27.540]  И по факту стрелочка это те инклуды, которые вы используете.
[01:02:27.540 --> 01:02:34.740]  Такая вот визуальная диаграмма, которая вам явно все покажет,
[01:02:34.740 --> 01:02:35.740]  если у вас проблемы.
[01:02:35.740 --> 01:02:41.620]  Так, хорошо.
[01:02:41.620 --> 01:02:46.940]  Есть ли вопрос по этой диаграмме?
[01:02:46.940 --> 01:02:47.940]  Вот.
[01:02:47.940 --> 01:02:51.500]  Значит, когда будет самая простая диаграмма, вопрос
[01:02:51.500 --> 01:02:52.500]  к вам.
[01:02:52.500 --> 01:02:56.620]  В каком случае будет?
[01:02:56.620 --> 01:02:57.620]  Ой, простая диаграмма.
[01:02:57.620 --> 01:03:02.620]  А?
[01:03:02.620 --> 01:03:05.300]  Один пакет, все написали в одном файле.
[01:03:05.300 --> 01:03:09.980]  Ну, понятно, что тогда мы очень долго будем разбираться
[01:03:09.980 --> 01:03:11.900]  в этом коде, потому что у нас никакой поддержимости
[01:03:11.900 --> 01:03:12.900]  не будет.
[01:03:12.900 --> 01:03:15.300]  Так, давайте сейчас следующий диаграмм.
[01:03:15.300 --> 01:03:16.980]  По-моему, это последний из диаграмм, который здесь
[01:03:16.980 --> 01:03:18.900]  есть в этой презентации, это диаграмма компонентов.
[01:03:19.900 --> 01:03:24.340]  Собственно, это, так сказать, большие мазки нашей системы.
[01:03:24.340 --> 01:03:27.180]  То есть это как раз очень будет полезно тем, кто делает
[01:03:27.180 --> 01:03:29.940]  проекты, состоящие из нескольких подсистем.
[01:03:29.940 --> 01:03:33.460]  То есть в каждой из них мы определяем с вами определенную
[01:03:33.460 --> 01:03:34.460]  подсистему.
[01:03:34.460 --> 01:03:36.900]  Здесь, на примере, есть три подсистемы.
[01:03:36.900 --> 01:03:42.300]  Это интернет-магазин, есть warehouse, это склады, есть
[01:03:42.300 --> 01:03:43.300]  система расчета.
[01:03:43.300 --> 01:03:47.940]  И дальше показано, как они взаимодействуют, каким
[01:03:47.940 --> 01:03:49.380]  образом они связаны между собой.
[01:03:49.380 --> 01:03:53.900]  Значит, у нас с вами вот эта вот подсистема, связанная
[01:03:53.900 --> 01:03:57.140]  с веб-магазином, имеет две входных точки.
[01:03:57.140 --> 01:04:00.220]  По факту, эти входные точки — это, так или иначе, наши
[01:04:00.220 --> 01:04:02.540]  варианты использования, которые мы предлагаем нашими
[01:04:02.540 --> 01:04:03.540]  системами.
[01:04:03.540 --> 01:04:08.140]  Значит, у нас есть вариант использования поиска продуктов,
[01:04:08.140 --> 01:04:09.140]  product search.
[01:04:09.140 --> 01:04:10.140]  Мы описываем его каким-то интерфейсом.
[01:04:10.140 --> 01:04:12.980]  Опять же, какие интерфейсы бывают, мы с вами поговорим
[01:04:12.980 --> 01:04:15.860]  чуть попозже, когда мы будем говорить про веб-заимодействие.
[01:04:16.700 --> 01:04:20.820]  И вот здесь как раз есть связь, которая позволяет
[01:04:20.820 --> 01:04:24.380]  нам по факту передать информацию, которая у нас идет с внешнего
[01:04:24.380 --> 01:04:26.540]  интерфейса, внутренний компонент.
[01:04:26.540 --> 01:04:28.460]  Значит, это порт.
[01:04:28.460 --> 01:04:33.820]  То есть, возможно, вы слышали как раз, что когда вы подключаетесь
[01:04:33.820 --> 01:04:36.660]  к интернету к какому-то запросу, вы на самом деле идете по
[01:04:36.660 --> 01:04:41.620]  определенному порту, по протоколу HTTP или HTTPS.
[01:04:42.100 --> 01:04:47.300]  HTTP расшифровывается как HyperText Transfer Protocol, HTTPS расшифровывается
[01:04:47.300 --> 01:04:50.980]  как HyperText Transfer Protocol Secure.
[01:04:50.980 --> 01:04:52.980]  Всегда вы идете по одному из этих протоколов.
[01:04:52.980 --> 01:04:57.060]  И здесь как раз можно явно описывать, какие протоколы
[01:04:57.060 --> 01:04:58.060]  у вас идут.
[01:04:58.060 --> 01:05:02.500]  А дальше у нас идет система заказов веб-магазин, допустим,
[01:05:02.500 --> 01:05:03.500]  онлайн-покупка товаров.
[01:05:03.500 --> 01:05:09.020]  Дальше мы идем в компонент под названием продуктовая
[01:05:09.020 --> 01:05:10.020]  корзина.
[01:05:10.020 --> 01:05:11.860]  Да, это большая компонента.
[01:05:11.860 --> 01:05:17.540]  И дальше она уже идет в подсистему аккаунтинга, зависит от
[01:05:17.540 --> 01:05:19.420]  того, какие заказы у нас есть.
[01:05:19.420 --> 01:05:21.300]  То есть, каким образом мы с вами можем изменять эти
[01:05:21.300 --> 01:05:22.300]  заказы.
[01:05:22.300 --> 01:05:23.300]  Вот.
[01:05:23.300 --> 01:05:28.780]  И дальше они уже дополнительно идут в склад.
[01:05:28.780 --> 01:05:31.940]  То есть, как раз здесь мы видим связи между системами.
[01:05:31.940 --> 01:05:33.780]  Кто, от какой подсистемы зависит.
[01:05:33.780 --> 01:05:38.420]  Понятно, что, кстати, сразу скажу, такой забавный момент,
[01:05:38.420 --> 01:05:44.300]  что вот те связи, которые у нас идут в обычный интернет-магазин,
[01:05:44.300 --> 01:05:47.820]  вот отсюда, они отличаются от тех связей, которые производят
[01:05:47.820 --> 01:05:48.820]  здесь.
[01:05:48.820 --> 01:05:54.060]  То есть, мы здесь, вот, в части взаимодействия зависимости
[01:05:54.060 --> 01:05:55.820]  можем делать все, что угодно.
[01:05:55.820 --> 01:05:57.660]  Мы можем, в принципе, на одном и том же компьютере
[01:05:57.660 --> 01:05:59.620]  расположить эти компоненты.
[01:05:59.620 --> 01:06:03.500]  Но самое важное зачастую, что вот сейчас в современных
[01:06:03.500 --> 01:06:06.500]  реалиях разные компоненты системы располагаются
[01:06:06.580 --> 01:06:07.580]  на разных компьютерах.
[01:06:07.580 --> 01:06:12.740]  То есть, у вас есть один сервис, это называется сервисами.
[01:06:12.740 --> 01:06:15.780]  У вас есть сервис как раз по веб-магазину, у вас есть
[01:06:15.780 --> 01:06:18.900]  сервис по складам, у вас есть сервис по аккаунтингу.
[01:06:18.900 --> 01:06:19.900]  Вот.
[01:06:19.900 --> 01:06:23.300]  И связь между ними может быть настроена по одному
[01:06:23.300 --> 01:06:24.300]  из протоколов.
[01:06:24.300 --> 01:06:28.180]  Вы можете там файлами обмениваться, положить его куда-то в
[01:06:28.180 --> 01:06:32.140]  общее хранилище, либо там отправить запрос по сети.
[01:06:32.300 --> 01:06:37.500]  Либо еще как-нибудь это очень забавный кейс, вы просто
[01:06:37.500 --> 01:06:40.940]  идете ручками, значит, печатаете вот эти вот все запросы и
[01:06:40.940 --> 01:06:43.340]  тащите их в другой компонент.
[01:06:43.340 --> 01:06:48.100]  Вбиваете их ручками и все у вас работает.
[01:06:48.100 --> 01:06:52.020]  То есть, понятно, что когда у нас тестовые заглушки,
[01:06:52.020 --> 01:06:54.260]  тестовые сценарии, то понятно, что нам нужно будет делать
[01:06:54.260 --> 01:06:57.820]  заглушки для того, чтобы это у нас все работало.
[01:06:57.820 --> 01:07:00.900]  То есть, это вот такая большая-большая диаграмма, на которой
[01:07:00.900 --> 01:07:03.820]  прямо видно структура всей вашей системы.
[01:07:03.820 --> 01:07:11.060]  Потом мы ее уже бьем на классы и дальше уже смотрим
[01:07:11.060 --> 01:07:14.540]  на наше поведение между этими объектами.
[01:07:14.540 --> 01:07:19.180]  Здесь, кстати, диаграмма достаточно хорошая, то есть
[01:07:19.180 --> 01:07:21.220]  у нас нет никаких циклических зависимостей.
[01:07:21.220 --> 01:07:27.300]  Так, вот такая большая диаграмма.
[01:07:27.300 --> 01:07:33.500]  И здесь как раз мы можем вспомнить наш паттерн-адаптер,
[01:07:33.500 --> 01:07:36.020]  потому что каждую из связей, которые у нас есть, желательно
[01:07:36.020 --> 01:07:38.740]  делать при помощи адаптеров, чтобы, если что, мы могли
[01:07:38.740 --> 01:07:42.260]  легко поменять наш протокол, взаимодействие.
[01:07:42.260 --> 01:07:48.180]  Так, все, это что касается паттернов, ой, диаграмм,
[01:07:48.180 --> 01:07:49.700]  давайте вопросы по ЮМЛю.
[01:07:49.700 --> 01:08:09.540]  Смотрите, давайте достаточно простой пример, допустим,
[01:08:09.540 --> 01:08:14.620]  если у нас очень простой сценарий в нашем системе.
[01:08:14.620 --> 01:08:20.500]  Давайте тогда, сейчас напишу, во-первых, классы точно
[01:08:20.500 --> 01:08:23.420]  нужны, диаграмма классов, варианты использования
[01:08:23.420 --> 01:08:24.420]  тоже нужны.
[01:08:24.420 --> 01:08:32.820]  Значит, если вариант использования, так сказать, достаточно
[01:08:32.820 --> 01:08:36.220]  несложный, полезно нарисовать либо диаграмму деятельности
[01:08:36.220 --> 01:08:39.820]  либо диаграмму последности, то есть они друг друга взаимозаменяют.
[01:08:40.380 --> 01:08:45.340]  То есть она, диаграмма деятельности показывает большую часть,
[01:08:45.340 --> 01:08:49.300]  как у нас объекты существуют между собой, как актеры,
[01:08:49.300 --> 01:08:50.300]  как акторы.
[01:08:50.300 --> 01:08:55.660]  То есть, если у вас в системе много пользователей и каким-то
[01:08:55.660 --> 01:08:57.700]  образом они обмениваются информацией, лучше все-таки
[01:08:57.700 --> 01:08:59.340]  использовать диаграмму деятельности.
[01:08:59.340 --> 01:09:02.660]  Если у вас в системе мало акторов, но при этом у вас
[01:09:02.660 --> 01:09:07.260]  есть какой-то сложный алгоритм, именно сложный алгоритм
[01:09:07.300 --> 01:09:09.580]  вызова сообщений, то для этого лучше использовать
[01:09:09.580 --> 01:09:10.580]  диаграмму последностей.
[01:09:10.580 --> 01:09:15.540]  Если у вас есть система, в которой есть что-то напоминает
[01:09:15.540 --> 01:09:18.500]  состояние, переключение этих состояний, то мы можем
[01:09:18.500 --> 01:09:19.980]  использовать диаграмму состояний.
[01:09:19.980 --> 01:09:23.740]  И если, допустим, у нас эти состояния переключаются
[01:09:23.740 --> 01:09:26.820]  по каким-то триггерам, то для этого у вас состояние
[01:09:26.820 --> 01:09:29.660]  можно нарисовать диаграмму деятельности.
[01:09:29.660 --> 01:09:34.700]  В конце, если у вас система очень большая, и у вас это
[01:09:34.700 --> 01:09:37.980]  не какая-то простая игра, то, опять же, нужно сначала
[01:09:37.980 --> 01:09:40.500]  придумать, собственно, вот облачную архитектуру,
[01:09:40.500 --> 01:09:44.540]  попытаться разбить большие блоки на маленькие компоненты
[01:09:44.540 --> 01:09:46.140]  и дальше двигаться по ним.
[01:09:46.140 --> 01:09:49.220]  Но в нашем проекте я сразу советую, в наших проектах
[01:09:49.220 --> 01:09:52.540]  я сразу советую не использовать диаграмму компонентов,
[01:09:52.540 --> 01:09:55.820]  потому что вы сначала застрелитесь, вам сначала нужно маленькую
[01:09:55.820 --> 01:09:59.340]  логику проработать, а потом уже думать по этой маленькой
[01:09:59.340 --> 01:10:01.860]  логике, как это все бьется на отдельные компоненты.
[01:10:02.820 --> 01:10:06.620]  Пока что у нас просто знаний нет для того, чтобы соорудить
[01:10:06.620 --> 01:10:08.180]  большой проект с компонентами.
[01:10:08.180 --> 01:10:13.540]  Надо разбираться в веб-заимодействии, в базах данных, в транзакционности
[01:10:13.540 --> 01:10:16.180]  и других разных вещах протоколов.
[01:10:16.180 --> 01:10:18.340]  Поэтому мы пока живем на уровне бизнес-логики, и
[01:10:18.340 --> 01:10:20.620]  в нашем случае как раз будет достаточно, то есть если
[01:10:20.620 --> 01:10:24.100]  вы не работаете в проекте в несколько человек, то
[01:10:24.100 --> 01:10:28.900]  будет достаточно сейчас диаграммы классов, диаграммы
[01:10:28.900 --> 01:10:31.420]  классов, диаграмма вариантов использования.
[01:10:31.420 --> 01:10:33.540]  И для бизнес-логики будет достаточно диаграмма
[01:10:33.540 --> 01:10:36.460]  вариантов последовательств, диаграмма последовательств,
[01:10:36.460 --> 01:10:37.460]  этого вполне будет достаточно.
[01:10:41.180 --> 01:10:43.940]  Так, давайте еще вопрос, спасибо за вопрос, да, действительно
[01:10:43.940 --> 01:10:44.940]  полезно.
[01:10:44.940 --> 01:10:45.940]  Я ответил на него?
[01:10:45.940 --> 01:10:46.940]  Да.
[01:10:52.460 --> 01:10:53.460]  Хорошо.
[01:10:54.900 --> 01:10:57.220]  Давайте тогда я сделаю затравку некоторую на следующую
[01:10:57.220 --> 01:10:58.220]  лекцию.
[01:10:58.420 --> 01:11:03.580]  Значит, в следующие две лекции, даже две с половиной, мы
[01:11:03.580 --> 01:11:05.540]  будем говорить про одну интересную тему.
[01:11:05.540 --> 01:11:11.900]  Это тема тестирования ПО, то есть пока что мы с вами
[01:11:11.900 --> 01:11:16.660]  только разрабатывали ПО и говорили про архитектуру,
[01:11:16.660 --> 01:11:19.380]  но мы пока вообще ни разу не говорили про то, как его
[01:11:19.380 --> 01:11:20.380]  тестировать.
[01:11:20.380 --> 01:11:26.420]  Что у вас возникает при понятии тестирования, когда
[01:11:26.420 --> 01:11:28.020]  я говорю тестирование?
[01:11:28.020 --> 01:11:31.020]  Чего-чего тестировать?
[01:11:31.020 --> 01:11:32.020]  Ага.
[01:11:32.020 --> 01:11:44.020]  Это уже продвинутая мысль.
[01:11:44.020 --> 01:11:51.020]  Да, некоторые уже знают, что такое юнит-тест.
[01:11:51.020 --> 01:11:52.020]  Да.
[01:11:52.620 --> 01:12:01.900]  Ну да, по которым он выполняет определенные действия.
[01:12:01.900 --> 01:12:07.300]  На самом деле, давайте так скажу, что вы понимаете
[01:12:07.300 --> 01:12:08.820]  под понятием тестирующей системы.
[01:12:08.820 --> 01:12:16.820]  Да, сравнивать желаемое состояние с получаемым.
[01:12:16.820 --> 01:12:19.940]  То есть обычно, когда мы говорим про тестирование,
[01:12:19.940 --> 01:12:22.500]  мы думаем, что у нас есть какая-то программа, по каким-то
[01:12:22.500 --> 01:12:24.500]  входам мы получаем какие-то выходы.
[01:12:24.500 --> 01:12:25.500]  И все.
[01:12:25.500 --> 01:12:30.340]  Но на самом деле, тестирование – это намного большая структурная
[01:12:30.340 --> 01:12:32.820]  вещь, которую нам детально нужно разобрать.
[01:12:32.820 --> 01:12:36.700]  Я сейчас начну с некоторой большой картинки про то,
[01:12:36.700 --> 01:12:39.180]  какие виды тестирования бывают.
[01:12:39.180 --> 01:12:40.180]  Готовы?
[01:12:40.180 --> 01:12:41.180]  Картинка.
[01:12:41.180 --> 01:12:47.060]  Значит, давайте я ее сейчас буду увеличивать у себя.
[01:12:47.060 --> 01:12:52.060]  Такие виды тестирования существуют.
[01:12:52.060 --> 01:12:57.740]  Значит, мы с вами сначала пойдем в наших лекциях говорить
[01:12:57.740 --> 01:12:59.700]  про уровни тестирования.
[01:12:59.700 --> 01:13:01.260]  Что означает уровни тестирования?
[01:13:01.260 --> 01:13:04.900]  То есть мы тестируем свои модули, мы с вами тестируем
[01:13:04.900 --> 01:13:08.500]  взаимодействие между компонентами, либо всю программу целиком,
[01:13:08.500 --> 01:13:11.060]  либо всю программу целиком в реальных условиях.
[01:13:11.060 --> 01:13:12.260]  Это приемочные тестирования.
[01:13:12.260 --> 01:13:13.860]  Про это мы будем говорить в следующий раз.
[01:13:14.720 --> 01:13:19.000]  Дальше важно, чтобы вы понимали, как это все работает.
[01:13:19.000 --> 01:13:21.660]  По объекту тестирования, по предмету тестирования.
[01:13:21.660 --> 01:13:24.880]  И здесь как раз разделяются тестирования функциональных
[01:13:24.880 --> 01:13:27.140]  требований и нефункциональных требований.
[01:13:27.140 --> 01:13:31.340]  Значит, давайте поговорим, что мы просто можем тестировать
[01:13:31.340 --> 01:13:32.740]  в функциональных требованиях.
[01:13:32.740 --> 01:13:41.020]  ой, я все сломал, так, вот, значит, что мы можем тестировать?
[01:13:41.020 --> 01:13:44.620]  Мы можем тестировать функциональности, то есть как раз выполняется
[01:13:44.620 --> 01:13:48.040]  ли у нас бизнес требования, которые прописали, и выполняются
[01:13:48.040 --> 01:13:51.820]  ли основные сценарии в вариантах использования.
[01:13:51.820 --> 01:13:54.820]  Дальше мы можем тестировать безопасность, то есть это
[01:13:54.820 --> 01:13:59.180]  доступа, то есть, что, грубо говоря, если вы заходите
[01:13:59.180 --> 01:14:03.820]  по паролю, можете ли вы его перебрать, включена
[01:14:03.820 --> 01:14:06.220]  ли у вас двухфакторная аутентификация, хотя это
[01:14:06.220 --> 01:14:08.900]  больше про нефункциональные требования, и вы можете
[01:14:08.900 --> 01:14:12.300]  дополнительно проверить, тестировать совместимость
[01:14:12.300 --> 01:14:16.740]  ваших версий продукта, то есть вы завещаете, допустим,
[01:14:16.740 --> 01:14:20.380]  говорите, что у вас компьютер должен работать на таких-то
[01:14:20.380 --> 01:14:23.820]  ресурсах, действительно ли он запускает наш продукт
[01:14:23.820 --> 01:14:25.780]  на определенных ресурсах.
[01:14:25.780 --> 01:14:28.420]  Дополнительно вы можете проверить, что у вас пользователи
[01:14:28.820 --> 01:14:31.940]  такими-то правами должны иметь доступ, а пользователи
[01:14:31.940 --> 01:14:34.560]  такими-то правами не должны иметь доступ, это как раз
[01:14:34.560 --> 01:14:36.800]  тестирование доступности, и вот это все включается
[01:14:36.800 --> 01:14:40.740]  в функциональные тестирования, а все остальное, это нефункциональные
[01:14:40.740 --> 01:14:43.960]  тестирования, и как раз здесь можно понять, что является
[01:14:43.960 --> 01:14:47.200]  нефункциональными требованиями.
[01:14:47.200 --> 01:14:50.340]  Здесь кстати, важно подчеркнуть, что именно когда мы говорим
[01:14:50.340 --> 01:14:55.840]  про security, это security и access control, это функциональные
[01:14:55.840 --> 01:15:01.140]  что ваши данные не утекают, что у вас все не разваливается.
[01:15:01.140 --> 01:15:04.140]  Значит, теперь давайте поговорим про нефункциональные требования.
[01:15:04.140 --> 01:15:07.340]  Первое нефункциональное требование это интерфейс пользователя.
[01:15:07.340 --> 01:15:13.740]  Что это означает? Это означает, что если у вас в функциональных требованиях написано,
[01:15:13.740 --> 01:15:18.840]  что вот у вас система должна делать такие-то действия A, B, C, D, E.
[01:15:18.840 --> 01:15:25.740]  А потом вы такие думаете, нам бы хотелось, чтобы пользователи с точки зрения бизнеса
[01:15:25.740 --> 01:15:31.740]  с правил получали красивые окошки для того, что на них можно было удобно тыкать.
[01:15:31.740 --> 01:15:39.740]  Или если вы покупаете какой-то товар, то у вас есть корзина отрисованная, прямо картиночка.
[01:15:39.740 --> 01:15:43.740]  И вот вы тестируете, насколько удобно вам пользоваться этим интерфейсом.
[01:15:43.740 --> 01:15:52.740]  Я не знаю, видел ли кто-то из вас, как выглядят разные системы по поводу того,
[01:15:52.740 --> 01:15:54.740]  когда вы покупаете товар в магазине.
[01:15:54.740 --> 01:15:58.740]  Вот у вас мобильное приложение выглядит очень красиво.
[01:15:59.740 --> 01:16:04.740]  Кнопочки там, все такое. А что происходит с обратной стороны?
[01:16:08.740 --> 01:16:13.740]  Ну либо 1S какой-нибудь стоит, либо...
[01:16:16.740 --> 01:16:21.740]  Там есть системы про онлайн-кассы, где у вас прям просто некоторый набор кнопок,
[01:16:21.740 --> 01:16:24.740]  вы тыкаете кнопки и дальше у вас что-то пробивается.
[01:16:24.740 --> 01:16:28.740]  То есть там никакого интерфейса нету, user-friendly.
[01:16:28.740 --> 01:16:31.740]  Хотя функциональные требования выполнены.
[01:16:31.740 --> 01:16:36.740]  То есть некоторые, наоборот, отказываются от удобства интерфейс-спользования.
[01:16:36.740 --> 01:16:39.740]  Следующее тестирование – тестирование локализации.
[01:16:39.740 --> 01:16:44.740]  И давайте я как раз проведу тест по локализации и его сломаю.
[01:16:45.740 --> 01:16:49.740]  Я скажу, что система не проходит тестирование локализации.
[01:16:51.740 --> 01:16:53.740]  Так, ну давайте тестировать.
[01:16:53.740 --> 01:16:56.740]  Тестирую локализацию, тестирую и на переход на другой язык.
[01:16:58.740 --> 01:16:59.740]  Пока работает, да?
[01:17:02.740 --> 01:17:03.740]  Да, ну перевода нет.
[01:17:04.740 --> 01:17:06.740]  Здесь вроде тоже все окей.
[01:17:07.740 --> 01:17:08.740]  Идем в курсы.
[01:17:10.740 --> 01:17:12.740]  Где курс по ТП?
[01:17:15.740 --> 01:17:17.740]  Так, тест-таск все отлично.
[01:17:21.740 --> 01:17:24.740]  Все, тестирование локализации провалено.
[01:17:32.740 --> 01:17:35.740]  Да, мы не перевели задание на английский язык.
[01:17:38.740 --> 01:17:40.740]  Да, жаль, жаль, жаль, жаль.
[01:17:41.740 --> 01:17:43.740]  Здесь тоже не перевели.
[01:17:44.740 --> 01:17:46.740]  Здесь тоже, здесь тоже.
[01:17:46.740 --> 01:17:48.740]  Надо будет заняться.
[01:17:49.740 --> 01:17:51.740]  Вот мы провалили тестирование локализации.
[01:17:51.740 --> 01:17:55.740]  Опять же, в зависимости от того, куда вы заходите, у вас может быть разная вещь.
[01:17:55.740 --> 01:17:59.740]  Допустим, на Фистехе, кстати, раньше была такая забавная особенность,
[01:17:59.740 --> 01:18:02.740]  что русскоязычная версия сайта отличалась от англоязычной.
[01:18:04.740 --> 01:18:08.740]  Причем самое забавное было, что русская версия сайта открывается по адресу mip-true,
[01:18:08.740 --> 01:18:11.740]  а английская у вас идет переадресаться на фистех.edu.
[01:18:12.740 --> 01:18:17.740]  Я не знаю, осталось это сейчас или нет, но такое есть.
[01:18:17.740 --> 01:18:21.740]  Дальше у нас с вами идет тестирование скорости и надежности.
[01:18:21.740 --> 01:18:24.740]  И здесь тоже выделяют разные виды тестирования.
[01:18:24.740 --> 01:18:27.740]  Это либо тестирование производительности,
[01:18:27.740 --> 01:18:30.740]  либо стресс-тестирование, либо нагрузочное тестирование.
[01:18:33.740 --> 01:18:35.740]  Давайте поговорим про следующее.
[01:18:36.740 --> 01:18:40.740]  Да, кстати, я забыл выделить, что есть UI-тестирование.
[01:18:40.740 --> 01:18:42.740]  То есть вы проверяете, что у вас кнопки работают.
[01:18:42.740 --> 01:18:45.740]  Несмотря на то, что вы когда нажимаете на кнопки,
[01:18:45.740 --> 01:18:48.740]  под капотом на самом деле идут запросы по сети.
[01:18:48.740 --> 01:18:51.740]  То есть вы можете в принципе вашу систему проверять
[01:18:51.740 --> 01:18:53.740]  с точки зрения нажатия кнопок на запросы.
[01:18:53.740 --> 01:18:57.740]  А есть тестирование, так сказать, удобства использования.
[01:18:57.740 --> 01:19:00.740]  То есть все, что у вас кнопки красивые, и они правильно отрисованы.
[01:19:00.740 --> 01:19:03.740]  Допустим, есть ли у вас версия для слабовидящих.
[01:19:04.740 --> 01:19:06.740]  Это очень важно.
[01:19:08.740 --> 01:19:11.740]  А тестирование надежности и скорости, если мы говорим,
[01:19:11.740 --> 01:19:13.740]  они тоже бывают разными.
[01:19:13.740 --> 01:19:17.740]  И давайте я сейчас вам покажу пример
[01:19:20.740 --> 01:19:22.740]  того, как это происходит.
[01:19:25.740 --> 01:19:27.740]  Вы можете делать следующую вещь.
[01:19:31.740 --> 01:19:34.740]  Вы с момента времени t можете увеличивать количество запросов
[01:19:34.740 --> 01:19:38.740]  на ваш сайт, на любой ваш сервис.
[01:19:38.740 --> 01:19:40.740]  Опять же, это говорится про функциональные.
[01:19:40.740 --> 01:19:43.740]  Значит, смотрите, в чем заключается стресс-тестирование.
[01:19:43.740 --> 01:19:47.740]  Вы начинаете увеличивать постепенно нагрузку на сайт.
[01:19:51.740 --> 01:19:57.740]  Знакомые с этим, с термином запас прочности,
[01:19:57.740 --> 01:20:00.740]  прочность системы, это физическое понятие.
[01:20:00.740 --> 01:20:03.740]  То есть это максимальная сила, которую нужно приложить
[01:20:03.740 --> 01:20:07.740]  на объект, которая разломает этот объект пополам.
[01:20:07.740 --> 01:20:09.740]  Что происходит в стресс-тестировании?
[01:20:09.740 --> 01:20:12.740]  Вы пытаетесь увеличить нагрузку на вашу систему
[01:20:12.740 --> 01:20:15.740]  и ищете первый момент, когда оно у вас сломается.
[01:20:17.740 --> 01:20:19.740]  Когда у вас сайт перестанет работать.
[01:20:21.740 --> 01:20:24.740]  Отмечаете этот момент, а дальше вы проверяете,
[01:20:24.740 --> 01:20:26.740]  стабильно ли ваша система работает под этой нагрузкой.
[01:20:26.740 --> 01:20:28.740]  То есть вы снижаете уровень нагрузки
[01:20:28.740 --> 01:20:31.740]  и начинаете постоянно прогонять эту нагрузку.
[01:20:31.740 --> 01:20:33.740]  Смотрите, какое количество ошибок у вас прилетит.
[01:20:41.740 --> 01:20:43.740]  Давайте проверим.
[01:20:47.740 --> 01:20:50.740]  Опять же, тут нужно отправлять количество запросов.
[01:20:50.740 --> 01:20:55.740]  У кого есть компуктер под руками?
[01:20:55.740 --> 01:20:58.740]  Я сейчас выполню этот запрос.
[01:20:59.740 --> 01:21:02.740]  Утилита АБ на Apache Benchmark.
[01:21:02.740 --> 01:21:06.740]  Я сейчас буду отправлять 5000 запросов на сайтах check
[01:21:06.740 --> 01:21:09.740]  с календарной стресс-тестировкой.
[01:21:09.740 --> 01:21:12.740]  У меня тут есть дополнительный патрон.
[01:21:12.740 --> 01:21:15.740]  Я буду использовать его для расписания터�ов.
[01:21:15.740 --> 01:21:18.740]  Утилита АБ на Apache Benchmark.
[01:21:18.740 --> 01:21:21.740]  Я сейчас буду отправлять 5000 запросов на сайтах check
[01:21:21.740 --> 01:21:23.740]  с календарной стресс-тестировкой.
[01:21:23.740 --> 01:21:27.240]  только с из 24-х потоков
[01:21:36.240 --> 01:21:37.740]  slash нужно добавить
[01:21:37.740 --> 01:21:55.740]  а вот кстати защита от ботов стоит по-моему сейчас 20 тысяч в месяц базовая
[01:21:55.740 --> 01:22:02.440]  если смотреть кажется мы это даже в чате с пренями обсуждали в комнате наших для преней
[01:22:02.440 --> 01:22:10.940]  вот ну что мы видим с вами мы видим с вами что в принципе основная страница курса сайта загружается
[01:22:10.940 --> 01:22:17.940]  где-то за 233 запросов в секунду переживает вот и при этом здесь мы можем с вами видеть
[01:22:17.940 --> 01:22:23.140]  квантили распределение то есть получается в 99 процентах случаев сайт открывается не больше
[01:22:23.140 --> 01:22:31.640]  чем за 126 миллисекунд вот основная страница собственно если мы хотим провести нагрузочное
[01:22:31.640 --> 01:22:36.140]  тестирование то нам надо дать большее количество запросов большое количество запросов и отправляйте их
[01:22:36.140 --> 01:22:42.440]  в постепенном потоке есть специальные инструменты для нагрузочного тестирования кто-нибудь еще
[01:22:42.440 --> 01:22:59.980]  запустил команду там минус ц количество запад этих ядер на своем компьютере и слэш в конце нужно
[01:22:59.980 --> 01:23:13.140]  не забыть что запустили скажите когда запустите на гитлап действительно часто падает
[01:23:13.140 --> 01:23:21.820]  но надо увеличить нагрузку на ахчек то я увеличил нагрузку она гитлап то не очень
[01:23:21.820 --> 01:23:38.320]  о помог тут мне ну либо не запустили либо это а в общем видно что 24 запроса вполне выдерживает
[01:23:38.320 --> 01:23:45.420]  там я думаю сейчас пик где-то под 200 под 500 запросов вот выдержит в принципе этого достаточно
[01:23:45.420 --> 01:23:54.580]  для наших бизнес целей вот 180 миллисекунд в принципе достаточно и тестирование совместимости
[01:23:54.580 --> 01:24:02.780]  это показывает следующее что вы вас система запускается на операционной системе не ниже
[01:24:02.780 --> 01:24:09.660]  такой-то такой-то такой-то то есть это то что обычно выносит системные требования вот значит
[01:24:09.660 --> 01:24:17.380]  у нас сегодня лекции конец значит следующий раз мы как раз будем смотреть уровни тестирования вот
[01:24:17.380 --> 01:24:23.220]  и дополнительно будем разбирать какие методы тестирования по доступности кода существует
[01:24:23.220 --> 01:24:33.980]  все значит если есть вопросы задавайте спасибо
