[00:00.000 --> 00:10.320]  Значит, у нас сегодня две задачки.
[00:10.320 --> 00:13.800]  Первая – это проверка принадлежности точки многоугольнику.
[00:13.800 --> 00:33.720]  Задача очень просто ставится.
[00:33.720 --> 00:36.120]  Есть некий многоугольник, не обязательно выпуклый.
[00:36.120 --> 00:38.200]  Есть какая-то точка на плоскости.
[00:38.200 --> 00:40.360]  Нужно для неё понять, лежит она внутри многоугольника
[00:40.360 --> 00:41.360]  или не внутри.
[00:41.360 --> 00:47.880]  Первый способ, ну, нулевой способ, который не всегда
[00:47.880 --> 00:50.680]  работает только в случае, если многоугольник выпуклый.
[00:50.680 --> 01:01.560]  Выпуклый многоугольник.
[01:01.560 --> 01:03.920]  Тогда можно сделать следующую штуку.
[01:03.920 --> 01:07.040]  Давайте считать, что у нас многоугольник так задан,
[01:07.040 --> 01:11.040]  что его нулевая вершина – это левая нижняя.
[01:11.040 --> 01:12.920]  Ну, как обычно, когда мы строим какую-нибудь выпуклую
[01:12.920 --> 01:16.280]  оболочку, у нас всегда нулевая точка – это самая левая
[01:16.280 --> 01:18.240]  среди таких самая нижняя.
[01:18.240 --> 01:19.240]  Вот.
[01:19.240 --> 01:24.120]  Тогда давайте нарисуем вот такие вот лучи из нулевой
[01:24.120 --> 01:26.040]  точки во все вершины многоугольника.
[01:26.040 --> 01:33.800]  И попытаемся понять, в каком из образовавшихся углов
[01:33.800 --> 01:34.800]  лежит наша точка.
[01:34.800 --> 01:39.080]  Соответственно, эта точка лежит в этом угле между
[01:39.080 --> 01:40.760]  вот такими двумя лучами.
[01:40.760 --> 01:42.960]  Это можно очень легко сделать бинпоиском, потому что вот
[01:42.960 --> 01:48.400]  у вас есть такой развернутый угол, внутри которого точно
[01:48.400 --> 01:49.400]  точка должна лежать.
[01:49.400 --> 01:51.720]  Если она, заведомо, не внутри этого угла, то, значит,
[01:51.720 --> 01:53.480]  она точно не в многоугольнике.
[01:53.480 --> 01:56.360]  Дальше вы бьётесь пополам, скажем, вот берёте середину,
[01:56.360 --> 01:58.600]  проверяете, она лежит здесь или здесь, ну и, соответственно,
[01:58.600 --> 01:59.600]  переходите либо сюда, либо сюда.
[01:59.600 --> 02:02.480]  Да, поэтому просто бинпоиском однозначно можете за алгорифм
[02:02.480 --> 02:05.040]  понять, между какими двумя соседними лучами должна
[02:05.040 --> 02:06.040]  точка лежать.
[02:06.040 --> 02:08.440]  Дальше, если вы поняли, какие два соседние луча
[02:08.440 --> 02:11.200]  вам нужны, в конце вам нужно просто проверить, лежит
[02:11.200 --> 02:12.400]  ли точка вот в таком треугольнике.
[02:12.400 --> 02:16.200]  Но проверить точку на параллельность треугольника уж как-нибудь
[02:16.200 --> 02:17.200]  мы сможем.
[02:17.200 --> 02:20.040]  Да, значит, кратко давайте напишем.
[02:20.040 --> 02:25.480]  Рассматриваем все лучи из нулевой точки, из нулевой
[02:25.480 --> 02:44.680]  вершины, бинпоиском находим два соседних, между которыми
[02:44.680 --> 02:46.440]  должна лежать точка, ну, точнее, между которыми
[02:46.440 --> 02:47.440]  она лежит.
[02:47.440 --> 03:12.960]  И в конце проверяем, что точка лежит в треугольнике.
[03:12.960 --> 03:21.800]  А симптотика – алгорифм, потому что просто бинпоиска
[03:21.800 --> 03:23.880]  здесь внутри от единички, нам нужно, чтобы проверить,
[03:23.880 --> 03:24.880]  что лежит на треугольнике.
[03:24.880 --> 03:32.360]  Значит, способ чуть лучше, а оно тоже не идеальный.
[03:32.360 --> 03:37.080]  Значит, теперь уже все, мы отказываемся от предположения,
[03:37.080 --> 03:38.080]  что многоугольник выпуклый.
[03:38.080 --> 03:40.120]  Первый многоугольник может быть любой, но на самом
[03:40.120 --> 03:43.080]  случае выпуклого многоугольника вот мы решили, и это самый
[03:43.080 --> 03:48.720]  крутой алгоритм, лучше мы не надеемся ничего получить.
[03:48.720 --> 03:50.080]  Значит, что делать с невыпуклым?
[03:50.080 --> 03:51.960]  Можно, например, сделать следующее.
[03:51.960 --> 04:01.040]  Давайте мы порисуем те углы, под которыми видны
[04:01.040 --> 04:04.200]  стороны нашего многоугольника, причем эти углы будем считать
[04:04.200 --> 04:05.200]  ориентированными.
[04:05.200 --> 04:06.480]  То есть мы пройдемся по границе многоугольника
[04:06.480 --> 04:09.240]  по всем сторонам и будем мерить вот эти уголочки.
[04:09.320 --> 04:13.880]  Вот этот угол проверяем, вот этот угол, вот этот,
[04:13.880 --> 04:14.660]  вот этот.
[04:15.260 --> 04:17.100]  Вот этот у нас будет с отрицательным знаком.
[04:17.100 --> 04:19.980]  Потому что мы начнем вращаться в другую сторону, потом
[04:19.980 --> 04:22.480]  этот опять с плюсом, этот опять с плюсом.
[04:23.800 --> 04:25.480]  И все просуммируем.
[04:25.480 --> 04:28.160]  ну и грубо говоря понятно, что если у нас точки
[04:28.160 --> 04:29.800] �!! в многоугольника, то там сумма углов должна
[04:29.800 --> 04:31.200]  быть два ПИ или минус два ПИ,
[04:31.200 --> 04:33.840]  смотря в какую сторону мы крутились.
[04:33.840 --> 04:35.720]  Вот я на самом деле не уверен, что там будет ровно два ПИ
[04:35.720 --> 04:37.360]  или минус два ПИ, возможно там что так радное
[04:37.360 --> 04:38.660]  двум ПИ будет.
[04:38.660 --> 04:40.340]  Потому что если на угольник какой-нибудь там сильный
[04:40.340 --> 04:43.060]  вот такой закручен, то, возможно, там будет типа 4p или что-то
[04:43.060 --> 04:44.060]  такое.
[04:44.060 --> 04:45.060]  Но я не уверен.
[04:45.060 --> 04:46.060]  Кажется, нет.
[04:46.060 --> 04:48.300]  Нет, на угольник простой.
[04:48.300 --> 04:49.300]  Тогда 2p, да?
[04:49.300 --> 04:52.780]  Вот мне тоже, но я без понятия как это доказывать, поэтому
[04:52.780 --> 04:53.780]  не ручаюсь.
[04:53.780 --> 04:56.140]  Ну и соответственно, если мы все углы эти ориентированные
[04:56.140 --> 04:57.700]  просуммируем, то понятно, что если мы были внутри,
[04:57.700 --> 05:00.260]  то мы как бы вот так вот полностью обошли точно
[05:00.260 --> 05:03.140]  по крайней мере один раз круг, а если бы мы были вне
[05:03.140 --> 05:06.220]  многоугольника, то мы просуммировали все эти уголочки, ну и как
[05:06.300 --> 05:08.820]  бы, грубо говоря, наш угол вот так вот как-то дергался,
[05:08.820 --> 05:10.380]  ну понятно, что он суммарно пройдет ноль.
[05:10.380 --> 05:12.980]  То есть он сначала как-то сюда повернулся, потом сюда
[05:12.980 --> 05:16.900]  вернулся в исходное состояние, не прокрутившись при этом
[05:16.900 --> 05:19.740]  на 360.
[05:19.740 --> 05:27.540]  Поэтому, значит, находим ориентированные углы до
[05:27.540 --> 05:32.660]  всех сторон, складываем.
[05:32.660 --> 05:40.820]  Если получился ноль или примерно ноль, то говорим,
[05:40.820 --> 05:44.300]  что точка снаружи, если не ноль, то внутри.
[05:44.300 --> 05:51.060]  Если сумма примерно равна нулю, то снаружи.
[05:51.060 --> 05:56.340]  Ну я здесь пишу примерно, потому что там, когда вы
[05:56.340 --> 05:58.900]  ищете угол, у вас точно будут всякие неточности,
[05:58.900 --> 06:01.500]  там какие-то погрешности будут, ну там ровно ноль
[06:01.500 --> 06:03.820]  вы никогда не получите, но что-то близкое там даст
[06:03.820 --> 06:08.460]  точность, не знаю, 10 минус 5, 10 минус 4, точно у вас будет
[06:08.460 --> 06:09.460]  ноль.
[06:09.460 --> 06:12.540]  А если она внутри, то там сумма будет около 2p, ну
[06:12.540 --> 06:15.300]  то есть вы как короче ноль и 2p вы точно уж различите
[06:15.300 --> 06:19.540]  как-нибудь, поэтому внутри и вне как-нибудь мы сможем
[06:19.540 --> 06:20.540]  здесь распознать.
[06:20.540 --> 06:23.540]  Значит, единственное, что я хочу сказать, как лучше
[06:23.540 --> 06:28.500]  всего находить угол, да, угол, ориентированный угол
[06:28.500 --> 06:30.940]  при стороне какой-то, под которой видна сторона.
[06:30.940 --> 06:35.460]  Ну вот если это векторы a и v, то лучше всего написать
[06:35.460 --> 06:49.540]  атан2 или даже атан2l, кросс и дот.
[06:49.540 --> 06:51.580]  По моему опыту самая точная функция, которая вычисляет
[06:51.580 --> 06:55.820]  угол между векторами, да, то есть мы могли бы скажем
[06:55.820 --> 06:57.580]  просто взять колярное произведение и поделить
[06:57.580 --> 07:02.900]  его на длины и взять аркосинус, или там наоборот взять векторное
[07:02.900 --> 07:05.380]  и поделить на длины и взять арксинус, но это как бы
[07:05.380 --> 07:09.220]  еще более точная штука, которая как бы по этому и этому
[07:09.220 --> 07:12.660]  наиболее точно, в общем, как может старается извлечь
[07:12.660 --> 07:18.100]  собственно сам угол вот этот вот, ну и собственно
[07:18.100 --> 07:19.900]  его лучше всего использовать, если мы хотим как можно
[07:19.900 --> 07:20.900]  меньше точности терять.
[07:20.900 --> 07:26.900]  Вот, носим точку, конечно, линейная по числу вершин
[07:26.900 --> 07:30.660]  многогольника, но недостатки здесь тоже весьма очевидны.
[07:30.660 --> 07:34.500]  Это тригонометрия, тригонометрия проблема, что, во-первых,
[07:34.500 --> 07:36.900]  все эти функции довольно долгие, но вот это атан2,
[07:36.900 --> 07:41.100]  он довольно долгий, во-вторых, ну вот есть какие-то погрешности
[07:41.100 --> 07:42.500]  и с ними возиться не очень хочется.
[07:43.340 --> 07:53.940]  Итак, напишем, недостатки, тригонометрические функции
[07:53.940 --> 07:58.580]  работают долго, ну по крайней мере, дольше, чем, не знаю,
[07:58.580 --> 08:04.300]  всякие произведения и так далее, и позволяют, ну
[08:04.300 --> 08:06.380]  как бы, и порождают погрешности.
[08:06.380 --> 08:16.020]  Ну это так, весьма условно недостатки, в принципе мета
[08:16.020 --> 08:17.020]  стала нерабочей.
[08:17.020 --> 08:25.900]  Так, ну и следующие две вещи, которые я хочу сказать,
[08:25.900 --> 08:27.860]  они работают, когда у нас все целочисленное, то
[08:27.860 --> 08:31.500]  есть вот это у нас в принципе работает, когда и все вершины
[08:31.500 --> 08:32.500]  не обязательно целочисленные.
[08:33.500 --> 08:36.340]  А если нам известно, что все координаты целые и мы
[08:36.340 --> 08:40.620]  хотим это сохранить, да, не хотим переходить в даблы,
[08:40.620 --> 08:44.220]  тогда вот работает второй и третий способ, значит,
[08:44.220 --> 08:48.900]  работает, если все координаты целые.
[08:48.900 --> 09:07.460]  Значит, ну вообще идея такая, что давайте мы выпустим
[09:07.460 --> 09:14.060]  из нашей вершины некий луч и посчитаем его число
[09:14.060 --> 09:17.460]  пересечений с границы ногогольника, то есть сколько раз он пересекает
[09:17.540 --> 09:18.540]  сторону.
[09:18.540 --> 09:22.700]  И как бы, ну понятно, что если он пересек нечетное
[09:22.700 --> 09:25.020]  число раз, значит, он изначально был внутри, да, потом вот
[09:25.020 --> 09:26.980]  так пересековался и вышел, понятно, что бесконечная
[09:26.980 --> 09:29.380]  далекая точка должна лежать вне ногогольника.
[09:29.380 --> 09:31.420]  Значит, если здесь нечетный число раз, то, наоборот,
[09:31.420 --> 09:34.340]  идиазбесконечности мы чередуясь, попадаем внутрь, а если
[09:34.340 --> 09:37.100]  он пересек, скажем, четное число раз, ну что-нибудь
[09:37.100 --> 09:40.100]  вот такое я нарисую, два пересечения, то он, значит,
[09:40.100 --> 09:42.580]  был изначально снаружи, потому что прочередовался
[09:42.580 --> 09:44.860]  и остался такой же, как был, значит, был снаружи.
[09:45.700 --> 09:47.940]  Вот, то есть наша задача – это посчитать просто число
[09:47.940 --> 09:51.220]  пересечений со сторонами и, ну, как бы, по чётности
[09:51.220 --> 09:52.380]  понять внутри или вне.
[09:52.380 --> 10:02.220]  Значит, в общем, это такое, что мы пускаем луч, считаем
[10:02.220 --> 10:13.700]  число пересечений с границей, если нечетно, то внутри.
[10:13.700 --> 10:20.460]  Если чётно, то снаружи.
[10:20.460 --> 10:28.900]  Вот, но здесь надо ещё аккуратно разобраться с точками,
[10:28.900 --> 10:31.500]  которые лежали на границе, давайте вот про границу
[10:31.500 --> 10:34.180]  мы тоже отдельно скажем, что ещё перед тем, как пускать
[10:34.180 --> 10:39.660]  луч, отдельно проверим принадлежность нашей точки всем
[10:39.660 --> 10:41.860]  сторонам нашего ногогольника, то есть отдельно по всем
[10:41.860 --> 10:45.340]  отрезкам пройдёмся, проверим, лежит ли точка на отрезке,
[10:45.340 --> 10:47.580]  если хотя бы одна ноль лежит, то значит, она на границе.
[10:47.580 --> 10:50.980]  Иначе, вот это вот, ну, как бы, количество там точно
[10:50.980 --> 10:53.780]  можно посчитать, да, не возникает случаев вот таких,
[10:53.780 --> 10:56.300]  когда точка сама лежит на стороне, это не очень
[10:56.300 --> 10:57.300]  приятно.
[10:57.300 --> 11:00.260]  Поэтому отдельно проверяем, не лежит ли она на границе.
[11:11.860 --> 11:25.620]  Да, значит, проблема в том, что луч может проходить
[11:25.620 --> 11:27.180]  через вершину, и тогда не очень понятно, как это
[11:27.180 --> 11:28.180]  учитывать.
[11:28.180 --> 11:31.580]  Мы с вами ещё порисуем много картинок, чтобы понять,
[11:31.580 --> 11:34.580]  как это всё учитывать, но вообще по умолчанию, если
[11:34.580 --> 11:36.380]  мы скажем, ну, вот здесь, если бы мы проходили вот
[11:36.380 --> 11:40.700]  так через вершину, то это как будто бы мы вообще
[11:40.860 --> 11:43.700]  не пересекаемся с многогольником, потому что мы вот так коснулись,
[11:43.700 --> 11:46.700]  ну, как бы, по касательной прошлись, и как бы не зашли
[11:46.700 --> 11:49.700]  в него, то есть это как бы надо не учитывать как пересечение.
[11:49.700 --> 11:52.060]  Хотя вроде это как точка пересечения, да, с границей
[11:52.060 --> 11:53.060]  не очень понятно.
[11:53.060 --> 11:54.060]  Вот.
[11:54.060 --> 12:00.700]  Вот тут, ну, типа, а если, а если наоборот, а если
[12:00.700 --> 12:06.140]  вот такая картинка, если такая картинка, вы проходите
[12:06.140 --> 12:08.500]  через вершину, учли два раза, на самом деле надо
[12:08.500 --> 12:09.500]  один раз.
[12:09.500 --> 12:11.500]  В общем, тут надо аккуратно с вершинами разобраться,
[12:11.500 --> 12:13.500]  мы это сделаем ещё на чуть позже.
[12:13.500 --> 12:20.500]  Проблема действительно такая, что, что делать,
[12:20.500 --> 12:22.500]  если луч проходит через вершину?
[12:33.500 --> 12:36.500]  Ну, решение здесь весьма прозоичное, давайте просто
[12:36.500 --> 12:38.500]  подберём такой луч, который через вершину заведомо
[12:38.500 --> 12:39.500]  не проходит.
[12:39.500 --> 12:41.500]  Самое тупое решение, это давайте пускать какой-нибудь
[12:41.500 --> 12:45.500]  случайный луч, да, выпустим случайный луч, но если мы
[12:45.500 --> 12:47.500]  хотим, чтобы всё было целочисленное, давайте просто выпустим
[12:47.500 --> 12:49.500]  там луч со случайными координатами, со случайным
[12:49.500 --> 12:50.500]  направляющим вектором.
[12:50.500 --> 12:53.500]  Проверим, что на нём нет ни одной точки, в смысле
[12:53.500 --> 12:54.500]  одной вершины.
[12:54.500 --> 12:57.500]  Если нет, то, ну, зашибись, да, мы дальше делаем вот
[12:57.500 --> 12:58.500]  это.
[12:58.500 --> 13:00.500]  Либо мы можем заведомо подобрать такой луч, на
[13:00.500 --> 13:02.500]  котором ни одна точка не лежит.
[13:02.500 --> 13:09.500]  Значит, во-первых, это случайный луч, ну, и соответственно
[13:09.500 --> 13:12.500]  генерируем в случайную пару координат, там A-B,
[13:12.500 --> 13:15.500]  давайте не A-B, давайте Х-эгрид.
[13:15.500 --> 13:17.500]  Генерируем случайный направляющий вектор нашего
[13:17.500 --> 13:21.500]  луча до тех пор, пока на нём есть хотя бы одна точка.
[13:21.500 --> 13:23.500]  Если нет, то значит хороший луч.
[13:23.500 --> 13:24.500]  Вот.
[13:24.500 --> 13:28.500]  Ну и во-вторых, скажем, если мы знаем, что все координаты,
[13:28.500 --> 13:35.500]  ну, например, целые от 0 до A, если координаты всех
[13:35.500 --> 13:54.500]  точек целые в отрезке от 0 до A, то подойдёт луч с
[13:54.500 --> 13:59.500]  вектором, ну, например, A, A плюс 1.
[13:59.500 --> 14:05.500]  Вот я утверждаю, что если пустить такой луч из нашей
[14:05.500 --> 14:07.500]  точки, то на нём никакая вершина быть не может.
[14:07.500 --> 14:14.500]  Вот здесь там что-то такое есть, есть наша вершина,
[14:14.500 --> 14:17.500]  мы пускаем вот такой вот луч.
[14:17.500 --> 14:23.500]  Ну, очень-очень легко понять, почему здесь не может быть
[14:23.500 --> 14:24.500]  координат.
[14:24.500 --> 14:26.500]  Потому что если это какая-то точка, то на этом отрезке
[14:26.500 --> 14:30.500]  от точки до, ну пусть это будет П, а это будет П плюс
[14:30.500 --> 14:33.500]  вектор А плюс 1.
[14:33.500 --> 14:38.500]  На этом отрезке никаких других целых точек нет,
[14:38.500 --> 14:41.500]  потому что координаты этого вектора взаимнопростые,
[14:41.500 --> 14:43.500]  если бы здесь была какая-то другая точка, то значит
[14:43.500 --> 14:47.500]  эта штука была бы делителем этого вектора, а у него
[14:47.500 --> 14:50.500]  нет делителей с целыми координатами, да, потому
[14:50.500 --> 14:51.500]  что здесь взаимнопростые координаты, значит здесь
[14:51.500 --> 14:54.260]  просто целых точек нету, ну и эта точка уже заведомо
[14:54.260 --> 14:57.540]  лежит вне нашего многоугольника, потому что мы лежим в квадрате
[14:57.540 --> 15:00.780]  а на а, а эта точка имеет координаты хотя бы а плюс
[15:00.780 --> 15:01.780]  один второму измерению.
[15:01.780 --> 15:05.700]  Значит, здесь никаких, конечно, нету, просто потому что
[15:05.700 --> 15:07.980]  они все были целочисленные, ну значит, лучше заведомо
[15:07.980 --> 15:08.980]  хороший.
[15:08.980 --> 15:09.980]  Окей?
[15:09.980 --> 15:16.860]  Вот, ну вроде все, опять получили линейный алгоритм,
[15:16.860 --> 15:21.380]  да только он уже все считает в целых числах и не переходит
[15:21.380 --> 15:22.380]  к доблам.
[15:22.380 --> 15:31.860]  Еще раз?
[15:31.860 --> 15:32.860]  Ну типа того, да.
[15:32.860 --> 15:35.580]  Ну то есть такое универсальное правило, оно на самом деле
[15:35.580 --> 15:41.060]  довольно бесполезно на практике в том плане, что как бы обычно
[15:41.060 --> 15:45.580]  если вы там пишете какую-нибудь геометрию, то у вас там сразу
[15:45.580 --> 15:49.580]  все гранаты могут быть добловские, да, но если вдруг
[15:49.620 --> 15:52.580]  у вас все происходит в какой-нибудь сеточке, вы знаете, что координаты
[15:52.580 --> 15:57.180]  всегда целые, ну такое в принципе тоже реально, вот,
[15:57.180 --> 15:59.420]  тогда вам как бы хочется, чтобы у вас ответ всегда
[15:59.420 --> 16:00.420]  был точно.
[16:00.420 --> 16:02.900]  То есть если у вас все изначально целое, да, у вас нет погрешностей
[16:02.900 --> 16:05.260]  в задании входных данных, ну значит и ответ наверное
[16:05.260 --> 16:06.260]  можно считать точно.
[16:06.260 --> 16:07.260]  Ну вот, пожалуйста.
[16:07.260 --> 16:08.260]  Да.
[16:08.260 --> 16:17.460]  Да, да, смотрим пересекается ли сторона с лучом, считаем
[16:17.460 --> 16:19.460]  число таких причин, если не чего-то, то внутри, если
[16:19.460 --> 16:20.460]  чего-то, то снаружи.
[16:20.460 --> 16:34.980]  Так, ну и значит третье, вот давайте теперь честно
[16:34.980 --> 16:37.300]  разберемся с вершинами.
[16:37.300 --> 16:41.100]  Честно разберемся вот с этими плохими случаями,
[16:41.260 --> 16:42.500]  когда луч проходит через вершин.
[16:42.500 --> 16:57.300]  Значит давайте я буду для удобства пускать горизонтальный
[16:57.300 --> 16:58.300]  луч.
[16:58.300 --> 16:59.460]  Горизонтальный луч вправо.
[16:59.460 --> 17:10.420]  Так, ну, боже не, пусть будет вот такой.
[17:10.420 --> 17:12.500]  Пускаю горизонтальный луч вправо и давайте сейчас
[17:12.500 --> 17:16.620]  честно пойму, что делать с вершинками, так чтобы,
[17:16.620 --> 17:19.180]  ну короче, правильно учесть все вот эти случаи, да, правильно
[17:19.180 --> 17:20.180]  учесть случаи вершин.
[17:20.180 --> 17:26.740]  Значит утверждается, что работает следующий алгоритм.
[17:26.740 --> 17:29.380]  Ну мы точно так же проходим по всем сторонам.
[17:29.380 --> 17:38.700]  Значит перебираем стороны, перебираем стороны, пусть
[17:38.700 --> 17:42.180]  отрезок А и Б это очередная сторона, ну то есть А и Б это
[17:42.180 --> 17:45.260]  две точки, я точки маленькими буквами тоже буду обозначать.
[17:45.260 --> 17:57.260]  Значит А и Б это очередная сторона, причем А и Y меньше
[17:57.260 --> 17:58.260]  и равно B.Y.
[17:58.260 --> 18:02.620]  То есть я взял очередную сторону и так обозвал вершины,
[18:02.620 --> 18:05.300]  что А более низко из них, не строго.
[18:05.300 --> 18:09.260]  То есть например вот здесь вот это А это Б, вот здесь
[18:09.260 --> 18:10.580]  вот это тоже А это Б.
[18:10.580 --> 18:15.020]  То есть на каждой стороне у меня свое обзывательство
[18:15.020 --> 18:17.660]  для обеих вершин.
[18:17.660 --> 18:26.220]  А дальше я говорю следующее, значит если отрезок, если
[18:26.220 --> 18:30.860]  сторона лежит целиком строго выше или целиком не строго
[18:30.860 --> 18:33.460]  ниже, чем этот луч, то мы ее скипаем.
[18:33.780 --> 18:40.500]  А именно если A.Y больше чем P.Y или B.Y меньше
[18:40.500 --> 18:45.820]  и равно P.Y, тогда мы просто эту сторону скипаем, считаем
[18:45.820 --> 18:47.580]  что она не пересекается с лучом, говорим скип.
[18:47.580 --> 18:52.580]  То есть это соответственно какие картинки, эта картинка
[18:52.580 --> 18:55.580]  вот такая, ну здесь это естественно, что если даже
[18:55.580 --> 19:00.300]  у точки А координата по Y больше чем у П, то конечно
[19:00.300 --> 19:01.820]  здесь точно нет пересечений.
[19:01.860 --> 19:06.180]  Это условие естественное, а второе условие это что
[19:06.180 --> 19:12.180]  если у нас картинка какая-то вот такая или даже скажем
[19:12.180 --> 19:16.140]  вот такая, а мы говорим что все равно пересечений
[19:16.140 --> 19:17.140]  нет.
[19:17.140 --> 19:21.140]  И даже сюда же входит случай вот такой, когда наш отрезок
[19:21.140 --> 19:24.100]  целиком лежит на луче, а мы все равно говорим что
[19:24.100 --> 19:26.420]  пересечений нет.
[19:26.420 --> 19:27.420]  Давайте пока так сделаем.
[19:31.820 --> 19:42.580]  А у них одинаковые Y, поэтому все знают, а, да, спасибо.
[19:42.580 --> 19:48.140]  Что-то у нас аж 4 картинки уже, капец, да, а внизу всегда
[19:48.140 --> 19:49.140]  спасибо.
[19:49.140 --> 20:05.900]  Ну вот, значит делаем это, а в противном случае проверяем
[20:05.900 --> 20:08.340]  пересечения, если есть пересечения, то там изменяем четность
[20:08.340 --> 20:09.340]  на единицу.
[20:09.340 --> 20:17.260]  Значит иначе проверяем пересечение, проверяем
[20:17.260 --> 20:24.460]  наличие пересечений.
[20:24.460 --> 20:28.420]  Ну проверить очень просто, если есть такой луч горизонтальный,
[20:28.420 --> 20:32.500]  если есть некоторый отрезок АВ, то, например, они пересекаются
[20:32.500 --> 20:40.180]  если и только если вот такое вот их векторное произведение,
[20:40.180 --> 20:46.460]  то есть я провожу вот такие два вектора, если оно отрицательно,
[20:46.540 --> 20:49.900]  ну не положительно пишу так, потому что если была бы
[20:49.900 --> 20:56.380]  какая-нибудь такая картинка, вот такая, скажем, да, тогда
[20:56.380 --> 21:02.300]  у вас здесь, наоборот, поворот идет против все, то есть положительный.
[21:02.300 --> 21:05.700]  Ну это опять на картинках все, можно просто порисовать
[21:05.700 --> 21:09.060]  все возможные взаимные расположения отрезка и луча вот этого
[21:09.060 --> 21:11.260]  горизонтального и понять, что пересекаются они ровно
[21:11.260 --> 21:18.340]  в этом случае, когда угол поворота из А от П к Б отрицательный,
[21:18.340 --> 21:20.780]  то есть в сторону по часовой стрелке.
[21:20.780 --> 21:23.980]  Ну и все, получается алгоритм очень простой, алгоритм
[21:23.980 --> 21:27.980]  очень короткий, значит мы идем по всем сторонам,
[21:27.980 --> 21:30.660]  если очередная сторона имеет там какие-то вершины,
[21:30.660 --> 21:33.140]  то давайте скажем, что А это более низкая из этих
[21:33.140 --> 21:34.140]  двух вершин.
[21:34.140 --> 21:36.300]  Дальше, если выполняется такое условие, мы эту сторону
[21:36.300 --> 21:39.420]  пропускаем и ничего не делаем, а иначе если выполняется
[21:39.420 --> 21:42.540]  вот это, то мы проявляем один к счетчику пересечений
[21:42.540 --> 21:44.580]  и в конце если он нечетный, то значит изначально точка
[21:44.580 --> 21:52.980]  была внутри, то есть конец такой же, что если насчитали
[21:52.980 --> 22:11.340]  что-то начало пересечений, то точка внутри.
[22:11.340 --> 22:13.400]  Ну то же самое надо было еще в самом начале отдельно
[22:13.400 --> 22:15.740]  проверить, что точка лежит где-нибудь на границе, потому
[22:15.740 --> 22:18.580]  что с точками на границе тут не очень приятно,
[22:18.580 --> 22:20.540]  потому что если эта точка П лежит на каком-то из
[22:20.540 --> 22:23.900]  отрезков, то короче отдельно разберем еще в случае на
[22:23.900 --> 22:24.900]  границе.
[22:24.900 --> 22:25.900]  То есть вот здесь вот на самом деле можно было
[22:25.900 --> 22:28.900]  выписать строгое неравенство, потому что нестрогое означало
[22:28.900 --> 22:31.660]  бы, что П лежит на отрезке, а это мы отдельно в самом
[22:31.660 --> 22:42.540]  начале разберем, то есть отдельно проверяем
[22:42.540 --> 22:43.700]  на принадлежность границы.
[22:43.700 --> 22:55.700]  Ну что теперь надо доказать, что это работает, что действительно
[22:55.700 --> 22:57.620]  все случаи вот этих пересечений совершены и мы правильно
[22:57.620 --> 22:58.620]  обработаем.
[22:58.620 --> 23:07.580]  Ну надо просто порисовать все случаи какие есть, давайте
[23:07.580 --> 23:08.580]  разберем.
[23:08.580 --> 23:11.740]  Ну понятно, что вот здесь вот если наш отрезок лежал
[23:11.740 --> 23:14.340]  целиком сверху или целиком снизу, то мы его правильно
[23:14.340 --> 23:16.100]  обрабатываем, здесь точно нет никаких пересечений.
[23:16.100 --> 23:20.820]  Значит дальше, если одна точка выше, другая точка
[23:20.820 --> 23:26.020]  ниже, то понятно, что в этот случай мы тоже правильно
[23:26.020 --> 23:31.300]  разберем, мы проверим наличие пересечений или нет, то есть
[23:31.300 --> 23:35.140]  на этом отрезке не вершина здесь лежит, поэтому здесь
[23:35.140 --> 23:37.700]  мы точно все нормально разберем, здесь все хорошо.
[23:37.700 --> 23:39.860]  Значит проблемы только с тем, когда одна из точек
[23:39.860 --> 23:47.020]  A или B лежат на луче, одна из точек A или B лежат на луче,
[23:47.020 --> 23:49.860]  но причем это видимо обязательно A, потому что если и A и B,
[23:49.860 --> 23:53.620]  то есть если B лежит на луче, то A только ниже, а значит
[23:53.620 --> 23:55.620]  это случай либо такой, либо такой, поэтому мы бы его
[23:55.620 --> 23:56.620]  скипнули.
[23:56.620 --> 23:58.820]  Поэтому нам нужно рассмотреть все случаи, когда A лежит
[23:58.820 --> 24:02.820]  где-то ниже луча A, а B на луче и понять, что мы их правильно
[24:02.820 --> 24:05.820]  разбираем.
[24:05.820 --> 24:08.380]  Ну, какие бывают случаи?
[24:08.380 --> 24:11.420]  Ну, например, вот такой случай бывает.
[24:11.420 --> 24:16.980]  Значит, вот была там очередная, просто буду вот так рисовать,
[24:16.980 --> 24:20.140]  очередная вершина и многоугольник где-то вот здесь был, или
[24:20.140 --> 24:21.980]  наоборот, была очередная вершина, а многоугольник
[24:21.980 --> 24:22.980]  где-то вот здесь.
[24:22.980 --> 24:32.380]  Такие случаи, значит, вот такие случаи, как-нибудь
[24:32.380 --> 24:41.100]  вот так вот я нарисую.
[24:41.100 --> 24:44.580]  Давайте с ними пока разберемся, что делать со случаем, когда
[24:44.580 --> 24:47.420]  вершина попадает к нам на луч.
[24:47.420 --> 24:53.780]  Значит, если оба прилежащих отрезка лежат ниже луча,
[24:53.780 --> 24:55.780]  то по сути, когда мы вот так вот проходим через эту
[24:55.780 --> 24:58.620]  вершину, у нас должно не поменяться число пересечений,
[24:58.620 --> 25:00.740]  потому что можно считать, что мы по внутренности
[25:01.740 --> 25:07.420]  То есть нам надо не изменить чётность числа пересечений
[25:07.420 --> 25:09.580]  при проходе вот этих двух отрезков, но они оба у меня
[25:09.580 --> 25:12.540]  игнорируются, потому что они оба лежат ниже, ниже
[25:12.540 --> 25:15.180]  нашего луча, поэтому мы их оба скипнём и чётность
[25:15.180 --> 25:16.180]  не изменим.
[25:16.180 --> 25:17.180]  Поэтому этот случай разбирается правильно.
[25:17.180 --> 25:20.180]  Тут согласны?
[25:20.180 --> 25:22.620]  То есть нам нужно не изменить чётность, пройдя вот эти
[25:22.620 --> 25:24.900]  два отрезка, но мы так и сделаем, потому что мы их оба скипнём.
[25:24.900 --> 25:28.380]  Значит, ну здесь то же самое, здесь мы проходим наоборот
[25:28.820 --> 25:32.540]  по внешне касательной, и всё равно надо не поменять
[25:32.540 --> 25:35.660]  чётность, но мы так и сделаем, потому что мы вновь оба
[25:35.660 --> 25:37.540]  эти отрезка скипнём.
[25:37.540 --> 25:38.540]  Здесь всё нормально.
[25:38.540 --> 25:48.860]  Так, ну нужны ещё случаи, когда вот такие случаи, когда
[25:48.860 --> 25:52.660]  наоборот у нас сверху, ну как бы наверх торчат две
[25:52.660 --> 25:55.780]  седние стороны, но здесь тоже всё верно, здесь нужно
[25:55.820 --> 26:01.380]  нам не учесть, что эта вершина как бы является точкой пересечения,
[26:01.380 --> 26:03.060]  то есть мы как бы вот здесь вот по внешне касательной
[26:03.060 --> 26:06.540]  проходим, здесь тоже как бы внутри обходим.
[26:06.540 --> 26:10.580]  Надо учесть с коэффициентом ноль, да, то есть как бы что
[26:10.580 --> 26:13.020]  эти два отрезка не вносят нам пересечения, но мы так
[26:13.020 --> 26:17.100]  и сделаем, потому что у нас оба эти отрезка дадут
[26:17.100 --> 26:19.940]  мне вклад в пересечение, да, то есть это случай, когда
[26:19.940 --> 26:25.020]  я их не скипаю, но при этом они оба пересекаются, то
[26:25.020 --> 26:27.700]  если я добавлю здесь единицу, здесь единицу, получится,
[26:27.700 --> 26:30.220]  что я не изменю четность числа пересечений, поэтому
[26:30.220 --> 26:32.180]  это случай тоже правильно обрабатывается.
[26:32.180 --> 26:34.940]  Тут то же самое, у меня оба эти отрезка посчитаются
[26:34.940 --> 26:38.420]  как пересечения, я добавлю по единице к числу пересечений
[26:38.420 --> 26:40.500]  и тем самым четность не изменю, всё будет правильно.
[26:40.500 --> 26:47.740]  Значит здесь, здесь уже чуть-чуть поинтереснее,
[26:47.740 --> 26:50.620]  если у меня вот такая картинка, то есть я пересекаюсь через
[26:50.620 --> 26:54.100]  вершину и надо выйти как бы из многоугольника.
[26:54.220 --> 26:56.760]  Ну тогда мне нужно поменять чётность числа пересечения,
[26:56.760 --> 26:59.380]  потому что я выхожу за границы многоугольника,
[26:59.380 --> 27:02.840]  но я ровно так и делаю, потому что нижнюю я скипаю,
[27:02.840 --> 27:04.120]  нижняя будет скип, да, да, да, да, да и даст на меня
[27:04.120 --> 27:07.180]  ноль к числу пересечений, а верхнюю я посчитаю как
[27:07.180 --> 27:10.340]  пересечение, она мне даст единичку и тем самым я
[27:10.340 --> 27:10.860]  поменяю числа пересечения, всё правильно.
[27:10.860 --> 27:15.700]  Нижняя скипну, а верхняя будет вот здесь вот разобрана
[27:15.700 --> 27:18.720]  и посчитается это пересечение.
[27:18.720 --> 27:22.100]  Тут то же самое, надо поменять, это пропустится, а это добавит
[27:22.100 --> 27:25.860]  единичку, тем самым я добавлю единицу к общему числу перещений и поступлю правильно.
[27:25.860 --> 27:34.340]  Так, ну и, кажется, последнее, что надо еще разобрать, это когда сторона лежит на луче.
[27:34.340 --> 27:44.460]  Еще бывают вот такие вот случаи, например, что-нибудь вот такое.
[27:44.460 --> 28:10.580]  Вот, тут вроде можно всегда заметить, что в таких картинках можно как будто бы склеить
[28:10.580 --> 28:14.780]  концы вот этого горизонтального ребра, горизонтальной стороны и считать, что его вообще не было.
[28:14.780 --> 28:20.940]  То есть вот представьте, что я вот так вот беру и этот кусок как бы притягиваю влево к этой вершинке,
[28:20.940 --> 28:24.620]  то есть стягиваю этот отрезок в точку, да, и тем самым у меня как бы это перенесется параллельно
[28:24.620 --> 28:31.860]  сюда, ну здесь соответственно граница как-то там перенесется. И тогда, по сути, да, ну то есть вот
[28:31.860 --> 28:36.260]  так вот здесь я не изменил как бы число перещений, то есть я как бы вот здесь вот так вот шел по ней,
[28:36.260 --> 28:40.260]  ждал, ждал, когда что-то произойдет, да, и когда сюда попал, я уже понимаю, что пресуд якобы
[28:40.260 --> 28:44.580]  попадаю внутрь, но давайте сразу тогда сюда притянем и тем самым поймем, что горизонтальные
[28:44.580 --> 28:49.980]  отрезки можно игнорировать, они как бы нам не влияют на число перещений. То же самое здесь,
[28:49.980 --> 28:56.620]  да, вот если я притяну вот эту вот штуку сюда, ну как бы сдвину как-нибудь все вот это вот,
[28:56.620 --> 29:03.340]  то у меня, ну как бы число перещений не изменится. То же самое здесь и здесь, я могу вот это сдвинуть,
[29:03.340 --> 29:09.220]  и здесь могу вот это сдвинуть, будет такой многоугольник. Ну соответственно видно,
[29:09.220 --> 29:14.380]  что горизонтальные отрезки, которые как бы лежат на нашем луче, можно просто игнорировать,
[29:14.380 --> 29:18.460]  они как бы не дают вклада, то есть если их игнорировать, то можно просто смотреть на
[29:18.460 --> 29:23.420]  следующую сторону, она и определяет нам как мы пересекаемся. Ну ровно так мы и поступаем с
[29:23.420 --> 29:30.580]  горизонтальными отрезками, вот они, это вот этот случай, когда B точке грех меньше,
[29:30.580 --> 29:35.780]  B точке греха мы просто скипаем и не учитываем в пересечении, поэтому такие случаи тоже корректно
[29:35.780 --> 29:45.380]  все разберутся, ну и вроде все, больше никаких неприятностей нету. Ну вот это мы отдельно ефаем,
[29:45.380 --> 29:52.420]  чтобы как раз не было кейсов, когда вот эта вот точка совпадает с каким-то из отрезков. То есть
[29:52.420 --> 29:57.060]  у нас алгоритм в итоге такой, что мы сначала проверяем по всем сторонам, не лежит ли точка
[29:57.060 --> 30:01.780]  на стороне, если лежит, то говорим, что там лежит на границе, затем запускаем этот простой алгоритм,
[30:01.780 --> 30:06.500]  тоже проход по всем сторонам вот с этими двумя условиями и потом по учетности определяем
[30:06.500 --> 30:14.700]  внутри или снаружи. Окей, ну как бы тут ничего приятного, надо просто порисовать картинки,
[30:14.700 --> 30:19.900]  понять, что мы их правильно учтем в этом алгоритме, все. Ничего приятного, но ничего хитрого.
[30:27.060 --> 30:45.460]  Так, хорошо, значит с этим тогда разобрались, с этим разобрались и можем ехать дальше,
[30:45.460 --> 30:47.900]  значит следующая задача это пересечение полуплоскостей.
[30:47.900 --> 31:01.700]  Задача такая, ну полуплоскость это понятно, что такое, мы живем на плоскости,
[31:01.700 --> 31:06.780]  полуплоскость это то, что лежит по одну сторону какой-то прямой, то есть есть прямая,
[31:06.780 --> 31:14.460]  АХ плюс БЮ плюс С равно нулю и какая-то вот из двух частей, на которые она развивает плоскость,
[31:14.460 --> 31:20.140]  ну скажем вот это. То есть вот это вот, все это какая-то полуплоскость. И теперь представьте,
[31:20.140 --> 31:24.860]  что есть N таких штук, N полуплоскостей, мы хотим понять, чему равно их пересечение,
[31:24.860 --> 31:35.980]  как выглядит их пересечение, полностью его описать. Найти пересечение N полуплоскостей.
[31:35.980 --> 31:47.300]  Ну сначала давайте скажем, как мы вообще будем задавать такие полуплоскости, есть какие-нибудь
[31:47.300 --> 31:57.660]  предложения? Как можно задать прямую вместе с вот одной из двух частей? Слишком сложно,
[31:57.660 --> 32:18.580]  слишком много сущностей. Лучше еще. Да, типа того, ну вот то, что вы сказали про буль, на самом деле
[32:18.580 --> 32:22.860]  можно сделать так, что если буль фолст, то мы могли бы коэффициенты на минус один просто
[32:22.860 --> 32:27.620]  домножить и получить как раз противоположную полуплоскость. Поэтому вместо буля давайте просто
[32:27.620 --> 32:36.500]  хранить на самом деле три N, ну там три коэффициенты, и будем считать, что полуплоскость это то,
[32:36.500 --> 32:41.100]  что дает вот такому вот неравенству. Больше оно нуля. Если бы был буль, то мы бы могли на минус
[32:41.100 --> 32:47.860]  один домножить, у нас поменялся бы как раз значок. То есть полуплоскость мы будем хранить так же,
[32:47.860 --> 32:54.820]  как прямую, грубо говоря, в той же структуре line, с коэффициентами abc. И считать, что
[32:54.820 --> 33:00.940]  полуплоскость это то, что дает вот этому неравенству. А х плюс у плюс все больше нуля. Значит более того,
[33:00.940 --> 33:07.980]  можно сказать, что это та из двух полуплоскостей, куда смотрит нормальный вектор ab. В эту
[33:07.980 --> 33:28.100]  полуплоскость смотрит нормальный вектор ab. Да, то есть вот этот вектор, который я пытался
[33:28.100 --> 33:35.820]  нарисовать, его можно в частности брать нормальным. Ну почему это верно? Легко показать, что если вот
[33:35.820 --> 33:42.540]  это какая-то точка там x0, y0, лежащая на прямой, тогда эта точка x0 плюс a, y0 плюс b, и если вы
[33:42.540 --> 33:47.100]  поставите просто вот эти координаты этой точки в это уравнение, то вы получите a квадрат плюс b
[33:47.100 --> 33:52.620]  квадрат, что точно положительно. Поэтому вот эта вот нормаль с координатами ab как раз ровно в
[33:52.620 --> 33:59.420]  этой полуплоскости лежит. То есть у нас есть как бы понимание, что полуплоскости мы храним ровно
[33:59.420 --> 34:05.380]  так, и в частности это та полуплоскость относительно данной прямой, куда торчит вектор нормали. Вот это
[34:05.380 --> 34:10.980]  вот наш стандартный вектор нормали ab. Да, ну и давайте их сразу будем, мы их сразу будем
[34:10.980 --> 34:15.780]  нормировать, потому что если нас просят найти пересекание полуплоскостей, то даже если здесь
[34:15.780 --> 34:20.060]  все целое, если коэффициенты целые, если они задавались целыми точками, целочисленными точками
[34:20.060 --> 34:26.180]  какими-то, вот целочисленными точками на прямой, то когда вы пересекаете прямые, вы там без доблов
[34:26.180 --> 34:30.820]  никуда. Ну или по крайней мере без рациональных чисел никуда, потому что если вы пересекаете две
[34:30.820 --> 34:37.380]  прямые, то точка перчения там может быть какая угодно, дробная. Вот, поэтому сразу давайте считать,
[34:37.380 --> 34:43.060]  что у нас здесь все смело в доблах, в числах с плавающей точкой, ну и поэтому собственно мы
[34:43.060 --> 34:54.980]  можем вот эти векторы сразу нормировать. Можем сразу нормировать. То есть сделать так, что длина
[34:55.620 --> 34:59.140]  это векра единица, то есть сумма кваратов A и B равна единице.
[34:59.140 --> 35:23.220]  Так.
[35:23.220 --> 35:31.780]  Да, ну теперь вопрос, да, как вообще в принципе может выглядеть пересечение
[35:31.780 --> 35:35.420]  N полуплоскостей? Вот вы что-то на плоскость набросали какие-то полуплоскости, пересекли,
[35:35.420 --> 35:40.300]  что может получиться? Ну в хорошем случае, собственно, в тот цикл, на который мы будем
[35:40.300 --> 35:43.900]  закладываться, у нас получается выпуклый многоугольник, какой-то конечный выпуклый
[35:43.900 --> 35:48.580]  многоугольник, да. То есть, например, если вы берете и пересекаете вот такую полуплоскость,
[35:48.580 --> 35:57.460]  вот такую полуплоскость, вот такую, вот такую, вот такую и вот такую, то их пересечение как раз
[35:57.460 --> 36:03.460]  вот этот выпуклый многоугольник. Это как раз самый такой, ну самый хороший что-ли случай. Но,
[36:03.460 --> 36:07.980]  естественно, бывает много других гадостей, да, бывает, например, что пересечение это не выпуклый,
[36:07.980 --> 36:12.900]  pardon, неограничный выпуклый многоугольник. Например, что у них вот такое, если вы пересекаете,
[36:13.080 --> 36:17.580]  если вы вот такие полуплоскости пересекаете, то пересечение это вот такая вот чашка,
[36:17.580 --> 36:25.540]  бесконечный верх. Может быть такое, что вы пересекли две вот такие вот полуплоскости и
[36:25.540 --> 36:31.860]  получили полоску неограниченную сверху и снизу. Может быть такое, что вы получили какую-нибудь
[36:31.860 --> 36:37.660]  прямую, например, если вы пересекли вот такую полуплоскость и вот такую. У вас может быть прямая.
[36:37.660 --> 36:41.980]  Ну, соответственно, где прямая, там и отрезок может быть, если вы пересекли
[36:41.980 --> 36:49.580]  вот такую и такую полуплоскости, скажем, еще вот такие две, то у вас першень — это отрезок. Значит,
[36:49.580 --> 36:54.380]  также может быть точка, ну и, конечно, пустое множество, если у вас какие-нибудь противоречия
[36:54.380 --> 37:00.860]  явные есть. Вот. Ну, конечно, всякая гадость бывает, кроме нормального случая, когда у нас
[37:00.860 --> 37:04.820]  получается невыраженный, ограниченный выпуклённого угольника, в смысле положительной площади,
[37:04.820 --> 37:11.740]  бывает еще много всяких таких неприятных штук. Самое неприятное здесь, на самом деле,
[37:11.740 --> 37:19.340]  это вот эти два случая, когда у нас ногогольник неограниченный получается. Вот. И мы с этим будем
[37:19.340 --> 37:25.220]  бороться следующим образом. Давайте мы поместим все наше безобразие в некий bounding box, в такую
[37:25.220 --> 37:32.140]  большую коробочку, где заведомо лежат все точки пересечения. Все точки пересечения наших
[37:32.140 --> 37:37.420]  полплоскостей там точно лежат. Ну и тогда, соответственно, представьте, что мы вот эту
[37:37.420 --> 37:45.220]  чашку помещаем в какую-то супергигантскую коробку вот такую. Вот так вот я нарисую. Да, тогда понятно,
[37:45.220 --> 37:50.140]  что здесь он правильно адекватно себя ведет, а там на бесконечность он пересекается, ну где-то там
[37:50.140 --> 37:58.540]  очень далеко он с этой коробкой пересекается, получается вот такой вот отрезок. То есть мы с
[37:58.540 --> 38:03.300]  одной стороны поняли, что наш ногогольник бесконечный, да, раз он пересекается где-то там далеко с
[38:03.300 --> 38:09.220]  bounding box, вот. Но и с другой стороны поняли, как он себя ведет на вот этом вот конечном нормальном
[38:09.220 --> 38:14.180]  куске плоскости. То есть там, где они все пересекаются, мы понимаем, как он себя ведет, а также, что он там
[38:14.180 --> 38:20.100]  бесконечен куда-то на плюс бесконечность. Ну или, короче, куда-то в сторону бесконечных координат,
[38:20.100 --> 38:33.980]  он бесконечный. Вот, поэтому, значит, подход такой. Значит, ведем bounding box. Наверное,
[38:33.980 --> 38:38.340]  я не буду переводить, ну как бы ограничивающая коробочка, да, ограничивающий прямоугольник,
[38:38.340 --> 38:44.220]  внутри которого мы рассматриваем все наше, весь наш мир. Значит, он будет у нас такой, х не больше
[38:44.220 --> 38:58.300]  чем, ну давайте напишу, с, х больше равно минус с, у меньше равно с, у больше равно минус с. Вот,
[38:58.300 --> 39:03.540]  и находим уже, после этого у нас, то есть если я насильно вот эти четыре полуплоскости добавлю
[39:03.540 --> 39:08.820]  в наш мир, в наши н-полуплоскости, в наш список полуплоскостей, то у меня многогольник заведомо
[39:08.820 --> 39:12.620]  станет конечным, потому что у меня все находится внутри вот такого, как бы, конечного квадрата.
[39:12.620 --> 39:33.740]  А тогда сразу, тогда пересечение сразу становится конечным. Но при этом также мы можем задетектить,
[39:33.740 --> 39:38.140]  не является ли оно на самом деле бесконечным. Делается очень просто, если в вашем результатившем
[39:38.140 --> 39:43.060]  многоугольнике есть хотя бы одна точка на этой границе bounding box, то на самом деле у вас вот
[39:43.060 --> 39:48.740]  реально такая картинка, и как бы, вот эта вот граничная точка, она на самом деле ограничивает
[39:48.740 --> 39:53.940]  ваш бесконечный многоугольник. То есть мы не просто сузили его на какую-то конечную область,
[39:53.940 --> 39:57.860]  но еще и можем однозначно понять, не является ли он на самом деле бесконечным, если нам это почему-то
[39:57.860 --> 40:08.500]  вдруг нужно. Ну и чтобы ничего не потерять, чтобы не отрезать каких-нибудь точек случайно,
[40:08.500 --> 40:13.100]  нужно C подобрать таким, чтобы внутри bounding box заведомо лежали все пересечения всех прямых.
[40:13.100 --> 40:39.460]  C надо подобрать так, чтобы внутри bounding box лежали точки пересечения всех пар прямых.
[40:43.100 --> 40:57.340]  Если мы это обеспечим, если мы подберем такое достаточно большое C, то мы точно никакие вершины
[40:57.340 --> 41:01.220]  нашего многоугольника не потеряем, потому что понятно, что вершины это обязательно какие-то
[41:01.220 --> 41:06.060]  пересечения прямых, прямых из вот этого нашего множества, ну и значит мы ограничим как раз только
[41:06.060 --> 41:11.100]  на бесконечности. Ничего вот здесь мы лишнюю не отрежем, если обеспечим, что все вершины,
[41:11.260 --> 41:15.260]  точнее все точки пересечения у нас сохраняются внутри bounding box, тогда мы ничего не отрежем лишнего.
[41:15.260 --> 41:26.780]  Вот. Ну мы не будем так делать, потому что это будет уже квадратичное время. Мы не будем так
[41:26.780 --> 41:32.660]  делать, потому что уже будет квадрат по времени. Вот. Ну как-нибудь вот можно оценить. На семинар
[41:32.660 --> 41:36.780]  будет задачка, что если у вас все прямые изначально задавались целыми координатами,
[41:36.780 --> 41:44.660]  от там по модуле не больше, чем какой-нибудь A, тогда у вас C достаточно взять типа A в кубе.
[41:44.660 --> 41:50.420]  То есть если у вас координаты изначально все были там порядка 10.9, то C можно взять порядка 10.27,
[41:50.420 --> 41:56.780]  тогда у вас короче точки заведомо будут внутри. Ну да, не очень приятно, но с точки зрения теории
[41:56.780 --> 42:06.260]  надо делать именно так. Вот. Ну хорошо. На счет пусть там какой-то C взяли достаточно большое.
[42:06.260 --> 42:24.020]  Алгоритм за n в квадрате. Давайте мы начнем с bounding box.
[42:24.020 --> 42:33.420]  А дальше будем вводить в рассмотрение все наши полуплоскости и пересекать текущий
[42:33.420 --> 42:38.060]  многоугольник с очередной полуплоскостью и ограничивать соответственно исходный
[42:38.060 --> 42:42.780]  многоугольник на новую полуплоскость. То есть вот скажем мы знаем, что изначально пересечение
[42:42.780 --> 42:49.300]  у нас вот такое bounding box. Потом приходит какая-то первая полуплоскость, вот такая.
[42:49.300 --> 42:54.700]  Тогда как теперь выглядит пересечение? Нам нужно пересечь bounding box с полуплоскостью.
[42:54.700 --> 43:02.940]  Теперь их пересечение это вот это. Ну как-нибудь его найдем. Дальше у нас есть выпуклый многоугольник,
[43:02.940 --> 43:09.140]  вот такой. Приходит очередная полуплоскость, их нужно пересечь. Давайте как-нибудь оно,
[43:09.140 --> 43:17.060]  не знаю, вот так вот выглядит. Их надо пересечь. Ну понятно, вот оно пересечение. И так далее.
[43:17.060 --> 43:23.380]  И так далее. То есть у нас на каждой террации есть выпуклый многоугольник, приходит прямая.
[43:23.380 --> 43:28.100]  По сути нам нужно просто пересечь прямую с этим многоугольником и взять одну из двух частей.
[43:28.100 --> 43:33.660]  Все очень просто. Каждая террация работает за линейное время, потому что мне нужно по сути
[43:33.660 --> 43:39.580]  просто пересечь эту прямую со всеми сторонами, коих не больше чем n. Ну и потом взять одну из
[43:39.580 --> 43:45.860]  двух частей и будет у нас новый, ну как бы один из них, один из этих многоугольников, а именно тот,
[43:45.860 --> 43:53.340]  который лежит вот по этому сторону от прямой и будет нашим новым многоугольником. Даже не
[43:53.340 --> 44:11.940]  знаю, что написать. Итеративно вводим по одной полуплоскости, по одной полуплоскости пересекаем
[44:11.940 --> 44:35.220]  текущий многоугольник с полуплоскостью. Вот. Значит это в принципе довольно хороший алгоритм.
[44:35.220 --> 44:42.060]  И если n у вас действительно там не очень большой такой, что n квадратный можете себе
[44:42.060 --> 44:47.340]  позволить, то я бы советовал наверное писать его, потому что по сравнению с алгоритмом design log n,
[44:47.340 --> 44:53.460]  ну как бы этот попроще будет. Вот. И поэтому поскольку он может быть полезен, давайте я немножко
[44:53.460 --> 45:00.300]  больше деталей дам, как именно его можно реализовать. Значит, ну вот пусть у вас был многоугольник,
[45:00.300 --> 45:15.740]  все вершины его как-то там занумированы, v1, v2 и так далее, vn. Вот. Давайте vk пусть будет. Так,
[45:15.740 --> 45:20.420]  понятно почему за квадрат это работает. Потому что n трация, на каждой трации у нас есть максимум
[45:20.420 --> 45:25.860]  n угольник, мы его пересекаем с прямой за линию, за o от n, и того n квадрат. Ну так вот, пусть есть
[45:25.860 --> 45:30.100]  многоугольник с ковершинами пронумерованными, приходит какая-то очередная полуплоскость,
[45:30.100 --> 45:36.180]  мы хотим ограничить наш многоугольник на полуплоскость, пересечь. Значит, простые
[45:36.180 --> 45:41.980]  случаи. Если все вершины исходного многоугольника лежат по правильную сторону от прямой, то делать
[45:41.980 --> 45:59.900]  ничего не надо. Значит, случай один. Если все вершины лежат в новой полуплоскости, то делать
[45:59.900 --> 46:11.220]  ничего не надо. Вот. И благо у нас полуплоскости заданы очень удобно, заданы неравенством,
[46:11.220 --> 46:16.020]  а x плюс y плюс все большего нуля. Значит, мне нужно просто координаты всех вершин их подставить в это
[46:16.020 --> 46:20.940]  уравнение, ну в это неравенство скорее, и проверить, что оно выполняется. Если оно действительно
[46:20.940 --> 46:25.340]  всюду выполняется для всех вершин, то значит наш многоугольник просто сохраняется, он и будет
[46:25.340 --> 46:32.140]  ответом на следующем шаге. Ну наоборот, то же самое, если наоборот все неравенства не выполняются,
[46:32.140 --> 46:40.860]  тогда полуплоска какая-нибудь вот такая, и тогда ответ сразу постоит множество. Если ни одна вершина
[46:40.860 --> 46:59.580]  не лежит в полуплоскости, тогда сразу return пустое множество. Потому что у нас была какая-то фигура,
[46:59.580 --> 47:04.260]  мы ее пересекли с полуплоскостью, которая не пересекается, значит сразу пересечение пусто,
[47:04.260 --> 47:08.780]  какие бы другие полуплоскости нам не поступали. Поэтому здесь можно сразу алгоритм завершить,
[47:08.780 --> 47:15.460]  сказать, что ответ это пустое множество. Вот, ну и наконец третье, если есть вершины и такие,
[47:15.460 --> 47:19.820]  и такие, то есть и лежащие по правильной стороны, вот по полуплоскости, и по неправильной.
[47:19.820 --> 47:34.380]  То есть что-нибудь вот такое. Вот так нарисую. Вот, мне соответственно нужно выделить вот это
[47:34.380 --> 47:49.980]  угольник. Тогда мы делаем следующее. Мы делаем цикл по всем сторонам, рассматриваем какую-то
[47:49.980 --> 47:57.100]  сторону v и v и плюс один. Вот. И давайте еще заведем какой-нибудь вектор, вершин, куда будем
[47:57.100 --> 48:01.580]  складывать вершины ответа. То есть понятно, что мне нужно как бы в качестве ответа вернуть
[48:01.580 --> 48:07.580]  вектор из вот этих вот вершинок в каком-нибудь порядке. А это будет, собственно, наш многоугольник
[48:07.580 --> 48:12.020]  очередной. Вот давайте я заведу вектор и буду в него поочередно складывать все вершины, которые
[48:12.020 --> 48:18.740]  я нахожу. То есть нашел очередную вершинку пересечения, положил ее в вектор. Итак, значит
[48:18.740 --> 48:28.180]  здесь есть следующие случаи. Во-первых, если обе эти вершины лежат вне полуплоскости, давайте
[48:28.180 --> 48:33.460]  я уже как-нибудь назову h от слова half plane полуплоскости. Если они обе не лежат в полуплоскости,
[48:33.460 --> 48:45.220]  то я просто делаю continue. v и не лежит в h, v и плюс один не лежит в h, тогда просто continue. Ну,
[48:45.220 --> 48:50.380]  это, грубо говоря, случай вот этой вот стороны. А у нас сторона лежит вне полуплоскости, понятно,
[48:50.380 --> 48:58.380]  что она вершин в пересечении не добавляет. Если, наоборот, обе вершины лежат в полуплоскости,
[48:58.380 --> 49:19.340]  тогда я добавлю в наш список только v и плюс первую. Ну, я не буду добавлять и то, и то,
[49:19.340 --> 49:22.740]  чтобы у меня не было повторений, потому что, например, если я рассматриваю вот эту сторону,
[49:22.740 --> 49:26.660]  а потом вот эту и добавляю оба конца каждый раз, то у меня бы эта вершинка продублировалась.
[49:26.660 --> 49:29.420]  Вот давайте, чтобы этого не было, буду добавлять только вторую из них.
[49:29.420 --> 49:40.740]  Случай v. Если предыдущая не лежала, а следующая лежит,
[49:40.740 --> 49:48.620]  тогда у меня получается картинка, что как бы я был вне полуплоскости, теперь попал в нее. То
[49:48.620 --> 49:56.740]  есть картинка какая-то такая. Вот у меня была h вот здесь, вот v и вот здесь, а v плюс 1 вот здесь.
[49:56.740 --> 50:02.620]  Тогда у меня появляется некая новая точка, точка пересечения нашего отрезка и полуплоскости,
[50:02.620 --> 50:08.500]  стороны полуплоскости q. Тогда я добавлю в наш список сначала q, а потом v и плюс первую.
[50:08.500 --> 50:22.460]  Ну и последний случай. Если наоборот v и в h, а v плюс 1 не в h, тогда картинка будет у нас наоборот.
[50:22.460 --> 50:32.020]  v и плюс 1 где-то здесь. Опять-таки есть некая точка пересечения. Вот ее я добавлю в наш список.
[50:32.020 --> 50:45.140]  Это q. Это просто q. Все, в конце я утверждаю, что у меня будет просто список вершин нашего
[50:45.140 --> 50:51.940]  многоугольника результирующего. Интуиция такая, что к моменту времени, когда я прихожу к какому-то
[50:51.940 --> 50:58.700]  такой картинке или такой, у меня предыдущая вершина v и t, если надо, она уже добавлена в
[50:58.700 --> 51:03.740]  наш список. Здесь не надо было добавлять, она добавлена вот здесь. Если у меня рассматривается
[51:03.740 --> 51:08.340]  такой случай, когда я лежал в многоугольнике, потом вышел из него, то к этому моменту v и
[51:08.340 --> 51:14.300]  уже добавлена в наш список просто потому, что я так шел. И если вот скажем здесь у меня было
[51:14.300 --> 51:18.140]  две подряд идущие вершины в h, то я вторую из них обязательно добавляю. У меня v и плюс 1 всегда
[51:18.140 --> 51:22.580]  добавляется, если она лежит в полуплоскости. Поэтому v и t, если надо, уже была добавлена. Не то,
[51:22.580 --> 51:27.380]  что я пропустил добавил q, а я ее уже обязательно добавил. Поэтому она точно в списке есть,
[51:27.380 --> 51:33.140]  я ничего не пропущу. Но тем самым я как раз все вершинки в правильном порядке добавлю.
[51:33.140 --> 51:45.380]  Окей? Ну все. Единственное, здесь нужно аккуратно разобраться со случаем, когда q совпадает с
[51:45.380 --> 51:51.740]  и плюс 1, когда не надо ее дублировать. И здесь тоже, если q совпадает с v, то ее не надо добавлять.
[51:51.740 --> 52:03.540]  Вот. А так у нас получается просто многоугольник, даже без дубликтированных вершин. Так,
[52:03.540 --> 52:09.420]  за квадрат понятно, идем дальше. Хорошо, тогда у нас следующий алгоритм за n log n.
[52:09.420 --> 52:23.100]  Так, алгоритм за n log n. Ну давайте номер 1 я его назову. Два рассмотрим. Они очень похожи,
[52:23.100 --> 52:31.020]  просто как бы что удобно, то пишите. Значит, и начало у них одинаковое. Давайте мы свалим все
[52:31.020 --> 52:35.260]  наши полуплоскости в одну кучу. Включаю bounding box, который тоже на самом деле является
[52:35.380 --> 52:42.500]  полуплоскостями. Свалим все в одну кучу и поделим на две группы. Значит, у нас будет первая группа,
[52:42.500 --> 52:48.620]  это те полуплоскости, у которых нормальный вектор, грубо говоря, смотрит вверх. Вторая
[52:48.620 --> 52:53.700]  это те, у которых, грубо говоря, нормальный вектор смотрит вниз. Более формально, первая группа
[52:53.700 --> 53:01.800]  это те, у которых нормальный вектор вот такой, один из вот таких. То есть это набор углов 0
[53:01.800 --> 53:09.200]  от нуля до пи, не включительно пи, ну как бы от вот этого
[53:09.200 --> 53:13.880]  обычного направления оси ОХ. Вторая группа полуплоскостей
[53:13.880 --> 53:16.480]  — это те, у которых нормально образуют вот такие углы,
[53:16.480 --> 53:20.280]  ну точнее вот такие векторы. Все вплоть до вот этого,
[53:20.280 --> 53:23.560]  то есть это набор углов от пи до 2п, не включительно.
[53:23.560 --> 53:29.880]  Да, ну и соответственно как бы мы знаем все такое
[53:29.880 --> 53:32.440]  нормальный вектор, это вектор с координатами АВ, то есть
[53:32.440 --> 53:35.840]  здесь условия на принадлежность первой группе следующие.
[53:35.840 --> 53:39.080]  У вас либо В больше нуля, то есть он смотрит вверх,
[53:39.080 --> 53:44.680]  или же В равно нулю, но при этом А больше нуля. Это
[53:44.680 --> 53:46.320]  вот специально отдельно выделенный горизонтальный
[53:46.320 --> 53:54.520]  вправо вектор. Здесь В меньше нуля или В равно нулю и А
[53:54.520 --> 53:59.760]  отрицательно. Вот это специально выделенный влево вектор.
[53:59.760 --> 54:04.640]  Разбили на две такие группы. Это немножко похоже на то,
[54:04.640 --> 54:07.960]  когда мы строим выпуклую оболочку нижнюю и верхнюю
[54:07.960 --> 54:10.040]  отдельно. Вот давайте отдельно построим нижнюю и отдельно
[54:10.040 --> 54:15.800]  верхнюю. Идея такая. Значит, вот разбили на две группы.
[54:15.800 --> 54:18.160]  Дальше внутри группы давайте эти векторы посортируем.
[54:18.160 --> 54:20.640]  То есть внутри каждой группы посортируем все полуплоскости.
[54:20.640 --> 54:24.600]  В порядке вот такого вращения против часовой стрелки
[54:24.600 --> 54:27.960]  по сравнению с положительным направлением оси ОХ все
[54:27.960 --> 54:30.200]  полуплоскости вот так отсортируем. То есть это будет нулевая,
[54:30.200 --> 54:32.240]  первая, вторая, третья и так далее. Здесь то же самое
[54:32.240 --> 54:34.920]  нулевая, первая, вторая, третья и так далее. Внутри
[54:34.920 --> 54:52.920]  каждой группы отсортируем полуплоскости по углу. Ну
[54:52.920 --> 54:55.920]  и делается просто с помощью векторного произведения.
[54:55.920 --> 54:58.880]  Углы считать не нужно, просто по векторному произведению.
[54:58.880 --> 55:01.520]  Если есть вот такой вектор и вот такой вектор, мы смотрим
[55:01.520 --> 55:03.880]  на их векторное произведение и понимаем, что если отсюда
[55:03.880 --> 55:06.520]  сюда поворот против часовой, то значит это должно быть
[55:06.520 --> 55:09.040]  раньше, чем этот. Ну, как всегда. Чтобы понять, кто
[55:09.040 --> 55:11.840]  из векторов раньше, считаем векторное и по знаку понимаем,
[55:11.840 --> 55:16.240]  кто из них должен идти раньше второго. Вот посортировали.
[55:16.240 --> 55:17.880]  То есть у нас теперь вот здесь такой порядок, здесь
[55:17.880 --> 55:32.880]  такой порядок. Значит, дальше. Ну вот, первый алгоритм
[55:32.880 --> 55:37.520]  такой. Смотрите, у нас точно есть обязательно полуплоскости
[55:37.520 --> 55:42.280]  с вот таким вектором горизонтально вправо и вот таким горизонтально
[55:42.280 --> 55:46.600]  влево. Это bounding box, вертикальный прямой bounding box. Если там
[55:46.640 --> 55:49.120]  есть несколько параллельных, то если кроме bounding box есть
[55:49.120 --> 55:51.960]  еще какие-то дополнительные прямые, то понятно, что из них
[55:51.960 --> 55:55.320]  есть смысл оставить только самую мощную, а именно ту,
[55:55.320 --> 55:57.200]  у которой c минимально. То есть если есть несколько
[55:57.200 --> 56:01.440]  параллельных прямых, тех, у которых a и b нормальные
[56:01.440 --> 56:03.360]  векторы одинаковые, то из них есть смысл оставить
[56:03.360 --> 56:06.120]  только самое сильное неравенство, то есть то, у которого c минимально
[56:06.120 --> 56:08.640]  возможно. Ну, давайте такие оставим. То есть параллельные
[56:08.640 --> 56:10.960]  прямые выкинем и оставим из них только самое сильное
[56:10.960 --> 56:17.440]  неравенство. Вот. И разберемся с первой категорией. Значит,
[56:17.440 --> 56:24.320]  рисую bounding box, вертикальные прямые. Это пока не буду
[56:24.320 --> 56:28.560]  рисовать. Давайте добавлять вот эти прямые по очереди
[56:28.560 --> 56:32.040]  в порядке сортировки из первой группы. Сначала будет какая-то
[56:32.040 --> 56:34.640]  вот такая полуплоскость, потом вот такая чуть более
[56:34.640 --> 56:38.520]  наклонная, потом вот такая еще чуть, ну как бы еще более
[56:38.520 --> 56:41.360]  завернутая и так далее. И на самом деле, за счет
[56:41.360 --> 56:45.240]  того, что мы их рассматриваем в таком порядке, у нас каждая
[56:45.240 --> 56:47.600]  очередная полуплоскость заведомо дает какое-то
[56:47.600 --> 56:50.560]  новое ограничение, потому что, ну то есть если у вас
[56:50.560 --> 56:52.720]  вот была какая-то такая картинка, и потом вы строите
[56:52.720 --> 56:56.160]  какую-то еще более крутую прямую, то она на бесконечность
[56:56.160 --> 56:57.840]  обязательно будет самая высокая. Ну, у нее как бы
[56:57.840 --> 57:00.200]  максимальный вот такой угловой коэффициент, поэтому
[57:00.200 --> 57:03.720]  она точно будет максимальная там для достаточно больших
[57:03.720 --> 57:08.920]  координат. Поэтому здесь обновление очень простое.
[57:08.920 --> 57:12.720]  Давайте мы просто проведем эту прямую, эту полуплоскость,
[57:12.720 --> 57:15.200]  и если что, нам нужно будет удалить несколько последних
[57:15.200 --> 57:17.600]  полуплоскостей, которые у нас лежали в нашем списке.
[57:17.600 --> 57:19.960]  То есть смотрите, вот это хороший случай, если я добавил,
[57:19.960 --> 57:22.280]  у меня как бы, ну, по сути, она просто дала очередную
[57:22.280 --> 57:26.160]  вершинку. Но если бы она лежала, например, вот здесь,
[57:26.160 --> 57:27.840]  то у меня, соответственно, вот эта предыдущая лежащая
[57:27.840 --> 57:29.400]  здесь прямая, она как бы становится лишняя, потому
[57:29.400 --> 57:31.760]  что она накладывает более слабые условия по сравнению
[57:31.760 --> 57:34.640]  с новой. Я мог эту прямую просто затереть и забыть
[57:34.640 --> 57:37.000]  про нее. Да, то же самое, если бы она лежала еще
[57:37.000 --> 57:39.880]  левее где-нибудь вот здесь вот, то не только это бесполезные
[57:39.880 --> 57:42.840]  условия, но и вот это горизонтальное, потому что, ну, как бы вот
[57:42.840 --> 57:45.080]  на самом деле пересечение, и здесь это горизонтально
[57:45.080 --> 57:49.360]  уже не входит. И по сути, алгоритм очень похож на алгоритм
[57:49.360 --> 57:52.240]  по сравнению выпуклооболочки, когда мы там вот снизу ее
[57:52.240 --> 57:55.960]  строили, мы идем слева направо, добавляется полуплоскость,
[57:55.960 --> 57:58.000]  которая заведомо лежит в пересечении, так же как
[57:58.000 --> 58:00.120]  точка лежала, потому что она была самая правая, так
[58:00.160 --> 58:02.480]  здесь полуплоскость лежит, потому что она самая наклонная
[58:02.480 --> 58:06.040]  вот в этом направлении. Ну, и мы просто удаляем несколько
[58:06.040 --> 58:08.960]  последних, пока они дают более слабые условия, чем
[58:08.960 --> 58:14.040]  новая прямая. Вот, и в конце у нас первая группа целиком
[58:14.040 --> 58:16.560]  обработается, закончится на вертикальной прямой,
[58:16.560 --> 58:21.400]  ну, поскольку она там достаточно там, нет, ну а что? Нет, ну
[58:21.400 --> 58:23.560]  просто короче, она закончится на какой-то вот такой вертикальной
[58:23.560 --> 58:28.120]  прямой, и все. Значит, алгоритм пишется очень просто. Мы
[58:28.120 --> 58:37.000]  храним вектор прямых, храним вектор прямых, вектор прямых,
[58:37.000 --> 58:42.080]  ну, я буду смешивать понятие прямая и полуплоскость,
[58:42.080 --> 58:44.200]  потому что они хранятся все равно в одной структуре,
[58:44.200 --> 58:48.000]  по крайней мере в моей голове. Может, это и плохо так делать
[58:48.000 --> 58:50.360]  на практике, но вот я буду так делать, потому что они
[58:50.360 --> 58:52.360]  задаются тремя чистыми, они будут в одной структуре
[58:52.360 --> 58:55.720]  у меня. Значит, вектор прямых, рассматриваем прямые в
[58:55.720 --> 59:04.600]  порядке сортировки, рассматриваем прямые первой группы в порядке
[59:04.600 --> 59:18.440]  сортировки. И вот тут надо написать условия. Значит,
[59:18.560 --> 59:24.740]  пока в векторе хотя бы две прямые, в векторе хотя бы
[59:24.740 --> 59:34.260]  две прямые, и пересечение двух последних не льет в новую
[59:34.260 --> 59:44.020]  полуплоскость, пересечение двух последних не льет в
[59:44.020 --> 59:53.260]  новой полуплоскости.
[59:53.260 --> 59:59.620]  Ну тогда надо сделать vector.popback.
[59:59.620 --> 01:00:02.660]  Мы как бы последнюю прямую удаляем, последнюю полуплоскость
[01:00:02.660 --> 01:00:03.660]  удаляем.
[01:00:03.660 --> 01:00:05.620]  То есть это как раз картинка, когда у меня была какая-то
[01:00:05.620 --> 01:00:10.060]  вот такая штука, пришла более крутая прямая, пересечение
[01:00:10.060 --> 01:00:13.100]  двух последних векторей лежало вне полуплоскости,
[01:00:13.100 --> 01:00:15.700]  значит вся эта последняя прямая задает бесполезные
[01:00:15.700 --> 01:00:19.120]  условия, его можно удалить, ее можно удалить, ну и соответственно
[01:00:19.120 --> 01:00:20.120]  игнорировать просто.
[01:00:20.120 --> 01:00:23.020]  Мы делаем это с помощью vector.popback.
[01:00:23.020 --> 01:00:26.380]  Все это while, и в конце в этот вектор, извините что
[01:00:26.380 --> 01:00:29.020]  я вектор назвал вектор, но как есть.
[01:00:29.020 --> 01:00:34.060]  Значит вектор pushback, новая прямая, вот эта вот h.i.t,
[01:00:34.060 --> 01:00:37.020]  пусть значит h.i.t, это новая полуплоскость, которую
[01:00:37.020 --> 01:00:38.020]  я рассматривал.
[01:00:38.020 --> 01:00:39.020]  h.i.
[01:00:39.020 --> 01:00:42.660]  И это корректное действие, потому что поскольку она
[01:00:42.660 --> 01:00:45.340]  более крутая, чем все предыдущие, то она точно лежит последней
[01:00:45.340 --> 01:00:48.380]  в нашей выпуклой оболочке, точнее в нашем пересечении.
[01:00:48.380 --> 01:00:52.940]  В итоге, после того, как я рассмотрел всю первую
[01:00:52.940 --> 01:00:56.680]  группу, у меня будет какая-то вот такая вот нижняя огибающая
[01:00:56.680 --> 01:00:57.680]  для всех наших прямых.
[01:00:57.680 --> 01:01:01.500]  Такая опять чашечка, которая является пересечением
[01:01:01.500 --> 01:01:03.980]  всех полуплоскостей из первой группы, ну еще я могу
[01:01:03.980 --> 01:01:07.700]  учесть вот эти вот, сейчас, вот этот вектор могу еще
[01:01:07.700 --> 01:01:12.060]  добавить, это как раз вертикальные ограничивающие справа
[01:01:12.460 --> 01:01:13.460]  bounding box.
[01:01:13.460 --> 01:01:16.100]  Да, я тоже это могу добавить, чтобы у нас была вот такая
[01:01:16.100 --> 01:01:17.100]  вот чашечка.
[01:01:17.100 --> 01:01:20.060]  Какая-то такая чашечка у нас получается.
[01:01:20.060 --> 01:01:21.060]  Понятно?
[01:01:21.060 --> 01:01:22.060]  Так, хорошо.
[01:01:22.060 --> 01:01:26.300]  Ну и на самом деле дальше можно сказать следующее.
[01:01:26.300 --> 01:01:28.780]  Давайте сделаем то же самое для верхней, для второй
[01:01:28.780 --> 01:01:31.220]  группы независимо, получение как крышечка.
[01:01:31.220 --> 01:01:37.740]  А потом с помощью scanline мы их пересечем.
[01:01:37.740 --> 01:01:40.980]  То есть вот так вот встанем вертикально прямой, идем
[01:01:40.980 --> 01:01:44.300]  слева-направо, у нас есть нижняя огибающая, верхняя
[01:01:44.300 --> 01:01:47.180]  огибающая, надо их пересечь, давайте тогда идти вот так
[01:01:47.180 --> 01:01:50.300]  слева-направо и аккуратно смотреть какой у нас сейчас
[01:01:50.300 --> 01:01:53.600]  профиль пересечения нашей прямой с крышечкой и с чашочкой.
[01:01:53.600 --> 01:01:56.420]  Вот так вот идем, видим пока нет пересечения, затем
[01:01:56.420 --> 01:01:59.020]  здесь становится, что вот эта какая-то сторона пересекается
[01:01:59.020 --> 01:02:00.020]  этой стороной.
[01:02:00.020 --> 01:02:01.620]  Здесь открываются пересечения.
[01:02:01.620 --> 01:02:03.800]  Ну дальше нужно просто все вот эти вершины перечислить
[01:02:03.800 --> 01:02:06.520]  и все вот эти вершины перечислить до того, пока они опять не
[01:02:06.520 --> 01:02:07.520]  пересекутся.
[01:02:07.520 --> 01:02:14.000]  Простая такая сканирующая прямая слева направо позволит нам пересечь нижнюю
[01:02:14.000 --> 01:02:16.600]  огибающую, верхнюю огибающую. Давайте немножко слов тут напишем.
[01:02:34.600 --> 01:02:35.600]  Аналогично
[01:02:35.600 --> 01:02:42.080]  строим верхнюю огибающую.
[01:02:44.000 --> 01:02:50.560]  Затем пересекаем их
[01:02:50.560 --> 01:02:59.080]  сканлайном
[01:02:59.080 --> 01:03:03.560]  слева направо.
[01:03:03.560 --> 01:03:13.800]  Ну то еще раз тут как бы проще на картинке объяснить. Вот есть нижняя огибающая и какая-то
[01:03:13.800 --> 01:03:24.000]  верхняя. Давайте ее вот так вот нарисуем. Встали вертикальный прямой здесь, храним
[01:03:24.000 --> 01:03:30.320]  указатель на текущую прямую здесь, на текущую прямую здесь. Встали, смотрим, что сначала
[01:03:30.320 --> 01:03:35.760]  происходит. Сначала происходит как бы прохождение этой прямой. Окей, сдвигаем указатель сюда. Дальше
[01:03:35.760 --> 01:03:40.680]  она целиком проходит, до этого еще не прошли, сдвинули указатель вот сюда. Теперь смотрим,
[01:03:40.680 --> 01:03:48.080]  ага, так, значит сначала пройдется вот эта прямая, затем мы пойдем на эту сторону. Затем
[01:03:48.080 --> 01:03:54.000]  идем, видим, что они пересекаются. Пересекаем текущие стороны, которые мы указываем,
[01:03:54.000 --> 01:03:58.840]  понимаем, что вот они где-то пересекаются. Окей, вот мы входим в пересечение. Дальше мне
[01:03:58.840 --> 01:04:04.960]  нужна верхняя часть нашего пересечения. Это последовательные вершины
[01:04:04.960 --> 01:04:08.760]  вот этой вот крышки, а нижняя часть это последовательные вершины вот этой чашки,
[01:04:08.760 --> 01:04:12.680]  на нижней огибающей. То есть мы дальше идем точно так же. Мы поддерживаем указатель на сторону
[01:04:12.680 --> 01:04:17.880]  здесь, на сторону здесь. Идем пока как бы нижняя, ниже чем верхняя. Идем, просто продолжаем,
[01:04:17.880 --> 01:04:22.720]  запихи все вершины сверху, снизу. И потом, когда они опять пересекаются, потом когда как бы
[01:04:22.720 --> 01:04:29.680]  происходит вот такое, ну как бы наложение стороны на сторону, мы опять ищем их пересечение и говорим,
[01:04:29.680 --> 01:04:33.880]  что здесь у нас завершается наше пересечение, потому что дальше они будут только расходиться еще
[01:04:33.880 --> 01:04:37.960]  дальше друг от друга. Вот, ну собственно все. То есть у нас будет отдельно верхняя,
[01:04:37.960 --> 01:04:43.240]  отдельно нижняя кусок хранится, потом их объединяем в один общий список, и получается
[01:04:43.240 --> 01:04:59.600]  список вершин нашего нагугонника. Не очень приятно, но в принципе делается. Да. Ну у нас есть два
[01:04:59.600 --> 01:05:06.760]  отрезка. Просто смотрим, у кого из них у, ну точнее х меньше. Кто раньше заканчивается,
[01:05:06.760 --> 01:05:17.640]  потому и переходим. Вот, в итоге симптотика будет действительно n log n, потому что самая сложная
[01:05:17.640 --> 01:05:22.080]  со симпатичной точки зрения это сшатировка. Вот здесь мы посортили отдельно первую-вторую группу
[01:05:22.080 --> 01:05:26.680]  за n log n. А дальше все линейный проход, потому что, ну это собственно по симпатике так же,
[01:05:26.680 --> 01:05:31.040]  как выпукла оболочка, хранится вектор, и там последние удаляются, каждая добавится максимум
[01:05:31.040 --> 01:05:36.320]  один раз. И здесь тоже у нас есть нижняя верхняя, уже все и так отсортировано слева направо,
[01:05:36.320 --> 01:05:39.880]  мы берем scanline и просто проходим там двумя указательными по нашим спискам, это уже будет
[01:05:39.880 --> 01:05:49.880]  линейное время. То есть симпточка будет действительно n log n. Значит n log n на сортировку. Все остальное от n.
[01:05:49.880 --> 01:06:12.000]  Так, вот видим второй, тоже n log n.
[01:06:19.880 --> 01:06:32.040]  Начало такое же. Посорти внутри каждой группы независимо, построим нижнюю вот эту вот огибающую.
[01:06:32.040 --> 01:06:38.920]  Но дальше я не буду независимо строить для верхней огибающей, я на самом деле просто свалю все
[01:06:38.920 --> 01:06:44.840]  полуплоскости в один список, сначала первая группа отсоединена, потом вторая. И буду делать вот
[01:06:44.840 --> 01:06:49.720]  это тоже самое. То есть я как бы сначала продаю нижнюю огибающую, и потом сразу здесь же буду
[01:06:49.720 --> 01:06:54.320]  доблюдать верхнюю. Давайте поймем, что получится. То есть вот сначала у меня будет все окей, у меня
[01:06:54.320 --> 01:07:00.480]  будет какая-то нижняя огибающая хранится. Потом поступают прямые, наоборот уже вот такие,
[01:07:00.480 --> 01:07:05.240]  смотрящие куда-то вниз. То есть я начинаю рассматривать верхнюю огибающую. Ну как бы нормальный
[01:07:05.240 --> 01:07:10.760]  случай, это когда приходит очередная прямая, и как-то там что-то высекает, что-то вот такое,
[01:07:11.400 --> 01:07:21.080]  ну так все хорошо. Но на самом деле может быть такое, что, ну как обычно, у нас могут удаляться
[01:07:21.080 --> 01:07:29.720]  какие-то последние вершины. Сейчас нарисую. Ну например, когда приходит вот такая прямая,
[01:07:29.720 --> 01:07:35.800]  мне нужно удалить вот эту прямую, та из нашего вектора. Но более того, могут удаляться некие первые
[01:07:35.800 --> 01:07:44.400]  прямые. Если у нас был какой-нибудь вот такой вот текущий, текущая картинка какая-нибудь,
[01:07:44.400 --> 01:07:52.640]  вот, и приходит еще вот такая прямая, то мне нужно удалить уже первую прямую. Да, но поскольку
[01:07:52.640 --> 01:07:58.040]  как бы по сути, у меня теперь уже новые вот эти полублоски, которые я добавляю, они у меня не
[01:07:58.040 --> 01:08:03.240]  только с как бы последними прямыми пересекаются, но и с первыми тоже могут пересекаться. Поэтому мне
[01:08:03.240 --> 01:08:08.600]  еще может понадобиться удалять какие-то первые прямые из нашего вектора. Да, ну и поскольку мне
[01:08:08.600 --> 01:08:12.880]  нужно удалять не только из конца, но еще из начала, то мне нужно завести какую структуру данных
[01:08:12.880 --> 01:08:27.080]  вместо вектора. Дек. Мы будем хранить не векторы, а дек прямых. Храним дек прямых. Все остальное
[01:08:27.080 --> 01:08:32.560]  практически идентично. Значит, мы когда рассматриваем новую прямую, мы удаляем несколько последних из
[01:08:32.560 --> 01:08:36.840]  дека, пока пересечение двух последних не лежит в полуплоскости. То есть пока вот такая картинка
[01:08:36.840 --> 01:08:41.560]  выполняется, когда вот эта точка лежит вне полуплоскости, я удаляю последнюю прямую. И то
[01:08:41.560 --> 01:08:46.560]  же самое с начала. Пока пересечение первых двух не лежит в полуплоскости, я удаляю первую прямую.
[01:08:46.560 --> 01:09:06.000]  Значит, так и напишу как-нибудь кратенько. Пока пересечение двух последних не лежит в HE,
[01:09:06.000 --> 01:09:25.400]  я делаю дек.popback. То же самое с началом. Пока пересечение первых двух не лежит в HE,
[01:09:25.400 --> 01:09:41.480]  я делаю дек.popfront. Да, удаляю первый элемент из дека. Вот. Ну это довольно естественная штука,
[01:09:41.480 --> 01:09:44.880]  что у нас теперь пересечение может не только какие-то граничные условия с конца давлять,
[01:09:44.880 --> 01:09:52.920]  но и с начала. Вот. Почти все, надо еще только понять при каком условии надо саму HE добавить в
[01:09:52.920 --> 01:09:59.080]  дек. Но ее нужно добавить, если она действительно как бы дает какое-то ограничение. А это случай,
[01:09:59.080 --> 01:10:10.960]  ну вот смотрите, когда она добавляет какое-то ограничение. Когда пересечение первый и
[01:10:10.960 --> 01:10:16.760]  последний не лежит в HE, тогда ее нужно обязательно добавить. Потому что если бы она лежала в HE,
[01:10:16.760 --> 01:10:22.280]  то получается она лежит где-то здесь, и она новых ограничений не добавляет. Вот. Поэтому условия
[01:10:22.280 --> 01:10:29.320]  здесь я пропишу так. Значит, если перешли уже ко второй группе, ну не так. Если мы в первой
[01:10:29.320 --> 01:10:33.680]  группе, то она обязательно добавляется просто автоматически, вот из этой штуки, поскольку она
[01:10:33.680 --> 01:10:38.360]  более крутая, чем все предыдущие, она точно будет лежать в деке. Значит, если в первой группе,
[01:10:38.360 --> 01:10:51.800]  если HE, например, в первой группе, то мы ее точно добавляем в дек, то дек pushback HE, точно добавляем.
[01:10:51.800 --> 01:10:57.640]  Вот. А если мы в второй группе, то нужно проверять условия, что она вот, ну как бы, что она уже может
[01:10:57.640 --> 01:11:02.160]  быть не, не существенная. Она может уже не добавлять ограничений. Для этого нужно пересечь
[01:11:02.160 --> 01:11:11.320]  первую и последнюю в случае, если она не вот эта вертикальная. Значит, ну давайте я грубо напишу,
[01:11:11.320 --> 01:11:30.200]  если HE принадлежит 2, кроме вертикальной прямой, то добавлять в дек, добавляем в дек,
[01:11:30.200 --> 01:11:44.360]  только если пересечение первой и последней из дека не лежит в HE, только если пересечение
[01:11:44.360 --> 01:12:07.840]  первой и последней дек не лежит в HE. Ну вот как-то так.
[01:12:14.360 --> 01:12:31.800]  Ну вроде все. Да, тогда у нас, смотрите, как работает наш алгоритм. Первую группу он обрабатывает
[01:12:31.800 --> 01:12:36.680]  точно так же, как предыдущий алгоритм. То есть он просто идет по первой группе, вот здесь вот, да.
[01:12:36.680 --> 01:12:47.360]  Так. Ну да, он идет просто по первой группе, добавляет вот это вот с концом, то есть он
[01:12:47.360 --> 01:12:51.520]  делает вот эти вот проверки. Он делает еще ненужные проверки про пересечение первых двух не лежит в
[01:12:51.520 --> 01:13:00.560]  HE, и на самом деле это для первой группы никогда не выполняется. Но если выполняется, так. Короче,
[01:13:00.560 --> 01:13:03.880]  для первой группы эта группа никогда не выполняется. То есть если вдруг это верно,
[01:13:03.880 --> 01:13:09.640]  то они на самом деле удалились бы еще вот здесь вот. Если картинка такая, что как-то вот так вот,
[01:13:09.640 --> 01:13:16.840]  и приходит новая полуплоскость вот такая, то мы раньше удалили бы эту прямую, и эта штука
[01:13:16.840 --> 01:13:20.480]  на самом деле никогда для первой группы не выполняется. Затем ее насильно добавляем,
[01:13:20.480 --> 01:13:24.200]  потому что она точно дает новые условия. Потом, когда я перехожу ко второй группе,
[01:13:24.200 --> 01:13:30.880]  у нас уже многоугольник выглядит как-то вот так. Какой-то такой многоугольник, вот эта вот штука,
[01:13:30.880 --> 01:13:36.800]  ограниченная полуплоскостями. Приходит новая прямая. Значит, она либо вообще бесполезна,
[01:13:36.800 --> 01:13:43.200]  тогда это соответственно вот этот случай, когда вот это условие неверно, я ее в дека не добавлю,
[01:13:43.200 --> 01:13:50.240]  и ничего из дека не удалю. Либо же она может, давайте вот такой случай нарисую, какой-нибудь там
[01:13:50.240 --> 01:13:56.760]  самый плохой, как вот так ее нарисую. Она удаляет несколько последних и несколько первых из дека.
[01:13:56.760 --> 01:14:00.640]  Она удалила вот эту, вот эту, вот эту, это были несколько последних, а также вот эту,
[01:14:00.640 --> 01:14:07.200]  вот эту несколько первых. Нет, это он не удалит, только вот эту. Вот. И в конце я ее добавлю в дек.
[01:14:07.200 --> 01:14:21.040]  Сейчас. Блин, сейчас, момент. Вот то, что я написал здесь первый-последний,
[01:14:21.040 --> 01:14:34.480]  это первый-последний вот в этот момент времени. Или так, да, если что-то удалили, то добавить.
[01:14:34.480 --> 01:14:39.120]  Но это недостаточно того, чтобы что-то удалили, потому что она могла быть вот так вот выглядеть,
[01:14:39.120 --> 01:14:44.720]  да, и если мы ничего не удалили, то тоже ее надо добавить. Ну да, если мы хоть что-то удалили,
[01:14:44.720 --> 01:14:49.040]  или если ничего не удалили, то верно вот это, то мы ее добавляем. Да, так верно. Значит, давайте я
[01:14:49.040 --> 01:14:58.060]  здесь вставлю или хоть что-то удаляли, или хоть что-то удаляли, да. Ну либо можно
[01:14:58.060 --> 01:15:01.300]  сказать, что мы вот эту проверку выносим в самое начало, то есть проверяем правда
[01:15:01.300 --> 01:15:05.900]  лишь, что перещение первое и последнее не лежит в h it, и если это верно, здесь было,
[01:15:05.900 --> 01:15:12.000]  то в самом конце я h it добавлю в дек. То есть я вот это условие про принадлежность, ну как
[01:15:12.000 --> 01:15:16.660]  бы про существенность h i выношу в самое начало, если она выполняется в начале, то я в конце
[01:15:16.660 --> 01:15:22.860]  добавляю в дек. Вот так лучше, то есть условия в начало, а pushback, так сейчас,
[01:15:22.860 --> 01:15:33.060]  а pushback в дек я делаю в самом конце, ну собственно, когда все очищу от ненужных прямых. Ну вот,
[01:15:33.060 --> 01:15:41.260]  получается, что мы как бы ну сквозняком все наши прямые рассмотрим, удалим как бы те,
[01:15:41.260 --> 01:15:48.500]  которые несущественны. Вот. Все, хорошо. Ну понятно, что 8 точек здесь будет тоже n log m,
[01:15:48.500 --> 01:15:56.140]  потому что кроме сортировки у нас только линейный проход по деку. Ну какие-то тонкости, какие здесь
[01:15:56.140 --> 01:16:05.380]  есть тонкости? Тонкости. Значит, во-первых, то, что я сказал, с параллельными прямыми надо
[01:16:05.380 --> 01:16:11.860]  разобраться. Из параллельных прямых мы оставляем всегда только самую сильную. Из параллельных прямых
[01:16:11.860 --> 01:16:29.740]  оставляем самую сильную. Самую сильную. Да, ну то есть, что такое параллельные прямые? Это те,
[01:16:29.740 --> 01:16:36.460]  у которых a и b одинаковые. a и b фиксированные, то есть те, которые лежат в одной группе и при
[01:16:36.460 --> 01:16:45.060]  этом у них как бы коллинеарные эти векторочки. Так вот, если у нас есть две прямые, задающие,
[01:16:45.060 --> 01:16:52.660]  соответственно, две полуплотности, то какая из них более мощная? Какая из них задает более
[01:16:52.660 --> 01:17:01.740]  сильные условия? Ну та, у которой c меньше. Если c меньше, то значит, здесь добавляется что-то маленькое,
[01:17:01.740 --> 01:17:11.740]  а значит, на это ограничение побольше будет. То есть, если c1 меньше c2, то вот это вот более сильные,
[01:17:11.740 --> 01:17:23.780]  более сильные условия. Поэтому можем в самом начале, когда мы делаем сортировку внутри первой
[01:17:23.780 --> 01:17:32.580]  группы, внутри второй группы, если мы видим две прямые с одинаковым нормальным вектором, а и b совпадают,
[01:17:32.580 --> 01:17:37.660]  то мы их, скажем, сортируем по c и игнорируем там все подряд идущие, у которых одинаковые a и b,
[01:17:37.660 --> 01:17:41.860]  берем только то, у которого c минимально. Ну или там просто удаляем их из вектора,
[01:17:41.860 --> 01:17:46.700]  чтобы они нам не мешали. Короче, оставляем только самые сильные из параллельных условий.
[01:17:46.700 --> 01:18:00.980]  Значит, еще полезное упрощение такое, что вот смотрите, здесь я все время говорил по дороге
[01:18:00.980 --> 01:18:05.260]  пересечения каких-то прямых, пересечения первых двух, последних двух, первых и последних. Короче,
[01:18:05.300 --> 01:18:12.980]  постоянно вызываю процедуру пересечение прямых. И бывает такое, в принципе, что я вызываю нашу
[01:18:12.980 --> 01:18:18.240]  процедуру для параллельных прямых. Я утверждаю, что если я вызываю эту процедуру для параллельных
[01:18:18.240 --> 01:18:25.220]  прямых, то пересечение точно пусто. То есть если вдруг где-то в процессе этого алгоритма я пытаюсь
[01:18:25.220 --> 01:18:29.820]  пересечь параллельные прямые, то у меня точно пересечение пусто, я могу сразу сказать, ага,
[01:18:29.820 --> 01:18:34.700]  ага, чел, я вижу, ты пересекаешь параллельные прямые, значит, до этого у тебя уже точно было
[01:18:34.700 --> 01:18:39.020]  какое-то противоречие, поэтому я сейчас пересекать не буду, то скажу, что пересекание пусто.
[01:18:39.020 --> 01:18:47.260]  Если алгоритм пытается пересечь параллельные прямые,
[01:18:57.260 --> 01:19:06.780]  мы сразу говорим, что ответы пустые множество. Сразу говорим, что пересечение пусто.
[01:19:06.780 --> 01:19:26.860]  Так, почему? Ну, потому что мы пересекаем всегда только какие-то соседние прямые,
[01:19:26.860 --> 01:19:31.540]  вот в порядке этого многоугольника, то есть я беру либо две последние, это вот подряд
[01:19:31.540 --> 01:19:35.580]  идущие стороны, либо две первые, либо первую последнюю, вот здесь я проверяю первую последнюю,
[01:19:35.580 --> 01:19:40.760]  то есть я всегда проверяю соседние какие-то стороны нашего многоугольника. Но извините,
[01:19:40.760 --> 01:19:44.160]  если я пытаюсь пересечь параллельные при этом, то есть у меня получаетсяalis стороны
[01:19:44.160 --> 01:19:50.260]  соседние параллельные, значит точно я что-то уже настолько не удалялся, что у меня их стороны
[01:19:50.260 --> 01:19:56.320]  двух соседних параллельных挺 много, значит я точно udah что-то такое удалил, что уже Heritage
[01:19:56.320 --> 01:20:22.320]  Ну, многоголик у меня уже точно некорректный, а такое может быть только если соседние стороны параллельны, но такого в реальном мире не бывает, такого для непустого пересечения быть не может.
[01:20:26.320 --> 01:20:49.320]  Ну, например, он что-нибудь так делал-делал, не знаю, там сначала было все нормально. Сейчас, ну что-нибудь придумаю.
[01:20:49.320 --> 01:20:58.320]  Ну, вот, например, он вот такое что-то построил, потом пришла такая прямая, вот такая, которая заставила все удалить.
[01:20:58.320 --> 01:21:08.320]  Да, в ней не лежит ни одна, короче, она дает такое ограничение, что вообще все пусто, вот, и она соответственно удаляет вот эти вот все последние.
[01:21:08.320 --> 01:21:17.320]  А первая остается, потому что ее не с кем пересекать. То есть вот эти вайлы, они работают, коль скоро у нас хотя бы две прямые в деке есть, а если она там одна, то она там одна останется, мы ее никак не можем удалить.
[01:21:17.320 --> 01:21:26.320]  Поэтому у нас после этого в деке будет типа вот это и вот это. Ну, потом, скажем, приходит сейчас вот это и вот это и вот это.
[01:21:33.320 --> 01:21:40.320]  Короче, в какой-то момент у нас в деке может быть вообще что-то неадекватное лежать, и оно соответствует пустому множеству.
[01:21:40.320 --> 01:21:47.320]  И это тогда, соответственно, если, сейчас, немножко плохой пример, да, сейчас сображу.
[01:21:49.320 --> 01:22:03.320]  Вот, я сделаю вот так вот, да, я сделаю вот так, смотрите, наоборот, я сделаю прямую какую-нибудь вот такую, оставлю вот такой, но при этом там были две последние.
[01:22:03.320 --> 01:22:11.320]  Ну, например, если бы я здесь поменял местами эти два вайла, если бы я сначала удалял первые, то я бы удалил все вот эти вот и осталась бы у меня последняя, скажем, вот эта прямая.
[01:22:11.320 --> 01:22:21.320]  Лежит вот это, а потом вот это. И тогда, потом, когда я рассматриваю следующую какую-то прямую, я буду, скажем, рассматривать, пытаться рассмотреть ее пересечения вот с этой.
[01:22:21.320 --> 01:22:24.320]  Вот, и это уже плохо, потому что они параллельны. Ну, что-то такое.
[01:22:24.320 --> 01:22:34.320]  Короче, в какой-то момент я мог удалить все, удалить все из дека так, что у меня остается там только две прямые, ну, скажем, как бы, я поудалял, осталась одна, еще вот эту в конце добавил.
[01:22:34.320 --> 01:22:38.320]  Но это тогда, как бы, соответствует тому, что на самом деле пересечение пусто.
[01:22:38.320 --> 01:22:49.320]  И вот потом, когда я пытаюсь пересекать новую прямую с кем-то, которая дает какое-то странное ограничение, которое тоже надо было удалить, но мы его не удалили, вот, ну, тогда я их могу пересечь, в принципе.
[01:22:55.320 --> 01:22:59.320]  Так, да? Да.
[01:22:59.320 --> 01:23:13.320]  Ну, наконец-то третье. Если в самом конце, если в самом конце деке не больше двух прямых, то нужно вернуть пустое нарастло.
[01:23:13.320 --> 01:23:21.320]  То пересечение пусто.
[01:23:21.320 --> 01:23:39.320]  Да, потому что если пересечение не пусто, в конце должен получиться какой-то адекватный многоугольник. Многоугольник не может сдаваться меньше, чем тремя, тремя сторонами.
[01:23:39.320 --> 01:23:50.320]  Даже если получается просто отрезок, ну, отрезок это вообще четыре аж стороны, четыре ограничения. А если их всего две, то, значит, опять я настолько наудалялся, что удалил вообще всю границу,
[01:23:50.320 --> 01:24:01.320]  положил там какую-то первую сторону и вот эту новую прямую, новую добавленную. Они не образуют многоугольника, а это соответствует тому, что ответ пустой, пересечение пусто.
[01:24:01.320 --> 01:24:18.320]  Ну, вроде все. Последнее замечание такое, что в случае, если у нас пересечение не пусто, у нас может получиться что-нибудь вот такое.
[01:24:18.320 --> 01:24:31.320]  Вот так вот еще может быть. То есть, поскольку у меня все не нравятся всегда нестрогие, то у нас, когда я построил пересечение, в деке могут лежать еще прямые, проходящие просто через вершину.
[01:24:31.320 --> 01:24:44.320]  Потому что они как будто бы задают условия нестрогие, вот такое вот. И они тоже будут лежать в нашем деке. Поэтому если мы хотим построить именно многоугольник, то мне нужно просто попересекать все пары соседних прямых и удалить дубликаты.
[01:24:44.320 --> 01:24:52.320]  Это как раз и отвечает в случае, что если у меня прямая проходит просто через вершину, тогда она как бы два раза какую-то вершину напишет.
[01:24:52.320 --> 01:25:03.320]  Удалить дубликаты вершин. Так, напишу кратко. Удалить дубликаты вершин.
[01:25:03.320 --> 01:25:05.320]  Все, спасибо.
