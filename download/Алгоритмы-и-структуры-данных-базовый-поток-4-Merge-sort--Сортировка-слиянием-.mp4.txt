[00:00.000 --> 00:08.000]  Так, алгоритмы. В прошлый раз мы с вами начали рассматривать задачи сортировки
[00:08.000 --> 00:12.000]  и рассмотрели три квадратичные сортировки, сортировка вставками,
[00:12.000 --> 00:14.000]  сортировка выборов и сортировка пузырьком.
[00:14.000 --> 00:18.000]  Каждый из них работал за квадратичное время, все плохо.
[00:18.000 --> 00:24.000]  Допустим, массив размера 1000 или 10000, таким образом вы, условно,
[00:24.000 --> 00:27.000]  можете сортировать за довольно быстрое время.
[00:27.000 --> 00:30.000]  Быстрое я имею в виду примерно меньше, чем за секунду.
[00:30.000 --> 00:33.000]  Если вам подается на вход массив размера миллион,
[00:33.000 --> 00:37.000]  то ждать, пока этот массив отсортируется, вы будете довольно долго.
[00:37.000 --> 00:42.000]  Давайте рассмотрим с вами сегодня первый пример сортировки,
[00:42.000 --> 00:44.000]  который работает быстрее, чем за квадратичное время
[00:44.000 --> 00:47.000]  и использует некоторую нетривиальную идею.
[00:47.000 --> 00:51.000]  Спойлер. Сегодня мы с вами изучим сортировку слияния.
[00:51.000 --> 00:55.000]  Давайте для начала рассмотрим, для простоты,
[00:55.000 --> 00:58.000]  давайте рассмотрим такую операцию как слияние.
[00:58.000 --> 01:05.000]  Что такое слияние? Слияние или мерч?
[01:05.000 --> 01:10.000]  Соответственно, задача слияния ставится следующим образом.
[01:10.000 --> 01:15.000]  Дано два отсортированных массива.
[01:15.000 --> 01:22.000]  Массива A и B.
[01:22.000 --> 01:41.000]  Требуется получить отсортированный массив C,
[01:41.000 --> 01:56.000]  который состоит из элементов A и B.
[01:56.000 --> 01:58.000]  Дано два отсортированных массива.
[01:58.000 --> 02:00.000]  Необходимо сделать так, чтобы появился третий массив,
[02:00.000 --> 02:02.000]  который содержит все элементы из A и B
[02:02.000 --> 02:05.000]  тоже в отсортированном порядке.
[02:05.000 --> 02:13.000]  Например, 1, 5, 7, 9 и есть массив 2, 3, 4, 10.
[02:13.000 --> 02:16.000]  Это массив A, это массив B.
[02:16.000 --> 02:27.000]  В результате слияния я должен получить массив 1, 2, 3, 4, 5, 7, 9, 10.
[02:27.000 --> 02:30.000]  Давайте разбираться, как мы это будем делать.
[02:30.000 --> 02:33.000]  Давайте сразу заведу некоторую функцию мерч,
[02:33.000 --> 02:36.000]  которая принимает исходный массив A,
[02:36.000 --> 02:41.000]  массив B и массив C, в которые нужно записывать результат.
[02:41.000 --> 02:47.000]  Смотрите, первая банальная идея заключается в следующем.
[02:47.000 --> 02:49.000]  Давайте возьмем два массива,
[02:49.000 --> 02:51.000]  запишем их в третий,
[02:51.000 --> 02:53.000]  и третий массив просто отсортируем.
[02:53.000 --> 02:55.000]  Известно нам сортировкой квадратичной.
[02:55.000 --> 02:57.000]  Как вам план?
[02:57.000 --> 02:59.000]  Так тебе.
[02:59.000 --> 03:02.000]  Если у вас суммарное количество элементов N,
[03:02.000 --> 03:05.000]  сольете два отсортированных массива за квадратичное время.
[03:05.000 --> 03:08.000]  Но кажется, что если у вас есть уже два отсортированных массива,
[03:08.000 --> 03:12.000]  то задача получения третьего массива не должна быть такой сложной.
[03:12.000 --> 03:15.000]  Будут ли какие-то приложения, как это можно сделать быстрее?
[03:19.000 --> 03:21.000]  Есть идея, два указателя.
[03:21.000 --> 03:25.000]  Действительно, задача мерч решается с помощью идеи двух указателей.
[03:25.000 --> 03:28.000]  У нас есть два массива, два отсортированных массива.
[03:28.000 --> 03:30.000]  Нам нужно получить третий.
[03:30.000 --> 03:32.000]  Давайте зададимся первым вопросом.
[03:32.000 --> 03:36.000]  Какой элемент будет идти первым в итоговом массиве?
[03:38.000 --> 03:40.000]  Понятное дело, что какой-то из этих двух.
[03:40.000 --> 03:42.000]  Либо этот, либо этот.
[03:42.000 --> 03:44.000]  Мы берем первые элементы,
[03:44.000 --> 03:46.000]  и мы точно знаем, что какой-то из них
[03:46.000 --> 03:48.000]  это наименьший элемент во втором массиве,
[03:48.000 --> 03:50.000]  это наименьший элемент в первом массиве.
[03:50.000 --> 03:53.000]  Кто-то из них обязательно должен стоять на первом месте в итоговом массиве.
[03:53.000 --> 03:54.000]  Согласны?
[03:54.000 --> 03:56.000]  Допустим, это единица.
[03:56.000 --> 03:58.000]  Что мы делаем дальше?
[03:58.000 --> 04:00.000]  Какой элемент должен идти следующим?
[04:00.000 --> 04:02.000]  Да, меньше из оставшихся.
[04:02.000 --> 04:04.000]  А какой меньше из оставшихся?
[04:04.000 --> 04:06.000]  Во-первых, мы этот элемент не рассматривали,
[04:06.000 --> 04:08.000]  поэтому он остается меньше в этом массиве.
[04:08.000 --> 04:10.000]  А этот элемент мы рассмотрели,
[04:10.000 --> 04:12.000]  поэтому этот указатель может сдвинуть на один вправо.
[04:12.000 --> 04:14.000]  Поэтому сравним теперь элемент два с элементом пять.
[04:14.000 --> 04:16.000]  И наименьший из этих элементов вставляем вот сюда.
[04:16.000 --> 04:18.000]  И продолжаем до тех пор,
[04:18.000 --> 04:20.000]  пока, соответственно, у нас оба массива не опустеют.
[04:20.000 --> 04:22.000]  Согласны?
[04:22.000 --> 04:24.000]  После того, как мы перенеси все элементы в итоговый массив,
[04:24.000 --> 04:26.000]  то мы заканчиваем работу.
[04:26.000 --> 04:30.000]  Давайте заведем три указателя.
[04:30.000 --> 04:32.000]  Три указателя я имею в виду три индекса.
[04:32.000 --> 04:35.000]  Первый индекс iA,
[04:35.000 --> 04:37.000]  второй индекс iB,
[04:37.000 --> 04:39.000]  третий индекс iC.
[04:39.000 --> 04:41.000]  Все они изначально указывают на ноль,
[04:41.000 --> 04:43.000]  но индекс iA указывает на элемент,
[04:43.000 --> 04:44.000]  который мы рассматриваем в первом массиве,
[04:44.000 --> 04:46.000]  в массиве iA,
[04:46.000 --> 04:48.000]  iB указывает на индекс, который мы указываем во втором массиве,
[04:48.000 --> 04:50.000]  и C это то место, куда мы вставляем в массиве C.
[04:50.000 --> 04:52.000]  Понятно?
[04:52.000 --> 04:54.000]  Ну и давайте, собственно, что скажем?
[04:54.000 --> 05:03.000]  Скажем, что пока индекс ИА не вышел за границы массива А
[05:03.000 --> 05:09.000]  и индекс массива Б не вышел за границы массива В,
[05:09.000 --> 05:14.000]  будем повторять следующее действие.
[05:14.000 --> 05:15.000]  То есть что мы делаем?
[05:15.000 --> 05:18.000]  Мы сравниваем эти элементы, которые указывают эти указатели.
[05:18.000 --> 05:21.000]  Если это зависит от того, какой из них меньше, мы вставляем в массив С.
[05:22.000 --> 05:24.000]  Так, давайте напишем так.
[05:24.000 --> 05:38.000]  Если B массива B меньше, чем элемент ИА массива А,
[05:38.000 --> 05:42.000]  то это означает, что нужно взять элемент массива B и перенести в С.
[05:43.000 --> 05:51.000]  Мы пишем просто C и C равно B и B.
[05:51.000 --> 05:55.000]  После этого делаем плюс-плюс и B.
[05:55.000 --> 05:58.000]  Ну а иначе?
[05:58.000 --> 06:04.000]  Ну да, плюс-с сделаем, но после L в конце сделаем плюс-плюс и С.
[06:04.000 --> 06:11.000]  Ну, кстати, хорошее замечание.
[06:11.000 --> 06:13.000]  В принципе, и С можно получить как сумму ИА и Б.
[06:13.000 --> 06:15.000]  Ну, пусть так будет.
[06:15.000 --> 06:22.000]  Не знаю, может сделать замечание, что и С всегда равен сумме ИА плюс ИБ.
[06:22.000 --> 06:25.000]  Так, что мы делаем иначе?
[06:25.000 --> 06:28.000]  Ну иначе мы берем не элемент Б, а элемент из А.
[06:28.000 --> 06:30.000]  Согласны?
[06:30.000 --> 06:38.000]  То есть берем С и С и вставляем туда значение А и А.
[06:38.000 --> 06:40.000]  И продвигаем указатель А вперед.
[06:40.000 --> 06:45.000]  Ну и в конце в любом случае мы продвигаем указатель ИС.
[06:47.000 --> 06:49.000]  Вот код.
[06:53.000 --> 06:55.000]  Как вам? Нормально?
[06:55.000 --> 07:01.000]  Верно ли, что этот код всегда работает?
[07:01.000 --> 07:06.000]  Да, давайте проведем вот эту процедуру до конца.
[07:06.000 --> 07:09.000]  Вот с помощью этого алгоритма давайте разберемся с этим массивом.
[07:09.000 --> 07:12.000]  Значит, мы сравнивали элемент 5 и 2.
[07:12.000 --> 07:17.000]  Соответственно, продвигаем указатель B на единицу вперед.
[07:17.000 --> 07:19.000]  Теперь сравним элемент 5 и 3.
[07:19.000 --> 07:23.000]  Соответственно, 3 меньше, поэтому не удаляем, а в смысле берем 3 и вставляем 3 вот сюда.
[07:23.000 --> 07:25.000]  Продвигаем указатель A.
[07:25.000 --> 07:30.000]  Снова сравниваем два числа — 4 и 5, вставляем 4.
[07:31.000 --> 07:35.000]  Дальше сравниваем 5 и 10, вставляем 5.
[07:37.000 --> 07:38.000]  Продвигаем указатель.
[07:38.000 --> 07:41.000]  Сравниваем 7 и 10, вставляем 7, продвигаем указатель.
[07:41.000 --> 07:44.000]  Дальше, сравниваем 9 и 10, вставляем 9.
[07:44.000 --> 07:48.000]  Все, на этом у меня массив А закончился и если у меня указатель вышел за границу массива,
[07:48.000 --> 07:50.000]  то я прекращаю на этом работу.
[07:50.000 --> 07:52.000]  Все, я прекратил работу.
[07:52.000 --> 07:57.000]  Но это явно не то, что нам нужно, потому что у меня осталась в итоге еще десятка из второго массива.
[07:57.000 --> 08:03.000]  Ну и теоретически у меня тут могли остаться еще какие-то элементы 11, 12, 13, ну и так далее.
[08:03.000 --> 08:06.000]  И ни один из этих элементов я в итоге в этим алгоритме не добавил, согласны?
[08:06.000 --> 08:09.000]  То есть что я должен еще сделать?
[08:09.000 --> 08:14.000]  Да, то есть если вдруг у меня либо в этом массиве, либо в этом массиве остались какие-то элементы,
[08:14.000 --> 08:16.000]  я должен их просто-напросто тупо добавить в конец.
[08:16.000 --> 08:19.000]  Потому что у меня один массив закончился, это означает, что все оставшиеся элементы отсюда
[08:19.000 --> 08:23.000]  должны просто-напросто стать конечного массива. Согласны?
[08:23.000 --> 08:32.000]  Все. То есть давайте тут напишем while и a меньше, чем модуль a.
[08:32.000 --> 08:41.000]  Я просто-напросто делаю c и c равно a и a.
[08:41.000 --> 08:47.000]  Ну и продвигаю вперед и a, продвигаю вперед и c.
[08:47.000 --> 08:52.000]  Ну и то же самое делаю с массивом b. Давайте тут напишу.
[08:55.000 --> 08:59.000]  While и b меньше, чем модуль b.
[08:59.000 --> 09:03.000]  Просто-напросто все оставшиеся элементы сгребаю в массив c.
[09:03.000 --> 09:14.000]  c и c равно b и b, плюс-плюс и b, плюс-плюс и c. Все.
[09:17.000 --> 09:25.000]  Нормально?
[09:25.000 --> 09:29.000]  Есть вопросы по этому алгоритму?
[09:29.000 --> 09:39.000]  Хорошо, давайте поговорим, за сколько он работает, время работы.
[09:39.000 --> 09:45.000]  Сколько действий делает этот алгоритм?
[09:45.000 --> 09:50.000]  Посмотрите, что мы по сути делаем на каждом шаге. На каждом шаге алгоритма мы либо
[09:50.000 --> 09:54.000]  вставляем один элемент из b, либо вставляем один элемент из a.
[09:54.000 --> 09:58.000]  Тут на одной интерации while мы добавили элементы b, либо из a.
[09:58.000 --> 10:02.000]  И тут в этом цикле мы добавили элементы из a и з os 분� Role.
[10:02.000 --> 10:07.000]  При этом по каждому элементу из a из b. Мы проходим все ровно один раз. Согласны?
[10:07.000 --> 10:14.260]  Соответственно, суммарное количество шагов – это тета от размера массива A плюс размера массива B.
[10:14.260 --> 10:20.460]  То есть два массива мы можем слить за время, пропорциональное сумме их размеров.
[10:20.460 --> 10:25.180]  Если у меня есть два массива, суммарная длина которых родна n, то из них можно получить...
[10:25.180 --> 10:26.680]  И при этом оба они отсортированы уже.
[10:26.680 --> 10:31.940]  То, соответственно, один большой отсортированный массив мы можем получить за время тета от A плюс B.
[10:31.940 --> 10:33.440]  Согласны?
[10:33.440 --> 10:34.940]  Нормально?
[10:34.940 --> 10:35.940]  Хорошо.
[10:36.440 --> 10:39.440]  Полдела сделано.
[10:39.440 --> 10:46.440]  Давайте теперь подумаем, как с помощью этого можно построить какой-нибудь эффективный алгоритм сортировки.
[10:46.440 --> 10:48.440]  Следующий пункт.
[10:52.440 --> 10:54.440]  Сортировка с лиянием.
[10:58.440 --> 11:00.440]  Ну или merge sort.
[11:00.940 --> 11:02.940]  Так.
[11:02.940 --> 11:04.940]  Как устроен merge sort?
[11:04.940 --> 11:06.940]  Смотрите.
[11:06.940 --> 11:08.940]  По слову, задача сортировки какая?
[11:08.940 --> 11:14.940]  Мне дан большой массив A, B, C, D, E, F, G, E.
[11:14.940 --> 11:16.940]  Какие там есть элементы?
[11:16.940 --> 11:24.940]  То есть дан один большой не отсортированный массив, мне нужно сделать из него один большой отсортированный.
[11:24.940 --> 11:26.940]  Задача звучит гораздо больше.
[11:27.440 --> 11:31.440]  Давайте попробуем настроиться на более оптимистичный лак.
[11:31.440 --> 11:34.440]  Давайте я скажу, что у меня есть не один большой не отсортированный массив.
[11:34.440 --> 11:40.940]  А я скажу, что у меня есть N отсортированных массивов.
[11:40.940 --> 11:42.940]  Все, у меня не один большой не отсортированный.
[11:42.940 --> 11:47.440]  А целых N отсортированных массивов размера 1.
[11:50.440 --> 11:51.440]  Так.
[11:51.440 --> 11:53.440]  Ну смотрите.
[11:53.440 --> 11:56.440]  Ну что, если у меня есть отсортированные массивы, то, что я могу robić?
[11:56.440 --> 12:03.160]  что я могу с ними сделать? Я могу их слить друг с другом, если у меня есть пара отсортированных массивов,
[12:03.160 --> 12:08.200]  то я могу их слить друг с другом. Смотрите, кажется, у меня ровно такая ситуация. У меня есть
[12:08.200 --> 12:12.920]  отсортированные массивы, соответственно, я могу их взять и просто послевать друг с другом.
[12:12.920 --> 12:33.680]  Как я буду это делать? Давайте рассмотрим на примере. Допустим, дан массив, 7, 3, 5, 4, 1, 2, 6, 8, вот дан такой массив.
[12:33.680 --> 12:42.160]  Значит, я из этого массива мысленно представляю, что это не один большой массив, а это вот 8 отсортированных
[12:42.160 --> 12:55.160]  массивов. Что я сделаю? Давайте я буду смотреть элементы попарно, то есть 7, 3, 5, 4, 1, 2, 6, 8, и солью их в массивчике размера 2.
[12:55.160 --> 13:05.160]  То есть возьму массив 7, возьму массив 3 и солью их в один отсортированный массив 3, 7. Получу массив 3, 7. Нормально?
[13:05.160 --> 13:10.160]  Просто взял первый элемент, второй элемент, запустил процедуру merge от вот этого массива, а вот этого массива и
[13:10.160 --> 13:18.160]  сохранил какой-то отдельный массив С. Дальше взял вот эти элементы и слил их в один массив 4, 5.
[13:18.160 --> 13:25.160]  Взял эти элементы, слил их в массив 1, 2. Взял эти элементы, слил их в массив 6, 8.
[13:25.160 --> 13:32.160]  После первого шага у меня получилось 4 массива размера 2, каждый из которых отсортирован. Согласны?
[13:32.160 --> 13:43.160]  Что я делаю дальше? Давайте я продолжу процедуру. Буду продолжать сливать. Возьму эти два массива и солью в один размера 4.
[13:43.160 --> 13:49.160]  Как я это делаю? Снова смотрю на первые элементы, минимальный из них это 3. Продвигаю этот указатель сюда.
[13:49.160 --> 13:54.160]  Сравниваю 4 и 7, записываю 4. Сравниваю 5 и 7, вставляю 5. Соответственно, этот массив закончился,
[13:54.160 --> 14:08.160]  и 7 просто дописываю в массив. Тут получается массив 1, 2, 6, 8. На последнем шаге я получаю два массива размера 4,
[14:08.160 --> 14:26.160]  которые просто остаются слить друг с другом. Сливаю два массива. Получаю 1, 2, 3, 4, 5, 6, 7, 8.
[14:26.160 --> 14:31.160]  На последнем шаге получил один отсортированный массив. Победа!
[14:32.160 --> 14:36.160]  Алгоритм понятен, порядок действий понятен, да. Беру элементы по парам и сливаю друг с другом.
[14:36.160 --> 14:41.160]  Снова беру элементы по парам и сливаю друг с другом.
[14:41.160 --> 14:54.160]  Давайте подумаем. И соответственно, вот о каждом этом шаге я делаю мерч. То есть тут делаю мерч, тут делаю мерч, тут делаю мерч, тут, тут, тут и тут.
[14:54.160 --> 15:09.160]  Так, главный вопрос, за сколько это работает? Давайте подумаем. На первом шаге я беру массивы размера единица, то есть беру n массивов размера 1, и попарно сливаю их друг с другом.
[15:09.160 --> 15:20.160]  То есть сколько действий суммарно я сделал вот на этом уровне? «n». Почему? Потому что я сливаю два массива размера «1», это занимает… ну «тета от 1 плюс 1», то есть два, ну два действия.
[15:20.160 --> 15:27.160]  Тут тоже я по сути делаю два действия, тут два действия, тут два действия, тут два действия, то есть суммарно я делаю количество действий, которое равно количеству элементов в массиве, согласны?
[15:27.160 --> 15:37.160]  То есть это «тета от n». Тета от n действий. Что я делаю на этом уровне. Я беру массивы размера «2» и сливаю друг с другом.
[15:37.160 --> 15:41.160]  размеры 2 сливаю друг с другом. Сколько времени я суммарно трачу?
[15:41.160 --> 15:47.160]  Ну тоже тетто от n. Почему? Потому что я сливаю вот эти два массива, время равно там 2 плюс 2,
[15:47.160 --> 15:50.160]  сливаю эти два массива, время равно 2 плюс 2. То есть суммарно по каждому элементу
[15:50.160 --> 15:53.160]  массива исходного я пройдусь один раз.
[15:53.160 --> 15:57.160]  Соответственно снова получают это от n.
[15:57.160 --> 16:01.160]  Я здесь никого не удивлю, что и на этом шаге тоже у меня время равно тетто от n.
[16:01.160 --> 16:05.160]  То есть на каждом шаге я буду делать тетто от n действий. Почему? Потому что слияние
[16:05.160 --> 16:10.160]  по каждому элементу проходит ровно один раз. Согласны?
[16:10.160 --> 16:13.160]  Есть понимание?
[16:13.160 --> 16:18.160]  Так, ну теперь давайте рассмотрим в общем случае. Вот если в общем случае у меня количество элементов n.
[16:18.160 --> 16:22.160]  Чему равно общее количество таких действий? То есть, окей, мы разобрались.
[16:22.160 --> 16:28.160]  На каждом шаге я делаю n действий. А сколько всего таких шагов у меня будет?
[16:28.160 --> 16:32.160]  Благодарю. Почему? Потому что давайте пойдем снизу вверх.
[16:32.160 --> 16:36.380]  Вот здесь снизу у меня получился массив размера n. Выше у меня были массивы размера 4,
[16:36.380 --> 16:39.380]  выше у меня были массивы размера решет two, выше были массивы размера один.
[16:39.380 --> 16:45.960]  То есть, если мне есть массив размера n personalized, то разделение, сколько раз я его разделить на 2,
[16:45.960 --> 16:50.080]  чтобы получить были массивы размера 1? Ну, логарифмическое число раз.
[16:50.080 --> 16:56.280] . Поэтому суммарное количество слоев у меня двоичный логарифм от n,
[16:56.280 --> 17:00.760]  не больше, чем двоичный логарифм от n. Смотрите, на каждом уровне я делаю n действий.
[17:00.760 --> 17:07.760]  уровень менял агарифом двоичный от n. Но кажется, что из этого следует, что сложность это тета от n-логан.
[17:07.760 --> 17:24.760]  Согласны? Да? Вот, пожалуйста, сортировка, которая работает быстрее, чем за квадратичное время,
[17:24.760 --> 17:34.760]  то есть массив размера миллион буквально за несколько миллисекунд отсортируется.
[17:34.760 --> 17:44.760]  Так, давайте напишем код, что ли.
[17:44.760 --> 17:54.760]  Merge Sort массива A.
[17:54.760 --> 18:08.760]  Так, ну, давайте начнем.
[18:08.760 --> 18:22.760]  4e от единицы до... давайте так напишем.
[18:22.760 --> 18:32.760]  4e равно единице, e меньше чем n, e умножить равно 2.
[18:32.760 --> 18:46.760]  Значит, что такое e? Умножить равно 2. А e это размер кусочков.
[18:46.760 --> 18:52.760]  То есть тут изначально у меня кусочки размера 1, и на каждом шаге у меня размеры кусочков увеличиваются на 2. Согласны?
[18:52.760 --> 18:58.760]  Ну и тут я итерируюсь по, собственно, числу кусочков.
[18:58.760 --> 19:14.760]  4g равно 0, пока g у меня меньше чем n, g плюс равно 2.
[19:14.760 --> 19:26.760]  Значит, g это начало первой последовательности.
[19:26.760 --> 19:38.760]  Начало первой, сливаемой последовательности.
[19:38.760 --> 19:48.760]  То есть g всегда указывает на начало первого сливаемого кусочка, окей?
[19:48.760 --> 19:58.760]  Ну все, и дальше я просто-напросто... ну что я делаю?
[19:58.760 --> 20:08.760]  Так, блин, я забыл, давайте вначале еще напишем, что я создаю массив c, который я буду складывать в временные значения.
[20:08.760 --> 20:18.760]  Ну массив c это просто array размера n.
[20:18.760 --> 20:30.760]  Ну нет, теоретически, если у меня массив не имеет цепи двойки, то у меня там в конце будут оставаться какие-то неспаренные куски.
[20:30.760 --> 20:36.760]  Ну на самом деле с этим мы разберемся. Сейчас мы код напишем, и потом мы разберемся, что с этим делать.
[20:36.760 --> 20:42.760]  Ну нет, тут у нас везде меньше чем n, поэтому кажется, что пока мы нигде не выходим за границу.
[20:43.760 --> 20:50.760]  Умножить равно 2. Создали массив c, в который складываем временные значения.
[20:50.760 --> 21:00.760]  Ну что, сливаем, пишем merge. Какой массив?
[21:00.760 --> 21:18.760]  Merge-массив, начиная с j по j плюс i, не включительно, массивом j плюс i до...
[21:18.760 --> 21:38.760]  И вот так. Максимум, точнее минимум, из n и j плюс 2i. Сливаю все в массив c.
[21:38.760 --> 21:45.760]  Что-то написано. Написано, что я беру в качестве первого массива массив j-j плюс i.
[21:45.760 --> 21:53.760]  J это начало левого кусочка. Соответственно этот кусочек имеет размер i.
[21:53.760 --> 21:59.760]  Поэтому я беру массив, начиная с j этого по j плюс первый элемент, не включительно.
[21:59.760 --> 22:05.760]  Я его сливаю с каким массивом? Я его сливаю с массивом, который начинается в позиции j.
[22:05.760 --> 22:09.760]  Если это позиция j, то соответственно эта позиция это j плюс i.
[22:09.760 --> 22:12.760]  Если это размер i, то соответственно это позиция j плюс i.
[22:12.760 --> 22:17.760]  До каких пор? До минимума из j плюс 2i.
[22:17.760 --> 22:20.760]  Потому что эта конец находится в позиции j плюс 2i.
[22:20.760 --> 22:24.760]  Если это j, это i, это i, то соответственно конец находится j плюс 2i.
[22:24.760 --> 22:28.760]  Но, как вы сказали, теоретически может случиться ситуация, при которой...
[22:28.760 --> 22:31.760]  Вот тут у меня не 8 элементов, а 7.
[22:31.760 --> 22:35.760]  Соответственно, чтобы не выходить за границы, я тут ставлю ограничение минимум n.
[22:35.760 --> 22:38.760]  Нормально теперь?
[22:41.760 --> 22:44.760]  Все, сливаю в массив C.
[22:44.760 --> 22:47.760]  Ну и дальше давайте я напишу...
[22:47.760 --> 22:53.760]  У меня были элементы, у меня элементы находились в массиве A, а в итоге оказались в массиве C.
[22:53.760 --> 22:57.760]  Ну а мне-то нужно отсердцевать исходный массив A, согласны?
[22:57.760 --> 23:01.760]  Давайте я просто возьму все элементы, которые оказались в C, и перенесу их в массив A.
[23:01.760 --> 23:04.760]  Нормально?
[23:04.760 --> 23:06.760]  Понятно?
[23:06.760 --> 23:09.760]  Ну вот у меня был исходный массив A,
[23:09.760 --> 23:12.760]  а я все элементы сложил в какой-то третий массив C.
[23:12.760 --> 23:15.760]  В какой-то сторонний массив C.
[23:15.760 --> 23:18.760]  Поэтому чтобы все элементы оказались в массиве A,
[23:18.760 --> 23:21.760]  я должен обратно из массива C перенести все элементы в массив A.
[23:21.760 --> 23:24.760]  Давайте я просто напишу...
[23:27.760 --> 23:38.760]  Ну просто давайте напишу копии из массива C в массиве J плюс 2i.
[23:42.760 --> 23:45.760]  Ну просто перенести все элементы, которые оказались в C,
[23:45.760 --> 23:48.760]  на исходные позиции в массиве A, окей?
[23:48.760 --> 23:50.760]  Понятно запись?
[23:50.760 --> 23:52.760]  Все.
[23:52.760 --> 23:55.760]  Ну кажется все. На этом сортировка заканчивается.
[23:57.760 --> 24:07.760]  Есть ли вопросы по этому коду?
[24:07.760 --> 24:10.760]  Да.
[24:10.760 --> 24:17.760]  Ну да, тут тоже минимум.
[24:17.760 --> 24:25.760]  От J до минимум из N, J плюс 2i.
[24:25.760 --> 24:28.760]  Последний, смотри так, для чего нужна последняя строчка.
[24:28.760 --> 24:31.760]  Вот у меня был массив A.
[24:31.760 --> 24:34.760]  Вот, допустим.
[24:34.760 --> 24:37.760]  И я хочу слить вот этот кусочек с вот этим кусочком.
[24:37.760 --> 24:39.760]  Ага. Как происходит слияние?
[24:39.760 --> 24:42.760]  Я создаю массив C, вот это массив исходный A,
[24:42.760 --> 24:45.760]  я создаю массив C и все сливаю вот сюда.
[24:45.760 --> 24:50.760]  То есть на самом деле отсортированно у меня оказывается массив C.
[24:50.760 --> 24:54.760]  Но мне-то нужно, чтобы все эти элементы были отсортированы в массиве A.
[24:54.760 --> 24:57.760]  Поэтому после того, как я все слил в массив C,
[24:57.760 --> 25:00.760]  я переношу все значения обратно в массив A.
[25:00.760 --> 25:06.760]  Ну это не средство, это просто условное обозначение в псевдокоде.
[25:06.760 --> 25:10.760]  Вот, что мне нужно все перенести в массив A от J до...
[25:10.760 --> 25:12.760]  Ну давайте напишем, если это смущает.
[25:12.760 --> 25:15.760]  Давайте прям честный цикл напишем.
[25:15.760 --> 25:25.760]  For k равно 0, пока k меньше, чем...
[25:25.760 --> 25:27.760]  Нет, давайте так.
[25:27.760 --> 25:37.760]  k равно J, k меньше, чем минимум из J, плюс 2i и n, плюс плюс k.
[25:37.760 --> 25:41.760]  Что я делаю? Я переношу все элементы из массива C в массив A.
[25:41.760 --> 25:51.760]  Я пишу ak равно C от k-J.
[25:51.760 --> 25:54.760]  Так нормально?
[26:02.760 --> 26:04.760]  Ну потому что у меня...
[26:04.760 --> 26:06.760]  Смотрите, когда я сливаю вот эти два кусочка,
[26:06.760 --> 26:10.760]  у меня в массиве A этот элемент находится на какой-то жидкой позиции.
[26:11.760 --> 26:14.760]  То есть J это как раз номер элемента,
[26:14.760 --> 26:18.760]  начиная с которого мне нужно слить вот эти два элемента.
[26:18.760 --> 26:20.760]  То есть по сути у меня массив A устроен так.
[26:20.760 --> 26:23.760]  3, 7, 4, 5, 1, 2, 6, 8.
[26:23.760 --> 26:26.760]  Мне нужно, чтобы в этих позициях оказался массив 1, 2, 6, 8.
[26:26.760 --> 26:30.760]  Поэтому я все переношу туда. Понятно?
[26:32.760 --> 26:34.760]  Нормально?
[26:35.760 --> 26:39.760]  Сдайте вопрос, есть непонятно.
[26:49.760 --> 26:51.760]  Давайте пример.
[27:00.760 --> 27:02.760]  Есть массив A.
[27:04.760 --> 27:12.760]  5, 3, 7, 8, 1, 2, 4, 3.
[27:15.760 --> 27:16.760]  Как работает алгоритм?
[27:16.760 --> 27:18.760]  Вначале я возвожу какой-то вспомогатель массив C,
[27:18.760 --> 27:21.760]  в который буду складывать промежуточные результаты.
[27:23.760 --> 27:27.760]  1, 2, 3, 4, 5, 6, 7, 8.
[27:27.760 --> 27:29.760]  Так, что я делаю?
[27:29.760 --> 27:35.760]  Внешний цикл у меня задает размер блоков, которые я сливаю.
[27:35.760 --> 27:36.760]  Согласны?
[27:36.760 --> 27:38.760]  Стартую с блоков размера 1.
[27:40.760 --> 27:43.760]  Сливаю вот этот блок с вот этим блоком.
[27:43.760 --> 27:47.760]  То есть позиция первого блока равна J равная нулю.
[27:47.760 --> 27:53.760]  И я сливаю блоки с нулевого по 0 плюс 1,
[27:53.760 --> 27:55.760]  с нулевого по первой невключительно,
[27:55.760 --> 27:58.760]  и с первого по второй невключительно.
[28:00.760 --> 28:04.760]  То есть я беру вот эти элементы и сливаю их друг с другом.
[28:04.760 --> 28:05.760]  Куда сливаю?
[28:05.760 --> 28:06.760]  Сливаю в массив C.
[28:06.760 --> 28:09.760]  Тут оказывается элемент 3, тут оказывается элемент 5.
[28:09.760 --> 28:12.760]  Все, после того как я их слил сюда, мне нужно чтобы вот тут,
[28:12.760 --> 28:14.760]  чтобы вот эти 3,5 оказались не тут, а тут.
[28:14.760 --> 28:15.760]  Согласны?
[28:15.760 --> 28:19.760]  Поэтому последний цикл, 4k равно J, k меньше минимум, и так далее,
[28:19.760 --> 28:21.760]  я просто эти элементы копирую обратно вот сюда.
[28:21.760 --> 28:23.760]  3, 5.
[28:23.760 --> 28:26.760]  Перехожу на следующую итерацию цикла по J.
[28:27.760 --> 28:30.760]  Следующий J у меня 0 плюс равно 2i.
[28:30.760 --> 28:33.760]  Ну i равно 1, поэтому я сдвигаюсь на двойку,
[28:33.760 --> 28:36.760]  то есть оказываюсь вот здесь.
[28:36.760 --> 28:38.760]  То есть сливаю теперь вот эти два массива.
[28:38.760 --> 28:39.760]  Согласны?
[28:39.760 --> 28:42.760]  Вот, сливаю два массива, у меня получается, то есть я их записываю сюда.
[28:42.760 --> 28:45.760]  Тут получается 7, тут 8.
[28:45.760 --> 28:47.760]  Теперь эти элементы я должен перенести сюда.
[28:47.760 --> 28:50.760]  Ну, семерку переношу сюда, восьмерку переношу сюда.
[28:50.760 --> 28:52.760]  Рассматриваю следующие блоки по единице.
[28:52.760 --> 28:54.760]  1, 4.
[28:54.760 --> 28:56.760]  Сливаю вот сюда.
[28:56.760 --> 28:59.760]  Тут у меня получается единица, тут получается четверка.
[28:59.760 --> 29:02.760]  Все, сливаю сюда, единица, четверка.
[29:02.760 --> 29:04.760]  Ну, то же самое с этими элементами, 2, 3.
[29:04.760 --> 29:07.760]  Сюда записываю 2, сюда записываю 3.
[29:07.760 --> 29:11.760]  Все, это после первой итерации по внешнему циклу, по i.
[29:11.760 --> 29:14.760]  Перехожу на следующую итерацию.
[29:14.760 --> 29:17.760]  На следующую итерацию у меня i умножить равно 2.
[29:17.760 --> 29:19.760]  То есть i становится равно 2.
[29:19.760 --> 29:20.760]  Чему соответствует i?
[29:20.760 --> 29:22.760]  i это размер кусочков.
[29:22.760 --> 29:23.760]  Кусочки размера 2.
[29:23.760 --> 29:26.760]  Вот этот кусочек, вот этот кусочек, вот этот и вот этот.
[29:44.760 --> 29:46.760]  Ну как, ну смотрите, давайте рассмотрим конкретный пример.
[29:46.760 --> 29:51.760]  Пусть у меня j равно 4.
[29:51.760 --> 29:53.760]  А i равно 2.
[29:56.760 --> 29:58.760]  j равно 4, это вот этот элемент.
[30:00.760 --> 30:02.760]  Значит, что мне нужно сделать?
[30:02.760 --> 30:06.760]  Мне нужно все элементы, мне нужно вставить элементы вот с этой позиции
[30:06.760 --> 30:09.760]  по минимуму j плюс 2i до n.
[30:09.760 --> 30:12.760]  То есть j плюс 2i это восьмой элемент, то есть вот этот.
[30:16.760 --> 30:19.760]  То есть мне нужно вставить элементы сюда,
[30:19.760 --> 30:21.760]  начиная с этого по этот, не включительно.
[30:21.760 --> 30:22.760]  Понятно?
[30:22.760 --> 30:25.760]  В этот момент, то есть когда я сливал вот эти два кусочка,
[30:25.760 --> 30:28.760]  когда я сливал вот эти два кусочка, у меня в массиве c
[30:28.760 --> 30:30.760]  записана следующая информация.
[30:30.760 --> 30:33.760]  1, 2, 3, 4.
[30:33.760 --> 30:35.760]  Но я хочу, чтобы у меня вот эти 1, 2, 3, 4 были вот тут,
[30:35.760 --> 30:37.760]  а не в каком-то массиве c.
[30:37.760 --> 30:39.760]  Поэтому я иду по циклу.
[30:39.760 --> 30:40.760]  k начинается с j.
[30:40.760 --> 30:42.760]  Давайте тут буду писать k.
[30:42.760 --> 30:44.760]  k равняется 4.
[30:44.760 --> 30:48.760]  Так, значит, в массив a, в k это элемент массива a,
[30:48.760 --> 30:52.760]  то есть вот в этот, я записываю элемент k минус j.
[30:52.760 --> 30:54.760]  k равно 4, j равно 4.
[30:54.760 --> 30:56.760]  То есть я записываю 0,8.
[30:56.760 --> 30:58.760]  Вот сюда.
[30:58.760 --> 31:00.760]  Первый элемент c я записываю вот сюда.
[31:00.760 --> 31:02.760]  Этот элемент c я записываю вот сюда.
[31:05.760 --> 31:08.760]  То есть по сути я последовательно записываю элементы массива c вот сюда,
[31:08.760 --> 31:10.760]  но просто-напросто со сдвигом в j.
[31:10.760 --> 31:12.760]  Ой, да, со сдвигом в j.
[31:15.760 --> 31:17.760]  Вот это расстояние j.
[31:18.760 --> 31:21.760]  Уже, если j равной 0, то guarantee meter при 0, то k меньше 0.
[31:22.760 --> 31:24.760]  А threats...
[31:25.760 --> 31:32.060]  🎶
[31:33.760 --> 31:35.760]  Ну то же самое.
[31:35.760 --> 31:37.760]  Ну j это просто смещение относительно начала.
[31:41.760 --> 31:45.760]  Если j равно 0, то кажется что k минус 0, это...
[31:45.760 --> 31:59.760]  Это кажется нет. А в чем проблема может быть?
[31:59.760 --> 32:07.760]  Как только мы сделаем g плюс 2i и у нас g станет равен n, то мы выйдем из цикла.
[32:07.760 --> 32:17.760]  Это псевдокод. В C++ срезов нет.
[32:17.760 --> 32:37.760]  То, что первый блок влезает, в каком плане, куда влезает?
[32:37.760 --> 32:47.760]  Смотрите, первый блок... Вы про это?
[32:47.760 --> 33:13.760]  Ну да, это имеет смысл.
[33:13.760 --> 33:23.760]  На самом деле нам нужно сливать блоки.
[33:23.760 --> 33:29.760]  Сейчас кажется, у нас первый блок.
[33:29.760 --> 33:35.760]  А, первый блок не в любом случае влезает, да?
[33:35.760 --> 33:39.760]  А, ну тогда, все, я понял.
[33:39.760 --> 33:47.760]  Тут можно взять g меньше, чем n-i. Кажется, это сработает.
[33:47.760 --> 33:49.760]  Ну понятно, в чем проблема?
[33:49.760 --> 33:55.760]  Я не знаю, давайте изобразим.
[33:55.760 --> 34:03.760]  Что у меня массив имеет длину, допустим, 10, я беру блоки размера 4, 4 и тут остается 2.
[34:03.760 --> 34:09.760]  В итоге эти два блока я солью, а первый блок у меня будет иметь размер 2, который меньше, чем 4.
[34:09.760 --> 34:13.760]  И, соответственно, вот тут я выйду за границу массива.
[34:13.760 --> 34:19.760]  Я просто-напросто пожил, буду идти до n-i и все.
[34:19.760 --> 34:21.760]  Тогда последний блок я не захвачу.
[34:21.760 --> 34:27.760]  Первое, что мы сказали, это то, что сортировка слиянием работает за n луган.
[34:27.760 --> 34:31.760]  Вроде как обосновали, все нормально.
[34:31.760 --> 34:39.760]  Какими дополнительными приятными и неприятными свойствами обладает сортировка слиянием?
[34:39.760 --> 34:45.760]  Хорошим свойством является то, что сортировка слиянием стабильна.
[34:49.760 --> 34:55.760]  Что значит стабильная? Это не что-то скрепное, это понятие из теории алгоритмов.
[34:55.760 --> 35:01.760]  Софтировка является стабильной, если она сохраняет порядок одинаковых элементов.
[35:01.760 --> 35:03.760]  Сейчас поясню, что это значит.
[35:03.760 --> 35:07.760]  Представьте себе, что мне дан массив...
[35:07.760 --> 35:09.760]  Давайте маленький массив нарисую.
[35:09.760 --> 35:15.760]  Массив 3, 1 штрих, 2, 1, 2 штриха.
[35:15.760 --> 35:19.760]  То есть, допустим, у меня в массиве есть две единицы,
[35:19.760 --> 35:21.760]  и они по каким-то причинам отличаются друг от друга.
[35:21.760 --> 35:23.760]  В смысле, эта единица, эта единица, они разные.
[35:29.760 --> 35:31.760]  Представим себе следующую ситуацию.
[35:31.760 --> 35:35.760]  Я взял сортировку и получил вот такой массив.
[35:35.760 --> 35:39.760]  1, 2 штриха, 1, 1 штрих, 2, 3.
[35:43.760 --> 35:47.760]  Данное упорядочение, данная сортировка не является стабильной. Почему?
[35:47.760 --> 35:51.760]  Потому что, несмотря на то, что тут вроде бы как все хорошо,
[35:51.760 --> 35:57.760]  сначала идет 1, 1, потом 2, 3, относительный порядок вот этих двух единиц, он поменялся.
[35:57.760 --> 36:00.760]  Изначально у меня шло значение 1 штрих, потом идет значение 1, 2 штриха.
[36:00.760 --> 36:02.760]  А в конечном массиве это не так.
[36:02.760 --> 36:06.760]  То есть данная сортировка поменяла порядок, относительный порядок одинаковых элементов.
[36:06.760 --> 36:08.760]  Поэтому она не является стабильной.
[36:08.760 --> 36:11.760]  Давайте подумаем над тем, почему, вообще говоря, стабильная сортировка,
[36:11.760 --> 36:14.760]  почему на самом деле иногда нам могут понадобиться стабильные сортировки.
[36:14.760 --> 36:16.760]  Можете привести какой-нибудь пример.
[36:16.760 --> 36:18.760]  Ну, какой-нибудь из жизни.
[36:24.760 --> 36:26.760]  Открывать счета папин-кодом.
[36:27.760 --> 36:29.760]  Ну, например.
[36:29.760 --> 36:31.760]  Или представьте себе, у вас есть таблица.
[36:31.760 --> 36:33.760]  Там, не знаю, Excel или еще какая-то.
[36:33.760 --> 36:37.760]  В которой у вас есть, не знаю, условно там FIO.
[36:37.760 --> 36:42.760]  И там, не знаю, какая-нибудь зарплата.
[36:42.760 --> 36:44.760]  Вот.
[36:44.760 --> 36:52.760]  И у вас, допустим, список отсортирован по возрастанию фамилий.
[36:53.760 --> 36:56.760]  А теперь вам нужно, допустим, отсортировать список по зарплатам.
[36:56.760 --> 36:58.760]  И correspondingly, там, поймете, какой там наибольший зарплат,
[36:58.760 --> 37:00.760]  какой он наименее сейчас зарплат, и так далее.
[37:00.760 --> 37:02.760]  Вот, допустим, вы отсортировали список по зарплатам.
[37:02.760 --> 37:04.760]  Вот. И отсортировали его каким-то случайным образом.
[37:04.760 --> 37:07.760]  Так что, понятное дело, у вас зарплаты перемешались.
[37:07.760 --> 37:09.760]  Поэтому соответственно, и фамилия имена отчество тоже,
[37:09.760 --> 37:11.760]  эти строчки соответственно поменяли с друг к другом.
[37:11.760 --> 37:13.760]  Но, если сортировка является стабильной,
[37:13.760 --> 37:16.760]  то какое свойство у нас еще гарантируется?
[37:16.760 --> 37:19.760]  Что если вдруг у кого-то есть одинаковая зарплата,
[37:19.760 --> 37:26.760]  то в рамках вот этого списка они будут отсортированы по фамилии имени отчества, понятно?
[37:26.760 --> 37:31.760]  То есть если у меня вот тут один штрих и один-два штриха были между собой отсортированы по какому-то другому критерию,
[37:31.760 --> 37:37.760]  то и в конечном оси они тоже будут отсортированы по тому же самому критерию, понятно?
[37:37.760 --> 37:40.760]  То есть я на самом деле могу отсортировать не просто отдельные числа,
[37:40.760 --> 37:43.760]  допустим, я могу отсортировать пары число и какая-то строка.
[37:43.760 --> 37:49.760]  И допустим, мой список уже отсортирован по строкам, и я хочу его теперь отсортировать по числам.
[37:49.760 --> 37:54.760]  Если я его отсортировал по числам, то теперь одинаковые числа, то есть внутри вот этих блоков,
[37:54.760 --> 37:58.760]  у меня числа будут дополнительно отсортированы по их строкам, понятно, да?
[37:58.760 --> 38:03.760]  То есть часто это довольно-таки приятное свойство, то есть стабильное, давайте формально напишем.
[38:03.760 --> 38:28.760]  Если ai равно aj и i меньше, чем j в исходном массиве,
[38:28.760 --> 38:42.760]  то их соответствующий индекс, давайте их обозначим как pe и pj,
[38:42.760 --> 38:47.760]  то и соотносятся таким образом.
[38:47.760 --> 39:09.760]  pe – это индекс этого элемента в отсортированном массиве, окей?
[39:09.760 --> 39:13.760]  Сортировка с лиянием стабильная, и на самом деле еще в плюс можно записать,
[39:13.760 --> 39:16.760]  что сортировка с лиянием всегда работает за n-логан.
[39:16.760 --> 39:20.760]  То есть какой бы у вас массив на вход не был передан, всегда в любом случае,
[39:20.760 --> 39:24.760]  хоть в худшем, хоть в лучшем, у вас сортировка будет работать за n-логан.
[39:24.760 --> 39:28.760]  Так, кто видит недостаток сортировки с лиянием?
[39:28.760 --> 39:30.760]  Какая у него есть проблема?
[39:30.760 --> 39:33.760]  В отличие, например, давайте, смотрите, у нас есть квадратичные сортировки,
[39:33.760 --> 39:38.760]  ну, не знаю, возьмем какую-нибудь сортировку выбором, или сортировку вставками, неважно.
[39:38.760 --> 39:40.760]  Все они, понятное дело, работают за n-квадрат.
[39:40.760 --> 39:43.760]  Но у них есть одно неоспоримое преимущество внезапно,
[39:43.760 --> 39:46.760]  перед сортировкой с лиянием. Какое?
[39:46.760 --> 39:54.760]  Они не создают дополнительных массивов.
[39:54.760 --> 39:57.760]  То есть, грубо говоря, вы квадратичной сортировке передали массив,
[39:57.760 --> 40:00.760]  и квадратичная сортировка работает только с этим массивом,
[40:00.760 --> 40:02.760]  не создает никакой дополнительной памяти.
[40:02.760 --> 40:07.760]  Здесь же нам нужно создавать некоторый дополнительный массив,
[40:07.760 --> 40:12.760]  который мы будем записывать в промежуточный результат.
[40:12.760 --> 40:14.760]  Согласны?
[40:14.760 --> 40:17.760]  И, к сожалению, это, собственно, недостаток сортировки с лиянием.
[40:17.760 --> 40:36.760]  То есть требует theta от n до памяти.
[40:36.760 --> 40:41.760]  Вот, это неприятный факт.
[40:41.760 --> 40:46.760]  Чтобы отсортировать массив, вы можете потратить немного времени,
[40:46.760 --> 40:51.760]  плюс вам нужно гарантировать, что у вас на системе еще хватает памяти
[40:51.760 --> 40:54.760]  для, по сути, такого же дополнительного массива.
[40:54.760 --> 41:00.760]  Понятно?
[41:00.760 --> 41:05.760]  В принципе, есть еще полчаса.
[41:05.760 --> 41:07.760]  Давайте поговорим вот о чем.
[41:07.760 --> 41:10.760]  Давайте поговорим о небольшой модификации сортировки с лиянием.
[41:10.760 --> 41:14.760]  И попробуем придумать такой алгоритм, который бы не требовал дополнительной памяти.
[41:14.760 --> 41:17.760]  Давайте попробуем модернизировать сортировку с лиянием так,
[41:17.760 --> 41:20.760]  чтобы дополнительной памяти он не требовал.
[41:20.760 --> 41:22.760]  Вопрос следующий.
[41:22.760 --> 41:24.760]  В какой момент нам нужна дополнительная память?
[41:24.760 --> 41:27.760]  Дополнительная память нам нужна в процессе слияния.
[41:27.760 --> 41:39.760]  Чтобы уметь сливать, нам нужно данные элементы записывать в какой-то третий массив.
[41:39.760 --> 41:43.760]  Давайте попробуем придумать слияние, которое этим недостатком не обладает.
[41:43.760 --> 41:48.760]  Которое позволяет сливать элементы и не требует дополнительного хранилища данных.
[41:48.760 --> 41:52.760]  Что я хочу написать?
[41:52.760 --> 41:59.760]  Это процедура, которая называется in-place merge.
[41:59.760 --> 42:04.760]  Какое ограничение у меня будет на in-place merge?
[42:04.760 --> 42:07.760]  In-place merge обязательно будет требовать следующего.
[42:07.760 --> 42:13.760]  Что сливаемые последовательности расположены строго друг за другом.
[42:13.760 --> 42:17.760]  То есть сливаемые последовательности лежат в одном массиве
[42:17.760 --> 42:23.760]  и плюс расположены последовательно друг за другом.
[42:23.760 --> 42:28.760]  То есть A и B находятся в точности друг за другом.
[42:28.760 --> 42:33.760]  Давайте начнем с чего. Давайте рассмотрим какие-нибудь простые случаи.
[42:33.760 --> 42:42.760]  Какие два массива нам легко слить друг с другом?
[42:42.760 --> 42:54.760]  Понятно дело, что эти два массива априори отсортированы уже.
[42:54.760 --> 42:58.760]  У вас этот массив имеет размер 10, а этот массив имеет размер 8.
[42:58.760 --> 43:03.760]  Как их слить друг с другом?
[43:03.760 --> 43:07.760]  Это простой вариант. Давайте рассмотрим такую ситуацию.
[43:07.760 --> 43:11.760]  В этом массиве не понятно, что находится, в этом тоже не понятно.
[43:11.760 --> 43:18.760]  Чему должны удовлетворять размеры массивов, чтобы их можно было легко слить друг с другом?
[43:18.760 --> 43:21.760]  Например, массивы 1 и 1 слить друг с другом легко.
[43:21.760 --> 43:24.760]  Допустим, у меня один массив имеет размер 100.
[43:24.760 --> 43:30.760]  Чему должен быть размер второго массива, чтобы их можно было легко слить друг с другом?
[43:30.760 --> 43:35.760]  Ноль.
[43:35.760 --> 43:45.760]  Если размер массива A равен нулю,
[43:45.760 --> 43:51.760]  то мы сразу можем завершить работу, согласны?
[43:51.760 --> 43:54.760]  Не массивы, а последовательности идут друг за другом.
[43:54.760 --> 44:00.760]  Вот у вас есть память, и по сути эти два куска принадлежат одному и тому же массиву.
[44:00.760 --> 44:07.760]  То есть сначала записанные элементы A, потом сразу же записаны элементы B.
[44:07.760 --> 44:14.760]  Аналогично, если B равен нулю, равно равно,
[44:14.760 --> 44:21.760]  то тоже можем завершить работу.
[44:21.760 --> 44:27.760]  Ну и третий вариант простой.
[44:27.760 --> 44:32.760]  Если размер первого массива равен единице,
[44:32.760 --> 44:36.760]  и размер второго массива равен единице,
[44:36.760 --> 44:42.760]  то что нам нужно сделать?
[44:42.760 --> 44:48.760]  Ну да, то есть можно записать, что если элемент B0...
[44:48.760 --> 44:50.760]  Так, давай допишем.
[44:50.760 --> 44:55.760]  Элемент B0 больше, чем элемент A0,
[44:55.760 --> 45:01.760]  так наоборот, A0 больше, чем элемент B0,
[45:01.760 --> 45:11.760]  то мы делаем swap, элемент A0, элемент B0.
[45:11.760 --> 45:15.760]  Простые случаи рассмотрели? Согласны?
[45:15.760 --> 45:18.760]  Так, теперь давайте недолго отвечу.
[45:18.760 --> 45:22.760]  Я сделал утверждение, что сортировка с лиянием стабильная,
[45:22.760 --> 45:24.760]  но не доказал же, почему она стабильная.
[45:24.760 --> 45:27.760]  А вы поверили?
[45:27.760 --> 45:31.760]  Уже на семинаре?
[45:31.760 --> 45:36.760]  Ну ладно, почему сортировка с лиянием стабильная?
[45:36.760 --> 45:40.760]  Ну, смотрите.
[45:40.760 --> 45:43.760]  Что делать с сортировкой с лиянием?
[45:43.760 --> 45:47.760]  С сортировкой с лиянием на каждом шаге просто-напросто сливают какие-то массивы.
[45:47.760 --> 45:50.760]  Поэтому, соответственно, если я сливаю два массива стабильным образом,
[45:50.760 --> 45:53.760]  то соответственно и сортировка с лиянием тоже будет стабильной.
[45:53.760 --> 45:57.760]  Смотрите, допустим, у меня тут в какой-то момент получилось так, что есть
[45:57.760 --> 46:01.760]  массив A, массив B, и я указываю на одинаковый элемент.
[46:01.760 --> 46:08.760]  Тут элемент X, тут элемент X.
[46:08.760 --> 46:13.760]  Что мне нужно сделать, чтобы гарантировать стабильность?
[46:13.760 --> 46:17.760]  Да, мне нужно брать элемент X не из B, а из A.
[46:17.760 --> 46:21.760]  Потому что если возьму элемент из B, то он будет стоять в исход в конечном массиве
[46:21.760 --> 46:24.760]  гораздо меньше, чем элемент X из A, согласны?
[46:24.760 --> 46:27.760]  Давайте посмотрим, гарантируется это здесь или нет.
[46:27.760 --> 46:31.760]  Если у меня элемент из A совпадает с элементом массива из B,
[46:31.760 --> 46:35.760]  то по какой ветке я иду? По ветке if или по ветке else?
[46:35.760 --> 46:39.760]  По ветке else, потому что тут в эту ветку я захожу только в случае,
[46:39.760 --> 46:43.760]  если у меня B и B меньше, чем A и A, а сюда я иду в случае,
[46:43.760 --> 46:46.760]  если у меня элемент из массива A меньше либо равен, чем элемент из массива B.
[46:46.760 --> 46:50.760]  Поэтому в случае равенства двух элементов я обязательно возьму элемент из массива A.
[46:50.760 --> 46:54.760]  Я гарантировал, что у меня сортировка будет стабильной. Понятно?
[46:54.760 --> 46:58.760]  То есть элементы из левого массива, то есть те элементы, которые идут раньше,
[46:58.760 --> 47:03.760]  я записываю в конечный массив раньше, чем те элементы, которые идут правее. Согласны?
[47:03.760 --> 47:06.760]  Нормально? Окей.
[47:06.760 --> 47:10.760]  Теперь давайте вернемся в in-play-смерт. Напоминаю, в чем задача.
[47:10.760 --> 47:14.760]  Нам дано две последовательности, про которые сказано,
[47:14.760 --> 47:18.760]  что они идут друг за другом в ком-то массиве, и плюс они обе отсортированы.
[47:18.760 --> 47:24.760]  Мне нужно из них сделать один большой отсортированный массив,
[47:24.760 --> 47:28.760]  при этом не используя никакой дополнительной памяти.
[47:48.760 --> 48:06.760]  Смотрите, я указываю на элемент X, тут указываю на элемент Y.
[48:06.760 --> 48:10.760]  Вот два указателя. Какие ситуации возможны?
[48:10.760 --> 48:14.760]  Возможна ситуация, что X меньше, чем Y, тогда я добавляю X. Нормально.
[48:14.760 --> 48:17.760]  Возможна ситуация, при которой Y меньше, чем X, тогда я добавляю Y.
[48:17.760 --> 48:22.760]  Возможна ситуация, когда у меня два элемента равны друг другу.
[48:22.760 --> 48:25.760]  Что происходит, когда два элемента равны друг другу?
[48:25.760 --> 48:27.760]  Я беру элементы из массива A.
[48:27.760 --> 48:29.760]  Вот, встретили.
[48:29.760 --> 48:33.760]  Так, ну смотрите. Почему мы закинули?
[48:33.760 --> 48:35.760]  Почему мы закинули X?
[48:35.760 --> 48:37.760]  Почему мы закинули Y?
[48:37.760 --> 48:39.760]  Почему мы закинули Y?
[48:39.760 --> 48:41.760]  Почему мы закинули Y?
[48:41.760 --> 48:43.760]  Почему мы закинули Y?
[48:43.760 --> 48:45.760]  Почему мы закинули Y?
[48:45.760 --> 48:47.760]  Почему мы закинули Y?
[48:47.760 --> 48:49.760]  Почему мы закинули Y?
[48:49.760 --> 48:51.760]  Почему мы закинули Y?
[48:51.760 --> 48:53.760]  Почему мы закинули Y?
[48:53.760 --> 48:55.760]  Так, ну, смотрите.
[48:55.760 --> 48:57.760]  Почему мы закинули элемент X?
[48:57.760 --> 48:59.760]  Почему мы закинули элемент Икс?
[48:59.760 --> 49:06.760]  Почему мы закинули элемент X?
[49:06.760 --> 49:08.760]  Почему мы закинули элемент Икс?
[49:08.760 --> 49:10.760]  Мы закинули элемент Икс, потому что икс меньше, чем Y.
[49:10.760 --> 49:12.760]  То есть в какой момент мы закидываем элемент Икс из B?
[49:12.760 --> 49:16.760]  Только в том случае, если он меньше, чем элемент из массива А.
[49:16.760 --> 49:18.760]  Но если он меньше, чем Y,
[49:18.760 --> 49:22.760]  то тут Иксы точно идти не могут.
[49:22.760 --> 49:24.760]  Поэтому такой ситуации просто быть не может.
[49:30.760 --> 49:32.760]  Есть вопросы?
[49:36.760 --> 49:38.760]  Тут какие ситуации рассмотрели?
[49:38.760 --> 49:40.760]  Рассмотрели ситуации, при которой у меня массив A пустой,
[49:40.760 --> 49:47.760]  массив B пустой, и ситуации, при которой у меня оба массива имеют длину единица.
[49:52.760 --> 49:58.760]  Давайте сделаем следующее.
[50:01.760 --> 50:15.760]  Пусть размер массива A меньше, чем размер массива B.
[50:15.760 --> 50:32.760]  Давайте я возьму элемент X, который стоит в середине массива A.
[50:38.760 --> 50:40.760]  Как это выглядит на картинке?
[50:40.760 --> 50:46.760]  Есть массив A, есть массив B.
[50:46.760 --> 50:50.760]  Я взял элемент X, который стоит по центру.
[50:56.760 --> 50:58.760]  Давайте наоборот.
[50:58.760 --> 51:00.760]  Массив A больше, чем массив B.
[51:00.760 --> 51:02.760]  Я взял элемент X, который стоит по центру.
[51:02.760 --> 51:06.760]  Отсюда следует, что число элементов больше равно, чем n на 4,
[51:06.760 --> 51:08.760]  и тут элементов больше равно, чем n на 4.
[51:08.760 --> 51:10.760]  Согласны?
[51:10.760 --> 51:14.760]  Если A больше из двух частей, то тут хотя бы n на 4 элементов,
[51:14.760 --> 51:16.760]  и тут хотя бы n на 4 элементов.
[51:16.760 --> 51:18.760]  Согласны?
[51:18.760 --> 51:22.760]  Теперь, что я сделаю?
[51:22.760 --> 51:34.760]  Давайте я в массиве B найду элемент, который равен lower bound at X.
[51:38.760 --> 51:46.760]  Что такое lower bound at X?
[51:52.760 --> 51:56.760]  Давайте лучше g обозначу.
[51:56.760 --> 52:06.760]  Lower bound в массиве A от X.
[52:06.760 --> 52:20.760]  Это индекс первого элемента в массиве A,
[52:20.760 --> 52:30.760]  который больше либо равен, чем X.
[52:30.760 --> 52:40.760]  То есть я нашел первый элемент, который больше либо равен, чем X.
[52:40.760 --> 52:44.760]  Тут у меня все элементы, которые больше либо равны X.
[52:44.760 --> 52:48.760]  Тут у меня все элементы меньше X.
[52:48.760 --> 52:54.760]  Понятно?
[52:54.760 --> 53:04.760]  В массиве B давайте lower bound BX.
[53:04.760 --> 53:14.760]  Окей.
[53:14.760 --> 53:18.760]  Какая у нас ситуация сейчас получается?
[53:18.760 --> 53:20.760]  Сейчас у нас получается следующая ситуация.
[53:20.760 --> 53:28.760]  Вот в этой части массива все элементы больше либо равны, чем X.
[53:28.760 --> 53:38.760]  В этой части массива все элементы больше либо равны, чем X.
[53:38.760 --> 53:42.760]  Здесь все элементы меньше X, а тут все элементы больше либо равны X.
[53:42.760 --> 53:46.760]  Согласны?
[53:46.760 --> 53:56.760]  Что будем делать дальше?
[53:56.760 --> 54:02.760]  Тут элементы строго меньше X.
[54:02.760 --> 54:04.760]  Почему?
[54:04.760 --> 54:10.760]  Потому что этот элемент это первый элемент в массиве, который больше либо равен, чем X.
[54:10.760 --> 54:14.760]  Если этот элемент равен X, то это первый такой элемент, который равен X.
[54:14.760 --> 54:20.760]  Поэтому тут все элементы меньше, чем X.
[54:20.760 --> 54:22.760]  Сейчас мы очень много задач параллельно разберем.
[54:22.760 --> 54:26.760]  Смотрите, чего я хочу сейчас сделать.
[54:26.760 --> 54:28.760]  Следующий план такой.
[54:28.760 --> 54:34.760]  Вот у меня кусочек больше либо равны X, есть кусочек меньше X.
[54:34.760 --> 54:40.760]  Согласны ли вы, что именно вот эти кусочки идут не в том порядке?
[54:40.760 --> 54:46.760]  Но вообще было бы неплохо, если бы вот этот кусочек был здесь, а вот этот кусочек был бы здесь.
[54:46.760 --> 54:48.760]  Согласны?
[54:48.760 --> 54:50.760]  Вот.
[54:50.760 --> 54:54.760]  То есть я хочу взять вот эти куски.
[54:54.760 --> 55:04.760]  Давайте я обозначу вот этот кусок A', вот этот кусок A'', вот этот кусок B', вот этот кусок B''.
[55:04.760 --> 55:08.760]  Согласны ли вы, что жизнь была бы лучше,
[55:08.760 --> 55:12.760]  если бы A', A' и B' поменялись местами?
[55:12.760 --> 55:14.760]  Так.
[55:14.760 --> 55:18.760]  То есть стоит перед нами следующая задача.
[55:22.760 --> 55:30.760]  Сейчас разберем классическую задачу салогермических собеседований.
[55:30.760 --> 55:34.760]  Значит, смотрите, есть два массива.
[55:34.760 --> 55:40.760]  Точнее, есть один массив, который как-то разделен на две части.
[55:40.760 --> 55:44.760]  Ну, условно часть A и часть B.
[55:44.760 --> 55:46.760]  Что я хочу сделать?
[55:46.760 --> 55:50.760]  Я хочу применить так называемую операцию rotate.
[55:50.760 --> 55:54.760]  Просто-напросто поменять кусок B с куском A местами.
[55:54.760 --> 56:00.760]  То есть я хочу, чтобы вначале шел кусок B, а потом шел кусок A.
[56:04.760 --> 56:08.760]  Вопрос, как это можно сделать?
[56:08.760 --> 56:10.760]  У меня возникла задача.
[56:10.760 --> 56:12.760]  Я хочу, чтобы кусок B' стоял до куска A''.
[56:12.760 --> 56:16.760]  То есть я хочу эти два куска поменять местами друг другом.
[56:16.760 --> 56:20.760]  Понятное дело, что вот эти куски теоретически могут быть разных размеров.
[56:20.760 --> 56:22.760]  Иначе было бы все слишком просто.
[56:22.760 --> 56:36.760]  В этом случае индекс первого элемента будет просто-напросто не существующим.
[56:36.760 --> 56:40.760]  То есть первый элемент находится за массивом.
[56:40.760 --> 56:44.760]  Тогда B' равен массиву B, а B' это пустой массив.
[56:44.760 --> 56:56.760]  Как будем решать эту задачу?
[56:56.760 --> 57:04.760]  Да, конечно, без дополнительной памяти.
[57:04.760 --> 57:10.760]  У меня есть, допустим, массив 1, 2, 3, 4, 5, 6, 7.
[57:10.760 --> 57:12.760]  Я, допустим, беру кусок вот такой и кусок вот такой.
[57:12.760 --> 57:18.760]  И хочу сделать так, чтобы у меня был массив 4, 5, 6, 7, 1, 2, 3.
[57:18.760 --> 57:24.760]  Еще раз, с конца.
[57:24.760 --> 57:36.760]  Так, подсказка.
[57:36.760 --> 57:42.760]  Эта задача сложная, я понял.
[57:42.760 --> 57:44.760]  А как их выровнять?
[57:44.760 --> 57:56.760]  То есть если у меня число элементов нечетное, то их как не выровню?
[57:56.760 --> 58:00.760]  Ну, кажется, так не получится, но давайте придем к кому-нибудь более простому решению,
[58:00.760 --> 58:04.760]  которое не требует условно выворота мозга.
[58:04.760 --> 58:10.760]  А если куски разных размеров?
[58:10.760 --> 58:12.760]  Ну нет, нет, нет, если у вас куски разных размеров,
[58:12.760 --> 58:14.760]  тогда у вас, смотрите, если у вас
[58:14.760 --> 58:16.760]  куск A сильно меньше, чем куск B,
[58:16.760 --> 58:18.760]  то у вас тут должно быть наоборот.
[58:18.760 --> 58:22.760]  Вот это большой кусок, а вот эти элементы должны вот тут стоять.
[58:22.760 --> 58:24.760]  Вот, развернуть хорошие идеи.
[58:24.760 --> 58:26.760]  Давайте рассмотрим более простую задачу.
[58:26.760 --> 58:28.760]  Задачу reverse.
[58:28.760 --> 58:30.760]  Есть массив A?
[58:30.760 --> 58:34.760]  Какой это массив A?
[58:34.760 --> 58:38.760]  Нужно его развернуть в обратном порядке.
[58:38.760 --> 58:42.760]  Ну какую задачу решать, я думаю, вы понимаете.
[58:42.760 --> 58:46.760]  Ну просто-напросто идем с первого элемента по пополамтоэлемент
[58:46.760 --> 58:48.760]  и обмениваем там первый элемент с последним,
[58:48.760 --> 58:50.760]  второй элемент с предпоследним, ну и так далее.
[58:50.760 --> 58:52.760]  Нормально, да?
[58:52.760 --> 58:54.760]  Ну эта задача простая.
[58:54.760 --> 58:58.760]  Но вот я утверждаю, что первая задача такая же простая, как и reverse.
[58:58.760 --> 59:00.760]  Что на самом деле rotate
[59:00.760 --> 59:02.760]  можно сделать с помощью
[59:02.760 --> 59:04.760]  трех reverse.
[59:08.760 --> 59:10.760]  Ну как, как это можно сделать?
[59:12.760 --> 59:14.760]  Во, да.
[59:14.760 --> 59:16.760]  Смотрите.
[59:16.760 --> 59:18.760]  Rotate
[59:18.760 --> 59:20.760]  вот AB.
[59:20.760 --> 59:22.760]  Давайте я сначала возьму
[59:24.760 --> 59:26.760]  и сделаю
[59:26.760 --> 59:28.760]  reverse
[59:28.760 --> 59:30.760]  всего массива AB.
[59:32.760 --> 59:34.760]  Это первый шаг.
[59:34.760 --> 59:36.760]  Что я в итоге получу?
[59:36.760 --> 59:38.760]  Согласны ли вы, что я сначала получу перевернутый массив B,
[59:40.760 --> 59:42.760]  а потом перевернутый массив A?
[59:44.760 --> 59:46.760]  Согласны?
[59:46.760 --> 59:48.760]  Так.
[59:48.760 --> 59:50.760]  Следующим шагом.
[59:50.760 --> 59:52.760]  Давайте я сделаю reverse
[59:52.760 --> 59:54.760]  от A штрих,
[59:54.760 --> 59:56.760]  ну дальше от B штрих.
[01:00:00.760 --> 01:00:02.760]  То есть я возьму вот этот кусок
[01:00:02.760 --> 01:00:04.760]  и разверну его.
[01:00:04.760 --> 01:00:06.760]  Что я в итоге получу?
[01:00:10.760 --> 01:00:12.760]  В итоге я получу кусок B
[01:00:12.760 --> 01:00:14.760]  и A штрих.
[01:00:14.760 --> 01:00:16.760]  Ну и наконец третьим пунктом
[01:00:18.760 --> 01:00:20.760]  я сделаю reverse от A штрих.
[01:00:20.760 --> 01:00:22.760]  В итоге получу
[01:00:22.760 --> 01:00:24.760]  B
[01:00:24.760 --> 01:00:26.760]  и A.
[01:00:30.760 --> 01:00:32.760]  Перешел от такой, от такого массива
[01:00:32.760 --> 01:00:34.760]  к вот такому массиву.
[01:00:34.760 --> 01:00:36.760]  Вопросы?
[01:00:38.760 --> 01:00:40.760]  Ну, reverse работает за линейное время,
[01:00:40.760 --> 01:00:42.760]  reverse работает за линейное время, за линейное время.
[01:00:42.760 --> 01:00:44.760]  Кажется, я за линейное время смог обменять два куска местами.
[01:00:44.760 --> 01:00:46.760]  То есть по сути такой свап для массивов,
[01:00:46.760 --> 01:00:48.760]  которые идут последовательно друг за другом.
[01:00:48.760 --> 01:00:50.760]  Правильно?
[01:00:50.760 --> 01:00:52.760]  Так.
[01:00:52.760 --> 01:00:54.760]  Ну, кажется, решили под задачку здесь.
[01:00:54.760 --> 01:00:56.760]  То есть, ну давайте я тут
[01:00:56.760 --> 01:00:58.760]  определю кусочки
[01:00:58.760 --> 01:01:00.760]  следующим образом.
[01:01:00.760 --> 01:01:02.760]  Значит, кусочек A штрих
[01:01:02.760 --> 01:01:04.760]  это будет кусочек A
[01:01:04.760 --> 01:01:06.760]  от нулевого до
[01:01:06.760 --> 01:01:08.760]  позиции
[01:01:08.760 --> 01:01:10.760]  X невключительно.
[01:01:10.760 --> 01:01:12.760]  Ну и X я обозначил позицию X.
[01:01:12.760 --> 01:01:14.760]  Ну позиции, ладно, позицию X
[01:01:14.760 --> 01:01:16.760]  у меня понятна, это N пополам.
[01:01:16.760 --> 01:01:18.760]  Ой, N на 4.
[01:01:22.760 --> 01:01:24.760]  Модуль A делить на 2.
[01:01:28.760 --> 01:01:30.760]  А 2 штриха, вот этот кусочек,
[01:01:30.760 --> 01:01:32.760]  это массив A
[01:01:32.760 --> 01:01:34.760]  начиная с позиции
[01:01:34.760 --> 01:01:36.760]  A пополам
[01:01:36.760 --> 01:01:38.760]  ну и до
[01:01:38.760 --> 01:01:40.760]  A невключительно.
[01:01:42.760 --> 01:01:44.760]  Так.
[01:01:44.760 --> 01:01:46.760]  Кусочек B штрих
[01:01:46.760 --> 01:01:48.760]  это у меня массив B
[01:01:48.760 --> 01:01:50.760]  начиная с нуля
[01:01:50.760 --> 01:01:52.760]  и до
[01:01:52.760 --> 01:01:54.760]  где?
[01:01:54.760 --> 01:01:56.760]  До G невключительно.
[01:01:56.760 --> 01:01:58.760]  G это lower bound от X, да, помните?
[01:02:00.760 --> 01:02:02.760]  Ну и B2 штриха
[01:02:02.760 --> 01:02:04.760]  это у меня
[01:02:04.760 --> 01:02:06.760]  массив B, ну давайте так
[01:02:06.760 --> 01:02:08.760]  напишу G-то и по последней.
[01:02:08.760 --> 01:02:10.760]  Ну все, то есть по сути
[01:02:10.760 --> 01:02:12.760]  просто написал определение кусочков
[01:02:12.760 --> 01:02:14.760]  A2 штрих, A2 штриха, B штрих, B2 штриха.
[01:02:14.760 --> 01:02:16.760]  Окей?
[01:02:16.760 --> 01:02:18.760]  Так, давайте перейду на
[01:02:20.760 --> 01:02:22.760]  вот эту доску.
[01:02:30.760 --> 01:02:32.760]  Так, следующим шагом, как я сказал
[01:02:32.760 --> 01:02:34.760]  просто поменяю местами кусочек B
[01:02:34.760 --> 01:02:36.760]  штрих и кусочек A штрих. То есть применю как раз
[01:02:36.760 --> 01:02:38.760]  вот эту процедуру rotate.
[01:02:38.760 --> 01:02:40.760]  Запишу rotate
[01:02:40.760 --> 01:02:42.760]  A2 штриха
[01:02:42.760 --> 01:02:44.760]  и B штрих.
[01:02:46.760 --> 01:02:48.760]  Так, что я в итоге получу?
[01:02:52.760 --> 01:02:54.760]  Да, в итоге я получу 4 отсортированные
[01:02:54.760 --> 01:02:56.760]  последовательности.
[01:02:56.760 --> 01:02:58.760]  Тут элементы все больше,
[01:02:58.760 --> 01:03:00.760]  так, меньше XA
[01:03:00.760 --> 01:03:02.760]  это кусочек B штрих.
[01:03:02.760 --> 01:03:04.760]  Тут все элементы больше равны XA
[01:03:04.760 --> 01:03:06.760]  это кусочек A2 штриха.
[01:03:06.760 --> 01:03:08.760]  Так.
[01:03:08.760 --> 01:03:10.760]  Подведем промежуточный итог.
[01:03:12.760 --> 01:03:14.760]  Что я сделал?
[01:03:14.760 --> 01:03:16.760]  У меня был исходно
[01:03:16.760 --> 01:03:18.760]  вот такой массив,
[01:03:18.760 --> 01:03:20.760]  который состоял из двух отсортированных.
[01:03:20.760 --> 01:03:22.760]  Теперь я получил 4 отсортированных кусочка,
[01:03:22.760 --> 01:03:24.760]  но зато слева у меня все элементы
[01:03:24.760 --> 01:03:26.760]  меньше либо равны X, а справа все элементы
[01:03:26.760 --> 01:03:28.760]  больше либо равны X. Окей?
[01:03:28.760 --> 01:03:30.760]  То есть по сути я
[01:03:30.760 --> 01:03:32.760]  что-то хорошее да сделал,
[01:03:32.760 --> 01:03:34.760]  то есть я все маленькие элементы
[01:03:34.760 --> 01:03:36.760]  перенес отсюда сюда, все большие элементы
[01:03:36.760 --> 01:03:38.760]  окей.
[01:03:38.760 --> 01:03:40.760]  Давайте еще о чем поговорим.
[01:03:40.760 --> 01:03:42.760]  Верно ли, что на текущий момент
[01:03:42.760 --> 01:03:44.760]  моя процедура является
[01:03:44.760 --> 01:03:46.760]  стабильной, в том смысле, что она
[01:03:46.760 --> 01:03:48.760]  сохраняет относительный порядок равных элементов?
[01:03:48.760 --> 01:03:50.760]  Почему?
[01:03:58.760 --> 01:04:00.760]  Смотрите, это действительно так, почему?
[01:04:00.760 --> 01:04:02.760]  Потому что единственная проблема,
[01:04:02.760 --> 01:04:04.760]  которая может возникнуть,
[01:04:04.760 --> 01:04:06.760]  допустим, у меня есть элементы тут,
[01:04:06.760 --> 01:04:08.760]  ну смотрите,
[01:04:08.760 --> 01:04:10.760]  какие элементы у меня
[01:04:10.760 --> 01:04:12.760]  могут быть равны вот здесь и здесь?
[01:04:12.760 --> 01:04:14.760]  В кусочке h' и h',
[01:04:14.760 --> 01:04:16.760]  какие у меня будут совпадающие элементы?
[01:04:16.760 --> 01:04:18.760]  Только иксы, да?
[01:04:18.760 --> 01:04:20.760]  Ну смотрите, в исходном массиве
[01:04:20.760 --> 01:04:22.760]  у меня вот эти иксы шли
[01:04:22.760 --> 01:04:24.760]  после вот этих иксов, и в полученном массиве
[01:04:24.760 --> 01:04:26.760]  эти иксы тоже идут после этих иксов, согласны?
[01:04:26.760 --> 01:04:28.760]  Все хорошо.
[01:04:28.760 --> 01:04:30.760]  Так, теперь давайте посмотрим
[01:04:30.760 --> 01:04:32.760]  вот здесь, ничего ли я не
[01:04:32.760 --> 01:04:34.760]  нарушил я стабильность вот этого куска
[01:04:34.760 --> 01:04:36.760]  с вот этим куском? Ну нет, тут у меня
[01:04:36.760 --> 01:04:38.760]  все элементы меньше иксов, а тут больше иксов,
[01:04:38.760 --> 01:04:40.760]  а тут вообще априори не может быть равных элементов, согласны?
[01:04:40.760 --> 01:04:42.760]  Ну и тут
[01:04:42.760 --> 01:04:44.760]  если тут были какие-то равные элементы
[01:04:44.760 --> 01:04:46.760]  с вот этими элементами, то этот кусок
[01:04:46.760 --> 01:04:48.760]  как шел позже всех, так и идет позже всех.
[01:04:48.760 --> 01:04:50.760]  Все, кажется, что никакие элементы равные не поменяли
[01:04:50.760 --> 01:04:52.760]  относительный порядок.
[01:04:52.760 --> 01:04:54.760]  Согласны?
[01:04:54.760 --> 01:04:56.760]  Так.
[01:04:56.760 --> 01:04:58.760]  Да.
[01:05:04.760 --> 01:05:06.760]  Ну блин, смотрите, давайте вот эту запись
[01:05:06.760 --> 01:05:08.760]  считать просто как
[01:05:08.760 --> 01:05:10.760]  псевдокод, как просто некоторые математическая
[01:05:10.760 --> 01:05:12.760]  абстракция. То есть просто мысленно считаем,
[01:05:12.760 --> 01:05:14.760]  что h' это вот этот кусок, b' это
[01:05:14.760 --> 01:05:16.760]  вот этот кусок, h' вот этот кусок и так далее.
[01:05:18.760 --> 01:05:20.760]  Да-да-да-да.
[01:05:20.760 --> 01:05:22.760]  Да, это просто мысленная абстракция, тут
[01:05:22.760 --> 01:05:24.760]  никаких выделений массива на самом деле не происходит.
[01:05:24.760 --> 01:05:26.760]  Вот.
[01:05:26.760 --> 01:05:28.760]  Получили вот такую ситуацию.
[01:05:28.760 --> 01:05:30.760]  А теперь сделаем
[01:05:30.760 --> 01:05:32.760]  страшное.
[01:05:34.760 --> 01:05:36.760]  Смотрите.
[01:05:38.760 --> 01:05:40.760]  Вот, смотрите, вот эта часть
[01:05:40.760 --> 01:05:42.760]  и вот эта часть, они вроде как
[01:05:42.760 --> 01:05:44.760]  относительно друг другу уже отсортированы, с ними все хорошо.
[01:05:46.760 --> 01:05:48.760]  Смотрите, согласитесь ли вы,
[01:05:48.760 --> 01:05:50.760]  что если я солью вот эти части друг с другом
[01:05:50.760 --> 01:05:52.760]  и вот эти части друг с другом, то я получу
[01:05:52.760 --> 01:05:54.760]  полностью отсортированный массив.
[01:05:54.760 --> 01:05:56.760]  То есть вот это кусок отсортирован, это кусок отсортирован
[01:05:56.760 --> 01:05:58.760]  Я их солью друг с другом,
[01:05:58.760 --> 01:06:00.760]  получу отсортированный массив. Тут тоже эти
[01:06:00.760 --> 01:06:02.760]  солью друг с другом, получу отсортированный массив, ну, в итоге
[01:06:02.760 --> 01:06:04.760]  два этих отсортированных массива дадут мне один большой отсортированный
[01:06:04.760 --> 01:06:05.760]  массив.
[01:06:06.760 --> 01:06:08.760]  Делаю страшную вещь.
[01:06:14.760 --> 01:06:16.760]  Пишу in place merge
[01:06:16.760 --> 01:06:18.760]  от
[01:06:18.760 --> 01:06:20.760]  h'
[01:06:20.760 --> 01:06:39.760]  Inplace merge. Вот a2, b2, k. Все.
[01:06:39.760 --> 01:06:48.760]  Да-да-да, то есть i и b можно считать, что это указатели на первые элементы части a и части b.
[01:06:48.760 --> 01:06:59.760]  Какую страшную вещь мы сделали? Мы свели исходную задачу к двум задачкам меньше. Согласны?
[01:06:59.760 --> 01:07:12.760]  То, что мы сейчас сделали, называется рекурсия. Формально рекурсию мы с вами будем проходить на следующем занятии, но в целом идея понятна.
[01:07:12.760 --> 01:07:24.760]  Если у нас есть какая-то большая задача, которую сложно решать, мы ее можем разбить на несколько других подзадач, которые тоже сложно решать, но они хотя бы имеют меньший размер. Понятно?
[01:07:24.760 --> 01:07:35.760]  Давайте попробуем это все проанализировать с точки зрения времени работы. Давайте попробуем математически доказать, что на самом деле тут все будет хорошо.
[01:07:35.760 --> 01:07:53.760]  Докажем по индукции. База индукции какая? База индукции, что у меня массив a равен нулю или массив b равен нулю.
[01:07:53.760 --> 01:08:03.760]  Или массив a равен единице и массив b, то есть размер массива b равен единице. Согласны ли вы, что в этом случае все хорошо?
[01:08:03.760 --> 01:08:32.760]  Но эти все случаи тривиальные, поэтому база индукции доказана. Допустим, пусть in-place merge умеет работать на массивах суммарной длины меньше, чем n.
[01:08:32.760 --> 01:08:44.760]  Предположение индукции. Для базы индукции это верно. Если сумма кусочков у меня равна нулю или кусочки маленькие, то я умею все делать.
[01:08:44.760 --> 01:08:50.760]  Теперь давайте предположим, что in-place merge умеет работать для произвольных массивов, суммарной длины которых не происходит n.
[01:08:50.760 --> 01:09:00.760]  Давайте докажу, что тогда у меня все работает и для in-place merge для массивов, суммарной длины которых равна n. Как я это делаю?
[01:09:00.760 --> 01:09:09.760]  Я запускаю in-place merge, перепорядочиваю все вот таким вот образом, и запускаю in-place merge от а3 к а3 и а2 к а2 к а3.
[01:09:09.760 --> 01:09:17.760]  Согласны ли вы, что суммарная длина этих кусочков меньше, чем n и суммарная длина этих кусочков меньше, чем n?
[01:09:17.760 --> 01:09:27.760]  Согласны? Все, окажется, что я победил. То есть все элементы меньше равны x, тут все элементы больше равны x.
[01:09:27.760 --> 01:09:35.760]  По предположению индукции вот это in-place merge сделает красиво все, это in-place merge тоже сделает красиво, в итоге у меня получится один большой отсортированный массив.
[01:09:35.760 --> 01:09:40.760]  Доказательство закончено. Понятно? Нормально?
[01:09:43.760 --> 01:09:52.760]  Да, смотрите, в предположении индукции, допустим in-place merge умеет сливать два массива, суммарные длины которых меньше, чем n.
[01:09:52.760 --> 01:09:58.760]  Допустим, мне на вход подается массив размера n. Что делает in-place merge?
[01:09:58.760 --> 01:10:09.760]  In-place merge, как я описал, вот тут и вот тут, в rotate, перепорядочит массив так, что в начале идут все элементы меньше равны x,
[01:10:09.760 --> 01:10:13.760]  то есть тут меньше равны x, тут меньше x, тут больше равны x, тут больше равны x. Согласны?
[01:10:13.760 --> 01:10:19.760]  И я дальше запускаю in-place merge от вот этих кусков и от вот этих кусков.
[01:10:19.760 --> 01:10:31.760]  Согласны ли вы, что если суммарное количество элементов у меня было n, то после выполнения этих операций вот тут у меня будет число элементов меньше, чем n, и тут точно меньше, чем n. Согласны?
[01:10:31.760 --> 01:10:56.760]  Подождите, я пока не оцениваю время работы. Я доказываю, что это работает.
[01:10:56.760 --> 01:11:08.760]  Я сделал предположение, что in-place merge имеет работать с массивами, суммарные которых меньше, чем n. Тут число элементов меньше, чем n, тут число элементов меньше, чем n,
[01:11:08.760 --> 01:11:14.760]  поэтому я могу воспользоваться предположением индукции и сказать, что тут все будет хорошо, тут все будет хорошо. Согласны?
[01:11:14.760 --> 01:11:23.760]  Все. А раз тут и тут все будет хорошо, то тут у меня будет отсортированный массив, в котором все элементы меньше равны x, а тут будет отсортированный массив, в котором все элементы больше равны x.
[01:11:23.760 --> 01:11:31.760]  Но кажется, что в итоге я получу один большой отсортированный массив. Все, я доказал переход. Соответственно, in-place merge действительно делает то, что нам нужно. Согласны?
[01:11:31.760 --> 01:11:37.760]  Теперь, если успеем, давайте поговорим, точнее запедраним время работы.
[01:11:37.760 --> 01:11:49.760]  Вот сейчас нам это пригодится. Как раз-таки во время работы мы это учтем.
[01:11:49.760 --> 01:12:17.760]  Так, смотрите. Изначально я запускаю in-place merge от a и b. Сумма длин a и b, допустим, равна n.
[01:12:17.760 --> 01:12:24.760]  Давайте я посмотрю, за сколько времени он отработает in-place merge, когда у меня размер входа равен n. К чему сводится у меня in-place merge?
[01:12:24.760 --> 01:12:33.760]  Ну, in-place merge у меня работает, сам по себе работает, за theta от n. Да, ну почему? Потому что время тратится на эти, ну там lower bound, понятное дело, я могу с помощью бинарного поиска найти.
[01:12:33.760 --> 01:12:45.760]  То есть основное время тратится на дет ротейт, дурацкий. Понятно? Согласны, что ротейт займет максимум, давайте o напишем, o большое от n времени.
[01:12:45.760 --> 01:13:02.760]  Вот. И плюс я вызовусь от in-place merge от a-b- и in-place merge от a-2-b-.
[01:13:02.760 --> 01:13:12.760]  Так, теперь давайте поймем, какой размер вот этой задачи и какой размер вот этой задачи. И вот как раз воспользуемся тем, что массив a больше, чем массив b.
[01:13:12.760 --> 01:13:34.760]  Смотрите, у меня вот отсюда следует, что размер h' больше равен, чем n на 4, и размер a2' тоже больше равен, чем n на 4. Согласны?
[01:13:34.760 --> 01:13:41.760]  Ну раз большой, раз кусок a изначально, вот этот кусок a был большим среди этих двух кусков, поэтому тут хотя бы n половым элементов.
[01:13:41.760 --> 01:13:46.760]  А так я его распилил половым, и в том, и в той части, как минимум n на 4 элементов. Согласны?
[01:13:46.760 --> 01:13:58.760]  Так, но если тут хотя бы n на 4 элементов, то это значит, что вот тут суммарно хотя бы n на 4 элементов, и тут суммарно хотя бы n на 4 элементов.
[01:13:58.760 --> 01:14:09.760]  Понятно? Но если тут хотя бы n на 4 элементов, то тут никак не больше 3n на 4 элементов. Согласны?
[01:14:09.760 --> 01:14:19.760]  А растут больше n на 4 элементов, то тут никак не больше 3n на 4 элементов. Все, вот это нафиг. Вот, вот что мне нужно.
[01:14:19.760 --> 01:14:26.760]  То есть я свел исходную задачу к двум задачам, которые меньше по размеру, причем меньше по размеру в 4 третьих раза.
[01:14:29.760 --> 01:14:33.760]  Вот. Так, теперь что я делаю?
[01:14:33.760 --> 01:14:38.760]  Каждый из этих in-place merge. Сколько времени занимает?
[01:14:39.760 --> 01:14:42.760]  Ну, короче говоря, я могу записать рекуррентное соотношение.
[01:14:42.760 --> 01:14:52.760]  Давайте так, что t от n равно t от 3n на 4 умножить на 2.
[01:14:55.760 --> 01:14:57.760]  Рекуррентное соотношение решали?
[01:14:57.760 --> 01:15:01.760]  Упражнение. Ну, это простое рекуррентное соотношение. Упражнение.
[01:15:01.760 --> 01:15:06.760]  Показать, что t от n есть o большое от n lug n.
[01:15:08.760 --> 01:15:13.760]  Ну, это все уходит в ошку, в o большое.
[01:15:13.760 --> 01:15:16.760]  Смотрите, мы на lower bound тратим, действительно, логарифом.
[01:15:16.760 --> 01:15:20.760]  Но на rotate мы тратим линейное время. Кажется, это больше, чем логарифом.
[01:15:20.760 --> 01:15:23.760]  Поэтому на lower bound можем просто на o забить.
[01:15:23.760 --> 01:15:29.760]  Все, то есть время работы in-place merge удовлетворяет вот такому соотношению.
[01:15:29.760 --> 01:15:32.760]  Ну, давайте так, тут межки в равно можно писать, межки в равно, межки в равно.
[01:15:32.760 --> 01:15:35.760]  Это какое-то линейное количество операций.
[01:15:35.760 --> 01:15:37.760]  Это какое-то линейное количество операций.
[01:15:37.760 --> 01:15:40.760]  Плюс дважды t от 3 на 4.
[01:15:40.760 --> 01:15:43.760]  Но кажется, что если мы построим дерево рекурсии,
[01:15:43.760 --> 01:15:45.760]  ну, например, с помощью дерева рекурсии,
[01:15:45.760 --> 01:15:47.760]  или там с помощью метода угадывания.
[01:15:47.760 --> 01:15:50.760]  Кстати, мы проходили метод угадывания, вот это вот все.
[01:15:50.760 --> 01:15:52.760]  То можно прийти к решению n lug.
[01:15:52.760 --> 01:15:57.760]  То есть главная суть заключается, еще раз, давайте повторю главную суть.
[01:15:57.760 --> 01:16:02.760]  Массив A, по предположению, больше, чем массив B.
[01:16:02.760 --> 01:16:04.760]  Поэтому в нем хотя бы n пополам элементов.
[01:16:04.760 --> 01:16:10.760]  Отсюда следует, что в массиве a' и a' хотя бы n на 4 элементов.
[01:16:11.760 --> 01:16:14.760]  Значит, вот тут суммарно хотя бы n на 4 элементов,
[01:16:14.760 --> 01:16:16.760]  и тут хотя бы n на 4 элементов.
[01:16:16.760 --> 01:16:25.760]  Раз тут хотя бы n на 4 элементов, то тут никак не больше 3n на 4 элемента.
[01:16:26.760 --> 01:16:30.760]  Все, то есть я свел задачу по 100% меньше под задачу,
[01:16:30.760 --> 01:16:33.760]  причем в несколько раз, поэтому в 4 третьих раз.
[01:16:34.760 --> 01:16:54.840]  Всё. Это упражнение 1. Упражнение 2. Что делать, если на самом деле массив b больше, чем массив a?
[01:16:54.840 --> 01:17:05.640]  Ну, смотрите, мы предположили, что у нас массив a, то есть эта часть больше, чем массив b.
[01:17:05.640 --> 01:17:10.440]  Но такое же, в принципе, не всегда выполняется. Теоретически у неё массив b может быть больше, чем массив a.
[01:17:10.440 --> 01:17:32.440]  Ну, смотрите, первый вариант окей, согласен. Можно просто сделать ротейт и поменять массивы b, массивы а. Хуже не станет.
[01:17:32.440 --> 01:17:40.440]  А подумайте, как это можно сделать без ротейт. Вот как сделать то же самое, но только вот в обратной ситуации.
[01:17:40.440 --> 01:17:46.440]  То есть на самом деле код будет абсолютно такой же. То есть тоже ищем центральный элемент b, затем ищем какой-то элемент va.
[01:17:46.440 --> 01:17:52.440]  Вот, кстати, вопрос, какой элемент va нужно искать. В общем, небольшое упражнение на подумать.
[01:17:52.440 --> 01:17:58.440]  Ну, в целом идея ротейт зачёт.
[01:17:58.440 --> 01:18:02.440]  Так, на сегодня всё. Всем спасибо.
