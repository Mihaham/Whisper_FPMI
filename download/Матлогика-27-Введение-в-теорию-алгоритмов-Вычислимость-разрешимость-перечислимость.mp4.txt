[00:00.000 --> 00:13.000]  Сегодня мы начнём разговор о алгоритмах, которые, видимо, займёт у нас всё оставшееся время.
[00:13.000 --> 00:25.400]  Ну, алгоритмы можно излагать, конечно, по-разному. Возможно, весьма формальные изложения. То есть,
[00:26.400 --> 00:33.400]  как мы можем записывать алгоритмы? Давайте, тем не менее, пойдём от реальной жизни. Как мы это делаем?
[00:33.400 --> 00:42.400]  Как мы на практике записываем алгоритмы? Кодом, то есть с помощью неких языков программирования,
[00:42.400 --> 00:51.400]  у которых имеется совершенно точно определённая семантика, то есть значение. Вроде того, как мы с вами
[00:51.400 --> 00:59.400]  построили значение логических формул, это многих из вас шокировало. Семантика языков программирования
[00:59.400 --> 01:09.400]  шокировала бы вас больше. Я не знаю, читали ли вы, например, стандарт какого-нибудь языка? C, например,
[01:09.400 --> 01:19.400]  или там C++. Если читали, возможно, вы заметили, что семантика там изложена обычно неформально.
[01:19.400 --> 01:28.400]  Неформально написано, что делает тот или иной оператор языка. А вот синтаксис языка обычно в приложениях
[01:28.400 --> 01:35.400]  изложен формально. Написана так называемая порождающая грамматика, что-то вроде индуктивного определения
[01:35.400 --> 01:45.400]  для всех правильно построенных поражений программ наших языков. Поэтому, чтобы излагать алгоритмы
[01:45.400 --> 01:50.400]  формально, нам нужно ввести некий язык программирования и точно определить его семантиком.
[01:50.400 --> 02:00.400]  Это весьма мучительное занятие. Но вместе с тем мы с вами, в принципе, давно знакомы с программированием
[02:00.400 --> 02:09.400]  и имеем определенную интуицию того, что алгоритмы могут или не могут делать. Поэтому основная идея
[02:09.400 --> 02:17.400]  вот этой вот теории, которую я вам предлагаю, мы постараемся изложить неформально. Для нас понятие
[02:17.400 --> 02:26.400]  алгоритм останется неформальным. Тем не менее, давайте отметим определенные его черты. Но, во-первых,
[02:26.400 --> 02:34.400]  у нас будут только детерминированные алгоритмы. Ничего, никакой рандомизации, ничего такого у нас не будет.
[02:34.400 --> 02:48.400]  Вот. Как же работает алгоритм? Ну, вообще говоря, он принимает некий вход, правильно? Что-то с этим входом
[02:48.400 --> 03:03.400]  делает. И какие есть варианты? Что может произойти? Применяете ваш опыт. Либо он завершается
[03:03.400 --> 03:13.400]  за конечное время. А что является временем в мире алгоритмов? Алгоритмы дискретные, они выполняются
[03:13.400 --> 03:22.400]  по шагам, правильно? На практике под этими шагами можно понимать разные вещи. Ну, например, если вы
[03:22.400 --> 03:28.400]  представите себе компьютер, то можно под шагами понимать там такт, процессор или что-нибудь такое.
[03:28.400 --> 03:35.400]  Шаги можно определять по-разному, но как вы не подойдете к алгоритму, он выполняется по шагам.
[03:35.400 --> 03:47.400]  Либо же за конечное число шагов наш алгоритм закончится и напечатает некий выход, правильно?
[03:47.400 --> 04:02.400]  Второй вариант. Второй вариант алгоритма не останавливается ни за какое конечное число шагов.
[04:02.400 --> 04:12.400]  При этом он может что-нибудь и выводит, но мы сейчас этот вопрос не обсуждаем. Согласны? Так, отлично.
[04:12.400 --> 04:24.400]  Это мы более или менее понимаем. А чем являются вход и выход алгоритма? Данными. Хорошее определение.
[04:24.400 --> 04:30.400]  Можешь сказать, что данные по определению этого входа и выхода алгоритма. Ну вот скажите, пожалуйста,
[04:30.400 --> 04:38.400]  вещественные числа могут быть такими данными? Может алгоритм работать с вещественными числами?
[04:38.400 --> 04:43.400]  Что значит с некоторой точностью?
[04:43.400 --> 04:58.400]  Ну и как же он это делает? Как, например, можно подать на вход произвольное вещественное число?
[04:58.400 --> 05:10.400]  Вот алгоритм, который возводит любое вещественное число в квадрат. Можете себе такое представить? Как он выглядит?
[05:10.400 --> 05:25.400]  Можете такой алгоритм написать на Си? А какой будет входной тип?
[05:25.400 --> 05:43.400]  А double это вещественные числа? Нет. Double это рациональные числа. Что же делать?
[05:43.400 --> 05:50.400]  Как произвольное вещественное число возводить в квадрат? Ну, допустим, даже мы его как-то ввели в алгоритм,
[05:50.400 --> 06:04.400]  а что с ним делать? Как его в квадрат возводить? Как вы себе это представляете?
[06:04.400 --> 06:11.400]  Как умножить одно вещественное число на другое?
[06:11.400 --> 06:20.400]  Правильно.
[06:20.400 --> 06:25.400]  Не очень понял вас.
[06:25.400 --> 06:31.400]  А как это иррациональное вы будете представлять?
[06:31.400 --> 06:39.400]  А каждый иррациональный это корень чего-то? Протрансцендентные числа не слышали?
[06:39.400 --> 06:52.400]  Вот пи, например, это не корень никакого рационального.
[06:52.400 --> 07:01.400]  На самом деле вещественные числа, они существенно бесконечны. Их вообще, говоря, нельзя представить конечным образом.
[07:01.400 --> 07:08.400]  Доказательства это очень простое. Конечных представлений счетно много, а вещественных чисел континум.
[07:08.400 --> 07:15.400]  То есть на самом деле алгоритм работает с объектами, имеющими конечное описание.
[07:15.400 --> 07:22.400]  И даже не с любыми такими объектами, а так называемыми конструктивными объектами.
[07:22.400 --> 07:37.400]  Например, такими, которые мы могли бы сравнить алгоритмически, проверить за конечное время, равны там они или нет.
[07:37.400 --> 07:48.400]  Что это означает на практике? На практике это конечные слова в конечных алфавитах.
[07:48.400 --> 07:57.400]  Помните, что такое слово? Это последовательность конечная, поэтому слово конечное тут избыточно.
[07:57.400 --> 08:10.400]  Конечные слова конечных алфавитов. А сколько таких слов? Сколько в конечном алфавите не пустом слов?
[08:10.400 --> 08:22.400]  Сколько слов можно составить из букв А? А из букв А и Б? Таких слов счетно много.
[08:22.400 --> 08:44.400]  Поэтому можно считать, что вход и выход это натуральные числа или их какие-то наборы. Понятная идея?
[08:44.400 --> 08:52.400]  Натуральные числа это конечные слова конечных алфавитов, например, в двоичной записи.
[08:52.400 --> 09:02.400]  Мы неформально считаем, что алгоритмы работают с конечными словами конечных алфавитов, вроде последовательности нуле единиц.
[09:02.400 --> 09:11.400]  Но при этом на практике всегда можно считать, что такие слова закодированы натуральными числами. Понятно?
[09:11.400 --> 09:28.400]  Поэтому мы можем нашу теорию строить для работы с натуральными числами, обобщая почти автоматически все результаты на наборы натуральных чисел.
[09:28.400 --> 09:37.400]  Ну поехали. Коль алгоритм по входу выдает выход, и выход этот зависит в общем только от входа.
[09:37.400 --> 09:49.400]  Алгоритм-то у нас детерминирован, он ничего не принимает от пользователя, ничего не ждет по сети, значит нет там никакого генератора случайных чисел.
[09:50.400 --> 10:00.400]  Выход является, стало быть, функцией входа, правильно? Каждому алгоритму соответствует некоторая функция в нашей модели.
[10:00.400 --> 10:06.400]  А если алгоритм не останавливается на входе, что же мы можем сказать о функции?
[10:06.400 --> 10:20.400]  Соответствующий алгоритм. Почему бесконечно? Как почему бесконечно? Что значит бесконечно? Что вы вообще имеете?
[10:20.400 --> 10:25.400]  Не определена. Помните, у нас были частичные функции.
[10:25.400 --> 10:35.400]  Вот в нашей модели алгоритмы будут вычислять частичные функции между наборами натуральных, ну или для простоты просто натуральными.
[10:35.400 --> 10:58.400]  Важнейшее определение. Функция F частичная, из натуральных в натуральные вычислима тогда и только тогда, когда существует алгоритм A.
[10:58.400 --> 11:10.400]  Такое, что для любого натурального x, если x принадлежит домену функции, помните какой домен?
[11:10.400 --> 11:34.400]  Ну где она определена? Тогда A на входе x, давайте так напишем, существует к натуральное такое, что A на входе x останавливается за k шагов
[11:34.400 --> 11:43.400]  и выдает значение нашей функции F от x, правильно?
[11:43.400 --> 12:01.400]  Так, а что будет, если x не принадлежит домену F?
[12:01.400 --> 12:15.400]  A на входе x не останавливается за k шагов, ни для какого k.
[12:15.400 --> 12:26.400]  Итак, что же означает вычислимость функции? Где функция определена, алгоритм за сколько-то шагов остановится и напечатает ее значение.
[12:26.400 --> 12:31.400]  Где она не определена, он точно не остановится, понятно?
[12:31.400 --> 12:44.400]  Так, пример. Рассвоим такую функцию, она даже будет тотальной, определенной на всех натуральных входах.
[12:44.400 --> 12:56.400]  Смотрите, F от x возвращает единицу, если бок есть, значит она возвращает ноль иначе.
[12:56.400 --> 13:09.400]  Является ли это функцией вычислимой?
[13:09.400 --> 13:24.400]  Кто как считает? Нет? Так, другие мнения будут? Вычислима функция?
[13:24.400 --> 13:32.400]  Кто считает, что она вычислима и готова доказать?
[13:32.400 --> 13:43.400]  Кто считает, что она не вычислима и готова доказать? Пожалуйста.
[13:43.400 --> 13:54.400]  Почему не существует? Вот алгоритм, который выдаёт константу 1, он выдаёт какой-то из этих значений.
[13:54.400 --> 14:03.400]  Проверить-то не будет? Нет, проверить, конечно, потруднее.
[14:03.400 --> 14:10.400]  Но вопрос в чём? Существует ли алгоритм, который вычисляет эту функцию? Ответ – да.
[14:10.400 --> 14:21.400]  Это легко доказать и не требует никаких теологических или философских аргументов.
[14:21.400 --> 14:32.400]  Это доказывается элементарно-математически. Смотрите, для любого x f от x равно единице.
[14:32.400 --> 14:41.400]  Или для любого x f от x равно нулю. Согласны?
[14:41.400 --> 14:48.400]  Есть ли наша функция константа 1? Есть ли алгоритм, который её вычисляет?
[14:48.400 --> 14:55.400]  Конечно, есть. Мы можем на нашем воображаемом си её написать.
[14:59.400 --> 15:02.400]  Вот. Но аналогично с нулем.
[15:02.400 --> 15:10.400]  Значит, в таком случае f вычислима, если она всегда принимает значение 1.
[15:10.400 --> 15:16.400]  Но если она всегда принимает значение 0, она тоже вычислима.
[15:16.400 --> 15:22.400]  Логика f вычислима.
[15:22.400 --> 15:28.400]  В чём здесь засада? В том, что непонятно, какая из возможностей верна.
[15:28.400 --> 15:35.400]  Откуда мы взяли эту дизъюнцию? Кто задавал вопрос про законно исключённого третьего, тем привет.
[15:35.400 --> 15:41.400]  Какая дизъюнция имеет место в общем в силу законно исключённого третьего?
[15:41.400 --> 15:49.400]  Доказать какой-либо из дизъюндов мы вряд ли можем.
[15:49.400 --> 15:55.400]  Но по закону исключённого третьего дизъюнция должна быть верна.
[15:55.400 --> 15:59.400]  То есть надо тонко прочувствовать эту проблематику.
[15:59.400 --> 16:04.400]  Вычислимая функция это такая, для которой есть вычисляющий алгоритм.
[16:04.400 --> 16:08.400]  Но это не означает обязательно, что мы можем его предъявить.
[16:08.400 --> 16:13.400]  То есть мы видим, что есть два тривиальных алгоритма.
[16:13.400 --> 16:17.400]  Один из них обязательно вычисляет эту функцию.
[16:17.400 --> 16:22.400]  А какой мы не знаем? Понятно это?
[16:22.400 --> 16:27.400]  Вот это очень важно осознавать. Масса задач основана на этой мысли.
[16:27.400 --> 16:33.400]  То есть речь не идёт о том, чтобы обязательно предъявить алгоритм.
[16:33.400 --> 16:38.400]  А только о том, что он обязан существовать.
[16:38.400 --> 16:43.400]  Так, хорошо. Обратите на это, пожалуйста, внимание.
[16:43.400 --> 16:47.400]  Это многих путает и сбивает с толком.
[16:47.400 --> 16:53.400]  Так, что такое? Вот с функциями, я надеюсь, понятно.
[16:53.400 --> 16:58.400]  Но кроме, по сути дела, вычислимая функция это функцию,
[16:58.400 --> 17:04.400]  которая есть достаточно простое описание алгоритм.
[17:04.400 --> 17:09.400]  Бывают ли не вычислимые функции?
[17:09.400 --> 17:16.400]  Проще всего мы построим явный пример не вычислимой функции,
[17:16.400 --> 17:19.400]  исходя из некоторых других соображений.
[17:19.400 --> 17:23.400]  Но сейчас мы докажем, что бывают не вычислимые функции.
[17:23.400 --> 17:27.400]  Что такое алгоритм? Опять обратимся к неформальной модели.
[17:27.400 --> 17:31.400]  Вот программа НАСИ, это что такое?
[17:35.400 --> 17:40.400]  Программа НАСИ, это что такое с формальной точки зрения?
[17:40.400 --> 17:43.400]  Последовательность байтов, правильно?
[17:43.400 --> 17:47.400]  То есть, конечно, ещё эта последовательность в нуле единиц.
[17:47.400 --> 17:50.400]  Слово в конечном алфавите.
[17:50.400 --> 17:53.400]  Давайте вспомним другие языки. Какие вам нравятся?
[17:53.400 --> 18:01.400]  Спитон, Хаскель, Брейнфак, Рифау, О'Кэмел, такого не слышал.
[18:01.400 --> 18:06.400]  Хороший язык, отличный.
[18:06.400 --> 18:09.400]  А там вообще ничего нет, кроме пробельных?
[18:09.400 --> 18:19.400]  Ну тогда, как вообще, там что, унарное кодирование, что ли?
[18:20.400 --> 18:24.400]  А, ну видите, какой богатый синтекс этого языка.
[18:24.400 --> 18:31.400]  Во всяком случае, в таком языке, который хорошо выглядит в терминале,
[18:31.400 --> 18:36.400]  очень удобно читать программу,
[18:36.400 --> 18:43.400]  в таком даже языке программа – это конечное слово конечного алфавита, правильно?
[18:43.400 --> 18:48.400]  В конечном счёте программ не более, чем счёт на много.
[18:48.400 --> 18:53.400]  То есть алгоритм с разумной точки зрения – это то же самое,
[18:53.400 --> 18:59.400]  конечное слово конечного алфавита.
[18:59.400 --> 19:09.400]  Следовательно, алгоритмов не более, чем счёт на много.
[19:09.400 --> 19:13.400]  Согласны?
[19:14.400 --> 19:23.400]  Сколько у нас функций из натуральных в натуральные, кто помнит?
[19:23.400 --> 19:28.400]  От частичных функций, ну никак не меньше, чем тотальных, правильно?
[19:28.400 --> 19:30.400]  Ну на самом деле столько же.
[19:30.400 --> 19:39.400]  То есть это континум, это строго больше, чем счётная мощность, согласны?
[19:39.400 --> 19:50.400]  То есть мы видим, что функций из натуральных в натуральные не счётно много.
[19:50.400 --> 20:01.400]  Следовательно, предполагаю, что каждый алгоритм вычисляет одну или даже не более, чем счётно много функций.
[20:01.400 --> 20:07.400]  Ну скажем, в зависимости от первого аргумента он там разные функции вычисляет.
[20:07.400 --> 20:14.400]  Предполагаю, что каждый алгоритм вычисляет не более, чем счётно много функций.
[20:14.400 --> 20:20.400]  Получается, что алгоритмов на все функции не хватит, согласны?
[20:20.400 --> 20:23.400]  Функций больше, чем алгоритмов.
[20:23.400 --> 20:31.400]  Получается, что существуют функции, на которые алгоритмов не хватит.
[20:33.400 --> 20:37.400]  Итак, не все функции вычислимы, согласны?
[20:37.400 --> 20:42.400]  Интересно знать, а как же обстоит дело с множествами?
[20:42.400 --> 20:47.400]  Итак, вычислимые функции, функции имеющие конечное описание.
[20:47.400 --> 20:55.400]  Давайте поговорим, в каком смысле множества могут иметь конечное описание.
[20:55.400 --> 21:00.400]  Ну самое простое, это когда множество просто само по себе конечное.
[21:00.400 --> 21:08.400]  А вот множество чётных чисел бесконечно, но интуитивно мы понимаем, что оно устроено очень просто.
[21:08.400 --> 21:14.400]  В частности, оно удовлетворяет вот такому вот свойству.
[21:14.400 --> 21:23.400]  Мы скажем, что множество а, и я напишу здесь натуральных чисел, но это могут быть и пары, и тройки, и прочее.
[21:23.400 --> 21:40.400]  Множество а разрешимо тогда и только тогда, но давайте я немножко по-другому это представлю, чтобы поменьше писать на доске.
[21:40.400 --> 21:49.400]  А, ну оно же было. Помните, у нас были характеристические функции? Как мы их обозначали?
[21:49.400 --> 22:02.400]  Множество разрешимо тогда и только тогда, когда его характеристическая функция вычислима.
[22:02.400 --> 22:08.400]  Ну давайте вспомним, что такое характеристическая функция под множество натурального ряда.
[22:08.400 --> 22:16.400]  Она принимает на вход натур числа, выдает нули или единицы, правильно? Как она устроена?
[22:16.400 --> 22:26.400]  Когда она выдает один? Характеристическая, вы же вообще ничего не помните?
[22:26.400 --> 22:38.400]  Если n попало в а, она выдает один, а она выдает ноль, если n не попало в а. Это вообще всюду определенная функция, правильно?
[22:38.400 --> 22:49.400]  У любого множества существует характеристическая функция? Безусловно, но не у любого множества она вычислима.
[22:49.400 --> 22:57.400]  Почему? Сколько характеристических функций? Ой или?
[22:57.400 --> 23:07.400]  Сколько функций из n в двойку? Continuum это строго больше, чем n, правильно?
[23:07.400 --> 23:28.400]  Следовательно, не все характеристические функции вычислимы. Следовательно, существуют неразрешимые под множество n. Понятно это?
[23:28.400 --> 23:36.400]  Итак, разрешимое множество – это множество, у которого характеристическая функция вычислима.
[23:36.400 --> 23:48.400]  Это можно и по-другому представить, а именно следующим образом. Есть алгоритм, который, работая на натуральном входе, всегда останавливается за конечное число шагов.
[23:48.400 --> 24:03.400]  Почему всегда? Потому что функция тотальна и выдает один или ноль. В соответствии с тем, попадает ли у нас наш элемент в а, понятно?
[24:03.400 --> 24:25.400]  Лемма один. Если а конечна, то а разрешима. Почему это так? Если множество заведомо конечное, какой алгоритм его разрешает?
[24:25.400 --> 24:41.400]  Мы можем рассмотреть такой алгоритм. Представьте себе, что наше множество состоит только из числа 1 на n, да?
[24:41.400 --> 24:57.400]  Мы можем написать такой алгоритм для характеристической функции. Вот он принимает на вход число n, и что он возвращает?
[24:57.400 --> 25:19.400]  Он возвращает результат сравнения нашего n со всеми вот этими вот числами. Почему такое возможно?
[25:19.400 --> 25:35.400]  Потому что в ходе алгоритма конструктивные объекты, мы верим, что в разумном языке программирования можно два числа сравнить там и вычислить дезъюнкцию и так далее.
[25:35.400 --> 25:46.400]  Понятно это? С интуитивной точки зрения очевидно, что любое конечное множество разрешимо. Можно просто число сравнить со всеми его элементами.
[25:46.400 --> 25:58.400]  Получится конечное. Чем больше множества, тем длиннее эта программа. Но в принципе она всегда существует. Понятно?
[25:58.400 --> 26:22.400]  Итак, конечное разрешимо. Следующая лемма. Вопросы какие-то? Пожалуйста, если A и B разрешимы, то тогда пересечение A и B, объединение A и B,
[26:22.400 --> 26:34.400]  дополнение A и Декартово произведение A и B тоже разрешимы. Как это доказывается?
[26:34.400 --> 26:50.400]  Но суть в том, что если у нас есть программы для характеристической функции A и для характеристической функции B, мы можем легко представить программу, вычисляющую характеристическую функцию пересечения.
[26:50.400 --> 27:07.400]  Вообще говоря, это зависит от языка программирования, типа того, есть ли там дизъюнкция. Но мы с вами работаем в каком-то интуитивном представлении о разумном языке программирования. Там все это есть. Правильно?
[27:07.400 --> 27:26.400]  Иначе надо уточнять, и мы за деревьями не увидим леса. Мы этого не хотим. Как нам выразить характеристическую функцию пересечения через характеристические функции A и B?
[27:26.400 --> 27:40.400]  Конъюнция или просто перемножить. Это у нас была такая формула. Согласны? Понятно, что это верно?
[27:40.400 --> 28:00.400]  Так, объединение. Ну можно арифметически, а можно взять, например, просто максимум. Мы же умеем в естественном языке сравнивать два значения натуральных.
[28:00.400 --> 28:24.400]  Дополнение. Если мы можем A вычислить для любого N, то мы можем из единицы это значение вычислить и получить то, что нужно. А с декартовым произведением тут у нас уже пары будут, N, M.
[28:24.400 --> 28:48.400]  Что нужно сделать, когда пара N, M принадлежит декартовому произведению? Заметьте, здесь надо уметь из пары достать первую и вторую координаты, но естественно считать, что в разумном языке программирования все это есть. Согласны? Есть ли какие-нибудь вопросы?
[28:48.400 --> 29:08.400]  Но оказывается, кстати, множество четных чисел разрешимо? Или нет? Можете написать программу на C, которая проверяет число начетность?
[29:08.400 --> 29:28.400]  Ну, формально, конечно, в C будет тип int, но можно придумать тип на неограниченной памяти реализуемый, который представляет просто все натуральные числа. Самое простое это взять строки. Они же могут быть сколь угодно длинные.
[29:28.400 --> 29:57.400]  И, например, в двоичном коде или даже унарном, то есть когда число N, это N единиц подряд, представлять наши числа. Так, хорошо, с этим понятно. Но оказывается, нам будет важно более слабое понятие алгоритмического описания нашего множества.
[29:57.400 --> 30:24.400]  Это понятие для вас будет более новым, скорее всего. Множество A, внимание, перечислимо. Множество A перечислимо. Это означает, тут я немножечко напишу много слов, но потом мы дадим и другие определения эквивалентно этому.
[30:24.400 --> 30:48.400]  Если существует алгоритм A красивое, который, работая на пустом входе или каком-то фиксированном, это совершенно неважно, или на любом, от входа там ничего не зависит, который, работая на пустом входе,
[30:48.400 --> 31:15.400]  не останавливается, обратите на это внимание, не останавливается, но выводит все элементы A и только их.
[31:15.400 --> 31:36.400]  Как это можно себе представить? Идея в том, что перечислимое множество можно алгоритмически перечислить, может быть, за бесконечное время, то есть, есть некий алгоритм-генератор, который работает, работает неограниченно долго,
[31:36.400 --> 31:57.400]  время от времени, вовсе не на каждом шаге, а когда ему заблагорассудится, он печатает некие числа, каждый из этих чисел принадлежит A, и обратно, для каждого элемента из A найдется шаг алгоритма, когда он будет напечатан.
[31:57.400 --> 32:17.400]  Понятная идея. Как это можно представить себе? Ну вот, в эпоху, в которой мы живем, сейчас, видите, наступает постепенно киберпанк, так сказать, хай-тек, лоу-лайф, ну все как водится, но мы можем подумать о другом стиле, так сказать, о стимпанке.
[32:17.400 --> 32:45.400]  Ну представьте себе такую коробочку, ручкой медной, типа арифмометра, вы ее крутите, крутите, крутите, каждый оборот это шаг исполнения нашего алгоритма, иногда из этой коробочки выплевываются числа, все они являются элементами A, и для каждого элемента A найдется шаг, когда оно будет выплюнуто, множество, которое мы можем сгенерировать.
[32:45.400 --> 33:09.400]  Вот давайте попробуем интуитивно ответить на такой вопрос. Как нам кажется, из того, что множество перечислимо, следует ли, что оно разрешимо? Если мы можем вот так вот множество генерировать, можем ли мы наперед заданный элемент проверить на то, появится он в выводе нашего генератора перечислителя или нет?
[33:11.400 --> 33:13.400]  Как?
[33:14.400 --> 33:23.400]  Вот дано число A, дано число 18, как узнать, появится оно в выводе генератора или нет?
[33:26.400 --> 33:42.400]  Почему? Потому что если вы запустите генератор, число, если оно появилось, все понятно, а вот оно не появляется, не появляется, не появляется, не появляется, но вы ни на каком шаге не можете гарантировать, что оно не появится в будущем.
[33:44.400 --> 34:10.400]  То есть, что такое перечислимость? Это такая односторонняя разрешимость или полуразрешимость. Можно убедиться в том, что число принадлежит A за конечное время, когда оно появится в выводе, а вот убедиться в том, что A не принадлежит A за конечное время не получится, вообще говоря. Понятно?
[34:11.400 --> 34:17.400]  Перечислимость – совершенно фундаментальное понятие, с ним надо освоиться.
[34:18.400 --> 34:27.400]  Давайте разберемся, как мы его могли бы характеризовать.
[34:28.400 --> 34:46.400]  Ну, лемма 3. Самое простое. Если A разрешимо, то A перечислимо. То есть, гарантирована разрешимость не слабее перечислимости, на самом деле, строго сильнее.
[34:46.400 --> 34:51.400]  Мы построим пример множества перечислимого, но неразрешимого.
[34:52.400 --> 35:04.400]  Так, а почему же разрешимое множество перечислимо? Как написать программу, которая перечисляет разрешимое множество?
[35:04.400 --> 35:14.400]  Правильно. Это бесконечный цикл while. Начнем с нуля.
[35:15.400 --> 35:23.400]  While true. Я не помню есть все true или нет. Если нет, напишите единицу.
[35:23.400 --> 35:37.400]  While true, что мы будем делать? Мы будем делать примерно следующее. Заметьте, A разрешимо, то есть, характеристическая функция за конечное время считается.
[35:37.400 --> 35:55.400]  Если характеристическая функция вернула нам один, то что? То надо вот это число, только не N, а K. Надо число K напечатать. Согласны?
[35:55.400 --> 36:13.400]  И перейти к следующему числу. Это бесконечный цикл, правильно? Он тестирует все натуральные, и для тех, которые принадлежат, он их выводит.
[36:13.400 --> 36:23.400]  Понятно это? Итак, из разрешимости следует перечислимость. Обратное, как мы увидим, неверно.
[36:23.400 --> 36:44.400]  Любопытно понять, как перечислимость относится к теоретико-множественным операциям.
[36:44.400 --> 37:05.400]  Давайте посмотрим. Отношения ее чуть более хитрые. Если A и B перечислимы, то мы можем утверждать, что пересечение A и B, объединение A и B, заметьте, дополнения нет.
[37:05.400 --> 37:23.400]  Дополнения пропало, потому что она у нас такая односторонняя. Пересечение A и B, объединение A и B, Дикартово произведение A и B, дополнение пропало, зато появилась проекция.
[37:23.400 --> 37:36.400]  Проекция. Сейчас я объясню, что это такое. Все они перечислимы. Что такое проекция? Под проекцией имеется в виду следующее.
[37:36.400 --> 37:57.400]  Я говорил, что все наши результаты имеют место и для наборов натуральных, правильно? Если у меня A это какое-то такое множество наборов, отношения, то что такое IT-проекция A?
[37:57.400 --> 38:14.400]  Ну, это все IT-координаты. Все IT-координаты, то есть такие, что существует x1, xi-1, xi-1 и так далее.
[38:14.400 --> 38:41.400]  А такие, что вот такой набор принадлежит A. Это надо прочувствовать. Понятно, что такое проекция? Все IT-координаты. Ясно? Вы не шокированы?
[38:44.400 --> 39:12.400]  Давайте доказывать теорему. Тоже неформально. Давайте начнем с объединения. Это проще всего. У нас есть два генератора, два перечислителя. Есть перечислитель множества A, есть перечислитель множества B.
[39:12.400 --> 39:41.400]  Как сконструировать из них перечислитель объединения? Что? А пустое множество перечислимо? Думаем, пустое перечислимо. Как устроен генератор пустого множества? Вы его уверен, писали не раз.
[39:42.400 --> 39:59.400]  Это программа, которая зацикливается, ничего не выводит. Было дело? Значит пустое множество перечислимо. Поэтому, если A кажется пустым, а вы будете ждать вывода первого элемента, вы никогда не переключитесь на B.
[39:59.400 --> 40:10.400]  Вот это важно запомнить. Не надо считать элементы. Считать можно только шаги. Что вывод элементов от вас не зависит, а от вас зависит шаги.
[40:10.400 --> 40:31.400]  Итак, если у нас есть перечислители A красивое. A красивое перечисляет A, B красивое перечисляет B. Что мы делаем? Как нам перечислить объединения?
[40:31.400 --> 40:42.400]  Да, можно делать не шаг из A, можно делать один шаг из A и миллион шагов из B. Потом опять один шаг из A и миллион шагов из B.
[40:42.400 --> 40:53.400]  Никакой разницы не будет. Важно лишь обеспечить, чтобы каждый шаг из A и каждый шаг из B были бы проимулированы. Правильно?
[40:53.400 --> 41:11.400]  Будем поочередно делать по шагу в A красивым и в B красивым.
[41:11.400 --> 41:32.400]  Все выдаваемые числа пускаем в общий выход. Понятно, что имеется в виду?
[41:32.400 --> 41:44.400]  Итак, у меня два генератора. Я один прокрутил, другой, один другой, один другой по очереди. Все, что какой-то генератор выводит, я пускаю на выход.
[41:44.400 --> 41:50.400]  Понятно, что все, что выпадет в выход принадлежит либо A, либо B, правильно?
[41:50.400 --> 42:00.400]  Обратно. Допустим, что-то принадлежит объединению. Тогда оно принадлежит либо A, либо B. Ну, допустим, A без ограничений общности.
[42:00.400 --> 42:15.400]  Значит, на каком-то шаге A красивого это число будет напечатано. Но мы-то с вами все шаги A красивого выполним, каждый. Понятно это?
[42:15.400 --> 42:30.400]  Значит, мы напечатаем это число. А как перечислить, например, декартного произведения? Это хитрее. Пересечение тоже поймем как.
[42:30.400 --> 42:34.400]  Ну, давайте с декартом произведением.
[42:39.400 --> 42:44.400]  Идея в том, чтобы запоминать все то, что они выводят.
[42:44.400 --> 43:02.400]  Запоминаем выводы отдельно. Вот у нас A красивая работала и печатала какие-то такие числа, правильно?
[43:03.400 --> 43:13.400]  У нас B красивая работала, печатала какие-то такие числа. Мы их все запоминаем, правильно?
[43:13.400 --> 43:24.400]  На каждом шаге нашего большого перечислителя количество чисел накопленных, оно будет конечным, правильно?
[43:25.400 --> 43:34.400]  Что мы будем делать? Вот у нас сколько-то чисел накопилось.
[43:34.400 --> 43:55.400]  А, Т, Б, Т. Это что такое? Это числа, накопленные к этому шагу вот этого вот большого перечислителя.
[43:55.400 --> 44:06.400]  Понятная идея? Что мы будем делать после каждого шага? Хотя это неэффективно, но не важно.
[44:06.400 --> 44:16.400]  После каждого шага мы можем делать, ну давайте к этому шагу A красивая лучше. Их будем считать.
[44:16.400 --> 44:28.400]  Что мы будем делать, сделав очередной шаг? А очень просто. Мы будем выводить дикартовое произведение вот этих вот множеств.
[44:28.400 --> 44:46.400]  Оно, разумеется, конечное. Понятно, что произошло? Я повторю еще раз. Мы теперь дергаем две ручки.
[44:46.400 --> 44:57.400]  Попеременно. Все, что вывел первый перечислитель, запоминаем в один буфер. То, что вывел второй, запоминаем в другой.
[44:57.400 --> 45:08.400]  И каждый раз мы печатаем дикартовое произведение двух конечных множеств. До сих пор накопленных элементов.
[45:08.400 --> 45:23.400]  Понятно, что это можно сделать за конечное время? Напечатали, делаем следующий шаг. Оптимизировать что-либо тут не имеет смысла, потому что это алгоритм в принципе бесконечный.
[45:23.400 --> 45:36.400]  Не останавливающийся. Как доказать, что любое число, любая пара из дикартового произведения, когда-нибудь будет напечатана?
[45:36.400 --> 45:49.400]  Но возьмем произвольную пару. Она состоит из элементов А и В, правильно? А появится на каком-нибудь К там шаге перечислителя красивое.
[45:49.400 --> 46:09.400]  В появится на каком-то М там шаге. Возьмем максимум из этих двух значений. Оба шага будут проимулированы, то есть в какой-то момент наши числа будут и в накопителе для А, и в накопителе для В.
[46:09.400 --> 46:21.400]  После этого их пара обязательно будет напечатана. Поднимите руку, кому ясно, как это работает. Всем что ли? А вам?
[46:21.400 --> 46:32.400]  А как надо изменить эту конструкцию для перечисления пересечения вместо дикартового произведения?
[46:32.400 --> 46:49.400]  Да. А какие проблемы? А где-то написано, что каждое надо выводить однократно? Не запрещено разрешено. Как изменить конструкцию для пересечения?
[46:49.400 --> 47:14.400]  Пересечение, конечно, просто смотреть на те элементы среди выведенных, которые оказались общими. Понятно это? К вопросу о повторах. Общий факт, если есть перечислитель произвольный, то есть и перечислитель, который перечисляет тоже множество без повторов. Как это доказать?
[47:14.400 --> 47:28.400]  Будем запоминать все выведенные элементы. Если какой-то элемент уже был выведен, мы его второй раз не выводим. Понятно это?
[47:28.400 --> 47:47.400]  Оптимизировать не имеет смысла в принципе. Это только усложнит доказательства того, что это корректно работает.
[47:47.400 --> 48:03.400]  Конечно, мы можем обновлять только когда новый элемент появляется, испаривать его со старыми СБ, безусловно. Но смысла в этом нет. Это чисто теоретические алгоритмы. Понятна идея?
[48:03.400 --> 48:23.400]  Так, с этим разобрались. А как проектор перечислить? Допустим, перечислимо какое-нибудь множество троек. Как нам перечислить множество их вторых координат? Это очень просто. Что нужно делать?
[48:23.400 --> 48:39.400]  В каждой тройке стирать все координаты, кроме второй. Тройка появилась, мы выводим только вторую координату. Понятно это? Точно это ясно?
[48:39.400 --> 48:54.400]  Проекция это множество. А что вы называете упорядоченным множеством? Почему оно упорядоченное? А состоит из наборов, но само они упорядоченные.
[48:54.400 --> 49:18.400]  Да, это ИТ-координата. В наборе-то координата упорядоченная, но мы считаем, что у нас А состоит из упорядоченных каких-то Н. Но само они упорядоченные, упорядоченные Нки.
[49:18.400 --> 49:39.400]  Каждый Н-ка это упорядоченный набор. Не понятно, что такое неупорядоченное множество упорядоченных пар? Вы не верите, что можно ИТ-координату узнать?
[49:39.400 --> 49:51.400]  Ну каждый перечислитель множество упорядочивает каким-то образом, но нам все равно в каком порядке они...
[49:51.400 --> 50:15.400]  Так, кто еще не понял, что значит вывести ИТ-координату из набора? Что все остальные поняли? Тогда вам задание. Напишите на оси алгоритм, который генерирует какое-то множество наборов и выводит из них третью координату.
[50:15.400 --> 50:25.400]  Кто упорядочен? Элементы набора упорядочены, но только это вам и требуется. Еще какие вопросы?
[50:25.400 --> 50:31.400]  Почему мы в определении ИТ-координату множество говорим, что оно играет по значению натуральных?
[50:31.400 --> 50:49.400]  Ну мы обобщаем натуральных или каких-нибудь наборов натуральных? Я же сказал, что все эти результаты имеют место в более широком спектре случаев. Понятно это? Так, хорошо.
[50:49.400 --> 51:09.400]  Существуют ли неперечислимые множества, как вы считаете? Почему? По-моему такое же рассуждение, как в прошлый раз.
[51:09.400 --> 51:29.400]  Алгоритмов перечислителей сколько? Четно много. А сколько под множество натурального ряда? Континул значит, на какое-нибудь под множество обязательно не хватит. Понятно? Так, хорошо.
[51:29.400 --> 51:47.400]  Теперь мы докажем еще несколько теорем, характеризующих перечислимые множества. Самый важный из них является так называемая теорема о графике.
[51:47.400 --> 52:03.400]  Что такое график функций? График функций это по сути дела сама функция, как множество пар. Больше ничего. Понятна идея?
[52:03.400 --> 52:21.400]  Теорема 6 о графике. Это очень важная теорема. Обратите внимание на то, как мы ее докажем. Для любой функции имеет место следующее.
[52:21.400 --> 52:47.400]  Функция вычислима тогда и только тогда, когда эта функция как множество пар перечислима. Функция вычислима тогда и только тогда, когда ее график перечислим.
[52:47.400 --> 53:07.400]  Понятны утверждения? Понятно, что график функции? Какой графику нигде не определенной функции? Пустой. Какой графику константы 1 определенных натуральных числах?
[53:07.400 --> 53:25.400]  Какое множество? Н умножить на? Понятно, да? Оказывается, функция вычислима тогда и только тогда, когда ее график перечислим.
[53:25.400 --> 53:45.400]  Перечислим в одну сторону. Более простое. Пусть Ф перечислимо.
[53:45.400 --> 54:13.400]  Строим алгоритм Ф красивая для вычисления Ф. Как же этот алгоритм работает? Что за алгоритм? Вот он принимает на вход какой-то х и он должен посчитать его значение, правильно?
[54:13.400 --> 54:38.400]  Если оно есть. А если нет, зациклится. Давайте отметим, что нам дано. У нас есть перечислитель вот этого графика, правильно? У нас есть перечислитель А красивая.
[54:38.400 --> 54:48.400]  Что мы будем делать? Мы будем делать следующее.
[54:48.400 --> 55:13.400]  Запустим бесконечный цикл. Ну даже, даже давайте я словами напишу. Будем делать шаги вот этого А красивого. А красивое может выдавать пары, правильно?
[55:18.400 --> 55:46.400]  Когда вывелась пара, когда вывелась какая-то пара х' и y', что мы делаем? Вот он update, когда появилась пара, что мы делаем? Мы смотрим первая координата пары, равна ли нашему числу х?
[55:46.400 --> 56:04.400]  Если равна, то что? То мы нашли значение нашей функции. Завершаемся. Согласны? Если нет, ждем следующей пары.
[56:04.400 --> 56:20.400]  Давайте докажем, что такой алгоритм действительно вычисляет функцию f. Помните определение вычислимой функции? Там два случая. Либо функция определена на х, либо нет.
[56:20.400 --> 56:46.400]  Если она определена на х, то у нас в графике функции обязательно есть пара вида x и y. Перечислитель ее когда-нибудь напечатает. Мы распознаем этот момент и выведем вторую координату пары, то есть значение нашей функции. Это всем понятно?
[56:46.400 --> 57:09.400]  Второй случай. Предположим, функция не определена в точке х. Что тогда? Тогда в графике точно нет пары, у которой первая координата х. Значит, эта фигня зациклится, будет работать бесконечно долго.
[57:09.400 --> 57:38.400]  Как и требовалось определением. Поднимите руку, кто понял. Какой вопрос? Смотрите, мы перечисляем график, то есть все пары х вида х, f от х. На вход нам дан некий х. Мы ждем пары, которая начинается с этого х. Если мы дождались, выводим ее вторую координату, это будет значение функции.
[57:39.400 --> 58:01.400]  А если не дождались, что эквивалентно тому, что функция не определена в нашей точке х, то мы зацикливаемся. Как и надо, потому что алгоритм, учисляющий функцию, должен зацикливаться в тех точках, где функция не определена. Понятно это?
[58:01.400 --> 58:16.400]  Итак, в одну сторону мы доказали теорему, а теперь в другую. Здесь более хитрая, но очень-очень важная конструкция.
[58:16.400 --> 58:36.400]  Слушайте, у вас сколько ядер в процессоре? Вот у вас, например. Вот у вас есть компьютер. Сколько ядер? 6. А сколько процессов исполняется одновременно?
[58:36.400 --> 58:49.400]  Процессов там, скорее всего, несколько сотен. Потоков еще там больше. Как так может быть?
[58:49.400 --> 59:05.400]  А как вот на одноядерных процессорах исполнялась многозадачная операционная система Windows 95? Как это происходило, как вы думаете?
[59:05.400 --> 59:21.400]  По очереди. Там есть некий планировщик, который в памяти держит состояние всех процессов и дает поработать одному, другому, третьему в порядке некой очереди. Правильно?
[59:21.400 --> 59:35.400]  Вот и мы сейчас аналогичным образом эмулируем параллельные исполнения. Это простая классическая идея. Что нам дано?
[59:35.400 --> 01:00:01.400]  Есть алгоритм f красивый для функции f. Мы хотим придумать перечислитель для всех пар. Хотим перечислить весь график, все пары, аргумент значения. Согласны?
[01:00:01.400 --> 01:00:16.400]  Что мы будем делать? Слушайте, а множество натуральных перечислимо? А множество пар натуральных? Почему? Вы ж Декартово произведение перечислимых?
[01:00:16.400 --> 01:00:42.400]  Перечислимые. Я даже не буду уточнять детали, как это сделать. А теперь внимание. Как работает наш a? Перечисляем все пары x, k. Все возможные пары натуральных чисел.
[01:00:42.400 --> 01:00:58.400]  Понятно, что такой перечислитель возможен? Кто не верит, на оси напишите. Так, это несложно. Не будет все, конечно, перечислять. Все пары top.
[01:00:58.400 --> 01:01:25.400]  Для каждой пары мы делаем вот что. Это самое главное. Мы пускаем вот этот алгоритм f красивое на входе x на k шагов.
[01:01:25.400 --> 01:01:40.400]  Мы делаем k шагов алгоритма. Интуитивно мы понимаем, что за конечное время можно проимулировать k шагов. Согласны? Это ключевое соображение.
[01:01:40.400 --> 01:02:03.400]  Если f вывел какой-то y, если f вывел y, то мы печатаем пару. Не ретон, потому что мы продолжаем. Это же перечислитель. То мы печатаем пару какую? x, y.
[01:02:03.400 --> 01:02:19.400]  И продолжаем наши итерации. Понятно, что происходит? Мы перебираем все возможные входы и все возможные значения для числа шагов.
[01:02:19.400 --> 01:02:42.400]  Имулируем алгоритм f, алгоритм, считающий функцию f малая, на входе x на k шагов. Если он что-то напечатал, значит функция на входе x посчиталась. Ее значение y мы это значение вместе с x выводим. Понятно?
[01:02:42.400 --> 01:02:54.400]  Понятно, что выводится только пара из функции f. Ну, аргумент значения. Как доказать, что любая такая пара будет выведена?
[01:02:54.400 --> 01:03:13.400]  Ну, предположим, пара x, y принадлежит функции f. Значит, алгоритм f красивый, на входе x этот y за сколько-то шагов вычислит. Существует такое число шагов. Правильно?
[01:03:13.400 --> 01:03:32.400]  Но так как мы перебираем пары, рассматриваем для всех возможных количеств шагов, мы обязательно эту ситуацию найдем, выполним f красивое на достаточное число шагов и y напечатаем. Понятно?
[01:03:32.400 --> 01:03:38.400]  Понятно? Нить рук кому понятно? Че, всем? Молодцы.
[01:03:38.400 --> 01:04:06.400]  Значит, и нам пора закругляться. Теперь несколько простых следствий из теоремы о графике.
[01:04:06.400 --> 01:04:34.400]  Следствие 7. Если f вычислимо, то домен функции f. Помнишь какой домен? Все точки, где она определена. И range функции f перечислимо.
[01:04:34.400 --> 01:04:53.400]  Запоминаем, у вычислимой функции всегда перечислимая область значения и область определения. Как это доказывается? Очень просто.
[01:04:53.400 --> 01:05:10.400]  Смотрите. Что такое домен? Мы сейчас этот домен чисто лебраически выразим. Давайте на картинке. Вот у нас есть график функции f, правильно? Где у нее домен?
[01:05:10.400 --> 01:05:36.400]  Домен это, по сути дела, проекция нашего графика. Домен это проекция графика на первую координату.
[01:05:36.400 --> 01:05:55.400]  А range что такое? Проекция графика на вторую координату. Согласны? А проекция перечислима множество перечислима, а график вычислимой функции перечислим. Понятно?
[01:05:55.400 --> 01:06:09.400]  И небольшое обобщение вот этого, из которого, конечно, следствие 7 тоже следует. Тут чуть труднее будет. Смотрите. Ну сейчас закончим. Следствие 8.
[01:06:09.400 --> 01:06:33.400]  Если функция f вычислима и множество a перечислимо, то образ множества a и прообраз множества a тоже перечислимы.
[01:06:33.400 --> 01:06:47.400]  Запоминаем. Под действием вычислимой функции перечислимое множество переходит в перечислимое. Образ и прообраз перечислимого всегда перечислим.
[01:06:47.400 --> 01:06:58.400]  В частности, что такое домен? Это прообраз множества всех натуральных, правильно? Давайте получим этот результат.
[01:06:58.400 --> 01:07:12.400]  Ну, например, образ, что такое? Опять посмотрим сюда. Вот график наш f, а вот, допустим, множество a. Ну, где будет его образ?
[01:07:12.400 --> 01:07:38.400]  Что нужно сделать? Надо из графика взять не все точки, а какие? Те, у которых первая координата в a, правильно? А потом надо спроецировать это вот сюда, на вторую координату.
[01:07:38.400 --> 01:07:58.400]  Справедливо? То есть что мы делаем? Мы берем наш график и пересекаем его со множеством тех точек, у которых первая координата в a, а вторая где? Где угодно, правильно?
[01:07:58.400 --> 01:08:13.400]  А потом мы берем проекцию всей этой штуки на вторую координату и получится range f. Согласны? Это понятно?
[01:08:13.400 --> 01:08:36.400]  Так как f вычислимо, то вот это множество перечислимо, a перечислимо по условию, n перечислимо, дикартовое произведение перечислимых перечислимо, пересечение перечислимых перечислимо, проекция перечислима перечислима.
[01:08:36.400 --> 01:08:50.400]  А домен как выразить аналогично? Что такое домен? Ой, я глупость пишу, а вы меня не поправляете. Это не range, а образ а.
[01:08:50.400 --> 01:09:11.400]  А что такое прообраз а? Как получить прообраз а? Надо взять график, пересечь его с теми точками, у которых, взять из графиков все те, только те точки, у которых вторая координата в a, правильно?
[01:09:11.400 --> 01:09:23.400]  И потом узнать, какие у этих точек первые координаты. Тут тоже все операции, сохраняющие перечислемость.
[01:09:23.400 --> 01:09:43.400]  Итак, образ и прообраз перечислимого множества под действием вычислимой функции перечислимо. Мы с вами доказали два следствия из очень важной теоремы, которые следует хорошенько запомнить.
[01:09:43.400 --> 01:10:12.400]  Функции вычислима тогда и только тогда, когда ее график перечислим. Есть еще несколько результатов, которые нам нужны, не знаю как там на семинаре, наверное на семинаре эти результаты придется сформулировать, на следующей лекции мы их докажем и продвинемся, я надеюсь, дальше.
[01:10:12.400 --> 01:10:35.400]  Есть ли вопросы? У нас есть конспект по вычислимости, вы его можете почитать. Есть записи на эту тему, я их тоже выложу, можете их посмотреть. Пожалуйста, постарайтесь все это запомнить и уже начинайте решать задачки, тоже они появятся.
[01:10:35.400 --> 01:10:45.400]  У нас остается, по-моему, две официальные лекции. Я предлагаю сделать три.
[01:10:45.400 --> 01:11:00.400]  Что? Вот, ну мы можем завочно всегда сделать, чтобы не мучиться там. Даже просто я могу запись сделать.
[01:11:00.400 --> 01:11:22.400]  В следующий раз мы закончим характеризовать перечислимость и ведем новую идею универсального алгоритма и докажем знаменитую неразрешимость проблемы остановки, знаменитую теорему. Вот такие дела, благодарю за внимание.
