[00:00.000 --> 00:06.000]  Добрый день.
[00:30.000 --> 00:46.000]  У вас запутались наушники или у вас запуталась цепочка?
[00:46.000 --> 00:49.000]  Что нужно сделать?
[00:49.000 --> 00:59.000]  Нужно ее распутать.
[00:59.000 --> 01:11.000]  Необходимо упорядочить звенья так, чтобы все связи шли только в одну сторону.
[01:11.000 --> 01:34.000]  На этом графе можно положить звено 2, 3, 0, 1, 5, 6, 4.
[01:34.000 --> 01:39.000]  Если таким образом упорядочить вершину вашего графа, то что у нас получится?
[01:39.000 --> 01:44.000]  2, 3, 2, 0, 3, 1, 3, 0, 3, 4.
[01:44.000 --> 01:47.000]  3, 1, 3, 0, 3, 4.
[01:47.000 --> 01:49.000]  Дальше из нуля ничего.
[01:49.000 --> 01:51.000]  1, только 5.
[01:51.000 --> 01:57.000]  И дальше 6, 4.
[01:57.000 --> 02:00.000]  Понятно.
[02:00.000 --> 02:06.000]  Если у вас наушники беспроводные или цепочка, то представьте себе такую ситуацию.
[02:06.000 --> 02:13.000]  У вас есть некоторый набор задач, и все задачи условно разделены по телам.
[02:13.000 --> 02:17.000]  У вас есть задача на то, чтобы применить DFS, задача на то, чтобы применить BFS,
[02:17.000 --> 02:21.000]  есть задача на то, чтобы применить hash таблицу.
[02:21.000 --> 02:23.000]  А есть более сложные задачи.
[02:23.000 --> 02:28.000]  Есть задачи, которые требуют знания и BFS, и DFS одновременно.
[02:28.000 --> 02:32.000]  Есть задачи, которые требуют знания и hash таблицы DFS.
[02:32.000 --> 02:37.000]  Есть, грубо говоря, задачи, которые можно решить, только зная про hash таблицы,
[02:37.000 --> 02:39.000]  и то, как решается вот эта задача.
[02:39.000 --> 02:43.000]  Вопрос. В каком порядке решать все эти задачи и задания?
[02:43.000 --> 02:45.000]  Ну, естественно, по возрастанию сложности.
[02:45.000 --> 02:48.000]  То есть если вы знаете, как решать задачу DFS, и знаете, как решать задачу про BFS,
[02:48.000 --> 02:52.000]  то, скорее всего, вы знаете обе идеи, поэтому вы можете приступать к решению более сложной задачи.
[02:52.000 --> 02:54.000]  И так далее.
[02:54.000 --> 02:56.000]  И мы можем упорядочить все эти вершины.
[02:56.000 --> 03:01.000]  Давайте снова 0, 1, 2, 3, 4, 5.
[03:01.000 --> 03:05.000]  Вот таким образом.
[03:05.000 --> 03:10.000]  То есть есть задача 0, из которой следует задача 3, 4.
[03:10.000 --> 03:13.000]  Есть задача 1, из которой следует задача 4.
[03:13.000 --> 03:17.000]  Есть задача 2, из которой следует задача 3, 5.
[03:17.000 --> 03:22.000]  Ну и есть задача 5, которая следует из задачи 3.
[03:22.000 --> 03:26.000]  Снова упорядочили ровно таким образом, что все ребра идут слева направо.
[03:26.000 --> 03:34.000]  Или сейчас в последнее время очень стали популярны так называемые графы вычислений.
[03:34.000 --> 03:37.000]  Я не знаю, вы на экран слышали про нейросети.
[03:37.000 --> 03:40.000]  Вот нейросети такие сложные функции, которые состоят из большого количества блоков.
[03:40.000 --> 03:43.000]  То есть из большого количества таких вычислительных модулей.
[03:43.000 --> 03:46.000]  Они, собственно, как раз таки устроены так, что, допустим, у вас есть входы.
[03:46.000 --> 03:50.000]  Дальше эти входы могут подаваться в различные более сложные функции.
[03:50.000 --> 03:54.000]  Дальше эти функции могут комбинироваться в более сложные конструкции и так далее.
[03:54.000 --> 03:58.000]  И, соответственно, возникает вопрос, а в каком порядке это все безобразие вычислять?
[03:58.000 --> 04:04.000]  То же самое. Необходимо просто упорядочить так, чтобы когда вы выполняете определенный блок,
[04:04.000 --> 04:07.000]  все предыдущие блоки уже были выполнены. То есть мы этого хотим.
[04:07.000 --> 04:12.000]  Но для этого, соответственно, нужно упорядочить граф таким образом, чтобы все ребра в нем шли слева направо.
[04:12.000 --> 04:17.000]  И вот эта задача упорядочивания графа называется топологической сортировкой.
[04:20.000 --> 04:37.000]  Так, давайте более формально.
[04:37.000 --> 04:59.000]  Пусть задан частичный порядок на вершинах графа.
[04:59.000 --> 05:15.000]  Ну, какой порядок? Порядок такой, что если у вас есть ребро из A в B, то из этого следует, что у вас A меньше, чем B.
[05:15.000 --> 05:20.000]  Ну, ровно как здесь. То есть если у нас есть ребро 2 и 3, то мы предполагаем, что 2 меньше 3.
[05:20.000 --> 05:24.000]  Поэтому в упорядочивании нам хочется, чтобы 2 стояло раньше, чем 3.
[05:24.000 --> 05:43.000]  Ну и задача стоит в том, чтобы упорядочить в соответствии с этим порядком.
[05:43.000 --> 05:55.000]  То есть в некотором смысле нам дано некоторое частично упорядоченное множество, и нам необходимо его отсортировать.
[05:55.000 --> 06:04.000]  Проблема заключается в том, что не между всеми парами вершин вы знаете больше оно или меньше.
[06:04.000 --> 06:20.000]  Ну и понятно, что она никак не связана вообще с основным графом, то есть есть две слабо связанные компоненты.
[06:20.000 --> 06:27.000]  И вот вас спрашивают, сравните число единицу и восьмерку. Мы их сравнить не можем, потому что они никак не связаны никаким порядком.
[06:27.000 --> 06:32.000]  Задача усложняется этим, что не между всеми парами вершин есть на самом деле какая-то связь.
[06:32.000 --> 06:37.000]  Еще более сложная ситуация состоит в том, что у вас граф в некотором смысле разреженный.
[06:37.000 --> 06:46.000]  Он содержит не всю информацию. Вот пример. Вот у вас есть такая цепочка A, B, C, D.
[06:46.000 --> 06:51.000]  При этом вы понимаете, что в этом смысле A меньше B, B меньше чем C, C меньше чем D.
[06:51.000 --> 06:56.000]  Ну и так как мы говорим, что это частичный порядок, то в нем выполняется свойство транзитивности.
[06:56.000 --> 07:02.000]  То есть естественно C больше чем A и D больше чем A. Но при этом таких связей в нашем графе нет.
[07:02.000 --> 07:08.000]  То есть если мы обращаемся к паре A и C и нам говорят, что я не знаю какая там связь.
[07:08.000 --> 07:12.000]  То есть A меньше C или C меньше чем A, я не знаю этого. Это может означать две вещи.
[07:12.000 --> 07:19.000]  Либо они никак не связаны как здесь, либо просто мы пропустили вот эту транзитивную связь, хотя на самом деле порядок на них есть.
[07:19.000 --> 07:26.000]  Сложность понятна. Вот и поэтому хотелось бы придумать какой-то алгоритм, который бы работал вот в этих условиях.
[07:26.000 --> 07:31.000]  То есть с одной стороны мы знаем, что на вершинах каким-то образом задан частичный порядок,
[07:31.000 --> 07:37.000]  а с другой стороны мы знаем, что граф наш не совсем полный, но в частности в нем пропущены транзитивные связи.
[07:37.000 --> 07:47.000]  То есть связи вот такого типа пропущены. Понятна постановка, да?
[07:47.000 --> 07:57.000]  Так, окей. Ну и перед тем, как мы придем к обсуждению, как это все можно сделать, такой вопрос.
[07:57.000 --> 08:03.000]  Как вы думаете, любой ли граф можно топологически отсортировать? Какие графы нельзя топологически отсортировать?
[08:03.000 --> 08:31.000]  Да, отлично. Замечание. Задача имеет смысл только для ориентированных ациклических графов.
[08:31.000 --> 08:45.000]  Ну или сокращенно так. Directed acyclic graph. Вот, то есть если у вас в графе есть цикл,
[08:45.000 --> 08:52.000]  давайте вот тут его придумаем какой-нибудь вот такой, то понятное дело, что упорядочить не семерку, не восьмерку друг от друга никак нельзя.
[08:52.000 --> 08:56.000]  То есть неверно, что семерка меньше восьмерки, неверно, что восьмерка меньше семерки.
[08:56.000 --> 09:04.000]  То есть как бы вы не упорядочили, вы получите противоречие. Окей? Вот.
[09:04.000 --> 09:11.000]  Так, ну давайте еще тут напишем, что в терминах, ну тут мы задали топологическую сортировку как упорядочивание
[09:11.000 --> 09:17.000]  некоторого частично упорядоченного множества. Давайте скажем, что в терминах графов, ну так что для понимания,
[09:17.000 --> 09:42.000]  в терминах графа, топологическая сортировка означает упорядочение вершин в массиве так,
[09:42.000 --> 10:07.000]  чтобы все ребра шли слева направо. Ну понятно, да? Шли слева направо.
[10:07.000 --> 10:25.000]  Ну и давайте, я думаю, сразу пойдем к алгоритму. В общем, алгоритм, на самом деле,
[10:25.000 --> 10:30.000]  от топологической сортировки вообще ничем не отличается от обхода DFS. Вот этим образом оказывается,
[10:30.000 --> 10:35.000]  что одного запуска DFS на графе вполне достаточно, чтобы отсортировать все вершины.
[10:35.000 --> 11:00.000]  Вот в том виде, в котором мы хотим. Давайте сразу алгоритм. Алгоритм – это арена.
[11:00.000 --> 11:09.000]  Давайте сначала обсудим идею. Вот, например, здесь. Давайте возьмем произвольную вершину и запустим от нее DFS.
[11:09.000 --> 11:18.000]  Произвольную, допустим, двойку. Запустил от нее DFS. DFS каким-то образом гуляет, гуляет,
[11:18.000 --> 11:25.000]  и в какой-то момент DFS будет некуда идти. Такое очевидно произойдет. В какой вершине это произойдет впервые?
[11:26.000 --> 11:35.000]  На этом графе можно, в общем, в случае.
[11:35.000 --> 11:44.000]  Что еще раз? Да, впервые вы остановитесь в той вершине, у которой исходящая степень 0.
[11:44.000 --> 11:48.000]  То есть вы остановились в какой-то вершине. Если вы в ней остановились, то что это означает?
[11:48.000 --> 11:53.000]  То есть вот вы запустили DFS. Вот у вас серая вершина, вот эта серая вершина, здесь вы остановились.
[11:53.000 --> 11:56.000]  Почему вы в ней остановились? Ну вы могли остановиться по двум причинам.
[11:56.000 --> 12:03.000]  Либо из нее идти некуда. Ну а что значит идти некуда? Ну просто у нее нет никаких ребер, исходящих из нее.
[12:03.000 --> 12:10.000]  Тогда мы ее спокойно, естественно, можем положить в конец списка.
[12:10.000 --> 12:16.000]  Потому что она ничему не будет мешать. У нее нет никаких ребер, поэтому никаких ребер назад идти не будет.
[12:16.000 --> 12:22.000]  Или у нее есть ребра, но все ребра, которые ведут в какие-то вершины, они все заняты.
[12:22.000 --> 12:28.000]  Но по какой причине они в данном случае могут быть заняты? Они серые, да?
[12:28.000 --> 12:33.000]  А мы могли встретить серые вершины? Нет, серые вершины мы встретить не могли. Почему?
[12:33.000 --> 12:37.000]  Потому что у нас граф ациклический. Поэтому мы спокойно можем пятерку положить в конец очереди.
[12:37.000 --> 12:44.000]  Вот, мы ее положили. Ну что мы делаем дальше? Мы положили пятерку и пометили ее черным цветом.
[12:44.000 --> 12:49.000]  Дальше аналогично. Продолжаем поиск. В какой-то момент остановились в вершине.
[12:49.000 --> 12:53.000]  Снова что это означает? Это означает, что либо у нас нет никаких вообще исходящих ребер,
[12:53.000 --> 12:59.000]  тогда снова можно спокойно ее положить в конец очереди. Не в очереди, а в начало списка.
[12:59.000 --> 13:04.000]  Либо из нее есть исходящие ребра, которые ведут в уже посещенные вершины.
[13:04.000 --> 13:09.000]  А какие это могут быть вершины? Либо серые, ну тогда у нас есть цикл, чего не может быть.
[13:09.000 --> 13:13.000]  Либо черные. Но если вершина черная, то она уже в списке.
[13:13.000 --> 13:17.000]  Поэтому если я положу сюда четверку, то у меня ребра будут идти только вправо.
[13:17.000 --> 13:23.000]  Идея понятна? То есть черные вершины, они уже в списке, поэтому у меня ребра будут идти только в них.
[13:23.000 --> 13:29.000]  А остальные вершины я по очереди как раз положу в мою очередь.
[13:29.000 --> 13:40.000]  Идея очень простая. Давайте запустим топ-сорт на графе G.
[13:52.000 --> 13:58.000]  Ну что мы делаем? Во-первых, говорим, что цвета как обычно всех вершин изначально
[14:00.000 --> 14:12.000]  белые. Ну и заводим массив ответов. Изначально пустой.
[14:12.000 --> 14:17.000]  Вот этот массив мы потихоньку будем добавлять в вершины, формируя упорядоченное
[14:17.000 --> 14:25.000]  согласно топологической сортировке. Ну и для каждой вершины из множества вершин,
[14:25.000 --> 14:45.000]  если она белая, запускаем ДФС топ-сорта G и V.
[14:45.000 --> 14:57.000]  Ну а как выглядит ДФС топ-сорта G и V? Давайте я напишу так, что ДФС топ-сорт от G и V
[14:57.000 --> 15:07.000]  Это то же самое, что и обычный ДФС. Нет, давайте нормально напишу там.
[15:07.000 --> 15:16.000]  Заодно исполним.
[15:16.000 --> 15:24.000]  Так, изначально что мы делаем? Мы говорим, что цвет вершины V серый.
[15:24.000 --> 15:34.000]  Дальше, для каждой вершины U среди соседей вершины V, что мы делаем?
[15:34.000 --> 15:45.000]  Проверяем в первую очередь, если мой сосед серый, то что в этом случае происходит?
[15:45.000 --> 15:51.000]  Ну все, панику поднимаем. Мы встретили цикл.
[15:51.000 --> 15:55.000]  Это значит, что топологически сортировать мы наш граф не можем.
[15:55.000 --> 15:59.000]  Помните, в прошлый раз обсуждали критерии цикличности. Если мы встретили серую вершину,
[15:59.000 --> 16:01.000]  то это значит, что в нашем графе есть цикл.
[16:01.000 --> 16:04.000]  А если в нашем графе есть цикл, то топологически сортировать невозможно.
[16:04.000 --> 16:10.000]  Ну просто включим о помощи.
[16:10.000 --> 16:28.000]  Далее, если вершина белая на самом деле, то в этом случае запускаем DFS TopSort JU.
[16:28.000 --> 16:37.000]  Ну и все, после того как цикл закончился, мы помечаем нашу вершину черным цветом
[16:37.000 --> 16:42.000]  и добавляем эту вершину V.
[16:42.000 --> 16:49.000]  И добавляем вершину V в начало списка.
[16:49.000 --> 16:57.000]  Ну, давайте считать, что они как бы... вот эти colors и answer это вот отсюда.
[16:57.000 --> 17:04.000]  Я думаю понятно.
[17:04.000 --> 17:12.000]  Давайте push-front от V.
[17:12.000 --> 17:21.000]  Ну и здесь делаем просто return answer.
[17:21.000 --> 17:25.000]  Здесь можно поступить немного по-другому, то есть делать push-back,
[17:25.000 --> 17:28.000]  а потом вернуть перевернутый массив.
[17:28.000 --> 17:35.000]  Ну давайте считать, что у меня массив позволяет быстро осуществлять вставку в начало.
[17:35.000 --> 17:42.000]  Вот такой алгоритм. То есть просто запускаем DFS и добавляем только одну строчку.
[17:42.000 --> 17:47.000]  После того как закончили обрабатывать вершину, добавляем ее в начало массива.
[17:47.000 --> 17:52.000]  Результирующий массив возвращаем.
[17:52.000 --> 17:56.000]  Ну давайте посмотрим, как он работает.
[17:56.000 --> 18:00.000]  Вот давайте вот этого графа.
[18:00.000 --> 18:03.000]  От него запустим DFS. Ну от какой вершины?
[18:03.000 --> 18:05.000]  Ну, например, давайте от вершины 3.
[18:05.000 --> 18:09.000]  Мы попали в вершину 3, пометили ее серым цветом.
[18:09.000 --> 18:11.000]  Дальше попали, допустим, в вершину 4.
[18:11.000 --> 18:14.000]  И понимаем, что из четверки идти некуда.
[18:14.000 --> 18:23.000]  Значит в этот момент мы завершаем над ней работу и кладем в начало из списка.
[18:23.000 --> 18:27.000]  Далее откатываемся в тройку и из тройку идем, допустим, в единицу.
[18:27.000 --> 18:31.000]  Из единицы идем в пятерку. Из пятерки идем в шестерку.
[18:31.000 --> 18:33.000]  Из шестерки идти некуда.
[18:33.000 --> 18:37.000]  Пометили ее черным цветом, кладем в конец списка.
[18:37.000 --> 18:42.000]  Дальше откатываемся в пятерку, из пятерки идти некуда, кладем в начало.
[18:42.000 --> 18:46.000]  Из единицы снова идти некуда, кладем единицу.
[18:46.000 --> 18:50.000]  Из тройки можно пойти в ноль. Из нуля никуда.
[18:50.000 --> 18:51.000]  Пишем ноль.
[18:51.000 --> 18:54.000]  Дальше возвращаемся в тройку, из тройки теперь снова идти некуда.
[18:54.000 --> 18:56.000]  Завершаем, кладем в тройку.
[18:56.000 --> 18:59.000]  Ну и в конце запускаемся от двойки, из двойки идти некуда.
[18:59.000 --> 19:02.000]  Завершаем работу.
[19:02.000 --> 19:04.000]  Все.
[19:04.000 --> 19:06.000]  Ну и что у нас получилось?
[19:06.000 --> 19:11.000]  2, 3, 2, 0, 3, 0, 3, 1, 3, 4.
[19:11.000 --> 19:14.000]  3, 0, 3, 1, 3, 4.
[19:14.000 --> 19:18.000]  А, ну ровно то, что и мы и делали, да?
[19:18.000 --> 19:21.000]  Окей? Все, никакого мало.
[19:21.000 --> 19:25.000]  Так, теперь давайте обсудим.
[19:25.000 --> 19:29.000]  Что еще раз?
[19:29.000 --> 19:31.000]  Так смотрите, у нас уже...
[19:31.000 --> 19:33.000]  Да, мы запустили от тройки.
[19:33.000 --> 19:35.000]  Спасибо за вопрос.
[19:35.000 --> 19:39.000]  Мы запустились от тройки, и действительно из тройки до двойки мы не могли добраться.
[19:39.000 --> 19:41.000]  Да?
[19:41.000 --> 19:44.000]  Но у нас же весь алгоритм состоит в чем?
[19:44.000 --> 19:46.000]  Мы рассматриваем все вершины,
[19:46.000 --> 19:48.000]  и если вершину мы до этого не посещали,
[19:48.000 --> 19:50.000]  мы вызываем от нее DFS TopSort.
[19:50.000 --> 19:52.000]  То есть изначально мы запустились от тройки,
[19:52.000 --> 19:57.000]  тройка породила все возможные вот эти вот...
[19:57.000 --> 19:59.000]  свои подковерные игры.
[19:59.000 --> 20:04.000]  В общем, мы запустила все DFS от тех вершин, до которых она может дотянуться.
[20:04.000 --> 20:06.000]  Затем мы вышли из вот этого DFS TopSort
[20:06.000 --> 20:08.000]  и перешли на следующую итерацию цикла.
[20:08.000 --> 20:10.000]  И с помощью вот этого EFA нашли первую вершину,
[20:10.000 --> 20:12.000]  точнее нашли, да, нашли очередную вершину,
[20:12.000 --> 20:15.000]  которую мы еще не посетили в рамках предыдущего прохода.
[20:15.000 --> 20:18.000]  Понятно?
[20:18.000 --> 20:21.000]  То есть мы запускаем DFS TopSort от произвольной вершины.
[20:21.000 --> 20:23.000]  Если вот этот DFS TopSort посетил не все вершины,
[20:23.000 --> 20:25.000]  то мы запускаемся заново от какой-либо другой вершины,
[20:25.000 --> 20:27.000]  которая все еще белая.
[20:27.000 --> 20:29.000]  Ну и так далее, пока не обойдем все вершины.
[20:29.000 --> 20:31.000]  Окей?
[20:31.000 --> 20:33.000]  Ну то есть вот этот вот цикл как раз нужен, чтобы обойти
[20:33.000 --> 20:35.000]  во-первых, все компоненты слабой связности,
[20:35.000 --> 20:38.000]  ну а во-вторых, все те вершины, до которых мы раньше не доходили.
[20:44.000 --> 20:46.000]  Так, ну и теперь, почему это работает не на том графе,
[20:46.000 --> 20:48.000]  который я нарисовал, а вообще в любом случае.
[20:52.000 --> 20:54.000]  Теорема.
[20:54.000 --> 20:56.000]  Альгоритм Тарьяна
[20:56.000 --> 20:58.000]  либо
[20:58.000 --> 21:00.000]  корректно
[21:02.000 --> 21:04.000]  определяет
[21:04.000 --> 21:06.000]  наличие цикла.
[21:12.000 --> 21:14.000]  Это первое, что может сделать этот алгоритм.
[21:14.000 --> 21:16.000]  Либо
[21:16.000 --> 21:18.000]  корректно
[21:18.000 --> 21:20.000]  определяет
[21:20.000 --> 21:22.000]  наличие цикла.
[21:24.000 --> 21:26.000]  Либо
[21:26.000 --> 21:28.000]  корректно
[21:30.000 --> 21:32.000]  строит
[21:34.000 --> 21:36.000]  топологическую сортировку.
[21:42.000 --> 21:44.000]  Это два.
[21:46.000 --> 21:48.000]  Откуда следует первое утверждение?
[21:54.000 --> 21:56.000]  Он скорее следует
[21:56.000 --> 21:58.000]  из критерии ацикличности.
[21:58.000 --> 22:00.000]  А не из ИФА.
[22:00.000 --> 22:02.000]  Ну то есть вот этот алгоритм
[22:02.000 --> 22:04.000]  да, вот этот вот алгоритм,
[22:04.000 --> 22:06.000]  то есть если забыть вообще про этанцию,
[22:06.000 --> 22:08.000]  он дословно повторяет алгоритм поиска циклов.
[22:08.000 --> 22:10.000]  Но мы в прошлый раз оказали, что циклы у нас
[22:10.000 --> 22:12.000]  ищутся корректно.
[22:12.000 --> 22:14.000]  Поэтому этот первый случай просто следует
[22:16.000 --> 22:18.000]  из критерии
[22:18.000 --> 22:20.000]  ацикличности.
[22:24.000 --> 22:26.000]  Так, теперь два.
[22:30.000 --> 22:32.000]  Давайте по индукции докажем.
[22:32.000 --> 22:34.000]  Изначально у нас массив пустой,
[22:34.000 --> 22:36.000]  в нем все корректно.
[22:36.000 --> 22:38.000]  Изначально
[22:42.000 --> 22:44.000]  массив
[22:46.000 --> 22:48.000]  корректен.
[22:48.000 --> 22:50.000]  Корректен.
[22:56.000 --> 22:58.000]  Рассмотрим
[22:58.000 --> 23:00.000]  добавление
[23:02.000 --> 23:04.000]  вершины В в массив.
[23:10.000 --> 23:12.000]  Допустим, в какой-то момент мы добавили очередную
[23:12.000 --> 23:14.000]  вершину В. То есть у нас есть какой-то
[23:14.000 --> 23:16.000]  построенный массив.
[23:16.000 --> 23:18.000]  То есть тут есть какие-то вершины.
[23:18.000 --> 23:20.000]  И на очередном шаге
[23:20.000 --> 23:22.000]  добавили вершину В.
[23:22.000 --> 23:24.000]  Сначала.
[23:26.000 --> 23:28.000]  Добавили вершины В в массив.
[23:28.000 --> 23:30.000]  Что было до этого?
[23:30.000 --> 23:32.000]  Вот что произошло
[23:32.000 --> 23:34.000]  до добавления вершины В.
[23:34.000 --> 23:36.000]  До добавления вершины В мы проходили
[23:36.000 --> 23:38.000]  по всем его соседям.
[23:42.000 --> 23:44.000]  До этого
[23:46.000 --> 23:48.000]  мы рассматривали
[23:50.000 --> 23:52.000]  всех
[23:52.000 --> 23:54.000]  соседей В.
[23:58.000 --> 24:00.000]  Что могло произойти?
[24:00.000 --> 24:02.000]  Во-первых, могла произойти грустная ситуация,
[24:02.000 --> 24:04.000]  когда соседей у вершины В вообще не было.
[24:04.000 --> 24:06.000]  Согласно, вот эта итрация
[24:06.000 --> 24:08.000]  этого цикла ни разу не повторилась.
[24:08.000 --> 24:10.000]  Точнее, ни разу мы не вошли внутрь этого цикла.
[24:12.000 --> 24:14.000]  А
[24:14.000 --> 24:16.000]  соседей
[24:16.000 --> 24:18.000]  не было.
[24:18.000 --> 24:20.000]  Не было, в смысле, совсем
[24:20.000 --> 24:22.000]  никаких. Ни черных, ни белых,
[24:22.000 --> 24:24.000]  ни серых.
[24:24.000 --> 24:26.000]  Что из этого следует?
[24:26.000 --> 24:28.000]  Верно ли, что тогда
[24:28.000 --> 24:30.000]  я вполне спокойно могу положить вершину В
[24:30.000 --> 24:32.000]  сюда? Почему?
[24:32.000 --> 24:34.000]  Потому что у меня нет ребер, которые идут
[24:34.000 --> 24:36.000]  справа налево.
[24:36.000 --> 24:38.000]  Раз нет ребер совсем,
[24:38.000 --> 24:40.000]  раз у него нет соседей, то это значит, что
[24:40.000 --> 24:42.000]  ребер, которые будут вести справа налево,
[24:42.000 --> 24:44.000]  нет.
[24:46.000 --> 24:48.000]  Нет.
[24:48.000 --> 24:50.000]  Ребер.
[24:50.000 --> 24:52.000]  Ребер
[24:52.000 --> 24:54.000]  ведущих
[24:54.000 --> 24:56.000]  справа
[24:56.000 --> 24:58.000]  налево.
[24:58.000 --> 25:00.000]  Ну и
[25:00.000 --> 25:02.000]  второй случай.
[25:04.000 --> 25:06.000]  Все соседи уже черные.
[25:08.000 --> 25:10.000]  Белых соседей быть не может, потому что мы их уже
[25:10.000 --> 25:12.000]  обошли. Серых соседей не может быть так,
[25:12.000 --> 25:14.000]  как мы предполагаем, что граф у нас уже
[25:14.000 --> 25:16.000]  ациклический. Значит, все соседи
[25:16.000 --> 25:18.000]  черные. Согласны?
[25:20.000 --> 25:22.000]  Все соседи
[25:24.000 --> 25:26.000]  черные.
[25:26.000 --> 25:28.000]  А если все соседи черные,
[25:28.000 --> 25:30.000]  то что это значит?
[25:30.000 --> 25:32.000]  Да, они уже вот здесь.
[25:32.000 --> 25:34.000]  Все соседи уже здесь.
[25:34.000 --> 25:36.000]  Вот он, вот он.
[25:36.000 --> 25:38.000]  Все соседи
[25:40.000 --> 25:42.000]  уже справа.
[25:46.000 --> 25:48.000]  Ну это просто нам означает, что все ребра
[25:48.000 --> 25:50.000]  идут для вершины V слева
[25:50.000 --> 25:52.000]  направо.
[25:52.000 --> 25:54.000]  Ну все.
[26:04.000 --> 26:06.000]  Окей?
[26:06.000 --> 26:08.000]  Ну, наверное.
[26:08.000 --> 26:10.000]  Как?
[26:10.000 --> 26:12.000]  Каким образом?
[26:12.000 --> 26:14.000]  Ну, предположим, что у нас
[26:14.000 --> 26:16.000]  ну, в общем-то, алгоритм
[26:16.000 --> 26:18.000]  не коллектно строит логическую сортировку.
[26:18.000 --> 26:20.000]  То есть, он его
[26:20.000 --> 26:22.000]  так и построил, но у нас какие-то две вершины
[26:22.000 --> 26:24.000]  вспоминаются в неверном порядке.
[26:24.000 --> 26:26.000]  То есть, для них верно, что
[26:26.000 --> 26:28.000]  та вершина, которая слева,
[26:28.000 --> 26:30.000]  она, условно, младшая вершина,
[26:30.000 --> 26:32.000]  которая справа. То есть, вершина справа
[26:32.000 --> 26:34.000]  ведет следовательно вершину слева.
[26:34.000 --> 26:36.000]  Такая ситуация, то есть.
[26:36.000 --> 26:38.000]  Да, ну тогда давайте
[26:38.000 --> 26:40.000]  заметим, что так
[26:40.000 --> 26:42.000]  у нас мы добавляли каждую вершину V
[26:42.000 --> 26:44.000]  ровно в тот момент, когда
[26:44.000 --> 26:46.000]  у нее не было ребра, которые
[26:46.000 --> 26:48.000]  исходят в другую вершину.
[26:48.000 --> 26:50.000]  Значит, вершина
[26:50.000 --> 26:52.000]  у нас каким-то образом
[26:52.000 --> 26:54.000]  уже разводит.
[26:54.000 --> 26:56.000]  Или уже добавлен.
[27:00.000 --> 27:02.000]  Ну, кажется, что это ровно то же самое, что я тут
[27:02.000 --> 27:04.000]  показывал. Ну, то есть,
[27:04.000 --> 27:06.000]  можно так. А тут противоречие с тем,
[27:06.000 --> 27:08.000]  что U была добавлена
[27:08.000 --> 27:10.000]  позже, чем вершина V.
[27:10.000 --> 27:12.000]  Хотя во время вызова V
[27:12.000 --> 27:14.000]  мы вызывали U. И поэтому она должна была
[27:14.000 --> 27:16.000]  оказаться раньше. Примерно то же самое здесь
[27:16.000 --> 27:18.000]  и написано. Если вам так удобнее,
[27:18.000 --> 27:20.000]  то можно так.
[27:20.000 --> 27:22.000]  Еще вопросы?
[27:26.000 --> 27:28.000]  Окей.
[27:28.000 --> 27:30.000]  Ага.
[27:30.000 --> 27:32.000]  На этом удивительно,
[27:32.000 --> 27:34.000]  но с топологической сортировкой пока все.
[27:36.000 --> 27:38.000]  Простая задача, простое решение.
[27:38.000 --> 27:40.000]  Теперь давайте
[27:40.000 --> 27:42.000]  как и заявлялось
[27:42.000 --> 27:44.000]  на прошлой лекции, будем рассматривать
[27:44.000 --> 27:46.000]  компоненты сильной связанности.
[27:50.000 --> 27:52.000]  Ну и сильно про топологическую сортировку
[27:52.000 --> 27:54.000]  не забывайте, она нам еще сегодня понадобится.
[27:54.000 --> 27:56.000]  Вот.
[27:56.000 --> 27:58.000]  Компоненты сильные.
[28:06.000 --> 28:08.000]  Да.
[28:08.000 --> 28:10.000]  Отлично, да.
[28:10.000 --> 28:12.000]  Вот давайте кто-нибудь будет в этой аудитории отвечать
[28:12.000 --> 28:14.000]  за асимптотику алгоритмов.
[28:14.000 --> 28:16.000]  Кто-то будет дико любопытный.
[28:16.000 --> 28:18.000]  Все, вот кто-нибудь.
[28:18.000 --> 28:20.000]  Выберите себя. Да, отлично.
[28:20.000 --> 28:22.000]  Ну, асимптотика, на самом деле,
[28:22.000 --> 28:24.000]  очень очевидная. Ну, то есть мы в прошлый раз
[28:24.000 --> 28:26.000]  анализировали DFS.
[28:26.000 --> 28:28.000]  DFS работал, ну, если мы использовали списки смежности,
[28:28.000 --> 28:30.000]  то за V плюс E.
[28:30.000 --> 28:32.000]  Соответственно, так как здесь мы ничего, кроме DFS,
[28:32.000 --> 28:34.000]  по сути, не делаем, то асимптотика
[28:34.000 --> 28:36.000]  от V плюс E.
[28:38.000 --> 28:40.000]  Время точно совпадает
[28:40.000 --> 28:42.000]  со временем работы DFS.
[28:42.000 --> 28:44.000]  Время работы DFS
[28:44.000 --> 28:46.000]  от V плюс E.
[28:46.000 --> 28:48.000]  То есть, по сути, залинейное
[28:48.000 --> 28:50.000]  от размера графа время
[28:50.000 --> 28:52.000]  вы создаете топологическую сортировку.
[28:52.000 --> 28:54.000]  Тут еще, кстати, может возникнуть
[28:54.000 --> 28:56.000]  вопрос, а можно ли, с помощью grammar,
[28:56.000 --> 28:58.000]  сортировать, скажем, обычные
[28:58.000 --> 29:00.000]  числа, ну, то есть выполнять
[29:00.000 --> 29:02.000]  обычную сортировку. Что это значит?
[29:02.000 --> 29:04.000]  Это значит, что вы просто-напросто строите полный граф,
[29:04.000 --> 29:06.000]  то есть, вам дано множество чисел и вы на всем
[29:06.000 --> 29:08.000]  множестве чисел строите полный граф.
[29:08.000 --> 29:10.000]  То есть, между каждой парой вершин проводите какой-либо реброн.
[29:10.000 --> 29:12.000]  Допустим, один меньше двойки,
[29:12.000 --> 29:14.000]  двойка меньше десятки и так далее.
[29:14.000 --> 29:16.000]  Но, на самом деле,
[29:16.000 --> 29:18.000]  тогда это все вырождается, по сути, в сортировку выбора.
[29:18.000 --> 29:23.880]  если вы посмотрите, то по сути это сортировка выбором. То есть вы ищете самую большую вершину,
[29:23.880 --> 29:32.000]  вершину с точки зрения порядка наибольшую, кладете ее в начало, потом ищете следующую по величине,
[29:32.000 --> 29:38.000]  кладете в начало и так далее. И это все вырождается, секунду, в асимптотику o от v квадрат.
[29:38.000 --> 29:41.000]  Потому что общее число ребер порядка v квадрат.
[29:41.000 --> 29:50.000]  А если мы проведем ребра из 2 в единичку, то есть e будет v, а не v квадрат,
[29:50.000 --> 29:53.000]  тогда у нас получится сортировка 2 в единичку.
[29:53.000 --> 29:58.000]  Да, но тогда, смотрите, в этом случае, нет, у вас другая проблема возникает.
[29:58.000 --> 30:03.000]  У вас неупорядочный граф, но вот эти вот ребра вам нужно каким-то образом построить.
[30:03.000 --> 30:08.000]  А для этого вам нужно определить, что 0 это минимальное число, единица это следующее,
[30:08.000 --> 30:12.000]  то есть вам в любом случае придется выполнить какую-то сортировку.
[30:12.000 --> 30:15.000]  Поэтому теорию вы не обманете.
[30:15.000 --> 30:21.000]  Компоненты сильной связности. В прошлый раз мы обсуждали, что такое компоненты сильной связности.
[30:21.000 --> 30:26.000]  Давайте устно напомню. Компоненты сильной связности в ориентированных графах это такие компоненты,
[30:26.000 --> 30:32.000]  то есть такой наибольший подграф, в котором из любой вершины можно добраться до любой другой.
[30:32.000 --> 30:39.000]  Самый простой случай – это треугольник.
[30:39.000 --> 30:42.000]  Вот это компоненты сильной связности, из любой вершины можно добраться до любой другой.
[30:42.000 --> 30:49.000]  Это не компоненты сильной связности. Из этой вершины до этой можно добраться, обратно нельзя.
[30:49.000 --> 31:00.000]  Давайте ведем такое понятие, как конденсация графа.
[31:00.000 --> 31:05.000]  Конденсации ор-графа.
[31:05.000 --> 31:20.000]  Ор-графа G называется граф G SCC.
[31:20.000 --> 31:38.000]  SCC – это аббревиатура от strongly connected points.
[31:38.000 --> 32:04.000]  Называется граф G SCC, в котором вершины – это компоненты сильной связности.
[32:04.000 --> 32:30.000]  А ребро проводится, если в исходном графе есть ребро из одной компоненты в другую.
[32:30.000 --> 32:36.000]  Что это значит? Давайте нарисуем конденсацию графа.
[32:36.000 --> 32:51.000]  Есть треугольник, есть какой-то такой цикл, есть что-то такое.
[32:51.000 --> 32:56.000]  Какой-то такой граф. Давайте сначала выделим компоненты сильной связности.
[32:56.000 --> 33:11.000]  Что тут? Какие тут компоненты? Вот компоненты, вот компоненты, вот компоненты и вот компоненты.
[33:11.000 --> 33:15.000]  Да, компоненты сильной связности, как я сказал, это максимальное приключение.
[33:15.000 --> 33:21.000]  Ну и действительно, вот это вот множество никак нельзя расширить никакой другой вершиной так, чтобы сильная связность сохранилась.
[33:21.000 --> 33:25.000]  То же самое с этой компонентой, с этой, с этой. Понятно, да?
[33:25.000 --> 33:33.000]  В некотором смысле я разбил граф на такие мощные куски, внутри которых я могу свободно передвигаться.
[33:33.000 --> 33:46.000]  Теперь давайте я представлю, что вот эти вот красные кружочки, это вершины графа, которые я сейчас строю, то есть конденсация.
[33:46.000 --> 33:51.000]  И ребра между компонентами я буду проводить, если у меня есть ребро из соответствующей компоненты в другую компоненту.
[33:51.000 --> 33:55.000]  То есть вот здесь у меня есть ребро между этими компонентами, которое ведет отсюда сюда.
[33:55.000 --> 34:01.000]  Поэтому я провожу здесь ребро. У меня есть ребро из этой компоненты в эту и из этой в эту.
[34:01.000 --> 34:09.000]  Поэтому я тут провожу ребр. Ну есть ребро из этой компоненты в эту компоненту.
[34:09.000 --> 34:18.000]  То есть таким образом я получаю вот такой граф. Вот так, так, вот так, вот так...
[34:18.000 --> 34:26.000]  Вот это конденсация графа. Вот это обычный граф.
[34:26.000 --> 34:36.000]  Понятно? Может вы скажете, каким свойством у меня всегда обладает граф конденсации?
[34:36.000 --> 34:46.000]  Он не сильно связан, но это правда. Если бы он был сильно связан, тогда у меня и весь граф был бы сильно связан.
[34:46.000 --> 34:52.000]  А какое еще есть свойство интересное? Оцикличен. Это важно.
[34:52.000 --> 35:00.000]  Все понимают, что в графе конденсации не может быть циклов? Нет, не все. Отлично.
[35:00.000 --> 35:07.000]  Допустим, у меня есть цикл. Давайте нарисую. Допустим, у меня есть вот такое ребро.
[35:07.000 --> 35:11.000]  Допустим, вот эти вершины образуют цикл. Что это означает?
[35:11.000 --> 35:21.000]  Это означает, что я внутри этой компоненты могу двигаться как угодно.
[35:21.000 --> 35:25.000]  Ну и плюс я между этими компонентами тоже могу двигаться как угодно. Почему?
[35:25.000 --> 35:31.000]  Потому что отсюда я беру произвольную вершину, добираюсь до вершины, из которой ведет ребро в эту компоненту.
[35:32.000 --> 35:38.000]  И отсюда уже добираюсь, куда мне надо. И соответственно наоборот. Понятно?
[35:38.000 --> 35:48.000]  Если у меня есть две компоненты связанности, то есть есть какой-то путь сюда, есть какой-то путь сюда.
[35:48.000 --> 35:53.000]  И мне нужно построить путь из произвольной вершины отсюда в произвольную вершину сюда.
[35:53.000 --> 36:03.000]  Ну как мне нужно действовать? Давайте я просто доберусь до этой вершины, пройдусь путем до некоторой вершины отсюда и доберусь сюда.
[36:03.000 --> 36:12.000]  Аналогично из этой вершины я смогу добраться до этой вершины. Ну, например, вот так и вот так.
[36:12.000 --> 36:20.000]  То есть если у меня в графе конденсации есть цикл, то это означает, что те вершины, которые образуют цикл, на самом деле сами по себе являются сильной компонентой.
[36:20.000 --> 36:26.000]  То есть я между ними могу спокойно перемещаться. Теперь понятно?
[36:26.000 --> 36:31.000]  Поэтому такой ситуации быть не может.
[36:37.000 --> 36:42.000]  То есть циклов в графе конденсации не бывает.
[36:43.000 --> 36:58.000]  Ну и наша задача на сегодняшнюю лекцию понять, каким образом строить конденсацию графа, ну и каким образом выделять сами компоненты сильной связности.
[36:58.000 --> 37:05.000]  Ну и в прошлый раз, я думаю, мы обсудили, что наивный подход с помощью одного обхода DFS нам не поможет.
[37:05.000 --> 37:11.000]  Ну потому что в зависимости того, с какой вершиной вы начинаете, вы обойдете разное количество компонентов.
[37:11.000 --> 37:18.000]  Ну, допустим, если вам повезло и вы сортовали с этой вершины, то вы обойдете только эту вершину, и она, соответственно, у вас будет в компоненте, ну, образовывая компоненту сильной связности.
[37:18.000 --> 37:21.000]  Но если вы начнете отсюда, то вы обойдете весь граф целиком.
[37:21.000 --> 37:26.000]  Но при этом неверно, что весь граф целиком является компонентой связности, компонентой сильной связности.
[37:28.000 --> 37:30.000]  Хорошо.
[37:31.000 --> 37:38.000]  Перед тем, как мы перейдем к основному алгоритму, давайте накажем одну небольшую лему.
[37:42.000 --> 37:44.000]  Давайте даже как-нибудь озаглавим.
[37:44.000 --> 38:08.000]  Лемма о том, что будет, если забыть проверять ацикличность в орграфе.
[38:08.000 --> 38:16.000]  Что будет, если забыть проверять ацикличность перед топологической сортировкой.
[38:17.000 --> 38:19.000]  Ну, сокращенно.
[38:27.000 --> 38:31.000]  Мы к этой лемме будем обращаться именно так.
[38:32.000 --> 38:50.000]  Ну, то есть, формулировка такая, если запустить топ-сорт без проверки циклов.
[38:56.000 --> 38:58.000]  Что?
[38:58.000 --> 39:03.000]  Нет, ну, смотрите, вот так. Не будет иррора.
[39:03.000 --> 39:09.000]  Вот представьте себе, что вы запустили топологическую сортировку, но убрали вот эту строку.
[39:09.000 --> 39:12.000]  То есть, просто игнорируете серые вершины.
[39:12.000 --> 39:14.000]  Алгоритм же что-то сделает.
[39:14.000 --> 39:17.000]  Более того, он сформирует вам какой-то массив.
[39:17.000 --> 39:20.000]  И вот эта лемма сейчас вам скажет, какой массив вы сформируете.
[39:20.000 --> 39:24.000]  То есть, если вы забыли на самом деле проверить серые вершины, то вы на самом деле не забыли.
[39:24.000 --> 39:26.000]  Вы сделали что умное.
[39:27.000 --> 39:30.000]  Ну, не сейчас, хорошо.
[39:30.000 --> 39:35.000]  Давайте пока вы запомните название леммы, а потом после перерыва продолжим.
[39:35.000 --> 39:37.000]  Продолжим.
[39:37.000 --> 39:39.000]  Немного изменил начало.
[39:39.000 --> 39:42.000]  Пусть запустили топологическую сортировку без проверки циклов.
[39:43.000 --> 39:45.000]  Теперь утверждение.
[39:45.000 --> 40:04.000]  Если есть ребро из компонента сильной связности C в компоненту сильной связности C штрих, то...
[40:04.000 --> 40:07.000]  Ну, то есть, что утверждает лемма.
[40:07.000 --> 40:10.000]  Вот у меня есть какой-то граф ориентированный.
[40:10.000 --> 40:14.000]  Я на нем запустил топсорт и при этом забил на циклы.
[40:14.000 --> 40:18.000]  Допустим, у меня есть компоненты сильной связности одна, есть вторая компонент связности,
[40:18.000 --> 40:20.000]  из одной в другую идет ребро.
[40:20.000 --> 40:24.000]  Пусть это C, а это C штрих.
[40:24.000 --> 40:26.000]  Вот что утверждается тогда.
[40:31.000 --> 40:38.000]  Найдется вершина U, которая принадлежит компоненте сильной связности C.
[40:39.000 --> 40:51.000]  Такая, что в массиве answord она будет лежать.
[40:53.000 --> 41:02.000]  Такая, что идет вершина, которая будет лежать левее всех остальных вершин из C штрих.
[41:02.000 --> 41:14.000]  Левее всех вершин из C штрих.
[41:14.000 --> 41:15.000]  Ну, что это означает?
[41:15.000 --> 41:19.000]  Смотрите, вот есть граф, есть компонент связанности C, есть компонент связанности C штрих.
[41:19.000 --> 41:21.000]  В таком графе я запустил топологическую сортировку.
[41:21.000 --> 41:24.000]  И получил мы какой-то упорядоченный у нее вершин.
[41:24.000 --> 41:25.000]  И вот что утверждается.
[41:25.000 --> 41:30.000]  Найдется вершина U, вот некоторая, которая лежит в C.
[41:30.000 --> 41:37.000]  Такая, что она находится левее вообще всех вершин, которые принадлежат C штрих.
[41:37.000 --> 41:40.000]  Допустим, все вершины C штрих сосредоточены где-то здесь.
[41:40.000 --> 41:42.000]  В какой-то такой области.
[41:42.000 --> 41:48.000]  И обязательно найдется такая вершина U из C, которая будет лежать левее всех остальных.
[41:48.000 --> 41:52.000]  То есть в некотором смысле топологическая сортировка без проверки циклов
[41:52.000 --> 41:55.000]  топологически сортирует граф конденсации.
[41:55.000 --> 41:57.000]  Понятно?
[41:58.000 --> 42:02.000]  То есть, если вы запускаете топологичную сортировку в таком графе,
[42:02.000 --> 42:04.000]  то вы получите такое упорядочение.
[42:04.000 --> 42:08.000]  Сначала у вас будет какая-то вершина из вот этой компоненты,
[42:08.000 --> 42:11.000]  то дальше вы идете, ходите, встретите какую-то вершину из этой компоненты связанности
[42:11.000 --> 42:15.000]  и дальше идете, встретите какую-то вершину из этой компоненты связанности
[42:15.000 --> 42:19.000]  и самое последнее, вы встретите первую вершину из вот этой компоненты связанности.
[42:19.000 --> 42:27.000]  Если бы мы проверяли циклы, то уже на этом шаге мы бы зафэрились.
[42:27.000 --> 42:32.000]  Если мы проверяем циклы, то у нас алгоритм в целом не работает.
[42:32.000 --> 42:34.000]  Он сообщает об ошибке.
[42:34.000 --> 42:39.000]  А если мы на циклы забиваем, то мы запускаем на графе,
[42:39.000 --> 42:41.000]  и он какой-то массив нам строит.
[42:41.000 --> 42:43.000]  И вот я утверждаю, что в таком массиве есть циклы,
[42:43.000 --> 42:45.000]  то есть есть ребра, которые идут справа налево,
[42:45.000 --> 42:51.000]  но при этом существует вершина из С, которая находится левее, чем все вершины из С'.
[42:51.000 --> 42:55.000]  Итак, для любой пары компонент-связи, между которыми есть ребро.
[43:09.000 --> 43:11.000]  Как будем доказывать?
[43:11.000 --> 43:35.000]  Пусть у первая вершина из С, которую нашел топ-сорт.
[43:35.000 --> 43:39.000]  То есть мой топ-сорт как-то гуляет по графу,
[43:39.000 --> 43:41.000]  но в какой-то момент попал в компонент-связи С.
[43:41.000 --> 43:43.000]  И вот это первая вершина, в которую мы попали.
[43:43.000 --> 43:45.000]  Что тогда?
[43:45.000 --> 43:49.000]  Тогда возможны два варианта.
[43:57.000 --> 43:59.000]  Первый вариант.
[43:59.000 --> 44:05.000]  Мы попали в компонент-связи С, и при этом компоненту С' еще не обходили.
[44:05.000 --> 44:17.000]  Т.е. компоненту С' еще не обходили.
[44:17.000 --> 44:21.000]  У меня есть компонента С, у меня есть компонента С' , в которой есть ребро.
[44:21.000 --> 44:23.000]  Вот она, вершина У.
[44:23.000 --> 44:25.000]  И тут, и тут все вершины белые.
[44:25.000 --> 44:29.000]  А что это значит?
[44:29.000 --> 44:35.000]  Так, а что это значит?
[44:35.000 --> 44:47.000]  То есть все вершины из С и С' белые.
[44:47.000 --> 44:53.000]  Что это значит по лемме о белом пути?
[44:53.000 --> 45:01.000]  Да, по лемме о белых путях это значит, что когда я запускаю DFS от U,
[45:01.000 --> 45:05.000]  я посещу все вершины из С' и С.
[45:05.000 --> 45:11.000]  Мне сейчас важно, что я посещу все вершины из С' во время запуска DFS от U.
[45:11.000 --> 45:37.000]  По лемме о белых путях во время DFS от U посещу все вершины из С'.
[45:37.000 --> 45:43.000]  А это в свою очередь что означает?
[45:43.000 --> 45:47.000]  Что все вершины из С' будут лежать правее, чем U.
[45:47.000 --> 45:50.000]  То есть я сначала положу все вершины С' в мой массив,
[45:50.000 --> 45:53.000]  и только потом спустя какое-то время положу вершину U.
[45:53.000 --> 45:59.000]  Потому что с вершины U я заканчиваю позже, чем с вершинами С'.
[45:59.000 --> 46:24.000]  Значит, что все вершины С' будут правее или положены раньше вершины U.
[46:24.000 --> 46:28.000]  Все. В этом случае доказали.
[46:28.000 --> 46:32.000]  Теперь второй случай.
[46:32.000 --> 46:36.000]  Можно?
[46:36.000 --> 46:44.000]  Второй случай.
[46:44.000 --> 46:54.000]  До посещения U посещали С'.
[46:54.000 --> 46:59.000]  Вот у меня есть компоненты С, есть репро из компонента С'.
[46:59.000 --> 47:02.000]  Вот U это вообще первая вершина, в которую я попал, из компонента С'.
[47:02.000 --> 47:12.000]  Но при этом в С' есть вершины, которые я посещал.
[47:12.000 --> 47:21.000]  Верно ли, что это означает, что все вершины в С' уже черные?
[47:21.000 --> 47:27.000]  Все понимают, что все вершины в С' черные.
[47:27.000 --> 47:29.000]  Не очевидно.
[47:29.000 --> 47:36.000]  Если я в какой-то момент попал в компоненту С', то в компоненту С я попасть никак не мог.
[47:36.000 --> 47:54.000]  То есть, когда попал в С', не мог добраться до С'.
[47:54.000 --> 47:59.000]  Так как С' у меня компонент сильной связности, при этом у меня граф конденсации ациклический.
[47:59.000 --> 48:03.000]  То есть, я не мог добраться до С'.
[48:03.000 --> 48:19.000]  Из этого следует они стали черными до посещения С'.
[48:19.000 --> 48:22.000]  То есть, из какой-то вершины С' я запустил поиск.
[48:22.000 --> 48:25.000]  Этот поиск обошел мне все вершины из С'.
[48:25.000 --> 48:27.000]  Обошел, может быть, еще какие-то компоненты.
[48:27.000 --> 48:30.000]  Но я точно знаю, что в вершину С я не добрался.
[48:30.000 --> 48:35.000]  Соответственно, все вот эти вершины стали черными, так и не добравшись вот отсюда.
[48:35.000 --> 48:37.000]  Да?
[48:37.000 --> 48:41.000]  То есть, ни один вызов DFS от С' не мог меня привести сюда.
[48:41.000 --> 48:46.000]  Это значит, что они завершились так и не узнав, что есть какая-то компонента С.
[48:46.000 --> 48:50.000]  Да?
[48:50.000 --> 48:52.000]  Иронно это я написал.
[48:52.000 --> 48:55.000]  Они стали черными до посещения С'.
[48:55.000 --> 49:09.000]  Из этого следует они все правее вершин из С'.
[49:09.000 --> 49:11.000]  Все.
[49:16.000 --> 49:19.000]  То есть, если я посещаю компоненту С' раньше, чем С',
[49:19.000 --> 49:21.000]  то в С попасть не могу.
[49:21.000 --> 49:24.000]  То есть, эта компонента чернеет, и дальше только я посещаю вершину С'.
[49:24.000 --> 49:26.000]  Если я сначала посещал компоненту С',
[49:26.000 --> 49:29.000]  то во время посещения компонента С я обязательно посещу компоненту С'.
[49:29.000 --> 49:34.000]  Но при этом с ней я закончу раньше, чем с вершинами отсюда.
[49:34.000 --> 49:37.000]  Вот и вся соль.
[49:37.000 --> 49:39.000]  Окей?
[49:39.000 --> 49:42.000]  Хорошо.
[49:42.000 --> 49:49.000]  Ну и наконец, давайте попробуем построить алгоритм
[49:49.000 --> 49:55.000]  для выявления компонентов сильной связности.
[49:55.000 --> 49:58.000]  Так.
[49:58.000 --> 50:02.000]  Давайте на каком-нибудь идейном уровне попробуем понять,
[50:02.000 --> 50:05.000]  что нам хочется сделать.
[50:05.000 --> 50:07.000]  Вот смотрите.
[50:07.000 --> 50:10.000]  Вот представьте себе, что нам удалось,
[50:10.000 --> 50:12.000]  представьте себе, что мы откуда-то, ну пока не понятно,
[50:12.000 --> 50:15.000]  откуда знаем конденсацию нашего графа.
[50:15.000 --> 50:18.000]  Вот мы ее откуда-то знаем.
[50:18.000 --> 50:23.000]  И плюс она как-то топологически отсортирована.
[50:23.000 --> 50:26.000]  Вот.
[50:26.000 --> 50:31.000]  Могу ли я как-то посетить вершину, то есть запустить DFS из вот этой компоненты
[50:31.000 --> 50:33.000]  так, чтобы я попал только внутрь вот этой компоненты,
[50:33.000 --> 50:35.000]  то есть я обошел только все вершины из этой компоненты
[50:35.000 --> 50:37.000]  и при этом не попал в другие?
[50:37.000 --> 50:39.000]  Могу ли я это как-то устроить?
[50:39.000 --> 50:41.000]  А если все другие черные?
[50:41.000 --> 50:43.000]  А если не все черные?
[50:43.000 --> 50:45.000]  Вот если я только запустил DFS, все вершины белые,
[50:45.000 --> 50:47.000]  я как-то запускаю DFS от этой вершины,
[50:47.000 --> 50:49.000]  чтобы при этом с целью обойти только вот эти вершины,
[50:49.000 --> 50:51.000]  только вершины из этой компоненты.
[50:51.000 --> 50:53.000]  Нет.
[50:53.000 --> 50:56.000]  Нет. А можно ли как-то граф исправить, чтобы это было возможно?
[50:56.000 --> 51:00.000]  Ну можно, чтобы не шли никакие.
[51:00.000 --> 51:02.000]  Не шли никакие что?
[51:02.000 --> 51:03.000]  Ну чтобы не на какие левы выходили.
[51:03.000 --> 51:06.000]  Так. А как это устроить?
[51:06.000 --> 51:11.000]  Давайте просто поменяем ребра местами, то есть обратим все ребра.
[51:11.000 --> 51:17.000]  Смотрите, давайте я возьму граф и все ребра в нем инвертирую.
[51:17.000 --> 51:21.000]  Это называется транспонирование графа.
[51:21.000 --> 51:38.000]  УВ принадлежит ЕТ, когда ВУ принадлежит Е.
[51:38.000 --> 51:42.000]  Транспонированный граф это такой граф, в котором я поменял направление всех ребр.
[51:42.000 --> 51:47.000]  Представьте себе, что я в моем графе G поменял направление всех ребр.
[51:47.000 --> 51:51.000]  Изменились ли у меня компоненты сильной связности?
[51:51.000 --> 51:55.000]  Нет! Транспонирование графа никак не влияет на компоненты сильной связности.
[51:55.000 --> 52:01.000]  Потому, что я по одному пути добрался от одной вершины до другой, так я могу и по другому пути добраться с помощью переворачивания ребер.
[52:01.000 --> 52:05.000]  То есть на компоненты сильной связности это вообще никак не влияет.
[52:05.000 --> 52:09.000]  А влияет ли это на достижимость в графе конденсации?
[52:09.000 --> 52:14.000]  Влияет, потому что если я теперь стартую с этой вершины и у меня все ребра перевернуты,
[52:14.000 --> 52:17.000]  то я обойду только те вершины, которые мне нужны.
[52:17.000 --> 52:19.000]  Согласны?
[52:19.000 --> 52:23.000]  Теперь, допустим, я обошел все вершины здесь.
[52:23.000 --> 52:28.000]  Дальше я иду, согласно топологической сортировке, в другую компоненту сильной связности.
[52:28.000 --> 52:30.000]  Допустим, вот в эту.
[52:30.000 --> 52:33.000]  Куда я могу из нее добраться?
[52:33.000 --> 52:36.000]  Теоретически я могу добраться по обратному ребру вот сюда.
[52:36.000 --> 52:38.000]  Предполагаем, что это ребро перевернуто.
[52:38.000 --> 52:40.000]  Но эта вершина уже черная.
[52:40.000 --> 52:42.000]  То есть сюда я не доберусь.
[52:42.000 --> 52:46.000]  А сюда я не доберусь, потому что это ребро перевернуто.
[52:46.000 --> 52:48.000]  По глазам вижу, что надо...
[52:48.000 --> 52:52.000]  Давайте по порядку. В чем план?
[52:52.000 --> 52:54.000]  Алгоритм будет называться...
[52:54.000 --> 52:56.000]  Ну как будет называться? Его назвали уже.
[52:56.000 --> 53:01.000]  Алгоритм к сараю.
[53:12.000 --> 53:17.000]  Состоит он из трех простых шагов, которые вам всем уже известны.
[53:17.000 --> 53:19.000]  Первый шаг.
[53:20.000 --> 53:26.000]  Запускаем топсорта G без проверки циклов.
[53:33.000 --> 53:36.000]  Топсорт без проверки циклов.
[53:36.000 --> 53:38.000]  Второй шаг.
[53:38.000 --> 53:40.000]  Транспонируем граф G.
[53:40.000 --> 53:49.000]  Давайте, пока не забыл, сразу буду писать сложность каждого шага.
[53:49.000 --> 53:55.000]  Топологическая сфотография графа G без проверки циклов по-прежнему от V плюс E.
[53:55.000 --> 53:59.000]  Транспонирование графа тоже за V плюс E выполняется.
[53:59.000 --> 54:02.000]  Просто надо пройтись по всем ребрам и поменять их местами.
[54:02.000 --> 54:06.000]  То есть поменять вершины местами.
[54:06.000 --> 54:31.000]  И, наконец, запустить DFS на графе G, точнее на G-транспонированном, в порядке, заданном пунктом 1.
[54:36.000 --> 54:51.000]  Все компоненты, полученные на шаге 3, это компоненты с сильной связностью.
[54:51.000 --> 54:58.000]  Давайте продемонстрирую, как это работает.
[54:58.000 --> 55:01.000]  Давайте тот граф вернем.
[55:07.000 --> 55:15.000]  0, 1, 2, 3, 4, 5.
[55:21.000 --> 55:23.000]  Вот как-то так.
[55:23.000 --> 55:26.000]  Давайте я на нем просто проверну вот всю такую схему.
[55:26.000 --> 55:28.000]  Давайте я стартую.
[55:28.000 --> 55:30.000]  Первый шаг.
[55:30.000 --> 55:33.000]  Запускаю топологическую сортировку на этом всем графе.
[55:33.000 --> 55:36.000]  rocks.
[55:36.000 --> 55:43.000]  Допустим, запускаю с вершины 0, из вершины 0 я иду в вершину 2.
[55:43.000 --> 55:46.000]  Из вершины 0 я иду в вершину 2.
[55:46.000 --> 55:48.000]  Из вершины 2 я иду в вершину 3.
[55:48.000 --> 55:51.000]  Из вершины 3 я иду в вершину 5.
[55:51.000 --> 55:54.000]  Из вершины 5 quantitative, не куда?
[55:54.000 --> 55:55.000]  Кладу в начало.
[55:55.000 --> 55:56.000]  Дальше.
[55:56.000 --> 55:59.000]  Откатываюсь в тройку, из тройки – негуда.
[55:59.000 --> 56:02.000]  Откатываюсь в двойку, из тройки – некуда.
[56:02.000 --> 56:08.200]  Откатываясь в ноль, из нуля могу пойти в единицу, из единицы в четверку.
[56:08.200 --> 56:17.000]  Из четверки возвращаясь обратно в единицу, и из единицы обратно в ноль.
[56:17.000 --> 56:24.600]  Теперь давайте проверим ту лему, которая для любой компонента связанности верна,
[56:24.600 --> 56:30.700]  что если есть ребро, то какая-то вершина находится левее всех остальных.
[56:30.780 --> 56:33.680]  Есть ребро между этой компонентой и этой компонентой.
[56:33.680 --> 56:37.580]  Верно ли, что пятерка находится позже какой-либо из вершин отсюда?
[56:37.580 --> 56:41.880]  Ну верно. Вот есть ноль, а пятерка находится здесь.
[56:41.880 --> 56:48.680]  Вот, дальше, 1-4. но при этом ноль находится левее, чем любая вершина отсюда.
[56:48.680 --> 56:56.300]  Пятерка, точнее, единица находится левее, чем пятерка, то есть все вершины отсюда.
[56:56.300 --> 56:59.300]  Вот. Это первый шаг.
[56:59.300 --> 57:01.300]  Теперь второй шаг.
[57:01.300 --> 57:05.300]  Затем граф ЖТ.
[57:11.300 --> 57:14.300]  Вот так, вот так.
[57:14.300 --> 57:33.300]  0, 2, 3, 1, 4, 5.
[57:33.300 --> 57:37.300]  Вот. Это транспонированный, это обычный граф.
[57:37.300 --> 57:40.300]  Ну и, наконец, третий пункт.
[57:40.300 --> 57:43.300]  Запускаю DFS в соответствии вот с этим порядком.
[57:43.300 --> 57:45.300]  Ну, что это означает?
[57:45.300 --> 57:47.300]  Раньше DFS я выполнял как?
[57:47.300 --> 57:49.300]  Ну, на бум.
[57:54.300 --> 57:58.300]  Да, для каждой вершины, которая еще не посещена, естественно.
[57:58.300 --> 57:59.300]  Что это означает?
[57:59.300 --> 58:02.300]  Это означает, что раньше, когда мы делали DFS,
[58:02.300 --> 58:04.300]  мы обходили вообще в произвольном порядке.
[58:04.300 --> 58:06.300]  То есть здесь нам было неважно, в каком порядке мы обходим вершины.
[58:06.300 --> 58:09.300]  Хоть с нулевой стартуем, хоть с первой, хоть с десятой.
[58:09.300 --> 58:13.300]  А здесь мы вот этот вот обход, вот здесь цикл,
[58:13.300 --> 58:17.300]  начинаем именно в том порядке, в котором заданы все вот эти вот вершины.
[58:17.300 --> 58:19.300]  Ну, то есть что это означает?
[58:19.300 --> 58:21.300]  Обход начинаем с вершины номер 0.
[58:23.300 --> 58:25.300]  Вот отсюда.
[58:27.300 --> 58:32.300]  Что мы сделаем? Что сделает обход при запуске от нуля?
[58:33.300 --> 58:35.300]  Да, он обойдет только вот эти вершины.
[58:35.300 --> 58:37.300]  Согласны?
[58:37.300 --> 58:38.300]  Почему?
[58:38.300 --> 58:41.300]  Как раз-таки потому, что я пытался объяснить до этого.
[58:41.300 --> 58:45.300]  Потому что на первом шаге мы топологически отсортировали все компоненты сильной связности.
[58:47.300 --> 58:50.300]  То есть сначала идет компонент, который принадлежит 0,
[58:50.300 --> 58:52.300]  дальше идет компонент, который принадлежит единицы,
[58:52.300 --> 58:54.300]  дальше идет компонент, который принадлежит пятерки.
[58:54.300 --> 58:56.300]  Отсортировали все компоненты сильной связности.
[58:56.300 --> 59:01.300]  И потом перебираем как раз-таки все вершины в порядке
[59:01.300 --> 59:03.300]  топологической сортировки компонент связности.
[59:03.300 --> 59:06.300]  Но так как мы обратили ребра,
[59:06.300 --> 59:07.300]  то есть как у нас строено топологическая сортировка.
[59:07.300 --> 59:13.600]  все ребра идут слева направо. Но после того, как мы обратили ребра, у нас все
[59:13.600 --> 59:18.840]  ребра стали идти справа налево. То есть нет ни одного ребра, который вышел из одной
[59:18.840 --> 59:24.240]  компоненты связанности слева в компоненту связанности справа. То есть из-за
[59:24.240 --> 59:30.760]  этой компонент связанности мы теперь никуда выйти не можем. Понятно? Вот, поэтому
[59:30.760 --> 59:43.880]  запускаем DFS от нуля, получаем 0, 2, 3. Далее идем. Запускаем DFS от единицы. Единицу
[59:43.880 --> 59:53.680]  мы еще не проходили. Что нам обходит DFS от единицы? Ну, единицу и четверку. Снова, отсюда
[59:53.680 --> 59:56.360]  мы уже сюда не доберемся, то есть другую компонент связанности мы не доберемся.
[59:56.360 --> 59:59.800]  А вот сюда мы не доберемся, потому что всю эту компонент связанности мы уже
[59:59.800 --> 01:00:11.280]  ранее обошли. DFS от единицы обойдет нам единицу и четверку. Дальше, пытаемся запустить DFS от четверки, но четверка уже посещена.
[01:00:11.280 --> 01:00:16.920]  DFS от двойки, двойка уже посещена. DFS от тройки, тройка уже посещена. DFS от пятерки, ну, наконец
[01:00:16.920 --> 01:00:29.320]  находим компонент связанности, который состоит из одной вот этой вершины. Все, магия. Круто? Вот и
[01:00:29.320 --> 01:00:35.000]  все. Ну, основная идея, давайте запомним, в чем стоит основная идея. Это каким-то образом
[01:00:35.000 --> 01:00:42.480]  отсортировать компоненты сильной связанности, а потом поступить хитро. Обратить обратные
[01:00:42.480 --> 01:00:46.840]  ребра и сделать так, чтобы из одной компонент связанности мы не могли добраться ни до одной
[01:00:46.840 --> 01:01:06.880]  другой. То есть мы, грубо говоря, компонент связанности запираем в самой себе. Вот. Так. Вот. Ну и третий пункт,
[01:01:06.880 --> 01:01:16.040]  за сколько работает. Это V плюс E, это V плюс E. Третий пункт, за. Ну, тоже V плюс E. Тут DFS, тут DFS, тут просто
[01:01:16.040 --> 01:01:23.440]  транспонирование графа. Все, то есть за рамки алгоритма DFS мы вообще не выходим последние две
[01:01:23.440 --> 01:01:31.680]  лекции. То есть все за счет DFS. Ну и суммарно, естественно, тоже O от V плюс E. Все, то есть, по сути,
[01:01:31.680 --> 01:01:50.800]  залинейное от размера графа время вы находите все компоненты сильной связанности. Ну и осталось
[01:01:50.800 --> 01:02:11.120]  доказать корректность. О корректности. Ну, алгоритм Косараю.
[01:02:21.680 --> 01:02:42.280]  корректно находит все компоненты сильной связанности. Почему так? Ну, потому что, значит, после первого шага,
[01:02:42.280 --> 01:03:05.960]  что у нас получается? После первого шага по, почему? Ну вот, по вот этой вот штуке. По лемме. О,
[01:03:06.560 --> 01:03:28.800]  вот об этом всем. Что у нас получается? Топологически отсортированы компоненты сильной связанности. Ну,
[01:03:28.800 --> 01:03:33.040]  с точки зрения, что первая вершина из компонентов сильной связанности, то есть если мы возьмем самые
[01:03:33.040 --> 01:03:36.520]  первые вершины из компонентов сильной связанности, то они будут образовывать топологическую сортировку.
[01:03:36.520 --> 01:04:01.360]  Ну, обсуждали. Вот. На шаге 3 запускаем DFS от первой вершины. Какие вершины она обойдет?
[01:04:01.360 --> 01:04:18.400]  Она обойдет все вершины из своей. Давайте ее обозначим STC1.
[01:04:18.400 --> 01:04:41.120]  Но в силу шага 2 не попадет в остальные. Ну, почему? Потому что вот у меня есть массив,
[01:04:41.120 --> 01:04:45.200]  отсортированный в топологическом порядке, и у меня все ребра в исходном графе шли только
[01:04:45.200 --> 01:04:53.000]  вот так. Из-за этой компоненты сильной связанности. Так как я на шаге 2 все ребра обратил, у меня нет
[01:04:53.000 --> 01:04:58.240]  исходящих ребр, то есть все ребра только входящие. Из-за этой компоненты сильной связанности.
[01:04:58.240 --> 01:05:20.640]  Мне попадет в остальные. Вот. Следующая вершина обойдет свою компоненту сильной связанности
[01:05:20.640 --> 01:05:50.440]  ДС2. Не попадет в остальные, так как из шага 2 следует. Нет исходящих ребр.
[01:05:50.440 --> 01:06:06.680]  Ну и плюс нельзя попасть в компоненту сильной связанности 1, потому что она уже пройдена. То есть из
[01:06:06.680 --> 01:06:10.280]  компонента сильной связанности 2, то есть которая здесь, я не буду попасть в те компоненты сильной
[01:06:10.280 --> 01:06:14.480]  связанности, которые находятся правее, потому что у меня ребра инвертированы. И плюс вот в эту компонентную
[01:06:14.480 --> 01:06:23.280]  связанность я не попаду, но потому что я ее уже обошел. Ну все, ну и так далее для любой компонент
[01:06:23.280 --> 01:06:39.520]  сильной связанности. Все. Вот такие дела.
[01:06:39.520 --> 01:07:04.000]  Ну и давайте обсудим еще одно интересное свойство, которое непосредственно вытекает из доказательства
[01:07:04.000 --> 01:07:10.160]  теоремы, но и самого алгоритма. Что вы можете сказать про порядок компонентов связанности, которые мы тут получаем?
[01:07:10.160 --> 01:07:21.600]  Ну вот мы получили компоненты сильной связанности 0, 2, 3, 1, 4 и 5. Да, смотрите. Во-первых, мы выделили
[01:07:21.600 --> 01:07:27.600]  компоненты сильной связанности, это первый шаг, что уже неплохо. А второй момент, когда вы выписываете
[01:07:27.600 --> 01:07:31.760]  все вот эти компоненты сильной связанности, вы их выписываете как раз в порядке топологической сортировки.
[01:07:32.240 --> 01:07:42.240]  То есть у вас вот эти компоненты уже топологически отсортированы в самом результате, понятно?
[01:07:42.240 --> 01:07:47.920]  То есть если у вас перед вами стоит задача, допустим, выделить граф, точнее выделить компоненты
[01:07:47.920 --> 01:07:51.340]  сильной связанности, и все эти компоненты сильной связанности топологически отсортировать, то по сути faced andivedsnob
[01:07:51.340 --> 01:07:55.600]  алгоритм Сарае сразу иерои и то и другое. То есть не нужно отдельно строить граф конденциации,
[01:07:55.600 --> 01:08:00.600]  и строить его топологическую сортировку.
[01:08:00.600 --> 01:08:03.600]  Да, потому что сами компоненты уже топологически отсортированы.
[01:08:03.600 --> 01:08:11.600]  Вот эти компоненты.
[01:08:11.600 --> 01:08:14.600]  То есть вот компонент 0.2.3
[01:08:14.600 --> 01:08:19.600]  она топологически находится раньше, чем компонент 1.4.5.
[01:08:19.600 --> 01:08:22.600]  Сначала выписали вот эту вершину, а вот эту.
[01:08:22.600 --> 01:08:30.600]  И потом эту.
[01:08:30.600 --> 01:08:37.600]  Наверное, на этом все, что касается сильной связности, все.
[01:08:37.600 --> 01:08:42.600]  Есть вопросы?
[01:08:42.600 --> 01:08:47.600]  Раз осталось время, давайте тогда перейдем.
[01:08:47.600 --> 01:08:50.600]  И начнем следующую тему.
[01:08:50.600 --> 01:08:57.600]  Алгоритмы, наверное, не успеем обсудить, но необходимые определения дадим.
[01:08:57.600 --> 01:09:02.600]  Поговорим мы про эйлеровые циклы.
[01:09:02.600 --> 01:09:04.600]  Слышали что-то про них?
[01:09:04.600 --> 01:09:10.600]  Не все.
[01:09:10.600 --> 01:09:19.600]  Эйлеровые графы.
[01:09:19.600 --> 01:09:23.600]  Давайте за оставшийся 10 минут устроим легбез небольшой.
[01:09:23.600 --> 01:09:27.600]  Следующую лекцию начнем с алгоритмов.
[01:09:27.600 --> 01:09:35.600]  Эйлеров путь.
[01:09:35.600 --> 01:10:04.600]  Это путь в графе, проходящий по каждому ребру графа ровно один раз.
[01:10:04.600 --> 01:10:21.600]  Здесь нет эйлеров в пути, давайте где-нибудь придумаем.
[01:10:21.600 --> 01:10:23.600]  В таком графе эйлеров в пути есть.
[01:10:23.600 --> 01:10:30.600]  То есть я могу пройти вот так, вот так, вот так, вот так, вот так, вот так и вот так.
[01:10:30.600 --> 01:10:37.600]  То есть я могу повторяться по вершинам, но примерно по каждому ребру я могу пройтись только один раз.
[01:10:37.600 --> 01:10:49.600]  Граф, в котором есть эйлеров путь, называется полуэйлеров.
[01:10:49.600 --> 01:11:07.600]  Это граф с эйлеровым путем.
[01:11:07.600 --> 01:11:15.600]  Эйлеров цикл.
[01:11:15.600 --> 01:11:30.600]  Просто замкнутый эйлеров путь.
[01:11:30.600 --> 01:11:39.600]  Ну, например, если я возьму этот граф и добавлю в нем вот такое ребро, то я получу эйлеров цикл.
[01:11:39.600 --> 01:11:44.600]  Раз, два, три, четыре, пять, шесть, семь, восемь.
[01:11:44.600 --> 01:11:47.600]  Откуда стартовал, откуда туда и закончил.
[01:11:47.600 --> 01:11:51.600]  То есть весь граф представляет себя один большой реберный цикл.
[01:11:51.600 --> 01:11:56.600]  Эйлеровым графом как раз называется граф, который представим в виде одного эйлерового цикла,
[01:11:56.600 --> 01:12:01.600]  в котором содержится эйлеров цикл.
[01:12:01.600 --> 01:12:21.600]  Эйлеров граф с эйлеровым циклом.
[01:12:21.600 --> 01:12:25.600]  Понятное дело, что не в любом графе есть эйлеров путь и эйлеров граф.
[01:12:25.600 --> 01:12:31.600]  Ну, как минимум, в несвязанном графе, очевидно, таких путей и таких циклов не существует.
[01:12:31.600 --> 01:12:39.600]  Сегодня мы не будем обсуждать, как искать эйлеров путь и эйлеровые циклы в графах, если они существуют.
[01:12:39.600 --> 01:12:44.600]  Давайте сегодня ограничимся тем, что поймем, как вообще понять, если посмотреть на граф,
[01:12:44.600 --> 01:12:49.600]  есть ли в нем эйлеров цикл или нет эйлеров цикла, при этом не строя сам цикл.
[01:12:49.600 --> 01:12:53.600]  Хорошая новость заключается в том, что это возможно.
[01:12:53.600 --> 01:12:58.600]  То есть, возможно, просто глядя на граф, понять, есть ли в нем такой цикл или путь или нет.
[01:12:58.600 --> 01:13:08.600]  Давайте 1.1 критерий
[01:13:08.600 --> 01:13:18.600]  Полуэйлеровости. Нет, давайте эйлеровости.
[01:13:18.600 --> 01:13:27.600]  Для неорграфов.
[01:13:27.600 --> 01:13:32.600]  Значит, дан неориентированный граф, ну, без направлений ребер, необходимо понять, является он эйлеровым или нет.
[01:13:32.600 --> 01:13:41.600]  То есть, есть ли в нем эйлеров цикл или нет.
[01:13:41.600 --> 01:13:58.600]  Связана игра в G эйлеров тогда и только тогда, когда связана в графе G для любой вершины V
[01:13:58.600 --> 01:14:09.600]  из множества вершин, степень вершины четна.
[01:14:09.600 --> 01:14:16.600]  Очень простой критерий. Если степень каждой вершины в графе у вас четная, в связанном графе четкая,
[01:14:16.600 --> 01:14:22.600]  то значит, в этом графе у вас есть эйлеров цикл.
[01:14:22.600 --> 01:14:26.600]  Это неориентированный граф.
[01:14:26.600 --> 01:14:31.600]  Для ориентированного графа, да, там мы будем различать входящий и исходящий. Пока так.
[01:14:31.600 --> 01:14:37.600]  Ну, давайте, доказывается просто, ну, вот в одну сторону.
[01:14:37.600 --> 01:14:41.600]  Ну, почему это так? Ну, просто следует из баланса входящий и исходящий ребер.
[01:14:41.600 --> 01:14:46.600]  Давайте просто построим сам цикл.
[01:14:46.600 --> 01:14:51.600]  Построим цикл.
[01:14:51.600 --> 01:15:09.600]  В каждую вершину вошли столько же раз.
[01:15:09.600 --> 01:15:19.600]  Сколько вышли?
[01:15:19.600 --> 01:15:22.600]  Из-за этого следует, что степень каждой вершины четна.
[01:15:22.600 --> 01:15:30.600]  Ну, как у нас выглядит эйлеров цикл? Мы попадаем в какую-то вершину, из нее выходим.
[01:15:30.600 --> 01:15:34.600]  Ну вот, если я допустим стрелочками, у меня указано направление цикла.
[01:15:34.600 --> 01:15:38.600]  Для каждой вершины, видите, что есть стрелка входящая, есть стрелка исходящая, есть стрелка входящая, есть стрелка исходящая.
[01:15:38.600 --> 01:15:43.600]  То есть ни в какой вершине мы не застреваем.
[01:15:43.600 --> 01:15:46.600]  Поэтому степень каждой вершины четна.
[01:15:46.600 --> 01:16:00.600]  Обратно покажем конструктивно предъявив алгоритм.
[01:16:00.600 --> 01:16:07.600]  Но это в следующий раз.
[01:16:07.600 --> 01:16:17.600]  То есть в следующий раз мы рассмотрим алгоритм и покажем, что если все вершины четные, то мы найдем эйлеров цикл.
[01:16:17.600 --> 01:16:22.600]  Вопросы есть?
[01:16:22.600 --> 01:16:34.600]  Теорема 1.2.
[01:16:34.600 --> 01:16:38.600]  Критерий...
[01:16:38.600 --> 01:16:40.600]  Что?
[01:16:40.600 --> 01:16:42.600]  Я сказал, мы алгоритм предъявим в следующий раз.
[01:16:42.600 --> 01:16:45.600]  То есть сегодня мы алгоритм не обсуждаем.
[01:16:45.600 --> 01:16:53.600]  Ну в следующий раз давайте.
[01:16:53.600 --> 01:16:58.600]  Критерий полуэйлерности
[01:16:58.600 --> 01:17:07.600]  неориентированного графа.
[01:17:07.600 --> 01:17:19.600]  В связной графе G полуэйлеров.
[01:17:19.600 --> 01:17:21.600]  Когда и только тогда.
[01:17:21.600 --> 01:17:24.600]  Когда, на самом деле, то же самое.
[01:17:24.600 --> 01:17:30.600]  В связном графе G
[01:17:30.600 --> 01:17:39.600]  для любой вершины
[01:17:39.600 --> 01:17:44.600]  четная, кроме
[01:17:44.600 --> 01:17:51.600]  может быть двух.
[01:17:51.600 --> 01:17:56.600]  Это если у вас все вершины четные, точнее, степень кончески четная, то у вас есть Book clerk в циклу.
[01:17:56.600 --> 01:18:01.600]  Ну а Bookler в циклу, соответственно, Perform150 contr gab iyi.
[01:18:01.600 --> 01:18:04.600]  Но при этом возможно такая ситуация, что у вас есть ровно две вершины, вот ровно две,
[01:18:04.600 --> 01:18:07.600]  у которых степень нечетная.
[01:18:07.600 --> 01:18:11.600]  Но тогда у вас просто есть earrings-путь, но Эйлерова цикла нет.
[01:18:11.600 --> 01:18:12.600]  Ну, как доказать?
[01:18:12.600 --> 01:18:27.440]  Кажется, очень просто. Сведем к теореме 1,1, добавив
[01:18:27.440 --> 01:18:44.540]  ребро между вершинами с четними степенями, понятно? Вот мы нашли две вершины, у которых
[01:18:44.540 --> 01:18:54.320]  степень нечетная. Что? Может есть, но просто ставим еще одну.
[01:18:54.320 --> 01:19:06.600]  Мульти граф не важно. Вот ровно то, что мы делали до этого. Да, у нас был эллеров путь, точнее был граф,
[01:19:06.600 --> 01:19:11.960]  в котором, если представить тебе, что все эти вершины, все эти ребра неориентированы, то у каждой
[01:19:11.960 --> 01:19:16.960]  вершины степень была четная, кроме вот этих двух. Мы просто между ними ставили ребро, нашли цикл,
[01:19:16.960 --> 01:19:20.600]  а потом цикл обратно вернули в это ребро, получили путь.
