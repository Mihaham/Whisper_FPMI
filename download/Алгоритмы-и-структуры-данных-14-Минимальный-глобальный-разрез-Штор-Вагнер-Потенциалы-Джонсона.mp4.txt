[00:00.000 --> 00:14.760]  Здравствуйте! Начинаем. Так, ну что, у нас остается две лекции с учетом этой. Значит, сегодня мы
[00:14.760 --> 00:28.280]  договорим про потоки. Вот, на оставшейся лекции поговорим что-нибудь про деревья. Вот. Значит,
[00:28.280 --> 00:37.400]  по всяким зачетам-экзаменам. Так, сейчас я попытаюсь вспомнить. Значит, у того,
[00:37.400 --> 00:44.600]  что я называю PMI и зачета-экзамен, значит, зачет, как обычно, просто по задачам семестра. Экзамен,
[00:44.600 --> 00:52.320]  так же, как был в первом семестре. Ну, приходите, пишите теории вопроса и потом задачи на до балла.
[00:52.320 --> 00:59.480]  Значит, дальше. У PMF, который, видимо, КТФ и PMI, только зачет, и чтобы как-то проконтролировать
[00:59.480 --> 01:05.040]  теоретический материал, будет контрольная, видимо, на одном из последних семинаров. Там
[01:05.040 --> 01:09.520]  будет 20 вопросов в стиле, там, сформулируйте теорему Форда Фалкерсона или дайте определение,
[01:09.520 --> 01:16.240]  что у нас там было, ну, не знаю, клики, например, ну, что-нибудь такое. Определение, формулировки,
[01:16.240 --> 01:20.920]  и, возможно, самые-самые простые доказательства, где там, ну, они буквально однострочные. Такие
[01:20.920 --> 01:26.000]  доказательства тоже могут быть. Вот программу я, видимо, сегодня-завтра тоже постараюсь скинуть.
[01:26.000 --> 01:31.960]  Это будет на, значит, 20 вопросов, на плюс 20 баллов. Вот. И, соответственно, пороговые значения тоже
[01:31.960 --> 01:37.880]  я, пороговые значения за зачет я тоже на днях выставлю. В табличке будет отдельно по PMI,
[01:37.880 --> 01:47.360]  отдельно по КТ. Вот. А ФУПУМ, который PM, у нас вроде бы только экзамен, поэтому работа в семестре
[01:47.360 --> 01:52.640]  будет учитываться на экзамене и плюс на экзамене, ну, в общем, какой-то похожий формат. Там будет
[01:52.640 --> 01:59.360]  теор-вопрос, но это еще подробнее. Это, в общем, скорее семинарист вам объявит, как это будет. Мы
[01:59.360 --> 02:02.400]  еще не до конца продумали. Ну, в общем, какой-то такой план. То есть зачет нет, только экзамен,
[02:02.400 --> 02:09.000]  и там, ну, вот учитывается работа в семестре плюс ответ на экзамен. Вот. Так, есть ли вопросы по
[02:09.000 --> 02:19.200]  оргинформации какой-нибудь? Ну, а пока там приблизительно, да, стоит. Я говорю, как бы они
[02:19.200 --> 02:23.400]  пока не окончательные. В том семестре у нас было, ну, то есть там сначала стоит приблизительно,
[02:23.400 --> 02:28.400]  просто линейная, а потом я немножко ее подфиксирую. Ну, то есть конкретный будет порог на U3,
[02:28.400 --> 02:33.840]  на U4, на U5 и так далее, на U10. Но они будут не сильно отличаться от того, что сейчас стоит. Ну,
[02:33.840 --> 02:42.080]  наверное. Ваша цель это не оценку получить, а задачу научиться решать. Поэтому я оставляю
[02:42.080 --> 02:48.080]  за собой право немножко их фиксировать. Так, еще вопросы? Хорошо. Значит, тогда у нас на сегодня
[02:48.080 --> 03:04.640]  две задачи. Первая это минимальный глобальный разрез. Ну, разрез мы должны помнить, что такое,
[03:04.640 --> 03:11.640]  если у нас есть сеть, и сток, и сток, и нам нужно, значит, как-то их разрезать, то есть разбить все
[03:11.640 --> 03:16.240]  множество на две доли, S большое, T большое. Так что с маленькой в S большом, T маленькая в T
[03:16.240 --> 03:21.360]  большом. И в объединении эти два множества дают все множество вершин. Значит, это разрез между
[03:21.360 --> 03:25.760]  двумя вершинами, а глобальный разрез — это когда S маленькая и T маленькая у вас не фиксированы.
[03:25.760 --> 03:36.640]  Значит, пусть G и C — это сеть, то есть граф с функцией вот этой вот capacity без выделенных и
[03:36.640 --> 03:50.640]  стока, и стока. Значит, тогда пара S, T называется разрезом, если это два непустых множества,
[03:50.640 --> 03:56.640]  которые в дизюнктном объединении дают все множество вершин графа. Если S и T не пустые,
[03:56.640 --> 04:04.480]  при этом их дизюнктное объединение равно множеству вершин всего графа. То есть каждая вершина
[04:04.480 --> 04:10.360]  отнесена к одной из двух долей. Ну, величина такого разреза — это сумма всех ребер пересекающих
[04:10.360 --> 04:15.520]  разрез, в смысле сумма capacity всех ребер пересекающих разрез. Ну, давайте это напишем. Это у нас уже
[04:15.520 --> 04:27.280]  было. C, S, T — это сумма по всем U из S, V из T, C, U, V, где C — вот эта самая функция пропускных способностей.
[04:27.280 --> 04:35.120]  Вот. Ну, мы в дальнейшем... Давайте я также напишу. То есть это я для разреза определил C. Я могу
[04:35.120 --> 04:41.840]  определить также C для любых двух множеств. Если A и B произвольные под множество V,
[04:41.840 --> 05:03.840]  то мы можем точно также определить C от A, B как сумму U из A, V из B, C, U, V. То есть C — это
[05:03.840 --> 05:07.400]  как бы не только величина разреза, но и для произвольных нож. Там не обязательно все вершины,
[05:07.400 --> 05:12.680]  не обязательно. Там они оба не пустые. Вот просто любую пару можем такое определить. Ну,
[05:12.680 --> 05:18.680]  значит, смотрите. Тут возникает две таких задачи естественных. Это поиск минимального глобального
[05:18.680 --> 05:24.200]  разреза. Ну, вот здесь я написал просто разрез. Можно написать, что глобальный, подчеркнуть,
[05:24.200 --> 05:30.640]  как бы, что он называется глобальным разрезом. Подчеркнуть, что на него нет условий, что там S в
[05:30.640 --> 05:35.400]  S большом, а T в T большом. Так вот, значит, появляется задача поиска минимального глобального
[05:35.400 --> 05:48.160]  разреза и максимального глобального разреза. Вот с первой задачей мы сегодня справимся,
[05:48.160 --> 05:59.360]  а вторая довольно сложная. Не просто довольно сложная, а НП трудная. То есть, если, например,
[05:59.360 --> 06:04.840]  стоит задача данный граф, нужно разбить все его множество вершин на две доли так, чтобы суммарно
[06:04.840 --> 06:12.680]  из первой доли во вторую сумма весов ребер была максимально возможна. Это задача НП трудная. Для
[06:12.680 --> 06:17.880]  нас, как бы, неважно пока, что это значит. Тут нужно много времени потратить, чтобы определить,
[06:17.880 --> 06:23.040]  что такое НП трудность. Но для нас это словосочетание значит, что эту задачу мы пока не умеем решать
[06:23.040 --> 06:28.880]  за поляном. Так же, как у нас было, мы уже несколько раз встречались с этим словом, когда мы искали
[06:28.880 --> 06:36.120]  максимально независимое множество или там, что мы еще искали, минимальное вершинное покрытие,
[06:36.120 --> 06:41.240]  не в вдовдольном графе, а в произвольном. Все такие задачи, они НП трудные, и пока никто не умеет
[06:41.240 --> 06:46.040]  их решать за поляном. Напоминаю, зачем нам это знание. Затем, что если вы вдруг какую-то задачу
[06:46.040 --> 06:51.000]  свели к поиску, скажем, максимального глобального разреза, то это сведение не очень полезное.
[06:51.000 --> 06:56.280]  Если у вас был исходной граф на тысячи вершин, и вы свели исходную задачу к поиске максимального
[06:56.280 --> 07:01.040]  глобального разреза на этой же самой тысячи вершин, ну вот тогда дальше непонятно, что делать,
[07:01.040 --> 07:05.720]  потому что пока что никто не умеет быстро это решать. То есть, там есть какие-то приближенные алгоритмы,
[07:05.720 --> 07:13.200]  которые с какой-то точностью дают разрез. То есть, там не хуже, чем в два раза отличается. Ну,
[07:13.200 --> 07:17.680]  не больше, чем в два раза отличается от максимального, например. Но точное решение пока никто искать не умеет.
[07:17.680 --> 07:24.920]  Вот. Но давайте я напишу какой-то пул НП трудных задач, которые у нас уже есть, то есть, которые,
[07:24.920 --> 07:32.360]  как бы, я бы сказал так, как бы на текущем уровне понимания можно даже не пытаться решать. То есть,
[07:32.360 --> 07:37.600]  на третьем курсе у некоторых из вас будет курс сложности учисления, где вот все вот эти задачи
[07:37.600 --> 07:41.800]  будут как бы друг к другу там сведены в каком-то смысле, и показано, что все они одинаковой трудности,
[07:41.800 --> 07:46.920]  и решить одно из них значит решить все вообще. Поэтому они как бы не просто все сложены сами по себе,
[07:46.920 --> 07:51.720]  но и совокупности тоже. То есть, если вы хотя бы одно решите, то сразу решите все. То есть,
[07:51.760 --> 07:57.880]  не одинаковой трудности между собой, и решить одну значит решить все. А пока никто не умеет это делать.
[07:57.880 --> 08:05.920]  Итак, значит, это максимально независимое множество. Ну, в произвольном графе, конечно,
[08:05.920 --> 08:09.920]  потому что в долудольном мы уже умеем искать. Там кунти, аримакеннига и так далее. Значит,
[08:09.920 --> 08:20.400]  двойственное к нему это минимальное вершинное покрытие. Тоже похожа характеристика,
[08:20.400 --> 08:27.080]  это максимальная клика. Напомню, что мы умели искать максимальную клику вот за такое время.
[08:27.080 --> 08:32.040]  Два всегда не n пополам, но это экспоненты от размеров хода. Вот, а какой-нибудь там полином,
[08:32.040 --> 08:43.360]  типа n в кубе, пока никто делать не умеет. Дальше, максимальный разрез. Можно же добавить поиск
[08:43.360 --> 08:49.320]  гаметного цикла. То есть, проверка того, существует он, ну и скажем, если существует, то вывести его.
[08:49.320 --> 08:57.760]  Давайте я так напишу поиск гаметного цикла. Поиск гаметного цикла или гаметного пути. Это одно
[08:57.760 --> 09:03.000]  и то же в плане сложности. Они обе NP трудные. Про гаметного цикла мы тоже что-то говорили,
[09:03.000 --> 09:07.320]  когда про DP начинали говорить. То есть там можно опять-таки за экспоненту решать, типа за два в
[09:07.320 --> 09:12.920]  степени n умножить на n. Но за какой-то полином пока никто не умеет. Ну и последнее добавлю еще
[09:12.920 --> 09:23.000]  хроматическое число. Графа. Хроматическое число. Хроматическое число. Это вот у вас есть граф.
[09:23.000 --> 09:30.280]  Есть какие-то ребра в нем. И вам нужно покрасить все вершины в какие-то цвета, в минимальное число
[09:30.280 --> 09:35.800]  цветов, так чтобы вершины, соединенные ребрами, были разных цветов. То есть, если вот между двумя
[09:35.800 --> 09:41.920]  вершинками есть ребро, то цвета, которые на них написаны, различны. С1 не равно С2. И так по всем
[09:41.920 --> 09:47.120]  ребрам. Соответственно, какое минимальное число цветов вам нужно, чтобы иметь какую-то
[09:47.120 --> 09:59.600]  корректную раскраску. Это тоже NP трудная задача. Вот такой обзор. Ну, конечно, есть NP трудные
[09:59.600 --> 10:05.520]  задачи не только на графах. Я, кажется, еще формулировал, когда задача 3 SAT тоже NP трудная.
[10:05.520 --> 10:11.560]  Значит, мы решали два SAT с помощью ориентированных графов каких-то и поиском компонент сильно
[10:11.560 --> 10:15.480]  связанности. Но вот если вы разрешите в каждой скобке содержать три литералы, то это уже тоже
[10:15.480 --> 10:21.320]  станет NP трудная задача. Пока как решать неизвестно. Вот. Ну, еще их много-много других, но вот такие,
[10:21.320 --> 10:28.880]  которые у нас в курсе, по крайней мере, были рядышком. Так. Ну, значит, давайте отложим этот
[10:28.880 --> 10:33.320]  максимальный глобальный разрез. Мы его поняли, что искать не умеем и не будем этого делать. Будем
[10:33.320 --> 10:40.600]  искать минимальный глобальный разрез. Значит, давайте я для удобства буду считать, что наш граф не
[10:40.800 --> 10:52.040]  ориентированный уже, не ориентированный. Это значит, что если вы какие-то две вершинки,
[10:52.040 --> 10:57.560]  разнесли в разные доли. Скажем uws, avvt, то обязательно вес этого ребра,
[10:57.560 --> 11:03.020]  ну, капасти этого ребра обязательно учтется в разрезе. То есть как бы вы эти uw не разносили,
[11:04.080 --> 11:09.900]  в смысле, если он не в разных долях, то обязательно вес этого ребра учтется в разрезе. Тут нет
[11:09.900 --> 11:12.900]  если проходит разрез, то оно обязательно учитывается.
[11:12.900 --> 11:17.900]  Так, ну конечно, у нас есть уже какой-то способ, как можно найти минимальный глобальный разрез.
[11:17.900 --> 11:22.900]  Вопрос к вам, к помощи какого алгоритма можно найти из уже известных,
[11:22.900 --> 11:24.900]  можно найти минимальный разрез?
[11:28.900 --> 11:30.900]  А если это кто?
[11:35.900 --> 11:38.900]  Ну конечно, да, можно просто перевернуть все пары вершин s маленькая, t маленькая,
[11:38.900 --> 11:43.900]  найти максимальный поток между s и t и взять минимум по всем возможным таким парам s и t.
[11:43.900 --> 11:53.900]  Давайте напишем, ans равно бесконечность, цикл s от единицы до n, цикл t от, скажем, s плюс одного до n,
[11:53.900 --> 12:01.900]  ans равно минимум из ans, plow между s и t.
[12:01.900 --> 12:07.900]  Ну то есть мы знаем, что в оптимальном разрезе s, t точно есть хотя бы кто-то здесь, хотя бы кто-то здесь.
[12:07.900 --> 12:10.900]  Давайте какие-нибудь вершины здесь фиксируем, s маленькая, t маленькая.
[12:10.900 --> 12:15.900]  Тогда, в частности, вес, величина этого разреза будет равна величине потока между s и t.
[12:15.900 --> 12:18.900]  Потому что мы знаем, что минимальный разрез равен максимальному потоку.
[12:18.900 --> 12:26.900]  А раз это вообще минимальный разрез во всей сети, то он подавно меньше либо равен, чем вес минимального разреза между s маленькая и t маленькая.
[12:26.900 --> 12:33.900]  Значит, если мы все такие пары переберем, то у нас точно получится вообще минимально возможный разрез.
[12:34.900 --> 12:41.900]  Значит, соответственно, здесь время работы будет n квадрат на время работы какого-нибудь алгоритма поиска максимального потока.
[12:41.900 --> 12:44.900]  Вот, но можно еще немножко это даже оптимизировать.
[12:44.900 --> 12:50.900]  Можно не делать два вложенных цикла, можно, скажем, зафиксировать s равно единичке и перебирать только t.
[12:50.900 --> 12:54.900]  Давайте напишем альтернативную версию, тоже работающую.
[12:54.900 --> 12:59.900]  Значит ans это бесконечность, а s это единица, а дальше цикл только по t.
[12:59.900 --> 13:07.900]  У двойки до n. И в цикле мы делаем то же самое ans равно минимум из ans low st.
[13:10.900 --> 13:17.900]  Ну, потому что поскольку граф не ориентированный, мы понимаем, что не умоляя общности, можно считать, что вершина номер один лежит здесь.
[13:17.900 --> 13:22.900]  Вершина номер один лежит здесь, потому что иначе можно переставить s и t, от этого вес разреза не изменится.
[13:22.900 --> 13:25.900]  Значит, единичка здесь, ну и тогда надо просто перебирать, кто лежит здесь.
[13:25.900 --> 13:32.900]  То есть хотя бы одна вершина должна сюда попасть, мы ее перебираем, и тогда величина этого потока равна в точности величине разреза минимального.
[13:32.900 --> 13:34.900]  Согласны?
[13:34.900 --> 13:39.900]  Значит, получили, что время работы это n на время работы потока.
[13:39.900 --> 13:42.900]  Я напишу так time от flow.
[13:42.900 --> 13:50.900]  Ну, если, например, поток мы ищем алгоритмом диница, который работает за v квадрат e, то это будет, ну я напишу так, v куб e.
[13:51.900 --> 13:55.900]  Ну, n это v, число вершин.
[13:55.900 --> 13:58.900]  Поток мы с помощью алгоритма диница находим за v квадрат e.
[13:58.900 --> 14:03.900]  Вот такая ужасная симптотика поиска минимального глобального разреза.
[14:07.900 --> 14:14.900]  Так, ну и сейчас мы будем делать другой алгоритм, который позволяет нам сделать то же самое за лучшую симптотику.
[14:20.900 --> 14:23.900]  Это так называемый алгоритм Штор-Вагнера.
[14:24.900 --> 14:25.900]  Два автора.
[14:25.900 --> 14:28.900]  Штор-женщина-вагнер-мужчина.
[14:28.900 --> 14:32.900]  Поэтому так сперегаются фамилии.
[14:32.900 --> 14:33.900]  Значит, алгоритм следующий.
[14:33.900 --> 14:52.240]  два автора тор женщина вагнер мужчина поэтому так сперегаются фамилии значит
[14:52.240 --> 14:58.660]  алгоритм следующий сейчас будет его описание алгоритм будет рекурсивный и
[14:58.660 --> 15:08.020]  делает он следующее значит сначала говорит что а 1 это единичка а аито это множество
[15:08.020 --> 15:14.700]  вершин с а 1 по аито в частности а большое первое это вершина только одна вершина номер один
[15:14.700 --> 15:21.620]  дальше на и плюс первом шаге мы находим такую вершину то есть у нас есть весь граф у нас
[15:21.620 --> 15:26.700]  фиксировано там какие-то вершины с первой поитой и на следующем шаге мы находим такую вершину
[15:26.700 --> 15:31.100]  которая максимально связана вот с этим предыдущим множеством максимально в смысле
[15:31.100 --> 15:38.380]  цэ в смысле capacity значит формально это арк максимум по всем вершинам вы не лежащим в аито
[15:38.380 --> 15:53.380]  величина вот такого вот разреза в кавычках между вы и аито то есть есть у вас уже найденное
[15:53.380 --> 15:57.780]  множество а большое это вы перебираете все остальные вершины которые в нем не лежать вы
[15:57.780 --> 16:03.140]  складываете сумму весов всех этих ребер и находите такое вы где где здесь достигается максимум
[16:03.140 --> 16:10.940]  значит ну тогда соответственно а и плюс первая это аито в объединении с это новой вершинкой а и
[16:10.940 --> 16:17.420]  плюс первой вот так делайте получается n минус один раз находите а второе а третья и так далее
[16:17.740 --> 16:22.620]  вот в конце у вас есть какой-то порядок вершин так что каждая это как бы наиболее
[16:22.620 --> 16:29.220]  связанная со всеми остальными так вот тогда алгоритм утверждает следующее давайте утверждение
[16:29.220 --> 16:50.260]  что ну да минимальный разрез между а n минус 1 и а n то есть рассматриваем две вершины которые
[16:50.260 --> 16:56.100]  мы на двух последних шагах находим оказывается что минимальный разрез между ними равен
[16:59.700 --> 17:02.460]  по величине вот этому вот разрезу
[17:08.180 --> 17:14.140]  смотрите мы в каком-то странном порядке номируем вершины и оказывается что две последние вершины
[17:14.140 --> 17:19.620]  когда мы их вот занумеровали две последние добавлены в наш массив вершины оказывается что если
[17:19.620 --> 17:23.980]  мы будем пытаться находить максимальный поток между ними то есть минимальный разрез между
[17:23.980 --> 17:30.220]  ними да то есть скажем из а n в а n минус 1 будем пускать максимальный поток это то же
[17:30.220 --> 17:34.620]  самое что искать минимальный разрез и вот оказывается что среди всех таких разрезов которые
[17:34.620 --> 17:40.220]  разносят а n минус 1 и а n в разные стороны оказывается что минимальным является вот такой то
[17:40.220 --> 17:44.820]  есть когда у вас просто отдельная а n а все остальные во второй долю
[17:53.980 --> 18:02.620]  так но если это верно то смотрите получается что за один вот такой прогон мы смогли найти
[18:02.620 --> 18:07.180]  минимальный разрез между какой-то парой вершин это утверждение мы чуть-чуть позже докажем но
[18:07.180 --> 18:12.140]  смотрите за один прогон мы смогли найти минкат между кем-то двумя вершинами а дальше замечание
[18:12.140 --> 18:18.620]  следующее что если это не минкат если это не ответ то значит в минимальном разрезе эти две
[18:18.620 --> 18:26.160]  вершины не по разные стороны разреза то есть они должны лежать либо оба либо обе в с либо обе в
[18:26.160 --> 18:31.820]  т потому что не по разное то минимально возможный разрез вот он тут написан значит если это не
[18:31.820 --> 18:35.740]  ответ то можно считать что в ответе эти две вершины в одной доле их можно склеить
[18:35.740 --> 18:46.380]  вот ну значит дальше мы их склеиваем и запускаем наш алгоритм рекурсивно уже на
[18:46.380 --> 18:53.020]  графе зену с одной вершины и так делаем пока в графе не останется одна или две вершины значит
[18:53.020 --> 19:07.620]  две опции да либо c а n а n минус 1 это глобальный минкат глобальный минимальный разрез либо
[19:07.620 --> 19:20.700]  в глобально минимальном разрезе глобально минимальном разрезе а n минус 1 и а n лежат в
[19:20.700 --> 19:38.300]  одном множестве следовательно их можно склеить ну склейка происходит очень просто есть две
[19:38.300 --> 19:49.420]  вершинки у вас а n минус 1 и а n и есть все ребра которые в них входят но тогда вот считайте что
[19:49.420 --> 19:55.260]  вот это вот это одна такая толстая вершина а ребра которые в них в них ходили но тоже надо
[19:55.260 --> 19:59.980]  склеить то есть например вот эти вот два ребра которые из одной тоже вершины исходили нужно
[19:59.980 --> 20:05.740]  превратить в ребро с весом равным сумме весов вот этих вот двух величин вот это плюс вот это
[20:05.740 --> 20:14.020]  не знаю напишу здесь там x y а тогда в частности будет вот такое ребро веса x плюс y соответственно
[20:14.020 --> 20:18.700]  надо будет сложить вот эти вот две величины тоже ну добавить там такое ребро а эти просто
[20:18.700 --> 20:24.420]  ребра добавить без складывая ну короче в общем ребра из одной вершины которые ввели в а n минус
[20:24.420 --> 20:31.980]  1 и в а н надо просто склеить и сложить к опассите тех ребер которые там были написаны вот ну а
[20:31.980 --> 20:42.780]  дальше значит рекурсивный запуск рекурсивный запуск на графе с n минус одной вершины
[20:53.020 --> 20:57.100]  пока не дойдем до графа с двумя вершинами если в графе две вершины то понятно как выглядит
[20:57.420 --> 21:01.700]  это просто сумма весов ну как бы просто вес ребра на самом деле между тем двумя вершинами
[21:01.700 --> 21:12.620]  вот такой алгоритм значит за сколько он работает ну здесь понятно что нужно делать вот этот прогон
[21:12.620 --> 21:18.460]  n раз да какая-то какая-то какая-то номерации вершин дальше склейка двух последних и опять входим
[21:18.460 --> 21:24.140]  входим в цикл опять перенумеровываем вершины нужно просто это сколько реализуется вот это
[21:24.140 --> 21:32.240]  можно сделать за квадрат вот этот прогон можно сделать за н квадрат потому что ну здесь что-то
[21:32.240 --> 21:37.500]  очень похоже на алгоритм ну допустим prima потому что смотрите вы как бы по очереди так откусывайте
[21:37.500 --> 21:43.540]  вершинки а дальше для всех остальных которые вы еще не не откусили вы рассматривайте там какую-то
[21:43.540 --> 21:50.140]  величину берете из них максимально и и перетягивайте в множество а и плюс первая это очень похоже на
[21:50.140 --> 21:54.620]  алгоритм прима, что у вас есть уже какое-то остовное дерево, дальше всех остальных недобавленных
[21:54.620 --> 22:00.460]  востов вы выбираете вершину, ну там, какое-то минимальное ребро, и его добавляете востов,
[22:00.460 --> 22:04.540]  и дальше пересчитываете вот эти вот, вот эти штуки. Ну то же самое надо сделать здесь. Давайте
[22:04.540 --> 22:08.540]  просто для каждой вершины, не лежащей в аитом, будем поддерживать вот эту вот текущую величину,
[22:08.540 --> 22:15.920]  суммой весов и ребер между v и всем аитом, находить там максимум, перетаскивать вершину в а и плюс
[22:15.920 --> 22:20.560]  первая, ну и дальше тогда эта величина просто пересчитывается. Если вы v перенесли в а и плюс
[22:20.560 --> 22:25.880]  первая, то как меняется вот эта величина для всех остальных вершин? Надо просто пройтись по
[22:25.880 --> 22:32.440]  ребрам исходящим из v и прибавить сюда вес вот этих вот, ну как бы сюда прибавить вес этого
[22:32.440 --> 22:37.680]  ребра, сюда вес этого, сюда вес этого. На этом сам мы будем знать вот это значение всех вершин,
[22:37.680 --> 22:42.520]  максимум находим за линию, просто пройдясь по всем вершинам, ну и потом пересчет делается за
[22:42.520 --> 22:50.080]  число ребер на самом деле. Тут можно было написать, а ну да, ну да, n квадрат, потому что суммарный
[22:50.080 --> 22:55.120]  ребер у меня e, не больше чем n квадрат, и мне нужно n раз находить максимум, это еще n квадрат.
[22:55.120 --> 23:06.400]  Согласны? Вот, ну и итоговая симптотика будет n куб, потому что мы n раз так делаем. Симптотика
[23:06.400 --> 23:14.560]  вот в кубе. Значит, все, что нам осталось сделать, это доказать вот это утверждение, что при такой
[23:14.560 --> 23:19.440]  странной нумерации минимальный разрез между двумя последними, это тривиальный разрез, где а n в
[23:19.440 --> 23:40.880]  отдельной доле лежит. Чтобы доказать утверждение, давайте скажем следующее. Пусть st какой-то разрез,
[23:40.880 --> 23:52.760]  какой-то разрез. Наша задача показать не совсем какой-то, сейчас одну секунду,
[23:52.760 --> 24:04.800]  какой-то разрез между а n и а n-1, то есть такой, что а n скажем в s, а n-1 в t. Наш стать показать,
[24:04.960 --> 24:12.280]  что вес этого разреза не меньше, чем вес вот того разреза, accumufacturing published algorithm,
[24:12.280 --> 24:17.760] SHIP, который мы находим в нашем алгоритме. Цель показать, что вес этого разреза больше
[24:17.760 --> 24:21.340]  либо равен. Вес вот того оптимального разреза, который мы утверждаем, что является
[24:21.340 --> 24:27.720]  минимальным между ними. Если мы это докажем, получается, что любой разрез больше либо равен
[24:27.720 --> 24:34.920]  чем вот этот, значит, это минимальный. Итак, вот будем доказывать такое утверждение для произвольного
[24:34.920 --> 24:56.800]  разреза СТ. Значит, говорим, что вершина АИ является активной, если она и предыдущая,
[24:56.800 --> 25:06.200]  а и минус первая, лежат в разных долях СТ. Я напишу так, если АИ лежит в С, а АИ минус
[25:06.200 --> 25:15.600]  первая лежит в Т, или АИТ лежит в Т, а АИ минус первая лежит в С. В общем, активная вершина
[25:15.600 --> 25:19.200]  это та, которая была добавлена в другую долю по сравнению с предыдущей вершиной.
[25:19.200 --> 25:35.360]  Вот, и давайте докажем для активных вершин следующее утверждение. Если АИ активная, то
[25:35.360 --> 25:52.760]  разрез между АИ и АИ минус первая меньше либо равен, чем сужение вот этого разреза на множество
[25:52.760 --> 26:02.880]  АИТ, то есть С пересечь с АИТ, Т пересечь с АИТ. Давайте докажем такое утверждение для каждой
[26:02.880 --> 26:25.200]  активной вершины. Доказательства. Индукция по активным вершинам.
[26:25.200 --> 26:37.920]  По активным вершинам. База, когда у нас появляется первая активная вершина, что такое первая активная
[26:37.920 --> 26:43.680]  в этом нашем порядке 1 на 2 и так далее? Первая активная, это такая, что все до нее лежали в С
[26:43.680 --> 26:47.800]  большом, а она первая попала в Т большое. Ну или наоборот, она первая в С, а все остальные в Т
[26:47.800 --> 26:57.200]  большом. База. Пусть АЖ это первая активная, первая активная, ну тогда картинка какая-то такая,
[26:57.200 --> 27:02.720]  например. Вот здесь вот лежали все товарищи с первого, позже минус первая, скажем, это было С
[27:02.720 --> 27:12.200]  пересечь с АЖТ, а АЖТ единственная, которая попала в Т большое. Ну здесь понятно, что там, может быть
[27:12.200 --> 27:16.840]  здесь наоборот ТС, из-за неориентированности мне неважно, кто из них кто. С и Т можно всегда
[27:16.840 --> 27:22.280]  свопнуть при необходимости. Вот, ну и тогда понятно, что на самом деле то, что написано вот в
[27:22.280 --> 27:32.320]  утверждении, это одно и то же просто. Так, АЖТ, АЖ минус первая, в точности равно просто на величине
[27:32.320 --> 27:46.120]  вот этого разреза. Потому что вот здесь это просто сумма весов вот этих вот ребер. Но это есть величина
[27:46.120 --> 27:51.480]  разреза просто. База очевидна, база даже, в базе у нас даже просто равенство, а не не равенство.
[27:51.480 --> 28:00.080]  Даже равенство. База есть. Теперь переход.
[28:00.080 --> 28:18.960]  Для перехода мы рассматриваем две последовательные активные вершины.
[28:18.960 --> 28:30.640]  Переход. Пусть АУ и АВ две последовательные активные вершины.
[28:30.640 --> 28:44.720]  Две последовательные активные вершины. Значит между ними не было активных. Ну тогда картинка какая-то такая.
[28:48.960 --> 28:56.640]  Вот в какой-то момент АУТ куда-то добавилось. Дальше все последующие до АВТ добавлялись туда же.
[28:56.640 --> 29:04.240]  Потому что если бы добавились в другое, то это была бы активная вершина. Значит там же, где АУ, лежит АУ плюс один и так далее, АВ минус один.
[29:04.240 --> 29:11.800]  А вот АВТ уже попадает в противоположную долю. У нас получается вот такое вот разбиение нашего графа.
[29:11.800 --> 29:24.680]  Если здесь у меня С пересечь с АВ, здесь Т пересечь с АВ, то у меня картинка какая-то такая, что все с УТ по В-1 попали в одну и ту же долю.
[29:24.680 --> 29:31.640]  Так, ну и тогда давайте писать, что такое величина разреза между АВ и АВ минус один.
[29:45.640 --> 29:47.640]  Значит это сумма весов.
[29:55.640 --> 30:04.120]  Ну давайте я напишу так, значит это вот эти вот ребра, да точно. Ну еще соответственно сумма весов всех ребер из АВ вот во все остальные.
[30:04.120 --> 30:15.640]  То есть я напишу так, это С между АВ и все, что находится вот здесь, это можно написать так. АВ минус один без АУ минус один.
[30:16.600 --> 30:30.600]  Это получается все вершины, вот эти вот, которые были добавлены между ними, плюс С между АВ и так сейчас, ну да, и АУ минус один.
[30:31.560 --> 30:45.560]  То есть вот это вот, это вот эти ребра между новодобавленными вершинами, а все остальное, АВ и АУ минус один, это все вот эти вот, все остальные.
[30:46.520 --> 31:00.520]  Итак, значит теперь мне нужно эти два слога как-то сверху оценить. Значит смотрите, первая идея следующая, вот эта штука не больше, чем САУ АУ минус один по выбору АУ.
[31:01.480 --> 31:16.480]  Вот это объясняется выбором АУ. Почему? Ну потому что на каждом шаге как мы выбрали АУ? АУ мы выбрали как вершину, не лежащую в АУ минус один, с максимальным значением вот этого разреза.
[31:16.480 --> 31:26.480]  Максимальное значение было вот это. Но, да, значит АВ я тогда не выбрал и выбрал когда-то позднее. Получается, что АВ оно хуже с точки зрения этой величины, чем АУ.
[31:27.440 --> 31:33.440]  Потому что АУ максимально. Значит можно написать такое неравенство. Раз мы АВ не выбрали в тот момент, а выбрали АУ, значит есть такое неравенство.
[31:33.440 --> 31:43.440]  Вот, а эту штуку мы уже умеем оценивать по предположению индукции, что вот эта вот вещь не больше там какой-то там С, по утверждению которой мы доказываем.
[31:43.440 --> 31:47.440]  Теперь надо разобраться вот с этим. Как это можно оценить?
[31:57.440 --> 32:15.440]  Ну, смотрите, вес вот этих вот ребер, которые здесь написан, вес этих ребер, это точно нижняя оценка на то, насколько изменился вообще наш разрез по сравнению с состоянием С пересечь с АУ, Т пересечь с АУ.
[32:15.440 --> 32:22.440]  То есть вот эти вот кружочки, которые я нарисовал, это на самом деле С пересечь с АУ минус один.
[32:23.400 --> 32:27.400]  Так, Т пересечь с АУ минус один.
[32:29.400 --> 32:41.400]  Да, ну потому что здесь все номера с У по В, они не лежат в них. То есть смотрите, если я сравню два как бы разреза, если я сравню два разреза, всех напишу.
[32:43.400 --> 32:46.400]  Вот этот вот, который самый большой, вот эти два множества.
[32:47.360 --> 32:53.360]  И вот этот, С пересечь с АУ минус один и пересечь с АУ минус один.
[32:53.360 --> 32:59.360]  Рассмотрю такую разность, то она явно больше равна, чем как раз все вот эти ребра.
[33:01.360 --> 33:08.360]  То есть больше равна, чем С между АВ и АВ минус один без АУ минус один.
[33:09.320 --> 33:11.320]  Еще раз, да, что я написал, смотрите.
[33:11.320 --> 33:17.320]  Первое, вот это вот уменьшаемое, это величина разреза между двумя большими кружочками.
[33:17.320 --> 33:20.320]  Дальше, вычитаемые, это величина разреза между маленькими кружочками.
[33:20.320 --> 33:22.320]  Я рассматриваю как отличаются эти два разреза.
[33:22.320 --> 33:26.320]  То есть какие ребра появляются в разрезе, когда я добавляю вот эти кашины и вот эту.
[33:26.320 --> 33:28.320]  Ну, понятно, что хотя бы вот эти.
[33:28.320 --> 33:32.320]  Да и еще какие-то, конечно, появляются, появляются вот эти ребра, вот эти ребра и так далее.
[33:32.320 --> 33:34.320]  Какие-то, конечно, еще появляются, но как минимум вот эти появляются.
[33:34.320 --> 33:37.720]  и так далее. Какие-то, конечно, еще появляются, но, как минимум, вот эти появляются.
[33:37.720 --> 33:42.920]  Значит, эта разность точно больше собрана, чем вот эта. Мы предполагаем, что все
[33:42.920 --> 33:49.320]  капасти не отрицательны. Ну, значит, вот эту штуку можем оценить через такую разность.
[33:49.320 --> 33:57.560]  Так, давайте перейдем сюда. Вот, ну все, соответственно, дальше вот это оцениваем
[33:57.560 --> 34:00.360]  по индукции, там сокращается вот это и вычитаем, и получается то, что нужно.
[34:00.360 --> 34:16.720]  Значит, так, что мы получили? Мы получили, что вот эта вещь меньше либо равна, чем...
[34:16.720 --> 34:21.400]  Вот это первое с логами я оцениваю через эту разность.
[34:30.360 --> 34:47.880]  Второе с логами я оцениваю по вот этому. Просто переписали. Дальше, эта вещь у нас
[34:47.880 --> 34:52.840]  оценивается по предположению индукции для вершинки ау, поскольку ау предыдущая активная,
[34:52.840 --> 34:58.000]  для нее верно вот это утверждение, поэтому можем оценить сверху величину этого разреза.
[34:58.040 --> 35:09.600]  Это не больше, чем с пересечь с аут, ты пересечь с аут. Так, ну и вот,
[35:09.600 --> 35:13.040]  то есть эти штуки почти одно и то же. Надо сейчас разобраться.
[35:28.880 --> 35:34.000]  Ну понятно, просто вот эта вещь не отрицательна. Вот эта вот минус вот эта явно не отрицательна,
[35:34.000 --> 35:39.120]  потому что здесь мы расширили, там с большое, t большое, значит вот эта вот минус вот эта не
[35:39.120 --> 35:48.160]  отрицательна. Давайте сделаем вставку. Величина такого разреза, очевидно,
[35:48.160 --> 35:52.600]  больше равна, чем величина такого разреза, когда у меня на одну вершинку меньше.
[35:52.600 --> 36:01.640]  Понятно, что чем отличается вот этот разрез от вот этого. Я куда-то добавил просто аута маленькая,
[36:01.640 --> 36:05.160]  одну вершинку добавил и поняли, что величина разреза могла только увеличиться. Значит,
[36:05.160 --> 36:09.760]  вот эта разность не отрицательна и отсюда мы получаем то, что нужно.
[36:09.760 --> 36:16.880]  Что это не больше, чем вот это вот первое слагаемое.
[36:16.880 --> 36:22.040]  Что и требовалось.
[36:22.040 --> 36:48.320]  Сейчас одну секунду, действительно справедливо. Сейчас я тогда минутку подумаю.
[36:48.320 --> 36:52.000]  Да, вы право, момент.
[37:48.320 --> 38:01.280]  Мне хотелось бы вот, чтобы здесь не было вот этого, чтобы здесь было не минус один,
[38:01.280 --> 38:03.000]  тогда бы все получилось.
[38:03.000 --> 38:16.640]  Так, sorry.
[38:48.320 --> 39:17.800]  Смотрите, можно сделать вот так, видимо.
[39:17.800 --> 39:32.760]  Нет, это бред.
[39:47.800 --> 40:05.840]  Ладно, sorry. Я не вижу, как это фиксовать. Давайте я на следующий раз это перенесу. Виноват.
[40:05.840 --> 40:10.200]  Значит, здесь где-то бага. Бага, потому что действительно, да, вот правильно заметили,
[40:10.200 --> 40:16.560]  что если тут написано что-то не отрицательное, то мы доказали, что наше не больше, чем то,
[40:16.560 --> 40:22.080]  что надо, плюс что-то, но оно может быть больше, чем это. Да, окей, виноват. В следующий раз давайте
[40:22.080 --> 40:31.160]  это я пофиксирую. Ну, пока давайте считать, что мы это уже не доказали. Точно верно? Где-то я тут
[40:31.160 --> 40:42.400]  перемудрил. Тем не менее, давайте мы в него просто поверим, тогда потом это исправится.
[40:42.400 --> 40:47.480]  Значит, смотрите, что мы доказали. Давайте мы вот то самое применим для AN. Я утверждаю,
[40:47.480 --> 40:58.440]  что AN обязательно активная. AN обязательно активная. Значит, почему так? Потому что AN-1 и AN,
[40:58.440 --> 41:07.320]  они точно в разных долях относительно нашего разреза ST. В разных долях нашего разреза ST.
[41:07.320 --> 41:12.120]  Потому что это был разрез между как раз AN-1 и AN, поэтому скажем, если это в S, то это в T
[41:12.120 --> 41:16.360]  обязательно. Да, они обязательно в разных, поэтому вот эта вот последняя, она активная, она в новой доле
[41:16.360 --> 41:21.880]  по сравнению с предыдущей вершиной. Поэтому для нее выполняется утверждение, ну, в смысле,
[41:21.880 --> 41:34.800]  заключение утверждения нашего, что вот такой вот разрез меньше либо равен, чем С пересечь с AN,
[41:34.800 --> 41:40.000]  T пересечь с AN. Ну, а AN это просто все вершины, потому что мы как-то там все перенумеровали,
[41:40.000 --> 41:47.320]  и AN это все вершины. Здесь остается просто CST. Ну все, отсюда следует то, что нам нужно,
[41:47.320 --> 41:53.200]  что вот этот разрез, который мы нашли, он на самом деле не больше, чем любой другой.
[41:53.200 --> 42:01.520]  Окей? Тогда мой долг доказать вот это утверждение, из него следует все,
[42:01.520 --> 42:20.040]  все для, ну, собственно, то, что мы хотели доказать. Вот. Странно вроде всегда доказывалось,
[42:20.040 --> 42:30.280]  сейчас что-то не получилось. Ну ладно, тогда давайте не будем терять время, перейдем к
[42:30.280 --> 42:35.160]  минимальным, значит, поток минимальной стоимости, потоки минимальной стоимости,
[42:43.160 --> 42:49.880]  потоки минимальной стоимости. Начну здесь, конструкция такая. Теперь у нас есть какой-то штраф,
[42:49.880 --> 42:54.960]  который мы платим за то, чтобы протолкнуть единицу потока по ребру. То есть теперь у каждого
[42:54.960 --> 43:02.800]  ребра, кроме capacity, появляется также какая-то стоимость, кост. И это значит, что если я пропускаю
[43:02.800 --> 43:09.000]  единичку потока по этому ребру, то я плачу кост, не знаю, кост рублей в бюджет. Да, и если я,
[43:09.000 --> 43:15.080]  скажем, пускаю здесь F единиц потока, то мой штраф за это ребро равен F умножить на кост.
[43:15.080 --> 43:21.640]  Равен F умножить на кост. Значит, тогда, соответственно, суммарный штраф, это сумма по всем
[43:21.640 --> 43:27.680]  ребрам. Величина потока умножить на стоимость, пускай не единички потока по ребру. Вот, значит,
[43:27.680 --> 43:41.240]  суммарный штраф. Это сумма по всем ребрам F от E на кост от E. И наша задача, например,
[43:41.240 --> 43:55.520]  такая. Min-coast k-flow. Min-coast k-flow. Это найти поток величины k минимальной стоимости. То есть
[43:55.520 --> 44:00.000]  мы хотим протокнуть k единиц потока, при этом так, чтобы общая стоимость была суммарно минимально
[44:00.000 --> 44:22.920]  возможна. Поток величины k минимальной суммарной стоимости. Суммарной стоимости. Вот, ну и
[44:22.920 --> 44:31.560]  родственная задача. Min-coast max-flow. То же самое, только k равно просто величине максимального потока
[44:31.560 --> 44:49.320]  в сети. Тоже только k равно max-flow. Вот, ну и как мы увидим, научившись решать эту задачу,
[44:49.320 --> 44:53.520]  мы научимся решать вот эту, потому что мы там просто будем пускать по единичке потока каждый
[44:53.520 --> 44:58.200]  раз. Один, два, три и так далее. И так, в общем, пока в остаточной сети есть путь, мы будем пускать
[44:58.200 --> 45:03.000]  поток, тем самым найдем максимальный поток, при этом минимальной стоимости. Если у нас на каждом
[45:03.000 --> 45:22.560]  шаге было минимальный, то в конце тоже минимальный. Так, при этом, чтобы у нас все работало,
[45:22.560 --> 45:27.640]  нам нужно будет добавлять обратные ребра, ну как всегда, в задачах на потоке мне нужны также
[45:27.640 --> 45:33.480]  обратные ребра. И здесь, вот если у меня было прямое ребро с весом кост, то обратное будет
[45:33.480 --> 45:40.280]  со стоимостью минус кост. Это отвечает, собственно, тому, что... Что такое вообще пустить единичку
[45:40.280 --> 45:44.160]  потока по обратному пути? Это, по сути, отменить ту единицу, которую мы выпустили по прямому
[45:44.160 --> 45:48.680]  ребру. То есть, если здесь мы заплатили, скажем, кост рублей и протокнули единицу потока сюда,
[45:48.680 --> 45:52.680]  теперь хотим ее отменить, то мы как бы должны заплатить минус кост, то есть нам должны вернуть
[45:52.680 --> 46:03.000]  кост. Вот как раз это означает, что нам вернется та самая величина, которую мы заплатили. Вот. И
[46:03.000 --> 46:11.280]  ну тогда алгоритм, на самом деле, будет довольно простой. Алгоритм такой. Алгоритм Минко-Скофлоу.
[46:15.280 --> 46:22.160]  Он просто ка раз находит в остаточной сети самый дешевый путь, самый дешевый, в смысле,
[46:22.160 --> 46:26.600]  из стоимости. Находит самый дешевый путь, пускает по нему единичку потока и перестраивает
[46:26.600 --> 46:38.400]  остаточную сеть, так делает ка раз. Значит, и от одного дока найти самый дешевый путь в остаточной сети,
[46:38.400 --> 46:50.280]  дешевый по кост, в смысле, путь в gf, ну и пустить по нему единицу потока.
[46:50.280 --> 47:11.640]  Ну, с одной стороны, похоже на Айдманскарпа, потому что мы когда-то уже так делали. Мы там искали самый
[47:11.640 --> 47:16.760]  короткий, ну, кратчайший путь и пускали по нему поток. Только там, кратчайшись, понималось в смысле
[47:16.760 --> 47:21.560]  числа ребер, там все ребра были невзвешеные, а тут у нас появляются стоимости, поэтому нам нужно будет писать
[47:21.560 --> 47:27.840]  что-то типа Дэйкстры или Форда Бэлмана, который находит кратчайший путь от одной вершины до другой, до Т.
[47:27.840 --> 47:45.960]  Ну, имеется в виду, конечно, путь из-за С в Т. Ну и мы знаем, что, скажем, алгоритм Форда Бэлмана
[47:45.960 --> 47:51.080]  ну, в общем, с Дэйкстра здесь, как бы, на первый взгляд, проблема, потому что могут быть отрицательные
[47:51.080 --> 47:54.960]  ребра. Да, Дэйкстра не умеет с отрицательными ребрами работать, мы научимся с этим разбираться,
[47:54.960 --> 48:07.280]  но по умолчанию мы здесь можем писать алгоритм Форда Бэлмана. Алгоритм Форда Бэлмана. Он нам
[48:07.280 --> 48:11.680]  позволяет находить кратчайший путь в этой сети, в остаточной сети, даже с учетом отрицательных
[48:11.680 --> 48:17.040]  ребер. Ну и вот, собственно, по нему опускаем 1 поток. Почему это верно? Чтобы доказать,
[48:17.040 --> 48:27.480]  что алгоритм находит правильный ответ, нам нужна будет такая лемма сначала. Лемма. Пусть Ф это поток
[48:27.480 --> 48:46.240]  величины К, поток величины К, тогда Ф минко с кафлоном, если и только если в остаточной сети
[48:46.240 --> 48:54.440]  относительно него нет циклов отрицательного веса. Нет циклов отрицательного веса.
[48:58.080 --> 49:06.760]  То есть, собственно, у нас будет сейчас критерий того, что какой-то поток является потоком минимальной
[49:06.760 --> 49:10.400]  стоимости, то есть в остаточной сети не должно быть циклов отрицательного веса.
[49:10.400 --> 49:23.920]  Значит, ну почему это так? Доказательства скажем слева-направо. Лево-направо очевидно,
[49:23.920 --> 49:28.680]  если Ф это минкост кафлог, и при этом в остаточной сети есть какой-то отрицательный цикл. Пусть есть
[49:28.680 --> 49:40.240]  отрицательный цикл. То есть, в остаточной сети есть какой-то замкнутый маршрут, такой,
[49:40.240 --> 49:44.720]  что здесь вся капаситет положительная, и при этом сумма кастов отрицательна. Значит,
[49:44.720 --> 49:48.800]  если я просто по этому замкнутому маршруту пущу денечку потока, то у меня, во-первых,
[49:48.800 --> 49:53.520]  поток останется потоком величины К, потому что вот такая циркуляция, когда водичка просто
[49:53.520 --> 49:58.600]  течет по контуру, это не меняет величины потока, и при этом это будет, по-прежнему,
[49:58.600 --> 50:07.000]  корректный поток. А стоимость уменьшится. Добавим циркуляцию по этому циклу.
[50:14.520 --> 50:21.800]  Ну, собственно, останется поток тоже величины, потому что в каждую, ну, то есть, даже если кто-то
[50:21.800 --> 50:25.880]  из них С, то в него что-то втекло и что-то вытекло. Короче, эта единичка, которую мы пустили,
[50:25.880 --> 50:30.280]  она не повлияет на величину потока. То есть, величина потока не изменится, а при этом стоимость
[50:30.280 --> 50:37.480]  уменьшится. Значит, наш исходный поток был не минимальным. Противоречие. Теперь обратно.
[50:37.480 --> 50:49.000]  Значит, пусть нет резатных циклов, но пусть F не минимальный. Пусть F не минкост кофлоу.
[50:49.000 --> 51:03.600]  Тогда рассмотрим настоящий минкост кофлоу. Значит, F звездочка, настоящий минкост кофлоу.
[51:03.600 --> 51:22.320]  И рассмотрим вот такой поток. F звездочка, минус F. Значит, это будет тоже поток. Ну,
[51:22.320 --> 51:28.800]  F звездочка, минус F. То есть, мы на каждом ребре просто вычитаем то, что текло в одном потоке из того,
[51:28.800 --> 51:32.400]  что текло на другом потоке. Это будет тоже поток. Можно там убедиться, что все неравенцы
[51:32.400 --> 51:37.840]  сохраняются, которые требуются в определении потока. При этом это будет поток величины ноль.
[51:37.840 --> 51:48.280]  Потому что если в F к единиц потока исходила из S, и в F звездочка тоже к единиц потока исходила из S,
[51:48.280 --> 51:53.880]  то значит, они все друг друга убьют. Останется ноль единиц потока, которые исходили из S,
[51:53.880 --> 51:59.040]  поэтому величина останется нулевая. Значит, это поток величины ноль. То есть, это опять циркуляция.
[51:59.040 --> 52:24.200]  При этом отрицательного веса. Да, потому что это поток минимальной стоимости, это поток чуть
[52:24.200 --> 52:28.000]  большей стоимости, поэтому их разность имеет отрицательную стоимость. Минимум, минус что-то
[52:28.000 --> 52:33.840]  побольше, а это что-то отрицательное. Получился у нас поток отрицательной стоимости, величины ноль.
[52:38.600 --> 52:44.520]  Но это на самом деле значит, что относительно F у нас есть отрицательный цикл. В остаточности есть
[52:44.520 --> 52:51.000]  отрицательный цикл. Как выглядит такая циркуляция? Несколько таких циклов.
[52:58.000 --> 53:06.760]  Таких, что на них течет суммарный стоимость всех этих циклов отрицательно. Среди них есть хотя
[53:06.760 --> 53:19.880]  бы один отрицательный цикл. Среди них есть хотя бы один отрицательный цикл отрицательного веса.
[53:19.880 --> 53:24.280]  Значит, по нему можно, скажем, пустить единичку потока бесплатно. Ну, собственно, это и будет,
[53:24.280 --> 53:30.040]  скажем, если здесь вес ноль, то это и будет тот самый цикл отрицательного веса в остаточности GF.
[53:30.040 --> 53:36.520]  Ну и, собственно, все. Противоречие с тем, что мы предположили, что таких циклов нет.
[53:36.520 --> 53:53.040]  А зачем нам бесконечно это делать? Вы про вот это, да? Не, нам не надо еще раз, смотрите,
[53:53.040 --> 53:56.640]  мы просто берем один цикл отрицательный, пускаем по нему единичку потока, мы это можем сделать
[53:56.640 --> 54:01.760]  один раз. И стоимость уменьшилась от этого. Противоречие, мы предполагаем, что изначально у нас
[54:01.760 --> 54:06.680]  была минимальная стоимость, а получили меньше. Нам не надо бесконечно, нам достаточно один раз.
[54:06.680 --> 54:19.480]  Вот, тем самым у нас есть критерий минимальности какого-то потока. Это значит, что в остаточности не
[54:19.480 --> 54:30.760]  должно быть циклов отрицательного веса. Давайте подумаем.
[54:49.480 --> 55:03.920]  Так-так-так-так-так, начнем поток включить ноль в исходной сети GF.
[55:19.480 --> 55:33.040]  То есть, если вот нарисую GF, у меня будет какая-то сеть, остаточная сеть, такая, что остаточная
[55:33.040 --> 55:40.600]  capacity у всех ребер будет что-то типа исходная capacity минус F от E. Дальше я строю новый поток G,
[55:40.600 --> 55:50.280]  и получается, что поток по ребру равен F звездочка минус F от E. И тогда, соответственно,
[55:50.280 --> 55:58.600]  остаточная capacity после этого есть исходная capacity минус F звездочка от E плюс F от E.
[56:10.600 --> 56:37.200]  Ну да, уже с индексом же маленько, да.
[56:40.600 --> 56:53.320]  Ну да, окей, значит, есть вот такой вот отрицательный цикл сети G с индексом G. И что это значит?
[56:53.320 --> 57:00.040]  Значит, здесь все остаточные capacity положительные. То есть, вот эти штуки положительные. Нам хотелось
[57:00.040 --> 57:06.040]  бы показать, что все тогда вот такие штуки положительные, чтобы можно было бы по этому
[57:06.120 --> 57:15.600]  же циклу пропустить единицу потока. Ну или хотя бы чтобы на одном цикле так было.
[57:15.600 --> 57:26.000]  Так, значит, поток отрицательной стоимости и отрицательный цикл.
[57:45.600 --> 58:00.000]  Так, значит, поток отрицательной стоимости и отрицательный цикл.
[58:00.000 --> 58:14.400]  Так, значит, поток отрицательной стоимости и отрицательный цикл.
[58:14.400 --> 58:28.800]  Так, значит, поток отрицательной стоимости и отрицательный цикл.
[58:28.800 --> 58:38.800]  Так, значит, поток отрицательной стоимости и отрицательный цикл.
[58:38.800 --> 59:05.200]  Так.
[59:05.200 --> 59:15.600]  Так.
[59:35.200 --> 59:37.600]  Так.
[01:00:05.600 --> 01:00:07.600]  Так.
[01:00:15.600 --> 01:00:17.600]  Все, момент.
[01:00:17.600 --> 01:00:41.200]  Значит, смотрите, вот у нас есть два потока, да, F и F звездочка. F и F звездочка. Значит,
[01:00:41.200 --> 01:00:48.800]  я строю вот тот поток. Хочу, на самом деле, показать, что это будет во старшинности GF. Что
[01:00:48.800 --> 01:00:56.560]  во старшинности GF будет вот такой отрицательный цикл. То есть я утверждаю, что как бы F равно F
[01:00:56.560 --> 01:01:06.480]  звездочка плюс несколько циклов, плюс несколько циклов, ну то есть циркуляция, да, можно написать,
[01:01:06.480 --> 01:01:16.800]  плюс циркуляция, GF. Вот. Значит, для этого я рассматриваю их разность.
[01:01:16.800 --> 01:01:27.440]  Звездочка минус F. Понятно, что это какие-то отрицательные циклы. Почему GF? Ну, надо,
[01:01:27.440 --> 01:01:38.120]  надо, видимо, понять, какие, как выглядит capacity. Ну, вот смотрите, если я на каком-то
[01:01:38.120 --> 01:01:48.240]  ребре напишу, да, звездочка E минус F от E. Значит, это меньше либо равно чем, то есть поток по
[01:01:48.240 --> 01:02:01.440]  каком-то ребру G от E не больше чем C от E минус F от E, что, собственно, есть осащенная пропускная
[01:02:01.440 --> 01:02:10.160]  способность в графе GF. Ну, собственно, да, вот получилось. То есть, смотрите, есть у нас вот эти
[01:02:10.160 --> 01:02:16.200]  вот два потока, которые мы один из другого вычли. Тогда поток, текущий по ребру E, это вот эта вот
[01:02:16.200 --> 01:02:22.800]  разность. Оцениваем первый из них через capacity ребра. Ну, а такая разность, это осащенная
[01:02:22.800 --> 01:02:30.680]  пропускная способность в графе GF. То есть это capacity в GF. Получается, что поток по ребру в
[01:02:30.680 --> 01:02:36.760]  циркуляции же не превосходит осащенной capacity, то есть, ну, в общем, в этой осащенности оно есть.
[01:02:36.760 --> 01:02:42.400]  Поэтому все вот эти циклы, на них действительно поток не больше, чем осащенные capacity в GF,
[01:02:42.400 --> 01:02:54.720]  поэтому все такие циклы у нас есть. Вот вроде получилось. Итак, ну, хорошо. Лему вроде как
[01:02:54.720 --> 01:03:02.960]  доказали. Теперь, чтобы доказать корректность этого алгоритма, который к раз просто находит
[01:03:02.960 --> 01:03:09.880]  минимальный путь в осащенной сети, в смысле самый дешевый путь в осащенной сети, то нам
[01:03:09.880 --> 01:03:19.720]  достаточно доказать следующее, что утверждение после этого шага наш алгоритм находит корректный
[01:03:19.720 --> 01:03:42.200]  минкост и flow. Находит корректный минкост и flow. При условии, что в исходном графе GF нет циклов
[01:03:42.200 --> 01:04:01.320]  отрицательного веса, что в GF нет циклов отрицательного веса. То есть, в исходном
[01:04:01.320 --> 01:04:05.880]  графе мы считаем, что нет плохих циклов. Дальше мы каждый раз спускаем самый дешевый путь в
[01:04:05.880 --> 01:04:11.240]  осащенной сети, так делаем K раз, и утверждаем, что после каждого шага у нас будет минкост-поток,
[01:04:11.240 --> 01:04:16.280]  то есть, что эквивалентно, после каждого шага в осащной сети не будет появляться отрицательных
[01:04:16.280 --> 01:04:21.960]  циклов. Поэтому нам достаточно показать, что если отрицательных циклов не было в начале,
[01:04:21.960 --> 01:04:35.480]  то они не появятся никогда по дороге. Достаточно доказать, что не появляется отрицательных циклов.
[01:04:41.240 --> 01:04:49.720]  Ну пусть появляются. Вот у нас была какая-то хорошая осащенная сеть GF, мы в ней нашли
[01:04:49.720 --> 01:04:54.160]  кратчайший путь, самый дешевый в плане стоимости, пустили по нему динечку потока,
[01:04:54.160 --> 01:05:00.880]  перестроили осащенную сеть, и у нас появился отрицательный цикл. Вот пусть GF, а был какой-то
[01:05:00.880 --> 01:05:07.440]  путь P, кратчайший путь, мы по нему протолкнули динечку потока, и потом вдруг появился отрицательный
[01:05:07.440 --> 01:05:13.000]  цикл. То есть раньше не было, теперь появился. Ну как он может тогда выглядеть? Раз он появляется,
[01:05:13.000 --> 01:05:16.880]  его раньше не было, то он обязательно должен использовать одно из вновь появившихся ребер.
[01:05:16.880 --> 01:05:22.240]  То есть обязательно хотя бы одно из таких обратных ребер он должен использовать. Потому что если
[01:05:22.240 --> 01:05:27.280]  он ни одно из этих обратных ребер не использует, которые позволяют отменять вдоль пути P, то
[01:05:27.280 --> 01:05:31.720]  соответственно он использует только остальные ребра, значит цикл был в исходной сети. То есть хотя
[01:05:31.720 --> 01:05:37.600]  бы одно такое ребро мы используем. Давайте я какую-нибудь картинку нарисую, вот это был P. Что-нибудь
[01:05:37.600 --> 01:05:45.640]  вот такое может быть, например. У нас мог появиться в осащенном сети GF штрих вот такой вот отрицательный
[01:05:45.640 --> 01:06:08.320]  цикл. Давайте его назову C. Пусть в GF штрих появляется отрицательный цикл C. Тогда смотрите,
[01:06:08.320 --> 01:06:26.200]  давайте я в GF посмотрим поток. Рассмотрим поток. Ну я вот так назову P плюс C. То есть давайте
[01:06:26.200 --> 01:06:33.320]  вот в этой исходной сети GF пущу единичку потока здесь и единичку потока по этому циклу. Что у меня
[01:06:33.320 --> 01:06:37.760]  получится? Ну во-первых, потому что этот цикл, у меня останется поток величины 1. Как он будет
[01:06:37.760 --> 01:06:41.240]  выглядеть на этом конкретном примере? Вот смотрите, здесь у меня текла туда единичка,
[01:06:41.240 --> 01:06:49.360]  но я ее здесь отменил. То есть по сути разорвал вот этот путь. Значит у меня будет... Так,
[01:06:49.360 --> 01:06:55.840]  сейчас я нарисую. Значит будет вот здесь вот циркуляция, вот такая. И будет вот такой вот путь,
[01:06:55.840 --> 01:07:02.720]  по которому течет поток. В данном конкретном случае, если я сложу этот путь и вот этот цикл,
[01:07:02.720 --> 01:07:08.120]  то у меня останется цикл и путь. И так будет, соответственно, всегда. Если у меня есть поток
[01:07:08.120 --> 01:07:13.120]  величины 1 и поток величины 0, то есть путь и циркуляция, я их сложу, у меня останется какой-то
[01:07:13.120 --> 01:07:17.760]  поток величины 1, то есть какой-то путь из старта в T, из S в T. И еще какая-то циркуляция, там
[01:07:17.760 --> 01:07:31.400]  будет несколько циклов. Вот эта штука, это путь плюс циркуляция. Потому что это поток величины
[01:07:31.400 --> 01:07:38.040]  1, значит это один путь с капостью 1 из S в T. И еще там несколько циклов возможно. Вот,
[01:07:38.040 --> 01:07:43.120]  но при этом смотрите, этот путь обязательно имеет вес больше либо равный, чем вес P, потому что P
[01:07:43.120 --> 01:07:47.840]  был кратчайший. Это какой-то путь в остаточности GF. Значит этот путь имеет величину, стоимость
[01:07:47.840 --> 01:07:56.040]  хотя бы как у P. А эта циркуляция в GF, то есть это несколько циклов в исходном графе GF, поэтому они
[01:07:56.040 --> 01:08:00.520]  все имеют вес не отрицательным. Мы предположим, что в GF отрицательных циклов нет. Значит эта штука
[01:08:00.520 --> 01:08:06.520]  большая на P, а эти все не отрицательные. По стоимости больше обыкновенна, чем стоимость P,
[01:08:06.520 --> 01:08:16.240]  а это все не отрицательные. Так.
[01:08:30.520 --> 01:08:42.080]  Но при этом вот эта вот вещь, мы же предположили, что стоимость C отрицательна. Получается,
[01:08:42.080 --> 01:08:50.160]  что стоимость вот этой вот вещи, она как бы меньше должна быть, чем стоимость P, противоречие. То есть
[01:08:50.160 --> 01:08:56.280]  с одной стороны стоимость P плюс C меньше, чем стоимость P, потому что это P плюс что-то отрицательное.
[01:08:56.280 --> 01:08:58.360]  Давайте я напишу на этой доске.
[01:09:07.120 --> 01:09:23.160]  Итак, с одной стороны стоимость P плюс C равна стоимость P плюс стоимость C. Это меньше, чем стоимость
[01:09:23.160 --> 01:09:31.960]  P, потому что P это отрицательный цикл. С другой стороны, P плюс C это какой-то путь уличный хотя бы
[01:09:31.960 --> 01:09:38.520]  кост P и несколько циклов, все из которых не отрицательные. Ну, противоречие. С другой стороны,
[01:09:38.520 --> 01:09:53.640]  кост P плюс C больше равно, чем кост P, плюс что-то не отрицательное. То есть она меньше, с другой
[01:09:53.640 --> 01:10:01.360]  стороны больше она равна. Противоречие, значит, не могло быть такого цикла C, значит, если его не было
[01:10:01.360 --> 01:10:04.320]  в исходной сети, то его не будет ни после какого момента времени.
[01:10:09.360 --> 01:10:15.760]  Вот. Ну что, значит, наш алгоритм корректен. Если в исходной сети, вот прям в G, в исходном нет
[01:10:15.760 --> 01:10:27.760]  отрицательных циклов, то они никогда и не появляются. Они никогда не появятся. Поэтому наш алгоритм,
[01:10:27.760 --> 01:10:32.080]  скажем, Форда Белмана, он будет просто отлично работать. Напоминаю, что алгоритм Форда Белмана,
[01:10:32.080 --> 01:10:38.040]  там нужно немножко что-то обновить, если есть отрицательные циклы. Если есть отрицательные циклы,
[01:10:38.040 --> 01:10:43.080]  то нужно делать на одну итерацию больше. Там тогда на каждом цикле хотя бы в одной вершинке что-то
[01:10:43.080 --> 01:10:46.960]  меньше надо запустить. Ну, в общем, и так далее. Бывают расстояния равны минус бесконечности,
[01:10:46.960 --> 01:10:52.640]  а тут такого не будет, потому что нет таких циклов. Ну и так. Нет отрицательных циклов.
[01:10:52.640 --> 01:10:58.480]  Следовательно, Форт Белман работает очень хорошо.
[01:10:58.480 --> 01:11:12.080]  Работает, ну, я имею в виду, без всяких минус бесконечности. Не надо вот с этим лишний раз
[01:11:12.080 --> 01:11:19.360]  запариваться. Хорошо. Значит, в итоге алгоритм такой, что мы просто на каждом шаге, вот у нас
[01:11:19.360 --> 01:11:24.080]  есть исходная сеть без отрицательных циклов, находим корочайший путь с помощью Форт Белмана,
[01:11:24.080 --> 01:11:30.640]  пускаем поднимающую потоку, перестраиваем сеть и так делаем K раз. Асимптотика, соответственно,
[01:11:30.640 --> 01:11:37.840]  будет от K умножить на асимптотику Форда Белмана, это, ну, видимо, VE.
[01:11:37.840 --> 01:11:46.480]  Форт Белман — это динамика, в которой V слоев и каждый слой пересчитывается за VE.
[01:11:46.480 --> 01:11:58.440]  Так, хорошо. Вот, но на самом деле можно делать все-таки что-то похожее с помощью алгоритма
[01:11:58.440 --> 01:12:02.800]  Dijkstra. То есть, смотрите, Dijkstra как бы сама в себе неприменима, потому что у нас есть вот
[01:12:02.800 --> 01:12:06.800]  эти отрицательные ребра. Если мы что-то пустили, то у меня появилось обратное ребро отрицательного
[01:12:06.800 --> 01:12:11.840]  веса, и как бы Dijkstra с ними по умолчанию работать не умеет. Вот, но мы сейчас ведем,
[01:12:11.840 --> 01:12:17.320]  так называем, потенциалу Джонсона, который нам позволит нашу Dijkstra модифицировать.
[01:12:17.320 --> 01:12:29.840]  Вот, смотрите, пусть VE — это какая-то функция, тогда мы можем следующим образом исправить
[01:12:29.840 --> 01:12:39.440]  стоимость любого ребра у V. Я буду называть эту функцию потенциалом. Тогда стоимость после
[01:12:39.440 --> 01:12:45.360]  применения потенциала — это стоимость до применения потенциала, плюс потенциал начала,
[01:12:45.360 --> 01:12:54.400]  минус потенциал конца. Fiat-V. Значит, вот так изменяем веса всех ребер. Прелесть такого
[01:12:54.400 --> 01:12:58.800]  преобразования в том, что у нас не изменятся кратчайшие пути между любой парой вершин.
[01:12:58.800 --> 01:13:05.880]  Потому что как устроен путь? Вот есть какой-то путь P из одной вершины в другую. Как меняется
[01:13:05.880 --> 01:13:12.720]  его стоимость при навешивании, при переходе от костов к костам с индексом phi. Давайте проследим.
[01:13:12.720 --> 01:13:19.640]  У нас добавится phi от начала здесь, вычтется phi отсюда. Дальше, на этом ребре добавится phi здесь,
[01:13:19.640 --> 01:13:23.240]  вычтется phi здесь. То есть вот это вот как бы уничтожится. Здесь было плюс phi и минус phi.
[01:13:23.240 --> 01:13:29.000]  Здесь тоже самое. Плюс от ребра и минус от этого ребра. Поэтому здесь тоже уничтожится. Короче,
[01:13:29.000 --> 01:13:34.960]  по всем вот этим промежуточным вершинам у меня потенциал не войдет. У меня останется только плюс
[01:13:34.960 --> 01:13:41.400]  потенциал начала, минус потенциал конца. Давай так напишем, что исправленный потенциал,
[01:13:41.400 --> 01:13:49.640]  ну точнее исправленный вес любого пути, это его исходная стоимость, плюс потенциал старта,
[01:13:49.640 --> 01:13:56.680]  минус потенциал конца. В частности, это означает, что у меня не поменялись кратчайшие пути сами
[01:13:56.680 --> 01:14:04.240]  по себе. То есть любой путь по стоимости изменился вот на такую поправочку. И если у меня S и T это
[01:14:04.240 --> 01:14:07.680]  какие-то фиксированные вершины, то значит, что они все поменялись на одну и ту же константу,
[01:14:07.680 --> 01:14:12.400]  которая не зависит от пути. Значит, если на каждом пути мне прибавили одну и ту же константу,
[01:14:12.400 --> 01:14:17.320]  значит все кратчайшие пути сохранились. Они просто изменили свой вес вот на столько.
[01:14:17.320 --> 01:14:25.960]  И при этом мы хотим, чтобы после навешивания этих потенциалов у нас все косты стали
[01:14:25.960 --> 01:14:34.600]  не отрицательными, чтобы можно было DX пускать. Мы хотим, чтобы кост Фи от УВ было
[01:14:34.600 --> 01:14:49.480]  всегда не отрицательным. Это можно сделать следующим способом. Пустим один раз алгоритм
[01:14:49.480 --> 01:15:03.400]  Форда Белмана и положим, что Фи от В это DIST SV. Раньше я пускал карат Форда Белмана,
[01:15:03.400 --> 01:15:08.240]  теперь я запущу его только один раз. И скажу, что потенциал каждой вершины равен расстоянию от S
[01:15:08.240 --> 01:15:14.480]  до нее, которую мы нашли в алгоритме Форда Белмана. Тогда смотрите, что такое кост Фи для какого-то
[01:15:14.480 --> 01:15:28.200]  ребра. Это кост УВ плюс DIST SU минус DIST SV. Я хочу понять, что это не отрицательно,
[01:15:28.200 --> 01:15:33.280]  но это просто не нравится треугольника. Если я примесю это в правую часть, у меня здесь написано
[01:15:33.280 --> 01:15:46.880]  следующее, что DIST SV не больше, чем кост УВ, плюс DIST SU. Это очевидно, что если есть какой-то
[01:15:46.880 --> 01:15:54.800]  путь до У и можно пройти ребро УВ, то вес пути до В он меньше равен, чем вот этот. Мы взяли
[01:15:54.800 --> 01:16:00.640]  кратчайший путь от S до У, дальше приклеили ребро УВ. Понятно, что кратчайший путь от S до В либо такой,
[01:16:00.640 --> 01:16:04.800]  либо еще меньше. То есть, возможно, есть какой-то более короткий от S до В, но такой точно есть,
[01:16:04.800 --> 01:16:15.280]  поэтому это не нравится у нас. Если мы потенциально возьмем функцию расстояний и потом пересчитаем
[01:16:15.280 --> 01:16:19.920]  с ее помощью все стоимости всех ребер, тогда у меня получится, что эти стоимости не отрицательны,
[01:16:19.920 --> 01:16:31.400]  а значит, на них можно пускать DXT. Ну хорошо, давайте мы один раз пустили Форда Белмана,
[01:16:31.400 --> 01:16:37.640]  посчитали все потенциалы, то есть все расстояния. Теперь у меня все стоимости вот эти не отрицательны,
[01:16:37.640 --> 01:16:42.240]  и я понимаю, что искать кратчайшие пути в терминах кост В, то же самое, что искать кратчайшие пути
[01:16:42.240 --> 01:16:48.320]  в терминах кост. Они все изменились только на константу, но сами пути не изменились. Поэтому давайте
[01:16:48.320 --> 01:17:08.200]  найдем, пустим алгоритм DXT. Как он отработает? На весах кост с индексом Фи. То есть мы обновили
[01:17:08.200 --> 01:17:17.680]  стоимости, теперь все стоимости это кост Фи. Как он отработает? Во-первых, мы понимаем,
[01:17:17.680 --> 01:17:23.720]  что все веса не отрицательны, все вот эти косты индексом Фи больше нуля. Но также мы можем легко
[01:17:23.720 --> 01:17:30.000]  заметить, что стоимость всех вот этих вот ребер, стоимость этого пути, это в точности ноль. Потому
[01:17:30.000 --> 01:17:35.640]  что раньше, поскольку мы, ну то есть до этого, мы только что пускали Форда Белмана из С, и на каждой
[01:17:35.640 --> 01:17:41.520]  вершине написали ее расстояние, расстояние от С до нее, а дальше все вот эти вот косты пересчитали,
[01:17:41.520 --> 01:17:46.680]  как стоимость там, плюс разность расстояний. То на самом деле, тогда на всех этих ребрах кост
[01:17:46.680 --> 01:17:54.640]  Фи нулевое, на всех ребрах на кратчайшем пути от С до Т кост Фи нулевое. А почему? Потому что
[01:17:54.640 --> 01:18:07.320]  кост Фи у В это, ну давайте напишем, кост у В плюс Фиату минус Фи от В. Но поскольку это все кратчайший
[01:18:07.320 --> 01:18:13.320]  путь от С до Т, то это в частности кратчайший путь от С до В. Значит, Фи от В отличается от Фиату
[01:18:13.320 --> 01:18:27.960]  ровно на эту стоимость, поэтому это ноль. На ноль на кратчайшем пути от С до Т. То есть, как будто бы
[01:18:27.960 --> 01:18:33.040]  можно даже было бы не пускать Dx, а просто найти произвольный путь веса ноль из С до Т. То есть,
[01:18:33.040 --> 01:18:37.280]  как будто бы мы наставляем только ребра стоимости ноль, ну и там скажем, с помощью Dfs мы находим
[01:18:37.280 --> 01:18:45.400]  произвольный путь из С до Т. Это будет самый короткий путь из С до Т. Но при этом после того,
[01:18:45.400 --> 01:18:51.120]  как я опускаю днику потока здесь, у меня появляются обратные ребра. Но тоже нулевого
[01:18:51.120 --> 01:18:54.840]  веса, нулевой стоимости. Потому что если здесь была нулевая стоимость, то здесь тоже стоимость
[01:18:54.840 --> 01:19:08.040]  будет ноль. Противоположно, это ноль. И тогда как будто бы опять у нас не появляется отрицательных
[01:19:08.040 --> 01:19:14.080]  ребер. То есть, мы опустили днику потока здесь, появилось несколько обратных со стоимостью ноль,
[01:19:14.080 --> 01:19:19.320]  ну как будто бы опять применил алгоритм Dx. Потому что нет отрицательных ребер, не появилось
[01:19:19.320 --> 01:19:26.360]  отрицательных ребер. На самом деле это пока что верно. На следующей терации все ребра не отрицательны,
[01:19:26.360 --> 01:19:31.000]  но потом уже, вот на второй терации, если я опять запущу алгоритм Dx, у меня получится так,
[01:19:31.000 --> 01:19:38.680]  что путь, который я найду, он уже возможно не обязательно состоит из нулей. И там могут быть
[01:19:38.680 --> 01:19:42.360]  ребра положительного веса, и соответственно обратное к ним будет отрицательно. Поэтому мы сделаем
[01:19:42.360 --> 01:19:52.440]  следующее. Вот мы опустили алгоритм Dx. Пусть, давайте напишу Pseud V, это dist Sv, который нашел
[01:19:52.440 --> 01:20:08.400]  алгоритм Dx. Который нашел алгоритм Dx. И дальше, ну как бы, что мне было важно, почему я смог
[01:20:08.400 --> 01:20:14.120]  применить алгоритм Dx здесь? В смысле, почему все веса были не отрицательны и веса обратных ребер
[01:20:14.120 --> 01:20:21.240]  тоже были не отрицательны? Потому что к этому моменту потенциал это был dist Sv. То есть вот
[01:20:21.240 --> 01:20:27.200]  к этому моменту потенциал это была функция расстояния от S до V. Теперь, значит, я хочу сделать
[01:20:27.200 --> 01:20:30.960]  то же самое. То есть у меня теперь опять есть какая-то сеть, я пускаю в ней единичный поток,
[01:20:30.960 --> 01:20:37.120]  поток единичной и единичной величины. Как-то у меня перестраивается граф. Я хочу опять, чтобы новая
[01:20:37.120 --> 01:20:40.560]  функция, вот эта вот Pseud, опять была функцией расстояния. Ну вот, я ее, собственно, с помощью
[01:20:40.560 --> 01:20:46.600]  Dx нашел. Дальше, чтобы правильно пересчитать потенциалы, мне нужно еще кост, ну, обновить на
[01:20:46.600 --> 01:20:55.320]  величину вот этого потенциала. То есть сделать так кост у V. Сейчас, секунду. То есть мне нужно
[01:20:55.320 --> 01:21:01.120]  теперь вот в этой остаточной сети применить то же самое преобразование, что я сделал с phi,
[01:21:01.120 --> 01:21:05.760]  только теперь с Pseud. То есть нужно как бы учесть в потенциале наш потенциал Pseud, который мы нашли.
[01:21:05.760 --> 01:21:15.440]  То есть нужно просто все стоимости, ну вот, опять увеличить на Pseud от U и уменьшить на Pseud от V.
[01:21:15.440 --> 01:21:25.440]  И тогда у меня опять будет верно, что потенциал, который вот я сделал, у них это функция расстояния,
[01:21:25.440 --> 01:21:33.680]  это функция расстояния. Значит опять все ребра не отрицательны. Корочайший путь, это путь по нулевым
[01:21:33.680 --> 01:21:37.440]  ребрам. Значит, когда я сделаю следующий dx, у меня все обратные ребра тоже не отрицательны.
[01:21:37.440 --> 01:21:40.840]  Поэтому алгоритм можно написать такой.
[01:21:54.840 --> 01:22:00.520]  Значит, алгоритм. Ну, мне нужна будет процедура какая-нибудь типа Void. Применить потенциалы,
[01:22:00.520 --> 01:22:07.960]  применить потенциал, phi. Ну, это вот ровно вот для каждого ребра сделать вот то преобразование.
[01:22:07.960 --> 01:22:17.520]  Для любого ребра E нужно стоимость этого ребра исправить на phi от U минус phi от V.
[01:22:17.520 --> 01:22:23.760]  Значит, это вот такое применение потенциала ко всем ребрам. Дальше.
[01:22:23.760 --> 01:22:36.400]  Минкостка flow. Сначала мы считаем потенциальную функцию с помощью алгоритмов Форд Белмана.
[01:22:36.400 --> 01:22:53.720]  Форд Белман. Собственно apply потенциал phi. Ну, а затем k раз. Находим корочайший путь,
[01:22:53.720 --> 01:22:58.840]  пускаем по нему единичку потока и пересчитываем потенциал с помощью apply potential.
[01:22:58.840 --> 01:23:07.880]  Значит, phi это алгоритм Dijkstra. Ну, на нашем графе. На текущей версии графа как бы.
[01:23:07.880 --> 01:23:11.320]  Случно там вот этих вот уже примененных потенциалов.
[01:23:11.320 --> 01:23:16.600]  Значит, дальше пустить единицу потока. Не знаю как это написать.
[01:23:16.600 --> 01:23:22.640]  Комментарии, ладно. Пустить единицу потока.
[01:23:22.640 --> 01:23:37.320]  И потом просто apply потенциал phi. Потому что когда я это делаю, у меня опять,
[01:23:37.320 --> 01:23:45.120]  ну, я нашел корочайшее расстояние от вершины до, ну, от S до всех остальных,
[01:23:45.120 --> 01:23:51.640]  применил. Соответственно могу применить алгоритм Dijkstra и все проблемы устранил.
[01:23:51.640 --> 01:23:56.040]  То есть когда я вот здесь вот у меня появляются обратные ребра, возможно отрицательных весов,
[01:23:56.040 --> 01:24:00.720]  я потом это исправляю с помощью пересчета потенциалов функции psi.
[01:24:00.720 --> 01:24:05.800]  Вот, тем самым у меня алгоритм просто один раз Fort Bellman и потом k раз до extra.
[01:24:05.800 --> 01:24:16.800]  Вот это? Да-да-да, конечно. То есть мы нашли корочайший путь от S до всех, в частности от S до T.
[01:24:16.800 --> 01:24:21.440]  И вот по нему пускаем. Ну, корочайший у нас, конечно, всегда от S до T. В смысле,
[01:24:21.440 --> 01:24:26.400]  пускаем путь по корочайшему потоку от S до T. Значит, симптотика напишу. Ну,
[01:24:26.400 --> 01:24:33.640]  Fort Bellman у нас работает за VE, Dijkstra работает за, ну, например, kE log V.
[01:24:33.640 --> 01:24:40.440]  У нас была такая Dijkstra или можно написать, что это kV квадрат, например. Если у вас граф плотный,
[01:24:40.440 --> 01:24:45.680]  то здесь будет вместо E log V можно за V квадрат написать Dijkstra. Будет симптотика, ну, например,
[01:24:45.680 --> 01:24:50.360]  вот такая VE плюс kV квадрат. Всё, спасибо.
