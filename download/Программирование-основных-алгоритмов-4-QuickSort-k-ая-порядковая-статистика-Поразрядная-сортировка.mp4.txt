[00:00.000 --> 00:13.000]  Так, всем доброго утра. Давайте начнем. Мы с вами продолжаем сегодня заниматься сортировками.
[00:13.000 --> 00:23.000]  И, надеюсь, мы сегодня закончим этим заниматься. И дальше пойдем уже к деревьям поиска, скорее всего.
[00:23.000 --> 00:28.000]  Продолжение будет вылечено на сортировках.
[00:28.000 --> 00:41.000]  И первый сюжет, о котором мы говорим, это будет про сортировку.
[00:41.000 --> 00:53.000]  Точно ангрейтинг он не очень сложный. Давайте его быстренько и разберем.
[00:53.000 --> 01:16.000]  Шаг первый. Выберем опорный элемент. Вот здесь сочетаем, что мы пока не говорим как именно. Мы его убираем как то. Его убираем. То есть вот ваш.
[01:16.000 --> 01:32.000]  Допустим выбираем средний элемент. Шаг второй. Выполним так называемый partition.
[01:32.000 --> 01:41.000]  То есть что такое partition? От массива Х.
[01:41.000 --> 01:55.000]  То есть что этот шаг приводит к Ху, что мы выбираем упорный элемент, это Х. А partition от массива Х что он делает?
[01:55.000 --> 02:01.000]  Все так, да. То есть это у вас 3 Х, то у вас здесь все меньше Х, здесь все больше Х.
[02:01.000 --> 02:06.000]  У вас может быть много одинаковых элементов, поэтому давайте где-то равенство поставим.
[02:06.000 --> 02:18.000]  Убор. То есть это вам индекс И так называется.
[02:18.000 --> 02:26.000]  Перераспределили элементы.
[02:26.000 --> 02:38.000]  Чтобы слева меньше Х, справа больше либо равенство.
[02:38.000 --> 02:45.000]  Ну что тогда можно сказать? Можно сказать, что Х у нас стоит на нужном месте.
[02:45.000 --> 02:51.000]  И нам надо сферовать эту часть и эту часть к курсиву. Потому что это был Х стоит на победном месте.
[02:51.000 --> 02:54.000]  Где он должен стоять на цифровом массиве.
[02:54.000 --> 03:15.000]  Шаг третий. Это вызвать крюксот от массива 0 и и крюксот от кого? От индекса И.
[03:15.000 --> 03:27.000]  И плюс один. Ну это длина его.
[03:27.000 --> 03:30.000]  Ну все, победа.
[03:30.000 --> 03:37.000]  Главный алгоритм очень гениальный и простой. То есть если записать все доходом, то у вас будет выбирать пилот функция.
[03:37.000 --> 03:40.000]  Ну пилот это опорный элемент.
[03:40.000 --> 03:43.000]  Дальше будет партишн.
[03:43.000 --> 03:48.000]  Дальше будет вызвать рикурсивно от левой и правой половины.
[03:48.000 --> 03:51.000]  А, возникает вопрос. За сколько это дело работает?
[03:51.000 --> 03:53.000]  Квадрат.
[03:53.000 --> 03:55.000]  N лог N среди.
[03:55.000 --> 04:03.000]  Ну вот давайте скажем следующее. Утверждение 1.
[04:03.000 --> 04:07.000]  Партишн.
[04:07.000 --> 04:13.000]  Можно сделать.
[04:13.000 --> 04:20.000]  За отс N времени.
[04:20.000 --> 04:27.000]  Пилот единицы до памяти.
[04:27.000 --> 04:30.000]  Вот так вот можно сделать.
[04:30.000 --> 04:35.000]  Тогда как выглядит рекуррент?
[04:35.000 --> 04:43.000]  Рикуррент выглядит так, что здесь есть какой-то L, здесь есть какой-то R.
[04:43.000 --> 04:45.000]  То есть в общем случае вот что это такое?
[04:45.000 --> 04:47.000]  T от R.
[04:47.000 --> 04:50.000]  Это T от I.
[04:50.000 --> 04:52.000]  Плюс T от N минус I.
[04:52.000 --> 04:54.000]  Плюс там.
[04:54.000 --> 04:57.000]  Ну плюс линия на партишн.
[04:57.000 --> 05:03.000]  С на N.
[05:03.000 --> 05:06.000]  А оказалось бы, какое решение у этой рекурренты?
[05:06.000 --> 05:08.000]  Ну не очевидно, на самом деле.
[05:08.000 --> 05:11.000]  Ну что у нас зависит от I строк говоря.
[05:11.000 --> 05:13.000]  Например.
[05:13.000 --> 05:17.000]  Пусть I равно единичке.
[05:17.000 --> 05:21.000]  Тогда T от N.
[05:21.000 --> 05:25.000]  Это от N квадрат происходит.
[05:25.000 --> 05:32.000]  Если уже от I порядка по.
[05:32.000 --> 05:36.000]  То у вас в кратке получится то, что мы хотели.
[05:36.000 --> 05:44.000]  Вот N было прям.
[05:44.000 --> 05:46.000]  Ну то есть вот такие вот два корридии случая.
[05:46.000 --> 05:48.000]  И оба выражаются в разной асимптотипе.
[05:48.000 --> 05:52.000]  И непонятно от чего это зависит.
[05:52.000 --> 05:53.000]  Ну в целом не понятно.
[05:53.000 --> 05:57.000]  Зависит от того, кто выбирает церковный элемент.
[05:57.000 --> 06:00.000]  И нам вот нужно этот вопрос в кратке с вами обсудить.
[06:00.000 --> 06:03.000]  То есть как нужно выбирать первый шаг алгоритма.
[06:03.000 --> 06:07.000]  Чтобы все было хорошо.
[06:07.000 --> 06:10.000]  Для этого.
[06:10.000 --> 06:12.000]  Сначала промулируем одну теорему.
[06:12.000 --> 06:14.000]  Интересно.
[06:14.000 --> 06:18.000]  И доказывать ее не будем.
[06:18.000 --> 06:24.000]  Потому что бы это оказательно знать немножко теоргера.
[06:24.000 --> 06:41.000]  Если выбирать опортные элементы независимо.
[06:41.000 --> 06:48.000]  И равновероятно.
[06:48.000 --> 06:49.000]  То что тогда?
[06:49.000 --> 06:54.000]  То.
[06:54.000 --> 06:57.000]  От ожидания.
[06:57.000 --> 07:03.000]  Времени работы.
[07:03.000 --> 07:06.000]  Составит.
[07:06.000 --> 07:08.000]  От N.
[07:08.000 --> 07:10.000]  Лог N.
[07:10.000 --> 07:14.000]  Такая вот теорема.
[07:14.000 --> 07:16.000]  Собственно, что здесь значит слово независимо.
[07:16.000 --> 07:18.000]  Это значит, что каждый раз туда надо выбирать опорный элемент.
[07:18.000 --> 07:21.000]  То есть вот здесь вот.
[07:21.000 --> 07:22.000]  Потом когда рекурсивно запускать все этих половинок.
[07:22.000 --> 07:24.000]  Они как бы друг от друга вообще не зависит.
[07:24.000 --> 07:25.000]  Независимо.
[07:25.000 --> 07:28.000]  То есть это должен быть абсолютно изолированный эксперимент.
[07:28.000 --> 07:29.000]  Окей.
[07:29.000 --> 07:30.000]  Что значит равновероятно?
[07:30.000 --> 07:34.000]  Ну вы можете взять любой элемент из N.
[07:34.000 --> 07:35.000]  Там один, два, три было у вас.
[07:35.000 --> 07:36.000]  Индексам N.
[07:36.000 --> 07:37.000]  Равновероятно.
[07:37.000 --> 07:41.000]  То есть вы можете взять любой из них в качестве опорного.
[07:41.000 --> 07:43.000]  И здесь в кратке равновероятно.
[07:43.000 --> 07:44.000]  Равновероятно.
[07:44.000 --> 07:47.000]  Это значит, что у вас вероятность выбрать каждый из них один, девять на N.
[07:47.000 --> 07:51.000]  То есть абсолютно случайный.
[07:51.000 --> 07:52.000]  Вот.
[07:52.000 --> 07:54.000]  И что значит тогда от ожидания?
[07:54.000 --> 07:56.000]  Ну представим, что у нас есть кубик, да?
[07:56.000 --> 07:57.000]  Ну и грани.
[07:57.000 --> 07:58.000]  Кубик от одного до шести.
[07:58.000 --> 07:59.000]  Там шесть граний.
[07:59.000 --> 08:00.000]  Там точка.
[08:00.000 --> 08:01.000]  На каждой грани.
[08:01.000 --> 08:04.000]  Там кто одна точка, кто две точки и так далее.
[08:04.000 --> 08:10.000]  Тогда сколько в среднем у вас выпадет на кубике?
[08:10.000 --> 08:11.000]  Вот вы подбрасываете кубик.
[08:11.000 --> 08:14.000]  Сколько в среднем у вас выпадет?
[08:14.000 --> 08:16.000]  Ну три с половиной.
[08:16.000 --> 08:17.000]  Да, я понимаю.
[08:17.000 --> 08:18.000]  Математика сложна.
[08:18.000 --> 08:19.000]  Окей.
[08:19.000 --> 08:22.000]  Так же и здесь, собственно говоря.
[08:22.000 --> 08:25.000]  Какую бы вы перестановку не дали вашему алгоритму.
[08:25.000 --> 08:27.000]  Перестановку от одного до N.
[08:27.000 --> 08:29.000]  В среднем он будет работать за N.
[08:29.000 --> 08:30.000]  Утверждается.
[08:30.000 --> 08:35.000]  То есть там будет очень мало случаев, которые вырождаются в квадрат.
[08:35.000 --> 08:37.000]  И они как бы очень редки.
[08:37.000 --> 08:39.000]  То есть их вероятность очень мала.
[08:39.000 --> 08:41.000]  Поэтому они входят туда с очень маленьким кладом.
[08:41.000 --> 08:43.000]  В среднем N log N побеждают.
[08:44.000 --> 08:45.000]  Вот.
[08:47.000 --> 08:48.000]  Окей.
[08:50.000 --> 08:51.000]  Хорошо, казалось бы круто, да?
[08:51.000 --> 08:53.000]  Вот можно писать просто.
[08:53.000 --> 08:56.000]  Выбери рандомно опорный элемент и побеждай.
[08:56.000 --> 08:57.000]  Ну действительно.
[08:57.000 --> 08:58.000]  Правда.
[08:59.000 --> 09:02.000]  Однако мы с вами хотим, чтобы у нас алгоритмы были диссерминированы.
[09:02.000 --> 09:07.000]  И не зависели от какой-то случайности.
[09:07.000 --> 09:09.000]  Причем это случайность доказана лишь теоретически.
[09:09.000 --> 09:12.000]  Энтерически-то у вас нет ничего случайного.
[09:12.000 --> 09:15.000]  У вас компьютер не умеет делать случайные числа, неожиданно.
[09:15.000 --> 09:19.000]  В нем конечно вставят алгоритмы генерации псевдослучайных чисел самые разные.
[09:19.000 --> 09:25.000]  Но никто из них не может вам дать гарантию, что у вас есть четкая равноверенность и строгая независимость.
[09:25.000 --> 09:29.000]  Ну может независимости есть, но про равноверенность очень сложно говорить.
[09:33.000 --> 09:34.000]  Окей.
[09:35.000 --> 09:37.000]  Так, с этим справились.
[09:38.000 --> 09:40.000]  Ну вот, например, почему-то сложно.
[09:40.000 --> 09:43.000]  Представьте, у вас есть игральный кубик, который от 1 до 6 выбрасывает.
[09:43.000 --> 09:49.000]  Придумайте алгоритм, который вам будет выбирать с помощью него число от 1 до 31 равномерно.
[09:51.000 --> 09:53.000]  Да, на вероятность его выдавать.
[09:53.000 --> 09:54.000]  Вот какой-то алгоритм.
[09:54.000 --> 09:55.000]  Вот у вас есть кубик.
[09:55.000 --> 09:57.000]  Вы подбрасываете его несколько раз.
[09:57.000 --> 09:59.000]  Ну сколько угодно.
[09:59.000 --> 10:04.000]  Вот вам нужно получить как-то алгоритм, который вам возвращает равномерно от 1 до 31 числа.
[10:04.000 --> 10:08.000]  Подбрасываем кубик два раза, у нас получается 36 результатов.
[10:08.000 --> 10:12.000]  Если у нас какой-то результат от 1 до 31, то мы его оставляем.
[10:12.000 --> 10:14.000]  Если больше, то мы снова подбрасываем кубик два раза.
[10:14.000 --> 10:17.000]  Хорошо, докажите, что это конечное время будет длиться.
[10:18.000 --> 10:20.000]  Оно не обязательно длится.
[10:21.000 --> 10:24.000]  Вероятность того, что оно будет бесконечно длиться, равна нулю.
[10:24.000 --> 10:27.000]  Это правда, что оно будет там, короче, воевывать будет постоянно.
[10:27.000 --> 10:31.000]  Вероятность, с которой вы будете выкидывать, поставить числа.
[10:31.000 --> 10:37.000]  Но суть в том, что раз придумать алгоритм, который однозначно выдаст равномерно от часа, то конечное время очень сложно.
[10:38.000 --> 10:40.000]  Вообще не очевидно, как это делать.
[10:41.000 --> 10:47.000]  Поэтому не очень любят, когда у вас есть некоторые недетерминированные алгоритмы.
[10:47.000 --> 10:50.000]  Поэтому давайте изучим с вами такую вещь, как
[10:54.000 --> 10:55.000]  алгоритм
[10:57.000 --> 10:58.000]  медиан и медиан
[11:05.000 --> 11:08.000]  В общем-то, у него он именной на самом деле.
[11:08.000 --> 11:10.000]  Там пять авторов.
[11:11.000 --> 11:13.000]  Поэтому будем считать его, что это алгоритм медиан и медиан.
[11:13.000 --> 11:15.000]  Потому что все пяти даже с них в пол.
[11:18.000 --> 11:19.000]  Как выглядит алгоритм?
[11:20.000 --> 11:21.000]  Собственно, это алгоритм.
[11:21.000 --> 11:27.000]  Как выбрать такой опорный элемент, чтобы у вас здесь гарантировано было нормальное разбиение?
[11:29.000 --> 11:31.000]  Под нормальным мы тоже ставим, что это такое скоро.
[11:33.000 --> 11:34.000]  Шаг первый.
[11:34.000 --> 11:35.000]  Это
[11:38.000 --> 11:39.000]  распилить
[11:40.000 --> 11:41.000]  массив
[11:43.000 --> 11:44.000]  на пятерке.
[11:49.000 --> 11:50.000]  То есть, вот ваш массив.
[11:52.000 --> 11:54.000]  Вот у вас здесь блок пять элементов.
[11:55.000 --> 11:56.000]  Здесь блок пять элементов.
[11:57.000 --> 11:59.000]  Здесь что-нибудь меньше либо равно пяти элементов.
[11:59.000 --> 12:01.000]  Останется в конце в хвосте.
[12:06.000 --> 12:07.000]  Шаг второй.
[12:09.000 --> 12:10.000]  Найди медиан в каждом из них.
[12:15.000 --> 12:16.000]  В каждом блоке.
[12:20.000 --> 12:21.000]  Ну, например,
[12:22.000 --> 12:25.000]  можно искать ее с помощью сортировки пузырьком.
[12:27.000 --> 12:29.000]  Да, пузырек нам все-таки пригодился.
[12:29.000 --> 12:32.000]  Потому что здесь у вас пять элементов все-таки в каждом блоке.
[12:32.000 --> 12:34.000]  Пять квадратов это двадцать пять.
[12:34.000 --> 12:36.000]  Но у вас типа N делить на пять.
[12:36.000 --> 12:39.000]  Этих блок, поэтому сойдет.
[12:39.000 --> 12:41.000]  За линию все еще будут работать.
[12:42.000 --> 12:43.000]  Шаг третий.
[12:46.000 --> 12:47.000]  Запустись.
[12:49.000 --> 12:50.000]  Рекурсивно
[12:53.000 --> 12:55.000]  от массива медиана.
[13:05.000 --> 13:06.000]  Такая вот идея.
[13:08.000 --> 13:10.000]  То есть, когда у вас остается там меньше пяти элементов,
[13:10.000 --> 13:11.000]  ну или пять,
[13:12.000 --> 13:14.000]  вы уже не можете разделить массив.
[13:14.000 --> 13:15.000]  На пятерке у вас один блок.
[13:15.000 --> 13:16.000]  Вы находите медиан, но это ваш ответ.
[13:17.000 --> 13:18.000]  То есть, выход у вас вот здесь вот будет.
[13:19.000 --> 13:20.000]  Так.
[13:22.000 --> 13:23.000]  Окей.
[13:23.000 --> 13:24.000]  Давайте с вами докажем.
[13:25.000 --> 13:26.000]  Вообще посмотрим,
[13:26.000 --> 13:28.000]  какое число можно получить тогда.
[13:34.000 --> 13:35.000]  Ну, у вас есть массив.
[13:35.000 --> 13:37.000]  Вы выделили в каждом из них медиану.
[13:41.000 --> 13:42.000]  Раз, два, три.
[13:42.000 --> 13:43.000]  И вот эта вот массива есть.
[13:43.000 --> 13:44.000]  Раз, два, три.
[13:44.000 --> 13:45.000]  Запустите.
[13:45.000 --> 13:46.000]  Рекурсивно.
[13:46.000 --> 13:48.000]  А почему это будет работать?
[13:48.000 --> 13:49.000]  Что именно?
[13:54.000 --> 13:55.000]  Во-первых, он ищет медиану.
[14:00.000 --> 14:02.000]  Но он называет медиану медиану не потому,
[14:02.000 --> 14:03.000]  что он ищет медиану,
[14:03.000 --> 14:05.000]  а потому что он как бы вас берет медианы в маленьких блоках
[14:05.000 --> 14:07.000]  и из них пытается найти медиану.
[14:07.000 --> 14:09.000]  В конце концов, он медиану не найдет.
[14:09.000 --> 14:10.000]  Это правда.
[14:10.000 --> 14:12.000]  Но мы сейчас докажем, что он будет бить массив,
[14:12.000 --> 14:14.000]  что найденный элемент будет нормально,
[14:14.000 --> 14:15.000]  если это же не бить массив.
[14:15.000 --> 14:17.000]  Не один к одному, но...
[14:18.000 --> 14:19.000]  около того.
[14:19.000 --> 14:21.000]  А почему еще раз это залинировали?
[14:22.000 --> 14:23.000]  Мы еще это не говорили.
[14:23.000 --> 14:25.000]  Подождите, мы сначала давайте обсудим,
[14:25.000 --> 14:27.000]  что мы получим в результате.
[14:27.000 --> 14:29.000]  Если мы получим что-то удобоваримое,
[14:29.000 --> 14:30.000]  значит давайте докажем потом,
[14:30.000 --> 14:32.000]  что это работает за нужное нам время.
[14:32.000 --> 14:34.000]  Пока что мы искренне верим, что это работает,
[14:34.000 --> 14:37.000]  но не знаем ни почему, ни за сколько.
[14:37.000 --> 14:39.000]  Вот, а надо ответить на эти два вопроса.
[14:40.000 --> 14:43.000]  А давайте посмотрим следующее.
[14:43.000 --> 14:45.000]  Я нарисую матричку.
[14:48.000 --> 15:00.000]  2, 2, A, A1.
[15:02.000 --> 15:05.000]  Дальше здесь будет какой-нибудь A,
[15:05.000 --> 15:08.000]  D5, A, D3, D4.
[15:08.000 --> 15:09.000]  Я не знаю.
[15:16.000 --> 15:17.000]  Я не знаю.
[15:17.000 --> 15:20.000]  A, D5, D5.
[15:24.000 --> 15:26.000]  Ну, у вас индексация такая странная.
[15:27.000 --> 15:29.000]  В смысле странная?
[15:31.000 --> 15:33.000]  Ну, я не знаю.
[15:33.000 --> 15:36.000]  Как проиндексировалось, так проиндексировалось.
[15:39.000 --> 15:41.000]  Вот, я смотрю такую матрицу.
[15:41.000 --> 15:44.000]  Где A и D, это всегда элемент массива.
[15:45.000 --> 15:47.000]  То есть вот это вот ваш первый блок.
[15:50.000 --> 15:52.000]  Первый блок.
[15:53.000 --> 15:55.000]  Вот, короче, вот этот.
[15:55.000 --> 15:57.000]  Где мы делили массив на пятерке, это первый блок.
[15:57.000 --> 15:59.000]  Это второй блок.
[16:00.000 --> 16:02.000]  Ну и так далее.
[16:03.000 --> 16:05.000]  Так как мы их сортировали,
[16:06.000 --> 16:09.000]  у нас есть какое-то соотношение на них.
[16:12.000 --> 16:15.000]  Согласны, что здесь выполнено вот такое вот неравенство?
[16:19.000 --> 16:20.000]  Дальше.
[16:20.000 --> 16:22.000]  Так как мы говорили, что мы берем все-таки,
[16:22.000 --> 16:24.000]  типа рекурсивно запускаемся,
[16:24.000 --> 16:27.000]  и сортировали эти массивы,
[16:27.000 --> 16:29.000]  то мы утверждаем, что здесь вот такой вот вариант на них есть.
[16:35.000 --> 16:37.000]  А где мы их сортировали?
[16:37.000 --> 16:39.000]  Кого?
[16:39.000 --> 16:41.000]  Нет, нет, у вас...
[16:41.000 --> 16:43.000]  Смотрите.
[16:43.000 --> 16:45.000]  Вы же что делали дальше?
[16:45.000 --> 16:47.000]  Вы берете этот массив из пятерок.
[16:47.000 --> 16:49.000]  Это медианы в каждой пятерке, согласны?
[16:49.000 --> 16:51.000]  Вот этот вот ряд.
[16:52.000 --> 16:54.000]  Вот, а что вы дальше делали?
[16:54.000 --> 16:57.000]  Вы били его на пятерке и снова выбирали там медианы в каждом.
[16:57.000 --> 17:00.000]  Поэтому здесь можно вот такие сравнения просто ставить.
[17:03.000 --> 17:05.000]  В каждом блоке они тоже есть.
[17:14.000 --> 17:20.000]  Давайте посмотрим, сколько элементов меньше, чем A и B3.
[17:20.000 --> 17:22.000]  Ну, если это,
[17:22.000 --> 17:24.000]  типа здесь у вас
[17:24.000 --> 17:26.000]  N делик на 10 блоков,
[17:29.000 --> 17:31.000]  и здесь N делик на 10 блоков.
[17:41.000 --> 17:43.000]  То есть, смотрите, у вас здесь было
[17:43.000 --> 17:45.000]  несколько элементов,
[17:45.000 --> 17:47.000]  ну, N делик на 5.
[17:47.000 --> 17:49.000]  Из них до середины
[17:49.000 --> 17:51.000]  N делик на 10 блоков,
[17:51.000 --> 17:53.000]  и после середины N делик на 10 блоков.
[17:55.000 --> 17:57.000]  Тогда сколько элементов меньше либо равных, чем данные?
[17:57.000 --> 17:59.000]  Три десятых.
[17:59.000 --> 18:01.000]  Ну, сейчас, подождите.
[18:03.000 --> 18:05.000]  Ну да, да, да, все, вот они.
[18:05.000 --> 18:07.000]  Ну вот,
[18:07.000 --> 18:09.000]  вот,
[18:09.000 --> 18:11.000]  вот,
[18:11.000 --> 18:13.000]  вот,
[18:13.000 --> 18:15.000]  ну да, да, да, все, вот они.
[18:17.000 --> 18:20.000]  Вот они, элементы меньше либо равные данного.
[18:20.000 --> 18:22.000]  Вот в этом квадрате находятся.
[18:25.000 --> 18:27.000]  Меньше либо равны, чем A
[18:29.000 --> 18:32.000]  Здесь можно писать N делик на 10, 3.
[18:32.000 --> 18:35.000]  А, то есть, знак меньше либо равно, это значит, что
[18:35.000 --> 18:37.000]  медиана меньше либо равна?
[18:37.000 --> 18:39.000]  Чего?
[18:39.000 --> 18:41.000]  Сейчас, что такое вообще меньше либо равна?
[18:41.000 --> 18:43.000]  Ну, ты берешь твою чиселку
[18:43.000 --> 18:45.000]  и говоришь, меньше либо равна 1,
[18:45.000 --> 18:47.000]  если выполняется какое-то соотношение N.
[18:49.000 --> 18:51.000]  Х меньше либо равно Y,
[18:51.000 --> 18:53.000]  это тогда, когда х минус Y меньше
[18:53.000 --> 18:55.000]  либо равно U.
[18:55.000 --> 18:57.000]  Ну, у нас тут 5 в ряд чиселок.
[18:57.000 --> 18:59.000]  Да.
[18:59.000 --> 19:01.000]  А, навременно к 5 всем применять?
[19:01.000 --> 19:03.000]  Кто?
[19:03.000 --> 19:05.000]  А этот третий применяется
[19:05.000 --> 19:07.000]  к центральным числам,
[19:07.000 --> 19:09.000]  вдоль ряда.
[19:09.000 --> 19:11.000]  Ну, то есть, вот, вдоль этого ряда
[19:11.000 --> 19:13.000]  вы применяете.
[19:13.000 --> 19:15.000]  А почему вдоль ряда будет справедливо меньше равно?
[19:15.000 --> 19:17.000]  Вдоль ряда?
[19:17.000 --> 19:19.000]  Давайте подумаем.
[19:29.000 --> 19:31.000]  Ну, окей, хорошо.
[19:33.000 --> 19:35.000]  А ведь медиан и медиан все-таки ищут медиану
[19:35.000 --> 19:37.000]  в этом массиве. То есть, вы, на самом деле,
[19:37.000 --> 19:39.000]  будете найти, будто бы, медиану.
[19:39.000 --> 19:41.000]  Да?
[19:41.000 --> 19:43.000]  Утверждается, что если вы найдете медиану
[19:43.000 --> 19:45.000]  в этом...
[19:45.000 --> 19:47.000]  Если мы найдем медиану
[19:47.000 --> 19:49.000]  в массиве вот этих вот пятерок,
[19:49.000 --> 19:51.000]  то это будет верно. Согласны?
[19:51.000 --> 19:53.000]  То есть, мы всегда берем центральный элемент
[19:53.000 --> 19:55.000]  и их сравниваем?
[19:55.000 --> 19:57.000]  Центральный ем?
[19:57.000 --> 19:59.000]  Ну, мы всегда берем этот элемент, который...
[20:01.000 --> 20:03.000]  Ну, будто бы данный массив явно не сортируется.
[20:03.000 --> 20:05.000]  То есть, говорить медиан и медиан,
[20:05.000 --> 20:07.000]  я говорю, что он ищет медиану,
[20:07.000 --> 20:09.000]  он хочет ее найти.
[20:09.000 --> 20:11.000]  И он ищет медиану массива пятерок.
[20:11.000 --> 20:13.000]  Центральных элементов.
[20:13.000 --> 20:15.000]  Окей.
[20:15.000 --> 20:17.000]  Вот у вас есть блоки.
[20:17.000 --> 20:19.000]  Каждым из них выделено медиану.
[20:19.000 --> 20:21.000]  Средний ряд.
[20:21.000 --> 20:23.000]  А, все, мы ж отсортовали массивы сначала, да?
[20:23.000 --> 20:25.000]  Нет, конечно.
[20:25.000 --> 20:27.000]  Мы нигде не сортировали его.
[20:27.000 --> 20:29.000]  Вы... Вы вот в этом вот массиве
[20:29.000 --> 20:31.000]  ищем
[20:31.000 --> 20:33.000]  медиану.
[20:35.000 --> 20:37.000]  Рекурсивно.
[20:37.000 --> 20:39.000]  То есть, мы будто бы искали здесь медиану в исходном массиве.
[20:39.000 --> 20:41.000]  Для этого мы подлили массив на пятерке
[20:41.000 --> 20:43.000]  и запустились рекурсивно
[20:43.000 --> 20:45.000]  от этого массива.
[20:53.000 --> 20:55.000]  Ну, и допустим, вот вы вытащили
[20:55.000 --> 20:57.000]  эту медиану как?
[20:57.000 --> 20:59.000]  Тогда мы можем поставить вот этот столбец с ней сюда.
[20:59.000 --> 21:01.000]  Все, что с левой будет меньше,
[21:01.000 --> 21:03.000]  все, что с правой будет больше.
[21:03.000 --> 21:05.000]  У нас, типа, нет такого расположения элементов.
[21:05.000 --> 21:07.000]  Их просто удобно нарисовать, что они так есть.
[21:19.000 --> 21:21.000]  Мы каждую из пятерок сортировали.
[21:33.000 --> 21:35.000]  Нет, нет.
[21:35.000 --> 21:37.000]  А можно соменить еще блоги.
[21:37.000 --> 21:39.000]  Ну, не до этого блогов.
[21:39.000 --> 21:41.000]  Но в общем, медианы
[21:41.000 --> 21:43.000]  в этих блогах будут идти...
[21:43.000 --> 21:45.000]  Конечно, нет, не обязательно.
[21:45.000 --> 21:47.000]  Они, вроде, переставлены.
[21:47.000 --> 21:49.000]  Ну, как бы, мы же здесь
[21:49.000 --> 21:51.000]  не пересовывали таблицу.
[21:51.000 --> 21:53.000]  Потому что все работа
[21:53.000 --> 21:55.000]  с этой таблицей.
[21:55.000 --> 21:57.000]  А, окей, хорошо, я понял.
[21:57.000 --> 21:59.000]  Да, действительно, визуал так себе
[21:59.000 --> 22:01.000]  получился. Но я думаю,
[22:01.000 --> 22:03.000]  концепция понятна.
[22:03.000 --> 22:05.000]  То есть, мы взяли эти пятерки и будто бы отсортировали
[22:05.000 --> 22:07.000]  по вот этому элементу,
[22:07.000 --> 22:09.000]  по третьему элементу.
[22:09.000 --> 22:11.000]  Окей?
[22:15.000 --> 22:17.000]  Вот, тогда утверждается, что у вас
[22:19.000 --> 22:21.000]  тогда
[22:23.000 --> 22:25.000]  найденный элемент,
[22:25.000 --> 22:27.000]  найденный х таков,
[22:27.000 --> 22:29.000]  что хотя бы
[22:31.000 --> 22:33.000]  3n деленное на 10
[22:33.000 --> 22:35.000]  элементов
[22:35.000 --> 22:37.000]  меньше либо равны х.
[22:41.000 --> 22:43.000]  То есть, мы не нашли с вами медиану.
[22:43.000 --> 22:45.000]  Как видите.
[22:47.000 --> 22:49.000]  Мы пытались ее искать каждый раз.
[22:49.000 --> 22:51.000]  И, как бы, каждый раз мы к этому приближались,
[22:51.000 --> 22:53.000]  но каждый раз вы не могли найти медиану.
[22:53.000 --> 22:55.000]  Тут вот мы ее как-то нашли.
[22:57.000 --> 22:59.000]  Вот.
[22:59.000 --> 23:01.000]  3n.
[23:01.000 --> 23:03.000]  3n.
[23:03.000 --> 23:05.000]  3n делить на 10.
[23:05.000 --> 23:07.000]  Ну, у вас 3n делить на 10 блоков,
[23:07.000 --> 23:09.000]  здесь по три чиселки.
[23:11.000 --> 23:13.000]  Окей, тогда...
[23:15.000 --> 23:17.000]  То есть мы уже медиану
[23:17.000 --> 23:19.000]  среди самих блоков
[23:19.000 --> 23:21.000]  и там уже алгоритмов.
[23:21.000 --> 23:23.000]  То есть она будет не ровно посередине,
[23:23.000 --> 23:25.000]  а с 3n делить на 10
[23:25.000 --> 23:27.000]  за 7n делить на 10.
[23:27.000 --> 23:29.000]  И тогда у нас оттенка будет чуть меньше.
[23:29.000 --> 23:31.000]  Все, 3n делить на 10.
[23:39.000 --> 23:41.000]  Ну, окей, сейчас.
[23:41.000 --> 23:45.000]  Я подумаю и на перерыве скажу тогда, если что. Хорошо?
[23:47.000 --> 23:49.000]  Окей, здесь мы с этим справились.
[23:51.000 --> 23:53.000]  И, соответственно, тогда мы получаем какой-то элемент,
[23:53.000 --> 23:55.000]  который вот так вот соотносится.
[23:55.000 --> 23:57.000]  Тогда что мы имеем право сказать здесь?
[23:57.000 --> 23:59.000]  Вот в этой вот рекурренте.
[24:01.000 --> 24:03.000]  Что у вас получается?
[24:03.000 --> 24:05.000]  Что у нас получается?
[24:05.000 --> 24:07.000]  Что у нас получается?
[24:07.000 --> 24:09.000]  Что у нас получается?
[24:09.000 --> 24:11.000]  Что у вас i равно...
[24:11.000 --> 24:13.000]  хотя бы 3n делить на 10.
[24:17.000 --> 24:19.000]  То есть у нас было с нами соотношение
[24:23.000 --> 24:25.000]  плюс cn.
[24:25.000 --> 24:27.000]  Да?
[24:29.000 --> 24:31.000]  Ну что тогда можно сказать?
[24:31.000 --> 24:33.000]  Что раз у вас i больше либо равно,
[24:33.000 --> 24:35.000]  чем 3n делить на 10.
[24:35.000 --> 24:37.000]  Ну, понятно дело, что у вас такой вот отрезок.
[24:39.000 --> 24:41.000]  То есть у вас i какое-то такое.
[24:43.000 --> 24:45.000]  Утверждается, что для таких i
[24:47.000 --> 24:49.000]  t от n
[24:49.000 --> 24:51.000]  равно от n лог n.
[24:57.000 --> 24:59.000]  Ну,
[24:59.000 --> 25:01.000]  это не очень смешно.
[25:01.000 --> 25:03.000]  Ну,
[25:03.000 --> 25:05.000]  это не очень трудно доказать,
[25:05.000 --> 25:07.000]  на самом деле.
[25:07.000 --> 25:09.000]  То есть вы берете рекуррент у вида
[25:09.000 --> 25:11.000]  t от n
[25:11.000 --> 25:13.000]  равно t от альпа n
[25:13.000 --> 25:15.000]  плюс t от
[25:15.000 --> 25:17.000]  альпа
[25:19.000 --> 25:21.000]  1 минус альпа n
[25:23.000 --> 25:25.000]  альпа из этого интервала.
[25:27.000 --> 25:29.000]  Ну, из отрезка.
[25:31.000 --> 25:33.000]  И дальше решайте ее.
[25:33.000 --> 25:35.000]  И получайте, что у вас
[25:35.000 --> 25:37.000]  действительно все хорошо будет.
[25:37.000 --> 25:39.000]  Ну, ладно, давайте докажем это.
[25:39.000 --> 25:41.000]  Вот у вас изначально был массив
[25:41.000 --> 25:43.000]  длины n.
[25:43.000 --> 25:45.000]  Дальше у вас алгоритм рекурсина
[25:45.000 --> 25:47.000]  бьет его на две части.
[25:47.000 --> 25:49.000]  Одна из них
[25:49.000 --> 25:51.000]  альпа n, другая
[25:51.000 --> 25:53.000]  1 минус альпа
[25:53.000 --> 25:55.000]  на n.
[26:01.000 --> 26:03.000]  Заметьте, что у нас
[26:03.000 --> 26:05.000]  на каждом уровне
[26:05.000 --> 26:07.000]  там будет n элементов.
[26:07.000 --> 26:09.000]  Ну, порядка n, потому что 1 серийно
[26:09.000 --> 26:11.000]  убирается.
[26:11.000 --> 26:13.000]  Ну, будем считать, что их m.
[26:13.000 --> 26:15.000]  Дальше. Здесь будет блок
[26:15.000 --> 26:17.000]  альпа квадрат n.
[26:17.000 --> 26:19.000]  Здесь будет блок
[26:19.000 --> 26:21.000]  альпа альпа минус 1n.
[26:21.000 --> 26:23.000]  Здесь будет блок
[26:23.000 --> 26:25.000]  альпа альпа минус 1n.
[26:25.000 --> 26:27.000]  Здесь будет блок
[26:27.000 --> 26:29.000]  ой, 1 минус альпа.
[26:31.000 --> 26:33.000]  Альпа квадрат n.
[26:33.000 --> 26:35.000]  Ну, если просумировать,
[26:35.000 --> 26:37.000]  получите снова n.
[26:37.000 --> 26:39.000]  И так далее.
[26:39.000 --> 26:41.000]  И так далее,
[26:41.000 --> 26:43.000]  пока у вас тут не станут блоки
[26:43.000 --> 26:45.000]  по одному элементу.
[26:45.000 --> 26:47.000]  И там будет даже сам альпа
[26:47.000 --> 26:49.000]  в третьей шаге.
[26:49.000 --> 26:51.000]  Ну, хорошо.
[26:51.000 --> 26:53.000]  Мы считаем, что альпа
[26:53.000 --> 26:55.000]  просто какая-то коэффициент
[26:55.000 --> 26:57.000]  этого интервала.
[26:57.000 --> 26:59.000]  Вот из этого. Все.
[26:59.000 --> 27:01.000]  Ну, какой-нибудь альпа 1 может быть.
[27:01.000 --> 27:03.000]  Да, действительно.
[27:03.000 --> 27:05.000]  Альпа на втором шаге, альпа на третьем шаге
[27:05.000 --> 27:07.000]  могут быть разные. Да, конечно.
[27:07.000 --> 27:09.000]  Нам главное, что они делятся в каком-то константном
[27:09.000 --> 27:11.000]  соотношении.
[27:11.000 --> 27:13.000]  Ну, действительно, да, здесь надо нормально
[27:13.000 --> 27:15.000]  другие константы писать, но
[27:15.000 --> 27:17.000]  мне их уже лень пойти здесь слишком.
[27:17.000 --> 27:19.000]  Все равно это будет схематическое доказательство.
[27:19.000 --> 27:21.000]  Такая вот выстава
[27:21.000 --> 27:23.000]  от этого дерева рекурсия.
[27:29.000 --> 27:31.000]  Ну, будто бы
[27:35.000 --> 27:37.000]  ну, будто бы вы берете
[27:37.000 --> 27:39.000]  говорите, что альпа в степи h
[27:41.000 --> 27:43.000]  на n
[27:43.000 --> 27:45.000]  должно быть чему равно?
[27:45.000 --> 27:47.000]  Должно быть меньше, должно быть равно единичке.
[27:47.000 --> 27:49.000]  Ну, меньше либо равно.
[27:49.000 --> 27:51.000]  Сейчас.
[27:53.000 --> 27:55.000]  Ну, да, да, да.
[27:55.000 --> 27:57.000]  Чтобы какой-то либо этот блок, либо этот блок.
[27:57.000 --> 27:59.000]  Ну, пускай вот так вот.
[27:59.000 --> 28:01.000]  Тогда альпа в степени h меньше
[28:01.000 --> 28:03.000]  либо равно 1 делить на n.
[28:05.000 --> 28:07.000]  h меньше либо равно, чем логариф
[28:07.000 --> 28:09.000]  по основанию. Альпа от 1 делить на n.
[28:11.000 --> 28:13.000]  Что-то такое вот.
[28:19.000 --> 28:21.000]  Так, получаем здесь что?
[28:21.000 --> 28:23.000]  По-моему, можно вот так вот перейти
[28:23.000 --> 28:25.000]  к другому основанию.
[28:25.000 --> 28:27.000]  1 делить на h.
[28:29.000 --> 28:31.000]  Вроде бы. Здесь можно так делать.
[28:31.000 --> 28:33.000]  Но это не точно.
[28:35.000 --> 28:37.000]  Можно, да? Супер.
[28:37.000 --> 28:39.000]  То есть, ваш h равно
[28:39.000 --> 28:41.000]  от
[28:41.000 --> 28:43.000]  лог n.
[28:43.000 --> 28:45.000]  И у вас на каждом шаге n действий.
[28:45.000 --> 28:47.000]  Потому что у вас
[28:47.000 --> 28:49.000]  нерекурсивная компонента.
[28:49.000 --> 28:51.000]  Потому что у вас нерекурсивная компонента
[28:51.000 --> 28:53.000]  она cn.
[28:53.000 --> 28:55.000]  Здесь cn действий, здесь cn действий, здесь cn действий.
[28:55.000 --> 28:57.000]  И так далее у вас уровни сила лог n.
[28:57.000 --> 28:59.000]  Ну, все.
[28:59.000 --> 29:01.000]  Можно так доказывать.
[29:01.000 --> 29:03.000]  То есть, это вот называется метод рассмотреть дерево
[29:03.000 --> 29:05.000]  рекурсия. Вот.
[29:05.000 --> 29:07.000]  А как мы используем, что альпа прижит отрезку вот этому?
[29:07.000 --> 29:09.000]  То, что альпа — это как констант.
[29:09.000 --> 29:11.000]  Ну, а вот в том случае,
[29:11.000 --> 29:13.000]  когда альпа от 1 до
[29:13.000 --> 29:15.000]  от 0 до 1 мы тоже могли делать, получается.
[29:15.000 --> 29:17.000]  В самом деле.
[29:17.000 --> 29:19.000]  Совсем.
[29:19.000 --> 29:21.000]  Вы должны зафиксировать альпа
[29:21.000 --> 29:23.000]  не от 0 до 1.
[29:23.000 --> 29:25.000]  Вы же должны как-то уметь
[29:25.000 --> 29:27.000]  Смотрите, хорошо. У вас альпа
[29:27.000 --> 29:29.000]  должно быть
[29:29.000 --> 29:31.000]  строго больше 0,
[29:31.000 --> 29:33.000]  но при этом какие-то адекватные числа.
[29:33.000 --> 29:35.000]  Скажем так.
[29:35.000 --> 29:37.000]  Смотрите, если у вас
[29:37.000 --> 29:39.000]  альпа — это не констант, а какая-то функция
[29:39.000 --> 29:41.000]  здесь у вас нельзя просто
[29:41.000 --> 29:43.000]  так сказать, что здесь нельзя
[29:43.000 --> 29:45.000]  просто перейти и снять основание.
[29:45.000 --> 29:47.000]  Вдруг у вас альпа — это не констант?
[29:47.000 --> 29:49.000]  Когда вы говорите,
[29:49.000 --> 29:51.000]  что у вас альпа — это...
[29:51.000 --> 29:53.000]  Здесь вот получается время
[29:53.000 --> 29:55.000]  1, то альпа — это функция
[29:55.000 --> 29:57.000]  так или иначе. И здесь нельзя
[29:57.000 --> 29:59.000]  переходить к...
[29:59.000 --> 30:01.000]  к тому, что здесь просто нельзя снимать
[30:01.000 --> 30:03.000]  это основание, и нам тогда нормально
[30:03.000 --> 30:05.000]  уже оценивать. Здесь альпа констант,
[30:05.000 --> 30:07.000]  поэтому все можно делать, все легально.
[30:07.000 --> 30:09.000]  Когда у вас альпа — это не констант, так сделать просто нельзя.
[30:09.000 --> 30:11.000]  Вы можете повторить, откуда вы
[30:11.000 --> 30:13.000]  получили альпу в степени N на N
[30:13.000 --> 30:15.000]  или меньше, или ровно.
[30:15.000 --> 30:17.000]  Ну, я оцениваю
[30:17.000 --> 30:19.000]  какая будет высота дерева, если у меня
[30:19.000 --> 30:21.000]  вот этот кусочек все время самый большой остается.
[30:23.000 --> 30:25.000]  Да, в степени H.
[30:27.000 --> 30:29.000]  То есть у вас размер этого блока
[30:29.000 --> 30:31.000]  альпа, альпа квадрат, аж...
[30:33.000 --> 30:35.000]  альпа N, альпа квадрат N,
[30:35.000 --> 30:37.000]  альпа в степени H на N.
[30:37.000 --> 30:39.000]  Вот, ну давайте мы будем считать
[30:39.000 --> 30:41.000]  просто, что альпа... Ну да, у нас альпа меньше
[30:41.000 --> 30:43.000]  одна и вторая, поэтому этот блок...
[30:45.000 --> 30:47.000]  Непринципиально.
[30:47.000 --> 30:49.000]  Хорошо, да.
[30:49.000 --> 30:51.000]  Хорошо, мы здесь надо один
[30:51.000 --> 30:53.000]  минус альпу везде написать, но
[30:53.000 --> 30:55.000]  с точностью до замены перемены все будет корректно.
[30:55.000 --> 30:57.000]  Все равно здесь алгоритм
[30:57.000 --> 30:59.000]  тоже сам получится.
[31:01.000 --> 31:03.000]  По поводу вот этой вот
[31:03.000 --> 31:05.000]  штуки...
[31:05.000 --> 31:07.000]  Давайте мы
[31:07.000 --> 31:09.000]  до конца распишем эту идею все-таки.
[31:09.000 --> 31:11.000]  Вот.
[31:11.000 --> 31:13.000]  Потому что я здесь, да, забыл кое-что упомянуть
[31:13.000 --> 31:15.000]  и нам надо об этом сказать с вами.
[31:19.000 --> 31:21.000]  Собственно, понадобится еще один алгоритм.
[31:25.000 --> 31:27.000]  Xselect.
[31:29.000 --> 31:31.000]  Собственно, мы хотим найти
[31:31.000 --> 31:33.000]  кат и упорядково.
[31:37.000 --> 31:39.000]  Статистику.
[31:41.000 --> 31:43.000]  Как он делается у вас?
[31:43.000 --> 31:45.000]  Он делается следующим образом, что
[31:45.000 --> 31:47.000]  вы берете какой-то элемент
[31:47.000 --> 31:49.000]  опорным,
[31:49.000 --> 31:51.000]  например, случайным,
[31:51.000 --> 31:53.000]  дальше разделяете пополам,
[31:53.000 --> 31:55.000]  ну, делаете partition
[31:55.000 --> 31:57.000]  и смотрите, что получается.
[31:57.000 --> 31:59.000]  То есть, вот ваш массивчик,
[31:59.000 --> 32:01.000]  вот вы его поделили,
[32:01.000 --> 32:03.000]  x и меньше x.
[32:03.000 --> 32:05.000]  Можешь ли вы равны x, да?
[32:09.000 --> 32:11.000]  То есть, шаг первый, это
[32:11.000 --> 32:13.000]  выбрать
[32:13.000 --> 32:15.000]  опорный элемент.
[32:17.000 --> 32:19.000]  Шаг второй, когда вы
[32:19.000 --> 32:21.000]  делаете пополам,
[32:21.000 --> 32:23.000]  ну, делаете partition
[32:23.000 --> 32:25.000]  и смотрите, где у вас элементов сколько.
[32:25.000 --> 32:27.000]  Шаг второй, когда вы
[32:27.000 --> 32:29.000]  выбрали опорный элемент, что вы делаете?
[32:31.000 --> 32:33.000]  Вы делаете partition.
[32:35.000 --> 32:37.000]  Шаг третий, осталось
[32:37.000 --> 32:39.000]  разобраться с тем, как
[32:39.000 --> 32:41.000]  искать кат и упорядково. Ну, давайте посмотрим,
[32:41.000 --> 32:43.000]  что у нас может быть.
[32:45.000 --> 32:47.000]  k меньше i.
[32:49.000 --> 32:51.000]  То есть, например, у нас здесь десятый элемент,
[32:51.000 --> 32:53.000]  и мы ищем какую-нибудь третью упорядковую.
[32:53.000 --> 32:55.000]  И она где-то вот здесь вот находится, согласны?
[33:01.000 --> 33:03.000]  Если вы отсортируете массивчик
[33:03.000 --> 33:05.000]  и возьмете кат и элемент в нем,
[33:05.000 --> 33:07.000]  то это кат и упорядка и статистика.
[33:07.000 --> 33:09.000]  Вот.
[33:09.000 --> 33:11.000]  Если у вас k меньше i,
[33:11.000 --> 33:13.000]  значит у вас где-то в этой половине находится ваш
[33:13.000 --> 33:15.000]  кат и элемент.
[33:15.000 --> 33:17.000]  Вызываем quick select.
[33:17.000 --> 33:19.000]  Quick select
[33:21.000 --> 33:23.000]  от массива
[33:23.000 --> 33:25.000]  0 и k.
[33:27.000 --> 33:29.000]  Ну, 0 и это индексы,
[33:29.000 --> 33:31.000]  это границы.
[33:33.000 --> 33:35.000]  Второй вариант k равно равно i.
[33:39.000 --> 33:41.000]  Ну, вы нашли кат и элементы, вас поздравляю.
[33:41.000 --> 33:43.000]  Ретерн x.
[33:45.000 --> 33:47.000]  В случае, когда k больше i,
[33:47.000 --> 33:49.000]  что мы делаем?
[33:57.000 --> 33:59.000]  Делаем quick select. От чего?
[34:05.000 --> 34:07.000]  И смотрите,
[34:07.000 --> 34:09.000]  у нас здесь есть
[34:09.000 --> 34:11.000]  и смотрите,
[34:11.000 --> 34:13.000]  если вы искали в этом вот
[34:13.000 --> 34:15.000]  и, допустим, равно 10,
[34:15.000 --> 34:17.000]  вы ищете 50-ю упорядковую статистику,
[34:19.000 --> 34:21.000]  вы ищете в этом массиве,
[34:21.000 --> 34:23.000]  тогда вы уже должны отбросить все вот эти вот
[34:23.000 --> 34:25.000]  i плюс 1 элементов.
[34:25.000 --> 34:27.000]  Поэтому здесь вы должны искать не k-ую упорядковую,
[34:27.000 --> 34:29.000]  а вот такую вот
[34:29.000 --> 34:31.000]  k минус i минус 1
[34:31.000 --> 34:33.000]  статистику.
[34:33.000 --> 34:35.000]  Окей?
[34:37.000 --> 34:39.000]  Ну, потому что
[34:39.000 --> 34:41.000]  если вы ищете 50-ю упорядковую
[34:41.000 --> 34:43.000]  во всем этом массиве,
[34:43.000 --> 34:45.000]  и вы знаете, что у вас
[34:45.000 --> 34:47.000]  еще 10 элементов меньше вашего,
[34:47.000 --> 34:49.000]  значит, в этом блоке вы ищете уже
[34:49.000 --> 34:51.000]  50 минус 11
[34:51.000 --> 34:53.000]  и эту упорядковую статистику.
[34:53.000 --> 34:55.000]  Понятно?
[34:55.000 --> 34:57.000]  Оно
[34:57.000 --> 34:59.000]  делит
[34:59.000 --> 35:01.000]  массив как-то,
[35:01.000 --> 35:03.000]  чтобы было меньше x больше
[35:03.000 --> 35:05.000]  либо равно x и сам x.
[35:09.000 --> 35:11.000]  Как конечный элемент?
[35:11.000 --> 35:13.000]  Если x минимальный?
[35:17.000 --> 35:19.000]  Мы выбираем в себе
[35:19.000 --> 35:21.000]  упорный элемент как-то,
[35:21.000 --> 35:23.000]  получаем x, да.
[35:23.000 --> 35:25.000]  Да.
[35:27.000 --> 35:29.000]  Конечно.
[35:29.000 --> 35:31.000]  Но его цель это переставить
[35:31.000 --> 35:33.000]  элементы массива так, чтобы
[35:33.000 --> 35:35.000]  слева было меньше x, справа было больше
[35:35.000 --> 35:37.000]  x и x посередине.
[35:37.000 --> 35:39.000]  Что среди меньших x
[35:39.000 --> 35:41.000]  и среди больших x творится, никому не известно.
[35:43.000 --> 35:45.000]  Вот.
[35:45.000 --> 35:47.000]  Вот.
[35:47.000 --> 35:49.000]  Смотрите.
[35:49.000 --> 35:51.000]  Вот у вас есть массивчик.
[35:53.000 --> 35:55.000]  Вы спрашиваете, что такое вторая
[35:55.000 --> 35:57.000]  упорядковая?
[35:59.000 --> 36:01.000]  Вы сортируете массив.
[36:03.000 --> 36:05.000]  Ну, из зависимости от того, в какой индексации
[36:05.000 --> 36:07.000]  вы берете либо в 1, либо в 0
[36:07.000 --> 36:09.000]  индексации, второй элемент.
[36:09.000 --> 36:11.000]  В этот момент
[36:11.000 --> 36:13.000]  вы делаете массив
[36:13.000 --> 36:20.160]  либо в ноль индексации второй элемент. Это четыре. Если вас просят третью порядковую,
[36:20.160 --> 36:31.840]  вы берете третий элемент и так далее. Осознанно? Нет, конечно. Нет, если он сортирован,
[36:31.840 --> 36:39.080]  верни просто катаэлемент. Чего мы здесь распинаемся? Как бы да, если мы здесь сортирован,
[36:39.080 --> 36:45.080]  то непонятно, как катаэпорядку возвращать. А здесь, если нет, то вот такая вот идея. И,
[36:45.080 --> 36:50.440]  казалось бы, проблема в том, что если вы берете случайный опорный элемент,
[36:50.440 --> 36:54.480]  то тогда это будет работать в среднем за линию. Тоже утверждается, что если у вас,
[36:54.480 --> 37:20.120]  давай теорема BD, если выбирать опорный элемент за случайно, ну здесь вот это вот должна быть
[37:20.120 --> 37:42.040]  независимая равномерно то мотожидание времени работы отн. Утверждается, что в среднем он за линию
[37:42.040 --> 38:06.840]  работает. Теперь нам нужно как-то связывать вот с этой вот штукой. Что? Будет, будет. Мы
[38:06.840 --> 38:13.280]  сейчас будем комбинировать этого алгоритма, они будут друг друга поочередно вызывать. То есть,
[38:13.280 --> 38:22.520]  как смотрите, у нас наша глобальная цель — это получить медиану массива. Согласны? Давайте теперь
[38:22.520 --> 38:29.320]  будем вызывать их друг, короче говоря, они будут дергать сейчас друг друга эти алгоритмы. И давайте
[38:29.320 --> 38:39.640]  мы сделаем вот как. У нас будет функция Quick Select. Ну или там int, неважно, что-то она вернет,
[38:39.640 --> 38:52.920]  короче. Она будет принимать в себя ваш массив. Допустим, было индексы, да, там LR. Как же хочется
[38:52.920 --> 39:02.120]  в такие моменты подписать на питоне? Там все так хорошо, не нужно ничего прописывать. Короче,
[39:02.120 --> 39:12.000]  ладно, просто массив и pivot function. Ну собственно, она принимает в себя функцию. Как выбирать
[39:12.000 --> 39:19.200]  этот опорный элемент? Опорный элемент — это pivot еще называется. Вот. И как устроен будет этот код?
[39:19.200 --> 39:27.200]  А, ну и по умолчанию она будет типа random. У нас будет еще аргумент по умолчанию,
[39:27.200 --> 39:39.840]  что это random просто, равно random. Что мы будем делать здесь? Для этого мы сами выбираем pivot
[39:39.840 --> 39:59.320]  равно pivot function от array. Вот мы сами выбрали опорный элемент. Дальше сделан partition от массива
[39:59.320 --> 40:11.520]  pivot. То есть вот его разбили. Это сам array, там типа на месте делается. Отлично. Теперь вы смотрите,
[40:11.520 --> 40:20.160]  ну, соответственно, вы получаете этот вот i. Вот этот прекрасный i. Дальше теперь что вы делаете?
[40:20.160 --> 40:40.000]  Типа if, if меньше, чем k, click select. И теперь надо понять функцию какую вы хотите сюда передать.
[40:40.000 --> 40:49.960]  Что? Ну да.
[40:49.960 --> 41:19.240]  Делать просто return r и ты. И последнее if и больше k. А, ну сюда еще типа надо k передавать.
[41:19.240 --> 41:30.920]  Вот.
[41:30.920 --> 41:52.640]  Ну что это такое? Ну да, мы здесь что-то return, поэтому делаем. Ну типа здесь мы должны
[41:52.640 --> 42:04.320]  написать просто return и return к результату. Можно и плюс один, неважно. А теперь, собственно,
[42:04.320 --> 42:21.560]  ну давайте хорошо с выпуском начнем. Вот. Теперь дальше займемся как писать саму медиану медиану.
[42:21.560 --> 42:47.320]  Здесь я буду писать уже совсем псевдокодом. Ну, тоже видимо int возвращает у нас, не знаю.
[42:51.760 --> 43:01.400]  Медиас. Короче, он там что-то попринимает. Напишем, что он там принимает, когда поймем, что нам нужно.
[43:01.400 --> 43:22.160]  Что она сделает? Она будет типа делать split by 5 от массива. Ну, давайте нажимаем эти штуки там.
[43:22.160 --> 43:41.200]  Не хватает места. Это грустно. Короче говоря, получим двумерный массив chunks. Вот этот вот массив
[43:41.200 --> 43:50.080]  просто вот такого вот вида. Здесь 5 элементов, здесь 5 элементов, здесь 5 элементов. Такой двумерный
[43:50.080 --> 43:56.960]  массив, где мы просто взяли этот наш исходный массив array по 5 блоки, по 5 вот так вот просто
[43:56.960 --> 44:15.000]  поставили и все, матрицу такую получили. Дальше. Я напишу функцию гениальную. Сортируем пятерки chunks.
[44:15.000 --> 44:26.600]  Пробегаетесь в форум и от каждого сорта вызываете. Баблсорт какой-нибудь. Теперь вы хотите дальше
[44:26.600 --> 44:43.960]  medians равно. Что такое medians? Это где-то medians какой-нибудь. Чанк с вашего. То есть этот, который
[44:43.960 --> 44:51.480]  вот форум пробегает по этим всем массивам, вытаскивает вам сердинные элементы. И что вы теперь делаете? Теперь вы
[44:51.480 --> 45:09.160]  делаете гениальный контент вида quick select от array, от вашего массива medians только. Дальше. Вместо k вы
[45:09.160 --> 45:33.200]  передаете n деленное на 10. Где n? Это длина массива. Здесь мы вытаскиваем medians. По дефолту мы считаем, что
[45:33.200 --> 45:46.880]  random. Потому что заявили, что если вы будете делать просто medians medians каждый шаг, то у вас здесь 3n на 10,
[45:46.880 --> 45:54.760]  но на следующем шаге вытащите здесь не medians, вытащите что-то, что снова 3 десятых только отсечет.
[45:54.760 --> 46:01.360]  То есть если вы будете постоянно вызывать одно и то же, то у вас будет 3 десятых на 3 десятых на
[46:01.840 --> 46:08.320]  3 десятых. И так далее элементов будет меньше только. И таким образом у вас получится, что это будет
[46:08.320 --> 46:17.080]  нелагерифмическая высота. Так нет, мы сейчас возьмем самый интересный random.
[46:17.080 --> 46:34.680]  Да, только смотрите, вы каждый раз вызываете здесь массив 5 раз меньше.
[46:39.280 --> 46:45.320]  Он вам вернул медиану. Именно что он вернул медиану этого массива в пятерках. Вот тут он
[46:45.360 --> 46:50.160]  вам вернет чистую медиану, потому что random вызывает. А если он вам вернет чистую медиану,
[46:50.160 --> 46:55.840]  значит у вас выполнено соотношение 3n на 10. И вы получите тогда в исходном click
[46:55.840 --> 47:17.040]  select вы получите нормальный пивот. Что? Ну это убийство сейчас будет. Здесь напишите
[47:17.040 --> 47:27.080]  return click select. Вот смотрите, да, мы стремились избежать рандома, но здесь важно понимать,
[47:27.080 --> 47:31.800]  что рандом только где у вас есть. Давайте посмотрим когда у вас появляется рандом. Вот здесь вот,
[47:31.800 --> 47:40.600]  да. То есть вы вызвали рандом на пивот, сделали с ним партию, но потом-то вы делаете click select
[47:40.600 --> 47:45.240]  с медианом и медианом. То есть по факту здесь рандома-то почти нет. И гарантируется, что при
[47:45.240 --> 47:52.640]  любом рандоме все будет хорошо. Так она вызывает click select. То есть они друг друга дергают.
[47:52.640 --> 48:03.880]  И что? Ну давайте оценим время работы, хорошо. Давайте время работы этой штуки оценим. Вот у вас
[48:03.880 --> 48:16.680]  3n. Это что такое? Ну понятно ее, что это n. Вот здесь вот, да. Вот это вот с этим вот это n.
[48:16.680 --> 48:28.560]  Плюс click select с медианом и медианом. То есть смотрите, что у вас здесь будет. У вас медиан и медиан
[48:28.560 --> 48:39.360]  тоже работает за линию, согласны, да. Вот это вот линия, линия, линия. Плюс. Вы делаете все то же
[48:39.360 --> 48:49.440]  самое, вызываете с рандомом. Только плюс t от n делить на 5, согласны? Ну у вас массив медиан с 5 раз меньше.
[48:49.440 --> 49:03.040]  Окей? Вот вы вызвали эту штуку. Он вам вернул вот этот вот вызов. И дальше вы идете либо сюда,
[49:03.040 --> 49:13.200]  либо сюда. Но мы с вами знаем, что медианная массива этих пятерок, она что такое? Она по сути
[49:13.200 --> 49:17.680]  является чем? Она является медианом от массива пятерок, а значит у нее хотя бы 3n на 10 элементов
[49:17.920 --> 49:28.720]  меньше нее. Значит у вас в обеих этих ветках не больше чем 7n делить на 10 может остаться здесь.
[49:28.720 --> 49:38.520]  И поэтому вызываете то же самое время. Плюс t от 7n деленное на 10. Ну давайте я вот эти вот n-ки
[49:38.520 --> 49:49.360]  зафиксирую просто как c умножить на n. Ну понятное дело, что у вас здесь типа вот это ничего не
[49:49.360 --> 49:55.200]  дергается, если у вас просто 5 элементов, если у вас меньше 5 элементов здесь. А здесь вот у вас
[49:55.200 --> 50:02.720]  выход из рекурсии есть. То есть вы каждый раз уменьшаете размер вашего массива, да, и при этом у вас
[50:02.720 --> 50:08.480]  выход есть как? Когда у вас меньше 5 остаётся элементом, он просто выдаёт вам ответ. Давайте
[50:08.480 --> 50:20.960]  докажем, как ведется этот рекуррент по времени. Ваши идеи. Какая мастерти арема? Она не подойдет,
[50:20.960 --> 50:34.440]  потому что у нас здесь рекурсивный вызов Quick Select идёт дальше. Вы нашли, хорошо, у вас первая
[50:34.440 --> 50:39.120]  итерация, когда вы кучу раз вызывали друг друга эти алгоритмы, вы нашли вот эту вот чиселку,
[50:39.120 --> 50:46.200]  меньше которой 7n на 10, 3n на 10 элементов. Вы же ищете произвольную катую порядковую, а не какую-то.
[50:46.200 --> 50:55.880]  То есть вы хотите, чтобы у вас вот эта вот штука, она вам вернёт вот этот вот элемент. А, и ты третий.
[50:55.880 --> 51:02.960]  Окей? Естественно, дальше вы будете выбирать вот это вот всё дело.
[51:02.960 --> 51:20.160]  Кого? Ещё раз. У вас этот чувак вернёт вам медиану массива Medians. Согласны? Вот этот
[51:20.160 --> 51:29.440]  вот ряд – это массив Medians. И он вам утверждает, что он вам вернёт чистую медиану, которую вы
[51:29.440 --> 51:35.680]  хотите от него. Не важно, чтобы внутри он там будет себя дёргать кучу всего. Вот здесь вам
[51:35.680 --> 51:41.800]  гарантируется, что вам вернётся честная n делить на 10 порядковая статистика. Потому что у вас Quick
[51:41.800 --> 51:51.400]  Select так устроен. Да, да, рано или поздно вы до него спуститесь. Просто как, смотрите, у вас Quick
[51:51.400 --> 51:57.360]  Select дёргает медиану медиан, медиану медиану дёргает Quick Select с рандомом, тот дёргает
[51:57.360 --> 52:03.680]  Quick Select с медианом и медианом, который дёргает медиану медиан. Да, они друг друга дёргают.
[52:09.680 --> 52:16.960]  У вас кара равна n делить на 10, вот вы вызвались. Он ищет массив Median, n делить на 10 порядковую
[52:16.960 --> 52:23.920]  статистику. Дальше он выбирает у вас тут случайно Pivot и вытаскивает от него Quick Select с медианом и
[52:23.920 --> 52:30.200]  медианом. У вас уже длина массива маленькая, она у вас уже была типа n делить на n делить на 5
[52:30.200 --> 52:43.920]  стала. Вот он t от n делить на 5. Кого? Пять раз меньше массив только, потому что у вас массив медиан
[52:43.920 --> 52:53.800]  всё-таки остаётся. Смотрите, у вас будто бы запуск Quick Select лишь одной итерации вот этой
[52:53.800 --> 53:00.400]  вот выбрать опорный элемент, она будет дёргать внутри себя Quick Select, медиану медиан, Quick Select,
[53:00.400 --> 53:08.080]  медиану медиан поочерёдно. И вот он вам вернёт медиану, массиву медиан, а это и третий. И это
[53:08.080 --> 53:14.840]  у вас закончится только вот этот вот шаг. Дальше он пойдёт сюда, здесь ничего рекурсивного не будет,
[53:14.840 --> 53:27.560]  и дальше он пойдёт сюда и начнётся всё то же самое. Партишн у вас вообще ничего не вызывает
[53:27.560 --> 53:37.960]  рекурсивно. Партишн всё время одинаковый, да. Ну короче говоря, вот вам рекомендую просто взять
[53:37.960 --> 53:42.920]  этот код и просто представить как будут функции себя вызывать, какие в таком порядке. Это хорошее
[53:42.960 --> 53:56.320]  упражнение на рекурсию. Так, давайте докажем, что это работает за линию. Смотрите, что мы делаем в
[53:56.320 --> 54:02.920]  поиске кат и порядка в Quick Select? Мы вызываемся либо от левой части, либо от правой части. Мы
[54:02.920 --> 54:08.120]  говорим себе, что меньше части хотя бы 3n на 10 элементов. Значит, в большей части не больше,
[54:08.200 --> 54:27.840]  чем 7n на 10. Поэтому вот такая вот у вас оценка сверху. Что? Окей. Ну там в среднем n log n. Мы хотим
[54:27.840 --> 54:34.080]  в худшем случае n log n. Смотрите, если злоумышленник знает ваш генератор случайных чисел, то он вам
[54:34.080 --> 54:37.760]  построит массив, который за н квадрат будет работать. А теперь вы хотите так, чтобы никакой
[54:37.760 --> 54:58.080]  злоумышленник не мог вам этим помешать. Он требует допамяти. Докажем по индукции, что t от n меньше
[54:58.080 --> 55:27.120]  либо равно, чем 10 cn. Докажем по индукции, что t от n меньше либо равно, чем 10 cn.
[55:27.120 --> 55:36.040]  Доказательство гениальное будет просто. Мы говорим тогда, что вот это вот все меньше
[55:36.040 --> 55:53.200]  либо равно, чем cn плюс 10 cn делить на 5, плюс 7n делить на 10, на 10 cn.
[56:06.040 --> 56:19.120]  Хипсорт не требует, да. Это классно, конечно. Ну, скажем так, хипсорт, конечно, допамяти у вас
[56:19.120 --> 56:30.880]  особо не требует, да, но в целом чувак не очень быстрый. Там константик. Короче говоря, что? Да,
[56:30.880 --> 56:36.200]  мы короче еще проведем сравнительные анализы. Вы не бегите вперед в паровоз. Вот t от n равно
[56:36.200 --> 56:43.760]  10 cn, доказали. Откуда у вас следует, что t от n равно o от n? То есть мы с вами построили
[56:43.760 --> 56:52.080]  детерминированный алгоритм поиска за o от n, катой порядка произвольной. Вот, а это значит,
[56:52.080 --> 56:58.560]  что вы можете искать все гарантированно медиану каждый раз в быстрой сортировке, да. А медиан у вас
[56:58.560 --> 57:05.160]  делит пополам массив обязательно. А если это так, значит вы умеете делать рекурренту t от n
[57:05.160 --> 57:21.920]  равно 2t от n пополам плюс o от n. Все. Ну вот, у меня есть... Докажем по индукции, что это так. То есть
[57:21.920 --> 57:35.120]  для любого k, t от k меньше либо равно, чем 10 ck. Докажем, что для любого k меньше n. Верно вот
[57:35.120 --> 57:45.960]  это. Докажем, что t от n меньше либо равно, чем 10 cn. Ну окей, хорошо, берем рекурсивный раскрайм,
[57:46.080 --> 57:52.240]  делить на 5 меньше, чем n. Логично, что меньше. Значит, мы имеем право применить вот это вот.
[57:52.240 --> 58:13.120]  Аналогично с 7n на 10. Все. Окей. Да. Да. Ну если что, у вас есть такая задача в контесте написать-то
[58:13.120 --> 58:19.720]  все. Но она бонусная. Там типа можно написать рандомный quicksort, тогда он 1 балл будет стоить.
[58:19.720 --> 58:30.720]  А если напишете еще вот эту вот штуку, то будет 2 балла. Это 1 балл. А как вы собираетесь искать?
[58:30.720 --> 58:37.440]  Нет. Требуется, чтобы... Ну если вы будете постоянно выбирать серединный элемент, это плохо.
[58:37.440 --> 58:46.200]  Ну конечно зайдет, если... Ну невозможно на любую стратегию придумать контур-тест,
[58:46.200 --> 58:54.720]  потому что тестов конечное количество, а стратегий чуть больше, чем тестов. Но на то она есть review,
[58:54.720 --> 59:19.400]  чтобы... Рандом? Ну рандом нет, не детерминированный. Ну смотрите, у вас стоит... Здесь рандом,
[59:19.400 --> 59:24.240]  да, действительно. Но у вас здесь медианы-медиан, которые нивелируют все это действие рандома. Вам
[59:24.240 --> 59:36.880]  особо не важно, что здесь произойдет. Ну вроде бы да. Все равно здесь медианы-медиан все время вызываются.
[59:49.640 --> 59:53.600]  Потому что по умолчанию вы не хотите писать медиану-медиану.
[59:53.600 --> 01:00:02.720]  Ну окей, хорошо, давайте сделаем вот так вот. Сейчас.
[01:00:02.720 --> 01:00:13.760]  Но здесь можно дергать просто-напросто ту же самую pivot функцию, писать медиан вместо медиан-медиан,
[01:00:13.760 --> 01:00:24.800]  вызвать единожды с медианом-медианом, все будет все равно ок. Окей? Так,
[01:00:24.800 --> 01:00:36.800]  давайте подумайте над всем этим делом пока что, а я расскажу, что хотел. Если останутся еще
[01:00:36.840 --> 01:00:44.400]  вопросы, то давайте, тогда подойдете просто после лекции. Окей. Последнее,
[01:00:44.400 --> 01:00:49.560]  про что я хотел сегодня рассказать, это по разрядной сортировке, ну или еще называть цифровой сортировке.
[01:00:49.560 --> 01:01:07.560]  Пусть мы хотим сортировать числа, ну дать им числа, пусть хотим сортировать
[01:01:07.560 --> 01:01:31.080]  объекты, которые принимают значение, принимают одно из к значений. Например,
[01:01:31.080 --> 01:01:37.720]  мы хотим сортировать числа от 1 до 100. У вас массив, в нем все числа от 1 до 100. В плане,
[01:01:37.720 --> 01:01:42.840]  что каждый аид, и он там от 1 до 100 где-то лежит. Вот натуральный и все, то есть у вас кар равно 100
[01:01:42.840 --> 01:01:50.360]  здесь. Вот оказалось бы, можно что делать? Можно просто посчитать сколько у вас единичек, сколько
[01:01:50.360 --> 01:01:55.960]  двоих, сколько троих и так далее, и дальше выписать столько раз, сколько и надо. Алгоритм 30 из 10,
[01:01:55.960 --> 01:02:02.640]  я считаю. Давайте все-таки напишем теперь стабильную сортировку подсчетом. Так,
[01:02:02.640 --> 01:02:10.360]  я не помню, давали определение стабильности или нет. Хорошо. Сортировка подсчетом.
[01:02:10.360 --> 01:02:35.000]  Сортировка стабильная, определение. Сортировка стабильная, если она не меняет
[01:02:35.000 --> 01:02:53.320]  место положения относительного, равных элементов. Ну, пример здесь такой. Вы хотите
[01:02:53.320 --> 01:03:12.720]  отсортировать пары по первой компоненте. Вы их сортируете по верхней компоненте. Что
[01:03:12.720 --> 01:03:19.480]  тогда будем делать? Понятное дело, первым мы должны писать минус 1,3. И дальше стабильная
[01:03:19.480 --> 01:03:25.440]  сортировка, если у вас есть равные ключи, вот у вас ключ равный единичке, она не будет как-то
[01:03:25.440 --> 01:03:34.520]  смотреть на второй элемент, а выпишет их именно в том порядке. То есть она пишет 1,2, 1,0, 1,2 и дальше
[01:03:34.520 --> 01:03:40.000]  2,1 допишет. Это вот стабильная сортировка. Не стабильная, а как-то бы их потом перемешала
[01:03:40.000 --> 01:03:45.320]  скорее всего. То есть нам не дают такой гарантии. Ну, где вы могли в жизни видеть стабильные
[01:03:45.320 --> 01:04:01.840]  сортировки? Ну, в Google табличках, знаете, там можно отсортировать. Вот, например, у вас есть список людей по
[01:04:01.840 --> 01:04:09.800]  баллам и их фио. Вот вы берете сначала, сортируете по фио, потом по баллам. Тогда у вас если баллы
[01:04:09.800 --> 01:04:16.000]  одинаковые, то порядок по фио сохранится относительный. Потому что сортировка там
[01:04:16.000 --> 01:04:21.280]  стабильная написана. Ну, тогда сразу скажем, что мерсорт является стабильной сортировкой,
[01:04:21.280 --> 01:04:26.640]  квиксорт не является, хипсорт тоже не является. А стабильность — это прекрасные свойства,
[01:04:26.640 --> 01:04:35.240]  которые многому хочется достичь. Окей, как будет теперь устроена такая цифровая сортировка,
[01:04:35.240 --> 01:04:51.720]  чтобы она была стабильной? Пусть CNT — это массив. Такое, что CNT ИТ, сколько раз встречается ИТ
[01:04:51.720 --> 01:05:09.920]  элемент? Раз, встречается ИТ элемент. Ну, элемент с ключом И. Тогда сделано вот так,
[01:05:09.920 --> 01:05:32.960]  что преф от нулевой равен нулю, пор И и меньше, чем n-1, плюс-плюс И. Скажем, что преф ИТ равно преф
[01:05:32.960 --> 01:05:49.640]  И-1, плюс CNT ИТ. То есть построить сам массив префиксных сумм CNT. И дальше я буду говорить
[01:05:49.640 --> 01:06:08.560]  следующее тогда, что пор И равен нулю и меньше n. Сейчас. Здесь k. Потому что у вас k разных,
[01:06:08.560 --> 01:06:18.160]  у вас же CNT будет длиной k, поэтому здесь будет до k цикл. Плюс-плюс И. Давайте посмотрим.
[01:06:20.640 --> 01:06:29.800]  То есть вот у нас есть массив наших прекрасных пар. Давайте я здесь для красоты просто ноль напишу.
[01:06:29.800 --> 01:06:37.640]  Вот давайте посмотрим сами, как у нас массив будет устроен. То есть у нас массив здесь,
[01:06:37.640 --> 01:06:57.680]  если мы по ключам посмотрим 1, 0, 1, 2, 1. Дальше мы считаем массив CNT. 1, 3, 1. То есть вот у
[01:06:57.680 --> 01:07:06.480]  вас по ключам 0, 1, 2, у вас три денечки, один нолик, одна двойка. Тогда массив преф чему равен? Он
[01:07:06.480 --> 01:07:23.760]  имеет такой вот вид интересный. 0, 1, 4. Даже здесь давайте, видимо, вот так вот будет алгоритм,
[01:07:23.760 --> 01:07:39.000]  чтобы по индексам все завпало. Массив преф и CNT только без последнего элемента. Смотрите,
[01:07:39.000 --> 01:07:53.000]  в чем здесь суть. Это значит, что у вас элементы с ключом 0 пишутся на позицию 0. Дальше все элементы
[01:07:53.040 --> 01:08:00.040]  с ключом 1 пишутся на позиции 1, 2, 3. Элемент с ключом 2 будет писаться по индексу 4. То есть вы
[01:08:00.040 --> 01:08:04.800]  посчитали, сколько элементов меньше данного. То есть где должны начинаться эти элементы.
[01:08:04.800 --> 01:08:32.880]  Теперь вы здесь говорите, что рез от преф, от а и ты. Балдеж. Вы получите так массив,
[01:08:33.000 --> 01:08:39.200]  отсортированный в итоге. Давайте в качестве примера, что вы будете делать. Вот вы идете
[01:08:39.200 --> 01:08:49.800]  циклом по массиву А, тот массив А ваш изначальный. Вы увидите 1, 2. Ключ берете равный 1. Смотрите,
[01:08:49.800 --> 01:09:02.760]  что такое А1. А1 это ключ, это есть единичка. Дальше берем преф 1, это 1. Тогда результат
[01:09:02.760 --> 01:09:09.200]  по первому индексу будет вот этой вот парой. То есть вы пишете именно индекс здесь, выбираете
[01:09:09.200 --> 01:09:16.240]  нужный вам. А дальше увеличивайте. Говорят, что у вас свободное место теперь только с двойки
[01:09:16.240 --> 01:09:23.280]  здесь. То есть вам нужно будет писать следующий элемент с ключом 1 по индексу 2. Дальше берете
[01:09:23.280 --> 01:09:36.320]  этот элемент 0. Преф 0 это 0, поэтому он пишет его на 0 место и говорит, что здесь 1. Дальше берет
[01:09:36.320 --> 01:09:46.320]  этот элемент. Ключ 1, преф 1 это 2, поэтому он пишет по второму индексу и соответственно
[01:09:46.320 --> 01:09:55.880]  заменяй здесь на троечку. Ну понятно, да, как это работает. Итого время работы
[01:10:00.680 --> 01:10:12.160]  от N плюс K, память от K. Потому что вот с Nt и преф этот массив длины K.
[01:10:12.160 --> 01:10:19.320]  Собственно, а в чем это польза этих сортировок? Казалось бы, вообще бесполезная вещь.
[01:10:19.320 --> 01:10:28.240]  Как теперь с помощью этой штуки сортировать произвольные числа?
[01:10:28.240 --> 01:10:38.640]  Ну вспомним, что произвольные числа это набор байтов просто в памяти компьютера.
[01:10:38.640 --> 01:10:49.320]  То есть у вас произвольное число это вот раз, два, ну давайте я int скажу, int это 4 байта.
[01:10:49.320 --> 01:10:59.480]  Но если быть более точным, я хочу вот такие вот числа сортировать у int 32t. 4 байта.
[01:10:59.480 --> 01:11:06.720]  Я же могу их стабильно отсортировать все числа по первому байту, согласны?
[01:11:06.720 --> 01:11:14.320]  Если отсортирую все числа по первому байту по убыванию, а дальше по второму байту,
[01:11:14.320 --> 01:11:20.800]  я что получу? Что у меня есть сортировка по второму байту, а по первому байту,
[01:11:20.800 --> 01:11:30.800]  если вторые равны, они будут отсортированы все еще. Согласны? Да, именно так. То есть сортируем
[01:11:30.800 --> 01:11:48.080]  стабильно по возрастанию, по байтово, от меньших к большим.
[01:11:48.080 --> 01:12:13.760]  Эта сортировка еще называется вот так вот. List significant digit sort. Именно так.
[01:12:13.760 --> 01:12:21.880]  Лекции, семинары, домашки, формула успеха на нашем курсе. Вот. Есть еще msd, если что.
[01:12:21.880 --> 01:12:26.640]  Это когда вы наоборот не от младших байтов к большему сортируете, а наоборот от больших к младшему.
[01:12:30.640 --> 01:12:34.600]  Вы научились сортировать числа вида у int 32t? Давайте посчитаем за сколько.
[01:12:34.600 --> 01:12:42.800]  Просто две вариации существуют. Мы их разбирать не будем, мы только это будем смотреть.
[01:12:42.800 --> 01:12:52.080]  Там что-то как-то умному делают, чтобы работало. То есть давайте посмотрим на время работы.
[01:12:52.080 --> 01:13:07.120]  Это будет от 4 умножить на n плюс 2 в восьмой. Ну 2 в восьмой, потому что у вас здесь это сколько
[01:13:07.120 --> 01:13:14.240]  бит, сколько у вас в байте может быть от 0 до 255 хранится, потому что это 8 бит. А четверка
[01:13:14.240 --> 01:13:21.240]  это потому что у вас раз, два, три, четыре блока. Шок контент мы построили сортировку за линию.
[01:13:29.240 --> 01:13:36.080]  Нам важно идти от меньших значащих байтов к большим значащим байтом. Другое в простом,
[01:13:36.080 --> 01:13:42.480]  как они у вас записаны, что меньше это будет первые 8 или последние 8 бит. Ну есть такие вещи
[01:13:42.480 --> 01:13:48.920]  и Little Endian и Big Endian. То есть заканчиваются на большие байты или на меньшие байты. Но это у вас
[01:13:48.920 --> 01:13:56.120]  будет у кого-то на окосе, у кого-то видимо на паке, так этот курс сейчас называется, у второго курса.
[01:13:59.880 --> 01:14:05.720]  Вам придется в системе узнать какой порядок Little Endian или Big Endian используется, потому что у вас
[01:14:05.720 --> 01:14:16.040]  есть задача написать эту штуку. Что? Ну да, можно, можно. Короче да, вот так вот, мы придумали самим
[01:14:16.040 --> 01:14:22.440]  сортировку за линию. И видите, мы здесь используем далеко не только то, что у нас есть 10, что у нас
[01:14:22.440 --> 01:14:28.400]  есть меньше-больше. Мы используем еще очень сильная и наглая информация о внутреннем строении числа в
[01:14:28.400 --> 01:14:33.120]  памяти компьютера. Поэтому эта сортировка не может являться сортировкой основанной на сравнениях.
[01:14:33.120 --> 01:14:40.960]  Если вы очень нагло используете вот эти вот штуки, то что у вас байты какие-то конкретные и то,
[01:14:40.960 --> 01:14:46.000]  что компьютер их именно так и представляет. Ну также вы можете строки сортировать по символам.
[01:14:46.000 --> 01:14:57.760]  То есть вы сортируете от меньших к большим. Вот, окей. Теперь давайте быстренько подведем
[01:14:57.760 --> 01:15:06.480]  анализ заключительный. HipSort. Сколько требует доп памяти HipSort?
[01:15:11.120 --> 01:15:16.360]  Так вы можете делать Hippify на нужном месте, а Extract Min у вас просто свапывает, в конец же идет и все.
[01:15:16.360 --> 01:15:32.600]  Доп память. Худшее время. Стабильность. Доп памяти HipSort у вас 100 единиц требует. На самом деле,
[01:15:32.600 --> 01:15:41.120]  вы можете прям на том же массиве все посортить. Худшее время. Ну вот, M.Lugen. Стабильности нет,
[01:15:41.120 --> 01:15:45.800]  HipSort нестабильен. Поэтому дело, что вы можете к каждому элементу добавить его ключ,
[01:15:45.800 --> 01:15:52.440]  ну его индекс, типа создать пары элементов и их посортировать уже. Но это плохо закончится,
[01:15:52.440 --> 01:16:05.480]  потому что доп памяти вот N требуется. Дальше MergeSort. Доп памяти MergeSort требует от N.
[01:16:05.480 --> 01:16:23.320]  Худшее время MergeSort N.Lugen. И он будет являться стабильным. Дальше. Давайте QuickSort.
[01:16:23.320 --> 01:16:40.720]  Без Median и Median. Какой у вас доп памяти требует QuickSort? А Stack Recursive кто хранить будет?
[01:16:40.720 --> 01:16:49.080]  В среднем. В худшем случае OATM. Если у вас без Median и Median, в худшем случае все будет очень плохо.
[01:16:49.080 --> 01:17:14.360]  В среднем OATM. В худшем OATM. Худшее время QuickSort. N квадрат. Стабильность. Нестабильная
[01:17:14.360 --> 01:17:30.040]  сортировка. Теперь QuickSort с MM. Доп памяти. Ну да, действительно, здесь нам нужно хранить с вами
[01:17:30.040 --> 01:17:36.720]  массив Median. Надо сохранить все-таки. Когда мы вырезали Recursive, у вас создается массив Median,
[01:17:36.720 --> 01:17:44.080]  так или иначе, в котором вы ищете саму Median. Вот этот массив 5 у вас. Это вы можете делать in place,
[01:17:44.080 --> 01:17:47.800]  но важно, что у вас этот массив вам нужно его отдельно сохранить, потому что вы его отдельно
[01:17:47.800 --> 01:17:56.000]  пробрасываете функцию. Поэтому OATM доп памяти себя. Но здесь мы говорим, что OATM.Lugen. Зато худшее
[01:17:56.000 --> 01:18:10.160]  время. И стабильности нет. Кто самый крутой? Так Merge вас требует OATM доп памяти. Так HipSort
[01:18:10.160 --> 01:18:22.400]  нестабильно. Так оно не умеет сортировать произвольные объекты. Здесь нет идеала, да.
[01:18:27.000 --> 01:18:31.840]  На QuickSort легко пишется на самом деле. Ну вот эта вот штука очень легко пишется.
[01:18:31.840 --> 01:18:41.040]  Это серьезный недостаток, конечно. У него памяти в среднем, то он OATM.Lugen и памяти в среднем меньше
[01:18:41.040 --> 01:18:50.840]  потребляют. Ну конечно, вы же можете себе выделить. Вот у вас был гигабайтный массив,
[01:18:50.840 --> 01:19:01.640]  давайте еще гигабайтный массив бахну. Мне ж не жалко. Дело в масштабах. Вот N это не очень много,
[01:19:01.640 --> 01:19:09.680]  но если N это гигабайт, то уже много. Вот. Короче говоря, вот так вот. То есть видите,
[01:19:09.680 --> 01:19:15.000]  здесь нет идеальной сортировки. У нас ее не проходим. По-моему, где-то утверждается,
[01:19:15.000 --> 01:19:18.520]  что существует какая-то идеальная сортировка, которая и стабильно, и OATM.Lugen в худшем времени,
[01:19:18.520 --> 01:19:24.240]  и OATM.Lugen до памяти потребляют. Что? Я даже не вспомню. На Википедии можно открыть,
[01:19:24.240 --> 01:19:29.520]  там есть огромная табличка сравнения сортировок. Вот там 50 штук. Вот найдете там идеал.
[01:19:35.160 --> 01:19:42.480]  Короче вот. Вот так вот. И, собственно, главный вывод это то, что вам нужно использовать. Мы же
[01:19:42.480 --> 01:19:49.240]  зачем изучаем разные сортировки? А затем, чтобы вы понимали в зависимости от задачи,
[01:19:49.240 --> 01:19:52.760]  какую вам можно использовать. Если у вас нет много допамяти, вы вынуждены использовать
[01:19:52.760 --> 01:19:57.880]  либо хипсорт, либо что-то еще. Если вам же нужна стабильность, то вы вынуждены использовать
[01:19:57.880 --> 01:20:03.760]  нордсорт. Если у вас обычные чиселки, то вы можете использовать LSD. Если это строки,
[01:20:03.760 --> 01:20:13.520]  тоже можете использовать LSD. Вот. В целом не надо использовать LSD. Вот. Так что в зависимости от
[01:20:13.520 --> 01:20:18.720]  задачи выбирайте, какой инструмент вам полезнее. И в целом мы на курсе алгоритма будем проходить
[01:20:18.720 --> 01:20:24.640]  много вещей, которые, казалось бы, похожи. Деревья поискают, мы будем несколько штук рассматривать,
[01:20:24.640 --> 01:20:28.520]  и у каждого из них будут свои нюансы. Хотя, казалось бы, там все будут работать плюс-минус
[01:20:28.560 --> 01:20:39.080]  алгоритм, там и что-то еще. Вот. Как-то так. Вопрос тогда остались. Ну тогда на следующем занятии мы
[01:20:39.080 --> 01:20:41.680]  начинаем деревья поиска, вот, сортировка, и мы закончили.
