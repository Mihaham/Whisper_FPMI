[00:00.000 --> 00:06.480]  Так, добрый день, начинаем.
[00:06.480 --> 00:27.800]  Так, начнем мы с продолжения LCA.
[00:27.800 --> 00:34.320]  В прошлый раз мы научились делать это за какие-то асимптотики.
[00:34.320 --> 00:39.880]  Напоминаю задачу. Есть корневое подвешенное дерево, то есть есть какая-то выделенная вершинка, назначенная корнем.
[00:39.880 --> 00:44.840]  Как бы можно считать, что все ребра направлены сверху вниз.
[00:44.840 --> 00:58.000]  Вот. И для каких-то двух вершин нужно найти самую близкую к корню вершины на пути между ними.
[00:58.000 --> 01:02.760]  А если опять-таки игнорировать ориентацию. Вот это и LCA будет.
[01:02.760 --> 01:08.480]  Мы научились это делать за N-логен предподсчета и единицу на запрос.
[01:08.480 --> 01:19.640]  Это с эллеровым обходом и с парстейблом на нем. Вот давайте теперь еще лучше сделаем.
[01:19.640 --> 01:22.040]  Давайте сделаем вообще линейный предподсчет и единицу на запрос.
[01:22.040 --> 01:29.040]  Значит, это будет способ 3 нахождения LCA. Это алгоритм Парахолтона и Бендера.
[01:29.040 --> 01:42.040]  Значит, сначала такое же. Построим эллеровый обход.
[01:42.040 --> 01:57.840]  Заметим, что соседние элементы в этом обходе всегда по глубине отличаются ровно на единицу.
[01:57.840 --> 02:02.040]  Потому что обход это что такое? Вот мы просто ходим по ребрам. Каждый раз, когда зашли в вершину,
[02:02.040 --> 02:07.680]  напечатали ее. Поэтому соседи в этом обходе, это соседи просто в графе. Значит, у них глубины ровно
[02:07.680 --> 02:16.840]  один отличаются. Значит, соседние элементы отличаются по глубине ровно на единицу.
[02:16.840 --> 02:30.640]  И мне нужно в этом массиве уметь искать минимум на отрезке. Раньше мы делали с помощью
[02:30.640 --> 02:34.200]  с парстейблом, а вот за такую симпатику. Теперь мы хотим как-то побыстрее это сделать.
[02:34.200 --> 02:41.080]  Использую информацию, что у меня глубины соседей отличаются на один. По высоте, да.
[02:41.080 --> 02:49.000]  Смотрите, я сейчас скажу следующее. Как искать минимум по высоте? Понятно, нужно просто в этом
[02:49.000 --> 02:56.680]  обходе на месте каждой вершины написать ее глубину и саму вершину как пару. И тогда нужно просто
[02:56.680 --> 03:03.960]  искать минимум на отрезке. Причем понятно, что основным параметром, по которому происходит
[03:03.960 --> 03:10.040]  сравнение, это вот как раз глубина. Давайте я сейчас буду игнорить V. Мне просто будет так удобнее
[03:10.040 --> 03:14.520]  расширять, потом ее когда надо можно вклинить. Меня сейчас на самом деле самое интересное,
[03:14.520 --> 03:19.480]  это просто найти минимум на отрезке вот по глубинам. Если я знаю, где это находится,
[03:19.480 --> 03:23.720]  то надо просто посмотреть, какое число в паре с ней стоит здесь, и это будет ответ. Поэтому
[03:23.720 --> 03:33.720]  сейчас на второй элемент пары я буду сбивать. Ну вот, у меня есть массив длины N. Массив глубин
[03:33.720 --> 03:46.760]  N. Давайте сделаем следующее. Давайте введем такую странную величину, половину алгорифма,
[03:46.760 --> 03:57.280]  и разобьем весь наш массив на блоке такого размера, по K. Ну там, если последний меньше,
[03:57.280 --> 04:02.880]  чем K, то он будет меньше, чем K, и бог с ним. Или там можно в конце чем-нибудь дополнить
[04:02.880 --> 04:12.160]  какими-нибудь бесконечностями, чтобы на K делилось. И при этом мы понимаем, что внутри каждого блока
[04:12.160 --> 04:18.360]  соседи отличаются на единицу. Поэтому на самом деле каждый блок можно представить следующим
[04:18.360 --> 04:23.200]  образом. Во-первых, это просто первый элемент, а во-вторых, это последовательность плюс-минус
[04:23.200 --> 04:27.520]  единичек, как каждый следующий, отличается от предыдущего. Если я знаю стартовый элемент,
[04:27.520 --> 04:34.960]  если я знаю все разности между соседями, скажем, что здесь плюс один, здесь минус один, здесь минус
[04:34.960 --> 04:41.280]  один, ну и так далее, если я знаю, в каком порядке все они идут, то я знаю целиком этот блок. Поэтому
[04:41.280 --> 04:47.200]  для описания блока мне достаточно знать х, и по факту маску из плюс-минус единиц длины ровно
[04:47.200 --> 05:04.000]  K, точнее K-1 даже. Вот, значит, маска размера K-1. Согласны? Вот. Ну более того, если я возьму и
[05:04.000 --> 05:08.200]  просто этот х за нулю, то это то же самое, что если просто вычесть из всех элементов маски х,
[05:08.200 --> 05:14.040]  тогда, конечно, минимум не изменится. Поэтому я могу считать, что у меня все задается просто маской,
[05:14.040 --> 05:26.440]  потому что я могу вычесть х из всех элементов. Нет, ну подождите, вот если у нас есть второй блок,
[05:26.440 --> 05:30.920]  я знаю здесь первый элемент у и знаю маску размера K-1, то я тоже этот блок целиком восстанавливаю.
[05:30.920 --> 05:43.000]  Так вот, потому что можно вычесть х. Ну, не то что можем забыть, а скорее никакие
[05:43.000 --> 05:46.920]  минимумы не изменятся. Точнее, если я из всех элементов вычту х, то у меня минимум на любом
[05:46.920 --> 05:53.160]  отрезке останется в том же месте, где был раньше, просто на х уменьшится. Значит, мне достаточно
[05:53.160 --> 05:59.240]  охранить только маску, ну и какое-то х отдельно. Если я знаю просто маску, а х считаю равным нулю,
[05:59.240 --> 06:02.920]  то потом после нахождения минимума на отрезке мне нужно просто х прибавить. Потому что х это
[06:02.920 --> 06:12.120]  общее, что я вычил из всех чуваков. Ну вот, хорошо, тогда вопрос, а сколько получается различных
[06:12.120 --> 06:17.360]  масок? Сколько различных блоков, вот если я сделаю такую нормировку их, если я вычил первый элемент?
[06:17.360 --> 06:26.360]  Ну два в степеника минус один, потому что масок ровно столько. Всего масок два в степеника минус
[06:26.360 --> 06:33.880]  один. Значит, его чудо это что-то маленькое. Ка специально так подобрано, там специально
[06:33.880 --> 06:41.000]  множество и одна вторая, чтобы здесь был корень из Н. То есть, вообще говоря, вот этих блоков после
[06:41.000 --> 06:45.400]  нормализации, то есть после вычитания первого элемента из них, их мало. Различных блоков,
[06:45.400 --> 06:59.560]  их всего корень максимум. Нет, различных масок вот столько, потому что ну просто два в степеника
[06:59.560 --> 07:11.200]  минус один. Каждый блок это маска, различных различных масок вот столько. То есть, мы
[07:11.200 --> 07:14.840]  получаем, что у меня, ну как бы самих блоков много, блоков вот столько, N делить на K,
[07:14.840 --> 07:21.040]  но различных из них после нормализации вот столько. Корень из N примерно. Тогда давайте
[07:21.040 --> 07:25.560]  сделаем следующее. Давайте мы для каждого нормализованного блока, то есть для каждой
[07:25.560 --> 07:37.920]  маски предпочитаем ответ на всех возможных подотресках на них. Первый шаг. Для всех масок
[07:37.920 --> 07:52.720]  предпочитаем минимум на всех подотресках
[07:52.720 --> 08:11.760]  для блока ноль запитая маск. Если у меня блок имеет первое число ноль, дальше вот кодирование
[08:11.760 --> 08:18.520]  плюс-минус 1 задается маской маск. Я хочу знать, я хочу предпочитать минимум на всех подотресках.
[08:18.520 --> 08:25.320]  Вот это, на всех возможных вообще. Понятно, что делается за корень из N на K квадрат,
[08:25.320 --> 08:29.840]  потому что у меня корень из N масок, корень из N вот таких массивов, на каждом из них за
[08:29.840 --> 08:37.840]  квадрат длины я могу предпочитать все минимумы. Значит, это делается за корень из N на K квадрат,
[08:37.840 --> 08:57.200]  то есть корень из N на K квадрат N. Вот это все еще что-то сильно меньше, чем N. Я говорю,
[08:57.200 --> 09:02.280]  что давайте я виртуально сейчас из всех блоков вот эти первые элементы вычел. Но и для них,
[09:02.680 --> 09:11.360]  для различных всех масок я предпочитал ответ. Теперь второй шаг, смотри, что произошло. У меня
[09:11.360 --> 09:22.440]  есть большой мой массив, длина N большая, который разбит на блоке. И в каждом блоке, на самом деле,
[09:22.440 --> 09:28.440]  я на любом его подотреске могу найти ответ за отоденицы. Как это делается? Я сначала понимаю,
[09:28.440 --> 09:34.760]  какая здесь маска. Как-нибудь заранее для каждого блока сохранил какая там маска. Знаю,
[09:34.760 --> 09:41.400]  какой здесь X и знаю, какой для этой маски на этом подотреске ответ. Ну и потом просто X
[09:41.400 --> 09:45.920]  прибавляю, чтобы восстановить его. Чтобы вот этот X вот сюда вот добавить, надо просто к минимуму
[09:45.920 --> 09:53.920]  добавить X. Поэтому на любом подотреске внутри блока я могу найти ответ за единицу, согласны?
[09:53.920 --> 10:00.840]  Просто потому что я это все предпочитал. Теперь надо научиться искать ответ между блоками. То
[10:00.840 --> 10:07.380]  есть, когда отрезок не внутри блоков, а какой-то вот такой. Делается очень просто. Мы найдем
[10:07.380 --> 10:12.560]  минимум вот здесь вот, минимум вот здесь вот, потому что мы умеем искать минимумы на подотресках
[10:12.560 --> 10:21.040]  внутри блоков. А вот здесь мы найдем минимум с помощью sparse table на блоках. Потому что это непрерывный
[10:21.040 --> 10:28.160]  подотрезок блоков. И мы сейчас, если воспринимать блок как нечто неделимое, то мы можем построить у
[10:28.160 --> 10:44.920]  них sparse table размер N делить на K. Второй шаг. Если блоки считать неделимыми, на них можно построить
[10:44.920 --> 11:04.760]  sparse table. Ну и поскольку блоков всего у меня N делить на K, то sparse table строится за N делить на K
[11:04.760 --> 11:13.080]  умножено логарифом N делить на K. Значит, sparse table строится за N делить на K логарифом N делить на K.
[11:13.080 --> 11:20.120]  Ну давайте подставим, что K это половина логарифма.
[11:20.120 --> 11:34.920]  Значит, логарифм отношения, это разность логарифмов. Ну здесь двоичный логарифм N,
[11:34.920 --> 11:43.160]  минус двоичный логарифм K. Вот. Значит, когда раскрываю скобки, эти логарифмы сократятся,
[11:43.160 --> 11:54.360]  останется N. Минус что-то еще. N минус что-то еще. Ну это все, понятно дело, от N. Вот. То есть
[11:54.360 --> 12:00.480]  по построму, поскольку я как бы сократил длину моего массива в K раз, я на нем могу sparse table
[12:00.480 --> 12:04.680]  за линию построить. Ну просто потому что массив стал сильно короче. У меня вместо одного элемента
[12:04.680 --> 12:11.720]  K элементов теперь. K элементов склеились в один. Все, а в sparse table я могу за единицу находить
[12:11.720 --> 12:18.560]  минимум на отрезке. Ну а то есть еще раз, когда поступает запрос минимума на каком-то большом вот
[12:18.560 --> 12:28.520]  таком вот куске массива, я сначала вычисляю, в каких блоках лежит начало и конец. Беру минимум
[12:28.520 --> 12:32.440]  вот здесь, вот минимум вот здесь, вот из первого шага, потому что для каждого блока я умею на под
[12:32.440 --> 12:37.400]  отрезке внутри блока находить минимум. А дальше у меня есть некий непрерывный кусок блоков,
[12:37.400 --> 12:42.360]  мне нужно на этом куске найти минимум на отрезке. Это я делаю с помощью второго шага,
[12:42.360 --> 12:47.600]  с помощью sparse table опять за единицу. Ну и все, получается, что ответ на запрос за единицу.
[12:47.600 --> 12:55.440]  Поясните?
[12:55.440 --> 13:04.880]  Ну, наверное, лучшим линии никак уж не получится.
[13:04.880 --> 13:12.480]  Ну у нас просто n большой элементов, наверное, предпочитать быстрее, чем за n невозможно.
[13:26.280 --> 13:29.600]  У нас ассимдотика, смотрите, получилось, первый шаг делается вот до столько,
[13:29.600 --> 13:36.240]  то есть за o от n, и второй шаг делается за o от n, а запрос за единицу, ну понятно,
[13:36.240 --> 13:42.680]  что эффективнее нельзя. Вот такая магия. Понятно?
[13:42.680 --> 13:52.880]  Так, ну хорошо, значит, мы научились находить lca за линейный предпочет и за единицу на запрос.
[13:52.880 --> 14:01.360]  Теперь мы можем это применить для того, чтобы находить минимум в любом массиве за линейный
[14:01.360 --> 14:11.960]  предпочет и единицу на запрос. Ну давайте напишу задачу. Задача, которую мы давно решали.
[14:11.960 --> 14:26.160]  Есть статический массив, а 1 и так далее а n. К нему поступают запросы. На отрезке lr найти
[14:26.160 --> 14:39.080]  минимум между lr. Найти минимум на отрезке между l и r. Ну это вот модельная задача для sparse table.
[14:39.080 --> 14:44.560]  Мы умеем это решать за n логин предпочета и единицу на запрос. Теперь научимся за линейный предпочет и единицу на запрос.
[14:44.560 --> 15:01.880]  Решение. Давайте построим дикартовое дерево
[15:01.880 --> 15:17.280]  с элементами, задающимися парами и ai. То есть и это ключ, а и это приоритет.
[15:17.280 --> 15:33.360]  Сейчас скажу за линию. Напоминаю дикартовое дерево. Это такая дерево поиска, точнее не так.
[15:33.360 --> 15:42.920]  Это бинарное дерево, являющееся деревом поиска по ключам и кучей по y. Куча по y значит минимум y
[15:42.920 --> 15:56.200]  всегда лежит в корне. Вот здесь я оставлю место для того, чтобы описать, как строить дерево за
[15:56.200 --> 16:01.320]  линейное время. На самом деле должна была быть эта задача в предыдущем семестре, что если у вас
[16:01.320 --> 16:07.520]  ключи уже отсорщены по возрастанию, но понятно, что ключи у нас просто 1, 2 и так далее n, то мы можем
[16:07.520 --> 16:13.440]  это построить дерево за линейное время. Значит вот здесь, давайте я оставлю, потом сюда вернусь, вопрос
[16:13.440 --> 16:26.280]  как построить это дерево за вот n, зная, что ключи упорядочены. Здесь достаточно знать только того,
[16:26.280 --> 16:37.360]  что ключи упорядочены. Теперь я отождаю следующее, чтобы найти минимум на отрезке в исходном
[16:37.360 --> 16:47.360]  массиве. Достаточно всего лишь в этом дереве найти LCA у этих двух вершин LAL и RAR. Отвержение,
[16:47.360 --> 17:04.160]  если, давайте я пишу так, если M это LCA для вершин L и R, то а M это минимум на отрезке SAEL по AVERT.
[17:04.160 --> 17:15.400]  И значит, вместо того, чтобы находить минимум на отрезке, мне достаточно будет просто в этом
[17:15.400 --> 17:23.720]  декартовом дереве найти LCA и вывести то число, которое в нем содержится. Давайте
[17:23.720 --> 17:27.360]  какой-нибудь примерчик нарисую и докажем.
[17:38.600 --> 17:42.520]  Так, пример.
[17:54.720 --> 18:02.720]  Пусть будет что-то такое. Понятно, что корнем будет вот эта вот четверка. Здесь я пишу ключ,
[18:02.720 --> 18:08.720]  запятая приоритет 4.1. Слева нужно вот эта вот будет корнем.
[18:24.720 --> 18:31.720]  Вот оно. Вот такое декартовое дерево получается по этому массиву. И, например, смотрите, если я хочу
[18:31.720 --> 18:36.920]  найти минимум на отрезке между первым и третьим элементом, то есть вот этот вот, вот он минимум,
[18:36.920 --> 18:42.600]  то мне реально нужно между ними найти LCA и вот он будет здесь же, в той же самой точке 2. Если
[18:42.600 --> 18:48.120]  нужно найти минимум между тройкой и пятеркой, вот они у меня, то их LCA вот здесь, это как раз
[18:48.120 --> 18:53.840]  минимум. Это точка номер 4, вот она, это действительно минимум. То есть действительно получается так,
[18:53.840 --> 18:59.600]  что минимум всегда там же, где LCA находится. Вот, но это на самом деле несложно показать,
[18:59.600 --> 19:06.720]  несложно показать. Давайте мы поймем вообще, где находится минимум. Вот пусть M это их LCA.
[19:13.440 --> 19:17.400]  Вот где-то оно находится, где-то эта вершина в нашем дереве располагается, M.
[19:18.120 --> 19:35.880]  Да. Да, вот это тогда скорее нет. Ну, по крайней мере, в обычной реализации у меня
[19:35.880 --> 19:44.640]  от TIN это нулевой TIN всегда вот здесь. Не знаю, нет, я не могу провести аналогию. То есть,
[19:44.640 --> 19:50.080]  ну вхожу-то я вот здесь, вот сначала-то вот здесь, а единица у меня самая левая вершина, она вот там
[19:50.080 --> 20:00.160]  вот. Поэтому, поэтому кажется, что нет. Ну вот, значит, давайте рассмотрим их LCA. Смотрите,
[20:00.160 --> 20:10.280]  я утверждаю следующее, что не может быть такого, что L и R больше, чем M. Вот такого быть не может,
[20:10.440 --> 20:14.960]  потому что если бы они были оба больше, чем M, то они должны бы оба лежать в правом поддереве.
[20:14.960 --> 20:23.160]  Ну, потому что декартовое дерево так работает, если я знаю, что M это предок L и R, и при этом они
[20:23.160 --> 20:25.720]  больше, чем M, то оно должно быть в правом поддереве, потому что у меня дерево поиска,
[20:25.720 --> 20:30.080]  все ключи больше, чем M, лежат в правом под дереве. Ну извините, тогда у меня M не может быть LCA,
[20:30.080 --> 20:37.480]  потому что эта вершина тоже их общий предок. Вот эта вершина тоже является предком и L и R.
[20:37.480 --> 20:43.060]  потому что они оба в этом под деревья. Значит такого не бывает. Не бывает. Ну
[20:43.060 --> 20:49.080]  симметрично не может быть такого, что LR оба в левом под деревья, потому что
[20:49.080 --> 20:53.560]  будь они оба в левом под деревья, вот эта вершина была бы их
[20:53.560 --> 21:04.280]  общим предком. Значит не бывает такого, что оба меньше чем m. Ну значит m как раз
[21:04.280 --> 21:08.680]  между ними. Из этого всего следует, что m действительно где-то на отрезке между
[21:08.680 --> 21:15.440]  ними. То есть по крайней мере мы попадаем куда-то внутрь отрезка. Теперь почему
[21:15.440 --> 21:23.920]  там минимум достигается, минимальное значение h? Ну смотрите, если есть вот это
[21:23.920 --> 21:32.280]  вот вершина m, в ее под дереве лежит целиком, ну точнее в ее под дереве лежит и L и R,
[21:32.280 --> 21:39.080]  значит целиком подрезок с L по R. То есть если где-то вот здесь вот лежит L, где-то
[21:39.080 --> 21:41.960]  здесь вот лежит R, то понятно, что весь отрезок между ними тоже целиком тут
[21:41.960 --> 21:52.560]  лежит. Так, сейчас. Я думаю это очевидно. Вопрос почему это так? Почему если какие-то
[21:52.560 --> 22:04.080]  две точки лежат, то между ними все тоже тут лежит? Да. Ну да, да, да, да, да, да. Я бы себе
[22:04.080 --> 22:08.840]  это объяснил так, потому что если взять какой-то ключ X, расположенный между L и R, и
[22:08.840 --> 22:12.720]  пытаться его искать в дереве поиска, то мы сначала дойдем досюда, потому что
[22:12.720 --> 22:18.560]  поведение от корня до отсюда такое же, как вот при сравнении с L или с R. Ну а
[22:18.560 --> 22:23.360]  дальше оно значит где-то внизу лежит. Я бы себе так это объяснил. Вот, значит
[22:23.360 --> 22:26.680]  действительно весь отрезок здесь целиком лежит. Но раз весь отрезок здесь
[22:26.680 --> 22:31.600]  целиком лежит, а m их общий предок, значит потому что дикартовое дерево это
[22:31.600 --> 22:36.680]  куча, вот эта штука меньше обравна, чем все вот эти вот. Потому что приоритет
[22:36.680 --> 22:40.680]  минимальный в корне, в корне текущего по дереву. Значит этот элемент меньше
[22:40.680 --> 22:46.360]  обравнен, чем все они, значит он минимум просто. Вот. Значит давайте напишем, что в под
[22:46.360 --> 23:07.640]  дереве, под дереве вершины m целиком лежит под отрезок с L по R, значит приоритет
[23:07.640 --> 23:19.320]  у m-ки минимальный. Приоритет у m минимален. Ну все, а это значит как раз что m это
[23:19.320 --> 23:32.080]  минимум на отрезке. Вот. Итого, мы свели задачу нахождения минимума на отрезке к
[23:32.080 --> 23:38.880]  задаче поиска LCA, а LCA мы по предыдущему алгоритму Фарахолтон Бендера умеем за
[23:38.880 --> 23:52.120]  линейный предпочет и за единицу на запрос отвечать. Да, да, да. Да, значит. Итог, свели
[23:52.120 --> 24:09.720]  к LCA, а LCA мы умеем решать за линейный предпочет и единицу на запрос. Победа. То есть получилось
[24:09.720 --> 24:15.320]  даже лучше, чем Спарстейбл. Ну и на самом деле просто как бы оптимальный алгоритм. Понятно,
[24:15.320 --> 24:30.440]  что быстрее нельзя. Вот. Вопросы есть? Да, значит у меня остался долг научиться строить дерево
[24:30.440 --> 24:37.600]  за линейное время. Ну давайте, давайте я это быстренько нарисую. Значит смотрите, я буду идти
[24:37.600 --> 24:43.040]  просто по вершинам. Значит у меня вершины все даны. Да, вот они. Я буду идти по ним слева направо и
[24:43.040 --> 24:49.440]  поддерживать текущую версию декартового дерева, постепенно добавляя в него вершины. Значит вот
[24:49.440 --> 24:54.440]  давайте я несколько вершин добавил, несколько первых. И мое декартовое дерево выглядит вот так.
[24:54.440 --> 25:02.680]  И вот здесь вот что-то. То есть я буду хранить правую ветку просто. От корня список всех правых
[25:02.680 --> 25:07.280]  его детей. Ну точнее как бы его правого сына, правого сына, правого сына и так далее и так далее.
[25:07.280 --> 25:13.920]  До самого конца пока есть вот эта правая ветка. Значит я построил вот такое декартовое дерево для
[25:13.920 --> 25:20.680]  начала нашего массива. Теперь приходит новый элемент ИАИ, который лежит правее, чем все это
[25:20.680 --> 25:27.600]  дерево, потому что И больше, чем все предыдущие ключи. Ну вот он где-то здесь. Ну тогда это уже
[25:27.600 --> 25:33.360]  значит нужно сделать примерно следующее. Нужно найти, нужно как бы провести такую горизонтальную
[25:34.360 --> 25:40.340]  понять какую стрелочку он рассекает и перенаправить вот эту стрелку сюда,
[25:40.340 --> 25:46.680]  а вот эту сюда. Тогда это будет корректно декартово дерево. Ну потому что как бы понятно,
[25:46.680 --> 25:52.100]  что у этой точки эта находится правее, а для этой это находится левее, и это будет корректно
[25:52.100 --> 25:57.920]  декартово дерево. Ну чтобы понять, что все хорошо, надо строго поговорить про все вот эти
[25:57.920 --> 26:02.800]  приоритеты там, короче, что это остается деревом поиска по ключам и кучей по Y,
[26:02.800 --> 26:11.800]  ну если позалипать, то это очевидно. Вот. И значит, я как бы, храня вот эту вот правую ветку,
[26:11.800 --> 26:17.680]  я могу просто, ну то есть смотрите, когда я новую вишину сюда вставляю, у меня правая ветка на
[26:17.680 --> 26:23.880]  самом деле вот так упрощается. Это уже не направо движение, а сначала влево куда-то. Это я удаляю
[26:23.880 --> 26:29.760]  из моей правой ветки. Значит, я могу правую ветку хранить в стеке, вершина стека будет вот здесь,
[26:29.760 --> 26:34.920]  дальше я удаляю несколько последних, и новая добавленная вершина будет всегда вершиной стека.
[26:34.920 --> 26:39.880]  Ну то есть я скажу, несколько последних мне нужно удалить, перенаправить здесь стрелки,
[26:39.880 --> 26:45.400]  добавить эту последнюю вершину, новую вершину на вершину стека, и перенаправить вот это вот
[26:45.400 --> 26:50.760]  ребро из последней вершины в последнюю вершину стека. То есть я храню правую ветку в виде стека.
[26:50.760 --> 27:03.000]  Ну и понятно, что это тоже линейное время, потому что у каждой вершины добавится
[27:03.000 --> 27:11.400]  удалиться максимум один раз, поэтому суммарно время работы линия. Кажется, все. Вопросы.
[27:11.400 --> 27:36.600]  Окей, окей. Значит, пафос, еще раз повторюсь, что научившись искать ильца в дереве за линейный
[27:36.600 --> 27:42.240]  предпочет и единицу на запрос, мы научились решать задачу поиска минимума в массиве опять за
[27:42.240 --> 27:48.080]  линейный предпочет и единицу на запрос. То есть даже лучше, чем то, что мы имели раньше, через
[27:48.080 --> 28:00.760]  вот такой переход к деревьям. Да, конечно, на самом деле в алгоритме нам даже, ну да-да-да-да-да-да,
[28:00.760 --> 28:11.560]  нам не нужны операции на декартном дереве, нам нужно просто дерево само. Ну вот, такой прикол.
[28:11.560 --> 28:19.880]  Так, хорошо, давайте следующий сюжет. Центральная декомпозиция.
[28:30.760 --> 28:37.040]  Напоминание. Центроид это такая вершина, что после ее удаления из графа все компоненты будут
[28:37.040 --> 28:45.000]  иметь размер не больше н пополам. Это такая вершина, что если удалить ее и все ребра из нее исходящие,
[28:45.000 --> 28:53.800]  то размеры всех компонентов будут не больше н пополам. Где n это число вершин, как обычно.
[28:53.800 --> 29:06.200]  Давайте представим себе какой-нибудь следующий тип задач. Задача дано дерево,
[29:06.200 --> 29:16.600]  нужно в нем посчитать количество каких-нибудь объектов. Количество чего-нибудь. Да. Подождите,
[29:16.600 --> 29:23.160]  это пока это название, тему сейчас вот я к ней подвожу. Я напоминаю, что какой-то центроид.
[29:23.160 --> 29:34.480]  Отлично. Видите, все помните. Значит, еще раз. Давайте рассмотрим следующий тип задач. Задача,
[29:34.480 --> 29:40.360]  есть дерево, и в нем нужно посчитать количество каких-нибудь объектов, которые как-нибудь описаны.
[29:40.360 --> 29:46.640]  Там, не знаю, количество вершин на данном расстоянии. Или количество путей, удовлетворяющих
[29:46.640 --> 29:52.320]  кому-нибудь свойству. Или количество троих вершин, таких что-то, что-то, что-то. Короче,
[29:52.320 --> 29:58.040]  количество каких-то объектов комминаторных. Тогда такую задачу можно было бы решать так.
[29:58.040 --> 30:06.800]  Смотрите, давайте выделим центроид в нашем дереве. Какие объекты пропадают после того,
[30:06.880 --> 30:14.320]  как я удаляю центроид и, соответственно, все ребра из него. Давайте упростим. Давайте считать
[30:14.320 --> 30:26.400]  пути. Например, нас просят найти количество каких-то путей. Просят найти количество каких-то
[30:26.400 --> 30:32.760]  путей. Каких-то, то есть, обладающих каким-то задным свойством. Я сейчас не хочу конкретить
[30:33.080 --> 30:40.680]  свойства, просто какое-то свойство. Какие пути, эти хорошие, которые мы ищем, пропадают после
[30:40.680 --> 30:47.200]  удаления центроида и, соответственно, разбиение задач на эти более мелкие. Я бы сказал те,
[30:47.200 --> 30:55.760]  которые проходят через центроид. Не обязательно длинные, они могут быть и короткие. Если я
[30:55.760 --> 30:59.760]  удаляю центроид, я какие-то объекты разрушаю. Я убиваю какие-то пути, которые надо было бы
[30:59.760 --> 31:07.080]  найти. Давайте их сначала все учтем. Посчитаем число объектов, проходящих через С. Потом С
[31:07.080 --> 31:12.480]  удалим вместе со всеми ребрами и рекурсивно решим задачу на всех поддеревьях. Сложим ответы
[31:12.480 --> 31:17.640]  вместе. Будет общий ответ. Понятно тогда, что я посчитаю все объекты, потому что каждый объект
[31:17.640 --> 31:22.600]  либо содержится, либо не содержит. И тогда он, соответственно, целиком лежит в одном из поддеревьев.
[31:22.600 --> 31:45.880]  Давайте это допишем. Сначала найдем количество объектов, содержащих С. Потом удалим С и
[31:45.880 --> 31:50.520]  рекурсивно решим задачу на всех поддеревьях.
[31:50.520 --> 32:19.280]  Вроде нет. Тогда смотрите в чем крутизна. Крутизна в том, что каждый рекурсивный
[32:19.280 --> 32:24.400]  спуск уменьшает размер текущего поддерева хотя бы вдвое. Потому что если изначально
[32:24.400 --> 32:28.600]  дерево было размера N, то после рекурсивного спуска у меня размер не больше ни на пополам за
[32:28.600 --> 32:33.640]  счет того, что я решил его центровить. Ну и дальше в рекурсии тоже самое происходит. В этом меньшем
[32:33.640 --> 32:38.720]  поддеревья находится какой-то новый центровец С штрих. За него все это поддерево подвешивается.
[32:38.720 --> 32:43.440]  То есть вот это вот я как бы подвешиваю за С штрих. Там будет опять такая же аналогичная картинка.
[32:43.440 --> 32:49.240]  Я сначала считаю количество объектов, проходящих через С штрих, потом его удаляю и рекурсивно
[32:49.240 --> 32:55.880]  запускается от всех поддеревьев. Ну и уж по крайней мере можно точно сказать, что глубина рекурсии
[32:55.880 --> 33:00.320]  будет логарифмическая. Потому что каждый спуск в рекурсии это уменьшение размеров по дереву хотя
[33:00.320 --> 33:09.240]  бы вдвое. Вот именно зависит от того, какие объекты мы ищем. Но для конкретных задач это
[33:09.240 --> 33:17.000]  обычно можно делать быстро. Значит глубина рекурсии будет логарифмическая, глубина рекурсии
[33:17.000 --> 33:25.400]  даже не просто логарифмическая. Ну в смысле не от логарифма, а просто там логарифм. Не больше,
[33:25.400 --> 33:34.760]  то есть логарифм округленный вверх скажем. Ну и теперь осталось нам как-нибудь эффективно научиться
[33:34.760 --> 33:41.160]  решать вот эту штуку. Вот если мы научимся находить количество объектов, проходящих через С,
[33:41.160 --> 33:47.440]  содержащих С как-нибудь быстро, то мы решим задачу, ну типа там Зейн Логан грубо говоря.
[33:47.440 --> 33:57.200]  Понятная идея? Хорошо, ну давайте например рассмотрим.
[34:12.160 --> 34:24.840]  Недолго думая решим такую задачу. Данного дерева и число D. Давайте отметим, что невзвешенное.
[34:24.840 --> 34:36.600]  Невзвешенное и число D. Надо найти количество пар вершин на расстоянии ровно D друг от друга.
[34:36.600 --> 34:51.680]  Найти число пар вершин у В таких, что расстояние между ними равно D.
[34:51.680 --> 35:14.280]  Вот. Начну как раз вот задачу такого типа найти количество объектов. Объект это ну по факту путь
[35:14.280 --> 35:20.640]  длины D. Потому что путь длины D и пара вершин на расстоянии D это одно и то же. То есть я сейчас
[35:20.640 --> 35:26.320]  буду искать по факту, давайте я напишу эквалентную формулировку, что это просто число путей длины D.
[35:26.320 --> 35:38.640]  Число путей длины D. Это вот ровно того типа задач. Значит сразу скажу, я не уверен, что эта задача
[35:38.640 --> 35:43.920]  нельзя решить как-нибудь попроще. Типа там просто хитрым DFS каким-нибудь достаточно умным предпочетом
[35:43.920 --> 35:49.760]  или что-то такое. Значит если вдруг вы научитесь решать эту задачу без центроида, то расскажите мне.
[35:49.760 --> 35:59.800]  Вопрос можно ли это делать без центровой декомпозиции? Ну если у вас вдруг к концу
[35:59.800 --> 36:03.400]  семестра много свободного времени образовалось, то вот подумайте, пожалуйста.
[36:03.400 --> 36:10.320]  Ну N log N достаточно.
[36:10.320 --> 36:18.920]  Композиции за N log N.
[36:18.920 --> 36:30.360]  Это я не знаю. То есть вроде как на вскидку нельзя, но может быть что-нибудь и может.
[36:30.360 --> 36:39.720]  Вот. Ну давайте научимся считать с центровой декомпозиции. Значит начало. То есть мы поняли,
[36:39.720 --> 36:43.080]  что самый сложный шаг это научиться искать число объектов, проходящих через центроид.
[36:43.080 --> 36:48.520]  Все остальное это общая схема, разбиение задач на подзадачи и рекурсивные решения в них.
[36:48.520 --> 36:54.640]  Итак, вот есть центроид. Давайте за него подвесим. У меня образуется несколько под деревьев.
[36:54.640 --> 37:06.640]  Мне сейчас нужно учесть, нужно добавить к ответу. Все пути, проходящие через C длины
[37:06.640 --> 37:13.960]  вот этой вот фиксированной D. Все пути такой длины. Ну это практически следующая величина.
[37:13.960 --> 37:23.280]  Давайте я подвешу все за C. Давайте я посчитаю глубину всех вершин. И тогда это практически
[37:23.280 --> 37:28.800]  следующая величина. Сумму по всем вершинам... А, ну и еще мне нужно будет, видимо, ввести
[37:28.800 --> 37:41.280]  количество вершин на каждой глубине. Пусть будет x от h. Это число вершин на глубине h.
[37:41.280 --> 37:52.960]  Вершин на глубине h. Тогда ответ это примерно следующая величина. Сумму по всем вершинам
[37:52.960 --> 38:09.720]  x от D-Dx от V. Потому что если я зафиксировал, скажем, один из концов нашего пути, то как
[38:09.720 --> 38:14.120]  он выглядит? Раз этот путь содержит C, то мне нужно сначала дойти до центроида, то есть подняться
[38:14.120 --> 38:19.640]  вверх. Это занимает у меня вот столько шагов. И потом нужно еще спуститься вниз вот настолько,
[38:19.640 --> 38:26.280]  чтобы длина была ровно D. То есть я сначала поднимаюсь вверх на depth от V, а потом мне
[38:26.280 --> 38:34.120]  нужно спуститься вниз вот настолько D-depth от V. И как раз если начало однозначно определено,
[38:34.120 --> 38:38.360]  то спуститься я могу ровно таким числом способов. Сколько вершин на такой глубине,
[38:38.360 --> 38:49.720]  столько способов и есть. Единственная проблема какая? Можно не делить, если я пару считаю
[38:49.720 --> 39:05.160]  порядочными. Другая проблема есть. Нет, это легко считается. Да, вот такие пути мы зачем-то
[39:05.160 --> 39:10.280]  посчитаем. Подняться D-depth, спуститься в то же под дерево и здесь куда-то вниз пойти. Это плохие
[39:10.280 --> 39:16.040]  пути. Ну мы считаем, как бы я тут явно написал, но конечно мы считаем простые пути. Число простых
[39:16.040 --> 39:20.600]  путей такое длинное. А вот эта штука нам такие пути посчитает. Вот нам нужно сейчас будет от них
[39:20.600 --> 39:27.360]  избавиться и потом мы победим. Пережив. Ну, значит на самом деле добивается это очень просто. Мы
[39:27.360 --> 39:36.480]  поняли какие пути плохие. Точнее, что мы учтем несколько раз. Мы учтем лишние пары внутри одного
[39:36.480 --> 39:42.800]  под дерево. Вот если V в этом под дереве и конец этого пути, вот такого стрёмного тоже в этом
[39:42.800 --> 39:48.800]  под дереве, то нам нужно его вычесть. Поэтому на самом деле можно после нахождения вот этой штуки
[39:48.800 --> 39:54.920]  вычесть то же самое внутри каждого под дерево в каком-то смысле. То есть мне смотрите, вот если у
[39:54.920 --> 40:01.940]  меня V вот здесь фиксировано, то что мне нужно выкинуть? Мне нужно выкинуть количество вершин в этом
[40:01.940 --> 40:13.720]  под дереве таких, что длина вот этого пути это D. Давайте это по дереву нарисую вот здесь. Вот
[40:13.720 --> 40:28.640]  здесь есть центрой C. Я хочу, чтобы вот этот путь имел длину D. Ничего ломать не будет.
[40:28.640 --> 40:37.600]  Да, ну мы такие тоже удалим. Мы такие тоже удалим, если будет проблема. Ну, смотрите,
[40:37.600 --> 40:46.800]  если вот такой вот путь имеет длину D, то вот такой вот путь без центроида имеет длину D-2,
[40:46.800 --> 40:52.440]  потому что то ребро дважды учитывалось. А значит, мне нужно при фиксированном V вычесть просто из
[40:52.440 --> 41:03.120]  ответа число вершин в этом дереве на глубине, вот отсюда считаемой, типа D-2-DxV. Ну что-то такое.
[41:08.600 --> 41:19.480]  Ну типа того, да, типа того. Так, сейчас давайте я немножко по-другому это скажу. Вот пусть эта
[41:19.480 --> 41:36.720]  вершина PIT, тогда вершина U плохая, если она лежит в том же под дереве, что и V. Значит,
[41:36.720 --> 41:49.080]  если U и V лежат в поддереве PIT, ну где P-шки, это вот эти вот становья центроида. Вот это вот P1,
[41:49.080 --> 41:57.880]  P2 и так далее, там ПК. Вот если они лежат в одном поддереве и при этом, значит, сумма их глубин
[41:57.880 --> 42:09.120]  относительно центроида, это D. Вот. Ну а если я посчитаю их глубины относительно Pi,
[42:09.120 --> 42:15.760]  ну то есть расстояние до Pi, давайте их вот так вот обозначу, depth,
[42:15.760 --> 42:29.080]  depth-штрих, допусть будет. Да-да-да, это sin-центроида. Так вот давайте depth-штрих от каждой вершины,
[42:29.080 --> 42:45.640]  это расстояние до sin-центроида. Вот. Тогда с точки зрения работы внутри этого
[42:45.640 --> 42:50.680]  поддерева, то есть depth-глубины, это во всем дереве, а вот мне нужно, если на это я по дерево
[42:50.680 --> 42:56.040]  суживаю, то у меня глубины все на единичку уменьшаются, и мне нужно, чтобы вот эти вот глубины их
[42:56.040 --> 43:09.720]  в сумме давали бы D-2. Вот тогда такие пары надо вычесть. Ну вот, собственно, все. Тогда, смотрите,
[43:09.720 --> 43:14.440]  моя задача сваливается к следующей. Во-первых, мне нужно во всем дереве для каждой глубины посчитать
[43:14.440 --> 43:21.400]  число вершин на такой глубине. Во-вторых, в каждом из меньших поддеревьев, если я пересчитываю
[43:21.400 --> 43:26.400]  глубины как depth-штрих, ну то есть получается, для depth-штрих просто всегда на 1 меньше, чем depth,
[43:26.400 --> 43:34.960]  потому что я измеряю глубину не от sin-центроида, а от ребенка sin-центроида. Вот. Но опять наша
[43:34.960 --> 43:38.680]  самая задача, только уже внутри этого поддерева, число вершин на каждой конкретной глубине в этом
[43:38.680 --> 43:56.080]  поддереве. Вот. Их потом вычитаю. Значит, осталось, давайте напишу, сделать следующее. Во всем
[43:56.080 --> 44:16.840]  дереве и во всех поддеревьях P-шек найти число вершин на каждой глубине, не происходящей D.
[44:16.840 --> 44:31.840]  Ну или просто на самом деле на каждой глубине. Найти число вершин на каждой глубине. Это вот
[44:31.840 --> 44:36.400]  то, что у меня там X обозначено. X это в общем дереве, ну и в каждом вот этом поддереве тоже
[44:36.400 --> 44:44.080]  будет как бы свой какой-то X-штрих. Вот. А делать это очень просто. Смотрите, если у меня есть большое
[44:44.080 --> 44:51.400]  дерево, там подвешенное за что-то, за какой-то корень, как посчитать число вершин на каждой
[44:51.400 --> 44:58.880]  глубине? Но давайте сделать сначала следующее. Давайте запущу DFS на этом вот дереве, его все обойду
[44:58.880 --> 45:12.760]  и посчитаю для каждой вершины размер поддерева sub-3 и глубину depth. Сейчас скажу. Тогда, понятное
[45:12.760 --> 45:18.040]  дело, что глубина всегда не больше, ну скажем глубины всех вершин не больше, чем sub-3 от корня.
[45:18.040 --> 45:25.600]  Потому что sub-3 от корня это количество вершин вообще везде вот здесь вот. Ну и понятно,
[45:25.600 --> 45:29.400]  что глубина не может быть больше, чем размер всего этого дерева. Потому что даже в худшем случае,
[45:29.400 --> 45:36.400]  если идти вниз, глубина получается как раз размер поддерева. Значит, я могу сделать следующее. Я
[45:36.400 --> 45:45.640]  могу для корня завести массив размер sub-3 и просто для каждой вершины v добавить 1 в этом массиве в
[45:45.640 --> 45:52.960]  позиции depth от v. Значит, я завожу массив какой-нибудь там x от 0 до sub-3 от корня.
[45:52.960 --> 46:09.920]  Любой вершины делаю просто плюс-плюс x от depth от v. Как раз по глубине, вот она глубина.
[46:09.920 --> 46:27.000]  Sub-3 это количество вершин в поддереве. Ну смотрите, вот еще раз моя задача какая. Вот есть поддерево
[46:27.000 --> 46:35.120]  какое-то, просто дерево какое-то. Мне нужно для всех вершин посчитать глубину относительно вот
[46:35.120 --> 46:39.800]  этого корня и посчитать количество вершин каждой конкретной глубины. То есть мне нужно создать
[46:39.800 --> 46:45.280]  массив x, который бы для каждого числа, для каждого h сообщал количество вершин на такой глубине.
[46:45.280 --> 46:56.160]  Ну я это ровное дело, только как бы я ровно это и делаю, только мне нужно, ну вот короче,
[46:56.160 --> 47:01.760]  мне удобно ограничить размер x вот таким вот образом. То есть тут можно было бы вместо sub-3
[47:01.760 --> 47:13.600]  написать max depth, например. Вы мне запрещаете? Ну вот я говорю, мне так будет удобно. Пока что
[47:13.600 --> 47:18.800]  пока что это, то есть еще раз, пока что очевидно, что все глубины, все depth от v не больше чем sub-3
[47:18.800 --> 47:23.520]  от r. Ну я это объяснил, глубина всегда не больше чем количество вершин в этом дереве. Значит это
[47:23.520 --> 47:35.240]  все, это правильный код. Возможно. Но смотрите, я вот это сделал все. То есть получается,
[47:35.240 --> 47:48.280]  что я за время, пропорциональный размер этого дерева решил задачу. Не-не-не, ну да, ну типа того.
[47:48.280 --> 47:53.240]  Так вот теперь смотрите, вернемся сюда. Что мне нужно? Мне нужно было во всем этом дереве решить
[47:53.380 --> 48:00.240]  задачу, и во всех вот этих вот K под деревьях, во всех под деревьях сыновей. Причем время работы
[48:00.240 --> 48:07.620]  на всем под деревья, это скажем n, а на всех под деревьях это время работы равно размеру под дерева.
[48:07.620 --> 48:11.920]  Потому что тот массив, который я создаю, он как раз имеет размер такой же, как размер под дерево,
[48:11.920 --> 48:17.640]  и все ограничено размером под дерево. То есть вот здесь время работы c1, где c1 размер этого дерева,
[48:17.640 --> 48:22.600]  здесь время работы c2 и так далее, здесь время работы сk. Ну поэтому суммарное время
[48:22.600 --> 48:25.680]  время работы всех этих штук это сумма эссок, а суммарность
[48:25.680 --> 48:29.760]  здесь совершенно n-1, все кроме центроида. Поэтому
[48:29.760 --> 48:33.640]  суммарное время работы это n плюс сумма эссок, ну это
[48:33.640 --> 48:39.600]  вот l. И ту оценку через размер под дерево я вел
[48:39.600 --> 48:42.200]  именно для того, чтобы сказать, что время работы, то есть
[48:42.200 --> 48:47.480]  если бы я здесь написал max depth, то у меня время работы
[48:47.480 --> 48:53.200]  было бы как бы, ну можно и так. Просто здесь более
[48:53.200 --> 48:55.240]  наглядно видно, что здесь полностью время работы
[48:55.240 --> 48:59.040]  ограничено чисто размером под дерево корня. Поэтому
[48:59.040 --> 49:01.120]  здесь все вот эти времена работы, это размер этого
[49:01.120 --> 49:03.920]  по дереву, плюс это, плюс это, плюс это. А они в сумме
[49:03.920 --> 49:08.960]  дают как раз n. Поэтому суммарно, чтобы посчитать число путей
[49:08.960 --> 49:11.800]  длины d, проходящего через центроид, я потратил линейное
[49:11.800 --> 49:21.000]  время. Все. Да, да, да, да. То есть я вот эту вот задачу
[49:21.000 --> 49:24.120]  применяю ко всему дереву и вот к этим капот деревьям.
[49:24.120 --> 49:50.400]  Да, да, в это же под дерево. Да. Еще раз. Так. Так. Можно-можно-можно-можно-можно-можно.
[49:50.400 --> 49:53.480]  А потом вернем, типа, да? Можно так, да, вы правы,
[49:53.480 --> 49:58.880]  можно так. Но мне кажется, чуть-чуть труднее объяснять,
[49:58.880 --> 50:08.120]  но... Ваш тоже рабочий. Ау? Можно. Вы можете что хотите
[50:08.120 --> 50:19.440]  вообще? В алгоритме можно и не делать, да? Пожалуйста.
[50:19.440 --> 50:29.080]  Ну вот, вроде все. А то есть, смотрите, давайте еще раз,
[50:29.080 --> 50:34.200]  давайте пройдемся по алгоритму. То есть, во-первых, алгоритм
[50:34.200 --> 50:35.800]  мне дается деревом, мне нужно посчитать количество
[50:35.800 --> 50:38.440]  путей такой-то длины. Я в дерево сначала выбираю
[50:38.440 --> 50:41.560]  центроид. Центроид мы уже умеем искать. Подвешиваю
[50:41.560 --> 50:44.280]  дерево за центроид. У него появляются какие-то дети
[50:45.160 --> 50:51.200]  Я решаю вот ту задачу для всего дерева и всех вот
[50:51.200 --> 50:54.400]  этих вот кап от деревьев его детей. Тем самым узнавая
[50:54.400 --> 50:56.920]  количество вершин каждой конкретной глубины в каждом
[50:56.920 --> 50:59.800]  из этих деревьев. Дальше, там, суммируя какие-то правильные
[50:59.800 --> 51:03.720]  штуки, я узнаю количество путей как раз пересекающих
[51:03.720 --> 51:07.440]  ц, проходящих через ц. Дальше я все это удаляю, ц вместе
[51:07.440 --> 51:09.640]  с ребрами, и рекурсивно запускаюсь вот на этих
[51:09.640 --> 51:12.680]  по деревьях. Тогда давайте время работы померяем.
[51:12.680 --> 51:27.440]  Хорошо. Начнем со времени работы. Смотрите, если текущий
[51:27.440 --> 51:30.920]  размер по дереву был n, то я за отн нашел число путей
[51:30.920 --> 51:34.600]  пересекающих ц, проходящих через ц, и рекурсивно запустился
[51:34.600 --> 51:41.640]  от каких-то кусков. Давайте напишу так, что t от n – это
[51:41.640 --> 51:52.160]  от n плюс t от всех под деревьев, где я знаю, что все s не больше
[51:52.160 --> 51:55.400]  чем n пополам. Вот эти s – это как раз размеры под деревьев
[51:55.400 --> 51:58.560]  всех, под деревьев детей центроида. И причем они
[51:58.560 --> 52:00.000]  все имеют размер не больше чем n пополам.
[52:04.600 --> 52:16.800]  Так. И хочется сказать, что это будет n log n. Начнем
[52:16.800 --> 52:18.680]  давайте немножко по-другому. Представляете, почему это
[52:18.680 --> 52:26.240]  n log n? Вот есть у меня изначально все дерево, все n-вершин. Их
[52:26.240 --> 52:31.040]  обрабатываю я за линейное время, за отн. Дальше. Из
[52:31.040 --> 52:34.680]  исходного дерева, где было n-вершин, я удаляю центроид,
[52:34.680 --> 52:37.680]  разбиваю под задачу на несколько детей и, соответственно,
[52:37.680 --> 52:39.680]  запускаюсь рекурсивно для массива длины n1, то есть
[52:39.680 --> 52:43.080]  для дерева размера s1, для дерева размера s2 и так далее
[52:43.080 --> 52:46.520]  для дерева размера sk. Причем суммарный размер всех этих
[52:46.520 --> 52:51.240]  деревьев не больше чем n, точнее ровно n-1. Вот. Значит,
[52:51.240 --> 52:56.080]  это будет второй слой моей рекурсии. Каждое вот это
[52:56.080 --> 52:59.400]  вот дерево обрабатывается за линейное время от его
[53:00.040 --> 53:02.240]  значит, суммарно все вот эти деревья опять за линию
[53:02.240 --> 53:05.440]  обработаются. То есть суммарно весь второй слой рекурсии
[53:05.440 --> 53:08.600]  работает за линию, потому что здесь каждое за линию от
[53:08.600 --> 53:13.320]  размера и суммарный размер линии. Да. Ну и дальше
[53:13.320 --> 53:15.240]  тоже самое. Каждое из них рекурсивно разбивается
[53:15.240 --> 53:20.440]  на какие-то поддеревья, но при этом суммарно на третьем
[53:20.440 --> 53:22.440]  уровне рекурсии опять не больше чем n-вершин, значит
[53:22.440 --> 53:25.920]  они суммарно обработаны за линейное время отн. Ну и
[53:25.920 --> 53:29.200]  так далее. А глубина, как мы уже замечали, у нас
[53:29.200 --> 53:32.240]  ограничена логарифмом. Поэтому суммарный время работает
[53:32.240 --> 53:42.320]  n-логан. Ну вот. Нет, нет, нет, нет, нет. K это просто
[53:42.320 --> 53:44.240]  какой-то параметр. Сколько угодно может быть. Давайте
[53:44.240 --> 53:54.640]  напишу просто S. С какое-то. Наверное, ну вот наверное
[53:54.640 --> 54:00.360]  можно, но так как-то нагляднее. Давайте подумаем минутку.
[54:00.360 --> 54:08.400]  Ну тут надо понять, что n-логан, она выпуклая или вогнутая.
[54:08.400 --> 54:13.760]  То есть как бы у меня есть, у меня по сути есть n-1, представленное
[54:13.760 --> 54:16.320]  в виде суммы. Да, я, кстати, забыл написать, что n-1 – это
[54:16.320 --> 54:23.440]  сумма S. Вот. Мне нужно понять, какое максимальное значение
[54:23.440 --> 54:25.760]  может достигать вот эта величина при вот этих условиях.
[54:25.760 --> 54:32.400]  Ну это что-то неприятное. Надо понять, как ведется
[54:32.400 --> 54:36.000]  эта функция. Почему она вдруг максимально, именно когда
[54:36.000 --> 54:40.440]  они примерно поровну разбиваются. Ну да, вот именно, что они
[54:40.440 --> 55:00.320]  константа, поэтому не понятно. А так вроде. Ну вроде все.
[55:00.320 --> 55:09.000]  Так есть вопросы по центровой уровне композиции? Хорошо.
[55:09.000 --> 55:17.560]  Значит, тогда следующая структура – это хавиллайди-композиция.
[55:28.360 --> 55:35.640]  Хавиллайди-композиция. Значит, здесь уже задача не про подсчет чего-нибудь,
[55:35.640 --> 55:40.120]  а задача очень похожая на то, что мы делали в каких-нибудь там задачах на дерево отрезков.
[55:40.120 --> 55:45.120]  Да, например, что у нас было в дереве отрезков. У нас есть массив, и он как-то обновляется,
[55:45.120 --> 55:48.840]  и к нему поступают какие-нибудь запросы. Типа там обновить в точке и посчитать сумму на отрезки.
[55:48.840 --> 55:57.160]  Вот здесь то же самое только на дереве. А именно, есть какое-то дерево. Давайте я для удобства скажу,
[55:57.160 --> 56:05.120]  что на ребрах написаны числа. На ребрах написаны числа. Поступают запросы. На
[56:05.120 --> 56:11.240]  ребре число изменить и найти сумму на пути. То есть, если раньше я искал в массиве сумму на отрезки,
[56:11.240 --> 56:18.120]  то теперь я буду искать сумму на пути. Вот какое-нибудь там дерево. Не обязательно бинарное произвольное
[56:18.120 --> 56:24.000]  дерево. На ребрах написаны числа. Мне нужно искать сумму на пути и менять числа, записанные на пути.
[56:24.000 --> 56:30.880]  Вот что-нибудь такое же похоже на ДО хотелось бы сделать. То есть, по факту это просто запросы,
[56:30.880 --> 56:40.360]  запросы на путях. Так, напишу, запросы на путях. На путях. Ну, соответственно, модельная задача.
[56:40.360 --> 56:51.400]  Давайте зафиксирую. Такая. У нас есть дерево, давайте напишу так, дерево фиксированной структуры. То есть,
[56:51.400 --> 56:59.640]  как бы набор ребер одинаковый. Вот ребра не меняются, только числа на них. Дерево фиксированной структуры.
[56:59.640 --> 57:19.480]  Есть числа на ребрах. Есть два типа запроса. Первый это апдейт на ребре. Апдейт, скажем,
[57:19.480 --> 57:26.520]  ех. Это нужно число, записанное на ребре х, например, увеличить на, sorry, число, записанное на ребре е,
[57:26.520 --> 57:44.480]  увеличить на х. Число на ребре е, увеличить на х. Вот. Ну и второй это сумма на пути. Вам дают две
[57:44.480 --> 57:51.960]  вершины у и в, концы пути. Вот они. Вам нужно на единственном простом пути между ними найти сумму
[57:51.960 --> 58:01.320]  чисел записанных на всех ребрах. Найти сумму чисел на пути.
[58:21.960 --> 58:38.520]  Вот. Идея будет такая. Идея будет следующая. Я, вот эти вот пути, которые у меня есть в дереве,
[58:38.520 --> 58:50.000]  какие-то из них, так, сейчас. Значит, не так. Я мое дерево
[58:50.000 --> 59:03.000]  представлю в виде нескольких путей не пересекающихся. То есть, например, вот это дерево можно представить так.
[59:03.000 --> 59:11.800]  Вот такой вот путь. Вот такой вот путь. Единственные ребра бывают. Вот такой вот путь. И вот такой вот путь.
[59:11.800 --> 59:19.640]  Значит, я разбиваю все мое дерево на какие-то пути, не пересекающиеся по вершинам. Ну еще, возможно,
[59:19.640 --> 59:26.360]  будут такие отдельные ребра, которые отдельно будут торчать. Тогда у меня теперь каждый путь вот
[59:26.360 --> 59:31.600]  такой вот. Это, по факту, массив. Я могу вот такой путь воспринимать как массив. Потому что на нем
[59:31.640 --> 59:37.040]  фиксировано какой-то порядок, например, там снизу вверх. Вот они занумерованы эти ребра на этом пути.
[59:37.040 --> 59:42.840]  И я могу на каждом таком пути ввести дерево отрезков, например. На каждом пути ввожу структуру
[59:42.840 --> 59:48.240]  данных, которая, по факту, позволяет защищать на эти запросы. А дальше, смотрите, если на каждом таком
[59:48.240 --> 59:55.480]  пути у меня введено свое дерево отрезков, то чтобы, например, найти ответ на вот таком вот пути,
[59:55.560 --> 01:00:01.340]  то есть вот на этом пути, мне нужно взять ответ из вот этого дерева, из вот этого дерева отрезков и
[01:00:01.340 --> 01:00:05.480]  прибавить еще вот это ребро. Давайте я даже поинтереснее веду. Вот, например, вот такой путь мне
[01:00:05.480 --> 01:00:15.360]  нужно сделать. Если меня интересует ответ вот таком вот пути, то мне нужно взять целиком величину
[01:00:15.360 --> 01:00:21.920]  вот этого дерева, прибавить вес вот этого ребра и взять под отрезок вот этого нового дерева.
[01:00:21.920 --> 01:00:28.800]  И мне хотелось бы сделать так, чтобы вот этих вот суммарно количество деревьев отрезков,
[01:00:28.800 --> 01:00:33.140]  которые я перехожу в моем пути, было не очень много. Тогда если, скажем, мой вот этот путь
[01:00:33.140 --> 01:00:38.440]  между У и В пересекает какое-нибудь маленькое количество деревьев отрезков, ну как бы имеется
[01:00:38.440 --> 01:00:42.600]  с ними не пустое пересечение, то мне нужно будет в несколько, в небольшое количество деревьев
[01:00:42.600 --> 01:00:46.140]  отрезков сделать запрос на отрезке. Ну и плюс еще вот эти вот ребра, которые
[01:00:46.140 --> 01:00:51.080]  переходят между деревьями тоже учесть. Если их будет маленькое количество, у нас их будет
[01:00:51.080 --> 01:00:55.400]  логарифмическое количество, то я смогу отвечать на запрос за лог квадрат. Потому что у меня
[01:00:55.400 --> 01:01:00.360]  логарифм разных деревьев, отрезков, и в каждом дереве я за логарифм отвечаю на запрос.
[01:01:00.360 --> 01:01:06.960]  Тогда у меня получится ответный запрос за лог квадрат. Вот идея такая. Значит, как мы это реализуем?
[01:01:06.960 --> 01:01:16.080]  Как мы это реализуем? Значит, во-первых, давайте мы опять посчитаем размеры всех по деревьев.
[01:01:16.080 --> 01:01:27.640]  Посчитаем с помощью DFS размеры всех по деревьев.
[01:01:27.640 --> 01:01:50.800]  Дальше. Давайте рассмотрим какую-то вершину и все исходящие линии ребра.
[01:01:50.800 --> 01:02:04.600]  Тяжелым или активным я назову ребро, ведущее в самое большое под дерево. Тяжелое ребро — это
[01:02:04.600 --> 01:02:12.480]  ребро, ведущее из В какого-то из сыновей с наибольшим размером под дерево. Тяжелое
[01:02:12.480 --> 01:02:31.400]  ребро из В — это ребро сына с наибольшим сап-3. Если таких несколько, давайте выберем вершину
[01:02:31.400 --> 01:02:44.440]  с меньшим номером. А если таких несколько, ну, я просто для однозначности напишу сына с наименьшим номером.
[01:02:44.440 --> 01:02:59.960]  Вот. Теперь у меня у каждой вершины есть какая-то выделенное ребро вниз. У каждой вершины есть
[01:02:59.960 --> 01:03:07.480]  выделенное ребро вниз. Из всех детей один выбран. Такой, у которого размер вот этот, то есть вот это
[01:03:07.480 --> 01:03:11.080]  вот по дереву самое большое, по сравнению со всеми остальными они будут маленькими. Вот такие вот.
[01:03:11.080 --> 01:03:26.000]  Ребро самого большого сына. Так. Ну и вот теперь, если вот эти вот тяжелые ребра воспринимать,
[01:03:26.000 --> 01:03:31.880]  как вот эти вот самые выделенные, да, вот которые здесь сплошными рисовал, и пути выделять,
[01:03:31.880 --> 01:03:39.840]  как пути тяжелых ребер подряд, то это и будут те пути, которые мы ищем. Значит, разбиваем дерево,
[01:03:39.840 --> 01:03:58.480]  дерево на пути из тяжелых ребер. Пример сразу нарисую, чтобы было понятно,
[01:03:58.480 --> 01:04:13.040]  что имеется в виду. Так. Какое-нибудь мне нужно дерево большое. Ну вот я сейчас как раз проиллюстрирую.
[01:04:13.040 --> 01:04:18.560]  То есть у меня у каждой вершины выделено какое-то исходящее ребро, и вот последовательность подряд
[01:04:18.560 --> 01:04:22.920]  идущих ребер, тяжелых вот этих вот, это будет путь, на котором я буду строить дерево отрезков.
[01:04:22.920 --> 01:04:30.920]  Так. Вот давайте, например, такое дерево, вот он корень. Давайте у каждой вершины найдем тяжелое
[01:04:30.920 --> 01:04:36.720]  исходящее ребро. Значит, снизу вверх, но для листьев тяжелого ребра нет. Вот здесь у меня все три под
[01:04:36.720 --> 01:04:41.160]  дерево одинаковые. Ну давайте для определенности самое левое из них выбирать. Вот оно, тяжелое
[01:04:41.160 --> 01:04:46.600]  ребро. Дальше у этой вершины здесь одна вершина под дерево, здесь четыре. Понятно, что вот это
[01:04:46.600 --> 01:04:52.240]  ребро, это тяжелое ребро. Самое большое ребро тяжелое. Так. Здесь тоже самое. Из трех детей
[01:04:52.240 --> 01:05:01.120]  выбираю самого левого. Здесь один, четыре, один. Опять этот самый тяжелый. Вот. Тут пока непонятно.
[01:05:01.120 --> 01:05:07.040]  Здесь из двух детей выбираем самого левого. Здесь самый тяжелый опять вот он. И теперь мне
[01:05:07.040 --> 01:05:12.040]  нужно определить для корня, кто из вот этих вот трех под деревом самый тяжелый. Давайте размеры
[01:05:12.040 --> 01:05:27.160]  посчитаем. Здесь 6 получился размер, здесь 7, здесь тоже 7. Похоже на правду, да. Ну из них
[01:05:27.160 --> 01:05:33.560]  максимальная семерка, из них выбираем самого левого. Вот оно. Что получилось? Вот у меня
[01:05:33.560 --> 01:05:39.680]  получился один путь по тяжелым ребрам. Второй путь и третий путь. То есть вот эти вот цепочки
[01:05:39.680 --> 01:05:44.440]  подряд идущих вниз путей по тяжелым ребрам, это и будут те пути, на которых мы будем строить
[01:05:44.440 --> 01:05:49.440]  деревоотресков. Вот. Будем называть это тяжелыми путями. Вот эти вот товарищи тяжелые пути.
[01:05:49.440 --> 01:06:12.800]  Тяжелые пути. Значит, на них строим деревьяотресков. На тяжелых путях строим, ну в нашей задаче деревоотресков,
[01:06:12.800 --> 01:06:17.440]  в общей задаче какую-то структуру данных, ту структуру данных, которая позволяет на вот
[01:06:17.440 --> 01:06:40.200]  эти запросы отвечать. Давайте в нашем случае строим деревоотресков. Да. На каждом свое. Да. Вот
[01:06:40.200 --> 01:06:44.440]  здесь, ну то есть как бы мне нужна структура, как бы там класс какой-то деревоотресков, который
[01:06:44.440 --> 01:06:49.320]  по данному набору ребра строит на нем деревоотресков. У меня будет вот здесь одно, вот здесь второе,
[01:06:49.320 --> 01:06:57.040]  здесь третье. Они не пересекаются, это прям отдельные сущности независимые. Давайте напишем свое. Да,
[01:06:57.040 --> 01:07:11.320]  свое. Что? Сейчас скажу. Вот в этом графе у меня будет три деревоотресков. Одно из них имеет
[01:07:11.320 --> 01:07:15.840]  размер два, потому что вот эти два ребра, ну то есть как бы мне нужно построить деревоотресков на
[01:07:15.840 --> 01:07:22.440]  вот этих числах, х и у. То есть у меня будет вот такое деревоотресков, а здесь сумма х плюс у. Ну как
[01:07:22.440 --> 01:07:29.320]  строится ДО на сумму оботрески. Если здесь написано АВЦ, то у меня написано в листах АВЦ, а здесь
[01:07:29.320 --> 01:07:36.240]  там ну как-то считается сумма. Вот так, например. То есть я, ну на самом деле не важно, давайте
[01:07:36.240 --> 01:07:41.120]  считать, что у меня номерация идет снизу. Вот у меня есть набор чисел снизу вверх на этом пути.
[01:07:41.120 --> 01:07:48.880]  Я на нем как на массиве обычном строю деревоотресков. Не все, не все, не все. Конечно,
[01:07:48.880 --> 01:07:56.160]  какие-то ребра, которые не помечены тяжелыми, они не войдут ни в какое ДО. Это пока нормально.
[01:07:56.160 --> 01:08:13.240]  Потому что по определению, это вершина, у нее есть тяжелый сын, вот он, у нее есть тяжелый сын,
[01:08:13.240 --> 01:08:21.680]  это все путь тяжелый, путь из тяжелых ребер. Я на нем тоже строю ДО. Неважно, просто-просто,
[01:08:21.680 --> 01:08:26.360]  вот есть вершина какая-то, у нее есть исходящее тяжелое ребро, у нее есть исходящее тяжелое
[01:08:26.360 --> 01:08:31.480]  ребро и так далее. Вот целиком, пока я вниз могу этот путь продолжить, я все это объединяю и говорю,
[01:08:31.480 --> 01:08:39.440]  что это один тяжелый путь. Сплошной, как бы, сплошная постоянность тяжелых ребер. Да нет,
[01:08:39.440 --> 01:08:47.960]  бывает почему, если у вас вот такое вот дерево, например, у вас вот будет тяжелый путь ДН1. Хорошо.
[01:08:48.080 --> 01:09:05.840]  Вот, а теперь, значит, утверждение. Путь между вершинами У и В пересекает не больше,
[01:09:05.920 --> 01:09:21.840]  чем от Логен тяжелых путей. Если мы это докажем, то мы победили на самом деле,
[01:09:21.840 --> 01:09:27.120]  потому что, ну, как бы, я это уже описывал, что если есть какой-то путь, то он, получается,
[01:09:27.120 --> 01:09:31.960]  складывается из каких-то кусочков тяжелых путей непрерывных. На каждом тяжелом пути нужно сделать
[01:09:31.960 --> 01:09:36.560]  запрос к ДО за логарифом, и есть еще между ними перемычки, например, вот здесь. Если я ищу путь
[01:09:36.560 --> 01:09:42.280]  отсюда до сюда, то мне нужно взять целиком отрезок вот этот вот, потом добавить это легкое ребро,
[01:09:42.280 --> 01:09:46.920]  ну, я знаю, ну, как бы, не тяжелое ребро, я знаю, как это на нем написано, просто храню, добавляю
[01:09:46.920 --> 01:09:51.960]  к ответу. И вот на этом куске, то есть на этом отрезке в массиве, в своем ДО, я тоже добавляю
[01:09:51.960 --> 01:09:57.000]  ответ. Беру оттуда сумму, она у меня там хранится где-то, и за логарифом еще добавляю. Ну все.
[01:09:57.000 --> 01:10:14.960]  Почему это верно? Доказательства. Давайте рассмотрим путь от У до их LCA. Рассмотрим путь от У до LCA-UV.
[01:10:14.960 --> 01:10:28.040]  Вот такой восходящий путь. Значит, что такое, что значит, что нам придется пересекать разные
[01:10:28.040 --> 01:10:34.160]  тяжелые пути? Значит, например, у меня начало это какой-то один тяжелый путь, дальше ребро легкое,
[01:10:34.160 --> 01:10:39.800]  и я перехожу к новому тяжелому пути. Потом опять легкое ребро, опять перехожу к новому тяжелому
[01:10:39.800 --> 01:10:46.920]  пути, и так далее. То есть по факту число тяжелых путей, которые я здесь пересекаю, это количество
[01:10:46.920 --> 01:10:51.200]  с точностью до плюс-минус 1, это количество легких ребер, которые я встречаю, потому что каждое
[01:10:51.200 --> 01:10:57.760]  легкое ребро это переключение на другой тяжелый путь. Каждое легкое ребро это переключение на
[01:10:57.760 --> 01:11:05.240]  другой тяжелый путь. Но вопрос, сколько может быть легких ребер на пути от У до LCA? Вот я даже
[01:11:05.240 --> 01:11:11.000]  что не большим логарифом, потому что если ребро легкое, давайте это ребро рассмотрим, вот было
[01:11:11.000 --> 01:11:19.320]  легкое ребро какое-то, легкое. Значит, вот здесь вот размер поддерева не больше, чем у какого-то
[01:11:19.320 --> 01:11:26.920]  другого сына этой вершины. Значит, при переходе вверх по легкому ребру, текущий размер поддерева
[01:11:26.920 --> 01:11:33.440]  хотя бы удваивается, потому что если здесь был sub3 какой-то s, размер sub3 хотя бы s, то здесь
[01:11:33.440 --> 01:11:39.000]  еще тем более больше равно s, потому что это легкое, а значит в тяжелом хотя бы s. Значит,
[01:11:39.000 --> 01:11:46.280]  суммарно во всем поддереве хотя бы 2s плюс 1. Значит, подъем по легкому ребру хотя бы удваивает
[01:11:46.280 --> 01:11:51.760]  размер текущего поддерева, ну а удваивается можно логарифом раз только. Значит, легких ребер максимум
[01:11:51.760 --> 01:12:02.120]  логарифом их log n. Значит, как раз вот этих вот сплошных кусков тяжелых путей логарифмическое
[01:12:02.120 --> 01:12:08.480]  количество. Это у меня был путь от u до lca, путь от lca до v, но аналогично здесь можно его также снизу
[01:12:08.480 --> 01:12:13.960]  вверх пройти, здесь будет максимум логарифом легких ребер. Значит, суммарно у меня будет от
[01:12:13.960 --> 01:12:23.160]  логарифма тяжелых путей и от логарифма легких ребер. Похоже на правду? Ну и собственно все.
[01:12:23.160 --> 01:12:41.760]  Значит, тогда давайте я напишу как отвечать тогда на запрос. Ну запрос апдейта. С апдейтом все очень
[01:12:41.760 --> 01:12:47.120]  просто. Мне дают какое-то ребро, говорят на нем увеличить число на x. Значит, мне нужно понять это
[01:12:47.120 --> 01:12:51.240]  ребро легкое или тяжелое. Если легкое, то делать ничего не нужно, нужно просто обновить здесь число,
[01:12:51.320 --> 01:12:55.720]  потому что легкие ребра у меня в DO не входят. Легкие ребра это просто вот эти отдельные перемышки,
[01:12:55.720 --> 01:13:05.640]  которые я отдельно храню и бог с ними. Значит, если ребро легкое, я просто за единицу увеличиваю на
[01:13:05.640 --> 01:13:16.080]  нем храняющее число и больше ничего не делаю. Если оно тяжелое, то мне нужно понять в каком оно
[01:13:16.440 --> 01:13:20.280] preneу дерева отрезков лежит. Если оно тяжелое, значит оно является частью какого-то тяжелого пути.
[01:13:20.280 --> 01:13:25.880]  Мне нужно понять, что это за путь, то есть что за DO ему соответствуют и какой номер у этого
[01:13:25.880 --> 01:13:32.880]  ребра в этом дереве отрезков и на следующей ячейке сделать апдейт. Вот это вот сводится к
[01:13:32.880 --> 01:13:40.840]  Doesn't Useless Update в DO. Ну для этого мне нужно знать, какой номер у этого дерева отрезков,
[01:13:40.840 --> 01:13:45.120]  потому что у меня же много деревьев отрезков, да? У меня для каждого тяжелого пути свое дерево
[01:13:45.120 --> 01:13:47.480]  отрезков так вот давайте тогда буду просто для каждого
[01:13:47.480 --> 01:13:52.200]  ребра хранить что за номер DO в котором он лежит и какой
[01:13:52.200 --> 01:13:56.880]  у него номер в этом DO ну потому что у меня же вот это
[01:13:56.880 --> 01:14:00.440]  путь вот он скажем давайте это ребро номер ноль имеет
[01:14:00.440 --> 01:14:04.080]  в своем DO это один это два главное чтобы у каждого
[01:14:04.080 --> 01:14:08.840]  ребра был свой номер в этом DO вот значит у каждого
[01:14:08.840 --> 01:14:20.960]  ребра у каждого ребра нужен номер DO и позиция внутри
[01:14:20.960 --> 01:14:34.600]  этого DO и позиция внутри DO нет нет нет это предпочитывается
[01:14:34.600 --> 01:14:39.880]  за линию в самом начале это предпочитывается за линию
[01:14:39.880 --> 01:14:42.480]  в самом начале потому что ну вот давайте вот у меня
[01:14:42.480 --> 01:14:47.720]  было дерево мне нужно сейчас для каждого ребра сохранить
[01:14:47.720 --> 01:14:49.720]  какой номер DO у него то есть какой номер тяжелого
[01:14:49.720 --> 01:14:57.480]  пути и какая позиция внутри этого тяжелого пути так
[01:14:57.480 --> 01:15:04.320]  но наверное все таки удобнее сверху вниз нумеровать
[01:15:05.040 --> 01:15:08.040]  давайте снизу вверх раз уж начал значит как нумеровать
[01:15:08.040 --> 01:15:14.160]  снизу вверх вот я иду моим ДФСом для каждой вершины
[01:15:14.160 --> 01:15:17.200]  запоминаю родителя и если я дошел до вершины у которой
[01:15:17.200 --> 01:15:22.480]  нет тяжелого стына то есть до листа то я буду подниматься
[01:15:22.480 --> 01:15:26.100]  по родителям их нумеровать 012 то есть снизу вверх как
[01:15:26.100 --> 01:15:28.080]  бы рекурсию развернуть и здесь пронумеровать у
[01:15:28.080 --> 01:15:30.360]  них все у них все номера причем сказать что они все
[01:15:30.360 --> 01:15:32.320]  в одном DO лежат то есть завести какую-то новую структуру
[01:15:33.320 --> 01:15:36.640]  им всем сказать что эти ребра лежат в новом DO и имеют
[01:15:36.640 --> 01:15:40.600]  такие номера 012 вот ну и соответственно то же самое
[01:15:40.600 --> 01:15:46.000]  я как бы ну да то есть для каждого листа я просто поднимаюсь
[01:15:46.000 --> 01:15:49.240]  рекурсивно ну не рекурсивно просто по родителям поднимаюсь
[01:15:49.240 --> 01:15:52.720]  пока пока вот эти все ребра тяжелые я поднимаюсь и их
[01:15:52.720 --> 01:15:54.920]  нумеру то есть это просто в самом начале делать каким-то
[01:15:54.920 --> 01:16:00.720]  подсчетом тут ничего ничего в среднем не будет вот
[01:16:00.880 --> 01:16:02.560]  значит тогда это будет за логарифом потому что по
[01:16:02.560 --> 01:16:09.760]  факту это просто один запрос к до вот теперь сумму как
[01:16:09.760 --> 01:16:17.400]  находить ну тут как бы тоже нужны какие-то подробности
[01:16:17.400 --> 01:16:27.720]  но идейно уже все объяснили значит сумма во-первых мне
[01:16:27.720 --> 01:16:37.240]  нужна найти lca во-первых я нахожу их кольца и давайте
[01:16:37.240 --> 01:16:40.480]  я сведу задачу к двум под задачам сумму от у до w и
[01:16:40.480 --> 01:16:49.520]  от в до w ну две одинаковые задачи сейчас решаю от
[01:16:49.520 --> 01:16:53.360]  в от вершины до какого-то предка решаю теперь у меня
[01:16:53.360 --> 01:16:55.560]  задача такая вот есть у вот есть какой-то ее предок
[01:16:55.920 --> 01:17:01.400]  я хочу здесь найти сумму мне нужно этот путь уметь
[01:17:01.400 --> 01:17:04.120]  эффективно разбить на вот эти вот куски тяжелых
[01:17:04.120 --> 01:17:14.080]  путей и легкие перемычки между ними ну как это сделать
[01:17:14.080 --> 01:17:16.160]  на самом деле когда у меня происходит перемычка между
[01:17:16.160 --> 01:17:18.960]  одним тяжелым путем и другим это значит что вот здесь
[01:17:18.960 --> 01:17:22.080]  вот этот тяжелый путь как раз таки начинался вот
[01:17:22.080 --> 01:17:25.080]  это вот вершина самой верхней вершины вот этого נижнего
[01:17:25.080 --> 01:17:27.920]  тяжелого пути это его начал на самом деле ну потому
[01:17:27.920 --> 01:17:31.080]  что просто ребров родитель оно уже не тяжелое значит
[01:17:31.080 --> 01:17:34.280]  этотixon здесь начался поэтому мне нужно просто
[01:17:34.280 --> 01:17:37.840]  знать где начинается текущая тяжелый путь я попаду сюда
[01:17:37.840 --> 01:17:42.960]  его родитель соответственно это это лег Lane потом я
[01:17:42.960 --> 01:17:46.080]  пришел сюда знаю что я нахожусь в каком-то новом дереве
[01:17:46.080 --> 01:17:48.920]  отрезков в новом тяжелом пути знаю где он начинается
[01:17:48.920 --> 01:17:55.520]  вот это новое начинаешь серебро нахожу здесь сумму на пути мы так далее значит мне нужно
[01:17:55.520 --> 01:18:07.760]  давайте напишем что не нужно хранить позицию начала для каждого тяжелого пути
[01:18:07.760 --> 01:18:21.120]  но дальше делаю ровно вот это у меня есть вершина у меня есть какой-то тяжелый путь
[01:18:21.120 --> 01:18:27.040]  ее содержащий я знаю где он начинается да вот это вот начало давайте какой-то
[01:18:27.040 --> 01:18:37.000]  beginning beginning от в где от у где начинается тяжелый путь содержащий у вот если этот весь путь
[01:18:37.000 --> 01:18:42.520]  лежит целиком ниже чем в то есть в где-то еще выше если в или от сопредком beginning то мне
[01:18:42.520 --> 01:18:48.240]  нужно взять целиком сумму на этом пути сделать запрос в до причем я знаю на каком отрезке у меня
[01:18:48.240 --> 01:18:53.600]  все здесь нумеровано я знаю что это там это последний это предпоследний так далее короче
[01:18:53.600 --> 01:18:59.600]  я знаю какие у них номера скажем просто исходя из глубин я знаю глубину вот этого я знаю глубину
[01:18:59.600 --> 01:19:05.080]  этого я знаю длину ну короче короче номера их легко восстанавливается вот нахожу сумму на
[01:19:05.080 --> 01:19:10.880]  пути дальше следующий рюбов легкая я к ответу просто прибавляю его вес потому что легкие
[01:19:10.880 --> 01:19:16.880]  ребра у меня отдельно хранятся поднимаюсь сюда ну и делаю так пока не дадут до до дольца и
[01:19:16.880 --> 01:19:24.320]  таких итерации будет как раз логарифмическое количество то есть у меня от логарифма запросов
[01:19:24.320 --> 01:19:29.480]  до получается это лог квадрат
[01:19:37.480 --> 01:19:51.600]  да если правильно сделать то можно ну а вы умеете делать такой такой обход который бы хранил
[01:19:54.320 --> 01:20:04.480]  так давайте мы лекцию закончим и мы с вами это обсудим все да спасибо
