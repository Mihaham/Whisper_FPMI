[00:00.000 --> 00:08.280]  И начинаю рекординг здесь.
[00:08.280 --> 00:09.280]  Тут идет, там идет.
[00:09.280 --> 00:21.200]  Ну вот, то есть была трехчасовая лекция, мы устали от лекций,
[00:21.200 --> 00:23.520]  поэтому сегодня тоже будет лекция.
[00:23.520 --> 00:24.960]  Но только полуторачасовая.
[00:24.960 --> 00:27.640]  Дальше у нас будет практика, вы не поверите.
[00:27.640 --> 00:28.960]  Мы прям код попишем вместе.
[00:28.960 --> 00:32.560]  Вот, а про лекцию.
[00:32.560 --> 00:34.480]  Что-то, я думаю, не хватает.
[00:34.480 --> 00:35.480]  Кликера не хватает.
[00:35.480 --> 00:36.480]  Кликер.
[00:36.480 --> 00:37.480]  Вот это.
[00:37.480 --> 00:38.480]  Плохо, да?
[00:38.480 --> 00:39.480]  Стало лучше.
[00:39.480 --> 00:40.480]  Можно половину...
[00:40.480 --> 00:41.480]  Нет?
[00:41.480 --> 00:56.000]  Или там нету кнопочки, чтобы половину включить?
[00:56.000 --> 00:57.000]  Там раздельные выключатели?
[00:57.000 --> 00:58.000]  Нет.
[00:58.000 --> 00:59.000]  Ну ладно.
[00:59.000 --> 01:00.000]  Ну давайте.
[01:00.000 --> 01:01.000]  Нормально видно.
[01:01.000 --> 01:02.000]  Начинаем.
[01:02.000 --> 01:03.000]  Все хорошо.
[01:03.000 --> 01:04.000]  Все, прекрасно.
[01:04.000 --> 01:06.760]  Сегодня у нас будут космические корабли и друзья.
[01:06.760 --> 01:10.400]  Ну может кто-то что-то уже слышал про это и понимает
[01:10.400 --> 01:11.400]  о чем.
[01:11.400 --> 01:12.400]  Но так со стороны.
[01:12.400 --> 01:17.280]  Да, он самый, там flying saucer его называют, то есть летающая
[01:17.280 --> 01:18.280]  тарелка.
[01:18.280 --> 01:19.280]  Работает?
[01:19.280 --> 01:20.280]  Не работает.
[01:20.280 --> 01:21.280]  Вот так сработает?
[01:22.280 --> 01:23.280]  И так не сработает.
[01:23.280 --> 01:24.280]  А он включен?
[01:24.280 --> 01:25.280]  Он всегда включен.
[01:25.280 --> 01:26.280]  Это же инфракрасное просто.
[01:26.280 --> 01:27.280]  Ну пожалуйста.
[01:27.280 --> 01:28.280]  О!
[01:28.280 --> 01:29.420]  Все.
[01:29.420 --> 01:30.700]  Работает.
[01:30.700 --> 01:32.260]  Тарелка.
[01:32.260 --> 01:46.520]  Я 크� 소�енку proplex и еще одна.
[01:46.520 --> 01:51.960]  Эм...
[01:51.960 --> 01:56.500]  Д conjugating.
[01:56.500 --> 02:00.500]  Ну, что-то каждый раз оно через 10 секунд включается.
[02:00.500 --> 02:07.500]  Вот, C++20 у нас наконец-то сделали нормально то, что у всех нормальных людей было нормально с самого начала.
[02:07.500 --> 02:09.500]  Но у нас всегда была боль.
[02:09.500 --> 02:13.500]  Ну, это такое краткое резюме того, что будет дальше в подробностях.
[02:13.500 --> 02:17.500]  Добавили новый оператор смешной, выглядит как летающая тарелка.
[02:17.500 --> 02:20.500]  Добавили, не поверите, дефолтные операторы сравнения.
[02:20.500 --> 02:25.500]  Даже по названию уже можно догадаться, что это, но там есть некоторые детали тонкие.
[02:25.500 --> 02:27.500]  И вот это.
[02:27.500 --> 02:30.500]  Ну, тоже можно по названию догадаться.
[02:30.500 --> 02:33.500]  Если не догадались, то давайте слушать внимательно.
[02:33.500 --> 02:36.500]  Начинаем мы с дурацкого вопроса, как обычно.
[02:36.500 --> 02:39.500]  Вот эти вещи равносильны?
[02:39.500 --> 02:41.500]  Нет.
[02:41.500 --> 02:44.500]  Да, у нас там есть понятие.
[02:44.500 --> 02:46.500]  Ну, тут даже подсказка есть.
[02:46.500 --> 02:49.500]  Ну, вы флоты.
[02:49.500 --> 02:53.500]  Ну, когда в армии флот плывет.
[02:53.500 --> 02:55.500]  Флоты, да?
[02:55.500 --> 02:57.500]  Floating Point Numbers.
[02:57.500 --> 03:00.500]  Почему для них вот это все не выполняется?
[03:00.500 --> 03:03.500]  Там сравнение не будет.
[03:03.500 --> 03:07.500]  Нет, с нормальными флотами должен выполняться проблема с нанами.
[03:07.500 --> 03:09.500]  Да, именно так.
[03:09.500 --> 03:12.500]  Там наны всякие разные и бесконечности, по-моему, тоже.
[03:12.500 --> 03:16.500]  Они как-то вот в эту всю картинку не очень вписываются.
[03:16.500 --> 03:19.500]  Ну, и да, вот понятие такое Loom было.
[03:19.500 --> 03:22.500]  Линейно-порядочное множество на MatLogia.
[03:22.500 --> 03:25.500]  Ну, даже неважно, если вы его не помните, но я надеюсь, что помните.
[03:25.500 --> 03:27.500]  Вот это.
[03:27.500 --> 03:29.500]  Еще такая смешная штука.
[03:29.500 --> 03:31.500]  Уже нет отдельного слайда? Нет.
[03:31.500 --> 03:33.500]  Подскажите, Женя.
[03:33.500 --> 03:36.500]  Да, тут не хватает слайда.
[03:36.500 --> 03:39.500]  Ну, это, короче, буквально то, о чем вы говорили вчера,
[03:39.500 --> 03:41.500]  про симпатическую разницу.
[03:41.500 --> 03:44.500]  Ну, как бы да, но не совсем.
[03:44.500 --> 03:47.500]  Тут добавляется новая деталь.
[03:47.500 --> 03:51.500]  Вчера я говорил про равенство представлений и равенство значений.
[03:51.500 --> 03:53.500]  Ну, не вчера, на прошлой неделе.
[03:53.500 --> 03:56.500]  Да, там было представление в битиках.
[03:56.500 --> 03:59.500]  И значение как...
[03:59.500 --> 04:02.500]  Ну, как что-то такое симантическое, что вы сами придумываете.
[04:02.500 --> 04:06.500]  Если оператор ровно-ровно для вектора, то
[04:06.500 --> 04:09.500]  два вектора разных, с одинаковым набором.
[04:09.500 --> 04:12.500]  Идеи должны быть равны, но они не неотличимы.
[04:12.500 --> 04:14.500]  Да.
[04:14.500 --> 04:17.500]  Вот это, кстати, тоже правда, потому что есть точка дата.
[04:17.500 --> 04:22.500]  И мы можем эту точку дата сравнить и понять, что они на самом деле отличимы.
[04:22.500 --> 04:26.500]  То есть как бы нам оператор равенства, говорит, и не равны.
[04:26.500 --> 04:29.500]  Но можно сделать некоторое преобразование и понять, что
[04:29.500 --> 04:32.500]  ой, на самом деле там какие-то детали имплементации внутри разные.
[04:32.500 --> 04:35.500]  И вот второе, это именно про вот детали имплементации,
[04:35.500 --> 04:37.500]  которые можно наружу вытряхнуть.
[04:37.500 --> 04:39.500]  То есть там любые какие-то структурки вы делаете,
[04:39.500 --> 04:42.500]  и для них компаратор только по одному полю из нескольких,
[04:42.500 --> 04:45.500]  вот ровный этот случай.
[04:45.500 --> 04:48.500]  Ну и вот штука слева называется equality в дальнейшем,
[04:48.500 --> 04:50.500]  а справа equivalence.
[04:50.500 --> 04:52.500]  Наоборот.
[04:52.500 --> 04:55.500]  Слева equivalence, справа equality.
[04:55.500 --> 04:58.500]  Да никак.
[04:58.500 --> 05:01.500]  Ну почему я про все это рассказываю?
[05:01.500 --> 05:05.500]  Потому что в плюсах, как обычно, покрыли крайние случаи.
[05:05.500 --> 05:08.500]  Эти крайние случаи у вас будут возникать далеко не всегда.
[05:08.500 --> 05:11.500]  В повседневной жизни у вас все это одно и то же,
[05:11.500 --> 05:13.500]  и все нормально, и все круто.
[05:13.500 --> 05:16.500]  А когда крайние случаи возникнут,
[05:16.500 --> 05:18.500]  вы вспомните, что что-то я об этом говорил,
[05:18.500 --> 05:20.500]  откройте с папе-референс, и по остаточным знаниям
[05:20.500 --> 05:22.500]  поймете, что там написано.
[05:22.500 --> 05:24.500]  Вот, ну и вот понятие сохранения равенства.
[05:24.500 --> 05:26.500]  Помните, оно было?
[05:26.500 --> 05:28.500]  Оно ровно про это.
[05:28.500 --> 05:31.500]  Про то, что никакое выражение нельзя написать,
[05:31.500 --> 05:37.500]  которое нам позволит потом отличить эти значения.
[05:39.500 --> 05:41.500]  Ну я надеюсь, это все пока несложно.
[05:41.500 --> 05:43.500]  Ну так к чему все это рассказывается?
[05:43.500 --> 05:46.500]  К тому, что есть теперь три янамо классных.
[05:46.500 --> 05:48.500]  Да, это янамо.
[05:48.500 --> 05:51.500]  Здесь нигде не подписано, но это они.
[05:51.500 --> 05:55.500]  Они нужны, чтобы моделировать разные типы порядков.
[05:55.500 --> 05:57.500]  Смотлога.
[05:57.500 --> 06:01.500]  Легко догадаться, что стронгордеринг — это вот именно лум,
[06:01.500 --> 06:03.500]  линейное упорядоченное множество.
[06:03.500 --> 06:06.500]  Тут вообще, переведя, понимаем, что это частично упоряд...
[06:06.500 --> 06:07.500]  Сейчас.
[06:07.500 --> 06:09.500]  Линейно... Да, я вроде правильно сказал.
[06:09.500 --> 06:13.500]  Линейно упорядоченное множество — это частично упорядоченное множество.
[06:13.500 --> 06:18.500]  Ну просто понятно, и вроде как должно быть понятно, зачем это, да?
[06:18.500 --> 06:23.500]  Как бы есть типы, для которых вот только частичный порядок можно гарантировать.
[06:23.500 --> 06:28.500]  Встречаются все-таки, хорошо бы про них уметь говорить на стандартном языке.
[06:28.500 --> 06:31.500]  Зачем посерединке штука?
[06:33.500 --> 06:36.500]  Вот из этой подводочки про эквивалентность равенства.
[06:36.500 --> 06:38.500]  Догадайтесь.
[06:38.500 --> 06:42.500]  Есть типы, которые не гарантируют то свойство, что больше-меньше значит равно?
[06:42.500 --> 06:44.500]  Нет.
[06:44.500 --> 06:46.500]  Наоборот, первая планета, вторая — нет?
[06:46.500 --> 06:48.500]  Что первая, что вторая?
[06:48.500 --> 06:53.500]  Первая — то, что меньше-больше, а вторая — это эквивалентность.
[06:53.500 --> 06:55.500]  Эквалити-эквивалентность.
[06:55.500 --> 07:01.500]  Окей. Меньше-больше, сейчас, не меньше и не больше, следовательно, равно
[07:01.500 --> 07:04.500]  выполнено и тут, и тут, и в стронговый виг.
[07:04.500 --> 07:09.500]  И то, и другое, и линейно-упорядоченное множество с точки зрения теории.
[07:09.500 --> 07:10.500]  Да?
[07:10.500 --> 07:12.500]  В чем отличие?
[07:12.500 --> 07:14.500]  В том, что...
[07:14.500 --> 07:16.500]  Строгая и строгая есть, меньше и меньше равно?
[07:16.500 --> 07:18.500]  Нет, тоже не это.
[07:18.500 --> 07:20.500]  Меньше и меньше равно есть везде здесь.
[07:20.500 --> 07:24.500]  И они все консистентно себя ведут, там все от вас требуют и все гарантируют.
[07:24.500 --> 07:30.500]  Разница в том, что понятие эквивалентности и равенства, они отличаются для стронговик.
[07:30.500 --> 07:33.500]  Вернее, для виг они разные, для стронга они одинаковые.
[07:33.500 --> 07:39.500]  Ну, да. Я не услышал просто формулировку, которая была бы мне понятна.
[07:39.500 --> 07:42.500]  А если мне не понятна, то, наверное, и вам не понятно.
[07:42.500 --> 07:44.500]  Ну, я предполагаю.
[07:44.500 --> 07:45.500]  Я тоже пока не понял.
[07:45.500 --> 07:47.500]  Не понял. Сейчас будет подробно.
[07:47.500 --> 07:51.500]  Первый сохраняет равенство.
[07:51.500 --> 07:57.500]  То есть, оператор равно-равно, вот здесь, как и меньше, и больше, и все остальные, они должны сохранять равенство.
[07:58.500 --> 08:09.500]  Это значит, что если вы берете точку из двух интов и делаете компаратор, который сравнивает эту точку только по первому из интов,
[08:09.500 --> 08:14.500]  то вы стронгордеринг не можете пользоваться для такого компаратора.
[08:17.500 --> 08:19.500]  Понимаете, о чем я?
[08:20.500 --> 08:24.500]  Сейчас еще раз помню.
[08:24.500 --> 08:26.500]  Давай попишем.
[08:26.500 --> 08:31.500]  Не крути так быстро камеру, если я иду сюда зачем-то, наверное, я вернусь.
[08:39.500 --> 08:41.500]  Что я хотел написать?
[08:41.500 --> 08:43.500]  О чем мы говорили?
[08:43.500 --> 08:45.500]  Стронг и виг.
[08:45.500 --> 08:46.500]  Да, точка.
[08:46.500 --> 08:48.500]  Точка XY.
[08:50.500 --> 08:52.500]  И мы говорим, что там...
[08:59.500 --> 09:01.500]  Я супер псевдокодом напишу.
[09:15.500 --> 09:17.500]  P2.x
[09:18.500 --> 09:22.500]  Можно вопрос в рамках equality, code и equivalence?
[09:22.500 --> 09:33.500]  То есть, если, ну, выполняется, что если равно-равно, то оно именно equality, то есть неотличимым.
[09:33.500 --> 09:35.500]  Равно-равно это эквилентность.
[09:35.500 --> 09:43.500]  Что значит выражение, которое показывают, ну, что нет выражений, которые показали бы отличимость?
[09:43.500 --> 09:45.500]  Взятие адреса у перемен, например.
[09:45.500 --> 09:48.500]  Это является штук, который отвечает?
[09:52.500 --> 09:56.500]  Отчаянно никто не верит, что оператор взятия адреса и хвалили по визио-органу.
[09:56.500 --> 10:04.500]  Да, тут есть куча маленьких деталек, таких как точка дату вектора, вот это вот взятие адреса.
[10:04.500 --> 10:09.500]  Ну, как бы, да, их не рассматриваем, их вот под ковер.
[10:09.500 --> 10:14.500]  Ковер, про это не считаем, у нас абстрактная машина C++, они не в счет.
[10:14.500 --> 10:16.500]  Вот, про что я говорю.
[10:16.500 --> 10:22.500]  Если вот такую структуру рассмотреть, две точки, точка из двух нтов, лотов, неважно.
[10:22.500 --> 10:29.500]  И делаем операторы всякие, все вообще делаем операторы сравнения для двух таких точек, только по иксу.
[10:29.500 --> 10:35.500]  Ну, в алгоритмах такое писали точно, правда? Нет?
[10:35.500 --> 10:39.500]  Ну, там есть всякие алгоритмы, где надо точки по иксу посортировать.
[10:39.500 --> 10:44.500]  Ну, да, в 2D за n log n.
[10:49.500 --> 10:50.500]  Чего-чего?
[10:54.500 --> 10:56.500]  Ну, да.
[10:56.500 --> 10:58.500]  Ну, вот представьте, что вот такое написали.
[10:58.500 --> 11:05.500]  Вот он, как бы, частичным множеством, частично-приличным множеством не является тогда эти точки, да?
[11:05.500 --> 11:07.500]  У нас здесь любая точка с любой сравнима.
[11:07.500 --> 11:09.500]  Это ничум, это лум.
[11:09.500 --> 11:15.500]  Но мы можем взять у двух точек, которые с точки зрения вот этих всех операторов равны,
[11:15.500 --> 11:24.500]  ну, то есть у них x равен, взять их y, y сравнить, и окажется, что, ой, не равны точки были.
[11:24.500 --> 11:28.500]  То есть с точки зрения наших там вот этих операторов сравнения они равны,
[11:28.500 --> 11:35.500]  а по факту мы можем их отличить, просто взяв их y и сравних в y отдельно уже, как nt, да?
[11:35.500 --> 11:38.500]  Знаете, в чем разница?
[11:38.500 --> 11:42.500]  Поэтому вот Стронгорденинг говорит, что так нельзя.
[11:42.500 --> 11:46.500]  Не должно быть такого, что вы какие-то данные можете извлечь из своих структур
[11:46.500 --> 11:51.500]  и потом отличить их, в то время как операторы сравнения вам говорят, что они равны.
[11:51.500 --> 11:53.500]  А флаты, еще раз, флаты это лум.
[11:53.500 --> 11:56.500]  Флаты это лум. Нет, чум.
[11:56.500 --> 11:59.500]  Паршалордеринг.
[11:59.500 --> 12:00.500]  Потому что там есть...
[12:00.500 --> 12:02.500]  Наны.
[12:02.500 --> 12:06.500]  Да, наны, несравнимые ни с кем, везде фолс, и там вообще что-то странное.
[12:06.500 --> 12:10.500]  Кажется, что тогда Стронгордеринг это просто сравнение над риск.
[12:10.500 --> 12:13.500]  Нет, нет, нет.
[12:13.500 --> 12:19.500]  Если мы сравниваем две точки по x и по y лексикографически, то это вполне себе Стронгордеринг.
[12:20.500 --> 12:22.500]  Не считается.
[12:22.500 --> 12:24.500]  Да, не считается.
[12:24.500 --> 12:26.500]  Вот это все не считается, это все другое.
[12:26.500 --> 12:28.500]  Не смотрим сейчас в память.
[12:28.500 --> 12:31.500]  Это семантика такая более высокоуровневая.
[12:33.500 --> 12:34.500]  Нет.
[12:34.500 --> 12:37.500]  Нет, да, нет.
[12:39.500 --> 12:41.500]  Подожди, Андрей, сейчас...
[12:43.500 --> 12:45.500]  Побитого они не обязаны совпадать.
[12:45.500 --> 12:46.500]  Давайте еще раз.
[12:46.500 --> 12:50.500]  Побитовое совпадение называется равенство представления.
[12:50.500 --> 12:53.500]  У любых данных есть представление битовое, да?
[12:53.500 --> 12:57.500]  Но концептуальные эти данные могут значить что-то более такое абстрактное.
[12:57.500 --> 13:02.500]  Понятно, что два n-та, они в памяти два n-та, в битах два n-та и везде два n-та.
[13:02.500 --> 13:08.500]  Но если мы этими двумя n-тами моделируем рациональные числа, то что это значит?
[13:08.500 --> 13:14.500]  Что на самом деле мы представляем себе как значение отношения этих n-тов.
[13:14.500 --> 13:18.500]  Просто мы в битах записываем их по отдельности, а не уже их отношения.
[13:18.500 --> 13:25.500]  И с нашей интуитивной точки зрения значения 2,4 и 4,8 оно одно и то же.
[13:25.500 --> 13:28.500]  И то и другое представляет одну вторую на самом деле.
[13:28.500 --> 13:30.500]  Вот все эти значения они одно и то же.
[13:30.500 --> 13:32.500]  Одно и то же рациональное число.
[13:32.500 --> 13:38.500]  То есть если мы такие рациональные числа пишем, то мы, наверное, в приват засунем вот эти вот n-ты,
[13:38.500 --> 13:42.500]  которых будет класс, там будет приватная часть, в нем будут два n-та.
[13:42.500 --> 13:44.500]  Снаружи к ним доступа не будет.
[13:44.500 --> 13:50.500]  Но снаружи будет оператор сравнения для такого рационального числа.
[13:50.500 --> 13:52.500]  Куча их.
[13:52.500 --> 13:58.500]  И вот они будут сравнивать как нормальные рациональные числа эти байтики
[13:58.500 --> 14:01.500]  и вполне себе будут образовывать стронгордеринг.
[14:06.500 --> 14:11.500]  То есть побитовые представления не совпадают, но стронгордеринг все равно есть.
[14:11.500 --> 14:13.500]  Можем его организовать.
[14:19.500 --> 14:22.500]  Да, и нельзя из этого привата достать.
[14:24.500 --> 14:27.500]  Понятное дело, что хаками можно. Говорим про хороший код.
[14:27.500 --> 14:33.500]  То есть если вы сделаете метод getRowDenominator или getRowNumerator, то это все сломается.
[14:33.500 --> 14:39.500]  Вы уже сможете их достать, сравнить, ой, они не равны, а нам сказали, что сами дроби равны, все сломалось.
[14:41.500 --> 14:43.500]  Тогда все нормально будет.
[14:46.500 --> 14:52.500]  Потому что ты из разных представлений битвах вытащишь для одной и той же дроби
[14:52.500 --> 14:55.500]  один и тот же числитель или один и тот же знаменатель.
[14:55.500 --> 14:57.500]  И все будет ток.
[14:57.500 --> 15:02.500]  То есть даже не то, что все в привате, а просто инварианты нужно сохранять.
[15:02.500 --> 15:07.500]  Вы должны разрабатывать структуры, классы или структурки,
[15:07.500 --> 15:11.500]  которые свои внутренние инварианты не дают им протекать наружу.
[15:11.500 --> 15:14.500]  Не дают протекать наружу формата представления данных.
[15:14.500 --> 15:17.500]  Понимаете, о чем я так философски?
[15:18.500 --> 15:22.500]  Окей, я вижу, вам наскучило. Давайте пойдем дальше.
[15:25.500 --> 15:30.500]  Зачем нам дополнительные требования сохранить сохранение реальности? Что оно нам дает?
[15:30.500 --> 15:36.500]  Оно нам дает возможность рассуждать о коде, не получая какие-то странные приколы.
[15:36.500 --> 15:41.500]  Просто это естественно работать с значениями, как с математическими значениями.
[15:41.500 --> 15:44.500]  Что там битовое представление...
[15:44.500 --> 15:49.500]  Ну, над обительными представлениями думать не хочется, хочется думать о значениях.
[15:49.500 --> 15:51.500]  В голове иметь какую-то абстракцию.
[15:51.500 --> 15:55.500]  Эту абстракцию, вот как просто вертеть ее как математический объект
[15:55.500 --> 15:58.500]  и на основе этого писать код, чтобы он работал.
[15:58.500 --> 16:04.500]  Как только вы даете своим битовым представлениям протекать наружу в обход абстракции значения,
[16:04.500 --> 16:08.500]  код становится писать сложнее, могут быть неожиданности.
[16:08.500 --> 16:12.500]  То есть все вот это вот, это про то, как писать правильный код.
[16:12.500 --> 16:16.500]  Если у вас стронгординг, то вы в шоколаде все хорошо, все правильно делаете.
[16:16.500 --> 16:18.500]  Обычно так и получается.
[16:18.500 --> 16:24.500]  А если что-то послабее, то надо уже задуматься, не пошло ли что-то не так и нормально ли все.
[16:24.500 --> 16:30.500]  Давайте идти дальше, потому что там еще много слайдов, я боюсь, я вперед уже забежал.
[16:30.500 --> 16:38.500]  У этих янамов, я напоминаю, это были янамы, которые как бы классифицируют типы компараторов,
[16:38.500 --> 16:45.500]  но у янамов есть элементы, которые дают ответ на вопрос сравнения.
[16:45.500 --> 16:48.500]  Вот два элемента, сравни мне их.
[16:48.500 --> 16:53.500]  Стронгординг вам может сказать less, equivalent, equal и greater.
[16:53.500 --> 16:59.500]  Но equivalent и equal у стронгордера это одно и то же значение.
[16:59.500 --> 17:02.500]  Один и тот же элемент янама.
[17:02.500 --> 17:04.500]  Да?
[17:04.500 --> 17:07.500]  Ну, легко догадаться, что у...
[17:07.500 --> 17:12.500]  Вот тут еще в таком формализме то же самое написано,
[17:12.500 --> 17:17.500]  что любая функция, которая как бы сохраняет вот этот контракт абстракции,
[17:17.500 --> 17:20.500]  она не может взять и различить.
[17:20.500 --> 17:22.500]  Вот все.
[17:22.500 --> 17:26.500]  Мы считаем вместе с этими побочными эффектами или без?
[17:26.500 --> 17:30.500]  Со всеми побочными эффектами, со всем таким.
[17:30.500 --> 17:33.500]  Внутренний счетчик просто увеличивает.
[17:33.500 --> 17:36.500]  Как с каждым уже зовут.
[17:36.500 --> 17:39.500]  Наверное, чистая функция, надо сказать.
[17:39.500 --> 17:41.500]  И без всяких адресов.
[17:41.500 --> 17:42.500]  Ну да.
[17:42.500 --> 17:45.500]  Мы сразу все отсекли.
[17:45.500 --> 17:47.500]  Ну, equality preserving, да.
[17:47.500 --> 17:51.500]  Смотрите, если вы хотите очень точные, очень максимально точные формулировки,
[17:51.500 --> 17:55.500]  их можно открыть в стандарте, но там, к сожалению, вот не столько строк, а вот столько.
[17:55.500 --> 17:57.500]  В этом проблема.
[17:57.500 --> 17:59.500]  То есть тут надо учитывать.
[17:59.500 --> 18:03.500]  Если мы обовляем рецензивные числа и глянем за динаминатор, то мы получаем q-кордеринг?
[18:03.500 --> 18:05.500]  Да.
[18:05.500 --> 18:07.500]  А что с ней?
[18:07.500 --> 18:09.500]  Они разные просто.
[18:09.500 --> 18:12.500]  Ну окей, у строн-кордеринга это одно и то же.
[18:12.500 --> 18:14.500]  Вот просто эти элементы янамы, они равны.
[18:14.500 --> 18:16.500]  Давай q-кордерингу.
[18:16.500 --> 18:17.500]  А, да.
[18:17.500 --> 18:20.500]  Тыры-пыры, объекты равны, неразличимый по концу ссылкам.
[18:20.500 --> 18:23.500]  Вот это вот прям, по-моему, цитата из стандарта.
[18:23.500 --> 18:25.500]  Идея в этом.
[18:25.500 --> 18:27.500]  Окей.
[18:27.500 --> 18:31.500]  У q-кордеринга уже нет просто equal.
[18:31.500 --> 18:37.500]  Мы не можем на равенство сравнивать то, что реализует q-кордеринг, только на эквалентность.
[18:37.500 --> 18:44.500]  То есть тут абстракция такая, что ваш компаратор реализует какой-то порядок,
[18:44.500 --> 18:47.500]  но который не совсем естественный для этих данных.
[18:47.500 --> 18:51.500]  То есть он учитывает не все данные, например.
[18:51.500 --> 18:54.500]  Или как-то нарушает абстракцию.
[18:54.500 --> 18:57.500]  Такое тоже бывает, поэтому он есть в стандарте.
[18:57.500 --> 18:59.500]  Но лучше стараться так не писать.
[18:59.500 --> 19:05.500]  Ну, если вы там для точек все-таки пишете компаратор, который только по одной из точек сравнивает,
[19:05.500 --> 19:08.500]  то вот такой он будет.
[19:08.500 --> 19:10.500]  И partial.
[19:10.500 --> 19:12.500]  Тут еще один вариант добавляется.
[19:12.500 --> 19:16.500]  У нас бывает, что вообще несравнимы два элемента, так как порядок частичный.
[19:16.500 --> 19:20.500]  Ничего космического, все окей.
[19:20.500 --> 19:27.500]  Да, вот тут странный вопрос, странно сформулированный.
[19:27.500 --> 19:30.500]  Непонятно, что я спрашиваю, да.
[19:30.500 --> 19:32.500]  А я спрашиваю вот что.
[19:32.500 --> 19:38.500]  Вам откуда-то с неба прилетела в автопеременную один из элементов одного из этих янамов.
[19:38.500 --> 19:42.500]  Написали там auto x равно, непонятно что.
[19:42.500 --> 19:48.500]  В обратку прилетел один из этих вот элементов одного из янамов,
[19:48.500 --> 19:52.500]  непонятно какого, и хочется понять, что он как бы в целом значил.
[19:52.500 --> 19:56.500]  Больше, меньше, равно или там вообще что-то непонятное.
[19:56.500 --> 20:02.500]  Это, кстати, нас отсылает к тому, о чем мы с самого начала говорили про спаны.
[20:02.500 --> 20:06.500]  Такая ситуация, где непонятно, что прилетело в обобщенном коде возникает,
[20:06.500 --> 20:10.500]  когда у вас еще один шаблон, вы даже не знаете, какой из янамов используете,
[20:10.500 --> 20:12.500]  и надо как-то выкручиваться.
[20:12.500 --> 20:17.500]  Ну, а нас позаботились, нам позволили сравнивать эти элементы
[20:17.500 --> 20:21.500]  любого из вышеперечисленных янамов с нулем.
[20:23.500 --> 20:27.500]  Ну и понятно, что будет, да.
[20:27.500 --> 20:31.500]  Мы сравниваем элемент, и при сравнении less будет меньше нуля,
[20:31.500 --> 20:39.500]  equal and equal будут равны, greater больше, и просто не равен ему unordered.
[20:40.500 --> 20:45.500]  То есть, на самом деле, это вот какой-то дебильный подхак, мое честное мнение.
[20:45.500 --> 20:51.500]  Можно было бы сделать функцию из less, и для всех less-ов из трех янамов возвращать true.
[20:51.500 --> 20:53.500]  Ну, идея в этом.
[20:53.500 --> 20:56.500]  А вот это вот не равно, это is unordered на самом деле.
[20:59.500 --> 21:04.500]  Ну оно как бы имеет некоторую такую интуитивную интуицию, но в целом...
[21:10.500 --> 21:12.500]  Короче, про лего сейчас дойдем.
[21:12.500 --> 21:14.500]  Потихонечку давайте.
[21:14.500 --> 21:16.500]  И внимание.
[21:16.500 --> 21:19.500]  Про UB в стандарте на ровном месте.
[21:19.500 --> 21:22.500]  Сравнивать можно только с литералом ноль.
[21:22.500 --> 21:25.500]  Если вы напишите в коде сравнение с чем угодно другим для этих янамов,
[21:25.500 --> 21:27.500]  то это UB.
[21:31.500 --> 21:34.500]  Почему? Зачем? Ну, вот так вот.
[21:35.500 --> 21:37.500]  Идем дальше.
[21:37.500 --> 21:40.500]  Но дело, что эти штуки образуют такую некую иерархию.
[21:40.500 --> 21:44.500]  Как бы strong он является и weak, и partial.
[21:44.500 --> 21:46.500]  Weak при этом является partial.
[21:46.500 --> 21:48.500]  Ну и...
[21:48.500 --> 21:50.500]  Короче, картинка.
[21:50.500 --> 21:54.500]  Их можно кастить даже, по-моему, друг к другу, если я не ошибаюсь.
[21:54.500 --> 21:58.500]  Прям просто брать, и как значение кастить, и все будет работать.
[21:59.500 --> 22:01.500]  Окей.
[22:03.500 --> 22:05.500]  Зачем все это было нужно?
[22:05.500 --> 22:08.500]  Вот для этого главного персонажа сегодняшней программы,
[22:08.500 --> 22:10.500]  оператор Spaceship.
[22:10.500 --> 22:12.500]  Его возвращаемое значение
[22:12.500 --> 22:15.500]  это как раз один из элементов одного из...
[22:15.500 --> 22:17.500]  Окей.
[22:17.500 --> 22:19.500]  Возвращаемый тип.
[22:19.500 --> 22:22.500]  Один из этих янамов, возвращаемое значение, элемент одного из них.
[22:24.500 --> 22:30.500]  LAS, less equality, equal, или просто strong order.
[22:30.500 --> 22:32.500]  Вот это типы.
[22:32.500 --> 22:34.500]  Вот эти элементы?
[22:34.500 --> 22:37.500]  Это янамы, да?
[22:37.500 --> 22:42.500]  Возвращать из этого оператора мы обязаны тип янам.
[22:42.500 --> 22:45.500]  То есть какое-то из значений этого янама.
[22:45.500 --> 22:47.500]  Причем и сам янам тоже нужно выбрать.
[22:47.500 --> 22:51.500]  То есть для каждого типа вы, когда пишете сравнение,
[22:51.500 --> 22:53.500]  вы выбираете одно из этих трех,
[22:53.500 --> 22:56.500]  и пишете оператор Spaceship.
[22:56.500 --> 22:58.500]  Пока не понятно, зачем.
[22:58.500 --> 23:03.500]  А возвращает он либо strong, либо weak, либо partial order.
[23:03.500 --> 23:07.500]  И в своей реализации, соответственно, одно из значений.
[23:07.500 --> 23:10.500]  Почему-то очень сложно сформулировать то, что я хочу сказать.
[23:10.500 --> 23:12.500]  Функция возвращает янам.
[23:12.500 --> 23:14.500]  Понятно же, да?
[23:14.500 --> 23:16.500]  Будем надеяться, что да.
[23:16.500 --> 23:20.500]  Можно писать и как просто глобальную штуку,
[23:20.500 --> 23:22.500]  то есть вне класса.
[23:22.500 --> 23:24.500]  А можно писать как member класса.
[23:24.500 --> 23:27.500]  Тогда неявный второй аргумент это класс.
[23:27.500 --> 23:32.500]  И из двух аргументов понимаем, что это бинарный вообще-то оператор.
[23:32.500 --> 23:35.500]  Нужно писать там x меньше равно больше y.
[23:35.500 --> 23:37.500]  И что-то произойдет.
[23:37.500 --> 23:39.500]  Так вот, что произойдет?
[23:39.500 --> 23:44.500]  Эта штука сравнит, по идее, сравнит x и y.
[23:44.500 --> 23:48.500]  И даст вам как элемент одного из этих янамов ответ,
[23:48.500 --> 23:50.500]  что там было на самом деле.
[23:52.500 --> 23:53.500]  Ага.
[23:53.500 --> 23:55.500]  Поняли, что такое Spaceship?
[23:55.500 --> 24:00.500]  Так, ну сейчас давайте пока чуть-чуть придержим коней.
[24:00.500 --> 24:02.500]  То есть он, получается, по элементам скажет,
[24:02.500 --> 24:04.500]  в каком порядке они относятся?
[24:04.500 --> 24:08.500]  Окей, нет, это просто Memcmp обобщенный.
[24:08.500 --> 24:10.500]  Знаете функцию Memcmp?
[24:10.500 --> 24:11.500]  Да.
[24:11.500 --> 24:14.500]  Она сравнивает строки и говорит,
[24:14.500 --> 24:17.500]  1 если больше, 0 если равны,
[24:17.500 --> 24:19.500]  минус 1 если меньше.
[24:19.500 --> 24:25.500]  Это удобно, потому что местами в коде вы хотите сделать 3 бронча.
[24:25.500 --> 24:29.500]  Один бронч меньше, другой бронч больше, третий равны.
[24:29.500 --> 24:31.500]  Бывает такое.
[24:31.500 --> 24:37.500]  Стандартные старые операторы сравнения C++ вам не позволяют взять
[24:37.500 --> 24:43.500]  и за одно сравнение понять, какой из трех вариантов там был.
[24:43.500 --> 24:47.500]  Вы можете сравнить на меньше либо на равно.
[24:47.500 --> 24:50.500]  Ну и если вы хотите все три варианта как бы разобрать,
[24:50.500 --> 24:54.500]  вам нужно два раза вызвать какой-то оператор в сравнение.
[24:54.500 --> 24:57.500]  Для строк, например, это неэффективно.
[24:57.500 --> 25:00.500]  Понимаете, нам в два раза пробежаться по строке нужно,
[25:00.500 --> 25:02.500]  по двум строкам.
[25:02.500 --> 25:05.500]  Первый раз мы пробегаемся, сравниваем, что одна меньше другой,
[25:05.500 --> 25:08.500]  поняли, ой, нет, она не меньше,
[25:08.500 --> 25:10.500]  но еще же они могут быть равны,
[25:10.500 --> 25:12.500]  поэтому второй раз запускаем оператор сравнения,
[25:12.500 --> 25:14.500]  уже оператор равно-равно,
[25:14.500 --> 25:16.500]  и проверяем, равны ли строки.
[25:16.500 --> 25:18.500]  Неэффективно, да?
[25:18.500 --> 25:20.500]  Хочется один раз пробежаться и сразу как Memcmp вернуть,
[25:20.500 --> 25:23.500]  просто меньше, больше или равны были элементы.
[25:23.500 --> 25:26.500]  Вот оператор spaceship призван делать ровно это.
[25:26.500 --> 25:29.500]  А вся эта билиберда с разными ордерингами,
[25:29.500 --> 25:32.500]  потому что не получается так просто сказать,
[25:32.500 --> 25:35.500]  что все типы, в принципе, сравниваются одинаково,
[25:35.500 --> 25:38.500]  все нормально, давайте там возвращать int.
[25:38.500 --> 25:42.500]  Что-то должен вернуть Memcmp в случае, если там несравнимый...
[25:42.500 --> 25:45.500]  Ну ладно, Memcmp ничего не должен никому.
[25:47.500 --> 25:49.500]  Короче, янамы, мне кажется, понятно, зачем добавили.
[25:49.500 --> 25:51.500]  Понятно ли вам?
[25:51.500 --> 25:52.500]  Можно вопрос?
[25:52.500 --> 25:53.500]  Да.
[25:53.500 --> 25:55.500]  Почему только в 20 плюсах это добавили?
[25:55.500 --> 25:57.500]  Потому что долго не могли договориться,
[25:57.500 --> 26:00.500]  что такая штука нужна, очевидно.
[26:00.500 --> 26:02.500]  А вот об этом не могли долго договориться,
[26:02.500 --> 26:04.500]  что должно происходить с этими тремя штуками,
[26:04.500 --> 26:07.500]  какие должны быть, какие не должны быть.
[26:09.500 --> 26:11.500]  Ну да, там...
[26:11.500 --> 26:13.500]  Задай мне вопрос.
[26:14.500 --> 26:15.500]  Он стесняется.
[26:15.500 --> 26:17.500]  Задайте кто-нибудь другой вопрос.
[26:17.500 --> 26:20.500]  Или это очевидно сейчас, что spaceship...
[26:20.500 --> 26:22.500]  То есть, какой рецепт теперь?
[26:22.500 --> 26:24.500]  Ну, зачем это понятно, да?
[26:24.500 --> 26:26.500]  Умеем сравнивать, все круто.
[26:26.500 --> 26:27.500]  Рецепт.
[26:27.500 --> 26:29.500]  Вы написали свой класс,
[26:29.500 --> 26:32.500]  хотите его запихнуть в какой-нибудь unordered map.
[26:32.500 --> 26:34.500]  Фу, ordered map, map просто.
[26:34.500 --> 26:36.500]  В map или set?
[26:36.500 --> 26:37.500]  Класс set.
[26:37.500 --> 26:39.500]  Нужны операторы сравнения.
[26:39.500 --> 26:43.500]  Вы теперь пишете не шесть операторов, а один.
[26:43.500 --> 26:44.500]  Вот этот.
[26:44.500 --> 26:47.500]  Но перед тем, как его писать, вы должны понять,
[26:47.500 --> 26:53.500]  к какой категории порядков относится ваш класс.
[26:53.500 --> 26:54.500]  Категории три.
[26:54.500 --> 26:56.500]  Strong, weak, partial.
[26:56.500 --> 27:00.500]  Лучше всего, если вы напишете такое сравнение,
[27:00.500 --> 27:03.500]  которое будет его относить к strong.
[27:03.500 --> 27:05.500]  Иногда это неестественно.
[27:05.500 --> 27:08.500]  То есть, можно за уши притянуть побитовое сравнение всегда,
[27:08.500 --> 27:11.500]  но смысла в таком сравнении будет мало, да?
[27:11.500 --> 27:15.500]  Опять же, пишем рациональные числа, два nта.
[27:15.500 --> 27:18.500]  Ну, хотим strong, давайте там побитого сравним
[27:18.500 --> 27:20.500]  в представлении ntoflix графически.
[27:20.500 --> 27:22.500]  Бесполезно.
[27:23.500 --> 27:25.500]  Weak иногда бывает более естественно.
[27:25.500 --> 27:30.500]  Partial совсем в редких случаях, если у вас что-то исключительное.
[27:30.500 --> 27:33.500]  Выбрали yinam, написали сигнатуру,
[27:33.500 --> 27:35.500]  и дальше пишете свое сравнение,
[27:35.500 --> 27:38.500]  где код сравнения настоящий,
[27:38.500 --> 27:40.500]  и возвращаете один из элементов yinama.
[27:40.500 --> 27:42.500]  Меньше, больше, равно, неравно.
[27:42.500 --> 27:44.500]  Во!
[27:44.500 --> 27:45.500]  Поняли?
[27:45.500 --> 27:47.500]  С 20-х плюсов вы больше не пишете.
[27:47.500 --> 27:50.500]  Никогда руками операторы меньше, операторы больше,
[27:50.500 --> 27:52.500]  меньше равно, больше равно.
[27:52.500 --> 27:54.500]  Я так говорю уверенно.
[27:54.500 --> 27:56.500]  Ну, скоро увидим.
[27:56.500 --> 27:59.500]  Перед этим надо посмотреть на новый концепт.
[27:59.500 --> 28:02.500]  Мы же любим смотреть на концепты жуткие.
[28:02.500 --> 28:06.500]  Ну вот, класс называется, корректно,
[28:06.500 --> 28:09.500]  three-way comparable
[28:09.500 --> 28:13.500]  для категории конкретной сравнения.
[28:13.500 --> 28:19.500]  Если, во-первых, вот это и вот это,
[28:19.500 --> 28:21.500]  это мы, кажется, в прошлый раз
[28:21.500 --> 28:23.500]  примерно что-то такое видели,
[28:23.500 --> 28:26.500]  но давайте просто подсказки откроем.
[28:26.500 --> 28:29.500]  Просто вот равенство и неравенство
[28:29.500 --> 28:31.500]  нормально работают.
[28:31.500 --> 28:33.500]  То есть там все требования уже наложены про...
[28:33.500 --> 28:37.500]  Короче, все ждут.
[28:37.500 --> 28:39.500]  Концепты мы смотрели.
[28:39.500 --> 28:42.500]  Да, в прошлой лекции оно есть.
[28:42.500 --> 28:45.500]  Пересмотрите, если хотите.
[28:45.500 --> 28:48.500]  Кроме, вот там называлось
[28:48.500 --> 28:50.500]  просто equality comparable with,
[28:50.500 --> 28:52.500]  а здесь weekly.
[28:52.500 --> 28:54.500]  Теперь понимать должны, в чем разница.
[28:54.500 --> 28:57.500]  Equality preservation не требуется.
[28:57.500 --> 28:59.500]  Тут тот концепт, который мы раньше смотрели,
[28:59.500 --> 29:01.500]  он был полноценный концепт в STD,
[29:01.500 --> 29:03.500]  который вы сами можете использовать.
[29:03.500 --> 29:06.500]  И там требовался equality preservation.
[29:06.500 --> 29:07.500]  Здесь не требуется.
[29:07.500 --> 29:08.500]  Вот такой прикол.
[29:08.500 --> 29:10.500]  Потому что вот этот весь концепт
[29:10.500 --> 29:13.500]  в целом должен для всех категорий работать.
[29:13.500 --> 29:15.500]  OK.
[29:15.500 --> 29:17.500]  Partially ordered тоже понятно,
[29:17.500 --> 29:19.500]  что меньше, больше, всякие вот эти штуки
[29:19.500 --> 29:21.500]  определены, консистентны.
[29:21.500 --> 29:23.500]  То есть все математические правила,
[29:23.500 --> 29:25.500]  что если меньше, то можно поменять местами.
[29:25.500 --> 29:27.500]  Вот это все фиксируется.
[29:27.500 --> 29:33.500]  Ну и тут какие-то еще мелочи.
[29:33.500 --> 29:35.500]  Ну вот эта мелочь там...
[29:35.500 --> 29:40.500]  Что-то...
[29:40.500 --> 29:44.500]  Давайте просто вы посмотрите.
[29:44.500 --> 29:47.500]  Сначала.
[29:47.500 --> 29:50.500]  Потому что я чувствую, что если я просто говорю вслух,
[29:50.500 --> 29:54.500]  то вы меня слушаете, а это не смотрите, и нехорошо.
[29:54.500 --> 29:55.500]  Да?
[29:55.500 --> 29:57.500]  Третье, что требуется компресс,
[29:57.500 --> 29:59.500]  он вот здесь приведен.
[29:59.500 --> 30:02.500]  То можно сказать, что вот это вот заклинание значит.
[30:02.500 --> 30:06.500]  Да, именно так.
[30:06.500 --> 30:08.500]  То есть требуется, чтобы вот это вот выражение
[30:08.500 --> 30:10.500]  вернуло какую-то категорию,
[30:10.500 --> 30:12.500]  ну то есть возвращаемый тип этой функции
[30:12.500 --> 30:14.500]  был какой-то категорией,
[30:14.500 --> 30:16.500]  которая хотя бы настолько сильная,
[30:16.500 --> 30:18.500]  насколько попросили изначально.
[30:18.500 --> 30:20.500]  То есть любой Strongly Comparable
[30:20.500 --> 30:22.500]  будет и Паршали, и Викли,
[30:22.500 --> 30:24.500]  и любой Викли будет Паршали.
[30:24.500 --> 30:26.500]  Во.
[30:26.500 --> 30:28.500]  Едем дальше.
[30:28.500 --> 30:30.500]  Тут, кажется, больше ничего нет.
[30:30.500 --> 30:32.500]  Да, для встроенных типов
[30:32.500 --> 30:34.500]  у нас оператор спейс-шипа определен.
[30:34.500 --> 30:36.500]  Понятно как.
[30:36.500 --> 30:40.500]  Здесь есть маленький подвох.
[30:40.500 --> 30:42.500]  Ищите подвох.
[30:42.500 --> 30:44.500]  Где здесь на самом деле...
[30:44.500 --> 30:46.500]  Андрей, тихо.
[30:46.500 --> 30:48.500]  Ты молчишь.
[30:54.500 --> 30:56.500]  Кто из вас лучше всех знает плюсы?
[31:00.500 --> 31:02.500]  Что-что?
[31:04.500 --> 31:06.500]  А почему ты считаешь, что Вик
[31:06.500 --> 31:08.500]  Ордеринг Пойнтеров?
[31:10.500 --> 31:12.500]  Что это значит?
[31:14.500 --> 31:16.500]  Нет, просто сам указатель
[31:16.500 --> 31:18.500]  по себе это значение.
[31:18.500 --> 31:20.500]  Да, мы его рассматриваем
[31:20.500 --> 31:22.500]  как значение, как число.
[31:22.500 --> 31:24.500]  Да, вот сравнение указателей
[31:24.500 --> 31:26.500]  не является сравнением объектов,
[31:26.500 --> 31:28.500]  на которые они указывают.
[31:28.500 --> 31:30.500]  Но это правильное замечание,
[31:30.500 --> 31:32.500]  что подвох именно в указателях.
[31:32.500 --> 31:34.500]  Где он?
[31:34.500 --> 31:36.500]  Никто не видит подвоха.
[31:36.500 --> 31:38.500]  Да, нолпы Т это не проблема,
[31:38.500 --> 31:40.500]  это просто нолик.
[31:40.500 --> 31:42.500]  Да, тут я выделил,
[31:42.500 --> 31:44.500]  что флотинг-поинт подвох.
[31:44.500 --> 31:46.500]  Нет, подвох,
[31:46.500 --> 31:48.500]  ну, конечно, он определен только для конкретного типа.
[31:48.500 --> 31:50.500]  То есть для всех Т-звездочка
[31:50.500 --> 31:52.500]  с конкретным Т их можно сравнивать,
[31:52.500 --> 31:54.500]  получить стронг Ордеринг.
[31:54.500 --> 31:56.500]  Но, забавный факт,
[31:56.500 --> 31:58.500]  если вы сравните два произвольных указателя,
[32:00.500 --> 32:02.500]  которые не указывают
[32:02.500 --> 32:04.500]  на часть одного и того же объекта,
[32:04.500 --> 32:06.500]  это УБ.
[32:10.500 --> 32:12.500]  То есть выделили один массив,
[32:12.500 --> 32:14.500]  другой массив, и решили посмотреть,
[32:14.500 --> 32:16.500]  кто из них в памяти раньше лежит,
[32:16.500 --> 32:18.500]  а кто позже.
[32:18.500 --> 32:20.500]  Сравнили их бигины или их даты,
[32:20.500 --> 32:22.500]  УБ.
[32:24.500 --> 32:26.500]  Если с кастом кинт по ТРТ,
[32:26.500 --> 32:28.500]  все будет хорошо.
[32:28.500 --> 32:30.500]  Но это при условии,
[32:30.500 --> 32:32.500]  как вообще рекомендация
[32:32.500 --> 32:34.500]  implementation defines.
[32:34.500 --> 32:36.500]  Это умные слова.
[32:36.500 --> 32:38.500]  А что на самом деле происходит?
[32:38.500 --> 32:40.500]  Они пытаются поддерживать архитектуры,
[32:40.500 --> 32:42.500]  где виртуальная память
[32:42.500 --> 32:44.500]  не является последовательной.
[32:48.500 --> 32:50.500]  Разве в NUMA это как-то используется?
[32:50.500 --> 32:52.500]  Хороший вопрос.
[32:54.500 --> 32:56.500]  Кто-нибудь знает здесь,
[32:56.500 --> 32:58.500]  что такое NUMA?
[33:02.500 --> 33:04.500]  Это скорее, когда на материнке
[33:04.500 --> 33:06.500]  много процессоров, что-то такое.
[33:06.500 --> 33:08.500]  Я тоже не особо могу...
[33:08.500 --> 33:10.500]  Ходят там легенды,
[33:10.500 --> 33:12.500]  что в дата-центрах сейчас ставят
[33:12.500 --> 33:14.500]  на одну материнку по пять процессоров,
[33:14.500 --> 33:16.500]  и у каждого из них отдельная память.
[33:16.500 --> 33:18.500]  Но, по-моему, это не про это.
[33:18.500 --> 33:20.500]  По-моему, это про экзотические,
[33:20.500 --> 33:22.500]  старинные системы, которые давно
[33:22.500 --> 33:24.500]  никому не нужны и никто ими не пользуется.
[33:24.500 --> 33:26.500]  Может и про NUMA.
[33:28.500 --> 33:30.500]  Короче, это такая вещь,
[33:30.500 --> 33:32.500]  в которой разбирается полтора человек на планете.
[33:32.500 --> 33:34.500]  И вот им это важно, что там...
[33:38.500 --> 33:40.500]  Ну, как-то так.
[33:40.500 --> 33:42.500]  Вот им важно, что там УБ,
[33:42.500 --> 33:44.500]  что есть ли из разных объектов
[33:44.500 --> 33:46.500]  сравнивать указатели.
[33:46.500 --> 33:48.500]  На практике это никогда не ломается,
[33:48.500 --> 33:50.500]  прекрасно работает.
[33:50.500 --> 33:52.500]  Поэтому решили бахнуть стронг,
[33:52.500 --> 33:54.500]  что, конечно, забавно.
[33:54.500 --> 33:56.500]  Вы как бы сравнить-то можете,
[33:56.500 --> 33:58.500]  результат мы вам всегда скажем,
[33:58.500 --> 34:00.500]  но в какой-то момент дракон может
[34:00.500 --> 34:02.500]  вылезти из компьютера.
[34:06.500 --> 34:08.500]  С ТДЛС? Нет, потом все будет.
[34:08.500 --> 34:10.500]  Мы же помним, что у НТДС
[34:10.500 --> 34:12.500]  создавались основные
[34:12.500 --> 34:14.500]  драконоператоры?
[34:14.500 --> 34:16.500]  Фалбекки какие-то.
[34:16.500 --> 34:18.500]  Я такие вещи не известно.
[34:18.500 --> 34:20.500]  Пора это будет.
[34:20.500 --> 34:22.500]  Что ты спиллеришь?
[34:28.500 --> 34:30.500]  По-моему, нельзя один объект
[34:30.500 --> 34:32.500]  на разных распределенных штуках
[34:32.500 --> 34:34.500]  выделить. Там вот так не работает.
[34:34.500 --> 34:36.500]  Просто вся эта схема. Не уверен.
[34:36.500 --> 34:38.500]  Я здесь не советчик, я решил
[34:38.500 --> 34:40.500]  распредамень не заниматься,
[34:40.500 --> 34:42.500]  это было волевое решение,
[34:42.500 --> 34:44.500]  поэтому я не могу про них ничего
[34:44.500 --> 34:46.500]  рассказать, кроме каких-то вот таких
[34:46.500 --> 34:48.500]  научпоп.
[34:48.500 --> 34:50.500]  Потому что оно все не визуальное,
[34:50.500 --> 34:52.500]  в графике как-то картиночки классные.
[34:52.500 --> 34:54.500]  Да, тут строчка появилась,
[34:54.500 --> 34:56.500]  пока вы отвлекались, давайте
[34:56.500 --> 34:58.500]  поменьше как-то отвлекаться.
[34:58.500 --> 35:00.500]  Про булы.
[35:00.500 --> 35:02.500]  Тут тоже
[35:02.500 --> 35:04.500]  такая смешная деталь,
[35:04.500 --> 35:06.500]  что мы как бы пытаемся
[35:06.500 --> 35:08.500]  ограничивать всякие дурацкие
[35:08.500 --> 35:10.500]  implicit конверсии,
[35:10.500 --> 35:12.500]  даже в плюсах как.
[35:12.500 --> 35:14.500]  Функция принимает
[35:14.500 --> 35:16.500]  yinam, можно туда передать true.
[35:16.500 --> 35:18.500]  Спокойно.
[35:18.500 --> 35:20.500]  True конверсируется в int,
[35:20.500 --> 35:22.500]  а yinam, который не класс,
[35:22.500 --> 35:24.500]  он по умолчанию является int.
[35:24.500 --> 35:26.500]  Вот тут пытаются это как-то
[35:26.500 --> 35:28.500]  отпилить. Не уверен,
[35:28.500 --> 35:30.500]  что это к чему-то приведет,
[35:30.500 --> 35:32.500]  но в какой-то момент у вас ошибка
[35:32.500 --> 35:34.500]  компиляции будет и здорово.
[35:34.500 --> 35:36.500]  Да, про потенциальную B мы
[35:36.500 --> 35:38.500]  сказали.
[35:38.500 --> 35:40.500]  Вот, сейчас
[35:40.500 --> 35:42.500]  будет самый сок.
[35:42.500 --> 35:44.500]  То, чего мы ждали годами
[35:44.500 --> 35:46.500]  и дождались.
[35:46.500 --> 35:48.500]  Вот этот код
[35:48.500 --> 35:50.500]  скомпилируется.
[35:50.500 --> 35:52.500]  Почему?
[35:52.500 --> 35:54.500]  Ну,
[35:54.500 --> 35:56.500]  ты понял, значит,
[35:56.500 --> 35:58.500]  в чем суть.
[35:58.500 --> 36:00.500]  Поняли ли остальные?
[36:00.500 --> 36:02.500]  Да, да, да.
[36:02.500 --> 36:04.500]  Да, вот просто теперь
[36:04.500 --> 36:06.500]  не надо никогда оператор
[36:06.500 --> 36:08.500]  не равно писать. Вообще никогда.
[36:08.500 --> 36:10.500]  Он сам по магии появляется.
[36:10.500 --> 36:12.500]  Сколько плюсам лет?
[36:12.500 --> 36:14.500]  30, 40, 50?
[36:14.500 --> 36:16.500]  Ну,
[36:16.500 --> 36:18.500]  ну,
[36:18.500 --> 36:20.500]  сколько плюсам лет? 30, 40.
[36:20.500 --> 36:22.500]  Спустя 40 лет мы научились
[36:22.500 --> 36:24.500]  автоматически в компиляторе
[36:24.500 --> 36:26.500]  прописывать восклицательный знак
[36:26.500 --> 36:28.500]  и скобочки, что там не A равно
[36:28.500 --> 36:30.500]  B. Круть.
[36:32.500 --> 36:34.500]  Да, но ведь и так
[36:34.500 --> 36:36.500]  тоже работаем.
[36:40.500 --> 36:42.500]  То есть, вот почему я сказал, что
[36:42.500 --> 36:44.500]  больше не надо никакие операторы писать,
[36:44.500 --> 36:46.500]  потому что один спейс шип реализовали, все
[36:46.500 --> 36:48.500]  сравнения работают.
[36:52.500 --> 36:54.500]  А в чем проблема?
[37:00.500 --> 37:02.500]  Примеры все будут
[37:02.500 --> 37:04.500]  абсолютно одинаковые.
[37:06.500 --> 37:08.500]  Вот так еще бывает.
[37:08.500 --> 37:10.500]  Да, вопрос.
[37:16.500 --> 37:18.500]  Ну, вот чтобы
[37:18.500 --> 37:20.500]  из равно-равной
[37:20.500 --> 37:22.500]  была Вадима неравно,
[37:22.500 --> 37:24.500]  почему это
[37:24.500 --> 37:26.500]  не можно?
[37:26.500 --> 37:28.500]  Ну, потому что приходят и говорят,
[37:28.500 --> 37:30.500]  ну, раз вы это добавляете,
[37:30.500 --> 37:32.500]  добавьте еще, чтобы операторы меньше-больше
[37:32.500 --> 37:34.500]  друг из друга выражались.
[37:36.500 --> 37:38.500]  Нет, ну, ты приходишь в
[37:38.500 --> 37:40.500]  комитет, тебе говорят,
[37:40.500 --> 37:42.500]  ну, вот раз вы это делаете,
[37:42.500 --> 37:44.500]  то сделайте и это тоже, пожалуйста.
[37:44.500 --> 37:46.500]  Но ты приносишь сделанное, тебе говорят,
[37:46.500 --> 37:48.500]  ну, это ж неудобно, давайте добавим какой-нибудь
[37:48.500 --> 37:50.500]  оператор сравнения для всех трех сразу.
[37:50.500 --> 37:52.500]  И вот мы как бы уперлись
[37:52.500 --> 37:54.500]  в старых баранов.
[38:04.500 --> 38:06.500]  Да, в общем,
[38:06.500 --> 38:08.500]  бюрократия. Почему это все так поздно пришло,
[38:08.500 --> 38:10.500]  это все бюрократия.
[38:10.500 --> 38:12.500]  Вот такое еще переписывание бывает.
[38:14.500 --> 38:16.500]  На старом слайде
[38:16.500 --> 38:18.500]  просто было про то, что
[38:18.500 --> 38:20.500]  оператор spaceship можно переписывать
[38:20.500 --> 38:22.500]  как, компилятор умеет
[38:22.500 --> 38:24.500]  переписывать как оператор сравнения.
[38:24.500 --> 38:26.500]  Теперь про
[38:26.500 --> 38:28.500]  разные типы.
[38:28.500 --> 38:30.500]  Здесь оператор сравнения равенства,
[38:30.500 --> 38:32.500]  он принимает
[38:32.500 --> 38:34.500]  два разных типа.
[38:34.500 --> 38:36.500]  Причем первый, ну, вот this,
[38:36.500 --> 38:38.500]  он как первый аргумент идет всегда.
[38:38.500 --> 38:40.500]  А второй аргумент, тут какой?
[38:40.500 --> 38:42.500]  Q. То есть
[38:42.500 --> 38:44.500]  аргумент C, второй Q. А здесь
[38:44.500 --> 38:46.500]  какой порядок снизу?
[38:46.500 --> 38:48.500]  Наоборот.
[38:48.500 --> 38:50.500]  Она переписала. Даже аргументы местами
[38:50.500 --> 38:52.500]  получается уметь переписывать.
[38:52.500 --> 38:54.500]  И spaceship тоже может.
[38:54.500 --> 38:56.500]  Давай полную табличку.
[38:58.500 --> 39:00.500]  Вот это полная табличка, все,
[39:00.500 --> 39:02.500]  чему научили компиляторы в двадцатых плюсах
[39:02.500 --> 39:04.500]  по переписыванию. Равенство
[39:04.500 --> 39:06.500]  переписывается по
[39:06.500 --> 39:08.500]  часто симметричность называется,
[39:08.500 --> 39:10.500]  да, коммодативность
[39:10.500 --> 39:12.500]  что-то другое.
[39:16.500 --> 39:18.500]  Сейчас, про что эта табличка была
[39:18.500 --> 39:20.500]  на самом деле?
[39:20.500 --> 39:22.500]  Окей, все, тихо.
[39:22.500 --> 39:24.500]  Давайте просто дальше по ней пойдем.
[39:24.500 --> 39:26.500]  Неравно через равно переписывается.
[39:26.500 --> 39:28.500]  Да, то есть если у вас определенный
[39:28.500 --> 39:30.500]  вот, про что табличка.
[39:30.500 --> 39:32.500]  Здесь написано, какой должен быть оператор
[39:32.500 --> 39:34.500]  определен. А вот в той табличке
[39:34.500 --> 39:36.500]  какое выражение
[39:36.500 --> 39:38.500]  мы будем использовать вместо
[39:38.500 --> 39:40.500]  изначального выражения.
[39:40.500 --> 39:42.500]  Если изначально было равно,
[39:42.500 --> 39:44.500]  то мы попробуем использовать равно с
[39:44.500 --> 39:46.500]  другим порядком, и выражение
[39:46.500 --> 39:48.500]  в итоге будет такое.
[39:48.500 --> 39:50.500]  Если увидели неравно,
[39:50.500 --> 39:52.500]  попробуем найти равенство.
[39:52.500 --> 39:54.500]  Причем в обоих направлениях.
[39:54.500 --> 39:56.500]  И перепишем.
[39:56.500 --> 39:58.500]  Вот, как я говорил,
[39:58.500 --> 40:00.500]  восклицательный знак, скобочки.
[40:00.500 --> 40:02.500]  Со всеми
[40:02.500 --> 40:04.500]  операторами сравнения, меньше, больше,
[40:04.500 --> 40:06.500]  меньше или равно, больше или равно,
[40:06.500 --> 40:08.500]  все одинаково.
[40:08.500 --> 40:10.500]  Всегда увидев такую штуку, мы пытаемся найти
[40:10.500 --> 40:12.500]  спейс-шип и переписываем как
[40:12.500 --> 40:14.500]  спейс-шип...
[40:14.500 --> 40:16.500]  Спейс-шип собака
[40:16.500 --> 40:18.500]  ноль. Где собака это изначальный
[40:18.500 --> 40:20.500]  оператор. Или наоборот
[40:20.500 --> 40:22.500]  ноль собака спейс-шип.
[40:22.500 --> 40:24.500]  Вот.
[40:24.500 --> 40:26.500]  Если так задуматься, то
[40:26.500 --> 40:28.500]  понт вот этого всего в том,
[40:28.500 --> 40:30.500]  что вы можете взять и из спейс-шипа
[40:30.500 --> 40:32.500]  вернуть int
[40:32.500 --> 40:34.500]  memcmp.
[40:34.500 --> 40:36.500]  Вот как бы под это все немножко подстроено,
[40:36.500 --> 40:38.500]  чтобы мы были обратно совместимы
[40:38.500 --> 40:40.500]  с C до каких-то вот невероятных просто
[40:40.500 --> 40:42.500]  высот. Ну и сам спейс-шип
[40:42.500 --> 40:44.500]  тоже переписывается внезапно.
[40:44.500 --> 40:46.500]  Сменой порядка аргументов.
[40:46.500 --> 40:48.500]  Но как же я вам, блин, не рекомендую
[40:48.500 --> 40:50.500]  пытаться сравнивать на меньше, больше,
[40:50.500 --> 40:52.500]  разные типы. Это какая-то дичь.
[40:52.500 --> 40:54.500]  Лучше такой код просто не писать.
[40:54.500 --> 40:56.500]  Вопрос, если мы захотим двойно
[40:56.500 --> 40:58.500]  сравнить вот эти
[40:58.500 --> 41:00.500]  коды.
[41:00.500 --> 41:02.500]  В X у нас пролетела STD
[41:02.500 --> 41:04.500]  Strong Ordering Less
[41:04.500 --> 41:06.500]  и мы
[41:06.500 --> 41:08.500]  сравним это с the Big
[41:08.500 --> 41:10.500]  SGP.
[41:10.500 --> 41:12.500]  Ты их можешь прикастить
[41:12.500 --> 41:14.500]  к, типа, к наименьшему общему кратному.
[41:14.500 --> 41:16.500]  Они же друг друга кастятся.
[41:16.500 --> 41:18.500]  Но оно автоматически скастится или нужно
[41:18.500 --> 41:20.500]  будет скаститься? Не знаю.
[41:20.500 --> 41:22.500]  Ну, таких проблем у тебя не возникнет,
[41:22.500 --> 41:24.500]  потому что проблема с всеми этими
[41:24.500 --> 41:26.500]  ордерами возникает, когда ты пишешь
[41:26.500 --> 41:28.500]  какие-то сложные алгоритмы, которые
[41:28.500 --> 41:30.500]  используют сравнение и хочешь, чтобы они
[41:30.500 --> 41:32.500]  работали с любым legacy.
[41:32.500 --> 41:34.500]  Вот каким бы оно плохим не было.
[41:34.500 --> 41:36.500]  На нашем курсе
[41:36.500 --> 41:38.500]  нету таких вот задач, где бы
[41:38.500 --> 41:40.500]  просто написать алгоритм и
[41:40.500 --> 41:42.500]  аккуратно использовать
[41:42.500 --> 41:44.500]  шаблоны
[41:44.500 --> 41:46.500]  на меньше, больше.
[41:46.500 --> 41:48.500]  Возможно, такие задачи
[41:48.500 --> 41:50.500]  стоит сделать, но сейчас ее нет.
[41:50.500 --> 41:52.500]  Да и в жизни ты вряд ли в какой-то момент
[41:52.500 --> 41:54.500]  такое будешь делать.
[41:54.500 --> 41:56.500]  Но если будешь, то вот это все придется
[41:56.500 --> 41:58.500]  перечитать заново, конечно же, и учесть.
[42:00.500 --> 42:02.500]  Ну, в целом,
[42:02.500 --> 42:04.500]  если ты пишешь новый код,
[42:04.500 --> 42:06.500]  то сейчас будет простой рецепт, который
[42:06.500 --> 42:08.500]  позволит все быстро просто
[42:08.500 --> 42:10.500]  чтобы нормально было.
[42:10.500 --> 42:12.500]  Давайте просто дальше пойти.
[42:12.500 --> 42:14.500]  Поняли, как все это переписывается.
[42:14.500 --> 42:16.500]  Вот тут некоторые вещи называют
[42:16.500 --> 42:18.500]  разными именами. Есть
[42:18.500 --> 42:20.500]  синтетические кандидаты,
[42:20.500 --> 42:22.500]  а есть типа
[42:22.500 --> 42:24.500]  обычные, переписанные.
[42:26.500 --> 42:28.500]  Видите, в чем отличие?
[42:28.500 --> 42:30.500]  Вот синтетические
[42:30.500 --> 42:32.500]  это те, у которых местами аргументы
[42:32.500 --> 42:34.500]  поменяли.
[42:34.500 --> 42:36.500]  Дурацкое слово, но
[42:36.500 --> 42:38.500]  вот так их называют.
[42:38.500 --> 42:40.500]  Поверлот-резолюшн.
[42:40.500 --> 42:42.500]  Помните, что это? У нас там был
[42:42.500 --> 42:44.500]  целый списочек, что типа три пункта,
[42:44.500 --> 42:46.500]  как мы выбираем какую функцию вызвать.
[42:46.500 --> 42:48.500]  Последний пункт был выверать из множества
[42:48.500 --> 42:50.500]  имен функции самую подходящую.
[42:50.500 --> 42:52.500]  Но вот я сказал, что его не поменяли
[42:52.500 --> 42:54.500]  в двадцатых плюсах. Нет, поменяли.
[42:54.500 --> 42:56.500]  Добавили
[42:56.500 --> 42:58.500]  вот это вот правило,
[42:58.500 --> 43:00.500]  что когда мы пытаемся найти оператор
[43:00.500 --> 43:02.500]  подходящий
[43:02.500 --> 43:04.500]  для какого-то сравнения,
[43:04.500 --> 43:06.500]  то мы сначала пытаемся
[43:06.500 --> 43:08.500]  найти обычный оператор,
[43:08.500 --> 43:10.500]  определенный пользователем, потом
[43:10.500 --> 43:12.500]  пытаемся использовать переписанные кандидаты,
[43:12.500 --> 43:14.500]  то есть здесь белые строчки.
[43:14.500 --> 43:16.500]  То есть равно,
[43:16.500 --> 43:18.500]  не равно выразить как равно
[43:18.500 --> 43:20.500]  или какой-нибудь меньше, больше и прочее,
[43:20.500 --> 43:22.500]  выразить как spaceship.
[43:22.500 --> 43:24.500]  И только в последнюю очередь, если совсем не повезло,
[43:24.500 --> 43:26.500]  то пытаемся вот эти вот synthesize.
[43:26.500 --> 43:28.500]  Сложные какие-то правила, да?
[43:28.500 --> 43:30.500]  Мораль не надо определять.
[43:30.500 --> 43:32.500]  И всякие меньше, больше,
[43:32.500 --> 43:34.500]  и spaceship, потому что
[43:34.500 --> 43:36.500]  что-нибудь запутается у вас, и все будет плохо.
[43:36.500 --> 43:38.500]  Лучше один spaceship
[43:38.500 --> 43:40.500]  и о.
[43:44.500 --> 43:46.500]  Вот.
[43:48.500 --> 43:50.500]  Чувствую, что какого-то слайда не хватает.
[43:50.500 --> 43:52.500]  Так делать можно.
[43:52.500 --> 43:54.500]  Внезапно.
[43:58.500 --> 44:00.500]  Да ни в чем.
[44:00.500 --> 44:02.500]  Просто это немножко странно.
[44:02.500 --> 44:04.500]  Мы из оператора spaceship
[44:04.500 --> 44:06.500]  возвращаем int, да?
[44:06.500 --> 44:08.500]  Какой ордеринг?
[44:08.500 --> 44:10.500]  Вот это правильный вопрос.
[44:10.500 --> 44:12.500]  Вот он к вам,
[44:12.500 --> 44:14.500]  он не ко мне.
[44:14.500 --> 44:16.500]  Табличка есть,
[44:16.500 --> 44:18.500]  пример есть.
[44:18.500 --> 44:20.500]  Вот.
[44:20.500 --> 44:22.500]  Что нам сделают?
[44:22.500 --> 44:24.500]  Ну да.
[44:24.500 --> 44:26.500]  Ну, с предыдущим примером
[44:26.500 --> 44:28.500]  по аналогии. Просто смотрим в табличку,
[44:28.500 --> 44:30.500]  как она переписывается.
[44:30.500 --> 44:32.500]  Да, вот там выражение
[44:32.500 --> 44:34.500]  есть, самая правая колонка.
[44:34.500 --> 44:36.500]  Вот это будет переписано
[44:36.500 --> 44:38.500]  как выражение самой правой колонки.
[44:38.500 --> 44:40.500]  И в этом выражении уже можно понять,
[44:40.500 --> 44:42.500]  какие типы сравниваются,
[44:42.500 --> 44:44.500]  и какой тогда будет ордеринг.
[44:44.500 --> 44:46.500]  Не на меня надо смотреть,
[44:46.500 --> 44:48.500]  на табличку.
[44:48.500 --> 44:50.500]  Какой?
[44:50.500 --> 44:52.500]  Ну, вот в первом случае,
[44:52.500 --> 44:54.500]  во втором.
[44:54.500 --> 44:56.500]  Тут два примера.
[44:56.500 --> 44:58.500]  Ну, первый очевидный.
[44:58.500 --> 45:00.500]  Скажите мне, какой тут будет тип?
[45:00.500 --> 45:02.500]  Int.
[45:02.500 --> 45:04.500]  Никакого переписывания не произойдет.
[45:04.500 --> 45:06.500]  По overload resolution у нас есть
[45:06.500 --> 45:08.500]  просто оператор spaceship, вот его и используем.
[45:08.500 --> 45:10.500]  А во втором случае,
[45:10.500 --> 45:12.500]  просто оператора spaceship мы не найдем.
[45:12.500 --> 45:14.500]  Да, вот какой из них,
[45:14.500 --> 45:16.500]  какая строчка подойдет?
[45:16.500 --> 45:18.500]  Да, вот самая последняя строчка,
[45:18.500 --> 45:20.500]  где мы поменяем их местами.
[45:20.500 --> 45:22.500]  Так, вот у нас выражение
[45:22.500 --> 45:24.500]  B и A.
[45:24.500 --> 45:26.500]  Ну, наша неудача в том,
[45:26.500 --> 45:28.500]  что там A и B наоборот названы.
[45:28.500 --> 45:30.500]  Ну, мы, короче, это перепишем,
[45:30.500 --> 45:32.500]  переставим их местами,
[45:32.500 --> 45:34.500]  потому что такой оператор spaceship
[45:34.500 --> 45:36.500]  не подойдет.
[45:36.500 --> 45:38.500]  Ну, в этом случае мы не найдем
[45:38.500 --> 45:40.500]  оператора spaceship,
[45:40.500 --> 45:42.500]  переставим их местами,
[45:42.500 --> 45:44.500]  потому что такой оператор у нас есть.
[45:44.500 --> 45:46.500]  И выражение в итоге будет какое?
[45:46.500 --> 45:48.500]  A фигурный 0,
[45:48.500 --> 45:50.500]  spaceship A, spaceship B.
[45:50.500 --> 45:52.500]  То есть, если на самую правую
[45:52.500 --> 45:54.500]  нижнюю ячейку посмотрите,
[45:54.500 --> 45:56.500]  провалидируйте.
[45:56.500 --> 45:58.500]  Там будет spaceship
[45:58.500 --> 46:00.500]  между нами.
[46:00.500 --> 46:02.500]  Да, и это будет
[46:02.500 --> 46:04.500]  strong, правда ведь?
[46:04.500 --> 46:06.500]  Да, вот, то есть, кто сказал
[46:06.500 --> 46:08.500]  strong, кажется, это ты первый был.
[46:08.500 --> 46:10.500]  В общем, действительно будет strong,
[46:10.500 --> 46:12.500]  что достаточно странно.
[46:14.500 --> 46:16.500]  Может и не странно.
[46:16.500 --> 46:18.500]  Может.
[46:18.500 --> 46:20.500]  И за счет
[46:20.500 --> 46:22.500]  переписывания у вас
[46:22.500 --> 46:24.500]  начнет происходить какая-то дичь.
[46:24.500 --> 46:26.500]  Ну, зачем
[46:26.500 --> 46:28.500]  это сделано? Под memcpy.
[46:28.500 --> 46:30.500]  Здесь предполагается написать
[46:30.500 --> 46:32.500]  memcmp.
[46:32.500 --> 46:34.500]  Memcmp возвращает int
[46:34.500 --> 46:36.500]  минус 1, 0, 1.
[46:36.500 --> 46:38.500]  За счет
[46:38.500 --> 46:40.500]  всей этой фигни
[46:40.500 --> 46:42.500]  у вас все, в принципе, будет работать.
[46:42.500 --> 46:44.500]  Но опять же, лучше
[46:44.500 --> 46:46.500]  так не делать. Лучше
[46:46.500 --> 46:48.500]  избавляться от legacy, переписывать его
[46:48.500 --> 46:50.500]  и делать нормальный ордеринг.
[46:50.500 --> 46:52.500]  Чтобы вот это
[46:52.500 --> 46:54.500]  в голове не хранить табличку там.
[46:54.500 --> 46:56.500]  Вообще ужас.
[46:56.500 --> 46:58.500]  Нам добавили много функциональных
[46:58.500 --> 47:00.500]  объектов, смешных, в стандартную библиотеку.
[47:00.500 --> 47:02.500]  Ну, то есть, less были,
[47:02.500 --> 47:04.500]  все были, кроме
[47:04.500 --> 47:06.500]  mpr3way, да?
[47:06.500 --> 47:08.500]  Ну, про них
[47:08.500 --> 47:10.500]  что-нибудь помните? Что это такое?
[47:14.500 --> 47:16.500]  Что? Нет, вы не помните,
[47:16.500 --> 47:18.500]  что это за функциональный объект
[47:18.500 --> 47:20.500]  std less?
[47:20.500 --> 47:22.500]  Ну да, просто
[47:22.500 --> 47:24.500]  тип, у которого есть
[47:24.500 --> 47:26.500]  оператор круглые скобки, который делает
[47:26.500 --> 47:28.500]  то, что он говорит.
[47:28.500 --> 47:30.500]  Мне кажется, я сегодня туплю.
[47:30.500 --> 47:32.500]  Сейчас.
[47:32.500 --> 47:34.500]  Фулбек, будут сейчас
[47:34.500 --> 47:36.500]  фулбеки, так.
[47:36.500 --> 47:38.500]  Сколько времени? Нормально
[47:38.500 --> 47:40.500]  времени, мы идем более-менее
[47:40.500 --> 47:42.500]  хорошо. Нет, быстрее
[47:42.500 --> 47:44.500]  бы.
[47:46.500 --> 47:48.500]  Вот.
[47:48.500 --> 47:50.500]  Бонус, как раз,
[47:50.500 --> 47:52.500]  который заспылирили, мне казалось, тут
[47:52.500 --> 47:54.500]  больше слайдов, но их меньше.
[47:56.500 --> 47:58.500]  Поняли, что это значит?
[47:58.500 --> 48:00.500]  Без УБ.
[48:00.500 --> 48:02.500]  То есть, если вы сравниваете
[48:02.500 --> 48:04.500]  через вот эти функциональные объекты
[48:04.500 --> 48:06.500]  указателя, вам
[48:06.500 --> 48:08.500]  уже УБ на указателях
[48:08.500 --> 48:10.500]  не будет.
[48:10.500 --> 48:12.500]  Как они этого достигают,
[48:12.500 --> 48:14.500]  это их забота, но
[48:14.500 --> 48:16.500]  вот магия.
[48:16.500 --> 48:18.500]  Ну, то есть, что это вам позволяет делать
[48:18.500 --> 48:20.500]  на самом деле? Это вам позволяет
[48:20.500 --> 48:22.500]  запихнуть, не так,
[48:22.500 --> 48:24.500]  сделать мап из указателей
[48:24.500 --> 48:26.500]  во что-то другое.
[48:26.500 --> 48:28.500]  Потому что если бы указатели
[48:28.500 --> 48:30.500]  на объекты, которые никак не связаны,
[48:30.500 --> 48:32.500]  нельзя было вообще сравнивать,
[48:32.500 --> 48:34.500]  то мы бы как бы мап не смогли
[48:34.500 --> 48:36.500]  из указателей во что-то сделать, да?
[48:36.500 --> 48:38.500]  Вообще беда.
[48:38.500 --> 48:40.500]  Можно, но только через пятую точку нужно
[48:40.500 --> 48:42.500]  через эти функциональные объекты идти.
[48:42.500 --> 48:44.500]  Да, про легаси.
[48:44.500 --> 48:46.500]  Для легаси уже
[48:46.500 --> 48:48.500]  много чего сказал, что нужно.
[48:48.500 --> 48:50.500]  Вот мы написали новый бинпоиск,
[48:50.500 --> 48:52.500]  оригинальный,
[48:52.500 --> 48:54.500]  и вписали туда вот этот вот
[48:54.500 --> 48:56.500]  с ревей, чтобы было быстрее.
[48:56.500 --> 48:58.500]  Тут он меньше,
[48:58.500 --> 49:00.500]  больше, равно три случая.
[49:00.500 --> 49:02.500]  Воюзкейс.
[49:04.500 --> 49:06.500]  Но вот надо утверждать, что не так.
[49:06.500 --> 49:08.500]  Надо писать вот такое заклинание.
[49:10.500 --> 49:12.500]  Про то, как, собственно, алгоритмы писать.
[49:12.500 --> 49:14.500]  Заклинание
[49:14.500 --> 49:16.500]  крайне магическое.
[49:20.500 --> 49:22.500]  Вот почему
[49:22.500 --> 49:24.500]  речь идет
[49:24.500 --> 49:26.500]  о легаси.
[49:26.500 --> 49:28.500]  Мы написали вот этот меньше равно больше,
[49:28.500 --> 49:30.500]  но был ли там пункт
[49:30.500 --> 49:32.500]  про переписывание меньше равно больше
[49:32.500 --> 49:34.500]  через обычные операторы сравнения?
[49:40.500 --> 49:42.500]  Там был просто спейс-шип.
[49:42.500 --> 49:44.500]  Вот если мы сюда
[49:44.500 --> 49:46.500]  попытаемся подставить тип,
[49:46.500 --> 49:48.500]  который не современный, о легаси,
[49:48.500 --> 49:50.500]  и в нем просто по отдельности
[49:50.500 --> 49:52.500]  оператор меньше, оператор больше,
[49:52.500 --> 49:54.500]  равно и так далее.
[49:54.500 --> 49:56.500]  Что будет?
[49:56.500 --> 49:58.500]  Ошибка будет. Почему?
[49:58.500 --> 50:00.500]  Правил переписывания спейс-шип в старые
[50:00.500 --> 50:02.500]  операторы нет.
[50:02.500 --> 50:04.500]  И это задумано так не случайно,
[50:04.500 --> 50:06.500]  а специально.
[50:06.500 --> 50:08.500]  Что там цикл может возникнуть,
[50:08.500 --> 50:10.500]  что вы туда-сюда переписываете?
[50:10.500 --> 50:12.500]  Наверное, не может.
[50:12.500 --> 50:14.500]  Но в целом вот эта шняга
[50:14.500 --> 50:16.500]  позволяет совладать со старыми классами,
[50:16.500 --> 50:18.500]  для которых нет оператора спейс-шип.
[50:18.500 --> 50:20.500]  И там сейчас опять начинается
[50:20.500 --> 50:22.500]  целая стена
[50:22.500 --> 50:24.500]  разных таких штук.
[50:24.500 --> 50:26.500]  То есть,
[50:26.500 --> 50:28.500]  что это все значит?
[50:30.500 --> 50:32.500]  Сейчас, первые три, что значили?
[50:32.500 --> 50:34.500]  Мне кажется, на следующих слайдах
[50:34.500 --> 50:36.500]  будет. В общем, что вот это за strong
[50:36.500 --> 50:38.500]  order, weak order и partial order
[50:38.500 --> 50:40.500]  fallback? Это говорит,
[50:40.500 --> 50:42.500]  что попробуй сравнить
[50:42.500 --> 50:44.500]  оператором меньше равно больше,
[50:44.500 --> 50:46.500]  но если не выходит,
[50:46.500 --> 50:48.500]  если обычные старые операторы меньше,
[50:48.500 --> 50:50.500]  операторы больше и так далее,
[50:50.500 --> 50:52.500]  и думай, что
[50:52.500 --> 50:54.500]  order вот такой, как тут написано.
[50:54.500 --> 50:56.500]  По-моему, так.
[51:04.500 --> 51:06.500]  Давай вот сюда сразу смотреть.
[51:06.500 --> 51:08.500]  Тут просто по реализации
[51:08.500 --> 51:10.500]  проще понять, что происходит.
[51:10.500 --> 51:12.500]  Мне кажется, еще больше, чем в прошлый раз
[51:12.500 --> 51:14.500]  туплю. Знаете, почему?
[51:14.500 --> 51:16.500]  Я до четырех ночи заполнял
[51:16.500 --> 51:18.500]  интерплан аспиранта.
[51:18.500 --> 51:20.500]  Так что, прошу прощения,
[51:20.500 --> 51:22.500]  я не выспался от слова совсем.
[51:22.500 --> 51:24.500]  За тупы идут.
[51:26.500 --> 51:28.500]  Да, и поэтому я уже
[51:28.500 --> 51:30.500]  успел хотеть спать обратно.
[51:30.500 --> 51:32.500]  Это функции, да?
[51:32.500 --> 51:34.500]  Стена шесть штук, я их
[51:34.500 --> 51:36.500]  на две штуки, две категории разбил,
[51:36.500 --> 51:38.500]  одни из fallback, другие просто.
[51:38.500 --> 51:40.500]  Функции
[51:40.500 --> 51:42.500]  принимают два аргумента и делают следующую
[51:42.500 --> 51:44.500]  последовательность действий.
[51:44.500 --> 51:46.500]  Во-первых, они являются CPO.
[51:46.500 --> 51:48.500]  Что это такое, мы узнаем попозже.
[51:48.500 --> 51:50.500]  Пока что это значит, что
[51:50.500 --> 51:52.500]  можно кастомизировать и вот сюда
[51:52.500 --> 51:54.500]  впендюрить свой callback, как бы.
[51:54.500 --> 51:56.500]  Вообще кастомный, со стороны.
[51:56.500 --> 51:58.500]  Странно
[51:58.500 --> 52:00.500]  звучит сейчас, не будем об этом.
[52:00.500 --> 52:02.500]  Внезапно
[52:02.500 --> 52:04.500]  вот эти функции гарантируют
[52:04.500 --> 52:06.500]  для флотов total order,
[52:06.500 --> 52:08.500]  то есть strong.
[52:08.500 --> 52:10.500]  Как, почему?
[52:10.500 --> 52:12.500]  Гарантируют.
[52:14.500 --> 52:16.500]  То есть они как бы по приоритетам
[52:16.500 --> 52:18.500]  идут, если нашлась какая-то
[52:18.500 --> 52:20.500]  кастомизация, чтобы это
[52:20.500 --> 52:22.500]  не было. Но это то, что вы руками пишете,
[52:22.500 --> 52:24.500]  оно перехватывает управление вот этим всем.
[52:24.500 --> 52:26.500]  Если нашлось, то и запускаем
[52:26.500 --> 52:28.500]  ее, если флот, то делаем
[52:28.500 --> 52:30.500]  вот этот костыль странный, иначе
[52:30.500 --> 52:32.500]  three-way spaceship, иначе
[52:32.500 --> 52:34.500]  пытаемся сравнивать с более сильным
[52:34.500 --> 52:36.500]  order.
[52:36.500 --> 52:38.500]  То есть о чем этот вот order?
[52:38.500 --> 52:40.500]  То есть spaceship
[52:40.500 --> 52:42.500]  как бы пытается делать
[52:42.500 --> 52:44.500]  именно с
[52:44.500 --> 52:46.500]  таким order, который вы попросили.
[52:46.500 --> 52:48.500]  По-моему так.
[52:48.500 --> 52:50.500]  А fallback
[52:50.500 --> 52:52.500]  делает то же самое, что и первое,
[52:52.500 --> 52:54.500]  но еще и пытается выражать
[52:54.500 --> 52:56.500]  через меньшее и равенство.
[52:56.500 --> 52:58.500]  Вот так вот. То есть
[52:58.500 --> 53:00.500]  поддержка legacy вообще
[53:00.500 --> 53:02.500]  во много стизей. Если у вашего legacy есть
[53:02.500 --> 53:04.500]  вот эти операторы, то через них выразится
[53:04.500 --> 53:06.500]  круто, если нет, то можете
[53:06.500 --> 53:08.500]  вот сюда впихнуть кастомизацию, как
[53:08.500 --> 53:10.500]  неважно, таким образом
[53:10.500 --> 53:12.500]  подкостылять, да еще и флоты
[53:12.500 --> 53:14.500]  вот почему-то тоже подкостыленные.
[53:14.500 --> 53:16.500]  Сейчас
[53:16.500 --> 53:18.500]  не могу сказать зачем.
[53:18.500 --> 53:20.500]  Но если честно, это очень полезно,
[53:20.500 --> 53:22.500]  что каждая
[53:22.500 --> 53:24.500]  функция, они как минимум
[53:24.500 --> 53:26.500]  всегда возвращают
[53:26.500 --> 53:28.500]  ordering, в отличие от оператора spaceship,
[53:28.500 --> 53:30.500]  который вот благодаря тому,
[53:30.500 --> 53:32.500]  более ранних примеров, иногда не творится.
[53:32.500 --> 53:34.500]  Да, вот это тоже
[53:34.500 --> 53:36.500]  как бы полезно,
[53:36.500 --> 53:38.500]  да. Коль скоро
[53:38.500 --> 53:40.500]  мы позволяем spaceship возвращать
[53:40.500 --> 53:42.500]  int, кто-нибудь это будет делать,
[53:42.500 --> 53:44.500]  поэтому нужно позаботиться о том, чтобы это
[53:44.500 --> 53:46.500]  не сломало наш код и использовать вот эти функции
[53:46.500 --> 53:48.500]  на самом деле. Да.
[53:48.500 --> 53:50.500]  Кажется, что
[53:50.500 --> 53:52.500]  вот std exporter
[53:52.500 --> 53:54.500]  в частности, кстати,
[53:54.500 --> 53:56.500]  неправильно сказал.
[53:56.500 --> 53:58.500]  Кажется, что std compare freeway
[53:58.500 --> 54:00.500]  учитывает тоже, что кастыль для
[54:00.500 --> 54:02.500]  флотов добавляется там для указателей.
[54:02.500 --> 54:04.500]  Да, для указателей.
[54:04.500 --> 54:06.500]  Кажется, что хочется не всегда
[54:06.500 --> 54:08.500]  пользоваться compare freeway, а не
[54:08.500 --> 54:10.500]  spaceship.
[54:10.500 --> 54:12.500]  Да, на самом деле ты в обобщенном коде никогда
[54:12.500 --> 54:14.500]  не хочешь оператора spaceship писать.
[54:14.500 --> 54:16.500]  Ты хочешь использовать всегда одну из вот этих
[54:16.500 --> 54:18.500]  трех функций.
[54:18.500 --> 54:20.500]  Вот вообще реально всегда.
[54:20.500 --> 54:22.500]  Если твой алгоритм требует
[54:22.500 --> 54:24.500]  strong ordering от типов,
[54:24.500 --> 54:26.500]  то пиши вот этот. Если
[54:26.500 --> 54:28.500]  и wix идет, то пиши этот.
[54:28.500 --> 54:30.500]  Если вообще partial достаточно, у тебя там
[54:30.500 --> 54:32.500]  топологическая сортировка
[54:32.500 --> 54:34.500]  по partial order,
[54:34.500 --> 54:36.500]  то partial.
[54:46.500 --> 54:48.500]  Оно ошибку выдаст, по-моему.
[54:48.500 --> 54:50.500]  То есть если прямо у объекта определен
[54:50.500 --> 54:52.500]  оператор spaceship с partial order,
[54:52.500 --> 54:54.500]  а ты пытаешься их сравнить через
[54:54.500 --> 54:56.500]  strong order, то это
[54:56.500 --> 54:58.500]  ошибка.
[55:00.500 --> 55:02.500]  Вот это фара из тоф в объекте,
[55:02.500 --> 55:04.500]  ну в классе.
[55:04.500 --> 55:06.500]  И вот я говорю, что...
[55:06.500 --> 55:08.500]  Ну как? Он просто декл-тайп
[55:08.500 --> 55:10.500]  от a, spaceship, b.
[55:10.500 --> 55:12.500]  Знаешь, какой там тип?
[55:12.500 --> 55:14.500]  Ну и все.
[55:14.500 --> 55:16.500]  Сразу понятно, какой это из ордеров
[55:16.500 --> 55:18.500]  и подходит ли он тебе.
[55:18.500 --> 55:20.500]  То есть как бы если кто-то определил специально
[55:20.500 --> 55:22.500]  неправильный spaceship с неправильным
[55:22.500 --> 55:24.500]  ордером, то это вам вообще все сломает.
[55:24.500 --> 55:26.500]  Тут никак не закострелять,
[55:26.500 --> 55:28.500]  как кажется,
[55:28.500 --> 55:30.500]  кроме CPO.
[55:30.500 --> 55:32.500]  То есть вот это CPO еще и позволяет закострелять,
[55:32.500 --> 55:34.500]  если кто-то плохой оператор сделал.
[55:34.500 --> 55:36.500]  Давайте не будем о плохом мораль
[55:36.500 --> 55:38.500]  вот этих всех тонкостей, что
[55:38.500 --> 55:40.500]  есть дурацкая процедура о том, что нужно
[55:40.500 --> 55:42.500]  сделать, чтобы
[55:42.500 --> 55:44.500]  нормально вызвать в обобщенном коде
[55:44.500 --> 55:46.500]  spaceship.
[55:46.500 --> 55:48.500]  Если вы слушали внимательно, вы ее наверное
[55:48.500 --> 55:50.500]  сейчас поняли. Если нет, то просто
[55:50.500 --> 55:52.500]  используйте вот одно из этих трех.
[55:52.500 --> 55:54.500]  В вашем шаблонном коде
[55:54.500 --> 55:56.500]  пишите не spaceship, а вот это.
[55:56.500 --> 55:58.500]  Все, едем дальше.
[56:02.500 --> 56:04.500]  О чем это мы?
[56:06.500 --> 56:08.500]  Да, для точки
[56:08.500 --> 56:10.500]  хотим лексографический порядок.
[56:10.500 --> 56:12.500]  Как-то тупо, да?
[56:12.500 --> 56:14.500]  Вот если это будет точка
[56:14.500 --> 56:16.500]  из трех координат, то тут еще один
[56:16.500 --> 56:18.500]  IF добавится тупой. Если из четырех,
[56:18.500 --> 56:20.500]  то еще один IF.
[56:20.500 --> 56:22.500]  Ну как-то ежу понятно, что имеется
[56:22.500 --> 56:24.500]  в виду, правда? Это тупой
[56:24.500 --> 56:26.500]  машинный код. Вот можно его
[56:26.500 --> 56:28.500]  на питоне сгенерить.
[56:28.500 --> 56:30.500]  А можно...
[56:30.500 --> 56:32.500]  А, нет,
[56:32.500 --> 56:34.500]  это пока не про это, что ли?
[56:34.500 --> 56:36.500]  Я запутал себя. Черт побери.
[56:40.500 --> 56:42.500]  Что здесь происходит?
[56:46.500 --> 56:48.500]  Нет.
[56:48.500 --> 56:50.500]  А, да.
[56:50.500 --> 56:52.500]  Давайте это пропустим.
[56:52.500 --> 56:54.500]  Это все нафиг не надо.
[56:54.500 --> 56:56.500]  Вот.
[56:56.500 --> 56:58.500]  Оператор равенства.
[56:58.500 --> 57:00.500]  Дефолтный.
[57:00.500 --> 57:02.500]  Угадайте, как он работает.
[57:04.500 --> 57:06.500]  Нет, не побитого.
[57:06.500 --> 57:08.500]  Вот ко всем полям это правильно.
[57:08.500 --> 57:10.500]  Теперь надо сформулировать, что такое поле.
[57:10.500 --> 57:12.500]  Но оператор spaceship
[57:12.500 --> 57:14.500]  тоже есть дефолтный.
[57:14.500 --> 57:16.500]  Какой он порядок будет делать
[57:16.500 --> 57:18.500]  на полях?
[57:18.500 --> 57:20.500]  По всем полям по-разному можно
[57:20.500 --> 57:22.500]  спросить.
[57:22.500 --> 57:24.500]  Ну, вот как бы да.
[57:24.500 --> 57:26.500]  Самый естественный
[57:26.500 --> 57:28.500]  это лексиферический порядок. Именно он и
[57:28.500 --> 57:30.500]  будет. Вопрос в каком
[57:30.500 --> 57:32.500]  порядке поля считается?
[57:32.500 --> 57:34.500]  Да, и где
[57:34.500 --> 57:36.500]  вообще поля?
[57:36.500 --> 57:38.500]  Ну, сейчас будет.
[57:38.500 --> 57:40.500]  А, да, даже вот так можно.
[57:40.500 --> 57:42.500]  Внезапно. То есть тут я говорил, что можно
[57:42.500 --> 57:44.500]  spaceship и конкретный ордер указать.
[57:44.500 --> 57:46.500]  А теперь
[57:46.500 --> 57:48.500]  я говорю, что можно не указывать
[57:48.500 --> 57:50.500]  ордера, просто авто
[57:50.500 --> 57:52.500]  написать, и вам его сами выведут.
[57:54.500 --> 57:56.500]  Но, я думаю, интуитивно можно представить себе,
[57:56.500 --> 57:58.500]  как это будет работать и должно
[57:58.500 --> 58:00.500]  работать. Давайте на всякий случай разберем.
[58:00.500 --> 58:02.500]  Вот так делать нельзя.
[58:04.500 --> 58:06.500]  То есть только два варианта.
[58:06.500 --> 58:08.500]  Оператор равенства и оператор spaceship.
[58:10.500 --> 58:12.500]  А зачем вам какие-то дефолтные операторы меньше,
[58:12.500 --> 58:14.500]  если есть дефолтный оператор spaceship?
[58:14.500 --> 58:16.500]  Они через spaceship выводятся.
[58:16.500 --> 58:18.500]  Ну, да.
[58:18.500 --> 58:20.500]  Поэтому ничего нельзя,
[58:20.500 --> 58:22.500]  все это запрещено, оно все выводится. Не надо
[58:22.500 --> 58:24.500]  их больше писать, эти операторы.
[58:24.500 --> 58:26.500]  Просто не надо, никогда.
[58:28.500 --> 58:30.500]  Идем дальше.
[58:30.500 --> 58:32.500]  Вот, что такое поля.
[58:32.500 --> 58:34.500]  Тут вводится такое понятие,
[58:34.500 --> 58:36.500]  опять новый стандарт впихнули.
[58:36.500 --> 58:38.500]  Проширенный список
[58:38.500 --> 58:40.500]  подобъектов.
[58:40.500 --> 58:42.500]  Просто мы не можем.
[58:42.500 --> 58:44.500]  Значит, берем список базовых классов,
[58:44.500 --> 58:46.500]  берем все поля,
[58:46.500 --> 58:48.500]  но если среди этих полей
[58:48.500 --> 58:50.500]  есть массив C,
[58:50.500 --> 58:52.500]  то есть int A в квадратных скобках
[58:52.500 --> 58:54.500]  8, то они как бы разворачиваются
[58:54.500 --> 58:56.500]  поэлементно и добавляются
[58:56.500 --> 58:58.500]  в этот список.
[59:00.500 --> 59:02.500]  То есть список состоит из вот этих
[59:02.500 --> 59:04.500]  вот объектов,
[59:04.500 --> 59:06.500]  подобъектов.
[59:06.500 --> 59:08.500]  Ну, и мы просто их сравниваем
[59:08.500 --> 59:10.500]  в электрографическом порядке либо
[59:10.500 --> 59:12.500]  подряд.
[59:12.500 --> 59:14.500]  То есть вот, дефолтный оператор сравнения
[59:14.500 --> 59:16.500]  работает так,
[59:16.500 --> 59:18.500]  дефолтный спейс-шип работает
[59:18.500 --> 59:20.500]  вот так.
[59:20.500 --> 59:22.500]  Причем
[59:24.500 --> 59:26.500]  сейчас, вот это авто, да.
[59:26.500 --> 59:28.500]  Привет.
[59:28.500 --> 59:30.500]  Ты пришел к нам послушать?
[59:30.500 --> 59:32.500]  Ну, приходи, заходи,
[59:32.500 --> 59:34.500]  только поздно. Надо вот так, и вот
[59:34.500 --> 59:36.500]  перед камерой у тебя выбора к сожалению нет,
[59:36.500 --> 59:38.500]  чтобы все видели, кто
[59:38.500 --> 59:40.500]  опаздывает.
[59:42.500 --> 59:44.500]  Какой порядок?
[59:44.500 --> 59:46.500]  Ну, потому что
[59:46.500 --> 59:48.500]  ты можешь сравнить точки сначала по
[59:48.500 --> 59:50.500]  X, потом по Y, а может
[59:50.500 --> 59:52.500]  сначала по Y, потом по X.
[59:52.500 --> 59:54.500]  Это будет не одно и то же.
[59:54.500 --> 59:56.500]  Поэтому, когда ты делаешь свой
[59:56.500 --> 59:58.500]  оператор сравнение, нужно как бы
[59:58.500 --> 01:00:00.500]  учесть это.
[01:00:00.500 --> 01:00:02.500]  Вот, и да,
[01:00:02.500 --> 01:00:04.500]  я не сказал, поля здесь подряд добавляются
[01:00:04.500 --> 01:00:06.500]  в порядке объявления, просто сверху вниз.
[01:00:06.500 --> 01:00:08.500]  Ну, вот это самое естественное,
[01:00:08.500 --> 01:00:10.500]  что можно было придумать. Сначала идем
[01:00:10.500 --> 01:00:12.500]  родительские классы, потом поля, потом
[01:00:14.500 --> 01:00:16.500]  и потом все.
[01:00:18.500 --> 01:00:20.500]  Про вот этот вывод авто.
[01:00:20.500 --> 01:00:22.500]  Тут опять закавыристые детали как раз,
[01:00:22.500 --> 01:00:24.500]  одно из того, из-за чего они могли договориться.
[01:00:26.500 --> 01:00:28.500]  Ну, понятно, что мы проходимся по всем
[01:00:28.500 --> 01:00:30.500]  полям и видим, что у каждого из них
[01:00:30.500 --> 01:00:32.500]  есть какой-то оператор спейс-шип, да.
[01:00:32.500 --> 01:00:34.500]  Дальше начинаем
[01:00:34.500 --> 01:00:36.500]  посмотреть, что они возвращают.
[01:00:36.500 --> 01:00:38.500]  Weak, strong, partial.
[01:00:38.500 --> 01:00:40.500]  Берем как бы
[01:00:40.500 --> 01:00:42.500]  наибольшее из них,
[01:00:42.500 --> 01:00:44.500]  наименьшее.
[01:00:44.500 --> 01:00:46.500]  То есть, если хотя бы одно поле
[01:00:46.500 --> 01:00:48.500]  partial, то и вся структурка
[01:00:48.500 --> 01:00:50.500]  ваша тоже будет partial.
[01:00:50.500 --> 01:00:52.500]  Ну, например, из-за этого
[01:00:52.500 --> 01:00:54.500]  для точки из двух флотов
[01:00:54.500 --> 01:00:56.500]  как-то не очень прикольно получится,
[01:00:56.500 --> 01:00:58.500]  если вы напишите вот с авто здесь, да,
[01:00:58.500 --> 01:01:00.500]  вам выведут, что
[01:01:00.500 --> 01:01:02.500]  у вас точки тоже
[01:01:02.500 --> 01:01:04.500]  partial, возможно, вы хотели не этого.
[01:01:08.500 --> 01:01:10.500]  Ну, и да,
[01:01:10.500 --> 01:01:12.500]  выводят, выводят, выводят,
[01:01:12.500 --> 01:01:14.500]  получают что-то, и оно и превращается
[01:01:14.500 --> 01:01:16.500]  в авто.
[01:01:16.500 --> 01:01:18.500]  Сейчас был ли тут, вот, отлично.
[01:01:18.500 --> 01:01:20.500]  Если же вы явно указали, что я хочу
[01:01:20.500 --> 01:01:22.500]  вот такой ордеринг, а не какой-то другой,
[01:01:22.500 --> 01:01:24.500]  то вам будут проверять
[01:01:24.500 --> 01:01:26.500]  еще, что
[01:01:26.500 --> 01:01:28.500]  все
[01:01:28.500 --> 01:01:30.500]  поля, они как бы имеют
[01:01:30.500 --> 01:01:32.500]  хотя бы настолько сильный оператор
[01:01:32.500 --> 01:01:34.500]  сравнения, spaceship.
[01:01:34.500 --> 01:01:36.500]  Ну, то есть, вот,
[01:01:36.500 --> 01:01:38.500]  это must be convertible
[01:01:38.500 --> 01:01:40.500]  turret T. Помним где-то
[01:01:40.500 --> 01:01:42.500]  на подкорке, что эти янамы кастятся друг
[01:01:42.500 --> 01:01:44.500]  другу.
[01:01:46.500 --> 01:01:48.500]  Проверка.
[01:01:48.500 --> 01:01:50.500]  Какой здесь будет ордер?
[01:01:50.500 --> 01:01:52.500]  Вик,
[01:01:52.500 --> 01:01:54.500]  Вик,
[01:01:54.500 --> 01:01:56.500]  потому что флоты
[01:01:56.500 --> 01:01:58.500]  флотов Вик,
[01:01:58.500 --> 01:02:00.500]  partial.
[01:02:00.500 --> 01:02:02.500]  Правда ведь? Правда.
[01:02:02.500 --> 01:02:04.500]  Ура.
[01:02:04.500 --> 01:02:06.500]  Тут еще что-то про legacy.
[01:02:08.500 --> 01:02:10.500]  Они еще синтезируют ордер.
[01:02:10.500 --> 01:02:12.500]  О, да.
[01:02:12.500 --> 01:02:14.500]  Потому что мы хотим еще и так делать.
[01:02:14.500 --> 01:02:16.500]  Вдруг у вас в полях есть legacy класс,
[01:02:16.500 --> 01:02:18.500]  у которого нет spaceship, а вы все равно
[01:02:18.500 --> 01:02:20.500]  хотите сделать дефолтный spaceship?
[01:02:20.500 --> 01:02:22.500]  Ну, мало ли.
[01:02:22.500 --> 01:02:24.500]  Вдруг вы там boost разрабатываете
[01:02:24.500 --> 01:02:26.500]  какой-нибудь?
[01:02:26.500 --> 01:02:28.500]  Сейчас нам как-то помогут, да?
[01:02:32.500 --> 01:02:34.500]  Да, нам помогли. Сказали, что
[01:02:34.500 --> 01:02:36.500]  сравнение идет через
[01:02:36.500 --> 01:02:38.500]  since reway
[01:02:38.500 --> 01:02:40.500]  rete.
[01:02:40.500 --> 01:02:42.500]  Который выглядит
[01:02:42.500 --> 01:02:44.500]  вот так.
[01:02:44.500 --> 01:02:46.500]  То есть, ну, да,
[01:02:46.500 --> 01:02:48.500]  накрутили.
[01:02:48.500 --> 01:02:50.500]  Даже когда вы дефолтный оператор spaceship объявляете,
[01:02:50.500 --> 01:02:52.500]  у вас оно там пойдет искать
[01:02:56.500 --> 01:02:58.500]  операторы legacy,
[01:02:58.500 --> 01:03:00.500]  операторы сравнения, из них пытаться
[01:03:00.500 --> 01:03:02.500]  составить нормальный
[01:03:04.500 --> 01:03:06.500]  spaceship. Причем spaceship
[01:03:06.500 --> 01:03:08.500]  генерируется по-разному,
[01:03:08.500 --> 01:03:10.500]  в зависимости от того, какой ордеринг
[01:03:10.500 --> 01:03:12.500]  вы запросили.
[01:03:12.500 --> 01:03:14.500]  Он генерится
[01:03:14.500 --> 01:03:16.500]  как бы не при вызовах,
[01:03:16.500 --> 01:03:18.500]  при вызовах он не генерится,
[01:03:18.500 --> 01:03:20.500]  когда вы просто пытаетесь вызывать spaceship,
[01:03:20.500 --> 01:03:22.500]  он не сгенерится.
[01:03:22.500 --> 01:03:24.500]  А когда вы пытаетесь
[01:03:24.500 --> 01:03:26.500]  сделать дефолтный оператор spaceship
[01:03:26.500 --> 01:03:28.500]  с конкретным типом,
[01:03:28.500 --> 01:03:30.500]  вот здесь вот,
[01:03:30.500 --> 01:03:32.500]  да, и одно из
[01:03:32.500 --> 01:03:34.500]  полей этого класса legacy,
[01:03:34.500 --> 01:03:36.500]  то есть у него нету spaceship,
[01:03:36.500 --> 01:03:38.500]  он генерит,
[01:03:38.500 --> 01:03:40.500]  он как бы не то чтобы
[01:03:40.500 --> 01:03:42.500]  генерит, но он сравнивает
[01:03:42.500 --> 01:03:44.500]  как будто бы есть spaceship
[01:03:44.500 --> 01:03:46.500]  по следующему алгоритму,
[01:03:46.500 --> 01:03:48.500]  то есть получает результат
[01:03:48.500 --> 01:03:50.500]  spaceship для этого legacy класса
[01:03:50.500 --> 01:03:52.500]  следующим образом.
[01:03:52.500 --> 01:03:54.500]  Вот это вот зашито в spaceship,
[01:03:54.500 --> 01:03:56.500]  то есть spaceship не регенерится,
[01:03:56.500 --> 01:03:58.500]  но все это проверяется.
[01:03:58.500 --> 01:04:00.500]  Да, вот все это зашито в равно
[01:04:00.500 --> 01:04:02.500]  дефолт молшебное.
[01:04:02.500 --> 01:04:04.500]  Если вы запросили strong,
[01:04:04.500 --> 01:04:06.500]  то оно будет сравнивать просто двумя
[01:04:06.500 --> 01:04:08.500]  сравнениями, если weak, ну в принципе тоже.
[01:04:08.500 --> 01:04:10.500]  Еще раз, я может быть пропустил,
[01:04:10.500 --> 01:04:12.500]  можно чуть-чуть сказать назад,
[01:04:12.500 --> 01:04:14.500]  если я скажу
[01:04:14.500 --> 01:04:16.500]  оператор spaceship
[01:04:16.500 --> 01:04:18.500]  const равно
[01:04:18.500 --> 01:04:20.500]  default и там
[01:04:20.500 --> 01:04:22.500]  strong quartering,
[01:04:22.500 --> 01:04:24.500]  поэтому у меня там будут флоты
[01:04:24.500 --> 01:04:26.500]  или точки, ну не точки,
[01:04:26.500 --> 01:04:28.500]  ладно, флоты будут,
[01:04:28.500 --> 01:04:30.500]  то он выдаст ошибку?
[01:04:30.500 --> 01:04:32.500]  Хороший вопрос.
[01:04:32.500 --> 01:04:34.500]  Не знаю.
[01:04:34.500 --> 01:04:36.500]  Может и выдаст, надо проверить.
[01:04:36.500 --> 01:04:38.500]  Тут
[01:04:38.500 --> 01:04:40.500]  не об этом речь,
[01:04:40.500 --> 01:04:42.500]  тут речь о моментах,
[01:04:42.500 --> 01:04:44.500]  когда у тебя вообще не определен оператор spaceship
[01:04:44.500 --> 01:04:46.500]  для одного из классов.
[01:04:46.500 --> 01:04:48.500]  Наверное, он должен выдать ошибку, да.
[01:04:48.500 --> 01:04:50.500]  Но тут ситуация была такая,
[01:04:50.500 --> 01:04:52.500]  вот в S есть E,
[01:04:52.500 --> 01:04:54.500]  у E нет spaceship, а мы все равно хотим
[01:04:54.500 --> 01:04:56.500]  дефолтный spaceship.
[01:04:56.500 --> 01:04:58.500]  Разрешается это следующим алгоритмом,
[01:04:58.500 --> 01:05:00.500]  что те классы, у которых нет spaceship,
[01:05:00.500 --> 01:05:02.500]  мы сравниваем либо вот так,
[01:05:02.500 --> 01:05:04.500]  если запросили strong, либо так, если weak,
[01:05:04.500 --> 01:05:06.500]  либо так, если partial. Обратите внимание,
[01:05:06.500 --> 01:05:08.500]  в случае partial, а тут два раза
[01:05:08.500 --> 01:05:10.500]  на меньше проверяются.
[01:05:12.500 --> 01:05:14.500]  Прикол, да?
[01:05:18.500 --> 01:05:20.500]  Ну да, да, типа там, если...
[01:05:26.500 --> 01:05:28.500]  Я искренне молюсь, что нет.
[01:05:34.500 --> 01:05:36.500]  Тут задумано, что это legacy класс,
[01:05:36.500 --> 01:05:38.500]  у которого есть вот эти операторы меньше
[01:05:38.500 --> 01:05:40.500]  и равно.
[01:05:42.500 --> 01:05:44.500]  Тогда это не просто legacy,
[01:05:44.500 --> 01:05:46.500]  это то, что нужно сжечь.
[01:05:46.500 --> 01:05:48.500]  Это ересь.
[01:05:48.500 --> 01:05:50.500]  Если происходит, то это просто вообще убой
[01:05:50.500 --> 01:05:52.500]  и застрелись.
[01:05:56.500 --> 01:05:58.500]  Возможно. Давайте перейдем
[01:05:58.500 --> 01:06:00.500]  к морали или еще какой-то вопрос.
[01:06:00.500 --> 01:06:02.500]  Хочу закончить со spaceship.
[01:06:04.500 --> 01:06:06.500]  У нас вот в legacy классе,
[01:06:06.500 --> 01:06:08.500]  у которого вот по такому алгоритму
[01:06:08.500 --> 01:06:10.500]  является spaceship,
[01:06:10.500 --> 01:06:12.500]  у него внутри флоты,
[01:06:12.500 --> 01:06:14.500]  и я скажу ему strong ordering.
[01:06:14.500 --> 01:06:16.500]  Он же проверит, он нормально все сделает.
[01:06:16.500 --> 01:06:18.500]  Да, да.
[01:06:18.500 --> 01:06:20.500]  Это же фигня. Да нет.
[01:06:20.500 --> 01:06:22.500]  Предполагается, что ты legacy код тоже писал,
[01:06:22.500 --> 01:06:24.500]  когда в здравом эме был,
[01:06:24.500 --> 01:06:26.500]  поэтому ты там придумал, как гарантировать,
[01:06:26.500 --> 01:06:28.500]  ну, заглянув в будущее, что там потом
[01:06:28.500 --> 01:06:30.500]  будет важно сохранять равенство
[01:06:30.500 --> 01:06:32.500]  и иметь полные порядки,
[01:06:32.500 --> 01:06:34.500]  ты как-то продумал, что должно в случае
[01:06:34.500 --> 01:06:36.500]  nano происходить, что там никакие
[01:06:36.500 --> 01:06:38.500]  приватные данные наружу не улетают,
[01:06:38.500 --> 01:06:40.500]  если это не так, то в принципе
[01:06:40.500 --> 01:06:42.500]  оно тоже в целом все будет работать,
[01:06:42.500 --> 01:06:44.500]  но можешь ждать сюрпризов.
[01:06:52.500 --> 01:06:54.500]  Нет, вот в случае, когда legacy,
[01:06:54.500 --> 01:06:56.500]  ты по legacy классу
[01:06:56.500 --> 01:06:58.500]  не можешь понять, какой
[01:06:58.500 --> 01:07:00.500]  ordering на нем. Вот в чем соль.
[01:07:02.500 --> 01:07:04.500]  Поэтому надо явно ordering указать,
[01:07:04.500 --> 01:07:06.500]  авто здесь написать нельзя уже.
[01:07:14.500 --> 01:07:16.500]  На самом деле нет, это просто такая
[01:07:16.500 --> 01:07:18.500]  человеческая абстракция
[01:07:18.500 --> 01:07:20.500]  про то, какие бывают типы
[01:07:20.500 --> 01:07:22.500]  сравнимых классов.
[01:07:22.500 --> 01:07:24.500]  Это категории сравнения классов.
[01:07:24.500 --> 01:07:26.500]  Вот так же, как выражение делится
[01:07:26.500 --> 01:07:28.500]  на lvalue и rvalue, классы,
[01:07:28.500 --> 01:07:30.500]  для которых определено сравнение
[01:07:30.500 --> 01:07:32.500]  в каком-то резонном смысле, делится
[01:07:32.500 --> 01:07:34.500]  на три категории, weak, strong, partial.
[01:07:34.500 --> 01:07:36.500]  Это в человеческом понимании.
[01:07:36.500 --> 01:07:38.500]  А в коде мы пытаемся сделать так,
[01:07:38.500 --> 01:07:40.500]  чтобы все, что происходит, соответствовало
[01:07:40.500 --> 01:07:42.500]  нашему пониманию.
[01:07:42.500 --> 01:07:44.500]  Получить
[01:07:44.500 --> 01:07:46.500]  ordering
[01:07:46.500 --> 01:07:48.500]  без оператора spaceship нельзя.
[01:07:48.500 --> 01:07:50.500]  Это единственный
[01:07:50.500 --> 01:07:52.500]  способ сказать, что
[01:07:52.500 --> 01:07:54.500]  за ordering твоего класса.
[01:07:54.500 --> 01:07:56.500]  Это намеренно так сделано, чтобы нельзя было
[01:07:56.500 --> 01:07:58.500]  просто пойти и какому-то старому
[01:07:58.500 --> 01:08:00.500]  legacy-классу через какой-нибудь trait указать,
[01:08:00.500 --> 01:08:02.500]  что ты на самом деле strong.
[01:08:02.500 --> 01:08:04.500]  Это специально не сделали.
[01:08:04.500 --> 01:08:06.500]  По-моему, я надеюсь.
[01:08:06.500 --> 01:08:08.500]  Давайте дальше
[01:08:08.500 --> 01:08:10.500]  пойдем к уже
[01:08:10.500 --> 01:08:12.500]  итогам. Дельные советы
[01:08:12.500 --> 01:08:14.500]  про то, что
[01:08:14.500 --> 01:08:16.500]  надо делать и что не надо делать.
[01:08:16.500 --> 01:08:18.500]  Это старый
[01:08:18.500 --> 01:08:20.500]  совет, такой вы уже наверняка
[01:08:20.500 --> 01:08:22.500]  видели.
[01:08:22.500 --> 01:08:24.500]  Не надо пытаться выпендриваться, использовать
[01:08:24.500 --> 01:08:26.500]  операторы сравнения для каких-то своих классных
[01:08:26.500 --> 01:08:28.500]  monads или еще чего-нибудь такого.
[01:08:28.500 --> 01:08:30.500]  Только сравнивать.
[01:08:30.500 --> 01:08:32.500]  Человек пишет меньше, он не ожидает,
[01:08:32.500 --> 01:08:34.500]  что это будет какая-нибудь функциональная операция,
[01:08:34.500 --> 01:08:36.500]  какого-нибудь бинда, кого-нибудь куда-нибудь.
[01:08:36.500 --> 01:08:38.500]  И все они должны быть определены,
[01:08:38.500 --> 01:08:40.500]  всегда.
[01:08:40.500 --> 01:08:42.500]  Ну да, то есть
[01:08:42.500 --> 01:08:44.500]  либо сравнить можно только на равенство,
[01:08:44.500 --> 01:08:46.500]  либо на все операторы, либо
[01:08:46.500 --> 01:08:48.500]  вообще нельзя сравнивать. Три варианта
[01:08:48.500 --> 01:08:50.500]  других не надо делать, пожалуйста. В современном
[01:08:50.500 --> 01:08:52.500]  мире это выливается в то, что вы либо
[01:08:52.500 --> 01:08:54.500]  определяете только оператор равно,
[01:08:54.500 --> 01:08:56.500]  либо определяете только оператор
[01:08:56.500 --> 01:08:58.500]  spaceship,
[01:08:58.500 --> 01:09:00.500]  по идее. Но
[01:09:00.500 --> 01:09:02.500]  в компиляторах бывают баги, которые заставляют
[01:09:02.500 --> 01:09:04.500]  вас и равно тоже определить.
[01:09:04.500 --> 01:09:06.500]  Я сталкивался в прошлом году.
[01:09:08.500 --> 01:09:10.500]  Идет ли у нас запись?
[01:09:10.500 --> 01:09:12.500]  Идет.
[01:09:12.500 --> 01:09:14.500]  Я думал, что это специально,
[01:09:14.500 --> 01:09:16.500]  то есть на равно же можно,
[01:09:16.500 --> 01:09:18.500]  если у нас скажем два вектора, можно очень быстро
[01:09:18.500 --> 01:09:20.500]  на равно сравнить просто по сайту.
[01:09:20.500 --> 01:09:22.500]  Что? Как?
[01:09:22.500 --> 01:09:24.500]  Как?
[01:09:24.500 --> 01:09:26.500]  Надо пройтись по обоим векторам,
[01:09:26.500 --> 01:09:28.500]  чтобы их на равно сравнить.
[01:09:28.500 --> 01:09:30.500]  Да, но если мы сразу видим,
[01:09:30.500 --> 01:09:32.500]  что сайты неравны, то можем быстро
[01:09:32.500 --> 01:09:34.500]  по сравнению.
[01:09:34.500 --> 01:09:36.500]  Возможно,
[01:09:36.500 --> 01:09:38.500]  возможно.
[01:09:38.500 --> 01:09:40.500]  Опять тонкий момент.
[01:09:42.500 --> 01:09:44.500]  Ну равно должен переписываться через spaceship,
[01:09:44.500 --> 01:09:46.500]  а он не переписывается через spaceship.
[01:09:46.500 --> 01:09:48.500]  Стоп, что я говорю? Вы помните
[01:09:48.500 --> 01:09:50.500]  табличку?
[01:09:50.500 --> 01:09:52.500]  Все переписывается через spaceship.
[01:09:52.500 --> 01:09:54.500]  Нет, равно не переписывается.
[01:09:54.500 --> 01:09:56.500]  Равно не переписывается через spaceship.
[01:09:56.500 --> 01:09:58.500]  Да, все.
[01:09:58.500 --> 01:10:00.500]  Да, это выкинули.
[01:10:00.500 --> 01:10:02.500]  Вот, у меня осталось небольшое
[01:10:02.500 --> 01:10:04.500]  отложение с прежних лет.
[01:10:04.500 --> 01:10:06.500]  Да, надо писать либо только
[01:10:06.500 --> 01:10:08.500]  оператор равно, либо и spaceship, и равно.
[01:10:08.500 --> 01:10:10.500]  Все. То есть через spaceship
[01:10:10.500 --> 01:10:12.500]  понимать равенство можно,
[01:10:12.500 --> 01:10:14.500]  но не стоит, потому что вот пропиров
[01:10:14.500 --> 01:10:16.500]  только что сказали с размерами, да.
[01:10:16.500 --> 01:10:18.500]  Все абсолютно верно. Поэтому да,
[01:10:18.500 --> 01:10:20.500]  не требуется насильно.
[01:10:22.500 --> 01:10:24.500]  Да, вот это. Все, что вы сравниваете
[01:10:24.500 --> 01:10:26.500]  должно быть под множеством того, что вы
[01:10:26.500 --> 01:10:28.500]  копируете. То есть если
[01:10:28.500 --> 01:10:30.500]  вы делаете какой-то оператор копирования
[01:10:30.500 --> 01:10:32.500]  у своего типа,
[01:10:32.500 --> 01:10:34.500]  и что-то, что вы используете в операторе
[01:10:34.500 --> 01:10:36.500]  сравнение не копируете,
[01:10:36.500 --> 01:10:38.500]  то вы очень быстро получите нарушение
[01:10:38.500 --> 01:10:40.500]  стронгордеринга.
[01:10:40.500 --> 01:10:42.500]  Из-за вот этих свойств сохранения равенства
[01:10:42.500 --> 01:10:44.500]  там все полетит, так делать не надо.
[01:10:44.500 --> 01:10:46.500]  Почему под множество, а не все
[01:10:46.500 --> 01:10:48.500]  и ровно все?
[01:10:48.500 --> 01:10:50.500]  Потому что у вас может быть какой-нибудь
[01:10:50.500 --> 01:10:52.500]  кэш, который
[01:10:52.500 --> 01:10:54.500]  не особо влияет на что-то,
[01:10:54.500 --> 01:10:56.500]  но он просто есть.
[01:10:58.500 --> 01:11:00.500]  Используйте стронгордер.
[01:11:00.500 --> 01:11:02.500]  Вот эта вот строчка называется
[01:11:02.500 --> 01:11:04.500]  переводится на русский как
[01:11:04.500 --> 01:11:06.500]  используйте только стронгордер.
[01:11:10.500 --> 01:11:12.500]  Дефолтный оператор всегда предпочитает
[01:11:12.500 --> 01:11:14.500]  в 99% случаев их достаточно,
[01:11:14.500 --> 01:11:16.500]  потому что вы объявили какую-то структуру
[01:11:16.500 --> 01:11:18.500]  просто чтобы как-то данные сгруппировать,
[01:11:18.500 --> 01:11:20.500]  теперь там в мап понадобилось
[01:11:20.500 --> 01:11:22.500]  или в сет засунуть.
[01:11:22.500 --> 01:11:24.500]  Вам все равно, что там происходит, какой
[01:11:24.500 --> 01:11:26.500]  оператор, ну дефолт прекрасно.
[01:11:32.500 --> 01:11:34.500]  Ну вот в случае точек
[01:11:34.500 --> 01:11:36.500]  геометрических фигур
[01:11:36.500 --> 01:11:38.500]  и прочего, где у
[01:11:38.500 --> 01:11:40.500]  объекта нету естественных
[01:11:40.500 --> 01:11:42.500]  порядка на них,
[01:11:42.500 --> 01:11:44.500]  вообще не надо определять спейс шип.
[01:11:44.500 --> 01:11:46.500]  Тут, по-моему, тоже где-то было.
[01:11:46.500 --> 01:11:48.500]  Ну во-первых, вот это.
[01:11:48.500 --> 01:11:50.500]  Я тут говорил про мапчик, сетик,
[01:11:50.500 --> 01:11:52.500]  определите дефолт спейс шип и все хорошо,
[01:11:52.500 --> 01:11:54.500]  нет. Не надо определять на самом деле
[01:11:54.500 --> 01:11:56.500]  спейс шип, только потому что вы хотите
[01:11:56.500 --> 01:11:58.500]  в мап или в сет засунуть что-то.
[01:12:00.500 --> 01:12:02.500]  Тут опять идет апелляция к
[01:12:02.500 --> 01:12:04.500]  человеческой логике.
[01:12:04.500 --> 01:12:06.500]  Вот вы когда видите, что
[01:12:06.500 --> 01:12:08.500]  экземпляры класса можно сравнивать,
[01:12:08.500 --> 01:12:10.500]  вы ожидаете какой-то адекватный порядок.
[01:12:12.500 --> 01:12:14.500]  Лексикографический порядок на всем
[01:12:14.500 --> 01:12:16.500]  подряд он может быть неадекватным
[01:12:16.500 --> 01:12:18.500]  в большом количестве случаев.
[01:12:18.500 --> 01:12:20.500]  Для точек на плоскости
[01:12:20.500 --> 01:12:22.500]  лексикографический порядок он неестественный.
[01:12:22.500 --> 01:12:24.500]  Про комплексные числа
[01:12:24.500 --> 01:12:26.500]  не зря говорят, что их там невозможно упорядочить.
[01:12:26.500 --> 01:12:28.500]  Потому что так и есть, и вот с
[01:12:28.500 --> 01:12:30.500]  человеческого понимания нормальный порядок
[01:12:30.500 --> 01:12:32.500]  это не лексикографический.
[01:12:32.500 --> 01:12:34.500]  Сетили по полярному углу весьма-весьма
[01:12:34.500 --> 01:12:36.500]  и он... Ну у тебя все равно это
[01:12:36.500 --> 01:12:38.500]  будет не нормальный порядок,
[01:12:38.500 --> 01:12:40.500]  а с отношением эквивалентности.
[01:12:42.500 --> 01:12:44.500]  Это будет викордер как раз.
[01:12:44.500 --> 01:12:46.500]  Вот если ты по полярному углу
[01:12:46.500 --> 01:12:48.500]  сортируешь комплексные точки,
[01:12:48.500 --> 01:12:50.500]  комплексные числа,
[01:12:50.500 --> 01:12:52.500]  это будет викордер.
[01:12:52.500 --> 01:12:54.500]  Потому что у тебя на одном
[01:12:54.500 --> 01:12:56.500]  луче может лежать много-много
[01:12:56.500 --> 01:12:58.500]  точек, которые...
[01:13:00.500 --> 01:13:02.500]  То есть сначала по полярному углу, потом по
[01:13:02.500 --> 01:13:04.500]  расстоянию. Окей.
[01:13:04.500 --> 01:13:06.500]  Все равно непонятно...
[01:13:06.500 --> 01:13:08.500]  Все равно непонятно, является ли это
[01:13:08.500 --> 01:13:10.500]  естественным каким-то порядком для них.
[01:13:10.500 --> 01:13:12.500]  Можно дружить ли далее
[01:13:12.500 --> 01:13:14.500]  с какими-то другими операциями?
[01:13:14.500 --> 01:13:16.500]  Полезно ли это на практике? Но вот окажется, что нет.
[01:13:16.500 --> 01:13:18.500]  А поэтому не следует
[01:13:18.500 --> 01:13:20.500]  брать и впендюривать во все классы подряд
[01:13:20.500 --> 01:13:22.500]  дефолтные операторы-сравнения
[01:13:22.500 --> 01:13:24.500]  и вообще операторы-сравнения.
[01:13:24.500 --> 01:13:26.500]  Лучше бы напишите компаратор отдельный,
[01:13:26.500 --> 01:13:28.500]  прокиньте его руками в
[01:13:28.500 --> 01:13:30.500]  сам мапчик или сам сетик.
[01:13:30.500 --> 01:13:32.500]  Потому что кто-то другой, кто начнет пользоваться вашими структурами,
[01:13:32.500 --> 01:13:34.500]  он может не ожидать таких
[01:13:34.500 --> 01:13:36.500]  странных порядков.
[01:13:36.500 --> 01:13:38.500]  Порядки должны быть такими
[01:13:38.500 --> 01:13:40.500]  естественными.
[01:13:40.500 --> 01:13:42.500]  Если...
[01:13:42.500 --> 01:13:44.500]  В каком-то смысле мне кажется,
[01:13:44.500 --> 01:13:46.500]  что в случае с флотами,
[01:13:46.500 --> 01:13:48.500]  тот порядок, который по умолчанию
[01:13:48.500 --> 01:13:50.500]  встроен в свой язык,
[01:13:50.500 --> 01:13:52.500]  он...
[01:13:52.500 --> 01:13:54.500]  ну...
[01:13:54.500 --> 01:13:56.500]  внесть к тому, что мы
[01:13:58.500 --> 01:14:00.500]  должны вводить
[01:14:00.500 --> 01:14:02.500]  свой оператор равно, который там
[01:14:02.500 --> 01:14:04.500]  учитывает небольшие смещения.
[01:14:04.500 --> 01:14:06.500]  В этом случае какой-то совет есть?
[01:14:06.500 --> 01:14:08.500]  Нет, так
[01:14:08.500 --> 01:14:10.500]  правильно все.
[01:14:10.500 --> 01:14:12.500]  С флотами все правильно сделали,
[01:14:12.500 --> 01:14:14.500]  потому что флоты по своей
[01:14:14.500 --> 01:14:16.500]  природе это
[01:14:16.500 --> 01:14:18.500]  не действительные числа и даже не рациональные.
[01:14:18.500 --> 01:14:20.500]  Это хитрая конструкция.
[01:14:20.500 --> 01:14:22.500]  И чтобы корректно с ней работать,
[01:14:22.500 --> 01:14:24.500]  нужно понимать, что ты делаешь,
[01:14:24.500 --> 01:14:26.500]  понимать, с какой погрешностью ты работаешь
[01:14:26.500 --> 01:14:28.500]  и брать эпсилон меньше этой
[01:14:28.500 --> 01:14:30.500]  погрешности.
[01:14:30.500 --> 01:14:32.500]  Это все вопрос просто и вычмотов такой.
[01:14:32.500 --> 01:14:34.500]  И если в языке просто за вас выберут,
[01:14:34.500 --> 01:14:36.500]  что мы будем сравнивать
[01:14:36.500 --> 01:14:38.500]  флоты с точностью
[01:14:38.500 --> 01:14:40.500]  1e-7.
[01:14:40.500 --> 01:14:42.500]  Но это будет невозможно использовать
[01:14:42.500 --> 01:14:44.500]  на практике.
[01:14:44.500 --> 01:14:46.500]  Что вдруг у вас числа как раз близкие к 1e-7,
[01:14:46.500 --> 01:14:48.500]  и вам там вот чуть-чуть не хватает,
[01:14:48.500 --> 01:14:50.500]  а они там... зазор взяли слишком
[01:14:50.500 --> 01:14:52.500]  большой.
[01:14:54.500 --> 01:14:56.500]  Ну или наоборот. Вдруг у вас огромная
[01:14:56.500 --> 01:14:58.500]  погрешность, и вам все-таки хочется сравнивать
[01:14:58.500 --> 01:15:00.500]  с точностью до 1e-3.
[01:15:00.500 --> 01:15:02.500]  Ну и сами же флотания не
[01:15:02.500 --> 01:15:04.500]  равномерно распределены?
[01:15:04.500 --> 01:15:06.500]  Тоже, тоже, да.
[01:15:06.500 --> 01:15:08.500]  Тут просто нет хорошего числа, чтобы выбрать
[01:15:08.500 --> 01:15:10.500]  с какой точностью. Поэтому решили
[01:15:10.500 --> 01:15:12.500]  во всех языках ничего
[01:15:12.500 --> 01:15:14.500]  не делать с этим.
[01:15:14.500 --> 01:15:16.500]  Тут два пункта еще.
[01:15:18.500 --> 01:15:20.500]  Вот это вообще непонятный пункт.
[01:15:20.500 --> 01:15:22.500]  Третий.
[01:15:22.500 --> 01:15:24.500]  В целом не используйте просто викордеринг.
[01:15:24.500 --> 01:15:26.500]  Он как бы есть для некоторых
[01:15:26.500 --> 01:15:28.500]  особых случаев нужен, но лучше
[01:15:28.500 --> 01:15:30.500]  избегать.
[01:15:30.500 --> 01:15:32.500]  Ну как бы да, но лучше всегда
[01:15:32.500 --> 01:15:34.500]  самое хорошее, потому что
[01:15:34.500 --> 01:15:36.500]  что ты с паршал порядочной штукой
[01:15:36.500 --> 01:15:38.500]  сможешь сделать?
[01:15:38.500 --> 01:15:40.500]  Ты даже посортировать не сможешь.
[01:15:42.500 --> 01:15:44.500]  Но вообще как бы
[01:15:44.500 --> 01:15:46.500]  флоты ты можешь посортировать, потому
[01:15:46.500 --> 01:15:48.500]  что там всегда через вот эти вот
[01:15:48.500 --> 01:15:50.500]  синт три вей
[01:15:50.500 --> 01:15:52.500]  штуки. Это кажется старый термин.
[01:15:52.500 --> 01:15:54.500]  Короче, вот эти шесть функций, которые мы
[01:15:54.500 --> 01:15:56.500]  видели, половина из которых fallback,
[01:15:56.500 --> 01:15:58.500]  половина обычная. В обобщенном коде
[01:15:58.500 --> 01:16:00.500]  надо вот не spaceship, а их использовать.
[01:16:00.500 --> 01:16:02.500]  И будет все хорошо.
[01:16:04.500 --> 01:16:06.500]  Да, да.
[01:16:06.500 --> 01:16:08.500]  Но если вы хотите запретить legacy, то можно без
[01:16:08.500 --> 01:16:10.500]  fallback. Вдруг вам так надо.
[01:16:12.500 --> 01:16:14.500]  Вот тут был совет
[01:16:14.500 --> 01:16:16.500]  про то, что надо
[01:16:16.500 --> 01:16:18.500]  операторы сравнения делать
[01:16:18.500 --> 01:16:20.500]  свободными функциями, а не методами.
[01:16:22.500 --> 01:16:24.500]  Какой-то фиговый совет.
[01:16:28.500 --> 01:16:30.500]  А, ну там про разные типы было, да?
[01:16:30.500 --> 01:16:32.500]  Про разные типы,
[01:16:32.500 --> 01:16:34.500]  что там... Привитения
[01:16:34.500 --> 01:16:36.500]  какие-то.
[01:16:36.500 --> 01:16:38.500]  Да, ну теперь из-за синтеза все хорошо,
[01:16:38.500 --> 01:16:40.500]  но я скажу, что и это все фигня.
[01:16:40.500 --> 01:16:42.500]  И вот это
[01:16:42.500 --> 01:16:44.500]  тоже фигня.
[01:16:44.500 --> 01:16:46.500]  Надо делать friend-off.
[01:16:48.500 --> 01:16:50.500]  Да, кстати,
[01:16:50.500 --> 01:16:52.500]  я там выше объявлял
[01:16:52.500 --> 01:16:54.500]  friend-off прямо внутри класса.
[01:16:54.500 --> 01:16:56.500]  Это не смутило?
[01:16:56.500 --> 01:16:58.500]  Вы такое видели уже?
[01:17:02.500 --> 01:17:04.500]  Давайте я найду.
[01:17:06.500 --> 01:17:08.500]  Нет, я хочу, чтобы определение было.
[01:17:08.500 --> 01:17:10.500]  Не только объявление, но и определение.
[01:17:14.500 --> 01:17:16.500]  А тут не хватает ключевого...
[01:17:16.500 --> 01:17:18.500]  А, нет, да.
[01:17:18.500 --> 01:17:20.500]  Так, черт.
[01:17:20.500 --> 01:17:22.500]  Ладно, короче,
[01:17:22.500 --> 01:17:24.500]  можно вот прям здесь объявить
[01:17:26.500 --> 01:17:28.500]  саму функцию.
[01:17:28.500 --> 01:17:30.500]  Это ее определение, а можно ее объявить
[01:17:30.500 --> 01:17:32.500]  прямо здесь. И вот этот способ
[01:17:32.500 --> 01:17:34.500]  я считаю оптимальным. А почему
[01:17:34.500 --> 01:17:36.500]  чуть попозже узнаем...
[01:17:36.500 --> 01:17:38.500]  Так, давайте все.
[01:17:38.500 --> 01:17:40.500]  На этом же у нас кончились приколы.
[01:17:40.500 --> 01:17:42.500]  А, ну тут вот вообще
[01:17:42.500 --> 01:17:44.500]  никогда не используйте
[01:17:44.500 --> 01:17:46.500]  partial ordering.
[01:17:46.500 --> 01:17:48.500]  Все знают, что с такими типами делать
[01:17:48.500 --> 01:17:50.500]  и куда их засунуть вообще можно.
[01:17:50.500 --> 01:17:52.500]  Ну, возникает вопрос, опять же,
[01:17:52.500 --> 01:17:54.500]  зачем стандарт добавили?
[01:17:54.500 --> 01:17:56.500]  Но, вероятно, кому-то это очень нужно было.
[01:17:58.500 --> 01:18:00.500]  О, сейчас узнаем,
[01:18:00.500 --> 01:18:02.500]  почему про friend-off хорошо.
[01:18:02.500 --> 01:18:04.500]  Надо только посмотреть на время.
[01:18:04.500 --> 01:18:06.500]  Мы сколько здесь уже?
[01:18:06.500 --> 01:18:08.500]  Час 45.
[01:18:08.500 --> 01:18:10.500]  Наверное, время перерыва.
[01:18:10.500 --> 01:18:12.500]  И дальше нужно будет...
[01:18:12.500 --> 01:18:14.500]  Да, давайте перерыв
[01:18:14.500 --> 01:18:16.500]  50 минут.
[01:18:16.500 --> 01:18:18.500]  55, окей.
[01:18:18.500 --> 01:18:20.500]  Перерыв, и потом возвращаемся.
[01:18:20.500 --> 01:18:22.500]  И нам надо голопом по европам, чтобы еще
[01:18:22.500 --> 01:18:24.500]  код пописать.
[01:18:24.500 --> 01:18:26.500]  Что-то как-то затянулось.
