[00:00.000 --> 00:08.000]  Так, давайте начинать.
[00:08.000 --> 00:13.700]  Я сегодня про деревья немножко поговорю, там видимо в контесте
[00:13.700 --> 00:15.520]  есть задача про лица, вот давайте с лица начнём.
[00:15.520 --> 00:20.200]  Так, нет, рано, определение.
[00:20.200 --> 00:27.000]  Значит, что такое дерево?
[00:27.000 --> 00:28.920]  Сложный конечно вопрос, дерево это неориентированный
[00:28.920 --> 00:29.920]  граф без циклов.
[00:29.920 --> 00:38.320]  Так, определим, граф без циклов, тогда же называется
[00:38.320 --> 00:39.320]  деревом.
[00:39.320 --> 00:49.520]  Да, так, что-то я сегодня, связный, да, неориентированный
[00:49.520 --> 00:56.920]  связный граф без циклов, достаточно вроде бы.
[00:56.920 --> 00:59.520]  Ну, какие свойства у деревьев есть?
[00:59.520 --> 01:02.920]  Значит, во-первых, ребер у них всегда на один меньшим
[01:02.920 --> 01:09.920]  вершин, вот, и это можно, например, аргументировать
[01:09.920 --> 01:13.080]  тем, что, ну, смотрите, давайте скажем, что граф изначально
[01:13.080 --> 01:15.280]  пустой, то есть там нет ребер, и вот каждая вершинка
[01:15.280 --> 01:16.280]  сама по себе.
[01:16.280 --> 01:19.520]  У меня получается есть n, ну, то есть мощность v компонент
[01:19.520 --> 01:20.520]  связности.
[01:20.520 --> 01:23.680]  И дальше я хочу, чтобы каждое ребро стягивало какие-то
[01:23.680 --> 01:26.120]  две новые компоненты связанности, которые раньше были не
[01:26.120 --> 01:27.560]  связанные, а теперь вот я провел ребро, они стали
[01:27.560 --> 01:28.560]  связанные.
[01:28.560 --> 01:30.480]  Ну и понятно, что если у меня изначально n компонент
[01:30.480 --> 01:33.120]  связанности, а в конце должна быть одна, то мне нужно провести
[01:33.120 --> 01:35.920]  хотя бы n-1 ребро, чтобы все стянуть в одну.
[01:35.920 --> 01:36.920]  Вот.
[01:36.920 --> 01:38.800]  Ну и вот как раз дерево, это где никаких других
[01:38.800 --> 01:41.160]  ребер нету, то есть каждое проводимое ребро, оно стягивает
[01:41.160 --> 01:42.160]  как раз две какие-то компоненты.
[01:42.160 --> 01:43.160]  Вот.
[01:43.160 --> 01:49.000]  Ну, во-вторых, например, известно, что в дереве
[01:49.000 --> 01:52.160]  между любыми двумя вершинками есть ровно один путь простой.
[01:53.040 --> 02:01.240]  Значит между любыми двумя вершинами есть ровно один
[02:01.240 --> 02:02.240]  простой путь.
[02:02.240 --> 02:07.240]  Вот.
[02:07.240 --> 02:17.240]  То есть, если фиксировать любые две вершинки у и
[02:17.240 --> 02:21.480]  в, то существует ровно одна последовательность ребер,
[02:21.480 --> 02:25.920]  нужно пройти, чтобы из одной попасть в другую.
[02:25.920 --> 02:28.840]  Ну интуитивно, значит, почему это может быть так.
[02:28.840 --> 02:31.320]  Ну понятно, раз граф связан, то путь обязательно есть
[02:31.320 --> 02:33.320]  между любыми двумя вершинами.
[02:33.320 --> 02:34.320]  Почему он единственный?
[02:34.320 --> 02:36.480]  Ну пусть есть какие-то два пути из УВ.
[02:36.480 --> 02:38.800]  Вот есть какой-то такой путь, есть какой-то другой
[02:38.800 --> 02:40.760]  путь, да, там как-то от него отличающийся.
[02:40.760 --> 02:46.040]  Вот, ну тогда цикл есть обязательно, да, типа на картинке видно,
[02:46.040 --> 02:47.920]  что вот как раз вот это будет циклом.
[02:47.920 --> 02:51.400]  Ну и формально тоже можно наказать, можно, если, скажем,
[02:51.400 --> 02:55.360]  рассмотреть вот все ребра, используемые в первом пути,
[02:55.360 --> 02:58.040]  все ребра, используемые во втором пути, и если взять
[02:58.040 --> 03:00.240]  их симметрическую разность, то есть оставить только
[03:00.240 --> 03:02.800]  те, которые присутствуют ровно в одном из двух путей,
[03:02.800 --> 03:05.880]  то у нас получится, ну там, вот в этом случае получится
[03:05.880 --> 03:08.280]  просто вот такой вот цикл, в общем случае получится
[03:08.280 --> 03:12.800]  несколько циклов, что противоречит как раз определению дерева.
[03:12.800 --> 03:16.840]  Да, но почему это так, ну скажем, что такое путь вообще?
[03:16.840 --> 03:20.440]  Вот если рассмотреть путь как граф, то это граф, в котором
[03:20.440 --> 03:23.800]  каждая вишина имеет степень 1 или 2, вот, у нас есть два
[03:23.800 --> 03:27.160]  таких графа, путь первый, путь второй, если рассмотреть
[03:27.160 --> 03:29.600]  симметрическую разность, то я утверждаю, что у каждой
[03:29.600 --> 03:31.400]  вишины будет степень максимум 2 как раз.
[03:31.400 --> 03:41.400]  Это неправда, да, сейчас, да, неправда, кстати, потому
[03:41.400 --> 03:46.480]  что, например, есть вот такой вот и вот такой вот, да,
[03:46.560 --> 03:52.840]  то есть разность как раз, хорошо, обманул, ну окей,
[03:52.840 --> 03:54.960]  да, так это не доказывается, но в любом случае понятно,
[03:54.960 --> 04:02.680]  что если у вас есть два маршрута отсюда до сюда, то, ну понятно,
[04:02.680 --> 04:11.280]  можно поверить же, не-не-не, не надо, не надо, может, скажем,
[04:11.280 --> 04:13.560]  там рассмотреть, вот первый момент времени, когда пути
[04:13.560 --> 04:16.600]  расходятся, вот, можно так рассмотреть, пусть первый
[04:16.600 --> 04:18.840]  момент времени, когда они расходятся, посмотрим,
[04:18.840 --> 04:21.200]  и потом первый момент, когда они сходятся, тогда
[04:21.200 --> 04:24.080]  все вот эти вот вершины попарно различные и, значит, тут
[04:24.080 --> 04:29.520]  есть цикл, ну может так, например, вот, но мы это
[04:29.520 --> 04:33.440]  используем как просто вот, как данность более-менее,
[04:33.440 --> 04:41.080]  ну вот, хорошо, дерево это вот такой граф, да, связанный
[04:41.080 --> 04:45.160]  без циклов, я буду часто говорить про ориентированное
[04:45.160 --> 04:51.120]  дерево, ну или оно же корневое, да, давайте буду говорить
[04:51.120 --> 04:57.240]  лучше, корневое, корневое дерево, это когда в моем
[04:57.240 --> 05:02.240]  дереве выделено некая корневая вершинка R, и все ребра как
[05:02.240 --> 05:08.600]  будто бы ориентированы сверху вниз от этого корня R, ну,
[05:08.600 --> 05:11.400]  то есть вот что-то такое, где ребра как будто бы
[05:11.400 --> 05:14.880]  сверху вниз ориентированы, вот, корневое дерево, это
[05:14.880 --> 05:17.400]  дерево, где выделено некая фиксированная вершинка
[05:17.400 --> 05:22.360]  корень R, вот, и по умолчанию считается, что все ребра
[05:22.360 --> 05:26.400]  идут сверху вниз, то есть от, ну, по факту ориентированы
[05:26.400 --> 05:29.480]  на путях от R до всех вершин, вот, как бы вот в ту сторону
[05:29.480 --> 05:36.400]  от R, вот, ну и, соответственно, вот в таком корневом дереве
[05:36.480 --> 05:43.000]  при фиксации какого-то корня я буду говорить об LCA, значит,
[05:43.000 --> 05:47.680]  он же то ли lowest, то ли least, давайте скажем lowest common
[05:47.680 --> 06:00.000]  ancestor, а по-русски наименьший общепредок, наименьший
[06:00.000 --> 06:01.000]  общепредок.
[06:02.000 --> 06:06.000]  Значит, следующая штука, вот представьте, у вас
[06:06.000 --> 06:11.880]  есть две вершины какие-то у и в, ну, давайте рассмотрим
[06:11.880 --> 06:17.080]  путь между ними, мы знаем, что путь единствен, вот,
[06:17.080 --> 06:19.400]  ну, он тут как бы не совсем согласован с ориентацией
[06:19.400 --> 06:22.200]  этих ребер, потому что ему там иногда надо придется,
[06:22.200 --> 06:26.360]  надо идти вверх, то есть как бы против движения,
[06:26.360 --> 06:28.560]  против направлений ребер, ну, не важно, у меня же граф
[06:28.560 --> 06:31.240]  на самом деле не ориентированный, вот такой путь я рассмотрю
[06:31.240 --> 06:35.040]  между ними, вот, и давайте самую высокую вершинку
[06:35.040 --> 06:45.000]  на этом пути я как раз назову LCA, LCA для вершин у и в, вот,
[06:45.000 --> 06:47.320]  ну и вообще любой путь в дереве у меня это сначала
[06:47.320 --> 06:52.040]  подъем до LCA, потом спуск до второй вершинки, ну, почему
[06:52.040 --> 06:55.000]  это так, вот, не знаю, у меня есть корень, у меня есть
[06:55.240 --> 06:58.680]  другая вершина, есть другая вершина, можно построить
[06:58.680 --> 07:03.860]  путь от U до R, да, это какая-то послед существиробер,
[07:03.860 --> 07:06.920]  можно построить путь от V до R, это вновь какая-то
[07:06.920 --> 07:09.160]  последствитель�ер, которая рано или поздно сольется
[07:09.160 --> 07:11.880]  вот с этой вот последств Eine стрибер от У до R,
[07:11.880 --> 07:14.120]  то есть, либо они там где-то пересекутся и потом пойдут
[07:14.120 --> 07:17.720]  вместе, либо оно там полностью будет по другой ветке chicken
[07:17.720 --> 07:21.900]  ну, так или иначе, пути от U до Korn и от V до Korn що рано
[07:21.900 --> 07:24.600]  или поздно пересекутся в одной точке, и вот
[07:24.600 --> 07:33.280]  точка, где они пересекаются, и будет их Lца.
[07:33.280 --> 07:36.840]  Либо альтернативно, просто по определению, что такое
[07:36.840 --> 07:37.840]  Lца.
[07:37.840 --> 07:40.440]  Это такая самая низкая вершина, которая тем не менее является
[07:40.440 --> 07:41.440]  их общим предком.
[07:41.440 --> 07:45.480]  То есть такая самая низкая в дереве вершина, что тем
[07:45.480 --> 07:48.440]  не менее она является предком U и она является предком V.
[07:48.440 --> 07:51.320]  Предком в том смысле, что они обе из нее достижимы
[07:51.720 --> 07:52.720]  при движении вниз.
[07:52.720 --> 07:59.720]  Вот такие эквивалентные характеристики Lца.
[07:59.720 --> 08:03.960]  Вопрос, как можно было бы этот Lца находить довольно
[08:03.960 --> 08:04.960]  быстро.
[08:05.960 --> 08:08.960]  Как можно находить Lца быстро?
[08:22.960 --> 08:25.960]  Так, ну есть много способов.
[08:25.960 --> 08:31.960]  Давайте самый простой, давайте алгоритм 1.
[08:31.960 --> 08:33.960]  Это через двоичные подъемы.
[08:39.960 --> 08:40.960]  Значит, смотрите.
[08:40.960 --> 08:44.960]  Вот пусть у меня фиксирован какой-то корень R.
[08:44.960 --> 08:47.960]  У меня есть корневое дерево с корнем R.
[08:47.960 --> 08:50.960]  Давайте я запущу DFS из этого корня.
[08:53.960 --> 08:58.960]  Чем хорошо дерево, тем что, смотрите, в дереве у нас
[08:58.960 --> 09:00.960]  все пути как бы однозначно определены.
[09:00.960 --> 09:02.960]  Между любыми двумя вершинами есть ровно один путь.
[09:02.960 --> 09:06.960]  И поэтому в частности эти пути являются кратчайшими.
[09:06.960 --> 09:09.960]  Поскольку путь единственный, то тот самый единственный
[09:09.960 --> 09:11.960]  путь, это есть кратчайший путь.
[09:11.960 --> 09:14.960]  И поэтому, когда я запускаю DFS, он мне не только
[09:14.960 --> 09:17.960]  находит компонент связанности, но еще и все кратчайшие
[09:17.960 --> 09:18.960]  расстояния находит.
[09:18.960 --> 09:20.960]  От корня находит все расстояния до всех вершин.
[09:20.960 --> 09:26.960]  Поэтому если просто запустить DFS от корня, то он что сделает?
[09:26.960 --> 09:31.960]  Он упорядочит, найдет всех детей как соседей R,
[09:31.960 --> 09:35.960]  потом будут все соседей R, точнее соседей-соседей и так далее.
[09:35.960 --> 09:39.960]  То есть у меня все вершины упорядочатся по уровням.
[09:39.960 --> 09:42.960]  То есть так как было бы в BFS, но прямо внутри DFS,
[09:42.960 --> 09:44.960]  потому что пути однозначно определены, можно просто
[09:44.960 --> 09:47.960]  идти по графу, и это сразу расстояние считается.
[09:47.960 --> 09:52.960]  Ну и давайте я сразу разобью все вершины по вот этим
[09:52.960 --> 09:55.960]  уровням, по глубине.
[09:55.960 --> 09:58.960]  Что здесь глубина равна единице у всех этих вершин,
[09:58.960 --> 10:03.960]  здесь глубина равна двойке, ну и так далее.
[10:03.960 --> 10:06.960]  И прямо сразу в DFS я могу эту глубину насчитывать.
[10:06.960 --> 10:09.960]  Каждый раз, когда я перехожу вниз, я уменьшаю глубину на 1,
[10:09.960 --> 10:11.960]  поднимаюсь наверх и наоборот.
[10:11.960 --> 10:12.960]  Ну, короче, вы поняли.
[10:12.960 --> 10:14.960]  Спускаюсь вниз, у меня будет плюс глубина,
[10:14.960 --> 10:19.960]  поднимаясь с рекурсии наверх, будет минус глубина.
[10:19.960 --> 10:24.960]  Вот.
[10:24.960 --> 10:25.960]  Ну хорошо.
[10:25.960 --> 10:28.960]  И заодно, кстати, я посчитал, могу предпочитать
[10:28.960 --> 10:30.960]  для каждой вершины ее родителя.
[10:30.960 --> 10:33.960]  При вот таком спуске сверху вниз, при проходе из вершинки
[10:33.960 --> 10:38.960]  в ее сына, я могу записать, что родителем этого сына
[10:38.960 --> 10:39.960]  является вот эта вершина.
[10:39.960 --> 10:43.960]  То есть я не только глубины знаю, но и родителей всех вершин.
[10:43.960 --> 10:44.960]  Вот.
[10:44.960 --> 10:46.960]  А дальше идея следующая.
[10:46.960 --> 10:48.960]  Значит, как работают двоичные подъемы.
[10:48.960 --> 10:50.960]  Сначала я давайте введу такой массив,
[10:50.960 --> 10:54.960]  лифтс, да, binary-лифтс,
[10:54.960 --> 10:57.960]  который для каждого k и для каждой вершинки v
[10:57.960 --> 11:03.960]  находит предка вершины v в поколении с номером 2 в k.
[11:03.960 --> 11:09.960]  Значит, предок вершины v
[11:09.960 --> 11:12.960]  в 2 в k-том поколении.
[11:22.960 --> 11:25.960]  То есть что будет, если я встану v и 2 в k-то раз
[11:25.960 --> 11:29.960]  пропрыгаю наверх, то есть поднимусь в родителя.
[11:29.960 --> 11:30.960]  Вот.
[11:30.960 --> 11:32.960]  В частности, лифтс нулевой от v.
[11:32.960 --> 11:34.960]  Это просто родитель.
[11:34.960 --> 11:37.960]  То есть родитель в первом поколении просто родитель.
[11:37.960 --> 11:40.960]  То есть если вот это v, то вот это лифтс нулевой от v.
[11:40.960 --> 11:42.960]  Лифтс первого от v это получается дедушка,
[11:42.960 --> 11:44.960]  то есть родители родителя.
[11:44.960 --> 11:46.960]  Лифтс второго это как бы прапрадедушка,
[11:46.960 --> 11:48.960]  то есть дедушка дедушки, ну и так далее.
[11:48.960 --> 11:50.960]  По степням двойки.
[11:50.960 --> 11:52.960]  Значит, это либо предок в 2 в k-том поколении,
[11:52.960 --> 11:55.960]  если он существует, да, ну либо просто корень,
[11:55.960 --> 11:57.960]  если нет такого высокого предка.
[11:57.960 --> 11:59.960]  То есть если я пытаюсь куда-то прыгнуть слишком высоко,
[11:59.960 --> 12:01.960]  то я ограничиваюсь, обрываюсь r-кой.
[12:01.960 --> 12:04.960]  Либо корень, если такого нет.
[12:04.960 --> 12:08.960]  Либо r, если предка нет.
[12:15.960 --> 12:18.960]  Так, давайте сначала скажем, как это находить,
[12:18.960 --> 12:20.960]  как эти двойственные подъемы найти.
[12:20.960 --> 12:23.960]  Ну, во-первых, лифтс нулевой заполняется очень просто.
[12:25.960 --> 12:27.960]  Это просто родителя.
[12:27.960 --> 12:31.960]  Ну, родитель, если он есть, либо единственная вершина,
[12:31.960 --> 12:33.960]  у которой нет родителя, это сам корень,
[12:33.960 --> 12:36.960]  тогда можно просто сказать, что лифтс от корня это корень.
[12:38.960 --> 12:41.960]  Давайте я просто буду считать, что parent от r это r.
[12:45.960 --> 12:47.960]  Если родителям корневой вершины считать сам корень,
[12:47.960 --> 12:49.960]  то все сходится.
[12:51.960 --> 12:54.960]  Ну а если родителям корневой вершины считать сам корень,
[12:55.960 --> 12:57.960]  ну а дальше давайте считать,
[12:57.960 --> 13:01.960]  что пусть у меня известны все подъемы вплоть до катого уровня,
[13:02.960 --> 13:08.960]  пусть известны лифтс катая для всех вершин,
[13:08.960 --> 13:11.960]  хочу посчитать лифтс k плюс 1.
[13:13.960 --> 13:17.960]  То есть пойду по слоям по значению k.
[13:17.960 --> 13:21.960]  Ну, идея здесь на самом деле такая же, как в sparse table более-менее.
[13:22.960 --> 13:27.960]  Ну а именно следующее, чтобы получить предков 2 в k плюс 1 поколении,
[13:27.960 --> 13:30.960]  это значит, что мне нужно прыгнуть вверх на 2 в степени k плюс 1.
[13:30.960 --> 13:33.960]  Давайте я сначала прыгну на 2 в катой,
[13:33.960 --> 13:35.960]  потом еще раз прыгну на 2 в катой.
[13:35.960 --> 13:38.960]  В сумме как раз получится 2 в k плюс 1.
[13:38.960 --> 13:42.960]  Но узнавать предков поколений 2 в катой я умею.
[13:42.960 --> 13:44.960]  Это как раз лифтс прошлого слоя.
[13:44.960 --> 13:48.960]  Поэтому если вот эта вершинка, скажем, х, то у это ответ.
[13:51.960 --> 13:53.960]  Согласны?
[13:53.960 --> 13:57.960]  Ну и вот как раз, если где-то я пытаюсь прыгнуть выше головы,
[13:57.960 --> 14:01.960]  выше корня дерева, то это просто обрубится и будет корнем.
[14:01.960 --> 14:03.960]  То есть можно написать следующую.
[14:03.960 --> 14:05.960]  Можно написать такую мерзкую формулу.
[14:05.960 --> 14:09.960]  Я для экономии места напишу ее.
[14:09.960 --> 14:11.960]  Что такое предков 2 в k плюс 1?
[14:11.960 --> 14:15.960]  Это предок в катом поколении, предка в катом поколении.
[14:18.960 --> 14:20.960]  Точнее в 2 в катом поколении.
[14:23.960 --> 14:25.960]  Кат и предок катома предка.
[14:25.960 --> 14:27.960]  Правда же?
[14:27.960 --> 14:30.960]  Ну все, очень простой пересчет.
[14:30.960 --> 14:32.960]  Прям думать не надо почти.
[14:32.960 --> 14:37.960]  Тогда утверждается, что на подсчет двоичных подъемов
[14:37.960 --> 14:40.960]  мне нужно столько времени и памяти.
[14:40.960 --> 14:42.960]  И вот я думаю, что я еще не готов.
[14:42.960 --> 14:44.960]  Я не буду думать.
[14:44.960 --> 14:46.960]  Все эти пересчеты на 2 в катом поколении,
[14:46.960 --> 14:48.960]  на 1 в катом поколении,
[14:48.960 --> 14:50.960]  на 1 в катом поколении,
[14:50.960 --> 14:52.960]  на 1 в катом поколении,
[14:52.960 --> 15:02.320]  подъемов, мне нужно вот столько времени и памяти.
[15:02.320 --> 15:04.880]  Ну потому что понятно, k нет смысла брать больше, чем логарифм,
[15:04.880 --> 15:09.220]  потому что если k больше, чем логарифм, то 2 вкаты больше, чем n, и я прям в небо
[15:09.220 --> 15:14.000]  прыгаю, я явно выше корня, поэтому k брать больше логарифма смысла не имеет,
[15:14.000 --> 15:21.240]  но если k не больше логарифма, то у меня первый аргумент в моем массиве
[15:21.240 --> 15:27.680]  принимает лог значений, второй n значений, ну и отсюда как раз и лог получается.
[15:27.680 --> 15:33.640]  Вот. Ну хорошо, теперь давайте считать, что двоичный подъем я насчитал.
[15:33.640 --> 15:42.680]  Что дальше? Как теперь находить lca?
[15:42.680 --> 15:52.240]  Вот из вершин в дереве я хочу найти их lca. Давайте его как-нибудь уже изображу.
[15:52.240 --> 16:06.200]  Я сделаю следующее, возможно не самый интуитивный способ, но работающий.
[16:06.200 --> 16:13.040]  Значит, давайте я вместо того, чтобы искать lca, я найду вот это вот сына lca,
[16:13.040 --> 16:21.480]  то есть ребенок w, лежащий вот на ветке между w и u, вот первая вершина вот на этом пути.
[16:21.480 --> 16:30.680]  Я хочу вот эту штуку найти. Как это сделать? Можно сказать так, что эта вершина это самый
[16:30.680 --> 16:35.960]  высокий предок u, не являющийся предком v. Давайте скажем, что это будет у меня p.
[16:35.960 --> 16:49.800]  Да, тогда p это самый высокий предок u, не являющийся предком v.
[16:49.800 --> 16:56.840]  Ну и тогда ответ это просто p rent от p.
[16:56.840 --> 17:26.360]  Хорошо. Во-первых, мне нужна вот подпроцедурка коротенькая,
[17:26.360 --> 17:33.320]  которая проверяет, является вершинопредком или нет в дереве. Делается это очень просто.
[17:33.320 --> 17:38.360]  Давайте в DFS насчитывать не только вот все, что я здесь уже насчитал, но еще и давайте
[17:38.360 --> 17:46.000]  ставить наши любимые меточки tint и out. Время входа, время выхода из вершины. Когда захожу в вершину,
[17:46.000 --> 17:48.480]  то есть у меня есть какой-то глобальный таймер, который считает количество шагов,
[17:48.480 --> 17:53.680]  которые я сделал. Захожу в вершину, поставил tint, увеличил таймер, выхожу, то есть хочу
[17:53.680 --> 17:58.480]  завершить рекурсию, подняться наверх, ставлю tout и увеличиваю таймер, поднимаюсь наверх.
[17:58.480 --> 18:03.960]  Так же, как в самом обычном DFS, я расставляю меточки tint и out. Значит, тогда можно проверить,
[18:03.960 --> 18:10.520]  что одна вершина это предок другой следующим образом. Бульевская функция является или предком
[18:10.520 --> 18:23.080]  там не знаю, вершина x, вершина y. Это просто следующие две проверки. Чтобы x была предком y,
[18:23.080 --> 18:37.360]  у нее должен быть меньше tint и больше tout. Ну не строго все. Вот эта штука проверяет,
[18:37.360 --> 18:54.320]  что x это предок y. Вот, я утверждаю, что x это предок y, если и только если у них вот так
[18:54.320 --> 19:04.640]  соотносятся tint и tout. Ну хорошо, давайте дерево какое-то рассмотрим. Пусть есть дерево большое,
[19:04.640 --> 19:10.680]  пусть тут есть x. Давайте в одну, в простую сторону. Пусть x это предок y. Что это значит?
[19:10.680 --> 19:18.720]  Если x предок y, значит я сначала от корня дошел до x, потом где-то внизу нашел y. Тогда понятно,
[19:18.720 --> 19:25.920]  что у меня DFS сначала нашел x, потом нашел y, потом вышел из y и только потом вышел из x.
[19:25.920 --> 19:30.520]  Значит у меня как раз выполняется такие неравенства, что я сначала вошел в x,
[19:30.520 --> 19:38.560]  потом после этого вошел в y, обнаружил его где-то снизу, потом вышел из него и только потом,
[19:38.560 --> 19:46.240]  поднявшись наверх и все еще обойдя, вышел из x. Значит все вот эти неравенства выполняются.
[19:46.240 --> 19:59.200]  Ну а вот если x не является предком y, то это будет неверно. Я имею в виду неравенство не
[19:59.200 --> 20:03.920]  строгие, то есть я считаю, что вершина является предком самой себя. То есть если скормить туда
[20:03.920 --> 20:09.800]  две одинаковые вершинки, то будет считать, что она является предком самой себя. Понятно,
[20:09.800 --> 20:13.760]  если поменяю местами y и x, то у меня конечно не будет выполняться вот это вот неравенство.
[20:13.760 --> 20:19.240]  А если они вообще лежат в каких-то разных поддеревьях, скажем вот здесь вот x,
[20:19.240 --> 20:24.920]  а вот здесь вот y, в каких-то там не пересекаешься поддеревьях, ну тогда понятно, что я сначала
[20:24.920 --> 20:31.000]  выйду из x, а потом обнаружу y. А вот здесь как раз вот, давайте так нарисую, как раз вот эти
[20:31.000 --> 20:36.640]  неравенства означают, что засечки установлены во времени следующим образом, что я сначала вошел в x,
[20:36.640 --> 20:49.760]  потом вошел в y, потом вышел из y, потом вышел из x. А если они вот так вот как бы не пересекаются,
[20:49.760 --> 20:55.840]  деревья затрагивают, то я сначала вышел из x, а потом вошел в y, и вот это вот вложение уже будет
[20:55.840 --> 21:07.480]  неверно. Так, сойдет? Ну вот. Все, проверять предыдущность мы умеем, то есть мы умеем
[21:07.480 --> 21:11.640]  проверять, что одна вершина предка другой. Теперь я хочу вот найти самого высокого предка,
[21:11.640 --> 21:28.760]  не являющегося предком v. Ну сейчас сделаем. Значит, процедура LCA. Давайте вот так напишу.
[21:28.760 --> 21:36.520]  LCA принимает две вершинки u и v, работает следующим образом. Ну, во-первых, если u это предок v,
[21:36.520 --> 21:51.040]  то можно сразу ее вернуть, ничего находить больше не нужно. Вернуть u. Если одна вершина предка
[21:51.040 --> 21:57.920]  другой, то она и есть LCA, выше не нужно прыгать. Вот, а иначе как раз вот такая вот картинка какая-то,
[21:57.920 --> 22:03.400]  и я могу найти вот этот вот p, который является вот самым высоким предком u, не являющимся предком v.
[22:03.400 --> 22:14.520]  И это идет следующим образом. Ну пусть будет p равно u. Значит, по всем k, начиная с какого-нибудь
[22:14.520 --> 22:28.440]  k-max до нуля, я пытаюсь поднять p на два степеника вверх, если при этом выполняется условие,
[22:28.440 --> 22:51.240]  что p это не предок v. Если неверно, что k и предок p являются предком v, то есть если я
[22:51.240 --> 22:56.400]  могу спокойно прыгнуть из p на 2 в k вверх, и при этом я все еще не окажусь предком v. То есть я
[22:56.400 --> 23:02.920]  прыгаю на 2 в k спокойно, не оказываюсь при этом предком v. Тогда я могу прыгнуть. Тогда просто
[23:02.920 --> 23:15.280]  вместо p беру лифтс k-t-p-t. Вот, значит вот так жадно прыгаю по степням двойки, по всем позволяющим
[23:15.280 --> 23:19.320]  мне прыгать вверх. И дальше я утверждаю, что в конце p это вот ровно то самое p, которое мне
[23:19.320 --> 23:45.320]  нужно. И в качестве ответа я удушаю просто parent от p. Ретерн parent от p. Просто что? Ну, можно,
[23:45.320 --> 23:50.960]  да. Ну, как бы можно, но я думаю, что это особо не даст вам выигрыша. То есть здесь можно проверить,
[23:50.960 --> 23:57.440]  действительно, что если наоборот, если v предок, то можно вернуть v сразу. Ну, тут как бы на любителя.
[23:57.440 --> 24:04.040]  С одной стороны больше кода на целую строчку, с другой стороны чуть быстрее. Ну, не знаю, в общем
[24:04.040 --> 24:08.240]  случае, если вам дали две случайные вершины, то они обычно как раз не соотносятся друг с другом,
[24:08.240 --> 24:18.400]  то есть ни одна не предок другой. Поэтому я так обычно не делал. Вот, значит, почему это работает?
[24:18.400 --> 24:23.520]  То есть я утверждаю, что по окончании вот этого цикла p это реально самая высокая возможная вершина,
[24:23.520 --> 24:30.400]  при этом не являешься предком v. Вот. Ну, почему это так? Потому что, смотрите, вот можно представить
[24:30.400 --> 24:36.800]  вот это вот расстояние между u и настоящим p как степень двойки. И по факту я вот как раз иду
[24:36.800 --> 24:40.960]  по вот этой вот битовой записи. То есть я представляю вот это расстояние в длительности
[24:40.960 --> 24:46.320]  имуществления, иду справа налево от старших битых к младшим и каждую возможную днику пропрыгиваю.
[24:46.320 --> 24:51.280]  А то есть, ну там не знаю, если на 16 вверх прыгнуть нельзя, то я не прыгаю, а если на 8 можно, то я
[24:51.280 --> 24:56.680]  прыгаю. Как раз вот это вот число я представляю в длительности имуществления, оно задает мне те
[24:56.680 --> 25:02.600]  возможные прыжки, которые надо сделать, я их прыгаю в том порядке от больших к меньшим. Вот. И в конце
[25:02.600 --> 25:10.360]  как раз я пропрыгаю все возможные степени двойки. То есть, ну там не знаю, 8 плюс 4, ну там плюс 2,
[25:10.360 --> 25:17.280]  например. Все возможные пропрыгал, выше нельзя. Так. Поэтому вот p будет вот ровно вот эта точка.
[25:17.280 --> 25:27.080]  Понятно? Ну все, кайф. Значит, тогда получилось что? У нас получился предподсчет n log n на то, чтобы
[25:27.080 --> 25:33.280]  посчитать вот эти глубины, t in и t out и двойчные подъемы. А после этого на запрос я отвечаю
[25:33.280 --> 25:43.520]  за логарифм всего лишь. Да, потому что вот он код, он за логарифм работает. Вот. Это был первый способ.
[25:43.520 --> 25:57.200]  Способ второй. Значит, через Эллеров обход.
[26:13.520 --> 26:36.960]  Значит, смотри, что такое Эллеров обход на примере. Давайте кунь дерева нарисую.
[26:36.960 --> 26:57.720]  Переборщил. Ну ладно. Как-нибудь они зонумерованы. Значит, Эллеров обход работает так. Мы встаем в
[26:57.720 --> 27:04.240]  корень, начинаем обходить все наше дерево, ну как обычно по DFS, там вверх-вниз проходим по
[27:04.240 --> 27:09.720]  ребрам, и каждый раз, когда заходим очередной раз в вершину, мы ее печатаем. Значит, тогда на этом
[27:09.720 --> 27:14.200]  примере что это будет такое? Сначала 1 в корне начал, потом перехожу в вершину номер 12,
[27:14.200 --> 27:19.960]  спускаюсь в номер 11. Ну я из нее сразу выхожу, поднимаюсь в 12, еще раз ее печатаю, несмотря на
[27:19.960 --> 27:27.160]  то, что она уже была, я ее еще раз напечатал, спускаюсь в 9. Значит, дальше 10, подъем в 9,
[27:27.160 --> 27:36.160]  спуск в 8, подъем 5 в 9, 12, 1, ну и так далее. То есть каждый раз, когда я наступаю в вершинку,
[27:36.160 --> 27:52.000]  там будь это снизу или сверху, я ее печатаю. Это называется Эллеров обход дерева. Значит,
[27:52.000 --> 27:57.840]  тогда утверждается следующее. Вот у меня есть какая-то последовательств вершин. Последовательств
[27:57.840 --> 28:08.680]  вершин у нее длина примерно 2n будет. Ну потому что по сути я каждое ребро прошел один раз сверху
[28:08.680 --> 28:13.760]  вниз, один раз снизу вверх, и каждое прохождение ребра дает мне печатание конца этого ребра. Я
[28:13.760 --> 28:18.520]  спустился сверху вниз, напечатал конец ребра, поднялся снизу вверх, напечатал опять-таки конец
[28:18.520 --> 28:23.160]  ребра. Ну и поскольку ребер у меня в два раза больше, pardon, ребер столько же сколько вершин
[28:23.160 --> 28:29.560]  примерно, и каждое ребро я печатаю, каждый ребро раздваивается сверху вниз, снизу вверх, то здесь
[28:29.560 --> 28:36.200]  вершин будет примерно в два раза больше, чем в исходном графе. То есть суммарно будет 2n вершин
[28:36.200 --> 28:42.680]  вот этой последовательств. Тогда утверждается, что верно следующее. Чтобы найти LCA каких-то двух
[28:42.680 --> 28:51.000]  вершин, скажем 11 и 8, мне нужно в этом Эллеровом обходе найти вхождение 11 и 8,
[28:51.000 --> 29:03.200]  и найти просто на отрезке между ними вершину с наименьшей глубиной. Я ищу вершину с наименьшей
[29:03.200 --> 29:14.280]  глубиной. Ну вот в нашем случае понятно, LCA это 12, ну и вот как раз на этом отрезке 12 это самое
[29:14.280 --> 29:24.360]  высокое. В общем случае, чтобы найти LCA каких-то двух вершин у и в, я нахожу, где они встречаются в
[29:24.360 --> 29:32.200]  моем Эллеровом обходе, скажем, на позициях L и R, и дальше в этом отрезке, на этом отрезке,
[29:32.200 --> 29:43.680]  я нахожу минимальную глубину, нахожу вершину с минимальной глубиной. Это неважно, можно взять
[29:43.680 --> 29:48.800]  любое вхождение U, любое вхождение V, и на отрезке между этими вхождениями найти вершину минимальной
[29:48.800 --> 29:57.920]  глубины. Вот, почему это верно? Почему минимальная глубина на отрезке это LCA? Ну потому что что
[29:57.920 --> 30:04.520]  такое вот это посредство вершин? Что такое Эллеров обход? По факту это некий путь в графе,
[30:04.520 --> 30:10.680]  да, и каждые вот как бы любые две соседние вершинки, они как раз ребром соединены. У меня так работает,
[30:10.680 --> 30:15.280]  что вот я прошел по ребру, напечатал вот конец, прошел, напечатал. То есть по факту у меня вот это
[30:15.280 --> 30:21.080]  некий путь в графе, так что любые два соседа соедены ребром. И значит, если я рассмотрю отрезок от U до V,
[30:21.080 --> 30:27.440]  то вот между ними какой-то путь от U до V, то есть это там какие-то ребра. Ну возможно не путь напрямую,
[30:27.440 --> 30:33.440]  как например вот в этом случае от 11 до 8, я добираюсь вот так. Я сначала захожу в 10,
[30:33.440 --> 30:39.400]  потом выхожу и спускаюсь в 8. То есть это какой-то путь с отменами, возможно. Я могу заходить в какие-то
[30:39.400 --> 30:48.480]  лишние ветки, но так или иначе я дохожу до конца от U до V. Ну и тогда понятно, что раз я дохожу,
[30:48.480 --> 30:54.880]  то на этом пути должен быть LCA. Я понимаю, что у меня любой путь этот LCA содержит. Ну а выше я
[30:54.880 --> 31:00.760]  никуда не перепрыгну, потому что если я поднимаюсь выше LCA, то значит я прошел все, что было ниже.
[31:00.760 --> 31:08.160]  Если я поднимаюсь вверх на какой-то вершинке, значит все по дереву я уже обошел. Ну поэтому
[31:08.160 --> 31:19.240]  действительно просто минимальная глубина здесь, это LCA. Понятно? Ну вот, хорошо. Получается,
[31:19.240 --> 31:22.840]  как работает алгоритм. Мы сначала строим error обход, это понятно за линию делается,
[31:22.840 --> 31:29.760]  потому что это просто DFS по сути. Дальше я для каждой вершинки запоминаю произвольное ее вхождение
[31:29.760 --> 31:35.720]  в этот массив на позицию вхождения. Повторю, мне неважно, если скажем 12 несколько раз встречается,
[31:35.720 --> 31:40.400]  мне неважно какое иное из вхождения брать, потому что какое бы я не взял, все равно любой путь
[31:40.400 --> 31:48.520]  там будет содержаться. Я запоминаю любое из вхождений, и чтобы найти потом LCA двух вершин,
[31:48.520 --> 31:52.720]  я нахожу вот эти два вхождения этих двух вершин и нахожу минимум на отрезке. Как искать
[31:52.720 --> 32:01.640]  минимум на отрезке? Спарстейблом, конечно. Поскольку у меня массив этот статичен,
[32:01.640 --> 32:06.440]  и он меняться не будет, структура дерева у меня один раз зафиксирована, и глубины меняться не
[32:06.440 --> 32:14.400]  будут, то я могу вместо дерева отрезков напевать спарстейбл. У меня статический массив элементов,
[32:14.400 --> 32:22.000]  мне нужно на отрезке находить минимум. Формально не минимум, а вершину с наименьшей глубиной. Поэтому
[32:22.000 --> 32:30.960]  скорее я должен не вот такой массив выписать, а массив пар глубина V, запятая V. И уже вот на
[32:30.960 --> 32:38.280]  таком массиве строить спарстейбл. Тогда как раз у меня пары сравниваются сначала по первому
[32:38.280 --> 32:42.200]  аргументу, и если я выбираю минимум из нескольких пар, то это будет как раз вершина с минимальной
[32:42.200 --> 32:49.880]  глубиной. То есть я построил такой массив вот с такими вот парами, построил error обход, где
[32:49.880 --> 32:55.240]  каждая вершина в пару превратилась, потом построил на этом спарстейбл и нахожу минимум на отрезке уже
[32:55.240 --> 33:05.240]  за единицу. Потому что в спарстейбле запрос за единицу обрабатывается. Получился алгоритм за n log n
[33:05.240 --> 33:11.800]  опять-таки на предподсчет, потому что спарстейбл требует n log n времени на предподсчет, а потом уже
[33:11.800 --> 33:25.120]  единичка на запрос. Вот. Похоже на правду? Супер. Ну то есть это чуть лучше, чем предыдущая,
[33:25.120 --> 33:34.240]  потому что тут на запрос всего лишь единичка входит, а не логариф. Так, ну и наконец третий
[33:34.240 --> 33:52.960]  алгоритм называется алгоритм Фарах Колтона Бендера. Два чувака, один чувак это Фарах Колтон, другой
[33:52.960 --> 34:12.560]  это Бендер. Поэтому тут дефис, а там тебе. Значит, сейчас вот магия. Смотрите, я остаюсь в этой парадигме того,
[34:12.560 --> 34:21.520]  что я рассматриваю эйлеров обход. Давайте я посмотрю в этом эйлеровом обходе на массив глубин.
[34:21.520 --> 34:25.440]  То есть у меня вот каждая вершина ассоциирована с какой-то глубиной. Давайте посмотрим на глубины,
[34:25.440 --> 34:32.360]  на последовательность глубин этих вершин. Понятно, что поскольку две соседние вершинки в обходе
[34:32.360 --> 34:37.720]  всегда с одной ребром, то глубины у меня при переходе к следующему элементу отличаются
[34:37.720 --> 34:41.680]  на плюс-минус один всегда. То есть когда я перехожу от одного элемента к следующему,
[34:41.680 --> 34:53.800]  у меня глубина либо на плюс один, либо на минус один изменяется. Но давайте скажу,
[34:53.800 --> 35:10.320]  что пусть n это длина эйлерового обхода. Давайте я введу вот такой параметр, половину логарифма.
[35:10.320 --> 35:20.880]  Ну там двоичный логарифм округленный куда-нибудь, неважно. И разобью весь мой обход на блоке длины k.
[35:20.880 --> 35:30.200]  Вот у меня был большой обход длины n, я его посплитил на блоке длины k. Ну если целиком не
[35:30.200 --> 35:34.960]  вошло, то как-нибудь вот так считаю, что там какие-то фиктивные элементы, неважно. Давайте я для
[35:34.960 --> 35:45.040]  простых считаю, что n делится на k. Вот. И дальше смотрите, каждый блок на самом деле, каждый маленький
[35:45.040 --> 35:51.680]  вот такой блок, может быть охарактеризован двумя числами. Значит, во-первых, это число х,
[35:51.680 --> 35:57.680]  которое написано в начале этого блока, а во-вторых, это последовательность из плюс-минус
[35:57.680 --> 36:03.040]  единичек, которые говорят мне про разность между соседями. То есть если в начале стоит х,
[36:03.040 --> 36:06.960]  то дальше, чтобы описать целиком этот блок, мне нужно всего лишь знать, насколько отличаются эти
[36:06.960 --> 36:12.840]  два элемента, эти два, эти два, эти два и так далее. То есть по факту каждый блок характеризуется х и
[36:12.840 --> 36:28.040]  маской длины k-1. Маска длины k-1. Ну давайте там скажем, что, не знаю, 1 соответствует единичке,
[36:28.040 --> 36:32.360]  а минус 1 соответствует нулю. Тогда как раз последовательность плюс-минус единичек это
[36:32.360 --> 36:37.800]  какая-то просто битовая маска длины k-1. Вот, и если у меня зафиксировано первый
[36:37.800 --> 36:44.000]  элемент пары и битовая маска, то я точно знаю, как выглядят все элементы этого массива. Понятно?
[36:44.000 --> 36:58.680]  Еще раз? Нет, это число, смотрите, смотрите. Давайте так, давайте вот в этом массиве я считаю,
[36:58.760 --> 37:05.420]  что написано только глубины. Я забываю про вершины, я здесь написал только массив глубин. А дальше,
[37:05.420 --> 37:13.120]  если я узнаю позицию, ну, дальше по позиции, и я знаю, что было в этой позиции исходного массива,
[37:13.120 --> 37:17.700]  значит я могу восстанить вершинку. Если я здесь нахожу минимум и где он находится, то я знаю,
[37:17.700 --> 37:23.080]  какая вершина ему соответствует. Я перешел к постановке. Задача такая. У меня просто есть
[37:23.080 --> 37:27.400]  массив глубин. Мне нужно здесь искать минимум на отрезке, ну и узнавать, где он. Если я узнаю,
[37:27.400 --> 37:31.400]  где он, то я знаю, какая вершина ему соответственно вейлером обходит, значит я знаю LCA.
[37:31.400 --> 37:43.400]  Смотрите, вот я в этом массиве буду находить не только минимум, но и позицию минимума.
[37:43.400 --> 37:56.400]  То есть я нахожу, где находится минимальная глубина d, точнее значение, но еще и позицию, где находится i, ну индекс.
[37:56.400 --> 38:08.400]  То есть я расширяю задачу, мне нужно будет на отрезке искать минимум и его позицию.
[38:12.400 --> 38:17.400]  Мне кажется, что такая задача была то ли в листочке, то ли в контесте на спарстейбл,
[38:17.400 --> 38:24.400]  что если нужно не только минимум находить, но и где он находится, можно просто внутри спарстейбла хранить минимум и его позицию.
[38:24.400 --> 38:32.400]  Тогда если вы знаете, ну как обычно, если у вас есть там 2 в бетой, 2 в бетой размеры блоков,
[38:32.400 --> 38:37.400]  если вы знаете минимум и его позицию здесь, то где минимум и его позиция во всем массиве?
[38:37.400 --> 38:43.400]  Ну понятно, либо это, либо это. Вот тут тоже самое будет сейчас.
[38:43.400 --> 38:48.400]  Ну так вот, давайте вернусь сюда.
[38:48.400 --> 38:57.400]  Каждый блок у меня, каждый блок как массив глубин, характеризуется числом х, начальным числом, и маской.
[38:57.400 --> 39:03.400]  Причем масок всего, возможных масок 2 в степени k-1, что если оно специально такое подобрано,
[39:03.400 --> 39:10.400]  k специально так подобрано, что это было бы от корни из n.
[39:10.400 --> 39:14.400]  Ну короче, сильно меньше н что-то.
[39:14.400 --> 39:22.400]  Хорошо. То есть получается, что всего различных блоков, ну вот с поправкой на x,
[39:22.400 --> 39:27.400]  по факту x это какое-то смещение. Вот у меня по факту блок определяется однозначно маской
[39:27.400 --> 39:31.400]  и каким-то смещением, что все элементы ко всем элементам надо прибавить x.
[39:31.400 --> 39:39.400]  Вот, если x считать нулевым, то по факту у меня всего различных блоков вот столько, по количеству масок.
[39:39.400 --> 39:44.400]  То есть у меня есть какие-то аддитивные сдвиги, в смысле ко всем элементам надо прибавить плюс x.
[39:44.400 --> 39:47.400]  То есть можно сказать, что всего блоков, давайте напишу так,
[39:47.400 --> 39:53.400]  всего нормализованных блоков, то есть тех у которых x0,
[39:53.400 --> 40:04.400]  нормализованных блоков, вот корни из n, различных.
[40:04.400 --> 40:09.400]  Всего различных блоков мало.
[40:09.400 --> 40:12.400]  Давайте тогда предпочитаем всевозможные ответы для всех блоков.
[40:12.400 --> 40:16.400]  Ну а раз их мало, давайте их все перед тем, как отвечать на запросы,
[40:16.400 --> 40:20.400]  давайте их все возможные все переберем, вот все корни из n их переберем,
[40:20.400 --> 40:26.400]  и на всех возможных их подотресках найдем минимум.
[40:26.400 --> 40:33.400]  Поскольку их мало и они маленькой длины, то можно за время типа корень из n умножить на лог квадрат
[40:33.400 --> 40:52.400]  для каждого блока и для каждого подотреска внутри блока предпочитать ответ, предпочитать минимум на отрезке.
[40:52.400 --> 41:18.400]  Значит, за корень из n на лог квадрат n предпочитаем минимумы на всех подотресках
[41:18.400 --> 41:32.400]  всех нормализованных блоков.
[41:32.400 --> 41:37.400]  Потому что отрезков, подотресков как квадрат, внутри отрезка.
[41:37.400 --> 41:45.400]  То есть я рассматриваю блок длины k, в нем k квадрат подотресков.
[41:45.400 --> 41:49.400]  То есть таким образом вот за такое время я могу создать такой массив какой-нибудь,
[41:49.400 --> 41:59.400]  дп от маски и lr, это информация о том, чему равен минимум в блоке,
[41:59.400 --> 42:05.400]  если блок характеризуется маской маск, и минимум нужен на отрезке с lpr.
[42:05.400 --> 42:11.400]  То есть я взял блок, взял подотреск с lpr, и дп хранит мне минимум.
[42:11.400 --> 42:14.400]  Ну точнее не только минимум, но еще и позицию.
[42:14.400 --> 42:18.400]  Раз я расширил задачу и хочу знать не только минимум, но и его позицию,
[42:18.400 --> 42:22.400]  то как раз дп хранит мне позицию в этом массиве и чему он равен.
[42:22.400 --> 42:26.400]  И так для всех возможных блоков вообще.
[42:26.400 --> 42:31.400]  Ну вот, все, а дальше идея такая, смотрите.
[42:31.400 --> 42:34.400]  То есть по факту у меня вот здесь блоков-то очень много.
[42:34.400 --> 42:38.400]  Блоков у меня примерно n под директным алгорифом, то есть блоков самих по себе много,
[42:38.400 --> 42:43.400]  а блоков из них различных после нормализации мало.
[42:43.400 --> 42:50.400]  Значит, тогда что я сделаю? Давайте я покажу, как находить минимум на отрезке.
[42:50.400 --> 42:54.400]  Пусть у меня есть много блоков.
[42:54.400 --> 42:59.400]  Значит, как найти минимум на отрезке, скажем, вот отсюда, вот до сюда?
[42:59.400 --> 43:02.400]  От i до j.
[43:02.400 --> 43:06.400]  Ну смотрите, я, во-первых, могу взять вот этот блок
[43:06.400 --> 43:10.400]  и найти минимум на этом отрезке, то есть на суффиксе.
[43:10.400 --> 43:15.400]  Это понятно как. То есть я знаю, что это за блок, я знаю, какая у него маска,
[43:15.400 --> 43:18.400]  и я знаю, насколько он недонормализован.
[43:18.400 --> 43:21.400]  То есть если здесь стоит x, то по факту это нормализованный блок, плюс x.
[43:21.400 --> 43:27.400]  Но если я все эти числа знаю, то я же предпочитал минимум на этом отрезке для всех блоков.
[43:27.400 --> 43:31.400]  И дальше просто плюс x надо будет добавить, и все.
[43:31.400 --> 43:35.400]  То же самое здесь. Я рассматриваю блок, где лежит крайняя граница моя правая,
[43:35.400 --> 43:38.400]  мне нужно минимум вот на этом отрезке. То же самое.
[43:38.400 --> 43:41.400]  Я знаю, что это за блок, я знаю, какая маска ему соответствует,
[43:41.400 --> 43:45.400]  я знаю, насколько он сдвинут, какой здесь стоит y.
[43:45.400 --> 43:49.400]  Но поскольку у меня для всех нормализованных блоков я знаю, где лежит минимум,
[43:49.400 --> 43:54.400]  то минимум здесь лежит тут же, только он на y еще увеличен.
[43:54.400 --> 43:59.400]  Потому что там ко всем элементам прибавлен один тот же y.
[43:59.400 --> 44:02.400]  Получается, что я знаю минимум на этом кусочке и на этом кусочке.
[44:02.400 --> 44:05.400]  А дальше у меня подряд несколько блоков.
[44:05.400 --> 44:09.400]  Мне нужно минимум еще вот здесь взять.
[44:09.400 --> 44:12.400]  Но это сделаю опять спарстейблом.
[44:12.400 --> 44:17.400]  Но спарстейблом уже не на n элементах, а на n делить на k элементах.
[44:17.400 --> 44:21.400]  Теперь я блоки воспринимаю, чтобы найти минимум на таком отрезке,
[44:21.400 --> 44:27.400]  я блоки воспринимаю неделимыми и строю на них спарстейбл.
[44:28.400 --> 44:33.400]  Дальше я строю спарстейбл на неделимых блоках.
[44:36.400 --> 44:41.400]  Опять же, я на каждом блоке сначала независимо предпочитал минимум и где он находится.
[44:41.400 --> 44:47.400]  Затем сжал все эти блоки в одно число, минимум и где он находится.
[44:47.400 --> 44:52.400]  А дальше на всем этом построил спарстейбл, чтобы находить минимум на отрезке между блоками.
[44:52.400 --> 44:57.400]  И за сколько работает тогда спарстейбл? Он строится за время вот такое.
[44:57.400 --> 44:59.400]  Давайте просто Бизону пишу.
[44:59.400 --> 45:03.400]  n делить на k он может на логариф, n делить на k.
[45:03.400 --> 45:08.400]  Потому что у меня вот столько блоков, и спарстейбл получается строится вот в такое время.
[45:08.400 --> 45:11.400]  Но если подставить, то получится n просто.
[45:11.400 --> 45:16.400]  Ну что это такое? Это n делить на k лог n,
[45:16.400 --> 45:20.400]  минус там что-то там, то есть минус n делить на k лог k.
[45:20.400 --> 45:25.400]  Но минус я отброшу, что будет не больше, чем n делить на k лог n.
[45:25.400 --> 45:27.400]  Но k это как раз логарифм пополам.
[45:27.400 --> 45:31.400]  Поэтому здесь будет 2n.
[45:34.400 --> 45:39.400]  Потому что k это половина логарифма, логарифмы сократились, половина вылезла в числитель.
[45:39.400 --> 45:41.400]  Будет 2n.
[45:43.400 --> 45:47.400]  Получается, что время необходимое для построения спарстейбла на вот этих блоках,
[45:47.400 --> 45:50.400]  если я блоки сжал до одной точки,
[45:50.400 --> 45:54.400]  то мне нужно всего лишь линейное время, чтобы построить спарстейбл.
[45:55.400 --> 45:58.400]  И значит я на запрос отвечаю за единичку.
[46:01.400 --> 46:05.400]  То есть у меня получился алгоритм такой, у меня будет линейный предподсчет,
[46:05.400 --> 46:08.400]  и единичка на запрос.
[46:08.400 --> 46:12.400]  То есть пафос такой, что я вот в этой симптомике перешел вот к этой,
[46:12.400 --> 46:14.400]  и дальше вот к этой.
[46:14.400 --> 46:18.400]  Ну где n это то же самое, что n маленькое.
[46:24.400 --> 46:26.400]  Значит еще раз, почему у меня получилась такая симптомика.
[46:26.400 --> 46:28.400]  Смотрите, давайте сначала предподсчет.
[46:28.400 --> 46:31.400]  Суммарно, что входит в предподсчет до того, как я начинаю отвечать на запросы,
[46:31.400 --> 46:33.400]  и что я делаю с деревом.
[46:33.400 --> 46:38.400]  Значит сначала я сделал эйлеров обход, записал массив глубин,
[46:38.400 --> 46:41.400]  посплитил его на блоке длины k,
[46:41.400 --> 46:46.400]  и понял, что у меня нормализованных блоков всего вот примерно корень и z.
[46:46.400 --> 46:49.400]  То есть теперь у меня каждый блок моего вот этого вот массива,
[46:49.400 --> 46:53.400]  это какой-то один из нормализованных, плюс аддитивный язык, плюс x.
[46:53.400 --> 46:56.400]  То есть все элементы надо увеличить на какой-то x.
[46:56.400 --> 46:58.400]  Хорошо, значит дальше.
[46:58.400 --> 47:02.400]  Я для каждого возможного нормализованного блока, коих корень и z,
[47:02.400 --> 47:05.400]  и для каждого подотреска внутри этого блока,
[47:05.400 --> 47:08.400]  предподсчитываю минимум, где он тут находится.
[47:08.400 --> 47:11.400]  То есть буквально запоминаю для каждого возможного нормализованного блока,
[47:11.400 --> 47:14.400]  для каждого подотреска lr, где находится минимум,
[47:14.400 --> 47:16.400]  его значение и где он находится.
[47:16.400 --> 47:19.400]  Это вот за такое время, что, понятно, делаем меньше, чем у от n.
[47:19.400 --> 47:22.400]  На корень данного угла меньше, чем у от n.
[47:22.400 --> 47:24.400]  Это первый шаг.
[47:24.400 --> 47:29.400]  Второй шаг предподсчета – это построение спарстейбла на сжатых блоках.
[47:29.400 --> 47:33.400]  То есть теперь я в каждом блоке нахожу минимум.
[47:34.400 --> 47:36.400]  Да, вот там не знаю какой это там,
[47:36.400 --> 47:39.400]  минимум 1, минимум 2, минимум 3 и так далее.
[47:39.400 --> 47:42.400]  И дальше на вот этих минимумах строю спарстейбл.
[47:42.400 --> 47:45.400]  Который строится вот за такое время,
[47:45.400 --> 47:47.400]  за n делить на k, log n делить на k,
[47:47.400 --> 47:49.400]  потому что у меня вот столько блоков,
[47:49.400 --> 47:51.400]  и спарстейбл как раз строится за количество элементов,
[47:51.400 --> 47:53.400]  множество логарифм этого количества.
[47:53.400 --> 47:56.400]  Это будет опять-таки у от n.
[47:56.400 --> 48:00.400]  Получается, я за линейное время еще вот такой спарстейбл на этих м-ках построил.
[48:00.400 --> 48:02.400]  Все, предподсчет закончился.
[48:02.400 --> 48:05.400]  Такой двухфазный, сначала нормализованные блоки,
[48:05.400 --> 48:08.400]  затем спарстейбл на настоящих блоках.
[48:08.400 --> 48:11.400]  Это вот линейное время на предподсчет.
[48:11.400 --> 48:13.400]  Теперь, чтобы давить на запрос,
[48:13.400 --> 48:16.400]  я делаю следующее, в общем случае.
[48:16.400 --> 48:19.400]  Мне нужно минимум на отрезке между i и j.
[48:19.400 --> 48:21.400]  Я нахожу минимум вот здесь, вот как?
[48:21.400 --> 48:24.400]  Обращаюсь к dp-шке, потому что я знаю, что это за блок,
[48:24.400 --> 48:26.400]  я знаю, как его нормализовать,
[48:26.400 --> 48:28.400]  мне нужно вычесть x из всех элементов.
[48:28.400 --> 48:30.400]  Значит, я знаю маску этого блока.
[48:30.400 --> 48:32.400]  Я знаю, как отчитан минимум вот на этом отрезке.
[48:32.400 --> 48:36.400]  Потому что на всех подотресках каждого нормализованного блока я знаю ответ.
[48:36.400 --> 48:38.400]  То же самое здесь.
[48:38.400 --> 48:40.400]  Это какой-то подотрезок нормализованного отрезка,
[48:40.400 --> 48:43.400]  я знаю минимум здесь и где он лежит.
[48:43.400 --> 48:46.400]  А дальше мне нужно взять некий отрезок блоков
[48:46.400 --> 48:48.400]  и на нем найти минимум.
[48:48.400 --> 48:50.400]  Но это запрос к спарстейблу,
[48:50.400 --> 48:52.400]  который тоже за единицу работает.
[48:52.400 --> 48:56.400]  Вот отсюда получается как раз единичка на каждый запрос.
[48:57.400 --> 48:58.400]  Вот.
[48:58.400 --> 49:00.400]  Такой прикол.
[49:04.400 --> 49:05.400]  Так.
[49:05.400 --> 49:07.400]  Вопросы есть?
[49:07.400 --> 49:09.400]  Тогда давайте пережив.
[49:09.400 --> 49:11.400]  Чуть-чуть, пять минуточек.
[49:11.400 --> 49:13.400]  Дальше пойдем.
[49:14.400 --> 49:16.400]  Давайте дальше.
[49:16.400 --> 49:19.400]  Смотрите, я сейчас вот эту конструкцию хочу обобщить
[49:19.400 --> 49:23.400]  и приложить ее к старой нашей задаче, так называемой RMQ.
[49:23.400 --> 49:25.400]  Именно.
[49:25.400 --> 49:29.400]  Range Minimum Query.
[49:32.400 --> 49:33.400]  Вот эта задача,
[49:33.400 --> 49:35.400]  Промиум на статистическом уровне.
[49:35.400 --> 49:37.400]  И вот эта задача,
[49:37.400 --> 49:39.400]  Промиум на статистическом уровне.
[49:39.400 --> 49:41.400]  И вот эта задача,
[49:41.400 --> 49:43.400]  Промиум на статистическом уровне.
[49:43.400 --> 49:45.400]  И вот эта задача,
[49:45.400 --> 49:47.400]  Промиум на статистическом массиве.
[49:47.400 --> 49:49.400]  То есть есть у меня массив какой-то,
[49:49.400 --> 49:51.400]  а1, а2 и так далее, аn.
[49:51.400 --> 49:53.400]  Он не меняется.
[49:53.400 --> 49:55.400]  И поступают только запросы.
[49:55.400 --> 49:57.400]  Найдите, пожалуйста, минимум на отрезке.
[49:59.400 --> 50:00.400]  Вот.
[50:00.400 --> 50:02.400]  Это то, что мы решали спарстейблом
[50:02.400 --> 50:04.400]  за n log n предпочет и единичку на запрос.
[50:04.400 --> 50:06.400]  Теперь, вот вооружившись этим аппаратом
[50:06.400 --> 50:08.400]  с Фарах Колтона,
[50:08.400 --> 50:10.400]  можно решить ее тоже
[50:10.400 --> 50:12.400]  за линейный предпочет и единицу на запрос.
[50:13.400 --> 50:15.400]  То есть раньше мы имели только
[50:15.400 --> 50:17.400]  за n log n предпочета.
[50:17.400 --> 50:19.400]  Теперь можно сделать за линейный предпочет.
[50:19.400 --> 50:21.400]  Значит, решение-то будет такое.
[50:21.400 --> 50:23.400]  На, давайте, алгоритм будет такой.
[50:23.400 --> 50:25.400]  Значит, давайте мы
[50:25.400 --> 50:27.400]  построим
[50:27.400 --> 50:29.400]  дикартово дерево
[50:34.400 --> 50:37.400]  на точках и запятая аито.
[50:38.400 --> 50:40.400]  То есть у меня ключами
[50:40.400 --> 50:42.400]  будут выступать просто индексы,
[50:42.400 --> 50:44.400]  а приоритетами ашки.
[50:44.400 --> 50:46.400]  Вот те самые значения а.
[50:50.400 --> 50:52.400]  Вот.
[50:54.400 --> 50:56.400]  Ну, еще раз, да, то есть
[50:56.400 --> 50:58.400]  по умолчанию в дикартовом дереве,
[50:58.400 --> 51:00.400]  ну, в алгоритме построения
[51:00.400 --> 51:02.400]  мы брали приоритеты случайными.
[51:02.400 --> 51:04.400]  А вот здесь я не беру случайные,
[51:04.400 --> 51:06.400]  беру вот ровно те, которые мне нужны.
[51:06.400 --> 51:08.400]  Значит, с одной стороны, это плохо тем,
[51:08.400 --> 51:10.400]  что у меня тогда глубина будет не алгоритмическая,
[51:10.400 --> 51:12.400]  а произвольная какая-то.
[51:12.400 --> 51:14.400]  Ну, мне тут это и не важно, мне глубина этого дерева не важна.
[51:14.400 --> 51:16.400]  Как, собственно, и в предыдущей задаче,
[51:16.400 --> 51:18.400]  я про глубину дерева нигде особо не рассуждал.
[51:18.400 --> 51:20.400]  Вот.
[51:20.400 --> 51:22.400]  Ну, хорошо, построили такое дикартово дерево.
[51:22.400 --> 51:24.400]  Мы это вроде умеем делать, у меня ключи отсортированы
[51:24.400 --> 51:26.400]  по i, то есть по ключам.
[51:26.400 --> 51:28.400]  Тогда мы знаем, что это можно сделать
[51:28.400 --> 51:30.400]  за линейное время. Вот это можно сделать
[51:30.400 --> 51:32.400]  за o от n. Там просто хранить
[51:32.400 --> 51:34.400]  текущее дикартово дерево,
[51:34.400 --> 51:36.400]  хранить вот эту текущую правую веточку,
[51:36.400 --> 51:38.400]  самую ветку, идущую направо, в стеке.
[51:38.400 --> 51:40.400]  И тогда, когда приходит новая точка,
[51:40.400 --> 51:42.400]  мне нужно несколько последних элементов из стека удалить,
[51:42.400 --> 51:44.400]  а последнюю добавить.
[51:44.400 --> 51:46.400]  И вот так вот перенаправить указатель.
[51:46.400 --> 51:48.400]  Разбирали когда-то такое.
[51:48.400 --> 51:50.400]  Что может дикартово дерево построить за линию,
[51:50.400 --> 51:52.400]  если ключи отсортированы. А это у нас так и есть.
[51:52.400 --> 51:54.400]  Вот. Ну и все.
[51:54.400 --> 51:56.400]  А дальше тут ожидается следующее,
[51:56.400 --> 51:58.400]  что чтобы найти минимум на отрезке
[51:58.400 --> 52:00.400]  с l по r,
[52:00.400 --> 52:02.400]  мне нужно просто взять lca вот этих вот вершин,
[52:02.400 --> 52:04.400]  которые соответствуют этим элементам.
[52:04.400 --> 52:06.400]  И это и будет минимум.
[52:06.400 --> 52:08.400]  Ну, то есть, значит, если
[52:08.400 --> 52:10.400]  там m,
[52:10.400 --> 52:12.400]  am,
[52:12.400 --> 52:14.400]  это есть lca,
[52:14.400 --> 52:16.400]  вершин
[52:16.400 --> 52:18.400]  lal,
[52:18.400 --> 52:20.400]  prar,
[52:20.400 --> 52:22.400]  то
[52:22.400 --> 52:24.400]  am-то это как раз
[52:24.400 --> 52:26.400]  минимум на отрезке с l по r.
[52:26.400 --> 52:28.400]  Значит, am-то это минимум среди чисел
[52:28.400 --> 52:30.400]  с al-того
[52:30.400 --> 52:32.400]  по ar-того.
[52:38.400 --> 52:40.400]  Вот.
[52:40.400 --> 52:42.400]  То есть, чтобы найти минимум,
[52:42.400 --> 52:44.400]  достаточно найти lca. То есть, мы свели задачу
[52:44.400 --> 52:46.400]  поиска минимума
[52:46.400 --> 52:48.400]  к задаче поиска lca, а lca мы искать умеем.
[52:48.400 --> 52:50.400]  За быстро.
[52:50.400 --> 52:52.400]  За линией предпочета, единичка на запрос.
[52:52.400 --> 52:54.400]  Значит, почему вот это верно? Почему
[52:54.400 --> 52:56.400]  чтобы найти минимум, достаточно найти lca?
[52:56.400 --> 52:58.400]  Ну, давайте
[52:58.400 --> 53:00.400]  картинку нарисую. Вот пусть я нашел lca.
[53:00.400 --> 53:02.400]  Вот, m, am.
[53:02.400 --> 53:04.400]  Это lca вот этих двух вершин.
[53:04.400 --> 53:06.400]  Ну, поскольку это lca,
[53:06.400 --> 53:08.400]  во-первых, можно сказать сразу, что
[53:08.400 --> 53:10.400]  тогда l и r лежат
[53:10.400 --> 53:12.400]  по разные стороны
[53:12.400 --> 53:14.400]  от этой точки.
[53:14.400 --> 53:16.400]  Потому что, ну, там, скажем, если бы они лежали оба
[53:16.400 --> 53:18.400]  в левом поддереве, то это какой-то фиговый lca,
[53:18.400 --> 53:20.400]  потому что эта штука тоже тогда их общий корень,
[53:20.400 --> 53:22.400]  общий предок.
[53:22.400 --> 53:24.400]  Если обе вот эти вершинки лежат слева,
[53:24.400 --> 53:26.400]  то эта вершина тоже общий предок,
[53:26.400 --> 53:28.400]  но при этом более низкий.
[53:28.400 --> 53:30.400]  Значит, это неверно. Получается, что у меня l и r
[53:30.400 --> 53:32.400]  лежат по разные стороны.
[53:32.400 --> 53:34.400]  То есть где-то вот здесь вот l,
[53:34.400 --> 53:36.400]  где-то вот здесь вот r.
[53:36.400 --> 53:38.400]  То есть тогда действительно понятно,
[53:38.400 --> 53:40.400]  что m на отрезке между ними лежит,
[53:40.400 --> 53:42.400]  по крайней мере.
[53:42.400 --> 53:44.400]  Ну и все. А дальше
[53:44.400 --> 53:46.400]  пользуемся тем, что
[53:46.400 --> 53:48.400]  декартовое дерево – это куча
[53:48.400 --> 53:50.400]  по приоритетам. Это значит, что
[53:50.400 --> 53:52.400]  вот это am меньше, чем
[53:52.400 --> 53:54.400]  все возможные приоритеты в поддереве.
[53:54.400 --> 53:56.400]  В частности, здесь есть все
[53:56.400 --> 53:58.400]  элементы от l до r.
[54:00.400 --> 54:02.400]  Значит, am –
[54:02.400 --> 54:04.400]  это минимальность среди элементов,
[54:04.400 --> 54:06.400]  в частности, с alt по ar.
[54:06.400 --> 54:08.400]  Там есть еще какие-то, возможно,
[54:08.400 --> 54:10.400]  туда идущие, туда идущие.
[54:10.400 --> 54:12.400]  Такое, что тоже am меньше, чем все они.
[54:12.400 --> 54:14.400]  Но, по крайней мере, все элементы
[54:14.400 --> 54:16.400]  с alt по r точно лежат в этом поддереве.
[54:16.400 --> 54:18.400]  И получается, что am-то
[54:18.400 --> 54:20.400]  это самые маленькие приоритеты
[54:20.400 --> 54:22.400]  среди всех вот этих на этом отрезке.
[54:22.400 --> 54:24.400]  Значит, am-то – это минимум.
[54:28.400 --> 54:30.400]  Окей?
[54:30.400 --> 54:32.400]  Ну вот, все.
[54:32.400 --> 54:34.400]  Значит, чтобы находить минимум на отрезке,
[54:34.400 --> 54:36.400]  в нашей старой задачке
[54:36.400 --> 54:38.400]  RMQ,
[54:38.400 --> 54:40.400]  нужно построить декартовое дерево
[54:40.400 --> 54:42.400]  за линию, потом
[54:42.400 --> 54:44.400]  за линейное время весь предпочет
[54:44.400 --> 54:46.400]  сделать, разбить это дерево,
[54:46.400 --> 54:48.400]  то есть аэрово обойти его,
[54:48.400 --> 54:50.400]  разбить на блоки, посчитать нормализованные блоки,
[54:50.400 --> 54:52.400]  построить sports table,
[54:52.400 --> 54:54.400]  ну а дальше просто
[54:54.400 --> 54:56.400]  там, как раньше,
[54:56.400 --> 54:58.400]  за единичку на запрос отвечать.
[55:00.400 --> 55:02.400]  Понятная идея?
[55:02.400 --> 55:04.400]  Ну все.
[55:04.400 --> 55:06.400]  Так, хорошо.
[55:06.400 --> 55:10.400]  Тогда с этим закончили.
[55:20.400 --> 55:22.400]  Все, тогда с LCA закончили.
[55:24.400 --> 55:26.400]  Давайте последний сюжет на сегодня
[55:26.400 --> 55:28.400]  это про
[55:28.400 --> 55:30.400]  изоморфизмы,
[55:30.400 --> 55:32.400]  изоморфизмы деревьев.
[55:38.400 --> 55:40.400]  Ну постепенно буду сюда подбираться.
[55:40.400 --> 55:42.400]  Сначала такое определение.
[55:42.400 --> 55:44.400]  Вершина V называется центроидом дерева,
[55:48.400 --> 55:50.400]  если после ее удаления
[55:50.400 --> 55:52.400]  все компоненты связанности
[55:52.400 --> 55:54.400]  имеют размер,
[55:54.400 --> 55:56.400]  как максимум, N пополам.
[55:56.400 --> 55:58.400]  Значит, если
[55:58.400 --> 56:00.400]  в графе после удаления
[56:00.400 --> 56:02.400]  вершинки V
[56:02.400 --> 56:04.400]  все компоненты связанности
[56:04.400 --> 56:06.400]  по размеру N пополам,
[56:06.400 --> 56:08.400]  то есть если в графе
[56:08.400 --> 56:10.400]  после удаления вершинки V
[56:10.400 --> 56:12.400]  связанности
[56:16.400 --> 56:18.400]  имеют размер
[56:18.400 --> 56:20.400]  не больше, чем N пополам.
[56:20.400 --> 56:22.400]  Ну, где N как обычное число вершин.
[56:30.400 --> 56:32.400]  Вот.
[56:32.400 --> 56:34.400]  То есть это такая вершина,
[56:34.400 --> 56:36.400]  что если ее из графа удалить,
[56:36.400 --> 56:38.400]  то все, что останется, разобьется
[56:38.400 --> 56:40.400]  и все компоненты маленькие, в том смысле,
[56:40.400 --> 56:42.400]  что они, по крайней мере, в два раза меньше,
[56:42.400 --> 56:44.400]  чем исходный граф.
[56:44.400 --> 56:46.400]  То есть не больше половины вершин
[56:46.400 --> 56:48.400]  каждый из них содержит.
[56:48.400 --> 56:50.400]  Вот. Это центроид.
[56:52.400 --> 56:54.400]  Утверждение...
[56:54.400 --> 56:56.400]  Давайте, наверное, без доказательства.
[56:56.400 --> 56:58.400]  Оно элементарное, но времени не остается,
[56:58.400 --> 57:00.400]  поэтому без доказательства.
[57:00.400 --> 57:02.400]  Утверждение...
[57:02.400 --> 57:04.400]  В любом дереве...
[57:08.400 --> 57:10.400]  Есть центроид...
[57:12.400 --> 57:14.400]  Причем...
[57:14.400 --> 57:16.400]  Значит, он либо единствен...
[57:18.400 --> 57:20.400]  То есть он всего один,
[57:20.400 --> 57:22.400]  всего одна вершина является центроидом.
[57:22.400 --> 57:24.400]  Либо их два,
[57:24.400 --> 57:26.400]  и они с одной ребром.
[57:26.400 --> 57:28.400]  Значит, либо их два,
[57:28.400 --> 57:30.400]  они с одной ребром.
[57:38.400 --> 57:40.400]  Ну вот, например,
[57:40.400 --> 57:42.400]  такую картинку можно рассмотреть.
[57:44.400 --> 57:46.400]  Вот. Если такое дерево нарисовать,
[57:46.400 --> 57:48.400]  то вот эти две штуки являются центроидами.
[57:48.400 --> 57:50.400]  Потому что всего вершин восемь.
[57:50.400 --> 57:52.400]  А если вот это удалить,
[57:52.400 --> 57:54.400]  то здесь будет...
[57:54.400 --> 57:56.400]  Ну, короче, любую из них удали,
[57:56.400 --> 57:58.400]  получится в одной компонент четыре,
[57:58.400 --> 58:00.400]  остальные даже еще меньше будут.
[58:00.400 --> 58:02.400]  Вот.
[58:02.400 --> 58:04.400]  Ну, либо он вообще один.
[58:04.400 --> 58:06.400]  Ну, вот это я доказывать не буду.
[58:06.400 --> 58:08.400]  Я докажу, что он есть.
[58:10.400 --> 58:12.400]  Алгоритм как его найти.
[58:18.400 --> 58:20.400]  Алгоритм как найти центроид очень простой.
[58:20.400 --> 58:22.400]  Значит, давайте запустимся как обычно.
[58:22.400 --> 58:24.400]  Давайте подвесим дерево за какую-нибудь вершинку
[58:24.400 --> 58:26.400]  произвольную, R.
[58:26.400 --> 58:28.400]  Запустим DFS.
[58:28.400 --> 58:30.400]  И давайте еще посчастливее.
[58:30.400 --> 58:32.400]  Ну, вот.
[58:32.400 --> 58:34.400]  И давайте еще посчитаем
[58:34.400 --> 58:36.400]  новую характеристику.
[58:36.400 --> 58:38.400]  Размер поддерева.
[58:38.400 --> 58:40.400]  Sub3 вот V.
[58:40.400 --> 58:42.400]  Это то, сколько вершин
[58:42.400 --> 58:44.400]  вот в этом поддереве V, включая V.
[58:46.400 --> 58:48.400]  Количество вершин в поддереве V.
[58:48.400 --> 58:50.400]  Количество вершин
[58:50.400 --> 58:52.400]  в поддереве V.
[58:54.400 --> 58:56.400]  Сколько вот здесь суммарных вершин.
[58:56.400 --> 58:58.400]  Значит, тогда понятно, что
[58:58.400 --> 59:00.400]  в корне, понятное дело,
[59:00.400 --> 59:02.400]  Sub3 вот R.
[59:02.400 --> 59:04.400]  Это просто N,
[59:04.400 --> 59:06.400]  потому что все вершины лежат
[59:06.400 --> 59:08.400]  в поддереве корня.
[59:08.400 --> 59:10.400]  И дальше, чтобы найти
[59:10.400 --> 59:12.400]  центроид,
[59:12.400 --> 59:14.400]  можно сделать следующее.
[59:14.400 --> 59:16.400]  Смотрите, вот давайте я встал в корень.
[59:16.400 --> 59:18.400]  Я знаю, что в корне
[59:18.400 --> 59:20.400]  Sub3 равен N.
[59:20.400 --> 59:22.400]  Дальше давайте переходить вниз.
[59:22.400 --> 59:24.400]  Если есть ребенок
[59:24.400 --> 59:26.400]  Sub3, у которого хотя бы N пополам.
[59:26.400 --> 59:28.400]  Если есть ребенок, у которого
[59:28.400 --> 59:30.400]  Sub3 хотя бы N пополам,
[59:30.400 --> 59:32.400]  то я в него перехожу.
[59:32.400 --> 59:34.400]  И так делаю дальше.
[59:34.400 --> 59:36.400]  Если у этой штуки есть куда спуститься,
[59:36.400 --> 59:38.400]  сохраняя свойство, что Sub3 хотя бы N пополам,
[59:38.400 --> 59:40.400]  то я спускаюсь.
[59:40.400 --> 59:42.400]  И так далее.
[59:42.400 --> 59:44.400]  Вот я так спускаюсь, спускаюсь.
[59:44.400 --> 59:46.400]  До тех пор, пока не обнаружится
[59:46.400 --> 59:48.400]  вершина, такая, что
[59:48.400 --> 59:50.400]  вот здесь, в ее поддереве,
[59:50.400 --> 59:52.400]  вершина хотя бы N пополам,
[59:52.400 --> 59:54.400]  но в каждом из поддеревьев
[59:54.400 --> 59:56.400]  для дочерних вершин
[59:56.400 --> 59:58.400]  там уже меньше, чем N пополам.
[59:58.400 --> 01:00:00.400]  То есть вот здесь вот суммарно хотя бы,
[01:00:00.400 --> 01:00:02.400]  а здесь меньше, чем N пополам.
[01:00:04.400 --> 01:00:06.400]  Тогда вот эта штука
[01:00:06.400 --> 01:00:08.400]  это центроид.
[01:00:12.400 --> 01:00:14.400]  Потому что
[01:00:14.400 --> 01:00:16.400]  какие появляются компоненты связанности
[01:00:16.400 --> 01:00:18.400]  после удаления этой вершинки С?
[01:00:18.400 --> 01:00:20.400]  Во-первых, все вот эти поддеревья,
[01:00:20.400 --> 01:00:22.400]  я знаю, что их размеры маленькие.
[01:00:22.400 --> 01:00:24.400]  Во-вторых, все остальное,
[01:00:24.400 --> 01:00:26.400]  но размер этой штуки
[01:00:26.400 --> 01:00:28.400]  не больше N пополам,
[01:00:28.400 --> 01:00:30.400]  потому что размер вот этой штуки хотя бы N пополам.
[01:00:30.400 --> 01:00:32.400]  А суммарно они N дают.
[01:00:32.400 --> 01:00:34.400]  Ну все, значит, это центроид.
[01:00:34.400 --> 01:00:36.400]  И того, получается, я встал в корень,
[01:00:36.400 --> 01:00:38.400]  ну понятно, что в корне
[01:00:38.400 --> 01:00:40.400]  у меня выполняется вот это вот свойство,
[01:00:40.400 --> 01:00:42.400]  что размер хотя бы N пополам.
[01:00:42.400 --> 01:00:44.400]  И дальше просто иду в любой сыновей,
[01:00:44.400 --> 01:00:46.400]  пока есть сын, размер которого хотя бы N пополам,
[01:00:46.400 --> 01:00:48.400]  я туда иду, спускаюсь,
[01:00:48.400 --> 01:00:50.400]  и вот этот вариант.
[01:00:50.400 --> 01:00:52.400]  В последний раз, когда это выполняется,
[01:00:52.400 --> 01:00:54.400]  это и есть центроид.
[01:00:54.400 --> 01:00:56.400]  Ну и можно доказать тогда,
[01:00:56.400 --> 01:00:58.400]  что второй обязательно это либо вот этот,
[01:00:58.400 --> 01:01:00.400]  либо его родитель,
[01:01:00.400 --> 01:01:02.400]  это просто,
[01:01:02.400 --> 01:01:04.400]  но давайте пропустим.
[01:01:18.400 --> 01:01:20.400]  Да.
[01:01:24.400 --> 01:01:26.400]  Да, да, да, все так.
[01:01:30.400 --> 01:01:32.400]  Вот.
[01:01:34.400 --> 01:01:36.400]  Да, что теперь хочу?
[01:01:36.400 --> 01:01:38.400]  Вот центроиды вели, смотрите,
[01:01:38.400 --> 01:01:40.400]  прикол в том, что в дереве
[01:01:40.400 --> 01:01:42.400]  центроид определен либо однозначно,
[01:01:42.400 --> 01:01:44.400]  либо есть два кандидата, есть две вершины,
[01:01:44.400 --> 01:01:46.400]  которые являются центроидами.
[01:01:46.400 --> 01:01:48.400]  Из аморфизма.
[01:01:48.400 --> 01:01:50.400]  Что это определение?
[01:01:50.400 --> 01:01:52.400]  Ну что такое вообще из аморфизм графов?
[01:01:52.400 --> 01:01:54.400]  Возможно вы знаете, но на всякий случай напомню.
[01:01:54.400 --> 01:01:56.400]  Пусть у меня есть два графа GH,
[01:02:00.400 --> 01:02:02.400]  значит тогда из аморфизм
[01:02:04.400 --> 01:02:06.400]  это такая функция из вершин одного графа
[01:02:06.400 --> 01:02:08.400]  в вершину другого,
[01:02:12.400 --> 01:02:14.400]  если выполняются два условия.
[01:02:14.400 --> 01:02:16.400]  Во-первых, феет объекция,
[01:02:18.400 --> 01:02:20.400]  во-вторых, она ребра
[01:02:20.400 --> 01:02:22.400]  переводит в ребра,
[01:02:22.400 --> 01:02:24.400]  а не ребра вне ребра.
[01:02:24.400 --> 01:02:26.400]  Да, давайте напишу так,
[01:02:26.400 --> 01:02:28.400]  что для любой пары УВ
[01:02:30.400 --> 01:02:32.400]  значит УВ
[01:02:32.400 --> 01:02:34.400]  это ребро графа
[01:02:34.400 --> 01:02:36.400]  Г,
[01:02:36.400 --> 01:02:38.400]  только если феет УФИ
[01:02:38.400 --> 01:02:40.400]  от В,
[01:02:40.400 --> 01:02:42.400]  это ребро графа H.
[01:02:44.400 --> 01:02:46.400]  А вот так.
[01:02:52.400 --> 01:02:54.400]  То есть произвольная пара вершин,
[01:02:54.400 --> 01:02:56.400]  давайте рассмотрим произвольную пару вершин УВ,
[01:02:56.400 --> 01:02:58.400]  в исходном графе это какая-то пара вершин УВ,
[01:02:58.400 --> 01:03:00.400]  в новом графе, после отображения
[01:03:00.400 --> 01:03:02.400]  фи, это пара фиу-фи-в.
[01:03:02.400 --> 01:03:04.400]  Отверждается, что
[01:03:04.400 --> 01:03:06.400]  точнее, мне нужно, чтобы эта пара была ребром,
[01:03:06.400 --> 01:03:08.400]  если только эта пара ребро в новом графе.
[01:03:08.400 --> 01:03:10.400]  Если это ребро, то это ребро,
[01:03:10.400 --> 01:03:12.400]  и наоборот, если это ребро, то это ребро.
[01:03:12.400 --> 01:03:14.400]  Тогда вот это изоморфизм.
[01:03:16.400 --> 01:03:18.400]  Но по сути, это просто перенумерация
[01:03:18.400 --> 01:03:20.400]  графа.
[01:03:20.400 --> 01:03:22.400]  Есть там какой-нибудь вот такой
[01:03:22.400 --> 01:03:24.400]  граф,
[01:03:24.400 --> 01:03:26.400]  где вершины как-то занумерованы.
[01:03:26.400 --> 01:03:28.400]  И есть другой граф, который там
[01:03:28.400 --> 01:03:30.400]  как-то по-другому нарисован,
[01:03:30.400 --> 01:03:32.400]  вершины как-то по-другому
[01:03:32.400 --> 01:03:34.400]  занумерованы,
[01:03:34.400 --> 01:03:36.400]  и спрашивается, это изоморфинная графа или нет.
[01:03:38.400 --> 01:03:40.400]  На маленьких картинках понятно,
[01:03:40.400 --> 01:03:42.400]  что это не изоморфинная графа,
[01:03:42.400 --> 01:03:44.400]  там можно вот это 1 отобразить в 3,
[01:03:44.400 --> 01:03:46.400]  3 в 2, ну и так далее.
[01:03:46.400 --> 01:03:48.400]  Можно сопоставить однозначные вершинки так,
[01:03:48.400 --> 01:03:50.400]  чтобы ребра сохранились,
[01:03:50.400 --> 01:03:52.400]  и ничего нового не появилось.
[01:03:52.400 --> 01:03:54.400]  Но в общем случае,
[01:03:54.400 --> 01:03:56.400]  если у вас есть два просто произвольных больших графа,
[01:03:56.400 --> 01:03:58.400]  и вас спрашивают, они изоморфинные или нет,
[01:03:58.400 --> 01:04:00.400]  то пока что
[01:04:00.400 --> 01:04:02.400]  никто быстро решать эту задачу не умеет.
[01:04:02.400 --> 01:04:04.400]  К сожалению.
[01:04:04.400 --> 01:04:06.400]  Там есть какие-то
[01:04:06.400 --> 01:04:08.400]  квазиполиномиальные алгоритмы,
[01:04:08.400 --> 01:04:10.400]  даже не N в степени log N,
[01:04:10.400 --> 01:04:12.400]  но это все равно сверхполином,
[01:04:12.400 --> 01:04:14.400]  это не N в степени константа даже,
[01:04:14.400 --> 01:04:16.400]  даже не N в пятый.
[01:04:16.400 --> 01:04:18.400]  Так что вообще говоря, в произвольном случае
[01:04:18.400 --> 01:04:20.400]  эта задача пока что считается трудной,
[01:04:20.400 --> 01:04:22.400]  про нее непонятно, насколько она простая,
[01:04:22.400 --> 01:04:24.400]  можно ли ее за полином разрешать.
[01:04:24.400 --> 01:04:26.400]  По двум графам понять, они изоморфны или нет.
[01:04:26.400 --> 01:04:28.400]  А про деревья это можно сделать
[01:04:28.400 --> 01:04:30.400]  и довольно просто.
[01:04:38.400 --> 01:04:40.400]  Вот.
[01:04:40.400 --> 01:04:42.400]  Хотим теперь два дерева проверить на изоморфность.
[01:04:42.400 --> 01:04:44.400]  Давайте начнем с корневых деревьев.
[01:04:48.400 --> 01:04:50.400]  Проверка корневых деревьев
[01:04:54.400 --> 01:04:56.400]  на изоморфность.
[01:05:08.400 --> 01:05:10.400]  Пока мне будет удобно жить в мире,
[01:05:10.400 --> 01:05:12.400]  что у меня фиксированы корни
[01:05:12.400 --> 01:05:14.400]  обоих деревьев
[01:05:14.400 --> 01:05:16.400]  и мне нужно чтобы корень
[01:05:16.400 --> 01:05:18.400]  пережило в корень, дети корни перешли в детей,
[01:05:18.400 --> 01:05:20.400]  ну и так далее.
[01:05:20.400 --> 01:05:22.400]  Вот две вот такие картинки.
[01:05:22.400 --> 01:05:24.400]  Мне нужно чтобы корень перешел в корень,
[01:05:24.400 --> 01:05:26.400]  дети в каком-то порядке пришли в детей,
[01:05:26.400 --> 01:05:28.400]  то есть у меня проблема в том,
[01:05:28.400 --> 01:05:30.400]  что у меня дети не зонумерованы,
[01:05:30.400 --> 01:05:32.400]  у меня есть список детей, корня.
[01:05:32.400 --> 01:05:34.400]  И здесь список детей, корня.
[01:05:34.400 --> 01:05:36.400]  Я не знаю, в какую именно порядку их нужно переставить,
[01:05:36.400 --> 01:05:41.400]  И вот вопрос, можно ли их так переставить? Если да, то как?
[01:05:41.400 --> 01:05:46.400]  Ну и так далее.
[01:05:46.400 --> 01:05:53.400]  Хорошо. Давайте сделаем очень амбициозную штуку.
[01:05:53.400 --> 01:05:59.400]  Давайте мы просто рассмотрим все возможные поддеревья любого дерева
[01:05:59.400 --> 01:06:02.400]  и захашируем их.
[01:06:02.400 --> 01:06:08.840]  В том смысле, что занумируем все поддеревья так, чтобы touching
[01:06:08.840 --> 01:06:13.400]  одинаковым поддеревьем, а разным разным.
[01:06:13.400 --> 01:06:15.940]  Мы хотим каждому подделеву поставить соответствую
[01:06:15.940 --> 01:06:20.140]  какое-то число c, такое, что, если поддеревье изоморфенное,
[01:06:20.140 --> 01:06:22.520]  то им соответственно одинаковые числа, а если не изоморфное,
[01:06:22.520 --> 01:06:26.860]  то разные. Определить класс эквалентности
[01:06:26.860 --> 01:06:30.440]  по изоморфизму в каком-то смысле.
[01:06:30.440 --> 01:06:36.440]  что я хочу сделать, чтобы каждое поддерево теперь ассоциировано было с числом.
[01:06:36.440 --> 01:06:40.440]  Ну хорошо. Давайте начнем с самых простых поддеревьев.
[01:06:40.440 --> 01:06:44.440]  С поддеревьев листа, то есть вершинки без детей.
[01:06:44.440 --> 01:06:48.440]  Вот если у вершин нет детей, то давайте для определенности скажем тогда,
[01:06:48.440 --> 01:06:55.440]  что это поддерево соответствует нулю. Ну или это самое простое дерево без детей.
[01:06:55.440 --> 01:07:00.440]  Просто одна вершина, один корень, одна точка.
[01:07:00.440 --> 01:07:05.440]  Ну давайте считать, что я запустил на моем дереве какой-то ДФС,
[01:07:05.440 --> 01:07:09.440]  какой-то обход, который вот так вот рекурсивно пытается всем поддеревьям
[01:07:09.440 --> 01:07:13.440]  назначить какой-то число, какой-то классик эволюционности.
[01:07:13.440 --> 01:07:19.440]  Давайте считать следующее, что вот есть вершина В, и для детей я уже знаю
[01:07:19.440 --> 01:07:25.440]  номера классов. Там не знаю, скажем, 0, 1, 3, 0, там еще что-нибудь,
[01:07:25.440 --> 01:07:28.440]  какой-нибудь 4, ну и так далее. Давайте так будет.
[01:07:28.440 --> 01:07:34.440]  То есть пусть я для детей, для дочерних поддеревьев уже вычислил номер класса.
[01:07:34.440 --> 01:07:38.440]  Теперь я хочу понять, какой номер класса будет у вот этого вот дерева,
[01:07:38.440 --> 01:07:44.440]  у вот этого вот всего дерева вот с этими поддеревьями.
[01:07:45.440 --> 01:07:53.440]  Вот. Ну идея здесь такая, что вот это поддерево однозначно характеризуется
[01:07:53.440 --> 01:07:57.440]  мультимножеством вот этих вот классов детей.
[01:07:57.440 --> 01:08:04.440]  То есть если я рассмотрю мультимножество 0, 1, 3, 0, 4,
[01:08:04.440 --> 01:08:10.440]  то два вот таких вот дерева изоморфны, только если у них равны вот эти вот мультимножества.
[01:08:10.440 --> 01:08:13.440]  Ну потому что понятно, детей можно как угодно между собой переставлять,
[01:08:13.440 --> 01:08:16.440]  от этого структура дерева не изменится.
[01:08:16.440 --> 01:08:19.440]  Но при этом понятно, скажем, что если у меня есть какое-нибудь другое поддерево,
[01:08:19.440 --> 01:08:26.440]  где написано 0, 1, 3, 0, 4, а скажем 0, 2, 3, 0, 4, то понятно, что они не изоморфны.
[01:08:26.440 --> 01:08:33.440]  Потому что, ну скажем, я обязан В отобразить на У, я обязан 0-ое отобразить на 0-ое,
[01:08:33.440 --> 01:08:35.440]  ну скажем, вот это на это или вот на это.
[01:08:35.440 --> 01:08:37.440]  Но второе я никуда не отображу.
[01:08:37.440 --> 01:08:41.440]  И если эти мультимножества отличаются, то понятно, что изоморфизма нет.
[01:08:41.440 --> 01:08:48.440]  Я не могу отобразить то, какое-то дерево будет обязательно без пары вот здесь вот.
[01:08:48.440 --> 01:08:52.440]  Поэтому получается, что как бы класс эквивалентности под дерево
[01:08:52.440 --> 01:08:58.440]  однозначно определен мультимножеством классов детей.
[01:08:58.440 --> 01:09:00.440]  Ну давайте вот это закодируем.
[01:09:00.440 --> 01:09:03.440]  Скажем, что вот это 5, новое число какое-то.
[01:09:03.440 --> 01:09:05.440]  И все.
[01:09:05.440 --> 01:09:07.440]  Вот.
[01:09:07.440 --> 01:09:10.440]  Значит мне нужно просто теперь кодировать мультимножество.
[01:09:10.440 --> 01:09:14.440]  Ну давайте я от мультимножества перейду просто к упорядоченным массивам.
[01:09:18.440 --> 01:09:20.440]  Просто посорчу.
[01:09:20.440 --> 01:09:24.440]  Тогда понятно, что мультимножества равны, только если их отсортированные версии равны.
[01:09:24.440 --> 01:09:30.440]  То есть я от мультимножества перехожу к упорядоченному массиву отсортированному.
[01:09:30.440 --> 01:09:36.440]  Ну и дальше просто говорю, что если у меня появился какой-то отсортированный массив,
[01:09:36.440 --> 01:09:38.440]  то я ставлю ему соответственно какое-то новое число.
[01:09:38.440 --> 01:09:45.440]  Если я такого еще не видел, то это новый класс эквивалентности с номером 5.
[01:09:45.440 --> 01:09:46.440]  И все.
[01:09:46.440 --> 01:09:51.440]  Вот так вот иду снизу вверх по дереву, определяю классы детей, сорчу.
[01:09:51.440 --> 01:09:53.440]  Смотрю, видел ли я такой класс где-то или нет.
[01:09:53.440 --> 01:09:55.440]  Если не видел, то это новый класс.
[01:09:55.440 --> 01:09:57.440]  Я ему присваиваю новый номер.
[01:09:57.440 --> 01:10:00.440]  И так у меня для каждой вершинки будет посчитан класс.
[01:10:05.440 --> 01:10:07.440]  Давайте код напишу.
[01:10:11.440 --> 01:10:16.440]  Во-первых, мне нужен будет какой-нибудь способ хранить все эти векторы.
[01:10:16.440 --> 01:10:22.440]  Давайте я скажу, что это будет какой-нибудь мап из векторов в int.
[01:10:27.440 --> 01:10:39.440]  Я хочу для каждого сортированного вектора хранить его номер в этой классификации.
[01:10:43.440 --> 01:10:46.440]  Дальше классов изначально 0.
[01:10:46.440 --> 01:10:49.440]  Как работает DFS от вершинки v?
[01:10:49.440 --> 01:10:54.440]  Он сначала заводит пустой список.
[01:10:55.440 --> 01:10:59.440]  Дальше проходится по детям.
[01:11:03.440 --> 01:11:07.440]  Запускает DFS от ребенка.
[01:11:07.440 --> 01:11:11.440]  В A добавляет класс ребенка.
[01:11:11.440 --> 01:11:15.440]  Какой-нибудь там C от tu.
[01:11:15.440 --> 01:11:25.440]  После этого в A валяются в каком-то порядке классы всех детей.
[01:11:25.440 --> 01:11:31.440]  Дальше я ассортирую по возрастанию.
[01:11:31.440 --> 01:11:37.440]  Теперь мне нужно сказать, что у меня появился новый класс к эвалентности, определяемый h.
[01:11:37.440 --> 01:11:41.440]  Если это A уже есть в num, то все хорошо.
[01:11:41.440 --> 01:11:43.440]  Тут нужно просто num отвернуть.
[01:11:43.440 --> 01:12:00.440]  А если A нет в num, то я говорю, что num от A это класс и класс увеличен на единичку.
[01:12:00.440 --> 01:12:04.440]  И после этого просто C от v это num от A.
[01:12:13.440 --> 01:12:22.440]  Еще раз, я запускаюсь в вершинке.
[01:12:22.440 --> 01:12:25.440]  Сначала спускаюсь в детей, узнаю у них классы.
[01:12:25.440 --> 01:12:28.440]  C от tu это номер класса эквивалентности для ребенка.
[01:12:28.440 --> 01:12:32.440]  Сваливаю классы всех детей в один список A.
[01:12:32.440 --> 01:12:35.440]  Дальше ассортирую по возрастанию.
[01:12:35.440 --> 01:12:39.440]  И говорю, что у меня появился новый класс эквивалентности, задаваемый вектором A.
[01:12:39.440 --> 01:12:41.440]  Дальше просто проверяю.
[01:12:41.440 --> 01:12:44.440]  Если его раньше не было в num, то есть я впервые встретил такой класс эквивалентности,
[01:12:44.440 --> 01:12:50.440]  то я его завожу, говорю, что num от A это новый класс эквивалентности, равный класс UCL.
[01:12:50.440 --> 01:12:53.440]  И все, в любом случае теперь у меня num от A это корректный номер класса.
[01:12:53.440 --> 01:12:59.440]  И я говорю, что класс вершинки это num от A просто.
[01:12:59.440 --> 01:13:19.440]  Ну и все, тогда алгоритм такой.
[01:13:19.440 --> 01:13:23.440]  У меня есть два дерева, я запускаю с DFS по вот этому вот,
[01:13:23.440 --> 01:13:25.440]  насчитываю здесь все классы эквивалентности.
[01:13:25.440 --> 01:13:27.440]  Потом запускаю DFS вот по этому дереву,
[01:13:27.440 --> 01:13:29.440]  и здесь тоже все классы эквивалентности.
[01:13:29.440 --> 01:13:32.440]  И в конце просто сравниваю, правда ли, что C вот здесь равен C вот здесь.
[01:13:32.440 --> 01:13:36.440]  Если они равны, то значит деревья изоморфны, если нет, то не изоморфны.
[01:13:36.440 --> 01:13:38.440]  Потому что как раз я их так занумеровал все,
[01:13:38.440 --> 01:13:41.440]  что изоморфным деревьям соответствует одинаковая класса,
[01:13:41.440 --> 01:13:46.440]  не изоморфным разные.
[01:13:46.440 --> 01:13:52.440]  Вот, значит, а сколько это работает?
[01:13:52.440 --> 01:13:54.440]  Еще раз?
[01:13:54.440 --> 01:13:56.440]  Да, да, да.
[01:13:56.440 --> 01:14:06.440]  Мапа num, она общая для обоих деревьев, да, это правда.
[01:14:06.440 --> 01:14:09.440]  Значит, а сколько работает?
[01:14:09.440 --> 01:14:18.440]  Я отужаю, что один вот такой DFS по всему дереву работает суммарно за n log n.
[01:14:18.440 --> 01:14:20.440]  Ну почему?
[01:14:20.440 --> 01:14:25.440]  Значит, давайте поймем.
[01:14:25.440 --> 01:14:28.440]  То есть тут на самом деле понятно, что какие-то сортировки, понятно,
[01:14:28.440 --> 01:14:30.440]  что это работает, за какой это работает.
[01:14:30.440 --> 01:14:35.440]  Тут на самом деле вопрос про то, как работают обращения к num
[01:14:35.440 --> 01:14:38.440]  в условиях того, что a это вектор, а не число.
[01:14:38.440 --> 01:14:42.440]  То есть у меня раньше скорее в мапах лежали какие-то числа,
[01:14:42.440 --> 01:14:45.440]  какие-то простые объекты, теперь вектор лежат.
[01:14:45.440 --> 01:14:48.440]  Ну тогда, соответственно, запрос к мапе будет работать не за логарифом,
[01:14:49.440 --> 01:14:52.440]  а за логарифом множество время сравнения.
[01:14:52.440 --> 01:14:56.440]  Потому что в мапе я как обычно как-то спускаюсь по дереву,
[01:14:56.440 --> 01:14:58.440]  у меня есть ключ, я сравню его с ключом в корне,
[01:14:58.440 --> 01:15:02.440]  если он больше иду туда, если меньше, то иду туда.
[01:15:02.440 --> 01:15:05.440]  Поэтому у меня на самом деле время запроса к мапе,
[01:15:05.440 --> 01:15:12.440]  оно пропорционально логарифму n умножить на время сравнения вектора с вектором.
[01:15:12.440 --> 01:15:16.440]  Ну понятно тогда, что время работы будет вот таким вот примерно.
[01:15:16.440 --> 01:15:22.440]  Лог n это глубина мапы, глубина дерева, в смысле структуры мои,
[01:15:22.440 --> 01:15:25.440]  красно-черного дерева, скажем.
[01:15:25.440 --> 01:15:28.440]  А a это по факту время работы сравнения,
[01:15:28.440 --> 01:15:31.440]  потому что если у вас есть вектор a, вы его сравните с другим,
[01:15:31.440 --> 01:15:34.440]  то время сравнения максимум вот такое.
[01:15:34.440 --> 01:15:39.440]  То есть у вас есть маленький вектор a и какой-то большой вектор b,
[01:15:39.440 --> 01:15:44.440]  ну понятно, чтобы их сравнить, вы все эти элементы сравниваете вот за столько,
[01:15:44.440 --> 01:15:47.440]  и однозначно понимаете, кто больше, кто меньше.
[01:15:47.440 --> 01:15:50.440]  Поэтому все вот эти вот запросы NUMATA работают вот за такую асимптотику.
[01:15:50.440 --> 01:15:53.440]  Ну каждый конкретно работает вот за столько.
[01:15:56.440 --> 01:15:58.440]  Вот дальше надо просто просуммировать все,
[01:15:58.440 --> 01:16:00.440]  мне нужно просуммировать по всем вершинкам,
[01:16:00.440 --> 01:16:02.440]  какая у меня будет асимптотика.
[01:16:02.440 --> 01:16:07.440]  У меня будет там линия от всяких тривиальных действий, типа рекурсии,
[01:16:07.440 --> 01:16:12.440]  потом у меня будет сумма по вершинам a log n,
[01:16:12.440 --> 01:16:14.440]  это из-за обращений к мапе,
[01:16:14.440 --> 01:16:18.440]  и плюс, видимо, a log a из-за сортировки,
[01:16:20.440 --> 01:16:23.440]  потому что здесь еще сортировка, которая работает за a log a.
[01:16:24.440 --> 01:16:26.440]  Ну понятно, что это доминируется этим,
[01:16:26.440 --> 01:16:30.440]  я могу это просто вычеркнуть, потому что логарифм N больше, чем логарифм A.
[01:16:30.440 --> 01:16:33.440]  Ну а сумма ашек, это как раз будет просто N,
[01:16:34.440 --> 01:16:39.440]  потому что это сумма количеств детей у всех вершин.
[01:16:42.440 --> 01:16:43.440]  Это просто N.
[01:16:44.440 --> 01:16:46.440]  Поэтому сумма N log N получилась.
[01:16:49.440 --> 01:16:50.440]  Ну как?
[01:16:54.440 --> 01:16:55.440]  Ну ладно.
[01:16:55.440 --> 01:16:57.440]  Вот, сначала был случай корневых деревьев.
[01:16:58.440 --> 01:17:00.440]  А что делать с некорневыми?
[01:17:03.440 --> 01:17:04.440]  Что?
[01:17:06.440 --> 01:17:08.440]  Ну произвольно не подойдет, да?
[01:17:08.440 --> 01:17:10.440]  Мне же нужно как бы угадать.
[01:17:10.440 --> 01:17:12.440]  Да, лучше центроид.
[01:17:12.440 --> 01:17:15.440]  Вот смотрите, не зря же мы центроиды ввели.
[01:17:15.440 --> 01:17:18.440]  Мы знаем, что у меня есть два дерева какие-то,
[01:17:18.440 --> 01:17:20.440]  то есть у них корни не обозначены,
[01:17:20.440 --> 01:17:23.440]  я не знаю, куда приходит каждая вершина.
[01:17:24.440 --> 01:17:26.440]  Точнее, я не знаю, что корень должен быть в корень,
[01:17:26.440 --> 01:17:27.440]  у меня нет корней.
[01:17:27.440 --> 01:17:29.440]  Ну давайте я переберу центроид.
[01:17:29.440 --> 01:17:32.440]  Я знаю, что их здесь максимум 2, а здесь максимум 2.
[01:17:32.440 --> 01:17:35.440]  Давайте я переберу центроид здесь и центроид здесь.
[01:17:36.440 --> 01:17:41.440]  Подвешу за них и скажу, что я ищу изоморфизм корневых деревьев,
[01:17:41.440 --> 01:17:44.440]  точнее проверяю наизоморфность два корневых дерева,
[01:17:45.440 --> 01:17:48.440]  где в первом корень это C1, в другом корень это C2.
[01:17:49.440 --> 01:17:50.440]  Вот, ну и все.
[01:17:50.440 --> 01:17:52.440]  Корневые я умею проверять наизоморфность.
[01:17:53.440 --> 01:17:55.440]  И понятно, что центроид обязан перейти в центроид.
[01:17:55.440 --> 01:17:57.440]  Я не знаю, в какой именно из двух,
[01:17:57.440 --> 01:17:59.440]  то есть здесь есть два центроида,
[01:17:59.440 --> 01:18:01.440]  я не знаю, в какой именно из двух.
[01:18:01.440 --> 01:18:03.440]  Давайте переберем, давайте угадаем,
[01:18:03.440 --> 01:18:05.440]  как образится вот этот чувак, в этого или в этого.
[01:18:05.440 --> 01:18:07.440]  Два варианта переберем.
[01:18:07.440 --> 01:18:09.440]  Если хотя бы в одном сработало,
[01:18:09.440 --> 01:18:12.440]  если нашелся изоморфизм, то значит деревья изоморфны.
[01:18:12.440 --> 01:18:15.440]  А если нет, то значит этот центроид некуда отображать,
[01:18:15.440 --> 01:18:17.440]  его невозможно отобразить в центроид,
[01:18:17.440 --> 01:18:18.440]  сохранив изоморфизм.
[01:18:18.440 --> 01:18:20.440]  Значит и вообще изоморфизма нет.
[01:18:20.440 --> 01:18:22.440]  Потому что понятно, что...
[01:18:22.440 --> 01:18:23.440]  Еще раз?
[01:18:26.440 --> 01:18:28.440]  Но если их два в обоих,
[01:18:28.440 --> 01:18:32.440]  если их по два в обоих деревьях, то наверное да.
[01:18:34.440 --> 01:18:37.440]  Сейчас, сейчас, погодите, склеить...
[01:18:40.440 --> 01:18:42.440]  Нет, я его все-таки не стал склеивать.
[01:18:42.440 --> 01:18:44.440]  Потому что...
[01:18:44.440 --> 01:18:47.440]  Ну то есть смотрите, если они разные какие-нибудь, да...
[01:18:50.440 --> 01:18:52.440]  То есть вот, смотрите,
[01:18:52.440 --> 01:18:55.440]  вот представьте, что у вас вот какая-то такая картинка,
[01:18:57.440 --> 01:18:59.440]  ну и там что-то вот здесь еще подвешено.
[01:18:59.440 --> 01:19:02.440]  Тогда если вы их склеите, то они станут изоморфны.
[01:19:02.440 --> 01:19:04.440]  А если не склеивать, то они изоморфны.
[01:19:04.440 --> 01:19:06.440]  Поэтому лучше не склеивать, мне кажется.
[01:19:08.440 --> 01:19:09.440]  Вот.
[01:19:09.440 --> 01:19:11.440]  Вопрос есть?
[01:19:13.440 --> 01:19:15.440]  Тогда все. Всем спасибо.
