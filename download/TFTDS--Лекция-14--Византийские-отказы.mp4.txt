[00:00.000 --> 00:10.000]  Итак, напомню, мы с вами уже два-три месяца говорим про определенные системы и говорим про них по двум причинам.
[00:10.000 --> 00:18.000]  Во-первых, нас интересует масштабируемость, мы хотим добавлять новые узлы, система должна расширяться и работать также эффективно и хранить и проводовать больше данных.
[00:18.000 --> 00:24.000]  Во-вторых, нам нужны узлы, все больше и больше, потому что мы хотим справляться со сбоями.
[00:24.000 --> 00:29.000]  И вот все эти три месяца мы работали с очень простыми сбоями.
[00:29.000 --> 00:38.000]  Мы работали с отказами узлов, когда узел просто выключается и больше не включается никогда, и не посылаете отправлять никакие сообщения в будущем.
[00:38.000 --> 00:41.000]  И мы с вами переживали рестарты узлов.
[00:41.000 --> 00:47.000]  Ну вот давайте для начала вспомним, с помощью каких инструментов мы справлялись с первой проблемой и с второй.
[00:47.000 --> 00:53.000]  Отказы узлов. С ними мы справлялись с помощью...
[00:53.000 --> 00:55.000]  с помощью кворумов.
[00:56.000 --> 01:01.000]  Вот мы никогда не требовали, чтобы для записи в систему должны обратить все узлы.
[01:01.000 --> 01:05.000]  Мы требовали доступность, ну скажем, большинства узлов.
[01:05.000 --> 01:09.000]  Если мы можем получить ответ от большинства, то мы делаем запись, мы подтверждаем ее клиенту.
[01:09.000 --> 01:15.000]  Когда мы читаем, мы снова читаем с большинства и мы знаем, что давайте их большинство пересеклись, по крайней мере, по одному узлу.
[01:15.000 --> 01:22.000]  И вот та реплика, которая была в пересечении, она про записанные данные сообщит.
[01:22.000 --> 01:27.000]  Ну, строго говоря, большинство узлов тут не обязательно. Мы говорили про системы кворумов.
[01:27.000 --> 01:32.000]  Про системы подножеств, такие, что любые два множества этой системы пересекались.
[01:32.000 --> 01:39.000]  И на лекции про Paxos Made Life мы с вами обсуждали, как можно сделать системы кворума более гибкими.
[01:39.000 --> 01:43.000]  Так, чтобы они содержали меньше, чем большинство узлов, но при этом давали нужные нам гарантии.
[01:43.000 --> 01:48.000]  Ну, там была еще история про доменный отказов, это, в общем, сложно повторять сейчас некогда.
[01:48.000 --> 01:50.000]  Это мы, наверное, понимаем хорошо.
[01:50.000 --> 01:55.000]  Вторая проблема, второй тип сбоя, с которым мы работали, это рестарты узлов.
[01:55.000 --> 01:59.000]  Ну, с рестартами там решение было даже не алгоритмическое, а скорее инженерное.
[01:59.000 --> 02:05.000]  Мы разделили наше состояние на персистентное и волатильное и сказали, что вторую часть состояния можно потерять.
[02:05.000 --> 02:12.000]  А вот первую часть состояния, персистентное состояние, нужно хранить отказу устойчивого на диске, на каком-то внешнем устройстве.
[02:12.000 --> 02:19.000]  Ну, и мы хранили его в каком виде? В виде LSM, то есть в виде базы данных или в виде просто голого райта хэтлога.
[02:19.000 --> 02:22.000]  Но на самом деле LSM в конце концов хранит в виде сортированных пайлов и тоже райта хэтлога,
[02:22.000 --> 02:28.000]  поэтому в конце концов все упирается в лог, куда мы записываем все наши мутации последовательно.
[02:28.000 --> 02:30.000]  Ну, и делаем все это аккуратно.
[02:30.000 --> 02:35.000]  На позапрошлом семинаре мы говорили про чексумы, про вообще как лог аккуратно вести.
[02:35.000 --> 02:39.000]  То есть мы с этими проблемами, с этими отказами умеем бороться.
[02:39.000 --> 02:42.000]  Но, конечно же, мы себя в чем-то здесь ограничивали.
[02:42.000 --> 02:48.000]  Мы ограничивали здесь мир, потому что мир может уломаться не только так.
[02:48.000 --> 02:52.000]  В мире у нас что может происходить? У нас могут происходить аппаратные ошибки, например,
[02:52.000 --> 02:58.000]  когда космический луч переворачивает бит в нашей планке памяти и дальше последствия плохо предсказуемы для нас.
[02:58.000 --> 03:01.000]  Диск может покарабтить данные, которые он хранит.
[03:01.000 --> 03:04.000]  Вы, как разработчик, можете совершить ошибку.
[03:04.000 --> 03:09.000]  Не знаю, в конце концов узел нашей системы может захватить злоумышленника,
[03:09.000 --> 03:11.000]  а может быть даже не один узел, а несколько узлов.
[03:11.000 --> 03:16.000]  И они будут вести себя как-то координированно и действовать против нас, против нашего алгоритма.
[03:17.000 --> 03:23.000]  Короче говоря, мы сегодня хотим обобщить модель отказов, с которой мы работаем.
[03:23.000 --> 03:26.000]  Мы сегодня хотим поговорить про византийский отказ.
[03:26.000 --> 03:50.000]  То есть мы хотим позволить сбойным узлам вести себя абсолютно произвольным образом.
[03:50.000 --> 03:53.000]  Но вот все, что мы можем себе вообразить, мы можем им позволить.
[03:54.000 --> 03:59.000]  То есть в частности они могут произвольно отступать под протокол, по разным причинам.
[03:59.000 --> 04:02.000]  Оборотной сбой, баг в программе, злоумышленник.
[04:02.000 --> 04:05.000]  Все это может послужить причиной такого поведения.
[04:05.000 --> 04:10.000]  И, разумеется, никакие наши алгоритмы к такому приспособлены не были.
[04:10.000 --> 04:14.000]  Но представим, что у нас есть алгоритм RAFT, и там лидер посылает...
[04:14.000 --> 04:20.000]  И там какой-то узел в любом состоянии получает сообщение append-entries из старшего терма.
[04:20.000 --> 04:23.000]  То есть он как будто бы думает, что с ним говорит лидер и говорит ему,
[04:23.000 --> 04:26.000]  реплицируя команды в свой лог, либо со три команды из своего лога.
[04:26.000 --> 04:30.000]  И если мы такое сообщение получаем, то мы переходим в терм этого лидера в будущий,
[04:30.000 --> 04:33.000]  и стираем в свои команды, например.
[04:33.000 --> 04:35.000]  Вот мы обязаны так делать.
[04:35.000 --> 04:39.000]  Если нам это сообщение отправил узел, который просто выдумал это сообщение,
[04:39.000 --> 04:42.000]  то, конечно же, наш алгоритм пострадает, наши данные будут потеряны.
[04:42.000 --> 04:45.000]  Ну, с multipax-ом то же самое, в общем-то, один и тот же алгоритм.
[04:45.000 --> 04:49.000]  Так что никакой надежды, что наши алгоритмы будут работать в такой модели отказов нет.
[04:49.000 --> 04:52.000]  Вот мы должны специально об этом позаботиться сегодня.
[04:52.000 --> 04:56.000]  И наша цель на сегодня даже не то, чтобы алгоритмы строить.
[04:56.000 --> 04:59.000]  Про алгоритмы мы будем говорить в следующие два занятия.
[04:59.000 --> 05:02.000]  Мы будем говорить про BFT и про алгоритмы биткоина.
[05:02.000 --> 05:05.000]  Это два очень разных алгоритма, но чтобы до них добраться,
[05:05.000 --> 05:09.000]  нужно в принципе понять, с помощью каких инструментов мы собираемся бороться
[05:09.000 --> 05:13.000]  вот с такими вот произвольными, очень сложными отказами.
[05:14.000 --> 05:17.000]  Но прежде чем с ними бороться и прежде чем говорить про инструменты,
[05:17.000 --> 05:23.000]  которые нам в этом помогут, давайте обсудим, почему вообще мы до сих пор
[05:23.000 --> 05:26.000]  игнорировали все эти проблемы.
[05:26.000 --> 05:28.000]  Привет, заходи.
[05:28.000 --> 05:32.000]  Почему мы игнорировали, не то чтобы мы совсем игнорировали,
[05:32.000 --> 05:37.000]  мы обсуждали немного аппаратные сбои, но давайте проговорим это еще раз.
[05:37.000 --> 05:42.000]  Вот все перечисленные проблемы, которые могут привести к нарушению поведения протокола,
[05:42.000 --> 05:44.000]  проведение узла.
[05:44.000 --> 05:50.000]  С аппаратными сбоями мы справляемся более-менее с помощью чексу на разных уровнях.
[05:50.000 --> 05:54.000]  Но мы чексу мы используем в планках памяти прямо.
[05:54.000 --> 05:57.000]  Мы используем чексу, мы когда храним что-то на диске, мы записываем чексу,
[05:57.000 --> 06:00.000]  потом поднимаем с диска и проверяем, что чексу мы все еще сходим,
[06:00.000 --> 06:02.000]  что диск не испортится в наши данные.
[06:02.000 --> 06:09.000]  И, конечно же, мы отправляем данные всей только если мы тоже их снабдили контрольной суммой.
[06:09.000 --> 06:14.000]  Все это позволяет нам, мы не можем защититься от аппаратных сбоев.
[06:14.000 --> 06:20.000]  У нас большие системы, там кластеры из тысяч десятков, тысяч сотен машин,
[06:20.000 --> 06:23.000]  и в таком масштабе даже самые редкие аппаратные сбои все равно проявляются.
[06:23.000 --> 06:29.000]  Так что наша задача здесь с помощью контрольных сумм не избавиться от ошибок,
[06:29.000 --> 06:31.000]  а локализовать ошибки.
[06:31.000 --> 06:37.000]  Вот если где-то ошибка произошла, то мы хотим максимально уменьшить ее радиус поражения.
[06:37.000 --> 06:40.000]  Вот будет очень печально, если мы запишем данные на диске,
[06:40.000 --> 06:45.000]  данные на диске испортятся, потом мы их поднимем и отправим снапшот нашего автомата в РСМ,
[06:45.000 --> 06:48.000]  и отправим его в другую машину, и другая машина его накатит, и все.
[06:48.000 --> 06:50.000]  После этого мы ни на что рассчитывать не можем.
[06:50.000 --> 06:53.000]  Мы хотим ошибку локализовать в пределах одной машины,
[06:53.000 --> 06:56.000]  ну или в пределах провода, чтобы она дальше никуда не распространялась.
[06:56.000 --> 07:01.000]  Так что вот с аппаратными сбоями мы в принципе живем.
[07:01.000 --> 07:04.000]  Другая причина – это багги в алгоритме.
[07:04.000 --> 07:06.000]  Ну это уже чуть хуже.
[07:06.000 --> 07:10.000]  То есть понятно, что вы можете придумать правильный алгоритм, вы можете его доказать,
[07:10.000 --> 07:12.000]  вы можете написать спецификацию, потом вы пишете код два года,
[07:12.000 --> 07:14.000]  и окажется, что в нем бага.
[07:14.000 --> 07:16.000]  Ну как с этим бороться, мы немного уже обсуждали,
[07:16.000 --> 07:21.000]  мы говорили, что, скажем, model checking вам не поможет здесь,
[07:21.000 --> 07:26.000]  и спецификация уже при реализации непосредственно, но поможет fault injection.
[07:26.000 --> 07:31.000]  Вот и fault injection может быть разного вида, он может быть в виде симулятора, как у нас,
[07:31.000 --> 07:36.000]  он может быть в виде внешнего фреймворка, как Jepson.
[07:36.000 --> 07:41.000]  Но тем не менее он все же нам не гарантирует, что все баги будут найдены.
[07:41.000 --> 07:46.000]  Он стремится увеличить покрытие графа состояния, но при этом ничего не гарантирует.
[07:46.000 --> 07:52.000]  Как же нам обходиться быть с багами в алгоритме, в реализации?
[07:52.000 --> 07:57.000]  Если баг в реализации приведет к тому, что наш протокол начнет действовать иначе,
[07:57.000 --> 08:02.000]  то он же бедно творит.
[08:02.000 --> 08:05.000]  Что делать?
[08:05.000 --> 08:10.000]  Ну, я бы сказал, что да, нужно просто добавлять,
[08:10.000 --> 08:12.000]  нужно постоянно проверять варианты.
[08:12.000 --> 08:15.000]  Опять же, нужно, чтобы если какое-то странное состояние,
[08:15.000 --> 08:20.000]  которое не должно было возникнуть, все же возникло, мы как можно раньше это заметили
[08:20.000 --> 08:23.000]  и как можно раньше упали.
[08:23.000 --> 08:27.000]  Вот неработающий узел гораздо лучше, чем узел, который работает неправильно.
[08:27.000 --> 08:32.000]  Но в случае с репликацией тут есть один нюанс очень печальный для нас.
[08:32.000 --> 08:36.000]  Вот если ошибка аппаратная, то, скорее всего, она произошла на отдельной машине.
[08:36.000 --> 08:40.000]  И мы с помощью контрольных сумм там ее можем блокализовать, машина выйдет из машины,
[08:40.000 --> 08:44.000]  откажется, забудет про все свои данные, скажет, что я больше не могу ничего делать,
[08:44.000 --> 08:46.000]  ничего обещать, там мультипаксы все.
[08:46.000 --> 08:50.000]  Но это одна машина, в конце концов, она готова пережить отказ этой машины.
[08:50.000 --> 08:56.000]  Но вот если у нас баг в нашем алгоритме репликации,
[08:56.000 --> 08:59.000]  в нашем алгоритме репликации, что паксы, что мультирафт,
[08:59.000 --> 09:03.000]  он существенно опирается на детерминизм реализации,
[09:03.000 --> 09:07.000]  то если у вас, вот, не знаю, процесс пакса, что мультирафта,
[09:07.000 --> 09:14.000]  то если у вас, вот, не знаю, процесс падает, процесс вашего РСМа падает и там пишет корку на диск,
[09:14.000 --> 09:17.000]  то, скорее всего, он падает на разных, на всех узлах,
[09:17.000 --> 09:20.000]  потому что все узлы проходят через детерминистическое состояние.
[09:20.000 --> 09:22.000]  То есть если у вас узлы падают, то они падают вместе.
[09:22.000 --> 09:27.000]  И это уже довольно печально, но, с другой стороны, они все еще не делают ничего плохого.
[09:27.000 --> 09:31.000]  Ничего хорошего тоже не делают, но, вот, по крайней мере, не вредят.
[09:31.000 --> 09:35.000]  Так что мы, да, действительно проверяем, делаем очень много проверок,
[09:35.000 --> 09:39.000]  даже если мы не умеем после них восстанавливаться, все равно их нужно делать, чтобы в случае чего
[09:39.000 --> 09:43.000]  отказать и, по крайней мере, не нарушить гарантии.
[09:43.000 --> 09:46.000]  Гарантии сейфти, в смысле.
[09:46.000 --> 09:50.000]  Ну и, наконец, последняя причина, которую мы до сих пор игнорировали,
[09:50.000 --> 09:55.000]  это злоумышленники, которые могут захватить узлы вашей системы и поместить там свой код.
[09:55.000 --> 10:01.000]  И дело не в том, что, там, не знаю, узел, сбоенный узел посылает некорректные сообщения,
[10:01.000 --> 10:04.000]  потому что там переворачиваются битики.
[10:04.000 --> 10:09.000]  А он отправляет корректные сообщения просто по смыслу разным и разным узлам.
[10:09.000 --> 10:14.000]  То есть протокол соблюдается, узел посылает синтетически корректные сообщения,
[10:14.000 --> 10:17.000]  но при этом выдают остальные возбуждения.
[10:17.000 --> 10:20.000]  И поэтому могут нарушаться какие-то глобальные варианты.
[10:20.000 --> 10:25.000]  Но почему мы до сих пор это все игнорировали?
[10:25.000 --> 10:28.000]  Точнее, как? Не то чтобы мы игнорировали.
[10:28.000 --> 10:30.000]  Мы-то как раз сегодня перестанем.
[10:30.000 --> 10:33.000]  А вот разработчики, скажем, Google Spanner не пытаются в систему
[10:33.000 --> 10:37.000]  встроить какие-то механизмы, которые от подобного поведения защищали бы
[10:37.000 --> 10:39.000]  саму систему.
[10:43.000 --> 10:49.000]  Ну вот, да, пока мы говорим про системы, которые живут в пределах какой-то условной компании,
[10:49.000 --> 10:56.000]  и вот в таком мире, в таких ограничениях гораздо разумнее от злоумышленников
[10:56.000 --> 11:00.000]  избавляться не в алгоритме, тем самым усложняя его и замедляя,
[11:00.000 --> 11:04.000]  а просто построить аккуратненький забор вокруг системы,
[11:04.000 --> 11:06.000]  ну, этим займется служба безопасности.
[11:06.000 --> 11:09.000]  И, наверное, ничего плохого не произойдет.
[11:09.000 --> 11:12.000]  Но другое дело, что, может быть, мы не хотим доверять какой-то одной службе безопасности
[11:12.000 --> 11:15.000]  каким-то конкретным людям, какой-то конкретной компании.
[11:15.000 --> 11:19.000]  И вот тогда уже эти проблемы нужно решать на уровне протоколов.
[11:19.000 --> 11:23.000]  Собственно, поэтому мы к византийским отказам и переходим.
[11:23.000 --> 11:27.000]  То есть, проблему с злоумышленниками мы сейчас решим алгоритмически.
[11:27.000 --> 11:31.000]  Проблему с аппаратными сбоями, но, видимо, нам придется примерно так же решать.
[11:31.000 --> 11:36.000]  По крайней мере, чексу мы нам уже помогали, нет причин, по которым мы от них откажемся.
[11:36.000 --> 11:39.000]  А с багами в протоколе, но, боюсь, тут лучше ничего не сделать.
[11:39.000 --> 11:45.000]  Если вы пишете неправильный код, то что тут уже сделаешь?
[11:45.000 --> 11:49.000]  Окей, значит, наша модель – это византийские отказы.
[11:50.000 --> 11:56.000]  Модель подразумевает, что сбоенный узел может вести себя совершенно произвольным образом.
[11:56.000 --> 11:59.000]  Почему византийские?
[12:03.000 --> 12:07.000]  Да, потому что Лэп когда-то в 82-м году написал статью,
[12:07.000 --> 12:11.000]  которая называлась «Задачи византийских генералов» про византийскую армию,
[12:11.000 --> 12:17.000]  которая осаждала какой-то город, и генералы, которые руководили дивизиями в этих армиях,
[12:17.000 --> 12:20.000]  должны были вместе атаковать или вместе отступать.
[12:20.000 --> 12:22.000]  Но делать это согласовано обязательно.
[12:22.000 --> 12:28.000]  Если кто-то из них поступит одним образом другим, другим противоположным, то все погибнут.
[12:28.000 --> 12:33.000]  Но среди генералов были предатели, они могли протоколу спотировать,
[12:33.000 --> 12:36.000]  принимать произвольные решения, врать остальным.
[12:36.000 --> 12:44.000]  И задача состояла в том, чтобы принять решение координированно среди корректных узлов,
[12:44.000 --> 12:48.000]  то есть генералов, которые соблюдают все-таки протокол.
[12:48.000 --> 12:52.000]  Это задача византийского консенсу, как вы можете понять.
[12:52.000 --> 12:58.000]  У нас есть входные данные, решение каждого генерала отступать или атаковать, 0 или 1,
[12:58.000 --> 13:04.000]  и все корректные, несбойные генералы должны принять одно и то же решение.
[13:04.000 --> 13:09.000]  Ну и, разумеется, если не все на старте разумно предположить хотя бы одного и того же,
[13:09.000 --> 13:12.000]  то они должны принять вот это самое решение.
[13:12.000 --> 13:15.000]  Если у всех на входе 0, то они должны выбрать 0.
[13:15.000 --> 13:19.000]  Короче говоря, это задача бинарного консенсуса.
[13:23.000 --> 13:35.000]  И свойства такие же, но они касаются только несбойных узлов.
[13:36.000 --> 13:43.000]  Сбойные узлы предателей действуют произвольным образом, мы их уже не контролируем,
[13:43.000 --> 13:46.000]  поэтому зачем от них чего-то ожидать вообще.
[13:49.000 --> 13:53.000]  Пока эта постановка задачи, мы не про нижние оценки пока не говорим.
[13:53.000 --> 13:58.000]  Вот мы сегодня эту задачу обсудим, потому что, в общем, консенсус.
[13:58.000 --> 14:02.000]  Потому что консенсус нам по-прежнему важен, по-прежнему он лежит в основе репликации,
[14:02.000 --> 14:08.000]  этого никуда не уйти, но задача решается уже в более сложной модели.
[14:11.000 --> 14:15.000]  Прежде чем обсуждать, как она решается или как она не решается,
[14:15.000 --> 14:18.000]  мы должны еще в модели внести некоторую поправку.
[14:18.000 --> 14:24.000]  А именно, мы все же в чем-то сбойные узлы ограничить можем,
[14:24.000 --> 14:27.000]  потому что без этого жить совсем будет невозможно.
[14:28.000 --> 14:34.000]  А именно, мы должны запретить византийским сбойным узлам представляться другими узлами.
[14:35.000 --> 14:40.000]  Потому что без этого вообще сложно себе что-то представить разумное.
[14:43.000 --> 14:46.000]  Как это запретить? Какой инструмент для этого нужен?
[14:48.000 --> 14:53.000]  Нет, для этого нужна криптография, потому что мы хотим решать задачу аутентификации.
[14:53.000 --> 14:56.000]  Вот если мы получаем сообщение, то мы хотим удостовериться,
[14:56.000 --> 15:01.000]  что действительно тот, кто заявляет о том, что он автор этого сообщения, им является.
[15:02.000 --> 15:04.000]  Вот для этого нам потребуется механизм...
[15:05.000 --> 15:07.000]  В общем, можно представить себе по-разному.
[15:07.000 --> 15:10.000]  Вот давайте представим себе наиболее общий механизм,
[15:10.000 --> 15:13.000]  который мы можем использовать, это цифровые подписи.
[15:23.000 --> 15:26.000]  Цифровые подписи – это три алгоритма.
[15:31.000 --> 15:38.000]  Во-первых, мы можем сгенерировать пару из приватного и публичного ключа.
[15:40.000 --> 15:45.000]  С помощью приватного ключа мы можем подписать сообщение.
[15:45.000 --> 15:49.000]  А дальше получатель этого сообщения может действительно удостовериться,
[15:49.000 --> 15:54.000]  что удостоверится в авторстве этого сообщения.
[16:16.000 --> 16:18.000]  Верифицировать авторство.
[16:19.000 --> 16:24.000]  Вот отправитель подписывает своим приватным ключом отправляемое сообщение.
[16:24.000 --> 16:29.000]  Получатель, зная публичный ключ от правителя, может удостовериться,
[16:29.000 --> 16:32.000]  что действительно это сообщение отправило.
[16:32.000 --> 16:35.000]  Вот это максимально эффектно.
[16:37.000 --> 16:41.000]  Этот механизм, кажется, дает нам самые сильные гарантии, которые только можно представить.
[16:42.000 --> 16:45.000]  Но он на самом деле кое-чего требует от нас.
[16:45.000 --> 16:48.000]  В смысле, от системы, которую этот алгоритм использует.
[16:51.000 --> 16:56.000]  Да, чтобы этот механизм работал, узлы должны знать публичные ключи друг друга.
[16:56.000 --> 17:00.000]  Вообще говоря, это некоторая подзадача, подсистема, которая тоже касается распределенности,
[17:00.000 --> 17:02.000]  которая тоже нужно как-то решать.
[17:02.000 --> 17:07.000]  Мы это чуть подробнее обсудим в следующий раз, когда мы будем говорить про PBFT.
[17:07.000 --> 17:10.000]  Вот там у нас будет инфраструктура публичных ключей.
[17:11.000 --> 17:15.000]  Но в конце концов, вы знаете, что интернет на сертификатах работает.
[17:16.000 --> 17:21.000]  Вы, заходя на какой-то сайт, должны удостовериться, что действительно это публичные ключи.
[17:21.000 --> 17:24.000]  Ну а для этого у вас есть публичные ключи, опять же.
[17:25.000 --> 17:26.000]  Ну а почему вы им доверяете?
[17:26.000 --> 17:28.000]  Откуда вы их берете?
[17:29.000 --> 17:30.000]  Об этом нужно задумываться.
[17:32.000 --> 17:35.000]  Но можно себе представить и чуть более слабые гарантии.
[17:35.000 --> 17:43.000]  А именно, можно считать, что вот если у нас есть два узлы,
[17:43.000 --> 17:45.000]  и этот узел отправляет сообщение этому,
[17:45.000 --> 17:49.000]  то этот узел всегда может проверить, что действительно сообщение отправлено этим узлом.
[17:50.000 --> 17:55.000]  Вот кажется, что это одно и то же, но на самом деле цифровые подписи дают нам чуть больше гарантий.
[17:57.000 --> 18:01.000]  Но поскольку мы пока их использовать не будем, мы можем эту разницу отложить.
[18:02.000 --> 18:04.000]  И мы будем использовать эти гарантии.
[18:05.000 --> 18:07.000]  И мы будем использовать эти гарантии.
[18:08.000 --> 18:14.000]  Но поскольку мы пока их использовать не будем, мы можем эту разницу отложить опять до следующего раза.
[18:15.000 --> 18:18.000]  Короче говоря, мы либо верим каналу, либо мы верим прям подписям.
[18:18.000 --> 18:20.000]  Это вот немного разные вещи.
[18:24.000 --> 18:29.000]  Но так или иначе, византийский сбоенный узел не может представляться другим узлом.
[18:30.000 --> 18:31.000]  Это для нас важно.
[18:31.000 --> 18:37.000]  Хорошо, ну тогда давайте, если ограничения, если сбои нам понятны,
[18:37.000 --> 18:39.000]  то давайте обсудим какую-то задачу.
[18:39.000 --> 18:41.000]  Ну вот задача бинарного консенсуса.
[18:43.000 --> 18:48.000]  Вспомним, с чего мы начинали говорить о консенсусе обычном, с отказами узлов.
[18:49.000 --> 18:52.000]  Мы сначала обсуждали, в каких условиях задача не решается.
[18:53.000 --> 18:56.000]  Ну понятно, что мы наследуем теоремы ФЛП, потому что куда надеемся.
[18:56.000 --> 18:58.000]  И вроде бы ее уже усиливать особо некуда.
[19:02.000 --> 19:05.000]  Была другая теорема, другой результаты невозможности.
[19:05.000 --> 19:10.000]  Он состоял в том, что он ограничивал отказу устойчивости в том смысле,
[19:10.000 --> 19:17.000]  что ваш алгоритм, если он переживал много сбоев и при этом завершался,
[19:17.000 --> 19:20.000]  то в некоторых сценариях он не может быть успешным.
[19:20.000 --> 19:25.000]  Если алгоритм переживал много сбоев и при этом завершался,
[19:25.000 --> 19:29.000]  то в некоторых сценариях он начинал неизбежно врать, то есть нарушать агримент.
[19:29.000 --> 19:31.000]  Мы доказывали такую нижнюю оценку.
[19:35.000 --> 19:37.000]  N больше 2F.
[19:37.000 --> 19:43.000]  Она означала, что если алгоритм готов пережить вот такое количество сбоев
[19:43.000 --> 19:48.000]  и готов завершаться, то чтобы не нарушать агримент никогда,
[19:48.000 --> 19:50.000]  то нужно сделать такое количество узлов.
[19:50.000 --> 19:57.000]  Мы сегодня начнем с того, что докажем такую же оценку снизу для византийской модели.
[19:57.000 --> 20:00.000]  И что удивительно, она кажется не сильно хуже.
[20:06.000 --> 20:10.000]  И тут есть некоторая тонкость, которую нужно сразу обсудить.
[20:13.000 --> 20:16.000]  Модель отказов максимально общая.
[20:16.000 --> 20:19.000]  Вот она допускает любое поведение.
[20:19.000 --> 20:22.000]  Кажется, что задача сильно усложнилась.
[20:22.000 --> 20:26.000]  При этом оценка снизу ухудшилась, она же, заметьте, ухудшилась,
[20:26.000 --> 20:29.000]  но совершенно незначительно, мы двойку заменили на тройку.
[20:29.000 --> 20:32.000]  Кажется, что это совсем не страшно.
[20:32.000 --> 20:35.000]  Но тем не менее, беда наша не в этом.
[20:35.000 --> 20:38.000]  Не в том, что 2 на 3 поменялось.
[20:46.000 --> 20:56.000]  Давай рассуждать, что мы в таком плоском мире живем,
[20:56.000 --> 20:58.000]  где у нас отдельные узлы.
[20:58.000 --> 21:04.000]  Мы не думаем, как они локализованы, какими группами узлы отказывают.
[21:12.000 --> 21:15.000]  Вообще, ты про очень интересные и разумные вещи говоришь,
[21:15.000 --> 21:18.000]  когда мы говорим про византийскую модель,
[21:18.000 --> 21:21.000]  у нас византийскими могут быть, конечно, не только узлы системы,
[21:21.000 --> 21:24.000]  у нас могут быть византийскими клиенты.
[21:24.000 --> 21:28.000]  И они могут честным узлам отправлять очень странные запросы,
[21:28.000 --> 21:30.000]  абсолютно безумные.
[21:30.000 --> 21:34.000]  Они будут корректными эти запросы, но они будут какими-то видоносными.
[21:34.000 --> 21:36.000]  И нужно как-то с этим бороться.
[21:36.000 --> 21:39.000]  Или, скажем, с протоколом общения клиента и системы.
[21:39.000 --> 21:41.000]  Но это тема следующего раза.
[21:41.000 --> 21:44.000]  Сегодня мы говорим про бинарный консенсус, про такую задачу
[21:44.000 --> 21:46.000]  как раз, чтобы не касаться многих сложностей,
[21:46.000 --> 21:48.000]  которые нас пока не волнуют.
[21:48.000 --> 21:52.000]  Мы хотим пока какие-то базовые алгоритмические идеи обсудить,
[21:52.000 --> 21:55.000]  которые даже от конкретных клиентов,
[21:55.000 --> 21:58.000]  от конкретного состояния,
[21:58.000 --> 22:01.000]  которое мы реприлицируем, не зависит.
[22:05.000 --> 22:07.000]  Да, вот именно.
[22:07.000 --> 22:10.000]  Мы в наш алгоритм можем заложить какое-то f,
[22:10.000 --> 22:12.000]  какое-то значение.
[22:12.000 --> 22:15.000]  Мы готовы пережить два отказа, поэтому берем 5 реплик.
[22:17.000 --> 22:20.000]  И если отказов не больше, чем два,
[22:20.000 --> 22:23.000]  то наш алгоритм работает, он отвечает клиентам, все хорошо.
[22:23.000 --> 22:26.000]  Если же отказы становятся больше, чем два,
[22:26.000 --> 22:29.000]  то, опять, ничего прям смертельного не происходит.
[22:29.000 --> 22:32.000]  Потому что, ну, что происходит с нашим алгоритмом?
[22:32.000 --> 22:35.000]  Он просто не может собрать quorum больше.
[22:35.000 --> 22:38.000]  То есть он не может обслужить ни чтения,
[22:38.000 --> 22:40.000]  может быть, что, допустим, обслужить.
[22:40.000 --> 22:43.000]  Но вот запись в случае он уже не может.
[22:45.000 --> 22:48.000]  Система не может нарушить safety-свойства,
[22:48.000 --> 22:51.000]  потому что она не может принять сбойный узел
[22:51.000 --> 22:54.000]  за работающий.
[22:54.000 --> 22:57.000]  Вот беда наша не в том, что мы увеличили вот этот коэффициент.
[22:57.000 --> 23:00.000]  Беда наша в том, что...
[23:00.000 --> 23:03.000]  Беда наша случается в тот момент, когда мы переходим
[23:03.000 --> 23:06.000]  через границу числа заложенных отказов.
[23:06.000 --> 23:09.000]  Вот если отказов в византийском сеттинге
[23:09.000 --> 23:12.000]  у нас больше, чем заложенное f,
[23:12.000 --> 23:15.000]  то нет никакого разумного способа
[23:15.000 --> 23:18.000]  от этого защититься.
[23:18.000 --> 23:21.000]  Потому что византийские сбойные узлы...
[23:21.000 --> 23:24.000]  Ну, они, конечно, могут просто, скажем, не работать, не отвечать.
[23:24.000 --> 23:27.000]  Ну, потому что отказы узлов – это частный случай византийского поведения.
[23:27.000 --> 23:31.000]  Но они могут притворяться, что не работают корректно.
[23:31.000 --> 23:34.000]  И если их слишком много,
[23:34.000 --> 23:37.000]  то наш алгоритм ничего не сможет сделать.
[23:39.000 --> 23:42.000]  Ну, а действительно, мы же настоящего f не знаем.
[23:44.000 --> 23:47.000]  Вот это беда.
[23:49.000 --> 23:52.000]  Ну, мы должны с этим смириться.
[23:52.000 --> 23:55.000]  Тут мы ничего сделать не можем уже.
[23:55.000 --> 23:58.000]  Наша задача сначала доказать, что действительно лучше не получится,
[23:58.000 --> 24:01.000]  а потом уже постараться узнать,
[24:01.000 --> 24:04.000]  достигается ли вообще эта оценка снизу.
[24:06.000 --> 24:09.000]  То есть можно ли построить алгоритм, который будет
[24:09.000 --> 24:12.000]  устойчив к f византийским узлам
[24:12.000 --> 24:15.000]  и при этом будет использовать всего лишь там 3 f плюс одну реплику.
[24:18.000 --> 24:21.000]  Ну, давайте сначала поговорим про невозможность.
[24:24.000 --> 24:27.000]  Итак, мы хотим доказать сейчас, что
[24:27.000 --> 24:30.000]  для того, чтобы пережить f отказов,
[24:30.000 --> 24:33.000]  нам требуется, по крайней мере,
[24:33.000 --> 24:36.000]  3 f плюс один узел.
[24:42.000 --> 24:45.000]  Мы будем эту тарему доказывать в два шага.
[24:47.000 --> 24:50.000]  Во-первых, мы рассмотрим частный случай,
[24:50.000 --> 24:53.000]  когда n равно 3
[24:53.000 --> 24:56.000]  и f одному.
[25:08.000 --> 25:11.000]  Сначала поговорим про частный случай, когда у нас
[25:11.000 --> 25:14.000]  всего лишь 3 узла и покажем, что с тремя узлами
[25:14.000 --> 25:17.000]  пережить один византийский узел не получится.
[25:18.000 --> 25:21.000]  Докажем это от противного.
[25:21.000 --> 25:24.000]  Предположим, что алгоритм все-таки нашелся.
[25:24.000 --> 25:27.000]  Про алгоритм мы мало что знаем, но вот пусть
[25:27.000 --> 25:30.000]  он состоит из трех узла,
[25:30.000 --> 25:33.000]  состоит из трех разных алгоритмов PQER.
[25:41.000 --> 25:44.000]  Эти три узла способны,
[25:44.000 --> 25:47.000]  запустив на себе эти три алгоритма,
[25:47.000 --> 25:50.000]  пережить византийское поведение
[25:50.000 --> 25:53.000]  любого из них, скажем, узла R.
[25:54.000 --> 25:57.000]  Покажем, что такого на самом деле не бывает.
[25:59.000 --> 26:02.000]  Давайте я немного картинку смещу.
[26:02.000 --> 26:19.000]  Итак, пусть PQER такие нашлись,
[26:19.000 --> 26:21.000]  что эти три узла могут решить
[26:21.000 --> 26:24.000]  византийский консенсус, могут решить задачу
[26:24.000 --> 26:27.000]  консенсуса при условии, что какой-то один из этих узлов
[26:27.000 --> 26:30.000]  может позволить себе произвольное поведение.
[26:30.000 --> 26:33.000]  позволит себе произвольное поведение.
[26:33.000 --> 26:36.000]  Построим некоторую вспомогательную конструкцию, которая будет
[26:36.000 --> 26:41.000]  очень индуитивной, надеюсь, я смысл ее продемонстрирую вам.
[26:41.000 --> 26:54.000]  Возьмем 6 узлов.
[26:54.000 --> 26:59.000]  Вот сейчас я рисую провода.
[26:59.000 --> 27:02.000]  То есть каждый узел может общаться только с двумя соседями,
[27:02.000 --> 27:04.000]  только про них знает.
[27:04.000 --> 27:11.000]  И вот на эти 3 узла мы посадим алгоритм ПКУ и Р.
[27:11.000 --> 27:14.000]  И дадим им на вход нули.
[27:14.000 --> 27:17.000]  Да, мы показываем невозможность чего-то, для этого достаточно
[27:17.000 --> 27:24.000]  рассматривать случай бинарного концерна, как византийских генералов.
[27:24.000 --> 27:33.000]  А на эти 3 узла мы посадим снова алгоритм ПКУ и Р, но с другими входами.
[27:33.000 --> 27:38.000]  Вот это, это вход.
[27:38.000 --> 27:46.000]  Вот это, это алгоритм.
[27:46.000 --> 27:49.000]  Вот у нас есть 6 узлов.
[27:49.000 --> 27:53.000]  Им на вход подаются значения.
[27:53.000 --> 27:59.000]  И мы в этом странном шестиугольном мире эти алгоритмы запускаем.
[27:59.000 --> 28:04.000]  Вот получается некоторое исполнение альфа 6, назовем вот так.
[28:04.000 --> 28:16.000]  Есть ли в нем какой-то смысл?
[28:16.000 --> 28:18.000]  Ну, во-первых, почему я вообще могу так сделать?
[28:18.000 --> 28:19.000]  Почему я могу запустить алгоритм?
[28:19.000 --> 28:23.000]  Тут есть на самом деле некоторые тонкости, я их позже прокомментирую.
[28:23.000 --> 28:27.000]  Но когда мы запускаем эти алгоритмы, конечно, мы каждому сообщаем,
[28:27.000 --> 28:30.000]  что он на самом деле живет в треугольном мире.
[28:30.000 --> 28:34.000]  И вот сообщаем узлу вот этому экземпляру алгоритма ПЭ,
[28:34.000 --> 28:39.000]  этому узлу мы сообщаем, что он живет в мире вот из трех этих узлов.
[28:39.000 --> 28:41.000]  Он только с ними может общаться, только про них знает.
[28:41.000 --> 28:46.000]  Поэтому он как-то локально функционирует, думая, что он решает вместе с ними задачу консенсуса.
[28:46.000 --> 28:48.000]  Так думает каждый.
[28:48.000 --> 28:51.000]  Что они делают вместе совершенно непонятно.
[28:51.000 --> 28:54.000]  То есть требовать от них, чтобы они выбрали, скажем, одно значение,
[28:54.000 --> 29:01.000]  это было бы странно, потому что явно алгоритм для такого не рассчитан.
[29:01.000 --> 29:08.000]  Так что они просто запускаются, работают и, может быть, что-то выбирают.
[29:08.000 --> 29:13.000]  Но вот нам сейчас не очень важно, что они решают консенсус.
[29:13.000 --> 29:16.000]  Каждый из них думает, что решает консенсус, но вместе делает что-то странное.
[29:16.000 --> 29:21.000]  Но, тем не менее, давайте посмотрим на какие-то пары этих узлов.
[29:21.000 --> 29:24.000]  Вот, скажем, посмотрим на эту пару.
[29:28.000 --> 29:30.000]  П0 и К0.
[29:34.000 --> 29:36.000]  Вот они оба корректны.
[29:36.000 --> 29:40.000]  Вообще в этом исполнении Альфа-6 византийских узлов нет и не будет.
[29:40.000 --> 29:43.000]  Тут все действуют честно по протоколу.
[29:43.000 --> 29:48.000]  Но вот подумаем, как мир выглядит для этой пары узлов.
[29:53.000 --> 29:59.000]  Вот я бы сказал, что он выглядит, как будто бы эти два узла живут в некотором треугольном мире.
[30:05.000 --> 30:10.000]  И с ними общается один византийский узел R, волнистый.
[30:13.000 --> 30:18.000]  Вот у этого узла на входе 0, у этого на входе 0.
[30:18.000 --> 30:27.000]  И они живут в мире с каким-то странным узлом R с волной, который с Q0 общается, как будто бы у него 0.
[30:27.000 --> 30:30.000]  Ну, короче, он с Q0 общается, как R0.
[30:32.000 --> 30:35.000]  А с P0 он общается, как R1.
[30:36.000 --> 30:45.000]  Ну, или можно сказать иначе, что мы поместили P0 и Q0 в византийское треугольное исполнение,
[30:47.000 --> 30:52.000]  в котором узел R с волной просто в голове симулирует
[30:52.000 --> 30:54.000]  вот такую конструкцию.
[30:57.000 --> 31:04.000]  То есть он как будто бы у себя в голове поместил еще 4 копии алгоритмов, их запустил и вот общается с P0 и Q0 таким вот образом.
[31:07.000 --> 31:10.000]  Ну, а вот в этом же случае, как бы он и византийский узел,
[31:10.000 --> 31:15.000]  он просто в голове симулирует вот такую конструкцию.
[31:15.000 --> 31:22.000]  Ну, окей, наш алгоритм обещал нам в таких ситуациях завершаться и достигать agreement.
[31:23.000 --> 31:28.000]  Вот здесь на входе у узлов 0, поэтому они должны выбрать только 0.
[31:28.000 --> 31:35.000]  Так что они вот рано или поздно завершатся, и каждый из них выберет этот самый 0.
[31:36.000 --> 31:39.000]  По нашему предположению, что этот алгоритм такой нашелся.
[31:39.000 --> 31:42.000]  Окей, теперь посмотрим на другую пару.
[31:46.000 --> 31:48.000]  Вот на эту.
[31:49.000 --> 31:50.000]  Ну, понятно, к чему я кладу.
[31:50.000 --> 31:52.000]  Вот можно нарисовать такую же картинку.
[31:52.000 --> 31:56.000]  У нас есть узел R1, у нас есть узел Q1.
[31:57.000 --> 32:00.000]  У них на входе единицы, они ведут себя честно.
[32:01.000 --> 32:05.000]  У нас есть узел R1, у нас есть узел Q1.
[32:05.000 --> 32:08.000]  У них на входе единицы, они ведут себя честно.
[32:09.000 --> 32:22.000]  И они как будто бы общаются с узлом волнистым P, византийским, который общается с R1,
[32:23.000 --> 32:27.000]  как будто бы он P0 в этом шестиугольном исполнении,
[32:27.000 --> 32:38.000]  и ИСКО 1, как будто бы он алгоритм P со входом 1.
[32:41.000 --> 32:45.000]  Ну опять, вот этот византийский узел, давайте его перекрасим.
[32:45.000 --> 33:07.000]  Этот византийский узел, можно сказать, что в голове у себя эмулирует вот такой набор, такой подграф.
[33:08.000 --> 33:14.000]  Ну и по тем же самым соображениям, алгоритмы Q и R должны решать консенсус
[33:14.000 --> 33:20.000]  при условии византийского P и должны выбрать неизбежную единицу, потому что у обоих на входе единицы.
[33:24.000 --> 33:30.000]  Значит, вот это исполнение мы обозначим давайте за Δ1, это Δ2.
[33:33.000 --> 33:36.000]  Ну а дальше какое исполнение мы рассмотрим?
[33:36.000 --> 33:55.000]  Да, вот мы рассмотрим вот эту пару и подумаем, что происходит с ней.
[33:56.000 --> 34:05.000]  Ну опять те же самые соображения, это все для них не отличается от треугольного исполнения.
[34:06.000 --> 34:21.000]  P0, R1 и с ними общается византийский узел Q.
[34:26.000 --> 34:29.000]  Что же им делать? Что же им выбрать?
[34:29.000 --> 34:41.000]  В этом исполнении они завершаются, потому что алгоритм решает задачу консенсуса для трех узлов с одним византийским отказом.
[34:42.000 --> 34:48.000]  Они выбирают что-то общее и выбирают из набора 0 и 1. Оба входа были, поэтому можно выбрать что угодно.
[34:49.000 --> 34:52.000]  Но для нас важно, что они выбирают одно и то же.
[34:53.000 --> 34:58.000]  А вот по двум другим соображениям они должны выбрать разное, неизбежное.
[35:00.000 --> 35:06.000]  И в этом заключается противоречие, и видимо оно нас убеждает, что наше предположение было неверное.
[35:08.000 --> 35:19.000]  Можно это все объяснить немного по-другому, то есть чуть более интуитивно, а именно сказать, что кажется узел P0 не отличает исполнение
[35:19.000 --> 35:33.000]  дельта 3 от дельта 1, где вот здесь византийский узел моделирует вот такую часть графа, а здесь византийский узел моделирует вот такую часть графа.
[35:33.000 --> 35:39.820]  такую часть графа. А узел Q1 не отличает дельта 2,
[35:39.820 --> 35:49.920]  нет, узел R1 не отличает дельта 2 и дельта 3. То есть можно
[35:49.920 --> 35:53.460]  с другой стороны на всю эту конструкцию посмотреть,
[35:53.460 --> 35:57.900]  ну и прийти к тем же самым выводам. Итого алгоритма
[35:57.900 --> 36:03.700]  для трёх узлов быть не может. Понятно?
[36:03.700 --> 36:10.700]  Окей, тогда небольшое замечание по поводу этого алгоритма.
[36:10.700 --> 36:16.700]  А именно мы здесь предполагаем, что византийский узел,
[36:16.700 --> 36:21.700]  вообще говоря, может симулировать поведение других узлов.
[36:21.700 --> 36:26.700]  Так чтобы вот эти узлы ничего ни о чём не догадались.
[36:27.500 --> 36:32.500]  Это, вообще говоря, довольно сильное требование.
[36:32.500 --> 36:39.500]  И, скажем, если у нас есть приватные ключи, если мы работаем
[36:39.500 --> 36:42.500]  вот с цифровыми подписями, то было бы странно ожидать,
[36:42.500 --> 36:45.500]  что византийский узел может моделировать поведение
[36:45.500 --> 36:51.500]  узла P с его приватным ключом. Него его нет.
[36:51.500 --> 36:53.500]  Короче говоря, тут нужно быть очень аккуратным,
[36:53.500 --> 36:56.500]  а способен ли алгоритм понять, что он находится
[36:56.500 --> 37:01.500]  на самом деле не вот... По-другому скажу.
[37:01.500 --> 37:04.500]  Вот узел R, он византийский, он, конечно, может делать
[37:04.500 --> 37:07.500]  всё, что угодно. Но он не может придумать сообщения
[37:07.500 --> 37:13.500]  от имени, скажем честно, узла P.
[37:13.500 --> 37:17.500]  И это всё-таки некоторое ограничение.
[37:17.500 --> 37:21.500]  Так вот, в этой теории на самом деле не явно полагается,
[37:21.500 --> 37:25.500]  что у нас здесь не цифровые подписи, а у нас здесь есть
[37:25.500 --> 37:30.500]  провода, в которые мы верим. Это не одно и то же.
[37:30.500 --> 37:33.500]  Но вы же есть приватный ключ R.
[37:33.500 --> 37:36.500]  Ну ещё раз, смотри, у тебя византийский узел может
[37:36.500 --> 37:40.500]  сказать вот этому узлу Q, что он получил от узла P что-то.
[37:40.500 --> 37:44.500]  Вот если ты веришь в провода, то он может тебе соврать.
[37:44.500 --> 37:46.500]  А если у тебя есть цифровые подписи, то он про P соврать не может,
[37:46.500 --> 37:50.500]  потому что ты можешь проверить, что подпись P совпадает.
[37:50.500 --> 37:59.500]  Вот такая система из зацепленных троек.
[37:59.500 --> 38:03.500]  Тут сложно понять, что происходит. Мне с трудом удается.
[38:03.500 --> 38:09.500]  Но ты всё-таки должен понимать, что византийский узел в некотором
[38:09.500 --> 38:11.500]  смысле ограничен возможности симулировать по единению
[38:11.500 --> 38:14.500]  других узлов, потому что алгоритм может быть произвольным.
[38:14.500 --> 38:19.500]  И если алгоритм пересылает постоянно все сообщения всем узлам,
[38:19.500 --> 38:23.500]  то вот R византийский здесь не может придумать сообщения,
[38:23.500 --> 38:28.500]  от имени P отправить его Q, если есть цифровые подписи.
[38:28.500 --> 38:33.500]  А если цифровых подписей нет, и ты просто доверяешь каналам,
[38:33.500 --> 38:36.500]  то такой обман возможен.
[38:36.500 --> 38:39.500]  Так вот в этой теории мы предполагаем, что мы доверяем
[38:39.500 --> 38:42.500]  именно каналам, но без подписи живём.
[38:42.500 --> 38:46.500]  Потому что иначе ты можешь кочевно догадаться всё же.
[38:46.500 --> 38:53.500]  Ну смотри, ты взял алгоритм P и поместил его в такой граф.
[38:53.500 --> 38:58.500]  Он вообще для такого не задуман. Правда ведь?
[38:58.500 --> 39:04.500]  Вот. И вдруг у тебя алгоритм устроен так, что все узлы посылают
[39:04.500 --> 39:06.500]  постоянно всем сообщения, которые они от других узлов получали.
[39:06.500 --> 39:09.500]  Ну ты, конечно, можешь о чём-то умолчать, но с другой стороны,
[39:09.500 --> 39:12.500]  ты не можешь византийский узел соврать о том другому узлу,
[39:12.500 --> 39:17.500]  что ты получил от другого честного узла сообщения.
[39:17.500 --> 39:19.500]  Правда ведь?
[39:19.500 --> 39:25.500]  Вот R с волной не может наврать Q0, что он получил что-то от P0.
[39:25.500 --> 39:31.500]  То есть здесь он, конечно, может сказать, что он получил от P1 какое-то сообщение.
[39:31.500 --> 39:37.500]  Вот. Но он же не знает приватного ключа P. Не может знать.
[39:37.500 --> 39:41.500]  Поэтому алгоритм может о чём-то догадаться.
[39:41.500 --> 39:44.500]  То есть, короче говоря, наш R в чём-то ограничен.
[39:44.500 --> 39:52.500]  В это время мы такие ограничения не учитываем, мы считаем, что эти алгоритмы ничего не поймут.
[39:52.500 --> 39:56.500]  И это означает, что мы живём в модели, где мы верим в провода.
[39:56.500 --> 40:03.500]  То есть если мы получили сообщение от R с волной, то мы считаем, что он его отправил.
[40:03.500 --> 40:07.500]  И мы считаем, что да, он говорит, что ему кто-то сказал.
[40:07.500 --> 40:11.500]  То есть установить подлинность последнего утверждения мы не можем.
[40:11.500 --> 40:17.500]  Но, по крайней мере, мы не спутаем сообщение от R с волной от сообщения от P0.
[40:17.500 --> 40:25.500]  То есть чувствуете разницу между моделью, где мы доверяем каналам и где мы используем цифровые подписи?
[40:25.500 --> 40:28.500]  Ну вот, здесь мы доверяем именно каналам.
[40:28.500 --> 40:33.500]  Вот тогда действительно алгоритмы ничего не поймут, что они живут в таком шестиугольном мире.
[40:34.500 --> 40:37.500]  С этим случаем мы...
[40:37.500 --> 40:38.500]  Что?
[40:38.500 --> 40:43.500]  Доверяем каналам, мы как будто прислали цифровый транспорт.
[40:43.500 --> 40:49.500]  Нет, как будто бы у нас есть некоторый сессионный ключ.
[40:49.500 --> 40:53.500]  Тут же вопрос про транзитивность.
[40:53.500 --> 40:55.500]  Ну то есть это и по-другому называется.
[40:55.500 --> 41:01.500]  Я через неделю об этом подробнее расскажу, когда будет больше поводов.
[41:01.500 --> 41:05.500]  Речь про то, что происходит, когда один узел получил сообщение от другого и пересылает его третьему.
[41:11.500 --> 41:14.500]  Что значит цифрование? У тебя есть цифрование между двумя узлами.
[41:14.500 --> 41:16.500]  У них есть какой-то секретный сессионный ключ.
[41:16.500 --> 41:19.500]  Они общаются друг с другом, они уверены, что...
[41:21.500 --> 41:24.500]  Но пересылки ты гарантии теряешь.
[41:25.500 --> 41:28.500]  И здесь пересылка...
[41:29.500 --> 41:30.500]  Еще раз.
[41:30.500 --> 41:32.500]  Мы не решаем задачу шифрования нигде здесь.
[41:32.500 --> 41:35.500]  Это неважно. Мы решаем задачу аутентификации.
[41:35.500 --> 41:38.500]  Мы должны проверить авторство.
[41:38.500 --> 41:42.500]  От кого мы здесь не шифруем данные?
[41:42.500 --> 41:47.500]  Это хороший вопрос в смысле, что Тебяна спросила, но это не наша цель.
[41:47.500 --> 41:50.500]  Наша цель аутентификация.
[41:50.500 --> 41:54.500]  Ладно, давайте вторую часть докажем, потому что нам нужен теперь общий случай.
[41:54.500 --> 42:02.500]  А именно мы покажем, что не существует алгоритма, когда у нас n не больше 3f.
[42:02.500 --> 42:05.500]  Как мы собираемся это сделать?
[42:05.500 --> 42:11.500]  Предположим, что нашелся алгоритм, который решает задачу консенсуса,
[42:11.500 --> 42:16.500]  переживает f византийских отказов и обходится вот таким числом узлов.
[42:16.500 --> 42:22.500]  То есть представим, что у нас нашелся алгоритм, который переживает 4 отказа
[42:22.500 --> 42:26.500]  и обходится 11 узлами.
[42:26.500 --> 42:29.500]  Вот некоторые произвольные числа.
[42:33.500 --> 42:35.500]  Почему бы и нет?
[42:35.500 --> 42:42.500]  Так вот, я сейчас хочу показать, что имея такой алгоритм, мы назовем его a.
[42:42.500 --> 42:48.500]  Мы с его помощью можем построить алгоритм b для трех узлов,
[42:48.500 --> 42:50.500]  который переживает один отказ.
[42:50.500 --> 42:53.500]  Но поскольку такого алгоритма не существует, как мы ранее показали,
[42:53.500 --> 42:56.500]  то значит не существует алгоритма a.
[42:59.500 --> 43:03.500]  Ну вот давайте строить алгоритм b.
[43:03.500 --> 43:08.500]  Здесь было 11 узлов, у нас будет 3 узла, и мы должны посадить на эти 3 узла
[43:08.500 --> 43:11.500]  алгоритмы P, Q и R.
[43:14.500 --> 43:18.500]  Вот я предлагаю исследовать немножко некорректной, но довольно смешной
[43:18.500 --> 43:23.500]  нотации авторов статьи про генералов и говорить, что у нас здесь генералы есть
[43:23.500 --> 43:25.500]  и здесь генералы есть, их нужно различать.
[43:25.500 --> 43:29.500]  Здесь будут албанские генералы, здесь будут византийские генералы.
[43:29.500 --> 43:33.500]  И как будут устроены византийские генералы?
[43:33.500 --> 43:39.500]  Ну вот у нас есть алгоритм a, который, скажем, работает на 11 узлах.
[43:39.500 --> 43:42.500]  Тут отдельные алгоритмы на отдельных узлах могут быть разными, неважно.
[43:42.500 --> 43:45.500]  Мы знаем, что поскольку выполняется такое соотношение, мы можем разделить
[43:45.500 --> 43:55.500]  группы этих алгоритмов на 3 группы, так чтобы в каждой группе было не более,
[43:55.500 --> 43:57.500]  чем f узлов.
[43:58.500 --> 44:05.500]  Вот мы эти группы назовем P, Q и R.
[44:05.500 --> 44:12.500]  И скажем, что каждый византийский генерал будет у себя в голове моделировать,
[44:12.500 --> 44:16.500]  так же, как здесь византийский узел симулировал группу других узлов,
[44:16.500 --> 44:20.500]  здесь вот каждый алгоритм будет симулировать поведение своей группы
[44:20.500 --> 44:22.500]  албанских генералов.
[44:22.500 --> 44:28.500]  То есть мы вот этим 3 алгоритмам раздадим вот эти группы алгоритмов.
[44:33.500 --> 44:35.500]  Дальше.
[44:35.500 --> 44:40.500]  Когда византийские генералы будут получать на вход значение, скажем,
[44:40.500 --> 44:47.500]  1 или 0, то это будет означать, что все албанские генералы,
[44:47.500 --> 44:53.500]  которые, поведение которых симулируют в голове византийский,
[44:53.500 --> 44:55.500]  тоже получат то же самое значение.
[45:03.500 --> 45:05.500]  Вот здесь будут все нули, соответственно.
[45:09.500 --> 45:15.500]  Итого, мы раздали вот этим 3 узлам алгоритмы,
[45:15.500 --> 45:19.500]  мы дали им входы, они их передали этим албанским генералам,
[45:19.500 --> 45:23.500]  а дальше мы запускаем протокол, то есть запускаем византийских генералов,
[45:23.500 --> 45:26.500]  они начинают решать задачу консенсуса.
[45:26.500 --> 45:31.500]  Это означает, что эти албанские генералы внутри этих византийских
[45:31.500 --> 45:33.500]  начинают делать то же самое.
[45:33.500 --> 45:36.500]  Ну и по пути они обмениваются сообщениями.
[45:36.500 --> 45:43.500]  Так вот, если сообщение, то есть у нас начинается исполнение алгоритма B,
[45:43.500 --> 45:47.500]  и вместе с ним разворачивается некоторое исполнение алгоритма A.
[45:47.500 --> 45:51.500]  И в этом исполнении алгоритма A какие-то албанские генералы обмениваются сообщениями.
[45:51.500 --> 45:59.500]  Так вот, если сообщение отправляется албанским генералам внутри его группы,
[45:59.500 --> 46:02.500]  то это все происходит в голове одного византийского генерала,
[46:02.500 --> 46:05.500]  и он просто отправляет и все.
[46:05.500 --> 46:08.500]  А вот если сообщение пересекает границу групп,
[46:08.500 --> 46:15.500]  то surrender, то есть албанский генерал A отправляет албанскому генералу C
[46:15.500 --> 46:19.500]  из другой группы какое-то сообщение, алгоритме A.
[46:19.500 --> 46:22.500]  То это означает, что византийский генерал L, R отправляет сообщению
[46:22.500 --> 46:25.500]  византийскому генералу Q, что его албанский генерал A
[46:25.500 --> 46:31.500]  отправляет его, албанскому генералу C узла Q, какое-то сообщение.
[46:31.500 --> 46:35.500]  То есть алгоритм начинает работать.
[46:35.500 --> 46:44.000]  И в ходе работы этого алгоритма B возникают византийские отказы.
[46:44.000 --> 46:49.500]  То есть какой-то узел Q может отказать.
[46:49.500 --> 46:53.500]  Что это означает для алгоритма A?
[46:53.500 --> 46:58.500]  Что в соответствующем исполнении алгоритма A у нас отказывает
[46:58.500 --> 47:02.500]  некоторая группа албанских генералов.
[47:03.500 --> 47:07.500]  Но только группа целиком.
[47:07.500 --> 47:11.500]  То есть у нас к каждому исполнению алгоритма B соответствуют некоторые
[47:11.500 --> 47:16.500]  исполнения алгоритма A. Но мы такой симуляцией не покрываем
[47:16.500 --> 47:21.500]  все возможные исполнения алгоритма A. Мы покрываем только те исполнения,
[47:21.500 --> 47:27.500]  в которых византийскими может оказаться только группа целиком.
[47:27.500 --> 47:32.500]  Ну, а мы знаем, что алгоритм A по предположению нашему переживает
[47:32.500 --> 47:37.500]  отказ любых F узлов.
[47:37.500 --> 47:42.500]  А это означает, что рано или поздно A завершится.
[47:42.500 --> 47:50.500]  И мы знаем, что внутри каждой группы, которая уцелела все коллектные
[47:50.500 --> 47:53.500]  албанские генералы, выберут одно значение.
[47:53.500 --> 47:57.500]  То есть не бывает такого, что в одной группе оказались и сбойные узлы,
[47:57.500 --> 48:03.500]  и честные. Все сбойные локализованы в пределах одной группы.
[48:03.500 --> 48:10.500]  Поэтому если узел корректный и завершается, то завершаются и все другие узлы
[48:10.500 --> 48:14.500]  этой же группы.
[48:14.500 --> 48:18.500]  Ну, допустим, все выбрали один.
[48:18.500 --> 48:22.500]  Ну, вот таким образом, если в группе все завершаются и все выбирают одно и то же,
[48:22.500 --> 48:26.500]  то значит определено понятие выбора для византийского генерала.
[48:26.500 --> 48:30.500]  То есть можно сказать, что когда первый генерал из группы завершится и выберет значение,
[48:30.500 --> 48:36.500]  тогда византийский генерал может считать, что он тоже выбрал значение.
[48:36.500 --> 48:39.500]  Ясно?
[48:39.500 --> 48:48.500]  Вот вроде бы алгоритм описан, правда?
[48:48.500 --> 48:52.500]  Это какая разница, что они делают? Они уже контролируются злоумышленником.
[48:52.500 --> 48:56.500]  В смысле, контролируются злоумышленником узелку. Вот все, эти уже...
[48:56.500 --> 49:04.500]  Непонятно, что мы от них ожидаем.
[49:04.500 --> 49:08.500]  Мы предположили, что алгоритм А решает задачу византийского консенсуса и переживает
[49:08.500 --> 49:12.500]  любые четыре отказа.
[49:12.500 --> 49:20.500]  Так что если у тебя какой-то византийский генерал сходит с ума,
[49:20.500 --> 49:28.500]  то сходит с ума разом вся его группа, но другие группы остаются невредимыми.
[49:28.500 --> 49:33.500]  Потому что мы рассматриваем задачу в таких ограничениях, что у нас BF не больше, чем F.
[49:33.500 --> 49:38.500]  А если усыреет вся группа целиком, она сохранит свой разум, значит определено,
[49:38.500 --> 49:46.500]  почему такой выбор для византийского генерала R или P.
[49:46.500 --> 49:53.500]  Значит говоря, для любого допустимого исполнения алгоритма B на трех узлах
[49:53.500 --> 50:01.500]  с не более чем одним отказом, ему соответствует допустимое исполнение алгоритма A
[50:01.500 --> 50:07.500]  с не более чем F отказами. Ну а значит алгоритм A выполняет все свойства консенсуса,
[50:07.500 --> 50:17.500]  значит наследуется сюда, и здесь они тоже выполняются.
[50:17.500 --> 50:21.500]  Ну что?
[50:21.500 --> 50:36.500]  Кажется, что это делать неразумно, потому что цель у нас другая.
[50:36.500 --> 50:44.500]  А? Нет, не пройдет, конечно, потому что если у тебя в одной группе будет, скажем, 5 генералов,
[50:44.500 --> 50:55.500]  ну вот скажем, в группе Q у тебя будет 5 генералов, да? Давай сотрем одного здесь и добавим сюда.
[50:55.500 --> 51:05.500]  Вот, да, избойной будет... Нет, еще раз, если избойной будет группа P, то что страшного-то произойдет?
[51:05.500 --> 51:12.500]  Ну алгоритм A переживет отказ трех узлов.
[51:12.500 --> 51:18.500]  Еще раз, когда мы строим алгоритм B, мы берем любое разбиение алгоритмов A на три группы,
[51:18.500 --> 51:32.500]  нам важно лишь то, чтобы размер каждой группы был не более чем F узлов.
[51:32.500 --> 51:42.500]  Прости, я, видимо, не схватываю твой вопрос.
[51:42.500 --> 51:47.500]  Нет, мы не предположили, что они избойные, мы предположили, что алгоритм есть.
[51:47.500 --> 51:55.500]  Если мы предполагаем, что алгоритм есть, и он переживает F отказов и использует n не более чем 3F узлов при этом,
[51:55.500 --> 52:00.500]  то я могу разделить их на три группы и построить алгоритм для трех узлов.
[52:00.500 --> 52:09.500]  И отказ любого византийского такого узла будет отвечать отказу не более чем F узлов в алгоритме A.
[52:09.500 --> 52:21.500]  Алгоритм A с этим справится и свойства консенсуса не растеряет.
[52:21.500 --> 52:27.500]  Нет, но если откажет...
[52:27.500 --> 52:31.500]  Нет, речь, видимо, я, кажется, понял вопрос.
[52:31.500 --> 52:34.500]  Он переформулирует так.
[52:34.500 --> 52:37.500]  Рассмотрим другое разбиение, где в одну группу будет одна очень маленькая,
[52:37.500 --> 52:46.500]  другая очень большая, и если в маленькой группе кто-то сойдет с ума, то это не страшно, да?
[52:46.500 --> 52:54.500]  Нет, конечно, потому что сойти с ума из византийских узлов может любой.
[52:54.500 --> 53:01.500]  Я говорю, кто бы из этих трех не сошел с ума, все равно для алгоритма A у нас будет не более чем F отказов.
[53:01.500 --> 53:08.500]  Если ты их распределишь неравномерно, то если сойдет с ума узел P, у которого один албанский, то, конечно, никто не пострадает.
[53:08.500 --> 53:19.500]  А вот если сойдет с ума узел Q, то алгоритм A потеряет византийскими сразу много узлов, и тогда никаких гарантий для него уже не будет.
[53:19.500 --> 53:31.500]  Окей, с этим разобрались.
[53:31.500 --> 53:44.500]  Ну что, кажется, теорема доказана, да? Что мы скажем?
[53:44.500 --> 53:49.500]  Обычно она вызывает больше вопросов, но почему-то здесь мне сразу верю.
[53:49.500 --> 53:57.500]  Ладно, тогда давайте я поговорю про замечание относительно условий этой теоремы.
[53:57.500 --> 54:08.500]  Вот я сказал, что мы говорим, что у нас нет приватных цифровых подписей, но мы доверяем каналам.
[54:08.500 --> 54:16.500]  Еще один аспект. Мы нигде не делаем предположения оба синхронности сети, правда?
[54:16.500 --> 54:24.500]  Вот кажется, что эта теорема, эти рассуждения работают в ходе синхронной сети.
[54:24.500 --> 54:31.500]  Так что с одной стороны теорема довольно сильна, то есть даже в синхронной сети выполняется такая оценка снизу,
[54:31.500 --> 54:39.500]  но с другой стороны она исключает цифровые подписи. А мы собираемся использовать цифровые подписи.
[54:39.500 --> 54:46.500]  Это значит, что каждое сообщение доставляется за некоторое ограниченное время.
[54:46.500 --> 54:48.500]  Есть оценка сверху, надо время доставки сообщений.
[54:48.500 --> 54:53.500]  Короче говоря, мы здесь нигде не требовали о сети, чтобы она могла позволить себе работать медленно.
[54:53.500 --> 55:03.500]  Мы нигде этим не пользовались. Если мы нигде не пользовались этим способствием, то, видимо, его не нужно включать в условия теоремы.
[55:03.500 --> 55:11.500]  Но можно эту же оценку снизу доказать для других условий, а именно где у нас цифровые подписи могут даже быть,
[55:11.500 --> 55:16.500]  то мы готовы воспользоваться синхронной сетью, точнее частично синхронной.
[55:16.500 --> 55:42.500]  Итак, посмотрим на... Ещё раз доказываем, заново доказываем ту же самую теорему,
[55:42.500 --> 55:48.500]  только теперь не делаем предположений про то, что один узел может симулировать много других.
[55:48.500 --> 55:51.500]  Это может быть слишком практический случай цифровых подписей.
[55:51.500 --> 55:57.500]  Но зато у нас есть частично синхронная сеть, которая может задерживать сообщение.
[55:57.500 --> 56:03.500]  Опять покажем, что у нас имеется до края нижняя оценка. Опять начнём со случая N3F1.
[56:03.500 --> 56:11.500]  Предположим, что у нас есть три алгоритма.
[56:11.500 --> 56:18.500]  И пусть... Три алгоритма P, Q и R.
[56:18.500 --> 56:28.500]  И пусть снова этот алгоритм получил на вход 0, этот алгоритм получил на вход 0, этот алгоритм получил на вход что-нибудь.
[56:28.500 --> 56:39.500]  И мы запустили этот алгоритм, и может быть даже R не византийский, просто сеть между этими узлами работает очень быстро,
[56:39.500 --> 56:43.500]  а здесь у нас сообщение задерживает.
[56:43.500 --> 56:54.500]  И такое исполнение для узлов P0 и Q0 неотличимо от исполнения, где узел R вообще отказал, и дождаться мы его не можем.
[56:54.500 --> 57:00.500]  И в этом случае мы по свойствам задачи консенса должны рано или поздно завершиться.
[57:00.500 --> 57:07.500]  В мире, где R отказал, мы обязаны завершиться и выбрать 0.
[57:19.500 --> 57:23.500]  Просто потому что здесь медленная сеть.
[57:23.500 --> 57:26.500]  Рассмотрим другое исполнение.
[57:33.500 --> 57:35.500]  Три узла.
[57:36.500 --> 57:41.500]  И теперь, чтобы мне не сбиться...
[57:44.500 --> 57:50.500]  Давайте скажем, что у Q на входе 1, у R на входе 1, у P на входе что-то,
[57:50.500 --> 57:55.500]  но по-прежнему с ним очень тяжело общаться, потому что сеть очень медленная.
[57:55.500 --> 57:59.500]  Мы задерживаем здесь сообщение, насколько это потребуется.
[57:59.500 --> 58:06.500]  И снова алгоритмы Q1 и R1 не могут отличить это исполнение от исполнения, где P вообще отказывает.
[58:06.500 --> 58:10.500]  Не то чтобы он византийский, а просто не работает.
[58:10.500 --> 58:17.500]  И по тем же самым соображениям они в этом исполнении должны завершиться и выбрать 1.
[58:21.500 --> 58:25.500]  Ну а теперь строим третье исполнение.
[58:31.500 --> 58:37.500]  Вот здесь на входе будет 0, здесь на входе будет 1,
[58:40.500 --> 58:44.500]  а узел Q будет византийским.
[58:45.500 --> 58:56.500]  И он с узлом P будет общаться так, как общался узел Q в этом исполнении.
[58:57.500 --> 59:07.500]  То есть как будто бы у него сознание разделено на две части, и вот здесь он Q0, а здесь он Q1.
[59:09.500 --> 59:12.500]  А этот канал по-прежнему медленный.
[59:13.500 --> 59:19.500]  Давайте я буду медленный канал как-то обозначать, чтобы мы его отличали.
[59:19.500 --> 59:22.500]  Какой-то очень медленный канал.
[59:22.500 --> 59:25.500]  Здесь медленных каналов было 2.
[59:28.500 --> 59:32.500]  И здесь медленных каналов было тоже 2.
[59:36.500 --> 59:39.500]  Ну и что получается?
[59:40.500 --> 59:50.500]  Что вот это исполнение delta3, оно для узла P0 неотличимо от delta1.
[59:51.500 --> 59:58.500]  И так же, ну поскольку это исполнение неотличимое, то вот за некоторое время P0 неизбежно выберет значение,
[59:58.500 --> 01:00:02.500]  потому что он выбирал это значение в delta1, он выберет значение 0.
[01:00:03.500 --> 01:00:17.500]  Ну и по тем же самым рассуждениям, узел R1, поскольку эти два исполнения для R1 неотличимы от исполнения delta3,
[01:00:17.500 --> 01:00:23.500]  поэтому если он завершался здесь и выбирал 1, то он также завершится здесь и тоже выберет 1.
[01:00:28.500 --> 01:00:30.500]  Гораздо проще, оказывается, да?
[01:00:31.500 --> 01:00:37.500]  То есть у нас либо нет цифровых подписей, либо у нас есть задержки в сети,
[01:00:37.500 --> 01:00:43.500]  все это приводит к тому, что мы не можем преодолеть даже 3 отказов.
[01:00:43.500 --> 01:00:50.500]  Но для того, чтобы обобщить эти рассуждения на общий случай, когда у нас n не больше, чем 3f,
[01:00:50.500 --> 01:00:53.500]  то что мы делаем? Как легко догадаться, наверное.
[01:00:55.500 --> 01:00:59.500]  Ну да, мы разделим на 3 группы и сделаем примерно то же самое.
[01:01:01.500 --> 01:01:03.500]  Что? Что значит повести?
[01:01:13.500 --> 01:01:15.500]  Нет, ну не хочешь неверно.
[01:01:17.500 --> 01:01:23.500]  Если ты говоришь, что клиент своему, у меня так не бывает, то он тоже может тебе поверить.
[01:01:23.500 --> 01:01:26.500]  Но если так случится, то ты ничем себя не защитишь.
[01:01:26.500 --> 01:01:31.500]  Вот мы хотим строить алгоритмы, которые не то чтобы верят или не верят, что бывает или не бывает,
[01:01:31.500 --> 01:01:33.500]  бывают по-всякому.
[01:01:36.500 --> 01:01:41.500]  У нас есть вот уж точно разными способами, в разных предположениях,
[01:01:41.500 --> 01:01:47.500]  оценка снизу, что для преодоления f сбоев в византийском окружении нам требуется,
[01:01:47.500 --> 01:01:50.500]  по крайней мере, 3f плюс 1 узел.
[01:01:56.500 --> 01:01:58.500]  Какие вопросы у нас остаются?
[01:01:58.500 --> 01:02:00.500]  Достижимы ли это оценка снизу?
[01:02:00.500 --> 01:02:03.500]  То есть можем ли мы построить алгоритмы 3 f плюс 1 реплики?
[01:02:03.500 --> 01:02:06.500]  Ответ – да, можем. Через неделю мы это увидим.
[01:02:09.500 --> 01:02:15.500]  У нас остается замечание о том, что когда f, когда действительное число отказов византийских
[01:02:15.500 --> 01:02:20.500]  превышает заложенное значение, то мы теряем всякие гарантии, мы уже не можем
[01:02:20.500 --> 01:02:26.500]  отличить сбоенный узел, мы можем принять сбоенный узел за корректный,
[01:02:26.500 --> 01:02:30.500]  в отличие от модели, где у нас были отказы узлов.
[01:02:32.500 --> 01:02:39.500]  Ну и давайте за оставшееся время попробуем и попробуем вам объяснить,
[01:02:39.500 --> 01:02:42.500]  с помощью каких инструментов, помимо криптографии,
[01:02:42.500 --> 01:02:47.500]  помимо цифровых подписей и хэш-функций, про хэш-функции я вам не сказал,
[01:02:47.500 --> 01:02:50.500]  помимо всего этого, какие инструменты могут быть использованы,
[01:02:50.500 --> 01:02:55.500]  какие инструменты нужно использовать для того, чтобы жить в такой модели отказов.
[01:02:56.500 --> 01:02:58.500]  Да, маленькое замечание, которое я упустил.
[01:03:01.500 --> 01:03:04.500]  А именно, что когда мы пользуемся цифровыми подписями, то мы, как правило,
[01:03:04.500 --> 01:03:08.500]  подписываем не само сообщение, это может быть довольно затратно,
[01:03:08.500 --> 01:03:11.500]  мы подписываем хэш от сообщения.
[01:03:12.500 --> 01:03:16.500]  Хэш-функции тоже могут быть криптографическими, как цифровые подписи.
[01:03:16.500 --> 01:03:19.500]  Да, и, наверное, я не сказал какие-то очевидные вещи,
[01:03:19.500 --> 01:03:24.500]  но, надеюсь, мы, люди, все понимаем здесь, что подпись – это не то,
[01:03:24.500 --> 01:03:27.500]  чтобы ее можно оторвать от сообщения, прикрыть к другому сообщению,
[01:03:27.500 --> 01:03:30.500]  подпись от сообщения неотделима.
[01:03:30.500 --> 01:03:36.500]  То есть, вы подписываете хэш, и вы не можете, если вы адверсере,
[01:03:36.500 --> 01:03:39.500]  то есть, вы злоумышленник, вы числительно ограничены,
[01:03:39.500 --> 01:03:41.500]  то вы не можете ни коллизии хэш-функций подбирать,
[01:03:41.500 --> 01:03:44.500]  так бы вы могли подобрать другое сообщение с тем же самым хэшом
[01:03:44.500 --> 01:03:46.500]  и переиспользовать подпись.
[01:03:46.500 --> 01:03:49.500]  И вы не можете, конечно же, саму подпись подделать,
[01:03:49.500 --> 01:03:52.500]  потому что вы не можете дискретно алгорифом считать эффективно,
[01:03:52.500 --> 01:03:55.500]  или вы не можете на простые множители складывать что-то.
[01:03:55.500 --> 01:03:58.500]  Вот мы в это верим, в смысле, что это нельзя делать эффективно,
[01:03:58.500 --> 01:04:03.500]  и вот на этом предположении все держится у нас, вся аутентификация.
[01:04:03.500 --> 01:04:10.500]  Ну что ж, оценку снизу мы доказали, давайте теперь построим какой-то алгоритм.
[01:04:10.500 --> 01:04:13.500]  Он будет решать задачу бинарного консенсуса,
[01:04:13.500 --> 01:04:17.500]  что оно абсолютно бесполезно, но цель этого алгоритма не в том для нас,
[01:04:17.500 --> 01:04:21.500]  не в том, чтобы консенсус решать, а в том, чтобы продемонстрировать,
[01:04:21.500 --> 01:04:26.500]  с помощью какого инструмента мы в следующий раз можем строить
[01:04:26.500 --> 01:04:29.500]  какие-то уже разумные и полезные алгоритмы.
[01:04:29.500 --> 01:04:38.500]  Итак, решаем задачу бинарного консенсуса алгоритм Ben-Ora.
[01:04:38.500 --> 01:04:48.500]  У нас есть n узлов, у них на входе 0 и 1, они должны выбрать общее значение, как обычно.
[01:04:48.500 --> 01:04:52.500]  Давайте я сначала расскажу про версию алгоритма,
[01:04:52.500 --> 01:05:00.500]  которая работает в модели crash-failures, то есть с отказами узлов, но без изантийского поведения.
[01:05:01.500 --> 01:05:13.500]  У нас для этого уже есть Paxos и Raft, но мы удобно алгоритм сначала изложить в этой модели отказов.
[01:05:13.500 --> 01:05:21.500]  Итак, у каждого узла будет вход, и на старте каждый узел будет...
[01:05:21.500 --> 01:05:24.500]  У каждого узла будет состояние.
[01:05:24.500 --> 01:05:28.500]  Это состояние образовано, во-первых, переменной preference,
[01:05:28.500 --> 01:05:33.500]  в которую изначально передается вход узла.
[01:05:33.500 --> 01:05:38.500]  Preference это текущее пожелание узла относительно выбора.
[01:05:38.500 --> 01:05:42.500]  Вот он хочет, чтобы было выбрано такое значение.
[01:05:42.500 --> 01:05:48.500]  И у каждого узла будет переменная round, в каком round он находится,
[01:05:48.500 --> 01:05:54.500]  и в каждом раунде алгоритм пытается что-то выбрать.
[01:05:54.500 --> 01:05:59.500]  Изначально все в нулевом раунде.
[01:05:59.500 --> 01:06:07.500]  Алгоритм делится на раунды, в каждом раунде две фазы, в каждой фазе два шага.
[01:06:07.500 --> 01:06:13.500]  Итак, первая фаза.
[01:06:13.500 --> 01:06:22.500]  Каждый узел отправляет другим узлам, всем другим узлам сообщение vote,
[01:06:22.500 --> 01:06:32.500]  куда прикладывает свой preference и номер раунды.
[01:06:32.500 --> 01:06:40.500]  На втором шаге первые фазы.
[01:06:40.500 --> 01:06:45.500]  Каждый узел дожидается, пока он не соберет...
[01:06:45.500 --> 01:06:48.500]  Сколько у нас всего узлов, я не сказал.
[01:06:48.500 --> 01:06:52.500]  Всего узлов у нас...
[01:06:52.500 --> 01:07:08.500]  Ну, видимо, 2F плюс 1 для случая crash failures.
[01:07:08.500 --> 01:07:19.500]  Пока не соберет большинство сообщений о других узлах.
[01:07:19.500 --> 01:07:24.500]  Где white? Ну, либо 0, либо 1.
[01:07:24.500 --> 01:07:30.500]  Давайте это напишем, что задача бинарная.
[01:07:30.500 --> 01:07:34.500]  Вот только 0 и 1.
[01:07:34.500 --> 01:07:41.500]  На второй фазе, перед второй фазой, вернее, после того, как узел,
[01:07:41.500 --> 01:07:45.500]  после того, как он собрал большинство голосов, он смотрит на эти голоса.
[01:07:45.500 --> 01:07:52.500]  Если он видит, что все входы, все волты, которые он получил с одним и тем же значением,
[01:07:52.500 --> 01:08:18.500]  то он посылает всем узлам сообщение propose.
[01:08:18.500 --> 01:08:25.500]  Ну, либо если голоса разделились, которые он получил, там были и 0, и 1,
[01:08:25.500 --> 01:08:31.500]  то вместо V посылается знак вопроса.
[01:08:31.500 --> 01:08:41.500]  То есть, либо propose знак вопроса R.
[01:08:41.500 --> 01:09:04.500]  И на втором шаге второй фазы каждый узел опять собирает большинство пропозов.
[01:09:04.500 --> 01:09:14.500]  Знак просто плохо рисовать уже. V или знак вопроса R.
[01:09:14.500 --> 01:09:20.500]  И дальше анализирует то, что он собрал. У нас три ветки.
[01:09:20.500 --> 01:09:33.500]  Если все сообщения, пропоз, который он получил, содержали одно и то же значение V,
[01:09:33.500 --> 01:09:38.500]  оператор мне видно?
[01:09:38.500 --> 01:09:44.500]  Давай проверим, в смысле, удостоверим все, что меня видно.
[01:09:44.500 --> 01:09:52.500]  Видно, да? Давай все-таки немного смещусь, чтобы было безопаснее.
[01:09:52.500 --> 01:10:00.500]  Если все пропозы, которые узел собрал, содержали какое-то значение V,
[01:10:00.500 --> 01:10:05.500]  то алгоритм просто выбирает в этом раунде V.
[01:10:05.500 --> 01:10:13.500]  Вот это выбор в смысле консенсуса.
[01:10:13.500 --> 01:10:34.500]  Если же узел получил хотя бы один пропоз без знака вопроса,
[01:10:34.500 --> 01:10:45.500]  то тогда он обновляет свой преференс.
[01:10:45.500 --> 01:10:58.500]  Если же все пропозы содержали знак вопроса,
[01:10:58.500 --> 01:11:13.500]  то тогда в качестве преференса для следующего раунда выбирается что?
[01:11:13.500 --> 01:11:28.500]  Нет, ты совсем не чувствуешь идею. Мы подбрасываем монетку.
[01:11:28.500 --> 01:11:31.500]  У нас же бинальный консенсус. Нам нужно выбрать у ныря единицы.
[01:11:31.500 --> 01:11:41.500]  Мы знаем, что у нас есть у ныря единицы среди узлов, так что мы подбросим монетку и выберем что-то случайное.
[01:11:41.500 --> 01:11:44.500]  Вот такой алгоритм. Нам нужно теперь доказать, что он коллекционный,
[01:11:44.500 --> 01:11:47.500]  а потом дальше из него сделать какую-то византийскую версию.
[01:11:47.500 --> 01:11:54.500]  Но для начала вопрос на понимание, а верно ли, что алгоритм коллекционно сформулирован вообще?
[01:11:54.500 --> 01:12:04.500]  Нет, ну разумеется, он может не закончиться. Мы все время доказывали про это.
[01:12:04.500 --> 01:12:11.500]  Конечно, он уже монетки подбрасывает.
[01:12:11.500 --> 01:12:19.500]  Тут можно усомниться просто в корректной постановке этого алгоритма.
[01:12:19.500 --> 01:12:24.500]  Ну вот смотрите, у нас есть три ветки, по которым мы можем пойти в конце каждого раунда.
[01:12:24.500 --> 01:12:31.500]  Да, вот мы выиграли один из трех исходов и после этого перешли в следующий раунд, увеличили наши перемены.
[01:12:31.500 --> 01:12:38.500]  Так вот, второй переход вызывает сомнения, потому что а вдруг мы получили прополз и с нулем, и с единицей?
[01:12:38.500 --> 01:12:44.500]  Не совсем понятно, как мы тогда действуем. Правда?
[01:12:44.500 --> 01:12:47.500]  Ну вот утверждение, что такого не бывает просто.
[01:12:47.500 --> 01:12:52.500]  Что в пределах одного раунда вы не можете получить два проползу с разными значениями.
[01:12:52.500 --> 01:13:07.500]  Почему? Потому что если вдруг такое произошло, то есть какой-то узел х отправил прополз 1r,
[01:13:07.500 --> 01:13:17.500]  то это узел у отправил в этом же раунде прополз 0r.
[01:13:17.500 --> 01:13:31.500]  Так вот, такого не бывает, потому что чтобы отправить прополз 1r, нужно сначала собрать большинство голосов за ноль,
[01:13:31.500 --> 01:13:41.500]  за единицу, простите, а здесь точно также за ноль.
[01:13:41.500 --> 01:13:45.500]  Ну а значит в пересечении есть какой-то узел, который поголосовал из-за ноль из-за один из предел одного раунда,
[01:13:45.500 --> 01:13:54.500]  такого не бывает. Так что алгоритм, по крайней мере, можно закодировать, и тут ни однозначности не будет.
[01:13:54.500 --> 01:14:01.500]  Но что нас беспокоит? Опять нас беспокоит agreement.
[01:14:01.500 --> 01:14:06.500]  Мы хотим показать, что если два узла убирают значения, то они убирают одно и то же.
[01:14:06.500 --> 01:14:14.500]  Ну мы поступим так, мы скажем, что пусть какой-то узел в конце какого-то раунда пошел по этой ветке.
[01:14:14.500 --> 01:14:20.500]  То есть он получил, почему он это сделал? Потому что он получил все проползы, скажем, за ноль.
[01:14:20.500 --> 01:14:27.500]  Ну тогда я утверждаю, что в следующем раунде у всех узлов на входе будет один и тот же preference.
[01:14:27.500 --> 01:14:32.500]  Ну не на входе, а просто все узлы. Почему?
[01:14:32.500 --> 01:14:39.500]  Если какой-то узел пошел по первой ветке, то это означает вот какой-то узел х.
[01:14:39.500 --> 01:14:47.500]  Если он сделал выбор, скажем, выбрал один, то это означает, что какой-то quorum прислал ему
[01:14:47.500 --> 01:14:54.500]  прополз 1r.
[01:14:54.500 --> 01:15:06.500]  И при этом любой другой узел y в этом же раунде собрал тоже большинство проползов каких-то.
[01:15:06.500 --> 01:15:13.500]  Ну в том числе, по крайней мере, один прополз от узла, который был в пересечении, то есть в этом quorum.
[01:15:13.500 --> 01:15:21.500]  И вот какой-то узел, по крайней мере один, прислал y прополз со значением 1.
[01:15:21.500 --> 01:15:27.500]  Ну а мы сказали, что в этом случае этот узел пойдет по этой ветке и обновит себе preference до 1.
[01:15:27.500 --> 01:15:34.500]  То есть если в каком-то раунде один из узлов выбрал значение, то в следующем раунде в preference
[01:15:34.500 --> 01:15:40.500]  каждого другого узла будет то же самое значение, а дальше они уже просто не могут сделать что-то иначе.
[01:15:40.500 --> 01:15:47.500]  Ну вот, абсолютно бесполезный для нас алгоритм, который что-то делает, мы как-то доказали.
[01:15:47.500 --> 01:15:55.500]  Короче, дальше нам нужен для другого, для того, чтобы из него сделать византийский.
[01:15:55.500 --> 01:16:05.500]  Ну вот, я сейчас хочу сделать из него византийский, при этом не сильно что-то меняю.
[01:16:05.500 --> 01:16:10.500]  Сейчас я не буду строить его инкрементально, я просто сейчас с неба его брошу на вас,
[01:16:10.500 --> 01:16:16.500]  а дальше мы из него сделаем какие-то выводы. Вот целыми будут выводы и не самый алгоритм.
[01:16:16.500 --> 01:16:24.500]  Во-первых, чтобы сделать из этого алгоритма византийский, мы возьмем 5f плюс один узел.
[01:16:24.500 --> 01:16:30.500]  Тут сейчас будут какие-то подогнанные числа, опять же, не нужно сейчас сильно в какую-то интуицию погружаться,
[01:16:30.500 --> 01:16:38.500]  нам это не очень важно. Мы скажем, что опять у каждого узла есть preference, узлы находятся в раундах,
[01:16:38.500 --> 01:16:48.500]  и в начале первой фазы каждого раунда мы отправляем вводы, а потом дожидаемся какого числа вводов.
[01:16:48.500 --> 01:16:59.500]  Какого числа мы можем себе позволить дожидаться, если у нас 5f плюс один узел, и мы готовы пережить f отказов.
[01:16:59.500 --> 01:17:05.500]  И мы дожидаемся 4f плюс одного ответа.
[01:17:05.500 --> 01:17:16.500]  И если оказывается, что среди этих ответов, среди этих вводов больше 3f одинаковых,
[01:17:16.500 --> 01:17:23.500]  то мы посылаем всем проповз с этим значением.
[01:17:23.500 --> 01:17:30.500]  Ну а иначе посылаем снова знак вопроса.
[01:17:30.500 --> 01:17:37.500]  Ну а здесь мы снова дожидаемся 4f плюс одного проповза.
[01:17:37.500 --> 01:17:50.500]  И если мы получили больше 3f проповзов с одним и тем же значением, то мы его выбираем.
[01:17:50.500 --> 01:18:04.500]  Если мы получили по крайней мере f проповзов с одним значением, то мы обновляем свой preference,
[01:18:04.500 --> 01:18:11.500]  чуть хуже. Ну а в остальных случаях мы подбрасываем монетку.
[01:18:11.500 --> 01:18:17.500]  Да, забыл провалидировать ваше понимание в прошлый раз, в смысле в алгоритме без византийских отказов.
[01:18:17.500 --> 01:18:22.500]  А почему он завершается?
[01:18:22.500 --> 01:18:30.500]  Ну давайте по-другому. Можно ли в нем заменить вот эту процедуру подбрасывания монетки, скажем, на ноль?
[01:18:30.500 --> 01:18:45.500]  Или на один? Дотерминированно?
[01:18:45.500 --> 01:18:51.500]  Что бы это значило? В смысле, могу ли закодировать так?
[01:18:51.500 --> 01:18:56.500]  Ну действительно, если ты получил только знаки вопроса, ты знаешь, что у тебя на входе 0 и 1 есть.
[01:18:56.500 --> 01:19:00.500]  Но стоит ли так делать?
[01:19:00.500 --> 01:19:06.500]  Не стоит, потому что, понятно, тогда получится детерминированный алгоритм, подверженный FOPтиареме.
[01:19:06.500 --> 01:19:11.500]  В нем есть лайфлог, который может длиться бесконечно.
[01:19:11.500 --> 01:19:19.500]  С подбрасыванием монетки все лучше. Мы знаем, что на каждой фазе у нас могут быть проповзы
[01:19:19.500 --> 01:19:24.500]  только со знакомыми вопроса или с одним из значений, либо с 0, либо с единицей.
[01:19:24.500 --> 01:19:31.500]  Так что в каждом раунде у нас все узлы делятся на узлы, которые получили одно значение,
[01:19:31.500 --> 01:19:35.500]  и узлы, которые получили только вопросы.
[01:19:35.500 --> 01:19:43.500]  Так что в каждом раунде вероятность того, что в этом раунде все закончатся одним и тем же преференсом,
[01:19:43.500 --> 01:19:50.500]  она кажется не меньше, чем единица на 2 в степени N.
[01:19:50.500 --> 01:19:53.500]  Верно?
[01:19:53.500 --> 01:19:58.500]  Потому что какие-то узлы уже получили общее значение, в качестве преференса уже выбрали общее значение,
[01:19:58.500 --> 01:20:05.500]  а какие-то узлы подбрасывают монетки, но в худшем случае это все узлы.
[01:20:05.500 --> 01:20:09.500]  Ну а так что у нас есть, пусть экспоненциальные, но все-таки от ожидания того,
[01:20:09.500 --> 01:20:13.500]  что алгоритм какое-то количество итерации сделает и выберет значение.
[01:20:13.500 --> 01:20:17.500]  Но он довольно тупой, он даже не пытается консенсусить, он просто подбрасывает монетки,
[01:20:17.500 --> 01:20:20.500]  он проверяет, что они правильно упали все.
[01:20:20.500 --> 01:20:22.500]  То есть не то, что очень сложно.
[01:20:22.500 --> 01:20:25.500]  Ну а дальше мы с ним делаем византийский.
[01:20:25.500 --> 01:20:32.500]  Подкручиваем параметры, теперь у нас 4f плюс 1q, и 3f это пороги.
[01:20:32.500 --> 01:20:37.500]  Так вот, давайте сейчас покажем, что примерно таким же образом,
[01:20:37.500 --> 01:20:44.500]  что алгоритмом остается коррекцион даже при условии византийских отказов.
[01:20:44.500 --> 01:20:53.500]  Ну давай напишем else.
[01:20:53.500 --> 01:21:01.500]  Это конечно не остается, потому что у тебя византийские узлы могут просто выдумывать что-то.
[01:21:15.500 --> 01:21:19.500]  Те же самые шаги в рассуждениях.
[01:21:19.500 --> 01:21:25.500]  Опять нужно побеспокоиться о том, что вот эти 3 ветки корректно определены.
[01:21:25.500 --> 01:21:32.500]  Почему не может быть такого, что во второй ветке мы можем пойти и по ветке с 0, и по ветке с 1?
[01:21:32.500 --> 01:21:38.500]  То есть почему не может быть такого, что какой-то узел получил 2 f проповозов,
[01:21:38.500 --> 01:21:45.500]  f плюс 1 проповоз с 0, f плюс 1 проповоз с 1?
[01:21:45.500 --> 01:21:50.500]  Опять, почему так могло случиться?
[01:21:50.500 --> 01:21:58.500]  Потому что набрался quorum узлов, которые отправили x, допустим, единицы в качестве голосов,
[01:21:58.500 --> 01:22:02.500]  а другому узлоне отправили в качестве голосов 0.
[01:22:02.500 --> 01:22:05.500]  Вот сейчас говорю некорректно.
[01:22:05.500 --> 01:22:09.500]  Нашелся quorum, который отправил в качестве ваута единицы, нашелся quorum,
[01:22:09.500 --> 01:22:13.500]  который отправил в качестве значения ваута 0.
[01:22:13.500 --> 01:22:24.500]  Какого размера эти quorums?
[01:22:24.500 --> 01:22:28.500]  Ну нет, это сейчас неправда.
[01:22:28.500 --> 01:22:35.500]  Еще раз, чтобы проголосовать за проповоз, мы дожидаемся 4 f плюс 1 от ваута,
[01:22:35.500 --> 01:22:43.500]  и если среди них по крайней мере 3 f одинаковых, то мы посылаем какой-то проповоз.
[01:22:43.500 --> 01:22:51.500]  Вот если мы посылаем проповоз 1, то это значит, что мы получили по крайней мере 3 f ваутов с единицей.
[01:22:51.500 --> 01:22:59.500]  И здесь мы получили по крайней мере 3 f ваутов с 0.
[01:22:59.500 --> 01:23:07.500]  Больше 3 f, да. Спасибо.
[01:23:07.500 --> 01:23:13.500]  Но какие дальше рассуждения? Дальше наши рассуждения вообще, говоря, ломаются.
[01:23:13.500 --> 01:23:18.500]  Но по крайней мере нельзя сказать, что quorums пересекаются по одному узлу,
[01:23:18.500 --> 01:23:24.500]  а этот узел отправил только один ваут. В пересечении этих quorums могли находиться византийские узлы,
[01:23:24.500 --> 01:23:29.500]  они могли врать, они могли отправить разные вауты разным узлам в одном раунде.
[01:23:29.500 --> 01:23:34.500]  Сколько узлов в пересечении?
[01:23:34.500 --> 01:23:42.500]  Вот здесь всего у нас 5 f плюс 1, здесь по крайней мере 3 f плюс 1, а здесь по крайней мере 3 f плюс 1.
[01:23:42.500 --> 01:23:46.500]  Значит, в пересечении у нас больше f узлов.
[01:23:46.500 --> 01:23:55.500]  А это значит, что среди них есть по крайней мере один корректный.
[01:23:55.500 --> 01:24:02.500]  И вот ровно поэтому мы получаем наше утверждение, что не могло быть такого,
[01:24:02.500 --> 01:24:08.500]  что получилось два разных проповза в пределах одного раунда.
[01:24:08.500 --> 01:24:12.500]  Первый шаг готов. Второй шаг, напомню, в чем он состоял.
[01:24:12.500 --> 01:24:18.500]  Мы говорили, что если какой-то узел корректный пошел по этой ветке, по первой ветке, то есть он выбрал значение,
[01:24:18.500 --> 01:24:24.500]  то в следующем раунде все корректные узлы в качестве преференса будут иметь одно и то же вот и это же значение.
[01:24:24.500 --> 01:24:31.500]  Почему узел x пошел по первой ветке? Потому что он получил много одинаковых пропозов.
[01:24:38.500 --> 01:24:42.500]  Посмотрим на другой узел y в пределах того же раунда.
[01:24:42.500 --> 01:24:47.500]  Вот он ожидал 4 f плюс 1 пропоз.
[01:24:54.500 --> 01:24:56.500]  Сколько в пересечении узлов?
[01:25:04.500 --> 01:25:06.500]  Изучаем рифметику.
[01:25:09.500 --> 01:25:20.500]  Вот в пересечении у нас такое количество узлов.
[01:25:20.500 --> 01:25:27.500]  И смотрите, среди них могут быть византийские, но их этих византийских не более чем f.
[01:25:29.500 --> 01:25:32.500]  А значит, по крайней мере, f плюс 1 честных.
[01:25:38.500 --> 01:25:49.500]  А это значит, что если какой-то узел в раунде пошел по первой ветке, то любой другой узел получил,
[01:25:49.500 --> 01:25:57.500]  по крайней мере, f плюс 1 пропоз с вот этой самой единицей, вот честных узлов.
[01:25:57.500 --> 01:26:01.500]  Поэтому он идет по второй ветке. Значит, он обновит себе преференс.
[01:26:01.500 --> 01:26:07.500]  Ну а других пропозов, конкурирующих в одном раунде, не бывает, потому что мы от них защитили здесь.
[01:26:08.500 --> 01:26:15.500]  Так что в следующем раунде на старте у всех честных узлов на входе будет одно и то же значение.
[01:26:15.500 --> 01:26:22.500]  Ну вообще говоря, и этого мало, и нужно дальше убедиться, что оно не потеряется.
[01:26:22.500 --> 01:26:33.500]  То есть, если вы честный узел, и дальше вы собираете, скажем, 4 f плюс 1 голос от всех узлов,
[01:26:33.500 --> 01:26:47.500]  то вы знаете, что среди этих 4 f плюс 1 не более чем f византийских.
[01:26:47.500 --> 01:27:04.500]  Поэтому после первого раунда вы получите, по крайней мере, 3 f волтов с одинаковым значением.
[01:27:04.500 --> 01:27:12.500]  Так что если на старте раунда все корректные узлы стартовались с одинаковым преференсом,
[01:27:12.500 --> 01:27:18.500]  то это значит, что дальше они его тоже не потеряют. Ну и такие же рассуждения для второй фазы.
[01:27:18.500 --> 01:27:30.500]  Вот такой алгоритм. Почему он нам полезен? Он нам полезен, потому что алгоритм сам бесполезен.
[01:27:30.500 --> 01:27:36.500]  Предлагается его забыть сразу же. Он нам полезен будет, потому что он демонстрирует технику,
[01:27:36.500 --> 01:27:41.500]  которую мы дальше собираемся использовать, а именно он нам говорит о том,
[01:27:41.500 --> 01:27:49.500]  как правильно работать с коровами в византийском окружении.
[01:27:49.500 --> 01:28:02.500]  Вот давайте алгоритм сотру, чтобы забыть о нем. Он нам правда не важен.
[01:28:02.500 --> 01:28:26.500]  Нам важно, что мы в нем увидели, как работают византийские клорумы.
[01:28:26.500 --> 01:28:32.500]  Это второй наш важный инструмент вместе с криптографией и с цифровыми подписями,
[01:28:32.500 --> 01:28:40.500]  с криптографическими хэш-функциями. Давайте вспомним про интуицию, стоящую за кворумами.
[01:28:40.500 --> 01:28:44.500]  У нас узлы могут отказывать, поэтому мы не хотим дожидаться ответа от всех.
[01:28:44.500 --> 01:28:49.500]  Вспомним, как мы кворумы использовали на второй лекции, когда мы говорили про атомарный регистр.
[01:28:49.500 --> 01:28:54.500]  У нас была операция записи, операция чтения, и мы писали версионируемые значения,
[01:28:54.500 --> 01:29:04.500]  чтобы потом отличать старые от новых. Вот пусть мы что-то на кворум пишем,
[01:29:04.500 --> 01:29:12.500]  кворум на запись, а потом с кворума читаем, кворум на чтение.
[01:29:12.500 --> 01:29:21.500]  Пишем мы какую-то пару значения и временная метка.
[01:29:21.500 --> 01:29:26.500]  Что нам кворумы гарантировали? Что если мы записали значение на кворум,
[01:29:26.500 --> 01:29:38.500]  версионируемое, чтение завершилось, и после этого мы стартовали чтение,
[01:29:38.500 --> 01:29:45.500]  то кворум на чтение пересечется с кворумом на запись.
[01:29:45.500 --> 01:29:52.500]  Как мы по-другому, как мы читаем? Мы собираем ответы с любого кворума на чтение.
[01:29:52.500 --> 01:29:58.500]  Эти ответы могут быть двух сортов. Во-первых, мы могли получить ответ от реплик,
[01:29:58.500 --> 01:30:07.500]  которые вошли в R, разумеется, но не вошли в W, и в них будет устаревшее значение.
[01:30:07.500 --> 01:30:13.500]  И актуальные ответы от реплик, которые входили в кворум на запись.
[01:30:13.500 --> 01:30:20.500]  Как мы отличим эти два типа ответов? Вот актуальные от устаревших.
[01:30:20.500 --> 01:30:25.500]  Просто по временной метке. Мы выберем максимум, и мы будем уверены,
[01:30:25.500 --> 01:30:30.500]  что мы взяли ответ с одной из репликов пересечения кворумов.
[01:30:30.500 --> 01:30:39.500]  А теперь представим, что у нас мир византийский. И теперь у нас от реплик кворума R
[01:30:39.500 --> 01:30:48.500]  три типа ответов. Это устаревшие ответы от честных реплик, которые не вошли в пересечение.
[01:30:48.500 --> 01:30:55.500]  Это актуальные ответы от честных реплик, которые вошли в пересечение.
[01:30:55.500 --> 01:31:01.500]  И выдуманные ответы от византийских реплик, каких угодно.
[01:31:01.500 --> 01:31:08.500]  Давайте я нарисую зеленым.
[01:31:08.500 --> 01:31:16.500]  Это реплики с актуальным значением, которые ведут себя честно.
[01:31:16.500 --> 01:31:23.500]  И они дают нам максимально актуальную версию значения.
[01:31:23.500 --> 01:31:34.500]  И есть византийские узлы. Они находятся здесь, они находятся где-то здесь, и они значения выдумывают.
[01:31:34.500 --> 01:31:40.500]  И теперь вы не можете просто так отличить. То есть вы можете по-прежнему отличить корректные
[01:31:40.500 --> 01:31:46.500]  устаревшие значения от корректных актуальных по временной метке.
[01:31:46.500 --> 01:31:50.500]  Но вы не можете отличить корректные актуальные от выдуманных.
[01:31:50.500 --> 01:31:53.500]  Вы не можете отличить зеленые ответы от красных.
[01:31:53.500 --> 01:32:00.500]  В самом деле, что мешает византийскому узлу просто выдумать значения с временной меткой 100-500.
[01:32:00.500 --> 01:32:10.500]  Как же быть?
[01:32:10.500 --> 01:32:14.500]  Но зачем? Я вам только что алгоритм рисовал, а потом стирал его.
[01:32:14.500 --> 01:32:27.500]  Потратил столько сил.
[01:32:27.500 --> 01:32:30.500]  Вот мы не можем просто выбрать значения с максимальной временной меткой.
[01:32:30.500 --> 01:32:36.500]  Нам нужно какой-то более сложный протокол чтения с Quorum теперь.
[01:32:36.500 --> 01:32:41.500]  Нам нужно, чтобы зеленые ответы подавили красные ответы.
[01:32:41.500 --> 01:32:51.500]  Вот предлагается сделать так. Сказать, что у нас теперь любые два Quorum'а в нашей системе
[01:32:51.500 --> 01:33:00.500]  византийских Quorum'ов пересекаются. Вот Quorum на запись, Quorum на чтение.
[01:33:00.500 --> 01:33:06.500]  Что два этих Quorum'а должны пересекаться, по крайней мере, по какому количеству узлов.
[01:33:06.500 --> 01:33:11.500]  У нас, видите, здесь было два варианта. Я, собственно, хочу сейчас про эти два варианта рассказать.
[01:33:11.500 --> 01:33:24.500]  По 2F плюс 1 узлу. Иначе говоря, в пересечении, по крайней мере, F плюс один корректный.
[01:33:24.500 --> 01:33:34.500]  То есть я хочу, чтобы число честных репликов пересечения Quorum'ов на запись чтения
[01:33:34.500 --> 01:33:40.500]  было больше, чем число византийских узлов, которые могут выдумывать ответы.
[01:33:40.500 --> 01:33:51.500]  Тогда читать я буду так. Я соберу ответы с Quorum'а, оставлю только те, которых просто больше, чем F,
[01:33:51.500 --> 01:34:01.500]  и среди них выберу максимальный timestamp. То есть я хочу, чтобы честные реплики с актуальным значением нашего регистра
[01:34:01.500 --> 01:34:06.500]  количеством просто задавили византийские реплики, которые выдумывают значения.
[01:34:06.500 --> 01:34:09.500]  Для этого я беру Quorum'ы пожирнее.
[01:34:13.500 --> 01:34:18.500]  Ну максимально, разумеется. Если ты ничего не понял, нужно заново объяснять.
[01:34:18.500 --> 01:34:20.500]  С какого момента?
[01:34:25.500 --> 01:34:38.500]  У тебя проблема в том, что не актуальные ответы от честных узлов, это вся белая область,
[01:34:38.500 --> 01:34:43.500]  актуальные ответы от честных узлов и выдуманные ответы от византийских узлов.
[01:34:43.500 --> 01:34:47.500]  И вот эти ответы от этих ты легко отмечаешь, потому что у этих меньше timestamp.
[01:34:47.500 --> 01:34:56.500]  Беда в том, что ты не различаешь зеленые и красные. На уровне твоей логики с версионированием.
[01:34:56.500 --> 01:35:03.500]  Но ты различаешь их количеством. Ты говоришь, сделаю так, чтобы зеленых было больше, чем красных.
[01:35:03.500 --> 01:35:13.500]  Если я это гарантирую, то есть если я гарантирую, что у меня зеленых, по крайней мере F+,
[01:35:13.500 --> 01:35:21.500]  то я могу, получив ответ из Quorum'а, сначала оставить только те ответы, которые повторяются,
[01:35:21.500 --> 01:35:25.500]  по крайней мере F+, один раз, и среди них выбрать максимум.
[01:35:26.500 --> 01:35:37.500]  Вот максимум отфильтрует эти вопросы, эти ответы, а ограничение на F+, F1 копию отфильтрует красные ответы.
[01:35:42.500 --> 01:35:45.500]  То есть я два фильтра использую.
[01:35:45.500 --> 01:36:00.500]  Такая система Quorum'ов называется маскирующей.
[01:36:00.500 --> 01:36:14.500]  И есть второй тип Quorum'ов. Второй тип систем Quorum'ов.
[01:36:14.500 --> 01:36:21.500]  Где Quorum' на запись и Quorum' на чтение пересекаются, по крайней мере, по F+,
[01:36:22.500 --> 01:36:27.500]  или иначе, по крайней мере, по одному корректному.
[01:36:31.500 --> 01:36:37.500]  Вот нам здесь этого было достаточно. Мы выбирали между 0 и 1, грубо говоря,
[01:36:37.500 --> 01:36:42.500]  и нам нужно было убедиться, что никакой корректный узел не мог проголосовать дважды.
[01:36:42.500 --> 01:36:46.500]  Есть более общая интуиция. Эта система Quorum'ов называется
[01:36:52.500 --> 01:36:54.500]  disseminating, рассеивающая.
[01:36:54.500 --> 01:37:00.500]  Тут название, я не знаю, насколько они удачно говорящие. Мне кажется, что не очень.
[01:37:00.500 --> 01:37:10.500]  Но суть такая, если у вас данные, вот как здесь, нельзя никак верифицировать,
[01:37:10.500 --> 01:37:16.500]  что они не выдуманные, то тогда вы должны задавить византийские узлы количеством.
[01:37:16.500 --> 01:37:20.500]  Поэтому вы используете систему Quorum'ов, где пересечение довольно жирное.
[01:37:20.500 --> 01:37:26.500]  Но предположим, ваше значение, которое вы пишете, а потом читаете,
[01:37:26.500 --> 01:37:34.500]  это не просто какие-то значения, это то, что называется сертификатом,
[01:37:34.500 --> 01:37:38.500]  это значение, подписанное снабженной цифровой подписью.
[01:37:38.500 --> 01:37:44.500]  И византийский узел не может его выдумать.
[01:37:44.500 --> 01:37:52.500]  В следующий раз мы будем как раз собирать, у нас в Quorum'ах объекты,
[01:37:52.500 --> 01:37:56.500]  которые мы передаем через Quorum, будут являться сертификатами.
[01:37:56.500 --> 01:38:00.500]  То есть мы будем собирать чужие голоса, потом их куда-то передавать.
[01:38:00.500 --> 01:38:04.500]  И вот византийские узлы не могут их уже выдумать.
[01:38:04.500 --> 01:38:08.500]  И нам достаточно, чтобы в пересечении был, по крайней мере, один коллектный узел,
[01:38:08.500 --> 01:38:14.500]  потому что византийский узел может только скрыть информацию, но он не может ее породить.
[01:38:14.500 --> 01:38:20.500]  Поэтому одного честного узла достаточно, чтобы раскрыть полную информацию.
[01:38:20.500 --> 01:38:24.500]  Ну вот две такие системы Quorum'ов.
[01:38:24.500 --> 01:38:28.500]  Правильным образом из них, выбирая ту или иную, которая больше подходит,
[01:38:28.500 --> 01:38:34.500]  вы можете дальше Quorum'у использовать живя с византийскими отказами.
[01:38:40.500 --> 01:38:46.500]  Ну что скажете? Есть вопросы?
[01:38:46.500 --> 01:38:52.500]  Если нет, то главное сегодня все, а в следующий раз мы, воспользуясь нашими наработками,
[01:38:52.500 --> 01:38:56.500]  а именно нижней границей, цифровыми подписями, то есть криптографией,
[01:38:56.500 --> 01:39:02.500]  и византийскими Quorum'ами такими и такими, построим, ну, некоторый аналог, не знаю,
[01:39:02.500 --> 01:39:08.500]  рафта, мультипаксиса, но то есть алгоритм, который реплицирует произвольное состояние
[01:39:08.500 --> 01:39:14.500]  и справляется с византийскими отказами лидеров, клиентов, реплик, разумеется, чего угодно.
[01:39:14.500 --> 01:39:20.500]  Вот он будет более-менее похож на рафт и будет повторять его идеи, правда, вот с такой византийской спецификой.
[01:39:20.500 --> 01:39:26.500]  А еще через неделю мы поговорим про Bitcoin, который решает, в общем-то, ту же самую задачу,
[01:39:26.500 --> 01:39:32.500]  но делает это совершенно иным образом, и мы вот почувствуем,
[01:39:32.500 --> 01:39:38.500]  почему он делает все по-другому и чем это ему обходится.
[01:39:45.500 --> 01:39:50.500]  Там вообще-то сложно, то есть тут много чего в нем меняется, вот давай доживем,
[01:39:50.500 --> 01:39:58.500]  и я разницу приористирую, а в самом-самом конце, на последнем занятии, я расскажу про результат 2019 года, кажется,
[01:39:58.500 --> 01:40:04.500]  где научились совмещать одно с другим и получать сильные стороны двух протоколов.
[01:40:05.500 --> 01:40:11.500]  Еще вопрос, последние хворомы использовали здесь?
[01:40:11.500 --> 01:40:16.500]  Ну вот мы использовали в том-то и дело, что мы в этом алгоритме Benora использовали оба типа хворомов,
[01:40:16.500 --> 01:40:25.500]  когда мы выбирали, за кого, какое значение предлагать, мы использовали такие вот хворомы,
[01:40:25.500 --> 01:40:29.500]  нам было достаточно, чтобы в пересечении был только один ответ,
[01:40:29.500 --> 01:40:37.500]  потому что тут выбор бинарный, либо 0, либо 1, поэтому куда бы лизантийские узлы не примкнули, нам не страшно,
[01:40:37.500 --> 01:40:43.500]  а здесь уже было важно, что пересечение хворомов довольно большое,
[01:40:43.500 --> 01:40:49.500]  короче, мы использовали здесь и вариант, когда в пересечении много корректных узлов больше, чем в лизантийских,
[01:40:49.500 --> 01:40:54.500]  и когда всего лишь одного корректного было достаточно.
[01:40:54.500 --> 01:41:01.500]  Ну здесь это немного по-другому было, мы не можем поделать, потому что у нас бинарные значения,
[01:41:01.500 --> 01:41:04.500]  там были 0 и 1, тут поделывай, не поделывай.
[01:41:13.500 --> 01:41:17.500]  Ну что, если вопросов не остается теперь, то перерыв.
