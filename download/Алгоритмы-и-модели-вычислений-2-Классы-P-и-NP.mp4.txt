[00:00.000 --> 00:14.400]  Так, ну вот неделю назад мы на онлайн-лекции в общих
[00:14.400 --> 00:20.460]  чертах обсудили такую проблему PNP, значит, сегодня мы
[00:20.460 --> 00:25.000]  ее поставим немножко более четко и формально, значит,
[00:25.000 --> 00:28.160]  сначала хочу немножко поговорить про учитывательные модели,
[00:28.160 --> 00:29.920]  ну и дальше, соответственно, определить, что такое класс
[00:29.920 --> 00:37.600]  P, что такое класс NP, ну, некоторые общие значения мы уже обсудили.
[00:37.600 --> 00:53.880]  Ну, а смотрите, вообще есть несколько подходов к тому,
[00:53.880 --> 00:58.640]  что такое вообще алгоритм, да, что означает, что там
[00:58.640 --> 01:02.040]  функция вычислима и так далее, вот, ну, вот один из
[01:02.040 --> 01:06.240]  классических подходов это машина тюринга и машина
[01:06.240 --> 01:12.840]  тюринга, кажется, очень хорошо подходит для сложки
[01:12.840 --> 01:16.040]  вычислений, потому что когда мы говорим о сложке
[01:16.040 --> 01:23.520]  вычислений, нам нужны какие-то базовые шаги, да, и, ну,
[01:23.520 --> 01:27.840]  у нас есть базовые элементы памяти, если мы хотим считать
[01:27.840 --> 01:33.600]  память, и, значит, соответственно, в машине тюринга это очень
[01:33.600 --> 01:38.580]  все хорошо выделяется, да, и хорошо поддается под
[01:38.580 --> 01:43.680]  счетом, вот, есть другие модели, которые хороши для
[01:43.680 --> 01:47.200]  других целей, да, там какой-то лямдовый вычисление, да,
[01:47.200 --> 01:54.280]  там декурсивные функции, вот, но для сложности хорошая
[01:54.280 --> 02:00.480]  машина тюринга, вот, ну, давайте немножко поговорим
[02:00.480 --> 02:05.040]  о том, что такое машина тюринга, да, у вас же это
[02:05.040 --> 02:11.640]  где-то было, да, на ТФС было, вот, ну, да, это вспомним,
[02:11.640 --> 02:15.440]  значит, потому что тут нам будет важно, что машина
[02:15.440 --> 02:19.600]  многоленточная, да, так, было и часто распространено
[02:19.600 --> 02:25.840]  одна ленточная, а вот в торжке вычислений, да, и других
[02:25.840 --> 02:30.880]  смежных областях удобно, что она была многоленточная,
[02:30.880 --> 02:34.280]  ну, например, двухленточная, да, соответственно, есть
[02:34.280 --> 02:45.360]  вот две бесконечные ленты, вот, может быть, и счетом,
[02:45.360 --> 02:50.320]  может быть, их больше, вот, есть какой-то управляющий
[02:50.320 --> 02:57.240]  блок, ну, у которого есть указатель, значит, указатель
[02:57.240 --> 03:00.760]  на одну ленту на другую, вот, ну, а у самого блока
[03:00.760 --> 03:04.840]  есть какое-то внутреннее состояние, да, на лентах
[03:04.840 --> 03:08.320]  записаны какие-то символы из некоторого алфавита,
[03:08.320 --> 03:15.080]  например, А и Б, ну, и дальше команда имеет вид, наш, например,
[03:15.080 --> 03:21.480]  Q, A, B, переходит в какое-нибудь другое состояние S, да,
[03:21.480 --> 03:28.440]  какие-нибудь другие символы C, D и еще два сдвига, да,
[03:29.120 --> 03:33.360]  значит, сдвиг налево, сдвиг направо, вот, ну, в данном
[03:33.360 --> 03:35.400]  случае, это что будет означать? Это будет означать, что
[03:35.400 --> 03:44.640]  вот тут, как бы, следующий шаг, следующий шаг, значит,
[03:44.640 --> 03:51.360]  здесь вместо Q будет состояние S, дальше здесь вместо A будет
[03:51.360 --> 03:56.800]  символ C, вместо B будет символ D, и так же это изменится,
[03:57.160 --> 04:05.160]  то есть здесь это сдвинется вот сюда вот, ну, а тут какой-то
[04:05.160 --> 04:10.760]  еще был символ, да, там, Z, а здесь, соответственно,
[04:10.760 --> 04:14.760]  сдвинется вот сюда вот, и здесь какой-то еще там
[04:14.760 --> 04:20.560]  символ D, например, вот, ну, а после этого нужна будет
[04:21.320 --> 04:29.000]  новая команда уже не Q, A, B, не S, C, D, а S, Z, E, да, S, Z, E тоже
[04:29.000 --> 04:31.120]  на что-то перезапишут, в какое-то состояние перейдет,
[04:31.120 --> 04:34.320]  куда-то сдвинется, ну, и так все это вот будет работать,
[04:34.320 --> 04:39.520]  значит, это, ну, наверное, довольно похоже, да, у вас,
[04:39.520 --> 04:42.000]  наверное, с одной лентой было или прямо с одной лентой,
[04:42.000 --> 04:45.440]  да, ну, в принципе, наверное, если вы сами будете придумать,
[04:45.440 --> 04:50.520]  то вы что-нибудь такое придумаете, в принципе, можно обсуждать
[04:51.480 --> 04:53.520]  какие-то более хитрые модели, да, значит, может быть,
[04:53.520 --> 04:56.520]  например, вообще не одна лента, не много лента,
[04:56.520 --> 04:59.520]  какая-нибудь там клетчатая плоскость, на которую можно
[04:59.520 --> 05:04.520]  переходить в разных направлениях, может быть, еще надстройка
[05:04.520 --> 05:07.520]  такая, что есть какой-нибудь там произвольный доступ,
[05:07.520 --> 05:10.520]  что можно, это собственно то, что в реальных компьютерах
[05:10.520 --> 05:13.520]  происходит, да, можно прочесть адрес ячейки памяти и
[05:13.520 --> 05:18.520]  прямо на эту ячейку перейти, а не то, что по одному шагу
[05:18.520 --> 05:26.520]  сюда, вот, ну, и так далее, значит, если делать больше,
[05:26.520 --> 05:28.520]  тогда понятно, что здесь будет просто больше символов
[05:28.520 --> 05:32.520]  здесь, больше символов здесь и больше направлений
[05:32.520 --> 05:36.520]  здесь, но важно, что состояние одно, состояние свое на
[05:36.520 --> 05:42.520]  каждой ленте, оно вообще одно на всю машину, вот,
[05:42.520 --> 05:49.520]  ну, хорошо, значит, дальше, ну, формально машина тюринга
[05:49.520 --> 05:54.520]  это какой-нибудь там набор из там алфавита, из которого
[05:54.520 --> 05:57.520]  все эти буквы, множество состояний, из которого вот
[05:57.520 --> 06:00.520]  эти буквы, ну, и, самое главное, функции перехода, да,
[06:00.520 --> 06:05.520]  значит, обычно там, там бывает еще два варианта, может быть,
[06:05.520 --> 06:11.520]  у нас машина отвечает да или нет, тогда вот этот вот
[06:11.520 --> 06:15.520]  вот ответ можно записать прямо состояние, да, можно
[06:15.520 --> 06:18.520]  считать, что есть специальные два состояния, выделенные
[06:18.520 --> 06:24.520]  QA, это принимающее слово accept, значит, принимающее
[06:24.520 --> 06:37.520]  состояние, AQR reject, отвергающее состояние, вот, тогда, если
[06:37.520 --> 06:39.520]  машина приходит в одно из них, то она заканчивает
[06:39.520 --> 06:44.520]  работу, и, соответственно, в этом случае ответ один,
[06:44.520 --> 06:50.520]  а в этом случае ответ ноль, да или нет. Вот, а другой
[06:50.520 --> 06:53.520]  вариант, когда ответ, это какая-то там длинная строка
[06:53.520 --> 06:57.520]  символов, да, или число, или что-то такое, тогда есть
[06:57.520 --> 07:01.520]  одно завершающее состояние, но после этого ответ нужно
[07:01.520 --> 07:04.520]  получить не из состояния, а где-то прочесть ленты.
[07:04.520 --> 07:12.520]  Вот, ну и тогда нужно все договориться, что есть
[07:12.520 --> 07:16.520]  какое-нибудь еще начальное состояние, и, соответственно,
[07:16.520 --> 07:19.520]  в самом начале, машинное начальное состояние, скажем,
[07:19.520 --> 07:23.520]  на одной из лент написан вход, вторая, например,
[07:23.520 --> 07:26.520]  пустая, ну и после этого начинается какая-то такая
[07:26.520 --> 07:32.520]  работа, которая задана конечной программой. Так, ну
[07:32.520 --> 07:36.520]  ладно, я не хотел бы сейчас вдаваться в полные формальные
[07:36.520 --> 07:40.520]  детали, я это, наверное, не буду записывать, но
[07:40.520 --> 07:47.520]  глобально я надеюсь, что это понятно. Вот, хорошо.
[07:47.520 --> 07:52.520]  Значит, теперь почему важно, что именно две ленты?
[07:52.520 --> 07:58.520]  Ну, на самом деле в некоторых моделях они могут
[07:58.520 --> 08:04.520]  иметь разный статус, но, например, есть модели
[08:04.520 --> 08:13.520]  вычислений, где вход неизменяемый, и тогда вот на одной
[08:13.520 --> 08:16.520]  ленте будет просто записан вход, его можно читать, но
[08:16.520 --> 08:19.520]  там нельзя ничего менять, а все вычисления будут
[08:19.520 --> 08:22.520]  произвести на второй ленте, и, например, если вас
[08:22.520 --> 08:26.520]  интересует затраченная память, то тогда, естественно,
[08:26.520 --> 08:29.520]  нужно считать им дополнительную память, не ту, которая
[08:29.520 --> 08:32.520]  вот здесь вместе со входом, а ту, на которой собственные
[08:32.520 --> 08:36.520]  вычисления происходят. Вот, бывает так, что у лент
[08:36.520 --> 08:40.520]  вообще разный статус, например, есть рандомизированные
[08:40.520 --> 08:48.520]  вычисления, где можно считать, что случайные биты записаны
[08:48.520 --> 08:51.520]  на отдельной ленте, да, могут быть какие-то интерактивные
[08:51.520 --> 08:55.520]  алгоритмы, да, тогда может быть, что там две машины
[08:55.520 --> 08:57.520]  имеют как бы одну общую интерактивную ленту, какие-то
[08:57.520 --> 09:01.520]  свои рабочие, ну и так далее, да, на самом деле можно
[09:01.520 --> 09:04.520]  множество разных сюжетов описать на языке машины
[09:04.520 --> 09:08.520]  тюринга с разными лентами, там, с разным статусом.
[09:08.520 --> 09:16.520]  Вот, значит, тем еще хороша машина тюринга, тем, что
[09:16.520 --> 09:19.520]  тут вот есть элементарные единицы и по времени и по
[09:19.520 --> 09:22.520]  памяти, да, по времени есть элементарный шаг, это
[09:22.520 --> 09:25.520]  выполнение вот этой вот команды, соответственно,
[09:25.520 --> 09:30.520]  по памяти есть вот одна ячейка, ну, при желании можно
[09:30.520 --> 09:33.520]  не умножить там алгоритм по размеру алфавита, но это
[09:33.520 --> 09:36.520]  если уж прям совсем точно надо мерить, вот, а так
[09:36.520 --> 09:39.520]  по простому можно просто свой ячейк использовать,
[09:39.520 --> 09:43.520]  на который машина там хотя бы раз указывала в ходе
[09:43.520 --> 09:50.520]  работы. Так, хорошо, теперь смотрите, если есть
[09:50.520 --> 09:57.520]  конкретная машина, если есть машина, значит, или
[09:57.520 --> 10:00.520]  программа, да, значит, это я буду как синониму использовать
[10:00.520 --> 10:04.520]  слова машина и программа, да, значит, если есть
[10:04.520 --> 10:15.520]  программа, да, значит, есть какой-то вход, то дальше,
[10:15.520 --> 10:18.520]  в принципе, есть два варианта, либо машина остановилась
[10:18.520 --> 10:23.520]  на этом входе, либо не остановилась. Ну, мы будем
[10:23.520 --> 10:26.520]  считать, что она всегда останавливается, да, потому
[10:26.520 --> 10:31.520]  что как раз когда она там не останавливается, это
[10:31.520 --> 10:35.520]  же вопрос перевычастимости, а не сложность вычислений,
[10:35.520 --> 10:38.520]  да, то есть здесь нас будет интересовать, сколько
[10:38.520 --> 10:41.520]  времени она будет работать или там сколько ячейк
[10:41.520 --> 10:47.520]  займет и так далее. Вот, соответственно, можно
[10:47.520 --> 10:55.520]  написать, ну, как-нибудь обозначить тайм m от х, значит,
[10:55.520 --> 11:00.520]  это время работы машины на входе х, и будем считать,
[11:00.520 --> 11:08.520]  что оно меньше бесконечности, значит, время работы m от
[11:08.520 --> 11:12.520]  х, да, значит, это может быть измерено, собственно,
[11:12.520 --> 11:20.520]  в базовых шагах, а может быть измерено, ну, в каких-то
[11:20.520 --> 11:24.520]  других единицах, да, например, если у вас какие-нибудь
[11:24.520 --> 11:27.520]  аристетические вычисления, можно смотреть, сколько
[11:27.520 --> 11:30.520]  у нас адефинных операций, сколько мультипликативных
[11:30.520 --> 11:36.520]  операций, да, и считать именно вот эти вот переходы,
[11:36.520 --> 11:42.520]  да, не доходить прям до машины тюринга, это операции
[11:42.520 --> 11:45.520]  с отдельными символами, а прям считать базовые
[11:45.520 --> 11:47.520]  операции, что у нас, например, умножение на травер
[11:47.520 --> 11:50.520]  чисел, это вот базовая операция, и мы считаем, сколько
[11:50.520 --> 11:54.520]  их происходит, да, там, если у нас на входе матрица.
[11:54.520 --> 12:03.520]  Вот, хорошо, значит, ну, дальше, когда у нас есть и
[12:03.520 --> 12:07.520]  машина, и вход, то вот можно просто взять и посчитать,
[12:07.520 --> 12:10.520]  если мы договорились, что считать, да, то берем и
[12:10.520 --> 12:16.520]  считаем, а если у нас есть просто машина, то уже есть
[12:16.520 --> 12:20.520]  разные способы в качестве такой времени работы машины,
[12:20.520 --> 12:28.520]  да, без точения входа, да, значит, время работы самой
[12:28.520 --> 12:35.520]  машины может вычисляться, как видим, двумя способами,
[12:35.520 --> 12:39.520]  значит, один способ это в худшем случае, да, значит,
[12:39.520 --> 12:47.520]  это может быть худший случай, но же в худшем случае
[12:47.520 --> 12:51.520]  даже еще и иксы могут быть самые разные, но это означает,
[12:51.520 --> 12:58.520]  что мы смотрим на иксы одной длины, да, то есть можно
[12:58.520 --> 13:06.520]  сказать так, что time, значит, time m от числа m, это максимум
[13:06.520 --> 13:12.520]  по всем иксам, у которых длина равна m, да, значит,
[13:12.520 --> 13:15.520]  а тут, соответственно, время времени работает time m от
[13:15.520 --> 13:25.520]  икс. Ну, опять же, да, значит, общий подход, что n это просто
[13:25.520 --> 13:30.520]  длина как бы в битах, да, или символах икса, в принципе,
[13:30.520 --> 13:34.520]  можно считать, что, например, если это у нас граф, то n это
[13:34.520 --> 13:39.520]  там число вершин, если у нас матрица, то n это там число
[13:39.520 --> 13:42.520]  там строк или столбцов, ну и так далее, да, в общем,
[13:42.520 --> 13:45.520]  в конкретных приложениях n может быть не длиной икс,
[13:45.520 --> 13:48.520]  а каким-нибудь другим параметрам, который нас интересует,
[13:48.520 --> 13:56.520]  вот, в общем случае это вот длина икса. Ну и также может быть
[13:56.520 --> 14:07.520]  не худший случай, а в среднем. В среднем тогда вместо
[14:07.520 --> 14:10.520]  максимума берем какое-то усреднение, и это вообще
[14:10.520 --> 14:20.520]  можно там разными способами делать. Ну можно просто
[14:20.520 --> 14:23.520]  брать там среднеархитетическое, но так не очень хорошая
[14:23.520 --> 14:26.520]  теория получается, да, значит, там некоторые ухищрения
[14:26.520 --> 14:32.520]  нужны. Вот, ну что дальше, хорошо, ну для машины мы это
[14:32.520 --> 14:37.520]  посчитали, но дальше хочется понять, что такое сложность
[14:37.520 --> 14:42.520]  вопроса, который машина решает. Ну что означает, что
[14:42.520 --> 14:46.520]  машина там решает вопрос, ну, например, распознает язык,
[14:46.520 --> 15:03.520]  м распознает язык, а если для любого икс, да, значит,
[15:03.520 --> 15:09.520]  если икс лежит в а, то тогда м от икс равно единице,
[15:09.520 --> 15:15.520]  значит, а если икс не лежит в а, то тогда м от икс равно
[15:15.520 --> 15:22.520]  нуди. Да, то есть машина должна дать ответ на вопрос
[15:22.520 --> 15:27.520]  да или нет, и причем всегда правильно, да, то есть мы
[15:27.520 --> 15:31.520]  здесь не разрешаем никогда там ошибаться, да, значит,
[15:31.520 --> 15:39.520]  всегда должен быть правильный ответ. Вот, ну хорошо, тогда
[15:39.520 --> 15:45.520]  как определить сложность, собственно, этой задачи, да,
[15:45.520 --> 15:55.520]  что такое сложность? Сложность задачи на распознавание
[15:55.520 --> 16:02.520]  языка. Что это вообще такое? Ну вообще, вообще хотелось бы
[16:02.520 --> 16:07.520]  дать определение, что это там время работы самой быстрой
[16:07.520 --> 16:15.520]  машины, которая решает эту задачу. Вот, но, к сожалению,
[16:15.520 --> 16:21.520]  так ничего не получится. Вот, почему? Ну, во-первых,
[16:21.520 --> 16:26.520]  прежде чем понимать, что не получится, да, все не получится,
[16:26.520 --> 16:31.520]  надо понять, что не получится. Как, конечно, можно сравнивать,
[16:31.520 --> 16:35.520]  да, пусть у нас есть одна машина М, другая М штрих. Ну,
[16:35.520 --> 16:38.520]  и, например, мы этого считали по лучшему варианту, да,
[16:38.520 --> 16:42.520]  вот максимум вот такой. И у нас какие-то есть две функции
[16:42.520 --> 16:48.520]  растущие, да, вот как понять, какая лучше. Ну, опять
[16:48.520 --> 16:51.520]  стандартный подход, что нужно смотреть на асимптотику,
[16:51.520 --> 16:57.520]  да, то есть, например, если есть там какая-нибудь одна
[16:57.520 --> 17:04.520]  функция такая, да, значит, это тайм М от М, а есть еще
[17:04.520 --> 17:09.520]  другая функция, там какая-нибудь вот такая, значит, тайм
[17:09.520 --> 17:14.520]  Q от М, да, и что машины М и Q решают одну и ту же задачу,
[17:14.520 --> 17:19.520]  и у них время, но иметь в виду, что вот эта ось это М,
[17:19.520 --> 17:25.520]  да, а эта ось это время, вот, и одна растет вот так,
[17:25.520 --> 17:29.520]  а другая растет вот так вот. Ну, стандартный подход,
[17:29.520 --> 17:32.520]  что нас интересует в виде бесконечности, то есть машина
[17:32.520 --> 17:38.520]  Q будет лучше, значит, машина Q будет лучше, но в частности,
[17:38.520 --> 17:43.520]  например, любой полином считается лучше, чем любая
[17:43.520 --> 17:49.520]  экспонента. Теорема изматонализа, да, что если мы поделили
[17:49.520 --> 17:51.520]  там экспонентом на полином, то это будет стремиться
[17:51.520 --> 17:55.520]  бесконечности, но, может быть, очень не скоро, да,
[17:55.520 --> 18:00.520]  если мы поделим там 1.001 в N и поделим на N в тысячной,
[18:00.520 --> 18:03.520]  то это стремится бесконечности, но очень не скоро
[18:03.520 --> 18:10.520]  даже единицу. Вот, но, тем не менее, по крайней мере,
[18:10.520 --> 18:14.520]  в теории нас интересует именно проведение бесконечности.
[18:14.520 --> 18:24.520]  Вот, но хорошо, а можно ли все-таки дать такое определение,
[18:24.520 --> 18:28.520]  да, что сложность задачи – это сложность машины,
[18:28.520 --> 18:32.520]  которая асимпатически быстрее всего решает эту задачу.
[18:32.520 --> 18:37.520]  Но было, конечно, хорошо такое определение дать, но,
[18:37.520 --> 18:41.520]  к сожалению, такой асимпатически наилучшей машины может
[18:41.520 --> 18:47.520]  не быть, да, потому что может быть такая ситуация, да,
[18:47.520 --> 18:51.520]  что может быть одна машина, которая работает вот так вот,
[18:51.520 --> 18:57.520]  да, а другая быстрее, а третья какого-то момента еще быстрее,
[18:57.520 --> 19:01.520]  да, четвертая дальше тут будет еще быстрее и так далее,
[19:01.520 --> 19:06.520]  и каждую машину можно улучшить, но не будет одной машины,
[19:06.520 --> 19:08.520]  которая будет идти там вот по нижней огибающей.
[19:08.520 --> 19:13.520]  Да, это значит «Терема Блума», значит «Терема Блума»,
[19:13.520 --> 19:23.520]  что может не существовать оптимальной машины, «Терема Блума»,
[19:23.520 --> 19:31.520]  да, по крайней мере для некоторых задач, значит,
[19:31.520 --> 19:40.520]  для некоторых задач не существует оптимальная машина,
[19:40.520 --> 19:53.520]  которая их решает.
[19:53.520 --> 19:59.520]  Да, то есть любая машина может быть улучшена, да, та еще
[19:59.520 --> 20:03.520]  улучшена, та еще улучшена и так далее, вот, но не будет
[20:03.520 --> 20:12.520]  одной машины, которая будет прям лучше всех.
[20:12.520 --> 20:17.520]  Вот, значит, эта теорема довольно общая, довольно ранняя,
[20:17.520 --> 20:22.520]  она еще в 1965 году была доказана, но мы ее не будем доказывать,
[20:22.520 --> 20:27.520]  да, там не каких-то таких совсем в боксах, где и там нет,
[20:27.520 --> 20:32.520]  зато здесь много техники, значит, поэтому мы с ней ознакомимся,
[20:32.520 --> 20:37.520]  и пойдем дальше. Ну, что получается с «Теремой Блума»?
[20:37.520 --> 20:41.520]  Получается, что нельзя вот так определять, да, уж не говоря о том,
[20:41.520 --> 20:45.520]  что непонятно, как понять лучше эта программа или не лучше,
[20:45.520 --> 20:50.520]  ее может вообще не быть, да, так что даже определить так мы не можем.
[20:50.520 --> 20:54.520]  Ну и в результате получается, что, собственно, нет такого
[20:54.520 --> 20:58.520]  прям четкого понятия, что такое сложность задачи, есть только
[20:58.520 --> 21:03.520]  нижние и нижние оценки, да, то есть если есть какая-то машина,
[21:03.520 --> 21:07.520]  которая решает задачу, у которой какое-то время работая,
[21:07.520 --> 21:12.520]  то вот такое время будет верхней оценкой на сложность задачи.
[21:12.520 --> 21:17.520]  Ну а в принципе могут быть и нижние оценки, что в принципе гораздо сложнее,
[21:17.520 --> 21:23.520]  да, что мы доказываем, что ни одна машина не может
[21:23.520 --> 21:28.520]  решать быстрее, чем в какой-то скорости.
[21:28.520 --> 21:32.520]  Вот, вот нижние оценки, это самое сложное, что есть сложные вычисления,
[21:32.520 --> 21:36.520]  очень мало теорем, в которых прям доказана нижняя оценка,
[21:36.520 --> 21:40.520]  гораздо больше открытых вопросов. Собственно задача про УП и НП,
[21:40.520 --> 21:45.520]  это вот классический пример вопроса о нижней оценке.
[21:45.520 --> 21:50.520]  Значит, если П строго вложена в НП, то тогда
[21:50.520 --> 21:57.520]  некоторые задачи из НП не имеют паридомиального алгоритма.
[21:57.520 --> 22:07.520]  Ну вот, мы почти уже вплотную подобрались к формальному определению,
[22:07.520 --> 22:17.520]  здесь есть понятие D time, значит D time от T от N,
[22:17.520 --> 22:22.520]  это класс языков, то есть задач с бинарным ответом,
[22:22.520 --> 22:30.520]  советом да или нет. Значит, это класс языков,
[22:30.520 --> 22:49.520]  которые распознаются на многоленточной машине тюринга
[22:49.520 --> 22:59.520]  за время O большое от T от N.
[22:59.520 --> 23:07.520]  Так, что значит O большое? Ну, то есть какая-то универсальная константа,
[23:07.520 --> 23:13.520]  так что время будет меньше, чем вот этот констант умножить на T от N.
[23:13.520 --> 23:19.520]  А зачем вот я пишу O большое, почему просто T от N не написать?
[23:19.520 --> 23:24.520]  Ну, потому что это константы, это совсем какие-то низкуровневые детали,
[23:24.520 --> 23:28.520]  например, если мы будем несколько клеток у машины объединять в одну,
[23:28.520 --> 23:33.520]  то есть переходить от битов к байтам, то у нас там операция над байтами
[23:33.520 --> 23:39.520]  станет гораздо меньшей операцией над битами, но только в какую-то константу раз.
[23:39.520 --> 23:45.520]  И тогда получается, что все переходим от байтов к 2-байтовым,
[23:45.520 --> 23:50.520]  к 3-байтовым и так далее участкам. В общем, можем искусственно
[23:50.520 --> 23:56.520]  увеличивать размеры ячеек, и соответственно от этого числа операции
[23:56.520 --> 24:01.520]  у нас будет меньше. Если для подсчета памяти еще можно умножить на логари
[24:01.520 --> 24:07.520]  числа состояний, то со временем не очень понятно, на каком основании это делать.
[24:07.520 --> 24:12.520]  И получается, что в константу раз мы можем уменьшить время
[24:12.520 --> 24:16.520]  за счет искусственного объединения нескольких ячеек в одну.
[24:16.520 --> 24:21.520]  Поэтому, хотя на практике константы это очень важно,
[24:21.520 --> 24:27.520]  если ваш программа стала 2 раз быстрее работать, это может очень сказаться
[24:27.520 --> 24:32.520]  на результатах, тем более если в 100 раз быстрее.
[24:32.520 --> 24:37.520]  То в теории считается, что это не важно. Нас интересует симптомика,
[24:37.520 --> 24:42.520]  скорость роста, а не конкретные константы.
[24:47.520 --> 24:51.520]  Ну хорошо. И дальше.
[24:51.520 --> 24:57.520]  Класс П от слова полиномиальное время.
[24:57.520 --> 25:03.520]  Значит, это объединение по всем С от 1 до бесконечности.
[25:03.520 --> 25:12.520]  Значит, здесь будет D time от N в степени С.
[25:12.520 --> 25:17.520]  Значит, поскольку у нас уже константы есть вот здесь, то здесь можно просто
[25:17.520 --> 25:22.520]  функцию писать. Без дополнительного множителя.
[25:22.520 --> 25:29.520]  Ну вот, мы обсуждали, что в классе П есть много хороших задач.
[25:29.520 --> 25:34.520]  Там раскраска в два цвета, там поиск кратчайшего пути,
[25:34.520 --> 25:40.520]  проверка на Эллера в цикл, там поиск совершенно парасчитания,
[25:40.520 --> 25:46.520]  проверка простоты числа, где N это будет уже не само число, а его логарифм,
[25:46.520 --> 25:49.520]  то есть число знаков.
[25:49.520 --> 25:54.520]  Линейно-программирование, например, тоже в П.
[25:54.520 --> 26:01.520]  Ну и так далее. В общем, огромное множество хороших задач лежат в П.
[26:01.520 --> 26:08.520]  Так, а дальше возникает вопрос, почему тут до бесконечности?
[26:08.520 --> 26:12.520]  Почему бы не провести какую-нибудь границу?
[26:12.520 --> 26:17.520]  Скажем, что четвертая степень это хорошо, а пятая это плохо.
[26:17.520 --> 26:22.520]  Но дело как раз в деталях модели.
[26:22.520 --> 26:26.520]  Что вообще-то, что мы хотим?
[26:26.520 --> 26:32.520]  Мы хотим, чтобы этот язык включал в себя все эффективно решаемые задачи.
[26:32.520 --> 26:38.520]  Что мы как бы хотим формально поймать понятие эффективности.
[26:38.520 --> 26:46.520]  Но если мы смотрим на сути, то понятие эффективности
[26:46.520 --> 26:53.520]  в сути, то понятие, то вообще-то хорошо бы, чтобы деталь модели не зависела.
[26:53.520 --> 26:56.520]  Например, не зависела от теплолент.
[26:56.520 --> 27:00.520]  И даже если мы вместо двух лент сделаем одну ленту,
[27:00.520 --> 27:07.520]  хорошо бы, чтобы наш класс эффективной задачи не поменялся.
[27:07.520 --> 27:11.520]  Иначе, если мы даже такой модели не можем разобраться,
[27:11.520 --> 27:16.520]  то странно было, что мы перешли на новый процессор.
[27:16.520 --> 27:22.520]  И от этого у нас понятие эффективной задачи изменилось.
[27:22.520 --> 27:25.520]  Хорошо бы, чтобы все-таки было устойчивое понятие,
[27:25.520 --> 27:28.520]  не связанное с деталями техническими.
[27:28.520 --> 27:36.520]  Но оказывается, что если вы переходите от двух лент к одной ленте,
[27:37.520 --> 27:46.520]  если переходите от двух лент к одной ленте,
[27:46.520 --> 27:50.520]  то тогда время может возлестись в квадрат.
[27:50.520 --> 28:04.520]  Время t от n может перейти во время t от n в квадрате.
[28:04.520 --> 28:11.520]  Но почему?
[28:11.520 --> 28:14.520]  Потому что как вообще переходить от двух лент к одной ленте?
[28:14.520 --> 28:17.520]  Есть разные способы.
[28:17.520 --> 28:24.520]  Например, можно их записать на одну ленту.
[28:24.520 --> 28:28.520]  Вот здесь будет первая лента.
[28:28.520 --> 28:33.520]  Значит, а вот здесь будет вторая лента.
[28:33.520 --> 28:44.520]  Да, и тут вот какие-то места есть указатели.
[28:44.520 --> 28:48.520]  Там же у нас было два указателя, а здесь у нас один указатель.
[28:48.520 --> 28:52.520]  Поэтому вместо старых указателей мы там пометки какие-то ставим.
[28:53.520 --> 28:58.520]  Ну и дальше как нужно моделировать?
[28:58.520 --> 29:03.520]  Мы тут идем, ищем указатель, не знаю, что здесь написано.
[29:03.520 --> 29:07.520]  Потом идем дальше, ищем здесь указатель, не знаю, что здесь написано.
[29:07.520 --> 29:10.520]  Смотрим, какая должна быть программа.
[29:10.520 --> 29:12.520]  Соответственно, перезаписан здесь символ,
[29:12.520 --> 29:14.520]  передвигаем указатель, идем сюда.
[29:14.520 --> 29:17.520]  Тоже здесь перезаписано, тоже передвигаем указатель.
[29:17.520 --> 29:20.520]  Может все так выйдет, что занято место растет,
[29:20.520 --> 29:24.520]  что мы там дописываем сюда вот какой-то символ,
[29:24.520 --> 29:26.520]  дописываем сюда какой-то символ,
[29:26.520 --> 29:29.520]  и они у нас как бы столкнулись.
[29:29.520 --> 29:32.520]  Тогда что можно делать?
[29:32.520 --> 29:36.520]  Ну, можно взять, например, отдельную операцию,
[29:36.520 --> 29:38.520]  весь этот блок взять и сдвинуть туда,
[29:38.520 --> 29:41.520]  чтобы дополнительное место образовалось в центре,
[29:41.520 --> 29:44.520]  и его потом использовать.
[29:44.520 --> 29:49.520]  В общем, так или иначе, чтобы смоделировать один шаг
[29:49.520 --> 29:51.520]  на старой машине,
[29:51.520 --> 29:54.520]  нужно, более-менее, туда обратно пройти
[29:54.520 --> 29:57.520]  по всем клеткам на новой машине.
[30:02.520 --> 30:04.520]  Можно, да, можно перемешку записывать,
[30:04.520 --> 30:06.520]  но это не особо будет от того, что вам нужно
[30:06.520 --> 30:08.520]  найти место, где здесь отметка стоит,
[30:08.520 --> 30:10.520]  и найти место, где здесь отметка стоит.
[30:10.520 --> 30:15.520]  А если вы еще будете хранить, чтобы они были рядом,
[30:15.520 --> 30:19.520]  то тогда вам нужно будет вместо перемещения отметки
[30:19.520 --> 30:21.520]  передвигать всю ленту,
[30:21.520 --> 30:25.520]  а все равно будет порядка длины ленты требоваться.
[30:29.520 --> 30:31.520]  Не, можно не передвигать ленты,
[30:31.520 --> 30:33.520]  тогда вот эти указатели могут быть в разных местах,
[30:33.520 --> 30:36.520]  и тогда нужно ходить туда-сюда, чтобы их найти.
[30:36.520 --> 30:40.520]  Можно пытаться держать их рядом друг с другом,
[30:40.520 --> 30:43.520]  но тогда, если вы указатель зафиксируете,
[30:43.520 --> 30:46.520]  у вас лента будет вдоль него двигаться,
[30:46.520 --> 30:48.520]  и все равно нужно вместо того, чтобы
[30:48.520 --> 30:50.520]  бегать искать указатель, нужно будет бегать
[30:50.520 --> 30:52.520]  и двигать ленту.
[30:52.520 --> 30:57.520]  Вообще, никуда это на самом деле не деться.
[30:57.520 --> 31:02.520]  Получится, что у вас один шаг на двух лентах
[31:02.520 --> 31:05.520]  соответствует примерно такому числу шагов,
[31:05.520 --> 31:07.520]  сколько у вас занятых ячеек.
[31:07.520 --> 31:11.520]  Но что-таки занятых ячеек у вас порядка ТАТН,
[31:11.520 --> 31:13.520]  потому что за один шаг на одной ленте
[31:13.520 --> 31:15.520]  нельзя занять больше одной новой ячейки.
[31:17.520 --> 31:21.520]  Поэтому всего занятых ячеек не больше, чем ТАТН,
[31:21.520 --> 31:23.520]  но получается, что у вас ТАТН шагов
[31:23.520 --> 31:27.520]  и ТАТН на каждый шаг,
[31:27.520 --> 31:29.520]  ТАТН опираться на каждый шаг еще нужно.
[31:29.520 --> 31:31.520]  Вот и получается ТАТН в квадрате.
[31:35.520 --> 31:37.520]  Ну и на самом деле, вот тут как раз даже можно
[31:37.520 --> 31:39.520]  нижнюю оценку доказать.
[31:39.520 --> 31:43.520]  Значит, есть такая одна конкретная задача,
[31:43.520 --> 31:45.520]  называемая задача о полиндроме.
[31:47.520 --> 31:50.520]  Значит, полиндром, то есть нож таких х,
[31:50.520 --> 31:55.520]  что у вас как этот х лево направо
[31:55.520 --> 31:57.520]  и справа налево считается одинаково.
[31:57.520 --> 31:59.520]  Значит, хр, это имеется у х
[31:59.520 --> 32:01.520]  написано на обратном порядке.
[32:03.520 --> 32:06.520]  Ну вот как проверить, что слово это полиндром?
[32:07.520 --> 32:09.520]  Ну, смотрите, если у вас есть две ленты,
[32:13.520 --> 32:15.520]  если у вас есть две ленты,
[32:15.520 --> 32:17.520]  то можно просто скопировать.
[32:19.520 --> 32:21.520]  Значит, скопировали.
[32:23.520 --> 32:25.520]  Дальше на этой ленте остались намечки,
[32:25.520 --> 32:30.520]  а на этой ленте, значит, двигается другой конец.
[32:31.520 --> 32:33.520]  И дальше идем по одной слева направо,
[32:33.520 --> 32:35.520]  по другой справа налево
[32:35.520 --> 32:37.520]  одному все символы.
[32:37.520 --> 32:39.520]  Если дошли до конца, все совпало, значит,
[32:39.520 --> 32:41.520]  полиндром, если где-то разночьение, значит, не полиндром.
[32:42.520 --> 32:44.520]  И вот эта процедура линейная.
[32:45.520 --> 32:48.520]  Например, 3n, то есть n шагов скопировать,
[32:48.520 --> 32:51.520]  n шагов перейти в другой конец на одной ленте
[32:51.520 --> 32:53.520]  и n шагов идти и сравнивать.
[32:56.520 --> 32:58.520]  Соответственно, тут две ленты,
[33:00.520 --> 33:02.520]  значит, две ленты это n шагов.
[33:05.520 --> 33:07.520]  Но одна лента,
[33:07.520 --> 33:09.520]  как на одной ленте,
[33:09.520 --> 33:11.520]  но нужно ходить туда-сюда,
[33:11.520 --> 33:13.520]  как-то сравнивать,
[33:13.520 --> 33:15.520]  и нужно будет более-менее,
[33:15.520 --> 33:17.520]  там, n пополам раз,
[33:17.520 --> 33:19.520]  там, сходить туда-сюда,
[33:19.520 --> 33:21.520]  будет типа n в квадрате шагов.
[33:26.520 --> 33:28.520]  Это одна лента.
[33:30.520 --> 33:32.520]  Я без константа пишу.
[33:33.520 --> 33:35.520]  n в квадрате шагов.
[33:38.520 --> 33:40.520]  Ну да, на основании, смотрите,
[33:40.520 --> 33:43.520]  вот здесь надо написать о большое,
[33:43.520 --> 33:45.520]  а вот здесь надо написать,
[33:45.520 --> 33:47.520]  наоборот, о мега большое.
[33:49.520 --> 33:51.520]  Что о мега большое означает, что есть
[33:51.520 --> 33:53.520]  какая-то константа, как оценка снизу.
[33:55.520 --> 33:57.520]  То, что о большое, значит, может быть, и сильно меньше.
[33:58.520 --> 34:00.520]  А о мега большое, значит, может быть, больше,
[34:00.520 --> 34:02.520]  но обязательно больше,
[34:02.520 --> 34:04.520]  чем какой-то епсилон больше нуля,
[34:04.520 --> 34:06.520]  он нужно на n в квадрате.
[34:06.520 --> 34:08.520]  Что-то, опять же, можно экономить,
[34:08.520 --> 34:10.520]  запомнить сразу три е-символа,
[34:10.520 --> 34:12.520]  пойти туда, сравнить,
[34:12.520 --> 34:14.520]  и тут будет n в квадрате,
[34:14.520 --> 34:16.520]  одна треть от n в квадрате.
[34:20.520 --> 34:22.520]  Но тут можно как раз доказать,
[34:22.520 --> 34:24.520]  что меньше никак нельзя.
[34:26.520 --> 34:28.520]  Но это, может быть, на некоторых семинарах
[34:28.520 --> 34:30.520]  что-то не было пока не в одной группе,
[34:30.520 --> 34:32.520]  а даже было, да, ну вот.
[34:34.520 --> 34:36.520]  Вот, хорошо.
[34:41.520 --> 34:43.520]  Хороший вопрос.
[34:43.520 --> 34:45.520]  Это вот еще более сложная теорема.
[34:45.520 --> 34:47.520]  Значит, смотрите, если k-лент,
[34:49.520 --> 34:51.520]  если k-лент, переходим в две ленты,
[34:54.520 --> 34:56.520]  то на самом деле там
[34:56.520 --> 34:58.520]  куча получается,
[34:58.520 --> 35:00.520]  значит, тогда время
[35:02.520 --> 35:04.520]  время t от n
[35:04.520 --> 35:06.520]  превратится во время
[35:10.520 --> 35:12.520]  t от n
[35:14.520 --> 35:16.520]  t от n на логарифм t от n.
[35:18.520 --> 35:20.520]  Что тоже немножко больше,
[35:20.520 --> 35:22.520]  но уже не в квадрате,
[35:22.520 --> 35:24.520]  всего нужно на логарифм.
[35:24.520 --> 35:26.520]  Но это тоже довольно сложная техническая теорема.
[35:30.520 --> 35:32.520]  Есть в первой главе Рорбарака,
[35:32.520 --> 35:34.520]  если интересно, то
[35:34.520 --> 35:36.520]  можно изучить.
[35:40.520 --> 35:42.520]  Так что здесь вот такой большой шаг,
[35:42.520 --> 35:44.520]  именно от 2 к 1.
[35:44.520 --> 35:46.520]  Так, так стоит нам все говорить
[35:46.520 --> 35:48.520]  только из зрения П.
[35:48.520 --> 35:50.520]  Ну а говорит следующее, смотрите,
[35:50.520 --> 35:52.520]  но мы не хотим,
[35:52.520 --> 35:54.520]  чтобы наша временная граница
[35:54.520 --> 35:56.520]  зависела от деталей модели.
[35:56.520 --> 35:58.520]  Но точно хотим, чтобы линейные
[35:58.520 --> 36:00.520]  алгоритмы попали в
[36:00.520 --> 36:02.520]  классы эффективных.
[36:02.520 --> 36:04.520]  Ну а какой минимальный класс функций,
[36:04.520 --> 36:06.520]  который вместе с каждой функцией
[36:06.520 --> 36:08.520]  содержит ее квадрат
[36:08.520 --> 36:10.520]  и при этом содержит
[36:10.520 --> 36:12.520]  линейную функцию?
[36:12.520 --> 36:14.520]  Ну это есть многочлены, да?
[36:16.520 --> 36:18.520]  Да, с одной стороны квадрат
[36:18.520 --> 36:20.520]  многочлен, это многочлен,
[36:20.520 --> 36:22.520]  а с другой стороны, если есть тен, то есть тен
[36:22.520 --> 36:24.520]  в квадрате, в четвертый, восьмой и так далее.
[36:26.520 --> 36:28.520]  Вот.
[36:30.520 --> 36:32.520]  Так, ну что, прерывы будем делать?
[36:34.520 --> 36:36.520]  Ну давайте, да, вроде
[36:38.520 --> 36:40.520]  есть трепность 5 минут тогда,
[36:40.520 --> 36:42.520]  значит потом прорыв.
[36:42.520 --> 36:44.520]  Попробовать у вас подрегулировать
[36:46.520 --> 36:48.520]  Давайте.
[36:50.520 --> 36:52.520]  Зай, надень наушники, пожалуйста.
[36:52.520 --> 36:54.520]  Сейчас потестируем еще раз.
[36:54.520 --> 36:56.520]  Подживу хорошую пробку.
[36:58.520 --> 37:00.520]  Продолжим?
[37:06.520 --> 37:08.520]  Так, значит, на самом деле, значит,
[37:08.520 --> 37:10.520]  прежде чем приходить к энплею,
[37:10.520 --> 37:12.520]  я поговорю еще
[37:12.520 --> 37:14.520]  про эти вот классы.
[37:14.520 --> 37:16.520]  Значит, то, что здесь есть некоторая
[37:16.520 --> 37:18.520]  иерархия
[37:18.520 --> 37:20.520]  классов,
[37:20.520 --> 37:22.520]  значит, кроме
[37:22.520 --> 37:24.520]  p,
[37:24.520 --> 37:26.520]  ну, есть некоторый ряд
[37:26.520 --> 37:28.520]  тоже стандартных классов.
[37:34.520 --> 37:36.520]  Ну, важнейшие, я их так
[37:36.520 --> 37:38.520]  буду писать подряд,
[37:38.520 --> 37:40.520]  значит, важнейший из них это класс
[37:40.520 --> 37:42.520]  x,
[37:42.520 --> 37:44.520]  значит, класс
[37:44.520 --> 37:46.520]  x, это
[37:48.520 --> 37:50.520]  объединение по c
[37:50.520 --> 37:52.520]  от
[37:52.520 --> 37:54.520]  единицы бесконечности,
[37:54.520 --> 37:56.520]  значит, d time
[37:58.520 --> 38:00.520]  от 2 в степени n в степени c.
[38:04.520 --> 38:06.520]  То есть, это какая-то такая экспонента,
[38:06.520 --> 38:08.520]  но при этом экспоненты от полинома.
[38:08.520 --> 38:10.520]  Да, не просто от n.
[38:10.520 --> 38:12.520]  Да, не просто что-то в степени n,
[38:12.520 --> 38:14.520]  а что-то прямо в степени c.
[38:18.520 --> 38:20.520]  Значит, есть класс e,
[38:20.520 --> 38:22.520]  который чуть-чуть
[38:22.520 --> 38:24.520]  поменьше.
[38:24.520 --> 38:26.520]  Значит, e, то c, то c,
[38:26.520 --> 38:28.520]  от единицы до бесконечности,
[38:28.520 --> 38:30.520]  значит, тут
[38:30.520 --> 38:32.520]  d time
[38:34.520 --> 38:36.520]  от 2 в степени c.
[38:38.520 --> 38:40.520]  Да, это все классы языков.
[38:40.520 --> 38:42.520]  То есть, тут вообще такая
[38:42.520 --> 38:44.520]  структура получается многоступенчатая,
[38:44.520 --> 38:46.520]  что есть
[38:46.520 --> 38:48.520]  как бы, собственно, слова, про которые
[38:48.520 --> 38:50.520]  спрашивают, да или нет.
[38:50.520 --> 38:52.520]  Да, есть языки.
[38:52.520 --> 38:54.520]  Значит, языки это множество слов.
[38:56.520 --> 38:58.520]  Дальше есть классы.
[38:58.520 --> 39:00.520]  Классы языков.
[39:00.520 --> 39:02.520]  А дальше, в принципе, есть еще
[39:02.520 --> 39:04.520]  и иерархия классов.
[39:04.520 --> 39:06.520]  Да, то есть, ну, это не просто
[39:06.520 --> 39:08.520]  множество классов, да, какие-то структурированные.
[39:08.520 --> 39:10.520]  Вот.
[39:10.520 --> 39:12.520]  Ну, в данном случае, если
[39:12.520 --> 39:14.520]  такие вот p,
[39:14.520 --> 39:16.520]  q, p,
[39:16.520 --> 39:18.520]  ну, понятно, что
[39:18.520 --> 39:20.520]  экспонента, полинов меньше
[39:20.520 --> 39:22.520]  экспонента симпатически,
[39:22.520 --> 39:24.520]  а линейные экспоненты меньше
[39:24.520 --> 39:26.520]  полиминальные экспоненты.
[39:26.520 --> 39:28.520]  Да, дальше тут есть, например,
[39:28.520 --> 39:30.520]  тут уже не такое стандартное
[39:30.520 --> 39:32.520]  обозначение q, p,
[39:32.520 --> 39:34.520]  q от слова квазер.
[39:34.520 --> 39:36.520]  Значит, тут
[39:36.520 --> 39:38.520]  объединение
[39:38.520 --> 39:40.520]  по c, от единицы
[39:40.520 --> 39:42.520]  до бесконечности.
[39:42.520 --> 39:44.520]  Да, значит,
[39:44.520 --> 39:46.520]  вот
[39:46.520 --> 39:48.520]  два в степени
[39:48.520 --> 39:50.520]  логарины.
[39:50.520 --> 39:52.520]  n
[39:52.520 --> 39:54.520]  в степени
[39:54.520 --> 39:56.520]  c.
[39:56.520 --> 39:58.520]  Да, то есть, ну, можно сказать,
[39:58.520 --> 40:00.520]  что q, p, по отношению к
[40:00.520 --> 40:02.520]  p, это то же самое, что x, по отношению
[40:02.520 --> 40:04.520]  к е. Да, что
[40:04.520 --> 40:06.520]  вот здесь, если здесь
[40:06.520 --> 40:08.520]  c, то это как раз
[40:08.520 --> 40:10.520]  полинов, да.
[40:10.520 --> 40:12.520]  2 в степени целой логарины, это то же самое, что
[40:12.520 --> 40:14.520]  n в степени c.
[40:14.520 --> 40:16.520]  Вот, а здесь 2 в степени c на n.
[40:16.520 --> 40:18.520]  Вот, соответственно, здесь 2 в степени
[40:18.520 --> 40:20.520]  в степени c, а здесь 2 в степени логарины
[40:20.520 --> 40:22.520]  в степени c.
[40:22.520 --> 40:24.520]  Ну, дальше, в принципе, может быть там какой-нибудь
[40:24.520 --> 40:26.520]  е-е,
[40:26.520 --> 40:28.520]  например, да, это
[40:30.520 --> 40:32.520]  тоже объединение, здесь, соответственно,
[40:32.520 --> 40:34.520]  the time.
[40:34.520 --> 40:36.520]  Вот,
[40:36.520 --> 40:38.520]  два в степени 2 в степени tn,
[40:38.520 --> 40:40.520]  и на экспонента.
[40:40.520 --> 40:42.520]  Вот, может быть и эксп.
[40:44.520 --> 40:46.520]  Ну, понятно, я уже не буду
[40:46.520 --> 40:48.520]  писать.
[40:48.520 --> 40:50.520]  Вот, ну и может быть какие-то градации
[40:50.520 --> 40:52.520]  здесь делась.
[40:52.520 --> 40:54.520]  Например, есть
[40:54.520 --> 40:56.520]  такой очень нетипичный класс,
[40:56.520 --> 40:58.520]  который иногда упоминается,
[40:58.520 --> 41:00.520]  это вот такой класс sub-exp.
[41:02.520 --> 41:04.520]  И это, на самом деле, вместо
[41:04.520 --> 41:06.520]  объединения пересечения,
[41:06.520 --> 41:08.520]  да, это пересечение
[41:08.520 --> 41:10.520]  по всем эпсилон
[41:10.520 --> 41:12.520]  больше 0,
[41:14.520 --> 41:16.520]  так, а то значит the time
[41:18.520 --> 41:20.520]  от
[41:20.520 --> 41:22.520]  2 в степени n в степени
[41:22.520 --> 41:24.520]  epsilon.
[41:26.520 --> 41:28.520]  Да, то есть тут наоборот,
[41:28.520 --> 41:30.520]  да, это вот сюда
[41:30.520 --> 41:32.520]  идет, вместо n
[41:32.520 --> 41:34.520]  будет онкорень из n, онкорень
[41:34.520 --> 41:36.520]  из n, и вот если для всех
[41:36.520 --> 41:38.520]  epsilon это будет верно,
[41:38.520 --> 41:40.520]  то это вот будет sub-exp.
[41:42.520 --> 41:44.520]  Вот, но
[41:46.520 --> 41:48.520]  тут
[41:48.520 --> 41:50.520]  еще очень интересный класс
[41:50.520 --> 41:52.520]  в следующем смысле.
[41:52.520 --> 41:54.520]  Да, по крайней мере
[41:54.520 --> 41:56.520]  теоретически
[41:56.520 --> 41:58.520]  не гарантируется, что есть один алгоритм,
[41:58.520 --> 42:00.520]  у которого время работы
[42:00.520 --> 42:02.520]  меньше, чем любая такая величина
[42:02.520 --> 42:04.520]  синтетическая.
[42:04.520 --> 42:06.520]  Но может быть так, что для каждого эпсилона
[42:06.520 --> 42:08.520]  есть свой алгоритм, который работает быстрее,
[42:08.520 --> 42:10.520]  и тогда свой язык попадет
[42:10.520 --> 42:12.520]  в это пересечение.
[42:14.520 --> 42:16.520]  Вот.
[42:16.520 --> 42:18.520]  Так, ну теперь
[42:20.520 --> 42:22.520]  чуть-чуть поговорю
[42:22.520 --> 42:24.520]  про то, какие тут
[42:24.520 --> 42:26.520]  могут быть задачи.
[42:26.520 --> 42:28.520]  Ну вот E это, наверное,
[42:28.520 --> 42:30.520]  самый такой
[42:30.520 --> 42:32.520]  появляющийся язык,
[42:32.520 --> 42:34.520]  самый сейчас появляющийся
[42:34.520 --> 42:36.520]  класс.
[42:38.520 --> 42:40.520]  Да, потому что, например,
[42:40.520 --> 42:42.520]  да, вообще есть теорема
[42:42.520 --> 42:44.520]  в булирархии, мы, наверное,
[42:44.520 --> 42:46.520]  ее не будем доказывать, но опять же, знаете,
[42:46.520 --> 42:48.520]  очень полезно, что вот в этом ряду
[42:48.520 --> 42:50.520]  каждый следующий класс строго больше, чем
[42:50.520 --> 42:52.520]  предыдущий.
[42:52.520 --> 42:54.520]  Да, то есть, действительно есть
[42:54.520 --> 42:56.520]  опять же там
[42:56.520 --> 42:58.520]  я точные условия не буду
[42:58.520 --> 43:00.520]  давать, но
[43:00.520 --> 43:02.520]  интуитивный смысл
[43:02.520 --> 43:04.520]  такой, что чем больше времени дать,
[43:04.520 --> 43:06.520]  тем больше задач можно решить.
[43:08.520 --> 43:10.520]  Причем это верно даже внутри P, да, то есть, скажем,
[43:10.520 --> 43:12.520]  за N в кубе можно решить
[43:12.520 --> 43:14.520]  строго больше задачи, чем за N в квадрате.
[43:16.520 --> 43:18.520]  И так далее.
[43:18.520 --> 43:20.520]  За 3 в степени N
[43:20.520 --> 43:22.520]  можно решить строго больше, чем за 2 в степени,
[43:22.520 --> 43:24.520]  и так далее.
[43:24.520 --> 43:26.520]  Но по крайней мере
[43:26.520 --> 43:28.520]  на каждом следующем этапе есть задач
[43:28.520 --> 43:30.520]  которые не решаются на предыдущем.
[43:30.520 --> 43:32.520]  Но так, чтобы
[43:32.520 --> 43:34.520]  Яну в виде получить такую
[43:34.520 --> 43:36.520]  задачу, и
[43:36.520 --> 43:38.520]  она была осмысленная, и принес, чтобы можно
[43:38.520 --> 43:40.520]  было доказать это, это вот не так
[43:40.520 --> 43:42.520]  легко.
[43:44.520 --> 43:46.520]  Вот. Ну, например,
[43:46.520 --> 43:48.520]  вот в классе E будут лежать
[43:48.520 --> 43:50.520]  разные переборные
[43:50.520 --> 43:52.520]  задачи.
[43:52.520 --> 43:54.520]  Они, на самом деле, в NP лежат, и мы, на самом деле, про них
[43:54.520 --> 43:56.520]  не знаем, потому что они EF лежат.
[43:56.520 --> 43:58.520]  Ну, вот переборные, типа
[43:58.520 --> 44:00.520]  раскраска в 3 цвета, например.
[44:00.520 --> 44:02.520]  Ну, а тогда, скажем,
[44:02.520 --> 44:04.520]  N вершин, 3 цвета,
[44:04.520 --> 44:06.520]  поэтому простейший переборный алгоритм
[44:06.520 --> 44:08.520]  это 3 в степени N
[44:08.520 --> 44:10.520]  умножить на
[44:10.520 --> 44:12.520]  небольшое время для проверки
[44:12.520 --> 44:14.520]  каких-то расходов.
[44:16.520 --> 44:18.520]  Вот. Гамильтонов цикл
[44:18.520 --> 44:20.520]  или путь.
[44:20.520 --> 44:22.520]  Но, на самом деле, если
[44:22.520 --> 44:24.520]  перебирать напрямую,
[44:24.520 --> 44:26.520]  то нужно перебирать все
[44:26.520 --> 44:28.520]  перестановки, а перестановка будет, как раз, N
[44:28.520 --> 44:30.520]  факториал.
[44:30.520 --> 44:32.520]  То есть, в принципе, гамильтонов путь, если
[44:32.520 --> 44:34.520]  решать простым
[44:34.520 --> 44:36.520]  перебором, то будет, как раз, алгоритма
[44:36.520 --> 44:38.520]  из EXP. Да, тут будет
[44:38.520 --> 44:40.520]  ну, N факториал, это там
[44:40.520 --> 44:42.520]  по форме стирлинга, типа N в степени
[44:42.520 --> 44:44.520]  то есть, типа 2 в степени
[44:44.520 --> 44:46.520]  N на гриф плос N, что
[44:46.520 --> 44:48.520]  немножко больше, чем 20% констанции.
[44:48.520 --> 44:50.520]  Да, вот гамильтонов путь
[44:52.520 --> 44:54.520]  значит, гамильтонов путь
[44:54.520 --> 44:56.520]  при простейшем переборе
[44:56.520 --> 44:58.520]  будет решать вот здесь вот.
[44:58.520 --> 45:00.520]  Но, на самом деле, есть более хитрый алгоритм,
[45:00.520 --> 45:02.520]  который его вот сюда отправит.
[45:02.520 --> 45:04.520]  Вот. И вообще
[45:04.520 --> 45:06.520]  очень довольно сложно
[45:06.520 --> 45:08.520]  естественным образом придумать
[45:08.520 --> 45:10.520]  язык, который будет вот здесь вот.
[45:10.520 --> 45:12.520]  Но там непонятно будет ли его здесь.
[45:14.520 --> 45:16.520]  Вот. Но искусственно можно там
[45:16.520 --> 45:18.520]  что угодно придумать.
[45:18.520 --> 45:20.520]  Да, значит, например, вот из
[45:20.520 --> 45:22.520]  квазиполиномов.
[45:22.520 --> 45:24.520]  А почему, кстати, квазиполином?
[45:24.520 --> 45:26.520]  Ну, потому что не N в степени константа,
[45:26.520 --> 45:28.520]  а N в степени алгоритма, да, или N в степени
[45:28.520 --> 45:30.520]  полинома от алгоритма.
[45:30.520 --> 45:32.520]  Ну, например,
[45:32.520 --> 45:34.520]  можно придумать такую задачу,
[45:34.520 --> 45:36.520]  у которой будет перебор
[45:36.520 --> 45:38.520]  ровного такого размера.
[45:38.520 --> 45:40.520]  Например, задача
[45:40.520 --> 45:42.520]  если в графе
[45:42.520 --> 45:44.520]  из N вершин клика размером
[45:44.520 --> 45:46.520]  логорифм N.
[45:46.520 --> 45:48.520]  Да, клика, то есть
[45:48.520 --> 45:50.520]  можно найти графизм вершин,
[45:50.520 --> 45:52.520]  логорифм N вершин, которые все
[45:52.520 --> 45:54.520]  друг с другом соединены.
[45:56.520 --> 45:58.520]  Ну, там
[45:58.520 --> 46:00.520]  будет то в стане из N
[46:00.520 --> 46:02.520]  по логорифм N, то будет
[46:02.520 --> 46:04.520]  как раз вот такого примерно порядка.
[46:04.520 --> 46:06.520]  Да, порядка N в степени логорина.
[46:08.520 --> 46:10.520]  Вот. То есть вот это будет
[46:10.520 --> 46:14.520]  полный перебор.
[46:16.520 --> 46:18.520]  Вот. Может это быть
[46:18.520 --> 46:20.520]  из какой-то
[46:20.520 --> 46:22.520]  значит,
[46:22.520 --> 46:24.520]  из какой-то теорем математически
[46:24.520 --> 46:26.520]  получаться. Например, есть такая теорема
[46:26.520 --> 46:28.520]  о доминирующем множестве
[46:34.520 --> 46:36.520]  турниря. Да, значит такой граф
[46:36.520 --> 46:38.520]  турнир. Значит, турнир
[46:38.520 --> 46:40.520]  это такой полный и ориентированный граф.
[46:40.520 --> 46:42.520]  Да, то есть тут есть
[46:42.520 --> 46:44.520]  значит, есть там N команд
[46:44.520 --> 46:46.520]  и они все друг с другом сыграли без
[46:46.520 --> 46:48.520]  ничьих. Да, и там в какую-то
[46:48.520 --> 46:50.520]  сторону приведено ребро.
[46:50.520 --> 46:52.520]  Так вот,
[46:52.520 --> 46:54.520]  но что называется доминирующим
[46:54.520 --> 46:56.520]  если
[46:56.520 --> 46:58.520]  в любую вершину N из него
[46:58.520 --> 47:00.520]  ведет хотя бы одно ребро
[47:00.520 --> 47:02.520]  из него.
[47:02.520 --> 47:04.520]  Да, то есть набор команд доминирующий,
[47:04.520 --> 47:06.520]  если любая команда оставшись
[47:06.520 --> 47:08.520]  проиграла хотя бы одно из этих.
[47:10.520 --> 47:12.520]  Вот. Но там есть теорема,
[47:12.520 --> 47:14.520]  что в любом турнире есть доминирующий множество
[47:14.520 --> 47:16.520]  размера логарифма N.
[47:16.520 --> 47:18.520]  И тогда задача поиска такого множества
[47:18.520 --> 47:20.520]  будет как раз иметь вот такую сложность.
[47:20.520 --> 47:22.520]  Да, тоже опять же
[47:22.520 --> 47:24.520]  C из N пологарифма N.
[47:26.520 --> 47:28.520]  Вот.
[47:28.520 --> 47:30.520]  В общем, могут быть осмысленные задачи
[47:30.520 --> 47:32.520]  на разных уровнях. Но вот есть
[47:32.520 --> 47:34.520]  даже с
[47:34.520 --> 47:36.520]  другими базами есть экспонент, тоже есть
[47:36.520 --> 47:38.520]  вполне осмысленные задачи,
[47:38.520 --> 47:40.520]  но они обычно
[47:42.520 --> 47:44.520]  как сложная математика связанная.
[47:44.520 --> 47:46.520]  Ну, например, если там
[47:46.520 --> 47:48.520]  спрашивать что-нибудь про выигрышные стратегии,
[47:48.520 --> 47:50.520]  то это все будет где-то вот
[47:50.520 --> 47:52.520]  в е и в эк.
[47:54.520 --> 47:56.520]  Кто выигрывает в шахматах N на N?
[47:58.520 --> 48:00.520]  Да, или шахматах N на N.
[48:00.520 --> 48:02.520]  Если в стратегии просто кто выигрывает
[48:02.520 --> 48:04.520]  в шахматах,
[48:04.520 --> 48:06.520]  то это на самом деле вообще не задача
[48:06.520 --> 48:08.520]  этого класса. Просто какой-то один ответ
[48:08.520 --> 48:10.520]  там нет параметра.
[48:10.520 --> 48:12.520]  Да, мы просто его не знаем,
[48:12.520 --> 48:14.520]  но этот ответ там есть.
[48:14.520 --> 48:16.520]  А вот если обобщить шахмат
[48:16.520 --> 48:18.520]  на доску N на N,
[48:18.520 --> 48:20.520]  то это же будет такого рода задача.
[48:20.520 --> 48:22.520]  Тут уже будет асимптотика,
[48:22.520 --> 48:24.520]  будет куда-то стремиться.
[48:24.520 --> 48:26.520]  Ну, и на самом деле там будет
[48:26.520 --> 48:28.520]  именно экспонента какая-то.
[48:28.520 --> 48:30.520]  Ну, это на самом деле еще зависит
[48:30.520 --> 48:32.520]  от того о точных правил,
[48:32.520 --> 48:34.520]  что мы там
[48:34.520 --> 48:36.520]  по повторам разрешаем и так далее.
[48:36.520 --> 48:38.520]  Но, в принципе,
[48:38.520 --> 48:40.520]  так
[48:40.520 --> 48:42.520]  наверное можно так формулировать,
[48:42.520 --> 48:44.520]  что это будет какая-то двойная экспонента.
[48:46.520 --> 48:48.520]  Но при классических правилах
[48:48.520 --> 48:50.520]  там будет экспоненционное число позиций,
[48:50.520 --> 48:52.520]  и мы соответственно
[48:52.520 --> 48:54.520]  будем каждую из них
[48:54.520 --> 48:56.520]  размечать, там будет выигрышная она
[48:56.520 --> 48:58.520]  или проигрышная,
[48:58.520 --> 49:00.520]  ну, и рано или поздно
[49:00.520 --> 49:02.520]  поймем про начальную выигрышную
[49:02.520 --> 49:04.520]  или проигрышную.
[49:04.520 --> 49:06.520]  Вот.
[49:06.520 --> 49:08.520]  То есть это будет экспенциальный алгоритм.
[49:14.520 --> 49:16.520]  Да, сейчас кроме квазиполинома
[49:16.520 --> 49:18.520]  есть, по-моему, театрополином,
[49:18.520 --> 49:20.520]  который немножко
[49:20.520 --> 49:22.520]  другой смысл имеет.
[49:22.520 --> 49:24.520]  Вот я оговаривался
[49:24.520 --> 49:26.520]  про простые числа,
[49:26.520 --> 49:28.520]  то когда мы говорим о полиномиальности
[49:28.520 --> 49:30.520]  проверки простоты,
[49:30.520 --> 49:32.520]  то здесь вместо n
[49:32.520 --> 49:34.520]  мы поставим логарифм n,
[49:34.520 --> 49:36.520]  потому что полином не от самого числа,
[49:36.520 --> 49:38.520]  а от длины его записи,
[49:38.520 --> 49:40.520]  то есть от логарифма.
[49:40.520 --> 49:42.520]  А вот псевдополиномиальные, они как раз те,
[49:42.520 --> 49:44.520]  где от самого числа,
[49:44.520 --> 49:46.520]  где может быть много разных чисел, например,
[49:46.520 --> 49:48.520]  и, например, полином будет
[49:48.520 --> 49:50.520]  от количества этих чисел
[49:50.520 --> 49:52.520]  и от максимального этих чисел,
[49:52.520 --> 49:54.520]  а не логарифма.
[49:54.520 --> 49:56.520]  То есть длина записи
[49:56.520 --> 49:58.520]  это число на логарифм максимального.
[49:58.520 --> 50:00.520]  А если полином
[50:00.520 --> 50:02.520]  от количества чисел
[50:02.520 --> 50:04.520]  и от самого максимального,
[50:04.520 --> 50:06.520]  то это псевдополином называется.
[50:16.520 --> 50:18.520]  По умолчанию
[50:18.520 --> 50:20.520]  полином это всегда полином
[50:20.520 --> 50:22.520]  от общей длины записи.
[50:22.520 --> 50:24.520]  И тогда, если у вас есть цепочка чисел,
[50:24.520 --> 50:26.520]  то длина этой записи
[50:26.520 --> 50:28.520]  это количество чисел в цепочке
[50:28.520 --> 50:30.520]  умножить на число знака
[50:30.520 --> 50:32.520]  в самом большом числе.
[50:32.520 --> 50:34.520]  А если мы...
[50:34.520 --> 50:36.520]  Нет, можно сказать, что псевдополином
[50:36.520 --> 50:38.520]  это если мы все числа
[50:38.520 --> 50:40.520]  записываем в лунарной записи,
[50:40.520 --> 50:42.520]  то число записываем через n едини.
[50:42.520 --> 50:44.520]  И после этого
[50:44.520 --> 50:46.520]  от такой увеличенной записи
[50:46.520 --> 50:48.520]  это будет полином.
[50:48.520 --> 50:50.520]  Вот этот псевдополином
[50:50.520 --> 50:52.520]  и т.д.
[50:52.520 --> 50:54.520]  То есть сортировки
[50:54.520 --> 50:56.520]  за n и n
[50:56.520 --> 50:58.520]  вычисляют все же полиномы?
[50:58.520 --> 51:00.520]  Да нет, почему?
[51:00.520 --> 51:02.520]  Мы же сравнивали...
[51:02.520 --> 51:04.520]  Нет, смотрите,
[51:04.520 --> 51:06.520]  когда мы говорим про сортировки,
[51:06.520 --> 51:08.520]  то мы в качестве базовой операции
[51:08.520 --> 51:10.520]  учитываем сравнение
[51:10.520 --> 51:12.520]  двух элементов.
[51:12.520 --> 51:14.520]  И если эти элементы как-нибудь по нормальному
[51:14.520 --> 51:16.520]  сравниваются, просто как числа,
[51:16.520 --> 51:18.520]  то, конечно, мы их умеем
[51:18.520 --> 51:20.520]  сравнить за полином
[51:20.520 --> 51:22.520]  от линной записи.
[51:22.520 --> 51:24.520]  Но может быть, само сравнение
[51:24.520 --> 51:26.520]  подразумевает какую-то сложную процедуру.
[51:26.520 --> 51:28.520]  И тогда сортировка
[51:28.520 --> 51:30.520]  будет использовать полинное число
[51:30.520 --> 51:32.520]  сравнений, но само сравнение может быть
[51:32.520 --> 51:34.520]  каким-то сложным.
[51:34.520 --> 51:38.520]  Ну конечно, да.
[51:38.520 --> 51:40.520]  Да, может быть так, что
[51:40.520 --> 51:42.520]  базовой операции
[51:42.520 --> 51:44.520]  не много,
[51:44.520 --> 51:46.520]  но они сами большие.
[51:46.520 --> 51:48.520]  И когда мы определяем
[51:48.520 --> 51:50.520]  все классы P,
[51:50.520 --> 51:52.520]  там, X и т.д.,
[51:52.520 --> 51:54.520]  мы должны быть
[51:54.520 --> 51:56.520]  уверены, что
[51:56.520 --> 52:02.520]  сортировка
[52:02.520 --> 52:04.520]  P, там, X и т.д.,
[52:04.520 --> 52:06.520]  мы доходим до самых маленьких операций.
[52:06.520 --> 52:08.520]  Поэтому если базовые операции
[52:08.520 --> 52:10.520]  сами все полиномиальные,
[52:10.520 --> 52:12.520]  то это ничего не меняет.
[52:12.520 --> 52:14.520]  А если базовые операции вдруг
[52:14.520 --> 52:16.520]  оказались сложными,
[52:16.520 --> 52:18.520]  тогда нужно еще на время
[52:18.520 --> 52:20.520]  для базовой операции умножить,
[52:20.520 --> 52:22.520]  чтобы получить нужную оценку.
[52:22.520 --> 52:26.520]  Конечно, да.
[52:26.520 --> 52:28.520]  Да, конечно, да.
[52:42.520 --> 52:44.520]  Ну ладно,
[52:44.520 --> 52:46.520]  соответственно, в принципе,
[52:46.520 --> 52:48.520]  классификация вот в тех классах
[52:48.520 --> 52:50.520]  тоже может иногда
[52:50.520 --> 52:52.520]  быть интересной задачей.
[52:52.520 --> 52:54.520]  Но давайте теперь перейдем
[52:54.520 --> 52:56.520]  все-таки к НП.
[53:00.520 --> 53:02.520]  Значит, на НП можно двумя способами
[53:02.520 --> 53:04.520]  смотреть.
[53:06.520 --> 53:08.520]  Значит, один вариант,
[53:08.520 --> 53:10.520]  и это вот то, что мы
[53:10.520 --> 53:12.520]  говорили про сертификаты,
[53:12.520 --> 53:14.520]  а второй вариант — это
[53:14.520 --> 53:16.520]  через специальную модель
[53:16.520 --> 53:18.520]  недоторминированных машин тьюринга.
[53:18.520 --> 53:20.520]  И, собственно, второй вариант
[53:20.520 --> 53:22.520]  и дал буквку N
[53:22.520 --> 53:24.520]  в название НП,
[53:24.520 --> 53:26.520]  потому что НП означает
[53:26.520 --> 53:28.520]  non-deterministic polynomial.
[53:28.520 --> 53:30.520]  То есть полиномиальное время
[53:30.520 --> 53:32.520]  на недоторминированной машине.
[53:32.520 --> 53:34.520]  Ну и, по крайней мере,
[53:34.520 --> 53:36.520]  немножко я поговорю про
[53:38.520 --> 53:40.520]  эти самые недоторминированные машины.
[53:42.520 --> 53:44.520]  И это не то же самое,
[53:44.520 --> 53:46.520]  что вероятностные машины.
[53:46.520 --> 53:48.520]  Да, значит, хотя
[53:48.520 --> 53:50.520]  оказалось бы, что
[53:52.520 --> 53:54.520]  оказалось бы, что
[53:54.520 --> 53:56.520]  детерминированные вероятности — это вроде как антонимы,
[53:56.520 --> 53:58.520]  но недоторминированные и
[53:58.520 --> 54:00.520]  вероятности — это не синонимы,
[54:00.520 --> 54:02.520]  это немножко разные вещи.
[54:02.520 --> 54:04.520]  Хотя что-то общее у них тоже есть.
[54:08.520 --> 54:10.520]  Ну, хорошо,
[54:10.520 --> 54:12.520]  недоторминированные
[54:12.520 --> 54:14.520]  машины Тьюринга.
[54:14.520 --> 54:16.520]  Что это такое?
[54:16.520 --> 54:18.520]  Значит, математически
[54:18.520 --> 54:20.520]  можно сказать, что
[54:20.520 --> 54:22.520]  у них функция перехода —
[54:22.520 --> 54:24.520]  это не однозначная функция, а многозначная.
[54:28.520 --> 54:30.520]  Да, то есть это
[54:30.520 --> 54:32.520]  аналог
[54:32.520 --> 54:34.520]  обычных
[54:36.520 --> 54:38.520]  машин Тьюринга
[54:38.520 --> 54:40.520]  с многозначной
[54:46.520 --> 54:48.520]  функцией перехода.
[54:58.520 --> 55:00.520]  Вот, а как тогда
[55:00.520 --> 55:02.520]  они работают?
[55:02.520 --> 55:04.520]  Ну, они, получается, работают
[55:04.520 --> 55:06.520]  как ветвящиеся процессы.
[55:06.520 --> 55:08.520]  То есть у нас
[55:10.520 --> 55:12.520]  место
[55:14.520 --> 55:16.520]  линейного вычисления
[55:16.520 --> 55:18.520]  получается дерево.
[55:18.520 --> 55:20.520]  Место линейного вычисления
[55:22.520 --> 55:24.520]  получается дерево.
[55:24.520 --> 55:26.520]  То есть можно себе представлять
[55:28.520 --> 55:30.520]  тут
[55:32.520 --> 55:34.520]  как бы
[55:34.520 --> 55:36.520]  тут как бы
[55:36.520 --> 55:38.520]  хорошие метафоры такие проявленные вселенные.
[55:38.520 --> 55:40.520]  Что
[55:40.520 --> 55:42.520]  вот если
[55:42.520 --> 55:44.520]  машина встречает, когда
[55:44.520 --> 55:46.520]  реально есть много разных вариантов перехода,
[55:46.520 --> 55:48.520]  то она
[55:48.520 --> 55:50.520]  как бы создает несколько копий
[55:50.520 --> 55:52.520]  из проявленных вселенных.
[55:52.520 --> 55:54.520]  И в одной копии запущен
[55:54.520 --> 55:56.520]  один переход, другой копий, другой переход
[55:56.520 --> 55:58.520]  и так далее.
[55:58.520 --> 56:00.520]  А дальше, если еще раз
[56:00.520 --> 56:02.520]  будет много вариантов, то она еще раз
[56:02.520 --> 56:04.520]  появится.
[56:04.520 --> 56:06.520]  То есть получается, что
[56:06.520 --> 56:08.520]  каждый раз
[56:08.520 --> 56:10.520]  каждый раз получается
[56:10.520 --> 56:12.520]  вот такое ответвление.
[56:16.520 --> 56:18.520]  Где-то может быть
[56:18.520 --> 56:20.520]  и нет ответвления, где-то одно значение.
[56:20.520 --> 56:22.520]  Где-то, возможно, даже
[56:22.520 --> 56:24.520]  пустое множество в тупик пришло
[56:24.520 --> 56:26.520]  и никакого ответа
[56:26.520 --> 56:28.520]  нету.
[56:28.520 --> 56:30.520]  Вот.
[56:30.520 --> 56:32.520]  Ну и так далее.
[56:32.520 --> 56:34.520]  Это как-то идет.
[56:34.520 --> 56:36.520]  А дальше происходит следующее.
[56:36.520 --> 56:38.520]  Если какая-то из копий
[56:38.520 --> 56:40.520]  в какой-то из проявленных вселенных
[56:40.520 --> 56:42.520]  пришла к ответу
[56:42.520 --> 56:44.520]  да,
[56:44.520 --> 56:46.520]  то тогда как бы все это слопывается,
[56:46.520 --> 56:48.520]  получается ответ да.
[56:48.520 --> 56:50.520]  То есть она как бы во все
[56:50.520 --> 56:52.520]  проявленные вселенные шлёт сигнал,
[56:52.520 --> 56:54.520]  что ответ да.
[56:54.520 --> 56:56.520]  И все это узнают.
[56:56.520 --> 56:58.520]  А если ответ нет,
[56:58.520 --> 57:00.520]  то ничего не делает.
[57:00.520 --> 57:02.520]  И если сигнала туда не пришло,
[57:02.520 --> 57:04.520]  то значит ответ нет.
[57:04.520 --> 57:06.520]  Вот. То есть получается
[57:06.520 --> 57:08.520]  это именно для бинарного
[57:08.520 --> 57:10.520]  ответа.
[57:10.520 --> 57:12.520]  Значит, если одна из ветвей
[57:14.520 --> 57:16.520]  если одна из ветвей
[57:20.520 --> 57:22.520]  пришла
[57:22.520 --> 57:24.520]  к ответу
[57:24.520 --> 57:26.520]  да,
[57:30.520 --> 57:32.520]  то, соответственно, общий ответ
[57:32.520 --> 57:34.520]  да.
[57:46.520 --> 57:48.520]  Вот. А если,
[57:48.520 --> 57:50.520]  соответственно,
[57:50.520 --> 57:52.520]  те пришли к ответу нет,
[57:52.520 --> 57:54.520]  то общий ответ нет.
[57:54.520 --> 57:56.520]  То есть можно сказать, что ответ это дизьюция
[57:56.520 --> 57:58.520]  ответов на отдельных ветвях.
[57:58.520 --> 58:00.520]  Вот. А время работы
[58:00.520 --> 58:02.520]  это длина максимальной ветви.
[58:02.520 --> 58:04.520]  Вот.
[58:04.520 --> 58:06.520]  Иначе
[58:08.520 --> 58:10.520]  иначе ответ нет.
[58:12.520 --> 58:14.520]  Вот. А время работы всей машины
[58:14.520 --> 58:16.520]  это
[58:16.520 --> 58:18.520]  время максимальное
[58:18.520 --> 58:20.520]  на всех ветвях.
[58:20.520 --> 58:22.520]  То есть длина максимальной ветви.
[58:28.520 --> 58:30.520]  Максимальная, да.
[58:30.520 --> 58:32.520]  Время работы, длина.
[58:38.520 --> 58:40.520]  Да.
[58:40.520 --> 58:42.520]  Мы не хотим такого.
[58:42.520 --> 58:44.520]  Ну вот, да.
[58:44.520 --> 58:46.520]  Мы не хотим, чтобы
[58:46.520 --> 58:48.520]  было бесконечно.
[58:48.520 --> 58:50.520]  Хотим, чтобы всегда останавливалось.
[58:54.520 --> 58:56.520]  Ну, может никакого
[58:56.520 --> 58:58.520]  ответа не дать.
[58:58.520 --> 59:00.520]  То есть где-то может быть
[59:00.520 --> 59:02.520]  где-то ответ да, там где-то ответ нет.
[59:02.520 --> 59:04.520]  А где-то никакого. Ну, может считать, что никакого
[59:04.520 --> 59:06.520]  значит нет.
[59:06.520 --> 59:08.520]  Не особо повлияет на что-то.
[59:12.520 --> 59:14.520]  Ну, да.
[59:14.520 --> 59:16.520]  Ну, тут это, в общем, тут
[59:16.520 --> 59:18.520]  вообще в машине-чурнике
[59:18.520 --> 59:20.520]  можно очень много чего варьировать.
[59:20.520 --> 59:22.520]  Получает то же самое здесь тоже. Можно, например, считать,
[59:22.520 --> 59:24.520]  что у вас просто есть две функции
[59:24.520 --> 59:26.520]  перехода.
[59:26.520 --> 59:28.520]  Значит, тогда будет
[59:28.520 --> 59:30.520]  либо ветвление на две, либо
[59:30.520 --> 59:32.520]  без ветвления, если две функции дают
[59:32.520 --> 59:34.520]  одно и то же.
[59:36.520 --> 59:38.520]  Значит, можно считать, что
[59:38.520 --> 59:40.520]  может быть большое ветвление,
[59:40.520 --> 59:42.520]  может быть тупика, обязательно там либо да, либо нет.
[59:50.520 --> 59:52.520]  Вот.
[59:58.520 --> 01:00:00.520]  Ну хорошо, значит, вот это вот один подход,
[01:00:00.520 --> 01:00:02.520]  а другой подход чертификатный.
[01:00:06.520 --> 01:00:08.520]  Да, сейчас я тут не недороскал подход.
[01:00:08.520 --> 01:00:10.520]  В общем, после этого,
[01:00:10.520 --> 01:00:12.520]  да, вот, кроме
[01:00:12.520 --> 01:00:14.520]  D time, можно определить
[01:00:14.520 --> 01:00:16.520]  M time, да,
[01:00:16.520 --> 01:00:18.520]  то же самый язык, рассказываемый
[01:00:18.520 --> 01:00:20.520]  на вот такой вот нетремерной машине
[01:00:20.520 --> 01:00:22.520]  за соответствующего времени.
[01:00:24.520 --> 01:00:26.520]  В остальном все то же самое.
[01:00:38.520 --> 01:00:40.520]  Вот.
[01:00:46.520 --> 01:00:48.520]  А вот сейчас обсудим.
[01:01:02.520 --> 01:01:04.520]  Так, дай сначала определим.
[01:01:04.520 --> 01:01:06.520]  Значит, M time
[01:01:08.520 --> 01:01:10.520]  от M.
[01:01:10.520 --> 01:01:12.520]  Значит, это класс.
[01:01:12.520 --> 01:01:14.520]  Класс языков
[01:01:18.520 --> 01:01:20.520]  распознаваемых
[01:01:22.520 --> 01:01:24.520]  на
[01:01:26.520 --> 01:01:28.520]  нетремерной машине
[01:01:28.520 --> 01:01:30.520]  тюринга
[01:01:30.520 --> 01:01:32.520]  за время у большой от M.
[01:01:32.520 --> 01:01:34.520]  За время у большой
[01:01:34.520 --> 01:01:36.520]  от M.
[01:01:40.520 --> 01:01:42.520]  Вот.
[01:01:42.520 --> 01:01:44.520]  И опять же данное время
[01:01:44.520 --> 01:01:46.520]  это глубина дерева,
[01:01:46.520 --> 01:01:48.520]  распознаваемых
[01:01:48.520 --> 01:01:50.520]  на смысле вот такого ответа.
[01:01:52.520 --> 01:01:54.520]  Вот.
[01:01:54.520 --> 01:01:56.520]  Ну и есть соответственно
[01:01:56.520 --> 01:01:58.520]  значит, класс
[01:01:58.520 --> 01:02:00.520]  NP.
[01:02:00.520 --> 01:02:02.520]  Значит, класс NP
[01:02:02.520 --> 01:02:04.520]  это
[01:02:06.520 --> 01:02:08.520]  соответственно, N time
[01:02:10.520 --> 01:02:12.520]  от N степени C.
[01:02:14.520 --> 01:02:16.520]  Может, например, класс NX.
[01:02:18.520 --> 01:02:20.520]  Да, NX,
[01:02:20.520 --> 01:02:22.520]  это соответственно
[01:02:24.520 --> 01:02:26.520]  то же самое.
[01:02:26.520 --> 01:02:28.520]  Да, вот там
[01:02:28.520 --> 01:02:30.520]  два степени C.
[01:02:30.520 --> 01:02:32.520]  Вот.
[01:02:32.520 --> 01:02:34.520]  Ну и конечно там NE может быть.
[01:02:34.520 --> 01:02:36.520]  Ну и даже NQP
[01:02:36.520 --> 01:02:38.520]  на том никто не изучает.
[01:02:38.520 --> 01:02:40.520]  Не изучает такое.
[01:02:40.520 --> 01:02:42.520]  Вот.
[01:02:44.520 --> 01:02:46.520]  Так.
[01:02:46.520 --> 01:02:48.520]  Видите, действительно, как они связаны
[01:02:48.520 --> 01:02:50.520]  друг с другом?
[01:02:50.520 --> 01:02:52.520]  Ну связь очень простая.
[01:02:52.520 --> 01:02:54.520]  Значит, знаете, D time
[01:02:54.520 --> 01:02:56.520]  D time
[01:02:58.520 --> 01:03:00.520]  от A от N
[01:03:02.520 --> 01:03:04.520]  вложено в N time
[01:03:08.520 --> 01:03:10.520]  в N time от A от N.
[01:03:12.520 --> 01:03:14.520]  А это вложено в D time.
[01:03:18.520 --> 01:03:20.520]  D time от
[01:03:20.520 --> 01:03:22.520]  два в степени
[01:03:22.520 --> 01:03:24.520]  но здесь я большое напишу.
[01:03:24.520 --> 01:03:26.520]  Потому что помолчалась
[01:03:26.520 --> 01:03:28.520]  констанция здесь, а нужно чтобы была
[01:03:28.520 --> 01:03:30.520]  констанция здесь.
[01:03:34.520 --> 01:03:36.520]  Вот. То есть, недетерминированные
[01:03:36.520 --> 01:03:38.520]  учисления можно моделировать
[01:03:38.520 --> 01:03:40.520]  детерминированными
[01:03:40.520 --> 01:03:42.520]  но за экспенсально большое время.
[01:03:42.520 --> 01:03:44.520]  Значит, почему?
[01:03:44.520 --> 01:03:46.520]  Ну потому что просто размер этого дерева
[01:03:46.520 --> 01:03:48.520]  будет экспенсален.
[01:03:48.520 --> 01:03:50.520]  Да, каждый раз, смотрите, даже если
[01:03:50.520 --> 01:03:52.520]  насветление больше, чем на два
[01:03:52.520 --> 01:03:54.520]  все равно оно будет
[01:03:54.520 --> 01:03:56.520]  в какую-то константу раз.
[01:03:56.520 --> 01:03:58.520]  Да, просто
[01:03:58.520 --> 01:04:00.520]  потому что у нас всего есть константы вариантов.
[01:04:00.520 --> 01:04:02.520]  Да, потому что есть константы новых символов
[01:04:02.520 --> 01:04:04.520]  констант новых состояний
[01:04:04.520 --> 01:04:06.520]  констант новых направлений.
[01:04:06.520 --> 01:04:08.520]  Все это перемножение будет какая-то константа,
[01:04:08.520 --> 01:04:10.520]  которая от N независима, есть только от машины.
[01:04:10.520 --> 01:04:12.520]  Вот. Поэтому размер
[01:04:12.520 --> 01:04:14.520]  этого дерева будет экспенсален
[01:04:14.520 --> 01:04:16.520]  от его глубины.
[01:04:16.520 --> 01:04:18.520]  Но и соответственно можно
[01:04:18.520 --> 01:04:20.520]  детерминированно обойти все листья
[01:04:20.520 --> 01:04:22.520]  понять есть там ответ
[01:04:22.520 --> 01:04:24.520]  да или нет
[01:04:24.520 --> 01:04:26.520]  и сказать какой будет ответ.
[01:04:26.520 --> 01:04:28.520]  Дальше. Поэтому
[01:04:28.520 --> 01:04:30.520]  соответственно вот.
[01:04:30.520 --> 01:04:32.520]  Вот. Ну, в частности
[01:04:32.520 --> 01:04:34.520]  в частности будет
[01:04:34.520 --> 01:04:36.520]  P вножено в N P
[01:04:38.520 --> 01:04:40.520]  и вножено в N P.
[01:04:44.520 --> 01:04:46.520]  Вот. Именно X пониже
[01:04:46.520 --> 01:04:48.520]  да, потому что если здесь N степени C,
[01:04:48.520 --> 01:04:50.520]  то здесь тоже N степени C.
[01:04:58.520 --> 01:05:00.520]  А вот это мы есть.
[01:05:00.520 --> 01:05:02.520]  Это мой вопрос.
[01:05:02.520 --> 01:05:04.520]  Смотрите, что мы знаем.
[01:05:04.520 --> 01:05:06.520]  Мы знаем, что P вложено
[01:05:06.520 --> 01:05:08.520]  в X строго.
[01:05:08.520 --> 01:05:10.520]  Вот. Но вот про эти два вложения
[01:05:10.520 --> 01:05:12.520]  промежуточных не про одно.
[01:05:12.520 --> 01:05:14.520]  У нас неизвестно, строго или оно.
[01:05:14.520 --> 01:05:16.520]  Да, хотя верят,
[01:05:16.520 --> 01:05:18.520]  что оба строгие,
[01:05:18.520 --> 01:05:20.520]  но не парадонка доказать не могут.
[01:05:24.520 --> 01:05:26.520]  Вот.
[01:05:34.520 --> 01:05:36.520]  Так.
[01:05:36.520 --> 01:05:38.520]  Но у нас очень много времени осталось. Давайте я на это расскажу
[01:05:38.520 --> 01:05:40.520]  как вот это вот определение
[01:05:40.520 --> 01:05:42.520]  через нетренированные машины
[01:05:42.520 --> 01:05:44.520]  связано с сертификатным,
[01:05:44.520 --> 01:05:46.520]  которое мы в прошлый раз
[01:05:46.520 --> 01:05:48.520]  обсудили.
[01:05:50.520 --> 01:05:52.520]  Да, значит, есть вот сертификатное определение.
[01:05:56.520 --> 01:05:58.520]  Сертификатное определение N P.
[01:06:00.520 --> 01:06:02.520]  Да, значит, у нас
[01:06:04.520 --> 01:06:06.520]  X должно лежать в A тогда и только тогда,
[01:06:06.520 --> 01:06:08.520]  когда существует Y.
[01:06:08.520 --> 01:06:10.520]  Такое, что
[01:06:10.520 --> 01:06:12.520]  В от XY
[01:06:12.520 --> 01:06:14.520]  равно единице.
[01:06:20.520 --> 01:06:22.520]  Вот. Ну и, соответственно, В работает за полинальное время,
[01:06:22.520 --> 01:06:24.520]  Y имеет полинальную длину.
[01:06:26.520 --> 01:06:28.520]  Вот. Все это одно и то же.
[01:06:34.520 --> 01:06:36.520]  Ну, смотрите, значит,
[01:06:36.520 --> 01:06:38.520]  из нетренированной
[01:06:38.520 --> 01:06:40.520]  детерминированной машины
[01:06:40.520 --> 01:06:42.520]  можно перейти
[01:06:42.520 --> 01:06:44.520]  в сертификатное.
[01:06:44.520 --> 01:06:46.520]  Ну, в следующем образом.
[01:06:46.520 --> 01:06:48.520]  Мы просто в сам сертификат запишем,
[01:06:48.520 --> 01:06:50.520]  по какой ветке вычисления нужно идти.
[01:06:52.520 --> 01:06:54.520]  Значит, включать 100Y
[01:06:54.520 --> 01:06:56.520]  это
[01:06:56.520 --> 01:06:58.520]  вет
[01:06:58.520 --> 01:07:00.520]  вычислений,
[01:07:02.520 --> 01:07:04.520]  приводящие
[01:07:04.520 --> 01:07:06.520]  к ответу.
[01:07:08.520 --> 01:07:10.520]  Да?
[01:07:14.520 --> 01:07:16.520]  Вот. А В
[01:07:16.520 --> 01:07:18.520]  это, соответственно, моделирование
[01:07:18.520 --> 01:07:20.520]  машины вдоль этой
[01:07:20.520 --> 01:07:22.520]  ветки.
[01:07:22.520 --> 01:07:24.520]  Значит, моделирование
[01:07:26.520 --> 01:07:28.520]  вычисления
[01:07:30.520 --> 01:07:32.520]  вдоль ветки Y.
[01:07:34.520 --> 01:07:36.520]  Ну, находить.
[01:07:40.520 --> 01:07:42.520]  Вот. А получается,
[01:07:42.520 --> 01:07:44.520]  что, во-первых,
[01:07:44.520 --> 01:07:46.520]  вот это вот моделирование.
[01:07:46.520 --> 01:07:48.520]  Ну, тут нужно вообще немножко
[01:07:48.520 --> 01:07:50.520]  сказать про универсальную машину тюринга.
[01:07:50.520 --> 01:07:52.520]  Это, наверное, проходили.
[01:07:52.520 --> 01:07:54.520]  Есть универсальная машина тюринга, которая умеет моделировать
[01:07:54.520 --> 01:07:56.520]  другие машины тюринга.
[01:07:56.520 --> 01:07:58.520]  И если там немножко посмотреть, то она это умеет делать
[01:07:58.520 --> 01:08:00.520]  с полиномерным
[01:08:00.520 --> 01:08:02.520]  замедлением. Ну, это примерно так же,
[01:08:02.520 --> 01:08:04.520]  как вот тут мы обсуждали все.
[01:08:04.520 --> 01:08:06.520]  Она, например,
[01:08:06.520 --> 01:08:08.520]  так же действует и с таким
[01:08:08.520 --> 01:08:10.520]  замедлением работает.
[01:08:10.520 --> 01:08:12.520]  А может быть, даже и с таким.
[01:08:12.520 --> 01:08:14.520]  Вообще, какое-то
[01:08:14.520 --> 01:08:16.520]  замедление должно быть, потому что у нас
[01:08:16.520 --> 01:08:18.520]  универсальная машина тюринга фиксирует
[01:08:18.520 --> 01:08:20.520]  число лент, а у моделируемой
[01:08:20.520 --> 01:08:22.520]  произвольное число лента.
[01:08:22.520 --> 01:08:24.520]  Поэтому какое-то замедление должно быть.
[01:08:24.520 --> 01:08:26.520]  Но если там хотя бы две ленты есть,
[01:08:26.520 --> 01:08:28.520]  тогда оно будет вот таким.
[01:08:28.520 --> 01:08:30.520]  Ну, и в любом случае
[01:08:30.520 --> 01:08:32.520]  в полиномерном.
[01:08:38.520 --> 01:08:40.520]  Нет, моделирует
[01:08:40.520 --> 01:08:42.520]  моделирует
[01:08:42.520 --> 01:08:44.520]  моделирует
[01:08:44.520 --> 01:08:46.520]  вычисления вдоль ветви у.
[01:08:56.520 --> 01:08:58.520]  Вот, а получается, что если действительно
[01:08:58.520 --> 01:09:00.520]  если ответ да,
[01:09:00.520 --> 01:09:02.520]  то тогда получается,
[01:09:02.520 --> 01:09:04.520]  что
[01:09:04.520 --> 01:09:06.520]  есть ветвь приводит к ответу да,
[01:09:06.520 --> 01:09:08.520]  можно ее
[01:09:10.520 --> 01:09:12.520]  можно ее подать на вход
[01:09:12.520 --> 01:09:14.520]  и верификаторы ее проверят
[01:09:14.520 --> 01:09:16.520]  и скажут, что действительно
[01:09:16.520 --> 01:09:18.520]  приводит к ответу да.
[01:09:18.520 --> 01:09:20.520]  Если все ветвь приводит к ответу нет,
[01:09:20.520 --> 01:09:22.520]  то тогда что верификатору не подать,
[01:09:22.520 --> 01:09:24.520]  он сразу скажет нет.
[01:09:24.520 --> 01:09:26.520]  Вот.
[01:09:26.520 --> 01:09:28.520]  Ну, и еще в другую сторону.
[01:09:30.520 --> 01:09:32.520]  Значит, в другую сторону.
[01:09:34.520 --> 01:09:36.520]  И сертификатного определения
[01:09:36.520 --> 01:09:38.520]  в
[01:09:38.520 --> 01:09:40.520]  определении
[01:09:40.520 --> 01:09:42.520]  через нетренированные машины.
[01:09:42.520 --> 01:09:44.520]  Ну, тут история такая,
[01:09:44.520 --> 01:09:46.520]  что как машина должна сначала
[01:09:46.520 --> 01:09:48.520]  угадать сертификат.
[01:09:48.520 --> 01:09:50.520]  Угадать сертификат.
[01:09:52.520 --> 01:09:54.520]  Да, тут машина
[01:09:56.520 --> 01:09:58.520]  машина сначала
[01:10:02.520 --> 01:10:04.520]  угадывает сертификат.
[01:10:12.520 --> 01:10:14.520]  Угадывает сертификат, затем
[01:10:14.520 --> 01:10:16.520]  проверяет,
[01:10:18.520 --> 01:10:20.520]  затем проверяет, подходит ли он.
[01:10:22.520 --> 01:10:24.520]  Затем проверяет,
[01:10:34.520 --> 01:10:36.520]  подходит ли он.
[01:10:38.520 --> 01:10:40.520]  Ну, то есть
[01:10:40.520 --> 01:10:42.520]  картинного чтения будет такая, что
[01:10:42.520 --> 01:10:46.200]  как бы такое двоичное дерево полное, то есть сначала она
[01:10:47.000 --> 01:10:50.480]  выбирает, пусть там первый бит у будет ноль или он будет один,
[01:10:50.920 --> 01:10:56.480]  потом выбирает, какой будет второй бит у и так далее, а потом, когда она все биты у выписала, она уже
[01:10:56.880 --> 01:10:59.040]  детерминированно вычисляет вот это самое в.
[01:11:00.280 --> 01:11:02.600]  Ну и тогда, если подходящий у есть,
[01:11:03.200 --> 01:11:05.200]  да еще и не слишком длинный,
[01:11:05.200 --> 01:11:09.160]  то она этот у выпишет и на нем придет к ответу да.
[01:11:09.960 --> 01:11:11.960]  Поэтому общий ответ машины будет да.
[01:11:12.280 --> 01:11:17.560]  Если ни один игрек не подходит, то на любой ветви в итоге будет ответ нет и общий ответ нет.
[01:11:18.880 --> 01:11:20.880]  Поэтому, действительно, вот такая вот машина
[01:11:21.560 --> 01:11:23.560]  дает тот же ответ, который
[01:11:24.240 --> 01:11:26.240]  дает вот это условие.
[01:11:29.520 --> 01:11:32.800]  Ну вот, поэтому действительно получается, что
[01:11:33.920 --> 01:11:35.920]  определение через n-time
[01:11:36.840 --> 01:11:38.840]  оправдывает обнущение n-p,
[01:11:39.960 --> 01:11:44.160]  да, определение через сертификаты просто удобно использовать,
[01:11:45.040 --> 01:11:47.040]  да, и
[01:11:47.880 --> 01:11:51.480]  более наглядно позволяет представлять, что тут происходит.
[01:11:53.600 --> 01:11:55.600]  Ну ладно, есть какие-то еще вопросы.
[01:11:59.160 --> 01:12:01.880]  Длину у, значит, длина у должна
[01:12:02.720 --> 01:12:04.720]  быть ограничена полиновом от х.
[01:12:04.840 --> 01:12:09.400]  На самом деле, можно считать, что время работы в это полином от х,
[01:12:10.000 --> 01:12:14.760]  и тогда от любого у он сможет прочесть только ограниченную тем же самым полиновом часть.
[01:12:15.760 --> 01:12:21.800]  И поэтому, можно считать, что у имеет ту самую длину каково время работы в.
[01:12:27.200 --> 01:12:29.200]  Пример,
[01:12:30.040 --> 01:12:36.480]  не, ну пример типа того, что х это, скажем, граф, а у раскраска три цвета, а в проверяет, что раскраска правильная.
[01:12:36.960 --> 01:12:39.480]  То есть, соседние вершины в разные цвета покрашены.
[01:12:41.840 --> 01:12:43.840]  Да, или там
[01:12:44.280 --> 01:12:47.800]  клика, например, что х это тоже граф, а у
[01:12:48.720 --> 01:12:54.760]  это набор вершин, а в проверяет, что они все друг другу соединены и что в наборе нужное число разных вершин.
[01:12:54.760 --> 01:12:56.760]  Вот.
[01:12:57.760 --> 01:13:02.760]  Ну хорошо, я думаю, на сегодня это все, в следующий раз начнем чрезвычайную полноту, и вот спасибо.
