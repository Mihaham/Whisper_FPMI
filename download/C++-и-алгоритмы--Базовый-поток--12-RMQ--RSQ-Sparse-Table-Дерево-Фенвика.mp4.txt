[00:00.000 --> 00:11.720]  Так, начнем лекцию. Сегодня мы начинаем новую веху в нашей базовой истории и будем говорить,
[00:11.720 --> 00:16.200]  собственно, мы начинаем четвертый модуль, заключительный, в нашем курсе мы будем говорить
[00:16.200 --> 00:27.080]  целиком и полностью про задачи rmq и rsq. Значит, расшифровываются как
[00:27.080 --> 00:53.000]  рейндж минимум или сам кьюри, ну или запросы, запрос минимума, суммы
[00:53.000 --> 01:08.680]  на отрезке. Будем разбирать эти задачи. Значит, для начала классическая базовая постановка. Задача.
[01:08.680 --> 01:35.200]  Дан некоторый массив. Вот и нужно отвечать на запросы следующего вида. Значит, запрос выглядит так.
[01:35.200 --> 01:44.160]  Как кьюри от l до r. Что это означает? Это означает, что надо найти
[01:44.160 --> 02:12.480]  результат некоторой операции на отрезке l до r. Ну, то есть, давайте приведем пример.
[02:12.480 --> 02:30.480]  Пусть мне дан массив, 7, 5, 0, 1, 2, 4, 3. Вот. 1, 2, 3, 4, 5, ну давайте шестерку еще напишем.
[02:30.480 --> 02:37.040]  Значит, там такой массив и периодически к нему приходят различные запросы. Например, найти минимум на отрезке
[02:37.040 --> 02:44.080]  отресов второго по четвертый элемент. Нолевой, первый, второй, третий, четвертый. То есть, мне нужно найти минимум вот на этом отрезке.
[02:44.080 --> 02:54.320]  То есть, естественно, в качестве ответа должен вернуться ноль. Или запрос найти сумму на отрезке с четвертого по, ну пусть по седьмой.
[02:54.320 --> 03:05.200]  5, 6, 7. Соответственно, нужно найти те сумму, что это 15. Да, ну и так далее. То есть, операции могут быть, вообще говоря, разные.
[03:05.280 --> 03:12.880]  То есть, не обязательно это операция минимума, суммы. То есть, может быть, операция произведения, максимума, наименьшего общего делителя,
[03:12.880 --> 03:22.640]  количество нулей. Ну и так далее. Ну, в общем, просто некоторый запрос к отрезку. Ну и соответственно, цель нашей сегодняшней будущей лекции
[03:22.640 --> 03:32.080]  понять, как можно это все делать наиболее эффективно. Ну, давайте для начала, как и в любой другой задаче, рассмотрим какой-нибудь наивный подход.
[03:32.080 --> 03:57.680]  Ну, то есть, понятно, что наивный подход работает за, за сколько? Ну, за линию, да. То есть, за θ от r минус l, ну или за o большое от n.
[03:57.760 --> 04:05.840]  Ну, где n это, где n это размер массива? Ну, то есть, естественно, если вам приходит некий запрос, то самый банальный способ это просто пройтись и все посчитать.
[04:05.840 --> 04:12.720]  Ну, естественно, такой способ вряд ли нас устраивает, особенно если у вас запросов много. Скажем, если у вас размер массива миллион, да, запросов тысяч,
[04:12.720 --> 04:20.320]  то за какое-то обозримое время, то есть, там меньше секунды и так далее, вы это, естественно, не посчитаете. Ну, а запросы, естественно, будут попадаться именно такие.
[04:20.320 --> 04:28.320]  С другой стороны, если вам известно, что запросов достаточно мало, то есть понятно дело, что если запросов мало,
[04:28.320 --> 04:34.320]  вам известно, что 2-3 запроса в сутки или всего 2-3 запроса на всю таблицу, то, естественно,
[04:34.320 --> 04:40.320]  никакие структуры данных строить не надо. Это, в принципе, нормальное решение.
[04:40.320 --> 04:44.320]  Вы за линейное время обработали все запросы. Но, естественно, мы будем стремиться не к этому,
[04:44.320 --> 04:49.320]  но мы будем стремиться немного к другим вещам. Давайте попробуем как-нибудь этот подход улучшить.
[04:49.320 --> 04:54.320]  Как-нибудь попробуем этот подход улучшить. И первое улучшение, про которое мы поговорим,
[04:54.320 --> 05:03.320]  будет, давайте, пункт номер ноль, SQRT, декомпозиция.
[05:03.320 --> 05:11.320]  Кто-нибудь слышал что-нибудь про такой метод? Встречался? Нет?
[05:11.320 --> 05:15.320]  Просто довольно популярный способ оптимизации каких-то запросов на отрезках
[05:15.320 --> 05:19.320]  или каких-то функций для работы с массивами. Давайте разберем.
[05:19.320 --> 05:25.320]  Идея в чем? Давайте здесь будет иллюстрация, здесь я буду писать, что происходит.
[05:25.320 --> 05:44.320]  Первым шагом разобьем массив на подотрезке размера B.
[05:44.320 --> 05:55.320]  Возьмем и как-то порежем наш большой массив на вот такие подотрезочки.
[05:55.320 --> 05:59.320]  Ну последний, может быть, не достигает B, но вот как-то так.
[05:59.320 --> 06:13.320]  Значит, это первый шаг. На втором шаге посчитаем результат операции
[06:13.320 --> 06:29.320]  на каждом из этих подотрезков. Ну и сохраним. Сохраним в каком-то отдельном массиве.
[06:29.320 --> 06:41.320]  Это означает буквально следующее. Мы считаем минимум или сумму здесь,
[06:41.320 --> 06:47.320]  считаем минимум и сумму здесь и строим некоторый новый массив,
[06:47.320 --> 06:55.320]  в котором все эти результаты сохраним. Размер исходного массива был N,
[06:55.320 --> 07:03.320]  размер этого массива N деленное на B, округленное куда? Вверх-вниз, кажется, вверх.
[07:03.320 --> 07:10.320]  Ну не важно, короче говоря, N деленное на B. Ну в общем-то и все.
[07:10.320 --> 07:16.320]  Это предпочет таким образом закончен. Да, тут важно отметить, что сейчас мы будем рассматривать.
[07:16.320 --> 07:20.320]  Понятно, если мы не используем наимный подход, то чтобы его не использовать,
[07:20.320 --> 07:23.320]  нам необходимо сделать какой-то предпочет. То есть нам необходимо либо построить
[07:23.320 --> 07:26.320]  какую-то структуру данных, либо как-то обработать наши входные данные,
[07:26.320 --> 07:29.320]  чтобы можно было в дальнейшем использовать более эффективные методы.
[07:29.320 --> 07:35.320]  Поэтому любой алгоритм я буду оценивать с помощью двух увеличений.
[07:35.320 --> 07:46.320]  Первое это время при процессинге.
[07:46.320 --> 07:51.320]  То есть это то время, которое я потрачу на то, чтобы прочитать мои входные данные
[07:51.320 --> 07:55.320]  и с ними что-то сделать, каким-то образом переупорядочить, построить какую-то структуру данных,
[07:55.320 --> 07:58.320]  чтобы можно было более эффективно наполнять запросы.
[07:58.320 --> 08:10.320]  Ну и время, соответственно, операции запроса.
[08:10.320 --> 08:14.320]  Так вот, давайте вернемся к этой структуре, то, что мы построили,
[08:14.320 --> 08:26.320]  и поймем, сколько времени нам потребуется, чтобы построить достаточно примитивную, но все-таки структуру данных.
[08:26.320 --> 08:29.320]  От n, да? Все согласны? Все видят, что от n.
[08:29.320 --> 08:32.320]  Ну потому что что я делаю? Я, по сути, беру первый отрезок, считаю в нем сумму минимум,
[08:32.320 --> 08:37.320]  или что угодно сохраняю, беру второй отрезок, считаю в нем зеленей на время и так далее.
[08:37.320 --> 08:40.320]  Если я просуммирую размеры всех отрезков, то, естественно, получу n.
[08:40.320 --> 08:45.320]  Поэтому время на припроцессинг, это от n.
[08:45.320 --> 08:50.320]  Как выполняется запрос?
[08:50.320 --> 08:54.320]  Значит, запрос выглядит следующим образом.
[08:54.320 --> 08:56.320]  Давайте здесь порисуем.
[08:56.320 --> 09:02.320]  Вот у меня есть большой массив, который я некоторым образом разбил на отрезке.
[09:02.320 --> 09:10.320]  Приходит запрос. Найти сумму произведения, что угодно, вот на таком отрезке.
[09:10.320 --> 09:20.320]  Как бы вы решили эту задачу, имея на руках вот то, что у нас есть?
[09:20.320 --> 09:34.320]  Вот эти. Да, смотрите, вот эти.
[09:34.320 --> 09:38.320]  Вот для всех этих элементов мы уже значение посчитали. Согласны?
[09:38.320 --> 09:45.320]  То есть мы можем запрос вот на этих отрезках свести к запросу вот на этих штуках.
[09:45.320 --> 09:50.320]  То есть давайте запишем.
[09:50.320 --> 10:19.320]  Если под отрезки целиком лежат в запросе, то считаем ответ
[10:19.320 --> 10:26.320]  в построенном массиве. Ну, под построенным массивом я имею в виду вот этот массив.
[10:26.320 --> 10:33.320]  То есть у нас есть потенциально много кусков больших, для которых мы все уже посчитали.
[10:33.320 --> 10:38.320]  Они находятся здесь. Поэтому свели задачу подсчета минимума или суммы на таком большом отрезке
[10:38.320 --> 10:41.320]  к подсчету на вот таком маленьком отрезке. Согласны?
[10:41.320 --> 10:51.320]  А что с вот этими делать? Да, ну а здесь посчитаем вручную.
[10:51.320 --> 11:01.320]  Остатки. Ну давайте. Что такое остатки? Остатки это вот эти вот штуки.
[11:01.320 --> 11:16.320]  Остатки посчитаем вручную. Вот.
[11:16.320 --> 11:26.320]  Такая идея. Ну и за сколько это все работает?
[11:26.320 --> 11:31.320]  Ну, N и B получается тут. У нас все-таки два параметра. То есть у нас есть параметры размер массива
[11:31.320 --> 11:35.320]  и размеры отрезков, на которые мы делим. То есть я думаю, вы понимаете, что если мы возьмем в качестве B единицу,
[11:35.320 --> 11:39.320]  то мы ничего не выиграем. Поэтому B нужно выбрать каким-то разумным.
[11:39.320 --> 11:43.320]  Сейчас вспомним вам каким. Давай для произвольного B попробуем понять, за сколько мы работаем.
[11:43.320 --> 11:50.320]  Ну вот первый шаг из опроса. За сколько мы посчитаем ответ вот на таких отрезках?
[11:50.320 --> 11:57.320]  Ну это неправда. Ну то есть в каждом отдельном отрезке, естественно, за единицу.
[11:57.320 --> 12:04.320]  Но суммарно-то их больше, чем один. N на B, да. То есть потенциально мы, в худшем случае,
[12:04.320 --> 12:11.320]  мы пройдемся по всем элементам здесь. Поэтому первый шаг работает за N делить на B. Все согласны?
[12:11.320 --> 12:16.320]  Большое N деленное на B. И плюс, за сколько времени мы обработаем вот эти самые остатки?
[12:16.320 --> 12:21.320]  За 2B. Ну снова, у нас каждый из остатков не превосходит B,
[12:21.320 --> 12:28.320]  поэтому мы отработаем за B, ну как бы на константу забьем, поэтому напишем просто плюс B. Вот такая сложность.
[12:28.320 --> 12:57.320]  Смотрите, мы эту схему будем улучшать, мы эту схему улучшим в какой-то момент. Возможно в следующем семестре.
[12:57.320 --> 13:01.320]  Вот так или иначе. Да, то есть вот эти штуки тоже можно оптимизировать.
[13:01.320 --> 13:07.320]  Ну самый простой ответ, который здесь мог быть, это скажем, мы можем посчитать сумму на всех префиксах здесь
[13:07.320 --> 13:14.320]  и сумму на всех суффиксах. Ну тоже предпочитать. Ну тут правда непонятно, как вы будете разбираться вот такими запросами.
[13:14.320 --> 13:21.320]  Это мы будем улучшать, это естественно не самый хороший подход, но это просто простой подход, который работает,
[13:21.320 --> 13:29.320]  с помощью которого можно заметно улучшить время запроса. Так вот, давайте попробуем вот эту штуку минимизировать.
[13:29.320 --> 13:41.320]  Что? Плюс 2B, ну в терминах онотации мы на констанции забиваем. Ну что 2B, что 3B.
[13:41.320 --> 13:56.320]  Ну давайте, чтобы никого не смущает. Пишу 2B. Так, давайте минимизируем эту штуку.
[13:56.320 --> 14:04.320]  Ну при каком B это достигает минимума. Кто считает производные, окститесь, да, B равно корень из N.
[14:04.320 --> 14:10.320]  Да, ну это легко понять почему, потому что если я возьму B равно корень из N, то первое слагаемое состояние корень из N
[14:10.320 --> 14:15.320]  и второе слагаемое состояние корень из N. Если разнюю что-то больше чем корень из N, то у меня второе слагаемое вырастет.
[14:15.320 --> 14:20.320]  Если я возьму что-то меньше чем корень из N, то у меня первое слагаемое вырастет. Ну понятно, да?
[14:20.320 --> 14:26.540]  поэтому минимум достигается на корне из n. Ну и собственно отсюда и название
[14:26.540 --> 14:33.660]  square-t-декомпозиция. То есть мы разбили наш весь отрезок под отрезки размера
[14:33.660 --> 14:43.600]  корень из n и улучшили время работы от n до корня из n, ну короче говоря улучшили
[14:43.600 --> 14:59.200]  запрос, но это все равно не очень хорошо. Почему? Не совсем понял. То есть приведите пример
[14:59.200 --> 15:11.240]  запроса, который работает за линию. Вот этот? Так если такие запросы, то я просто
[15:11.920 --> 15:15.920]  за линейное время считаю тут минимум, но размер этого кусочка у меня корень из n.
[15:15.920 --> 15:19.520]  И этот запрос я обрабатываю максимум за корень из n.
[15:19.520 --> 15:35.080]  Или что-то не ясно? Да. Вы смотрите время при процессинге это что? Вот вам приходит массив и
[15:35.080 --> 15:40.800]  говорят, то есть вам приходит задача, вам приходит массив и вам говорят,
[15:40.800 --> 15:46.120]  будет миллион запросов вида найти минимум на отрезке, найти сумму на отрезке. То есть вы
[15:46.120 --> 15:51.000]  можете потратить какое-то время на то, чтобы как-то обработать ваши данные, ну чтобы потом в
[15:51.000 --> 15:55.440]  последствии можно было эффективно считать. Вот пример. Если мы никак не обрабатываем массив,
[15:55.440 --> 15:59.720]  а просто в тупую обрабатываем наши запросы, то мы каждый запрос обрабатываем в худшем случае
[15:59.720 --> 16:05.360]  за линию. А что мы здесь делали? Мы взяли массив и не стали сразу отвечать на запросы,
[16:05.360 --> 16:11.000]  а провели некоторую работу над ним, то есть свели задачу к меньшим подзадачам, корневым,
[16:11.000 --> 16:21.080]  и потратили на это время teta от m. То есть это один раз на всю программу. А потом нам приходят
[16:21.080 --> 16:26.960]  запросы и мы отвечаем на все остальные запросы за корень из n. То есть суммарное время, если угодно,
[16:26.960 --> 16:36.480]  да, это t при процессинга плюс количество запросов, умноженное на tq от n, и это равно o от n
[16:36.480 --> 16:52.280]  плюс q на корень из n. Это суммарное время работы над этой структурой данных. Вот. Ну это вот два
[16:52.280 --> 17:00.640]  простых метода, которые позволяют практически бесплатно получить некоторые улучшения или как-то
[17:00.640 --> 17:05.360]  решить задачу. Ну как бы что ответ за n, что ответ за корень из n, на самом деле достаточно плохо,
[17:05.360 --> 17:09.600]  потому что они достаточно, то есть это достаточно быстрорастущие функции. Все-таки хотелось бы,
[17:09.600 --> 17:19.120]  хотелось бы чего-то получше. Ну и давайте перейдем к более осмысленным структурам данных, которые
[17:19.120 --> 17:27.120]  решают те же самые задачи. Значит, здесь необходимо поговорить про классификацию задач.
[17:27.120 --> 17:52.080]  Задача rmq-rsq под пункт классификация. Задача rmq-rsq делится на несколько категорий, то есть бывают
[17:52.080 --> 17:55.720]  разные, у них бывают разные постановки, и вот в зависимости от того, какая постановка вам дана,
[17:55.720 --> 18:07.320]  различают следующие виды задач. Бывают задачи статик, а бывают задачи дайнэмик. Чем эти задачи
[18:07.320 --> 18:21.560]  отличаются? Статик, массив не меняется. Ну то есть вот это та задача, которую мы решали сейчас. То
[18:21.560 --> 18:25.720]  есть вам дана некоторый массив, он фиксирован, то есть вам гарантируется, что он никогда не
[18:25.720 --> 18:29.120]  будет меняться, то есть в него не будут добавляться элементы, сами элементы тоже не будут изменяться,
[18:29.120 --> 18:33.440]  и вам нужно просто отвечать на запросы, сумму, минимум и так далее. Ну а динамика, естественно,
[18:33.440 --> 18:49.920]  давайте так скажем, есть запросы изменения. Ну то есть помимо запросов там найти сумму,
[18:49.920 --> 18:53.160]  найти минимум, найти максимум, периодически поступают запросы, скажем, изменить этот
[18:53.160 --> 18:57.520]  элемент и изменить какую-то группу элементов и так далее. Ну естественно, эта задача более
[18:57.520 --> 19:06.960]  сложная, ее мы тоже будем решать. Какие еще есть бывают виды? Бывают оффлайн задача и онлайн задача.
[19:06.960 --> 19:27.840]  Значит, оффлайн, все запросы известны заранее. Ну допустим, вам дана некоторый массив, и вам
[19:27.840 --> 19:33.840]  сразу же сказано, что будут именно такие вот запросы. То есть будет запрос, скажем, найти сумму
[19:33.840 --> 19:40.380]  с первого по третьей, с четвертого по пятой и так далее. Тут, в принципе, вам сказано, что вот
[19:40.380 --> 19:44.840]  есть запросы, вам приходит на вход запрос, и вы понимаете, что все эти отрезки не пересекаются
[19:44.840 --> 19:50.280]  друг с другом. Естественно, в таком случае вы можете просто все запросы считать и дальше обрабатывать
[19:50.280 --> 19:55.120]  их в нужном вам порядке. Скажем, обработать все запросы, которые работают с первой половиной
[19:55.120 --> 20:01.400]  массива, потом обработать запрос, который работает со второй половиной массива и так далее. Ну и онлайн задача.
[20:01.400 --> 20:11.520]  Давайте так скажем. Эта задача вид запрос-ответ. То есть вам приходит запрос, вам тут же нужно выплюнуть
[20:11.520 --> 20:18.120]  ответ. То есть если в оффлайн-задаче вы можете сразу считать все запросы и потом отвечать на них в
[20:18.120 --> 20:23.080]  нужном вам порядке, в каком вы хотите, то в случае онлайн-постановке вам приходит запрос, вам сразу
[20:23.080 --> 20:32.380]  нужно выдать ответ. Да, запрос и ответ. На лекциях мы будем рассматривать статическую постановку,
[20:32.380 --> 20:37.120]  динамическую постановку и онлайн постановку. С оффлайн вы тоже поработаете, но уже самостоятельно,
[20:37.120 --> 20:48.320]  на семинарах и в домашнем задании. Естественно, у нас есть две задачи, которые отличаются одной
[20:48.320 --> 20:57.120]  буквой. RMQ и RSQ. Давайте я даже, наверное, перейду куда-то сюда. Все ли понимают, что операции вида
[20:57.120 --> 21:02.280]  минимум и операции вида максимум, это разные операции и поэтому, скорее всего, их решать придется
[21:02.280 --> 21:09.320]  каким-то разными методами. Давайте переведем пример. Давайте не пример точнее, а попробуем ответить на вопрос,
[21:09.320 --> 21:26.200]  в чем отличие задач RMQ и RSQ. Давайте скажем, есть операция минимума, есть операция суммы.
[21:26.200 --> 21:34.800]  Давайте попробуем найти сходство и отличия. В общем, какими свойствами обладает операция минимума?
[21:34.800 --> 21:45.560]  Своица операции там, она ассоциативна, коммунативна. Ассоциативна или операция минимума?
[21:45.560 --> 21:55.800]  Ассоциативна, да, то есть есть ассоциативность. Сложение, естественно, тоже ассоциативно.
[21:55.800 --> 22:14.400]  Коммунативность есть. Здесь тоже есть. Ну хорошо, обе операции ассоциативны, обе операции коммунативны,
[22:14.400 --> 22:23.480]  а в чем отличие-то? Почему бы не просто взять, не свести там, скажем, обе задачи к одной и той же и все?
[22:23.480 --> 22:28.960]  Почему, скажем, методы, которые применимы к одной операции, могут быть неприменимы к другой операции?
[22:28.960 --> 22:38.960]  Что вы про плюс, например, можете сказать? Плюс операция обратимая.
[22:38.960 --> 22:51.440]  Минимум, к сожалению, нет. Ну скажем, если я вам дам уравнение вида, давайте так, х плюс 3 равно 5,
[22:52.400 --> 22:57.040]  то, как минимум, к экзамену по матану вы должны будете уметь это решать, правильно? То есть теоретически это возможно.
[22:57.040 --> 23:09.040]  Если я вам дам уравнение вида равно 3, то тут вам даже 6 курсов вистеха не помогут.
[23:09.040 --> 23:20.480]  Поэтому минимум операции не обратимая, это печально. Но у минимума есть одно замечательное свойство,
[23:20.520 --> 23:36.560]  у которого нету плюса. Ну хорошо, слово дня. Идемпотентность. Что это за свойство, кто знает?
[23:36.560 --> 23:46.560]  Отлично. Идемпотентность это свойство, что если вы применяете некоторую операцию к одному и тому же элементу два раза,
[23:46.640 --> 23:54.640]  то вы получите тот же самый элемент. Понятное дело, что минимум из х и икса это х. Для суммы, естественно, это неверно.
[23:54.640 --> 24:10.640]  То есть х плюс х в общем случае не равно 2х. Не равно х, да. Это я вас проверял. Согласны?
[24:10.720 --> 24:18.520]  Ну и давайте, собственно, зная вот эту разницу, будем строить некоторые специфичные структуры данных,
[24:18.520 --> 24:24.320]  которые будут позволять решать те или иные издачи. Ну в общем-то, специфичная операция,
[24:24.320 --> 24:29.920]  они как раз используют свойства либо обратимости, либо идемпотентности. То есть если вы можете построить
[24:29.920 --> 24:33.920]  какую-то эффективную структуру данных для суммы, то она вряд ли заработает для минимума.
[24:33.920 --> 24:40.920]  структуру данных для минимума, то она вряд ли будет эффективной для суммы.
[24:40.920 --> 24:49.920]  В качестве первого примера такой структуры данных решим простую задачу.
[24:49.920 --> 24:52.920]  Значит, какой пункт?
[24:52.920 --> 25:00.920]  Задача статик rsq.
[25:00.920 --> 25:03.920]  Просто я говорил выше. Задача звучит следующим образом.
[25:03.920 --> 25:07.920]  У меня есть некоторый массив, этот массив неизменяемый,
[25:07.920 --> 25:10.920]  и мне нужно отвечать на запросы, виды найти сумму на каком-то отрезке,
[25:10.920 --> 25:13.920]  найти сумму на другом отрезке, ну или на самом деле найти результат
[25:13.920 --> 25:16.920]  в выполнении произвольной операции, которая обладает свойствами обратимости.
[25:16.920 --> 25:23.920]  Ну а там обративности, коммутативности, ассоциативности.
[25:23.920 --> 25:26.920]  Ну, снова давайте кончимся.
[25:26.920 --> 25:35.920]  Думаем, 6, 0, 5, 4, 3, 2.
[25:35.920 --> 25:44.920]  Ну вот вам данная задача. Как будем решать?
[25:44.920 --> 25:46.920]  Да, да, все гениальное просто.
[25:46.920 --> 25:58.920]  Действительно, решение массив префиксных сумм.
[25:58.920 --> 26:04.920]  Ну то есть заведем массив P такой, что в элементе P i там будет хранится сумма,
[26:04.920 --> 26:15.920]  давайте ПК там, будет хранится сумма P i от 0 до k аитах.
[26:15.920 --> 26:19.920]  Просто будем хранить суммы на всевозможных префиксах.
[26:19.920 --> 26:23.920]  Ну то есть если это массив A, то из этого массива A мы сделаем массив P,
[26:23.920 --> 26:43.920]  который будет иметь вид 6, дальше 11, 15, 18, 20.
[26:43.920 --> 26:50.920]  Соответственно, при процессинге, естественно, работает за сколько?
[26:50.920 --> 26:53.920]  За линейное время.
[26:53.920 --> 26:57.920]  Все понимают, как посчитать массив префиксных сумм за линейное время.
[26:57.920 --> 27:02.920]  Ну мы просто идем, значит записываем элемент сюда, дальше сюда записываем элемент.
[27:02.920 --> 27:05.920]  Ну давайте формулу просто напишем.
[27:05.920 --> 27:12.920]  Ну отсюда нам просто следует, что это P i-1 плюс i.
[27:12.920 --> 27:15.920]  Ну естественно там крайний случай нуля надо рассмотреть,
[27:15.920 --> 27:21.920]  но не будем этим заморачивать голову.
[27:21.920 --> 27:24.920]  Ну и запрос.
[27:24.920 --> 27:30.920]  Мне нужно найти, скажем, значение суммы вот на таком отрезке.
[27:30.920 --> 27:34.920]  Со второго по четвертый.
[27:34.920 --> 27:39.920]  Что я должен сделать?
[27:40.920 --> 27:44.920]  То есть qi от lr выглядит следующим образом.
[27:44.920 --> 27:48.920]  Я обращаюсь к элементу под номером r.
[27:48.920 --> 27:51.920]  Ну давайте так распишем.
[27:51.920 --> 27:56.920]  Это будет сумма по i от l до r аитых.
[27:56.920 --> 28:01.920]  В свою очередь это равно сумма по i от 0 до r аитых,
[28:01.920 --> 28:09.920]  минус сумма по i от 0 до l-1 аитых.
[28:09.920 --> 28:14.920]  Но это в точности равно значению префиксной суммы в точке r
[28:14.920 --> 28:18.920]  и значению префиксной суммы в точке l-1.
[28:18.920 --> 28:24.920]  То есть P от r минус P от l-1.
[28:24.920 --> 28:29.920]  Ну и время запроса.
[28:30.920 --> 28:33.920]  Вот вам пример структура данных,
[28:33.920 --> 28:35.920]  которая решила ту же самую задачу,
[28:35.920 --> 28:37.920]  которую мы вроде поставили до этого.
[28:37.920 --> 28:40.920]  Но при этом мы воспользовались всего лишь свойством обратимости
[28:40.920 --> 28:42.920]  и смогли сильно улучшить наш алгоритм.
[28:42.920 --> 28:45.920]  При процессе за линейное время и сразу же отвечаем на вопросы.
[28:45.920 --> 28:49.920]  То есть сразу отвечаем на запросы за O от единицы.
[28:49.920 --> 28:54.920]  Вот. Такие дела.
[28:55.920 --> 28:58.920]  Что?
[28:58.920 --> 29:02.920]  Минус.
[29:02.920 --> 29:06.920]  Ну скажем, давайте заменим операцию суммы на операцию минимума.
[29:06.920 --> 29:10.920]  Как бы вы нашли значение минимум? Давайте мысленно.
[29:10.920 --> 29:14.920]  Можно записывать просто.
[29:14.920 --> 29:17.920]  Мысленно представим, что у нас такая вещь.
[29:17.920 --> 29:19.920]  То есть считаем минимум на префексе.
[29:19.920 --> 29:22.920]  То есть тут 6, тут 0 и дальше везде 0.
[29:22.920 --> 29:26.920]  Нужно найти минимум на отрезке от 2 до 4.
[29:26.920 --> 29:28.920]  Вот. Обращаясь к вот этим элементам,
[29:28.920 --> 29:31.920]  вы естественно никак не поймете, какой у вас там минимум.
[29:31.920 --> 29:33.920]  Потому что вы не можете вычесть.
[29:33.920 --> 29:35.920]  Ну короче, нет операции в вычитании,
[29:35.920 --> 29:38.920]  нет операции обратной минимуму.
[29:38.920 --> 29:43.920]  Так, ну еще пару слов про массив рефиксум.
[29:47.920 --> 29:50.920]  Ну смотрите, с обратимостью разобрались.
[29:50.920 --> 29:53.920]  Ассоциативность вроде тоже понятна.
[29:53.920 --> 29:57.920]  С ассоциативностью, думаю, тоже все понятно.
[29:57.920 --> 30:01.920]  Потому что если мы хотим посчитать значение здесь,
[30:01.920 --> 30:05.920]  то мы берем значение отсюда, вычитаем отсюда и так далее.
[30:05.920 --> 30:10.920]  А что коммутативность? Нужна ли тут коммутативность или нет?
[30:13.920 --> 30:17.920]  Скажем, можем ли мы использовать то же самое для некоммунативной операции?
[30:17.920 --> 30:21.920]  Например, у меня в ячейках массива хранятся матрицы.
[30:21.920 --> 30:24.920]  Я перемножаю так матрицы.
[30:24.920 --> 30:28.920]  И, собственно, здесь, когда я использую вычитание,
[30:28.920 --> 30:30.920]  умножаю на обратную матрицу.
[30:30.920 --> 30:32.920]  Скажем, если я хочу найти произведение матриц здесь,
[30:32.920 --> 30:34.920]  то я беру произведение матриц здесь
[30:34.920 --> 30:42.920]  и умножаю на обратную матрицу, полученную произведением элементов здесь.
[30:42.920 --> 30:51.920]  Что? Другой ответ получится. А какой?
[30:55.920 --> 30:58.920]  Нет, на самом деле все хорошо с коммутативностью.
[30:58.920 --> 31:01.920]  Единственный момент заключается в том,
[31:01.920 --> 31:06.920]  что то, как мы писали здесь, тут написано следующее.
[31:06.920 --> 31:13.920]  То есть мы берем a0, a1, a2, и так далее, ar.
[31:13.920 --> 31:24.920]  А потом берем следующую штуку, a0, и так далее, al, минус 1.
[31:24.920 --> 31:32.920]  Естественно, если операция некоммунативна, то это не работает.
[31:32.920 --> 31:34.920]  Согласны?
[31:36.920 --> 31:39.920]  Ну просто, потому что если я беру минус 1,
[31:39.920 --> 31:45.920]  то получается вот такая история, al-1, и так далее, a0-1.
[31:45.920 --> 31:48.920]  Естественно, al-1 и ar, они не сократятся.
[31:51.920 --> 31:53.920]  В общем, операция некоммунативна.
[31:53.920 --> 31:55.920]  Если у меня операция была коммунативна,
[31:55.920 --> 32:01.920]  то я мог просто al вынести к kL, al-1, kL-1, a0 к 0, и все бы сократилось.
[32:01.920 --> 32:02.920]  Здесь такого нет.
[32:02.920 --> 32:04.920]  Но операцию можно сделать коммунативно,
[32:04.920 --> 32:06.920]  то есть от этой штуки можно добиться того,
[32:06.920 --> 32:08.920]  чтобы она не требовала коммунативность,
[32:08.920 --> 32:11.920]  просто-напросто поменяв местами операнды.
[32:11.920 --> 32:15.920]  Скажем, если я возьму a0, и так далее, al-1,
[32:15.920 --> 32:20.920]  и потом только выполню a0, и так далее, ar,
[32:20.920 --> 32:26.920]  тут al, то тут все будет хорошо.
[32:26.920 --> 32:28.920]  Согласны?
[32:28.920 --> 32:31.920]  Я возьму вот эту штуку, свернусь вот этой штукой,
[32:31.920 --> 32:35.920]  и получается только произведение от al-1 до ar.
[32:35.920 --> 32:38.920]  Поэтому коммунативность тут тоже не нужна.
[32:38.920 --> 32:40.920]  Единственное требование на операцию,
[32:40.920 --> 32:45.920]  которую можно с помощью такой префиксной суммы обрабатывать,
[32:45.920 --> 32:47.920]  это ассоциативность и обратимость.
[32:51.920 --> 32:53.920]  Идем дальше.
[32:54.920 --> 33:04.920]  Следующий на очереди у нас задача статика РМК.
[33:11.920 --> 33:13.920]  Как будем решать?
[33:13.920 --> 33:18.920]  С помощью такой структуры решить задачу с минимумом не получится.
[33:18.920 --> 33:21.920]  Нельзя сказать, что если я посчитаю минимум на префексе,
[33:21.920 --> 33:23.920]  посчитаю минимум на маленьком префексе,
[33:23.920 --> 33:25.920]  то я смогу понять минимум на разности.
[33:25.920 --> 33:27.920]  То есть такого, естественно, сделать нельзя.
[33:30.920 --> 33:32.920]  Давайте попробуем что-нибудь придумать.
[33:36.920 --> 33:38.920]  Придумаем что-нибудь вот в таком виде.
[33:38.920 --> 33:44.920]  Значит, первый пункт, метод грубой силы,
[33:44.920 --> 33:47.920]  ну или просто некоторый наивный подход.
[33:47.920 --> 33:49.920]  Давайте сейчас рассмотрим некоторый наивный подход,
[33:49.920 --> 33:51.920]  то есть тупой, банальный, который работает долго,
[33:51.920 --> 33:55.920]  но впоследствии мы его очень сильно улучшим.
[33:55.920 --> 33:58.920]  Давайте сделаем довольно странную вещь.
[33:58.920 --> 34:01.920]  Давайте посчитаем минимумы на всевозможных отрезках.
[34:01.920 --> 34:04.920]  Вопрос возьмем и на всевозможных отрезках посчитаем.
[34:19.920 --> 34:34.920]  Ну, то есть заведем массив s, двумерный, давайте t лучше, t и s.
[34:34.920 --> 34:48.920]  Это минимум на отрезке i, i плюс s минус 1.
[34:49.920 --> 34:53.920]  Ну, то есть это минимум на отрезке, начинающейся в позиции i,
[34:53.920 --> 34:55.920]  и имеющий размер s.
[34:59.920 --> 35:04.920]  Ну, естественно, при процессинг такой штуки работает за n квадрат.
[35:07.920 --> 35:10.920]  Ну, чтобы заполнить эту табличку, вам потребуется времени n квадрат.
[35:10.920 --> 35:16.920]  Но за то время запроса у вас будет вот единица.
[35:16.920 --> 35:18.920]  Красота?
[35:19.920 --> 35:21.920]  Нравится?
[35:22.920 --> 35:24.920]  Мне тоже нравится.
[35:28.920 --> 35:30.920]  Давайте попробуем как-то вот эту штуку улучшить.
[35:30.920 --> 35:32.920]  В общем, этот метод понятен.
[35:32.920 --> 35:34.920]  Он плохой, но он работает.
[35:34.920 --> 35:36.920]  Давайте попробуем как-нибудь улучшить.
[35:36.920 --> 35:40.920]  В общем, я предлагаю улучшать следующую сторону.
[35:41.920 --> 35:45.920]  Я утверждаю, что хранить минимум на каждом подотреске довольно дорого.
[35:45.920 --> 35:48.920]  Хранить минимум, точнее, на подотреске всех длин.
[35:48.920 --> 35:51.920]  На подотреске длины 1, 2, 3, 4, 5.
[35:51.920 --> 35:54.920]  В общем, это слишком много, и это на самом деле избыточно.
[35:54.920 --> 35:58.920]  Я утверждаю, что можно обойтись меньшим количеством отрезков.
[36:09.920 --> 36:11.920]  Какие отрезки нам достаточно?
[36:12.920 --> 36:14.920]  Ну, смотрите.
[36:15.920 --> 36:21.920]  Вот пусть мне нужно посчитать минимум на отрезке длины s.
[36:22.920 --> 36:24.920]  Минимум на отрезке длины s.
[36:25.920 --> 36:27.920]  В том подходе предлагается следующее.
[36:27.920 --> 36:30.920]  Ну, так как я храню минимум на всех подотресках,
[36:30.920 --> 36:32.920]  на подотресках всех длин,
[36:32.920 --> 36:35.920]  то я соответственно значение здесь могу посчитать за единицу.
[36:36.920 --> 36:38.920]  А вот давайте представим себе следующую ситуацию.
[36:38.920 --> 36:43.920]  Допустим, я не знаю минимума на отрезке длины s.
[36:43.920 --> 36:45.920]  Конкретно на этом отрезке я ничего не знаю.
[36:46.920 --> 36:51.920]  Могу ли я по-прежнему как-то за о от единицы посчитать значение минимуму здесь?
[36:51.920 --> 36:54.920]  Если я знаю, скажем, значение минимума на подотресках меньше длины.
[36:57.920 --> 36:58.920]  Например.
[37:00.920 --> 37:01.920]  Из-за идемпатентности, да.
[37:01.920 --> 37:02.920]  Значит, смотрите.
[37:02.920 --> 37:07.920]  Если я знаю значение на подотреске s меньше, чем s,
[37:08.920 --> 37:10.920]  то что я могу сделать?
[37:11.920 --> 37:16.920]  Я могу развить мой отрезок на вот такой отрезок длины s.
[37:17.920 --> 37:19.920]  И вот на такой отрезок длины s.
[37:20.920 --> 37:24.920]  Посчитать минимум, то есть найти минимум здесь, найти минимум здесь.
[37:24.920 --> 37:26.920]  И дальше я могу взять минимум от этих двух штук.
[37:27.920 --> 37:29.920]  И так как у меня выполняются свойства идемпатентности,
[37:30.920 --> 37:32.920]  идемпатентности,
[37:33.920 --> 37:34.920]  то все будет хорошо.
[37:35.920 --> 37:38.920]  Согласны? То есть то, что я два раза учту вот этот вот отрезок,
[37:38.920 --> 37:39.920]  меня в принципе не волнует.
[37:39.920 --> 37:40.920]  Он просто-напросто схлопнется.
[37:41.920 --> 37:42.920]  Для суммы это, естественно, не работает.
[37:43.920 --> 37:44.920]  Потому что если я посчитаю сумму здесь,
[37:44.920 --> 37:45.920]  потом посчитаю сумму здесь,
[37:45.920 --> 37:47.920]  то неверно, что сумма на всем отрезке это сумма вот этих штук.
[37:47.920 --> 37:49.920]  А вот для минимума, максимума,
[37:49.920 --> 37:50.920]  что там еще?
[37:51.920 --> 37:52.920]  Наименьший общий делитель,
[37:53.920 --> 37:54.920]  наибольший общий делитель,
[37:54.920 --> 37:55.920]  наименьший общий крат,
[37:55.920 --> 37:56.920]  на это все верно.
[38:00.920 --> 38:01.920]  Ну и, собственно,
[38:02.920 --> 38:03.920]  заключительный вопрос.
[38:04.920 --> 38:05.920]  А для каких s-трих мне тогда,
[38:05.920 --> 38:07.920]  вот какие s-трих мне нужно посчитать,
[38:08.920 --> 38:09.920]  чтобы это всегда можно было сделать?
[38:18.920 --> 38:19.920]  Здесь следующее.
[38:19.920 --> 38:20.920]  Давайте в качестве s-трих
[38:21.920 --> 38:22.920]  будем брать
[38:23.920 --> 38:24.920]  отрезки,
[38:25.920 --> 38:26.920]  длина которых
[38:27.920 --> 38:28.920]  является степенью двойки.
[38:29.920 --> 38:31.920]  То есть не будем считать минимум на всевозможных отрезках.
[38:31.920 --> 38:32.920]  Один, два, три, четыре и так далее.
[38:33.920 --> 38:35.920]  А будем считать минимум на подотресках длины один,
[38:35.920 --> 38:37.920]  длины два, длины четыре, длины восемь и так далее.
[38:37.920 --> 38:39.920]  И вот тогда я утверждаю, что вы любой отрезок
[38:40.920 --> 38:41.920]  таким образом покроете.
[38:42.920 --> 38:43.920]  Понятно как?
[38:44.920 --> 38:46.920]  Ну вы просто возьмете ближайшую степень двойки снизу,
[38:46.920 --> 38:48.920]  и она, естественно, покроет
[38:48.920 --> 38:49.920]  два раза ваш отрезок.
[38:51.920 --> 38:52.920]  Вот идея.
[38:52.920 --> 38:54.920]  И, собственно, идея к структуре данных,
[38:54.920 --> 38:55.920]  которая реализует эту идею, называется
[38:56.920 --> 38:57.920]  sparse table
[38:58.920 --> 38:59.920]  или разреженная таблица.
[39:03.920 --> 39:04.920]  Разреженная
[39:09.920 --> 39:10.920]  таблица.
[39:12.920 --> 39:13.920]  То есть будем строить
[39:14.920 --> 39:16.920]  двумерный массив вот такого вида.
[39:19.920 --> 39:20.920]  Это будет равно
[39:21.920 --> 39:23.920]  минимуму на отрезке
[39:25.920 --> 39:26.920]  от i
[39:27.920 --> 39:28.920]  до i плюс
[39:29.920 --> 39:30.920]  два степеника минус один.
[39:33.920 --> 39:34.920]  То есть это минимум на отрезке,
[39:35.920 --> 39:36.920]  который начинается в позиции i
[39:37.920 --> 39:38.920]  и имеет длину два степеника.
[39:40.920 --> 39:41.920]  Окей?
[39:44.920 --> 39:45.920]  Давайте начнем с запроса.
[39:46.920 --> 39:48.920]  Пока забьем на то, как это можно построить,
[39:49.920 --> 39:50.920]  давайте убедимся, что
[39:55.920 --> 39:57.920]  давайте убедимся, что запрос
[39:58.920 --> 39:59.920]  действительно можно выполнить за от единицы.
[39:59.920 --> 40:01.920]  Вот смотрите, допустим, вам известно,
[40:01.920 --> 40:02.920]  вам известно следующее.
[40:03.920 --> 40:04.920]  Вам известно вот такая штука.
[40:06.920 --> 40:08.920]  То есть вам известны минимумы на всех подотресках,
[40:09.920 --> 40:10.920]  длина которых является степенью двойки.
[40:11.920 --> 40:13.920]  И вам приходит запрос найти минимум на отрезке от l до r.
[40:14.920 --> 40:15.920]  Вот от l до r.
[40:17.920 --> 40:18.920]  Как обработать этот запрос,
[40:18.920 --> 40:19.920]  имея на руках вот эту таблицу?
[40:26.920 --> 40:27.920]  Что нужно взять в качестве k?
[40:31.920 --> 40:32.920]  Логарифм двоичный, да, то есть
[40:34.920 --> 40:35.920]  в качестве k берем
[40:36.920 --> 40:38.920]  логарифм двоичный от r-l
[40:39.920 --> 40:41.920]  плюс один, ну скажем, округляем вниз.
[40:44.920 --> 40:45.920]  Вот.
[40:46.920 --> 40:47.920]  И дальше что?
[40:48.920 --> 40:49.920]  Что возвращаем?
[40:49.920 --> 40:50.920]  Ага.
[40:59.920 --> 41:04.920]  Минимум из t, l и k.
[41:05.920 --> 41:07.920]  То есть берем минимум вот на этом отрезке.
[41:08.920 --> 41:09.920]  Да?
[41:09.920 --> 41:10.920]  То есть что такое t, l, k?
[41:10.920 --> 41:11.920]  t, l, k это минимум на отрезке,
[41:12.920 --> 41:13.920]  который начинается в позиции l
[41:14.920 --> 41:15.920]  и имеет длину 2 в степени k.
[41:16.920 --> 41:17.920]  Ну то есть вот на таком отрезке.
[41:17.920 --> 41:18.920]  И теперь нужно взять вот этот отрезок.
[41:20.920 --> 41:21.920]  А он какой размер имеет?
[41:21.920 --> 41:22.920]  Точнее, какой вид?
[41:26.920 --> 41:28.920]  Да, t от r-2 в степени k
[41:30.920 --> 41:31.920]  от k.
[41:32.920 --> 41:33.920]  Ну вот.
[41:41.920 --> 41:42.920]  Согласны?
[41:42.920 --> 41:43.920]  Вот.
[41:47.920 --> 41:49.920]  Ну естественно, то есть вот это обращение
[41:50.920 --> 41:51.920]  за 1, вот это обращение за 1,
[41:52.920 --> 41:53.920]  соответственно, весь запрос
[41:54.920 --> 41:56.920]  вас обрабатывает за 1.
[41:57.920 --> 41:58.920]  То есть вы берете произвольное отрезок
[41:59.920 --> 42:00.920]  и разбиваете его на два подотреска,
[42:01.920 --> 42:02.920]  которые имеют,
[42:03.920 --> 42:04.920]  ну два на два подотреска,
[42:05.920 --> 42:06.920]  длина которых имеет,
[42:07.920 --> 42:08.920]  которая является степенью двойки.
[42:09.920 --> 42:10.920]  Тут есть тонкий момент,
[42:10.920 --> 42:11.920]  который появляется вот здесь.
[42:12.920 --> 42:13.920]  То есть как посчитать логарифм двоичный,
[42:14.920 --> 42:15.920]  то есть как найти ближайшую
[42:16.920 --> 42:17.920]  минимальную степень двойки.
[42:18.920 --> 42:19.920]  Но это абсолютно на семинарах.
[42:20.920 --> 42:21.920]  В общем-то, есть более-менее два подхода.
[42:22.920 --> 42:23.920]  То есть первое, это вы предварительно
[42:24.920 --> 42:25.920]  считаете всевозможные логарифмы,
[42:26.920 --> 42:27.920]  то есть там для единиц, для двойки, для тройки,
[42:28.920 --> 42:29.920]  то есть для всех предпочитываете k.
[42:30.920 --> 42:31.920]  А есть другой подход,
[42:32.920 --> 42:33.920]  используете встроенную функцию.
[42:36.920 --> 42:37.920]  Ну, она не встроена в язык,
[42:38.920 --> 42:39.920]  но является некоторым расширением
[42:40.920 --> 42:41.920]  для GCC и других,
[42:42.920 --> 42:43.920]  Billkin CLZ,
[42:44.920 --> 42:45.920]  которая просто считает количество ведущих нулей
[42:46.920 --> 42:47.920]  в числе.
[42:48.920 --> 42:49.920]  Таким образом, вы можете эффективно
[42:50.920 --> 42:51.920]  высчитывать логарифм от числа,
[42:52.920 --> 42:53.920]  ну для целого числа.
[42:54.920 --> 42:56.920]  В общем, поговорите семинаристами,
[42:57.920 --> 42:58.920]  какой способ они вам предложат,
[42:59.920 --> 43:00.920]  таким и пользуйтесь.
[43:01.920 --> 43:02.920]  Но это уже такая техническая деталь,
[43:03.920 --> 43:04.920]  мы туда не лезем.
[43:05.920 --> 43:07.920]  Так, давайте сюда.
[43:11.920 --> 43:12.920]  Значит, что нам остается?
[43:13.920 --> 43:14.920]  Нам остается,
[43:18.920 --> 43:20.920]  да я думаю, пример нам привести надо,
[43:21.920 --> 43:23.920]  ну что, было понимание?
[43:26.920 --> 43:27.920]  Примерно.
[43:28.920 --> 43:29.920]  Давайте возьмем какой-нибудь массив снова.
[43:29.920 --> 43:39.920]  5, 0, 4, 3, 6, 1,
[43:40.920 --> 43:41.920]  5, 0, 4, 3, 6, 1,
[43:42.920 --> 43:43.920]  ну и еще какой-нибудь,
[43:44.920 --> 43:45.920]  ну пусть 7.
[43:48.920 --> 43:49.920]  Вот, как будет выглядеть наша таблица?
[43:50.920 --> 43:52.920]  Значит, наша таблица будет выглядеть так.
[43:53.920 --> 43:54.920]  Ну, здесь мы будем писать,
[43:55.920 --> 43:56.920]  k равна 0, k равна 1, k равна 2.
[43:56.920 --> 43:57.920]  Этого нам будет достаточно.
[43:58.920 --> 43:59.920]  Ну и здесь, соответственно,
[44:00.920 --> 44:05.920]  0, 1, 2, 3, 4, 5, 6.
[44:12.920 --> 44:14.920]  Вот, значит, в нулевой строке,
[44:15.920 --> 44:16.920]  в нулевой строке нашей таблицы,
[44:17.920 --> 44:18.920]  что будет храниться?
[44:19.920 --> 44:20.920]  2 в степени 0 это 1,
[44:21.920 --> 44:22.920]  ну то есть мы будем хранить там минимумы
[44:23.920 --> 44:24.920]  на всех подотресках длины 1.
[44:24.920 --> 44:25.920]  То есть просто исходный массив, да.
[44:26.920 --> 44:32.920]  То есть просто 5, 0, 4, 3, 6, 1, 7.
[44:34.920 --> 44:35.920]  То есть ну минимум на отрезках длины 1,
[44:36.920 --> 44:37.920]  это просто самый исходный массив.
[44:38.920 --> 44:40.920]  Теперь, как посчитать значение здесь?
[44:41.920 --> 44:43.920]  Ну, давайте параллельно думать о том,
[44:44.920 --> 44:45.920]  во-первых, что сюда нужно поставить,
[44:46.920 --> 44:47.920]  во-вторых, как это посчитать?
[44:48.920 --> 44:49.920]  Давайте сначала ответим на первый вопрос.
[44:50.920 --> 44:51.920]  Что тут должно стоять?
[44:52.920 --> 44:53.920]  Тут должно стоять минимум на подотреске,
[44:54.920 --> 44:55.920]  в нуле,
[45:00.920 --> 45:02.920]  и имеет длину 2 в степени 1, то есть 2.
[45:03.920 --> 45:04.920]  То есть здесь хранится 0.
[45:07.920 --> 45:08.920]  Далее. Здесь.
[45:09.920 --> 45:10.920]  Значит, у нас отрезок начинается в единице,
[45:11.920 --> 45:12.920]  имеет длину 2, поэтому должен 0.
[45:13.920 --> 45:14.920]  Переходим дальше. Здесь 3.
[45:15.920 --> 45:16.920]  Здесь 3.
[45:17.920 --> 45:18.920]  Здесь 1.
[45:19.920 --> 45:20.920]  Здесь 1.
[45:21.920 --> 45:22.920]  Все, дальше мы выходим за границы,
[45:22.920 --> 45:23.920]  но тут мы ничего не считаем.
[45:25.920 --> 45:26.920]  Так, ну и дальше х равное 2,
[45:27.920 --> 45:28.920]  то есть на подотресках длины 4.
[45:29.920 --> 45:31.920]  Значит, берем подотрезок, который начинается в нуле,
[45:32.920 --> 45:33.920]  и длины 4. Тут 0.
[45:34.920 --> 45:36.920]  Дальше сдвигаемся вправо, тут тоже 0.
[45:37.920 --> 45:38.920]  Сдвигаемся вправо, тут единица.
[45:39.920 --> 45:40.920]  Сдвигаемся вправо, тут тоже единица.
[45:41.920 --> 45:42.920]  Здесь ничего не ставим.
[45:43.920 --> 45:44.920]  Ну вот, получилась такая таблица.
[45:49.920 --> 45:50.920]  Вопрос, как ее построить?
[45:50.920 --> 45:51.920]  Вопросов нет, да?
[45:52.920 --> 45:53.920]  Все понятно.
[45:54.920 --> 45:55.920]  Что мы тут сделали и так далее.
[45:56.920 --> 45:57.920]  Окей, ну построение такое.
[45:59.920 --> 46:00.920]  Что у нас тут? Какой индекс?
[46:03.920 --> 46:08.920]  t и 0 равно просто a и t для любого i.
[46:09.920 --> 46:10.920]  Это обсудили.
[46:11.920 --> 46:12.920]  То есть, первое, что мы делаем,
[46:13.920 --> 46:14.920]  что мы делаем,
[46:15.920 --> 46:16.920]  что мы делаем,
[46:17.920 --> 46:18.920]  для любого i.
[46:19.920 --> 46:20.920]  Это обсудили.
[46:21.920 --> 46:22.920]  То есть, первая строка таблицы,
[46:23.920 --> 46:24.920]  это всегда просто-напросто исходный массив.
[46:25.920 --> 46:26.920]  Вот он.
[46:27.920 --> 46:28.920]  Идем дальше.
[46:31.920 --> 46:32.920]  Как мне построить следующие уровни?
[46:35.920 --> 46:44.920]  4k, in, 1 и так далее, ugn.
[46:44.920 --> 46:46.920]  Так, давайте в другое место перейдем.
[47:08.920 --> 47:13.920]  4k, in, 1 и так далее, log n.
[47:15.920 --> 47:18.920]  4i, in, 0 и так далее.
[47:19.920 --> 47:20.920]  До какого?
[47:23.920 --> 47:24.920]  До какого?
[47:25.920 --> 47:26.920]  До n-2 в степени k.
[47:29.920 --> 47:30.920]  Да?
[47:31.920 --> 47:32.920]  Ну, чтобы не выходить за границу,
[47:33.920 --> 47:34.920]  чтобы не читать минимум там, где нам не надо.
[47:35.920 --> 47:36.920]  Мы делаем следующую вещь.
[47:38.920 --> 47:43.920]  t от i k равно чему?
[47:44.920 --> 47:47.920]  Ну вот, мне нужно посчитать значения в ячейке t и k.
[47:48.920 --> 47:50.920]  То есть, мне, грубо говоря, нужно идти минимум на отрезке от i,
[47:51.920 --> 47:55.920]  до i плюс 2 в степени k минус 1.
[48:03.920 --> 48:05.920]  Ну, смотрите, если я иду циклом по k,
[48:06.920 --> 48:09.920]  то я считаю значения в точке k,
[48:10.920 --> 48:12.920]  то я точно знаю, что у меня уже посчитаны все значения
[48:12.920 --> 48:14.920]  для k минус 1, k минус 2 и так далее.
[48:15.920 --> 48:17.920]  То есть, я могу просто свести задачу к меньшим.
[48:18.920 --> 48:19.920]  То есть, как я здесь могу свести?
[48:20.920 --> 48:23.920]  Я могу свести к поиску минимума на отрезке от i,
[48:24.920 --> 48:26.920]  до i плюс 2 в степени k минус 1 минус 1.
[48:28.920 --> 48:30.920]  И i плюс 2 в степени k минус 1.
[48:31.920 --> 48:35.920]  И плюс 2 в степени k минус 1.
[48:38.920 --> 48:39.920]  Согласны?
[48:40.920 --> 48:41.920]  А это что такое?
[48:42.920 --> 48:44.920]  Это отрезок, который начинается в позиции i,
[48:45.920 --> 48:46.920]  имеет длину 2 в степени k минус 1.
[48:47.920 --> 48:49.920]  Где у меня хранится этот результат?
[48:50.920 --> 48:55.920]  до t i k минус 1.
[48:56.920 --> 48:58.920]  Ну, естественно, от всего этого я беру минимум.
[49:00.920 --> 49:01.920]  А вот это что за отрезок?
[49:02.920 --> 49:05.920]  Смотрите, он имеет длину 2 в степени k минус 1 и начинается здесь.
[49:05.920 --> 49:10.920]  То есть, я беру значение в точке i плюс 2 в степени k минус 1,
[49:13.920 --> 49:14.920]  k минус 1.
[49:15.920 --> 49:16.920]  Все.
[49:22.920 --> 49:25.920]  То есть, вот таким вот рекуррентным способом я посчитал все значения матрицы t i k
[49:26.920 --> 49:27.920]  на основании уже посчитанных значений.
[49:28.920 --> 49:31.920]  То есть, заметьте, что к моменту, когда я считаю значение для
[49:31.920 --> 49:34.920]  индекса k, у меня все значения для k минус 1 уже посчитаны.
[49:35.920 --> 49:36.920]  Да, поэтому я спокойно могу ими пользоваться.
[49:37.920 --> 49:38.920]  Вот.
[49:40.920 --> 49:42.920]  Вот, собственно, весь код построения.
[49:43.920 --> 49:44.920]  Это build.
[49:48.920 --> 49:49.920]  И за сколько это работает?
[49:50.920 --> 49:52.920]  t при процессинге от n.
[49:53.920 --> 49:54.920]  За сколько отработает этот цикл?
[49:56.920 --> 49:58.920]  Ну, за сколько отработает этот цикл?
[49:58.920 --> 50:01.920]  Ну, этот цикл, естественно, работает за длину моей sparse таблицы.
[50:02.920 --> 50:04.920]  Можем ли мы как-то ограничить ее размер сверху?
[50:07.920 --> 50:08.920]  Ну, сколько у меня столбцов?
[50:09.920 --> 50:10.920]  Ну, вот здесь.
[50:11.920 --> 50:12.920]  Да, за n лог n.
[50:13.920 --> 50:14.920]  Вот и ответ.
[50:15.920 --> 50:16.920]  За n лог n.
[50:17.920 --> 50:20.920]  Ну, тут тоже легко понять, иначе у меня внешний цикл работает за алгоритм,
[50:21.920 --> 50:23.920]  внутренний цикл работает максимум за n.
[50:24.920 --> 50:25.920]  Поэтому n лог n.
[50:25.920 --> 50:28.920]  Ну, понятное дело, что у меня тут постепенно размеры внутреннего цикла уменьшаются,
[50:29.920 --> 50:31.920]  но если просуммировать, то есть если честно все просуммировать,
[50:32.920 --> 50:34.920]  то лучше, чем n лог n, то очень не получится.
[50:35.920 --> 50:36.920]  В общем.
[50:37.920 --> 50:38.920]  А симпатика здесь n лог n.
[50:39.920 --> 50:40.920]  Все, значит, итог.
[50:41.920 --> 50:42.920]  Какой у нас итог?
[50:44.920 --> 50:45.920]  Итог.
[50:46.920 --> 50:48.920]  Мы построили sparse table, разреженную таблицу,
[50:48.920 --> 50:49.920]  у которой при процессинг занимает n лог n,
[50:50.920 --> 50:53.920]  и на запрос он отвечает за вот единицы.
[50:56.920 --> 50:57.920]  Достойно, да?
[51:01.920 --> 51:04.920]  То есть с помощью такого нехитрого трюка мы начинали там с чего?
[51:05.920 --> 51:07.920]  Мы начинали с того, что мы строим там квадратичную какую-то таблицу,
[51:08.920 --> 51:10.920]  и в итоге спустились до таблицы, которая строится за n лог n.
[51:11.920 --> 51:12.920]  У вас может возникнуть вопрос.
[51:13.920 --> 51:14.920]  Можно ли лог n лог n?
[51:14.920 --> 51:15.920]  Ответ можно.
[51:16.920 --> 51:17.920]  Но вы еще маленькие.
[51:18.920 --> 51:19.920]  Я вам этого не расскажу.
[51:20.920 --> 51:21.920]  Вот, возрастейте через лекции 2.
[51:22.920 --> 51:23.920]  Может быть, поговорим.
[51:26.920 --> 51:27.920]  Что?
[51:28.920 --> 51:30.920]  Деревоотресков решать другую задачу.
[51:31.920 --> 51:32.920]  И у него симпатика чуть похуже.
[51:34.920 --> 51:38.920]  Давайте, раз время есть, давайте поговорим просто про некоторые улучшения.
[51:38.920 --> 51:39.920]  Которые мы уже сейчас можем сделать.
[51:40.920 --> 51:42.920]  В общем, ну к чему мы в итоге стремимся?
[51:43.920 --> 51:45.920]  Мы в итоге на самом деле хотим, чтобы тут стояла n.
[51:46.920 --> 51:47.920]  То есть n лог n на самом деле очень неплохо.
[51:48.920 --> 51:49.920]  Н лог n на самом деле здорово.
[51:50.920 --> 51:52.920]  Н лог n на практике практически ничем не отличается от линий.
[51:53.920 --> 51:55.920]  А симпатически, естественно, хочется чего-то лучшего.
[51:56.920 --> 51:58.920]  Тем более, что у нас была там структура данных, префиксные суммы,
[51:59.920 --> 52:01.920]  которые умели все делать, делать все то же самое для суммы,
[52:02.920 --> 52:03.920]  ну там, за линией.
[52:04.920 --> 52:06.920]  То есть, в общем, мы хотим, чтобы у нас была структура данных,
[52:06.920 --> 52:07.920]  чтобы у нас было все то же самое для суммы,
[52:08.920 --> 52:10.920]  ну там, за линейный препроцессинг и за от единицы.
[52:11.920 --> 52:13.920]  Значит, как я уже сказал, для SPARS таблицы это тоже возможно.
[52:14.920 --> 52:15.920]  Но об этом поговорим как-нибудь потом.
[52:16.920 --> 52:19.920]  Сейчас давайте обсудим просто некоторые способы оптимизации,
[52:20.920 --> 52:29.920]  которые можно здесь применить и получить нечто лучшее.
[52:30.920 --> 52:33.920]  Нелинейное, но с лучшими асимптотиками.
[52:36.920 --> 52:42.920]  А давайте вернемся к SQLT декомпозиции, внезапно.
[52:43.920 --> 52:45.920]  Давайте попробуем применить тот же самый метод,
[52:46.920 --> 52:48.920]  только к вот этой схеме.
[52:49.920 --> 53:04.920]  Давайте назовем улучшение SPARS табел.
[53:04.920 --> 53:05.920]  Что мы сделаем?
[53:06.920 --> 53:09.920]  Давайте, как и в случае SQLT декомпозиции,
[53:10.920 --> 53:15.920]  разобьем наш массив под массивы размера b.
[53:16.920 --> 53:17.920]  b мы подберем тоже снова позже,
[53:18.920 --> 53:21.920]  потому что здесь не факт, что будет тот же самый корень.
[53:22.920 --> 53:25.920]  Тут b, тут b, тут b, тут b.
[53:26.920 --> 53:32.920]  И снова посчитаем минимумы.
[53:34.920 --> 53:36.920]  Ну, минимумы, максимумы, то есть любую операцию,
[53:37.920 --> 53:38.920]  которую вы хотите.
[53:43.920 --> 53:48.920]  Считаем минимумы.
[53:53.920 --> 54:01.920]  И давайте сделаем следующую штуку.
[54:01.920 --> 54:03.920]  Давайте вот я на вот таком массиве,
[54:04.920 --> 54:05.920]  то есть этот массив имеет размер n,
[54:06.920 --> 54:07.920]  этот массив имеет размер n деленное на b,
[54:08.920 --> 54:12.920]  вот давайте я на этом массиве построю SPARS таблицу.
[54:13.920 --> 54:16.920]  То есть раньше я строил SPARS таблицу на всем массиве,
[54:17.920 --> 54:21.920]  а теперь я построю SPARS таблицу на массиве меньшей длины.
[54:31.920 --> 54:46.920]  Построим SPARS таблицу на массиве меньшей длины.
[54:49.920 --> 54:51.920]  Чему тогда будет равно время при процессинге?
[54:51.920 --> 55:02.920]  Вы видите, у меня b пока произвольная, пока нет корня.
[55:03.920 --> 55:10.920]  Да, nb на лук n деленное на b.
[55:11.920 --> 55:14.920]  Вот такая симптотипа.
[55:15.920 --> 55:17.920]  А время запроса?
[55:25.920 --> 55:27.920]  Чему будет равно время запроса?
[55:31.920 --> 55:32.920]  Ну как у меня выглядит запрос?
[55:33.920 --> 55:35.920]  Допустим, мне нужно посчитать минимум вот на таком отрезке.
[55:38.920 --> 55:39.920]  Да, то есть здесь я посчитаю за единицу.
[55:40.920 --> 55:42.920]  То есть снова все те отрезки, которые у меня попали в середину,
[55:42.920 --> 55:45.920]  я их все предпочитаю за единицу.
[55:46.920 --> 55:48.920]  Ну а здесь по-прежнему я не знаю, что сделаю.
[55:49.920 --> 55:50.920]  Давайте честно посчитаю.
[55:55.920 --> 55:56.920]  Снова посчитаю честно.
[55:57.920 --> 55:58.920]  Что у меня в итоге будет?
[55:59.920 --> 56:06.920]  У меня в итоге будет у от единицы плюс, возможно, плюс b.
[56:13.920 --> 56:15.920]  Ну и давайте попробуем подобрать какую-нибудь b.
[56:16.920 --> 56:20.920]  Что будет, если я возьму в качестве b, в качестве b логарифм?
[56:25.920 --> 56:32.920]  Если я возьму в качестве b логарифм, то tp от n у меня будет равно чему?
[56:33.920 --> 56:36.920]  Значит, тут будет n деленное на логарифм, тут тоже будет n деленное на логарифм,
[56:37.920 --> 56:39.920]  но на логарифм можно тут забить, поэтому тут получится n деленное на логарифм,
[56:39.920 --> 56:41.920]  умноженное на логарифм n, умноженное на логарифм n.
[56:42.920 --> 56:45.920]  То есть логарифм, знаменатель логарифм 4 здесь сократятся, получится просто o от n.
[56:53.920 --> 56:54.920]  Ну а запрос будет за логарифм.
[56:57.920 --> 57:00.920]  То есть с помощью такого же трюка, как и мы делали в случае эскорты декомпозиции,
[57:01.920 --> 57:08.920]  я могу улучшить время построения с n лог n до n, но при этом чуть ухудшил время запроса.
[57:10.920 --> 57:11.920]  Вот.
[57:19.920 --> 57:21.920]  Хорошо, давайте попробуем что-нибудь сделать еще.
[57:24.920 --> 57:25.920]  Можно ли тут еще как-то улучшить?
[57:39.920 --> 57:40.920]  Вот здесь стоит логарифм.
[57:41.920 --> 57:42.920]  Можно ли мы как-то здесь избавиться от логарифма?
[57:43.920 --> 57:44.920]  Ну, например, давайте сделаем так.
[57:45.920 --> 57:50.920]  Давайте построим SPARS таблицу не только здесь, но и на каждом внутреннем подотреске.
[57:52.920 --> 57:53.920]  Окей?
[57:54.920 --> 57:55.920]  Давайте попробуем.
[58:10.920 --> 58:24.920]  SPARS таблицей на каждом подотреске B.
[58:27.920 --> 58:28.920]  Что у нас получится?
[58:28.920 --> 58:38.920]  Время построения по-прежнему будет n деленное на B, логарифм n деленное на B,
[58:39.920 --> 58:43.920]  плюс я строю теперь SPARS таблицы на каждом из этих маленьких подотресках.
[58:44.920 --> 58:45.920]  Да?
[58:46.920 --> 58:47.920]  Сколько времени это работает?
[58:49.920 --> 58:56.920]  Это будет работать n деленное на B умножить на время построения SPARS таблицы здесь.
[58:56.920 --> 58:58.920]  То есть это B, лог B.
[58:59.920 --> 59:00.920]  Согласны?
[59:01.920 --> 59:02.920]  Никто еще не потерялся?
[59:03.920 --> 59:04.920]  Понятно, что мы делаем.
[59:05.920 --> 59:07.920]  То есть SPARS таблицу мы уже построили, мы сейчас просто издеваемся над ней,
[59:08.920 --> 59:10.920]  пытаемся какие-то копейки выжить из нее, пока у нас есть время.
[59:11.920 --> 59:12.920]  Вот.
[59:13.920 --> 59:15.920]  Хорошо, значит, это n лог B.
[59:16.920 --> 59:20.920]  Это относится к маленькому массиву.
[59:20.920 --> 59:21.920]  Вот к маленькому массиву.
[59:23.920 --> 59:29.920]  А вот эти B лог B, они относятся к вот этим массивчикам.
[59:36.920 --> 59:37.920]  Так.
[59:39.920 --> 59:41.920]  Ну, если все это причисать, то что у нас получится?
[59:42.920 --> 59:46.920]  У нас получится n деленное на B, лог n деленное на B,
[59:47.920 --> 59:49.920]  плюс вот эти B сократятся, получится просто n лог B.
[59:50.920 --> 59:53.920]  N лог B.
[59:54.920 --> 59:55.920]  Вот.
[59:56.920 --> 01:00:00.920]  Но время запроса внезапно станет раундом от единицы.
[01:00:01.920 --> 01:00:02.920]  Почему?
[01:00:03.920 --> 01:00:05.920]  Потому что любой запрос на отрезки, у нас сводится к чему?
[01:00:06.920 --> 01:00:08.920]  У нас сводится к запросу на маленькой SPARS таблице вот этой,
[01:00:09.920 --> 01:00:11.920]  и к двум запросам на SPARS таблицу здесь, и SPARS таблицу здесь.
[01:00:13.920 --> 01:00:17.920]  SPARS таблица делает запрос за единицу, поэтому мы улучшили запрос до единицы.
[01:00:20.920 --> 01:00:21.920]  Улучшили запрос до единицы.
[01:00:22.920 --> 01:00:27.920]  Но это при условии, что у нас в качестве B выступает логарифм n.
[01:00:28.920 --> 01:00:33.920]  Если я сюда подставлю в качестве B логарифм n, то что у меня получится?
[01:00:34.920 --> 01:00:39.920]  Здесь по-прежнему будет n-ка, как и раньше, а здесь зараза возникнет что?
[01:00:40.920 --> 01:00:41.920]  n логарифм логарифма n.
[01:00:42.920 --> 01:00:45.920]  О, n лог n.
[01:00:51.920 --> 01:00:52.920]  Ну вот.
[01:00:54.920 --> 01:00:56.920]  Это максимум, что я могу вам на сегодня предложить.
[01:00:57.920 --> 01:01:02.920]  Есть классическая SPARS таблица, которая работает за n лог n,
[01:01:03.920 --> 01:01:08.920]  которая может быть построена за n лог n, и запросы могут быть обработаны за единицу.
[01:01:09.920 --> 01:01:16.920]  Если у вас много свободного времени, то вы можете эту же SPARS таблицу улучшить до n лог лог n,
[01:01:16.920 --> 01:01:21.920]  ну и при этом оставить асимптотику запроса до единицы.
[01:01:22.920 --> 01:01:23.920]  Вот.
[01:01:24.920 --> 01:01:28.920]  Но опять же повторюсь, в принципе, возможно построить ее из-за линейное время.
[01:01:29.920 --> 01:01:30.920]  Об этом мы как-нибудь поговорим позже.
[01:01:31.920 --> 01:01:32.920]  Вот.
[01:01:33.920 --> 01:01:34.920]  Короче говоря, мораль.
[01:01:35.920 --> 01:01:38.920]  Для задачи статика RMQ, то есть если вам нужно посчитать минимум или любую другую
[01:01:39.920 --> 01:01:42.920]  единопатентную операцию, то пользуйтесь SPARS таблицей.
[01:01:42.920 --> 01:01:43.920]  Вот.
[01:01:44.920 --> 01:01:48.920]  Если у вас операция обратима, то пользуйтесь массивом префиксных сумм.
[01:01:49.920 --> 01:01:52.920]  Ну и, собственно, ключевой момент.
[01:01:53.920 --> 01:01:59.920]  Есть замечательная схема, которая классически называется escort этих композиций,
[01:02:00.920 --> 01:02:04.920]  которая позволяет всевозможный запрос, всевозможные задачи структуру данных ускорить.
[01:02:05.920 --> 01:02:06.920]  И вот пример.
[01:02:07.920 --> 01:02:10.920]  Либо мы ускоряем построение до n, но делаем запрос при этом из алгорифма,
[01:02:10.920 --> 01:02:15.920]  либо просто ускоряем время построения до n лог n.
[01:02:16.920 --> 01:02:17.920]  Вот.
[01:02:18.920 --> 01:02:21.920]  Ну и в этой части остается немного времени.
[01:02:22.920 --> 01:02:25.920]  Давайте к следующей задаче пока переходить не будем.
[01:02:26.920 --> 01:02:27.920]  Давайте еще обсудим один момент.
[01:02:31.920 --> 01:02:33.920]  Поговорим про многомерные задачи.
[01:02:34.920 --> 01:02:38.920]  То есть я думаю понятно, что задачи RMQ и RSCOM уже ставятся не только на, скажем, массиве,
[01:02:38.920 --> 01:02:41.920]  но и на двумерных массивах или на трехмерных массивах.
[01:02:42.920 --> 01:02:44.920]  То есть как они ставятся?
[01:02:45.920 --> 01:02:46.920]  В многомерный случай.
[01:02:58.920 --> 01:03:02.920]  Значит, вам дана матрица, и необходимо уметь читать
[01:03:02.920 --> 01:03:09.920]  уметь читать минимум, максимум или сумму на
[01:03:16.920 --> 01:03:18.920]  вот таких вот под прямоугольниках.
[01:03:23.920 --> 01:03:25.920]  На таких вот под прямоугольниках.
[01:03:26.920 --> 01:03:30.920]  Вопрос вам, понимаете ли вы как, скажем, не знаю, префиксные суммы.
[01:03:30.920 --> 01:03:32.920]  Скажем, мы решаем задачу RSQ.
[01:03:33.920 --> 01:03:38.920]  Понимаете ли вы, как массив префиксных сумм можно адаптировать и для этой конкретной задачи?
[01:03:39.920 --> 01:03:41.920]  Что нужно сделать?
[01:03:48.920 --> 01:03:50.920]  Да, то есть что нужно сделать, чтобы посчитать...
[01:03:51.920 --> 01:03:55.920]  То есть я утверждаю, что мне на самом деле достаточно уметь читать сумму вот на таких прямоугольниках.
[01:03:56.920 --> 01:03:59.920]  То есть мне достаточно посчитать суммы.
[01:04:00.920 --> 01:04:03.920]  То есть мне достаточно уметь быстро и эффективно вычислять суммы,
[01:04:04.920 --> 01:04:09.920]  суммы на прямоугольниках, у которых левый верхний конец находится в точке 0.0.
[01:04:10.920 --> 01:04:14.920]  То есть наверное на таком прямоугольнике, вот на таком прямоугольнике и так далее.
[01:04:15.920 --> 01:04:16.920]  Вот допустим, я такой умею.
[01:04:17.920 --> 01:04:19.920]  Ну и на самом деле массив префиксных сумм ровно это и дело.
[01:04:20.920 --> 01:04:22.920]  Он вычисляет сумму на некоторых префиксах.
[01:04:22.920 --> 01:04:26.920]  Здесь тоже самое, только в качестве префиксов выступают вот такие вот прямоугольнички.
[01:04:26.920 --> 01:04:35.920]  Вот, допустим, мы предпочитали все значения для таких прямоугольников.
[01:04:35.920 --> 01:04:40.920]  Как посчитать значение суммы вот здесь?
[01:04:40.920 --> 01:04:41.920]  Очень просто, да?
[01:04:41.920 --> 01:05:05.920]  Мы должны взять значение суммы здесь, вычесть суммы здесь, вычесть.
[01:05:05.920 --> 01:05:09.920]  То есть воспользоваться такой своеобразной формулой включения исключений.
[01:05:09.920 --> 01:05:14.920]  То есть мне нужно взять большой прямоугольник, потом вычесть вот этот прямоугольник, вычесть вот этот прямоугольник.
[01:05:14.920 --> 01:05:18.920]  В итоге оказалось, что вот эту штуку я вычел два раза, ее нужно еще раз прибавить.
[01:05:18.920 --> 01:05:24.920]  То есть если расписывать в виде формулы, то получается так.
[01:05:24.920 --> 01:05:38.920]  Эта задача сводится к поиску суммы на прямоугольнике, у которого последние координаты равны что-то бъ.
[01:05:38.920 --> 01:05:48.920]  Вычесть значение суммы в прямоугольнике, у которого последний координат находится в xb.
[01:05:48.920 --> 01:06:06.920]  Да, x-1b, точнее yb, x-1b, минус сумма в точке вот этой, это что у нас?
[01:06:06.920 --> 01:06:15.920]  То есть у-1, ну и прибавить вот этот прямоугольник, который мы вычисли два раза.
[01:06:15.920 --> 01:06:25.920]  То есть что это? x-1a-1.
[01:06:25.920 --> 01:06:32.920]  Ну все, если вот это мы все умеем считать за вот единицы, то есть если у нас предпочитаны все суммы на вот таких вот прямоугольниках,
[01:06:32.920 --> 01:06:40.920]  то и значение суммы здесь мы тоже посчитаем за вот единицы.
[01:06:40.920 --> 01:06:43.920]  Идея понятна?
[01:06:43.920 --> 01:06:48.920]  Ну и то же самое можно сделать с задачей rmq.
[01:06:48.920 --> 01:06:55.920]  Идея такая же, то есть тоже можно построить разреженную таблицу на двумерной таблице.
[01:06:55.920 --> 01:07:06.920]  Только в этом случае вам нужно считать t от i, ik, j, l.
[01:07:06.920 --> 01:07:18.920]  Это будет значение минимума на вот таком отрезке от i до i плюс 2 в степени k минус 1 декартового произведения,
[01:07:18.920 --> 01:07:26.920]  с j до j плюс 2 в степени l минус 1.
[01:07:26.920 --> 01:07:34.920]  Ну то есть i и j задают начало прямоугольника, а k и l задают длину по вертикали и длину по горизонтали соответственно.
[01:07:34.920 --> 01:07:48.920]  В этом случае время при процессинге будет естественно nm умноженное на log n, log m.
[01:07:48.920 --> 01:07:59.920]  То есть размер споет к координате n, размер споет к координате m, размер споет к координате log n, размер споет к координате log m.
[01:07:59.920 --> 01:08:16.920]  Ну а ответ на запрос по-прежнему за 1, потому что вы, собственно, ваш произвольный прямоугольник разбиваете на 4 прямоугольника, размеры которых имеют по каждой координате размеры 2 степеника.
[01:08:16.920 --> 01:08:28.920]  Динамика РСК.
[01:08:28.920 --> 01:08:39.920]  Первая динамическая структура данных, то есть напомню, что задача динамического РСК или динамического РМК заключается в том, что вам помимо того, что приходят запросы на изменения,
[01:08:39.920 --> 01:08:47.920]  у нас еще периодически сам массив портится. То есть приходят запросы типа измени вот этот элемент, измени вот этот элемент и так далее.
[01:08:47.920 --> 01:08:54.920]  Тут понятно, что вот те структуры данных, которые мы до этого обсуждали, они, скажем так, не очень гибкие.
[01:08:54.920 --> 01:09:12.920]  Ну скажем, если мы используем массив префиксных сумм, вот этот массив префиксных сумм и есть массив a, то если скажем, даже если мне приходит какой-нибудь маленький запрос на изменение элемента x, то что мне придется сделать?
[01:09:12.920 --> 01:09:21.920]  Мне придется изменить все элементы здесь, потому что, так или иначе, x, вот этот x отрагивает вот эту штуку, вот эту штуку, вот эту штуку и так далее.
[01:09:21.920 --> 01:09:28.920]  То же самое со sparse table. То есть теоретически, если изменить элемент x, то этот x может входить в достаточно большое количество подотрезков.
[01:09:28.920 --> 01:09:36.920]  В такой подотрезок, в такой подотрезок, в такой подотрезок, плюс еще куча других подотрезков, ну и так далее.
[01:09:36.920 --> 01:09:42.920]  В общем, непонятно. То есть, во-первых, нужно найти все эти подотрезки и их как-то изменить. В общем, непонятно, сложно, долго.
[01:09:42.920 --> 01:09:54.920]  Поэтому необходимо придумать какую-нибудь хорошую структуру данных, которая бы позволяла не только выполнять запросы, но и эффективно обновлять.
[01:09:54.920 --> 01:10:02.920]  И вот первая структура данных, про которую мы поговорим, это структура данных, которая называется дерево Фенлика.
[01:10:02.920 --> 01:10:27.920]  Нет, она называется дерево Фенлика по-русски, а в логоизвечной литературе называется binary index tree.
[01:10:32.920 --> 01:10:44.920]  Вот. Как она выглядит? Давайте начнем с идеи.
[01:10:44.920 --> 01:10:54.920]  Идея простая. Идея самого запроса, то есть запроса поиска суммы, она такая же, по сути, как и в префиксах суммах.
[01:10:54.920 --> 01:10:58.920]  Давайте просто возьмем и научимся эффективно считать сумму на префиксах.
[01:10:58.920 --> 01:11:08.920]  Опять же, если мы умеем считать сумму на префиксах, то мы умеем считать сумму на любом подотрезке. Понятно, да?
[01:11:08.920 --> 01:11:13.920]  То есть, если вы AbH-у умеете считать вот такие суммы, то сумму здесь вы тоже умеете считать.
[01:11:13.920 --> 01:11:20.920]  То есть вы посчитали сумму здесь, вычитали сумму здесь, вычили одну из другой, и получили сумму вот здесь.
[01:11:20.920 --> 01:11:25.920]  Давайте поймем, как можно эффективно выполнять сумму на префиксе.
[01:11:25.920 --> 01:11:29.920]  Значит, Фенвик предлагает следующую историю.
[01:11:29.920 --> 01:11:36.920]  Давайте возьмем сумму pi от 0 до r аитах
[01:11:36.920 --> 01:11:41.920]  и разобьем эту сумму на сумму нескольких сумм.
[01:11:41.920 --> 01:11:45.920]  Точнее так, сумму небольшого количества сумм.
[01:11:45.920 --> 01:11:49.920]  Каким образом?
[01:11:49.920 --> 01:11:54.920]  Полагается это делать как-то вот так.
[01:11:54.920 --> 01:12:08.920]  f от r минус 1 и равно f от r минус 1, а и плюс и так далее.
[01:12:08.920 --> 01:12:16.920]  Сумма по i от 0 до f от f...
[01:12:16.920 --> 01:12:30.920]  r минус 1, минус 1, минус 1, минус 1, аитах.
[01:12:30.920 --> 01:12:34.920]  Давайте напишем код.
[01:12:34.920 --> 01:12:36.920]  Мне кажется, так будет понятней.
[01:12:36.920 --> 01:12:38.920]  q i от r выглядит очень просто.
[01:12:39.920 --> 01:12:53.920]  И равное r и больше либо равно 0, и равно f от i минус 1.
[01:12:53.920 --> 01:12:56.920]  Начало в таком цикле.
[01:12:56.920 --> 01:12:59.920]  Тут я записываю сумму.
[01:12:59.920 --> 01:13:01.920]  Изначально равна 0.
[01:13:01.920 --> 01:13:07.920]  А сумма плюс равно ft от i.
[01:13:13.920 --> 01:13:15.920]  Ретерн сам.
[01:13:15.920 --> 01:13:19.920]  Вот эту штуку я сохраню в ячейку с номером r.
[01:13:19.920 --> 01:13:25.920]  Вот эту сумму я сохраню в ячейку с номером f от r минус 1.
[01:13:25.920 --> 01:13:31.920]  Вот эту сумму я сохраню в какую-то другую ячейку.
[01:13:31.920 --> 01:13:37.920]  Грубо говоря, я целиковую сумму разбиваю на сумму вот таких слагаемых.
[01:13:37.920 --> 01:13:41.920]  Где верхняя граница это r, то есть верхняя граница это текущее значение,
[01:13:41.920 --> 01:13:45.920]  а нижняя граница это некоторая функция от r.
[01:13:45.920 --> 01:13:49.920]  Общая идея понятна.
[01:13:49.920 --> 01:13:55.920]  Теперь, что Фенвик предлагает использовать в качестве этой функции f от r?
[01:13:55.920 --> 01:14:06.920]  Утверждается, что если я возьму в качестве функции f от r r амперсант r плюс 1,
[01:14:06.920 --> 01:14:11.920]  то количество этих слагаемых всегда будет логарифмическое.
[01:14:11.920 --> 01:14:17.920]  Давайте поймем почему.
[01:14:17.920 --> 01:14:25.920]  Что делает функция f?
[01:14:25.920 --> 01:14:29.920]  Может что-нибудь понимать на вскидку?
[01:14:29.920 --> 01:14:32.920]  У вас есть число r, и вы делаете следующую вещь.
[01:14:32.920 --> 01:14:36.920]  Берете r плюс 1 и андите с r и r плюс 1.
[01:14:37.920 --> 01:14:41.920]  Давайте посмотрим. Допустим, у меня r равно чему?
[01:14:41.920 --> 01:14:49.920]  Это какое-то начальное число r, дальше 0, и какое-то количество единиц в конце.
[01:14:49.920 --> 01:14:54.920]  В двоичной системе числения.
[01:14:54.920 --> 01:14:56.920]  Пусть у меня r представляется в таком виде.
[01:14:56.920 --> 01:15:01.920]  Что такое r плюс 1?
[01:15:01.920 --> 01:15:05.920]  Я единицу прибавляю к r. Что у меня в итоге получится?
[01:15:05.920 --> 01:15:08.920]  Да, r, 1 и куча нулей.
[01:15:08.920 --> 01:15:11.920]  Точнее, нули в конце.
[01:15:11.920 --> 01:15:14.920]  А теперь я это все андю.
[01:15:14.920 --> 01:15:16.920]  Что у меня в итоге получится?
[01:15:16.920 --> 01:15:19.920]  Что тут везде получится?
[01:15:19.920 --> 01:15:23.920]  Везде получится нули, ну n, побитывая i.
[01:15:23.920 --> 01:15:27.920]  1 и 0 это 0, 1 и 0 это 0 и так далее.
[01:15:27.920 --> 01:15:30.920]  Здесь что получится? 0 и 1 это 0.
[01:15:30.920 --> 01:15:33.920]  А r с волной i, r с волной, что это?
[01:15:33.920 --> 01:15:36.920]  Это то же самое r с волной.
[01:15:36.920 --> 01:15:39.920]  И это f от r.
[01:15:39.920 --> 01:15:46.920]  Вот это исходный r, вот это f от r.
[01:15:46.920 --> 01:15:51.920]  Что сделал f от r?
[01:15:51.920 --> 01:15:55.920]  Просто убрал завершающие единицы.
[01:15:55.920 --> 01:15:59.920]  У меня есть r, у него есть последние единицы.
[01:15:59.920 --> 01:16:02.920]  f от r берет и убирает последние единицы.
[01:16:02.920 --> 01:16:05.920]  То есть ответ
[01:16:05.920 --> 01:16:12.920]  убирает последовательность
[01:16:12.920 --> 01:16:19.920]  младших единиц
[01:16:19.920 --> 01:16:22.920]  в двоичном представлении.
[01:16:29.920 --> 01:16:32.920]  Ну и теперь, на самом деле, должно быть понятно, почему
[01:16:32.920 --> 01:16:37.920]  вот эта функция f от r разбивает мою исходную сумму
[01:16:37.920 --> 01:16:40.920]  налогарифмическое количество под сумм.
[01:16:40.920 --> 01:16:42.920]  Почему это так?
[01:16:42.920 --> 01:16:44.920]  Потому что у меня было число r.
[01:16:44.920 --> 01:16:47.920]  Давайте какой-нибудь пример проведем, чтобы
[01:16:47.920 --> 01:16:49.920]  было наглядно.
[01:16:49.920 --> 01:16:52.920]  Думаете какое-нибудь число r?
[01:16:52.920 --> 01:16:55.920]  Не очень большое, не очень маленькое.
[01:17:00.920 --> 01:17:03.920]  Давайте так, от
[01:17:03.920 --> 01:17:06.920]  от 100 до 500.
[01:17:06.920 --> 01:17:09.920]  100 сколько?
[01:17:12.920 --> 01:17:13.920]  133.
[01:17:13.920 --> 01:17:16.920]  Давайте для простоты представим в виде
[01:17:16.920 --> 01:17:19.920]  суммы 128 плюс
[01:17:19.920 --> 01:17:21.920]  что тут?
[01:17:21.920 --> 01:17:25.920]  Плюс 8. Нет.
[01:17:25.920 --> 01:17:28.920]  Плюс 4 плюс 1.
[01:17:28.920 --> 01:17:31.920]  Ну или это 1,
[01:17:31.920 --> 01:17:34.920]  0, 1.
[01:17:37.920 --> 01:17:40.920]  Вот такое двоичное представление.
[01:17:40.920 --> 01:17:43.920]  Давайте посмотрим,
[01:17:43.920 --> 01:17:46.920]  что такое r.
[01:17:46.920 --> 01:17:49.920]  Что такое отрезок r и f от r?
[01:17:49.920 --> 01:17:52.920]  Значит, отрезок r и f от r это отрезок
[01:17:52.920 --> 01:17:55.920]  от 133
[01:17:55.920 --> 01:17:58.920]  до f от r, f от r что делает?
[01:17:58.920 --> 01:18:01.920]  f от r просто берет и конечную единицу убирает.
[01:18:01.920 --> 01:18:04.920]  То есть я убираю эту единицу, получается число 132.
[01:18:04.920 --> 01:18:07.920]  Все, то есть
[01:18:07.920 --> 01:18:10.920]  f
[01:18:10.920 --> 01:18:13.920]  ft от 133
[01:18:13.920 --> 01:18:16.920]  у меня хранит сумму элементов
[01:18:16.920 --> 01:18:19.920]  от 132 до 133.
[01:18:19.920 --> 01:18:22.920]  Дальше.
[01:18:22.920 --> 01:18:25.920]  Дальше мне нужно посчитать сумму где?
[01:18:25.920 --> 01:18:28.920]  Мне нужно посчитать сумму от 131.
[01:18:28.920 --> 01:18:31.920]  Ну, я тут немного перевернул,
[01:18:31.920 --> 01:18:34.920]  ничего страшного.
[01:18:34.920 --> 01:18:37.920]  Элементы со 133 по 132 я посчитал.
[01:18:37.920 --> 01:18:40.920]  Следующий элемент суммы должен начинаться со 131.
[01:18:40.920 --> 01:18:43.920]  Какое битвое представление имеет 131?
[01:18:43.920 --> 01:18:46.920]  132 имеет такое представление.
[01:18:46.920 --> 01:18:49.920]  Да.
[01:18:49.920 --> 01:18:52.920]  То есть мы убрали вот эту единицу
[01:18:52.920 --> 01:18:55.920]  и вместо этой единицы поставили ноль
[01:18:55.920 --> 01:18:58.920]  и в конце дописали просто две единицы.
[01:18:58.920 --> 01:19:01.920]  Так.
[01:19:01.920 --> 01:19:04.920]  Применяю к этому значению f от r.
[01:19:04.920 --> 01:19:07.920]  Последние единицы убираются.
[01:19:07.920 --> 01:19:10.920]  Что в итоге остается?
[01:19:10.920 --> 01:19:13.920]  2, 3, 4, 5,
[01:19:13.920 --> 01:19:16.920]  2, 3, 4, 5, 6, 7.
[01:19:16.920 --> 01:19:19.920]  Вот.
[01:19:19.920 --> 01:19:22.920]  То есть тут я обращаюсь к элементу ft 131,
[01:19:22.920 --> 01:19:25.920]  которая хранит сумму от
[01:19:25.920 --> 01:19:28.920]  128 до 131.
[01:19:28.920 --> 01:19:31.920]  Вот.
[01:19:31.920 --> 01:19:34.920]  Ну и далее.
[01:19:34.920 --> 01:19:37.920]  127 это просто 7 единиц.
[01:19:37.920 --> 01:19:40.920]  Ну и если я у числа,
[01:19:40.920 --> 01:19:43.920]  которого в двоичном представлении все единицы убираю
[01:19:43.920 --> 01:19:46.920]  и все единицы последние, то остается ноль.
[01:19:46.920 --> 01:19:49.920]  Всё. Таким образом у меня завершается
[01:19:49.920 --> 01:19:52.920]  сумма.
[01:19:52.920 --> 01:19:55.920]  Тут просто сумма от 0 до 127.
[01:19:55.920 --> 01:19:58.920]  Вот.
[01:19:58.920 --> 01:20:01.920]  Идея понятна, да?
[01:20:01.920 --> 01:20:04.920]  Понятна, на какие отрезки у вас разбивает
[01:20:04.920 --> 01:20:07.920]  функция f от r? То есть на очередном шаге
[01:20:07.920 --> 01:20:10.920]  у вас функция f от r
[01:20:10.920 --> 01:20:13.920]  просто берет и откусывает очередную единицу
[01:20:13.920 --> 01:20:16.920]  из двоичного представления.
[01:20:16.920 --> 01:20:19.920]  То есть здесь откусила последнюю единицу, здесь откусила вот эту единицу,
[01:20:19.920 --> 01:20:22.920]  здесь откусила вот эту единицу.
[01:20:22.920 --> 01:20:25.920]  Ну а так у меня в числе длины n.
[01:20:25.920 --> 01:20:28.920]  То есть если у меня массив имеет размер n, то максимальный индекс,
[01:20:28.920 --> 01:20:31.920]  который я могу обратиться, это n.
[01:20:31.920 --> 01:20:34.920]  То есть у меня максимальный логарифм n-бит.
[01:20:34.920 --> 01:20:37.920]  Поэтому количество сумм здесь
[01:20:37.920 --> 01:20:40.920]  у меня логарифмическое.
[01:20:40.920 --> 01:20:43.920]  Согласны?
[01:20:43.920 --> 01:20:46.920]  Ну вот.
[01:20:46.920 --> 01:20:49.920]  Пока ничего, нормально.
[01:20:49.920 --> 01:20:52.920]  Все вот эти рассуждения не могут показаться сложными,
[01:20:52.920 --> 01:20:55.920]  но на самом деле всё, что нужно знать, это
[01:20:55.920 --> 01:20:58.920]  вот эта вещь.
[01:20:59.920 --> 01:21:02.920]  И вот эта формула, всё.
[01:21:02.920 --> 01:21:05.920]  То есть запрос в данной структуре данных
[01:21:05.920 --> 01:21:08.920]  выполняется в три строчки.
[01:21:08.920 --> 01:21:11.920]  То есть мы проходим всё в цикле от r до 0,
[01:21:11.920 --> 01:21:14.920]  обновляем и вот по такому правилу,
[01:21:14.920 --> 01:21:17.920]  и просто добавляем в сумму очередной элемент
[01:21:17.920 --> 01:21:20.920]  дерева Фенлика. Возвращаем сумму.
[01:21:22.920 --> 01:21:25.920]  Работает зал логарифм.
[01:21:26.920 --> 01:21:29.920]  От лога n.
[01:21:29.920 --> 01:21:32.920]  Ну я думаю понятно, как выглядит
[01:21:32.920 --> 01:21:35.920]  запрос на отрезке от l до r.
[01:21:35.920 --> 01:21:38.920]  Запрос на отрезке от l до r
[01:21:38.920 --> 01:21:41.920]  является просто запросом на префиксе r
[01:21:41.920 --> 01:21:44.920]  минус запрос
[01:21:44.920 --> 01:21:47.920]  на префиксе l-1.
[01:21:50.920 --> 01:21:53.920]  Так как каждый из отдельных запросов
[01:21:53.920 --> 01:21:56.920]  логарифм, то и суммарный запрос на отрезке
[01:21:56.920 --> 01:21:59.920]  тоже выполняется зал логарифм.
[01:21:59.920 --> 01:22:02.920]  Вопросы есть?
[01:22:02.920 --> 01:22:05.920]  Теперь переходим к самому интересному.
[01:22:05.920 --> 01:22:08.920]  Первое, а как всё это построить?
[01:22:08.920 --> 01:22:11.920]  Как построить такое дерево Фенлика?
[01:22:11.920 --> 01:22:14.920]  А во-вторых, причём тут обновление?
[01:22:14.920 --> 01:22:17.920]  Как обновлять элементы?
[01:22:17.920 --> 01:22:20.920]  Кажется, мы задачу не упростили.
[01:22:20.920 --> 01:22:23.920]  Что-то придумали, что довольно сложно должно быть обновлять.
[01:22:23.920 --> 01:22:26.920]  На самом деле, я утверждаю, что обновление тоже будет в 3 строчки.
[01:22:26.920 --> 01:22:29.920]  Сейчас мы это увидим.
[01:22:40.920 --> 01:22:43.920]  Для начала обсудим построение.
[01:22:46.920 --> 01:22:49.920]  Построение довольно простое.
[01:22:49.920 --> 01:22:52.920]  Трейс состоит из двух шагов.
[01:22:52.920 --> 01:22:55.920]  Первый шаг.
[01:22:55.920 --> 01:22:58.920]  Строим префиксные суммы P.
[01:22:58.920 --> 01:23:01.920]  Ну, те самые префиксные суммы,
[01:23:01.920 --> 01:23:04.920]  про которые мы на первой половине говорили.
[01:23:04.920 --> 01:23:07.920]  Ну а второе.
[01:23:07.920 --> 01:23:10.920]  Ft от I равно значение префиксной суммы в точке I
[01:23:10.920 --> 01:23:13.920]  минус значение префиксной суммы в точке l-1.
[01:23:19.920 --> 01:23:22.920]  Ft от I минус 1.
[01:23:22.920 --> 01:23:25.920]  Всё.
[01:23:25.920 --> 01:23:28.920]  Это tt от n,
[01:23:28.920 --> 01:23:31.920]  это tt от n. Всё. Построили структуру данных
[01:23:31.920 --> 01:23:34.920]  за линейное время.
[01:23:34.920 --> 01:23:37.920]  Здесь понятно или пояснить?
[01:23:37.920 --> 01:23:40.920]  Ft и t это просто-напросто
[01:23:40.920 --> 01:23:43.920]  сумма по
[01:23:43.920 --> 01:23:46.920]  тежи от
[01:23:46.920 --> 01:23:49.920]  F от I до I,
[01:23:49.920 --> 01:23:52.920]  ожитых.
[01:23:52.920 --> 01:23:55.920]  А чтобы посчитать такую сумму, я беру сумму от 0 до I
[01:23:55.920 --> 01:23:58.920]  и сумму от 0 до F от I минус 1.
[01:23:58.920 --> 01:24:01.920]  Вычитаю, получаю равно то, что можно.
[01:24:01.920 --> 01:24:04.920]  Всё, с построением разобрались.
[01:24:04.920 --> 01:24:07.920]  Ну и обновление в точке.
[01:24:17.920 --> 01:24:20.920]  Хотим
[01:24:23.920 --> 01:24:26.920]  обновить
[01:24:30.920 --> 01:24:33.920]  значение
[01:24:33.920 --> 01:24:36.920]  ai.
[01:24:36.920 --> 01:24:39.920]  Ну что мы хотим сделать? Мы хотим на самом деле
[01:24:39.920 --> 01:24:42.920]  ai сделать плюс равно дельта.
[01:24:42.920 --> 01:24:45.920]  То есть мы хотим взять элемент
[01:24:45.920 --> 01:24:48.920]  i и увеличить его на дельту.
[01:24:51.920 --> 01:24:54.920]  Что нам для этого понадобится?
[01:24:59.920 --> 01:25:02.920]  Что нужно сделать, чтобы у меня вся моя
[01:25:02.920 --> 01:25:05.920]  структура данных обновилась, чтобы она увидела это обновление?
[01:25:11.920 --> 01:25:14.920]  Ну что?
[01:25:14.920 --> 01:25:17.920]  У меня вся моя структура данных состоит из одного
[01:25:17.920 --> 01:25:20.920]  из одного массива Ft. Что мне нужно сделать с массивом Ft?
[01:25:24.920 --> 01:25:27.920]  Что?
[01:25:27.920 --> 01:25:30.920]  Ft и t плюс равно дельта этого не достаточно.
[01:25:30.920 --> 01:25:33.920]  Ну то есть у меня Ft и t действительно в качестве члена содержат
[01:25:33.920 --> 01:25:36.920]  ai и t, поэтому его надо обновить.
[01:25:36.920 --> 01:25:39.920]  Но у меня в принципе ai и t могут содержать и другие члены
[01:25:39.920 --> 01:25:42.920]  Ft и t.
[01:25:42.920 --> 01:25:45.920]  Массив Ft, давайте так.
[01:25:45.920 --> 01:25:48.920]  Формально.
[01:25:48.920 --> 01:25:51.920]  Нужно
[01:25:51.920 --> 01:25:54.920]  обновить
[01:25:54.920 --> 01:25:57.920]  все...
[01:25:57.920 --> 01:26:00.920]  Давайте тут k.
[01:26:00.920 --> 01:26:03.920]  Я хочу обновить окатый.
[01:26:03.920 --> 01:26:06.920]  Нужно обновить все Ft и t
[01:26:06.920 --> 01:26:09.920]  такие, что
[01:26:09.920 --> 01:26:12.920]  окатый,
[01:26:12.920 --> 01:26:15.920]  давайте так грубо скажем, принадлежит
[01:26:18.920 --> 01:26:21.920]  Ft и t.
[01:26:21.920 --> 01:26:24.920]  Согласны?
[01:26:24.920 --> 01:26:27.920]  Ну то есть у меня в массиве Ft и t содержатся какие-то маленькие суммы.
[01:26:27.920 --> 01:26:30.920]  Тут сумма,
[01:26:30.920 --> 01:26:33.920]  Ft0 сумма, Ft1 какая-то сумма, Ft2 какая-то сумма и так далее.
[01:26:33.920 --> 01:26:36.920]  Мне нужно среди всех этих элементов
[01:26:36.920 --> 01:26:39.920]  найти такие, которые содержат внутри себя член окатый.
[01:26:39.920 --> 01:26:42.920]  Да?
[01:26:42.920 --> 01:26:45.920]  Беда, как это сделать?
[01:26:50.920 --> 01:26:53.920]  Можно ли как-то по i
[01:26:58.920 --> 01:27:01.920]  можно ли как-то по i понять
[01:27:01.920 --> 01:27:04.920]  содержится у меня там k или нет?
[01:27:04.920 --> 01:27:07.920]  То есть вопрос, как
[01:27:07.920 --> 01:27:10.920]  по i
[01:27:10.920 --> 01:27:13.920]  понять
[01:27:16.920 --> 01:27:19.920]  нужно обновлять
[01:27:21.920 --> 01:27:24.920]  Ft и t
[01:27:25.920 --> 01:27:28.920]  или нет?
[01:27:28.920 --> 01:27:31.920]  Да.
[01:27:31.920 --> 01:27:34.920]  У меня k должен лежать в пределах
[01:27:34.920 --> 01:27:37.920]  от i
[01:27:37.920 --> 01:27:40.920]  ой, наоборот.
[01:27:40.920 --> 01:27:43.920]  i должен лежать в пределах от k
[01:27:43.920 --> 01:27:46.920]  k должен лежать в пределах от i
[01:27:46.920 --> 01:27:49.920]  до f от i.
[01:27:49.920 --> 01:27:52.920]  Согласны?
[01:27:52.920 --> 01:27:55.920]  Да нет,
[01:27:55.920 --> 01:27:58.920]  у меня же сумма вот такой вид имеет.
[01:27:58.920 --> 01:28:01.920]  То есть если k равно f от i,
[01:28:01.920 --> 01:28:04.920]  то он все еще принадлежит сумме.
[01:28:04.920 --> 01:28:07.920]  Все, и осталось,
[01:28:07.920 --> 01:28:10.920]  я свел задачу обновления к поиску всех таких i-шек,
[01:28:10.920 --> 01:28:13.920]  которые удовлетворяют этому соотношению.
[01:28:13.920 --> 01:28:16.920]  Задача понятна.
[01:28:16.920 --> 01:28:19.920]  Осталось
[01:28:19.920 --> 01:28:22.920]  найти все i
[01:28:22.920 --> 01:28:25.920]  такие что
[01:28:26.920 --> 01:28:29.920]  f от i меньше либо значим k,
[01:28:29.920 --> 01:28:32.920]  и меньше либо значим i.
[01:28:32.920 --> 01:28:35.920]  Вот.
[01:28:35.920 --> 01:28:38.920]  Сейчас мы немного повыводим формул
[01:28:38.920 --> 01:28:41.920]  и в итоге получим что-то очень-очень приятное.
[01:28:43.920 --> 01:28:46.920]  Вот.
[01:28:46.920 --> 01:28:49.920]  Давайте
[01:28:49.920 --> 01:28:52.920]  в виде некоторого вывода оформим.
[01:28:52.920 --> 01:28:55.920]  Будем строить i в порядке
[01:28:55.920 --> 01:28:58.920]  возрастания.
[01:28:58.920 --> 01:29:01.920]  То есть возьмем наименьшее i, которое удовлетворяет этому условию,
[01:29:01.920 --> 01:29:04.920]  потом следующее повелечение i, следующее и так далее.
[01:29:04.920 --> 01:29:07.920]  То есть построим возрастающую последовательность i,
[01:29:07.920 --> 01:29:10.920]  которая удовлетворяет этому соотношению.
[01:29:10.920 --> 01:29:13.920]  План понятен?
[01:29:14.920 --> 01:29:17.920]  Возрастающую
[01:29:17.920 --> 01:29:20.920]  последовательность i.
[01:29:20.920 --> 01:29:23.920]  Давайте эту звездочку обозначим.
[01:29:23.920 --> 01:29:26.920]  Удовлетворяю последовательность, удовлетворяющую,
[01:29:28.920 --> 01:29:31.920]  удовлетворяющих
[01:29:32.920 --> 01:29:35.920]  звездочки.
[01:29:36.920 --> 01:29:38.920]  Ну, погнали.
[01:29:38.920 --> 01:29:40.920]  И нульвое.
[01:29:40.920 --> 01:29:43.920]  Это первый элемент последовательности.
[01:29:43.920 --> 01:29:46.920]  k.
[01:29:46.920 --> 01:29:49.920]  Все согласны, что k это минимальный i, который удовлетворяет этому соотношению.
[01:29:49.920 --> 01:29:52.920]  Ну, если я возьму i меньше, чем k, то у меня вот это
[01:29:52.920 --> 01:29:55.920]  утверждение будет выполнено.
[01:29:55.920 --> 01:29:58.920]  Если возьму i больше, чем k, то если я возьму i равное k, то
[01:29:58.920 --> 01:30:01.920]  естественно вот это будет выполнено, и вот это естественно тоже будет выполнено.
[01:30:01.920 --> 01:30:04.920]  Ну, потому что f от i, да, я этого не сказал, но я думаю это понятно,
[01:30:04.920 --> 01:30:07.920]  что f от r всегда меньше либо равен, чем r.
[01:30:07.920 --> 01:30:10.920]  Ну, операция побитого i не может увеличить число,
[01:30:10.920 --> 01:30:13.920]  потому что там какие-то биты выставляются в ноль.
[01:30:13.920 --> 01:30:16.920]  Новые единицы там не появляются.
[01:30:16.920 --> 01:30:19.920]  Вот, хорошо, и нульвое равное k. Отлично, уже что-то.
[01:30:19.920 --> 01:30:22.920]  Теперь давайте по индукции допустим,
[01:30:26.920 --> 01:30:29.920]  допустим, построили
[01:30:31.920 --> 01:30:34.920]  i с индексом. Ну, какой индекс?
[01:30:34.920 --> 01:30:37.920]  Ну, давайте альфа, не знаю.
[01:30:37.920 --> 01:30:40.920]  Допустим, построили i альфа.
[01:30:42.920 --> 01:30:45.920]  Построим следующий член последовательности,
[01:30:45.920 --> 01:30:48.920]  i альфа плюс один.
[01:30:49.920 --> 01:30:52.920]  Вот сейчас будут содержательные рассуждения.
[01:30:52.920 --> 01:30:55.920]  Ничего не пропустить.
[01:30:55.920 --> 01:30:58.920]  Давайте посмотрим на i альфа.
[01:30:58.920 --> 01:31:01.920]  Как он выглядит?
[01:31:02.920 --> 01:31:05.920]  Ну, посмотрим на двоичное представление числа i альфа.
[01:31:05.920 --> 01:31:08.920]  i альфа выглядит каким-то таким образом.
[01:31:08.920 --> 01:31:11.920]  Ну, во-первых, тут стоит какая-то альфа.
[01:31:11.920 --> 01:31:14.920]  Дальше идет нолик
[01:31:17.920 --> 01:31:20.920]  и куча единиц.
[01:31:20.920 --> 01:31:23.920]  И куча единиц.
[01:31:24.920 --> 01:31:27.920]  И куча единиц.
[01:31:27.920 --> 01:31:30.920]  Ну, не куча единиц, а просто какие-то единицы в конце.
[01:31:30.920 --> 01:31:33.920]  Ну, вы согласны, что любое число i предстоит вот в таком виде?
[01:31:33.920 --> 01:31:36.920]  Какой-то начальный кусок, ноль, и дальше последние единицы.
[01:31:36.920 --> 01:31:39.920]  Ну, произвольное количество. Тут может быть ноль и так далее.
[01:31:39.920 --> 01:31:42.920]  Окей. Что мне известно?
[01:31:42.920 --> 01:31:45.920]  Мне известно, что i альфа больше либо равен, чем k.
[01:31:45.920 --> 01:31:48.920]  А какой вид имеет k?
[01:31:48.920 --> 01:31:51.920]  Нет, давайте так.
[01:31:51.920 --> 01:31:54.920]  Сначала поймем, чему равен f от i альфа в этом случае.
[01:31:54.920 --> 01:31:57.920]  f от i альфа имеет какой вид?
[01:31:57.920 --> 01:32:00.920]  Ну, что делает f от i альфа?
[01:32:00.920 --> 01:32:03.920]  Он просто убирает последние единицы. Согласны?
[01:32:03.920 --> 01:32:06.920]  Поэтому тут тоже самое альфа с волной.
[01:32:06.920 --> 01:32:09.920]  И дальше на всех позициях, которые здесь стояли единицы,
[01:32:09.920 --> 01:32:12.920]  теперь стоят нули.
[01:32:12.920 --> 01:32:15.920]  Кроме того, мне известно, что i альфа лежит в этой последовательности.
[01:32:15.920 --> 01:32:18.920]  Ну, то есть по условиям индукции, по предположениям индукции.
[01:32:18.920 --> 01:32:21.920]  Eles снижают между этими значениями.
[01:32:21.920 --> 01:32:24.920]  Поэтому k имеет вид альфа, с волной, ноль, и здесь что угодно.
[01:32:27.920 --> 01:32:30.920]  ДА?
[01:32:30.920 --> 01:32:33.920]  Ну, согласны, что я тут вместо альфы не могу поставить
[01:32:33.920 --> 01:32:36.920]  никакое число, которое больше, чем альфа с волной.
[01:32:36.920 --> 01:32:39.920]  Потому что иначе оно бы было больше, чем и альфа.
[01:32:39.920 --> 01:32:42.920]  Также вместо альфа с волной, я не могу поставить число, которое меньше альфа с волной,
[01:32:42.920 --> 01:32:45.920]  потому что оно тогда было бы меньше, чем вот это число.
[01:32:45.920 --> 01:32:53.420]  Дальше, здесь обязательно стоит ноль, потому что если бы стояла единица, я бы вышел за пределы и альфа, хорошо, значит тут должен стоять ноль.
[01:32:53.420 --> 01:32:56.920]  Ну а сюда я могу поставить что угодно, неравенство всегда будет выполнено.
[01:32:56.920 --> 01:32:58.920]  Окей.
[01:33:01.920 --> 01:33:04.920]  Ну и осталось теперь понять, точнее осталось найти
[01:33:11.920 --> 01:33:14.920]  наименьший и альфа плюс один
[01:33:17.920 --> 01:33:20.920]  удовлетворяющий звездочки.
[01:33:20.920 --> 01:33:28.920]  Вот давайте попробуем как-то изменить и альфа наиболее, скажем так, наиболее слабым образом, так чтобы это неравенство все еще выполнялось.
[01:33:29.920 --> 01:33:33.920]  Вопрос. Могу ли я изменить что-то внутри альфы?
[01:33:35.920 --> 01:33:39.920]  Ну нет, подождите, не будьте так категоричны. Чисто теоретически могу.
[01:33:40.920 --> 01:33:46.920]  Но чисто теоретически и альфа может измениться так, что тут вместо альфы будут стоять какие-то другие значения.
[01:33:47.920 --> 01:33:51.920]  Ну чисто теоретически. Ну то есть, например, я тут поставил все единицы,
[01:33:51.920 --> 01:33:58.920]  и тогда, когда я буду делать f от и альфы, у меня у альфы какие-то единицы дропнутся, и все еще вот это неравенство будет выполняться.
[01:33:59.920 --> 01:34:03.920]  Ну то есть теоретически альфу я изменить могу, но я пока не хочу этого делать. Почему?
[01:34:03.920 --> 01:34:06.920]  Потому что если я изменю альфу, то это будет какое-то сильное изменение.
[01:34:06.920 --> 01:34:09.920]  Давайте я попробую изменить какие-то младшие биты.
[01:34:09.920 --> 01:34:13.920]  Какой младший бит я могу пока изменить? Ну только вот этот.
[01:34:17.920 --> 01:34:22.920]  То есть попробуем построить вот такую штуку.
[01:34:24.920 --> 01:34:30.920]  Ну то есть вот этот кусок я увеличивать уже никак не могу, поэтому я увеличиваю вот этот кусок.
[01:34:31.920 --> 01:34:37.920]  На вот этот кусок минимально я могу увеличивать вот до вот такой величины. И альфа единица.
[01:34:38.920 --> 01:34:43.920]  Вот. Следующий этап рассуждений.
[01:34:44.920 --> 01:34:50.920]  А может ли случиться так, что у меня где-то здесь будет стоять 0?
[01:34:51.920 --> 01:34:52.920]  Вопрос.
[01:34:55.920 --> 01:35:00.920]  Может ли здесь стоять 0?
[01:35:01.920 --> 01:35:02.920]  Плохо написал.
[01:35:03.920 --> 01:35:05.920]  Мне нужно будет место.
[01:35:07.920 --> 01:35:10.920]  Нет, не может. Давайте пока другие тоже осознайте, почему нет.
[01:35:12.920 --> 01:35:18.920]  Может ли здесь стоять 0?
[01:35:19.920 --> 01:35:20.920]  Почему?
[01:35:26.920 --> 01:35:31.920]  Да. Смотрите, давайте я применю к вот такому и альфа плюс один.
[01:35:31.920 --> 01:35:33.920]  f от и альфа плюс один.
[01:35:33.920 --> 01:35:35.920]  Чему это будет равно?
[01:35:35.920 --> 01:35:37.920]  Что сделает и альфа плюс один?
[01:35:38.920 --> 01:35:41.920]  И альфа плюс один уберет единички отсюда. Согласны?
[01:35:42.920 --> 01:35:49.920]  То есть f от и альфа плюс один будет иметь вид альфа, один, этот нолик останется на месте,
[01:35:50.920 --> 01:35:54.920]  и возможно тут изменятся какие-то там значения. Давайте я просто звездочками обозначу.
[01:35:55.920 --> 01:36:01.920]  А k у меня имеет вид 0, ну и так далее. Все, неравенство не выполняется.
[01:36:02.920 --> 01:36:09.920]  То есть вот этот нолик мешает вот этой f от и альфа поменять вот эту единицу, которая мне не нужна.
[01:36:10.920 --> 01:36:11.920]  Понятно?
[01:36:14.920 --> 01:36:15.920]  Нет.
[01:36:18.920 --> 01:36:20.920]  Так как вот.
[01:36:23.920 --> 01:36:27.920]  То есть вот это неравенство не выполняется.
[01:36:28.920 --> 01:36:30.920]  И что в итоге остается?
[01:36:31.920 --> 01:36:37.920]  В итоге остается, что у меня и альфа плюс один имеет вид альфа, один, и тут все единицы. Понятно?
[01:36:38.920 --> 01:36:41.920]  Ну вот и все. Вы боялись.
[01:36:48.920 --> 01:36:50.920]  Сейчас, почему вот это не выполняется?
[01:36:51.920 --> 01:36:54.920]  Смотрите, давайте еще раз. Это единственный сложный момент.
[01:36:56.920 --> 01:36:57.920]  Смотрите еще раз.
[01:36:58.920 --> 01:37:00.920]  Я пытаюсь сюда поставить единицу.
[01:37:01.920 --> 01:37:03.920]  Теперь, я задаюсь вопросом.
[01:37:04.920 --> 01:37:09.920]  Можно ли сюда куда-нибудь, вот там где стояли раньше единицы, могу ли я сюда куда-нибудь втиснуть ноль?
[01:37:10.920 --> 01:37:13.920]  То есть если я сюда втисну ноль, при этом изменю единицу, у меня все равно и альфа плюс один увеличится.
[01:37:14.920 --> 01:37:21.920]  Я утверждаю, что не могу. Почему? Потому что если я к этой и альфа плюс один применю f, то что сделает f?
[01:37:22.920 --> 01:37:26.920]  f берет и уберет все завершающие единицы, если они тут были.
[01:37:27.920 --> 01:37:30.920]  То есть если тут есть завершающие единицы, f их уберет.
[01:37:31.920 --> 01:37:35.920]  Но при этом дальше f не пойдет. Почему? Потому что она убирает только последовательные единицы.
[01:37:36.920 --> 01:37:38.920]  Все, соответственно тут у меня возможно заменились какие-то единицы.
[01:37:39.920 --> 01:37:43.920]  И f от альфа минус один, и альфа плюс один имеет вот такой вид.
[01:37:49.920 --> 01:37:54.920]  Именно, да. То есть и альфа плюс один имеет такой вид, f от и альфа плюс один имеет вот такой вид, а k имеет вот такой вид.
[01:37:55.920 --> 01:37:57.920]  И поэтому k никак не может быть зажат между ними.
[01:37:58.920 --> 01:38:00.920]  Все, поэтому это меня не устраивает.
[01:38:01.920 --> 01:38:07.920]  И единственное, что меня устраивает, это вот такая вещь. Альфа и дальше куча единиц.
[01:38:10.920 --> 01:38:16.920]  То есть если мне дан какой-то и альфа, то правильным решением, то есть правильным способом получить следующий элемент по величине,
[01:38:17.920 --> 01:38:20.920]  будет просто заменить ближайший ноль справа на единицу. Понятно?
[01:38:21.920 --> 01:38:24.920]  То есть я взял просто первый ноль справа, заменил ее на единицу.
[01:38:25.920 --> 01:38:27.920]  Давайте поймем, почему тут все будет хорошо.
[01:38:27.920 --> 01:38:29.920]  Ну рассмотрим f от и альфа плюс один.
[01:38:30.920 --> 01:38:32.920]  f от и альфа плюс один имеет какой вид?
[01:38:33.920 --> 01:38:35.920]  Он имеет вид.
[01:38:36.920 --> 01:38:39.920]  Вот тут бета, ноль, ноль, и так далее ноль.
[01:38:40.920 --> 01:38:41.920]  Понятно, почему бета?
[01:38:42.920 --> 01:38:45.920]  Ну потому что у этой альфы в свою очередь тоже могли быть какие-то завершающие единицы.
[01:38:46.920 --> 01:38:48.920]  Да, и f их тоже сожрет.
[01:38:49.920 --> 01:38:53.920]  То есть ну в любом случае b с волной меньше либо равно, чем i с волной.
[01:38:54.920 --> 01:38:55.920]  Ой, альфа с волной.
[01:38:55.920 --> 01:38:56.920]  Этот момент понятен, да?
[01:38:58.920 --> 01:39:01.920]  Ну не обязательно, если альфа завершается нулем, то тогда...
[01:39:02.920 --> 01:39:06.920]  Ну то есть если в качестве альфа я возьму один ноль, то тут по-прежнему останется один ноль.
[01:39:11.920 --> 01:39:13.920]  Короче, и альфа плюс один имеет такой вид.
[01:39:14.920 --> 01:39:16.920]  f от и альфа плюс один имеет вид такой.
[01:39:17.920 --> 01:39:20.920]  f сожирает все единицы, и возможно что-то отжирает от альфы.
[01:39:20.920 --> 01:39:21.920]  Ну поэтому тут бета, которая меньше либо равно, чем альфа.
[01:39:22.920 --> 01:39:24.920]  Ну а k у меня по-прежнему имеет тот же самый вид.
[01:39:25.920 --> 01:39:26.920]  Ну k я никак не изменяю.
[01:39:26.920 --> 01:39:28.920]  k мне дано откуда-то сверху.
[01:39:34.920 --> 01:39:35.920]  Не равенство по-прежнему выполняются.
[01:39:37.920 --> 01:39:38.920]  Согласны?
[01:39:41.920 --> 01:39:45.920]  Ну вот это i больше, чем k, и вот это k больше, чем альфа.
[01:39:46.920 --> 01:39:50.920]  Ну вот это i больше, чем k, и вот это k больше, чем fk.
[01:39:51.920 --> 01:39:53.920]  Ну почему? Потому что альфа больше либо равно, чем бета.
[01:39:59.920 --> 01:40:00.920]  Задайте вопросы.
[01:40:00.920 --> 01:40:01.920]  Ну и все, теперь катарсис.
[01:40:02.920 --> 01:40:03.920]  Plo есть.
[01:40:05.920 --> 01:40:06.920]  и альфа плюс один равно…
[01:40:07.920 --> 01:40:08.920]  И вот вопрос вам.
[01:40:09.920 --> 01:40:13.920]  Что это за такая функция, которая берет и альфа,
[01:40:13.920 --> 01:40:15.920]  и вместо последнего нуля выставляет единицы?
[01:40:16.920 --> 01:40:17.920]  А можно勝ить?
[01:40:18.920 --> 01:40:19.920]  А можно выиграть?
[01:40:20.920 --> 01:40:21.920]  А можно выиграть?
[01:40:21.920 --> 01:40:22.920]  А можно быть львовым?
[01:40:23.920 --> 01:40:24.920]  А можно сломать?
[01:40:24.920 --> 01:40:25.920]  А можно선 сломать?
[01:40:25.920 --> 01:40:26.920]  А можно들을 сломать?
[01:40:26.920 --> 01:40:27.920]  А можноboards сломать?
[01:40:27.920 --> 01:40:28.920]  А можноы сломать?
[01:40:28.920 --> 01:40:30.920]  И вместо последнего нуля выставляет единицу.
[01:40:37.920 --> 01:40:40.920]  Ну, давайте в терминах битовых операций.
[01:40:43.920 --> 01:40:48.920]  О, и альфа, или и альфа плюс один.
[01:40:50.920 --> 01:40:53.920]  А напомните, как у нас была функция f изначально?
[01:40:58.920 --> 01:40:59.920]  Все.
[01:41:04.920 --> 01:41:05.920]  То есть мораль.
[01:41:06.920 --> 01:41:12.920]  Когда мы выполняем запрос суммы, мы пользуемся вот такой формулой.
[01:41:13.920 --> 01:41:16.920]  Когда мы используем запрос обновления, мы пользуемся вот такой формулой.
[01:41:17.920 --> 01:41:18.920]  Все.
[01:41:19.920 --> 01:41:22.920]  Чтобы научиться писать дерево Фенга, достаточно запомнить эти две формулы.
[01:41:23.920 --> 01:41:27.920]  Ну то есть, вывод сложный, а сама структура данных простая.
[01:41:29.920 --> 01:41:37.920]  Давайте напишем функцию update, ну и восстановим функцию query, чтобы вы убедились.
[01:41:38.920 --> 01:41:40.920]  Можете засечь, за сколько у меня это получится.
[01:41:44.920 --> 01:41:45.920]  Так, update.
[01:41:48.920 --> 01:41:51.920]  Значит, я обновляю i, элемент i на дельту.
[01:41:52.920 --> 01:41:54.920]  Что мне нужно сделать?
[01:41:55.920 --> 01:41:57.920]  Мне нужно взять i.
[01:41:58.920 --> 01:41:59.920]  Делать в к, в точке к мы обновляем.
[01:42:00.920 --> 01:42:01.920]  i равное k.
[01:42:02.920 --> 01:42:09.920]  И пока i меньше чем n, делать i равно i, или i плюс один.
[01:42:11.920 --> 01:42:16.920]  Да, ну то есть мы вывели формулу, чтобы получить по возрастающую последовательность i,
[01:42:17.920 --> 01:42:22.920]  возрастающую последовательность индексов, которые мне нужно обновить, она должна иметь следующий вид.
[01:42:23.920 --> 01:42:25.920]  Первый член это k, а следующий член я получаю вот по той формуле.
[01:42:26.920 --> 01:42:27.920]  Все.
[01:42:28.920 --> 01:42:29.920]  И что я должен сделать?
[01:42:30.920 --> 01:42:35.920]  Просто взять iто-элемент дерева Фенлика и увеличить его на дельту.
[01:42:36.920 --> 01:42:37.920]  Все.
[01:42:38.920 --> 01:42:39.920]  Update закончен.
[01:42:40.920 --> 01:42:41.920]  Query.
[01:42:44.920 --> 01:42:45.920]  Query на префиксе.
[01:42:45.920 --> 01:43:02.920]  В префиксе for i равное r, i больше либо равно, чем ноль, i равно i and i плюс один.
[01:43:03.920 --> 01:43:04.920]  Ну и тут минус один еще добавляется.
[01:43:04.920 --> 01:43:07.920]  Да, опять забыл.
[01:43:08.920 --> 01:43:16.920]  Переменная, в которой мы будем сохранять сумму, sum плюс равно FTI.
[01:43:19.920 --> 01:43:21.920]  Return sum.
[01:43:22.920 --> 01:43:23.920]  Сколько там?
[01:43:24.920 --> 01:43:25.920]  В пять минут вкладываешь?
[01:43:26.920 --> 01:43:27.920]  Так, давайте последний.
[01:43:28.920 --> 01:43:29.920]  Query на отрезке от L до R.
[01:43:30.920 --> 01:43:38.920]  Просто return q от R минус q от R.
[01:43:39.920 --> 01:43:40.920]  Время.
[01:43:41.920 --> 01:43:42.920]  Все.
[01:43:43.920 --> 01:43:44.920]  А вот это все дерево Фенлика.
[01:43:45.920 --> 01:43:46.920]  Все.
[01:43:47.920 --> 01:43:50.920]  Ну хорошо, там еще есть построение, но в принципе построение как может выглядеть?
[01:43:51.920 --> 01:43:56.920]  То есть если вам в лом писать то построение, то вы можете построить построение как просто апдейты.
[01:43:56.920 --> 01:44:00.920]  Просто апдейт ноль, апдейт один, апдейт два, апдейт три и так далее.
[01:44:02.920 --> 01:44:04.920]  Вот это весь код дерева Фенлика вообще.
[01:44:05.920 --> 01:44:06.920]  Где?
[01:44:07.920 --> 01:44:08.920]  Блин, ладно.
[01:44:09.920 --> 01:44:11.920]  Ну ладно, со штрафом сдал, все.
[01:44:14.920 --> 01:44:15.920]  Ладно, давайте проверим баги.
[01:44:16.920 --> 01:44:17.920]  Первый член тк.
[01:44:18.920 --> 01:44:20.920]  Следующий член последовательности получаю вот так.
[01:44:21.920 --> 01:44:24.920]  Значит i член массива FTI увеличиваю здесь.
[01:44:24.920 --> 01:44:30.920]  Дальше беру R, считаю FTI, дальше перехожу к этому элементу.
[01:44:31.920 --> 01:44:32.920]  Ну кажется не набагал.
[01:44:33.920 --> 01:44:34.920]  Все нормально.
[01:44:36.920 --> 01:44:39.920]  Значит про этот кьюри мы поговорили, он работает за log n.
[01:44:40.920 --> 01:44:45.920]  Соответственно этот кьюри тоже работает за log n.
[01:44:46.920 --> 01:44:47.920]  Абдейт.
[01:44:48.920 --> 01:44:49.920]  За сколько работает апдейт?
[01:44:54.920 --> 01:44:55.920]  За логарифм.
[01:44:55.920 --> 01:44:56.920]  А почему за логарифм?
[01:45:01.920 --> 01:45:02.920]  Да, да.
[01:45:03.920 --> 01:45:04.920]  Что делает эта функция?
[01:45:05.920 --> 01:45:06.920]  Она просто завершит последний ноль, самый младший ноль,
[01:45:07.920 --> 01:45:08.920]  и заменяет его на единицу.
[01:45:09.920 --> 01:45:10.920]  Сколько раз я могу добавить единицу?
[01:45:11.920 --> 01:45:12.920]  Ну не больше, чем логарифм n раз.
[01:45:13.920 --> 01:45:15.920]  Потому что если я добавлю больше, чем n раз, то логарифм n раз,
[01:45:16.920 --> 01:45:17.920]  то я выйду за границу массива.
[01:45:24.920 --> 01:45:25.920]  Это тоже логарифм.
[01:45:30.920 --> 01:45:31.920]  Вот такая история.
[01:45:38.920 --> 01:45:39.920]  Вот это?
[01:45:40.920 --> 01:45:41.920]  А почему нет?
[01:45:42.920 --> 01:45:43.920]  Вы верите, вот это работает за логарифм?
[01:45:44.920 --> 01:45:45.920]  Следовательно, вот это логарифм, вот это логарифм.
[01:45:52.920 --> 01:45:53.920]  Так.
[01:45:55.920 --> 01:45:56.920]  Вопросы есть?
[01:45:59.920 --> 01:46:01.920]  Ну и давайте итог промежуточный подведем.
[01:46:03.920 --> 01:46:04.920]  В общем, дерево фенвик, оно крутое.
[01:46:05.920 --> 01:46:09.920]  И оно крутое тем, что его очень быстро писать,
[01:46:11.920 --> 01:46:17.920]  и оно умеет выполнять обновления в точке.
[01:46:18.920 --> 01:46:22.920]  Ну по сравнению с массивом префиксных сумм.
[01:46:24.920 --> 01:46:25.920]  Итак, итог.
[01:46:28.920 --> 01:46:29.920]  Временно при процессинг.
[01:46:31.920 --> 01:46:33.920]  За сколько мы можем построить дерево фенвика?
[01:46:37.920 --> 01:46:38.920]  За сколько?
[01:46:39.920 --> 01:46:40.920]  За o от n.
[01:46:41.920 --> 01:46:42.920]  Ну за log n мы не можем построить,
[01:46:43.920 --> 01:46:44.920]  потому что у нас всего элементов n.
[01:46:45.920 --> 01:46:48.920]  Построение за o от n вот с помощью вот такой функции.
[01:46:50.920 --> 01:46:51.920]  Ну либо, давайте напишем,
[01:46:51.920 --> 01:46:55.920]  либо n log n,
[01:46:58.920 --> 01:47:00.920]  ну если используем следующий код,
[01:47:01.920 --> 01:47:04.920]  for i равно 0, to n-1,
[01:47:08.920 --> 01:47:09.920]  update i.
[01:47:12.920 --> 01:47:13.920]  В принципе, если в лом писать то,
[01:47:14.920 --> 01:47:15.920]  то можно написать вот так.
[01:47:16.920 --> 01:47:17.920]  Это будет работать тогда за n log n.
[01:47:18.920 --> 01:47:19.920]  Окей?
[01:47:20.920 --> 01:47:21.920]  Ну то есть, понятное дело,
[01:47:22.920 --> 01:47:24.920]  инициализируем массив нулями изначально.
[01:47:28.920 --> 01:47:30.920]  Изначально зануляем массив,
[01:47:32.920 --> 01:47:35.920]  а потом просто последовательно каждому элементу добавляем ai.
[01:47:38.920 --> 01:47:40.920]  Ну и запрос, причем неважно какой,
[01:47:41.920 --> 01:47:43.920]  запрос на обновление, запрос на сумму
[01:47:44.920 --> 01:47:47.920]  выполняется за o.
[01:47:49.920 --> 01:47:50.920]  O от log n.
[01:47:53.920 --> 01:47:54.920]  Так, давайте немного отдохнем от кода,
[01:47:55.920 --> 01:47:58.920]  немного отдохнем от кода и от формул,
[01:47:59.920 --> 01:48:02.920]  и просто приведем, скажем, пример работы операции
[01:48:03.920 --> 01:48:05.920]  на дереве Фенвика, ну чтобы как бы убедиться,
[01:48:06.920 --> 01:48:07.920]  что все понимают, как все устроено,
[01:48:08.920 --> 01:48:09.920]  как это работает и так далее.
[01:48:10.920 --> 01:48:13.920]  Давайте, похоже на поле чудес, но нет,
[01:48:14.920 --> 01:48:17.920]  давайте загадаем числа какие-нибудь,
[01:48:17.920 --> 01:48:20.920]  чтобы можно было над ними операции какие-то проводить.
[01:48:21.920 --> 01:48:22.920]  Давайте заполним массив a.
[01:48:24.920 --> 01:48:25.920]  Я жду.
[01:48:26.920 --> 01:48:27.920]  15,
[01:48:28.920 --> 01:48:29.920]  4,
[01:48:31.920 --> 01:48:32.920]  минус 7,
[01:48:33.920 --> 01:48:34.920]  нет,
[01:48:35.920 --> 01:48:36.920]  49 просто,
[01:48:37.920 --> 01:48:39.920]  49, 3, что еще?
[01:48:40.920 --> 01:48:41.920]  Ноль, нормально.
[01:48:42.920 --> 01:48:43.920]  17,
[01:48:44.920 --> 01:48:45.920]  25,
[01:48:45.920 --> 01:48:46.920]  11,
[01:48:47.920 --> 01:48:48.920]  1,
[01:48:49.920 --> 01:48:50.920]  нормально.
[01:48:51.920 --> 01:48:53.920]  Ну и заполним массив дерева Фенвика.
[01:48:54.920 --> 01:48:56.920]  Я сразу тут записал индексы в двоичном формате,
[01:48:57.920 --> 01:48:58.920]  чтобы было удобнее.
[01:48:59.920 --> 01:49:00.920]  В дереве Фенвика с индексом ноль, что хранится?
[01:49:01.920 --> 01:49:03.920]  В нем хранится сумма с верхней границей ноль,
[01:49:04.920 --> 01:49:06.920]  и с нижней границей убираем все последние единицы,
[01:49:07.920 --> 01:49:08.920]  соответственно только 15 остается, да?
[01:49:09.920 --> 01:49:11.920]  То есть сумма от нуля до нуля.
[01:49:12.920 --> 01:49:13.920]  Здесь,
[01:49:13.920 --> 01:49:15.920]  здесь хранится сумма с первого элемента
[01:49:16.920 --> 01:49:17.920]  по элементу,
[01:49:18.920 --> 01:49:20.920]  у которого все последние единицы за нулены.
[01:49:21.920 --> 01:49:22.920]  То есть,
[01:49:23.920 --> 01:49:24.920]  с нулевого по первой, согласны?
[01:49:25.920 --> 01:49:26.920]  То есть 19.
[01:49:27.920 --> 01:49:29.920]  Здесь хранится сумма всех элементов
[01:49:30.920 --> 01:49:32.920]  с 2, ну то есть с 1, 0,
[01:49:33.920 --> 01:49:35.920]  до элемента, у которого все последние единицы за нулены.
[01:49:36.920 --> 01:49:37.920]  Ну это то же самое число, да, то есть,
[01:49:38.920 --> 01:49:39.920]  от 2 до 2,
[01:49:40.920 --> 01:49:41.920]  минус 7.
[01:49:41.920 --> 01:49:42.920]  Что хранится здесь?
[01:49:43.920 --> 01:49:44.920]  Здесь хранится сумма
[01:49:45.920 --> 01:49:47.920]  от элемента с индексом 3,
[01:49:48.920 --> 01:49:49.920]  ну то есть 1, 1,
[01:49:50.920 --> 01:49:52.920]  до элемента, у которого все последние единицы за нулены,
[01:49:53.920 --> 01:49:54.920]  то есть ноль.
[01:49:55.920 --> 01:49:56.920]  То есть все единицы убираем, остается ноль.
[01:49:59.920 --> 01:50:02.920]  42, 46, 61, да?
[01:50:03.920 --> 01:50:05.920]  Так, здесь, здесь хранится сумма
[01:50:06.920 --> 01:50:08.920]  от 4 до 4.
[01:50:09.920 --> 01:50:10.920]  Тоже понятно, да?
[01:50:11.920 --> 01:50:12.920]  Здесь тоже последние единицы,
[01:50:13.920 --> 01:50:14.920]  никаких единиц нет, поэтому
[01:50:15.920 --> 01:50:16.920]  сумма от этого элемента до него самого,
[01:50:17.920 --> 01:50:18.920]  то есть 3.
[01:50:19.920 --> 01:50:20.920]  Дальше, берем этот элемент,
[01:50:21.920 --> 01:50:23.920]  1, 0, 1, то есть это 5,
[01:50:24.920 --> 01:50:26.920]  и нижняя граница убираем последние единицы,
[01:50:27.920 --> 01:50:28.920]  то есть 4.
[01:50:29.920 --> 01:50:30.920]  То есть ноль плюс 3, 3.
[01:50:31.920 --> 01:50:32.920]  Дальше, здесь
[01:50:33.920 --> 01:50:34.920]  тоже последние единицы знулять не надо,
[01:50:35.920 --> 01:50:37.920]  поэтому тут просто 6, 6, да?
[01:50:38.920 --> 01:50:39.920]  17.
[01:50:39.920 --> 01:50:40.920]  Ну и на самом деле легко заметить,
[01:50:41.920 --> 01:50:42.920]  что для всех четных это выполняется.
[01:50:45.920 --> 01:50:46.920]  То есть для всех четных у меня
[01:50:47.920 --> 01:50:49.920]  в дереве Фенвика соответствующие ячейки хранится,
[01:50:50.920 --> 01:50:51.920]  ну просто-напросто это самое число.
[01:50:52.920 --> 01:50:53.920]  А здесь, здесь что у меня хранится?
[01:50:54.920 --> 01:50:56.920]  Здесь у меня хранится все значения от 8 до нуля.
[01:50:57.920 --> 01:50:58.920]  Да, почему?
[01:50:59.920 --> 01:51:00.920]  От семерки, простите.
[01:51:01.920 --> 01:51:02.920]  Потому что 3 единиц это 7,
[01:51:03.920 --> 01:51:04.920]  убираю все последние единицы, остается ноль,
[01:51:05.920 --> 01:51:07.920]  поэтому тут лежит сумма с нулевого по седьмой элемент.
[01:51:07.920 --> 01:51:08.920]  Сколько?
[01:51:09.920 --> 01:51:10.920]  Отлично.
[01:51:11.920 --> 01:51:12.920]  Поверим?
[01:51:13.920 --> 01:51:14.920]  Ну ладно.
[01:51:15.920 --> 01:51:16.920]  103.
[01:51:17.920 --> 01:51:18.920]  Если что, это не я.
[01:51:19.920 --> 01:51:20.920]  Дальше.
[01:51:21.920 --> 01:51:23.920]  Ну и здесь просто-напросто с девятки
[01:51:24.920 --> 01:51:26.920]  убираем последнюю единицу в 8.
[01:51:27.920 --> 01:51:28.920]  То есть 12.
[01:51:30.920 --> 01:51:33.920]  Все, то есть дерево Фенвика представляет из себя вот такой массив.
[01:51:34.920 --> 01:51:35.920]  Вот.
[01:51:35.920 --> 01:51:36.920]  А я чувствую.
[01:51:37.920 --> 01:51:38.920]  Отлично.
[01:51:39.920 --> 01:51:42.920]  Так, а теперь давайте попробуем выполнять какие-то запросы.
[01:51:43.920 --> 01:51:45.920]  Давайте какую-нибудь пару запросов рассмотрим.
[01:51:46.920 --> 01:51:49.920]  Ну давайте, какие-нибудь два произвольных числа.
[01:51:50.920 --> 01:51:52.920]  Два произвольных индекса.
[01:51:53.920 --> 01:51:54.920]  Стройки по четверку.
[01:51:55.920 --> 01:51:56.920]  Отлично.
[01:51:57.920 --> 01:51:58.920]  Стройки по четверку.
[01:51:59.920 --> 01:52:03.920]  Значит это все мы раскладываем в виде запроса от четверки.
[01:52:03.920 --> 01:52:10.920]  Да, то есть давайте сразу представим это в двоичном виде.
[01:52:11.920 --> 01:52:12.920]  Что такое кьюри от четверки?
[01:52:13.920 --> 01:52:14.920]  Как вычисляется кьюри от четверки?
[01:52:15.920 --> 01:52:19.920]  Мы берем Ft от четверки.
[01:52:20.920 --> 01:52:21.920]  Что это?
[01:52:22.920 --> 01:52:24.920]  Ft от четверки 0, 1, 2, 3, 4.
[01:52:25.920 --> 01:52:26.920]  Это 3.
[01:52:27.920 --> 01:52:28.920]  Дальше мы берем Ft от...
[01:52:29.920 --> 01:52:30.920]  Убираем последнюю единицу.
[01:52:31.920 --> 01:52:32.920]  Сейчас, нет.
[01:52:33.920 --> 01:52:34.920]  Как выглядит формула?
[01:52:35.920 --> 01:52:36.920]  Мы берем 1, 0, 0.
[01:52:37.920 --> 01:52:38.920]  Андимся 1, 0, 1.
[01:52:39.920 --> 01:52:41.920]  0, 0, 1.
[01:52:42.920 --> 01:52:43.920]  И вычитаем единицу.
[01:52:44.920 --> 01:52:45.920]  Получается 1, 1.
[01:52:46.920 --> 01:52:47.920]  То есть 3.
[01:52:48.920 --> 01:52:50.920]  Ft от тройки 0, 1, 2, 3.
[01:52:51.920 --> 01:52:52.920]  Это 61.
[01:52:55.920 --> 01:52:56.920]  Ну и все.
[01:52:57.920 --> 01:52:58.920]  Да?
[01:52:59.920 --> 01:53:00.920]  Еще раз, что мы сделали?
[01:53:01.920 --> 01:53:02.920]  Мы обратились Ft от четверки.
[01:53:03.920 --> 01:53:04.920]  Мы ее записали здесь.
[01:53:05.920 --> 01:53:06.920]  Дальше обратились сюда.
[01:53:07.920 --> 01:53:08.920]  Здесь хранится сумма от 0 до 3.
[01:53:09.920 --> 01:53:10.920]  Все, значит, все элементы мы покрыли таким образом.
[01:53:11.920 --> 01:53:12.920]  Все, в итоге 64.
[01:53:13.920 --> 01:53:14.920]  Но это только полдела.
[01:53:15.920 --> 01:53:16.920]  Теперь давайте кьюри от тройки посчитаем.
[01:53:17.920 --> 01:53:19.920]  Ну а кьюри от тройки мы, кажется, уже посчитали, да?
[01:53:22.920 --> 01:53:25.920]  Кьюри от тройки это просто-напросто Ft от тройки.
[01:53:26.920 --> 01:53:28.920]  Ну, то есть 61.
[01:53:31.920 --> 01:53:32.920]  Да, то есть 61.
[01:53:34.920 --> 01:53:35.920]  Сейчас.
[01:53:36.920 --> 01:53:37.920]  Нам нужно кьюри от двойки.
[01:53:42.920 --> 01:53:43.920]  Понятно почему кьюри от двойки?
[01:53:44.920 --> 01:53:47.920]  Мы хотим найти сумму от третьего 0, 1, 2, 3.
[01:53:49.920 --> 01:53:50.920]  От третьего до четвертого.
[01:53:51.920 --> 01:53:53.920]  То есть нам нужно посчитать сумму вот здесь и вычесть сумму вот здесь.
[01:53:54.920 --> 01:53:55.920]  То есть кьюри от двойки.
[01:53:57.920 --> 01:53:58.920]  Ft от двойки.
[01:53:59.920 --> 01:54:01.920]  Ft от двойки это минус 7.
[01:54:03.920 --> 01:54:04.920]  Вот.
[01:54:05.920 --> 01:54:06.920]  То есть здесь хранится значение от 2 до 2.
[01:54:07.920 --> 01:54:08.920]  Поэтому переходим сюда.
[01:54:09.920 --> 01:54:10.920]  Тут хранится значение от 0 до 1.
[01:54:11.920 --> 01:54:12.920]  То есть то, что нам нужно.
[01:54:13.920 --> 01:54:14.920]  Поэтому считаем Ft от единицы.
[01:54:15.920 --> 01:54:16.920]  Получаем 19.
[01:54:17.920 --> 01:54:21.920]  В итоге сумма равна здесь 12, а здесь 64.
[01:54:22.920 --> 01:54:23.920]  Ну и осталось вычесть.
[01:54:24.920 --> 01:54:25.920]  Да.
[01:54:26.920 --> 01:54:33.920]  В кьюри от 4 минус кьюри от 2 равно 52.
[01:54:34.920 --> 01:54:35.920]  Сошлось?
[01:54:41.920 --> 01:54:42.920]  Сошлось, нет?
[01:54:43.920 --> 01:54:44.920]  Отлично.
[01:54:45.920 --> 01:54:46.920]  Так, хорошо.
[01:54:47.920 --> 01:54:48.920]  Давайте дальше.
[01:54:51.920 --> 01:54:52.920]  Сейчас.
[01:54:53.920 --> 01:54:54.920]  Да, все нормально.
[01:54:55.920 --> 01:54:56.920]  Я сюда смотрел.
[01:54:57.920 --> 01:54:58.920]  Да, все.
[01:54:59.920 --> 01:55:00.920]  Значит кьюри от 3 до 4.
[01:55:01.920 --> 01:55:02.920]  49 плюс 3.
[01:55:03.920 --> 01:55:04.920]  52.
[01:55:05.920 --> 01:55:06.920]  Еще кьюри или апдейт?
[01:55:07.920 --> 01:55:08.920]  Да, давайте апдейт.
[01:55:09.920 --> 01:55:10.920]  Какой апдейт?
[01:55:11.920 --> 01:55:12.920]  Какой элемент хотим изменить?
[01:55:13.920 --> 01:55:14.920]  Вот этот?
[01:55:15.920 --> 01:55:16.920]  На что?
[01:55:17.920 --> 01:55:18.920]  На 57.
[01:55:19.920 --> 01:55:20.920]  Ну давайте как обозначим?
[01:55:20.920 --> 01:55:21.920]  Пишем 57.
[01:55:25.920 --> 01:55:30.920]  То есть пишем апдейт в точке 2 на...
[01:55:31.920 --> 01:55:32.920]  Вот тут надо...
[01:55:33.920 --> 01:55:34.920]  То есть если мы хотим изменить минус 7 на 57...
[01:55:35.920 --> 01:55:36.920]  Сейчас, что вы имели в виду на 57?
[01:55:37.920 --> 01:55:38.920]  Мы хотим заменить его на 57 или прибавить 57?
[01:55:39.920 --> 01:55:40.920]  Заменить.
[01:55:41.920 --> 01:55:42.920]  Значит мы должны прибавить 64.
[01:55:43.920 --> 01:55:44.920]  Вот.
[01:55:45.920 --> 01:55:46.920]  То есть апдейт выглядит как плюс равно.
[01:55:47.920 --> 01:55:49.920]  То есть мы в точке делаем именно плюс равно, а не присваивание.
[01:55:50.920 --> 01:55:51.920]  Так.
[01:55:52.920 --> 01:55:53.920]  Что такое апдейт?
[01:55:54.920 --> 01:55:57.920]  Апдейт это значит нам нужно найти все эти ft, на которые влияет этот элемент.
[01:55:58.920 --> 01:56:00.920]  Ну соответственно и 0 это что у нас?
[01:56:01.920 --> 01:56:02.920]  Это 2.
[01:56:03.920 --> 01:56:07.920]  И 1 это и 0 или и 0 плюс 1.
[01:56:08.920 --> 01:56:11.920]  То есть если 2 это 1, 0.
[01:56:12.920 --> 01:56:13.920]  Убираем последнюю единицу.
[01:56:14.920 --> 01:56:15.920]  Ну то есть 0.
[01:56:16.920 --> 01:56:17.920]  Сейчас.
[01:56:18.920 --> 01:56:19.920]  1, 1.
[01:56:20.920 --> 01:56:21.920]  1, 1 просто.
[01:56:22.920 --> 01:56:23.920]  Да?
[01:56:24.920 --> 01:56:25.920]  Дальше.
[01:56:26.920 --> 01:56:29.920]  И 2 это и 1 или и 1 плюс 1.
[01:56:30.920 --> 01:56:31.920]  То есть 1, 1, 1.
[01:56:32.920 --> 01:56:33.920]  3.
[01:56:34.920 --> 01:56:35.920]  7.
[01:56:36.920 --> 01:56:38.920]  Следующую единицу не добавляем, потому что выходим за границы.
[01:56:39.920 --> 01:56:40.920]  Поэтому вот.
[01:56:41.920 --> 01:56:42.920]  Вот эти три индекса, которые нам нужно обновить.
[01:56:43.920 --> 01:56:45.920]  Ну давайте попробуем понять, действительно мы сделали то, что нужно или нет.
[01:56:45.920 --> 01:56:53.920]  Значит какие у нас элементы дерева Фенвика отвечают за, точнее в какие элементы дерева Фенвика входит индекс 2?
[01:56:54.920 --> 01:56:55.920]  Значит вот сюда.
[01:56:56.920 --> 01:56:57.920]  То есть это 2 есть сюда.
[01:56:58.920 --> 01:56:59.920]  То есть это 3 есть.
[01:57:00.920 --> 01:57:01.920]  Дальше, дальше, дальше здесь.
[01:57:02.920 --> 01:57:03.920]  Это 7.
[01:57:04.920 --> 01:57:05.920]  Есть и все.
[01:57:06.920 --> 01:57:07.920]  То есть все индексы нашли правильно.
[01:57:08.920 --> 01:57:10.920]  Ну все осталось только все вот эти элементы, которые нашли, обновить.
[01:57:11.920 --> 01:57:12.920]  Вот собственно как здесь и написано.
[01:57:12.920 --> 01:57:16.920]  Все эти элементы, все эти элементы мы нашли, осталось их только обновить на плюс равно дельту.
[01:57:17.920 --> 01:57:18.920]  А дельта у нас 64.
[01:57:19.920 --> 01:57:22.920]  Ну то есть здесь 57.
[01:57:23.920 --> 01:57:24.920]  Дальше.
[01:57:25.920 --> 01:57:28.920]  Здесь плюс 64 это 125.
[01:57:29.920 --> 01:57:35.920]  И здесь 64 плюс 106, 170.
[01:57:36.920 --> 01:57:37.920]  Ну вот.
[01:57:42.920 --> 01:57:43.920]  Похоже на правду?
[01:57:44.920 --> 01:57:45.920]  Ну давайте проверим.
[01:57:46.920 --> 01:57:47.920]  Допустим, допустим здесь.
[01:57:48.920 --> 01:57:50.920]  Верно лишь, что сумма всех значений от 0 до 3 это 125.
[01:57:51.920 --> 01:58:01.920]  15, 19, 67, 76, плюс 49, 119, 125.
[01:58:02.920 --> 01:58:03.920]  Все нормально.
[01:58:04.920 --> 01:58:05.920]  Окей?
[01:58:06.920 --> 01:58:07.920]  Ну вот.
[01:58:07.920 --> 01:58:11.920]  Дерево Фенвика оно по сути таким образом разбивает все отрезки на логарифмическое...
[01:58:12.920 --> 01:58:14.920]  То есть каждую сумму разбивает на логарифмическое.
[01:58:14.920 --> 01:58:18.920]  То есть, во-первых, оно разбивает каждую сумму на логарифмическое число под сумм,
[01:58:18.920 --> 01:58:21.920]  а во-вторых, каждая, а во-вторых, каждая из элементов,
[01:58:21.920 --> 01:58:23.840]  что самое главное, каждая из элементов,
[01:58:23.840 --> 01:58:28.920]  входит всего лишь в логарифмическое число элементов дерева Фенвика.
[01:58:29.920 --> 01:58:33.920]  То есть, чтобы собрать сумму на подотрезке, достаточно обратить внимание.
[01:58:33.920 --> 01:58:38.120]  дерева фенвика. То есть чтобы собрать сумму на подотреске, достаточно обратиться к
[01:58:38.120 --> 01:58:41.280]  логарифмическому числу здесь, и чтобы вновить элемент здесь, достаточно обратиться к
[01:58:41.280 --> 01:58:47.680]  логарифмическому числу объектов здесь. Все отлично. Нужен еще какой-нибудь пример, или достаточно?
[01:58:47.680 --> 01:58:59.200]  Ну, значит достаточно, окей. Так, следующий пункт, короткий. Это, мы когда говорили про
[01:58:59.200 --> 01:59:05.280]  разреженную таблицу и про массив префикса суммы, говорили, что там нужно как бы вести
[01:59:05.280 --> 01:59:09.480]  некоторую двумерную структуру. То есть если мы хотим обобщить на многомерный случай, то там
[01:59:09.480 --> 01:59:15.560]  нужно как бы обобщить все на, ну скажем, завести двумерную таблицу, двумерную разреженную таблицу
[01:59:15.560 --> 01:59:22.360]  и так далее. В общем, там как-то хитрым образом снова вычислять значения в соответствующих
[01:59:22.360 --> 01:59:28.440]  ячейках. Еще одна классная вещь, которая связана с деревом фенвика, состоит в том, что дерево
[01:59:28.440 --> 01:59:34.640]  фенвика очень просто обобщается на многомерный случай. То есть буквально, чтобы написать дерево
[01:59:34.640 --> 01:59:40.600]  фенвика для двумерного случая, мне достаточно изменить, точнее дописать здесь три строчки. Давайте
[01:59:40.600 --> 02:00:02.320]  поймем как. Обобщение на многомерный случай. Ну идея такая же. Если мне нужно посчитать
[02:00:02.320 --> 02:00:19.240]  сумму от i равная нулю, ну скажем давайте до х, сумма по g от нуля до y, а и g, то это все разбивается на вот
[02:00:19.240 --> 02:00:36.920]  такие вот маленькие суммы. То есть это сумма по i равная f от x, от x сумма по g равная f от y, y, а и g, ну и так далее.
[02:00:36.920 --> 02:00:47.400]  Ну а это не что иное, как значение дерева фенвика в точке x, y. Вот, и при этом все вот эти вот нижние
[02:00:47.400 --> 02:00:51.840]  индексы, они получаются ровно по той же самой формуле. Вот, поэтому если я хочу написать, например, запрос,
[02:00:51.840 --> 02:01:02.240]  давайте напишем запрос, для двумерного дерева фенвика, то как это выглядит? Я пишу кьюри от x, y, ну то есть я хочу
[02:01:02.240 --> 02:01:15.440]  посчитать сумму, что такое кьюри от x, y? Значит, я хочу посчитать сумму вот здесь. Я хочу посчитать сумму в
[02:01:15.480 --> 02:01:22.760]  прямоугольнике, у которого левый угол находится в точке 0, 0, а правый нижний угол в точке x, y. Тогда кьюри от x, y
[02:01:22.760 --> 02:01:40.920]  выглядит вот так. Просто for i равно x, i больше либо равно нуля, i равно i plus 1, minus 1. Дальше внутренний цикл for g
[02:01:40.920 --> 02:01:58.280]  равно y, g больше либо равно нуля, g равно g plus 1, minus 1. Снова забыл сумму, отлично, sum равно нулю, sum
[02:01:58.280 --> 02:02:18.280]  плюс равно ft от i g. Return sum. Все. Ну как и раньше, потому что вот этот элемент дерева фенвика у меня считает
[02:02:18.280 --> 02:02:28.600]  сумму от x до f от x, поэтому следующий элемент суммы должен начинаться с f от x минус 1. Да, ну то есть
[02:02:28.600 --> 02:02:37.160]  заметьте, f минус 1 всегда была, то есть и здесь, а здесь ее нет. Ну то есть чтобы обобщить дерево
[02:02:37.160 --> 02:02:41.880]  фенвика на двумерный случай, мне достаточно всего лишь добавить один цикл, ну и одну размерность у дерева
[02:02:41.880 --> 02:02:49.920]  фенвика. Все. Хотите подумать над тем, что он сделал, чтобы обобщить его на трехмерный случай? Добавляйте
[02:02:49.920 --> 02:02:57.480]  и да, добавляйте еще один цикл вот точно такого же рода. Чуть сложнее выглядит, если вы хотите
[02:02:57.480 --> 02:03:21.600]  посчитать запрос на, если вы хотите посчитать запрос не на вот таком префексе, а скажем вот на такой, ну давайте вот так, x, y, a, b. Вот если вы хотите
[02:03:21.600 --> 02:03:25.200]  посчитать сумму вот на таком прямоугольнике, то снова придется воспользоваться формулой включения
[02:03:25.200 --> 02:03:34.080]  исключений. Да, ну то есть понимаете. Давайте еще раз напишем, лишнего не будет, значит это то же самое,
[02:03:34.080 --> 02:03:41.480]  что кьюери на прямоугольнике x, y, вот на таком большом треугольнике x, y. Дальше я должен вычесть сумму
[02:03:41.480 --> 02:04:02.600]  вот здесь. Это что у нас? Это минус q, x, b-1. Минус, должен вычесть сумму вот здесь. Это q, так почему x, y? Потому что x, y, x, b-1, да и тут
[02:04:02.600 --> 02:04:19.000]  a-1, y и плюс q, да и плюс вот этот вот маленький квадратик, я вычел два раза. То есть прибавил один раз и вычел два раза, поэтому мне нужно, чтобы выйти в ноль, нужно прибавить его еще раз.
[02:04:19.000 --> 02:04:42.000]  Вот. То есть q от a-1, b-1. Ну вот. Ну в трехмерном случае, соответственно, тут будет 8 слагаемых, то есть подумать, как в кубе выделить нужный параллелепипед.
[02:04:42.000 --> 02:04:53.000]  Вот. Ну тоже самая форма включения и исключения. То есть это на самом деле можно обобщить на произвольную размерность. Вот. Ну и апдейт. А с апдейтом, ну давайте не будем останавливаться тоже долго.
[02:04:53.000 --> 02:05:11.000]  Апдейт тоже понятно. То есть для апдейта тоже добавляете еще один цикл, ну наподобие того, что был написан там, и получаете апдейт для двумерного случая. То есть если вы хотите обновить в двумерной таблице какой-то один элемент, то вы передаете ему два индекса
[02:05:11.000 --> 02:05:26.000]  и проходите по одному индексу вот так, по второму индексу вот так, и внутри изменяете элемент ft и g. Все. Рассуждения абсолютно точно такие же. То есть дерево фенвика, оно позволяет очень легко обобщать себя на произвольной размерности.
[02:05:26.000 --> 02:05:47.000]  Вот. Поэтому для задачи динамика rsq дерево фенвика это вот то, что нужно и быстро, и эффективно. Ну и в качестве последнего пункта давайте рассмотрим некоторое обобщение дерева фенвика, точнее не обобщение, а некоторое улучшение дерева фенвика.
[02:05:47.000 --> 02:06:05.000]  Попробуем добавить ему некоторый новый функционал. Ну смотрите, прибавление в точке, конечно, хорошо. То есть вот у вас есть массив, вы можете обрабатывать запросы, найти сумму на произвольном отрезке, и плюс можете обновлять произвольный элемент.
[02:06:05.000 --> 02:06:14.000]  Вот. Но часто бывает такая ситуация, что вам нужно обновить значение не только в одной точке, то есть не просто в одной точке, а нужно, скажем, обновить сразу группу элементов.
[02:06:14.000 --> 02:06:27.000]  Скажем, вам нужно обновить все элементы с третьего по шестой. Ну точнее так, взять элементы с третьего по шестой и всем им прибавить, скажем, единицу, или всем им прибавить 17, и так далее.
[02:06:27.000 --> 02:06:39.000]  Значит, подробнее про то, как обрабатываются такие запросы мы поговорим в следующий раз, то есть в следующий раз мы будем говорить про групповые обновления, то есть что делать, если вам нужно обновлять на целых отрезках и так далее.
[02:06:39.000 --> 02:06:45.000]  Сегодня я расскажу просто небольшой трюк, какой-то подвид этой задачи можно сделать с помощью дерева Фенлика.
[02:06:45.000 --> 02:07:12.000]  Значит, задача научить дерева Фенлика выполнять операцию прибавления на отрезке.
[02:07:15.000 --> 02:07:25.000]  Ну, как это сделать в тупую, на самом деле понятно. То есть если вам нужно обновить все значения на отрезке, то вы просто обновляете этот элемент, этот элемент, этот элемент, этот элемент.
[02:07:25.000 --> 02:07:40.000]  Работает за калоген, где k – это размер под отрезок, который вам нужно улучшить. Можно ли лучше? На самом деле можно. Можно, если воспользоваться следующим трюком.
[02:07:40.000 --> 02:07:56.000]  Давайте рассмотрим, нам дан массив А, а мы перейдем к другому массиву.
[02:07:56.000 --> 02:08:06.000]  Будем рассматривать не исходный массив А, а возьмем массив В, который имеет следующий вид.
[02:08:06.000 --> 02:08:24.000]  А0, А1-А0, А2-А1 и так далее, An-1-An-2.
[02:08:24.000 --> 02:08:34.000]  То есть просто почитаем по парной разности всех элементов А и запишем в массив В.
[02:08:34.000 --> 02:08:43.000]  Для чего это нужно? Смотрите, ключевой вопрос зачем.
[02:08:43.000 --> 02:09:05.000]  А затем прибавим, прибавим, прибавим дельту, давайте так, прибавим, прибавим дельту на префиксе от 0 до r.
[02:09:05.000 --> 02:09:25.000]  Не так, на суффиксе. Вот у меня есть массив А.
[02:09:25.000 --> 02:09:31.000]  Давайте я покажу, как прибавлять дельту на суффиксе, то есть на концевой части массива.
[02:09:31.000 --> 02:09:38.000]  Согласны ли вы, что если я умею эффективно добавлять дельту на суффиксе, то я могу добавлять дельту на произвольном подотреске.
[02:09:38.000 --> 02:09:46.000]  Почему? Потому что если я хочу прибавить дельту сюда, то я могу прибавить дельту вот на этом отрезке и вычесть дельту отсюда.
[02:09:46.000 --> 02:09:53.000]  Тоже самый трюк. Хочу прибавить дельту здесь, для этого мне нужно прибавить дельту здесь и вычесть дельту здесь.
[02:09:53.000 --> 02:10:03.000]  Поэтому давайте посмотрим, что у меня происходит с массивом B, когда я прибавляю дельту на суффиксе от r до n-1.
[02:10:03.000 --> 02:10:17.000]  А происходит вот что. А 0 меняется? Не меняется. А 1-0 меняется? Не меняется.
[02:10:17.000 --> 02:10:22.000]  Какой первый элемент у меня изменится в этом массиве?
[02:10:22.000 --> 02:10:34.000]  Да. ar-ar-1. Он увеличится на дельту. Согласны? Ну, r-1 у меня не изменился, а r у меня увеличился на дельту.
[02:10:34.000 --> 02:10:40.000]  Как у меня изменится ar-1-ar? А вот никак.
[02:10:40.000 --> 02:10:46.000]  Потому что если я дельту прибавляю на суффиксе, то эта дельта у меня прибавляется как к k-r, так и к k-r-1.
[02:10:46.000 --> 02:10:57.000]  И так далее. То есть an-1-an-2 тоже не меняется, потому что на дельту у меня изменился как этот элемент, так и этот элемент.
[02:10:57.000 --> 02:11:04.000]  Понимаете, к чему я клоню? Я клоню к тому, что если я прибавляю дельту на всем подотреске, на всем суффиксе массива A,
[02:11:04.000 --> 02:11:10.000]  то это то же самое, как если бы в массив D использовать обновление всего лишь одного элемента.
[02:11:10.000 --> 02:11:15.000]  То есть я свел задачу обновления на суффиксе к задаче обновления на одном элементе.
[02:11:15.000 --> 02:11:21.000]  Но правда в каком-то другом массиве B.
[02:11:21.000 --> 02:11:33.000]  Все понятно? Ну и давайте посмотрим, как с этим массивом B работать.
[02:11:33.000 --> 02:11:43.000]  Допустим, мне нужно найти сумму на вот таком префиксе, i от 0 до r, ai.
[02:11:43.000 --> 02:11:52.000]  Как бы мне переписать эту сумму в терминах массива B? То есть массива A у меня нет, у меня есть только массив B.
[02:11:52.000 --> 02:11:58.000]  Вот как мне расписать эту сумму? Ну очень просто, i от 0 до r.
[02:11:58.000 --> 02:12:05.000]  А что такое ai? Как получить ai из массива B?
[02:12:05.000 --> 02:12:12.000]  Ну я утверждаю на самом деле, что эта сумма от k равна 0 до i.
[02:12:12.000 --> 02:12:19.000]  Вот эта штука это в точности ai. Согласны?
[02:12:19.000 --> 02:12:24.000]  Ну вот я прибавляю a0, потом a1-a0, то есть a0 и a0 сокращаются, получается a1.
[02:12:24.000 --> 02:12:29.000]  Дальше a1 плюс a2 минус a1, получается a2, ну и так далее.
[02:12:36.000 --> 02:12:42.000]  Так, ну и давайте это попробуем как-то представить.
[02:12:42.000 --> 02:12:47.000]  Как-то представить в каком-нибудь хорошем виде.
[02:12:47.000 --> 02:13:02.000]  Вот это есть сумма у k от 0 до r, bk умноженное на, я хочу понять, сколько раз у меня в сумме встречается bk.
[02:13:02.000 --> 02:13:05.000]  Давайте попробуем понять.
[02:13:05.000 --> 02:13:10.000]  Ну смотрите, если у меня i равно 0, то что у меня получается?
[02:13:10.000 --> 02:13:12.000]  Просто b0, да?
[02:13:12.000 --> 02:13:18.000]  Если у меня i равно 1, то сколько тут элементов в сумме?
[02:13:18.000 --> 02:13:20.000]  b0 и b1.
[02:13:20.000 --> 02:13:24.000]  Значит, когда i равно 2, то у меня 0, 1 и 2, ну и так далее.
[02:13:24.000 --> 02:13:29.000]  То есть сколько всего b0-иков у меня?
[02:13:29.000 --> 02:13:35.000]  r плюс 1.
[02:13:35.000 --> 02:13:38.000]  Да, всего 0-иков у меня r плюс 1.
[02:13:38.000 --> 02:13:42.000]  Сколько всего b первых? r плюс 1 минус 1.
[02:13:42.000 --> 02:13:48.000]  Сколько всего b вторых? r плюс 1 минус 2 и так далее.
[02:13:48.000 --> 02:13:52.000]  То есть количество элементов bk, которые встречаются в этой сумме, оно равно вот такому количеству.
[02:13:52.000 --> 02:13:58.000]  Поэтому эту сумму я могу переписать просто вот так.
[02:13:58.000 --> 02:14:01.000]  Согласны?
[02:14:01.000 --> 02:14:04.000]  Ну все, остался последний штрих.
[02:14:04.000 --> 02:14:21.000]  Если мы смесим 1 плюс r, то будет сумма bk от 0 до r, bk минус сумма k, bk равно 0 до r.
[02:14:21.000 --> 02:14:24.000]  Все.
[02:14:24.000 --> 02:14:27.000]  Что мы получили?
[02:14:35.000 --> 02:14:44.000]  А получили ли мы следующее? Мы свели задачу поиска суммы на массиве a к поиску суммы на массиве b.
[02:14:44.000 --> 02:14:48.000]  Смотрите, раньше у меня был только a, сейчас есть массив b.
[02:14:48.000 --> 02:14:53.000]  То же самое. То есть тут от 0 до r, тут тоже от 0 до r.
[02:14:53.000 --> 02:15:02.000]  И плюс сумма на префиксе вот для такого массива.
[02:15:02.000 --> 02:15:24.000]  То есть нужно уметь считать суммы на b и на массиве b штрих, который равен чему?
[02:15:24.000 --> 02:15:31.000]  0, 1 на b первое, 2 на b второе, и так далее.
[02:15:31.000 --> 02:15:36.000]  n минус 1, bn минус 1.
[02:15:44.000 --> 02:15:48.000]  Все. То есть я строю еще раз заново.
[02:15:48.000 --> 02:15:50.000]  Что я хотел?
[02:15:50.000 --> 02:15:55.000]  Я хочу сделать массив и научиться выполнять на нем операцию поиска суммы и операцию добавления элемента.
[02:15:55.000 --> 02:15:57.000]  Как выглядит операция поиска суммы?
[02:15:57.000 --> 02:16:03.000]  Операция поиска суммы на префиксе сводится к операции поиска суммы на массиве bk.
[02:16:03.000 --> 02:16:07.000]  То есть я считаю сумму на bk и умножаю на 1 плюс r.
[02:16:07.000 --> 02:16:12.000]  И я считаю сумму на вот таком массиве.
[02:16:12.000 --> 02:16:18.000]  Можно считать, что это некоторый массив b штрих a.
[02:16:18.000 --> 02:16:22.000]  Я вычитаю сумму на массиве b, на массиве b штрих, и вычитаю одну из другого.
[02:16:22.000 --> 02:16:26.000]  Все таким образом я нашел сумму на префиксе для массива a.
[02:16:26.000 --> 02:16:51.000]  Это делается за log n, так как b и b штрих храним в дереве Фенрика.
[02:16:51.000 --> 02:16:56.000]  Вот этот первый пункт.
[02:16:56.000 --> 02:17:11.000]  Второй пункт обновления на суффиксе от r до n-1.
[02:17:11.000 --> 02:17:16.000]  Что для этого нужно сделать?
[02:17:16.000 --> 02:17:28.000]  Нужно всего лишь обновить b в точке r на дельту.
[02:17:28.000 --> 02:17:33.000]  То есть обновление на суффиксе на дельту.
[02:17:33.000 --> 02:17:55.000]  И обновить b штрих в точке r на дельту, умноженное на r.
[02:17:55.000 --> 02:17:59.000]  Ну почему мы b обновляем на дельту?
[02:17:59.000 --> 02:18:01.000]  Мы это обсуждали.
[02:18:01.000 --> 02:18:04.000]  Почему b штрих я должен обновить на r дельту?
[02:18:04.000 --> 02:18:10.000]  Потому что в массиве b штрих у меня хранятся не просто b, а 1 умножить на b1, 2 умножить на b2 и так далее.
[02:18:10.000 --> 02:18:15.000]  Поэтому если я обновляю какой-то b r, то сам b штрих мне нужно обновить на сколько?
[02:18:15.000 --> 02:18:23.000]  Ну как раз таки на r умножить на дельту.
[02:18:23.000 --> 02:18:36.000]  Ну давайте пример проведем, чтобы все встало на свои места.
[02:18:36.000 --> 02:18:42.000]  Давайте какой-нибудь короткий массив.
[02:18:42.000 --> 02:18:49.000]  Давайте просто 0, 1, 2, 3, 4.
[02:18:49.000 --> 02:18:58.000]  Что мы делаем? Мы по этому массиву строим массив b.
[02:18:58.000 --> 02:19:04.000]  Этот массив в качестве первого элемента берет a0, в качестве второго элемента берет разность a1 и a0,
[02:19:04.000 --> 02:19:09.000]  то есть 1, дальше берет разность вот этой штуки, ну и так далее.
[02:19:09.000 --> 02:19:15.000]  То есть просто хранит последовательную разность всех элементов.
[02:19:15.000 --> 02:19:20.000]  Вот этой штуке мы строим дерево Федрика.
[02:19:20.000 --> 02:19:29.000]  Дальше строим b штрих, 0, 1, 2, 3, 4,
[02:19:29.000 --> 02:19:32.000]  который строится вот по такому правилу.
[02:19:32.000 --> 02:19:36.000]  Первый элемент 0, второй элемент 1 умножить на b1, то есть 1 умножить на 1,
[02:19:36.000 --> 02:19:44.000]  дальше 2 умножить на 1, 3 умножить на 1, 4 умножить на 1.
[02:19:44.000 --> 02:19:48.000]  Строим по нему дерево Федрика.
[02:19:48.000 --> 02:19:54.000]  Ну и теперь что? Я хочу найти сумму, скажем, на отрезке,
[02:19:54.000 --> 02:20:01.000]  ну на каком отрезке? Давайте от единицы до четверки.
[02:20:01.000 --> 02:20:11.000]  Что я делаю? Давайте я сначала посчитаю сумму на префиксе от 0 до 4.
[02:20:11.000 --> 02:20:17.000]  Сначала я должен посчитать сумму на префиксе для b.
[02:20:17.000 --> 02:20:26.000]  То есть сумма для b, чему равна?
[02:20:26.000 --> 02:20:32.000]  Равна 4.
[02:20:32.000 --> 02:20:35.000]  И еще я должен посчитать сумму для b штрих.
[02:20:35.000 --> 02:20:37.000]  Тоже на том же самом префиксе.
[02:20:37.000 --> 02:20:43.000]  Для b штрих от 0 до 4 равна 10.
[02:20:43.000 --> 02:20:47.000]  Все, ну и теперь я должен взять
[02:20:47.000 --> 02:20:50.000]  первый элемент с весом 1 на r,
[02:20:50.000 --> 02:20:53.000]  а второй элемент с весом минус 1.
[02:20:53.000 --> 02:20:56.000]  То есть я должен взять эту сумму умножить на 1 плюс r,
[02:20:56.000 --> 02:21:00.000]  вторую сумму умножить на минус 1.
[02:21:00.000 --> 02:21:02.000]  В итоге у меня получается что?
[02:21:02.000 --> 02:21:04.000]  r у меня равно 4, то есть 4 на 4-16,
[02:21:04.000 --> 02:21:08.000]  минус 10-6.
[02:21:08.000 --> 02:21:09.000]  Все, нашли ответ.
[02:21:09.000 --> 02:21:14.000]  То есть сумма от 0 до 4 равна?
[02:21:14.000 --> 02:21:19.000]  Тут 5 должно быть, да.
[02:21:19.000 --> 02:21:22.000]  Ну r это 4, поэтому 1 плюс r это 5.
[02:21:22.000 --> 02:21:27.000]  Ну действительно, сумма от 0 до 4 это 10.
[02:21:27.000 --> 02:21:35.000]  Ну и дальше считаем сумму на отрезке от 0 до 1.
[02:21:35.000 --> 02:21:37.000]  Снова, чтобы посчитать сумму на отрезке от 0 до 1,
[02:21:37.000 --> 02:21:42.000]  мне нужно посчитать сумму для b от 0 до 1.
[02:21:42.000 --> 02:21:45.000]  Вот здесь, это 1.
[02:21:45.000 --> 02:21:47.000]  И посчитать сумму для b штрих от 0 до 1.
[02:21:47.000 --> 02:21:49.000]  Это тоже 1.
[02:21:49.000 --> 02:21:51.000]  Дальше первую штуку я должен умножить на 1 на r,
[02:21:51.000 --> 02:21:55.000]  вторую штуку должен умножить на минус 1.
[02:21:55.000 --> 02:21:57.000]  В итоге что получается?
[02:21:57.000 --> 02:22:02.000]  r равно 1, поэтому 1 плюс 1 это 2.
[02:22:02.000 --> 02:22:05.000]  Ну и минус 1,
[02:22:05.000 --> 02:22:11.000]  сейчас нет, просто минус 1, равно 1.
[02:22:11.000 --> 02:22:13.000]  Ну действительно, сумма от 0 до 1 это 1.
[02:22:13.000 --> 02:22:19.000]  Поэтому просто сумма отрезки от 1 до 4 это 10.
[02:22:19.000 --> 02:22:23.000]  Минус 1 равно 9.
[02:22:29.000 --> 02:22:31.000]  Похоже на правду?
[02:22:33.000 --> 02:22:35.000]  Простите.
[02:22:39.000 --> 02:22:43.000]  Тут нужно считать сумму на отрезке от 0 до 0.
[02:22:43.000 --> 02:22:45.000]  Потому что если мы хотим найти сумму от 1 до 4,
[02:22:45.000 --> 02:22:47.000]  то нам нужно посчитать сумму от 0 до 4
[02:22:47.000 --> 02:22:49.000]  на отрезке,
[02:22:49.000 --> 02:22:53.000]  а потом вычесть нулевой элемент.
[02:22:53.000 --> 02:22:55.000]  Тут понятно, тут везде будет 0,
[02:22:55.000 --> 02:22:57.000]  то есть то же самое не буду проделать,
[02:22:57.000 --> 02:22:59.000]  тут просто будет 0,
[02:22:59.000 --> 02:23:01.000]  поэтому сумма это просто 10.
[02:23:01.000 --> 02:23:03.000]  Ну и давайте обновление тоже выполним.
[02:23:03.000 --> 02:23:05.000]  Мне приходит обновление,
[02:23:05.000 --> 02:23:07.000]  я говорю, что мне нужно обновить
[02:23:07.000 --> 02:23:13.000]  элементы вот эти на плюс 2.
[02:23:13.000 --> 02:23:15.000]  Что я делаю?
[02:23:17.000 --> 02:23:19.000]  Что мне нужно сделать, чтобы обновить
[02:23:19.000 --> 02:23:21.000]  вот этот подотрезок на плюс 2?
[02:23:23.000 --> 02:23:27.000]  Мне нужно все вот это обновить на плюс 2,
[02:23:27.000 --> 02:23:31.000]  а потом вот это обновить на минус 2.
[02:23:31.000 --> 02:23:33.000]  Согласны?
[02:23:33.000 --> 02:23:35.000]  Как выглядит обновление здесь на плюс 2?
[02:23:35.000 --> 02:23:37.000]  Очень просто, вот этот элемент я должен
[02:23:37.000 --> 02:23:39.000]  увеличить на 2.
[02:23:39.000 --> 02:23:41.000]  Вот.
[02:23:41.000 --> 02:23:45.000]  И вот этот элемент я должен обновить на
[02:23:45.000 --> 02:23:47.000]  2 умножить на 2, то есть 4.
[02:23:47.000 --> 02:23:49.000]  Все, с этим обновлением разбрались,
[02:23:49.000 --> 02:23:51.000]  теперь вот это обновление на минус 2.
[02:23:51.000 --> 02:23:53.000]  Ну что я должен сделать?
[02:23:53.000 --> 02:23:55.000]  Здесь минус 2, и здесь минус 2 умножить на 4,
[02:23:55.000 --> 02:23:57.000]  то есть минус 8.
[02:23:57.000 --> 02:23:59.000]  Все.
[02:24:03.000 --> 02:24:05.000]  Короче говоря, мораль,
[02:24:05.000 --> 02:24:07.000]  если я хочу, чтобы у меня работали
[02:24:07.000 --> 02:24:09.000]  обновления не только в одном элементе,
[02:24:09.000 --> 02:24:11.000]  но и на подотрезках,
[02:24:11.000 --> 02:24:13.000]  я должен перейти от массива A к 2 массивам.
[02:24:13.000 --> 02:24:15.000]  Массиву B,
[02:24:15.000 --> 02:24:17.000]  которая хранит последовательные разницы элементов,
[02:24:17.000 --> 02:24:19.000]  и массиву B штрих,
[02:24:19.000 --> 02:24:21.000]  который массив B умножает на,
[02:24:21.000 --> 02:24:23.000]  то есть каждый элемент умножает на соответствующий индекс.
[02:24:23.000 --> 02:24:25.000]  Вот.
[02:24:25.000 --> 02:24:29.000]  Тогда запрос суммы выглядит как?
[02:24:29.000 --> 02:24:31.000]  Вы считаете сумму на B,
[02:24:31.000 --> 02:24:33.000]  умножаете на 1 плюс R.
[02:24:33.000 --> 02:24:35.000]  Вы считаете сумму на B штрих,
[02:24:35.000 --> 02:24:37.000]  и вы читаете.
[02:24:37.000 --> 02:24:39.000]  Все, это запрос суммы на отрезке.
[02:24:39.000 --> 02:24:41.000]  Как выглядит запрос обновления?
[02:24:41.000 --> 02:24:43.000]  Запрос обновлений выглядит просто.
[02:24:43.000 --> 02:24:47.000]  Если вы хотите обновить на отрезке,
[02:24:47.000 --> 02:24:49.000]  то вы обновляете на таком суффиксе,
[02:24:49.000 --> 02:24:51.000]  и обновляете на таком суффиксе.
[02:24:51.000 --> 02:24:53.000]  Но обновление на таком суффиксе,
[02:24:53.000 --> 02:24:55.000]  и таком суффиксе, оно выглядит просто.
[02:24:55.000 --> 02:24:57.000]  Вы просто обновляете один элемент здесь,
[02:24:57.000 --> 02:24:59.000]  один элемент здесь,
[02:24:59.000 --> 02:25:01.000]  и один элемент здесь,
[02:25:01.000 --> 02:25:03.000]  и один элемент здесь.
[02:25:03.000 --> 02:25:05.000]  Все.
[02:25:05.000 --> 02:25:07.300]  Ну вроде уложили.
[02:25:07.300 --> 02:25:09.300]  Короче, давайте подведем небольшой итог.
[02:25:09.300 --> 02:25:17.100]  То есть у нас сегодня было времени много, поэтому мы рассмотрели много структур данных.
[02:25:17.100 --> 02:25:22.800]  Давайте краткое резюме о том, что важно на практике.
[02:25:22.800 --> 02:25:32.300]  Важно помнить, что если вам дана задача статик rsk, то есть просто нужно находить сумму на всевозможных адресках,
[02:25:32.300 --> 02:25:34.300]  то просто используй массив префиксных сумм.
[02:25:34.300 --> 02:25:41.300]  Если мы хотим решать задачу статик rsk, то есть искать минимумы, максимумы, наибольший общеделитель на адресках,
[02:25:41.300 --> 02:25:45.300]  то мы используем разреженную таблицу, тоже писали.
[02:25:45.300 --> 02:25:50.300]  Если вам нужна задача динамика rsk, и при этом у вас обновление только в одной точке,
[02:25:50.300 --> 02:25:55.300]  то есть если вас интересует обновление только в одной точке, то вам приходит запрос с виду найти сумму на таком-то отрезке
[02:25:55.300 --> 02:25:59.300]  и обновить, скажем, это элемент, то тогда мы пишем дерево фенлика.
[02:25:59.300 --> 02:26:05.300]  Если вам нужно что-то более сложное, то мы используем не эту штуку, а то, чтобы пройдем в следующий раз.
[02:26:05.300 --> 02:26:10.300]  Это просто чтобы себя повеслить.
[02:26:10.300 --> 02:26:13.300]  Все, спасибо, до следующего раза.
