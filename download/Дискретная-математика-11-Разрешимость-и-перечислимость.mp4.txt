[00:00.000 --> 00:15.960]  Сейчас вот как раз мы начнём теорию алгоритмов. Что нужно сказать, какой базовый объект тут
[00:15.960 --> 00:29.080]  изучается? Базовый объект у нас называется частичной функцией. Смотрите, функция f,
[00:29.080 --> 00:41.800]  обозначение вот такое, буква p над стрелкой пишется, называется частичной функцией.
[00:41.800 --> 01:05.400]  Если f у нас, отношение f, f это множество пар, как вы понимаете, отношение f,
[01:05.400 --> 01:24.800]  функционально, но не обязательно тотально. Ну то есть почему оно частичное? Тотальности,
[01:24.800 --> 01:32.240]  просто функциональное требование. Функция обычно, как понимается, тотально-функциональное
[01:32.240 --> 01:41.040]  отношение. Здесь просто функциональное отношение. То есть у нас есть область определения. Почему мы,
[01:41.040 --> 01:48.480]  кстати, в теории алгоритмов будем рассматривать функции строго всегда? Либо из n в n, либо из n
[01:48.480 --> 01:56.320]  квадрат в n, либо из n в куб в n, либо из n в степени k в n. То есть мы такие объекты будем рассматривать.
[01:56.320 --> 02:06.560]  Например, это вот такой стандартный вопрос с троечником на экзамене. Они очень часто это
[02:06.560 --> 02:15.480]  забывают говорить. Сейчас мы определим, что такое вычислимая функция. Откуда может быть определена,
[02:15.480 --> 02:24.360]  где может быть определена вычислимая функция. Например, на r может быть определена стандартный
[02:24.360 --> 02:30.800]  вопрос с троечником. Некоторые говорят, что может. Почему никогда в теории алгоритмов
[02:30.800 --> 02:47.320]  действительно значные функции не рассматриваются? Догадайтесь. Если мы говорим про математику,
[02:47.320 --> 02:55.360]  они какие-нибудь там компьютерные, ну вот практически компьютерные науки, в которых в памяти
[02:55.360 --> 03:00.840]  компьютера фактически задаются именно рациональные числа. Там действительных чисел нет. Действительные
[03:00.840 --> 03:07.080]  числа, чтобы записать действительное число в памяти компьютера, нужно затратить бесконечно
[03:07.080 --> 03:14.400]  много места. У нас такого диска не существует, на который вы бы смогли записать одно действительное
[03:14.400 --> 03:22.960]  число. Потому что это бесконечная последовательность из нулей единиц, например. А соответственно,
[03:22.960 --> 03:28.440]  для хранения бесконечной последовательности из нулей единиц нужна бесконечно большая память. То
[03:28.440 --> 03:35.800]  есть вы даже вычисления не начнете. Вы просто записать это число в алгоритме не сможете.
[03:35.800 --> 03:43.880]  То, что в практических приложениях это округление, рациональное округление действительных
[03:43.880 --> 03:54.000]  чисел. Действительные числа компьютер запихать невозможно. Вот. Поэтому вот в практических
[03:54.000 --> 04:01.640]  алгоритмах, опять же, нельзя даже сказать, что мы можем вычислять значение функций от рациональных
[04:01.640 --> 04:08.320]  аргументов. Потому что может быть, это может быть задано слишком длинной дроби. Ну слишком
[04:08.320 --> 04:15.360]  длинной период у этой дроби может оказаться правильно. И мы, опять же, не сможем это сохранить.
[04:15.360 --> 04:21.840]  Вот. То есть вопрос в объеме памяти, доступной нам для хранения. Опять же, то есть в компьютере
[04:21.840 --> 04:28.320]  хранится не все рациональные числа, только рациональные числа с довольно коротким периодом.
[04:28.320 --> 04:34.400]  С большим периодом, опять же, точности мы сохранить не можем. Математика, она не про
[04:34.400 --> 04:40.520]  приближение и не про округление, а про точные значения. А соответственно, точные значения
[04:40.520 --> 04:46.400]  недействительного числа, ни вообще плохого рационального числа вы записать не сможете просто.
[04:46.400 --> 04:55.800]  Вот. Поэтому берутся то, чего мы действительно можем записать, то, чего мы можем сохранить,
[04:55.800 --> 05:02.160]  то, чего можем обработать. Натуральное число. Вот. Либо пару натуральных чисел, либо тройки
[05:02.160 --> 05:08.960]  натуральных чисел. Это тоже хорошо хранится. Либо там четверки и так далее. То есть вот вычислимые
[05:08.960 --> 05:14.680]  функции и все функции, которые в теории алгоритмов рассматриваются, они определены только вот на
[05:14.680 --> 05:24.760]  таких множествах, которые можно записать в памяти. Машина тюринга, например. Машина тюринга тоже,
[05:24.800 --> 05:32.960]  ну в принципе потенциально машина тюринга может сохранить действительно одно действительное число,
[05:32.960 --> 05:42.480]  но есть беда. Есть требования, что в каждый конечный момент времени на ленте только конечная
[05:42.480 --> 05:49.960]  область занята должна быть во время вычислений. Для действительных чисел это невыполнимо. Вот.
[05:49.960 --> 05:59.080]  Ну что ж. Смотрите. То есть понятно, да, что такое частичная функция. Во-первых,
[05:59.080 --> 06:07.360]  буду писать из n в n, но потом у нас появятся функции из n квадрат в n, из n куб в n. То есть
[06:07.360 --> 06:16.560]  в принципе можно чуть больше такие множества рассматривать. Вот. Но давайте просто, чтобы
[06:16.560 --> 06:23.280]  немножко, ну просто чуть-чуть упростить. Вот из n в n, скажем, частичная функция. Значит,
[06:23.280 --> 06:39.320]  определение f из np, а вы букву p понимаете почему? partial, partial, от слова partial частичная. Вот.
[06:39.320 --> 07:06.000]  Вот. Значит, частичная функция f вычислена, если
[07:06.000 --> 07:29.480]  существует машина тьюринга, которая по номеру, по числу n налетит, ну по аргументу n налетит,
[07:29.480 --> 07:59.080]  которая по аргументу n налетит, либо вычислит f от n, либо вычислит f от n за конечное число шагов
[07:59.080 --> 08:18.560]  Но это в этом случае, если f от n определено. Как вы понимаете, функция частичная, поэтому в некоторых
[08:18.560 --> 08:25.400]  точках она может быть просто неопределена. То есть f от n символ на самом деле плохой,
[08:25.400 --> 08:34.400]  неплохо было бы записать что-нибудь вот такое, как я писал там в логике. Здесь это все-таки f от n
[08:34.400 --> 08:41.560]  понимается, что здесь есть значение, есть значение, это не придумано для частичных функций. Вот такое
[08:41.560 --> 08:48.040]  обозначение, это пустое множество там, если здесь не определено и значение, если определено. Вот.
[08:48.040 --> 09:03.160]  Но давайте уже традиционно использовать. Вот. Если f от n определено, или никогда не закончит
[09:03.160 --> 09:07.560]  вычисление, то есть она зациклется и никогда не закончит вычисление, если f от n не определено,
[09:07.560 --> 09:23.480]  или не остановится никогда, если f от n не определено.
[09:23.480 --> 09:44.200]  Не определено. То есть вычислимая функция, что значит, если неформально, то это функция,
[09:44.200 --> 09:50.400]  для которой есть машина тюринга, которая эту функцию вычисляет, но из натуральных натуральный.
[09:50.400 --> 09:56.640]  Вот. А что значит машина тюринга вычисляет? Если функция определена, то она вычислит
[09:56.640 --> 10:02.840]  законечное число шагов и остановится, если не определена, то никогда ничего не выведет,
[10:02.840 --> 10:11.360]  а зациклится. Вот. В этом, кстати, в определении такой вот хитрость хранится. Короче говоря,
[10:11.360 --> 10:16.520]  идея в чем в том, что алгоритмически законечное число шагов мы не сможем определить,
[10:17.000 --> 10:27.120]  остановится когда-либо или нет. То есть как бы определенность вычислить нельзя алгоритмически
[10:27.120 --> 10:33.360]  задать. Определенность функции, алгоритм просто данный алгоритм, считающий данную частичную
[10:33.360 --> 10:42.360]  функцию. Определена эта частичная функция на n, по алгоритму понять алгоритмически g нельзя,
[10:42.760 --> 10:50.200]  анализируя сей алгоритм. Это мы докажем. То есть вопрос остановки, то есть когда-либо
[10:50.200 --> 11:00.360]  вот оно остановится, вот в законечное время понять это нельзя. Вот. Значит, смотрите,
[11:00.360 --> 11:10.840]  а с этим связано, собственно, понятие разрешимое перечислим множество. Смотрите. Определение
[11:10.840 --> 11:38.600]  под множество, а под множество n называется разрешимым, если существует, если функция
[11:38.920 --> 11:50.920]  вот такая х, х, х, х, х, который равна единице, если х принадлежит и ноль, если х не принадлежит.
[11:50.920 --> 12:08.280]  Вот эта функция разрешима, вычислима. В частности, она тотальная. То есть в данном случае
[12:08.280 --> 12:14.280]  В любом случае, получается, она иногда, можно сказать, тотально вычислима,
[12:14.280 --> 12:18.280]  чтобы отметить, что она ещё и определена всюду,
[12:18.280 --> 12:24.280]  а можно просто сказать, вычислима достаточно будет.
[12:24.280 --> 12:27.280]  То есть, характеристическая функция вычислима,
[12:27.280 --> 12:33.280]  то есть мы можем при помощи машины чьюринга по данному числу выяснить,
[12:33.280 --> 12:38.280]  принадлежит это число множеству или не принадлежит при помощи алгоритма.
[12:38.280 --> 12:42.280]  Вот. Это называется разрешимое множество.
[12:42.280 --> 12:47.280]  Перечислимое это вот что.
[12:47.280 --> 12:56.280]  Под множество называется перечислимым
[13:04.280 --> 13:10.280]  Я пишу немножко упрощённо, а под множество n.
[13:10.280 --> 13:16.280]  Вообще говоря, мы можем рассматривать разрешимые перечислимые под множество вн, декарта вн.
[13:16.280 --> 13:18.280]  Вн, декарта вн, декарта вн.
[13:18.280 --> 13:22.280]  Вот, короче, вот эти конечных декартовых степенях натурального числа
[13:22.280 --> 13:26.280]  тоже есть разрешимые перечислимые под множество.
[13:26.280 --> 13:29.280]  Ну вот, просто поймите.
[13:29.280 --> 13:32.280]  Ну вот, например, вн это уже нельзя рассматривать.
[13:32.280 --> 13:37.280]  Понимаете, да, потому что там алгоритмы нельзя задать.
[13:37.280 --> 13:40.280]  Вот.
[13:40.280 --> 13:49.280]  Значит, перечислимым, если существует перечислитель.
[13:49.280 --> 13:56.280]  Перечислитель, что такое перечислитель?
[13:56.280 --> 14:17.280]  Машина тьюринга, которая без входа в любом порядке...
[14:17.280 --> 14:43.280]  Вот так, да, в любом порядке на ленте выводит все элементы.
[14:43.280 --> 14:46.280]  Важно, чтобы было видно все элементы.
[14:46.280 --> 14:49.280]  Не требуется, чтобы они, например, не повторялись.
[14:49.280 --> 14:52.280]  Оно может повторять их сколько угодно раз.
[14:52.280 --> 14:53.280]  Вот.
[14:53.280 --> 14:57.280]  И второе условие для перечислителя, то есть это машина тьюринга,
[14:57.280 --> 15:04.280]  которая на ленте в каком-то порядке можно с повторениями выводить элементы А.
[15:04.280 --> 15:12.280]  И работает бесконечно долго.
[15:12.280 --> 15:18.280]  Ну, то есть она бесконечно долго работает и за это время должна вывести...
[15:18.280 --> 15:24.280]  Какое главное требование, что за конечное время должен появиться любой элемент А,
[15:24.280 --> 15:27.280]  если он присутствует в перечислимом множестве?
[15:27.280 --> 15:29.280]  Там еще нет входа.
[15:29.280 --> 15:30.280]  А?
[15:30.280 --> 15:31.280]  Значит, без входа.
[15:31.280 --> 15:32.280]  Ну...
[15:32.280 --> 15:36.280]  У нее нет там на ленте в начале ничего написанного.
[15:36.280 --> 15:37.280]  Она пишет...
[15:37.280 --> 15:40.280]  У нее нет данных для обработки.
[15:40.280 --> 15:47.280]  Она просто начинает работать и выписывать элементы А.
[15:47.280 --> 15:49.280]  Все.
[15:49.280 --> 15:52.280]  Поэтому называется перечислитель.
[15:52.280 --> 15:57.280]  Она просто начинает работать и выписывать элементы А.
[15:57.280 --> 15:59.280]  Все.
[15:59.280 --> 16:02.280]  Поэтому называется перечислитель.
[16:02.280 --> 16:08.280]  Понятно, что это вообще соответствует только счетным множествам.
[16:08.280 --> 16:10.280]  То есть совсем.
[16:10.280 --> 16:13.280]  Для несчетных это вообще бред такое понятие.
[16:13.280 --> 16:15.280]  Вот.
[16:15.280 --> 16:23.280]  Ну, и вообще я вам пояснил, почему ВЭР это плохо вообще определять.
[16:23.280 --> 16:25.280]  Ну, вот.
[16:25.280 --> 16:27.280]  Значит...
[16:29.280 --> 16:30.280]  Конечно.
[16:30.280 --> 16:33.280]  Ну, да, собственно...
[16:33.280 --> 16:34.280]  Ну, какие...
[16:34.280 --> 16:36.280]  Давайте примеры какие-нибудь приведем.
[16:36.280 --> 16:38.280]  Примеры.
[16:38.280 --> 16:40.280]  Примеры.
[16:44.280 --> 16:45.280]  Любое...
[16:45.280 --> 16:46.280]  Давайте...
[16:46.280 --> 16:48.280]  Любое конечное множество разрешимо.
[16:48.280 --> 16:51.280]  Любое конечное множество разрешимо.
[16:55.280 --> 17:02.280]  Ну, естественно, опять я это пропускаю, но мы все под множество опять предполагаем под множествами N.
[17:02.280 --> 17:04.280]  Это, кстати, вот...
[17:04.280 --> 17:05.280]  Знаете, почему?
[17:05.280 --> 17:14.280]  Видимо, вот в тех конспектах, на которые я ссылаюсь, там вот это в начале такой вот строкой написано.
[17:14.280 --> 17:16.280]  Все множества под множество N.
[17:16.280 --> 17:18.280]  Ну, вот.
[17:19.280 --> 17:23.280]  Там вот это в начале такой вот строкой написано.
[17:23.280 --> 17:25.280]  Все множества под множество N.
[17:25.280 --> 17:27.280]  Больше мы про это не упоминаем.
[17:27.280 --> 17:29.280]  И дальше в определениях про это не говорится.
[17:29.280 --> 17:34.280]  И потом, как в какой-нибудь переиздаче, спрашиваешь вот...
[17:34.280 --> 17:37.280]  Конечное множество там разрешимо.
[17:37.280 --> 17:40.280]  Оно конечное множество чего?
[17:40.280 --> 17:42.280]  Какой там универсум?
[17:42.280 --> 17:45.280]  Или это множество под множество всех множеств?
[17:45.280 --> 17:46.280]  Не знаю.
[17:46.280 --> 17:47.280]  Вот.
[17:47.280 --> 17:50.280]  И начинаются очень интересные варианты.
[17:50.280 --> 17:53.280]  Никто почему-то вот N не говорит.
[17:53.280 --> 17:56.280]  Почему-то все мыслят более широкими рамками.
[17:56.280 --> 17:58.280]  Не понимаю почему.
[17:58.280 --> 18:00.280]  Вот.
[18:09.280 --> 18:10.280]  Вот.
[18:10.280 --> 18:12.280]  Значит...
[18:14.280 --> 18:16.280]  Любое, конечно, множество разрешимо.
[18:16.280 --> 18:18.280]  Но почему?
[18:22.280 --> 18:25.280]  Ну, собственно, здесь можно даже программу...
[18:25.280 --> 18:27.280]  Вообще говоря, есть...
[18:27.280 --> 18:30.280]  Вот это не математическое утверждение от слова «совсем»,
[18:30.280 --> 18:33.280]  потому что математическое утверждение так не формулируется.
[18:33.280 --> 18:35.280]  Но это называется тезис...
[18:37.280 --> 18:38.280]  Блин.
[18:38.280 --> 18:39.280]  Чёрти росы.
[18:39.280 --> 18:40.280]  Вот.
[18:40.280 --> 18:41.280]  Чёрти росы.
[18:41.280 --> 18:42.280]  Распомнил.
[18:42.280 --> 18:44.280]  Вот тезис...
[18:44.280 --> 18:48.280]  Он говорит, что любая интуитивная модель алгоритма
[18:48.280 --> 18:51.280]  может быть задана машиной тьюринга.
[18:51.280 --> 18:53.280]  Почему не математическое утверждение?
[18:53.280 --> 18:57.280]  Потому что непонятно, что такое интуитивная модель алгоритма.
[18:57.280 --> 18:58.280]  Вот.
[18:58.280 --> 19:00.280]  И формально это не задать.
[19:00.280 --> 19:01.280]  Вот.
[19:02.280 --> 19:05.280]  Но, то есть, можно просто переписать алгоритм,
[19:05.280 --> 19:07.280]  который вычисляет, руками.
[19:07.280 --> 19:12.280]  Типа вот, если x равно a1, то 1 выводим.
[19:12.280 --> 19:14.280]  Если x равно a2, то a2 выводим.
[19:14.280 --> 19:15.280]  И так далее.
[19:15.280 --> 19:17.280]  Если x равно an, an выводим.
[19:17.280 --> 19:18.280]  Иначе выводим 0.
[19:18.280 --> 19:19.280]  Всё.
[19:19.280 --> 19:23.280]  Вот просто алгоритм пишется для конечного множества.
[19:23.280 --> 19:28.280]  Эти все элементы множества хранятся в этом алгоритме.
[19:28.280 --> 19:33.280]  И, собственно, сравнивается данное число с этими элементами.
[19:33.280 --> 19:38.280]  Но в машине тьюринга это можно хранить в виде состояния, например.
[19:38.280 --> 19:44.280]  Но, опять же, вы видите, в данной теории мы описываем алгоритм вот так, руками, махая.
[19:44.280 --> 19:45.280]  Почему?
[19:45.280 --> 19:53.280]  Потому что, на самом деле, если мы нормально систематически эту всю теорию здесь будем задавать.
[19:53.280 --> 19:56.280]  Например, писать машины тьюринга вот здесь.
[19:56.280 --> 20:00.280]  Нормально программировать машины тьюринга вот тут.
[20:00.280 --> 20:04.280]  Есть такие книжки, но они очень тяжело читаемые.
[20:04.280 --> 20:06.280]  Там ужасно.
[20:06.280 --> 20:11.280]  Ну вот базовые вещи, которые мы докажем чуть позже.
[20:11.280 --> 20:13.280]  Условно докажем.
[20:13.280 --> 20:16.280]  Я не скажу, что я приведу вам доказательства.
[20:16.280 --> 20:20.280]  Потому что настоящее доказательство – это целая книжка.
[20:22.280 --> 20:28.280]  Ну там реально человек действительно заморочился и написал машину тьюринга,
[20:28.280 --> 20:33.280]  которая вычисляет так называемую универсальную вычислимую функцию.
[20:33.280 --> 20:35.280]  Он разбирал классы вычислимой функции.
[20:35.280 --> 20:39.280]  Там целая теория была из-за этого построена.
[20:39.280 --> 20:43.280]  Мы же скажем просто, что она, грубо говоря, существует.
[20:48.280 --> 20:50.280]  Потому что оно безумно.
[20:50.280 --> 20:55.280]  Если в конкретной модели начнем еще алгоритмы,
[20:55.280 --> 21:00.280]  еще пытаться эту теорию построить в конкретной модели,
[21:00.280 --> 21:02.280]  скажем, только машиной тьюринга,
[21:02.280 --> 21:04.280]  тогда тут вообще начнется…
[21:04.280 --> 21:08.280]  Мы будем вынуждены на каждый чих машины тьюринга писать,
[21:08.280 --> 21:13.280]  и это будет очень сложно и долго, и мы сильно не продвинемся.
[21:14.280 --> 21:19.280]  То есть поэтому тут много таких неформальных мест,
[21:19.280 --> 21:21.280]  где мы говорим, что есть алгоритм,
[21:21.280 --> 21:25.280]  и мы задаем каким-нибудь удобным для нас способом его.
[21:25.280 --> 21:27.280]  Это сам алгоритм.
[21:29.280 --> 21:31.280]  Скажем, какой еще пример?
[21:31.280 --> 21:37.280]  Ну, например, 1, 3, 5, 7.
[21:37.280 --> 21:41.280]  Оно разрешимо.
[21:41.280 --> 21:45.280]  Как алгоритм примерно писать?
[21:53.280 --> 22:03.280]  По данному числу выясняет, принадлежит ли,
[22:03.280 --> 22:07.280]  четное ли число или нет.
[22:10.280 --> 22:14.280]  Ну, например, да, когда машиной тьюринга там двоечное в виде.
[22:14.280 --> 22:17.280]  Да, элементарно, двоечное в виде.
[22:20.280 --> 22:25.280]  То есть любые числа, которые отличаются друг от друга,
[22:25.280 --> 22:27.280]  любая арифметическая прогрессия,
[22:27.280 --> 22:29.280]  даже бесконечная вы можете записать,
[22:29.280 --> 22:31.280]  она тоже будет разрешима.
[22:31.280 --> 22:33.280]  Но, ребята, то есть множество,
[22:33.280 --> 22:36.280]  которое вы начнете сейчас придумывать,
[22:36.280 --> 22:40.280]  они все, как ни странно, оказываются разрешимыми.
[22:40.280 --> 22:42.280]  Просто мозг так и работает.
[22:42.280 --> 22:44.280]  На самом деле не все множества разрешимы
[22:44.280 --> 22:46.280]  и не все множества перечислимы.
[22:48.280 --> 22:50.280]  Сейчас два вот этих понятия,
[22:50.280 --> 22:52.280]  как они взаимоотносятся,
[22:52.280 --> 22:54.280]  давайте сейчас как раз и будем изучать.
[22:54.280 --> 22:57.280]  Смотрите, ЛМ-1.
[23:01.280 --> 23:08.280]  Если А под множество разрешимо,
[23:14.280 --> 23:17.280]  то А перечислимо.
[23:17.280 --> 23:20.280]  То есть любой разрешимый множество перечислимо.
[23:20.280 --> 23:22.280]  Давайте докажем.
[23:24.280 --> 23:28.280]  Ну вот, по предположению,
[23:28.280 --> 23:30.280]  по нашему предположению,
[23:40.280 --> 23:42.280]  хиата,
[23:43.280 --> 23:45.280]  предположение,
[23:48.280 --> 23:50.280]  хиата,
[23:52.280 --> 23:54.280]  тот х,
[23:54.280 --> 23:56.280]  вычислимо.
[23:59.280 --> 24:01.280]  Больше того, давайте сразу отметим,
[24:01.280 --> 24:03.280]  тотально вычислимо.
[24:03.280 --> 24:05.280]  То есть за конечное,
[24:05.280 --> 24:07.280]  неважно какое число тот х будет подано,
[24:07.280 --> 24:09.280]  за конечное число шагов
[24:09.280 --> 24:11.280]  мы выясним, принадлежит ли это число
[24:11.280 --> 24:13.280]  множество или не принадлежит.
[24:13.280 --> 24:15.280]  Тотально вычислимо.
[24:26.280 --> 24:28.280]  Как мы построим перечислитель
[24:28.280 --> 24:30.280]  нашего А?
[24:30.280 --> 24:32.280]  Перечислитель работает так.
[24:41.280 --> 24:51.280]  Значит, он в бесконечном цикле берет все натуральные числа.
[24:51.280 --> 24:53.280]  Перебирает все натуральные числа.
[24:53.280 --> 24:55.280]  В бесконечном цикле.
[25:03.280 --> 25:05.280]  Перебираем все натуральные числа.
[25:11.280 --> 25:13.280]  Все натуральные числа.
[25:19.280 --> 25:21.280]  И проверяем,
[25:21.280 --> 25:23.280]  принадлежат ли они множество
[25:23.280 --> 25:25.280]  или не принадлежат.
[25:25.280 --> 25:27.280]  И вычисляем
[25:31.280 --> 25:33.280]  хиаатен.
[25:33.280 --> 25:35.280]  Если хиаатен
[25:35.280 --> 25:37.280]  равно единице, то он печатаем.
[25:37.280 --> 25:39.280]  Если нет, то нет.
[25:39.280 --> 25:41.280]  Поняли, да?
[25:47.280 --> 25:49.280]  То
[25:49.280 --> 25:51.280]  n печатается.
[25:57.280 --> 25:59.280]  Иначе нет.
[26:01.280 --> 26:03.280]  Поэтому иногда, кстати,
[26:03.280 --> 26:05.280]  перечислитель определяет,
[26:05.280 --> 26:07.280]  как машина чьюринга с двумя лентами.
[26:07.280 --> 26:09.280]  Одна, грубо говоря, для вычислений
[26:09.280 --> 26:11.280]  промежуточных, а другая
[26:11.280 --> 26:13.280]  для вывода итога.
[26:13.280 --> 26:15.280]  Так проще даже представить.
[26:17.280 --> 26:19.280]  Но, в принципе, двухлетночную
[26:19.280 --> 26:21.280]  можно заменить одноленточной.
[26:21.280 --> 26:23.280]  Правда, там будет
[26:23.280 --> 26:25.280]  в какой-то отдаленной области
[26:25.280 --> 26:27.280]  вычисление производить.
[26:27.280 --> 26:29.280]  Понимаете, да?
[26:37.280 --> 26:39.280]  Ну вот.
[26:39.280 --> 26:41.280]  Смотрите, в чем
[26:41.280 --> 26:43.280]  собственно утверждение
[26:43.280 --> 26:45.280]  доказано.
[26:45.280 --> 26:47.280]  В чем хитрость. Главное
[26:49.280 --> 26:51.280]  это тоже интересный вопрос все время
[26:51.280 --> 26:53.280]  на экзамене спрашиваю.
[26:53.280 --> 26:55.280]  Вот, например,
[26:55.280 --> 26:57.280]  выяснили, а разрешима?
[26:57.280 --> 26:59.280]  Да, конечно, а разрешима.
[26:59.280 --> 27:01.280]  В том числе, кстати, пустое
[27:01.280 --> 27:03.280]  множество разрешима.
[27:03.280 --> 27:05.280]  Ну, программа,
[27:05.280 --> 27:07.280]  которая выдает все до ноль,
[27:07.280 --> 27:09.280]  легко написать программу.
[27:13.280 --> 27:15.280]  Значит, отсюда по нашей теории
[27:15.280 --> 27:17.280]  выходит
[27:17.280 --> 27:19.280]  любое конечное множество,
[27:19.280 --> 27:21.280]  в том числе пустое, перечислимо.
[27:21.280 --> 27:23.280]  Я все время спрашиваю,
[27:23.280 --> 27:25.280]  а как будет работать перечислитель,
[27:25.280 --> 27:27.280]  который перечисляет конечное множество?
[27:27.280 --> 27:29.280]  Ну вот, если
[27:29.280 --> 27:31.280]  просто по доказательству
[27:31.280 --> 27:33.280]  теории мы пройдемся,
[27:33.280 --> 27:35.280]  что он сделает?
[27:35.280 --> 27:37.280]  Он будет проверять
[27:37.280 --> 27:39.280]  в бесконечном цикле,
[27:39.280 --> 27:41.280]  принадлежит ли
[27:41.280 --> 27:43.280]  элемент множеству.
[27:43.280 --> 27:45.280]  Значит,
[27:45.280 --> 27:47.280]  понятное дело,
[27:47.280 --> 27:49.280]  что на каком-то конечном шаге
[27:49.280 --> 27:51.280]  он выведет все элементы.
[27:51.280 --> 27:53.280]  А что после этого будет?
[27:53.280 --> 27:55.280]  Он будет ничего не писать.
[27:55.280 --> 27:57.280]  Он будет ничего не писать,
[27:57.280 --> 27:59.280]  но бесконечно долго работать.
[28:03.280 --> 28:05.280]  Понимаете, в чем дело?
[28:05.280 --> 28:07.280]  Поэтому я здесь
[28:07.280 --> 28:09.280]  обязательно приписал,
[28:09.280 --> 28:11.280]  работает бесконечно долго.
[28:11.280 --> 28:13.280]  Даже для конечных множеств он работает
[28:13.280 --> 28:15.280]  бесконечно долго.
[28:15.280 --> 28:17.280]  Даже если нужно вывести, перечислить,
[28:17.280 --> 28:19.280]  грубо говоря, пустое множество,
[28:19.280 --> 28:21.280]  то что он будет делать?
[28:21.280 --> 28:23.280]  Он просто зациклится, но он никогда
[28:23.280 --> 28:25.280]  не напишет, но он будет бесконечно
[28:25.280 --> 28:27.280]  долго работать.
[28:27.280 --> 28:29.280]  Опять же,
[28:29.280 --> 28:31.280]  почему вот здесь
[28:31.280 --> 28:33.280]  по-другому никак нельзя?
[28:33.280 --> 28:35.280]  Потому что у нас
[28:35.280 --> 28:37.280]  мы на самом деле алгоритмически
[28:37.280 --> 28:39.280]  не сможем выяснить
[28:39.280 --> 28:41.280]  хиата.
[28:41.280 --> 28:43.280]  Нам дан алгоритм для хиата,
[28:43.280 --> 28:45.280]  вот мы больше ничего не знаем.
[28:45.280 --> 28:47.280]  Нам вот этот алгоритм
[28:47.280 --> 28:49.280]  только известен.
[28:49.280 --> 28:51.280]  Мы не сможем выяснить
[28:51.280 --> 28:53.280]  хиата.
[28:53.280 --> 28:55.280]  Остановит конечное множество
[28:55.280 --> 28:57.280]  за этот алгоритм или нет.
[28:59.280 --> 29:01.280]  Поэтому мы вынуждены перебирать
[29:01.280 --> 29:03.280]  именно все натуральные числа.
[29:03.280 --> 29:05.280]  И поэтому
[29:05.280 --> 29:07.280]  здесь никак по-другому не можем.
[29:11.280 --> 29:13.280]  Ну что ж,
[29:13.280 --> 29:15.280]  что еще?
[29:15.280 --> 29:17.280]  Давайте
[29:17.280 --> 29:19.280]  докажем, что есть
[29:19.280 --> 29:21.280]  неразрешимое множество.
[29:27.280 --> 29:29.280]  Каких?
[29:31.280 --> 29:33.280]  Неперечислимых.
[29:33.280 --> 29:35.280]  Давайте неразрешимое
[29:35.280 --> 29:37.280]  приведем, а то оно же будет
[29:37.280 --> 29:39.280]  неперечислимым.
[29:39.280 --> 29:41.280]  Привести я его не смогу,
[29:41.280 --> 29:43.280]  как ни странно.
[29:43.280 --> 29:45.280]  Я грубо говоря
[29:45.280 --> 29:47.280]  мощностными аргументами покажу,
[29:47.280 --> 29:49.280]  что оно есть.
[29:49.280 --> 29:51.280]  А вот пример неразрешимого
[29:51.280 --> 29:53.280]  или неперечисленного множества
[29:53.280 --> 29:55.280]  я дам позже, конструктивные примеры есть
[29:55.280 --> 29:57.280]  сразу говорю.
[29:57.280 --> 29:59.280]  Пока что это статистический аргумент,
[29:59.280 --> 30:01.280]  грубо говоря.
[30:01.280 --> 30:03.280]  Просто статистический аргумент
[30:03.280 --> 30:05.280]  работает следующим образом.
[30:05.280 --> 30:07.280]  Разрешимых множеств
[30:07.280 --> 30:09.280]  счет намного на самом деле,
[30:09.280 --> 30:11.280]  потому что каждому разрешимому множеству
[30:11.280 --> 30:13.280]  соответствует алгоритм.
[30:13.280 --> 30:15.280]  Алгоритм счет намного.
[30:15.280 --> 30:17.280]  Алгоритм это конечный последствий
[30:17.280 --> 30:19.280]  каких-то четко заданных команд.
[30:21.280 --> 30:23.280]  Таких конечных последовательностей
[30:23.280 --> 30:25.280]  счетно.
[30:25.280 --> 30:27.280]  А под множество натуральных чисел,
[30:27.280 --> 30:29.280]  континум,
[30:33.280 --> 30:35.280]  поэтому конечно же найдется
[30:35.280 --> 30:37.280]  среди континума
[30:37.280 --> 30:39.280]  только разрешимых
[30:39.280 --> 30:41.280]  и перечислимых,
[30:41.280 --> 30:43.280]  перечислим тоже соответственно алгоритм.
[30:43.280 --> 30:45.280]  Их счетно много,
[30:45.280 --> 30:47.280]  а значит есть
[30:47.280 --> 30:49.280]  неразрешимые и не перечислимые,
[30:49.280 --> 30:51.280]  но значит и не перечислимые
[30:51.280 --> 30:53.280]  множества.
[30:53.280 --> 30:55.280]  Их тоже континум, их очень много.
[30:55.280 --> 30:57.280]  Ну вот написать
[30:57.280 --> 30:59.280]  конструкт,
[30:59.280 --> 31:01.280]  прям вот явно привести пример
[31:01.280 --> 31:03.280]  неразрешимого множества
[31:03.280 --> 31:05.280]  можно, но это будет позже.
[31:05.280 --> 31:07.280]  Потому что для этого
[31:07.280 --> 31:09.280]  нужно некую теорию
[31:09.280 --> 31:11.280]  развить с вами.
[31:11.280 --> 31:13.280]  Так называемых универсальных вычислимых функций.
[31:17.280 --> 31:19.280]  То есть пока что я просто
[31:19.280 --> 31:21.280]  статистически,
[31:21.280 --> 31:23.280]  мы просто выяснили мощность
[31:23.280 --> 31:25.280]  множества разрешимых и перечислимых
[31:25.280 --> 31:27.280]  множеств их счетно
[31:27.280 --> 31:29.280]  и мощность всего
[31:29.280 --> 31:31.280]  под множество, континум.
[31:31.280 --> 31:33.280]  Значит есть и не перечислимые
[31:33.280 --> 31:35.280]  и не разрешимые
[31:35.280 --> 31:37.280]  их тоже континум.
[31:41.280 --> 31:43.280]  Так.
[31:57.280 --> 31:59.280]  То есть смотрите,
[31:59.280 --> 32:01.280]  но понятное дело,
[32:01.280 --> 32:03.280]  что они есть
[32:03.280 --> 32:05.280]  и они как минимум бесконечны.
[32:05.280 --> 32:07.280]  То есть поэтому например
[32:07.280 --> 32:09.280]  на доске их выписать не смогу.
[32:09.280 --> 32:11.280]  Вот.
[32:11.280 --> 32:13.280]  То есть неразрешимые
[32:13.280 --> 32:15.280]  множества есть
[32:15.280 --> 32:17.280]  и не перечислимые есть.
[32:17.280 --> 32:19.280]  Больше того, смотрите в обратную сторону
[32:19.280 --> 32:21.280]  любой перечислимая разрешимка
[32:21.280 --> 32:23.280]  тоже это неверное утверждение.
[32:23.280 --> 32:25.280]  И есть перечислимые,
[32:25.280 --> 32:27.280]  но неразрешимые множества.
[32:31.280 --> 32:33.280]  Но опять же
[32:33.280 --> 32:35.280]  конструктивный пример
[32:35.280 --> 32:37.280]  такого дела
[32:37.280 --> 32:39.280]  я дам позже,
[32:39.280 --> 32:41.280]  когда мы будем изучать с вами опять
[32:41.280 --> 32:43.280]  универсальные вычислимые функции.
[32:43.280 --> 32:45.280]  Пока что на базовой теории
[32:45.280 --> 32:47.280]  лучше
[32:47.280 --> 32:49.280]  мы не сможем это сейчас
[32:49.280 --> 32:51.280]  произвести такой пример,
[32:51.280 --> 32:53.280]  построить. Он будет, он позже будет.
[32:53.280 --> 32:55.280]  Вот.
[32:55.280 --> 32:57.280]  Значит ну давайте
[32:59.280 --> 33:01.280]  следующую гемму.
[33:01.280 --> 33:03.280]  Но это про операции,
[33:03.280 --> 33:05.280]  которые сохраняют перечислимость
[33:05.280 --> 33:07.280]  и разрешимость.
[33:09.280 --> 33:11.280]  Операции, сохраняющие
[33:13.280 --> 33:15.280]  перечислимость
[33:17.280 --> 33:19.280]  и разрешимость.
[33:25.280 --> 33:27.280]  Смотрите,
[33:27.280 --> 33:29.280]  первая
[33:29.280 --> 33:31.280]  если
[33:31.280 --> 33:33.280]  A-B
[33:33.280 --> 33:35.280]  разрешимый,
[33:41.280 --> 33:43.280]  то
[33:43.280 --> 33:45.280]  A объединенное
[33:45.280 --> 33:47.280]  B,
[33:47.280 --> 33:49.280]  A пересечь
[33:49.280 --> 33:51.280]  B,
[33:51.280 --> 33:53.280]  A дикартово-B.
[33:53.280 --> 33:55.280]  Опять вот я говорил,
[33:55.280 --> 33:57.280]  мы можем с вами
[33:57.280 --> 33:59.280]  собственно говорить про разрешимые
[33:59.280 --> 34:01.280]  перечислимые подмножества
[34:01.280 --> 34:03.280]  в N дикарта ВН.
[34:03.280 --> 34:05.280]  Вот это одно из подмножеств
[34:05.280 --> 34:07.280]  N дикарта ВН.
[34:07.280 --> 34:09.280]  Вот.
[34:09.280 --> 34:11.280]  A дикартово-B,
[34:11.280 --> 34:13.280]  A дополнительное,
[34:13.280 --> 34:15.280]  тоже разрешимое.
[34:15.280 --> 34:17.280]  Но еще можно дописать вот такой
[34:17.280 --> 34:19.280]  объект проекции A.
[34:19.280 --> 34:21.280]  Что такое проекция A?
[34:21.280 --> 34:23.280]  Это проекция
[34:23.280 --> 34:25.280]  подмножества N дикарта ВН
[34:25.280 --> 34:27.280]  с координат.
[34:27.280 --> 34:29.280]  Понятно, да?
[34:31.280 --> 34:33.280]  Сейчас напишу.
[34:35.280 --> 34:37.280]  A подмножество N квадрат
[34:37.280 --> 34:39.280]  в данном случае.
[34:39.280 --> 34:41.280]  Ну или N степеника.
[34:41.280 --> 34:43.280]  A опять же
[34:43.280 --> 34:45.280]  разрешима.
[34:45.280 --> 34:47.280]  Вот это преамбула для всех остается
[34:47.280 --> 34:49.280]  с одноэтажа.
[34:49.280 --> 34:51.280]  А N степеника это те
[34:51.280 --> 34:53.280]  N, что
[34:53.280 --> 34:55.280]  существует
[34:55.280 --> 34:57.280]  N1,
[34:57.280 --> 34:59.280]  N2,
[34:59.280 --> 35:01.280]  Nk-1,
[35:01.280 --> 35:03.280]  Nk-1.
[35:05.280 --> 35:07.280]  Ой-ой-ой.
[35:07.280 --> 35:09.280]  Ng.
[35:11.280 --> 35:13.280]  Проекция g.
[35:15.280 --> 35:17.280]  Nk такое что?
[35:19.280 --> 35:21.280]  N1,
[35:21.280 --> 35:23.280]  Ng,
[35:23.280 --> 35:25.280]  минус 1 на
[35:25.280 --> 35:27.280]  здесь, вот тут N.
[35:29.280 --> 35:31.280]  Вот тут Ng плюс 1
[35:31.280 --> 35:33.280]  Nk
[35:33.280 --> 35:35.280]  принадлежат
[35:41.280 --> 35:43.280]  Понятно, да?
[35:43.280 --> 35:45.280]  Ну то есть мы, что такое?
[35:45.280 --> 35:47.280]  У нас вот множество натуральных чисел,
[35:47.280 --> 35:49.280]  вот такое последовательство.
[35:49.280 --> 35:51.280]  Мы собираем только одну компоненту.
[35:55.280 --> 35:57.280]  То есть убираем все остальные
[35:57.280 --> 35:59.280]  компоненты, берем все
[35:59.280 --> 36:01.280]  элементы нашего множества,
[36:01.280 --> 36:03.280]  берем только одну компоненту.
[36:03.280 --> 36:05.280]  Собираем все эти компоненты множества,
[36:05.280 --> 36:07.280]  это получится проекция.
[36:07.280 --> 36:09.280]  Значит разрешима.
[36:19.280 --> 36:21.280]  Подождите.
[36:31.280 --> 36:33.280]  Подождите, про проекцию
[36:33.280 --> 36:35.280]  может быть Махо дал, может быть
[36:35.280 --> 36:37.280]  это неверно, подождите.
[36:37.280 --> 36:39.280]  Для разрешимости конкретно,
[36:39.280 --> 36:41.280]  для перечисления, да,
[36:41.280 --> 36:43.280]  это перечислимая проекция, простите.
[36:45.280 --> 36:47.280]  Проекция это не здесь
[36:47.280 --> 36:49.280]  должна быть.
[36:51.280 --> 36:53.280]  То есть проекция разрешима множество,
[36:53.280 --> 36:55.280]  вообще говоря, перечислима.
[36:55.280 --> 36:57.280]  Вот это можно точно сказать,
[36:57.280 --> 36:59.280]  но не факт, что она разрешима.
[36:59.280 --> 37:01.280]  Вот так.
[37:05.280 --> 37:07.280]  Ну и вторая часть
[37:07.280 --> 37:09.280]  нашего утверждения, AB,
[37:09.280 --> 37:11.280]  если AB
[37:13.280 --> 37:15.280]  перечислимы,
[37:17.280 --> 37:19.280]  то
[37:21.280 --> 37:23.280]  A объединить B,
[37:23.280 --> 37:25.280]  A пересечь B,
[37:25.280 --> 37:27.280]  A Декартова B.
[37:31.280 --> 37:33.280]  Вот о дополнительной
[37:33.280 --> 37:35.280]  нельзя сказать, кстати.
[37:35.280 --> 37:37.280]  Если A перечислима, то
[37:37.280 --> 37:39.280]  о дополнительной, вообще говоря,
[37:39.280 --> 37:41.280]  не обязательно перечислима.
[37:41.280 --> 37:43.280]  И примеры у нас будут,
[37:43.280 --> 37:45.280]  когда A перечислима,
[37:45.280 --> 37:47.280]  а дополнительной нет.
[37:47.280 --> 37:49.280]  Но они тоже даются
[37:49.280 --> 37:51.280]  при помощи универсальной вычислимой функции.
[37:55.280 --> 37:57.280]  Ну и проекция.
[38:01.280 --> 38:03.280]  То есть A под множество Н-степеника,
[38:05.280 --> 38:07.280]  проекция это те
[38:07.280 --> 38:09.280]  НСН,
[38:09.280 --> 38:11.280]  для которых существует
[38:11.280 --> 38:13.280]  Н1, существует Н2,
[38:15.280 --> 38:17.280]  существует Nj-1,
[38:17.280 --> 38:19.280]  существует Nj-1,
[38:23.280 --> 38:25.280]  существует Nk,
[38:25.280 --> 38:27.280]  такое, что N1,
[38:29.280 --> 38:31.280]  Nj-1, N,
[38:31.280 --> 38:33.280]  Nj-1,
[38:35.280 --> 38:37.280]  Nk
[38:37.280 --> 38:39.280]  из A.
[38:41.280 --> 38:43.280]  Вот эти множества перечислимы.
[38:45.280 --> 38:47.280]  Вы говорили о дополнительной.
[38:47.280 --> 38:49.280]  О дополнительной.
[38:51.280 --> 38:53.280]  Это чуть позже.
[38:53.280 --> 38:55.280]  Вот следующий.
[38:55.280 --> 38:57.280]  Я сейчас скажу, это интересный момент.
[38:57.280 --> 38:59.280]  Я скажу,
[38:59.280 --> 39:01.280]  потому что у нас будет следующая
[39:01.280 --> 39:03.280]  теория, и вы поймете, почему.
[39:03.280 --> 39:05.280]  Вот. Пока...
[39:09.280 --> 39:11.280]  Пока.
[39:11.280 --> 39:13.280]  Как я сказал,
[39:13.280 --> 39:15.280]  почему не обязательно, если A перечислимо,
[39:15.280 --> 39:17.280]  а дополнительно не перечислимо,
[39:19.280 --> 39:21.280]  это будет из следующей лему, видно.
[39:21.280 --> 39:23.280]  А вот конструктивный,
[39:23.280 --> 39:25.280]  конкретный пример,
[39:25.280 --> 39:27.280]  когда вот именно так происходит,
[39:27.280 --> 39:29.280]  это когда мы уже будем универсально вычислимую функцию изучать.
[39:31.280 --> 39:33.280]  Так.
[39:43.280 --> 39:45.280]  Следующая теорема,
[39:45.280 --> 39:47.280]  это так называемые критерии Поста.
[39:47.280 --> 39:49.280]  Да, вы его знаете, нет?
[39:49.280 --> 39:51.280]  Но это не для булевых функций,
[39:51.280 --> 39:53.280]  а да.
[39:53.280 --> 39:55.280]  В теории алгоритмов есть тоже критерии Поста.
[39:55.280 --> 39:57.280]  Он звучит так.
[39:57.280 --> 39:59.280]  A разрешима
[39:59.280 --> 40:01.280]  тогда и только тогда, когда
[40:01.280 --> 40:03.280]  A и A дополнительные перечислимы.
[40:03.280 --> 40:05.280]  Одновременно.
[40:07.280 --> 40:09.280]  Вот.
[40:09.280 --> 40:11.280]  Это вот критерии разрешимости множества.
[40:11.280 --> 40:13.280]  Реказательство вот этого.
[40:13.280 --> 40:15.280]  Сначала давайте вот это докажем,
[40:15.280 --> 40:17.280]  потом вот критерии Поста.
[40:17.280 --> 40:19.280]  Ну, давайте.
[40:19.280 --> 40:21.280]  Вот A, B разрешимы.
[40:21.280 --> 40:23.280]  Как разрешить A объединить B?
[40:33.280 --> 40:35.280]  Ну да, да, да.
[40:35.280 --> 40:37.280]  Запускаем алгоритм
[40:37.280 --> 40:39.280]  вычисляющий хиасы,
[40:39.280 --> 40:41.280]  вычисляющий хиата
[40:41.280 --> 40:43.280]  и вычисляющий хиат B.
[40:43.280 --> 40:45.280]  Если один из ответов,
[40:45.280 --> 40:47.280]  который хотя бы один из алгоритмов
[40:47.280 --> 40:49.280]  выдал единица, то
[40:49.280 --> 40:51.280]  тоже и выдаем единицу, иначе ноль.
[40:51.280 --> 40:53.280]  Так?
[40:53.280 --> 40:55.280]  Как перечислить,
[40:55.280 --> 40:57.280]  разрешить A пересечь B?
[40:57.280 --> 40:59.280]  Опять запускаем
[40:59.280 --> 41:01.280]  алгоритм вычисляющий хиата,
[41:01.280 --> 41:03.280]  хиат B, если обе единицы,
[41:03.280 --> 41:05.280]  то
[41:05.280 --> 41:07.280]  печатаем единицу, иначе ноль.
[41:07.280 --> 41:09.280]  Так?
[41:09.280 --> 41:11.280]  А дикартово B.
[41:11.280 --> 41:13.280]  Хиата, хиат B.
[41:13.280 --> 41:15.280]  Если обе единицы, то пара
[41:15.280 --> 41:17.280]  принадлежит
[41:17.280 --> 41:19.280]  А дикартово B.
[41:23.280 --> 41:25.280]  Ну нет, ну у нас A, B
[41:25.280 --> 41:27.280]  разные же. То есть у нас хиата,
[41:27.280 --> 41:29.280]  да там две программы соответственно.
[41:29.280 --> 41:31.280]  Можем их как-то параллельно
[41:31.280 --> 41:33.280]  запускать, но вот как-то вот.
[41:33.280 --> 41:35.280]  То есть у нас две программы,
[41:35.280 --> 41:37.280]  запускаем по очереди. Вот.
[41:39.280 --> 41:41.280]  Как разрешить дополнительное?
[41:43.280 --> 41:45.280]  Да. Вычисляем
[41:45.280 --> 41:47.280]  хиата, хиат X.
[41:47.280 --> 41:49.280]  Если
[41:49.280 --> 41:51.280]  единица, то выводим ноль,
[41:51.280 --> 41:53.280]  если ноль, то выводим
[41:53.280 --> 41:55.280]  единицу, инвертируем
[41:55.280 --> 41:57.280]  ответ. Это будет
[41:59.280 --> 42:01.280]  вычисление характеристическая
[42:01.280 --> 42:03.280]  функция, а дополнительная. Вот.
[42:05.280 --> 42:07.280]  Теперь. Перечислитель.
[42:07.280 --> 42:09.280]  Вот есть перечислитель A,
[42:09.280 --> 42:11.280]  перечислитель B.
[42:11.280 --> 42:13.280]  Как перечислить A
[42:13.280 --> 42:15.280]  объединить B?
[42:17.280 --> 42:19.280]  Перечислять по варианту.
[42:19.280 --> 42:21.280]  Да, да, да, правильно, правильно.
[42:21.280 --> 42:23.280]  Можно даже там, знаете,
[42:23.280 --> 42:25.280]  как Мусатов любит рассказывать,
[42:25.280 --> 42:27.280]  он
[42:27.280 --> 42:29.280]  говорит, ну можем по очереди шаги
[42:29.280 --> 42:31.280]  алгоритмов перечисления A,
[42:31.280 --> 42:33.280]  перечисления B делать. Сначала один, потом
[42:33.280 --> 42:35.280]  второй. Когда какой-то алгоритм решит
[42:35.280 --> 42:37.280]  напечатать что-то,
[42:37.280 --> 42:39.280]  печатаем. Вот. Потом запуск
[42:39.280 --> 42:41.280]  по очереди опять продолжаем.
[42:41.280 --> 42:43.280]  И так далее. То есть шаги
[42:43.280 --> 42:45.280]  не обязательно же приводят к тому, что
[42:45.280 --> 42:47.280]  что-то вводится, он просто может быть
[42:47.280 --> 42:49.280]  посередине какого-то вычисления.
[42:49.280 --> 42:51.280]  Вот. Когда алгоритм
[42:51.280 --> 42:53.280]  решит что-то напечатать, вот, печатаем
[42:53.280 --> 42:55.280]  это. Вот. То есть мы
[42:55.280 --> 42:57.280]  по очереди запускаем два алгоритма
[42:57.280 --> 42:59.280]  и печатаем оба вывода
[42:59.280 --> 43:01.280]  этих самых алгоритмов.
[43:01.280 --> 43:03.280]  Так перечислим A,
[43:03.280 --> 43:05.280]  как перечисить A пересечь B?
[43:11.280 --> 43:13.280]  Да. То есть мы должны
[43:13.280 --> 43:15.280]  отсортировать вывод, так сказать.
[43:15.280 --> 43:17.280]  То есть что у нас будет? Мы
[43:17.280 --> 43:19.280]  должны вывод алгоритма
[43:19.280 --> 43:21.280]  A, вывод алгоритма B
[43:21.280 --> 43:23.280]  сравнивать
[43:23.280 --> 43:25.280]  постоянно и
[43:25.280 --> 43:27.280]  выводить только общие элементы.
[43:27.280 --> 43:29.280]  Да?
[43:29.280 --> 43:31.280]  То есть выведенные элементы
[43:31.280 --> 43:33.280]  A, выведенные элементы B
[43:33.280 --> 43:35.280]  сравнивайте те, которые
[43:35.280 --> 43:37.280]  появились на той и на той линте,
[43:37.280 --> 43:39.280]  вводить в общий вывод.
[43:39.280 --> 43:41.280]  Так?
[43:53.280 --> 43:55.280]  Почему?
[43:57.280 --> 43:59.280]  А какие выводы должны быть?
[44:09.280 --> 44:11.280]  А когда проверяешь, что
[44:11.280 --> 44:13.280]  что-то вывели или
[44:13.280 --> 44:15.280]  что-то сравнивали?
[44:27.280 --> 44:29.280]  Если какой-то алгоритм есть,
[44:29.280 --> 44:31.280]  этот алгоритм
[44:31.280 --> 44:33.280]  безусловно будет работать
[44:33.280 --> 44:35.280]  очень долго.
[44:35.280 --> 44:37.280]  Вопросов нет.
[44:37.280 --> 44:39.280]  Тем не менее.
[44:39.280 --> 44:41.280]  А вот как перечислять A
[44:41.280 --> 44:43.280]  дикарту B?
[44:43.280 --> 44:45.280]  Ну тут еще длиннее.
[44:45.280 --> 44:47.280]  Смотрите алгоритм. Перечисляем
[44:47.280 --> 44:49.280]  элементы A,
[44:49.280 --> 44:51.280]  перечисляем элементы B.
[44:51.280 --> 44:53.280]  На самом деле делаем вот так.
[44:53.280 --> 44:55.280]  Делаем шаг алгоритма перечислителя,
[44:55.280 --> 44:57.280]  шаг алгоритма перечислителя B.
[44:57.280 --> 44:59.280]  Когда что-то новое
[44:59.280 --> 45:01.280]  будет выведено на каждом шаге,
[45:01.280 --> 45:03.280]  берем все элементы,
[45:03.280 --> 45:05.280]  которые на линте для A выведены
[45:05.280 --> 45:07.280]  и выводим пары
[45:07.280 --> 45:09.280]  этого нового B
[45:09.280 --> 45:11.280]  со всеми перечисленными
[45:11.280 --> 45:13.280]  элементами A.
[45:13.280 --> 45:15.280]  Так?
[45:15.280 --> 45:17.280]  Если появилось что-то новое
[45:17.280 --> 45:19.280]  на перечислителе A,
[45:19.280 --> 45:21.280]  то выводим все пары
[45:21.280 --> 45:23.280]  нового элемента со всеми
[45:23.280 --> 45:25.280]  перечисленными элементами B.
[45:25.280 --> 45:27.280]  Только так. По-другому никак нельзя.
[45:27.280 --> 45:29.280]  Ну и вот так
[45:29.280 --> 45:31.280]  по очереди действуем.
[45:31.280 --> 45:33.280]  То есть нам нужно обрабатывать весь выход
[45:33.280 --> 45:35.280]  с самого начала.
[45:35.280 --> 45:37.280]  Конечно, бесконечно долго.
[45:37.280 --> 45:39.280]  Конечно долго, но очень долго
[45:39.280 --> 45:41.280]  это все будет работать.
[45:43.280 --> 45:45.280]  Значит, проекцию
[45:45.280 --> 45:47.280]  как перечислить?
[45:49.280 --> 45:51.280]  Перечисляем вот эти
[45:51.280 --> 45:53.280]  кортежи
[45:53.280 --> 45:55.280]  по алгоритму.
[45:55.280 --> 45:57.280]  И выпечатаем только
[45:57.280 --> 45:59.280]  нужную позицию.
[46:01.280 --> 46:03.280]  Согласны?
[46:03.280 --> 46:05.280]  Это все.
[46:07.280 --> 46:09.280]  Так. Ну ладно.
[46:09.280 --> 46:11.280]  Видите,
[46:11.280 --> 46:13.280]  если я сейчас начну это записывать,
[46:13.280 --> 46:15.280]  долго будет. Давайте.
[46:17.280 --> 46:19.280]  Вот, чтобы быстрее. Следующий LEMO.
[46:19.280 --> 46:21.280]  LEMO 3.
[46:23.280 --> 46:25.280]  Критерии поста.
[46:35.280 --> 46:37.280]  A под множество N.
[46:39.280 --> 46:41.280]  Разрешено.
[46:45.280 --> 46:47.280]  Тогда и только тогда, когда
[46:47.280 --> 46:49.280]  A и A дополнительно перечислим.
[47:01.280 --> 47:03.280]  Давайте доказать.
[47:09.280 --> 47:11.280]  Смотрите, ну пускай вот в эту сторону.
[47:13.280 --> 47:15.280]  Пускай A разрешено.
[47:17.280 --> 47:19.280]  Как перечислить
[47:19.280 --> 47:21.280]  A дополнительно?
[47:29.280 --> 47:31.280]  Ну да, следует перечислить.
[47:31.280 --> 47:33.280]  Все правильно. А почему следует перечислить
[47:33.280 --> 47:35.280]  A дополнительно?
[47:37.280 --> 47:39.280]  Ну да, в принципе,
[47:39.280 --> 47:41.280]  все правильно.
[47:41.280 --> 47:43.280]  То есть A разрешимо.
[47:43.280 --> 47:45.280]  Давайте вот в этом.
[47:45.280 --> 47:47.280]  Значит, A дополнительно разрешимо.
[47:49.280 --> 47:53.280]  Значит, A дополнительно перечислим.
[47:53.280 --> 47:55.280]  По LEMO 1.
[48:05.280 --> 48:07.280]  А это по LEMO 2.
[48:07.280 --> 48:09.280]  Все.
[48:11.280 --> 48:13.280]  В обратную сторону.
[48:13.280 --> 48:15.280]  Вот теперь мы знаем, что A
[48:15.280 --> 48:17.280]  дополнительно перечислим.
[48:25.280 --> 48:27.280]  Почему
[48:27.280 --> 48:29.280]  тогда разрешимо?
[48:29.280 --> 48:31.280]  Ну как разрешить A?
[48:31.280 --> 48:33.280]  Вот так.
[48:33.280 --> 48:35.280]  Вот тут очень
[48:35.280 --> 48:37.280]  такой неэффективный алгоритм
[48:37.280 --> 48:39.280]  сразу говорю.
[48:39.280 --> 48:41.280]  Но какой есть?
[48:41.280 --> 48:43.280]  Значит, по
[48:43.280 --> 48:45.280]  числу
[48:45.280 --> 48:47.280]  X
[48:47.280 --> 48:49.280]  и Z
[48:49.280 --> 48:51.280]  запускаем
[48:51.280 --> 48:53.280]  перечислитель A
[48:53.280 --> 48:55.280]  дополнительно.
[48:55.280 --> 48:57.280]  Запускаем перечислитель A.
[49:03.280 --> 49:05.280]  И собственно,
[49:05.280 --> 49:07.280]  если X появится
[49:07.280 --> 49:09.280]  на перечислителе,
[49:09.280 --> 49:11.280]  на выводе перечислителя A,
[49:11.280 --> 49:13.280]  то выводим один,
[49:13.280 --> 49:15.280]  если X
[49:15.280 --> 49:17.280]  появится
[49:19.280 --> 49:21.280]  на выводе
[49:21.280 --> 49:23.280]  перечислителя A,
[49:23.280 --> 49:25.280]  то выводим один,
[49:25.280 --> 49:27.280]  если X
[49:27.280 --> 49:29.280]  появится
[49:29.280 --> 49:48.280]  Если на выводе перечислителя
[49:48.280 --> 50:12.840]  а дополнительное, то выводим 0.
[50:12.840 --> 50:35.520]  Ну, собственно, либо там, либо там он появится, да? Ну и всё, так мы вычисляем характеристическую
[50:35.520 --> 50:49.720]  функцию. Ну вот, вот, собственно, критерии. Вот почему, так, косвенно, почему из-за того,
[50:49.720 --> 50:55.840]  что а перечислимо, не следует, что дополнительно перечислимо. Потому что, если это одновременно
[50:55.840 --> 51:01.520]  происходит, то разрешимо, но не всякое перечислимое множество разрешимо. То есть, если множество
[51:01.520 --> 51:07.840]  перечислимо, но неразрешимо, то само собой дополнение к нему уже перечислимо не будет,
[51:07.840 --> 51:14.480]  потому что иначе по критерии пост оно было бы разрешимо. А вот конструктивный пример
[51:14.480 --> 51:20.640]  перечислимого, но неразрешимого множества я приведу, мы построим, ну, позже. Вот.
[51:20.640 --> 51:35.080]  Вот теперь довольно сложная часть сейчас пойдёт. По крайней мере, почему-то на экзамене студенты,
[51:35.080 --> 51:43.920]  не только трошники, кстати, довольно сильные студенты, почему-то тут путаются и всякие глупости
[51:43.920 --> 51:55.000]  говорят. То есть, как бы я даже стал считать, что она для отличников, что ли. Вот. Такая типа сложная,
[51:55.000 --> 52:04.160]  потому что немногие в ней разбираются. Значит, смотрите. Ну, как мы выяснили, по критерии пост,
[52:04.160 --> 52:11.280]  даже разрешимость можно проверять через перечислимость. То есть, нужно какие-то признаки
[52:11.280 --> 52:21.600]  перечислимости. Как проверить перечислимость множества. И тут вот у нас вот такая теория.
[52:21.600 --> 52:49.920]  Давайте даже циркулируем. Пусть А под множество N перечислим. Тогда. Следующие. Пусть А под
[52:49.920 --> 52:55.920]  множество N. Вот просто. Вот так. Вот так. А под множество N. Тогда следующее утверждение эквивалентное.
[52:55.920 --> 53:21.760]  Первое. А перечислимо. Первое. Второе.
[53:21.760 --> 53:43.160]  Существует частичная функция из N в N. Такая, что область значений функции равна вычислимою.
[53:43.160 --> 53:55.120]  Я забыл отметить. Вычислимо. То есть, область определения вычислимой функции перечислима.
[53:55.120 --> 54:04.400]  Опять же, вообще говоря, нет. Не является разрешимой. Только перечислима. Третье.
[54:04.400 --> 54:31.200]  Существует частичная функция из N в N. Вычислимо. Такая, что range f равна. И так.
[54:31.200 --> 54:38.640]  Четвертое. Волшебный критерий. Значит, перечислимость звучит следующим образом.
[54:38.640 --> 54:57.360]  Существует тотально вычислимая функция из N в N. Тотально вычислимая. Такая, что
[54:57.360 --> 55:10.080]  range f равна. Ну, чаще всего, вот в эту сторону мы будем использовать. Если а перечислимо,
[55:10.080 --> 55:17.160]  то есть тотально вычислимая функция, область значений которой равна. Это нам очень часто будет
[55:17.160 --> 55:30.000]  удобно использовать. Ну и пятое. Значит, сейчас я, чтобы не запутаться, подсмотрю. Существует разрешимое
[55:30.000 --> 55:44.720]  N. B под множество N квадрат. Такое, что проекция на первую координату A равно
[55:44.720 --> 56:08.440]  проекция на первую координату B. Вот она. Зачем? Ну, удивительно, что они эквивалентны. Мы на самом
[56:08.440 --> 56:15.480]  деле как-то вот примерно так и будем доказывать на самом деле. Оно более сильное, безусловно,
[56:15.480 --> 56:22.080]  но все-таки иногда и это пригождается. А то удивительный факт заключает в том,
[56:22.080 --> 56:30.520]  что они эквивалентны, понимаете? Один действительно выглядит более сильным, но они одинаково на самом деле.
[56:30.520 --> 56:55.320]  А на сколько времени осталось? В 19.10 же, да? Просто довольно длинная теорема. Ну давайте.
[56:55.320 --> 57:24.480]  Значит, ну давайте один эквивалент на два. Сначала. Если A перечислимо,
[57:24.760 --> 57:31.920]  то как найти такую функцию, у которой область определения совпадает с A? А перечислимо.
[57:31.920 --> 57:48.520]  А тогда вот такая функция, я определю ее из чертой. Это не характеристическая, это так
[57:48.520 --> 57:57.880]  называема полухарактеристическая функция. Она выглядит следующим образом. Это единица,
[57:57.880 --> 58:11.880]  если x принадлежит A, и не определена, если x не принадлежит A. Полухарактеристическая функция
[58:11.880 --> 58:29.720]  называется. Она вычислима. Почему? Как вычислить, какой алгоритм вычисляет эту функцию? Значит,
[58:29.720 --> 58:41.320]  смотрим на вывод перечислителя. Если там появился x, то пишем единицу. Ну короче,
[58:41.320 --> 58:48.840]  ждем, пока появится x. Если x не принадлежит A, то он никогда на ленте не появится. Но за
[58:48.840 --> 58:54.560]  конечное время выяснить не сможем. Поэтому это неопределенное значение. То есть там никогда
[58:54.560 --> 59:01.640]  машина зациклится, будет бесконечно ждать, пока появится не принадлежащий множество A, а элемент,
[59:01.640 --> 59:08.720]  и поэтому здесь неопределенное значение. Поняли, да? То есть по сути, алгоритм заключается в том,
[59:08.720 --> 59:15.840]  что мы выводим все все перечисляем все элементы A и ждем, пока нужны нам появиться. Если появится,
[59:15.840 --> 59:35.760]  пишем один, если не появится, ничего не делаем. Все. Вот. Она вычислима. Кстати, отсюда же,
[59:35.760 --> 59:42.600]  почему я так акцентирую внимание на вычислимость каких-то функций? Потому что давайте тот же самый
[59:42.600 --> 59:49.440]  статистический аргумент применим. Сколько у нас алгоритмов? Счетно много, да? Потому что
[59:49.440 --> 59:55.960]  характеристи... вычислимым функциям соответствует алгоритм. А сколько у нас всего функций из N в N?
[59:55.960 --> 01:00:03.920]  Континум. Поэтому, опять же, вычислимых функций их мало, вот. И поэтому каждую нужно доказывать,
[01:00:03.920 --> 01:00:19.000]  что она вычислима. Вот. Значит, ну, в обратную сторону, если существует вычислимая F из N,
[01:00:19.000 --> 01:00:32.560]  частичная функция из N в N, такое, что domain F равна... Пускай мы знаем, что существует. Почему?
[01:00:32.560 --> 01:00:45.520]  Почему тогда перечислима? Как перечислить область определения функций? Как вы думаете? Как я вам
[01:00:45.520 --> 01:00:53.880]  уже говорил, вы за конечное время не выясните, закончится ли вычисление или нет. То есть понять,
[01:00:53.880 --> 01:01:01.600]  как бы, алгоритмически конкретная точка, что конкретная... Почему я ваше обращаю внимание?
[01:01:01.600 --> 01:01:10.080]  Я сейчас пытаюсь построить не перечислитель, а разрешитель этого множества. То есть алгоритм,
[01:01:10.080 --> 01:01:16.960]  который по точке выясняет, принадлежит или нет этому множеству. Это нельзя сделать. Разрешитель,
[01:01:16.960 --> 01:01:27.400]  вообще говоря, построить. Перечислитель можно. Сейчас я расскажу. Значит... Да, нам нужно
[01:01:27.400 --> 01:01:40.360]  перечислитель, поэтому сейчас его построим. Значит, смотрите. Что мы можем сделать? Вот тут
[01:01:40.360 --> 01:01:52.920]  нужно определить вот такую штуку. Такие скобочки будут обозначать тотально вычислимую нумерацию пар
[01:01:52.920 --> 01:02:14.680]  натуральных чисел. Это вот такая штука. Сейчас я перепишу вам формулу. Вот это тотально вычислимая
[01:02:14.680 --> 01:02:32.920]  биекция из n² в n. Тотально вычислимая, потому что вот формула. Тотально вычислимая биекция
[01:02:32.920 --> 01:02:58.800]  из n² в n. Вот. Как мы здесь будем работать? Смотрите. По паре. Значит, смотрите,
[01:02:58.800 --> 01:03:14.160]  что делаем. Берем элемент, собственно говоря, к натуральный и... А, да, забыл сказать. Прошу прощения.
[01:03:14.160 --> 01:03:26.040]  Смотрите. Вот. Поскольку биекция, то вот для каждого натурального можно представить единственное
[01:03:26.040 --> 01:03:37.560]  k такое, что k это номер пары m, n, да? Так, ребят? Отсюда есть обратная функция. Она тоже вычислимая.
[01:03:37.560 --> 01:03:55.680]  Это n, это p1 от k, а m это p2 от k. Вот эти обозначения потом понадобятся дальше. Мы это тоже будем
[01:03:55.680 --> 01:04:04.240]  использовать. То есть, это p как бы обозначает проектор, но этот проектор странный. Обратите
[01:04:04.240 --> 01:04:12.920]  внимание. Проектор обычно функции из, там, не знаю, из a², да? Ну, из lz, из a². В данном случае этот
[01:04:12.920 --> 01:04:25.720]  проектор из n-ven. Он по номеру пары выясняет какая пара и выдает нужную компоненту этой пары. То есть,
[01:04:25.720 --> 01:04:32.520]  это функция из n-ven, тотально вычислимая. Как выяснить по номеру пары, какова пара имеет данный
[01:04:32.520 --> 01:04:41.400]  номер? Ну, можно тупо перечислять эти пары, считать их номера, сравнивать и потом найти, да?
[01:04:41.400 --> 01:04:54.560]  Но по-другому вроде даже непонятно, как еще это делать. В натуральных числах? Не знаю,
[01:04:54.560 --> 01:05:03.120]  честно говоря. Я не вижу, как их решать в натуральных числах, честно говоря. Ну, это же,
[01:05:03.120 --> 01:05:08.720]  нет, то, что это биекция, это легко проверить, на самом деле. Я не хочу просто сейчас проверять,
[01:05:08.720 --> 01:05:18.260]  но это довольно легко проверять, что биекция. Как проверить, что это биекция, что у любого
[01:05:18.260 --> 01:05:24.200]  натурального… Ну, сюррективность надо показать, что у нас тут, собственно говоря,
[01:05:24.200 --> 01:05:30.800]  все натуральные числа встречаются. И инъективность. Инъективность там проверяется довольно просто.
[01:05:30.800 --> 01:05:49.800]  Ну, сюррективность… Я уже забыл, знаете, как мы делаем, мы просто в первом семестре даем вот
[01:05:49.800 --> 01:05:57.560]  такую задачку, там студенты нам решают ее. А во следующем мы просто используем этот факт. Я
[01:05:57.560 --> 01:06:04.120]  сейчас забыл, как… Но студенты обычно быстро догадываются, как тут сюррективность показать,
[01:06:04.120 --> 01:06:18.120]  что существует такое натуральное, что существует пара с таким номером. Ну вот, то есть условный
[01:06:18.120 --> 01:06:25.360]  проектор работает следующим образом. Он пока вычисляет пару с номером таким, а потом выдает
[01:06:25.360 --> 01:06:31.280]  компоненты этой самой пары. Это тотальная отчисленная функция из n-th. Это тоже тотальная
[01:06:31.280 --> 01:06:42.400]  отчисленная функция из n-th. Вот. Значит… Ну вот теперь. Вот теперь. В бесконечном цикле
[01:06:42.400 --> 01:07:02.760]  перечисляем k, kaizen. Находим пары с номером k. Находим пары.
[01:07:12.400 --> 01:07:35.240]  Mn из n-квадрат. Пару. Mn из n-квадрат. Такое, что… Нет, вот так обозначим xk. Такое,
[01:07:35.240 --> 01:07:50.120]  что xk… Номер xk равен x… Нет, x… Нет, k использовано. Но давайте l. l, l, l. xk равен l.
[01:07:50.120 --> 01:08:15.240]  А потом делаем вот какое действие. Затем… Затем. Значит, запускаем алгоритм вычисляющие и делаем
[01:08:15.240 --> 01:08:24.240]  k шагов этого алгоритма. Почему именно пара понадобилась? Вообще говоря, по входу вы не
[01:08:24.240 --> 01:08:30.200]  сможете понять, закончится ли этот алгоритм. Но k шагов проделать этого алгоритма и выяснить,
[01:08:30.200 --> 01:08:40.000]  что он там выдал или не выдал, вы сможете. Правильно? Так, ребят. Запускаем алгоритм.
[01:08:40.000 --> 01:08:55.800]  Алгоритм. Вычисление f от x и делаем k его шагов.
[01:09:10.000 --> 01:09:33.720]  К первых его шагов. Если алгоритм за k шагов либо раньше остановился, либо за k шагов вывел ответ,
[01:09:33.720 --> 01:10:00.480]  если алгоритм на входе x за меньше либо равно чем k шагов вывел ответ, то, собственно,
[01:10:00.480 --> 01:10:15.960]  нам нужно перечислить domain, перечисляем x, печатаем x, то печатаем x. Иначе переходим
[01:10:15.960 --> 01:10:24.360]  к следующему числу, к следующему, к l плюс один. Понимаете, да? Иначе переходим к следующему l.
[01:10:24.360 --> 01:10:48.480]  Всё. Вот перечислитель области определения. Понятно, да? Также можно, кстати, перечислить
[01:10:49.480 --> 01:10:58.120]  вычислимые функции. Вы не сможете, собственно, если функция x не определена в какой-то точке,
[01:10:58.120 --> 01:11:05.520]  выяснить это за конечное число шагов. Но, опять же, вот таким же образом вы перечисляете область значений
[01:11:05.520 --> 01:11:14.800]  функции. То есть, если алгоритм на входе x за k шагов вывел ответ, то этот ответ, собственно,
[01:11:14.800 --> 01:11:22.080]  перечисляется. Правильно? Иначе следующий. Итак, мы перебираем все пары натуральных чисел. Поняли?
[01:11:22.080 --> 01:11:50.440]  Ну, берем l плюс один, опять вычисляем пару с номером l плюс один.
[01:11:50.440 --> 01:12:06.840]  Новый x, новый k. Ну да, но там же другая пара будет. Вот точно другая будет. Ищем пару с
[01:12:06.840 --> 01:12:15.640]  номером l плюс один. Опять запускаем на входе с первой компоненты, а вторая компонент — количество
[01:12:15.640 --> 01:12:28.520]  шагов алгоритма, который мы делаем. Опять, если выход есть, то печатается, собственно, x, а иначе
[01:12:28.520 --> 01:12:39.280]  ничего не делает следующая l плюс два и так далее. Ну как? Мы же просто перечисляем все входы,
[01:12:39.480 --> 01:12:56.840]  по сути, и все длительности алгоритмов. Так? Ну да. Ну да, да, да. То есть, мы все входы перечисляем и
[01:12:56.840 --> 01:13:05.200]  все количество шагов возможные, которые можно сделать. Если к пределу перейти. Но алгоритм,
[01:13:05.200 --> 01:13:23.280]  как вы понимаете, к пределу за конечное время перейти не сможет. Вот. Да, и все входы перебрали.
[01:13:23.280 --> 01:13:33.320]  Ничего не выйдет, да. Если и на точке x не определено, то какое k бы там не ставим,
[01:13:33.320 --> 01:13:42.240]  мы ничего не напечатаем. Поэтому мы, собственно, в домейн это и не запишем. Вот. А если это принадлежит
[01:13:42.240 --> 01:13:48.760]  домейна, то за конечное число шагов x принадлежит домейна, за конечное k мы это выведем и, соответственно,
[01:13:48.760 --> 01:13:54.960]  так или иначе рано или поздно это будет напечатано. Поэтому это действительно перечислитель. Вот.
[01:13:54.960 --> 01:14:11.760]  Понятно, да? Хорошо. Это один эквивалент на два. Один эквивалент на три. Ну так оно вот почему-то и
[01:14:11.760 --> 01:14:19.200]  доказывается, собственно говоря, что все сравнивается с вот этими состояниями. Вот.
[01:14:19.200 --> 01:14:45.120]  Ну, если A перечислимо, то существует вычислимая функция f, у которой range равна.
[01:14:49.200 --> 01:15:16.760]  Как это сделать? Ублазначение. Ублазначение. Да, в принципе, правильно.
[01:15:16.760 --> 01:15:29.880]  Собственно, грубо говоря, идея, да, такое у нас получается. То есть вот такая f от x равна x,
[01:15:29.880 --> 01:15:43.520]  если x принадлежит, и не определена иначе, если x не принадлежит. Будет вычислимая функция. Почему?
[01:15:43.520 --> 01:16:01.080]  Вычислима. Почему? Опять? Я вот как с полухарактеристической функцией. Аналогично, да, рассуждение.
[01:16:01.080 --> 01:16:08.320]  То есть если ждём x, вот у нас на входе x, ждём x на перечислитель. Если x появился,
[01:16:08.320 --> 01:16:15.000]  печатаем его. Ну, то есть выдаём ответ x. Если не появился, то мы ждём бесконечно долго,
[01:16:15.000 --> 01:16:36.000]  и, соответственно, вычисление выцикливается. Поняли? Вот. Ну, если существует f из n в n частично
[01:16:36.000 --> 01:16:57.720]  вычислимое, такая что range f равна в обратную сторону, то почему a перечислимо? На самом деле
[01:16:57.720 --> 01:17:05.040]  аналогичное доказательство, то есть перечислитель строится так же. То есть перечисляем в бесконечном
[01:17:05.040 --> 01:17:21.120]  цикле вот эти номера l. Poel восстанавливаем в пару с таким номером. А потом делаем на входе x
[01:17:21.120 --> 01:17:30.280]  первые ка шагов, и если ответ выведен, то этот ответ, собственно, и перечисляем. То есть единственная
[01:17:30.280 --> 01:17:38.160]  разница с предыдущим доказательством. Там мы перечисляли тот x, на котором ответ был выведен,
[01:17:38.160 --> 01:17:49.520]  а там ответ, который мы получили, был перечислять. Поняли? Он выведет же f от x, значит мы перечислим.
[01:17:49.520 --> 01:18:05.080]  Вот так. Вам непонятно, да? Вам пояснить? Ну, это же тоже самое же. Ну, смотрите. То же самое. То есть и потом
[01:18:05.080 --> 01:18:15.520]  восстанавливаем пару poel, так? Потом на входе x делаем ка шагов алгоритма. Если за ка шагов
[01:18:15.520 --> 01:18:26.080]  на входе x ответ выведен, то печатаем этот ответ. Ну, выводим на перечислитель этот самый ответ.
[01:18:26.080 --> 01:18:34.960]  Если не выведен, ничего не делаем. Следующее натуральное число смотрим. Так далее. Если f от x
[01:18:34.960 --> 01:18:39.960]  не определено в какой-то точке, то мы ничего не выведем ни за какое натуральное количество шагов.
[01:18:39.960 --> 01:18:45.360]  Правильно? Если оно определено, то за конечное количество шагов оно будет выведено, соответственно,
[01:18:45.360 --> 01:18:55.840]  f от x будет напечатан, поэтому это перечисляет все значения области значения f от x. Все числа
[01:18:55.840 --> 01:19:14.400]  области значения f от x. Вот. Аналогично. Два следует один. Хорошо. Так. Опа. Опа. Сколько у нас
[01:19:14.400 --> 01:19:25.640]  время? Четыре минуты. Блин. Так. Ну ладно. Ну, один, четыре, четыре, один, наверное, все-таки.
[01:19:25.640 --> 01:19:34.600]  Блин, не хочу торопиться. Так, ребята, давайте вот как сделаем. Один эквивалент на один,
[01:19:34.600 --> 01:19:42.320]  эквивалент на четыре, четыре, эквивалент на один. В одну сторону, надеюсь, вам понятно,
[01:19:42.320 --> 01:19:47.520]  ребята, смотрите. Если есть тотально вычислимая функция, для которой range f равно a,
[01:19:47.520 --> 01:19:56.480]  а перечислимая — это понятно, почему. Но мы уже доказали, что область значений вычислимой
[01:19:56.480 --> 01:20:03.320]  функции перечислима, и область определений вычислимой функции перечислима. Поэтому,
[01:20:03.320 --> 01:20:10.000]  собственно, если есть такая функция, для которой range f равно a, то а точно перечислимое множество.
[01:20:10.000 --> 01:20:18.360]  А вот в прямую сторону, то есть, если перечислимая, то есть, тотально вычислимая функция. Вот это
[01:20:18.360 --> 01:20:26.160]  интересная часть. И здесь я не хочу торопиться. Давайте вот 1,5, 5,1. Там закончу в следующий раз.
[01:20:26.160 --> 01:20:46.720]  Вот так. Один эквивалент на пять. Пусть а перечислимо.
[01:20:56.160 --> 01:21:07.720]  Как найти разрешимое множество пар натуральных чисел, для которых а будет проекция? Ну давайте.
[01:21:07.720 --> 01:21:30.880]  Что мы сделаем? Ну, на самом деле, да. То есть, в данном случае, какое разрешимое множество пар?
[01:21:30.880 --> 01:21:49.600]  B это xk. Это множество пар из натуральных чисел. Такое, что перечислитель
[01:21:49.600 --> 01:22:18.400]  собственно, именно разрешимое же нужно множество пар. Перечислитель для а выведет x за меньше
[01:22:18.400 --> 01:22:34.320]  либо равно, чем k шагов. Ну давайте даже за равно, чем k шагов. Чтобы немножко так. Можно так, можно так.
[01:22:34.320 --> 01:22:46.160]  В любом случае разрешимое свойство, правда? Мы можем проделать k шагов перечислителя и бы посмотреть
[01:22:46.160 --> 01:22:54.960]  вывел ли x. Если x вывелось, то это единичка. Характеристическая функция будет равна единичке.
[01:22:54.960 --> 01:23:06.240]  Мы это вычислим. А если нет, то ноль. Вот это разрешимое множество пар натуральных чисел.
[01:23:06.240 --> 01:23:11.240]  Проекция B это наша А.
[01:23:16.240 --> 01:23:32.240]  Оно всё. То есть, если А перечислим, то она является проекцией на первую координату какого-то разрешимого множества.
[01:23:32.240 --> 01:23:46.240]  В обратную сторону проекция множества разрешима. Как перечислить проекцию?
[01:23:46.240 --> 01:24:02.240]  Да, B разрешима. Да, всё правильно. То есть алгоритм работает так. Перечисляем циклы по всем натуральным L.
[01:24:02.240 --> 01:24:14.240]  Значит, Poil восстанавливаем пару с таким номером, а потом проверяем B разрешима. Принадлежит ли эта пара B?
[01:24:14.240 --> 01:24:26.240]  А, ребят, алгоритм на то есть. Значит, если принадлежит, то выводим первую компоненту. Если не принадлежит, ничего не делаем.
[01:24:26.240 --> 01:24:36.240]  Переходим к следующей паре. Итак, мы перебираем все пар натуральных чисел. Поняли? И перечислим первые компоненты.
[01:24:36.240 --> 01:25:00.240]  А, ребят? Всё, поняли? Ладно, блин. Давайте тогда, раз вы не успеваете это понимать, давайте я повторю это 1-5-5-1 и 1-4-4-1. Это в следующий раз повторю. Всё.
