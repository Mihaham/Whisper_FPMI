[00:00.000 --> 00:13.420]  Так, добрый вечер, давайте начинать.
[00:13.420 --> 00:17.480]  Мы переходим к потокам, которые в каком-то смысле обобщают
[00:17.480 --> 00:19.340]  пара сочетаний, которые были в прошлый раз, как вас
[00:19.340 --> 00:20.340]  мало.
[00:20.340 --> 00:27.360]  Будем изучать максимальные потоки в сетях.
[00:27.360 --> 00:31.640]  Идея примерно следующая.
[00:31.640 --> 00:32.920]  Какую задачу мы будем решать?
[00:32.920 --> 00:34.560]  Представьте, что у нас есть какой-то ориентированный
[00:34.560 --> 00:39.200]  граф, в котором две вершины отдельно выделены, s и t.
[00:39.200 --> 00:44.560]  И нам нужно передавать водичку из s в t, в воду, нефть или
[00:44.560 --> 00:47.760]  может быть машинки надо, чтобы ехали как-то оптимально
[00:47.760 --> 00:49.800]  из s в t.
[00:49.800 --> 00:52.360]  При этом в графе есть какие-то ребра ориентированные.
[00:52.360 --> 01:03.240]  Какие-то ребра, по которым можно пускать водичку, и
[01:03.240 --> 01:06.200]  на каждом ребре написана некая пропускная способность,
[01:06.200 --> 01:08.040]  некое ограничение на то, сколько водички может
[01:08.040 --> 01:10.080]  течь по данному ребру в единицу времени.
[01:10.080 --> 01:21.680]  Какие числа написаны на ребрах?
[01:21.680 --> 01:25.080]  Это значит, что вдоль этого ребра в одну единицу времени
[01:25.080 --> 01:28.080]  может течь не больше чем семь единичек водички.
[01:28.080 --> 01:29.960]  Здесь не больше чем восемь, здесь не больше чем одна
[01:29.960 --> 01:30.960]  и так далее.
[01:30.960 --> 01:34.840]  Наша задача как-то таким образом распределить воду,
[01:34.840 --> 01:38.120]  чтобы она текла из s в t так, чтобы ее суммарно перетекало
[01:38.120 --> 01:39.400]  на максимально возможное количество.
[01:39.400 --> 01:42.520]  Вот, например, здесь что можно сделать?
[01:42.520 --> 01:47.320]  Здесь, наверное, какой-то неинтересный пример получился,
[01:47.320 --> 01:50.680]  потому что у меня есть верхняя часть графа и нижняя часть
[01:51.480 --> 01:53.320]  gagner eingрафа, верхняя цепочка и нижняя.
[01:53.320 --> 01:55.900]  Понятно, что, суммарно, по верхней течет максимум
[01:55.900 --> 01:58.560]  одна единичка воды, потому что вот здесь вот ограничение
[01:58.560 --> 02:01.220]  один… gigabytes stain, затянутое воду, значит, суммарно здесь
[02:01.220 --> 02:03.040]  всего протекает максимум идиница, потому что здесь
[02:03.040 --> 02:06.020]  вот... узкая горлашка… мы не можем больше, чем одну
[02:06.020 --> 02:07.100]  единицу здесь протолкнуть.
[02:07.100 --> 02:09.440]  Например, можно взять вот такой вот такой какой-нибудь
[02:09.440 --> 02:10.440]  путь, давать руку, personalization runner.
[02:10.440 --> 02:12.120]  И вдоль него протолкнуть единицу потока.
[02:12.120 --> 02:16.280]  Тут можно взять три единицы потока протолкнуть вот
[02:16.280 --> 02:17.380]  здесь, вот по этому пути.
[02:17.380 --> 02:20.600]  Протолкнуть сразу по троечке.
[02:20.600 --> 02:27.160]  Ну вот, видимо это будет максимальный поток, то есть больше нельзя, и в общем случае
[02:27.160 --> 02:30.400]  собственно задача так и ставится. Есть какая-то транспортная сеть, то есть
[02:30.400 --> 02:36.200]  ориентированный граф с ограничениями на ребрах, и нужно пустить поток максимальной
[02:36.200 --> 02:40.000]  величины, то есть чтобы как можно больше водички текло из С в Т, но при условии,
[02:40.000 --> 02:43.720]  что поток на каждом ребре не превосходит пропорционную способность этого ребра.
[02:43.720 --> 02:53.720]  Ну вот, такая идеиная постановка, давайте займемся формализмом. Что такое сеть,
[02:53.720 --> 03:09.880]  сеть или транспортная сеть? Это граф ориентированный, выделенные в нем вершины С и Т, а также,
[03:09.880 --> 03:14.200]  ну собственно, вот эта вот весовая функция, которая каждому ребру ставит в соответствие
[03:14.200 --> 03:23.480]  некое число. Пусть это будет функция С. Значит, здесь G, ну давайте считать, что это ориентированный
[03:23.480 --> 03:34.120]  граф. Дальше С и Т, две различные вершины из множества V от G, две различные вершины графа,
[03:34.120 --> 03:43.640]  значит я их буду называть соответственно сток и исток. Вот, а С это функция, которая, как я уже
[03:43.640 --> 03:48.520]  сказал, каждому ребру ставит в соответствие какую-то пропорционную способность. Формально это просто
[03:48.520 --> 03:58.200]  функция из Е, ну давайте скажем в целые неотрясательные числа. Ну, капость, наверное,
[03:58.200 --> 04:06.200]  всегда не отрицательно. Да, и соответственно, это называется пропускные способности ребер,
[04:06.200 --> 04:18.000]  пропускные способности ребер. Вот, я для краткости буду говорить capacity, собственно,
[04:18.000 --> 04:27.400]  от английского capacity, вместимость ребра, сколько можно вдоль ребра протолкнуть наши водички.
[04:27.400 --> 04:40.240]  Ну вот, вроде ничего хитрого пока. Значит, дальше я буду считать, если что, если нужно,
[04:40.240 --> 04:46.640]  я могу в принципе эту функцию С продлить не только на ребра графа, могу продлить на потенциально
[04:46.640 --> 04:52.920]  все пары вообще вершин. То есть я могу для каждой пары вершин сказать, что если там есть
[04:52.920 --> 04:58.200]  ребро, то capacity такое же, собственно, как на ребре написано, а иначе, если нет ребра в графе, то я
[04:58.200 --> 05:02.840]  могу считать, что на нем нулевая capacity. Например, я могу сказать, что для вот этой вот пары вершин,
[05:02.840 --> 05:09.320]  ну я всегда могу ввести ребро нулевой capacity. Понятно, это граф никак не меняет, водичка по нему
[05:09.320 --> 05:13.800]  все равно течь не может. Вот, но формально можно считать, что вот это вот С определено не только
[05:13.800 --> 05:18.600]  для ребер, но и вообще для всех пар вершин. Потому что если ребра нет, то можно считать,
[05:18.680 --> 05:22.760]  что capacity нулевая. Хорошо, что такое тогда поток?
[05:22.760 --> 05:37.520]  Значит, поток вот в этой вот нашей сети, поток в сети, это такая функция, давайте сразу скажу,
[05:37.520 --> 05:51.400]  из v квадрат в целые числа, такая что? Во-первых, ну самое естественное требование, что поток по
[05:51.400 --> 05:58.840]  ребру всегда не превосходит capacity, значит, для любой пары вершин, увы, поток, текущий вдоль
[05:58.840 --> 06:05.280]  ребра, не превосходит, собственно, capacity этого ребра. Вот, но здесь как раз играет то, что я сказал,
[06:05.280 --> 06:09.640]  что я функцию С могу продлить на v квадрат, и в случае отсутствия ребра здесь написано,
[06:09.640 --> 06:22.400]  что f от ув не больше нуля. Второе, ну давайте скажу антисимметричность. Значит, я скажу,
[06:22.400 --> 06:28.480]  что для любой пар вершин, ув, поток, текущий вдоль ребра, ув, равен минус потоку, текущему
[06:28.480 --> 06:41.680]  вдоль противоположного ребра, что-то называется антисимметричность. Формально просто давайте
[06:41.680 --> 06:49.520]  скажем, что если вдоль ребра течет f единиц потока, то вдоль обратного течет минус f, ну как это можно
[06:49.520 --> 06:57.600]  понимать, да, не знаю, вот у вас есть две станции, которые передают друг другу нефть, вот если одна
[06:57.600 --> 07:07.080]  другой передала f, то это как бы то же самое, что вторая первой должна как бы минус f. Вот, ну это
[07:07.080 --> 07:12.040]  значит будет играть, пока давайте просто формально так запишем, что всегда если течет, как бы течет поток
[07:12.040 --> 07:17.400]  в одну сторону, то всегда в обратную течет отрицательность. Так, ну и третье, свойство
[07:17.400 --> 07:27.120]  сохранения потока, значит, для любой вершины отличной от ста и стока и стока, сумма исходящих
[07:27.120 --> 07:45.680]  потоков равна нулю. Равна нулю. Ага, это и так открыто, ну вот. Вот, значит свойство сохранения.
[07:45.680 --> 08:01.760]  Так, ну что хотелось бы этой формулой выразить? Хотелось бы выразить следующее, что если у вас
[08:01.760 --> 08:06.800]  v, эта вершина отличная от начала и конца, то в ней как бы ничего не скапливается, то есть все,
[08:06.800 --> 08:13.560]  что в нее поступило, вся водителька, которая в нее поступила, должна вытечь. Вот, ну то есть другими
[08:13.560 --> 08:19.080]  словами, да, если здесь втекает какая-нибудь альфа-бета-гамма потока, а здесь вытекает а и b,
[08:19.080 --> 08:26.000]  то мне хотелось бы, чтобы альфа-бета-гамма в сумме равнялись а плюс b. Да, ну то есть как бы,
[08:26.000 --> 08:29.480]  что вода не застревает вот в промежуточных вершинах, она если в вершину пришла, то она
[08:29.480 --> 08:34.840]  дальше течет. Ну иными словами, у нас вот здесь вот нету таких резервуаров для накопления. У нас
[08:34.840 --> 08:40.320]  только здесь есть как бы скважина, которая качает воду, и здесь есть хранилище, куда, как бы, где вода
[08:40.320 --> 08:47.960]  складывается. Вот, а посередине мы ее накапливать не можем. Вот, ну хочется выразить вот так, но как
[08:47.960 --> 08:52.160]  раз в частности за счет того, что я ввел антисимметричность потока, я мог бы сказать
[08:52.160 --> 08:56.840]  просто следующее. Я могу, значит, вот эти вот серебра развернуть, тогда на них написано минус
[08:56.840 --> 09:04.040]  альфа, минус бета, минус гамма, вот, и вот эта формула, что сумма всех исходящих потоков из вершины
[09:04.040 --> 09:09.520]  равна нулю, как раз вот этой мы и равносильно, да, потому что сумма всех исходящих сейчас это a плюс b
[09:09.520 --> 09:16.880]  минус альфа, минус бета, минус гамма. Вот, и оно равно нулю по соссохранению потока. Понятно, что это
[09:16.880 --> 09:22.720]  эквивалентные формулы, значит, вот эта вот запись как раз и означает, что водичка в вершинках не
[09:22.720 --> 09:33.480]  скапливается. Вот это эквивалентное равенство, а это есть соссохранение. Понятно это? Ну вот. Так, хорошо.
[09:33.480 --> 09:43.040]  Ну и давайте, значит, скажем сразу, что в таком случае величиной потока
[09:43.040 --> 09:50.080]  называем
[09:50.080 --> 09:58.400]  суммарное количество потока, которое вытекает из s.
[09:58.400 --> 10:19.760]  Сколько вот суммарно из s выходит, это эта величина потока. Так, хорошо, хорошо. Вот. Мы хотим
[10:19.760 --> 10:27.280]  разработать какой-то алгоритм поиска максимального потока. Чтобы его сделать, я веду еще одно
[10:27.280 --> 10:41.760]  определение остаточной сети. Значит, пусть f это поток в сети g, тогда остаточная сеть
[10:41.760 --> 10:54.640]  g с индексом f, значит, эта сеть, ну, буквально остающаяся после того, как мы пропустили f потока.
[10:54.640 --> 11:03.320]  Формально я запишу просто следующее. Для любого, для любой пары вершин uv, capacity, давайте
[11:03.320 --> 11:09.440]  напишу так, остаточная пропускная способность ребра uv просто равна изначальной capacity минус
[11:09.440 --> 11:20.360]  величина потока f uv. Ну то есть как бы я знаю, что вдоль каждого ребра может течь максимум c,
[11:20.360 --> 11:25.600]  единиц потока, но при этом f уже течет. Значит, осталось пустить максимум вот столько. Ну вот,
[11:25.600 --> 11:31.920]  давайте тогда просто для каждого ребра напишем на нем вот такую capacity, остаточную, и это будет
[11:31.920 --> 11:37.720]  собственно наша остаточная сеть. Просто по сути вычли из capacity потоки. Ну, понятно, что эта
[11:37.720 --> 11:43.520]  штука не отрицательна по первому свойству потока, что поток всегда не больше, чем capacity. Значит,
[11:43.520 --> 11:49.760]  у меня все остаточные capacity всегда не отрицательны, и это будет корректное определение сети. Вот,
[11:49.800 --> 11:56.400]  ну здесь еще давайте добавлю, что в вот этой вот остаточной сети GF я ребра нулевой capacity
[11:56.400 --> 12:16.520]  удаляю. При этом ребра с нулевой capacity в GF не добавляются. Ну то есть если вот это
[12:16.520 --> 12:22.960]  вот выражение равно нулю, да, ну как бы я понимаю, что при ребро счет 0 потока, наоборот, по нему
[12:22.960 --> 12:27.120]  можно пустить 0 потока, то есть ничего вообще опускать нельзя. Давайте его выкинем из нашего
[12:27.120 --> 12:32.840]  графа, как бы его нет. Понятно опять же, что от этого ничего не изменится, потому что и так это ребро
[12:32.840 --> 12:38.920]  бесполезно, по нему ничего нельзя пустить. Давайте его удалим. Вот, значит, и оказывается, что,
[12:39.160 --> 12:51.000]  оказывается, что поток F максимален, то есть его величина максимальна, если и только если в
[12:51.000 --> 13:16.920]  остаточной сети JSONXMF нет пути из FFT. Вот, то есть чтобы искать максимальный поток, можно делать
[13:16.920 --> 13:22.760]  следующее, можно просто итеративно многократно строить остаточную сеть JSONXMF, пытаться находить
[13:22.760 --> 13:28.960]  в ней какой-то путь из FFT. Вот, если мы нашли какой-то путь, вот давайте вот в GF, я нашел какой-то путь
[13:28.960 --> 13:36.520]  из FFT. Поскольку это какой-то путь в остаточной сети, и все ребра здесь имеют положительную
[13:36.520 --> 13:41.160]  остаточную capacity, то я могу, ну там единичку потока точно могу вдоль этого пути протолкнуть,
[13:41.160 --> 13:45.960]  потому что все capacity положительно, значит хотя бы один, поэтому хотя бы единичку потока вот вдоль
[13:45.960 --> 13:52.440]  этого пути я еще могу протолкнуть. И вот если я здесь сделаю везде F плюс равно один, то есть вдоль
[13:52.440 --> 13:58.880]  этого пути протолкну единицу потока, то у меня увеличится поток в исходной сети, понятно,
[13:58.880 --> 14:04.840]  потому что из S что-то дополнительно вытекло, и поток увеличится. Вот, вот оказывается,
[14:04.840 --> 14:14.560]  что этого достаточно, что достаточно насытить все пути в остаточной сети, и вот если их больше нет
[14:14.560 --> 14:19.960]  в остаточной сети, то оказывается поток максимален. Ну это отчасти похоже как раз на просочетание,
[14:19.960 --> 14:24.000]  что просочетание максимально, если нет увеличивающих путей в вдольном графе. То же самое
[14:24.000 --> 14:31.440]  здесь, поток максимален, если в остаточной сети просто нет никакого пути из FFT. Вот, значит здесь
[14:31.440 --> 14:38.200]  есть важный трюк, почему, собственно, я ввожу в частности отрицательное значение потока. Это за
[14:38.200 --> 14:43.000]  следующим, что в такой постановке мне нужно как бы уметь отменять поток текущий вдоль ребра,
[14:43.000 --> 14:49.400]  потому что вот, например, вот пусть у меня каким-то образом в какой-то момент времени пустился
[14:49.400 --> 14:54.280]  единица поток вдоль какого-то ребра, но она оказывается неправильная, то есть в оптимальном,
[14:54.280 --> 14:58.800]  в правильном решении вдоль этого ребра ничего течет не должно. Ну, например, давайте вот такой
[14:58.800 --> 15:07.880]  пример рассмотрю. Вот пусть такой граф у меня будет. Вот такой граф, все копасти единичные.
[15:07.880 --> 15:15.520]  Пусть какой-то дурак пришел и пустил единицу потока вдоль вот такого пути. Ну, понятно,
[15:15.520 --> 15:19.120]  что это не оптимально, надо было пустить единицу здесь, единицу здесь. ну вот пусть внезапно как бы
[15:19.120 --> 15:26.040]  кто-то пустил единицу потока здесь. Это корректный поток величины 1. Чтобы его добить до правильного,
[15:26.040 --> 15:31.920]  до максимального потока величины 2, мне хотелось бы как-то отменить поток текущий вдоль вот
[15:31.920 --> 15:35.960]  этого ребра, потому что в правильном решении мне нужно было бы пустить здесь, и здесь поток,
[15:35.960 --> 15:42.280]  а вот тут вот отменить. Но для этого как раз у меня вот по такой формуле в
[15:42.280 --> 15:46.360]  остаточной сети возникает обратное ребро вот к этому вот. У меня возникает на
[15:46.360 --> 15:49.760]  самом деле вот такое ребро. Ну почему? Потому что у меня было изначально, давайте
[15:49.760 --> 15:54.520]  перерисую, у меня было изначально ребро с капастью 1 и с потоком 1,
[15:54.520 --> 16:00.600]  обратное у меня было с капастью 0 и с потоком минус 1,
[16:00.600 --> 16:03.880]  потому что по обратному течет отрицательный поток. И вот если я теперь
[16:03.960 --> 16:12.200]  вычту f и c, то у меня остаточная капасти будет как раз 1. На 0 минус минус 1 это 1.
[16:12.200 --> 16:16.080]  И значит как раз в остаточной сети у меня появляется вот такое обратное ребро,
[16:16.080 --> 16:21.120]  вдоль которого я смогу как раз найти вот такой вот путь, использовав вот это вот
[16:21.120 --> 16:25.640]  ребро снизу вверх. И это как раз означает, что я отменяю ту единицу потока, которая
[16:25.640 --> 16:29.960]  текла сверху вниз, с помощью, наоборот, единицы потока текущего сверху вниз.
[16:29.960 --> 16:37.040]  Ну, короче, вы поняли, такое отменяю таким. Ну и видно, что как бы сумма двух вот таких
[16:37.040 --> 16:41.080]  вот потоков вдоль такого пути и вдоль такого пути как раз вот здесь сократится,
[16:41.080 --> 16:45.560]  1 минус 1 будет 0, и останется поток вдоль верхней дужки и вдоль нижней дужки.
[16:59.960 --> 17:10.160]  Ну, не совсем, потому что, смотрите, вот тут у вас понятно, что поток не больше единицы сверху вниз.
[17:10.160 --> 17:20.920]  Значит обратный поток хотя бы минус 1, наоборот. То есть как бы там симметрично будет
[17:20.920 --> 17:29.200]  неравенство возникать из этого. Так, то есть еще раз мораль. Отрицательные потоки нужны для того,
[17:29.200 --> 17:35.560]  чтобы они порождали обратные ребра. Как раз, если я пускаю поток вдоль обратного ребра,
[17:35.560 --> 17:40.360]  это значит, что я отменяю старый поток, который шел по прямому ребру, и тем самым перестраиваю
[17:40.360 --> 17:44.640]  как-то тот поток, который уже в графе течет. Ну и вот оказывается, что если вводить вот такие
[17:44.640 --> 17:50.480]  обратные ребра, то можно просто вот пока есть путь в остаточной сети, пока он есть,
[17:50.480 --> 17:56.040]  пускать по нему поток, так многократно делать, пока все пути не исчерпаются. И когда исчерпаются,
[17:56.040 --> 18:04.960]  оказывается, что поток максимален. Это мы докажем. Ну если не было обратного ребра,
[18:04.960 --> 18:09.520]  то, например, кто-нибудь мог прийти и сказать, давайте я пущу поток вот вдоль такого пути.
[18:09.520 --> 18:15.080]  Тогда что останется? У меня останется вот такое ребро и вот такое ребро, а все остальные уже
[18:15.080 --> 18:20.680]  насыщенные. И я ничего с ним делать не смогу. То есть мне нужно, мне как бы, мне придется как-то
[18:20.680 --> 18:25.360]  отменять поток вдоль вот этого ребра, но у меня нет таких ресурсов, я могу только пускать поток.
[18:25.360 --> 18:31.440]  Именно для этого я ввожу обратное ребро, которое как раз и означает, что можно отменить поток
[18:31.440 --> 18:46.320]  текущий сверху вниз. Без него провал будет, к сожалению. Так. Ну вот, хорошо. Вот это утверждение мы
[18:46.320 --> 18:50.360]  сейчас будем доказывать, но для этого мне, там теорема из трех эквивалентных утверждений,
[18:50.360 --> 18:58.240]  мне для этого нужно еще пару определений ввести. Определение, как обычно, пусть g это сеть,
[18:58.240 --> 19:16.600]  тогда пара множеств s и t называется разрезом, если, если s маленькое лежит в s большом,
[19:16.600 --> 19:23.080]  t маленькое лежит в t большом, и при этом они в дизюмкном объединении равны множеству вершин.
[19:23.080 --> 19:33.000]  Граф ажи. Это буквально какое-то разбиение множества вершин на два куска, такие, что s в одном, а t в другом.
[19:33.000 --> 19:44.160]  Дизюмкное объединение все же знают, не пересекающие множество в объединении, дающее все v. Так, ну давайте
[19:44.160 --> 20:05.160]  тоже напишу. В таком случае величиной разреза назовем, назовем сумму capacity всех ребер из s в t.
[20:05.160 --> 20:18.480]  Просто формально сумма по всем u из s, v из t, capacity ребра у v. Картинка примерно такая. У вас есть
[20:18.480 --> 20:23.520]  разбиение вашего графа на два множества, s большое, t большое. Здесь где-то s маленькое,
[20:23.520 --> 20:30.360]  здесь где-то t маленькое. Вот, и мы просто считаем суммарную капасти всех ребер слева направо. То есть
[20:30.680 --> 20:36.480]  все такие ребра перебираем, складываем их capacity, это называется величиной разреза.
[20:36.480 --> 20:45.120]  Cst это просто сумма вот этих всех capacity на ребрах между долями. Вот, интуиция у этой величины
[20:45.120 --> 20:53.160]  следующая, что любой поток заведомо не превосходит величины вот этого разреза. Да, ну потому что,
[20:53.160 --> 20:59.160]  смотрите, любой поток, он же начинает в s, заканчивается в t. Значит, любой поток он должен рано или
[20:59.160 --> 21:05.360]  поздно пересекать этот разрез и из s переходить в t, из s перетекать в t. Ну, тогда понятно, что поток
[21:05.360 --> 21:11.440]  не больше, чем величина разреза, потому что вот как-то поток здесь, здесь что-то течет, потом
[21:11.440 --> 21:19.880]  переходит и потом дотекает в t отсюда. Ну, значит, вот суммарно весь поток не превосходит того,
[21:19.880 --> 21:25.200]  сколько здесь потенциально может протечь слева направо. Вот как раз не больше этой суммы. Вот,
[21:25.200 --> 21:29.880]  мы тоже формально докажем. Идея такая, что это какое-то ограничение на максимальный поток,
[21:29.880 --> 21:54.880]  что любой поток не больше, чем такой разрез. Так, ну еще давайте, да, определю,
[21:54.880 --> 22:12.160]  значит, величина потока через разрез. Величина потока через разрез. fst, это то же самое,
[22:12.160 --> 22:20.040]  только я буду суммировать потоки на ребрах слева направо. Значит, сумма по u из s, vst, fuv.
[22:20.040 --> 22:34.320]  Так, то же самое, да, только я суммирую не капасти на ребрах, а потоки, f. Вот, значит,
[22:34.320 --> 22:48.600]  ну, лемма давайте напишем. Если st это разрез, то величина потока через разрез равна просто
[22:48.700 --> 23:02.080]  MATA-величине потока. Вот вся величина потока, это вот вся эта идея, что весь поток,
[23:02.080 --> 23:06.200]  вытекающе из s, то есть как бы все, что здесь вот есть, все, что из s выходит, оно должно
[23:07.000 --> 23:11.160] tycznie Conveniently перейти через из S и Typing в tt, то есть суммарно, сколько потока протекает
[23:11.160 --> 23:15.440]  из S и Typing в tt, это есть размер всего потока. То есть все, что вытекло, то есть как бы все,
[23:15.440 --> 23:30.780]  что исходит отсюда, рано или поздно переходит отсюда сюда. Так, ну доказательства. Давайте займемся
[23:30.780 --> 23:38.720]  арихметикой. Значит, я утверждаю, что fst можно переписать так. Ну, во-первых, давайте я скажу,
[23:38.720 --> 23:45.400]  что я для любых просто множеств, для любых множеств a и b, просто определяю f и b как сумму потоков
[23:45.400 --> 23:54.760]  из a в b. То есть это сумма по всем a из a, b из b и f a b. Ну, короче, то же самое, только я могу
[23:54.760 --> 23:59.280]  для вообще, для произвольных множеств это определить, не обязательно не пересекающихся. Вот,
[23:59.280 --> 24:13.480]  тогда утверждаю, что fst это просто fsv минус fss. Вот, это вроде очевидно, потому что здесь написаны
[24:13.480 --> 24:20.200]  суммы потоков из s в t, здесь написана сумма потоков из s куда угодно, минус из s в s. Ну,
[24:20.200 --> 24:27.480]  понятно как раз, что v-s это будет t в точности. Понятно это? Вот, хорошо,
[24:27.480 --> 24:41.600]  значит теперь утверждаю, что эта штука ноль на самом деле. Почему, как вы думаете? Ну да,
[24:41.600 --> 24:46.640]  по антисим barreijke более-менее, потому что здесь вот каждый ребро будет учтено дважды. Слева�
[24:46.640 --> 24:49.920]  направо и с права налево, но мы знаем, что по противоположным реб 330 текут противоположные потоки.
[24:50.880 --> 24:56.240]  Поэтому здесь будет ноль. Формально мне нужно было бы... То есть у меня есть на самом деле рёбра и петли
[24:56.900 --> 25:01.720]  еще. По ребрам понятно, каждый ребро будет пощ зависма два раза, слева направо, с права налево,
[25:01.720 --> 25:07.600]  поэтому сумме они дадут нулевой вклад. Есть еще петли, но понятно, что по петлям тоже
[25:07.600 --> 25:12.100]  течет нулевой поток опять же в силу антисимметричности, что поток по петле
[25:12.100 --> 25:18.160]  должен быть равен минус потоку по ней же, значит это ноль.
[25:18.160 --> 25:26.240]  Поэтому вся эта штука тоже нулевая. Остается fsv, хорошо.
[25:37.600 --> 26:02.000]  Так, ладно. Что дальше? Дальше я хочу расписать это следующим образом.
[26:02.000 --> 26:12.520]  Я хочу выделить в s большом одну конкретную вершину s маленькая, а все остальное загнать во второе слагаемое.
[26:12.520 --> 26:20.480]  То есть я вот эту всю большую сумму, из всей этой большой суммы вычленяю те слагаемые,
[26:20.480 --> 26:25.760]  в которых f течет из s маленького, а все остальное остается во втором слагаемом.
[26:25.760 --> 26:31.600]  Вот, ну тогда понятно, что вот это по определению это просто у нас величина потока,
[26:31.600 --> 26:37.640]  потому что f из s маленького в это как раз сумма всех потоков текущих из s маленького,
[26:37.640 --> 26:42.160]  это есть в точности величина потока просто по определению. Вот, ну и хочется доказать, что это тоже ноль.
[26:42.160 --> 26:51.360]  Почему вот это ноль? Ну да, да, потому что мне известно, что для каждой вершины,
[26:51.360 --> 26:57.680]  вершины отличные от s и от t, сумма потоков истекающих из нее в весь граф это ноль.
[26:57.680 --> 27:07.120]  Да, значит я могу написать, что для любого u неравного s и t, я знаю, что сумма по всем v, f и v это ноль.
[27:07.120 --> 27:13.600]  Это третье свойство у меня. Ну вот, а я такие штуки еще суммирую по всем u из s большого без s маленького.
[27:13.600 --> 27:18.840]  И понятно, что здесь как раз вот в этом множестве отсутствует и s маленькая и t маленькая,
[27:18.840 --> 27:24.760]  потому что s я выкинул, а t маленькая здесь, потому что она в t большом лежит. Ну и все,
[27:24.760 --> 27:28.560]  и значит для каждой вершинки вот эта сумма нулевая, и дальше суммирую и получаю тоже ноль.
[27:28.560 --> 27:38.280]  Да, окей. Ну все, получилось, что это просто величина потока. Так, шикарно.
[27:38.280 --> 27:47.320]  Значит отсюда следует немедленно наблюдение, что величина любого потока не больше величины любого разреза.
[27:47.320 --> 28:01.880]  Я так словами напишу. Величина любого потока не превосходит величины любого разреза.
[28:01.880 --> 28:18.120]  Ну просто потому, что поток, как мы знаем, имеет величину fst, такую же, как величина потока через разрез,
[28:18.120 --> 28:25.400]  ну а это уже понятно, что это не больше, чем cst, потому что каждая f в этой сумме не больше,
[28:25.400 --> 28:29.320]  чем соответствующая c. Значит и весь поток не больше, и весь разрез.
[28:29.320 --> 28:38.680]  Вот, ну все, теперь наконец-то можно доказывать теорему. Теорема, теорема Форда Фалкерсона.
[28:38.680 --> 28:55.600]  Значит она утверждает, что следующие три условия эквивалентны. Во-первых,
[28:55.600 --> 29:13.840]  поток f максимален. Во-вторых, в остаточной сети f, gf, нет пути из svt. Вот. И третье дополнительное
[29:13.840 --> 29:23.800]  условие, которое здесь пригождается, это что поток f равен величине какого-то разреза. Существует
[29:23.800 --> 29:39.280]  разрез st такой, что его величина равна величине потока. Что есть какой-то разрез равный по
[29:39.280 --> 29:49.400]  величине потоку. Ну доказательства давайте просто по кругу докажем. Из 1 в 2. Вроде уже доказали,
[29:49.400 --> 29:56.680]  что если, скажем, второй не выполняется и есть какой-то остаточный путь, то можно вот вдоль
[29:56.680 --> 30:02.120]  этого пути протолкнуть единичку потока. Поток вдоль этого пути увеличен на 1, тогда весь поток
[30:02.120 --> 30:09.560]  увеличится и останется корректным потоком. Можно просто, ну очевидно, можно просто протолкнуть
[30:09.560 --> 30:21.920]  поток. Так, из 2 в 3. Если у кого-то интуиция, каким образом можно было бы сконструировать вот такой
[30:21.920 --> 30:31.600]  вот разрез, величина которого равна величине потока. То есть я знаю, что нет путей из svt и хочу
[30:31.600 --> 30:40.840]  сконструировать разрез конкретный. Представляет ли кто-нибудь, вот тут будет явная конструкция,
[30:40.840 --> 31:10.120]  определим s вот так, t вот так. Первое что? s маленькое. Ну нет, к сожалению, не хватит. В
[31:10.120 --> 31:21.680]  общем случае это не верно. Да, вот ровно так. Чтобы вот это вот было верно, что это значит? Это
[31:21.680 --> 31:28.440]  значит, что в нашем разрезе вот все вот эти ребра насыщенные, то есть они как раз пропадают, у них
[31:28.440 --> 31:33.320]  остаточная капасти 0. Чтобы c было равно f, мне нужно, чтобы все вот эти ребра были полностью
[31:33.320 --> 31:38.800]  заполнены потоком. Чтобы c на каждом было равно потоку на каждом. Чтобы этих ребер не было в
[31:38.800 --> 31:54.800]  остаточной сети. Вот как можно выбрать svt? Да, только я скажу проще. Я просто скажу, что давайте
[31:54.800 --> 32:05.280]  s большое – это все достижимые из s маленького. Ну просто по ребрам. Пусть s большое – это все
[32:05.280 --> 32:20.600]  вершины, достижимые из s маленького в остаточной сети jsindex.mf. Тогда как раз все вот эти ребра
[32:20.680 --> 32:38.400]  отсутствуют в остаточной сети, потому что как раз это достижимые, а это не достижимые.
[32:38.400 --> 32:47.160]  Ну значит как раз все эти ребра отсутствуют в остаточной сети, значит на них капасти равно потоку.
[32:47.160 --> 32:59.780]  Ну давайте это пропишем, что для любого u из s, v из t, c, f, u, v равно нулю, так как
[32:59.780 --> 33:17.900]  ребра, увы, нет в остаточной сети. Нет уже с nxmf. Ну тогда, тогда победа. Тогда, тогда c, величина
[33:17.900 --> 33:23.100]  вот этого разреза, равна величине потока через разрез просто потому, что на каждом ребре c равно
[33:23.100 --> 33:35.900]  f. Ну а это мы знаем, что это просто величина всего потока. Понятно? Хорошо. Ну и наконец,
[33:35.900 --> 33:43.420]  из 3 в 1, надо доказать, что если есть какой-то разрез, то поток максимален. Ну понятно,
[33:43.420 --> 33:49.540]  это вот отсюда следует немедленно. Я знаю, что любой поток меньше любого разреза, и оказывается,
[33:50.460 --> 33:56.320]  где-то равенство достигается. Что какой-то равен какому-то. Давайте я такую картинку
[33:56.320 --> 34:02.260]  нарисую. Вот пусть у меня есть все возможные величины потока, величины потока. Пусть есть
[34:02.260 --> 34:09.020]  все возможные величины всех разрезов. Я знаю, что все потоки не больше всех разрезов последствию.
[34:09.020 --> 34:13.820]  То есть у меня как раз засечка где-то слева, потом засечка где-то справа, это разрезы.
[34:13.820 --> 34:21.700]  то есть они вот так вот как бы разделены. Но при этом откуда-то существует равенство,
[34:21.700 --> 34:26.060]  что существует конкретный поток равный конкретному разрезу. Значит, вот эти множества пересекаются,
[34:26.060 --> 34:33.820]  есть какая-то общая засечка вот здесь. Она соответствует и потоку, и разрезу одновременно.
[34:33.820 --> 34:38.060]  Значит, это экстремальный поток, максимальный поток и экстремальный разрез, то есть минимальный
[34:38.060 --> 34:47.060]  разрез. Ну еще раз, смотрите, вот это, не знаю, там, вещественная прямая, я на ней наношу засечки двух
[34:47.060 --> 34:53.500]  типов, равные величине потока и равной величине разреза. Вот здесь все f и здесь все c, для всех
[34:53.500 --> 34:58.820]  возможных поток и для всех возможных разрезов. Я знаю, что все потоки не больше всех разрезов по
[34:58.820 --> 35:03.620]  следствию. Поэтому эти два множества отделены друг от друга, то есть у меня есть вот это вот все множество
[35:03.620 --> 35:09.020]  всех потоков, это множество всех разрезов. Они вот так вот отделены. Эти все слева, эти все справа.
[35:09.020 --> 35:14.540]  Но при этом они пересекаются. Вот потому что существует конкретный поток, существует конкретный
[35:14.540 --> 35:19.140]  разрез с одинаковыми значениями. Ну значит, это максимальный поток и минимальный разрез.
[35:19.140 --> 35:33.580]  Давайте напишем, что в таком случае f это максимальный поток, а st это минимальный разрез.
[35:33.580 --> 35:50.260]  Ну вот, вроде доказали. Так, нормально? Хорошо. Вот, ну все, тогда из этого теоремы немедленно
[35:50.260 --> 35:53.100]  следует простейший алгоритм. То есть алгоритм Форда Фалкерсона.
[35:53.100 --> 36:08.020]  Он делает следующее. Пока в остаточной сети есть путь из СФТ, найди его, скажем, ДФС,
[36:08.020 --> 36:19.740]  вот просто возьми первый положившийся путь. Посмотри на ребра на нем, возьми среди всех
[36:19.740 --> 36:26.860]  capacity минимальную. У меня есть какой-то путь. Я выбираю среди всех этих ребер минимальное
[36:26.860 --> 36:30.900]  остаточное capacity, то есть сколько потока я могу протолкнуть вдоль этого пути. Ну понятно,
[36:30.900 --> 36:36.140]  если тут есть какие-то числа, то суммарно я могу протолкнуть минимум из них, чтобы все ограничения
[36:36.140 --> 36:41.180]  превысить. Вот, возьму минимум и протолкну здесь столько потока. И так буду делать,
[36:41.180 --> 36:58.020]  пока путь существует. Давайте это кратенько напишу, что пока в ЖФ есть путь из СФТ. Найти
[36:58.020 --> 37:11.500]  его с помощью ДФС, положить х равным минимальной из остаточной capacity ребер на пути. Я так и
[37:11.500 --> 37:18.020]  напишу минимум. На минимум по всем ребрам, лежащим на пути, остаточной capacity на ребре. Ну и пустить
[37:18.020 --> 37:35.140]  по нему х потока. Пустить по этому пути х потока. Ну то есть буквально, просто непосредственно
[37:35.140 --> 37:44.500]  применение теоремы, пока есть путь, пускай по нему поток. А, вот здесь? Ну, минимум всех СФ от Е
[37:44.500 --> 37:48.820]  по всем ребрамам. То есть вот Е это ребра на этом пути. Среди них выбираем минимально остаточную
[37:48.820 --> 37:56.820]  capacity, ЦСН, ХМФ. И проталкиваю здесь х потока. То есть вот здесь вот везде пускаю х, х, х, х, х, х.
[37:56.820 --> 38:09.500]  Понятно? Ну понятно тогда, корректность следует непосредственно из теоремы, потому что просто
[38:09.500 --> 38:14.780]  вот я заканчиваю, только когда исчерпали все пути. А асимптотика здесь будет, давайте
[38:14.780 --> 38:21.820]  напишу вот так вот, F умножить на Е, где F это собственно величина потока, ну ответ, грубо говоря,
[38:21.820 --> 38:28.300]  максимальный поток, а Е это число ребер в графе. Почему? Ну потому что в худшем случае, вот
[38:28.300 --> 38:33.740]  итерация вот этого вайла происходит как раз в худшем случае F. Потому что в худшем случае на
[38:33.740 --> 38:38.540]  каждом пути находится всего лишь единичная минимальная capacity, и я проталкиваю единицу потока
[38:38.540 --> 38:43.020]  вдоль пути. Ну а внутри е это просто сколько времени трачет. То есть, грубо говоря, здесь ДФС,
[38:43.020 --> 38:49.300]  потом проход по пути, и здесь прибавление константы на каким-то ребрам. Самое сложное здесь ДФС,
[38:49.300 --> 38:53.500]  но ДФС работает за В плюс Е. Я, как обычно, считаю, что е больше, чем В, потому что иначе можно
[38:53.500 --> 39:00.220]  отбросить недостижимое и считать, что е хотя бы В минус 1. Ну отсюда такая асимптотика. F это
[39:00.220 --> 39:08.340]  величина максимального потока. Собственно, вот это вот. Это максимальный поток. Ну, ответ, грубо говоря.
[39:08.340 --> 39:18.620]  Так, тогда давайте перерывчик небольшой. Так, давайте дальше.
[39:18.620 --> 39:28.940]  Смотрите, я утверждаю, что вот ту асимптотику, которую я написал, F на Е, она на самом деле в
[39:28.940 --> 39:42.980]  каком-то смысле точная. Давайте на примере. Давайте я нарисую такой граф. Вот пусть на этих ребрах поток,
[39:42.980 --> 39:49.380]  точнее, капасти у меня какой-нибудь очень большое, а на этом ребре капасти всего единичка.
[39:49.380 --> 39:57.660]  Ну, понятно тогда, что чтобы решить задачу, можно было бы просто пустить вот здесь вот
[39:57.660 --> 40:05.100]  10-9 потока и здесь 10-9 потока и победить. Было бы максимально понятным делом поток. Но возможно,
[40:05.100 --> 40:09.860]  я же там никак не специфицировал, как DFS работает. Он может как-нибудь по-другому искать эти пути.
[40:09.860 --> 40:14.820]  Например, он может сначала, первым делом, найти вот такой вот путь, используя это ребро, и пустить
[40:14.820 --> 40:18.300]  тут всего единичку потока, потому что это минимальная капасти 1. Ну вот пусть он здесь
[40:18.300 --> 40:26.260]  пустил единичку. Тогда что? Тогда у меня появляется обратное ребро, вдоль которого можно как бы
[40:26.260 --> 40:32.220]  отменять вот этот поток. Ну единственный остающийся путь, это вот этот вот, по которому тоже можно
[40:32.220 --> 40:39.500]  всего единичку протолкнуть. Ну и так далее. Вот мы будем вот такими вот путями с капастью 1 пускать
[40:39.500 --> 40:44.100]  по единичке потока каждый раз. Понятно, что это долго, но это будет 2 на 10 вятое итерация как раз.
[40:44.100 --> 40:51.220]  То есть, что вот в этом случае у меня поток был 2 на 10-9, и в принципе, если как-то я DFS
[40:51.220 --> 40:56.300]  неудачно реализовал, если он какой-то дурацкий путь находит, то вот примерно столько итераций может
[40:56.300 --> 41:08.540]  быть. Может быть F итераций поиска пути. Поэтому это оценка, ну в каком-то смысле строгая,
[41:08.540 --> 41:14.380]  что она достигается, что реально может быть столько итераций. Вот, значит, ну оказывается,
[41:14.380 --> 41:19.220]  что это можно довольно легко починить. Именно вот смотрите, я здесь вот взял путь из трех ребер,
[41:19.220 --> 41:23.420]  а надо было из двух ребер. Вот оказывается, что если всегда выбирать не абы какой путь,
[41:23.420 --> 41:28.260]  а самый короткий, в плане как бы самой короткой пищу ребер, то можно избавиться вот от этой
[41:28.260 --> 41:39.980]  зависимости от величины потока. Это называется алгоритм Эдманса Карпа. Значит, все то же самое,
[41:39.980 --> 41:49.940]  только DFS меняю на BFS. И нахожу не абы какой путь, а самый короткий, ну как бы в плане почлу ребер,
[41:49.940 --> 41:57.060]  самый короткий почлу ребер путь. Значит, тогда утверждается, что асимптотика вот-вот такой вот,
[41:57.060 --> 42:06.500]  переходит вот к такой вот. Ну и, соответственно, пропадает зависимость от величины потока.
[42:06.500 --> 42:15.700]  Ну тоже, конечно, не очень хорошее. Ве квадрат не очень мало, даже много для нормальных графов.
[42:15.700 --> 42:20.500]  Вот, но в потоках в среднем получается так, что даже вот эти теоретические оценки,
[42:20.500 --> 42:23.340]  даже несмотря на то, что они, наверное, достигаются на каких-то конкретных графах,
[42:23.340 --> 42:30.260]  и при конкретном выборе вот этих вот кратчайших путей, да, потому что даже в случае BFS у меня,
[42:30.260 --> 42:35.380]  ну как бы их может быть много кратчайших путей, да, и там, какой именно выбирается алгоритмом,
[42:35.380 --> 42:39.220]  я, опять же, не указываю. Вот если он как-то неудачно выбирает, то, наверное, эта оценка,
[42:39.220 --> 42:44.660]  опять же, достигается. Вот, но на каких-то специфических графах, если нам постоянно не везет,
[42:44.660 --> 42:51.180]  если мы берем неправильные пути каждый раз и так далее. На практике вот время работы,
[42:51.180 --> 42:55.820]  реальное время работы алгоритма сильно меньше, чем вот это вот. Ну, тут уже, как бы, вам предстоит
[42:55.820 --> 43:03.420]  самим поэкспериментировать, насколько быстры все эти алгоритмы в контесте. Вот, ну, теоретически
[43:03.420 --> 43:08.740]  можно только вот это доказывать. Но если как бы сеть, да, вот как бы сеть, даваемая вам в инпуте,
[43:08.740 --> 43:14.860]  она не, грубо говоря, если вы сами ее строите, если это не какой-то граф, который вам специально дают,
[43:14.860 --> 43:21.380]  который, грубо говоря, специально по-доброму, чтобы заваливать Edmunds Carp, например. А вы сами
[43:21.380 --> 43:26.380]  строите сеть, то есть вы, грубо говоря, у вас есть какая-то исходная задача, вы берете и сводите эту
[43:26.380 --> 43:31.620]  задачу к потоковой. То есть вы сами строите сеть и говорите, что решить исходную задачу – это то
[43:31.620 --> 43:36.140]  же самое, что найти максимальный поток в новой сети, в какой-то вами построенной. Тогда это сеть
[43:36.140 --> 43:40.700]  специфического вида, совсем необщего, какого-то конкретного, который вы сами построили. Ну, и там
[43:40.700 --> 43:45.740]  скорее всего вот эту оценку можно усилить и доказать, что алгоритм работает быстрее,
[43:45.740 --> 43:54.820]  чем теоретически максимум. Вот, ну, как-то так. Вот, давайте доказывать, по крайней мере,
[43:54.820 --> 44:02.340]  что теоретически достигается вот такая оценка. Ну, поехали. Для этого мне нужно будет две леммы.
[44:02.340 --> 44:16.100]  Лемма первая. Значит, пусть, ну, давайте напишу так, пусть GF и GF штрих – это два последовательных
[44:16.100 --> 44:28.460]  состояния остаточной сети в алгоритме Эдмонс-Карпа. Два последовательных состояния остаточной сети
[44:28.460 --> 44:38.340]  в алгоритме Эдмонс-Карпа. То есть мы делаем несколько итераций Эдмонс-Карпа, каждый раз
[44:38.340 --> 44:43.620]  пропускаем поток вдоль какой-то пути, и вот пусть у нас после итерации была такая сеть,
[44:43.620 --> 44:55.260]  после и плюс первой вот такая. Значит, дальше пусть D от V – это, соответственно, расстояние от S до V
[44:55.260 --> 45:07.180]  в графе GF, а D штрих от V – это то же самое расстояние, но уже в новом графе, в графе GF штрих.
[45:07.180 --> 45:20.820]  Графя GF штрих. Тогда утверждается, что для всех вершин расстояние выросло только, не строго.
[45:20.820 --> 45:31.540]  То есть Эдмонс-Карп так работает, что кратчайшие расстояния от S до всех вершин могут только
[45:31.540 --> 45:40.580]  увеличиваться в процессе его работы. Вот такое утверждение. Но давайте пойдем от противного.
[45:40.580 --> 45:50.020]  Значит, пусть это неверно, и для какого-то V расстояние уменьшилось, то есть D штрих меньше,
[45:50.020 --> 45:55.140]  чем D от V. Давайте среди всех таких вершин, для которых это неравенство нарушается,
[45:55.220 --> 46:05.940]  выберем вершину с минимальным значением D штрих. Среди всех вершин, для которых
[46:05.940 --> 46:15.820]  неравенство нарушилось, выберем ту, у которой D штрих минимально.
[46:15.820 --> 46:23.980]  Выберем вершину с минимальным D штрих от V.
[46:23.980 --> 46:38.340]  Хорошо. Значит, тогда давайте я вот в этой новой остаточной сети GF штрих нарисую кратчайший
[46:38.340 --> 46:48.220]  путь из S в V. На, это кратчайший путь из S в V вот в новой остаточной сети GF штрих.
[46:48.220 --> 46:57.660]  Кратчайший. Смотрите, ну понятно, наверное, что V не равно S, потому что если V равно S,
[46:57.660 --> 47:01.940]  то D штрих и D всегда равно нулю, потому что расстояние от S до S всегда нулевое. Поэтому
[47:01.940 --> 47:07.860]  для S это неравенство нарушаться не может. Значит, V точно не S. Значит, есть какая-то на пути предпоследние
[47:07.860 --> 47:15.860]  вершины. Давайте ее зафиксируем. Пусть это U. Пусть предпоследние вершины пути это U. Вот,
[47:15.860 --> 47:21.540]  тогда, например, я могу написать следующее. Я могу написать, что D штрих от V равно D штрих от U
[47:21.540 --> 47:30.660]  плюс 1. Ну, потому что все это часть одного большого кратчайшего пути от S до V, если U предпоследнее,
[47:30.660 --> 47:39.260]  то значит до него расстояние на 1 меньше, чем до V. Вот, поэтому в частности у меня получается,
[47:39.260 --> 47:48.660]  что D штрих от U меньше, чем D штрих от V. А значит, раз D штрих была минимальная, для которого
[47:48.660 --> 47:54.100]  нарушается это неравенство, значит получается, что для U оно не нарушается. Значит, D штрих от U
[47:54.100 --> 48:05.500]  больше либо равно, чем D от U. Потому что, еще раз, вот это вот неравенство нарушалось для каких-то
[48:05.500 --> 48:11.180]  вершин, и D штрих было минимально, для которого это нарушается. Но D штрих от U меньше, чем D штрих
[48:11.180 --> 48:20.260]  от V, поэтому для U вот это не нарушается. Значит, выполняется такое. Хорошо, значит, это мы зафиксировали.
[48:20.260 --> 48:29.860]  Мы знаем вот это, мы знаем вот это. Так, теперь давайте я задам себе такой вопрос. Откуда взялось
[48:29.860 --> 48:36.660]  вот это ребро в остаточной сети? У V что это за ребро? Ну, может быть, два варианта. Либо оно
[48:36.660 --> 48:42.460]  как бы просто унаследовалось с прошлого состояния сети, из GSMF, то есть оно было и оно осталось.
[48:42.460 --> 48:48.100]  Либо же его не было, но оно появилось. Раз оно есть в этом графе, если бы, скажем, не было в
[48:48.100 --> 48:52.820]  исходном, то оно как бы появилось. Но появиться, понятно, оно могло только за счет того, что оно
[48:52.820 --> 48:58.500]  ввелось как обратное к чему-то. То есть мы как бы пустили поток по обратному ребру, и у нас появилась
[48:58.500 --> 49:04.180]  у V как возможность отменять поток вдоль вот этого ребра. Ну, давайте два случая рассмотрим. Значит,
[49:04.180 --> 49:24.740]  откуда у V в новом графе GF? Ну, случай первый. Это ребро было в GF и осталось. Было в GF и осталось
[49:24.740 --> 49:43.540]  в GF'. В графе GF было это ребро. Вот, но раз оно было в исходном графе на предыдущей
[49:43.540 --> 49:48.500]  итерации, то я точно могу записать вот такое неравенство, что dA2 не больше, чем dA2 плюс 1.
[49:48.500 --> 49:55.260]  Ну, как обычно, неравенство треугольника. Если у меня есть такой ребро, то расстояние
[49:55.260 --> 50:03.780]  досюда не больше, чем досюда плюс 1. Вот. Ну и все. Теперь утверждаю, что совокупность всех
[50:03.780 --> 50:12.820]  неравенств, которые написаны на доске, противоречива. Давайте попробуем. Вот отсюда мы знаем,
[50:12.820 --> 50:19.180]  что dA2, например, оценится сверху через d'A2. Поэтому я могу продолжить это неравенство тем,
[50:19.180 --> 50:25.180]  что dA2 не больше, чем d'A2, ну и плюс 1 переписывается. На это вот это неравенство задействует.
[50:25.180 --> 50:37.820]  Дальше я знаю, что d'A2 плюс 1, это в точности d'A2. Ну, у меня получилось, что d не больше,
[50:37.820 --> 50:45.180]  чем d'. А это противоречит вот этому вот предположению. Здесь написано, что d больше,
[50:45.180 --> 50:52.580]  чем d', а там, что d не больше, чем d'. Противоречие. Противоречие с выбором v.
[50:52.580 --> 51:09.500]  Да, видно. Хорошо. Значит, случай второй должен быть. Случай второй. У v не было в gf, но оно
[51:09.500 --> 51:22.420]  появляется. У v не было в gf. Ну, как я уже сказал, если его не было, но оно появляется, значит,
[51:22.420 --> 51:27.380]  оно появляется только как обратное ребро к тому, вдоль которого протек поток. Значит,
[51:27.380 --> 51:33.340]  что вот эти два потока f' и f, отличаются друг от друга тем, что я пустил какой-то поток,
[51:33.340 --> 51:38.620]  текущий в частности вот по этому обратному ребру. То есть по обратному пустилось, за счет этого
[51:38.620 --> 51:51.380]  появляется ребро uv. Хорошо. Значит, это значит, что в gf, переход от gf к gf' устроен так. Давайте
[51:51.380 --> 51:58.580]  вот так его нарисую. Значит, это какой-то такой путь из s в t, в частности, содержащий ребро v u.
[51:58.580 --> 52:11.540]  Чтобы оно появилось, по нему должен был протечь поток. Ну, это значит, что, смотрите, я же пускаю
[52:11.540 --> 52:17.700]  поток вдоль кратчайшего пути всегда. Значит, в частности, я могу записать, что d от v плюс 1
[52:17.700 --> 52:25.580]  было равно d от u, потому что это все составная часть большого кратчайшего пути, значит,
[52:25.580 --> 52:34.060]  расстояние до u равно d от v плюс 1, потому что это все кратчайший путь. Так, вот. Ну,
[52:34.060 --> 52:46.980]  опять я утверждаю, что записанное неравенство противоречиво. Давайте в этом убедимся.
[52:47.060 --> 52:59.220]  Так, давайте вот это продолжать. Значит, я знаю, что d от v плюс 1 это d от u. Я знаю,
[52:59.220 --> 53:09.420]  что d от u не больше, чем d штрих от v. Продон. d от u не больше, чем d штрих от u, извините.
[53:09.420 --> 53:20.100]  Так, это вот это. Ну и дальше я могу написать, что d штрих от u это d штрих от v минус 1.
[53:20.100 --> 53:33.700]  Так, это вот самое левое равенство я использую. Ну и все, получается, что тогда, давайте я пишу так,
[53:33.700 --> 53:51.820]  d штрих от v равно d от v плюс 2. Да, спасибо, больше всего равно, спасибо. Ну а у меня было
[53:51.820 --> 53:57.860]  предположение вот такое, что d штрих меньше, чем d от v. С одной стороны, больше равно, чем d от v
[53:57.860 --> 54:08.660]  плюс 2, с другой стороны, меньше. Такого не бывает. Но опять противоречие. Ну все, не такого,
[54:08.660 --> 54:13.900]  не такого не бывает. Значит, наше исходное предположение неверно, и таких вы не существует.
[54:13.900 --> 54:40.100]  Поэтому вот это всегда получается. Окей? Хорошо. Хорошо. Тогда лемма два. Лемма два. Ну, например,
[54:40.100 --> 54:45.380]  вот здесь, чтобы вот это вот утверждать, я говорил, что поток обязательно вдоль кратчайшего пути
[54:45.380 --> 54:51.980]  протолкнут был. То есть вот это вот равенство следует только из того, что путь из sft, вдоль которого
[54:51.980 --> 54:56.460]  я пустил поток, кратчайший. Значит, вот это вот равенство я могу утверждать только для кратчайшего
[54:56.460 --> 55:14.860]  пути. Вроде больше нигде этого не было. Да, вроде больше не было. Итак, лемма два. Шлема два утверждает,
[55:14.860 --> 55:36.980]  что каждое ребро, увы, в алгоритме Эдманскарпа насыщается не более, чем от вырос.
[55:36.980 --> 55:49.100]  А что такое насыщается? Ну, насыщается, это когда мы полностью исчерпываем пропускную способность
[55:49.100 --> 55:54.540]  ребра. То есть вот там, не знаю, если у него было пять, если к опасти было пять, то насыщение,
[55:54.540 --> 55:58.620]  это когда вот начинает течь ровно пять потока. То есть когда раньше было меньше пять, а потом
[55:58.620 --> 56:03.500]  становится пять. Ну и понятно, что каждое ребро может потенциально насыщаться несколько раз,
[56:04.140 --> 56:08.300]  потому что мы могли его сначала насытить, потом пустить поток по обратному ребру и pair, соответственно,
[56:08.300 --> 56:12.200]  уменьшить здесь поток вдоль этого ребра и обратно потом его опять насытить. То есть может быть такое,
[56:12.200 --> 56:17.100]  что оно насытилось, потом какой-то поток отменился за счет обратного ребра, и потом
[56:17.100 --> 56:22.400]  опять ребро насытилось. Вот я отвераю, что количество раз, когда оно становится насыщенным, оно маленькое.
[56:22.400 --> 56:29.400]  В пополам примерно будет.
[56:29.400 --> 56:32.400]  Доказательства.
[56:32.400 --> 56:35.400]  Давайте эту мысль сформулируем.
[56:35.400 --> 56:40.400]  Между двумя последовательными насыщениями конкретного ребра
[56:40.400 --> 56:47.400]  мы должны пустить поток по обратному ребру.
[56:48.400 --> 56:57.400]  Двумя последовательными насыщениями
[57:05.400 --> 57:10.400]  мы должны пустить поток по ребру ВУ.
[57:17.400 --> 57:24.400]  Двумя последовательными насыщениями
[57:24.400 --> 57:31.400]  Двумя последовательными насыщениями
[57:42.400 --> 57:45.400]  Ну что тогда?
[57:45.400 --> 57:47.400]  Давайте это ребро нарисую.
[57:47.400 --> 57:52.400]  Вот у меня изначально ребро насытилось, в очередной раз оно насытилось.
[57:52.400 --> 57:57.400]  Что это значит?
[57:57.400 --> 58:01.400]  Это значит, что если вот здесь было какое-то изначальное ДАТУ,
[58:01.400 --> 58:05.400]  то поскольку у меня проталкивается поток всегда вдоль кратчайшего пути,
[58:05.400 --> 58:09.400]  то расстояние до В было в точности ДАТУ плюс один.
[58:09.400 --> 58:14.400]  Потому что это ребро принадлежит кратчайшему пути, раз вдоль него протекает поток,
[58:14.400 --> 58:17.400]  значит это ребро лежит на кратчайшем пути из СВТ,
[58:17.400 --> 58:20.400]  поэтому расстояние до В ровно такое.
[58:20.400 --> 58:26.400]  После этого у меня происходит проталкивание по обратному ребру.
[58:26.400 --> 58:32.400]  Но тогда я знаю, что между этими итерациями у меня расстояние до вершины только растет.
[58:32.400 --> 58:37.400]  Поэтому если я здесь рассмотрю расстояние от С до В в этот момент времени,
[58:37.400 --> 58:40.400]  оно будет хотя бы ДАТУ плюс один.
[58:40.400 --> 58:43.400]  Потому что раньше оно было уже ровно ДАТУ плюс один,
[58:43.400 --> 58:46.400]  здесь прошло сколько-то итераций между ними,
[58:46.400 --> 58:50.400]  то вот это ребро берется в обратную сторону.
[58:50.400 --> 58:55.400]  Тогда расстояние только выросло, расстояние до нее хотя бы ДАТУ плюс один в этот момент времени.
[58:55.400 --> 58:59.400]  Но значит до этой расстояние хотя бы ДАТУ плюс два.
[58:59.400 --> 59:04.400]  Потому что раз это ребро на кратчайшем пути, значит здесь на один больше, чем здесь.
[59:04.400 --> 59:07.400]  Получается дальше сколько эта итерация проходит,
[59:07.400 --> 59:10.400]  и в момент, когда это ребро вновь насыщается,
[59:10.400 --> 59:15.400]  получается опять-таки хотя бы ДАТУ плюс два.
[59:15.400 --> 59:20.400]  Получается, что между двумя последовательными насыщениями одного и того же ребра
[59:20.400 --> 59:25.400]  расстояние до начала увеличивается хотя бы на два.
[59:25.400 --> 59:29.400]  Понятно, что расстояние всегда не очень большое,
[59:29.400 --> 59:34.400]  а именно расстояние всегда не больше, чем В минус один.
[59:34.400 --> 59:38.400]  В невзвешенном графе все расстояния не больше, чем В минус один.
[59:38.400 --> 59:41.400]  Ну и все, значит у меня этих насыщений может быть не очень много.
[59:41.400 --> 59:46.400]  Если между двумя насыщениями увеличивается расстояние хотя бы на два,
[59:46.400 --> 59:51.400]  но при этом ограничено сверху В, то значит насыщение примерно В пополам.
[59:51.400 --> 01:00:07.400]  Следовательно, насыщение ребра В может быть не больше, чем примерно В пополам.
[01:00:07.400 --> 01:00:16.400]  Что есть у АТВ, что мы и хотели. Понятно?
[01:00:16.400 --> 01:00:25.400]  Ну вот, все отсюда уже немедленно следует, что алгоритм Эдманскарпа работает за ВЕ квадрат.
[01:00:25.400 --> 01:00:41.400]  То есть всегда находит максимальный поток и работает за ВЕ квадрат.
[01:00:41.400 --> 01:00:46.400]  Корректность очевидна, потому что Эдманскарп это просто модификация Форда Фалкерсона.
[01:00:46.400 --> 01:00:49.400]  Пока есть путь во старшем сети, найди его и пусти поток.
[01:00:49.400 --> 01:00:53.400]  Понятно, что корректность следует немедленно из теоремы, из теоремы Форда Фалкерсона.
[01:00:53.400 --> 01:00:57.400]  Почему ВЕ квадрат?
[01:00:57.400 --> 01:01:06.400]  Ну смотрите, давайте я замечу следующее, что каждая итерация алгоритма,
[01:01:06.400 --> 01:01:12.400]  то есть каждый раз, когда я опускаю поток вдоль какого-то пути, она насыщает хотя бы одно ребро.
[01:01:12.400 --> 01:01:17.400]  Потому что как работает эта итерация? Я нахожу кратчайший путь в ЖФ,
[01:01:17.400 --> 01:01:22.400]  выбираю среди всех остаточных капаситей минимальную, то есть я смотрю на все ребра,
[01:01:22.400 --> 01:01:26.400]  выбираю минимальную остаточную капасити и пускаю вдоль этого пути ровно такой поток,
[01:01:26.400 --> 01:01:28.400]  какая минимальная капасити.
[01:01:28.400 --> 01:01:32.400]  Значит, то самое ребро, которое было с минимальной капасити, оно и насытилось.
[01:01:32.400 --> 01:01:45.400]  Поэтому каждая итерация алгоритма насыщает хотя бы одно ребро.
[01:01:45.400 --> 01:01:54.400]  Но поскольку каждое ребро, коих Е, насыщается всего В пополам раз, то значит итерацией будет ВЕ.
[01:01:54.400 --> 01:01:57.400]  Итерацией от ВЕ.
[01:01:57.400 --> 01:02:02.400]  Потому что каждое ребро насыщается столько раз, значит суммарная итерация ВЕ.
[01:02:02.400 --> 01:02:06.400]  Ну и все, а каждая итерация это просто BFS, которая работает за Е.
[01:02:06.400 --> 01:02:10.400]  Отсюда вот такая симптомка.
[01:02:10.400 --> 01:02:12.400]  Ну вот.
[01:02:17.400 --> 01:02:20.400]  Ого, что-то я прям быстро сегодня.
[01:02:22.400 --> 01:02:24.400]  Ну что, понятно?
[01:02:26.400 --> 01:02:28.400]  Вот, хорошо.
[01:02:28.400 --> 01:02:30.400]  Ну, пройдемаскарпайда доказали.
[01:02:30.400 --> 01:02:33.400]  Еще раз повторюсь, что это какая-то теоретическая оценка.
[01:02:33.400 --> 01:02:39.400]  И на конкретных графах, которые вы сами строите руками, специфического вида,
[01:02:39.400 --> 01:02:41.400]  скорее всего этот маскарп работает быстрее.
[01:02:41.400 --> 01:02:44.400]  То есть конкретно такая асимпточка не достигается.
[01:02:44.400 --> 01:02:46.400]  Но в общем случае на это надеяться нельзя.
[01:02:46.400 --> 01:02:51.400]  И тут как бы зависит от удачи и от чего-нибудь еще возможно.
[01:02:53.400 --> 01:02:55.400]  Может нормально, может ненормально.
[01:02:55.400 --> 01:02:57.400]  Короче, магия обычно происходит.
[01:02:59.400 --> 01:03:03.400]  Так, ну давайте расскажу один способ, как можно это ускорить.
[01:03:10.400 --> 01:03:12.400]  Это называется масштабирование.
[01:03:15.400 --> 01:03:17.400]  Техника масштабирования.
[01:03:29.400 --> 01:03:31.400]  Идея.
[01:03:31.400 --> 01:03:33.400]  Ну давайте я здесь скажу сначала следующее.
[01:03:33.400 --> 01:03:35.400]  То есть какое-нибудь С большое.
[01:03:37.400 --> 01:03:39.400]  Это ограничение сверху на все capacity.
[01:03:41.400 --> 01:03:45.400]  Ограничение сверху на все capacity.
[01:03:48.400 --> 01:03:51.400]  И давайте скажу, что нет кратных ребер.
[01:03:51.400 --> 01:03:53.400]  Здесь это будет важно.
[01:03:56.400 --> 01:04:01.400]  Если есть две вершинки УВ, то между ними может течь максимум С потока.
[01:04:01.400 --> 01:04:03.400]  Capacity максимум С.
[01:04:05.400 --> 01:04:07.400]  Так, хорошо.
[01:04:07.400 --> 01:04:09.400]  Значит тогда давайте будем делать следующее.
[01:04:11.400 --> 01:04:17.400]  Давайте будем пытаться пускать потоки сначала какими-то очень большими пачками.
[01:04:19.400 --> 01:04:21.400]  Представьте, С равно 200.
[01:04:23.400 --> 01:04:27.400]  Давайте возьмем максимальную степень двойки, не происходящую С.
[01:04:28.400 --> 01:04:30.400]  Сейчас 128.
[01:04:30.400 --> 01:04:35.400]  Давайте тогда все те ребра, у которых capacity больше или равно, чем 128.
[01:04:35.400 --> 01:04:38.400]  Будем считать, что на них просто написано 128.
[01:04:40.400 --> 01:04:43.400]  Те, кто больше, останутся просто 128.
[01:04:43.400 --> 01:04:48.400]  А те, кто были меньше, чем 128, получают нулевую capacity.
[01:04:49.400 --> 01:04:55.400]  Сейчас я хочу представить, что я ищу поток, такой неразделимый поток величины 128.
[01:04:55.400 --> 01:04:59.400]  Соответственно все, что меньше, чем 128, все ребра с меньшей capacity я могу просто дропнуть.
[01:04:59.400 --> 01:05:04.400]  У нас, конечно, у них нулевой поток, потому что все равно я вдоль этого ребра не смогу протолкнуть 128 потока.
[01:05:05.400 --> 01:05:08.400]  Хорошо, но давайте я сделаю такое преобразование.
[01:05:09.400 --> 01:05:15.400]  Тогда теперь у меня в графе все ребра имеют по факту либо 0, либо 128 capacity.
[01:05:16.400 --> 01:05:25.400]  Тогда можно все поделить смело на 128, пускать поток величины 1 и в конце ответ умножить на 128.
[01:05:25.400 --> 01:05:27.400]  То есть я здесь еще поделю.
[01:05:30.400 --> 01:05:37.400]  Ну и на таком графе запущу любой алгоритм Эдман Скарпа или Форда Фалкерсона, и вот на таком графе найду поток.
[01:05:38.400 --> 01:05:43.400]  Умножу ответ на 128, соответственно получу какое-то приближение к ответу в исходной сети.
[01:05:44.400 --> 01:05:50.400]  Я пускал потоки такими большими батчами по 128, это какое-то приближение к ответу.
[01:05:50.400 --> 01:05:52.400]  Хорошо, вот что-то построили.
[01:05:52.400 --> 01:05:58.400]  Дальше давайте спустимся на шурчик пониже, будем пускать потоки поменьше, по 64.
[01:05:59.400 --> 01:06:04.400]  Ну опять, у меня есть какие-то ребра, те, которые меньше, чем 64 я их просто игнорирую, те, которые больше.
[01:06:05.400 --> 01:06:14.400]  Ну вот здесь уже может быть такое, что будут ребра, скажем, если на ребре написано 130, то оно превратится в 128, равное 64 умножить на 2.
[01:06:15.400 --> 01:06:20.400]  То есть потенциально у меня остаются такие большие ребра, и соответственно я их превращаю в 64 умножить на 2.
[01:06:20.400 --> 01:06:25.400]  И соответственно потом, после деления на 64, там будет просто 2 написано.
[01:06:26.400 --> 01:06:35.400]  Вот. Ну здесь опять будет некая сеть с небольшими уже capacity, то есть на ребрах будет написано не 64, не 130, а 2 просто.
[01:06:36.400 --> 01:06:43.400]  Ну тогда, например, Форт Фалкерсон будет довольно быстро работать, потому что если capacity маленькие, то и поток маленький, значит и Форт Фалкерсон будет быстро работать.
[01:06:44.400 --> 01:06:49.400]  Ну и так далее. Буду уменьшать размер батча по степеням 2 вплоть до 1.
[01:06:50.400 --> 01:07:01.400]  Соответственно в конце я буду пытаться пустить поток величины 1, ну просто в исходной сети, без всяких сокращений, потому что когда у меня будет единица здесь, у меня никаких вот этих вот сжатий и масштабирований не будет уже.
[01:07:02.400 --> 01:07:06.400]  Значит, в конце я точно получу правильный поток, потому что, ну потерем Форта Фалкерсона опять.
[01:07:07.400 --> 01:07:11.400]  Я там какие-то потоки пустил изначально, потом добиваю это потоком величины 1.
[01:07:13.400 --> 01:07:15.400]  Ну вот и все, такая идея.
[01:07:16.400 --> 01:07:19.400]  Теперь давайте это как-нибудь запишем.
[01:07:20.400 --> 01:07:34.400]  Ну как-нибудь совсем схематично напишу следующим образом.
[01:07:34.400 --> 01:07:42.400]  Значит, давайте в цикле по всем K от 2-ичного логарифма С до нуля.
[01:07:44.400 --> 01:07:48.400]  Значит, ну я что делаю? Я вот делаю такое преобразование.
[01:07:49.400 --> 01:07:58.400]  Я каждую остаточную capacity округляю, то есть считаю сколько раз туда помещается 2 вкатый, и оставляю только то, сколько раз тут поместилось 2 вкатый.
[01:07:58.400 --> 01:08:07.400]  Поэтому я для любого ребра просто говорю, что вот новая capacity в масштабированном графе, это просто остаточная capacity поделить на 2 вкатый.
[01:08:08.400 --> 01:08:12.400]  То есть сколько раз через это ребро можно пропустить batch поток величины 2 вкатый.
[01:08:12.400 --> 01:08:34.400]  Дальше находим в новом графе, в новом графе, поток, ну там, здесь неважно, с помощью Форд Фалтерсона или с помощью Эдмонс Карпа, тут с точки зрения симптотики не влияет.
[01:08:34.400 --> 01:08:46.400]  Ну и дальше увеличиваем этот поток на 2 степеника. Точнее, умножаем его на 2 степеника.
[01:08:51.400 --> 01:08:59.400]  В частности, на последней итерации, когда кара равно нулю, у меня просто C штриха то же самое, что C с инксом F, то есть просто остаточная capacity, потому что делю на 1.
[01:08:59.400 --> 01:09:04.400]  Ну и значит, в частности, на последней итерации я просто добиваю всеми возможными путями.
[01:09:04.400 --> 01:09:16.400]  Поэтому корректность как раз очевидна здесь. Я опускаю потоки сначала большие, 128, 64, 32 и так далее, а заканчиваю, добиваю все потоками величины 1 и так делаю, пока все пути не исчерпаются.
[01:09:16.400 --> 01:09:19.400]  Поэтому ответ будет точно правильный.
[01:09:20.400 --> 01:09:28.400]  Ну и вот утверждается, что это работает за E квадрат на лог C.
[01:09:33.400 --> 01:09:40.400]  Что потенциально может дать выигрыш по сравнению с обычным Эдмонс Карпом, где был E квадрат на лог В, обычно лог C все-таки сильно меньше, чем В.
[01:09:43.400 --> 01:09:46.400]  Так, хорошо. Давайте это попробуем доказать.
[01:09:49.400 --> 01:10:07.400]  Ну, мне понадобится следующий факт. Пусть LEM опять будет.
[01:10:07.400 --> 01:10:27.400]  Лемма 11. Пусть F большое. Это настоящий максимальный поток, величина максимального потока.
[01:10:27.400 --> 01:10:39.400]  Вот, а F с индексом K это величина потока, найденная после ката-итерации.
[01:10:39.400 --> 01:10:51.400]  Величина потока найденная после ката-итерации.
[01:10:51.400 --> 01:10:58.400]  K вот у меня также пронумерована. То есть у меня сначала итерация с номером лог C, потом лог C-1 и так далее вплоть до нуля.
[01:10:58.400 --> 01:11:07.400]  Вот тогда F не больше, чем F ката, плюс 2 в каты, но ж на E.
[01:11:07.400 --> 01:11:35.400]  Ну, хорошо. Доказательства. Давайте рассмотрим остаточную сеть после ката-итерации.
[01:11:35.400 --> 01:11:49.400]  Как она устроена? После ката-итерации в остаточной сети нет пути.
[01:11:49.400 --> 01:11:54.400]  Но вот в остаточной пути вот с этими штрихованными масштабированными ребрами.
[01:11:54.400 --> 01:12:01.400]  То есть на самом деле ребра-то вот здесь как бы есть.
[01:12:01.400 --> 01:12:10.400]  Ну, как обычно, S это все достижимые, T это все остальные. На самом деле ребра-то есть, но у них как бы вес меньше, чем 2 в каты.
[01:12:10.400 --> 01:12:17.400]  То есть они как бы, они может быть и есть, но по ним их недостаточно, чтобы пускать большие батчи потока.
[01:12:17.400 --> 01:12:22.400]  На этих ребер остаточная capacity будет меньше, чем 2 в степаняка.
[01:12:22.400 --> 01:12:27.400]  Ну, потому что было бы больше, тогда это ребро присутствовало бы вот здесь.
[01:12:27.400 --> 01:12:34.400]  А здесь у него было бы тогда положительный C-штрих, значит эта вершинка должна была быть в S.
[01:12:34.400 --> 01:12:39.400]  Ну, значит суммарно величина вот этого разреза, она меньше 2 в каты умножить на E.
[01:12:39.400 --> 01:12:46.400]  Потому что всего у меня E-ребер, и каждый имеет capacity максимум 2 в каты.
[01:12:46.400 --> 01:12:54.400]  Значит, величина вот этого разреза не больше, чем 2 в каты умножить на E.
[01:13:03.400 --> 01:13:08.400]  Максимальный поток. То есть вот мы построили новый граф, вот такой вот, с такими капастями.
[01:13:08.400 --> 01:13:12.400]  Дальше в этом графе масштабируемым, таком сжатым находим максимальный поток.
[01:13:12.400 --> 01:13:16.400]  Ну, не один путь, а максимальный. То есть пока все не исчерпаются.
[01:13:16.400 --> 01:13:20.400]  Именно поэтому как раз я говорю, что после каты итерации не остается вообще путей
[01:13:20.400 --> 01:13:26.400]  по ребрам с capacity больше равно 2 в каты. Значит, все вот эти ребра как раз меньше capacity.
[01:13:26.400 --> 01:13:35.400]  Ну вот, а я знаю, что в этой остаточной сети поток, по сути,
[01:13:35.400 --> 01:13:39.400]  остаточный поток от F-каты до F, он не больше, чем этот разрез,
[01:13:39.400 --> 01:13:41.400]  потому что поток всегда не больше, чем разрез.
[01:13:41.400 --> 01:13:46.400]  Значит, остаточный поток, он не больше, чем конкретный вот этот разрез,
[01:13:46.400 --> 01:13:49.400]  который не больше 2 в каты умножить на E.
[01:13:49.400 --> 01:13:53.400]  Ну а остаточный поток, это в точности F-F-каты.
[01:13:53.400 --> 01:13:56.400]  Потому что F это максимальный, а F-каты тоже пущенный.
[01:13:56.400 --> 01:13:59.400]  Осталось до конца добить как раз F-Fk.
[01:13:59.400 --> 01:14:02.400]  Ну, отсюда получается вот это неравенство.
[01:14:02.400 --> 01:14:14.400]  Так, что-то понятно? Хорошо.
[01:14:14.400 --> 01:14:25.400]  Лемма 2. Для любого к, на каты итерации,
[01:14:26.400 --> 01:14:33.400]  алгоритм находит не больше, чем E путей.
[01:14:33.400 --> 01:14:43.400]  Алгоритм находит не больше E путей.
[01:14:44.400 --> 01:14:51.400]  Пардон, 2E.
[01:14:51.400 --> 01:14:55.400]  Да, ну, то есть еще раз, у меня здесь внутри есть какой-то рекурс,
[01:14:55.400 --> 01:14:58.400]  ну там запуск, форт Фалкерс, неледман Скарпа.
[01:14:58.400 --> 01:15:01.400]  Каждый из них работает так, находит какой-то путь в графе,
[01:15:01.400 --> 01:15:04.400]  пускает по нему поток, находит путь, пускает поток и так далее.
[01:15:04.400 --> 01:15:08.400]  Вот я отмечаю, что в суммарных путей любой из них найдет максимум 2E.
[01:15:08.400 --> 01:15:12.400]  Ну почему? Смотрите, я вижу, что остаточный поток максимум вот такой.
[01:15:12.400 --> 01:15:20.400]  Но при этом, ну окей, давайте, давайте идею сначала.
[01:15:20.400 --> 01:15:23.400]  Смотрите, я понимаю, что с предыдущего шага, вот если у меня катый шаг закончился,
[01:15:23.400 --> 01:15:27.400]  а ката итерация закончилась, то мне осталось пустить максимум вот столько потока.
[01:15:27.400 --> 01:15:31.400]  Дальше, на следующей итерации k-1, у меня k уменьшается,
[01:15:31.400 --> 01:15:35.400]  на k-1 итерации мне нужно пустить максимум вот столько потока,
[01:15:35.400 --> 01:15:38.400]  но если я нахожу какой-то путь в этот момент времени,
[01:15:38.400 --> 01:15:42.400]  то я по нему пускаю хотя бы 2 в k-1 потока,
[01:15:42.400 --> 01:15:45.400]  потому что у меня бачи будут иметь размер как раз 2 в степени k-1.
[01:15:45.400 --> 01:15:50.400]  Но если мне осталось вот столько, а любой путь привносит мне вот столько,
[01:15:50.400 --> 01:15:55.400]  то значит путей максимум как раз 2E. Вот то поделить вот на это будет как раз 2E.
[01:15:55.400 --> 01:15:58.400]  Давайте это запишем быстренько.
[01:15:58.400 --> 01:16:27.400]  Значит, после каты итерации остается найти не больше, чем 2 в k-1,
[01:16:27.400 --> 01:16:30.400]  а, возможно, E-потока.
[01:16:32.400 --> 01:16:40.400]  Далее, любой путь, найденный на k-1 итерации,
[01:16:48.400 --> 01:16:51.400]  увеличивает поток хотя бы на 2 в степени k-1.
[01:16:57.400 --> 01:17:10.400]  Потому что как раз все ребра сжались так, что единичка превратилась в 2 в степени k-1.
[01:17:10.400 --> 01:17:16.400]  Если нашел путь, то значит с точки зрения исходной сети на нем поток вот такой хотя бы.
[01:17:16.400 --> 01:17:26.400]  Ну все, значит путей не больше, чем вот этот дробь 2 в k-1E делит на 2 в степени k-1.
[01:17:26.400 --> 01:17:30.400]  Потому что столько осталось, но каждый путь привносит вот столько хотя бы.
[01:17:30.400 --> 01:17:32.400]  Это просто 2E.
[01:17:32.400 --> 01:17:35.400]  Иначе путей мало.
[01:17:39.400 --> 01:17:45.400]  Ну и все. Отсюда следствие, что алгоритм работает за...
[01:17:45.400 --> 01:17:51.400]  Ну, конечно, это утверждение доказывает, что алгоритм работает за E2лc.
[01:17:59.400 --> 01:18:05.400]  Ну, это уже вроде очевидно. Вот столько всего итераций, k пробегает вот столько значений и логарифмическая.
[01:18:05.400 --> 01:18:10.400]  И дальше, на каждой итерации, что я делаю? Я запускаю от Манскарпа или Форт Фалкерсона,
[01:18:11.400 --> 01:18:15.400]  но каждый из них находит максимум 2E-путей.
[01:18:15.400 --> 01:18:19.400]  Каждый путь находится с помощью DFS или BFS, то есть еще за E примерно.
[01:18:19.400 --> 01:18:24.400]  Получается отсюда как раз E2. У меня вот столько. У меня E итерации, O от E итерации.
[01:18:24.400 --> 01:18:27.400]  И каждая итерация работает за E.
[01:18:27.400 --> 01:18:36.400]  Поэтому вот суммарно, при каждом k, вот этот Форт Фалкерсон или Манскарп, неважно кто, работает за O от E2.
[01:18:36.400 --> 01:18:39.400]  Ну, суммарная симптомика вот такая.
[01:18:42.400 --> 01:18:48.400]  Так, вроде все. Отлично. Вопросы есть?
[01:18:48.400 --> 01:18:51.400]  Ну, тогда все. Спасибо. До следующего раза.
