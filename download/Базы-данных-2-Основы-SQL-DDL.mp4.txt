[00:00.000 --> 00:13.440]  Более практическая тема. Будем знакомиться с основами SQL на более или менее конкретных примерах.
[00:13.440 --> 00:22.320]  Посмотрим некоторые особенности того подможества команд, которые мы сегодня успеем затронуть.
[00:22.320 --> 00:33.880]  Но давайте, наверное, хотелось бы начать. Вот с чего был на прошлой лекции вопрос по делению.
[00:33.880 --> 00:42.960]  Давайте немножко вернемся на корреляционным операциям и начнем с повторения того,
[00:42.960 --> 00:53.080]  что было с повторением деления. Более детального, что и разбора. Во-первых, немножко про нотацию.
[00:53.080 --> 01:02.080]  Более или менее строго, если подходить к вопросу нотации реалиционной алгебры,
[01:02.080 --> 01:09.720]  то она представлена на экране. Символьная запись более-менее общепринятая. Запоминать
[01:09.760 --> 01:14.800]  по большому счету не нужно. Просто зачем приведена на экране табличка? Затем,
[01:14.800 --> 01:20.120]  чтобы следующая формула была понятна. Формула формального определения деления.
[01:20.120 --> 01:28.240]  Оно выражается через операции проекции, выборки и ряд теоретиков множественных операций.
[01:28.240 --> 01:37.320]  Вот формальное деление можно определить следующим образом. Здесь у нас три теоретика множественной
[01:37.320 --> 01:45.520]  операции и несколько проекций с ограничениями. Какого-то более или менее простого алгоритма
[01:45.520 --> 01:51.000]  наверное предложить здесь не удастся. В конце того набора слайдов про деление,
[01:51.000 --> 01:56.440]  который сейчас пойдет, там будет более простая формулировка того, что происходит при делении,
[01:56.440 --> 02:00.520]  на что нужно обратить внимание. Но вот формально, полноценно это записывается,
[02:00.520 --> 02:04.920]  операция деления. Определяется следующим образом, как показано на слайде. И соответственно,
[02:04.920 --> 02:17.920]  теоретика множественных операций здесь три основных. Это построение декартового произведения,
[02:17.920 --> 02:23.200]  исключение уже существующих кортежей из этого произведения и исключение из кортежей,
[02:23.200 --> 02:27.840]  имеющихся потенциальными ответами того, что у нас получилось в первых двух действиях в скобках.
[02:27.840 --> 02:36.280]  Так, хорошо, деление. Определение такое, посмотрим на конкретном примере. Допустим,
[02:36.280 --> 02:40.240]  у нас есть два отношения поставщики и товары. Нужно найти всех поставщиков цена товаров,
[02:40.240 --> 02:44.960]  у которых больше тысячи рублей. Поставщики, товары. Товары соответственно у нас два
[02:44.960 --> 02:50.600]  соответствуют условия, это кирпич и цемент. Применим операцию деления. Собственно, что мы
[02:50.600 --> 02:56.720]  будем делать? Мы будем делать следующее. Сначала мы для ответа исключим лишние данные из наших
[02:56.720 --> 03:01.520]  отношений. Сделаем проекцию по поставщикам и по товарам, потому что нам нужны только
[03:01.520 --> 03:09.120]  правильные идентификаторы поставщиков. Построим проекцию, которая нам необходима для первого
[03:09.120 --> 03:18.760]  нашего действия. По формуле, там где у нас внутренняя скобка с цифрой 1 над знаком декартового
[03:18.760 --> 03:24.120]  произведения, соответственно мы строим левый оперант этого произведения. Построим проекцию
[03:24.120 --> 03:32.800]  по поставщикам, причем R1-R2. То есть мы исключаем, здесь происходит операция вычитания,
[03:32.800 --> 03:42.120]  мы исключаем лишних поставщиков из отношений R1 по соответственно тем поставщикам, которые вошли в
[03:42.120 --> 03:48.200]  отношение R2. Построим декартового произведения теперь. То есть совершим первое действие в наших
[03:48.200 --> 03:54.680]  скобках. Вот результат мы видим на экране. Произведем вычитание, то есть совершим второе действие по
[03:54.680 --> 04:04.440]  порядку. Что у нас получается? Соответственно вот результат виден тоже на экране. Вычитаем из
[04:04.440 --> 04:10.320]  меньше таблицы большую. Вычитание у нас происходит, как вы должны уже знать, по совпадающим только
[04:10.320 --> 04:16.200]  элементам. Соответственно тот факт, что у нас поставщики таблица более емкая, отношение более
[04:16.200 --> 04:22.400]  емкое, ничего нам не говорит. Мы из первого отношения вычитаем только то, что у нас совпадает со
[04:22.400 --> 04:31.960]  вторым. Получаем результат, соответственно, хлопнутая, уменьшенная таблица, измененные отношения
[04:31.960 --> 04:39.960]  слева от знака вычитания множества. Ну, вычитание отношений, если вернее. Теперь мы строим проекцию,
[04:39.960 --> 04:46.440]  чтобы нам получить правый оперант для третьего действия. У нас получается всего четыре поставщика
[04:46.440 --> 04:56.520]  в данном случае. И мы соответственно этих четырех поставщиков, их идентификаторы вычитаем из
[04:56.520 --> 05:07.200]  левого операнда, из проекции, которую мы построили в самом начале, поскольку у нас соответственно
[05:07.200 --> 05:14.040]  таким образом получится правильный ответ. То есть мы вычитаем из всех потенциальных ответов
[05:14.040 --> 05:21.360]  неправильные ответы и получаем исключить оставшийся один правильный ответ. Ну, грамостка получается,
[05:21.360 --> 05:28.240]  на словах, наверное, не очень удобно это воспринимать. Оставляю это вам для изучения уже, может быть,
[05:28.240 --> 05:35.280]  по слайдам более как-то постепенно, если кому будет интересно в своем темпе, что называется.
[05:35.280 --> 05:41.160]  А то, на что собственно сущностно надо обратить внимание еще, это то, что деление в религационной
[05:41.160 --> 05:45.760]  алгебре похоже на арифметическое деление. При построении декартового произведения частного
[05:45.760 --> 05:51.320]  и делителя мы должны получить подмножество отношений делимого. То есть у нас результат
[05:51.320 --> 06:03.240]  должен быть всегда, при его декартовом произведении с делителем, всегда должен давать подмножество
[06:03.960 --> 06:10.200]  делимого м Ki подмножества исходного множества. Не обязательно мы построим,
[06:10.200 --> 06:19.000]  обратив деление, совершив обратную опирацию, то есть она несимметрична в данном случае. Не
[06:19.000 --> 06:23.080]  обязательно мы построим исходное множество, множество А вот как проведено на слайде. Но
[06:23.080 --> 06:28.360]  мы точно получим подмножество этого множества. А если мы этого не получаем, соответственно мы
[06:28.360 --> 06:33.040]  что-то пределение сделали неправильно. Надо пересмотреть наши шаги.
[06:33.040 --> 06:39.760]  Также деление можно описать следующим образом, но, мне кажется, это то, вот
[06:39.760 --> 06:44.840]  следующее это описание, оно не работает без того, чтобы я привел на предыдущих
[06:44.840 --> 06:49.480]  слайдах, а предыдущие слайды, с другой стороны, не работают без вот такого
[06:49.480 --> 06:56.480]  пояснения, более простого, наверное, потому что как-то вот выглядит это все
[06:56.480 --> 07:03.040]  очень формально, но смысл довольно простой. У нас есть два отношения и
[07:03.040 --> 07:06.920]  атрибуты, конечно, должны быть определены на одном и том же домене.
[07:06.920 --> 07:11.640]  Результатом деления A на B будет отношение с заголовком из атрибута X и
[07:11.640 --> 07:16.400]  телом, в котором входят кортежи
[07:18.400 --> 07:23.840]  X из домена X, такие, что существует кортеж XY, который
[07:24.000 --> 07:28.840]  принадлежит отношению A для всех кортежей Y из домена Y, из отношения B.
[07:28.840 --> 07:35.120]  Тоже, пожалуй, грабостка, но смотрите, то есть, по сути дела, мы
[07:35.120 --> 07:45.440]  пытаемся поделить совокупности наших строк, которые подходят нам
[07:45.440 --> 07:50.640]  исходя из того, какой у нас делитель. Мы пытаемся на эти совокупности
[07:50.640 --> 08:00.440]  срок поделить делимое и получить частное, которое будет содержать те
[08:00.440 --> 08:07.960]  атрибуты, которые у нас были, собственно говоря, в исходном отношении, ну, по крайней
[08:07.960 --> 08:13.560]  мере, под множество тех атрибутов. На этом я, пожалуй, оставлю вас с операции
[08:13.560 --> 08:18.440]  релиционного деления. Может быть, на слух, повторюсь, это воспринимается не
[08:18.440 --> 08:24.320]  очень удобно, но если вы хотите немножко так проникнуться, то просто посмотрите
[08:24.320 --> 08:30.960]  пошагово на слайды, посмотрите, что, где происходит от одного действия к другому.
[08:30.960 --> 08:35.240]  Но, как я уже сказал, деление операции производной, она хоть и выделяется среди
[08:35.240 --> 08:39.760]  теоретикам, среди релиционных, но, по сути дела, она выразима через более простые.
[08:40.760 --> 08:44.760]  Ну, и из того, что С на В принадлежит А в целом, понятен смысл.
[08:44.760 --> 08:51.760]  Да, то есть, поэтому, раз сдаем, мы поставим точку с релиционной, наверное,
[08:51.760 --> 08:56.760]  с операциями релиционной. Одну секунду, вопрос в чате.
[08:56.760 --> 09:00.760]  Про квиз будет написано отдельно, ребята.
[09:00.760 --> 09:05.760]  Так, а что дальше читать про позу Гресс-Кьюэль?
[09:05.760 --> 09:10.760]  Смотрите, то есть, сейчас мы с вами переходим от теоретической, исключительно теоретической
[09:10.760 --> 09:18.760]  такой части, к части практически, полностью практической, извините за
[09:18.760 --> 09:24.760]  тавтологию, мы уже будем работать конкретно не просто даже с языком, но и
[09:24.760 --> 09:30.760]  с конкретным его приложением, с конкретной его реализацией в СБД-Позгресс.
[09:30.760 --> 09:34.760]  И поэтому, конечно, нужно определиться, на что нам операция, на что обращать
[09:34.760 --> 09:38.760]  внимание. Ну, здесь, наверное, я думаю, вам уже на семинарах все это сказали,
[09:38.760 --> 09:41.760]  даже предоставили какую-то, может быть, более детальную подборку литературы,
[09:41.760 --> 09:46.760]  в зависимости от семинаристов. Я обращаю у вас ваше внимание только на
[09:46.760 --> 09:52.760]  самые что ли такие важные источники, которые просто нужно иметь в виду,
[09:52.760 --> 09:55.760]  только на
[09:58.280 --> 10:07.520]  только на самые что ли такие важные источники, которые просто нужно иметь в
[10:07.520 --> 10:12.040]  виду может быть для кого-то да может быть
[10:13.680 --> 10:19.000]  может быть кто-то не успел записать на семинаре условно говоря вот повторяю на
[10:19.000 --> 10:23.040]  лекции это в первую очередь конечно же документация документация хорошая
[10:23.040 --> 10:27.960]  подробная исчерпывающая я более того есть официальная документация на русском
[10:27.960 --> 10:33.800]  языке подготовленная пост-гресс профессионал компании это наши российские вендоры
[10:33.800 --> 10:40.600]  поставляют на основе пост-гресса решения коммерческие соответственно
[10:40.600 --> 10:47.480]  занимаются поддержкой большой вклад компания вносят в open source составляющие
[10:47.480 --> 10:55.520]  пост-гресса и отдельные люди которые за ней стоят вставатели и топ менеджеры они
[10:55.520 --> 11:02.840]  в принципе сами довольно давно в этом участвуют в поддержании open source ветки
[11:02.840 --> 11:06.400]  пост-гресса что называется вносит туда какие-то дополнительные функции и
[11:06.400 --> 11:17.800]  улучшают всячески помимо собственно до коммерческого решения и в общем это все
[11:17.800 --> 11:22.880]  ну заслуживает доверия это прямой прямой адекватный грамотный перевод того что
[11:22.880 --> 11:30.080]  написано на пост-гресс. ком да вот разделе documentation но единственное чуть-чуть чуть-чуть
[11:30.080 --> 11:34.960]  запаздывает переводные версии во всяком случае в свободном доступе вот как вы видите сейчас
[11:34.960 --> 11:41.560]  пост-гресс ql на официальном сайте есть версия 16 2 документации на сайте пост-гресс
[11:41.560 --> 11:49.560]  профессионал документация только версии 16 точка 1 точка 1 даже вот так по-моему но тем не менее
[11:49.560 --> 11:55.520]  там какие-то совсем для нас с вами очевидно незначительные изменения поэтому можно смело
[11:55.520 --> 12:00.080]  пользоваться русскоязычной версией хорошо на сайте пост-гресс еще рекомендую вам раздел
[12:00.080 --> 12:06.840]  образования там полезная информация ссылки всякие самое главное наверное что там есть это
[12:06.840 --> 12:12.880]  во-первых демо база с по-моему чуть ли там не на гигабайт если ее скачать разархивировать то
[12:12.880 --> 12:17.600]  есть там прямо можно посмотреть поиграться с каким-то реальными более менее запросами и
[12:17.600 --> 12:26.720]  там есть несколько книг в открытом доступе разной степени сложности наверное что ли вовлеченности
[12:26.720 --> 12:30.920]  у материала они тем не менее все равно не повторяет документацию то есть это такое надо
[12:30.920 --> 12:36.240]  множество смыслов по сравнению с документацией что ли или нет под множество наверное да а
[12:36.240 --> 12:41.960]  документация на гораздо более черпающие книги тем не менее неплохие даже хорошие даже отличный
[12:41.960 --> 12:48.520]  в некоторых местах и ну все я просто не читал возможно они полностью от а да и отличный вот
[12:48.520 --> 12:53.840]  допросят меня авторы если услышат тем не менее рекомендую для ознакомления по каким-то может
[12:53.840 --> 13:03.440]  быть вопросом которые документация выглядит не вполне однозначно ну конечно интернет поисковые
[13:03.440 --> 13:11.920]  движки места где люди обмениваются информацией по проблемам вопросом типа stack overflow конечно
[13:11.920 --> 13:16.840]  же никто не отменял для общего развития также вот интервью вам рекомендую последний с иваном
[13:16.840 --> 13:23.440]  панченко но довольно любопытный наверное если вы захотите чуть больше погрузиться в атмосферу что
[13:23.440 --> 13:32.680]  ли разработки субботы окей поехали дальше собственно то о чем мы с вами поговорим сегодня
[13:32.680 --> 13:38.640]  предметный плотно мы в принципе затронули это еще на прошлой лекции ну совсем кратенько совсем
[13:38.640 --> 13:51.840]  чуть-чуть structure query language да sequel sql рассмотрим общую информацию и рассмотрим потом собственно
[13:51.880 --> 14:00.160]  множество его команд ну какие успеем сегодня немного истории ну просто повторяю вот слайд
[14:00.160 --> 14:06.800]  перед вами оставляю на обозрение мы видели в прошлый раз еще раз единственно заостряю
[14:06.800 --> 14:17.560]  ваше внимание на последнем буллите что цитаты из статьи дональда чемберлина такой небольшая
[14:17.560 --> 14:26.640]  совсем его даже заметка про суть по сути дела про историю раннюю историю SQL SQL SQL я буду
[14:26.640 --> 14:39.000]  называть SQL сразу оговоришь да простят меня те кто любит говорить SQL и как вы видите да изначально
[14:39.000 --> 14:43.520]  наберем намерение был довольно благородным и заслуживающим всяких участников всяческого
[14:43.520 --> 14:51.800]  почрения разработчики хотели создать язык понятный для простого пользователя наверное сейчас
[14:51.800 --> 14:59.240]  сказать что он что и запрос что язык SQL прям понятие для любого простого пользователя ну
[14:59.240 --> 15:05.520]  это проблематично есть много нетрибиальных средств язык стал гораздо гипче и выразительнее
[15:05.520 --> 15:10.840]  потому что тогда первоначальной статье он описывался буквально парой страниц основные
[15:10.840 --> 15:17.240]  синтаксические конструкции сейчас стандарты многотысячные многотысячные страничные и
[15:17.240 --> 15:24.360]  язык стал более гибким проявились процедурные расширения в зависимости от одного вентера
[15:24.360 --> 15:32.080]  к другому и конечно появились возможности писать очень нетрибиальные запросы которых довольно
[15:32.080 --> 15:39.200]  сложно разобраться да и в принципе такие запросы довольно сложно сходу не изучив язык
[15:39.200 --> 15:49.000]  сложно сформулировать чуть-чуть буквально истории на слайде приведены даты ну такие отчасти
[15:49.000 --> 15:55.120]  наверное ключевые для ранней опять же истории SQL потом это уже пошло то ли называется более
[15:55.120 --> 16:04.600]  менее подокатанный но здесь может быть вот фамилия рейман фамилия имя рейман бойс это тот
[16:04.600 --> 16:15.640]  собой бойс который потом у нас появится форме бойса кода к сожалению рейман бойс умер 75 как
[16:15.640 --> 16:25.040]  раз по моему году и ну вот его память так сказать увековечен в том числе для всех изучающих курс
[16:25.040 --> 16:31.240]  баз данных видео от формы бойса конда нормальной формы бойса кода но о которой мы с вами поговорим
[16:31.240 --> 16:44.360]  попозже стандартизация SQL язык у нас стандартизирован первый стандарт 86 и 87 года к тому
[16:44.360 --> 16:56.560]  времени уже SQL стал широко достаточно широко используем в среде разработки и как суббота как
[16:56.560 --> 17:02.560]  так и разработки конкретных баз данных для конкретных приложений и предметных областей
[17:02.560 --> 17:10.800]  доработка с 86 года проходит в среднем раз в пять лет и сейчас действующая редакция она с июля
[17:10.800 --> 17:19.280]  2023 что называется вступила в силу это версия стандарта SQL 2023 а может на сам язык посмотрим
[17:19.280 --> 17:27.960]  да хорошо давайте посмотрим стандарты по годам выхода тогда у нас на слайде приведены вот
[17:27.960 --> 17:36.920]  последний стандарт SQL 2023 2023 тоже здесь у нас приведены ну такие может быть две основные
[17:36.920 --> 17:40.920]  реперные точки там еще есть всякие разные минорные для кого-то минорные может быть
[17:40.920 --> 17:45.560]  кто-то наоборот рассынет их как очень существенные изменения но пожалуй что наверное первое бросается
[17:45.560 --> 17:53.200]  в глаза это полноценная поддержка джейсон и новый раздел про протеграф queries есть определенные
[17:53.200 --> 17:58.960]  проблемы у стандартов потому что не все вендеры полноценно их поддерживают и нужно конечно
[17:58.960 --> 18:07.480]  обращаться к документации при переносе тех или иных программ команд из-за одной соба да в другую
[18:07.480 --> 18:16.240]  и также то есть и стандарт поддержит каждый вендор не в полной мере поддерживает во первых
[18:16.240 --> 18:21.240]  стандарт нет стопроцентной поддержки а с другой стороны даже в той части в которой поддерживается
[18:21.240 --> 18:28.240]  есть бывает различия по синтаксу по синтаксису и по логике поэтому смотрите документацию
[18:28.240 --> 18:36.720]  ребята группа операторов сql принято делить на четыре группы изначально вообще и часто даже
[18:36.720 --> 18:42.160]  сейчас можно говорить можно встретить что выделяют только первые две группы вот прям таких
[18:42.160 --> 18:51.800]  корневых что ли корневые группы две основные группы операторов этот detail и dml и ну собственно
[18:51.800 --> 18:59.960]  четыре по четыре команды в каждой группе четыре основные команды dcl и tcl мы тоже с вами затронем
[18:59.960 --> 19:06.200]  но мы их затронем уже попозже уже наверное даже после проектирования базы данных будем смотреть
[19:06.200 --> 19:14.640]  поэтому пока мы откладываем это что называется долгий ящик может быть не очень но отложим
[19:14.640 --> 19:25.080]  сегодня у нас в первую очередь дель посмотрим что успеем из dml но сразу предупреждаю предупреждаю
[19:25.080 --> 19:32.840]  что dml мы в полной мере сегодня не успеем захватить основные типы данных сql также на слайде приведены
[19:32.840 --> 19:38.840]  здесь собственно что можно пояснить это вот тогда самые самые такие знаете базовые что ли вещи
[19:38.840 --> 19:48.680]  которые будут вот такие какие они есть скорее всего без изменения там наименований в частности в
[19:48.680 --> 19:58.440]  каждой современной революционной собеде если вы откроете документацию посгрыса опять же то там
[19:58.440 --> 20:07.520]  увидите что дан типов данных ощутимо больше особенности их соответственно тоже ну покажет
[20:07.720 --> 20:13.360]  конечно свои особенности возможности использования в тех или иных командах поэтому конечно тоже опять
[20:13.360 --> 20:19.280]  же здесь смотрите документацию для более детального изучения каких-то специфических
[20:19.280 --> 20:30.400]  специфических типов данных в той или иной субботы а лексическая структура сql во первых сразу да
[20:30.400 --> 20:37.360]  сразу оговорюсь что здесь тоже вам рекомендую обращаться к документации в первую очередь
[20:37.360 --> 20:48.720]  четвертый раздел документации посгрыса там три таких объемных главы они правда написаны знаете
[20:48.720 --> 20:55.440]  не может быть не очень не очень последовательно в некотором роде но дают довольно полное
[20:55.440 --> 21:03.240]  представление о том что и как можно формулировать в языке но правда у нас есть определенные
[21:03.240 --> 21:08.880]  проблемы проблемы заключаются в том что синтаксис сql не очень строго определяет какие компоненты
[21:08.880 --> 21:14.600]  идентифицируют команды какие их операнды или параметры ну то есть в принципе у нас это вот как
[21:14.600 --> 21:20.440]  бы да если выделять конкретную конкретную проблему а вообще смысл в том что у нас
[21:20.440 --> 21:30.520]  даже не то что смысл а связано еще проблемность лексической структуры сql с тем что это язык
[21:30.520 --> 21:41.080]  декларативный и плюс есть определенные не строгие наверное правила в отношении формулирования
[21:41.080 --> 21:48.320]  тех или иных команд и здесь может быть не очень очевидно как сложно сформулировать какие-то
[21:48.320 --> 21:53.920]  общие правила не очень очевидно как использовать ту или иную команду поэтому тоже здесь уже
[21:53.920 --> 21:58.480]  наверное в третий или в четвертый раз я вам рекомендую обращаться в документанты документации
[21:58.480 --> 22:03.720]  обязательно если есть какие-то сомнения или команда повелась и будет так как нужно потому
[22:03.720 --> 22:09.040]  что по всем тем даже командам которые мы сейчас затронем или которые вы затрагиваете до семинарах
[22:09.040 --> 22:14.600]  и по которым вы наверное уже обращались документации вы наверное видели что в документации официально
[22:14.600 --> 22:20.520]  есть просто огромнейшие статьи с которой предваряются сначала формальным описанием абстрактным
[22:20.520 --> 22:26.880]  формальным описанием на псевдокоде команд операторов ключевых слов в этих командах и
[22:26.880 --> 22:37.120]  соответственно у каждой команды есть довольно большая вариативность и гибкость и соответственно
[22:37.120 --> 22:49.840]  довольно такие объемные правила ее использовали так вот компонентом команды что может быть ключевое
[22:49.840 --> 22:54.800]  слово идентификатор идентификатор в кавычках оператор строка или константа специальный символ
[22:54.800 --> 23:00.160]  как это все выглядит ну вот примерно иксически правильные сql программы
[23:08.120 --> 23:10.920]  соответственно ключевые слова
[23:16.240 --> 23:23.920]  ключевые слова крейт и показано отдельно выделено на слайде отдельные компоненты вот пример
[23:23.920 --> 23:30.200]  ключевых слов крейт тейбл это ключевые слова идентификатор в кавычках lectures имейте
[23:30.200 --> 23:35.360]  виду вот что у нас по умолчанию язык кейс инсенситив да то есть мы можем писать в принципе
[23:35.360 --> 23:46.360]  ну практически да там кемал кейсом можем писать каждую букву как нам заблагорассудиться с точки
[23:46.360 --> 23:53.400]  зрения регистра потому что во внутреннем таком первоначальном представлении все это будет
[23:53.400 --> 23:59.920]  приводиться к нижнему регистру и соответственно будет будут проводиться операции сопоставления но
[23:59.960 --> 24:09.520]  если мы идентификатор ставим в кавычках то мы говорим фактически нашей базе данных что у
[24:09.520 --> 24:13.840]  нас идентификатор должен быть обязательно именно такой если мы к нему будем обращаться
[24:13.840 --> 24:19.680]  обязательно такой как мы его прописали в кавычках но и обращаться мы будем к нему тоже используя его
[24:19.680 --> 24:27.760]  наименовать строку на являющиеся его на именование тоже заключая в кавычке поэтому определить
[24:27.840 --> 24:32.880]  определив идентификатор в кавычках вот например так как показано на слайде мы всегда его должны
[24:32.880 --> 24:39.240]  будем именно так задавать во всех наших запросах и никак иначе идентификатор в кавычках ну если
[24:39.240 --> 24:44.880]  дата для общего развития позволяет нам использовать в том числе и ключевые как не забавно слова здесь
[24:44.880 --> 24:52.760]  не будет наложение между ключевыми словами из по словами используемыми без кавычек ключевыми
[24:52.760 --> 24:59.400]  словами заключенными в кавычке это будет отдельно просто литерал где-то в некоем пространстве
[24:59.400 --> 25:08.000]  хранящим хранящийся пространстве памяти хранящийся у базы данных и она будет к нему относиться по
[25:08.000 --> 25:13.880]  особому не будет наложение ну конечно наверное вряд ли вам потребуется все-таки в общем случае
[25:13.880 --> 25:21.440]  ключевые слова использовать в качестве идентификаторов так специальный символ вот в примере он приведен
[25:21.440 --> 25:27.440]  в виде звездочки в данном случае select from students ну я думаю вы уже знаете что эта команда у
[25:27.440 --> 25:35.040]  нас выведет все строки из таблицы students students соответственно идентификатор уже обычный без
[25:35.040 --> 25:43.040]  кавычек он будет опять же casing sensitive а константы константы тоже приведены на слайде вот они
[25:43.040 --> 25:55.560]  выделены в команде insert insert into трататата values и два две величины вносятся для константа вносится
[25:55.560 --> 26:03.440]  в таблицу язык поддерживает комментарии однострочные комментарии многосрочные комментарии однострочные
[26:03.440 --> 26:08.560]  комментарии у нас с двумя дефисами обозначается и после двух дефисов все что идет до конца строки
[26:08.560 --> 26:15.320]  соответственно является комментарии комментарии ему многосрочные комментарии использует си подобный
[26:15.320 --> 26:27.040]  синтаксис давайте с вами попробуем начать обзорное знакомство с основными группами команд с ql ddl и
[26:27.040 --> 26:37.920]  dml начнем соответственно с data definition language и с его четырех основных команд сразу оговорюсь
[26:38.000 --> 26:42.880]  вот вот по поводу чего у нас есть наверное определенная проблема в изложении может быть
[26:42.880 --> 26:54.760]  потому что у нас здесь есть в сql есть некоторые вещи которые нельзя объяснить не объяснив другие
[26:54.760 --> 27:00.440]  вещи которые должны быть объяснены после первых вещей вот вот такая немножко да запутанная
[27:00.440 --> 27:07.680]  конструкция но по сути дела просто напросто имеется в виду что вот мы сегодня с вами затронем
[27:07.680 --> 27:13.080]  тернарную логику и ключи но по большому счету тернарная логика относится не только к дд л операциям
[27:13.080 --> 27:21.840]  и ключи тоже не ограничиваются дд л командами их значение и особенности и поэтому и с тернарной
[27:21.840 --> 27:28.160]  логикой и о тернарной логике мы еще с вами будем говорить на следующей лекции а с ключ о ключах
[27:28.160 --> 27:34.400]  мы будем говорить при рассмотрении вопросов проектирования базы данных и нормальных формах
[27:34.400 --> 27:41.880]  сейчас мы с вами поговорим о дд л команде create и в частности команде крейт тейбл почему в
[27:41.880 --> 27:47.640]  частности потому что если вы зайдете в документацию посмотрите нас раздел справочное руководство то
[27:47.640 --> 27:56.520]  увидите что с крейт есть еще наверное и команд начинающихся с команды крейт есть наверное ну штук
[27:56.520 --> 28:05.520]  15 20 мне кажется и создавать можем далеко не только таблицы но такие исчерпывающие подробности
[28:05.520 --> 28:10.280]  выходят наверное все-таки за рамки нашего по крайней мере сегодняшнего разговора поэтому
[28:10.280 --> 28:17.480]  мы ограничимся только созданием таблиц а посмотрим на ограничение на ограничение в виде проверки
[28:17.480 --> 28:26.240]  целостности и также на ограничение в виде ключей крейт тейбл базовый синтакс из создания таблиц
[28:26.240 --> 28:36.760]  здесь на слайде я привел ну признаюсь это просто цитата из официального руководства да но стата
[28:36.760 --> 28:41.800]  неполная на самом деле если вы посмотрите то соответственно увидите что вот этот псевдокод
[28:41.800 --> 28:49.280]  проведенный на рисунке на слайде он соответствующий страницы указанный внизу слайда он занимает
[28:49.280 --> 28:57.760]  гораздо больше места гораздо более объемная объемная команда крейт тейбл и ну мы касаться
[28:57.760 --> 29:03.640]  всего повторюсь вот к сожалению время нам не позволяет там много всяких интересностей посмотрим
[29:03.640 --> 29:09.720]  на какие-то базовые вещи ну я понимаю что с одной стороны у кого-то уже прошли семинары
[29:09.800 --> 29:19.120]  первые может быть даже вторые и вы уже прям матерые создатели таблиц но тем не менее мы
[29:19.120 --> 29:23.560]  будем идти последовательно поэтому если для кого-то это конечно будет повторением до уже пройденного
[29:23.560 --> 29:32.120]  призываю тем не менее еще раз прослушать какие-то может быть особенности мы затронем которые бы
[29:32.120 --> 29:39.960]  не затрагивали на семинарах что главное наверное нам в создании таблицы на сегодняшний момент
[29:39.960 --> 29:53.640]  нужно понимать и усвоить это то что у нас определение таблицы обязательно должно состоять из трех ну
[29:53.640 --> 30:01.040]  обязательно должно включать в себя следующие три компонента вот так вот скажи это имя столбца
[30:01.080 --> 30:06.480]  тип данных и ограничение таблицы принципе мы можем создать команду мы можем команду
[30:06.480 --> 30:13.040]  create table исполнить с именем таблицы это обязательный да как видите имя таблицы не в скобках не в каких
[30:13.040 --> 30:22.520]  просто указано мы можем команду create table имя таблицы некое исполнить без задания конкретных
[30:22.520 --> 30:31.780]  атрибутов, отношений или конкретных доменов на этих атрибутах определенных, для этих
[30:31.780 --> 30:38.460]  атрибутов определенных. И это будет нормально, у нас наш Postgres не выдаст никакой ошибки,
[30:38.460 --> 30:45.980]  просто потом мы сможем дополнительными командами AlterTable, в частности, добавлять новые и новые столбцы.
[30:45.980 --> 30:58.120]  Итак, что мы должны иметь в виду при создании таблицы. Реальная команда
[30:58.120 --> 31:06.700]  по созданию таблицы выглядит так, как показано на слайде. Имя столбца у нас задается первым,
[31:06.700 --> 31:15.780]  потом через пробел дополнительные идентификаторы, ключевые слова. В данном случае у нас
[31:15.880 --> 31:24.240]  для каждого столбца есть определитель типа данных, на некоторые столбцы установлены
[31:24.240 --> 31:33.740]  определенные ограничения, которые при добавлении записи в таблицу будут проверяться,
[31:33.740 --> 31:40.300]  вернее записи при добавлении будут проверяться на предметы этих ограничений. Будет ли успешная
[31:40.300 --> 31:45.440]  операция по добавлению либо соответственно наша база данных, наш систем управления базой данных
[31:45.440 --> 31:52.440]  будет выдавать ту или иную ошибку да еще наверное знаете оговорить сразу что у
[31:52.440 --> 31:58.560]  нас довольно есть обширные правила по ну это предыдущим немножко наверно
[31:58.560 --> 32:02.200]  слайдом тут тем не менее есть обширные правила по формулированию
[32:02.200 --> 32:06.960]  идентификаторов тому что у нас считается операндом
[32:06.960 --> 32:15.720]  операторам прошу прощения по порядку по старшинству действия операторов
[32:15.720 --> 32:19.360]  все это опять же есть в официальном руководстве
[32:19.360 --> 32:26.360]  отсылаю вас к нему ну там наверно такие тривиальные вещи все-таки описаны из
[32:26.360 --> 32:37.440]  серии да что там не знаю нельзя с со знака астрикс начинать имя идентификатора
[32:37.440 --> 32:48.640]  ну так принципе латинские буквы числа нижние подчеркивания допустимые более
[32:48.640 --> 32:54.040]  чем наверное достаточно для того чтобы сформулировать такой идентификатор который
[32:54.040 --> 33:00.000]  нам хочется да там по идентификатором также есть у нас ограничение на длину мы
[33:00.000 --> 33:05.320]  его можем изменить в заголовочном файле позгресса ну если вдруг кому-то
[33:05.320 --> 33:09.280]  интересно опять же все это подробно у нас в документации описано поэтому еще
[33:09.280 --> 33:15.760]  раз предлагаю за подробностями туда обратиться давайте подробнее поговорим
[33:15.760 --> 33:20.680]  про ограничение в таблицах так одну секунду вопрос
[33:20.680 --> 33:30.640]  хорошо значит вопрос что такое прайм реки хорошо значит не у всех не у всех прошли
[33:30.640 --> 33:39.920]  соответствующие лекции семинары прошу прощения значит это будет вдвое полезно
[33:39.920 --> 33:45.600]  смотрите прайм реки это особый вид ограничения ограничения по первичному ключу мы сейчас
[33:45.600 --> 33:52.560]  об этом специально поговорим но глобально да что-то почему мы выделяем это в виде
[33:52.560 --> 34:01.160]  отдельных отдельного словосочетания ключевого потому что ключи имеют серьезные значения для
[34:01.160 --> 34:07.360]  религационной модели по сути дела посредством первичных и внешних ключей мы создаем
[34:07.360 --> 34:12.280]  функциональные зависимости между нашими таблицами между нашими отношениями таким
[34:12.280 --> 34:17.240]  образом у нас совокупность разрозненных таблиц существующих в некоем там где-то
[34:17.240 --> 34:25.160]  до нашим воображаемом табличном пространстве она становится у нас неким подобием что ли
[34:25.160 --> 34:31.880]  графа как не забавно но это уже может быть отсылки предыдущей лекции взаимообратимости
[34:31.880 --> 34:38.520]  моделей данных и представлений короче говоря у нас благодаря первичным и внешним ключам о
[34:38.520 --> 34:42.840]  которых мы поговорим буквально через несколько слайдов можно формулировать функциональные
[34:42.840 --> 34:52.240]  зависимости между отношениями между таблицами и таким образом дополнительно создается условия
[34:52.240 --> 34:58.960]  на целостность данных более сложные условия для целостности целостности данных позволяют нам в
[34:58.960 --> 35:07.800]  базе хранить неповторяющуюся не избыточную информацию и позволяют по вот этим вот с взаимным
[35:07.800 --> 35:15.120]  ссылкам искать соответственно нужный нам кусочек этой информации разделенные на отдельные
[35:15.120 --> 35:23.080]  таблицы разделенные по причине необходимости поддержания нормальной формы ладно это наверное
[35:23.080 --> 35:29.360]  для вас это прозвучит сейчас очень общего просто будет понятнее когда мы с вами дойдем до нормальных
[35:29.360 --> 35:36.400]  форм и поймем почему нельзя хранить данные в одной таблице но вот например как в одной таблице
[35:36.400 --> 35:43.600]  файлы excel ну это очень не оптимально сразу да можно говорить и кто пытался создавать большие
[35:43.600 --> 35:49.320]  таблицы наверное может представить почему это происходит там потому что данные не по всем полям
[35:49.320 --> 35:57.560]  всегда у нас есть или потому что например нужно бывает к уже имеющимся данным добавить новые но
[35:57.560 --> 36:02.640]  если добавлять новые атрибуты вот в это единичное отношение у нас получается черти что у нас
[36:02.640 --> 36:07.560]  получается по трем записям условно три новых атрибута добавлено но для предыдущей тысячи это
[36:07.560 --> 36:12.840]  не имеет никакого отношения то есть здесь тоже возникают вот такие вопросы если вы к цели это
[36:12.840 --> 36:20.280]  еще приемлемо то когда мы говорим о промышленных объемах данных там с этим встают вопросы встают
[36:20.280 --> 36:24.000]  большие вопросы о том как это оптимизировать ну оптимизировать понятно как использовать
[36:24.000 --> 36:31.200]  революционную модель ну ладно ребят извините это я забегаю вперед такие общие вещи на общее
[36:31.200 --> 36:35.920]  понимание но правильные это ограничение для обозначения функциональной зависимости между
[36:35.920 --> 36:43.120]  отношениями если вот кратко резюми хорошо что такое ограничение в таблицах вообще для чего они
[36:43.120 --> 36:47.360]  нужны служат средством поддержания целостности данных гарантирует что при внесении данных
[36:47.360 --> 36:51.880]  таблицу не будут нарушена взаимосвязи между ними обеспечивают ссылочную целостность между таблицами
[36:51.880 --> 37:00.160]  вот это вот конкретно за счет внешних ключей но внешние ключи они тесно связаны с первичными
[37:00.160 --> 37:05.920]  ключами сейчас мы об этом тоже поговорим и ограничение определяются после типа данных либо
[37:05.920 --> 37:12.760]  отдельным утверждением при определении таблицы это про синтаксис про синтаксис сейчас тоже мы
[37:12.760 --> 37:23.640]  скажем основные ограничения в SQL первое это нот нал соответствующий столбец не принимает
[37:23.640 --> 37:31.880]  значение нал ну вот по нот нал примеры с кодом на слайде нет но в принципе здесь довольно
[37:31.880 --> 37:41.440]  просто себе это представить мне кажется просто вот например до левый нижний уголу где где у нас
[37:41.440 --> 37:51.600]  показан в зеленом таком квадратики с текст команды слово унит просто заменить на нот нал и вот это
[37:51.600 --> 37:55.840]  будет то же самое ограничение то есть синтаксически как вы помните из предыдущих слайдов у нас
[37:55.840 --> 38:02.360]  должны разделяться пробелинами символами части команды и вот продукт но продукт нам барда
[38:02.360 --> 38:08.520]  integer но тнал будет означать что когда мы создали создали таблицу products у нас есть в ней три
[38:08.520 --> 38:16.400]  атрибута продан номер продукта имя продукта и цена и вот имя номер продукта у нас является
[38:16.400 --> 38:27.280]  атрибутом на домене целочисленных чисел целых чисел и ограничение нот нал будет означать что
[38:27.280 --> 38:31.800]  когда мы добавляем новую запись мы обязательно в этой новой записи должны будем сказать что
[38:31.800 --> 38:41.080]  продукт ноу продукт нам барда должен принять какое-то значение мы не сможем избежать мы не
[38:41.080 --> 38:46.880]  сможем ставить только два значения в два атрибута нейм и прайс мы должны обязательно всегда в продукт
[38:46.880 --> 38:52.880]  нам бар вставлять какое-то целочисленное значение иначе у нас всегда будет возникать ошибка ну или
[38:52.880 --> 38:58.080]  юник в данном случае как показано на слайде означает что просто у нас на продукт нам бар да как
[38:58.080 --> 39:04.680]  накладывается другое ограничение что оно должно быть это значение для во всей таблице во всей
[39:04.680 --> 39:11.920]  нашей этой колонке продукт нам бар уникальная мы могли бы два ограничения вместе наложить без
[39:11.920 --> 39:17.480]  запятых просто через пробел нот нал и юник и у нас тогда было бы двойное ограничение чтобы всегда
[39:17.480 --> 39:23.920]  должны заполнять продукт нам бар каким-то значением он должен быть уникальным и вот такое обозначение
[39:23.920 --> 39:33.720]  нот нал юник оно как не забавно можно его считать до некоторого до некоторого до некоторого порядка
[39:33.720 --> 39:40.160]  псевдонимом для вернее определением для ограничения праймеры ки а праймеры ки считать
[39:40.160 --> 39:45.640]  псевдонимом правда есть это да правда это справедливо только в определенном в первом
[39:45.640 --> 39:50.080]  приближении потому что на праймеры ки добавляются еще дополнительные внутренние операции базы
[39:50.080 --> 39:58.800]  данных по создать по индексации по созданию всяческих статистических по отслеживаю всяческих
[39:58.800 --> 40:06.160]  статистических данных поэтому прямого соответствия нет но тем не менее праймеры ки у нас по сути дела
[40:06.160 --> 40:13.000]  на сущностном уровне задает те же ограничения нот нал и уник одновременно вопрос в чате
[40:14.000 --> 40:20.280]  уник ас дает уникальность кортежей или вида ас вернее да или вида ас или каждого из столбцов а и
[40:20.280 --> 40:28.240]  ц отдельно а уникальность кортежей уникальность кортежи должно быть так прошу прощения да то есть
[40:28.240 --> 40:37.600]  у нас всегда ас должно быть уникальным для всей нашей таблицы хорошо нот нал юник в принципе довольно
[40:37.600 --> 40:44.260]  просто мне кажется здесь нет каких-то специалистов нет каких-то вот особых подводных камней уж точно
[40:44.260 --> 40:51.760]  на уровне каких-то вот простеньких бас из нескольких таблиц все ну прямо линейно выглядит и
[40:51.760 --> 40:58.040]  прозрачно что касается прайма реки вот собственно да немножко я предварил то о чем написано на
[40:58.040 --> 41:09.720]  этом слайде если вы обратите внимание внизу да вот в квадрате с черной каймой и в квадрате
[41:09.720 --> 41:18.240]  с на с таком оранжевым фоном они сопоставлены в двухсторонней стрелочке то есть уник нот нал
[41:18.240 --> 41:24.240]  примерно то же самое что прайма реки но повторюсь это не совсем так если смотреть
[41:24.440 --> 41:30.720]  на внутренности базы данных и то что она делает с прайм реки то есть там есть дополнительные
[41:30.720 --> 41:38.800]  всякие оптимизационные механизмы и операции поэтому конечно прайма реки вы не замените на еник
[41:38.800 --> 41:44.480]  нот нал но по сути дела прайма реки означает что у нас таблицы средний который мы создаем по
[41:44.480 --> 41:51.040]  вот коду оранжевом квадратики у нас на продукт намбер накладываются те же ограничения что
[41:51.040 --> 42:02.800]  накладывают юник и нот нал одновременно так замечательно спасибо за пояснение потому
[42:02.800 --> 42:11.080]  что прошлый раз вроде говорили что курсор не виден спасибо виден курсор замечательно тогда
[42:11.080 --> 42:17.760]  что еще что есть что здесь сказать да опять же вот синтактический обратите внимание как на
[42:17.760 --> 42:23.520]  прошлом слайде слайде так и на этом у нас есть варианты мы можем синтактически определять
[42:23.520 --> 42:29.680]  ограничения при определении колонки при определении столбца можем в конце таблицы
[42:29.680 --> 42:39.480]  конце определение таблицы привести ограничения и более того будет еще один вариант ну даже
[42:39.480 --> 42:45.680]  наверное, полтора, что ли, варианта того, как можно сформулировать ограничения чуть попозже.
[42:45.680 --> 42:54.720]  Так, хорошо, fornky – это еще одно ограничение, которое у нас сдает столбец или группу столбцов
[42:54.720 --> 42:58.640]  таблиц, значения которых должны совпадать со значениями столбцов первичного ключа другой
[42:58.640 --> 43:03.720]  таблицы, указанной в этом ограничении. То есть это вот та самая функциональная зависимость,
[43:03.720 --> 43:08.680]  о которой я говорил. Ну, про функциональность пока можете просто отложить себе в голове. Это
[43:08.680 --> 43:16.600]  словно потом, чтобы когда мы дойдем до соответствующей темы какие-то вопросы,
[43:16.600 --> 43:22.640]  уточняющие задательную смысл. Вот еще у нас есть primary key, таблица с primary key с первичным
[43:22.640 --> 43:33.760]  ключом, есть таблица с вторичным ключом, с fornky. У нас вот пример задания, опять же,
[43:33.760 --> 43:39.080]  синтаксис, разница за подробным описанием синтаксиса, уж не обессудьте, я вас еще раз
[43:39.080 --> 43:46.480]  отправлю в документацию, потому что там прям вот как в естественном языке практически вариантов
[43:46.480 --> 43:56.160]  очень много. И смотрите, у нас есть primary key, мы задали fornky через ограничение references
[43:56.160 --> 44:05.440]  product number, то есть у нас во второй таблице нашей вот create orders, таблице orders, на столбце
[44:05.440 --> 44:13.960]  product number задается ссылка, задается внешний ключ в виде ссылки на таблицу products и конкретно
[44:13.960 --> 44:21.080]  на столбце product number. Что это значит? Это значит, что у нас в таблице orders никогда, ни при каких
[44:21.080 --> 44:30.280]  обстоятельствах не должно быть в столбце product number числа, которая не появляется у нас в столбце
[44:30.280 --> 44:37.720]  product number в таблице products. У нас соответственно таблица products будет главной по отношению к
[44:37.720 --> 44:44.640]  таблице orders, таблица orders будет подчиненной и она всегда должна подчиняться в том плане, что
[44:44.640 --> 44:50.080]  использовать только то подможество значений, которое уже существует в таблице products, никак иначе,
[44:50.080 --> 44:57.240]  иначе у нас не запишется просто запись в нашу базу данных при добавлении, у нас возникнет опять же
[44:57.240 --> 45:06.640]  ошибка. Можно ссылаться опять же на группу столбцов целевого отношения, вот здесь еще пример
[45:06.640 --> 45:19.240]  синтаксиса задания ограничения, for ain key, прошу прощения, for ain key задается на столбце BC и
[45:19.240 --> 45:30.400]  ставится ссылка на некое иное отношение, иную таблицу на ее уже главные столбцы по отношению к
[45:30.400 --> 45:41.040]  T1, столбцы C1 и C2, то есть в our table C1, C2 значения, которые туда попали, только эти значения мы
[45:41.040 --> 45:50.700]  сможем использовать в таблице T1 в столбцах BC. Имеется ввиду, что для каждой пары BC должна
[45:50.700 --> 46:01.920]  существовать пара C1, C2 из другой таблицы? Да. В смысле прямо в одном столбце? Смотрите, там
[46:01.920 --> 46:15.040]  надо смотреть, но в принципе да, в принципе да, там получается, что у нас primary key, ну даже не
[46:15.040 --> 46:21.720]  надо смотреть, у нас получается, что primary key в таблице our table будет C1, C2, мы можем ссылаться,
[46:21.720 --> 46:27.400]  только for ain key у нас должен ссылаться обязательно на primary key, то есть соответственно C1, C2 если у
[46:27.400 --> 46:32.360]  нас будет primary key, то как вы только что увидели, это у нас ограничение unique not null на эти же два
[46:32.360 --> 46:39.880]  столбца C1, C2, соответственно C1, C2 будет кортежем, который должен быть уникальным в рамках вот двух
[46:39.880 --> 46:53.240]  столбцов одновременно в главной таблице. Как пара? Как пара? Так, да.
[46:57.400 --> 47:06.600]  Да, следующее ограничение check. Задает произвольное условие назначения одного или нескольких столбцов в одной
[47:06.600 --> 47:19.600]  строке таблицы и что это значит? Что мы можем поставить логическое условие при определении
[47:19.600 --> 47:26.120]  таблицы и когда мы будем носить запись, у нас запись будет проверяться отдельные ее атрибут,
[47:27.080 --> 47:33.160]  отдельное значение атрибута, будет проверяться в соответствующем правиле для столбца таблицы,
[47:33.160 --> 47:40.600]  если проверка не будет пройдена, соответственно запись у нас в таблицу не попадет. Что важно иметь
[47:40.600 --> 47:43.880]  в виду, что в ограничении check у нас задается выражение, возвращающее логический результат,
[47:43.880 --> 47:49.160]  по которому определяется будет ли успешна операция добавления или изменения для конкретных строк.
[47:49.160 --> 48:00.440]  И операция у нас будет выполнена успешно только если у нас при проверке check логическими результатами
[48:00.440 --> 48:10.540]  будет true или unknown. Если у нас будет false, операция добавления ничего не поменяет в базе данных,
[48:10.540 --> 48:17.680]  у нас возникнет ошибка. Пример с ограничением check. Записывается довольно просто, по сути дела,
[48:17.680 --> 48:26.400]  как используя логический оператор, довольно простая понятная запись. В данном случае оператор
[48:26.400 --> 48:36.440]  больше, то есть при добавлении записи у нас цена должна быть обязательно больше нуля. Также можно
[48:36.440 --> 48:46.200]  еще отнести к операциям ограничения команда default, но как бы с одной стороны это не то,
[48:46.320 --> 48:50.960]  что по большому счету это не ограничение, это просто задание значений по умолчанию,
[48:50.960 --> 49:02.920]  когда мы не будем вносить запись в таблицу. Соответственно, если мы ничего не вносим и у нас
[49:02.920 --> 49:13.120]  нет default, то у нас появляется значение null. Если у нас default, то мы можем по default установить
[49:13.120 --> 49:17.400]  какое-то значение, когда мы не вносим запись на слайд, где это значение даты,
[49:17.400 --> 49:24.160]  с текущей даты. В данном случае даже не просто даты, а в данном случае функция now у нас вернет
[49:24.160 --> 49:30.520]  дату с timestamp, но мы ее сокращаем в примере до выражения вот год-год-год,
[49:30.520 --> 49:46.880]  default месяц-месяц, default день-день. Это следующая группа операторов, это будет оператор insert,
[49:46.880 --> 49:56.480]  insert. Простите уж мой английский, может быть. Но смысл в том, что мы просто не все значения
[49:56.480 --> 50:09.920]  будем выносить из полей. Да, если это будет допустимо, сможем вынести не все, да.
[50:09.920 --> 50:21.520]  Ну, не совсем, но мы там до insert дойдем, когда я все это покажу. А к ограничениям принято... Так,
[50:21.520 --> 50:29.160]  да, default мы с вами уже проговорили. Задается значением без переменных, выражением без
[50:29.160 --> 50:36.120]  переменных, не допускается под запросы. Ну, то есть, в принципе, в идеале это, конечно,
[50:36.120 --> 50:40.360]  какая-нибудь вообще константа. Ну, условно в идеале, да, для простоты, что называется. А так,
[50:40.360 --> 50:46.920]  конечно, есть определенный простор. Вот можно функцию default поставить какую-то, которая будет
[50:46.920 --> 51:00.360]  вычислять некое значение и вставлять в поле при отсутствии соответственно значения при вставке.
[51:00.360 --> 51:11.160]  Так, хорошо. Синтаксис, наконец, ограничений. Любопытная штука. Вот почему. Потому что мы
[51:11.160 --> 51:18.680]  можем не просто писать ограничения для столбца или ограничения для таблицы, как на второй картинке,
[51:18.680 --> 51:25.440]  вот на вот этой, да. Мы можем еще и явным образом присвоить ими ограничению. И почему это полезно?
[51:25.440 --> 51:33.640]  Потому что в этом случае у нас более осознанно, более человекочитаемые, удобные для восприятия,
[51:33.640 --> 51:40.200]  будут сообщения об ошибке, если вдруг что-то у нас пойдет не так и будет связано с каким-то
[51:40.200 --> 51:44.400]  конкретным ограничением. Соответственно, у нас сообщение об ошибке будет, что, условно,
[51:44.400 --> 51:53.280]  не просто ошибка там в такой-то, не знаю, записи, да, на таком-то этапе, а ошибка в связи с таким-то
[51:53.280 --> 52:07.720]  ограничением. И более информативно. Но, в принципе, что еще можно сказать, что у нас, прошу прощения,
[52:07.720 --> 52:16.840]  у нас ограничения на столбце не полностью эквивалентны ограничению на таблице. То есть,
[52:16.840 --> 52:23.080]  вернее, наоборот, у нас ограничение на таблице не всегда можно переформулировать на ограничение
[52:23.080 --> 52:32.280]  на столбце, поэтому есть определенная небольшая синтоксическая разница. Она может быть заметна
[52:32.280 --> 52:38.440]  при определенных операциях, вот так вот несколько туманно, скажу я, но смысл просто в том, что вот это
[52:38.440 --> 52:43.400]  вот, да, не во всех случаях эквивалентно, ну, понятно, что здесь разные условия, но, в принципе,
[52:43.400 --> 52:49.400]  вот эта вот запись не эквивалентна была бы записи, когда бы чек у нас просто стояла внизу,
[52:49.400 --> 52:57.160]  отдельно в конце таблицы. Такое не всегда эквивалентно. Ну, просто имейте это в виду,
[52:57.160 --> 53:01.000]  держите в голове, если вдруг у вас появится ошибка, с которой вы не сможете справиться,
[53:01.000 --> 53:10.840]  хотя, казалось бы, ваши базы данных довольно просты и очевидны. Так, ладно, давайте будем двигаться
[53:10.840 --> 53:23.280]  дальше. У нас с вами по нашему, да, вот нашей дорожной карте это ключи. Про ключи мы с вами сказали,
[53:23.280 --> 53:31.600]  что есть праймерики, есть форейнки, да, праймерики мы задаем для текущего отношения. Это эквивалентно
[53:31.600 --> 53:38.480]  заданию ограничения not null и unique. Форейнки мы задаем для текущего отношения путем ссылки
[53:38.480 --> 53:49.760]  на некое главное отношение, где есть праймерики и что мы еще можем сказать о ключах. Немного
[53:49.760 --> 53:56.320]  теоретической информации сейчас будет, она нам понадобится при больше даже, наверное,
[53:56.320 --> 54:04.760]  может быть, проектировании в некотором смысле, но раз уж мы затронули ключи, давайте мы поговорим
[54:04.760 --> 54:12.160]  чуть-чуть подробнее о них и разберем их виды. Во-первых, начинается все с потенциального ключа,
[54:12.160 --> 54:17.280]  то есть в релиционной модели данных это подмножество атрибутов отношения, удовлетворяющие определенным
[54:17.280 --> 54:21.800]  требованиям, их всего два, это уникальность и несократимость или минимальность. То есть
[54:21.800 --> 54:27.040]  потенциальный ключ это обязательно, то есть подмножество атрибутов, наверное, с этого начнем,
[54:27.040 --> 54:34.440]  это один или, ну пустое подмножество не будем брать, это один или там все атрибуты отношения и,
[54:34.440 --> 54:40.760]  соответственно, для простоты один атрибут отношения это таблица и уникальность, то есть на этом
[54:40.760 --> 54:45.840]  столбце у нас все наши данные должны быть уникальны, не должны быть повторяющиеся, то самое
[54:45.840 --> 54:52.660]  ограничение уник. И второе ограничение минимальности, что в составе потенциального ключа отсутствует
[54:52.660 --> 54:56.780]  меньшее подмножество атрибутов, удовлетворяющие условия уникальности. Иными словами, это значит,
[54:56.780 --> 55:03.820]  что когда у нас потенциальный ключ состоит из более чем одного атрибута и мы не можем из этого
[55:03.820 --> 55:11.860]  вот набора атрибутов убрать какой-то атрибут без потери свойства уникальности, то это значит,
[55:11.860 --> 55:20.740]  мы достигли минимально возможного набора уникальных атрибутов. Ну, о чем будет речь,
[55:20.740 --> 55:28.060]  о том, что у нас может быть, как знаете, вот для примера представьте себе таблицу истинности
[55:28.060 --> 55:38.540]  логическую, да, и вот, например, с тремя переменными, у нас, соответственно, там будет 8 строк. И в начале
[55:38.540 --> 55:45.100]  с левой стороны этой таблицы мы запишем назначение A, B, C, и там будет 4 истинных,
[55:45.100 --> 55:56.060]  4 ложных, значит, строки подряд у B будет по две строки чередующихся, и у C через одну строку будет
[55:56.060 --> 56:04.900]  чередоваться истинно-ложно, истинно-ложно. У нас таким образом здесь получается, что мы сформировали,
[56:04.900 --> 56:09.060]  ну, помимо там того, что мы потом будем какую-то логическую функцию по этой таблице развертывать,
[56:09.060 --> 56:17.260]  мы сформировали вот в этих трех столбцах, три расписали по трем атрибутам их значение таким
[56:17.260 --> 56:22.140]  образом, что у нас каждая строка оказалась уникальным набором, они не повторяются нигде. У нас вот
[56:22.140 --> 56:27.660]  этот кортеж из трех значений в этой таблице истинности из трех логических переменных, у нас
[56:27.660 --> 56:36.780]  каждая повторяющая строка получается трехстрочным, трех-трехэлементным кортежем, который уникален
[56:36.780 --> 56:42.980]  по отношению к другим. При этом, когда мы будем дальше справа чертить новые колонки, там какие-то
[56:42.980 --> 56:52.940]  логические функции уже развертывать, расписывать по участвующие в выражении, у нас может случиться так,
[56:52.940 --> 57:04.900]  что мы не сможем их добавить в наши вот эти три первых атрибута, потому что если мы их добавим,
[57:04.900 --> 57:09.900]  возможно у нас тогда потеряется уникальность. Но с другой стороны, мы их, если уберем, уникальность
[57:09.900 --> 57:16.980]  из трех этих атрибутов у нас останется, и вот он наш потенциальный ключ, который можно использовать.
[57:16.980 --> 57:23.580]  Сейчас вопрос. Я не могу сейчас сходу сообразить, из этого следует, что они все равномощны или нет?
[57:23.580 --> 57:29.460]  Равномощны? Ну, в плане, что во всех потенциальных ключах одинаковое количество элементов.
[57:29.460 --> 57:37.740]  А, ну, конечно, конечно, да, во всех. Не, ну, имеется в виду, смотрите, у нас получается как, да, под множество
[57:37.740 --> 57:47.540]  атрибутов. Нет, они не равномощны. У нас потенциальный ключ для отношения может быть... Вы знаете, хороший
[57:47.540 --> 57:53.940]  вопрос, хороший, нет, я не могу, наверное, сходу вам ответить про равномощность, но у нас, по идее,
[57:53.940 --> 58:03.420]  получается, что потенциальных ключей может быть несколько. Это да. Они могут быть... Очевидно,
[58:03.420 --> 58:08.300]  в одном отношении может быть такое, что... Ну, очевидно, вот на пальцах, интуитивно, очевидно,
[58:08.300 --> 58:12.500]  что называется, в одном отношении может быть потенциальный ключ, состоящий из двух атрибутов и из одного,
[58:12.500 --> 58:18.380]  например. Ну, такой совсем простой случай возьмем. А равномощны по отношению к кому тогда? К другим отношениям?
[58:18.380 --> 58:23.820]  Но, очевидно, нет. Внутри одного отношения все потенциальные ключи равномощны.
[58:23.820 --> 58:28.780]  Мне кажется, тоже нет, я вам не смогу, наверное, математическую...
[58:28.780 --> 58:33.620]  Один ключ, который уникальный везде, и два ключа, которые каждый из них повторяются,
[58:33.620 --> 58:36.340]  но при этом множество их пар не повторяются.
[58:36.340 --> 58:43.700]  Да-да-да, совершенно верно. Наверное, здесь нужна таблица для пояснения.
[58:43.700 --> 58:57.140]  Да, уж, наверное, извините, что таблицы не щад, к сожалению, но получается, что у нас нет ограничений на равномощность.
[58:57.140 --> 58:59.140]  Мы можем, да, потенциальные ключи в одном отношении, а не...
[58:59.140 --> 59:02.900]  Как можно таблицу, как раз, пример?
[59:02.900 --> 59:10.900]  Не обязательно равномощна... Так, это у нас, соответственно, вопрос в чате.
[59:10.900 --> 59:18.100]  Потенциальный ключ уникально? Вроде да, вроде да.
[59:18.100 --> 59:22.340]  Вроде кажется, что да, на первый взгляд.
[59:22.340 --> 59:26.340]  Кажется, что да.
[59:26.340 --> 59:35.180]  То есть, мы можем взять по первому атрибуту, по первому самому столбцу, можем взять по трем столбцам одновременно,
[59:35.180 --> 59:44.220]  а при этом по первому, второму и по второму, третьему мы взять, например, не можем, потому что у нас будет пересечение в среднем кортеже.
[59:44.220 --> 59:48.420]  2-1-1-2 порядок нам, поскольку не важен, вроде бы.
[59:48.420 --> 59:58.540]  Окей, ну, соответственно, да, получается, вот если обратить внимание на таблицу в чате, у нас не обязательно равномощна, совершенно верно, пример приведен корректный.
[59:58.900 --> 01:00:09.220]  Хорошо, так, потенциальный ключ может быть простым или составным, соответственно, да, две атрибуты или несколько атрибутов в него могут входить.
[01:00:09.220 --> 01:00:17.140]  Далее, что еще нужно знать? Ну, дальше уже идут, на самом деле, такие вариации на тему того, каким потенциальный ключ еще может быть.
[01:00:17.140 --> 01:00:21.300]  А потенциальный ключ дальше можно разделить на первичный ключ и альтернативный ключ.
[01:00:21.300 --> 01:00:27.140]  Что такое первичный ключ? Это тот потенциальный, который мы выбрали для своего отношения в качестве основного,
[01:00:27.140 --> 01:00:38.100]  то есть который мы, таблицы прям наши пометили как праймы реки, альтернативный ключ это все остальные потенциальные ключи, которые в первичный наш ключ не вошли.
[01:00:38.100 --> 01:00:55.780]  Естественный ключ, суррогатный ключ, любопытная штука, потому что можно, для простоты, часто, очень часто, если едва ли в каких-то промышленных вещах не всегда создают первичный ключ не на основе
[01:00:56.140 --> 01:01:02.020]  каких-то реальных данных, занесенных в таблицу, а на основе некоего технического поля типа ID,
[01:01:03.300 --> 01:01:19.620]  которое там еще и генерируется автоинкрементом каким-нибудь и таким образом у нас, или вообще, может быть, каким-то рандомным способом генерируется строка симбольная в суррогатном ключе.
[01:01:19.780 --> 01:01:31.140]  И таким образом мы просто отдаем обязанность следить за тем, чтобы ключ был уникальным и не сократимым на откуп функционалу СУБД.
[01:01:32.500 --> 01:01:48.420]  И мы не думаем, правильно ли мы сделали, чтобы выбрали в качестве нашего первичного ключа имя и фамилию студентов в таблице students тех, кто не просто учится в МВТ
[01:01:48.500 --> 01:01:58.580]  сейчас, в текущем семестре, а учился на протяжении 10 лет. Очевидно, такой первичный ключ будет некорректным, вероятность совпадения фамилии будет очень велика.
[01:01:59.060 --> 01:02:07.060]  А если мы добавим туда какое-нибудь автоинкрементное поле, суррогатный ключ, пожалуйста, гарантированно уникальные значения.
[01:02:07.060 --> 01:02:36.980]  Так, здесь еще можно сказать, что есть определенные недостатки. Неинформативность, поскольку техническое поле, мы ничего из него с одной стороны не можем понять, с другой стороны уязвимость для генераторов, вернее уязвимость генераторов в том плане, что по этому полю, если мы к нему доступ как-то получим, мы можем понять вообще движение в таблице, какие происходят, сколько в нее добавляется, сколько там удаляется, наверное, нет.
[01:02:37.060 --> 01:02:50.980]  Если у нас там какой-нибудь автоинкремент, да, но сколько добавляется, например, данных, что вообще, сколько данных записей вообще в таблице есть или как минимум было за все периоды ее существования и так далее.
[01:02:50.980 --> 01:03:03.900]  И, наверное, действительно такой вот серьезный недостаток, но он не связан с техническим аспектом, он связан с аспектом человеческим исключительно.
[01:03:03.900 --> 01:03:25.820]  Суррогатный ключ можно использовать вместо нормализации и таким образом положить не громоздки избыточные, семантически избыточные таблицы, в которых содержится избыточные данные, вместо того, чтобы их правильно разделять и эффективно с ними взаимодействовать.
[01:03:26.740 --> 01:03:53.740]  Так, внешний ключ. Мы с вами посмотрели, что это, да, как это определяется, а что это по существу. Это, ну, определение, в принципе, тоже я вам примерно проговаривал в менее формальном изложении, но, по сути дела, внешний ключ, это вот, да, то он может содержать некое подможество значений, которые принимает у нас первичный ключ,
[01:03:54.660 --> 01:04:08.660]  на который ссылается внешний. Вот это, наверное, самое главное свойство. Определение, опять же, на слайде есть. Если хотите, вы можете прочитать это еще раз уже по слайдам самостоятельно.
[01:04:09.580 --> 01:04:24.580]  Мы еще вернемся к рассмотрению ключей в следующих лекциях, при проектированиях, при проектировании базы данных. Там, правда, будет, там не будет уже каких-то новых подробностей, но мы просто будем еще о ключах говорить.
[01:04:25.500 --> 01:04:37.500]  Хорошо. Тернарная логика, тернарная логика, вспоминаем мы о ней благодаря нашей логической проверке целостности, благодаря ограничению check.
[01:04:38.500 --> 01:04:50.500]  Как мы с вами говорили, check, если у нас true или unknown значение при логической проверке, то запись у нас пройдет, а если у нас false, то запись не пройдет.
[01:04:51.420 --> 01:04:58.420]  Встает вопрос, что такое true, unknown и false? Казалось бы, в двоичной логике у нас было всего два значения.
[01:04:59.340 --> 01:05:22.340]  Да, ребята, вопрос. На слайде написано, что для внешнего ключа нужен потенциальный, раньше говорили, что нужен первичный, а первичный у нас в любом случае является видовым понятием по отношению к потенциальному.
[01:05:23.260 --> 01:05:50.260]  Потенциальный – это род, первичный – это тот потенциальный, который мы выбрали, поэтому здесь нет прямого противоречия. Здесь есть, возможно, некоторая некорректность, соглашусь с вами, но прямого противоречия нет, потому что мы и там, и там говорим о сущностях, обладающих одинаковыми свойствами с точки зрения минимальности и уникальности.
[01:05:51.180 --> 01:06:11.180]  И первичные и потенциальные ключи должны быть минимальными и уникальными, а это нам принципиально важно для внешнего ключа, поэтому корректнее говорить о первичных ключах, потому что внешне мы формулируем для уже выбранного. Я исправлю, несу корректуру, когда буду выгружать слайд.
[01:06:12.100 --> 01:06:27.100]  Спасибо. Хорошо. Фернарная логика. То есть у нас есть проблема. Мы не всегда в ячейке таблицы можем занести какие-то реальные значения. Что нам тогда делать? Тогда у нас появляется специальный маркер Now. Now у нас не является ни числом, ни символом.
[01:06:28.020 --> 01:06:42.020]  Это просто специальный филер такой, который СУБД вставляет в нашу базу данных, когда она не знает, что вставить, потому что у нас в принципе не должно быть пустых полей, не должно быть пустых атрибутов.
[01:06:42.940 --> 01:07:01.940]  И есть проблема. Что нам делать с нал? Если по сути дела это не ложное значение, не истинное значение, а это значение, о котором мы не можем ничего определенного сказать. Решение, тернарная логика, троичная логика, тройственная логика.
[01:07:02.860 --> 01:07:16.860]  Я использую термин тернарная. Вы больны использовать любой иной употребимый термин. Насколько я понимаю они взаимозаменяемы.
[01:07:17.780 --> 01:07:29.780]  Нужно отличать сам маркер нал, который у нас реально фигурирует в данных, в нашей таблице, от логического значения unknown. Логическое значение unknown у нас нигде не фигурирует.
[01:07:30.700 --> 01:07:48.700]  Это может быть результатом действия какого-то оператора, который производит логическое сравнение, например. Чего-то с нал, или может быть даже чего-то с unknown. Но unknown у нас такого типа самого по себе нет.
[01:07:49.620 --> 01:08:01.620]  True or null. Сейчас вы все увидите. Таблицы истинности приведены на экране.
[01:08:02.540 --> 01:08:10.540]  Таким образом у нас true or null должно быть равно чему чему чему чему.
[01:08:13.540 --> 01:08:22.540]  Должно быть равно true по вот этой вот клеточке получается.
[01:08:23.460 --> 01:08:41.460]  Здесь, наверное, это просто нужно запомнить. Смириться и начать жить в парадигме тройственной логики, троичной логики, тернарной логики.
[01:08:42.380 --> 01:08:52.380]  Здесь, наверное, нет какой-то особой может быть сложности. Просто нужна практика, чтобы все это осело.
[01:08:53.380 --> 01:09:01.380]  Единственное, хотелось бы сказать, что есть также в документации описание функции оператора в сравнении.
[01:09:02.300 --> 01:09:11.300]  Оно, честно говоря, даже, наверное, может быть в некотором роде более удобное. Оно просто довольно обширное. Оно объемное, но может быть более удобное для восприятия.
[01:09:12.300 --> 01:09:22.300]  Здесь я вам привожу более, может быть, общие какие-то описания того, как логические функции будут действовать в поле тернарной логики.
[01:09:23.300 --> 01:09:29.300]  Там более практико-ориентированные. Поэтому рекомендую обратиться тоже, посмотреть, как и что работает.
[01:09:30.220 --> 01:09:36.220]  SQL предоставляет несколько стандартных предикатов, позволяющих провести логическое сравнение.
[01:09:37.220 --> 01:09:42.220]  Как эти предикаты действуют, опять же, тоже на слайде приведено.
[01:09:43.140 --> 01:10:00.140]  Здесь, в принципе, что можно сказать? Обратите внимание, эти предикаты, в отличие от только что просмотренных таблиц истинности, не выдают нам значение unknown.
[01:10:01.140 --> 01:10:09.140]  У них всегда значение или false, или true. Почему это может быть важно? А вот, собственно говоря, почему.
[01:10:10.060 --> 01:10:18.060]  Все сравнения с маркером null приводят к значению unknown, за исключением специальных предикатов.
[01:10:19.060 --> 01:10:22.060]  Значение or не является сравнением, да?
[01:10:27.060 --> 01:10:33.060]  С логической точки зрения у нас будет true. True или unknown будет true.
[01:10:34.060 --> 01:10:37.060]  То есть логические операторы – это не сравнение?
[01:10:37.980 --> 01:10:44.980]  Нет, нет, нет. Это логические функции.
[01:10:45.980 --> 01:10:56.980]  Они сообщают результат в виде истинности и ложности, ну или в данном случае unknown, по отношению к тому, какие операторы в них загружены.
[01:10:57.900 --> 01:11:09.900]  Сравнение у нас подразумевает, что у нас есть какое-то, как бы это обозначить, чтобы не быть более или менее корректным.
[01:11:10.900 --> 01:11:16.900]  Сравнение у нас подразумевает какую-то шкалу, что ли, мерную. С логическими функциями никакой мерной шкалы нет, есть просто правила.
[01:11:17.820 --> 01:11:25.820]  Поэтому у нас, как бы так сказать, тоже плохое описание.
[01:11:26.820 --> 01:11:28.820]  В общем or – это не сравнение, ребята, это логическая функция.
[01:11:29.820 --> 01:11:34.820]  Давайте вот так вот на этом завершим, чтобы не впадать в какую-то тавтологию.
[01:11:37.820 --> 01:11:41.820]  Сейчас постараемся закончить все-таки стернарной логикой быстренько.
[01:11:42.740 --> 01:11:48.740]  Основное правило, еще раз, с маркером null все сравнения приводят к значению unknown, тем не менее.
[01:11:49.740 --> 01:11:51.740]  И что это значит?
[01:11:52.740 --> 01:11:56.740]  Что null равно 5, что у нас мы получим? Unknown. 5 равно null? Unknown.
[01:11:57.740 --> 01:11:59.740]  null меньше или равно 5 – unknown.
[01:12:00.740 --> 01:12:02.740]  Ну и далее, что у нас получается еще?
[01:12:03.660 --> 01:12:11.660]  Если мы берем какое-то значение из некоего атрибута и начинаем сравнивать его с 5,
[01:12:12.660 --> 01:12:17.660]  то есть проходим по строчкам таблицы, берем оттуда по одному атрибуту значения, сравниваем с 5,
[01:12:18.660 --> 01:12:22.660]  и у нас в этой конкретной строчке конкретной таблице получается значение null, мы получаем unknown.
[01:12:23.580 --> 01:12:37.580]  Причем у нас, опять же, если мы сравниваем две таблицы по какому-то атрибуту,
[01:12:38.580 --> 01:12:44.580]  и у одной таблицы в этом атрибуте или у обеих таблиц в этих атрибутах сразу появляется значение null,
[01:12:45.580 --> 01:12:47.580]  то тоже значение unknown.
[01:12:48.580 --> 01:12:50.580]  null равно null тоже у нас не определено.
[01:12:51.500 --> 01:12:55.500]  Что нужно помнить еще о тернарной логике при запросах?
[01:12:56.500 --> 01:13:01.500]  Ключевые слова in, where и having строго требуют значения true, поэтому not false для них недостаточно.
[01:13:02.500 --> 01:13:06.500]  А not false – это что у нас такое? Это у нас true или unknown, как мы понимаем.
[01:13:07.500 --> 01:13:11.500]  Поэтому у нас со значением unknown они не работают,
[01:13:12.500 --> 01:13:17.500]  но, как было показано ранее, для проверки по команде check действует более слабое условие.
[01:13:18.420 --> 01:13:23.420]  Для сравнения значения с null нужно использовать специальный предикат,
[01:13:24.420 --> 01:13:32.420]  можно также использовать is not distinct from или is not distinct from с типом null.
[01:13:33.420 --> 01:13:38.420]  При наличии сомнений, опять же, обращаться к документации, подумать вообще,
[01:13:39.420 --> 01:13:41.420]  вспомнить о том, что мы работаем с тернарной логикой,
[01:13:42.340 --> 01:13:50.340]  и что у нас есть null умножить на ноль в Эйбейте.
[01:13:56.340 --> 01:13:58.340]  Так, ошибка должна быть.
[01:13:59.260 --> 01:14:09.260]  Так, что еще можно использовать?
[01:14:10.260 --> 01:14:12.260]  Нужно помнить тернарные логики при запросах.
[01:14:13.260 --> 01:14:16.260]  Соответственно, помните, у нас тернарная логика,
[01:14:17.260 --> 01:14:22.260]  у нас специфические вещи происходят, если у нас появляется null,
[01:14:23.180 --> 01:14:29.180]  при этом мы можем, опять же, еще использовать два интересных предиката,
[01:14:30.180 --> 01:14:32.180]  это is unknown и is not unknown,
[01:14:33.180 --> 01:14:38.180]  когда мы хотим сравнить прям результат,
[01:14:39.180 --> 01:14:44.180]  именно логический результат с неким, является ли он unknown или нет.
[01:14:47.180 --> 01:14:50.180]  Там любопытный момент, любопытные обстоятельства,
[01:14:51.100 --> 01:14:54.100]  я уже, наверное, видимо, на следующей лекции вам покажу.
[01:14:55.100 --> 01:14:59.100]  Так, сейчас просто быстро закроем DDL,
[01:15:00.100 --> 01:15:05.100]  чтобы у нас уже со следующего раза был точно data manipulation language.
[01:15:07.100 --> 01:15:13.100]  Две основные команды, это alter, вернее, не две, а там три получается команды,
[01:15:14.100 --> 01:15:16.100]  у нас остается alter table,
[01:15:17.020 --> 01:15:20.020]  опять же, у нас команда alter является,
[01:15:22.020 --> 01:15:25.020]  слово ключевой alter является началом многих других команд,
[01:15:26.020 --> 01:15:28.020]  документации, как и с create,
[01:15:29.020 --> 01:15:31.020]  вы увидите, что с alter есть еще варианты,
[01:15:32.020 --> 01:15:36.020]  не только table, но и других сущностей,
[01:15:37.020 --> 01:15:39.020]  можно другие сущности менять, не только таблицы,
[01:15:40.020 --> 01:15:43.020]  но для базового понимания, вот пример приведен с alter table,
[01:15:43.940 --> 01:15:46.940]  syntax is приведен на рисунке на слайде,
[01:15:47.940 --> 01:15:49.940]  он тоже урезанный,
[01:15:50.940 --> 01:15:55.940]  там гораздо-гораздо больше возможностей по действиям,
[01:15:56.940 --> 01:15:58.940]  по крайней мере,
[01:15:59.940 --> 01:16:02.940]  и в принципе, на самом деле alter table,
[01:16:03.940 --> 01:16:05.940]  команда довольно простая с точки зрения логики того,
[01:16:06.940 --> 01:16:08.940]  что она делает, того, как она формулируется,
[01:16:09.940 --> 01:16:12.940]  поэтому здесь на самом деле нет каких-то подводных команд,
[01:16:13.940 --> 01:16:16.940]  мы делаем таблицу с людьми,
[01:16:19.940 --> 01:16:21.940]  с персоналом, например,
[01:16:22.940 --> 01:16:26.940]  и хотим дальше изменить, например, ограничения,
[01:16:27.940 --> 01:16:30.940]  мы можем менять в таблице колонки добавлять,
[01:16:31.940 --> 01:16:33.940]  ограничения менять, удалять,
[01:16:34.940 --> 01:16:37.940]  можем много-много вариантов всевозможных,
[01:16:38.940 --> 01:16:41.940]  документации вы найдете исчерпывающий перечень ребят,
[01:16:42.860 --> 01:16:48.860]  вот на примере мы добавляем ограничения в виде первичного ключа,
[01:16:49.860 --> 01:16:54.860]  и удаляем потом ограничения в виде первичного ключа,
[01:17:02.860 --> 01:17:04.860]  дальше у нас truncate и drop,
[01:17:05.860 --> 01:17:08.860]  две простые команды на самом деле,
[01:17:09.860 --> 01:17:11.860]  буквально по два слова о каждой,
[01:17:12.860 --> 01:17:15.860]  truncate позволяет быстро удалять все строки из таблиц,
[01:17:16.860 --> 01:17:20.860]  похоже на команду delete из datamanipulationlanguage,
[01:17:21.860 --> 01:17:24.860]  но действует быстрее, так как не всканируют таблицы
[01:17:25.860 --> 01:17:28.860]  и сразу высвобождает дисковое пространство,
[01:17:29.860 --> 01:17:31.860]  не нужно выполнять операцию vacuum,
[01:17:32.860 --> 01:17:34.860]  про операцию vacuum мы с вами еще поговорим,
[01:17:35.860 --> 01:17:37.860]  потому что как не забавно,
[01:17:38.860 --> 01:17:40.860]  оказывается, что когда мы изменяем данные,
[01:17:41.780 --> 01:17:45.780]  не всегда получается в результате освобождения дискового пространства,
[01:17:46.780 --> 01:17:54.780]  не всегда получается физическое удаление,
[01:17:55.780 --> 01:17:57.780]  иногда нужно запускать отдельно команду vacuum,
[01:17:58.780 --> 01:18:05.780]  и у нас удаляются по сути дела только ссылочные информации из нашей базы
[01:18:06.780 --> 01:18:09.780]  на удаленные команды delete строки,
[01:18:10.700 --> 01:18:12.700]  в общем случае,
[01:18:13.700 --> 01:18:15.700]  и сама таблица, важно иметь в виду,
[01:18:16.700 --> 01:18:18.700]  что сама таблица после исполнения команды truncate остается,
[01:18:19.700 --> 01:18:21.700]  то есть остается у нас по сути заголовок отношения,
[01:18:22.700 --> 01:18:24.700]  там будет ноль строк, но отношение останется,
[01:18:25.700 --> 01:18:27.700]  droptable команда базовый syntax is опять же на экране,
[01:18:28.700 --> 01:18:30.700]  droptable удаляет таблицу,
[01:18:31.700 --> 01:18:33.700]  droptable можно не только удалять таблицу,
[01:18:34.700 --> 01:18:36.700]  можно удалять еще данные,
[01:18:37.620 --> 01:18:39.620]  но удаляет таблицу из базы данных полностью,
[01:18:40.620 --> 01:18:42.620]  удаляет таблицу может ее владелец,
[01:18:43.620 --> 01:18:46.620]  ну ладно, про роли мы не будем сейчас с вами останавливаться на этом,
[01:18:47.620 --> 01:18:53.620]  но важно, наверное, как резюме понимать,
[01:18:54.620 --> 01:18:58.620]  что truncate удаляет тело таблицы оставляясь за заголовок отношения,
[01:18:59.620 --> 01:19:06.620]  drop удаляет отношение целиком со всеми его данными задержащимися,
[01:19:06.700 --> 01:19:08.620]  миссия в нем.
