[00:00.000 --> 00:18.000]  Помним, что до этого мы делали. У нас пошел раздел про синтаксис, определение ложность, в прошлый раз мы определили истинность формулы при помощи синтаксиса.
[00:18.000 --> 00:30.000]  Ну, понятно, что если мы можем синтаксически определять истинность, то теперь нас будет интересовать, можем ли мы синтаксически проверять наложность.
[00:30.000 --> 00:47.000]  Причем проверка на ложность и на истинность равносильна в том смысле, что А от автологии, я буду писать так, равносильно, что не А противоречие.
[00:47.000 --> 01:04.000]  Еще чуть раньше мы проговорили, что любая булевая формула, функция может быть приведена к КНФ, например. Даже СКНФ научились это все строить.
[01:04.000 --> 01:33.000]  КНФ, как мы помним, определяется в несколько этапов. Первый этап это литерал, это переменная либо ее отрицание, дальше у нас есть дизюнкт, это конъюнция дизюнтей литералов и дальше идет само КНФ, конъюнция дизюнтых.
[01:33.000 --> 01:51.000]  Помнится, мы рассматривали, что КНФ и дизюнт могут иметь мощность 1, то есть конъюнция только одного дизюнта и дизюнт только с одной переменной.
[01:51.000 --> 02:06.000]  Но ведь натуральные числа у нас, как мы помним, стартуют с нуля, поэтому хочется уже задуматься о том, что такое дизюнт от нуля переменных.
[02:06.000 --> 02:20.000]  Назовем его пустым. Какие предположения, чем будет у нас вообще пустой дизюнт?
[02:20.000 --> 02:29.000]  Ну нулем, наверное.
[02:29.000 --> 02:41.000]  Действительно, пустой дизюнт- это ложь. Почему так?
[02:41.000 --> 02:58.000]  Идейно, когда мы используем дизюнцию, то свойство дизюнтства такое, что если что-то 0, если что-то 1, то и все 1.
[02:58.000 --> 03:10.000]  И каждый раз, когда мы добавляем через дизюнцию, мы стараемся расширить количество выполняющих наборов.
[03:10.000 --> 03:22.000]  И если бы изначально начинались единицы, то понятно, что любое дальше добавление, оно не сможет добавить новых выполняющих наборов в силу того, что уже у нас есть единица.
[03:22.000 --> 03:30.000]  А значит, стартую с нуля, то есть тождественной ложи, добавляю новой переменной, мы расширяем.
[03:30.000 --> 03:44.000]  По аналогичной логике, пустой конюнт будет тождественной истиной, потому что конюнтцы, наоборот, у нас стремятся сократить количество выполняющих наборов, сузить.
[03:44.000 --> 03:54.000]  Обозначать будем его, как обозначали тождественную ложь.
[03:54.000 --> 04:08.000]  В частности, тогда вот, например, я решил обозначать тождественную ложь, тождественной истиной, но при помощи перевернутой T и просто T, чтобы дальше вот, когда мы начали говорить по пустой дизюнте, с этим перекрикалось.
[04:14.000 --> 04:32.000]  Оказывается, что если мы сможем получить КНФ, то есть КНФ у нас, дайте, D1, конюнтцы D2, конюнтцы Dn.
[04:32.000 --> 04:42.000]  Как мы помним, из Axiom и Modus ponens я смогу из этого всего вывести просто D1, тогда ли Dn.
[04:42.000 --> 04:52.000]  Если я теперь могу вывести каждый дизюнт, то что я могу сделать с любым из них?
[04:52.000 --> 05:06.000]  Ну, например, я могу любые два дизюнта как-то объединить произвольными операциями с пропозициональных формул.
[05:06.000 --> 05:16.000]  Но если произвольными, то импликацию мне пока незачем получать, потому что, да, я вот тайду идеи над КНФ.
[05:16.000 --> 05:20.000]  Если я пойду объединять их по конюнтце, я просто вернусь к тому, что у меня было изначально.
[05:20.000 --> 05:26.000]  Но у меня остается только одна операция – дизюнтце. То есть я расширю в некотором смысле дизюнт.
[05:26.000 --> 05:36.000]  Был D1, D2, получили D1 или D2.
[05:36.000 --> 05:49.000]  Но понятно же, что можно упрощать дизюнт.
[05:49.000 --> 06:00.000]  И как раз правило метода резолюции говорит о том, что у нас был раз дизюнт, был два дизюнт, мы можем как-то их простить, объединяя по дизюнтце.
[06:00.000 --> 06:16.000]  И оно звучит так. У нас есть D1 или X.
[06:16.000 --> 06:28.000]  Дизюнты мы считаем… Ну ладно, он все равно будет работать. В самом общем случае будем смотреть D2 или не X.
[06:28.000 --> 06:38.000]  То есть у нас есть какая-то переменная дизюнтце с дизюнтом и другой дизюнт, но уже дизюнтце с отрицанием этой переменной.
[06:38.000 --> 06:53.000]  Тогда отсюда выведется D1 или D2.
[06:53.000 --> 07:01.000]  Ну и как раз как нам вывести пустой дизюнт? Пустой дизюнт значит 0 переменных.
[07:01.000 --> 07:14.000]  Если здесь должно быть 0 переменных, то D1 у нас 0 и D2 тоже 0.
[07:14.000 --> 07:27.000]  А значит выводится это единственным образом из переменной и отрицания.
[07:27.000 --> 07:30.000]  Хорошо.
[07:30.000 --> 07:54.000]  Дальше. Так как мы поняли, что под капотом всего этого происходят правильные преобразования в смысле прошлого раза аксиом и правилов вывода, то то, что мы получили работает корректно в предположении исходных посылок.
[07:54.000 --> 08:11.000]  А значит мы можем спокойно дописывать новые полученные дизюнты, а мы действительно получаем дизюнты, потому что это дизюнт, это дизюнт, а дизюнтцы дизюнтов это дизюнт.
[08:11.000 --> 08:16.000]  То мы можем спокойно дописать это в новую формулу.
[08:16.000 --> 08:23.000]  То есть у нас было какой-то КНФ.
[08:23.000 --> 08:26.000]  D1, так далее.
[08:26.000 --> 08:30.000]  Dn-1 или
[08:30.000 --> 08:32.000]  x и
[08:32.000 --> 08:34.000]  Dn-2
[08:34.000 --> 08:35.000]  или
[08:35.000 --> 08:37.000]  не x.
[08:37.000 --> 08:42.000]  И мы дальше при помощи метода резолюций
[08:42.000 --> 08:47.000]  перевели к эквивалентному
[08:47.000 --> 08:50.000]  КНФ штрих давайте.
[08:50.000 --> 08:53.000]  D1, так далее.
[08:53.000 --> 08:55.000]  D
[08:55.000 --> 09:00.000]  вот это еще раз писать. Я просто Dn-2
[09:00.000 --> 09:02.000]  или не x
[09:02.000 --> 09:03.000]  и
[09:03.000 --> 09:12.000]  новый выведенный дизюнт.
[09:12.000 --> 09:17.000]  Тогда что бы это означать, что мы вывели пустой дизюнт?
[09:17.000 --> 09:22.000]  То мы сделали конъюнцию с пустым дизюнтом.
[09:22.000 --> 09:24.000]  А пустой дизюнт это ложь.
[09:24.000 --> 09:27.000]  То есть мы сделали конъюнцию с ложью.
[09:27.000 --> 09:31.000]  Значит вся формула это ложь.
[09:31.000 --> 09:32.000]  Вот.
[09:32.000 --> 09:36.000]  И глобально мы делаем что?
[09:36.000 --> 09:40.000]  Мы берем формулу, приводим ее к КНФ
[09:40.000 --> 09:44.000]  и дальше пытаемся вывести пустой дизюнт.
[09:44.000 --> 09:48.000]  Если его вывели, то мы знаем, что формула ложна.
[09:48.000 --> 09:53.000]  Соответственно при помощи этого же можно проверять на
[09:53.000 --> 09:54.000]  истинность.
[09:54.000 --> 09:58.000]  Просто проводя метод резолюции для отрицания формулы.
[09:58.000 --> 10:09.000]  И как понятно, что
[10:09.000 --> 10:15.000]  для этого метода должны появиться две теоремы.
[10:15.000 --> 10:18.000]  Как и за числением высказываний.
[10:18.000 --> 10:26.000]  У нас есть метод резолюции.
[10:26.000 --> 10:30.000]  Не буду сокращать mp, чтобы не было путаницы с modus ponens.
[10:30.000 --> 10:39.000]  У нас в одну сторону есть теорема корректности.
[10:40.000 --> 10:55.000]  Что для любой фии, принадлежащем к
[10:55.000 --> 11:03.000]  не выполнимым формулам, то есть противоречием
[11:03.000 --> 11:08.000]  выполняется, что выводится пустой дизюнт.
[11:08.000 --> 11:14.000]  То есть любая плохая формула мы действительно ее распознаем.
[11:14.000 --> 11:18.000]  И теорема в полноте, что действительно мы всех таких плохих формул сможем.
[11:18.000 --> 11:37.000]  Давайте я назову это SAT.
[11:37.000 --> 11:46.000]  SAT это от английского Satisify.
[11:46.000 --> 11:50.000]  Удовлетворять и я не помню сейчас.
[11:50.000 --> 11:59.000]  Может быть скажу Satisify.
[11:59.000 --> 12:05.000]  Не помню я все.
[12:05.000 --> 12:17.000]  Выполнимые формулы выполнено, что не выведется пустой дизюнт.
[12:17.000 --> 12:18.000]  Я вру.
[12:18.000 --> 12:20.000]  Это наоборот как раз.
[12:20.000 --> 12:25.000]  Это корректности, что мы ничего плохого не вывели.
[12:25.000 --> 12:30.000]  Это полноте, что мы вывели все.
[12:30.000 --> 12:33.000]  Еще не проснулся.
[12:33.000 --> 12:50.000]  Так.
[12:50.000 --> 13:00.000]  Давайте теперь поговорим, что KNF.
[13:00.000 --> 13:10.000]  Давайте рассмотрим такую штуку, как NKNF.
[13:10.000 --> 13:14.000]  Будем говорить, что NKNF.
[13:14.000 --> 13:31.000]  Это KNF такая, что для любого дизюнта, принадлежащего в KNF, выполнено, что в этом дизюнте не больше N переменных.
[13:31.000 --> 13:36.000]  Или их, не больше N литералов.
[13:36.000 --> 13:46.000]  И отдельно рассмотрим 3 KNF.
[13:46.000 --> 13:51.000]  Почему будем такое внимание уделять 3 KNF?
[13:51.000 --> 13:58.000]  Рассмотрим еще раз метод резолюции.
[13:58.000 --> 14:03.000]  У нас есть A или не X.
[14:03.000 --> 14:07.000]  Есть B или X.
[14:07.000 --> 14:10.000]  И из этого мы можем вывести B или A.
[14:10.000 --> 14:14.000]  Давайте посмотрим на соотношение мощностное.
[14:14.000 --> 14:18.000]  Наверное, по-хорошему нужно сразу сказать, что такое.
[14:18.000 --> 14:20.000]  Мощность D.
[14:20.000 --> 14:22.000]  Мощность D, где D изюнт.
[14:33.000 --> 14:40.000]  Вот такое количество литералов.
[14:40.000 --> 14:48.000]  Тогда рассмотрим, что у нас изначально было A или не X.
[14:48.000 --> 14:53.000]  То есть равняется мощности A плюс 1.
[14:53.000 --> 14:57.000]  Аналогично, что B или X.
[14:57.000 --> 15:01.000]  Мощность B плюс 1.
[15:01.000 --> 15:05.000]  И на выходе мы из этого всего получаем.
[15:05.000 --> 15:09.000]  Мощность A или B равная сумме мощностей.
[15:09.000 --> 15:11.000]  Изюнкта файли.
[15:17.000 --> 15:27.000]  Получается, если мы рассмотрим эти 4 KNF.
[15:27.000 --> 15:31.000]  То в худшем случае у нас везде по 4.
[15:31.000 --> 15:37.000]  То есть тогда A у нас это 3.
[15:37.000 --> 15:42.000]  B у нас это 3.
[15:42.000 --> 15:53.000]  А значит это все добро мы приводим к 3 плюс 3 равняется 6.
[15:53.000 --> 15:58.000]  И мы из 4 KNF перешли в 6 KNF.
[15:58.000 --> 16:00.000]  Но звучит уже немножко страшно.
[16:00.000 --> 16:10.000]  Если мы сделаем и рассмотрим просто N KNF, то N минус 1 плюс N минус 1 равняется 2N минус 2.
[16:10.000 --> 16:18.000]  Мы почти что в два раза начинаем увеличивать количество переменных.
[16:18.000 --> 16:23.000]  А это действительно очень плохо и в 8 точке мы вылежаем вообще в 2N.
[16:29.000 --> 16:32.000]  Поэтому давайте рассмотрим что происходит в 3 KNF.
[16:32.000 --> 16:35.000]  Почему мы именно на нее заострили внимание.
[16:35.000 --> 16:41.000]  3 KNF это мы из 3 переходим в 2 на 3 минус 2.
[16:41.000 --> 16:44.000]  Равняется 4.
[16:44.000 --> 16:50.000]  То есть уже на тройке мы почти что не изменили размер дезюмптов.
[16:50.000 --> 16:56.000]  Но только вот в особых случаях мы начали кушать по 4.
[16:59.000 --> 17:04.000]  Логично, что захочется использовать 2 KNF.
[17:04.000 --> 17:13.000]  Потому что тогда мы вообще не выйдем за пределы двуместных дезюмптов.
[17:13.000 --> 17:19.000]  Но с 2 KNF проблема к приведению к нему.
[17:23.000 --> 17:31.000]  А 3 KNF мы можем легко привести к этой форме произвольную булеу функцию.
[17:33.000 --> 17:36.000]  Точнее не булеу функцию, а пропозициональную форму.
[17:36.000 --> 17:38.000]  Как это сделать?
[17:39.000 --> 17:43.000]  Да даже можно произвольную булеу функцию.
[17:46.000 --> 17:49.000]  3 KNF.
[17:59.000 --> 18:01.000]  Построение.
[18:01.000 --> 18:04.000]  Давайте расскажем как строить.
[18:04.000 --> 18:07.000]  У нас есть некоторая пропозициональная формула.
[18:08.000 --> 18:16.000]  На входе. Давайте я скажу, что изначально будет что-то типа P, следует A или M.
[18:29.000 --> 18:31.000]  Ну собственно, почему бы и нет.
[18:33.000 --> 18:35.000]  Первое, что мы делаем.
[18:36.000 --> 18:40.000]  Не забываем скобки, иначе это не пропозициональная формула.
[18:40.000 --> 18:47.000]  Если это не пропозициональная формула, то у нас начинаются беды с синтаксисом.
[18:47.000 --> 18:50.000]  Изначально мы требовали всегда скобки.
[18:53.000 --> 18:56.000]  Первый шаг, строим дерево разбора.
[18:57.000 --> 19:02.000]  В силу того, что мы добавляли скобки, у нас есть единственность разбора,
[19:02.000 --> 19:05.000]  поэтому мы можем построить только одно дерево, и оно будет хорошим.
[19:13.000 --> 19:19.000]  Давайте отметим, что у нас будет листьями, что будет вершинами, узлами дерева.
[19:19.000 --> 19:27.000]  Листья дерева – это переменные, узлы дерева – это знаки логических операций.
[19:28.000 --> 19:30.000]  Дальше здесь.
[19:41.000 --> 19:42.000]  Супер.
[19:43.000 --> 19:56.000]  Теперь мы начинаем рекурсивно от листьев к корню заменять каждый узел на 3КНФ.
[19:58.000 --> 19:59.000]  А именно.
[20:04.000 --> 20:05.000]  Что мы будем делать?
[20:05.000 --> 20:11.000]  Перемены, очевидно, они сами 3КНФ, поэтому листья прямо сразу все хорошо.
[20:11.000 --> 20:16.000]  Есть юнция, есть юнция 3КНФ, 3КНФ, оставим ее.
[20:16.000 --> 20:18.000]  Преследует что-то.
[20:18.000 --> 20:29.000]  Значит, нам надо импликацию поменять на 3КНФ.
[20:29.000 --> 20:30.000]  Как мы это делаем?
[20:31.000 --> 20:33.000]  Делаем…
[20:35.000 --> 20:36.000]  Давайте.
[20:36.000 --> 20:40.000]  Мю ню и мю следует ню.
[20:41.000 --> 20:43.000]  Таблицы истинности.
[20:46.000 --> 20:48.000]  Тыц-тыц-тыц-тыц-тыц.
[20:51.000 --> 20:53.000]  И делаем конъюнцы.
[20:54.000 --> 20:56.000]  Конъюнцы у нас фиксированы нули.
[20:56.000 --> 20:58.000]  То есть это…
[20:58.000 --> 20:59.000]  Да.
[20:59.000 --> 21:03.000]  Значит, это не мю или ню.
[21:05.000 --> 21:06.000]  Супер.
[21:09.000 --> 21:12.000]  Начинаем заменять этот узел.
[21:18.000 --> 21:23.000]  Получаем, что не п, а ню.
[21:24.000 --> 21:31.000]  Получаем, что не п, или а, или м.
[21:34.000 --> 21:37.000]  А теперь у нас появилось конъюнцы с ку.
[21:37.000 --> 21:42.000]  То есть получили ку и не п, или а, или м.
[21:42.000 --> 21:59.000]  Пришли ку или не п, или ку и а, или ку и м.
[22:02.000 --> 22:04.000]  Все, получили 3КНФ.
[22:04.000 --> 22:05.000]  Но…
[22:08.000 --> 22:11.000]  Давайте вопрос на понимание.
[22:11.000 --> 22:14.000]  Чем плох такой алгоритм?
[22:25.000 --> 22:31.000]  На самом деле здесь очень просто понять, что он плохой и не подходит на самом деле.
[22:31.000 --> 22:34.000]  Давайте просто рассмотрим 3 раза дизюнцию.
[22:34.000 --> 22:38.000]  Тогда по нему нам потребуется каждый раз объединить по дизюнции.
[22:38.000 --> 22:41.000]  И мы получим не 3КНФ, а 4КНФ.
[22:43.000 --> 22:45.000]  А значит, его надо как-то модифицировать.
[22:45.000 --> 22:47.000]  А именно.
[22:50.000 --> 22:55.000]  Нам придется расширить множество переменных.
[22:56.000 --> 22:58.000]  Путем…
[23:01.000 --> 23:04.000]  Давайте я выделю этот узел.
[23:14.000 --> 23:18.000]  Путем заведения дополнительной переменной на каждый узел.
[23:22.000 --> 23:24.000]  То есть я заведу сюда…
[23:25.000 --> 23:30.000]  В, W, У.
[23:31.000 --> 23:34.000]  Давайте все-таки сюда R, потому что root.
[23:36.000 --> 23:41.000]  Теперь, если мы будем смотреть на каждый узел…
[23:41.000 --> 23:44.000]  Ой, на каждую развилку сам по себе.
[23:46.000 --> 23:49.000]  У нас, по сути, плюс-минус бинарное дерево.
[23:49.000 --> 23:54.000]  А значит, у нас родители 2 его ребенка дают сумме 3 переменных.
[23:55.000 --> 24:00.000]  Как раз сразу уже понимаем, есть какая-то связь с 3КНФ.
[24:01.000 --> 24:07.000]  Теперь осталось лишь понять, как связать родители 2 его ребенка с некоторой булевой функцией.
[24:07.000 --> 24:14.000]  И тогда дальше мы будем абсолютно аналогично, как в прошлый раз, но только модифицированным проходить.
[24:18.000 --> 24:24.000]  Ну, что значит, что мы заменили узел на вершину?
[24:24.000 --> 24:30.000]  Значит, что значение переменной должно быть таким же, как и значение на этом узле.
[24:33.000 --> 24:37.000]  А что за булева функция у нас отвечает за такой же как?
[24:38.000 --> 24:45.000]  Это экваленция. То есть у нас теперь V должна быть эквивалентно A или M.
[24:45.000 --> 24:53.000]  Тогда теперь нам нужно будет уже приводить вот это выражение к 3КНФ.
[25:05.000 --> 25:12.000]  Понятно, что если мы просто построим наш обычный SKNF, она и будет как раз 3КНФ.
[25:16.000 --> 25:18.000]  Поэтому сделать это можно.
[25:19.000 --> 25:26.000]  Тогда мы получим какую-то переменную V, которая будет эквалентно 3КНФ.
[25:26.000 --> 25:28.000]  Но что же делать дальше?
[25:28.000 --> 25:32.000]  Дальше, на самом деле, когда мы рассмотрим, вот у нас был узел V.
[25:37.000 --> 25:43.000]  V отвечает, получается, за значение.
[25:46.000 --> 25:51.000]  Теперь нам нужно будет для дубль V рассмотреть.
[25:59.000 --> 26:05.000]  Мы знаем, что значение на ребенке это V.
[26:06.000 --> 26:11.000]  А значит, теперь мы будем для V строить то же самое, но
[26:12.000 --> 26:18.000]  V должно отвечать за P следует V.
[26:24.000 --> 26:30.000]  И глобально, когда у нас есть произвольный узел, есть какие-то две переменные, отвечающие за два ребенка, есть операция,
[26:31.000 --> 26:37.000]  то переменная, отвечающая за операцию, должна быть эквивалентна
[26:37.000 --> 26:43.000]  Левый узел, операция, правый ребенок.
[26:45.000 --> 26:51.000]  Так, каждый раз у нас будет по три переменных, поэтому будет получаться 3КНФ.
[26:51.000 --> 26:56.000]  Тогда, суммарно, мы просто возьмем конюнцы всего этого.
[26:56.000 --> 27:02.000]  Это будет означать, что V отвечает за такое, и это V.
[27:03.000 --> 27:09.000]  Сейчас, это W отвечает за такой узел, и V отвечает за такой узел,
[27:11.000 --> 27:17.000]  и что там у нас будет? И R отвечает за такой узел.
[27:17.000 --> 27:21.000]  И в конце еще нам нужно будет что добавить.
[27:21.000 --> 27:27.000]  Так мы сказали, что вот у нас теперь каждый узел за него что-то отвечает.
[27:27.000 --> 27:33.000]  И нам нужно добавить, что формула сама по себе верна, что это именно эта формула.
[27:33.000 --> 27:37.000]  Значит, мы должны еще добавить R.
[27:41.000 --> 27:45.000]  То есть мы сделаем вот здесь вот будет какой-то 3КНФ.
[27:47.000 --> 27:52.000]  Конюнцы с вот этим 3КНФ.
[27:52.000 --> 27:55.000]  Ну и конюнцы с R.
[27:58.000 --> 28:05.000]  Первые три вот эти 3КНФ будут на самом деле просто своего рода кодированием формулы.
[28:05.000 --> 28:08.000]  А дальше нам нужно добавить 3КНФ исходной формулы.
[28:08.000 --> 28:11.000]  И мы добавляем 3КНФ.
[28:11.000 --> 28:14.000]  И мы добавляем 3КНФ.
[28:14.000 --> 28:17.000]  И мы добавляем 3КНФ.
[28:18.000 --> 28:22.000]  А дальше нам нужно добавить 3КНФ исходной формулы.
[28:22.000 --> 28:24.000]  А это есть R.
[28:24.000 --> 28:25.000]  Все.
[28:25.000 --> 28:30.000]  Так мы смогли перевести произвольную формулу 3КНФ.
[28:35.000 --> 28:37.000]  Можно про это немножко поподробнее?
[28:37.000 --> 28:44.000]  Потому что у нас же в этих вот конюнтах там сохраняются значения V, W и U.
[28:48.000 --> 28:54.000]  Можно еще раз поподробнее сказать, просто не совсем понимая про что.
[28:54.000 --> 29:01.000]  У нас в этих вот 3КНФ, которые остались, у нас сохраняются V, W и U.
[29:03.000 --> 29:05.000]  Они же не должны там оставаться.
[29:06.000 --> 29:08.000]  Почему не должны?
[29:08.000 --> 29:16.000]  Мы построили, ну на самом деле действительно, мы построили 3КНФ не исходной формулы, а формулы эквалентной Е.
[29:17.000 --> 29:30.000]  То есть сами по себе V, W и R, они расширят количество переменных, но не изменят значения.
[29:30.000 --> 29:33.000]  В... сейчас.
[29:33.000 --> 29:38.000]  Не изменят значения в рамках исходных переменных.
[29:38.000 --> 29:45.000]  То есть значения переменных R, W и V и всех произвольных наших новых формул.
[29:45.000 --> 29:52.000]  Наших новых фиктивных переменных, оно однозначно определяет со значениями исходных.
[29:54.000 --> 29:59.000]  И глобально они сами по себе смысла не несут.
[30:02.000 --> 30:08.000]  Ну то есть мы это можем сделать только в том случае, если нам нужно с 3КНФ что-то делать дальше.
[30:08.000 --> 30:09.000]  Да.
[30:09.000 --> 30:12.000]  Ну допустим, прерези там верна не верна.
[30:12.000 --> 30:13.000]  Да-да-да.
[30:13.000 --> 30:14.000]  Окей.
[30:14.000 --> 30:17.000]  То есть глобально мы сейчас захотели что?
[30:17.000 --> 30:25.000]  Мы захотели перейти к 3КНФ в силу того, что так мы будем не сильно разрастаться в методе резолюций.
[30:26.000 --> 30:34.000]  Поэтому мы готовы пожертвовать, ладно, давайте нам чуть побольше переменных, но зато мы будем меньше...
[30:34.000 --> 30:42.000]  Меньше разрастаться в методе резолюций, потому что сам по себе разрастание переменных оно не так страшно,
[30:42.000 --> 30:48.000]  как то, что нам придется метод резолюции запускать много-много-много-много-много раз
[30:50.000 --> 30:59.000]  и ждать пока мы начнем уменьшать количество этих, уменьшать размеры дизюнктов.
[30:59.000 --> 31:10.000]  Чем больше исходные у нас дизюнкты, тем дольше у нас будет тратиться времени на то, чтобы начать уменьшать их размер.
[31:10.000 --> 31:18.000]  Вначале у нас просто начнет колоссальным образом расти количество дизюнктов с большим числом переменных,
[31:18.000 --> 31:24.000]  ну что и логично, и из-за этого мы никакой полезной информации для себя,
[31:24.000 --> 31:32.000]  а для нас полезной это вводимость пустого, поэтому чем меньше дизюнкт, тем нам более интересно его вывести.
[31:32.000 --> 31:39.000]  И так у нас будет неэффективно строить изначально просто КНФ, НР-ной формулы.
[31:39.000 --> 31:44.000]  НР-ной, ну в смысле, что от N переменных зависит.
[31:54.000 --> 31:59.000]  Удивительно, но на этом теория все.
[31:59.000 --> 32:07.000]  Еще могли бы мы сегодня поговорить про языки первопорядка, как в прошлом году, но их не будет.
[32:07.000 --> 32:21.000]  Наверное, в общем, после этой контрольной появятся впервые задания,
[32:21.000 --> 32:30.000]  по которым будет явно сказано, что вы можете не решать программу руками, а написать программу.
[32:30.000 --> 32:42.000]  То есть можно действительно руками пытаться проводить методы изолюции, можно проводить это все, написав программу.
[32:42.000 --> 32:51.000]  По опыту скажу, что руками я не знаю сколько потребуется,
[32:51.000 --> 33:04.000]  потому что когда я решал, я писал программу, и у меня программа отрабатывала на 5000 с половиной резолюций.
[33:04.000 --> 33:09.000]  Ну и понятно, что раз это программа, то как она работает.
[33:09.000 --> 33:17.000]  Вот мы запускаем полный перебор на всякие различные резолюции 2, 3, 4.
[33:17.000 --> 33:22.000]  Если кто-то хочет оптимизировать, пожалуйста, welcome.
[33:22.000 --> 33:24.000]  Стоит ли оно того?
[33:24.000 --> 33:27.000]  Я, наверное, скажу, что не особо стоит оно того.
[33:27.000 --> 33:33.000]  Наша задача просто вывести, поэтому прогоним мы 5000 раз. В чем проблема?
[33:33.000 --> 33:38.000]  Посидим не полминуты, а минуту.
[33:38.000 --> 33:46.000]  И на самом деле, вот сейчас что мы начали думать?
[33:46.000 --> 33:52.000]  Мы начали думать о выполнимости 3КНФ.
[33:52.000 --> 34:01.000]  Наша задача про выполнимость 3КНФ.
[34:01.000 --> 34:05.000]  Ну или на самом деле невыполнимость.
[34:05.000 --> 34:10.000]  Есть такая задача, как 3SAT.
[34:10.000 --> 34:18.000]  Это задача про выполнимость 3КНФ.
[34:36.000 --> 34:42.000]  Это, если вы слышали, есть такой понятие, как NP полная задача.
[34:42.000 --> 34:49.000]  Ну не знаю, у вас на алгоритмах было ли уже динамическое программирование.
[34:49.000 --> 34:54.000]  Если не было, то, может быть, вы раньше сталкивались.
[34:54.000 --> 34:59.000]  Есть такая штука, как задача о рюкзаке, который решается DPS.
[34:59.000 --> 35:03.000]  Задача о рюкзаке очень нехорошая.
[35:03.000 --> 35:07.000]  В том смысле, что мы не умеем ее оптимально искать.
[35:07.000 --> 35:10.000]  То есть не умеем искать за пленом.
[35:10.000 --> 35:20.000]  Наверное, для людей, любящих оптимизацию, это не просто значит, что мы не можем искать за линию.
[35:20.000 --> 35:27.000]  Мы не можем написать и за квадрат, и за куб, и за четвертую, и за десятую, и за тысячную степень от N.
[35:27.000 --> 35:30.000]  Мы можем только за экспоненту.
[35:30.000 --> 35:34.000]  А за экспоненту понятно, что алгоритм очень неоптимальный.
[35:34.000 --> 35:43.000]  Вот задача о нахождении выполняющего набора, задача о выполнимости 3KNF, она также является NP трудной.
[35:43.000 --> 35:46.000]  То есть ни за какой пленом мы это решить не можем.
[35:46.000 --> 35:48.000]  Это только экспонента.
[35:48.000 --> 35:51.000]  Так что глобально к чему я веду?
[35:51.000 --> 36:02.000]  Что не нужно рассчитывать, что ваш алгоритм будет работать за какое-то там количество циклов фаров.
[36:02.000 --> 36:08.000]  Какого вы написали, в общем случае, его недостаточно.
[36:08.000 --> 36:14.000]  Поэтому можно пытаться оптимизировать, но с нужной ли?
[36:14.000 --> 36:16.000]  Хороший вопрос.
[36:18.000 --> 36:21.000]  Идеи на асимптотику вы не улучшите.
[36:21.000 --> 36:27.000]  Поэтому можете прям глупым перебором делать 1, 2, 3, 4, 5 итераций.
[36:27.000 --> 36:31.000]  Вот так вот прогонять, пока у вас не выведется пустой дизюнкт.
[36:31.000 --> 36:43.000]  Ну и помните, что пустой дизюнкт получается не из дизюнктов размера 6 и 6, а из дизюнктов только размера 2 и 2.
[36:44.000 --> 36:58.000]  Так что стараемся сначала поновыводить дизюнктов размера 2, потом из двоек поновыводить...
[36:58.000 --> 37:00.000]  Каких у нас?
[37:01.000 --> 37:03.000]  Сейчас, сейчас, сейчас.
[37:04.000 --> 37:06.000]  Из двоек поновыводить единиц.
[37:06.000 --> 37:08.000]  Что-то я, кстати, натупил тогда.
[37:08.000 --> 37:12.000]  Пустой дизюнкт из одноместных получается.
[37:12.000 --> 37:14.000]  Поэтому сначала получаем двойки.
[37:14.000 --> 37:22.000]  Из двоек выводим единички, и потом уже из единичек выводим пустой дизюнкт.
[37:24.000 --> 37:31.000]  Из таких вот действительно более-менее разумных оптимизаций это...
[37:32.000 --> 37:37.000]  Мы можем сразу, когда получаем пустой дизюнкт, мы можем сразу проверять на выводимость...
[37:37.000 --> 37:39.000]  Получать одноместный дизюнкт.
[37:40.000 --> 37:46.000]  Когда получаем одноместный дизюнкт, можем сразу проверять на выводимость пустого.
[37:47.000 --> 37:51.000]  Потому что выводимость пустого — это наличие некоторой переменной и отрицания.
[37:52.000 --> 38:00.000]  Просто можно завести что-то типа мопы и проверять, что если есть...
[38:01.000 --> 38:06.000]  Ну, там сделать типа два флага, пары какой-нибудь там, переменные и отрицания.
[38:06.000 --> 38:13.000]  И проверять, что если в паре противоположные значения.
[38:13.000 --> 38:16.000]  Если есть, то можно останавливать программу и вводить.
[38:18.000 --> 38:20.000]  Можно делать менее оптимально.
[38:21.000 --> 38:33.000]  Для любителей красивого оформления весь этот метод можно прям явно запограммировать в лотех.
[38:35.000 --> 38:40.000]  То есть берете дизюнкты, заводите, придумайте им какие-то названия переменных упоротые.
[38:40.000 --> 38:44.000]  И 1, и 2, и 3, и 500, и 700.
[38:45.000 --> 38:54.000]  Там какие-нибудь на узлы, когда нам понадобится вводить эффективные переменные.
[38:54.000 --> 39:01.000]  Можно придумать следующий вариант названия, что это будет переменная там типа f, эффективная.
[39:01.000 --> 39:04.000]  И с индексами левого, правого сына.
[39:04.000 --> 39:07.000]  Тогда у нас будет единственность названия всех этих переменных.
[39:08.000 --> 39:11.000]  Ну дальше мы имеем названия странные.
[39:11.000 --> 39:14.000]  Значки какие у нас есть?
[39:14.000 --> 39:19.000]  У нас по сути конъюнция, дизюнция, отрицание в лотехе.
[39:19.000 --> 39:25.000]  Это нод, ведж, и...
[39:30.000 --> 39:33.000]  Я не помню уже дизюнцию.
[39:33.000 --> 39:37.000]  Еще как-то там дизюнция, штопор у нас это vdash.
[39:40.000 --> 39:53.000]  И просто каждый раз берем, храним ужасный txt файл, в котором сырым лотеховским форматом просто каждый раз новую дизюнцию записываю в конец.
[39:55.000 --> 40:01.000]  Наверное тут что-то типа питона потрясающе подойдет, когда надо быстро написать какую-то вещь.
[40:01.000 --> 40:04.000]  Не особо парясь про оптимальность кода.
[40:09.000 --> 40:15.000]  Я бы даже может быть показал идей на код свой как я делал.
[40:15.000 --> 40:18.000]  Но наверное не буду.
[40:18.000 --> 40:20.000]  Не буду спойлурить.
[40:20.000 --> 40:29.000]  Глобально когда я решал задачу, идея была такая, что у нас есть изначально какое-то условие.
[40:29.000 --> 40:33.000]  Нам нужно сгенерировать сначала саму формулу.
[40:33.000 --> 40:36.000]  Там нигде не сказано про оптимальность формулы.
[40:36.000 --> 40:43.000]  Поэтому если понять ее логику, то мы просто берем сначала, генерируем какую-то вещь.
[40:43.000 --> 40:47.000]  У меня было это связано с ксорами.
[40:47.000 --> 40:53.000]  Поэтому у меня был там что-то ксор пяти переменных.
[40:53.000 --> 40:59.000]  Зная ксор пяти переменных, мы можем руками построить пять кнф.
[40:59.000 --> 41:02.000]  Ну тогда берем, строим пять кнф.
[41:02.000 --> 41:06.000]  Объединяем все эти пять кнф в одну большую пять кнф.
[41:06.000 --> 41:19.000]  А дальше, если у нас есть n-кнф, и мы хотим ее перевести к три кнф, то на самом деле нам не нужно каждую операцию переводить.
[41:19.000 --> 41:34.000]  У нас просто есть вот n1, давайте, l1, так далее, ln-2, ln-1, ln.
[41:34.000 --> 41:48.000]  Мы можем упростить себе жизнь, заменив вот так вот на n, на новую эффективную.
[41:48.000 --> 41:52.000]  Тыц-тыц-тыц-тыц-тыц.
[41:52.000 --> 42:02.000]  Так мы доведем до n-2, получим какую-то эффективную л-штрих, а это уже три кнф и оставить.
[42:02.000 --> 42:05.000]  А все предыдущие, ну просто допишем в конец.
[42:05.000 --> 42:12.000]  И глобально нам просто нужно вот подправить слишком широкие дезюмпты.
[42:12.000 --> 42:14.000]  Все.
[42:14.000 --> 42:18.000]  Как работать с дезюмптами-конюнктами?
[42:18.000 --> 42:21.000]  Ну это вообще очень просто.
[42:21.000 --> 42:23.000]  Нам значки вот эти не нужны.
[42:23.000 --> 42:28.000]  Нам просто нужно название этих переменных, поэтому можно хранить следующим образом.
[42:28.000 --> 42:48.000]  У нас будет один лист, это типа кнф, лист дезюмптов, а сам дезюмпт это просто лист литералов.
[42:58.000 --> 43:05.000]  Как-то так.
[43:05.000 --> 43:21.000]  Ну и еще из идей на того, что я делал, что я заводил отдельно массивы там под...
[43:21.000 --> 43:26.000]  Дезюмпты одноместные, под двуместные, трехместные, четырехместные.
[43:26.000 --> 43:28.000]  Всего рода сортировка по ним.
[43:28.000 --> 43:39.000]  И прогонял там комбинации 3 плюс 2, 2 плюс 3, 3 плюс 3, там 2 плюс 2, 1 плюс 1.
[43:39.000 --> 43:47.000]  И спустя там наверное 5 или 6 таких вот комбинаций-итераций у меня все прошло.
[43:47.000 --> 44:02.000]  Давайте, если есть вопросы по теории, задавайте и пойдем решать задачу.
[44:02.000 --> 44:10.000]  Можете, пожалуйста, еще раз объяснить про три кнф, почему вот эта новая форма соответствует изначально?
[44:10.000 --> 44:13.000]  Изначально.
[44:13.000 --> 44:17.000]  Хорошо.
[44:17.000 --> 44:37.000]  Начнем с первого, что если у меня есть вот n дезюмптов, то из этого по правилам вывода я могу спокойно вывести по отдельности каждый дезюмпт.
[44:37.000 --> 44:40.000]  Это вроде понятно.
[44:40.000 --> 44:51.000]  Хорошо. Если у меня выводится d1, т.д. или dn, то я могу вывести объединение dn и dm.
[44:51.000 --> 44:56.000]  Произвольные два дезюмпта, я могу вывести их дезюмпт сюда.
[44:56.000 --> 44:59.000]  Хорошо.
[44:59.000 --> 45:13.000]  Так, давай так сделаем.
[45:13.000 --> 45:16.000]  Вот это правило мы чуть модифицируем.
[45:16.000 --> 45:24.000]  Понятно, что если у меня есть d1 или x, я могу вывести формулу d1 или nx.
[45:24.000 --> 45:31.000]  В частности, я могу вывести коммутативность, значит я могу записать ниней x или d.
[45:31.000 --> 45:35.000]  Здесь ниней x или d2.
[45:35.000 --> 45:42.000]  Я могу вывести формулу, что ни a или b из этого выводится из a следует b.
[45:42.000 --> 45:54.000]  Из этих двух штук я могу вывести не x, а d1. Из x следует d2.
[45:54.000 --> 46:02.000]  Хорошо.
[46:02.000 --> 46:06.000]  Тогда...
[46:06.000 --> 46:10.000]  Ну так, съема про...
[46:10.000 --> 46:14.000]  Сейчас давайте скажу.
[46:14.000 --> 46:16.000]  Или даже не так.
[46:16.000 --> 46:24.000]  Ну ладно, давай так пока.
[46:24.000 --> 46:40.000]  Если у меня есть такие две штуки, то я могу сказать, что из не x или x следует d1 или d2.
[46:40.000 --> 46:42.000]  Хорошо.
[46:42.000 --> 46:46.000]  Вот если у меня есть две такие, то я могу вывести такую.
[46:46.000 --> 46:49.000]  Вот это, это съема 11.
[46:49.000 --> 46:52.000]  Значит я его могу вывести.
[46:52.000 --> 46:59.000]  И тогда по modus ponens я могу вывести d1 или d2.
[46:59.000 --> 47:01.000]  А теперь внимание, то есть...
[47:01.000 --> 47:07.000]  Окей, хорошо, вот я получил, что вот эта штучка корректна как-то.
[47:07.000 --> 47:10.000]  А теперь внимание, изначально что мы сделали?
[47:10.000 --> 47:15.000]  Мы сказали, что если выводится вот такой вот d1 dn, значит выводится то.
[47:15.000 --> 47:29.000]  То есть мы в рамках того, что если формула верна, то верны и все остальные.
[47:29.000 --> 47:37.000]  А значит, если мы допишем вот эти все штуки, то что получится?
[47:37.000 --> 47:47.000]  Если исходная формула была верна, то все дописанные тоже верны.
[47:47.000 --> 47:50.000]  Значит, и новая формула тоже будет верна.
[47:50.000 --> 47:58.000]  Если исходная формула была неверна, то конъюнцию с произвольной штукой это все равно неверная формула.
[47:58.000 --> 48:02.000]  Значит, если исходная была неверна, то и новая тоже неверна.
[48:02.000 --> 48:06.000]  И таким образом, что они эквалентны.
[48:06.000 --> 48:14.000]  эквивалентно. А в обратную сторону? Почему? Я понял, почему если исходная верна, то новая верна.
[48:14.000 --> 48:26.640]  Потому что если исходная не верна, то вторая не верна. Это контрпозиция факта того, что если вторая верна, то первая верна.
[48:26.640 --> 48:45.640]  Вообще, вот это хорошее свойство в доказательствах используется, что если мы хотим эквалент из двух фактов показать, мы можем неявно говорить, что если один верен, то второй верен, и второй верен, то первый верен.
[48:45.640 --> 48:59.640]  Мы можем также рассматривать, что если первый верен, то второй верен, и что если первый не верен, то и второй не верен. В этом плане контрпозиция очень хорошая штука в доказательствах.
[48:59.640 --> 49:20.640]  Хорошо. Еще вопросы по теории? Ну если нет, то давайте смотреть задачи.
[49:29.640 --> 49:48.640]  Первая задача вот такая вот. Там вроде бы возможно добавить, там вроде должно еще одну задачу добавить. Ее как добавит, я выложу ее решение.
[49:48.640 --> 50:05.640]  Хорошо. Задача формулируется так, что у нас есть изначально множество дезюнтов, то есть есть некоторые КНФ, даже три КНФ.
[50:05.640 --> 50:23.640]  Мы рассматриваем множество циты, где это множество дезюнтов, вводимых за и расприменение метода резолюции.
[50:23.640 --> 50:48.640]  Монологичное определение этого множества, что если мы запишем метод резолюции при помощи дерева, то глубина дерева должна не превосходить и.
[50:48.640 --> 51:00.640]  И нужно проверить следующие дезюнтов. Укажите минимальные. Такое, что дезюнт лежит в цитах. Если такое нет, напишите минус один.
[51:00.640 --> 51:20.640]  Я бы советовал начать, либо с попытки вывести пустой дезюнт, либо с попытки вывести выполняющий набор.
[51:20.640 --> 51:34.640]  Как это делать? Давайте начнем сначала просто применять метод резолюции, не особо парясь на классификацию данного.
[51:34.640 --> 51:46.640]  Вот, например, сразу просто смотрим, когда есть два двухместных дезюнта. Если можем применить метод резолюции, обязательно применяем.
[51:46.640 --> 52:08.640]  Дальше. Важно, что нужно отметить, какой вариант метод резолюции не стоит применять.
[52:08.640 --> 52:36.640]  Ну или другая там комбинация x и y, когда один истинно другой ложь, это без разницы.
[52:36.640 --> 52:46.640]  Почему не стоит применять метод резолюции к нему? Глобально без разницы. Вот я сейчас почему проведу резолюцию по x или по y.
[52:46.640 --> 53:01.640]  Потому что если произведу это без ограничения общности по x, я получу d1 или d2 или y или не y. Я получу y или не y. То есть если дезюнт это торжественная истина.
[53:01.640 --> 53:21.640]  А смысл каждой новой резольвенты, резольвенты это результат, получаемый после применения метода резолюции, то каждая резольвента она добавляется в конъюнцию к исходной формулы.
[53:21.640 --> 53:41.640]  А добавление единицы к конъюнции не несет никакого смысла. Поэтому вот это мы не делаем.
[53:41.640 --> 53:57.640]  А что мы можем сделать? Мы можем сделать какую-нибудь еще такую шнягу. Давайте я вот это с этим. Почему я хочу применить вот эти два дезюнта?
[53:57.640 --> 54:17.640]  Потому что у них есть общие переменные. А значит в резольвенте она схлопнется до одной. То есть у нас был q или s, а не q или r или s.
[54:17.640 --> 54:33.640]  Если q или q пропадают, то остается s или r или s. А это то же самое, что s или r.
[54:33.640 --> 54:47.640]  Но на самом деле для того, чтобы как-то жить красиво, будем поддерживать алфавитный порядок и будем писать все-таки раз.
[54:47.640 --> 55:11.640]  Хорошо. Что я еще могу сделать? Я могу по аналогии применить ко второму и последнему q или s. q или r или s.
[55:11.640 --> 55:25.640]  Это qr. Вот смотрите у меня снова появились два двух местных. Начинаю творить с ними чудо.
[55:25.640 --> 55:50.640]  П или q? Ну дайте прям так запишу. А это p или r? Что еще у меня есть? Что-нибудь интересное.
[55:50.640 --> 56:02.640]  Вот у меня есть p или r и теперь есть p или не r или не s. Сейчас вы поймете зачем это делаю. p или не r или не s.
[56:02.640 --> 56:21.640]  Я могу вывести p или не s. Но у меня же есть p или s и есть p или не s. Я могу наконец-то вывести одноместный дизюнк.
[56:21.640 --> 56:31.640]  Как только мы получили одноместный дизюнк, самое разумное будет сделать, что понизить местность дизюнка в содержащие не p.
[56:31.640 --> 56:51.640]  Мы просто можем, используя метод резолюции, поубирать вхождения не p из них. Я могу п или не q или не r.
[56:51.640 --> 57:07.640]  Возвращаем по методу резолюции не q или не r. У меня есть q или r и как мы понимаем, что поменять метод резолюции к ним особо пользы не принесет. Ну ладно.
[57:07.640 --> 57:35.640]  У меня есть q или не q и есть r. Давайте применять к этому.
[57:35.640 --> 58:03.640]  Это не q или r или s, не q или s.
[58:03.640 --> 58:30.640]  А теперь у меня есть q или s. Раз получили s, два получили p. Что мы теперь будем делать? Снова получили литерал. Начинаем понижать местность всех дизюнков с отрицанием его.
[58:30.640 --> 58:47.640]  Ну как мы это будем делать? У нас есть q или не... Ой сейчас, ладно, нет, у нас есть p или не r.
[58:47.640 --> 59:08.640]  У нас есть q или r. Уводим q или r. Дальше еще что-нибудь с не с у нас есть.
[59:08.640 --> 59:26.640]  У нас что-то больше ничего нету. Ну ладно. У нас есть q или не r и q или r. q или не r. Если у нас что-нибудь полезное для этой штуки.
[59:26.640 --> 59:39.640]  Пум-пум-пум-пум-пум. Сейчас скажу.
[59:39.640 --> 59:59.640]  Ну вот, можно заметить, что уже сейчас я смотрю и особо не могу придумать что-то хорошего. Правда ли что? Ну кроме... Сейчас подумаю полезно ли это вообще.
[59:59.640 --> 01:00:25.640]  q и не r, q и не q и не s, q и не r. То есть, что сказать, что s, q, r, q, r выявилось. Если что-нибудь у меня на...
[01:00:25.640 --> 01:00:39.640]  Ну вот, мы видим, что как-то особой пользы от того, что я сейчас начинаю выводить двуместные дизюнкты не получилось.
[01:00:39.640 --> 01:00:50.640]  Значит, придется нам как-то вывести трехместный. Ну какой нам трехместный будет полезен? По-хорошему, нам будет полезен...
[01:00:50.640 --> 01:01:02.640]  Какой-то...
[01:01:02.640 --> 01:01:15.640]  Какой-то какой-то сейчас...
[01:01:15.640 --> 01:01:30.640]  Да никакого уже особого хорошего нет. Это тестовое задание. Дальше думать здесь, наверное, не надо. Если смогли вывести, то супер. Глобальная задача просто попытаться вывести двуместных дизюнтов.
[01:01:30.640 --> 01:01:52.640]  Зачем их нужно пытаться выводить? Затем, что теперь у нас есть ограничение по управляющему набору. То есть, у нас есть s, у нас есть p и у нас есть формула, связывающая койлер.
[01:01:52.640 --> 01:02:11.640]  Значит, мы можем просто теперь попробовать подобрать какие-то наборы. А именно, если у нас есть p, то у нас выполнен автоматический набор этот и вот этот. s даст нам выполнимость вот этого набора, вот этого набора.
[01:02:11.640 --> 01:02:25.640]  И все. Теперь этот набор у нас будет не койлер, а этот набор даст нам койлер.
[01:02:25.640 --> 01:02:40.640]  Но если у нас есть тут такие две штуки, то мы можем подобрать выполняющий набор? Действительно, можем. Возьмем q и r неравные между собой. Например, q равны нулю, r равны единице.
[01:02:40.640 --> 01:02:58.640]  Тогда оба два оставшихся дизюнта выполнятся. И значит, мы получим того, что исходное кнф будет выполнимо. А тогда по терям и корректности мы не сможем вывести пустой дизюнт. То есть, получили минус один.
[01:02:58.640 --> 01:03:10.640]  Более того, зачем мы это делали? Вот смотрите. Например, мы можем уже проверить, среди этих формул, выводятся они или нет.
[01:03:10.640 --> 01:03:24.640]  Ну, понятно, что если p верно, то вот это вот все оно как-нибудь там выведется. А вот здесь у нас что? s это...
[01:03:24.640 --> 01:03:29.640]  Сейчас скажу.
[01:03:29.640 --> 01:03:53.640]  С это у нас один, значит это ноль. Это можно забить. А значит, от нас хотят, что теперь выводится формула q или не r.
[01:03:53.640 --> 01:04:04.640]  Но q или не r, она будет верна, если эти оба равны единицам. Если эти оба равны единицам, как мы помним, наша исходная формула была не верна.
[01:04:04.640 --> 01:04:10.640]  А значит, из нее вывести такой дизюнт нельзя.
[01:04:10.640 --> 01:04:16.640]  Сейчас, сейчас, сейчас. Или я туплю. Я туплю.
[01:04:16.640 --> 01:04:28.640]  Нельзя вывести, если исходная была верна, а заключение было неверно. Тогда это делается несколько иначе. Делается ноль-один. Вот.
[01:04:28.640 --> 01:04:35.640]  Такое мы вывести не сможем. Исходная формула наша истина, а мы вывели дизюнт, который будет ложен.
[01:04:35.640 --> 01:04:50.640]  Поэтому это тоже минус один. И теперь наша задача просто в том, чтобы понять, за сколько можно вывести первые три.
[01:04:51.640 --> 01:05:00.640]  Ну, давайте смотреть. PLS, как мы помним, мы сразу получили за один. Поэтому прямо сразу пишем за один. Чего его париться?
[01:05:00.640 --> 01:05:08.640]  Ну, PLR методом пристального взгляда можно понять, что за один мы не выведем.
[01:05:08.640 --> 01:05:18.640]  Выводили ли мы PLR? Выводили. И выводили мы его за два.
[01:05:18.640 --> 01:05:28.640]  Так как мы помним, что за один методом пристального взгляда мы доказали, что не выведем, смогли за два, значит пишем два.
[01:05:28.640 --> 01:05:47.640]  Теперь P. Ну, как нам P? П у нас есть вариант вывести за сколько? За...
[01:05:47.640 --> 01:05:58.640]  Можем ли мы вывести? Мы можем вывести здесь за четыре. Четыре уже очень плохое число. Обычно будет один, два, три.
[01:05:58.640 --> 01:06:11.640]  Но кто знает, может в этом году поменять и сделать четыре. Пытаемся просто, если у нас четыре, придумать, можно ли вывести это за три.
[01:06:11.640 --> 01:06:22.640]  То есть, недостаток этого дерева в чем? Что у нас на каждом пути у нас только один треугольничек, только один вывод.
[01:06:22.640 --> 01:06:36.640]  Можем ли мы сделать так, что это будет вида жух, дерево жух, жух, жух, жух. Да, как-то сбалансировать его.
[01:06:36.640 --> 01:06:42.640]  Ну, давайте смотреть. P мы можем вывести по P или не R, или так.
[01:06:47.640 --> 01:06:52.640]  P или R мы можем вывести за две. Можем ли мы вывести P или не R?
[01:06:52.640 --> 01:07:10.640]  Можем. Как это сделать? Вот у нас вещь хорошая, я ее сохраняю. Копировать, ставить.
[01:07:10.640 --> 01:07:17.640]  Теперь мы хотим получить P или не R. Понятно, что чтобы получить P или не R мы хотим задействовать как тут эту штуку.
[01:07:17.640 --> 01:07:24.640]  Чтобы вывести нам теперь что нужно? Нам нужно либо не R и S, либо P и не S.
[01:07:24.640 --> 01:07:31.640]  Ой, либо не R и S, либо P и S. Но P и S мы можем вывести за два.
[01:07:31.640 --> 01:07:45.640]  Сейчас, сейчас, сейчас. P или S мы можем за один вывести, вот. Поэтому хорошо все.
[01:07:45.640 --> 01:08:13.640]  П или не R или не S, P или S, которые выводятся из P или не Q, Q или S, Q или S, P или S, жух P или не R, жух P.
[01:08:13.640 --> 01:08:21.640]  Ну видно, что глубина дерева три. То есть три полосочки у нас. Поэтому можем за три.
[01:08:21.640 --> 01:08:31.640]  Можем ли за два? Звучит как что-то Unreal. Мы только ко второму смогли получить.
[01:08:31.640 --> 01:08:46.640]  Штуки, которые двуместные изюмты, в котором один литерал будет ходить, одна переменная будет ходить как сама и как отрицание.
[01:08:46.640 --> 01:08:50.640]  В общем, как-то так.
[01:08:50.640 --> 01:09:04.640]  Насчет этого номера будем помечать его красным цветом. Почему красным цветом?
[01:09:04.640 --> 01:09:11.640]  Потому что для теста номера за 0.8 баллов он требует слишком много времени.
[01:09:11.640 --> 01:09:22.640]  И поэтому к нему советую переходить после остальных. Остальные будут проще.
[01:09:22.640 --> 01:09:27.640]  Можете еще раз, пожалуйста, объяснить четвертый пункт, почему нельзя вывести?
[01:09:27.640 --> 01:09:41.640]  Четвертый пункт? Смотри. Мы нашли, что формула, если мы вывели P и S, мы можем какие-то изюмты сразу вычиснуть в осмотрение, потому что они теперь верны всегда.
[01:09:41.640 --> 01:09:50.640]  И у нас осталось в итоге два изюмта, которые мы еще упростили. Это не Q или не R и Q или R.
[01:09:50.640 --> 01:10:00.640]  Тогда теперь они будут, например, выполняться на наборах 0.1 и 1.0.
[01:10:00.640 --> 01:10:10.640]  Любой новый изюмт каким свойством обладает, что если исходная верна, то и выведенный изюмт тоже будет верен.
[01:10:10.640 --> 01:10:16.640]  Поэтому если исходная формула была верна, а выведенный не верен, значит мы такой изюмт вывести не можем.
[01:10:16.640 --> 01:10:27.640]  Вот давай смотреть так. У меня есть вот здесь вот P1, значит у меня P равняется 1, значит этот верен, этот верен, этот верен.
[01:10:27.640 --> 01:10:34.640]  Но не тождественный лож, понятно, что мы его не сможем вывести, потому что нашли выполняющий набор.
[01:10:34.640 --> 01:10:43.640]  Теперь S у меня единица, поэтому я могу на этот забить. Я получил, что на самом деле из этой штуки выводится Q или не R.
[01:10:43.640 --> 01:10:51.640]  Но это же будет ложно, когда Q равняется 0, а R единица.
[01:10:51.640 --> 01:10:58.640]  А исходная формула будет верной, значит мы не сможем вывести к дизюмту.
[01:10:58.640 --> 01:11:12.640]  В общем, да. Дальше, вероятно, нам будет задача вот такая.
[01:11:12.640 --> 01:11:20.640]  Это адекватная теста задачи на подумать.
[01:11:20.640 --> 01:11:36.640]  У каждой попозициональной формулы есть эквалентный ядрик NAF.
[01:11:36.640 --> 01:11:41.640]  Ну да, это верно, потому что мы сами рассказали же алгоритм, как строить.
[01:11:41.640 --> 01:11:48.640]  Если применить правила резолюции к двум дизюмтам, то обязательно получится дизюмт из не более большего числа литералов,
[01:11:48.640 --> 01:11:52.640]  чем более длинным из исходным.
[01:11:52.640 --> 01:11:57.640]  Ну, мы помним наши правила про соотношение мощностей.
[01:11:57.640 --> 01:12:06.640]  У нас получаемый дизюмт это мощность A плюс мощность B,
[01:12:06.640 --> 01:12:16.640]  где то же самое, что D1 плюс D2 минус 2.
[01:12:16.640 --> 01:12:25.640]  И у нас спрашивают, что если применить правила резолюции к двум дизюмтам,
[01:12:25.640 --> 01:12:30.640]  то обязательно получится дизюмт из не большего числа литералов, чем более длинным из исходным.
[01:12:30.640 --> 01:12:40.640]  Ну, это уже звучит очень странно, что сумма, которая почти 2, не должна превосходить максимум.
[01:12:40.640 --> 01:12:48.640]  Возьмем что-то похожее, типа 4, 4.
[01:12:48.640 --> 01:12:55.640]  Получим сумме D1, D2.
[01:12:55.640 --> 01:13:05.640]  4, 4. Получим сумме 8, минус 2, 6.
[01:13:05.640 --> 01:13:11.640]  Здесь будет 4. Ну, конечно же, это неверно.
[01:13:11.640 --> 01:13:17.640]  Такую штуку мы будем получать из двух, что из двух мы получим 2.
[01:13:17.640 --> 01:13:28.640]  Для всех больших, как мы помним, мы можем нагенерировать что-то большее.
[01:13:28.640 --> 01:13:36.640]  Но можем получить и меньше, потому что из трех и трех мы действительно можем получить 3.
[01:13:36.640 --> 01:13:46.640]  Вот здесь оценка.
[01:13:46.640 --> 01:13:54.640]  Да, на самом деле здесь не равно, потому что могут совпадать.
[01:13:54.640 --> 01:14:04.640]  А мы смотрим на различные, нас интересует количество литералов различных.
[01:14:04.640 --> 01:14:14.640]  Чуть модифицируем наше определение.
[01:14:14.640 --> 01:14:24.640]  Поэтому 3 сделается, да, тут будет 3, не больше.
[01:14:24.640 --> 01:14:34.640]  Вот. Если phi является тавтологией, то не phi, можно проверить методом резолюции.
[01:14:34.640 --> 01:14:40.640]  Но если phi – тавтология, то не phi, это противоречие.
[01:14:40.640 --> 01:14:50.640]  А если не phi – противоречие, то мы по теореме о полноте выведем обязательно пустой тезюм.
[01:14:50.640 --> 01:14:58.640]  Значит, сможем действительно провернуть.
[01:14:58.640 --> 01:15:04.640]  Это стандартное зачеркивание.
[01:15:04.640 --> 01:15:14.640]  Если из КНФ можно методом резолюции вывести ровно один литерал с каждой переменной, то у этой КНФ ровно один наполняющий набор.
[01:15:14.640 --> 01:15:24.640]  Сейчас еще раз почитаю. Если из КНФ можно методом резолюции вывести ровно один литерал с каждой переменной, то у...
[01:15:24.640 --> 01:15:32.640]  Давайте, какие предположения?
[01:15:44.640 --> 01:15:46.640]  Это хороший уже вопрос.
[01:15:46.640 --> 01:15:48.640]  Вроде верно.
[01:15:48.640 --> 01:15:50.640]  Да, это действительно верно.
[01:15:50.640 --> 01:15:56.640]  Потому что, чтобы получить пустой тезюм...
[01:15:56.640 --> 01:16:08.640]  Ну, то есть, опять же, вспомним оценку, что это мощность D1 плюс мощность D2 минус 2 должна равняться 0.
[01:16:08.640 --> 01:16:16.640]  Ну, то есть, D1 плюс D2 равняется 2.
[01:16:16.640 --> 01:16:24.640]  Причем мы знаем оценку на каждый из них, что D1 у нас будет равен единице.
[01:16:24.640 --> 01:16:26.640]  Почему будет хотя бы единица?
[01:16:26.640 --> 01:16:30.640]  Потому что если какой-то из них ноль, то мы, значит, уже раньше вывели.
[01:16:30.640 --> 01:16:36.640]  И смотреть на это нам не имеет смысла вводить еще раз с пустого тезюма что-то новое.
[01:16:36.640 --> 01:16:42.640]  Но это кажется, что может быть неправда, если мы вывели, допустим, пусть и все переменные,
[01:16:42.640 --> 01:16:46.640]  мы можем еще какое-нибудь противоречие получить после этого.
[01:16:46.640 --> 01:16:58.640]  Ну, смотри, вот я как раз сейчас и говорю про это, что чтобы получить противоречие нам нужно два дезюмта, которые будут одноместными.
[01:16:58.640 --> 01:17:00.640]  А как нам...
[01:17:00.640 --> 01:17:02.640]  Дезюмты?
[01:17:02.640 --> 01:17:04.640]  Да.
[01:17:04.640 --> 01:17:08.640]  Ну, я всегда обозначаю D это дезюмт.
[01:17:08.640 --> 01:17:20.640]  Вот. Мы знаем такую оценку, потому что если оно будет равняться нулю, то мы уже вывели это пустой дезюмт, и не имеет смысла теперь смотреть.
[01:17:20.640 --> 01:17:22.640]  Значит, они хотя бы единицы.
[01:17:22.640 --> 01:17:34.640]  Если они хотя бы единицы, то здесь единственное решение имеет такое уравнение, что D1 равняется D2 равняется единице.
[01:17:34.640 --> 01:17:40.640]  Откуда взялась эта сумма 2?
[01:17:40.640 --> 01:18:00.640]  Ну, еще раз, у нас была оценка, что у нас был дезюмт 1, дезюмт 2, по методу резолюции мы получаем не больше, чем вот такая штука.
[01:18:00.640 --> 01:18:02.640]  Да.
[01:18:02.640 --> 01:18:12.640]  Хотим мы получить пустой дезюмт, то есть вот эта штука должна равняться нулю.
[01:18:12.640 --> 01:18:18.640]  Мы смотрим сейчас на максимум, поэтому забираем на знак меньше равно.
[01:18:18.640 --> 01:18:22.640]  Дальше мы знаем ограничение, что...
[01:18:22.640 --> 01:18:30.640]  что каждая из дайотов это хотя бы единица, только переносим вправо, значит получаем, что сумма этих должна быть 2.
[01:18:30.640 --> 01:18:44.640]  Откуда мы получаем, что это все должно быть в равенстве с единицей?
[01:18:52.640 --> 01:19:02.640]  А раз это в равенстве с единицей, то каждая из дезюмтов это какая-то переменная.
[01:19:02.640 --> 01:19:16.640]  Причем у нас было правило в методе резолюции, что мы можем провести резолюцию тогда и только тогда, когда в одном дезюмте есть переменная, а во втором есть ее отрицание.
[01:19:16.640 --> 01:19:24.640]  Вообще у нас же неравенство есть, что у нас из D1 до D2 появится что-то, что не больше, чем вот модуль D1 плюс модуль D2.
[01:19:24.640 --> 01:19:30.640]  Ну хорошо, давай, если формально рассмотрим.
[01:19:30.640 --> 01:19:33.640]  Это не важно, суть не в этом.
[01:19:33.640 --> 01:19:37.640]  Должно быть вот так.
[01:19:37.640 --> 01:19:41.640]  Вот так.
[01:19:41.640 --> 01:19:45.640]  Сейчас AD с волной это что?
[01:19:45.640 --> 01:19:55.640]  Это новый дезюмт получаемый D1 или D2.
[01:19:55.640 --> 01:20:02.640]  Вот так.
[01:20:02.640 --> 01:20:09.640]  Даже не так, ну короче, это метод резолюции получаемый.
[01:20:09.640 --> 01:20:18.640]  Вот.
[01:20:18.640 --> 01:20:23.640]  И поэтому, ну окей, 0 поставим выше, больше равно ну.
[01:20:23.640 --> 01:20:26.640]  D1 или D2 станет не превосходить двойки.
[01:20:26.640 --> 01:20:31.640]  Ну не превосходите каждый больше 1, опять же решение только одно, это единственное.
[01:20:31.640 --> 01:20:35.640]  Почему мы можем написать, что 0 больше правильного, чем вот это?
[01:20:35.640 --> 01:20:37.640]  Мы же нашли другую сторону неравенства.
[01:20:37.640 --> 01:20:39.640]  Какую?
[01:20:39.640 --> 01:20:46.640]  Ну, что модуль D с волной больше равен 0.
[01:20:46.640 --> 01:20:52.640]  Если модуль D больше равен 0, то мы можем получить модуль D, который будет 1.
[01:20:52.640 --> 01:20:55.640]  А модуль D равный 1 нам не нужен.
[01:20:55.640 --> 01:21:00.640]  Нам нужно именно, чтобы модуль D был не больше 0, равен 0.
[01:21:00.640 --> 01:21:03.640]  То есть.
[01:21:03.640 --> 01:21:06.640]  Равен 0 это то же самое, что не больше 0.
[01:21:06.640 --> 01:21:08.640]  А больше 0 мы получаем.
[01:21:08.640 --> 01:21:11.640]  Хорошо, модуль D с волной равен 0.
[01:21:11.640 --> 01:21:14.640]  Но из этого следует, мне нравится как раз другую сторону, что 0 не больше, чем модуль D1,
[01:21:14.640 --> 01:21:19.640]  пришло модуль D2-2.
[01:21:19.640 --> 01:21:22.640]  Нас интересует получение.
[01:21:22.640 --> 01:21:26.640]  Ну хорошо, допустим, ты получишь из этого что-то большее.
[01:21:26.640 --> 01:21:29.640]  Это будет после дезюмта? Нет.
[01:21:29.640 --> 01:21:33.640]  Нам нужно именно, чтобы достигалось это.
[01:21:33.640 --> 01:21:36.640]  Нам все, что больше, нас не интересует.
[01:21:36.640 --> 01:21:38.640]  Но, в принципе, это просто оценка.
[01:21:38.640 --> 01:21:41.640]  Значит, она же может быть сильно больше, чем 0.
[01:21:41.640 --> 01:21:42.640]  Может.
[01:21:42.640 --> 01:21:43.640]  Да.
[01:21:43.640 --> 01:21:47.640]  А теперь мы говорим, в каких случаях она достигается?
[01:21:47.640 --> 01:21:57.640]  Достижение этой оценки возможно только в том случае, когда оба этих D1 и D2 равняются 1.
[01:21:57.640 --> 01:22:03.640]  Ну хорошо, ты можешь, давай прям совсем, как ты хочешь, 0.
[01:22:03.640 --> 01:22:05.640]  Все, что больше, нас не интересует.
[01:22:05.640 --> 01:22:07.640]  Зачем нам это?
[01:22:07.640 --> 01:22:09.640]  Мы хотим, когда достижение.
[01:22:09.640 --> 01:22:11.640]  Ну почему у нас противорей?
[01:22:11.640 --> 01:22:12.640]  Сейчас.
[01:22:12.640 --> 01:22:14.640]  На самом деле, это неважно.
[01:22:14.640 --> 01:22:19.640]  Мы же можем просто, когда угодно, вывести P и вывести не P.
[01:22:19.640 --> 01:22:26.640]  Ну вот я и говорю, что чтобы вывести пустой дезюмп, нам понадобится переменная и ее отрицание.
[01:22:26.640 --> 01:22:27.640]  Да.
[01:22:27.640 --> 01:22:28.640]  Никак по-другому мы не можем.
[01:22:28.640 --> 01:22:30.640]  Вот мы формально обосновали.
[01:22:30.640 --> 01:22:33.640]  А у нас здесь сказано, что ровно один литерал с каждой письменой.
[01:22:33.640 --> 01:22:35.640]  А, на первом один сказано?
[01:22:35.640 --> 01:22:36.640]  Да.
[01:22:36.640 --> 01:22:38.640]  А, все, сори, окей.
[01:22:41.640 --> 01:22:46.640]  То есть глобально нам просто не хватит литералов, чтобы вывести противоречие.
[01:22:46.640 --> 01:22:49.640]  Значит, есть хотя бы один выполняющий набор.
[01:22:53.640 --> 01:22:54.640]  Вот.
[01:22:54.640 --> 01:22:56.640]  И теперь...
[01:23:10.640 --> 01:23:11.640]  Пауэром.
[01:23:13.640 --> 01:23:16.640]  Давайте я еще раз проверю, какие задачи удаются.
[01:23:20.640 --> 01:23:22.640]  Поверка на выполнимость.
[01:23:23.640 --> 01:23:24.640]  Ну да.
[01:23:26.640 --> 01:23:27.640]  Вот 33.
[01:23:27.640 --> 01:23:29.640]  Проверка на выполнимость.
[01:23:29.640 --> 01:23:33.640]  То есть просто делаем метод резолюции.
[01:23:34.640 --> 01:23:38.640]  Как правило, это все заканчивается просто...
[01:23:40.640 --> 01:23:43.640]  ...выводом пустого дезюмпа, этот номер.
[01:23:50.640 --> 01:23:51.640]  Ну что делаем?
[01:23:51.640 --> 01:23:53.640]  У нас выписываем дезюмпты.
[01:23:54.640 --> 01:23:59.640]  И здесь вообще самый простой способ как это решать.
[01:23:59.640 --> 01:24:05.640]  Я все-таки предпочитаю не дерево здесь, а вот такую штуку.
[01:24:06.640 --> 01:24:08.640]  Что-то типа а-ля явный вывод.
[01:24:11.640 --> 01:24:15.640]  34рс не п или р или с.
[01:24:15.640 --> 01:24:20.640]  5рс не п или не р или с.
[01:24:23.640 --> 01:24:26.640]  6рс не п или не с.
[01:24:29.640 --> 01:24:32.640]  7рс не п или не с.
[01:24:35.640 --> 01:24:38.640]  Ну и начинаем творить чудо.
[01:24:38.640 --> 01:24:42.640]  8рс не р или с.
[01:24:42.640 --> 01:24:59.080]  не r или s выведется q или не r, дальше 9 p или r, q или не r выводится p или q.
[01:25:00.440 --> 01:25:05.880]  Не нужно пока искать какой-то смысл, как я ищу последующие, просто
[01:25:05.880 --> 01:25:11.440]  абсолютно тупо, влом, перебираю всевозможные варианты, возможно что-то хорошее
[01:25:11.440 --> 01:25:14.280]  выведется. Все очень просто.
[01:25:14.280 --> 01:25:21.120]  Не r или s выводится p или s.
[01:25:21.120 --> 01:25:30.400]  Прикольное. Все прикольное закончилось, начинаю применять
[01:25:30.400 --> 01:25:33.320]  двуместный, трехместный, чтобы получить двуместный.
[01:25:33.320 --> 01:25:43.160]  11 жух, p или s, не p или r или s, выводится r или s.
[01:25:43.160 --> 01:25:48.840]  Супер. 12 не r или s, r или s вывел s.
[01:25:48.840 --> 01:25:55.400]  У меня теперь 13, q или не s, s вывел q.
[01:25:55.400 --> 01:26:00.760]  Шестерку могу теперь убрать.
[01:26:00.760 --> 01:26:14.720]  Не q или r или не s, с s вывожу не q или r.
[01:26:14.720 --> 01:26:19.640]  15 не q или r, q вывожу r.
[01:26:19.640 --> 01:26:34.120]  О, 5. Это у меня что, p или не q или не r, r вывожу p или не q.
[01:26:34.120 --> 01:26:43.240]  17, p или не q, q вывожу p. Теперь смотрю, могу ли я вывести
[01:26:43.240 --> 01:26:46.240]  противоречие всего этого добра. То есть я получил что?
[01:26:46.240 --> 01:26:56.640]  Такое нехорошо. Давайте, вот так вот, жух, p получил, r получил, вот так вот.
[01:26:56.640 --> 01:27:03.440]  Это можно, как только получили четыре переменных, проверяем просто на выполнимость
[01:27:03.440 --> 01:27:11.400]  каждой дизюнт. p или r, плюсик, q или s, плюсик, плюсик, плюсик, плюсик, плюсик, минусик.
[01:27:11.400 --> 01:27:17.720]  Все, получили минусик, значит из него просто начинаем вводить пустой дизюнт.
[01:27:17.720 --> 01:27:32.320]  Все, 18 не p, там что? Не q, не s. Не p или не q или не s. У меня есть p вывел не q или не s.
[01:27:32.320 --> 01:27:43.360]  19 не q или не s, есть q вывел не s. 20 не s, s вывел пустой дизюнт. Все.
[01:27:52.360 --> 01:27:58.400]  Глобально начинаем просто хаотично вводить все что можно, до тех пор пока не вывели все четыре
[01:27:58.400 --> 01:28:04.000]  переменных. Как только вывели все четыре переменных, проверили, что каждый из исходных
[01:28:04.000 --> 01:28:09.920]  дизюнтов выполняется. Если выполняется, значит вывели выполняющий набор, его записали в ответ.
[01:28:09.920 --> 01:28:17.800]  Если не выполняется, значит найдется какой-то дизюнт, в котором будет отрицание этого литерала.
[01:28:17.800 --> 01:28:24.400]  Ну тогда просто берем по методу резолюции нужное количество раз, убираем все до пустого.
[01:28:28.400 --> 01:28:40.400]  Вот эта задача халявная, ее делаем, лутаем один балл. 29, ну задача средняя,
[01:28:40.400 --> 01:28:48.600]  может быть простой, может быть сложной, в зависимости от того, что дадут. Она желтенькая.
[01:28:48.600 --> 01:28:57.160]  30 точно красная, для теста задачи слишком много гемора. И осталась задача 32.
[01:28:57.160 --> 01:29:12.320]  Так, еще раз посмотреть, что там за задача. 30. РК-состояние значит выполнимость. Да.
[01:29:12.320 --> 01:29:22.000]  Про вводимость говорили в прошлый раз, можете еще раз посмотреть, свяжите память.
[01:29:22.000 --> 01:29:34.800]  Теперь от нас хотят формулу. На самом деле странно, что дают задачу про логику первого порядка,
[01:29:34.800 --> 01:29:45.520]  не проходя логику первого порядка глобально. А пишите формулу выполнимость, которая коллективна,
[01:29:45.520 --> 01:29:50.080]  потому что у каждой исходной формулы есть хотя бы два выполняющих набора. То есть нужно
[01:29:50.080 --> 01:29:56.600]  написать преобразование, которое каждую формулу phi превращает в psi. Так что если есть и в phi два
[01:29:56.600 --> 01:30:05.200]  различных набора, то psi выполнимо. Если у phi есть один выполняющий набор или phi не выполнимо, то phi выполнимо.
[01:30:05.200 --> 01:30:34.160]  А теперь, я извиняюсь, сейчас один момент и зайду. Я вас удивлю, а именно вот то, что я
[01:30:34.160 --> 01:30:42.520]  сейчас давал, мы это рассматривать не будем. И объясню почему. Потому что реальная задача будет
[01:30:42.520 --> 01:30:57.080]  несколько иначе сформулирована, чем то, что вы видели до этого. 7 и 5 на резолюции. Так запускаю демонстрацию экрана.
[01:30:57.080 --> 01:31:14.840]  Да, возвращаю сюда. Вот на этом забиваем. И в реальности задача будет выглядеть так. Вот как-то так. Думаю,
[01:31:14.840 --> 01:31:21.400]  объем уже должен был удивить. Итак, задача будет такая, как очень любят давать что-то
[01:31:21.400 --> 01:31:28.040]  связанное с графами. У вас изначально будет задан граф матрицей смертностями, то есть набор
[01:31:28.040 --> 01:31:39.520]  переменных ПОВ. И вашей задачей нужно будет сгенерировать формулу из этого всего под данным
[01:31:39.520 --> 01:31:45.080]  переменным. Не так, что вот это чудо какое-то приведите к преобразованию, а так что изначально
[01:31:45.080 --> 01:31:54.120]  даны переменные и на основе их нужно построить. У нас здесь какие переменные, что есть? Матрица
[01:31:54.120 --> 01:32:07.200]  смертности, то есть мы как-то закодировали ребра. И есть РУ. Переменные, которые обозначают
[01:32:07.200 --> 01:32:12.360]  принадлежность вот ядру. В прошлом году было, по-моему, задача что-то там про клику.
[01:32:12.360 --> 01:32:23.200]  Или в позапросто. Как решать задачу? Сначала мы начинаем просто записывать на языке кванторов
[01:32:23.200 --> 01:32:47.400]  обычные формулы, как на мотоне эту штуку. Ну давайте думать. Ну нам нужно что? Нам нужно
[01:32:47.480 --> 01:32:57.240]  ядро. То есть множество. Берем записку. Требуется установить, что существует ядро. Существует ка.
[01:32:57.240 --> 01:33:07.200]  Прямо вот заберем записку. Существует такое ка, что между любыми, что между вершинами из ка
[01:33:07.200 --> 01:33:20.440]  нету ребер. Это первое существо. Для любых в1 и в2, но я не хочу долбиться с индексами,
[01:33:20.440 --> 01:33:38.040]  поэтому для любых в1, ой, в и в из в выполняется, что в и в не принадлежит е. То есть нету ребра
[01:33:38.040 --> 01:33:57.360]  между в и w. У вас рассказывали про то, что такой граф? Ну не знаю, у нас просто не рассказывали.
[01:33:57.360 --> 01:34:15.960]  Граф это пара из множества v и e, где e это некоторое под множество v2. То есть на самом деле граф
[01:34:15.960 --> 01:34:22.840]  это некоторое множество и дальше под множество v2. Это множество, это множество вершин, а под множество
[01:34:22.840 --> 01:34:35.600]  квадрата это множество ребер. Все. Причем это даже знаете, это своего рода ориентированный граф,
[01:34:35.600 --> 01:34:46.000]  не ориентированный. Это c из v2. Просто множество двух сочетаний, но как мы понимаем, определение
[01:34:46.000 --> 01:35:01.760]  два сочетания это двумястное под множество. Ладно, ставим. Хорошо. Этому потребуется, что нет ребра.
[01:35:01.760 --> 01:35:22.220]  А любая вершина, а это союз объединяющий. То есть ставим конъюнцию. И любая вершина из vsk для
[01:35:22.220 --> 01:35:37.820]  любой у принадлежащей vsk соединена с ребром, с одной из вершин v. То есть существует вершина vsk такая,
[01:35:37.820 --> 01:35:56.300]  что uv принадлежит, смотрим внимательно, неориентированный граф, поэтому достаточно написать uv. Если бы был
[01:35:56.300 --> 01:36:10.300]  граф ориентирован, то uv и vu разные, разные ребра, они по-разному идут. Поэтому если будет ориентированный,
[01:36:10.300 --> 01:36:22.260]  смотрим обязательно на то, какое именно ребро нам нужно. Хорошо. И все. Вот мы записали, по сути,
[01:36:22.260 --> 01:36:45.940]  условия. Сейчас. Любая вершина из этого. Сейчас еще раз давайте. Вот. С одной вершиной. Здесь еще
[01:36:45.940 --> 01:36:56.900]  важное условие, что если бы было с хотя бы одной, то вот это условие видно, а тут с одной. Значит,
[01:36:56.900 --> 01:37:06.260]  нужно существует и единственное. Теперь давайте, как мы будем это все раскрывать. Для этого нужно
[01:37:06.260 --> 01:37:16.580]  углубиться в семантику кванторов. Оставим до следующего раза, пока просто поверим на слово,
[01:37:16.580 --> 01:37:34.020]  что существует эта дизъюнция по каким-то там йод. Для любого это конъюнция. Ну то есть действительно,
[01:37:34.020 --> 01:37:39.580]  что если существует, значит где-то один раз должна быть выполнена и все верно. Это дизъюнция.
[01:37:39.580 --> 01:37:53.700]  А для любого, значит, должна быть выполнена всегда. Это конъюнция. Вот. Ну, существует k,
[01:37:53.700 --> 01:38:01.140]  можем забить. У нас здесь не просят. Значит, теперь нам нужно будет упрощать как-то для любого vk,
[01:38:01.140 --> 01:38:15.780]  и вот это. Существует k. На что нам нужно будет, во-первых, убрать принадлежит к. Для любых v,
[01:38:15.780 --> 01:38:32.300]  для любых v2 переходим к принадлежащим v. Заданное множество v это сам граф. Выполняется,
[01:38:32.300 --> 01:38:50.060]  что если они принадлежат к, то это верно. Мы же говорим, что принадлежит к, а принадлежит к у нас
[01:38:50.060 --> 01:39:08.540]  это переменная ru. Если rv и rw, то тогда между ними нет ребра. Наличие ребра отвечает переменной uw.
[01:39:08.540 --> 01:39:32.060]  То есть нет ребра uw. Хорошо. Супер. Следующим этапом надо как-то отойти от разницы множества.
[01:39:32.060 --> 01:39:40.540]  Что значит, что u принадлежит v без k? Это значит, что u принадлежит v и при этом u не лежит в k.
[01:39:40.540 --> 01:40:06.140]  И для любой u принадлежащим v, что выполняется, что из того, что не ru, то есть если она не лежит,
[01:40:06.140 --> 01:40:20.540]  то существует единственная v из k. Такая, что у нас в верхней коричневой строчке не должно быть не uww.
[01:40:20.540 --> 01:40:31.020]  Должно быть. Спасибо. Да, все верно. Хорошо. И теперь самое сложное, что есть в этой задаче,
[01:40:31.020 --> 01:40:40.140]  это вот это вот кванторсуществование. Что значит кванторсуществование? Кванторсуществование.
[01:40:40.140 --> 01:40:52.180]  Вообще, по-хорошему, кванторсуществование, что если он существует, единственное x такое,
[01:40:52.180 --> 01:41:00.100]  что, знаете, phi от x. Defi какая-то формула. Хотя на самом деле мы даже не знаем, что такое формула.
[01:41:00.100 --> 01:41:20.180]  Эта штука раскрывается как то, что существует x и для любого y выполняется, что phi от x и
[01:41:20.180 --> 01:41:42.860]  из того, что x не равняется y, следует, что не phi от y. Но есть одно но. Вот эта вот штучка не равно.
[01:41:42.860 --> 01:41:53.300]  Что такое не равно? Ну, можно сказать, что это отрицание x равняется y. Но мы все равно сохраняем
[01:41:53.300 --> 01:42:05.340]  вопрос, а что такое равно? У нас нигде в номере не задано равенство. То есть мы не можем им пользоваться.
[01:42:05.340 --> 01:42:13.220]  Значит, мы должны как-то это равенство выразить через то, что нам даны. В частности, нам сказано,
[01:42:13.220 --> 01:42:31.060]  что... что... граф без петель... сейчас скажу...
[01:42:31.060 --> 01:42:44.060]  Сейчас я подумаю и скажу вам...
[01:42:44.060 --> 01:43:13.580]  Что если есть... у нас есть штука. Ну, давайте. Это существует ребро. Хорошо. Это... что если...
[01:43:13.580 --> 01:43:21.780]  Сейчас я подумаю и скажу. Это через петлю надо сделать.
[01:43:21.780 --> 01:43:42.220]  Вот я придумал. Как нам сделать неравенство? Неравенство мы можем сделать следующим образом.
[01:43:42.780 --> 01:43:49.180]  Существует x. Это они принадлежат какому-то множеству. То есть существует x принадлежит множеству.
[01:43:49.180 --> 01:43:59.580]  Давайте я его назову m. Для любого y принадлежит m. Выполняется вот это все. Как нам избавиться от равенства?
[01:43:59.580 --> 01:44:11.020]  Давайте ему просто сразу скажем откуда y. Для любого y без x. У нас же x уже... мы знаем,
[01:44:11.020 --> 01:44:19.260]  что это такое. Ну, все. Значит, мы можем это сделать. Тогда выполняется, что fiat x и не fiat y.
[01:44:29.060 --> 01:44:38.220]  Супер. Тогда давайте вот при помощи этого продолжим упрощать вот это v и так далее.
[01:44:38.220 --> 01:44:50.420]  Пока квантеры не снимаем. Сейчас позже будет понятно зачем мы все еще тянем с собой.
[01:44:50.420 --> 01:44:57.940]  Вот эту штуку нам нужно будет заменить. А именно существует единственный. Мы заменяем как на...
[01:44:57.940 --> 01:45:14.780]  Существует v принадлежащий v. Что для любого w принадлежащего v без v выполняется...
[01:45:14.780 --> 01:45:35.700]  выполняется что? Выполняется, что если не ro у нережит множество k, то должно выполниться, что
[01:45:35.700 --> 01:45:49.220]  r, v должно лежать в множестве k.
[01:46:05.700 --> 01:46:25.580]  Что если r, v режет r, v, k и r, v... Ну да, то есть мы сказали, что они оба неравны, при этом лежат в нем.
[01:46:25.580 --> 01:46:41.420]  То должно быть выполнено первое, что есть ребро между p, u, v и нет ребра между p, u, w.
[01:46:41.420 --> 01:46:46.100]  На самом деле можно даже упростить до следующего момента.
[01:46:46.100 --> 01:47:02.380]  Вот так вот. Вот давайте еще раз проверим, что для любого u, для любого v существует v такое, что не оно.
[01:47:02.380 --> 01:47:16.860]  Но, что если u это k, эти тоже k, то тогда будет существовать ребро между u и v, но не будет существовать между u и w.
[01:47:16.860 --> 01:47:26.940]  Все хорошо. А теперь мы просто начинаем вот этот вот квантор существования заменять на конъюнцию и дизюнцию.
[01:47:26.940 --> 01:47:30.900]  Как мы его заменяем? Здесь нужно сказать немножко поточнее.
[01:47:30.900 --> 01:47:40.300]  Существует... Можете, пожалуйста, еще раз пояснить последнее, что у вас получилось, что мы должны садусти?
[01:47:40.300 --> 01:47:51.700]  А, сейчас я иду. Это вот чуть поподробнее, что это такое. Последнее, что у нас получилось.
[01:47:51.700 --> 01:47:56.380]  Первые условия мы просто сохранили. Здесь все понятно.
[01:47:56.380 --> 01:48:04.900]  Это просто условие на то, что между двумя вершинами, если они обе из k, то между ними нет вершин.
[01:48:04.900 --> 01:48:10.420]  Ой, нету ребра. А вот нижнее самое. А нижнее. А теперь нижнее.
[01:48:10.420 --> 01:48:19.700]  Первое, что мы говорим, что для любой вершины v найдется такая вершина v, что для любой вершины v неравной вершине...
[01:48:19.700 --> 01:48:29.700]  Дайте, я просто буду продолжать. Для любой вершины u существует вершина v, да простите, да простят мой немецкий,
[01:48:29.700 --> 01:48:41.940]  что для любой вершины v неравной вершине v выполняется, что если ru это не из множества k,
[01:48:41.940 --> 01:49:02.020]  то эти две из множества k, помните вот эти вот, принадлежит где у нас, вот, то дальше выполняется это условие,
[01:49:02.020 --> 01:49:09.380]  которое мы записали уже теперь чисто через переменные r и p. Глобально же, вот это что такое?
[01:49:09.620 --> 01:49:17.700]  Это что для любой лежащей, а для любой лежащей ничего не понятно. Значит, мы просто возьмем, скажем, что вот если так, то то,
[01:49:17.700 --> 01:49:27.460]  а дальше, ну, все что угодно условие не запрещает. Поэтому это превращается в импликацию. Все.
[01:49:27.460 --> 01:49:39.300]  А теперь мы просто пользуемся вот этим вот свойством, что существует x принадлежит a, это то же самое, что для любого x есть a.
[01:49:39.940 --> 01:49:47.700]  Ой, дизюнция по x принадлежащим a. Для любого x принадлежащего a, это есть конъюнция по всем x из a.
[01:49:50.020 --> 01:49:59.460]  Это важно помнить. И важно помнить что? Что вот эти вот все дизюнции, конъюнции, которые мы в конце будем раскрывать,
[01:50:00.740 --> 01:50:08.100]  большие формулы, должны обладать следующим свойством, что можно их проводить только по заданным множествам.
[01:50:08.900 --> 01:50:15.940]  У нас заданном множество только одно g, это v и e. То есть мы можем брать конъюнции только по g, только по v, только по e.
[01:50:17.940 --> 01:50:26.900]  Раз. И два, у нас было, было по-моему, будет еще требование, что это полинамиальное число. То есть можно
[01:50:26.900 --> 01:50:33.540]  проводить сколь угодно конечное число вот таких вот конъюнций-дизюнций по заданным множествам.
[01:50:34.500 --> 01:50:41.060]  Уходить в экспоненту то есть перебирать по всем под множеством. Вот самое реальное, где можно
[01:50:41.060 --> 01:50:48.180]  нарушить Полином, это начать перебирать все под множество. Это нельзя делать. Нельзя делать
[01:50:50.260 --> 01:50:54.340]  x под множество. По всем множеству x под множеством множественного v.
[01:50:56.180 --> 01:51:01.060]  Это экспонента. Почему экспонента? Потому что всего под множеством это два степени v.
[01:51:01.060 --> 01:51:10.840]  Видим сразу экспонент. Только явно по одному множеству итерируемся. Сколько угодно
[01:51:10.840 --> 01:51:19.200]  раз. Никто вас не запрещает. Все. Последний этап. Этап замены. У нас везде допустимое
[01:51:19.200 --> 01:51:28.760]  множество. В, В, В. Здесь тоже В. И причем мы итерируемся только по ним, как по
[01:51:28.760 --> 01:51:39.480]  элементам. Не по множеству. Заменяем. Конъюнция это что? Конъюнция это дезюнция.
[01:51:39.480 --> 01:51:57.240]  Конъюнция по В принадлежащим В большому. Когда через запятую понятно, что это для
[01:51:57.240 --> 01:52:20.600]  любого В, для любого В выполняется что из РВ и РВ следует не ПВВ. Глобально вот еще раз,
[01:52:20.600 --> 01:52:28.400]  если заметить закономерность в этих формулах. У нас в посылке идут ограничения на принадлежность
[01:52:28.400 --> 01:52:34.720]  нашему множеству, а дальше идут просто та формула. Раньше мы писали через существует К,
[01:52:34.720 --> 01:52:44.640]  теперь мы говорим что ну занесем принадлежность К в посылку в импликации. Точно так же здесь.
[01:52:44.640 --> 01:52:57.240]  Это первая формула. Дальше нам нужна конъюнция. И вторая у нас была вот. И вторая это что?
[01:52:57.240 --> 01:53:10.960]  Это большие конъюнции. То же самое что мы писали когда большие суммы, большие произведения,
[01:53:10.960 --> 01:53:19.960]  пересечения, объединения, дизью. Вот это вот все. Точно так же когда писали еще больше XOR.
[01:53:19.960 --> 01:53:47.960]  Точно так же это здесь. И у из В существует конъюнция ПВ. И теперь сама формула.
[01:53:47.960 --> 01:54:06.960]  Не РУ. На самом деле можно прям так дальше писать не захламляя скопками. Не РВ. Следует что ПУВ и не ПУВ.
[01:54:06.960 --> 01:54:30.640]  Все. Получили такую вот формулу. Эта формула будет ответом на задачу. На этом все. Если есть вопросы,
[01:54:30.640 --> 01:54:42.360]  задавайте. Решение прошлых лет постараюсь выложить побыстрее. Но не гарантирую,
[01:54:42.360 --> 01:55:01.040]  скорее всего будет понедельник. Ну а раз нет вопросов, задаю. Всем спасибо. Всем пока.
