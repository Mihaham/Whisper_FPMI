[00:00.000 --> 00:07.000]  Так, ну ладно, давайте начнём.
[00:07.000 --> 00:19.000]  Сегодня последняя лекция в курсе. Она посвящена лямбодисчислению и операциями с нумералами Чорча.
[00:20.000 --> 00:35.000]  Значит, я напомню, что такое нумералы Чорча.
[00:35.000 --> 00:45.000]  Значит, нумералы Чорча выглядят так. Есть для каждого натурального числа есть соответствующий нумерал, и они все выглядят примерно одинаково.
[00:45.000 --> 01:07.000]  Значит, ноль, подчёркнутое число – это нумерал. Нумерал 0 – это лямбда fx.x. Нумерал 1 – это лямбда fx.fx. Нумерал 2 – лямбда fx.f.
[01:07.000 --> 01:17.000]  Тут всегда хочется написать ещё одну скобку, так в принципе можно делать, но не нужно.
[01:17.000 --> 01:27.000]  Ну давайте, нумерал 3 – лямбда fx.f от f от fx. Ну и так далее.
[01:27.000 --> 01:43.000]  Значит, нумерал N – это лямбда fx.f от f от fx. Здесь f повторено N раз.
[01:43.000 --> 01:45.000]  Вот и так далее.
[01:45.000 --> 01:56.000]  А с чем смысл? Смысл в том, что нумерал – такая функция, которая переводит функцию f в N композицию функции f.
[01:56.000 --> 02:04.000]  А дальше стоит вопрос о выражении отличных функций.
[02:04.000 --> 02:28.000]  То есть в целом она, как говорят, комбинатор g представляет функцию g малая, которая получает k натуральных чисел и возвращает натуральное число.
[02:28.000 --> 02:46.000]  Если для любых N1 и так далее Nk, g дальше N1 и так далее Nk, это будет g от N1 и так далее Nk.
[02:46.000 --> 03:00.000]  То есть если записать сначала комбинатор, потом k нумералов, то полученный лямбда term будет равен нумералу для значения функции g.
[03:00.000 --> 03:08.000]  Причем можно расширить это определение и для случаев не всюду определенной функции g.
[03:08.000 --> 03:32.000]  Можно сказать, что если g от N1 и так далее Nk не определена, что тогда соответствующий комбинатор g, который приписан на N1 и так далее Nk, не должен иметь…
[03:32.000 --> 03:46.000]  не должен иметь нормальной формы.
[03:46.000 --> 04:07.000]  Соответственно, именно это определение дает альтернативное понятие вычислимости функции.
[04:07.000 --> 04:15.000]  Можно сказать, что функция вычислима, если она предстоит каким-то лямбда комбинаторам в этом смысле.
[04:15.000 --> 04:25.000]  И оказывается, что такое определение будет равносильно всем остальным определениям вычислимости, из которых главное для нас это определение через машину чьюринга.
[04:25.000 --> 04:39.000]  В одну сторону это не очень удивительно.
[04:39.000 --> 04:45.000]  Если нас не интересует эффективность, то вроде понятно, что…
[04:45.000 --> 05:01.000]  Да, тут именно нужное определение, что мы можем записать такой комбинатор, применять там все возможные преобразования и, соответственно, ждать, когда у нас появится нумерал.
[05:01.000 --> 05:10.000]  Тут нужно только сказать, что преобразование обратной метаредукции тоже будет вычислимым.
[05:10.000 --> 05:18.000]  В общем, тут есть технические сложности, но концептуальная идея простая, что у нас есть такое выражение, мы к нему применяем все возможные преобразования.
[05:18.000 --> 05:25.000]  Вот, и, соответственно…
[05:25.000 --> 05:34.000]  А, кстати, на самом деле можно еще доказать через черчеросыра, что если у нас какой-то терм равняется нормальной форме,
[05:34.000 --> 05:44.000]  то там в процессе этого равенства можно не использовать операции обратной метаредукции, а использовать только метаредукции альфа-конверсии.
[05:44.000 --> 05:55.000]  Вот, и тогда получается, что алгоритм будет таким, что мы напишем выражение, будем туда применять все возможные редукции конверсии и ждать, пока встретится нумерал.
[05:55.000 --> 05:59.000]  Значит, если встретился нумерал, то это и будет значением.
[05:59.000 --> 06:11.000]  Ну, а если процесс будет бесконечным, то тогда, соответственно, это все никогда не закончится, но так и должно быть, если функция не определена.
[06:11.000 --> 06:21.000]  Значит, это идея в одну сторону. Почему? Это то же самое, что вычислимость, что если это верно, то тогда функцию уже можно вычислить.
[06:21.000 --> 06:32.000]  Ну, а в другую сторону, что если функцию уже можно вычислить, то это как раз если мы представим архиметические функции,
[06:32.000 --> 06:43.000]  то тогда мы сможем все вычислимые сделать, потому что через архиметические можно выражать строковые, через строковые работы машины тюринга,
[06:43.000 --> 06:53.000]  и тогда получается, что мы любую машину смоделируем. Так что, в общем, в целом, видимо, понятно, что это то же самое, что вычислимость.
[06:53.000 --> 07:01.000]  Но сегодня возникает вопрос, а как, собственно, все это моделировать, то есть как выражать разного рода функции.
[07:01.000 --> 07:06.000]  Значит, последнее, что у нас было в прошлый раз, это прибавление единицы.
[07:06.000 --> 07:19.000]  Значит, комбинатор инкриментации, прибавление единицы, это было λnfx точка f от nfx.
[07:19.000 --> 07:33.000]  Ну и мы обсуждали, что вот это вот n делает n раз примененные в самом себе, а вот это вот f прибавляет еще одно, получается, что n плюс 1 как раз.
[07:33.000 --> 07:54.000]  Ну, аналогично можно сложение, ну а можно выражать вот так вот, да, написать просто lambdamn точка m,
[07:54.000 --> 08:06.000]  инкримент m. То есть, что, когда вы прибавите m, значит, m раз приводит единицу.
[08:06.000 --> 08:12.000]  Но вот такая запись на самом деле так и устроена, да, потому что когда мы...
[08:12.000 --> 08:17.000]  Ну давайте я покажу, почему это будет так.
[08:17.000 --> 08:27.000]  Потому что тогда add, а дальше mn, и это будет, соответственно, m inc n.
[08:27.000 --> 08:42.000]  Значит, а это будет, соответственно, λfx точка f от f и так далее, вот fx, inc n.
[08:42.000 --> 08:47.000]  А дальше, смотрите, помните, что вот это λfx, это сокращение от λf точка λx.
[08:47.000 --> 08:57.000]  Вот, ну сначала за счет λf, у меня inc сюда вместо f появится, а потом за счет λx, n, номерал, поставится вместо x.
[08:57.000 --> 09:09.000]  То есть, это будет, значит, increment от increment и так далее, значит, от increment m.
[09:09.000 --> 09:19.000]  Вот. Ну вот, получается, что мы m раз, m раз инкриментировали n, то есть, увеличили на единицу.
[09:19.000 --> 09:25.000]  Но это как раз и получится m+.
[09:25.000 --> 09:34.000]  Вот. Ну вот, это один подход, а можно прямой это написать.
[09:34.000 --> 09:45.000]  А так, значит, давайте я это другим цветом нарисую, в том смысле, что это будет не тот же самый, на самом деле, комбинатор, но выполняющий ту же функцию.
[09:45.000 --> 10:03.000]  Значит, можно альтернативно написать, что add, это будет λm nfx точка, значит, а тут будет mf от nfx.
[10:03.000 --> 10:12.000]  Ну и, соответственно, вот такая запись позволяет сразу вместо того, чтобы много раз инкриментировать,
[10:12.000 --> 10:21.000]  сразу написать m раз f, f от f от f, m раз, а потом еще туда поставить f от f от f, n раз.
[10:21.000 --> 10:27.000]  То есть, фактически тут будет вот такое равенство использоваться.
[10:27.000 --> 10:37.000]  Композиция m-той итерации на n-ту итерацию, это будет m плюс n-та итерация.
[10:37.000 --> 10:49.000]  Вот, значит, это вот сложение. Есть какие-нибудь вопросы.
[10:49.000 --> 11:04.000]  Так, значит, ну если сложение все понятно, то переходим к умножению.
[11:04.000 --> 11:08.000]  Ну опять же, умножение, в принципе, можно определять как итерированное сложение.
[11:08.000 --> 11:18.000]  Да, там, m раз, прибавлять n к нулю. Вот, но канонический способ это опять же действовать иначе.
[11:18.000 --> 11:32.000]  Написать вот так, вот, λm nfx точка m от nfx. Вот, обратите внимание на скобки.
[11:32.000 --> 11:37.000]  Да, что именно, именно nf взято в скобки.
[11:37.000 --> 11:49.000]  Соответственно, это построено на идее, что, значит, если мы n-ную итерацию возведем в m-тую степень,
[11:49.000 --> 12:18.000]  то будет f в степени n. Вот.
[12:18.000 --> 12:30.000]  Значит, ну, соответственно, можно немножко подробнее расписать.
[12:30.000 --> 12:39.000]  Значит, мульт mn. Значит, это вот, смотрите, когда мы m и n подставили, то вот эти λm и λn ушли, а fx остались.
[12:39.000 --> 12:50.000]  То есть будет λfx, а тут будет m от nf от x. Вот.
[12:50.000 --> 12:55.000]  Так, ну, собственно, можно после этого λfx за собой не таскать.
[12:55.000 --> 12:59.000]  Да, посмотреть на то, что после λ стоит.
[12:59.000 --> 13:04.000]  Значит, вот, значит, м от nfx.
[13:04.000 --> 13:10.000]  Так, и чтоб не путаться, давайте у m какие-нибудь другие.
[13:10.000 --> 13:15.000]  Значит, λdgy тоже будет g, aj и так далее.
[13:15.000 --> 13:22.000]  Вот gy.
[13:22.000 --> 13:25.000]  nfx.
[13:25.000 --> 13:31.000]  Ну и после этого получается, что мы подставляем.
[13:31.000 --> 13:41.000]  Значит, вот это вот nf. Подставляем сюда, вот сюда.
[13:41.000 --> 13:54.000]  А x подставляем, соответственно, вот сюда.
[13:54.000 --> 14:00.000]  Ну и после этого что же получится.
[14:00.000 --> 14:05.000]  Вот, ну, получится, что и должно быть.
[14:05.000 --> 14:10.000]  Значит, тут будет nf.
[14:10.000 --> 14:14.000]  nf и так далее.
[14:14.000 --> 14:23.000]  nfx.
[14:23.000 --> 14:35.000]  Ну и вот это вот фактически теперь получается прибавление m раз n самого к себе.
[14:35.000 --> 14:45.000]  То есть тут...
[14:45.000 --> 14:50.000]  Заметьте, что, в принципе, вот эти вот скобки, они не нужны по нашему соглашению.
[14:50.000 --> 14:54.000]  Вот.
[14:54.000 --> 15:02.000]  То есть тут, если опять же расписать...
[15:02.000 --> 15:08.000]  Давайте я вот это n теперь распишу.
[15:08.000 --> 15:13.000]  Вот тут будет λ, какой-нибудь еще, там hz.
[15:13.000 --> 15:24.000]  .h от h и так далее от hz.
[15:24.000 --> 15:31.000]  Так, дальше тут будет f.
[15:31.000 --> 15:35.000]  И дальше будет все остальное.
[15:35.000 --> 15:41.000]  Нф и так далее.
[15:41.000 --> 15:48.000]  Эти скобки по соглашению можно снять.
[15:48.000 --> 15:53.000]  Ну и теперь получается, что вот это вот f.
[15:53.000 --> 15:58.000]  Значит, вот это вот f будет подставляться вместо h.
[15:58.000 --> 16:01.000]  Сюда-всюду.
[16:01.000 --> 16:11.000]  А вот эта вот вся эта большая скобка подставится вместо z.
[16:11.000 --> 16:18.000]  Ну и тогда получается, что тут будет...
[16:18.000 --> 16:25.000]  Значит, тут будет f от f и так далее от f.
[16:25.000 --> 16:40.000]  А вот это вот по предложению индукции можно считать, что тут будет...
[16:40.000 --> 16:45.000]  Тут будет как бы m, m-1 на n.
[16:45.000 --> 16:50.000]  Значит, m-1 на n.
[16:50.000 --> 16:57.000]  fx.
[16:57.000 --> 17:02.000]  Так, в общем, закрываем.
[17:02.000 --> 17:10.000]  Ну и все вместе будет m на n, потому что здесь вот этих вот как раз будет m штук.
[17:10.000 --> 17:17.000]  Нет, n штук их будет.
[17:17.000 --> 17:21.000]  Да, они же вот отсюда брались.
[17:21.000 --> 17:24.000]  Значит, здесь n раз.
[17:24.000 --> 17:31.000]  И как раз, если мы n добавим вот сюда, то будет как раз mn, что не нужно.
[17:31.000 --> 17:34.000]  Так, ну что, пример понятно?
[17:34.000 --> 17:38.000]  В общем, основная суть вот в этом зеленом равенстве.
[17:38.000 --> 17:51.000]  А вот это уже подробный, аккуратный анализ, почему действительно именно так получится.
[17:51.000 --> 17:55.000]  Так, ну что, понятно?
[17:55.000 --> 17:59.000]  Дальше такими же элементарными методами...
[17:59.000 --> 18:05.000]  Таким же элементарными методами можно возведение в степень получить.
[18:05.000 --> 18:07.000]  Ну то есть как элементарными?
[18:07.000 --> 18:11.000]  Будет элементарная запись, но не совсем элементарным доказательством.
[18:11.000 --> 18:14.000]  Считаю, что я его пропущу, оно такое довольно громоздкое.
[18:14.000 --> 18:22.000]  И вообще поучительно, самостоятельно попробовать его провести.
[18:22.000 --> 18:30.000]  Во, значит, сейчас у меня все с большой буквы, так что давайте...
[18:30.000 --> 18:34.000]  Значит, экспонента имеется в виду от двух аргументов, где первый аргумент в степени,
[18:34.000 --> 18:37.000]  и второй аргумент.
[18:37.000 --> 18:45.000]  Так, тут будет лямбда mnfx.nmfx.
[18:45.000 --> 18:48.000]  То есть тут, в общем, имеется в виду следующее.
[18:48.000 --> 18:52.000]  Да, утверждается, что если мы подряд запишем...
[18:52.000 --> 18:56.000]  Так, ну это контактинация, да, ее вообще обычно...
[18:56.000 --> 19:01.000]  Давайте, чтобы не получилось с умножением, напишу вот так вот.
[19:01.000 --> 19:04.000]  Значит, если мы подряд запишем номерал n, а потом номерал m,
[19:04.000 --> 19:11.000]  то мы правой на самом деле возводим в степень левого.
[19:11.000 --> 19:15.000]  Вот.
[19:15.000 --> 19:20.000]  Но это пусть остается в качестве задачи такой.
[19:22.000 --> 19:27.000]  Значит, это вот задача.
[19:27.000 --> 19:34.000]  Ну, рекомендуется, скажем, 3 и 2 в разных порядках друг на друга поперемножать,
[19:34.000 --> 19:37.000]  посмотреть, что там получается.
[19:37.000 --> 19:42.000]  Ну и потом понять, как это в общем случае происходит.
[19:42.000 --> 19:49.000]  Так. Ну ладно, это вот то, что можно сделать элементарными методами.
[19:49.000 --> 19:53.000]  А дальше вообще в архиметике 4 действия основных.
[19:53.000 --> 19:57.000]  Кроме сложения и умножения, есть еще вычитание и деление.
[19:57.000 --> 20:02.000]  И для вычитания и деления нужны некоторые специальные ухищрения.
[20:02.000 --> 20:12.000]  Так, ну давайте посмотрим вычитание.
[20:12.000 --> 20:20.000]  Значит, ну на самом деле главное это получить вычитание единицы.
[20:20.000 --> 20:25.000]  А, ну вообще, прежде чем говорить про вычитание, нужно сказать, что мы имеем в виду.
[20:25.000 --> 20:31.000]  Потому что не всегда же можно вычесть натуральное число.
[20:31.000 --> 20:33.000]  Ну и можно это делать разными способами.
[20:33.000 --> 20:39.000]  То есть один способ, если уменьшаемое меньше вычитаемого, то не определено.
[20:39.000 --> 20:44.000]  Но мы не так будем делать.
[20:44.000 --> 20:53.000]  Значит, это у нас будет функция максимум из m-n и нуля.
[20:53.000 --> 21:00.000]  То есть это как бы срезка такая, что если результат меньше нуля, то мы возвращаем 0.
[21:01.000 --> 21:20.000]  Вот, и тогда ясно, что главное это определить вычитание единицы.
[21:20.000 --> 21:30.000]  Значит, то есть максимум из m-1 и 0.
[21:30.000 --> 21:37.000]  Ну, то есть, по общему говоря, это 0 остается нулем, а все остальное уменьшается на единицу.
[21:37.000 --> 21:44.000]  Вот, потому что тогда можно сделать так же, как мы делали с осложением в первом варианте.
[21:44.000 --> 21:54.000]  У осложений в первом варианте было m раз инкремент, а тут у нас будет n раз декремент.
[21:54.000 --> 22:04.000]  Да, потому что тогда получается, что subtract будет лямбда m-m.
[22:04.000 --> 22:13.000]  Если мы вот так вот именно из m вычитаем n, то нужно n раз применить декремент к m.
[22:13.000 --> 22:19.000]  То есть самое сложное, это вот взять декремент.
[22:19.000 --> 22:27.000]  Ну, оказывается, что это нельзя просто так взять и сделать, а нужна сначала некоторая специальная подготовка.
[22:27.000 --> 22:56.000]  Вот, и сначала придется, сначала освоим логические операции и операции с парами.
[22:56.000 --> 23:02.000]  Значит, что мы вообще хотим от логических операций?
[23:02.000 --> 23:06.000]  Ну, мы хотим какие-то логические константы, во-первых.
[23:06.000 --> 23:10.000]  Я понимаю, что все есть функции, а функции есть лямбда-комбинатор.
[23:10.000 --> 23:16.000]  То есть, логические константы это тоже какие-то такие функции, считаем, лямбда-комбинатора.
[23:16.000 --> 23:23.000]  Но нужно, чтобы были еще другие функции, которые вывели бы себя как логически обычные функции.
[23:23.000 --> 23:28.000]  И, соответственно, на этих логических константах работали как положено.
[23:28.000 --> 23:39.000]  То есть мы, например, хотим логические операции.
[23:39.000 --> 23:42.000]  Значит, мы, например, хотим константы.
[23:42.000 --> 23:48.000]  Значит, константа true и константа false.
[23:48.000 --> 23:52.000]  Вот, ну и, например, функция...
[23:52.000 --> 24:02.000]  Ну, например, такие, что and true true равняется true.
[24:02.000 --> 24:11.000]  Значит, там and true false равняется false.
[24:11.000 --> 24:19.000]  Значит, and false true равняется false.
[24:19.000 --> 24:30.000]  И and false false равняется false.
[24:30.000 --> 24:36.000]  Ну и аналогично для других.
[24:36.000 --> 24:52.000]  И для других логических функций аналогично.
[24:52.000 --> 25:01.000]  Вот.
[25:01.000 --> 25:04.000]  Хорошо.
[25:04.000 --> 25:08.000]  Значит, это то, что мы хотим.
[25:08.000 --> 25:10.000]  Теперь, как этого добиться?
[25:10.000 --> 25:14.000]  Значит, в принципе, возможно, разные ситуации, разные подходы.
[25:14.000 --> 25:16.000]  Так же, как и с номералами.
[25:16.000 --> 25:22.000]  Но я один удобный расскажу.
[25:22.000 --> 25:26.000]  Значит, удобно делать так.
[25:26.000 --> 25:31.000]  Вот, смотрите, false на самом деле будет равняться нулю просто.
[25:31.000 --> 25:34.000]  Значит, false равняется нулю.
[25:34.000 --> 25:39.000]  Но только я вот так вот запишу lambda.xy.y.
[25:39.000 --> 25:41.000]  И это же получается...
[25:41.000 --> 25:46.000]  Ну, как функция, это получается проекция на вторую координату.
[25:46.000 --> 25:57.000]  Значит, это проекция на вторую координату.
[25:57.000 --> 26:01.000]  Вот, а true...
[26:01.000 --> 26:09.000]  Так, ой, тут много черточек.
[26:09.000 --> 26:11.000]  Значит, true это номерал 1.
[26:11.000 --> 26:14.000]  Ой, нет, наоборот.
[26:14.000 --> 26:27.000]  Так, true, наоборот, не равняется номералу 1.
[26:27.000 --> 26:30.000]  В отличие от того, что можно было бы подумать,
[26:30.000 --> 26:34.000]  это вот, что lambda.xy.x или всякого у.
[26:34.000 --> 26:37.000]  И это не равно номералу 1.
[26:37.000 --> 26:44.000]  Вот, но зато это симметрично получается проекция на первую координату.
[26:44.000 --> 26:55.000]  Проекция на первую координату.
[26:55.000 --> 27:00.000]  Вот, как же тогда, значит, как же тогда
[27:00.000 --> 27:06.000]  логические операции выражать?
[27:06.000 --> 27:09.000]  Ну, например, можно заметить следующее,
[27:09.000 --> 27:14.000]  что вообще можно писать про конъюнцию, например,
[27:14.000 --> 27:17.000]  что такое p и q.
[27:17.000 --> 27:22.000]  Ну, можно сказать, что это 0, если p равно 0,
[27:22.000 --> 27:28.000]  и q, если p равно 1.
[27:28.000 --> 27:33.000]  Вместо аналогичного
[27:33.000 --> 27:37.000]  можно писать, что...
[27:37.000 --> 27:41.000]  Написать, комбинатор end
[27:41.000 --> 27:51.000]  будет lambda pq.pq false.
[27:51.000 --> 27:53.000]  Значит, и что здесь будет происходить?
[27:53.000 --> 27:57.000]  Если p равно 0,
[27:57.000 --> 28:01.000]  ну, например,
[28:01.000 --> 28:08.000]  end, потом false, потом q.
[28:08.000 --> 28:12.000]  Значит, это что такое будет?
[28:12.000 --> 28:18.000]  Это будет false q false,
[28:18.000 --> 28:27.000]  и это равно false.
[28:27.000 --> 28:32.000]  Потому что вот этот вот false первый, он из следующих двух комбинаторов
[28:32.000 --> 28:38.000]  выберет второй, потому что false всегда второй выбирает.
[28:38.000 --> 28:43.000]  Ну, а если, соответственно, end true q
[28:43.000 --> 28:48.000]  q написать, то это будет true q false,
[28:48.000 --> 28:55.000]  и это будет q.
[28:55.000 --> 28:57.000]  Вот.
[28:57.000 --> 29:03.000]  Ну, а в самом деле можно и чуть попроще написать.
[29:03.000 --> 29:07.000]  Можно также написать, что p и q будет равняться
[29:07.000 --> 29:09.000]  p, если p равно 0,
[29:09.000 --> 29:11.000]  потому что если p равно 0, то 0 равно p.
[29:11.000 --> 29:13.000]  И можно заменить на p.
[29:13.000 --> 29:14.000]  Вот.
[29:14.000 --> 29:18.000]  И q, если, соответственно, p равно 1.
[29:18.000 --> 29:20.000]  И тогда будет немножко попроще.
[29:20.000 --> 29:22.000]  Значит, тогда end будет
[29:22.000 --> 29:30.000]  lambda pq.pq.p.
[29:30.000 --> 29:31.000]  Вот.
[29:31.000 --> 29:34.000]  А or
[29:34.000 --> 29:41.000]  можно написать lambda pq.p.pq.
[29:41.000 --> 29:44.000]  Значит, наоборот, если p равно 1,
[29:44.000 --> 29:48.000]  то тогда дизюнкция верна, и она же равна p.
[29:48.000 --> 29:54.000]  А если p равно 0, тогда дизюнкция равна q.
[29:54.000 --> 29:55.000]  Вот.
[29:55.000 --> 29:57.000]  То есть, вообще, в целом, смотрите, в целом,
[29:57.000 --> 30:00.000]  тут логические значения придуманы так, чтобы подходить
[30:00.000 --> 30:02.000]  под тернарный оператор.
[30:02.000 --> 30:04.000]  А то есть, что такое тернарный оператор?
[30:04.000 --> 30:06.000]  Что если первый аргумент истинен,
[30:06.000 --> 30:08.000]  то он равен второму аргументу,
[30:08.000 --> 30:10.000]  а если ложен, то равен третьему аргументу.
[30:10.000 --> 30:12.000]  Но здесь ровно это и происходит.
[30:12.000 --> 30:14.000]  Точнее, не здесь вот, а вот здесь вот.
[30:14.000 --> 30:16.000]  Да, он как раз...
[30:16.000 --> 30:18.000]  Первый аргумент есть логическое значение,
[30:18.000 --> 30:20.000]  то из следующих двух он выберет
[30:20.000 --> 30:24.000]  либо первое, если он истинен,
[30:24.000 --> 30:28.000]  либо второе, если он ложен.
[30:28.000 --> 30:29.000]  Вот.
[30:29.000 --> 30:32.000]  Соответственно, всякие другие логические операции
[30:32.000 --> 30:34.000]  можно аналогично сделать.
[30:34.000 --> 30:37.000]  Но не всегда можно избавиться от константа.
[30:37.000 --> 30:40.000]  То есть, например, нот так не получится.
[30:40.000 --> 30:46.000]  Значит, нот будет что-нибудь типа лямбда p,
[30:46.000 --> 30:50.000]  лямбда p, точка p, false true.
[30:53.000 --> 30:56.000]  Значит, если по истину, тогда вернется ложь,
[30:56.000 --> 30:58.000]  если p ложь, то вернется истина.
[31:00.000 --> 31:01.000]  Вот.
[31:05.000 --> 31:07.000]  Так, нот это логическая операция.
[31:07.000 --> 31:09.000]  Есть какие-нибудь вопросы?
[31:12.000 --> 31:14.000]  Так, значит, тогда следующая это
[31:14.000 --> 31:16.000]  операция над парой.
[31:17.000 --> 31:19.000]  Так, а что мы хотим от пары?
[31:19.000 --> 31:21.000]  Ну, как всегда, мы хотим у пары
[31:21.000 --> 31:23.000]  брать первую и вторую компоненту,
[31:23.000 --> 31:25.000]  первую и вторую компоненту,
[31:25.000 --> 31:27.000]  левую и правую.
[31:27.000 --> 31:29.000]  И, соответственно, нужно, чтобы был оператор пары,
[31:29.000 --> 31:31.000]  который изготавливает некоторый код пары,
[31:31.000 --> 31:33.000]  и операторы взять левую и правую,
[31:33.000 --> 31:35.000]  которые ему обратны.
[31:35.000 --> 31:37.000]  То есть, для пары...
[31:37.000 --> 31:55.000]  Значит, комбинаторы, комбинаторы пары будут pair left и right.
[31:57.000 --> 31:59.000]  Так что мы хотим, чтобы было выполнено,
[31:59.000 --> 32:05.000]  чтобы left, взятый от пары x, y,
[32:05.000 --> 32:07.000]  обратите внимание на скобке,
[32:07.000 --> 32:09.000]  значит, это должно быть x,
[32:11.000 --> 32:13.000]  а, соответственно, right,
[32:15.000 --> 32:17.000]  взятый от пары x, y,
[32:17.000 --> 32:19.000]  это должно равняться y.
[32:21.000 --> 32:23.000]  Можно сказать, что мы хотим уравнение решить.
[32:23.000 --> 32:25.000]  То есть, мы хотим найти такие
[32:25.000 --> 32:27.000]  pair left и right,
[32:27.000 --> 32:29.000]  чтобы для любых x, y были бы верны
[32:29.000 --> 32:31.000]  вот эти два условия.
[32:35.000 --> 32:39.000]  Вот такое вот задание.
[32:41.000 --> 32:43.000]  Сейчас будет звонок, давайте после прерыва
[32:43.000 --> 32:45.000]  я расскажу,
[32:45.000 --> 32:47.000]  как это делать при помощи
[32:47.000 --> 32:49.000]  true и false.
[32:49.000 --> 32:51.000]  Так, прерыв 5 минут.
[32:51.000 --> 32:57.000]  Ну, действительно, эти три комбинатора pair left и right
[32:57.000 --> 33:01.000]  основаны на логических операциях.
[33:01.000 --> 33:07.000]  Значит, а именно будет pair x, y,
[33:07.000 --> 33:09.000]  x, y,
[33:09.000 --> 33:11.000]  x, y,
[33:11.000 --> 33:13.000]  x, y,
[33:13.000 --> 33:15.000]  x, y,
[33:15.000 --> 33:17.000]  а именно будет pair,
[33:19.000 --> 33:21.000]  pair это будет
[33:21.000 --> 33:23.000]  λx, y,
[33:23.000 --> 33:25.000]  pair.pxy,
[33:29.000 --> 33:31.000]  значит, left,
[33:37.000 --> 33:41.000]  значит, left это будет λp.ptrue,
[33:45.000 --> 33:49.000]  и right это будет λp.pfalse.
[33:53.000 --> 33:55.000]  Значит, почему это сработает?
[33:57.000 --> 33:59.000]  Ну, легко понять,
[33:59.000 --> 34:01.000]  что pair x, y
[34:01.000 --> 34:03.000]  это будет λp,
[34:05.000 --> 34:07.000]  да, уже без x, y,
[34:07.000 --> 34:09.000]  а просто λp.pxy.
[34:15.000 --> 34:17.000]  Ну, а дальше,
[34:17.000 --> 34:19.000]  значит,
[34:19.000 --> 34:21.000]  left,
[34:21.000 --> 34:23.000]  вот pair x, y,
[34:25.000 --> 34:27.000]  значит, это будет
[34:27.000 --> 34:29.000]  λp.ptrue,
[34:31.000 --> 34:33.000]  тут будет
[34:33.000 --> 34:35.000]  λp.pxy.
[34:37.000 --> 34:39.000]  Дальше что происходит?
[34:39.000 --> 34:41.000]  Значит, дальше начинается бета-редукция.
[34:41.000 --> 34:43.000]  Значит, я вот эту вот штуку
[34:43.000 --> 34:45.000]  вставляю вот сюда вот.
[34:47.000 --> 34:49.000]  Да, значит, и получается
[34:53.000 --> 34:55.000]  λp.pxy,
[34:55.000 --> 34:57.000]  а потом true.
[34:59.000 --> 35:01.000]  А после этого я
[35:01.000 --> 35:03.000]  вот эту вот штуку true
[35:03.000 --> 35:05.000]  вставляю вот сюда,
[35:05.000 --> 35:07.000]  вставляю вот здесь,
[35:07.000 --> 35:09.000]  вставляю вот здесь,
[35:09.000 --> 35:11.000]  вставляю вот сюда вот,
[35:11.000 --> 35:13.000]  и получается true.xy.
[35:17.000 --> 35:19.000]  Значит, будет true.xy,
[35:19.000 --> 35:21.000]  ну, и это x, да,
[35:21.000 --> 35:23.000]  потому что они действуют
[35:23.000 --> 35:25.000]  как торнарный оператор.
[35:25.000 --> 35:27.000]  То есть, тут,
[35:27.000 --> 35:29.000]  вот, такая конкатинация действует
[35:29.000 --> 35:31.000]  как торнарный оператор.
[35:31.000 --> 35:33.000]  Вот. Ну, с это left,
[35:33.000 --> 35:35.000]  а right полностью аналогично,
[35:35.000 --> 35:37.000]  только вместо true будет false,
[35:37.000 --> 35:39.000]  так.
[35:41.000 --> 35:43.000]  Так.
[35:47.000 --> 35:49.000]  Ну, че, согласны?
[35:51.000 --> 35:53.000]  Вот, хорошо. Комминаторы пары у нас есть.
[35:53.000 --> 35:55.000]  Вот. Ну, а теперь можно
[35:55.000 --> 35:57.000]  приходить к вычитанию.
[35:57.000 --> 35:59.000]  Значит, вычитание единицы
[36:01.000 --> 36:03.000]  декремент.
[36:03.000 --> 36:05.000]  Значит, вычитание единицы.
[36:07.000 --> 36:09.000]  Значит, тут идея,
[36:09.000 --> 36:11.000]  которая называется трюк
[36:11.000 --> 36:13.000]  клинья.
[36:15.000 --> 36:17.000]  Значит, ну,
[36:17.000 --> 36:19.000]  историю рассказывают, что
[36:23.000 --> 36:25.000]  клинья там долго думал,
[36:25.000 --> 36:27.000]  надо всем как это сделать,
[36:27.000 --> 36:29.000]  а потом у него заболел зуб мудрости,
[36:31.000 --> 36:33.000]  и вроде то ли его вырвали этот зуб,
[36:33.000 --> 36:35.000]  и он после этого придумал,
[36:35.000 --> 36:37.000]  то ли наоборот.
[36:37.000 --> 36:39.000]  Сначала придумал, потом вырвали.
[36:39.000 --> 36:41.000]  В общем, можно где-нибудь литературы поискать.
[36:41.000 --> 36:43.000]  Но, в общем, поэтому еще это называется
[36:43.000 --> 36:45.000]  трюком зуба мудрости.
[36:45.000 --> 36:47.000]  Что клинья придумал?
[36:47.000 --> 36:49.000]  А придумал следующее.
[36:49.000 --> 36:51.000]  Что он рассмотрел?
[36:51.000 --> 36:53.000]  Вот такое преобразование,
[36:53.000 --> 36:55.000]  такую цепочку преобразования.
[36:55.000 --> 36:57.000]  Смотрите, значит, пара x, y
[36:59.000 --> 37:01.000]  преобразуется в пару f от x, x.
[37:01.000 --> 37:03.000]  f от x, x.
[37:03.000 --> 37:05.000]  Значит, это преобразуется в пару
[37:05.000 --> 37:07.000]  f от f от x,
[37:07.000 --> 37:09.000]  f от x.
[37:09.000 --> 37:11.000]  Значит, а тут будет,
[37:11.000 --> 37:13.000]  соответственно, там
[37:13.000 --> 37:15.000]  f кубя,
[37:15.000 --> 37:17.000]  f квадратя
[37:17.000 --> 37:19.000]  и так далее.
[37:19.000 --> 37:21.000]  Итак, если это n раз сделать,
[37:21.000 --> 37:23.000]  то тут будет
[37:23.000 --> 37:25.000]  fnm от x,
[37:25.000 --> 37:27.000]  а тут n-1
[37:27.000 --> 37:29.000]  от x.
[37:31.000 --> 37:33.000]  И на самом деле вот эта вот вторая часть
[37:33.000 --> 37:35.000]  это ровно то, что нам нужно.
[37:37.000 --> 37:39.000]  Да, то есть идея следующая,
[37:39.000 --> 37:41.000]  что как бы сделать...
[37:43.000 --> 37:45.000]  В чем трюк заключается?
[37:45.000 --> 37:47.000]  Значит, трюк заключается в том,
[37:47.000 --> 37:49.000]  что вот это вот,
[37:49.000 --> 37:51.000]  значит, повторить
[37:53.000 --> 37:55.000]  n раз
[37:55.000 --> 37:57.000]  и взять
[37:57.000 --> 37:59.000]  вторую часть.
[38:01.000 --> 38:03.000]  Тогда это будет ровно то,
[38:03.000 --> 38:05.000]  что нам нужно.
[38:07.000 --> 38:09.000]  Вот.
[38:25.000 --> 38:27.000]  Так, ну...
[38:31.000 --> 38:33.000]  Хорошо.
[38:33.000 --> 38:35.000]  Значит, как...
[38:35.000 --> 38:37.000]  Как это теперь записать?
[38:37.000 --> 38:39.000]  Что нам нужно?
[38:39.000 --> 38:41.000]  Во-первых, нужно от функции f
[38:41.000 --> 38:43.000]  перейти вот к такому преобразованию.
[38:47.000 --> 38:49.000]  Вот.
[38:49.000 --> 38:51.000]  Вот.
[38:51.000 --> 38:53.000]  Вот.
[38:53.000 --> 38:55.000]  Вот.
[38:55.000 --> 38:57.000]  Вот.
[38:57.000 --> 38:59.000]  Вот.
[38:59.000 --> 39:01.000]  Так.
[39:01.000 --> 39:03.000]  И давайте сначала вот это вот.
[39:05.000 --> 39:07.000]  Значит, это назовем
[39:13.000 --> 39:15.000]  deckfn, то есть как бы
[39:15.000 --> 39:17.000]  функция для декремента.
[39:17.000 --> 39:19.000]  Вспомогательная функция
[39:19.000 --> 39:21.000]  для декремента.
[39:21.000 --> 39:23.000]  Да, значит, это...
[39:23.000 --> 39:25.000]  Значит, f
[39:25.000 --> 39:27.000]  нужно преобразовать
[39:27.000 --> 39:29.000]  соответственно функцию,
[39:29.000 --> 39:31.000]  которая x, y
[39:31.000 --> 39:33.000]  преобразует
[39:33.000 --> 39:35.000]  в f от x и x.
[39:37.000 --> 39:39.000]  Так, значит,
[39:39.000 --> 39:41.000]  это у нас будет выглядеть следующим образом.
[39:43.000 --> 39:45.000]  Значит, лямда
[39:45.000 --> 39:47.000]  fp,
[39:47.000 --> 39:49.000]  потому что этот аргумент это пара.
[39:49.000 --> 39:51.000]  Значит,
[39:51.000 --> 39:53.000]  pair
[39:53.000 --> 39:55.000]  от
[39:57.000 --> 39:59.000]  f
[39:59.000 --> 40:01.000]  от left
[40:01.000 --> 40:03.000]  pair.
[40:03.000 --> 40:05.000]  И просто
[40:05.000 --> 40:07.000]  left pair.
[40:13.000 --> 40:15.000]  Вот. Вот это вот это самое
[40:15.000 --> 40:17.000]  deckfn. То есть, смотрите, если сюда f подставить,
[40:17.000 --> 40:19.000]  то вот это вот лямда f у тебя
[40:19.000 --> 40:21.000]  останется лямда p.
[40:21.000 --> 40:23.000]  Вот. И тогда как раз получается, что мы
[40:23.000 --> 40:25.000]  из пара x, y берем только x,
[40:25.000 --> 40:27.000]  потом устроим f от x
[40:27.000 --> 40:29.000]  и образуем
[40:29.000 --> 40:31.000]  из них снова пару.
[40:33.000 --> 40:35.000]  Вот.
[40:35.000 --> 40:37.000]  Ну, а теперь, собственно,
[40:37.000 --> 40:39.000]  сам декремент.
[40:43.000 --> 40:45.000]  Декремент
[40:45.000 --> 40:47.000]  будет выглядеть так.
[40:47.000 --> 40:49.000]  Лямда
[40:49.000 --> 40:51.000]  nfx
[40:51.000 --> 40:53.000]  точка
[40:53.000 --> 40:55.000]  right
[40:57.000 --> 40:59.000]  от
[40:59.000 --> 41:01.000]  следующей
[41:01.000 --> 41:03.000]  штуки.
[41:03.000 --> 41:05.000]  От n раз
[41:05.000 --> 41:07.000]  примененной
[41:07.000 --> 41:09.000]  из многогаитной функции
[41:09.000 --> 41:11.000]  deckfn.
[41:11.000 --> 41:13.000]  Примененной из многогаитной функции
[41:13.000 --> 41:15.000]  deckfn.
[41:17.000 --> 41:19.000]  Значит, примененной
[41:21.000 --> 41:23.000]  так, наверное, вот так вот нужно
[41:23.000 --> 41:25.000]  сделать.
[41:29.000 --> 41:31.000]  И
[41:31.000 --> 41:33.000]  pair x, x.
[41:33.000 --> 41:35.000]  Значит, зачем тут именно
[41:35.000 --> 41:37.000]  x, x?
[41:37.000 --> 41:39.000]  А для случая
[41:41.000 --> 41:43.000]  значит, pair x, x
[41:43.000 --> 41:45.000]  нужен для случая n равного 0.
[41:45.000 --> 41:47.000]  Потому что если n равно
[41:47.000 --> 41:49.000]  0, то тогда нам
[41:49.000 --> 41:51.000]  ничего не нужно менять.
[41:51.000 --> 41:53.000]  И тогда n
[41:53.000 --> 41:55.000]  равному 0 ничего не сделает. Оставит пару из
[41:55.000 --> 41:57.000]  x и x.
[41:57.000 --> 41:59.000]  И тогда right возьмет x. Это нам и нужно.
[42:05.000 --> 42:07.000]  Вот. Если n больше 0,
[42:07.000 --> 42:09.000]  то тогда мы как раз
[42:09.000 --> 42:11.000]  значит, deckfnf
[42:11.000 --> 42:13.000]  это вот это вот преобразование.
[42:13.000 --> 42:15.000]  Применение
[42:15.000 --> 42:17.000]  к паре из x, x.
[42:17.000 --> 42:19.000]  Получим такую штуку, возьмем правую
[42:19.000 --> 42:21.000]  часть. И будет как раз
[42:21.000 --> 42:23.000]  n минус первая итерация,
[42:23.000 --> 42:25.000]  а λfx тут как раз останутся.
[42:27.000 --> 42:29.000]  Вот. Поэтому получается, что
[42:29.000 --> 42:31.000]  значит, нам нужно, что
[42:31.000 --> 42:33.000]  декремент от 0
[42:33.000 --> 42:35.000]  равняется 0.
[42:35.000 --> 42:37.000]  Декремент от n плюс 1
[42:37.000 --> 42:39.000]  равняется n.
[42:43.000 --> 42:45.000]  Так. Ну чего, понятно?
[42:45.000 --> 42:47.000]  Нужно здесь что-нибудь пояснять
[42:47.000 --> 42:49.000]  подробнее.
[42:51.000 --> 42:53.000]  Как этот трюк работает?
[43:03.000 --> 43:05.000]  Сейчас. Чего? Вот это как
[43:05.000 --> 43:07.000]  используем. Ну, смотрите.
[43:07.000 --> 43:09.000]  Вот. Вот это вот pair x,
[43:09.000 --> 43:11.000]  это то же самое, что вот здесь.
[43:11.000 --> 43:13.000]  Ну, вместо x, y мы и y тоже равно x берем.
[43:13.000 --> 43:15.000]  Потом
[43:15.000 --> 43:17.000]  deckfnf
[43:17.000 --> 43:19.000]  это вот каждый из вот этих вот преобразований.
[43:19.000 --> 43:21.000]  Оно
[43:21.000 --> 43:23.000]  согласно
[43:23.000 --> 43:25.000]  одной и той же функции делается.
[43:25.000 --> 43:27.000]  Мы от левой части
[43:27.000 --> 43:29.000]  берем f и
[43:29.000 --> 43:31.000]  ставим снова налево,
[43:31.000 --> 43:33.000]  а саму без изменения левую
[43:33.000 --> 43:35.000]  часть ведем направо.
[43:37.000 --> 43:39.000]  Соответственно, мы n раз
[43:39.000 --> 43:41.000]  применяем вот такой преобразований
[43:41.000 --> 43:43.000]  к pair x, x. Это означает, что мы
[43:43.000 --> 43:45.000]  вычисляем вот эту вот цепочку.
[43:45.000 --> 43:47.000]  После этого берем правую часть, то есть
[43:47.000 --> 43:49.000]  берем как раз вот эту вот штуку.
[43:55.000 --> 43:57.000]  Ну, смотрите, если все равно не понятно,
[43:57.000 --> 43:59.000]  так на слух, то попробуйте для маленьких
[43:59.000 --> 44:01.000]  чисел просто непосредственно все расписать.
[44:01.000 --> 44:03.000]  Когда там 0, 1, 2,
[44:03.000 --> 44:05.000]  наверное, станет понятно.
[44:11.000 --> 44:13.000]  Ну вот, соответственно,
[44:13.000 --> 44:15.000]  если мы единицу научились вычитать,
[44:15.000 --> 44:17.000]  то после этого
[44:17.000 --> 44:19.000]  берем.
[44:21.000 --> 44:23.000]  Давно уже было.
[44:25.000 --> 44:27.000]  Во, значит,
[44:27.000 --> 44:29.000]  тогда мы сколько угодно
[44:29.000 --> 44:31.000]  можем вычитать по этой формуле.
[44:43.000 --> 44:45.000]  Вот так.
[44:45.000 --> 44:47.000]  Ну, остается деление.
[44:59.000 --> 45:01.000]  Вот, деление уже нужно
[45:01.000 --> 45:03.000]  выполнять общим методом
[45:03.000 --> 45:05.000]  через рекурсивное программирование.
[45:07.000 --> 45:09.000]  Деление общим методом
[45:13.000 --> 45:15.000]  общим методом через
[45:19.000 --> 45:21.000]  рекурсивное программирование.
[45:23.000 --> 45:25.000]  Потому что, значит,
[45:25.000 --> 45:27.000]  деление у нас будет числочисленное.
[45:27.000 --> 45:29.000]  То есть оно пускай будет всегда
[45:29.000 --> 45:31.000]  определено как целая часть.
[45:33.000 --> 45:35.000]  То есть деление
[45:35.000 --> 45:37.000]  будем считать как целая часть
[45:37.000 --> 45:39.000]  m делить на n.
[45:39.000 --> 45:41.000]  А, но сначала, прежде чем
[45:41.000 --> 45:43.000]  вот еще так,
[45:45.000 --> 45:47.000]  чтобы научиться делать деление,
[45:47.000 --> 45:49.000]  на самом деле нужно сначала научиться делать сравнение.
[45:51.000 --> 45:53.000]  Потому что хочется делать следующее.
[45:53.000 --> 45:55.000]  Надо написать, что целая часть
[45:55.000 --> 45:57.000]  m делить на n.
[45:57.000 --> 45:59.000]  Это будет 0, если m меньше n.
[46:01.000 --> 46:03.000]  И, соответственно,
[46:03.000 --> 46:05.000]  1 плюс целая часть
[46:05.000 --> 46:07.000]  m-n делить на n.
[46:07.000 --> 46:09.000]  Иначе.
[46:11.000 --> 46:13.000]  Значит, такое рекурсивное определение.
[46:15.000 --> 46:17.000]  Но, соответственно, вопрос
[46:17.000 --> 46:19.000]  как проверить?
[46:21.000 --> 46:23.000]  Значит, как проверить
[46:25.000 --> 46:27.000]  что m меньше m?
[46:31.000 --> 46:33.000]  Ну, на самом деле достаточно научиться сравниваться
[46:33.000 --> 46:35.000]  с нулем, потому что вы читать мы уже научились.
[46:35.000 --> 46:37.000]  Вы читать научились,
[46:37.000 --> 46:39.000]  соответственно, можно написать, что
[46:39.000 --> 46:41.000]  m меньше n
[46:41.000 --> 46:43.000]  тогда и только тогда,
[46:43.000 --> 46:45.000]  когда
[46:45.000 --> 46:47.000]  n-m
[46:47.000 --> 46:49.000]  не равно 0.
[46:51.000 --> 46:53.000]  Ну, где минус понимается в нашем смысле
[46:53.000 --> 46:55.000]  со срезкой.
[46:57.000 --> 46:59.000]  То есть, вот это получается
[46:59.000 --> 47:01.000]  как
[47:01.000 --> 47:03.000]  максимум из n-m
[47:03.000 --> 47:05.000]  и 0.
[47:07.000 --> 47:09.000]  Но, поскольку
[47:09.000 --> 47:11.000]  отрицание мы тоже научились делать,
[47:13.000 --> 47:15.000]  то достаточно
[47:15.000 --> 47:17.000]  научиться проверять равенство 0.
[47:23.000 --> 47:25.000]  Соответственно, получается, что вот мы свели
[47:25.000 --> 47:27.000]  задачу
[47:27.000 --> 47:29.000]  к вопросу равенства 0.
[47:29.000 --> 47:31.000]  Значит,
[47:31.000 --> 47:33.000]  соответственно, нужно
[47:37.000 --> 47:39.000]  нужно проверять
[47:39.000 --> 47:41.000]  равенство 0.
[47:43.000 --> 47:45.000]  Читаем, нужно какой-то предикат
[47:47.000 --> 47:49.000]  из 0,
[47:49.000 --> 47:51.000]  который обладает следующими свойствами.
[47:51.000 --> 47:53.000]  Значит, из 0, 0
[47:53.000 --> 47:55.000]  равняется true,
[47:57.000 --> 47:59.000]  а из 0,
[47:59.000 --> 48:01.000]  n плюс 1
[48:01.000 --> 48:03.000]  равняется false.
[48:11.000 --> 48:13.000]  Вот.
[48:13.000 --> 48:15.000]  Ну, в общем.
[48:27.000 --> 48:29.000]  Значит, из 0
[48:31.000 --> 48:33.000]  будет вот что такое.
[48:33.000 --> 48:35.000]  Значит, это будет лямбда m.
[48:37.000 --> 48:39.000]  Тут будет m
[48:39.000 --> 48:41.000]  а тут будет n
[48:45.000 --> 48:47.000]  лямбда x
[48:47.000 --> 48:49.000]  точка false
[48:49.000 --> 48:51.000]  true.
[48:55.000 --> 48:57.000]  То есть, смотрите, что тут
[48:57.000 --> 48:59.000]  говорит, что мы как бы итерируем n раз
[48:59.000 --> 49:01.000]  константу лож
[49:01.000 --> 49:03.000]  и примеем ее к true.
[49:03.000 --> 49:05.000]  То есть, мы хотя бы один раз
[49:05.000 --> 49:07.000]  итерируем, то результат будет константой лож.
[49:07.000 --> 49:09.000]  Но если мы ни разу не итерируем,
[49:09.000 --> 49:11.000]  то будет то, что изначально было
[49:11.000 --> 49:13.000]  и изначально было true.
[49:13.000 --> 49:15.000]  Вот.
[49:15.000 --> 49:17.000]  Если подробнее расписать,
[49:17.000 --> 49:19.000]  значит,
[49:19.000 --> 49:21.000]  из 0, 0.
[49:21.000 --> 49:23.000]  Значит, это будет
[49:23.000 --> 49:25.000]  0
[49:25.000 --> 49:27.000]  лямбда x точка false
[49:27.000 --> 49:29.000]  true.
[49:29.000 --> 49:31.000]  Ну, а 0 то же самое, что false,
[49:31.000 --> 49:33.000]  а false то же самое, что взятие
[49:33.000 --> 49:35.000]  второй координаты.
[49:35.000 --> 49:37.000]  Это будет true.
[49:39.000 --> 49:41.000]  Вот.
[49:41.000 --> 49:43.000]  Значит, а из 0
[49:43.000 --> 49:45.000]  n плюс 1
[49:45.000 --> 49:47.000]  значит,
[49:47.000 --> 49:49.000]  это будет вот такое.
[49:49.000 --> 49:51.000]  Тут будет лямбда fx
[49:51.000 --> 49:53.000]  f.
[49:53.000 --> 49:55.000]  Дальше что-нибудь, неважно что.
[49:57.000 --> 49:59.000]  Значит, дальше лямбда x точка
[49:59.000 --> 50:01.000]  false
[50:01.000 --> 50:03.000]  и дальше true.
[50:05.000 --> 50:07.000]  Значит, соответственно, дальше это будет
[50:11.000 --> 50:13.000]  Так, давайте я распишу.
[50:13.000 --> 50:15.000]  Обычно.
[50:15.000 --> 50:17.000]  Значит, вот это вот лямбда x точка
[50:17.000 --> 50:19.000]  false поставится вот сюда вот.
[50:21.000 --> 50:23.000]  Вот. Ну, а true даже неважно,
[50:23.000 --> 50:25.000]  куда денется. В общем, true оно
[50:25.000 --> 50:27.000]  куда-то вот сюда вот в это многоточие
[50:27.000 --> 50:29.000]  подставится.
[50:31.000 --> 50:33.000]  Вот. Совершенно
[50:33.000 --> 50:35.000]  будет
[50:39.000 --> 50:41.000]  будет лямбда x
[50:41.000 --> 50:43.000]  точка false.
[50:43.000 --> 50:45.000]  А здесь что-нибудь
[50:45.000 --> 50:47.000]  будет. Ну, и
[50:53.000 --> 50:55.000]  соответственно, это будет
[50:55.000 --> 50:57.000]  false.
[50:57.000 --> 50:59.000]  Потому что если мы в константе заменим x
[50:59.000 --> 51:01.000]  на что угодно,
[51:01.000 --> 51:03.000]  то останется та же самая константа.
[51:07.000 --> 51:09.000]  Вот. Вот это вот последнее
[51:09.000 --> 51:11.000]  может быть неинтуитивно
[51:11.000 --> 51:13.000]  выглядит, но это правильно, потому что
[51:13.000 --> 51:15.000]  это beta-редукция, потому что
[51:15.000 --> 51:17.000]  мы все вхождения x
[51:17.000 --> 51:19.000]  заменяем на вот это выражение,
[51:19.000 --> 51:21.000]  но у нас нет ни одного вхождения x, поэтому
[51:21.000 --> 51:23.000]  остается то, что было.
[51:31.000 --> 51:33.000]  Вот.
[51:37.000 --> 51:39.000]  Ну вот, соответственно, получается,
[51:39.000 --> 51:41.000]  что мы с нулем сравниваем.
[51:41.000 --> 51:43.000]  Раз с нулем сравним, то и вообще
[51:43.000 --> 51:45.000]  сравниваем.
[51:45.000 --> 51:47.000]  А тогда у нас есть рекурсивная форму
[51:47.000 --> 51:49.000]  для деления, но только
[51:49.000 --> 51:51.000]  непонятно, как собственно
[51:51.000 --> 51:53.000]  эту рекурсию выполнить.
[51:53.000 --> 51:55.000]  Так. Ну, смотрите, значит,
[51:55.000 --> 51:57.000]  можно
[51:59.000 --> 52:01.000]  и можно взять
[52:01.000 --> 52:03.000]  и, нечто же сумняшусь,
[52:03.000 --> 52:05.000]  взять просто и записать
[52:05.000 --> 52:07.000]  вот так вот.
[52:07.000 --> 52:09.000]  Значит,
[52:11.000 --> 52:13.000]  что мы хотим?
[52:13.000 --> 52:15.000]  Мы хотим
[52:15.000 --> 52:17.000]  какой-то такой
[52:17.000 --> 52:19.000]  стабильной формы
[52:19.000 --> 52:21.000]  для деления.
[52:21.000 --> 52:23.000]  Значит, мы хотим
[52:23.000 --> 52:25.000]  какой-то div,
[52:25.000 --> 52:27.000]  division.
[52:29.000 --> 52:31.000]  Значит, мы хотим, чтобы он работал так.
[52:31.000 --> 52:33.000]  Значит,
[52:33.000 --> 52:35.000]  λdmn
[52:35.000 --> 52:37.000]  точка.
[52:39.000 --> 52:41.000]  Так, давайте считать,
[52:41.000 --> 52:43.000]  что мы уже
[52:43.000 --> 52:45.000]  определили комбинатор
[52:45.000 --> 52:47.000]  сравнения.
[52:47.000 --> 52:49.000]  Мы фактически уже сделали, чтобы не расписывать
[52:49.000 --> 52:51.000]  подробно, значит,
[52:51.000 --> 52:53.000]  lt это less than.
[52:53.000 --> 52:55.000]  Значит, less than
[52:55.000 --> 52:57.000]  mn, значит, если
[52:57.000 --> 52:59.000]  m меньше n,
[52:59.000 --> 53:01.000]  тогда это будет
[53:01.000 --> 53:03.000]  константа ноль.
[53:05.000 --> 53:07.000]  А иначе
[53:07.000 --> 53:09.000]  это будет
[53:09.000 --> 53:11.000]  инкремент
[53:11.000 --> 53:13.000]  от
[53:15.000 --> 53:17.000]  деления,
[53:17.000 --> 53:19.000]  тут будет sub
[53:21.000 --> 53:23.000]  так, значит, мы n из m вычитаем,
[53:23.000 --> 53:25.000]  значит, sub mn,
[53:27.000 --> 53:29.000]  тут останется n
[53:31.000 --> 53:33.000]  и, собственно, все.
[53:39.000 --> 53:41.000]  Вот.
[53:41.000 --> 53:43.000]  Ну, казалось бы, вот так вот нашу рекурсивную формулу записали,
[53:43.000 --> 53:45.000]  но проблема в том, что
[53:45.000 --> 53:47.000]  у меня теперь это самое div
[53:47.000 --> 53:49.000]  и слева и справа.
[53:49.000 --> 53:51.000]  Division
[53:51.000 --> 53:53.000]  получается
[53:53.000 --> 53:55.000]  и слева и справа.
[53:55.000 --> 53:57.000]  Вот division и вот division.
[53:59.000 --> 54:01.000]  То есть это получается
[54:01.000 --> 54:03.000]  уравнение.
[54:05.000 --> 54:07.000]  Уравнение
[54:07.000 --> 54:09.000]  на div.
[54:11.000 --> 54:13.000]  Ну вот, если мы это уравнение решим,
[54:13.000 --> 54:15.000]  то решение будет, соответственно,
[54:15.000 --> 54:17.000]  комбинатором деления.
[54:25.000 --> 54:27.000]  Так, как же
[54:27.000 --> 54:29.000]  решать
[54:29.000 --> 54:31.000]  такие уравнения?
[54:31.000 --> 54:33.000]  Вот есть общий метод.
[54:33.000 --> 54:35.000]  Значит, общий метод
[54:35.000 --> 54:37.000]  это комбинатор неподвижной точки.
[54:37.000 --> 54:39.000]  Также, вот этот сейчас
[54:39.000 --> 54:41.000]  называют y-комбинатор.
[54:47.000 --> 54:49.000]  Вот.
[54:49.000 --> 54:51.000]  Вот.
[54:51.000 --> 54:53.000]  Вот.
[54:53.000 --> 54:55.000]  Вот.
[54:55.000 --> 54:57.000]  Вот.
[54:57.000 --> 54:59.000]  Вот.
[54:59.000 --> 55:01.000]  Вот.
[55:01.000 --> 55:03.000]  Вот.
[55:03.000 --> 55:05.000]  Вот.
[55:05.000 --> 55:07.000]  Вот.
[55:29.000 --> 55:31.000]  Вот.
[55:31.000 --> 55:33.000]  Значит,
[55:33.000 --> 55:35.000]  они называют разные формулы для y-комбинатора.
[55:35.000 --> 55:37.000]  Каждый из отцов-основателей
[55:37.000 --> 55:39.000]  этой области
[55:39.000 --> 55:41.000]  придумал свой.
[55:41.000 --> 55:43.000]  Там есть комбинатор Чорчо, комбинатор Кария
[55:43.000 --> 55:45.000]  и еще несколько комбинаторов.
[55:45.000 --> 55:47.000]  У Клиния я не помню.
[55:47.000 --> 55:49.000]  У Клиния вот трюк придумал.
[55:49.000 --> 55:51.000]  Вот.
[55:51.000 --> 55:53.000]  А комбинатор неподвижной точки, ну может, тоже был такой не свой.
[55:53.000 --> 55:55.000]  Вот.
[55:55.000 --> 55:57.000]  Ну вот, например,
[55:57.000 --> 55:59.000]  значит, например, можно
[56:03.000 --> 56:07.000]  вот такой вот y-комбинатор взять.
[56:07.000 --> 56:09.000]  Так.
[56:09.000 --> 56:11.000]  Значит,
[56:11.000 --> 56:13.000]  λ
[56:15.000 --> 56:17.000]  x, y
[56:17.000 --> 56:19.000]  точка y
[56:19.000 --> 56:21.000]  от x, x, y
[56:21.000 --> 56:23.000]  и еще раз
[56:23.000 --> 56:25.000]  λ, x, y
[56:25.000 --> 56:27.000]  точка y от
[56:27.000 --> 56:29.000]  x, x, y.
[56:33.000 --> 56:35.000]  Вот.
[56:35.000 --> 56:37.000]  А смотрите, какая замечательная вещь.
[56:37.000 --> 56:39.000]  Посмотрим теперь
[56:39.000 --> 56:41.000]  на y, f.
[56:41.000 --> 56:43.000]  Где f?
[56:43.000 --> 56:45.000]  Это там какой-то еще комбинатор.
[56:49.000 --> 56:51.000]  Так.
[56:51.000 --> 56:53.000]  Давайте я даже на следующей доске,
[56:53.000 --> 56:55.000]  чтобы у меня было много места.
[56:55.000 --> 56:57.000]  Так.
[56:57.000 --> 56:59.000]  Y, f.
[56:59.000 --> 57:01.000]  Сейчас еще раз перепишу.
[57:01.000 --> 57:03.000]  Значит, λ, y, точка y
[57:03.000 --> 57:05.000]  от x, x, y.
[57:05.000 --> 57:07.000]  Значит, обратите внимание на скобки.
[57:07.000 --> 57:09.000]  То есть, вообще, правильно расстановка скобок
[57:09.000 --> 57:11.000]  здесь очень важна.
[57:11.000 --> 57:13.000]  Вот.
[57:13.000 --> 57:15.000]  И еще f.
[57:15.000 --> 57:17.000]  Ой, сейчас.
[57:17.000 --> 57:19.000]  Не подождите, я же не то написал.
[57:19.000 --> 57:21.000]  Сейчас.
[57:21.000 --> 57:23.000]  Да, да, да, я не то написал.
[57:23.000 --> 57:25.000]  Там было правильно.
[57:25.000 --> 57:27.000]  Давайте я тут исправлю.
[57:27.000 --> 57:29.000]  λ, x, y
[57:29.000 --> 57:31.000]  λ, x, y должно быть.
[57:33.000 --> 57:35.000]  Ой.
[57:37.000 --> 57:39.000]  Ой, а что произошло?
[57:39.000 --> 57:41.000]  Брос переключился.
[57:41.000 --> 57:43.000]  Все, ничего не пропало.
[57:45.000 --> 57:47.000]  λ, x, y.
[57:47.000 --> 57:49.000]  И тут λ, x, y.
[57:49.000 --> 57:51.000]  Вот. Так вот, смотрите.
[57:51.000 --> 57:53.000]  Вот это вот.
[57:53.000 --> 57:55.000]  Значит, вот это вот.
[57:59.000 --> 58:01.000]  Вот эта вот часть, она
[58:01.000 --> 58:03.000]  вместо x подставляется.
[58:05.000 --> 58:07.000]  Так вот.
[58:07.000 --> 58:09.000]  Вот сюда вот.
[58:09.000 --> 58:11.000]  И вот сюда вот.
[58:13.000 --> 58:15.000]  А вот эта вот часть
[58:15.000 --> 58:17.000]  f.
[58:17.000 --> 58:19.000]  Вместо y.
[58:19.000 --> 58:21.000]  Вот сюда вот и вот сюда вот.
[58:21.000 --> 58:23.000]  Вот. И что ж получается?
[58:25.000 --> 58:27.000]  Значит, получается
[58:27.000 --> 58:29.000]  f.
[58:29.000 --> 58:31.000]  Дальше скобка.
[58:31.000 --> 58:33.000]  Вот это вот открывается.
[58:35.000 --> 58:37.000]  Дальше будет
[58:37.000 --> 58:39.000]  λ, x, y.
[58:39.000 --> 58:41.000]  x, x, y.
[58:41.000 --> 58:43.000]  Значит, еще раз
[58:43.000 --> 58:45.000]  λ, x, y.
[58:45.000 --> 58:47.000]  x, x, y.
[58:49.000 --> 58:51.000]  И после этого
[58:51.000 --> 58:53.000]  f.
[58:53.000 --> 58:55.000]  И теперь скобка,
[58:55.000 --> 58:57.000]  вот эта вот скобка,
[58:57.000 --> 58:59.000]  вот здесь закрылась.
[58:59.000 --> 59:01.000]  Ну и теперь, смотрите, если посмотреть,
[59:01.000 --> 59:03.000]  что вообще в скобках происходит,
[59:03.000 --> 59:05.000]  то видно, что это ровно то же самое,
[59:05.000 --> 59:07.000]  что было в предыдущей строчке.
[59:07.000 --> 59:09.000]  То есть, это получается
[59:09.000 --> 59:11.000]  f
[59:11.000 --> 59:13.000]  от y, f.
[59:23.000 --> 59:25.000]  Вот.
[59:25.000 --> 59:27.000]  У нас любой...
[59:27.000 --> 59:29.000]  Значит, любой комбинатор,
[59:29.000 --> 59:31.000]  для которого при любом f
[59:31.000 --> 59:33.000]  выполнено это свойство,
[59:33.000 --> 59:35.000]  называется y-комбинатором.
[59:39.000 --> 59:41.000]  Комбинатором неподвижной точки
[59:45.000 --> 59:47.000]  Комбинатором неподвижной точки
[59:47.000 --> 59:49.000]  Неподвижной точки
[59:51.000 --> 59:53.000]  называется
[59:53.000 --> 59:55.000]  любой y
[59:57.000 --> 59:59.000]  такой, что при любом f
[01:00:03.000 --> 01:00:05.000]  при любом f
[01:00:05.000 --> 01:00:07.000]  верно
[01:00:07.000 --> 01:00:09.000]  y, f
[01:00:09.000 --> 01:00:11.000]  равно f от y, f.
[01:00:17.000 --> 01:00:19.000]  Вот.
[01:00:33.000 --> 01:00:35.000]  Так.
[01:00:39.000 --> 01:00:41.000]  Таким образом получается, что
[01:00:41.000 --> 01:00:43.000]  y, f
[01:00:43.000 --> 01:00:45.000]  значит y, f
[01:00:45.000 --> 01:00:47.000]  будет неподвижной точкой
[01:00:49.000 --> 01:00:51.000]  комбинатора f.
[01:00:51.000 --> 01:00:53.000]  То есть y, f
[01:00:53.000 --> 01:00:55.000]  это неподвижная точка
[01:00:59.000 --> 01:01:01.000]  неподвижная точка преобразования
[01:01:01.000 --> 01:01:03.000]  f.
[01:01:07.000 --> 01:01:09.000]  Вот. Это очень хорошо.
[01:01:09.000 --> 01:01:11.000]  Это очень хорошо, потому что
[01:01:11.000 --> 01:01:13.000]  теперь нам нужно только понять
[01:01:13.000 --> 01:01:15.000]  неподвижная точка
[01:01:15.000 --> 01:01:17.000]  какого преобразования
[01:01:17.000 --> 01:01:19.000]  должен быть наша искомая div.
[01:01:23.000 --> 01:01:25.000]  Давайте вернемся к уравнению.
[01:01:25.000 --> 01:01:27.000]  Вот. Вот наше уравнение
[01:01:27.000 --> 01:01:29.000]  для div.
[01:01:29.000 --> 01:01:31.000]  У какого преобразования
[01:01:31.000 --> 01:01:33.000]  вот этот div должен быть неподвижной точкой?
[01:01:33.000 --> 01:01:35.000]  Ну, а у того, который вообще
[01:01:35.000 --> 01:01:37.000]  все что угодно подставляет
[01:01:37.000 --> 01:01:39.000]  в такую формулу.
[01:01:39.000 --> 01:01:41.000]  То есть мы подставили div
[01:01:41.000 --> 01:01:43.000]  вот сюда вот
[01:01:43.000 --> 01:01:45.000]  и у нас получилось то же самое,
[01:01:45.000 --> 01:01:47.000]  что было изначально.
[01:01:47.000 --> 01:01:49.000]  То есть вот div это неподвижная точка
[01:01:49.000 --> 01:01:51.000]  преобразования, которая
[01:01:51.000 --> 01:01:53.000]  берет комбинатор и подставляет его вот сюда,
[01:01:53.000 --> 01:01:55.000]  вот в эту формулу.
[01:01:57.000 --> 01:01:59.000]  Вот.
[01:01:59.000 --> 01:02:01.000]  Ну, соответственно, осталось это f написать
[01:02:01.000 --> 01:02:03.000]  и будет решение.
[01:02:05.000 --> 01:02:07.000]  Так.
[01:02:07.000 --> 01:02:09.000]  Значит, тут
[01:02:09.000 --> 01:02:11.000]  div fn,
[01:02:11.000 --> 01:02:13.000]  вспомогательная функция
[01:02:13.000 --> 01:02:15.000]  для деления.
[01:02:17.000 --> 01:02:19.000]  Значит, это будет вот что.
[01:02:19.000 --> 01:02:21.000]  Значит, это будет
[01:02:21.000 --> 01:02:23.000]  лямда gmn.
[01:02:25.000 --> 01:02:27.000]  Ну, а дальше нужно переписать.
[01:02:27.000 --> 01:02:29.000]  То есть там было, давайте я заново напишу,
[01:02:29.000 --> 01:02:31.000]  не буду копировать.
[01:02:31.000 --> 01:02:33.000]  Лямда gmn.
[01:02:33.000 --> 01:02:35.000]  Если less than
[01:02:35.000 --> 01:02:37.000]  mn.
[01:02:37.000 --> 01:02:39.000]  Значит, если m меньше n,
[01:02:39.000 --> 01:02:41.000]  тогда константа ноль.
[01:02:41.000 --> 01:02:43.000]  Значит, а иначе
[01:02:43.000 --> 01:02:45.000]  нужно инкриментировать.
[01:02:47.000 --> 01:02:49.000]  Что нужно инкриментировать?
[01:02:49.000 --> 01:02:51.000]  Ну, результат деления,
[01:02:51.000 --> 01:02:53.000]  то есть вот сюда как раз нужно ставить
[01:02:53.000 --> 01:02:55.000]  функцию g,
[01:02:55.000 --> 01:02:57.000]  примененную
[01:02:57.000 --> 01:02:59.000]  к вычитанию
[01:02:59.000 --> 01:03:01.000]  из mn.
[01:03:01.000 --> 01:03:03.000]  Так.
[01:03:03.000 --> 01:03:05.000]  Все вроде, да?
[01:03:05.000 --> 01:03:07.000]  Так, давайте сравним.
[01:03:09.000 --> 01:03:11.000]  Бывает то же самое, да?
[01:03:11.000 --> 01:03:13.000]  А, n я забыл, да?
[01:03:15.000 --> 01:03:17.000]  N я забыл.
[01:03:19.000 --> 01:03:21.000]  Так, n нужно вот сюда вот.
[01:03:25.000 --> 01:03:27.000]  Так.
[01:03:27.000 --> 01:03:29.000]  Вот сюда вот n.
[01:03:29.000 --> 01:03:31.000]  Вот, теперь правильно.
[01:03:37.000 --> 01:03:39.000]  Ну вот, а после этого
[01:03:39.000 --> 01:03:41.000]  сам div
[01:03:41.000 --> 01:03:43.000]  будет неподвижная точка,
[01:03:43.000 --> 01:03:45.000]  а неподвижная точка будет y
[01:03:45.000 --> 01:03:47.000]  на div fm.
[01:03:47.000 --> 01:03:49.000]  Ну вот,
[01:03:49.000 --> 01:03:51.000]  а после этого
[01:03:51.000 --> 01:03:53.000]  сам div
[01:03:53.000 --> 01:03:55.000]  будет неподвижная точка,
[01:03:55.000 --> 01:03:57.000]  на div fm.
[01:04:01.000 --> 01:04:03.000]  Вот.
[01:04:13.000 --> 01:04:15.000]  Ну, на самом деле, рекурсивное программирование
[01:04:15.000 --> 01:04:17.000]  это очень такой мощный инструмент.
[01:04:19.000 --> 01:04:21.000]  Да, значит, а может
[01:04:21.000 --> 01:04:23.000]  очень много чего можно
[01:04:23.000 --> 01:04:25.000]  сделать при помощи рекурсии.
[01:04:27.000 --> 01:04:29.000]  Да, можно, скажем...
[01:04:29.000 --> 01:04:31.000]  Ну, а сами
[01:04:31.000 --> 01:04:33.000]  можно остаток считать.
[01:04:35.000 --> 01:04:37.000]  Да, значит, можно аналогично
[01:04:37.000 --> 01:04:39.000]  написать, например,
[01:04:39.000 --> 01:04:41.000]  mod.
[01:04:41.000 --> 01:04:43.000]  Это будет y.
[01:04:43.000 --> 01:04:45.000]  Значит, а тут будет
[01:04:45.000 --> 01:04:47.000]  аналогичная штука,
[01:04:47.000 --> 01:04:49.000]  lambda gmn.
[01:04:49.000 --> 01:04:51.000]  Так, только чуть-чуть по-другому.
[01:04:51.000 --> 01:04:53.000]  Значит, если m
[01:04:53.000 --> 01:04:55.000]  меньше n,
[01:04:55.000 --> 01:04:57.000]  то тогда будет просто m.
[01:04:57.000 --> 01:04:59.000]  Остаток по делению на n
[01:04:59.000 --> 01:05:01.000]  это само число, если оно меньше, чем m.
[01:05:01.000 --> 01:05:03.000]  Вот. А иначе
[01:05:03.000 --> 01:05:05.000]  ничего ингредиентировать не нужно,
[01:05:05.000 --> 01:05:07.000]  а нужно просто взять
[01:05:07.000 --> 01:05:09.000]  модуль от...
[01:05:09.000 --> 01:05:11.000]  не только не модуля,
[01:05:11.000 --> 01:05:13.000]  а g.
[01:05:15.000 --> 01:05:17.000]  Значит, g
[01:05:17.000 --> 01:05:19.000]  от, соответственно,
[01:05:19.000 --> 01:05:21.000]  mn и n.
[01:05:25.000 --> 01:05:27.000]  Так, вроде бы правильно, да?
[01:05:27.000 --> 01:05:29.000]  Значит,
[01:05:29.000 --> 01:05:31.000]  вычитаем m, а остаток тот же самый.
[01:05:31.000 --> 01:05:33.000]  Вот. Это, конечно,
[01:05:33.000 --> 01:05:35.000]  прям что, если по этой форме прямо вычислять,
[01:05:35.000 --> 01:05:37.000]  то это, конечно, совершенно не это самое,
[01:05:37.000 --> 01:05:39.000]  неэффективное дело.
[01:05:39.000 --> 01:05:41.000]  Не нужно так на самом деле
[01:05:41.000 --> 01:05:43.000]  вычислять остаток, это будет очень долго.
[01:05:43.000 --> 01:05:45.000]  Вот. Но
[01:05:45.000 --> 01:05:47.000]  если нас это не заботит, заботит, в принципе,
[01:05:47.000 --> 01:05:49.000]  теоретическая возможность,
[01:05:49.000 --> 01:05:51.000]  то вполне годится.
[01:05:53.000 --> 01:05:55.000]  Вот.
[01:05:55.000 --> 01:05:57.000]  Ну а если у нас есть умножение
[01:05:57.000 --> 01:05:59.000]  и модуль,
[01:05:59.000 --> 01:06:01.000]  то у нас есть бета-функция Геделя.
[01:06:01.000 --> 01:06:03.000]  Да, потому что там, собственно,
[01:06:03.000 --> 01:06:05.000]  больше ничего не использовалось.
[01:06:05.000 --> 01:06:07.000]  Ну, сложение еще, да?
[01:06:07.000 --> 01:06:09.000]  Да, значит,
[01:06:09.000 --> 01:06:11.000]  соответственно,
[01:06:11.000 --> 01:06:13.000]  сложение, умножение
[01:06:13.000 --> 01:06:15.000]  и модуль
[01:06:15.000 --> 01:06:17.000]  дает бета-функцию Геделя.
[01:06:25.000 --> 01:06:27.000]  Ну а бета-функция Геделя вообще все что угодно дает,
[01:06:27.000 --> 01:06:29.000]  все выразимое.
[01:06:29.000 --> 01:06:31.000]  Вот. И, соответственно, можно
[01:06:35.000 --> 01:06:37.000]  через это вообще
[01:06:37.000 --> 01:06:39.000]  через это выразить, в принципе,
[01:06:39.000 --> 01:06:41.000]  все вычислимые функции.
[01:06:45.000 --> 01:06:47.000]  Все вычислимые функции.
[01:06:47.000 --> 01:06:49.000]  Вот. То есть действительно получается
[01:06:49.000 --> 01:06:51.000]  альтернативная модель вычисления.
[01:06:53.000 --> 01:06:55.000]  Вот. И тут же можно, в принципе,
[01:06:55.000 --> 01:06:57.000]  тут повторить проблему остановки.
[01:06:57.000 --> 01:06:59.000]  Это я уже не успею подробно
[01:06:59.000 --> 01:07:01.000]  рассказать, но, в принципе, можно
[01:07:01.000 --> 01:07:03.000]  точно также поставить вопрос.
[01:07:03.000 --> 01:07:05.000]  То есть, давайте я
[01:07:05.000 --> 01:07:07.000]  по крайней мере сформулирую.
[01:07:07.000 --> 01:07:09.000]  Да, значит, аналог
[01:07:09.000 --> 01:07:11.000]  аналог
[01:07:13.000 --> 01:07:15.000]  аналог
[01:07:15.000 --> 01:07:17.000]  неразрешимости проблемы остановки
[01:07:25.000 --> 01:07:27.000]  да, значит, что
[01:07:27.000 --> 01:07:29.000]  нет
[01:07:29.000 --> 01:07:31.000]  нет комбинатора,
[01:07:35.000 --> 01:07:37.000]  значит, который
[01:07:37.000 --> 01:07:39.000]  получает
[01:07:41.000 --> 01:07:43.000]  ну, даже может
[01:07:43.000 --> 01:07:45.000]  просто другой комбинатор на вход
[01:07:45.000 --> 01:07:47.000]  получает
[01:07:47.000 --> 01:07:49.000]  другой комбинатор
[01:07:55.000 --> 01:07:57.000]  и говорит
[01:08:01.000 --> 01:08:03.000]  есть ли у него
[01:08:03.000 --> 01:08:05.000]  есть ли у него нормальная форма
[01:08:15.000 --> 01:08:17.000]  Вот. Ну, и так кажется, например, точно также,
[01:08:17.000 --> 01:08:19.000]  если бы он был, то мы бы его там
[01:08:19.000 --> 01:08:21.000]  применили сам к себе и
[01:08:21.000 --> 01:08:23.000]  сделали наоборот.
[01:08:23.000 --> 01:08:25.000]  Вот. В общем, это
[01:08:25.000 --> 01:08:27.000]  на самом деле вот эта вот идея диагонализации
[01:08:27.000 --> 01:08:29.000]  она тут всюду есть, да, и
[01:08:29.000 --> 01:08:31.000]  в вычислимости, и в арифметике, и вот
[01:08:31.000 --> 01:08:33.000]  я вот лямбое исчисление.
[01:08:35.000 --> 01:08:37.000]  Так. Ну, ладно,
[01:08:37.000 --> 01:08:39.000]  остается три минуты.
[01:08:39.000 --> 01:08:41.000]  Вот. И остается только
[01:08:41.000 --> 01:08:43.000]  рассказать какую-нибудь веселую вещь.
[01:08:43.000 --> 01:08:45.000]  Напоследок
[01:08:47.000 --> 01:08:49.000]  значит, напоследок
[01:08:49.000 --> 01:08:51.000]  я расскажу
[01:08:51.000 --> 01:08:53.000]  вот что.
[01:08:55.000 --> 01:08:57.000]  Значит, есть другой
[01:08:57.000 --> 01:08:59.000]  y комбинатор
[01:08:59.000 --> 01:09:01.000]  называется y комбинатор
[01:09:01.000 --> 01:09:03.000]  Клоппа.
[01:09:03.000 --> 01:09:05.000]  Ну, тут уже для русского уха сама по себе фамилия смешная,
[01:09:05.000 --> 01:09:07.000]  но
[01:09:07.000 --> 01:09:09.000]  смешное тут не это
[01:09:09.000 --> 01:09:11.000]  с математической точки зрения.
[01:09:11.000 --> 01:09:13.000]  Вот.
[01:09:13.000 --> 01:09:15.000]  Значит, а именно
[01:09:15.000 --> 01:09:17.000]  значит, здесь
[01:09:17.000 --> 01:09:19.000]  смотрите, сначала есть такой
[01:09:19.000 --> 01:09:21.000]  комбинатор L.
[01:09:21.000 --> 01:09:23.000]  Так.
[01:09:23.000 --> 01:09:25.000]  И он выглядит так. Смотрите, лямбда,
[01:09:25.000 --> 01:09:27.000]  A, B, C, D, E, F, G,
[01:09:27.000 --> 01:09:29.000]  H, I, J, K, L,
[01:09:29.000 --> 01:09:31.000]  M, N,
[01:09:31.000 --> 01:09:33.000]  O, P, Q.
[01:09:33.000 --> 01:09:35.000]  Дальше R пропущено.
[01:09:35.000 --> 01:09:37.000]  S, T,
[01:09:37.000 --> 01:09:39.000]  U, V, W,
[01:09:39.000 --> 01:09:41.000]  X, Y, Z
[01:09:41.000 --> 01:09:43.000]  и после этого R.
[01:09:43.000 --> 01:09:45.000]  Вот. Это не случайно.
[01:09:45.000 --> 01:09:47.000]  После этого идет следующее.
[01:09:47.000 --> 01:09:49.000]  Тут будет
[01:09:49.000 --> 01:09:51.000]  R,
[01:09:51.000 --> 01:09:53.000]  а здесь в скобках
[01:09:53.000 --> 01:09:55.000]  написано this is
[01:09:55.000 --> 01:09:57.000]  a fixed
[01:09:57.000 --> 01:09:59.000]  point
[01:09:59.000 --> 01:10:01.000]  combinator.
[01:10:05.000 --> 01:10:07.000]  Во.
[01:10:07.000 --> 01:10:09.000]  А сам Y будет еще
[01:10:09.000 --> 01:10:11.000]  этими самыми L
[01:10:11.000 --> 01:10:13.000]  приписанными
[01:10:13.000 --> 01:10:15.000]  26 раз.
[01:10:15.000 --> 01:10:17.000]  Вот. Давайте я прям явно
[01:10:17.000 --> 01:10:19.000]  напишу.
[01:10:19.000 --> 01:10:21.000]  Так, 5.
[01:10:25.000 --> 01:10:27.000]  10.
[01:10:29.000 --> 01:10:31.000]  Так, сейчас не влезет.
[01:10:31.000 --> 01:10:33.000]  Так.
[01:10:33.000 --> 01:10:35.000]  Это 15, да.
[01:10:37.000 --> 01:10:39.000]  20.
[01:10:39.000 --> 01:10:41.000]  Так. 23
[01:10:41.000 --> 01:10:43.000]  вообще не влезло немножко.
[01:10:43.000 --> 01:10:45.000]  26 раз.
[01:10:45.000 --> 01:10:47.000]  Значит, 26 штук.
[01:10:47.000 --> 01:10:49.000]  Вот.
[01:10:49.000 --> 01:10:51.000]  Вот такая вот штука работает
[01:10:51.000 --> 01:10:53.000]  точно так же,
[01:10:53.000 --> 01:10:55.000]  как и предыдущий Y.
[01:10:55.000 --> 01:10:57.000]  Вот. И на самом деле
[01:10:57.000 --> 01:10:59.000]  вот это единственный способ
[01:10:59.000 --> 01:11:01.000]  запомнить.
[01:11:01.000 --> 01:11:03.000]  Сможешь, конечно, вызубрить.
[01:11:03.000 --> 01:11:05.000]  Вот.
[01:11:05.000 --> 01:11:07.000]  Что вот так же, как здесь, только там покороче.
[01:11:09.000 --> 01:11:11.000]  Вот. Тоже смотрите, что получается.
[01:11:13.000 --> 01:11:15.000]  Ну, видно, что вот это
[01:11:15.000 --> 01:11:17.000]  вот R. Значит, R играет
[01:11:17.000 --> 01:11:19.000]  ту же самую роль,
[01:11:19.000 --> 01:11:21.000]  которая вот здесь играл Y.
[01:11:21.000 --> 01:11:23.000]  То есть Y повторяется вот здесь.
[01:11:23.000 --> 01:11:25.000]  И вот здесь, если посчитать
[01:11:25.000 --> 01:11:27.000]  буквки,
[01:11:27.000 --> 01:11:29.000]  вот это все
[01:11:29.000 --> 01:11:31.000]  кроме R, вот тут, смотрите,
[01:11:31.000 --> 01:11:33.000]  вот 5, 10,
[01:11:33.000 --> 01:11:35.000]  15,
[01:11:35.000 --> 01:11:37.000]  20, 25,
[01:11:37.000 --> 01:11:39.000]  26, да, ровно 26 букв.
[01:11:39.000 --> 01:11:41.000]  Вот.
[01:11:41.000 --> 01:11:43.000]  И эту тоже, да,
[01:11:43.000 --> 01:11:45.000]  26 букв.
[01:11:45.000 --> 01:11:47.000]  В общем, если действительно это
[01:11:47.000 --> 01:11:49.000]  начать расписывать, да,
[01:11:49.000 --> 01:11:51.000]  Y, F,
[01:11:51.000 --> 01:11:53.000]  то вот будет как бы первая L,
[01:11:53.000 --> 01:11:55.000]  потом еще 25 штук L и потом
[01:11:55.000 --> 01:11:57.000]  F.
[01:11:59.000 --> 01:12:01.000]  Соответственно, вот эти вот
[01:12:01.000 --> 01:12:03.000]  25 штук L, кроме первой,
[01:12:03.000 --> 01:12:05.000]  они поставят вместо всех букв латинского
[01:12:05.000 --> 01:12:07.000]  аферита, кроме R.
[01:12:07.000 --> 01:12:09.000]  Соответственно, вот здесь будет F.
[01:12:09.000 --> 01:12:11.000]  Вот это все заменится на
[01:12:11.000 --> 01:12:13.000]  L. Не важно, что тут повторяются
[01:12:13.000 --> 01:12:15.000]  буквы, это все
[01:12:15.000 --> 01:12:17.000]  на одну и ту же заметится, все равно.
[01:12:17.000 --> 01:12:19.000]  И здесь тоже будет F.
[01:12:19.000 --> 01:12:21.000]  И вот здесь останется ровно 26 L,
[01:12:21.000 --> 01:12:23.000]  как и было.
[01:12:23.000 --> 01:12:25.000]  Поэтому это действительно работает.
[01:12:25.000 --> 01:12:27.000]  Вот.
[01:12:27.000 --> 01:12:29.000]  Ну все, спасибо за внимание.
