[00:00.000 --> 00:15.000]  Начнем лекцию. Сегодня мы так условно заканчиваем первый модуль нашего курса, который был посвящен
[00:15.000 --> 00:21.000]  ведению объектно-ориентированного программирования. В целом, мы заканчиваем с темами первого задания.
[00:21.000 --> 00:27.000]  Заканчиваем, на самом деле, чуть ли не наиболее важной темой в нашем курсе. Это конструкторы и деструкторы.
[00:27.000 --> 00:35.000]  Если задать какой-нибудь вопрос, что самое главное, что отличает язык C++ от языка C, или, в принципе,
[00:35.000 --> 00:39.000]  объектно-ориентированные языки не объектно-ориентированные, то, наверное, это конструкторы и деструкторы.
[00:39.000 --> 00:47.000]  Потому что это, наверное, наиболее важная вещь, наиболее существенная часть, которая из языка C++
[00:47.000 --> 00:53.000]  делает, собственно, язык C++. В принципе, все остальное, это какой-то сахар, какой-то гарнирка
[00:53.000 --> 00:57.000]  и ко всему остальному. Ну а конструкторы и деструкторы, в принципе, очень важная тема.
[00:57.000 --> 01:05.000]  И очень хотелось бы, чтобы все в ней разобрались. Достаточно понагнетал? Все напряжены?
[01:05.000 --> 01:13.000]  Окей, давайте начнем. А начнем мы с того, что скроем некоторые проблемы, которые у нас появились
[01:13.000 --> 01:17.000]  после прошлой лекции. Вообще у нас с любой занятией будет стоять из следующих вещей.
[01:17.000 --> 01:21.000]  Мы будем ставить какую-то проблему, с ней бороться, то есть в итоге поборем, но на следующей лекции
[01:21.000 --> 01:25.000]  выясним, что появились дополнительные проблемы, которые нам нужно решать и так далее.
[01:25.000 --> 01:28.000]  То есть постоянно мы будем решать какие-то проблемы, у нас будут появляться новые.
[01:28.000 --> 01:33.000]  Ну кроме последней лекции. Я надеюсь, что после последней лекции мы более-менее все проблемы решим.
[01:33.000 --> 01:39.000]  Итак, давайте вспомним класс стека, который мы писали в прошлый раз.
[01:39.000 --> 01:44.000]  Напомню, у нас был класс стека. Мы в приватную область занесли все детали реализации,
[01:44.000 --> 01:47.000]  а в частности указатель на буфер, то есть мы реализуем стек на массиве.
[01:47.000 --> 01:52.000]  Дальше в приватной части у нас также сам размер стека хранится, в смысле значение размера.
[01:52.000 --> 01:56.000]  Ну и мы говорим, что у нас вместимость стека фиксированная, равна сотне,
[01:56.000 --> 02:01.000]  ну просто для простоты реализации, чтобы не загромождать слайды,
[02:01.000 --> 02:04.000]  ну и чтобы вам было что решать в домашних задачах.
[02:04.000 --> 02:08.000]  И мы вынесли в публичную часть весь интерфейс стека, то есть как с ним можно взаимодействовать.
[02:08.000 --> 02:14.000]  То есть есть метода init finalize, которую мы вызываем в начале работы со стеком и в конце работы со стеком.
[02:14.000 --> 02:19.000]  И ввели методы push, pop и top, стандартные методы для взаимодействия со стеком.
[02:19.000 --> 02:22.000]  Добавить элемент, удалить элемент и получить верхний элемент.
[02:22.000 --> 02:26.000]  Ну и константный метод top size и empty, который позволяет получить размер,
[02:26.000 --> 02:30.000]  узнать пусть ли стек или получить верхний элемент стека, даже если он константен.
[02:30.000 --> 02:33.000]  Ну и метод capacity, который говорит пользователю,
[02:33.000 --> 02:37.000]  какое максимальное количество элементов может наш стек вместить.
[02:37.000 --> 02:43.000]  И написали вроде как классный стек. В прошлый раз все были очень счастливы,
[02:43.000 --> 02:46.000]  звонили родственникам, вот какой стек мы написали, все очень круто.
[02:46.000 --> 02:50.000]  Но вот я утверждаю, что этот стек очень-очень плох.
[02:50.000 --> 02:52.000]  Ну пока еще.
[02:52.000 --> 02:56.000]  Давайте подумаем, что вам не нравится вот в такой реализации класса stack?
[02:56.000 --> 03:01.000]  Что в ней не так?
[03:01.000 --> 03:07.000]  От чего бы хотелось, может быть, избавиться? Что бы хотелось добавить?
[03:07.000 --> 03:11.000]  Замечательно, у вас очень разное чувство прекрасного, действительно.
[03:11.000 --> 03:15.000]  Мы вроде как в прошлый раз договорились, что не очень хорошо, наверное,
[03:15.000 --> 03:18.000]  самостоятельно как-то выделять память, самостоятельно устанавливать размер,
[03:18.000 --> 03:20.000]  самостоятельно очищать, то есть вызывать new, delete и так далее.
[03:20.000 --> 03:24.000]  И мы сказали, ну хорошо, давайте это все скроем внутрь специальных методов.
[03:24.000 --> 03:27.000]  init finalize, то есть когда нам нужно создать стек, мы вызываем метод init,
[03:27.000 --> 03:29.000]  когда нам нужно завершить работу со стеком, мы вызываем мету finalize.
[03:29.000 --> 03:31.000]  А теперь давайте задумываемся над таким вопросом.
[03:31.000 --> 03:34.000]  А чем это, вообще говоря, отличается вот вызова new и delete?
[03:34.000 --> 03:36.000]  Ну хорошо, нам не нужно знать о деталях реализации стека,
[03:36.000 --> 03:39.000]  то есть нам не нужно знать о том, что стек на самом деле реализован в виде
[03:39.000 --> 03:42.000]  какой-то динамического массива. Но все равно вот сама процедура,
[03:42.000 --> 03:46.000]  что-то сделать в начале и что-то обязательно сделать в конце, она сохранилась.
[03:46.000 --> 03:48.000]  То есть если мы не вызовем init, у нас стек не заработает.
[03:48.000 --> 03:51.000]  Если мы не вызовем finalize, у нас будет утечка ресурсов и так далее.
[03:51.000 --> 03:55.000]  То есть об этом все еще нужно думать.
[03:55.000 --> 03:58.000]  Более того, ну вот хорошо, мы написали класс stack.
[03:58.000 --> 04:02.000]  Кто-то другой написал класс массива, кто-то другой написал класс очереди и так далее.
[04:02.000 --> 04:05.000]  И каждый из них назвал по-своему. Кто-то назвал init, кто-то назвал метод start,
[04:05.000 --> 04:07.000]  кто-то назвал констракт и так далее.
[04:07.000 --> 04:10.000]  Вам нужно для каждого класса помнить, а что нужно на самом деле вызвать,
[04:10.000 --> 04:14.000]  чтобы он заработал, или что нужно на самом деле вызвать, чтобы он закончил работу.
[04:14.000 --> 04:17.000]  Согласитесь, это не очень удобно.
[04:17.000 --> 04:20.000]  Ну вот ровно то, про что я говорил.
[04:20.000 --> 04:23.000]  Нам необходимо все еще вручную инициализировать объект.
[04:23.000 --> 04:28.000]  После того, как мы создали объект стека, нам нужно обязательно вызвать метод init.
[04:28.000 --> 04:31.000]  Если мы его не вызовем, то стек у нас не заработает.
[04:31.000 --> 04:36.000]  Еще одна проблема, которая не сразу приходит в голову, но тем не менее она существует.
[04:36.000 --> 04:39.000]  А что, если я захочу завести константный стек?
[04:39.000 --> 04:42.000]  Давайте пока не думать о том, зачем это нам нужно.
[04:42.000 --> 04:45.000]  Наверное, константный стек не совсем имеет смысл.
[04:45.000 --> 04:48.000]  Вы пишете класс массива, и вам нужно завести константный массив,
[04:48.000 --> 04:52.000]  который хранит определенное количество значений, причем фиксированное.
[04:52.000 --> 04:55.000]  Я хочу завести константный стек, который никак не меняется.
[04:55.000 --> 04:57.000]  Вопрос, как мне его пронициализировать?
[04:57.000 --> 04:59.000]  Только оказывается, что никак.
[04:59.000 --> 05:01.000]  Потому что метод init, естественно, я вызвать не могу.
[05:01.000 --> 05:04.000]  Потому что init у меня изменяет стек, согласны?
[05:04.000 --> 05:07.000]  Как я могу преодолеть эту проблему?
[05:07.000 --> 05:10.000]  Могу ли я у константного стека вызвать init как-то?
[05:11.000 --> 05:14.000]  Да, я могу сделать метод init константным.
[05:14.000 --> 05:18.000]  Но если я сделаю метод init константным, то это сразу же повлечет за собой то,
[05:18.000 --> 05:21.000]  что я должен все поля сделать mutable.
[05:21.000 --> 05:23.000]  Но это как-то странно.
[05:23.000 --> 05:26.000]  То есть я все поля разрешаю менять в константных методах.
[05:26.000 --> 05:28.000]  Это странно.
[05:28.000 --> 05:30.000]  Вот возникает такая проблема.
[05:30.000 --> 05:32.000]  Константный объект я инициализировать не могу.
[05:32.000 --> 05:34.000]  Проблема с копированием.
[05:34.000 --> 05:37.000]  Давайте подумаем над тем, что должно происходить при копировании объектов.
[05:37.000 --> 05:39.000]  Вот у меня есть стек.
[05:39.000 --> 05:41.000]  Я, кстати, тут забыл вызвать метод init.
[05:41.000 --> 05:43.000]  И это вот как раз эта проблема, про которую мы говорили.
[05:43.000 --> 05:47.000]  Хорошо, я создал стек, сделал init и запушил туда один элемент.
[05:47.000 --> 05:50.000]  А дальше решил создать копию объекта стек.
[05:50.000 --> 05:53.000]  Вот когда вы создаете копию какого-то объекта, что вы ожидаете, какого поведения?
[05:53.000 --> 05:56.000]  Наверное, вы ожидаете, что у вас будут две независимые копии.
[05:56.000 --> 05:59.000]  То есть можно работать с одним стеком, можно работать с другим стеком.
[05:59.000 --> 06:03.000]  Но при этом в одном стеке один стек создастся с теми же элементами, который был в исходном стеке.
[06:03.000 --> 06:05.000]  Но что происходит при копировании структур?
[06:05.000 --> 06:07.000]  Или при копировании классов сейчас?
[06:07.000 --> 06:11.000]  Когда вы одну структуру копируете в другую, что происходит?
[06:11.000 --> 06:13.000]  Да, просто побитовое копирование.
[06:13.000 --> 06:15.000]  То есть каждое поле копируется в другое.
[06:15.000 --> 06:17.000]  То есть что у нас было?
[06:17.000 --> 06:24.000]  У нас был объект стек, у которого был буфер, который указывал куда-то в динамическую область памяти и хранил там массив.
[06:24.000 --> 06:29.000]  Ну и также есть у него свой size, который равен единице.
[06:29.000 --> 06:36.000]  И вы завели стек other, у которого тоже есть поле буфер, у которого есть поле size.
[06:36.000 --> 06:39.000]  Хорошо, size вы скопировали, он стал равен единице.
[06:39.000 --> 06:42.000]  А что стало с буфером у other?
[06:42.000 --> 06:46.000]  Он теперь указывает на ту же область памяти, что и исходный стек.
[06:46.000 --> 06:50.000]  То есть теперь и первый стек, и второй стек указывают в одну и ту же область памяти.
[06:50.000 --> 06:52.000]  Что это в свою очередь означает?
[06:52.000 --> 07:00.000]  Это означает, что если я буду вставлять элементы в первый стек или буду вставлять элементы в второй стек, у меня оба стека увидят эти изменения.
[07:00.000 --> 07:02.000]  Да?
[07:02.000 --> 07:04.000]  Беда.
[07:04.000 --> 07:06.000]  Хотелось бы наверное иметь две независимые копии.
[07:06.000 --> 07:09.000]  Более того, смотрите еще какая проблема.
[07:09.000 --> 07:13.000]  Ну смотрите, у меня есть в моей программе два объекта типа стек.
[07:13.000 --> 07:15.000]  Ну это собственно стек и other.
[07:15.000 --> 07:18.000]  Вопрос, кто из них должен называть met finalize?
[07:19.000 --> 07:23.000]  Что произойдет, если я у них обоих буду вызывать finalize?
[07:23.000 --> 07:25.000]  Будет это проблема или нет?
[07:25.000 --> 07:27.000]  Да, будет double free.
[07:27.000 --> 07:32.000]  Ну то есть формально это undefined behavior, то есть непонятно, что произойдет, но скорее всего вы получите ошибку double free.
[07:32.000 --> 07:34.000]  То есть вы два раза очищаете одну и ту же память.
[07:34.000 --> 07:36.000]  Чего делать нельзя.
[07:36.000 --> 07:38.000]  Снова беда.
[07:38.000 --> 07:40.000]  Окей.
[07:40.000 --> 07:42.000]  Ну и наконец с finalize.
[07:42.000 --> 07:44.000]  Ну та же самая проблема, что и с init.
[07:44.000 --> 07:46.000]  То есть его нужно постоянно вызывать вручную.
[07:46.000 --> 07:51.000]  Более того, если у вас есть стек, который содержит внутри себя какие-то другие стеки,
[07:51.000 --> 07:56.000]  то вам нужно делать просто те же самые действия, что вы делали при создании динамического доумерного массива.
[07:56.000 --> 08:00.000]  То есть мы в цикле добавляем элемент в стек,
[08:00.000 --> 08:02.000]  для каждого из них вызываем met init,
[08:02.000 --> 08:06.000]  а потом в цикле, чтобы очистить стек, нам нужно для каждого элемента вызвать finalize,
[08:06.000 --> 08:10.000]  и только потом вызвать finalize для внешнего стека.
[08:10.000 --> 08:12.000]  Совсем беда, совсем плохо.
[08:12.000 --> 08:13.000]  Согласны?
[08:13.000 --> 08:17.000]  И вот я утверждаю, что на сегодняшней лекции мы все эти проблемы поборем,
[08:17.000 --> 08:19.000]  и все у нас будет замечательно.
[08:19.000 --> 08:21.000]  Ну и первым, с чем мы начнем,
[08:21.000 --> 08:23.000]  это с конструкторов.
[08:25.000 --> 08:27.000]  Да.
[08:27.000 --> 08:29.000]  Ну, определение.
[08:29.000 --> 08:31.000]  Конструктор – это особый метод класса,
[08:31.000 --> 08:35.000]  который вызывается всякий раз при создании объекта.
[08:35.000 --> 08:41.000]  То есть конструктор – это метод, который вызывается неявно при создании объекта.
[08:41.000 --> 08:43.000]  В чем особенности этого метода?
[08:43.000 --> 08:45.000]  Особенность этого метода заключается в том,
[08:45.000 --> 08:47.000]  что он не имеет возвращаемого значения,
[08:47.000 --> 08:49.000]  то есть возвращаемое значение у него писать не нужно.
[08:49.000 --> 08:53.000]  Не void ничего, то есть единственное значение конструктора – это создать объект.
[08:53.000 --> 08:55.000]  Дальше.
[08:55.000 --> 08:57.000]  Имя этого метода обязаны совпадать с именем класса.
[08:57.000 --> 08:59.000]  То есть если вы пишете метод, у которого имя совпадает с именем класса,
[08:59.000 --> 09:01.000]  это конструктор.
[09:01.000 --> 09:03.000]  Ну и конструктор вызывается неявно при создании объекта.
[09:03.000 --> 09:05.000]  То есть вручную конструктор вам вызывать не нужно.
[09:05.000 --> 09:07.000]  Он вызывается всякий раз, когда вы создаете объект.
[09:07.000 --> 09:09.000]  Когда вы создаете объект,
[09:09.000 --> 09:12.000]  когда вы создаете объект, конструктор вызывается автоматом.
[09:12.000 --> 09:16.000]  Ну давайте попробуем написать какой-нибудь пример конструктора для класса stack.
[09:16.000 --> 09:19.000]  Ну вот пример. Что тут происходит?
[09:19.000 --> 09:22.000]  У меня имя метода совпадает с именем класса stack.
[09:22.000 --> 09:25.000]  Этот конструктор в данной ситуации ничего не принимает.
[09:25.000 --> 09:27.000]  Видно, что он ничего не возвращает.
[09:27.000 --> 09:30.000]  Ну и дальше я просто фигурно-скопко пишу те действия, которые мне необходимо сделать.
[09:30.000 --> 09:33.000]  Но в частности, при создании stack мне нужно проинитилизировать буфер,
[09:33.000 --> 09:37.000]  то есть выделить память. Ну и сказать, что size равен нулю.
[09:37.000 --> 09:42.000]  Ну и написав такой конструктор, теперь при создании объекта stack
[09:42.000 --> 09:46.000]  у меня все вот эти действия будут выполняться автоматически.
[09:46.000 --> 09:49.000]  То есть теперь вот в этой строке происходит,
[09:49.000 --> 09:52.000]  ну во-первых, создается переменная типа stack,
[09:52.000 --> 09:55.000]  а во-вторых, сам stack инициализируется вот таким способом, как я описал.
[09:55.000 --> 09:58.000]  То есть таким образом мы вроде как избавились от метода init.
[09:58.000 --> 10:00.000]  Круто? Вот.
[10:00.000 --> 10:03.000]  Ну и теперь давайте, ну собственно это такой небольшой пример,
[10:03.000 --> 10:05.000]  значит все понятно, то есть по синтаксису.
[10:05.000 --> 10:07.000]  Сейчас мы будем подробно обсуждать все виды стеков,
[10:07.000 --> 10:10.000]  все виды конструкторов, какие они бывают и так далее.
[10:15.000 --> 10:17.000]  В смысле, типа void.
[10:19.000 --> 10:21.000]  Ну типа как-то вот так.
[10:21.000 --> 10:24.000]  Скорее всего он скажет, что вы неправильно пишете конструктор.
[10:28.000 --> 10:29.000]  Не обязательно.
[10:29.000 --> 10:32.000]  Естественно, если вы пишете конструкторы,
[10:32.000 --> 10:34.000]  то как и любые другие методы могут быть написаны
[10:34.000 --> 10:36.000]  как в публичной области, так и в приватной области.
[10:36.000 --> 10:38.000]  Если вы пишете конструктор в приватной области,
[10:38.000 --> 10:41.000]  то это означает, что внешний код не имеет права пользоваться этим конструктором.
[10:41.000 --> 10:43.000]  Ну вот в частности давайте,
[10:43.000 --> 10:48.000]  что произойдет, если я тут public заменю на private.
[10:50.000 --> 10:52.000]  У меня вот эта строка, последняя,
[10:52.000 --> 10:54.000]  она просто наоборот не скомпилируется.
[10:54.000 --> 10:58.000]  Потому что в этом месте компилятор попытается вызвать конструктор,
[10:58.000 --> 11:01.000]  но зафейлится, потому что он приватный.
[11:03.000 --> 11:11.000]  И на самом деле существует целая классификация видов конструкторов.
[11:12.000 --> 11:14.000]  И каждый их из них обладает своими свойствами.
[11:14.000 --> 11:17.000]  Классическая классификация выглядит следующим образом.
[11:17.000 --> 11:19.000]  Есть параметрический конструктор,
[11:19.000 --> 11:20.000]  есть конструктор преобразования,
[11:20.000 --> 11:22.000]  есть конструктор по умолчанию,
[11:22.000 --> 11:24.000]  есть конструктор копирования, есть конструктор перемещения.
[11:24.000 --> 11:26.000]  Ну про конструктор перемещение будет отдельная история,
[11:26.000 --> 11:28.000]  будем говорить через несколько лекций.
[11:28.000 --> 11:32.120]  это отдельная история, будем говорить через несколько лекций.
[11:32.120 --> 11:36.040]  Давайте поподробнее мы говорим про каждый из этих видов.
[11:36.040 --> 11:41.000]  Первый вид erstуктора самый простой – параметрический конструктор.
[11:41.000 --> 11:43.340]  Давайте будем называть параметрическим конструктором
[11:43.340 --> 11:47.340]  любой конструктор, который может принимать более одного аргумента Л丈夫.
[11:47.340 --> 11:49.640]  Если конструктор принимает более одного аргумента,
[11:49.640 --> 11:52.740]  то будем говорить, что это просто обычный параметрический конструктор.
[11:52.740 --> 11:53.920]  Большой пример.
[11:53.920 --> 11:59.320]  Допустим, я хочу уметь создавать стэки таким образом.
[11:59.320 --> 12:03.120]  Я хочу стэку передавать размер и те элементы, которые он должен хранить изначально.
[12:03.120 --> 12:07.620]  Допустим, я хочу создать стэк, который изначально заполнен 10 единицами.
[12:07.620 --> 12:10.620]  Я хочу уметь так делать, потому что мне так удобнее, допустим.
[12:10.620 --> 12:15.620]  Я не хочу в цикле вызывать push, я хочу, чтобы у меня сразу стэк был определенного размера с определенными значениями.
[12:15.620 --> 12:19.620]  Чтобы так сделать, я могу написать конструктор.
[12:19.620 --> 12:23.620]  Я пишу стэк, снова без возвращаемого значения, снова метод называется так же, как и обычный класс.
[12:24.320 --> 12:27.320]  Ну и дальше я передаю ему аргументы.
[12:27.320 --> 12:31.320]  Соответственно, первый метод это size, то есть каким размером мне нужно проинитиализировать стэк.
[12:31.320 --> 12:35.320]  Ну и второй параметр, это какими значениями мне нужно стэк заполнить.
[12:35.320 --> 12:39.320]  Ну и дальше в фигурных скобках я делаю необходимые действия.
[12:39.320 --> 12:44.320]  Завожу новый буфер, завожу, соответственно, инициализирую size,
[12:44.320 --> 12:49.320]  в значении не инициализирую, а присваиваю size нужное значение.
[12:50.020 --> 12:54.020]  И в цикле, собственно, заполняю мой стэк.
[12:54.020 --> 12:58.020]  И теперь как я могу вызвать этот конструктор?
[12:58.020 --> 13:02.020]  Теперь, когда у меня есть такой конструктор, который вынимает два аргумента,
[13:02.020 --> 13:06.020]  я могу создавать стэк с помощью аргумента вот таким образом.
[13:06.020 --> 13:10.020]  То есть я пишу имя типа или переменный, и дальше в круглых скобках я указываю,
[13:10.020 --> 13:14.020]  с какими параметрами мне нужно проинитиализировать этот стэк.
[13:14.020 --> 13:18.020]  И вот эта запись означает, что при создании стэка у меня будет вызван вот этот конструктор, который описан выше.
[13:18.720 --> 13:22.720]  Ну альтернативные способы создания здесь также указаны.
[13:22.720 --> 13:26.720]  Можно через присваивающую инициализацию это все делать абсолютно эквивалентно.
[13:30.720 --> 13:34.720]  Ну все, после того как у меня отработал этот конструктор, я могу спокойно обращаться к size, к top,
[13:34.720 --> 13:38.720]  и, собственно, все работает так, как нужно.
[13:40.720 --> 13:46.720]  Теперь давайте поговорим о важной детали конструкторов, про списки инициализации.
[13:48.720 --> 13:54.720]  Значит, давайте рассмотрим такой пример.
[13:54.720 --> 13:58.720]  Вот представьте себе, что у меня есть класс B, у которого есть константное поле типа int,
[13:58.720 --> 14:02.720]  и у которого есть ссылочное поле, которое ссылается на double.
[14:02.720 --> 14:06.720]  Вот x и y. x это константа, y это ссылка.
[14:06.720 --> 14:10.720]  И вот я хочу написать конструктор, который в конструкторе, который в качестве параметров принимает
[14:10.720 --> 14:14.720]  значение, которое должен быть проинитиализирован x, и значение, которым должен быть проинитиализирован y.
[14:15.420 --> 14:19.420]  Ну точнее значение, с которым должен связаться y.
[14:19.420 --> 14:23.420]  Ну и в конструкторе я, собственно, что делаю. Я говорю, что x у меня должен быть равен x,
[14:23.420 --> 14:27.420]  у которого мне передали, и y должен ссылаться на y, который мне передали.
[14:27.420 --> 14:31.420]  Ну казалось бы, все нормально. Ну и дальше я создаю объект типа B,
[14:31.420 --> 14:35.420]  передаю ему 0 и z. То есть понятно, что в качестве второго аргумента я могу передать только
