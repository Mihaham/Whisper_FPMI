[00:00.000 --> 00:15.000]  Начнем лекцию. Сегодня мы так условно заканчиваем первый модуль нашего курса, который был посвящен
[00:15.000 --> 00:21.000]  ведению объектно-ориентированного программирования. В целом, мы заканчиваем с темами первого задания.
[00:21.000 --> 00:27.000]  Заканчиваем, на самом деле, чуть ли не наиболее важной темой в нашем курсе. Это конструкторы и деструкторы.
[00:27.000 --> 00:35.000]  Если задать какой-нибудь вопрос, что самое главное, что отличает язык C++ от языка C, или, в принципе,
[00:35.000 --> 00:39.000]  объектно-ориентированные языки не объектно-ориентированные, то, наверное, это конструкторы и деструкторы.
[00:39.000 --> 00:47.000]  Потому что это, наверное, наиболее важная вещь, наиболее существенная часть, которая из языка C++
[00:47.000 --> 00:53.000]  делает, собственно, язык C++. В принципе, все остальное, это какой-то сахар, какой-то гарнирка
[00:53.000 --> 00:57.000]  и ко всему остальному. Ну а конструкторы и деструкторы, в принципе, очень важная тема.
[00:57.000 --> 01:05.000]  И очень хотелось бы, чтобы все в ней разобрались. Достаточно понагнетал? Все напряжены?
[01:05.000 --> 01:13.000]  Окей, давайте начнем. А начнем мы с того, что скроем некоторые проблемы, которые у нас появились
[01:13.000 --> 01:17.000]  после прошлой лекции. Вообще у нас с любой занятией будет стоять из следующих вещей.
[01:17.000 --> 01:21.000]  Мы будем ставить какую-то проблему, с ней бороться, то есть в итоге поборем, но на следующей лекции
[01:21.000 --> 01:25.000]  выясним, что появились дополнительные проблемы, которые нам нужно решать и так далее.
[01:25.000 --> 01:28.000]  То есть постоянно мы будем решать какие-то проблемы, у нас будут появляться новые.
[01:28.000 --> 01:33.000]  Ну кроме последней лекции. Я надеюсь, что после последней лекции мы более-менее все проблемы решим.
[01:33.000 --> 01:39.000]  Итак, давайте вспомним класс стека, который мы писали в прошлый раз.
[01:39.000 --> 01:44.000]  Напомню, у нас был класс стека. Мы в приватную область занесли все детали реализации,
[01:44.000 --> 01:47.000]  а в частности указатель на буфер, то есть мы реализуем стек на массиве.
[01:47.000 --> 01:52.000]  Дальше в приватной части у нас также сам размер стека хранится, в смысле значение размера.
[01:52.000 --> 01:56.000]  Ну и мы говорим, что у нас вместимость стека фиксированная, равна сотне,
[01:56.000 --> 02:01.000]  ну просто для простоты реализации, чтобы не загромождать слайды,
[02:01.000 --> 02:04.000]  ну и чтобы вам было что решать в домашних задачах.
[02:04.000 --> 02:08.000]  И мы вынесли в публичную часть весь интерфейс стека, то есть как с ним можно взаимодействовать.
[02:08.000 --> 02:14.000]  То есть есть метода init finalize, которую мы вызываем в начале работы со стеком и в конце работы со стеком.
[02:14.000 --> 02:19.000]  И ввели методы push, pop и top, стандартные методы для взаимодействия со стеком.
[02:19.000 --> 02:22.000]  Добавить элемент, удалить элемент и получить верхний элемент.
[02:22.000 --> 02:26.000]  Ну и константный метод top size и empty, который позволяет получить размер,
[02:26.000 --> 02:30.000]  узнать пусть ли стек или получить верхний элемент стека, даже если он константен.
[02:30.000 --> 02:33.000]  Ну и метод capacity, который говорит пользователю,
[02:33.000 --> 02:37.000]  какое максимальное количество элементов может наш стек вместить.
[02:37.000 --> 02:43.000]  И написали вроде как классный стек. В прошлый раз все были очень счастливы,
[02:43.000 --> 02:46.000]  звонили родственникам, вот какой стек мы написали, все очень круто.
[02:46.000 --> 02:50.000]  Но вот я утверждаю, что этот стек очень-очень плох.
[02:50.000 --> 02:52.000]  Ну пока еще.
[02:52.000 --> 02:56.000]  Давайте подумаем, что вам не нравится вот в такой реализации класса stack?
[02:56.000 --> 03:01.000]  Что в ней не так?
[03:01.000 --> 03:07.000]  От чего бы хотелось, может быть, избавиться? Что бы хотелось добавить?
[03:07.000 --> 03:11.000]  Замечательно, у вас очень разное чувство прекрасного, действительно.
[03:11.000 --> 03:15.000]  Мы вроде как в прошлый раз договорились, что не очень хорошо, наверное,
[03:15.000 --> 03:18.000]  самостоятельно как-то выделять память, самостоятельно устанавливать размер,
[03:18.000 --> 03:20.000]  самостоятельно очищать, то есть вызывать new, delete и так далее.
[03:20.000 --> 03:24.000]  И мы сказали, ну хорошо, давайте это все скроем внутрь специальных методов.
[03:24.000 --> 03:27.000]  init finalize, то есть когда нам нужно создать стек, мы вызываем метод init,
[03:27.000 --> 03:29.000]  когда нам нужно завершить работу со стеком, мы вызываем мету finalize.
[03:29.000 --> 03:31.000]  А теперь давайте задумываемся над таким вопросом.
[03:31.000 --> 03:34.000]  А чем это, вообще говоря, отличается вот вызова new и delete?
[03:34.000 --> 03:36.000]  Ну хорошо, нам не нужно знать о деталях реализации стека,
[03:36.000 --> 03:39.000]  то есть нам не нужно знать о том, что стек на самом деле реализован в виде
[03:39.000 --> 03:42.000]  какой-то динамического массива. Но все равно вот сама процедура,
[03:42.000 --> 03:46.000]  что-то сделать в начале и что-то обязательно сделать в конце, она сохранилась.
[03:46.000 --> 03:48.000]  То есть если мы не вызовем init, у нас стек не заработает.
[03:48.000 --> 03:51.000]  Если мы не вызовем finalize, у нас будет утечка ресурсов и так далее.
[03:51.000 --> 03:55.000]  То есть об этом все еще нужно думать.
[03:55.000 --> 03:58.000]  Более того, ну вот хорошо, мы написали класс stack.
[03:58.000 --> 04:02.000]  Кто-то другой написал класс массива, кто-то другой написал класс очереди и так далее.
[04:02.000 --> 04:05.000]  И каждый из них назвал по-своему. Кто-то назвал init, кто-то назвал метод start,
[04:05.000 --> 04:07.000]  кто-то назвал констракт и так далее.
[04:07.000 --> 04:10.000]  Вам нужно для каждого класса помнить, а что нужно на самом деле вызвать,
[04:10.000 --> 04:14.000]  чтобы он заработал, или что нужно на самом деле вызвать, чтобы он закончил работу.
[04:14.000 --> 04:17.000]  Согласитесь, это не очень удобно.
[04:17.000 --> 04:20.000]  Ну вот ровно то, про что я говорил.
[04:20.000 --> 04:23.000]  Нам необходимо все еще вручную инициализировать объект.
[04:23.000 --> 04:28.000]  После того, как мы создали объект стека, нам нужно обязательно вызвать метод init.
[04:28.000 --> 04:31.000]  Если мы его не вызовем, то стек у нас не заработает.
[04:31.000 --> 04:36.000]  Еще одна проблема, которая не сразу приходит в голову, но тем не менее она существует.
[04:36.000 --> 04:39.000]  А что, если я захочу завести константный стек?
[04:39.000 --> 04:42.000]  Давайте пока не думать о том, зачем это нам нужно.
[04:42.000 --> 04:45.000]  Наверное, константный стек не совсем имеет смысл.
[04:45.000 --> 04:48.000]  Вы пишете класс массива, и вам нужно завести константный массив,
[04:48.000 --> 04:52.000]  который хранит определенное количество значений, причем фиксированное.
[04:52.000 --> 04:55.000]  Я хочу завести константный стек, который никак не меняется.
[04:55.000 --> 04:57.000]  Вопрос, как мне его пронициализировать?
[04:57.000 --> 04:59.000]  Только оказывается, что никак.
[04:59.000 --> 05:01.000]  Потому что метод init, естественно, я вызвать не могу.
[05:01.000 --> 05:04.000]  Потому что init у меня изменяет стек, согласны?
[05:04.000 --> 05:07.000]  Как я могу преодолеть эту проблему?
[05:07.000 --> 05:10.000]  Могу ли я у константного стека вызвать init как-то?
[05:11.000 --> 05:14.000]  Да, я могу сделать метод init константным.
[05:14.000 --> 05:18.000]  Но если я сделаю метод init константным, то это сразу же повлечет за собой то,
[05:18.000 --> 05:21.000]  что я должен все поля сделать mutable.
[05:21.000 --> 05:23.000]  Но это как-то странно.
[05:23.000 --> 05:26.000]  То есть я все поля разрешаю менять в константных методах.
[05:26.000 --> 05:28.000]  Это странно.
[05:28.000 --> 05:30.000]  Вот возникает такая проблема.
[05:30.000 --> 05:32.000]  Константный объект я инициализировать не могу.
[05:32.000 --> 05:34.000]  Проблема с копированием.
[05:34.000 --> 05:37.000]  Давайте подумаем над тем, что должно происходить при копировании объектов.
[05:37.000 --> 05:39.000]  Вот у меня есть стек.
[05:39.000 --> 05:41.000]  Я, кстати, тут забыл вызвать метод init.
[05:41.000 --> 05:43.000]  И это вот как раз эта проблема, про которую мы говорили.
[05:43.000 --> 05:47.000]  Хорошо, я создал стек, сделал init и запушил туда один элемент.
[05:47.000 --> 05:50.000]  А дальше решил создать копию объекта стек.
[05:50.000 --> 05:53.000]  Вот когда вы создаете копию какого-то объекта, что вы ожидаете, какого поведения?
[05:53.000 --> 05:56.000]  Наверное, вы ожидаете, что у вас будут две независимые копии.
[05:56.000 --> 05:59.000]  То есть можно работать с одним стеком, можно работать с другим стеком.
[05:59.000 --> 06:03.000]  Но при этом в одном стеке один стек создастся с теми же элементами, который был в исходном стеке.
[06:03.000 --> 06:05.000]  Но что происходит при копировании структур?
[06:05.000 --> 06:07.000]  Или при копировании классов сейчас?
[06:07.000 --> 06:11.000]  Когда вы одну структуру копируете в другую, что происходит?
[06:11.000 --> 06:13.000]  Да, просто побитовое копирование.
[06:13.000 --> 06:15.000]  То есть каждое поле копируется в другое.
[06:15.000 --> 06:17.000]  То есть что у нас было?
[06:17.000 --> 06:24.000]  У нас был объект стек, у которого был буфер, который указывал куда-то в динамическую область памяти и хранил там массив.
[06:24.000 --> 06:29.000]  Ну и также есть у него свой size, который равен единице.
[06:29.000 --> 06:36.000]  И вы завели стек other, у которого тоже есть поле буфер, у которого есть поле size.
[06:36.000 --> 06:39.000]  Хорошо, size вы скопировали, он стал равен единице.
[06:39.000 --> 06:42.000]  А что стало с буфером у other?
[06:42.000 --> 06:46.000]  Он теперь указывает на ту же область памяти, что и исходный стек.
[06:46.000 --> 06:50.000]  То есть теперь и первый стек, и второй стек указывают в одну и ту же область памяти.
[06:50.000 --> 06:52.000]  Что это в свою очередь означает?
[06:52.000 --> 07:00.000]  Это означает, что если я буду вставлять элементы в первый стек или буду вставлять элементы в второй стек, у меня оба стека увидят эти изменения.
[07:00.000 --> 07:02.000]  Да?
[07:02.000 --> 07:04.000]  Беда.
[07:04.000 --> 07:06.000]  Хотелось бы наверное иметь две независимые копии.
[07:06.000 --> 07:09.000]  Более того, смотрите еще какая проблема.
[07:09.000 --> 07:13.000]  Ну смотрите, у меня есть в моей программе два объекта типа стек.
[07:13.000 --> 07:15.000]  Ну это собственно стек и other.
[07:15.000 --> 07:18.000]  Вопрос, кто из них должен называть met finalize?
[07:19.000 --> 07:23.000]  Что произойдет, если я у них обоих буду вызывать finalize?
[07:23.000 --> 07:25.000]  Будет это проблема или нет?
[07:25.000 --> 07:27.000]  Да, будет double free.
[07:27.000 --> 07:32.000]  Ну то есть формально это undefined behavior, то есть непонятно, что произойдет, но скорее всего вы получите ошибку double free.
[07:32.000 --> 07:34.000]  То есть вы два раза очищаете одну и ту же память.
[07:34.000 --> 07:36.000]  Чего делать нельзя.
[07:36.000 --> 07:38.000]  Снова беда.
[07:38.000 --> 07:40.000]  Окей.
[07:40.000 --> 07:42.000]  Ну и наконец с finalize.
[07:42.000 --> 07:44.000]  Ну та же самая проблема, что и с init.
[07:44.000 --> 07:46.000]  То есть его нужно постоянно вызывать вручную.
[07:46.000 --> 07:51.000]  Более того, если у вас есть стек, который содержит внутри себя какие-то другие стеки,
[07:51.000 --> 07:56.000]  то вам нужно делать просто те же самые действия, что вы делали при создании динамического доумерного массива.
[07:56.000 --> 08:00.000]  То есть мы в цикле добавляем элемент в стек,
[08:00.000 --> 08:02.000]  для каждого из них вызываем met init,
[08:02.000 --> 08:06.000]  а потом в цикле, чтобы очистить стек, нам нужно для каждого элемента вызвать finalize,
[08:06.000 --> 08:10.000]  и только потом вызвать finalize для внешнего стека.
[08:10.000 --> 08:12.000]  Совсем беда, совсем плохо.
[08:12.000 --> 08:13.000]  Согласны?
[08:13.000 --> 08:17.000]  И вот я утверждаю, что на сегодняшней лекции мы все эти проблемы поборем,
[08:17.000 --> 08:19.000]  и все у нас будет замечательно.
[08:19.000 --> 08:21.000]  Ну и первым, с чем мы начнем,
[08:21.000 --> 08:23.000]  это с конструкторов.
[08:25.000 --> 08:27.000]  Да.
[08:27.000 --> 08:29.000]  Ну, определение.
[08:29.000 --> 08:31.000]  Конструктор – это особый метод класса,
[08:31.000 --> 08:35.000]  который вызывается всякий раз при создании объекта.
[08:35.000 --> 08:41.000]  То есть конструктор – это метод, который вызывается неявно при создании объекта.
[08:41.000 --> 08:43.000]  В чем особенности этого метода?
[08:43.000 --> 08:45.000]  Особенность этого метода заключается в том,
[08:45.000 --> 08:47.000]  что он не имеет возвращаемого значения,
[08:47.000 --> 08:49.000]  то есть возвращаемое значение у него писать не нужно.
[08:49.000 --> 08:53.000]  Не void ничего, то есть единственное значение конструктора – это создать объект.
[08:53.000 --> 08:55.000]  Дальше.
[08:55.000 --> 08:57.000]  Имя этого метода обязаны совпадать с именем класса.
[08:57.000 --> 08:59.000]  То есть если вы пишете метод, у которого имя совпадает с именем класса,
[08:59.000 --> 09:01.000]  это конструктор.
[09:01.000 --> 09:03.000]  Ну и конструктор вызывается неявно при создании объекта.
[09:03.000 --> 09:05.000]  То есть вручную конструктор вам вызывать не нужно.
[09:05.000 --> 09:07.000]  Он вызывается всякий раз, когда вы создаете объект.
[09:07.000 --> 09:09.000]  Когда вы создаете объект,
[09:09.000 --> 09:12.000]  когда вы создаете объект, конструктор вызывается автоматом.
[09:12.000 --> 09:16.000]  Ну давайте попробуем написать какой-нибудь пример конструктора для класса stack.
[09:16.000 --> 09:19.000]  Ну вот пример. Что тут происходит?
[09:19.000 --> 09:22.000]  У меня имя метода совпадает с именем класса stack.
[09:22.000 --> 09:25.000]  Этот конструктор в данной ситуации ничего не принимает.
[09:25.000 --> 09:27.000]  Видно, что он ничего не возвращает.
[09:27.000 --> 09:30.000]  Ну и дальше я просто фигурно-скопко пишу те действия, которые мне необходимо сделать.
[09:30.000 --> 09:33.000]  Но в частности, при создании stack мне нужно проинитилизировать буфер,
[09:33.000 --> 09:37.000]  то есть выделить память. Ну и сказать, что size равен нулю.
[09:37.000 --> 09:42.000]  Ну и написав такой конструктор, теперь при создании объекта stack
[09:42.000 --> 09:46.000]  у меня все вот эти действия будут выполняться автоматически.
[09:46.000 --> 09:49.000]  То есть теперь вот в этой строке происходит,
[09:49.000 --> 09:52.000]  ну во-первых, создается переменная типа stack,
[09:52.000 --> 09:55.000]  а во-вторых, сам stack инициализируется вот таким способом, как я описал.
[09:55.000 --> 09:58.000]  То есть таким образом мы вроде как избавились от метода init.
[09:58.000 --> 10:00.000]  Круто? Вот.
[10:00.000 --> 10:03.000]  Ну и теперь давайте, ну собственно это такой небольшой пример,
[10:03.000 --> 10:05.000]  значит все понятно, то есть по синтаксису.
[10:05.000 --> 10:07.000]  Сейчас мы будем подробно обсуждать все виды стеков,
[10:07.000 --> 10:10.000]  все виды конструкторов, какие они бывают и так далее.
[10:15.000 --> 10:17.000]  В смысле, типа void.
[10:19.000 --> 10:21.000]  Ну типа как-то вот так.
[10:21.000 --> 10:24.000]  Скорее всего он скажет, что вы неправильно пишете конструктор.
[10:28.000 --> 10:29.000]  Не обязательно.
[10:29.000 --> 10:32.000]  Естественно, если вы пишете конструкторы,
[10:32.000 --> 10:34.000]  то как и любые другие методы могут быть написаны
[10:34.000 --> 10:36.000]  как в публичной области, так и в приватной области.
[10:36.000 --> 10:38.000]  Если вы пишете конструктор в приватной области,
[10:38.000 --> 10:41.000]  то это означает, что внешний код не имеет права пользоваться этим конструктором.
[10:41.000 --> 10:43.000]  Ну вот в частности давайте,
[10:43.000 --> 10:48.000]  что произойдет, если я тут public заменю на private.
[10:50.000 --> 10:52.000]  У меня вот эта строка, последняя,
[10:52.000 --> 10:54.000]  она просто наоборот не скомпилируется.
[10:54.000 --> 10:58.000]  Потому что в этом месте компилятор попытается вызвать конструктор,
[10:58.000 --> 11:01.000]  но зафейлится, потому что он приватный.
[11:03.000 --> 11:11.000]  И на самом деле существует целая классификация видов конструкторов.
[11:12.000 --> 11:14.000]  И каждый их из них обладает своими свойствами.
[11:14.000 --> 11:17.000]  Классическая классификация выглядит следующим образом.
[11:17.000 --> 11:19.000]  Есть параметрический конструктор,
[11:19.000 --> 11:20.000]  есть конструктор преобразования,
[11:20.000 --> 11:22.000]  есть конструктор по умолчанию,
[11:22.000 --> 11:24.000]  есть конструктор копирования, есть конструктор перемещения.
[11:24.000 --> 11:26.000]  Ну про конструктор перемещение будет отдельная история,
[11:26.000 --> 11:28.000]  будем говорить через несколько лекций.
[11:28.000 --> 11:32.120]  это отдельная история, будем говорить через несколько лекций.
[11:32.120 --> 11:36.040]  Давайте поподробнее мы говорим про каждый из этих видов.
[11:36.040 --> 11:41.000]  Первый вид erstуктора самый простой – параметрический конструктор.
[11:41.000 --> 11:43.340]  Давайте будем называть параметрическим конструктором
[11:43.340 --> 11:47.340]  любой конструктор, который может принимать более одного аргумента Л丈夫.
[11:47.340 --> 11:49.640]  Если конструктор принимает более одного аргумента,
[11:49.640 --> 11:52.740]  то будем говорить, что это просто обычный параметрический конструктор.
[11:52.740 --> 11:53.920]  Большой пример.
[11:53.920 --> 11:59.320]  Допустим, я хочу уметь создавать стэки таким образом.
[11:59.320 --> 12:03.120]  Я хочу стэку передавать размер и те элементы, которые он должен хранить изначально.
[12:03.120 --> 12:07.620]  Допустим, я хочу создать стэк, который изначально заполнен 10 единицами.
[12:07.620 --> 12:10.620]  Я хочу уметь так делать, потому что мне так удобнее, допустим.
[12:10.620 --> 12:15.620]  Я не хочу в цикле вызывать push, я хочу, чтобы у меня сразу стэк был определенного размера с определенными значениями.
[12:15.620 --> 12:19.620]  Чтобы так сделать, я могу написать конструктор.
[12:19.620 --> 12:23.620]  Я пишу стэк, снова без возвращаемого значения, снова метод называется так же, как и обычный класс.
[12:24.320 --> 12:27.320]  Ну и дальше я передаю ему аргументы.
[12:27.320 --> 12:31.320]  Соответственно, первый метод это size, то есть каким размером мне нужно проинитиализировать стэк.
[12:31.320 --> 12:35.320]  Ну и второй параметр, это какими значениями мне нужно стэк заполнить.
[12:35.320 --> 12:39.320]  Ну и дальше в фигурных скобках я делаю необходимые действия.
[12:39.320 --> 12:44.320]  Завожу новый буфер, завожу, соответственно, инициализирую size,
[12:44.320 --> 12:49.320]  в значении не инициализирую, а присваиваю size нужное значение.
[12:50.020 --> 12:54.020]  И в цикле, собственно, заполняю мой стэк.
[12:54.020 --> 12:58.020]  И теперь как я могу вызвать этот конструктор?
[12:58.020 --> 13:02.020]  Теперь, когда у меня есть такой конструктор, который вынимает два аргумента,
[13:02.020 --> 13:06.020]  я могу создавать стэк с помощью аргумента вот таким образом.
[13:06.020 --> 13:10.020]  То есть я пишу имя типа или переменный, и дальше в круглых скобках я указываю,
[13:10.020 --> 13:14.020]  с какими параметрами мне нужно проинитиализировать этот стэк.
[13:14.020 --> 13:18.020]  И вот эта запись означает, что при создании стэка у меня будет вызван вот этот конструктор, который описан выше.
[13:18.720 --> 13:22.720]  Ну альтернативные способы создания здесь также указаны.
[13:22.720 --> 13:26.720]  Можно через присваивающую инициализацию это все делать абсолютно эквивалентно.
[13:30.720 --> 13:34.720]  Ну все, после того как у меня отработал этот конструктор, я могу спокойно обращаться к size, к top,
[13:34.720 --> 13:38.720]  и, собственно, все работает так, как нужно.
[13:40.720 --> 13:46.720]  Теперь давайте поговорим о важной детали конструкторов, про списки инициализации.
[13:48.720 --> 13:54.720]  Значит, давайте рассмотрим такой пример.
[13:54.720 --> 13:58.720]  Вот представьте себе, что у меня есть класс B, у которого есть константное поле типа int,
[13:58.720 --> 14:02.720]  и у которого есть ссылочное поле, которое ссылается на double.
[14:02.720 --> 14:06.720]  Вот x и y. x это константа, y это ссылка.
[14:06.720 --> 14:10.720]  И вот я хочу написать конструктор, который в конструкторе, который в качестве параметров принимает
[14:10.720 --> 14:14.720]  значение, которое должен быть проинитиализирован x, и значение, которым должен быть проинитиализирован y.
[14:15.420 --> 14:19.420]  Ну точнее значение, с которым должен связаться y.
[14:19.420 --> 14:23.420]  Ну и в конструкторе я, собственно, что делаю. Я говорю, что x у меня должен быть равен x,
[14:23.420 --> 14:27.420]  у которого мне передали, и y должен ссылаться на y, который мне передали.
[14:27.420 --> 14:31.420]  Ну казалось бы, все нормально. Ну и дальше я создаю объект типа B,
[14:31.420 --> 14:35.420]  передаю ему 0 и z. То есть понятно, что в качестве второго аргумента я могу передать только
[14:35.420 --> 14:39.420]  так называемое lvalue, то есть, грубо говоря, переменную или то, что имеет какое-то место в памяти,
[14:40.120 --> 14:42.120]  потому что на это можно было ссылаться.
[14:42.120 --> 14:44.120]  Вот как вы думаете, все ли будет нормально?
[14:48.120 --> 14:50.120]  Почему?
[14:50.120 --> 14:56.120]  А нет, в чем проблема?
[14:56.120 --> 14:58.120]  Методы же могут обращаться к приватным полям.
[14:58.120 --> 15:02.120]  Ну то есть если бы мы не могли в принципе обращаться к приватным полям,
[15:02.120 --> 15:06.120]  тогда бы конструкторы были нафиг не нужны, потому что если конструкторы не могут
[15:06.120 --> 15:08.120]  обращаться к приватным полям, то как они тогда что-то инициализируют?
[15:08.820 --> 15:10.820]  То есть, естественно, конструкторы к приватным вариантам тоже имеют доступ.
[15:12.820 --> 15:14.820]  На самом деле будет довольно неожиданная проблема.
[15:16.820 --> 15:19.820]  Компилятор нам скажет, что, во-первых, у меня не проинициализировано
[15:19.820 --> 15:21.820]  константное поле x в первой строке.
[15:21.820 --> 15:23.820]  Во-вторых, он скажет, что у меня не проинициализирована ссылка
[15:23.820 --> 15:25.820]  во второй строке.
[15:25.820 --> 15:29.820]  И в-третьих, он скажет, что по какой-то причине я пытаюсь сделать присваивание
[15:29.820 --> 15:31.820]  члену, который доступен только на чтение.
[15:33.820 --> 15:35.820]  Что-то не то происходит, да?
[15:36.520 --> 15:38.520]  То есть, казалось бы, я сделал x равно x, y равно y,
[15:38.520 --> 15:40.520]  то есть вроде как я их проинициализировал.
[15:40.520 --> 15:42.520]  А компилятор жалуется, что я их не проинициализировал это раз,
[15:42.520 --> 15:44.520]  а во-вторых, он жалуется, что я пытаюсь как-то изменить
[15:44.520 --> 15:46.520]  поле, которое доступно только для чтения.
[15:46.520 --> 15:48.520]  Но в частности, это x.
[15:50.520 --> 15:52.520]  Ну и проблема на самом деле заключается в следующем.
[15:52.520 --> 15:56.520]  На самом деле то, что вы пишете внутри фигурных скобок в конструкторе,
[15:56.520 --> 15:58.520]  это не инициализация.
[15:58.520 --> 16:00.520]  Ну, точнее так.
[16:00.520 --> 16:02.520]  Это инициализация, но это инициализация стека.
[16:03.220 --> 16:04.660]  Вот.
[16:04.660 --> 16:06.660]  Вот то, что Вы пишете здесь,
[16:06.660 --> 16:08.540]  это...
[16:08.540 --> 16:10.540]  это присваивание, анициализация.
[16:10.540 --> 16:11.820]  Давайте так скажем.
[16:11.820 --> 16:13.820]  Смотрите, чтобы вам к чему-то оборотиться внутри фигурных скобок,
[16:13.820 --> 16:15.820]  Вам нужно что-бы это что-то было уже создано.
[16:15.820 --> 16:17.320]  Согласны?
[16:17.320 --> 16:19.320]  Допустим, что-бы я мог обратиться к x чертой,
[16:19.320 --> 16:21.320]  это x чертой должно быть уже где-то создано,
[16:21.320 --> 16:23.320]  должно уже быть как-то проинициализировано.
[16:23.420 --> 16:25.420]  y с чертой то же самое.
[16:25.420 --> 16:27.420]  Что-бы я мог обратиться к y с чертой,
[16:27.420 --> 16:29.420]  оно тоже должно быть как-то уже проинициализировано.
[16:29.420 --> 16:31.420]  То есть, грубо говоря, внутри у меня все поля
[16:31.420 --> 16:36.420]  и дальше внутри фигуринскобок я с ними только работаю.
[16:36.420 --> 16:39.420]  Но в частности, вот тут я пытаюсь заново присвоить какое-то другое значение х
[16:39.420 --> 16:43.420]  и заново присвоить какое-то другое значение в у.
[16:43.420 --> 16:48.420]  Понятно? Понятно разница между присваиванием и инициализацией?
[16:48.420 --> 16:53.420]  То есть, грубо говоря, когда я пишу вот так, это что?
[16:53.420 --> 16:55.420]  Инициализация или присваивание?
[16:55.420 --> 16:59.420]  Инициализация. Да, я задаю начальное значение при создании.
[16:59.420 --> 17:01.420]  А вот это? Это присваивание.
[17:01.420 --> 17:04.420]  Да, то есть х у меня уже проинциализирован, то есть х у меня уже есть в памяти,
[17:04.420 --> 17:07.420]  он уже создан, и дальше я просто заменяю его значение.
[17:07.420 --> 17:09.420]  Вот в конструкторе происходит то же самое.
[17:09.420 --> 17:11.420]  Когда вы заходите в тело конструктора,
[17:11.420 --> 17:16.420]  предполагается, что все элементы, все поля уже проинциализированы.
[17:16.420 --> 17:18.420]  Понятно?
[17:18.420 --> 17:23.420]  Ну и возникает парадокс C++ очередной.
[17:23.420 --> 17:25.420]  Мне нужно как-то проинциализировать поля,
[17:25.420 --> 17:27.420]  и мне их нужно проинциализировать в конструкторе.
[17:27.420 --> 17:30.420]  Но как только я захожу в конструктор, они уже проинциализированы.
[17:30.420 --> 17:31.920]  Что делать?
[17:31.920 --> 17:35.420]  Внутри фигурных скобок, то есть внутри тела конструктора,
[17:35.420 --> 17:37.420]  я их проинциализировать не могу.
[17:37.420 --> 17:39.420]  где мне их нужно проинциализировать?
[17:39.420 --> 17:43.420]  На самом деле, мне их нужно проинциализировать до входа тела конструктора.
[17:43.420 --> 17:46.420]  То есть до фигurdных скобок внезапно.
[17:46.420 --> 17:49.420]  И вот такой синтаксис называется...
[17:49.420 --> 17:51.420]  Как называется?
[17:51.420 --> 17:54.420] ès Shelley
[17:54.420 --> 18:00.420]  Как проинициализировать поля класса правильно? Делайте следующим образом.
[18:00.420 --> 18:06.420]  До входа в тело конструктора, то есть между прототипом конструктора и между телом конструктора,
[18:06.420 --> 18:10.420]  то есть открывающейся фигурной скопкой, вы пишете следующую вещь.
[18:10.420 --> 18:15.420]  Двоеточие. Ну и даже через запятую инициализируйте поля.
[18:15.420 --> 18:21.420]  Вот то, что пишется вот здесь, вот здесь происходит инициализация.
[18:21.420 --> 18:25.420]  То есть вы задаете начальные значения ваших полей.
[18:25.420 --> 18:28.420]  Вот если я напишу так, то теперь все будет работать как надо.
[18:28.420 --> 18:32.420]  То есть если я попытаюсь создать объект B с помощью нуля и Z,
[18:32.420 --> 18:38.420]  у меня X чертой проинициализируется нулем, Y чертой проинициализируется ссылкой на Z,
[18:38.420 --> 18:43.420]  и дальше, когда я вошел в тело конструктора, у меня уже вот эти значения будут проинициализированы нужными значениями,
[18:43.420 --> 18:48.420]  и я могу с ними как-то дальше продолжать работать. Понятно?
[18:49.420 --> 18:54.420]  Да, об этом будет отдельный слайд. Важно.
[18:54.420 --> 18:59.420]  Точнее так, не важно, но мы поговорим об этом.
[18:59.420 --> 19:03.420]  Все понятно, что здесь происходит.
[19:03.420 --> 19:08.420]  Вот то, что вы пишете здесь, то, что помечено здесь, это инициализация.
[19:08.420 --> 19:12.420]  Вы сдаете начальное значение. Поэтому важное правило.
[19:12.420 --> 19:16.420]  Если вы хотите что-то проинициализировать, то есть вы хотите задать какие-то начальные значения в конструкторе,
[19:16.420 --> 19:20.420]  старайтесь это как можно больше делать в списках инициализации,
[19:20.420 --> 19:24.420]  потому что это правильнее.
[19:24.420 --> 19:28.420]  Если вы так не делаете, то давайте вернемся к стеку.
[19:28.420 --> 19:32.420]  Что здесь происходит? Здесь происходит следующая вещь.
[19:32.420 --> 19:36.420]  Сначала компилятор вам создает ваши переменные по умолчанию,
[19:36.420 --> 19:41.420]  а затем вы как будто бы присваиваете,
[19:41.420 --> 19:45.420]  если вы не написали список инициализации, то компилятор это все проинициализирует как-то по умолчанию.
[19:45.420 --> 19:49.420]  То есть он сначала их создает, и сохранит какое-то мусорное значение, которое лежало в памяти до этого.
[19:49.420 --> 19:53.420]  А уже потом, после этого, вы пытаетесь что-то менять.
[19:53.420 --> 19:57.420]  В частности, пишете size равно чему-то, и буфер равно чему-то.
[19:57.420 --> 20:01.420]  Вместо того, чтобы сразу вы не выкопали, а вы не выкопали,
[20:01.420 --> 20:05.420]  то есть вы не выкопали, а вы не выкопали.
[20:05.420 --> 20:09.420]  И буфер равно чему-то.
[20:09.420 --> 20:13.420]  Вместо того, чтобы сразу написать то, что вы хотите.
[20:13.420 --> 20:17.420]  Согласитесь, что второй способ гораздо более эффективный, чем первый.
[20:17.420 --> 20:23.420]  В данном случае не более эффективный, но представьте, что с качества полей возникают какие-то другие тяжелые объекты.
[20:23.420 --> 20:29.420]  Когда вы сначала создаете тяжелый объект, а потом внутри конструктора сразу его как-то изменяете.
[20:29.420 --> 20:33.420]  Согласитесь, гораздо логично сразу создать его таким, каким он должен быть.
[20:33.420 --> 20:41.420]  А если мы, например, как-то инициируем объект, который намного сложнее чем переменная,
[20:41.420 --> 20:47.420]  например, это список, то участием можно создать функцию, которая будет возвращать, например, носик,
[20:47.420 --> 20:55.420]  и указать в спокус при децентрализации функцию от нашего агумента и стат.
[20:55.420 --> 21:01.420]  Что вы имеете в виду?
[21:01.420 --> 21:05.420]  Если у вас само поле является каким-то другим объектом,
[21:05.420 --> 21:09.420]  во-первых, в списке инициализации мы об этом поговорим позже, но можно вызывать другие конструкторы.
[21:09.420 --> 21:13.420]  То есть объект можно проинциализировать его конструктором.
[21:13.420 --> 21:17.420]  Если у вас поле поддерживает конструктор, то вы можете...
[21:17.420 --> 21:21.420]  Пусть у B есть поле stack.
[21:21.420 --> 21:25.420]  И вот я могу списки инициализации через двоеточие указать до фигурной скобки.
[21:25.420 --> 21:31.420]  Указать S и в скобках указать параметры конструктора, и тогда он создается.
[21:31.420 --> 21:35.420]  Если вам нужна какая-то более сложная инициализация,
[21:35.420 --> 21:39.420]  можно написать какую-то функцию, которая возвращает нужный вам объект.
[21:39.420 --> 21:45.420]  И вы ее можете передать в круглой скобке, но тогда это будет работать как то,
[21:45.420 --> 21:49.420]  что вы внутри функции F создали объект, а потом его скопировали в нужный вам.
[21:49.420 --> 21:53.420]  Копирования, скорее всего, не будет, но грубо говоря, так.
[22:01.420 --> 22:05.420]  Ну и здесь то, про что я говорил минут назад.
[22:05.420 --> 22:13.420]  Если вы не пишете список инициализации, то компилятор все равно его вам напишет,
[22:13.420 --> 22:17.420]  но только он все поля проинциализирует так, как он хочет.
[22:17.420 --> 22:21.420]  Грубо говоря, если это просто какие-то инты в латын, то-есть примитивный тип,
[22:21.420 --> 22:25.420]  он там просто ничего не инфтилизирует не будет, просто там сохранится мусор.
[22:25.420 --> 22:31.420]  А если поля являются этими классами или структурами,
[22:31.420 --> 22:33.420]  то они будут проинциализированы по умолчанию.
[22:33.420 --> 22:37.420]  Про то, что такое по умолчанию, что такое конструктор по умолчанию, поговорим позже.
[22:37.420 --> 22:41.420]  В общем, самое главное, который надо помнить, что даже если вы не пишете списка инициализации,
[22:41.420 --> 22:44.420]  компилятор все равно его напишет за вас, но вам может не понравится, что он там напишет.
[22:47.420 --> 22:57.420]  Потому что компилятор не может проинцелизировать константы.
[22:57.420 --> 23:01.420]  Он пытается проинцелизировать, но если у него что-то не получается, то он паникует.
[23:01.420 --> 23:04.420]  Вот константы сами по себе не инцелизируются. Ну вы помните.
[23:04.420 --> 23:06.420]  Ну и ссылки сами по себе никак не инцелизируются.
[23:06.420 --> 23:08.420]  Вот поэтому тут проблема.
[23:08.420 --> 23:13.420]  Если бы тут был просто int или просто double, то все было бы нормально.
[23:13.420 --> 23:15.420]  Обычные значения инцелизируются мусором.
[23:15.420 --> 23:21.420]  Да, ну и тут вот как раз второй пункт.
[23:21.420 --> 23:25.420]  Если какое-то поле не проинцелизировано, то компилятор попытается проинцелизировать его самостоятельно.
[23:25.420 --> 23:28.420]  Вот важное слово «попытается», но у него может не получиться.
[23:28.420 --> 23:31.420]  Если не получится, то вы получите ошибку компиляции, естественно.
[23:31.420 --> 23:40.420]  И тот вопрос, который вы задавали про порядок в списке инцелизации.
[23:41.420 --> 23:49.420]  Значит, порядок создания полей определяется порядком следования их внутри класса, а не внутри списка инцелизации.
[23:49.420 --> 23:55.420]  Короче, компилятор будет инцелизировать ваши поля ровно в том порядке, в котором вы указали их в структуре,
[23:55.420 --> 23:58.420]  в котором они перечислены вот здесь.
[23:58.420 --> 24:02.420]  Вот порядок здесь компилятор будет игнорировать полностью.
[24:02.420 --> 24:07.420]  Ну вот пример такой, классическая ошибка.
[24:07.420 --> 24:12.420]  У меня есть структура A, у которой есть три поля интовых X, Y и Z.
[24:12.420 --> 24:16.420]  И я хочу, чтобы все три поля были сразу проинцелизированы одним и тем же значением,
[24:16.420 --> 24:18.420]  которое я передаю в конструктор, то есть в value.
[24:18.420 --> 24:20.420]  Ну и как бы я делаю следующий вещь.
[24:20.420 --> 24:24.420]  Я говорю, ну давайте я сначала проинцелизирую Z, передам ему значение в value.
[24:24.420 --> 24:27.420]  Дальше я проинцелизирую X тем же значением, который лежит в Z.
[24:27.420 --> 24:30.420]  Ну как бы я предполагаю, что в Z у меня сейчас лежит в value.
[24:30.420 --> 24:32.420]  Казалось бы, все нормально.
[24:32.420 --> 24:35.420]  Ну а потом X я проинцелизирую тем же, что лежит в Y.
[24:35.420 --> 24:37.420]  В этом случае лежит тоже в value.
[24:37.420 --> 24:41.420]  То есть я предполагаю, что все поля у меня проинцелизируются значением в данном случае 11.
[24:41.420 --> 24:44.420]  Но при этом, когда я попытаюсь вывести на экран, то я увижу,
[24:44.420 --> 24:47.420]  что 11 у меня проинцелизировался только Z,
[24:47.420 --> 24:50.420]  а все остальные содержат какие-то странные значения.
[24:50.420 --> 24:52.420]  Почему так получилось?
[24:52.420 --> 24:55.420]  А потому что компилятору плевать, что вы написали списки интеллизации.
[24:55.420 --> 24:57.420]  Точнее плевать в каком порядке вы что-то написали.
[24:57.420 --> 24:59.420]  Компилятор сначала посмотрит и увидит.
[24:59.420 --> 25:02.420]  Сначала идет поле X, поэтому он интеллизирует X, Y.
[25:02.420 --> 25:05.420]  А в Y хранится мусор, поэтому X тоже проинцелизируется мусором.
[25:05.420 --> 25:08.420]  Дальше он смотрит, дальше идет Y, поэтому он интеллизирует Y.
[25:08.420 --> 25:12.420]  В Z лежит мусор, поэтому в Y лежит теперь какой-то другой мусор.
[25:12.420 --> 25:15.420]  То есть старый мусор убрали, новый положили.
[25:15.420 --> 25:18.420]  И только в конце самом проинцелизируется Z.
[25:18.420 --> 25:22.420]  Ну вот Z как раз повезло, и он будет проинцелизирован нормально.
[25:22.420 --> 25:26.420]  А вот вы когда описывали списки интеллизации,
[25:26.420 --> 25:29.420]  я как-то поняла, что у нас при создании перемены
[25:29.420 --> 25:32.420]  сразу где-то описывается то, что с кодом.
[25:32.420 --> 25:36.420]  Чего же здесь уйдет, например, о моей зафотографии с мусором,
[25:36.420 --> 25:39.420]  кто дал вам?
[25:39.420 --> 25:42.420]  Ну смотрите, что такое перемена?
[25:42.420 --> 25:44.420]  Перемена – это ссылка на область памяти.
[25:44.420 --> 25:47.420]  Грубо говоря, когда вы звели какое-то имя,
[25:47.420 --> 25:50.420]  вот этому имени уже поставлена в соответствие какая-то область памяти,
[25:50.420 --> 25:52.420]  но еще не проинцелизированная.
[25:52.420 --> 25:55.420]  И здесь как раз про то же самое.
[25:55.420 --> 25:58.420]  За Y может закопиться, грубо говоря, вот у вас есть адрес дома,
[25:58.420 --> 26:01.420]  вы купили строящийся дом.
[26:01.420 --> 26:04.420]  Место вроде как у вас есть, а дом сам не построен.
[26:04.420 --> 26:07.420]  Адрес вы можете там прочитать.
[26:07.420 --> 26:10.420]  То есть Y связан с каким-то местом в памяти, но оно еще не проинцелизировано.
[26:14.420 --> 26:17.420]  Ну и правильный вариант выглядит следующим образом.
[26:17.420 --> 26:20.420]  Что про инцелизацию?
[26:20.420 --> 26:23.420]  Минцелизация в ровном том порядке, в котором она указана в полях структуры.
[26:23.420 --> 26:26.420]  Вот если вы сделаете так, сначала проинцелизируете X,
[26:26.420 --> 26:29.420]  потом Y проинцелизируете тем же, чем проинцелизирован X,
[26:29.420 --> 26:32.420]  а дальше Z проинцелизируете Y,
[26:32.420 --> 26:35.420]  то все будет работать нормально.
[26:35.420 --> 26:38.420]  Потому что сначала инцелизируется X, туда записывается value,
[26:38.420 --> 26:41.420]  дальше Y проинцелизируется X,
[26:41.420 --> 26:44.420]  там уже нормальное значение,
[26:44.420 --> 26:47.420]  Вот так работают. Понятно?
[26:47.420 --> 26:51.420]  То есть порядок создания полей определяется порядком объявления в классе,
[26:51.420 --> 26:54.420]  но не порядком списка инициализации, это важно.
[26:54.420 --> 26:59.420]  Ну и нормальный компилятор на самом деле вам скажет, что вы делаете что-то не так,
[26:59.420 --> 27:02.420]  если вы написали в списке инициализации в другом порядке.
[27:02.420 --> 27:06.420]  То есть если вы с достаточным уровнем предупреждения его поставили,
[27:06.420 --> 27:10.420]  то компилятор такие ситуации отслеживает и вам выдает предупреждение.
[27:10.420 --> 27:15.420]  Так, идем дальше...
[27:15.420 --> 27:18.420]  Следующий вид конструктора.
[27:18.420 --> 27:34.420]  Я напомню, мы разбираем виды конструктора.
[27:34.420 --> 27:36.920]  Вот если ровно один аргумент, то это конструктор преобразования.
[27:36.920 --> 27:39.620]  Вообще говоря, конструктор преобразования — это более широкое понятие,
[27:39.620 --> 27:43.620]  но, как правило, удовольствуются таким, и это нормально.
[27:43.620 --> 27:48.120]  Почему конструктор преобразования называется конструктором преобразования?
[27:48.120 --> 27:52.120]  Ну, потому что он используется для выполнения всевозможных преобразований типов.
[27:52.120 --> 27:56.120]  Например, вы знаете, что существуют стандартные преобразования типов.
[27:56.120 --> 28:02.120]  Типы float в double, int в long — типы могут преобразовываться друг в друга.
[28:02.820 --> 28:08.820]  Конструктор преобразования тоже может быть использован для преобразования одного типа в тип вашего класса, например.
[28:08.820 --> 28:15.820]  Вот пример. Я хочу написать конструктор стека, который принимает только один аргумент — это размер стека.
[28:15.820 --> 28:18.820]  То есть какое количество элементов у меня должно изначально лежать в стеке.
[28:18.820 --> 28:22.820]  Ну и все эти элементы я, допустим, хочу инициализировать нулем.
[28:22.820 --> 28:27.820]  То есть вот такой конструктор у меня создает size элементов, равных нулю.
[28:28.520 --> 28:33.520]  То есть я в списке инициализации создаю буфер, инициализирую массив нулями, фигурные скобки.
[28:33.520 --> 28:35.520]  Ну и дальше задаю size.
[28:35.520 --> 28:37.520]  Ну и теперь что у меня происходит?
[28:37.520 --> 28:39.520]  Теперь я могу, как обычно, вызывать конструктор.
[28:39.520 --> 28:45.520]  Ну, с помощью круглых скобок я пишу стек, ими перемены, и даже в круглых скобках с какими параметрами я вызываю конструктор.
[28:45.520 --> 28:48.520]  Дальше. Я могу сделать вот такую вещь.
[28:48.520 --> 28:50.520]  Казалось бы, довольно странно.
[28:50.520 --> 28:55.520]  Я могу стеку присвоить какое-то другое значение, которое равно какому-то целому значению.
[28:56.220 --> 28:59.220]  Окей? То есть стек равно 3.
[28:59.220 --> 29:02.220]  Более того, если у меня есть какая-то функция, которая принимает стек,
[29:02.220 --> 29:05.220]  я могу в эту функцию передать, ну, как переменную стек,
[29:05.220 --> 29:08.220]  а могу передать какое-то числовое значение, например, f от 10.
[29:08.220 --> 29:14.220]  И когда я вызываю f от 10, у меня 10 неявно преобразуется в стек и вызывается f от стека.
[29:14.220 --> 29:16.220]  Круто?
[29:18.220 --> 29:20.220]  Нет, это ж нифига не круто. Вы чего?
[29:20.220 --> 29:23.220]  Ну вот, смотрите, вот если вы смотрите на код и видите f от 10,
[29:23.920 --> 29:26.920]  вот с какой вероятностью вы думаете, что, ага, здесь вызывается функция от стека?
[29:26.920 --> 29:28.920]  Есть такие люди?
[29:28.920 --> 29:30.920]  Вот f от 10. Это f от стека, да?
[29:30.920 --> 29:33.920]  Нет, это бред. И тем более, когда вы идентифицируете стек числом,
[29:33.920 --> 29:35.920]  вот таким образом, ну это тоже что-то странное.
[29:35.920 --> 29:38.920]  Ну как вы стеку присваиваете какое-то число?
[29:38.920 --> 29:41.920]  Наверное, хотелось бы, чтобы такие вещи не работали.
[29:41.920 --> 29:43.920]  Ну, точнее так.
[29:43.920 --> 29:47.920]  Если вы пишете класс комплексного числа или класс рационального числа,
[29:47.920 --> 29:49.920]  то, наверное, это норм.
[29:50.620 --> 29:52.620]  То есть это норм, что у вас там десятка преобразуется в комплексное число
[29:52.620 --> 29:54.620]  или десятка преобразуется в рациональное число.
[29:54.620 --> 29:56.620]  Это нормально.
[29:56.620 --> 29:58.620]  Но если там десятка преобразуется в какой-нибудь стек,
[29:58.620 --> 30:00.620]  или десятка преобразуется в какого-то персонажа игры,
[30:00.620 --> 30:02.620]  которого вы пишете, ну странно.
[30:02.620 --> 30:06.620]  Хотелось бы такие вещи запрещать иногда.
[30:06.620 --> 30:08.620]  Чтобы такие вещи запретить,
[30:08.620 --> 30:10.620]  здесь специально ключевое слово explicit.
[30:10.620 --> 30:12.620]  Ну, от английского explicit это явный,
[30:12.620 --> 30:14.620]  вот implicit не явный.
[30:14.620 --> 30:16.620]  То есть explicit говорит, что этот конструктор
[30:16.620 --> 30:18.620]  нужно обязательно вызывать только явно.
[30:19.320 --> 30:21.320]  Неявно его вызывать запрещено.
[30:21.320 --> 30:23.320]  Ну, как это выглядит?
[30:23.320 --> 30:25.320]  Вы пишете ключевое слово explicit,
[30:25.320 --> 30:27.320]  ну и дальше пишете сам конструктор.
[30:27.320 --> 30:29.320]  Конструктор одного аргумента.
[30:29.320 --> 30:31.320]  Ну, на самом деле можно от нескольких,
[30:31.320 --> 30:33.320]  но, как правило, explicit пишут только для конструкторов с одним аргументом.
[30:33.320 --> 30:35.320]  Это явное указание конструктора,
[30:35.320 --> 30:37.320]  ой, явное указание компилятору,
[30:37.320 --> 30:39.320]  что данный конструктор можно использовать
[30:39.320 --> 30:41.320]  только для явных преобразований.
[30:41.320 --> 30:43.320]  Только для преобразований,
[30:43.320 --> 30:45.320]  которые вы попросили сами.
[30:45.320 --> 30:47.320]  То есть без вашего ведома,
[30:47.320 --> 30:49.320]  это совершать запрещено.
[30:49.320 --> 30:51.320]  То есть без вашего разрешения запрещено
[30:51.320 --> 30:53.320]  преобразовывать size t в stack.
[30:53.320 --> 30:55.320]  Вот.
[30:55.320 --> 30:57.320]  То есть теперь, когда вы написали конструктор с ключевым словом explicit,
[30:57.320 --> 30:59.320]  у вас вот такая штука.
[30:59.320 --> 31:01.320]  Не работает.
[31:01.320 --> 31:03.320]  То есть это считается
[31:03.320 --> 31:05.320]  неявным преобразованием тройки в stack.
[31:05.320 --> 31:07.320]  Такое вы запретили.
[31:07.320 --> 31:09.320]  Ну и вот такая строка тоже не работает.
[31:09.320 --> 31:11.320]  Неявно преобразовывать десятку в stack
[31:11.320 --> 31:13.320]  без вашего разрешения
[31:13.320 --> 31:15.320]  запрещено.
[31:15.320 --> 31:17.320]  Если вы все-таки хотите вызвать f от десятки
[31:17.320 --> 31:19.320]  по какой-то причине,
[31:19.320 --> 31:21.320]  вы должны явно попросить компилятора
[31:21.320 --> 31:23.320]  об этом.
[31:23.320 --> 31:25.320]  Написать stack от 10.
[31:25.320 --> 31:27.320]  То есть вы тут явно попросили,
[31:27.320 --> 31:29.320]  что нужно десятку преобразовать в stack
[31:29.320 --> 31:31.320]  и только потом вызвать функцию f.
[31:31.320 --> 31:33.320]  Вот назначение
[31:33.320 --> 31:35.320]  в слово explicit.
[31:35.320 --> 31:37.320]  Дальше.
[31:41.320 --> 31:43.320]  На этом с конструктором
[31:43.320 --> 31:45.320]  преобразование все.
[31:45.320 --> 31:47.320]  Теперь очередной вид конструктора
[31:47.320 --> 31:49.320]  это конструктор по умолчанию.
[31:49.320 --> 31:51.320]  Конструктор по умолчанию
[31:51.320 --> 31:53.320]  это конструктор, который
[31:53.320 --> 31:55.320]  может быть вызван без аргументов.
[31:55.320 --> 31:57.320]  Ну мы идем по уменьшению
[31:57.320 --> 31:59.320]  количества аргументов.
[31:59.320 --> 32:01.320]  Короче говоря.
[32:01.320 --> 32:03.320]  Если вы пишите конструктор,
[32:03.320 --> 32:05.320]  который не принимает аргументов,
[32:05.320 --> 32:07.320]  то этот конструктор будет выubbyн
[32:07.320 --> 32:09.320]  когда вы создаете объект
[32:09.320 --> 32:11.320]  и не передаете ему ничего в круглых скопках.
[32:11.320 --> 32:16.320]  Если вы задаете объект и ничего в круглоскопах не передаете, то в этом случае работает конструктор по умолчанию.
[32:16.320 --> 32:20.320]  То есть так или как-то вот так, с помощью присваивающегося синтаксиса.
[32:20.320 --> 32:23.320]  И вот тут есть важный момент, очередной странный момент C++.
[32:23.320 --> 32:32.320]  Вот смотрите, до этого мы могли спокойно вызвать вот такие конструкторы таким образом.
[32:32.320 --> 32:36.320]  То есть писать стек и даже в круглоскопах указывать, что нужно передать.
[32:36.320 --> 32:40.320]  Казалось бы, чтобы вызвать конструктор по умолчанию, наверное, хотелось бы, чтобы можно было делать точно так же.
[32:40.320 --> 32:43.320]  Вот так. Ну просто передать круглые скопки.
[32:43.320 --> 32:46.320]  Но вот оказывается, что так делать нельзя по довольно странной причине.
[32:46.320 --> 32:53.320]  Вот если посмотреть на вот эту запись, то она должна вам очень сильно напоминать объявление функции.
[32:53.320 --> 32:58.320]  Объявление функции other, которая ничего не принимает и возвращает стек.
[32:58.320 --> 33:01.320]  И компилятор воспринимает это точно так же.
[33:01.320 --> 33:06.320]  То есть он думает, что когда вы написали вот так, это значит вы объявили функцию other, которая возвращает стек и ничего не принимает.
[33:06.320 --> 33:11.320]  И вот по такой причине вот так писать нельзя. Можно писать только вот так или вот так.
[33:19.320 --> 33:21.320]  Ну и, собственно, такой вопрос.
[33:21.320 --> 33:26.320]  Вот смотрите, до этого мы вроде как про конструкторы вообще ничего не знали.
[33:26.320 --> 33:29.320]  Например, на прошлой лекции мы вообще ничего не говорили про конструкторы.
[33:29.320 --> 33:34.320]  Но при этом мы спокойно создавали стек без аргументов, дальше вызывали какие-то методы, и это все даже работало.
[33:34.320 --> 33:37.320]  Вот вопрос. Ну, смотрите, мы не написали ни одного конструктора.
[33:37.320 --> 33:40.320]  Более того, в прошлом семестре вы не писали ни одного конструктора.
[33:40.320 --> 33:42.320]  Вы писали структуру, но при этом конструкторы не писали.
[33:42.320 --> 33:45.320]  Но при этом вы могли спокойно создавать объекты без аргументов. Как так?
[33:45.320 --> 33:48.320]  Вы писали значение по умолчанию?
[33:48.320 --> 33:53.320]  Нет. В стеке мы не писали значение по умолчанию.
[33:53.320 --> 34:10.320]  Нет, мы так не делали, на самом деле. То есть когда мы писали стек, то есть в принципе вы можете не писать ничего.
[34:10.320 --> 34:17.320]  То есть когда мы писали стек, у нас был просто указатель на буфер и сайс.
[34:17.320 --> 34:19.320]  То есть мы ничего тут не указывали.
[34:19.320 --> 34:23.320]  Мы просто всю инициализацию указывали в методе init.
[34:23.320 --> 34:25.320]  Вот на прошлой лекции.
[34:25.320 --> 34:29.320]  Именно в методе init мы присваивали мультр или что-то еще.
[34:29.320 --> 34:33.320]  То есть даже если вы по умолчанию ничего не укажете, то это все равно будет работать.
[34:33.320 --> 34:37.320]  И все это по следующей причине.
[34:37.320 --> 34:47.320]  Это потому, что если вы не написали ни одного конструктора, то есть если вы компилятору дали понять,
[34:47.320 --> 34:53.320]  что вы находитесь в первом семестре и вы вообще ничего не знаете про конструкторы, то компилятор любезно за вас напишет свой конструктор.
[34:53.320 --> 35:05.320]  То есть правило такое, если вы в классе не объявляете ни одного конструктора, то компилятор напишет конструктора по умолчанию за вас.
[35:05.320 --> 35:09.320]  Важный момент, он напишет за вас только конструктор по умолчанию.
[35:09.320 --> 35:11.320]  Хорошо, не только.
[35:11.320 --> 35:13.320]  Давайте так.
[35:13.320 --> 35:15.320]  Все, остановимся на этом.
[35:15.320 --> 35:19.320]  Если вы не пишете ни одного конструктора, не объявляете ни одного конструктора, то компилятор за вас пишет конструктор по умолчанию.
[35:19.320 --> 35:23.320]  Что будет делать этот конструктор по умолчанию?
[35:23.320 --> 35:25.320]  Каким он будет?
[35:25.320 --> 35:27.320]  Тут есть три возможностей ответа.
[35:27.320 --> 35:31.320]  Самый слабый ответ заключается в том, что он просто-напросто ничего не сделает.
[35:31.320 --> 35:35.320]  Просто-напросто проренетилизирует все поля мусором.
[35:35.320 --> 35:37.320]  Это не совсем правда.
[35:37.320 --> 35:41.320]  Если у вас класс или структура состоит только из полей примитивных типов.
[35:41.320 --> 35:45.320]  Если у вас все поля примитивные типы, то действительно там будет просто храниться мусор, ничего другого.
[35:45.320 --> 35:55.320]  Более правильный ответ заключается в том, что если вы не пишете свой конструктор, то компилятор пишет за вас конструктор по умолчанию, который все поля инициализирует по умолчанию.
[35:55.320 --> 35:57.320]  Точнее, вызывает у всех конструктор по умолчанию.
[35:57.320 --> 36:03.320]  Но это тоже не совсем правда, потому что у примитивных типов конструктор по умолчанию, естественно, нет.
[36:03.320 --> 36:07.320]  Это не констанция конструктора по умолчанию, потому что это не класс и не структура.
[36:07.320 --> 36:09.320]  Наиболее полный ответ заключается следующим образом.
[36:09.320 --> 36:17.320]  Когда компилятор создает вам конструктор по умолчанию, все примитивные типы он инициализирует мусором, то есть никак их не инициализирует.
[36:17.320 --> 36:23.320]  А если у вас в качестве полей выступают другие классы или другие структуры, то для них он вызовет конструктор по умолчанию.
[36:24.320 --> 36:27.320]  А если у вас константные поля?
[36:27.320 --> 36:33.320]  Мы возвращаемся к физическому инициализации. Константные поля компилятор не умеет создавать.
[36:33.320 --> 36:36.320]  Там будет ошибка, да.
[36:36.320 --> 36:42.320]  Ну вот такой пример. У меня есть какой-то класс A, то есть как-то он написан, неважно, ну и допустим у него есть свой конструктор по умолчанию.
[36:42.320 --> 36:50.320]  Вот я написал класс B, у которого есть поле X и у которого есть поле A.
[36:50.320 --> 36:54.320]  Ну и допустим в этом классе B я не написал своего конструктора по умолчанию.
[36:54.320 --> 36:57.320]  Точнее так, я вообще никакого конструктора не написал.
[36:57.320 --> 37:05.320]  И вот в этом случае я по-прежнему могу вызывать, точнее могу создавать объекты типа B без аргументов.
[37:05.320 --> 37:11.320]  В этом случае у меня поле X будет ничем не проинциализирован, точнее будет проинциализировано мусором.
[37:11.320 --> 37:18.320]  А для B точка A, точнее для этого поля A, у меня будет вызван конструктор по умолчанию.
[37:18.320 --> 37:28.320]  Естественно. То есть если в классе A, давайте так, если в классе A есть конструктор по умолчанию, то будет вызван именно он.
[37:28.320 --> 37:39.320]  Если в классе A, давайте так, если в классе A нет конструктора по умолчанию, то будет ошибка эмпиляции, но об этом сейчас поговорим.
[37:39.320 --> 37:42.320]  Давайте так, да.
[37:42.320 --> 37:48.320]  Естественно, вы для класса можете писать сколько угодно конструктора.
[37:48.320 --> 37:55.320]  То есть конструктора можно перегружать. Естественно, нельзя написать два конструктора, которые принимают один и тот же набор аргументов.
[37:55.320 --> 37:58.320]  Разные можно.
[37:58.320 --> 38:01.320]  Абсолютно, да.
[38:01.320 --> 38:10.320]  Но если вы в своем классе написали хотя бы один конструктор, то есть вы дали понять компилятору, что я знаю, что такое конструктор, и вот я пишу их,
[38:10.320 --> 38:14.320]  то компилятор вам не будет ничего создавать.
[38:14.320 --> 38:16.320]  Такое правило.
[38:16.320 --> 38:24.320]  В общем, если вы не написали ни одного конструктора, то компилятор вам создаст. Если написали хотя бы один, то все, забудьте.
[38:24.320 --> 38:35.320]  Ну и да, соответственно, тот конструктор, который представляет вам конструктор, то есть конструктор от государства, он выглядит вот таким образом.
[38:35.320 --> 38:40.320]  То есть он, грубо говоря, конструктор с пустым телом.
[38:40.320 --> 38:47.320]  Но при этом мы помним, что если написали список инициализации, то список инициализации все равно выполняется.
[38:47.320 --> 38:57.320]  Именно поэтому все поля, если у них есть конструктор по умолчанию, для них будет вызван конструктор по умолчанию, обязательно.
[38:57.320 --> 39:03.320]  Comp palavr может отказаться вам генерировать конструктор по умолчанию не только в случае, если вы сами написали какой-то конструктор.
[39:03.320 --> 39:32.020]  Этим небольшим Seoul
[39:32.020 --> 39:33.860]  в общем, совсем расстроится, потому что,
[39:33.860 --> 39:36.100]  во первых, нельзя создать поле а,
[39:36.100 --> 39:37.740]  потому что конструктор приватный.
[39:37.740 --> 39:39.560]  Во вторых, нельзя создать поле b,
[39:39.560 --> 39:41.140]  потому что непонятно чем проник préางельизировать
[39:41.140 --> 39:41.880]  константу.
[39:41.880 --> 39:45.060]  Ну а в третих не может проникра sermon,
[39:45.060 --> 39:46.980]  чем проникра Californ thanked.
[39:47.040 --> 39:49.680]  В этом случае, даже несмотря на то,
[39:49.680 --> 39:52.100]  что вы не написали ни одного конструктора,
[39:52.100 --> 39:54.040]  комплятор вам тоже отказался генерировать
[39:54.040 --> 39:55.060]  конструктор по умолчанию, потому что
[39:55.060 --> 39:57.760]  непонятно, как должен он выглядеть.
[39:57.760 --> 40:04.320]  Ну и последний пункт здесь. Конструкция равно default.
[40:04.320 --> 40:09.840]  Допустим, вы в своем классе написали какие-то конструкторы.
[40:09.840 --> 40:13.840]  Какой-то конструктор преобразования, какой-то параметрический конструктор и так далее.
[40:13.840 --> 40:18.240]  Ну и при этом вы хотите, чтобы у вас в классе также был еще конструктор по умолчанию.
[40:18.240 --> 40:22.960]  Но при этом вы не хотите писать его самостоятельно, вы хотите отдать это все на откуп компилятору.
[40:23.920 --> 40:27.920]  Тогда вы можете воспользоваться конструкцией равно default.
[40:27.920 --> 40:30.880]  Ну смотрите, вы написали свой конструктор какой-то.
[40:30.880 --> 40:34.880]  В этом случае компилятор вам, естественно, не будет генерировать конструктор по умолчанию.
[40:34.880 --> 40:38.880]  Но вы можете вежливо попросить компилятора сделать это и делать это следующим образом.
[40:38.880 --> 40:42.880]  Вы пишете b круглой скобки равно default.
[40:42.880 --> 40:46.880]  В этом случае компилятор за вас напишет конструктор по умолчанию.
[40:46.880 --> 40:50.880]  Вот ровно в таком виде, в котором мы обсуждали до этого.
[40:50.880 --> 40:54.880]  Если бы я эту строку не написал, то у меня бы конструктор по умолчанию в классе не было.
[40:54.880 --> 40:58.880]  Но я хочу, чтобы он был. Но при этом мне самому писать его в лом.
[40:58.880 --> 41:04.880]  Ну тогда я просто пишу равно default и это явная просьба компилятора создать за меня этот конструктор.
[41:04.880 --> 41:06.880]  Вот и все.
[41:06.880 --> 41:12.880]  В данном случае они оправдываются.
[41:12.880 --> 41:16.880]  Но это лучше тем, что это более явно показывает ваше намерение.
[41:16.880 --> 41:20.880]  То есть когда кто-то читает ваш код, ему более понятно, что вот этот конструктор предоставлен компиляторам.
[41:20.880 --> 41:22.880]  Они вы писали.
[41:22.880 --> 41:28.880]  Ну и когда мы будем говорить про следующий конструктор, там default будет отличаться от пустых фигурных скобок.
[41:28.880 --> 41:32.880]  Так, вопросы?
[41:32.880 --> 41:36.880]  Ну перерыв тогда.
[41:36.880 --> 41:42.880]  Следующий конструктор, по которому мы поговорим, это конструктор копирования.
[41:42.880 --> 41:50.880]  Конструктор копирования это конструктор, который создает объект с помощью другого объекта того же типа.
[41:50.880 --> 41:56.880]  То есть если в качестве параметра ваш конструктор может принимать другой объект того же типа,
[41:56.880 --> 42:02.880]  то этот конструктор называется конструктором копирования.
[42:02.880 --> 42:04.880]  Вот.
[42:04.880 --> 42:08.880]  Вот, к сожалению, вот просто так написать конструктор копирования правильно.
[42:08.880 --> 42:12.880]  В общем, это просто так.
[42:12.880 --> 42:16.880]  В общем, если не знать про то, как ведет себя конструктор копирования,
[42:16.880 --> 42:18.880]  очень сложно написать его правильно с первого раза.
[42:18.880 --> 42:20.880]  Вот, смотрите, допустим, я пишу вот такой конструктор копирования.
[42:20.880 --> 42:22.880]  Ну, я следую ту по определению.
[42:22.880 --> 42:26.880]  Значит, по определению у меня конструктор должен принимать другой объект того же типа.
[42:26.880 --> 42:28.880]  Ну, соответственно, если я хочу написать конструктор копирования для стека,
[42:28.880 --> 42:34.880]  то я в качестве аргумента ему передаю просто stack s.
[42:34.880 --> 42:36.880]  Ну и дальше я задаю вопрос.
[42:36.880 --> 42:38.880]  Ну и дальше я задаю вопрос.
[42:38.880 --> 42:40.880]  Ну и дальше я задаю вопрос.
[42:40.880 --> 42:42.880]  Ну и дальше я задаю вопрос.
[42:42.880 --> 42:44.880]  Ну и дальше я задаю вопрос.
[42:44.880 --> 42:46.880]  Ну и дальше я задаю вопрос.
[42:46.880 --> 42:48.880]  Ну и дальше я задаю вопрос.
[42:48.880 --> 42:50.880]  Ну и дальше я задаю вопрос.
[42:50.880 --> 42:52.880]  Ну и дальше я задаю вопрос.
[42:52.880 --> 42:54.880]  Ну и дальше я задаю вопрос.
[42:54.880 --> 42:56.880]  Ну и дальше я задаю вопрос.
[42:56.880 --> 42:58.880]  Ну и дальше я задаю вопрос.
[42:58.880 --> 43:00.880]  Ну и дальше я задаю вопрос.
[43:00.880 --> 43:02.880]  Ну и дальше я задаю вопрос.
[43:02.880 --> 43:04.880]  Ну и дальше я задаю вопрос.
[43:04.880 --> 43:06.880]  Ну и дальше я задаю вопрос.
[43:06.880 --> 43:08.880]  Ну и дальше я задаю вопрос.
[43:08.880 --> 43:10.880]  Ну и дальше я задаю вопрос.
[43:10.880 --> 43:12.880]  Ну и дальше я задаю вопрос.
[43:12.880 --> 43:14.880]  Ну и дальше я задаю вопрос.
[43:14.880 --> 43:16.880]  Ну и дальше я задаю вопрос.
[43:16.880 --> 43:18.880]  Ну и дальше я задаю вопрос.
[43:18.880 --> 43:20.880]  Ну и дальше я задаю вопрос.
[43:20.880 --> 43:22.880]  Ну и дальше я задаю вопрос.
[43:22.880 --> 43:24.880]  Ну и дальше я задаю вопрос.
[43:24.880 --> 43:26.880]  Ну и дальше я задаю вопрос.
[43:26.880 --> 43:28.880]  Ну и дальше я задаю вопрос.
[43:28.880 --> 43:30.880]  Вам задана вопрос.
[43:30.880 --> 43:32.880]  Бесконечные рекурсии отвечать нельзя.
[43:40.880 --> 43:42.880]  Ну а в чем проблема?
[43:42.880 --> 43:44.880]  Ну не по ссылке и что?
[43:52.880 --> 43:54.880]  Ну да, смотрите, в чем проблема.
[43:54.880 --> 43:56.880]  Проблема в следующем.
[43:56.880 --> 43:58.880]  В этом случае я вызываю конструктор копирования.
[43:58.880 --> 44:00.880]  В этом случае я вызываю конструктор копирования.
[44:00.880 --> 44:02.880]  Что делает конструктор копирования?
[44:02.880 --> 44:04.880]  Конструктор копирования принимает,
[44:04.880 --> 44:06.880]  у него есть в качестве аргумента
[44:06.880 --> 44:08.880]  он принимает s.
[44:08.880 --> 44:10.880]  Как я принимаю s?
[44:10.880 --> 44:12.880]  s я принимаю по значению.
[44:12.880 --> 44:14.880]  А что происходит с аргументом,
[44:14.880 --> 44:16.880]  когда я передаю его по значению?
[44:16.880 --> 44:18.880]  Аргумент копируется.
[44:18.880 --> 44:20.880]  Фактически аргумент копируется
[44:20.880 --> 44:22.880]  в тот аргумент, который у меня в функции.
[44:22.880 --> 44:24.880]  То есть у меня сначала a должен скопироваться в s.
[44:24.880 --> 44:26.880]  Ну смотрите, я хочу a скопировать в b,
[44:26.880 --> 44:28.880]  но перед тем как скопировать a в b,
[44:28.880 --> 44:30.880]  у меня a должен скопироваться в аргумент s,
[44:30.880 --> 44:32.880]  чтобы я мог с s внутри
[44:32.880 --> 44:34.880]  вот этого конструктора работать.
[44:34.880 --> 44:36.880]  Понятно?
[44:36.880 --> 44:38.880]  а как мне скопировать a в s?
[44:38.880 --> 44:40.880]  с помощью конструктора копирования.
[44:40.880 --> 44:42.880]  Хорошо, вот тут тогда вызывается
[44:42.880 --> 44:44.880]  Конструктор копирования
[44:44.880 --> 44:46.880]  из a в s.
[44:46.880 --> 44:48.880]  А как работает конструктор копирования?
[44:48.880 --> 44:50.880]  Сначала он должен скопировать аргумент.
[44:50.880 --> 44:52.880]  То есть а у меня теперь копируется в какой-то s'.
[44:52.880 --> 44:57.880]  в какой-то s-трих. То есть я пытаюсь вызвать конструкцию
[44:57.880 --> 45:00.580]  закопирования, которая копирует a в s-трих. Но чтобы скопировать
[45:00.580 --> 45:03.380]  a в s-трих, мне должен создаться какой-то аргумент, и поэтому,
[45:03.380 --> 45:06.580]  и так далее. Это очень понятно. Чтобы запустить конструкцию
[45:06.580 --> 45:09.380]  закопирования, мне нужен конструкцию закопирования, а у меня его нет.
[45:09.380 --> 45:23.880]  А про это мы поговорим. Если вы не пишете конструкцию
[45:23.880 --> 45:25.880]  закопирования, то действительно вся поля копируется побитого.
[45:25.880 --> 45:28.380]  Но когда вы написали свой конструкцию закопирования, то работает
[45:28.380 --> 45:33.380]  то, что я сказал. Проблема понятна? То есть чтобы скопировать
[45:33.380 --> 45:37.380]  a в b, мне нужно сначала a скопировать в s. А чтобы скопировать
[45:37.380 --> 45:39.380]  a в s, мне нужно вызвать конструкцию закопирования, получать
[45:39.380 --> 45:41.380]  такая рекурсия. То есть я не могу вызвать конструкцию
[45:41.380 --> 45:43.380]  закопирования, потому что мне нужен конструктор
[45:43.380 --> 45:48.380]  закопирования. Как решается эта проблема? Решается очень
[45:48.380 --> 45:53.380]  просто. Нужно принимать аргумент не по значению, а по ссылке.
[45:53.380 --> 46:00.380]  Точнее, по константной ссылке. Почему именно по ссылке,
[46:00.380 --> 46:03.380]  понятно, потому что ссылка не создает копий. Ссылкой
[46:03.380 --> 46:05.380]  ссылается на ровно тот же объект, который вы передали.
[46:05.380 --> 46:11.380]  А почему по константной ссылке? Ну, во-первых, из соображения
[46:11.380 --> 46:13.380]  безопасности, чтобы вы точно не поменяли тот объект,
[46:13.380 --> 46:15.380]  который вы передали. То есть странно, что вы копируете
[46:15.380 --> 46:19.380]  один объект, и при этом этот объект меняется. Но, во-вторых,
[46:19.380 --> 46:22.380]  константные ссылки позволяют вам передавать так называемое
[46:22.380 --> 46:28.380]  r-value, то есть временное значение. Если я захочу скопироваться
[46:28.380 --> 46:32.380]  от временного значения, то по ссылке мне не получится
[46:32.380 --> 46:34.380]  его передать. Потому что нельзя создавать ссылку
[46:34.380 --> 46:37.380]  на временный объект. А константную ссылку на временный объект
[46:37.380 --> 46:43.380]  создавать можно. Конструктор копирования это конструктор,
[46:43.380 --> 46:49.380]  который принимает элемент того же типа, но по ссылке.
[46:49.380 --> 46:56.380]  Желательно по константной ссылке. Ну и теперь вот про
[46:56.380 --> 46:59.380]  вопрос из зала. Смотрите, до этого мы вроде как конструктор
[46:59.380 --> 47:01.440]  то есть вы к конструктору копирования писали?
[47:01.440 --> 47:02.960]  Но при этом копировать объекты могли,
[47:02.960 --> 47:05.760]  ну вот вы же наверное могли одну структуру скопировать другую struct,
[47:05.760 --> 47:06.340]  и так далее.
[47:06.520 --> 47:09.100]  В этом случае тоже действуешь особые правила.
[47:10.060 --> 47:13.040]  Точнее в этом случае комп administration создат вам concerts Standing 부�파,
[47:13.040 --> 47:14.540]  и правило здесь такое.
[47:14.560 --> 47:17.380]  Если вы не написали своего конструктора копирования
[47:17.580 --> 47:19.400]  и конструктора перемещения,
[47:19.480 --> 47:20.400]  что такое? Поговорим позже.
[47:21.020 --> 47:23.540]  Если вы не написали копирование и перемещение,
[47:23.820 --> 47:27.640]  то компилятор за вас напишет вам конструктор копирования.
[47:27.640 --> 47:31.140]  Parechite. discernible.
[47:31.140 --> 47:34.240] ıma,
[47:34.240 --> 47:38.240]  Raz Yea.
[47:38.240 --> 47:41.700]  Shla低,
[47:41.700 --> 47:47.320]  شætegeryt,
[47:47.320 --> 47:51.240]  stest,
[47:51.240 --> 47:56.240]  все равно будет вам создаваться. Ну и соответственно, что делает
[47:56.240 --> 47:59.240]  конструктор копирования, который предоставляет вам компилятор?
[47:59.240 --> 48:02.240]  Самый простой ответ – это то, что он просто берет по битву
[48:02.240 --> 48:05.240]  и копирует все поля, но ровно то, что мы наблюдали до этого.
[48:05.240 --> 48:09.240]  То есть у вас все поля стекок просто-напросто взяли и скопировались
[48:09.240 --> 48:13.240]  в поля другого стека. Но это не вся правда. А вся правда заключается в том,
[48:13.240 --> 48:17.240]  что копирование происходит следующим образом. Примитивные поля копируются,
[48:17.240 --> 48:22.240]  то есть всякие инты, флоты, були и так далее, они копируются по битву.
[48:22.240 --> 48:26.240]  Просто берется битвое представление и дословно копируется в новый объект.
[48:26.240 --> 48:32.240]  А если поле представляет из себя не примитивный тип, а объект-класс,
[48:32.240 --> 48:36.240]  то это поле будет копироваться с помощью конструктора копирования.
[48:36.240 --> 48:40.240]  Понятно? То есть если у кого-то поле есть свой конструктор копирования,
[48:40.240 --> 48:44.240]  то при копировании будет вызван именно он.
[48:44.240 --> 48:48.240]  Ну вот здесь пример. Соответственно, если вы написали свой конструктор копирования,
[48:48.240 --> 48:52.240]  то компилятор предоставляет вам конструктор копирования, который эквивалентен следующему.
[48:52.240 --> 48:57.240]  Он для класса A, точнее для поля A вызывает конструктор копирования,
[48:57.240 --> 49:02.240]  ну а для объекта X он просто копирует его по битву.
[49:02.240 --> 49:08.240]  Можно сказать, что он просто берет и вызывает копирование для каждого поля в отдельности.
[49:08.240 --> 49:12.240]  А что произойдет, если у меня в классе A нет конструктора копирования?
[49:12.240 --> 49:16.240]  Ну то есть в принципе нет вообще никакого. Что произойдет?
[49:19.240 --> 49:22.240]  Ну представьте, в классе A вообще нет никакого копирования.
[49:22.240 --> 49:25.240]  То есть даже компилятор там не создал. Что произойдет?
[49:29.240 --> 49:33.240]  Ну вот это сможет? Компилятор сможет создать? Нет.
[49:33.240 --> 49:37.240]  То есть если у вас какие-то поля некопируемые, то, естественно,
[49:37.240 --> 49:39.240]  конструктор копирования создаваться за вас не будет.
[49:39.240 --> 49:41.240]  Я думаю, это вполне естественное правило.
[49:44.240 --> 49:46.240]  Ну вот ровно то, что я говорил.
[49:46.240 --> 49:49.240]  Компилятор откажется генерировать за вас конструктор копирования,
[49:49.240 --> 49:51.240]  если у вас в классе есть поля, которые нельзя копировать.
[49:51.240 --> 49:53.240]  Ну вот как это может получиться?
[49:53.240 --> 49:56.240]  Ну вот представьте, что у вас есть структура A,
[49:56.240 --> 49:58.240]  и снова структура A написала какую-то вреднючку,
[49:58.240 --> 50:01.240]  которая запретила нам вызывать конструктор копирования.
[50:01.240 --> 50:04.240]  То есть он сделал этот конструктор копирования приватным.
[50:04.240 --> 50:09.240]  И у меня есть структура B, у которой в качестве поля выступает поле А.
[50:09.240 --> 50:12.240]  И вот тогда, если я попытаюсь скопировать объект B,
[50:12.240 --> 50:14.240]  то это у меня не получится, почему!?
[50:14.240 --> 50:17.240]  Потому что у меня в структуре B нет конструктора копирования.
[50:17.240 --> 50:19.240]  А почему у меня в структуре B нет конструктора копирования?
[50:19.240 --> 50:22.240]  Потому что компилятор отказался генерировать конструктор копирования,
[50:22.240 --> 50:25.240]  потому что ему непонятно, как копировать объект A.
[50:25.240 --> 50:32.240]  У объекта A нельзя вызывать конструктор копирования, он приватный.
[50:34.240 --> 50:43.240]  Ну и аналогично, если вы хотите, чтобы компилятор за вас
[50:43.240 --> 50:47.240]  сгенерировал конструктор копирования, вы можете его явно об этом попросить.
[50:47.240 --> 50:52.240]  С помощью конструкции равно default. То есть если вы хотите явно сказать
[50:52.240 --> 50:56.240]  компилятору, что вот конструктор копирования нужно сгенерировать за меня,
[50:56.240 --> 50:59.240]  то есть не знаю, я сам не умею, или вот меня устраивает то, как делаешь ты,
[50:59.240 --> 51:05.240]  то можно сделать равно default. В данном случае я пишу b
[51:05.240 --> 51:11.240]  и дальше принимаю объект типа b по константной ссылке и пишу равно default.
[51:11.240 --> 51:14.240]  В этом случае компилятор генерирует его за меня.
[51:14.240 --> 51:18.240]  При этом писать для конструктора копирования равно default не обязательно,
[51:18.240 --> 51:20.240]  потому что если вы не опишете свой конструктор копирования,
[51:20.240 --> 51:24.240]  то в принципе компиляторы за вас это и сделают.
[51:24.240 --> 51:34.240]  Ну и вопрос. Как вы думаете, есть ли ситуации, при которых нужно
[51:34.240 --> 51:36.240]  писать свой конструктор копирования? То есть мы вроде как обсудили,
[51:36.240 --> 51:40.240]  что компилятор со созданием копирования справляется сам.
[51:40.240 --> 51:43.240]  То есть компилятор в принципе сам может все поля взять и скопировать.
[51:43.240 --> 51:47.240]  В каких ситуациях нужно писать конструктор копирования тогда самостоятельно,
[51:47.240 --> 51:50.240]  если компилятор всегда за нас задает это копирование?
[51:51.240 --> 51:53.240]  Указатель.
[51:55.240 --> 51:58.240]  Ну да, то есть если говорить в общем, то если вы управляете
[51:58.240 --> 52:02.240]  какими-то ресурсами, например, у вас внутри объекта хранится указатель
[52:02.240 --> 52:06.240]  на выделенную память, то в этом случае, естественно, вам хочется глубокое копирование.
[52:06.240 --> 52:10.240]  То есть вам хочется этот буфер скопировать целиком, а не просто скопировать указатель.
[52:10.240 --> 52:12.240]  Но чтобы не возникала такой ситуация, как со стеком.
[52:12.240 --> 52:17.240]  То есть у вас есть буфер от первого стека, у вас есть буфер от второго стека.
[52:17.240 --> 52:21.240]  Если вы просто бездумно с помощью компилятора скопируете s2 в s1 или наоборот,
[52:21.240 --> 52:25.240]  то у вас оба этих буфера будут указывать на одну и ту же область памяти.
[52:25.240 --> 52:27.240]  Ничего, наверное, не хотелось бы, да?
[52:27.240 --> 52:30.240]  То есть хочется, чтобы два стека имели разные области памяти,
[52:30.240 --> 52:33.240]  точнее разные массивы, на которые они указывают.
[52:33.240 --> 52:37.240]  И вот в этом случае вам нужно писать свой конструктор копирования, действительно.
[52:39.240 --> 52:41.240]  Эта ремарка понятна?
[52:41.240 --> 52:44.240]  Если вы сами как-то управляете памятью или в принципе ресурсами,
[52:44.240 --> 52:47.240]  то чтобы корректно их передавать, чтобы корректно их копировать,
[52:47.240 --> 52:49.240]  нужно написать свой конструктор копирования.
[52:49.240 --> 52:52.240]  Если у вас в принципе класс состоит только из примитивных типов,
[52:52.240 --> 52:55.240]  ну например, у вас вы пишете свой класс комплексного числа.
[52:55.240 --> 52:57.240]  Ну комплексное число это что?
[52:57.240 --> 53:01.240]  Это просто два типа флотовых числа, которые отвечают за действительно умнимую часть.
[53:01.240 --> 53:04.240]  В этом случае, естественно, конструктор копирования свой писать не имеет смысла,
[53:04.240 --> 53:08.240]  потому что компилятор и так справится за вас, побит вас копировать все поля.
[53:08.240 --> 53:10.240]  Это нормально.
[53:10.240 --> 53:12.240]  Мораль ясна?
[53:12.240 --> 53:14.240]  Окей.
[53:16.240 --> 53:19.240]  Ну и замечание про конструктор копирования.
[53:19.240 --> 53:23.240]  Вот смотрите, когда мы обсуждали конструктор по умолчанию,
[53:23.240 --> 53:28.240]  мы говорили, что вот эти две записи, они абсолютно эквивалентны.
[53:28.240 --> 53:31.240]  Ну потому что если вы пишете пустые фигурные скобки,
[53:31.240 --> 53:35.240]  то компилятор все равно за вас напишет список инициализации,
[53:35.240 --> 53:37.240]  которые все поля создаст по умолчанию.
[53:37.240 --> 53:41.240]  То есть что написать равно default, что написать пустые фигурные скобки,
[53:41.240 --> 53:43.240]  это абсолютно то же самое.
[53:43.240 --> 53:45.240]  Вот для конструктора копирования это неверно,
[53:45.240 --> 53:48.200]  потому что если в конструкторе копирования вы напишите пустые фигурные
[53:48.240 --> 53:51.240]  скобки, то для компилятора это означает, что
[53:51.240 --> 53:53.240]  конструктор копирования должен вести себя так,
[53:53.240 --> 53:55.240]  он должен ничего не делать.
[53:55.240 --> 53:58.640]  В этом случае компилятор так, как вы написали пустые
[53:58.640 --> 54:01.240]  фигурные скобки без списка инициализации,
[54:01.240 --> 54:04.240]  в этом случае компилятор все поля создаст по умолчанию,
[54:04.240 --> 54:06.240]  но не скопирует.
[54:07.240 --> 54:09.240]  Понятно?
[54:09.240 --> 54:15.040]  Поэтому в этом случае есть разница между равно-дефолт и просто пустыми фигурными скобками.
[54:15.040 --> 54:19.040]  То есть для конструктора копирования написать просто пустые фигурные скобки недостаточно.
[54:19.040 --> 54:28.040]  Пустые фигурные скобки без списка инициализации для компилятора означают создать все по умолчанию.
[54:28.040 --> 54:31.040]  Но копирование это не создать по умолчанию, естественно.
[54:31.040 --> 54:37.040]  Все понятно? Отлично.
[54:37.840 --> 54:42.840]  Ну и делегирование конструкторов.
[54:42.840 --> 54:46.840]  Значит, все, с видами конструктора мы закончили.
[54:46.840 --> 54:49.840]  Какие конструкторы мы успели разобрать?
[54:49.840 --> 54:53.840]  Параметрический конструктор, конструктор преобразования, конструктор по умолчанию,
[54:53.840 --> 54:56.840]  конструктор копирования.
[54:56.840 --> 55:00.840]  Есть еще один специальный вид конструктора, конструктор перемещения,
[55:00.840 --> 55:04.840]  но мы договорились, что о нем попозже поговорим, когда-нибудь.
[55:05.640 --> 55:11.640]  Теперь про делегирование конструкторов.
[55:11.640 --> 55:17.640]  Проблема следующего рода.
[55:17.640 --> 55:22.640]  Допустим, я хочу написать для своего класса stack следующий конструктор.
[55:22.640 --> 55:31.640]  Конструктор, который принимает массив динамический и его размер.
[55:32.440 --> 55:37.440]  И я хочу, чтобы в этом конструкторе у меня в stack загрузили все эти значения
[55:37.440 --> 55:40.440]  из вот этого массива.
[55:40.440 --> 55:45.440]  То есть я хочу проинтересировать stack элементами из переднего массива values.
[55:45.440 --> 55:49.440]  Нормальное желание?
[55:49.440 --> 55:51.440]  Ну что я делаю?
[55:51.440 --> 55:54.440]  Я создаю буфер с помощью new, то есть выделяю память для своего буфера,
[55:54.440 --> 55:56.440]  в котором будут храниться элементы.
[55:56.440 --> 55:59.440]  Задаю значение size, ну и дальше в цикле копирую все элементы
[56:00.240 --> 56:02.240]  из массива values в свой буфер.
[56:02.240 --> 56:04.240]  Все нормально, да?
[56:04.240 --> 56:06.240]  Хорошо.
[56:06.240 --> 56:08.240]  Теперь мне приходит еще одна идея.
[56:08.240 --> 56:10.240]  Так у меня stack управляет как-то нетривиально памятью,
[56:10.240 --> 56:12.240]  мне нужно писать свой конструктор копирования,
[56:12.240 --> 56:14.240]  чтобы не было поверхностей своего копирования,
[56:14.240 --> 56:16.240]  чтобы копирование было глубоким.
[56:16.240 --> 56:18.240]  Ну хорошо, что я делаю?
[56:18.240 --> 56:20.240]  Я создаю снова буфер с помощью new,
[56:20.240 --> 56:22.240]  я создаю начальный размер size, который равен такой же размер,
[56:22.240 --> 56:24.240]  как переданный stack other.
[56:24.240 --> 56:26.240]  Ну и дальше в цикле я копирую все элементы
[56:26.240 --> 56:28.240]  из другого буфера в свой буфер.
[56:29.040 --> 56:31.040]  В чем проблема?
[56:33.040 --> 56:35.040]  Здесь написано, окей.
[56:35.040 --> 56:37.040]  Ну понятно, да, что есть дублирование кода.
[56:37.040 --> 56:39.040]  То есть что первый конструктор, что второй конструктор
[56:39.040 --> 56:41.040]  в принципе выполняют одни и те же действия.
[56:43.040 --> 56:45.040]  Мы просто копируем элементы из одного массива
[56:45.040 --> 56:47.040]  в свой массив, и все.
[56:47.040 --> 56:49.040]  Ну наверное хотелось бы как-то,
[56:49.040 --> 56:51.040]  ну естественное желание избежать дублирования кода.
[56:53.040 --> 56:55.040]  То есть наверное хотелось бы чего-то такого.
[56:55.040 --> 56:57.040]  То есть я понимаю, что конструктор копирует,
[56:57.840 --> 56:59.840]  то есть я понимаю, что конструктор копирования
[56:59.840 --> 57:01.840]  в принципе у меня работает точно так же,
[57:01.840 --> 57:03.840]  как и вот конструктор, который написан выше.
[57:03.840 --> 57:05.840]  То есть в частности, если я вот в конструктор,
[57:05.840 --> 57:07.840]  который у меня выше находится,
[57:07.840 --> 57:09.840]  передам значение other size и other buffer,
[57:09.840 --> 57:11.840]  то все будет происходить так, как я хочу.
[57:11.840 --> 57:13.840]  Да, у меня скопируется size
[57:13.840 --> 57:15.840]  и скопируются элементы из буфера.
[57:15.840 --> 57:17.840]  Согласны?
[57:17.840 --> 57:19.840]  То есть хотелось бы, чтобы у меня был какой-то вот такой синтаксис.
[57:19.840 --> 57:21.840]  Я внутри одного stack вызываю другой stack.
[57:23.840 --> 57:25.840]  Но при этом есть проблема. Какая?
[57:26.640 --> 57:28.640]  Мы помним, что все, что написано в фигурных скобках
[57:28.640 --> 57:30.640]  может быть использовано против вас.
[57:32.640 --> 57:34.640]  Все, что написано в фигурных скобках,
[57:34.640 --> 57:36.640]  это не инициализация, а что?
[57:36.640 --> 57:38.640]  Ну это просто изменение текущих значений,
[57:38.640 --> 57:40.640]  изменение уже проинциализированных значений.
[57:42.640 --> 57:44.640]  Поэтому естественно, что внутри
[57:44.640 --> 57:46.640]  фигурных скобок другой конструктор
[57:46.640 --> 57:48.640]  вызывать нельзя.
[57:48.640 --> 57:50.640]  Более того, когда вы пишете
[57:50.640 --> 57:52.640]  вот таким образом,
[57:52.640 --> 57:54.640]  когда вы написали такую строку,
[57:55.440 --> 57:57.440]  на самом деле у вас тут происходит не вызов конструктора,
[57:57.440 --> 57:59.440]  то есть не вызов другого конструктора,
[57:59.440 --> 58:01.440]  а создание временного объекта.
[58:01.440 --> 58:03.440]  То есть это то же самое, как если бы вы написали
[58:03.440 --> 58:05.440]  int в скобках 5
[58:05.440 --> 58:07.440]  и вот так.
[58:07.440 --> 58:09.440]  Ну что эта строка означает?
[58:09.440 --> 58:11.440]  Это выражение, которое, грубо говоря, означает 5.
[58:11.440 --> 58:13.440]  Вот в этой строке 5.
[58:13.440 --> 58:15.440]  Ну что 5?
[58:15.440 --> 58:17.440]  Не понятно.
[58:17.440 --> 58:19.440]  Вот здесь то же самое. Вы просто создаете stack временный,
[58:19.440 --> 58:21.440]  то есть вы в этой строке создали stack,
[58:21.440 --> 58:23.440]  и он сразу же уничтожился.
[58:24.240 --> 58:26.240]  Хорошо.
[58:26.240 --> 58:28.240]  А как правильно?
[58:28.240 --> 58:30.240]  Как правильно вызвать конструктор
[58:30.240 --> 58:32.240]  в другом конструкторе?
[58:32.240 --> 58:34.240]  Делается тоже через синтаксис
[58:34.240 --> 58:36.240]  списков инициализации.
[58:36.240 --> 58:38.240]  Вы должны вот здесь,
[58:38.240 --> 58:40.240]  через двоеточие указать
[58:40.240 --> 58:42.240]  конструктор, которому вы делегируете
[58:42.240 --> 58:44.240]  полномочия.
[58:44.240 --> 58:46.240]  То есть, грубо говоря, вот тут дословно говорить следующее.
[58:46.240 --> 58:48.240]  У меня конструктор копирования
[58:48.240 --> 58:50.240]  выполняет те же самые действия,
[58:50.240 --> 58:52.240]  что и вот такой конструктор с вот такими параметрами.
[58:52.240 --> 58:54.240]  Понятно?
[58:54.240 --> 58:56.240]  То есть я говорю, что конструктор копирования
[58:56.240 --> 58:58.240]  у меня должен выполнить вот такие действия.
[58:58.240 --> 59:00.240]  Я должен ему передать other size и other buffer,
[59:00.240 --> 59:02.240]  ну и дальше, собственно, выполняется код
[59:02.240 --> 59:04.240]  конструктора, который был написан ранее.
[59:06.240 --> 59:08.240]  Ну и начиная с этого момента
[59:08.240 --> 59:10.240]  управление полностью переходит
[59:10.240 --> 59:12.240]  в конструктор, который вы указали.
[59:18.240 --> 59:20.240]  Какое важное правило здесь нужно поговорить?
[59:20.240 --> 59:22.240]  Во-первых, нельзя сделать следующим образом.
[59:22.240 --> 59:24.240]  Нельзя сказать, что
[59:24.240 --> 59:26.240]  одни поля ты проинфилизируешь с помощью...
[59:26.240 --> 59:28.240]  Одни поля ты проинфилизируешь так же, как и
[59:28.240 --> 59:30.240]  инициализирует другой конструктор,
[59:30.240 --> 59:32.240]  остальные поля я проинфилизирую сам.
[59:32.240 --> 59:34.240]  То есть, грубо говоря, нельзя вот тут написать
[59:34.240 --> 59:36.240]  через запятую size 0.
[59:36.240 --> 59:38.240]  То есть вот так нельзя.
[59:38.240 --> 59:40.240]  То есть если вы уже делегировали
[59:40.240 --> 59:42.240]  полномочия другому конструктору,
[59:42.240 --> 59:44.240]  то этот конструктор полностью будет отвечать
[59:44.240 --> 59:46.240]  за создание вашего объекта.
[59:46.240 --> 59:48.240]  То есть ничего больше
[59:48.240 --> 59:50.240]  написать после двоеточия,
[59:50.240 --> 59:52.240]  если вы делегировали полномочию
[59:52.240 --> 59:54.240]  другому конструктору, нельзя.
[59:54.240 --> 59:56.240]  Но при этом, если вы хотите как-то...
[59:56.240 --> 59:58.240]  Вот вас полностью устраивает,
[59:58.240 --> 01:00:00.240]  что делает другой конструктор.
[01:00:00.240 --> 01:00:02.240]  Вас полностью устраивает, что происходит здесь.
[01:00:02.240 --> 01:00:04.240]  Но при этом вы хотите как-то
[01:00:04.240 --> 01:00:06.240]  изменить size, например.
[01:00:06.240 --> 01:00:08.240]  Вы хотите сделать все то же самое,
[01:00:08.240 --> 01:00:10.240]  но при этом size был на один побольше.
[01:00:10.240 --> 01:00:12.240]  Это вы можете сделать,
[01:00:12.240 --> 01:00:14.240]  просто написать внутри фигуры скобок
[01:00:14.240 --> 01:00:16.240]  size...
[01:00:16.240 --> 01:00:18.240]  Можно и так.
[01:00:22.240 --> 01:00:24.240]  Все ясно?
[01:00:26.240 --> 01:00:28.240]  Окей.
[01:00:28.240 --> 01:00:30.240]  Это про делегирование конструкторов.
[01:00:30.240 --> 01:00:32.240]  То есть конструктор можно взять
[01:00:32.240 --> 01:00:34.240]  в других конструкторах,
[01:00:34.240 --> 01:00:36.240]  если вас устраивают эти действия,
[01:00:36.240 --> 01:00:38.240]  которые он должен совершать.
[01:00:38.240 --> 01:00:40.240]  Так, ну и...
[01:00:40.240 --> 01:00:42.240]  Значит, с конструкторами все.
[01:00:42.240 --> 01:00:44.240]  Есть вопросы?
[01:00:44.240 --> 01:00:46.240]  В принципе, по конструкторам.
[01:00:50.240 --> 01:00:52.240]  Ну тогда давайте поговорим про деструкторы.
[01:00:52.240 --> 01:00:54.240]  Ну, я думаю, по названию понятно.
[01:00:54.240 --> 01:00:56.240]  Если конструкторы создают объект,
[01:00:56.240 --> 01:00:58.240]  то деструкторы его уничтожают.
[01:00:58.240 --> 01:01:00.240]  Соответственно,
[01:01:00.240 --> 01:01:02.240]  деструкторов существует
[01:01:02.240 --> 01:01:04.240]  всего один тип.
[01:01:04.240 --> 01:01:06.240]  То есть у конструкторов у нас была целая семейство,
[01:01:06.240 --> 01:01:08.240]  а деструктор только один.
[01:01:08.240 --> 01:01:10.240]  Деструктор это особый метод класса.
[01:01:10.240 --> 01:01:12.240]  Но деструктор,
[01:01:12.240 --> 01:01:14.240]  деструктор это особый метод класса,
[01:01:14.240 --> 01:01:16.240]  который вызывается при завершении времени
[01:01:16.240 --> 01:01:18.240]  жизни объекта.
[01:01:18.240 --> 01:01:20.240]  Как только время жизни объекта завершается,
[01:01:20.240 --> 01:01:22.240]  вызывается деструктор.
[01:01:22.240 --> 01:01:24.240]  Каков синтаксис?
[01:01:24.240 --> 01:01:26.240]  Как написать свой деструктор?
[01:01:26.240 --> 01:01:28.240]  Во-первых, деструктор не имеет возвращаемого значения.
[01:01:28.240 --> 01:01:30.240]  То есть когда объект уничтожается,
[01:01:30.240 --> 01:01:32.240]  у него нет возможности сказать последнее слово.
[01:01:32.240 --> 01:01:34.240]  Он уничтожается и все.
[01:01:34.240 --> 01:01:36.240]  Без последнего слова он ничего не возвращает.
[01:01:36.240 --> 01:01:38.240]  Его имя совпадает с именем класса,
[01:01:38.240 --> 01:01:40.240]  но перед началом вы должны написать тильду.
[01:01:40.240 --> 01:01:42.240]  То есть тильда имя класса означает,
[01:01:42.240 --> 01:01:44.240]  что вы пишете деструктор.
[01:01:44.240 --> 01:01:46.240]  Ну и плюс деструктор
[01:01:46.240 --> 01:01:48.240]  ничего не принимает.
[01:01:48.240 --> 01:01:50.240]  У объекта нет шанса
[01:01:50.240 --> 01:01:52.240]  на последнее слово,
[01:01:52.240 --> 01:01:54.240]  на последнее желание, то есть ничего передать деструктор вы не можете.
[01:01:54.240 --> 01:01:56.240]  То есть деструктор всегда выглядит следующим образом.
[01:01:56.240 --> 01:01:58.240]  Тильда, название класса
[01:01:58.240 --> 01:02:00.240]  и пустые круглые скобки.
[01:02:00.240 --> 01:02:02.240]  Это деструктор.
[01:02:06.240 --> 01:02:08.240]  Ну какие действия можно выполнить деструктуре?
[01:02:08.240 --> 01:02:10.240]  Например, что нужно сделать для стека?
[01:02:10.240 --> 01:02:12.240]  Что мы знаем для стека?
[01:02:12.240 --> 01:02:14.240]  Что нужно сделать, чтобы он завершил корректную работу?
[01:02:14.240 --> 01:02:16.240]  Очистить память, вернуть ресурсы
[01:02:16.240 --> 01:02:18.240]  в операционной системе.
[01:02:18.240 --> 01:02:20.240]  Ну что мы делаем?
[01:02:20.240 --> 01:02:22.240]  Просто в деструкторе пишем delete-буфер.
[01:02:22.240 --> 01:02:24.240]  И вот теперь,
[01:02:24.240 --> 01:02:26.240]  когда мы так написали,
[01:02:26.240 --> 01:02:28.240]  мы знаем, что деструктор вызывается всякий раз
[01:02:28.240 --> 01:02:30.240]  автоматически, когда время
[01:02:30.240 --> 01:02:32.240]  жизни объекта подходит к концу.
[01:02:32.240 --> 01:02:34.240]  И вот теперь нам не нужно вручную управлять памятью стека.
[01:02:34.240 --> 01:02:36.240]  Теперь стек автоматически выделяет память
[01:02:36.240 --> 01:02:38.240]  в конструкторе и автоматически
[01:02:38.240 --> 01:02:40.240]  очищает память в деструкторе.
[01:02:40.240 --> 01:02:42.240]  То есть теперь, когда вы напишете просто
[01:02:42.240 --> 01:02:44.240]  вот такой код, без всяких
[01:02:44.240 --> 01:02:46.240]  файналайзов, у вас стек будет корректно
[01:02:46.240 --> 01:02:48.240]  работать. То есть вот тут при создании
[01:02:48.240 --> 01:02:50.240]  выделилась память, вот тут,
[01:02:50.240 --> 01:02:52.240]  когда вы вышли из области действия
[01:02:52.240 --> 01:02:54.240]  стека, у вас стек вернул все ресурсы,
[01:02:54.240 --> 01:02:56.240]  то есть вызывался деструктор. Понятно?
[01:03:00.240 --> 01:03:02.240]  UndefinedBehaviour.
[01:03:02.240 --> 01:03:04.240]  То есть если вы
[01:03:04.240 --> 01:03:06.240]  написали как-то стек
[01:03:06.240 --> 01:03:08.240]  в какой-то области,
[01:03:08.240 --> 01:03:10.240]  вот как только фигурная
[01:03:10.240 --> 01:03:12.240]  скобка закрылась,
[01:03:12.240 --> 01:03:14.240]  вот в этот момент вызываются все деструкторы.
[01:03:14.240 --> 01:03:16.240]  То есть все объекты, которые были
[01:03:16.240 --> 01:03:18.240]  созданы внутри этого скоба,
[01:03:18.240 --> 01:03:20.240]  для всех этих объектов будет вызов деструктор.
[01:03:20.240 --> 01:03:22.240]  И все ресурсы вернутся системе.
[01:03:24.240 --> 01:03:26.240]  И вот деструктор
[01:03:26.240 --> 01:03:28.240]  это, наверное, самая важная концепция,
[01:03:28.240 --> 01:03:30.240]  самая важная часть языка C++,
[01:03:30.240 --> 01:03:32.240]  которая позволяет, вообще говоря,
[01:03:32.240 --> 01:03:34.240]  не следить за всякими
[01:03:34.240 --> 01:03:36.240]  утечками памяти и так далее. То есть если вы
[01:03:36.240 --> 01:03:38.240]  корректно написали для всех классов деструкторы и так далее,
[01:03:38.240 --> 01:03:40.240]  то все ресурсы автоматически выделяются,
[01:03:40.240 --> 01:03:42.240]  все ресурсы автоматически возвращаются системе.
[01:03:42.240 --> 01:03:44.240]  И никакого ручного управления памятью.
[01:03:46.240 --> 01:03:48.240]  Да, ну и про последний пункт.
[01:03:48.240 --> 01:03:50.240]  Тут написано, что деструктор
[01:03:50.240 --> 01:03:52.240]  вызывается неявно при уничтожении любого объекта.
[01:03:52.240 --> 01:03:54.240]  При этом деструктор при большом желании
[01:03:54.240 --> 01:03:56.240]  можно вызвать и, грубо говоря, явно.
[01:03:56.240 --> 01:03:58.240]  То есть, грубо говоря, вы можете
[01:03:58.240 --> 01:04:00.240]  сделать его так.
[01:04:00.240 --> 01:04:02.240]  То есть вы можете в конце сказать
[01:04:02.240 --> 01:04:04.240]  stack,
[01:04:04.240 --> 01:04:06.240]  точка и через тильду
[01:04:06.240 --> 01:04:08.240]  вот так. То есть вы, грубо говоря,
[01:04:08.240 --> 01:04:10.240]  явно вызвали деструктор. Но так делать не стоит,
[01:04:10.240 --> 01:04:12.240]  точнее так делать нельзя.
[01:04:12.240 --> 01:04:14.240]  Почему? Потому что компилятор
[01:04:14.240 --> 01:04:16.240]  все равно за вас. То есть даже если вы написали
[01:04:16.240 --> 01:04:18.240]  так, компилятор все равно за вас.
[01:04:18.240 --> 01:04:20.240]  Когда вы выйдете из этой области действия,
[01:04:20.240 --> 01:04:22.240]  из этой области видимости, у вас stack
[01:04:22.240 --> 01:04:24.240]  все равно, для stack все равно вызовется деструктор.
[01:04:24.240 --> 01:04:26.240]  И тогда у вас будет как раз-таки вот это вот самое
[01:04:26.240 --> 01:04:28.240]  double-free. То есть вы два раза очистите одну и ту же память.
[01:04:28.240 --> 01:04:30.240]  Чего делать нельзя?
[01:04:30.240 --> 01:04:32.240]  Понятно?
[01:04:36.240 --> 01:04:38.240]  В данном случае ничего. То есть, как правило,
[01:04:38.240 --> 01:04:40.240]  деструкторы нужны для того, чтобы вернуть какие-то ресурсы
[01:04:40.240 --> 01:04:42.240]  в системе. Ну, допустим, у вас там класс открывает
[01:04:42.240 --> 01:04:44.240]  какие-то файлы, какие-то соединения по сети,
[01:04:44.240 --> 01:04:46.240]  что-то еще.
[01:04:46.240 --> 01:04:48.240]  Чтобы это все корректно обработать, чтобы это корректно закрыть,
[01:04:48.240 --> 01:04:50.240]  делается деструктор.
[01:04:50.240 --> 01:04:52.240]  Если у вас просто класс комплексного числа, то, естественно,
[01:04:52.240 --> 01:04:54.240]  деструктора ему не нужен.
[01:04:54.240 --> 01:04:56.240]  Да, про это, видимо,
[01:04:56.240 --> 01:04:58.240]  на следующем слайде...
[01:04:58.240 --> 01:05:00.240]  Ну, про это мы поговорим.
[01:05:00.240 --> 01:05:02.240]  Деструктор должен быть публичным.
[01:05:02.240 --> 01:05:04.240]  Иначе будут всякие неприятные штуки.
[01:05:08.240 --> 01:05:10.240]  Да, кстати, давайте еще такой момент сделаем.
[01:05:10.240 --> 01:05:12.240]  Его на слайдах нет, но
[01:05:12.240 --> 01:05:14.240]  это тоже важно проговорить.
[01:05:14.240 --> 01:05:16.240]  В каких ситуациях
[01:05:16.240 --> 01:05:18.240]  еще вызываются конструкторы и деструкторы?
[01:05:18.240 --> 01:05:20.240]  Ну, вот, смотрите, вот, допустим, я
[01:05:20.240 --> 01:05:22.240]  хочу, чтобы у меня stack
[01:05:22.240 --> 01:05:24.240]  хранился в куче.
[01:05:24.240 --> 01:05:26.240]  Ну, то есть, не в смысле данные stack хранились в куче,
[01:05:26.240 --> 01:05:28.240]  они и так в куче хранятся.
[01:05:28.240 --> 01:05:30.240]  Я хочу, чтобы сама переменная stack,
[01:05:30.240 --> 01:05:32.240]  ну, не переменная, а вот
[01:05:32.240 --> 01:05:34.240]  само то место, где хранится stack,
[01:05:34.240 --> 01:05:36.240]  это была куча.
[01:05:36.240 --> 01:05:38.240]  То есть, грубо говоря, я хочу сделать вот так.
[01:05:38.240 --> 01:05:40.240]  auto ptr равно
[01:05:40.240 --> 01:05:42.240]  new stack.
[01:05:44.240 --> 01:05:46.240]  Понимаешь, что здесь происходит?
[01:05:46.240 --> 01:05:48.240]  Ну, я создаю stack,
[01:05:48.240 --> 01:05:50.240]  но в куче.
[01:05:50.240 --> 01:05:52.240]  Ну, и через вот этот ptr я могу
[01:05:52.240 --> 01:05:54.240]  вызывать всякие методы push,
[01:05:54.240 --> 01:05:56.240]  один,
[01:05:56.240 --> 01:05:58.240]  всякие топы,
[01:06:00.240 --> 01:06:02.240]  ну и так далее.
[01:06:02.240 --> 01:06:04.240]  Как вы думаете, вот в этом случае вызывается
[01:06:04.240 --> 01:06:06.240]  конструктор для stack или нет?
[01:06:06.240 --> 01:06:08.240]  Почему?
[01:06:14.240 --> 01:06:16.240]  Почему бы ему не вызваться?
[01:06:20.240 --> 01:06:24.240]  Потому что
[01:06:24.240 --> 01:06:26.240]  сам stack же как объект,
[01:06:26.240 --> 01:06:28.240]  он в куче находится.
[01:06:34.240 --> 01:06:36.240]  Ну, а сам объект
[01:06:36.240 --> 01:06:38.240]  надо создать,
[01:06:38.240 --> 01:06:40.240]  конструктор-то для него, наверное, должен быть вызван.
[01:06:40.240 --> 01:06:42.240]  Короче, ответ такой,
[01:06:42.240 --> 01:06:44.240]  конструктор вызывается
[01:06:44.240 --> 01:06:46.240]  не только, когда вы на stack
[01:06:46.240 --> 01:06:48.240]  создаете переменные,
[01:06:48.240 --> 01:06:50.240]  но и когда вы создаете объекты
[01:06:50.240 --> 01:06:52.240]  с помощью new.
[01:06:52.240 --> 01:06:54.240]  Вот new,
[01:06:54.240 --> 01:06:56.240]  операция new,
[01:06:56.240 --> 01:06:58.240]  тоже
[01:06:58.240 --> 01:07:00.240]  порождает вызов конструктора.
[01:07:00.240 --> 01:07:02.240]  То есть, в этом случае какой конструктор
[01:07:02.240 --> 01:07:04.240]  для stack будет вызван?
[01:07:04.240 --> 01:07:06.240]  Конструктор по умолчанию.
[01:07:06.240 --> 01:07:08.240]  Вы можете здесь указать
[01:07:08.240 --> 01:07:10.240]  внутри круглых скобок
[01:07:10.240 --> 01:07:12.240]  какие-то параметры, например, 10 и 1.
[01:07:12.240 --> 01:07:14.240]  И в этом случае у вас в куче
[01:07:14.240 --> 01:07:16.240]  создаться объект stack
[01:07:16.240 --> 01:07:18.240]  с параметрами 10 и 1.
[01:07:18.240 --> 01:07:20.240]  То есть, new
[01:07:20.240 --> 01:07:22.240]  тоже вызывает конструктор.
[01:07:22.240 --> 01:07:24.240]  То есть, объект
[01:07:24.240 --> 01:07:26.240]  без конструктора создаться не может.
[01:07:26.240 --> 01:07:28.240]  Для любого объекта все равно
[01:07:28.240 --> 01:07:30.240]  вызывается конструктор.
[01:07:30.240 --> 01:07:32.240]  Но, как вы правильно сказали,
[01:07:32.240 --> 01:07:34.240]  деструктора
[01:07:34.240 --> 01:07:36.240]  вызвана не будет.
[01:07:36.240 --> 01:07:38.240]  Действительно.
[01:07:38.240 --> 01:07:40.240]  Если вы создали объект в куче,
[01:07:42.240 --> 01:07:44.240]  это не локальный объект,
[01:07:44.240 --> 01:07:46.240]  если бы нет области видимости.
[01:07:46.240 --> 01:07:48.240]  Если вы выходите из области видимости,
[01:07:48.240 --> 01:07:50.240]  то у вас уничтожается сам указатель,
[01:07:50.240 --> 01:07:52.240]  сама переменная, в которой хранится адрес.
[01:07:52.240 --> 01:07:54.240]  Но сам stack продолжает жить в куче.
[01:07:54.240 --> 01:07:56.240]  Это обычное поведение.
[01:07:56.240 --> 01:07:58.240]  Хорошо.
[01:07:58.240 --> 01:08:00.240]  Чтобы эту память очистить,
[01:08:00.240 --> 01:08:02.240]  естественно, мы вызываем delete.
[01:08:02.240 --> 01:08:04.240]  Delete.ptr.
[01:08:04.240 --> 01:08:06.240]  Как вы думаете, при вызове delete
[01:08:06.240 --> 01:08:08.240]  вызывается деструктор или нет?
[01:08:08.240 --> 01:08:10.240]  Видимо, да.
[01:08:10.240 --> 01:08:12.240]  Когда вы вызываете delete,
[01:08:12.240 --> 01:08:14.240]  то нью порождает вызов деструктора.
[01:08:16.240 --> 01:08:18.240]  То есть нью порождает вызов конструктора,
[01:08:18.240 --> 01:08:20.240]  а delete сначала вызывает деструктор
[01:08:20.240 --> 01:08:22.240]  у того объекта, у которого вы вызываете delete,
[01:08:22.240 --> 01:08:24.240]  а потом очищает память,
[01:08:24.240 --> 01:08:26.240]  у которой оставился бы объект.
[01:08:26.240 --> 01:08:28.240]  Поэтому нью и delete тоже порождают вызовы
[01:08:28.240 --> 01:08:30.240]  конструкторов и деструкторов.
[01:08:30.240 --> 01:08:32.240]  Вот такое замечание.
[01:08:34.240 --> 01:08:36.240]  Ну, ptr на что указывает?
[01:08:36.240 --> 01:08:38.240]  На stack.
[01:08:38.240 --> 01:08:40.240]  Поэтому будет вызван деструктор stack.
[01:08:42.240 --> 01:08:44.240]  Почему?
[01:08:46.240 --> 01:08:48.240]  Потому что
[01:08:48.240 --> 01:08:50.240]  когда вы вызываете...
[01:08:50.240 --> 01:08:52.240]  Потому что компилятор не понимает,
[01:08:52.240 --> 01:08:54.240]  в каком случае нужно освободить память в куче.
[01:08:54.240 --> 01:08:56.240]  Вы создали
[01:08:56.240 --> 01:08:58.240]  объект в куче.
[01:08:58.240 --> 01:09:00.240]  Сохрани на него указатель.
[01:09:00.240 --> 01:09:02.240]  И объект продолжает жить в куче.
[01:09:02.240 --> 01:09:04.240]  Когда вы выходите из области видимости, у вас уничтожается указатель.
[01:09:04.240 --> 01:09:06.240]  У нас в языке C++ нет сборки мусора.
[01:09:06.240 --> 01:09:08.240]  Если у нас была, как в джаве
[01:09:08.240 --> 01:09:10.240]  или в питоне, сборка мусора,
[01:09:10.240 --> 01:09:12.240]  то компилятор бы понял, а на этот объект никто больше не ссылается,
[01:09:12.240 --> 01:09:14.240]  то есть на него нет указателей, значит его нужно удалить.
[01:09:14.240 --> 01:09:16.240]  А в данном случае нет.
[01:09:16.240 --> 01:09:18.240]  То есть вы создали объект в куче, и вы теперь сами ответственно
[01:09:18.240 --> 01:09:20.240]  за то, чтобы его как-то самостоятельно уничтожить
[01:09:20.240 --> 01:09:22.240]  или самостоятельно создать.
[01:09:24.240 --> 01:09:26.240]  Но это то же самое, как если вы
[01:09:26.240 --> 01:09:28.240]  с помощью нью выделяете массив,
[01:09:28.240 --> 01:09:30.240]  и массив у вас тоже автоматически оттуда не удаляется.
[01:09:30.240 --> 01:09:32.240]  Вы должны явно сами очистить этот массив.
[01:09:36.240 --> 01:09:38.240]  Поэтому, грубо говоря, когда вы используете нью и delete,
[01:09:38.240 --> 01:09:40.240]  вы сами вручную управляете временем жизни объекта.
[01:09:40.240 --> 01:09:42.240]  То есть вы сами
[01:09:42.240 --> 01:09:44.240]  начинаете жизнь объекта с помощью нью,
[01:09:44.240 --> 01:09:46.240]  вы его породили, и сами должны
[01:09:46.240 --> 01:09:48.240]  уничтожить с помощью delete.
[01:09:52.240 --> 01:09:54.240]  А если вы создаете объекты в локальной области видимости,
[01:09:54.240 --> 01:09:56.240]  то есть на стеке, то тут проблем нет.
[01:09:58.240 --> 01:10:00.240]  Стек создался, а вот конструктор.
[01:10:00.240 --> 01:10:02.240]  Мы вышли из области действия, из области видимости,
[01:10:02.240 --> 01:10:04.240]  стек должен быть уничтожен, все понятно.
[01:10:08.240 --> 01:10:10.240]  Что значит, как-то не так.
[01:10:16.240 --> 01:10:18.240]  А зачем?
[01:10:22.240 --> 01:10:24.240]  Мы будем
[01:10:24.240 --> 01:10:26.240]  говорить про умные указатели,
[01:10:26.240 --> 01:10:28.240]  в частности про SharedPtr.
[01:10:28.240 --> 01:10:30.240]  Вот там пример такое поведение.
[01:10:30.240 --> 01:10:32.240]  Когда объект удаляется,
[01:10:32.240 --> 01:10:34.240]  точнее, когда вы выходите
[01:10:34.240 --> 01:10:36.240]  за область видимости, когда вызывается
[01:10:36.240 --> 01:10:38.240]  конструктор для умного указателя,
[01:10:38.240 --> 01:10:40.240]  то объект, на который он указывает, он удаляется не сразу,
[01:10:40.240 --> 01:10:42.240]  ну а позже, когда на него уже никто больше не ссылается.
[01:10:42.240 --> 01:10:44.240]  Вот так можно.
[01:10:44.240 --> 01:10:46.240]  А вот прям, чтобы сказать явно,
[01:10:46.240 --> 01:10:48.240]  что удали не сейчас, а через 5 секунд, то нет.
[01:10:48.240 --> 01:10:50.240]  Ну, точнее, можно
[01:10:50.240 --> 01:10:52.240]  с помощью параллельности, с помощью потоков,
[01:10:52.240 --> 01:10:54.240]  но это вам не нужно.
[01:10:58.240 --> 01:11:00.240]  Дальше?
[01:11:02.240 --> 01:11:04.240]  Да, ну и, соответственно,
[01:11:04.240 --> 01:11:06.240]  ну снова вспоминаем, что
[01:11:06.240 --> 01:11:08.240]  для Stacking мы на самом деле не писали свой деструктор,
[01:11:08.240 --> 01:11:10.240]  и вообще для структура вы не писали свой деструктор.
[01:11:10.240 --> 01:11:12.240]  То есть вы его не писали, а он есть.
[01:11:12.240 --> 01:11:14.240]  На самом делеيل конструктор за вас пишет деструкторы.
[01:11:14.240 --> 01:11:16.240]  Что он делает?
[01:11:18.240 --> 01:11:20.240]  Ну, простой ответ, но неправильно.
[01:11:20.240 --> 01:11:22.240]  Это ничего не делает
[01:11:22.240 --> 01:11:24.240]  И это примерно правильный ответ,
[01:11:24.240 --> 01:11:26.240]  то есть если у вас действительно
[01:11:26.240 --> 01:11:28.240]  в классе поля только примитивных типов,
[01:11:28.240 --> 01:11:30.240]  тогда boring.
[01:11:30.240 --> 01:11:32.240]  Если вы пишете свою структуру для комплексных чисел,
[01:11:32.240 --> 01:11:39.120]  чисел, то деструктор просто-напросто забьет. Ну хорошо, была переменная комплексная числость,
[01:11:39.120 --> 01:11:44.000]  теперь ее нет. Ну все, короче, я просто указатель стека сдвигаю, там теперь хранится то, что хранилось
[01:11:44.000 --> 01:11:50.160]  раньше, я перезаписывать ничего не буду. Ну это нормальное поведение. Если объекты это примитивный
[01:11:50.160 --> 01:11:56.040]  тип, то ничего делать не надо. Но при этом, если в качестве полей у вас выступают объекты других
[01:11:56.040 --> 01:12:12.240]  классов, то для них вызываются деструкторы. Ну то есть, если у вас есть, уйди, если у вас есть класс A,
[01:12:12.240 --> 01:12:24.520]  и он как-то написан, и у вас есть класс B, у которого внутри есть int x и аа, ну и при этом для B вы
[01:12:24.520 --> 01:12:29.160]  не написали своего деструктора, то для B все равно деструктор будет создан за вас, ну потому что
[01:12:29.160 --> 01:12:36.040]  для любого объекта обязательно должен быть вызван деструктор. И вот в этом случае деструктор
[01:12:36.040 --> 01:12:40.720]  для B, который создался для вас компилятор, он x просто проигнорирует, потому что примитивный
[01:12:40.720 --> 01:12:48.880]  тип, с ним ничего делать не надо, а вот для A он самостоятельно вызовет деструктор. Понятно? То есть
[01:12:48.880 --> 01:12:54.360]  деструкторы для полей всегда вызывают автоматические, то есть вам самостоятельно этого делать не
[01:12:54.360 --> 01:13:01.280]  нужно, окей? То есть компилятор достаточно умный, чтобы самостоятельно уничтожить поля класса.
[01:13:01.280 --> 01:13:15.160]  Ну естественно, дефолтный деструктор вам не доступен, если у какого-то поля класса нет
[01:13:15.160 --> 01:13:24.120]  деструктора. Ну например, снова есть класс A, у которого приватный деструктор, и вы создаете
[01:13:24.120 --> 01:13:31.560]  объект типа A. Вот объект типа A на стеке в данном случае создать нельзя, ну это другой пример на
[01:13:31.560 --> 01:13:37.720]  самом деле, это пример того, что произойдет, если у вас будет приватный деструктор. Вот если
[01:13:37.720 --> 01:13:41.440]  у вас приватный деструктор, то вы получите довольно интересный артефакт, ваши объекты теперь
[01:13:41.440 --> 01:13:47.160]  нельзя создавать на стеке. Впрочем, если у вас есть, если вы написали приватный деструктор, то есть
[01:13:47.160 --> 01:13:54.400]  деструктор, который никому не доступен, то просто так создавать объекты вам нельзя. Как вы думаете,
[01:13:54.400 --> 01:14:04.120]  почему нельзя? Что? Ну нет, тут другая проблема. Ну как бы у меня класс A пустой, у него и так
[01:14:04.120 --> 01:14:13.240]  ничего не утекает. В принципе его вызвать нельзя. Тут проблема в том, смотрите, когда вы
[01:14:13.240 --> 01:14:19.680]  создаете объект A, и когда вы выходите из области его действия, вот тут компилятор за вас подставляет
[01:14:19.680 --> 01:14:26.960]  вызов деструктора. Когда вы выходите из области действия, вызывается деструктор. Но компилятор
[01:14:26.960 --> 01:14:32.680]  не может вызвать деструктор, потому что вы скажете, что он приватный. Вот проблема. Поэтому вы
[01:14:32.680 --> 01:14:37.600]  получите, если вы напишете так, то вы получите ошибку, что короче, деструктор приватный, и создавать
[01:14:37.600 --> 01:14:47.120]  объекты на стеке вам нельзя. Поэтому не делайте приватный деструктор, вам этого не нужно.
[01:14:47.120 --> 01:15:02.320]  С чем? С приватным конструктором у нас было такое же, но была другая проблема. Вам создать
[01:15:02.320 --> 01:15:08.400]  объект нельзя, а тут проблема другая. Вам создать объект можно, но уничтожить его нельзя. Но компилятор
[01:15:08.400 --> 01:15:11.940]  в любом случае попытается его уничтожить, поэтому в любом случае у вас будет ошибка
[01:15:11.940 --> 01:15:17.560]  компиляции. Если у вас приватный конструктор, там особо нет проблем. То есть если вы делаете
[01:15:17.560 --> 01:15:20.920]  приватный конструктор, то вы говорите, что этот конструктор вызвать нельзя. Ну окей, тогда вы
[01:15:20.920 --> 01:15:27.520]  можете воспользоваться другим конструктором. А здесь в принципе проблема в том, что если вы
[01:15:27.520 --> 01:15:31.520]  когда вы создаете объект на стеке, то вам придется его в какой-то момент уничтожить.
[01:15:31.520 --> 01:15:33.520]  Точнее, компилятору придется его уничтожить.
[01:15:33.520 --> 01:15:36.520]  Но он не может его уничтожить, потому что он плеватый.
[01:15:43.520 --> 01:15:47.520]  Ну и вопрос, что нужно делать в деструкторе, нужно ли писать свой деструктор и так далее.
[01:15:47.520 --> 01:15:49.520]  Мы это на самом деле уже проговорили.
[01:15:49.520 --> 01:15:53.520]  Если для уничтожения объекта никакой нетривиальной логики не требуется,
[01:15:53.520 --> 01:15:56.520]  то деструктора писать не нужно.
[01:15:56.520 --> 01:15:59.360]  Если вы пишете свой класс комплексного числа,
[01:15:59.360 --> 01:16:02.520]  свой класс, не знаю, рационального числа и так далее,
[01:16:02.520 --> 01:16:04.520]  то свой деструктор писать не нужно,
[01:16:04.520 --> 01:16:06.520]  потому что компилятор справится за вас.
[01:16:07.520 --> 01:16:10.520]  Если у вас есть какая-то нетривиальная логика,
[01:16:10.520 --> 01:16:12.520]  например при уничтожении объекта вы знаете,
[01:16:12.520 --> 01:16:14.520]  что вам нужно очистить память.
[01:16:15.520 --> 01:16:18.520]  То есть вы знаете, что в процессе своей работы ваш класс выделяет память.
[01:16:18.520 --> 01:16:20.520]  ваш класс открывает какие-то файлы,
[01:16:20.520 --> 01:16:22.520]  ваш класс открывает сетиовые соединения.
[01:16:22.520 --> 01:16:25.520]  Вот при уничтожении объекта вы знаете, что вам нужно это все закрыть.
[01:16:25.520 --> 01:16:27.520]  все эти ресурсы вернуть в операционной системе.
[01:16:27.520 --> 01:16:30.520]  Все эти действия нужно прописывать в деструкторе.
[01:16:30.520 --> 01:16:36.520]  Общее правило такое, если вы как-то работаете с ресурсами ограниченными,
[01:16:36.520 --> 01:16:40.520]  то нужно их корректно возвращать в деструкторе.
[01:16:40.520 --> 01:16:44.520]  Если у вас такого нет, то не пишите деструктор, вам он не нужен.
[01:16:45.520 --> 01:16:57.520]  Последнее правило тоже я проговорил, что у каждого поля в вашем классе все равно будет вызван деструктор.
[01:16:57.520 --> 01:16:59.520]  Поэтому вручную вызывать деструктор не нужно.
[01:16:59.520 --> 01:17:02.520]  Нужно просто сделать те действия, с до которых компилятор не додумается.
[01:17:02.520 --> 01:17:07.520]  Например, освободить память с помощью delete, закрыть файл и так далее.
[01:17:15.520 --> 01:17:20.520]  Если вы не писали свой деструктор, то компилятор за вас напишет деструктор.
[01:17:20.520 --> 01:17:25.520]  Если вам не нужен деструктор, то вообще его не пишите.
[01:17:25.520 --> 01:17:30.520]  Если у вас деструктор тривиальный, то его писать вообще не нужно.
[01:17:30.520 --> 01:17:34.520]  Продолжение предыдущего слайда.
[01:17:34.520 --> 01:17:37.520]  Для стека нужно очистить память.
[01:17:37.520 --> 01:17:39.520]  Вот это действие нужно прописать.
[01:17:39.520 --> 01:17:45.520]  Многие еще пишут вот такую строку, но зачем?
[01:17:45.520 --> 01:17:48.520]  У вас стек все равно уничтожается.
[01:17:48.520 --> 01:17:50.520]  Этим стеком все равно никто не воспользуется.
[01:17:50.520 --> 01:17:52.520]  Зачем вы делаете size равно 0?
[01:17:52.520 --> 01:17:54.520]  Не нужно это делать.
[01:17:54.520 --> 01:17:57.520]  Сайд самостоятельно уничтожится, сам вернется в систему.
[01:17:57.520 --> 01:18:00.520]  Так можно сделать, но не обязательно.
[01:18:00.520 --> 01:18:03.520]  Так делать тоже не нужно.
[01:18:03.520 --> 01:18:06.520]  Если у вас есть структура B, и в ней есть поле stack,
[01:18:06.520 --> 01:18:10.520]  то в деструкторе B не нужно вызывать самостоятельный деструктор для стека.
[01:18:10.520 --> 01:18:13.520]  Компилятор сам за вас справится, он это все сделает.
[01:18:13.520 --> 01:18:17.520]  Вы главное, память очистите, если вы что-то выделяли, и все.
[01:18:17.520 --> 01:18:23.520]  Поэтому для структуры B деструктор в принципе не нужен.
[01:18:23.520 --> 01:18:28.520]  Почему вы выделили деструктор вручную?
[01:18:28.520 --> 01:18:32.520]  Потому что тут вы вызвали деструктор вручную.
[01:18:32.520 --> 01:18:34.520]  То есть вы самостоятельно уничтожили S.
[01:18:34.520 --> 01:18:39.520]  Но компилятор всегда, после того, как заканчивается деструктор,
[01:18:39.520 --> 01:18:43.520]  он самостоятельно уничтожает все поля класса, точнее он высчитает эти поля.
[01:18:43.520 --> 01:18:47.520]  Поэтому компилятор снова вызывает деструктор для S.
[01:18:47.520 --> 01:18:52.520]  Но это разговор о том, что компилятор всегда вызывает деструктор у всех полей.
[01:18:52.520 --> 01:18:57.520]  Если вы самостоятельно вызовите деструктор, то вы вызовете его второй раз.
[01:18:57.520 --> 01:19:03.520]  А этого делать не нужно.
[01:19:03.520 --> 01:19:15.520]  Мы закончили обсуждать конструкторы, деструкторы, и сейчас я утверждаю, что мы на самом деле можем
[01:19:15.520 --> 01:19:20.520]  в полной мере реализовать одну из важнейших идиом языка C++, а именно RAI,
[01:19:20.520 --> 01:19:26.520]  или Resource Acquisition is Initialization, то есть захват ресурса, есть инициализация.
[01:19:26.520 --> 01:19:31.520]  В чем это идиом состоит? А идиом заключается в следующем, что всякий раз,
[01:19:31.520 --> 01:19:49.520]  когда вам нужен, говорим про RAI, захват ресурса, есть инициализация.
[01:19:49.520 --> 01:19:55.520]  Идиом говорит следующее, что всякий раз, когда вам нужен какой-то ресурс,
[01:19:55.520 --> 01:20:07.520]  например, память, соединение по сети, мютекс, что угодно, этот объект необходимо оборачивать
[01:20:07.520 --> 01:20:13.520]  в некоторые классы в деструктуру, чтобы захват этого ресурса происходил автоматически в конструкторе,
[01:20:13.520 --> 01:20:20.520]  а освобождение происходило автоматически в деструкторе. Понятно, почему это важно, почему это нужно?
[01:20:20.520 --> 01:20:27.520]  Потому что если вы ресурс захватываете внутри какого-то класса, то этот же ресурс будет автоматически освобождаться в деструкторе.
[01:20:27.520 --> 01:20:33.520]  То есть теперь вам не нужно думать о том, чтобы вовремя освободить ресурс, чтобы вовремя вызвать delete,
[01:20:33.520 --> 01:20:38.520]  вовремя сделать Unlock для мютекса и тому подобное и так далее. Понятно?
[01:20:38.520 --> 01:20:45.520]  То есть исследование данной идиоми и оборачивание ресурсов в некоторые так называемые классы обертки,
[01:20:45.520 --> 01:20:52.520]  например, мы будем говорить про класс Vector. Vector в языке C++ это некоторая обертка над динамическим массивом.
[01:20:52.520 --> 01:20:59.520]  Будем говорить про умные указатели. Это, собственно, обертка над обычными указателями, которые ведут в кучу и так далее.
[01:20:59.520 --> 01:21:07.520]  Если мы для каждой такой ситуации заведем свою обертку ООП-шную, то все будет замечательно.
[01:21:07.520 --> 01:21:14.520]  Не нужно вызывать никаких вручную delete и так далее, все будет происходить автоматически, тем самым повышая безопасность ваших программ.
[01:21:14.520 --> 01:21:21.520]  Ну и здесь пример. Пример абсолютно не связан с реальностью.
[01:21:21.520 --> 01:21:27.520]  Мы спустя какое-то время напишем свой стильный, модный, молодежный, классный, умный указатель.
[01:21:27.520 --> 01:21:34.520]  Но пока пример такой. Смотрите, я могу создавать объекты в куче с помощью new.
[01:21:34.520 --> 01:21:40.520]  Например, автоптр равно new int и 10. Создается десятка в динамической области памяти.
[01:21:40.520 --> 01:21:45.520]  Теперь мне нужно следить за тем, чтобы для этого ptr я вовремя вызвал delete.
[01:21:45.520 --> 01:21:52.520]  Как бы выглядело все то же самое, но если мы следуем идиоме раи. Выглядит это следующим образом.
[01:21:52.520 --> 01:21:59.520]  У нас есть класс int ptr, который из себя представляет указатель на int.
[01:21:59.520 --> 01:22:04.520]  В поле он, собственно, этот самый указатель на int сохраняет.
[01:22:04.520 --> 01:22:14.520]  В конструкторе мы выделяем память и инициализируем это значение тем аргументом, который нам передали.
[01:22:14.520 --> 01:22:18.520]  А в диструкторе этот самый указатель освобождаем.
[01:22:18.520 --> 01:22:24.520]  Если мы пользуемся этим классом int ptr, то при создании объекта у нас автоматически происходит выделение ресурса.
[01:22:24.520 --> 01:22:29.520]  А при уничтожении этого объекта, когда он выходит из области действия, автоматически происходит вызов диструктора.
[01:22:29.520 --> 01:22:33.520]  Теперь нам не нужно вручную вызывать не new, не delete. Все происходит автоматически из-за нас.
[01:22:33.520 --> 01:22:39.520]  Понятно? В этом стоит смысл идиома раи.
[01:22:39.520 --> 01:22:45.520]  Один из последних пунктов. Поговорим про порядок вызова конструкторов и диструкторов.
[01:22:45.520 --> 01:22:53.520]  Важно помнить, что конструкторы вызываются в точности в порядке объявлений.
[01:22:53.520 --> 01:22:59.520]  Это мы уже говорили, когда говорили про списке инициализации.
[01:22:59.520 --> 01:23:03.520]  Мы говорили, что поля создаются в том порядке, в котором вы объявили.
[01:23:03.520 --> 01:23:07.520]  Тоже самое верно для любых переменных.
[01:23:07.520 --> 01:23:11.520]  Если вы создаете объект A, а потом B, то сначала создается объект A, а потом B.
[01:23:11.520 --> 01:23:19.520]  А уничтожаются они в обратном порядке. Сначала уничтожится объект B, а потом уничтожится объект A.
[01:23:19.520 --> 01:23:21.520]  Для полей или структуры всё тоже самое.
[01:23:21.520 --> 01:23:28.520]  Если у вас есть какой-то класс c, у которого в качестве полей содержится f1, f2, f3.
[01:23:28.520 --> 01:23:46.280]  Когда будет вызвана диструктор c, для этих полей в следующем
[01:23:46.280 --> 01:23:48.280]  Как вы думаете, для чего это может быть нужно?
[01:23:48.280 --> 01:23:50.280]  Или почему так сделано?
[01:23:52.280 --> 01:23:56.280]  Ну а какая разница? От перестановки это вызовет деструкторов. Что может поменяться?
[01:24:00.280 --> 01:24:02.280]  Что еще раз?
[01:24:06.280 --> 01:24:08.280]  Ну что вы имеете в виду? В каком смысле?
[01:24:10.280 --> 01:24:12.280]  Да, да, да. Ну правильно.
[01:24:12.280 --> 01:24:16.280]  Смотрите, действительно, так как у меня сначала создается f1, потом f2, потом f3,
[01:24:16.280 --> 01:24:18.280]  то есть я вполне себе могу закладываться в такое поведение.
[01:24:18.280 --> 01:24:24.280]  То есть у меня f2, например, внутри себя может как-то не явно содержать информацию об f1.
[01:24:24.280 --> 01:24:32.280]  Так как f2 объявлен позже, чем f1, то f2 вполне себе, например, внутри себя может хранить ссылку на f1, указатель на f1 и что угодно.
[01:24:33.280 --> 01:24:37.280]  Поэтому, если я уничтожу f1 раньше, чем f2, то будет печально.
[01:24:38.280 --> 01:24:41.280]  То есть f2 будет пользоваться уже уничтоженным объектом.
[01:24:42.280 --> 01:24:44.280]  Но это может испортить поведение моей программы.
[01:24:45.280 --> 01:24:55.280]  Поэтому я сначала уничтожаю f3, от которого точно уже другие аргументы не зависят, уничтожаю f2, от которого f1 не зависят, но уже потом уничтожаю f1.
[01:24:58.280 --> 01:25:02.280]  Ну и плюс еще одно объяснение, что на самом деле переменные так тупо располагаются на стеке.
[01:25:02.280 --> 01:25:05.280]  То есть когда вы заводите переменную a, у вас кладется a.
[01:25:05.280 --> 01:25:08.280]  Потом когда вы создаете переменную b, у вас переменная b остается на стеке.
[01:25:08.280 --> 01:25:12.280]  Но естественно, чтобы уничтожить переменную, то переменная уничтожается в обратном порядке.
[01:25:12.280 --> 01:25:15.280]  Сначала из стека извлекается b, а потом из стека извлекается a.
[01:25:15.280 --> 01:25:17.280]  Поэтому уничтожается в обратном порядке.
[01:25:18.280 --> 01:25:19.280]  Понятно, да?
[01:25:21.280 --> 01:25:29.280]  Ну и еще одно важное правило, которому нужно следовать после того, как мы рассмотрели сегодня конструкторы-деструкторы.
[01:25:30.280 --> 01:25:36.280]  Есть так называемое правило 3, которое в процессе нашего курса эволюционирует до правила 5,
[01:25:36.280 --> 01:25:38.280]  а потом к концу курса мы узнаем про правило 0.
[01:25:38.280 --> 01:25:40.280]  Но это уже другая история.
[01:25:40.280 --> 01:25:42.280]  Пока давайте поговорим про правило 3.
[01:25:42.280 --> 01:25:44.280]  Правило 3 звучит следующим образом.
[01:25:44.280 --> 01:25:46.280]  Правило 3 – это не правило языка.
[01:25:46.280 --> 01:25:50.280]  То есть если вы не будете ему следовать, то компилятор в принципе не расстроится.
[01:25:50.280 --> 01:25:55.280]  Расстроится ваш семинарист и так далее, но вот с компилятором все будет нормально, он переживет.
[01:25:56.280 --> 01:25:58.280]  Правило 3 – это скорее правило приличия.
[01:25:58.280 --> 01:26:00.280]  И звучит оно следующим образом.
[01:26:00.280 --> 01:26:11.280]  Если в вашем классе необходимо написать конструктор копирования или деструктор или присваивание –
[01:26:11.280 --> 01:26:16.280]  про присваивание мы поговорим сегодня, спустя какое-то время.
[01:26:16.280 --> 01:26:22.280]  Если вам нужно реализовать одно из трех, либо деструктор, либо конструктор-копирование, либо копирующее присваивание,
[01:26:22.280 --> 01:26:27.280]  если у вас появилась необходимость в чем-то одном, то нужно реализовать сразу все три.
[01:26:27.280 --> 01:26:36.740]  Опять же, это не правил языка. Если вы напишите деструктор, но при этом не напишите копирование или присваивание, то конструктор от этого
[01:26:36.740 --> 01:26:46.380]  не пострадает. Пострадает, скорее всего, ваша программа. Почему? Потому что смотрите, давайте подумаем, в каком случае нам нужно писать свой деструктор или конструктор копирования?
[01:26:46.380 --> 01:26:52.940]  Мы уже говорили, что деструктор и конструктор копирования мы пишем, если мы как-то нитривиально управляем памятью для стека.
[01:26:52.940 --> 01:26:58.920]  Для стека мы, естественным образом, пришли к мысли, что нужно написать деструктор, потому что нам нужно делать delete.
[01:26:58.920 --> 01:27:02.960]  То же самое для стека мы пришли к мысли, что нужно написать конструктор копирования,
[01:27:02.960 --> 01:27:07.380]  потому что дефолтное копирование нас не устраивает.
[01:27:07.380 --> 01:27:11.040]  Ну скорее всего, если вы пишете свое деструкторе-конструктор-копирование,
[01:27:11.040 --> 01:27:14.540]  то это значит, что у вас есть какое-то управление ресурсами,
[01:27:14.540 --> 01:27:18.040]  а если у вас есть управление ресурсами, вам нужно не забыть и написать корректный деструктор,
[01:27:18.040 --> 01:27:21.040]  корректное копирование и корректное присваивание.
[01:27:21.040 --> 01:27:23.040]  Вот такое правило.
[01:27:23.040 --> 01:27:25.040]  Окей?
[01:27:25.040 --> 01:27:27.040]  Поэтому оно так называется, правило трех,
[01:27:27.040 --> 01:27:29.040]  потому что он фигурирует три сущности.
[01:27:29.040 --> 01:27:31.040]  Вот.
[01:27:31.040 --> 01:27:33.040]  Да, ну и позже мы поговорим про правило пяти
[01:27:33.040 --> 01:27:35.040]  и правило нуля. То есть это все будет.
[01:27:35.040 --> 01:27:37.040]  Вопросы?
[01:27:37.040 --> 01:27:39.040]  Да.
[01:27:39.040 --> 01:27:41.040]  То есть нужно будет реализовать
[01:27:41.040 --> 01:27:43.040]  прям их полностью,
[01:27:43.040 --> 01:27:45.040]  или достаточно будет
[01:27:45.040 --> 01:27:47.040]  получить компилятор?
[01:27:47.040 --> 01:27:49.040]  Если вас устраивает то,
[01:27:49.040 --> 01:27:51.040]  как компилятор себя поведет в этом случае,
[01:27:51.040 --> 01:27:53.040]  то можно написать default.
[01:27:53.040 --> 01:27:55.040]  Не, просто как правило,
[01:27:55.040 --> 01:27:57.040]  опять же, если у вас возникла
[01:27:57.040 --> 01:27:59.040]  супер потребность написать destructor,
[01:27:59.040 --> 01:28:01.040]  то скорее всего, в 99% случаев
[01:28:01.040 --> 01:28:03.040]  вам просто необходимо
[01:28:03.040 --> 01:28:05.040]  написать и копирование, и присваивание.
[01:28:05.040 --> 01:28:07.040]  То есть скорее всего у вас
[01:28:07.040 --> 01:28:09.040]  дефолтное поведение не устраивает.
[01:28:09.040 --> 01:28:11.040]  Вот как в случае со stack.
[01:28:11.040 --> 01:28:13.040]  Опять же, да, это просто такое правило
[01:28:13.040 --> 01:28:15.040]  программистов среди C++.
[01:28:15.040 --> 01:28:17.040]  Вот.
[01:28:17.040 --> 01:28:19.040]  Да, ну и собственно демонстрация
[01:28:19.040 --> 01:28:21.040]  этого правила, например, для случая
[01:28:21.040 --> 01:28:23.040]  псевдоумного указателя,
[01:28:23.040 --> 01:28:25.040]  который мы написали для int.
[01:28:25.040 --> 01:28:27.040]  То есть мы написали свой конструктор
[01:28:27.040 --> 01:28:29.040]  копирования, написали свое присваивание
[01:28:29.040 --> 01:28:31.040]  и написали свой destructor.
[01:28:31.040 --> 01:28:33.040]  Да, ну и тут
[01:28:33.040 --> 01:28:35.040]  вопрос на подумать, что произойдет,
[01:28:35.040 --> 01:28:37.040]  если не реализовать хотя бы один из методов.
[01:28:37.040 --> 01:28:39.040]  Ну, я думаю, понятно. Если не реализуете destructor,
[01:28:39.040 --> 01:28:41.040]  то у вас утечка памяти.
[01:28:41.040 --> 01:28:43.040]  Если не реализуете конструктор копирования,
[01:28:43.040 --> 01:28:45.040]  то что происходит?
[01:28:45.040 --> 01:28:47.040]  У вас получается
[01:28:47.040 --> 01:28:49.040]  два объекта,
[01:28:49.040 --> 01:28:51.040]  которые указывают
[01:28:51.040 --> 01:28:53.040]  на одну и ту же область памяти.
[01:28:53.040 --> 01:28:55.040]  Да?
[01:28:55.040 --> 01:28:57.040]  А к чему это в итоге может привести?
[01:28:57.040 --> 01:28:59.040]  Да, к двойному удалению.
[01:28:59.040 --> 01:29:01.040]  То есть естественно у вас для х будет вызван destructor
[01:29:01.040 --> 01:29:03.040]  и для y будет вызван destructor,
[01:29:03.040 --> 01:29:05.040]  но так как они указывают на ту же область памяти,
[01:29:05.040 --> 01:29:07.040]  то у вас одна и ту же область памяти будет очищена
[01:29:07.040 --> 01:29:09.040]  два раза, что делать запрещено.
[01:29:09.040 --> 01:29:11.040]  Понятно?
[01:29:11.040 --> 01:29:13.040]  Ну и все остальные приколы там связаны с тем,
[01:29:13.040 --> 01:29:15.040]  что если вы тут измените значение 10
[01:29:15.040 --> 01:29:17.040]  на значение 11,
[01:29:17.040 --> 01:29:19.040]  то это же значение изменится и для y,
[01:29:19.040 --> 01:29:21.040]  и для всех остальных,
[01:29:21.040 --> 01:29:23.040]  кто указывает на эту область памяти.
[01:29:23.040 --> 01:29:25.040]  Чего, наверное, вы бы не хотели.
[01:29:29.040 --> 01:29:31.040]  Что?
[01:29:31.040 --> 01:29:33.040]  Ну, про пресваивание мы еще не говорили,
[01:29:33.040 --> 01:29:35.040]  но в целом история такая же.
[01:29:35.040 --> 01:29:37.040]  Вот смотрите, допустим,
[01:29:37.040 --> 01:29:39.040]  пресваивание на самом деле еще более печальная ситуация.
[01:29:39.040 --> 01:29:41.040]  Тут, кстати, пресваивание неправильно реализовано.
[01:29:41.040 --> 01:29:43.040]  Кто понимает, что тут неправильно?
[01:29:43.040 --> 01:29:45.040]  Ну ладно, сейчас объясню.
[01:29:45.040 --> 01:29:47.040]  В общем, смотрите, у вас есть x
[01:29:47.040 --> 01:29:49.040]  и тут есть y,
[01:29:49.040 --> 01:29:51.040]  и они живут своей жизнью.
[01:29:51.040 --> 01:29:53.040]  А дальше вы в какой-то момент решили,
[01:29:53.040 --> 01:29:55.040]  что x должен быть равен y.
[01:29:57.040 --> 01:29:59.040]  Допустим, вы решили,
[01:29:59.040 --> 01:30:01.040]  что x должен указывать
[01:30:01.040 --> 01:30:03.040]  туда же,
[01:30:03.040 --> 01:30:05.040]  точнее так.
[01:30:05.040 --> 01:30:07.040]  Вы хотите скопировать значение,
[01:30:07.040 --> 01:30:09.040]  на которое указывает x,
[01:30:09.040 --> 01:30:11.040]  хотя нет, тут все правильно, я вру.
[01:30:21.040 --> 01:30:23.040]  Нет, тут все нормально, в общем.
[01:30:23.040 --> 01:30:25.040]  Тут никакой ошибки нет, тут просто поведение другое.
[01:30:25.040 --> 01:30:27.040]  Допустим, у x была десятка,
[01:30:27.040 --> 01:30:29.040]  у y была двенадцать.
[01:30:29.040 --> 01:30:31.040]  И когда я присваиваю x равно y,
[01:30:31.040 --> 01:30:33.040]  на самом деле довольно странное поведение,
[01:30:33.040 --> 01:30:35.040]  но мы хотим, чтобы эта десятка заменилась на двенадцать.
[01:30:35.040 --> 01:30:37.040]  И все.
[01:30:37.040 --> 01:30:39.040]  Но мы не напишем присваивания.
[01:30:39.040 --> 01:30:41.040]  Допустим, мы забыли написать присваивания.
[01:30:41.040 --> 01:30:43.040]  Тогда что произойдет?
[01:30:43.040 --> 01:30:45.040]  Тогда спойлер, сейчас мы об этом поговорим,
[01:30:45.040 --> 01:30:47.040]  но тогда просто произойдет то,
[01:30:47.040 --> 01:30:49.040]  что x будет указывать туда же, куда y.
[01:30:51.040 --> 01:30:53.040]  То есть если мы написали свои присваивания,
[01:30:53.040 --> 01:30:55.040]  то стандартное присваивание работает таким образом,
[01:30:55.040 --> 01:30:57.040]  что оно просто присваивает все поля.
[01:30:57.040 --> 01:30:59.040]  И снова возникает та же самая проблема,
[01:30:59.040 --> 01:31:01.040]  что и с конструктором копирования.
[01:31:01.040 --> 01:31:03.040]  Два объекта указывают на одну и ту же область.
[01:31:03.040 --> 01:31:05.040]  Поэтому что?
[01:31:05.040 --> 01:31:07.040]  Что еще раз?
[01:31:09.040 --> 01:31:11.040]  Почему x становится ссылкой y?
[01:31:11.040 --> 01:31:13.040]  Внутри x хранится указатель,
[01:31:13.040 --> 01:31:15.040]  и вот этот указатель указывает туда же,
[01:31:15.040 --> 01:31:17.040]  куда указывает y.
[01:31:21.040 --> 01:31:23.040]  Это логично, но у нас неправильное поведение у деструктора тогда.
[01:31:23.040 --> 01:31:25.040]  Потому что деструктор
[01:31:25.040 --> 01:31:27.040]  он удаляет в любом случае.
[01:31:27.040 --> 01:31:29.040]  А если мы два раза удаляем одну и ту же память,
[01:31:29.040 --> 01:31:31.040]  это плохо.
[01:31:31.040 --> 01:31:33.040]  В общем, это просто пример.
[01:31:35.040 --> 01:31:37.040]  Данный класс им пользоваться не нужно.
[01:31:37.040 --> 01:31:39.040]  Мы разберем,
[01:31:39.040 --> 01:31:41.040]  как правильно написать умный указатель
[01:31:41.040 --> 01:31:43.040]  с правильной семантикой копирования и так далее.
[01:31:45.040 --> 01:31:47.040]  Просто пример, что все три сущности,
[01:31:47.040 --> 01:31:49.040]  в которые фигирует правило 3,
[01:31:49.040 --> 01:31:51.040]  они на самом деле нужны.
[01:31:51.040 --> 01:31:53.040]  И ни от какой из них избавиться нельзя.
[01:31:53.040 --> 01:31:55.040]  Дальше.
[01:31:59.040 --> 01:32:01.040]  Конструкция равно delete,
[01:32:01.040 --> 01:32:03.040]  которая появилась в C++11.
[01:32:03.040 --> 01:32:05.040]  Равно delete
[01:32:05.040 --> 01:32:07.040]  это такая конструкция,
[01:32:07.040 --> 01:32:09.040]  которая позволяет
[01:32:09.040 --> 01:32:11.040]  помечать функции,
[01:32:11.040 --> 01:32:13.040]  которые вызывать нельзя ни в коем случае.
[01:32:13.040 --> 01:32:15.040]  Как это работает?
[01:32:15.040 --> 01:32:17.040]  Допустим, у вас есть функция f от int.
[01:32:17.040 --> 01:32:19.040]  Если вы написали просто функцию f от int,
[01:32:19.040 --> 01:32:21.040]  то ее можно вызывать и для int,
[01:32:21.040 --> 01:32:23.040]  и для doub, и так далее.
[01:32:23.040 --> 01:32:25.040]  Просто у вас аргумент будет преобразовываться в тип int.
[01:32:25.040 --> 01:32:27.040]  А что, если вы
[01:32:27.040 --> 01:32:29.040]  жутко не хотите, чтобы у вас
[01:32:29.040 --> 01:32:31.040]  функцию f может было вызываться от doub?
[01:32:31.040 --> 01:32:33.040]  То есть вы не хотите, чтобы вашу функцию f
[01:32:33.040 --> 01:32:35.040]  можно было вызывать от 0.0?
[01:32:35.040 --> 01:32:37.040]  То есть вы не хотите, чтобы у вас происходило преобразование
[01:32:37.040 --> 01:32:39.040]  из double в int?
[01:32:39.040 --> 01:32:41.040]  Тогда вы просто пишете f от double равно delete.
[01:32:41.040 --> 01:32:43.040]  И тогда, если кто-то попытается вызвать
[01:32:43.040 --> 01:32:45.040]  функцию f от double,
[01:32:45.040 --> 01:32:47.040]  у него ничего не получится. Он получит ошибку в компиляции,
[01:32:47.040 --> 01:32:49.040]  которая написана здесь.
[01:32:49.040 --> 01:32:51.040]  То есть у вас есть функция f от deleted function f.
[01:32:51.040 --> 01:32:53.040]  Ну и аналогично, например,
[01:32:53.040 --> 01:32:55.040]  для шаблонов.
[01:32:55.040 --> 01:32:57.040]  То есть вы хотите, чтобы у вас была
[01:32:57.040 --> 01:32:59.040]  шаблонная функция, которая работает со всеми типами,
[01:32:59.040 --> 01:33:01.040]  но с каким-то конкретным типом она не работает.
[01:33:01.040 --> 01:33:03.040]  Ну, допустим, шаблонная
[01:33:03.040 --> 01:33:05.040]  функция g, которая
[01:33:05.040 --> 01:33:07.040]  в общем случае принимает один аргумент,
[01:33:07.040 --> 01:33:09.040]  но в случае, если она принимает int,
[01:33:09.040 --> 01:33:11.040]  вы хотите, чтобы не работало,
[01:33:11.040 --> 01:33:13.040]  такое не компилировалось.
[01:33:13.040 --> 01:33:15.040]  Тогда вы просто пишете специализацию,
[01:33:15.040 --> 01:33:17.040]  и для нее пишете равно delete.
[01:33:17.040 --> 01:33:19.040]  И вот в этом случае
[01:33:19.040 --> 01:33:21.040]  у вас функцию f от 1.0 нельзя вызывать,
[01:33:21.040 --> 01:33:23.040]  и нельзя вызывать g от единицы,
[01:33:23.040 --> 01:33:25.040]  потому что единица это int.
[01:33:25.040 --> 01:33:27.040]  Ну, для чего это может быть нужно?
[01:33:27.040 --> 01:33:29.040]  Это может быть нужно для того,
[01:33:29.040 --> 01:33:31.040]  чтобы, например, запретить вызывать какие-то
[01:33:31.040 --> 01:33:33.040]  конкретные методы у вашего класса.
[01:33:33.040 --> 01:33:35.040]  Ну, например, смотрите,
[01:33:35.040 --> 01:33:37.040]  мы знаем, что если вы не написали своего собственного
[01:33:37.040 --> 01:33:39.040]  конструктора копирования,
[01:33:39.040 --> 01:33:41.040]  то компилятор с конструктором копирования
[01:33:41.040 --> 01:33:43.040]  создается за вас.
[01:33:43.040 --> 01:33:45.040]  А что, если вы не хотите, чтобы компилятор
[01:33:45.040 --> 01:33:47.040]  вообще создавал за вас конструктор копирования?
[01:33:47.040 --> 01:33:49.040]  Ну представьте, вы не написали конструктор
[01:33:49.040 --> 01:33:51.040]  копирования, и вы не написали его намеренно.
[01:33:51.040 --> 01:33:53.040]  Вы просто не хотите, чтобы ваши объекты могли копироваться.
[01:33:55.040 --> 01:33:57.040]  Как это сделать? Как запретить копирование?
[01:33:57.040 --> 01:33:59.040]  Ну, смотрите, можно поместить
[01:33:59.040 --> 01:34:01.040]  конструктор копирования
[01:34:01.040 --> 01:34:03.040]  во приватную область.
[01:34:03.040 --> 01:34:05.040]  Если мы поместим конструктор копирования в приватную область,
[01:34:05.040 --> 01:34:07.040]  то это значит, что конструктор
[01:34:07.040 --> 01:34:09.040]  копирования вызывать никому нельзя.
[01:34:09.040 --> 01:34:11.040]  Но на самом деле правильней сделать следующим образом.
[01:34:11.040 --> 01:34:13.040]  Правильнее просто пом roller
[01:34:13.040 --> 01:34:18.040]  как удаленный, то есть написать равно delete. И вот в этом случае уже точно никто
[01:34:18.040 --> 01:34:23.400]  конструктор копирования вызвать не сможет. Вот кто понимает, в чем отличие первого
[01:34:23.400 --> 01:34:30.960]  способа от второго способа? Да, вот в этом случае вы не совсем полностью запретили
[01:34:30.960 --> 01:34:38.840]  копирование. Вот если вы тут внутри напишете какой-то метод, то внутри него вы вполне
[01:34:38.840 --> 01:34:42.320]  спокойно можете копировать элементы, потому что приватные конструктор
[01:34:42.320 --> 01:34:45.840]  копирования означает, что конструктор копирования могут вызывать только методы
[01:34:45.840 --> 01:34:54.240]  вашего класса. В приватной области имеет доступ метод вашего класса. Понятна
[01:34:54.240 --> 01:34:58.240]  история. А если вы помечаете конструктор копирования как равно delete, то это
[01:34:58.240 --> 01:35:01.240]  означает, что вообще никто не имеет права вызывать конструктор копирования, хоть
[01:35:01.240 --> 01:35:07.520]  наши, хоть не наши. Поэтому равно delete это более радикальная вещь, чем
[01:35:07.520 --> 01:35:18.280]  просто приватный конструктор или деструктор. Вопросы? В общем, мораль такая, если вы
[01:35:18.280 --> 01:35:21.800]  хотите полностью запретить использовать какой-то конструктор копирования или в
[01:35:21.800 --> 01:35:27.880]  принципе какой-то метод, то вы просто помечаете его как равно delete. Потому что
[01:35:27.880 --> 01:35:30.720]  если вы тут, например, не напишете равно delete, то компилятор попытается создать
[01:35:30.720 --> 01:35:34.200]  конструктор копирования за вас. Вот если вас это не устраивает, то вы пишете равно
[01:35:34.200 --> 01:35:42.760]  delete. На этом эти слайды закончились, и подводим итог. Мы познакомились с
[01:35:42.760 --> 01:35:46.560]  конструкторами, то есть со специальными методами класса, которые вызываются при
[01:35:46.560 --> 01:35:50.600]  создании объекта. Мы познакомились с деструкторами, которые вызываются всякий
[01:35:50.600 --> 01:35:56.040]  раз, когда объект уничтожается. Мы понимаем, что для конструкторов, для более
[01:35:56.040 --> 01:35:59.800]  эффективной реализации конструкторов нужно использовать списки инициализации.
[01:35:59.800 --> 01:36:04.320]  Мы познакомились с конструкторами равно default и равно delete, которые позволяют либо
[01:36:04.320 --> 01:36:09.560]  попросить компилятор создать что-то за вас, либо равно delete, который говорит, что
[01:36:09.560 --> 01:36:16.240]  вот эту штуку в принципе использовать нельзя и реализовывать ее не надо.
[01:36:16.240 --> 01:36:18.240]  Ну и правила трех тоже следует соблюдать.
[01:36:18.240 --> 01:36:31.240]  Все правильно. Вопросы?
[01:36:31.240 --> 01:36:38.240]  Давайте перейдем к следующей теме. Очередная тема называется перегрузка операций.
[01:36:38.240 --> 01:36:48.240]  Это более интересная часть, более интересная, чем нудные конструкторы-деструкторы.
[01:36:48.240 --> 01:36:56.240]  Давайте поговорим о следующем. Мы когда-то на первой лекции работали со структурой
[01:36:56.240 --> 01:37:00.240]  комплексных чисел. Мы написали структуру комплекс, у которой есть два поля.
[01:37:00.240 --> 01:37:05.240]  Действительно имнимая часть. Действительно комплексное число представляется в виде
[01:37:05.240 --> 01:37:09.240]  двух чисел. Действительно имнимая часть. Ну естественно, как и любые другие числа,
[01:37:09.240 --> 01:37:12.240]  наверное, нам хочется, чтобы их можно было складывать.
[01:37:12.240 --> 01:37:15.240]  Чтобы мы могли взять два комплексных числа и их сложить.
[01:37:15.240 --> 01:37:18.240]  Взять два комплексных числа, посчитать разность, посчитать произведение и так далее.
[01:37:18.240 --> 01:37:24.240]  И собственно, чтобы это сделать, мы можем просто взять и написать функцию сам,
[01:37:24.240 --> 01:37:30.240]  которая принимает два комплексных числа и возвращает некоторое новое комплексное число,
[01:37:30.240 --> 01:37:34.240]  которое является суммой двух переданных.
[01:37:34.240 --> 01:37:39.240]  И при этом возникает следующая проблема. С одно стороны, для того чтобы сложить встроенные
[01:37:39.240 --> 01:37:43.240]  в язык числа нам нужно воспользоваться операцией Плюс.
[01:37:43.240 --> 01:37:47.240]  То есть одним плюс три нам складывают числа. А чтобы сложить два комплексных числа нам нужно
[01:37:47.240 --> 01:37:51.240]  вызывать какую-то дополнительную внешнюю функцию сам, которая и складывает.
[01:37:51.240 --> 01:37:55.240]  То есть возникает некоторая асимметричность, то есть с одной стороны для одних чисел
[01:37:55.240 --> 01:37:59.240]  вам нужно вызывать Плюс, для других чисел вам нужно вызывать специальную функцию.
[01:37:59.240 --> 01:38:05.240]  Наверное, хотелось бы, чтобы можно было брать два комплексных числа и просто складывать их между собой с помощью плюса.
[01:38:05.240 --> 01:38:07.240]  Естественное желание, да?
[01:38:07.240 --> 01:38:13.240]  Просто чтобы был более удобный интерфейн, чтобы можно было более чисто и явно читать ваш код.
[01:38:13.240 --> 01:38:16.240]  И вот хорошая новость заключается в том, что все плюс-плюс это сделать можно.
[01:38:16.240 --> 01:38:21.240]  То есть можно настроить операцию плюс так, чтобы она работала с вашими собственными типами.
[01:38:21.240 --> 01:38:23.240]  И вот мы поговорим об этом.
[01:38:23.240 --> 01:38:28.240]  Возможно, этот механизм, который позволяет вам писать свои реализации операции, называется перегрузкой операций.
[01:38:28.240 --> 01:38:32.240]  Перегрузка операции является примером статического полиморфизма.
[01:38:32.240 --> 01:38:39.240]  То есть помните, когда мы говорили про ООП, мы говорили, что одним из признаков объектно-ориентированного языка является такое свойство как полиморфизм.
[01:38:39.240 --> 01:38:42.240]  Полиморфизм – это один интерфейс с много реализацией.
[01:38:42.240 --> 01:38:45.240]  Перегрузка операции является примером полиморфизма. Почему?
[01:38:45.240 --> 01:38:48.240]  Потому что вы используете общий интерфейс, например, операцию плюс.
[01:38:48.240 --> 01:38:53.240]  И эта операция плюс работает как с интами, как с слотами, так и с вашими собственными типами, например, комплексными числами.
[01:38:53.240 --> 01:38:57.240]  То есть одна операция, но при этом работает со всеми типами по-своему.
[01:39:00.240 --> 01:39:03.240]  Ну, как выглядит синтаксис перегрузки операций?
[01:39:03.240 --> 01:39:05.240]  Очень просто.
[01:39:05.240 --> 01:39:12.240]  Чтобы перегрузить операцию плюс так, чтобы она работала для ваших собственных типов, достаточно написать функцию, которая называется оператор плюс.
[01:39:12.240 --> 01:39:17.240]  Оператор плюс – это специальное имя, которое говорит о том, что мы сейчас определяем свою собственную операцию плюс.
[01:39:19.240 --> 01:39:22.240]  Дальше пишем ее как бы мы писали обычную функцию.
[01:39:22.240 --> 01:39:28.240]  Мы знаем, что операция плюс принимает 2 аргумента, мы говорим, что она принимает 2 комплексных числа,
[01:39:28.240 --> 01:39:31.240]  и возвращает новое комплексное число.
[01:39:31.240 --> 01:39:36.240]  Дальше в фигурных скобках мы описываем, что должна делать функция.
[01:39:36.240 --> 01:39:40.240]  То есть мы складываем действительные части, именимые части и возвращаем новое комплексное число.
[01:39:40.240 --> 01:39:51.240]  Все, и теперь, как только вы перегрузили свою операцию, вы можете спокойно пользоваться операцией плюс и складывать ваши собственные типы, в данном случае комплексные числа.
[01:39:51.240 --> 01:40:04.240]  Мы про унарные, про бинарные, про все операции мы подробно говорим, пока просто про синтаксис, что можно делать так.
[01:40:05.240 --> 01:40:13.240]  Важное замечание. Естественно, когда вы перегружаете свою собственную операцию, компилятор не будет следить за тем, что вы следуете правилам математики.
[01:40:13.240 --> 01:40:21.240]  Если вы перегрузили операцию плюс, которая на самом деле неправильно складывает комплексные числа, компилятор не скажет, что идите, сходите на комплексный анализ и потом возвращайтесь к себе плюс-плюс.
[01:40:21.240 --> 01:40:26.240]  Нет, такого не будет. Компилятору в принципе плевать, что вы напишете внутри операции плюс.
[01:40:26.240 --> 01:40:35.240]  То есть вы можете написать даже вот таким образом. Вы можете написать операцию плюс, которая ничего не возвращает и которая внутри себя просто выводит hello world.
[01:40:35.240 --> 01:40:41.240]  И тогда при складывании двух комплексных чисел у вас будет просто на экране всегда появляется hello world.
[01:40:41.240 --> 01:40:50.240]  Так можно делать, но зачем? Естественно, когда вы перегружаете свою собственную операцию, нужно как-то стараться делать так, чтобы она следовала общепринятой семантике.
[01:40:50.240 --> 01:40:56.240]  Чтобы никто ни у кого не возникало никаких сомнений в ваших умственных способностях.
[01:40:56.240 --> 01:41:05.240]  Ну и вот сейчас мы как раз поговорим, во-первых, мы чуть-чуть поговорим про правила перегрузки, про то, как можно перегружать бинарную операцию, внарную операцию.
[01:41:05.240 --> 01:41:09.240]  Ну и попутно поговорим про принятую семантику известных вам уже операций.
[01:41:09.240 --> 01:41:16.240]  То есть как правильно их перегружать так, чтобы никто не подумал, что вы не свистех, а... ладно, не будем.
[01:41:17.240 --> 01:41:20.240]  Сами подставьте что угодно.
[01:41:20.240 --> 01:41:26.240]  Так, значит, синтаксис перегрузки и операции. Да, в общем, основной синтаксис мы проговорили.
[01:41:26.240 --> 01:41:31.240]  На самом деле существует альтернативный синтаксис, который позволяет вам перегружать операцию как метод класса.
[01:41:31.240 --> 01:41:37.240]  То есть альтернативно вы можете перегрузить оператор плюс непосредственно внутри комплексного числа.
[01:41:37.240 --> 01:41:43.240]  То есть, грубо говоря, вот у вас есть структура комплекс,
[01:41:43.240 --> 01:41:54.240]  и внутри нее вы пишете, собственно, комплекс, оператор плюс, ну и так далее.
[01:41:54.240 --> 01:41:59.240]  Вот в чем отличие перегрузки операций как обычной функции и как метод класса?
[01:41:59.240 --> 01:42:03.240]  Значит, если вы перегружаете операцию как метод класса, вам нужно передавать на один аргумент меньше.
[01:42:03.240 --> 01:42:09.240]  Потому что левый аргумент автоматически считается тем аргументом, относительно которого вы вызываетесь.
[01:42:09.240 --> 01:42:11.240]  Понятно сказал, нет?
[01:42:15.240 --> 01:42:18.240]  Никак. Всегда автоматически левый.
[01:42:18.240 --> 01:42:25.240]  Ну то есть, грубо говоря, если вот эта штука, вот эта штука, у вас раскрывался такой вызов,
[01:42:25.240 --> 01:42:31.240]  то есть когда компилятор встречает вот такую штуку, он, грубо говоря, вместо этого подставляет за вас вызов такой странной функции.
[01:42:31.240 --> 01:42:35.240]  Оператор плюс и дальше в круглых скобках комплекс 1 и комплекс 2.
[01:42:35.240 --> 01:42:42.240]  Если вы реализуете это как метод класса, вот так, то вот эта конструкция у вас раскрывается в другую часть,
[01:42:42.240 --> 01:42:48.240]  точнее в другом виде. В этом случае она раскрывается вот в такую запись.
[01:42:48.240 --> 01:42:52.240]  То есть у вас от левого операнда через точку вызывается операция плюс.
[01:42:52.240 --> 01:42:57.240]  И дальше передается то, что вы передали в скобке. Понятно?
[01:42:57.240 --> 01:43:01.240]  Просто разница такая. Вы можете перегружать операции как внешнюю функцию,
[01:43:01.240 --> 01:43:05.240]  и тогда вам нужно передавать строго то количество аргументов, которые нужно.
[01:43:05.240 --> 01:43:09.240]  Либо вы перегружаете как метод класса, тогда вам нужно передавать на один аргумент меньше.
[01:43:09.240 --> 01:43:14.240]  Но при этом левый операт автоматически считается вот тот, который стоит слева, точнее.
[01:43:16.240 --> 01:43:21.240]  Есть, об этом мы поговорим позже. Различия есть.
[01:43:21.240 --> 01:43:28.240]  И на ваш вопрос можно также перегружать унарные операции.
[01:43:28.240 --> 01:43:34.240]  Унарные операции перегружаются также как бинарные, просто на один аргумент меньше.
[01:43:34.240 --> 01:43:38.240]  В частности вы можете перегрузить унарную операцию минус.
[01:43:38.240 --> 01:43:41.240]  Унарная операция минус принимает один аргумент. Вот вы его передаете.
[01:43:41.240 --> 01:43:47.240]  В этом случае операция минус для комплексного частот находится в зависимости от минуса в действительной части и минус м eightю части.
[01:43:47.240 --> 01:43:52.240]  Названия у них одинаковые, но просто отличаются по количеству аргументов.
[01:43:52.240 --> 01:43:57.240]  Ну и унарные операции, так же как и бинарные, можно перегружать в виде методов класса.
[01:43:57.240 --> 01:44:03.240]  В этом случае действует общее правило. Если вы перегружаете как метод класса, нужно делать на один аргумент поменьше.
[01:44:03.240 --> 01:44:08.240]  Если вы реализуете унарную операцию как метод класса, то не нужно ничего передавать в качестве аргумента.
[01:44:08.240 --> 01:44:12.240]  Уже приори понятно, для какого объекта вам нужно вызывать операцию минус.
[01:44:12.240 --> 01:44:17.240]  Если вы вызываете минус c, то это то же самое, что c.оператор минус.
[01:44:17.240 --> 01:44:28.240]  Если вы перегружаете как внешнюю функцию, то минус c это то же самое, что оператор минус от c.
[01:44:28.240 --> 01:44:37.240]  Просто в зависимости от того, что вы реализуете, у вас раскрывается либо в таком виде, либо в таком виде и это всё больше.
[01:44:37.240 --> 01:44:43.240]  Просто в зависимости от того, что вы реализуете, у вас раскрывается либо в таком виде, либо в таком виде.
[01:44:43.240 --> 01:44:51.240]  Теперь давайте поговорим про общие правила перегрузки операций.
[01:44:51.240 --> 01:44:55.240]  Ну и про конкретные особенности для конкретных операций.
[01:44:55.240 --> 01:44:59.240]  Значит, правил всего 6, общих правил 6.
[01:44:59.240 --> 01:45:05.240]  Первое правило – нельзя переоперировать операции для уже встроенных типов, давайте так скажем.
[01:45:05.240 --> 01:45:09.240]  То есть, вы не можете переоперировать операцию плюс для inta и inta так, чтобы она работала как минус.
[01:45:09.240 --> 01:45:13.240]  Или вы не можете переоперировать операцию плюс для inti candles.
[01:45:13.240 --> 01:45:15.240]  Вот для встроенных типов перегружать нельзя.
[01:45:15.240 --> 01:45:19.240]  Вот то, что есть для встроенных типов – это уже будет навсегда, вы этого никак не измените.
[01:45:19.240 --> 01:45:24.240]  То есть в частности, если вы посчитали, что хорошей идеей было бы перегрузить операцию умножения для
[01:45:24.240 --> 01:45:28.240]  cons char звёздочки и inta, то не получится никак.
[01:45:28.240 --> 01:45:32.240]  Просто запрещено для встроенных типов перегружать операции, понятно?
[01:45:32.240 --> 01:45:37.240]  То есть хотя бы один из аргументов у вас должен быть пользовательского типа.
[01:45:37.240 --> 01:45:42.240]  Например, вы можете перегрузить операцию плюс для комплексного числа int. Вот так можно.
[01:45:42.240 --> 01:45:47.240]  Потому что первый аргумент у вас комплексное число. Это первое правило.
[01:45:47.240 --> 01:45:51.240]  Второе правило состоит в том, что нельзя вводить в язык новой операции.
[01:45:51.240 --> 01:45:58.240]  Например, если вы хотите, так же как и в Python, чтобы умножить-умножить работало как в здении степень,
[01:45:58.240 --> 01:46:02.240]  то воспользуйтесь Python. C++ вам этого не позволяет делать.
[01:46:02.240 --> 01:46:05.240]  То есть вы не можете просто взять и вести новую операцию. Все, нельзя.
[01:46:05.240 --> 01:46:08.240]  Если такой операции в языке нет, то и создать вы ее не можете.
[01:46:08.240 --> 01:46:12.240]  То есть перегружать можно только существующей операции.
[01:46:12.240 --> 01:46:15.240]  Третий пункт. Нельзя менять арности приоритет операций.
[01:46:15.240 --> 01:46:20.240]  Что такое? Арность это количество аргументов, которые принимает операция.
[01:46:20.240 --> 01:46:26.240]  То есть если у вас есть... какая есть чисто Бинарная операция?
[01:46:26.240 --> 01:46:29.240]  Деление. Есть операция деления, которая принимает два аргумента.
[01:46:29.240 --> 01:46:34.240]  Вот вы не можете перегрузить деление так, чтобы оно принимало только один аргумент.
[01:46:34.240 --> 01:46:38.240]  Или вы не можете перегрузить операцию плюс так, чтобы оно принимало три аргумента.
[01:46:38.240 --> 01:46:41.240]  Нельзя. Ну и приоритет операции тоже нельзя.
[01:46:41.240 --> 01:46:44.240]  то есть если в языке с плюс-плюс есть приоритет операций,
[01:46:44.240 --> 01:46:47.240]  собственно, приоритет операций тоже не меняется от этого.
[01:46:47.240 --> 01:46:50.240]  То есть если вы приопределяете операцию плюс, как умножить, а умножить как плюс,
[01:46:50.240 --> 01:46:53.240]  то приоритет этого никак не поменяется.
[01:46:53.240 --> 01:46:58.240]  Существует четыре операции, которые перегружать нельзя.
[01:46:58.240 --> 01:47:01.240]  Это операция разрешения области видимости,
[01:47:01.240 --> 01:47:04.240]  операция точка, тернарная операция
[01:47:04.240 --> 01:47:07.240]  и операция точка звездочек, что бы это не значило.
[01:47:07.240 --> 01:47:09.240]  Короче, общий правил такой.
[01:47:09.240 --> 01:47:12.800]  Если в операции присутствует точка, то перегружать ее нельзя.
[01:47:15.760 --> 01:47:18.340]  Еще есть четыре особенная операции,
[01:47:18.380 --> 01:47:21.160]  которые можно перегружать только как методы класса.
[01:47:21.160 --> 01:47:24.600]  Мы говорили, что операцию можно перегружать как внешнюю функцию,
[01:47:24.600 --> 01:47:25.600]  а может как метод класса.
[01:47:25.600 --> 01:47:28.380]  Но вот есть четыре операции, конкретно вот эти.
[01:47:28.380 --> 01:47:31.180]  Это операция пресваивания, операция круглой скобки,
[01:47:31.180 --> 01:47:33.420]  операция квадратной скобки, операция стрелочка.
[01:47:33.420 --> 01:47:36.960]  Вот их можно перегружать только как метод класса.
[01:47:36.960 --> 01:47:39.140]  Как внешнюю функцию, их перегрузить не получится.
[01:47:39.140 --> 01:47:50.140]  Ну и шестое правило. На самом деле его нужно переименовать таким образом, что не перегружайте операции и, и, или.
[01:47:50.140 --> 01:47:56.140]  Но если вы все-таки их переопределяете, то важно помнить, что они теряют свойства короткого вычисления.
[01:47:56.140 --> 01:47:58.140]  Что такое свойство короткого вычисления для этих операций?
[01:47:58.140 --> 01:48:10.140]  Ну да, да, да. То есть для И означает, что если первый аргумент ложь, то второй аргумент уже в принципе не вычисляется.
[01:48:10.140 --> 01:48:14.140]  Ну а для И, или если первый аргумент это правда, то остальные аргументы тоже не вычисляются.
[01:48:14.140 --> 01:48:17.140]  Вот если вы перегрузили операцию для своих собственных типов, то это уже не работает.
[01:48:17.140 --> 01:48:20.140]  Всегда будут вычисляться и первый, и второй аргумент.
[01:48:20.140 --> 01:48:26.140]  Ну и плюс в старых плюсах до 17 стандарта, то есть еще вот эти операции, они обладают тем свойством,
[01:48:26.140 --> 01:48:30.140]  обладают тем свойством, что у них все аргументы вычисляются строго слева-на вправо.
[01:48:30.140 --> 01:48:34.140]  Для плюса это неверно, для плюсов вполне может вычислиться сначала второй операKNOWN, а потом первый операணт.
[01:48:34.140 --> 01:48:38.140]  Вот для операции и, и, или строго слева-направо.
[01:48:38.140 --> 01:48:42.140]  И в старых плюсах это тоже терялось свойство, но теперь как бы все нормально.
[01:48:42.140 --> 01:48:45.140]  То есть если вы используете 17 стандарт, то у вас в аргумент тоже будут вычисляться сначала первый аргумент,
[01:48:45.140 --> 01:48:47.140]  потом второй аргумент, все нормально.
[01:48:47.140 --> 01:48:52.140]  Ну в общем, шестой правил на самом деле звучит так, что старайтесь не перегружать операции и, или.
[01:48:52.140 --> 01:48:57.140]  Потому что все привыкли, что и или это логические операции, которые работают с булями.
[01:48:57.140 --> 01:49:00.140]  В общем, по-другому не надо делать.
[01:49:00.140 --> 01:49:03.140]  Так, по правилам есть вопросы?
[01:49:03.140 --> 01:49:13.140]  Нет, она потеряет короткую логику только для вашей перегрузки.
[01:49:13.140 --> 01:49:16.140]  Для булей, естественно, короткое учтение все еще работает.
[01:49:16.140 --> 01:49:20.140]  Что еще раз?
[01:49:20.140 --> 01:49:26.140]  Как можно перегрузить операцию в виде метода?
[01:49:26.140 --> 01:49:30.140]  Вот был пример.
[01:49:30.140 --> 01:49:38.140]  Унарная операция минус, и мы ее перегрузили в виде метода класса.
[01:49:39.140 --> 01:49:53.140]  Вот эта фраза, комплекс, выточий, дветочий, оператор, означает, что мы перегружаем метод класса комплекс.
[01:49:53.140 --> 01:50:01.140]  Аналогично, можно операцию минус перегрузить прямо, внести прямо внутрь класса комплекс и перегрузить, то есть и написать как обычный метод.
[01:50:01.140 --> 01:50:06.140]  Единственное отличие, что надо на один аргумент меньше писать.
[01:50:06.140 --> 01:50:09.140]  Об этом мы поговорим, все будет нормально.
[01:50:09.140 --> 01:50:11.140]  Почти про все операции сейчас поговорим.
[01:50:11.140 --> 01:50:16.140]  Общие правила есть вопросы?
[01:50:16.140 --> 01:50:18.140]  Окей.
[01:50:18.140 --> 01:50:22.140]  Ну тогда давайте поговорим про конкретные особенности конкретных операций.
[01:50:22.140 --> 01:50:25.140]  Отвечаю на ваш вопрос.
[01:50:25.140 --> 01:50:32.140]  Есть ли разница, перегружать ли бинарную операцию как метод класса или перегружать ее как внешнюю функцию?
[01:50:32.140 --> 01:50:34.140]  Разница есть.
[01:50:34.140 --> 01:50:37.140]  Общее правило в том, что лучше перегружать как внешнюю функцию.
[01:50:37.140 --> 01:50:39.140]  Вот почему.
[01:50:39.140 --> 01:50:45.140]  Если я написал перегрузку в виде внешней функции, то если я попытаюсь вызвать...
[01:50:45.140 --> 01:50:50.140]  Давайте начнем с верхней строчки.
[01:50:50.140 --> 01:50:58.140]  Предположим, что комплексное число у меня поддерживает конструктор от 0, 2 и 1 аргумента.
[01:50:58.140 --> 01:51:01.140]  При этом заметьте, что это конструктор не explicit.
[01:51:01.140 --> 01:51:04.140]  Конструктор может использоваться для неявных преобразований.
[01:51:04.140 --> 01:51:08.140]  Все числа у меня могут не явно преобразовываться в комплексное число, но это нормальное поведение.
[01:51:08.140 --> 01:51:13.140]  Тут я explicit нарочно не пишу, чтобы разрешить подобные неявные преобразования.
[01:51:13.140 --> 01:51:18.140]  И вот теперь допустим я пишу перегрузку операции плюс как внешнюю функцию.
[01:51:18.140 --> 01:51:23.140]  То есть я принимаю комплексное число y и складываю их внутри.
[01:51:23.140 --> 01:51:25.140]  И таким образом у меня работает и вот такой код.
[01:51:25.140 --> 01:51:27.140]  Ну почему он работает?
[01:51:28.140 --> 01:51:32.140]  То есть вот эта штука раскрывается в вызов функции оператор плюс.
[01:51:32.140 --> 01:51:34.140]  Первое аргументом комплексное число.
[01:51:34.140 --> 01:51:39.140]  Второе аргумент это не комплексное число, но при этом число может спокойно преобразовываться в комплексное число,
[01:51:39.140 --> 01:51:42.140]  потому что у меня есть вот это конструктор.
[01:51:42.140 --> 01:51:44.140]  Понятно, да?
[01:51:44.140 --> 01:51:46.140]  И аналогично я могу вызывать 1 плюс комплекса 2,2.
[01:51:46.140 --> 01:51:52.140]  Потому что один из аргументов комплексное число, а второй аргумент может быть преобразован в комплексное число.
[01:51:52.140 --> 01:52:00.640]  Но, если я перегружаю операцию плюс как внешнюю функцию, то внезапно у меня перестает работать вот такая вот запись.
[01:52:03.140 --> 01:52:07.140]  То есть внезапно мне теперь становится важно, в каком порядке у меня следуют аргументы.
[01:52:08.140 --> 01:52:10.140]  Почему работает верхняя запись?
[01:52:10.140 --> 01:52:14.140]  Потому что у комплексного числа есть метод оператор плюс, который я спокойно вызываю.
[01:52:17.140 --> 01:52:20.140]  А вторая строка в принципе не может быть вызвана. Почему?
[01:52:20.140 --> 01:52:25.140]  Потому что компилятор в принципе не будет рассматривать то, что у единицы можно вызвать через точку какую-то операцию.
[01:52:26.140 --> 01:52:28.140]  Потому что единица это не класс, у нее нет никаких методов.
[01:52:29.140 --> 01:52:34.140]  Поэтому компилятор в принципе не может догадаться, то есть он не видит никакой возможности вызвать операцию плюс.
[01:52:35.140 --> 01:52:37.140]  И поэтому это вызывает ошибку компиляции. Понятно?
[01:52:39.140 --> 01:52:47.140]  Поэтому общий правил заключается в том, что если у вас есть бинарная операция, плюс умножить, минус разделить и так далее, то реализуйте ее как внешнюю функцию.
[01:52:47.140 --> 01:52:49.140]  Чтобы у вас работали неявные преобразования.
[01:52:52.140 --> 01:52:53.140]  Пример понятен?
[01:53:00.140 --> 01:53:03.140]  Перегрузка префиксного инкремента и декремента.
[01:53:04.140 --> 01:53:10.140]  Вы знаете, что существует префиксная операция плюс-плюс и префиксная операция минус.
[01:53:12.140 --> 01:53:13.140]  Как она работает?
[01:53:14.140 --> 01:53:15.140]  Вот как она работает?
[01:53:16.140 --> 01:53:18.140]  Понятно, что она увеличивает что-то на единицу или уменьшает что-то на единицу.
[01:53:19.140 --> 01:53:20.140]  А что она возвращает?
[01:53:23.140 --> 01:53:25.140]  Да, возвращает результат, то есть возвращает новое значение.
[01:53:26.140 --> 01:53:30.140]  При этом не просто новое значение, но вот возвращает просто-напросто исходный х.
[01:53:31.140 --> 01:53:33.140]  То есть она возвращает сам объект х.
[01:53:34.140 --> 01:53:38.140]  И в итоге на самом деле результат операции плюс-плюс можно что-то присвоить.
[01:53:38.140 --> 01:53:40.140]  И в итоге после этой операции у вас будет х равен 5.
[01:53:41.140 --> 01:53:42.140]  Понятно?
[01:53:43.140 --> 01:53:46.140]  Потому что плюс-плюс возвращает, ну грубо говоря, сам х.
[01:53:47.140 --> 01:53:50.140]  Ну или говоря умным языком, который мы узнаем через несколько лекций.
[01:53:51.140 --> 01:53:52.140]  Он возвращает lvalue.
[01:53:53.140 --> 01:53:55.140]  Он возвращает категорию значения lvalue, то есть возвращает сам х.
[01:53:56.140 --> 01:53:59.140]  И об этом стоит помнить, когда вы перегружаете свою префиксную операцию.
[01:54:00.140 --> 01:54:01.140]  Ну префиксную операцию плюс-плюс или минус-минус.
[01:54:02.140 --> 01:54:03.140]  Значит как ее правильно перегрузить?
[01:54:04.140 --> 01:54:05.140]  Ну вот тут пример показан.
[01:54:05.140 --> 01:54:08.140]  Тут показаны два примера, как ее перегрузить в виде внешней функции и как в виде метода.
[01:54:09.140 --> 01:54:10.140]  Но давайте как в виде внешней функции.
[01:54:11.140 --> 01:54:16.140]  Операция плюс-плюс принимает объект комплексного числа по ссылке.
[01:54:17.140 --> 01:54:18.140]  Понятно почему по ссылке?
[01:54:19.140 --> 01:54:20.140]  Потому что мы этот объект хотим изменить.
[01:54:21.140 --> 01:54:25.140]  То есть мы не хотим изменить копию, мы хотим изменить именно тот объект, который нам передается.
[01:54:26.140 --> 01:54:30.140]  Поэтому мы принимаем его по ссылке, увеличиваем в данном случае только действительную часть на единицу.
[01:54:31.140 --> 01:54:32.140]  И возвращаем сам объект.
[01:54:32.140 --> 01:54:33.140]  При этом возвращаем его тоже по ссылке.
[01:54:34.140 --> 01:54:39.140]  Потому что любой разработчик на C++ привык к тому, что операция плюс-плюс возвращает исходный объект.
[01:54:40.140 --> 01:54:42.140]  То есть именно сам объект, а не копию его.
[01:54:43.140 --> 01:54:46.140]  Ну и ровно то же самое можно писать в виде метода класса.
[01:54:47.140 --> 01:54:48.140]  То есть метода класса комплекс.
[01:54:49.140 --> 01:54:52.140]  Но в этом случае вам нужно достаточно просто сделать плюс-плюс re и все.
[01:54:53.140 --> 01:55:00.140]  И тут кстати мы приходим к первому осознанному применению ключевого слова this.
[01:55:00.140 --> 01:55:02.140]  Помните такое слово this в прошлый раз изучали?
[01:55:03.140 --> 01:55:04.140]  This это указатель на текущий объект.
[01:55:05.140 --> 01:55:10.140]  И вот собственно основное применение this это в случае, если мы хотим вернуть ссылку на самого себя.
[01:55:11.140 --> 01:55:14.140]  Ну смотрите, если бы у нас не было this, допустим у нас нет this такого ключевого слова.
[01:55:15.140 --> 01:55:17.140]  Как бы вернули ссылку на самого себя, на самый этот объект?
[01:55:18.140 --> 01:55:19.140]  Ну непонятно как.
[01:55:20.140 --> 01:55:21.140]  Может как-то можно?
[01:55:23.140 --> 01:55:26.140]  Короче я не знаю, хотя наверное можно как-то.
[01:55:27.140 --> 01:55:28.140]  Ладно, не будем об этом говорить.
[01:55:28.140 --> 01:55:30.140]  This нужно для того, чтобы вернуть ссылку на себя.
[01:55:31.140 --> 01:55:33.140]  Чтобы вернуть ссылку на себя, вы разыменовываете this.
[01:55:34.140 --> 01:55:35.140]  Понятно?
[01:55:36.140 --> 01:55:38.140]  This это адрес, по которому лежит вот мой объект.
[01:55:39.140 --> 01:55:41.140]  И чтобы его получить, точнее получить ссылку на него, вы его разыменовываете.
[01:55:44.140 --> 01:55:50.140]  Потому что когда вы разыменовываете указатель, вы же можете разыменованному указателю присвоить какое-то значение.
[01:55:51.140 --> 01:55:53.140]  И вот тому значение, на которое он указывает, он изменится.
[01:55:54.140 --> 01:55:55.140]  Из этого следует.
[01:55:55.140 --> 01:55:57.140]  То есть это просто доказательство того, что возвращается на самом деле ссылка.
[01:55:58.140 --> 01:56:00.140]  Ну или возвращается lvalue.
[01:56:01.140 --> 01:56:02.140]  Вот.
[01:56:03.140 --> 01:56:09.140]  Ну и аналогично префиксному инкременту и префиксному декременту есть посфиксные инкременты и декременты.
[01:56:10.140 --> 01:56:12.140]  Чему они отличаются от префиксного?
[01:56:13.140 --> 01:56:16.140]  Да, они возвращают копию начального значения.
[01:56:17.140 --> 01:56:22.140]  То есть они возвращают не измененное значение, а они сохраняют то, что мы говорили.
[01:56:22.140 --> 01:56:28.140]  Они возвращают не измененное значение, а они сохраняют исходный объект и потом его возвращают.
[01:56:29.140 --> 01:56:30.140]  Окей?
[01:56:31.140 --> 01:56:37.140]  И тут возникает довольно интересная, снова парадоксальная ситуация, снова приколы C++.
[01:56:38.140 --> 01:56:41.140]  Смотрите, есть префиксный инкремент, он принимает один аргумент.
[01:56:42.140 --> 01:56:45.140]  Есть постфиксный инкремент, и он принимает тоже один аргумент.
[01:56:46.140 --> 01:56:47.140]  Как отличить один от другого?
[01:56:47.140 --> 01:56:52.140]  И вот было принято гениальное решение, нужно второму принимать фиктивный аргумент int.
[01:56:53.140 --> 01:57:00.140]  То есть это абсолютно фиктивный аргумент, который просто служит для того, чтобы сообщить, что вот сейчас я перегружаю постфиксную операцию.
[01:57:01.140 --> 01:57:02.140]  И все.
[01:57:03.140 --> 01:57:04.140]  Его на самом деле нельзя передать.
[01:57:05.140 --> 01:57:08.140]  На самом деле его можно как-то обозвать, то есть можно сказать int x.
[01:57:09.140 --> 01:57:13.140]  Этим x-ом даже можно внутри пользоваться, но при этом передать x непосредственно в эту функцию никак нельзя.
[01:57:14.140 --> 01:57:18.140]  Но это просто вот такой костыль, чтобы отличать префиксную операцию от постфиксной операции.
[01:57:20.140 --> 01:57:22.140]  Ну и как работает постфиксная операция?
[01:57:23.140 --> 01:57:30.140]  Значит, мы сначала сохраняем старое значение, потом увеличиваем то значение, которое нам передали, и возвращаем старое значение.
[01:57:31.140 --> 01:57:37.140]  Ну при этом, естественно, возвращаем не ссылку, потому что ссылку на локальный объект возвращать не стоит, но возвращаем копию старого объекта.
[01:57:38.140 --> 01:57:47.140]  И тут на самом деле такая демонстрация того, что лучше всегда использовать префиксный инкремент, чем постфиксный инкремент.
[01:57:48.140 --> 01:57:52.140]  Потому что префиксному инкременту нужно сделать некоторые дополнительные действия, сохранить старый элемент, а потом его снова вернуть.
[01:57:53.140 --> 01:57:56.140]  Вот префиксному ничего не нужно, он просто увеличивает и возвращает себя же. Вот и все.
[01:57:57.140 --> 01:58:03.140]  Поэтому в общем случае префиксный он, во-первых, он чуть более эффективен, особенно если мы говорим про какие-то тяжелые объекты.
[01:58:03.140 --> 01:58:13.140]  Смотрите, если я попробую вернуть ссылку, то у меня будет проблема. Я возвращаю ссылку на локальный объект.
[01:58:14.140 --> 01:58:18.140]  То есть я возвращаю ссылку на объект, который уже по выходу из функции будет уничтожен.
[01:58:19.140 --> 01:58:23.140]  Это называется провисшая ссылка, висячая ссылка.
[01:58:24.140 --> 01:58:28.140]  Но ровно как и указатель на локальные элементы тоже возвращать не стоит.
[01:58:28.140 --> 01:58:34.140]  Следующая операция, про которую мы поговорим, это операция взять элементы по индексу.
[01:58:35.140 --> 01:58:42.140]  Или квадратные скобки. Напомню, что в рамках общих правил операцию квадратной скобки можно перегружать только как метод класса.
[01:58:43.140 --> 01:58:45.140]  Как внешнюю функцию перегрузить нельзя. Это первая особенность.
[01:58:46.140 --> 01:58:49.140]  А вторая ее особенность заключается в том, что она может принимать только один аргумент.
[01:58:50.140 --> 01:58:52.140]  То есть в квадратных скобках можно написать только один аргумент.
[01:58:52.140 --> 01:58:54.140]  То есть нельзя написать ноль, нельзя написать два, три и так далее.
[01:58:55.140 --> 01:58:57.140]  Ну, для чего это может быть нужно?
[01:58:58.140 --> 01:59:02.140]  Например, если вы пишете какой-то класс, который представляет из себя массив или строку.
[01:59:03.140 --> 01:59:07.140]  Что? Еще раз.
[01:59:08.140 --> 01:59:13.140]  Если вы пишете двумерный массив, то в квадратных скобках нельзя указать два аргумента.
[01:59:14.140 --> 01:59:17.140]  В общем, в квадратных скобках нельзя указать два аргумента.
[01:59:17.140 --> 01:59:22.140]  Ну, в задании у вас есть матрица, и там в качестве решения этой проблемы мы пишем круглые скобки.
[01:59:23.140 --> 01:59:26.140]  В круглых скобках, ну, забегай вперед, в круглых скобках можно сколько угодно аргументов написать.
[01:59:27.140 --> 01:59:29.140]  А в квадратных скобках только один.
[01:59:30.140 --> 01:59:34.140]  Ну, например, если вы пишете свой класс массива, то вы можете перегрузить операцию квадратной скобки,
[01:59:35.140 --> 01:59:39.140]  которая просто возвращает, ну, собственно, по указателю возвращает...
[01:59:40.140 --> 01:59:43.140]  Ну, короче, от указателя берет квадратные скобки и возвращает результат.
[01:59:43.140 --> 01:59:45.140]  Ну, а для матрицы, вот как я сейчас только что ответил, нельзя.
[01:59:46.140 --> 01:59:50.140]  То есть если вы пишете свой класс для матрицы, то круглые скобки не могут принимать два аргумента.
[01:59:51.140 --> 01:59:53.140]  Квадратные скобки всегда принимают только один аргумент.
[01:59:54.140 --> 01:59:57.140]  Окей? Окей.
[01:59:58.140 --> 02:00:02.140]  Ну и сразу же про круглые скобки. Снова круглые скобки, ровно как и квадратные скобки,
[02:00:03.140 --> 02:00:05.140]  могут быть перегружены только как метод класса.
[02:00:06.140 --> 02:00:08.140]  То есть непосредственно внутри класса вы можете реализовать круглые скобки.
[02:00:08.140 --> 02:00:10.140]  Как внешнюю функцию круглые скобки вы перегрузить не можете.
[02:00:11.140 --> 02:00:15.140]  И в отличие от квадратных скобок круглые скобки могут принимать абсолютно произвольное количество аргументов.
[02:00:16.140 --> 02:00:18.140]  Хоть ноль, хоть один, хоть два, хоть десять.
[02:00:20.140 --> 02:00:22.140]  Ну, вот такой пример.
[02:00:23.140 --> 02:00:28.140]  Допустим, мы написали структуру Printer, которая перегружает операцию круглые скобки.
[02:00:29.140 --> 02:00:33.140]  Эта операция круглые скобки принимает int, принимает C-шную строку и принимает
[02:00:33.140 --> 02:00:35.140]  чар. И что теперь можно делать с этой структурой?
[02:00:36.140 --> 02:00:38.140]  Ну, можно создать объекты этой структуры.
[02:00:39.140 --> 02:00:42.140]  И теперь объекты этой структуры можно вызывать как обычные функции с помощью круглые скобок.
[02:00:43.140 --> 02:00:45.140]  Ну, вот такие объекты еще называются функторами.
[02:00:46.140 --> 02:00:48.140]  Функтор.
[02:00:49.140 --> 02:00:51.140]  То есть функтор – это объекты, у которых можно вызвать круглые скобки.
[02:00:52.140 --> 02:00:55.140]  Ну, потому что они ведут себя примерно таким же образом, как и обычные функции.
[02:00:56.140 --> 02:00:58.140]  Окей?
[02:00:58.140 --> 02:01:00.140]  Вот.
[02:01:01.140 --> 02:01:03.140]  Пример понятен?
[02:01:04.140 --> 02:01:10.140]  Ну, или для класса матрицы, например, вы можете определить тоже оператор круглые скобки,
[02:01:11.140 --> 02:01:15.140]  передавать туда sizeTi, sizeTj.
[02:01:16.140 --> 02:01:20.140]  Ну, и дальше уже возвращать элемент по индексу ij.
[02:01:21.140 --> 02:01:25.140]  Ну, и дальше уже возвращать элемент по индексу ij.
[02:01:25.140 --> 02:01:27.140]  Так.
[02:01:28.140 --> 02:01:31.140]  Ну, и наконец, перегрузка операции присваивания.
[02:01:32.140 --> 02:01:35.140]  Значит, это тоже особенная операция, и, вот, если вы помните,
[02:01:36.140 --> 02:01:38.140]  операция присваивания фигурирует в правил cel3.
[02:01:39.140 --> 02:01:41.140]  Вот. В правил cel3 говорится, что если вы перегружаете,
[02:01:42.140 --> 02:01:46.140]  точнее если вы пишите свой деструктур конструкции копирования или операцию присваивания копирующую,
[02:01:47.140 --> 02:01:49.140]  то вам нужно лизать все три.
[02:01:50.140 --> 02:01:52.140]  Вот. Значит, как работает классическая операция присваивания?
[02:01:52.140 --> 02:01:54.300]  Классическая операция присваивания работает следующим образом.
[02:01:54.300 --> 02:01:59.060]  Понятное дело, что она должна взять элемент, который стоит справа, и записать его в объект,
[02:01:59.060 --> 02:02:05.380]  который стоит слева. А что возвращает операция присваивания?
[02:02:05.380 --> 02:02:11.140]  Она возвращает объект, который стоит слева, но, если быть точнее, она возвращает ссылку на объект, который стоит слева.
[02:02:11.140 --> 02:02:18.900]  То есть, если я напишу так, вiele OctaveX, что будет записано?
[02:02:18.900 --> 02:02:25.440]  1, да, потому что операция пресваивания работает следующим образом. Сначала вычисляется x равно 0, то есть x' присваивается 0
[02:02:26.440 --> 02:02:33.140]  и операция пресваивания возвращает сам x, то есть тут вместо пресваивания возвращается x. И теперь этому x' присваивается единица.
[02:02:33.900 --> 02:02:35.900]  То есть в итоге x' будет присвоена единица.
[02:02:41.200 --> 02:02:48.260]  Я думаю, это мы разобрали то, как действует обычная операция пресваивания.
[02:02:48.260 --> 02:02:50.260]  Для обычных типов.
[02:02:50.580 --> 02:02:55.660]  Естественно, моя мысль заключается в том, что свои операции нужно реализовывать с учетом вот этого.
[02:02:56.340 --> 02:03:01.940]  То есть операции нужно реализовывать так, чтобы они были похожи на поведение классических встроенных операций.
[02:03:01.940 --> 02:03:08.600]  Но вот в частности, если мы знаем, что операция пресваивания, которая работает со встроенным типом, возвращает ссылку на элемент,
[02:03:08.600 --> 02:03:14.420]  точнее вот на тот элемент, к которому учет пресваиваем, то и наша операция тоже должна возвращать ссылку на этот элемент.
[02:03:15.260 --> 02:03:23.580]  Ну и операция пресваивания, копирующая, должна принимать ссылку на элемент того же типа.
[02:03:24.700 --> 02:03:31.220]  Понятно почему ссылку, и понятно, почему константную ссылку. Ровно те же самые правила, что и для конструктора копирования.
[02:03:33.820 --> 02:03:37.820]  Ну и как выглядит операция пресваивания для комплексного числа.
[02:03:37.820 --> 02:03:41.540]  Мы просто копируем действительную часть, копируем немую часть и возвращаем this. Вот и все.
[02:03:44.420 --> 02:03:56.780]  В смысле, чтобы она возвращала ссылку?
[02:03:56.780 --> 02:04:04.300]  Опять же, давайте вернемся вот прям вот сюда.
[02:04:04.300 --> 02:04:12.420]  Любая ваша операция может делать что угодно. Никто вам не указал, в общем, может делать что хотите.
[02:04:13.100 --> 02:04:18.980]  Но желательно, чтобы вы делали так, как делают нормальные люди.
[02:04:22.980 --> 02:04:27.200]  То есть, в принципе, вы можете написать операцию пресваивания, которая не пресваивает, а делает что-то еще.
[02:04:27.200 --> 02:04:32.340]  Вы можете написать операцию пресваивания, которая возвращает не ссылку, а возвращает что-то другое.
[02:04:32.340 --> 02:04:36.100]  Но лучше, если она будет вести себя так, как все от нее ожидают.
[02:04:36.100 --> 02:04:38.820]  Стандартное ожидаемое поведение от операции пресваивания.
[02:04:42.420 --> 02:04:48.420]  Ну и правила для операции присваивания. Операция присваивания особенно еще тем, что если вы не
[02:04:48.420 --> 02:04:52.420]  реализ·ите свою соб·ствуную операцию при сваивании, то апп сериал об步 работит
[02:04:53.420 --> 02:04:58.420]  Ровно как и для конструктора-по-умолчанию деструктора-и конструктора копирования. Если вы не написали
[02:04:58.420 --> 02:05:02.420]  свою собственную операцию при сваивании, то она будет написана за вас. То есть компилятор за вас
[02:05:02.420 --> 02:05:06.420]  напишет операцию при сваивании. Эта операция при сваивении-по-умолчанию, она просто JUST возьмет
[02:05:06.420 --> 02:05:13.660]  возьмет и присвоит все поля. Условно, если у вас есть класс A, у которого есть
[02:05:13.660 --> 02:05:20.300]  поля x, y и z, если задаете A, задаете B, потом a-шки присвоите B, то у вас
[02:05:20.300 --> 02:05:28.980]  произойдет следующее. a.x равно b.x, a.y равно b.y и a.z равно b.z.
[02:05:28.980 --> 02:05:32.740]  Вот ровно это сделает за вас компилятор.
[02:05:36.420 --> 02:05:46.660]  Зачем нужна операция скобочки, если можно писать просто метод?
[02:05:46.660 --> 02:05:50.980]  Давайте подумаем. Смотрите, как вам удобнее, если у вас есть какой-то массив,
[02:05:50.980 --> 02:06:03.940]  что вам удобнее? Вызвать array 0.get, а круглые скобки нужны как в случае матриц,
[02:06:03.940 --> 02:06:09.500]  чтобы можно было индексироваться. Это первый случай. Второй случай, более подробно про то,
[02:06:09.500 --> 02:06:12.340]  зачем перегружать операцию круглые скобки, мы, наверное, поговорим ближе к концу курса,
[02:06:12.340 --> 02:06:16.900]  когда будем говорить про всякие лямбдовыражения, стандартные алгоритмы и так далее.
[02:06:16.900 --> 02:06:23.140]  В общем, иногда хочется написать объект, который ведет себя как функция, чтобы его можно было
[02:06:23.140 --> 02:06:27.620]  передавать в другие функции, например. Если нам нужен объект, который ведет себя как функции,
[02:06:27.620 --> 02:06:30.980]  то это можно создать с помощью структуры и перегрузки операции круглые скобки.
[02:06:30.980 --> 02:06:40.900]  С операцией присваивания понятно. Операция присваивания фигурой правилы 3,
[02:06:40.900 --> 02:06:44.780]  то есть ее тоже нужно реализовывать, если у вас есть какая-то нитриальная работа с ресурсами.
[02:06:44.780 --> 02:06:50.420]  Если вы не пишете свою операцию присваивания, то она просто берет и присваивает все поля по
[02:06:50.420 --> 02:06:56.940]  отдельности. Операция присваивания, я это не говорил, но это в общих правилах есть.
[02:06:57.080 --> 02:06:59.980]  А операция присваивания – это операция, которую можно перегружать только как метод
[02:06:59.980 --> 02:07:02.240]  класса. Как внешнюю функцию операцию присваивания нельзя перегружать.
[02:07:03.100 --> 02:07:14.220]  Важный момент. Присваивание нельзя перегружать как внешнюю функцию, а вот всякие плюс равно,
[02:07:14.220 --> 02:07:22.380]  минус равно, умножить равно и так далее, вот их можно. То есть плюс равно минус равно
[02:07:22.380 --> 02:07:28.380]  пресваиванием не считаются. Их можно реализовывать как обычные внешние функции и так далее.
[02:07:28.380 --> 02:07:34.380]  Исключение касается только самого пресваивания.
[02:07:34.380 --> 02:07:40.380]  Это, наверное, даже где-то должно быть прописано.
[02:07:40.380 --> 02:07:46.380]  Это мы уже обсуждали, что если у нас есть в классе какое-то нетривиальное управление ресурсами,
[02:07:46.380 --> 02:07:51.380]  то стоит операцию пресваивания писать самостоятельно, а не доверяться компилятору.
[02:07:51.380 --> 02:07:55.380]  Но снова понятно почему. Потому что нас не устраивает, что если у вас есть какой-то stack x,
[02:07:55.380 --> 02:07:59.380]  который указывает на какую-то область памяти, есть stack y, который указывает на какую-то область памяти.
[02:07:59.380 --> 02:08:05.380]  Да, вот тут, кстати, будет проблема. Смотрите, если я stack x, присвою y, то что у меня произойдет?
[02:08:05.380 --> 02:08:10.380]  У меня x теперь будет указывать туда же, куда указывает y.
[02:08:10.380 --> 02:08:13.380]  И тут возникают сразу две проблемы.
[02:08:13.380 --> 02:08:20.380]  Во-первых, x и y указывают на одну и ту же область памяти, а во-вторых, вот эту память мы уже безвозвратно потеряли.
[02:08:20.380 --> 02:08:25.380]  То есть мы потеряли на нее указатель, и все, у нас утечка, без возможности восстановления.
[02:08:25.380 --> 02:08:31.380]  Поэтому если вы работаете с ресурсами, то операцию пресваивания тоже нужно перегружать обязательно.
[02:08:31.380 --> 02:08:36.380]  Пример, как это можно сделать, показан здесь.
[02:08:36.380 --> 02:08:42.380]  Что нужно сделать для stack? Во-первых, нужно удалить старую память, выделить новую память,
[02:08:42.380 --> 02:08:49.380]  скопировать размер другого stack, ну и даже в цикле скопировать все содержимое другого stack в наш stack.
[02:08:49.380 --> 02:08:52.380]  Ну и не забыть вернуть this, точнее разыминованный this.
[02:08:52.380 --> 02:08:59.380]  Потому что операция пресваивания обычно возвращает ссылку на себя.
[02:08:59.380 --> 02:09:04.380]  И вот это тоже не совсем хорошая реализация операции пресваивания, вот по какой причине.
[02:09:04.380 --> 02:09:09.380]  Вот что если я вдруг захочу сделать довольно странную, но все равно, вот такую вещь.
[02:09:09.380 --> 02:09:14.380]  А равно а.
[02:09:14.380 --> 02:09:19.380]  А почему?
[02:09:19.380 --> 02:09:23.380]  Да, смотрите, если я попытаюсь сделать, это называется проблема самопресваивания,
[02:09:23.380 --> 02:09:29.380]  то есть если я попытаюсь объект присвоить самому себе, то у меня в общем случае возникнет ошибка,
[02:09:29.380 --> 02:09:34.380]  ну проблема точнее, почему? Потому что в этом случае у меня a.
[02:09:34.380 --> 02:09:40.380]  То же самое, что и this, точнее разыминованный this, согласны?
[02:09:40.380 --> 02:09:46.380]  И когда я у себя удаляю буфер, я на самом деле буфер удаляю и у a.
[02:09:46.380 --> 02:09:50.380]  Потому что a. это то же самое, что и я, понятно?
[02:09:50.380 --> 02:09:56.380]  И по сути вот в этой строке что происходит? Я из уже удаленной памяти копирую снова в себя же.
[02:09:56.380 --> 02:10:00.380]  То есть я уже из какого-то мусора копирую вот свой буфер.
[02:10:00.380 --> 02:10:03.380]  Ну то есть проблема явная.
[02:10:03.380 --> 02:10:09.380]  Ну если, соответственно, чтобы избежать этой проблемы, обычно пишут так называемую защиту от самопресваивания,
[02:10:09.380 --> 02:10:14.380]  просто в начале операции пресваивания вы пишете проверку.
[02:10:14.380 --> 02:10:17.380]  Ну вот, вот она здесь написана.
[02:10:17.380 --> 02:10:20.380]  Это вы пишете в самом начале.
[02:10:20.380 --> 02:10:25.380]  То есть если я, то есть this, не совпадает с other, то есть точнее address other, то место, где расположен other,
[02:10:25.380 --> 02:10:30.380]  не совпадает со мной, то есть то, где располагаюсь я и то, где располагается other, это разные места,
[02:10:30.380 --> 02:10:33.380]  тогда я могу выполнять пресваивание.
[02:10:33.380 --> 02:10:36.380]  Если нет, то в общем не выполняю ничего.
[02:10:36.380 --> 02:10:39.380]  Ну то есть это выглядит так.
[02:10:39.380 --> 02:10:44.380]  Если this не равно address other, то я что-то делаю.
[02:10:44.380 --> 02:10:47.380]  Вот все вот это проделываю.
[02:10:47.380 --> 02:10:52.380]  А иначе просто ничего не делаю и возвращаю сразу.
[02:10:52.380 --> 02:10:54.380]  Понятно?
[02:10:54.380 --> 02:10:59.380]  Это защита от самопресваивания. То есть это еще один пункт, про который нужно помнить, когда вы реализуете свою операцию пресваивания.
[02:10:59.380 --> 02:11:04.380]  То есть нужно помнить про защиту от самопресваивания.
[02:11:11.380 --> 02:11:18.380]  А это по кодстайлу. Все глобальные константы, все статические константы по кодстайлу у нас должны начинаться с префикса k
[02:11:18.380 --> 02:11:21.380]  и писаться в camel-кейсе.
[02:11:22.380 --> 02:11:27.380]  Но чтобы подчеркнуть, что это глобальные константы.
[02:11:32.380 --> 02:11:36.380]  Честно говоря, я сам не знаю, но такой синтаксируется.
[02:11:43.380 --> 02:11:47.380]  А, ну вот как раз слайд про составные операции пресваивания.
[02:11:47.380 --> 02:11:50.380]  На них подробно останутся не будем.
[02:11:50.380 --> 02:11:53.380]  Но я не знаю, как работают остальные операции пресваивания.
[02:11:53.380 --> 02:11:56.380]  То есть плюс равно, умножить равно, делить равно.
[02:11:56.380 --> 02:12:00.380]  Они изменяют объект, который находится слева за счет объекта, который расположен справа.
[02:12:00.380 --> 02:12:03.380]  При этом они ровно как и обычные операции пресваивания.
[02:12:03.380 --> 02:12:07.380]  Ну, во-первых, изменяют сам объект, а во-вторых, возвращают ссылку на измененный объект.
[02:12:07.380 --> 02:12:09.380]  Вот и все.
[02:12:09.380 --> 02:12:14.380]  Но при этом, в отличие от обычной операции пресваивания, они могут быть реализованы как внешняя функция.
[02:12:14.380 --> 02:12:17.380]  Вот, например, как здесь показано.
[02:12:17.380 --> 02:12:21.380]  То есть в качестве левой операнта вы принимаете ссылку на комплексное число,
[02:12:21.380 --> 02:12:25.380]  а в качестве правой операнта принимаете просто константную ссылку на число.
[02:12:25.380 --> 02:12:28.380]  Потому что то, что стоит справа, не изменяется.
[02:12:28.380 --> 02:12:35.380]  Ну вот, вы выполняете необходимые действия, и дальше возвращаете левое число, то есть левый оперант.
[02:12:35.380 --> 02:12:40.380]  То же самое можно сделать с помощью реализации в виде метода класса.
[02:12:40.380 --> 02:12:44.380]  То есть в этом случае вы принимаете просто правый оперант по константной ссылке
[02:12:44.380 --> 02:12:46.380]  и возвращаете разыминованный this.
[02:12:46.380 --> 02:12:48.380]  Все стандартно.
[02:12:52.380 --> 02:12:58.380]  Ну и теперь в качестве последовательного пункта подробно поговорим про перегрузку побитого сдвига.
[02:12:58.380 --> 02:13:00.380]  Смотрите.
[02:13:00.380 --> 02:13:05.380]  Казалось бы, кому может прийти в голову перегружать побитый сдвиг?
[02:13:05.380 --> 02:13:10.380]  Это как-то странно. У вас есть комплексное число, что значит сдвинуть его побитого влево?
[02:13:10.380 --> 02:13:13.380]  Как-то странно все поля сдвигать побитого влево.
[02:13:13.380 --> 02:13:17.380]  Или у вас есть класс массива, как-то странно его тоже побитого как-то сдвигать и так далее.
[02:13:17.380 --> 02:13:21.380]  Тем не менее, побитого сдвиг перегружают регулярно.
[02:13:21.380 --> 02:13:23.380]  Почти всегда.
[02:13:23.380 --> 02:13:30.380]  Но просто его, как правило, перегружают для того, чтобы перегрузить вывод и ввод из потока и в поток.
[02:13:30.380 --> 02:13:35.380]  Вы вряд ли в прошлом семестре обсуждали, почему C in и C out работают именно таким образом.
[02:13:35.380 --> 02:13:39.380]  Почему побитого сдвиг для C in и C out работает как вывод или ввод?
[02:13:39.380 --> 02:13:42.380]  И вот сейчас мы подробно об этом поговорим.
[02:13:42.380 --> 02:13:44.380]  Как это работает? Почему это работает?
[02:13:44.380 --> 02:13:50.380]  И как заставить C in и C out, точнее как подружить C in и C out со своими собственными классами.
[02:13:50.380 --> 02:13:57.380]  Тут история такая. Начнем с далека.
[02:13:57.380 --> 02:14:03.380]  Давайте сначала разберемся с тем, что такое STD C in и что такое STD C out.
[02:14:03.380 --> 02:14:10.380]  Где-то в стандартной библиотеке, определён класс, стандартная библиотека состоит из большого количества классов.
[02:14:10.380 --> 02:14:14.380]  В частности, в стандартной библиотеке обрели классы E stream и O stream.
[02:14:14.380 --> 02:14:19.380]  От слова input stream, то есть поток ввода, и output stream, поток вывода.
[02:14:19.380 --> 02:14:23.380]  STD E stream и STD O stream – это классы.
[02:14:23.380 --> 02:14:29.380]  А STD C in и STD C out – это объекты этих самых классов.
[02:14:29.380 --> 02:14:32.380]  То есть где-то в стандартной библиотеке обрел класс.
[02:14:32.380 --> 02:14:38.380]  Не STD, а просто обрел класс E stream или O stream.
[02:14:38.380 --> 02:14:46.380]  И тоже в стандартной библиотеке обрела переменная O stream, C out.
[02:14:46.380 --> 02:14:54.380]  C in и C out – это просто некоторые переменные, которые имеют тип E stream или O stream.
[02:14:54.380 --> 02:15:01.380]  Так как C in и C out – это пользовательский тип, класс, не встроенный тип,
[02:15:01.380 --> 02:15:05.380]  для них можно перегрузить некоторые операции.
[02:15:05.380 --> 02:15:10.380]  В частности, для них перегружены операции по bit.ly влево и по bit.ly вправо.
[02:15:10.380 --> 02:15:15.380]  Так что они что-то внутри себя пишут, то есть передное значение они внутри себя пишут,
[02:15:15.380 --> 02:15:17.380]  или передное значение куда-то что-то выводят.
[02:15:17.380 --> 02:15:21.380]  Важно понимать, что C in и C out, ровно как E stream и O stream –
[02:15:21.380 --> 02:15:24.380]  это не единственные потоки, которые существуют в стандартной библиотеке.
[02:15:24.380 --> 02:15:26.380]  В стандартной библиотеке есть куча других потоков.
[02:15:26.380 --> 02:15:30.380]  Например, есть поток E stream, есть поток O stream, есть O stream stream и E stream stream.
[02:15:30.380 --> 02:15:33.380]  Первые два осуществляют вот или вывод файл.
[02:15:33.380 --> 02:15:37.380]  Можно писать конкретный файл, у вас на компьютере создается файл с нужным вам содержимым.
[02:15:37.380 --> 02:15:42.380]  Или если у вас в файле записано какие-то данные, их можно считать с помощью потока ввода из файла.
[02:15:42.380 --> 02:15:47.380]  Также можно данные записать в строку или считать данные из строки.
[02:15:47.380 --> 02:15:50.380]  Здесь пример приведен для строк.
[02:15:50.380 --> 02:15:56.380]  Например, я могу создать поток ввода из строки, то есть я создал строку 123 и создал поток S in.
[02:15:56.380 --> 02:16:02.380]  Из этой строки я могу считать данные x, y и z, то есть могу считать 3 целых числа.
[02:16:02.380 --> 02:16:08.380]  Ровно с помощью такого же синтакса, как я это делаю с помощью stdc и stdcout.
[02:16:08.380 --> 02:16:15.380]  Или я могу попытаться вывести в строку, то есть я могу записать данные не в консоль или файл, а в какую-то строку.
[02:16:15.380 --> 02:16:19.380]  Но делаю в следующем образом. Я создаю объект sout, типа O stream stream,
[02:16:19.380 --> 02:16:25.380]  ну и дальше вот в этот самый sout вывожу данные x через запятую y, через запятую z.
[02:16:25.380 --> 02:16:28.380]  И теперь я эту строку могу получить с помощью метода str.
[02:16:28.380 --> 02:16:32.380]  И вот этот метод мне вернет строку 1,2,3.
[02:16:37.380 --> 02:16:43.380]  По-моему, у sin нет str, это надо уточнить, я точно не в курсе. Может есть, может нет.
[02:16:46.380 --> 02:16:53.380]  В общем-то, общая концепция понятна. Есть потоки, и sin и sout это просто объекты потоков.
[02:16:53.380 --> 02:16:55.380]  Объекты потоков вы можете создавать самостоятельно.
[02:16:55.380 --> 02:17:00.380]  Например, с помощью sin, sout, ну или можете создать свои файловые потоки,
[02:17:00.380 --> 02:17:03.380]  они будут работать так же, как и обычные потоковые консольные вводы и выводы.
[02:17:12.380 --> 02:17:16.380]  Ну точно можно указать нужную вам строку в конструкторе.
[02:17:16.380 --> 02:17:19.380]  Можно ли как-то ее впоследствии дописать, я, честно говоря, не в курсе.
[02:17:19.380 --> 02:17:21.380]  Нужно в документацию посмотреть, можно ли там что-то делать или нет.
[02:17:21.380 --> 02:17:23.380]  В общем, общая идея понятна.
[02:17:23.380 --> 02:17:32.380]  Так вот, почему же все-таки операция по битву издвига работает с объектами класса estream и ostream?
[02:17:32.380 --> 02:17:38.380]  На самом деле, да, я уже рассказывал, в общем, идея стоит в том, что в стандартной библиотеке
[02:17:38.380 --> 02:17:42.380]  перегружена операция по битву издвига влево или по битву издвига вправо.
[02:17:42.380 --> 02:17:48.380]  Так, что вместо того, чтобы осуществлять по битву издвиг, она осуществляет ввод или вывод.
[02:17:48.380 --> 02:17:56.380]  Понятно? То есть вот эта вот операция, то есть вот эта вот запись sdsin вправо-вправо x,
[02:17:56.380 --> 02:18:00.380]  это не что иное, как просто вызов бинарной операции по битву издвига,
[02:18:00.380 --> 02:18:05.380]  но просто перегруженный для типа estream.
[02:18:05.380 --> 02:18:12.380]  Тут никакой магии нет, просто перегрузка операции, про которую мы уже час говорим.
[02:18:12.380 --> 02:18:19.380]  Да, ну и тут есть вопрос. Как вы думаете, любая операция, она что делает?
[02:18:19.380 --> 02:18:23.380]  Она выполняет какие-то действия, в данном случае она записывает что-то в поток,
[02:18:23.380 --> 02:18:29.380]  точнее записывает из консоли что-то и, естественно, что-то возвращает.
[02:18:29.380 --> 02:18:33.380]  Как вы думаете, что возвращает операцию по битву издвига, применённую к потоку?
[02:18:33.380 --> 02:18:39.380]  Есть ещё идея, есть вариант bool. Что ещё?
[02:18:39.380 --> 02:18:43.380]  Скан возвращает количество изчитанного.
[02:18:43.380 --> 02:18:47.380]  Скан возвращает количество изчитанного, да, но а sin что возвращает?
[02:18:47.380 --> 02:18:49.380]  Возвращает поток.
[02:18:49.380 --> 02:18:51.380]  Возвращает поток, а если точнее?
[02:18:51.380 --> 02:18:53.380]  Ссылку на поток.
[02:18:53.380 --> 02:18:57.380]  Ну ссылку на поток, да, действительно.
[02:18:57.380 --> 02:19:02.380]  Давайте задумаемся, смотрите, как мы можем использовать поток-вывод и вывод.
[02:19:02.380 --> 02:19:07.380]  Ну в частности наверняка вы использовали вот такой вот, как называется, трамвайный поток.
[02:19:07.380 --> 02:19:11.380]  Как конвейерный поток. Вот или вывод.
[02:19:11.380 --> 02:19:15.380]  То есть std sin x, а потом то же самое, но y, да?
[02:19:15.380 --> 02:19:19.380]  И как это работает? Ну смотрите, чтобы это работало, чтобы это работало,
[02:19:19.380 --> 02:19:23.380]  ну смотрите, давайте рассмотрим, давайте посмотрим вот на эту операцию.
[02:19:23.380 --> 02:19:30.380]  Вот чтобы она работала, чтобы она работала, ей нужно в качестве левого операнда тоже передать поток.
[02:19:30.380 --> 02:19:34.380]  Поэтому, то есть это раскрывается следующую вещь.
[02:19:34.380 --> 02:19:38.380]  Тут как будто бы вот тут стоят скобки, и даже от того результата, который получается в скобках,
[02:19:38.380 --> 02:19:40.380]  мы вызываем побитву из двиг вправо.
[02:19:40.380 --> 02:19:45.380]  И вот чтобы это работало точно так же, как и вывод, точнее, ввод из потока,
[02:19:45.380 --> 02:19:50.380]  необходимо, что вот то, что стоит в скобках, возвращало нам исходный поток.
[02:19:50.380 --> 02:19:57.380]  И вот ровно так побитву из двиг, перегруженной для операторов ввода или вывода в поток, ровно так он и работает.
[02:19:57.380 --> 02:19:59.380]  То есть прототип их выглядит следующим образом.
[02:19:59.380 --> 02:20:05.380]  То есть оператор побитого из двига вправо принимает поток ввода по ссылке
[02:20:05.380 --> 02:20:10.380]  и принимает ссылку на элемент, в который нужно что-то ввести.
[02:20:10.380 --> 02:20:14.380]  Понятно почему по ссылке, потому что мы изменяем тот элемент.
[02:20:14.380 --> 02:20:22.380]  И возвращаем мы ссылку на оперенный поток, чтобы могли работать вот такие вот конвейерные вводы или выводы.
[02:20:22.380 --> 02:20:25.380]  Ну и то же самое касается оператора вывода из потока,
[02:20:25.380 --> 02:20:32.380]  потому что если вы пишете что-то в поток, то естественно вы тоже можете делать вот так.
[02:20:32.380 --> 02:20:34.380]  Тут все понятно?
[02:20:34.380 --> 02:20:41.380]  То есть важно понимать, что вывод из потока и в поток работает так, что, во-первых, это просто перегруженная операция побитого из двига,
[02:20:41.380 --> 02:20:49.380]  а во-вторых, чтобы работала конвейерная вывод или конвейерный ввод, они просто возвращают ссылку на передный поток.
[02:20:49.380 --> 02:20:55.380]  Ну и теперь, если вы хотите переопределить операцию ввода или вывода в поток или из потока для своих классов,
[02:20:55.380 --> 02:20:58.380]  понятно, что теперь нужно сделать.
[02:20:58.380 --> 02:21:02.380]  Нужно просто перегрузить операцию побитого из двига влево или побитого из двига вправо, вот и все.
[02:21:02.380 --> 02:21:08.380]  То есть если вы это не перегрузите, то естественно комплексное число просто так выводить на экран у вас не получится.
[02:21:08.380 --> 02:21:15.380]  Потому что STDCOUT не знает, как выводить в поток ваши данные.
[02:21:16.380 --> 02:21:20.380]  То есть как перегрузить, например, операцию вывода в поток для вашего комплексного числа?
[02:21:20.380 --> 02:21:31.380]  Ну очень просто. Вы пишете оператор с двига влево, дальше вы принимаете по ссылке поток и принимаете по константной ссылке ваше комплексное число.
[02:21:31.380 --> 02:21:35.380]  Ну а дальше, собственно, вы пишете, в каком виде это все нужно вывести.
[02:21:35.380 --> 02:21:41.380]  Ну вот вы пишете, что в поток, нужно записать сначала действительную часть, потом плюс, ну и потом минимум часть.
[02:21:41.380 --> 02:21:49.380]  А если вы хотите вывести комплексное число 5, 3, то выводите 5, потом плюс, потом 3, потом пишете И.
[02:21:49.380 --> 02:21:52.380]  И вот ровно в таком виде у вас будут вводиться данные.
[02:21:52.380 --> 02:21:57.380]  Когда вы будете, например, делать STDCOUT от С.
[02:21:57.380 --> 02:22:02.380]  Вот, аналогично для операции ввода из потока.
[02:22:02.380 --> 02:22:07.380]  В качестве первого аргумента вы принимаете ссылку на поток вода.
[02:22:07.380 --> 02:22:12.380]  Надо помнить, что вам нужно вернуть ссылку на поток вода, чтобы сработала эта конвертная штука.
[02:22:12.380 --> 02:22:17.380]  И в качестве правого аргумента вы передаете комплексное число по ссылке, ну потому что вы его изменяете, естественно.
[02:22:17.380 --> 02:22:24.380]  Ну и дальше вы пишете, что из потока нужно ввести сначала действительную часть, а потом из потока нужно ввести минимум часть.
[02:22:24.380 --> 02:22:35.380]  То есть теперь, когда вы пишете STDCIN C и в консоль пишете 5, 3, то у вас в C записывается комплексное число 5, плюс 3, и.
[02:22:35.380 --> 02:22:43.380]  Окей? Вот. Вопросы? Да.
[02:22:48.380 --> 02:22:51.380]  Ну нужно отдельно обработать вот этот центральный плюс.
[02:22:51.380 --> 02:22:58.380]  То есть отдельно считать 5, потом отдельно пропустить нужное вам количество символов, и 3.
[02:23:01.380 --> 02:23:02.380]  Что?
[02:23:05.380 --> 02:23:17.380]  Что такое поток? Поток это просто можно считать, что объект класса STDOStream или STDEStream.
[02:23:17.380 --> 02:23:25.380]  Я думаю, на этом понимания достаточно. То есть объект класса EStream или OStream мы называем потоком.
[02:23:25.380 --> 02:23:33.380]  Ну и тут стоит вопрос, смотрите.
[02:23:33.380 --> 02:23:40.380]  Вот часто возникает такая ситуация, что мы для нашего класса делаем приватные поля.
[02:23:40.380 --> 02:23:46.380]  Ну например, для комплексного числа мы можем сделать так, что у нас поля, действительная часть и минимум часть, они приватные.
[02:23:46.380 --> 02:23:50.380]  А доступ к ним мы получаем с помощью специальных методов. Ну можем так сделать? Можем.
[02:23:51.380 --> 02:23:57.380]  При этом понятно, что операции ввода или вывода в поток мы можем реализовывать только как внешнюю функцию.
[02:23:57.380 --> 02:24:03.380]  Ну понятно почему. Потому что мы не можем реализовать их как метод. Мы не можем написать метод внутрь потока.
[02:24:03.380 --> 02:24:11.380]  Потому что он где-то определен в стандартной библиотеке. То есть мы не можем залезть в кишки стандартной библиотеки и написать, что вот для моего класса делай вот так.
[02:24:11.380 --> 02:24:18.380]  То есть операцию ввода или вывода поток мы можем реализовать только внешнюю функцию.
[02:24:18.380 --> 02:24:23.380]  А внешние функции не имеют доступа к приватным данным.
[02:24:23.380 --> 02:24:30.380]  И вот тут может возникнуть проблема. А как считать данные в мой объект, если данные приватные?
[02:24:30.380 --> 02:24:38.380]  Ну например, представьте себе, что у меня вот это вот поле Re и поле Im, это приватные поля. Вот как в них что-то считать?
[02:24:38.380 --> 02:24:45.380]  Ну можно, да, можно через специальные методы, сеттеры. Типа set Re, set Im и так далее. Но это не всегда удобно.
[02:24:45.380 --> 02:24:55.380]  И вот тут очень подходящий или неподходящий момент, но тут можно поговорить про дружбу C++.
[02:24:55.380 --> 02:25:02.380]  Значит, в C++ классы умеют дружить с некоторыми функциями. Но более того, классы умеют дружить между собой.
[02:25:02.380 --> 02:25:14.380]  Что это означает? Если ваш класс объедил какую-то функцию своим другом, то это значит, что этой функцией разрешено лезть в приватные поля.
[02:25:14.380 --> 02:25:22.380]  Вы вряд ли помните, но на предыдущей лекции, когда мы говорили про приватные поля, там была отдельная сноска,
[02:25:22.380 --> 02:25:42.380]  что приватные поля запрещают доступ всем остальным, кроме друзей. То есть приватные поля запрещены, доступ к приватным полям запрещается всем, кроме друзей.
[02:25:42.380 --> 02:25:49.380]  Как объявить функцию другом? Очень просто. Если вы пишете свой класс, вы внутри своего класса пишете friend,
[02:25:49.380 --> 02:25:56.380]  ну и дальше пишете про те функции, которые вы хотите объявить другом. То есть вы говорите friend и дальше пишете, кто ваш друг.
[02:25:56.380 --> 02:26:04.380]  Здесь вы говорите, что функция print является вашим другом. Что это означает? Это означает, что теперь функция print,
[02:26:04.380 --> 02:26:13.380]  которая написана где-то вне, которая написана где-то снаружи класса, теперь эта функция имеет полный доступ приватным полям вашего класса.
[02:26:13.380 --> 02:26:19.380]  Но в частности она может воспользоваться полем size, которое приватное, она может воспользоваться полем buffer, которое приватное и так далее.
[02:26:19.380 --> 02:26:24.380]  То есть полный доступ к внутренностям вашего стека эта функция имеет.
[02:26:24.380 --> 02:26:36.380]  Что еще раз? То же самое. Вы можете объявить другом метод кого-то из другого класса. То есть вы можете написать friend,
[02:26:36.380 --> 02:26:46.380]  а дальше например void a.f. Вот это означает, что вы объявили метод класса a своим другом.
[02:26:47.380 --> 02:26:55.380]  Более того, другом, давайте его есть, скорее всего есть, но давайте на всякий случай скажу, что другом можно объявить и другой класс.
[02:26:55.380 --> 02:27:06.380]  То есть если вы хотите, чтобы класс a, ну какой-то другой класс, friend, класс a. То есть если вы хотите, чтобы какой-то другой класс, например класс a,
[02:27:06.380 --> 02:27:13.380]  имел полный доступ к приватным полям стека, вы можете написать вот такую строку.
[02:27:13.380 --> 02:27:20.380]  То есть другом можно объявить функцию, можно объявить метод другого класса, или можно объявить другой класс целиком.
[02:27:20.380 --> 02:27:25.380]  В этом случае вот то, кого вы объявили другом, будет иметь полный доступ к вашим полям.
[02:27:27.380 --> 02:27:34.380]  Дружба нетранзитивна, к сожалению, как и в жизни. Если я говорю, что вы мой друг, то я вам как бы разрешаю всем пользу.
[02:27:34.380 --> 02:27:37.380]  Но это не значит, что я для вас стал другом, понимаете?
[02:27:37.380 --> 02:27:43.380]  Поэтому, если я сказал, что класс a это мой друг, то это не значит, что стек стал другом для класса a.
[02:27:47.380 --> 02:27:51.380]  Внутри класса стек. Ну где-то внутри класса стек.
[02:27:53.380 --> 02:27:58.380]  Без разницы абсолютно. Да, вот тут приватность публическая не работает.
[02:27:59.380 --> 02:28:05.380]  Внутри мэйна? А, функцию мэйн сделать своим другом.
[02:28:05.380 --> 02:28:10.380]  Тогда из мэйна вы можете вызывать приватные поля, но так не делают обычно.
[02:28:28.380 --> 02:28:32.380]  Нет, объявление friend является объявлением.
[02:28:32.380 --> 02:28:34.380]  Отдельное объявление делать не нужно.
[02:28:34.380 --> 02:28:38.380]  Если вы сделали объявление friend, то считайте, что вы написали про тип функции.
[02:28:41.380 --> 02:28:45.380]  Есть такое из области шизофрении, вы можете объявить друга и сразу его создать.
[02:28:45.380 --> 02:28:48.380]  Сделать друга или воображаемого друга.
[02:28:50.380 --> 02:28:53.380]  Если вы хотите написать функцию, которая является вашим другом,
[02:28:53.380 --> 02:28:56.380]  то вы можете объявить функцию print другом и сразу ее реализовать.
[02:28:56.380 --> 02:28:58.380]  Вот это мой друг и вот он такой.
[02:28:59.380 --> 02:29:01.380]  То есть так тоже можно.
[02:29:10.380 --> 02:29:13.380]  На этом слайде показано, что другом может быть метод другого класса
[02:29:13.380 --> 02:29:15.380]  или другой класс целиком.
[02:29:15.380 --> 02:29:16.380]  Ну вот тут пример.
[02:29:16.380 --> 02:29:19.380]  Соответственно, класс a объявляет класс b целиком другом,
[02:29:19.380 --> 02:29:22.380]  а класс b объявляет только метод f своим другом.
[02:29:22.380 --> 02:29:27.380]  Поэтому методу f класса a можно обращаться к приватной части класса b,
[02:29:27.380 --> 02:29:32.380]  а методу h нельзя, но при этом классу b
[02:29:32.380 --> 02:29:36.380]  класс b имеет полный доступ к приватным частям класса a.
[02:29:36.380 --> 02:29:39.380]  Потому что сам класс a сказал, что b это мой друг.
[02:29:44.380 --> 02:29:46.380]  Ну и теперь, собственно, вот пример реализации,
[02:29:46.380 --> 02:29:49.380]  например, потокового ввода для класса комплексного числа.
[02:29:49.380 --> 02:29:54.380]  Если вдруг так получилось, что поля у моего класса комплекс, они приватные.
[02:29:54.380 --> 02:29:55.380]  То есть что я делаю?
[02:29:55.380 --> 02:30:00.380]  Я говорю, что операция побитого с двига вправо,
[02:30:00.380 --> 02:30:02.380]  ну вот такая, является моим другом.
[02:30:02.380 --> 02:30:04.380]  Вот, и теперь я могу вот внутри этой операции
[02:30:04.380 --> 02:30:06.380]  свободно использовать точка re, точка im.
[02:30:08.380 --> 02:30:10.380]  Ну и все нормально.
[02:30:14.380 --> 02:30:16.380]  Ну это способ обойти приватность, то есть объявить кого-то другом.
[02:30:16.380 --> 02:30:18.380]  То есть если вам нужна какая-то функция,
[02:30:18.380 --> 02:30:21.380]  и вы хотите, чтобы эта функция имела полный доступ к вашим приватным полям
[02:30:21.380 --> 02:30:23.380]  или к приватным методам, вы просто объявляете ее другом.
[02:30:23.380 --> 02:30:24.380]  Вот и все.
[02:30:26.380 --> 02:30:29.380]  Ну это был последний слайд, но при этом я хочу сделать небольшое замечание
[02:30:29.380 --> 02:30:32.380]  про то, что не стоит плодить очень много друзей.
[02:30:32.380 --> 02:30:34.380]  Ну вообще слово friend нужно использовать с осторожностью.
[02:30:34.380 --> 02:30:36.380]  Что в жизни, что вот здесь.
[02:30:36.380 --> 02:30:37.380]  Почему?
[02:30:37.380 --> 02:30:40.380]  Потому что я могу объяснить с архитектурной точки зрения.
[02:30:40.380 --> 02:30:42.380]  Ну вот, представьте себе, что у вас есть класс.
[02:30:43.380 --> 02:30:46.380]  У него есть какое-то, давайте назвать, приватное ядро.
[02:30:46.380 --> 02:30:49.380]  Что мы обычно помещаем в приватную область?
[02:30:49.380 --> 02:30:52.380]  Ну какие-то детали реализации, то есть как реализован мой класс.
[02:30:52.380 --> 02:30:55.380]  Например, для стека в приватную область мы поместили буфер,
[02:30:55.380 --> 02:30:58.380]  то есть массив, в котором хранятся элементы, и размер.
[02:30:58.380 --> 02:31:02.380]  То есть в данном случае мы в качестве реализации используем стэк на массиве.
[02:31:03.380 --> 02:31:07.380]  Ну из этой реализации обычно торчат какие-то публичные,
[02:31:07.380 --> 02:31:10.380]  давайте вот, закрашенная часть это приватная часть,
[02:31:12.380 --> 02:31:14.380]  а не закрашенная это публичная часть.
[02:31:15.380 --> 02:31:17.380]  То есть у вас есть какая-то приватная часть,
[02:31:17.380 --> 02:31:20.380]  которая отвечает за детали реализации, то есть как реализован ваш класс.
[02:31:20.380 --> 02:31:23.380]  И дальше из нее у вас торчат публичные геттеры,
[02:31:23.380 --> 02:31:25.380]  то есть публичные методы, которые позволяют вам
[02:31:25.380 --> 02:31:27.380]  получать доступ к этим самым приватным полям,
[02:31:27.380 --> 02:31:29.380]  или пользоваться вашей реализацией.
[02:31:29.380 --> 02:31:35.380]  В частности это, не знаю, какой-нибудь push, top, size, ну и так далее.
[02:31:36.380 --> 02:31:38.380]  И у вас может возникнуть мысль, ну смотрите,
[02:31:38.380 --> 02:31:41.380]  а зачем не использовать вот эти вот самые push, top и size,
[02:31:41.380 --> 02:31:43.380]  если я пишу свою собственную функцию,
[02:31:43.380 --> 02:31:46.380]  допустим, я пишу функцию f ну и бла, бла.
[02:31:47.380 --> 02:31:49.380]  Ну, допустим вы думаете, что, ну смотрите, я сам реализовал класс стэк,
[02:31:50.380 --> 02:31:53.380]  то есть я пишу свою библиотеку и я написал класс стэк,
[02:31:54.380 --> 02:31:56.380]  ну я пишу какую-то функцию f, которая работает со стэком.
[02:31:57.380 --> 02:32:00.380]  Ну мне как-то хочется, например, напрямую работать с данными,
[02:32:00.380 --> 02:32:02.380]  с приватными данными стэка.
[02:32:02.380 --> 02:32:04.380]  Ну почему, потому что я же реализовал стэка, да,
[02:32:04.380 --> 02:32:06.380]  то есть я реализовал стэк, я понимаю, как он внутри устроен,
[02:32:06.380 --> 02:32:09.380]  поэтому я, наверное, смогу использовать вот эти самые внутренние представления
[02:32:09.380 --> 02:32:13.380]  внутреннее представление в своих функциях, поэтому я объявляю функцию f своим другом.
[02:32:13.380 --> 02:32:18.380]  Почему так делать не стоит? Представьте, что у вас куча друзей, которые лезут в вашу
[02:32:18.380 --> 02:32:24.380]  приватную область, функция f, функция h и так далее. Почему это плохо? Представьте себе, что
[02:32:24.380 --> 02:32:28.380]  ваша программа эволюционирует, ваша библиотека эволюционирует, и в какой момент вы
[02:32:28.380 --> 02:32:31.380]  поняли, что, наверное, лучше stack реализовывать все-таки на связанном списке.
[02:32:31.380 --> 02:32:37.380]  Потому что вы так вот потестировали, собрали эти отзывы от пользователей и поняли, что гораздо
[02:32:37.380 --> 02:32:40.380]  эффективнее у вас будет реализация, если это будете реализовать на связанном списке.
[02:32:40.380 --> 02:32:45.380]  И решили взять и всё изменить. Полностью переписали ядро вашего класса реализацию.
[02:32:45.380 --> 02:32:51.380]  Что из этого следует? Что вам теперь нужно изменить реализацию f? Потому что f у вас
[02:32:51.380 --> 02:33:00.380]  было завязано на том, что у вас stack реализовано массиве. Вам нужно изменить реализацию h.
[02:33:00.380 --> 02:33:05.380]  То же самое для функции g. Чем больше вы лезете в вашу приватную область,
[02:33:05.380 --> 02:33:10.300]  больше вы зависимости распространяете на другие функции. Понятно? Поэтому правильный
[02:33:10.300 --> 02:33:15.940]  способ является следующим, то есть не плодить друзей, а стараться все остальные
[02:33:15.940 --> 02:33:20.700]  функции h и g реализовывать через публичный интерфейс, через методы top, size и так далее.
[02:33:20.700 --> 02:33:24.260]  И вот если вы реализовываете так, то даже если вы измените внутреннюю
[02:33:24.260 --> 02:33:27.980]  реализацию, то вам достаточно будет изменить методы push, top, size и так далее,
[02:33:27.980 --> 02:33:33.340]  то есть какой-то ограниченный набор действий. Вот. И все остальные функции, которые
[02:33:33.340 --> 02:33:36.300]  используют ваш публичный интерфейс, автоматически будут работать корректно,
[02:33:36.300 --> 02:33:41.700]  потому что они уже не зависят от деталей реализации. Понятно? Короче, друзей
[02:33:41.700 --> 02:33:45.900]  должно быть как можно меньше. И вот на этой ноте давайте закончим лекцию.
[02:33:45.900 --> 02:33:49.900]  Окей? Все, спасибо.
