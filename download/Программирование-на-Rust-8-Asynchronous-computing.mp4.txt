[00:00.000 --> 00:16.000]  Так, сегодня последняя лекция семестра, одна очень крутая фича RASTA, даже не фича RASTA, а синхронные модели RASTA.
[00:16.000 --> 00:24.000]  Мы уже знаем о параллельных вычислениях в RASTA, теперь осталось узнать, что же там с синхронными вычислениями.
[00:24.000 --> 00:32.000]  Как вы знаете, с курса Concurrency нам нужна некоторая поддержка со стороны языка, чтобы нам было удобно писать синхронный код.
[00:32.000 --> 00:37.000]  Вот она в RASTA есть, мы будем смотреть вглубь, как она устроена.
[00:47.000 --> 00:51.000]  Во-первых, в этой лекции мы посмотрим сначала на то, что такое генератор.
[00:51.000 --> 00:55.000]  Вы знаете, что такое генераторы, в принципе, спитона, например.
[00:55.000 --> 01:02.000]  Но нам это важно посмотреть конкретно в RASTA, потому что оно будет похоже на то, как мы дальше будем устраивать нашу future.
[01:02.000 --> 01:09.000]  Потом будет такой концепт, называемый pinning, который предназначен для Self-referential структурок.
[01:09.000 --> 01:16.000]  Потом мы посмотрим на упрощенный вариант future, чтобы понять, какая основная идея.
[01:16.000 --> 01:22.000]  И затем на sync и await ключевое слово, которое предназначено для того, чтобы генерировать стейт машины.
[01:22.000 --> 01:31.000]  Ну и наконец, только в этот момент мы сможем понять, а как сверху устроена синхронность в RASTA.
[01:31.000 --> 01:34.000]  Посмотрим прямо на модель.
[01:34.000 --> 01:40.000]  Затем вернемся к реальному trait of future, добавим в нее очень важную вещь, контекст.
[01:40.000 --> 01:45.000]  Ну и напишем какой-то очень-очень простенький синхронный runtime.
[01:45.000 --> 01:51.000]  С огромным количеством недостатков, но тем не менее работающим.
[01:51.000 --> 01:58.000]  Так, генераторы. Вы должны быть с ними уже прекрасно знакомы.
[01:58.000 --> 02:03.000]  Вот такой вот код вы можете увидеть себе в Python.
[02:03.000 --> 02:07.000]  Это такой способ превратить функцию во что-то вроде итератора.
[02:08.000 --> 02:12.000]  Например, такая вот функция последовательно будет выдавать 1, 2, 3.
[02:12.000 --> 02:19.000]  Ну и потом будет в случае Python exception, что это end of iteration.
[02:19.000 --> 02:26.000]  В общем, конец генератора. Точно не помню, какое будет сообщение.
[02:26.000 --> 02:29.000]  В RASTA у нас тоже есть генераторы.
[02:29.000 --> 02:35.000]  Генератор – это такой объект, который представляет из себя какую-то рутину,
[02:35.000 --> 02:39.000]  какое-то вычисление, которое можно резюить.
[02:39.000 --> 02:42.000]  Ну и, соответственно, у нас есть таких генераторов очень много,
[02:42.000 --> 02:46.000]  поэтому это trait, чтобы их обобщить между собой.
[02:46.000 --> 02:51.000]  Trait у нас предназначается, как мы помним, для того чтобы какие-то общие вещи
[02:51.000 --> 02:53.000]  между объектами выделять.
[02:53.000 --> 02:56.000]  Ну и вот у нас trait обобщает генераторы.
[02:56.000 --> 03:00.000]  Конкретно в RASTA все, что мы будем говорить дальше, кроме генераторов,
[03:00.000 --> 03:04.000]  оно стабилизировано, а у генератора не стабилизировано.
[03:04.000 --> 03:07.000]  Мы будем говорить о нестабильной фиче RASTA.
[03:07.000 --> 03:10.000]  Но, тем не менее, она нам будет очень полезна.
[03:12.000 --> 03:15.000]  Давайте посмотрим на некоторый упрощенный вариант генератора,
[03:15.000 --> 03:18.000]  который, наверное, переделают в будущем.
[03:20.000 --> 03:24.000]  Это чуть-чуть упрощенная, без одного аргумента в резюме,
[03:24.000 --> 03:29.000]  версия генератора, которая есть в unstable RASTA.
[03:29.000 --> 03:34.000]  У нас есть какой-то state, ну и сам trait – генератор.
[03:34.000 --> 03:40.000]  Когда вы вызываете генератор, до тех пор, пока у вас yield происходит,
[03:40.000 --> 03:43.000]  вы возвращаете какое-то одно возвращаемое значение.
[03:43.000 --> 03:45.000]  Ну и потом у вас в конце происходит return.
[03:45.000 --> 03:49.000]  Тогда вы знаете, что у вас закончилась итерация по генератору.
[03:49.000 --> 03:52.000]  Ну и, соответственно, yield и return имеют разные типы.
[03:52.000 --> 03:57.000]  Вы можете даже возвращать yield одно, а return другое.
[04:00.000 --> 04:03.000]  Вот. Ну и, видите, тут meet self.
[04:03.000 --> 04:05.000]  Возвращаем что-то одно из этого.
[04:05.000 --> 04:10.000]  Давайте посмотрим на какой-то примерчик, чтобы было чуть-чуть понятнее, что происходит.
[04:11.000 --> 04:15.000]  Вот какое-то чиселко взяли, замували его внутрь.
[04:16.000 --> 04:19.000]  Сначала выводим hello сообщение,
[04:19.000 --> 04:25.000]  потом возвращаем из нашего генератора восьмерку и выводим world.
[04:26.000 --> 04:29.000]  Ну, соответственно, тут будет у нас вывод.
[04:29.000 --> 04:32.000]  Какой, кстати, будет вывод у этого кода?
[04:32.000 --> 04:33.000]  Очевидный.
[04:33.000 --> 04:35.000]  Ну давай очевидный, проговори его.
[04:35.000 --> 04:38.000]  Hello, got value, world, finished.
[04:38.000 --> 04:41.000]  Got value, 8, да, и finished.
[04:41.000 --> 04:44.000]  Абсолютно такая простая штука.
[04:45.000 --> 04:48.000]  Интересно, как же у нас работает yield все-таки?
[04:48.000 --> 04:51.000]  Работать yield будет у нас таким образом.
[04:51.000 --> 04:53.000]  Это же из себя представляет какую-то state-машину.
[04:53.000 --> 05:00.000]  У нас в Rust есть прекрасные enum, которые могут показывать state текущей вычислений.
[05:00.000 --> 05:05.000]  Давайте у нас до того, как мы запустили хотя бы раз наш генератор,
[05:05.000 --> 05:09.000]  у нас будет какой-то enter, например, значению enum.
[05:09.000 --> 05:13.000]  Потом yield, потом, в общем, что вышли?
[05:13.000 --> 05:15.000]  Значение enum.
[05:15.000 --> 05:19.000]  Ну и, соответственно, при создании мы просто enter с нужным числом создаем.
[05:19.000 --> 05:24.000]  Вот такая вот closure, которая на самом деле себя представляет enum.
[05:24.000 --> 05:29.000]  С имплементированным trait-ом генератор.
[05:29.000 --> 05:32.000]  Вот как он, кстати, имплементируется.
[05:32.000 --> 05:34.000]  Примерно вот так.
[05:34.000 --> 05:35.000]  Вот у нас резюм.
[05:35.000 --> 05:38.000]  Мы смотрим на то, какое у нас текущее состояние.
[05:38.000 --> 05:41.000]  Мы сейчас поговорим, что там внутри написано.
[05:41.000 --> 05:45.000]  Причем, если мы уже закончили нашу итерацию, то запаникуем.
[05:48.000 --> 05:52.000]  Ну и вот так вот примерно выглядят стейты.
[05:52.000 --> 05:55.000]  Переходы между стейтами.
[05:55.000 --> 05:58.000]  Посмотрите на них, понятно ли все.
[05:58.000 --> 06:00.000]  Ну вроде несложно.
[06:00.000 --> 06:03.000]  Эту всю штуку генерирует за нас компилятор на самом деле.
[06:03.000 --> 06:06.000]  То есть мы написали, конечно, руками, для примера.
[06:06.000 --> 06:10.000]  Но вот эту штуку будет генерирует за нас компилятор
[06:10.000 --> 06:16.000]  и бить функцию нашего начальства каким-то образом.
[06:16.000 --> 06:18.000]  И запускать.
[06:18.000 --> 06:20.000]  Ну и вот так вот.
[06:20.000 --> 06:23.000]  Теперь мы приходим к самой важной главе, наверное, нашей лекции.
[06:23.000 --> 06:25.000]  Которая займет примерно половину лекции.
[06:25.000 --> 06:27.000]  Это пи-нинг.
[06:27.000 --> 06:29.000]  Это очень сложная штука.
[06:29.000 --> 06:33.000]  Но, тем не менее, надеюсь, мы с ней разберемся.
[06:33.000 --> 06:37.000]  Давайте посмотрим вот на такой примерчик.
[06:37.000 --> 06:39.000]  В нем есть проблема.
[06:39.000 --> 06:41.000]  Видите ли вы эту проблему?
[06:41.000 --> 06:43.000]  В ней есть проблема.
[06:43.000 --> 06:45.000]  В ней есть проблема.
[06:45.000 --> 06:47.000]  В ней есть проблема.
[06:47.000 --> 06:49.000]  В нем есть проблема.
[06:49.000 --> 06:51.000]  Видите ли вы эту проблему?
[07:18.000 --> 07:22.000]  Ну давайте тогда я вам подскажу, наверное.
[07:31.000 --> 07:34.000]  Ну да, действительно, тут есть проблемы со ссылочкой.
[07:34.000 --> 07:36.000]  Но ты неправильно сказал, в чем проблема.
[07:36.000 --> 07:38.000]  С этой ссылочкой.
[07:47.000 --> 07:50.000]  Ну да, тут проблема, конечно, в ссылочке.
[07:50.000 --> 07:52.000]  Если вы попробуете это обессахарить,
[07:52.000 --> 07:54.000]  то вы заметите то, что это структура,
[07:54.000 --> 07:56.000]  которая сама на себя ссылается.
[07:56.000 --> 07:59.000]  У вас внутри будет строчка, и вы будете на нее ссылаться внутри.
[07:59.000 --> 08:01.000]  Вы уже, наверное, пробовали вот такой вот код,
[08:01.000 --> 08:04.000]  как минимум, в ReepGzip'е, например, сделать где-то.
[08:04.000 --> 08:06.000]  Сделать какую-то ссылочку на объект,
[08:06.000 --> 08:09.000]  который у вас внутри находится, текущая структура.
[08:09.000 --> 08:11.000]  Такое небезопасно.
[08:11.000 --> 08:13.000]  Потому что если вы будете моивать объект,
[08:13.000 --> 08:15.000]  то тогда эта ссылка инвалидируется внутри.
[08:15.000 --> 08:17.000]  Поэтому у вас нет такого понятия, например,
[08:17.000 --> 08:19.000]  как lifetime self.
[08:21.000 --> 08:23.000]  Иначе мы могли бы писать такие штуки
[08:23.000 --> 08:25.000]  и получать undefinedBehaviourForFree.
[08:27.000 --> 08:29.000]  Окей. Ну ладно.
[08:29.000 --> 08:31.000]  Есть проблема с ссылочкой.
[08:31.000 --> 08:33.000]  Давайте попробуем зафигачить сюда указатель.
[08:33.000 --> 08:35.000]  Проблемы, конечно, уже никуда не ушли.
[08:35.000 --> 08:37.000]  Проблема, она уехала в runtime.
[08:37.000 --> 08:39.000]  Да, она уехала в runtime из CompileTime.
[08:41.000 --> 08:43.000]  И получается, что компилятор нам бы
[08:43.000 --> 08:45.000]  генерировал какой-то некорректный код.
[08:47.000 --> 08:49.000]  Он будет разминовать этот указатель.
[08:49.000 --> 08:51.000]  Этот указатель не факт, что верен.
[08:51.000 --> 08:53.000]  Нам нужно дать какие-то гарантии.
[08:53.000 --> 08:55.000]  Нам нужно как-то убедиться в том,
[08:55.000 --> 08:57.000]  что пользователь не мувал структурку.
[08:57.000 --> 08:59.000]  Такую структурку нельзя мувать.
[09:01.000 --> 09:03.000]  Вот это конкретный пример.
[09:03.000 --> 09:05.000]  То, как это можно сломать.
[09:07.000 --> 09:09.000]  Делаем такую вот штуку.
[09:09.000 --> 09:11.000]  Например, делаем резюм,
[09:11.000 --> 09:13.000]  потом муваем наш генератор
[09:13.000 --> 09:15.000]  и еще раз делаем резюм.
[09:15.000 --> 09:17.000]  Вот у нас произошел мем-копия,
[09:17.000 --> 09:19.000]  у нас уже другой адрес,
[09:19.000 --> 09:21.000]  а вот у нас findBehaviour в коде.
[09:21.000 --> 09:23.000]  Поэтому на самом деле тот генератор,
[09:23.000 --> 09:25.000]  который я вам показал, он потому и упрощенный,
[09:25.000 --> 09:27.000]  потому что он не поддерживает никаких
[09:27.000 --> 09:29.000]  self-referential структурок.
[09:29.000 --> 09:31.000]  То есть не всякую функцию он может
[09:31.000 --> 09:33.000]  превратить в генератор.
[09:35.000 --> 09:37.000]  Ну что ж, нам нужно придумать
[09:37.000 --> 09:39.000]  какой-то способ как это решить в языке.
[09:41.000 --> 09:43.000]  Во-первых, мы можем попробовать
[09:43.000 --> 09:45.000]  создать бокс с нашей структуркой.
[09:45.000 --> 09:47.000]  Бокс – это аллокация на хиппи.
[09:47.000 --> 09:49.000]  Если аллокация на хиппи,
[09:49.000 --> 09:51.000]  но муваем бокс, казалось бы, все хорошо.
[09:51.000 --> 09:53.000]  Есть ли в этом
[09:53.000 --> 09:55.000]  проблема какая-то?
[09:55.000 --> 09:57.000]  Так, на аллокации конечно проблема,
[09:57.000 --> 09:59.000]  а есть ли еще какая-нибудь проблема
[09:59.000 --> 10:01.000]  в таком решении?
[10:07.000 --> 10:09.000]  Я подскажу STDmem.
[10:09.000 --> 10:11.000]  Подумайте, что STDmem есть.
[10:15.000 --> 10:17.000]  Так, что с ним можно сделать?
[10:27.000 --> 10:29.000]  Ну можно на самом деле
[10:29.000 --> 10:31.000]  любую из функций, которые ты сказал,
[10:31.000 --> 10:33.000]  просто заиспользовать.
[10:33.000 --> 10:35.000]  Ну swap – это самое простое.
[10:35.000 --> 10:37.000]  И просто то,
[10:37.000 --> 10:39.000]  на что указывает бокс, свопнуть.
[10:39.000 --> 10:41.000]  И соответственно у вас получится,
[10:41.000 --> 10:43.000]  что инвалидируется то,
[10:43.000 --> 10:45.000]  что вы забрали из бокса.
[10:47.000 --> 10:49.000]  Ну смотри, давай я
[10:49.000 --> 10:51.000]  такой примерчик покажу.
[10:51.000 --> 10:53.000]  У нас есть такая
[10:53.000 --> 10:55.000]  self-referential структурка.
[10:55.000 --> 10:57.000]  Мы делаем бокс на нее.
[10:57.000 --> 10:59.000]  Потом мы, ну тут
[10:59.000 --> 11:01.000]  еще две строчки, мы просто
[11:01.000 --> 11:03.000]  инициализируем это каким-то указателем.
[11:03.000 --> 11:05.000]  А после этого, смотри, я могу сделать
[11:05.000 --> 11:07.000]  STDmem.replace.
[11:07.000 --> 11:09.000]  Я делаю STDmem.replace,
[11:09.000 --> 11:11.000]  у меня в этот момент то, что
[11:11.000 --> 11:13.000]  hip-value, там уже некорректный указатель.
[11:13.000 --> 11:15.000]  Ну точнее, не где hip-value,
[11:15.000 --> 11:17.000]  а где stack-value,
[11:17.000 --> 11:19.000]  там уже некорректный указатель.
[11:21.000 --> 11:23.000]  Stack-value сейчас находится
[11:23.000 --> 11:25.000]  self-referential с указателем, который показывает
[11:25.000 --> 11:27.000]  куда-то на hip.
[11:33.000 --> 11:35.000]  Ну проблема в том,
[11:35.000 --> 11:37.000]  что у тебя инвалидировался указатель
[11:37.000 --> 11:39.000]  тем, что ты сделал STDmem.replace.
[11:41.000 --> 11:43.000]  Ты ему внул структурку,
[11:43.000 --> 11:45.000]  она опять сломалась.
[11:49.000 --> 11:51.000]  У нас в Replace у него в итоге
[11:51.000 --> 11:53.000]  его дженерик параметра
[11:53.000 --> 11:55.000]  выводится как
[11:55.000 --> 11:57.000]  как self-referential.
[11:57.000 --> 11:59.000]  Ну смотри, hip-value, когда-то, ну да-да,
[11:59.000 --> 12:01.000]  вот эта вот, эта мюта, ссылка
[12:01.000 --> 12:03.000]  на self-referential на hip.
[12:03.000 --> 12:05.000]  Ты уменяешь с каким-то, ну,
[12:05.000 --> 12:07.000]  каким-то просто, которым ты сделал.
[12:07.000 --> 12:09.000]  Теперь тебе на stack-value
[12:09.000 --> 12:11.000]  какой-то self-referential.
[12:11.000 --> 12:13.000]  Внутри какой указатель содержится?
[12:13.000 --> 12:15.000]  Тот же указатель, который на hip.
[12:15.000 --> 12:17.000]  То есть он указывает не сам на себя,
[12:17.000 --> 12:19.000]  а на стеке, а где-то на hip,
[12:19.000 --> 12:21.000]  в другую сторону. То есть не то, что мы ожидаем.
[12:21.000 --> 12:23.000]  Да, а именно
[12:23.000 --> 12:25.000]  это find.
[12:25.000 --> 12:27.000]  А именно в это место мы записали
[12:27.000 --> 12:29.000]  новый self-referential.
[12:29.000 --> 12:31.000]  Ну в старое место написали
[12:31.000 --> 12:33.000]  новый self-referential, и
[12:33.000 --> 12:35.000]  в текущем нашем месте написан
[12:35.000 --> 12:37.000]  на стеке
[12:37.000 --> 12:39.000]  какой-то уже старый инвалидированный
[12:39.000 --> 12:41.000]  self-referential. Он должен был указывать
[12:41.000 --> 12:43.000]  сам на себя, а теперь уже не указывает.
[12:43.000 --> 12:45.000]  То есть проблема в том, что
[12:45.000 --> 12:47.000]  мы разломали структурку,
[12:47.000 --> 12:49.000]  ну, self-referential структурку
[12:49.000 --> 12:51.000]  тем, что мы ее move-нули.
[12:59.000 --> 13:01.000]  Не, сейчас погоди.
[13:01.000 --> 13:03.000]  То есть что получается?
[13:03.000 --> 13:05.000]  Не, формально
[13:05.000 --> 13:07.000]  это указатель все еще валиден,
[13:07.000 --> 13:09.000]  потому что он указывает не на саму себя,
[13:09.000 --> 13:11.000]  а на какую-то другую структурку.
[13:11.000 --> 13:13.000]  Ну, ты же наверное понимаешь,
[13:13.000 --> 13:15.000]  что я могу написать какой-нибудь очень
[13:15.000 --> 13:17.000]  страшный код, который
[13:17.000 --> 13:19.000]  в итоге сделает так, что я пройду
[13:19.000 --> 13:21.000]  к некорректному указателю.
[13:21.000 --> 13:23.000]  Ну это указывает.
[13:23.000 --> 13:25.000]  Мне хочется, чтобы указатель был корректен,
[13:25.000 --> 13:27.000]  но указывал куда-то внутрь себя.
[13:27.000 --> 13:29.000]  А он не указывает.
[13:29.000 --> 13:31.000]  Вот вариант наш разломался.
[13:35.000 --> 13:37.000]  Мы не хотим, чтобы так ломался,
[13:37.000 --> 13:39.000]  мы хотим дать какие-то гарантии
[13:39.000 --> 13:41.000]  по поводу self-referential нашей структурки,
[13:41.000 --> 13:43.000]  чтобы пользователь не мог ее просто так разломать.
[13:45.000 --> 13:47.000]  Мы можем
[13:47.000 --> 13:49.000]  пойти по какому-то плюсовому пути.
[13:49.000 --> 13:51.000]  В плюсах можно, например, CD-move
[13:51.000 --> 13:53.000]  запретить.
[13:53.000 --> 13:55.000]  Вот разве вы думали
[13:55.000 --> 13:57.000]  ввести такой вот move-trade,
[13:57.000 --> 13:59.000]  но, как говорят
[13:59.000 --> 14:01.000]  люди, которые с ним поработали,
[14:01.000 --> 14:03.000]  то, что он просто загрязняет весь код
[14:03.000 --> 14:05.000]  вокруг себя. То есть он появляется
[14:05.000 --> 14:07.000]  даже там, где он абсолютно никому не нужен.
[14:07.000 --> 14:09.000]  Там появляется
[14:09.000 --> 14:11.000]  в ненужных местах, например, вопросик
[14:11.000 --> 14:13.000]  move, где вам не обязательно,
[14:13.000 --> 14:15.000]  чтобы структура была movable,
[14:15.000 --> 14:17.000]  но вам почему-то об этом нужно думать.
[14:17.000 --> 14:19.000]  И получается, что у вас
[14:19.000 --> 14:21.000]  такой,
[14:21.000 --> 14:23.000]  как говорится, super normal trade.
[14:23.000 --> 14:25.000]  Это уже
[14:25.000 --> 14:27.000]  такое понятие Растова.
[14:27.000 --> 14:29.000]  Вопрос сайза, вопрос move.
[14:29.000 --> 14:31.000]  Ну, сайз-то это нормальная штука.
[14:31.000 --> 14:33.000]  Ну, ты бы не захотел писать
[14:33.000 --> 14:35.000]  move везде подряд.
[14:35.000 --> 14:37.000]  А здесь его придется
[14:37.000 --> 14:39.000]  писать, он просто
[14:39.000 --> 14:41.000]  будет появляться везде.
[14:43.000 --> 14:45.000]  У нас в Расте
[14:45.000 --> 14:47.000]  мы не хотим, чтобы у нас был такой код.
[14:49.000 --> 14:51.000]  Раст еще
[14:51.000 --> 14:53.000]  хочет к тому же, чтобы у нас все структуры
[14:53.000 --> 14:55.000]  mov-ались. Мы просто были как
[14:55.000 --> 14:57.000]  meme-копии и все mov-алось. Поэтому у нас
[14:57.000 --> 14:59.000]  такого понятия в Расте как
[14:59.000 --> 15:01.000]  movable-types нет
[15:01.000 --> 15:03.000]  вообще.
[15:03.000 --> 15:05.000]  И Раст считает,
[15:05.000 --> 15:07.000]  что move это всегда безопасно и хорошо.
[15:11.000 --> 15:13.000]  Что же тогда сделать?
[15:13.000 --> 15:15.000]  Как-то несложно догадаться,
[15:15.000 --> 15:17.000]  скорее всего, нам нужно сейчас
[15:17.000 --> 15:19.000]  затребовать какой-то контракт с пользователем.
[15:19.000 --> 15:21.000]  Нужно договориться с ним,
[15:21.000 --> 15:23.000]  что он что-то сейчас
[15:23.000 --> 15:25.000]  не будет делать, конкретно не будет делать move.
[15:27.000 --> 15:29.000]  И вот здесь такое вот решение приходит.
[15:29.000 --> 15:31.000]  У нас появляется структурка
[15:31.000 --> 15:33.000]  pin и trade on pin.
[15:35.000 --> 15:37.000]  Смотрите, конкретно в данном случае
[15:37.000 --> 15:39.000]  я написал, что self у меня теперь
[15:39.000 --> 15:41.000]  это pin на mute self.
[15:41.000 --> 15:43.000]  Заметьте, mute self это какой-то
[15:43.000 --> 15:45.000]  указатель, точнее
[15:45.000 --> 15:47.000]  это ссылка на self.
[15:47.000 --> 15:49.000]  Мы запинили ссылку
[15:49.000 --> 15:51.000]  на себя.
[15:51.000 --> 15:53.000]  То есть когда вы пишете
[15:53.000 --> 15:55.000]  pin mute self это означает,
[15:55.000 --> 15:57.000]  что вы запинили
[15:57.000 --> 15:59.000]  адрес памяти, на котором вы находитесь сейчас.
[16:01.000 --> 16:03.000]  Ну и текущий
[16:03.000 --> 16:05.000]  вид
[16:05.000 --> 16:07.000]  нашего трейда говорит так.
[16:07.000 --> 16:09.000]  Если вы будете читать,
[16:09.000 --> 16:11.000]  для того чтобы зарезюмить
[16:11.000 --> 16:13.000]  ваш генератор,
[16:13.000 --> 16:15.000]  вам нужно пообещать, что вы никогда
[16:15.000 --> 16:17.000]  не будете больше mute self.
[16:17.000 --> 16:19.000]  То есть это
[16:19.000 --> 16:21.000]  примерно так должно считаться.
[16:21.000 --> 16:23.000]  Итак, давайте мы
[16:23.000 --> 16:25.000]  чуть-чуть конкретнее поймем, что такое
[16:25.000 --> 16:27.000]  pin. Пока что не очень понятно.
[16:31.000 --> 16:33.000]  Не со стороны...
[16:33.000 --> 16:35.000]  Вообще да.
[16:35.000 --> 16:37.000]  Частично.
[16:37.000 --> 16:39.000]  С pin есть еще проблема,
[16:39.000 --> 16:41.000]  что он появился, он нужен
[16:41.000 --> 16:43.000]  в основном для асинхронности, появился гораздо
[16:43.000 --> 16:45.000]  позже, чем был Rast 1.0.
[16:45.000 --> 16:47.000]  Поэтому
[16:47.000 --> 16:49.000]  pin, он немножечко выглядит вычурно
[16:49.000 --> 16:51.000]  в языке. В принципе нормально,
[16:51.000 --> 16:53.000]  потому что он редко нужен, очень
[16:53.000 --> 16:55.000]  редко, когда пишете низкоуровневый
[16:55.000 --> 16:57.000]  асинхронный код преимущественно.
[16:57.000 --> 16:59.000]  Или вот, например, если вы захотите написать
[16:59.000 --> 17:01.000]  всякие двусвязанные интрузивные списки
[17:01.000 --> 17:03.000]  в сейв коде, то скорее всего тоже захотите
[17:03.000 --> 17:05.000]  pin сделать.
[17:07.000 --> 17:09.000]  В общем,
[17:09.000 --> 17:11.000]  это такой немножечко костыль для того,
[17:11.000 --> 17:13.000]  чтобы какой-то контракт с пользователем
[17:13.000 --> 17:15.000]  объявить.
[17:15.000 --> 17:17.000]  И в общем-то, как этот контракт выглядит.
[17:17.000 --> 17:19.000]  Когда вы создаете pin,
[17:19.000 --> 17:21.000]  вот вы создаете pin на какой-то
[17:21.000 --> 17:23.000]  ссылке.
[17:23.000 --> 17:25.000]  Это вам говорит, что
[17:25.000 --> 17:27.000]  в момент создания pin
[17:27.000 --> 17:29.000]  вы гарантируете, я никогда
[17:29.000 --> 17:31.000]  не буду больше после этого момента
[17:31.000 --> 17:33.000]  move-ать эту структурку.
[17:33.000 --> 17:35.000]  А pin...
[17:35.000 --> 17:37.000]  параметром pin может быть только ссылка.
[17:37.000 --> 17:39.000]  Ссылка,
[17:39.000 --> 17:41.000]  указатель,
[17:41.000 --> 17:43.000]  box может быть тоже, будем говорить.
[17:43.000 --> 17:45.000]  В общем, любой тип, который
[17:45.000 --> 17:47.000]  имплементирует дерево.
[17:49.000 --> 17:51.000]  То есть, вы хотите запинить адрес
[17:51.000 --> 17:53.000]  вот в этом идее, и поэтому
[17:53.000 --> 17:55.000]  вот так вот это примерно работает.
[17:55.000 --> 17:57.000]  Unpin означает,
[17:57.000 --> 17:59.000]  то есть, если ваш тип
[17:59.000 --> 18:01.000]  имплементирует unpin, это означает,
[18:01.000 --> 18:03.000]  что ему, он не self-referential,
[18:03.000 --> 18:05.000]  не по барабану, что вы будете мне
[18:05.000 --> 18:07.000]  пинить, что он пинит, вы можете мне move-ать
[18:07.000 --> 18:09.000]  только захотите.
[18:09.000 --> 18:11.000]  Поэтому это и авто-трейд,
[18:11.000 --> 18:13.000]  потому что примерно любая структурка
[18:13.000 --> 18:15.000]  у вас в Rust, она имплементирует unpin.
[18:17.000 --> 18:19.000]  Сейчас посмотрим на это.
[18:19.000 --> 18:21.000]  Для того, чтобы сделать это
[18:21.000 --> 18:23.000]  не pin, в будущем
[18:23.000 --> 18:25.000]  в Rust появится
[18:25.000 --> 18:27.000]  негатив трейдс, вы сможете написать
[18:27.000 --> 18:29.000]  импл not unpin for структура,
[18:29.000 --> 18:31.000]  но сейчас пока что нужно в структурку добавить
[18:31.000 --> 18:33.000]  phantom pinned, примерно как
[18:33.000 --> 18:35.000]  phantom...
[18:35.000 --> 18:37.000]  Что сейчас?
[18:37.000 --> 18:39.000]  Да.
[18:39.000 --> 18:41.000]  А вот phantom pinned
[18:41.000 --> 18:43.000]  тоже как-то хитит компилятор,
[18:43.000 --> 18:45.000]  чтобы он не...
[18:45.000 --> 18:47.000]  Нет, это просто тип, который не имплементирует pin,
[18:47.000 --> 18:49.000]  ну такой, zero-size тип, который не имплементирует pin,
[18:49.000 --> 18:51.000]  а... А это сделано,
[18:51.000 --> 18:53.000]  через компилятор это сделано?
[18:53.000 --> 18:55.000]  Таким средствами языка
[18:55.000 --> 18:57.000]  в данный момент не выражается? Выражается.
[18:57.000 --> 18:59.000]  Ну вот здесь есть авто,
[18:59.000 --> 19:01.000]  как я говорил, авто пока что
[19:01.000 --> 19:03.000]  для пользовательских типов не работает,
[19:03.000 --> 19:05.000]  скоро он должен появиться,
[19:05.000 --> 19:07.000]  но пока что его не для пользовательских типов,
[19:07.000 --> 19:09.000]  он есть только для всяких компиляторных.
[19:09.000 --> 19:11.000]  Ну и работает в том случае, если у вас все
[19:11.000 --> 19:13.000]  объекты в структурке,
[19:13.000 --> 19:15.000]  все типы, они тоже что-то имплементируют.
[19:17.000 --> 19:19.000]  То есть unpin будет
[19:19.000 --> 19:21.000]  ваша структурка автоматически в том случае,
[19:21.000 --> 19:23.000]  если у вас все unpin в структуре.
[19:23.000 --> 19:25.000]  Я бы... Как там
[19:25.000 --> 19:27.000]  файлы в стандартной биотеке?
[19:27.000 --> 19:29.000]  Что phantom pinned не unpin?
[19:29.000 --> 19:31.000]  Там написано, скорее всего, что это
[19:31.000 --> 19:33.000]  langitem и все.
[19:33.000 --> 19:35.000]  И там появляются автоматические свойства.
[19:35.000 --> 19:37.000]  Ну вот на этом, да,
[19:37.000 --> 19:39.000]  вот phantom pinned пока что
[19:39.000 --> 19:41.000]  хинтенк компилятора, но потом появится
[19:41.000 --> 19:43.000]  нагдефтрейтс, можно просто написать, что
[19:43.000 --> 19:45.000]  я имплементирую на тампин и все.
[19:45.000 --> 19:47.000]  Вот мы что-то здесь сиделись на этом.
[19:55.000 --> 19:57.000]  Вот.
[19:57.000 --> 19:59.000]  Смотрите, первая важная структурка, о которой
[19:59.000 --> 20:01.000]  мы хотим поговорить, это new.
[20:01.000 --> 20:03.000]  Она создает новый pin
[20:03.000 --> 20:05.000]  вокруг какого-то указателя.
[20:05.000 --> 20:07.000]  Ну, ссылки, указатели.
[20:09.000 --> 20:11.000]  Вот.
[20:11.000 --> 20:13.000]  Ну, вот примерно
[20:13.000 --> 20:15.000]  так вот он выглядит.
[20:15.000 --> 20:17.000]  Обратите, пожалуйста, внимание, здесь
[20:17.000 --> 20:19.000]  target, к которому мы dereferимся,
[20:19.000 --> 20:21.000]  это unpin, обязательно.
[20:21.000 --> 20:23.000]  Это очень важно.
[20:23.000 --> 20:25.000]  Потому что new — это save
[20:25.000 --> 20:27.000]  функция. А как я сказал,
[20:27.000 --> 20:29.000]  если вы запинили какой-то объект,
[20:29.000 --> 20:31.000]  то в таком случае вы
[20:31.000 --> 20:33.000]  говорите, у вас контракт
[20:33.000 --> 20:35.000]  появляется, что вы никогда
[20:35.000 --> 20:37.000]  этот объект не будете move.
[20:37.000 --> 20:39.000]  Но в том случае, если объект имплементирует
[20:39.000 --> 20:41.000]  ampin,
[20:41.000 --> 20:43.000]  то ему становится без разницы с когда и как
[20:43.000 --> 20:45.000]  вы move'ите, хоть пиньте, хоть ampinьте
[20:45.000 --> 20:47.000]  этот объект, ему без разницы.
[20:47.000 --> 20:49.000]  И поэтому функция new безопасна.
[20:49.000 --> 20:51.000]  Потому что можно безопасно
[20:51.000 --> 20:53.000]  запинить объект и потом точно также его
[20:53.000 --> 20:55.000]  заanpin'ить. Сейчас дальше еще
[20:55.000 --> 20:57.000]  посмотрим. Там есть его unsaved
[20:57.000 --> 20:59.000]  вариант.
[20:59.000 --> 21:01.000]  Вот. Например, U32 —
[21:01.000 --> 21:03.000]  ampin. Ну, по понятной причине, это просто
[21:03.000 --> 21:05.000]  какое-то чиселка.
[21:05.000 --> 21:07.000]  Вот. И ему без разницы
[21:07.000 --> 21:09.000]  абсолютно, что вы его как-то move'ите.
[21:09.000 --> 21:11.000]  В том числе, вот, видите, я сделал
[21:11.000 --> 21:13.000]  replace
[21:13.000 --> 21:15.000]  и не value
[21:15.000 --> 21:17.000]  не сломал, ничего не сломал.
[21:19.000 --> 21:21.000]  Value у меня сейчас написано будет троечка,
[21:21.000 --> 21:23.000]  и так как у нас U32 — это не
[21:23.000 --> 21:25.000]  у нас referential структурка, у нас ничего не сломается.
[21:31.000 --> 21:33.000]  Какие-то такие дела.
[21:35.000 --> 21:37.000]  А как вы думаете,
[21:37.000 --> 21:39.000]  box.t имплементирует ampin?
[21:53.000 --> 21:55.000]  Нет, на самом деле
[21:55.000 --> 21:57.000]  оно вполне безопасно.
[21:57.000 --> 21:59.000]  Причем для любого t вообще.
[21:59.000 --> 22:01.000]  Даже если это t не имплементирует ampin.
[22:03.000 --> 22:05.000]  Ну, в общем,
[22:05.000 --> 22:07.000]  я думаю, что
[22:07.000 --> 22:09.000]  у нас есть
[22:09.000 --> 22:11.000]  один вариант.
[22:11.000 --> 22:13.000]  Вот.
[22:13.000 --> 22:15.000]  Вот.
[22:15.000 --> 22:17.000]  Вот.
[22:17.000 --> 22:19.000]  Вот.
[22:19.000 --> 22:21.000]  Вот.
[22:21.000 --> 22:23.000]  То, что там находится,
[22:23.000 --> 22:25.000]  оно находится на хипе.
[22:25.000 --> 22:27.000]  Соответственно,
[22:27.000 --> 22:29.000]  мы можем безопасно box
[22:29.000 --> 22:31.000]  запинить,
[22:31.000 --> 22:33.000]  а потом заampinить.
[22:33.000 --> 22:35.000]  То есть,
[22:35.000 --> 22:37.000]  ну, мы дали обещание,
[22:37.000 --> 22:39.000]  что мы не будем move'ать то,
[22:39.000 --> 22:41.000]  что находится за t,
[22:41.000 --> 22:43.000]  и мы, соответственно, это не move'аем,
[22:43.000 --> 22:45.000]  как и обещали.
[22:45.000 --> 22:47.000]  Потому что оно находится на хипе.
[22:47.000 --> 22:49.000]  Это, кстати, очень важная вещь,
[22:49.000 --> 22:51.000]  когда мы будем говорить
[22:51.000 --> 22:53.000]  еще дальше про
[22:53.000 --> 22:55.000]  асинхронную страсть.
[22:55.000 --> 22:57.000]  Потому что box
[22:57.000 --> 22:59.000]  достаточно часто используется для того,
[22:59.000 --> 23:01.000]  чтобы поместить какой-то объект,
[23:01.000 --> 23:03.000]  который pin на хипу.
[23:03.000 --> 23:05.000]  В таком случае
[23:05.000 --> 23:07.000]  вы делаете, конечно,
[23:07.000 --> 23:09.000]  локацию, но тем не менее у вас
[23:09.000 --> 23:11.000]  объект никуда не двигается.
[23:11.000 --> 23:13.000]  Соответственно, у вас все безопасно.
[23:13.000 --> 23:15.000]  В том числе есть у box
[23:15.000 --> 23:17.000]  другая штука, которая называется
[23:17.000 --> 23:19.000]  есть box.new, например, а есть box.pin.
[23:19.000 --> 23:21.000]  Она делает то же самое,
[23:21.000 --> 23:23.000]  но возвращает не просто box на объект,
[23:23.000 --> 23:25.000]  она возвращает pin на box на объект.
[23:25.000 --> 23:27.000]  В любом случае в том,
[23:27.000 --> 23:29.000]  что box.ampin, поэтому им без разницы.
[23:29.000 --> 23:31.000]  Это безопасная функция,
[23:31.000 --> 23:33.000]  которая делает pin.box, а не просто box.
[23:33.000 --> 23:35.000]  Такая штука.
[23:37.000 --> 23:39.000]  Более того,
[23:39.000 --> 23:41.000]  если у нас то,
[23:41.000 --> 23:43.000]  на что указывает наш p
[23:43.000 --> 23:45.000]  в таком случае
[23:45.000 --> 23:47.000]  мы еще и dref.mute получим
[23:47.000 --> 23:49.000]  бесплатно.
[23:49.000 --> 23:51.000]  Это была очень важная вещь,
[23:51.000 --> 23:53.000]  надо было сказать это еще в прошлом слайде.
[23:53.000 --> 23:55.000]  То, что ты вспоминал,
[23:55.000 --> 23:57.000]  ты правильно вспоминал про
[23:57.000 --> 23:59.000]  реплейс, например.
[23:59.000 --> 24:01.000]  Но ты не сможешь сделать реплейс
[24:01.000 --> 24:03.000]  в тот момент, когда у тебя нет dref.mute.
[24:03.000 --> 24:05.000]  То есть ты не сможешь
[24:05.000 --> 24:07.000]  получить просто мутабельный указатель.
[24:07.000 --> 24:09.000]  Ты сможешь просто почитать что-то.
[24:09.000 --> 24:11.000]  Поэтому когда у тебя
[24:11.000 --> 24:13.000]  объект, на который
[24:13.000 --> 24:15.000]  у тебя pin есть,
[24:15.000 --> 24:17.000]  не имплементирует,
[24:17.000 --> 24:19.000]  то в таком случае
[24:19.000 --> 24:21.000]  тогда и только тогда мы будем dref.mute
[24:21.000 --> 24:23.000]  имплементировать.
[24:25.000 --> 24:27.000]  И вопрос такой,
[24:27.000 --> 24:29.000]  на который я уже частично ответил.
[24:29.000 --> 24:31.000]  Представьте, что мы все-таки имплементируем.
[24:31.000 --> 24:33.000]  Почему же это будет невезопасно?
[24:41.000 --> 24:43.000]  Ну, видимо, Данбик,
[24:43.000 --> 24:45.000]  ты как его реплейсишь?
[24:45.000 --> 24:47.000]  Да, просто
[24:47.000 --> 24:49.000]  делаем какой-то реплейс.
[24:49.000 --> 24:51.000]  Но, смотрите, self-referential.
[24:51.000 --> 24:53.000]  Я зафигачил phantom pin,
[24:53.000 --> 24:55.000]  то оно unpin.
[24:55.000 --> 24:57.000]  Ну, действительно, unpin же структура
[24:57.000 --> 24:59.000]  self-referential.
[24:59.000 --> 25:01.000]  Если мы ее запинили, мы больше не можем
[25:01.000 --> 25:03.000]  ее умывать.
[25:03.000 --> 25:05.000]  Мы пообещали, что я умывать не буду.
[25:05.000 --> 25:07.000]  Но если мы ее запинили,
[25:07.000 --> 25:09.000]  мы больше не можем ее умывать.
[25:09.000 --> 25:11.000]  Мы пообещали, что я умывать не буду.
[25:13.000 --> 25:15.000]  Надо обратить внимание, что я
[25:15.000 --> 25:17.000]  default какой-то сделал,
[25:17.000 --> 25:19.000]  неважно, что делает default,
[25:19.000 --> 25:21.000]  возвращает какую-то структуру.
[25:21.000 --> 25:23.000]  Здесь у меня есть фул какой-то,
[25:23.000 --> 25:25.000]  который принимает на вход
[25:25.000 --> 25:27.000]  pin self-referential.
[25:27.000 --> 25:29.000]  Я просто делаю
[25:29.000 --> 25:31.000]  реплейс.
[25:31.000 --> 25:33.000]  И получается, что я разломал
[25:33.000 --> 25:35.000]  все наши гарантии.
[25:35.000 --> 25:37.000]  Я поломал то, что находилось
[25:37.000 --> 25:39.000]  за pin.
[25:45.000 --> 25:47.000]  В первую очередь даже не то,
[25:47.000 --> 25:49.000]  что находилось за pin,
[25:49.000 --> 25:51.000]  а то, что я получил из std-memo,
[25:51.000 --> 25:53.000]  оно некорректно.
[25:57.000 --> 25:59.000]  Теперь
[25:59.000 --> 26:01.000]  все становится еще более
[26:01.000 --> 26:03.000]  интересно. Появляется функция
[26:03.000 --> 26:05.000]  unchecked.
[26:05.000 --> 26:07.000]  Не unchecked она делает pin для
[26:07.000 --> 26:09.000]  любого объекта, даже если он un-pin.
[26:09.000 --> 26:11.000]  Не un-pin.
[26:11.000 --> 26:13.000]  И вот ее особенность в том,
[26:13.000 --> 26:15.000]  что если до этого
[26:15.000 --> 26:17.000]  она была, ну new ее вариант,
[26:17.000 --> 26:19.000]  вариант new pin
[26:19.000 --> 26:21.000]  был безопасен,
[26:21.000 --> 26:23.000]  потому что мы имплеметировали
[26:23.000 --> 26:25.000]  un-pin, и это было нормально вполне, pin-ить и un-pin-ить.
[26:25.000 --> 26:27.000]  У нас структурки было без разницы.
[26:29.000 --> 26:31.000]  Да, unsafe, потому что у нас
[26:31.000 --> 26:33.000]  контракт.
[26:33.000 --> 26:35.000]  Да, мы сделали этот pin,
[26:35.000 --> 26:37.000]  и соответственно у нас контракт, что мы не будем
[26:37.000 --> 26:39.000]  мувать этот pin, то, что за pin.
[26:39.000 --> 26:41.000]  Поэтому мы явным образом писали
[26:41.000 --> 26:43.000]  unsafe. Здесь вот пользователь,
[26:43.000 --> 26:45.000]  ты должен проследить за тем,
[26:45.000 --> 26:47.000]  что ты дальше не будешь мувать эту структурку
[26:47.000 --> 26:49.000]  после того, как ты создал pin.
[26:53.000 --> 26:55.000]  Ну вот, смотрите.
[26:55.000 --> 26:57.000]  На этот раз я создаю pin unchecked,
[26:57.000 --> 26:59.000]  например.
[26:59.000 --> 27:01.000]  Точно так же там инициализирую что-то.
[27:01.000 --> 27:03.000]  Ну и обратите внимание,
[27:03.000 --> 27:05.000]  что вот это на этот раз не будет
[27:05.000 --> 27:07.000]  компилироваться, потому что у нас
[27:07.000 --> 27:09.000]  не будет имплементирован direct-mute.
[27:09.000 --> 27:11.000]  Мы не сможем просто
[27:11.000 --> 27:13.000]  из hit-value на этот раз получить
[27:13.000 --> 27:15.000]  просто так мутабельную ссылку,
[27:15.000 --> 27:17.000]  иначе мы могли сразу же разломать
[27:17.000 --> 27:19.000]  наше сейфти. Могли бы просто
[27:19.000 --> 27:21.000]  написать memory-place,
[27:21.000 --> 27:23.000]  вот как я это сделал, и тогда бы у нас просто
[27:23.000 --> 27:25.000]  поломал все наше сейфти.
[27:25.000 --> 27:27.000]  А так,
[27:27.000 --> 27:29.000]  если вы захотите все-таки сделать
[27:29.000 --> 27:31.000]  такой replace, то вам нужно будет написать еще
[27:31.000 --> 27:33.000]  одну unsafe-функцию, в которой, соответственно,
[27:33.000 --> 27:35.000]  будет контракт, что вы
[27:35.000 --> 27:37.000]  не ломайте никаких
[27:37.000 --> 27:39.000]  указателей на себя внутри.
[27:39.000 --> 27:41.000]  До этого мы сейчас дойдем.
[27:43.000 --> 27:45.000]  Вот, ну это как раз
[27:45.000 --> 27:47.000]  упражнение. Да, как раз
[27:47.000 --> 27:49.000]  вопрос, на который мы ответили.
[27:49.000 --> 27:51.000]  Какой контракт? Ну контракт, что мы
[27:51.000 --> 27:53.000]  если создаем pin, то в таком случае
[27:53.000 --> 27:55.000]  мы никогда ни в каком случае не будем ломать
[27:55.000 --> 27:57.000]  нашу
[27:57.000 --> 27:59.000]  не сломаем нашу структурку.
[27:59.000 --> 28:01.000]  Мы никогда не будем двигать то,
[28:01.000 --> 28:03.000]  что находится за ссылкой.
[28:05.000 --> 28:07.000]  Если мы разломаем
[28:07.000 --> 28:09.000]  это, разломаем наше обещание,
[28:09.000 --> 28:11.000]  не выполним это обещание, то в таком случае мы
[28:11.000 --> 28:13.000]  очень легко можем получить антенсейфти.
[28:15.000 --> 28:17.000]  Ну вот, смотрите.
[28:17.000 --> 28:19.000]  Давайте посмотрим на наш пример с генератором.
[28:21.000 --> 28:23.000]  Ну, насколько вы должны помнить, у нас
[28:23.000 --> 28:25.000]  генераторе теперь не просто muteSelf, а
[28:25.000 --> 28:27.000]  pin от muteSelf.
[28:27.000 --> 28:29.000]  И обратить внимание,
[28:29.000 --> 28:31.000]  этот код, конечно, компилируется.
[28:31.000 --> 28:33.000]  Но мы написали дважды unsafe.
[28:33.000 --> 28:35.000]  И более того, мы, когда
[28:35.000 --> 28:37.000]  сделали move снизу, мы нарушили наш контракт,
[28:37.000 --> 28:39.000]  который мы написали сверху.
[28:39.000 --> 28:41.000]  Вот здесь вот. То есть в первой строчке,
[28:41.000 --> 28:43.000]  когда мы пишем unsafe,
[28:43.000 --> 28:45.000]  мы делаем pin,
[28:45.000 --> 28:47.000]  обещаем, что мы не будем ничего
[28:47.000 --> 28:49.000]  ломать, и после этого все ломаем.
[28:49.000 --> 28:51.000]  И соответственно, следующий unsafe
[28:51.000 --> 28:53.000]  там будет резюм на генераторе,
[28:53.000 --> 28:55.000]  который разломан.
[28:55.000 --> 28:57.000]  Там будет ссылочка куда-то,
[28:57.000 --> 28:59.000]  которая находится в другом месте на стеке.
[29:03.000 --> 29:05.000]  Получается, таким образом мы явно указали
[29:05.000 --> 29:07.000]  какой-то контракт и возложили
[29:07.000 --> 29:09.000]  на пользователя обязанности ему следовать.
[29:09.000 --> 29:11.000]  Ну, в общем-то,
[29:11.000 --> 29:13.000]  я думаю, что это правильно
[29:13.000 --> 29:15.000]  более чем какой-нибудь straight move,
[29:15.000 --> 29:17.000]  потому что все-таки эти структурки редко возникают,
[29:17.000 --> 29:19.000]  pin.
[29:19.000 --> 29:21.000]  И поэтому очень, наверное, правильно
[29:21.000 --> 29:23.000]  все-таки приложить на пользователя
[29:23.000 --> 29:25.000]  то, чтобы он
[29:25.000 --> 29:27.000]  занимался
[29:27.000 --> 29:29.000]  тем, чтобы
[29:29.000 --> 29:31.000]  корректное состояние поддерживал
[29:31.000 --> 29:33.000]  своей
[29:33.000 --> 29:35.000]  self-referential структурке.
[29:37.000 --> 29:39.000]  Ну, есть еще две важные функции.
[29:39.000 --> 29:41.000]  GetMute и GetUncheckedMute.
[29:41.000 --> 29:43.000]  Ну, как вы можете заметить,
[29:43.000 --> 29:45.000]  GetMute безопасен,
[29:45.000 --> 29:47.000]  но он требует onPin типа.
[29:47.000 --> 29:49.000]  Если мы без разницы, ну, выдаем GetMute
[29:49.000 --> 29:51.000]  и там хоть Replace,
[29:51.000 --> 29:53.000]  хоть что меняете, без разницы.
[29:53.000 --> 29:55.000]  Ну, здесь понятно,
[29:55.000 --> 29:57.000]  почему GetMute реализован
[29:57.000 --> 29:59.000]  для onPin.
[30:01.000 --> 30:03.000]  Да, так, и
[30:03.000 --> 30:05.000]  GetUncheckedMute.
[30:05.000 --> 30:07.000]  Ну, вот если вы onPin не имплементируете,
[30:07.000 --> 30:09.000]  то в таком случае, если вы возьмете
[30:09.000 --> 30:11.000]  ссылку на объект, который находится
[30:11.000 --> 30:13.000]  за pin, то в таком случае вы бы
[30:13.000 --> 30:15.000]  могли все разломать, поэтому
[30:15.000 --> 30:17.000]  сейф функция и контракт у нее,
[30:17.000 --> 30:19.000]  что вы, получив эту ссылочку,
[30:19.000 --> 30:21.000]  не разломайте ничего внутри.
[30:25.000 --> 30:27.000]  Вот. Ну, когда вы
[30:27.000 --> 30:29.000]  как раз-то же сказал,
[30:29.000 --> 30:31.000]  когда вы используете GetUncheckedMute, вы должны
[30:31.000 --> 30:33.000]  пообещать, что вы не будете ломать никакие
[30:33.000 --> 30:35.000]  self-references,
[30:35.000 --> 30:37.000]  то есть ссылки указательные на себе.
[30:39.000 --> 30:41.000]  Ну, и более того,
[30:41.000 --> 30:43.000]  тут есть некоторая сложность
[30:43.000 --> 30:45.000]  в том, что
[30:45.000 --> 30:47.000]  DREF нашего указателя,
[30:47.000 --> 30:49.000]  который мы будем использовать, и DREFMute
[30:49.000 --> 30:51.000]  не должны
[30:51.000 --> 30:53.000]  в общем, ломать нам self.
[30:53.000 --> 30:55.000]  Насколько вы помните, у нас
[30:55.000 --> 30:57.000]  trait.dref и dref.mute это какие-то произвольные
[30:57.000 --> 30:59.000]  штуки, о которых пишутся пользователи.
[30:59.000 --> 31:01.000]  А внутри бы мы могли написать в таком случае
[31:01.000 --> 31:03.000]  просто из TD Replace какой-нибудь, да?
[31:03.000 --> 31:05.000]  Ну, по-моему, у меня дальше должен быть примерчик.
[31:05.000 --> 31:07.000]  Да. Ну, вот, смотрите.
[31:07.000 --> 31:09.000]  Есть какой-то evil pointer,
[31:09.000 --> 31:11.000]  который принимает на ход наш self-referential
[31:11.000 --> 31:13.000]  турку,
[31:13.000 --> 31:15.000]  и мы сделали, ну, DREF работает как надо,
[31:15.000 --> 31:17.000]  а вот DREFMute у нас
[31:17.000 --> 31:19.000]  такой негодяй внутри делает Replace.
[31:21.000 --> 31:23.000]  И все ломает.
[31:23.000 --> 31:25.000]  Ну, и тем самым получается,
[31:25.000 --> 31:27.000]  что когда мы пишем
[31:27.000 --> 31:29.000]  вот этот вот unsave,
[31:29.000 --> 31:31.000]  мы не выполняем наш контракт, что у нас
[31:31.000 --> 31:33.000]  корректная имплементация
[31:33.000 --> 31:35.000]  от DREFMute,
[31:35.000 --> 31:37.000]  которая нам
[31:37.000 --> 31:39.000]  MemReplace,
[31:39.000 --> 31:41.000]  ну, в общем, MemReplace нам
[31:41.000 --> 31:43.000]  ломает этот контракт внутри.
[31:49.000 --> 31:51.000]  Смотри, просто когда ты будешь делать...
[31:55.000 --> 31:57.000]  Ну, смотри, когда ты просто создаешь PIN,
[31:57.000 --> 31:59.000]  здесь проблем не будет.
[31:59.000 --> 32:01.000]  Просто создаешь... Ну, вот если ты дальше там будешь
[32:01.000 --> 32:03.000]  делать что-нибудь по Mute указать,
[32:03.000 --> 32:05.000]  просто сделаешь getUncheckedMute,
[32:05.000 --> 32:07.000]  то в таком случае
[32:07.000 --> 32:09.000]  у тебя же для того, чтобы получить
[32:09.000 --> 32:11.000]  эту Mute ссылочку, тебе нужно сделать DREFMute.
[32:11.000 --> 32:13.000]  Все, у тебя здесь разломалась,
[32:13.000 --> 32:15.000]  ты разломал структуру.
[32:15.000 --> 32:17.000]  Поэтому ты должен дать гарантию насчет своей имплементации.
[32:21.000 --> 32:23.000]  Ну, есть еще
[32:23.000 --> 32:25.000]  последнее место, где мы можем что-то разломать.
[32:25.000 --> 32:27.000]  Это drop.
[32:27.000 --> 32:29.000]  Drop это, как обычно, такая штука, которая
[32:29.000 --> 32:31.000]  что-то может в последний момент
[32:31.000 --> 32:33.000]  испортить.
[32:33.000 --> 32:35.000]  Ну, вот когда у нас
[32:35.000 --> 32:37.000]  drop вызывается, он получает
[32:37.000 --> 32:39.000]  mutable ссылочку на self, насколько вы
[32:39.000 --> 32:41.000]  помните. Но дело в том, что
[32:41.000 --> 32:43.000]  он вызывается даже тогда, когда у вас
[32:43.000 --> 32:45.000]  тип был запинан до этого.
[32:45.000 --> 32:47.000]  А это означает то, что
[32:47.000 --> 32:49.000]  внутри dropа может
[32:49.000 --> 32:51.000]  какой-то некорректный код сидеть,
[32:51.000 --> 32:53.000]  который вам что-то разломает.
[32:53.000 --> 32:55.000]  Ну, вот опять же, я зафигачил здесь memReplace
[32:55.000 --> 32:57.000]  и вот у меня drop,
[32:57.000 --> 32:59.000]  который нарушит
[32:59.000 --> 33:01.000]  контракт PIN-а.
[33:01.000 --> 33:03.000]  Явно.
[33:03.000 --> 33:05.000]  Стоп.
[33:05.000 --> 33:07.000]  Ну,
[33:07.000 --> 33:09.000]  по-моему,
[33:09.000 --> 33:11.000]  когда у нас drop происходит,
[33:11.000 --> 33:13.000]  то, скорее всего, PIN умирает
[33:13.000 --> 33:15.000]  вместе со самой ссылкой с самим объектом.
[33:17.000 --> 33:19.000]  Там нужно просто найти такой момент.
[33:19.000 --> 33:21.000]  Дело в том, что drop...
[33:21.000 --> 33:23.000]  После dropа ты, на самом деле, сразу же диалогацию
[33:23.000 --> 33:25.000]  не делаешь. Ты сначала drop
[33:25.000 --> 33:27.000]  и делаешь у всех объектов,
[33:27.000 --> 33:29.000]  у самой структурки, у всех
[33:29.000 --> 33:31.000]  ее полей,
[33:31.000 --> 33:33.000]  а потом уже ты вызываешь диалогацию.
[33:33.000 --> 33:35.000]  И вот тут у тебя может быть такое,
[33:35.000 --> 33:37.000]  что у тебя drop в структурке,
[33:37.000 --> 33:39.000]  что-то соседнее, например,
[33:39.000 --> 33:41.000]  будет полагаться на то, что у тебя
[33:41.000 --> 33:43.000]  корректная структура внутри.
[33:43.000 --> 33:45.000]  То есть там будет внутри
[33:45.000 --> 33:47.000]  где-нибудь PIN у тебя внутри своей структурки
[33:47.000 --> 33:49.000]  на эту ерунду,
[33:49.000 --> 33:51.000]  и drop у тебя будет некорректный,
[33:51.000 --> 33:53.000]  и в итоге какой-то
[33:53.000 --> 33:55.000]  сосед у тебя обратится
[33:55.000 --> 33:57.000]  в некорректную структурку.
[33:57.000 --> 33:59.000]  Сейчас, ну да, если мы drop'ем
[33:59.000 --> 34:01.000]  этот объект, то это действительно может нам все разломать.
[34:01.000 --> 34:03.000]  Просто если у нас
[34:03.000 --> 34:05.000]  такой dropающийся объект
[34:05.000 --> 34:07.000]  это complete object, то кажется,
[34:07.000 --> 34:09.000]  ничего страшного уже не будет.
[34:09.000 --> 34:11.000]  Ну,
[34:11.000 --> 34:13.000]  здесь можно легко напортачить.
[34:13.000 --> 34:15.000]  Если его сцинкер скидать,
[34:15.000 --> 34:17.000]  то, скорее всего, все должно вернуться,
[34:17.000 --> 34:19.000]  поэтому проще попросить, чтобы drop
[34:19.000 --> 34:21.000]  никого не ломал.
[34:21.000 --> 34:23.000]  Тут есть, кстати, предложение такое,
[34:23.000 --> 34:25.000]  только предлагает решить раз.
[34:25.000 --> 34:27.000]  Здесь это я должен признать, опять же.
[34:27.000 --> 34:29.000]  Опять же, PIN появился значительно позже,
[34:29.000 --> 34:31.000]  чем
[34:31.000 --> 34:33.000]  появилась синхронность,
[34:33.000 --> 34:35.000]  точнее, чем стабилизировался raster,
[34:35.000 --> 34:37.000]  соответственно, drop.
[34:37.000 --> 34:39.000]  И получается, что в drop'е
[34:39.000 --> 34:41.000]  было бы хорошо принимать PIN на mute self.
[34:43.000 --> 34:45.000]  То есть было бы максимально правильно,
[34:45.000 --> 34:47.000]  здесь это WFM drop, вместо mute self
[34:47.000 --> 34:49.000]  принимать PIN mute self.
[34:49.000 --> 34:51.000]  Это было бы правильно и корректно.
[34:51.000 --> 34:53.000]  Но так как PINов те времена не было,
[34:53.000 --> 34:55.000]  нам
[34:55.000 --> 34:57.000]  у нас есть то, что есть.
[34:57.000 --> 34:59.000]  И теперь, если у вас структурка
[34:59.000 --> 35:01.000]  где-нибудь использует PIN,
[35:01.000 --> 35:03.000]  то в таком случае вам нужно подумать,
[35:03.000 --> 35:05.000]  а может мой drop что-то может разломать
[35:05.000 --> 35:07.000]  и написать такой код.
[35:07.000 --> 35:09.000]  Явно запинить вот здесь тот объект,
[35:09.000 --> 35:11.000]  который мы вам передали.
[35:11.000 --> 35:13.000]  И дальше писать код, исходя из того,
[35:13.000 --> 35:15.000]  что вам выдали PIN.
[35:15.000 --> 35:17.000]  Но это просто для того,
[35:17.000 --> 35:19.000]  чтобы как-то самому себе отметить,
[35:19.000 --> 35:21.000]  вот я вот здесь должен соблюдать
[35:21.000 --> 35:23.000]  этот контракт.
[35:23.000 --> 35:25.000]  То есть чтобы не писать код,
[35:25.000 --> 35:27.000]  который не исстреляет в ноги,
[35:27.000 --> 35:29.000]  нам надо взять unsaved.
[35:29.000 --> 35:31.000]  Не приятно.
[35:31.000 --> 35:33.000]  Смотри, ты же unsaved может
[35:33.000 --> 35:35.000]  где-то внешне заюзать,
[35:35.000 --> 35:37.000]  вне dropа.
[35:37.000 --> 35:39.000]  И вот если ты не можешь его заюзать,
[35:39.000 --> 35:41.000]  ну там допустим у тебя объект self
[35:41.000 --> 35:43.000]  unpin, то в таком случае тебя об этом
[35:43.000 --> 35:45.000]  беспокойте не надо.
[35:45.000 --> 35:47.000]  А если он not unpin, то в таком случае
[35:47.000 --> 35:49.000]  для тебя это уже очень важно.
[35:49.000 --> 35:51.000]  Особенно тогда, когда ты начинаешь уже
[35:51.000 --> 35:53.000]  посоветствовать где-то PIN.
[35:53.000 --> 35:55.000]  В таком случае тебе нужно об этом думать.
[35:55.000 --> 35:57.000]  Да, да.
[35:57.000 --> 35:59.000]  Поэтому вот это вот просто
[35:59.000 --> 36:01.000]  для того, чтобы явно
[36:01.000 --> 36:03.000]  себе обозначить контракт
[36:03.000 --> 36:05.000]  свой же в дропе.
[36:05.000 --> 36:07.000]  По факту можете это не делать,
[36:07.000 --> 36:09.000]  а просто так учитывать, но это не очень
[36:09.000 --> 36:11.000]  красиво как-то будет.
[36:11.000 --> 36:13.000]  Это идея прикольная.
[36:15.000 --> 36:17.000]  Ну вот да, я как раз
[36:17.000 --> 36:19.000]  только написал, что на самом деле
[36:19.000 --> 36:21.000]  в идеальном мире мы бы хотели, чтобы drop
[36:21.000 --> 36:23.000]  принимал PIN на mute self, но к сожалению
[36:23.000 --> 36:25.000]  уже слишком поздно.
[36:25.000 --> 36:27.000]  Возможно кто-нибудь сделает 1.2.0, и там будет
[36:27.000 --> 36:29.000]  сразу же PIN mute self на drop.
[36:29.000 --> 36:31.000]  Пока что то, что есть.
[36:35.000 --> 36:37.000]  Ну не знаю.
[36:37.000 --> 36:39.000]  Плюс ко всему ты все-таки drop пишешь
[36:39.000 --> 36:41.000]  очень редко для PIN типов.
[36:41.000 --> 36:43.000]  Ну вообще сами по себе
[36:43.000 --> 36:45.000]  PIN типы редкие, тем более редкие
[36:45.000 --> 36:47.000]  dropы на PIN типы.
[36:47.000 --> 36:49.000]  Поэтому
[36:49.000 --> 36:51.000]  получается такая ерунда,
[36:51.000 --> 36:53.000]  что тебе просто
[36:53.000 --> 36:55.000]  наверное не хочется даже это, возможно, язык
[36:55.000 --> 36:57.000]  добавлять, потому что придется слишком
[36:57.000 --> 36:59.000]  сложно пользователям, которые вообще
[36:59.000 --> 37:01.000]  ничего не знают, им придется про это знать
[37:01.000 --> 37:03.000]  и что-то учить.
[37:05.000 --> 37:07.000]  Ну смотрите, на восьмой лекции узнал.
[37:07.000 --> 37:09.000]  Ты узнал на восьмой лекции про это.
[37:09.000 --> 37:11.000]  Проблема.
[37:13.000 --> 37:15.000]  Так.
[37:15.000 --> 37:17.000]  Хорошо.
[37:17.000 --> 37:19.000]  Есть еще одна такая штука.
[37:19.000 --> 37:21.000]  Задумались ли вы, пока сидели на лекции,
[37:21.000 --> 37:23.000]  почему он PIN вообще безопасно
[37:23.000 --> 37:25.000]  для имплементации? У нас был например
[37:25.000 --> 37:27.000]  send и sync, которые были unsaved для имплементации.
[37:29.000 --> 37:31.000]  Которым нужно было что-то гарантировать.
[37:31.000 --> 37:33.000]  А почему он PIN безопасно
[37:33.000 --> 37:35.000]  имплементировать?
[37:35.000 --> 37:37.000]  Причем всегда.
[37:37.000 --> 37:39.000]  Он же может нам что-то
[37:39.000 --> 37:41.000]  похерить в коде вокруг.
[37:45.000 --> 37:47.000]  Более того,
[37:47.000 --> 37:49.000]  здесь есть такой
[37:49.000 --> 37:51.000]  код, на который вы можете посмотреть.
[37:51.000 --> 37:53.000]  Здесь я
[37:53.000 --> 37:55.000]  сделал какую-то структурку readyT,
[37:55.000 --> 37:57.000]  в которую у меня внутри value есть.
[37:57.000 --> 37:59.000]  Ну и все, что я делаю в генераторе,
[37:59.000 --> 38:01.000]  это просто говорю, ну, я закончил
[38:01.000 --> 38:03.000]  итерацию, вот,
[38:03.000 --> 38:05.000]  take значение и возвращаю
[38:05.000 --> 38:07.000]  его.
[38:07.000 --> 38:09.000]  Почему это безопасно?
[38:09.000 --> 38:11.000]  Я же что-то умываю внутри.
[38:11.000 --> 38:13.000]  При том, что я пообещал, что ничего умывать не буду
[38:13.000 --> 38:15.000]  здесь вот в PIN.
[38:29.000 --> 38:31.000]  Ну, так это вроде
[38:31.000 --> 38:33.000]  как бы сам
[38:33.000 --> 38:35.000]  ну, запиненный объект,
[38:35.000 --> 38:37.000]  ты опшен по нему не умываешь,
[38:37.000 --> 38:39.000]  ты умываешь только какой-то содержимое
[38:39.000 --> 38:41.000]  опшен.
[38:41.000 --> 38:43.000]  Ну, как бы совсем, ну, через несколько слоев
[38:43.000 --> 38:45.000]  пролезаем, чтобы что-то умудрить, и кажется,
[38:45.000 --> 38:47.000]  что это не очень страшно.
[38:47.000 --> 38:49.000]  Если ты все предпочел, то конечно уже
[38:49.000 --> 38:51.000]  веселее начинается.
[38:51.000 --> 38:53.000]  Ну, вот, хорошо, смотри.
[38:53.000 --> 38:55.000]  Короткий ответ, потому что
[38:55.000 --> 38:57.000]  у нас мы не давали
[38:57.000 --> 38:59.000]  никаких гарантий насчет T.
[38:59.000 --> 39:01.000]  Мы и запинили self, но мы не пинили
[39:01.000 --> 39:03.000]  никакого T. Мы же не гарантировали, что
[39:03.000 --> 39:05.000]  T мы не будем умывать.
[39:05.000 --> 39:07.000]  Все, все хорошо.
[39:07.000 --> 39:09.000]  Весь этот
[39:09.000 --> 39:11.000]  код безопасен.
[39:11.000 --> 39:13.000]  И с ним все хорошо.
[39:13.000 --> 39:15.000]  Он же никогда не сломается, он максимум
[39:15.000 --> 39:17.000]  запаникует, если вы дважды резюм сделаете
[39:17.000 --> 39:19.000]  на ready, и внутри значения
[39:19.000 --> 39:21.000]  не будет.
[39:21.000 --> 39:23.000]  Ну, он же безопасен абсолютно.
[39:25.000 --> 39:27.000]  Ну, в общем,
[39:27.000 --> 39:29.000]  PIN имеет значение только тогда,
[39:29.000 --> 39:31.000]  когда его вы создаете.
[39:31.000 --> 39:33.000]  То есть вы когда создаете структуру с PIN,
[39:33.000 --> 39:35.000]  то вы даете обещание,
[39:35.000 --> 39:37.000]  и вот только тогда уже PIN начинает иметь значение.
[39:37.000 --> 39:39.000]  До этого момента на PIN
[39:39.000 --> 39:41.000]  вам все равно.
[39:43.000 --> 39:45.000]  А что насчет такого вот кода?
[39:45.000 --> 39:47.000]  Теперь у нас в readyT
[39:47.000 --> 39:49.000]  внутри сидит генератор.
[39:51.000 --> 39:53.000]  T это генератор.
[39:53.000 --> 39:55.000]  И здесь внутри у меня unsaved
[39:55.000 --> 39:57.000]  код. То есть я делаю unsaved
[39:57.000 --> 39:59.000]  PIN для того, чтобы вызвать резюм
[39:59.000 --> 40:01.000]  на своем value, который
[40:01.000 --> 40:03.000]  сидит внутри.
[40:27.000 --> 40:29.000]  Ну, смотрите,
[40:29.000 --> 40:31.000]  на этот раз я уже дал какое-то обещание.
[40:31.000 --> 40:33.000]  Написал unsaved, написал PIN,
[40:33.000 --> 40:35.000]  new, unchecked. Я дал только что
[40:35.000 --> 40:37.000]  обещание, и я не буду этому быть.
[40:39.000 --> 40:41.000]  Вот это вот обещание,
[40:41.000 --> 40:43.000]  оно некорректное,
[40:43.000 --> 40:45.000]  потому что у меня
[40:45.000 --> 40:47.000]  Myself это onPIN.
[40:47.000 --> 40:49.000]  Ну,
[40:49.000 --> 40:51.000]  вот это вот обещание,
[40:51.000 --> 40:53.000]  оно некорректное,
[40:53.000 --> 40:55.000]  потому что у меня
[40:55.000 --> 40:57.000]  это onPIN.
[40:57.000 --> 40:59.000]  Ну, если он onPIN,
[40:59.000 --> 41:01.000]  то в таком случае, что он не мешает
[41:01.000 --> 41:03.000]  помыть sel, да.
[41:03.000 --> 41:05.000]  И все разломалось.
[41:07.000 --> 41:09.000]  Если он onPIN, то в таком случае
[41:09.000 --> 41:11.000]  вот это вот не имеет никакого значения.
[41:11.000 --> 41:13.000]  Оказывается.
[41:13.000 --> 41:15.000]  И этот код,
[41:15.000 --> 41:17.000]  если бы вот это onPIN не было,
[41:17.000 --> 41:19.000]  тогда мы могли его сделать
[41:19.000 --> 41:21.000]  вот так вот, потому что я пообещал,
[41:21.000 --> 41:23.000]  что я не буду этому быть. Этот код был
[41:23.000 --> 41:25.000]  некорректен, потому что
[41:27.000 --> 41:29.000]  я бы moval объект, который
[41:29.000 --> 41:31.000]  внутри запиненного находится, и все
[41:31.000 --> 41:33.000]  было бы хорошо.
[41:33.000 --> 41:35.000]  А вот если бы я,
[41:35.000 --> 41:37.000]  ну, когда я написал onPIN,
[41:37.000 --> 41:39.000]  то в таком случае мне ничего не мешает
[41:39.000 --> 41:41.000]  помыть текущий объект, ну, то есть запинить, заонпинить его,
[41:41.000 --> 41:43.000]  то есть это никакого значения опять же
[41:43.000 --> 41:45.000]  теперь не имеет.
[41:45.000 --> 41:47.000]  И вот этот вот unsafe, он некорректен.
[41:47.000 --> 41:49.000]  Абсолютно.
[41:49.000 --> 41:51.000]  То есть pin new, unchecked, ну, просто не в состоянии
[41:51.000 --> 41:53.000]  помыть это обещание, на самом деле.
[41:53.000 --> 41:55.000]  То есть по-хорошему нам бы
[41:55.000 --> 41:57.000]  законстроение, что new unchecked только для тех,
[41:57.000 --> 41:59.000]  кто не реализует onPIN?
[41:59.000 --> 42:01.000]  Нет, это что-то уже
[42:01.000 --> 42:03.000]  сверху, понимаешь, получается.
[42:03.000 --> 42:05.000]  То есть ты начинаешь что-то родителям
[42:05.000 --> 42:07.000]  говорить, ну, что-то не очень.
[42:09.000 --> 42:11.000]  Ну, слушай, почему бы не сказать, что мы не можем
[42:11.000 --> 42:13.000]  делать new unchecked для тех, кто...
[42:13.000 --> 42:15.000]  Что-то мне подсказывает, потому что
[42:15.000 --> 42:17.000]  есть очень много примеров, когда и можно,
[42:17.000 --> 42:19.000]  и нельзя, поэтому...
[42:19.000 --> 42:21.000]  А вдруг вот этот вот те, который...
[42:21.000 --> 42:23.000]  А, нет, тогда бы нам unsafe здесь не понадобился,
[42:23.000 --> 42:25.000]  если бы внутри был pin.
[42:25.000 --> 42:27.000]  Ну, короче, мне кажется, что
[42:27.000 --> 42:29.000]  такое невозможно, потому что
[42:29.000 --> 42:31.000]  просто код легко придумать, в котором...
[42:31.000 --> 42:33.000]  Должно быть легко придумать, в котором
[42:33.000 --> 42:35.000]  это принесет
[42:35.000 --> 42:37.000]  проблемы, а не
[42:37.000 --> 42:39.000]  удобства.
[42:39.000 --> 42:41.000]  Поэтому onPIN сам по себе здесь
[42:41.000 --> 42:43.000]  был безопасен, а вот этот вот unsafe
[42:43.000 --> 42:45.000]  просто не выполнил контракт,
[42:45.000 --> 42:47.000]  когда мы его написали.
[42:49.000 --> 42:51.000]  Вот, и мы не знаем,
[42:51.000 --> 42:53.000]  имплементируют ли те onPIN.
[42:53.000 --> 42:55.000]  Если бы мы написали, что те onPIN, то в таком случае
[42:55.000 --> 42:57.000]  действительно мы создали pin.
[42:57.000 --> 42:59.000]  Более того, он бы был safe, там pin new,
[42:59.000 --> 43:01.000]  и все было бы хорошо. А так получается,
[43:01.000 --> 43:03.000]  что просто можем
[43:03.000 --> 43:05.000]  умолвить наш текущий объект.
[43:07.000 --> 43:09.000]  Соответственно, у нас имплементация
[43:09.000 --> 43:11.000]  onPIN, она абсолютно безопасна,
[43:11.000 --> 43:13.000]  но она может резонировать с тем кодом,
[43:13.000 --> 43:15.000]  который находится вокруг.
[43:15.000 --> 43:17.000]  Ведь это вот пример нелокальности
[43:17.000 --> 43:19.000]  unsafe.
[43:19.000 --> 43:21.000]  В прошлой лекции я вам не показывал таких примеров,
[43:21.000 --> 43:23.000]  но это вот такой пример,
[43:23.000 --> 43:25.000]  когда вы пишете unsafe в одном месте,
[43:25.000 --> 43:27.000]  а стреляет он из-за кода
[43:27.000 --> 43:29.000]  совершенно в другом месте.
[43:31.000 --> 43:33.000]  То есть, писать unsafe очень сложно.
[43:33.000 --> 43:35.000]  Когда вы пишете unsafe, то вы должны гарантировать
[43:35.000 --> 43:37.000]  в любой момент времени, что у вас что-то вокруг
[43:37.000 --> 43:39.000]  хорошо, что вы выполняете
[43:39.000 --> 43:41.000]  какие-то контракты, которые вам сказал unsafe.
[43:41.000 --> 43:43.000]  Иначе может быть такое, что вы
[43:43.000 --> 43:45.000]  написали, например, точно так же
[43:45.000 --> 43:47.000]  для генератора такой вот код,
[43:47.000 --> 43:49.000]  потом в какой-то момент пришел другой человек,
[43:49.000 --> 43:51.000]  написал onPIN, вы это не заметили,
[43:51.000 --> 43:53.000]  у вас ралмонался unsafe внутри.
[43:53.000 --> 43:55.000]  Потому что он перестал
[43:55.000 --> 43:57.000]  выполняться контракт какой-то.
[44:01.000 --> 44:03.000]  Давайте перейдем еще одной функцией.
[44:03.000 --> 44:05.000]  Называется map unchecked new.
[44:07.000 --> 44:09.000]  Это такая функция, которая нам
[44:09.000 --> 44:11.000]  позволяет запустить какой-то клоуже,
[44:11.000 --> 44:13.000]  внутри которой нам будет доступно
[44:13.000 --> 44:15.000]  мьют, ссылочка на T.
[44:17.000 --> 44:19.000]  Возвращается на будет PIN
[44:19.000 --> 44:21.000]  на какой-то другой тип.
[44:21.000 --> 44:23.000]  Вот это вот map.
[44:23.000 --> 44:25.000]  В общем, map это наш
[44:25.000 --> 44:27.000]  текущий тип в какой-то другой.
[44:27.000 --> 44:29.000]  И внутри клоуже нам доступна
[44:29.000 --> 44:31.000]  мьют, ссылочка на текущий тип.
[44:31.000 --> 44:33.000]  Внутри мы, естественно, должны гарантировать,
[44:33.000 --> 44:35.000]  что в map unchecked
[44:35.000 --> 44:37.000]  мы не ломаем никаких инвариантов.
[44:37.000 --> 44:39.000]  Мы там делаем
[44:39.000 --> 44:41.000]  replace, например.
[44:43.000 --> 44:45.000]  И когда это бывает полезно?
[44:45.000 --> 44:47.000]  Например, тогда, когда вы хотите
[44:47.000 --> 44:49.000]  получить доступ
[44:49.000 --> 44:51.000]  к какому-то полю
[44:51.000 --> 44:53.000]  исходной структурки.
[44:53.000 --> 44:55.000]  Давайте посмотрим какой-нибудь пример.
[44:55.000 --> 44:57.000]  Смотрите, у меня есть мой
[44:57.000 --> 44:59.000]  generator,
[44:59.000 --> 45:01.000]  внутри которого сидит какой-то другой генератор.
[45:03.000 --> 45:05.000]  Гай-генератор,
[45:05.000 --> 45:07.000]  и я пишу какой-то
[45:07.000 --> 45:09.000]  map unchecked mute для того,
[45:09.000 --> 45:11.000]  чтобы вызвать резюм.
[45:11.000 --> 45:13.000]  Безопасен ли этот код?
[45:13.000 --> 45:15.000]  Ну как будто бы никто нигде не умывается
[45:15.000 --> 45:17.000]  вот с этим часом генератор
[45:17.000 --> 45:19.000]  и вот-вот генератор.
[45:19.000 --> 45:21.000]  Ну да, здесь получается,
[45:21.000 --> 45:23.000]  что действительно
[45:23.000 --> 45:25.000]  безопасный код.
[45:25.000 --> 45:27.000]  А вот здесь
[45:27.000 --> 45:29.000]  ну, если бы мы не делали
[45:29.000 --> 45:31.000]  как-то такой
[45:31.000 --> 45:33.000]  субботик,
[45:33.000 --> 45:35.000]  то бы он не он не был
[45:35.000 --> 45:37.000]  в текущей структуре.
[45:37.000 --> 45:39.000]  А если бы мы не делали
[45:39.000 --> 45:41.000]  как-то такой
[45:41.000 --> 45:43.000]  Действительно безопасный код
[45:43.000 --> 45:46.000]  MyGenerator вот мы дали по поводу
[45:46.000 --> 45:48.000]  генератора какой-то promise
[45:48.000 --> 45:50.000]  что он не мувается
[45:50.000 --> 45:52.000]  и потом внутри мы на него полагаемся
[45:52.000 --> 45:53.000]  вот здесь вот
[45:53.000 --> 45:55.000]  ну раз что он не двигается, значит что поля не двигаются
[45:55.000 --> 45:57.000]  все хорошо
[45:57.000 --> 45:59.000]  делаем unsave, который коллекцион
[45:59.000 --> 46:03.000]  достает нам pin на mute this j
[46:03.000 --> 46:07.000]  ну и резюмим генератор
[46:07.000 --> 46:10.000]  вот, ну здесь конкретная причина
[46:10.000 --> 46:12.000]  во-первых нам юзер пообещал
[46:12.000 --> 46:14.000]  что он не будет мувать селфи
[46:14.000 --> 46:16.000]  и мы внутри map unchecked mute
[46:16.000 --> 46:18.000]  этот promise выполняем
[46:18.000 --> 46:20.000]  мы внутри не делаем никаких replace
[46:20.000 --> 46:22.000]  ну и более того
[46:22.000 --> 46:24.000]  мы пообещали не мувать this j
[46:24.000 --> 46:26.000]  ну мы же создали pin
[46:26.000 --> 46:28.000]  соответственно мы должны ответить за этот pin
[46:28.000 --> 46:30.000]  соответственно мы не двигаем
[46:30.000 --> 46:32.000]  то что находится за pin
[46:32.000 --> 46:34.000]  как и обещали
[46:34.000 --> 46:36.000]  вот, обратите внимание
[46:36.000 --> 46:38.000]  что
[46:38.000 --> 46:40.000]  вот сейчас
[46:40.000 --> 46:42.000]  мы это смогли сделать
[46:42.000 --> 46:44.000]  только потому что нам юзер дал
[46:44.000 --> 46:46.000]  pin на mute self
[46:46.000 --> 46:48.000]  если бы он не смог
[46:48.000 --> 46:50.000]  ну не было здесь вот этот pin mute self
[46:50.000 --> 46:52.000]  то в том случае этот код не был бы коррекцией
[46:52.000 --> 46:54.000]  да
[46:54.000 --> 46:56.000]  мы бы тогда не смогли просто выполнить наш контракт
[46:56.000 --> 46:58.000]  который мы
[46:58.000 --> 47:00.000]  гарантировали что выполняется
[47:00.000 --> 47:02.000]  а теперь
[47:02.000 --> 47:04.000]  давайте чуть-чуть поменяем
[47:04.000 --> 47:06.000]  примерчик
[47:06.000 --> 47:08.000]  здесь
[47:08.000 --> 47:10.000]  безопасен ли этот код
[47:24.000 --> 47:26.000]  похоже кстати на прошлый пример
[47:26.000 --> 47:28.000]  поздно
[47:36.000 --> 47:38.000]  ну да
[47:38.000 --> 47:40.000]  этот код небезопасен
[47:40.000 --> 47:42.000]  потому что у нас
[47:42.000 --> 47:44.000]  он pin соответственно
[47:44.000 --> 47:46.000]  на этот pin полагаться не можем
[47:46.000 --> 47:48.000]  потому что юзер у нас может дальше
[47:48.000 --> 47:50.000]  он pin безопасно
[47:50.000 --> 47:52.000]  и замувать
[47:52.000 --> 47:54.000]  соответственно наш unsaved
[47:54.000 --> 47:56.000]  внутри опять же не коллекцион
[47:56.000 --> 47:58.000]  и
[47:58.000 --> 48:00.000]  и
[48:00.000 --> 48:02.000]  и
[48:02.000 --> 48:04.000]  и
[48:04.000 --> 48:06.000]  и
[48:06.000 --> 48:08.000]  ok давайте перейдем
[48:08.000 --> 48:10.000]  дальше
[48:10.000 --> 48:12.000]  примерно чуть-чуть интереснее
[48:12.000 --> 48:14.000]  а теперь давай
[48:14.000 --> 48:16.000]  вот этот код я сказал
[48:16.000 --> 48:18.000]  небезопасен
[48:18.000 --> 48:20.000]  на этот раз мы убрали
[48:20.000 --> 48:22.000]  pin раз уж он некорректен
[48:22.000 --> 48:24.000]  и пробуем добавить
[48:24.000 --> 48:26.000]  такой код импл
[48:26.000 --> 48:28.000]  generate уже
[48:28.000 --> 48:30.000]  и выдаем mute self
[48:30.000 --> 48:32.000]  просто ссылочку где-то внутри
[48:32.000 --> 48:38.000]  Теперь генератор умеет давать мью целочку на генератор внутри.
[48:38.000 --> 48:42.000]  Будет ли в таком случае вот этот вот код безопасен?
[48:42.000 --> 48:46.000]  При условии, что у вас рядом стоит вот такой вот.
[48:46.000 --> 48:50.000]  Просто умеете мьюджи брать.
[49:02.000 --> 49:06.000]  По-моему, да.
[49:06.000 --> 49:10.000]  Потому что мы вроде как...
[49:10.000 --> 49:14.000]  Ну, внешний жамбург нигде не убиваем.
[49:14.000 --> 49:16.000]  Вот.
[49:16.000 --> 49:20.000]  Но внутренний жамбург, пока никаких требований на код.
[49:20.000 --> 49:28.000]  Ну, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то.
[49:28.000 --> 49:32.000]  Ну, а внутренний жамбург, пока никаких требований на код.
[49:32.000 --> 49:36.000]  На самом деле, у тебя есть ансаунд-код.
[49:36.000 --> 49:38.000]  И на этот раз уже неправ.
[49:38.000 --> 49:42.000]  Смотри, а что мне мешало, например, написать вот так.
[49:42.000 --> 49:46.000]  Здесь, конечно, pin нужно учесть, что он берется по селфу.
[49:46.000 --> 49:50.000]  Соответственно, он будет муваться.
[49:50.000 --> 49:54.000]  Здесь вот уже гений будет существовать после g-резюм.
[49:55.000 --> 49:59.000]  Смотрите, вот сделал g-резюм.
[49:59.000 --> 50:03.000]  Соответственно, после этого я делаю какой-то Memoreplace.
[50:03.000 --> 50:05.000]  У меня ломаются ссылки.
[50:05.000 --> 50:09.000]  Потому что, ну, смотрите, я просто получил мотабельную ссылочку безопасным образом.
[50:09.000 --> 50:13.000]  И потом он адапт-женерейтер запихнул какой-то.
[50:13.000 --> 50:17.000]  И опять написал резюм.
[50:17.000 --> 50:21.000]  У меня опять все разломалось.
[50:22.000 --> 50:26.000]  Тем, что ты не выполнил контракт пина.
[50:26.000 --> 50:30.000]  Ты пообещал, что ты не будешь вот это вот мувать.
[50:30.000 --> 50:32.000]  Ну, хорошо, здесь все хорошо.
[50:32.000 --> 50:34.000]  А потом ты делаешь replace внутри.
[50:34.000 --> 50:38.000]  Ты делаешь внутри replace, и все разломалось.
[50:38.000 --> 50:44.000]  И вот этот вот unsafe, который внутри там находится резюм, он уже некорректен.
[50:45.000 --> 50:51.000]  Что-то, блин, я уже не умываю, что здесь происходит.
[50:51.000 --> 50:55.000]  Ну, здесь вот replace.
[50:55.000 --> 50:59.000]  Ну, внутреннюю жежку можно ли?
[50:59.000 --> 51:05.000]  Ну, раз мы договорились, что не имеем права мувать ее.
[51:05.000 --> 51:09.000]  Мы как бы внешне же не муваем, а внутренне.
[51:09.000 --> 51:11.000]  Ну, в этом смысле ты прав.
[51:11.000 --> 51:14.000]  Ты можешь мувать внутреннюю жежку.
[51:14.000 --> 51:20.000]  Но вот этот вот unsafe код, который ты написал внутри резюм здесь, уже некорректный.
[51:20.000 --> 51:23.000]  Потому что ты пообещал, что ты запинил self.
[51:23.000 --> 51:27.000]  А теперь ты во второй раз вызовешься на другом генераторе.
[51:27.000 --> 51:30.000]  Все, соответственно, ты его мувнул.
[51:30.000 --> 51:34.000]  Ну, ты его мувнул, засунул какой-то другой генератор.
[51:34.000 --> 51:37.000]  А, внутренний пин сломался. Все, понял.
[51:37.000 --> 51:39.000]  То есть внешний пин все еще нормально, а внутренний уже не.
[51:39.000 --> 51:44.000]  Ну, точнее внешний коррекцион, вот этот внутренний, который мы здесь делаем,
[51:44.000 --> 51:47.000]  он уже не выполняет наши варианты.
[51:47.000 --> 51:51.000]  То есть из-за того, что мы добавили вот эту вот возможность получить ньют ссылочку.
[51:51.000 --> 51:54.000]  Нос-н-саунд абстракция. Все.
[51:54.000 --> 51:57.000]  То есть очень такая сложная штука пин здесь.
[51:57.000 --> 52:02.000]  Она стреляет в самые разные способы.
[52:02.000 --> 52:06.000]  То, о чем мы только что говорили, называется structural pin.
[52:06.000 --> 52:09.000]  То есть мы получили из нашей структурки какое-то поле,
[52:09.000 --> 52:11.000]  пин на какое-то наше внутреннее поле.
[52:11.000 --> 52:14.000]  Иногда это бывает нужно.
[52:14.000 --> 52:21.000]  Ну, и, соответственно, если наше поле зависит от пина нашей структуры в целом,
[52:21.000 --> 52:26.000]  то мы structural по нашему полю.
[52:26.000 --> 52:29.000]  Вот так вот. Ну, точнее пиннинг и наш structural по field.
[52:29.000 --> 52:32.000]  Вот так вот.
[52:32.000 --> 52:34.000]  Самое главное, что вам стоит запомнить,
[52:34.000 --> 52:37.000]  что вам больше часть времени все-таки не хочется ничего пинить.
[52:37.000 --> 52:42.000]  То есть, в том числе, у нас был Get Unchecked PIN до этого функции.
[52:42.000 --> 52:46.000]  Постарайтесь в большую часть времени никогда не создавать пина.
[52:46.000 --> 52:49.000]  Если вы создаете PIN, то вы даете какую-то гарантию,
[52:49.000 --> 52:50.000]  ее приходится выполнять.
[52:50.000 --> 52:53.000]  Соответственно, код вокруг можно случайно как-то сломать,
[52:53.000 --> 52:55.000]  если вы PIN создаете.
[52:55.000 --> 52:57.000]  А если вы не даете никаких обещаний, ну все хорошо.
[52:57.000 --> 53:01.000]  Поэтому лучше получать при возможности просто ньют ссылку.
[53:01.000 --> 53:03.000]  Это может быть не очевидно.
[53:03.000 --> 53:06.000]  Ну, типа лучше ждать более сильной гарантии.
[53:06.000 --> 53:09.000]  Но, оказывается, мы тогда даем какое-то обещание.
[53:09.000 --> 53:11.000]  Обещание мы не хотим просто так выполнить.
[53:11.000 --> 53:14.000]  Мы хотим, чтобы обещаний давали меньше.
[53:16.000 --> 53:18.000]  Вот.
[53:18.000 --> 53:20.000]  Ну, поговорим про пиннинг.
[53:20.000 --> 53:23.000]  Так, очень-очень важно понимать, что такое пиннинг.
[53:23.000 --> 53:27.000]  Можете ли вы повторить просто, что значит создать?
[53:27.000 --> 53:31.000]  Какой контракт происходит, когда мы создаем PIN, например?
[53:34.000 --> 53:38.000]  Мы не мываем то, что находится по ссылке,
[53:38.000 --> 53:42.000]  которое мы передали в PIN.
[53:44.000 --> 53:46.000]  Ну, янпин соответственно, что значит?
[53:53.000 --> 53:55.000]  То, что нам по барабану.
[53:55.000 --> 53:56.000]  На эту гарантию.
[53:56.000 --> 54:00.000]  А можно еще объяснить, что такое structural pinning?
[54:00.000 --> 54:04.000]  Structural pinning – это смотри, вот у тебя в этом случае
[54:04.000 --> 54:06.000]  у тебя внутри структурка есть,
[54:06.000 --> 54:09.000]  ну, у тебя внутри глобального генератора есть внутри генератор.
[54:09.000 --> 54:13.000]  И, соответственно, structural pinning – это тогда, когда у тебя есть какое-то поле,
[54:13.000 --> 54:16.000]  которое зависит от пиннинга исходной структуры.
[54:16.000 --> 54:19.000]  Вот у тебя как раз вот этот PIN зависит от этого PIN.
[54:19.000 --> 54:21.000]  Это structural pinning просто называется.
[54:23.000 --> 54:25.000]  Вот.
[54:25.000 --> 54:27.000]  Есть какие-нибудь еще вопросы?
[54:34.000 --> 54:37.000]  Ну, тогда, может, давайте фьючем перейдем.
[54:38.000 --> 54:41.000]  Будем смотреть пока что только на простую фьючу.
[54:41.000 --> 54:43.000]  Для того, чтобы сразу же не испугаться,
[54:43.000 --> 54:45.000]  а то, если я вам выкачу сразу же, как она выглядит,
[54:45.000 --> 54:47.000]  возможно, вы ничего не поймете.
[54:49.000 --> 54:50.000]  Вот.
[54:51.000 --> 54:54.000]  Когда вы смотрите на фьючу, сразу же думаете, что это, наверное,
[54:54.000 --> 54:57.000]  concurrency, вот это вот фьюч, вот эти вот комбинаторы,
[54:57.000 --> 55:01.000]  future promise, парочка, shared state – и понеслась.
[55:02.000 --> 55:04.000]  На самом деле это не так.
[55:04.000 --> 55:09.000]  Фьюч – это какая-то рутина, которая представляет из себя какое-то вычисление.
[55:10.000 --> 55:12.000]  Эту рутину можно полить.
[55:13.000 --> 55:17.000]  Заполить рутину означает попробовать совершить какой-то прогресс.
[55:19.000 --> 55:22.000]  Ну, там, не знаю, например, try read сделать внутри, да?
[55:22.000 --> 55:24.000]  Давайте для примера пока что такое простой пример.
[55:25.000 --> 55:28.000]  Try read внутри пола, который пытается что-то прочитать.
[55:29.000 --> 55:31.000]  Ну, тут тоже есть какая-то структурка пол,
[55:31.000 --> 55:33.000]  которая говорит, что либо вычисление готово,
[55:33.000 --> 55:35.000]  вот, пожалуйста, тебе результат T,
[55:35.000 --> 55:37.000]  либо что мы продолжаем ждать.
[55:38.000 --> 55:40.000]  Результаты этого вычисления.
[55:45.000 --> 55:46.000]  Окей.
[55:46.000 --> 55:49.000]  Это ведь у нас есть какой-то примерчик с async file read.
[55:49.000 --> 55:53.000]  Это структурка, у которой есть выдуманный мной файл handle.
[55:54.000 --> 55:55.000]  Если что, его нигде нет.
[55:55.000 --> 55:58.000]  Просто такой примерчик чистый.
[55:59.000 --> 56:03.000]  Вот, и что я делаю в поле – это если у моего файла есть возможность,
[56:03.000 --> 56:05.000]  ну, если я из своего файла могу что-то прочитать,
[56:05.000 --> 56:09.000]  окей, я читаю в буфер и возвращаю в буфер.
[56:09.000 --> 56:10.000]  Все.
[56:10.000 --> 56:12.000]  Иначе я говорю, ну, мне ничего не получилось прочитать,
[56:12.000 --> 56:14.000]  пока что файл не готов к чтению opening.
[56:14.000 --> 56:15.000]  Все.
[56:15.000 --> 56:16.000]  Все.
[56:16.000 --> 56:20.000]  Вот такая вот штука, которая пытается совершить какой-то прогресс.
[56:20.000 --> 56:22.000]  Выглядит пока что просто, да?
[56:23.000 --> 56:25.000]  Только непонятно какая здесь синхронность получается.
[56:25.000 --> 56:26.000]  Что-то пытаемся полить.
[56:26.000 --> 56:27.000]  Ничего непонятно.
[56:27.000 --> 56:30.000]  Так что вся синхронность при этом на поле нигде пишется?
[56:30.000 --> 56:32.000]  Ну, это потому что слова одинаковые, думаю,
[56:32.000 --> 56:34.000]  пока что поэтому так думаешь.
[56:34.000 --> 56:36.000]  Да, типа епол вспоминаешь.
[56:36.000 --> 56:39.000]  Ну да, вот ты думаешь просто епол,
[56:39.000 --> 56:42.000]  но пока что непонятно, где здесь должен быть епол, да?
[56:42.000 --> 56:43.000]  Ну, такое вопросное.
[56:43.000 --> 56:44.000]  Да, вот пока что...
[56:44.000 --> 56:46.000]  Мы пишем этот реактор и полим.
[56:47.000 --> 56:48.000]  Так, реактор, да.
[56:48.000 --> 56:50.000]  Ну, скоро дойдем до такого понятия.
[56:52.000 --> 56:53.000]  Окей.
[56:53.000 --> 56:54.000]  То, что могли обратить внимание,
[56:54.000 --> 56:56.000]  это то, что future это инертное.
[56:57.000 --> 56:59.000]  Инертное такое, инертный объект.
[56:59.000 --> 57:01.000]  Для того, чтобы они совершали прогресс,
[57:01.000 --> 57:03.000]  их нужно активно полить.
[57:03.000 --> 57:05.000]  То есть нужно говорить, соверши прогресс,
[57:05.000 --> 57:07.000]  соверши прогресс.
[57:07.000 --> 57:08.000]  Это...
[57:08.000 --> 57:09.000]  Team Fortress.
[57:09.000 --> 57:10.000]  Team Fortress, да.
[57:10.000 --> 57:12.000]  Заставлять ее что-то сделать.
[57:13.000 --> 57:14.000]  Да.
[57:16.000 --> 57:18.000]  Во-вторых, вам нужно узнать, что...
[57:18.000 --> 57:20.000]  Нужно знать, что если вы делаете пол,
[57:20.000 --> 57:22.000]  после того, как вернулся пол ready,
[57:22.000 --> 57:24.000]  то в таком случае, раз, он говорит,
[57:24.000 --> 57:27.000]  что поведение будет безопасное,
[57:27.000 --> 57:29.000]  но не определенным стандартом.
[57:29.000 --> 57:32.000]  То есть потому, что это просто определяется тем,
[57:32.000 --> 57:34.000]  как имплементирует future user.
[57:34.000 --> 57:35.000]  То есть у вас может...
[57:35.000 --> 57:36.000]  Ну, самый дефолтный случай,
[57:36.000 --> 57:38.000]  это запаникует просто программа,
[57:38.000 --> 57:41.000]  потому что у вас запаялся фьюч.
[57:41.000 --> 57:43.000]  Просто учитывайте, что если у вас пол ready,
[57:43.000 --> 57:45.000]  в таком случае фьючу дальше не нужно полить.
[57:45.000 --> 57:46.000]  Не логично звучит.
[57:46.000 --> 57:48.000]  Просто что...
[57:48.000 --> 57:50.000]  Знайте, что это...
[57:50.000 --> 57:52.000]  Так работает.
[57:55.000 --> 57:57.000]  Так, вот это вот...
[57:57.000 --> 57:59.000]  Да, вот третий пункт, вы пока что не поймете,
[57:59.000 --> 58:02.000]  он, видимо, одна ошибочка закралась.
[58:02.000 --> 58:05.000]  Сейчас дойдем до AsyncAwait
[58:05.000 --> 58:07.000]  и поймем, что значит третий пункт.
[58:07.000 --> 58:09.000]  Я вам его скажу.
[58:09.000 --> 58:11.000]  Блин, блин, что-то...
[58:11.000 --> 58:13.000]  Как будто, например, непонятно,
[58:13.000 --> 58:15.000]  о чем он должен существовать.
[58:15.000 --> 58:16.000]  Совсем внезапно появляется,
[58:16.000 --> 58:18.000]  но а так это маленький рандомный факт,
[58:18.000 --> 58:20.000]  и нормально окринкается.
[58:20.000 --> 58:22.000]  Что-то хорошо было бы у нас
[58:22.000 --> 58:25.000]  сфотографировали фьюч и другие прочие программы.
[58:25.000 --> 58:27.000]  Так, теперь подумайте,
[58:27.000 --> 58:29.000]  как мы можем имплементировать end-end
[58:29.000 --> 58:31.000]  на двух фьючах.
[58:31.000 --> 58:32.000]  На двух?
[58:32.000 --> 58:34.000]  Да, ну вот есть две фьючи.
[58:34.000 --> 58:36.000]  Вот я утверждаю, что у меня есть такой интерфейс,
[58:36.000 --> 58:38.000]  я уже могу какой-то end-end сделать у них.
[58:38.000 --> 58:40.000]  Значит, вы увидите какие-то упражнения,
[58:40.000 --> 58:42.000]  отлогуете по этим машинам,
[58:42.000 --> 58:44.000]  и на всех их числящих множеств
[58:44.000 --> 58:46.000]  вы напишите вот это.
[58:46.000 --> 58:48.000]  Вот то, что...
[58:48.000 --> 58:50.000]  Так, в общем, мы делаем end-end.
[58:50.000 --> 58:52.000]  Если первое ready,
[58:52.000 --> 58:54.000]  нарезал так,
[58:54.000 --> 58:56.000]  если первый сам,
[58:56.000 --> 58:58.000]  то вообще второй.
[58:58.000 --> 59:00.000]  Иначе он...
[59:00.000 --> 59:02.000]  Что-то такое.
[59:02.000 --> 59:04.000]  Значит, что...
[59:04.000 --> 59:06.000]  Вообще, что означает, что сначала
[59:06.000 --> 59:08.000]  на двух фьючах одну исполняем,
[59:08.000 --> 59:10.000]  потом другую после этого.
[59:10.000 --> 59:12.000]  Вот это вот менее очевидно.
[59:12.000 --> 59:14.000]  Подожди, end-end даже у курса Леповского есть.
[59:14.000 --> 59:16.000]  Пока не понятно, кого мы исполняем,
[59:16.000 --> 59:18.000]  что он...
[59:18.000 --> 59:20.000]  Ну вот полить...
[59:20.000 --> 59:22.000]  Так я же тебе объяснил, смотри.
[59:22.000 --> 59:24.000]  Пол — это попробовать
[59:24.000 --> 59:26.000]  совершить прогресс.
[59:26.000 --> 59:28.000]  Ну, например, там tri-read, как я тебе сказал.
[59:28.000 --> 59:30.000]  Все, я утверждаю, что тебе достаточно этой информации,
[59:30.000 --> 59:32.000]  чтобы пробовать сделать end-end.
[59:32.000 --> 59:34.000]  Окей, что должен end-end понимать
[59:34.000 --> 59:36.000]  Ну, он пытается сначала исполнить одну фьючу,
[59:36.000 --> 59:38.000]  потом, когда она исполнилась,
[59:38.000 --> 59:40.000]  вторую фьючу пытается исполнить.
[59:40.000 --> 59:42.000]  В принципе, он даже решение только что сказал.
[59:44.000 --> 59:46.000]  Просто, ну давайте...
[59:46.000 --> 59:48.000]  С таким интерфейсом,
[59:48.000 --> 59:50.000]  с таким trait-ом фьюча откроем,
[59:50.000 --> 59:52.000]  мы не сразу понятны, что хотим этот end-end.
[59:54.000 --> 59:56.000]  Ну, мне, например, не очевидно,
[59:56.000 --> 59:58.000]  что это означает полить там порядки,
[59:58.000 --> 01:00:00.000]  в котором мы расформили.
[01:00:00.000 --> 01:00:02.000]  Ну, смотрите, просто первая фьюча у нас будет
[01:00:02.000 --> 01:00:04.000]  фьюча A, а вторая — это фьюча B.
[01:00:04.000 --> 01:00:06.000]  Ну, у нас простейшее такое будет end-end.
[01:00:06.000 --> 01:00:08.000]  Он просто будет возвращаться
[01:00:08.000 --> 01:00:10.000]  с успехом
[01:00:10.000 --> 01:00:12.000]  только тогда, когда у него
[01:00:12.000 --> 01:00:14.000]  получилось заполнить обе фьючи.
[01:00:14.000 --> 01:00:16.000]  Ну, в таком случае,
[01:00:16.000 --> 01:00:18.000]  когда нас будут конструировать, мы будем получать
[01:00:18.000 --> 01:00:20.000]  две фьючи на ход.
[01:00:20.000 --> 01:00:22.000]  Соответственно, у нас здесь будет сам фьюча A
[01:00:22.000 --> 01:00:24.000]  и какая-то фьюча B.
[01:00:24.000 --> 01:00:26.000]  Мы то, что будем делать
[01:00:26.000 --> 01:00:28.000]  в поле — это смотреть на
[01:00:28.000 --> 01:00:30.000]  первую фьючу, если она
[01:00:30.000 --> 01:00:32.000]  еще у нас есть, то есть мы еще не закончили
[01:00:32.000 --> 01:00:34.000]  ее исполнять,
[01:00:34.000 --> 01:00:36.000]  то пытаемся ее заполить.
[01:00:36.000 --> 01:00:38.000]  Если ready, то в таком случае
[01:00:38.000 --> 01:00:40.000]  мы take-ом текущую фьючу
[01:00:40.000 --> 01:00:42.000]  и переходим ко второй. Иначе
[01:00:42.000 --> 01:00:44.000]  мы возвращаем пол pending, и когда
[01:00:44.000 --> 01:00:46.000]  нам в следующий раз придут, мы пробуем опять
[01:00:46.000 --> 01:00:48.000]  первую фьючу заполить. То есть
[01:00:48.000 --> 01:00:50.000]  что-то такое достаточно вроде бы простое.
[01:00:50.000 --> 01:00:52.000]  Просто полим первую фьючу, пока она не закончится,
[01:00:52.000 --> 01:00:54.000]  потом мы ее выкидываем, полим вторую.
[01:00:54.000 --> 01:00:56.000]  Вообще тоже будет понятно, что мы требуем вообще
[01:00:56.000 --> 01:00:58.000]  говоря, ну, а вот
[01:00:58.000 --> 01:01:00.000]  вот это было непонятно.
[01:01:00.000 --> 01:01:02.000]  А, ну, output, да. Я, конечно,
[01:01:02.000 --> 01:01:04.000]  про простейший mdent здесь говорил.
[01:01:04.000 --> 01:01:06.000]  Ну непонятно, типа, просто ты не сказал
[01:01:06.000 --> 01:01:08.000]  вот это ограничение, зайду эти патчи.
[01:01:08.000 --> 01:01:10.000]  Ну, окей, да, хорошо. Потом допишу.
[01:01:12.000 --> 01:01:14.000]  Так, ну, утверждается,
[01:01:14.000 --> 01:01:16.000]  что вроде бы вы должны понимать дальше, ну,
[01:01:16.000 --> 01:01:18.000]  как все комбинаторы примерно делают. Ну, если
[01:01:18.000 --> 01:01:20.000]  там все, ну, там типа all, ну, давайте
[01:01:20.000 --> 01:01:22.000]  все по полям, до тех пор, пока они не закончатся.
[01:01:22.000 --> 01:01:24.000]  Ну, first-off поинтересен, конечно.
[01:01:24.000 --> 01:01:26.000]  Ну,
[01:01:26.000 --> 01:01:28.000]  ну, first-off, ну, хорошо,
[01:01:28.000 --> 01:01:30.000]  да. Мы не можем
[01:01:30.000 --> 01:01:32.000]  полить все подряд, а хотя можем
[01:01:32.000 --> 01:01:34.000]  полить все подряд просто.
[01:01:38.000 --> 01:01:40.000]  Напомню, first-off возвращает же ошибку,
[01:01:40.000 --> 01:01:42.000]  либо первую ошибку, либо все результаты.
[01:01:42.000 --> 01:01:44.000]  Ну, может это all.
[01:01:44.000 --> 01:01:46.000]  All подручает вот либо все результаты, либо
[01:01:46.000 --> 01:01:48.000]  первую ошибку, а first-off либо
[01:01:48.000 --> 01:01:50.000]  либо первые результаты, либо
[01:01:50.000 --> 01:01:52.000]  последние ошибки.
[01:01:52.000 --> 01:01:54.000]  Ну, наверное, пытаемся все
[01:01:54.000 --> 01:01:56.000]  заполить.
[01:01:56.000 --> 01:01:58.000]  Да, и просто до тех пор,
[01:01:58.000 --> 01:02:00.000]  пока у нас не появится
[01:02:00.000 --> 01:02:02.000]  результат номер один, либо
[01:02:02.000 --> 01:02:04.000]  ну, то есть префикс у нас должен заполниться
[01:02:04.000 --> 01:02:06.000]  до какого-то результата, либо все ошибки.
[01:02:06.000 --> 01:02:08.000]  И так правильно понять?
[01:02:08.000 --> 01:02:10.000]  Не, ну, я подумал так, что мы ходим по кругу
[01:02:10.000 --> 01:02:12.000]  по future, ну, типа находим какое-то состояние
[01:02:12.000 --> 01:02:14.000]  нашего future, которое мы хотим заполить
[01:02:14.000 --> 01:02:16.000]  в следующий раз. И так просто по кругу,
[01:02:16.000 --> 01:02:18.000]  пока какая-нибудь не закончится.
[01:02:18.000 --> 01:02:20.000]  В общем, вроде понятно, даже нашли здесь комбинаторы
[01:02:20.000 --> 01:02:22.000]  этих наших future,
[01:02:22.000 --> 01:02:24.000]  которых, кстати говоря, еще нет
[01:02:24.000 --> 01:02:26.000]  даже примерно ничего, но мы уже
[01:02:26.000 --> 01:02:28.000]  нашли здесь комбинаты.
[01:02:28.000 --> 01:02:30.000]  Ага, все, сейчас.
[01:02:30.000 --> 01:02:32.000]  Async and wait.
[01:02:32.000 --> 01:02:34.000]  Не, не, сейчас они
[01:02:34.000 --> 01:02:36.000]  пока что нам пригодятся.
[01:02:36.000 --> 01:02:38.000]  Так, хорошо, мы вынимаем
[01:02:38.000 --> 01:02:40.000]  в простых терминах,
[01:02:40.000 --> 01:02:42.000]  что значит
[01:02:42.000 --> 01:02:44.000]  rastovaya future.
[01:02:44.000 --> 01:02:46.000]  Ну, подождите, мы хотим писать
[01:02:46.000 --> 01:02:48.000]  код что-то вроде такого.
[01:02:48.000 --> 01:02:50.000]  Да, вот здесь,
[01:02:50.000 --> 01:02:52.000]  кстати говоря,
[01:02:52.000 --> 01:02:54.000]  наверное, я
[01:02:54.000 --> 01:02:56.000]  сделаю так.
[01:02:56.000 --> 01:02:58.000]  Я просто...
[01:02:58.000 --> 01:03:00.000]  До этого был план другой.
[01:03:00.000 --> 01:03:02.000]  Чуть-чуть.
[01:03:02.000 --> 01:03:04.000]  Но я его поменяю прямо по ходу дела.
[01:03:04.000 --> 01:03:06.000]  Давайте мы посмотрим
[01:03:06.000 --> 01:03:08.000]  на один примерчик.
[01:03:12.000 --> 01:03:14.000]  Вам не видно?
[01:03:14.000 --> 01:03:16.000]  Хорошо, сейчас.
[01:03:16.000 --> 01:03:18.000]  И еще.
[01:03:18.000 --> 01:03:20.000]  Еще, пожалуйста.
[01:03:20.000 --> 01:03:22.000]  Еще.
[01:03:22.000 --> 01:03:24.000]  Так, сейчас.
[01:03:24.000 --> 01:03:26.000]  Ну, вот
[01:03:26.000 --> 01:03:28.000]  примерно так.
[01:03:28.000 --> 01:03:30.000]  Смотрите, давайте мы посмотрим даже
[01:03:30.000 --> 01:03:32.000]  на такой примерчик. Всем знаком
[01:03:32.000 --> 01:03:34.000]  эхо-сервер. Он написан на токе.
[01:03:34.000 --> 01:03:36.000]  Я просто хочу вам показать, как это выглядит.
[01:03:36.000 --> 01:03:38.000]  По идее, это мы должны посмотреть через пару
[01:03:38.000 --> 01:03:40.000]  десятков слайдов, но мы посмотрим сейчас.
[01:03:40.000 --> 01:03:42.000]  Для того, чтобы чуть-чуть
[01:03:42.000 --> 01:03:44.000]  больше проникнуться. Вы же помните
[01:03:44.000 --> 01:03:46.000]  файберное эхо?
[01:03:46.000 --> 01:03:48.000]  У Дюповского.
[01:03:48.000 --> 01:03:50.000]  Ну, вот то-то и оно.
[01:03:50.000 --> 01:03:52.000]  Вообще, токел — это прям планировщик
[01:03:52.000 --> 01:03:54.000]  ГО, файберы как в ГО.
[01:03:54.000 --> 01:03:56.000]  Это ГО.
[01:03:56.000 --> 01:03:58.000]  Вы можете просто взять и в сейф-расте
[01:03:58.000 --> 01:04:00.000]  пользоваться ГОшкой.
[01:04:04.000 --> 01:04:06.000]  Нет файберного эхо?
[01:04:06.000 --> 01:04:08.000]  Да, в результате
[01:04:08.000 --> 01:04:10.000]  переделывания курса, задачи временно
[01:04:10.000 --> 01:04:12.000]  потерялись.
[01:04:12.000 --> 01:04:14.000]  Ну, жалко. Такая хорошая задача, моя любимая.
[01:04:14.000 --> 01:04:16.000]  Ну, она скучная
[01:04:16.000 --> 01:04:18.000]  из одной по точности.
[01:04:18.000 --> 01:04:20.000]  Не знаю, зато она прекрасно
[01:04:20.000 --> 01:04:22.000]  показывает, как все работает.
[01:04:22.000 --> 01:04:24.000]  Давайте посмотрим. Это как раз то,
[01:04:24.000 --> 01:04:26.000]  что вы писали в файберном эхо.
[01:04:26.000 --> 01:04:28.000]  По крайней мере, в прошлом году должны были, да?
[01:04:28.000 --> 01:04:30.000]  Сейчас мы какой-то
[01:04:30.000 --> 01:04:32.000]  нагрузки наблюдаем.
[01:04:32.000 --> 01:04:34.000]  Окей, ну вот у нас
[01:04:34.000 --> 01:04:36.000]  создается какой-то
[01:04:36.000 --> 01:04:38.000]  лисенер, которому мы биндимся.
[01:04:38.000 --> 01:04:40.000]  Делаем эвейт на нем.
[01:04:40.000 --> 01:04:42.000]  Эвейт можно вспомнить
[01:04:42.000 --> 01:04:44.000]  из каких-нибудь
[01:04:44.000 --> 01:04:46.000]  более таких
[01:04:46.000 --> 01:04:48.000]  висковых языков программирования.
[01:04:48.000 --> 01:04:50.000]  Вы знаете какой-нибудь язык
[01:04:50.000 --> 01:04:52.000]  программирования, в котором есть асимка
[01:04:52.000 --> 01:04:54.000]  эвейт? Котлин, например.
[01:04:54.000 --> 01:04:56.000]  Сиша.
[01:04:56.000 --> 01:04:58.000]  Ну и JavaScript
[01:04:58.000 --> 01:05:00.000]  сойдет, в принципе.
[01:05:00.000 --> 01:05:02.000]  Эвейт мы что-то
[01:05:02.000 --> 01:05:04.000]  асинхронно ждем.
[01:05:04.000 --> 01:05:06.000]  Мы ждем, пока у нас что-то забиндется.
[01:05:06.000 --> 01:05:08.000]  Потом мы в цикле accept
[01:05:08.000 --> 01:05:10.000]  асинхронно ждем всех лисенеров.
[01:05:10.000 --> 01:05:12.000]  Здесь Tokyo Spawn это означает
[01:05:12.000 --> 01:05:14.000]  создать какую-то
[01:05:14.000 --> 01:05:16.000]  какой-то файбер,
[01:05:16.000 --> 01:05:18.000]  к которому мы будем вот такие вот штуки делать дальше.
[01:05:18.000 --> 01:05:20.000]  У нас здесь
[01:05:20.000 --> 01:05:22.000]  создается буфер.
[01:05:22.000 --> 01:05:24.000]  Потом мы в цикле читаем асинхронно.
[01:05:24.000 --> 01:05:26.000]  Асинхронно пишем.
[01:05:28.000 --> 01:05:30.000]  Очень просто выйдет код.
[01:05:30.000 --> 01:05:32.000]  И в каждой точке эвейт
[01:05:32.000 --> 01:05:34.000]  на самом деле наш код
[01:05:34.000 --> 01:05:36.000]  начинает асинхронно
[01:05:36.000 --> 01:05:38.000]  ждать, пока он что-то
[01:05:38.000 --> 01:05:40.000]  начинает делать.
[01:05:40.000 --> 01:05:42.000]  В принципе, если вы были на курсе
[01:05:42.000 --> 01:05:44.000]  конкуренции Рома Липовского и писали эхо,
[01:05:44.000 --> 01:05:46.000]  то в таком случае там, по сути,
[01:05:46.000 --> 01:05:48.000]  итоговый эхо сервер, который вы писали,
[01:05:48.000 --> 01:05:50.000]  выглядел абсолютно точно так же.
[01:05:50.000 --> 01:05:52.000]  То есть
[01:05:52.000 --> 01:05:54.000]  за исключением того, что вы писали
[01:05:54.000 --> 01:05:56.000]  на C++, что там эвейт, не было
[01:05:56.000 --> 01:05:58.000]  ничего слова.
[01:05:58.000 --> 01:06:00.000]  Я бы сказал, что да,
[01:06:00.000 --> 01:06:02.000]  он все-таки выглядел не так же,
[01:06:02.000 --> 01:06:04.000]  и он сейчас больше похож на крутимный,
[01:06:04.000 --> 01:06:06.000]  да-да-да.
[01:06:06.000 --> 01:06:08.000]  У нас тоже будут
[01:06:08.000 --> 01:06:10.000]  почти карутины,
[01:06:10.000 --> 01:06:12.000]  скопчика-генераторы,
[01:06:12.000 --> 01:06:14.000]  семикарутины.
[01:06:14.000 --> 01:06:16.000]  Вот так вот это все выглядит.
[01:06:16.000 --> 01:06:18.000]  Понятно ли примерно,
[01:06:18.000 --> 01:06:20.000]  чего мы хотим добиться в идеальном мире,
[01:06:20.000 --> 01:06:22.000]  чтобы так вот мы писали?
[01:06:22.000 --> 01:06:24.000]  Вся остальная часть лекции
[01:06:24.000 --> 01:06:26.000]  мы будем разбираться, а как это внутри устроено?
[01:06:26.000 --> 01:06:28.000]  А, и у нас ключевое слово
[01:06:28.000 --> 01:06:30.000]  асинх есть посреди?
[01:06:30.000 --> 01:06:32.000]  Да, асинх, кстати говоря,
[01:06:32.000 --> 01:06:34.000]  нужно, конечно, выбрать ключевое слово асинх.
[01:06:34.000 --> 01:06:36.000]  Компилятор бы сам просто уводил,
[01:06:36.000 --> 01:06:38.000]  что это функция асинхронная.
[01:06:38.000 --> 01:06:40.000]  Но мы же хотим, чтобы
[01:06:40.000 --> 01:06:42.000]  вот color is your function, есть, например, статья,
[01:06:42.000 --> 01:06:44.000]  мы хотим отмечать функции красного цвета,
[01:06:44.000 --> 01:06:46.000]  которые асинхронные.
[01:06:46.000 --> 01:06:48.000]  Ну и вот
[01:06:48.000 --> 01:06:50.000]  в расти асинх существует для того, чтобы
[01:06:50.000 --> 01:06:52.000]  отмечать синхронные блоки,
[01:06:52.000 --> 01:06:54.000]  соответственно, синхронные
[01:06:54.000 --> 01:06:56.000]  асинхронные блоки,
[01:06:56.000 --> 01:06:58.000]  в первую очередь.
[01:06:58.000 --> 01:07:00.000]  Вот.
[01:07:00.000 --> 01:07:02.000]  Ну давайте посмотрим
[01:07:02.000 --> 01:07:04.000]  такой примерчик.
[01:07:04.000 --> 01:07:06.000]  Ну как мы будем писать вот такой вот код
[01:07:06.000 --> 01:07:08.000]  в таких вот фьючах, которые я вам выдал?
[01:07:08.000 --> 01:07:10.000]  Что за ерунда?
[01:07:14.000 --> 01:07:16.000]  Ну полить, конечно, полить,
[01:07:16.000 --> 01:07:18.000]  но утверждается.
[01:07:18.000 --> 01:07:20.000]  Во-первых, async await
[01:07:20.000 --> 01:07:22.000]  это синтастический сахар для компилятора,
[01:07:22.000 --> 01:07:24.000]  который генерирует какой-то стейт машины.
[01:07:24.000 --> 01:07:26.000]  Во-первых, когда вы пишете async fn
[01:07:26.000 --> 01:07:28.000]  и какой-то возвращаемый тип,
[01:07:28.000 --> 01:07:30.000]  компилятор на самом деле это превращает
[01:07:30.000 --> 01:07:32.000]  вот в это.
[01:07:34.000 --> 01:07:36.000]  То есть, на самом деле он превращает
[01:07:36.000 --> 01:07:38.000]  это в синхронную функцию,
[01:07:38.000 --> 01:07:40.000]  которая возвращает какую-то стейт машину.
[01:07:42.000 --> 01:07:44.000]  Какую-то фьючу.
[01:07:44.000 --> 01:07:46.000]  Ну, как плюсов там
[01:07:46.000 --> 01:07:48.000]  сложно сказать, потому что плюсов
[01:07:48.000 --> 01:07:50.000]  настолько много,
[01:07:50.000 --> 01:07:52.000]  большой зоопарк,
[01:07:52.000 --> 01:07:54.000]  всякие возможности.
[01:07:54.000 --> 01:07:56.000]  Ну, я не знаю, давайте так, как
[01:07:56.000 --> 01:07:58.000]  и Рома Юлиповского.
[01:07:58.000 --> 01:08:00.000]  Придем к единому знаменателю.
[01:08:04.000 --> 01:08:06.000]  Ну, async read file
[01:08:06.000 --> 01:08:08.000]  напоминаю,
[01:08:08.000 --> 01:08:10.000]  это какая-то у нас фьюча, которая возвращала
[01:08:10.000 --> 01:08:12.000]  стринг в качестве результата пола.
[01:08:12.000 --> 01:08:14.000]  Так?
[01:08:14.000 --> 01:08:16.000]  На самом деле это превращается
[01:08:16.000 --> 01:08:18.000]  в что-то такое. Там внутри фьюча
[01:08:18.000 --> 01:08:20.000]  сидит, импл фьюча.
[01:08:20.000 --> 01:08:22.000]  То есть, async read file
[01:08:22.000 --> 01:08:24.000]  это импл фьюча, где output это
[01:08:24.000 --> 01:08:26.000]  на самом деле.
[01:08:28.000 --> 01:08:30.000]  А во-вторых,
[01:08:30.000 --> 01:08:32.000]  наверное, так будет даже понятней, чем на
[01:08:32.000 --> 01:08:34.000]  прошлом слайде.
[01:08:34.000 --> 01:08:36.000]  Внутри
[01:08:36.000 --> 01:08:38.000]  находится асинхронный блок.
[01:08:38.000 --> 01:08:40.000]  Это какой-то лишний слайд.
[01:08:40.000 --> 01:08:42.000]  Точнее, не лишний, он должен
[01:08:42.000 --> 01:08:44.000]  просто позже находиться.
[01:08:44.000 --> 01:08:46.000]  Это то, что происходит
[01:08:46.000 --> 01:08:48.000]  на самом деле.
[01:08:48.000 --> 01:08:50.000]  Async слова убирается,
[01:08:50.000 --> 01:08:52.000]  вместо этого появляется
[01:08:52.000 --> 01:08:54.000]  импл фьюча.
[01:08:56.000 --> 01:08:58.000]  Внутри фигачится асинхронный блок,
[01:08:58.000 --> 01:09:00.000]  и внутри него помещается
[01:09:00.000 --> 01:09:02.000]  то, что внутри функции находилось.
[01:09:02.000 --> 01:09:04.000]  А это первый шаг,
[01:09:04.000 --> 01:09:06.000]  который делает компилятор.
[01:09:06.000 --> 01:09:08.000]  Второй, он строит стейт-машину
[01:09:08.000 --> 01:09:10.000]  внутри, по которой он
[01:09:10.000 --> 01:09:12.000]  ходит.
[01:09:12.000 --> 01:09:14.000]  Во-первых, у нас есть start state. Это означает то,
[01:09:14.000 --> 01:09:16.000]  что мы еще не начали исполняться вообще.
[01:09:18.000 --> 01:09:20.000]  Мы ни разу не вызвали функцию.
[01:09:20.000 --> 01:09:22.000]  Ни разу не вызвали фьючу,
[01:09:22.000 --> 01:09:24.000]  которая вернула эту функцию.
[01:09:24.000 --> 01:09:26.000]  Это start state.
[01:09:26.000 --> 01:09:28.000]  Обратите внимание,
[01:09:28.000 --> 01:09:30.000]  что мы сделаем в этой функции.
[01:09:30.000 --> 01:09:32.000]  Мы пытаемся прочитать из foo.
[01:09:32.000 --> 01:09:34.000]  Потом, если у нас длина
[01:09:34.000 --> 01:09:36.000]  недостаточная, мы читаем еще из
[01:09:36.000 --> 01:09:38.000]  бара и консоциируем что-то.
[01:09:38.000 --> 01:09:40.000]  Когда мы вызываем экземпл,
[01:09:40.000 --> 01:09:42.000]  то нам возвращается
[01:09:42.000 --> 01:09:44.000]  стейт-машина в состоянии start state
[01:09:44.000 --> 01:09:46.000]  и никакая строча кода тут
[01:09:46.000 --> 01:09:48.000]  еще не выполнилась.
[01:09:48.000 --> 01:09:50.000]  Когда возвращается какая-то фьюча,
[01:09:50.000 --> 01:09:52.000]  она исключительно лэйзи, она ничего не делает.
[01:09:52.000 --> 01:09:54.000]  Для того, чтобы она полилась,
[01:09:54.000 --> 01:09:56.000]  тебе нужен экзекют. Мы до этого еще дойдем.
[01:10:00.000 --> 01:10:02.000]  Создается вот такая
[01:10:02.000 --> 01:10:04.000]  стейт-машинка.
[01:10:04.000 --> 01:10:06.000]  Во-первых, у нас есть start.
[01:10:06.000 --> 01:10:08.000]  После того, как мы пройдем start,
[01:10:08.000 --> 01:10:10.000]  у нас будет какой-то
[01:10:10.000 --> 01:10:12.000]  синхронный код, контент.
[01:10:12.000 --> 01:10:14.000]  Мы создадим какую-то фьючу.
[01:10:14.000 --> 01:10:16.000]  Потом мы пойдем какую-то фьючу исполнять.
[01:10:16.000 --> 01:10:18.000]  У нас есть weighting on foo.txt.
[01:10:18.000 --> 01:10:20.000]  Внутри будет такая структурка,
[01:10:20.000 --> 01:10:22.000]  которая означает ждать на foo.
[01:10:22.000 --> 01:10:24.000]  Потом то же самое.
[01:10:24.000 --> 01:10:26.000]  Либо мы переходим к end state,
[01:10:26.000 --> 01:10:28.000]  либо мы зайдем в bar.
[01:10:28.000 --> 01:10:30.000]  В таком случае у нас следующий идет
[01:10:30.000 --> 01:10:32.000]  стейт. Нужно было рядом, наверное,
[01:10:32.000 --> 01:10:34.000]  поместить кусочки кода.
[01:10:38.000 --> 01:10:40.000]  Примерно так выглядят эти структурки.
[01:10:40.000 --> 01:10:42.000]  Внутри start state он сделал
[01:10:42.000 --> 01:10:44.000]  просто аргумент входной функции,
[01:10:44.000 --> 01:10:46.000]  которая меняет.
[01:10:46.000 --> 01:10:48.000]  Внутри weighting on foo.txt
[01:10:48.000 --> 01:10:50.000]  находится только то, что важно
[01:10:50.000 --> 01:10:52.000]  между start state и weighting on foo.txt.
[01:10:52.000 --> 01:10:54.000]  Это min.len и foo.txt.
[01:10:54.000 --> 01:10:56.000]  Фьючу, которую мы полили.
[01:10:58.000 --> 01:11:00.000]  И bar.state
[01:11:00.000 --> 01:11:02.000]  это контент,
[01:11:02.000 --> 01:11:04.000]  который мы получили от foo.txt.
[01:11:04.000 --> 01:11:06.000]  И future.bar.txt.
[01:11:10.000 --> 01:11:12.000]  Вот как будет выглядеть наша
[01:11:12.000 --> 01:11:14.000]  страндишина.
[01:11:14.000 --> 01:11:16.000]  Обратите внимание на loop.
[01:11:16.000 --> 01:11:18.000]  Я сейчас объясню, зачем он нужен.
[01:11:18.000 --> 01:11:20.000]  Он нужен для того, чтобы
[01:11:20.000 --> 01:11:22.000]  если вы успешно
[01:11:22.000 --> 01:11:24.000]  заполили с первого раза фьючу,
[01:11:24.000 --> 01:11:26.000]  чтобы вы сразу перешли дальше
[01:11:26.000 --> 01:11:28.000]  в синхронную подделку.
[01:11:28.000 --> 01:11:30.000]  Вы можете его не писать,
[01:11:30.000 --> 01:11:32.000]  хуже от этого не станет,
[01:11:32.000 --> 01:11:34.000]  но полм больше раз придется вызвать.
[01:11:34.000 --> 01:11:36.000]  В таком случае.
[01:11:36.000 --> 01:11:38.000]  Вот.
[01:11:38.000 --> 01:11:40.000]  Потом вы можете self.
[01:11:40.000 --> 01:11:42.000]  Ну и в зависимости от того,
[01:11:42.000 --> 01:11:44.000]  какой у вас self, вы выполняете
[01:11:44.000 --> 01:11:46.000]  соответствующий кусочек кода.
[01:11:46.000 --> 01:11:48.000]  Вот как эти кусочки кода выглядят.
[01:11:48.000 --> 01:11:50.000]  Во-первых, есть start.
[01:11:50.000 --> 01:11:52.000]  Start, как вы видите, создает какую-то фьючу.
[01:11:52.000 --> 01:11:54.000]  Нашу потом
[01:11:54.000 --> 01:11:56.000]  weighting on foo.txt state
[01:11:56.000 --> 01:11:58.000]  создает собственную структурку
[01:11:58.000 --> 01:12:00.000]  и обновляет нас таким вот state.
[01:12:00.000 --> 01:12:02.000]  Все. То есть мы просто создали фьючу.
[01:12:02.000 --> 01:12:04.000]  Здесь вот.
[01:12:04.000 --> 01:12:06.000]  И self у нас обновился.
[01:12:06.000 --> 01:12:08.000]  Вот в текущем состоянии,
[01:12:08.000 --> 01:12:10.000]  что он нас ждет foo.txt.
[01:12:10.000 --> 01:12:12.000]  И внутри состояния
[01:12:12.000 --> 01:12:14.000]  сидит minlan и, собственно, сама foo.txt.
[01:12:16.000 --> 01:12:18.000]  Потом есть weighting on foo.txt
[01:12:20.000 --> 01:12:22.000]  state. Здесь интересно.
[01:12:22.000 --> 01:12:24.000]  У нас же фьюча. Мы сейчас ждем на фьюча.
[01:12:24.000 --> 01:12:26.000]  Поэтому когда нам говорят,
[01:12:26.000 --> 01:12:28.000]  что наши верхние уровни, вот этот фьюч,
[01:12:28.000 --> 01:12:30.000]  который мы сейчас пытаемся сделать,
[01:12:30.000 --> 01:12:32.000]  она сейчас пытается
[01:12:32.000 --> 01:12:34.000]  заполить наш foo.txt.
[01:12:34.000 --> 01:12:36.000]  Если не получилось,
[01:12:36.000 --> 01:12:38.000]  то она говорит, все, у меня ничего не получилось.
[01:12:38.000 --> 01:12:40.000]  Если получилось, в таком случае
[01:12:40.000 --> 01:12:42.000]  она совершает прогресс дальше,
[01:12:42.000 --> 01:12:44.000]  говорит, что она переходит weighting on bar.txt
[01:12:44.000 --> 01:12:46.000]  либо в self.end.
[01:12:46.000 --> 01:12:48.000]  Ну, в зависимости от того, как получится дальше.
[01:12:48.000 --> 01:12:50.000]  И возвращает либо
[01:12:50.000 --> 01:12:52.000]  poll ready, либо пытается еще заполить
[01:12:52.000 --> 01:12:54.000]  on bar.
[01:12:56.000 --> 01:12:58.000]  И затем еще есть
[01:12:58.000 --> 01:13:00.000]  пендинг
[01:13:00.000 --> 01:13:02.000]  weighting on foo.txt.
[01:13:02.000 --> 01:13:04.000]  Но это уже просто.
[01:13:04.000 --> 01:13:06.000]  Если пендинг, то пендинг, иначе мы
[01:13:06.000 --> 01:13:08.000]  переходим в end state и после этого
[01:13:08.000 --> 01:13:10.000]  poll ready. Возвращаем.
[01:13:12.000 --> 01:13:14.000]  Ну и в end просто паникуем.
[01:13:14.000 --> 01:13:16.000]  То есть идея в том, что
[01:13:16.000 --> 01:13:18.000]  мы разбиваем нашу функцию на кусочки,
[01:13:18.000 --> 01:13:20.000]  где у нас
[01:13:20.000 --> 01:13:22.000]  каждая точка это либо
[01:13:22.000 --> 01:13:24.000]  начало функции, либо конец функции,
[01:13:24.000 --> 01:13:26.000]  либо фьюча, о которой мы ждем.
[01:13:26.000 --> 01:13:28.000]  И когда нас полят, то мы пытаемся
[01:13:28.000 --> 01:13:30.000]  заполить текущую фьючу,
[01:13:30.000 --> 01:13:32.000]  на которую мы ждем.
[01:13:32.000 --> 01:13:34.000]  Либо совершить прогресс, начиная
[01:13:34.000 --> 01:13:36.000]  со старта функции.
[01:13:36.000 --> 01:13:38.000]  То есть это просто способ создать
[01:13:38.000 --> 01:13:40.000]  state машину.
[01:13:40.000 --> 01:13:42.000]  В плюсах тоже, когда вы смотрели
[01:13:42.000 --> 01:13:44.000]  на картины в плюсах, по сути там точно так же
[01:13:44.000 --> 01:13:46.000]  устроена какая-то структурка,
[01:13:46.000 --> 01:13:48.000]  которая содержит
[01:13:48.000 --> 01:13:50.000]  текущее состояние
[01:13:50.000 --> 01:13:52.000]  стека.
[01:13:52.000 --> 01:13:54.000]  Да, только это
[01:13:54.000 --> 01:13:56.000]  конкретно.
[01:13:56.000 --> 01:13:58.000]  Да, поэтому это по сути то же самое.
[01:14:00.000 --> 01:14:02.000]  Вот. Поэтому после того, как мы
[01:14:02.000 --> 01:14:04.000]  все это сгеировали, тада,
[01:14:04.000 --> 01:14:06.000]  вот так вот это примерно будет выглядеть.
[01:14:06.000 --> 01:14:08.000]  Функция example теперь будет не asyncfnExample,
[01:14:08.000 --> 01:14:10.000]  которая возвращает string.
[01:14:10.000 --> 01:14:12.000]  На самом деле это будет какая-то синхронная
[01:14:12.000 --> 01:14:14.000]  функция example, которая возвращает
[01:14:14.000 --> 01:14:16.000]  state машину, которая является
[01:14:16.000 --> 01:14:18.000]  фьючей, собственно. Ее можно полить.
[01:14:18.000 --> 01:14:20.000]  Все. То есть она на самом деле
[01:14:20.000 --> 01:14:22.000]  такая, но быстренькая. Просто
[01:14:22.000 --> 01:14:24.000]  создает фьючу и закончилось все.
[01:14:24.000 --> 01:14:26.000]  Спасибо компиратору за то, что сгенерировал
[01:14:26.000 --> 01:14:28.000]  за нас весь этот код.
[01:14:28.000 --> 01:14:30.000]  В общем, если вы создаете какую-то синхронную
[01:14:30.000 --> 01:14:32.000]  функцию и даже там сделаете let
[01:14:32.000 --> 01:14:34.000]  не знаю, x равняется
[01:14:34.000 --> 01:14:36.000]  значению синхронной функции
[01:14:36.000 --> 01:14:38.000]  без await,
[01:14:38.000 --> 01:14:40.000]  в таком случае у вас x без это имеется какой-то
[01:14:40.000 --> 01:14:42.000]  тип какой-то фьючей.
[01:14:44.000 --> 01:14:46.000]  Вот.
[01:14:48.000 --> 01:14:50.000]  Ну теперь давайте
[01:14:50.000 --> 01:14:52.000]  вот это вот очень важный такой
[01:14:52.000 --> 01:14:54.000]  checkpoint. Вы понимаете,
[01:14:54.000 --> 01:14:56.000]  что значит тут разбить
[01:14:56.000 --> 01:14:58.000]  функцию на state машину и создать
[01:14:58.000 --> 01:15:00.000]  из функции синхронной фьючу другую.
[01:15:02.000 --> 01:15:04.000]  Здесь еще важный концепт.
[01:15:04.000 --> 01:15:06.000]  Вот те фьючи, которые мы будем писать,
[01:15:06.000 --> 01:15:08.000]  ну, все синхронные
[01:15:08.000 --> 01:15:10.000]  функции, они представляют в себя
[01:15:10.000 --> 01:15:12.000]  функции, которые собирают
[01:15:12.000 --> 01:15:14.000]  другие фьючи. Просто полят
[01:15:14.000 --> 01:15:16.000]  другие фьючи. Но есть же какие-то самые
[01:15:16.000 --> 01:15:18.000]  низкоуровневые фьючи,
[01:15:18.000 --> 01:15:20.000]  которые дальше разбивать нельзя.
[01:15:20.000 --> 01:15:22.000]  Например, те не из сокета.
[01:15:22.000 --> 01:15:24.000]  А вот их уже предоставляет run time,
[01:15:24.000 --> 01:15:26.000]  который вы напишете.
[01:15:26.000 --> 01:15:28.000]  Мы о нем чуть-чуть дальше поговорим.
[01:15:30.000 --> 01:15:32.000]  То есть это лиффьючи, вы их пишете
[01:15:32.000 --> 01:15:34.000]  руками или вы пользуетесь готовыми
[01:15:34.000 --> 01:15:36.000]  run time-ами вроде Tokyo.
[01:15:36.000 --> 01:15:38.000]  И в итоге они там
[01:15:38.000 --> 01:15:40.000]  работают с вашим async'ом.
[01:15:40.000 --> 01:15:42.000]  Кстати, еще тоже пока вспомнил,
[01:15:42.000 --> 01:15:44.000]  async await чем прекрасен,
[01:15:44.000 --> 01:15:46.000]  он же
[01:15:46.000 --> 01:15:48.000]  в Rust вы размазили,
[01:15:48.000 --> 01:15:50.000]  он был предназначен
[01:15:50.000 --> 01:15:52.000]  для написания браузерного движка
[01:15:52.000 --> 01:15:54.000]  преимущественно.
[01:15:54.000 --> 01:15:56.000]  И дело в том, что там все
[01:15:56.000 --> 01:15:58.000]  однопоточное внутри браузера.
[01:15:58.000 --> 01:16:00.000]  Ну, я имею в виду не
[01:16:00.000 --> 01:16:02.000]  прям все, а вкладки.
[01:16:02.000 --> 01:16:04.000]  И внутри вкладок вам хочется
[01:16:04.000 --> 01:16:06.000]  тоже асинхронность, но вы же
[01:16:06.000 --> 01:16:08.000]  однопоточные. И тут
[01:16:08.000 --> 01:16:10.000]  появляется какое-то желание
[01:16:10.000 --> 01:16:12.000]  воспользоваться асинхронностью.
[01:16:12.000 --> 01:16:14.000]  Это как раз преимущество
[01:16:14.000 --> 01:16:16.000]  асинхронности Rust, за счет того,
[01:16:16.000 --> 01:16:18.000]  что он выросло в таком браузерном мире,
[01:16:18.000 --> 01:16:20.000]  в том числе, оно
[01:16:20.000 --> 01:16:22.000]  работает даже в новости D.
[01:16:22.000 --> 01:16:24.000]  То есть вы можете на Embedded запускать
[01:16:24.000 --> 01:16:26.000]  асинхронный код.
[01:16:26.000 --> 01:16:28.000]  Ну, оно даже понятно почему, потому что у вас
[01:16:28.000 --> 01:16:30.000]  это просто какая-то стоит машина,
[01:16:30.000 --> 01:16:32.000]  которая генерируется компилятором.
[01:16:32.000 --> 01:16:34.000]  И вот тоже тут
[01:16:34.000 --> 01:16:36.000]  могу сказать небольшую историю
[01:16:36.000 --> 01:16:38.000]  такого появления фьюч.
[01:16:38.000 --> 01:16:40.000]  Там были в самом начале фьючи 01, потом 02,
[01:16:40.000 --> 01:16:42.000]  потом 03. Не будем
[01:16:42.000 --> 01:16:44.000]  людям подробно о лекции говорить об этом.
[01:16:44.000 --> 01:16:46.000]  Были какие-то недостатки,
[01:16:46.000 --> 01:16:48.000]  которые люди
[01:16:48.000 --> 01:16:50.000]  исправляли постепенно.
[01:16:50.000 --> 01:16:52.000]  Ну и вот
[01:16:52.000 --> 01:16:54.000]  в чем
[01:16:54.000 --> 01:16:56.000]  прикол в том,
[01:16:56.000 --> 01:16:58.000]  что те, кто занимались
[01:16:58.000 --> 01:17:00.000]  тем, что опруили,
[01:17:00.000 --> 01:17:02.000]  просматривали просто пропозалы, как
[01:17:02.000 --> 01:17:04.000]  асинхронность устроить в Rust,
[01:17:04.000 --> 01:17:06.000]  там же приходили люди, свои предложения
[01:17:06.000 --> 01:17:08.000]  показывали всякие.
[01:17:08.000 --> 01:17:10.000]  Вот как раз те люди, которые
[01:17:10.000 --> 01:17:12.000]  приходили и писали что-то,
[01:17:12.000 --> 01:17:14.000]  те люди, которые проверяли
[01:17:14.000 --> 01:17:16.000]  то, что писали другие люди,
[01:17:16.000 --> 01:17:18.000]  у них была прям засорена там почта,
[01:17:18.000 --> 01:17:20.000]  прям сотни тысячи писем
[01:17:20.000 --> 01:17:22.000]  и это была головная боль
[01:17:22.000 --> 01:17:24.000]  для того, чтобы как-то все это
[01:17:24.000 --> 01:17:26.000]  просмотреть и
[01:17:26.000 --> 01:17:28.000]  дать на все фидбэк
[01:17:28.000 --> 01:17:30.000]  и подумать, как это все нужно устроить.
[01:17:30.000 --> 01:17:32.000]  Но в итоге асинхронная страсти
[01:17:32.000 --> 01:17:34.000]  устроена хорошо достаточно.
[01:17:34.000 --> 01:17:36.000]  Мы сможем написать в ней
[01:17:36.000 --> 01:17:38.000]  примерно все, что захотим.
[01:17:38.000 --> 01:17:40.000]  Асинхронная.
[01:17:40.000 --> 01:17:42.000]  Ладно, это был такой экскурс
[01:17:42.000 --> 01:17:44.000]  вперед немножко.
[01:17:44.000 --> 01:17:46.000]  Ну давайте
[01:17:46.000 --> 01:17:48.000]  большой шаг
[01:17:48.000 --> 01:17:50.000]  сделаем к нашей настоящей фьюче.
[01:17:50.000 --> 01:17:52.000]  Видите ли вы
[01:17:52.000 --> 01:17:54.000]  какую-нибудь проблему в этом
[01:17:54.000 --> 01:17:56.000]  примере?
[01:18:00.000 --> 01:18:02.000]  Насладеется ответного
[01:18:02.000 --> 01:18:04.000]  вопроса.
[01:18:04.000 --> 01:18:06.000]  Да, там сверху написано
[01:18:06.000 --> 01:18:08.000]  пининг, ну наверное
[01:18:08.000 --> 01:18:10.000]  pin strikes back
[01:18:10.000 --> 01:18:12.000]  и естественно
[01:18:12.000 --> 01:18:14.000]  мы зафигачиваем simple future здесь
[01:18:14.000 --> 01:18:16.000]  не просто mute self, а pin mute self.
[01:18:16.000 --> 01:18:18.000]  Потому что мы делаем, стоит машина,
[01:18:18.000 --> 01:18:20.000]  в которой тоже могут быть self-referential структурки
[01:18:20.000 --> 01:18:22.000]  и мы должны дать какие-то гарантии.
[01:18:22.000 --> 01:18:24.000]  Еще, кстати, если бы
[01:18:24.000 --> 01:18:26.000]  вы сделали non-movable структурки в расте,
[01:18:26.000 --> 01:18:28.000]  то, например, вы же когда
[01:18:28.000 --> 01:18:30.000]  возвращаете фьючу из функции,
[01:18:30.000 --> 01:18:32.000]  вы же хотите, чтобы в тот момент она мувалась,
[01:18:32.000 --> 01:18:34.000]  а когда начинает исполняться, она уже не мувается.
[01:18:34.000 --> 01:18:36.000]  Поэтому pin еще чем хорош,
[01:18:36.000 --> 01:18:38.000]  тем, что вы пините
[01:18:38.000 --> 01:18:40.000]  объект, который
[01:18:42.000 --> 01:18:44.000]  в тот момент,
[01:18:44.000 --> 01:18:46.000]  когда он начинает исполняться,
[01:18:46.000 --> 01:18:48.000]  он начинает иметь значение.
[01:18:52.000 --> 01:18:54.000]  Теперь нужно поговорить о небольших
[01:18:54.000 --> 01:18:56.000]  идейках синхронности
[01:18:56.000 --> 01:18:58.000]  в расте.
[01:18:58.000 --> 01:19:00.000]  Можем чуть-чуть отдохнуть, я думаю, дальше
[01:19:00.000 --> 01:19:02.000]  будет не очень сложно.
[01:19:02.000 --> 01:19:04.000]  Если вы хотите отдыхать, конечно.
[01:19:06.000 --> 01:19:08.000]  Давайте поговорим
[01:19:08.000 --> 01:19:10.000]  о том, как устроена
[01:19:10.000 --> 01:19:12.000]  синхронность в расте.
[01:19:12.000 --> 01:19:14.000]  До этого мы посмотрели на фьючу,
[01:19:14.000 --> 01:19:16.000]  посмотрели на генераторы.
[01:19:16.000 --> 01:19:18.000]  Кстати, заметно, понятно
[01:19:18.000 --> 01:19:20.000]  то, как связаны генераторы и фьюч.
[01:19:22.000 --> 01:19:24.000]  И то, и то стоит машина,
[01:19:24.000 --> 01:19:26.000]  только если генератор всегда делает прогресс,
[01:19:26.000 --> 01:19:28.000]  то фьюч пытается.
[01:19:32.000 --> 01:19:34.000]  Давайте поговорим о том,
[01:19:34.000 --> 01:19:36.000]  какими моделями
[01:19:36.000 --> 01:19:38.000]  concurrency мы уже знакомы.
[01:19:40.000 --> 01:19:42.000]  Модели как устроить
[01:19:42.000 --> 01:19:44.000]  параллельные вычисления,
[01:19:44.000 --> 01:19:46.000]  синхронные, куриентные.
[01:19:46.000 --> 01:19:48.000]  Как их выразить.
[01:19:52.000 --> 01:19:54.000]  Давай
[01:19:54.000 --> 01:19:56.000]  самого простого.
[01:19:58.000 --> 01:20:00.000]  Усложнил.
[01:20:00.000 --> 01:20:02.000]  Ну хорошо, эхо-сервер.
[01:20:02.000 --> 01:20:04.000]  Ты, даме студент, хочешь написать
[01:20:04.000 --> 01:20:06.000]  эхо-сервер, который беспараллельно...
[01:20:06.000 --> 01:20:08.000]  Да, 3D.
[01:20:08.000 --> 01:20:10.000]  Это вообще самое простое.
[01:20:10.000 --> 01:20:12.000]  Вытесняющая многозадачность.
[01:20:14.000 --> 01:20:16.000]  Недостатки к 3D вам известно.
[01:20:16.000 --> 01:20:18.000]  Поэтому не буду рассказывать.
[01:20:18.000 --> 01:20:20.000]  Callback.
[01:20:20.000 --> 01:20:22.000]  Давай до callback еще дойдем.
[01:20:22.000 --> 01:20:24.000]  Я просто хочу, чтобы мы
[01:20:24.000 --> 01:20:26.000]  попытались пройтись в том списке,
[01:20:26.000 --> 01:20:28.000]  который написал.
[01:20:30.000 --> 01:20:32.000]  Так, пойдем.
[01:20:32.000 --> 01:20:34.000]  Да, файберы, которые кооперативные.
[01:20:34.000 --> 01:20:36.000]  Да, есть файберы. Это Stackful Coroutine
[01:20:36.000 --> 01:20:38.000]  называется. Ну там много названий.
[01:20:38.000 --> 01:20:40.000]  Многолики они. Green Tracks,
[01:20:40.000 --> 01:20:42.000]  Fiber, Scrutin, то же самое.
[01:20:42.000 --> 01:20:44.000]  Ну или просто говоря, NxM Trading.
[01:20:46.000 --> 01:20:48.000]  Подписал бы, что кооперативные
[01:20:48.000 --> 01:20:50.000]  многозадачные. Да, но дело в том,
[01:20:50.000 --> 01:20:52.000]  что кооперативные многозадачности
[01:20:52.000 --> 01:20:54.000]  дальше примерно все.
[01:20:54.000 --> 01:20:56.000]  Это все, кроме людей.
[01:20:56.000 --> 01:20:58.000]  Поэтому
[01:20:58.000 --> 01:21:00.000]  пошли дальше.
[01:21:00.000 --> 01:21:02.000]  В том есть Stackless Coroutine.
[01:21:02.000 --> 01:21:04.000]  Ну или Generator.
[01:21:04.000 --> 01:21:06.000]  Только что с ним познакомились.
[01:21:08.000 --> 01:21:10.000]  В плюсах мы тоже с ним знакомы.
[01:21:10.000 --> 01:21:12.000]  Прекрасно.
[01:21:12.000 --> 01:21:14.000]  В том есть комбинаторы.
[01:21:14.000 --> 01:21:16.000]  Ну или то, как можно назвать Promises,
[01:21:16.000 --> 01:21:18.000]  Futures, Callbacks.
[01:21:22.000 --> 01:21:24.000]  Так, окей, что же ты называешь
[01:21:24.000 --> 01:21:26.000]  Callback? Это самое...
[01:21:26.000 --> 01:21:28.000]  Когда ты просто
[01:21:28.000 --> 01:21:30.000]  пытаешься какую-то функцию передать,
[01:21:30.000 --> 01:21:32.000]  и она становится Callback.
[01:21:46.000 --> 01:21:48.000]  Ну, не знаю.
[01:21:48.000 --> 01:21:50.000]  Это такое ощущение, что это просто
[01:21:50.000 --> 01:21:52.000]  то, как оно устроено, скажем так,
[01:21:52.000 --> 01:21:54.000]  на железном уровне. Все остальные
[01:21:54.000 --> 01:21:56.000]  способы устроить синхронность.
[01:22:04.000 --> 01:22:06.000]  Да, и актер, конечно.
[01:22:06.000 --> 01:22:08.000]  Актеры никто здесь не знает.
[01:22:08.000 --> 01:22:10.000]  Если только они работали
[01:22:10.000 --> 01:22:12.000]  с ними на работе, например.
[01:22:12.000 --> 01:22:14.000]  Рома Липовски про них не рассказывает.
[01:22:14.000 --> 01:22:16.000]  Ну, в общем-то, это просто такой способ,
[01:22:16.000 --> 01:22:18.000]  скажу для тех, кто не знает.
[01:22:18.000 --> 01:22:20.000]  Есть объекты, которые
[01:22:20.000 --> 01:22:22.000]  общаются между собой посредством
[01:22:22.000 --> 01:22:24.000]  сообщений. Вот эти объекты называются
[01:22:24.000 --> 01:22:26.000]  актеры. Ну, они посылают какие-то
[01:22:26.000 --> 01:22:28.000]  сообщения друг к другу, и
[01:22:28.000 --> 01:22:30.000]  актеры однопоточные. Они
[01:22:30.000 --> 01:22:32.000]  обрабатывают те сообщения, которые им приходят.
[01:22:32.000 --> 01:22:34.000]  Соответственно, актеры чем хороши?
[01:22:34.000 --> 01:22:36.000]  Они хороши в всяких распределенных системах,
[01:22:36.000 --> 01:22:38.000]  например, когда вам хочется
[01:22:38.000 --> 01:22:40.000]  распределить
[01:22:40.000 --> 01:22:42.000]  какие-то вычисления.
[01:22:42.000 --> 01:22:44.000]  То есть, если до этого вам нужно было
[01:22:44.000 --> 01:22:46.000]  в любой другой модели
[01:22:46.000 --> 01:22:48.000]  явно думать про то, что у вас
[01:22:48.000 --> 01:22:50.000]  объекты находятся на одном компьютере
[01:22:50.000 --> 01:22:52.000]  или нет, то в актерах все равно.
[01:22:52.000 --> 01:22:54.000]  Здесь
[01:22:54.000 --> 01:22:56.000]  вас за это решает
[01:22:56.000 --> 01:22:58.000]  ронтайм, все.
[01:22:58.000 --> 01:23:00.000]  Есть подозрение, что тогда актеры
[01:23:00.000 --> 01:23:02.000]  это только файберы с каналами.
[01:23:02.000 --> 01:23:04.000]  Ну, почти.
[01:23:04.000 --> 01:23:06.000]  В принципе, да.
[01:23:06.000 --> 01:23:08.000]  Это такая вот штука.
[01:23:08.000 --> 01:23:10.000]  Файберы с каналами, но только
[01:23:10.000 --> 01:23:12.000]  ронтайм посложнее, конечно,
[01:23:12.000 --> 01:23:14.000]  чем просто файберы.
[01:23:16.000 --> 01:23:18.000]  Вот.
[01:23:18.000 --> 01:23:20.000]  Ну, кажется, что с актерами понятно,
[01:23:20.000 --> 01:23:22.000]  с таквулкарутинами, в принципе,
[01:23:22.000 --> 01:23:24.000]  тоже пресс-минус понятно.
[01:23:24.000 --> 01:23:26.000]  Ну, в общем, утверждается, что в Расте
[01:23:26.000 --> 01:23:28.000]  мы можем все из этого построить.
[01:23:30.000 --> 01:23:32.000]  Вот. Очень важно.
[01:23:32.000 --> 01:23:34.000]  В Расте эта модель, которую мы устроим,
[01:23:34.000 --> 01:23:36.000]  она называется
[01:23:36.000 --> 01:23:38.000]  синхронная, не блокирующая.
[01:23:38.000 --> 01:23:40.000]  Ну, что-то по-английски у полинга, да,
[01:23:40.000 --> 01:23:42.000]  синхронная она называется.
[01:23:44.000 --> 01:23:46.000]  Ну, полинг там
[01:23:46.000 --> 01:23:48.000]  на самом деле асинхронность, просто мы пока что
[01:23:48.000 --> 01:23:50.000]  до нее не дошли.
[01:23:50.000 --> 01:23:52.000]  Сейчас посмотрим.
[01:23:52.000 --> 01:23:54.000]  Это синхронная, не блокирующая модель.
[01:23:54.000 --> 01:23:56.000]  Понимаете ли вы, что это значит?
[01:23:58.000 --> 01:24:00.000]  Ну, я понимаю, типа так, что
[01:24:00.000 --> 01:24:02.000]  у нас отдельное поняние операции,
[01:24:02.000 --> 01:24:04.000]  отдельное ожидание результатов,
[01:24:04.000 --> 01:24:06.000]  и ожидание у нас активное,
[01:24:06.000 --> 01:24:08.000]  а операция, ну, когда-нибудь может быть.
[01:24:08.000 --> 01:24:10.000]  Ну, я, конечно, хотел бы сказать это так.
[01:24:10.000 --> 01:24:12.000]  Я бы хотел сказать, что
[01:24:12.000 --> 01:24:14.000]  синхронная либо асинхронная означает то,
[01:24:14.000 --> 01:24:16.000]  как у вас код выглядит.
[01:24:16.000 --> 01:24:18.000]  Например, когда вы пишете
[01:24:18.000 --> 01:24:20.000]  в каком-нибудь джаваскрипте,
[01:24:20.000 --> 01:24:22.000]  с Node.js,
[01:24:22.000 --> 01:24:24.000]  то у вас в таком случае
[01:24:24.000 --> 01:24:26.000]  всякие околбекки, вы там явно пишете
[01:24:26.000 --> 01:24:28.000]  .dn, .dn, .dn,
[01:24:28.000 --> 01:24:30.000]  это все
[01:24:30.000 --> 01:24:32.000]  выглядит как какой-то
[01:24:32.000 --> 01:24:34.000]  асинхронный код. То есть он выглядит как что-то,
[01:24:34.000 --> 01:24:36.000]  что должно выполняться асинхронно.
[01:24:36.000 --> 01:24:38.000]  А блокирующий или не блокирующий, то,
[01:24:38.000 --> 01:24:40.000]  как он на самом деле исполняется.
[01:24:40.000 --> 01:24:42.000]  Ну, понятное дело, что
[01:24:42.000 --> 01:24:44.000]  синхронный блокирующий
[01:24:44.000 --> 01:24:46.000]  это вообще простейший код,
[01:24:46.000 --> 01:24:48.000]  а асинхронный блокирующий не имеет
[01:24:48.000 --> 01:24:50.000]  никакого смысла. Зачем нам писать код, который выглядит
[01:24:50.000 --> 01:24:52.000]  асинхронным? На самом деле он блокирующий.
[01:24:52.000 --> 01:24:54.000]  Вообще не приносит
[01:24:54.000 --> 01:24:56.000]  никакого смысла. А вот, например, в Гошке
[01:24:56.000 --> 01:24:58.000]  у нас синхронный не блокирующий
[01:24:58.000 --> 01:25:00.000]  runtime. Прямо как в Rasta.
[01:25:00.000 --> 01:25:02.000]  То есть вы пишете код, который выглядит
[01:25:02.000 --> 01:25:04.000]  как какой-то асинхронный,
[01:25:04.000 --> 01:25:06.000]  он достаточно простой,
[01:25:06.000 --> 01:25:08.000]  последовательный,
[01:25:08.000 --> 01:25:10.000]  но при этом он не блокирующий.
[01:25:10.000 --> 01:25:12.000]  А асинхронный не блокирующий,
[01:25:12.000 --> 01:25:14.000]  но, опять же, как node.js,
[01:25:14.000 --> 01:25:16.000]  явно пишете какие-то
[01:25:16.000 --> 01:25:18.000]  callbacks, и вы понимаете, что они там
[01:25:18.000 --> 01:25:20.000]  где-то по очереди
[01:25:20.000 --> 01:25:22.000]  будут как-то исполняться в runtime.
[01:25:22.000 --> 01:25:24.000]  Ну, а что у Fiber получается,
[01:25:24.000 --> 01:25:26.000]  когда так и дают
[01:25:26.000 --> 01:25:28.000]  синхронные интерфейсы?
[01:25:28.000 --> 01:25:30.000]  Такс.
[01:25:30.000 --> 01:25:32.000]  Ну, здесь в этот момент
[01:25:32.000 --> 01:25:34.000]  мы должны были бы посадить, как вы видите,
[01:25:34.000 --> 01:25:36.000]  а сервер на Tokio, но, кажется, мы это уже сделали.
[01:25:36.000 --> 01:25:38.000]  Мы же, в принципе,
[01:25:38.000 --> 01:25:40.000]  примерно, понимаем, что хотим получить.
[01:25:40.000 --> 01:25:42.000]  Смотрите.
[01:25:42.000 --> 01:25:44.000]  Вот теперь пришел момент истины.
[01:25:44.000 --> 01:25:46.000]  Мы посмотрели на нашу
[01:25:46.000 --> 01:25:48.000]  SimpleFuture, и сейчас выглядит как-то так
[01:25:48.000 --> 01:25:50.000]  наша моделька.
[01:25:50.000 --> 01:25:52.000]  Смотрите, у нас есть асинхронная функция foo.
[01:25:52.000 --> 01:25:54.000]  Пусть у нас есть
[01:25:54.000 --> 01:25:56.000]  какой-то executor. Что у нас сейчас
[01:25:56.000 --> 01:25:58.000]  делает executor? Сейчас executor
[01:25:58.000 --> 01:26:00.000]  просто все foo.future, которые ему дали,
[01:26:00.000 --> 01:26:02.000]  просто пытается заполить.
[01:26:02.000 --> 01:26:04.000]  Беспрерывно. Вот у него есть taskFullQueue,
[01:26:04.000 --> 01:26:06.000]  и он внутри него просто
[01:26:06.000 --> 01:26:08.000]  полит фьючу.
[01:26:08.000 --> 01:26:10.000]  А сама фьюча
[01:26:10.000 --> 01:26:12.000]  ну, сама фьюча просто
[01:26:12.000 --> 01:26:14.000]  говорит, что либо у него получилось что-то сделать,
[01:26:14.000 --> 01:26:16.000]  либо не получилось.
[01:26:16.000 --> 01:26:18.000]  Это как-то неэффективно, да?
[01:26:18.000 --> 01:26:20.000]  Мы постоянно полим фьючу.
[01:26:20.000 --> 01:26:22.000]  Мы не стоим на месте, мы не ждем.
[01:26:22.000 --> 01:26:24.000]  У нас
[01:26:24.000 --> 01:26:26.000]  очень много бесполезной работы. Давайте мы ее
[01:26:26.000 --> 01:26:28.000]  как-то как-нибудь уберем.
[01:26:28.000 --> 01:26:30.000]  Ну, как уберем, давайте сделаем так.
[01:26:30.000 --> 01:26:32.000]  Теперь, когда мы будем вызывать пол,
[01:26:32.000 --> 01:26:34.000]  ну, для простоты, если что, я здесь убрал специально
[01:26:34.000 --> 01:26:36.000]  пин.
[01:26:36.000 --> 01:26:38.000]  Наверное, в этом месте даже не нужно было делать,
[01:26:38.000 --> 01:26:40.000]  но как факт,
[01:26:40.000 --> 01:26:42.000]  здесь пина нет. На самом деле он нужен,
[01:26:42.000 --> 01:26:44.000]  просто что я его убрал для простоты.
[01:26:44.000 --> 01:26:46.000]  Мы будем придавать еще wake.
[01:26:46.000 --> 01:26:48.000]  Wake — это такая функция,
[01:26:48.000 --> 01:26:50.000]  которую
[01:26:50.000 --> 01:26:52.000]  мы шедулим как наш callback.
[01:26:52.000 --> 01:26:54.000]  То есть,
[01:26:54.000 --> 01:26:56.000]  если у нас
[01:26:56.000 --> 01:26:58.000]  фьюча
[01:26:58.000 --> 01:27:00.000]  выдает ради, то в таком случае она ради.
[01:27:00.000 --> 01:27:02.000]  Если она выдает pending,
[01:27:02.000 --> 01:27:04.000]  то в таком случае мы говорим,
[01:27:04.000 --> 01:27:06.000]  что
[01:27:06.000 --> 01:27:08.000]  наш runtime как-то так должен быть устроен,
[01:27:08.000 --> 01:27:10.000]  что мы где-то шедулим,
[01:27:10.000 --> 01:27:12.000]  что в случае, когда у нас эта фьюча
[01:27:12.000 --> 01:27:14.000]  будет готова совершать прогресс,
[01:27:14.000 --> 01:27:16.000]  будет вызвана эта функция wake.
[01:27:18.000 --> 01:27:20.000]  Ну, он эту функцию wake
[01:27:20.000 --> 01:27:22.000]  запустит.
[01:27:24.000 --> 01:27:26.000]  Ну, и вот, например, наш asyncFileRead,
[01:27:26.000 --> 01:27:28.000]  на котором мы смотрели в самом первом,
[01:27:28.000 --> 01:27:30.000]  будет выглядеть в таком случае примерно так.
[01:27:30.000 --> 01:27:32.000]  Добавилась только одна строчка.
[01:27:32.000 --> 01:27:34.000]  Это FileHandleSetReadableCallback.
[01:27:34.000 --> 01:27:36.000]  Просто, когда он станет readable,
[01:27:36.000 --> 01:27:38.000]  оп, wake вызвался, и наша фьюча такая
[01:27:38.000 --> 01:27:40.000]  yes, я готова исполняться.
[01:27:40.000 --> 01:27:42.000]  Экзекутер ее
[01:27:42.000 --> 01:27:44.000]  в полем q засунул
[01:27:44.000 --> 01:27:46.000]  и все, и начал исполнить.
[01:27:46.000 --> 01:27:48.000]  До этого он ее даже не трогал.
[01:27:48.000 --> 01:27:50.000]  Ну, и таким образом наша модель
[01:27:50.000 --> 01:27:52.000]  становится примерно такой.
[01:27:52.000 --> 01:27:54.000]  Понятно ли примерно, как она устроена?
[01:27:56.000 --> 01:27:58.000]  То есть, фьюча, она там где-то,
[01:27:58.000 --> 01:28:00.000]  если у нее не получилось исполниться
[01:28:00.000 --> 01:28:02.000]  в шедуле wake,
[01:28:02.000 --> 01:28:04.000]  эта штука будет называться Reactor,
[01:28:04.000 --> 01:28:06.000]  которая у нас будет реагировать
[01:28:06.000 --> 01:28:08.000]  на события,
[01:28:08.000 --> 01:28:10.000]  которые, ну,
[01:28:10.000 --> 01:28:12.000]  будет реагировать на события,
[01:28:12.000 --> 01:28:14.000]  что фьюча завершилась.
[01:28:14.000 --> 01:28:16.000]  И в этот момент наша фьюча
[01:28:16.000 --> 01:28:18.000]  завершилась.
[01:28:18.000 --> 01:28:20.000]  И в тот момент, когда он словит
[01:28:20.000 --> 01:28:22.000]  сообщение о том, что эта фьюча
[01:28:22.000 --> 01:28:24.000]  готова исполняться, он ее
[01:28:24.000 --> 01:28:26.000]  передвинет в TaskPortQueue и снова
[01:28:26.000 --> 01:28:28.000]  пробует заполнить.
[01:28:28.000 --> 01:28:30.000]  И так до тех пор, пока фьюча не закончится.
[01:28:30.000 --> 01:28:32.000]  Вот такой вот примерно цикл получается.
[01:28:36.000 --> 01:28:38.000]  Теперь нужно понять,
[01:28:38.000 --> 01:28:40.000]  как на самом деле устроена фьюча.
[01:28:40.000 --> 01:28:42.000]  Ну, как она устроена?
[01:28:42.000 --> 01:28:44.000]  Ну, как она устроена?
[01:28:44.000 --> 01:28:46.000]  Ну, как она устроена?
[01:28:46.000 --> 01:28:48.000]  Как на самом деле устроена фьюча?
[01:28:48.000 --> 01:28:50.000]  Мы могли
[01:28:50.000 --> 01:28:52.000]  обратить внимание, что мы
[01:28:52.000 --> 01:28:54.000]  даем только fn какой-то pointer.
[01:28:54.000 --> 01:28:56.000]  Дело в том, что fn нет аргументов.
[01:28:56.000 --> 01:28:58.000]  Это просто какая-то глобальная функция.
[01:28:58.000 --> 01:29:00.000]  Что если, ну, просто даже самый
[01:29:00.000 --> 01:29:02.000]  простой пример,
[01:29:02.000 --> 01:29:04.000]  что если наша фьюча
[01:29:04.000 --> 01:29:06.000]  это нечто, что
[01:29:06.000 --> 01:29:08.000]  в общем, она
[01:29:08.000 --> 01:29:10.000]  выполняется на экзекутере не одна.
[01:29:10.000 --> 01:29:12.000]  В таком случае нужно сказать, что именно ее нужно
[01:29:12.000 --> 01:29:14.000]  разбудить. Им нужен какой-то контекст
[01:29:14.000 --> 01:29:16.000]  исполнения. То есть сказать, что именно ее нужно
[01:29:16.000 --> 01:29:18.000]  разбудить, а не все фьючи, например.
[01:29:20.000 --> 01:29:22.000]  Вот. Ну, пришло время
[01:29:22.000 --> 01:29:24.000]  для того, чтобы
[01:29:24.000 --> 01:29:26.000]  наконец усложнить до самой
[01:29:26.000 --> 01:29:28.000]  настоящей фьючи, взрослой фьючи.
[01:29:28.000 --> 01:29:30.000]  У нее, во-первых, есть pin, во-вторых,
[01:29:30.000 --> 01:29:32.000]  у нее есть такая штука, называется context.
[01:29:32.000 --> 01:29:34.000]  Context — это, собственно,
[01:29:34.000 --> 01:29:36.000]  то же самое, что у нас
[01:29:36.000 --> 01:29:38.000]  наш callback, но только на стероидах.
[01:29:38.000 --> 01:29:40.000]  С некоторыми изменениями.
[01:29:40.000 --> 01:29:42.000]  Сейчас посмотрим.
[01:29:42.000 --> 01:29:44.000]  Так, ну, тут идея понятна.
[01:29:48.000 --> 01:29:50.000]  В это
[01:29:50.000 --> 01:29:52.000]  же время, вот, на данный момент
[01:29:52.000 --> 01:29:54.000]  context — это просто что-то,
[01:29:54.000 --> 01:29:56.000]  что оборачивает тип waker.
[01:29:56.000 --> 01:29:58.000]  Сейчас, если что, будет матрешка.
[01:29:58.000 --> 01:30:00.000]  Приготовьте, здесь будет четыре
[01:30:00.000 --> 01:30:02.000]  типа прямо подряд матрешечка.
[01:30:02.000 --> 01:30:04.000]  Context
[01:30:04.000 --> 01:30:06.000]  на данный момент — это просто что-то,
[01:30:06.000 --> 01:30:08.000]  что оборачивает waker.
[01:30:08.000 --> 01:30:10.000]  Waker, опять же, это тоже
[01:30:10.000 --> 01:30:12.000]  callback.
[01:30:12.000 --> 01:30:14.000]  Context, я так понял,
[01:30:14.000 --> 01:30:16.000]  существует для того, чтобы, во-первых,
[01:30:16.000 --> 01:30:18.000]  был lifetime какой-то.
[01:30:18.000 --> 01:30:20.000]  Во-вторых, для того, чтобы можно было,
[01:30:20.000 --> 01:30:22.000]  если захочется, в будущем, раз еще что-нибудь
[01:30:22.000 --> 01:30:24.000]  дописать.
[01:30:24.000 --> 01:30:26.000]  То есть, в плане
[01:30:26.000 --> 01:30:28.000]  не ломая то, как уже устроены
[01:30:28.000 --> 01:30:30.000]  фьючи,
[01:30:30.000 --> 01:30:32.000]  добавить какие-то дополнительные возможности.
[01:30:32.000 --> 01:30:34.000]  То есть, context — это такое промежуточное
[01:30:34.000 --> 01:30:36.000]  звено, которое, скорее всего,
[01:30:36.000 --> 01:30:38.000]  именно поэтому так и устроено.
[01:30:38.000 --> 01:30:40.000]  В крайней мере, в библиотеке
[01:30:40.000 --> 01:30:42.000]  стандартно так и написано, что на данный момент
[01:30:42.000 --> 01:30:44.000]  оно существует только для того, чтобы
[01:30:44.000 --> 01:30:46.000]  оборачивать тип waker.
[01:30:46.000 --> 01:30:48.000]  Вот.
[01:30:48.000 --> 01:30:50.000]  Соответственно, там внутри просто сидит какой-то waker.
[01:30:50.000 --> 01:30:52.000]  Ссылочка, точнее,
[01:30:52.000 --> 01:30:54.000]  даже на waker.
[01:30:54.000 --> 01:30:56.000]  Ну, и вы можете либо создаться из waker,
[01:30:56.000 --> 01:30:58.000]  либо waker вызвать.
[01:30:58.000 --> 01:31:00.000]  Опять же, waker — это callback.
[01:31:00.000 --> 01:31:02.000]  Что такое waker? Это что-то, что
[01:31:02.000 --> 01:31:04.000]  инкапсулирует raw waker.
[01:31:04.000 --> 01:31:06.000]  Пошли
[01:31:06.000 --> 01:31:08.000]  еще глубже.
[01:31:08.000 --> 01:31:10.000]  Нет, даже 5 будет сейчас.
[01:31:10.000 --> 01:31:12.000]  Вот.
[01:31:12.000 --> 01:31:14.000]  Эта штука имплементирует clone-send-desync.
[01:31:16.000 --> 01:31:18.000]  Так.
[01:31:18.000 --> 01:31:20.000]  Самые важные функции — это, во-первых,
[01:31:20.000 --> 01:31:22.000]  wake, собственно. На waker вы можете
[01:31:22.000 --> 01:31:24.000]  вызвать wake
[01:31:24.000 --> 01:31:26.000]  и тем самым разбудить
[01:31:26.000 --> 01:31:28.000]  future, который ему соответствует.
[01:31:30.000 --> 01:31:32.000]  И потом есть, собственно, еще from-raw.
[01:31:32.000 --> 01:31:34.000]  Здесь есть raw-waker.
[01:31:34.000 --> 01:31:36.000]  Она unsafe, потому что
[01:31:36.000 --> 01:31:38.000]  в raw-waker внутри
[01:31:38.000 --> 01:31:40.000]  вы создаете vtable,
[01:31:40.000 --> 01:31:42.000]  о котором мы сейчас посмотрим.
[01:31:42.000 --> 01:31:44.000]  И вы должны гарантировать то, что этот
[01:31:44.000 --> 01:31:46.000]  vtable-correction, что он очищает
[01:31:46.000 --> 01:31:48.000]  все ресурсы, которые
[01:31:48.000 --> 01:31:50.000]  future
[01:31:52.000 --> 01:31:54.000]  алоцировала.
[01:31:54.000 --> 01:31:56.000]  Нужно эти какие-то
[01:31:56.000 --> 01:31:58.000]  гарантии дать.
[01:31:58.000 --> 01:32:00.000]  В общем, это создано для того,
[01:32:00.000 --> 01:32:02.000]  чтобы вы явным образом
[01:32:02.000 --> 01:32:04.000]  контракт
[01:32:04.000 --> 01:32:06.000]  прописали у себя где-то в коде,
[01:32:06.000 --> 01:32:08.000]  когда вы будете создавать raw-waker.
[01:32:08.000 --> 01:32:10.000]  Вот.
[01:32:12.000 --> 01:32:14.000]  Вот raw-waker — это уже такая штука,
[01:32:14.000 --> 01:32:16.000]  которая, во-первых...
[01:32:16.000 --> 01:32:18.000]  Ну, вот она уже первая, наверное,
[01:32:18.000 --> 01:32:20.000]  осмысленная, а не просто какой-то врагер.
[01:32:20.000 --> 01:32:22.000]  Это такая штука, которая...
[01:32:22.000 --> 01:32:24.000]  Ну ладно,
[01:32:24.000 --> 01:32:26.000]  контекст был не очень осмыслен,
[01:32:26.000 --> 01:32:28.000]  waker для того, чтобы
[01:32:28.000 --> 01:32:30.000]  контракт явным образом объявить,
[01:32:30.000 --> 01:32:32.000]  а raw-waker — это уже штука, которая, во-первых,
[01:32:32.000 --> 01:32:34.000]  содержит указательно какие-то
[01:32:34.000 --> 01:32:36.000]  данные, которые нужны future
[01:32:36.000 --> 01:32:38.000]  для того, чтобы разбудиться.
[01:32:38.000 --> 01:32:40.000]  А vtable — это функция, которую нужно будет вызывать.
[01:32:42.000 --> 01:32:44.000]  Единственное тут важное для нас
[01:32:44.000 --> 01:32:46.000]  на данную функцию — это
[01:32:46.000 --> 01:32:48.000]  конструктор, который принимает
[01:32:48.000 --> 01:32:50.000]  указательные данные и
[01:32:50.000 --> 01:32:52.000]  статическую ссылку на raw-waker
[01:32:52.000 --> 01:32:54.000]  vtable.
[01:32:54.000 --> 01:32:56.000]  Итак, самый важный raw-waker vtable.
[01:32:56.000 --> 01:32:58.000]  В ней внутри четыре функции —
[01:32:58.000 --> 01:33:00.000]  clone, wake, wake-brf и drop.
[01:33:02.000 --> 01:33:04.000]  Wake-brf нам сейчас
[01:33:04.000 --> 01:33:06.000]  не очень важен.
[01:33:06.000 --> 01:33:08.000]  Он используется для оптимизации всяких,
[01:33:08.000 --> 01:33:10.000]  для того, чтобы waker не...
[01:33:10.000 --> 01:33:12.000]  Ну, в общем,
[01:33:12.000 --> 01:33:14.000]  не идеалацировать waker, не съедать его, скажем так,
[01:33:14.000 --> 01:33:16.000]  посылки разбудить.
[01:33:16.000 --> 01:33:18.000]  Потому что у нас waker,
[01:33:18.000 --> 01:33:20.000]  он передается
[01:33:20.000 --> 01:33:22.000]  future...
[01:33:22.000 --> 01:33:24.000]  Ну, в общем, мы не хотим
[01:33:24.000 --> 01:33:26.000]  его идеалацировать,
[01:33:26.000 --> 01:33:28.000]  поэтому иногда хочется
[01:33:28.000 --> 01:33:30.000]  wake-brf использовать.
[01:33:30.000 --> 01:33:32.000]  Мы не будем на него подробно смотреть.
[01:33:32.000 --> 01:33:34.000]  Это такая вещь, которая для оптимизации предназначена.
[01:33:34.000 --> 01:33:36.000]  Суть она не меняет.
[01:33:36.000 --> 01:33:38.000]  Но есть clone, wake,
[01:33:38.000 --> 01:33:40.000]  clone, wake и drop —
[01:33:40.000 --> 01:33:42.000]  важная функция.
[01:33:42.000 --> 01:33:44.000]  Как видите, это какие-то функции, которые
[01:33:44.000 --> 01:33:46.000]  принимают на вход данные.
[01:33:46.000 --> 01:33:48.000]  Собственно,
[01:33:48.000 --> 01:33:50.000]  туда будет передаваться указатель на data.
[01:33:50.000 --> 01:33:52.000]  И в случае clone
[01:33:52.000 --> 01:33:54.000]  мы будем возвращать raw-waker.
[01:33:56.000 --> 01:33:58.000]  Потому что мы будем клонировать наш
[01:33:58.000 --> 01:34:00.000]  текущий waker.
[01:34:00.000 --> 01:34:02.000]  Функция clone
[01:34:02.000 --> 01:34:04.000]  будет вызываться тогда,
[01:34:04.000 --> 01:34:06.000]  когда мы будем пытаться склонировать
[01:34:06.000 --> 01:34:08.000]  raw-waker.
[01:34:08.000 --> 01:34:10.000]  То есть, если вы будете еще где-то выше
[01:34:10.000 --> 01:34:12.000]  клонировать waker, то в одном случае
[01:34:12.000 --> 01:34:14.000]  он будет клонировать свой raw-waker и вызывать эту функцию.
[01:34:14.000 --> 01:34:16.000]  Соответственно.
[01:34:16.000 --> 01:34:18.000]  Функция wake
[01:34:18.000 --> 01:34:20.000]  будет вызываться на...
[01:34:20.000 --> 01:34:22.000]  Ну, собственно, вызываться waker,
[01:34:22.000 --> 01:34:24.000]  когда вы будете вызывать на нем wake
[01:34:24.000 --> 01:34:26.000]  для того, чтобы future разбудить.
[01:34:26.000 --> 01:34:28.000]  Ну и drop тогда
[01:34:28.000 --> 01:34:30.000]  будет вызываться drop.
[01:34:32.000 --> 01:34:34.000]  То есть, это тот же самый wake,
[01:34:34.000 --> 01:34:36.000]  который мы посмотрели с самого
[01:34:36.000 --> 01:34:38.000]  начала, который мы добавили, просто fn-поинтер.
[01:34:38.000 --> 01:34:40.000]  Но на стероидах. У нас теперь есть
[01:34:40.000 --> 01:34:42.000]  какие-то данные, теперь мы умеем клонировать
[01:34:42.000 --> 01:34:44.000]  и дропаться еще.
[01:34:44.000 --> 01:34:46.000]  Еще есть указатель
[01:34:46.000 --> 01:34:48.000]  wake-by-ref, который
[01:34:48.000 --> 01:34:50.000]  предназначен для оптимизации.
[01:34:54.000 --> 01:34:56.000]  Так.
[01:34:56.000 --> 01:34:58.000]  Ну, вот это вот я сказал,
[01:34:58.000 --> 01:35:00.000]  давайте вы тоже поговорите.
[01:35:18.000 --> 01:35:20.000]  Ну, мы ведем в том, что да,
[01:35:20.000 --> 01:35:22.000]  мы хотим, чтобы
[01:35:24.000 --> 01:35:26.000]  еще нет, он raw-waker,
[01:35:26.000 --> 01:35:28.000]  мы хотели, чтобы...
[01:35:28.000 --> 01:35:30.000]  Вообще, верно, что сам raw-waker
[01:35:30.000 --> 01:35:32.000]  получается своим retable никак
[01:35:32.000 --> 01:35:34.000]  не пользуется, и он нужен только для того,
[01:35:34.000 --> 01:35:36.000]  чтобы дать его waker.
[01:35:36.000 --> 01:35:38.000]  Да, да, да. Тогда мы хотим, чтобы
[01:35:38.000 --> 01:35:40.000]  этот retable дало тот контракт
[01:35:40.000 --> 01:35:42.000]  этого waker. Да, мы хотим, чтобы
[01:35:42.000 --> 01:35:44.000]  мы очищали все ресурсы, мы хотим, чтобы у нас
[01:35:44.000 --> 01:35:46.000]  retable был корректным, поэтому
[01:35:46.000 --> 01:35:48.000]  у нас он unsafe.
[01:35:48.000 --> 01:35:50.000]  Нет никакой проблемы создать некорректный raw-waker,
[01:35:50.000 --> 01:35:52.000]  плохо тогда, когда мы его засунем
[01:35:52.000 --> 01:35:54.000]  в наш
[01:35:54.000 --> 01:35:56.000]  save-waker, который будет
[01:35:56.000 --> 01:35:58.000]  ему уже пользоваться. В таком случае у нас что-то может
[01:35:58.000 --> 01:36:00.000]  разломаться в runtime.
[01:36:00.000 --> 01:36:02.000]  Поэтому мы явно
[01:36:02.000 --> 01:36:04.000]  этот контракт создаем.
[01:36:06.000 --> 01:36:08.000]  Так, еще более интересно, как
[01:36:08.000 --> 01:36:10.000]  нам cancellation в такой модельке создать?
[01:36:12.000 --> 01:36:14.000]  Это, наверное, очень простой вопрос.
[01:36:16.000 --> 01:36:18.000]  В такой модели
[01:36:18.000 --> 01:36:20.000]  это можно сделать достаточно
[01:36:20.000 --> 01:36:22.000]  несложно.
[01:36:26.000 --> 01:36:28.000]  Смотри, чтобы у future
[01:36:28.000 --> 01:36:30.000]  делал прогресс, тебе нужно
[01:36:30.000 --> 01:36:32.000]  полить.
[01:36:34.000 --> 01:36:36.000]  Cancellation это означает, что
[01:36:36.000 --> 01:36:38.000]  future тебе нужно перестать полить.
[01:36:38.000 --> 01:36:40.000]  Логично.
[01:36:40.000 --> 01:36:42.000]  То есть тебе нужно просто брохнуть future.
[01:36:42.000 --> 01:36:44.000]  То есть, когда нам говорят,
[01:36:44.000 --> 01:36:46.000]  что вот этот future cancelled,
[01:36:46.000 --> 01:36:48.000]  в таком случае это такое,
[01:36:48.000 --> 01:36:50.000]  ну, значит, я выкидываю ее из очереди,
[01:36:50.000 --> 01:36:52.000]  где он там есть, либо
[01:36:52.000 --> 01:36:54.000]  пол-Q, либо wake-Q,
[01:36:54.000 --> 01:36:56.000]  и все.
[01:36:56.000 --> 01:36:58.000]  Просто перестал его полить.
[01:37:00.000 --> 01:37:02.000]  То есть, идея на это примерно так просто.
[01:37:02.000 --> 01:37:04.000]  А как на практике
[01:37:04.000 --> 01:37:06.000]  пишется, ну, посложнее.
[01:37:08.000 --> 01:37:10.000]  Давайте еще посмотрим такой пример
[01:37:10.000 --> 01:37:12.000]  raw-waker, который не делает ничего.
[01:37:12.000 --> 01:37:14.000]  Дами raw-waker.
[01:37:16.000 --> 01:37:18.000]  Здесь мы
[01:37:18.000 --> 01:37:20.000]  имеем три функции, которые
[01:37:20.000 --> 01:37:22.000]  просто ничего абсолютно
[01:37:22.000 --> 01:37:24.000]  не делают. Клоун возвращает
[01:37:24.000 --> 01:37:26.000]  тот же самый dummy raw-waker.
[01:37:26.000 --> 01:37:28.000]  Vtable у нас
[01:37:28.000 --> 01:37:30.000]  состоит из клоуна
[01:37:30.000 --> 01:37:32.000]  нескольких no-op.
[01:37:34.000 --> 01:37:36.000]  Raw-waker new это
[01:37:36.000 --> 01:37:38.000]  no-pointer на данное, и vtable.
[01:37:38.000 --> 01:37:40.000]  Все.
[01:37:42.000 --> 01:37:44.000]  Пока что еще ничего не понятно, да?
[01:37:44.000 --> 01:37:46.000]  Нам, наверное, нужно посмотреть на примерчик
[01:37:46.000 --> 01:37:48.000]  сейчас, как это все связать
[01:37:48.000 --> 01:37:50.000]  между собой.
[01:37:52.000 --> 01:37:54.000]  Text.
[01:37:54.000 --> 01:37:56.000]  Ну что ж, самая важная,
[01:37:56.000 --> 01:37:58.000]  наверное, глава, на которой мы сейчас
[01:37:58.000 --> 01:38:00.000]  разберемся, как это устроено.
[01:38:02.000 --> 01:38:04.000]  Давайте построим небольшой
[01:38:04.000 --> 01:38:06.000]  простенький такой асинхронный рейн-тайм.
[01:38:06.000 --> 01:38:08.000]  В нем будет одна ли фьюча.
[01:38:08.000 --> 01:38:10.000]  Ну, как я говорил, у нас есть
[01:38:10.000 --> 01:38:12.000]  фьюча, которую мы пишем,
[01:38:12.000 --> 01:38:14.000]  которую проводим в наш рейн-тайм.
[01:38:16.000 --> 01:38:18.000]  Одна из таких фьюч может быть
[01:38:18.000 --> 01:38:20.000]  таймер фьюча. Мы ее как раз построим.
[01:38:20.000 --> 01:38:22.000]  Она у нас будет безумно простая.
[01:38:22.000 --> 01:38:24.000]  Мы просто будем создавать thread,
[01:38:24.000 --> 01:38:26.000]  который будет спать
[01:38:26.000 --> 01:38:28.000]  до тех пор, пока...
[01:38:28.000 --> 01:38:30.000]  Короче, будет спать, а потом
[01:38:30.000 --> 01:38:32.000]  он будет нашу фьючу будить, когда проснется.
[01:38:32.000 --> 01:38:34.000]  И все.
[01:38:34.000 --> 01:38:36.000]  Ну, в реальном
[01:38:36.000 --> 01:38:38.000]  мире вы, конечно, так не захотите,
[01:38:38.000 --> 01:38:40.000]  но в нашем рейн-тайме
[01:38:40.000 --> 01:38:42.000]  это будет вполне нормально,
[01:38:42.000 --> 01:38:44.000]  потому что мы ее только учимся.
[01:38:44.000 --> 01:38:46.000]  Еще, когда вы будете писать,
[01:38:46.000 --> 01:38:48.000]  что это более сложный рейн-тайм,
[01:38:48.000 --> 01:38:50.000]  скорее всего, заходите в всякие
[01:38:50.000 --> 01:38:52.000]  отчетения и соки 3D и TAP.
[01:38:52.000 --> 01:38:54.000]  В следующем году, наверное,
[01:38:54.000 --> 01:38:56.000]  это будет домашки, но не в этом.
[01:38:56.000 --> 01:38:58.000]  Так.
[01:38:58.000 --> 01:39:00.000]  Более того, нам сейчас
[01:39:00.000 --> 01:39:02.000]  понадобится какой-то экзекютер.
[01:39:02.000 --> 01:39:04.000]  Мы его тоже напишем.
[01:39:04.000 --> 01:39:06.000]  Вот.
[01:39:06.000 --> 01:39:08.000]  Как вам должно быть известно,
[01:39:08.000 --> 01:39:10.000]  наша
[01:39:10.000 --> 01:39:12.000]  non-only-future...
[01:39:12.000 --> 01:39:14.000]  Ну, то есть у нас есть не фьючи, которые
[01:39:14.000 --> 01:39:16.000]  делают реальный прогресс, и non-only-future,
[01:39:16.000 --> 01:39:18.000]  которые представляют у себя сверху просто
[01:39:18.000 --> 01:39:20.000]  стоит машина над этими фьючами.
[01:39:20.000 --> 01:39:22.000]  Они просто вызывают полно всех тех фьючих.
[01:39:22.000 --> 01:39:24.000]  Вот.
[01:39:24.000 --> 01:39:26.000]  Ну и мы будем передавать им какой-то
[01:39:26.000 --> 01:39:28.000]  вейкер для того, чтобы нас разбудили.
[01:39:28.000 --> 01:39:30.000]  Ух, так.
[01:39:30.000 --> 01:39:32.000]  И для того, чтобы
[01:39:32.000 --> 01:39:34.000]  когда мы пишем ли-фьюч, нам нужно
[01:39:34.000 --> 01:39:36.000]  как-то гарантировать то,
[01:39:36.000 --> 01:39:38.000]  что мы будем как-то
[01:39:38.000 --> 01:39:40.000]  сообщать о том, что мы готовы
[01:39:40.000 --> 01:39:42.000]  совершать прогресс.
[01:39:42.000 --> 01:39:44.000]  Ну, то есть в случае нашей таймер-фьюч
[01:39:44.000 --> 01:39:46.000]  нам нужно как-то послать сообщение,
[01:39:46.000 --> 01:39:48.000]  что у нас пора уже как-то достать
[01:39:48.000 --> 01:39:50.000]  из очереди вспоминания.
[01:39:52.000 --> 01:39:54.000]  Ну, это, как я и говорил,
[01:39:54.000 --> 01:39:56.000]  есть несколько
[01:39:56.000 --> 01:39:58.000]  несколько синхронных рантаймов в Rust.
[01:39:58.000 --> 01:40:00.000]  Они представляют
[01:40:00.000 --> 01:40:02.000]  предоставляют некоторые
[01:40:02.000 --> 01:40:04.000]  ли-фьючи сами. Ну, то есть, например,
[01:40:04.000 --> 01:40:06.000]  если вы хотите откуда-то синхронно почитать,
[01:40:06.000 --> 01:40:08.000]  то, скорее всего, уже из-за вас написано
[01:40:08.000 --> 01:40:10.000]  ли-фьюча, и вам ничего делать не нужно.
[01:40:10.000 --> 01:40:12.000]  И она уже соответственно прикручена
[01:40:12.000 --> 01:40:14.000]  к вашему рантайму, с учетом того,
[01:40:14.000 --> 01:40:16.000]  на какой вы операционной системе,
[01:40:16.000 --> 01:40:18.000]  там, ну, там E-Poll,
[01:40:18.000 --> 01:40:20.000]  CastElector, как она там в маке называется,
[01:40:20.000 --> 01:40:22.000]  и так далее.
[01:40:22.000 --> 01:40:24.000]  Ну, в общем-то, вам это
[01:40:24.000 --> 01:40:26.000]  на практике, скорее всего, не понадобится.
[01:40:26.000 --> 01:40:28.000]  Это просто в образовательных целях
[01:40:28.000 --> 01:40:30.000]  мы так глубоко это все
[01:40:30.000 --> 01:40:32.000]  рассматриваем.
[01:40:32.000 --> 01:40:34.000]  На практике, конечно, вы будете просто писать
[01:40:34.000 --> 01:40:36.000]  sync-await на каком-то готовом рантайме.
[01:40:38.000 --> 01:40:40.000]  Вот.
[01:40:40.000 --> 01:40:42.000]  Так мы изучаем hardcore.rust.
[01:40:42.000 --> 01:40:44.000]  Давайте построим свой рантайм.
[01:40:44.000 --> 01:40:46.000]  Для начала.
[01:40:46.000 --> 01:40:48.000]  Наш таймер-фьюча будет себе представлять
[01:40:48.000 --> 01:40:50.000]  какой-то shared state,
[01:40:50.000 --> 01:40:52.000]  который будет показывать,
[01:40:52.000 --> 01:40:54.000]  готова мы или нет,
[01:40:54.000 --> 01:40:56.000]  и в том числе там внутри будет сидеть какой-то
[01:40:56.000 --> 01:40:58.000]  вейкер, который будет
[01:40:58.000 --> 01:41:00.000]  вызываться тогда, когда мы,
[01:41:00.000 --> 01:41:02.000]  ну, будет вейк вызываться тогда,
[01:41:02.000 --> 01:41:04.000]  когда мы уже будем готовы к
[01:41:04.000 --> 01:41:06.000]  исполнению.
[01:41:06.000 --> 01:41:08.000]  Так, ну тут вроде бы просто
[01:41:08.000 --> 01:41:10.000]  shared state и все.
[01:41:10.000 --> 01:41:12.000]  Этот shared state будет делиться
[01:41:12.000 --> 01:41:14.000]  между нашей фьючей и между тем
[01:41:14.000 --> 01:41:16.000]  тридом, который, собственно, спит.
[01:41:16.000 --> 01:41:18.000]  Ну, соответственно, для того, чтобы
[01:41:18.000 --> 01:41:20.000]  заполиться, нам нужно просто посмотреть
[01:41:20.000 --> 01:41:22.000]  закончили ли
[01:41:22.000 --> 01:41:24.000]  мы исполнение.
[01:41:26.000 --> 01:41:28.000]  То есть мы делаем лог
[01:41:28.000 --> 01:41:30.000]  на время всего пола.
[01:41:30.000 --> 01:41:32.000]  Если мы готовы, ну окей, вернем
[01:41:32.000 --> 01:41:34.000]  ready.
[01:41:34.000 --> 01:41:36.000]  Иначе мы будем
[01:41:36.000 --> 01:41:38.000]  склонируем наш текущий вейкер.
[01:41:38.000 --> 01:41:40.000]  Обратите внимание, пожалуйста, что
[01:41:40.000 --> 01:41:42.000]  вейкер клонировать здесь, это,
[01:41:42.000 --> 01:41:44.000]  естественно, какая-то аллокация.
[01:41:44.000 --> 01:41:46.000]  Это неэффективно.
[01:41:46.000 --> 01:41:48.000]  Это на практике лучше
[01:41:48.000 --> 01:41:50.000]  не делать, но мы это сделаем
[01:41:50.000 --> 01:41:52.000]  в случае нашего простенького варантайма.
[01:41:52.000 --> 01:41:54.000]  Просто вейкер наш запихнем в
[01:41:54.000 --> 01:41:56.000]  timer.future и скажем,
[01:41:56.000 --> 01:41:58.000]  что мы pending на этот раз.
[01:41:58.000 --> 01:42:00.000]  Понимаете ли вы, почему нам вообще нужно
[01:42:00.000 --> 01:42:02.000]  клонировать наш вейкер
[01:42:02.000 --> 01:42:04.000]  каждый раз?
[01:42:10.000 --> 01:42:12.000]  Вообще, просто говоря,
[01:42:12.000 --> 01:42:14.000]  потому что мы не знаем,
[01:42:14.000 --> 01:42:16.000]  у нас может поменяться
[01:42:16.000 --> 01:42:18.000]  рантайм, под которым мы находимся,
[01:42:18.000 --> 01:42:20.000]  например, или что-нибудь такое.
[01:42:22.000 --> 01:42:24.000]  Поэтому нам нужно учитывать то, что у нас
[01:42:24.000 --> 01:42:26.000]  и вейкер может поменяться, соответственно,
[01:42:26.000 --> 01:42:28.000]  даже в рамках одного рантайма.
[01:42:32.000 --> 01:42:34.000]  Ну, как я говорил, обратите внимание
[01:42:34.000 --> 01:42:36.000]  на эту аллокацию, которую мы не хотим делать,
[01:42:36.000 --> 01:42:38.000]  этот клон.
[01:42:38.000 --> 01:42:40.000]  Теперь нам хочется
[01:42:40.000 --> 01:42:42.000]  настоящий конструктор
[01:42:42.000 --> 01:42:44.000]  фьючи написать.
[01:42:44.000 --> 01:42:46.000]  А, еще, кстати говоря,
[01:42:46.000 --> 01:42:48.000]  если вы не хотите просто так делать
[01:42:48.000 --> 01:42:50.000]  клоун на вейкер, то еще есть такая функция
[01:42:50.000 --> 01:42:52.000]  вейкер и willWake называется.
[01:42:52.000 --> 01:42:54.000]  Она проверяет, что
[01:42:54.000 --> 01:42:56.000]  эти два вейкера,
[01:42:56.000 --> 01:42:58.000]  которые вы передадите, они действительно
[01:42:58.000 --> 01:43:00.000]  будут одну и ту же фьючу.
[01:43:00.000 --> 01:43:02.000]  Потому что может такое получиться,
[01:43:02.000 --> 01:43:04.000]  что поменялось фьюч,
[01:43:04.000 --> 01:43:06.000]  и в таком случае вам действительно
[01:43:06.000 --> 01:43:08.000]  нужна какая-то новая информация о вейкере.
[01:43:08.000 --> 01:43:10.000]  А если нет, то в таком случае
[01:43:10.000 --> 01:43:12.000]  мы можем дропнуть наш текущий новый вейкер,
[01:43:12.000 --> 01:43:14.000]  потому что он точно такой же,
[01:43:14.000 --> 01:43:16.000]  как и был. Он будет ту же самую фьючу.
[01:43:22.000 --> 01:43:24.000]  У нас здесь таймер фьюча.
[01:43:26.000 --> 01:43:28.000]  Когда мы ее создаем,
[01:43:28.000 --> 01:43:30.000]  ну, что делаем? Создаем, собственно, sharedState,
[01:43:30.000 --> 01:43:32.000]  создаем клон,
[01:43:32.000 --> 01:43:34.000]  который threadState,
[01:43:34.000 --> 01:43:36.000]  спауним
[01:43:36.000 --> 01:43:38.000]  thread, и внутри него просто
[01:43:38.000 --> 01:43:40.000]  спим какое-то время, и потом пишем
[01:43:40.000 --> 01:43:42.000]  такие встает, ну, все.
[01:43:42.000 --> 01:43:44.000]  Я закончился, и буди.
[01:43:44.000 --> 01:43:46.000]  Я готов совершать прогресс.
[01:43:46.000 --> 01:43:48.000]  Ну, и все.
[01:43:48.000 --> 01:43:50.000]  И таймер фьюч готов.
[01:43:54.000 --> 01:43:56.000]  Окей, давайте.
[01:43:56.000 --> 01:43:58.000]  Мы построили нашу фьючу,
[01:43:58.000 --> 01:44:00.000]  а теперь давайте еще построим экзекьютор,
[01:44:00.000 --> 01:44:02.000]  на котором наши фьючи будут исполняться.
[01:44:02.000 --> 01:44:04.000]  Так, ну, у нас есть экзекьютор, собственно,
[01:44:04.000 --> 01:44:06.000]  с очередью
[01:44:06.000 --> 01:44:08.000]  готовых задач
[01:44:08.000 --> 01:44:10.000]  к исполнению.
[01:44:10.000 --> 01:44:12.000]  Ну, он будет из себя представлять
[01:44:12.000 --> 01:44:14.000]  какой-то ресивер,
[01:44:14.000 --> 01:44:16.000]  из которого он будет просто задача
[01:44:16.000 --> 01:44:18.000]  брать. Вот.
[01:44:18.000 --> 01:44:20.000]  И спаунер, в котором мы можем запихнуть
[01:44:20.000 --> 01:44:22.000]  новую задачу на исполнение.
[01:44:22.000 --> 01:44:24.000]  Еще я объявил
[01:44:24.000 --> 01:44:26.000]  такой новый тип boxFuech, называется, который
[01:44:26.000 --> 01:44:28.000]  из себя представляет просто pinBox.
[01:44:28.000 --> 01:44:30.000]  Pin, но для того, чтобы нам было удобно
[01:44:30.000 --> 01:44:32.000]  сделать, собственно, пол.
[01:44:32.000 --> 01:44:34.000]  И box, ну, да, это
[01:44:34.000 --> 01:44:36.000]  локация, опять же, но нам было
[01:44:36.000 --> 01:44:38.000]  барабанно. Мы пишем простой рентайм.
[01:44:38.000 --> 01:44:40.000]  У нас здесь
[01:44:40.000 --> 01:44:42.000]  будет просто фьюча в боксе.
[01:44:44.000 --> 01:44:46.000]  Итак, задача из себя представляет
[01:44:46.000 --> 01:44:48.000]  какой-то muteX
[01:44:48.000 --> 01:44:50.000]  на, собственно, фьючу нашу и сендер.
[01:44:50.000 --> 01:44:52.000]  То есть task
[01:44:52.000 --> 01:44:54.000]  это обертка нашей фьючи,
[01:44:54.000 --> 01:44:56.000]  которую мы исполняем. Она
[01:44:56.000 --> 01:44:58.000]  нужна для нашего рентайма таска.
[01:44:58.000 --> 01:45:00.000]  Таска.
[01:45:00.000 --> 01:45:02.000]  Наш простенький рентайм.
[01:45:04.000 --> 01:45:06.000]  Итак.
[01:45:06.000 --> 01:45:08.000]  Здесь
[01:45:08.000 --> 01:45:10.000]  вы можете увидеть такую штуку, называется
[01:45:10.000 --> 01:45:12.000]  ArcWake.
[01:45:12.000 --> 01:45:14.000]  Она для вас новенькая.
[01:45:14.000 --> 01:45:16.000]  Она находится в крейте,
[01:45:16.000 --> 01:45:18.000]  который называется
[01:45:18.000 --> 01:45:20.000]  future. Он предназначен
[01:45:20.000 --> 01:45:22.000]  для того, чтобы сделать жизнь тех,
[01:45:22.000 --> 01:45:24.000]  кто пишет синхронный рентайм, для расто
[01:45:24.000 --> 01:45:26.000]  удобнее.
[01:45:26.000 --> 01:45:28.000]  Этот трейд
[01:45:28.000 --> 01:45:30.000]  предназначен для того, чтобы
[01:45:30.000 --> 01:45:32.000]  делать простенький
[01:45:32.000 --> 01:45:34.000]  wake на арке.
[01:45:34.000 --> 01:45:36.000]  То есть, как вы видите, wake by ref
[01:45:36.000 --> 01:45:38.000]  у нас в таком случае будет работать таким
[01:45:38.000 --> 01:45:40.000]  образом. Наверное, достаточно wake by ref.
[01:45:40.000 --> 01:45:42.000]  В данном случае, поэтому мы заимплементим
[01:45:42.000 --> 01:45:44.000]  его.
[01:45:44.000 --> 01:45:46.000]  Просто будем делать так. Если
[01:45:46.000 --> 01:45:48.000]  wake происходит,
[01:45:48.000 --> 01:45:50.000]  в таком случае мы берем task sender
[01:45:50.000 --> 01:45:52.000]  и посылаем
[01:45:52.000 --> 01:45:54.000]  просто в наш текущий рентайм
[01:45:54.000 --> 01:45:56.000]  нашу задачу.
[01:45:56.000 --> 01:45:58.000]  И все.
[01:45:58.000 --> 01:46:00.000]  Все, что нужно задачи,
[01:46:00.000 --> 01:46:02.000]  это просто посылать себе в рентайм.
[01:46:02.000 --> 01:46:04.000]  В следующем году,
[01:46:04.000 --> 01:46:06.000]  я думаю,
[01:46:06.000 --> 01:46:08.000]  мне вот эта часть не нравится,
[01:46:08.000 --> 01:46:10.000]  я хочу здесь написать так, чтобы вы увидели
[01:46:10.000 --> 01:46:12.000]  здесь витейблы.
[01:46:12.000 --> 01:46:14.000]  Это не совсем понятно,
[01:46:14.000 --> 01:46:16.000]  где эти витейблы сидят, но там
[01:46:16.000 --> 01:46:18.000]  на самом деле они появляются
[01:46:18.000 --> 01:46:20.000]  здесь,
[01:46:20.000 --> 01:46:22.000]  на следующем сладе.
[01:46:22.000 --> 01:46:24.000]  New Executor и Spawner
[01:46:24.000 --> 01:46:26.000]  понятны, просто какие-то два канала
[01:46:26.000 --> 01:46:28.000]  и после этого Executor это очередь
[01:46:28.000 --> 01:46:30.000]  готова к исполнению задач, а Spawner это
[01:46:30.000 --> 01:46:32.000]  task sender.
[01:46:32.000 --> 01:46:34.000]  Просто какой-то канал
[01:46:34.000 --> 01:46:36.000]  неограничен.
[01:46:36.000 --> 01:46:38.000]  Потом у нас есть Spawner.
[01:46:38.000 --> 01:46:40.000]  Spawner
[01:46:40.000 --> 01:46:42.000]  делает так.
[01:46:42.000 --> 01:46:44.000]  Он просто берет наш текущий future,
[01:46:44.000 --> 01:46:46.000]  делает
[01:46:46.000 --> 01:46:48.000]  pinbox
[01:46:48.000 --> 01:46:50.000]  и после этого ее отправляет на исполнение.
[01:46:52.000 --> 01:46:54.000]  И мы оперируем опять же task.
[01:46:56.000 --> 01:46:58.000]  Так, мне кажется,
[01:46:58.000 --> 01:47:00.000]  что Андрей даже запутался.
[01:47:00.000 --> 01:47:02.000]  Очень много кодок,
[01:47:02.000 --> 01:47:04.000]  которые требуют постоянно ссылаться назад,
[01:47:04.000 --> 01:47:06.000]  чтобы
[01:47:06.000 --> 01:47:08.000]  играть в полной категории.
[01:47:16.000 --> 01:47:18.000]  Тут примерно понятно,
[01:47:18.000 --> 01:47:20.000]  как работает Spawner.
[01:47:20.000 --> 01:47:22.000]  Здесь очередь задач
[01:47:22.000 --> 01:47:24.000]  и он отправляет в нее задачу.
[01:47:24.000 --> 01:47:26.000]  Executor и Spawner это просто
[01:47:26.000 --> 01:47:28.000]  какой-то Executor, который
[01:47:28.000 --> 01:47:30.000]  представляет каналчик.
[01:47:34.000 --> 01:47:36.000]  Executor, когда мы
[01:47:36.000 --> 01:47:38.000]  делаем на нем точечку ран,
[01:47:38.000 --> 01:47:40.000]  он пытается просто ранить задачу.
[01:47:40.000 --> 01:47:42.000]  До тех пор, пока у нас канал не станет
[01:47:42.000 --> 01:47:44.000]  disconnected.
[01:47:44.000 --> 01:47:46.000]  Помните в лекции про CROSSBIM?
[01:47:46.000 --> 01:47:48.000]  Мы говорили про то, что
[01:47:48.000 --> 01:47:50.000]  канал может стать disconnected,
[01:47:50.000 --> 01:47:52.000]  когда у него закончились все сендеры.
[01:47:54.000 --> 01:47:56.000]  До тех пор, пока сендеры не закончились,
[01:47:58.000 --> 01:48:00.000]  мы пытаемся задачку достать.
[01:48:02.000 --> 01:48:04.000]  Если у нас получилось ее достать,
[01:48:04.000 --> 01:48:06.000]  то в таком случае мы...
[01:48:08.000 --> 01:48:10.000]  Так, сейчас
[01:48:10.000 --> 01:48:12.000]  сам припомни, как тут работает.
[01:48:18.000 --> 01:48:20.000]  Текст.
[01:48:30.000 --> 01:48:32.000]  Мы создаем Waker.
[01:48:32.000 --> 01:48:34.000]  Мы пытаемся
[01:48:34.000 --> 01:48:36.000]  создать Waker заранее.
[01:48:40.000 --> 01:48:42.000]  А потом мы создаем, соответственно,
[01:48:42.000 --> 01:48:44.000]  from Waker контекст.
[01:48:44.000 --> 01:48:46.000]  Контекст, как говорила, такая штука,
[01:48:46.000 --> 01:48:48.000]  которая нужна для того, чтобы
[01:48:48.000 --> 01:48:50.000]  заврапить Waker.
[01:48:50.000 --> 01:48:52.000]  И после этого мы
[01:48:52.000 --> 01:48:54.000]  пытаемся заполить фьючу
[01:48:54.000 --> 01:48:56.000]  с этим контекстом.
[01:48:56.000 --> 01:48:58.000]  Если у него все получится,
[01:48:58.000 --> 01:49:00.000]  то есть мы делаем пол,
[01:49:00.000 --> 01:49:02.000]  а потом она говорит, что она
[01:49:02.000 --> 01:49:04.000]  допустим pending.
[01:49:04.000 --> 01:49:06.000]  Если она ready, то нам все равно,
[01:49:06.000 --> 01:49:08.000]  потому что мы все равно
[01:49:08.000 --> 01:49:10.000]  простенький, ему без разницы,
[01:49:10.000 --> 01:49:12.000]  он принимает на вход
[01:49:12.000 --> 01:49:14.000]  салфпутом,
[01:49:14.000 --> 01:49:16.000]  который просто unity.
[01:49:16.000 --> 01:49:18.000]  Он просто забивает, если у нас
[01:49:18.000 --> 01:49:20.000]  фьюча закончилась.
[01:49:20.000 --> 01:49:22.000]  А если не закончилась, то в таком случае
[01:49:22.000 --> 01:49:24.000]  мы пытаемся просто фьюча-слот,
[01:49:24.000 --> 01:49:26.000]  это сам фьюч.
[01:49:26.000 --> 01:49:28.000]  То есть где-то просто фьючу откладываем
[01:49:28.000 --> 01:49:30.000]  и ждем, пока
[01:49:30.000 --> 01:49:32.000]  нельзя будет ее заполнить.
[01:49:32.000 --> 01:49:34.000]  На самом деле у нас
[01:49:34.000 --> 01:49:36.000]  этот экземпьютер совсем
[01:49:36.000 --> 01:49:38.000]  плохой.
[01:49:38.000 --> 01:49:40.000]  Во-первых, он однопоточный.
[01:49:40.000 --> 01:49:42.000]  Во-вторых,
[01:49:42.000 --> 01:49:44.000]  у него нет
[01:49:44.000 --> 01:49:46.000]  трушных
[01:49:46.000 --> 01:49:48.000]  вейпи
[01:49:48.000 --> 01:49:50.000]  sleeping queue.
[01:49:50.000 --> 01:49:52.000]  Точнее,
[01:49:52.000 --> 01:49:54.000]  ready и sleeping queue.
[01:49:54.000 --> 01:49:56.000]  Поэтому получается, что он
[01:49:56.000 --> 01:49:58.000]  не очень эффективный.
[01:49:58.000 --> 01:50:00.000]  Но тем не менее, он работает.
[01:50:00.000 --> 01:50:02.000]  И вы можете даже пробовать его запустить
[01:50:02.000 --> 01:50:04.000]  таким вот образом.
[01:50:04.000 --> 01:50:06.000]  Кстати говоря, вот пример
[01:50:06.000 --> 01:50:08.000]  из Токио и вот этот весь код,
[01:50:08.000 --> 01:50:10.000]  он будет в двух разных проектах,
[01:50:10.000 --> 01:50:12.000]  когда я выложу эту лекцию.
[01:50:12.000 --> 01:50:14.000]  Потом вы сможете еще раз пересмотреть
[01:50:14.000 --> 01:50:16.000]  это все и потыкаться.
[01:50:16.000 --> 01:50:18.000]  Обратите внимание,
[01:50:18.000 --> 01:50:20.000]  что спаунер мы запихиваем
[01:50:20.000 --> 01:50:22.000]  фьючу, который non-live.
[01:50:22.000 --> 01:50:24.000]  То есть у нас есть какой-то синхронный блок,
[01:50:24.000 --> 01:50:26.000]  он возвращает
[01:50:26.000 --> 01:50:28.000]  фьючу какую-то новую,
[01:50:28.000 --> 01:50:30.000]  которая из себя представляет какую-то
[01:50:30.000 --> 01:50:32.000]  штуку с тремя стейтами получается.
[01:50:32.000 --> 01:50:34.000]  end state,
[01:50:34.000 --> 01:50:36.000]  waiting on timer фьюча
[01:50:36.000 --> 01:50:38.000]  собственно начало, enter.
[01:50:40.000 --> 01:50:42.000]  Ну и timer фьюча
[01:50:42.000 --> 01:50:44.000]  в нашем случае это уже live фьюча.
[01:50:46.000 --> 01:50:48.000]  Потом мы можем спаунер наш
[01:50:48.000 --> 01:50:50.000]  дропнуть для того, чтобы наш
[01:50:50.000 --> 01:50:52.000]  экзекутер перешел в disconnected state
[01:50:52.000 --> 01:50:54.000]  и он
[01:50:54.000 --> 01:50:56.000]  корректно
[01:50:56.000 --> 01:50:58.000]  завершил свою работу,
[01:50:58.000 --> 01:51:00.000]  а не ждал бесконечную сдачу.
[01:51:02.000 --> 01:51:04.000]  Все.
[01:51:04.000 --> 01:51:06.000]  Так.
[01:51:06.000 --> 01:51:08.000]  Я надеюсь, примерно понятно,
[01:51:08.000 --> 01:51:10.000]  как и должен работать в runtime
[01:51:10.000 --> 01:51:12.000]  врасте. Ну просто есть две очереди.
[01:51:12.000 --> 01:51:14.000]  А ну прям в конкурс
[01:51:14.000 --> 01:51:16.000]  будет. Сейчас я обсудим потихонечку.
[01:51:16.000 --> 01:51:18.000]  Есть какие-то
[01:51:18.000 --> 01:51:20.000]  вопросы, потому что сейчас был мысль.
[01:51:20.000 --> 01:51:22.000]  Что-то с экзекутером я не понял.
[01:51:22.000 --> 01:51:24.000]  Вот мы там, если
[01:51:24.000 --> 01:51:26.000]  фьюч в случае pending, мы пишем обратно
[01:51:26.000 --> 01:51:28.000]  в фьюч слот.
[01:51:28.000 --> 01:51:30.000]  И что дальше с этим слотом
[01:51:30.000 --> 01:51:32.000]  происходит?
[01:51:32.000 --> 01:51:34.000]  Мы ж типа из канала забрали.
[01:51:34.000 --> 01:51:36.000]  Нам, наверное, по-хорошему уже обратно
[01:51:36.000 --> 01:51:38.000]  в канал кинуть.
[01:51:38.000 --> 01:51:40.000]  Да. Ну это не идеальный просто.
[01:51:40.000 --> 01:51:42.000]  Не идеальный экзекутер.
[01:51:42.000 --> 01:51:44.000]  Поэтому ты можешь
[01:51:44.000 --> 01:51:46.000]  ты не идеальность, которую видел, просто
[01:51:46.000 --> 01:51:48.000]  смириться с ней, а потом
[01:51:48.000 --> 01:51:50.000]  писать сам что-то получше.
[01:51:50.000 --> 01:51:52.000]  То есть у нас
[01:51:52.000 --> 01:51:54.000]  даже таймер фьюча не работает.
[01:51:54.000 --> 01:51:56.000]  Таймер фьюча работает.
[01:51:56.000 --> 01:51:58.000]  Она идет именно с канала.
[01:51:58.000 --> 01:52:00.000]  По-моему две фьючи уже работать не будут.
[01:52:00.000 --> 01:52:02.000]  Да, но это, конечно, почему работает.
[01:52:02.000 --> 01:52:04.000]  Мы достаем фьюч, она все еще не pending,
[01:52:04.000 --> 01:52:06.000]  потому что мы в время еще
[01:52:06.000 --> 01:52:08.000]  едят.
[01:52:12.000 --> 01:52:14.000]  Так, ну пошли давайте конклужину, чтобы
[01:52:14.000 --> 01:52:16.000]  вот это все проговорить еще раз.
[01:52:16.000 --> 01:52:18.000]  У нас
[01:52:18.000 --> 01:52:20.000]  асинхронная рентайма, вроде же, работает
[01:52:20.000 --> 01:52:22.000]  вокруг фьюча.
[01:52:22.000 --> 01:52:24.000]  То есть у нас все устроено вокруг фьюча.
[01:52:24.000 --> 01:52:26.000]  Как какое-то вычисление, которое вы можете
[01:52:26.000 --> 01:52:28.000]  попробовать совершить какой-то прогресс.
[01:52:28.000 --> 01:52:30.000]  Заполить его.
[01:52:30.000 --> 01:52:32.000]  Вот.
[01:52:32.000 --> 01:52:34.000]  То есть фьюча это что-то, что вы пытаетесь
[01:52:34.000 --> 01:52:36.000]  полить беспрерывно.
[01:52:38.000 --> 01:52:40.000]  Есть два типа фьюча. Это лиффьюча,
[01:52:40.000 --> 01:52:42.000]  которая рентайм проводится,
[01:52:42.000 --> 01:52:44.000]  и нонлиффьюча, которые создаются
[01:52:44.000 --> 01:52:46.000]  асинком и эвейтом.
[01:52:46.000 --> 01:52:48.000]  Стоит машина, которая
[01:52:48.000 --> 01:52:50.000]  лепит друг с другом фьючи для того,
[01:52:50.000 --> 01:52:52.000]  чтобы получилась какая-то фьюча побольше.
[01:52:52.000 --> 01:52:54.000]  Кстати, тоже интересный факт.
[01:52:54.000 --> 01:52:56.000]  Когда фьючи были еще найтли,
[01:52:56.000 --> 01:52:58.000]  на них же пытались что-то писать.
[01:52:58.000 --> 01:53:00.000]  Вот Фуксия, всем известная
[01:53:00.000 --> 01:53:02.000]  официальная система на Rust
[01:53:02.000 --> 01:53:04.000]  и Гугловская,
[01:53:04.000 --> 01:53:06.000]  когда писали какие-то тесты,
[01:53:06.000 --> 01:53:08.000]  у них создавались фьючи.
[01:53:08.000 --> 01:53:10.000]  Просто они были не оптимизированы тогда дико
[01:53:10.000 --> 01:53:12.000]  и создавались какие-то ужасные стейт-машины.
[01:53:12.000 --> 01:53:14.000]  Там создалась фьюча, которая была размером
[01:53:14.000 --> 01:53:16.000]  400 килобайт.
[01:53:16.000 --> 01:53:18.000]  Это очень много.
[01:53:18.000 --> 01:53:20.000]  То есть почти мегабайт, представьте себе.
[01:53:20.000 --> 01:53:22.000]  Фьюча.
[01:53:22.000 --> 01:53:24.000]  Это какие-то дикие размеры для стейт-машины.
[01:53:24.000 --> 01:53:26.000]  Сейчас они уже очень хорошо оптимизированы.
[01:53:26.000 --> 01:53:28.000]  И вот
[01:53:28.000 --> 01:53:30.000]  то, что я хотел проговорить,
[01:53:30.000 --> 01:53:32.000]  это то, что у нас
[01:53:32.000 --> 01:53:34.000]  вот эта вот машина,
[01:53:34.000 --> 01:53:36.000]  стейт-машина, которую мы создаем,
[01:53:36.000 --> 01:53:38.000]  у нее каждый шаг,
[01:53:38.000 --> 01:53:40.000]  ну это же енумы, поэтому у нас
[01:53:40.000 --> 01:53:42.000]  енум будет иметь размер наибольшего
[01:53:42.000 --> 01:53:44.000]  из стейтов. Соответственно,
[01:53:44.000 --> 01:53:46.000]  у нас оптимальный размер
[01:53:46.000 --> 01:53:48.000]  для этой стейт-машины.
[01:53:50.000 --> 01:53:52.000]  Async, как я говорил, это способ
[01:53:52.000 --> 01:53:54.000]  такой покрасить функцию для того, чтобы мы
[01:53:54.000 --> 01:53:56.000]  видели, что она синхронна.
[01:53:58.000 --> 01:54:00.000]  I await это штука,
[01:54:00.000 --> 01:54:02.000]  которая предназначена для того, чтобы
[01:54:02.000 --> 01:54:04.000]  стейт, очередной
[01:54:04.000 --> 01:54:06.000]  стейт-машины объявить.
[01:54:06.000 --> 01:54:08.000]  То есть что мы ждем на этой фьюче.
[01:54:08.000 --> 01:54:10.000]  Эта фьюча дальше уже пойдет, там ждать
[01:54:10.000 --> 01:54:12.000]  другие фьючи, либо она ли фьюча и будет пытаться
[01:54:12.000 --> 01:54:14.000]  выполнить себя.
[01:54:16.000 --> 01:54:18.000]  Вот. Потом у нас есть
[01:54:18.000 --> 01:54:20.000]  ну I await это
[01:54:20.000 --> 01:54:22.000]  может создать self-referential
[01:54:22.000 --> 01:54:24.000]  структурку, и поэтому, чтобы
[01:54:24.000 --> 01:54:26.000]  структурку обозначить
[01:54:26.000 --> 01:54:28.000]  self-referential и нормально с ними работать,
[01:54:28.000 --> 01:54:30.000]  у нас есть pin.
[01:54:30.000 --> 01:54:32.000]  Вот. Когда вы конструируете
[01:54:32.000 --> 01:54:34.000]  pin, то в таком случае обещайте, что
[01:54:34.000 --> 01:54:36.000]  объект, который находится по ссылке
[01:54:36.000 --> 01:54:38.000]  на pin, никогда
[01:54:38.000 --> 01:54:40.000]  не будет move-аться после этого момента.
[01:54:42.000 --> 01:54:44.000]  Если ваш unpin объект
[01:54:44.000 --> 01:54:46.000]  то в таком случае вам
[01:54:46.000 --> 01:54:48.000]  без разницы
[01:54:48.000 --> 01:54:50.000]  на промес, который вы даете
[01:54:50.000 --> 01:54:52.000]  создавая pin.
[01:54:52.000 --> 01:54:54.000]  Это обещание без разницы.
[01:54:58.000 --> 01:55:00.000]  Когда есть такая возможность
[01:55:00.000 --> 01:55:02.000]  не пишите pin.
[01:55:02.000 --> 01:55:04.000]  Не пользуйтесь pin, потому что
[01:55:04.000 --> 01:55:06.000]  это лишний промес, и вам придется
[01:55:06.000 --> 01:55:08.000]  следить за тем, что вы действительно
[01:55:08.000 --> 01:55:10.000]  корректно его используете.
[01:55:10.000 --> 01:55:12.000]  Если у вас есть такая возможность,
[01:55:12.000 --> 01:55:14.000]  не давайте
[01:55:14.000 --> 01:55:16.000]  такую гарантию, что вы что-то
[01:55:16.000 --> 01:55:18.000]  не будете двигать.
[01:55:20.000 --> 01:55:22.000]  OK.
[01:55:22.000 --> 01:55:24.000]  С pin мы разобрались.
[01:55:24.000 --> 01:55:26.000]  Когда вы пытаетесь заранить future,
[01:55:26.000 --> 01:55:28.000]  то в первую очередь пытаетесь ее заполить.
[01:55:30.000 --> 01:55:32.000]  Если она
[01:55:32.000 --> 01:55:34.000]  не получилась
[01:55:34.000 --> 01:55:36.000]  сделав прогресс и она закончилась,
[01:55:36.000 --> 01:55:38.000]  то все хорошо, иначе она говорит
[01:55:38.000 --> 01:55:40.000]  у меня прогресс не получилось до конца
[01:55:40.000 --> 01:55:42.000]  свой довести.
[01:55:42.000 --> 01:55:44.000]  И в таком случае вместо
[01:55:44.000 --> 01:55:46.000]  полинга предлагается
[01:55:46.000 --> 01:55:48.000]  пользоваться callback,
[01:55:48.000 --> 01:55:50.000]  который нужен
[01:55:50.000 --> 01:55:52.000]  runtime, чтобы сообщить
[01:55:52.000 --> 01:55:54.000]  о том, что мы
[01:55:54.000 --> 01:55:56.000]  готовы совершать прогресс.
[01:55:56.000 --> 01:55:58.000]  В получении
[01:55:58.000 --> 01:56:00.000]  мы находимся в COMTA waiting queue,
[01:56:00.000 --> 01:56:02.000]  а потом мы хотим
[01:56:02.000 --> 01:56:04.000]  передвинуться в
[01:56:04.000 --> 01:56:06.000]  polling queue.
[01:56:06.000 --> 01:56:08.000]  Так.
[01:56:08.000 --> 01:56:10.000]  Затем мы хотим,
[01:56:10.000 --> 01:56:12.000]  как я сказал,
[01:56:12.000 --> 01:56:14.000]  мы ждем, пока
[01:56:14.000 --> 01:56:16.000]  вейкер нам пошлет сигнал,
[01:56:16.000 --> 01:56:18.000]  что
[01:56:18.000 --> 01:56:20.000]  наша очередь,
[01:56:20.000 --> 01:56:22.000]  что мы готовы
[01:56:22.000 --> 01:56:24.000]  совершать прогресс.
[01:56:24.000 --> 01:56:26.000]  Люди
[01:56:26.000 --> 01:56:28.000]  не нужен вейкер.
[01:56:28.000 --> 01:56:30.000]  Если вы будете писать на Rast,
[01:56:30.000 --> 01:56:32.000]  скорее всего вам не нужно будет
[01:56:32.000 --> 01:56:34.000]  знать настолько глубоко, как устроен runtime.
[01:56:34.000 --> 01:56:36.000]  Это нужно тем, кто пишет
[01:56:36.000 --> 01:56:38.000]  runtime, собственно, асинхронно.
[01:56:38.000 --> 01:56:40.000]  Таким, как Рома Липовский.
[01:56:40.000 --> 01:56:42.000]  Если вам это нравится,
[01:56:42.000 --> 01:56:44.000]  то в таком случае вам нужно хорошо с этим разобраться.
[01:56:44.000 --> 01:56:46.000]  Асинхронность Rast
[01:56:46.000 --> 01:56:48.000]  устроена хорошо и красиво.
[01:56:48.000 --> 01:56:50.000]  Так, есть ли
[01:56:50.000 --> 01:56:52.000]  общий вопрос про асинхронность?
[01:56:52.000 --> 01:56:54.000]  В таком случае получается
[01:56:54.000 --> 01:56:56.000]  все.
[01:56:56.000 --> 01:56:58.000]  Это была наша последняя лекция
[01:56:58.000 --> 01:57:00.000]  по языку Rast,
[01:57:00.000 --> 01:57:02.000]  и мы теперь Растасина.
[01:57:02.000 --> 01:57:04.000]  Если вы все поняли с лекцией,
[01:57:04.000 --> 01:57:06.000]  то вам остается только
[01:57:06.000 --> 01:57:08.000]  это все отработать,
[01:57:08.000 --> 01:57:10.000]  тогда вы точно Растасин.
[01:57:10.000 --> 01:57:12.000]  Так, может, есть какие-то вопросы,
[01:57:12.000 --> 01:57:14.000]  пожелания, предложения по курсу,
[01:57:14.000 --> 01:57:16.000]  все, что угодно, любые мысли.
[01:57:22.000 --> 01:57:24.000]  Да, все, что я планировал,
[01:57:24.000 --> 01:57:26.000]  можно разобраться.
[01:57:26.000 --> 01:57:28.000]  Но если вы все поняли с лекцией,
[01:57:28.000 --> 01:57:30.000]  то вам остается только это все отработать,
[01:57:30.000 --> 01:57:32.000]  тогда вы точно Растасин.
[01:57:32.000 --> 01:57:34.000]  Так, может, есть какие-то вопросы,
[01:57:34.000 --> 01:57:36.000]  пожелания, предложения по курсу,
[01:57:36.000 --> 01:57:38.000]  все, что угодно, любые мысли.
[01:57:40.000 --> 01:57:42.000]  Ну, видите, в силу базы.
[01:57:42.000 --> 01:57:44.000]  Это предложения положена
[01:57:44.000 --> 01:57:46.000]  до следующего года,
[01:57:46.000 --> 01:57:48.000]  тогда будет первая полноценная версия.
[01:57:48.000 --> 01:57:50.000]  Ну, ты можешь сказать предложение сейчас,
[01:57:50.000 --> 01:57:54.000]  если тебе интересно.
[01:57:54.000 --> 01:57:56.000]  Сложновато, возможно, я не знаю.
[01:57:56.000 --> 01:57:58.000]  Я старался
[01:57:58.000 --> 01:58:00.000]  понятнее рассказывать,
[01:58:00.000 --> 01:58:02.000]  мне не получилось везде
[01:58:02.000 --> 01:58:04.000]  рассказать LEGITparallel,
[01:58:06.000 --> 01:58:08.000]  или не везде просто,
[01:58:08.000 --> 01:58:14.000]  Но тем не менее, не все вещи просты, но для синхронизм без Рома Липовского я вообще не представляю, как вам рассказывать.
[01:58:14.000 --> 01:58:20.000]  Там пришлось бы очень много видений делать. Очень большое.
[01:58:20.000 --> 01:58:26.000]  Ну, в общем-то, да, просто на предложение в лэшет таракура мы не читаем.
[01:58:26.000 --> 01:58:30.000]  Иначе конец хвоста живых нет.
[01:58:32.000 --> 01:58:33.000]  Ладно.
