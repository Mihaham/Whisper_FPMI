[00:00.000 --> 00:09.540]  Итак, смотрите, в прошлый раз у нас в конце был
[00:09.540 --> 00:10.540]  спортстейбл.
[00:10.540 --> 00:12.660]  Давайте ократканно напомним задачу, какую мы решали
[00:12.660 --> 00:13.660]  с помощью спортстейбла.
[00:13.660 --> 00:18.500]  Спортстейбл на русский вообще переводит разреженная
[00:18.500 --> 00:19.500]  таблица.
[00:19.500 --> 00:22.980]  Но так никто не говорит, все говорят спортстейбл.
[00:22.980 --> 00:28.660]  У нас был статический, то есть не изменяющийся
[00:28.660 --> 00:29.660]  спортстейбл.
[00:29.660 --> 00:30.660]  У нас был статический, то есть не изменяющийся
[00:30.660 --> 00:31.660]  спортстейбл.
[00:31.660 --> 00:32.660]  У нас был статический, то есть не изменяющийся
[00:32.660 --> 00:33.660]  спортстейбл.
[00:33.660 --> 00:34.660]  У нас был статический, то есть не изменяющийся
[00:34.660 --> 00:35.660]  спортстейбл.
[00:35.660 --> 00:36.660]  У нас был статический, то есть не изменяющийся
[00:36.660 --> 00:37.660]  спортстейбл.
[00:37.660 --> 00:38.660]  У нас был статический, то есть не изменяющийся
[00:38.660 --> 00:39.660]  спортстейбл.
[00:39.660 --> 00:40.660]  У нас был статический, то есть не изменяющийся
[00:40.660 --> 00:41.660]  спортстейбл.
[00:41.660 --> 00:42.660]  У нас был статический, то есть не изменяющийся
[00:42.660 --> 00:43.660]  спортстейбл.
[00:43.660 --> 00:44.660]  У нас был статический, то есть не изменяющийся
[00:44.660 --> 00:45.660]  спортстейбл.
[00:45.660 --> 00:46.660]  У нас был статический, то есть не изменяющийся
[00:46.660 --> 00:47.660]  спортстейбл.
[00:47.660 --> 00:48.660]  У нас был статический, то есть не изменяющийся
[00:48.660 --> 00:49.660]  спортстейбл.
[00:49.660 --> 00:50.660]  У нас был статический, то есть не изменяющийся
[00:50.660 --> 00:51.660]  спортстейбл.
[00:51.660 --> 00:52.660]  У нас был статический, то есть не изменяющийся
[00:52.660 --> 00:53.660]  спортстейбл.
[00:53.660 --> 00:54.660]  У нас был статический, то есть не изменяющийся
[00:54.660 --> 00:55.660]  спортстейбл.
[00:55.660 --> 00:56.660]  У нас был статический, то есть не изменяющийся
[00:56.660 --> 00:57.660]  спортстейбл.
[00:57.660 --> 00:58.660]  У нас был статический, то есть не изменяющийся
[00:58.660 --> 00:59.660]  спортстейбл.
[00:59.660 --> 01:00.660]  У нас был статический, то есть не изменяющийся
[01:00.660 --> 01:01.660]  спортстейбл.
[01:01.660 --> 01:02.660]  У нас был статический, то есть не изменяющийся
[01:02.660 --> 01:03.660]  спортстейбл.
[01:03.660 --> 01:04.660]  У нас был статический, то есть не изменяющийся
[01:04.660 --> 01:05.660]  спортстейбл.
[01:05.660 --> 01:06.660]  У нас был статический, то есть не изменяющийся
[01:06.660 --> 01:07.660]  спортстейбл.
[01:07.660 --> 01:08.660]  У нас был статический, то есть не изменяющийся
[01:08.660 --> 01:09.660]  спортстейбл.
[01:09.660 --> 01:10.660]  У нас был статический, то есть не изменяющийся
[01:10.660 --> 01:11.660]  спортстейбл.
[01:11.660 --> 01:12.660]  У нас был статический, то есть не изменяющийся
[01:12.660 --> 01:13.660]  спортстейбл.
[01:13.660 --> 01:14.660]  У нас был статический, то есть не изменяющийся
[01:14.660 --> 01:15.660]  спортстейбл.
[01:15.660 --> 01:16.660]  У нас был статический, то есть не изменяющийся
[01:16.660 --> 01:17.660]  спортстейбл.
[01:17.660 --> 01:18.660]  У нас был статический, то есть не изменяющийся
[01:18.660 --> 01:19.660]  спортстейбл.
[01:19.660 --> 01:20.660]  У нас был статический, то есть не изменяющийся
[01:20.660 --> 01:21.660]  спортстейбл.
[01:21.660 --> 01:22.660]  У нас был статический, то есть не изменяющийся
[01:22.660 --> 01:23.660]  спортстейбл.
[01:23.660 --> 01:24.660]  У нас был статический, то есть не изменяющийся
[01:24.660 --> 01:25.660]  спортстейбл.
[01:25.660 --> 01:26.660]  У нас был статический, то есть не изменяющийся
[01:26.660 --> 01:27.660]  спортстейбл.
[01:27.660 --> 01:28.660]  У нас был статический, то есть не изменяющийся
[01:28.660 --> 01:29.660]  спортстейбл.
[01:29.660 --> 01:30.660]  У нас был статический, то есть не изменяющийся
[01:30.660 --> 01:31.660]  спортстейбл.
[01:31.660 --> 01:32.660]  У нас был статический, то есть не изменяющийся
[01:32.660 --> 01:33.660]  спортстейбл.
[01:33.660 --> 01:34.660]  У нас был статический, то есть не изменяющийся
[01:34.660 --> 01:35.660]  спортстейбл.
[01:35.660 --> 01:36.660]  У нас был статический, то есть не изменяющийся
[01:36.740 --> 01:38.740]  Чтобы найти сумму на отрезке, мне нужно как бы сложить
[01:38.740 --> 01:40.980]  на левом отрезке, на правом отрезке и как бы вычесть
[01:40.980 --> 01:43.980]  вот это вот пересечение, но вот это вот переченье
[01:43.980 --> 01:45.980]  мы никак не можем вычесть, потому что оно может вообще
[01:45.980 --> 01:46.980]  не являться степенью двойки.
[01:46.980 --> 01:50.180]  Вот оказывается, что можно как-то это пообщить, написать
[01:50.180 --> 01:53.260]  disjointsportstable, там немножко по-другому все выглядит,
[01:53.260 --> 01:56.060]  и мы научимся отвечать на все такие запросы, там
[01:56.060 --> 01:59.340]  сумма на отрезке, предзвение на отрезке, особенно,
[01:59.340 --> 02:01.780]  например, если у вас есть задача в стиле, есть у
[02:01.780 --> 02:06.540]  вас много матриц, а0, а1 и так далее, а и-1, много
[02:06.540 --> 02:10.020]  матриц, и поступают запросы, произведение куска матриц
[02:10.020 --> 02:12.100]  на отрезке, то есть вам нужно найти произведение
[02:12.100 --> 02:16.500]  с l-той матрицы по r-той, что-нибудь вот такое, умножить, умножить
[02:16.500 --> 02:20.300]  на a r-тую, то есть тут понятно, уже никакие префиксные
[02:20.300 --> 02:22.940]  суммы не подойдут, нельзя посчитать произведение
[02:22.940 --> 02:25.500]  с нулевой по r-той и с нулевой по l-минус первую и потом
[02:25.500 --> 02:27.860]  как бы поделить да одно на другое, потому что оно
[02:27.860 --> 02:31.180]  может вообще не делиться, или обратную может быть
[02:31.180 --> 02:32.180]  сложно найти.
[02:32.180 --> 02:35.660]  Вот, и в таком случае, например, тоже подойдет disjointsportstable,
[02:35.660 --> 02:39.340]  это позволит на отрезке найти вам какую-то величину,
[02:39.340 --> 02:40.340]  какую-то функцию от элементов.
[02:40.340 --> 02:45.540]  Вот, хорошо, но это все работает только если массив статический
[02:45.540 --> 02:46.940]  и никаких изменений не поступает.
[02:46.940 --> 02:50.100]  Сегодня мы будем изучать дерево отрезков, которое
[02:50.100 --> 02:52.980]  умеет все то же самое, только еще позволяет вам как-то
[02:52.980 --> 02:56.100]  менять массив дерево отрезков.
[02:56.100 --> 02:58.060]  Задача более-менее та же самая, на отрезках найти
[02:58.060 --> 03:01.740]  что-нибудь, типа там сумму, произведение, максимум,
[03:01.740 --> 03:04.420]  и при этом еще массив может меняться, то есть могут
[03:04.420 --> 03:07.380]  поступать запросы в стиле и это элемент поменять
[03:07.380 --> 03:18.740]  на какой-то x, сделать присвоение, а это равно x.
[03:18.740 --> 03:25.780]  Модельная задача такая, модельная задача, есть у
[03:25.780 --> 03:30.060]  вас опять массив, а 0, 1, и так далее, а n-1, и два типа
[03:30.060 --> 03:31.060]  запросов.
[03:31.060 --> 03:34.300]  Первый запрос, это изменение в точке, то есть по какой-то
[03:34.380 --> 03:38.500]  позиции и по значению вал вам нужно выполнить присваивание,
[03:38.500 --> 03:42.300]  а посты равно вал, то есть просто заменить один элемент
[03:42.300 --> 03:43.300]  другим.
[03:43.300 --> 03:45.660]  Ну и второй это опять, скажем, сумма на отрезке, по двум
[03:45.660 --> 03:50.340]  индексам lr вам нужно найти сумму чисел с l того по rt,
[03:50.340 --> 03:55.980]  a l плюс a l плюс 1, плюс так далее, плюс a r, ну вот такая самая
[03:55.980 --> 03:57.980]  простая задача для дерево отрезков.
[04:04.300 --> 04:10.460]  Так, давайте мы для удобства предположим, что n является
[04:10.460 --> 04:12.500]  степень двойки.
[04:12.500 --> 04:16.820]  Будем считать, что n это степень двойки, n равно 2 в каторе
[04:16.820 --> 04:18.100]  для какого-то целого k.
[04:18.100 --> 04:26.340]  Тогда построим следующее дерево, я нарисую пример
[04:26.340 --> 04:32.460]  для n равного 8, листьями будут выступать наши 8 элементов
[04:32.620 --> 04:33.620]  массива.
[04:33.620 --> 04:39.580]  Вот эти 8 элементов, соответственно, здесь а0, а1, и так далее
[04:39.580 --> 04:40.580]  а7.
[04:40.580 --> 04:45.580]  Затем мы эти вершинки объединяем по парам и подвешиваем
[04:45.580 --> 04:46.780]  к одному общему предку.
[04:46.780 --> 04:49.060]  Значит, мы рисуем вершинку, которая является родителем
[04:49.060 --> 04:53.740]  а0 и а1, то же самое делаем с а2 и а3, объединяем их как
[04:53.740 --> 04:58.260]  бы в одну высшую вершинку, то же самое с а4 и а5, ну
[04:58.260 --> 05:00.860]  и с последним двумя, а6 и а7.
[05:01.460 --> 05:06.300]  И в каждой вершине мы будем хранить сумму как бы в поддереве.
[05:06.300 --> 05:08.780]  Вот здесь будем хранить а0 плюс а1, то есть здесь
[05:08.780 --> 05:11.620]  знаем сумму на отрезке длины 2.
[05:11.620 --> 05:14.020]  Здесь тоже сумма на отрезке длины 2 у нас будет а2 плюс
[05:14.020 --> 05:21.460]  а3, тут а4 плюс а5, здесь а6 плюс а7.
[05:21.460 --> 05:26.940]  Продолжаем опять, склеиваем пары вершин в одну высшую,
[05:26.940 --> 05:27.940]  вот так будет и вот так.
[05:27.940 --> 05:31.420]  Ну и соответственно, число написано в вершине будет
[05:31.420 --> 05:34.460]  равно сумме во всем поддереве, то есть сумма вот этих вот
[05:34.460 --> 05:38.860]  чисел а0 и а1, а2 и а3 или по-другому, сумма просто того, что написано
[05:38.860 --> 05:41.340]  в детях, потому что с левой стороны это а0 и а1, справа
[05:41.340 --> 05:42.340]  а2 плюс а3.
[05:42.340 --> 05:44.340]  И здесь число, которое мы будем хранить равно просто
[05:44.340 --> 05:49.780]  а0 плюс а1 плюс а2 плюс а3, здесь то же самое, все элементы
[05:49.780 --> 05:50.780]  с четвертого по седьмой.
[05:50.780 --> 05:53.820]  Напишу а4 плюс и так далее плюс а7.
[05:53.820 --> 05:58.140]  Ну и в конце самая верхняя вершина будет корнем нашего
[05:58.140 --> 06:02.060]  дерева и в ней число будет равно сумме всего, что написано
[06:02.060 --> 06:05.020]  во всех листьях, а0, а1, а2 и так далее вплоть до
[06:05.020 --> 06:06.020]  а7.
[06:06.020 --> 06:08.620]  Или что то же самое, сумма в двух детях, в левом и в
[06:08.620 --> 06:09.620]  правом.
[06:09.620 --> 06:14.940]  Здесь будет просто сумма всех чисел, а0 по а7.
[06:14.940 --> 06:18.340]  Вот построили такую структуру, такое дерево, бинарное
[06:18.340 --> 06:20.980]  дерево, бинарное значит, что у каждой вершины максимум
[06:20.980 --> 06:21.980]  два ребенка.
[06:22.140 --> 06:25.940]  Бинарное дерево, в каждой вершине записываем число,
[06:25.940 --> 06:29.500]  равное сумме чисел в листьях этого поддерева, вот здесь
[06:29.500 --> 06:30.500]  какое поддерево.
[06:30.500 --> 06:31.500]  Вот это вот все.
[06:31.500 --> 06:34.860]  Из этого листья это четыре вершинки нижние, мы складываем
[06:34.860 --> 06:37.740]  числа, которые там написаны и пишем это в вершинку, в
[06:37.740 --> 06:38.740]  корень этого поддерева.
[06:38.740 --> 06:44.580]  Ну например, вот мы такое как-то сделаем.
[06:44.580 --> 06:47.260]  Теперь давайте поймем, как отвечать на наши запросы
[06:47.260 --> 06:48.260]  наших двух типов.
[06:48.620 --> 06:49.620]  Поцвал и Элер.
[06:49.620 --> 06:52.420]  Ну, поцвал самый простой.
[06:52.420 --> 06:56.100]  Представьте, что у меня какое-нибудь опятое меняется,
[06:56.100 --> 06:59.460]  оно раньше было х, а теперь станет у.
[06:59.460 --> 07:03.380]  Раньше было 10, стало 7, как-то поменялось это число.
[07:03.380 --> 07:05.740]  Тогда, чтобы мне корректно пересчитать все вот эти
[07:05.740 --> 07:07.460]  значения, чтобы в каждой вершине было правильное
[07:07.460 --> 07:12.340]  по-прежнему число, равное сумме с листьев поддерева,
[07:12.340 --> 07:14.260]  тогда мне нужно поменять все такие вершины, где
[07:14.260 --> 07:15.260]  участвовало опять.
[07:15.260 --> 07:18.060]  То есть, если меняю только одно число, то меняются
[07:18.060 --> 07:21.060]  суммы только содержащие это число опять.
[07:21.060 --> 07:23.060]  Ну, а таких вершин всего 4.
[07:23.060 --> 07:27.060]  Вот это, вот это, вот это и вот это.
[07:27.060 --> 07:30.060]  Больше ни в каких вершинах опять не участвует.
[07:30.060 --> 07:31.060]  Ни в каких суммах опять не участвует.
[07:31.060 --> 07:34.060]  Значит, просто давайте пройдемся по вот этому вот восходящему пути
[07:34.060 --> 07:36.060]  от этого листика до корня.
[07:36.060 --> 07:39.060]  И во всех вершинах сделаем такую поправку, что если
[07:39.060 --> 07:41.060]  там раньше был х, то теперь у.
[07:41.060 --> 07:44.060]  То есть, по сути, сумма увеличивается на у-х.
[07:44.060 --> 07:46.060]  Если у меня здесь была какая-то сумма, то она меняется
[07:46.060 --> 07:48.060]  увеличивается на у-х.
[07:48.060 --> 07:50.060]  То есть, я делал во всех этих точках.
[07:50.060 --> 07:52.060]  Плюс равно у-х.
[07:52.060 --> 07:54.060]  Плюс равно у-х.
[07:54.060 --> 07:56.060]  Плюс равно у-х.
[07:56.060 --> 07:58.060]  Ну, здесь не забываем тоже в листике изменить.
[07:58.060 --> 08:00.060]  Плюс равно у-х.
[08:00.060 --> 08:06.060]  Если у меня х как бы стерлось, а у добавилось, то это как раз разность.
[08:06.060 --> 08:08.060]  Так, понятно?
[08:08.060 --> 08:09.060]  Вот.
[08:09.060 --> 08:12.060]  Ну и, собственно, так и будет работать наш обработка
[08:12.060 --> 08:13.060]  первого типа запроса.
[08:14.060 --> 08:16.060]  Мы просто идем от листика до корня.
[08:16.060 --> 08:18.060]  Ну или, наоборот, от корня до нужного листика.
[08:18.060 --> 08:21.060]  И меняем все суммы в соответствии с тем, как поменялось число.
[08:21.060 --> 08:24.060]  Да, как бы насколько оно изменилось, настолько меняется и сумма,
[08:24.060 --> 08:25.060]  в которую оно входит.
[08:25.060 --> 08:27.060]  Это простой кусок.
[08:27.060 --> 08:30.060]  Чуть посложнее вот эти вот запросы типа lr.
[08:33.060 --> 08:35.060]  Запросы типа lr.
[08:35.060 --> 08:41.060]  Так, ну давайте ответим на запрос, когда l равно 2, а r семерки.
[08:42.060 --> 08:45.060]  l равно 2, а r семерки.
[08:45.060 --> 08:50.060]  Наша цель это найти в этом дереве как можно меньше вершин,
[08:50.060 --> 08:53.060]  которые в сумме как раз покрывают все элементы нашего отрезка lr
[08:53.060 --> 08:55.060]  ровно по одному разу.
[08:55.060 --> 08:59.060]  И здесь нам подойдет, скажем, вот такие две вершины.
[08:59.060 --> 09:02.060]  Вот эта вершинка, которая покрывает a2 и a3, да, то есть контролирует под дерево
[09:02.060 --> 09:03.060]  со второго по третий элемент.
[09:03.060 --> 09:07.060]  И вот эта вершина, которая контролирует с четвертого по седьмой элемента.
[09:07.060 --> 09:10.060]  И как раз если мы знаем сумму второго и третьего элемента,
[09:10.060 --> 09:13.060]  а также сумму элементов с четвертого по седьмой, то если мы их сложим,
[09:13.060 --> 09:16.060]  мы получим сумму как раз на нужном нам отрезке, со второго по седьмой.
[09:18.060 --> 09:20.060]  Получилось вот обойтись двумя вершинками.
[09:20.060 --> 09:23.060]  То есть если я как-то эти две вершинки найду, если я пойму, что отрезок 2,7
[09:23.060 --> 09:26.060]  вот разбивается на эти две вершины, что он целиком контролирует
[09:26.060 --> 09:30.060]  со этими двумя вершинами, то мы как бы знаем сумму.
[09:30.060 --> 09:33.060]  Нужно просто два эти числа сложить.
[09:33.060 --> 09:35.060]  Ну, разумеется, там можно как-нибудь по-другому покрыть.
[09:35.060 --> 09:38.060]  Скажем, можно вместо вот этой вершинкой взять две вот эти.
[09:38.060 --> 09:41.060]  Тогда у меня число вершин увеличится, но сумма останется той же.
[09:43.060 --> 09:47.060]  Это немножко неэффективно, потому что вместо того, чтобы складывать два числа,
[09:47.060 --> 09:49.060]  мы можем обратиться к их сумме.
[09:49.060 --> 09:52.060]  Если мы знаем их сумму, то уже нет смысла спускаться в под дерево.
[09:52.060 --> 09:55.060]  Нет смысла у вершинки брать какие-то ее детей.
[09:55.060 --> 09:58.060]  То есть если мы взяли вершину, то детей уже брать не нужно.
[10:00.060 --> 10:02.060]  Ну и так будет работать в общем случае.
[10:02.060 --> 10:05.060]  Нам нужно будет как-то отрезок LR, на котором мы ищем сумму,
[10:05.060 --> 10:09.060]  представить в виде объединения вот этих вот покрывающих вершин.
[10:09.060 --> 10:14.060]  Что это какое-то под дерево покрывает 2-3, а это под дерево покрывает 4-5-6-7.
[10:14.060 --> 10:18.060]  И вот нам нужно как-то найти эти вершинки, которые покрывают целиком наш отрезок.
[10:19.060 --> 10:24.060]  Так, ну хорошо, давайте вот эта идея, как будет работать дерево отрезков,
[10:24.060 --> 10:27.060]  давайте мы напишем все нужные процедуры.
[10:28.060 --> 10:30.060]  Поймем, за сколько это работает, поймем всякую корректность.
[10:30.060 --> 10:35.060]  Давайте опять, как у нас было в бинарной куче когда-то, давайте считать, что у меня вершинки
[10:35.060 --> 10:38.060]  номируются последовательно целыми числями, начиная с единицы.
[10:39.060 --> 10:42.060]  1, 2, 3, 4, 5, 6, ну и так далее.
[10:43.060 --> 10:47.060]  Что у вершинки есть два сына, у вершинки V есть сын 2V и 2V плюс 1.
[10:51.060 --> 10:52.060]  2V и 2V плюс 1.
[10:54.060 --> 10:58.060]  Вот, а также давайте у каждой вершинки еще помнить, ну или как-то поддерживать,
[10:59.060 --> 11:00.220]  какой отрезок она контролирует.
[11:01.060 --> 11:05.060]  Вот это вот корневая вершина, она контролирует весь отрезок с нулевого по 7-ой элемент.
[11:06.060 --> 11:10.060]  Дальше, ее левый сын контролирует отрезок с нулевого по 3-ий уже элемент.
[11:11.060 --> 11:14.060]  То есть мы просто смотрим, все, что находится под деревья И выписываем, какие нам есть номера.
[11:14.060 --> 11:16.060]  Ну это понятно дело, всегда какой-то подотрезок.
[11:16.060 --> 11:19.060]  Себя какой-то подотрезок, там левая граница, правая граница.
[11:20.060 --> 11:23.060]  Поэтому, также вместе с каждой вершиной мы будем как-то еще передавать,
[11:23.060 --> 11:25.060]  какой именно подотрезок она контролирует.
[11:25.060 --> 11:33.700]  подотрезок она контролирует. Вот я буду это обозначать TLTR, подотрезок массива,
[11:33.700 --> 11:52.000]  который контролируется в этой вершиной, вершиной V. Ну и тогда, если я знаю, какой
[11:52.000 --> 11:56.220]  отрезок контролируется вершиной V, то как понять, какие подотрезки контролируются
[11:56.220 --> 12:00.360]  двумя сыновьями этой вершинки? Очень просто, нужно посчитать полусумму наших
[12:00.360 --> 12:08.500]  чисел TLTR. Давайте я напишу прямо сразу, так как это можно писать в коде, TL
[12:08.500 --> 12:14.280]  плюс TR больше больше один. Вот, ну про битовые сдвиги мы немножко уже делали в
[12:14.280 --> 12:17.720]  прошлый раз. Значит, битовый сдвиг вправо на единичку, это значит, вот есть у вас
[12:17.720 --> 12:22.560]  какое-то битовое число, и вы как бы, вот здесь находятся младшие биты, ну левое,
[12:22.560 --> 12:26.360]  первое и так далее, и вы сдвигаете его вправо на единицу. То есть, как бы вот такое
[12:26.360 --> 12:30.600]  число записываете, и просто те биты, которые вылезли за пределы вот этой
[12:30.600 --> 12:34.840]  границы, за нулевой бит как бы, вы их отбрасываете. Поэтому, по сути, вы просто
[12:34.840 --> 12:39.440]  избавляетесь от младшего битика и все сдвигаете на единичку. Вот эти вот
[12:39.440 --> 12:44.640]  биты, это просто то, что раньше у вас было все левее, чем младший. И это как раз
[12:44.880 --> 12:49.360]  деление пополам. Вы просто отбрасываете младший бит и все сдвигаете на ее место.
[12:49.360 --> 12:53.300]  Это вот как раз деление пополам. Целочисленное деление пополам. То есть, если здесь было 0,
[12:53.300 --> 12:56.640]  то это просто деление пополам. Если там была единичка, то мы как бы сдвинули единичку и ее
[12:56.640 --> 13:03.440]  отбросили. То есть, это деление пополам с округлением вниз. Ну хорошо, тогда у левого
[13:03.440 --> 13:07.440]  сына мы пишем, что отрезок,
[13:07.440 --> 13:24.480]  Отрезок, который она контролирует, это tLtm, а здесь tm плюс 1tr.
[13:24.480 --> 13:32.400]  Так, сразу скажу, что если вы уже когда-то видели деревоотрезков и привыкли, скажем,
[13:32.400 --> 13:36.240]  писать его на полуинтервалах, когда правая граница не включена, ну вот, sorry,
[13:36.240 --> 13:39.640]  я пишу на отрезках, потому что называется деревоотрезков, по крайней мере, на русском,
[13:39.640 --> 13:46.240]  поэтому у меня все на отрезках. Так что если вам не привычно, ну извините. Ну понятно,
[13:46.240 --> 13:50.280]  как мы говорим, что левая половина уходит влево, правая половина уходит вправо. Вот ровно это
[13:50.280 --> 13:55.280]  здесь и написано, что первая половина элементов контролируется левым сыном, вторая правая. Ну
[13:55.280 --> 14:03.400]  все, тогда мы готовы написать, скажем, процедуру update. Давайте сначала скажем, что пусть t в
[14:03.880 --> 14:12.040]  это число, храняющиеся в этой вершине, число, храняющиеся в вершине v, то есть какая там
[14:12.040 --> 14:19.640]  сумма написана? В вершине v. Тогда процедура update реализуется очень просто. Void update.
[14:19.640 --> 14:32.440]  Да, давайте так и сделаем. 1, 0, n-1. Так, так, так, sorry, sorry. Нет, давайте я все-таки уйду на
[14:32.440 --> 14:55.800]  другую доску. Давайте я для лобста буду считать, что я уже понял вот эту разность y-x. То есть я
[14:55.800 --> 15:00.720]  понимаю, что мне нужно поменять число x на число y, и по сути мне важно только то, насколько он
[15:00.720 --> 15:04.640]  изменился. Мне не важно старое значение, не важно новое. Мне нужно просто знать вот эту поправку,
[15:04.640 --> 15:10.160]  поправочку y-x, насколько меняются все элементы. Давайте тогда передавать как раз эту поправку.
[15:10.160 --> 15:18.040]  То есть я встаю в какой-то вершине, которая контролирует отрезок tr, tr, и мне нужно элемент
[15:18.040 --> 15:27.560]  в позиции pos изменить на дельту, увеличить на дельту. Вот, значит, сначала я встаю в корня и
[15:27.560 --> 15:33.440]  понимаю, что я контролирую весь массив с 0 по n-1 элемент. И мне нужно поменять там элемент в
[15:33.440 --> 15:38.880]  какой-то позиции на сколько-то. Мы поняли, что мне нужно пройти, по сути, от корня до этого элемента,
[15:38.880 --> 15:43.960]  и все на этом пути увеличить на дельту. Все суммы увеличить на дельту. Поэтому давайте сразу это
[15:43.960 --> 15:50.480]  сделаем, что tvt плюс равно дельта. Мы увеличиваем значение в текущей точке на v, потому что сейчас
[15:50.480 --> 15:54.960]  там участвует этот элемент, который изменился, поэтому сумма меняется. Ну а дальше скажем,
[15:54.960 --> 15:59.640]  если мы уже спустились в лист, то есть если контролируемый под отрезок вырожденный состоит
[15:59.640 --> 16:05.040]  из одного элемента, то можно сразу сделать ретёрн. Нам уже дошли до листа, мы все обновили,
[16:05.040 --> 16:09.080]  больше сделать нечего. Иначе нужно спуститься в одного из двух санавей, либо влево, либо вправо.
[16:09.080 --> 16:18.240]  Для этого мы найдем полусумму границ, которые мы контролируем. И это как раз вот этот tm,
[16:18.240 --> 16:22.960]  это разделитель, что меньше или равнее tm уходит влево, больше tm уходит вправо. Значит,
[16:22.960 --> 16:27.920]  нам нужно написать, что если pos, то есть если изменяемый элемент меньше либо равен этой границе,
[16:27.920 --> 16:39.400]  меньше либо равен tm, тогда мне нужно рекурсивно запуститься от левого сына. Update v2 tail tm pos
[16:39.400 --> 16:50.280]  delta. Я спустился в левого сына, у него вершинка, его номер это v2, как мы договорились. Контролирует
[16:50.280 --> 16:55.440]  он подотрезок tail tm, тоже как тут нарисовано. Ну а pos и delta мы не меняем, мне нужно по-прежнему
[16:55.440 --> 17:01.120]  элемент в позиции pos увеличить на delta. Так, это случай, когда нужно идти в левого сына. Иначе,
[17:01.120 --> 17:06.560]  когда нужно идти вправого сына, мы запускаемся аналогично рекурсивно от правого сына. Здесь
[17:06.560 --> 17:16.080]  будет v2 plus 1, потому что это его номер. tm plus 1 tr, это контролируемый подотрезок, pos delta не меняется.
[17:16.080 --> 17:26.160]  pos и delta не меняются. Все, вот весь апдейт. Еще раз, мы запускаемся от корня. Давайте я
[17:26.160 --> 17:35.520]  напишу, что из мейна при обработке запроса мы запускаемся от корня. Update 1, 0, n-1, pos delta.
[17:35.520 --> 17:44.080]  pos delta. Мы стартуем в корне, который контролирует весь массив, то есть весь
[17:44.080 --> 17:48.080]  подотрезок с нулевого поэнонсферого элемента. И как-то там спускаемся, каждый раз понимая,
[17:48.080 --> 17:52.120]  нам нужно идти в левого сына или вправого. Вот если pos не больше половинка элементов,
[17:52.120 --> 17:56.520]  то есть находится как бы в левом сыне, то мы туда идем, иначе нужно идти вправо, туда идем.
[17:56.520 --> 18:05.880]  Так, есть ли вопросы по этому кусочку? Хорошо, тогда давайте здесь же сразу заметим, что время
[18:05.880 --> 18:12.280]  работы этой процедуры логарифмично по n, потому что если мы построили вот такое наше бинарное
[18:12.280 --> 18:17.160]  дерево, на нижнем уровне которого n листьев, а дальше как бы у меня все постоянно делится пополам,
[18:17.160 --> 18:22.000]  то есть я объединяю пары вершин на предыдущем уровне, и так дальше поднимаюсь. У меня число
[18:22.000 --> 18:25.400]  вершин каждый раз уменьшается вдвое, на каждом уровне при подъеме вверх. Значит,
[18:25.400 --> 18:30.160]  уровне логарифмичное количество, уровне всего логарифм, глубина моего дерева логарифм. Ну,
[18:30.160 --> 18:34.480]  а значит, поскольку я по сути просто спускаюсь как-то от корня до листика, значит время
[18:34.480 --> 18:41.320]  работы логарифмично, просто не больше, чем глубина дерева. Так, хорошо, теперь давайте напишем сумму.
[18:46.520 --> 18:55.360]  Теперь давайте напишем int getSum. Значит, опять мы находимся в какой-то вершинке
[18:55.360 --> 19:04.120]  которая контролирует tail-to-air, отрезок tail-to-air, и нам нужно найти сумму с подотреска LR.
[19:04.120 --> 19:13.440]  int L, int R. Нужно найти сумму на отрезке LR. Запускаться мы также будем от корня,
[19:13.440 --> 19:19.120]  мы стоим в корне, нам нужно в каком-то отрезке найти сумму. Самый простой случай, самый идеальный
[19:19.120 --> 19:25.640]  случай, это когда мы пришли в вершину, целиком совпадающую с нашим отрезком. Если TL равно L и
[19:25.640 --> 19:34.480]  TR равно R. То есть мы пришли в вершину, в которой хранится точно то число, которое мы ищем,
[19:34.480 --> 19:40.320]  хранится вершина равная сумме элементов с L-to-Apr. Давайте просто его тогда вернем, раз нам нужна эта
[19:40.320 --> 19:48.720]  сумма, то давайте просто ее вернем в качестве ответа. На это и будет то, что нужно. Иначе, иначе,
[19:48.720 --> 19:52.920]  мне опять нужно потенциально разветвиться налево и направо сына, понять, куда нужно идти. Вот это
[19:52.920 --> 19:59.240]  мы сейчас тоже сделаем. Значит, считаем опять наш разделитель, полусумму координат TL-TR.
[19:59.240 --> 20:11.080]  Ну и давайте здесь же мы заведем переменную ответ равной нулю. ans равно нулю. И дальше может быть
[20:11.080 --> 20:15.640]  следующее, может быть такое, что мне придется разветвиться в обоих сыновей. Ну, например,
[20:15.640 --> 20:20.360]  давайте какую-нибудь такую картинку нарисую. Вот есть вершина, есть отрезок, которые она
[20:20.360 --> 20:27.400]  контролирует, а мне нужна какая-то вот такая сумма. Тогда я частично задеваю как бы левого сына и
[20:27.400 --> 20:31.640]  соответственно частично задеваю правого сына. То есть мне может быть нужно спуститься и влево,
[20:31.640 --> 20:35.760]  и вправо как бы. Мне нужно разветвиться и туда, и туда. Если раньше я спускался только в одну из
[20:35.760 --> 20:40.680]  двух веточек, то здесь, возможно, придется в обе. Ну ничего страшного, в обе мы тогда и спустимся.
[20:40.680 --> 20:45.800]  Значит, что значит, что нам нужно идти влево? Это значит, что хотя бы один элемент нашего
[20:45.800 --> 20:49.760]  массива находится влево под деревом. Ну, это то же самое, что просто самый левый элемент массива
[20:49.760 --> 20:55.560]  находится в этом по дереву. Поэтому если у меня в принципе хоть кто-то лежит слева, тогда мне
[20:55.560 --> 21:05.680]  нужно к ответу прибавить getSum от левого ребенка. Так, давайте продолжим. Левый ребенок сдается
[21:05.680 --> 21:19.840]  такими координатами. А дальше нужно как-то сузить отрезок LR на то, что остается. Если есть такое
[21:19.840 --> 21:24.160]  частичное затрагивание левого сына и частичное затрагивание правого сына, то у меня отрезок
[21:24.160 --> 21:27.840]  LR, когда я спускаюсь к левому сыну, немножко меняется. У него левая граница остается,
[21:27.840 --> 21:34.080]  а правая она становится просто Tm. Потому что вот этот кусок как бы отбрасывается. Поэтому давайте
[21:34.080 --> 21:44.760]  здесь напишем такие границы. L минимум из R и Tm. Ну, тогда как раз если отрезок лежит
[21:44.760 --> 21:49.760]  частично слева и частично справа, то из этих двух чисел минимальным будет Tm. И граница как
[21:49.760 --> 21:57.480]  раз вот будет там же, где заканчивается граница вот этого левого сына. Иначе, давайте другую
[21:57.480 --> 22:02.760]  картинку в этом же месте. Если мой отрезок, на котором я ищу сумму, далеко лежит в левом сыне,
[22:02.760 --> 22:07.720]  вот что-то такое, тогда у него нелиньер не надо менять, просто мне нужно найти ответ с левого сына,
[22:07.720 --> 22:13.440]  а вправо я даже не пойду. Вот, поэтому тогда минимум из R будет равен R, и я просто нахожу
[22:13.440 --> 22:20.040]  сумму на целиком на этом отрезке. То есть тут два случая. Так, ну и нужно еще понять, нужно ли нам
[22:20.040 --> 22:25.960]  идти вправого сына. Здесь уже будет не else, а отдельный if. Если имеет смысл идти вправого сына,
[22:25.960 --> 22:31.920]  то есть правая граница отрезка попадает вправо в правого сына. Если R больше, ну давайте так
[22:31.920 --> 22:42.800]  и напишем, если R больше равно tm плюс 1. Если хоть кто-то из отрезка LR лежит в правом сыне,
[22:42.800 --> 22:48.720]  тогда нам придется дойти, и мы запускаемся рекурсивно от этого правого сына. GetSum значит
[22:48.720 --> 22:58.080]  v2 плюс 1. Отрезок контролируемый это tm плюс 1 tr. Ну и здесь тоже надо как-то сузить наш отрезок,
[22:58.080 --> 23:05.200]  на который мы ищем сумму. Можно написать так. Максимум из L и tm плюс 1, запятая R.
[23:11.200 --> 23:17.560]  Ну, то же самое. Да, как бы у нас, если отрезок частично слева, частично справа, то его правую
[23:17.560 --> 23:22.440]  границу нужно оставить на месте, а вместо левой написать tm плюс 1. Да, потому что tm плюс 1,
[23:22.440 --> 23:26.960]  то вот левая граница правого сына. Если же отрезок LR целиком лежит справа, то тогда этот
[23:26.960 --> 23:33.160]  максимум будет просто равен L, и отрезок наш не нужно менять, все хорошо. Так, ну и в конце нужно
[23:33.160 --> 23:45.600]  написать return ans. Return ans, и скобка закрывается. После того, как вернули ответ. Вот, то есть по
[23:45.600 --> 23:50.960]  сути алгоритм, ну вот прям максимально тупой, да, он что делает? Он говорит, что если мы ищем то,
[23:50.960 --> 23:55.600]  что нужно, то есть если мы знаем то, что нужно, то мы это сразу возвращаем. Иначе мы говорим,
[23:55.600 --> 24:00.080]  ага, ну значит нам нужно куда-то спуститься. Давайте поймем, нам надо идти влево. Если надо,
[24:00.080 --> 24:05.720]  то спускаемся и находим сумму на соответствующем подотрезке. Если надо вправо, то тоже спускаемся,
[24:05.720 --> 24:10.240]  там находим сумму и их складываем. То есть как-то учли сумму слева сына, как-то справого,
[24:10.240 --> 24:15.640]  их сложили и вернули в качестве ответа. То есть просто рекурсивно спустились в детей. Понятно?
[24:15.640 --> 24:23.200]  Вот. Ну, оказывается, что даже такой наивный алгоритм, который в общем-то довольно простой,
[24:23.200 --> 24:28.240]  он работает тоже за алгоритм на запрос. Значит, это мы сейчас докажем.
[24:39.000 --> 24:45.080]  Давайте я напишу так, где-то сам 0 запятая n-1 запятая lr, то есть когда я запускаю под
[24:45.080 --> 24:54.720]  корня в поисках суммы на каком-то отрезке lr, работает, ну здесь уже от log n, что у нас
[24:54.720 --> 25:00.200]  оценка логарифа. Возможно, он даже, он иногда отрабатывает за от 1, если не нужна сумма на
[25:00.200 --> 25:04.160]  всем массиве, скажем, он просто смотрит в корень, понимает, что в корне хранится сумма со всего
[25:04.160 --> 25:08.320]  отрезка, ее возвращает, никуда не спускается. То есть если, скажем, отрезок очень крутой,
[25:08.320 --> 25:12.840]  то это может работать даже быстрее, чем логариф, быстрее, чем логариф. Но обычно, конечно,
[25:13.760 --> 25:19.640]  обычно, конечно достигается вот логарифа. Ну не важно. Значит, почему отработать за логарифом?
[25:19.640 --> 25:24.200]  Почему вообще-то может не работать за логарифом? Проблема в том, что мы можем offer вершинки пойти
[25:24.200 --> 25:29.280]  и влево, и вправо. Раньше у нас было хорошо когда мы писали апдейт. Мы спускаемся к каждой вершине
[25:29.280 --> 25:33.480]  только либо влево, либо вправо и тогда время работы пропорционально просто ну длине пути,
[25:33.480 --> 25:37.760]  как мы спускаемся, это максимум логарифа, максимум глубина. А здесь мы в какой-то вершине
[25:37.760 --> 25:41.960]  можем пойти и влево, и вправо. И тогда, ну а кто нам сказал, что мы не будем витвиться как бы
[25:41.960 --> 25:47.600]  полностью вообще, почему мы не пройдем все дерево, например. Ну, например, по следующей причине.
[25:47.600 --> 25:53.240]  Давайте посмотрим, как именно наш алгоритм GetSum спускается по дереву. Вот он как-то встал в корень
[25:53.240 --> 26:00.480]  и идет, идет, идет, идет. Давайте посмотрим первый несколько шагов, пока он не витвится,
[26:00.480 --> 26:05.080]  пока он из этих двух запусков делает только один, либо левый, либо правый. Вот как-то он так
[26:05.080 --> 26:10.800]  спускался. Потом дошел до первой вишенки, где пришлось разветвиться и пойти рекурсивно и влево,
[26:10.800 --> 26:18.280]  и вправо. Что это значит? Это значит, что отрезок, на котором мы ищем сумму, он частично лежит,
[26:18.280 --> 26:26.440]  давайте я нарисую под дерево вот так, который я контролирую с этой вишенкой В. Тогда, значит,
[26:26.440 --> 26:31.120]  отрезок, на котором нам нужна сумма, он какой-то такой. Он частично слева, частично справа.
[26:31.120 --> 26:39.280]  Тогда мне нужно разветвиться. Ну вот я разветвился. А дальше смотрите, какой интересный факт,
[26:39.280 --> 26:44.680]  что если я нахожусь где-то вот здесь вот, и мне, скажем, приходится опять витвиться,
[26:44.680 --> 26:53.720]  то я уже от правого сына вниз спускаться рекурсивно не буду. Еще раз, давайте я сейчас
[26:53.720 --> 26:58.040]  фокусируюсь только на левом поддереве, то, что слева. Если я нахожусь здесь в какой-то
[26:58.040 --> 27:04.480]  вершинке, и мне опять нужно разветвиться, пойти и влево, и вправо, то тогда из правого сына я
[27:04.480 --> 27:10.000]  уже обязательно точно не буду витвиться. Потому что, что значит, что я вот здесь, давайте я введу
[27:10.000 --> 27:16.160]  эту букву У. Что значит, что я в вершинке У разветвился? Это значит, что у меня, так давайте я немножко
[27:16.160 --> 27:22.520]  перенесу, вот так. Это значило бы, что у меня частично отрезок, на который мы ищем сумму,
[27:22.520 --> 27:28.160]  попадает в правого сына У, и частично влево. Но тогда это в частности значит, что когда мы
[27:28.160 --> 27:32.080]  спускаемся в правого сына, мне нужно просто взять в нем сумму, и нам нет смысла спускаться ниже,
[27:32.080 --> 27:37.320]  чем вот этот правый сын. Потому что мы понимаем, что правая граница у меня сейчас вот здесь,
[27:37.320 --> 27:43.120]  и если я спустился и сюда, и сюда, то получается, что мне нужно целиком вот этот овальчик, и еще
[27:43.120 --> 27:49.040]  что-то слева. Ну, значит, мне нет смысла спускаться ниже, чем вот этот правый сын. Я до него дошел,
[27:49.200 --> 27:55.760]  и дальше вниз никуда не пойду. То есть, если я вот в этом левом поддереве, вот здесь, когда-то и
[27:55.760 --> 28:02.960]  ветвлюсь, или ветвлюсь, да, наверное, если я когда-то поветвился, тогда правый сын больше не дает потомков.
[28:02.960 --> 28:08.160]  То есть, я как бы поветвился, а здесь тогда уже у меня будет пустая ветка. Поэтому, на самом деле,
[28:08.160 --> 28:13.520]  каждое ветвление, оно, по сути, это только движение влево. То есть, я как бы взял сумму
[28:13.520 --> 28:17.560]  справого сына, а рекурсивно, содержательный рекурсивный запуск у меня только из левого сына.
[28:17.560 --> 28:22.840]  Опять там может быть какое-то ветвление, или там просто втуск влево. Короче, что-то сложное, но главное,
[28:22.840 --> 28:27.400]  что каждое ветвление порождает только одну содержательную ветку. Правое сразу заканчивается.
[28:27.400 --> 28:35.320]  Понятная идея? То же самое у меня находится в правом поддереве. Если я вот от В разведвился,
[28:35.320 --> 28:41.560]  и в какой-то момент там как-то прошел, и у какой-то вершинки W опять разведвился, пошел и влево,
[28:41.560 --> 28:46.760]  и вправо. Но это значит тогда, что от левой вершинки я никуда вниз не пойду, да, потому что у меня
[28:46.760 --> 28:53.440]  целиком этот отрезок меня интересует. Вот, я его добавляю к ответу. Значит, из левого сына W
[28:53.440 --> 28:58.400]  я вниз никуда не пойду. Я могу пойти вниз рекурсивно только от правого сына. Значит, по сути,
[28:58.400 --> 29:03.840]  у меня, ну скажем так, спуск куда-то вправо вот здесь, и спуск куда-то влево вот здесь. То есть,
[29:03.840 --> 29:08.520]  по сути, у меня просто два спуска после того, как я дошел до вершинки W. Поэтому число вершин,
[29:08.520 --> 29:13.880]  которые я рассматриваю, оно по-прежнему логарифмично от глубины дерева. Никогда не может быть, ну то есть,
[29:13.880 --> 29:18.720]  вот здесь мы, собственно, показали, что если я разведвился здесь, то я дальше не пойду в одну из
[29:18.720 --> 29:24.080]  дверь. Ну все, поэтому как бы это не то, что там какое-то очень широкое ветвление, а обычно,
[29:24.080 --> 29:27.880]  если я и поветвился, то одна из веток мертвая. То есть, я там спустился вниз и дальше никуда не
[29:27.880 --> 29:34.480]  пойду. Вот, поэтому время работает действительно логарифмично. Число вершин, число посещенных
[29:34.480 --> 29:51.640]  вершин есть от log n. Ну все, число посещенных — это как раз время работы алгоритма. Все,
[29:51.640 --> 29:57.600]  поэтому мы работаем за логарифм. Вот, и на этом мы нашу задачу, собственно, решили. Нашу задачу
[29:57.600 --> 30:05.640]  обновления в точке и сумма на отрезке мы решили. Так, есть ли вопросы по этой части?
[30:14.040 --> 30:26.840]  Хорошо. Тогда идем дальше. Давайте рассмотрим вторую задачу. Это каты 0 на отрезке.
[30:26.840 --> 30:37.040]  Каты 0 на отрезке. Задача такая. Есть у вас опять массив чисел а0 и так далее, а n-1. Только давайте
[30:37.040 --> 30:47.880]  считать, что все числа — это нули и единицы. Нули и единицы. И поступают опять два типа запросов.
[30:47.880 --> 30:55.600]  Первый — это update в точке, то есть изменение в точке по значению pos и значению val. Мне
[30:55.600 --> 31:01.960]  нужно pos-элемент поменять на val, сделать такое присваивание. Второй тип запроса — это найти
[31:01.960 --> 31:09.280]  каты 0 на отрезке. То есть вам сообщают какой-то подотрезок lr, а также число k. И вы вот рассматриваете
[31:09.280 --> 31:15.280]  ваш отрезок с l to the power element и как бы должны при счете слева направо найти среди нулей каты.
[31:15.280 --> 31:19.160]  То есть у вас там, не знаю, куча единиц, встретился 0. Это был первый 0. Потом опять куча единиц,
[31:19.160 --> 31:25.520]  второй 0 и так далее, и так далее. Вам нужно найти каты 0. Ну, позицию катова 0, в смысле позицию.
[31:25.520 --> 31:45.840]  Найти позицию катова 0 на отрезке lr. Вот. Хорошо, такая задача. Тоже ее мы сейчас решим с помощью
[31:46.000 --> 31:55.280]  деревоотрезков. Так, давайте теперь в вершине. Если мы раньше в вершине хранили сумму из листьев
[31:55.280 --> 32:00.840]  под дерево, то давайте теперь хранить количество нулей среди листьев под дерево. Теперь у меня t
[32:00.840 --> 32:14.880]  от v. Это количество нулей среди вот этих вот чисел a с индексом tl, a с индексом tl плюс 1 и так
[32:14.880 --> 32:24.280]  далее, а с индексом tr, где tl tr это отрезок, который соответствует вершинке v. Тл tr. Количество
[32:24.280 --> 32:31.120]  нулей на вот этом отрезке. Тогда, смотрите, нашу задачу можно немножко упростить. Можно, во-первых,
[32:31.120 --> 32:35.960]  по сути, откинуть правую границу. Можно откинуть правую границу. Потому что, что значит, что мы
[32:35.960 --> 32:40.560]  ищем каты 0 на отрезке? Ну вот есть у меня какое-то начало l, да? Тогда, по сути, мне нужно просто идти
[32:40.560 --> 32:45.480]  отсюда слева направо, и каждый нулик, который мы видим там, увеличивает счетчик. Когда счетчик
[32:45.480 --> 32:50.640]  дошел до k, нужно вывести текущий нуль. Поэтому, по сути, правая граница мне не нужна. Правая
[32:50.640 --> 32:54.200]  граница нужна только для того, чтобы понять, а есть ли вообще на этом отрезке k нулей. То есть,
[32:54.200 --> 32:59.760]  если я вдруг иду-иду-иду и в поисках каты 0 вышел за отрезок, вот здесь стоит каты 0, то тогда нужно
[32:59.760 --> 33:06.200]  сказать, что на нашем отрезке l-r каты 0 просто нет. То есть, по сути, r, она у нас только такая
[33:06.200 --> 33:11.440]  декоративная, что если мы найдем просто каты 0 в порядке прохода от l-того элемента, то нужно
[33:11.440 --> 33:16.040]  будет просто его позицию сравнить с r-кой. Если она больше, чем r, то, значит, он вылезает за наш
[33:16.040 --> 33:32.000]  отрезок. Поэтому r нам, в принципе, не очень важно. Поэтому, по сути, достаточно искать
[33:32.000 --> 33:49.560]  каты 0 просто от l-того элемента и до конца массива. То есть, нам это r, в принципе, не важно,
[33:49.560 --> 33:54.920]  мы просто если найдем каты 0 на отрезке от l до конца, то мы просто сравним эту позицию с r-кой,
[33:54.920 --> 33:57.800]  если она меньше или равна, то мы его нашли. Если больше, то, значит, просто там нету
[33:57.800 --> 34:03.640]  стольких нулей. На отрезке l-р нету стольких нулей. Это первое замечание. Второе замечание в том,
[34:03.640 --> 34:09.320]  что на самом деле и l-та мне особо не нужно. Потому что, смотрите, что мы сделали? Что мы
[34:09.320 --> 34:14.160]  делаем точнее? Вот есть у меня l-тая позиция. Я иду как бы отсюда слева направо в поисках каты 0.
[34:14.160 --> 34:21.040]  Но тогда, смотрите, если я найду число 0 вот здесь вот на префиксе, не включая l-тый элемент,
[34:21.040 --> 34:28.240]  если я знаю, что здесь, скажем, m нулей, то поиск k-того нуля, начиная с l-того элемента,
[34:28.240 --> 34:38.520]  каты 0, это, по сути, просто поиск k плюс m-того нуля с начала массива. Но если мы знаем,
[34:38.520 --> 34:42.880]  что здесь их m, а здесь мы находим каты, то, по сути, мы просто ищем k плюс m-тый сначала.
[34:42.880 --> 34:57.840]  Значит, и l-та нам тоже не особо важно. Итак, чтобы найти каты 0, начиная с l-того элемента,
[34:57.840 --> 35:11.520]  каты 0, начиная с l-того элемента, достаточно найти m плюс l-тый 0, sorry, m плюс k-тый 0,
[35:11.520 --> 35:22.280]  m плюс k-тый 0 с начала массива. Ну где m, это вот как раз количество нулей от нулевого элемента
[35:22.280 --> 35:33.280]  до l-1. Вот. Ну отлично. То есть, по сути, нам теперь что достаточно сделать? Мы стоим в позиции l,
[35:33.280 --> 35:39.040]  считаем количество нулевого отрезка от 0 до l-1. Это мы умеем делать с помощью нашего дерева
[35:39.040 --> 35:43.160]  отрезков. Если у меня в вершинке хранится число нулевого отрезка, то, по сути, как раз мне
[35:43.160 --> 35:47.880]  нужно там как-то спуститься точно так же, как мы искали сумму. Также у меня здесь будет в вершинке
[35:47.880 --> 35:53.640]  хранится число нулей, тогда я на этом отрезке могу найти число нулей. То есть, как я раньше
[35:53.640 --> 35:59.440]  считал сумму, так теперь считаю число нулей. Так вот, я нашел это количество нулей, нашел m,
[35:59.440 --> 36:04.880]  а дальше мне нужно уже независимо от отрезка lr, то есть все, я про lr забываю, мне нужно просто во
[36:04.880 --> 36:12.040]  всем массиве сначала с нулевого элемента найти вот такой вот 0, 0 с таким номером. Вот, хорошо.
[36:12.040 --> 36:15.960]  То есть, теперь мы как бы забываем про то, что у нас была задача на подотреске, мы решаем задачу
[36:15.960 --> 36:20.840]  на всем массиве. Просто нам нужен 0 с каким-то номером от начала массива.
[36:32.840 --> 36:43.120]  Давайте я его назову k-большое, k и 0 от начала массива. И здесь нам тоже понадобится дерево
[36:43.120 --> 36:50.280]  отрезков. Ну, пригодится скорее. Смотрите, идея следующая. Вот есть у вас корень нашего дерева,
[36:50.280 --> 36:57.720]  который контролирует весь массив. Есть левый сын, есть правый сын. Тогда понятно, что если в левом
[36:57.720 --> 37:03.200]  поддереве, то есть вот в поддереве, которое контролируется левым сыном нулей хотя бы k, то есть
[37:03.200 --> 37:08.360]  если вот это вот число хотя бы k, тогда ответ точно в нем. Понятно, что k и 0 тогда лежит в
[37:08.360 --> 37:13.720]  левом поддереве. Если здесь хотя бы k, то он точно там. Иначе, если их здесь меньше, чем k, то мне
[37:13.720 --> 37:19.640]  нужно из k вычесть количество нулей, которые здесь лежат, и перейти вправо. Например, если k равно
[37:19.640 --> 37:25.640]  тройке, а здесь мы знаем, что слева находится 2 нуля, то мне нужно искать просто первый 0 вот здесь.
[37:25.640 --> 37:33.600]  Понятно? Просто как бы k и 0. Если здесь их меньше k, то мне нужно вычесть то количество, сколько их
[37:33.600 --> 37:42.800]  здесь есть из k, и искать теперь уже с новым значением k, k и 0 в правом поддереве. Ну и, собственно,
[37:42.800 --> 37:49.240]  код будет ровно такой. Мы сначала пытаемся понять, есть ли слева хотя бы k нулей. Если есть,
[37:49.240 --> 37:54.240]  тогда идем в лево просто. И в левом сыне пытаемся найти k и 0. Иначе спускаемся вправо,
[37:54.240 --> 37:59.480]  уменьшая k на число нулей из левого поддерева. Давайте я пару строчек напишу. Значит, находясь
[37:59.480 --> 38:07.040]  в вершине v, мы смотрим, если k больше или равно, чем t от 2v, то есть чем число нулей в левом сыне,
[38:07.040 --> 38:14.200]  тогда просто return, ну то не знаю, get, я не буду писать целиком название функции, там get, get,
[38:14.200 --> 38:24.280]  k, 0. Идем в левого сына просто с его координатами t, l, t, m в поисках того же k нуля. Иначе,
[38:24.280 --> 38:32.680]  значит, нужно пойти в лево, в правого сына, извините, в правого сына v на 2 плюс 1. Отрезок,
[38:32.680 --> 38:43.000]  который он контролирует, это tm плюс 1 tr. Ну и теперь мы ищем не k и 0, а k минус t от 2v. Вот
[38:43.000 --> 38:48.000]  такой вот 0 мы ищем, потому что слева ровно столько нулей, мы их все отбрасываем, ищем 0 с таким
[38:48.000 --> 38:57.240]  именом. Вот такой алгоритм, он работает, понятное дело, за алгорифм, за алгорифмическое время от
[38:57.240 --> 39:02.040]  глубины дерева, потому что это просто спуск. Мы стоим вот здесь и идем либо вправо, либо влево.
[39:02.040 --> 39:06.640]  Здесь уже нет никаких дилем, что мы когда-то ветвимся, мы всегда спускаемся в одного из двух
[39:06.640 --> 39:13.040]  сыновей, либо влево, либо вправо. И заканчиваемся как раз в тот момент, когда мы дошли до искомого
[39:13.040 --> 39:19.040]  листа, где написан k и 0 в нашем массиве. Так, есть ли вопросы по этому куску?
[39:28.440 --> 39:33.720]  Да, ну, значит, вопрос такой, что делать, если длина массива не степень двойки? Ну на самом деле
[39:33.720 --> 39:38.480]  ничего не меняется, вот тот код, который я писал, он работает для любого n, даже если n не степень
[39:38.480 --> 39:44.120]  двойки. Там меняется только то, что у вас, ну, вот то деление, которое я пишу, да, tl плюс tm пополам,
[39:44.120 --> 39:51.160]  tl плюс, сори, плюс tr пополам. Оно, то есть у нас, если у меня всегда степень двойки, то это всегда
[39:51.160 --> 39:56.160]  делится пополам. И там вот прям все идеально, такое красивое дерево, у каждой вершинки ровно
[39:56.160 --> 40:03.640]  два сына, кроме листьев. Если n не степень двойки, то ничего не поменяется в плане кода, просто эта
[40:03.640 --> 40:08.600]  штука, ну, то есть эта штука может быть нечетная. Давайте пример нарисуем, значит, что происходит,
[40:08.600 --> 40:14.800]  если n равно 3, например. Тогда у меня корень контролирует отрезок 0,2, левый сын контролирует,
[40:14.800 --> 40:24.920]  видимо, отрезок 0,1, а правый 2,2. Здесь, соответственно, 0,0, 1,1. То есть единственное,
[40:24.920 --> 40:29.360]  что меняется, да, это что у меня не все листья на одной глубине получаются. Короче, ничего не
[40:29.360 --> 40:33.920]  поменяется, на самом деле, в плане кода, потому что у вас все равно, мы все равно договариваемся,
[40:33.920 --> 40:41.880]  что в левом поддереве находятся элементы стельтова по тмтой, в правом стм плюс первого по тр. Ну и тогда,
[40:41.880 --> 40:46.960]  в общем, все то же самое работает, просто даже глубина может, ну, в каких-то моментах вы доходите
[40:46.960 --> 40:54.520]  не до там, не до log n, а до log n минус 1. Каких-то листьев глубина просто меньше. Поэтому это работает,
[40:54.520 --> 40:59.120]  на самом деле, для всех n. Вот, но если вам хочется прям красивую структуру, то всегда можно сделать
[40:59.280 --> 41:03.920]  так. Всегда можно добить ваш исходный массив до ближайшей степени 2, просто увеличивать его длину,
[41:03.920 --> 41:09.160]  пока она не станет степенью 2. Ну и тогда считаю, что ваше дерево прям очень красивое и в нем
[41:09.160 --> 41:19.480]  выполняется все, что вы хотите. Так, окей. Дальше я хочу поговорить про отложенные операции.
[41:29.120 --> 41:51.480]  Задача такая, опять есть массив, а 0, а 1 и так далее, а n минус 1. Поступают опять два типа
[41:51.480 --> 41:58.080]  запроса, в первых из которых сумма на отрезке, давайте я вам напишу так, сумма lr, нам нужно найти
[41:58.080 --> 42:07.680]  сумму чисел с l по r элемента. Второй запрос это assign на отрезке, то есть делать присвоение на
[42:07.680 --> 42:14.520]  отрезке lr числа x. Вам нужно все числа на отрезке с l по r заменить на одно и то же x.
[42:22.200 --> 42:27.160]  Если раньше мы делали update в точке, если мы раньше делали изменение в точке, то теперь может быть такое,
[42:27.160 --> 42:33.280]  что изменение происходит на целом отрезке, ну и причем оно одинаковое, все числа обновляются
[42:33.280 --> 42:40.320]  x. Все старые числа забываются, вместо них везде пишется x. И опять нужно отвечать на сумму на отрезке.
[42:40.320 --> 42:48.160]  Так, здесь появляются отложенные операции, это значит концепция примерно следующая. Смотрите,
[42:48.160 --> 42:54.080]  мы понимаем, что если мы вот эти вот assign, вот эти присвоения будем делать в тупую, то есть,
[42:54.080 --> 42:59.120]  честно, для каждого элемента l, l plus 1, l plus 2 и так далее и так далее, вплоть до r, будем вызывать наш
[42:59.120 --> 43:03.600]  update, вот как было раньше, тогда это может работать долго, потому что если длина отрезка большая,
[43:03.600 --> 43:08.600]  то мы вызовем много апдейтов. У нас время обработки запроса будет не логарифмическое,
[43:08.600 --> 43:12.280]  оно будет пропорционально длине отрезка, еще множество логарифм. В общем, слишком долго.
[43:12.280 --> 43:21.320]  Значит, вместо этого мы будем делать такое. Мы будем в каких-то вершинках тебе делать такую
[43:21.320 --> 43:31.240]  пометку. Ну, я напишу, давайте promise. Promise равно x. Это значит, что мы себе пообещали когда-то в
[43:31.240 --> 43:38.040]  будущем присвоить всему поддереву, ну, точнее, всем листиком этого поддерева число x. То есть,
[43:38.040 --> 43:44.280]  у нас когда-то поступил запрос, где нам нужно все это поддерево присвоить равным x, все эти
[43:44.280 --> 43:49.360]  элементы сделать x. И мы как бы этого не делаем сейчас, но пообещаем себе обязательно это сделать
[43:49.360 --> 43:54.520]  когда-то в будущем. Мы это запомнили, мы это записали, пообещали себе это сделать. Promise равно x.
[43:54.520 --> 44:02.320]  И дальше, в будущем, если мне понадобится вдруг спуститься вниз из этой вершинки, если я рассматриваю
[44:02.320 --> 44:06.880]  какой-то вот такой запрос, скажем, тогда мне нужно пойти вправо из этой вершинки. Тогда давайте я
[44:06.880 --> 44:12.480]  эту отложенную операцию, да, отложенную на будущее, сейчас протолкну. Я передам информацию об этом
[44:12.480 --> 44:18.440]  промесе и в левого сына, и в правого сына. Ну, благо, передается она очень просто. Если я когда-то
[44:18.440 --> 44:24.640]  пообещал себе положить все эти элементы равными x, то я могу просто этот же самый promise сюда
[44:24.640 --> 44:30.640]  переписать. Promise равно x, promise равно x. Ну и сумма тоже себя, понятное дело, как ведет. То, что я
[44:30.640 --> 44:35.680]  t-шкой обозначал, сумма в поддереве, очевидно, как себя ведет, если все элементы равны x.
[44:35.680 --> 44:52.760]  Если все элементы в поддереве равны x, то сумма понятна какая-то. Просто x умножить на размер
[44:52.760 --> 45:00.080]  поддерева, на количество листиков в нем. Значит, протолкнуть эту операцию очень просто. Мы обновляем
[45:00.080 --> 45:08.920]  promise, который тут написан, обновляем сумму. В общем-то и все. Нам важно, что мы затираем информацию,
[45:08.920 --> 45:13.960]  которая лежала в этой вершинке. Там могло лежать что угодно, какая угодно сумма, какой угодно
[45:13.960 --> 45:21.680]  promise, но главное, что они были поставлены до того, как пришел вот этот promise. И когда я
[45:21.680 --> 45:26.240]  его протолкиваю вниз, когда вот эта операция приходит, и мне нужно ее протолкнуть вниз,
[45:26.240 --> 45:31.680]  я затираю все, что было раньше и сообщаю новую информацию, что все элементы там равны x.
[45:35.520 --> 45:49.920]  Давайте напишем несколько строчек, как это все формально работает. Уточню, у меня есть массив
[45:49.920 --> 45:56.720]  promise. Так, promise, кстати, вроде плохо называть. Давайте я буду написать pro, потому что, кажется,
[45:56.720 --> 46:02.000]  promise есть ключевое слово такое, ну или там, или вы стоили. В общем, не будем так делать. Pro от v
[46:02.000 --> 46:15.120]  — это отложенная операция вершины v. T от v — это, как всегда, сумма. T от v — это сумма. Во-первых,
[46:15.120 --> 46:22.800]  давайте напишем микропроцедуру, которую назовем push. Void push — это операция проталкивания
[46:22.800 --> 46:28.840]  информации, которая хранится в этой вершине, в ее детей. Мы стоим в какой-то вершинке, она
[46:28.840 --> 46:35.560]  контролирует отрезок TLTR, и мне нужна информация, вот эта промость, которая там стоит, передать
[46:35.560 --> 46:45.000]  детей. Информацию передать детей. Так, ну вот здесь небольшой хак давайте сделаем, себе облегчим
[46:45.000 --> 46:50.640]  жизнь и скажем, что вот эти s-сайны нам, когда приходят, они всегда не отрицательны, все x всегда
[46:50.640 --> 46:58.400]  не отрицательны. Тогда в промесе давайте будем хранить минус один, если там нет никого промеса,
[46:58.400 --> 47:02.320]  то есть на самом деле в этой вершинке ничего не меняется, ее нужно оставить вот как она была.
[47:02.320 --> 47:12.000]  Поэтому если промес равно минус 1, то есть в этой вершине нет никаких изменений, там никакой
[47:12.000 --> 47:16.680]  сайн не приходил или мы его уже обработали, то мы просто делаем ретерн, нам ничего не нужно
[47:16.680 --> 47:23.800]  делать, мы всю информацию и так передали, ничего делать не надо. Вот, ну это я так вольно себе допустил,
[47:23.800 --> 47:27.160]  что все x не отрицательны, если они могут быть отрицательны, то это не работает, потому что
[47:27.160 --> 47:31.800]  минус 1 может быть знаком того, что нужно минус 1 присвоить во всем падении. Вот, ну тогда нужно
[47:32.200 --> 47:37.920]  хранить какой-то булевский флаг того, что протолкнули мы уже или нет, протолкнули или нет, то есть нужно не
[47:37.920 --> 47:41.980]  только хранить число, которое надо протолкнуть, но и булевский флаг того, надо это делать или нет,
[47:41.980 --> 47:48.560]  потому что если уже протолкнули, то больше не нужно делать. Вот, ну а иначе нужно и влево сына,
[47:48.560 --> 47:53.080]  и вправо сына передать информацию об этом промесе. Так, давайте для удобства я введу
[47:53.080 --> 48:06.280]  переменную x равную промесу от v. Ну и вот теперь сделаю с детьми то, что нужно.
[48:06.280 --> 48:12.160]  Я посчитаю сначала границы, то контролируется каждым сыном, и теперь давайте посмотрим на то,
[48:12.160 --> 48:17.720]  что такое сумма, скажем, левого сына. Что такое t от v2? Это x умножен на размер под дерево.
[48:17.720 --> 48:26.560]  x умноженный на tm-tl плюс 1. Если мы все равно знаем, что каждое число там равно x,
[48:26.560 --> 48:32.600]  то сумма равна просто этому числу умножен на длину. Тоже самое с правым сыном, t2v
[48:32.600 --> 48:40.560]  плюс 1, это x умноженный на, здесь будет tr-tm, потому что у меня отрезок начинается в tm
[48:40.560 --> 48:46.560]  плюс 1, заканчивается в tr, значит его длина как раз вот такая разность. Не забываем передать
[48:46.560 --> 48:57.120]  сам промес. Промес v на 2 равно, давайте я вот так напишу, промес v на 2 плюс 1 равно x. Вот такая
[48:57.120 --> 49:01.520]  строчка с двумя равенствами работает так, что мы один и тот же x присваиваем и сюда, и сюда.
[49:01.520 --> 49:09.200]  Один и тот же x присвоили и сюда, и сюда. Ну и в конце говорим, что мы этот x протолкнули,
[49:09.200 --> 49:16.120]  говорим, что промес от v равно минус 1. Промес от v равно минус 1, то есть мы все сделали больше,
[49:16.120 --> 49:23.760]  этот x протолкнуть не нужно. Вот это как раз соответствует тому случаю, когда здесь была
[49:23.760 --> 49:27.840]  какая-то операция, не как бы, которую мы себе пообещали сделать, но еще не сделали. Вот давайте
[49:27.840 --> 49:36.520]  я ее сейчас сделаю и детям передам эту информацию. Так, ну теперь на сумму надо ответить, на запрос
[49:36.520 --> 49:54.280]  суммы. GetSum. Давайте сначала Assign сделаю, я что-то забыл. Мне нужны отрезки в вершине v,
[49:54.280 --> 50:05.040]  на каком-то отрезке lr и числа заменить на x. Вот так Assign сначала сделаем, потом GetSum.
[50:05.040 --> 50:12.520]  Есть вершина, мне нужно в каком-то подотрезке присвоить x всем элементам. Опять самый простой
[50:12.520 --> 50:18.200]  случай, это когда мы пришли в вершину, совпадающую целиком с тем, ну в общем, с тем отрезком,
[50:18.200 --> 50:27.880]  которым мы ищем. Ну тогда что нужно сделать? Нам нужно на всем отрезке присвоить x, то есть в
[50:27.880 --> 50:35.600]  частности нужно сказать, что pro от v это x, что мы этот x как бы сюда положили и в будущем, если что,
[50:35.600 --> 50:40.680]  мы эту информацию передадим детям, что на всем этом подделье присвоены x. Ну и также нужно
[50:40.680 --> 50:49.120]  написать сумму, что t в это это x на длину отрезка. tr-tl плюс 1. Return.
[50:49.120 --> 50:57.200]  Если мне нужно во всем подделье присвоить x, то я запоминаю эту информацию в промесе,
[50:57.200 --> 51:03.320]  обновляю сумму и заканчиваюсь. Причем здесь, например, важно, что если там уже был какой-то
[51:03.320 --> 51:08.000]  промес, если там лежала там операция, что раньше пришел запрос, который все числа в этом подделье
[51:08.000 --> 51:13.240]  присвоил равными y, то тогда я просто эту операцию затираю и забываю про нее, она мне нафиг не нужна.
[51:13.240 --> 51:18.200]  Если я раньше все числа присвоил y, а теперь переприсвоил x, то мне этот y уже вообще не нужен,
[51:18.200 --> 51:23.960]  да, и соответственно старое значение pro от v уже меня не интересует. Так, хорошо, это простой
[51:23.960 --> 51:27.760]  случай. Сложный случай, когда нужно опять в ветвице идти там влево или вправо. Для этого,
[51:27.760 --> 51:36.920]  перед тем как в ветвиться, я вызову push. Push v tr. И как раз я себе пообещал, что каждый раз,
[51:36.920 --> 51:42.800]  когда я прихожу в вершину, в которой есть как бы непереданная в детей отложенная операция,
[51:42.800 --> 51:48.400]  промес, да, здесь какой-то лежит, мне нужно сначала, перед тем как идти в детей, сначала ее протолкнуть.
[51:48.400 --> 51:53.480]  Чтобы пойти в детей, мне нужно сначала сделать вот то, что написано в этой вершинке. Поэтому пишем
[51:53.480 --> 52:06.280]  сначала push. Вот, ну дальше там считаем опять полусумму t и l, t и r пополам. И пишем тот же кусочек кода,
[52:06.280 --> 52:10.080]  который у нас был в гетсами, что если у нас хоть кто-то лежит слева, то мы запускаемся слева,
[52:10.080 --> 52:16.040]  в левого сына. Если хоть кто-то справа, то идем вправо. Значит, если l меньше равно tm,
[52:16.040 --> 52:34.120]  тогда нужно сделать assign в левом сыне. Это параметры левого сына, это координаты отрезка,
[52:34.120 --> 52:38.200]  да, что левый у меня не меняется, а правый может уменьшиться, если он был слишком большой,
[52:38.200 --> 52:44.200]  то он уменьшается до tm. x у меня не меняется. И аналогично вправо сына идем, что если хоть
[52:44.200 --> 52:48.600]  кто-то есть справа, то есть если есть хотя бы один элемент, лежащий в правом по дереве,
[52:48.600 --> 52:55.200]  тогда мне нужно запустить аналогичную функцию assign от правого ребенка с соответствующими параметрами.
[53:04.120 --> 53:22.160]  Вот, запустился в лево, запустился вправо. Здесь еще нужна одна строча в конце, скажите,
[53:22.160 --> 53:28.600]  пожалуйста, какая? Что вот если я запустился от левого ребенка, передал туда информацию,
[53:28.600 --> 53:33.120]  что что-то нужно там присвоить x, у правому передал, что что-то нужно присвоить x,
[53:33.120 --> 53:36.680]  что нужно сделать в конце, чтобы у меня можно было завершить этот запуск.
[53:36.680 --> 53:49.560]  Ой, нет, ну спасибо. Ну а Саня ничего не возвращается, да, это функция,
[53:49.560 --> 54:05.080]  я не знаю, что возвращать. Что-что? Ну она и так здесь до минус 1. После push она обязательно минус 1.
[54:05.080 --> 54:12.280]  Что? Да, все верно. Значит, мы что сделали? Мы поменяли что-то слева, поменяли что-то справа,
[54:12.280 --> 54:17.960]  но мне нужно не забыть, что в вершинке v должен быть правильный результат. Мне нужно написать,
[54:17.960 --> 54:30.200]  что t от v равно t от v на 2 плюс t от v на 2 плюс 1. Вот, и на этом мы можем закончиться после вот
[54:30.200 --> 54:36.360]  этой вот строчки. Чтобы доказать корректность, надо сформулировать утверждение в стиле,
[54:37.360 --> 54:44.120]  во-первых, если мы дошли до вершинки v, то в нем лежит правильное значение t от v. И потом,
[54:44.120 --> 54:49.960]  если мы запустились вот этим вот assign от вершинки v и целиком обработали левое и правое поддерево,
[54:49.960 --> 54:55.000]  то опять по выходе из этой вершинки у меня t в это будет правильным как бы обновленным значением,
[54:55.000 --> 54:59.360]  потому что я обновился слева, обновился справа, там по предположению индукции тоже все корректно
[54:59.360 --> 55:03.560]  сработало. И теперь, чтобы правильно склеить ответ в родительскую вершинку, мне нужно сложить вот
[55:03.560 --> 55:13.080]  то, что лежит слева и то, что лежит справа. Вопросы? Хорошо. Ну время работы здесь тоже понятно
[55:13.080 --> 55:17.120]  логарифмическое, потому что код здесь практически такой же, как был в GetSum. Да,
[55:17.120 --> 55:21.800]  я здесь делаю какие-то штуки за вот единицы и потом, если что, витвлюсь направо и налево. И опять,
[55:21.800 --> 55:30.200]  эти витвления, они такие, что суммарно вы пройдете только от log-in вершин. Так,
[55:30.200 --> 55:39.280]  тогда GetSum писать не будем. Я напишу просто, что там в одном месте нужно сделать push в функции
[55:39.280 --> 55:56.240]  GetSum. Перед тем, как спускаться в детей, нужно сделать push. Перед спуском в детей нужно вызвать push.
[55:56.240 --> 56:08.600]  Потому что, еще раз повторю, push работает так, что мы себе когда-то, мы когда-то прошли вершинку
[56:08.720 --> 56:14.600]  v и пообещали себе, что нужно во всем поддереве написать какой-то x. И если мне нужно вдруг пойти
[56:14.600 --> 56:19.680]  вниз и работать с поддеревом, то понятно дело, что эту отложенную операцию, которую я себе когда-то
[56:19.680 --> 56:24.560]  пообещал сделать, нужно сейчас сделать. Потому что я начинаю работать с поддеревом, но уже небольшой
[56:24.560 --> 56:28.760]  черный ящик, а там как-то подразбивается налево и право сына и так далее. Мне нужно вот эту
[56:28.760 --> 56:33.600]  информацию передать в детей. То, что я себе когда-то пообещал, вот сейчас сделать. Немножко на
[56:33.600 --> 56:38.640]  амортизационный анализ. Похоже, что то, что я себе пообещал раньше, я делаю сейчас. Вот эту
[56:38.640 --> 56:43.680]  информацию передаю сейчас. И всегда за этим нужно следить, что если вы вдруг из-за вершины
[56:43.680 --> 57:02.040]  спускаетесь вниз, то обязательно перед этим нужно запустить push. Так, ну вот,
[57:02.040 --> 57:06.040]  такие отложенные операции есть. Ну и здесь, соответственно, тоже можно кучу всяких модификаций
[57:06.040 --> 57:10.600]  делать, что там можно делать не присвоение на отрезке, а там, скажем, увеличение, что все числа нужно
[57:10.600 --> 57:16.360]  увеличить на x. Можно там делать, не знаю, всякие max равно. То есть, если все числа, которые были
[57:16.360 --> 57:22.200]  меньше, чем x, заменить на x, а те, которые были больше собраны на x, а их оставить x. В общем, всякие
[57:22.200 --> 57:27.640]  такие кучу-кучу разных запросов можно делать. Вот на семинарах посмотрите подробнее, какие они
[57:27.640 --> 57:34.120]  бывают, в каких задачах это нужно и так далее. Так, следующая, что я хочу рассказать, это тоже
[57:34.120 --> 57:45.360]  интересная штука. Это количество чисел на отрезке, значения которых лежат в отрезке.
[57:57.640 --> 58:08.880]  Так, что это значит? Это значит, что у нас, кстати, теперь появляется статический массив. Статический
[58:08.880 --> 58:17.600]  массив, то есть не изменяющийся, а 0, а 1 и так далее, а-1. И есть всего один тип запросов такой. У вас
[58:17.600 --> 58:25.480]  приходит 4 числа lr и x-еверик, и вам нужно на отрезке с l этого числа по r это число найти количество
[58:25.480 --> 58:37.040]  чисел, которые большеclip равно x и меньшеclip равно y. Формально нужно найти количество k, таких что l
[58:37.040 --> 58:46.760]  меньше clip равно k, меньше clip равно r, и при этом x меньше clip равно akata меньше clip равно y. Вам
[58:46.760 --> 58:52.400]  нужно вычислить как бы под отрезок, найти количество чисел меньшеclip равных чем что-то, и при этом
[58:52.400 --> 59:02.640]  больше бранных, чем что-то другое.
[59:02.640 --> 59:04.980]  Это нам, например, позволит считать количество различных
[59:04.980 --> 59:05.980]  чисел на отрезке.
[59:05.980 --> 59:30.300]  Можно находить количество различных чисел на отрезке.
[59:30.300 --> 59:42.860]  Вот скажем, вам опять вычленяет какой-то отрезок с L2R2-элемент,
[59:42.860 --> 59:45.260]  вы там видите, ага, вот единица входит сколько-то
[59:45.260 --> 59:47.500]  раз, там двойка сколько-то раз, тройка сколько-то раз,
[59:47.500 --> 59:49.740]  четверка, скажем, не входит ни разу, пятерка сколько-то
[59:49.740 --> 59:50.740]  раз и так далее.
[59:50.740 --> 59:52.900]  И вот вам нужно узнать, сколько чисел входит хотя бы один
[59:52.900 --> 59:53.900]  раз.
[59:53.900 --> 59:55.460]  Да, без учета как бы кратности вхождения.
[59:55.460 --> 59:58.220]  Понятно, что суммарно они входят все R-L плюс один
[59:58.220 --> 59:59.220]  раз.
[01:00:00.060 --> 01:00:02.980]  Но вот если не учитывать кратности, то сколько различных
[01:00:02.980 --> 01:00:03.980]  туда входит.
[01:00:03.980 --> 01:00:06.420]  Вот это тоже либо успеем на лекции, либо останется
[01:00:06.420 --> 01:00:07.420]  на семинарах.
[01:00:07.420 --> 01:00:14.460]  Итак, здесь тоже есть одно, видимо, упрощение как минимум,
[01:00:14.460 --> 01:00:17.620]  что давайте мы вот такой запрос, когда у меня есть
[01:00:17.620 --> 01:00:20.420]  ограничение и снизу и сверху, мы его преобразуем только
[01:00:20.420 --> 01:00:22.980]  к запросу, когда есть ограничение снизу.
[01:00:22.980 --> 01:00:25.660]  Давайте так напишем.
[01:00:25.660 --> 01:00:44.620]  Количество чисел, принадлежащих отрезку от х до у, равно количество
[01:00:44.620 --> 01:00:50.820]  чисел, больше или равных чем х, минус количество
[01:00:50.820 --> 01:00:56.420]  чисел, больше или равных чем у плюс один.
[01:00:56.420 --> 01:01:01.020]  Ну, очевидно, числа в отрезке это либо, с одной стороны,
[01:01:01.020 --> 01:01:03.060]  они больше или не чем х, с другой стороны, из них
[01:01:03.060 --> 01:01:05.140]  нужно вычесть те, которые больше или не чем у плюс
[01:01:05.140 --> 01:01:06.140]  один.
[01:01:06.140 --> 01:01:08.020]  Считаем, что все числа целые, то есть плюс и единичку
[01:01:08.020 --> 01:01:09.020]  можно добавить.
[01:01:09.020 --> 01:01:12.500]  Задача про отрезок х и у на самом деле сводится
[01:01:13.340 --> 01:01:16.180]  к количеству чисел на отрезке, которые больше
[01:01:16.180 --> 01:01:18.620]  или равных чем что-то, чем какая-то нижняя граница
[01:01:18.620 --> 01:01:19.620]  х.
[01:01:19.620 --> 01:01:22.020]  Ну или там для удобства можно было бы наоборот ограничиться
[01:01:22.020 --> 01:01:24.660]  верхней границей, что это количество чисел, меньше
[01:01:24.660 --> 01:01:27.380]  или равных чем у минус количество чисел, меньше
[01:01:27.380 --> 01:01:28.860]  или равных чем х минус один.
[01:01:28.860 --> 01:01:31.500]  Вот можно так, можно так, давайте сделаем сначала
[01:01:31.500 --> 01:01:32.500]  вот такую штуку.
[01:01:32.500 --> 01:01:41.500]  Здесь нам понадобится, ну давайте я напишу, что можно
[01:01:41.500 --> 01:01:48.060]  называть там деревом мёрч сорта, мёрч сорт, вот,
[01:01:48.060 --> 01:01:53.380]  или это ещё называется fractional cascading, fractional cascading.
[01:01:53.380 --> 01:02:00.740]  Идея следующая, давайте вспомним, как у нас работал
[01:02:00.740 --> 01:02:05.300]  мёрч сорт, ну вот в плане рекурсии, что есть у меня
[01:02:05.300 --> 01:02:08.460]  там на верхнем уровне весь мой массив длинный, потом
[01:02:08.460 --> 01:02:11.060]  он разбивается на два кусочка, как-то сортится его левая
[01:02:11.060 --> 01:02:13.260]  половинка, правая половинка, потом они склеиваются
[01:02:13.260 --> 01:02:15.460]  в один большой массив на верхнем уровне.
[01:02:15.460 --> 01:02:18.300]  Так вот давайте всю эту рекурсию так распишем,
[01:02:18.300 --> 01:02:19.300]  мы когда-то это уже делали.
[01:02:19.300 --> 01:02:33.980]  И давайте, сейчас я нарисую, окошки все.
[01:02:33.980 --> 01:02:35.900]  Давайте как бы промоделируем поведение этого алгоритма
[01:02:35.900 --> 01:02:36.900]  снизу вверх.
[01:02:36.900 --> 01:02:42.300]  Вот на нижнем уровне у меня, когда рекурсия доходит,
[01:02:42.300 --> 01:02:47.060]  она доходит просто до одноэлементных массивов а0, а1, а2, ну и так далее.
[01:02:47.060 --> 01:02:49.940]  В каждой ячейке будет просто массив из одного элемента,
[01:02:49.940 --> 01:02:53.900]  а6, а7.
[01:02:53.900 --> 01:02:57.780]  Дальше мне, как работает алгоритм, как он работал,
[01:02:57.780 --> 01:03:00.060]  он вот этот массив из двух элементов разбил на два,
[01:03:00.060 --> 01:03:03.060]  а теперь сливает обратно эти два элемента в этот
[01:03:03.060 --> 01:03:04.060]  массив длины 2.
[01:03:04.380 --> 01:03:09.340]  Так давайте мы какой-нибудь пример сразу напишем, чтобы было понятно.
[01:03:09.340 --> 01:03:22.100]  3, 5, 1, 0, 4, 2, не знаю там, что остается.
[01:03:22.100 --> 01:03:31.980]  Вот, значит, тогда мерч-сорт будет работать так.
[01:03:31.980 --> 01:03:35.300]  Мы вот эти два элемента, ну вот запускаем процедуру
[01:03:35.300 --> 01:03:37.900]  мерч, которая склеивает как бы два отсортированных
[01:03:37.900 --> 01:03:38.900]  массива.
[01:03:38.900 --> 01:03:39.900]  Здесь будет 3, 5.
[01:03:39.900 --> 01:03:43.780]  Дальше здесь будет 0, 1, мы склеиваем 1 и 0, получаем
[01:03:43.780 --> 01:03:49.500]  отсортированный 0, 1, здесь будет 2, 4, здесь будет 6, 7.
[01:03:50.500 --> 01:03:52.540]  Чтобы склеить вот эти два массива, мне нужно, ну
[01:03:52.540 --> 01:03:55.260]  вспоминаем, два указателя, один здесь, другой здесь,
[01:03:55.260 --> 01:03:57.100]  выписываем каждый раз минимальное число и избегаем указатель
[01:03:57.100 --> 01:03:59.540]  направо в том массиве, откуда выписали.
[01:03:59.540 --> 01:04:03.820]  Значит будет 0, 1, 3, 5, здесь будет, ну здесь вообще
[01:04:03.820 --> 01:04:06.460]  без заменения, 2, 4, 6, 7.
[01:04:06.460 --> 01:04:08.300]  Теперь вот эти два массива, чтобы склеить, мы сначала
[01:04:08.300 --> 01:04:11.100]  записываем вот этот, потом 1, потом вот это минимальное
[01:04:11.100 --> 01:04:17.660]  число будет 2, потом здесь, потом здесь, 5, 6, 7.
[01:04:17.660 --> 01:04:21.820]  Потом вот просто напомнили, как работает merge sort.
[01:04:21.820 --> 01:04:24.700]  А дальше смотрите, давайте моё дерево отрезков будет
[01:04:24.700 --> 01:04:26.180]  ровно вот так выглядеть.
[01:04:26.180 --> 01:04:29.060]  Оно в каждой вершине будет хранить там ни сумму на
[01:04:29.060 --> 01:04:31.180]  отрезке, ни количества нулей, как вот раньше было, не одно
[01:04:31.180 --> 01:04:33.740]  число, а прям вот все эти числа, которые на этом
[01:04:33.740 --> 01:04:37.540]  уровне рекурсии здесь сортируются, которые будут в таком
[01:04:37.540 --> 01:04:38.540]  порядке располагаем.
[01:04:38.540 --> 01:04:42.300]  То есть в корне будут вообще отсортированный весь
[01:04:42.300 --> 01:04:44.300]  массив, в корне дерева будет храниться весь отсортированный
[01:04:44.300 --> 01:04:45.300]  массив.
[01:04:45.460 --> 01:04:49.620]  В левом сыне будут храниться отсортированные элементы
[01:04:49.620 --> 01:04:53.500]  с нулевого по третьей, в правом сыне с четвертого
[01:04:53.500 --> 01:04:54.500]  по седьмой.
[01:04:54.500 --> 01:04:55.500]  И так далее.
[01:04:55.500 --> 01:04:58.660]  То есть у меня в каждой вершинке будет храниться отсортированный
[01:04:58.660 --> 01:05:02.540]  кусок моего, скажем так, под кусок моего исходного
[01:05:02.540 --> 01:05:03.540]  массива.
[01:05:03.540 --> 01:05:04.940]  Вот здесь будет храниться все, что находится в этом
[01:05:04.940 --> 01:05:05.940]  поддереве.
[01:05:05.940 --> 01:05:08.900]  Здесь отсортированы вот эти вот 2, 4, 6, 7 в правильном
[01:05:08.900 --> 01:05:09.900]  порядке.
[01:05:09.900 --> 01:05:13.100]  То есть в каждой вершинке у меня хранится вектор или
[01:05:13.100 --> 01:05:15.100]  массив, неважно, динамический какой-нибудь.
[01:05:15.100 --> 01:05:20.340]  Ну тогда, как можно на это все отвечать?
[01:05:20.340 --> 01:05:21.660]  Как можно отвечать на запросы?
[01:05:21.660 --> 01:05:24.660]  Поиск, количество чисел больше равных чем х на отрезке.
[01:05:24.660 --> 01:05:37.660]  Количество чисел больше равных х на отрезке селпайр.
[01:05:37.660 --> 01:05:39.220]  Ну самое простое это следующее.
[01:05:39.220 --> 01:05:41.500]  Давайте мы вот в этом нашем дереве отрезков, то есть
[01:05:41.500 --> 01:05:44.420]  теперь вот это будет являться уже деревом отрезков.
[01:05:44.420 --> 01:05:48.340]  Мы в нем опять разобьем наш отрезок LR на какие-то
[01:05:48.340 --> 01:05:49.340]  вершинки.
[01:05:49.340 --> 01:05:52.140]  То есть точно так же мы спустимся рекурсивно сверху вниз,
[01:05:52.140 --> 01:05:54.220]  дойдем до каких-то вершинок, которые целиком покрывают
[01:05:54.220 --> 01:05:55.700]  наш отрезок LR.
[01:05:55.700 --> 01:05:58.540]  Скажем вот в таком примере, опять-таки восстановим
[01:05:58.540 --> 01:05:59.540]  его.
[01:05:59.540 --> 01:06:03.740]  У меня вот эти вот две вершинки, вот это и вот это вдвоем
[01:06:03.740 --> 01:06:05.180]  целиком покрывают мой отрезок.
[01:06:05.180 --> 01:06:09.540]  Вот с А2 по А7 у меня весь отрезок покрывается двумя
[01:06:09.540 --> 01:06:10.540]  вершинками.
[01:06:11.380 --> 01:06:14.140]  Ну точно так же в любом случае у меня будет, то
[01:06:14.140 --> 01:06:16.540]  есть когда я так спускаюсь рекурсивно сверху вниз,
[01:06:16.540 --> 01:06:18.780]  у меня отрезок LR разбивается на какое-то логарифмическое
[01:06:18.780 --> 01:06:20.620]  количество вершинок, которые его целиком покрывают.
[01:06:20.620 --> 01:06:26.020]  Ну давайте тогда в каждом таком массиве, мы же знаем,
[01:06:26.020 --> 01:06:28.200]  что это уже отсортированный массив, он возрастает слева
[01:06:28.200 --> 01:06:29.200]  направо.
[01:06:29.200 --> 01:06:31.980]  Давайте мы в каждом из них с помощью бинарного поиска
[01:06:31.980 --> 01:06:34.820]  найдем количество чисел больше равных чем х.
[01:06:34.820 --> 01:06:37.700]  В каждом таком отсортированном массиве с помощью бинарного
[01:06:37.700 --> 01:06:39.660]  поиска найдем количество чисел больше
[01:06:39.660 --> 01:06:41.900]  равных чем x ну там не знаю скажем x
[01:06:41.900 --> 01:06:44.260]  равно
[01:06:44.260 --> 01:06:47.140]  так вот плохой ну ладно значит x равно не
[01:06:47.140 --> 01:06:49.140]  знать четырем да тогда я вот здесь вот
[01:06:49.140 --> 01:06:51.180]  находить давайте тройки давайте тройки
[01:06:51.180 --> 01:06:54.300]  тогда я в этом массиве нашел минимальное
[01:06:54.300 --> 01:06:56.660]  что больше рано чем x bin поиском вот
[01:06:56.660 --> 01:06:58.860]  эта четверка и в этом массиве тоже bin
[01:06:58.860 --> 01:07:02.700]  поиском я запускаю в поисках числа больше
[01:07:02.700 --> 01:07:04.340]  рано чем 3 но такого числа вообще нет
[01:07:04.340 --> 01:07:06.780]  мы будем там указывать на конец массив
[01:07:06.780 --> 01:07:08.700]  понятно что если есть ассоциированный
[01:07:08.700 --> 01:07:10.420]  массив то найти первое число больше
[01:07:10.420 --> 01:07:12.900]  равное чем x это ну логарифмическая задача
[01:07:12.900 --> 01:07:14.780]  вы делитесь как обычно пополам да
[01:07:14.780 --> 01:07:16.380]  и сдвигаетесь там либо либо в левую
[01:07:16.380 --> 01:07:17.780]  половинку либо вправо в поисках того
[01:07:17.780 --> 01:07:18.460]  самого элемента
[01:07:18.460 --> 01:07:20.860]  ну тогда вам нужно просто в каждый из
[01:07:20.860 --> 01:07:22.780]  этих решинок запустить bin поиск
[01:07:22.780 --> 01:07:25.660]  да если вы и тогда мы знаем ну то есть
[01:07:25.660 --> 01:07:27.500]  вот здесь мы получили три числа больше
[01:07:27.500 --> 01:07:29.940]  равное чем 3 здесь мы получили 0 чисел
[01:07:29.940 --> 01:07:31.820]  тогда если мы сложим эти как раз 3 и 0
[01:07:31.820 --> 01:07:33.460]  мы как раз получим суммарное количество
[01:07:33.460 --> 01:07:35.340]  чисел которые мы искали количество
[01:07:35.340 --> 01:07:36.940]  чисел на отрезке lr который по значению
[01:07:36.940 --> 01:07:42.020]  хотя бы x вот и сложим это все получим
[01:07:42.020 --> 01:07:43.980]  ответ ну и в общем случае так и будет
[01:07:43.980 --> 01:07:45.660]  работать мы разбиваем наш отрезок lr
[01:07:45.660 --> 01:07:47.500]  на какие-то вершинки которые его
[01:07:47.500 --> 01:07:49.220]  контролируют в каждый из них пускай
[01:07:49.220 --> 01:07:51.380]  bin поиск находим количество чисел в
[01:07:51.380 --> 01:07:53.060]  этом под дереве больше равное чем x и
[01:07:53.060 --> 01:07:59.100]  все это складываем так давайте тоже
[01:07:59.100 --> 01:08:02.020]  напишем это чуть-чуть
[01:08:02.020 --> 01:08:29.380]  обработка запроса lrx то есть число
[01:08:29.380 --> 01:08:31.140]  количества чисел на отрезке lr больше
[01:08:31.140 --> 01:08:41.180]  равных чем x мы находим от log n вершин в
[01:08:41.180 --> 01:08:44.540]  дереве отрезков в дереве отрезков
[01:08:44.540 --> 01:08:47.100]  которые как раз в объединении целиком
[01:08:47.100 --> 01:08:50.260]  покрывают отрезок lr ровно по одному разу
[01:08:50.260 --> 01:08:56.260]  которые покрывают отрезок lr ну
[01:08:56.260 --> 01:08:57.540]  собственно ровно это мы и делаем во
[01:08:57.540 --> 01:08:59.620]  всяких гетцамах предыдущих мы так
[01:08:59.620 --> 01:09:01.100]  спускаемся по дереву что мы доходим
[01:09:01.140 --> 01:09:02.680]  до вершины, Которые целиком контрольifies
[01:09:02.680 --> 01:09:04.680]  часть отрезка и так ну и так сделали
[01:09:04.680 --> 01:09:07.300]  несколько раз дошли до каких-то вершин
[01:09:07.300 --> 01:09:09.780]  в объединение не как они как раз дают
[01:09:09.780 --> 01:09:11.260]  весь отрезок на весь отрезок
[01:09:11.260 --> 01:09:13.300]  diver также здесь мы как-то спустились
[01:09:13.300 --> 01:09:14.760]  не знаю там вот так спускалисьmostе
[01:09:14.760 --> 01:09:16.500]  одно вершинку здесь тускались
[01:09:16.500 --> 01:09:18.700]  в другую здесь третью вот они в
[01:09:18.700 --> 01:09:20.120]  объединении то есть вот это вот плюс
[01:09:20.120 --> 01:09:21.520]  вот это вот плюс вот это вот в обнов Go
[01:09:21.520 --> 01:09:23.340]  Дают весь отрезок subtractor
[01:09:23.340 --> 01:09:25.680]  а дальше в каждой из них запускаем bin
[01:09:25.680 --> 01:09:26.820]  поиск
[01:09:26.820 --> 01:09:30.500]  продолжаем да в каждой из них
[01:09:30.500 --> 01:09:43.500]  из них, с помощью бинарного поиска, с помощью бинарного поиска, находим
[01:09:43.500 --> 01:09:51.020]  количество чисел больше и равных, чем х. То есть в каждом вот этом вот отцежетрованном
[01:09:51.020 --> 01:09:55.860]  списке, в котором у меня хранится bin поиск и там плюс к ответу. Тогда-тогда
[01:09:55.860 --> 01:10:00.020]  симпатотика ответ на запрос, это лог квадрат.
[01:10:00.820 --> 01:10:06.300]  Лог квадрат. Потому что у меня логарифм-вершинок и в каждой вершинке у меня bin поиск.
[01:10:06.300 --> 01:10:10.580]  Логарифм-вершинок и в каждой вершине bin поиск, которые работают опять за логарифм.
[01:10:10.580 --> 01:10:14.980]  Поэтому а симпатотика ответа на запрос будет лог квадрат.
[01:10:16.980 --> 01:10:19.980]  Что-что?
[01:10:20.220 --> 01:10:24.700]  Не, ну не обязательно двумя, конечно. Например, вот здесь, если у вас будет
[01:10:24.700 --> 01:10:29.900]  отрезок там с первого по седьмой просто, вот такой, то вы его двумя не покроете,
[01:10:29.900 --> 01:10:34.900]  то есть у вас будет три вершинки, вот это, вот это и вот это. В худшем случае логарифм придется всегда.
[01:10:44.900 --> 01:10:49.900]  Так, давайте подумаем. Мы по сути разбили наш массив lr, который имеет длину в худшем случае n,
[01:10:49.900 --> 01:10:54.900]  на несколько кусочков суммарной длины тоже n. То есть если у меня есть k1 плюс и так далее,
[01:10:54.900 --> 01:11:01.900]  плюс там km равно n, то я работаю за логарифм k1 плюс и так далее, плюс логарифм km, верно?
[01:11:01.900 --> 01:11:04.900]  Да, сумма логарифма всех этих штук.
[01:11:04.900 --> 01:11:11.900]  Ну, я напишу так, я напишу, что это логарифм произведения k1 и так далее на km,
[01:11:11.900 --> 01:11:15.900]  потому что сумма логарифм – это логарифм произведения.
[01:11:15.900 --> 01:11:20.900]  Дальше, ну, сейчас.
[01:11:24.900 --> 01:11:29.900]  На самом деле, возможно, вы правы, да, но это надо чуть более тонко проанализировать.
[01:11:29.900 --> 01:11:34.900]  То есть, ну, в худшем случае, если я здесь скажу, что все каиты – это n делит на m,
[01:11:34.900 --> 01:11:39.900]  если все каиты – это n делит на m, то здесь будет, ну, а m – это примерно логарифм n.
[01:11:39.900 --> 01:11:45.900]  m – это примерно логарифм. Тогда вот здесь будет написано n делит на m в степени m,
[01:11:45.900 --> 01:11:50.900]  и вот я беру логарифм. Ну, короче, m – это что-то, что-то, значит, деление на m – это несущественно.
[01:11:50.900 --> 01:11:56.900]  Главное, что здесь будет логарифм от n в степени m, и у вас будет все равно, ну, вот m вынесется умножением.
[01:11:56.900 --> 01:12:01.900]  Короче, в общем, лучше не получится. То есть, если проанализировать как-то в тупую,
[01:12:01.900 --> 01:12:06.900]  то есть, если пытаться максимизировать вот эту вот штуку при этом условии,
[01:12:06.900 --> 01:12:10.900]  то у вас будет лог квадрат. Вот скажем так. У вас будет лог квадрат.
[01:12:10.900 --> 01:12:15.900]  Но если аккуратно понять, как именно устроены эти отрезки, что там, видимо,
[01:12:15.900 --> 01:12:21.900]  в каждой глубине у вас максимум два отрезка может быть, то есть вот эти вот вершины,
[01:12:21.900 --> 01:12:26.900]  которые вы строите, они такие, что их максимум по 2-3 на каждом уровне.
[01:12:26.900 --> 01:12:30.900]  И тогда, наверное, можно получить оценку логарифм. Да, но это чуть более тонкий анализ.
[01:12:30.900 --> 01:12:40.900]  Можете попробовать самостоятельно. Так, хорошо. Я недосказал, как именно мы строим,
[01:12:40.900 --> 01:12:46.900]  как мы получаем вот это вот дерево Merge Sort. Как мы получаем, сколько это времени занимает,
[01:12:46.900 --> 01:12:49.900]  сколько это памяти занимает. Давайте с этим разберемся.
[01:12:49.900 --> 01:12:53.900]  Ну, со временем все понятно. Это просто алгоритм Merge Sort.
[01:12:53.900 --> 01:12:56.900]  Мы его уже понимаем, как он работает. Он работает за n log n.
[01:12:56.900 --> 01:13:02.900]  Построение вот этого всего, построение, это n log n времени.
[01:13:02.900 --> 01:13:09.900]  Там даже тетто от n log n, потому что в точности n log n времени.
[01:13:09.900 --> 01:13:13.900]  Теперь что с памятью? Можете ли вы мне сказать, сколько памяти занимает вот такое дерево,
[01:13:13.900 --> 01:13:18.900]  если я в каждой вершине храню ассортированный вектор всего, что находится под деревом?
[01:13:18.900 --> 01:13:26.900]  n log n, да. Память здесь тоже n log n. К сожалению, тоже тетто от n log n,
[01:13:26.900 --> 01:13:31.900]  потому что каждое конкретное число, скажем, a i t, оно хранится log n раз.
[01:13:31.900 --> 01:13:35.900]  Вот есть у вас a 4. Оно хранится здесь, здесь и здесь.
[01:13:35.900 --> 01:13:39.900]  Ну и каждая a i t хранится log раз, то есть участвует в алгоритмическом числе массивов.
[01:13:39.900 --> 01:13:43.900]  Поэтому суммарно размер всех этих массивов, он, конечно, n log n.
[01:13:43.900 --> 01:13:48.900]  Поэтому здесь памяти чуть больше, чем, скажем, в обычном дереве отрезков.
[01:13:48.900 --> 01:13:53.900]  Если в обычном у вас память линейное количество, то здесь n log n.
[01:13:53.900 --> 01:13:57.900]  Но построение такое же, как в Merge Sort. У вас просто есть нижний уровень.
[01:13:57.900 --> 01:14:02.900]  Вы берете два какие-то кусочка и склеиваете их с помощью процедуры Merge, вот эти два указателя.
[01:14:02.900 --> 01:14:05.900]  Поэтому построение работает с n log n.
[01:14:05.900 --> 01:14:10.900]  Так, окей, это вот такое решение с помощью бинпоисков.
[01:14:10.900 --> 01:14:15.900]  Теперь на самом деле можно это оптимизировать и вообще сделать только один бинпоиск.
[01:14:18.900 --> 01:14:26.900]  И получить асимптотику честный алгоритм без всяких там анализов того, как именно происходит разбиение на вершинке.
[01:14:27.900 --> 01:14:30.900]  А именно, давайте сделаем следующее.
[01:14:30.900 --> 01:14:34.900]  Давайте мы для каждой вершины, вот что у нас здесь написано.
[01:14:34.900 --> 01:14:39.900]  У нас здесь написано какой-то ассортированный массив, который как-то разбит на левые и правые кусочки.
[01:14:39.900 --> 01:14:43.900]  То есть какие-то элементы пошли влево, какие-то вправо.
[01:14:43.900 --> 01:14:48.900]  Тогда давайте нарисуем как бы не то, что историю каждого элемента, то есть откуда он именно пришелся.
[01:14:48.900 --> 01:14:51.900]  Вот эта четверка пришла из этой четверки, там пятерка отсюда и так далее.
[01:14:51.900 --> 01:14:59.900]  А мы для каждого элемента верхнего массива напишем элемент, минимальный элемент, который его больше равен.
[01:14:59.900 --> 01:15:02.900]  Сейчас я вот это все сотру и нарисую все стрелочки.
[01:15:11.900 --> 01:15:14.900]  Вот тут у меня был массив 2467.
[01:15:14.900 --> 01:15:16.900]  2467.
[01:15:16.900 --> 01:15:22.900]  Так вот, я для каждого числа верхнего массива нарисую две стрелочки влево и вправо.
[01:15:22.900 --> 01:15:26.900]  А именно, на минимальное число больше или равное, чем вот это число.
[01:15:26.900 --> 01:15:28.900]  Например, вот есть у меня нолик.
[01:15:28.900 --> 01:15:32.900]  У него минимальный больше или равный его слева это ноль, а здесь двойка.
[01:15:32.900 --> 01:15:35.900]  Минимальный больше или равный вот это двойка.
[01:15:35.900 --> 01:15:38.900]  Затем, скажем, для двойки.
[01:15:38.900 --> 01:15:41.900]  Двойка будет ссылаться вот сюда и вот сюда.
[01:15:41.900 --> 01:15:46.900]  Минимальный больше или равный двойки, простите, это 3 слева.
[01:15:46.900 --> 01:15:48.900]  Что здесь еще интересно?
[01:15:48.900 --> 01:15:52.900]  Например, шестерка показывает здесь сюда, а здесь вот сюда, после пятерки,
[01:15:52.900 --> 01:15:56.900]  потому что слева нет ни одного числа больше или равного, чем 6.
[01:15:56.900 --> 01:15:58.900]  То же самое для семерки.
[01:15:58.900 --> 01:16:01.900]  Она указывает сама на себя и на этот несуществующий элемент.
[01:16:01.900 --> 01:16:10.900]  Итак, для каждого числа храним два указателя.
[01:16:10.900 --> 01:16:12.900]  Ну, точнее, там два индекса.
[01:16:12.900 --> 01:16:14.900]  Я их назову указателями.
[01:16:14.900 --> 01:16:16.900]  Два указателя.
[01:16:19.900 --> 01:16:25.900]  На минимальные числа, давайте я его назову у.
[01:16:25.900 --> 01:16:27.900]  Для каждого числа у храним два указателя.
[01:16:27.900 --> 01:16:39.900]  На минимальные числа больше или равные, либо равные у в обоих сыновьях.
[01:16:40.900 --> 01:16:42.900]  В обоих сыновьях вершины v.
[01:16:44.900 --> 01:16:48.900]  Есть у меня число, оно понятно, оно лежит либо слева, либо справа.
[01:16:48.900 --> 01:16:51.900]  То есть одна из стрелочек обязательно будет показывать просто на y.
[01:16:51.900 --> 01:16:56.900]  Поскольку y откуда-то пришел, он обязательно хотя бы одна из двух стрелок указывает на тот же самый элемент.
[01:16:56.900 --> 01:17:01.900]  А вот в другой вершине мы будем хранить стрелочку на просто минимальный больше или равный.
[01:17:01.900 --> 01:17:03.900]  На минимальный больше или равный.
[01:17:03.900 --> 01:17:07.900]  Эти все стрелочки очень легко считаются там же, когда вы делаете мерч.
[01:17:07.900 --> 01:17:12.900]  Вот есть у вас два эти массива отсортированные, вам нужно сделать от них мерч и еще все стрелки посчитать.
[01:17:12.900 --> 01:17:14.900]  Ну это очень просто.
[01:17:14.900 --> 01:17:16.900]  Сначала вы написали 0, вы написали минимальное число.
[01:17:16.900 --> 01:17:19.900]  Тогда понятно, что он пришел отсюда, стрелка будет сюда.
[01:17:19.900 --> 01:17:23.900]  А стрелка в противоположном массиве будет просто на тот элемент, который вы еще не добавили.
[01:17:23.900 --> 01:17:27.900]  Потому что тот как раз первый недобавленный, это тот, который больше или равен чем этот 0.
[01:17:27.900 --> 01:17:32.900]  Дальше вы написали единицу, она ссылается сама на себя и на этот же недобавленный элемент на 2.
[01:17:32.900 --> 01:17:36.900]  Потом вы пишете 2, она ссылается на себя и на первый недобавленный слева.
[01:17:36.900 --> 01:17:38.900]  Вот на эту стройку.
[01:17:38.900 --> 01:17:43.900]  Короче говоря, все эти стрелки легко насчитываются там же, когда вы делаете мерч.
[01:17:43.900 --> 01:17:47.900]  Просто у вас есть ссылки на минимальный неиспользованный здесь, минимальный неиспользованный здесь.
[01:17:47.900 --> 01:17:51.900]  Вы пишете один из них и ссылаетесь как раз на это число и на то число.
[01:17:51.900 --> 01:17:54.900]  Ну в общем, туда, где у вас были указатели.
[01:17:54.900 --> 01:17:58.900]  И с помощью этих стрелок уже можно отвечать на запросы.
[01:17:59.900 --> 01:18:04.900]  Да, вот это вот количество чисел, количество чисел больше или равных х.
[01:18:04.900 --> 01:18:06.900]  Просто идя по этим стрелкам.
[01:18:06.900 --> 01:18:10.900]  Потому что вот, например, не знаю, было у меня там х равно.
[01:18:10.900 --> 01:18:13.900]  Так, чтобы интересно такое написать.
[01:18:13.900 --> 01:18:15.900]  Ну тройка давайте, да.
[01:18:15.900 --> 01:18:18.900]  Вот у меня, я эту тройку нашел одним бинпоиском.
[01:18:18.900 --> 01:18:22.900]  Значит в корне сделал бинпоиск, нашел, где эта тройка лежит.
[01:18:22.900 --> 01:18:24.900]  Дальше у меня есть две стрелки.
[01:18:24.900 --> 01:18:26.900]  Стрелка вот сюда и стрелка вот сюда.
[01:18:27.900 --> 01:18:30.900]  Ну и по сути это ровно то, что мне нужно от обоих сыновей.
[01:18:30.900 --> 01:18:36.900]  Мне нужно как бы потом, в этих сыновях, как бы бинпоиском найти минимальное число больше или равное Чем Х.
[01:18:36.900 --> 01:18:38.900]  Но эти стрелки ровно это и делают.
[01:18:38.900 --> 01:18:40.900]  Это тройка ссылается на эту тройку,
[01:18:40.900 --> 01:18:44.900]  а здесь на четверку, то есть на минимальное число справа больше или равное чем 3.
[01:18:44.900 --> 01:18:48.900]  Поэтому мне здесь бинпоиск не нужен, мне не нужно будет פускать бинпоиск в этом ребенке.
[01:18:48.900 --> 01:18:50.900]  Мне нужно просто перейти по этой стрелке.
[01:18:50.900 --> 01:18:53.900]  То есть я теперь хранил вот эту тройку и эту четверку.
[01:18:53.900 --> 01:18:55.900]  Дальше, если мне там нужно спуститься вот здесь скажем,
[01:18:55.900 --> 01:19:01.860]  скажем, у меня стрелка стоит сюда и сюда, поэтому теперь вместо бинпоиска там по тройке или по
[01:19:01.860 --> 01:19:06.980]  четверке я просто спущусь вот сюда и сюда, и это как раз минимальные элементы в обоих кусках,
[01:19:06.980 --> 01:19:13.940]  которые больше равны чем 3, потому что тройки нигде нету, 2 меньше чем 3, 6 это минимально больше
[01:19:13.940 --> 01:19:18.780]  равное чем 3, и так будет всегда, мы просто можем пойти по стрелочкам, и это и будет тот самый
[01:19:18.780 --> 01:19:23.780]  минимальный элемент, который мы ищем, минимальный больше равный чем x. В итоге мы избавились от
[01:19:23.780 --> 01:19:28.380]  бинпоисков, мы оставили только один бинпоиск в корне, и потом просто проходим по этим стрелочкам,
[01:19:28.380 --> 01:19:37.100]  мы получается избавились от бинпоисков, их заменили на проходы по стрелкам. Вместо
[01:19:37.100 --> 01:19:55.180]  логарифмического количества бинпоисков мы делаем один, один бинпоиск в корне,
[01:19:55.180 --> 01:20:11.100]  и потом переходим по стрелкам, а потом переходим по стрелкам. Ну и все, и тогда,
[01:20:11.100 --> 01:20:15.060]  если я дошел до вершинки, где мне нужно найти количество чисел там больше равных чем x,
[01:20:15.060 --> 01:20:19.780]  мне нужно просто понять, куда дошли вот эти вот стрелочки, вот это иду-иду-иду, спустился,
[01:20:19.780 --> 01:20:24.380]  и вот это и есть то самое минимальное число, которое я искал, то есть дальше здесь не нужно
[01:20:24.380 --> 01:20:34.980]  пускать бинпоиск, я уже знаю то самое минимальное число, больше равное чем x. Все? Нет-нет,
[01:20:34.980 --> 01:20:42.100]  у нас стрелочки есть вообще везде. Да, я это, возможно, недосказал, у меня для каждой вершинки
[01:20:42.100 --> 01:20:47.620]  и каждого числа в нем хранятся все вот эти вот стрелочки, потому что каждой вершины получается
[01:20:47.620 --> 01:20:53.100]  из двух более низких операций мерч, и этот мерч, он не только склеивает два массива,
[01:20:53.100 --> 01:20:56.220]  но и все эти стрелочки насчитывает. Все эти стрелки есть на всех уровнях.
[01:20:56.220 --> 01:21:04.980]  Вот, тем самым мы как бы избавились от бинпоиска, и тогда асимптотика уже точно логарифм. Асимптотика
[01:21:04.980 --> 01:21:20.700]  ответа на запрос. Ответа на запрос. Ну, тут уже, ну ладно, не важно. Вот логарифм. Логарифмэн. Вот так
[01:21:20.700 --> 01:21:24.260]  работает fractional cascading, это именно вот эти вот стрелочки, которые нам позволяют обойтись
[01:21:24.260 --> 01:21:30.260]  без бинпоиска. Все, тогда то, что я вот анонсировал про количество различных наотрезков, уйдет на
[01:21:30.260 --> 01:21:33.900]  семинар. На этом мы заканчиваем на сегодня. Спасибо, до следующего раза.
