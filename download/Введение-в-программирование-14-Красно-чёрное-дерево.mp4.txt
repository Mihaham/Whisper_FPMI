[00:00.000 --> 00:11.640]  У нас сегодня последняя лекция, и мы разберем сегодня
[00:11.640 --> 00:12.640]  красно-черное дерево.
[00:12.640 --> 00:20.600]  Это еще одна возможная реализация дерева поиска.
[00:20.600 --> 00:22.800]  Мы прошли с вами уже много, и вот сегодня еще одно
[00:22.800 --> 00:23.800]  и последнее.
[00:23.800 --> 00:29.000]  Зачем это нужно мы обсудим в конце.
[00:29.000 --> 00:37.000]  Мы сравним, построим итоговую табличку, где в чатике
[00:37.000 --> 00:38.000]  преподавателей.
[00:38.000 --> 00:47.400]  Сравним все деревья, которые мы прошли, и поймем, чем
[00:47.400 --> 00:49.880]  это лучше остальных, чем он уступает другим.
[00:49.880 --> 00:53.160]  В разных случаях нужны разные деревья, поэтому
[00:53.160 --> 00:56.800]  полезно иметь представление о них обо всем.
[00:56.960 --> 00:59.960]  Итак, определение.
[00:59.960 --> 01:00.960]  Красно-черное дерево.
[01:00.960 --> 01:03.120]  Кстати, давайте я сегодняшнюю лекцию буду писать синим
[01:03.120 --> 01:05.360]  маркером, потому что, раз оно красно-черное, нам
[01:05.360 --> 01:07.640]  нужно будет много красного и черного.
[01:07.640 --> 01:11.760]  Давайте я синий как нейтральный буду использовать для текста.
[01:11.760 --> 01:26.360]  Дерево поиска называется красно-черным, если выполнять
[01:26.360 --> 01:27.840]  следующие пять свойств.
[01:27.840 --> 01:28.840]  Первое.
[01:28.840 --> 01:37.560]  Все вершины покрашены в красный или черный цвет.
[01:37.560 --> 01:49.000]  Я красный буду писать Red или Black цвет.
[01:49.000 --> 01:53.560]  Соответственно дерево по-английски Red Black, Red Black 3.
[01:54.280 --> 01:57.280]  Второе.
[01:57.280 --> 02:07.680]  Корень черного дерева имеет черный цвет.
[02:07.680 --> 02:13.360]  Третье.
[02:13.360 --> 02:23.240]  У каждой вершины, сейчас не так, сейчас скажу, значит
[02:23.440 --> 02:25.000]  я хочу сделать следующее.
[02:25.000 --> 02:27.120]  Я хочу, чтобы у каждой вершины, в которой находился какой-то
[02:27.120 --> 02:29.440]  ключ, то есть у каждой нормальной вершины, которая покрашена
[02:29.440 --> 02:32.240]  в красный или черный цвет, было всегда два ребенка.
[02:32.240 --> 02:35.560]  И причем либо это настоящий обычный ребенок, то есть
[02:35.560 --> 02:39.240]  обычная вершина ключ, либо это вершина такой лист,
[02:39.240 --> 02:41.920]  который будет как бы мы будем воспринимать как
[02:41.920 --> 02:45.040]  на УПТР, как указатель на несуществующую вершинку.
[02:45.040 --> 02:49.600]  И у этих вершинок, которые как бы указательны на на
[02:49.600 --> 02:52.800]  УПТР мы будем считать отдельными элементами нашего дерева,
[02:52.800 --> 03:04.040]  и никакие ключи не хранятся, и они покрашены в тоже чёрный цвет, и так, у каждой вершины ровно два сына,
[03:04.040 --> 03:16.880]  и они могут быть чёрными нулевыми листьями, они могут быть чёрными
[03:16.880 --> 03:26.680]  листьями без ключей. Давайте мы сначала это напишем, потом я приведу какой-нибудь пример красно-черного
[03:26.680 --> 03:33.280]  дерева и поймём о чём идёт речь. Листьями без ключей. То есть у нас как бы будут обычные вершины,
[03:33.280 --> 03:37.840]  в которых хранятся ключи, а листьями будут выступать только такие вершины специальные, в которых не
[03:37.840 --> 03:42.480]  хранится ключ, она обязательно чёрная, ну и по сути вот такие, мы просто подвешиваем ко всем вершинам
[03:42.480 --> 03:48.440]  такие вот листья чёрные, чтобы только внутренние вершины дерева, то есть все не листовые вершины
[03:48.440 --> 03:54.800]  дерева, отвечали ключам, а листики это только вот эти вот фиктивные чёрные вершины. Четвёртое свойство,
[03:54.800 --> 04:09.240]  значит, дети красной вершины, красной вершины, так красной внутренним красным цветом, дети
[04:13.480 --> 04:14.720]  красной вершины,
[04:19.400 --> 04:26.160]  чёрные. Ну имеется в виду вот что есть красная вершина, у неё есть два ребёнка всегда и они
[04:26.160 --> 04:30.800]  оба должны быть чёрными, то есть не всё под дерево чёрное, а два непосредственных сына левый и правый.
[04:30.800 --> 04:39.720]  И наконец пятое, если мы начинаем путь в любой вершины и идём вниз до листа, то на этом пути,
[04:39.720 --> 04:43.840]  на любом таком пути будет поровну, будет одинаковое количество чёрных вершин, будет
[04:43.840 --> 05:02.280]  поровну чёрных вершин. Для любого В на любом нисходящем пути от В до листа одно и то же
[05:02.360 --> 05:16.520]  количество чёрных вершин. Вот, ну то есть, например, вот есть какая-то вершинка В,
[05:16.520 --> 05:22.560]  например, она сама по себе красная, в ней хранится какой-то ключ. И вот есть там, не знаю, какие-то её
[05:22.560 --> 05:30.000]  дети, здесь, например, чёрный, здесь чёрный, вот здесь, например, вот эти два листика, которые я
[05:30.000 --> 05:33.840]  буду обозначать прямогольниками, то есть здесь хранится какой-то ключ, здесь какой-то ключ,
[05:33.840 --> 05:38.680]  здесь ключ, а вот здесь ключей нет, то есть это чёрные листья, в которых нет ключей, и тогда,
[05:38.680 --> 05:46.340]  например, вот на этом пути от вершинки В вот сюда вот, есть две чёрные вершины, первая, вот эта
[05:46.340 --> 05:50.640]  вторая. Соответственно, тогда требование, что на любом таком пути от В, куда-либо вниз, куда-либо до
[05:50.640 --> 05:57.360]  листьев будет ровно две черные вершины. Вот такое пятый наш требуй. Ну, какой-нибудь пример.
[05:57.360 --> 06:04.600]  Пример. Значит, в корне обязательно должна быть, корень обязательно черный. Пусть, например,
[06:04.600 --> 06:14.360]  там число будет 20. Дальше пусть будет что-нибудь красное. Здесь какое-нибудь число 10, а здесь черное
[06:14.360 --> 06:22.240]  число 25. Здесь, например, я сделаю два вот таких черных листика. И тогда, например, смотрите,
[06:22.240 --> 06:26.000]  вот если в качестве корня рассматриваете вершинку В, то есть если вы это корень,
[06:26.000 --> 06:32.120]  тогда вот здесь есть путь, на котором суммарно три черные вершины. То есть В, сын и внук.
[06:32.120 --> 06:36.520]  Здесь три черные вершины. Тогда, соответственно, на любом пути, не исходящем отсюда, тоже должно
[06:36.520 --> 06:42.280]  быть три черные вершины. Ну, например, как может выглядеть это дерево. Извините, отсюда это откуда?
[06:42.280 --> 06:55.160]  Сейчас. От корня. На правом пути вот здесь три черные. Значит, на таком пути, не исходящем
[06:55.160 --> 06:59.640]  влево, тоже должно быть три черные вершины. Значит, красное. Пусть будет это красное,
[06:59.640 --> 07:02.640]  тогда мне нужно еще, чтобы было хотя бы две черные. Ну, точнее, ровно две черные. Ну,
[07:02.640 --> 07:10.080]  пусть я вот такую картинку нарисую. Вот такую. Так, я еще хочу что-нибудь сделать, чтобы...
[07:10.320 --> 07:24.160]  Одну секунду, я придумаю что-нибудь интересное. Да, сейчас будет. Вот здесь будет черное. Вот здесь
[07:24.160 --> 07:30.640]  будет один лист, такой фиктивный, в котором не хранится ключ. Дальше будет, в качестве левого сына,
[07:30.640 --> 07:37.080]  будет какая-то красная вершина, и у нее два черных листа. Ну и, соответственно, числа там,
[07:37.420 --> 07:44.280]  здесь можно писать что-то в стиле 18, здесь 15, здесь какой-нибудь там 8. Так что это корректное
[07:44.280 --> 07:50.920]  красно-черное дерево. Например, еще раз, давайте для v проверим пятое свойство. На вот таком пути
[07:50.920 --> 07:56.840]  3 черных, на таком пути 3 черных, на таком пути тоже 3 черных, здесь 3 черных, здесь 3 черных.
[07:56.840 --> 08:00.520]  В общем, здесь везде получается по 3 черных. То же самое можно проверить для вот
[08:00.520 --> 08:04.260]  этих вершинки в 18. Здесь на этом пути 2 черных, на этом пути 2 черных, на этом пути две черных.
[08:04.260 --> 08:10.060]  для всех это выполняется дальше важно это уже свойство что нет двух красных
[08:10.060 --> 08:16.260]  подряд то есть дети красная обязательно черная вот ну и все остальные свойства
[08:16.260 --> 08:19.100]  тоже вроде выполняется вот вам пожалуйста корректная красно-черная дерево
[08:19.100 --> 08:29.980]  пожалуйста надолго от представлять свойствами давайте спасибо вот значит такие странные
[08:29.980 --> 08:35.580]  свойства вот какое-то дерево да зачем это нужно непонятно но давайте не знаю то есть кто-то
[08:35.580 --> 08:40.060]  это придумал давайте поймем почему это вообще работает почему это может быть полезно нам для
[08:40.060 --> 08:52.020]  реализации каких-то деревьев утверждение если в красно-черном дереве в красно-черном дереве
[08:52.020 --> 09:00.500]  содержится n ключей повторюсь да что в листьях вот этих вот вершинах фиктивных которые я рисую
[09:00.500 --> 09:04.340]  прямоугольниками там ключей нет это просто такие фиктивные вершины которые покрашены в черный
[09:04.340 --> 09:08.980]  цвет просто чтобы нам было удобно считать черную но вот эту глубину да по чтобы нам было удобно
[09:08.980 --> 09:14.180]  считать число черных чтобы всегда мы заканчивались в черной вершинке на вот этом черном листике
[09:14.180 --> 09:22.580]  так вот если содержится n ключей вот как в этом случае в этом дереве у меня сколько ключей раз
[09:22.580 --> 09:28.660]  два три четыре пять шесть то есть есть куча листьев но самих ключей ровно шесть так если
[09:28.660 --> 09:37.580]  содержится n ключей то глубина аж не превосходит удвоенного двойственного алгоритма вот он присоединен
[09:37.580 --> 09:43.260]  ну это собственно то что нам всегда нужно да мы хотим чтобы глубина нашего дерева поиска была
[09:43.260 --> 09:48.520]  как можно меньше вот понятно что она там меньше чем логарифмической быть может иначе у нем просто
[09:48.520 --> 09:52.380]  не может быть аналиментов вот давайте покажем что здесь максимум удвоен алгоритм
[09:52.380 --> 10:00.380]  удвоен алгоритм глубина фиктивная вершина всегда чёрная и всегда листья да именно так фиктивные
[10:00.380 --> 10:05.620]  вершины это вот эти вот листья которые мы подвешиваем к каждой вершинке в которых
[10:05.620 --> 10:10.460]  содержится ключ ну в смысле если если у нее не хватает детей то мы подвешиваем к ней детей это
[10:10.460 --> 10:14.980]  это будут фиктивные вершины, листья всегда чёрные, да.
[10:14.980 --> 10:17.980]  Доказательства. Давайте докажем сначала следующее.
[10:17.980 --> 10:28.180]  Докажем сначала, что если х это произвольная вершина,
[10:28.180 --> 10:33.500]  произвольная вершина, а bh от х это так называемая
[10:33.500 --> 10:41.100]  чёрная глубина, чёрная глубина вершины х, чёрная глубина
[10:41.100 --> 10:44.260]  это количество чёрных вершин в любом нисходящем пути
[10:44.260 --> 10:58.140]  начиная с х. Количество чёрных вершин в любом нисходящем
[10:58.140 --> 11:05.020]  пути из х без учёта х. То есть сам х мы как бы не учитываем
[11:05.020 --> 11:11.740]  в bh. В этой чёрной глубине мы считаем только более
[11:11.740 --> 11:14.580]  низкие вершины, сама х не учитывается. Ну и поскольку
[11:14.580 --> 11:16.860]  у меня есть свойство, что на любом таком пути будет
[11:16.860 --> 11:18.940]  поровну чёрных вершин, то тогда такая чёрная глубина
[11:18.940 --> 11:21.220]  правильно определена. Раз на любом пути их поровну,
[11:21.220 --> 11:23.940]  то можно вести функцию bh от х как длину любого такого
[11:23.940 --> 11:26.420]  пути, ну в смысле количества чёрных вершин на любом таком
[11:26.420 --> 11:31.780]  пути. Так вот, если bh – это чёрная глубина, то в поддереве
[11:31.780 --> 11:42.220]  х лежит по крайней мере 2 в степени bh от х минус
[11:42.220 --> 11:48.660]  1 ключ. То есть если чёрная глубина какая-то, то этот
[11:48.660 --> 11:50.980]  дерево достаточно большое, оно экспоненциально большое
[11:51.980 --> 11:57.780]  то есть 2 в степени bh от х минус 1. Значит, доказывать
[11:57.780 --> 12:01.540]  этого движения мы будем индукцией по глубине h. Заметьте, не
[12:01.540 --> 12:09.940]  по чёрной глубине, а просто по глубине х. Докажем это
[12:09.940 --> 12:16.380]  индукцией по h от х. Не по чёрной глубине, а просто
[12:16.380 --> 12:20.700]  по глубине. Да, в поддереве, включая х. Да, само х входит
[12:20.700 --> 12:23.380]  в своё поддерево, то есть в той вот 2 в степени минус
[12:23.380 --> 12:29.060]  1 х тоже учитывается. А х учитывает х? Что? А х учитывает
[12:29.060 --> 12:33.900]  самого себя? Ну это уже не важно, давай считать что
[12:33.900 --> 12:39.660]  нет. Значит, база х равно 0, это значит что х – это
[12:39.660 --> 12:46.300]  лист и это фиктивная вершина. А фиктивная вершина, там
[12:46.380 --> 12:52.060]  нет ключей и это чёрная вершина. То есть фиктивная, чёрная – нет
[12:52.060 --> 12:58.020]  ключей, нет ключа. Ну а что такое 2 в степени bh от х? Минус
[12:58.020 --> 13:03.580]  1. Ну если х – это лист, получается такая прямоугольная
[13:03.580 --> 13:05.660]  коробочка, где ничего нет, это просто чёрная эффективная
[13:05.660 --> 13:09.940]  вершина, где нет ключа, тогда bh от х – это тоже 0. В bh мы
[13:09.940 --> 13:14.140]  не учитываем х в плане количества чёрных на нисходящем пути,
[13:14.140 --> 13:19.660]  значит это будет 0, 2 в 0 – это 1, минус 1 – это 0. Ну понятно, что в этом по дереве
[13:19.660 --> 13:23.900]  ничего нет, нет ни одного ключа, а понятно, что их там хотя бы 0. Значит, база верна.
[13:23.900 --> 13:31.740]  Дальше переход. Путь это верно для всех вершинок на какой-то глубине не больше, чем какая-то.
[13:31.740 --> 13:36.260]  Дальше возьмём вершинку х на какой-то фиксированной глубине. Что может быть,
[13:36.260 --> 13:43.420]  у неё есть два сына. И тогда что у них может быть с чёрными глубинами?
[13:43.420 --> 13:49.420]  Давайте я левого сына назову у, не давайте л, правого сына назову г. Какие у них могут быть
[13:49.420 --> 13:56.340]  чёрные глубины? Ну легко понять, что bh от l больше равно, чем bh от х-1, и то же самое bh от r.
[13:56.340 --> 14:02.660]  Bh, если вдруг вы ещё не поняли, bh – это black height, чёрная высота.
[14:02.660 --> 14:08.460]  Извините, а х – это любая вершина, и красная и чёрная может быть?
[14:08.460 --> 14:17.060]  Нет ограничений на цвет. Сейчас я сбился, пишу опять чёрный, давайте синий продолжим.
[14:17.060 --> 14:23.980]  Итак, если х – это произвольная вершина, у неё есть два сына. Если мы в переходе, то h от х больше 0,
[14:23.980 --> 14:31.420]  то есть это не лист. У неё есть два сына, левый и правый. У левой вершинки чёрная глубина хотя бы bh от x-1,
[14:31.420 --> 14:35.980]  потому что мы отрезали максимум одну вершинку. Раньше у меня был какой-то путь нисходящий
[14:35.980 --> 14:41.980]  без учёта х. Теперь я ещё перестал учитывать l, но понятно, что от этого глубина могла уменьшиться максимум на единицу.
[14:41.980 --> 14:46.980]  И то же самое с правым сыном, что bh от r больше равно, чем bh от x-1.
[14:46.980 --> 14:55.980]  Ну и тогда по предположению индукции, поскольку l и r – это менее глубокая вершина, то есть они ниже к листьям находятся,
[14:55.980 --> 15:07.980]  это означает, что в их поддеревьях здесь хотя бы 2 в степени bh от l-1 ключ, и здесь хотя бы 2 в степени bh от r-1 ключ.
[15:07.980 --> 15:25.980]  Суммарно, в поддеревье x вершин сколько? Ну хотя бы 1 плюс 1 от x. Дальше 2 в степени bh от l-1, 2 в степени bh от r-1.
[15:25.980 --> 15:32.980]  Ну и наконец теперь, поставляя вот эти неравенства сюда, получаю как раз то, что нужно. Значит это будет 1-1 сократилось,
[15:32.980 --> 15:46.980]  2 в степени bh от x-1 плюс 2 в степени bh от x-1 минус 1. Это в точности то, что нам нужно.
[15:46.980 --> 15:54.980]  Теперь мы доказали, простейшие индукции, просто снизу вверх по нашему дереву, доказали, что если у x-а фиксирована какая-то черная глубина bh от x,
[15:54.980 --> 16:04.980]  то в поддеревье этой вершины хотя бы вот столько ключей, хотя бы вот столько ключей, то есть вершин с численным значением, неэффективных вершин хотя бы столько.
[16:04.980 --> 16:14.980]  Так, ну теперь зачем это нам? Ну пусть теперь тогда h это высота всего дерева.
[16:14.980 --> 16:26.980]  Дальше легко понять, что bh от корня, от рута больше равно, чем h пополам, так как у нас не может быть такого, что идет две подряд красные вершины.
[16:26.980 --> 16:33.980]  То есть смотрите, вот есть у нас корень, мы знаем, что корень всегда черный, кстати, есть у нас корень, как устроен произвольный путь.
[16:33.980 --> 16:42.980]  Он как-то спускается, считает количество черных вершин, и при этом там нет двух подряд красных, потому что у нас было свойство, что у красной вершины сыновья обязательно черные.
[16:42.980 --> 16:52.980]  Значит, на этом пути понятное дело, что черных хотя бы столько, сколько красных.
[16:52.980 --> 16:56.980]  Ну значит, черная глубина, она хотя бы половина от общей глубины.
[16:56.980 --> 17:09.980]  Итак, черная глубина от корня хотя бы h пополам, так как у красной вершины, у красной вершины любой сын черный.
[17:09.980 --> 17:16.980]  Любой сын черный. Ну значит, черных просто на этом пути хотя бы половина.
[17:16.980 --> 17:23.980]  Вот отсюда сразу следует, что если у меня глубина хотя бы такая, то какое должно выполняться неравенство?
[17:23.980 --> 17:32.980]  n должно быть меньше либо равно, чем 2 в степени, сейчас одну секунду.
[17:32.980 --> 17:44.980]  То есть мы знаем, что в дереве всего n ключей, и при этом если высота такая, то в этом дереве как минимум 2 в степени h пополам минус 1 ключей.
[17:44.980 --> 17:51.980]  Значит, n должно быть больше либо равно, чем эта нижняя оценка. Здесь будет h пополам минус 1.
[17:51.980 --> 17:56.980]  Ну отсюда как раз следует наше требуемое неравенство, что n плюс 1 больше либо равно, чем 2 в степени h пополам.
[17:56.980 --> 18:01.980]  То есть h пополам меньше либо равно, чем двоечный алгорифм от n плюс 1.
[18:01.980 --> 18:08.980]  Ну что то же самое, это означает, что h не больше, чем двойный двоечный алгорифм от n плюс 1.
[18:08.980 --> 18:13.980]  Доказали.
[18:13.980 --> 18:22.980]  Вот, если используя просто черную глубину и зная, что не может быть под красной вершинки другой красной вершины, мы понимаем, что как бы на любом пути черных достаточно много.
[18:22.980 --> 18:34.980]  И раз у меня дерево экспедиционно растет по черной глубине, значит и количество узлов тоже, да, общее количество ключей, но экспедиционно по глубине, значит глубина, наоборот, логарифмична в большинстве ключей.
[18:34.980 --> 18:40.980]  Доказали. Ну, собственно, это нам и дает нашу любимую логарифмическую оценку на глубину.
[18:40.980 --> 18:43.980]  Так же, как в ВВЛ дереве, глубина у нас будет всегда логарифмическая.
[18:43.980 --> 18:50.980]  В отличие от, скажем, сплей дерева, где у нас только амортизировано, все выполняется за логарифм, здесь будет все гарантировано всегда от логарифма,
[18:50.980 --> 18:54.980]  потому что глубина всегда у нас будет не больше, чем удвоенный логарифм.
[18:54.980 --> 18:58.980]  Вот. Доказали.
[18:58.980 --> 19:05.980]  Идем дальше. Ну, давайте скажем, что find в таком дереве выполняется, как в любом дереве поиска.
[19:05.980 --> 19:09.980]  Как в любом дереве поиска.
[19:09.980 --> 19:17.980]  С таким мы уже умеем работать, мы просто встаем в корень, понимаем, когда нужно опуститься влево или вправо, и, собственно, ищем х в одном из двух по деревьям.
[19:17.980 --> 19:21.980]  Это работает за от глубины, то есть за от логарифма.
[19:21.980 --> 19:25.980]  За от логарифма.
[19:25.980 --> 19:30.980]  Вот. Значит, это просто сложнее обстоит ситуация с insert и raise.
[19:30.980 --> 19:32.980]  Давайте к ним перейдем.
[19:32.980 --> 19:36.980]  Как делать insertX?
[19:36.980 --> 19:38.980]  InsertX.
[19:38.980 --> 19:40.980]  А вот как.
[19:40.980 --> 19:45.980]  Значит, мы сначала сделаем все так же, как у нас было в, скажем, наивном дереве поиска.
[19:45.980 --> 19:53.980]  То есть мы сначала пытаемся найти этот х в дереве, то есть как-то спускаемся от корня в поисках этого х, и в какой-то момент доходим до вершинки,
[19:53.980 --> 20:00.980]  у которой, скажем, нужно пойти влево в поисках х, но здесь стоит черный вот этот вот фиктивный лист.
[20:00.980 --> 20:03.980]  То есть картинка какая-то будет такая. Мы дошли до ключа у.
[20:03.980 --> 20:06.980]  Он-то может быть черным, может быть красным, это неважно.
[20:06.980 --> 20:11.980]  И, например, нам в поисках х нужно спуститься влево, а слева у меня стоит фиктивный лист.
[20:11.980 --> 20:13.980]  Что это означает?
[20:13.980 --> 20:16.980]  И вот сюда я хочу поместить х.
[20:16.980 --> 20:25.980]  Тогда я оставляю у как бы неизменным, но в качестве улевого сына я к нему подвешиваю красную вершину х.
[20:25.980 --> 20:30.980]  То есть я создаю вершинку х, крашу ее в красный цвет, подвешиваю слева к этому саму у.
[20:30.980 --> 20:37.980]  И к х, поскольку это теперь как бы стало листом, я к нему подвешиваю ссылки на вот эти две фиктивные вершинки.
[20:37.980 --> 20:40.980]  Они будут обе черные, обе без ключей, они будут листьями.
[20:43.980 --> 20:49.980]  Вообще, кстати, давайте я здесь же замечу, что на самом деле вот эти вот черные прямоугольники, которые я рисую, вот эти листья,
[20:49.980 --> 20:53.980]  их не обязательно хранить прям отдельными вершинами в нашем дереве.
[20:53.980 --> 20:57.980]  То есть не обязательно заводить для них всю память там.
[20:57.980 --> 21:05.980]  Ну как у нас, в принципе, вершина. Это ссылка на левое сына, на правого сына, цвет, ключ и, возможно, еще ссылка на родителя.
[21:05.980 --> 21:13.980]  Так вот, у таких вот фиктивных вершинок, у листьев, на самом деле можно просто завести одну вершину, которая будет отвечать как бы всем листьям.
[21:13.980 --> 21:14.980]  Давайте это запишем.
[21:15.980 --> 21:21.980]  Можно создать всего одну вершину.
[21:24.980 --> 21:25.980]  Можно вопрос.
[21:25.980 --> 21:30.980]  А мы можем хранить просто указатель на фиктивную вершину, как 0ptr?
[21:30.980 --> 21:40.980]  Это не совсем удобно, потому что нам хочется, как бы нам будет иногда очень хотеться брать цвет от вот этой вот как бы фиктивной вершины.
[21:40.980 --> 21:47.980]  Но брать как бы цвет и ифать отдельно, что это если 0ptr, то верни, пожалуйста, черный.
[21:47.980 --> 21:55.980]  Можно так, но классически здесь именно подвешивается вот эта вот одна вершинка, и у нее просто хранится поле, что она черного цвета.
[21:55.980 --> 22:05.980]  И чтобы как бы это не давало сильного проигрыша по памяти, мы на самом деле заведем одну вершину, вот эту фиктивную, и как бы ее подвесим на место всех листиков.
[22:05.980 --> 22:06.980]  То есть вообще картинка будет какая-то такая.
[22:06.980 --> 22:19.980]  Вот если у меня там было много вершинок с листьями какими-то вот такими, то есть если вот это вот мы хотим видеть в реале, то на самом деле мы просто заведем одну вершинку фиктивную,
[22:19.980 --> 22:25.980]  и они все будут на нее ссылаться в качестве левой правой сыны.
[22:25.980 --> 22:34.980]  Так, когда вставка будет неудобной, нам во всей структуре придется у всех элементов хранить указатель на нилы.
[22:34.980 --> 22:43.980]  Ничего не помните, неудобного. Смотрите еще раз. У нас есть отдельная вершина, в которой написано, что она как бы фиктивная.
[22:43.980 --> 22:55.980]  Что это означает? Это значит, что у нее написано, скажем, в качестве цвета, что она черная, и еще, ну там, например, у нее нет ссылки на левую правую сыну.
[22:55.980 --> 23:01.980]  То есть у всех нормальных вершин есть ссылка на левую правую сыну, она указывает либо на настоящую вершину, либо на фиктивную вершину.
[23:01.980 --> 23:06.980]  А у фиктивной вершины, как раз таки, мы будем считать, что ссылка на левую и на правую, это на ЛПТР.
[23:06.980 --> 23:13.980]  И тогда нет никаких проблем. Вот когда я здесь хочу вставить, когда я останавливаюсь, когда я спустился в вершину, у которой нет ни левого, ни правого сына.
[23:13.980 --> 23:23.980]  То есть эта вершина как раз вот та самая эффективная. И для вставки я завожу как раз здесь красную вершину Х и подвешаю к ней две новые вот эти вот черные фиктивные вершины.
[23:23.980 --> 23:36.980]  Так, Максим, нет. Это мы сейчас все пофиксим. Матвей, vertex left nil, потом vertex new vertex будет ошибка.
[23:36.980 --> 23:39.980]  Что такое vertex? Стрелка new vertex, я не понимаю.
[23:39.980 --> 23:49.980]  Ну, то есть мы, типа, отдельно храним от вершины на реальную вершину один указатель, а от вершины на nil мы храним другой указатель, потому что nil не обладает теми же полями.
[23:50.980 --> 24:02.980]  Нет, nil обладает теми же полями. Вот я сказал, что мы вот эти вот узлы, вот эти вот прямоугольнички черные храним на самом деле просто как одну вершину nil, у которой есть все поля.
[24:02.980 --> 24:16.980]  У нее есть черный цвет, но у нее ссылка на левое правое сыно, это null pointer. Нет никаких проблем. То есть это адекватная вершина, просто одна на всех.
[24:20.980 --> 24:29.980]  Статик момбра для всего класса. Да, можно так. То есть нам от нее нужно только то, что у нее черный цвет, да, и у нее нету ссылок на левое правое сыно. Да, можно как статик момбра.
[24:29.980 --> 24:36.980]  Итак, это было просто техническое отступление, как можно реализовать вот это вот подвешивание эффективных черных вершин внизу дерева.
[24:36.980 --> 24:39.980]  Итак, что мы сделали в инсерте? Давайте возвращаться сюда.
[24:39.980 --> 24:51.980]  Так что было с y. Давайте считать, не умоляю общности, что мы подвешиваем x слева. То есть что это означало? Была какая-то вершина y, фиг знает какого цвета, может быть черная, может быть красная.
[24:51.980 --> 24:56.980]  И слева у нее была фиктивная вершина. Левый и ее сын, это вот этот фиктивный лист.
[24:56.980 --> 25:12.980]  Тогда я вне зависимости от цвета y, давайте это подчеркнем, вне зависимости от цвета y, мы подвешиваем в эту вот позицию красный x.
[25:12.980 --> 25:20.980]  Ну и соответственно у x создаем две ссылки слева и справа на нулевую вершину, ну точнее на вот эту фиктивную вершину черной прямой.
[25:20.980 --> 25:28.980]  Сделали так, теперь у меня что-то могло сломаться, конечно же. У меня могло, например, быть так, что если y была красная, то теперь у меня есть две красные вершины подряд.
[25:28.980 --> 25:34.980]  Может быть, например, такая проблема. Мы сейчас с этим будем бороться.
[25:34.980 --> 25:46.980]  Давайте пока поймем, какие вообще могли нарушиться свойства нашего дерева при подвешивании вот этой, при вставке этой черной вершины, извините, красной вершины, на место там, где изначально была, был черный.
[25:46.980 --> 25:50.980]  Если y был красный, будет беда.
[25:50.980 --> 26:05.980]  Да, это мы уже поняли, да, что если, ну то есть это нарушение свойств, кажется, так, у меня где-то написано номера вся, чтобы удобнее было идентифицировать, да, это будет нарушение четвертого свойства.
[26:05.980 --> 26:09.980]  Может быть нарушение четвертого свойства, это если y красный.
[26:09.980 --> 26:11.980]  Ну вроде только его можно нарушить.
[26:11.980 --> 26:14.980]  На самом деле нет.
[26:14.980 --> 26:22.980]  Еще одно свойство может нарушаться при при вставке красной вершины.
[26:22.980 --> 26:25.980]  На самом деле это второе свойство.
[26:25.980 --> 26:38.980]  Но оно может нарушиться только если изначально дерево было пустое, и вы вставили просто красный x, да, в качестве корня, то есть было пустое дерево, вы вставили x в качестве корня, и тогда, соответственно, корень стал красным, а должен быть черным.
[26:38.980 --> 26:41.980]  Да, и теперь точно все, теперь никакие другие свойства нарушаться не могут.
[26:41.980 --> 26:43.980]  Либо второй, либо четвертый.
[26:43.980 --> 26:48.980]  Давайте с этим разберемся и сделаем так, чтобы свойства все восстановились и никаких проблем не было.
[26:48.980 --> 27:01.980]  Вот, значит, ну понятно, что если x, давайте вернусь, значит, если x это сейчас корень, и он красный, то это просто первая вершина нашего дерева, давайте его просто перекрасим в черный цвет, тогда все восстановится.
[27:01.980 --> 27:05.980]  То есть от перекраски корня из красного в черный, понятно, где никакие свойства не поменяются.
[27:05.980 --> 27:11.980]  Теперь, то есть второе свойство легко как бы фиксится, нужно просто перекрасить x в черный цвет.
[27:11.980 --> 27:12.980]  Давайте это тоже запишем.
[27:12.980 --> 27:19.980]  То есть это легко лечится, перекрасить x в черный.
[27:19.980 --> 27:25.980]  Основная проблема это, конечно, четвертое свойство, вот мы с ним разберемся.
[27:25.980 --> 27:30.980]  В ходе эффективной киши можно сделать статик.
[27:30.980 --> 27:31.980]  Да, это уже отсудили.
[27:31.980 --> 27:43.980]  Итак, какая может быть проблема, когда у меня есть красный x, подвешенный к красному родителю.
[27:43.980 --> 27:53.980]  Но смотрите, если этот родитель красный, то поскольку из схода до вставки у меня было корректное красно-черное дерево, значит это точно не корень, y не корень, потому что он красный,
[27:53.980 --> 27:55.980]  значит у него есть черный родитель.
[27:55.980 --> 28:01.980]  Давайте я этого родителя назову G, grandparent.
[28:01.980 --> 28:02.980]  Вот есть черный родитель.
[28:02.980 --> 28:07.980]  Так, давайте ребра я не буду рисовать цветными.
[28:07.980 --> 28:09.980]  Ребра все-таки синие будут.
[28:09.980 --> 28:12.980]  Вот, а ключи у меня красный и черный.
[28:12.980 --> 28:22.980]  Тогда, значит, у меня есть, получается, вешина x, у него красный родитель и у него есть черный, опять-таки, родитель, который является дедушкой для нашей вешки x.
[28:22.980 --> 28:27.980]  Тогда мы посмотрим на так называемый дядю вешины x.
[28:27.980 --> 28:29.980]  То есть это второй сын вешины G.
[28:29.980 --> 28:33.980]  Вот есть уже один сын, это y, и есть второй сын, который мы назовем u.
[28:33.980 --> 28:34.980]  Слово ankle.
[28:34.980 --> 28:38.980]  У него есть две опции, либо он черный, либо он красный.
[28:38.980 --> 28:47.980]  Какого цвета дядя вешины x?
[28:47.980 --> 28:49.980]  Первый случай, когда он красный.
[28:49.980 --> 28:52.980]  Значит, случай один.
[28:52.980 --> 28:57.980]  Когда u красный.
[28:57.980 --> 28:58.980]  То есть картинка такая.
[28:58.980 --> 29:04.980]  Есть красный x, есть красный y, есть красный u и есть черный grandparent.
[29:04.980 --> 29:06.980]  Вот такое дерево.
[29:06.980 --> 29:09.980]  Ну, соответственно, там слева, справа могут быть подвешенные всякие деревья.
[29:09.980 --> 29:10.980]  Давайте я не буду рисовать.
[29:10.980 --> 29:12.980]  То есть понятно, что вот здесь, давайте один раз нарисую.
[29:12.980 --> 29:15.980]  Вот здесь есть какие-то всякие деревья подвешенные.
[29:15.980 --> 29:16.980]  Тогда мы сделаем следующее.
[29:16.980 --> 29:22.980]  Мы просто перекрасим G в красный, а u и y в черный.
[29:22.980 --> 29:25.980]  Значит, вместо G я рисую красное G.
[29:25.980 --> 29:30.980]  Вместо y и u я рисую черное y и u, а x оставляю красное.
[29:30.980 --> 29:33.980]  Все остальное не трогаю, не меняю, не перекрашиваю.
[29:33.980 --> 29:36.980]  То есть под деревья остаются такими же, как были.
[29:36.980 --> 29:39.980]  Все ссылки, все связы остаются такими же, как были.
[29:39.980 --> 29:42.980]  И тогда я утверждаю, что проблема решена.
[29:42.980 --> 29:45.980]  Ну, во-первых, по крайней мере, здесь локально.
[29:45.980 --> 29:48.980]  Действительно, мы избавились от двух подряд красных вершин.
[29:48.980 --> 29:53.980]  Было x и y, теперь якобы их разнес стало здесь чередование.
[29:53.980 --> 29:56.980]  Ну, а что еще нужно проверить?
[29:56.980 --> 29:58.980]  Там почти все свойства тривиальные.
[29:58.980 --> 30:01.980]  Понятно, что все вершины красные или черные.
[30:01.980 --> 30:04.980]  Понятно, что если мы еще не дошли до корня, то с корнем нет проблем.
[30:04.980 --> 30:07.980]  Понятно, что все листья у меня остались черными, потому что я листья не перекрашиваю.
[30:07.980 --> 30:10.980]  Эти эффективные вершины не перекрашиваю.
[30:10.980 --> 30:14.980]  Самое сложное свойство – это только что сохраняется черная глубина.
[30:14.980 --> 30:16.980]  Давайте вот за ней последим.
[30:16.980 --> 30:19.980]  Что вот, например, здесь, если у меня был черный g,
[30:19.980 --> 30:22.980]  то получается, что на всех вот таких вот путях у меня одинаковая черная глубина.
[30:22.980 --> 30:24.980]  То есть количество черных, на них нам всех одинаково.
[30:24.980 --> 30:28.980]  Но теперь смотрите, если я поменял цвета у вот таких трех вершинок,
[30:28.980 --> 30:30.980]  то ничего, собственно, не изменилось.
[30:30.980 --> 30:34.980]  У меня, скажем, если вот здесь было суммарно x красных,
[30:34.980 --> 30:37.980]  ну не x, а k, тогда здесь осталось уже k красных,
[30:37.980 --> 30:42.980]  потому что я просто поменял цвета у g и у y.
[30:42.980 --> 30:44.980]  Количество черных, черных.
[30:44.980 --> 30:46.980]  Количество черных не изменилось.
[30:46.980 --> 30:47.980]  То же самое здесь.
[30:47.980 --> 30:49.980]  Я поменял местами цвета у g и у u,
[30:49.980 --> 30:51.980]  количество черных на таких путях не изменилось.
[30:51.980 --> 30:53.980]  Поэтому с черной глубиной тоже все будет верно.
[30:53.980 --> 30:56.980]  То есть с черной глубиной все не раньше сохранятся.
[30:58.980 --> 31:01.980]  Вот, значит, тогда какие остаются проблемы?
[31:01.980 --> 31:03.980]  Проблемы могут быть только такие.
[31:03.980 --> 31:07.980]  Либо у g еще есть родитель, и он опять красный,
[31:07.980 --> 31:10.980]  тогда мне нужно, как бы, ну, по сути, запуститься рекурсирно
[31:10.980 --> 31:12.980]  и подниматься наверх, пока я вот это все не исправлю.
[31:12.980 --> 31:13.980]  Либо же корень.
[31:13.980 --> 31:15.980]  Тогда давайте просто делаем так.
[31:15.980 --> 31:17.980]  Вот смотрите, раньше у меня была какая проблема?
[31:17.980 --> 31:19.980]  Раньше я был сфокусированный вот на этом вот по дереве,
[31:19.980 --> 31:23.980]  и у меня было, как бы, нарушение могло быть только одно из двух видов.
[31:23.980 --> 31:25.980]  Либо x – это красный корень,
[31:25.980 --> 31:28.980]  либо у x есть красный родитель.
[31:28.980 --> 31:31.980]  Тогда, значит, я делаю, если вот эта ситуация выполняется,
[31:31.980 --> 31:34.980]  я так перекрашиваю, и теперь проблема сводится вот к такому по дереву.
[31:34.980 --> 31:35.980]  То есть здесь все нормально,
[31:35.980 --> 31:38.980]  и единственная проблема в нашем дереве – это либо то, что g – это красный корень,
[31:38.980 --> 31:40.980]  либо уже красный родитель.
[31:40.980 --> 31:42.980]  Тогда опять нужно подняться наверх и как-то перекрасить.
[31:42.980 --> 31:47.980]  Тогда просто я пишу какую-то процедурку, там, не знаю, fix after insert.
[31:47.980 --> 31:49.980]  Она запускается исходно от вершины x,
[31:49.980 --> 31:54.980]  и если ситуация такая, то она просто перекрашивает вершины так, как сказано,
[31:54.980 --> 31:56.980]  и x поднимает в дедушку.
[31:56.980 --> 31:58.980]  Затем запускается рекурсирно, как бы, в дедушке, да,
[31:58.980 --> 32:00.980]  и опять делает те же самые проверки.
[32:00.980 --> 32:04.980]  То есть если есть красный дядя, то нужно перекрасить
[32:04.980 --> 32:07.980]  и подняться от x на две вершины вверх.
[32:07.980 --> 32:10.980]  И то же самое, значит, запуститься рекурсивно выше.
[32:10.980 --> 32:18.980]  Давайте подпишем, что рекурсивный запуск от дедушки g.
[32:18.980 --> 32:24.980]  Это в случае красного дяди мы просто что-то перекрашиваем, поднимаемся наверх.
[32:24.980 --> 32:28.980]  Структуру дерева не меняет, только меняет цвета.
[32:28.980 --> 32:36.980]  Второй кейс – это когда наш дядя черный.
[32:36.980 --> 32:38.980]  Здесь возникают два случая, в зависимости от того,
[32:38.980 --> 32:43.980]  является ли x левым или правым сыном своего отца.
[32:43.980 --> 32:46.980]  Давайте сначала возьмем случай, когда x – это левый сын.
[32:46.980 --> 32:48.980]  Значит, случай 2.1.
[32:48.980 --> 32:55.980]  x – это левый сын y.
[32:59.980 --> 33:02.980]  Что еще раз, если у красный ажек корень?
[33:08.980 --> 33:12.980]  Еще раз, у нас есть процедура, которая fix after insert,
[33:12.980 --> 33:15.980]  фиксим после вставки от какой-то вершины x.
[33:15.980 --> 33:18.980]  Если она красная и корень, то просто ее перекрашиваем в черный.
[33:18.980 --> 33:21.980]  Иначе у нее есть красный родитель, мы делаем вот такую штуку
[33:21.980 --> 33:23.980]  и запускаемся рекурсивно от g.
[33:23.980 --> 33:26.980]  В том случае, в котором вы говорите, мы просто поднялись сюда,
[33:26.980 --> 33:28.980]  запустились рекурсивно от g, g – это красный корень,
[33:28.980 --> 33:31.980]  тогда просто ее перекрашиваем в черный, и на этом заканчиваем.
[33:34.980 --> 33:37.980]  Почему не ломается правило с черной глубиной?
[33:37.980 --> 33:40.980]  Смотрите, что у меня могло поменяться.
[33:40.980 --> 33:43.980]  Давайте просто посмотрим, на каких путях что-то изменилось.
[33:43.980 --> 33:46.980]  Например, вот такой путь.
[33:46.980 --> 33:50.980]  Путь из g через y вода по дереву.
[33:50.980 --> 33:52.980]  Теперь он здесь такой.
[33:52.980 --> 33:54.980]  Сколько на этом пути черных вершин?
[33:54.980 --> 33:56.980]  Сколько было, столько осталось,
[33:56.980 --> 33:58.980]  потому что одна красная перекрасилась в черный,
[33:58.980 --> 34:00.980]  одна черная – в красный.
[34:00.980 --> 34:02.980]  Какие еще есть пути?
[34:02.980 --> 34:04.980]  Есть какой-нибудь такой путь.
[34:04.980 --> 34:06.980]  Тоже самое, одна черная стала красная,
[34:06.980 --> 34:08.980]  одна красная стала черной.
[34:08.980 --> 34:10.980]  На всех путях просто можно явно перебрать все пути,
[34:10.980 --> 34:12.980]  какие здесь есть,
[34:12.980 --> 34:14.980]  и увидеть, что количество черных вершин
[34:14.980 --> 34:16.980]  на любом таком нисходящем пути не изменилось.
[34:16.980 --> 34:18.980]  Вот и все.
[34:18.980 --> 34:20.980]  Ну и там, например, если смотреть
[34:20.980 --> 34:22.980]  какой-нибудь родителя, то тоже самое.
[34:22.980 --> 34:24.980]  Если взять какой-нибудь вот такой вот путь,
[34:24.980 --> 34:26.980]  то на нем изменились только цвета двух вершин на противоположные.
[34:26.980 --> 34:28.980]  Значит, количество не изменилось.
[34:30.980 --> 34:34.980]  И так, значит, в случае, когда x это левый сын y.
[34:34.980 --> 34:36.980]  Давайте наносим картинку.
[34:36.980 --> 34:38.980]  Вот у меня есть g.
[34:42.980 --> 34:44.980]  Нет, не так.
[34:44.980 --> 34:46.980]  Есть x красный, есть y тоже красный,
[34:46.980 --> 34:48.980]  и есть черный дядя.
[34:48.980 --> 34:50.980]  Ну тогда понятно, кстати, что
[34:50.980 --> 34:52.980]  g обязательно черный.
[34:52.980 --> 34:54.980]  g обязательно черный,
[34:54.980 --> 34:58.980]  потому что если y был красным в исходном дереве,
[34:58.980 --> 35:00.980]  то значит его родители обязательно черные.
[35:00.980 --> 35:02.980]  У нас не могло быть двух красных подряд в исходном дереве.
[35:02.980 --> 35:04.980]  Тогда сделаем следующее.
[35:04.980 --> 35:06.980]  Мы сделаем просто один поворот.
[35:06.980 --> 35:08.980]  Вот такой вот.
[35:08.980 --> 35:10.980]  Вот такой поворот.
[35:10.980 --> 35:12.980]  И потом последующую перекраску.
[35:12.980 --> 35:14.980]  Значит, поворот как действует.
[35:14.980 --> 35:16.980]  Если здесь были подвешены какие-то деревья,
[35:16.980 --> 35:18.980]  давайте их тоже как-нибудь назовем,
[35:18.980 --> 35:22.980]  a, b, c, d, e.
[35:22.980 --> 35:24.980]  Тогда как действует малый такой поворот.
[35:24.980 --> 35:26.980]  Давайте вспоминать.
[35:26.980 --> 35:28.980]  y станет корнем.
[35:28.980 --> 35:30.980]  Дальше g переместится сюда,
[35:30.980 --> 35:32.980]  x переместится сюда.
[35:32.980 --> 35:34.980]  У останется справа,
[35:34.980 --> 35:36.980]  но здесь все переподвесится.
[35:36.980 --> 35:40.980]  a, b, c, d.
[35:40.980 --> 35:42.980]  Обычный, просто малый поворот,
[35:42.980 --> 35:44.980]  который мы уже много раз делали,
[35:44.980 --> 35:46.980]  когда говорили, например,
[35:46.980 --> 35:48.980]  про овл-деревь или просплейдер.
[35:48.980 --> 35:50.980]  И теперь назначим цвета всем вершинкам
[35:50.980 --> 35:52.980]  следующим образом.
[35:52.980 --> 35:54.980]  Значит, y станет черным.
[35:54.980 --> 35:56.980]  y станет черным.
[35:56.980 --> 35:58.980]  x останется красным.
[35:58.980 --> 36:00.980]  x станет красным.
[36:02.980 --> 36:04.980]  g станет красным.
[36:04.980 --> 36:06.980]  u станет черным.
[36:10.980 --> 36:12.980]  То есть в таком случае
[36:12.980 --> 36:14.980]  мы сделали один поворот
[36:14.980 --> 36:16.980]  и такую перекраску вершин.
[36:16.980 --> 36:18.980]  Давайте проверим, что все хорошо.
[36:18.980 --> 36:20.980]  Готовьтесь, будет много разных случаев.
[36:22.980 --> 36:24.980]  Алгоритм не из приятных,
[36:24.980 --> 36:26.980]  но у него есть определенные преимущества.
[36:26.980 --> 36:28.980]  Много случаев нужно развивать.
[36:28.980 --> 36:30.980]  Нам придется это сделать.
[36:30.980 --> 36:32.980]  Что мы сделали?
[36:32.980 --> 36:34.980]  Почему все работает?
[36:34.980 --> 36:36.980]  Понятно, что это осталось дерево поиска,
[36:36.980 --> 36:38.980]  потому что поворот сохраняется всегда дерево поиска.
[36:38.980 --> 36:40.980]  Дальше.
[36:40.980 --> 36:42.980]  Что у нас происходит,
[36:42.980 --> 36:44.980]  если у нас теперь две красные вершины подряд?
[36:44.980 --> 36:46.980]  Раньше были две красные подряд.
[36:46.980 --> 36:48.980]  Теперь такого точно не будет,
[36:48.980 --> 36:50.980]  потому что, смотрите, у меня y стал черным.
[36:50.980 --> 36:52.980]  И значит, даже все, что находится выше,
[36:52.980 --> 36:54.980]  там нет конфликтов.
[36:54.980 --> 36:56.980]  Даже если у него есть красный родитель,
[36:56.980 --> 36:58.980]  то все равно здесь нет конфликта.
[36:58.980 --> 37:00.980]  И выше тоже конфликта нет,
[37:00.980 --> 37:02.980]  потому что раньше было правильное красно-черное дерево.
[37:02.980 --> 37:04.980]  Если у меня здесь нет конфликтов,
[37:04.980 --> 37:06.980]  красное с красным не граничит,
[37:06.980 --> 37:08.980]  то выше подниматься не нужно.
[37:08.980 --> 37:10.980]  И я уже исправил все мои дисбалансы.
[37:10.980 --> 37:12.980]  У меня теперь все хорошо,
[37:12.980 --> 37:14.980]  в плане, что нет двух соседних красных.
[37:14.980 --> 37:16.980]  Осталось проверить все про черные глубины.
[37:16.980 --> 37:18.980]  Давайте посмотрим.
[37:18.980 --> 37:20.980]  Вот, например, был какой-нибудь путь.
[37:20.980 --> 37:22.980]  Вот такой, да?
[37:22.980 --> 37:24.980]  g, y, c.
[37:24.980 --> 37:26.980]  Теперь это превращается вот в такой вот путь.
[37:26.980 --> 37:28.980]  Что с ним произошло?
[37:28.980 --> 37:30.980]  Здесь была одна черная, одна красная,
[37:30.980 --> 37:32.980]  и какой-то путь в c.
[37:32.980 --> 37:34.980]  Здесь стало то же самое.
[37:34.980 --> 37:36.980]  Одна черная, одна красная, и путь в c.
[37:36.980 --> 37:38.980]  Но если в c правильная черная глубина,
[37:38.980 --> 37:40.980]  она не поменялась,
[37:40.980 --> 37:42.980]  значит, на этой пути тоже черная глубина не поменялась.
[37:42.980 --> 37:44.980]  Что еще можно взять?
[37:44.980 --> 37:46.980]  Ну, какой-нибудь там не знаю.
[37:46.980 --> 37:48.980]  g, y, x, b. Вот такой какой-то путь.
[37:48.980 --> 37:50.980]  Y, x, b.
[37:50.980 --> 37:52.980]  Что произошло?
[37:52.980 --> 37:54.980]  По сути, у нас было две красные, одна черная,
[37:54.980 --> 37:56.980]  а стало одна черная, одна красная,
[37:56.980 --> 37:58.980]  и путь в b.
[37:58.980 --> 38:00.980]  То есть черная глубина опять не поменялась.
[38:00.980 --> 38:02.980]  И так аккуратно тоже...
[38:02.980 --> 38:04.980]  Давайте не будем это суперподробно дальше делать.
[38:04.980 --> 38:06.980]  Если просто аккуратно рассмотреть все возможные пути,
[38:06.980 --> 38:08.980]  то можно легко понять,
[38:08.980 --> 38:10.980]  что черные глубины не поменялись.
[38:10.980 --> 38:12.980]  То есть на каждом пути количество черных ошиб не изменилось
[38:12.980 --> 38:14.980]  за счет вот этих хитрых перекрашиваний.
[38:14.980 --> 38:16.980]  Вот за счет хитрых перекрашиваний.
[38:18.980 --> 38:20.980]  Все.
[38:20.980 --> 38:22.980]  То есть мы выполнили один поворот
[38:22.980 --> 38:24.980]  и перекрашивания так,
[38:24.980 --> 38:26.980]  что у меня теперь все свойства опять выполняются.
[38:26.980 --> 38:28.980]  То есть у меня конфликт
[38:28.980 --> 38:30.980]  между x и родителем разрешился.
[38:30.980 --> 38:32.980]  Дальше y теперь не красный.
[38:32.980 --> 38:34.980]  Если он корень, то уже все хорошо,
[38:34.980 --> 38:36.980]  выше некуда подниматься.
[38:36.980 --> 38:38.980]  Но даже если он не корень, то родитель у него...
[38:38.980 --> 38:40.980]  То есть то конфликта с родителем нет.
[38:40.980 --> 38:42.980]  Поэтому здесь сразу наш подъем заканчивается.
[38:42.980 --> 38:44.980]  То есть мы сделали один поворот, и сразу можно завершиться.
[38:44.980 --> 38:46.980]  Потому что больше конфликтов нет.
[38:46.980 --> 38:48.980]  Вот.
[38:48.980 --> 38:50.980]  В случае второй, когда x это правый сын y,
[38:54.980 --> 38:56.980]  то нужно сделать следующее.
[38:56.980 --> 38:58.980]  Давайте нарисую картинку здесь.
[39:00.980 --> 39:02.980]  Что у меня было?
[39:02.980 --> 39:04.980]  У меня был черный g, черный дядя,
[39:04.980 --> 39:06.980]  красный y и красный x.
[39:06.980 --> 39:08.980]  Тогда первое, что я сделаю,
[39:08.980 --> 39:10.980]  это выполню вот такое вращение.
[39:12.980 --> 39:14.980]  Тогда что произойдет?
[39:14.980 --> 39:16.980]  А цвета пока что не меняем.
[39:16.980 --> 39:18.980]  Тогда g и y останутся на месте.
[39:20.980 --> 39:22.980]  Зато здесь перекрасится x и y.
[39:22.980 --> 39:24.980]  И мы свели ситуацию
[39:24.980 --> 39:26.980]  к 2.1.
[39:28.980 --> 39:30.980]  Потому что у меня вот эта вот картинка
[39:30.980 --> 39:32.980]  совпадает вот с этой картинкой.
[39:32.980 --> 39:34.980]  У меня есть
[39:34.980 --> 39:36.980]  две подряд идущие красные вершины.
[39:36.980 --> 39:38.980]  Одна из которых является левым сыном, другой.
[39:38.980 --> 39:40.980]  У них есть общий...
[39:40.980 --> 39:42.980]  Дедушка черный, и дядя тоже черный.
[39:42.980 --> 39:44.980]  То есть картинка совпадает вот с этой,
[39:44.980 --> 39:46.980]  только там просто x и y поменены местами.
[39:46.980 --> 39:48.980]  За счет такого маленького поворота
[39:48.980 --> 39:50.980]  мы как раз таки опять свели ситуацию,
[39:50.980 --> 39:52.980]  когда есть два красных подряд,
[39:52.980 --> 39:54.980]  свели ситуацию, что один является левым сыном,
[39:54.980 --> 39:56.980]  другой.
[39:56.980 --> 39:58.980]  Мы сводим случай правого сына
[39:58.980 --> 40:00.980]  к случаю левого сына просто одним поворотом.
[40:02.980 --> 40:04.980]  На этом разбор инсерта на самом деле закончен.
[40:06.980 --> 40:08.980]  Можете повторить, почему у x могут быть
[40:08.980 --> 40:10.980]  какие-то поддеревья после инсерта.
[40:10.980 --> 40:12.980]  Когда я рисую под деревья,
[40:12.980 --> 40:14.980]  это не обязательно какие-то ключи,
[40:14.980 --> 40:16.980]  это, возможно, просто один лист.
[40:16.980 --> 40:18.980]  В общем случае, это какое-то поддерево.
[40:18.980 --> 40:20.980]  Это иногда просто черные вершины,
[40:20.980 --> 40:22.980]  но это тоже поддерево.
[40:22.980 --> 40:24.980]  Никаких проблем с этим нет.
[40:24.980 --> 40:26.980]  Более того, мы же иногда,
[40:26.980 --> 40:28.980]  помните первый случай,
[40:28.980 --> 40:30.980]  когда дядя был красный,
[40:30.980 --> 40:32.980]  тогда мы поднялись из x в g.
[40:32.980 --> 40:34.980]  Мы поднялись на два раза,
[40:34.980 --> 40:36.980]  и тогда есть какие-то содержательные поддеревья.
[40:36.980 --> 40:38.980]  Мы же рекурсивно поднимаемся,
[40:38.980 --> 40:40.980]  и их нужно тоже учить.
[40:42.980 --> 40:44.980]  И таким образом, что мы сделали?
[40:44.980 --> 40:46.980]  Давайте резюмируем, как работает инсерт.
[40:46.980 --> 40:48.980]  Он идет снизу вверх.
[40:48.980 --> 40:52.980]  Если текущая вершина корень,
[40:52.980 --> 40:54.980]  то он просто перекрашивает в черный цвет,
[40:54.980 --> 40:56.980]  потому что проблем нет.
[40:56.980 --> 40:58.980]  Иначе, если текущая вершина красная,
[40:58.980 --> 41:00.980]  если у нее черный водитель,
[41:00.980 --> 41:02.980]  то можно сразу завершиться,
[41:02.980 --> 41:04.980]  потому что проблем нет.
[41:04.980 --> 41:06.980]  Давайте я, наверное, пропишу все-таки.
[41:06.980 --> 41:08.980]  Как работает инсерт x?
[41:08.980 --> 41:10.980]  То есть мы вставили красный x
[41:10.980 --> 41:12.980]  на нужное место.
[41:12.980 --> 41:14.980]  Дальше делаем следующее.
[41:14.980 --> 41:16.980]  Если x это корень,
[41:16.980 --> 41:18.980]  то перекрашиваем в красный.
[41:22.980 --> 41:26.980]  Иначе, если родитель черный,
[41:26.980 --> 41:28.980]  то заканчиваемся.
[41:28.980 --> 41:30.980]  Если родитель черный,
[41:30.980 --> 41:32.980]  то return,
[41:32.980 --> 41:34.980]  потому что делать ничего не нужно,
[41:34.980 --> 41:36.980]  а насice,ells Netflix,
[41:36.980 --> 41:38.980]  у меня есть x,
[41:38.980 --> 41:40.980]  родитель красный.
[41:40.980 --> 41:42.980]  Разбираем те два случая.
[41:42.980 --> 41:44.980]  У меня получается 2 красные вершины подряд.
[41:44.980 --> 41:46.980]  Если дядя красный,
[41:46.980 --> 41:48.980]  то мы перекрашиваем,
[41:48.980 --> 41:50.980]  yourself иверх.
[41:50.980 --> 41:52.980]  Иначе, если дядя черный,
[41:52.980 --> 41:54.980]  то мы делаем 1 или 2 поворота.
[41:54.980 --> 41:56.980]  И затем завершаемся.
[41:56.980 --> 41:58.980]  Ясно.
[41:58.980 --> 42:00.980]  Если дядя красный,
[42:00.980 --> 42:02.980]  тогда мы делаем перекрашивание и подъем.
[42:02.980 --> 42:14.420]  подъем, то есть фиксим от исходного дедушки, а если дядя черный, тогда мы делаем не больше
[42:14.420 --> 42:29.220]  чем два поворота, перекрашивание и return. Вот так работает наш фикс после инсерта. Прелесть в том,
[42:29.220 --> 42:34.900]  что здесь будет максимум два поворота. В итоге вся операция инсерта совершает максимум два
[42:34.900 --> 42:45.860]  поворота. Совершим не больше, чем два поворота. Более-менее понятно, что это самая сложная
[42:45.860 --> 42:51.460]  операция. Понятно, что перекрасить можно почти за бесплатно. Это совсем просто. Перепрессивой
[42:51.460 --> 42:58.460]  одно поле у узла. Нужно просто поменять цвет. А поворот там чуть более тонкая штука. Давайте
[42:58.460 --> 43:05.140]  нарисую его. Если у меня есть какие-то две вершинки x и p, я делаю поворот вокруг вот этого
[43:05.140 --> 43:10.140]  вот ребра, то мне нужно поменять кучу всяких ссылок. Потому что у вот этих вот трёх поддерев
[43:10.140 --> 43:16.940]  меняются родители, меняются дети x, меняются дети p, меняются указательные родители у x, у p.
[43:16.940 --> 43:21.980]  Короче, много всяких ссылок переставляются. Понятно дело, что из всех этих операций поворот это самое
[43:21.980 --> 43:27.860]  тяжёлое. По сравнению с переменой цвета, это самое тяжёлое. Прелесть инсерта в том, в красном-чёрном
[43:27.860 --> 43:31.940]  дереве, что будет максимум два поворота. То есть в принципе таких поворотов, таких дорогих операций
[43:31.940 --> 43:38.540]  будет не много всегда, будет всего две. Чему у нас при повороте у самого левого ребёнка x меняется
[43:38.540 --> 43:49.220]  родитель? Ну хорошо, не у всех поменяется. Окей, что у двух из трёх получается? Нет. У одного из трёх
[43:49.220 --> 43:54.580]  меняется. Окей, да, виноват. Я не прав, да, действительно. Ну окей, не у всех, да, ну у кого-то.
[43:54.580 --> 44:00.380]  Получается, вот этот, вот перебодрится к п. Виноват, да, вы правы. Так, вопрос в чате, если x корень, то
[44:00.380 --> 44:05.660]  почему перекрашиваем в красный? Ну потому что у нас было требование того, что корень всегда
[44:05.660 --> 44:11.220]  чёрный. Есть такое требование. И просто от перекрашивания корня в чёрный цвет ничего не
[44:11.220 --> 44:15.020]  сломается. Если он был красный, то его можно просто перекрасить в чёрный, и никакие свойства не
[44:15.020 --> 44:18.740]  нарушатся. То есть чёрная глубина останется корректно определённой везде, не будет двух
[44:18.740 --> 44:21.980]  подарков красных и так далее и так далее. Все свойства сохранены. То есть так можно всегда
[44:21.980 --> 44:25.980]  сделать, это ничего не испортит, но обеспечит выполнение новой свойства.
[44:25.980 --> 44:37.580]  Так, на этом сенсертом я и что-ли мы разобрались. А, блин, что-то я...
[44:37.580 --> 44:48.500]  Извините, да, тоже право, конечно. Перекрашиваем в чёрный. Да, спасибо. Значит, сенсертом мы
[44:48.500 --> 44:53.740]  разобрались, поняли, что здесь мало будет поворотов. То есть поворотов всегда не больше,
[44:53.740 --> 45:01.380]  чем два. Хорошо, теперь переходим к рейзу. Здесь ещё больше случаев, но прелесть будет такая же,
[45:01.380 --> 45:06.300]  что у нас будет мало поворотов. И это, в частности, выигрыш по сравнению с VL-деревом,
[45:06.300 --> 45:10.900]  что VL-дерев может быть довольно много поворотов, когда мы делаем эти фиксы. И это преимущество
[45:10.900 --> 45:17.500]  красно-чёрного по сравнению с VL-деревом. Итак, как у нас работает рейз в наивном дереве поиска?
[45:17.500 --> 45:25.580]  Мы находим наш X где-то в дереве. В идеальной ситуации, когда у него, скажем, оба сына это
[45:25.580 --> 45:33.900]  фиктивные листья, мы просто X как-то удаляем, и на его место записываем чёрный лист. То есть
[45:33.900 --> 45:37.180]  есть есть случай, когда у него как бы ноль. То есть в этом случае мы будем говорить, что у него
[45:37.180 --> 45:41.900]  ноль детей. То есть дети являются фиктивными листьями. Дальше может быть такой случай.
[45:41.900 --> 45:50.420]  Может быть случай, что у нас есть X, и у него есть, скажем, только левый сын. Есть только левое
[45:50.420 --> 45:57.300]  поддерево, а правое это фиктивный лист. В этом случае говорим, что у него один ребенок. Тогда в
[45:57.300 --> 46:01.260]  таком случае мы тоже знаем, что делать. Надо просто, ну по крайней мере в наивном дереве поиска,
[46:01.260 --> 46:07.140]  нужно просто вот это поддерево переподвесить на место X. X вынуть, переподвесить вот это дерево
[46:07.140 --> 46:12.220]  сюда и соответственно здесь будет, ну и это соответственно тоже удалится, соответственно вот
[46:12.220 --> 46:17.620]  это поддерево будет на месте X висеть. И наконец последний случай, это когда у X есть оба ребенка,
[46:17.620 --> 46:23.460]  есть оба поддерево, и левое и правое. Тогда давайте также, как в наивном дереве поиска, например,
[46:23.460 --> 46:29.460]  сделаем следующее. Давайте мы из левого поддерево возьмем максимальный элемент, скопируем его на
[46:29.460 --> 46:33.620]  место X и теперь удалим максимум из этого поддерево. И поскольку это был максимальный, то у него точно
[46:33.620 --> 46:41.820]  не будет правого сына, значит если у x два ребенка, два ребенка, делаем как мы это много раз делали,
[46:41.820 --> 47:00.420]  находим максимум в левом подделье, в левом подделье, копируем максимум на место x и
[47:00.420 --> 47:13.500]  удаляем максимум из поддерева, и тем самым мы перешли в ситуацию 0 или 1 сын, 0 или 1 ребенок,
[47:13.500 --> 47:20.100]  ну потому что у max точно нет правого сына, потому что максимум такая вершина, ну точнее нету как бы
[47:20.100 --> 47:24.660]  настоящего правого сына, там есть ссылка на фиктивный лист, но как бы ключей в правом по
[47:24.660 --> 47:29.420]  дереве нету, там нету вершин с ключами, вот, то есть мы на самом деле свели задачу удаления,
[47:29.420 --> 47:35.100]  к случаю вот этому и вот этому, когда есть 0 или когда есть один сын, в случае, когда есть два ребенка,
[47:35.100 --> 47:40.100]  я показал как разбираем, находим максимальный элемент слева, копируем его на место x, и тогда
[47:40.100 --> 47:44.540]  вот тот максимальный элемент, который мы скопировали, у него опять, нам его нужно удалить, у него 0 или 1
[47:44.540 --> 47:49.860]  ребенок, потому что правого точно нету, вот, значит нам достаточно разобрать в случае, когда удаляется
[47:49.860 --> 47:55.460]  вершина с нулем детей, то есть с двумя фиктивными листями, либо с одним ребенком, то есть один
[47:55.460 --> 48:01.020]  настоящий лист, там какой-то адекватный по дереву, а второй лист это вот этот фиктивный ребенок, вот,
[48:01.020 --> 48:08.260]  ну тогда я вот ожидал, что есть всего три случая, три случая, значит первый случай такой, мы удаляем
[48:08.260 --> 48:16.100]  красную вершину x, у которой оба сына это фиктивные черные листи, здесь решение очень простое,
[48:16.100 --> 48:26.140]  мы просто заменим этот x на фиктивный черный лист, и все, на этом рейс закончится, здесь все будет
[48:26.140 --> 48:30.500]  хорошо, потому что смотрите, что мы сделали, мы как бы по сути удалили вот эту красную вершину,
[48:30.500 --> 48:36.060]  удалили один фиктивный лист, да и по сути подняли один из черных листьев наверх, тогда смотрите,
[48:36.060 --> 48:40.660]  у меня ничего не сломалось, у меня точно не появилось двух красных подряд, потому что мы
[48:40.660 --> 48:45.460]  удалили только красную, но и вместо подвесили черную, точно не появился звук красных подряд. Дальше,
[48:45.460 --> 48:50.660]  у меня не изменилась черная глубина, потому что вот на таких путях, которые проходят через x,
[48:50.660 --> 48:54.700]  теперь число черных осталось таким же, как было, и вот это в частности ответ на вопрос,
[48:54.700 --> 48:59.260]  зачем нам это подрешивать, да, потому что вот раньше, если здесь была, то есть если бы не было
[48:59.260 --> 49:03.940]  листьев, у меня была бы скажем нулевая черная глубина, а здесь мы бы вообще, сейчас,
[49:03.940 --> 49:11.940]  ладно, плохая иллюстрация, короче, если мы переподвесим черный лист вот сюда, то черная глубина
[49:11.940 --> 49:15.580]  не поменяется, короче, то есть любой такой путь, он содержал вот этот один лист, ну значит,
[49:15.580 --> 49:18.820]  он теперь тоже его будет содержать, то есть черная глубина не поменялась, ну и все остальные
[49:18.820 --> 49:22.860]  свойства тоже выполняются, то есть корень либо не изменился, либо стал вот этим фиктивным
[49:22.860 --> 49:30.700]  листиком, он остался черным, все вершины это красные или черные, что еще там было, да,
[49:30.700 --> 49:35.380]  ну вроде все свойства хранили, то есть это простой случай, когда нужно добавить красную вершину,
[49:35.380 --> 49:41.220]  оба сына которой это фиктивные листины, нужно просто ее заменить на фиктивные листины. Дальше
[49:41.220 --> 49:47.860]  второй случай, сложный, это когда х это черная вершина с двумя черными фиктивными сыновьями,
[49:47.860 --> 49:53.420]  вот здесь будет еще более подробный разбор случаев, здесь будет еще много случаев,
[49:53.420 --> 50:01.700]  которые мы чуть позже разберем, много случаев. И наконец, третий случай, это когда я удаляю вершину,
[50:01.700 --> 50:09.180]  я удаляю вершину, у которой один сын это черный лист, а другой сын это какой-то поддерев. Давайте
[50:09.180 --> 50:15.740]  посмотрим, как может выглядеть такая ситуация. Вот есть х, есть справа у него черный лист,
[50:15.740 --> 50:21.540]  тогда что может быть слева? Давайте подумаем, если слева, а слева какое-то адекватное поддерево,
[50:21.540 --> 50:30.100]  хотя бы с одним ключом. Если слева есть черная вершина, черный не лист, тогда черная гудна вот
[50:30.100 --> 50:34.460]  здесь была бы хотя бы двойка, потому что у меня есть вот эта вот черная вершина, и дальше внизу
[50:34.460 --> 50:42.780]  обязательно мы доходим до черного листа, поэтому здесь не может быть черных вершин, нет черных
[50:42.780 --> 50:48.780]  вершин. Там могут быть черными только листья, потому что, постройте, иначе вот здесь черная
[50:48.780 --> 50:54.300]  гудна будет двойка, а здесь однице, противоречие с тем, что у нас, ну то есть изначально у меня
[50:54.300 --> 50:59.020]  было корректное красно-черное дерево, а здесь оно некорректное, противоречие. Здесь нет черных,
[50:59.020 --> 51:04.540]  поэтому единственное, что там может быть, это одна единственная красная, то есть здесь просто есть одна
[51:04.540 --> 51:14.700]  красная, какая-то там Y. Вот, ну почему она одна? Потому что у красной нету, то есть у красной любые
[51:14.700 --> 51:19.340]  дети черная, но если есть какой-то черный ребенок у нее, то опять противоречие, да, мы сказали,
[51:19.340 --> 51:24.500]  что нету черных вершин. То есть на самом деле картинка обязательно такая, если мы живем в третьем
[51:24.500 --> 51:31.420]  случае, то X черный, правый сын у него это черный фиктивный лист, левый сын это красный Y, а у Y
[51:31.420 --> 51:38.740]  есть два фиктивных черных сына. Вот такой простой разбор случаев позволяет сказать, что в этом
[51:38.740 --> 51:48.100]  случае обязательно X имеет глубину 2 снизу, да, правый сын пустой лист, левый сын это красный
[51:48.100 --> 51:54.700]  вершина Y и дальше у него тоже вот эти два черные черные листа из него торчат. Решение здесь тоже
[51:54.700 --> 52:00.420]  очень простое, то есть как и что мне нужно? Мне нужно из вот этого красно-черного дерева получить
[52:00.420 --> 52:07.020]  дерево, в котором X выкинуть. Давай тогда я просто напишу на место X, Y, покрашу его в черный и скажу,
[52:07.020 --> 52:11.900]  что у него есть два вот таких черных сына. Тогда я отуждаю, опять все свойства восстановятся,
[52:11.900 --> 52:17.660]  ну то есть все свойства не нарушатся, потому что опять-таки не будет двух красных подряд,
[52:17.660 --> 52:23.060]  потому что если их не было в дереве выше, то им нет куда взяться, потому что я на место вот этого
[52:23.060 --> 52:28.580]  черного X поставил черный Y, то есть цвета как бы выше не поменялись. Дальше, что с черной глубиной?
[52:28.580 --> 52:33.420]  Ну вот здесь была какая черная глубина? Здесь была черная вершина X и потом черный лист здесь,
[52:33.420 --> 52:37.300]  ну здесь тоже самое, черный Y и черный лист здесь. И все вот эти пути имели
[52:37.300 --> 52:40.180]  одинаково черную глубину, ну собственно так же здесь они все имеют одинаковую черную глубину.
[52:42.180 --> 52:48.980]  И тот X, который мы хотели удалить, мы спокойно удалили. То есть этот случай тоже простой. Он может
[52:48.980 --> 52:54.020]  выглядеть только так, только что у меня есть левый красный сын без потомков внизу, и тогда это
[52:54.020 --> 53:01.940]  просто решается тем, что мы Y ставим на место X и перекрашиваем его в черный. Нет, случай два,
[53:01.980 --> 53:08.140]  мы сейчас будем активно разбирать. Много случаев, смотри дальше. То есть мы сейчас показали,
[53:08.140 --> 53:13.820]  что первый и третий случай мы разобрали. Осталось понять, что происходит во втором.
[53:13.820 --> 53:18.820]  Ну и вот на оставшееся время, видим, мы будем разбирать этот второй случай. Так,
[53:18.820 --> 53:24.780]  есть ли вопросы на текущий момент? Так, а что было на прошлом слайде? Вот это?
[53:31.940 --> 53:44.980]  А, ну да, то есть сейчас. Ну как у нас, это надо проговорить или вам надо просто посмотреть?
[53:44.980 --> 53:51.860]  Ну давайте кратко, то есть если у меня у X есть два поддерева, в каждом из которых есть ключи,
[53:51.860 --> 53:58.980]  то есть там не только эффективные листья, то мы делаем как в обычном неявном дереве поиска,
[53:59.780 --> 54:04.560]  наивном дереве поиска. Мы спускаемся в левого сына, находим там максимальную вершину просто
[54:04.560 --> 54:09.900]  едя максимально вправо, вправо, вправо, пока есть вершина, нашли максимум, значит у него есть
[54:09.900 --> 54:15.420]  правый сын, но это обязательно черно эффективный лист. То есть справа нет ключей, там только
[54:15.420 --> 54:21.940]  эффективный лист. Тогда мы максимум копированы на место X и дальше у меня, на самом деле опять,
[54:21.940 --> 54:25.340]  случай либо вот этот, либо вот этот, потому что う меня есть максимальная вершина, которую нужно
[54:25.340 --> 54:30.100]  удалить, и у нее нет правого сына, то есть на месте правого сына эффективный лист, поэтому детей
[54:30.100 --> 54:34.020]  либо вообще ноль, то есть оба сына эффективные листия, либо есть один ребенок только слева,
[54:34.020 --> 54:40.220]  тогда соответственно вот эта вот ситуация. То есть в случае достаточно расправить когда ноль или один
[54:40.220 --> 54:52.540]  нормальный сын, вот, но и они здесь все разобраны. А правое под дерево х? Вот это типа? Так а что меняется?
[54:52.540 --> 54:56.420]  Вот здесь мы просто скопировали значение, у меня вот здесь вот правильное,
[54:56.420 --> 54:59.780]  корректное красно-черное дерево, мне нужно просто вот здесь разобраться с удалением х,
[54:59.780 --> 55:04.380]  то есть это ровно то же самое, что было в наитном дереве поиска, мы просто один элемент перетащили
[55:04.380 --> 55:08.780]  повыше, дерево не сломала структуру, нам нужно просто удалить один элемент, вот этот максимум.
[55:08.780 --> 55:20.860]  Что? Понятно. Так, если х красный имеет один эффективного сына, если х красный имеет одного
[55:20.860 --> 55:24.720]  неэффективного сына. Да, вот мы здесь расслужуясь, что такого не бывает.
[55:24.720 --> 55:28.460]  То есть вот третий случай, когда у х есть один неэффективный сын, тогда окей,
[55:28.460 --> 55:32.320]  значит давайте повторим, пусть х какой-то непонятный, вот здесь пусть х какой-то
[55:32.320 --> 55:37.680]  синий, есть один фективный сын, есть соответственно другое под дерево, где есть неэффективные дети,
[55:37.680 --> 55:41.460]  но раз здесь черная 이번ная единица, значит здесь тоже черная т merely должна быть единица
[55:41.460 --> 55:45.740]  и поскольку здесь есть обязательно черные листики, то там не может быть черных вершин, значит там
[55:45.740 --> 55:50.600]  может быть только что-то красное, и это обязательно тогда одна красная вершина y, then x черный,
[55:50.600 --> 56:01.640]  вот такая ровно, как здесь не рисована, да, вот здесь x не может быть красной, вот в этой
[56:01.640 --> 56:11.040]  ситуации x не может быть красной, мы это доказали, вот хорошо, значит чего, мы разбираем второй случай,
[56:11.040 --> 56:18.360]  разбираем второй случай, и давайте мы скажем, что сейчас у нас задачу немножко обобщим,
[56:18.360 --> 56:22.000]  потому что нам нужно будет ее рекурсивно опять применять, значит задача теперь такая,
[56:22.000 --> 56:34.640]  задача, было корректное красно-черное дерево, потом что с ним произошло, давайте я вернусь,
[56:34.640 --> 56:44.920]  вот у меня была категория x с ключом неэффективной высшинка x, и я ее как бы хочу удалить,
[56:45.120 --> 56:48.920]  понятно, что я ее просто заменю на такой черный прямоугольник, то есть по сути что произошло,
[56:48.920 --> 56:57.640]  у меня было дерево с черным корнем, и раньше было дерево под дерево с черным корнем, и я его так
[56:57.640 --> 57:03.160]  поменял, что у него уменьшилась черная глубина на 1, но корень остался черный, значит задача,
[57:03.160 --> 57:15.480]  было корректное красно-черное дерево, была черная вершина x, так вот вместо него, вместо нее
[57:15.480 --> 57:29.280]  подвесили опять-таки дерево с черным корнем, дерево с черным корнем, но черная глубина на 1 меньше,
[57:29.280 --> 57:43.720]  но черная глубина на 1 уменьшилась, потому что у меня там был черный x и лист, было две вершины на
[57:43.720 --> 57:48.240]  вот этом пути, теперь там осталось только одна, один черный лист, то есть по сути черная глубина
[57:48.240 --> 57:52.520]  просто уменьшилась, вот, и я буду решать эту задачу, да, то есть у меня что было, у меня есть там
[57:52.520 --> 57:57.280]  какое-то корректное красно-черное дерево, дальше было у него какое-то под дерево с черным корнем,
[57:57.580 --> 58:03.780]  с черной глубиной, там vh, потом я как-то его так перестроил, что теперь здесь глубина стала vh-1,
[58:03.780 --> 58:08.560]  вот, и это теперь все корректное красно-черное дерево,
[58:08.560 --> 58:14.240]  корректно красно-черное дерево, и моя задача теперь как-то пройтись снизу вверх, пересчитать,
[58:14.240 --> 58:17.400]  там сделаем какие-то повороты, чего-то перекрасить, так, чтобы теперь глобально,
[58:17.400 --> 58:23.600]  тоже стало корректно красно-черное дерево, вот, такая будет задача,wię ну, хорошо, значит
[58:23.600 --> 58:27.160]  я буду треугольником рисовать вот этого дерева, которое изменило свою глубину,
[58:27.160 --> 58:35.040]  уменьшило свою глубину черную на единицу. Тогда какие могут быть случаи? Давайте будем считать,
[58:35.040 --> 58:45.440]  считаем, что это дерево правый сын своего родителя. В случае, когда это левый сын,
[58:45.440 --> 58:51.160]  он симметричен. Правый сын своего родителя. Ну, во-первых, если родителя нету, то делать
[58:51.160 --> 58:55.840]  ничего не нужно. У меня было корректное красно-черное дерево с корнем в черной
[58:55.840 --> 59:00.760]  вершине. Мы что-то так сделали, что-то у него изменили, что теперь черный губан уменьшился на 1,
[59:00.760 --> 59:05.360]  но корень остался черным. И если это был корень, то делать ничего не нужно. У меня было просто
[59:05.360 --> 59:13.000]  корректное черное дерево, я в нем что-то поменял, осталось корректное черное дерево. Если родителя нет,
[59:13.000 --> 59:25.480]  то делать нечего, то есть у нас уже все хорошо. Иначе картинка какая-то такая. Вот есть тот
[59:25.480 --> 59:30.360]  треугольник, который поменял свою глубину, треугольник, который поменял свою глубину,
[59:30.360 --> 59:42.960]  и есть у него родитель А. Давайте синим его нарисуем. Родитель А. Тогда давайте посмотрим на цвет этой
[59:42.960 --> 59:58.520]  вершинки. Посмотрим на цвет этой вершины, какой красный, красный или черный. Красный или черный.
[59:58.520 --> 01:00:08.400]  Цвет вершинки А. И давайте сначала разберем случай, когда она была красная. Есть мой треугольник,
[01:00:08.400 --> 01:00:18.920]  правый сын, красные вершины. Вот какая такая картинка. Теперь хорошо, я утверждаю, что слева
[01:00:18.920 --> 01:00:23.920]  обязательно есть какая-то вершина с ключом. Почему? Потому что вот здесь исходно была какая-то
[01:00:24.080 --> 01:00:32.280]  положительная, даже не просто положительная, а была черная глубина хотя бы 2. Слева тоже должна быть
[01:00:32.280 --> 01:00:36.360]  черная глубина хотя бы 2, ну и значит здесь обязательно есть хотя бы одна вершина. Раз это
[01:00:36.360 --> 01:00:41.360]  был исходно, красное-черное дерево, то здесь глубина черная хотя бы 2, поэтому здесь есть хотя бы
[01:00:41.360 --> 01:00:49.880]  одна вершинка В. Дальше мы разберем случай по цвету этой вершинки В. Мы фиксировали,
[01:00:49.880 --> 01:00:54.880]  А, нет, тут нет случаев. Скажите, пожалуйста, какого цвета должна быть вершинка В?
[01:00:54.880 --> 01:00:59.880]  Синего.
[01:00:59.880 --> 01:01:07.880]  Так. Чёрная, конечно, да, потому что, раз у меня исходно было корректное красно-чёрное дерево,
[01:01:07.880 --> 01:01:11.880]  то у меня не может быть две красные подряд, поэтому В обязательно чёрная.
[01:01:11.880 --> 01:01:18.880]  Кто ещё раз такой А? Смотрите ещё раз. Треугольник – это то под дерево,
[01:01:18.880 --> 01:01:22.880]  откуда мы удалили х. То есть там было корректное красно-чёрное дерево.
[01:01:22.880 --> 01:01:25.880]  Мы удалили оттуда х, соответственно, чёрное угло уменьшилось на 1.
[01:01:25.880 --> 01:01:29.880]  А А – это родитель этого под деревом. Это родитель этого под деревом.
[01:01:29.880 --> 01:01:31.880]  И мы сейчас разбираем случай, когда А красно.
[01:01:31.880 --> 01:01:37.880]  Тогда слева обязательно чёрная вершинка В. Дальше два случая.
[01:01:38.880 --> 01:01:56.880]  Дальше два случая. Есть ли у В красный сын? Есть ли у В хотя бы один красный сын?
[01:01:56.880 --> 01:02:03.880]  Так, давайте случай 2.1.1. Есть.
[01:02:03.880 --> 01:02:09.880]  Тогда картинка такая. Есть вот этот наш треугольник, который изменился.
[01:02:09.880 --> 01:02:16.880]  Есть красная А. Есть чёрная В. И у него есть красный сын С.
[01:02:16.880 --> 01:02:19.880]  Давайте считаем, что он является правым сыном вершинки В.
[01:02:19.880 --> 01:02:25.880]  Тогда в этом случае я делаю следующее. Мы сделаем следующее.
[01:02:25.880 --> 01:02:30.880]  Мы сделаем два поворота. Это будет первый поворот, это второй поворот.
[01:02:30.880 --> 01:02:34.880]  И перекрашивание. Так что теперь картинка станет следующей.
[01:02:34.880 --> 01:02:38.880]  У меня С останется красной. Но даже здесь перекрашивания получается не будет.
[01:02:38.880 --> 01:02:43.880]  А А перекрасится тоже в чёрный. И будет вот такое дерево.
[01:02:43.880 --> 01:02:49.880]  Наш треугольник будет теперь вот здесь. Справа.
[01:02:49.880 --> 01:02:52.880]  Давайте здесь поймём, почему это будет корректно красно-чёрное дерево.
[01:02:52.880 --> 01:02:56.880]  И я восстановлю все свойства. У меня всё будет хорошо.
[01:02:56.880 --> 01:03:03.880]  Смотрите. Эта штука изменила свою чёрную глубину. Раньше было H, теперь H-1.
[01:03:03.880 --> 01:03:08.880]  Раз раньше было H, то получается, что чёрная глубина в треугольнике А равна H.
[01:03:08.880 --> 01:03:12.880]  То есть вот здесь те подделевья, которые висят, они имеют чёрную глубину.
[01:03:12.880 --> 01:03:16.880]  H-1 здесь, H-1 здесь, H-1 здесь.
[01:03:16.880 --> 01:03:21.880]  Чёрная глубина у них у всех получается H-1. Раз все вот эти вот пути имеют тоже число чёрных решений,
[01:03:21.880 --> 01:03:24.880]  что здесь ровно H, потому что раньше было корректно.
[01:03:24.880 --> 01:03:27.880]  Чёрное дерево. Значит, здесь у них вся гладина H-1.
[01:03:27.880 --> 01:03:31.880]  Теперь я сделаю такие повороты и перекрашивание, что теперь картинка вот такая.
[01:03:31.880 --> 01:03:37.880]  Давайте поймём, что здесь происходит со всеми глубинами чёрных.
[01:03:37.880 --> 01:03:43.880]  Здесь H-1, A, B, C, D. D подвесилось сюда.
[01:03:43.880 --> 01:03:50.880]  Дальше C подвесилось сюда, осталось H-1. A и B тоже подвесились к B, и у них тоже гладина H-1.
[01:03:51.880 --> 01:03:58.880]  Сейчас я на чат отвечу. Что здесь с чёрной глубиной?
[01:03:58.880 --> 01:04:04.880]  Ну, смотрите, просто смотрим. Если встать в вершину C, то у меня любой путь содержит ровно H чёрных вершин,
[01:04:04.880 --> 01:04:08.880]  потому что он проходит через B и под дерево, либо через A и под дерево.
[01:04:08.880 --> 01:04:14.880]  Поэтому у всех вершинок глубина осталась ровно H, такая, как и была.
[01:04:14.880 --> 01:04:18.880]  Если раньше у меня была чёрная глубина H, теперь осталась чёрная глубина H.
[01:04:18.880 --> 01:04:24.880]  По дереве тоже всё хорошо. То есть вот эти все пути, они не изменили свои чёрные глубины, поэтому здесь всё хорошо.
[01:04:24.880 --> 01:04:29.880]  Дальше у меня не может возникнуть конфликта красный-красный, что не может быть двух красных вершин подряд,
[01:04:29.880 --> 01:04:35.880]  потому что, раз раньше было корректное чёрное дерево, то вот здесь не было красного родителя у A.
[01:04:35.880 --> 01:04:38.880]  Ну, соответственно, этот родитель переместился сюда, тут нет двух красных.
[01:04:38.880 --> 01:04:43.880]  В итоге мы исправили все нарушения свойств.
[01:04:43.880 --> 01:04:48.880]  Ничего не означает, нет, это просто рефакт.
[01:04:53.880 --> 01:05:00.880]  В итоге случай 2.1.1 такой, если A красная, а у B есть хотя бы один красный сын,
[01:05:00.880 --> 01:05:08.880]  то можно за два поворота и перекрашивания выполнить все условия, выполнить все наши требования на красный-чёрный дерево.
[01:05:09.880 --> 01:05:17.880]  Значит, следующий случай. Давайте попробуем его здесь уместить.
[01:05:17.880 --> 01:05:22.880]  2.1.2. Это когда нет красного сына.
[01:05:22.880 --> 01:05:27.880]  Такая картинка такая. У меня есть, давайте повторим, красная A, чёрная B слева,
[01:05:27.880 --> 01:05:31.880]  и вот это наша треугольничка, которая поменяла свою глубину с H на H-1 справа.
[01:05:31.880 --> 01:05:40.880]  И смотрите, у B нет красного сына. То есть есть там вот эти два по дереву A и B,
[01:05:40.880 --> 01:05:45.880]  оба имеют красную глубину H-1, и у них у обоих, у обоих по дереве в корне чёрные,
[01:05:45.880 --> 01:05:48.880]  раз мы предположим, что нет у красного сына.
[01:05:48.880 --> 01:05:53.880]  Тогда преобразование следующее. Здесь даже не будет переподвешивание, здесь будет просто перекрашивание.
[01:05:53.880 --> 01:05:59.880]  Мы поменяем цвета у A и у B. Будет тогда чёрная A и красная B.
[01:05:59.880 --> 01:06:07.880]  А всё остальное останется таким, как было. Здесь A, B, здесь наш треугольничек, C.
[01:06:07.880 --> 01:06:14.880]  Тогда что происходит с глубинами? Раньше была чёрная глубина H, теперь стала H-1.
[01:06:14.880 --> 01:06:21.880]  Ну, в смысле, это то, что произошло вот в этом по дереве C.
[01:06:21.880 --> 01:06:28.880]  Что теперь здесь? Здесь у меня чёрная глубина H, потому что здесь H-1, ещё одна чёрная вершинка A,
[01:06:28.880 --> 01:06:33.880]  поэтому здесь всё хорошо. Здесь тоже будет H, потому что одна чёрная и H-1.
[01:06:33.880 --> 01:06:39.880]  И здесь тоже всё хорошо, потому что здесь одна чёрная A и H-1 от A-1 приходят.
[01:06:39.880 --> 01:06:45.880]  Значит, чёрная глубина – это вершинки правильные. Опять-таки конфликтов красный-красный нет,
[01:06:45.880 --> 01:06:51.880]  потому что, смотрите, у B нет красного сына, значит, оба вот эти вот корня, вот здесь вот, они чёрные,
[01:06:51.880 --> 01:06:55.880]  соответственно, вот здесь происходит чёрный вершин. Поэтому конфликтов красный-красный нет.
[01:06:56.880 --> 01:06:59.880]  Единственный конфликт, который мог бы появиться, он был бы вот здесь вот.
[01:06:59.880 --> 01:07:04.880]  Но поскольку вершины красные, то конфликта нет. У нас появляется красная и чёрная,
[01:07:04.880 --> 01:07:10.880]  тогда выполняются все свойства. И опять-таки мы что-то перекрасили, у нас выполняются все свойства,
[01:07:10.880 --> 01:07:16.880]  и мы восстановили опять корректность красно-чёрного дерева.
[01:07:16.880 --> 01:07:24.880]  Так, хорошо, это был случай 2.1, то есть, когда A это красный, а это красный.
[01:07:32.880 --> 01:07:36.880]  Так, хорошо, значит, это мы сделали. Теперь нам осталось разобрать противоположную точку,
[01:07:36.880 --> 01:07:44.880]  а чёрный. Здесь будет опять-таки несколько кейсов. Ничё случай 2.2, а чёрный.
[01:07:47.880 --> 01:07:52.880]  Вот есть чёрный A, вот есть под дерево справа от него, который уменьшил свою чёрную глубину,
[01:07:52.880 --> 01:07:58.880]  аж наш минус один. Теперь давайте разберём, какие могут быть цвета у левого сына A,
[01:07:58.880 --> 01:08:02.880]  какие могут быть цвета у вершинки B. Цвет B.
[01:08:06.880 --> 01:08:11.880]  Так, сейчас, одну секунду.
[01:08:11.880 --> 01:08:23.880]  Да, значит, случай 2.1 получается. Да, это когда у меня B красный.
[01:08:27.880 --> 01:08:29.880]  Так, ещё раз, сейчас, одну секунду.
[01:08:36.880 --> 01:08:47.880]  Да, и потом будет случай, когда он чёрный. Так, всё хорошо.
[01:08:47.880 --> 01:08:51.880]  Значит, пусть вот A, пусть B теперь красный у нас.
[01:08:55.880 --> 01:08:58.880]  Тогда что у него происходит? Давайте перерисуем.
[01:08:58.880 --> 01:09:05.880]  Вот есть A, вот есть B, вот есть под дерево аж минус один.
[01:09:05.880 --> 01:09:10.880]  Можно ещё раз, что в корне под дерево аж минус один.
[01:09:10.880 --> 01:09:14.880]  Это значит следующее, что вот здесь было раньше, здесь в качестве поддерево
[01:09:14.880 --> 01:09:20.880]  висела корректное красно-чёрное дерево с корнем в чёрной вершине, с чёрной глубиной аж.
[01:09:20.880 --> 01:09:24.880]  Потом мы как-то над ним поиздевались, так что это осталось корректное красно-чёрное дерево
[01:09:24.880 --> 01:09:29.880]  с корнем в чёрной вершине, но теперь у него чёрная губина на 1 уменьшилась, вот это означает, что губина уменьшилась.
[01:09:29.880 --> 01:09:32.880]  Соответственно, всё, что выше, было тоже корректно, красно-чёрное дерево,
[01:09:32.880 --> 01:09:36.880]  просто теперь вместо правильного дерева справа висит дерево губины на 1 поменьше.
[01:09:36.880 --> 01:09:39.880]  Соответственно, у меня могла сломаться чёрная губина.
[01:09:39.880 --> 01:09:47.880]  Итак, Б красный. Теперь опять-таки два случая насчёт того, есть ли у Б красные дети.
[01:09:48.880 --> 01:09:51.880]  А нет, не так. Красных детей точно нет, он виноват.
[01:09:51.880 --> 01:09:55.880]  Оба ребёнка у Б, конечно же, чёрные.
[01:09:55.880 --> 01:10:05.880]  Опять-таки, раз H хотя бы двойка, здесь должно быть хотя бы две чёрные вершины на пути.
[01:10:05.880 --> 01:10:10.880]  У него есть обе чёрные вершины, давайте рассмотрим правого чёрного сына.
[01:10:10.880 --> 01:10:13.880]  С обязательно чёрный.
[01:10:13.880 --> 01:10:18.880]  И здесь два случая. Есть ли у С красный сын?
[01:10:25.880 --> 01:10:33.880]  Соответственно, случай 2,2,1,1 получается, это когда есть.
[01:10:33.880 --> 01:10:39.880]  Нарисуем. Значит, есть А, есть левый сын Б, у него есть правый сын С,
[01:10:39.880 --> 01:10:44.880]  ну и, например, левый сын D красный.
[01:10:44.880 --> 01:10:48.880]  И справа к А подвешен треугольник, который поменял свою губину.
[01:10:48.880 --> 01:10:54.880]  Тогда я сделаю следующее. Я опять-таки сделаю два поворота и перекрашивание, чтобы получилось вот как-то так.
[01:10:54.880 --> 01:11:00.880]  Сначала вот этот поворот, потом вот этот поворот.
[01:11:00.880 --> 01:11:05.880]  Тогда будет следующее. С встанет в корень, и я покрашу в чёрный.
[01:11:05.880 --> 01:11:10.880]  А станет справа, я тоже покрашу его в чёрный.
[01:11:10.880 --> 01:11:15.880]  Здесь будет Б, здесь будет D.
[01:11:15.880 --> 01:11:20.880]  И, соответственно, вот этот наш треугольник, он переподвесится в качестве правого сына.
[01:11:20.880 --> 01:11:24.880]  Он останется в качестве правого сына УА.
[01:11:24.880 --> 01:11:28.880]  Соответственно, всё, что было здесь, всякие вот эти под деревья, я их даже здесь явно не рисую.
[01:11:28.880 --> 01:11:32.880]  Давайте я один раз их навесую, что вот здесь есть под дерево, вот это, вот это, вот это.
[01:11:32.880 --> 01:11:38.880]  Они все, соответственно, сюда переподвешиваются в правильном порядке, так чтобы было правильное дерево поиска.
[01:11:38.880 --> 01:11:40.880]  Все под деревья также подвешиваются.
[01:11:40.880 --> 01:11:43.880]  Значит, теперь что происходит, почему всё починилось?
[01:11:43.880 --> 01:11:52.880]  Значит, смотрите, у меня чёрная губина, вот здесь вот раньше была H плюс 1.
[01:11:52.880 --> 01:11:55.880]  То есть чёрная вершинка А, и H была вот отсюда.
[01:11:55.880 --> 01:11:57.880]  Соответственно, здесь тоже везде H плюс 1.
[01:11:57.880 --> 01:11:59.880]  Теперь что происходит от вершинки С?
[01:11:59.880 --> 01:12:02.880]  Есть чёрная С, есть чёрная А, и здесь глубина H минус 1.
[01:12:02.880 --> 01:12:06.880]  Поэтому чёрная губина осталась такая, как надо, H плюс 1.
[01:12:06.880 --> 01:12:09.880]  Значит, 1 плюс 1 плюс H минус 1, это H плюс 1.
[01:12:09.880 --> 01:12:11.880]  Какой-нибудь путь здесь.
[01:12:11.880 --> 01:12:16.880]  Значит, здесь есть две чёрные, и здесь есть тоже под дерево с глубиной чёрной H минус 1.
[01:12:16.880 --> 01:12:19.880]  У них у всех глубина, конечно, H минус 1, потому что здесь была одна чёрная.
[01:12:19.880 --> 01:12:20.880]  Вот, ну и так далее.
[01:12:20.880 --> 01:12:26.880]  Короче, легко убедиться, что опять-таки у всех под деревьев здесь выполняется свойство про чёрную губину.
[01:12:27.880 --> 01:12:31.880]  И нету двух красных подряд, и их не появится нигде сверху.
[01:12:31.880 --> 01:12:33.880]  Поэтому мы на самом деле можем сразу завершиться.
[01:12:33.880 --> 01:12:39.880]  То есть мы опять сделали два поворота, сделали перекрашивание и избавились от всяких нарушений и свойств.
[01:12:39.880 --> 01:12:40.880]  Вот так.
[01:12:42.880 --> 01:12:44.880]  Значит, противоволожный случай.
[01:12:45.880 --> 01:12:46.880]  Что получается?
[01:12:46.880 --> 01:12:49.880]  2, 2. Не знаю, что я их номирую, но ладно.
[01:12:49.880 --> 01:12:53.880]  2, 2, 1, 2, когда у С нет красного сына.
[01:12:53.880 --> 01:12:54.880]  Что мы такое видели?
[01:12:54.880 --> 01:12:56.880]  Тогда нужно просто С перекрасить в...
[01:13:00.880 --> 01:13:02.880]  Тогда нужно будет С просто перекрасить в красный, и всё будет хорошо.
[01:13:02.880 --> 01:13:04.880]  Значит, тогда картинка такая.
[01:13:11.880 --> 01:13:12.880]  Так.
[01:13:12.880 --> 01:13:17.880]  Вот здесь треугольник, который поменял высоту, и у С нет красных детей.
[01:13:17.880 --> 01:13:19.880]  И у С нет красных детей.
[01:13:22.880 --> 01:13:24.880]  Тогда мы делаем просто один поворот вот здесь.
[01:13:27.880 --> 01:13:28.880]  И будет следующее.
[01:13:28.880 --> 01:13:32.880]  Будет чёрная В, справа чёрная А, и слева красная С.
[01:13:33.880 --> 01:13:36.880]  Ну и синий треугольник останется вот здесь.
[01:13:38.880 --> 01:13:44.880]  За счёт того, что у С нет красных детей, я её могу спокойно перекрасить в красный.
[01:13:44.880 --> 01:13:49.880]  Когда не возникнет конфликтов вот с этими двумя детьми, не будет конфликтов красный-красный,
[01:13:49.880 --> 01:13:50.880]  потому что там не было красных детей.
[01:13:50.880 --> 01:13:53.880]  И оба вот этих под деревом начинаются с чёрной вершинки.
[01:13:53.880 --> 01:13:55.880]  Поэтому здесь тоже будет чёрная вершина в корне.
[01:13:56.880 --> 01:13:58.880]  Противоречий красный-красный не будет.
[01:13:59.880 --> 01:14:04.880]  Ну и с чёрной губиной тоже всё хорошо, потому что раньше у меня была чёрная губина H+,
[01:14:04.880 --> 01:14:07.880]  чёрная вершинка А, и раньше была H.
[01:14:07.880 --> 01:14:08.880]  Здесь стало сколько?
[01:14:08.880 --> 01:14:11.880]  Здесь есть чёрная В, чёрная А, и H-1.
[01:14:11.880 --> 01:14:13.880]  Тоже самое, H+.
[01:14:13.880 --> 01:14:16.880]  Какой-нибудь путь влево, например, что здесь было?
[01:14:16.880 --> 01:14:21.880]  Раз у меня было исходно H+, то вот здесь вот было под дерево с чёрной губиной H,
[01:14:21.880 --> 01:14:24.880]  и оно сюда и подвесилось, получается, здесь H+.
[01:14:25.880 --> 01:14:27.880]  Соответственно, все остальные пути можно также перебрать,
[01:14:27.880 --> 01:14:30.880]  убедиться, что у них чёрная губина не изменилась.
[01:14:30.880 --> 01:14:33.880]  То есть какая была в исходном дереве, такая стала и теперь.
[01:14:33.880 --> 01:14:35.880]  Ну и тоже можно завершиться.
[01:14:35.880 --> 01:14:40.880]  Я исправил все нарушения чёрной губины, и стало всё опять хорошо.
[01:14:40.880 --> 01:14:44.880]  Можно завершать наш рекурсивный подъём, который исправляет все нарушения свойств.
[01:14:47.880 --> 01:14:49.880]  Осталось нам два случая.
[01:14:49.880 --> 01:14:58.880]  Это когда и А, и Б чёрные.
[01:14:58.880 --> 01:15:00.880]  Давайте вернёмся.
[01:15:00.880 --> 01:15:03.880]  Да, мы фиксировали уже, что у нас А это чёрный.
[01:15:03.880 --> 01:15:05.880]  Дальше мы предположим, что он красный.
[01:15:05.880 --> 01:15:08.880]  Соответственно, случай 2.2.2 – это когда А чёрный, и Б чёрный.
[01:15:11.880 --> 01:15:13.880]  А есть Б, оба чёрные.
[01:15:13.880 --> 01:15:17.880]  А подвешено справа дерево, уменьшившее свою чёрную глубину.
[01:15:17.880 --> 01:15:19.880]  Теперь опять тоже наш любимый вопрос.
[01:15:19.880 --> 01:15:22.880]  Задаём себе, есть ли у Б красные дети?
[01:15:22.880 --> 01:15:25.880]  Есть ли у Б красные дети?
[01:15:25.880 --> 01:15:28.880]  Ну, соответственно, первая кесть – когда они есть.
[01:15:28.880 --> 01:15:31.880]  2.2.2.1 – есть.
[01:15:31.880 --> 01:15:33.880]  А есть Б, оба чёрные.
[01:15:33.880 --> 01:15:37.880]  А подвешено справа дерево, уменьшившее свою чёрную глубину.
[01:15:37.880 --> 01:15:40.880]  2.2.2.1 – есть.
[01:15:44.880 --> 01:15:46.880]  Опять давайте его нарисуем справа.
[01:15:46.880 --> 01:15:49.880]  Пусть он будет красный, красный Д.
[01:15:49.880 --> 01:15:53.880]  Тогда здесь будет опять-таки два поворота и перекрашивание.
[01:15:53.880 --> 01:15:56.880]  Первый поворот, второй поворот.
[01:15:56.880 --> 01:15:59.880]  Это сведёт нашу ситуацию вот к следующей.
[01:15:59.880 --> 01:16:02.880]  Д вылезет в корень.
[01:16:02.880 --> 01:16:05.880]  Мы его покрасим в чёрный.
[01:16:05.880 --> 01:16:09.880]  А у нас будут все вершинки чёрные.
[01:16:09.880 --> 01:16:12.880]  И синий треугольник будет справа.
[01:16:12.880 --> 01:16:15.880]  Опять-таки можно убедиться, что всё сохранится.
[01:16:15.880 --> 01:16:18.880]  Все свойства, какие были, такие останутся.
[01:16:18.880 --> 01:16:22.880]  Например, вот здесь исходно была глубина чёрной глубины h плюс 1.
[01:16:22.880 --> 01:16:24.880]  Вот здесь она теперь какая стала?
[01:16:24.880 --> 01:16:28.880]  Раз, два, плюс h минус 1, то есть в точности h плюс 1.
[01:16:28.880 --> 01:16:30.880]  Такая, как нам нужно.
[01:16:30.880 --> 01:16:32.880]  Дальше здесь какая глубина?
[01:16:32.880 --> 01:16:34.880]  Здесь одна чёрная, вторая чёрная.
[01:16:34.880 --> 01:16:36.880]  И деревья были вот здесь вот у b.
[01:16:36.880 --> 01:16:39.880]  Но здесь была глубина, видимо, h минус 1,
[01:16:39.880 --> 01:16:42.880]  потому что была чёрная-чёрная, значит здесь обязательно h минус 1.
[01:16:42.880 --> 01:16:45.880]  Ну и здесь опять осталась чёрная-чёрная и h минус 1.
[01:16:45.880 --> 01:16:47.880]  С чёрной глубиной всё хорошо.
[01:16:47.880 --> 01:16:51.880]  Противоречие красная-красная соседей у нас не появилось.
[01:16:51.880 --> 01:16:54.880]  Значит, мы опять всё исправили, и на этом можно завершиться.
[01:16:54.880 --> 01:16:58.880]  И, наконец, самый плохой случай, последний случай 2222,
[01:16:58.880 --> 01:17:03.880]  это когда нет красных детей.
[01:17:03.880 --> 01:17:09.880]  То есть ситуация такая, есть у нас a, есть слева b,
[01:17:09.880 --> 01:17:12.880]  есть под дерево, который изменил свою глубину,
[01:17:12.880 --> 01:17:17.880]  и здесь нет красных детей у b, то есть оба сына чёрные.
[01:17:17.880 --> 01:17:20.880]  Вот здесь чёрный корень и здесь чёрный корень.
[01:17:20.880 --> 01:17:22.880]  Тогда мы сделаем следующее.
[01:17:22.880 --> 01:17:25.880]  Мы перекрасим b в красный
[01:17:25.880 --> 01:17:35.880]  и запустимся рекурсивно от a.
[01:17:35.880 --> 01:17:41.880]  Рекурсивно вверх.
[01:17:41.880 --> 01:17:46.880]  И вот здесь, обратите внимание, здесь самый важный случай.
[01:17:46.880 --> 01:17:48.880]  Все остальные просто какие-то условия,
[01:17:48.880 --> 01:17:52.880]  когда можно за 1-2 поворота и перекрашивание всё сразу исправить,
[01:17:52.880 --> 01:17:54.880]  а вот здесь нужно придётся подниматься выше.
[01:17:54.880 --> 01:17:57.880]  Значит, смотрите, пусть a чёрный, и b чёрный,
[01:17:57.880 --> 01:18:03.880]  и у b нет красных детей, тогда оба ребёнка чёрные.
[01:18:03.880 --> 01:18:05.880]  То есть вот здесь чёрные, вот здесь чёрные.
[01:18:05.880 --> 01:18:08.880]  Слева и справа чёрные по дереве.
[01:18:08.880 --> 01:18:12.880]  Тогда вспоминаем, у меня вот здесь было корректное под дерево
[01:18:12.880 --> 01:18:16.880]  с глубиной h, стало с глубиной h-1.
[01:18:16.880 --> 01:18:20.880]  Тогда что я сделал, когда я поменял цвет вершинки b на красных?
[01:18:20.880 --> 01:18:23.880]  Во-первых, у меня не возникло конфликтов красный-красный,
[01:18:23.880 --> 01:18:25.880]  у меня у b не было красных сыновей.
[01:18:25.880 --> 01:18:28.880]  У меня теперь у b только чёрные дети,
[01:18:28.880 --> 01:18:32.880]  и перекраска его в красный цвет ничего не сломает.
[01:18:32.880 --> 01:18:36.880]  Но зато, смотрите, я уменьшил глубины вот этих всех чёрных путей.
[01:18:36.880 --> 01:18:39.880]  То есть здесь раньше была чёрная глубина h-1,
[01:18:39.880 --> 01:18:42.880]  раз раньше здесь была h-1, то здесь была раньше h-1,
[01:18:42.880 --> 01:18:44.880]  а теперь стала h.
[01:18:44.880 --> 01:18:47.880]  Я уменьшил за счёт перекраски одной чёрной вершины в красный цвет,
[01:18:47.880 --> 01:18:50.880]  и я уменьшил чёрную глубину на единицу.
[01:18:50.880 --> 01:18:54.880]  Поэтому все это теперь это корректное красно-черное дерево
[01:18:54.880 --> 01:18:56.880]  с корнем в чёрной вершине,
[01:18:56.880 --> 01:19:00.880]  у которой чёрная глубина уменьшилась на 1 по сравнению с исходом.
[01:19:00.880 --> 01:19:02.880]  Это как раз та задача, которую мы решаем.
[01:19:02.880 --> 01:19:05.880]  Раньше это выполнялось для под деревом,
[01:19:05.880 --> 01:19:08.880]  здесь было какой-то корректно красно-черное дерево,
[01:19:08.880 --> 01:19:12.880]  у которого уменьшилась чёрная глубина на единицу.
[01:19:12.880 --> 01:19:15.880]  В случае вот в этом… я могу так перекрасить,
[01:19:15.880 --> 01:19:18.880]  что теперь у меня вот это будет корректное красно-черное дерево,
[01:19:18.880 --> 01:19:21.480]  из которого чёрная губна уменьшилась на 1 disproportionately с исходом.
[01:19:21.480 --> 01:19:24.580]  Потому что здесь уменьчилась на 1 и здесь уменьчилась на 1 чёрная губина.
[01:19:24.580 --> 01:19:28.660]  Всё, я просто поднимаюсь в А и запускаю опять разбор случаев рекурсивных,
[01:19:28.660 --> 01:19:32.780]  то есть у меня опять есть функция, которая стоит в какой-то вершине,
[01:19:32.780 --> 01:19:36.780]  в которой поменялась вот это наше свойство, то есть что уменьшилась губина на единичку.
[01:19:36.780 --> 01:19:40.020]  Просто поднимается, там все случаи перебирает, если что поднимается вверх,
[01:19:40.020 --> 01:19:44.840]  опять рекурсивно что-то делает, либо делает trying to Göwoって перекрашен.
[01:19:44.840 --> 01:19:46.840]  На этом и рейс мы тоже разобрали.
[01:19:52.840 --> 01:19:56.840]  Я сразу скажу, что здесь можно ничего в принципе не пугаться.
[01:19:56.840 --> 01:20:00.840]  К экзамену не нужно будет учить все эти 9 случаев, которые мы разобрали.
[01:20:00.840 --> 01:20:02.840]  6 тут и 3 в инсерте.
[01:20:02.840 --> 01:20:05.840]  Я сделаю какую-нибудь паркалку, на которой будут написаны все эти повороты,
[01:20:05.840 --> 01:20:08.840]  потому что я считаю, что не нужно держать в голове.
[01:20:08.840 --> 01:20:12.840]  Нужно просто понимать, как все случаи достаточно разобрать.
[01:20:12.840 --> 01:20:15.840]  Что их достаточно для решения.
[01:20:15.840 --> 01:20:18.840]  Но их все заучивать, конечно, это убиться может.
[01:20:18.840 --> 01:20:26.840]  Итак, давайте напоследок я формулирую, чем все наши обсужденные деревья лучше.
[01:20:26.840 --> 01:20:29.840]  Где их можно применять, где они оптимальны.
[01:20:29.840 --> 01:20:33.840]  Красно-черные деревья, red-black деревья.
[01:20:33.840 --> 01:20:35.840]  Какие у них плюсы?
[01:20:35.840 --> 01:20:40.840]  Плюсы в том, что во-первых, всегда работают от логарифма,
[01:20:40.840 --> 01:20:43.840]  потому что глубина всегда ограничена логарифмом.
[01:20:43.840 --> 01:20:48.840]  И плюс еще в том, что всегда не больше, чем два поворота.
[01:20:48.840 --> 01:20:51.840]  Всегда не больше, чем два поворота.
[01:20:51.840 --> 01:20:57.840]  Я говорил, когда мы сделали инсерт, что самое тяжелое во всех этих перебалансировках,
[01:20:57.840 --> 01:21:03.840]  это, конечно, поворота, потому что поворот включает в себя много всяких присвоений указателей.
[01:21:03.840 --> 01:21:06.840]  И хотелось бы, чтобы было как можно меньше.
[01:21:06.840 --> 01:21:09.840]  Вы поняли, что и в инсерте, и в эрезе таких поворотов всегда максимум два.
[01:21:09.840 --> 01:21:12.840]  И это выгодно отличает red-black от avail.
[01:21:12.840 --> 01:21:15.840]  Значит, в red-black всего максимум два поворота.
[01:21:15.840 --> 01:21:18.840]  Но давайте я напишу минус.
[01:21:18.840 --> 01:21:23.840]  Глубина может быть примерно два логарифма.
[01:21:23.840 --> 01:21:28.840]  Значит, по сравнению с avail деревом, у него плюс тоже, что всегда за от логарифма,
[01:21:28.840 --> 01:21:32.840]  потому что глубина всегда от логарифма.
[01:21:32.840 --> 01:21:41.840]  У него было что-то в стиле логарифма по основанию phi от n,
[01:21:41.840 --> 01:21:43.840]  дефец золотой сечения.
[01:21:43.840 --> 01:21:47.840]  Насколько я помню, грубо говоря, это что-то в стиле полтора логен.
[01:21:47.840 --> 01:21:51.840]  То есть глубина у avail чуть меньше, чем у red-black.
[01:21:51.840 --> 01:21:57.840]  Поэтому если вы пишете red-black, то вам нужно будет в константу раз дольше спускаться.
[01:21:57.840 --> 01:22:00.840]  Примерно полтора логарифма.
[01:22:00.840 --> 01:22:02.840]  Сейчас я в чат вернусь.
[01:22:02.840 --> 01:22:14.840]  Минус, может быть много поворотов по сравнению с red-black.
[01:22:14.840 --> 01:22:21.840]  Red-black всегда максимум два, а в avail их максимум вплоть до всей глубины.
[01:22:21.840 --> 01:22:23.840]  Возможно, все дерево придется поворачивать.
[01:22:23.840 --> 01:22:26.840]  То есть подниматься наверх и для каждой вершинки делать поворот.
[01:22:26.840 --> 01:22:29.840]  А про все остальные деревья мы знаем их преимущество.
[01:22:29.840 --> 01:22:36.840]  Сплей минус его то, что он амортизированный и может на какие-то запросы отвечать долго.
[01:22:36.840 --> 01:22:40.840]  Но его плюс в том, что он частые запросы хранит близко к корню.
[01:22:40.840 --> 01:22:44.840]  У декартового дерева плюс, наверное, в том, что он проще всего пишется.
[01:22:44.840 --> 01:22:48.840]  Минус в том, что он вероятностный и опять-таки на какие-то вопросы может долго отвечать.
[01:22:48.840 --> 01:22:53.840]  У B дерева плюс в том, что оно работает с огромным массивом данных.
[01:22:53.840 --> 01:23:01.840]  А минус в том, что оно не дает выигрыша по сравнению с red-black или avail.
[01:23:01.840 --> 01:23:08.840]  Похожие посложности, всякие процедуры, повороты, сплиты, мержи и так далее.
[01:23:08.840 --> 01:23:15.840]  На малых массивах данных лучше писать avail или red-black.
[01:23:15.840 --> 01:23:23.840]  Последнее, что скажу, это что чаще всего именно на red-black деревьях реализуется STD set и STD demo.
[01:23:23.840 --> 01:23:28.840]  Это вроде как не требуется в...
[01:23:28.840 --> 01:23:34.840]  Ну, короче, это не требование компилятора, но большинство реализует их именно через красно-черное дерево.
[01:23:34.840 --> 01:23:36.840]  Так, вопрос.
[01:23:36.840 --> 01:23:40.840]  Рейс из-за 222 не может идти вверх до корни, совершив кучу действий хоть при пнастке?
[01:23:40.840 --> 01:23:45.840]  Может, может, но повторюсь, это гораздо более простое действие, чем поворот.
[01:23:45.840 --> 01:23:52.840]  Даже подняться в корни, подняться в родителя и сделать перекрашивание, это проще, чем сделать много поворотов.
[01:23:52.840 --> 01:23:57.840]  Он может подниматься, но, смотрите, если мы все равно спускаемся до этой вершинки,
[01:23:57.840 --> 01:23:59.840]  то потом подняться обратно, в принципе, это не очень сложно.
[01:23:59.840 --> 01:24:04.840]  Нужно просто пройтись в обратном порядке по тем вершинам, которые мы прошли, если нужно перекрасить.
[01:24:05.840 --> 01:24:10.840]  То есть у RedBlack меньше константов?
[01:24:10.840 --> 01:24:13.840]  Даже несмотря на то, что глубина немного больше, чем у AVL?
[01:24:13.840 --> 01:24:14.840]  Еще раз.
[01:24:14.840 --> 01:24:15.840]  Ну, не совсем.
[01:24:15.840 --> 01:24:17.840]  Сейчас скажу.
[01:24:17.840 --> 01:24:19.840]  У AVL меньше константов...
[01:24:19.840 --> 01:24:26.840]  У RedBlack можно сказать, что меньше константов в инсерт и в рейс.
[01:24:26.840 --> 01:24:29.840]  То есть он оптимальнее с точки зрения инсертов и рейзов,
[01:24:29.840 --> 01:24:32.840]  а AVL оптимальнее с точки зрения файлов, скажем так.
[01:24:32.840 --> 01:24:35.840]  То есть здесь хоть глубина побольше, но зато поворотов всяких меньше.
[01:24:35.840 --> 01:24:38.840]  А здесь Find лучше, потому что у него глубина меньше,
[01:24:38.840 --> 01:24:41.840]  а поворотов не надо ни в AVL, ни в RedBlack.
[01:24:41.840 --> 01:24:43.840]  Не нужны повороты при Fight.
[01:24:44.840 --> 01:24:46.840]  То есть, соответственно, опять зависит от задачи.
[01:24:46.840 --> 01:24:48.840]  Если у вас более-менее фиксированная база данных,
[01:24:48.840 --> 01:24:51.840]  и нередко поступает запрос изменения, то, наверное, лучше AVL.
[01:24:51.840 --> 01:24:54.840]  Иначе, если она часто динамически меняется, то, наверное, лучше RedBlack,
[01:24:54.840 --> 01:24:58.840]  хоть Find чуть-чуть подольше работает в константу раз.
[01:24:58.840 --> 01:25:01.840]  Но зато инсерт и рейс будут эффективнее, чем AVL.
[01:25:02.840 --> 01:25:11.840]  Вот, если нет вопросов, тогда всем спасибо за большое внимание.
[01:25:11.840 --> 01:25:15.840]  Увидимся на экзамене. Удачи на зачете и на экзамене. Всем пока!
