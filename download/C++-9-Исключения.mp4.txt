[00:00.000 --> 00:13.360]  так мы остановились на тихо давайте тихо все мы остановились на шаблонах с
[00:13.360 --> 00:19.080]  переменным количеством аргументов я показал вам функцию принт а что еще
[00:19.080 --> 00:26.440]  например можно продемонстрировать тут ну давайте например
[00:26.440 --> 00:38.000]  какую-нибудь еще функцию реализуем на шаблоне с переменом количеством
[00:38.000 --> 00:41.800]  аргументов вот что еще можно сделать например с шаблоном с переменным количеством аргументов
[00:41.800 --> 00:54.440]  ну скажем ну да можно например сумму сделать вот ну как это будет выглядеть
[00:54.440 --> 01:01.160]  там опять стимплейт ну мне опять надо будет
[01:02.160 --> 01:10.800]  когда ты передаешь пакет то он распаковывается в head и в tail
[01:10.800 --> 01:18.640]  ну вот когда передаю пакет то его первый первый аргумент автоматически становится первым
[01:18.640 --> 01:28.600]  типом вы можете не разговаривать слух там сейчас очень мне тяжело это перекликивать вот
[01:28.600 --> 01:39.480]  ну здесь я могу написать что-нибудь там ну я не знаю ну авто могу написать ладно допустим
[01:39.480 --> 01:53.880]  ну я буду возвращать там сумму да я буду говорить head плюс сумма от хвоста вот и опять-таки нужна
[01:53.880 --> 02:07.520]  специализация которая говорит там t сумма от одного аргумента даже от нуля правда непонятно
[02:07.520 --> 02:20.720]  что она возвращает поэтому уж лучше от одного какого типа какая надо складывать а ты это что
[02:20.720 --> 02:34.560]  такое если сумма без аргумента то непонятно что возвращать вот если так вот ну тут я написал
[02:34.560 --> 02:42.120]  авто типа так можно писать начиная с 11 если получается общий тип для них вывести то он
[02:42.120 --> 02:54.680]  выведет вот но если не получается конечно то будет ce вот да в принципе кажется все что я
[02:54.680 --> 03:01.880]  хотел сказать по этому поводу есть еще правда одна маленькая деталь ка это
[03:01.880 --> 03:15.560]  сайзов с многоточим да что что еще раз
[03:15.560 --> 03:28.040]  ну потому что возвращает потому что там я и так знаю какой тип там будет
[03:29.040 --> 03:43.000]  а тут я не знаю какой будет тип я сложу все эти штуки да но он является перегрузкой да
[03:43.000 --> 03:59.040]  формально ну вот это не очень ну да да да вызовется версия от нуля аргументов
[03:59.040 --> 04:11.520]  какая ссылка ну у вас пакете будет 0 аргументов это значит что ну как просто будет вот этот принт он
[04:11.520 --> 04:37.120]  от одного аргумента будет что сделать мы в прошлый раз уже видели что он смог так тут нет
[04:37.120 --> 04:43.520]  никакой специализации тут одна версия шаблонная и одна версия где ты видишь специализации никакой
[04:43.520 --> 04:49.880]  специализации нет ну компилятор понимает по числу аргументов какую версию вызывать потому что от
[04:49.880 --> 04:55.720]  любого количества аргументов больше нуля у него есть версия шаблонная от нуля аргументов у него
[04:55.720 --> 05:04.000]  есть не шаблонная версия все в чем проблема генерируется ровно n плюс 1 версия функций принт в
[05:04.000 --> 05:11.020]  реальности вы передали принт от н аргументов компилятор сгенерирует n плюс 1 версию функций
[05:11.020 --> 05:22.640]  принт в рантайме будет реальная n плюс 1 реальная там разная функция принт да почему что не
[05:22.640 --> 05:45.280]  компилирует все компилируется так ну авто мы с вами формально не проходили смотрите еще
[05:45.280 --> 05:53.460]  одна вещь которую надо здесь сказать это вот какая это оператор сайзов многоточие есть такой
[05:53.460 --> 06:07.420]  способ узнать сколько элементов в пакете встроенный язык способ для этого существует оператор сайзов
[06:07.420 --> 06:17.980]  многоточие который в компилтайме работает вот вот он так записывается значит сайзов многоточие это
[06:17.980 --> 06:29.040]  отдельный оператор вот сейчас он выведет мне количество аргументов в хвосте ну соответственно
[06:29.040 --> 06:37.320]  да он будет выводить ну сейчас понятно он увидит там один а в хвосте три аргумента потом два хвосте
[06:37.320 --> 06:44.640]  два аргумента потом овц в хвосте один аргумент потом три в хвосте ноль аргументов а потом принт
[06:44.640 --> 06:54.960]  пустой уже то есть сайзов многоточие говорит сколько аргументов в пакете в компилтайме он
[06:54.960 --> 07:02.480]  работает ну в компилтайме эта штука подставляется число в виде числа я могу например сказать следующее
[07:02.480 --> 07:15.720]  как я могу использовать оператор избавиться от принта от пустого принт я могу сказать и в
[07:15.720 --> 07:24.080]  конст экспор потому что это же в компилтайме работающая штука если сайзов многоточие tail больше
[07:24.080 --> 07:35.960]  нуля то принт от tail правильно а если убрать конст экспорт то это уже не скомпилируется
[07:35.960 --> 07:52.480]  если конст экспорт что да
[07:52.480 --> 08:02.040]  вызываться не будет да потому что конст экспорт значит не в конст экспорт означает что проверка
[08:02.040 --> 08:10.720]  должна быть выполнена в компилтайме как ты в рамптайме будешь генерирует ее функции
[08:10.720 --> 08:21.280]  потому что без слова конст экспорт я заставляю компилятор скомпилировать тело этой функции в
[08:21.280 --> 08:27.200]  любом случае со словом конст экспорт компилятор просто не компилирует вот эту строчку пропускает ее
[08:27.200 --> 08:37.800]  у меня нету функции от нуля аргументов и поэтому я с ней не пишу конст экспорт то он не может
[08:37.800 --> 08:41.840]  скомпилировать эту строчку а если я пишу конст экспорт то он ее не пытается компилировать
[08:41.840 --> 08:58.520]  нету функции принта от нуля аргументов я убрал функцию принта от нуля аргументов
[08:58.520 --> 09:06.240]  теперь он не может ее скомпилировать но если написать конст экспорта будет работать напоминаю
[09:06.240 --> 09:14.680]  что и в конст экспорт работает только начиная си плюс плюс 17 вот но вам пользоваться им
[09:14.680 --> 09:22.880]  будет нельзя наверное наверное я подумаю может быть и в конст экспорт все-таки можно я еще подумал
[09:22.880 --> 09:33.280]  ой слушайте я забыл сказать еще одну очень важную вещь а вот блин чуть не забыл я уже вот сколько раз
[09:33.280 --> 09:41.480]  я ловлю что надо не забыть рассказать я и забываю это на самом деле нужно было рассказать в предыдущем
[09:41.480 --> 09:53.120]  пункте который простейшие метафункции еще не в 6 8 а в 6 7 да как сгенерировать ошибку
[09:53.120 --> 10:00.480]  компиляции если какой-то компел тайм условия нарушена вот например я хочу убедиться что ну
[10:00.480 --> 10:09.880]  я не знаю ну давайте вот я здесь генерирую ошибку компиляции если
[10:09.880 --> 10:22.800]  а борд конст экспорт не знаю вот давайте я сгенерирую ошибку компиляции тут если что-нибудь
[10:22.800 --> 10:35.040]  но там если какой-нибудь условия не выполнено например если что не знаю ну чушь какой-нибудь
[10:35.040 --> 10:49.000]  там если это не и вот просто так вот значит я генерирую ошибку компиляции что кокнуло
[10:49.000 --> 11:01.880]  проектор это как я ничего не писал пока для того чтобы генерировать ошибки в рантайме есть
[11:01.880 --> 11:13.080]  функция ассерт как вы наверное знаете ассерт какое-то выражение вот и что и если оно лоша
[11:13.080 --> 11:24.320]  в этом месте то будет ре будет рантаймер ассерт фейл отгадайте как выглядит что надо
[11:24.320 --> 11:36.520]  написать чтобы это была компайл там ошибка статик ассерт статик ассерт это ключевое это ключевое
[11:36.520 --> 11:45.520]  слово начиная c++ 11 статик ассерт как видите это вообще зарезервированное слово начиная c++ 11
[11:45.520 --> 11:51.760]  есть такой способ ну до c++ 11 тоже можно было но это был уродский абсолютно то есть нужно было
[11:51.760 --> 11:56.320]  там искусственно заставлять инстанцировать шаблон в котором что-то там отсутствует какой-то
[11:56.320 --> 12:02.840]  тип вот статик ассерт это штука которая генерирует вам ошибку компиляции если нарушено какой-то
[12:02.840 --> 12:09.640]  компайл там условия ну например если тип хэд это не инд давайте сгенерируем ошибку компиляции
[12:09.640 --> 12:22.760]  значит как это написать что тип хэд это не инд type id не верно type id работает в рантайме мы не
[12:22.760 --> 12:29.320]  можем в компайл тайме проверить вызвать оператор type id как в компайл тайме проверить что тип хэд
[12:29.320 --> 12:38.640]  это не инд что хэд большой или хэд маленькая операторы можно вызывать только над значениями как
[12:38.640 --> 12:46.560]  ты проверяешь тип как ты сравниваешь типа с помощью оператора не равно третья попытка как проверить в
[12:46.560 --> 13:01.200]  компайл тайме что тип хэд это не инд нет я хочу вот здесь написать там можно я хочу статик
[13:01.200 --> 13:07.880]  ассертом проверить некоторые условия что ты говоришь есть какой-нибудь есть какой же как же он
[13:07.880 --> 13:19.320]  называется мы его в прошлый раз даже реализовывали прикиньте как вам такая новость я кстати забыл
[13:19.320 --> 13:27.160]  сказать у нас осталось всего две недели не считая этой а это значит что нам нужно с вами зачет
[13:27.160 --> 13:32.440]  провести а нам же надо с вами два зачета провести один по материалу семинаров а другой по материалу
[13:32.440 --> 13:39.680]  лекции этого семестра а значит вероятно а значит вероятно ну по материалам что федя рассказывал и
[13:39.680 --> 13:46.480]  по материалам что я рассказывал значит вероятно на на следующей неделе у вас будет зачет по что
[13:46.480 --> 13:57.120]  раньше вы хотите потому что я рассказывал и потому что федя рассказывает мне самому
[13:57.120 --> 14:03.000]  наверное хочется по фединому материалу потому что его меньше было я сегодня вам еще до расскажу
[14:03.000 --> 14:11.520]  еще за еще в следующий раз расскажу что-нибудь и 19 устрою вам зачет зачет по крайней мере по моей
[14:11.520 --> 14:19.000]  части будет письменной скорее всего то есть на всю первую пару на полтора часа вам выдам
[14:19.000 --> 14:28.040]  листочки задачем нет листочки где писать сами возьмите ну хотя не знаю 19 мы на семирязевской здесь
[14:28.040 --> 14:39.520]  а что почему нет а что вас удивляет а ты на что рассчитывал а у нас зачет недели есть
[14:40.220 --> 14:44.060]  чонбы зачет недели есть инфа за что неделя прошла
[14:44.060 --> 14:52.280]  19-я это еще зачет на недели вот 19 декабря зачет на неделя длиться ровно неделю как не странно
[14:52.280 --> 14:55.840]  начинается во вторник и 시작ени surtout по недельник по поводу или в среду начинается
[14:55.840 --> 15:02.140]  верх написать во вторник 19 декабря понедельник зачет на неделе вас как обычно tell и вы приезжаете
[15:02.140 --> 15:08.540]  сюда и мы устраиваем здесь зачет хотя можно устроить в принципе оба зачета 2019
[15:08.540 --> 15:18.780]  ну короче имейте в виду вот то что вы тут это как проверить что это не и есть метафункция и сейм
[15:18.780 --> 15:30.940]  реализовывали да и сейм в причем потому что мы вл я от нее берем хед стаинт вот статя
[15:31.060 --> 15:40.340]  вот такой что хэд это не инт и сейм в это буль значит я проверяю что ой наоборот я хочу
[15:40.340 --> 15:47.540]  проверить что это инт поэтому я пишу стд сейм в инт соответственно теперь я пытаюсь сделать
[15:47.540 --> 16:02.460]  сумм ну давайте стд сяут сумма 1 2 3 4 вот и будет значит 10 а цеда вот здесь тут надо констекс
[16:02.460 --> 16:18.500]  провернуть ну вот 10 выводится если я здесь например передам ансайн тинт то все будет
[16:19.100 --> 16:31.500]  статик ассершен фейлт ансайн тинт это уже не инт поэтому ци и сейм и проверяет что
[16:31.500 --> 16:39.420]  типы точно совпадет точно равны сайн инт это то же самое что инт просто
[16:39.420 --> 16:59.260]  да я даже могу написать юзинг май кул тайп равно инт и здесь сказать май тайп
[16:59.260 --> 17:10.180]  передать по умолчанию без параметров вот это будет нормально потому что это в точности
[17:10.180 --> 17:17.180]  инт это не новый тип а это тот же самый тип это инт юзинг не создает новых типов он просто
[17:17.180 --> 17:24.100]  дает другие названия старым типом поэтому май кул тайп это равно инт а сайн не равно
[17:24.100 --> 17:54.100]  да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да да
[17:54.100 --> 17:57.100]  не выражение времени компиляции
[17:59.100 --> 18:01.100]  ну во первых тут наверное надо вот так сделать
[18:05.100 --> 18:09.100]  ну потому что мне type-id от expression нужно а не от типа
[18:10.100 --> 18:13.100]  ну нет вроде можно type-id от типа но это не важно
[18:15.100 --> 18:21.100]  это CE потому что статик ассерт не то что неверен его невозможно выполнить
[18:21.100 --> 18:23.100]  статик ассерт
[18:23.100 --> 18:26.100]  может вызываться только от константных выражений
[18:26.100 --> 18:28.100]  а это не константное выражение
[18:29.100 --> 18:32.100]  non-constant condition статик ассерт
[18:32.100 --> 18:35.100]  типа type-id non-constant export function
[18:38.100 --> 18:40.100]  констант известен в компайл тайме
[18:40.100 --> 18:42.100]  это должно быть какое-то выражение
[18:42.100 --> 18:45.100]  константное значение которого известна в компайл тайме конечно
[18:45.100 --> 18:47.100]  тогда от него статик ассерт можно делать
[18:47.100 --> 18:51.100]  статик ассерт вам очень активно пригодится в задачи про матрицу
[18:51.100 --> 18:56.100]  потому что вам нужно будет собственно генерироваться ошибки компиляции в случае когда n не простое
[18:57.100 --> 19:01.100]  там в функции сумм короче у меня проблемы что типа когда он вызывает от одного аргумента
[19:01.100 --> 19:04.100]  он вызывает не верхнюю а вот это все еще и потом он хочет от нуля его
[19:04.100 --> 19:06.100]  это кто это так делает?
[19:06.100 --> 19:08.100]  компилятор
[19:08.100 --> 19:10.100]  какой компилятор я понимаю что не
[19:10.100 --> 19:12.100]  что не
[19:12.100 --> 19:14.100]  и g++ и сланк почему-то оба
[19:14.100 --> 19:16.100]  сам x++
[19:16.100 --> 19:18.100]  сам x++
[19:18.100 --> 19:20.100]  сланк
[19:20.100 --> 19:22.100]  ну не знаю
[19:22.100 --> 19:24.100]  я сейчас не готов смотреть на твой код
[19:24.100 --> 19:26.100]  подойди покажи мне потом
[19:28.100 --> 19:30.100]  так окей все я рассказал все что хотел в этом пункте
[19:30.100 --> 19:32.100]  идем дальше
[19:38.100 --> 19:40.100]  и еще одна замечательная вещь чтобы вас добить
[19:40.100 --> 19:42.100]  это 6,9
[19:42.100 --> 19:44.100]  да
[19:44.100 --> 19:46.100]  fold expressions
[19:48.100 --> 19:50.100]  выражение свертки
[19:50.100 --> 19:52.100]  по русски
[19:52.100 --> 19:54.100]  говоря
[19:54.100 --> 19:56.100]  свертки
[20:02.100 --> 20:04.100]  ну по русски они так называются
[20:04.100 --> 20:06.100]  а по английски fold expressions
[20:06.100 --> 20:08.100]  кто знает что это такое?
[20:08.100 --> 20:10.100]  фича
[20:10.100 --> 20:12.100]  начиная с c++17 но
[20:12.100 --> 20:14.100]  в сердечке
[20:14.100 --> 20:16.100]  очень классно
[20:16.100 --> 20:18.100]  будем активно пользоваться во втором семестре
[20:18.100 --> 20:20.100]  а сейчас только продемонстрирую вам
[20:20.100 --> 20:22.100]  как это круто
[20:22.100 --> 20:24.100]  начиная с c++17
[20:24.100 --> 20:26.100]  можно
[20:26.100 --> 20:28.100]  писать
[20:28.100 --> 20:30.100]  вещи типа
[20:30.100 --> 20:32.100]  функции сам
[20:32.100 --> 20:34.100]  короче
[20:34.100 --> 20:36.100]  а именно
[20:36.100 --> 20:38.100]  вот как давайте я
[20:38.100 --> 20:40.100]  еще раз реализую функцию сам
[20:40.100 --> 20:42.100]  template type name
[20:42.100 --> 20:44.100]  head type name
[20:44.100 --> 20:46.100]  многоточие tail
[20:48.100 --> 20:50.100]  э
[20:50.100 --> 20:52.100]  ну давайте
[20:52.100 --> 20:54.100]  будет все еще авто
[20:54.100 --> 20:56.100]  сумма
[20:56.100 --> 20:58.100]  const head&head
[20:58.100 --> 21:00.100]  const tail&
[21:00.100 --> 21:02.100]  многоточие tail
[21:02.100 --> 21:04.100]  и вот тут
[21:04.100 --> 21:06.100]  я сейчас
[21:06.100 --> 21:08.100]  напишу интересную вещь
[21:08.100 --> 21:10.100]  return
[21:10.100 --> 21:12.100]  скобочка открывается
[21:14.100 --> 21:16.100]  head
[21:16.100 --> 21:18.100]  плюс
[21:18.100 --> 21:20.100]  э
[21:22.100 --> 21:24.100]  мне не нужна
[21:24.100 --> 21:26.100]  head даже
[21:26.100 --> 21:28.100]  я вообще уберу head здесь
[21:30.100 --> 21:32.100]  будет вот как
[21:32.100 --> 21:34.100]  нет tail
[21:34.100 --> 21:36.100]  плюс многоточие и все
[21:36.100 --> 21:38.100]  вот что
[21:38.100 --> 21:40.100]  ладно мы так делали
[21:40.100 --> 21:42.100]  в принципе раньше
[21:42.100 --> 21:44.100]  что ты хочешь
[21:44.100 --> 21:46.100]  может ты так и делал
[21:46.100 --> 21:48.100]  ну
[21:48.100 --> 21:50.100]  давайте для начала
[21:50.100 --> 21:52.100]  проверим что я вас не обманула
[21:52.100 --> 21:54.100]  что это работает
[21:54.100 --> 21:56.100]  сумма от
[21:56.100 --> 21:58.100]  1,2,3,4
[21:58.100 --> 22:00.100]  а скобочки обязательно
[22:00.100 --> 22:02.100]  это тот самый пример
[22:02.100 --> 22:04.100]  нет это не тот
[22:04.100 --> 22:06.100]  пример
[22:06.100 --> 22:08.100]  это работает
[22:08.100 --> 22:10.100]  черт это работает
[22:10.100 --> 22:12.100]  но только начиная
[22:12.100 --> 22:14.100]  c++17 вот если я это уберу
[22:14.100 --> 22:16.100]  то скорее всего он что-нибудь скажет что
[22:16.100 --> 22:18.100]  warning all expressions
[22:18.100 --> 22:20.100]  почему
[22:20.100 --> 22:22.100]  черт
[22:22.100 --> 22:24.100]  не знаю
[22:24.100 --> 22:26.100]  кому-то не нравится мне так нравится
[22:26.100 --> 22:28.100]  мне надо работать
[22:28.100 --> 22:30.100]  с капетами
[22:30.100 --> 22:32.100]  да
[22:32.100 --> 22:34.100]  c++17
[22:34.100 --> 22:36.100]  добавил еще одну
[22:36.100 --> 22:38.100]  операцию над пакетом
[22:38.100 --> 22:40.100]  значит можно
[22:40.100 --> 22:42.100]  тут у меня нет доски
[22:42.100 --> 22:44.100]  точнее доска есть
[22:44.100 --> 22:46.100]  маркеров нет
[22:46.100 --> 22:48.100]  а подождите
[22:48.100 --> 22:50.100]  маркеры есть
[22:50.100 --> 22:52.100]  так маркеров нет
[22:52.100 --> 22:54.100]  вот 22 штуки
[22:56.100 --> 22:58.100]  о
[23:00.100 --> 23:02.100]  следующий шаг
[23:02.100 --> 23:04.100]  дай первую
[23:04.100 --> 23:06.100]  теперь точно
[23:06.100 --> 23:08.100]  давай
[23:08.100 --> 23:10.100]  а почему
[23:10.100 --> 23:12.100]  и там
[23:12.100 --> 23:14.100]  а
[23:14.100 --> 23:16.100]  блин ладно мне тогда
[23:16.100 --> 23:18.100]  жалко как-то их тратить
[23:18.100 --> 23:20.100]  нет давайте поступим
[23:20.100 --> 23:22.100]  иначе
[23:22.100 --> 23:24.100]  я их просто заберу и не ударю
[23:24.100 --> 23:30.460]  Блин, как бы нам поступить-то.
[23:30.460 --> 23:37.860]  Мне, ну давайте я, значит, временно выключу экран.
[23:37.860 --> 23:41.340]  Сейчас я вам открою cpp-референс.
[23:41.340 --> 23:46.020]  Да, Господи, что происходит.
[24:17.020 --> 24:21.020]  Смотрите, что позволяет fold expression.
[24:21.020 --> 24:24.020]  Во-первых, они обязательно должны в скобочках писаться.
[24:24.020 --> 24:30.020]  Значит, это просто требование такое, иначе бы компилятор не мог распарсить синтаксис.
[24:30.020 --> 24:33.020]  Нужно обязательно в круглых скобочках писать.
[24:33.020 --> 24:42.020]  И как это пишется? Вы говорите пакет, дальше некоторая бинарная операция, дальше многоточие, ну и всё.
[24:42.020 --> 24:48.020]  Значит, либо многоточие, бинарная операция и пакет.
[24:48.020 --> 24:50.020]  И всё это в скобочках.
[24:50.020 --> 24:57.020]  То есть вы должны бинарным оператором соединить пакет и многоточие.
[24:57.020 --> 25:00.020]  И в скобке это взять.
[25:00.020 --> 25:04.020]  Тогда у вас получится...
[25:04.020 --> 25:06.020]  Третью, четвёртую версию мы потом рассмотрим.
[25:06.020 --> 25:08.020]  Вот смотрите, как...
[25:08.020 --> 25:10.020]  Explanation, кто хотел объяснений?
[25:10.020 --> 25:11.020]  Смотрите объяснение.
[25:11.020 --> 25:13.020]  Вот тебе объяснение.
[25:13.020 --> 25:15.020]  Значит, что происходит?
[25:15.020 --> 25:18.020]  Во что компилятор это превращает?
[25:18.020 --> 25:25.020]  Инстанцирование fold expression, ну то есть шаблонная подстановка, превращает это в следующую вещь.
[25:25.020 --> 25:37.020]  Если у вас вот так написано, то есть если написано пакет оператор многоточие, то вот это превращается вот в это.
[25:37.020 --> 25:47.020]  Ну, вот пакет разворачивается на E1 и так далее, E1 и...
[25:47.020 --> 25:56.020]  Получается правоассоциативное вот такое вычисление этого оператора бинарного над всем пакетом.
[25:56.020 --> 26:02.020]  Left fold, значит, превращается в левоассоциативное вот такое выражение.
[26:02.020 --> 26:04.020]  Теперь дальше интересней.
[26:04.020 --> 26:08.020]  Можно сделать вот такую штуку.
[26:08.020 --> 26:14.020]  Можно сделать пакет...
[26:14.020 --> 26:18.020]  Вот сейчас я функцию print напишу с помощью fold expression.
[26:18.020 --> 26:22.020]  Simplate type name многоточие.
[26:22.020 --> 26:29.020]  Ну, мне здесь не надо называть его tail, потому что у меня всего, значит...
[26:29.020 --> 26:32.020]  Я вот так напишу, да, types просто.
[26:34.020 --> 26:37.020]  Нет, головы.
[26:37.020 --> 26:39.020]  Types.
[26:39.020 --> 26:44.020]  Значит, что сделать?
[26:44.020 --> 26:49.020]  Ну, void print от const types много...
[26:49.020 --> 26:53.020]  Ampersand многоточие types.
[26:53.020 --> 27:02.020]  И тут я пишу std seout многоточие пакет.
[27:02.020 --> 27:05.020]  И все это в скобочках обязательно.
[27:16.020 --> 27:17.020]  Вот.
[27:17.020 --> 27:20.020]  Ну, сейчас, правда, они без пробелов будут напечатаны.
[27:20.020 --> 27:22.020]  Значит, std seout...
[27:22.020 --> 27:24.020]  Тут не надо уже std seout.
[27:24.020 --> 27:28.020]  Print 1, 2, 3, 4.
[27:28.020 --> 27:30.020]  А это я закомментирую.
[27:30.020 --> 27:32.020]  Давайте посмотрим, что получится.
[27:32.020 --> 27:34.020]  А получится...
[27:34.020 --> 27:37.020]  Ну, надо std plus 17 добавить.
[27:37.020 --> 27:39.020]  Ну, вот напечаталось 1, 2, 3, 4.
[27:39.020 --> 27:40.020]  Как это сработало?
[27:40.020 --> 27:44.020]  А это я применил третью...
[27:44.020 --> 27:47.020]  Это я применил третью...
[27:47.020 --> 27:48.020]  Виноват.
[27:48.020 --> 27:51.020]  Четвертую версию fold expression.
[27:51.020 --> 27:55.020]  Инициализатор, оператор многоточия, оператор пакет.
[27:55.020 --> 27:59.020]  То есть я могу в скобочках написать...
[27:59.020 --> 28:03.020]  Вот такое.
[28:03.020 --> 28:10.020]  Я могу не просто пакет с бинарным оператором соединить с многоточием,
[28:10.020 --> 28:16.020]  а я могу многоточие соединить бинарными операторами с двух сторон.
[28:16.020 --> 28:19.020]  С одной стороны с пакетом, а с другой стороны с каким-то начальным значением.
[28:19.020 --> 28:26.020]  И получится, что у меня это развернется вот в такое.
[28:27.020 --> 28:31.020]  Ну, в моем случае это развернулось вот в такое.
[28:31.020 --> 28:34.020]  То есть левая ассоциативность произошла.
[28:34.020 --> 28:39.020]  У меня, поскольку инциализатор слева, то это разворачивается вот в такое.
[28:39.020 --> 28:41.020]  Скобки сначала вот вокруг этого.
[28:41.020 --> 28:43.020]  То есть t-out, первый элемент пакета.
[28:43.020 --> 28:49.020]  Потом снова двойной, значит, побитый сдвиг.
[28:49.020 --> 28:51.020]  Второй элемент пакета и так далее.
[28:51.020 --> 28:54.020]  Таким образом это все превратилось в std c-out.
[28:54.020 --> 28:57.020]  И один там, и так далее.
[29:04.020 --> 29:06.020]  Они должны быть одинаковыми, да.
[29:06.020 --> 29:07.020]  Чего ты так говоришь?
[29:09.020 --> 29:13.020]  Человек руку поднимал, и вот вы его перебивает.
[29:24.020 --> 29:29.020]  Не ретерна, просто вывести, и там пробел, вот стрелочка, и так далее.
[29:29.020 --> 29:31.020]  То есть это как текст разворачивается, или как что-то более существенное?
[29:31.020 --> 29:35.020]  Нет, это разворачивается, ну как, это expression.
[29:35.020 --> 29:39.020]  Вы должны, это превратится в некоторые expression в compile-time.
[29:39.020 --> 29:41.020]  Это шаблон expression, можно сказать.
[29:41.020 --> 29:42.020]  Хорошо, вопрос такой.
[29:42.020 --> 29:43.020]  Сработает ли следующая конструкция?
[29:43.020 --> 29:49.020]  Если мы напишем t-out, дальше две скобочки, в таком скобочке скобочки открываются,
[29:49.020 --> 29:51.020]  дальше внутри фолдер спрашивает следующего вида.
[29:51.020 --> 29:56.020]  Пробельный символ, вывод, мы готовы.
[29:56.020 --> 29:58.020]  Давай просто напишем что-то.
[29:58.020 --> 30:01.020]  Можно t-out за скобки вынести, заменив его на пробел.
[30:01.020 --> 30:03.020]  У нас же сейчас пробелов нет.
[30:03.020 --> 30:07.020]  Не понимаю, скажи мне буквально, что написать надо?
[30:07.020 --> 30:11.020]  С t-d-c-out, так.
[30:11.020 --> 30:13.020]  Дальше, дальше скобочка, фолд экспреш.
[30:13.020 --> 30:14.020]  Так.
[30:14.020 --> 30:16.020]  Тут пробел.
[30:16.020 --> 30:17.020]  Дальше...
[30:17.020 --> 30:19.020]  Тогда он у тебя будет визит раздвигать чару.
[30:19.020 --> 30:21.020]  Ча, подожди, ну пробел, что дальше?
[30:21.020 --> 30:25.020]  Ну он же будет понять, что, ну и дальше все то же самое.
[30:25.020 --> 30:27.020]  Он тебе будет прибавить пробел, а я бы...
[30:27.020 --> 30:31.020]  А, ну правильно, у тебя будет побитовый сдвиг применяться к чару и к...
[30:31.020 --> 30:33.020]  Ну к фолд экспрешу, ну хорошо, если это все.
[30:33.020 --> 30:35.020]  Смотрите, фолд экспреш на чате.
[30:35.020 --> 30:37.020]  Если еще раз t-out, эту штуку в скобку взять.
[30:37.020 --> 30:39.020]  Черт возьми.
[30:39.020 --> 30:40.020]  Нужно вводить пробел.
[30:40.020 --> 30:43.020]  У тебя вот есть фолд экспреш, который...
[30:43.020 --> 30:45.020]  Хорошо, есть у нас их два, то как бы, ну...
[30:45.020 --> 30:47.020]  Беремся, как бы сделать битвный сдвиг.
[30:47.020 --> 30:49.020]  Как сделать пробел, проще сказать.
[30:49.020 --> 30:50.020]  Так, хорошо, пробел.
[30:50.020 --> 30:52.020]  Как, как вывести их через пробел?
[30:54.020 --> 30:56.020]  Возможно никак.
[30:57.020 --> 30:58.020]  Есть мою камеру.
[30:58.020 --> 31:01.020]  Для таких вещей, ну, ну, а вот придумайте как.
[31:01.020 --> 31:03.020]  Вот, вот у вас есть формальный синтаксис.
[31:03.020 --> 31:05.020]  Вот вам сказано, какие операторы разрешены.
[31:05.020 --> 31:07.020]  Можно писать свой бинарный...
[31:07.020 --> 31:10.020]  In a binary fold both ops must be the same.
[31:10.020 --> 31:12.020]  Свой оператор выводы.
[31:12.020 --> 31:15.020]  А, вот такие операторы разрешены использовать.
[31:15.020 --> 31:18.020]  Кстати, точку со звездочкой и стрелочку со звездочкой можно.
[31:18.020 --> 31:20.020]  Очень полезно.
[31:20.020 --> 31:23.020]  А можно в деле что-то создать строку, там, чтобы...
[31:23.020 --> 31:28.020]  Нет, с плюс равно многоточие и с плюс равно types и вывести вот это.
[31:28.020 --> 31:30.020]  А...
[31:30.020 --> 31:33.020]  С плюс равно многоточие, плюс равно...
[31:34.020 --> 31:35.020]  И что?
[31:35.020 --> 31:37.020]  А как пробел ты добавишь?
[31:37.020 --> 31:39.020]  А пробел как...
[31:39.020 --> 31:42.020]  Вопрос в том, как добавить пробелы в эту конструкцию.
[31:42.020 --> 31:46.020]  Ну, чтобы добавить пробелы, пробелы добавить можно.
[31:46.020 --> 31:48.020]  Смотрите.
[31:48.020 --> 31:50.020]  У меня есть замечательный оператор.
[31:50.020 --> 31:51.020]  Мой любимый оператор.
[31:51.020 --> 31:53.020]  Кто знает мой любимый оператор?
[31:53.020 --> 31:55.020]  Давайте, к концу семестра надо знать.
[31:55.020 --> 31:57.020]  Оператор запятая, правильно.
[31:57.020 --> 31:58.020]  Вот ты хорошо лекции слушал.
[31:58.020 --> 32:00.020]  Знаешь, любимый оператор электрона.
[32:00.020 --> 32:01.020]  Вот, смотри.
[32:01.020 --> 32:03.020]  Используем любимый оператор.
[32:04.020 --> 32:07.020]  Значит, любимый оператор или мщельная.
[32:07.020 --> 32:08.020]  Запятая.
[32:08.020 --> 32:09.020]  Что мы делаем?
[32:09.020 --> 32:10.020]  Мы говорим...
[32:13.020 --> 32:15.020]  Значит...
[32:15.020 --> 32:17.020]  Я говорю...
[32:25.020 --> 32:26.020]  Сейчас.
[32:26.020 --> 32:27.020]  Ну да.
[32:27.020 --> 32:28.020]  Я говорю вот так.
[32:28.020 --> 32:30.020]  И многоточие.
[32:30.020 --> 32:31.020]  Чего?
[32:31.020 --> 32:32.020]  Сейчас.
[32:32.020 --> 32:34.020]  По-моему, вот так я должен просто сказать.
[32:34.020 --> 32:36.020]  Давайте проверим, что я правильно.
[32:40.020 --> 32:42.020]  Да, значит, бинарное выражение не работает.
[32:42.020 --> 32:44.020]  Сейчас, подождите, дайте.
[32:44.020 --> 32:47.020]  А может запятую в крылые скобки взять?
[32:50.020 --> 32:52.020]  Нет, ну правильно, да.
[32:52.020 --> 32:54.020]  Сейчас, сейчас, сейчас.
[32:56.020 --> 32:58.020]  Мне надо, чтобы...
[32:58.020 --> 32:59.020]  Что было?
[32:59.020 --> 33:02.020]  Мне надо, чтобы эта штука...
[33:04.020 --> 33:06.020]  Развернулась в...
[33:08.020 --> 33:10.020]  Бинарное...
[33:20.020 --> 33:22.020]  Что может быть пакетом?
[33:22.020 --> 33:23.020]  Вот здесь написано.
[33:23.020 --> 33:25.020]  Что подразумевается под словом pack?
[33:25.020 --> 33:28.020]  Это выражение, которое содержит неразвернутый пакет
[33:28.020 --> 33:33.020]  и не содержит оператора с приоритетом ниже, чем каст.
[33:33.020 --> 33:35.020]  На верхнем уровне.
[33:36.020 --> 33:37.020]  Ага.
[33:37.020 --> 33:39.020]  То есть...
[33:41.020 --> 33:43.020]  То есть, то есть, то есть...
[33:44.020 --> 33:46.020]  Возможно мне поможет...
[33:47.020 --> 33:50.020]  Так, а если я еще вот это в скобке возьму?
[33:50.020 --> 33:51.020]  Что мне не поможет?
[33:51.020 --> 33:52.020]  Мне это случайно.
[33:52.020 --> 33:54.020]  А у каста может что?
[33:55.020 --> 33:57.020]  Вот теперь помогло, да.
[34:00.020 --> 34:02.020]  Да, вот теперь работает.
[34:04.020 --> 34:07.020]  Что делать, если я уже не хочу знать почему?
[34:10.020 --> 34:11.020]  Да, ну смотрите.
[34:11.020 --> 34:15.020]  Я могу в качестве пакета подставлять
[34:15.020 --> 34:18.020]  не обязательно просто пакет сам по себе,
[34:18.020 --> 34:21.020]  а некоторые выражения, содержащие пакет.
[34:21.020 --> 34:22.020]  Да, да, да.
[34:22.020 --> 34:25.020]  Но, да, я подставляю выражение, содержащие пакет.
[34:25.020 --> 34:27.020]  Правда, здесь есть формальное ограничение.
[34:27.020 --> 34:30.020]  Вот не знаю, из-за чего оно такое.
[34:30.020 --> 34:34.020]  Надо, чтобы в этом выражении на верхнем уровне...
[34:35.020 --> 34:40.020]  На верхнем уровне не было оператора с приоритетом ниже, чем каст.
[34:41.020 --> 34:45.020]  Ну, что такое оператор с приоритетом ниже, чем каст?
[34:45.020 --> 34:48.020]  Ну, это значит...
[34:48.020 --> 34:50.020]  Все вот эти операторы.
[34:50.020 --> 34:53.020]  На верхнем уровне у меня был вот такой оператор,
[34:53.020 --> 34:55.020]  побитый в издвиг, он его не устраивал.
[34:55.020 --> 35:00.020]  Но, взятие выражения в скобке поднимает ему приоритет
[35:00.020 --> 35:06.020]  до уровня каста, поэтому все нормально становится.
[35:09.020 --> 35:11.020]  А вот это, по-моему, он и есть.
[35:11.020 --> 35:14.020]  Ну, короче, когда я беру выражение в скобке,
[35:14.020 --> 35:17.020]  то это сразу считается, что это выражение
[35:17.020 --> 35:21.020]  формально становится как бы каст-экспрешен, по-моему.
[35:21.020 --> 35:25.020]  Ну, не систейл, оно называется каст-экспрешен,
[35:25.020 --> 35:27.020]  но по стандарту выражение в скобках...
[35:27.020 --> 35:30.020]  Ну, по стандарту, когда компилятор парсит выражение,
[35:30.020 --> 35:33.020]  у него...
[35:33.020 --> 35:37.020]  Как приоритет операторов вообще в стандарте прописан?
[35:37.020 --> 35:39.020]  Он просто разбивает выражение на подтипы,
[35:39.020 --> 35:41.020]  и как синтоксическое дерево строится, как выражение.
[35:41.020 --> 35:45.020]  Это вот такое выражение, бинарный оператор нижнего уровня,
[35:45.020 --> 35:47.020]  это выражение второго уровня.
[35:47.020 --> 35:51.020]  Вот мне надо, чтобы выражение было выражением вот этого уровня не ниже.
[35:51.020 --> 35:55.020]  Но я просто взял скобки дополнительные поставил, и все получилось.
[36:07.020 --> 36:10.020]  Короче, компилятору надо, чтобы левым аргументом,
[36:10.020 --> 36:14.020]  чтобы бинарный оператор связывал, скажем так, унарное выражение
[36:14.020 --> 36:19.020]  содержащие пакет и многоточие с другой стороны.
[36:26.020 --> 36:29.020]  И эта штука распаковывается в следующую штуку.
[36:29.020 --> 36:33.020]  Стд си аут тайп 1, типа пробел,
[36:33.020 --> 36:39.020]  через запятую перечисляются стд си аут, вот эта штука, пробел.
[36:39.020 --> 36:46.020]  И это, значит, ему говорят, повтори через запятую вот эту конструкцию.
[36:46.020 --> 36:52.020]  Но он ставит ограничение, что он может только унарную конструкцию повторять через запятую.
[36:52.020 --> 36:57.020]  Если здесь какая-то штука, какой-то оператор используется с приоритетом ниже, чем вот это,
[36:57.020 --> 37:01.020]  то он отказывается это разворачивать, он говорит, я не понимаю.
[37:01.020 --> 37:04.020]  И поэтому ему надо, чтобы здесь были скобки дополнительные,
[37:04.020 --> 37:09.020]  чтобы он считал это как бы унарным выражением с одним аргументом.
[37:09.020 --> 37:14.020]  И он через запятую повторяет это выражение для всех types.
[37:17.020 --> 37:22.020]  Вот, давайте я здесь, вот.
[37:22.020 --> 37:25.020]  Просто генерал-оператор пытается возвращать то, что стоит справа.
[37:25.020 --> 37:27.020]  То, что стоит справа, да.
[37:27.020 --> 37:30.020]  То есть у нас сейчас си век с первого типа.
[37:30.020 --> 37:32.020]  У нас сейчас что?
[37:32.020 --> 37:36.020]  А, у нас сейчас, да, у нас сейчас, да, первого типа.
[37:36.020 --> 37:38.020]  Fold expression.
[37:38.020 --> 37:46.020]  Вот, смотрите, вот давайте я здесь в этой сумме поставлю результатом int
[37:46.020 --> 37:51.020]  и потребую, чтобы все эти штуки были типа int.
[37:51.020 --> 37:54.020]  Вот, еще одно упражнение.
[37:54.020 --> 37:57.020]  На фолду экспрессии у нас переглянцы.
[37:57.020 --> 38:00.020]  Все эти штуки были типа int.
[38:00.020 --> 38:04.020]  Вот, еще одно упражнение на понимание fold expression.
[38:04.020 --> 38:12.020]  Я хочу написать static assert на то, что все типы равны int.
[38:12.020 --> 38:16.020]  Нет, здесь не нужно будет оператор запятая.
[38:16.020 --> 38:23.020]  Оператор можно из самим и через двойной, ну, два имперсанта в логической эдитер.
[38:23.020 --> 38:25.020]  Да, fold expression с логической мы.
[38:25.020 --> 38:36.020]  Смотрите, static assert, std is, ну, конечно, я выражение пишу, std is same way,
[38:36.020 --> 38:44.020]  types запятая int и многоточие.
[38:44.020 --> 38:51.020]  Что?
[38:51.020 --> 39:01.020]  Ну, у тебя будет is same way type 1 int и is same way, а все это compile time вычтемые штуки.
[39:01.020 --> 39:04.020]  Я, правда, возможно, здесь нужны внутренние скобки.
[39:04.020 --> 39:09.020]  Сейчас.
[39:09.020 --> 39:12.020]  Ну, два имперсанта.
[39:12.020 --> 39:14.020]  Теперь работает.
[39:14.020 --> 39:20.020]  Потому что нужны внутренние скобки, потому что fold expression сам по себе должен в скобках быть.
[39:20.020 --> 39:21.020]  Обязательно.
[39:21.020 --> 39:26.020]  Static assert, одни скобки от static assert, а внутренние скобки от fold expression.
[39:26.020 --> 39:30.020]  Поэтому двойные скобки здесь должны быть, тогда работают.
[39:30.020 --> 39:33.020]  А как вызвать для всех функцию, которые вращаются тогда?
[39:33.020 --> 39:38.020]  Если я сейчас вот здесь делаю unsigned какой-нибудь из аргументов.
[39:38.020 --> 39:40.020]  Ой, здесь-то как раз нормально.
[39:40.020 --> 39:47.020]  Вот если я здесь делаю, допустим, std seout вот так, один unsigned, то будет ce,
[39:47.020 --> 39:52.020]  со словами static assertion вот этот вот failed.
[39:52.020 --> 39:53.020]  Что, как сделать?
[39:53.020 --> 39:54.020]  Подожди.
[39:54.020 --> 39:59.020]  Функцию, которая вызывает void, возвращает void для всех этих типов.
[39:59.020 --> 40:01.020]  Значит void для всех этих типов.
[40:01.020 --> 40:07.020]  Как вызвать для всего этого пакета, для каждого его элемента, функцию, которая возвращает void?
[40:07.020 --> 40:09.020]  Так через запятую, вот, пожалуйста.
[40:09.020 --> 40:12.020]  А void может принимать void?
[40:12.020 --> 40:16.020]  Запятая вообще без разницы, что принимать ей.
[40:16.020 --> 40:20.020]  Запятая просто вычисляет выражение по порядку.
[40:20.020 --> 40:22.020]  Чего ты, Горик, хотел?
[40:22.020 --> 40:24.020]  Это, конечно, мало имеет смысла.
[40:24.020 --> 40:26.020]  Кажется, штука работает за квадратом.
[40:26.020 --> 40:30.020]  В каждом экземпляре функ.sum будет вызывать статик assertProject.
[40:30.020 --> 40:32.020]  Правда или нет?
[40:32.020 --> 40:35.020]  Кажется, он не будет вызывать.
[40:41.020 --> 40:45.020]  Да, здесь ему не придется генерировать много версий функции.
[40:47.020 --> 40:51.020]  Да, потому что я здесь не использую рекурсивные вызовы с меньшим количеством аргументов.
[40:51.020 --> 40:55.020]  Здесь, по факту, ему удастся обойтись лишь одной версией sum.
[40:55.020 --> 40:58.020]  То есть, по поводу спрашивания, не генерировать рекурсивные вызовы в елице?
[40:58.020 --> 41:01.020]  Да, мы просто обходимся одной.
[41:01.020 --> 41:04.020]  Стоп, мы же больше нигде не подписали sum.
[41:04.020 --> 41:06.020]  Так я нигде не вызываю sum от меньшего числа аргументов.
[41:06.020 --> 41:09.020]  Я вызываю sum только от такого числа аргументов.
[41:09.020 --> 41:12.020]  В каком месте ему потребуется sum от меньшего числа аргументов?
[41:12.020 --> 41:15.020]  В каком месте можно аргументом принимать динарную операцию?
[41:15.020 --> 41:17.020]  Чего? Чего еще раз?
[41:17.020 --> 41:19.020]  Он принимает аргументом динарную операцию.
[41:19.020 --> 41:21.020]  Что?
[41:21.020 --> 41:23.020]  Fold expression?
[41:23.020 --> 41:25.020]  Кто? Ничего не понимаю.
[41:25.020 --> 41:27.020]  Fold expression это вот такая синтоксическая конструкция.
[41:27.020 --> 41:29.020]  Еще раз.
[41:29.020 --> 41:34.020]  Бинарный оператор, от которого с одной стороны стоит ноготочие, а слева унарное некоторое выражение содержащий пакет.
[41:34.020 --> 41:37.020]  Они все 32 случая ручками прописали.
[41:37.020 --> 41:40.020]  Они сделали функцию, которая принимает динарную операцию.
[41:40.020 --> 41:43.020]  Они это делали на ассемблере, как что-то важное?
[41:44.020 --> 41:49.020]  Нет, они это делали не на ассемблере, а на языке внутреннего представления компилятора.
[41:49.020 --> 41:52.020]  Слушай, ну когда...
[41:52.020 --> 41:57.020]  А вообще у тебя не возникает вопрос, как компилятор парсит выражение?
[41:57.020 --> 42:01.020]  Они что, все операторы ручками прописали, что такой оператор надо парсить так, а такой так?
[42:01.020 --> 42:03.020]  Ну да.
[42:03.020 --> 42:05.020]  Что тебя в этом смущает? А как?
[42:05.020 --> 42:07.020]  По-твоему, компилятор есть интуиция.
[42:07.020 --> 42:10.020]  А, это бинарный оператор, его надо парсить так.
[42:10.020 --> 42:13.020]  Ты стандарт видел? Открой стандарт к главу expressions.
[42:13.020 --> 42:16.020]  Ты увидишь, как компилятор парсит выражение.
[42:16.020 --> 42:20.020]  А бинарный оператор нельзя принимать просто так вообще?
[42:20.020 --> 42:23.020]  Я не понимаю, что значит принимать бинарный оператор.
[42:23.020 --> 42:26.020]  Есть просто вот такой синтакс, и все.
[42:26.020 --> 42:31.020]  Так, наверное, это все, что я хотел сказать по этому поводу.
[42:31.020 --> 42:35.020]  А, ну не совсем. Вот еще знаете что?
[42:35.020 --> 42:38.020]  Давайте еще вот такую штуку вам покажу.
[42:38.020 --> 42:43.020]  Вы же понимаете, что можно...
[42:47.020 --> 42:54.020]  Значит, например, сделать что-нибудь такое.
[42:54.020 --> 42:56.020]  Инт.
[42:59.020 --> 43:01.020]  Не знаю. Чек.
[43:07.020 --> 43:14.020]  Вот. И, ну, например, написать статик, ассерт.
[43:14.020 --> 43:19.020]  Значит, numbers многоточие.
[43:19.020 --> 43:26.020]  Значит, numbers плюс многоточие, там, равно 10.
[43:30.020 --> 43:32.020]  Не знаю, я какую фигню написал.
[43:32.020 --> 43:35.020]  Ну, даже не, даже не знаю.
[43:35.020 --> 43:37.020]  Ну, даже не знаю.
[43:37.020 --> 43:39.020]  Ну, даже не знаю.
[43:39.020 --> 43:41.020]  Ну, даже не знаю.
[43:41.020 --> 43:43.020]  Не знаю, я какую фигню написал.
[43:43.020 --> 43:46.020]  Ну, даже не, даже не int.check.
[43:46.020 --> 43:49.020]  О, смотрите, struct.check.
[43:49.020 --> 43:52.020]  Я могу статик ассерт писать в любых местах,
[43:52.020 --> 43:55.020]  не обязательно в функциях.
[43:55.020 --> 43:58.020]  Я могу статик ассерт внутри структуры написать.
[43:58.020 --> 44:02.020]  Вот, смотрите, я написал внутри структуры,
[44:02.020 --> 44:04.020]  у которой имеют переменное количество шаблонных
[44:04.020 --> 44:09.020]  аргументов int, статик ассерт, что сумма этих int равна 10.
[44:09.020 --> 44:11.020]  Теперь могу дописать.
[44:11.020 --> 44:14.020]  Check, 1, 2, 3, 4.
[44:18.020 --> 44:19.020]  Вот.
[44:23.020 --> 44:24.020]  Вот.
[44:24.020 --> 44:27.020]  И это будет просто compile-time-проверка,
[44:27.020 --> 44:30.020]  что сумма вот этих вот чисел равна 10.
[44:32.020 --> 44:35.020]  Ну, вот эта compile-time-проверка не прошла, да.
[44:36.020 --> 44:37.020]  Что?
[44:44.020 --> 44:49.020]  Нет, потому что в этот раз у меня нет рекурсивных вызовов.
[44:53.020 --> 44:56.020]  Там раньше у меня был head, и потом я вызывал,
[44:56.020 --> 44:58.020]  у меня head-ом ставилась следующая штука,
[44:58.020 --> 45:00.020]  а тут у меня нет рекурсивных вызовов,
[45:00.020 --> 45:02.020]  все types нужно сразу проверить, что они intы.
[45:05.020 --> 45:07.020]  Сразу несколько типов выходят.
[45:10.020 --> 45:11.020]  Ну да.
[45:11.020 --> 45:13.020]  Types это пакет.
[45:13.020 --> 45:15.020]  Зачем ему вообще type тогда?
[45:15.020 --> 45:16.020]  Чего? Кому?
[45:16.020 --> 45:17.020]  Ну, пакету.
[45:17.020 --> 45:19.020]  Что значит зачем type пакету?
[45:19.020 --> 45:21.020]  Зачем стол мухи?
[45:21.020 --> 45:23.020]  Я не понимаю, какая это вообще...
[45:23.020 --> 45:25.020]  Мы писали type-name-types.
[45:25.020 --> 45:26.020]  Ну?
[45:26.020 --> 45:29.020]  И мы давали пакету какой-то type.
[45:29.020 --> 45:31.020]  Что значит давать?
[45:32.020 --> 45:35.020]  Мы не давали пакету type.
[45:35.020 --> 45:38.020]  Пакет – это сущность, это не тип.
[45:38.020 --> 45:41.020]  Пакет – это другой вид сущности.
[45:51.020 --> 45:53.020]  Types – это не тип, Types – это пакет.
[45:53.020 --> 45:56.020]  Сейчас Types с большой буквы – это пакет типов,
[45:56.020 --> 45:59.020]  а Types с маленькой буквы – это пакет аргументов.
[45:59.020 --> 46:02.020]  У пакета нету никакого типа.
[46:02.020 --> 46:04.020]  Вот когда вы его распаковали,
[46:04.020 --> 46:06.020]  тогда можно...
[46:06.020 --> 46:07.020]  У...
[46:07.020 --> 46:08.020]  Распакован...
[46:08.020 --> 46:10.020]  Ну, про распакованные элементы пакета имеет смысл
[46:10.020 --> 46:12.020]  спрашивать, какой у них тип.
[46:14.020 --> 46:15.020]  Мы с ней...
[46:15.020 --> 46:17.020]  Да, но мы над ней можем выполнять
[46:17.020 --> 46:19.020]  только операции compile-time,
[46:19.020 --> 46:21.020]  выполнимые над пакетами.
[46:21.020 --> 46:23.020]  В данном случае мы над ней применяем...
[46:23.020 --> 46:25.020]  Мы к ней применяем fold expression.
[46:25.020 --> 46:27.020]  Мы над ней можем делать распаковку,
[46:27.020 --> 46:29.020]  то есть просто многоточие.
[46:29.020 --> 46:31.020]  Можем делать сайзов многоточие от нее,
[46:31.020 --> 46:34.020]  а можем делать fold expression еще над ней.
[46:34.020 --> 46:38.020]  Она разворачивается в список нормальных аргументов,
[46:38.020 --> 46:40.020]  и вот про них, про каждую уже отдельно,
[46:40.020 --> 46:42.020]  имеет смысл какую-то другую операцию сделать.
[46:42.020 --> 46:44.020]  А с пакетом все, что можно делать,
[46:44.020 --> 46:46.020]  только распаковывать разными способами,
[46:46.020 --> 46:48.020]  вот, например, таким.
[46:48.020 --> 46:49.020]  Хорошо.
[46:49.020 --> 46:51.020]  Types большое – это...
[46:51.020 --> 46:53.020]  Сейчас.
[46:53.020 --> 46:55.020]  Почему нам нельзя фориком пробежаться
[46:55.020 --> 46:57.020]  по элементу пакета?
[46:57.020 --> 46:59.020]  Синтаксически так решил...
[46:59.020 --> 47:01.020]  Ну, так решил комитет.
[47:01.020 --> 47:03.020]  Я не знаю, в чем смысл такого допера.
[47:03.020 --> 47:05.020]  Непонятно, как это...
[47:05.020 --> 47:07.020]  В разной типу можно...
[47:07.020 --> 47:09.020]  Как это вообще ты представляешь себе?
[47:09.020 --> 47:11.020]  Что значит фориком прибежаться?
[47:11.020 --> 47:13.020]  Как это синтаксически должно записываться?
[47:13.020 --> 47:16.020]  For out of queue – это вообще пакет.
[47:16.020 --> 47:19.020]  А, for для каждого элемента...
[47:19.020 --> 47:23.020]  Хорошо, это будет копирование или что?
[47:23.020 --> 47:25.020]  Ну, видимо, если не ссылка,
[47:25.020 --> 47:27.020]  то копирование, да?
[47:27.020 --> 47:29.020]  Да, если ссылка, то не копирование.
[47:29.020 --> 47:31.020]  Констакт с фор какой-нибудь...
[47:33.020 --> 47:35.020]  Ну, не добавили,
[47:35.020 --> 47:37.020]  не ввели такого, да,
[47:37.020 --> 47:39.020]  не знаю почему.
[47:39.020 --> 47:41.020]  То есть, вот эта же операция – это, по идее,
[47:41.020 --> 47:43.020]  форик по элементам пакета?
[47:43.020 --> 47:45.020]  Ну, в каком-то смысле да.
[47:45.020 --> 47:47.020]  Блин, а вот прикол,
[47:47.020 --> 47:49.020]  если сейчас оно скомпилируется,
[47:49.020 --> 47:51.020]  если я так напишу.
[47:52.020 --> 47:54.020]  Что, что нельзя?
[47:54.020 --> 47:56.020]  Фор по пакету нельзя делать.
[47:56.020 --> 47:58.020]  А for after – нет?
[47:58.020 --> 48:00.020]  Мы про это и говорим. Нет, нельзя так делать.
[48:00.020 --> 48:03.020]  Я не убрал лимит на размер функции,
[48:03.020 --> 48:05.020]  он у вас 30 до 40 изменил.
[48:07.020 --> 48:09.020]  Сможете поделиться?
[48:09.020 --> 48:11.020]  Ну, надо поговорить.
[48:11.020 --> 48:13.020]  Я не знаю, там какие-то...
[48:13.020 --> 48:15.020]  Надо посмотреть, что там за ограничения.
[48:15.020 --> 48:17.020]  Может быть...
[48:17.020 --> 48:19.020]  Так, давайте последнее,
[48:19.020 --> 48:21.020]  что там вы хотели спросить,
[48:21.020 --> 48:23.020]  и идем дальше.
[48:23.020 --> 48:25.020]  Да.
[48:25.020 --> 48:27.020]  Подождите, потом обсудите.
[48:33.020 --> 48:35.020]  Параметр пак с конкретным типом – нет.
[48:35.020 --> 48:37.020]  Почему? Шаблон может быть,
[48:37.020 --> 48:39.020]  хоть, пожалуйста, функция с таким же...
[48:39.020 --> 48:41.020]  Да.
[48:41.020 --> 48:43.020]  Конечно, конечно.
[48:45.020 --> 48:47.020]  Ну.
[48:49.020 --> 48:51.020]  C, E – это не константное выражение.
[48:53.020 --> 48:55.020]  Но ведь тип X константный.
[48:57.020 --> 48:59.020]  Так, и same ты чем...
[48:59.020 --> 49:01.020]  Так, подожди.
[49:01.020 --> 49:03.020]  И same ты от чего вызываешь?
[49:03.020 --> 49:05.020]  От XA и NTA.
[49:05.020 --> 49:07.020]  X – это не тип.
[49:07.020 --> 49:09.020]  И same можно сравнивать типы, а не переменные.
[49:09.020 --> 49:11.020]  Вы же вызывали от type A.
[49:11.020 --> 49:13.020]  Нет, я вызывал от типа.
[49:15.020 --> 49:17.020]  И same – это шаблон, у которого
[49:17.020 --> 49:19.020]  шаблонный аргумент является типы.
[49:19.020 --> 49:21.020]  Ты должен типы передать в шаблон.
[49:21.020 --> 49:23.020]  Ну.
[49:25.020 --> 49:27.020]  Это пакет типов.
[49:27.020 --> 49:29.020]  Да, здесь можно использовать как
[49:29.020 --> 49:31.020]  пакет типов, так и пакет аргументов.
[49:35.020 --> 49:37.020]  Да, пакет типов разворачивается
[49:37.020 --> 49:39.020]  через амперсант.
[49:39.020 --> 49:41.020]  Получается...
[49:41.020 --> 49:43.020]  Пакет можем использовать в нипсе и same way.
[49:43.020 --> 49:45.020]  Это же пакет, а не
[49:45.020 --> 49:47.020]  какой-то фиксированный.
[49:47.020 --> 49:49.020]  Потому что это fold expression.
[49:49.020 --> 49:51.020]  Потому же, почему я могу
[49:51.020 --> 49:53.020]  вот здесь использовать пакет.
[49:53.020 --> 49:55.020]  Это же пакет, а не фиксированный тип.
[49:55.020 --> 49:57.020]  Потому что это fold expression.
[49:57.020 --> 49:59.020]  Компилятор видит, что это fold expression
[49:59.020 --> 50:01.020]  и разворачивает его, пока компилирует.
[50:07.020 --> 50:09.020]  Вот. Если я здесь делаю
[50:09.020 --> 50:11.020]  1, 2, 3, 3, то будет
[50:11.020 --> 50:13.020]  CE со словами static assertion
[50:13.020 --> 50:15.020]  fail сумма не 10.
[50:15.020 --> 50:17.020]  Вот этот static assertion fail теперь.
[50:17.020 --> 50:19.020]  То есть вот эта
[50:19.020 --> 50:21.020]  compile time проверка, что сумма этих чисел
[50:21.020 --> 50:23.020]  равна 10. Все понятно, да?
[50:23.020 --> 50:25.020]  Отлично.
[50:25.020 --> 50:27.020]  Ну все.
[50:29.020 --> 50:31.020]  Значит, вот вам
[50:31.020 --> 50:33.020]  А как
[50:33.020 --> 50:35.020]  внутри чека вообще
[50:35.020 --> 50:37.020]  это вызываем функцию?
[50:37.020 --> 50:39.020]  Статик Assert
[50:39.020 --> 50:41.020]  можно писать
[50:41.020 --> 50:43.020]  это, я формально не знаю
[50:43.020 --> 50:45.020]  чем это является, но в общем
[50:45.020 --> 50:47.020]  это штука, которую можно писать в любом
[50:47.020 --> 50:49.020]  месте кода, хоть в
[50:49.020 --> 50:51.020]  Class Scope, хоть в Global Scope, хоть
[50:51.020 --> 50:53.020]  в
[50:53.020 --> 50:55.020]  Local Scope. То есть static assert
[50:55.020 --> 50:57.020]  ее смысл просто
[50:57.020 --> 50:59.020]  дойдя до сюда, сгенеряя ошибку
[50:59.020 --> 51:01.020]  компиляции, если условие нарушено.
[51:01.020 --> 51:03.020]  А если хорошо, то просто
[51:03.020 --> 51:05.020]  пропустить и идти дальше.
[51:05.020 --> 51:07.020]  Если хорошо, да, просто иди дальше.
[51:07.020 --> 51:09.020]  То есть можно писать
[51:09.020 --> 51:11.020]  A plus static assert B
[51:11.020 --> 51:13.020]  Нет, static assert
[51:13.020 --> 51:15.020]  это не expression, его нельзя
[51:15.020 --> 51:17.020]  подставлять. Результатом static assert
[51:17.020 --> 51:19.020]  ничего не вызвать.
[51:19.020 --> 51:21.020]  Что еще раз?
[51:21.020 --> 51:23.020]  Да нельзя static assert
[51:23.020 --> 51:25.020]  подставлять выражение,
[51:25.020 --> 51:27.020]  он ничего не возвращает.
[51:27.020 --> 51:29.020]  Я про то, что
[51:29.020 --> 51:31.020]  если static assert будет хорошо,
[51:31.020 --> 51:33.020]  то просто уберется A plus B.
[51:33.020 --> 51:35.020]  Нельзя static assert
[51:35.020 --> 51:37.020]  подставлять в expression,
[51:37.020 --> 51:39.020]  static assert это конструкция
[51:39.020 --> 51:41.020]  отдельно, самостоятельно.
[51:45.020 --> 51:47.020]  Нет, static assert
[51:47.020 --> 51:49.020]  можно писать только отдельно
[51:49.020 --> 51:51.020]  инструкцией, нельзя plus static assert
[51:51.020 --> 51:53.020]  делать, нельзя с результатом
[51:53.020 --> 51:55.020]  static assert делать ничего.
[51:55.020 --> 51:57.020]  В общем, если
[51:57.020 --> 51:59.020]  ленивая операция, например,
[51:59.020 --> 52:01.020]  он хочет ленивый плюс делать,
[52:01.020 --> 52:03.020]  не сладвал, если там произойдет ошибка
[52:03.020 --> 52:05.020]  в компиляции.
[52:05.020 --> 52:07.020]  Да, но если static assert выполнится, то он
[52:07.020 --> 52:09.020]  заменится на пустоту A plus B.
[52:15.020 --> 52:17.020]  Я не понял, давай
[52:17.020 --> 52:19.020]  ты потом подойдешь, скажешь
[52:19.020 --> 52:21.020]  про это.
[52:23.020 --> 52:25.020]  Все, господа,
[52:25.020 --> 52:27.020]  мы закончили главу шестую
[52:27.020 --> 52:29.020]  и пора начинать главу седьмую.
[52:31.020 --> 52:33.020]  Да, да, да.
[52:33.020 --> 52:35.020]  Мне шестой хватило.
[52:37.020 --> 52:39.020]  Нам надо с вами успеть
[52:39.020 --> 52:41.020]  пройти главу седьмую.
[52:41.020 --> 52:43.020]  Глава седьмая будет коротенькая и проста,
[52:43.020 --> 52:45.020]  и она будет последняя, которая войдет в зачет.
[52:49.020 --> 52:51.020]  Глава седьмая называется
[52:51.020 --> 52:53.020]  exceptions,
[52:53.020 --> 52:55.020]  исключения.
[53:01.020 --> 53:03.020]  Но тут я мог бы
[53:03.020 --> 53:05.020]  начать рисовать на доске,
[53:05.020 --> 53:07.020]  а у нас точно
[53:07.020 --> 53:09.020]  есть маркеры?
[53:09.020 --> 53:11.020]  Просто если есть, то я, наверное, лучше на доске
[53:11.020 --> 53:13.020]  порисую, тут мне особо писать ничего
[53:13.020 --> 53:15.020]  не надо, код показывать особо не надо.
[53:19.020 --> 53:21.020]  Че, вам не жалко маркеров
[53:21.020 --> 53:23.020]  или жалко? Ну если жалко, то я буду
[53:23.020 --> 53:25.020]  код писать, а если...
[53:25.020 --> 53:27.020]  Ну я не знаю, просто
[53:27.020 --> 53:29.020]  мне кажется, что здесь можно на доске
[53:29.020 --> 53:31.020]  Нормально?
[53:45.020 --> 53:47.020]  Ну давайте тогда на доске
[53:47.020 --> 53:49.020]  подпишу.
[53:49.020 --> 53:51.020]  Исключения.
[53:53.020 --> 53:55.020]  exceptions
[53:59.020 --> 54:01.020]  Сейчас напишу.
[54:15.020 --> 54:17.020]  Значит, глава
[54:17.020 --> 54:19.020]  седьмая исключения, параграф 7.1
[54:19.020 --> 54:21.020]  как обычно
[54:23.020 --> 54:25.020]  базовые идеи, базовые примеры.
[54:29.020 --> 54:31.020]  Но
[54:33.020 --> 54:35.020]  традиционно начну
[54:35.020 --> 54:37.020]  со слов, вы наверняка все знаете,
[54:37.020 --> 54:39.020]  что это такое, поэтому че вам рассказывать?
[54:41.020 --> 54:43.020]  Ну кто умеет исключения
[54:43.020 --> 54:45.020]  пользоваться? На каком уровне?
[54:45.020 --> 54:47.020]  Ну кто умеет сделать
[54:47.020 --> 54:49.020]  dry catch,
[54:49.020 --> 54:51.020]  что-нибудь кинуть
[54:51.020 --> 54:53.020]  и поймать?
[54:53.020 --> 54:55.020]  Половина умеет.
[54:55.020 --> 54:57.020]  Да, не ловит.
[54:57.020 --> 54:59.020]  Значит, надо понимать,
[54:59.020 --> 55:01.020]  как работает исключение.
[55:01.020 --> 55:03.020]  Вот мы сейчас про это поговорим.
[55:03.020 --> 55:05.020]  Ну давайте для начала, совсем
[55:05.020 --> 55:07.020]  на примитивном уровне, что такое
[55:07.020 --> 55:09.020]  исключение. Тут есть
[55:09.020 --> 55:11.020]  за этим стоит такая длинная
[55:11.020 --> 55:13.020]  философия. Вот если вы
[55:13.020 --> 55:15.020]  откроете книжку сраустру
[55:15.020 --> 55:17.020]  создателя, то есть
[55:17.020 --> 55:19.020]  про C++, и там
[55:19.020 --> 55:21.020]  в главе про исключение, там примерно две
[55:21.020 --> 55:23.020]  страницы текста, где он
[55:23.020 --> 55:25.020]  рассуждает, как же так вышло, почему
[55:25.020 --> 55:27.020]  мы добавили исключение язык, в чем
[55:27.020 --> 55:29.020]  плюсы и минусы. Я вам сейчас
[55:29.020 --> 55:31.020]  примерно расскажу,
[55:31.020 --> 55:33.020]  в чем плюсы. Зачем вообще
[55:33.020 --> 55:35.020]  нужна эта штука?
[55:37.020 --> 55:39.020]  Почему нас не устраивал
[55:39.020 --> 55:41.020]  старый способ обработки ошибок?
[55:41.020 --> 55:43.020]  Ну исключение такой, новый механизм обработки
[55:43.020 --> 55:45.020]  ошибок. Какой старый
[55:45.020 --> 55:47.020]  способ обработки ошибок? Если у вас
[55:47.020 --> 55:49.020]  какая-нибудь функция,
[55:51.020 --> 55:53.020]  ну вот в ней произошла какая-то
[55:53.020 --> 55:55.020]  операция,
[55:57.020 --> 55:59.020]  ну что-то пошло не так. Вы вызвали какую-то
[55:59.020 --> 56:01.020]  функцию, она вызвала еще какую-то
[56:01.020 --> 56:03.020]  функцию, она вызвала еще какую-то функцию,
[56:03.020 --> 56:05.020]  и в очередной функции что-то пошло не так.
[56:05.020 --> 56:07.020]  Как вы из вызывающего
[56:07.020 --> 56:09.020]  вашего кода узнаете, что что-то
[56:09.020 --> 56:11.020]  пошло не так? Допустим, ваша функция
[56:11.020 --> 56:13.040]  вот та, которую вы вызвали, возвращает
[56:13.040 --> 56:15.260]  int, она должна вам
[56:15.260 --> 56:17.020]  вернуть int в нормальной ситуации,
[56:17.020 --> 56:19.020]  но в ней что-то пошло не так
[56:19.020 --> 56:21.020]  и по какой-то причине
[56:21.020 --> 56:32.020]  она не может вам вернуть int. Ну, не получилось, допустим, она должна была прочитать что-нибудь с файла и вернуть вам это число, или с клавиатуры, и выровнять вам это число.
[56:32.020 --> 56:45.020]  И вот что-то пошло не так, файл, например, открыть не удалось. И она не может вам вернуть ничего, потому что любой int, который она вам вернет, будет означать, ну, вы будете интерпретировать как какой-то валидный результат.
[56:45.020 --> 56:47.020]  То есть может быть любой int, в принципе.
[56:47.020 --> 56:49.020]  Зарезервировать один родной int?
[56:49.020 --> 57:03.020]  Да, значит, вариант первый. Зарезервировать одно специальное значение под что-то пошло не так. Вот типа можно любое значение вернуть, но вот это значение будем читать как что-то пошло не так.
[57:03.020 --> 57:19.020]  Мы будем вызвали эту функцию писать. If, значит, вызвали эту функцию. Если вот результат и функция равен magic number, значит, ну, делаем действие на случай, если что-то пошло не так, выводим сообщение, ошибка, а иначе работаем обычным образом дальше.
[57:19.020 --> 57:21.020]  Еще можно глобальную переменную flag.
[57:21.020 --> 57:31.020]  Вот, по сути это, да, еще можно глобальную переменную flag поставить, да. По сути эта идея называется коды ошибок.
[57:31.020 --> 57:43.020]  Ну, какие есть альтернативы? Вот альтернативы, да, альтернативы исключением. Альтернативы исключением.
[57:43.020 --> 57:47.020]  Еще можно по сути передавать силы.
[57:47.020 --> 58:04.020]  Да, значит, ну, по сути их две. Значит, это коды ошибок. То есть, ну, так, идейно две есть альтернативы. То есть возвращать код ошибки, говорить, что у нас будет специальное обозначение на случай если что-то пошло не так.
[58:04.020 --> 58:15.020]  Вот, например, когда мы вызываем из консоли какую-нибудь программу, она может вернуть ноль, и это значит, что все пошло так. А может вернуть не ноль, и это означает, что что-то пошло не так.
[58:15.020 --> 58:19.020]  И вот что именно пошло не так, это надо по коду ошибки смотреть.
[58:19.020 --> 58:31.020]  Сто тридцать четыре. Ага, ну, если сто тридцать четыре, это значит всех фоллт, допустим. 200 и 5. Ага, ну, если 200 и 5, это значит там что-то еще произошло.
[58:31.020 --> 58:43.020]  И вот ваш код выглядит таким образом. Вы вызываете функцию, а дальше пишете. Если результат означает функции такой-то, то значит выведет такое сообщение об ошибке.
[58:43.020 --> 58:53.020]  Иначе, если он такое-то число, выведет такое сообщение об ошибке. Ну, и там, перебирайте эти коды ошибок. Эти коды ошибок у вас где-то выход кожаны. Вы там завели какие-то константы под эти коды ошибок.
[58:53.020 --> 59:02.020]  Но так было в языке СИП. В принципе, ничего. Да, так люди жили. Вот, проверяли коды ошибок постоянно, когда вызывали какую-то функцию.
[59:02.020 --> 59:14.020]  Другой вариант – это дополнительно передавать функцию, то есть заставить функцию возвращать какое-то специальное число или глобальное состояние менять, говорящее о том, что ошибка произошла.
[59:14.020 --> 59:26.020]  Например, кстати, вот у вас в потоках в Eostream есть глобальная система. Я забыл, какой метод проверяет в нормальном ли состоянии поток.
[59:26.020 --> 59:39.020]  Типа, Eostream, CIN. Забыл, что? Например, EOV. Ну, например, EOV, да, достигнули конец файла. Ну, по сути, то же самое.
[59:39.020 --> 59:46.020]  Но там есть еще какая-то функция, которая проверяет, все ли нормально. Это вот глобальное состояние.
[59:46.020 --> 01:00:00.020]  А другой вариант – это передавать каждый раз функцию дополнительным аргументом число, ну или буль, который будет записываться true или false, и вместо этого все ли окей.
[01:00:00.020 --> 01:00:11.020]  И проверять его. То есть у вас функция, допустим, принимает IN и возвращает IN. И вы хотите как-то узнавать, все ли нормально пошло или нет.
[01:00:11.020 --> 01:00:20.020]  Тогда вы заводите ей дополнительный аргумент Bool. Передаете его по ссылке. Ну, все не было ссылок, поэтому приходилось передавать по указателю.
[01:00:20.020 --> 01:00:28.020]  И, значит, в этот Bool эта функция записывает true или false, смотря, пошло у нее все хорошо или нет.
[01:00:28.020 --> 01:00:35.020]  И если все пошло плохо, то вы должны сначала проверить, прежде чем использовать результат этой функции, вы должны проверить этот Bool.
[01:00:35.020 --> 01:00:43.020]  И если только с ней все хорошо, то тогда вы дальше код выполняете. А иначе, значит, какое-то сообщение в ошибке.
[01:00:43.020 --> 01:00:48.020]  Почему функция не может возвращать значение и потом открыть, да, типа ошибки?
[01:00:48.020 --> 01:00:50.020]  И потом?
[01:00:50.020 --> 01:00:53.020]  Потому что не было пафоса.
[01:00:53.020 --> 01:00:55.020]  И потом?
[01:00:55.020 --> 01:00:57.020]  Пафоса тоже не было. Вот так и делали.
[01:00:57.020 --> 01:01:04.020]  Ну, не было. Ну как? Структуры были. Вы что, под каждую функцию свою структуру будете заводить или что?
[01:01:04.020 --> 01:01:06.020]  Что было?
[01:01:06.020 --> 01:01:09.020]  Ну, сначала было слово.
[01:01:09.020 --> 01:01:11.020]  Ну, много чего было.
[01:01:11.020 --> 01:01:15.020]  Можно было одну структуру int or error.
[01:01:15.020 --> 01:01:23.020]  Нет, были указатели, были expression, были функции, были структуры, только там не было этих конструкторов и прочего.
[01:01:23.020 --> 01:01:33.020]  Структура это просто был набор, то, что мы называли, там, агрегатной инициализации, оно там было, кажется.
[01:01:33.020 --> 01:01:41.020]  Так вот, доп-аргумент.
[01:01:41.020 --> 01:01:46.020]  Ну, типа bool-ok.
[01:01:46.020 --> 01:01:52.020]  Вот, булевская переменная, в которой записывается ok или не ok выполнение функции.
[01:01:52.020 --> 01:01:56.020]  И каждый раз после вызова функции нужно проверять, все ли нормально.
[01:01:56.020 --> 01:02:05.020]  Вот, в Си есть, как в Си, например, правильно делать выделение памяти?
[01:02:05.020 --> 01:02:07.020]  Как правильно в Си делать выделение памяти?
[01:02:07.020 --> 01:02:13.020]  Это наша операционная система.
[01:02:13.020 --> 01:02:17.020]  Нет, подожди, операционная система в конечном итоге делает.
[01:02:17.020 --> 01:02:22.020]  Вот, допустим, ты пишешь ход на Си, тебе нужно запросить динамическую память, как это делается?
[01:02:22.020 --> 01:02:25.020]  У тебя есть функция malloc, правильно?
[01:02:25.020 --> 01:02:32.020]  Ну, в Си у тебя есть функция malloc, в которой ты говоришь, там, сколько byte, там, сколько-то, m.
[01:02:32.020 --> 01:02:33.020]  Вот.
[01:02:33.020 --> 01:02:39.020]  Допустим, она решилась неудачно, у нее не получилось выделить, сколько ты попросил.
[01:02:39.020 --> 01:02:42.020]  Как ты об этом узнаешь?
[01:02:42.020 --> 01:02:44.020]  Сегфолт.
[01:02:44.020 --> 01:02:46.020]  Нет, если бы.
[01:02:46.020 --> 01:02:51.020]  Нет, если бы секфолт, это как-то совсем плохо, потому что, а как обрабатывать этот случай?
[01:02:51.020 --> 01:02:56.020]  Ну вот, как в Си узнать, что выделение памяти завершилось неудачно?
[01:02:56.020 --> 01:02:59.020]  Есть функция malloc сейчас какая-нибудь?
[01:02:59.020 --> 01:03:01.020]  Такая, чтобы просто донуть?
[01:03:01.020 --> 01:03:03.020]  Да.
[01:03:03.020 --> 01:03:09.020]  Просто malloc возвращает NullPTR, если не удалось выделить.
[01:03:09.020 --> 01:03:11.020]  То есть, как правильно пользоваться malloc?
[01:03:11.020 --> 01:03:15.020]  Вам надо проверять, вернулся ли NullPTR.
[01:03:15.020 --> 01:03:22.020]  Если вы написали malloc, вы написали, там, byte звездочка P равно malloc N.
[01:03:22.020 --> 01:03:25.020]  А дальше вам нужно проверить.
[01:03:25.020 --> 01:03:35.020]  Если не P, то что-то сделать, потому что вдруг там не получилось выделить, и тогда надо обработать этот случай отдельно.
[01:03:35.020 --> 01:03:37.020]  Вот.
[01:03:37.020 --> 01:03:40.020]  Но вы никак не узнаете иначе, что не удалось выделить.
[01:03:40.020 --> 01:03:44.020]  Вы дальше можете начать работать с этим указателем, как будто это нормальный указатель.
[01:03:44.020 --> 01:03:47.020]  И потом в разыменовании будет UB.
[01:03:47.020 --> 01:03:52.020]  Ну, на практике это, конечно, будет сикфолд, скорее всего, но...
[01:03:52.020 --> 01:03:56.020]  Мне кажется, если мы попытаемся разыменовывать NullPTR, то нас сразу убивает прям без вопросов.
[01:03:56.020 --> 01:04:02.020]  Ну да, это, скорее всего, будет сикфолд, но, ну да, на практике будет сикфолд.
[01:04:02.020 --> 01:04:09.020]  Но, тем не менее, вот, как вы поймете, что именно произошло, вот, когда у вас malloc не сработал,
[01:04:09.020 --> 01:04:13.020]  но вам как отличить случай, что malloc не сработал от случай, что malloc правильно сработал?
[01:04:13.020 --> 01:04:15.020]  Вам нужно if писать после malloc.
[01:04:15.020 --> 01:04:18.020]  И, на самом деле, так со всеми функциями сишными.
[01:04:18.020 --> 01:04:22.020]  Вот, например, как перевести строку в число?
[01:04:22.020 --> 01:04:27.020]  Там std, там a, то и и.
[01:04:27.020 --> 01:04:31.020]  Опять же, у вас нужно проверить, что вернулось.
[01:04:31.020 --> 01:04:34.020]  То есть, там она...
[01:04:34.020 --> 01:04:37.020]  Ну, я не помню, там, какой конкретно, там, что она...
[01:04:37.020 --> 01:04:42.020]  Она возвращает OK или не OK, или, наоборот, она принимает этим аргументом.
[01:04:42.020 --> 01:04:48.020]  Ну, короче, вы должны проверять результат, прежде чем пойдете дальше.
[01:04:48.020 --> 01:04:56.020]  То есть, вы вызвали функцию, проверили, все ли OK, и только потом пользуетесь результатом этой функции.
[01:04:56.020 --> 01:04:58.020]  Это очень неудобно.
[01:04:58.020 --> 01:05:04.020]  Это раздувает код очень сильно, потому что вам каждый раз, когда вы делаете любую...
[01:05:04.020 --> 01:05:06.020]  Ну, то есть, представьте, у вас код, ну как, вы вызываете...
[01:05:06.020 --> 01:05:08.020]  Код, по сути, состоит из вызова функций.
[01:05:08.020 --> 01:05:14.020]  И вот каждый раз, когда вы вызываете какую-то функцию, которая теоретически может завершиться неудачно,
[01:05:14.020 --> 01:05:16.020]  вам нужно писать if дополнительный.
[01:05:16.020 --> 01:05:19.020]  Что, если она завершилась неудачно?
[01:05:19.020 --> 01:05:21.020]  Вот, неудобно очень.
[01:05:25.020 --> 01:05:27.020]  Да.
[01:05:28.020 --> 01:05:30.020]  Да.
[01:05:30.020 --> 01:05:32.020]  Вот.
[01:05:32.020 --> 01:05:34.020]  Какая альтернатива?
[01:05:34.020 --> 01:05:37.020]  Давайте придумаем механизм исключений.
[01:05:37.020 --> 01:05:41.020]  Другая философия обработки ошибок.
[01:05:43.020 --> 01:05:45.020]  Мы...
[01:05:48.020 --> 01:05:51.020]  Да, причем, что еще неудобно, это самое главное.
[01:05:51.020 --> 01:05:55.020]  Вот, вы, допустим, поняли, что здесь что-то пошло не так.
[01:05:55.020 --> 01:05:57.020]  Вот, не удалось выделить.
[01:05:57.020 --> 01:06:01.020]  Но вы ничего не можете здесь с этим поделать.
[01:06:01.020 --> 01:06:05.020]  Это, в свою очередь, означает для вас, что ваша функция должна завершиться неудачно.
[01:06:06.020 --> 01:06:10.020]  И вам нужно как-то наверх сообщить вызывающему код о том, что вы тоже завершились неудачно.
[01:06:10.020 --> 01:06:13.020]  А у вас, как якунце, может быть, стекль из 10 вызовов.
[01:06:13.020 --> 01:06:21.020]  То есть вам везде нужно писать if и куда-то наверх возвращать тоже сообщение о том, что вы неудачно завершились.
[01:06:21.020 --> 01:06:26.020]  И та функция, получив от вас это сообщение, сама должна будет написать аналогичный if
[01:06:26.020 --> 01:06:28.020]  и еще наверх отдать, что вы неудачно завершились.
[01:06:28.020 --> 01:06:30.020]  И так там в десять уровней вверх.
[01:06:30.020 --> 01:06:34.500]  И только на самом верхнем уровне может быть кто-то что-то придумает, что с ним сделать.
[01:06:36.500 --> 01:06:43.860]  Альтернатива. Давайте введем новый оператор, который называется throw. Бросить, значит. Я могу
[01:06:45.900 --> 01:06:47.900]  написать throw
[01:06:48.180 --> 01:06:51.780]  что-нибудь. Ну, на самом деле можно бросать что угодно.
[01:06:52.580 --> 01:06:54.820]  В C++ бросать можно любые объекты.
[01:06:55.860 --> 01:06:59.100]  Вот, я могу бросить, ну, какой-нибудь объект.
[01:07:01.020 --> 01:07:05.020]  Ну, брошу-ка я int.
[01:07:05.660 --> 01:07:10.700]  Ну, так не надо делать никогда. Это, значит, это учебник. Примерно. Практически бросать int стоит.
[01:07:11.460 --> 01:07:13.460]  Вот, бросаться int не нужно.
[01:07:21.460 --> 01:07:24.460]  Можно бросить тухлое яйцо.
[01:07:25.460 --> 01:07:29.460]  Кстати, не знаю, как будет тухлое.
[01:07:34.460 --> 01:07:42.780]  Вот, я пишу, допустим, у меня что-то не получилось сделать, и я говорю throw какой-нибудь объект.
[01:07:43.660 --> 01:07:46.860]  Что делает функция throw? Ну, это не функция, это оператор.
[01:07:48.060 --> 01:07:50.060]  Ну, с точки зрения
[01:07:51.140 --> 01:07:53.540]  компилятора это в итоге функция все равно, потому что
[01:07:54.660 --> 01:08:01.380]  она компилируется в некоторых функциях, но это такой оператор для нас. Что он делает? Он берет.
[01:08:02.620 --> 01:08:04.620]  Вот у вас есть спек вызовов.
[01:08:07.100 --> 01:08:11.020]  Вот вы тут вызвали, значит, какую-то F, значит, адрес возврата.
[01:08:12.980 --> 01:08:16.940]  Потом какие-то локальные переменные, потом еще какой-то там адрес.
[01:08:18.340 --> 01:08:23.940]  Не знаю, адрес первый, там адрес второй, еще какая-то переменная. И вот тут вы написали throw.
[01:08:25.460 --> 01:08:27.460]  Вам нужно
[01:08:28.020 --> 01:08:35.540]  откатиться по стеку наверх, значит, когда вы пишете throw, происходит что называется stack unwinding.
[01:08:36.460 --> 01:08:38.460]  Разматывание стека.
[01:08:38.660 --> 01:08:40.660]  То есть
[01:08:40.740 --> 01:08:44.300]  все локальные переменные текущего блока
[01:08:45.940 --> 01:08:47.940]  уничтожаются, снимаются со стека, и
[01:08:48.780 --> 01:08:56.220]  вы выскакиваете наружу. Ну, если вы оказываетесь нам на уровне функции
[01:08:57.220 --> 01:09:00.220]  локально, то вы выскакиваете из этой функции.
[01:09:01.220 --> 01:09:07.780]  Уничтожаются все локальные переменные этой функции, которые были созданы, разумеется, в порядке обратном тому, в котором они были созданы, не уничтожаются.
[01:09:07.780 --> 01:09:12.060]  И вы выскакиваете наружу из функции. То есть, как бы со стека снимаются все эти штуки.
[01:09:12.980 --> 01:09:14.540]  Вы
[01:09:14.540 --> 01:09:16.940]  по адресу возврата возвращаетесь в функцию
[01:09:17.780 --> 01:09:22.420]  наверх. И дальше там тоже вы выскакиваете туда, откуда пришли.
[01:09:24.380 --> 01:09:28.780]  Опять там уничтожаются все локальные переменные. Вы выскакиваете еще наверх и так далее.
[01:09:29.820 --> 01:09:33.980]  Пока вы не окажетесь в блоке, где написано try.
[01:09:35.540 --> 01:09:37.540]  Вот.
[01:09:38.100 --> 01:09:41.860]  Когда заканчивается этот полет, это то, что называется летит исключение.
[01:09:43.220 --> 01:09:44.820]  Вы
[01:09:45.000 --> 01:09:48.360]  написав throw, начинаете выскакивать всех блоков.
[01:09:49.780 --> 01:09:52.420]  Уничтожаются все локальные переменные. Вы выскакиваете из этого блока.
[01:09:53.020 --> 01:09:58.000]  Оказываетесь более внешними блоками. Уничтожаются все локальные переменные. В этого блока вы выскакиваете из этого блока.
[01:09:58.660 --> 01:10:05.460]  Если это просто и姐 функции, то вы просто выходите из функции, уничтожаете cheap allocation.
[01:10:06.340 --> 01:10:13.220]  Выскакиваете туда, откуда были вызваны. Опять оказываются блоки и так далее, пока вы либо не окажетесь в мейне.
[01:10:13.220 --> 01:10:21.140]  либо не окажетесь внутри блока try. Вот если вы окажетесь внутри блока try, то
[01:10:21.140 --> 01:10:31.420]  дальше после try должен стоять, значит, секция заглавленная catch. Вот try это
[01:10:31.420 --> 01:10:37.820]  блок, внутри которого может вылететь исключение, так скажем. А дальше должно
[01:10:37.820 --> 01:10:43.060]  быть обязательно написано catch, и вот после catch может быть написано что-то
[01:10:43.060 --> 01:10:48.020]  конкретное, catch какой-то тип. Вот, после catch может быть либо написан конкретный
[01:10:48.020 --> 01:10:55.660]  тип, либо написано многоточие. Многоточие здесь это не... Нет, здесь многоточие это не
[01:10:55.660 --> 01:11:03.820]  пакет, и это не моё авторское... Это прямо в коде так писать можно, то есть это
[01:11:03.820 --> 01:11:09.620]  часть синтакса. Можно писать catch многоточие, это значит, что вы ловите всё, что угодно.
[01:11:10.460 --> 01:11:19.860]  Любое исключение вы ловите. Не любое, а любое исключение. Вот, а может быть здесь
[01:11:19.860 --> 01:11:27.380]  поймано что-то конкретное. Вот, здесь можно написать catch, допустим, in x. Это будет
[01:11:27.380 --> 01:11:38.540]  означать, что вы... Это будет означать, что если вот пока выполнялся этот код,
[01:11:38.540 --> 01:11:43.300]  где-то в нём или там функция, которую он вызвал, вылетел int, то вот здесь он будет
[01:11:43.300 --> 01:11:49.260]  пойман и будет выполнен код с этим, то что тут написано. А дальше, как ни в чём не
[01:11:49.260 --> 01:11:56.260]  бывало, вы пойдёте работать дальше. Если вылетел не int, то значит в этот catch вы не
[01:11:56.260 --> 01:12:05.740]  попадёте. Ну, там есть некоторые правила приведения, что можно ловить по каким
[01:12:05.740 --> 01:12:09.180]  правилам, но это попозже. В общем, если вылетел не int, считайте, что вы сюда не
[01:12:09.180 --> 01:12:13.860]  попадёте. У вас есть вариант написать несколько catch под одним try. Вот вы можете
[01:12:13.860 --> 01:12:18.020]  написать catch многоточие, тогда вы сюда попадёте уже в любом случае, если вылетел
[01:12:18.020 --> 01:12:32.060]  что угодно. Это значит, вы написали throw и какой-то int. Вы его и поймаете в x. Нет,
[01:12:32.060 --> 01:12:40.060]  нельзя. Только по типу можно ловить. Можно писать catch такой, а потом catch
[01:12:40.060 --> 01:12:45.580]  следующий, и так далее. А это вылет уже в тот же try, вы просто ловите разные
[01:12:45.580 --> 01:12:50.260]  варианты ошибок. А если мы ни в один из catch не попали, то мы продолжаем дальше?
[01:12:50.260 --> 01:12:55.100]  Если вы не попали ни в один из catch, то да, вы понимаете, что здесь нас не поймали,
[01:12:55.100 --> 01:13:02.820]  летим дальше, продолжаем вверх размахиваться. А можем ловить ошибки в catch? Что? В смысле
[01:13:02.820 --> 01:13:08.580]  ловить в catch? Можем делать throw в самом catch? Да, конечно. Но это не ловить ошибки,
[01:13:08.580 --> 01:13:18.100]  бросать в catch вы можете. Конечно можете. Если он что, в catch не попал, ну да, если он
[01:13:18.100 --> 01:13:23.220]  увидел, что внутри блока try подходящего catch нету, то окей, значит, выскакиваем
[01:13:23.220 --> 01:13:31.100]  еще выше и продолжаем дальше. Это вычислительно не очень сложно. Это что? Вычислительно не очень медленно.
[01:13:31.100 --> 01:13:42.180]  Вычислительно это, ну как вам сказать, это некоторые накладные расходы. Так, вот, в этом идее,
[01:13:42.180 --> 01:13:54.780]  собственно. В общем-то, в этом идее исполнения тихо опять что-то расшумелись. Вот. Почему это во многих
[01:13:54.780 --> 01:13:59.780]  случаях удобнее, чем старый стиль обработки ошибок? Да потому, что вам теперь можно не
[01:13:59.780 --> 01:14:05.940]  париться, ну вот, как побеждать ситуацию. Допустим, у вас на десятом уровне вложенности какая-то
[01:14:05.940 --> 01:14:13.140]  функция неудачно завершилась. Тогда она не говорит, я возвращаю какое-то значение, и вам нужно вручную
[01:14:13.140 --> 01:14:19.900]  самому через все уровни вызову проталкивать это значение. То есть, окей, тогда я из своей функции
[01:14:19.900 --> 01:14:25.740]  верну назад тоже какой-то вот ошибки. И моя и та функция, и так, 10 уровней наверх, и только на
[01:14:25.740 --> 01:14:31.420]  десятом уровне сверху от меня кто-то проверит наконец-то это вот ошибки и фом, и увидит,
[01:14:31.420 --> 01:14:37.180]  что он такой, а это означает то-то. Теперь это работает не так. Теперь вы пишете throw что-то,
[01:14:37.180 --> 01:14:46.380]  throw какой-то тип ошибки. А прикол в том, что вы просто для разных видов ошибок свои типы заводите.
[01:14:46.380 --> 01:14:53.700]  У вас есть стандартная иерархия исключений, у вас есть стандартный тип std exception, от которого много
[01:14:53.700 --> 01:15:06.300]  чего наследовано. Ну, там есть наследники std runtime error, например, std logic error. Там, ну, разные есть.
[01:15:06.300 --> 01:15:15.380]  Вот вы можете открыть, я их не помню все, но я не помню какая у них иерархия. В общем, вы можете там
[01:15:15.380 --> 01:15:23.340]  открыть разные, вы можете открыть себе переференс, увидеть там иерархию исключений. Вот, там еще много
[01:15:23.340 --> 01:15:33.740]  подвидов. Ну, например, вот если кто-то в векторе обращается за пределы, ну, по индексу выходящему
[01:15:33.740 --> 01:15:44.000]  за пределы, вы можете бросить ошибку std out of range. Вот есть такой тип std out of range. Он говорит
[01:15:44.000 --> 01:15:53.040]  вызывающему коду, что произошла ошибка, выход за границей. Вы можете там, если кто-то у вас там
[01:15:53.040 --> 01:15:59.640]  что-то произошло и понятно стало, что выход за границей, вот такие throw std out of range, а в скобочках
[01:15:59.640 --> 01:16:16.440]  с каким текстом? std out of range и можно передать сообщение какое-то. Вот, когда вы это поймаете, вот здесь,
[01:16:16.440 --> 01:16:36.640]  например, я говорю catch, а тут я ловлю std out of range, не знаю там, ex. Ex от слова exception. И тут я могу
[01:16:36.640 --> 01:16:43.960]  сказать, cout, ex, у всех стандартных исключений есть метод вот, который говорит что произошло.
[01:17:06.640 --> 01:17:17.720]  Вот, у стандартных всех исключений вот у exception есть метод вот, который выводит строку вот
[01:17:17.720 --> 01:17:24.600]  эту, которую передали, возвращает строку. Вот, и здесь можно писать вот. Ну и что-нибудь еще сделать.
[01:17:24.600 --> 01:17:30.400]  Вы можете унаследовать свой собственный класс std exception и добавить ему какие-нибудь свои методы.
[01:17:30.400 --> 01:17:36.360]  То есть, если вы поймаете этот вид исключения, вы что-то будете уметь с ним делать, вы там сможете
[01:17:36.360 --> 01:17:41.840]  у него что-нибудь вызвать и понять там, что конкретно произошло, например, где. Вот.
[01:17:41.840 --> 01:17:56.320]  Вот, теперь, теперь, да, самое, что я забыл сказать. Что, если так трай не будет. Вот мы летели,
[01:17:56.320 --> 01:18:04.040]  летели, долетели до мейна. То есть, мы поняли, что мы выскочили в мейн, а трая все еще нет. И вот все мы уже в самой верхней области.
[01:18:04.040 --> 01:18:13.400]  Все работает формально, как я сказал. То есть, мы находимся в блоке. Трай, если кэнч подошел,
[01:18:13.400 --> 01:18:21.560]  окей. Если нет, выскакиваем в блок выше и так далее. Блока может быть и трай. Трай это ключевое
[01:18:21.560 --> 01:18:31.320]  слово. Это управляющая конструкция. Такая же, как if, for и так далее. Вот, последняя из управляющей
[01:18:31.320 --> 01:18:36.560]  конструкции. Вот. Так вот, если мы долетели до мейна, а кэнча так и нет соответствующего. Что
[01:18:36.560 --> 01:18:43.640]  тогда происходит? Если исключение долетело до мейна и так и не нашелся подходящий трай,
[01:18:43.640 --> 01:19:03.760]  то вызывается стандартная функция std terminate. Вот. Что делает функция terminate?
[01:19:03.760 --> 01:19:14.400]  Да ты заходи. Да я сейчас все закончу. Да. Что делает функция std terminate? Ну, она, по сути,
[01:19:14.400 --> 01:19:24.800]  делает то, что стоило бы сделать, значит, вам поймать. Она просто пишет в консоль сообщение,
[01:19:24.800 --> 01:19:32.520]  что terminate call after throwing an instance of и пишет название типа того, чтобы были цела.
[01:19:32.520 --> 01:19:46.960]  А дальше вызываю C-шную функцию abort. C-шная функция abort просто делает, ну, она вызывает некоторые
[01:19:46.960 --> 01:19:54.840]  уже системную функцию, которая говорит убей меня с вердиктом abort for down. Ну, то есть,
[01:19:54.840 --> 01:20:01.800]  C-шная функция abort у операционной системы запрашивает как бы убей меня, пожалуйста,
[01:20:01.800 --> 01:20:11.640]  по причине, значит, я, значит, ну abort, вызвала abort. Ну вот, когда вы падаете из-за необработанного
[01:20:11.640 --> 01:20:18.560]  исключения, вы в консоли видите terminate call after throwing an instance of написано что, а дальше abort
[01:20:18.560 --> 01:20:23.440]  abort after down. Так вот, вот это вот terminate call after throwing an instance, это вот функция terminate
[01:20:23.440 --> 01:20:29.360]  пишет в консоль, а дальше она вызывает abort, которая вызывает уже системный вызов, который ее
[01:20:29.360 --> 01:20:36.920]  убивает. Вот. Да, что? Как мы можем дойти до мэйна, не поймав исключения? Я знаю, что мы нигде не написали
[01:20:36.920 --> 01:20:43.560]  try catch. Вот ты просто в мэйне напиши throw 1. Вот ты дойдешь до мэйна, не поймав исключения. Ну, то есть, мы нигде не писали try catch.
[01:20:43.560 --> 01:20:52.880]  Ты мог писать try catch просто не тех типов, которых надо. А мы могли бы писать catch без try? Нет. И try без catch не
[01:20:52.880 --> 01:21:02.960]  могли. Только try, а потом catch. А это уже циан. Да, да. Такая конструкция закончена. Вот. Последнее,
[01:21:02.960 --> 01:21:10.760]  что я скажу, видимо, бывает terminate call и не по причине, что исключения. Вот у нас с вами был, давайте,
[01:21:10.760 --> 01:21:18.360]  опять проверочки на то, насколько вы внимательно слышите. У нас с вами был пример уже, когда у нас было terminate
[01:21:18.360 --> 01:21:26.800]  call without an active exception. Это что, например? Это что было? Да, pure virtual function call. Вот. Это было terminate call
[01:21:26.800 --> 01:21:34.560]  without an active exception. Когда мы попадали в pure virtual функцию, вот когда у нас pure virtual функция
[01:21:34.560 --> 01:21:40.520]  вызывалась, мы попадали в некоторый код специально с билер-купилятором, который вызывал функцию. Ну, там
[01:21:40.520 --> 01:21:47.680]  вызывается функция terminate, но функция terminate в себе, ну, некоторым механизмом проверяет, почему она
[01:21:47.680 --> 01:21:55.080]  вызвалась. И она видит, что это не потому, что исключения летит, а потому, по какой-то любой причине. И, значит,
[01:21:55.080 --> 01:22:00.320]  функция terminate пишет в консоли terminate call without an active exception, ну, а дальше опять abort, abort
[01:22:00.440 --> 01:22:08.680]  когда? А если мы написали три точки, то мы уже не можем понять, какие сообщения там были. Если мы написали три точки, то понять, что именно
[01:22:08.680 --> 01:22:15.520]  летит, мы, кажется, уже не можем. Ну, по крайней мере, стандартных доказательств. Летит и летит. Ну, ладно,
[01:22:15.520 --> 01:22:27.880]  давайте на этом приостановимся, так сказать. Вот. Ладно. Так, мы остановились на разговоре о том,
[01:22:27.880 --> 01:22:37.760]  что такое std terminate. Вот. std terminate это функция, которая автоматически вызывается в случае, если у вас исключение
[01:22:37.760 --> 01:22:46.600]  долетело до мейна и так и не было обработано. Функция std terminate занимается тем, что пишет в консоль то, что
[01:22:46.600 --> 01:22:53.680]  знает о произошедшем, а дальше вызывает сишную функцию abort. Сишная функция abort, в свою очередь, вызывает
[01:22:53.680 --> 01:23:02.680]  некоторую другую уже системную функцию, которая, значит, приводит к тому, что операционная система
[01:23:02.680 --> 01:23:12.680]  завершает вашу программу, ну, то есть убивает вашу программу со словами abort. Иногда операционная
[01:23:12.680 --> 01:23:19.600]  система убивает вашу программу со словами segmentation fold, как вы знаете. Вот. А abort это такая ре, которая,
[01:23:19.600 --> 01:23:29.160]  которую можно попросить, чтобы, грубо говоря, есть функция, которая делает вызов операционной системы и
[01:23:29.160 --> 01:23:35.800]  говорит убей меня. Вот. И тогда операционная система как бы убивает вас по вашей просьбе. Это называется abort.
[01:23:35.800 --> 01:23:44.280]  Вот. Это тоже вас убили, но это потому что вы сами попросили. Таким образом, вот в отличие от всех
[01:23:44.280 --> 01:23:50.280]  предыдущих случаев ре, которые мы изучали, ре из-за выброшенного исключения, это прям ре, это не уб,
[01:23:50.280 --> 01:23:58.760]  а гарантированная ре. То есть вот если, у вас может быть такой вопрос. Напишите самую короткую
[01:23:58.760 --> 01:24:07.080]  программу, которая гарантированно приводит к ре. Ответ вот такой. Вот. Просто вот так вот. Значит,
[01:24:07.080 --> 01:24:14.920]  это гарантированная ре. Это не уб, а это ре. Прям, ну. То есть программа будет завершена. Ну да,
[01:24:14.920 --> 01:24:24.520]  да. Программа будет завершена с вердиктом, ну как. Там будет сделан abort. Ну можно и ну. Я просто
[01:24:24.520 --> 01:24:34.240]  единицу больше люблю. Можно что угодно, Фроу. Кстати, вот что будет, если просто Фроу без
[01:24:34.240 --> 01:24:49.440]  аргументов написать. Ну сейчас, сейчас обсудим. Да, ну это уже похитрее, а вот Фроу это прям,
[01:24:49.440 --> 01:24:59.320]  ну для того, чтобы вызвать terminate, нужно что-то include, а тут ничего не надо. Вот. Функцию terminate
[01:24:59.320 --> 01:25:11.080]  можно переопределить. Для того, чтобы переопределить функцию terminate, есть функция set terminate. То есть
[01:25:11.080 --> 01:25:24.560]  вы можете вызвать функцию std set terminate и в нее передать указатель на функцию, которую вы хотите,
[01:25:24.560 --> 01:25:44.680]  чтобы вызывалось вместо terminate. Вот. Значит std set terminate. Ну это редкий, редкий случай, но вот
[01:25:44.680 --> 01:26:00.040]  можете на cpp-reference, значит, вызвать, значит, функция set terminate, она определена в заголовочном файле exception.
[01:26:00.040 --> 01:26:06.920]  Как в общем-то, по-моему, и само, ну нет, насчет самой terminate не помню, где она определена. Вот set terminate,
[01:26:06.920 --> 01:26:14.000]  вы в нее туда передаете адрес функции, которую вы хотите, чтобы вместо terminate была. Вот. А можете
[01:26:14.000 --> 01:26:22.440]  еще есть симметричная функция get terminate, узнать, какая сейчас функция играет роль terminate. Вот. Это std
[01:26:22.440 --> 01:26:31.200]  get terminate. Ну это не факт, что вам пригодится, просто вот можно в этом месте тоже настроить, ну например,
[01:26:31.200 --> 01:26:35.400]  ну если у вас необработанное исключение долетело до мейна, вы хотите, чтобы не стандартное поведение
[01:26:35.400 --> 01:26:41.480]  было, типа abort at core dumped и сообщение terminate cold, бла-бла-бла, а какое-то свое поведение вы можете
[01:26:41.480 --> 01:26:47.000]  сделать в этой ситуации. Но это будет последнее, что вызовется, что вызовет ваша программа. По идее,
[01:26:47.000 --> 01:26:53.600]  если вы там сделаете, кстати, вот я не знаю, если там сделать что-то, что не завершает программу,
[01:26:53.600 --> 01:27:13.160]  что будет. Ну кто делает? Кто делает? Функция set terminate, еще раз, вы можете вместо terminate
[01:27:13.160 --> 01:27:24.480]  передать свою версию, что делать. Наверное, программа после этого будет все равно завершена,
[01:27:24.480 --> 01:27:31.760]  честно говоря, я даже не знаю, вы можете там файл открыть и что-нибудь написать туда,
[01:27:31.760 --> 01:27:37.920]  например. Например, для этого, чтобы произошло необработанное исключение. Вот, ну вообще,
[01:27:37.920 --> 01:27:43.280]  конечно, исключение лучше ловить, но если уж не удалось поймать, то можно вот так сделать.
[01:27:43.280 --> 01:28:07.000]  Ну, возможно. Ну, возможно. Не знаю,
[01:28:07.000 --> 01:28:21.880]  не могу сказать, как лучше. Так, теперь, какие есть стандартные операторы и функции,
[01:28:21.880 --> 01:28:29.960]  которые могут кинуть исключение? Вот мы с вами, ну, наверное, давайте это будет уже параграф 7.2. Вот
[01:28:29.960 --> 01:28:36.040]  в 7.1, значит, я рассказал все, что, ну, базовые сценарии, как использовать try-catch, значит,
[01:28:36.040 --> 01:28:40.680]  что есть оператор throw, есть управляющая конструкция try-catch, что можно что-нибудь кинуть,
[01:28:40.680 --> 01:28:47.640]  оно полетит-полетит, значит, если поймается хорошо, если не поймается, будет terminate.
[01:28:47.640 --> 01:29:00.760]  Вот, теперь, вот, следующий пункт, он, я бы сказал, ключевой для понимания того,
[01:29:00.760 --> 01:29:19.680]  что такое исключение в плюсах, вот, и он, значит, называется так, разница между исключениями
[01:29:19.680 --> 01:29:39.200]  и run-time-error-ами. Ну, RES, я так сокращен. Значит, разница между исключениями и RES-ками. Вот,
[01:29:39.200 --> 01:29:52.160]  самое главное, что надо запомнить, я не знаю, это надо вот просто в рамку написать и обвести,
[01:29:52.160 --> 01:30:03.640]  вот, я не знаю, сейчас я прямо так и сделаю, значит, не всякое REE является исключением. Ну,
[01:30:03.720 --> 01:30:12.280]  извините, что я по-английски как-то, я уж привык. Вот, это прям, вот, надо, вот,
[01:30:12.280 --> 01:30:18.600]  вот этот девиз сегодняшнего вечера будет, прям вот так вот, короче. Главный факт,
[01:30:18.600 --> 01:30:25.360]  который вы должны знать про исключение, не всякое REE исключение, вот, вы можете начать,
[01:30:25.360 --> 01:30:31.800]  не всякое исключение приводит к REE, это правда, и не всякое исключение даже
[01:30:31.880 --> 01:30:38.360]  ради REE заводится, но самое главное, это то, что не всякое REE это исключение в плюсах,
[01:30:38.360 --> 01:30:47.280]  по крайней мере. Ну, я бы уточнил, не всякое исключение это C++, не всякое REE это C++ exception.
[01:30:47.280 --> 01:30:55.240]  Ну, вот, смотрите, самый популярный вопрос, который люди задают про исключение и самый
[01:30:55.240 --> 01:31:01.760]  популярный фейл, который люди, значит, самое популярное заблуждение, которое у людей существует
[01:31:01.760 --> 01:31:09.520]  относительно исключений, это, что ты спрашивал? Да, вот, это оно, ну, это частный случай его,
[01:31:09.520 --> 01:31:18.920]  а общее выглядит так, ну, я вот, что-то там сделал, оно не поймалось, почему? Вот, я вот поделил на ноль,
[01:31:18.920 --> 01:31:23.240]  а ничего не поймалось, несмотря на то, что от Рай написал, я вот секфолд получил, и ничего не
[01:31:23.240 --> 01:31:31.280]  поймалось. Да, потому что опять в очередной раз мы вспоминаем, что мы не на питоне пишем,
[01:31:31.280 --> 01:31:39.440]  и в плюсах исключениями является только то, что вы сделаете исключениями сами, вот то, что вы,
[01:31:39.440 --> 01:31:45.560]  то, что вы бросите, то и будет исключением, а все остальное это никакой не исключение,
[01:31:45.560 --> 01:32:03.320]  это просто вас операционная система убивает, вот, значит, секфолд это не исключение, ну,
[01:32:03.320 --> 01:32:16.600]  то есть не C++ исключение, я сейчас поясню, почему я уточняю. Дальше, деление на ноль, тоже,
[01:32:16.600 --> 01:32:29.880]  это не C++ исключение, а что еще бывает? Ну, потому что это какие-то обращения к системе,
[01:32:30.880 --> 01:32:41.080]  да, там какие еще бывают причины? Да вы больше вроде и не знаете, у нас, в общем-то,
[01:32:41.080 --> 01:32:48.040]  три вида рее, в общем-то, и было, секфолд, деление на ноль и абортат, вот, ну, абортат это тоже не
[01:32:48.040 --> 01:33:02.400]  исключение. Чего? Double free or corruption это причина, по которой вызывается функция аборт. Если у
[01:33:02.400 --> 01:33:06.720]  вас происходит double free or corruption, то следующее, что происходит, абортат, опять-таки, если вы
[01:33:06.720 --> 01:33:15.160]  вспомните. Когда у вас, когда вы делаете free, ну, то есть, когда вы делаете освобождение памяти по
[01:33:15.160 --> 01:33:21.480]  неправильному указателю, вы на самом деле обращаетесь к функции free сишной, которая в себе тоже содержит
[01:33:21.480 --> 01:33:26.160]  некоторую логику, это не просто тупая функция, которая напрямую обращается к операционке,
[01:33:26.160 --> 01:33:32.560]  она еще внутри себя содержит некоторую логику и она умеет проверять некоторые ситуации, что вы
[01:33:32.560 --> 01:33:42.200]  сделали double free и вот сама функция, сишная либа, сишная библиотека, вот, siesta delib, которая занимается,
[01:33:42.200 --> 01:33:52.400]  там, ну, некоторая обертка над системными вызовами освобождения памяти, вот, она сама вызывает аборт,
[01:33:52.400 --> 01:34:04.240]  но уже, да, что? Нет, если вы в тупую делаете delete, то delete, ну, сейчас мы, нет, нет, нет,
[01:34:04.240 --> 01:34:09.520]  он проходит через много слоев, но мы сейчас рискуем это застрять на этой теме, это мы в втором
[01:34:09.520 --> 01:34:14.200]  смеси будем обсуждать. Когда вы вызываете delete, вы все равно в конечном счете упираетесь, не в
[01:34:14.200 --> 01:34:20.280]  конечном счете, вы упираетесь в сишную библиотеку, из которой вызывается функция free, ну, потому что
[01:34:20.280 --> 01:34:26.560]  new и delete опираются на сишные функции, malloc и free, а функции malloc и free они тоже не сразу
[01:34:26.560 --> 01:34:33.400]  напрямую лезут в операционную систему, они еще некоторую логику сами в себе содержат, и вот
[01:34:33.400 --> 01:34:39.600]  они иногда могут вызвать аборт, если видят, что вы не там вызвались, поэтому double free or
[01:34:39.600 --> 01:34:45.880]  corruption это тоже одна из причин, по которой может вызваться аборт, а вот аборт это уже функция,
[01:34:45.880 --> 01:34:53.080]  которая непосредственно просит операционную систему убить вас, да, ну, собственно, функция аборт это
[01:34:53.080 --> 01:35:04.840]  это и есть, аборт это убийство, вот, pure virtual function call это тоже не исключение, pure virtual function call конечно
[01:35:04.840 --> 01:35:12.800]  не исключение, ну, когда происходит pure virtual function call, там написано terminate call without
[01:35:12.800 --> 01:35:20.600]  an active exception, еще раз, pure virtual function call это когда вы ткнули вызов какой-то виртуальной
[01:35:20.600 --> 01:35:26.480]  функции, попали в таблице виртуальных функций, написано иди туда, а там такая заглушка, которая
[01:35:26.480 --> 01:35:33.400]  приводит вас в код, вызывающий terminate, вот, и у вас вызывается функция terminate, и функция terminate
[01:35:33.400 --> 01:35:38.440]  видит, что нет никакого исключения, а вызвалась terminate, значит она пишет нету исключения,
[01:35:38.440 --> 01:35:47.200]  но вызвалась terminate и делает аборт, все равно, вот, ну, мы с вами других видов, почему может
[01:35:47.200 --> 01:35:56.520]  быть программа убита вроде как и не знаем, пока только два знаем, но путаница добавляет тот факт,
[01:35:56.520 --> 01:36:03.240]  что вот деление на ноль, вот если поделить на ноль, то что будет написано в консоли, как звучит эта
[01:36:03.240 --> 01:36:10.200]  ошибка, вот если поделить на ноль, то там что в скобочках core dumped, ну там segmentation faults в скобочках
[01:36:10.200 --> 01:36:16.520]  core dumped, а деление на ноль, это как какое там сообщение об ошибке возникает в консоли, когда поделили ноль,
[01:36:16.520 --> 01:36:33.360]  там появится, там floating point exception, да, floating point exception, так вот floating point exception
[01:36:33.360 --> 01:36:44.080]  is not an exception, да, дело в том, что понятие исключения, оно существует на уровне процессора тоже,
[01:36:44.080 --> 01:36:51.120]  вот, и то, что в процессоре называется floating point exception, не является исключением исключения
[01:36:51.120 --> 01:36:57.000]  плюсов, то есть исключительные ситуации бывают на разных уровнях, вот есть то, что является
[01:36:57.000 --> 01:37:07.600]  sim++ exception, sim++ exception это то, что throw кидается, но такие вещи, как segfault и как деление на ноль,
[01:37:07.600 --> 01:37:12.920]  они, конечно же, никаким кетчем не ловятся, потому что кетчем можно поймать только то, что на этом
[01:37:12.920 --> 01:37:18.000]  же уровне брошено, ну как, кетч — это средство отловить ошибку, которая бросила какая-то другая
[01:37:18.000 --> 01:37:24.480]  часть вашей программы, но segfault и деление на ноль — это ошибки вообще вне вашего контроля,
[01:37:24.480 --> 01:37:32.200]  если вы наступили там в операционной системе на запрещенный участок памяти, то вы не контролируете,
[01:37:32.200 --> 01:37:41.240]  значит, механизм trycatch, конечно, не поможет вам спастись от того, что вас убьют за это, вот,
[01:37:41.560 --> 01:37:48.520]  поймать можно только то, что брошено, собственно, из кода c++, а не то, что там процессор понял,
[01:37:48.520 --> 01:37:55.240]  что память вам там или деление на ноль случилось, и он такой все, операционная система завершает эту
[01:37:55.240 --> 01:38:03.160]  лавочку, закрывай, вот, поэтому вот это главное, надо понимать, что то, что вы кидаете,
[01:38:03.160 --> 01:38:13.720]  короче, trycatch можно поймать далеко не все, вот segfault нельзя, с другой стороны, не всякое
[01:38:13.720 --> 01:38:22.360]  исключение, это runtime error, иногда исключение используют не для того, чтобы ошибку сгенерировать,
[01:38:22.360 --> 01:38:26.440]  а для каких-то странных сценариев, например, выйти из глубокого цикла можно с помощью
[01:38:26.440 --> 01:38:32.560]  exception, вот, но это такое извращение немножко, не советую вам так делать, покот стайлу, наверное,
[01:38:32.560 --> 01:38:40.480]  не стоит, даже не знаю, что лучше, честно говоря, но говорят лучше go to, я не знаю,
[01:38:40.480 --> 01:38:47.800]  что из этого больше зло, не знаешь и хорошо, лучше не выходить из глубокого цикла вообще,
[01:38:47.800 --> 01:38:59.720]  значит, внезапно, ну, короче, спорный вопрос, дискуссионный, помните, я вам говорил, что в
[01:38:59.720 --> 01:39:05.960]  стандартной библиотеке есть в заголочном файле exception иерархии исключений, и там есть такой класс
[01:39:05.960 --> 01:39:13.480]  std runtime error, вот, он еще сильнее запутывает дело, потому что вот этот класс std runtime error,
[01:39:13.480 --> 01:39:25.120]  он, ну, это некоторый подвид exception, но, как вы теперь понимаете, это лишь абстракция уровня
[01:39:25.120 --> 01:39:31.840]  языка c++, и это далеко не все возможные runtime error, т.е. segfold и division-based это, конечно,
[01:39:31.840 --> 01:39:37.200]  не какой-нибудь std runtime error, это исключение с точки зрения операционной системы и процессора,
[01:39:37.200 --> 01:39:43.080]  но не с точки зрения c++, а класс std runtime error нужен лишь для того, чтобы удобно представлять
[01:39:43.080 --> 01:39:51.280]  некоторые подвиды runtime error, которые вы бросаете сами, вот, тем не менее, есть некоторые функции,
[01:39:51.680 --> 01:39:57.520]  стандартные, операторы, встроенные в язык, в языке c++, которые такие бросают исключения,
[01:39:57.520 --> 01:40:07.600]  именно в терминах c++ исключения, что это за, ну, таких операторов два, вот, какие это операторы,
[01:40:07.600 --> 01:40:19.120]  мы уже, да, какие, да, new, во-первых, оператор new, значит, нет, delete исключений не бросает,
[01:40:19.120 --> 01:40:25.880]  delete может только double free or corruption произойти из-за него, но исключений у delete повода не
[01:40:25.880 --> 01:40:35.800]  бросать, значит, оператор new, почему он бросает исключения, да, если операционная система не дала
[01:40:35.800 --> 01:40:43.000]  памяти, сколько вы попросили, то что делать оператору new в такой ситуации, ну, он теоретически
[01:40:43.000 --> 01:40:51.560]  мог бы вернуть nullptr, но это как-то на C становится похоже, зачем нам так делать, если мы только что
[01:40:51.560 --> 01:40:55.040]  тут разговаривали, что, в общем-то, мы пытались уйти от этого, то есть, представьте, вам каждый
[01:40:55.040 --> 01:41:01.880]  раз после вызова new надо было проверять if не nullptr, то там что-то там дальше идет, вот, но это
[01:41:01.880 --> 01:41:08.120]  C-шный подход, то есть, если вы пишете на C, то это нормальный подход, а когда вы пишете на плюсах,
[01:41:08.120 --> 01:41:13.560]  вот весь этот механизм исключений придуман для того, чтобы вам так не делать, вот, и поэтому оператор
[01:41:13.560 --> 01:41:17.960]  new, поэтому вам не надо проверять возвращаемое значение оператора new, если у вас так вышло,
[01:41:17.960 --> 01:41:23.400]  что операционная система не дала выделить память, то у вас вылетит исключение, и если вы хотите,
[01:41:23.400 --> 01:41:27.560]  вы можете его где-то там обработать на верхнем уровне вашей программы, но в подавляющем большинстве
[01:41:27.560 --> 01:41:32.040]  случаев, если у вас вылетело это исключение, то вы уже ничего не можете сделать, ну, у вас память
[01:41:32.040 --> 01:41:38.200]  закончилась, что тут сделаешь, вы падаете, вот, но зато вам не надо проверять на nullptr каждый раз,
[01:41:38.200 --> 01:41:43.640]  представьте, каждый раз после new надо было бы ефать, чтобы код был безопасным, но это не очень,
[01:41:43.640 --> 01:41:48.840]  поэтому new по умолчанию кидает исключение, если не удалось выделить память, оно кидает
[01:41:48.840 --> 01:42:00.280]  исключение, которое имеет тип std bad alloc, ага, у кого-то начинает происходить паззл складываться,
[01:42:00.280 --> 01:42:07.440]  катарсис в голове случается, мини катарсис, да, я вот, поэтому я тогда и удивился, у вас у кого-то
[01:42:07.440 --> 01:42:20.640]  нет, а то и это вообще стишная функция, какое там может быть исключение, я имею в виду исключение
[01:42:20.640 --> 01:42:24.720]  в операторах, это stoi, это библиотечная функция, понятно, что многие библиотечные функции кидают
[01:42:24.720 --> 01:42:30.820]  исключение, ну да, stoi тоже кидает исключение, оно кидает исключение, кстати, я не помню какого
[01:42:30.820 --> 01:42:37.240]  типа, да, stoi, если у нее не получилось перевести строку в число, то какое-то исключение кидается,
[01:42:37.240 --> 01:42:42.480]  но я не помню какой тип у него, ну да, stoi кидает исключение, вот a to i не кидает исключение,
[01:42:42.480 --> 01:42:48.960]  потому что стишная функция, там нужно ефать, получилось ли привести, а stoi просто кинет
[01:42:48.960 --> 01:42:56.320]  исключение, если не получилось, вот, какой второй оператор, динамик каст, да, ну на самом деле
[01:42:56.320 --> 01:43:04.800]  три оператора кидают исключение, третий оператор это throw, да, но про него и так, да, вот, динамик
[01:43:04.800 --> 01:43:15.280]  каст еще кидает исключение, если вы делаете динамик каст к ссылке, то ему ничего, а каст неудачный,
[01:43:15.280 --> 01:43:19.320]  то ему ничего не остается, как бросить exception, ну потому что вернуть-то он ничего не может вам,
[01:43:19.320 --> 01:43:25.920]  он должен вернуть ссылку на derived, а оказался, что он не derived, что делать динамик каст, ну вариант
[01:43:25.920 --> 01:43:31.240]  один только, кинуть исключение, так вот, динамик каст в таких ситуациях кидает исключение std badcast,
[01:43:31.240 --> 01:43:50.720]  динамик каст к указателю вернет на lptr, если ты, да, если ты не хочешь, ну с динамик кастом у тебя
[01:43:50.720 --> 01:43:55.960]  есть выбор, ты либо хочешь связываться с исключением, либо нет, если ты хочешь использовать почему-то
[01:43:55.960 --> 01:44:00.840]  стишный подход и чтобы в твоей программе не было исключений вообще, то делай динамик каст к
[01:44:00.840 --> 01:44:08.920]  pointer и fi, если ты используешь исключение нормально, то делай к ссылке, на самом деле и у new есть
[01:44:08.920 --> 01:44:17.000]  способ сделать так, чтобы new не кидало исключение, есть такой так называемый no throw new, для этого
[01:44:17.000 --> 01:44:25.240]  надо написать new в скобочках std no throw, а дальше все как обычно new std no throw t от чего-то там,
[01:44:25.240 --> 01:44:35.680]  у new тоже есть не бросающая версия, оно все так же делает как обычный new, но просто в случае
[01:44:35.680 --> 01:44:46.080]  отказа памяти возвращать на lptr, ничего не кидает, не std new, оно все делает так же как и этот new,
[01:44:46.080 --> 01:44:50.680]  просто единственная разница, что не кидает исключение в случае отказа, возвращает на lptr,
[01:44:50.680 --> 01:44:57.500]  много в чем, например, в том, что возвращаемый тип это t звездочка, а не void звездочка, в том,
[01:44:57.500 --> 01:45:04.560]  что std new не вызывает никаких конструкторов, а этот вызывает, в том, что этот new использует
[01:45:04.560 --> 01:45:09.840]  new handler, если не получилось выделить память, там еще есть функция new handler,
[01:45:09.840 --> 01:45:16.240]  которую он может вызывать в случае нехватки памяти, короче много в чем, std new не умеет
[01:45:16.240 --> 01:45:26.240]  0 байт выделять, а этот new умеет, динамик к указателю возвращает на lptr, если не удалось,
[01:45:26.240 --> 01:45:33.240]  что кстати такое std no throw, это такой объект типа std no throw t, no throw t это такая пустая
[01:45:33.240 --> 01:45:42.000]  структура, у которой есть один глобальный объект, std no throw, и вот когда вы вызываете new от такого
[01:45:42.000 --> 01:45:48.000]  параметра, такого типа, то он понимает, что это не бросающий new и нужно другую версию, да, что?
[01:45:48.000 --> 01:45:55.040]  что значит выделить 0 байт? ну у new там есть такая особенность, что если просишь выделить 0 байт,
[01:45:55.040 --> 01:46:09.280]  он все равно выделяет 1, по-моему, ну если ты попросишь new типа, ну забейте, ну короче здесь,
[01:46:09.280 --> 01:46:24.280]  да, поэтому, да, ладно, так не получится 0 байт выделить, да, вот можно, есть еще треть,
[01:46:24.280 --> 01:46:31.080]  есть еще другой синтаксис, но забейте, это сложно слишком, потом как-нибудь, пока хватит этого,
[01:46:31.080 --> 01:46:49.840]  чего ты говоришь, ну вот если ты например напишешь new int в квадратных скобочках 0, то, по-моему,
[01:46:49.840 --> 01:47:00.600]  выделится, да, 1 int все равно, вот я не помню, потому что корректный вызов, он должен вернуть что-то,
[01:47:00.600 --> 01:47:20.800]  что-то легальное, ну а, ну вот, да, поэтому, ну вот, например, да, наверное, поэтому еще и да,
[01:47:20.800 --> 01:47:26.480]  потому что ему как минимум нужно сохранить число, где размер будет лежать, он же выделяет, да,
[01:47:26.480 --> 01:47:32.640]  он выделяет чуть больше, чем вы запросили элементов, давайте забьем, это несущественные детали,
[01:47:32.640 --> 01:47:42.200]  главное отличие в том, что он конструкторы вызывает от того, что вы выделили new, а сишный не вызывает,
[01:47:42.200 --> 01:47:48.720]  и еще его звездочку возвращает, ему нужно в байтах передавать, а new нужно передавать в штуках,
[01:47:48.720 --> 01:47:54.240]  и кастовать от молока нужно возвращаем и тип указательного то, что надо, вот это,
[01:47:54.240 --> 01:48:03.200]  все давайте дальше, я не готов, это у нас целая, мы сейчас очень глубоко залезем,
[01:48:03.200 --> 01:48:10.760]  к поинтеру кастовать просто, да,
[01:48:19.160 --> 01:48:32.280]  ну в этом и смысл try, что если в нем происходит throw, то ты попадаешь в catch, ближайший, если ты
[01:48:32.280 --> 01:48:39.000]  не уверен, что в try у тебя все будет хорошо, то ты, для этого try существует, что если в нем throw
[01:48:39.000 --> 01:48:48.360]  произошел, ты в catch попал, а не упал, а какие есть библиотечные функции, которые кидают
[01:48:48.360 --> 01:48:52.960]  исключения, ну вот вы знаете, например, да, что квадратные скобочки, обращение квадратными
[01:48:52.960 --> 01:49:03.760]  скобочками, что к строке, что к вектору исключения не кидает, зато есть метод add, вот у всех контейнеров
[01:49:03.760 --> 01:49:10.040]  вы могли видеть есть метод add, который отличается от квадратных скобочек тем, что он проверяет,
[01:49:10.040 --> 01:49:18.200]  не вышли ли вы за границу, если вышли, то кидает стд out of range, вопрос зачем нужно и то и другое
[01:49:18.200 --> 01:49:30.320]  одновременно, да, да, значит, если вы по какой-то причине не уверены, что у вас нет выхода за
[01:49:30.320 --> 01:49:34.400]  границу и вы хотите, чтобы у вас дополнительная проверка здесь случилась, то вызывайте add,
[01:49:34.400 --> 01:49:43.240]  тогда у вас будет, ну вот как, например, проверить, вот у вас падает что-то с segfault, в RE у вас
[01:49:43.240 --> 01:49:49.280]  получается происходит segfault, просто замените в своем коде все вызовы квадратных скобочек на
[01:49:49.280 --> 01:49:56.600]  вызовы add, и тогда вы, ну если вы векторами пользуетесь, если вы используете контейнеры,
[01:49:56.600 --> 01:50:02.600]  и вы, значит, у вас что-то падает, вот, и вы хотите понять это segfault из-за чего, вот можете
[01:50:02.600 --> 01:50:08.680]  заменить в своей программе все вызовы квадратных скобочек на add, и тогда у вас вердикт изменится,
[01:50:08.680 --> 01:50:15.080]  у вас не segfault будет выведено, а будет написано terminate after fraud instance of std out of range,
[01:50:15.080 --> 01:50:20.480]  и вы такие, ага, понятно, значит это я вышел за границу, вот поэтому у меня segfault, вот поэтому
[01:50:20.480 --> 01:50:42.200]  я упал, вот, да. А будет написано строка? Нет, это слишком много. В C++23 собираются добавить,
[01:50:42.200 --> 01:50:53.720]  или уже вроде как решили добавить стандартную функцию std stack trace, чтобы вы могли из кетча
[01:50:53.720 --> 01:51:07.640]  увидеть из какой функции вы сюда попали, вот, значит наш коллега Антон Полухин из Яндекса вот
[01:51:07.640 --> 01:51:16.320]  написал, реализовал этот механизм, по-моему это он его реализовал по большей части, и вот вроде
[01:51:16.320 --> 01:51:23.880]  как его одобрили стандарт включить, но я не уверен, что они в 23 его включат, вроде как частично
[01:51:23.880 --> 01:51:31.440]  собираются включить стд stack trace в 23 стандарт, но если не успеют, то в 26 включат, вот, чтобы можно
[01:51:31.440 --> 01:51:53.680]  было там в определенном формате видеть, как вы сюда попали, грубо говоря. Так, конечно можем,
[01:51:53.680 --> 01:51:59.880]  иначе какой смысл кидания, я об этом рассказываю, что вот эти операторы кидают исключения, разумеется.
[01:51:59.880 --> 01:52:14.920]  Разумеется, да. Terminate called after fraud instance of int, aborted core dumped.
[01:52:14.920 --> 01:52:32.040]  Ладно, давайте дальше. А вот дальше я перейду на проектор.
[01:52:32.040 --> 01:53:00.960]  В смысле какого числа или что? Ой, ну я не помню. Ну, там, ну ты, это зависит от того,
[01:53:00.960 --> 01:53:09.040]  насколько они быстро все успевают делать. Сначала происходит feature freeze, так называемый,
[01:53:09.040 --> 01:53:16.480]  потом они активно работают на тем, чтобы стандарт официальный записать, а потом еще пару лет
[01:53:16.480 --> 01:53:22.280]  после этого компиляторы мучаются с тем, чтобы это поддержать. Вот, на самом деле в комитете сидят
[01:53:22.280 --> 01:53:28.880]  основные разработчики компиляторов, то есть там люди, которые там ключевую роль играют в разработке
[01:53:28.880 --> 01:53:35.960]  G++ и в разработке Selengo, да и MSWC тоже, наверное, они сидят в комитете, то есть они, скажем так,
[01:53:35.960 --> 01:53:43.040]  иногда они блокируют принятие каких-то решений, потому что они говорят, пацаны, нет, вы с ума сошли,
[01:53:43.040 --> 01:53:50.240]  это нереально поддержать, вот, и по этой причине там некоторые вещи не добавляются, допустим. Так,
[01:53:50.240 --> 01:54:20.080]  ну что ж. Ой. А, наверное, все, микрофон можно снимать мне. Мне кажется,
[01:54:20.080 --> 01:54:45.680]  что я уже... А, кстати, я вас, кажется, обманул, точнее, не обманул, а немножко не договорил,
[01:54:45.680 --> 01:54:53.480]  потому что еще оператор TypeID может кидать исключение. Dynamic Cast и TypeID может кидать
[01:54:53.480 --> 01:55:23.440]  исключение. По-моему. Вот. Если выражение, которое, да, значит, если вы взяли TypeID,
[01:55:23.440 --> 01:55:32.760]  от разыменования какого-то поинтера, а поинтер был null-поинтером, то тогда будет исключение типа
[01:55:32.760 --> 01:55:51.360]  std badtypeid до C++14, а начиная C++14 type matching handlers of type std badtypeid. Ну, исключение типа не
[01:55:51.360 --> 01:55:57.640]  в точности std badtypeid, а какого-то, возможно, наследника от него, но такое, что его можно поймать
[01:55:57.640 --> 01:56:04.680]  по std badtypeid. Будет брошено. Что-то сказано. Зачем это так написали, не знаю, не спрашивайте. Ну,
[01:56:04.680 --> 01:56:10.880]  короче, еще есть один оператор, это TypeID, который может кидать исключение. Ну ладно, давайте теперь
[01:56:10.880 --> 01:56:27.320]  поговорим кое о чем. Уже на практике что-нибудь посмотрим. Вот. Параграф 7.3, давайте я назову его,
[01:56:27.320 --> 01:56:43.200]  ну как по-русски я его называю, более подробная, более подробный разговор о механизме бросания
[01:56:43.200 --> 01:57:10.320]  исключений. Ну давайте я напишу going deeper into exceptions throwing mechanism. Вот у меня есть какая-то функция,
[01:57:10.320 --> 01:57:19.600]  которая бросает исключение. Ну я тут какой-нибудь завожу x, не знаю, там что-нибудь ввожу с
[01:57:19.600 --> 01:57:34.200]  клавиатуры. Вот. И если, допустим, x там, не знаю, делится на два, то я решаю бросить что-нибудь. Ну,
[01:57:34.200 --> 01:57:45.520]  например, давайте я брошу какой-нибудь свой собственный тип. Вот у меня будет структура s,
[01:57:45.520 --> 01:57:57.640]  и она будет выводить разные сообщения, когда она создается. Значит, когда она создается,
[01:57:57.640 --> 01:58:08.560]  она будет писать кредат. Когда она копируется, она будет писать, что она скопировалась.
[01:58:08.560 --> 01:58:33.080]  Да, хорошо, ну давайте, я понял. Здесь-то пофигу. Нет, здесь тоже не пофигу, ну ладно. Здесь пофигу.
[01:58:33.080 --> 01:58:40.520]  Осуждаю. Ну нам не это читать, нам читать, что оно выводит. Это и так понятно. Ну и давайте,
[01:58:40.520 --> 01:58:54.280]  когда будет структура, будет выводиться, что... Да. Ну да, тут есть к чему придраться,
[01:58:54.280 --> 01:59:01.840]  с точки зрения кодстайла. Сейчас придет Федор. Не, сейчас вроде все-таки не придет. Если придет,
[01:59:01.840 --> 01:59:14.600]  я удивлюсь. Вот, значит, давайте я создам новую s, и тут буду ее ловить. Я напишу try,
[01:59:14.600 --> 01:59:24.960]  f, и вот здесь буду ловить s. Какой вопрос у вас сразу должен возникнуть? Проверка на то,
[01:59:24.960 --> 01:59:32.840]  насколько вы c++ программист. Что здесь первым делом нужно понять? Кэйч скопка открывается.
[01:59:32.840 --> 01:59:51.080]  Я собираюсь s поймать. s или s&% или const s&%? Это важный вопрос. Но мне ловить,
[01:59:51.080 --> 02:00:00.880]  здесь сюда принимать s по значению или по ссылке надо? Кэйч. Ну, наверное, по ссылке,
[02:00:00.880 --> 02:00:06.640]  потому что мы же не хотим лишнее копирование, правда? Если у нас уже сроу, то лишнее копирование
[02:00:06.640 --> 02:00:13.920]  текста нам не страшно. Ну это вот я бы вам так не сказал. Там еще раз выведется создан и будет
[02:00:13.920 --> 02:00:22.800]  отличный вопрос. Я сейчас собираюсь это выяснять. Вот давайте сейчас попробуем понять. Для начала
[02:00:22.800 --> 02:00:36.440]  просто посмотрим, что происходит, когда я его бросаю. Exception. Что мне там надо ввести? Один,
[02:00:36.920 --> 02:00:48.160]  да? Ага. Ну вот оно создалось, поймалось и уничтожилось. И все, ничего не произошло,
[02:00:48.160 --> 02:01:02.680]  интересно. А если бы я его по значению принял? Ну, как нетрудно догадаться, создалась бы копия
[02:01:02.680 --> 02:01:09.560]  локальная на время того кэйча. Потом бы уничтожилась копия, потом бы уничтожилась
[02:01:09.560 --> 02:01:18.680]  исходная. Вот. То есть на самом деле важно, вы ловите по значению или по ссылке. И понятно,
[02:01:18.680 --> 02:01:24.720]  что если я поймал по значению, то модификация вот этого того, что я поймал, не будет влиять на
[02:01:24.720 --> 02:01:31.560]  исходное. А если я поймал по ссылке, ну, например, если я поймал по обычной ссылке, то я отсюда
[02:01:31.560 --> 02:01:40.720]  могу поменять это S, и оно поменяет вот то самое исключение, которое летит там. Вот.
[02:01:40.720 --> 02:01:47.400]  Более подробно о механизме бросания исключений.
[02:02:01.560 --> 02:02:22.480]  Зачем, может быть, нужно принимать, ловить по значению, а не по ссылке? Не знаю. Ну, теоретически
[02:02:22.480 --> 02:02:27.280]  можно что делать. Допустим, у вас исключение хранит какую-то информацию. Допустим, у вас какая-то
[02:02:27.280 --> 02:02:31.680]  очень сложная ошибка, которую нужно частично обработать на одном уровне, частично обработать на
[02:02:31.680 --> 02:02:40.680]  другом уровне. Допустим, вы ее на каком-то уровне частично обработали и дальше бросили. А на более
[02:02:40.680 --> 02:02:49.720]  высоком уровне вы что-то еще доделали с ней. Вот. Тут самое время сказать о том, что значит дальше
[02:02:49.720 --> 02:02:58.120]  бросили. Дело в том, что то, что я поймал, я же могу дальше кинуть. Вот, смотрите, когда я нахожусь в
[02:02:58.120 --> 02:03:07.360]  кетче, у меня есть вариант снова написать throw, и если я поймал по ссылке, это будет означать,
[02:03:07.360 --> 02:03:16.080]  что я дальше кину ту же самую штуковину, которую я вот сейчас поймал. А если я поймал по значению,
[02:03:16.080 --> 02:03:23.680]  это будет означать, что я теперь решил кинуть уже новую штуку, которую я, ну вот свою копию
[02:03:23.680 --> 02:03:32.880]  локальную я кидаю, а та должна уничтожиться, соответственно. У меня летело одно исключение. Дальше
[02:03:32.880 --> 02:03:43.280]  я его поймал по значению, то есть скопировал, пока когда ловил, и написал throw s. Это значит,
[02:03:43.280 --> 02:03:49.320]  что я теперь хочу, чтобы дальше летело вот то, что я поймал, копия, а то, соответственно,
[02:03:49.320 --> 02:04:02.360]  должно быть уничтожено. Ну конечно. Вот. Я могу это все снова обернуть в трай. Вот это я могу обернуть
[02:04:02.360 --> 02:04:22.400]  в трай. И тут еще раз поймать. Ну уничтожиться исходное. Ну давайте вот этой структуры будет
[02:04:22.400 --> 02:04:38.960]  еще какое-нибудь поле int x равно нулю. Вот. И я изначально здесь сделаю s. Нет, нельзя,
[02:04:38.960 --> 02:04:47.920]  потому что конструкторы кастомные. Ну вот так сделаю. Но тут я напишу cre этот и еще какой x.
[02:04:47.920 --> 02:05:04.000]  Вот. А так, тут мне тогда надо тоже x проинцелизировать тем. Вот. Ну и давайте,
[02:05:04.000 --> 02:05:10.520]  когда я здесь буду бросать, я вот этому s что-нибудь поменяю. s.x будет равно двойке,
[02:05:10.520 --> 02:05:17.480]  а тут s от единицы сконструирую. Вот. И тут я выведу, вот тут я выведу, что поймалось,
[02:05:17.480 --> 02:05:37.920]  код значит s.x. И тут я снова выведу, что поймалось. И в деструктуре я еще буду писать,
[02:05:37.920 --> 02:05:48.080]  что уничтожилось сейчас. Вот. Ну сейчас мы увидим с вами, в общем-то, тут ничего особенного,
[02:05:48.080 --> 02:06:04.680]  неожиданного мы не увидим. Ну что сейчас произойдет? Значит, создалось первое. Что? Так, подождите. Так,
[02:06:04.680 --> 02:06:13.160]  нет, что-то я не понял. Сейчас, подождите. Так, что пошло не так? Чего? Как у нас, как у нас
[02:06:13.160 --> 02:06:21.360]  сначала уничтожилось, а потом поймалось? Это не важно. Да-да-да, вот это меня что-то как-то очень
[02:06:21.960 --> 02:06:32.080]  уничтожилось. Уничтожилась структура с таким полем, а не сама. Это логично. Нет. Может быть,
[02:06:32.080 --> 02:06:40.160]  переходе копируется? Да, нет, все нормально. Да, смотрите, смотрите, смотрите, да, все, я что-то
[02:06:40.160 --> 02:06:48.040]  затупил. Все правильно, он просто копируется, когда кидается. Смотрите, что происходит. Ну давайте
[02:06:48.120 --> 02:06:55.520]  разберемся. Сначала создалось первое. Ну понятно, вот здесь создалось. Мы прилетели сюда, и когда мы
[02:06:55.520 --> 02:07:06.000]  его поймали, оно скопировалось. Скопировалось. Дальше. Вывелось, что поймалось первое, вот один. А
[02:07:06.000 --> 02:07:12.120]  дальше снова скопировалось. А почему снова скопировалось? Да потому, что вот это исключение,
[02:07:12.120 --> 02:07:41.920]  которое мы сейчас кидаем, оно лежит на стеке, которое мы сейчас поймали, оно на стеке лежит, мы же в кетче создали локальную копию, а то, что мы кидаем, оно же не на стеке должно лежать, а где-то в другом месте, потому что мы, ну, со стек сейчас всё снимется, поэтому мы должны его ещё раз скопировать и положить куда-то в другое место памяти, где будет оно храниться, пока мы дальше летим.
[02:07:42.120 --> 02:08:01.920]  Поэтому происходит копия, вот, а уничтожается наша локальная переменная, которую мы только что поймали, после чего уничтожается исходное исключение, потому что мы его обработали, и остаётся существовать то второе, которое мы создали.
[02:08:01.920 --> 02:08:12.720]  И вот, наконец, уже когда мы его поймали тут, оно поймано и потом уничтожено. Вот такой сценарий.
[02:08:12.720 --> 02:08:15.720]  Ты сказал, локально уничтожается?
[02:08:15.720 --> 02:08:24.720]  Да, конечно, мне нужно уничтожить локальную копию, прежде чем я брошу, ну, мне нужно скопировать её куда-то, где хранятся исключения.
[02:08:25.520 --> 02:08:40.520]  Вот, мы приходим к вопросу, а где они хранятся? Вот есть у меня есть локальная переменная, которую я бросаю, она не в чистом виде бросается, она копируется, кладётся в какое-то специальное место памяти и бросается оттуда.
[02:08:40.520 --> 02:08:42.520]  Ну, и как бы вот это называется, она брошена.
[02:08:42.520 --> 02:08:46.520]  Почему нельзя просто бросить вот локальную переменную?
[02:08:47.320 --> 02:09:01.320]  На самом деле, если я вот здесь вот напишу s, там s от единицы, и здесь напишу throw s, мы увидим, что сейчас ещё одна копия создаётся.
[02:09:02.120 --> 02:09:21.120]  Смотрите, что происходит. Я вот создал локальную s и бросил её. И когда я пришёл вот сюда, она дважды скопировалась уже к этому моменту.
[02:09:21.120 --> 02:09:27.120]  Первый раз она скопировалась со стека в специальной области памяти, где хранятся исключения, чтобы быть брошенной.
[02:09:27.920 --> 02:09:31.920]  Второй раз она скопировалась из той области памяти на стек вот сюда, чтобы быть пойманной.
[02:09:38.920 --> 02:09:41.920]  Если бы здесь стояла ссылка, то второго копирования бы не было.
[02:09:42.720 --> 02:09:47.720]  А в какой момент умрёт которая была брожена?
[02:09:47.720 --> 02:09:50.720]  Когда закроется вот этот кетч?
[02:09:52.720 --> 02:10:04.720]  Да, когда мы выходим из кетч, по общему правилу, сначала уничтожается вся локальная переменная, потом уничтожается собственно исключение, которое мы обрабатывали только что.
[02:10:04.720 --> 02:10:10.720]  А вообще, имеет смысл принимать что-то по мне, по ссылке, если оно всё время копируется?
[02:10:11.520 --> 02:10:14.520]  Ну, не знаю.
[02:10:14.520 --> 02:10:18.520]  Видимо нет, потому что так или иначе может быть лишний копирование сделать непонятно ради чего.
[02:10:18.520 --> 02:10:23.520]  Может быть. Я не знаю, может такие случаи бывают, но вот работает так.
[02:10:23.520 --> 02:10:26.520]  Хочется тебе говорить, если R-логики работают, то может быть это полезно.
[02:10:26.520 --> 02:10:27.520]  Что?
[02:10:27.520 --> 02:10:30.520]  Что если мы Константу примем по ссылке?
[02:10:30.520 --> 02:10:31.520]  Константу?
[02:10:31.520 --> 02:10:32.520]  Да.
[02:10:32.520 --> 02:10:36.520]  Ну, как всегда, что если ты Константу функцию передашь по ссылке?
[02:10:36.520 --> 02:10:37.520]  Точно то же самое.
[02:10:38.320 --> 02:10:39.320]  Что?
[02:10:40.320 --> 02:10:41.320]  Какой УБ?
[02:10:41.320 --> 02:10:43.320]  Константу ты можешь...
[02:10:43.320 --> 02:10:47.320]  Функцию передашь Константу, ты можешь принять её по Константной ссылке.
[02:10:47.320 --> 02:10:50.320]  Нет, если я приму не по Константной ссылке.
[02:10:50.320 --> 02:10:54.320]  ЦЕ, нельзя кастовать С к См персанду.
[02:10:54.320 --> 02:10:55.320]  Ну, как?
[02:10:55.320 --> 02:10:58.320]  Что если ты Константу дашь функцию по не Константной ссылке?
[02:10:58.320 --> 02:10:59.320]  Конечно же ЦЕ.
[02:10:59.320 --> 02:11:05.320]  Может ему просто прошло и сказал, этот кетч мы не работаем, мы работаем на следующем.
[02:11:06.120 --> 02:11:07.120]  Кстати...
[02:11:08.120 --> 02:11:10.120]  Кстати, да, это просто было бы...
[02:11:10.120 --> 02:11:12.120]  Ну, оно бы просто не подошло сюда.
[02:11:12.120 --> 02:11:15.120]  Здесь бы не было ЦЕ, это я неправильно сказал, потому что...
[02:11:15.120 --> 02:11:17.120]  Просто он бы увидел, ну давайте...
[02:11:17.120 --> 02:11:19.120]  Давайте я так сделаю тогда.
[02:11:19.120 --> 02:11:24.120]  Оно бы просто не подошло по типу, поэтому он бы ничего не поймал.
[02:11:24.120 --> 02:11:25.120]  Правильно?
[02:11:25.120 --> 02:11:26.120]  Логично?
[02:11:26.120 --> 02:11:27.120]  Сейчас точно что-то пойдёт.
[02:11:27.120 --> 02:11:28.120]  Может скопируется?
[02:11:28.120 --> 02:11:29.120]  Нет.
[02:11:29.120 --> 02:11:30.120]  Что?
[02:11:30.120 --> 02:11:31.120]  У нас сейчас будет terminate?
[02:11:31.120 --> 02:11:32.120]  Или у нас...
[02:11:32.120 --> 02:11:33.120]  У нас не будет кодку.
[02:11:33.120 --> 02:11:35.120]  Тут обычная штука, у второго нет.
[02:11:35.920 --> 02:11:37.920]  Да, нас убьёт из мэна.
[02:11:37.920 --> 02:11:38.920]  Да, нас убьёт из мэна.
[02:11:38.920 --> 02:11:39.920]  Мать его.
[02:11:39.920 --> 02:11:40.920]  Чего?
[02:11:40.920 --> 02:11:42.920]  Вот, кстати, не очевидно, что сейчас будет, да.
[02:11:42.920 --> 02:11:44.920]  Зря я...
[02:11:44.920 --> 02:11:46.920]  Вопрос-то интересный, на самом деле.
[02:11:46.920 --> 02:11:48.920]  Зря я, значит, фейспаунд делал.
[02:11:48.920 --> 02:11:50.920]  Да, вопрос-то интересный.
[02:11:50.920 --> 02:11:51.920]  Давай запустим.
[02:11:51.920 --> 02:11:56.920]  Кажется, он что поймает, потому что когда он скопировал, он же...
[02:11:56.920 --> 02:11:58.920]  Убил Константность?
[02:11:58.920 --> 02:12:00.920]  Да, вот, исчезла ли Константность?
[02:12:00.920 --> 02:12:02.920]  То есть при любом втором...
[02:12:02.920 --> 02:12:04.920]  Ну, при кодировании должна исчезла.
[02:12:08.920 --> 02:12:09.920]  Ну, чем он Константность?
[02:12:09.920 --> 02:12:10.920]  По приколу.
[02:12:10.920 --> 02:12:12.920]  Потому что в АТ был такой исчез.
[02:12:12.920 --> 02:12:13.920]  Думаю, что...
[02:12:13.920 --> 02:12:15.920]  Ну, не знаю, я ставлю на то, что не поймает.
[02:12:15.920 --> 02:12:16.920]  Давайте проверим.
[02:12:16.920 --> 02:12:17.920]  Какой отбивал?
[02:12:17.920 --> 02:12:18.920]  Мне кажется, поймал.
[02:12:18.920 --> 02:12:19.920]  Нет, поймал.
[02:12:19.920 --> 02:12:22.920]  Ну, значит, Константность уничтожается, когда он скопировал, да.
[02:12:23.920 --> 02:12:26.920]  А ты думаешь, и terminate поймали, и Cine не поймали?
[02:12:26.920 --> 02:12:27.920]  Нет, всё мы поймали.
[02:12:27.920 --> 02:12:28.920]  Просто он создал копию.
[02:12:28.920 --> 02:12:33.920]  И эта копия уже лежит не являющейся Константой.
[02:12:33.920 --> 02:12:35.920]  И мы её ловим по неконстантной ссылке.
[02:12:44.920 --> 02:12:46.920]  А вот если я так сделаю...
[02:12:46.920 --> 02:12:47.920]  Ща, подожди.
[02:12:48.920 --> 02:12:49.920]  Эм...
[02:12:51.920 --> 02:12:52.920]  Консткаст.
[02:12:53.920 --> 02:12:54.920]  А, он снимает.
[02:12:55.920 --> 02:12:56.920]  Статиккаст.
[02:12:57.920 --> 02:12:59.920]  Нет, мне кажется, так я не смогу сделать.
[02:12:59.920 --> 02:13:01.920]  Потому что он всё равно скопирует.
[02:13:02.920 --> 02:13:03.920]  В общем, не получится.
[02:13:03.920 --> 02:13:05.920]  Короче, Константность снимается.
[02:13:06.920 --> 02:13:07.920]  Что вы говорили?
[02:13:07.920 --> 02:13:10.920]  Ну, когда мы просто кодируем язык единицы.
[02:13:10.920 --> 02:13:12.920]  Он же, по сути, локально должен был создать язык единицы.
[02:13:12.920 --> 02:13:15.920]  Потом его, получается, скопирует в это место, где...
[02:13:15.920 --> 02:13:16.920]  Да.
[02:13:17.920 --> 02:13:19.920]  Ну, тогда там ещё должна была быть ещё одна копия,
[02:13:19.920 --> 02:13:21.920]  когда он просто S от единицы писал.
[02:13:21.920 --> 02:13:22.920]  Почему её не было?
[02:13:22.920 --> 02:13:23.920]  Где?
[02:13:23.920 --> 02:13:24.920]  Ничего не понял.
[02:13:24.920 --> 02:13:25.920]  Вот здесь.
[02:13:25.920 --> 02:13:26.920]  Если мы сделаем throw S от единицы,
[02:13:26.920 --> 02:13:27.920]  он же не будет создавать копию?
[02:13:27.920 --> 02:13:28.920]  Не будет.
[02:13:28.920 --> 02:13:29.920]  Почему?
[02:13:29.920 --> 02:13:31.920]  Он сразу может это создать не на стеке,
[02:13:31.920 --> 02:13:33.920]  а в той области, которая...
[02:13:33.920 --> 02:13:34.920]  Нужна.
[02:13:34.920 --> 02:13:35.920]  А, то есть это...
[02:13:35.920 --> 02:13:37.920]  Он не заводит эту переменную на стеке просто.
[02:13:37.920 --> 02:13:39.920]  Он сразу её кладёт куда надо,
[02:13:39.920 --> 02:13:42.920]  если я не завожу локальную переменную с таким названием.
[02:13:42.920 --> 02:13:43.920]  Это называется RVO.
[02:13:43.920 --> 02:13:44.920]  Return value optimization.
[02:13:44.920 --> 02:13:47.920]  Это то же самое, что у вас в BigInteger было у некоторых.
[02:13:47.920 --> 02:13:48.920]  И в строке.
[02:13:51.920 --> 02:13:53.920]  Лишнюю копию он в этом случае не делает.
[02:13:53.920 --> 02:13:56.920]  А вот в этом случае он уже обязан сделать копию,
[02:13:56.920 --> 02:13:58.920]  потому что вы завели локальную S,
[02:13:58.920 --> 02:13:59.920]  а потом...
[02:14:02.920 --> 02:14:03.920]  Ну, скопировали её.
[02:14:03.920 --> 02:14:04.920]  Вопрос!
[02:14:04.920 --> 02:14:06.920]  А где же она хранится-то?
[02:14:06.920 --> 02:14:08.920]  Ну, не на стеке, а где?
[02:14:10.920 --> 02:14:11.920]  В динамической памяти?
[02:14:12.920 --> 02:14:14.920]  Если указатель вывести, то там какой-то...
[02:14:14.920 --> 02:14:16.920]  Давайте попробуем вывести...
[02:14:17.920 --> 02:14:18.920]  Вот здесь вот...
[02:14:20.920 --> 02:14:21.920]  Адрес...
[02:14:21.920 --> 02:14:22.920]  S.
[02:14:26.920 --> 02:14:28.920]  И тут вывести адрес S.
[02:14:41.920 --> 02:14:44.920]  Вот, ну, вы можете заметить, что...
[02:14:50.920 --> 02:14:52.920]  Адрес начинается с пятёрки.
[02:14:52.920 --> 02:14:55.920]  Внимательные слушатели могли запомнить,
[02:14:55.920 --> 02:14:59.920]  что у меня адреса в динамической памяти начинаются с пятёрки обычно.
[02:15:03.920 --> 02:15:04.920]  То есть, смотрите,
[02:15:04.920 --> 02:15:06.920]  если я ловлю по ссылке,
[02:15:06.920 --> 02:15:09.920]  то у меня адрес, это 0x500,
[02:15:09.920 --> 02:15:12.920]  то у меня адрес, это 0x5 что-то там,
[02:15:12.920 --> 02:15:14.920]  а если я ловлю по значению,
[02:15:14.920 --> 02:15:18.920]  то у меня сейчас адрес будет уже 0x7 сколько-то.
[02:15:19.920 --> 02:15:22.920]  Ну вот, на моей системе адреса локальных переменных,
[02:15:22.920 --> 02:15:23.920]  как мы с вами уже неоднократно видели,
[02:15:23.920 --> 02:15:26.920]  они начинаются с 0x7f и так далее,
[02:15:26.920 --> 02:15:31.920]  а адреса в динамической памяти начинаются с 0x56 и так далее.
[02:15:32.920 --> 02:15:34.920]  Причём, смотрите, они вообще очень близкие.
[02:15:34.920 --> 02:15:36.920]  0x56, 0x14, 0x...
[02:15:36.920 --> 02:15:38.920]  Ну, то есть они...
[02:15:38.920 --> 02:15:40.920]  Начало вообще одинаковое,
[02:15:40.920 --> 02:15:43.920]  ab5800,
[02:15:43.920 --> 02:15:45.920]  а тут ab4eb0,
[02:15:45.920 --> 02:15:47.920]  то есть, на самом деле,
[02:15:47.920 --> 02:15:49.920]  реально, вот что этот new,
[02:15:49.920 --> 02:15:51.920]  что этот int,
[02:15:51.920 --> 02:15:53.920]  который я в динамической памяти выделил,
[02:15:53.920 --> 02:15:55.920]  что вот это исключение, они лежат рядом,
[02:15:55.920 --> 02:15:58.920]  то есть, они реально лежат в динамической памяти.
[02:16:00.920 --> 02:16:02.920]  То есть, на самом деле,
[02:16:02.920 --> 02:16:04.920]  когда исключение кидается,
[02:16:04.920 --> 02:16:06.920]  есть какая-то локация в динамической памяти,
[02:16:06.920 --> 02:16:08.920]  получается, под него.
[02:16:09.920 --> 02:16:10.920]  Так.
[02:16:10.920 --> 02:16:11.920]  Ты только что говорил о том,
[02:16:11.920 --> 02:16:12.920]  что семёрка там была,
[02:16:12.920 --> 02:16:14.920]  если я заменить посылки и на...
[02:16:14.920 --> 02:16:16.920]  Ну вот, я сейчас...
[02:16:16.920 --> 02:16:18.920]  Сначала я вывожу адрес
[02:16:18.920 --> 02:16:20.920]  указателей из динамической памяти.
[02:16:20.920 --> 02:16:22.920]  0x56 там получается.
[02:16:22.920 --> 02:16:25.920]  Потом я вот этого s увожу адрес.
[02:16:25.920 --> 02:16:27.920]  А потом вот этого s увожу адрес.
[02:16:27.920 --> 02:16:29.920]  Да, ну у второго s 0.7.
[02:16:29.920 --> 02:16:31.920]  Да, а у третьего снова 0x5 сколько-то.
[02:16:31.920 --> 02:16:33.920]  Да, а второй s где лежит?
[02:16:33.920 --> 02:16:34.920]  На стеке.
[02:16:34.920 --> 02:16:35.920]  Я же локально...
[02:16:35.920 --> 02:16:36.920]  Я же по значению его принял,
[02:16:36.920 --> 02:16:38.920]  поэтому на стеке создалась копия.
[02:16:38.920 --> 02:16:40.920]  Вот этот s лежит на стеке,
[02:16:40.920 --> 02:16:41.920]  потому что он по значению принят.
[02:16:41.920 --> 02:16:42.920]  А вот этот s,
[02:16:42.920 --> 02:16:44.920]  это тот самый s из динамической памяти.
[02:16:45.920 --> 02:16:46.920]  Вот.
[02:16:46.920 --> 02:16:47.920]  А...
[02:16:48.920 --> 02:16:49.920]  Какой вопрос
[02:16:49.920 --> 02:16:51.920]  логично должен возникнуть следующим?
[02:16:51.920 --> 02:16:52.920]  Хорошо.
[02:16:52.920 --> 02:16:54.920]  Значит, исключения лежат в динамической памяти.
[02:16:58.920 --> 02:17:00.920]  Никакого у вас не возникает
[02:17:01.920 --> 02:17:03.920]  диссонанса от этого факта.
[02:17:03.920 --> 02:17:05.920]  Когда она освобождается?
[02:17:07.920 --> 02:17:08.920]  Типа кто их удаляет?
[02:17:08.920 --> 02:17:10.920]  Нет, удалять-то понятно,
[02:17:10.920 --> 02:17:11.920]  но когда исключение обрабатывается,
[02:17:11.920 --> 02:17:13.920]  тогда и освобождается динамическая память.
[02:17:14.920 --> 02:17:15.920]  А...
[02:17:15.920 --> 02:17:16.920]  Ничего вас, да, не смущает?
[02:17:16.920 --> 02:17:17.920]  Хорошо, напомните мне еще раз,
[02:17:17.920 --> 02:17:19.920]  кто кидает исключения, в каких случаях?
[02:17:19.920 --> 02:17:20.920]  А если у нас получился exception,
[02:17:20.920 --> 02:17:22.920]  за новоделение есть U?
[02:17:22.920 --> 02:17:23.920]  Молодец.
[02:17:23.920 --> 02:17:24.920]  Да, да.
[02:17:24.920 --> 02:17:26.920]  Вот именно этот вопрос я и ожидал.
[02:17:26.920 --> 02:17:27.920]  А если у нас B долог,
[02:17:27.920 --> 02:17:29.920]  то он где хранится?
[02:17:30.920 --> 02:17:31.920]  А...
[02:17:35.920 --> 02:17:36.920]  То есть, что происходит,
[02:17:36.920 --> 02:17:38.920]  если U не смогло выделить память?
[02:17:38.920 --> 02:17:40.920]  Он должен создать исключение B долог,
[02:17:40.920 --> 02:17:41.920]  на минуточку.
[02:17:41.920 --> 02:17:42.920]  А памяти-то нет.
[02:17:42.920 --> 02:17:43.920]  Памяти-то же...
[02:17:43.920 --> 02:17:44.920]  Памяти нет.
[02:17:44.920 --> 02:17:45.920]  Ну даже не через U.
[02:17:45.920 --> 02:17:46.920]  Можно у него всегда есть память
[02:17:46.920 --> 02:17:48.920]  под одному из B долога.
[02:17:49.920 --> 02:17:50.920]  Точно.
[02:17:51.920 --> 02:17:52.920]  Дорогая система,
[02:17:52.920 --> 02:17:53.920]  слезно прошу,
[02:17:53.920 --> 02:17:55.920]  выдели 16 баксов.
[02:17:55.920 --> 02:17:56.920]  Нет.
[02:17:59.920 --> 02:18:00.920]  Мне не подобно,
[02:18:00.920 --> 02:18:01.920]  честное слово.
[02:18:01.920 --> 02:18:02.920]  Вот примерно так.
[02:18:02.920 --> 02:18:05.920]  А можно эту память дать Сейки
[02:18:05.920 --> 02:18:06.920]  самому занятию?
[02:18:06.920 --> 02:18:07.920]  Нет.
[02:18:07.920 --> 02:18:08.920]  На самом деле,
[02:18:08.920 --> 02:18:11.920]  просто под B долог
[02:18:11.920 --> 02:18:14.920]  отдельно у компилятора
[02:18:14.920 --> 02:18:18.920]  есть так называемый emergency buffer.
[02:18:18.920 --> 02:18:20.920]  Значит, уфер для экстренных ситуаций,
[02:18:20.920 --> 02:18:22.920]  когда надо что-то куда-то положить,
[02:18:22.920 --> 02:18:23.920]  но некуда.
[02:18:23.920 --> 02:18:24.920]  Вот.
[02:18:24.920 --> 02:18:27.920]  И вот B долог обычно кладется туда.
[02:18:27.920 --> 02:18:29.920]  То есть если происходит B долог,
[02:18:29.920 --> 02:18:32.920]  то он создается вот в этом месте.
[02:18:32.920 --> 02:18:33.920]  Я не уверен,
[02:18:33.920 --> 02:18:35.920]  что я смогу вам продемонстрировать B долог,
[02:18:35.920 --> 02:18:36.920]  потому что...
[02:18:40.920 --> 02:18:42.920]  Я не хочу положить комп свой.
[02:18:42.920 --> 02:18:43.920]  Я просто не знаю.
[02:18:43.920 --> 02:18:44.920]  У меня много оперативки,
[02:18:44.920 --> 02:18:49.920]  если я запрошу сейчас 4 гигабайта.
[02:18:49.920 --> 02:18:50.920]  Запроси 40.
[02:18:50.920 --> 02:18:51.920]  Чего ты?
[02:18:51.920 --> 02:18:52.920]  Дайте ему 100 гигабайтов.
[02:18:52.920 --> 02:18:53.920]  А?
[02:18:53.920 --> 02:18:55.920]  Можно уже 100 гигабайт запросить.
[02:18:55.920 --> 02:18:59.920]  Да, но просто 100 гигабайт в Сайс Т не влезет.
[02:18:59.920 --> 02:19:01.920]  В смысле?
[02:19:01.920 --> 02:19:03.920]  Сайс Т же вы снимаете.
[02:19:03.920 --> 02:19:05.920]  Тогда может быть максимальный Сайс Т сделаем?
[02:19:05.920 --> 02:19:06.920]  Ладно, давайте...
[02:19:06.920 --> 02:19:08.920]  Мне сегодня кстати сон приснился...
[02:19:08.920 --> 02:19:09.920]  Почему в Сайс Т не влезет?
[02:19:09.920 --> 02:19:10.920]  Мне кстати сегодня сон приснился,
[02:19:10.920 --> 02:19:12.920]  что у меня ноут сломался.
[02:19:20.920 --> 02:19:22.920]  Ну давайте, значит, это был знак.
[02:19:22.920 --> 02:19:23.920]  Давайте я попробую.
[02:19:23.920 --> 02:19:24.920]  Ну короче, сейчас...
[02:19:24.920 --> 02:19:25.920]  Ну просто сейчас я,
[02:19:25.920 --> 02:19:27.920]  если его 100 раз попрошу по гигабайту выделить,
[02:19:27.920 --> 02:19:28.920]  то мы можем...
[02:19:28.920 --> 02:19:29.920]  У нас может все повиснуть.
[02:19:37.920 --> 02:19:38.920]  Ну давайте попробуем.
[02:19:38.920 --> 02:19:40.920]  Значит, int p...
[02:19:42.920 --> 02:19:44.920]  Значит, сколько мне надо?
[02:19:44.920 --> 02:19:45.920]  100...
[02:19:45.920 --> 02:19:47.920]  Ну давайте 50 гигабайт попрошу.
[02:19:48.920 --> 02:19:50.920]  Ньюинт...
[02:19:50.920 --> 02:19:52.920]  А, стоп, почему я здесь напишу?
[02:19:52.920 --> 02:19:53.920]  Да, мне надо...
[02:19:53.920 --> 02:19:55.920]  Просто int звездочка p...
[02:19:55.920 --> 02:19:56.920]  равно ньюинт...
[02:19:56.920 --> 02:19:57.920]  Так, минуточку, минуточку.
[02:19:57.920 --> 02:19:58.920]  Зачем 50?
[02:19:58.920 --> 02:19:59.920]  Если я хочу 100 гигабайт,
[02:19:59.920 --> 02:20:01.920]  то мне надо 25 миллиардов фунтов попросить.
[02:20:03.920 --> 02:20:06.920]  Вот, давайте я попробую вот так сделать.
[02:20:10.920 --> 02:20:13.920]  Ну если что, у меня доска есть.
[02:20:13.920 --> 02:20:15.920]  Ну что, не сделаешь рамку?
[02:20:16.920 --> 02:20:18.920]  Ну что не сделаешь ради науки?
[02:20:18.920 --> 02:20:19.920]  Значит, давайте, значит...
[02:20:19.920 --> 02:20:21.920]  Ну я поймаю просто std exception.
[02:20:24.920 --> 02:20:26.920]  И здесь выведу адрес.
[02:20:31.920 --> 02:20:33.920]  И здесь выведу, значит,
[02:20:33.920 --> 02:20:35.920]  ну адрес этого exception.
[02:20:39.920 --> 02:20:42.920]  Да, все стандартные exception являются частными случаями std exception.
[02:20:43.920 --> 02:20:45.920]  Вот, ну давайте я попробую так сделать.
[02:20:45.920 --> 02:20:48.920]  Да, ну и вот здесь я еще сделаю return сразу.
[02:20:48.920 --> 02:20:51.920]  Чтобы дальше не продолжать уже эту деятельность.
[02:20:55.920 --> 02:20:57.920]  А, я же из мейна возвращаюсь,
[02:20:57.920 --> 02:20:58.920]  значит, мне уже return ноль.
[02:20:58.920 --> 02:20:59.920]  Что нормально было?
[02:21:03.920 --> 02:21:04.920]  Что?
[02:21:04.920 --> 02:21:05.920]  Снизу.
[02:21:05.920 --> 02:21:06.920]  Не хочешь?
[02:21:11.920 --> 02:21:13.920]  Ну давайте попробуем.
[02:21:14.920 --> 02:21:16.920]  О, видите, все нормально,
[02:21:16.920 --> 02:21:18.920]  никто не умер.
[02:21:18.920 --> 02:21:19.920]  Вот.
[02:21:19.920 --> 02:21:21.920]  Система предотвратила.
[02:21:21.920 --> 02:21:23.920]  0x55a1.
[02:21:23.920 --> 02:21:25.920]  Ну вот, короче,
[02:21:25.920 --> 02:21:28.920]  оно лежит вроде не на стеке,
[02:21:28.920 --> 02:21:32.920]  но где-то в каком-то специальном месте.
[02:21:34.920 --> 02:21:37.920]  То есть, динамической памяти он не смог выделить,
[02:21:37.920 --> 02:21:40.920]  тем не менее, вот его куда-то в специальное место положил.
[02:21:40.920 --> 02:21:41.920]  Ну вот, значит,
[02:21:41.920 --> 02:21:44.920]  ну это то, что обычно у компиляторов называется emergency buffer,
[02:21:44.920 --> 02:21:45.920]  то есть,
[02:21:45.920 --> 02:21:48.920]  некоторое специальное место, где лежит вот этот вот B-даллог.
[02:21:52.920 --> 02:21:53.920]  Вот.
[02:21:53.920 --> 02:21:57.920]  Можно на stackoverflow, кстати, найти ответ,
[02:21:57.920 --> 02:22:00.920]  где подробно расскажется про этот механизм,
[02:22:00.920 --> 02:22:03.920]  как он кладет, куда он кладет B-даллог.
[02:22:04.920 --> 02:22:05.920]  Вот.
[02:22:05.920 --> 02:22:07.920]  Окей.
[02:22:10.920 --> 02:22:11.920]  Ну хорошо.
[02:22:14.920 --> 02:22:15.920]  Так.
[02:22:15.920 --> 02:22:16.920]  Дальше.
[02:22:17.920 --> 02:22:18.920]  Следующая история.
[02:22:18.920 --> 02:22:19.920]  Смотрите.
[02:22:26.920 --> 02:22:29.920]  Вот я здесь поймал std-exception,
[02:22:29.920 --> 02:22:32.920]  а брошен был std-b-dallog.
[02:22:32.920 --> 02:22:36.920]  То есть, это значит, что я поймал не совсем тот тип, который кинул.
[02:22:40.920 --> 02:22:44.920]  То есть, при кетче иногда бывают приведения типов.
[02:22:45.920 --> 02:22:50.920]  Но правила совсем другие, нежели приведения типов и перегрузки.
[02:22:52.920 --> 02:22:55.920]  Например, если я брошу int, то char я не поймаю,
[02:22:55.920 --> 02:22:57.920]  и double я не поймаю,
[02:22:57.920 --> 02:22:59.920]  и даже unsigned int я не поймаю.
[02:23:00.920 --> 02:23:02.920]  Вот давайте я попробую так сделать.
[02:23:02.920 --> 02:23:03.920]  Try.
[02:23:04.920 --> 02:23:06.920]  Throw 1.
[02:23:10.920 --> 02:23:12.920]  Да что ж такое.
[02:23:12.920 --> 02:23:14.920]  Catch int.
[02:23:20.920 --> 02:23:22.920]  Stash out 1.
[02:23:23.920 --> 02:23:26.920]  Вот если я здесь, допустим, напишу double,
[02:23:26.920 --> 02:23:28.920]  то я не поймаю сейчас ничего.
[02:23:28.920 --> 02:23:29.920]  Я упаду.
[02:23:34.920 --> 02:23:41.920]  Если бы я написал int, то, конечно же, я бы поймал.
[02:23:42.920 --> 02:23:44.920]  Но double я не поймаю.
[02:23:45.920 --> 02:23:47.920]  И даже unsigned int я не поймаю.
[02:23:50.920 --> 02:23:53.920]  Потому что после этого он пошел сюда,
[02:23:53.920 --> 02:23:55.920]  и дальше b-dallog стал заниматься.
[02:23:59.920 --> 02:24:01.920]  Но чтобы дальше не шел, давайте так сделаем.
[02:24:01.920 --> 02:24:03.920]  Вот, я сейчас кинул int.
[02:24:03.920 --> 02:24:05.920]  Поймаю ли я unsigned int? Нет.
[02:24:06.920 --> 02:24:10.920]  То есть даже приведения от int-a, unsigned int в кетче не делаются.
[02:24:10.920 --> 02:24:12.920]  У вас какая-то другая ошибка была.
[02:24:12.920 --> 02:24:13.920]  B-dallog.
[02:24:13.920 --> 02:24:14.920]  Нет.
[02:24:18.920 --> 02:24:21.920]  Я не поймал int, потому что я ловил unsigned int,
[02:24:21.920 --> 02:24:22.920]  а брошен был int.
[02:24:22.920 --> 02:24:25.920]  Это разные типы, и он не поймался.
[02:24:25.920 --> 02:24:31.920]  Тем не менее, если у меня был бы класс derived и base наследник derived,
[02:24:31.920 --> 02:24:35.920]  а я бы бросил derived, то по ссылке на base я бы поймал derived.
[02:24:36.920 --> 02:24:38.920]  Это просто не считается там кастом?
[02:24:38.920 --> 02:24:41.920]  Нет, это считается кастом, и это закастылина просто.
[02:24:41.920 --> 02:24:44.920]  Значит, в кетче не делаются касты, кроме
[02:24:46.920 --> 02:24:48.920]  каста от неконстанта к константе,
[02:24:48.920 --> 02:24:51.920]  а также каста от наследника к родителю.
[02:24:51.920 --> 02:24:53.920]  Можно вопрос чисто по идеологии.
[02:24:53.920 --> 02:24:56.920]  Насколько нормально в функции,
[02:24:56.920 --> 02:24:59.920]  которая какой-то базовый класс должна возвращать,
[02:24:59.920 --> 02:25:01.920]  писать просто return и class от наследника?
[02:25:03.920 --> 02:25:05.920]  Особенно если там поля просто совпадают.
[02:25:06.920 --> 02:25:08.920]  Чего return каст класс от наследника?
[02:25:08.920 --> 02:25:10.920]  В смысле, у нас вот есть два класса, base и derived.
[02:25:10.920 --> 02:25:12.920]  Есть функция, которая должна вернуть base.
[02:25:12.920 --> 02:25:14.920]  Она возвращает derived.
[02:25:14.920 --> 02:25:16.920]  Такое нормально писать или плохо?
[02:25:16.920 --> 02:25:17.920]  Зачем? Ну, бывает.
[02:25:17.920 --> 02:25:21.920]  Ну, потому что мне вот, например, в геоме иногда удобно вместо точки дектора.
[02:25:21.920 --> 02:25:23.920]  Давай потом, а?
[02:25:23.920 --> 02:25:25.920]  Вот сейчас давай про исключение.
[02:25:25.920 --> 02:25:27.920]  Давай про исключение, сейчас лучше говорить.
[02:25:27.920 --> 02:25:31.920]  Вот я сделал структуру base, а структуру derived наследницу base.
[02:25:31.920 --> 02:25:33.920]  Вот теперь я давайте создам,
[02:25:33.920 --> 02:25:35.920]  я давайте кину derived,
[02:25:38.920 --> 02:25:40.920]  а буду ловить base.
[02:25:40.920 --> 02:25:43.920]  Причем не важно, по значению я ловлю или по ссылке,
[02:25:43.920 --> 02:25:45.920]  я его поймаю.
[02:25:46.920 --> 02:25:49.920]  Вот каст от родителя к наследнику,
[02:25:49.920 --> 02:25:51.920]  от наследника к родителю работает в кетче,
[02:25:51.920 --> 02:25:53.920]  а другие касты не работают.
[02:25:54.920 --> 02:25:56.920]  Я также по константной ссылке могу поймать,
[02:25:56.920 --> 02:25:59.920]  то есть от неконстанты к константе тоже сработает каст,
[02:25:59.920 --> 02:26:02.920]  но другие касты не сработают.
[02:26:05.920 --> 02:26:07.920]  Вопрос на...
[02:26:10.920 --> 02:26:11.920]  Вопрос в телеси плюс-плюс.
[02:26:11.920 --> 02:26:13.920]  А если так, то что будет?
[02:26:14.920 --> 02:26:16.920]  Ну, я приватное наследование сделал.
[02:26:17.920 --> 02:26:19.920]  Поймаю или не поймаю?
[02:26:20.920 --> 02:26:22.920]  Наверное, не поймаю.
[02:26:22.920 --> 02:26:24.920]  Сейчас это ошибка.
[02:26:24.920 --> 02:26:28.920]  А потом, видимо, будет сообщение, что приватное наследование.
[02:26:30.920 --> 02:26:32.920]  Подожди, подожди.
[02:26:32.920 --> 02:26:34.920]  Давайте подумаем логикой.
[02:26:34.920 --> 02:26:36.920]  У нас private влияет только на CE.
[02:26:36.920 --> 02:26:40.920]  Да, потом это... когда потом получим?
[02:26:40.920 --> 02:26:42.920]  Мы в runtime-е ловим, уже там ничего нет.
[02:26:42.920 --> 02:26:44.920]  То есть вариантов на самом деле два.
[02:26:44.920 --> 02:26:46.920]  Либо мы просто не поймаем,
[02:26:46.920 --> 02:26:48.920]  либо будет сразу CE.
[02:26:48.920 --> 02:26:50.920]  Логично, чтобы не поймали.
[02:26:50.920 --> 02:26:52.920]  CE, по идее, не будет.
[02:26:52.920 --> 02:26:54.920]  Не, стоп, если она скомпилировалась,
[02:26:54.920 --> 02:26:56.920]  то у нас ведь правда, что дирают,
[02:26:56.920 --> 02:26:58.920]  это наследник BA.
[02:26:58.920 --> 02:27:00.920]  Почему правда?
[02:27:00.920 --> 02:27:02.920]  Он просто... почему?
[02:27:02.920 --> 02:27:04.920]  Ничего не понимаю.
[02:27:04.920 --> 02:27:06.920]  Я пока не компилировал.
[02:27:06.920 --> 02:27:08.920]  Вариантов два, либо будет CE, либо не поймается.
[02:27:08.920 --> 02:27:10.920]  В runtime-е у нас уже нет наследования
[02:27:10.920 --> 02:27:12.920]  и два независимых фаса.
[02:27:12.920 --> 02:27:14.920]  В runtime-е вообще нет типов.
[02:27:14.920 --> 02:27:16.920]  Да.
[02:27:18.920 --> 02:27:20.920]  В runtime-е есть только...
[02:27:20.920 --> 02:27:22.920]  В runtime-е есть как минимум cast динамик
[02:27:22.920 --> 02:27:24.920]  между типами.
[02:27:24.920 --> 02:27:26.920]  В runtime-е нет типов.
[02:27:26.920 --> 02:27:28.920]  Есть только числа,
[02:27:28.920 --> 02:27:30.920]  на которые процессор смотрит,
[02:27:30.920 --> 02:27:32.920]  и указатели, по которым он прыгает.
[02:27:32.920 --> 02:27:34.920]  И в зависимости от этого предпринимает какие-то другие действия над числами.
[02:27:34.920 --> 02:27:36.920]  Dynamic cast — это просто прыжок по указателю,
[02:27:36.920 --> 02:27:38.920]  на котором написан ИВчик,
[02:27:38.920 --> 02:27:40.920]  сравнение несколько байтиков.
[02:27:40.920 --> 02:27:42.920]  Значит, если они такие,
[02:27:42.920 --> 02:27:44.920]  то, по идее, вот эти байтики перезапиши,
[02:27:44.920 --> 02:27:46.920]  иначе другие байтики перезапиши и прыгни в другое место.
[02:27:46.920 --> 02:27:48.920]  Что?
[02:27:48.920 --> 02:27:50.920]  Ну, давайте. Кто считает, что будет CE?
[02:27:50.920 --> 02:27:52.920]  Давайте, давайте.
[02:27:52.920 --> 02:27:54.920]  А почему не может?
[02:27:54.920 --> 02:27:56.920]  Если у нас не поймают,
[02:27:56.920 --> 02:27:58.920]  то у нас не будет указатель
[02:27:58.920 --> 02:28:00.920]  из-за того, чтобы приватное наследование
[02:28:00.920 --> 02:28:02.920]  перебить такое.
[02:28:02.920 --> 02:28:04.920]  Так, кто считает?
[02:28:04.920 --> 02:28:06.920]  Твоя версия что будет?
[02:28:06.920 --> 02:28:08.920]  Что не поймает просто.
[02:28:08.920 --> 02:28:10.920]  А еще какие версии?
[02:28:12.920 --> 02:28:14.920]  Почему не может скомпилиться и поймать?
[02:28:14.920 --> 02:28:16.920]  Потому что тогда это нарушало бы
[02:28:16.920 --> 02:28:18.920]  идеологию приватного наследования.
[02:28:18.920 --> 02:28:20.920]  Я не должен
[02:28:20.920 --> 02:28:22.920]  извне класса derived
[02:28:22.920 --> 02:28:24.920]  знать, что Base — наследник derived.
[02:28:24.920 --> 02:28:28.920]  Когда я кидаю derived,
[02:28:28.920 --> 02:28:30.920]  я не ожидаю, что поймается Base.
[02:28:30.920 --> 02:28:32.920]  Я не должен знать, что Base — это родитель derived
[02:28:32.920 --> 02:28:34.920]  из Main.
[02:28:34.920 --> 02:28:36.920]  Вот.
[02:28:36.920 --> 02:28:38.920]  Ну, я
[02:28:38.920 --> 02:28:40.920]  кстати сам не уверен, но я думаю, что просто
[02:28:40.920 --> 02:28:42.920]  не поймается и все.
[02:28:42.920 --> 02:28:44.920]  Ну все, да, не поймалось.
[02:28:44.920 --> 02:28:46.920]  Ну, вроде логично.
[02:28:46.920 --> 02:28:48.920]  Ну да, это наиболее логично.
[02:28:48.920 --> 02:28:50.920]  Просто чисто логикой кажется, что нужно быть.
[02:28:50.920 --> 02:28:52.920]  Так это
[02:28:52.920 --> 02:28:54.920]  приватное наследование.
[02:28:54.920 --> 02:28:56.920]  Приватное наследование. Какой каст может быть
[02:28:56.920 --> 02:28:58.920]  если наследование приватное?
[02:28:58.920 --> 02:29:00.920]  Да, в этом весь вопрос, что наследование приватное.
[02:29:00.920 --> 02:29:02.920]  Ладно.
[02:29:02.920 --> 02:29:04.920]  Ну, следующий вопрос.
[02:29:04.920 --> 02:29:06.920]  Если у нас
[02:29:06.920 --> 02:29:08.920]  короче, может ли
[02:29:08.920 --> 02:29:10.920]  найти
[02:29:10.920 --> 02:29:12.920]  горизонтальный каст?
[02:29:12.920 --> 02:29:14.920]  Горизонтальный каст даже static
[02:29:14.920 --> 02:29:16.920]  кастом нельзя сделать.
[02:29:16.920 --> 02:29:18.920]  Какой горизонтальный каст
[02:29:18.920 --> 02:29:20.920]  может быть
[02:29:20.920 --> 02:29:22.920]  в compile-time?
[02:29:22.920 --> 02:29:24.920]  В compile-time никакого.
[02:29:24.920 --> 02:29:26.920]  Почему
[02:29:26.920 --> 02:29:28.920]  в compile-time?
[02:29:28.920 --> 02:29:30.920]  Потому что в какой кэч ты должен попасть,
[02:29:30.920 --> 02:29:32.920]  а этот компилятор должен в compile-time сгенерировать.
[02:29:36.920 --> 02:29:38.920]  Ну, потому что когда этот код транслируется
[02:29:38.920 --> 02:29:40.920]  в процессорной
[02:29:40.920 --> 02:29:42.920]  инструкции, компилятор уже в compile-time
[02:29:42.920 --> 02:29:44.920]  должен
[02:29:44.920 --> 02:29:46.920]  во что превращается throw?
[02:29:46.920 --> 02:29:48.920]  Оно превращается в
[02:29:48.920 --> 02:29:50.920]  если ты создай там
[02:29:50.920 --> 02:29:52.920]  вот эту штуку, а дальше начинаешь
[02:29:52.920 --> 02:29:54.920]  идти по стеку и смотреть
[02:29:56.920 --> 02:29:58.920]  дойти до сюда, и вот отсюда
[02:29:58.920 --> 02:30:00.920]  значит
[02:30:00.920 --> 02:30:02.920]  начни кэч делать.
[02:30:02.920 --> 02:30:04.920]  В compile-time ты должен
[02:30:08.920 --> 02:30:10.920]  уже знать, попадешь ты,
[02:30:10.920 --> 02:30:12.920]  можешь ли ты попасть сюда, если было брошено то
[02:30:12.920 --> 02:30:14.920]  или не можешь.
[02:30:18.920 --> 02:30:20.920]  Да не в этом дело, а в том,
[02:30:20.920 --> 02:30:22.920]  что ты заранее должен
[02:30:22.920 --> 02:30:24.920]  нагенерировать, будучи компилятором,
[02:30:24.920 --> 02:30:26.920]  ты должен заранее нагенерировать инструкции
[02:30:26.920 --> 02:30:28.920]  о том, в какой кэч ты теоретически
[02:30:28.920 --> 02:30:30.920]  можешь попасть, выпрыгнув отсюда.
[02:30:30.920 --> 02:30:32.920]  Мы могли бы их просто перебирать
[02:30:32.920 --> 02:30:34.920]  и для каждого проверять
[02:30:34.920 --> 02:30:36.920]  попадаем ли, но это будет просто долго.
[02:30:38.920 --> 02:30:40.920]  Ну да,
[02:30:40.920 --> 02:30:42.920]  с точки зрения реализации мы могли бы
[02:30:42.920 --> 02:30:44.920]  вызывать TypeID и сверять их.
[02:30:44.920 --> 02:30:46.920]  Нет, такого не будет.
[02:30:46.920 --> 02:30:48.920]  Просто потому что у нас может быть миллиард наследников
[02:30:48.920 --> 02:30:50.920]  и всех проверять долго.
[02:30:50.920 --> 02:30:52.920]  Причем даже не будет
[02:30:52.920 --> 02:30:54.920]  каста вниз, то есть каст вверх бывает,
[02:30:54.920 --> 02:30:56.920]  а каст вниз не бывает, конечно.
[02:30:56.920 --> 02:30:58.920]  Даже каст вниз не будет делаться,
[02:30:58.920 --> 02:31:00.920]  а вы говорите про каст вбок.
[02:31:00.920 --> 02:31:02.920]  Каст вниз...
[02:31:02.920 --> 02:31:04.920]  Господи, вот если здесь бейс,
[02:31:04.920 --> 02:31:06.920]  то вниз не будет ничего скастовано.
[02:31:10.920 --> 02:31:12.920]  А ты что хотел?
[02:31:12.920 --> 02:31:14.920]  А у нас тогда не произошло CE,
[02:31:14.920 --> 02:31:16.920]  потому что мы не довышали право доступа,
[02:31:16.920 --> 02:31:18.920]  мы ни к чему не обращались?
[02:31:18.920 --> 02:31:20.920]  Ну да, мы просто не поймали...
[02:31:20.920 --> 02:31:22.920]  Ну как, блин, вот окей.
[02:31:22.920 --> 02:31:24.920]  Вот ты используешь какой-нибудь контейнер
[02:31:24.920 --> 02:31:26.920]  из стандартной библиотеки,
[02:31:26.920 --> 02:31:28.920]  и решаешь, значит,
[02:31:28.920 --> 02:31:30.920]  делать try,
[02:31:30.920 --> 02:31:32.920]  какие-нибудь операции над этим контейнером,
[02:31:32.920 --> 02:31:34.920]  и в случае неудачи, например,
[02:31:34.920 --> 02:31:36.920]  бросаешь std string
[02:31:36.920 --> 02:31:38.920]  и ловишь разные типы.
[02:31:38.920 --> 02:31:40.920]  И вдруг чудесным образом,
[02:31:40.920 --> 02:31:42.920]  бросив std string, ты поймал std
[02:31:42.920 --> 02:31:44.920]  некоторую другую штуку,
[02:31:44.920 --> 02:31:46.920]  от которой наследуется std string
[02:31:46.920 --> 02:31:48.920]  приватно, просто был не в курсе.
[02:31:48.920 --> 02:31:50.920]  Это довольно странно.
[02:31:52.920 --> 02:31:54.920]  Вот, ты не должен был знать,
[02:31:54.920 --> 02:31:56.920]  что она наследник этой штуке.
[02:31:56.920 --> 02:31:58.920]  Вот, поэтому
[02:31:58.920 --> 02:32:00.920]  логично, что так.
[02:32:00.920 --> 02:32:02.920]  На самом деле,
[02:32:02.920 --> 02:32:04.920]  как мы выясним во втором смеси,
[02:32:04.920 --> 02:32:06.920]  std string, как std vector,
[02:32:06.920 --> 02:32:08.920]  они все наследники некоторой другой.
[02:32:08.920 --> 02:32:10.920]  Интересные вещи,
[02:32:10.920 --> 02:32:12.920]  но знать об этом,
[02:32:12.920 --> 02:32:14.920]  но ловя ее,
[02:32:14.920 --> 02:32:16.920]  мы не должны ловить их.
[02:32:16.920 --> 02:32:18.920]  Так,
[02:32:18.920 --> 02:32:20.920]  меня
[02:32:20.920 --> 02:32:22.920]  другой вопрос больше интересует.
[02:32:22.920 --> 02:32:24.920]  Знаете, какой?
[02:32:36.920 --> 02:32:38.920]  Смотрите, вот у меня есть такая штука,
[02:32:38.920 --> 02:32:40.920]  еще есть такая штука,
[02:32:40.920 --> 02:32:42.920]  а еще есть...
[02:32:44.920 --> 02:32:46.920]  Да...
[02:32:46.920 --> 02:32:48.920]  Ну, есть еще...
[02:32:48.920 --> 02:32:50.920]  сын...
[02:32:50.920 --> 02:32:52.920]  Да, они, конечно, не приватные,
[02:32:52.920 --> 02:32:54.920]  вот эти все штуки.
[02:32:54.920 --> 02:32:56.920]  А еще есть сын,
[02:32:56.920 --> 02:32:58.920]  который наследник их обоих.
[02:33:00.920 --> 02:33:02.920]  И вот я... Вы догадываетесь,
[02:33:02.920 --> 02:33:04.920]  что я сейчас делаю?
[02:33:06.920 --> 02:33:08.920]  Конечно.
[02:33:10.920 --> 02:33:12.920]  Что будет?
[02:33:12.920 --> 02:33:14.920]  Что будет?
[02:33:16.920 --> 02:33:18.920]  Какой из двух
[02:33:18.920 --> 02:33:20.920]  гренни?
[02:33:20.920 --> 02:33:22.920]  Их же два?
[02:33:24.920 --> 02:33:26.920]  Ну, у гренни
[02:33:26.920 --> 02:33:28.920]  есть поля.
[02:33:30.920 --> 02:33:32.920]  Так, стоп, еще раз.
[02:33:32.920 --> 02:33:34.920]  Ну, вот.
[02:33:36.920 --> 02:33:38.920]  Ну, и что?
[02:33:38.920 --> 02:33:40.920]  Кажется, что всех должны ловить.
[02:33:40.920 --> 02:33:42.920]  Какую гренни я должен поймать,
[02:33:42.920 --> 02:33:44.920]  если так напишу? Их там две.
[02:33:48.920 --> 02:33:50.920]  Возможно, вообще любую.
[02:33:50.920 --> 02:33:52.920]  Ну, первую, наверное.
[02:33:52.920 --> 02:33:54.920]  Кажется, что это будет
[02:33:54.920 --> 02:33:56.920]  какой-нибудь УБ.
[02:33:56.920 --> 02:33:58.920]  Нет, ну, УБ было бы странно, если...
[02:33:58.920 --> 02:34:00.920]  Ну, почему? Мы поймали рандомную бабушку.
[02:34:00.920 --> 02:34:02.920]  Нет, ну, тогда уж unspecified
[02:34:02.920 --> 02:34:04.920]  behavior, не совсем же УБ.
[02:34:04.920 --> 02:34:06.920]  Ну, хорошо, unspecified.
[02:34:06.920 --> 02:34:08.920]  Ну, в смысле, я ставлю на то, что мы в зависимости
[02:34:08.920 --> 02:34:10.920]  компилятора ловим одну из двух бабушек.
[02:34:12.920 --> 02:34:14.920]  Я, если честно, не знаю, что будет.
[02:34:14.920 --> 02:34:16.920]  Я никогда не пробовал.
[02:34:16.920 --> 02:34:18.920]  Я просто...
[02:34:18.920 --> 02:34:20.920]  Мне самому сейчас стало интересно. Давайте.
[02:34:20.920 --> 02:34:22.920]  Ну, давайте.
[02:34:22.920 --> 02:34:24.920]  Ну, оно скомпилирует.
[02:34:24.920 --> 02:34:26.920]  Ну, уже все, да.
[02:34:26.920 --> 02:34:28.920]  Нет, ну, я склоняюсь...
[02:34:28.920 --> 02:34:30.920]  Я склоняюсь
[02:34:30.920 --> 02:34:32.920]  в мысль, что мы ничего не поймаем.
[02:34:32.920 --> 02:34:34.920]  Ну, смотрите, опять-таки, я как пользователь.
[02:34:34.920 --> 02:34:36.920]  Вот, смотрите, вот у вас, например, есть...
[02:34:36.920 --> 02:34:38.920]  Да нет.
[02:34:38.920 --> 02:34:40.920]  Я как пользователь этой штуки
[02:34:40.920 --> 02:34:42.920]  не должен...
[02:34:42.920 --> 02:34:44.920]  Если я кидаю что-то,
[02:34:44.920 --> 02:34:46.920]  а потом ловлю в
[02:34:46.920 --> 02:34:48.920]  сковородню родителя,
[02:34:48.920 --> 02:34:50.920]  я не должен ловить СЕ из-за того, что родителей
[02:34:50.920 --> 02:34:52.920]  было несколько, и непонятно, кого поймать.
[02:34:52.920 --> 02:34:54.920]  Ну, это было бы странно.
[02:34:54.920 --> 02:34:56.920]  Я ставлю на то, что ничего не поймается.
[02:34:56.920 --> 02:34:58.920]  На самом деле.
[02:34:58.920 --> 02:35:00.920]  Ничего не поймалось.
[02:35:00.920 --> 02:35:02.920]  Ну, потому что не понятно,
[02:35:02.920 --> 02:35:04.920]  какую из двух ловить. Так же не буду ловить.
[02:35:04.920 --> 02:35:06.920]  Давай ловить!
[02:35:06.920 --> 02:35:08.920]  Я могу выбрать
[02:35:08.920 --> 02:35:10.920]  на сковородню или
[02:35:10.920 --> 02:35:12.920]  макароны, поэтому я пойду голодную.
[02:35:12.920 --> 02:35:14.920]  А, ну у нас действительно просто
[02:35:14.920 --> 02:35:16.920]  нет функции, которая
[02:35:16.920 --> 02:35:18.920]  выбирает определенную бабушку.
[02:35:18.920 --> 02:35:20.920]  Она просто пролетела.
[02:35:20.920 --> 02:35:22.920]  Ну, каст...
[02:35:22.920 --> 02:35:24.920]  Ну, давайте так. Каст от сына к бабушке...
[02:35:24.920 --> 02:35:26.920]  Слушайте, ну, че так громко
[02:35:26.920 --> 02:35:28.920]  голдешь какой-то? Давайте тихо.
[02:35:28.920 --> 02:35:30.920]  У меня, кстати, каст
[02:35:30.920 --> 02:35:32.920]  от сына к бабушке формально не
[02:35:32.920 --> 02:35:34.920]  чувствим, потому что непонятно, к чему
[02:35:34.920 --> 02:35:36.920]  кастовать. Ну, он просто когда делает кэч
[02:35:36.920 --> 02:35:38.920]  от грейни амперсанта, он такой, понятно, но этот грейн
[02:35:38.920 --> 02:35:40.920]  не подходит, потому что каст не определен
[02:35:40.920 --> 02:35:42.920]  от сына к грейни. Ну, все, я вообще не ловлю.
[02:35:44.920 --> 02:35:46.920]  То есть, он типа каст сам оборачивает
[02:35:46.920 --> 02:35:48.920]  внутри себя в тройке?
[02:35:48.920 --> 02:35:50.920]  Подожди, что ты говоришь?
[02:35:50.920 --> 02:35:52.920]  Если мы от отца
[02:35:52.920 --> 02:35:54.920]  приватно наследуемся?
[02:35:54.920 --> 02:35:56.920]  Приватность ни на что не влияет, конечно же.
[02:35:56.920 --> 02:35:58.920]  Все равно
[02:35:58.920 --> 02:36:00.920]  каст не определен от сына к грейне.
[02:36:00.920 --> 02:36:02.920]  Я просто понимал, что
[02:36:02.920 --> 02:36:04.920]  он не должен видеть, что он
[02:36:04.920 --> 02:36:06.920]  сын бейза,
[02:36:06.920 --> 02:36:08.920]  наследник бейза.
[02:36:08.920 --> 02:36:10.920]  Точно каст не определен?
[02:36:10.920 --> 02:36:12.920]  Каст не определен.
[02:36:12.920 --> 02:36:14.920]  Каст все равно остается не определен
[02:36:14.920 --> 02:36:16.920]  от сына к бабушке.
[02:36:16.920 --> 02:36:18.920]  Но я все равно уверен,
[02:36:18.920 --> 02:36:20.920]  что ничего не поймается. Нет, ничего не поймалось.
[02:36:22.920 --> 02:36:24.920]  Но все равно не определен каст
[02:36:24.920 --> 02:36:26.920]  от сына к грейне.
[02:36:26.920 --> 02:36:28.920]  Мы же ловили приватный бейс?
[02:36:28.920 --> 02:36:30.920]  Приватный бейс мы не ловили.
[02:36:30.920 --> 02:36:32.920]  Нет, когда
[02:36:32.920 --> 02:36:34.920]  мы наследовались приватно
[02:36:34.920 --> 02:36:36.920]  от бейс. Нет, мы не ловили
[02:36:36.920 --> 02:36:38.920]  приватный бейс. Это было бы очень странно, если
[02:36:38.920 --> 02:36:40.920]  мы его ловили. Пролетели.
[02:36:44.920 --> 02:36:46.920]  Так.
[02:36:46.920 --> 02:36:48.920]  Что там в случае сначала проверяется,
[02:36:48.920 --> 02:36:50.920]  что у нас... Да ничего
[02:36:50.920 --> 02:36:52.920]  не проверяется. Просто нельзя ловить
[02:36:52.920 --> 02:36:54.920]  приватное наследование, нельзя ловить неоднозначное
[02:36:54.920 --> 02:36:56.920]  наследование. Можно только касты вверх.
[02:36:56.920 --> 02:36:58.920]  Все. При публичном наследовании
[02:36:58.920 --> 02:37:00.920]  при чем? И однозначной. Все.
[02:37:02.920 --> 02:37:04.920]  Я тебе сказал, можно
[02:37:04.920 --> 02:37:06.920]  ловить только каст от
[02:37:06.920 --> 02:37:08.920]  наследника к родителю, если
[02:37:08.920 --> 02:37:10.920]  он публичный и однозначный. Точка.
[02:37:10.920 --> 02:37:12.920]  Никаких больше проверок. Все.
[02:37:12.920 --> 02:37:14.920]  Ничего не проверяется.
[02:37:14.920 --> 02:37:16.920]  Просто вот только это можно ловить и все.
[02:37:18.920 --> 02:37:20.920]  Это все не ловится.
[02:37:20.920 --> 02:37:22.920]  Еще можно ловить приведение
[02:37:22.920 --> 02:37:24.920]  от неконстанты к константе.
[02:37:24.920 --> 02:37:26.920]  От неконстантной ссылки можно поймать неконстантный объект.
[02:37:26.920 --> 02:37:28.920]  Ну ничего страшного.
[02:37:30.920 --> 02:37:32.920]  Теперь дальше. Вот смотрите.
[02:37:32.920 --> 02:37:34.920]  Давайте такой просмотрим
[02:37:34.920 --> 02:37:36.920]  пример. Вот у меня есть
[02:37:36.920 --> 02:37:38.920]  опять сын.
[02:37:40.920 --> 02:37:42.920]  И я поймал сначала
[02:37:42.920 --> 02:37:44.920]  маму.
[02:37:44.920 --> 02:37:46.920]  Ну да, давайте. Вот у меня был сын,
[02:37:46.920 --> 02:37:48.920]  я поймал маму. Смотрите,
[02:37:48.920 --> 02:37:50.920]  какая еще есть вещь.
[02:37:50.920 --> 02:37:52.920]  Вот сейчас, окей,
[02:37:52.920 --> 02:37:54.920]  сейчас всякие
[02:37:54.920 --> 02:37:56.920]  странные примеры
[02:37:56.920 --> 02:37:58.920]  закончились, сейчас будет реально полезное знание.
[02:37:58.920 --> 02:38:00.920]  Вот.
[02:38:00.920 --> 02:38:02.920]  Я могу сделать фроу того же
[02:38:02.920 --> 02:38:04.920]  самого, что уже летит, не пересоздавая
[02:38:04.920 --> 02:38:06.920]  его.
[02:38:06.920 --> 02:38:08.920]  Вот если я нахожусь в кетче, мне может быть
[02:38:08.920 --> 02:38:10.920]  нужно бросить то, что уже летит
[02:38:10.920 --> 02:38:12.920]  дальше вверх, не пересоздавая.
[02:38:12.920 --> 02:38:14.920]  Для этого я могу написать
[02:38:14.920 --> 02:38:16.920]  фроу без параметров.
[02:38:16.920 --> 02:38:18.920]  Вот
[02:38:18.920 --> 02:38:20.920]  фроу без параметров
[02:38:20.920 --> 02:38:22.920]  означает просто
[02:38:22.920 --> 02:38:24.920]  брось дальше то, что ты
[02:38:24.920 --> 02:38:26.920]  только что поймал. Не
[02:38:26.920 --> 02:38:28.920]  создавай новое, а брось
[02:38:28.920 --> 02:38:30.920]  вот что летит, не уничтожай
[02:38:30.920 --> 02:38:32.920]  его, а пусть оно летит
[02:38:32.920 --> 02:38:34.920]  дальше.
[02:38:34.920 --> 02:38:36.920]  А до этого бы оно его уничтожило?
[02:38:36.920 --> 02:38:38.920]  Мы же по ссылке передавали.
[02:38:38.920 --> 02:38:40.920]  Если я напишу фроу что-то новое,
[02:38:40.920 --> 02:38:42.920]  то старое, то что летело, уничтожится.
[02:38:42.920 --> 02:38:44.920]  Новое, то что я
[02:38:44.920 --> 02:38:46.920]  написал, будет скопировано
[02:38:46.920 --> 02:38:48.920]  и брошено туда. А если я
[02:38:48.920 --> 02:38:50.920]  напишу просто фроу, то ничего не будет
[02:38:50.920 --> 02:38:52.920]  нового создано, а просто то,
[02:38:52.920 --> 02:38:54.920]  что там уже летело, будет дальше лететь.
[02:38:54.920 --> 02:38:56.920]  То есть это способ не копировать?
[02:38:56.920 --> 02:38:58.920]  Это способ сказать, что я
[02:38:58.920 --> 02:39:00.920]  частично обработал эту ошибку,
[02:39:00.920 --> 02:39:02.920]  а теперь пусть дальше я на следующем
[02:39:02.920 --> 02:39:04.920]  уровне обрабатываю. Передать дальше?
[02:39:04.920 --> 02:39:06.920]  Да, ничего не копирую.
[02:39:06.920 --> 02:39:08.920]  Ничего нового не создавать.
[02:39:08.920 --> 02:39:10.920]  Ты можешь обернуть этот трай
[02:39:10.920 --> 02:39:12.920]  в еще один трай и тоже
[02:39:12.920 --> 02:39:14.920]  принять по ссылке?
[02:39:14.920 --> 02:39:16.920]  Ну, будет то же самое исключение.
[02:39:16.920 --> 02:39:18.920]  Я не буду этого делать, чтобы
[02:39:18.920 --> 02:39:20.920]  время не тратить, но будет то же самое.
[02:39:22.920 --> 02:39:24.920]  Что?
[02:39:28.920 --> 02:39:30.920]  Да, мы же видели здесь, что если я пишу фроу s,
[02:39:30.920 --> 02:39:32.920]  то создается новый объект s,
[02:39:32.920 --> 02:39:34.920]  а старый уничтожается.
[02:39:34.920 --> 02:39:36.920]  А если я бы написал просто фроу,
[02:39:36.920 --> 02:39:38.920]  то ничего бы нового не создалось.
[02:39:38.920 --> 02:39:40.920]  А если я
[02:39:40.920 --> 02:39:42.920]  в методе s
[02:39:42.920 --> 02:39:44.920]  вызову
[02:39:44.920 --> 02:39:46.920]  фроу s, но нормально будет.
[02:39:46.920 --> 02:39:48.920]  Что в методе s? Вызовешь фроу s?
[02:39:48.920 --> 02:39:50.920]  Фроу this.
[02:39:54.920 --> 02:39:56.920]  В методе s вызовешь
[02:39:56.920 --> 02:39:58.920]  фроу this?
[02:39:58.920 --> 02:40:00.920]  Ну, конечно же, я напишу это.
[02:40:00.920 --> 02:40:02.920]  Ну, создастся новый объект
[02:40:02.920 --> 02:40:04.920]  из твоего текущего с помощью конструктора
[02:40:04.920 --> 02:40:06.920]  копирования. И вот
[02:40:06.920 --> 02:40:08.920]  тот, который создастся, будет исключением
[02:40:08.920 --> 02:40:10.920]  летящим.
[02:40:12.920 --> 02:40:14.920]  Об этом сейчас будет следующий
[02:40:14.920 --> 02:40:16.920]  пункт.
[02:40:26.920 --> 02:40:28.920]  Если ты напишешь
[02:40:28.920 --> 02:40:30.920]  фроу без параметров, то
[02:40:30.920 --> 02:40:32.920]  дальше будет лететь то, что уже
[02:40:32.920 --> 02:40:34.920]  летело. Вот этот локальный объект уничтожится,
[02:40:34.920 --> 02:40:36.920]  а то, что летело, будет продолжать
[02:40:36.920 --> 02:40:38.920]  лететь.
[02:40:38.920 --> 02:40:40.920]  Вот. Если ты напишешь
[02:40:40.920 --> 02:40:42.920]  фроу без параметров не в кетче,
[02:40:42.920 --> 02:40:44.920]  а где-то в другом месте,
[02:40:44.920 --> 02:40:46.920]  то будет run time error.
[02:40:46.920 --> 02:40:48.920]  Давайте проверим.
[02:40:50.920 --> 02:40:52.920]  Вот я просто написал фроу. Ну, возможно,
[02:40:52.920 --> 02:40:54.920]  мне сейчас просто не даст компилировать это. Нет,
[02:40:54.920 --> 02:40:56.920]  дал.
[02:40:56.920 --> 02:40:58.920]  Да, будет вот такой, тот же самый run time error,
[02:40:58.920 --> 02:41:00.920]  когда у нас terminate cold,
[02:41:00.920 --> 02:41:02.920]  а исключения не было.
[02:41:04.920 --> 02:41:06.920]  Вот. Это еще один пример, когда
[02:41:06.920 --> 02:41:08.920]  если я фроу без параметров, то есть фроу
[02:41:08.920 --> 02:41:10.920]  формально не требует операнда себе.
[02:41:10.920 --> 02:41:12.920]  Он может быть вызван без параметров.
[02:41:12.920 --> 02:41:14.920]  Но если я сделал фроу не в кетче, то есть
[02:41:14.920 --> 02:41:16.920]  фроу сделал тогда, когда ничего
[02:41:16.920 --> 02:41:18.920]  не лежало в том месте, где
[02:41:18.920 --> 02:41:20.920]  хранятся исключения, а летящие, то значит
[02:41:20.920 --> 02:41:22.920]  просто terminate без исключения.
[02:41:24.920 --> 02:41:26.920]  Мы можем в кетче просто
[02:41:26.920 --> 02:41:28.920]  не принимать параметры, а принять
[02:41:28.920 --> 02:41:30.920]  фроу без параметра?
[02:41:30.920 --> 02:41:32.920]  Что в кетче сделать? В кетче
[02:41:32.920 --> 02:41:34.920]  сделать ноль параметров. Ну не принимать параметров в кетче
[02:41:34.920 --> 02:41:36.920]  и поймать фроу без параметров?
[02:41:36.920 --> 02:41:38.920]  Мы можем в кетче многоточие
[02:41:38.920 --> 02:41:40.920]  написать. Нет, просто в кетче вообще
[02:41:40.920 --> 02:41:42.920]  ничё не делаешь. Нет, в кетче
[02:41:42.920 --> 02:41:44.920]  нужно что-то написать здесь, либо многоточие,
[02:41:44.920 --> 02:41:46.920]  тогда вы поймете что угодно, либо
[02:41:46.920 --> 02:41:48.920]  какой-то тип. Если вы сделали
[02:41:48.920 --> 02:41:50.920]  кетч многоточие, то вы можете сделать фроу
[02:41:50.920 --> 02:41:52.920]  без параметров и будете лететь дальше то, что вы поймал,
[02:41:52.920 --> 02:41:54.920]  то, что летело. Чего?
[02:41:54.920 --> 02:41:56.420]  Если я написал
[02:41:56.420 --> 02:41:58.420]  фроу без параметров внутри
[02:41:58.420 --> 02:42:00.420]  трея, а кетч
[02:42:00.420 --> 02:42:02.420]  внутри фроу. Он его поймает,
[02:42:02.420 --> 02:42:04.420]  в первый раз
[02:42:04.420 --> 02:42:06.420]  нет
[02:42:06.420 --> 02:42:08.420]  ну как
[02:42:08.420 --> 02:42:10.420]  у вас
[02:42:10.420 --> 02:42:12.420]  в смысле
[02:42:12.420 --> 02:42:14.420]  если вы
[02:42:18.420 --> 02:42:20.420]  блин ну вы конечно извращенцы
[02:42:20.420 --> 02:42:22.420]  не знаю никогда так не пробовал ну давайте
[02:42:22.420 --> 02:42:24.420]  проверим
[02:42:24.420 --> 02:42:26.420]  ну все давайте просто вот так сделаем
[02:42:26.420 --> 02:42:28.420]  проверим ладно
[02:42:28.420 --> 02:42:30.420]  нет ничего если throw без параметров
[02:42:30.420 --> 02:42:32.420]  когда нет исключения то сразу terminate
[02:42:32.420 --> 02:42:34.420]  видимо он его нигде не сможет
[02:42:34.420 --> 02:42:36.420]  пробовать
[02:42:36.420 --> 02:42:38.420]  сейчас
[02:42:38.420 --> 02:42:40.420]  так
[02:42:42.420 --> 02:42:44.420]  блин у меня время закончилось уже
[02:42:44.420 --> 02:42:46.420]  ну мы блин опять начали позже
[02:42:46.420 --> 02:42:48.420]  на 15 минут
[02:42:48.420 --> 02:42:50.420]  у нас есть terminate в любом потому что у нас уже
[02:42:50.420 --> 02:42:52.420]  от следующего try terminate
[02:42:52.420 --> 02:42:54.420]  хватало
[02:42:54.420 --> 02:42:56.420]  кстати
[02:42:56.420 --> 02:42:58.420]  если у меня
[02:42:58.420 --> 02:43:00.420]  try catch
[02:43:00.420 --> 02:43:02.420]  и я выбросился
[02:43:02.420 --> 02:43:04.420]  один из второго catch
[02:43:04.420 --> 02:43:06.420]  так
[02:43:06.420 --> 02:43:08.420]  вот как раз на этот вопрос я сейчас отвечу
[02:43:08.420 --> 02:43:10.420]  так все давайте
[02:43:10.420 --> 02:43:12.420]  последнее что я скажу в этом пункте
[02:43:12.420 --> 02:43:14.420]  так смотрите
[02:43:14.420 --> 02:43:16.420]  последнее что я
[02:43:16.420 --> 02:43:18.420]  собираюсь сказать по поводу механизма
[02:43:18.420 --> 02:43:20.420]  try catch
[02:43:20.420 --> 02:43:22.420]  что если я делаю
[02:43:22.420 --> 02:43:24.420]  бросаю какой-то
[02:43:24.420 --> 02:43:26.420]  объект и у меня несколько
[02:43:26.420 --> 02:43:28.420]  catch есть сначала есть catch
[02:43:28.420 --> 02:43:30.420]  что-то одно
[02:43:30.420 --> 02:43:32.420]  а потом catch что-то более хорошо подходящее
[02:43:32.420 --> 02:43:34.420]  например вот так
[02:43:38.420 --> 02:43:40.420]  вот
[02:43:40.420 --> 02:43:42.420]  что поймает вообще поймается
[02:43:42.420 --> 02:43:44.420]  или что-то и что
[02:43:44.420 --> 02:43:46.420]  вот
[02:43:46.420 --> 02:43:48.420]  правильный ответ что выведется один
[02:43:48.420 --> 02:43:50.420]  и все
[02:43:52.420 --> 02:43:54.420]  catch работают не по принципу
[02:43:54.420 --> 02:43:56.420]  перегрузки функций они работают по принципу
[02:43:56.420 --> 02:43:58.420]  первого подходящего
[02:44:02.420 --> 02:44:04.420]  catch перебираются подряд и как только
[02:44:04.420 --> 02:44:06.420]  какой-то catch подошел
[02:44:06.420 --> 02:44:08.420]  он и выбирается и он не смотрит
[02:44:08.420 --> 02:44:10.420]  следующие catch не лучше ли они подходят
[02:44:10.420 --> 02:44:12.420]  выбирается первый подходящий
[02:44:16.420 --> 02:44:18.420]  и мне даже warning вывелся
[02:44:18.420 --> 02:44:20.420]  потому что на самом деле вот этот
[02:44:20.420 --> 02:44:22.420]  код никогда сюда невозможно
[02:44:22.420 --> 02:44:24.420]  попасть просто
[02:44:24.420 --> 02:44:26.420]  вот этот catch никогда не будет выбран
[02:44:26.420 --> 02:44:28.420]  потому что все что ловится им
[02:44:28.420 --> 02:44:30.420]  ловится и этим
[02:44:30.420 --> 02:44:32.420]  то есть просто вот сюда я никак
[02:44:32.420 --> 02:44:34.420]  не попаду никогда
[02:44:44.420 --> 02:44:46.420]  нет нет всякий раз когда
[02:44:46.420 --> 02:44:48.420]  при такой иерархии классов
[02:44:48.420 --> 02:44:50.420]  компилятор живит мою иерархию
[02:44:50.420 --> 02:44:52.420]  если у меня есть ссылка на сына и ссылка на маму
[02:44:52.420 --> 02:44:54.420]  то ссылка на маму всегда
[02:44:54.420 --> 02:44:56.420]  словит то что могла бы словить
[02:44:56.420 --> 02:44:58.420]  ну да ну
[02:44:58.420 --> 02:45:00.420]  понятно что при другой но при другой
[02:45:00.420 --> 02:45:02.420]  warning наверное не было бы
[02:45:02.420 --> 02:45:04.420]  да что
[02:45:04.420 --> 02:45:06.420]  если мы напишем просто ничего в try
[02:45:06.420 --> 02:45:08.420]  напишем просто throw
[02:45:08.420 --> 02:45:10.420]  если мы напишем просто throw там где не было
[02:45:10.420 --> 02:45:12.420]  исключения будет re со словами
[02:45:12.420 --> 02:45:14.420]  without an active exception мы это только что проверяли
[02:45:14.420 --> 02:45:16.420]  если в try мы это пишем
[02:45:16.420 --> 02:45:18.420]  мы это в try и писали
[02:45:18.420 --> 02:45:20.420]  да
[02:45:24.420 --> 02:45:26.420]  нет мы в try это писали
[02:45:26.420 --> 02:45:28.420]  мы пытались
[02:45:28.420 --> 02:45:30.420]  поймать многоточие мы это
[02:45:30.420 --> 02:45:32.420]  и ничего не ловилось
[02:45:36.420 --> 02:45:38.420]  ну да
[02:45:38.420 --> 02:45:40.420]  нет ну как нельзя если что-то
[02:45:40.420 --> 02:45:42.420]  летит уже в этот момент то оно просто прокинет дальше
[02:45:44.420 --> 02:45:46.420]  вот теперь дальше смотрите
[02:45:48.420 --> 02:45:50.420]  дальше
[02:45:50.420 --> 02:45:52.420]  если я поймал что-то
[02:45:52.420 --> 02:45:54.420]  и снова написал throw попаду ли я
[02:45:54.420 --> 02:45:56.420]  сюда
[02:45:56.420 --> 02:45:58.420]  нет не попаду
[02:45:58.420 --> 02:46:00.420]  да нет до этого throw не
[02:46:00.420 --> 02:46:02.420]  было
[02:46:02.420 --> 02:46:04.420]  вот
[02:46:04.420 --> 02:46:06.420]  нет не попаду если я уже
[02:46:06.420 --> 02:46:08.420]  значит считается следующее если я
[02:46:08.420 --> 02:46:10.420]  попал в один из обработчиков
[02:46:10.420 --> 02:46:12.420]  то все на этом уровне я больше обработчики не
[02:46:12.420 --> 02:46:14.420]  рассматриваю вот эти кэтчи
[02:46:14.420 --> 02:46:16.420]  уже не будут выбраны
[02:46:16.420 --> 02:46:18.420]  я полечу выше
[02:46:18.420 --> 02:46:20.420]  ну в данном случае
[02:46:20.420 --> 02:46:22.420]  я просто re схвачу
[02:46:28.420 --> 02:46:30.420]  ну если я в одном из обработчиков писал throw
[02:46:30.420 --> 02:46:32.420]  то следующие обработчики я не попаду
[02:46:32.420 --> 02:46:34.420]  благодаря этому throw я только
[02:46:34.420 --> 02:46:36.420]  на уровень выше попаду
[02:46:42.420 --> 02:46:44.420]  не попаду я вот сюда
[02:46:44.420 --> 02:46:46.420]  но я только что продемонстрировал
[02:46:52.420 --> 02:46:54.420]  почему
[02:46:54.420 --> 02:46:56.420]  у меня летел сын и дальше продолжает лететь сын
[02:46:56.420 --> 02:46:58.420]  я поймал его по ссылке
[02:46:58.420 --> 02:47:00.420]  на маму но от этого он не перестал быть сыном
[02:47:00.420 --> 02:47:02.420]  летит объект сына
[02:47:02.420 --> 02:47:04.420]  то есть просто throw летит сыном
[02:47:04.420 --> 02:47:06.420]  да
[02:47:12.420 --> 02:47:14.420]  так ну что ж
[02:47:16.420 --> 02:47:18.420]  блин
[02:47:18.420 --> 02:47:20.420]  ну конечно грустно что мы не успели
[02:47:20.420 --> 02:47:22.420]  опять до конца ну пофиг ладно
[02:47:22.420 --> 02:47:24.420]  у нас в принципе в следующий раз
[02:47:24.420 --> 02:47:26.420]  будет еще
[02:47:26.420 --> 02:47:28.420]  можно
[02:47:28.420 --> 02:47:30.420]  можно в следующий раз раз Филиппа не будет
[02:47:30.420 --> 02:47:32.420]  надо будет воспользоваться
