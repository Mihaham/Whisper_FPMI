[00:00.000 --> 00:17.520]  так ну что у нас сегодня вот такая вот тема и в общем это мое отношение к ней более-менее нет
[00:17.520 --> 00:24.360]  но она это это шутка на самом деле это очень прикольная структура которая умеет делать всякие
[00:24.360 --> 00:37.440]  штуки и при этом очень просто пишется не просто да ну скажем так если у вас написано
[00:37.440 --> 00:41.560]  сплэйд дерево то просто теперь если у вас написано сплэйд дерево то там дальше прям прям
[00:41.560 --> 00:48.360]  совсем почти ничего не надо писать вот основная загвоздка доказать что это быстро работает вот
[00:48.360 --> 00:52.600]  ну и мы сегодня попробуем все это сделать значит смотрите какую задачу мы хотим решать
[00:52.600 --> 00:58.960]  мы хотим поддерживать на самом деле лес корневых деревьев
[01:11.560 --> 01:15.560]  ну и давайте как обычно считать что он числа написано на ребрах
[01:15.560 --> 01:32.600]  вот ну поступают давайте как обычно давайте по запросов это у меня апдейт на ребре и сумма
[01:32.600 --> 01:42.400]  на пути что-то я так и напишу апдейт на ребре сейчас давайте пардон пардон мне будет сегодня
[01:42.400 --> 01:52.240]  удобно видимо числа на вершинах числа вершинах я сделаю вот так да так будет удобнее значит апдейт
[01:52.240 --> 02:04.240]  числа в вершине второй тип запроса это где-то сам на пути найти сумму на пути но давайте для
[02:04.240 --> 02:09.080]  простоты я буду искать сумму не на произвольном пути между двумя вершинами а от вершины до корня
[02:09.080 --> 02:14.360]  то есть сумма на восходящем пути от вершины ве до корня до корня соответствующего дерева
[02:14.360 --> 02:31.320]  гет сам от в это сумма чисел на пути от ве до корня вот то есть у меня все вершины разбиты на
[02:31.320 --> 02:38.480]  несколько деревьев вот есть там одно дерево да какое-то второе третье вот если дают в это я
[02:38.480 --> 02:43.720]  понимаю в каком дереве оно лежит и вот на этом пути до вплоть до корня мне нужна сумма сумма
[02:43.720 --> 02:53.600]  чисел в вершинах написанных на этом пути вот ну и собственно две новые операции линк это нужно
[02:53.600 --> 03:04.560]  подвесить одно дерево целиком к другому вот значит представьте что вас было два дерева и вы
[03:04.560 --> 03:11.040]  хотите как бы вот так вот подвесить вы хотите взять одно дерево целиком приклеить к другому
[03:11.040 --> 03:20.080]  дереву в какой-то точке ну по факту просто провести ребро провести ребро отсюда сюда такое значит да
[03:20.080 --> 03:23.960]  между конкретными ну не совсем на самом деле первого аргумента будет всегда корень своего
[03:23.960 --> 03:30.080]  дерева а вторая произвольная то есть вы целиком вот это вот под дерево взятая за корень подвешивайте
[03:30.080 --> 03:45.480]  какой-то другой вершине значит подвесить одно дерево целиком к данной вершине
[03:45.480 --> 03:55.520]  ну и противоположная операция так кат наоборот разрезать ребро если у вас было какое-то
[03:55.520 --> 04:04.240]  ребро ув вы его разрезаете соответственно по дерево в становится новым деревом кат ув это вам
[04:04.240 --> 04:13.880]  нужно разрезать ребро ув ну и соответственно то что было по деревам в становится самостоятельным
[04:13.880 --> 04:21.680]  деревом и ну как бы живет само по себе на то есть если была вот такая картинка что-то такое было
[04:21.680 --> 04:27.480]  было было ребро ув вы его разрезаете вот это вот становится самостоятельным деревом а вот это вот
[04:27.480 --> 04:34.760]  все остальное но остается вот этим большим по факту по факту в дополнение к запросам то что
[04:34.760 --> 04:38.640]  у нас было через хавилла декомпозиции мы делали у нас появляется добавить ребро и удалить ребро
[04:38.640 --> 04:42.920]  то есть такое динамически меняющееся дерево несколько верев которые там как-то динамически друг
[04:42.920 --> 04:55.520]  друга подвешиваться и отрезаются и так далее клево согласен вот значит чем а чем будем делать
[04:55.520 --> 05:08.160]  смотрите мы опять-таки все ребра всех наших деревьев разобьем на два класса активный не
[05:08.640 --> 05:13.200]  как у нас было в хавилла декомпозиции тяжелые легкие сейчас у нас будут ну я бы называть
[05:13.200 --> 05:24.200]  выделенные и не выделенные ребра все ребра у нас разбиваются на выделенные и не выделенные
[05:24.200 --> 05:35.000]  и так же как раньше на непрерывном пути из выделенных ребер и мы будем поддерживать какую-то
[05:35.000 --> 05:40.320]  структуру данных здесь раньше в хавилла декомпозиции у нас мы как бы рассматривали тяжелые пути и на
[05:40.320 --> 05:45.480]  тяжелом пути строили скажем дерево отрезков так здесь на выделенном пути мы строим свою структуру
[05:45.480 --> 05:51.680]  которая на самом деле будет с плой-деревом давайте какой-нибудь пример я нарисую
[05:51.680 --> 06:04.400]  такое дерево пусть будет вот давайте выделенные ребра я буду заштриховывать
[06:04.400 --> 06:12.040]  по волнистой линии вот это выделено вот это выделено вот это выделено вот это выделено
[06:12.040 --> 06:19.000]  ну и все например вот тогда у меня будет всего два сплой-дерева одно отвечает целиком вот этому
[06:19.000 --> 06:26.880]  пути, другое вот этому пути. Вот. И давайте договоримся, что у меня вершины на пути будут
[06:26.880 --> 06:32.360]  нумероваться в каждом пути независимо сверху вниз. То есть в этом пути это будет нулевая первая,
[06:32.360 --> 06:37.000]  вторая, третья вершины, в этом пути опять своя нумерация, поскольку это своя структура,
[06:37.000 --> 06:44.120]  в ней на объектах своя нумерация независимо от остальных. Здесь тоже это 0, 1, 2. Вот. Ну а получается
[06:44.120 --> 06:48.160]  вот такие отдельные вершины будут на самом деле своими отдельными сплей деревьями, в которых
[06:48.160 --> 06:53.720]  просто одна вершина находится, сплей дерева размера 1. То есть вот дерево, вот дерево,
[06:53.720 --> 07:02.480]  вот дерево. Ну все вот это будут отдельные сплей деревья. Вот. Значит давайте запишем. Я хочу,
[07:02.480 --> 07:10.800]  чтобы из каждой вершины, из каждой вершины выходило, то есть из каждой вершины выходит
[07:10.800 --> 07:29.760]  вниз не больше одного выделенного ребра. Так же, как в Хавеладе композиции, у нас тяжелое
[07:29.760 --> 07:33.480]  ребро ровно одно, но там как бы ровно одно было, здесь не больше, чем одно. То есть да, например,
[07:33.480 --> 07:38.560]  вот здесь вот ничего страшного, что здесь нет ни одного выделенного ребра. Это нормально. Да,
[07:38.560 --> 07:41.960]  уточню, что вот выделенные, это вот эти вот штрихованные, а все остальные не выделенные,
[07:41.960 --> 07:49.640]  не выделенные. Прямые это не выделенные ребра. Вот. Ну и значит строим сплей дерева,
[07:49.640 --> 07:59.720]  сплей дерева на каждом нисходящем пути по выделенным ребрам.
[08:08.560 --> 08:26.080]  Значит что у нас хранится в сплей дереве? Смотрите, у нас, ну нам явно надо хранить
[08:26.080 --> 08:31.840]  сумму в поддереве, да, то есть у нас в вершинах будет храниться числа, вот эти вот. Так же мне
[08:31.840 --> 08:35.560]  нужно искать сумму на поддереве, внутри сплей дерева, то есть там будет отдельное поле,
[08:35.560 --> 08:39.960]  которое хранит сумму в поддереве. И это дерево должно быть неявным, потому что, ну мы их будем
[08:39.960 --> 08:43.840]  явно сильно перестраивать, да, то есть когда там сюда что-то подвешивается. Ну, например, да,
[08:43.840 --> 08:48.600]  если я захочу в какой-то момент вот это вот ребро назначить не выделенным, а это выделенным,
[08:48.600 --> 08:54.160]  то мне нужно будет вот этом большом дереве этот кусок отрезать, а этот добавить. И я это часто
[08:54.160 --> 08:57.480]  буду делать, я буду часто менять типы ребра с выделенных на не выделенный и наоборот,
[08:57.480 --> 09:01.480]  поэтому мне нужна структура, которая внутри позволяет там быстро склеиваться как-нибудь,
[09:01.480 --> 09:07.360]  да, между собой, наоборот разделяться, то есть как бы отрезать ребра, ну и так далее.
[09:07.360 --> 09:14.960]  Привет, Артур Евгеньевич. Вот, значит, давайте это напишем, да, сплей дерева у нас будет по
[09:14.960 --> 09:39.680]  неявному ключу. По неявному ключу в вершинах этого дерева храним туму чисел из-под дерева.
[09:44.960 --> 10:01.920]  Так, это сказал, значит, последнее поле, которое я буду хранить, и после этого нарисую пример
[10:01.920 --> 10:09.520]  еще один. Значит, это мне нужно будет хранить для каждого начала каждого сплей дерева, то есть
[10:09.520 --> 10:15.480]  по факту для каждого начала всех выделенных путей я буду хранить ссылку на то, куда подвешен,
[10:15.480 --> 10:21.840]  как бы, ну, вот на родителя по факту. Вот у меня есть целиком какой-то выделенный путь, я буду
[10:21.840 --> 10:28.320]  для его корня, для начала этого пути хранить ссылочку, ну, давайте даже вот так скажу, вот это
[10:28.320 --> 10:34.680]  все как бы дерево целиком подвешено вот сюда. У меня будет вот такое поле, что этот путь является
[10:34.680 --> 10:39.960]  сыном непосредственно вот этой вершины. Например, дальше вот это вот будет целиком подвешено вот
[10:39.960 --> 10:47.360]  сюда, к единице, это все целиком сплей дерева, оно будет подвешено вот к этой единице, к этой вершине,
[10:47.360 --> 10:51.480]  ну и так далее. То есть у меня по факту каждое сплей дерево ссылается на то, куда оно подвешено.
[10:51.480 --> 11:04.480]  Каждое сплей дерево, а напоминаю, сплей дерево это путь из выделенных ребер, так вот каждый путь
[11:05.160 --> 11:11.440]  это какая-то вот такая вот картинка, да, все выделенные. Я хочу понять, какая вершина как бы
[11:11.440 --> 11:18.800]  предшествует всему этому пути. Вот ее я буду хранить. Значит, каждый сплей дерево, точнее корень
[11:18.800 --> 11:38.960]  сплей дерева хранит указатель ptr, ну я напишу на родительскую вершину, вот на предыдущую вершину
[11:38.960 --> 11:41.120]  относительно этого пути.
[11:49.800 --> 11:56.680]  Вот. Ну все, структуру более-менее писал. Теперь давайте нарисуем пример с числами,
[11:56.680 --> 12:20.080]  и вот эти ptr тоже как работают. Надеюсь, не хватит. Сейчас от балды выделю какие-то ребра. Значит,
[12:20.080 --> 12:24.920]  сразу скажу, что те ребра, которые выделены и не выделены, у них классификация, ну там нет
[12:24.920 --> 12:29.600]  никакого правила, что вот эти выделенные и не выделенные. Просто вот как алгоритм их в какой-то
[12:29.600 --> 12:33.880]  момент назначает выделенными или не выделенными, мы их так и считаем. Короче, вот как алгоритм хочет,
[12:33.880 --> 12:37.600]  он так их выделяет. То есть нет какого-то правила, что там тяжелые ребра выделены или что-то такое.
[12:37.600 --> 12:43.080]  Вот просто вот как в алгоритме он их назначит, так и так и будет. Вот, например, пусть такая картинка у меня.
[12:55.840 --> 13:22.280]  Пусть будет вот так. Давайте пронумерую вершины. Как-нибудь от балды. Вот. И построю как-нибудь
[13:22.280 --> 13:27.000]  сплей-деревья. Значит, смотрите, давайте вот с этого длинного пути начнем. Вот это вот все должно
[13:27.000 --> 13:32.600]  быть одно большое сплей-дерево. При этом как именно оно внутри устроено, мы не знаем. Но давайте
[13:32.600 --> 13:37.280]  какой-нибудь пример нарисуем. Вот скажем, пусть корнем этого сплей-дерева, напоминаю, у меня вершины
[13:37.280 --> 13:41.560]  как бы сверху внизу порядочены, то есть вот это должна быть первая, самая левая вершина сплей-дерева,
[13:41.560 --> 13:49.120]  это вторая, третья, четвертая. Ну, например, пусть двойка является корнем. Тогда, смотрите,
[13:49.120 --> 13:54.160]  слева должны идти те, кто левее, то есть выше в пути расположен. Вот эта единица будет сверху,
[13:54.160 --> 13:58.880]  а справа должно быть вот это поддерево между тройкой и четвертой. Ну, например, пусть будет вот так.
[13:58.880 --> 14:09.840]  Вот. Вот это корректная сплей-дерева для вот этого первого пути. Потому что, когда мы рассматриваем
[14:09.840 --> 14:15.920]  вершины слева направо, то есть смотрите на это, как на картинку на плоскости. Если вершины слева
[14:15.920 --> 14:20.040]  направо записывают, то будет сначала первая, потом вторая, потом третья, потом четвертая. Как раз ровно тот
[14:20.040 --> 14:24.920]  порядок, к которому вершина идет сверху вниз. Так, это корректное дерево вот это. Дальше давайте
[14:24.920 --> 14:36.120]  нарисую единичные, скажем. Вот это 10, 11, они будут сами в себе. Вот это вот 12, 15. Здесь корни может
[14:36.120 --> 14:42.120]  выступать как 12, так и 15. Смотрите, хотя хотелось бы ожидать, что 12 это корень свою сплей-дереву,
[14:42.120 --> 14:46.440]  потому что она сама верхняя. Это не всегда так. Может быть произвольная вершина. Вот, например,
[14:46.440 --> 14:52.760]  15. Значит, если 15 корень, то поскольку 12 расположена выше, идет раньше в сплей-дереве,
[14:52.760 --> 15:00.240]  то значит она должна располагаться левее. Потому что левее это раньше. Так, это нарисовал. Значит,
[15:00.240 --> 15:06.800]  ну давайте еще вот здесь вот нарисую, чтобы было поинтереснее. 5, 7, 9. Здесь давайте для
[15:06.800 --> 15:14.240]  разнообразия пятерка будет корнем. Мне нужно, чтобы остальные шли справа. Пусть, например, будет
[15:14.240 --> 15:22.000]  вот так. Это тоже будет корректный сплей-дерев, потому что самая левая вершина 5, потом 7,
[15:22.000 --> 15:29.120]  потом 9. Как раз 5, 7, 9 сверху вниз. Шестерка, восьмерка сами в себе. Где-нибудь я вот здесь
[15:29.120 --> 15:45.360]  их нарисую. Вот этот путь. 14, 20, 16. Пусть будет 16 корнем. Тогда слева 20 может быть и еще левее 14.
[15:45.360 --> 16:08.680]  Так, я почти закончил. Осталось у меня 13, 17 и 17. Давайте я нарисую вот здесь. Вот, например,
[16:08.680 --> 16:15.640]  такой набор сплей-дерев может соответствовать вот этому одному дереву. Понятно? Нет противоречи
[16:15.640 --> 16:27.640]  тут? Да. Нет, совсем не обязательно. Не-не-не, смотрите. Вот, например, давайте вот на этом примере,
[16:27.640 --> 16:33.040]  если бы четверка, скажем, была корнем, то у меня могло бы быть... Ну нет, подождите. Вот-вот,
[16:33.040 --> 16:37.760]  окей. Представьте себе, какой-то длинный путь вот здесь был бы. Тогда его корнем может выступать,
[16:37.760 --> 16:44.920]  например, вот эта вершина. Левое по дереву — это все вот это, правое — это вот это. А какое оно
[16:44.920 --> 16:48.720]  здесь устройство имеет? Да бог его знает. Может быть, например, вот эта штука — корень, потом вот
[16:48.720 --> 16:53.320]  сюда он как-то ссылается и сюда. То есть это произвольное сплей-дерево. Давайте пример нарисую тоже.
[16:53.320 --> 17:03.480]  Если есть вопросы, значит, вот что-нибудь подлиннее нарисую. Вот. Пусть, скажем,
[17:03.480 --> 17:11.360]  Т — это у меня корень, тогда слева нужно расположить вот это. Например, оно может получиться так.
[17:11.360 --> 17:21.040]  Корректное сплей-дерево, потому что при проходе слева направо в точности получается путь сверху вниз.
[17:21.040 --> 17:25.240]  Оно не совсем как бы произвольное, абсолютно. Произвольное сплей-дерево. Главное — бинарное.
[17:25.240 --> 17:29.480]  Сплей-дерево, понятное дело, бинарное. Так, давайте это сотру.
[17:29.480 --> 17:59.280]  Ну, смотрите, у меня все вершины исходного дерева,
[17:59.280 --> 18:04.000]  пронумерованы как-то. Ну, даже я бы сказал так, все вершины, которые вообще когда-либо участвуют в нашей
[18:04.000 --> 18:07.760]  структуре, пронумерованы 1, 2, и так далее, n. Вот там изначально в задаче сказали, что всего мы
[18:07.760 --> 18:13.120]  используем, работаем с n-вершинами. Изначально у меня они все 1, 2, и так далее, n. Нет ребер
[18:13.120 --> 18:17.200]  каждого в своем сплей-дереве. А потом говорят что-нибудь типа, ну там, не знаю, вот это объединить,
[18:17.200 --> 18:22.440]  тогда нужно вот эти два сплей-дерева склеить. Да. Но они же занумерованы. Мы по номеру можем
[18:22.440 --> 18:26.960]  получать вершину спокойно. У меня, смотрите, у меня нумерация здесь полностью соответствует
[18:27.040 --> 18:32.720]  нумерации в исходном дереве. И если мне сказали подвесить там x и y, то я знаю вершину соответствующую x в
[18:32.720 --> 18:45.960]  одном из сплей-деревев и y в другом. И подвешу, если надо. Ну, можно так сказать, нет, не на сплей-дерево,
[18:45.960 --> 18:51.800]  а на вершину я бы сказал. То есть по вершине исходного дерева мы имеем указатель на вершину
[18:51.800 --> 19:05.280]  в сплей-дереве. Да, да, исходное дерево мы в явном виде вроде даже не храним, да, это правда. Вроде
[19:05.280 --> 19:11.520]  даже не храним, действительно. Вот, ну теперь смотрите, давайте какую-нибудь операцию попробуем
[19:11.520 --> 19:17.800]  сделать. Давайте попробуем понять, что происходит, если я, например, хочу вот это вот ребро выделить.
[19:17.800 --> 19:26.320]  Вот это ребро выделить. Что это значит? Это значит, что я должен в частности вот это ребро антивыделить,
[19:26.320 --> 19:31.960]  да, то есть я должен его убрать, а это добавить. Ну, давайте тогда по шагам сделаем. Давайте сначала
[19:31.960 --> 19:36.480]  поймем, что происходит, когда я вот это вот ребро делаю невыделенным. То есть ребро между двойкой и
[19:36.480 --> 19:43.160]  тройкой. Я вот хочу его не выделить. Да, значит, смотрите, мне нужно по факту просто вот это дерево
[19:43.160 --> 19:48.320]  разрезать, чтобы сверху были один-два, а снизу три-четыре. Ну, давайте я сделал сплей, благо двойка
[19:48.320 --> 19:53.600]  и так уже корень, и мне на самом деле нужно просто отрезать вот это правое поддерево, потому что вот
[19:53.600 --> 19:59.400]  как раз вот эти три-четыре, они лежат ниже, их нужно отрезать. Поэтому первым делом, когда я хочу
[19:59.400 --> 20:05.880]  сделать ребро невыделенным, я поднимаю эту вершину в корень с помощью сплей, ну здесь она и так корень,
[20:05.880 --> 20:11.120]  и отрезаю правое поддерево, потому что все, что ниже, это гораздо то, что справа. Значит, сделать это
[20:11.120 --> 20:19.840]  ребро невыделенным, это значит просто убрать вот это ребро. Согласны? Но если я хочу это сделать
[20:19.840 --> 20:25.760]  выделенным, то мне нужно теперь вот это поддерево 5,9,7, то есть вот этот вот выделенный путь, подвесить
[20:25.760 --> 20:31.880]  справа к двойке, потому что как раз таки оно идет ниже, значит справа. Поэтому вот это все
[20:31.880 --> 20:38.000]  безобразие нужно подвесить вот сюда, вот на место того, где раньше было 4,3. Давайте перерисую. Будет
[20:38.040 --> 20:51.320]  теперь вот так. Вот. Тем самым я вот это ребро выделил. Давайте еще что-нибудь сделаем. Вот это
[20:51.320 --> 20:56.260]  хорошее, вот это ребро попробуем выделить тоже. Чтобы его выделить, мне нужно это сначала
[20:56.260 --> 21:00.260]  сначала не выделить, сделать не выделенным, а потом это выделить.
[21:00.260 --> 21:03.260]  Давайте сначала это сделаем не выделенным.
[21:03.260 --> 21:06.260]  Для этого я не могу просто отрезать это ребро, потому что это ребро в родителе.
[21:06.260 --> 21:08.260]  Мне нужно сначала сделать сплей.
[21:08.260 --> 21:13.260]  Сначала число 12 сделать корнем своего сплей-дерева.
[21:13.260 --> 21:18.260]  Понятно, что дело после сплея от 12 произойдет вот такое вращение.
[21:18.260 --> 21:20.260]  12 станет корнем.
[21:20.260 --> 21:25.260]  Ну понятно, сплей-дерево я могу делать вот эти, извините за выражение, зиги, зиг-зиги и зиг-заги.
[21:25.260 --> 21:30.260]  И от этого оно останется корректным сплей-деревом, там все суммы я умею находить и так далее.
[21:30.260 --> 21:35.260]  Вот, поэтому я могу сделать сплей и старое дерево превратить в новое.
[21:35.260 --> 21:40.260]  Ну а дальше я делаю ребро не выделенным, просто отрезаю это ребро.
[21:40.260 --> 21:43.260]  Говорю, что правый сын-то нул ПТР, что у меня нет правого сына.
[21:43.260 --> 21:47.260]  И на место правого сына я подвешиваю вот этот путь 14, 12, 16.
[21:48.260 --> 21:50.260]  Это 14, 20, 16. Вот он.
[21:50.260 --> 21:53.260]  Целиком я его подвешиваю в качестве правого сына 12-кир.
[21:53.260 --> 21:55.260]  Ну то есть делаю вот так.
[21:56.260 --> 21:58.260]  Согласны?
[21:58.260 --> 22:00.260]  Вот, вроде очень просто.
[22:03.260 --> 22:05.260]  Ребра, ребра, ребра.
[22:05.260 --> 22:08.260]  Какие-то ребра у нас будут выделены, какие-то не выделенные.
[22:08.260 --> 22:11.260]  Мы храним пути в сплей-деревьях.
[22:11.260 --> 22:15.260]  И мы более-менее научились переназначать типы ребер.
[22:15.260 --> 22:17.260]  Невыделенный и наоборот.
[22:17.260 --> 22:22.260]  Если мы хотим ребро выделить, то мне нужно подвесить нижнее под дерево к верхнему
[22:22.260 --> 22:24.260]  с помощью, ну просто подвешивания справа,
[22:24.260 --> 22:27.260]  потому что они идут ниже, значит нужно подвешивать справа.
[22:27.260 --> 22:31.260]  А если мне ребро нужно не выделить, то есть из выделенного сделать невыделенным,
[22:31.260 --> 22:35.260]  мне нужно сделать сплей от верхней вершины и правое подерево высечь.
[22:35.260 --> 22:38.260]  Потому что всё что справа, это снизу.
[22:40.260 --> 22:43.260]  Да, вот давайте их корни все эти нарисуем.
[22:43.260 --> 22:45.260]  Давайте в текущей ситуации...
[22:47.620 --> 22:49.620]  Да, извините, это я забыл нарисовать.
[22:49.620 --> 22:51.620]  Вот оно теперь выделенное, потому что я переподвесил.
[22:51.620 --> 22:55.260]  Давайте вот эти ПТР-ки еще нарисуем, кто на что ссылается.
[22:55.260 --> 22:57.260]  Ну, тут все просто.
[22:57.260 --> 23:01.260]  Смотрите, у этого дерева большого, 1, 2, 5, 9, 7,
[23:01.260 --> 23:03.760]  оно ни на что не ссылается, потому что оно и так самое верхнее.
[23:03.760 --> 23:06.760]  Поэтому у этой штуки 0 ПТР.
[23:06.760 --> 23:11.260]  Дальше. Вот есть такой выделенный путь 3, 4.
[23:11.260 --> 23:13.260]  Находим его, вот он.
[23:13.260 --> 23:17.260]  Для корня этого сплэй-дерева говорим, что он подвешен к вершине 2.
[23:17.260 --> 23:19.260]  Значит, я провожу вот такой вот ПТР.
[23:22.260 --> 23:27.260]  Потому что вот это сплэй-дерево целиком подвешено как сын к вершине 2.
[23:27.260 --> 23:31.260]  То, что ребро ведет в корень, совпадение, оно вполне могло быть подвешено вот сюда.
[23:32.260 --> 23:34.260]  Так.
[23:34.260 --> 23:39.260]  Да, например, вот этот путь 13-18, он подвешен куда?
[23:39.260 --> 23:41.260]  Он подвешен к тройке.
[23:41.260 --> 23:44.260]  Поэтому здесь отсюда ребро будет в тройку вести.
[23:44.260 --> 23:48.260]  Не в корень вот этого дерева, а просто в тройку.
[23:50.260 --> 23:52.260]  Ну, например, еще что будет куда подвешено?
[23:52.260 --> 23:55.260]  8 будет подвешено к 6, вот такое будет ребро.
[23:55.260 --> 23:58.260]  Вот этот вот весь большой путь, вот он у меня.
[23:58.260 --> 24:00.260]  16, 20, 14, 12.
[24:00.260 --> 24:02.260]  Вот это вот все подвешено к единице.
[24:02.260 --> 24:05.260]  Поэтому из корня этого поддерева я веду стрелку в единицу.
[24:05.260 --> 24:08.260]  Но я не буду рисовать, потому что уже перегружена картинка.
[24:08.260 --> 24:10.260]  Отсюда будет пунктировано ребро ПТР в единицу.
[24:10.260 --> 24:13.260]  Потому что этот путь целиком подвешено к единице.
[24:13.260 --> 24:15.260]  Вот.
[24:15.260 --> 24:17.260]  Ну и так далее.
[24:17.260 --> 24:21.260]  ПТР из корня текущего сплэй-дерева в произвольную вершину 2.
[24:21.260 --> 24:22.260]  Ну и так далее.
[24:22.260 --> 24:25.260]  ПТР из корня текущего сплэй-дерева в произвольную вершину 2.
[24:25.260 --> 24:28.260]  Туда, куда все это поддерево подвешено.
[24:32.260 --> 24:34.260]  Вот, ну по структуре вроде все.
[24:41.260 --> 24:45.260]  Теперь давайте попробуем понять, как мы будем делать запрос GetSum.
[24:45.260 --> 24:49.260]  Вот, смотрите, пусть у меня все вершины моего дерева разбиты по сплэй-деревям.
[24:49.260 --> 24:54.260]  Как найти сумму на вот таком вот пути от В до корня текущего дерева?
[24:54.260 --> 24:56.260]  От В до Р.
[24:59.260 --> 25:00.260]  Типа того.
[25:00.260 --> 25:05.260]  Но, смотрите, давайте еще для удобства сделаем все вот эти вот ребра выделенными.
[25:08.260 --> 25:12.260]  И еще сделаем все вот эти вот ребра выделенными.
[25:13.260 --> 25:17.260]  И еще сделаем все дочерние ребра из В не выделенными.
[25:18.260 --> 25:23.260]  На самом деле, чтобы сделать процедуру GetSum, я веду процедуру Expose от В.
[25:25.260 --> 25:27.260]  Которая делает следующее.
[25:27.260 --> 25:34.260]  Она делает все ребра на пути от В до корня выделенными, а все дочерние ребра из В не выделенными.
[25:34.260 --> 25:37.260]  Тогда вообще супер сумма на этом пути.
[25:38.260 --> 25:41.260]  Ну, то есть на самом деле, этот путь становится просто целиком сплэй-деревом.
[25:41.260 --> 25:44.260]  Потому что все эти ребра выделенные и он никуда не продолжается.
[25:44.260 --> 25:46.260]  Поэтому это становится целиком сплэй-деревом.
[25:46.260 --> 25:48.260]  Полностью это все, все это сплэй-дерево.
[25:48.260 --> 25:50.260]  Весь путь – это одно сплэй-дерево.
[25:50.260 --> 25:52.260]  И сумма на пути – это та сумма, которая в корне лежит.
[25:52.260 --> 25:56.260]  Потому что в корне лежит как раз таки сумма всего по дереву, то есть сумма на этом пути.
[25:57.260 --> 26:00.260]  Поэтому, если я так сделаю, то у меня сумма на пути вообще за единицу находится.
[26:00.260 --> 26:03.260]  Если я знаю, что это все –If I know that this is one of the indicates of 3534,
[26:03.260 --> 26:07.260]  одно большое расплое дерева, то сумма на пути – это просто значение в корне.
[26:07.260 --> 26:28.260]  Что делает Expose? Делает все ребра на пути от В до корня выделенными,
[26:28.260 --> 26:47.260]  а все ребра, исходящие из В, делать невыделенными.
[26:47.260 --> 26:53.260]  Вот такая процедура Expose. Благо, мы уже умеем делать ребра выделенными и невыделенными.
[26:53.260 --> 26:58.260]  А мы знаем, что там надо что-то переподвесить, что-то отрезать и так далее.
[26:58.260 --> 27:09.260]  Но давайте напишем процедуру, которая делает Expose.
[27:09.260 --> 27:12.260]  Попробую уместиться на этой части доски.
[27:12.260 --> 27:21.260]  Что делает Expose от В?
[27:21.260 --> 27:31.260]  Давайте картинку нарисую, если есть какой-то путь.
[27:31.260 --> 27:58.260]  Смотрите, на этом пути какие-то ребра выделенные, какие-то – невыделенные, какие-то – выделенные, какие-то – невыделенные.
[27:58.260 --> 28:01.260]  И еще, возможно, есть какие-то выделенные нисходящие ребра из В.
[28:01.260 --> 28:04.260]  От них надо избавиться, сделать их невыделенными.
[28:04.260 --> 28:08.260]  Давайте я сначала рассмотрю этот путь, который содержит В.
[28:08.260 --> 28:12.260]  И с помощью сплея В подниму в корень, соответствующий сплее дерева.
[28:12.260 --> 28:17.260]  Первым делом я делаю сплей от В.
[28:17.260 --> 28:24.260]  Что происходит? Теперь у меня этот путь, который изначально содержал В, стал соответствовать сплее дерева, в котором В – это корень.
[28:24.260 --> 28:29.260]  Картинка вот этого пути сейчас вот такая.
[28:29.260 --> 28:36.260]  Да, вот какое-то сплей дерево. Причем левое под дерево – это все, что вышевое, а правое – все, что ниже.
[28:36.260 --> 28:41.260]  А мне нужно отрезать вот это как раз ребро, то есть мне нужно сделать его невыделенным.
[28:41.260 --> 28:43.260]  Давайте просто отрежем.
[28:43.260 --> 28:46.260]  Отрежем и назначим ПТР вот отсюда, вот туда.
[28:46.260 --> 28:50.260]  Потому что когда я отрезаю, то есть когда я делаю ребро невыделенным,
[28:50.260 --> 28:57.260]  у меня, во-первых, разрушается сплей дерева, во-вторых, получается, что вот это маленькое сплей дерево подвешено вот сюда.
[28:57.260 --> 28:58.260]  Ну, давайте так и сделаем.
[28:58.260 --> 29:02.260]  Мне нужно сказать, что ПТР от правого сына – это В.
[29:02.260 --> 29:10.260]  Значит, ПТР от В.райт – это В.
[29:10.260 --> 29:15.260]  Я назначил ПТР, потому что теперь это отдельное сплей дерево, оно должно отсылаться сюда.
[29:15.260 --> 29:16.260]  Ну и отрезаю ребро.
[29:16.260 --> 29:22.260]  Говорю, что В.райт равно ну ПТР.
[29:22.260 --> 29:23.260]  Вот.
[29:23.260 --> 29:29.260]  Я за три строчки выполнил вот это вот нижнее условие, что все ребра, исходящие из В, невыделенные.
[29:29.260 --> 29:32.260]  Согласны?
[29:32.260 --> 29:33.260]  Чудно.
[29:33.260 --> 29:39.260]  Все, значит, здесь я преодолел трудности, теперь у меня вот здесь вот происходит конец моего сплей дерева, здесь все хорошо.
[29:39.260 --> 29:44.260]  Теперь мне нужно пройти снизу вверх и все невыделенные сделать выделенными.
[29:44.260 --> 29:47.260]  Ой, ну давайте.
[29:47.260 --> 29:52.260]  Значит, при этом, смотрите, В у меня теперь сейчас корень своего сплей дерева.
[29:52.260 --> 29:53.260]  Будьте здоровы.
[29:53.260 --> 29:54.260]  Я напишу следующее.
[29:54.260 --> 30:01.260]  Пока ПТР от В не налпойнтер.
[30:01.260 --> 30:04.260]  Потому что, смотрите, сейчас В – это корень своего сплей дерева.
[30:04.260 --> 30:08.260]  В корне сплей дерева ПТР от В указывает как раз такие.
[30:08.260 --> 30:11.260]  То есть вот корень вот этого сплей дерева указывает вот сюда вот.
[30:11.260 --> 30:13.260]  ПТР от него – это вот эта вершина.
[30:13.260 --> 30:16.260]  Как раз таки родительская вершина на восходящем пути.
[30:16.260 --> 30:18.260]  Значит, вот сюда мы указываем.
[30:18.260 --> 30:22.260]  И пока вообще есть родитель, то есть пока я не объединил все в один большой путь до корня,
[30:22.260 --> 30:31.260]  мне нужно вот это вот ребро между этим деревом и вот этим, и вот этой вершиной сделать выделенным.
[30:31.260 --> 30:33.260]  Ну давайте будем делать это как-нибудь.
[30:33.260 --> 30:34.260]  Во-первых, давайте его обзовем.
[30:34.260 --> 30:38.260]  Пусть это будет У.
[30:38.260 --> 30:39.260]  Тогда у меня картинка такая.
[30:39.260 --> 30:40.260]  Вот есть У.
[30:40.260 --> 30:45.260]  Вот есть сплошной путь, который целиком подвешен к У.
[30:45.260 --> 30:49.260]  При этом корнем является вершина В, которая имеет ПТР вот сюда.
[30:49.260 --> 30:55.260]  Так давайте я нарисую по-другому.
[30:55.260 --> 30:58.260]  Вот есть наш путь.
[30:58.260 --> 31:01.260]  И здесь где-то В, и она ссылается вот сюда.
[31:01.260 --> 31:04.260]  То есть по факту это отдельный сплей дерева, У в каком-то другом сплей дереве.
[31:04.260 --> 31:06.260]  Мне нужно их объединить сейчас.
[31:06.260 --> 31:09.260]  Мне нужно выделить это ребро и их склеить по факту.
[31:09.260 --> 31:14.260]  Ну тут как обычно, смотрите, если внезапно у У есть какой-то выделенный сын,
[31:14.260 --> 31:20.260]  то есть если из У кто-то исходит, вот он У, если здесь есть нисходящее выделенное ребро,
[31:20.260 --> 31:21.260]  то мне нужно его удалить.
[31:21.260 --> 31:24.260]  Ну потому что не может быть два выделенных ребра сходящих от одной вершины.
[31:24.260 --> 31:29.260]  Значит тогда мне нужно сначала У сделать корнем и отрезать правого сына.
[31:29.260 --> 31:35.260]  Потому что отрезание правого сына это как раз таки обрубание нисходящего выделенного пути.
[31:35.260 --> 31:40.260]  То есть я первым делом избавляюсь от выделенного ребра, если оно из У торчало.
[31:40.260 --> 31:47.260]  Как я это делаю? Я делаю сплей от У и отрезаю как обычно.
[31:47.260 --> 31:52.260]  Вот у меня, представьте, у меня было У, здесь левое правое под дерево.
[31:52.260 --> 31:57.260]  Мне нужно отрезать это ребро, ну и соответственно нужно не забыть ПТР вот сюда назначить.
[31:57.260 --> 32:00.260]  Потому что это вот все на самом деле подвешено к У.
[32:00.260 --> 32:03.260]  То есть на самом деле вот это вот я просто повторяю.
[32:03.260 --> 32:08.260]  Я говорю, что ПТР от U.right равно U.
[32:10.260 --> 32:14.260]  И U.right равно 0 ПТР.
[32:15.260 --> 32:17.260]  Это? Да.
[32:18.260 --> 32:19.260]  Да.
[32:21.260 --> 32:22.260]  Еще раз?
[32:24.260 --> 32:26.260]  Конечно, конечно, конечно, да.
[32:26.260 --> 32:28.260]  Указатель на область памяти, сама эта область памяти не изменилась.
[32:28.260 --> 32:30.260]  Ушка лежит там же.
[32:30.260 --> 32:33.260]  ПТР от В? Сейчас, сейчас изменим.
[32:34.260 --> 32:38.260]  Смотрите, это мы только подготовку сделали, мы раз выделили это ребро.
[32:38.260 --> 32:40.260]  Теперь вот это ребро тоже не выделенное.
[32:42.260 --> 32:45.260]  Что это значит? Это значит, что теперь картинка вот такая.
[32:45.260 --> 32:48.260]  У У нет правого сына, потому что я его только что отрезал.
[32:49.260 --> 32:54.260]  И мне нужно подвесить под дерево с корнем В справа к У.
[32:54.260 --> 32:57.260]  То есть мне нужно вот это вот все подвесить вот сюда.
[32:58.260 --> 33:01.260]  Потому что вот это вот все должно идти справа, потому что оно ниже.
[33:01.260 --> 33:04.260]  Вот это вот все ниже чем У.
[33:04.260 --> 33:07.260]  Поэтому мне нужно просто вот это вот подвесить в качестве правого сына.
[33:07.260 --> 33:11.260]  Значит, я говорю, что вместо этого я говорю U.right равно В.
[33:11.260 --> 33:14.260]  Потому что В это корень того сплей-дерева.
[33:15.260 --> 33:18.260]  Ну и давайте для красоты сделаем ПТР от В равно 0 ПТР.
[33:21.260 --> 33:23.260]  Потому что В перестало быть корнем своего сплей-дерева.
[33:23.260 --> 33:26.260]  И ПТР я не храню для некорневых лишин.
[33:26.260 --> 33:29.260]  ПТР хранится только для корня сплей-дерева.
[33:31.260 --> 33:34.260]  Если я ничего не забыл, то на этом эксползу закончился.
[33:34.260 --> 33:36.260]  А ну и В равно У, конечно, да.
[33:40.260 --> 33:43.260]  Чтобы подняться, мы теперь будем подвешивать.
[33:43.260 --> 33:46.260]  Когда я сделал вот это вот переподвешивание, вот это вот.
[33:46.260 --> 33:48.260]  У меня вот это вот все одно большое дерево.
[33:48.260 --> 33:51.260]  И мне нужно его подвесить вот сюда.
[33:51.260 --> 33:54.260]  Ну а корнем будет выступать, то есть я вот это переназову за В.
[33:54.260 --> 33:57.260]  И вот это под дерево целиком буду подвешивать снизу вверх.
[34:09.260 --> 34:13.260]  Не соответствует, но я вот здесь, когда рисовал,
[34:13.260 --> 34:16.260]  я многократно говорил, что путь сверху вниз,
[34:16.260 --> 34:20.260]  то есть сверху вниз в нормальном дереве,
[34:20.260 --> 34:23.260]  это путь слева направого сплей-дерева.
[34:24.260 --> 34:27.260]  Смотрите, у меня в моем неявном сплей-дереве
[34:27.260 --> 34:30.260]  все вершины можно перепорядочить слева направо.
[34:30.260 --> 34:33.260]  Стали в корень, сначала печатаем левое под дерево,
[34:33.260 --> 34:35.260]  потом корень, потом правое.
[34:35.260 --> 34:38.260]  Стандартный обход. Поняли, отлично.
[34:38.260 --> 34:41.260]  Ну и собственно это порядок мы просто всегда поддерживаем.
[34:41.260 --> 34:46.260]  Все, вот я утверждаю, что этот код сделал следующее.
[34:46.260 --> 34:49.260]  Он взял, прошелся по пути от В до корня.
[34:49.260 --> 34:52.260]  И все эти ребра сделал выделенными.
[34:52.260 --> 34:55.260]  Понятно, я просто носили, вот эти ребра сделал выделенными.
[34:55.260 --> 34:57.260]  Склеивал все вот эти сплей-деревья.
[34:57.260 --> 35:01.260]  Попутно отрезая вот эти вот хвосты, если они были там тоже подвешены.
[35:01.260 --> 35:03.260]  Все.
[35:03.260 --> 35:06.260]  Ну и дальше, если мне нужно найти сумму на этом пути,
[35:06.260 --> 35:09.260]  то поскольку это все одно большое сплей-дерево,
[35:09.260 --> 35:11.260]  то сумма в нем, это просто сумма в корне.
[35:11.260 --> 35:14.260]  Ну а в корне там просто за вот эту дницу можно найти значение.
[35:14.260 --> 35:16.260]  Понятно?
[35:16.260 --> 35:19.260]  Вот, ну зашибись.
[35:19.260 --> 35:21.260]  Значит, почему это работает?
[35:21.260 --> 35:23.260]  Это конкретно не такая реализация.
[35:23.260 --> 35:25.260]  Каждая конкретная итерация может работать долго.
[35:25.260 --> 35:28.260]  Потому что в худшем случае, если все эти ребра не выделенные,
[35:28.260 --> 35:31.260]  то нам придется N раз перевыделять ребра.
[35:31.260 --> 35:33.260]  Но вот учетно будет за логарифом, оказывается.
[35:33.260 --> 35:36.260]  Ну потому что сплей-дерево.
[35:36.260 --> 35:40.260]  Давайте пока я скажу, что будет учетно за логарифом.
[35:46.260 --> 35:48.260]  Это мы докажем.
[35:48.260 --> 35:50.260]  А пока давайте разберемся, как все остальные операции работают.
[35:50.260 --> 35:52.260]  То есть вот с гитсам мы вроде разобрались.
[35:52.260 --> 35:55.260]  Мы поняли, что гитсам можно просто вызвать экспоуз.
[35:55.260 --> 35:58.260]  И тогда сумма на пути, это значение в корне.
[35:58.260 --> 36:01.260]  Давайте попробуем понять, как работает линк и кат.
[36:08.260 --> 36:11.260]  Значит, давайте попробуем понять, что происходит сначала с кат.
[36:11.260 --> 36:13.260]  Кат у В.
[36:15.260 --> 36:18.260]  Значит, у меня было какое-то там дерево,
[36:18.260 --> 36:20.260]  где было в частности ребро из УВ.
[36:20.260 --> 36:22.260]  И там что-то вот здесь еще было.
[36:24.260 --> 36:26.260]  Мне нужно его удалить.
[36:26.260 --> 36:28.260]  Но это вроде не очень сложно.
[36:28.260 --> 36:30.260]  Мне нужно сначала это ребро сделать не выделенным.
[36:30.260 --> 36:32.260]  Если оно было выделенным.
[36:33.260 --> 36:35.260]  И просто его отрезать.
[36:37.260 --> 36:39.260]  Сейчас. Продон.
[36:41.260 --> 36:42.260]  Да даже проще.
[36:42.260 --> 36:44.260]  Удалить не выделенное ребро вообще ничего не стоит.
[36:44.260 --> 36:46.260]  Нужно просто ПТР от В занулить.
[36:46.260 --> 36:52.260]  Потому что единственные связки от того, что у меня ребра не выделены,
[36:52.260 --> 36:54.260]  как у меня вообще не выделены ребра хранятся в моей структуре?
[36:54.260 --> 36:56.260]  Только с помощью ПТР-ов.
[36:56.260 --> 36:59.260]  Потому что в сплэгеревах только выделенные ребра лежат.
[36:59.260 --> 37:01.260]  А не выделенные получается только за счет ПТР-ов.
[37:01.260 --> 37:05.260]  Потому что, например, у меня вот это подвешено к тройке,
[37:05.260 --> 37:07.260]  как раз по не выделенному ребру.
[37:07.260 --> 37:10.260]  Поэтому из 13-ти идет ПТР в тройку.
[37:10.260 --> 37:12.260]  У меня как раз не выделен это в точности ПТР-ы.
[37:12.260 --> 37:14.260]  Значит, если бы это ребро было не выделенным,
[37:14.260 --> 37:19.680]  выделенным, то мне нужно было просто ПТР от В занулить, сказать, что это нул ПТР. И все, и тогда это
[37:19.680 --> 37:24.820]  ребро автоматически удалится, потому что мы не знаем, что оно существует. А они никак не подвешены.
[37:24.820 --> 37:29.700]  Значит, тогда нужно сначала сделать ребро не выделенным, если оно было выделенным, а потом ПТР от В
[37:29.700 --> 37:47.060]  занулить просто. Сделать УВ не выделенным, ну и ПТР от В равном на ПТР. Давайте скажу, что В равном
[37:47.060 --> 37:52.180]  с плей от В, чтобы оно корнем стало сразу, потому что ПТР у меня только для корня определен. И вот
[37:52.180 --> 38:16.860]  давайте ПТР от В занулить. Так, хорошо. Еще раз. Продон, не эксполс, с плей только мы сделали. Да,
[38:16.860 --> 38:23.620]  так нам ровно это и нужно сделать, потому что теперь это разные деревья, они не связаны. Все, В корень
[38:23.620 --> 38:32.340]  своего дерева. Нет, не должны, потому что все, здесь это разные деревья, они никак не связаны,
[38:32.340 --> 38:37.940]  они независимы, мы не должны друг из друга их получать. То есть у вас там было, не знаю,
[38:37.940 --> 38:42.540]  например, у вас было одно большое дерево. Что такое КАТ? КАТ это по факту разделить ваше дерево
[38:42.540 --> 38:48.300]  на два. Вот первое, вот второе. Они между собой не связаны никак. Это свой независимый
[38:48.300 --> 38:53.460]  самостоятельный корень, они никак между собой не коррелируют. Мы просто забываем про их связь.
[39:01.460 --> 39:09.660]  Так, ну и линк давайте. Линк УВ. Значит это что значит? Значит у меня было под дерево с корнем У,
[39:09.660 --> 39:23.220]  я хочу подвесить к вершине В. Что можно сделать? Я хочу вот эти два дерева склеить с помощью этого
[39:23.220 --> 39:32.860]  ребра. Да, да, да. Значит У равно с плей от У. Сейчас зачем пишу? У меня просто, у меня с плей,
[39:32.860 --> 39:39.660]  наверное, Void просто работает. Да, плей ничего не возвращает. Я делаю У корнем своего дерева и
[39:39.660 --> 40:06.100]  говорю, что теперь оно подвешено к В. Вы про ПТР говорите? Ну да, вы про то, что происходит с ПТР,
[40:06.100 --> 40:11.180]  когда мы делаем с плей. Ну да, то есть на самом деле ПТР это какое-то внутреннее поле для корня,
[40:11.180 --> 40:15.580]  с плей в частности у меня меняется корень после поворота. Надо еще внимательно проследить,
[40:15.580 --> 40:19.900]  что когда мы поворачиваем, мы меняем ПТР. То есть если скажем, у меня была вот такая вот картинка
[40:19.900 --> 40:27.860]  для зига, я делаю зиг и меняю местами ПТР от X и ПТР от P, потому что это стало корнем, а это не
[40:27.860 --> 40:38.700]  корнем. Просто можно посвопать эти поля. Перерыв. Так, давайте дальше поедем. Вы против? Я понял.
[40:38.700 --> 40:44.340]  Смотрите, на самом деле с точки зрения реализации я все рассказал. Да, вопрос,
[40:44.340 --> 40:49.340]  типа насколько вы это поняли, ну вот я пытался. Теперь давайте попробуем доказать, что это учет
[40:49.340 --> 40:55.500]  работает за алгорифм. Для этого нам нужно немножечко вспомнить, как работает с плей деревом,
[40:55.500 --> 41:01.700]  точнее, какой у него учетная стоимость сплея. Кто-нибудь помнит, какая учетная стоимость сплея?
[41:01.700 --> 41:12.540]  Точно. Это определение вы говорите более-менее. Это тоже скорее следствие. Значит, на самом деле,
[41:12.540 --> 41:17.820]  когда мы доказывали что-то про сплей, мы говорили, что учетная стоимость сплея не больше чем один плюс
[41:17.820 --> 41:25.020]  утройная разность рангов. В конце минус в начале. У нас была такая форма. Это прям было.
[41:25.020 --> 41:34.140]  Там мамой клянусь. Вот, мы сейчас ее немножечко подправим и будем ей пользоваться. Значит,
[41:34.140 --> 41:41.540]  смотрите. Давайте я напомню, что у нас такое было R в обычном нормальном сплей дереве. Значит,
[41:41.540 --> 41:51.820]  вот у меня было какое-то сплей дерево. Я давайте скажу следующее. Вот раньше у меня для каждой
[41:51.820 --> 41:59.420]  вершины был определен вес равный единице. Для каждой вершины V вес равен единице. Дальше я
[41:59.420 --> 42:13.140]  определил S от V как сумму весов по дереву. Сумма U под дереве V, W от U. Потому что раньше S это у
[42:13.140 --> 42:17.980]  меня был просто размер текущего под дерево. Вот есть какая-то вершина V. Я знаю все вершины,
[42:17.980 --> 42:23.020]  достижимые из нее внутри сплей дерева, и размер это был в точности S от V. То есть по факту сумма
[42:23.020 --> 42:32.340]  W тоже самое. А рангом я называл просто двоичным логарифм размера. Лог2, S от V. Это то, что было
[42:32.340 --> 42:43.140]  раньше. И если я вводил вот такие вот всякие штуки, то мы с вами показывали, что учетное время
[42:43.140 --> 42:49.980]  работы сплей не превосходит один плюс у тройной разности нового ранга X up, то есть после того,
[42:49.980 --> 42:58.300]  как я сделал сплей от X, и старого, то есть до того, как я сделал сплей от X. Теперь давайте
[42:58.300 --> 43:02.100]  немножко изменим. Давайте скажем, что у меня у каждой вершины вес не единицы на самом деле,
[43:02.100 --> 43:10.460]  а суммарный размер всех сплей деревьев, из которых по ПТР можно добраться до V.
[43:10.460 --> 43:22.140]  Картинка. Вот есть одно сплей дерево. В его вершины с помощью ПТР ведут какие-то стрелки из других
[43:22.140 --> 43:26.700]  сплей деревьев. Мы помним, у нас много сплей деревьев. Они как-то друг на друга ссылаются. То есть
[43:26.700 --> 43:31.100]  корень каждого сплей дерева указывает на какую-то вершину в другом. Так вот, давайте посмотрим на все
[43:31.100 --> 43:36.860]  ребра, торчащие по ПТР вот сюда, вот в эту зашинку V. Ну это какие-то сплей деревья, скажем. Вот это,
[43:36.860 --> 43:47.500]  вот это. Это все стрелки ПТР. И вот это. Также давайте посмотрим, кто еще к ним подвешен по ПТР.
[43:47.500 --> 43:53.700]  Есть какое-то другое сплей дерево, которое вот сюда по ПТР подвешено, и еще кто-нибудь вот сюда
[43:53.700 --> 44:02.420]  подвешен по ПТР. Ну и так далее. Давайте рассмотрим цепочку, точнее рассмотрим все сплей деревья,
[44:02.420 --> 44:11.780]  из которых по цепочке ПТР можно попасть в V. И вот это я назову весом вершины V. Вес V это,
[44:11.780 --> 44:20.580]  давайте я напишу так, один из-за учета вершинки V, плюс суммарный размер всех сплей деревьев,
[44:20.580 --> 44:39.540]  из которых по ПТР можно добраться до V. Всех сплей деревьев, из которых по ПТР можно добраться
[44:39.540 --> 44:55.020]  до V. Вот такое странное определение. А S и R я оставляю. Значит, давайте я просто вот эту строчку
[44:55.020 --> 44:59.420]  сотру, все остальное я оставлю. S это сумма дубльвешек из-под дерева, R это additional
[44:59.420 --> 45:04.740]  grief mass. То есть, например, давайте какую-нибудь картинку нарисую. Если у меня есть вот такое вот
[45:04.740 --> 45:10.700]  сплей дерево, одно, сюда торчит, скажем, такое сплей дерево, сюда такое и к нему еще подвешено вот
[45:10.700 --> 45:19.980]  такое, пусть вот будут размеры X, Y, Z. Тогда у этой вершинки W вес равен 1 плюс X. Давайте я сразу S
[45:19.980 --> 45:26.180]  буду писать. 1 плюс X, потому что вот она сама и еще по дереву размера X сюда подвешена. У этой
[45:26.180 --> 45:38.180]  вершины S это она сама плюс Y, плюс Z. А у этой вершинки я складываю веса детей и добавляю единицу,
[45:38.180 --> 45:42.980]  ну потому что сюда больше никто не подвешен. То есть, нет другого сплая дерева, которое указывало
[45:42.980 --> 45:47.740]  бы сюда по ПТР, поэтому здесь вес у этой вершинки будет просто один, больше никто к нему не подвешен.
[45:47.740 --> 45:55.780]  Поэтому S, вот эта вот сумма весов из-под дерева, это будет 3 плюс X, плюс Y, плюс Z. Вот это я нарисовал
[45:55.780 --> 46:09.700]  значение S для вершины этого под дерева, для вершины этого сплай дерева. Еще раз? Да, вот ровно, ровно это так, да.
[46:17.060 --> 46:24.060]  Значит, оказывается, что при таком изменении потенциальной функции, да, то есть, я, смотрите, я что сказал,
[46:24.140 --> 46:30.020]  я сказал, что у меня вот есть эти ранги, и давайте я скажу, что потенциал внутри сплая дерева это,
[46:30.020 --> 46:37.220]  как обычно, сумма рангов по всем вершинам. Да, это потенциал. Ну и тогда можно показать,
[46:37.220 --> 46:42.460]  что учетное время работы опять подчиняется такому неравенству. Вот это я ставлю без доказательства,
[46:42.460 --> 46:46.740]  ну потому что надо просто в точности повторить доказательства, которые мы в первом семестре
[46:46.740 --> 46:52.660]  приводили, потому что все вот эти вот зигзиги, зиги и зигзаги, они на самом деле, ну то есть,
[46:52.660 --> 46:57.540]  им на самом деле более-менее пофиг на точное значение W. Всем, чем мы пользовались, это что-то типа
[46:57.540 --> 47:02.620]  там, когда мы что-то поворачиваем, мне нужно доказать, что там 2000 логарифм чего-то меньше, там,
[47:02.620 --> 47:07.780]  какой-то суммы, и это все сводило к тому, что вот это плюс это не покрывает все дерево. Значит,
[47:07.780 --> 47:11.260]  там было примерно такое рассуждение, что сумма этих размеров не больше, чем все дерево, не больше,
[47:11.260 --> 47:16.460]  чем вот это вот все. Вот. Ну и здесь тогда то же самое, если тут просто какие W хранятся,
[47:16.460 --> 47:22.260]  вы суммите эти W и эти, понятно, что вы там не больше, чем всю сумму W набрали. Вот.
[47:22.260 --> 47:27.980]  Поэтому вот это вот условие у нас сохраняется. Учет на время сплея вот такое будет. Это без
[47:27.980 --> 47:38.540]  заказательства. Потому что иначе пришлось бы передоказывать весь сплей. Нет. Значит, вот это
[47:38.540 --> 47:48.140]  уже не без заказательств. Ну все. Ну все. Значит, тогда теперь наконец давайте я веду общий потенциал всей
[47:48.140 --> 47:54.900]  нашей системы. Общий потенциал такой. Ну, во-первых, вот эта вот сумма рангов по всем по деревьям,
[47:54.900 --> 48:03.500]  по всем сплее деревьям точнее. Во-вторых, будет второе сплагаемое, которое будет равно следующему.
[48:03.500 --> 48:22.860]  Это количество тяжелых не выделенных ребер. Что такое тяжелые ребра? Смотри прошлую лекцию.
[48:22.860 --> 48:28.940]  Мы определяли heavy-loading-композицию. Мы про каждое ребро говорили. Что такое? Ну,
[48:28.940 --> 48:35.500]  точнее, для каждой вершины. Я смотрел на размеры поддеревьев. Находил самое большое и говорю,
[48:35.500 --> 48:40.300]  что это самое тяжелое ребро. То есть, если скажем, вот это поддерево самое большое, то это тяжелое
[48:40.300 --> 48:47.260]  ребро. Вот оно. Более того, heavy-loading-композиция там как-то однозначно определена. Я говорю,
[48:47.260 --> 48:51.860]  что если несколько равных, то выбираем самый левый. Там с минимальным номером. Так вот,
[48:51.860 --> 48:59.620]  давайте помимо потенциальной функции из сплея дерева добавим количество тяжелых не выделенных
[48:59.620 --> 49:09.460]  ребер. И вот с такой потенциальной функции у меня получится как раз логарифминская учетная
[49:09.460 --> 49:18.100]  стоимость. Ну, давайте попробуем понять, почему это так. Что мне нужно по факту? Самое сложное,
[49:18.100 --> 49:23.740]  это у меня Expose. Чтобы найти сумму на отрезке, мне нужно допустить Expose. Я про него сказал. Он
[49:23.740 --> 49:27.860]  непонятно сколько работает. Потому что там может быть много не выделенных ребер на пути. У них
[49:27.860 --> 49:34.260]  нужно все выделить, склеить деревья и так далее. Давайте поймем, за сколько работает Expose. Напоминаю,
[49:34.260 --> 49:40.380]  что учетное время при введении потенциальной функции мы считаем так. Мы считаем реальное время
[49:40.540 --> 49:53.780]  работы. Плюс изменение потенциала. То есть, вот это вот реальное время работы. Ну,
[49:53.780 --> 50:03.900]  а это на сколько изменился потенциал? То есть, финовый минус фистарый. New минус field. Вот.
[50:03.900 --> 50:14.460]  Хорошо. Теперь давайте вот эту сумму разобьем на два куска. На те операции, которые происходят
[50:14.460 --> 50:21.820]  внутри сплей. Вот этих вот сплей. И все остальное, соответственно. И то же самое с потенциалом.
[50:21.820 --> 50:26.060]  Потенциальную функцию я разобью отдельно на то, что происходит внутри сплей деревьев и отдельно
[50:26.060 --> 50:30.100]  количество тяжелых ребер. То есть, по факту у меня время работы складывается из двух компонентов.
[50:30.100 --> 50:35.100]  Во-первых, сложная операция — это сплей. Потому что сам сплей по себе может долго работать. Потому
[50:35.100 --> 50:39.460]  что дерево может выражаться в бамбук и так далее, чтобы его переподвесить, может потребоваться много
[50:39.460 --> 50:45.940]  времени. Но также вот этот вот while может долго работать, потому что он работает. Сколько было
[50:45.940 --> 50:51.300]  невыделенных ребер на пути, столько мы делаем итерации while. Не нужно все ребра выделить. И вот
[50:51.300 --> 50:59.140]  давайте тогда разделим эти две составляющие. Во-первых, я напишу так out expose. Это out splay.
[50:59.140 --> 51:09.500]  Точнее сумма сплейов. Сумма out splay. У меня сплей многократно вызывается от разных вершин.
[51:09.500 --> 51:17.460]  Давайте я их назову viter. Я вызывал сплей от v, потом сплей от u, потом сплей от его ptr и так далее.
[51:17.460 --> 51:22.340]  Давайте вот набор вершин, от которых я вызываю сплей, это будет viter. Это будет v0, это v1,
[51:22.340 --> 51:28.900]  потом еще раз v2, v3 и так далее. Значит, учет и время сплейов плюс учетное время, ну вот всего
[51:28.900 --> 51:44.580]  остального. Учетное время, давайте напишу, выделение ребер. Потому что время работы складывается из
[51:44.580 --> 51:58.180]  переподвешивания зигзигов внутри сплей дерева и того, сколько раз мы это делаем. Потому что
[51:58.180 --> 52:04.300]  каждое выделение ребер еще сопровождается от единицы действий. Я какие-то ptr переназначаю,
[52:04.300 --> 52:09.980]  делаю детей, переподвешиваю, ptr опять вот здесь поменял и так далее. Вот это вот время, это,
[52:09.980 --> 52:14.300]  грубо говоря, все, что внутри while прошло, кроме сплейов. Сплей отдельно и все остальное внутри
[52:14.300 --> 52:23.860]  вот этой штуки. Так, ну хорошо. Значит, вот это вот я знаю, за сколько работает. Это потому нашему
[52:23.860 --> 52:32.300]  утверждению, сумма по всем i, то есть по всем вершинам откуда мы называем сплей, единица плюс утрой
[52:32.300 --> 52:43.140]  на разные странгов. r штрих от vi минус r от vi. Ну и плюс еще вот эта вот страшная штука.
[52:43.140 --> 52:49.340]  Значит, давайте это пока оставим. Давайте, раз мы уже начали с сплей дерева, давайте вот с этим
[52:49.340 --> 53:18.540]  разберемся. Простой факт. r и плюс один, сори, r и vi плюс один больше равно r штрих от vi.
[53:18.540 --> 53:37.420]  Давайте поймем, что это значит. Смотри, что такое vi под штрихом и vi плюс один просто.
[53:37.420 --> 53:46.940]  Но давайте нарисуем. Вот в какой-то момент я говорю, я рассматриваю вот одно целиком сплей
[53:46.940 --> 53:58.020]  дерева. В нем есть вершина vi, которая является корнем. Это все подвешено вершине vi плюс один,
[53:58.020 --> 54:07.460]  которая тоже является частью какого-то там выделенного пути. И я утверждаю, что после того,
[54:07.460 --> 54:16.100]  что такое r штрих от vi. Ну это момент как раз, когда я подвешиваю это по дереву целиком сюда,
[54:16.100 --> 54:23.140]  а r от vi плюс один это момент, когда я вхожу по факту вот здесь. То есть когда я вот здесь уже
[54:23.140 --> 54:30.500]  все отрезал и переподвесил, ну короче по факту склеил вот эти два пути. То есть r от vi плюс один
[54:30.500 --> 54:36.140]  это какой ранг вершины vi плюс один в момент, когда мы вот сюда вот зашли и уравно vi плюс один.
[54:36.140 --> 54:41.180]  Вот здесь когда уровну vi плюс один, я измеряю ранг. То есть вот здесь будет ранг, а здесь будет ранг
[54:41.180 --> 54:56.300]  штрих, потому что после сплея. Вот. Ну тогда понятно, потому что что такое ранг vi? Давайте
[54:56.300 --> 55:02.100]  напишем s штрих от vi, потому что неравенство между логарифмами то же самое, что неравенство между
[55:02.100 --> 55:09.060]  s-ками. То есть я потенцирую это неравенство, получаю эквивалентное с точки зрения s. Что такое
[55:09.060 --> 55:19.100]  s от vi и vi плюс один? Для vi это все, что по птр смотри в это поддерево. А для vi плюс один это все,
[55:19.100 --> 55:25.220]  что смотрит сюда или еще вот сюда. Потому что я вот это поддерево подвесил к vi плюс один,
[55:25.220 --> 55:31.780]  а значит все, что было достижено по птрам, точнее по птрам до вот этого поддерева,
[55:31.780 --> 55:36.940]  до вот этого сплея дерева, теперь в частности отсюда можно добраться до vi плюс один. Ну просто
[55:36.940 --> 55:40.540]  потому что я вот это вот все подвесил как бы целиком сюда. То есть я склеил эти два дерева,
[55:40.540 --> 55:48.740]  поэтому ранг здесь только увеличился. Все, что раньше было достижено по птрам, то есть все,
[55:48.740 --> 55:53.500]  что раньше по птрам указывалось сюда, оно осталось. Но теперь также добавилось все,
[55:53.540 --> 55:58.740]  что раньше указывалось сюда. Теперь оно тоже указывает вот сюда. То есть по птрам можно
[55:58.740 --> 56:03.460]  подняться сюда, потому что все одно сплошное сплое дерево стало. Получается такое неравенство.
[56:03.460 --> 56:21.180]  s' да. Ну и все, тогда я вот эту штуку могу оценить. Смотрите, у меня каждое следующее вычитаемое больше
[56:21.340 --> 56:29.100]  чем предыдущее уменьшаемое. Поэтому я могу написать здесь меньшее равно 1 плюс утроенный
[56:29.100 --> 56:45.420]  последний ранг минус начальный. R'Vk-R'. Ну а, пардон, да, k. Даже видимо k плюс 1. Да,
[56:45.420 --> 56:51.540]  спасибо, это я наложал. Здесь будет k плюс 1. Там будет утроенная разность. То есть смотрите,
[56:51.540 --> 57:02.580]  у меня с помощью вот того неравенства, у меня сократятся там R'V0 и R'V1. R'V1 и R'V2 и так далее,
[57:02.580 --> 57:10.180]  все сократятся. Останется только R'V0 и R'Vk, где 0 это самое первое слагаемое, k это последнее.
[57:10.180 --> 57:21.300]  И единица сложится в k плюс 1. Так, вроде хорошо. Вроде хорошо. Ну и при этом, смотрите,
[57:21.300 --> 57:30.660]  эта штука, понятно дело, от логарифма. Потому что R это у меня логарифм от s, а s это количество
[57:30.660 --> 57:36.420]  вершин, из которых по ПТР можно добраться до данной. Понятно, что это не больше, чем общий
[57:36.420 --> 57:52.820]  размер всех деревьев. Значит, это есть логарифм. Вот. А пока непонятно. На самом деле,
[57:52.820 --> 58:00.260]  повторю, k это количество итераций в цикле while. То есть сколько ребер я делаю выделенными,
[58:00.260 --> 58:11.740]  сколько ребер было не выделенных, и я их выделяю. Вот это k. Но у нас же они не тяжелые,
[58:11.740 --> 58:15.860]  не легкие, они пока непонятны какие. Вот тут сейчас будет играть второе слагаемое,
[58:15.860 --> 58:29.300]  учетное время выделения ребер. Так, ну давайте разбираться. Давайте нарисуем картинку. Что
[58:29.300 --> 58:39.700]  происходит при выделении ребер? Вот есть наша V, V0, вершина которой мы начинаем. На этом пути
[58:39.700 --> 58:56.340]  есть какие-то не выделенные ребра. Их всего k. Значит, к невыделенных ребер. Давайте их
[58:56.340 --> 59:00.100]  классифицируем. Смотрите, у меня же ведь потенциалия, у меня учитывается количество
[59:00.100 --> 59:04.780]  тяжелых не выделенных ребер. Вот давайте теперь эти не выделенные ребра расклассифицируем на
[59:04.780 --> 59:13.380]  тяжелые и легкие. Вот пусть k это x плюс y, где x это количество тяжелых, а y количество легких
[59:13.380 --> 59:30.300]  из вот этих вот не выделенных. Количество тяжелых это количество легких. Тогда смотрите,
[59:30.300 --> 59:39.380]  в чем прелесть тяжелых ребер? Вот этих вот не выделенных тяжелых в том, что после эксполза они
[59:39.380 --> 59:47.260]  становятся выделенными тяжелыми. А значит потенциал уменьшится хотя бы на x. Потому что раньше
[59:47.260 --> 59:52.540]  они учитывались в потенциале, они были тяжелые не выделенные. Дальше я их выделяю, но они остаются
[59:52.540 --> 59:57.020]  тяжелыми, потому что структура дерева не меняется. То есть я не меняю структуру дерева, я меняю
[59:57.020 --> 01:00:01.780]  только понятие выделенности и невыделенности. Я меняю только сплей деревья. Значит, те которые
[01:00:01.780 --> 01:00:08.220]  были тяжелыми останутся тяжелыми. И вот эта вот штука уменьшится хотя бы на x. Потому что x
[01:00:08.300 --> 01:00:13.980]  ребер были тяжелыми, но не выделенными, а станут тяжелыми выделенными. Поэтому потенциал уменьшится
[01:00:13.980 --> 01:00:25.380]  хотя бы на x. Вот, ну а с y непонятно. Так, что непонятно? Сейчас скажу. Момент.
[01:00:25.380 --> 01:00:40.740]  Да, это правда. Это спасибо. Давайте сразу напишем, что y не больше, чем log n. Потому что
[01:00:40.740 --> 01:00:46.220]  легких ребер на любом восходящем пути максимум log n всегда, это правда. Так,
[01:00:46.700 --> 01:01:00.460]  у меня дельта фи не больше, чем у-х. А, так я понял, смотрите. Проблема выделения может быть в том,
[01:01:00.460 --> 01:01:08.820]  что если вот это вот было легким-невыделенным, то, возможно, у меня вот здесь вот торчало тяжелое
[01:01:08.820 --> 01:01:14.580]  выделенное. А я беру, его не выделяю, а это выделяю. То есть, возможно, из-за того, что я вот эти вот
[01:01:14.580 --> 01:01:18.640]  ребра делаю выделенными, у меня, возможно, потенциал ухудшится. То есть увеличится на y,
[01:01:18.640 --> 01:01:24.660]  потому что ребра, которыми я пожертвовал, чтобы сделать y выделенными, возможно, тоже были тяжелыми.
[01:01:24.660 --> 01:01:29.540]  То есть они вполне себе могли быть тяжелыми выделенными. И мне пришлось их сделать невыделенными,
[01:01:29.540 --> 01:01:36.940]  увеличив потенциал на 1 и сделать вот это ребро выделенным. Поэтому количество тяжелых невыделенных,
[01:01:36.940 --> 01:01:42.540]  Давайте напишем, что количество дельта, вот количество тяжелых невыделенных,
[01:01:42.540 --> 01:01:54.740]  количество тяжелых невыделенных будет меньше равно, чем у-х. То есть оно точно на х уменьшится,
[01:01:54.740 --> 01:02:00.780]  хотя бы на х уменьшится за счет вот этих вот тяжелых невыделенных, а не ребер. И, возможно,
[01:02:00.780 --> 01:02:06.140]  увеличится, но не больше, чем на у, потому что каждая легкая невыделенная дает, ну как бы,
[01:02:06.140 --> 01:02:10.420]  ухудшает не больше, чем на один ответ, потому что оно могло быть соседом только одного тяжелого
[01:02:10.420 --> 01:02:17.380]  невыделенного, который станет невыделенным. Поэтому от у у меня в сумме будет не больше,
[01:02:17.380 --> 01:02:27.020]  чем у. То есть оно ухудшит не больше, чем на у. Давайте напишем. Давайте я вот это расшифрую,
[01:02:27.020 --> 01:02:51.700]  так как каждая ранее тяжелая невыделенная ребро станет выделенным. Это отвечает слагамам
[01:02:51.700 --> 01:02:59.340]  минус х. Каждая тяжелая невыделенная станет выделенным. Вот. А каждая легкая невыделенная
[01:02:59.340 --> 01:03:11.100]  после его выделения может испортить максимум одно тяжелое ранее выделенное. А каждая легкая
[01:03:11.100 --> 01:03:30.460]  невыделенная после своего деления портит не больше одного тяжелого выделенного.
[01:03:30.460 --> 01:03:56.220]  Это отвечает слагамам меньше равно, чем у. Ну все. Так. И при этом х и у равно к. Теперь надо
[01:03:56.380 --> 01:04:06.300]  собрать. Да, давайте вот здесь напишу, что вот это вот время. Это по факту что-то типа у минус х.
[01:04:06.300 --> 01:04:16.900]  Потому что, что такое, давайте попробуем понять, что такое учетное время выделения всех ребер.
[01:04:16.900 --> 01:04:23.460]  Это по факту время, учетное время работы всех операций, кроме сплея, внутри вайл. Какие здесь
[01:04:23.460 --> 01:04:28.660]  операции? Тут все операции, на самом деле, работают за единицу. Вот эти все операции работают за единицу.
[01:04:28.660 --> 01:04:32.460]  И я знаю что происходит с потенциалом. Потенциал меняется настолько, не больше, чем настолько.
[01:04:32.460 --> 01:04:40.480]  Ну и давайте я напишу плюс у от k. Потому что у от k это реальное время работы всех этих операций.
[01:04:40.540 --> 01:04:45.780]  А учетное время, это всегда реальное время работы плюс изменение потенциала. Потенциал изменится
[01:04:45.780 --> 01:04:51.220]  настолько. А реальное время работы у от k, потому что время работы этого вайла, кроме сплея,
[01:04:51.220 --> 01:04:56.340]  пропорционально к, потому что внутри какие-то тривиальные операции. Все, теперь если все это
[01:04:56.340 --> 01:05:04.620]  сложу, смотрите, у меня здесь будет... да, я могу вот это вот к разложить как... сейчас,
[01:05:04.620 --> 01:05:13.820]  пардон. Плохо, да? k не должно... извините, секунду, секунду, секунду, секунду. Плохо,
[01:05:13.820 --> 01:05:30.500]  это я не хочу написать здесь. Сейчас. Так, да, там будет k плюс log n примерно.
[01:05:30.500 --> 01:05:42.820]  Момент.
[01:05:44.820 --> 01:05:51.260]  Смотрите, пафос в том, что если я вот это k распишу как x плюс y плюс 1, у меня x взаимно уничтожатся,
[01:05:51.260 --> 01:05:56.900]  останется 2 y, а y я знаю, что есть логарифм. Тогда у меня получился у человека как раз логарифм.
[01:05:57.780 --> 01:06:04.660]  Х сократятся, останется логарифм плюс 2 y, а y это логарифм, потому что легких на пути как раз
[01:06:04.660 --> 01:06:09.180]  максимум логарифм. Будет все хорошо. Вопрос, почему можно здесь написать что-то подобное?
[01:06:09.180 --> 01:06:22.380]  Почему учетное время всего остального это y минус x? Ну, вот он, потому что... я оценю вот
[01:06:22.380 --> 01:06:28.140]  эту часть, вот она, x плюс y плюс 1 плюс логарифма, плюс учетное время выделения, это не больше,
[01:06:28.140 --> 01:06:42.620]  чем y минус x. Вот он, короче, плюс. Сейчас я пофиксирую. Ну, короче, смотрите, потому что с
[01:06:42.620 --> 01:06:55.220]  ватка на самом деле не получалось. Я скажу как надо. Значит, давайте так. Рассказ Гоблина. Здесь
[01:06:55.220 --> 01:07:00.540]  можно сказать, что вот это вот все работает ну типа быстро, поэтому я тут все стер. Если чуть
[01:07:00.540 --> 01:07:05.420]  аккуратнее, надо на самом деле мне подправить потенциал. Я не хочу этого делать, давайте
[01:07:05.420 --> 01:07:11.060]  красным каким-нибудь сделаю. Смотрите, на самом деле давайте скажем следующее. Давайте скажем,
[01:07:11.060 --> 01:07:18.500]  что все вот эти вот операции работают за c действий, c константа. Тогда суммарно,
[01:07:18.500 --> 01:07:25.980]  while работает за ck плюс время работы с плей-офф. Давайте вот этот c вот сюда вот помещу. Тогда у
[01:07:25.980 --> 01:07:32.180]  меня здесь будет c, здесь будет c, здесь будет c на k плюс 1, а здесь будет плюс ck. И у меня как
[01:07:32.180 --> 01:07:39.260]  раз вот то вот ck с этим, вот те cк сократятся вот с этими, ну или там c плюс 1, ну короче,
[01:07:39.260 --> 01:07:46.820]  короче, вот этот x сократится вот с этими и будет все хорошо. Ну давайте, давайте, раз уж взялся,
[01:07:46.820 --> 01:07:50.820]  давайте я это доведу. То есть еще раз, смотрите, я вот здесь вижу раз, два, три, четыре, пять,
[01:07:50.820 --> 01:07:55.020]  шесть действий. Вот давайте c равно шести. Ну какая-то константа, конкретная константа. Сколько
[01:07:55.020 --> 01:08:00.020]  времени мне нужно, чтобы все это сделать? Давайте, давайте эту константу мультипликативно вынесу
[01:08:00.020 --> 01:08:09.540]  перед потенциалом для всех сплей-деревьев. Тогда у меня здесь останется множитель c. Здесь учетное
[01:08:09.540 --> 01:08:14.060]  время выделения всех ребер, это по-прежнему y-x, потому что настолько изменяется потенциал,
[01:08:14.060 --> 01:08:20.180]  плюс ck это реально время работы, потому что k итерации и здесь по c действия на каждой итерации.
[01:08:20.180 --> 01:08:27.900]  Теперь здесь у меня здесь будет c, здесь будет множитель c, здесь множитель c. Тут остается вот
[01:08:27.900 --> 01:08:33.860]  логарифм, потому что константа по-большим съедается, а здесь будет что-то типа t на x плюс y плюс 1.
[01:08:33.860 --> 01:08:47.780]  Ну и, видимо, надо даже не c, а c плюс 1 написать. А, и c минус 1 хватит, сейчас. Давайте я напишу,
[01:08:47.780 --> 01:08:55.100]  что ck это c на x плюс y и мне нужно, короче, чтобы вот этот x сократился вот с этим x.
[01:08:55.100 --> 01:09:07.660]  Значит, здесь надо написать c минус 1, вроде бы. Ну, подгон. Короче, надо подобрать такой коэффициент,
[01:09:07.660 --> 01:09:13.220]  чтобы все сошлось. Ну, c минус 1, если я здесь напишу, то у меня здесь будет c минус 1,
[01:09:13.220 --> 01:09:25.620]  здесь будет x как раз таки на 1 минус c плюс y на 1 плюс c. Этот x сократится с этим и останется
[01:09:25.620 --> 01:09:32.020]  от логарифма плюс y на c минус 1 и плюс еще 1 плюс c. Ну, то есть, короче, y на константу.
[01:09:32.020 --> 01:10:00.860]  Ну, y я знаю, что это логарифм, и все сошлось. Где? Правее? Так, что здесь не так? А, не сходится,
[01:10:00.860 --> 01:10:08.860]  да? Здесь будет тоже c минус 1, потому что здесь будет нож для c минус 1. Ага, момент. А, нет,
[01:10:08.860 --> 01:10:29.020]  здесь не будет. Почему? То есть, тут надо 1 минус c, да? Было написать? Ну, вы поняли, короче,
[01:10:29.100 --> 01:10:35.740]  доводится. Вообще, часто эти рассуждения опускаются. Говорится, ну, там на константу
[01:10:35.740 --> 01:10:41.420]  домножить, и как раз вот этот x сократится с тем. Ну, вот если возиться, то, ну окей,
[01:10:41.420 --> 01:10:49.220]  1 минус c я здесь поставлю. Тогда как раз там, короче, будет нужный коэффициент. А у меня
[01:10:49.220 --> 01:10:54.100]  потенциал изначально нулевой, потому что ранги у всех нулевые, количество тяжелых вообще нет,
[01:10:54.100 --> 01:10:58.500]  Ребер, потому что изначально ноль, а в конце ограничен по логарифмам, поэтому ничего страшного.
[01:10:58.500 --> 01:11:17.340]  Вот даже отрицательность тут ничего не спортит. Ну, вроде все. Ну, давайте обсудим, что здесь
[01:11:17.340 --> 01:11:23.820]  можно вынести о шпаргалку. Все? Полезно. Ну, я подумал, что это будет как-нибудь, не знаю,
[01:11:24.420 --> 01:11:33.060]  типа наутал вопрос, чтобы не всех этим мучить. Наверное, неплохой план, да. Ну, подумаем. Вот.
[01:11:33.060 --> 01:11:41.220]  Значит, давайте последнее скажу, последние пару минут. Как можно было бы решать эту задачу,
[01:11:41.220 --> 01:11:45.740]  если бы у меня, надо было сказать, сумма на пути, на произвольном пути, а не только вот вершина до
[01:11:45.740 --> 01:11:52.100]  корня? Ну, вот не совсем. Мыльца не можем находить, поскольку у нас дерево динамически перешли,
[01:11:52.100 --> 01:12:02.380]  мыльца не можем находить. Как? Ну, они же переподвешены, их глубины меняются.
[01:12:02.380 --> 01:12:22.180]  Изначальное дерево что? Не, у нас изначально, вообще изначальная конфигурация у нас вот такая,
[01:12:22.180 --> 01:12:31.780]  все отдельные вершинки. Между ними проводятся и удаляются ребра. Поэтому с ульца, ну, скажем так,
[01:12:31.820 --> 01:12:37.660]  я пока не понимаю, как это делать. Давайте расскажу, как знаю. Может, можно и по-другому.
[01:12:37.660 --> 01:12:54.060]  Итак, как искать сумму на произвольном пути? Ну, вот есть какие-то вершины В и У. Давайте мы сначала,
[01:12:54.060 --> 01:13:00.940]  как обычно, запустим эксполз от В и найдем сумму на восходящем пути от В до корня. Потом,
[01:13:00.940 --> 01:13:06.660]  что происходит с У? Давайте мы тоже запустим эксполз от У и в какой-то момент его остановим.
[01:13:06.660 --> 01:13:12.340]  Что делает эксполз от У? Он потихонечку расширяет контролируемый этот вершины путь. Он был сначала
[01:13:12.340 --> 01:13:22.180]  такой, потом он приклеил вот такой кусочек, такой кусочек и так далее. Это слишком, не нужна хэшмапа.
[01:13:22.180 --> 01:13:27.860]  Мы просто в какой-то момент, на самом деле, переходим к вот этому большому пути. Тут не нужна
[01:13:27.860 --> 01:13:33.700]  хэшмапа. Просто в момент, когда мы сюда переходим, мы ее делаем корнем и проверяем правду,
[01:13:33.700 --> 01:13:37.220]  что у нее ПТР равно нал ПТР. То есть, когда я дошел до этого пути, это легко проверить,
[01:13:37.220 --> 01:13:42.460]  что если от нее вызвать сплей, то для нее это нал ПТР. Потому что ПТР для этого дерева нал ПТР,
[01:13:42.460 --> 01:13:47.900]  потому что нет никого выше. Значит, в этот момент мне нужно сделать следующее. Это к ответу добавить,
[01:13:47.900 --> 01:13:53.380]  то есть то, что я уже в нашем складереве накопил, добавить к ответу. А вот это вычесть. Но чтобы это
[01:13:53.380 --> 01:14:00.460]  вычесть, надо сделать сплей. Вот эта вышина Х станет корнем. Вот здесь вот находится все,
[01:14:00.460 --> 01:14:05.580]  что правее, в частности В, а здесь вот находится все, что выше, в частности корень. И это нужно
[01:14:05.580 --> 01:14:11.980]  вычесть. Левое по дереву нужно вычесть. То есть, по факту мы находим тот самый LCA, просто мы
[01:14:11.980 --> 01:14:16.060]  его находим с помощью эксполза. То есть, мы сначала сделали эксполз от В, объединили все это в один
[01:14:16.060 --> 01:14:24.220]  путь, эксполз от В. Потом запустили эксполз от У. И ждем момента, когда мы дойдем до вот этого
[01:14:24.220 --> 01:14:28.860]  большого пути. Когда дошли, мы на самом деле нашли LCA. Но если мы нашли LCA, то нам нужно просто
[01:14:28.860 --> 01:14:33.500]  сложить вот это и вот это. Это благо мы умеем делать. Потому что это все, это уже отдельное сплейдерево,
[01:14:33.500 --> 01:14:44.540]  мы знаем какая там сумма. Но это какая-то часть большого сплейдерево. Вот это вот. Но по факту,
[01:14:44.540 --> 01:14:56.820]  мы научились искать LCA через два эксполз. Ну вот, давайте тогда закончим. Спасибо за внимание и всем удачи.
