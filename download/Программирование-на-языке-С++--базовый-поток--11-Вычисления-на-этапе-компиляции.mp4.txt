[00:00.000 --> 00:12.160]  добрый день давайте начнем сегодня сегодня мы с вами начнем такой условный заключительный
[00:12.160 --> 00:20.000]  третий модуль ну вообще завершающий модуль нашу с вами разговор про язык c++ и в нем мы так
[00:20.000 --> 00:26.080]  ну можно сказать обзорно посмотрим на те возможности которые не были рассмотрены
[00:26.080 --> 00:32.680]  которые не были рассмотрены в курсе ранее ну каким-то причинам ну в первую очередь в первую
[00:32.680 --> 00:38.640]  очередь мы ссориторимся на каких-то нововведениях последних стандартов языка c++ да это c++ 20
[00:38.640 --> 00:46.280]  23 ну и также подробно рассмотрим такую такой аспект программирования на c++ на самом не только
[00:46.280 --> 00:52.640]  c++ как метапрограммирование да то есть программирование скажем так программирование
[00:53.000 --> 00:57.920]  запрограммирование того как программы должны быть запрограммиров в общем давайте потихоньку
[00:57.920 --> 01:02.920]  потихоньку разбираться значит первое про что хотелось бы поговорить в рамках вот этих наших
[01:02.920 --> 01:09.580]  самых вот этого нашего самого вот этого нашего с вами цикла лекции посвященного нововведением
[01:09.580 --> 01:14.980]  стандарта c++ метапрограммирование мы поговорим про вычисление на этапе компиляции давайте как
[01:14.980 --> 01:19.580]  обычно начнем спробischen начнем с проблемы что вообще мы хотим решить то с чего мы
[01:19.580 --> 01:22.580]  мы не можем сделать на текущем уровне развития.
[01:22.580 --> 01:26.580]  Смотрите, мы с вами знаем, что в некоторых местах VZKC++
[01:26.580 --> 01:29.580]  нам необходимо подставлять так называемые
[01:29.580 --> 01:32.580]  compile-time константы.
[01:32.580 --> 01:35.580]  Что это означает? Это означает, что в некоторых местах программы
[01:35.580 --> 01:38.580]  должны вставить такие значения, которые должны быть известны
[01:38.580 --> 01:41.580]  уже на этапе компиляции. Одним из самых известных таких примеров
[01:41.580 --> 01:45.580]  являются C-style массивы, являются обычные C-шные массивы.
[01:45.580 --> 01:48.580]  Вот пример. У меня C-шный массив,
[01:48.580 --> 01:51.580]  который называется C-style,
[01:51.580 --> 01:54.580]  и, соответственно, если я хочу
[01:54.580 --> 01:59.580]  указать его размер
[01:59.580 --> 02:02.580]  в квадратных скобках,
[02:02.580 --> 02:05.580]  то известно, что этим самым размером
[02:05.580 --> 02:08.580]  может являться только нечто, что является
[02:08.580 --> 02:11.580]  константой известной на этапе компиляции.
[02:11.580 --> 02:14.580]  Согласно стандарту языка программирования C++,
[02:14.580 --> 02:17.580]  то обычные массивы, которые создаются на стеке,
[02:17.580 --> 02:20.580]  или там глобально, в общем, обычные такие вот C-шные массивы,
[02:20.580 --> 02:23.580]  они обязаны в квадратной скобке принимать нечто,
[02:23.580 --> 02:26.580]  что известно, что вычислимо на этапе компиляции.
[02:26.580 --> 02:29.580]  То есть, если мы подаем что-то, что известно на этапе runtime,
[02:29.580 --> 02:32.580]  например, вводим с клавиатуры число n, подаем его туда,
[02:32.580 --> 02:35.580]  то вообще говоря, стандарт языка программирования C++ такое не позволяет.
[02:35.580 --> 02:38.580]  В чем проблема?
[02:38.580 --> 02:41.580]  Ну, смотри, действительно, в этом примере я могу
[02:41.580 --> 02:44.580]  подать значение n, который известный на этапе компиляции,
[02:44.580 --> 02:47.580]  то есть, во-первых, константа n является константой,
[02:47.580 --> 02:50.580]  во-вторых, ее значение известной на этапе компиляции все OK.
[02:50.580 --> 02:53.580]  Кроме того, второй пример, который сейчас встречается,
[02:53.580 --> 02:56.580]  это, собственно, передача параметров шаблонов.
[02:56.580 --> 02:59.580]  Мы знаем, что шаблоны тоже могут принимать параметры
[02:59.580 --> 03:02.580]  в виде числовых значений, ну и, естественно, параметры шаблонов
[03:02.580 --> 03:05.580]  тоже должны быть известны на этапе компиляции. Почему?
[03:05.580 --> 03:08.580]  Потому что шаблоны, это на самом деле не код, который уже существует,
[03:08.580 --> 03:11.580]  в процессе компиляции программ. Ну, соответственно, чтобы ему сгенерировать код,
[03:11.580 --> 03:14.580]  естественно, ему нужно знать все значения в сети,
[03:14.580 --> 03:17.580]  по которым в него подставлены. Соответственно, все то, что мы передаем
[03:17.580 --> 03:20.580]  внутрь треугольных скобок, тоже, естественно, должно удовлетворять требованию
[03:20.580 --> 03:23.580]  вычислимости на этапе компиляции. Ну и тут, так как n является
[03:23.580 --> 03:26.580]  константой времени компиляции, n умножить на n плюс 32, тоже вычислимый на этапе компиляции,
[03:26.580 --> 03:29.580]  все OK, все супер.
[03:29.580 --> 03:32.580]  Вот. Соответственно,
[03:32.580 --> 03:35.580]  на прошлом слайде было представлено
[03:35.580 --> 03:38.580]  был представлен такой термин, как константное выражение. Давайте его
[03:38.580 --> 03:41.580]  подробнее обсудим. Константное выражение – это просто выражение, которое может быть вычислено
[03:41.580 --> 03:44.580]  на этапе компиляции. Вот. Соответственно, ну, понятное дело,
[03:44.580 --> 03:47.580]  что n умножить на n в данном контексте плюс 32 является
[03:47.580 --> 03:50.580]  константным выражением, потому что оно может быть вычислено
[03:50.580 --> 03:53.580]  на этапе компиляции. Давайте посмотрим на следующую
[03:53.580 --> 03:56.580]  проблему. Представьте себе следующую ситуацию. OK.
[03:56.580 --> 03:59.580]  Я понимаю, что в качестве значений,
[03:59.580 --> 04:02.580]  которые я могу передавать в качестве размера массива,
[04:02.580 --> 04:05.580]  я должен указывать какое-то константное выражение или какую-то
[04:05.580 --> 04:08.580]  константу, которая известна на этапе компиляции. Ну, смотрите,
[04:08.580 --> 04:11.580]  если размер массива представим в виде n в квадрате плюс 32,
[04:11.580 --> 04:14.580]  то кажется, что с этим никаких проблем нет. Если n – это штука,
[04:14.580 --> 04:17.580]  которая известна на этапе компиляции, то я просто пишу n умножить на n плюс 32
[04:17.580 --> 04:20.580]  и, соответственно, подаю на вход
[04:20.580 --> 04:23.580]  мои программы. А что если
[04:23.580 --> 04:25.580]  что если
[04:25.580 --> 04:28.580]  нечто, которое я хочу записать внутри квадрата скобок,
[04:28.580 --> 04:31.580]  тоже зависит от некой константы, известной на этапе
[04:31.580 --> 04:33.580]  компиляции, для констинт
[04:33.580 --> 04:36.580]  n равно сотне,
[04:36.580 --> 04:39.580]  но при этом не представимо вот в таком простом виде, как
[04:39.580 --> 04:42.580]  n умножить на n плюс 32. То есть представьте, что я хочу, например, вычислить
[04:42.580 --> 04:45.580]  n в третьей степени.
[04:45.580 --> 04:48.580]  Допустим, я хочу, чтобы размер
[04:48.580 --> 04:51.580]  массива был равен n-ке в третьей степени.
[04:51.580 --> 04:54.580]  При этом n-ка – это некоторая константа, которую я хочу…
[04:54.580 --> 04:57.580]  Я не хочу для нее заводить какую-то магическую константу,
[04:57.580 --> 05:00.580]  всегда писать 100, поэтому я тут завожу переменную n,
[05:00.580 --> 05:03.580]  записываю значение 100, и если мне вдруг нужно вместо n
[05:03.580 --> 05:06.580]  брать значение 1000, скажем 50, то я могу просто нам
[05:06.580 --> 05:09.580]  сменять это значение. Я хочу, чтобы это же изменение касалось
[05:09.580 --> 05:12.580]  и того, что вычисляется в квадратных скобках.
[05:12.580 --> 05:15.580]  Понятное дело, что n в третьей степени…
[05:15.580 --> 05:18.580]  Если это константы известной на этапе компиляции, то n в третьей степени
[05:18.580 --> 05:21.580]  вообще, говорят, наверное, тоже должно быть известной на этапе компиляции.
[05:21.580 --> 05:24.580]  Согласны? Согласны?
[05:24.580 --> 05:27.580]  В чем проблема? Проблема в том, что n известный
[05:27.580 --> 05:30.580]  на этапе компиляции, но если я в квадратной скобке
[05:30.580 --> 05:33.580]  подставлю функцию… Мне немного аргумента перепутаны,
[05:33.580 --> 05:36.580]  ну ладно. Если я в аргументы функции…
[05:36.580 --> 05:39.580]  Если я в аргументы, простите, квадратных скобок
[05:39.580 --> 05:42.580]  передаю некоторую функцию, то вообще говоря, функция
[05:42.580 --> 05:45.580]  rx10++ – это сущность этапа исполнения программы.
[05:45.580 --> 05:48.580]  Когда мы вызываем функцию, мы с вами говорим про то,
[05:48.580 --> 05:51.580]  что функция вызывается во время исполнения программы,
[05:51.580 --> 05:54.580]  а не во время компиляции. Поэтому если я попытаюсь сделать
[05:54.580 --> 05:57.580]  так, то несмотря на то, что у меня n является
[05:57.580 --> 06:00.580]  константы, которые известны на этапе компиляции,
[06:00.580 --> 06:03.580]  компилятор начнет ругаться. Он скажет, что, погодите,
[06:03.580 --> 06:06.580]  тут я в качестве аргумента квадратных скобок
[06:06.580 --> 06:09.580]  передаю результат вычисления функции,
[06:09.580 --> 06:12.580]  а функция вычисляется в рантайме. Функция не вычисляется
[06:12.580 --> 06:15.580]  на этапе компиляции. Соответственно, получается так,
[06:15.580 --> 06:18.580]  что, к сожалению, у меня не получится
[06:18.580 --> 06:21.580]  в квадратной скобке передать результат
[06:21.580 --> 06:24.580]  вызвав некоторые функции от константного выражения.
[06:26.580 --> 06:29.580]  Проблем понятен? То есть, хотелось бы
[06:29.580 --> 06:32.580]  иметь некий способ вычислять значение
[06:32.580 --> 06:35.580]  каких-то функций на этапе компиляции. Если бы я смог
[06:35.580 --> 06:38.580]  вычислять значение функции на этапе компиляции,
[06:38.580 --> 06:41.580]  то, передав функцию константы времени компиляции,
[06:41.580 --> 06:44.580]  при этом функция тоже может вычисляться
[06:44.580 --> 06:47.580]  на этапе компиляции, то тогда�� я получу
[06:47.580 --> 06:50.580]  возможность делать выч Eigenavigicide на этапе компиляции
[06:50.580 --> 06:52.580]  значение, которое тоже будут известны в этапе компиляции.
[06:52.580 --> 06:54.580]  Пока мы этого делать не можем, почему?
[06:54.580 --> 06:58.580]  Потому что те функции, с которыми мы с вами знакомились в течение курса,
[06:58.580 --> 07:01.580]  они обладают этим свойством, что они всегда вычисляются только во время исполнения программы.
[07:01.580 --> 07:05.580]  Поэтому компилятор их вычислять во время компиляции не будет.
[07:05.580 --> 07:10.580]  Окей, соответственно, главный вопрос, как все-таки заставить компилятор
[07:10.580 --> 07:12.580]  что-то вычислять на этапе компиляции?
[07:12.580 --> 07:16.580]  То есть, если у меня есть некоторая функция, которую я хочу вычислять на этапе компиляции,
[07:16.580 --> 07:20.580]  то как мне заставить компилятор это сделать?
[07:20.580 --> 07:23.580]  Ну и, на самом деле, у этого вопроса есть довольно-таки простой ответ,
[07:23.580 --> 07:26.580]  но прежде чем мы к нему перейдем, давайте немного пострадаем
[07:26.580 --> 07:29.580]  и пройдемся, так скажем, по историческим этапам развития C++,
[07:29.580 --> 07:36.580]  как развивалась история вычислений на этапе компиляции в языке C++.
[07:36.580 --> 07:44.580]  И в итоге придем к тому, к чему пришел стандарт в C++ 17 и C++ 20.
[07:44.580 --> 07:49.580]  На чем основаны классические compile-time вычисления?
[07:49.580 --> 07:53.580]  Ну, смотрите, для того, чтобы заставить компилятор что-то вычислять на этапе компиляции,
[07:53.580 --> 07:57.580]  нам нужно, вообще говоря, понять, что может сделать компилятор на этапе компиляции.
[07:57.580 --> 08:01.580]  Ну, смотрите, первое, про что мы с вами сказали в самом начале сегодняшнего занятия,
[08:01.580 --> 08:07.580]  так это то, что компилятор на этапе компиляции в первую очередь подставляет все шаблонные параметры.
[08:07.580 --> 08:15.580]  Если я создам некоторый класс C и в него передам какую-то константу времени компиляции,
[08:15.580 --> 08:19.580]  то эта константа, соответственно, в саму структуру или в сам класс,
[08:19.580 --> 08:31.580]  давайте напишем template int n, класс C,
[08:31.580 --> 08:38.580]  то вот этот вот шаблонный параметр n подставится во все нужные места класса еще на этапе компиляции.
[08:38.580 --> 08:45.580]  То есть, грубо говоря, если у меня внутри есть какой-то метод voidf,
[08:45.580 --> 08:51.580]  и тут есть создание перемены int x равно n, то вместо вот этого значения, вместо вот этой перемены n,
[08:51.580 --> 08:56.580]  подставится ровно то значение, которое я передаю при инстанцировании шаблона,
[08:57.580 --> 09:02.580]  то это значение 100, оно как раз-таки будет подставлено вот сюда на этапе компиляции.
[09:02.580 --> 09:05.580]  То есть, что делает компилятор во время компиляции?
[09:05.580 --> 09:10.580]  Это подставляет шаблонные параметры в те места программы, которые необходимы.
[09:10.580 --> 09:16.580]  Это первое. Второе. Что еще делает компилятор?
[09:16.580 --> 09:21.580]  Компилятор, естественно, на этапе компиляции пытается задать значение некоторым константам,
[09:21.580 --> 09:25.580]  которые могут быть вычтены на этапе компиляции. Давайте посмотрим на конкретный пример.
[09:25.580 --> 09:29.580]  Смотрите, если я создам некоторую структуру, которая называется integral constant,
[09:29.580 --> 09:33.580]  я создаю структуру integral constant, которая будет параметризована
[09:33.580 --> 09:37.580]  некоторым типом integer и некоторым значением.
[09:37.580 --> 09:41.580]  Собственно, значение я могу передать тоже в шаблонный параметр.
[09:41.580 --> 09:48.580]  Назову структуру integral constant и дальше заведу статическую константную переменную integer k value равно value.
[09:48.580 --> 09:53.580]  Что тут произойдет? Смотрите, integral constant это шаблонная структура.
[09:53.580 --> 09:55.580]  При установке параметра в шаблонную структуру что произойдет?
[09:55.580 --> 09:59.580]  У меня, во-первых, вместо типа integer подставится какой-то конкретный тип.
[09:59.580 --> 10:06.580]  Допустим int. Вот здесь, в этой строчке я в качестве параметра integral constant
[10:06.580 --> 10:08.580]  передаю int и 100. Что это будет означать?
[10:08.580 --> 10:13.580]  Это будет означать, что вместо этого типа integer автоматически будет подставлен int еще на этапе компиляции.
[10:13.580 --> 10:18.580]  А во-вторых, вместо этого значения 100, который передается в качестве второго шаблонного параметра,
[10:18.580 --> 10:20.580]  вот сюда подставится значение 100.
[10:20.580 --> 10:23.580]  И в итоге что у меня получится? У меня получится int-овая константа,
[10:23.580 --> 10:25.580]  которая изначально провентилизирует значение 100.
[10:25.580 --> 10:30.580]  При этом, так как она константа, то эта константа тоже будет известна на этапе компиляции.
[10:30.580 --> 10:32.580]  Понятно?
[10:32.580 --> 10:38.580]  Поэтому вот эту константную статическую переменную я вполне себе спокойно смогу использовать
[10:38.580 --> 10:42.580]  внутри квадратных скобок, которые требуют константа времени компиляции,
[10:42.580 --> 10:47.580]  ну и также внутри STD array, которые тоже требуют константа времени компиляции.
[10:47.580 --> 10:51.580]  То есть первое, что мы знаем, первое, какой факт не выберем,
[10:51.580 --> 10:54.580]  так это то, что компилятор подставляет все шаблонные параметры.
[10:54.580 --> 10:57.580]  И, соответственно, если какая-то переменная является константной,
[10:57.580 --> 11:02.580]  то, соответственно, по возможности он старается тоже вычислить ее на этапе компиляции.
[11:02.580 --> 11:04.580]  Окей.
[11:04.580 --> 11:09.580]  Вот то, что я написал здесь, то есть то, что я написал вот эту самую структуру integral constant,
[11:09.580 --> 11:12.580]  это на самом деле полноценный аналог аналогичной структуры из стандартной библиотеки.
[11:12.580 --> 11:15.580]  То есть если мы возьмем заголовочный файл type traits,
[11:15.580 --> 11:18.580]  то там мы найдем вот эту самую структуру std integral constant.
[11:18.580 --> 11:25.580]  Ну и, соответственно, вот эта самая std integral constant устроена ровно так же, как я описал здесь.
[11:25.580 --> 11:29.580]  То есть в ней есть статическое константное поле value,
[11:29.580 --> 11:33.580]  которое просто-напросто хранит вот это самое значение.
[11:33.580 --> 11:35.580]  Так, ну тут повис не мой вопрос.
[11:35.580 --> 11:37.580]  Ну, соответственно, зачем нам такая структура?
[11:37.580 --> 11:39.580]  То есть как бы зачем нам использовать какую-то побочную структуру,
[11:39.580 --> 11:41.580]  если мы можем просто-напросто подставлять константу?
[11:41.580 --> 11:46.580]  То есть зачем нам в качестве промежуточного этапа использовать какую-то структуру,
[11:46.580 --> 11:51.580]  которая внутри себя хранит статическое поле value?
[11:51.580 --> 11:57.580]  А вот для чего, смотрите, давайте я поступлю следующим образом.
[11:57.580 --> 12:03.580]  Давайте я попробую организовать вычисление некоторой функции на этапе компиляции.
[12:03.580 --> 12:07.580]  Ну, например, давайте я попробую организовать вычисление функции возведения в квадрат.
[12:07.580 --> 12:09.580]  Что я для этого сделаю?
[12:11.580 --> 12:36.580]  Я напишу структуру square и унаследую ее публичным образом, естественно, от std integral constant от int и n умножить на n.
[12:36.580 --> 12:44.580]  Вот, и дальше, если мне в каком-то месте программа, ну, например, вот здесь,
[12:44.580 --> 12:52.580]  то есть при создании массива int, если мне при создании массива,
[12:52.580 --> 12:58.580]  если у меня при создании массива возникнет необходимость вычислить какую-то функцию от константа известный этап компиляции,
[12:58.580 --> 13:02.580]  я могу поступить следующим образом.
[13:02.580 --> 13:07.580]  Я могу инстанцировать структуру square параметром, ну, допустим, n.
[13:07.580 --> 13:12.580]  Да, ну, n вот этот вот самый параметр, вот эта самая константа.
[13:12.580 --> 13:17.580]  И взять у нее значение статического поля value.
[13:17.580 --> 13:23.580]  Почему я уверен, что вот это значение обязательно будет вычислено на этапе компиляции?
[13:23.580 --> 13:29.580]  По следующей причине, смотрите, во-первых, я точно знаю, что так как, ну, давайте тут вместо n 100 напишем.
[13:29.580 --> 13:34.580]  Во-первых, я точно знаю, что все шаблонные параметры подставляются на этапе компиляции, согласны?
[13:34.580 --> 13:42.580]  Вот, то есть я беру сотку, подставляю вот сюда. Соответственно, шаблонный класс square инстанцируется с помощью параметра n равный 100.
[13:42.580 --> 13:48.580]  Дальше, чтобы инстанцировать square, ему нужно инстанцировать класс integral constant.
[13:48.580 --> 13:53.580]  Инстанцируется класс integral constant со значениями int и n умножить на n.
[13:53.580 --> 13:59.580]  Вот. Но вот это значение n умножить на n, так как n подставляется на этапе компиляции, и плюс, смотрите, что самое главное,
[13:59.580 --> 14:07.580]  чтобы компилятору понять, от чего будет наследоваться класс square, ему нужно будет обязательно вычислить вот это значение и сюда подставить.
[14:07.580 --> 14:12.580]  Понятно? То есть у компилятора возникает необходимость в инстанцировании square.
[14:12.580 --> 14:17.580]  А при инстанцировании square у компилятора возникает необходимость в инстанцировании integral constant от вот этого значения.
[14:17.580 --> 14:23.580]  И поэтому, так как компилятор понимает, ну окей, n это константы известной этапы компиляции, вот это тоже известный этап компиляции,
[14:23.580 --> 14:28.580]  n умножить на n я могу вычислить на этапе компиляции, точнее, мне необходимо вычислить это на этапе компиляции,
[14:28.580 --> 14:31.580]  чтобы можно было инстанцировать integral constant, и он ровно этим и займется.
[14:31.580 --> 14:35.580]  То есть он вычислит n умножить на n на этапе компиляции, подставит в integral constant,
[14:35.580 --> 14:43.580]  а в integral constant существует статическое поле value, которое будет равно как раз к этому самым бернному значению.
[14:43.580 --> 14:53.580]  Понятно? То есть каким образом мы смогли компилятор заставить выполнить вычисление?
[14:53.580 --> 14:59.580]  Мы его заставили тем, что при передаче шаблонных параметров компилятор обязан их вычислить на этапе компиляции,
[14:59.580 --> 15:06.580]  если это возможно. Понятное дело, что это возможно, так как n это шаблонный параметр, который представляется на этапе компиляции,
[15:06.580 --> 15:09.580]  поэтому у него такая возможность есть.
[15:09.580 --> 15:16.580]  Используя механизм подстановки шаблонных параметров, мы с вами смогли заставить компилятор делать полезную работу.
[15:19.580 --> 15:26.580]  Давайте посмотрим на другие примеры. Давайте посмотрим на примеры каких-нибудь более смыслных функций.
[15:26.580 --> 15:29.580]  Смотрите, возведение в квадрат кажется очень скучно. Почему?
[15:29.580 --> 15:37.580]  Потому что, вообще говоря, я тут вполне себе мог и раньше написать n умножить на n.
[15:37.580 --> 15:41.580]  То есть в вычислении n в квадрате на этапе компиляции это не очень интересно,
[15:41.580 --> 15:52.580]  потому что если я тут напишу n умножить на n, то компилятор это бы все равно вычислил, даже не требуя этой самой структуры.
[15:52.580 --> 15:56.580]  Давайте посмотрим на какой-нибудь более смыслный пример. Ну и более смыслный пример, например, вычисление факториала.
[15:56.580 --> 15:59.580]  Вряд ли я сюда смогу написать какой-нибудь факториал от n.
[15:59.580 --> 16:03.580]  Понятное дело, что, во-первых, функции факториала встроенные в c++ нет,
[16:03.580 --> 16:12.580]  во-вторых, даже если я напишу какую-то стороннюю функцию, то, как я уже сказал, функции вычисляются на этапе исполнения программы,
[16:12.580 --> 16:15.580]  поэтому на этапе компиляции компилятор вычислять эту функцию не будет.
[16:15.580 --> 16:21.580]  Давайте попробуем как-нибудь компилятор заставить вычислить факториал на этапе сборки программы.
[16:21.580 --> 16:24.580]  Предложение будет следующее. Как это будет устроено?
[16:24.580 --> 16:30.580]  Спойлер написан на экране. Давайте его проведем тоже на доске, чтобы проследить за логикой.
[16:30.580 --> 16:35.580]  Смотрите, чтобы заставить что-то вычислять на этапе компиляции, необходимо это все обернуть в шаблонный параметр.
[16:35.580 --> 16:43.580]  Давайте я так и поступлю. Давайте напишу шаблонную структуру факториал,
[16:47.580 --> 16:54.580]  который будет параметризован как раз таки значением, от которого нужно вычислить факториал.
[16:54.580 --> 17:04.580]  Что мне дальше нужно сделать? Мне дальше нужно каким-то образом компилятор заставить делать вычисление.
[17:04.580 --> 17:13.580]  Чтобы сделать вычисление, ему нужно эту n превратить во что-то, что будет поставлено в какой-то другой шаблонный параметр,
[17:13.580 --> 17:18.580]  в какой-то другой структуру. Смотрите, что мы знаем про факториал?
[17:18.580 --> 17:23.580]  Мы знаем, что факториал от n умножен на факториал от n-1.
[17:23.580 --> 17:38.580]  Давайте я факториал унаследую от факториала от n умножить на факториал от n-1.
[17:38.580 --> 17:59.580]  Давайте на одной доске напишу вот тут. Мы наследуем от факториала от n умножить на факториал от n-1,
[17:59.580 --> 18:19.580]  то есть смотрите, что я говорю? Я говорю, что факториал от n унаследовано от структуры...
[18:19.580 --> 18:46.580]  Я говорю, что факториал от n это целочисленная константа, которая внутри себя хранит значение n умножить на факториал от значения факториала n-1.
[18:46.580 --> 18:52.580]  Понятно? То есть что происходит? Снова, n это значение, которое должно быть известным в этапе компиляции.
[18:52.580 --> 19:00.580]  Действительно, я его подставляю вот сюда, допустим, факториал. Подставляю его вот так.
[19:00.580 --> 19:09.580]  Факториал от n... value. Вот, то есть n-ку я подставляю на этапе компиляции.
[19:09.580 --> 19:15.580]  Соответственно, подставляется n-ка и при инстанцировании факториала компилятор понимает, что так как мне нужно инстанцировать факториал,
[19:15.580 --> 19:21.580]  то мне нужно и инстанцировать базовый класс. Компилятор начинает инстанцировать базовый класс и, соответственно,
[19:21.580 --> 19:25.580]  понимает, что ему нужно... Для того, чтобы понять, что это вообще за класс, чтобы его инстанцировать,
[19:25.580 --> 19:29.580]  необходимо вычислить вот это значение. Соответственно, компилятор приступает к учтению это значение.
[19:29.580 --> 19:35.580]  То есть он рекурсивно начинает вычислять факториал от n-1, берет оттуда значение, это значение умножает на n,
[19:35.580 --> 19:44.580]  соответственно, вот в integer const в статическом polyvalue будет записано значение факториала от n. Понятно?
[19:44.580 --> 19:47.580]  В чем проблема? Да.
[19:48.580 --> 19:55.580]  Как он может понять, что в стриале есть polyvalue, если он уже увидел, что он наследует и его иностранство?
[19:55.580 --> 20:03.580]  Он не хочет еще параметры расследования, и он сразу определяется, что у него есть polyvalue.
[20:03.580 --> 20:06.580]  Как он поймет, что у него есть polyvalue? Очень просто.
[20:06.580 --> 20:11.580]  Во-первых, чтобы понять, что у него есть polyvalue, ему сначала нужно вот этот шаблон инстанцировать.
[20:11.580 --> 20:17.580]  Он его сначала инстанцирует. Понятно, что при постановке конкретного n ему конкретно n известен.
[20:17.580 --> 20:27.580]  После того, как он инстанцирует этот класс, естественно, станут известны ему все поля, которые там есть.
[20:27.580 --> 20:34.580]  Так как любой факториал в итоге является наследником integer constant, а в integer constant есть статическое polyvalue,
[20:34.580 --> 20:38.580]  то и факториал n-1 тоже есть статическое polyvalue.
[20:38.580 --> 20:48.580]  Все видят проблему типичной рекурсивной реализации факториала.
[20:48.580 --> 20:54.580]  То есть мы написали рекурсивное определение факториала, и вообще говорят, тут у нас нигде нет конца рекурсии.
[20:54.580 --> 21:03.580]  Согласны? То есть я буду вычислять факториал от 100, потом рекурсивно буду вычислять факториал от 99, факториал от 98, факториал от единицы, факториал от нуля,
[21:03.580 --> 21:08.580]  и дальше пойдет вычисление факториала от минус единицы, минус двойки и так далее.
[21:08.580 --> 21:13.580]  То есть тут не хватает конца рекурсии. Вопрос вам.
[21:13.580 --> 21:20.580]  А как мы реализуем конец рекурсии? Как мы в терминах наследования или в терминах структуры скажем,
[21:20.580 --> 21:25.580]  что дальше структуры инстанцировать не надо, на этом стоит остановиться, тут мы уже знаем ответ.
[21:25.580 --> 21:30.580]  Какой механизм нам позволит это сделать?
[21:30.580 --> 21:34.580]  Так, введем еще одну структуру. Какую?
[21:39.580 --> 21:43.580]  Так, ну смотрите, вот тут, смотрите, у меня факториал, вызывает всегда факториал.
[21:43.580 --> 21:47.580]  То есть тут вроде как нигде не фигурируется эта самая другая структура.
[21:47.580 --> 21:56.580]  Вот, супер, да, специализация уже близко к правде, то есть только не частичная специализация,
[21:56.580 --> 22:01.580]  тут нам поможет полная специализация. Вот, почему? Ну смотрите, тут мы что можем сказать?
[22:01.580 --> 22:07.580]  Напомню про идею специализации. Что такое специализация шаблона?
[22:07.580 --> 22:12.580]  Специализация шаблона позволяет вам сказать, что при некоторых конкретных параметрах,
[22:12.580 --> 22:17.580]  шаблон нужно инстанцировать чуть иначе. То есть я говорю, что в общем случае факториал устроен вот так,
[22:17.580 --> 22:22.580]  но в частности, как пишется полная специализация?
[22:22.580 --> 22:27.580]  Полная специализация пишется с пустыми треугольными скобками, дальше я снова прописываю ту самую
[22:27.580 --> 22:40.580]  структуру шаблонную, факториал, но при этом дополнительно прописываю эту структуру шаблонную.
[22:40.580 --> 22:45.580]  Дополнительно прописываю треугольные скобки и в треугольных скобках указываю, для какого параметра
[22:45.580 --> 22:51.580]  факториал должен вести себя иначе. В случае факториала речь идет про ноль, то есть факториал от нуля,
[22:51.580 --> 22:57.580]  база рекурсии тут факториал от нуля равен единице, поэтому я говорю, что я специализирую факториал от нуля
[22:57.580 --> 23:15.580]  и наследую его от std integral constant от int и от единицы.
[23:15.580 --> 23:23.580]  Вот и смотрите, что происходит. Ну давайте, допустим, посмотрим, как будет происходить вычисление
[23:23.580 --> 23:31.580]  на этапе компиляции факториала от тройки. Что будет происходить? Когда я попросил факториал от тройки
[23:31.580 --> 23:39.580]  2.2.value, вот, происходит следующее. Компилятор видит, что ему нужно понять, что это такой за класс
[23:39.580 --> 23:45.580]  или что это такая структура факториала тройки. Когда он начинает инстанцировать факториал от тройки,
[23:45.580 --> 23:51.580]  то есть он смотрит на это определение, а факториал от тройки это наследник класса integer constant от n умножить
[23:51.580 --> 23:57.580]  на факториал от 3-1, то есть двойки. То есть чтобы инстанцировать класс факториал,
[23:57.580 --> 24:00.580]  ему нужно инстанцировать класс факториала двойки. Окей.
[24:00.580 --> 24:05.580]  Компилятор идет дальше и начинает инстанцировать класс факториала двойки.
[24:05.580 --> 24:10.580]  Когда компилятор инстанцирует факториал от двойки, он видит, что факториал от двойки унаследован от integer constant,
[24:10.580 --> 24:17.580]  а чтобы инстанцировать integer constant, ему нужно инстанцировать, то есть ему нужно понять, что значение написано
[24:17.580 --> 24:20.160]  И нужно инстанцировать факториал от единицы.
[24:20.940 --> 24:23.440]  Инстанцируется факториал от единицы.
[24:26.380 --> 24:28.900]  Дальше инстанцируется, потому что сам принцип有人
[24:28.900 --> 24:30.900]  инстанцирует факториал от нуля.
[24:32.640 --> 24:35.660]  Факториал от нуля. Но когда я инстанцирую факториал от нуля,
[24:35.880 --> 24:39.220]  я уже смотру не сюда, а вот сюда, потому что тут факториал от нуля у меня вы체가 полностью
[24:39.500 --> 24:43.460]  специализирован. То есть, я говорю что, для факториала от нуля мне нужно действовать как-то иначе.
[24:43.460 --> 24:47.360]  Соответственно, компилятор приходит сюда, видит, что факториал от 0 это
[24:47.360 --> 24:51.700]  наследник класса integral constant со значением единица, ну и на этом все, как бы
[24:51.700 --> 24:57.500]  рекурсия закончилась. У меня создается факториал от 0 со значением value
[24:57.500 --> 25:03.140]  равным единице. Дальше я возвращаюсь в определение факториала от единицы, да,
[25:03.140 --> 25:08.780]  факториал от единицы у меня вычисляется как факториал от 0 умножить на n, то есть тут
[25:08.780 --> 25:14.100]  получится единица. Факториал от двойки будет вычисляться, то есть будет вычисляться как
[25:14.100 --> 25:19.180]  двойка умножить на факториал от единицы, то есть двойка, ну и конец факториала тройки
[25:19.180 --> 25:25.020]  2.2.value, он будет инстанцирован как тройка, умноженная на факториал от двойки.
[25:25.020 --> 25:43.220]  Мы про него говорили пару слайдов назад, вот integral constant это класс, в котором есть
[25:43.220 --> 25:45.860]  всего лишь одно статическое поле, статическое константное поле, которое
[25:45.860 --> 25:49.260]  хранит себе вот этот вот самый параметр, который мы передали в треугольной скобке.
[25:49.260 --> 25:54.420]  То есть это его, то есть единое значение integral constant это хранить себе, хранить
[25:54.420 --> 25:59.340]  себе статическую константу, которую мы передали. Так, есть ли еще вопросы?
[25:59.340 --> 26:07.180]  Окей, давайте рассмотрим, да, естественно, просто необходимо добавить специализацию шаблона.
[26:07.180 --> 26:19.100]  Так, ну что дальше? Смотрите, вот как пользоваться, а как пользоваться этим
[26:19.100 --> 26:22.500]  вычислением на этапе интелляции, который мы задали? Ну смотрите, чтобы воспользоваться
[26:22.500 --> 26:27.540]  этим значением нам необходимо сделать следующее. Ну так мы понимаем, что значение вот этого
[26:27.540 --> 26:31.780]  самого факториала от n в структуре факториал хранится в статическом поле value, да, мне
[26:31.780 --> 26:36.380]  необходимо написать факториал от n, даже 2.2.value. Вообще говоря, кажется, что это довольно
[26:36.380 --> 26:39.940]  фигуромостко, да, то есть, ну, понятное дело, что если я хочу узнать какое-то значение, да, то я бы
[26:39.940 --> 26:45.700]  хотел это сделать быстро, да, там, ну, как-то, не знаю, написать поменьше символов и так далее.
[26:45.700 --> 26:50.340]  Вот, как можно упростить, как можно упростить данный пример? Значит, упростить данный пример можно
[26:50.340 --> 26:57.900]  с помощью шаблонов переменных. Смотрите, давайте я заведу шаблонную переменную, то есть, после того,
[26:57.900 --> 27:01.900]  как я написал все это, давайте я напишу шаблонную переменную, шаблонную переменную, которая будет
[27:01.900 --> 27:11.660]  хранить себе значение факториала. Напомню, как пишется шаблонная переменная. Ну, шаблонная переменная,
[27:11.660 --> 27:19.820]  к любой другой шаблон начинается с преамбулы template, допустим int n, вот. Ну и дальше я задаю
[27:19.820 --> 27:25.060]  значение, дальше я задаю саму, дальше я задаю саму переменную. Ну, давайте напишу переменную const
[27:25.060 --> 27:36.820]  int факториал. Напомню, что по тайлу у нас константы начинаются, ну, глобальные константы начинаются
[27:36.820 --> 27:46.220]  с префикса k факториал, и скажу, что она будет равна статическому полю факториалу от n
[27:46.220 --> 27:58.420]  2.2.value, вот. То есть, вот, я завел шаблонную переменную факториал, которая в зависимости от параметра n,
[27:58.420 --> 28:04.580]  которая в зависимости от параметра n, точнее, я завел целый набор, да, целый набор переменных, вот,
[28:04.580 --> 28:08.900]  каждый из которых параметризовано типом, точнее, числом n, ну, и в зависимости от n у меня
[28:08.900 --> 28:14.740]  всегда подставляется либо факториал 100 вл, да, факториал 99 вл и так далее. Поэтому после того, как я
[28:14.740 --> 28:21.500]  ввел значение, после того, как я ввел вот эту шаблонную переменную, я могу и пользоваться вот
[28:21.500 --> 28:34.980]  таким образом. k факториал от n, вот. То есть, так эта шаблонная переменная, да, то она уже внутри себя
[28:34.980 --> 28:40.220]  хранит значение, вот, которое вычислено по тому правилу, и, соответственно, код стал значительно
[28:40.220 --> 28:52.460]  проще и значительно читаемее. Окей? Нормально? Хорошо. Давайте посмотрим еще, например, вычисления
[28:52.460 --> 28:56.300]  на этапе компиляции, ну, и еще один классический пример, да, сразу после факториала. Это пример,
[28:56.300 --> 28:59.780]  ну, то есть, естественно, после факториала, как правило, идет вычисление чисел Фибоначчи.
[28:59.780 --> 29:06.620]  Давайте попробуем организовать вычисление чисел Фибоначчи на этапе, на этапе компиляции. Вот,
[29:06.700 --> 29:15.500]  давайте тоже напишем, вот, потом прокомментируем. Ну, соответственно, вычисление чисел Фибоначчи
[29:15.500 --> 29:31.380]  устроено так же, да, мы должны завести шаблонную структуру Фибоначчи, которая должна быть
[29:31.380 --> 29:36.460]  наследована от класса, в котором будет, в котором, ну, в поле которого, да, будет храниться, ну,
[29:36.460 --> 29:42.580]  значение Фибоначчи от n. Ну, естественно, таким, естественно, таким классом у нас будет std
[29:42.580 --> 29:56.420]  integer constant, integral, integral constant от int, и, ну, и туда мы должны передать значение, которое будет
[29:56.420 --> 29:59.220]  храниться. Ну, как вычислять число Фибоначчи? Число Фибоначчи уничтожен следующим образом.
[29:59.260 --> 30:11.700]  Мы должны взять значение числа Фибоначчи от n-1, 2.2.value, вот, и прибавить к нему значение числа
[30:11.700 --> 30:24.900]  Фибоначчи от n-2, ну, и взять оттуда статическую переменную value. Вот, совершаем определение класса.
[30:24.900 --> 30:31.340]  Вот, ну, естественно, как и раньше, как и раньше, нам нужно прописать признак конца рекурсии,
[30:31.340 --> 30:33.620]  да, потому что если мы будем усилять Фибоначчи от n, у нас рекурсина будет
[30:33.620 --> 30:40.060]  усиляться в Фибоначчи от n-1, n-2, ну, и так далее. Давайте пропишем, давайте пропишем конец рекурсии.
[30:40.060 --> 30:46.820]  Ну, также делаем с помощью шаблонной специализации.
[30:46.820 --> 31:10.100]  Фибоначчи от единицы, да, и Фибоначчи от единицы это integral constant от единицы.
[31:10.100 --> 31:19.140]  Ну, аналогично прописываем Фибоначчи от нуля. Давайте не буду прописывать. Вот.
[31:19.140 --> 31:26.860]  Ну, и опять же абсолютно аналогично вот тут, как во второй строчке, да, я могу прописать шаблонную
[31:26.860 --> 31:30.900]  переменную k-Fibonacci, и вот сюда вместо k-factorial подставлять k-Fibonacci, у меня Фибоначчи будет
[31:30.900 --> 31:35.660]  вычисляться вот согласно тому правилу. То есть, когда я буду инстанцировать Фибоначчи, допустим,
[31:35.660 --> 31:41.020]  от 10. Вот. Компилятор, чтобы инстанцировать Фибоначчи от 10, ему нужно будет проинстанцировать
[31:41.020 --> 31:45.140]  класс SD integral constant, а чтобы проинстанцировать класс SD integral constant, ему нужно будет узнать,
[31:45.140 --> 31:48.980]  что за значение я передал сюда. Чтобы узнать, что значение я передал сюда, ему нужно будет
[31:48.980 --> 31:53.740]  проинстанцировать Фибоначчи от n-1, Фибоначчи от n-2, ну, и так далее. В итоге все, в итоге все,
[31:53.740 --> 32:00.100]  в итоге вычисление пройдет успешно. Вот. И в поле, и в статическом поле value будет храниться нужное
[32:00.100 --> 32:08.220]  значение. Вопрос. Как вы думаете, есть ли какие-то проблемы вот в этой реализации? Да. Вот, смотрите,
[32:08.220 --> 32:13.140]  да. Ну, я надеюсь, вы помните, что когда мы вычисляем Фибоначчи, когда мы вычисляем число Фибоначчи
[32:13.140 --> 32:18.900]  рекурсивно, у нас возникает следующая проблема. Давайте посмотрим на то, как вычисляется Фибоначчи
[32:18.900 --> 32:24.740]  от, не знаю, 5. Да, когда вычисляется Фибоначчи от 5, он вызывает Фибоначчи от 4 и Фибоначчи
[32:24.820 --> 32:32.540]  от 3. Фибоначчи от 4 вызывает Фибоначчи от 3, Фибоначчи от 2, тут вызывает Фибоначчи от 2,
[32:32.540 --> 32:39.740]  Фибоначчи от единицы. Вот. Ну, так или иначе, мы видим, что вот это вот дерево, да, вычисляется
[32:39.740 --> 32:45.760]  целиком здесь же. Вот. Вот это дерево вычисляется целиком здесь же. То есть, грубо говоря, у меня
[32:45.760 --> 32:50.420]  одни и те же вычисления повторяются кучу-кучу раз. Да. Ну, я надеюсь, вы помните, что вычисление
[32:50.420 --> 32:57.340]  фибоначи с помощью рекурсивного алгоритма, оно растет экспоненциально, то есть это
[32:57.340 --> 33:06.220]  ω большое от, по-моему, полтора в степени n. То есть на самом деле вычислять фибоначи с
[33:06.220 --> 33:11.380]  помощью рекурса неэффективно. И вроде как замечание ценное, действительно
[33:11.380 --> 33:16.140]  валидное, но на самом деле я утверждаю, что когда мы говорим про шаблоны,
[33:16.140 --> 33:20.020]  вот такой штуки не происходит. Понимаете ли вы почему? Понимаете ли вы
[33:20.020 --> 33:23.980]  почему вот такое вычтение фибоначи будет занимать линейное время, а не
[33:23.980 --> 33:30.900]  экспоненциальное? Да, смотрите, в чем прикол. Смотрите, как мы боимся с этой
[33:30.900 --> 33:34.060]  проблемой в случае рекурсии. В случае рекурсии мы используем технику
[33:34.060 --> 33:38.260]  минимализации. Мы вычислили код значения фибоначи, мы просто
[33:38.260 --> 33:42.020]  его запоминаем, и потом в следующий раз, ну, допустим, вот тут мы вычислили фибоначи от 3,
[33:42.020 --> 33:45.060]  и потом в следующий раз, когда нам понадобится вычислить фибоначи от 3, мы уже не вычисляем его
[33:45.060 --> 33:50.380]  заново. Мы используем уже готовые значения из какого-то массива. А теперь, смотрите,
[33:50.380 --> 33:54.660]  я утверждаю, что когда мы используем шаблоны, вот эта вот самая
[33:54.660 --> 33:57.620]  мимоизация с запоминанием предыдущих вычтенных значений, она происходит
[33:57.620 --> 34:03.780]  автоматически с помощью компилятора. Почему? Да потому что, если мы вспомним,
[34:03.780 --> 34:09.900]  как компилятор инстанцирует шаблоны, то увидим следующую вещь.
[34:09.900 --> 34:20.940]  Ну, смотрите, вот, допустим, я использую какую-то шаблонную функцию f от единицы.
[34:20.940 --> 34:25.940]  Это шаблонная функция, которая принимает на вход int. Соответственно, когда компилятор видит, что я вызываю
[34:25.940 --> 34:31.320]  функцию f от int, он инстанцирует функцию f от int. А что происходит, когда он встречает
[34:31.320 --> 34:40.200]  снова функцию f, которая вызывает от int? Инстанцирует ли он ее заново? Нет,
[34:40.200 --> 34:44.600]  инстанцирование шаблона для каждого набора параметров происходит ровно один раз.
[34:44.600 --> 34:48.880]  То есть, когда компилятор первый раз встретил функцию f, которая вызывает от int,
[34:48.880 --> 34:53.320]  он подставляет шаблонный параметр int и генерирует из этого шаблона готовую
[34:53.320 --> 34:57.960]  функцию и записывает ее в исполняемый файл. Дальше, когда в следующий раз он видит
[34:57.960 --> 35:04.160]  функцию f, которая вызывается от int, он же не будет повторно инстанцировать одну и ту же функцию.
[35:04.160 --> 35:09.360]  Зачем инстанцировать одну и ту же функцию несколько раз? И здесь то же самое.
[35:09.360 --> 35:19.440]  Когда компилятор видит инстанцирование класса Fibonacci от пяти впервые,
[35:19.440 --> 35:23.760]  естественно, этот класс инстанцирует, он сохраняет ее у себя в памяти.
[35:23.960 --> 35:28.440]  А когда он видит следующий раз Fibonacci от пяти, ну, компилятор естественно понимает,
[35:28.440 --> 35:31.880]  что вот этот класс я уже раньше инстанцировал, этот класс уже есть,
[35:31.880 --> 35:35.360]  поэтому заново инстанцировать я его не буду, я просто возьму оттуда готовое значение.
[35:35.360 --> 35:42.280]  Поэтому на самом деле вот этот алгоритм, точнее вот это вот вычтение, занимает OATN.
[35:42.280 --> 35:45.240]  Причем OATN не во время исполнения программы, а во время компиляции.
[35:45.240 --> 35:58.000]  Вот. И это, кстати, важный момент. Важно отметить, что вычисление вот этого значения,
[35:58.000 --> 36:02.200]  факториала от N или Fibonacci от N, будет тратить время только на этапе компиляции.
[36:02.200 --> 36:05.320]  То есть у вас будет долгая, то есть у вас компиляция, возможно, будет долгая,
[36:05.320 --> 36:08.000]  но вот во время исполнения программы, когда программа будет работать,
[36:08.000 --> 36:12.400]  тут уже будет готовое значение. То есть компилятор посчитает это значение на этапе компиляции
[36:12.400 --> 36:16.240]  и подставит уже сюда конкретный результат. Ну, допустим, 6. Понятно?
[36:16.240 --> 36:20.960]  То есть после того, как компилятор вычислит все значения, все value,
[36:20.960 --> 36:24.640]  все шаблоны переменной, этап компиляции, он уже во время исполнения
[36:24.640 --> 36:29.360]  будет просто использовать их значения. И вычислять на этапе исполнения программы он не будет.
[36:29.360 --> 36:33.720]  Это понятно? Вот. Да.
[36:33.720 --> 36:45.560]  Ну, скорее всего, скорее всего, нет. Ну, то есть если компилятор увидит, что, как бы,
[36:45.560 --> 36:51.240]  после установки всех значений код, значит, код, ну, смотрите, во-первых, тут есть два момента.
[36:51.240 --> 36:54.600]  Первый момент, вот эти все структуры, они не содержат никакого исполняемого кода,
[36:54.600 --> 36:58.440]  то есть они не содержат ни методов, скажем, ни функций, ни конструкторов и так далее.
[36:58.440 --> 37:02.160]  Вот. Поэтому, соответственно, хранить ему, по сути, нечего. Вот. Поэтому после
[37:02.160 --> 37:04.520]  установки всех шаблонных параметров, после всех значений, то есть, как бы,
[37:04.520 --> 37:08.000]  компилятор просто-напросто возьмет и в ассемблерный код тупо вставит значение 6,
[37:08.000 --> 37:13.480]  или тупо вставит значение 24. Вот. И после выполнения всего этого компилятора увидит,
[37:13.480 --> 37:18.040]  что в самом ассемблерном коде у него нет никаких вычислений связанных с этим структуром,
[37:18.040 --> 37:23.080]  поэтому он, скорее всего, их просто-напросто уберет. Вот. Поэтому на, по этому размеру бинарного файла,
[37:23.080 --> 37:26.040]  ну, опять же, там, скорее всего, в режиме оптимизации, скорее всего, там ничего
[37:26.040 --> 37:29.840]  сохранено не будет. В режиме дебага, возможно, он это сохранит. Так. Несколько замечаний,
[37:29.840 --> 37:34.000]  несколько замечаний по следам того, что мне задали, какие вопросы мне задали в перерыве,
[37:34.000 --> 37:39.400]  еще раз повторюсь, что вот это вот значение n, которое используется для вычислений факториала,
[37:39.400 --> 37:44.640]  фибоначи, и так далее, е, оно обязано быть известно, оно обязано быть известно на этап
[37:44.640 --> 37:51.440]  компиляции. Вот. То есть, ну, два момента. Первый момент такой. Вот эта штука, вот сам факториал,
[37:51.440 --> 37:54.800]  там, не знаю, факториал от тысячи, да, факториал от миллиона, он будет вычисляться на этап
[37:54.800 --> 37:58.680]  компиляции. То есть, в рантайме, то есть, пока, то есть, во время работы программы вы потратите
[37:58.680 --> 38:03.040]  все, вообще говоря, ничего. Вот. Тут может возникнуть следующая идея. Ага, давайте хакнем,
[38:03.040 --> 38:08.720]  давайте хакнем контест. Вот. И сделаем следующее. Давайте просто просто напишем, напишем факториал
[38:08.720 --> 38:12.400]  или напишем фибонач, который вычисляется на этапе компиляции. Вот. А когда, ну, собственно,
[38:12.400 --> 38:15.560]  программа будет запускаться, я туда подставлю там нужное значение, и, соответственно, получу
[38:15.560 --> 38:20.200]  значение за вот единицы. А вот шиш, так не выйдет. Почему? Потому что, еще раз повторю, что вот
[38:20.200 --> 38:25.480]  это вот значение n, оно должно быть известно на этапе компиляции. Естественно, параметры вашей
[38:25.480 --> 38:30.440]  программы передаются на этапе исполнения. Вот. Поэтому воспользоваться этим на этапе исполнения
[38:30.440 --> 38:35.320]  у вас не получится. То есть, как бы, вот это чисто концепция и этап компиляции. То есть, ну, единственное,
[38:35.320 --> 38:39.760]  что вы можете сделать, это на этапе компиляции заранее там почитать там факториалы там, ну,
[38:39.760 --> 38:43.560]  допустим, от нуля до сталь, там от нуля до тысячи, да, и потом, то есть, сохранить это все в массиве,
[38:43.560 --> 38:47.400]  и потом, во время исполнения программы, там, когда вы подаёте на вход какое-то там значение, да, вы
[38:47.400 --> 38:52.000]  можете обратиться к этому массиву, да, из этого массива вычислить какое-то, вычислить какое-то значение.
[38:52.740 --> 38:57.580]  Вот. Это первое замечание. Второе замечание заключается в следующем. Смотрите, несмотря на то,
[38:57.580 --> 39:00.800]  что вот вычисление факториал, вычление произвольного факториала или вычисления
[39:00.800 --> 39:04.920]  произвольного числа fibonacci на этапе исполнения программы теперь не стоит ничего. То есть, если
[39:04.920 --> 39:09.080]  вам нужно прям вот fibonacci steal on 1000, да, то во время исполнения программы, программа не сделает
[39:09.080 --> 39:11.440]  вообще ничего, она просто возьмет уже готовое значение, которое было посчитано и темпы компиляции.
[39:11.440 --> 39:17.940]  Вам можно считать, что fibonacci steal on n или factorial on n на этапе исполнения будет вычисляться за
[39:17.940 --> 39:21.960]  единицу. Но в чем подвох? Подвох в том, что вот это время на вычислении
[39:21.960 --> 39:26.720]  нужного факториала или нужного фибоначи, вы потратите на этапе компиляции, и поэтому не
[39:26.720 --> 39:31.240]  удивляйтесь, когда в третьем контесте вы увидите, что ограничение
[39:31.240 --> 39:35.080]  по времени на вычлении каких-то там функций будет занимать очень
[39:35.080 --> 39:39.600]  маленьким, но я сразу предупреждаю, что у нас будут ограничения по времени на
[39:39.600 --> 39:44.740]  время компиляции. То есть если ваша программа компилируется достаточно
[39:44.740 --> 39:49.960]  долго, то скорее всего вы реализовали какой-то неэффективный алгоритм, и соответственно
[39:49.960 --> 39:54.840]  таким образом тайм-ремит у вас будет на время компиляции, а не на время
[39:54.840 --> 39:59.960]  исполнения программы. Вот. Есть ли еще вопросы?
[39:59.960 --> 40:10.840]  Окей. Так, ну здесь мы продолжаем, значит продолжаем, продолжаем примеры, начнут
[40:10.840 --> 40:14.200]  вот пример быстрого возведения в степень. Напоминаю, что чтобы быстро
[40:14.200 --> 40:19.360]  возвести число в степень, допустим, х в степени n, чтобы это не делать за
[40:19.360 --> 40:25.960]  линейное время, мы поступаем как? Если n делится на два, то мы берем, то мы
[40:25.960 --> 40:34.960]  вычисляем x в степени n пополам и возводим в квадрат. Вот. Если n
[40:34.960 --> 40:42.280]  в остатке, если n является сочетным числом, то мы берем x и умножаем на x,
[40:42.280 --> 40:47.480]  ну тоже получается степень n пополам в квадрате. Вот. То есть таким образом
[40:47.480 --> 40:50.480]  вычисление степени происходит за логичмическое время, и ровно это же самое
[40:50.480 --> 40:55.200]  алгоритм можно реализовать с помощью вычислений на этапе компиляции.
[40:55.200 --> 40:59.800]  То есть что мы делаем? Мы пишем так называемую метафункцию возведения в
[40:59.800 --> 41:04.920]  степень по, вот, перенимаем на вход x, перенимаем на вход значение n, то есть если n
[41:04.920 --> 41:11.960]  если n делится на два, то мы вычисляем по x на x на n делить пополам, и иначе
[41:11.960 --> 41:17.400]  вычисляем x умножить на степень x умножить на x, n-1 делить на 2. В общем, все то
[41:17.400 --> 41:23.280]  же самое, что и раньше, просто тут возникает ветвление. Вот. Тут есть
[41:23.280 --> 41:27.800]  небольшая проблема, но про которую поговорим чуть позже. Вот.
[41:27.800 --> 41:32.920]  Окей. Значит, смотрите, вот все то, о чем я говорил до этого, вот вычисление
[41:32.920 --> 41:36.320]  Fibonacci в таком стиле, вычисление факториала в таком стиле, вычисление там
[41:37.280 --> 41:46.640]  степени, это все, скажем так, старый стиль C++. Вот. В общем, это то, как разработчикам
[41:46.640 --> 41:50.000]  необходимо, было необходимо выкручиваться в ситуации, когда C++
[41:50.000 --> 41:53.920]  не предоставлял никаких инструментов для того, чтобы делать корректные
[41:53.920 --> 41:57.720]  вычисления на этапе компиляции. Вот. На самом деле современный C++ в этом
[41:57.720 --> 42:01.480]  смысле стал более лоялен и оброс достаточно большим количеством инструментов
[42:01.480 --> 42:05.440]  для того, чтобы можно было организовать хорошие и правдоподобные, ну не
[42:05.520 --> 42:09.160]  правдоподобные, да, хорошие и приятные вычисления на этапе компиляции. Давайте
[42:09.160 --> 42:12.600]  про них поговорим. Значит, первое, про что мы поговорим, так это constexport
[42:12.600 --> 42:19.080]  функция. Что такое constexport функция? Значит, constexport функция — это функция,
[42:19.080 --> 42:23.080]  у которой в начале, да, перед описанием типа, ну или там перед возвращаемым
[42:23.080 --> 42:27.200]  значением написано ключевое слово constexport. Что это означает? constexport
[42:27.200 --> 42:31.640]  функция — это такая функция, которая может быть, может быть вычислена на этапе
[42:31.640 --> 42:36.120]  компиляции. Смотрите, вот до этого, когда мы с вами писали функции там на языке
[42:36.120 --> 42:39.960]  C++, вот эти функции, они все обязаны были вычисляться на этапе
[42:39.960 --> 42:42.840]  исполнения программы. То есть на этапе компиляции компилятор вообще, говорят,
[42:42.840 --> 42:46.760]  строго-настрого отказывался что-либо, что-либо вычислять, вычислять какие-либо
[42:46.760 --> 42:51.400]  функции. Так вот, в C++11 появились constexport функции, которые могут быть вычислены
[42:51.400 --> 42:54.400]  на этапе компиляции. То есть я как бы говорю компилятору о том, что вот эта
[42:54.400 --> 42:57.880]  функция, да, она может быть вычислена на этапе компиляции, потому что она использует
[42:57.880 --> 43:01.560]  только те операции, которые допустимы на этапе компиляции. Вот. В частности,
[43:01.560 --> 43:05.560]  если мне вдруг хочется реализовивать функцию факториала, ну
[43:05.560 --> 43:08.280]  которую я в теории там захочу вычислить на этапе компиляции, я могу просто-напросто
[43:08.280 --> 43:11.400]  перед функцией факториала написать constexport, вот.
[43:11.400 --> 43:14.040]  Ну и, соответственно,의 cooler, ну и, соответственно, к чему это приведет. Это приведет к
[43:14.040 --> 43:18.560]  тому, что если я функцию факториала буду передавать constexport значения, то
[43:18.560 --> 43:21.960]  есть, простите, если я функцию, если я факториала буду передавать значения, которые
[43:21.960 --> 43:25.120]  известны на этапе компиляции, например, факториал 5, как в данном примере,, то он
[43:25.120 --> 43:27.840]  все будет работать корректно. Почему? Потому что компиляторamer, ага, факториал
[43:27.840 --> 43:30.760]  и это принимает conscient, известную на этапе компиляции, в данном случае 5,
[43:30.760 --> 43:33.600]  factorial объявлен как consistent экспорт, то есть у функции может быть
[43:33.600 --> 43:35.360]  в metros Алексеев Main meanwhile архитектура
[43:35.360 --> 43:37.400]  ну и компилятор запустит эту функцию, ну то есть он как бы Representative
[43:37.400 --> 43:39.960]  компилирует эту функцию, потом на этапе компиляции её запустит
[43:39.960 --> 43:41.680]  и соответственно вычлит вот attention factorial
[43:41.680 --> 43:43.400]  вычлитDavid paintings factorial от 5
[43:43.400 --> 43:47.360]  то есть опять же, после того как вычлите эту функцию на этапе компиляции
[43:47.360 --> 43:48.680]  вы поставите туда уже готовое значение
[43:48.680 --> 43:50.700]  и на этапе исполнения программы вы потратите ровно ничего
[43:50.700 --> 43:53.240]  но при этом, опять же стоит понимать, что на этапе компиляции вы потратите какое-то...
[43:53.240 --> 43:56.760]  вы потратите какое-то время
[43:56.760 --> 43:57.800]  ОК?
[43:57.800 --> 44:06.800]  То есть вот все то же самое можно сделать просто с помощью constexpr функции и при этом писать обычные функции, как мы с вами привыкли.
[44:06.800 --> 44:11.800]  Давайте поговорим про некоторые свойства constexpr функций.
[44:11.800 --> 44:17.800]  Что они представляют, что можно писать в constexpr функции, что нельзя писать в constexpr функциях и так далее.
[44:17.800 --> 44:21.800]  Во-первых, любая constexpr функция автоматически является inline.
[44:21.800 --> 44:31.800]  Почему? Потому что если функция может быть вычислена на таблике компиляции, то, естественно, эта функция обязана появляться в той же самой единице трансляции или в том же самом файле, что мы сейчас компилируем.
[44:31.800 --> 44:40.800]  Кроме того, из первого пункта следует, что constexpr функции я могу спокойно помещать в заголовочные файлы, да, это не будет приводить к нарушению правил одного определения.
[44:40.800 --> 44:45.800]  Помните, что слово inline используется для того, чтобы можно было нарушить правила одного определения.
[44:45.800 --> 44:56.800]  Дальше, до C++20, а constexpr функции не могли быть виртуальными, сейчас виртуальными они и быть могут, то есть сейчас вы можете объявить виртуальную функцию constexpr.
[44:56.800 --> 45:09.800]  До C++20, то есть если вы используете стандарт, раньше C++20, то в constexpr функциях нельзя использовать try catch, потому что считалось, что если функция должна быть вычислена на таблике компиляции, то, естественно, и исключения она генерировать не должна.
[45:10.800 --> 45:14.800]  До C++20 она не могла использовать ассемблерные вставки, теперь она может использовать ассемблерные вставки.
[45:14.800 --> 45:17.800]  До C++20 она не могла использовать операции динамической памятью.
[45:17.800 --> 45:19.800]  Вот это вообще, наверное, самое хрешесносное.
[45:19.800 --> 45:25.800]  В общем, смотрите, когда мы выделяем динамическую память, выделение динамической памяти – это концепция времени исполнения.
[45:25.800 --> 45:35.800]  То есть мы с вами говорили о том, что если во время исполнения программы памяти не хватает, то я выделяю эту самую динамическую память во время исполнения и во время исполнения ее очищаю.
[45:35.800 --> 45:41.800]  И поэтому кажется, что понятие constexpr, то есть вычисление на этапе компиляции и динамическое выделение памяти не совместимы друг с другом.
[45:41.800 --> 45:44.800]  На самом деле это по-прежнему так.
[45:44.800 --> 45:53.800]  Просто C++20 разрешили использовать операции new внутри constexpr функций, но с дополнительными ограничениями.
[45:53.800 --> 46:02.800]  Первое ограничение – это то, что я выделяю new int 10.
[46:02.800 --> 46:07.800]  Вот это значение тоже должно быть в известном этапе компиляции.
[46:07.800 --> 46:12.800]  А во-вторых, я обязан для этого выделения памяти вызвать delete.
[46:12.800 --> 46:15.800]  Если я для этого выделения памяти не вызову delete, при этом компилятор это проверит.
[46:15.800 --> 46:18.800]  То есть компилятор проверит, что я для этого new вызову delete.
[46:18.800 --> 46:27.800]  Если этого не произойдет, то компилятор поругается, скажет, что я не могу вызывать constexpr функцию в случае, если для этого new не вызвано delete.
[46:27.800 --> 46:34.800]  Кстати, таким образом теперь можно проверять верное решение, не допускаете ли вы усечь памяти на этапе компиляции.
[46:34.800 --> 46:39.800]  Опять же, это такой вредный совет, но все-таки так можно сделать.
[46:39.800 --> 46:43.800]  Если вы можете пометить функцию, которая выделяет динамическую память, как constexpr,
[46:43.800 --> 46:48.800]  если вы ее не сможете вызвать на этапе компиляции, то компилятор поругается,
[46:48.800 --> 46:56.800]  то вы увидите, что он поругается того, что вы для какого-то new не вызвали delete.
[46:56.800 --> 47:06.800]  Дальше, DOSY плюс 23, constexpr функции не могли содержать Go2, DOSY плюс 23, они могли определять только нестатические литеральные переменные,
[47:06.800 --> 47:10.800]  про то, что такое литеральные переменные, поговорим на следующем слайде.
[47:10.800 --> 47:19.800]  Ну и самое главное, я уже сказал, что если вы в constexpr функции начинаете плюс 20 выделять динамическую память, при этом ее не освобождаете,
[47:19.800 --> 47:24.800]  то компилятор откажется эту constexpr функцию запускать, ну запускать на этапе компиляции.
[47:24.800 --> 47:31.800]  И дополнительно, если компилятор во время исполнения кода, во время компиляции увидит, что ваш код использует undefinedBehaviour,
[47:31.800 --> 47:37.800]  то он кинет вам ошибку компиляции. То есть, на самом деле, теперь как бы в дополнение к этому можно проверять ваш код,
[47:37.800 --> 47:44.800]  вашу функцию на то, содержат они undefinedBehaviour или нет. Ну как это делается, вы пишете функцию, помечаете constexpr,
[47:44.800 --> 47:51.800]  и дальше подаете на вход константы времени компиляции, точнее, пытаетесь запустить эту функцию на этапе компиляции.
[47:51.800 --> 47:56.800]  Если компилятор откажется запустить эту функцию на этапе компиляции, значит не содержится undefinedBehaviour.
[47:56.800 --> 48:02.800]  При этом он сдаст соответствующие сообщения об ошибке. Ну либо он скажет, что вы для new не вызвали delete и так далее.
[48:02.800 --> 48:10.800]  Понятно? Теперь давайте поговорим про то, что такое... давайте сюда немного перейдем.
[48:10.800 --> 48:17.800]  Давайте поговорим про то, что такое литеральный тип. То есть, почему в C++, по-моему, до C++23 в constexpr функциях можно было использовать только литеральные типы.
[48:17.800 --> 48:25.800]  Литеральный тип — это, по сути, тип, который состоит только из примитивных типов, там int, bool, double и так далее,
[48:25.800 --> 48:29.800]  либо состоит из структур, которые, в свою очередь, тоже состоят из литеральных типов.
[48:29.800 --> 48:36.800]  То есть, литеральный тип — это либо примитивные типы, либо какая-то структура или union, которая состоит из литеральных типов.
[48:36.800 --> 48:43.800]  То есть, если у вас есть структура, давайте вот пример. То есть, если у вас есть структура A,
[48:43.800 --> 48:53.800]  которая содержит внутри себя int, double и есть структура S,
[48:53.800 --> 49:03.800]  которая внутри себя содержит поле A и поле bool, f, то структура A и структура S являются литеральными типами.
[49:03.800 --> 49:07.800]  Потому что структура A является структурой от литеральных типов, а структура S тоже является структурой от литеральных типов,
[49:07.800 --> 49:13.800]  а A является литеральным типом, потому что состоит из литеральных типов.
[49:13.800 --> 49:21.800]  Да, да, но при этом, литеральный тип не может иметь конструкторов, кроме конструкторов копирования на перемещение,
[49:21.800 --> 49:29.800]  деструкторов и так далее.
[49:29.800 --> 49:32.800]  А пока еще примеры constexpr функции.
[49:32.800 --> 49:38.800]  Соответственно, вычление Fibonacci теперь можно организовать тоже на этапе компиляции, просто добавив слово constexpr к функции Fibonacci.
[49:38.800 --> 49:46.800]  Вычление степени тоже можно производить с помощью constexpr функции, при этом в constexpr функциях допустима рекурсия.
[49:46.800 --> 49:51.800]  То есть я могу организовать рекурсивное вычление, возведение в степень.
[49:51.800 --> 49:59.800]  И, соответственно, начинаясь смотреть, в чем проблема. При вычлении Fibonacci, что мне тут приходится делать?
[49:59.800 --> 50:08.800]  При вычлении числа Fibonacci мне приходится как-то изворачиваться, хранить предыдущие значения, предпредыдущие значения и так далее.
[50:08.800 --> 50:15.800]  Теперь при вычлении числа Fibonacci, начиная с плюс 20, я могу, как я уже сказал, я могу делать выделение с помощью new.
[50:15.800 --> 50:18.800]  То есть я могу условно реализовать функцию Fibonacci так.
[50:18.800 --> 50:24.800]  То есть завести какой-то динамический массив из n плюс одного элемента и заполнять его последовательно значениями i и i плюс 1.
[50:24.800 --> 50:30.800]  Fibonacci от 0 это 0, Fibonacci от 1 это 1, Fibonacci от i это Fibonacci от i минус 1, плюс Fibonacci от i минус 2.
[50:30.800 --> 50:34.800]  После этого я делаю delete, и программа работает корректно.
[50:34.800 --> 50:38.800]  Выделение динамической памяти на этапе компиляции допустима.
[50:38.800 --> 50:53.800]  В принципе, принципиальная разница будет, во-первых, то, что эта функция помещена как constexpr, не означает, что эту функцию мы обязаны запускать только на этапе компиляции.
[50:53.800 --> 50:56.800]  constexpr функция, она может быть вычислена на этапе компиляции.
[50:56.800 --> 51:00.800]  Но в то же время эту функцию можно вычислить на этапе исполнения программы.
[51:00.800 --> 51:04.800]  Ну а раз мы эту функцию можем вычислять на этапе исполнения программы, то естественно мы заранее значение n можем не знать.
[51:04.800 --> 51:08.800]  Ну а раз мы заранее значение n не знаем, то мы используем только динамический массив.
[51:08.800 --> 51:19.800]  Да, кстати, начиная с Fibonacci плюс 20, в качестве вот этого самого типа можно использовать и vector.
[51:19.800 --> 51:30.800]  То есть если в классе объявлены constexpr конструкторы, constexpr деструкторы и так далее, то сами типы тоже могут быть созданы внутри constexpr функции.
[51:30.800 --> 51:33.800]  То есть vector на самом деле тоже можно использовать, начиная с Fibonacci плюс 20.
[51:33.800 --> 51:37.800]  Окей?
[51:37.800 --> 51:39.800]  Хорошо.
[51:39.800 --> 51:50.800]  Так, следующий момент. Смотрите, я уже этот пункт проговорил, давайте еще раз рассмотрим следующую проблему.
[51:50.800 --> 52:03.800]  Посмотрите, из того, что я функцию пометил как constexpr, следует ли что, что компилятор может вызвать эту функцию на этапе компиляции.
[52:03.800 --> 52:14.800]  Если у компилятора есть выбор вызвать функцию на этапе компиляции или не вызвать на этапе компиляции, то корее всего компилятор сделает выбор в пользу того, чтобы не вызвать ее на этапе компиляции.
[52:14.800 --> 52:22.800]  То есть компилятор довольно такие ленивая штука. Если у него есть возможность не делать что-то на этапе компиляции, то он этого делать не будет.
[52:22.800 --> 52:27.200]  в частности. В частности, вот посмотрим, например, вот у меня есть систему массив,
[52:27.200 --> 52:32.600]  в который я передаю результат вызова функции по от 3,5.
[52:38.600 --> 52:41.600]  Погасил.
[52:41.600 --> 52:54.400]  Да, смотрите, вот у меня есть систему массив, которая передаёт результат вызова функции по от 3,5.
[52:54.400 --> 52:59.000]  Смотрите, вот тут у компилятора нет выбора, то есть тут компилятор обязан вызвать эту
[52:59.000 --> 53:03.800]  функцию на этапе компиляции, чтобы просто нам понять, какого размера будет массив. Но если
[53:03.800 --> 53:09.840]  я вызову, допустим, cout по у 5,3, то смотрите, несмотря на то, что вроде как все константы
[53:09.840 --> 53:14.440]  известны на этапе компиляции, то есть и 5,3 не известны на этапе компиляции, компилятор
[53:14.440 --> 53:20.840]  скорее всего будет вызвать эту функцию на этапе исполнения программы, а не на этапе
[53:20.840 --> 53:25.440]  компиляции. Ну кроме того, понятное дело, как я уже сказал, констант-эксперт функции, они могут
[53:25.440 --> 53:28.200]  быть вызваны на этапе компиляции, но они также могут быть использованы и во время рантайма,
[53:28.200 --> 53:31.520]  то есть, например, если я в поу передаю просто случайное число, то это случайное число будет
[53:31.520 --> 53:34.960]  вычислено на этапе исполнения программы и будет передано функцию, и функция будет вычислена на
[53:34.960 --> 53:40.720]  этапе исполнения. Возникает следующий вопрос. Как написать функцию, то есть можно ли написать
[53:40.720 --> 53:45.920]  какую-нибудь функцию, которая гарантированно будет вычислена на этапе компиляции? То есть можно
[53:45.920 --> 53:49.560]  написать такую функцию, которая имеет смысл, которую имеет смысл вызывать только на этапе
[53:49.560 --> 53:53.160]  компиляции? То есть я хочу, чтобы, во-первых, функцию компилятор всегда вызывал на этапе
[53:53.160 --> 53:57.200]  компиляции, если у меня есть такая возможность, а во-вторых, чтобы просто не было возможности
[53:57.200 --> 54:05.360]  вызывать конкретную функцию на этапе исполнения программы. И такая возможность есть. Точнее,
[54:05.360 --> 54:10.600]  она появилась, начиная с E++20, и появилось снова ключевое слово, которое называется consteval.
[54:10.600 --> 54:16.640]  Что такое consteval? consteval это функция, которая вычисляется только на этапе компиляции.
[54:16.640 --> 54:23.520]  Соответственно, если я передаю в систему массив pow3.5, то pow3.5 будет вычислено на этапе компиляции.
[54:23.520 --> 54:28.720]  Если я пишу cout pow.5.3, то эта функция pow.5.3 тоже будет вычислена на этапе компиляции.
[54:28.720 --> 54:33.040]  Туда, на то место, где прописана cout, вот на то место подставится конкретное значение.
[54:33.040 --> 54:41.080]  5 в степени 3. Но если я пытаюсь вызвать функцию pow.5.3 на этапе исполнения программы, то есть если
[54:41.080 --> 54:45.000]  я в функцию pow.5.3 передам аргументы, которые не являются константными временем компиляции,
[54:45.000 --> 54:48.720]  то, соответственно, возникнет ошибка в компиляции, потому что компилятор скажет, что в consteval
[54:48.720 --> 54:53.720]  функцию можно передавать только const expression, то есть может передавать только выражение,
[54:53.720 --> 54:58.400]  которое вычили мы на этапе компиляции. Понятно отличие consteval от constexpr?
[54:58.400 --> 55:03.400]  constexpr может быть вычислено как на этапе компиляции, так и на этапе исполнения программы. При этом,
[55:03.400 --> 55:08.120]  если есть выбор у компилятора, то он, скорее всего, выберет вычление ее на этапе исполнения,
[55:08.120 --> 55:14.440]  а consteval вычисляется всегда только на этапе компиляции.
[55:14.440 --> 55:21.720]  К чему еще может быть применено ключевое слово constexpr?
[55:21.720 --> 55:27.760]  Ключевое слово constexpr может быть применено к переменным. Что это будет означать?
[55:27.760 --> 55:32.440]  constexpr переменная — это, во-первых, константная переменная, то есть constexpr в этом смысле
[55:32.440 --> 55:37.920]  работает аналогично ключевому слову const, но помимо того, что constexpr переменная является
[55:37.920 --> 55:43.480]  константной, constexpr переменная обязана быть проинциализирована константой времени компиляции.
[55:43.480 --> 55:45.960]  Пример.
[55:52.560 --> 55:58.600]  Смотрите, я вполне себе могу написать что-то наподобие такого. int x
[55:58.600 --> 56:18.680]  int x и потом создать const int x умножить на x. Смотрите, эта константная переменная — это
[56:18.680 --> 56:21.720]  переменная константа, но при этом она проинциализирована значением,
[56:21.720 --> 56:26.200]  которой неизвестны этапы компиляции. Согласны? Так вот, если бы я тут написал вместо const
[56:26.200 --> 56:35.480]  expr, то это не скомпилировалось бы. Почему? Потому что constexpr,
[56:35.480 --> 56:39.480]  но помимо того, что делает саму переменную константной, constexpr еще гарантирует,
[56:39.480 --> 56:45.600]  что значение этой переменной будет известно на этапе компиляции. Но раз x неизвестна на этапе
[56:45.600 --> 56:49.240]  компиляции, то и значение переменной square от x тоже не может быть известно на этапе компиляции.
[56:49.240 --> 56:57.040]  Понятно? Вот, то есть constexpr, то есть таким образом можно использовать константная
[56:57.040 --> 56:59.960]  переменная для того, чтобы гарантировать, что, то есть если вы хотите действительно сказать,
[56:59.960 --> 57:03.800]  что значение данной переменной известно на этапе компиляции, вы можете помнить ее как
[57:03.800 --> 57:08.440]  constexpr, ну и таким образом const станет более читаемым, и во-вторых, таким образом вы сами
[57:08.440 --> 57:11.360]  себя будете проверять, то есть компилятор будет проверять, что действительно значение переменной
[57:11.360 --> 57:16.840]  известно только на этапе компиляции, а не на этапе исполнения программы.
[57:16.840 --> 57:21.600]  Вот. Соответственно, constexpr-переменные обладают следующими свойствами. Во-первых,
[57:21.600 --> 57:25.600]  переменная должна быть литерального типа, ну мы про это сказали, вот. Она должна быть,
[57:25.600 --> 57:30.480]  она обязана быть принципизирована константным выражением, вот сказали. И во-вторых,
[57:30.480 --> 57:35.080]  constexpr-переменные являются, и во-вторых, constexpr-переменные являются сами по себе
[57:35.080 --> 57:44.840]  константными. Ну, это я тоже упомянул. Теперь, смотрите, какая еще возникла проблема. Вот у нас
[57:44.840 --> 57:49.960]  есть возможность писать const-переменные, есть возможность писать constexpr-переменные.
[57:49.960 --> 57:59.200]  Вот. По сути, ну что можно сказать? Можно сказать, что constexpr-переменная, она является, ну такой
[57:59.200 --> 58:04.360]  вот, часть constexpr-переменных, да, почему? Потому что constexpr-переменные, помимо того, что, так,
[58:04.360 --> 58:12.240]  неправильно, да, наверное, ну так стоит. Ну, короче говоря, constexpr-переменная, помимо того,
[58:12.240 --> 58:16.280]  что является еще и константной переменной, да, constexpr-переменная еще гарантирует, что она
[58:16.280 --> 58:21.560]  обязана быть принципизирована константным выражением, вот. А что, если я хочу сказать следующее,
[58:21.560 --> 58:26.600]  что если я хочу сказать, что переменная сама по себе не является константной, да, то есть переменная
[58:26.600 --> 58:31.360]  может менять свое значение, но при этом принципизирована, она должна быть некоторым
[58:31.360 --> 58:34.920]  константным выражением. То есть значение данной переменной, начальное значение данной переменной,
[58:34.920 --> 58:40.040]  должно быть известно еще на этапе компиляции, вот, но при этом в последствии, да, в последствии,
[58:40.040 --> 58:44.640]  в результате выполнения программы переменная может свое значение менять. Вот. Как можно,
[58:44.640 --> 58:50.440]  как можно такое, как можно такое провернуть? Ну, смотрите, во-первых, для чего это может быть
[58:50.440 --> 58:56.160]  нужно? Значит, пример показан на экране. Смотрите, вот у меня есть функция pull, когда объявлена
[58:56.160 --> 59:01.080]  констэкспорт. Ну, по понятным причинам, да, то есть я хочу, чтобы возведение в степень, ну, работало
[59:01.080 --> 59:04.800]  и на этапе исполнения, и на этапе компиляции, вот, но при этом я хочу дать дополнительную
[59:04.800 --> 59:10.920]  возможность компилятору запускать эту функцию на этапе, на этапе компиляции, вот. Но если я напишу
[59:10.920 --> 59:16.600]  вот такой код, там auto x равно поу 3 5, то несмотря на то, что компилятор может вычислить степень,
[59:16.600 --> 59:21.640]  3 в степени 5 на этапе компиляции, скорее всего он этим заниматься не будет, то есть, ну, как минимум
[59:21.640 --> 59:26.200]  вот это вот поведение, да, то есть, как минимум, вычисление на этапе компиляции не гарантируется. А что, если я хочу,
[59:26.200 --> 59:31.120]  ну, что если я хочу сделать так, чтобы, ну, что если я хочу, чтобы у меня на этапе исполнения
[59:31.120 --> 59:35.520]  программы не тратилось время на вычтение, на вычтение этой самой степени, что если я хочу, чтобы
[59:35.520 --> 59:41.360]  значение переменной x начальное было уже заранее вычислено на заранее известный этапе компиляции. Вот,
[59:41.360 --> 59:47.440]  чтобы этого достичь, да, чтобы вынудить компилятор, вот, в данном контексте вычислить значение функции pull,
[59:47.440 --> 59:52.480]  можно поступить следующим образом. Можно воспользоваться ключевым словом constantit,
[59:52.480 --> 59:57.280]  которое тоже появилось все плюс 20. Что такое constantit переменная? А constantit переменная,
[59:57.280 --> 01:00:00.760]  ну, это как раз таки ровно та самая переменная, которая нам была нужна в предыдущем, в предыдущем
[01:00:00.760 --> 01:00:06.200]  примере. А constantit переменная гарантирует, гарантирует, что значение данной переменной, начальное
[01:00:06.200 --> 01:00:11.280]  значение данной переменной, будет известно на этапе компиляции, вот. Но при этом сама переменная
[01:00:11.280 --> 01:00:19.440]  не является константой, вот. То есть, можно считать, можно считать, что constant export переменная,
[01:00:19.440 --> 01:00:35.560]  constant export переменная, это есть const plus constantit, вот. То есть, constant export переменная,
[01:00:35.560 --> 01:00:39.160]  она, во-первых, нельзя менять во время исполнения программ, во-вторых, ее значение должно быть
[01:00:39.160 --> 01:00:43.960]  известно на этапе компиляции, вот. При этом, просто const переменная, она не обязана иметь значение,
[01:00:43.960 --> 01:00:47.960]  которое известно на этапе компиляции, а constantit переменная, она, она может, в принципе, в теории
[01:00:47.960 --> 01:00:53.560]  менять свое значение в процессе работы программы, вот. И поэтому, если мы рассмотрим данный пример,
[01:00:53.560 --> 01:00:58.320]  то что у нас тут есть? У нас тут есть constant export функция pull, которая может быть вычислена на этапе
[01:00:58.320 --> 01:01:03.800]  компиляции, и плюс вот этот самый вызов функции pull происходит при инициализации constantit переменной
[01:01:03.800 --> 01:01:08.400]  х. Но раз constantit переменная х, она, обязана быть вычислена, то есть ее значение обязательно
[01:01:08.400 --> 01:01:11.680]  быть вычислено на этапе компиляции, то к эмпилятору ничего не остается, кроме как вычислить значение
[01:01:11.680 --> 01:01:29.760]  3 степени 5 на этапе компиляции, вот. Понятно? Есть ли вопросы? Смотрите, чтобы, то есть, там, на самом
[01:01:29.760 --> 01:01:36.240]  деле, довольно сложные, в общем, сложные взаимоотношения с constant export, в общем, с constant export типами, давайте
[01:01:36.240 --> 01:01:47.960]  вернемся. Вот, смотрите, вот dos и plus, dos и plus 23, в качестве, ну, в качестве, в качестве переменных,
[01:01:47.960 --> 01:01:52.880]  которые могут встречаться в constant export функциях, могли встречаться только, могли встречаться только
[01:01:52.880 --> 01:01:56.920]  литеральные типы. Почему Behr не считался литеральным типом? Потому что, ну, во-первых, у него есть
[01:01:56.920 --> 01:02:00.600]  нетривиальные конструкторы, у него есть нетривиальные конструкторы копирования, конструкторы
[01:02:00.600 --> 01:02:04.600]  перемещения, плюс он внутри себя, естественно, там, в своих конструкторах вызывал new, ну, а dos и
[01:02:04.600 --> 01:02:09.080]  plus 20, соответственно, new в constant export контексте вызывать нельзя было, вот. Соответственно,
[01:02:09.080 --> 01:02:14.200]  начиная с plus 20 в constant export контексте, можно вызывать теперь практически все что угодно, там всякие
[01:02:14.200 --> 01:02:21.160]  try, catch блоки, new, delete и так далее, и плюс, соответственно, я, если я помечу, если я какие-то
[01:02:21.160 --> 01:02:25.520]  конструкторы и диструктор помечу как constant export, то, соответственно, таким образом, я для типа скажу, что,
[01:02:25.760 --> 01:02:29.880]  ну, данный конструктор можно вызывать на этапе компиляции, вот. Ну, соответственно, таким образом в
[01:02:29.880 --> 01:02:33.680]  векторе появилось это все, то есть, во-первых, появилась поддержка выделения памяти на этапе
[01:02:33.680 --> 01:02:37.360]  компиляции, плюс появилась поддержка constant export конструкторов, диструкторов, вот. Ну, и, соответственно,
[01:02:37.360 --> 01:02:48.680]  начиная с plus 23, можно создавать с вектора и на этапе компиляции, вот. Есть еще вопрос, да.
[01:02:48.680 --> 01:02:58.000]  Ну, потому что, ну, смотрите, если вы, проблема вот в чем, если вы объявите статическую
[01:02:58.000 --> 01:03:03.360]  переменную, давайте, вообще, кажется, эта проблема довольно-таки очевидная, ну, давайте.
[01:03:03.360 --> 01:03:23.360]  Смотрите, вот у вас есть функция f, вот. И представьте себе, что в ней есть статическая
[01:03:23.360 --> 01:03:34.240]  переменная, static int x там равно чему-то, вот. В чем проблема статических переменных? Ну, проблема
[01:03:34.240 --> 01:03:42.200]  статических переменных заключается в том, что, ну, статические переменные, они, смотрите, статические
[01:03:42.200 --> 01:03:49.560]  переменные инициализируются всегда только один раз при первом вызове функции f, вот. При этом,
[01:03:49.700 --> 01:03:53.480]  что считается первым вызовом функции f? Первым вызовом функции f считается, ну, как
[01:03:53.480 --> 01:03:57.240]  тот момент, когда у меня программа там начинает свое исполнение, дальше у меня программа
[01:03:57.240 --> 01:04:00.280]  исполняется, исполнилась, исполняется и в какой-то момент я там, и в какой-то
[01:04:00.280 --> 01:04:05.160]  момент, соответственно, вызываю функцию f. Вот, как только я в первую вызвал функцию f,
[01:04:05.160 --> 01:04:08.880]  у меня создается вот эта статическая переменная и дальше она начинает жить. Вот. В чем тут проблема?
[01:04:08.880 --> 01:04:16.360]  Представьте, что я теперь функцию f могу вызывать в
[01:04:16.360 --> 01:04:20.620]  конструктор-контексте, то возникает проблема, а что считать первым вызовом
[01:04:20.620 --> 01:04:25.340]  функции f? То есть считать ли вызов функции f на этап компиляции первым ее вызван или нет?
[01:04:25.340 --> 01:04:30.340]  То есть, смотрите, если у меня функция f вызвана вот здесь, то считается это или нет?
[01:04:30.340 --> 01:04:34.380]  С одной стороны, считается, потому что вроде как функция была вызвана, а с другой
[01:04:34.380 --> 01:04:38.100]  стороны, не считается, потому что предыдущий код, предыдущий legacy код,
[01:04:38.100 --> 01:04:42.220]  он мог опираться на то, что функция f вычисляется только на этапе
[01:04:42.220 --> 01:04:45.380]  исполнения, поэтому статическая перемена
[01:04:45.380 --> 01:04:50.800]  вызывается только на этапе исполнения. Вот, это первая проблема, а вторая проблема
[01:04:50.800 --> 01:04:55.160]  заключается в следующем. Представьте себе такую картину, а что если у меня тут стоит
[01:04:55.160 --> 01:05:05.280]  какой-то указатель static int звёдочка x, и я тут пишу new int.
[01:05:05.280 --> 01:05:09.360]  Что делать в этом случае? То есть, ну представьте, что я, допустим, разрешил
[01:05:09.360 --> 01:05:13.280]  писать new, но при этом статическую перемену
[01:05:13.280 --> 01:05:20.020]  записал какой-то указатель на какую-то другую переменную.
[01:05:20.020 --> 01:05:24.340]  В чём тут проблема? Проблема состоит в том, что если я вычисляю функцию на этапе
[01:05:24.340 --> 01:05:28.180]  компиляции, то мне нужен вот этот вот указатель, да, каким-то образом с этапом
[01:05:28.180 --> 01:05:31.740]  компиляции потом в последствии перенести на этап исполнения. Но как бы на этапе
[01:05:31.740 --> 01:05:36.100]  компиляции, на этапе исполнения будут совершенно разные значения. Вот, поэтому, в общем,
[01:05:36.100 --> 01:05:40.700]  со статическими переменами большое количество проблем, поэтому до какого-то
[01:05:40.700 --> 01:05:49.740]  момента они были запрещены. Вот, кстати, я не знаю, как они там решили эти
[01:05:49.740 --> 01:05:53.880]  проблемы с плюс 23, надо это отдельно посмотреть. Вот, но в целом проблемы с ними есть,
[01:05:53.880 --> 01:06:00.480]  поэтому, видимо, так долго их не водили. Ещё проблемы, ой, ещё вопросы или
[01:06:00.480 --> 01:06:09.840]  проблемы? Хорошо, давайте, давайте посмотрим, что у нас ещё осталось,
[01:06:09.840 --> 01:06:15.480]  константинит перемен, а, ну, в общем-то, всё, да. Собственно, мораль. Какая мораль?
[01:06:15.480 --> 01:06:21.880]  Человечество проделало очень большой путь от вот этого к вот этому. Вот, поэтому,
[01:06:21.880 --> 01:06:27.120]  в общем, что важно понимать? Важно понимать, вообще говоря, процесс инстанцирования
[01:06:27.120 --> 01:06:30.000]  шаблонов, да, то есть важно понимать, что процесс инстанцирования шаблонов
[01:06:30.000 --> 01:06:34.360]  происходит на этапе компиляции, поэтому при постановке шаблонов параметров у него,
[01:06:34.360 --> 01:06:41.040]  то есть компилятор нет никаких вариантов, и он обязан вычислять те свои параметры на этапе
[01:06:41.040 --> 01:06:44.800]  компиляции. Если у него такой возможности нет, то, соответственно, возникает ошибка
[01:06:44.800 --> 01:06:51.200]  компиляции. Вот, ну и, наконец, современные стандарты C++ привнесли много всего нового,
[01:06:51.200 --> 01:06:59.040]  чтобы можно было бы работать с вычислением на этапе компиляции. Вот, но, на самом деле,
[01:06:59.040 --> 01:07:04.920]  с этим есть много разных проблем, которые постепенно решаются. Вот, постепенно рамки того,
[01:07:04.920 --> 01:07:09.120]  что можно делать на этапе компиляции, что можно вычислять на этапе компиляции,
[01:07:09.120 --> 01:07:15.760]  на этапе исполнения программы, они увеличиваются. Вот. Есть ли вопросы?
[01:07:15.760 --> 01:07:22.640]  Ну, окей, тогда на сегодня все. До встречи в следующей неделе.
