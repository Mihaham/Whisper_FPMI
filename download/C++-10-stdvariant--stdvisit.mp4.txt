[00:00.000 --> 00:15.000]  Наш цель – обсудить, как устроен STD-вариант изнутри и еще, как устроено функциональный visit.
[00:15.000 --> 00:19.000]  То, что вам Федя показывал в прошлый раз в конце.
[00:19.000 --> 00:24.000]  И после этого можно будет выдать вторую задачу, которая…
[00:24.000 --> 00:27.000]  Ой, не вторую, а пятую задачу.
[00:27.000 --> 00:32.000]  И предпоследнюю задачу в этом семестре, которая называется вариант.
[00:32.000 --> 00:37.000]  То есть STD-вариант у вас будет задание реализовать.
[00:37.000 --> 00:45.000]  Но перед этим нам надо закончить, что мы недообсудили в прошлый раз.
[00:45.000 --> 00:49.000]  И в прошлый раз мы недообсудили STD-фанкшн.
[00:54.000 --> 00:59.000]  Вот такой файл был.
[00:59.000 --> 01:05.000]  Я думаю, что можно помельче сделать даже.
[01:05.000 --> 01:13.000]  В прошлый раз мы остановились на том, как реализовать STD-фанкшн.
[01:13.000 --> 01:20.000]  И обсудили почти все, что нужно.
[01:20.000 --> 01:23.000]  Решили почти все проблемы.
[01:23.000 --> 01:27.000]  Но самое последнее я не сказал.
[01:27.000 --> 01:33.000]  Давайте вспомним, что у нас там было.
[01:33.000 --> 01:39.000]  Во-первых, делали small object optimization.
[01:39.000 --> 01:42.000]  Это, если функция, а это часто бывает,
[01:42.000 --> 01:46.000]  если функциональный объект, его size of меньше или равен,
[01:46.000 --> 01:48.000]  чем некоторое число, например, 16,
[01:48.000 --> 01:52.000]  то нет смысла выделять под него динамическую память.
[01:52.000 --> 01:55.000]  Мы его храним в локальном буфере.
[01:55.000 --> 02:00.000]  Дальше, что мы еще делаем?
[02:00.000 --> 02:12.000]  Если у нас функтор, вот этот вызываемый callable объект,
[02:12.000 --> 02:16.000]  является pointer to member, указателем на член,
[02:16.000 --> 02:19.000]  то обычный синтаксис вызова не сработает,
[02:19.000 --> 02:24.000]  и нам надо будет делать вот такой синтаксис вызова
[02:24.000 --> 02:28.000]  через точку со звездочкой, ну или через стрелочку со звездочки.
[02:28.000 --> 02:30.000]  Поэтому, чтобы нам корректно вызывать,
[02:30.000 --> 02:33.000]  и в таком тоже случае мы используем STD-invoke.
[02:33.000 --> 02:36.000]  Я напоминаю, вот этот STD-invoke,
[02:36.000 --> 02:40.000]  она нужна для того, чтобы корректно обрабатывать ситуации,
[02:40.000 --> 02:42.000]  когда у нас callable не обычный,
[02:42.000 --> 02:45.000]  а, например, указатель на член или указатель на метод.
[02:45.000 --> 02:48.000]  Вообще объект, в котором мы вызываемся, является указательным.
[02:48.000 --> 02:52.000]  Он корректно обрабатывает стрелочку у нас со звездочкой и так далее.
[02:52.000 --> 02:55.000]  Вот, и какая еще была проблема последняя,
[02:55.000 --> 02:59.000]  которую мы обсуждали, это...
[02:59.000 --> 03:01.000]  Да вроде все, вроде у нас там...
[03:01.000 --> 03:03.000]  Ну, еще здесь корректно move-ать надо.
[03:03.000 --> 03:06.000]  Напоминаю, что вот здесь мы все forward-им.
[03:06.000 --> 03:08.000]  Вот.
[03:08.000 --> 03:12.000]  Здесь возвращаемый тип, мы написали declType от авто.
[03:12.000 --> 03:16.000]  Я, кстати, не уверен, что declType от авто будет всегда корректно подходить здесь,
[03:16.000 --> 03:18.000]  но может быть...
[03:18.000 --> 03:20.000]  Ну, кажется, что в базовых случаях будет.
[03:20.000 --> 03:23.000]  Но на самом деле здесь не declType от авто написано,
[03:23.000 --> 03:25.000]  а invokeResultT.
[03:25.000 --> 03:27.000]  Вот, и вычисляется он более сложно.
[03:27.000 --> 03:31.000]  Ну, по сути, он вычисляется отдельно для того, чтобы корректно вернуть.
[03:31.000 --> 03:33.000]  Ну, там есть какие-то тонкости,
[03:33.000 --> 03:37.000]  из-за которых, кажется, declType от авто не будет работать, но...
[03:37.000 --> 03:40.000]  Ну, в смысле, в каких-то краевых случаях, кажется, declType от авто не подойдет.
[03:40.000 --> 03:43.000]  То есть там, если у нас массивы, поинтеры, что-нибудь такое,
[03:43.000 --> 03:46.000]  то там declType от авто не подходит,
[03:46.000 --> 03:50.000]  поэтому в стандартной библиотеке используется специальная метафункция invokeResultT,
[03:50.000 --> 03:52.000]  которая, по сути, просто вот это все повторяет,
[03:52.000 --> 03:56.000]  и вот возвращаемый тип этого и называется invokeResult.
[03:56.000 --> 03:59.000]  Вот.
[03:59.000 --> 04:01.000]  У нас есть две проблемы еще.
[04:01.000 --> 04:03.000]  Ну, как две? Даже, наверное, три.
[04:03.000 --> 04:06.000]  Вот про function еще надо сказать три вещи.
[04:07.000 --> 04:10.000]  Во-первых...
[04:13.000 --> 04:16.000]  Ну, давайте начнем вот с чего.
[04:19.000 --> 04:22.000]  Сейчас я открою некоторый заготовленный код.
[04:36.000 --> 04:38.000]  Так.
[04:46.000 --> 04:49.000]  Значит, смотрите.
[04:56.000 --> 04:59.000]  Я назову файл function.impl2.cpp.
[04:59.000 --> 05:02.000]  Он у меня просто в другой папочке лежит.
[05:03.000 --> 05:07.000]  На самом деле стандартная функция реализована не так, как я написал.
[05:07.000 --> 05:11.000]  Она реализована чуть хитрее.
[05:11.000 --> 05:15.000]  И вот что там на самом деле написано.
[05:15.000 --> 05:20.000]  Вот это будет function.impl, а я сейчас открою function.impl2.
[05:20.000 --> 05:24.000]  Я просто этот код заранее подготовил.
[05:24.000 --> 05:28.000]  Я не хочу писать его руками, потому что это долго,
[05:28.000 --> 05:32.000]  но вот вкратце давайте обсудим, что здесь написано
[05:32.000 --> 05:36.000]  и чем это может быть лучше или хуже, чем то, что мы написали раньше.
[05:36.000 --> 05:40.000]  На самом деле мы, когда реализовались на function,
[05:40.000 --> 05:43.000]  использовали виртуальные функции.
[05:43.000 --> 05:46.000]  И вот стандартная библиотека...
[05:46.000 --> 05:50.000]  Ну, виртуальные функции, в которых еще...
[05:50.000 --> 05:54.000]  Там еще есть штука typeID, то есть хранится typeInfo.
[05:54.000 --> 05:58.000]  Можно у function, кажется, спросить название typeInfo того функтора,
[05:58.000 --> 06:00.000]  который там сейчас лежит.
[06:00.000 --> 06:05.000]  Вот в стандартной библиотеке function реализован не так, не через виртуальные функции.
[06:07.000 --> 06:09.000]  Есть другой подход.
[06:09.000 --> 06:13.000]  То есть можно сделать все то же самое, но без виртуальных функций.
[06:15.000 --> 06:19.000]  Понимаете ли вы идеи, как это можно сделать без виртуальных функций?
[06:19.000 --> 06:22.000]  На самом деле мы с вами вот эти вот виртуальные функции здесь использовали
[06:22.000 --> 06:25.000]  Зачем нам нужны виртуальные функции здесь были?
[06:25.000 --> 06:30.000]  Потому что без них мы как бы не умеем динамически подменять тип того, что у нас лежит.
[06:33.000 --> 06:35.000]  Почему не умеем?
[06:35.000 --> 06:40.000]  Потому что, ну, как минимум нам надо уметь вызывать деструктор старого,
[06:40.000 --> 06:43.000]  прежде чем класть новый.
[06:43.000 --> 06:47.000]  Если мы уничтожаем старый функтор и кладем на него новый,
[06:47.000 --> 06:50.000]  то нам нужно уметь вызывать деструктор.
[06:50.000 --> 06:55.000]  Но мы не можем узнать, какой именно код нужно вызвать для деструктора,
[06:55.000 --> 07:01.000]  если мы не помним, какой реально тип лежит под function.
[07:01.000 --> 07:07.000]  То есть нам нужно где-то что-то хранить, какой-то указатель на функцию,
[07:07.000 --> 07:10.000]  которая должна отрабатывать, когда деструктор вызывается.
[07:10.000 --> 07:13.000]  И по сути виртуальные функции именно этот механизм реализуют.
[07:13.000 --> 07:19.000]  Виртуальная таблица это и есть набор указателей на функции,
[07:19.000 --> 07:22.000]  которые вызываются в соответствующих случаях.
[07:22.000 --> 07:25.000]  Значит, что делать, если позвали деструктор,
[07:25.000 --> 07:27.000]  что делать, если позвали копирование,
[07:27.000 --> 07:31.000]  что делать, если позвали там, не знаю, оператор круглые скобочки и так далее.
[07:31.000 --> 07:33.000]  Ну, то есть вот здесь вот.
[07:33.000 --> 07:39.000]  Вот здесь вот еще должен быть метод getCopy тоже виртуальный,
[07:39.000 --> 07:43.000]  который будет зваться в случае, если позвали копирование.
[07:43.000 --> 07:51.000]  Там метод getMove, наверное, если позвали мувающий конструктор, ну и так далее.
[07:51.000 --> 07:55.000]  Вот, ну, мы его не реализовали, но понятно, что он должен быть.
[07:55.000 --> 08:03.000]  Вот можно все это делать не через виртуальные функции, а вручную.
[08:03.000 --> 08:09.000]  И у такого подхода, кажется, могут быть преимущества по эффективности.
[08:09.000 --> 08:13.000]  А мы хотим, типа, просто вручную реализовать то же самое?
[08:13.000 --> 08:17.000]  Ну, вот подход, который в STL выбран.
[08:17.000 --> 08:22.000]  Вот если вы откроете STL-ный код Function, вы там не найдете слово virtual нигде.
[08:22.000 --> 08:27.000]  Вот если вы откроете прям класс Function, вот я сейчас попробую.
[08:27.000 --> 08:29.000]  Я не знаю, здесь у меня есть вот Function.
[08:29.000 --> 08:31.000]  Давайте я попробую открыть.
[08:31.000 --> 08:37.000]  Нет, к сожалению, он так не может, что у меня сломалась переход к типу.
[08:37.000 --> 08:41.000]  Может быть, здесь он сможет.
[08:41.000 --> 08:47.000]  Да, ну вот, значит, вот я открыл STD Function, вот файл просто открыл.
[08:47.000 --> 08:51.000]  И здесь можно попробовать найти слово virtual.
[08:51.000 --> 08:55.000]  И я просто по коду STD Function ищу слово virtual.
[08:55.000 --> 08:59.000]  И вот я нашел bad function call, это исключение.
[08:59.000 --> 09:01.000]  Больше слова virtual не встречается нигде.
[09:01.000 --> 09:06.000]  То есть Function реализована как-то без виртуальных функций.
[09:06.000 --> 09:09.000]  Как же оно так сделано?
[09:09.000 --> 09:16.000]  А здесь просто, видите, есть статические методы, которые, по сути,
[09:16.000 --> 09:21.000]  ну, в каком-то смысле аналогичны по поведению таблиц виртуальных функций.
[09:21.000 --> 09:23.000]  Что такое таблица виртуальных функций?
[09:23.000 --> 09:26.000]  Это для данного типа набор статических методов.
[09:26.000 --> 09:28.000]  Что делать, если позвали destructor?
[09:28.000 --> 09:31.000]  Что делать, если позвали copy constructor?
[09:31.000 --> 09:34.000]  Что делать, если позвали оператора круглые скобочки?
[09:34.000 --> 09:37.000]  Мы можем, по сути, сделать то же самое.
[09:37.000 --> 09:39.000]  Мы можем сделать вот так.
[09:39.000 --> 09:41.000]  Я вам сейчас еще раз покажу этот код.
[09:41.000 --> 09:46.000]  Значит, это очень упрощенный код, но, значит, идейно он отражает суть.
[09:46.000 --> 09:51.000]  У нас будет для данного функтора, для данного typeName функтор
[09:51.000 --> 09:56.000]  шаблонный метод, который будет называться invoke,
[09:56.000 --> 09:59.000]  и он будет, значит, делать вызов этой функции.
[09:59.000 --> 10:04.000]  Ну, тут должен быть std invoke, но для простоты я делаю просто вызов,
[10:04.000 --> 10:06.000]  обычно через круглые скобочки.
[10:06.000 --> 10:10.000]  У нас будет шаблонный метод create, который для данного функтора
[10:10.000 --> 10:18.000]  создает по адресу destination объект функтор от другого.
[10:18.000 --> 10:21.000]  По сути, метод copy.
[10:21.000 --> 10:24.000]  У нас будет шаблонный метод статический, destroy,
[10:24.000 --> 10:27.000]  который для данного функтора, опять-таки,
[10:27.000 --> 10:31.000]  указатель на объект типа функтор вызывает его destructor.
[10:31.000 --> 10:35.000]  По сути, это и есть аналог таблицы виртуальных функций.
[10:35.000 --> 10:39.000]  Давайте назовем теперь вот такими типами.
[10:39.000 --> 10:44.000]  Значит, invoke.ptrt – это что такое?
[10:44.000 --> 10:48.000]  Это указатель на функцию, которая принимает void-звездочку
[10:48.000 --> 10:51.000]  и аргументы, и возвращает рез.
[10:51.000 --> 10:58.000]  Значит, create.ptrt – это просто штука, которая принимает две void-звездочки
[10:58.000 --> 11:02.000]  и возвращает ничего, а является указательной такой функцией.
[11:02.000 --> 11:05.000]  А destroy.ptrt – это указательная функция, которая просто
[11:05.000 --> 11:08.000]  принимает void-звездочку и ничего не возвращает.
[11:08.000 --> 11:14.000]  И по сути, мы в классе храним вот эти указатели,
[11:14.000 --> 11:19.000]  мы в объекте нашего класса, function, храним указатели
[11:19.000 --> 11:26.000]  на эти pointer, ой, господи, на эти методы статические.
[11:26.000 --> 11:31.000]  Когда мы создаем функцию, когда мы создаем function
[11:31.000 --> 11:35.000]  от функтора, мы инициализируем эти указатели.
[11:35.000 --> 11:40.000]  Указатели чем? Invoke.ptr – мы берем вот этот вот invoke от функтора,
[11:40.000 --> 11:44.000]  invoke с шаблонным параметром функтора, статический метод,
[11:44.000 --> 11:49.000]  и указатель на него, ну и кастим invoke к типу invoke.ptrt.
[11:49.000 --> 11:52.000]  То есть invoke.ptrt – reinterpret.cast.
[11:52.000 --> 11:56.000]  То есть мы просто, ну вот по сути делаем стирание типа.
[11:56.000 --> 11:59.000]  То есть мы делаем вот эти вот методы от void-звездочки, хотя на самом деле
[11:59.000 --> 12:02.000]  они от функтора звездочки. Всякий раз, когда мы создаем
[12:02.000 --> 12:06.000]  от нашего нового типа функтор, мы тем самым заставляем компилятор
[12:06.000 --> 12:10.000]  сгенерировать новую, ну синстанцировать новый статический метод
[12:10.000 --> 12:14.000]  с данным шаблонным параметром функтора, куда запихать код,
[12:14.000 --> 12:19.000]  что делать для такого функтора. И сохраняем у себя вот этот вот pointer
[12:19.000 --> 12:23.000]  на этот статический метод. Соответственно, когда нас просят
[12:23.000 --> 12:27.000]  что-то сделать, ну да, вот здесь надо еще сделать create, собственно.
[12:28.000 --> 12:32.000]  Или здесь надо просто new сделать сейчас. Давайте подумаем.
[12:32.000 --> 12:37.000]  Значит, я проинциализировал вот эти указатели, а теперь я могу просто сделать…
[12:41.000 --> 12:47.000]  Ну да, никто не отменял, что мне надо сделать align-ness, std,
[12:47.000 --> 13:00.000]  max-align-t, char, buffer, размером, господи, max-buffer-size.
[13:00.000 --> 13:04.000]  Ну то есть, короче, всю эту штуку мне надо сделать по-прежнему.
[13:04.000 --> 13:14.000]  И здесь мне нужно просто создать new от…
[13:17.000 --> 13:19.000]  Ну или мне, собственно, надо вызвать вот этот create.
[13:19.000 --> 13:22.000]  Да, по сути, create мне и надо вызвать. Значит, create-ptr.
[13:24.000 --> 13:30.000]  От чего? Значит, из чего на что? Мне нужно передать ему
[13:30.000 --> 13:34.000]  functor звездочка dest и functor звездочка crc. functor звездочка dest
[13:34.000 --> 13:42.000]  это будет мой буфер, а crc это будет вот эта штука.
[13:42.000 --> 13:46.000]  Ну, тут, возможно, надо сделать какие-то интерпрет-касты явные,
[13:46.000 --> 13:50.000]  чтобы оно скомпилировалось, но идея на именно это происходит.
[13:50.000 --> 13:53.000]  Значит, когда мне будет вызывать деструктор? Или когда мне будет вызывать
[13:53.000 --> 13:56.000]  оператор присваивания? Что я должен сделать?
[13:56.000 --> 14:02.000]  Ну, допустим, я хочу вот этому functor, ага, значит, function…
[14:06.000 --> 14:14.000]  Ну это опять будет template, typeName, functor, function&,
[14:14.000 --> 14:20.000]  оператор равно от const functor&f.
[14:20.000 --> 14:25.000]  И что я здесь должен сделать? Я должен сделать сначала dest ptr
[14:25.000 --> 14:31.000]  вызвать от своего буфера, а затем сделать…
[14:31.000 --> 14:37.000]  Ну, проинициализировать мои новые pointer вот этим вот типом,
[14:37.000 --> 14:43.000]  который мне передали. То есть invoke-ptr проинициализировать,
[14:43.000 --> 14:51.000]  reinterpret-cast-нуть к invoke-ptrt от того, значит, этот reinterpret-cast-нуть
[14:51.000 --> 15:00.000]  сделать вот так, dest ptr reinterpret-cast-нуть сделать вот так.
[15:00.000 --> 15:08.000]  И, значит, после этого сделать create ptr вот опять-таки от буфер
[15:08.000 --> 15:10.000]  и от того, что мне дали.
[15:10.000 --> 15:12.000]  А что такое еще раз буфер?
[15:12.000 --> 15:16.000]  Ну, буфер – это то самое место, где мы храним function наш.
[15:16.000 --> 15:19.000]  Вот. Ну, тут надо опять-таки…
[15:19.000 --> 15:29.000]  Ну, здесь должно быть как в нашем function smallObjectsOptimization,
[15:29.000 --> 15:33.000]  потому что у нас буфер может быть…
[15:33.000 --> 15:38.000]  Ну, у нас должен быть, короче, pointer на случай, если объект функции
[15:38.000 --> 15:41.000]  не помещается в динамическую, в локальный буфер.
[15:41.000 --> 15:45.000]  Или если помещается, мы просто на него кладем.
[15:45.000 --> 15:49.000]  Ну, то есть здесь должно быть еще написано if constexpr…
[15:49.000 --> 15:52.000]  Ну, короче, буфер – это просто то место, куда мы объект кладем,
[15:52.000 --> 15:53.000]  объект самого functor.
[15:53.000 --> 15:57.000]  Но на случай, если он помещается в smallObjectsOptimization,
[15:57.000 --> 16:00.000]  то есть maxBufferSize, ну, допустим, 16 или 32.
[16:00.000 --> 16:04.000]  Мы считаем, что если объект size объекта меньше или равен чем это,
[16:04.000 --> 16:07.000]  то мы просто кладем по этому адресу наш объект.
[16:07.000 --> 16:11.000]  А если нет, то здесь нужно еще сделать pointer на динамическую память,
[16:11.000 --> 16:19.000]  куда мы будем класть объект в случае, если его размер не влезает.
[16:27.000 --> 16:30.000]  Ну, соответственно, надо подредактировать весь код,
[16:30.000 --> 16:36.000]  чтобы различать, мы сейчас должны в динамическую память идти
[16:36.000 --> 16:38.000]  или не в динамическую память.
[16:38.000 --> 16:42.000]  Ну, то есть нам надо еще где-то помнить опять-таки, видимо, bool.
[16:42.000 --> 16:45.000]  Ну, как мы там это делали? Я уже забыл. У нас был…
[16:45.000 --> 16:46.000]  Ну да.
[16:46.000 --> 16:49.000]  У нас был FPTR, который либо NullPtr, да, либо не NullPtr.
[16:49.000 --> 16:53.000]  Если он NullPtr, то мы, значит, понимаем, что у нас локальный storage
[16:53.000 --> 16:55.000]  и идем вот от этого вызываться.
[16:55.000 --> 16:58.000]  Если он не NullPtr, то мы идем вызываться от того адреса,
[16:58.000 --> 17:00.000]  где лежит наш объект.
[17:01.000 --> 17:08.000]  Вот. Вот. По сути, мы написали таблицу виртуальных функций своими руками.
[17:08.000 --> 17:14.000]  Вот. Именно так сделано VSTL, именно так реализована Function.
[17:14.000 --> 17:18.000]  А зачем так сделано? Какой-нибудь есть идеи?
[17:18.000 --> 17:22.000]  То есть вот на самом деле то, что мы делали раньше, оно…
[17:22.000 --> 17:26.000]  Ну, проще пишется, казалось бы.
[17:26.000 --> 17:29.000]  Мы просто использовали готовый механизм виртуальных функций.
[17:29.000 --> 17:32.000]  Но можно было бы предположить, что мы не знаем виртуальных функций.
[17:32.000 --> 17:34.000]  Тогда мы могли бы, по сути, написать его сами.
[17:34.000 --> 17:38.000]  То, что здесь сделано, это, по сути, самописное виртуальное…
[17:38.000 --> 17:40.000]  самописное retable.
[17:40.000 --> 17:44.000]  Вот. А настоящий retable, ее отличает одно.
[17:44.000 --> 17:47.000]  Мы прямо в объекте класса храним эти поинтеры.
[17:47.000 --> 17:49.000]  И мы это тут побыстрее.
[17:49.000 --> 17:54.000]  Мы увидим, у нас просто меньше на один прыжок по указателю.
[17:54.000 --> 17:59.000]  Да. Значит, преимущество…
[17:59.000 --> 18:01.000]  В смысле избежать runtime приколов.
[18:01.000 --> 18:03.000]  В чате пишет человек.
[18:03.000 --> 18:05.000]  Избежать runtime приколов мы, кажется, никак не можем,
[18:05.000 --> 18:07.000]  потому что все равно уже в runtime идти подменяем.
[18:07.000 --> 18:09.000]  Вот.
[18:09.000 --> 18:12.000]  Преимущество этого в том…
[18:12.000 --> 18:17.000]  Ну, одно из преимуществ этого в том, что мы не прыгаем в…
[18:17.000 --> 18:22.000]  Ну да, можно сказать, что вот в такой реализации у нас
[18:22.000 --> 18:24.000]  на один прыжок по указателю меньше,
[18:24.000 --> 18:26.000]  когда мы с функцией что-то делаем.
[18:26.000 --> 18:29.000]  Когда мы, например, делаем call, вызываем функцию,
[18:29.000 --> 18:33.000]  делаем invoke, то поинтер, по которому делать invoke,
[18:33.000 --> 18:39.000]  он сразу вот этот вот адрес, указатель на функцию,
[18:39.000 --> 18:41.000]  которая является вызовом нашего функтора,
[18:41.000 --> 18:43.000]  она вот тут у нас прямо лежит.
[18:43.000 --> 18:45.000]  Нам не нужно идти в таблицу виртуальных функций
[18:45.000 --> 18:48.000]  и там искать адрес этой функции.
[18:48.000 --> 18:51.000]  То есть как будто бы мы делаем на один прыжок меньше.
[18:51.000 --> 18:58.000]  Правда, при такой реализации у нас размер самого объекта function
[18:58.000 --> 19:00.000]  сильно возрастает.
[19:00.000 --> 19:03.000]  У нас здесь, смотрите, сколько указателей.
[19:03.000 --> 19:05.000]  Invoke, putter, create, putter, destroy, putter.
[19:05.000 --> 19:08.000]  Так еще и нужен move, move-ующий оператор.
[19:08.000 --> 19:13.000]  Значит, ну, нужен еще оператор…
[19:13.000 --> 19:16.000]  Нужна еще функция, которая делает functor
[19:16.000 --> 19:17.000]  от std move от CRC.
[19:17.000 --> 19:19.000]  Это по идее еще одна.
[19:19.000 --> 19:24.000]  И у нас тогда размер самого объекта function раздувается просто неимоверно.
[19:24.000 --> 19:26.000]  Это минус.
[19:26.000 --> 19:29.000]  Но если мы посмотрим sizeof от std function,
[19:29.000 --> 19:31.000]  мы скорее всего увидим, что он небольшой.
[19:31.000 --> 19:35.000]  Там не лежит так много объектов.
[19:35.000 --> 19:42.000]  Ну вот, я не знаю, здесь где-нибудь закомментировать бы все
[19:42.000 --> 19:44.000]  и посмотреть просто std…
[19:44.000 --> 19:46.000]  Не аккомпилируется такой вот интересный или нет?
[19:46.000 --> 19:51.000]  Давайте я просто спрошу, какой размер sizeof std function, например,
[19:51.000 --> 19:56.000]  от… да хоть от того же, bool от int int.
[19:58.000 --> 20:01.000]  По коду std довольно трудно понять, какой он там.
[20:01.000 --> 20:04.000]  Там трудно.
[20:04.000 --> 20:07.000]  Господи, что я сделал.
[20:07.000 --> 20:11.000]  Вот, ну вот если я попрошу function.impl скомпилировать,
[20:11.000 --> 20:14.000]  конечно же будет куча ошибок компиляции.
[20:14.000 --> 20:16.000]  Ой, господи, боже мой.
[20:16.000 --> 20:18.000]  Ладно.
[20:18.000 --> 20:20.000]  А к чему 11?
[20:22.000 --> 20:25.000]  G++11, не C++11, а G.
[20:25.000 --> 20:27.000]  У меня версия компилятора G++11.
[20:27.000 --> 20:29.000]  Не версия языка, а версия компилятора.
[20:29.000 --> 20:31.000]  Не путайте.
[20:33.000 --> 20:36.000]  Но у меня не за inclusion function.
[20:37.000 --> 20:41.000]  Давайте за inclusion functional, да?
[20:45.000 --> 20:47.000]  32.
[20:49.000 --> 20:52.000]  Вот, размер объекта function 32.
[20:55.000 --> 20:58.000]  Я не помню, ну как?
[20:58.000 --> 21:01.000]  Я не знаю, какие именно там хранятся поинтеры.
[21:01.000 --> 21:04.000]  Ну, то есть вот какой был размер вот этого объекта,
[21:04.000 --> 21:07.000]  если бы мы реализовали его вот так?
[21:07.000 --> 21:11.000]  Кажется, что 24, да?
[21:12.000 --> 21:16.000]  А какой бы размер был, если бы мы реализовали вот так?
[21:16.000 --> 21:18.000]  Function.impl2.
[21:19.000 --> 21:22.000]  Как будто бы он равен...
[21:24.000 --> 21:26.000]  как раз...
[21:26.000 --> 21:28.000]  Ну, он равен 24.
[21:28.000 --> 21:30.000]  Это вот эти три поинтера.
[21:30.000 --> 21:32.000]  И еще buffer size char.
[21:32.000 --> 21:34.000]  Значит, это еще, видимо, 16.
[21:34.000 --> 21:38.000]  Еще у нас не хватает поинтера на move конструктор.
[21:38.000 --> 21:41.000]  Это еще 8.
[21:41.000 --> 21:43.000]  Ну, короче, много.
[21:43.000 --> 21:45.000]  48 где-то у нас было, да?
[21:45.000 --> 21:46.000]  4 еще.
[21:46.000 --> 21:48.000]  Ну, где-то 48 байт у нас при таком.
[21:48.000 --> 21:49.000]  Вот.
[21:49.000 --> 21:51.000]  Что можно сделать?
[21:51.000 --> 21:54.000]  На самом деле, скорее всего, я предполагаю,
[21:54.000 --> 21:56.000]  я сейчас не буду проверять,
[21:56.000 --> 21:59.000]  я предполагаю, что можно сделать так.
[21:59.000 --> 22:02.000]  Какая операция у нас самая...
[22:05.000 --> 22:07.000]  вот та, которая быстрой должна быть?
[22:07.000 --> 22:08.000]  На invoke.
[22:08.000 --> 22:11.000]  Самое главное, это чтобы invoke быстро делалось.
[22:11.000 --> 22:15.000]  Вот если мы invoke запрятали в таблицу виртуальных функций,
[22:15.000 --> 22:17.000]  то это очень неэффективно.
[22:17.000 --> 22:19.000]  Это каждый раз, когда мы вызываем функцию,
[22:19.000 --> 22:21.000]  а вдруг это компаратор,
[22:21.000 --> 22:23.000]  получается, каждый раз, чтобы мы ее вызвали,
[22:23.000 --> 22:25.000]  мы два прыжка по указателям делаем.
[22:25.000 --> 22:26.000]  Очень плохо.
[22:26.000 --> 22:28.000]  Давайте просто invoke будем хранить как поле.
[22:28.000 --> 22:31.000]  Прямо здесь непосредственно поинтер на него хранить.
[22:31.000 --> 22:33.000]  А остальные запрячем в структуру,
[22:33.000 --> 22:35.000]  которая будет как раз называться статической,
[22:35.000 --> 22:38.000]  вот эта вот function table для данного t,
[22:38.000 --> 22:40.000]  шаблонная для данного функтора.
[22:40.000 --> 22:43.000]  То есть у нас будет храниться просто здесь указатель
[22:43.000 --> 22:46.000]  на function table для данного функтора.
[22:46.000 --> 22:49.000]  По сути, мы делаем нечто среднее
[22:49.000 --> 22:52.000]  между этим решением и предыдущим решением.
[22:52.000 --> 22:54.000]  То есть часть функции мы прячем в table
[22:54.000 --> 22:58.000]  и там вызываем через механизм виртуальных функций.
[22:58.000 --> 23:00.000]  Ну, что значит по сути виртуальных функций?
[23:00.000 --> 23:03.000]  Мы просто храним здесь pointer
[23:03.000 --> 23:05.000]  объект той структуры,
[23:05.000 --> 23:08.000]  а в той структуре уже хранится несколько поинтеров
[23:08.000 --> 23:09.000]  на нужные нам методы.
[23:09.000 --> 23:13.000]  Но вот указатель на вызов круглых скобочек
[23:13.000 --> 23:16.000]  мы храним прямо тут, чтобы до него быстрее идти было,
[23:16.000 --> 23:18.000]  чтобы мы не прыгали два раза.
[23:18.000 --> 23:21.000]  Я думаю, что с defunction примерно так как-то и реализовано.
[23:21.000 --> 23:24.000]  Разумеется, это зависит все от компилятора
[23:24.000 --> 23:28.000]  и зависит все от версии компилятора.
[23:28.000 --> 23:30.000]  То есть вы можете самостоятельно проверить,
[23:30.000 --> 23:32.000]  как у вас реализована function в вашей версии,
[23:32.000 --> 23:35.000]  либо, конечно же, стандарт не регламентирует ничего подобного,
[23:35.000 --> 23:38.000]  он не говорит, как надо реализовать function.
[23:38.000 --> 23:39.000]  Вот.
[23:39.000 --> 23:47.000]  Но реализована она, вот, скорее всего, я думаю, так.
[23:47.000 --> 23:55.000]  Правда, был один доклад на CppCon,
[23:55.000 --> 23:57.000]  на конференции, про то, как можно...
[23:57.000 --> 23:59.000]  Ну, вот на самом деле то, что я вам рассказываю,
[23:59.000 --> 24:03.000]  это было рассказано в одной из лекций на конференции по C++
[24:03.000 --> 24:04.000]  несколько лет назад,
[24:04.000 --> 24:06.000]  а там чувак рассказывал про то,
[24:06.000 --> 24:08.000]  какие есть подходы к реализации function,
[24:08.000 --> 24:10.000]  показывал этот подход, тот подход,
[24:10.000 --> 24:12.000]  замерял время и выяснялось, что одинаково.
[24:12.000 --> 24:14.000]  Вот.
[24:14.000 --> 24:16.000]  Не помню, правда, какие он тесты делал.
[24:16.000 --> 24:18.000]  То есть как будто бы подход с виртуальными функциями
[24:18.000 --> 24:20.000]  не дает проигрыша.
[24:20.000 --> 24:24.000]  Ну, потому что, по сути, мы ровно это и сделали.
[24:24.000 --> 24:28.000]  Только переложили...
[24:30.000 --> 24:32.000]  Можно было, короче, virtual оставить,
[24:32.000 --> 24:36.000]  просто отдельно сохранить метод вызов круглых скобочек
[24:36.000 --> 24:38.000]  и его не через виртуальную таблицу вызывать,
[24:38.000 --> 24:39.000]  а напрямую.
[24:39.000 --> 24:41.000]  Можно было и через виртуальную функцию реализовать.
[24:41.000 --> 24:46.000]  Ну, в общем, почему именно в STL
[24:46.000 --> 24:49.000]  решили не использовать virtual?
[24:49.000 --> 24:51.000]  Я не знаю, почему именно этот подход,
[24:51.000 --> 24:52.000]  а не тот там выбран.
[24:52.000 --> 24:54.000]  То есть казалось бы он быстрее.
[24:54.000 --> 24:57.000]  Возможно, действительно, ну, виртуальные таблицы,
[24:57.000 --> 24:59.000]  они несут какие-то накладные расходы
[24:59.000 --> 25:01.000]  известные разработчикам компилятора,
[25:01.000 --> 25:02.000]  которые нам не очевидны.
[25:02.000 --> 25:04.000]  И в данном случае нам нужна миниатюрная версия
[25:04.000 --> 25:06.000]  виртуальной таблицы, чтобы всю виртуальную таблицу
[25:06.000 --> 25:09.000]  не создавать, с этим TypeID и прочим.
[25:09.000 --> 25:14.000]  Они написали мини свою версию конкретно для данного,
[25:14.000 --> 25:17.000]  чтобы там не было всяких дополнительных еще штуковин,
[25:17.000 --> 25:19.000]  которые, возможно, могут что-то замедлить
[25:19.000 --> 25:21.000]  в каких-то сценариях.
[25:21.000 --> 25:28.000]  Вот. Ну, короче, то, что мы обсудили, это, так сказать,
[25:28.000 --> 25:31.000]  TypeRager без виртуальных таблиц.
[25:31.000 --> 25:35.000]  Вот. По сути, сделали свою виртуальную таблицу
[25:35.000 --> 25:36.000]  своими руками.
[25:36.000 --> 25:38.000]  Вот.
[25:43.000 --> 25:45.000]  Вопросы?
[25:51.000 --> 25:55.000]  Вот. Есть еще одна проблема.
[25:57.000 --> 25:59.000]  Вот какая.
[26:01.000 --> 26:03.000]  Я вернусь вот к этой реализации,
[26:03.000 --> 26:05.000]  потому что она более полной получилась.
[26:08.000 --> 26:11.000]  Значит, вот мы здесь реализовали
[26:11.000 --> 26:13.000]  класс Function в каком-то виде.
[26:15.000 --> 26:19.000]  И у этого Function
[26:19.000 --> 26:22.000]  ну, да, не очень хорошо я реализовал,
[26:22.000 --> 26:24.000]  а тут нет конструктора копирования.
[26:24.000 --> 26:27.000]  Ну, понятно, что Function должна обладать
[26:27.000 --> 26:29.000]  всеми стандартными методами,
[26:29.000 --> 26:31.000]  которыми обладают всякие там интервью.
[26:31.000 --> 26:35.000]  То есть у Function есть конструктор копирования.
[26:35.000 --> 26:37.000]  Да, ну, давайте я его напишу, значит, Function.
[26:37.000 --> 26:41.000]  Я не буду прям реализовывать, я просто объявлю.
[26:41.000 --> 26:45.000]  Значит, есть конструктор копирования Function.
[26:45.000 --> 26:48.000]  Есть конструктор перемещения Function.
[26:48.000 --> 26:53.000]  Есть оператор присваивания Function
[26:56.000 --> 26:58.000]  от lvalue.
[26:58.000 --> 27:00.000]  Видимо, даже два.
[27:02.000 --> 27:04.000]  В смысле два?
[27:04.000 --> 27:06.000]  Ну, есть могущий оператор присваивания?
[27:06.000 --> 27:08.000]  Ну, да, да, да.
[27:08.000 --> 27:10.000]  Естественно.
[27:10.000 --> 27:12.000]  Вот. Понятно, что все эти штуки есть.
[27:12.000 --> 27:14.000]  И есть деструктор, само собой.
[27:14.000 --> 27:16.000]  Ну, правила пяти никто не отменял.
[27:16.000 --> 27:18.000]  Идеальный все, значит, все четыре эти штуковины надо сделать.
[27:18.000 --> 27:20.000]  Вот.
[27:20.000 --> 27:22.000]  Ну, и C++11.
[27:22.000 --> 27:24.000]  Собственно, вот тип Function так и выглядел.
[27:30.000 --> 27:32.000]  Значит, понятно, что здесь...
[27:36.000 --> 27:38.000]  Ну, короче, вам должно быть идейно понятно,
[27:38.000 --> 27:40.000]  как они реализованы.
[27:40.000 --> 27:42.000]  Я не буду их реализовывать.
[27:42.000 --> 27:44.000]  Это можно как упражнение сделать.
[27:44.000 --> 27:46.000]  Идейно понятно, что здесь происходит.
[27:46.000 --> 27:48.000]  Здесь мы просто создаем
[27:48.000 --> 27:50.000]  такую же штуку, как там хранится,
[27:50.000 --> 27:52.000]  со всей виртуальной таблицы копируем.
[27:52.000 --> 27:54.000]  Здесь мы, значит, move'ем, там
[27:54.000 --> 27:56.000]  оставляем на lptr, себе все забираем.
[27:56.000 --> 27:58.000]  Здесь то же самое, только первоначально
[27:58.000 --> 28:00.000]  мы уничтожаем то, что у нас лежит.
[28:02.000 --> 28:04.000]  Вот может быть кто-нибудь из вас...
[28:06.000 --> 28:08.000]  Значит, давайте сделаем тест.
[28:08.000 --> 28:10.000]  Диспозиция такая.
[28:10.000 --> 28:12.000]  Исходные данные такие.
[28:12.000 --> 28:14.000]  Вот у нас с C++11 мы реализовали
[28:14.000 --> 28:16.000]  вот так класс Function.
[28:16.000 --> 28:18.000]  То есть понятно, что здесь написано.
[28:18.000 --> 28:20.000]  Понятно, какие операции там делаются.
[28:20.000 --> 28:22.000]  Неважно у нас, через таблицу
[28:22.000 --> 28:24.000]  виртуальных функций мы реализовали
[28:24.000 --> 28:26.000]  или сами написали аналог таблиц виртуальных функций.
[28:26.000 --> 28:28.000]  Это как раз сейчас неважно.
[28:28.000 --> 28:30.000]  Мы реализовали вот такой класс
[28:30.000 --> 28:32.000]  с такими методами.
[28:32.000 --> 28:42.000]  Вот попробуйте быть умнее комитета по стандартизации.
[28:42.000 --> 28:44.000]  Что здесь...
[28:44.000 --> 28:46.000]  Я не ожидаюсь, что кто-нибудь догадается до ответа.
[28:46.000 --> 28:48.000]  Может кто-нибудь знает ответ.
[28:48.000 --> 28:50.000]  Но если кто-нибудь догадается до ответа,
[28:50.000 --> 28:52.000]  то круто, хотя вряд ли.
[28:52.000 --> 28:54.000]  Это трудно предвидеть такое.
[28:54.000 --> 28:56.000]  В общем, тут есть одна проблема,
[28:56.000 --> 28:58.000]  из-за которой этот класс Function
[28:58.000 --> 29:00.000]  оказался в некоторых сценариях очень
[29:00.000 --> 29:02.000]  ну скажем так, непригодным.
[29:02.000 --> 29:04.000]  Не для всех Functions,
[29:04.000 --> 29:06.000]  не для всех Callable объектов
[29:06.000 --> 29:08.000]  он годится.
[29:08.000 --> 29:10.000]  Просто для некоторых
[29:10.000 --> 29:12.000]  получается CE
[29:12.000 --> 29:14.000]  и ничего с этим сделать нельзя.
[29:14.000 --> 29:16.000]  И просто SD Function
[29:16.000 --> 29:18.000]  не подходит для них,
[29:18.000 --> 29:20.000]  если ее так реализовать.
[29:20.000 --> 29:22.000]  До этого вроде было много проблем
[29:22.000 --> 29:24.000]  с указателями на члены всякие.
[29:24.000 --> 29:26.000]  Не-не, это не связано с указателями на члены.
[29:26.000 --> 29:28.000]  Это не связано с указателями на члены.
[29:28.000 --> 29:30.000]  Не-не, это не связано с указателями на члены.
[29:30.000 --> 29:32.000]  С указателями на члены мы как раз решили проблему,
[29:32.000 --> 29:34.000]  мы написали специальный CD Invoke
[29:34.000 --> 29:36.000]  и все нормально.
[29:36.000 --> 29:38.000]  Нет, для самых нормальных, для вот обычных
[29:38.000 --> 29:40.000]  полноценных объектов.
[29:40.000 --> 29:42.000]  Статический метод у класса?
[29:42.000 --> 29:44.000]  Статический метод у класса?
[29:44.000 --> 29:46.000]  А что, в чем проблема с ним?
[29:46.000 --> 29:48.000]  Не понимаю.
[29:48.000 --> 29:52.000]  А что с исключением будет?
[29:52.000 --> 29:54.000]  Все нормально?
[29:54.000 --> 29:56.000]  Сейчас, что у нас с исключением будет?
[29:56.000 --> 29:58.000]  Все нормально?
[29:58.000 --> 30:00.000]  Хороший вопрос.
[30:00.000 --> 30:02.000]  И у нас понятно,
[30:02.000 --> 30:04.000]  что с ExceptionSafety умирает,
[30:04.000 --> 30:06.000]  но вот как бы, если...
[30:06.000 --> 30:08.000]  У нас нет ExceptionSafety, да,
[30:08.000 --> 30:10.000]  А что у нас может быть не так
[30:10.000 --> 30:12.000]  с ExceptionSafety?
[30:12.000 --> 30:14.000]  Когда мы копируем...
[30:14.000 --> 30:16.000]  Ну, это сейчас был разговор
[30:16.000 --> 30:18.700]  Это сейчас был разговор не про ExceptionSafety.
[30:18.700 --> 30:22.700]  Наверное, здесь надо добавить try-catch в каких-то местах, чтобы была ExceptionSafety.
[30:22.700 --> 30:26.080]  То есть, если у нас Exception происходит во время колла, во время вызова,
[30:26.080 --> 30:29.280]  то все нормально, оно просто так и летит наверх.
[30:29.280 --> 30:33.240]  При уничтожении, в смысле, при момент, когда мы делаем дестрой.
[30:33.240 --> 30:38.280]  Вот. Если у нас произошло Exception во время создания,
[30:41.080 --> 30:44.360]  во время того, как мы делаем присваивание,
[30:45.120 --> 30:46.120]  то...
[30:46.120 --> 30:48.120]  Тут как-то это тривиально поддерживается все.
[30:50.120 --> 30:52.120]  Ну да, кажется, что это несложно.
[30:52.120 --> 30:54.120]  То есть, типа, ну...
[30:59.120 --> 31:04.120]  Кстати, хороший вопрос про исключение во время присваивания function.
[31:04.120 --> 31:10.120]  Я, если честно, даже не помню, как там, что там написано в стандарте.
[31:10.120 --> 31:12.120]  Давайте почитаем.
[31:12.880 --> 31:14.880]  Std function.
[31:14.880 --> 31:16.880]  Оператор присваивания, допустим.
[31:27.880 --> 31:29.880]  На себе периференс даже не написано.
[31:32.880 --> 31:34.880]  ExceptionSafety.
[31:34.880 --> 31:38.880]  Ну, то есть, вопрос в том, что будет, если мы уже уничтожили старый объект
[31:38.880 --> 31:40.880]  и положили новый.
[31:41.640 --> 31:43.640]  М-м-м...
[31:54.640 --> 31:56.640]  Слушайте, не знаю.
[31:56.640 --> 32:00.640]  Ну, короче, вопрос хороший, но не хочу сейчас на него тратить время.
[32:00.640 --> 32:02.640]  В общем, я не знаю.
[32:02.640 --> 32:04.640]  В общем, я не знаю.
[32:04.640 --> 32:06.640]  В общем, я не знаю.
[32:06.640 --> 32:08.640]  В общем, я не знаю.
[32:08.640 --> 32:10.640]  Не хочу сейчас на него тратить время.
[32:10.640 --> 32:12.640]  В общем, понятно, что это можно поддержать.
[32:12.640 --> 32:15.640]  Поддерживать ли это function, я не знаю, если честно.
[32:15.640 --> 32:19.640]  Я не вижу на, типа, периференс слов, что оно exceptionSafe.
[32:19.640 --> 32:22.640]  Возможно, они забили на поддержку exceptionSafety
[32:22.640 --> 32:24.640]  в присваивании function одного другому.
[32:29.640 --> 32:31.640]  Типа...
[32:34.640 --> 32:37.640]  Кстати, не очень понятно, как это поддержать, на самом-то деле.
[32:37.640 --> 32:39.640]  Потому что буфер-то один.
[32:39.640 --> 32:41.640]  Если мы положили на этот же буфер...
[32:43.640 --> 32:46.640]  Ну, у нас же исключения во время копирования происходят.
[32:46.640 --> 32:48.640]  Может произойти, да.
[32:48.640 --> 32:52.640]  Если мы используем один и тот же буфер,
[32:52.640 --> 32:56.640]  то кажется, что мы не можем...
[32:56.640 --> 32:59.640]  Ну, если мы уничтожили старую функцию
[33:01.640 --> 33:04.640]  и начали класть новую, и произошел exception,
[33:04.640 --> 33:06.640]  то, кажется, мы никак уже старую не вернем.
[33:06.640 --> 33:08.640]  Потому что нам нужно на тот же буфер положить новую.
[33:08.640 --> 33:10.640]  И что мы тогда будем делать?
[33:10.640 --> 33:12.640]  Мы же не можем старую заново создать.
[33:12.640 --> 33:14.640]  И мы не можем создать второй буфер, в который положить новую,
[33:14.640 --> 33:17.640]  потому что потом все равно копировать в другой буфер ее придется.
[33:17.640 --> 33:20.640]  То есть, как минимум, кажется, строгую гарантию исключения
[33:20.640 --> 33:21.640]  мы не можем поддержать.
[33:21.640 --> 33:23.640]  Наверное, можно поддержать базовую.
[33:23.640 --> 33:25.640]  То есть, мы уничтожили старую штуку,
[33:25.640 --> 33:27.640]  попробовали создать новую.
[33:27.640 --> 33:29.640]  Если не вышло, то мы просто делаем...
[33:29.640 --> 33:31.640]  Считаем, что у нас nullPTR,
[33:31.640 --> 33:34.640]  и как бы, ну, остаемся в корректном состоянии,
[33:34.640 --> 33:36.640]  что в нас ничего не лежит.
[33:36.640 --> 33:38.640]  Мы не смогли создать функцию по...
[33:38.640 --> 33:40.640]  Из истой и, значит, просто null...
[33:40.640 --> 33:42.640]  Ну, остаемся в пустом состоянии.
[33:42.640 --> 33:44.640]  И протидываем exception дальше.
[33:44.640 --> 33:46.640]  Кажется, что так оно и должно работать,
[33:46.640 --> 33:48.640]  потому что, ну, по крайней мере,
[33:48.640 --> 33:50.640]  в SD-варианте так, кстати, работает.
[33:50.640 --> 33:52.640]  То есть, там базовая гарантия безопасности исключения,
[33:52.640 --> 33:53.640]  а не строгая.
[33:53.640 --> 33:55.640]  Потому что строгую вообще непонятно так соблюсти.
[33:55.640 --> 33:57.640]  Вот базовую можно.
[33:57.640 --> 33:59.640]  И, наверное, базовая так и есть.
[33:59.640 --> 34:01.640]  Правда, тут не написано почему-то.
[34:01.640 --> 34:03.640]  Но, окей, это...
[34:05.640 --> 34:07.640]  Это еще один интересный вопрос,
[34:07.640 --> 34:09.640]  но все-таки я...
[34:09.640 --> 34:11.640]  Есть еще одна...
[34:11.640 --> 34:13.640]  Еще проблема, даже, возможно, более серьезная.
[34:13.640 --> 34:15.640]  Для некоторых...
[34:15.640 --> 34:17.640]  Для некоторых объектов callable
[34:17.640 --> 34:19.640]  этот класс просто не применим вообще.
[34:19.640 --> 34:21.640]  Не то что там иногда,
[34:21.640 --> 34:23.640]  а просто не скомпилируется.
[34:23.640 --> 34:25.640]  А лямбда функция?
[34:25.640 --> 34:27.640]  Да нет, для лямбда функции тоже применим,
[34:27.640 --> 34:29.640]  но не для всех.
[34:29.640 --> 34:31.640]  Для некоторого подмножества лямбда функции
[34:31.640 --> 34:33.640]  он не применим.
[34:33.640 --> 34:35.640]  И для некоторого подмножества других объектов.
[34:35.640 --> 34:37.640]  Это не связано с тем,
[34:37.640 --> 34:39.640]  лямбда это функция или не лямбда функция.
[34:39.640 --> 34:41.640]  Короче...
[34:41.640 --> 34:43.640]  А если мы...
[34:43.640 --> 34:45.640]  А если мы хотим, чтобы объект
[34:45.640 --> 34:47.640]  можно было вызывать только на определенное количество раз?
[34:47.640 --> 34:49.640]  В смысле, в нем какой-нибудь счетчик,
[34:49.640 --> 34:51.640]  но там придется мутить с mutable,
[34:51.640 --> 34:53.640]  чтобы это адекватно работало?
[34:53.640 --> 34:55.640]  Вроде бы.
[34:55.640 --> 34:57.640]  Ну, кажется, что...
[34:57.640 --> 34:59.640]  Кажется, что это, опять же,
[34:59.640 --> 35:01.640]  не проблема, потому что...
[35:01.640 --> 35:03.640]  Может быть, качинивать...
[35:03.640 --> 35:05.640]  Конструктор считается функцией?
[35:07.640 --> 35:09.640]  Конструктор...
[35:09.640 --> 35:11.640]  функции... чего?
[35:11.640 --> 35:13.640]  Конструктора класса, не знаю...
[35:13.640 --> 35:15.640]  Нет, у тебя должен быть тип
[35:15.640 --> 35:17.640]  какой-то, callable.
[35:17.640 --> 35:19.640]  Что такое callable? Я не понимаю.
[35:19.640 --> 35:21.640]  Callable либо указатель на функцию,
[35:21.640 --> 35:23.640]  либо...
[35:23.640 --> 35:25.640]  С указателями на функцию нет никаких проблем.
[35:25.640 --> 35:27.640]  Если ты хочешь конструктора класса
[35:27.640 --> 35:29.640]  интерпретировать как callable объект,
[35:29.640 --> 35:31.640]  кажется, ты можешь указатель
[35:31.640 --> 35:33.640]  на конструктор. Можешь ли ты
[35:33.640 --> 35:35.640]  сделать?
[35:35.640 --> 35:37.640]  Я даже не знаю, что мне кажется...
[35:37.640 --> 35:39.640]  Нет.
[35:39.640 --> 35:41.640]  А может, ты можешь?
[35:41.640 --> 35:43.640]  Блин, это хороший вопрос. Можно ли взять указатель
[35:43.640 --> 35:45.640]  на конструктор как на функцию?
[35:45.640 --> 35:47.640]  Но в любом случае, это будет указатель на функцию, обычно сишный,
[35:47.640 --> 35:49.640]  и это не проблема. Ладно, в общем...
[35:49.640 --> 35:51.640]  Ну, никто не догадался, в общем, до этого трудно догадаться.
[35:51.640 --> 35:53.640]  Ну, да.
[35:53.640 --> 35:55.640]  Если у нас
[35:55.640 --> 35:57.640]  шаблонная функция
[35:57.640 --> 35:59.640]  от пакета,
[35:59.640 --> 36:01.640]  то она же будет
[36:01.640 --> 36:03.640]  в итоге компилятором
[36:03.640 --> 36:05.640]  как несколько функций просто рассматривать, да?
[36:05.640 --> 36:07.640]  Почему? Нет?
[36:07.640 --> 36:09.640]  Шаблонная функция от пакета?
[36:09.640 --> 36:11.640]  Ну, вот...
[36:11.640 --> 36:13.640]  Ну, если ты ее вызываешь, подожди,
[36:13.640 --> 36:15.640]  если ты ее вызываешь с разными типами аргументов,
[36:15.640 --> 36:17.640]  то да,
[36:17.640 --> 36:19.640]  она рассматривается, ну, под каждый
[36:19.640 --> 36:21.640]  вызов генерируется своя версия
[36:21.640 --> 36:23.640]  шаблона. Ну, да.
[36:23.640 --> 36:25.640]  Ну, и по итогу, ну, собственно,
[36:25.640 --> 36:27.640]  то есть никакой проблемы с такими функциями
[36:27.640 --> 36:29.640]  тоже не будет, да?
[36:29.640 --> 36:31.640]  Ну, ты, чтобы взять указатель на нее,
[36:31.640 --> 36:33.640]  ты должен конкретизировать типы.
[36:33.640 --> 36:35.640]  Ты же не можешь взять указатель на...
[36:35.640 --> 36:37.640]  Ну, да. Ну, поэтому ты просто берешь указатель на функцию,
[36:37.640 --> 36:39.640]  уже конкретизируя типы,
[36:39.640 --> 36:41.640]  и поэтому просто хранишь ее как панцирный планет.
[36:41.640 --> 36:43.640]  Короче, ответ вот какой.
[36:43.640 --> 36:45.640]  Это не будет компилироваться для объектов,
[36:45.640 --> 36:47.640]  которые только movable.
[36:47.640 --> 36:49.640]  В частности, например,
[36:49.640 --> 36:51.640]  если у нас в функцию захвачен какой-нибудь унит по tr,
[36:51.640 --> 36:53.640]  то std function в такую
[36:53.640 --> 36:55.640]  лямду
[36:55.640 --> 36:57.640]  в std function вы уже не положите.
[36:59.640 --> 37:01.640]  Давайте я...
[37:01.640 --> 37:03.640]  Примонстрирую. Ну, смотрите сейчас.
[37:07.640 --> 37:09.640]  Значит, я это закомментирую.
[37:09.640 --> 37:11.640]  Вот, смотрите, давайте у меня будет какая-нибудь лямба.
[37:13.640 --> 37:15.640]  Ну, значит, да.
[37:15.640 --> 37:17.640]  Значит,
[37:17.640 --> 37:19.640]  f равно
[37:19.640 --> 37:21.640]  after move only
[37:25.640 --> 37:27.640]  равно...
[37:27.640 --> 37:29.640]  Ну, вот у меня будет std unique ptr,
[37:29.640 --> 37:31.640]  точнее, after
[37:31.640 --> 37:33.640]  ptr равно
[37:33.640 --> 37:35.640]  std make
[37:35.640 --> 37:37.640]  unique
[37:37.640 --> 37:39.640]  от int
[37:39.640 --> 37:41.640]  от
[37:41.640 --> 37:43.640]  pt.
[37:43.640 --> 37:45.640]  И я скажу, значит,
[37:45.640 --> 37:47.640]  ptr равно std move
[37:47.640 --> 37:49.640]  от ptr.
[37:49.640 --> 37:51.640]  А что она
[37:51.640 --> 37:53.640]  будет принимать? Ну, не знаю.
[37:53.640 --> 37:55.640]  Ничего.
[37:55.640 --> 37:57.640]  Возвращать int и, значит,
[37:57.640 --> 37:59.640]  return звездочка
[37:59.640 --> 38:01.640]  ptr. Ну, какая-то дурацкая функция,
[38:01.640 --> 38:03.640]  просто которая заменовывает
[38:03.640 --> 38:05.640]  pointer. Теперь я хочу сказать
[38:05.640 --> 38:07.640]  std function
[38:07.640 --> 38:09.640]  от decal type
[38:11.640 --> 38:13.640]  от...
[38:13.640 --> 38:15.640]  Нет, std function
[38:15.640 --> 38:17.640]  с параметрами, значит,
[38:17.640 --> 38:19.640]  int круглые скобочки.
[38:19.640 --> 38:21.640]  Функция, которая принимает...
[38:21.640 --> 38:23.640]  Ничего не принимает, возвращает int.
[38:25.640 --> 38:27.640]  f2 равно
[38:27.640 --> 38:29.640]  std move
[38:29.640 --> 38:31.640]  от move only.
[38:31.640 --> 38:33.640]  Почему std move? Потому что копированием
[38:33.640 --> 38:35.640]  я, конечно же, не могу сделать.
[38:35.640 --> 38:37.640]  Ну, вот давайте попробуем так сделать.
[38:43.640 --> 38:45.640]  Я не заincluded memory, кажется.
[38:51.640 --> 38:53.640]  Так, попробуем.
[38:57.640 --> 38:59.640]  Что ж такое? Что на этот раз?
[38:59.640 --> 39:01.640]  А, потому что здесь я не поставил
[39:01.640 --> 39:03.640]  точку запятой.
[39:05.640 --> 39:07.640]  Вот.
[39:07.640 --> 39:09.640]  Вот случилось то, что я
[39:09.640 --> 39:11.640]  и говорил.
[39:11.640 --> 39:13.640]  Я попробовал в std function положить
[39:13.640 --> 39:15.640]  move'ом положить.
[39:15.640 --> 39:17.640]  Это ведь я все правильно сделал.
[39:17.640 --> 39:19.640]  Если бы я копированием клал, я бы вообще...
[39:19.640 --> 39:21.640]  Но я move'ом положил в...
[39:21.640 --> 39:23.640]  Хотел положить в f2
[39:23.640 --> 39:25.640]  сохранить вот этот объект.
[39:25.640 --> 39:27.640]  И не смог. Почему?
[39:27.640 --> 39:29.640]  А потому что
[39:31.640 --> 39:33.640]  класс инстанцируется
[39:33.640 --> 39:35.640]  с шаблонным параметром,
[39:35.640 --> 39:37.640]  как у меня, а в нем есть конструктор копирования.
[39:37.640 --> 39:39.640]  В конструкторе копирования
[39:39.640 --> 39:41.640]  function
[39:41.640 --> 39:43.640]  у меня инстанцируется function
[39:43.640 --> 39:45.640]  с нужными шаблонными параметрами.
[39:45.640 --> 39:47.640]  И в частности, там есть конструктор
[39:47.640 --> 39:49.640]  копирования.
[39:49.640 --> 39:51.640]  Конструктор копирования, он уже не шаблонный.
[39:51.640 --> 39:53.640]  У него уже подставлены шаблонные параметры,
[39:53.640 --> 39:55.640]  как у меня, как у класса function.
[39:55.640 --> 39:57.640]  И, значит, инстанцируется
[39:57.640 --> 39:59.640]  тело сразу, потому что там
[39:59.640 --> 40:01.640]  еще пока нету переменных шаблонных параметров.
[40:03.640 --> 40:05.640]  И в этом конструкторе копирования
[40:05.640 --> 40:07.640]  есть вот такая строчка.
[40:09.640 --> 40:11.640]  Потому что
[40:13.640 --> 40:15.640]  конструктор копирования, когда компилируется,
[40:15.640 --> 40:17.640]  он должен уметь пытаться создавать
[40:17.640 --> 40:19.640]  из
[40:21.640 --> 40:23.640]  объекта функтора другой объект функтора.
[40:23.640 --> 40:25.640]  Я не пытаюсь вызывать
[40:25.640 --> 40:27.640]  конструктор копирования.
[40:27.640 --> 40:29.640]  Но он таки инстанцируется,
[40:29.640 --> 40:31.640]  а значит, он пытается
[40:31.640 --> 40:33.640]  компилироваться.
[40:33.640 --> 40:35.640]  И это не работает.
[40:35.640 --> 40:37.640]  Сейчас у нас лямбда
[40:37.640 --> 40:39.640]  move only,
[40:39.640 --> 40:41.640]  потому что у нее есть глобальная
[40:41.640 --> 40:43.640]  захваченная переменная
[40:43.640 --> 40:45.640]  move only.
[40:45.640 --> 40:47.640]  У нее есть поле,
[40:47.640 --> 40:49.640]  которое не обладает
[40:49.640 --> 40:51.640]  конструктором копирования.
[40:51.640 --> 40:53.640]  Значит, и вся лямбда,
[40:53.640 --> 40:55.640]  только мобильная,
[40:55.640 --> 40:57.640]  некопируемая.
[40:57.640 --> 40:59.640]  Если мы пытаемся ее положить в...
[40:59.640 --> 41:01.640]  Я могу и функциональный класс свой создать
[41:01.640 --> 41:03.640]  без лямбды такой.
[41:03.640 --> 41:05.640]  Но если положить ее в std function,
[41:05.640 --> 41:07.640]  у меня ничего не получается.
[41:07.640 --> 41:09.640]  Даже move я ее пытаюсь положить.
[41:09.640 --> 41:11.640]  Потому что функцион с такими параметрами
[41:11.640 --> 41:13.640]  старается инстанцировать, пытается создать
[41:13.640 --> 41:15.640]  конструктор копирования себе,
[41:15.640 --> 41:17.640]  а его не может создать.
[41:17.640 --> 41:19.640]  Поэтому вся функцион отваливается.
[41:19.640 --> 41:21.640]  Это недостаток класса function.
[41:21.640 --> 41:23.640]  И как его исправить,
[41:23.640 --> 41:25.640]  не очень понятно.
[41:25.640 --> 41:27.640]  Да.
[41:27.640 --> 41:29.640]  Где он конкретно пытается создать
[41:29.640 --> 41:31.640]  конструктор копирования?
[41:31.640 --> 41:33.640]  Он пытается создать конструктор копирования
[41:33.640 --> 41:35.640]  от соответствующих перемен.
[41:35.640 --> 41:37.640]  Он пытается компилировать код класса function
[41:37.640 --> 41:39.640]  с подставленными типами int
[41:39.640 --> 41:41.640]  круглой скобочки.
[41:41.640 --> 41:43.640]  В этом классе function
[41:43.640 --> 41:45.640]  есть вот такой вот function
[41:45.640 --> 41:47.640]  от const function персан,
[41:47.640 --> 41:49.640]  в котором написано
[41:49.640 --> 41:51.640]  скомпируй функцию.
[41:51.640 --> 41:53.640]  Там есть конструктор копирования.
[41:53.640 --> 41:55.640]  Он не копирует переменные,
[41:55.640 --> 41:57.640]  а функция сама становится понятна.
[41:57.640 --> 41:59.640]  Конечно, он создает новый объект function
[41:59.640 --> 42:01.640]  а для этого он копирует объект
[42:01.640 --> 42:03.640]  функтора.
[42:07.640 --> 42:09.640]  А нельзя просто
[42:09.640 --> 42:11.640]  как-нибудь сказать, что это
[42:11.640 --> 42:13.640]  лямбда будет просто сказать,
[42:13.640 --> 42:15.640]  что все функции такого вида просто теперь не могут
[42:15.640 --> 42:17.640]  а еще и копируются.
[42:17.640 --> 42:19.640]  Говорить, что если вы делаете что-то не так,
[42:19.640 --> 42:21.640]  будет не так.
[42:21.640 --> 42:23.640]  Чего сказать надо?
[42:23.640 --> 42:25.640]  Заглушку поставить.
[42:25.640 --> 42:27.640]  Да, заглушку. Именно конкретно такой случай,
[42:27.640 --> 42:29.640]  что значит заглушку?
[42:29.640 --> 42:31.640]  Что написать надо и где?
[42:31.640 --> 42:33.640]  Ну как с привылзами виртуальных функций,
[42:33.640 --> 42:35.640]  чисто абстрактных pure virtual,
[42:35.640 --> 42:37.640]  там их можем вырывать, но потом заглушка.
[42:37.640 --> 42:39.640]  А или сейчас?
[42:39.640 --> 42:41.640]  Не можем, да.
[42:41.640 --> 42:43.640]  Не понимаю.
[42:43.640 --> 42:45.640]  Можем ли мы каким-то образом
[42:45.640 --> 42:47.640]  изменить категорию функции
[42:47.640 --> 42:49.640]  как не only move?
[42:49.640 --> 42:51.640]  Безыри интерплеть кастик,
[42:51.640 --> 42:53.640]  к чему-то там вообще волшебно, хоть и к самой себе.
[42:53.640 --> 42:55.640]  Я все еще не понимаю,
[42:55.640 --> 42:57.640]  где именно и что вы предлагаете написать.
[43:01.640 --> 43:03.640]  Что должно быть написано в конструкторе
[43:03.640 --> 43:05.640]  копирования вот этой вот function?
[43:05.640 --> 43:07.640]  Он же должен быть.
[43:07.640 --> 43:09.640]  Что в нем должно быть написано?
[43:09.640 --> 43:11.640]  Если его не будет вообще,
[43:11.640 --> 43:13.640]  то это значит, что любой объект
[43:13.640 --> 43:15.640]  function будет некопируемым.
[43:15.640 --> 43:17.640]  Не очень понятно, что у функции
[43:17.640 --> 43:19.640]  конкретно копируются
[43:19.640 --> 43:21.640]  и почему нельзя.
[43:21.640 --> 43:23.640]  У нас функция просто в какой-то момент
[43:23.640 --> 43:25.640]  из-за того, что мы...
[43:25.640 --> 43:27.640]  Ну, например, если лямбами что-то захватили,
[43:27.640 --> 43:29.640]  а становится внезапно
[43:29.640 --> 43:31.640]  некопирующейся просто
[43:31.640 --> 43:33.640]  из-за того, что мы захватили что-то плохое.
[43:33.640 --> 43:35.640]  Вы про лямбду забудьте. У нас объект
[43:35.640 --> 43:37.640]  функтора есть. Он может быть чем угодно,
[43:37.640 --> 43:39.640]  не обязательно лямбой. Это может быть bind expression
[43:39.640 --> 43:41.640]  или это может быть просто обычный класс.
[43:41.640 --> 43:43.640]  У нас объект функтора.
[43:43.640 --> 43:45.640]  И он некопируемый.
[43:45.640 --> 43:47.640]  Function — это класс, который хранит в себе объект функтора
[43:47.640 --> 43:49.640]  и динамически умеет
[43:49.640 --> 43:51.640]  подменять его на объект другого
[43:51.640 --> 43:53.640]  типа с сохранением сигнатуры
[43:53.640 --> 43:55.640]  оператора вызова.
[43:55.640 --> 43:57.640]  Вот мы решили положить в Function объект функтора,
[43:57.640 --> 43:59.640]  который некопируемым оказался.
[43:59.640 --> 44:01.640]  Тогда у нас некопилируется конструктор копирования Function.
[44:01.640 --> 44:03.640]  Что делать?
[44:03.640 --> 44:05.640]  Можно вопрос?
[44:05.640 --> 44:07.640]  Вот мы когда-то обсуждали, но не очень подробно,
[44:07.640 --> 44:09.640]  что шаблон может не полностью
[44:09.640 --> 44:11.640]  создаваться.
[44:11.640 --> 44:13.640]  И почему
[44:13.640 --> 44:15.640]  это здесь не происходит?
[44:15.640 --> 44:17.640]  То есть мы же не воспользовались нигде
[44:17.640 --> 44:19.640]  копированием Function.
[44:19.640 --> 44:21.640]  А если мы пользовались до того,
[44:21.640 --> 44:23.640]  как мы его присвоили?
[44:23.640 --> 44:25.640]  У нас, видимо, не шаблон.
[44:25.640 --> 44:27.640]  У нас подставился шаблон.
[44:27.640 --> 44:29.640]  Вот этот метод не шаблонный.
[44:29.640 --> 44:31.640]  У нас класс шаблонный.
[44:35.640 --> 44:37.640]  Если у меня есть вот такой метод,
[44:37.640 --> 44:39.640]  он шаблонный сам по себе.
[44:39.640 --> 44:41.640]  И вот этот код
[44:41.640 --> 44:43.640]  он не будет...
[44:43.640 --> 44:45.640]  Тут и в constexpr
[44:45.640 --> 44:47.640]  это скорее всего все равно будет.
[44:47.640 --> 44:49.640]  Когда я инстанцировал Function
[44:49.640 --> 44:51.640]  с каким-то шаблонным параметром,
[44:51.640 --> 44:53.640]  вот тело этого метода еще не инстанцировалось.
[44:53.640 --> 44:55.640]  Потому что шаблонный параметр класса я зафиксировал,
[44:55.640 --> 44:57.640]  а шаблонный параметр этого я не зафиксировал.
[44:57.640 --> 44:59.640]  И он пока не подставляет
[44:59.640 --> 45:01.640]  сюда никакой фактор.
[45:01.640 --> 45:03.640]  Когда я начну Function
[45:03.640 --> 45:05.640]  от данного шаблонного фактора инстанцировать,
[45:05.640 --> 45:07.640]  он уже сюда подставит фактор
[45:07.640 --> 45:09.640]  и будет говорить, что можно или нельзя.
[45:09.640 --> 45:11.640]  Но здесь шаблонные параметры
[45:11.640 --> 45:13.640]  этой штуки они такие же,
[45:13.640 --> 45:15.640]  как шаблонные параметры самого класса Function.
[45:15.640 --> 45:17.640]  Когда я инстанцировал Function
[45:17.640 --> 45:19.640]  с какими-то типами,
[45:19.640 --> 45:21.640]  компилятор уже подставил эти типы
[45:21.640 --> 45:23.640]  в том числе в тело вот этого конструктора.
[45:23.640 --> 45:25.640]  Сейчас, тело он не генерируется.
[45:25.640 --> 45:27.640]  Он генерируется как бы объявления, да?
[45:27.640 --> 45:29.640]  Но само тело не генерируется.
[45:29.640 --> 45:31.640]  Генерирует уже,
[45:31.640 --> 45:33.640]  потому что я подставил...
[45:33.640 --> 45:35.640]  Темплейтный же параметр.
[45:35.640 --> 45:37.640]  Это параметр класса,
[45:37.640 --> 45:39.640]  а не метода.
[45:39.640 --> 45:41.640]  Если я подставил
[45:41.640 --> 45:43.640]  шаблонные параметры в класс,
[45:43.640 --> 45:45.640]  то весь код,
[45:45.640 --> 45:47.640]  где написаны эти шаблонные параметры,
[45:47.640 --> 45:49.640]  он их уже зафиксировал.
[45:49.640 --> 45:51.640]  Конструктор не шаблонный сам по себе.
[45:53.640 --> 45:55.640]  У меня не генерировались
[45:55.640 --> 45:57.640]  некоторые методы, которые я не вызывал
[45:57.640 --> 45:59.640]  в шаблонном классе,
[45:59.640 --> 46:01.640]  но сами они шаблонные.
[46:01.640 --> 46:03.640]  Хотя в них было SE, но ничего страшного.
[46:03.640 --> 46:05.640]  Чего еще раз?
[46:05.640 --> 46:07.640]  Какие методы?
[46:07.640 --> 46:09.640]  Почему ты говоришь SE все еще?
[46:09.640 --> 46:11.640]  Говори, пожалуйста, CE, я не могу это слышать.
[46:11.640 --> 46:13.640]  Но это не буква C,
[46:13.640 --> 46:15.640]  а не S.
[46:15.640 --> 46:17.640]  Я описал шаблонный класс.
[46:17.640 --> 46:19.640]  Внутри у меня был метод,
[46:19.640 --> 46:21.640]  у которого в теле было CE.
[46:21.640 --> 46:23.640]  Но при этом я его не вызывал,
[46:23.640 --> 46:25.640]  поэтому CE не происходило
[46:25.640 --> 46:27.640]  и все работало.
[46:27.640 --> 46:29.640]  А метод был шаблонный или нет?
[46:29.640 --> 46:31.640]  Сам метод не шаблонный,
[46:31.640 --> 46:33.640]  класс шаблонный.
[46:35.640 --> 46:37.640]  Вот это странно,
[46:37.640 --> 46:39.640]  потому что кажется, что должно все равно.
[46:41.640 --> 46:43.640]  Не знаю.
[46:43.640 --> 46:45.640]  Если у тебя есть пример такого кода,
[46:45.640 --> 46:47.640]  то пришли его, пожалуйста.
[46:47.640 --> 46:49.640]  Так или иначе,
[46:49.640 --> 46:51.640]  по какой-то причине компилятор...
[47:01.640 --> 47:03.640]  В случае с конструктором копирования
[47:03.640 --> 47:05.640]  вот это так работает.
[47:05.640 --> 47:07.640]  Может быть, компилятор умеет иногда
[47:07.640 --> 47:09.640]  избегать такой подстановки,
[47:09.640 --> 47:11.640]  а он ее не умеет избегать.
[47:13.640 --> 47:15.640]  Короче, если метод не шаблонный,
[47:15.640 --> 47:17.640]  когда вы подставите в нее
[47:17.640 --> 47:19.640]  в класс шаблонные типы,
[47:21.640 --> 47:23.640]  вы, вообще говоря, нарветесь на CE
[47:23.640 --> 47:25.640]  во всех местах, где вы пытаетесь
[47:25.640 --> 47:27.640]  от этих типов уже вызывать методы.
[47:29.640 --> 47:31.640]  А мы можем сделать конструктор
[47:31.640 --> 47:33.640]  копирования шаблонным,
[47:33.640 --> 47:35.640]  чтобы его просто закостряли?
[47:35.640 --> 47:37.640]  Нет, если сделаешь что-то шаблонным,
[47:37.640 --> 47:39.640]  в случае с конструктором копирования по определению.
[47:45.640 --> 47:47.640]  Мы не могли теоретически сделать
[47:47.640 --> 47:49.640]  какую-нибудь специализацию
[47:49.640 --> 47:51.640]  function в плане
[47:51.640 --> 47:53.640]  дополнительных темплетных параметров
[47:53.640 --> 47:55.640]  туда прикрутить,
[47:57.640 --> 47:59.640]  и сделать там такое же взаимоотношение,
[47:59.640 --> 48:01.640]  как мы с стераторами делали
[48:01.640 --> 48:03.640]  для константного и неконстантного.
[48:03.640 --> 48:05.640]  То есть сделать специализацию
[48:05.640 --> 48:07.640]  для...
[48:07.640 --> 48:09.640]  сделать какой-нибудь
[48:09.640 --> 48:11.640]  inner function?
[48:11.640 --> 48:13.640]  Я вам просто скажу,
[48:13.640 --> 48:15.640]  что сделано в стандартной библиотеке для этого.
[48:15.640 --> 48:17.640]  Проблему осознали
[48:17.640 --> 48:19.640]  не сразу.
[48:19.640 --> 48:21.640]  Все преступники 11 написали вот так
[48:21.640 --> 48:23.640]  и не сразу осознали проблему.
[48:23.640 --> 48:25.640]  Потом ее осознали, но было уже поздно.
[48:25.640 --> 48:27.640]  Короче,
[48:27.640 --> 48:29.640]  есть вот такой замечательный класс.
[48:29.640 --> 48:31.640]  Правда, он
[48:31.640 --> 48:33.640]  C++23 только будет
[48:33.640 --> 48:35.640]  добавлен, потому что
[48:35.640 --> 48:37.640]  до сих пор еще не успели.
[48:37.640 --> 48:39.640]  Типа function without copy?
[48:39.640 --> 48:41.640]  Значит, move only function
[48:41.640 --> 48:43.640]  это все как function,
[48:43.640 --> 48:45.640]  только без конструктора копирования.
[48:45.640 --> 48:47.640]  Если вы хотите
[48:47.640 --> 48:49.640]  в function класть
[48:49.640 --> 48:51.640]  объекты, которые не копируются,
[48:51.640 --> 48:53.640]  то используйте move only function.
[48:53.640 --> 48:55.640]  На самом деле
[48:55.640 --> 48:57.640]  это очень редкий случай,
[48:57.640 --> 48:59.640]  когда вам нужно копировать function.
[48:59.640 --> 49:01.640]  Если вдуматься,
[49:01.640 --> 49:03.640]  то становится понятно, что это очень редкая операция.
[49:03.640 --> 49:05.640]  Зачем вам копировать функциональный объект?
[49:05.640 --> 49:07.640]  Наиболее часто вам нужно move
[49:07.640 --> 49:09.640]  функциональный объект.
[49:09.640 --> 49:11.640]  Если у вас есть функциональный объект
[49:11.640 --> 49:13.640]  реально, не тривиальный, с какими-то данными,
[49:13.640 --> 49:15.640]  то, как правило, вам эти данные нужны
[49:15.640 --> 49:17.640]  для вызова функции.
[49:17.640 --> 49:19.640]  Один раз вам не нужно
[49:19.640 --> 49:21.640]  создавать много копий этих данных,
[49:21.640 --> 49:23.640]  чтобы вызывать функцию.
[49:23.640 --> 49:25.640]  Где вы вызываете, там вам эти данные нужны.
[49:25.640 --> 49:27.640]  Вам вряд ли понадобится
[49:27.640 --> 49:29.640]  дублировать данные для вызова функции.
[49:29.640 --> 49:31.640]  Может быть и понадобится, но редко.
[49:31.640 --> 49:33.640]  Короче,
[49:33.640 --> 49:35.640]  на самом деле
[49:35.640 --> 49:37.640]  наиболее часто
[49:37.640 --> 49:39.640]  функциональные объекты именно move
[49:39.640 --> 49:41.640]  туда, где они нужны, вместе с данными.
[49:41.640 --> 49:43.640]  Например, есть стандартный пример,
[49:43.640 --> 49:45.640]  когда у вас будет многопоточка,
[49:45.640 --> 49:47.640]  вам, может быть, нужно взять
[49:47.640 --> 49:49.640]  функциональный объект и положить его в какой-нибудь
[49:49.640 --> 49:51.640]  thread pool на выполнение,
[49:51.640 --> 49:53.640]  чтобы он в какой-нибудь очереди
[49:53.640 --> 49:55.640]  пока его выполнен.
[49:55.640 --> 49:57.640]  Вы вряд ли будете его копировать туда.
[49:57.640 --> 49:59.640]  Вы его туда move'ните.
[49:59.640 --> 50:01.640]  И если у вас объект такой,
[50:01.640 --> 50:03.640]  что его копировать нельзя,
[50:03.640 --> 50:05.640]  с the function вам не поможет.
[50:05.640 --> 50:07.640]  Но вот есть на такой случай
[50:07.640 --> 50:09.640]  типа move only function.
[50:09.640 --> 50:11.640]  Все то же самое, только он
[50:11.640 --> 50:13.640]  умеет лишь
[50:13.640 --> 50:15.640]  move'аться.
[50:15.640 --> 50:17.640]  Копирующий конструктор удален.
[50:17.640 --> 50:19.640]  Только пока нет.
[50:19.640 --> 50:21.640]  Ну, пока нет.
[50:21.640 --> 50:23.640]  23-й год, поэтому, как бы, формально есть.
[50:23.640 --> 50:25.640]  Правда, компиляторы еще не поддержат, скорее всего.
[50:25.640 --> 50:27.640]  Но надо посмотреть, какие поддерживают.
[50:27.640 --> 50:29.640]  Было бы еще забавно, если бы
[50:29.640 --> 50:31.640]  можно было function в него
[50:31.640 --> 50:33.640]  конвертировать.
[50:35.640 --> 50:37.640]  Ну, вряд ли.
[50:37.640 --> 50:39.640]  А это разве не просто
[50:39.640 --> 50:41.640]  удалить два конструктора и
[50:41.640 --> 50:43.640]  вставить, копипаснуть в свой код
[50:43.640 --> 50:45.640]  function'а? По сути, да.
[50:45.640 --> 50:47.640]  То же самое все. То есть, по идее, поддержать
[50:47.640 --> 50:49.640]  не сложно. Да.
[50:49.640 --> 50:51.640]  Не, но если ты скопипасишь код
[50:51.640 --> 50:53.640]  остального function, я боюсь, что
[50:53.640 --> 50:55.640]  там простым удалением чего-либо
[50:55.640 --> 50:57.640]  ты не обойдешь. У тебя все сломается
[50:57.640 --> 50:59.640]  и будешь долго разбираться.
[50:59.640 --> 51:01.640]  Но я уверен, что в интернете
[51:01.640 --> 51:03.640]  много аналогов уже реализовано
[51:03.640 --> 51:05.640]  за вас. Вот, короче.
[51:07.640 --> 51:09.640]  Что еще надо сказать по поводу
[51:09.640 --> 51:11.640]  этого дела?
[51:11.640 --> 51:13.640]  Move only function.
[51:19.640 --> 51:21.640]  Ладно, вроде
[51:21.640 --> 51:23.640]  я забыл, что я хотел сказать
[51:23.640 --> 51:25.640]  про move only function. Будем считать, что я все
[51:25.640 --> 51:27.640]  сказал.
[51:27.640 --> 51:29.640]  Так.
[51:29.640 --> 51:31.640]  Хорошо.
[51:31.640 --> 51:33.640]  Дальше.
[51:43.640 --> 51:45.640]  Есть, на самом деле, еще одна проблема.
[51:45.640 --> 51:47.640]  Наша реализация function сейчас
[51:51.640 --> 51:53.640]  все еще не до конца корректная.
[51:53.640 --> 51:55.640]  Вот, в том виде, в котором
[51:55.640 --> 51:57.640]  это написано здесь.
[51:57.640 --> 51:59.640]  Но
[51:59.640 --> 52:01.640]  пока что
[52:01.640 --> 52:03.640]  мы эту проблему отложим,
[52:03.640 --> 52:05.640]  потому что она очень
[52:05.640 --> 52:07.640]  трудная для понимания.
[52:07.640 --> 52:09.640]  И я
[52:09.640 --> 52:11.640]  про нее проявляю.
[52:11.640 --> 52:13.640]  Ну, и
[52:13.640 --> 52:15.640]  я про нее
[52:15.640 --> 52:17.640]  расскажу, вероятно, в конце
[52:17.640 --> 52:19.640]  второй из сегодняшних
[52:19.640 --> 52:21.640]  двух пар.
[52:21.640 --> 52:23.640]  Потому что ровно такая же проблема будет
[52:23.640 --> 52:25.640]  и в реализации с the variant.
[52:25.640 --> 52:27.640]  Но поймем
[52:27.640 --> 52:29.640]  мы ее позже.
[52:29.640 --> 52:31.640]  А пока что
[52:31.640 --> 52:33.640]  давайте закончим.
[52:33.640 --> 52:35.640]  У нас сейчас параграф
[52:35.640 --> 52:37.640]  нет.
[52:37.640 --> 52:39.640]  Function implementation
[52:39.640 --> 52:41.640]  это 14.4.
[52:41.640 --> 52:43.640]  Федя вам рассказал
[52:43.640 --> 52:45.640]  14.5 и 14.6.
[52:45.640 --> 52:47.640]  14.5 это полиморфик-аллокатор,
[52:47.640 --> 52:49.640]  а 14.6 это варианты визитных использований.
[52:49.640 --> 52:51.640]  Нам сейчас предстоит как раз
[52:51.640 --> 52:53.640]  параграф 14.7,
[52:53.640 --> 52:55.640]  где мы будем реализовывать variant.
[52:57.640 --> 52:59.640]  Но прежде чем
[52:59.640 --> 53:01.640]  мы начнем реализовывать variant,
[53:01.640 --> 53:03.640]  ну, точнее, я не буду реализовывать
[53:03.640 --> 53:05.640]  его прям полностью, я объясню
[53:05.640 --> 53:07.640]  несколько идей, которые нужны для того,
[53:07.640 --> 53:09.640]  чтобы реализовать.
[53:09.640 --> 53:11.640]  А реализовывать вы его сами будете,
[53:11.640 --> 53:13.640]  там еще много приколов предстоит
[53:13.640 --> 53:15.640]  увидеть по ходу его реализации.
[53:15.640 --> 53:17.640]  Но
[53:17.640 --> 53:19.640]  прежде чем его реализовать,
[53:19.640 --> 53:21.640]  давайте я еще раз
[53:27.640 --> 53:29.640]  покажу то, что показывал
[53:29.640 --> 53:31.640]  Федя в конце последней пары,
[53:31.640 --> 53:33.640]  потому что это важно, и мне кажется
[53:33.640 --> 53:35.640]  тогда не очень все успели
[53:35.640 --> 53:37.640]  понять, что происходило,
[53:37.640 --> 53:39.640]  а это очень важно, потому что оно нам
[53:39.640 --> 53:41.640]  прямо сейчас потребуется для
[53:41.640 --> 53:43.640]  так, вот это я уже лишнего написал,
[53:43.640 --> 53:45.640]  вот я пока удалю, оно нам потребуется
[53:45.640 --> 53:47.640]  для того, чтобы
[53:47.640 --> 53:49.640]  ну, короче, в варианте нам
[53:49.640 --> 53:51.640]  пригодится эта идея.
[53:51.640 --> 53:53.640]  Смотрите,
[53:53.640 --> 53:55.640]  этот код демонстрирует
[53:55.640 --> 53:57.640]  использование варианта и визит.
[53:57.640 --> 53:59.640]  Напоминаю,
[53:59.640 --> 54:01.640]  что такое variant?
[54:01.640 --> 54:03.640]  Variant это штука, которая умеет
[54:07.640 --> 54:09.640]  хранить в себе один из
[54:11.640 --> 54:13.640]  облюстителей порядка,
[54:13.640 --> 54:15.640]  это параграф 14.6, в котором
[54:15.640 --> 54:17.640]  был разговор про
[54:17.640 --> 54:19.640]  вариант и визит,
[54:19.640 --> 54:21.640]  пока без реализации. Так вот, вариант умеет
[54:21.640 --> 54:23.640]  хранить один из перечисленных типов
[54:23.640 --> 54:25.640]  и динамически подменять один на другой,
[54:25.640 --> 54:27.640]  то есть это такой type-safe-union.
[54:27.640 --> 54:29.640]  Напоминаю, в union
[54:29.640 --> 54:31.640]  когда мы, если мы
[54:31.640 --> 54:33.640]  хранили что-то, например int, и решили туда
[54:33.640 --> 54:35.640]  положить string, присваиванием,
[54:35.640 --> 54:37.640]  то у нас будет seg-fold,
[54:37.640 --> 54:39.640]  потому что мы
[54:39.640 --> 54:41.640]  вызовем деструктор, ну там
[54:41.640 --> 54:43.640]  delete квадратной скобочки на памяти,
[54:43.640 --> 54:45.640]  которая не являлась string, в общем, всё плохо.
[54:45.640 --> 54:47.640]  Помните, я надеюсь, это пример,
[54:47.640 --> 54:49.640]  мы его разбирали в прошлый раз.
[54:49.640 --> 54:51.640]  Variant такой проблемой
[54:51.640 --> 54:53.640]  не страдает, вариант позволяет динамически
[54:53.640 --> 54:55.640]  подменять то, что в нём лежит, просто присваиванием.
[54:55.640 --> 54:57.640]  При этом,
[54:57.640 --> 54:59.640]  вариант,
[54:59.640 --> 55:01.640]  я напомню, это тоже очень
[55:01.640 --> 55:03.640]  важно, значит, у нас
[55:03.640 --> 55:05.640]  вариант умеет
[55:07.640 --> 55:09.640]  выбирать
[55:09.640 --> 55:11.640]  наиболее подходящий тип
[55:13.640 --> 55:15.640]  из тех, которые мы дали,
[55:15.640 --> 55:17.640]  то есть вот если у меня есть вариант int double
[55:17.640 --> 55:19.640]  и я его
[55:19.640 --> 55:21.640]  проинциализирую флуатом,
[55:21.640 --> 55:23.640]  то
[55:23.640 --> 55:25.640]  активируется тип double.
[55:27.640 --> 55:29.640]  Помните этот пример?
[55:29.640 --> 55:31.640]  Значит,
[55:31.640 --> 55:33.640]  вариант умеет
[55:33.640 --> 55:35.640]  выбирать наиболее подходящий тип
[55:35.640 --> 55:37.640]  из тех, что в нём есть, для того, чтобы
[55:37.640 --> 55:39.640]  ну, когда мы его инициализируем
[55:39.640 --> 55:41.640]  каким-то значением.
[55:41.640 --> 55:43.640]  По какому принципу, по какому правилу он понимает
[55:43.640 --> 55:45.640]  какой тип наиболее подходящий, по какому правилу он
[55:45.640 --> 55:47.640]  понимает, если в варианте нет
[55:47.640 --> 55:49.640]  Ну, как перегрузка функций.
[55:49.640 --> 55:51.640]  Да, причём в точности так же,
[55:51.640 --> 55:53.640]  то есть никаких новых правил
[55:53.640 --> 55:55.640]  нет, эти правила абсолютно аналогичны.
[55:55.640 --> 55:57.640]  Вариант выбирает подходящий
[55:57.640 --> 55:59.640]  тип в точности по правилам
[55:59.640 --> 56:01.640]  перегрузки функций.
[56:01.640 --> 56:03.640]  Это удивительно вообще, это
[56:03.640 --> 56:05.640]  совершенно не тривиально, это очень
[56:05.640 --> 56:07.640]  это
[56:07.640 --> 56:09.640]  вообще не очевидно, как это написать.
[56:09.640 --> 56:11.640]  Тем не менее, мы сегодня как раз это
[56:11.640 --> 56:13.640]  напишем, то есть мы
[56:13.640 --> 56:15.640]  именно напишем,
[56:15.640 --> 56:17.640]  как нужно реализовать, что нужно
[56:17.640 --> 56:19.640]  написать в классе вариант, чтобы
[56:19.640 --> 56:21.640]  именно так это работало.
[56:21.640 --> 56:23.640]  Это совсем
[56:23.640 --> 56:25.640]  не очевидная идея, вот догадаться
[56:25.640 --> 56:27.640]  самостоятельно до неё, я не знаю, очень
[56:27.640 --> 56:29.640]  трудно.
[56:29.640 --> 56:31.640]  Так вот,
[56:31.640 --> 56:33.640]  почему здесь
[56:33.640 --> 56:35.640]  double активируется? Потому что привести
[56:35.640 --> 56:37.640]  float к double это, я напоминаю,
[56:37.640 --> 56:39.640]  promotion. Это самый лёгкий вид
[56:39.640 --> 56:41.640]  приведения типов. Привести float к int
[56:41.640 --> 56:43.640]  это conversion,
[56:43.640 --> 56:45.640]  которая менее предпочтительна, чем promotion,
[56:45.640 --> 56:47.640]  поэтому будет выбран double.
[56:47.640 --> 56:49.640]  Если вы пытаетесь
[56:49.640 --> 56:51.640]  инициализировать вариант
[56:51.640 --> 56:53.640]  чем-то, что
[56:53.640 --> 56:55.640]  не
[56:55.640 --> 56:57.640]  конвертируется,
[56:57.640 --> 56:59.640]  ну, конверсия, где неоднозначно
[56:59.640 --> 57:01.640]  или вообще
[57:01.640 --> 57:03.640]  ни один тип не конвертируется,
[57:03.640 --> 57:05.640]  то вы получите CE,
[57:05.640 --> 57:07.640]  на этапе компиляции проверяем,
[57:07.640 --> 57:09.640]  а вы пытаетесь варианту
[57:09.640 --> 57:11.640]  с таким набором типов присвоить
[57:11.640 --> 57:13.640]  объект какого-то типа, у которого
[57:13.640 --> 57:15.640]  неоднозначна конверсия
[57:15.640 --> 57:17.640]  во что
[57:17.640 --> 57:19.640]  предпочтительно непонятно,
[57:19.640 --> 57:21.640]  вы получите CE, как и при перегрузке функций,
[57:21.640 --> 57:23.640]  ambiguous. То же самое вы получите,
[57:23.640 --> 57:25.640]  и ни один из типов вообще не конвертируется
[57:25.640 --> 57:27.640]  в ваш, наоборот.
[57:27.640 --> 57:29.640]  Вот, теперь
[57:29.640 --> 57:31.640]  что такое visit я напоминаю. Вот у меня есть
[57:31.640 --> 57:33.640]  вариант,
[57:33.640 --> 57:35.640]  точнее у меня есть вектор вариантов.
[57:37.640 --> 57:39.640]  Вариант
[57:39.640 --> 57:41.640]  из вот таких вещей,
[57:41.640 --> 57:43.640]  char long long and double long long.
[57:45.640 --> 57:47.640]  Код взят из интернета,
[57:47.640 --> 57:49.640]  я вам пришлю ссылку на страничку,
[57:49.640 --> 57:51.640]  откуда я взял этот код потом.
[57:51.640 --> 57:53.640]  Значит,
[57:53.640 --> 57:55.640]  вектор хранит в себе
[57:55.640 --> 57:57.640]  вот такие варианты,
[57:57.640 --> 57:59.640]  и в этих вариантах в первом из них лежит
[57:59.640 --> 58:01.640]  char, во втором в первом из них
[58:01.640 --> 58:03.640]  лежит int, потом char,
[58:03.640 --> 58:05.640]  потом double, потом long long,
[58:05.640 --> 58:07.640]  потом long,
[58:07.640 --> 58:09.640]  потом float и потом int
[58:09.640 --> 58:11.640]  опять.
[58:11.640 --> 58:13.640]  То есть,
[58:13.640 --> 58:15.640]  каждый объект
[58:15.640 --> 58:17.640]  варианта инициализировался соответствующим
[58:17.640 --> 58:19.640]  типом, и я вектор из
[58:19.640 --> 58:21.640]  них сделал.
[58:21.640 --> 58:23.640]  Вектор в каждом вариант и
[58:23.640 --> 58:25.640]  каждый вариант догадался, какой тип
[58:25.640 --> 58:27.640]  в нем лежит. А теперь я
[58:27.640 --> 58:29.640]  делаю вот
[58:29.640 --> 58:31.640]  такую штуку, и вот я напомню, значит,
[58:33.640 --> 58:35.640]  это вам показывал Федя
[58:35.640 --> 58:37.640]  в прошлый раз, но, возможно,
[58:37.640 --> 58:39.640]  вы, значит, не...
[58:43.640 --> 58:45.640]  тогда еще не поняли, но давайте
[58:45.640 --> 58:47.640]  наверное вот как сделаю, наверное
[58:47.640 --> 58:49.640]  вот это пока закомментирую,
[58:49.640 --> 58:51.640]  а здесь просто...
[58:53.640 --> 58:55.640]  Нет, даже не так я сделаю,
[58:55.640 --> 58:57.640]  я не буду это комментировать, я просто return,
[58:57.640 --> 58:59.640]  сделаю раньше времени. Сначала простой
[58:59.640 --> 59:01.640]  пример, более простой пример.
[59:01.640 --> 59:03.640]  У меня есть, значит,
[59:03.640 --> 59:05.640]  автовизитор
[59:07.640 --> 59:09.640]  равно
[59:09.640 --> 59:11.640]  лямбда функция, которая принимает
[59:11.640 --> 59:13.640]  авто
[59:13.640 --> 59:15.640]  и возвращает
[59:17.640 --> 59:19.640]  что?
[59:19.640 --> 59:21.640]  Не возвращает, а выводит
[59:21.640 --> 59:23.640]  typeId от
[59:23.640 --> 59:25.640]  x.name
[59:29.640 --> 59:31.640]  Вот.
[59:31.640 --> 59:33.640]  Тут я сделаю return 0,
[59:33.640 --> 59:35.640]  и теперь я сделаю
[59:35.640 --> 59:37.640]  for const
[59:37.640 --> 59:39.640]  auto percent
[59:39.640 --> 59:41.640]  where
[59:41.640 --> 59:43.640]  var
[59:43.640 --> 59:45.640]  veqVariant
[59:45.640 --> 59:47.640]  visit
[59:47.640 --> 59:49.640]  stdVisit
[59:53.640 --> 59:55.640]  Первым параметром я передаю
[59:55.640 --> 59:57.640]  Visitor,
[59:57.640 --> 59:59.640]  а вторым параметром я передаю
[59:59.640 --> 01:00:01.640]  V
[01:00:05.640 --> 01:00:07.640]  Что сейчас произойдет?
[01:00:07.640 --> 01:00:09.640]  Сейчас выведутся названия
[01:00:09.640 --> 01:00:11.640]  типов по очереди, которые в нем лежат.
[01:00:15.640 --> 01:00:17.640]  Overload,
[01:00:17.640 --> 01:00:19.640]  видит.
[01:00:21.640 --> 01:00:23.640]  Действительно вывелись.
[01:00:23.640 --> 01:00:25.640]  Char double
[01:00:27.640 --> 01:00:29.640]  x это, я не знаю, что такое,
[01:00:29.640 --> 01:00:31.640]  long,
[01:00:31.640 --> 01:00:33.640]  float,
[01:00:33.640 --> 01:00:35.640]  наверное это long-long так обозначается.
[01:00:35.640 --> 01:00:37.640]  Ну я напоминаю, что typeId он
[01:00:37.640 --> 01:00:39.640]  не настоящее название, типа
[01:00:39.640 --> 01:00:41.640]  name хранит, а
[01:00:41.640 --> 01:00:43.640]  для примитивных типов там однобуквенные
[01:00:43.640 --> 01:00:45.640]  каторы лежат.
[01:00:45.640 --> 01:00:47.640]  Понятно ли, как это работает на данный момент?
[01:00:47.640 --> 01:00:49.640]  Вот это должно быть понятно.
[01:00:49.640 --> 01:00:51.640]  Это обсуждали в прошлый раз.
[01:00:51.640 --> 01:00:53.640]  Значит, что
[01:00:53.640 --> 01:00:55.640]  произошло? Сгенерировался
[01:00:55.640 --> 01:00:57.640]  шаблонный класс,
[01:00:57.640 --> 01:00:59.640]  точнее нет, сгенерировался
[01:00:59.640 --> 01:01:01.640]  обычный класс, не шаблонный,
[01:01:01.640 --> 01:01:03.640]  в котором шаблонный оператор куглы скобочки,
[01:01:03.640 --> 01:01:05.640]  ведь Visitor это что такое? Это функциональный
[01:01:05.640 --> 01:01:07.640]  объект, а в нем есть template
[01:01:07.640 --> 01:01:09.640]  оператор куглы скобочки от t,
[01:01:09.640 --> 01:01:11.640]  и вот это auto оно как раз
[01:01:11.640 --> 01:01:13.640]  соответствует тому t, который в операторе
[01:01:13.640 --> 01:01:15.640]  куглы скобочки.
[01:01:15.640 --> 01:01:17.640]  И просто для каждого типа t сгенерировалась
[01:01:17.640 --> 01:01:19.640]  своя версия оператора куглы скобочки,
[01:01:19.640 --> 01:01:21.640]  когда мы вызвались, выбралась нужная
[01:01:21.640 --> 01:01:23.640]  просто для каждого t
[01:01:23.640 --> 01:01:25.640]  соответствующая версия оператора куглы скобочки
[01:01:25.640 --> 01:01:27.640]  сгенерировалась.
[01:01:27.640 --> 01:01:29.640]  То есть на самом деле сгенерировалась по факту
[01:01:29.640 --> 01:01:31.640]  сколько надо разных методов,
[01:01:31.640 --> 01:01:33.640]  не шаблонных уже.
[01:01:33.640 --> 01:01:35.640]  Хорошо.
[01:01:35.640 --> 01:01:37.640]  Вот теперь прикол
[01:01:37.640 --> 01:01:39.640]  с warlord, что здесь написано?
[01:01:39.640 --> 01:01:41.640]  Тут написано следующее.
[01:01:41.640 --> 01:01:43.640]  У меня есть тип
[01:01:43.640 --> 01:01:45.640]  overload, который является
[01:01:45.640 --> 01:01:47.640]  шаблонным, причем он
[01:01:47.640 --> 01:01:49.640]  у нас пока стояло многоточие,
[01:01:49.640 --> 01:01:51.640]  вот так ставится без пробела.
[01:01:51.640 --> 01:01:53.640]  У нас он
[01:01:53.640 --> 01:01:55.640]  шаблонный от перемен
[01:01:55.640 --> 01:01:57.640]  количества аргументов, и он
[01:01:57.640 --> 01:01:59.640]  вот это вот самое внезапное,
[01:01:59.640 --> 01:02:01.640]  вот это вот новое
[01:02:01.640 --> 01:02:03.640]  для вас, такого у нас
[01:02:03.640 --> 01:02:05.640]  раньше не было. Ну, Федя вам в прошлый раз
[01:02:05.640 --> 01:02:07.640]  показывал, но до этого у нас такого не было.
[01:02:07.640 --> 01:02:09.640]  И это нам сегодня еще пригодится.
[01:02:09.640 --> 01:02:11.640]  У нас наследование от переменного количества
[01:02:11.640 --> 01:02:13.640]  шаблонных аргументов.
[01:02:13.640 --> 01:02:15.640]  То есть я распаковал пакет
[01:02:15.640 --> 01:02:17.640]  типов вот прям здесь.
[01:02:17.640 --> 01:02:19.640]  Я сделал структуру
[01:02:19.640 --> 01:02:21.640]  наследницей всех шаблонных параметров,
[01:02:21.640 --> 01:02:23.640]  от которых она,
[01:02:23.640 --> 01:02:25.640]  которые у нее есть.
[01:02:25.640 --> 01:02:27.640]  А дальше я
[01:02:27.640 --> 01:02:29.640]  сделал следующее.
[01:02:29.640 --> 01:02:31.640]  А я написал
[01:02:31.640 --> 01:02:33.640]  using
[01:02:33.640 --> 01:02:35.640]  это еще один новый синтакс, из которого
[01:02:35.640 --> 01:02:37.640]  тоже у нас раньше не было.
[01:02:37.640 --> 01:02:39.640]  Вот этот синтакс
[01:02:39.640 --> 01:02:41.640]  разрешен только начиная с C++17.
[01:02:47.640 --> 01:02:49.640]  До этого
[01:02:49.640 --> 01:02:51.640]  это вообще нельзя было писать.
[01:02:51.640 --> 01:02:53.640]  До этого можно было
[01:02:53.640 --> 01:02:55.640]  написать. Вот
[01:02:55.640 --> 01:02:57.640]  using с многоточием
[01:02:59.640 --> 01:03:01.640]  стал разрешен начиная с C++17.
[01:03:01.640 --> 01:03:03.640]  На самом деле
[01:03:03.640 --> 01:03:05.640]  это можно было сымитировать
[01:03:05.640 --> 01:03:07.640]  средствами
[01:03:07.640 --> 01:03:09.640]  C++11.
[01:03:13.640 --> 01:03:15.640]  Но я забыл как.
[01:03:15.640 --> 01:03:17.640]  Надо вспомнить, надо подумать.
[01:03:33.640 --> 01:03:35.640]  Ну
[01:03:35.640 --> 01:03:37.640]  например
[01:03:37.640 --> 01:03:39.640]  можно было
[01:03:39.640 --> 01:03:41.640]  написать так.
[01:03:41.640 --> 01:03:43.640]  Ну чисто вот что
[01:03:43.640 --> 01:03:45.640]  можно было бы сказать.
[01:03:45.640 --> 01:03:47.640]  Можно было бы сказать, что
[01:03:47.640 --> 01:03:49.640]  у меня есть
[01:03:49.640 --> 01:03:51.640]  шаблонный метод
[01:03:51.640 --> 01:03:53.640]  в котором
[01:03:53.640 --> 01:03:55.640]  у меня есть шаблонные
[01:03:55.640 --> 01:03:57.640]  параметры.
[01:03:57.640 --> 01:03:59.640]  То есть у меня есть шаблонные
[01:03:59.640 --> 01:04:01.640]  параметры.
[01:04:01.640 --> 01:04:03.640]  Шаблонный метод
[01:04:03.640 --> 01:04:05.640]  оператор круглые скобочки
[01:04:11.640 --> 01:04:13.640]  void.
[01:04:13.640 --> 01:04:15.640]  Ну правда вот здесь
[01:04:15.640 --> 01:04:17.640]  типом будет
[01:04:17.640 --> 01:04:19.640]  некоторая проблема.
[01:04:19.640 --> 01:04:21.640]  Типы получаются у меня должны быть
[01:04:21.640 --> 01:04:23.640]  разными. Но с другой стороны
[01:04:23.640 --> 01:04:25.640]  перегрузки типы должны быть одинаковыми.
[01:04:25.640 --> 01:04:27.640]  Вот на самом деле тип здесь у меня
[01:04:27.640 --> 01:04:29.640]  должен быть какой-то один.
[01:04:29.640 --> 01:04:31.640]  Визи тоже должен быть одинаковый тип
[01:04:31.640 --> 01:04:33.640]  возвращаемый.
[01:04:33.640 --> 01:04:35.640]  Тип нужно явно указать, либо
[01:04:35.640 --> 01:04:37.640]  он должен выводиться какой-то одинаковый.
[01:04:37.640 --> 01:04:39.640]  Я здесь что напишу?
[01:04:39.640 --> 01:04:41.640]  void.оператор круглые скобочки
[01:04:41.640 --> 01:04:43.640]  от
[01:04:45.640 --> 01:04:47.640]  какого-то параметра.
[01:04:47.640 --> 01:04:49.640]  Ну скажем от
[01:04:49.640 --> 01:04:51.640]  чего?
[01:04:59.640 --> 01:05:01.640]  Сейчас.
[01:05:01.640 --> 01:05:03.640]  Принимаемый тип у меня
[01:05:03.640 --> 01:05:05.640]  здесь тоже является проблемой.
[01:05:05.640 --> 01:05:07.640]  А ну вариант
[01:05:07.640 --> 01:05:09.640]  видимо мне нужно принять.
[01:05:09.640 --> 01:05:11.640]  const
[01:05:11.640 --> 01:05:13.640]  вариант
[01:05:13.640 --> 01:05:15.640]  персант.
[01:05:15.640 --> 01:05:17.640]  Короче я что хочу сделать?
[01:05:17.640 --> 01:05:19.640]  Я могу сказать, что статик каст
[01:05:19.640 --> 01:05:21.640]  токсик
[01:05:21.640 --> 01:05:23.640]  токсик
[01:05:23.640 --> 01:05:25.640]  токсик
[01:05:25.640 --> 01:05:27.640]  токсик
[01:05:27.640 --> 01:05:29.640]  Я могу сказать, что статик каст
[01:05:29.640 --> 01:05:31.640]  т звездочки себя
[01:05:31.640 --> 01:05:33.640]  и вызвать у него круглые скобочки от этой штуки.
[01:05:35.640 --> 01:05:37.640]  Я кстати не уверен, что это
[01:05:37.640 --> 01:05:39.640]  прям
[01:05:39.640 --> 01:05:41.640]  что нет лучшего способа.
[01:05:41.640 --> 01:05:43.640]  То есть здесь надо написать статик ассерт
[01:05:43.640 --> 01:05:45.640]  что я вызываю этот
[01:05:45.640 --> 01:05:47.640]  оператор
[01:05:53.640 --> 01:05:55.640]  вариант
[01:05:55.640 --> 01:05:57.640]  стд вариант
[01:05:57.640 --> 01:05:59.640]  Ну да.
[01:05:59.640 --> 01:06:01.640]  Визит вызывается от варианта, потому что
[01:06:01.640 --> 01:06:03.640]  сейчас нет
[01:06:03.640 --> 01:06:05.640]  я что-то затупился
[01:06:05.640 --> 01:06:07.640]  я начал какую-то фигню писать
[01:06:07.640 --> 01:06:09.640]  по-моему.
[01:06:09.640 --> 01:06:11.640]  Слушайте
[01:06:11.640 --> 01:06:13.640]  нет, давайте я лучше не буду этим заниматься.
[01:06:13.640 --> 01:06:15.640]  Я не помню как это санитировать
[01:06:15.640 --> 01:06:17.640]  через средство C++11.
[01:06:17.640 --> 01:06:19.640]  Это можно, но
[01:06:19.640 --> 01:06:21.640]  видимо я не могу это сделать в ходу, поэтому я сейчас
[01:06:21.640 --> 01:06:23.640]  лучше не буду в этом делать.
[01:06:23.640 --> 01:06:25.640]  Следующую строчку объясните, пожалуйста.
[01:06:25.640 --> 01:06:27.640]  Вот
[01:06:27.640 --> 01:06:29.640]  короче, вот такой синтакс из работы
[01:06:29.640 --> 01:06:31.640]  начинается C++17. Может быть сейчас мы
[01:06:31.640 --> 01:06:33.640]  сделаем перерыв, когда у нас
[01:06:33.640 --> 01:06:35.640]  через полчаса
[01:06:35.640 --> 01:06:37.640]  и в перерыве я быстренько найду
[01:06:37.640 --> 01:06:39.640]  и покажу как это имитировалось раньше.
[01:06:39.640 --> 01:06:41.640]  Тем не менее, что вот это значит?
[01:06:41.640 --> 01:06:43.640]  Это значит, что я
[01:06:43.640 --> 01:06:45.640]  из всех наследников
[01:06:45.640 --> 01:06:47.640]  вношу в эту область видимости оператор
[01:06:47.640 --> 01:06:49.640]  круглые скобочки. Таким образом у меня
[01:06:49.640 --> 01:06:51.640]  получается много операторов
[01:06:51.640 --> 01:06:53.640]  круглые скобочки
[01:06:53.640 --> 01:06:55.640]  от
[01:06:55.640 --> 01:06:57.640]  нужных типов.
[01:06:59.640 --> 01:07:01.640]  Один
[01:07:01.640 --> 01:07:03.640]  оператор круглые скобочки от
[01:07:03.640 --> 01:07:05.640]  Char, другой от int,
[01:07:05.640 --> 01:07:07.640]  третий от unsigned int,
[01:07:07.640 --> 01:07:09.640]  потому что у всех моих наследников
[01:07:09.640 --> 01:07:11.640]  у каждого был по одному оператор круглые скобочки.
[01:07:11.640 --> 01:07:13.640]  И я
[01:07:13.640 --> 01:07:15.640]  тем самым их
[01:07:15.640 --> 01:07:17.640]  все унаследовал.
[01:07:17.640 --> 01:07:19.640]  Что вот это такое?
[01:07:19.640 --> 01:07:21.640]  А это, господа, type
[01:07:21.640 --> 01:07:23.640]  deduction guide, который у вас
[01:07:23.640 --> 01:07:25.640]  был в пункте
[01:07:25.640 --> 01:07:29.640]  дай бог памяти 11.3,
[01:07:29.640 --> 01:07:31.640]  когда вы говорили про
[01:07:31.640 --> 01:07:33.640]  сети ID, class template,
[01:07:33.640 --> 01:07:35.640]  аргумент deduction. Если я
[01:07:35.640 --> 01:07:37.640]  создаю
[01:07:37.640 --> 01:07:39.640]  оверлот от каких-то
[01:07:39.640 --> 01:07:41.640]  шаблонных параметров,
[01:07:41.640 --> 01:07:43.640]  то шаблонные параметры должны вывестись
[01:07:43.640 --> 01:07:45.640]  вот так.
[01:07:45.640 --> 01:07:47.640]  Это user defined deduction guide.
[01:07:47.640 --> 01:07:49.640]  Вот.
[01:07:49.640 --> 01:07:51.640]  И что здесь написано?
[01:07:51.640 --> 01:07:53.640]  Здесь написано, что если я в конструктор
[01:07:53.640 --> 01:07:55.640]  overload передаю какой-то набор
[01:07:55.640 --> 01:07:57.640]  типов, то считай, что
[01:07:57.640 --> 01:07:59.640]  твои шаблонные параметры это и есть
[01:07:59.640 --> 01:08:01.640]  эти типы. Вообще говоря,
[01:08:01.640 --> 01:08:03.640]  если бы я этого не написал, компилятору
[01:08:03.640 --> 01:08:05.640]  было бы совершенно непонятно,
[01:08:05.640 --> 01:08:07.640]  от каких шаблонных
[01:08:07.640 --> 01:08:09.640]  параметров я имею в виду overload,
[01:08:09.640 --> 01:08:11.640]  если я вызвал конструктор overload
[01:08:11.640 --> 01:08:13.640]  от таких типов.
[01:08:13.640 --> 01:08:15.640]  Но я написал deduction guide, что
[01:08:15.640 --> 01:08:17.640]  от этих типов тебя конструктор не вызывали,
[01:08:17.640 --> 01:08:19.640]  считай, что твои
[01:08:19.640 --> 01:08:21.640]  шаблонные параметры это и есть эти типы.
[01:08:21.640 --> 01:08:23.640]  Таким образом, если я вызываю
[01:08:23.640 --> 01:08:25.640]  конструктор от вот
[01:08:25.640 --> 01:08:27.640]  такого набора шаблонных параметров,
[01:08:27.640 --> 01:08:29.640]  то компилятор понимает, что именно эти
[01:08:29.640 --> 01:08:31.640]  типы и будут моими шаблонными параметрами,
[01:08:31.640 --> 01:08:33.640]  а значит,
[01:08:33.640 --> 01:08:35.640]  от них от всех мне надо унаследоваться.
[01:08:35.640 --> 01:08:37.640]  А значит,
[01:08:37.640 --> 01:08:39.640]  от каждого из них мне нужно внести
[01:08:39.640 --> 01:08:41.640]  вот этот вот using,
[01:08:41.640 --> 01:08:43.640]  из каждого из них в область видимости свою
[01:08:43.640 --> 01:08:45.640]  внесется оператор куглы-скобочки.
[01:08:45.640 --> 01:08:47.640]  Каким образом у меня в классе overload,
[01:08:47.640 --> 01:08:49.640]  в объекте вот этот вот,
[01:08:49.640 --> 01:08:51.640]  будет вот 6 разных операторов куглы-скобочки,
[01:08:51.640 --> 01:08:53.640]  которые для каждого типа
[01:08:53.640 --> 01:08:55.640]  делают то, что нужно.
[01:08:55.640 --> 01:08:57.640]  И теперь, если я так сделаю,
[01:08:57.640 --> 01:08:59.640]  то у меня просто выведутся
[01:08:59.640 --> 01:09:01.640]  названия этих типов по правилам перегрузки.
[01:09:01.640 --> 01:09:03.640]  Потому что у меня
[01:09:03.640 --> 01:09:05.640]  будет ровно столько операторов куглы-скобочки
[01:09:05.640 --> 01:09:07.640]  по одному на каждый тип.
[01:09:07.640 --> 01:09:09.640]  И для каждого из них выведется название.
[01:09:09.640 --> 01:09:11.640]  Понятно, что произошло вот здесь,
[01:09:11.640 --> 01:09:13.640]  вот в этом коде?
[01:09:13.640 --> 01:09:15.640]  Ну, самое сложное здесь, кажется,
[01:09:15.640 --> 01:09:17.640]  для понимания вот эта строчка.
[01:09:19.640 --> 01:09:21.640]  Но это просто надо принять,
[01:09:21.640 --> 01:09:23.640]  потому что это такой синтаксис специальный.
[01:09:23.640 --> 01:09:25.640]  То есть, начиная с 17,
[01:09:25.640 --> 01:09:27.640]  можно делать вот так.
[01:09:27.640 --> 01:09:29.640]  Можно делать using с многоточиями.
[01:09:29.640 --> 01:09:31.640]  Это значит, я у всех наследников
[01:09:31.640 --> 01:09:33.640]  унаследовал оператор куглы-скобочки.
[01:09:33.640 --> 01:09:35.640]  Вот.
[01:09:35.640 --> 01:09:37.640]  Ну а теперь, значит,
[01:09:37.640 --> 01:09:39.640]  самое интересное,
[01:09:39.640 --> 01:09:41.640]  когда у меня есть...
[01:09:41.640 --> 01:09:43.640]  Ой, что я сделал?
[01:09:43.640 --> 01:09:45.640]  Это мне не надо было удалять.
[01:09:45.640 --> 01:09:47.640]  Вот эту удаляю.
[01:09:47.640 --> 01:09:49.640]  Теперь у меня есть другой вектор вариантов.
[01:09:49.640 --> 01:09:51.640]  Смотрите, у меня вариант из вектора,
[01:09:51.640 --> 01:09:53.640]  дабла и стринг.
[01:09:53.640 --> 01:09:55.640]  И смотрите, что написано.
[01:09:55.640 --> 01:09:57.640]  Первый вариант я инициализирую даблом,
[01:09:57.640 --> 01:09:59.640]  второй вариант я инициализирую вектором,
[01:09:59.640 --> 01:10:01.640]  третий вариант я инициализирую стрингом.
[01:10:01.640 --> 01:10:03.640]  То есть у меня такой вектор,
[01:10:03.640 --> 01:10:05.640]  в котором первый элемент хранит дабл,
[01:10:05.640 --> 01:10:07.640]  второй элемент хранит вектор,
[01:10:07.640 --> 01:10:09.640]  третий элемент хранит стринг.
[01:10:09.640 --> 01:10:11.640]  И теперь я делаю вот такую вещь.
[01:10:11.640 --> 01:10:13.640]  У меня есть оверлот от двух лямб.
[01:10:13.640 --> 01:10:15.640]  Первая лямбда принимает вектор,
[01:10:15.640 --> 01:10:17.640]  а вторая лямбда принимает авто.
[01:10:17.640 --> 01:10:19.640]  К чему это приводит?
[01:10:19.640 --> 01:10:21.640]  А это приводит к тому,
[01:10:21.640 --> 01:10:23.640]  что в моем оверлот
[01:10:23.640 --> 01:10:25.640]  получается два оператора куглы-скобочки.
[01:10:25.640 --> 01:10:27.640]  Один оператор куглы-скобочки
[01:10:27.640 --> 01:10:29.640]  от конкретного типа вектор,
[01:10:29.640 --> 01:10:31.640]  а другой оператор куглы-скобочки
[01:10:31.640 --> 01:10:33.640]  шаблонный.
[01:10:33.640 --> 01:10:35.640]  Вот эта чудо-конструкция
[01:10:35.640 --> 01:10:37.640]  унаследовала мне от всех
[01:10:37.640 --> 01:10:39.640]  наследников оператор куглы-скобочки,
[01:10:39.640 --> 01:10:41.640]  один из которых конкретный
[01:10:41.640 --> 01:10:43.640]  от вектора, а второй из которых
[01:10:43.640 --> 01:10:45.640]  шаблонный от t.
[01:10:45.640 --> 01:10:47.640]  Таким образом у меня в этом классе
[01:10:47.640 --> 01:10:49.640]  оверлот есть два оператора куглы-скобочки,
[01:10:49.640 --> 01:10:51.640]  один конкретный от вектора,
[01:10:51.640 --> 01:10:53.640]  другой шаблонный от t.
[01:10:53.640 --> 01:10:55.640]  И дальше выбирается перегрузка,
[01:10:55.640 --> 01:10:57.640]  как происходит перегрузка между ними.
[01:10:57.640 --> 01:10:59.640]  Если я вызываюсь от вектора,
[01:10:59.640 --> 01:11:01.640]  ну вот здесь я делаю visit,
[01:11:01.640 --> 01:11:03.640]  вот этот вот функтор
[01:11:03.640 --> 01:11:05.640]  от вот этого варианта.
[01:11:05.640 --> 01:11:07.640]  И этот visit
[01:11:07.640 --> 01:11:09.640]  понимает, что раз в варианте
[01:11:09.640 --> 01:11:11.640]  лежит вектор,
[01:11:11.640 --> 01:11:13.640]  то ему надо вызвать
[01:11:13.640 --> 01:11:15.640]  версию от вектора.
[01:11:15.640 --> 01:11:17.640]  И он вызывает
[01:11:17.640 --> 01:11:19.640]  от него.
[01:11:21.640 --> 01:11:23.640]  Почему от него?
[01:11:23.640 --> 01:11:25.640]  Потому что у меня, частно-предпочтительно
[01:11:25.640 --> 01:11:27.640]  общего, у меня есть конкретная версия
[01:11:27.640 --> 01:11:29.640]  от вектора и шаблонная версия еще
[01:11:29.640 --> 01:11:31.640]  от нее.
[01:11:31.640 --> 01:11:33.640]  Но если у меня вектор,
[01:11:33.640 --> 01:11:35.640]  то предпочтительно, конечно, версия конкретная
[01:11:35.640 --> 01:11:37.640]  от вектора.
[01:11:37.640 --> 01:11:39.640]  А что дальше происходит?
[01:11:39.640 --> 01:11:41.640]  Дальше, когда у меня лежит double,
[01:11:41.640 --> 01:11:43.640]  версии от double нет,
[01:11:43.640 --> 01:11:45.640]  поэтому мы инстанцируем шаблонную версию.
[01:11:45.640 --> 01:11:47.640]  И попадаем вот в этот код.
[01:11:47.640 --> 01:11:49.640]  Вот этот шаблонный код, который здесь еще
[01:11:49.640 --> 01:11:51.640]  проверяет, правда ли тип...
[01:11:51.640 --> 01:11:53.640]  Ну, здесь я уже написал
[01:11:53.640 --> 01:11:55.640]  и в constexpr чисто, чтобы еще
[01:11:55.640 --> 01:11:57.640]  добавить веселухи.
[01:11:57.640 --> 01:11:59.640]  Здесь я проверяю, правда ли тип string,
[01:11:59.640 --> 01:12:01.640]  и тогда пишу string. А если тип int,
[01:12:01.640 --> 01:12:03.640]  то пишу int. Часто, правда, кстати,
[01:12:03.640 --> 01:12:05.640]  не сработает. Помните ли вы почему?
[01:12:05.640 --> 01:12:07.640]  Потому что у меня тип arg. На самом деле ссылка.
[01:12:07.640 --> 01:12:09.640]  Мне нужно std decay
[01:12:09.640 --> 01:12:11.640]  добавить.
[01:12:15.640 --> 01:12:17.640]  Ой, std decay перед декл-тайпом надо добавить.
[01:12:17.640 --> 01:12:19.640]  std decay t
[01:12:21.640 --> 01:12:23.640]  от декл-тайпа arg и
[01:12:23.640 --> 01:12:25.640]  std string. И здесь тоже std decay t.
[01:12:27.640 --> 01:12:29.640]  decay – это штука,
[01:12:29.640 --> 01:12:31.640]  которая снимает все...
[01:12:31.640 --> 01:12:33.640]  снимает звездочки, амперсанды,
[01:12:33.640 --> 01:12:35.640]  в общем, оставляет
[01:12:35.640 --> 01:12:37.640]  чистый тип, как он
[01:12:37.640 --> 01:12:39.640]  есть. Там без амперсандов,
[01:12:39.640 --> 01:12:41.640]  в частности. Массив разрушает
[01:12:41.640 --> 01:12:43.640]  допойнтера.
[01:12:43.640 --> 01:12:45.640]  В общем, снимает украшения с типа, можно так
[01:12:45.640 --> 01:12:47.640]  сказать, по-простому говоря.
[01:12:47.640 --> 01:12:49.640]  Вот. И сейчас
[01:12:49.640 --> 01:12:51.640]  у меня
[01:12:51.640 --> 01:12:53.640]  ничего не вывел. Раскулачивает.
[01:12:53.640 --> 01:12:55.640]  Потому что я написал...
[01:12:55.640 --> 01:12:57.640]  Почему?
[01:12:59.640 --> 01:13:01.640]  Сейчас что произошло? Я не понимаю.
[01:13:03.640 --> 01:13:05.640]  Сейчас можно мне вопрос задать?
[01:13:05.640 --> 01:13:07.640]  Да-да, сейчас. Вот. Все правильно.
[01:13:07.640 --> 01:13:09.640]  У меня случилось
[01:13:09.640 --> 01:13:11.640]  1.3.4.5, потом string hello.
[01:13:11.640 --> 01:13:13.640]  А, потому что там был не int.
[01:13:13.640 --> 01:13:15.640]  Здесь мне надо написать double.
[01:13:15.640 --> 01:13:17.640]  И тогда, кажется,
[01:13:17.640 --> 01:13:19.640]  все будет правильно. То есть он сначала выведет
[01:13:19.640 --> 01:13:21.640]  int.1.5.
[01:13:23.640 --> 01:13:25.640]  Ну, double написать было.
[01:13:25.640 --> 01:13:27.640]  Потом
[01:13:27.640 --> 01:13:29.640]  vector вывел, попав вот в эту версию.
[01:13:29.640 --> 01:13:31.640]  А потом вывел string,
[01:13:31.640 --> 01:13:33.640]  попав вот сюда.
[01:13:35.640 --> 01:13:37.640]  Да. Вопрос?
[01:13:37.640 --> 01:13:39.640]  Да, вопрос.
[01:13:39.640 --> 01:13:41.640]  У нас почему, когда мы конструируем
[01:13:41.640 --> 01:13:43.640]  оверлот от лямда...
[01:13:43.640 --> 01:13:45.640]  У нас же лямда авто — это тип
[01:13:45.640 --> 01:13:47.640]  без шаблона. То есть это как бы шаблон, но он такой
[01:13:47.640 --> 01:13:49.640]  необычный шаблон.
[01:13:49.640 --> 01:13:51.640]  Он не считается обычным.
[01:13:51.640 --> 01:13:53.640]  Почему мы конструируем класс от оверлот
[01:13:53.640 --> 01:13:55.640]  от лямда с этим авто?
[01:13:55.640 --> 01:13:57.640]  Тип этой лямды сам по себе тип
[01:13:57.640 --> 01:13:59.640]  не шаблонный.
[01:13:59.640 --> 01:14:01.640]  В нем оператор круглые скобочки шаблонный.
[01:14:03.640 --> 01:14:05.640]  О, ок.
[01:14:05.640 --> 01:14:07.640]  Вот.
[01:14:07.640 --> 01:14:09.640]  И мы его внесли в эту область видимости.
[01:14:09.640 --> 01:14:11.640]  И теперь в этой области видимости у нас есть один оператор
[01:14:11.640 --> 01:14:13.640]  круглые скобочки обычный от вектора.
[01:14:13.640 --> 01:14:15.640]  А другой оператор круглые скобочки шаблонный
[01:14:15.640 --> 01:14:20.120]  от tempersanda. Соответственно, когда мы вызываемся от
[01:14:20.120 --> 01:14:22.280]  вектора, мы попадаем в частную версию, потому что есть
[01:14:22.280 --> 01:14:25.080]  версия конкретно для такого типа. А если мы вызываемся
[01:14:25.080 --> 01:14:27.280]  от чего угодно другого, не от вектора, мы попадаем
[01:14:27.280 --> 01:14:30.240]  в эту версию, потому что предпочтительнее сделать
[01:14:30.240 --> 01:14:34.040]  подстановку t, чем конверсию типа. И дальше мы попадаем
[01:14:34.040 --> 01:14:36.040]  вот в этот код, где уже в зависимости от того, чему
[01:14:36.040 --> 01:14:38.800]  равно t, делаем либо одно, либо другое.
[01:14:38.800 --> 01:14:41.520]  А можете еще раз наверх промотать?
[01:14:41.520 --> 01:14:42.520]  Пожалуйста.
[01:14:42.520 --> 01:14:47.240]  Так, спасибо.
[01:14:47.240 --> 01:14:50.120]  Начиная с C++20, вот это можно не писать. Это вам тоже
[01:14:50.120 --> 01:14:53.960]  Федер говорил в прошлый раз. Надеюсь, мне нужно
[01:14:53.960 --> 01:15:00.400]  писать –std равно C++20. И это работает без кастомного
[01:15:00.400 --> 01:15:05.120]  вывода типов. Почему это работает без кастомного
[01:15:05.120 --> 01:15:07.080]  вывода типов? Потому что помните, мы с вами когда
[01:15:07.080 --> 01:15:11.080]  обсуждали classTemplate.argument.deduction, там был разговор о том, что
[01:15:11.080 --> 01:15:14.520]  начиная с C++20, добавили argument.deduction, в том числе
[01:15:14.520 --> 01:15:17.920]  для вот такого инициализации, когда вы инициализируете
[01:15:17.920 --> 01:15:20.880]  через когрегатную инициализацию.
[01:15:20.880 --> 01:15:28.360]  Здесь, правда, какой-то совсем интересный пример,
[01:15:28.360 --> 01:15:31.920]  потому что здесь конструктор как бы от всех наследников.
[01:15:31.920 --> 01:15:34.040]  Но меня не дает вывести на самом деле, то есть у
[01:15:34.040 --> 01:15:37.320]  меня ЦСЕ, если не прописать явно.
[01:15:37.320 --> 01:15:39.880]  А у тебя какой компилятор?
[01:15:39.880 --> 01:15:43.520]  Ну, C++20. Компилятор.
[01:15:43.520 --> 01:15:46.760]  Компилятор какой? Они могут не целиком поддерживать.
[01:15:46.760 --> 01:15:49.720]  Ну, в общем, не знаю, по идее должно работать.
[01:15:49.720 --> 01:15:51.800]  Что, в крайнем случае, если не работает, можно так
[01:15:51.800 --> 01:15:57.040]  писать. А так работает?
[01:15:57.040 --> 01:16:05.240]  По сути, наверное, все на этом. Ну, это была подводочка
[01:16:05.240 --> 01:16:07.800]  к тому, что мы сейчас начнем реализовывать, собственно,
[01:16:08.280 --> 01:16:10.800]  то есть наша задача сейчас будет состоять в том, чтобы
[01:16:10.800 --> 01:16:12.360]  понять, как это все работает внутри.
[01:16:12.360 --> 01:16:15.480]  Во-первых, как работает вариант, во-вторых, как работает
[01:16:15.480 --> 01:16:20.840]  визит, потому что это пока осталось загадкой.
[01:16:20.840 --> 01:16:24.920]  Ну, а у вас это будет, соответственно, предпоследней задачей в
[01:16:24.920 --> 01:16:26.840]  этом семестре написать это все как следует.
[01:16:26.840 --> 01:16:31.400]  И мы сейчас переходим к обсуждению того, как реализован
[01:16:31.400 --> 01:16:37.000]  вариант. Ну, начнем понятно как.
[01:16:37.240 --> 01:16:44.600]  У меня есть typeName многоточие types, а класс вариант.
[01:16:49.240 --> 01:16:56.840]  Давайте вместе думать. Ну, мы начнем с самого простого.
[01:16:56.840 --> 01:17:00.760]  Что нам надо очевидно хранить?
[01:17:00.760 --> 01:17:05.720]  Для начала обсудим поля. Вот, что надо должно храниться?
[01:17:06.440 --> 01:17:10.280]  Конечно, мы все потом переделаем. Сейчас мы будем итеративно,
[01:17:10.280 --> 01:17:14.520]  то есть мы будем делать какую-то банальную, реализовывать
[01:17:14.520 --> 01:17:18.120]  банальную идею, потом находить проблемы и преобразовывать
[01:17:18.120 --> 01:17:22.360]  более сложную идею. Ну, на первоначальном этапе, как
[01:17:22.360 --> 01:17:24.120]  кажется, что должно храниться у нас?
[01:17:24.120 --> 01:17:35.240]  Что, никто не может ничего сказать? Или еще не пришли
[01:17:35.240 --> 01:17:37.640]  с перерыва все? Так, сейчас.
[01:17:37.640 --> 01:17:43.960]  Должен быть Юниор. А есть кто смотрел лекцию прошлого
[01:17:43.960 --> 01:17:46.840]  года про реализацию варианта? Если вы смотрели, то у вас
[01:17:46.840 --> 01:17:50.440]  все заспойлерено, вам будет неинтересно. Тогда вы молчите.
[01:17:50.440 --> 01:17:53.800]  Надо, чтобы те, кто не смотрели, фантазировали.
[01:17:53.800 --> 01:17:58.920]  Я не смотрел даже нашу лекцию два-две лекции назад, потому
[01:17:58.920 --> 01:17:59.880]  что ее не выложили.
[01:17:59.880 --> 01:18:05.320]  А, ладно. Ну, кто-то сказал, Юнион надо хранить.
[01:18:05.320 --> 01:18:09.480]  Можно хранить Юнион, но как в этот Юнион положить все
[01:18:09.480 --> 01:18:12.040]  типы, какие надо? У меня же их переменное количество.
[01:18:12.040 --> 01:18:14.360]  Да, в стрейт-оче есть синтезис?
[01:18:14.360 --> 01:18:21.160]  Ну, я не могу сказать, я не могу поле объявить вот так,
[01:18:21.160 --> 01:18:26.760]  очевидно. Это бред полный. Ну, типа как?
[01:18:26.760 --> 01:18:29.960]  Может, через оператор запятую, что-нибудь такое веселое
[01:18:29.960 --> 01:18:30.200]  дело?
[01:18:30.200 --> 01:18:34.360]  Нет, опять через оператор совершенно непонятно как,
[01:18:34.360 --> 01:18:38.200]  потому что Types это пакет. Мне надо распаковать пакет,
[01:18:38.200 --> 01:18:39.240]  если я...
[01:18:39.240 --> 01:18:43.400]  Types, а, через оператор, нет, значит, это не оператор.
[01:18:43.400 --> 01:18:47.400]  Мне оператор никакой, кажется, не поможет по той простой
[01:18:47.400 --> 01:18:51.400]  причине, что мне нужно declaration сделать, мне нужно объявить
[01:18:51.400 --> 01:18:55.400]  несколько штук разных типов. Оператор тут никак не справится,
[01:18:55.400 --> 01:18:57.400]  потому что оператор это когда уже есть, а не можно
[01:18:57.400 --> 01:18:58.200]  expression писать.
[01:18:58.200 --> 01:19:00.200]  Но есть какую-нибудь функцию, которую они еще и делают,
[01:19:00.200 --> 01:19:02.200]  какой-нибудь define сделать?
[01:19:02.200 --> 01:19:05.800]  Нет, define вообще не вариант. На самом деле, вот мы с вами
[01:19:05.800 --> 01:19:07.000]  внимательно читали...
[01:19:07.000 --> 01:19:09.000]  Может, в сырую память их положить?
[01:19:09.000 --> 01:19:11.000]  Так тоже можно.
[01:19:11.000 --> 01:19:13.000]  Можно хоть звездочки все скастовать и положить
[01:19:13.000 --> 01:19:15.000]  указательные на них.
[01:19:15.000 --> 01:19:17.000]  Мы с вами, хоть звездочки, ты уже что-то перегнул.
[01:19:17.000 --> 01:19:20.000]  Мы с вами внимательно читали статью
[01:19:20.000 --> 01:19:23.000]  Seed Preference про юнионы, в которой было написано, что нельзя
[01:19:23.000 --> 01:19:26.000]  в юнионах. Там было написано в юнионах, там нельзя то,
[01:19:26.000 --> 01:19:29.000]  все, нельзя наследование, нельзя виртуальные функции,
[01:19:29.000 --> 01:19:31.000]  но там не было сказано, что нельзя делать шаблонные
[01:19:31.000 --> 01:19:34.000]  юнионы. На самом деле, можно сделать шаблонный юнион.
[01:19:34.000 --> 01:19:40.000]  Я богое имя типов сделаю, чтобы не конфликтовать с
[01:19:40.000 --> 01:19:42.000]  внешним.
[01:19:42.000 --> 01:19:44.000]  И сделаю следующее.
[01:19:44.000 --> 01:19:47.000]  Правда, мне придется сделать здесь head и tail.
[01:19:51.000 --> 01:19:53.000]  Да, здесь будет head и tail.
[01:19:53.000 --> 01:19:55.000]  Я сделаю head.
[01:19:55.000 --> 01:19:57.000]  Head.
[01:19:57.000 --> 01:19:59.000]  А дальше я сделаю union.
[01:19:59.000 --> 01:20:01.000]  Вот tail.
[01:20:01.000 --> 01:20:03.000]  Ой, какой union?
[01:20:03.000 --> 01:20:05.000]  Господи, что?
[01:20:05.000 --> 01:20:07.000]  А, tail.
[01:20:07.000 --> 01:20:09.000]  Так лучше.
[01:20:09.000 --> 01:20:11.000]  Вот.
[01:20:11.000 --> 01:20:13.000]  Понятно, как это работать будет.
[01:20:15.000 --> 01:20:17.000]  У них нужна специализация для одного head?
[01:20:17.000 --> 01:20:19.000]  Разумеется.
[01:20:19.000 --> 01:20:21.000]  Безусловно. Нужна специализация.
[01:20:23.000 --> 01:20:25.000]  Скорее для пустого.
[01:20:27.000 --> 01:20:29.000]  Ну, не знаю.
[01:20:29.000 --> 01:20:31.000]  Может быть лучше.
[01:20:31.000 --> 01:20:33.000]  Пустого union не очень понятно, что такое пустой union.
[01:20:33.000 --> 01:20:35.000]  Типа, там будет один byte, что это такое?
[01:20:35.000 --> 01:20:37.000]  Нет, я для одного лучше сделаю.
[01:20:39.000 --> 01:20:41.000]  Так что size of пустого union тогда не понятно,
[01:20:41.000 --> 01:20:43.000]  какой будет.
[01:20:43.000 --> 01:20:45.000]  Я лучше сделаю для такого.
[01:20:45.000 --> 01:20:47.000]  И что я здесь напишу?
[01:20:47.000 --> 01:20:49.000]  Ну, я напишу вот так.
[01:20:49.000 --> 01:20:51.000]  Только T.
[01:20:51.000 --> 01:20:53.000]  Да, T value.
[01:20:53.000 --> 01:20:55.000]  Ну, может я все-таки сделаю head.
[01:20:57.000 --> 01:20:59.000]  Да, я неправильно описал специализацию,
[01:20:59.000 --> 01:21:01.000]  потому что нужно вот так же делать.
[01:21:01.000 --> 01:21:03.000]  И сделаю просто head.
[01:21:03.000 --> 01:21:05.000]  Head, а tail никакого нет.
[01:21:05.000 --> 01:21:07.000]  Понятно, как это работать будет?
[01:21:07.000 --> 01:21:09.000]  Шаблонный union.
[01:21:11.000 --> 01:21:13.000]  Понятно ли,
[01:21:13.000 --> 01:21:15.000]  что size of такого union
[01:21:15.000 --> 01:21:17.000]  будет максимум
[01:21:17.000 --> 01:21:19.000]  из size of типов?
[01:21:19.000 --> 01:21:21.000]  Ну, максимум
[01:21:21.000 --> 01:21:23.000]  с точки корректировки на выравнивание.
[01:21:23.000 --> 01:21:25.000]  Сейчас вопрос.
[01:21:25.000 --> 01:21:27.000]  Он положит в память сначала head?
[01:21:27.000 --> 01:21:29.000]  Ой, сейчас, нет.
[01:21:29.000 --> 01:21:31.000]  Не совсем понятно,
[01:21:31.000 --> 01:21:33.000]  что значит union от tail
[01:21:33.000 --> 01:21:35.000]  в плане как это работает.
[01:21:35.000 --> 01:21:37.000]  Ну, как это? U с шаблонным параметром tail
[01:21:37.000 --> 01:21:39.000]  наготовишь. U вот с таким пакетом параметров.
[01:21:39.000 --> 01:21:41.000]  Если я сделаю U от int
[01:21:41.000 --> 01:21:43.000]  double string, например,
[01:21:43.000 --> 01:21:45.000]  то в нем будет лежать int,
[01:21:45.000 --> 01:21:47.000]  а еще union от double string.
[01:21:47.000 --> 01:21:49.000]  Это как бы рекурсивная штука,
[01:21:49.000 --> 01:21:51.000]  мы рекурсивно определяем их в список.
[01:21:51.000 --> 01:21:53.000]  Это немножко странно.
[01:21:53.000 --> 01:21:55.000]  Почему странно?
[01:21:55.000 --> 01:21:57.000]  Последним элементом надо N раз
[01:21:57.000 --> 01:21:59.000]  прошагать внутрь.
[01:21:59.000 --> 01:22:01.000]  Да, это правда. Это минус.
[01:22:01.000 --> 01:22:03.000]  Это недостаток такой реализации.
[01:22:03.000 --> 01:22:05.000]  Но это все будет в compile time
[01:22:05.000 --> 01:22:07.000]  делаться с другой стороны. То есть это
[01:22:07.000 --> 01:22:09.000]  линейное время, но и так компиляция.
[01:22:13.000 --> 01:22:15.000]  Понимаете? Ну, то есть если вы хотите
[01:22:15.000 --> 01:22:17.000]  считать из union последний его тип,
[01:22:17.000 --> 01:22:19.000]  то вам нужно как бы пройти
[01:22:19.000 --> 01:22:21.000]  по всему пакету типов,
[01:22:21.000 --> 01:22:23.000]  проверяя, это тот тип, какой надо или нет,
[01:22:23.000 --> 01:22:25.000]  и наконец вы достанете его.
[01:22:25.000 --> 01:22:27.000]  Но это будет линейное время
[01:22:27.000 --> 01:22:29.000]  в compile time, а не в run time.
[01:22:29.000 --> 01:22:31.000]  Вообще непонятно.
[01:22:31.000 --> 01:22:33.000]  Я же не могу обратиться
[01:22:33.000 --> 01:22:35.000]  от первого к union
[01:22:35.000 --> 01:22:37.000]  к третьему элементу,
[01:22:37.000 --> 01:22:39.000]  потому что это будет второй элемент второго union,
[01:22:39.000 --> 01:22:41.000]  который у меня лежит внутри.
[01:22:41.000 --> 01:22:43.000]  То есть я не могу писать union от 3,
[01:22:43.000 --> 01:22:45.000]  мне нужно написать union от 2 от 2.
[01:22:45.000 --> 01:22:47.000]  Что значит union от 3?
[01:22:47.000 --> 01:22:49.000]  Что такое union от 3?
[01:22:49.000 --> 01:22:51.000]  Я ничего не понимаю.
[01:22:51.000 --> 01:22:53.000]  У union нет никаких методов,
[01:22:53.000 --> 01:22:55.000]  union это зарезервировано
[01:22:55.000 --> 01:22:57.000]  в языке, это вид типов.
[01:22:57.000 --> 01:22:59.000]  Никаких методов у union нет,
[01:22:59.000 --> 01:23:01.000]  пока мы их не определим.
[01:23:01.000 --> 01:23:03.000]  Мы сейчас сами их будем определять.
[01:23:03.000 --> 01:23:05.000]  Вот у варианта есть метод,
[01:23:05.000 --> 01:23:07.000]  точнее не метод, а внешняя функция.
[01:23:07.000 --> 01:23:09.000]  Есть гент, который принимает вариант
[01:23:09.000 --> 01:23:11.000]  и индекс. И вот она-то как раз
[01:23:11.000 --> 01:23:13.000]  будет шагать по этому union,
[01:23:13.000 --> 01:23:15.000]  пока не дает методов.
[01:23:15.000 --> 01:23:17.000]  Вот у варианта есть метод,
[01:23:17.000 --> 01:23:19.000]  точнее не метод, а внешняя функция.
[01:23:19.000 --> 01:23:21.000]  У меня сейчас будет шагать по этому union,
[01:23:21.000 --> 01:23:23.000]  пока не дойдет до того,
[01:23:23.000 --> 01:23:25.000]  что тип, что его спросили, совпадает
[01:23:25.000 --> 01:23:27.000]  с типом, какой она видит.
[01:23:27.000 --> 01:23:29.000]  И пока не досчитает счетчик.
[01:23:29.000 --> 01:23:31.000]  При этом она будет именно
[01:23:31.000 --> 01:23:33.000]  на этапе компиляции это делать.
[01:23:33.000 --> 01:23:35.000]  Можно это написать так,
[01:23:35.000 --> 01:23:37.000]  чтобы на этапе компиляции работала.
[01:23:37.000 --> 01:23:39.000]  Я предлагаю, если вы будете смотреть
[01:23:39.000 --> 01:23:41.000]  лекции прошлого года,
[01:23:41.000 --> 01:23:43.000]  хотя зачем, казалось.
[01:23:43.000 --> 01:23:47.000]  В общем, тут опять есть два подхода.
[01:23:47.000 --> 01:23:49.000]  Как и в реализации Function,
[01:23:49.000 --> 01:23:51.000]  есть два подхода в реализации Variant.
[01:23:51.000 --> 01:23:53.000]  Один из подходов сделан такой шаблонный union.
[01:23:53.000 --> 01:23:55.000]  Другой подход – это просто сделать
[01:23:55.000 --> 01:23:57.000]  массив char, локальный буфер.
[01:23:57.000 --> 01:24:01.000]  И вот в него напрямую писать.
[01:24:01.000 --> 01:24:03.000]  Без вознес union.
[01:24:03.000 --> 01:24:05.000]  Я, пожалуй, в этот раз предпочту
[01:24:05.000 --> 01:24:07.000]  второй подход, хотя можно
[01:24:07.000 --> 01:24:09.000]  и через union делать.
[01:24:09.000 --> 01:24:11.000]  Хотя в STL кажется сделано
[01:24:11.000 --> 01:24:13.000]  через шаблонный union.
[01:24:13.000 --> 01:24:15.000]  Я, если честно, не очень разбирался
[01:24:15.000 --> 01:24:17.000]  в STL, как это прямо там написано,
[01:24:17.000 --> 01:24:19.000]  ну, типа, идейно.
[01:24:19.000 --> 01:24:21.000]  Понятно, как, почему они
[01:24:21.000 --> 01:24:23.000]  предпочли делать через шаблонный union.
[01:24:23.000 --> 01:24:25.000]  Я, честно говоря, не знаю.
[01:24:25.000 --> 01:24:27.000]  Но как будто бы...
[01:24:27.000 --> 01:24:29.000]  Ну, есть преимущественные
[01:24:29.000 --> 01:24:31.000]  недостатки у такого и у другого подхода.
[01:24:31.000 --> 01:24:33.000]  Вы можете сами когда-нибудь реализовывать,
[01:24:33.000 --> 01:24:35.000]  если будете реализовывать, писать и так, и так.
[01:24:35.000 --> 01:24:37.000]  В прошлом году я показывал
[01:24:37.000 --> 01:24:39.000]  подход через шаблонный union.
[01:24:39.000 --> 01:24:41.000]  В этом году давайте я все-таки
[01:24:41.000 --> 01:24:43.000]  сделаю без union, а просто сделаю
[01:24:43.000 --> 01:24:45.000]  буфер
[01:24:45.000 --> 01:24:47.000]  ну, просто обычной чары,
[01:24:47.000 --> 01:24:49.000]  короче, буду хранить. Массив чаров просто буду хранить.
[01:24:49.000 --> 01:24:51.000]  Вот.
[01:24:51.000 --> 01:24:53.000]  Это...
[01:24:53.000 --> 01:24:55.000]  Ну, дальше мы увидим.
[01:24:55.000 --> 01:24:57.000]  Это наложит определенные там...
[01:24:57.000 --> 01:24:59.000]  Возможно, местами это
[01:24:59.000 --> 01:25:01.000]  сделает ход чуть
[01:25:03.000 --> 01:25:05.000]  короче, но зато там чуть менее
[01:25:05.000 --> 01:25:07.000]  безопасным. Ну...
[01:25:07.000 --> 01:25:09.000]  Можете чуть-чуть вернуть назад на секунду?
[01:25:09.000 --> 01:25:11.000]  Ну, вернул.
[01:25:11.000 --> 01:25:13.000]  Ага.
[01:25:13.000 --> 01:25:15.000]  А, ну да.
[01:25:15.000 --> 01:25:17.000]  Короче, давайте
[01:25:17.000 --> 01:25:19.000]  просто хранить массив чаров.
[01:25:21.000 --> 01:25:23.000]  Буфер.
[01:25:23.000 --> 01:25:25.000]  Какого размера?
[01:25:29.000 --> 01:25:31.000]  Ну, max...
[01:25:31.000 --> 01:25:33.000]  Как это сделать? Как это написать?
[01:25:33.000 --> 01:25:35.000]  Вот тут начинается проблема. Пока у нас был union,
[01:25:35.000 --> 01:25:37.000]  это само считалось.
[01:25:37.000 --> 01:25:39.000]  Но зато нужно было шагать
[01:25:39.000 --> 01:25:41.000]  по union-у линейно в компиляции.
[01:25:41.000 --> 01:25:43.000]  Как нам размер буфера понять?
[01:25:43.000 --> 01:25:45.000]  Какой?
[01:25:49.000 --> 01:25:51.000]  Мы, кажется, можем... Типа, вот как мы делали
[01:25:51.000 --> 01:25:53.000]  с compile time вычислениями,
[01:25:53.000 --> 01:25:55.000]  мы можем как-то...
[01:25:55.000 --> 01:25:57.000]  Да, нам нужна
[01:25:57.000 --> 01:25:59.000]  метафункция, которая вычисляет...
[01:25:59.000 --> 01:26:01.000]  Нет какой-нибудь size of
[01:26:01.000 --> 01:26:03.000]  3.
[01:26:03.000 --> 01:26:05.000]  Size of 3. делает не то. Size of 3.
[01:26:05.000 --> 01:26:07.000]  вычитает количество типов в пакете.
[01:26:07.000 --> 01:26:09.000]  Нам нужен максимальный размер
[01:26:09.000 --> 01:26:11.000]  типа из пакета.
[01:26:11.000 --> 01:26:13.000]  Нам нужна метафункция,
[01:26:13.000 --> 01:26:15.000]  которая будет
[01:26:21.000 --> 01:26:23.000]  вычислять
[01:26:31.000 --> 01:26:33.000]  максимальный размер для данного множества типов.
[01:26:37.000 --> 01:26:39.000]  Ну,
[01:26:39.000 --> 01:26:41.000]  я не буду ее писать.
[01:26:43.000 --> 01:26:45.000]  Вы ее сами реализуете.
[01:26:47.000 --> 01:26:49.000]  Get max size of
[01:26:49.000 --> 01:26:51.000]  Давайте я здесь просто напишу static const
[01:26:51.000 --> 01:26:53.000]  size t
[01:26:53.000 --> 01:26:55.000]  value
[01:26:55.000 --> 01:26:57.000]  равно, не знаю, 128
[01:26:57.000 --> 01:26:59.000]  нам для всех нужд этого хватит.
[01:26:59.000 --> 01:27:01.000]  Вот.
[01:27:01.000 --> 01:27:03.000]  Можно даже 64
[01:27:03.000 --> 01:27:05.000]  написать. Я не думаю,
[01:27:05.000 --> 01:27:07.000]  что-то буду хранить большего размера.
[01:27:07.000 --> 01:27:09.000]  Короче,
[01:27:09.000 --> 01:27:11.000]  а буфер вот такого размера,
[01:27:11.000 --> 01:27:13.000]  но вы напишите свою функцию, которая
[01:27:13.000 --> 01:27:15.000]  значит
[01:27:15.000 --> 01:27:17.000]  вычисляет правильный размер.
[01:27:17.000 --> 01:27:19.000]  Еще чего не хватает,
[01:27:19.000 --> 01:27:21.000]  если мы так пишем.
[01:27:21.000 --> 01:27:23.000]  Вот мы такой буфер
[01:27:23.000 --> 01:27:25.000]  завели. Что еще не хватает ему?
[01:27:29.000 --> 01:27:31.000]  Если в такой буфер прямо сейчас
[01:27:31.000 --> 01:27:33.000]  писать начать, то это вообще говоря
[01:27:33.000 --> 01:27:35.000]  есть
[01:27:35.000 --> 01:27:37.000]  alignment
[01:27:37.000 --> 01:27:39.000]  Конечно, нужно align
[01:27:39.000 --> 01:27:41.000]  align s
[01:27:41.000 --> 01:27:43.000]  Он, кстати, можно вроде после
[01:27:43.000 --> 01:27:45.000]  типа писать.
[01:27:45.000 --> 01:27:47.000]  Опять, здесь нужно правильно вычислить,
[01:27:47.000 --> 01:27:49.000]  какой alignment. Но я не буду париться,
[01:27:49.000 --> 01:27:51.000]  напишу max align t.
[01:27:51.000 --> 01:27:53.000]  Вы, если будете писать,
[01:27:53.000 --> 01:27:55.000]  вам лучше запариться.
[01:27:57.000 --> 01:27:59.000]  Давайте я проверю, что все у меня
[01:27:59.000 --> 01:28:01.000]  на данный момент работает.
[01:28:03.000 --> 01:28:05.000]  Alignment t у меня не
[01:28:05.000 --> 01:28:07.000]  определено ожидаемо.
[01:28:07.000 --> 01:28:09.000]  Я уже теперь помню
[01:28:09.000 --> 01:28:11.000]  C, S, T, D, D, F.
[01:28:23.000 --> 01:28:25.000]  Видимо, надо все-таки
[01:28:25.000 --> 01:28:27.000]  слева писать что-ли.
[01:28:33.000 --> 01:28:35.000]  Да, интересно.
[01:28:35.000 --> 01:28:37.000]  Все-таки слева надо писать было типа.
[01:28:37.000 --> 01:28:39.000]  Окей, буфер.
[01:28:41.000 --> 01:28:43.000]  Что еще надо?
[01:28:43.000 --> 01:28:45.000]  Надо хранить индекс типа.
[01:28:45.000 --> 01:28:47.000]  Мы никак
[01:28:47.000 --> 01:28:49.000]  не можем этого избежать,
[01:28:49.000 --> 01:28:51.000]  потому что в рантайме нам где-то надо
[01:28:51.000 --> 01:28:53.000]  помнить, какой тип сейчас хранится.
[01:28:53.000 --> 01:28:55.000]  Иначе никак. Нам нужен какой-то
[01:28:55.000 --> 01:28:57.000]  индекс.
[01:28:57.000 --> 01:28:59.000]  Давайте я скажу, что это unsigned int.
[01:28:59.000 --> 01:29:01.000]  Ну или sizeT.
[01:29:01.000 --> 01:29:03.000]  Все равно выравнивать
[01:29:03.000 --> 01:29:05.000]  придется по 16,
[01:29:05.000 --> 01:29:07.000]  поэтому не сильно я потеряю.
[01:29:07.000 --> 01:29:09.000]  SizeT current
[01:29:09.000 --> 01:29:11.000]  index
[01:29:11.000 --> 01:29:13.000]  равно 0, допустим.
[01:29:15.000 --> 01:29:17.000]  На самом деле, хороший вопрос,
[01:29:17.000 --> 01:29:19.000]  почему он равен по умолчанию.
[01:29:19.000 --> 01:29:21.000]  Кстати, по умолчанию он как раз и должен быть равен 0, правда?
[01:29:21.000 --> 01:29:23.000]  Ведь мы, если создаем вариант
[01:29:23.000 --> 01:29:25.000]  по умолчанию, то он инициализируется первым
[01:29:25.000 --> 01:29:27.000]  из своих типов.
[01:29:27.000 --> 01:29:29.000]  Вот.
[01:29:29.000 --> 01:29:31.000]  Окей.
[01:29:31.000 --> 01:29:33.000]  Давайте что-нибудь
[01:29:33.000 --> 01:29:35.000]  какие-нибудь реализуем методы.
[01:29:35.000 --> 01:29:37.000]  Сначала простые какие-нибудь методы.
[01:29:37.000 --> 01:29:39.000]  Например,
[01:29:39.000 --> 01:29:41.000]  что у нас
[01:29:41.000 --> 01:29:43.000]  простое? Например, get.
[01:29:43.000 --> 01:29:45.000]  Вот как сделать get из варианта?
[01:29:45.000 --> 01:29:47.000]  Это легко
[01:29:47.000 --> 01:29:49.000]  должно быть.
[01:29:49.000 --> 01:29:51.000]  Только опять-таки нам понадобятся
[01:29:51.000 --> 01:29:53.000]  разные метафункции.
[01:29:53.000 --> 01:29:55.000]  Get – это
[01:29:55.000 --> 01:29:57.000]  внешняя функция, шаблонная.
[01:29:59.000 --> 01:30:01.000]  Template
[01:30:01.000 --> 01:30:03.000]  typeName
[01:30:03.000 --> 01:30:05.000]  Get бывает
[01:30:05.000 --> 01:30:07.000]  по индексу, а бывает по типу.
[01:30:07.000 --> 01:30:09.000]  Вот.
[01:30:09.000 --> 01:30:11.000]  Ну давайте сделаем get по индексу.
[01:30:13.000 --> 01:30:15.000]  Template
[01:30:15.000 --> 01:30:17.000]  sizeTn
[01:30:17.000 --> 01:30:19.000]  typeName
[01:30:19.000 --> 01:30:21.000]  многоточие types.
[01:30:21.000 --> 01:30:23.000]  А
[01:30:23.000 --> 01:30:25.000]  какой тип
[01:30:25.000 --> 01:30:27.000]  должен быть возвращаемый
[01:30:27.000 --> 01:30:29.000]  у функции get?
[01:30:29.000 --> 01:30:31.000]  Ну я напишу авто get
[01:30:33.000 --> 01:30:35.000]  без параметров
[01:30:35.000 --> 01:30:37.000]  стрелочка.
[01:30:37.000 --> 01:30:39.000]  Какой возвращаемый тип должен быть?
[01:30:39.000 --> 01:30:41.000]  Я из варианта
[01:30:41.000 --> 01:30:43.000]  по индексу n, а
[01:30:43.000 --> 01:30:45.000]  какой же, что же я делаю,
[01:30:45.000 --> 01:30:47.000]  вариант амперсам
[01:30:47.000 --> 01:30:49.000]  v.
[01:30:49.000 --> 01:30:51.000]  Get передаю в вариант.
[01:30:51.000 --> 01:30:53.000]  stget
[01:30:53.000 --> 01:30:55.000]  с шаблонным параметром int,
[01:30:55.000 --> 01:30:57.000]  ну шаблонным параметром число.
[01:30:57.000 --> 01:30:59.000]  Вот объекта варианта.
[01:30:59.000 --> 01:31:01.000]  Какой у него возвращаемый тип?
[01:31:01.000 --> 01:31:03.000]  Первый вопрос.
[01:31:03.000 --> 01:31:05.000]  Какой?
[01:31:09.000 --> 01:31:11.000]  Очевидная какая-то метафункция,
[01:31:11.000 --> 01:31:13.000]  которая…
[01:31:13.000 --> 01:31:15.000]  Это элемент пакета как бы.
[01:31:15.000 --> 01:31:17.000]  Вообще кажется, что подойдет
[01:31:17.000 --> 01:31:19.000]  амперсам или
[01:31:19.000 --> 01:31:21.000]  деплтайп от авто.
[01:31:21.000 --> 01:31:23.000]  Ну можно и прогресс.
[01:31:23.000 --> 01:31:25.000]  Кажется, что подойдет
[01:31:25.000 --> 01:31:27.000]  авто амперсам.
[01:31:27.000 --> 01:31:29.000]  Но я не уверен. Сейчас мы напишем
[01:31:29.000 --> 01:31:31.000]  и потом подумаем.
[01:31:31.000 --> 01:31:33.000]  Или вы подумаете. Я напишу пока так,
[01:31:33.000 --> 01:31:35.000]  но вы когда будете тесты проходить,
[01:31:35.000 --> 01:31:37.000]  возможно вы поймете, что
[01:31:37.000 --> 01:31:39.000]  это не всегда подходит, а надо что-то более умное.
[01:31:39.000 --> 01:31:41.000]  А что по существу надо сделать здесь?
[01:31:41.000 --> 01:31:43.000]  У варианта, наверное, надо аргумент
[01:31:43.000 --> 01:31:45.000]  указать в шаблоне.
[01:31:45.000 --> 01:31:47.000]  Это правда, кстати.
[01:31:47.000 --> 01:31:49.000]  Вариант от параметров types как раз.
[01:31:49.000 --> 01:31:51.000]  Нам нужна функция,
[01:31:51.000 --> 01:31:53.000]  которая… Нам нужно это элемент
[01:31:53.000 --> 01:31:55.000]  пакета достать.
[01:31:55.000 --> 01:31:57.000]  Нам нужно достать это и по счету элемент
[01:31:57.000 --> 01:31:59.000]  пакета.
[01:31:59.000 --> 01:32:01.000]  И скастовать к нему…
[01:32:01.000 --> 01:32:03.000]  Гуфер.
[01:32:03.000 --> 01:32:05.000]  Вот. Но этого мало.
[01:32:05.000 --> 01:32:07.000]  Нам надо бросить исключение.
[01:32:07.000 --> 01:32:09.000]  А что мы будем делать?
[01:32:09.000 --> 01:32:11.000]  Но этого мало. Нам надо бросить исключение,
[01:32:11.000 --> 01:32:13.000]  если тип вариант на самом деле не такой был.
[01:32:15.000 --> 01:32:17.000]  Нам нужно проверить, правда ли
[01:32:17.000 --> 01:32:19.000]  текущий тип в…
[01:32:19.000 --> 01:32:21.000]  Еще надо проверить, видимо, что n лежит
[01:32:21.000 --> 01:32:23.000]  в количестве аргументов.
[01:32:23.000 --> 01:32:25.000]  Ну, адекватное, короче.
[01:32:25.000 --> 01:32:27.000]  Ну, вот если
[01:32:27.000 --> 01:32:29.000]  n больше, чем sizeOfTypes,
[01:32:29.000 --> 01:32:31.000]  то это можно
[01:32:31.000 --> 01:32:33.000]  compileTimeError сделать.
[01:32:33.000 --> 01:32:35.000]  Как мы n,
[01:32:35.000 --> 01:32:37.000]  если оно не шаблонное,
[01:32:37.000 --> 01:32:39.000]  передадим в эту функцию?
[01:32:39.000 --> 01:32:41.000]  Кстати, на счет n меньше
[01:32:41.000 --> 01:32:43.000]  или равно, чем sizeOf
[01:32:43.000 --> 01:32:45.000]  многоточие Types.
[01:32:45.000 --> 01:32:47.000]  Это просто compileTime
[01:32:47.000 --> 01:32:49.000]  проверка. Чего-чего?
[01:32:49.000 --> 01:32:51.000]  Илья, каким образом у нас функция get
[01:32:51.000 --> 01:32:53.000]  будет работать только с числами вычислимыми
[01:32:53.000 --> 01:32:55.000]  в compileTime?
[01:32:55.000 --> 01:32:57.000]  Даже строго меньше.
[01:32:57.000 --> 01:32:59.000]  Каким образом что функция… Что еще раз?
[01:32:59.000 --> 01:33:01.000]  Get… Это шаблонный параметр
[01:33:01.000 --> 01:33:03.000]  get. Мы пишем std get
[01:33:03.000 --> 01:33:05.000]  от какого-то
[01:33:05.000 --> 01:33:07.000]  шаблонного параметра
[01:33:07.000 --> 01:33:09.000]  от варианта.
[01:33:09.000 --> 01:33:11.000]  n вычислимых в compileTime.
[01:33:11.000 --> 01:33:13.000]  Ну, так разве у
[01:33:13.000 --> 01:33:15.000]  варианта нету какой-то функции,
[01:33:15.000 --> 01:33:17.000]  которая позволяет получить его n
[01:33:17.000 --> 01:33:19.000]  и параметр,
[01:33:19.000 --> 01:33:21.000]  где n вычисляется в runTime?
[01:33:21.000 --> 01:33:23.000]  Нет.
[01:33:23.000 --> 01:33:25.000]  А каким образом это вообще можно сделать,
[01:33:25.000 --> 01:33:27.000]  по-твоему?
[01:33:27.000 --> 01:33:29.000]  Мне нужно…
[01:33:33.000 --> 01:33:35.000]  Ну, это довольно бессмысленно.
[01:33:35.000 --> 01:33:37.000]  Во-первых, кажется,
[01:33:37.000 --> 01:33:39.000]  это довольно бессмысленное желание,
[01:33:39.000 --> 01:33:41.000]  потому что
[01:33:45.000 --> 01:33:47.000]  n и параметров…
[01:33:51.000 --> 01:33:53.000]  Потому что пакет типов
[01:33:53.000 --> 01:33:55.000]  он же в compileTime известен.
[01:33:55.000 --> 01:33:57.000]  А вы хотите в runTime
[01:33:57.000 --> 01:33:59.000]  из пакета типов вытащить
[01:33:59.000 --> 01:34:01.000]  какой-то тип? Это, кажется,
[01:34:01.000 --> 01:34:03.000]  какая-то глупость. Ну как?
[01:34:03.000 --> 01:34:05.000]  У вас пакет типов-то зафиксирован
[01:34:05.000 --> 01:34:07.000]  в compileTime,
[01:34:07.000 --> 01:34:09.000]  и вы хотите в runTime
[01:34:11.000 --> 01:34:13.000]  выбирать какой-то из него.
[01:34:13.000 --> 01:34:15.000]  Но вам же нужно, чтобы возвращаемое значение
[01:34:15.000 --> 01:34:17.000]  имело какой-то конкретный тип.
[01:34:17.000 --> 01:34:19.000]  У вас же должно быть возвращаемый тип каким-то конкретным.
[01:34:19.000 --> 01:34:21.000]  О, get.
[01:34:21.000 --> 01:34:23.000]  Вы ушли бы тогда просто
[01:34:23.000 --> 01:34:25.000]  и вам тогда вариант никакой пользы не приносит.
[01:34:25.000 --> 01:34:27.000]  Либо, если вы пользуетесь get,
[01:34:27.000 --> 01:34:29.000]  то у get должен быть
[01:34:29.000 --> 01:34:31.000]  конкретный возвращаемый тип.
[01:34:31.000 --> 01:34:33.000]  Но конкретный возвращаемый тип нельзя в runTime
[01:34:33.000 --> 01:34:35.000]  определять.
[01:34:35.000 --> 01:34:37.000]  На прошлом занятии я показывал,
[01:34:37.000 --> 01:34:39.000]  что, на самом деле, когда он генерировал разные лямбды,
[01:34:39.000 --> 01:34:41.000]  то там просто лямбда генерируется на каждый из возможных
[01:34:41.000 --> 01:34:43.000]  вариантов и просто вызывает нужную функцию.
[01:34:43.000 --> 01:34:45.000]  Почему здесь нельзя сделать
[01:34:45.000 --> 01:34:47.000]  то же самое? Просто загенерировать функции для всех n,
[01:34:47.000 --> 01:34:49.000]  потому что, понятно, все они известны.
[01:34:49.000 --> 01:34:51.000]  После этого вызывать в runTime нужную функцию, которая нам нужна.
[01:34:51.000 --> 01:34:53.000]  Нет, мы будем писать visit.
[01:34:53.000 --> 01:34:55.000]  Visit – это другое.
[01:34:55.000 --> 01:34:57.000]  Visit работает так,
[01:34:57.000 --> 01:34:59.000]  что у него
[01:34:59.000 --> 01:35:01.000]  на каждый тип
[01:35:01.000 --> 01:35:03.000]  того, что может лежать в варианте,
[01:35:03.000 --> 01:35:05.000]  теоретически есть своя операция,
[01:35:05.000 --> 01:35:07.000]  и вы, просто вызывая visit,
[01:35:07.000 --> 01:35:09.000]  решаете, какая операция вызывается.
[01:35:09.000 --> 01:35:11.000]  Но по факту...
[01:35:11.000 --> 01:35:13.000]  Вот visit.get сделать, просто.
[01:35:13.000 --> 01:35:15.000]  Что значит visit.get?
[01:35:15.000 --> 01:35:17.000]  Ну, это значит сделать get, который будет
[01:35:17.000 --> 01:35:19.000]  вгенерировать код для получения
[01:35:19.000 --> 01:35:21.000]  типа каждого из
[01:35:21.000 --> 01:35:23.000]  вариантов, которые можно будет получать в runTime.
[01:35:29.000 --> 01:35:31.000]  Нет, я не понимаю. Давай ты скажешь
[01:35:31.000 --> 01:35:33.000]  сначала, какую ты хочешь сигнатуру функций
[01:35:33.000 --> 01:35:35.000]  иметь. Что ты хочешь, чтобы можно было
[01:35:35.000 --> 01:35:37.000]  делать? Есть вариант.
[01:35:37.000 --> 01:35:39.000]  Просто мы...
[01:35:39.000 --> 01:35:41.000]  Я не понимаю, в чем запрос
[01:35:41.000 --> 01:35:43.000]  состоит. Вот у меня есть вариант int double
[01:35:43.000 --> 01:35:45.000]  и std string, допустим.
[01:35:45.000 --> 01:35:47.000]  И я положил в него, я не знаю,
[01:35:47.000 --> 01:35:49.000]  там, 5.0.
[01:35:49.000 --> 01:35:51.000]  И дальше, что я должен...
[01:35:51.000 --> 01:35:53.000]  Ты хочешь функцию, которая что позволяет сделать?
[01:35:53.000 --> 01:35:55.000]  И что она возвращать
[01:35:55.000 --> 01:35:57.000]  должна? Отличный вопрос.
[01:35:57.000 --> 01:35:59.000]  Самый главный. Просто функция get,
[01:35:59.000 --> 01:36:01.000]  у нее возвращаемый тип, это tmperson,
[01:36:01.000 --> 01:36:03.000]  где t – это тип того, что ты попросил
[01:36:03.000 --> 01:36:05.000]  достать. Я хочу сделать
[01:36:05.000 --> 01:36:07.000]  n перегрузок на каждый тип
[01:36:07.000 --> 01:36:09.000]  варианта.
[01:36:09.000 --> 01:36:11.000]  Хочу сделать n перегрузок на каждый...
[01:36:11.000 --> 01:36:13.000]  на каждый вариант того, что будет представляться
[01:36:13.000 --> 01:36:15.000]  в n, чтобы возвращался
[01:36:15.000 --> 01:36:17.000]  соответствующий тип, который соответствует
[01:36:17.000 --> 01:36:19.000]  n-кому параметру варианта.
[01:36:19.000 --> 01:36:21.000]  Причем так, чтобы...
[01:36:21.000 --> 01:36:23.000]  Короче, я хочу просто сделать get, который работает
[01:36:23.000 --> 01:36:25.000]  в runtime.
[01:36:25.000 --> 01:36:27.000]  Какой у него будет возвращаемый тип?
[01:36:27.000 --> 01:36:29.000]  У него будут разные
[01:36:29.000 --> 01:36:31.000]  возвращаемые типы в зависимости от перегрузки от того,
[01:36:31.000 --> 01:36:33.000]  что... Как может быть разный возвращаемый тип?
[01:36:33.000 --> 01:36:35.000]  Get – это будет внешняя
[01:36:35.000 --> 01:36:37.000]  функция или метод варианта?
[01:36:37.000 --> 01:36:39.000]  Метод варианта.
[01:36:39.000 --> 01:36:41.000]  Какой у него
[01:36:41.000 --> 01:36:43.000]  будет возвращаемый тип? Вот здесь будет
[01:36:43.000 --> 01:36:45.000]  написано template или что?
[01:36:45.000 --> 01:36:47.000]  Это будет шаблонный метод или нет?
[01:36:47.000 --> 01:36:49.000]  Так он будет...
[01:36:49.000 --> 01:36:51.000]  Проблема, что я не понимаю, как это реализовано.
[01:36:51.000 --> 01:36:53.000]  Ну никак.
[01:36:53.000 --> 01:36:55.000]  Ну никак.
[01:36:55.000 --> 01:36:57.000]  Ну с visit-ом эта проблема обходится...
[01:36:57.000 --> 01:36:59.000]  В смысле, ты не понимаешь, как visit работает.
[01:36:59.000 --> 01:37:01.000]  Да, именно.
[01:37:01.000 --> 01:37:03.000]  Давай мы отложим это наконец,
[01:37:03.000 --> 01:37:05.000]  потому что сейчас мы, кажется, очень сложные проблемы
[01:37:05.000 --> 01:37:07.000]  начали обсуждать. Мы...
[01:37:07.000 --> 01:37:09.000]  Как visit работает, мы обсудим в конце.
[01:37:09.000 --> 01:37:11.000]  Вот, я надеюсь, успеем.
[01:37:11.000 --> 01:37:13.000]  Так не сможет работать.
[01:37:13.000 --> 01:37:15.000]  Хорошо, вопрос такой сразу.
[01:37:15.000 --> 01:37:17.000]  Если мы знаем, как работает visit, можно ли через visit
[01:37:17.000 --> 01:37:19.000]  реализовать get, который будет работать как visit?
[01:37:19.000 --> 01:37:21.000]  Ну, кажется, да.
[01:37:21.000 --> 01:37:23.000]  Ну, ты как минимум можешь из visit-а
[01:37:23.000 --> 01:37:25.000]  возвращать просто...
[01:37:25.000 --> 01:37:27.000]  Ну как, ссылку на
[01:37:27.000 --> 01:37:29.000]  то, что ты...
[01:37:29.000 --> 01:37:31.000]  Ну, ты делаешь visit,
[01:37:31.000 --> 01:37:33.000]  варианта...
[01:37:33.000 --> 01:37:35.000]  Значит, ты делаешь visit,
[01:37:35.000 --> 01:37:37.000]  и в visit в перегрузке принимаешь
[01:37:37.000 --> 01:37:39.000]  авто&x.
[01:37:39.000 --> 01:37:41.000]  Ты можешь просто вернуть этот x
[01:37:41.000 --> 01:37:43.000]  наружу из visit-а.
[01:37:43.000 --> 01:37:45.000]  И вот тебе будет visit, который возвращает тебе ссылку
[01:37:45.000 --> 01:37:47.000]  на то, что он получил
[01:37:47.000 --> 01:37:49.000]  в качестве параметра.
[01:37:51.000 --> 01:37:53.000]  Ну, а как бы тип...
[01:37:53.000 --> 01:37:55.000]  В смысле, что такое x?
[01:37:55.000 --> 01:37:57.000]  Ну, это не будет работать для всех наборов типов,
[01:37:57.000 --> 01:37:59.000]  потому что возвращаемый тип visit-а
[01:37:59.000 --> 01:38:01.000]  либо придется явно указывать, либо он
[01:38:01.000 --> 01:38:03.000]  не сможет вычислиться, если типы несовместимые.
[01:38:03.000 --> 01:38:05.000]  Короче, это всё равно
[01:38:05.000 --> 01:38:07.000]  не сможет работать, если типы несовместимые.
[01:38:07.000 --> 01:38:09.000]  Если нельзя, общий тип
[01:38:09.000 --> 01:38:11.000]  найти для всех данных.
[01:38:11.000 --> 01:38:13.000]  Стоп, всё, нет.
[01:38:13.000 --> 01:38:15.000]  Закрыли вопрос слишком долго.
[01:38:15.000 --> 01:38:17.000]  Мы сейчас уже начнём услышать, как visit работает.
[01:38:17.000 --> 01:38:19.000]  Визит мы в конце обсудим.
[01:38:19.000 --> 01:38:21.000]  Get конкретный тип возвращает.
[01:38:21.000 --> 01:38:23.000]  Вот get должен вернуть тип, который
[01:38:23.000 --> 01:38:25.000]  реально мы запросили, и это в compile-time вычисляется.
[01:38:27.000 --> 01:38:29.000]  Так?
[01:38:29.000 --> 01:38:31.000]  Как работает get с одним шаблонным
[01:38:31.000 --> 01:38:33.000]  аргументом, когда мы пишем get int
[01:38:33.000 --> 01:38:35.000]  от варианта?
[01:38:37.000 --> 01:38:39.000]  Давай сначала напишем get от числа.
[01:38:39.000 --> 01:38:41.000]  Вот сейчас я реализую get от числа.
[01:38:41.000 --> 01:38:43.000]  Ну хорошо, но get2
[01:38:43.000 --> 01:38:45.000]  от варианта.
[01:38:45.000 --> 01:38:47.000]  В любом случае, вот мы сейчас пишем get, который
[01:38:47.000 --> 01:38:49.000]  ещё, помимо этого,
[01:38:49.000 --> 01:38:51.000]  принимает ещё пакет типов.
[01:38:51.000 --> 01:38:53.000]  Замечательно. get
[01:38:53.000 --> 01:38:55.000]  берёт
[01:38:55.000 --> 01:38:57.000]  первым шаблонным аргументом число,
[01:38:57.000 --> 01:38:59.000]  а принимает в качестве параметра
[01:38:59.000 --> 01:39:01.000]  он вариант.
[01:39:01.000 --> 01:39:03.000]  И у этого варианта
[01:39:03.000 --> 01:39:05.000]  шаблонными параметрами являются типы.
[01:39:07.000 --> 01:39:09.000]  Но поскольку это шаблонная функция,
[01:39:09.000 --> 01:39:11.000]  то здесь однозначно
[01:39:11.000 --> 01:39:13.000]  сопоставляется от каких шаблонных параметров
[01:39:13.000 --> 01:39:15.000]  вызывается get.
[01:39:15.000 --> 01:39:17.000]  Потому что мы передали в get вариант от конкретного
[01:39:17.000 --> 01:39:19.000]  набора типов,
[01:39:19.000 --> 01:39:21.000]  и компилятор
[01:39:21.000 --> 01:39:23.000]  может вывести эти types.
[01:39:23.000 --> 01:39:25.000]  Но мы же обсуждали, что
[01:39:25.000 --> 01:39:27.000]  частичный аргумент reduction
[01:39:27.000 --> 01:39:29.000]  не бывает.
[01:39:29.000 --> 01:39:31.000]  Для функций вообще-то бывает. Это для классов не бывает.
[01:39:31.000 --> 01:39:33.000]  А, хорошо.
[01:39:33.000 --> 01:39:35.000]  Для функций ты можешь указать
[01:39:35.000 --> 01:39:37.000]  часть, начальный
[01:39:37.000 --> 01:39:39.000]  префикс шаблонного параметра явно,
[01:39:39.000 --> 01:39:41.000]  остальные он выведет сам.
[01:39:41.000 --> 01:39:43.000]  У нас был даже пример
[01:39:43.000 --> 01:39:45.000]  связанный, кажется.
[01:39:45.000 --> 01:39:47.000]  Короче, для функций это работает.
[01:39:47.000 --> 01:39:49.000]  Так вот, что мы дальше пишем?
[01:39:49.000 --> 01:39:51.000]  Мы должны...
[01:39:51.000 --> 01:39:53.000]  Ну, мы сделали static assert,
[01:39:53.000 --> 01:39:55.000]  что n меньше, чем size of многоточие types.
[01:39:55.000 --> 01:39:57.000]  А дальше мы что делаем?
[01:39:57.000 --> 01:39:59.000]  Ну, мы просто по сути делаем
[01:39:59.000 --> 01:40:01.000]  static cast к ссылке
[01:40:01.000 --> 01:40:03.000]  на
[01:40:03.000 --> 01:40:05.000]  Ну, нам нужен
[01:40:05.000 --> 01:40:07.000]  using
[01:40:07.000 --> 01:40:09.000]  t
[01:40:09.000 --> 01:40:11.000]  равно
[01:40:11.000 --> 01:40:13.000]  get
[01:40:13.000 --> 01:40:15.000]  type
[01:40:15.000 --> 01:40:17.000]  by index
[01:40:17.000 --> 01:40:19.000]  от n
[01:40:19.000 --> 01:40:21.000]  запятая types.
[01:40:21.000 --> 01:40:23.000]  Нам опять нужна метафункция,
[01:40:23.000 --> 01:40:25.000]  которая по данному пакету типов
[01:40:25.000 --> 01:40:27.000]  возвращает n-й тип.
[01:40:27.000 --> 01:40:29.000]  Так.
[01:40:29.000 --> 01:40:31.000]  Как?
[01:40:33.000 --> 01:40:35.000]  get type by index
[01:40:35.000 --> 01:40:37.000]  знак подчеркивания t.
[01:40:37.000 --> 01:40:39.000]  Ну, или
[01:40:39.000 --> 01:40:41.000]  вот здесь type.
[01:40:41.000 --> 01:40:43.000]  И можно было и на месте писать.
[01:40:43.000 --> 01:40:45.000]  На месте? Не очень понятно. Как?
[01:40:45.000 --> 01:40:47.000]  Ну, просто взять head и закуститься
[01:40:47.000 --> 01:40:49.000]  от варианта, который без первого
[01:40:49.000 --> 01:40:51.000]  типа. Это мне не очень нравится,
[01:40:51.000 --> 01:40:53.000]  потому что это была бы
[01:40:53.000 --> 01:40:55.000]  рекурсия с функций,
[01:40:55.000 --> 01:40:57.000]  а я хочу, чтобы у меня
[01:40:57.000 --> 01:40:59.000]  не было вызова функций с функций.
[01:40:59.000 --> 01:41:01.000]  Я только метафункции хочу вызывать.
[01:41:01.000 --> 01:41:03.000]  Но это вроде понятно, как писать.
[01:41:03.000 --> 01:41:05.000]  Да, я сейчас тоже напишу заглушку
[01:41:05.000 --> 01:41:07.000]  template type name
[01:41:07.000 --> 01:41:09.000]  size tn
[01:41:11.000 --> 01:41:13.000]  type name многоточие types
[01:41:15.000 --> 01:41:17.000]  значит struct
[01:41:17.000 --> 01:41:19.000]  get type
[01:41:19.000 --> 01:41:21.000]  by index
[01:41:21.000 --> 01:41:23.000]  Ну, и здесь я напишу, не знаю, using type
[01:41:23.000 --> 01:41:25.000]  равно
[01:41:27.000 --> 01:41:29.000]  int
[01:41:29.000 --> 01:41:31.000]  Ну, я просто написал заглушку,
[01:41:31.000 --> 01:41:33.000]  но понятно, что вы реализуете сами.
[01:41:33.000 --> 01:41:35.000]  Хорошо.
[01:41:35.000 --> 01:41:37.000]  И что мы делаем?
[01:41:37.000 --> 01:41:39.000]  Просто мы делаем reinterpret cast
[01:41:41.000 --> 01:41:43.000]  к этому типу
[01:41:43.000 --> 01:41:45.000]  от нашего
[01:41:45.000 --> 01:41:47.000]  v.buffer
[01:41:49.000 --> 01:41:51.000]  Откуда мы берем буфер?
[01:41:51.000 --> 01:41:53.000]  Ну, нам надо, чтобы эта функция была другом
[01:41:53.000 --> 01:41:55.000]  варианта.
[01:41:55.000 --> 01:41:57.000]  Разумеется.
[01:41:57.000 --> 01:41:59.000]  То есть эта функция, она
[01:41:59.000 --> 01:42:01.000]  будет
[01:42:01.000 --> 01:42:03.000]  иметь доступ
[01:42:03.000 --> 01:42:05.000]  к приватным полям.
[01:42:05.000 --> 01:42:07.000]  Вопрос
[01:42:11.000 --> 01:42:13.000]  Ответ, на который
[01:42:13.000 --> 01:42:15.000]  опять-таки до него сложно догадаться.
[01:42:19.000 --> 01:42:21.000]  Вопрос на
[01:42:21.000 --> 01:42:23.000]  либо вы очень умные, либо вы
[01:42:23.000 --> 01:42:25.000]  знаете наперед.
[01:42:25.000 --> 01:42:27.000]  У вас наверняка мучил этот вопрос
[01:42:27.000 --> 01:42:29.000]  еще в прошлый раз. Почему get это внешняя
[01:42:29.000 --> 01:42:31.000]  функция, а не метод варианта?
[01:42:31.000 --> 01:42:33.000]  Кто догадается, тот супер молодец.
[01:42:33.000 --> 01:42:35.000]  Ну, комитет
[01:42:35.000 --> 01:42:37.000]  эту проблему понял сразу, и они
[01:42:37.000 --> 01:42:39.000]  сразу сделали get внешней функции.
[01:42:39.000 --> 01:42:41.000]  Почему плохо делать get методом
[01:42:41.000 --> 01:42:43.000]  варианта?
[01:42:43.000 --> 01:42:45.000]  Это ответ очень тупой
[01:42:45.000 --> 01:42:47.000]  и очень, даже не знаю, смешной, но
[01:42:47.000 --> 01:42:49.000]  вот тем
[01:42:49.000 --> 01:42:51.000]  не менее он не очевидный совершенно.
[01:42:51.000 --> 01:42:53.000]  Может быть, типа они
[01:42:53.000 --> 01:42:55.000]  один get вообще на все возможные
[01:42:55.000 --> 01:42:57.000]  типы написали.
[01:42:57.000 --> 01:42:59.000]  Что значит один get на все возможные?
[01:42:59.000 --> 01:43:01.000]  Есть get для тапла, есть
[01:43:01.000 --> 01:43:03.000]  get для варианта. Может быть, это
[01:43:03.000 --> 01:43:05.000]  одна и та же функция.
[01:43:05.000 --> 01:43:07.000]  Они же по-разному работать должны.
[01:43:07.000 --> 01:43:09.000]  Как это может быть?
[01:43:09.000 --> 01:43:11.000]  Это как-нибудь связано с абстрактными
[01:43:11.000 --> 01:43:13.000]  методами?
[01:43:13.000 --> 01:43:15.000]  Абстрактные методы?
[01:43:15.000 --> 01:43:17.000]  Может там будет какой-нибудь метод, который будет
[01:43:17.000 --> 01:43:19.000]  годным? Нет, у нас никакого
[01:43:19.000 --> 01:43:21.000]  верчевого
[01:43:21.000 --> 01:43:23.000]  варианта
[01:43:23.000 --> 01:43:25.000]  в варианте у нас не будет.
[01:43:25.000 --> 01:43:27.000]  У нас нет
[01:43:27.000 --> 01:43:29.000]  здесь никакого runtime полиморфизма
[01:43:29.000 --> 01:43:31.000]  с ранее типов. Есть тупая версия?
[01:43:31.000 --> 01:43:33.000]  Да, я знаю. Ответ
[01:43:33.000 --> 01:43:35.000]  и есть тупой. Ответ очень смешной и
[01:43:35.000 --> 01:43:37.000]  тупой.
[01:43:37.000 --> 01:43:39.000]  Предположение, что мы не хотим
[01:43:39.000 --> 01:43:41.000]  на получение
[01:43:41.000 --> 01:43:43.000]  видимо одного и того же типа
[01:43:43.000 --> 01:43:45.000]  кучу
[01:43:45.000 --> 01:43:47.000]  getов генерировать для разных
[01:43:47.000 --> 01:43:49.000]  вариантов.
[01:43:49.000 --> 01:43:51.000]  Там что-нибудь такое?
[01:43:51.000 --> 01:43:53.000]  Короче, нет. Я вам могу так
[01:43:53.000 --> 01:43:55.000]  сказать. Давайте представим, что я этот get
[01:43:55.000 --> 01:43:57.000]  сделал методом.
[01:43:57.000 --> 01:43:59.000]  Это будет подсказка сейчас.
[01:43:59.000 --> 01:44:01.000]  У нас много разных вариантов
[01:44:01.000 --> 01:44:03.000]  с одним и тем же типом. Вот, смотрите.
[01:44:03.000 --> 01:44:05.000]  Вот, допустим, я сделал вот эту функцию
[01:44:05.000 --> 01:44:07.000]  get методом варианта.
[01:44:07.000 --> 01:44:09.000]  Шаблоны? Что с шаблонами?
[01:44:09.000 --> 01:44:11.000]  У нас два разных шаблона для...
[01:44:11.000 --> 01:44:13.000]  Ну, хорошо.
[01:44:13.000 --> 01:44:15.000]  Сделал вот так.
[01:44:15.000 --> 01:44:17.000]  Types здесь убрал.
[01:44:17.000 --> 01:44:19.000]  Оставил только вот так.
[01:44:19.000 --> 01:44:21.000]  Там с порядком шаблона
[01:44:21.000 --> 01:44:23.000]  сюда все плохо.
[01:44:23.000 --> 01:44:25.000]  Может быть, какие-нибудь универсальные
[01:44:25.000 --> 01:44:27.000]  ссылки не сработают?
[01:44:27.000 --> 01:44:29.000]  Так, смотрите. Все сейчас вроде нормально.
[01:44:29.000 --> 01:44:31.000]  N это параметр число.
[01:44:31.000 --> 01:44:33.000]  Сам вариант имеет шаблонные
[01:44:33.000 --> 01:44:35.000]  параметры Types.
[01:44:35.000 --> 01:44:37.000]  Ну, все нормально.
[01:44:37.000 --> 01:44:39.000]  Так у нас порядок.
[01:44:39.000 --> 01:44:41.000]  Чего? У меня есть вариант.
[01:44:41.000 --> 01:44:43.000]  Я говорю .get с одним шаблонным параметром.
[01:44:43.000 --> 01:44:45.000]  С одним шаблонным параметром.
[01:44:45.000 --> 01:44:47.000]  В чем проблема?
[01:44:47.000 --> 01:44:49.000]  Это метод теперь.
[01:44:49.000 --> 01:44:51.000]  Теперь я пишу
[01:44:51.000 --> 01:44:53.000]  v.get double
[01:44:53.000 --> 01:44:55.000]  и точка запятой.
[01:44:55.000 --> 01:44:57.000]  По идее, должно вернуться double
[01:44:57.000 --> 01:44:59.000]  imperson.
[01:44:59.000 --> 01:45:01.000]  Да?
[01:45:01.000 --> 01:45:03.000]  Ну, хотелось бы.
[01:45:03.000 --> 01:45:05.000]  Вот. Это не скомпилируется, к сожалению.
[01:45:05.000 --> 01:45:07.000]  Ну, то есть, казалось бы,
[01:45:07.000 --> 01:45:09.000]  можно сделать get методом.
[01:45:09.000 --> 01:45:11.000]  Но тогда вот это не будет
[01:45:11.000 --> 01:45:13.000]  скомпилироваться.
[01:45:13.000 --> 01:45:15.000]  Знаете, почему?
[01:45:15.000 --> 01:45:17.000]  А догадайтесь, почему?
[01:45:17.000 --> 01:45:19.000]  Это из первого семестра вы должны знать,
[01:45:19.000 --> 01:45:21.000]  почему это скомпилируется.
[01:45:27.000 --> 01:45:29.000]  Ой, что double-то?
[01:45:33.000 --> 01:45:35.000]  Get от пяти.
[01:45:35.000 --> 01:45:37.000]  А, блин, нет.
[01:45:37.000 --> 01:45:39.000]  Сейчас, подождите, может это скомпилируется?
[01:45:39.000 --> 01:45:41.000]  Так, наверное, это скомпилируется.
[01:45:43.000 --> 01:45:45.000]  Ну, у нас статикасер сработает,
[01:45:45.000 --> 01:45:47.000]  потому что 5...
[01:45:47.000 --> 01:45:49.000]  Статикасер сработает. Почему 5-то я написал?
[01:45:49.000 --> 01:45:51.000]  Get один. Вот так вот.
[01:45:51.000 --> 01:45:53.000]  Сейчас, может, я вам наврал, и на самом деле это скомпилируется.
[01:45:55.000 --> 01:45:57.000]  А когда ты копировал,
[01:45:57.000 --> 01:45:59.000]  фигурная скобочка осталась.
[01:46:01.000 --> 01:46:03.000]  Чего?
[01:46:03.000 --> 01:46:05.000]  Вот фигурная скобочка лишнего
[01:46:05.000 --> 01:46:07.000]  в Friend.
[01:46:07.000 --> 01:46:09.000]  А, да.
[01:46:09.000 --> 01:46:11.000]  Хорошо.
[01:46:19.000 --> 01:46:21.000]  И с буфером еще что-то странное
[01:46:21.000 --> 01:46:23.000]  происходит.
[01:46:23.000 --> 01:46:25.000]  В общем, cast,
[01:46:25.000 --> 01:46:27.000]  ampersand от просто буфера кажется...
[01:46:27.000 --> 01:46:29.000]  Господи, почему не private, public?
[01:46:31.000 --> 01:46:33.000]  Почему?
[01:46:33.000 --> 01:46:35.000]  Нет, Sereniter. Перед кастом это все должно быть нормально.
[01:46:37.000 --> 01:46:39.000]  Вот здесь мне
[01:46:39.000 --> 01:46:41.000]  надо написать другое название
[01:46:41.000 --> 01:46:43.000]  шаблонного параметра template
[01:46:43.000 --> 01:46:45.000]  многоточие ts.
[01:46:45.000 --> 01:46:47.000]  Господи.
[01:46:47.000 --> 01:46:49.000]  Началось просто.
[01:46:49.000 --> 01:46:51.000]  Обожаю это.
[01:46:53.000 --> 01:46:55.000]  Да, у меня только одна проблема.
[01:46:55.000 --> 01:46:57.000]  У меня нет конструктора.
[01:46:57.000 --> 01:46:59.000]  Сейчас.
[01:46:59.000 --> 01:47:01.000]  Да, к сожалению, пример
[01:47:01.000 --> 01:47:03.000]  не сработал. Почему это не скомпилировалось?
[01:47:03.000 --> 01:47:05.000]  Очень жаль.
[01:47:05.000 --> 01:47:07.000]  Очень жаль.
[01:47:09.000 --> 01:47:11.000]  Ладно.
[01:47:11.000 --> 01:47:13.000]  Давайте я вам отвечу, почему get плохо.
[01:47:13.000 --> 01:47:15.000]  В данном случае это работает.
[01:47:15.000 --> 01:47:17.000]  Я еще много раз промотаю.
[01:47:17.000 --> 01:47:19.000]  Ты за мной
[01:47:19.000 --> 01:47:21.000]  записываешь, что ли?
[01:47:23.000 --> 01:47:25.000]  Да.
[01:47:25.000 --> 01:47:27.000]  Да, кстати, этот код я вам не скину.
[01:47:29.000 --> 01:47:31.000]  А то будет слишком...
[01:47:31.000 --> 01:47:33.000]  Запись ты скинешь. Запись скину, да.
[01:47:33.000 --> 01:47:35.000]  Я твой файл не скину.
[01:47:35.000 --> 01:47:37.000]  Ну ладно, руками перебьем.
[01:47:37.000 --> 01:47:39.000]  Сами будете писать.
[01:47:41.000 --> 01:47:43.000]  Вот ты молодец.
[01:47:43.000 --> 01:47:45.000]  Короче, это не будет
[01:47:45.000 --> 01:47:47.000]  работать. На самом деле этот вопрос
[01:47:47.000 --> 01:47:49.000]  не очевиден совершенно. В прошлом году его тоже
[01:47:49.000 --> 01:47:51.000]  задавали.
[01:47:51.000 --> 01:47:53.000]  Мы не сразу поняли. Я тоже не сразу понял
[01:47:53.000 --> 01:47:55.000]  почему. На самом деле ответ вот какой.
[01:47:55.000 --> 01:47:57.000]  Потому что если вы
[01:47:57.000 --> 01:47:59.000]  будете это делать
[01:47:59.000 --> 01:48:01.000]  из шаблонного кода,
[01:48:01.000 --> 01:48:03.000]  то я сейчас не в шаблонном коде.
[01:48:03.000 --> 01:48:05.000]  Но если бы я делал это в шаблонном коде,
[01:48:05.000 --> 01:48:07.000]  то вот такой метод обращения
[01:48:07.000 --> 01:48:09.000]  к нему было бы некорректным
[01:48:09.000 --> 01:48:11.000]  по причине это зависимое имя
[01:48:11.000 --> 01:48:13.000]  и нужно было бы писать template get.
[01:48:17.000 --> 01:48:19.000]  То есть мы просто не хотим писать
[01:48:19.000 --> 01:48:21.000]  template каждый раз, поэтому делаем...
[01:48:21.000 --> 01:48:23.000]  Представьте, что мы находимся в функции
[01:48:23.000 --> 01:48:25.000]  template,
[01:48:25.000 --> 01:48:27.000]  typeName
[01:48:27.000 --> 01:48:29.000]  многоточие types,
[01:48:29.000 --> 01:48:31.000]  которая
[01:48:31.000 --> 01:48:33.000]  f
[01:48:35.000 --> 01:48:37.000]  и она объявляет здесь вариант
[01:48:37.000 --> 01:48:39.000]  от types.
[01:48:39.000 --> 01:48:41.000]  многоточие v.
[01:48:41.000 --> 01:48:43.000]  Вот. И если я эту штуку
[01:48:43.000 --> 01:48:45.000]  инстанцирую с каким-нибудь там
[01:48:45.000 --> 01:48:47.000]  int main
[01:48:49.000 --> 01:48:51.000]  Господи.
[01:48:51.000 --> 01:48:53.000]  int main и я сделаю f
[01:48:53.000 --> 01:48:55.000]  с шаблонным параметром int double
[01:48:55.000 --> 01:48:57.000]  std string,
[01:48:57.000 --> 01:48:59.000]  то вот здесь я окажусь
[01:48:59.000 --> 01:49:01.000]  в шаблонном коде
[01:49:01.000 --> 01:49:03.000]  и...
[01:49:09.000 --> 01:49:11.000]  Видите, что начало происходить?
[01:49:11.000 --> 01:49:13.000]  invalid operands of types
[01:49:13.000 --> 01:49:15.000]  unresolved overloaded function type
[01:49:15.000 --> 01:49:17.000]  и int
[01:49:17.000 --> 01:49:19.000]  к бинарному оператору меньше.
[01:49:23.000 --> 01:49:25.000]  Никогда такого не было и вот опять.
[01:49:25.000 --> 01:49:27.000]  Если у вас types это шаблонный параметр
[01:49:27.000 --> 01:49:29.000]  а это часто вообще
[01:49:29.000 --> 01:49:31.000]  это нормальная ситуация, что types это у вас
[01:49:31.000 --> 01:49:33.000]  короче это у вас зависимое
[01:49:33.000 --> 01:49:35.000]  имя и get парсится как
[01:49:35.000 --> 01:49:37.000]  поле, а не как шаблон
[01:49:37.000 --> 01:49:39.000]  и это воспринимается как оператор
[01:49:39.000 --> 01:49:41.000]  меньше. И чтобы это парсилось
[01:49:41.000 --> 01:49:43.000]  правильно, нужно писать v.template
[01:49:43.000 --> 01:49:45.000]  get.
[01:49:45.000 --> 01:49:47.000]  Если бы мы с вами
[01:49:47.000 --> 01:49:49.000]  реализовали через union, то у нас бы
[01:49:51.000 --> 01:49:53.000]  мы бы столкнулись с этой проблемой раньше.
[01:49:53.000 --> 01:49:55.000]  Но в общем
[01:49:55.000 --> 01:49:57.000]  это просто вопрос
[01:49:57.000 --> 01:49:59.000]  на Stack Overflow есть. Почему get не метод?
[01:49:59.000 --> 01:50:01.000]  Да вот почему, потому что иначе
[01:50:01.000 --> 01:50:03.000]  всегда бы вам пришлось template get писать,
[01:50:03.000 --> 01:50:05.000]  а не просто get. Это очень неудобно.
[01:50:05.000 --> 01:50:07.000]  Поэтому мы так не делаем, а get
[01:50:07.000 --> 01:50:09.000]  считаем, что это у нас
[01:50:09.000 --> 01:50:11.000]  внешняя функция.
[01:50:13.000 --> 01:50:15.000]  Не std get, а просто get
[01:50:15.000 --> 01:50:17.000]  от одного, например
[01:50:17.000 --> 01:50:19.000]  от нашего варианта.
[01:50:19.000 --> 01:50:21.000]  Сейчас еще раз глупой вопрос. Почему
[01:50:21.000 --> 01:50:23.000]  get парсится? Почему в конкретном случае
[01:50:23.000 --> 01:50:25.000]  она парсится? Потому что
[01:50:25.000 --> 01:50:27.000]  type v это зависимое
[01:50:27.000 --> 01:50:29.000]  имя.
[01:50:29.000 --> 01:50:31.000]  v зависит от того, что такое type.
[01:50:31.000 --> 01:50:33.000]  В зависимости от того, что такое type, get могло быть
[01:50:33.000 --> 01:50:35.000]  как полем, так и типом,
[01:50:35.000 --> 01:50:37.000]  так и шаблоном.
[01:50:37.000 --> 01:50:39.000]  Получание парсится как поле.
[01:50:39.000 --> 01:50:41.000]  А можете еще раз наверх?
[01:50:45.000 --> 01:50:47.000]  Ты можешь скрин сделать
[01:50:47.000 --> 01:50:49.000]  и переписывать там сколько тебе надо.
[01:50:51.000 --> 01:50:53.000]  А
[01:50:53.000 --> 01:50:55.000]  так, еще
[01:50:55.000 --> 01:50:57.000]  должно быть get по типу.
[01:50:57.000 --> 01:50:59.000]  Ну давайте get по типу я не буду писать,
[01:50:59.000 --> 01:51:01.000]  его сами тоже напишете.
[01:51:01.000 --> 01:51:03.000]  Ну то есть, что должен проверять get по типу?
[01:51:03.000 --> 01:51:05.000]  Get по типу, во-первых, должен проверять, что
[01:51:05.000 --> 01:51:07.000]  тип единственный в пакете,
[01:51:07.000 --> 01:51:09.000]  ну еще он ровно один вообще.
[01:51:09.000 --> 01:51:11.000]  Статика все на этом. А дальше он просто
[01:51:11.000 --> 01:51:13.000]  должен делать reinterpret cast к этому типу опять.
[01:51:15.000 --> 01:51:17.000]  Самая интересная
[01:51:17.000 --> 01:51:19.000]  часть.
[01:51:19.000 --> 01:51:21.000]  Одна из самых интересных частей,
[01:51:21.000 --> 01:51:23.000]  их сейчас будет несколько.
[01:51:23.000 --> 01:51:25.000]  Конструкторы.
[01:51:25.000 --> 01:51:27.000]  Давайте напишем конструктор варианта.
[01:51:27.000 --> 01:51:29.000]  Конструктор от
[01:51:31.000 --> 01:51:33.000]  t,
[01:51:33.000 --> 01:51:35.000]  где t это то, что мы вариант
[01:51:35.000 --> 01:51:37.000]  положить хотим.
[01:51:41.000 --> 01:51:43.000]  Template,
[01:51:43.000 --> 01:51:45.000]  type name t,
[01:51:45.000 --> 01:51:47.000]  variant
[01:51:47.000 --> 01:51:49.000]  от
[01:51:49.000 --> 01:51:51.000]  ну опять-таки понятно, что
[01:51:51.000 --> 01:51:53.000]  должен быть конструктор как от rvalue
[01:51:53.000 --> 01:51:55.000]  так и от lvalue.
[01:51:55.000 --> 01:51:57.000]  И на самом деле
[01:51:57.000 --> 01:51:59.000]  можно написать, что мы здесь делаем
[01:51:59.000 --> 01:52:01.000]  универсальную ссылку, но это все я
[01:52:01.000 --> 01:52:03.000]  короче опущу, вы сами это все сделаете,
[01:52:03.000 --> 01:52:05.000]  как полагается, там у вас будет
[01:52:05.000 --> 01:52:07.000]  значит,
[01:52:07.000 --> 01:52:09.000]  вы стоили посмотрите, увидите от чего там
[01:52:09.000 --> 01:52:11.000]  должен быть конструктор. Значит, эту всю
[01:52:11.000 --> 01:52:13.000]  историю я опущу.
[01:52:13.000 --> 01:52:15.000]  Будем считать, что просто стандартно от конста
[01:52:15.000 --> 01:52:17.000]  конструктора.
[01:52:17.000 --> 01:52:19.000]  Что надо сделать здесь?
[01:52:19.000 --> 01:52:21.000]  У кого-нибудь есть идеи вообще?
[01:52:21.000 --> 01:52:23.000]  Что написать?
[01:52:27.000 --> 01:52:29.000]  И вообще так ли надо написать?
[01:52:29.000 --> 01:52:31.000]  То есть как
[01:52:31.000 --> 01:52:33.000]  осознайте проблемы.
[01:52:39.000 --> 01:52:41.000]  Ну понятно, да, что я могу сказать
[01:52:41.000 --> 01:52:43.000]  new от буфера,
[01:52:43.000 --> 01:52:45.000]  но это совсем не то, что нам нужно.
[01:52:47.000 --> 01:52:49.000]  Это конструктор варианта, какой
[01:52:49.000 --> 01:52:51.000]  предыдущий?
[01:52:51.000 --> 01:52:53.000]  Но это работает совсем не так,
[01:52:53.000 --> 01:52:55.000]  как нужно. Это слишком
[01:52:55.000 --> 01:52:57.000]  примитивно.
[01:52:57.000 --> 01:52:59.000]  Это не то, чем мы хотим от варианта.
[01:52:59.000 --> 01:53:01.000]  Это наивная очень реализация конструктора,
[01:53:01.000 --> 01:53:03.000]  не так все должно работать. Почему?
[01:53:03.000 --> 01:53:05.000]  Что здесь не так будет работать?
[01:53:05.000 --> 01:53:07.000]  Главная особенность варианта,
[01:53:07.000 --> 01:53:09.000]  которая непонятная,
[01:53:09.000 --> 01:53:11.000]  которая в самом начале,
[01:53:11.000 --> 01:53:13.000]  я в прошлом акцентировал внимание,
[01:53:13.000 --> 01:53:15.000]  как должен себя вести вариант,
[01:53:15.000 --> 01:53:17.000]  если мы вызываем конструктор какого-то
[01:53:17.000 --> 01:53:19.000]  Т.
[01:53:23.000 --> 01:53:25.000]  Но карантиндекс нужно подвинуть.
[01:53:25.000 --> 01:53:27.000]  Да и это не в суть.
[01:53:27.000 --> 01:53:29.000]  Тут принципиально все неправильно
[01:53:29.000 --> 01:53:31.000]  работает. Никакой
[01:53:31.000 --> 01:53:33.000]  плейсмент юзди не получится так
[01:53:33.000 --> 01:53:35.000]  реализовать конструктор. Ну то есть получится,
[01:53:35.000 --> 01:53:37.000]  но будет работать неправильно.
[01:53:41.000 --> 01:53:43.000]  Ну еще раз,
[01:53:43.000 --> 01:53:45.000]  если я...
[01:53:45.000 --> 01:53:47.000]  Так у нас могут быть какие-то ссылки в полях,
[01:53:47.000 --> 01:53:49.000]  указатели, которые
[01:53:49.000 --> 01:53:51.000]  нельзя вот так сделать.
[01:53:51.000 --> 01:53:53.000]  Все мимо.
[01:53:53.000 --> 01:53:55.000]  У меня есть вариант от int и double,
[01:53:55.000 --> 01:53:57.000]  и я его конструирую от float.
[01:53:57.000 --> 01:53:59.000]  Должен создаться double, а не float.
[01:54:01.000 --> 01:54:03.000]  Конструктор должен
[01:54:03.000 --> 01:54:05.000]  работать по правилам перегрузки, мы же
[01:54:05.000 --> 01:54:07.000]  про это говорили час назад.
[01:54:07.000 --> 01:54:09.000]  Я должен
[01:54:09.000 --> 01:54:11.000]  выбрать тип из своего
[01:54:11.000 --> 01:54:13.000]  types, который наиболее предпочтителен
[01:54:13.000 --> 01:54:15.000]  для конверсии t в него,
[01:54:15.000 --> 01:54:17.000]  и его создать из этого t.
[01:54:17.000 --> 01:54:19.000]  А как вообще это писать тогда?
[01:54:19.000 --> 01:54:21.000]  В этом и вопрос главный.
[01:54:21.000 --> 01:54:23.000]  А мы не можем... А можно создать
[01:54:23.000 --> 01:54:25.000]  конструктора от всех типов, которые у нас
[01:54:25.000 --> 01:54:27.000]  есть, и потом
[01:54:27.000 --> 01:54:29.000]  просто вызвать отдельные фронты.
[01:54:29.000 --> 01:54:31.000]  Как их всех объявить-то
[01:54:31.000 --> 01:54:33.000]  эти конструкторы? У тебя ж не будет
[01:54:33.000 --> 01:54:35.000]  выбираться вроде из шамлонов.
[01:54:35.000 --> 01:54:37.000]  У меня есть вариант от 3 точья, как
[01:54:37.000 --> 01:54:39.000]  оператор.
[01:54:39.000 --> 01:54:41.000]  С многоточем
[01:54:41.000 --> 01:54:43.000]  только using можно писать.
[01:54:43.000 --> 01:54:45.000]  Метод объявить новый
[01:54:45.000 --> 01:54:47.000]  через многоточие нельзя.
[01:54:47.000 --> 01:54:49.000]  Вроде
[01:54:49.000 --> 01:54:51.000]  может быть можно создать какой-то вспоминательный
[01:54:51.000 --> 01:54:53.000]  класс, шаблонный, который
[01:54:53.000 --> 01:54:55.000]  будет как раз
[01:54:55.000 --> 01:54:57.000]  отвечать каким-то образом
[01:54:57.000 --> 01:54:59.000]  за конструирование,
[01:54:59.000 --> 01:55:01.000]  и для него написать using, что-то там.
[01:55:01.000 --> 01:55:03.000]  На самом деле
[01:55:03.000 --> 01:55:05.000]  нам потребуется...
[01:55:05.000 --> 01:55:07.000]  Единственный способ,
[01:55:07.000 --> 01:55:09.000]  известный мне,
[01:55:09.000 --> 01:55:11.000]  и кажется, что в ASTL
[01:55:11.000 --> 01:55:13.000]  также сделано.
[01:55:13.000 --> 01:55:15.000]  Единственный способ, известный мне,
[01:55:15.000 --> 01:55:17.000]  это через наследование
[01:55:17.000 --> 01:55:19.000]  и using
[01:55:19.000 --> 01:55:21.000]  многоточие.
[01:55:23.000 --> 01:55:25.000]  Мы сейчас
[01:55:25.000 --> 01:55:27.000]  сделаем переменное количество
[01:55:27.000 --> 01:55:29.000]  наследников
[01:55:29.000 --> 01:55:31.000]  в каждом из которых
[01:55:31.000 --> 01:55:33.000]  определим конструктор
[01:55:33.000 --> 01:55:35.000]  от соответствующего t
[01:55:35.000 --> 01:55:37.000]  и внесем их все
[01:55:37.000 --> 01:55:39.000]  в нашу область видимости
[01:55:39.000 --> 01:55:41.000]  через using с многоточием.
[01:55:43.000 --> 01:55:45.000]  Смотрите, что будет написано.
[01:55:47.000 --> 01:55:49.000]  Я заведу такой шаблонный
[01:55:49.000 --> 01:55:51.000]  класс.
[01:55:55.000 --> 01:55:57.000]  Назову его...
[01:55:57.000 --> 01:55:59.000]  Давайте я заведу это вообще структурой.
[01:55:59.000 --> 01:56:01.000]  Variant choice.
[01:56:03.000 --> 01:56:05.000]  И в нем
[01:56:05.000 --> 01:56:07.000]  будет...
[01:56:09.000 --> 01:56:11.000]  Я свой вариант сделаю
[01:56:11.000 --> 01:56:13.000]  приватным наследником, приватным,
[01:56:13.000 --> 01:56:15.000]  потому что никому не надо об этом знать.
[01:56:17.000 --> 01:56:19.000]  Variant choice от types многоточия.
[01:56:21.000 --> 01:56:23.000]  Мой вариант, это будет
[01:56:23.000 --> 01:56:25.000]  наследник от переменного количества таких
[01:56:25.000 --> 01:56:27.000]  choice.
[01:56:27.000 --> 01:56:29.000]  И в variant choice я напишу следующее.
[01:56:33.000 --> 01:56:35.000]  Так, нет.
[01:56:35.000 --> 01:56:37.000]  Это я что-то забежал вперед.
[01:56:37.000 --> 01:56:39.000]  Мне надо в
[01:56:39.000 --> 01:56:41.000]  variant choice
[01:56:41.000 --> 01:56:43.000]  сделать конструктор
[01:56:43.000 --> 01:56:45.000]  от данного t.
[01:56:49.000 --> 01:56:51.000]  И этот конструктор должен взять
[01:56:51.000 --> 01:56:53.000]  и прямо
[01:56:53.000 --> 01:56:55.000]  у нас есть буфер
[01:56:55.000 --> 01:56:57.000]  нужный объект t.
[01:56:57.000 --> 01:56:59.000]  Откуда он буфер возьмет?
[01:57:01.000 --> 01:57:03.000]  А для этого ему нужно
[01:57:03.000 --> 01:57:05.000]  посчитать, что он и есть вариант.
[01:57:05.000 --> 01:57:07.000]  Но это так на самом деле и есть.
[01:57:09.000 --> 01:57:11.000]  То есть ему нужно
[01:57:11.000 --> 01:57:13.000]  сделать static cast себя
[01:57:13.000 --> 01:57:15.000]  как будто он вариант.
[01:57:15.000 --> 01:57:17.000]  Но он и есть вариант. Мы как бы и приватно
[01:57:17.000 --> 01:57:19.000]  наследуемся. Это такой
[01:57:19.000 --> 01:57:21.000]  CRTP в каком-то смысле.
[01:57:21.000 --> 01:57:23.000]  Вот, например, мы
[01:57:23.000 --> 01:57:25.000]  берем вариант
[01:57:25.000 --> 01:57:27.000]  и делаем его
[01:57:27.000 --> 01:57:29.000]  наследником
[01:57:31.000 --> 01:57:33.000]  variant choice
[01:57:33.000 --> 01:57:35.000]  от него самого.
[01:57:35.000 --> 01:57:37.000]  На самом деле я могу вот так сделать.
[01:57:37.000 --> 01:57:39.000]  Здесь сказать variant
[01:57:39.000 --> 01:57:41.000]  с шаблонным параметром types.
[01:57:41.000 --> 01:57:43.000]  Но можно и лучше.
[01:57:43.000 --> 01:57:45.000]  То есть смотрите, что я делаю.
[01:57:45.000 --> 01:57:47.000]  Я говорю,
[01:57:47.000 --> 01:57:49.000]  вот здесь вот я хочу
[01:57:49.000 --> 01:57:51.000]  соответствующего варианта,
[01:57:51.000 --> 01:57:53.000]  из которого я сейчас
[01:57:53.000 --> 01:57:55.000]  создал, как бы создаюсь.
[01:57:55.000 --> 01:57:57.000]  Понимаете, что я пытаюсь сказать?
[01:57:57.000 --> 01:57:59.000]  Короче, я говорю
[01:57:59.000 --> 01:58:01.000]  using
[01:58:01.000 --> 01:58:03.000]  derived
[01:58:03.000 --> 01:58:05.000]  равно, и вот здесь говорю,
[01:58:05.000 --> 01:58:07.000]  какой тип. Это будет
[01:58:07.000 --> 01:58:09.000]  вариант с
[01:58:09.000 --> 01:58:11.000]  шаблонным параметром types.
[01:58:11.000 --> 01:58:13.000]  А откуда я узнаю types?
[01:58:13.000 --> 01:58:15.000]  А
[01:58:15.000 --> 01:58:17.000]  а я их
[01:58:17.000 --> 01:58:19.000]  передам сюда.
[01:58:43.000 --> 01:58:45.000]  Вы что-то говорите?
[01:58:45.000 --> 01:58:47.000]  Нет, я просто
[01:58:47.000 --> 01:58:49.000]  печатаю.
[01:58:51.000 --> 01:58:53.000]  По сути, вот что здесь должно быть
[01:58:53.000 --> 01:58:55.000]  написано.
[01:58:57.000 --> 01:58:59.000]  Осознайте это.
[01:59:05.000 --> 01:59:07.000]  А у нас не должно быть случайно
[01:59:07.000 --> 01:59:09.000]  варианта
[01:59:09.000 --> 01:59:11.000]  с шаблонным параметром
[01:59:11.000 --> 01:59:13.000]  types?
[01:59:13.000 --> 01:59:15.000]  Это правда.
[01:59:15.000 --> 01:59:17.000]  Должно быть, конечно.
[01:59:19.000 --> 01:59:21.000]  Потому что мы его используем
[01:59:21.000 --> 01:59:23.000]  не объявив.
[01:59:23.000 --> 01:59:25.000]  Тут еще одна есть проблема,
[01:59:25.000 --> 01:59:27.000]  но это все технические
[01:59:27.000 --> 01:59:29.000]  проблемы, вы суть осознайте.
[01:59:29.000 --> 01:59:31.000]  Значит,
[01:59:31.000 --> 01:59:33.000]  много проблем на самом деле.
[01:59:33.000 --> 01:59:35.000]  Понятно суть
[01:59:35.000 --> 01:59:37.000]  фокуса.
[01:59:37.000 --> 01:59:39.000]  Что я сделал благодаря наследованию
[01:59:39.000 --> 01:59:41.000]  такого количества родителей.
[02:00:01.000 --> 02:00:03.000]  Ну, у нас теперь есть конструкторы, которые будут
[02:00:03.000 --> 02:00:05.000]  вводиться в этом по правилам выда функций.
[02:00:05.000 --> 02:00:07.000]  Да.
[02:00:07.000 --> 02:00:09.000]  Вот здесь я напишу
[02:00:11.000 --> 02:00:13.000]  using
[02:00:13.000 --> 02:00:15.000]  variant
[02:00:15.000 --> 02:00:17.000]  choice от
[02:00:17.000 --> 02:00:19.000]  types
[02:00:19.000 --> 02:00:21.000]  variant choice
[02:00:21.000 --> 02:00:23.000]  многоточие.
[02:00:27.000 --> 02:00:29.000]  То есть, я взял и унаследовал,
[02:00:29.000 --> 02:00:31.000]  как бы, внес в свою областительность
[02:00:31.000 --> 02:00:33.000]  все конструкторы variant choice.
[02:00:33.000 --> 02:00:35.000]  Напоминаю, что using
[02:00:35.000 --> 02:00:37.000]  variant choice можно применять к родительским конструкторам в наследнике.
[02:00:37.000 --> 02:00:39.000]  Я взял
[02:00:39.000 --> 02:00:41.000]  и как бы сказал, что меня можно создавать
[02:00:41.000 --> 02:00:43.000]  от любого из того,
[02:00:43.000 --> 02:00:45.000]  из чего можно создавать было своих родителей.
[02:00:45.000 --> 02:00:47.000]  Я сказал, что пусть у меня
[02:00:47.000 --> 02:00:49.000]  будут конструкторы от всех
[02:00:49.000 --> 02:00:51.000]  тех типов,
[02:00:51.000 --> 02:00:53.000]  от которых можно было создавать
[02:00:53.000 --> 02:00:55.000]  моих родителей. А моих родителей
[02:00:55.000 --> 02:00:57.000]  можно было создавать от всех
[02:00:57.000 --> 02:00:59.000]  те, я как бы сделал
[02:00:59.000 --> 02:01:01.000]  наследование вот от такой штуки.
[02:01:01.000 --> 02:01:03.000]  Смотрите, допустим, если у меня есть
[02:01:03.000 --> 02:01:05.000]  понимаете, как это работает? У меня хитрая конструкция,
[02:01:05.000 --> 02:01:07.000]  у меня здесь многоточие,
[02:01:07.000 --> 02:01:09.000]  угловая скобка закрылась и снова многоточие.
[02:01:09.000 --> 02:01:11.000]  Как это работает?
[02:01:11.000 --> 02:01:13.000]  Если у меня есть,
[02:01:13.000 --> 02:01:15.000]  допустим, вариант
[02:01:17.000 --> 02:01:19.000]  а
[02:01:19.000 --> 02:01:21.000]  если у меня есть вариант какой-нибудь
[02:01:21.000 --> 02:01:23.000]  от int
[02:01:23.000 --> 02:01:25.000]  double
[02:01:25.000 --> 02:01:27.000]  string,
[02:01:27.000 --> 02:01:29.000]  то он получается наследник
[02:01:29.000 --> 02:01:31.000]  следующих вещей. Variant
[02:01:31.000 --> 02:01:33.000]  choice
[02:01:33.000 --> 02:01:35.000]  от int
[02:01:35.000 --> 02:01:37.000]  а потом int double
[02:01:37.000 --> 02:01:39.000]  string
[02:01:41.000 --> 02:01:43.000]  еще он наследует
[02:01:43.000 --> 02:01:45.000]  вариант choice
[02:01:47.000 --> 02:01:49.000]  от double
[02:01:49.000 --> 02:01:51.000]  а потом int double string
[02:01:53.000 --> 02:01:55.000]  а потом он еще
[02:01:55.000 --> 02:01:57.000]  наследует вариант choice
[02:01:57.000 --> 02:01:59.000]  от string
[02:01:59.000 --> 02:02:01.000]  int double string
[02:02:03.000 --> 02:02:05.000]  То есть у variant
[02:02:05.000 --> 02:02:07.000]  choice шаблонный параметр является
[02:02:07.000 --> 02:02:09.000]  некоторый тип, а дальше весь пакет.
[02:02:09.000 --> 02:02:11.000]  И у меня таких типов
[02:02:11.000 --> 02:02:13.000]  создается столько штук, сколько типов в пакете types.
[02:02:13.000 --> 02:02:15.000]  Вот что здесь на самом деле написано.
[02:02:15.000 --> 02:02:17.000]  Унаследуйся, пожалуйста,
[02:02:17.000 --> 02:02:19.000]  от variant choice вот со всеми
[02:02:19.000 --> 02:02:21.000]  такими возможными шаблонными
[02:02:21.000 --> 02:02:23.000]  аргументами. Вот этот пакет
[02:02:23.000 --> 02:02:25.000]  распаковывается вот здесь
[02:02:25.000 --> 02:02:27.000]  и превращается в перечтение int double string
[02:02:27.000 --> 02:02:29.000]  а вот это распаковывается внешним
[02:02:29.000 --> 02:02:31.000]  многоточием и получается, что у меня
[02:02:31.000 --> 02:02:33.000]  переменное количество родителей.
[02:02:35.000 --> 02:02:37.000]  Двойная распаковка пакета здесь происходит.
[02:02:39.000 --> 02:02:41.000]  Вопросы?
[02:02:49.000 --> 02:02:51.000]  Можете, пожалуйста, сказать, как мы
[02:02:51.000 --> 02:02:53.000]  вот в этот variant приписали?
[02:02:53.000 --> 02:02:55.000]  Мне очень на самом деле
[02:02:55.000 --> 02:02:57.000]  грустно, что у нас онлайн сегодня.
[02:02:57.000 --> 02:02:59.000]  Мы все еще сделали
[02:02:59.000 --> 02:03:01.000]  конструктор только от T, который
[02:03:01.000 --> 02:03:03.000]  мы передавали в variant.
[02:03:03.000 --> 02:03:05.000]  Я тут все еще ору просто
[02:03:05.000 --> 02:03:07.000]  с выключенным микрофоном.
[02:03:07.000 --> 02:03:09.000]  Да-да-да, вот я говорю, я очень жалею, я очень бы хотел,
[02:03:09.000 --> 02:03:11.000]  чтобы именно эта пара была онлайн,
[02:03:11.000 --> 02:03:13.000]  потому что, оффлайн, потому что мне не хватает
[02:03:13.000 --> 02:03:15.000]  эмоциональных комментариев от господина Васюка.
[02:03:15.000 --> 02:03:17.000]  Я просто как бы вот уже
[02:03:17.000 --> 02:03:19.000]  представляю себе,
[02:03:19.000 --> 02:03:21.000]  как он бы это прокомментировал,
[02:03:21.000 --> 02:03:23.000]  просто пока здесь сидишь
[02:03:23.000 --> 02:03:25.000]  и нифига не понимаешь,
[02:03:25.000 --> 02:03:27.000]  ты молчишь на камеру,
[02:03:27.000 --> 02:03:29.000]  а если в классе, то ты
[02:03:29.000 --> 02:03:31.000]  не молчишь, ты кричишь.
[02:03:31.000 --> 02:03:33.000]  Да, мне сейчас не достает вот это.
[02:03:33.000 --> 02:03:35.000]  Зато вот материться можно, все нормально.
[02:03:35.000 --> 02:03:37.000]  Эмоциональная реакция зала, да, что за черт происходит?
[02:03:37.000 --> 02:03:39.000]  Ну вот, ну ничего, не волнуйтесь,
[02:03:39.000 --> 02:03:41.000]  у нас еще с вами будет...
[02:03:41.000 --> 02:03:43.000]  Я все равно не особо понял.
[02:03:43.000 --> 02:03:45.000]  Каждой оставшейся паре у нас будет что-то подобное,
[02:03:45.000 --> 02:03:47.000]  поэтому мы еще насладимся, так сказать,
[02:03:47.000 --> 02:03:49.000]  всеми возможными возгласами.
[02:03:49.000 --> 02:03:51.000]  Можете, пожалуйста, юзинг показать?
[02:03:51.000 --> 02:03:53.000]  Да, вопрос, подождите, был задан вопрос.
[02:03:53.000 --> 02:03:55.000]  Мы же все равно сделали конструктор
[02:03:55.000 --> 02:03:57.000]  только от тех t, от которых
[02:03:57.000 --> 02:03:59.000]  которые были в пакете.
[02:03:59.000 --> 02:04:01.000]  Это правда, но
[02:04:01.000 --> 02:04:03.000]  теперь у нас
[02:04:03.000 --> 02:04:05.000]  эти все конструкторы внесены как обычные функции
[02:04:05.000 --> 02:04:07.000]  сюда, это уже не шаблонные
[02:04:07.000 --> 02:04:09.000]  функции, они
[02:04:09.000 --> 02:04:11.000]  сюда внесены, таким образом у нас,
[02:04:11.000 --> 02:04:13.000]  у меня как бы в варианте есть
[02:04:13.000 --> 02:04:15.000]  конструктор от int, конструктор от double,
[02:04:15.000 --> 02:04:17.000]  конструктор от string, они внесены
[02:04:17.000 --> 02:04:19.000]  как самостоятельные функции в этом
[02:04:19.000 --> 02:04:21.000]  области видимости, таким образом,
[02:04:21.000 --> 02:04:23.000]  кстати, вот это мне надо удалить, оно же не работает,
[02:04:23.000 --> 02:04:25.000]  таким образом
[02:04:25.000 --> 02:04:27.000]  у меня
[02:04:27.000 --> 02:04:29.000]  когда я создаю вариант от чего-то,
[02:04:29.000 --> 02:04:31.000]  выбирается версия из этих
[02:04:31.000 --> 02:04:33.000]  трех по правилам перегрузки, потому что
[02:04:33.000 --> 02:04:35.000]  у меня как раз таки вот эти три версии
[02:04:35.000 --> 02:04:37.000]  здесь и внесены в область видимости.
[02:04:37.000 --> 02:04:39.000]  У меня ровно столько версий, сколько типов
[02:04:39.000 --> 02:04:41.000]  для каждого своя, и они не шаблонные,
[02:04:41.000 --> 02:04:43.000]  поэтому подстав в шаблон там не делается,
[02:04:43.000 --> 02:04:45.000]  выбирается подходящая по правилам
[02:04:45.000 --> 02:04:47.000]  перегрузки.
[02:04:47.000 --> 02:04:49.000]  А вы можете скопилировать код?
[02:04:51.000 --> 02:04:53.000]  Не знаю, давайте попробуем.
[02:04:53.000 --> 02:04:55.000]  Там еще кажется в юзинге
[02:04:55.000 --> 02:04:57.000]  нужно пакет
[02:04:57.000 --> 02:04:59.000]  дописать. Вот у меня такая же ошибка
[02:04:59.000 --> 02:05:01.000]  просто кажется.
[02:05:05.000 --> 02:05:07.000]  Вот здесь кажется нужно пакет
[02:05:07.000 --> 02:05:09.000]  дописать. Да, не хватило,
[02:05:09.000 --> 02:05:11.000]  здесь нужен пакет.
[02:05:11.000 --> 02:05:13.000]  Type, во-первых, вот
[02:05:13.000 --> 02:05:15.000]  так.
[02:05:15.000 --> 02:05:17.000]  А сейчас будет еще одна ошибка,
[02:05:17.000 --> 02:05:19.000]  скорее всего.
[02:05:23.000 --> 02:05:25.000]  Не хватает конструктора
[02:05:25.000 --> 02:05:27.000]  по умолчанию ему еще?
[02:05:27.000 --> 02:05:29.000]  Он жалуется, что не хватает конструктора
[02:05:29.000 --> 02:05:31.000]  по умолчанию.
[02:05:43.000 --> 02:05:45.000]  Значит, в variant-choice
[02:05:45.000 --> 02:05:47.000]  нужен конструктор по умолчанию, кажется.
[02:05:47.000 --> 02:05:49.000]  Не знаю, чем
[02:05:49.000 --> 02:05:51.000]  вызвано это требование.
[02:05:51.000 --> 02:05:53.000]  Вот.
[02:05:53.000 --> 02:05:55.000]  И...
[02:05:55.000 --> 02:05:57.000]  Давайте, наверное,
[02:05:57.000 --> 02:05:59.000]  можно догадаться, чем это требование
[02:05:59.000 --> 02:06:01.000]  вызвано.
[02:06:01.000 --> 02:06:03.000]  Тут написано, что
[02:06:03.000 --> 02:06:05.000]  не хватает конструктора
[02:06:05.000 --> 02:06:07.000]  по умолчанию.
[02:06:07.000 --> 02:06:09.000]  И...
[02:06:09.000 --> 02:06:11.000]  И...
[02:06:11.000 --> 02:06:13.000]  Написано, что
[02:06:15.000 --> 02:06:17.000]  конструктор
[02:06:17.000 --> 02:06:19.000]  от const double and percent is implicitly deleted
[02:06:19.000 --> 02:06:21.000]  because the default definition would be ill-formed.
[02:06:21.000 --> 02:06:23.000]  variant-choice
[02:06:23.000 --> 02:06:25.000]  variant-choice без параметров
[02:06:25.000 --> 02:06:27.000]  отсутствует.
[02:06:31.000 --> 02:06:33.000]  Почему-то...
[02:06:37.000 --> 02:06:39.000]  Почему-то он хочет,
[02:06:39.000 --> 02:06:41.000]  что был конструктор без параметров.
[02:06:45.000 --> 02:06:47.000]  Не знаю, почему, если честно.
[02:06:47.000 --> 02:06:49.000]  Не помню.
[02:06:49.000 --> 02:06:51.000]  Надо почитать правила.
[02:06:51.000 --> 02:06:53.000]  Но ладно.
[02:06:53.000 --> 02:06:55.000]  Еще у нас одна ошибка в компиляции.
[02:06:55.000 --> 02:06:57.000]  Какая? Видите, какая?
[02:06:57.000 --> 02:06:59.000]  Понимаете, почему?
[02:06:59.000 --> 02:07:01.000]  variant-choice blah-blah-blah is inaccessible based
[02:07:01.000 --> 02:07:03.000]  off variant blah-blah-blah.
[02:07:03.000 --> 02:07:05.000]  Почему такая ошибка?
[02:07:09.000 --> 02:07:11.000]  Потому что наследование приватное.
[02:07:11.000 --> 02:07:13.000]  Потому что приватное, конечно, наследование.
[02:07:13.000 --> 02:07:15.000]  Наследование приватное — это значит,
[02:07:15.000 --> 02:07:17.000]  что variant скрывает от всех тот факт,
[02:07:17.000 --> 02:07:19.000]  что он наследник variant-choice,
[02:07:19.000 --> 02:07:21.000]  вообще от всех, в том числе
[02:07:21.000 --> 02:07:23.000]  от самого variant-choice.
[02:07:23.000 --> 02:07:25.000]  Variant-choice тоже не знает, что variant
[02:07:25.000 --> 02:07:27.000]  его наследник.
[02:07:27.000 --> 02:07:29.000]  Поэтому нам нужно сделать variant-choice
[02:07:29.000 --> 02:07:31.000]  другом варианта.
[02:07:31.000 --> 02:07:33.000]  Variant-choice с любыми шаблонными параметрами
[02:07:33.000 --> 02:07:35.000]  должен быть другом variant.
[02:07:35.000 --> 02:07:37.000]  Этот наследование нам не поможет?
[02:07:37.000 --> 02:07:39.000]  Так.
[02:07:39.000 --> 02:07:41.000]  Значит, я просто говорю, что...
[02:07:45.000 --> 02:07:47.000]  Наверное, я должен повторить сигнатуру точно.
[02:07:47.000 --> 02:07:49.000]  Ну, в общем, я должен сказать
[02:07:49.000 --> 02:07:51.000]  friend struct
[02:07:51.000 --> 02:07:53.000]  variant-choice.
[02:07:53.000 --> 02:07:55.000]  Сейчас, наверное, так можно.
[02:07:55.000 --> 02:07:57.000]  Если нет, то я дословно повторю
[02:07:57.000 --> 02:07:59.000]  сигнатуру.
[02:07:59.000 --> 02:08:01.000]  А, redeployer to use one template параметр.
[02:08:01.000 --> 02:08:03.000]  Да, так нельзя.
[02:08:03.000 --> 02:08:05.000]  Значит, мне все-таки придется явно
[02:08:05.000 --> 02:08:07.000]  повторить TypeName.ts, запитать TypeName.ts.
[02:08:07.000 --> 02:08:09.000]  У меня там два шаблонных параметра
[02:08:09.000 --> 02:08:11.000]  было.
[02:08:11.000 --> 02:08:13.000]  Ну, вот теперь это работает. Это даже запускается.
[02:08:13.000 --> 02:08:15.000]  Правда, ничего не выводит. Ну, понятно, почему
[02:08:15.000 --> 02:08:17.000]  ничего не выводит.
[02:08:19.000 --> 02:08:21.000]  А где вы добавили конструктор
[02:08:21.000 --> 02:08:23.000]  в умолчанию?
[02:08:23.000 --> 02:08:25.000]  Вот здесь.
[02:08:25.000 --> 02:08:27.000]  Вот.
[02:08:27.000 --> 02:08:29.000]  Хороший вопрос, правда.
[02:08:29.000 --> 02:08:31.000]  Как будет тогда вести себя конструктор
[02:08:31.000 --> 02:08:33.000]  в умолчанию самого варианта?
[02:08:33.000 --> 02:08:35.000]  Ну, давайте этот вопрос я оставлю
[02:08:35.000 --> 02:08:37.000]  вам на самостоятельное изучение,
[02:08:37.000 --> 02:08:39.000]  потому что это уже не так интересно.
[02:08:39.000 --> 02:08:41.000]  Тут, возможно, надо написать варианту
[02:08:41.000 --> 02:08:43.000]  отдельно конструктор в умолчании, который будет
[02:08:43.000 --> 02:08:45.000]  конструировать первый аргумент.
[02:08:45.000 --> 02:08:47.000]  Ну, это не интересная часть.
[02:08:47.000 --> 02:08:49.000]  То есть главное, что мы поняли,
[02:08:49.000 --> 02:08:51.000]  как победить вот эту проблему с перегрузкой.
[02:08:51.000 --> 02:08:53.000]  То есть мы поняли,
[02:08:53.000 --> 02:08:55.000]  как победить вот эту проблему с перегрузкой.
[02:08:57.000 --> 02:08:59.000]  То есть благодаря вот этому вот
[02:08:59.000 --> 02:09:01.000]  трюку, магическому фокусу
[02:09:01.000 --> 02:09:03.000]  с наследованием к переменам количества
[02:09:03.000 --> 02:09:05.000]  классов и юзингом с многоточием,
[02:09:05.000 --> 02:09:07.000]  мы умудрились
[02:09:09.000 --> 02:09:11.000]  в вариант
[02:09:15.000 --> 02:09:17.000]  добавить
[02:09:17.000 --> 02:09:19.000]  конструкторы,
[02:09:21.000 --> 02:09:23.000]  которые по правилам перегрузки
[02:09:23.000 --> 02:09:25.000]  выводятся.
[02:09:25.000 --> 02:09:27.000]  Кстати,
[02:09:31.000 --> 02:09:33.000]  кстати,
[02:09:33.000 --> 02:09:35.000]  кажется, что
[02:09:39.000 --> 02:09:41.000]  это все-таки можно было сымитировать без
[02:09:41.000 --> 02:09:43.000]  юзинг многоточия.
[02:09:43.000 --> 02:09:45.000]  То есть
[02:09:45.000 --> 02:09:47.000]  вот это вот самая
[02:09:47.000 --> 02:09:49.000]  самая удивительная конструкция здесь.
[02:09:49.000 --> 02:09:51.000]  Да, вот это вот вообще.
[02:09:53.000 --> 02:09:55.000]  Это C++17 тока.
[02:09:55.000 --> 02:09:57.000]  Но все-таки, если у нас
[02:09:57.000 --> 02:09:59.000]  нет юзинг многоточия, если вот без
[02:09:59.000 --> 02:10:01.000]  этой конструкции, как ее можно сымитировать?
[02:10:01.000 --> 02:10:03.000]  Но на самом деле у нас же есть
[02:10:03.000 --> 02:10:05.000]  user-defined-deduction-guides.
[02:10:05.000 --> 02:10:07.000]  Мы же можем варианту написать,
[02:10:07.000 --> 02:10:09.000]  вот представьте, что я без юзинг многоточий
[02:10:09.000 --> 02:10:11.000]  могу сказать.
[02:10:11.000 --> 02:10:13.000]  Deduction plate,
[02:10:13.000 --> 02:10:15.000]  type name,
[02:10:15.000 --> 02:10:17.000]  variant
[02:10:17.000 --> 02:10:19.000]  от const
[02:10:21.000 --> 02:10:23.000]  Я же могу сделать
[02:10:23.000 --> 02:10:25.000]  deduction-guide. Variant
[02:10:27.000 --> 02:10:29.000]  от
[02:10:29.000 --> 02:10:31.000]  Deduction plate
[02:10:49.000 --> 02:10:51.000]  Нет,
[02:10:51.000 --> 02:10:53.000]  не deduction-guide мне нужен. То есть
[02:10:53.000 --> 02:10:55.000]  смотрите, я могу что сделать? Я могу написать
[02:10:55.000 --> 02:11:06.000]  Что я могу написать? Я мог бы написать шаблонный конструктор, ну давайте я идею скажу, что можно было бы, как бы можно было это обойти, кажется. Смотрите идея.
[02:11:06.000 --> 02:11:09.000]  Я могу написать шаблонный конструктор от const.mpercent.
[02:11:09.000 --> 02:11:18.000]  Variant от const.mpercent.
[02:11:18.000 --> 02:11:24.000]  Вот. А здесь сделать такую вещь.
[02:11:24.000 --> 02:11:47.000]  Using type равно decal type от некоторая функция helper с шаблонным параметром types.
[02:11:47.000 --> 02:11:49.000]  Вот наш пакет.
[02:11:49.000 --> 02:11:54.000]  От value.
[02:11:54.000 --> 02:11:56.000]  Вот.
[02:11:56.000 --> 02:11:59.000]  Значит.
[02:11:59.000 --> 02:12:02.000]  Да, вот так.
[02:12:02.000 --> 02:12:06.000]  И...
[02:12:06.000 --> 02:12:13.000]  Блин, черт, все-таки не получается у меня, жалко да, ой, печально как.
[02:12:13.000 --> 02:12:21.000]  То есть я хочу что сделать, я хочу как бы сымитировать, я хочу сделать как бы перегрузку helper, которая бы была...
[02:12:21.000 --> 02:12:31.000]  Которая бы принимала вот этот вот value и при этом возвращала бы какой-то тип, как если бы...
[02:12:31.000 --> 02:12:33.000]  Вот от того types, от которого она вернулась.
[02:12:33.000 --> 02:12:38.000]  Блин, нет, все-таки не получается.
[02:12:38.000 --> 02:12:42.000]  Не будет это так работать.
[02:12:42.000 --> 02:12:48.000]  Блин, давайте я потом вам пришлю как это сделать, потому что не могу что-то я сходу написать, как это будет надо написать.
[02:12:48.000 --> 02:13:08.000]  Чтобы у меня была перегрузка функций реальных, чтобы я по decal type от выражения понимал какой выбрался тип из типов.
[02:13:08.000 --> 02:13:16.000]  То есть у меня пакет типов и я хочу написать по функции для каждого типа и вот каждая функция будет возвращать тот тип, от которого она реально вызвалась.
[02:13:16.000 --> 02:13:21.000]  И после этого я через decal type пойму какой тип.
[02:13:21.000 --> 02:13:26.000]  Не могу, забыл как это пишется, короче, сорян, но вот так мы...
[02:13:26.000 --> 02:13:29.000]  Вот так это стало писаться и начинать степель способствоваться.
[02:13:29.000 --> 02:13:32.000]  Может быть тот способ вам никогда не понадобится.
[02:13:32.000 --> 02:13:38.000]  Ну я пришлю в чат или в следующий раз вспомню и расскажу как это писать.
[02:13:38.000 --> 02:13:46.000]  Короче, это можно сымитировать было и без вот этого заклинания, но с этим заклинанием стало гораздо проще.
[02:13:46.000 --> 02:13:48.000]  Короче, так, есть ли вопросы?
[02:13:48.000 --> 02:13:52.000]  А, еще, я здесь забыл важную вещь, мне здесь надо сделать choice.
[02:13:52.000 --> 02:13:57.000]  Ну, мне здесь надо еще соответствующий этот currentIndex поменять на нужный.
[02:13:58.000 --> 02:14:03.000]  Ну, давайте я туду оставлю, тоже не буду это писать, потому что это тоже понятно так сделать.
[02:14:03.000 --> 02:14:05.000]  Ну как-как? Опять мне нужно...
[02:14:05.000 --> 02:14:12.000]  Ну, мне нужно скастить опять дирайвом персанду себя и у него сделать currentIndex каким?
[02:14:12.000 --> 02:14:23.000]  Таким каков индекс этого, значит, t, вот этого t в списке...
[02:14:23.000 --> 02:14:25.000]  Я не то сделал-то, господи.
[02:14:25.000 --> 02:14:27.000]  А, нет, все то сделал.
[02:14:27.000 --> 02:14:32.000]  Да, но у нас уже была похожая функция, которая по индексу возвращается.
[02:14:32.000 --> 02:14:38.000]  Да, у нас была функция getTypeByIndex, а здесь мне нужна функция getIndexByType.
[02:14:38.000 --> 02:14:53.000]  То есть мне здесь нужна еще метафункция getIndexByType, которая по типу возвращает его индекс в пакете.
[02:14:53.000 --> 02:14:55.000]  Ну, понятно, и вы ее тоже можете реализовать легко.
[02:15:00.000 --> 02:15:03.000]  А правда ли, что эта задача легче, чем какой-нибудь Android Map, например?
[02:15:05.000 --> 02:15:07.000]  Не думаю, не знаю.
[02:15:10.000 --> 02:15:14.000]  Тут еще далеко не все проблемы решены, сейчас вы увидите новые проблемы.
[02:15:14.000 --> 02:15:16.000]  Божить точно меньше.
[02:15:16.000 --> 02:15:18.000]  А...
[02:15:20.000 --> 02:15:23.000]  Окей, мы написали конструктор.
[02:15:25.000 --> 02:15:28.000]  Давайте напишем деструктор варианта.
[02:15:30.000 --> 02:15:32.000]  Как написать деструктор варианта?
[02:15:36.000 --> 02:15:39.000]  Ну, вызвать по индексу деструктор.
[02:15:39.000 --> 02:15:41.000]  А как узнать, какой вызвать?
[02:15:42.000 --> 02:15:48.000]  Так у нас же индекс есть, мы же имеем getTypeByIndex, у нас же есть индекс, который хранится в памяти у нас.
[02:15:48.000 --> 02:15:49.000]  Так он же...
[02:15:49.000 --> 02:15:50.000]  Да, но он runtime.
[02:15:50.000 --> 02:15:52.000]  Да, он runtime-ский.
[02:15:54.000 --> 02:15:57.000]  А что мешает деструктору в runtime понимать, что ему есть?
[02:15:57.000 --> 02:15:59.000]  Ну, продиктуй просто, что напечатать мне.
[02:16:00.000 --> 02:16:03.000]  А что мешает деструктору в runtime понимать, что ему есть?
[02:16:03.000 --> 02:16:05.000]  Ну, продиктуй просто, что напечатать мне.
[02:16:05.000 --> 02:16:14.000]  Ну, reinterpreter предкаст к там getIndex, точнее getTypeByIndex от types.
[02:16:15.000 --> 02:16:18.000]  Точнее от... А там первым идет индекс?
[02:16:18.000 --> 02:16:20.000]  Ну да.
[02:16:20.000 --> 02:16:23.000]  А, мы не можем currentIndex туда поставить?
[02:16:23.000 --> 02:16:27.000]  Да, мы не можем currentIndex, потому что это не compileTime константа.
[02:16:28.000 --> 02:16:30.000]  Че делать?
[02:16:30.000 --> 02:16:34.000]  Можно каким-нибудь ifConstext проифать все возможные варианты?
[02:16:34.000 --> 02:16:35.000]  Как?
[02:16:35.000 --> 02:16:37.000]  Их перемен...
[02:16:38.000 --> 02:16:41.000]  Если бы их было конечное, ну, фиксированное...
[02:16:41.000 --> 02:16:44.000]  Нет, у нас же фиксированное количество, у нас размер...
[02:16:44.000 --> 02:16:46.000]  Диктуй, че печатать.
[02:16:46.000 --> 02:16:52.000]  А мы можем рекурсивно, например, если один, то окей, а иначе запустится от...
[02:16:52.000 --> 02:16:55.000]  Ну, диктуй. Пожалуйста.
[02:16:55.000 --> 02:16:58.000]  Диктуйте, че писать. И ifConstexpr, что?
[02:16:58.000 --> 02:17:00.000]  Только мы current не можем проверить, да.
[02:17:00.000 --> 02:17:04.000]  Опять, мы не можем в constexpr че-то с currentIndex делать, потому что это не можно.
[02:17:04.000 --> 02:17:08.000]  Мы не можем, когда мы заменяем наш тип, который там хранится...
[02:17:08.000 --> 02:17:10.000]  Ну, типа хранить указательный деструктор.
[02:17:10.000 --> 02:17:17.000]  То есть вы предлагаете опять создать некое подобие таблицы виртуальных футов, то есть хранить pointer.
[02:17:17.000 --> 02:17:20.000]  Че делать, когда деструктор вызывается?
[02:17:20.000 --> 02:17:22.000]  Ну, как вариант.
[02:17:22.000 --> 02:17:28.000]  В целом, что угодно можно сделать. То, что мы до этого делали.
[02:17:28.000 --> 02:17:31.000]  Да, можно запилить опять TypeIrager.
[02:17:31.000 --> 02:17:38.000]  Но мы бы не хотели все-таки виртуальные функции сюда приделывать, потому что это уж как-то совсем грустно.
[02:17:38.000 --> 02:17:41.000]  Мы как-то хотели без них все-таки.
[02:17:41.000 --> 02:17:47.000]  Но действительно, кажется, можно сделать указательный деструктор.
[02:17:47.000 --> 02:17:51.000]  Нет, ну ладно, а тогда оператор присваивания как писать.
[02:17:51.000 --> 02:17:52.000]  Также.
[02:17:53.900 --> 02:17:55.500]  Ура, ура!
[02:17:57.000 --> 02:18:01.000]  Кстати, с оператором присваивании есть еще вот какой момент.
[02:18:01.000 --> 02:18:04.000]  Оператор присваивания должен работать так.
[02:18:04.000 --> 02:18:09.000]  Он должен вызвать деструктор и снова конструктор, если мы присваиваем не тот тип, который лежал.
[02:18:09.000 --> 02:18:13.000]  А если мы присваиваем тот же тип, который и так лежал, то мы просто типу присваиваем его.
[02:18:13.000 --> 02:18:17.000]  Не делаем деструктор и заново конструктор.
[02:18:17.000 --> 02:18:22.740]  допустим у нас в варианте лежал string и мы присваиваем в варианте новый string, тогда мы не делаем
[02:18:22.740 --> 02:18:26.360]  destructor string, а потом constructor string, вы просто должны вызвать оператор присваивания стринга,
[02:18:26.360 --> 02:18:33.960]  то есть если у нас в варианте мы присваиваем ipp который в нём и лежал, мы не делаем destructor,
[02:18:33.960 --> 02:18:41.360]  мы делаем непосредственно оператор присваивания. Это по стандарту? Да. То есть нам получится
[02:18:41.360 --> 02:18:48.640]  надо будет хранить еще указательный оператор присваивания. А если это мувающие присваивания,
[02:18:48.640 --> 02:18:52.160]  то нам надо будет еще хранить указательно мувающий оператор присваивания. И вот уже
[02:18:52.160 --> 02:18:57.720]  три указательных надо хранить. Попахивает опять какой-то таблицей виртуальных функций. Что-то
[02:18:57.720 --> 02:19:10.720]  вообще неприятно. Я вам сейчас покажу козырное решение. Оно тоже может вызвать... Вот короче,
[02:19:10.720 --> 02:19:19.440]  Денис, Васюк, включи микрофон. Сейчас я просто... Мне нужна реакция зрителей. Мы сделаем деструкторы
[02:19:19.440 --> 02:19:23.600]  и отнаследуем все деструкторы. Смотри, деструкторы мы отнаследовать не сможем,
[02:19:23.600 --> 02:19:35.000]  потому что деструктор должен быть только один в классе. Но мы сделаем вот... Смотрите, мы вот что
[02:19:35.000 --> 02:19:53.440]  сделаем. Давайте я так напишу. ThisVariant равно... Короче, вот эту штуку я просто скопирую,
[02:19:53.440 --> 02:19:58.880]  потому что мне опять надо будет себя кастить к варианту. Значит, ThisVariant это статик каст,
[02:19:58.880 --> 02:20:05.840]  вот эта штука. Только не буфер, а просто статик каст дирайвт от себя. Вот. И теперь смотрите,
[02:20:05.840 --> 02:20:26.080]  я напишу, если ThisVariant.currentIndex равно getIndexByType от at.types, if не constexpr,
[02:20:26.080 --> 02:20:35.560]  потому что... Ну, потому что currentIndex это runtime штука. Давайте я сделаю тоже заглушку какую-нибудь.
[02:20:35.560 --> 02:20:50.760]  getIndexByType будет всегда 0 возвращать. getIndexByType. И здесь будет typeNameT. И здесь будет value static
[02:20:50.760 --> 02:21:04.440]  const sizeT value равно 0. Так вот, я что говорю, если ThisVariant.currentIndex равно... Если,
[02:21:04.440 --> 02:21:26.760]  короче, в варианте index сейчас такой, каков index типа t в пакете types, то мы вот по
[02:21:26.760 --> 02:21:39.920]  этому буферу и вызываем index. Деструктор t. А, то есть мы вызываем все деструкторы,
[02:21:39.920 --> 02:21:46.080]  но только один из них сработает? Ну, типа да. Ну, кажется, что ничего такого неадекватного нет.
[02:21:46.080 --> 02:22:15.680]  Ну да. Ну и смотрите, что происходит. Когда уничтожается Varian, должны уничтожиться все
[02:22:15.680 --> 02:22:33.040]  его родители. А как они работают? А уничтожаясь, соответствующий родитель Varian проверяет,
[02:22:33.040 --> 02:22:38.000]  правда ли, index был таким, каким надо, и если да, то вызывает по нужному адресу деструктор
[02:22:38.000 --> 02:22:44.680]  нужного типа. Таким образом, ровно один раз уничтожается нужный тип. Поняли вы идею?
[02:22:44.680 --> 02:22:53.720]  А можете, пожалуйста, уточнить, что такое буфер? Тут написано куда как точнее. Char, буфер вот такого
[02:22:53.720 --> 02:23:10.760]  размера. Это массив Char. Так, понятна ли идея с деструктором? Сейчас, только видимо не буфер,
[02:23:10.760 --> 02:23:36.080]  а здесь Varian буфер. Да. Это сейчас компилируется. То есть здесь мы явно использовали MTBaseOptimization в том,
[02:23:36.080 --> 02:23:41.720]  что у нас в Varian.choice ничего нет, и у них все будут такой же адрес, как у установок варианта.
[02:23:41.720 --> 02:24:01.720]  Нам еще надо буфер в интерплет кастнуть. Сейчас. Там, кажется, 2.2.2 value в верхней 38 строке.
[02:24:01.720 --> 02:24:16.480]  Где-где? Где-где indexByType 2.2.2 value? Вот здесь. Это не компилируется, впрочем. Почему не компилируется это?
[02:24:20.480 --> 02:24:26.160]  Ну да, потому что мы буфер, как бы, у него нет деструктора T. Да, потому что мы вызываем
[02:24:26.160 --> 02:24:35.360]  диструктор T у штуки, которая не является штукой соответствующего типа. Это бред. Но даже если бы
[02:24:35.360 --> 02:24:44.240]  это компилировалось, было бы тоже плохо, потому что это UB. Знаете, почему это UB? Мы же уже уничтожаем
[02:24:44.240 --> 02:24:49.320]  сначала объект Varian, а потом его родителей. Сначала делается диструктор наследника,
[02:24:49.320 --> 02:24:55.520]  потом диструктор родителей. В момент, когда делается диструктор родителей, наследника уже
[02:24:55.520 --> 02:25:07.240]  не существует. Обращение к полям наследника в этом случае UB. Блин. Блин, я вам рано про это сказал,
[02:25:07.240 --> 02:25:16.800]  потому что вы сейчас заметите еще одну проблему, которую я хотел на попозже отложить. Ну короче,
[02:25:16.800 --> 02:25:24.360]  ладно, давайте пока решим проблему, что это не компилируется. Что же делать-то? Принтер при этом
[02:25:24.360 --> 02:25:43.960]  из каст все равно нужно. Нет. Так, сейчас. Давайте ко мне минутку подумать. Я тут кое над чем сам задумался.
[02:25:54.360 --> 02:26:24.080]  А мы можем сделать функцию destroy, которая, допустим, возвращала бы int равный нулю и, короче,
[02:26:24.080 --> 02:26:32.760]  через FoldExpression заставить его вызывать destroy по всем типам. Да, мы так и хотим сделать,
[02:26:32.760 --> 02:26:43.400]  но все равно непонятно как решить обойти вот эту проблему пока что. Так нет, у нас будет функция
[02:26:43.400 --> 02:26:49.240]  destroy и у нас диструктор сам по себе. Сначала явно destroy всех VarianChoices, а диструктор VarianChoices
[02:26:49.240 --> 02:26:56.560]  получается не нужен будет, потому что он всегда будет корректно удален заранее. Да, действительно,
[02:26:56.560 --> 02:27:01.840]  и нам даже даже на самом деле никакой тип нам не нужен, у нас есть прекрасный первый разопитая.
[02:27:01.840 --> 02:27:14.800]  Значит, смотрите, вот у нас destroy, вот здесь, да. Можно еще раз, что вы предлагаете? Ну, короче,
[02:27:14.800 --> 02:27:18.320]  сделать все то, что у нас было в диструкторе в destroy. Вы хотите сделать вот эту функцию,
[02:27:18.320 --> 02:27:30.920]  назвать ее destroy. Да, и затем явно вызвать VarianChoices в диструкторе нашего класса через FoldExpression.
[02:27:30.920 --> 02:27:36.080]  Да, но как решить проблему, что это не компилируется-то? Так а в чем проблема еще
[02:27:36.080 --> 02:27:47.960]  раз? Ну да, видимо, ни в чем. Видимо, надо просто здесь ринтерпрет кастом писать. Да, почему,
[02:27:47.960 --> 02:27:53.560]  ну то есть все, понятно, разобрались. Почему нельзя это было делать в диструкторе VarianChoices? Потому
[02:27:53.560 --> 02:27:59.520]  что тогда бы мы вызвали УБ себе, мы бы обращались к полю буфер, после того, как уже Varian
[02:27:59.520 --> 02:28:07.360]  Choice уничтожен. То есть давайте еще раз, что-то я запутался сам, давайте я распутаю. Почему мы не
[02:28:07.360 --> 02:28:11.560]  могли сделать вот так? То есть мы могли бы просто сказать ринтерпрет каст Tampersandu, точнее к
[02:28:11.560 --> 02:28:20.040]  T звездочки, господи, к T звездочки от вот этого стрелочка tilde T. Мы могли бы так написать,
[02:28:20.040 --> 02:28:25.280]  и это бы компилировалось, но это бы было УБ, потому что диструктор VarianChoices вызывается
[02:28:25.280 --> 02:28:32.320]  после того, как уничтожился сам наследник. А когда сам наследник уничтожился, вот эти поля,
[02:28:32.320 --> 02:28:37.640]  обращение к его полям, это уже УБ. И компилятор имел бы право это вообще соптимизировать,
[02:28:37.640 --> 02:28:42.040]  и ничего бы не происходило на самом деле. И так бы и было, скорее всего, если бы мы так не
[02:28:42.040 --> 02:28:50.880]  писали. Поэтому на самом деле так не работает. Но мы можем это сделать функцией Destroy. Сделаем
[02:28:50.880 --> 02:28:58.880]  функцию Destroy, в которой напишем вот это. И когда мы будем вызывать диструктор Varian,
[02:28:58.880 --> 02:29:11.200]  мы с помощью FoldExpression вызовем Destroy от всех предков. То есть мы пишем VarianChoice от types,
[02:29:11.200 --> 02:29:23.000]  запитая types, многоточие, двоеточие, двоеточие, Destroy, запитая многоточие, и все это в скобочках.
[02:29:28.520 --> 02:29:35.200]  Понятно ли, что я здесь написал? Но это именно то, что предлагал, не помню кто.
[02:29:41.200 --> 02:29:53.960]  Давайте проверим, что это компилируется. Компилируется. Кстати, опыт прошлых лет показывает,
[02:29:53.960 --> 02:30:04.600]  что на G++ версии ниже 11 это не компилируется. G++, я надеюсь не путаю, то есть C-Lang, по-моему,
[02:30:04.600 --> 02:30:11.840]  это может компилировать, это G++ нет. В общем, G++ до 11 версии почему-то не мог это распарсить и
[02:30:11.840 --> 02:30:18.640]  ломался. Давайте, кстати, я попробую. У меня G++ 9, кажется, по умолчанию стоит. Если я ему
[02:30:18.640 --> 02:30:29.400]  напишу C++ 17, то он скорее всего не справится. Да. Значит, G++ 9 версии не может это скопилировать,
[02:30:29.400 --> 02:30:35.920]  хотя я не использую никаких фичей C++ 20, я использую только C++ 17. Это был баг G++,
[02:30:35.920 --> 02:30:44.320]  он не мог это скомпилировать. G++ 11 уже может. Ну и он по умолчанию в C++ 17 компилирует.
[02:30:44.320 --> 02:31:04.760]  C-Lang, по-моему, мог довольно давно. Так, ну что, есть вопросы? Но у меня оно 6 секв ловит. Ну,
[02:31:04.760 --> 02:31:11.720]  в смысле, это значит, что ты что-то неправильно, в смысле оно ловит. Кто именно? Этот код, который ты
[02:31:11.720 --> 02:31:19.400]  запустил, вот ты его сейчас запустил прям. Да. Так у нас есть еще одна проблема. У нас куча заглушек,
[02:31:19.400 --> 02:31:24.920]  во-первых, поэтому я не удивлен. Если бы мы правильно реализовали все getIndexByType и getType
[02:31:24.920 --> 02:31:30.680]  byIndex, то, может, у нас бы и работало. А у нас в конструкторе разве нет проблемы? Да, это совершенно
[02:31:30.680 --> 02:31:37.000]  верно, это следующая вещь, которую надо обсудить. У нас, я вам сказал, что я забежал вперед, у нас та
[02:31:37.000 --> 02:31:42.760]  проблема, которую я только что озвучил в Destructor, с обращением к полям, на самом деле ровно это же
[02:31:42.760 --> 02:31:49.160]  проблема, если в конструкторе, просто мы ее не сразу заметили. И поэтому, если так написать, то это
[02:31:49.160 --> 02:31:56.360]  тоже UB, потому что конструкторы родителей вызываются до конструктора наследника и до создания вообще
[02:31:56.360 --> 02:32:03.120]  полей наследника. Обращаясь из конструктора родителей к полю буфер, мы ловим UB, потому что буфер,
[02:32:03.120 --> 02:32:10.320]  еще его время жизни началось, и компилятор имеет право вот этот вот код просто соптимизировать и
[02:32:10.320 --> 02:32:17.920]  выкинуть. Он может просто не делать эту строчку, потому что буфера еще не существует. Мы находимся
[02:32:17.920 --> 02:32:23.080]  в конструкторе родителя, буфер появится как поле только тогда, когда начнет работать конструктор
[02:32:23.080 --> 02:32:29.240]  наследника, то есть перед тем, как закончится конструктор родителя и после того, как закончится
[02:32:29.440 --> 02:32:33.040]  конструктор родителя, перед тем, как начнет работать конструктор наследника, появится поле буфер,
[02:32:33.040 --> 02:32:40.320]  до этого его нет. Как решать эту проблему? Ровно так же, как с деструктором создать
[02:32:40.320 --> 02:32:48.840]  какой-нибудь констракт, который точно так же вызвать в конструкторе? Да, можно так решить эту
[02:32:48.840 --> 02:32:58.320]  проблему, то есть, нет, стоп, в каком конструкторе? В конструкторе самого варианта. А он будет от чего
[02:32:58.320 --> 02:33:07.920]  этот конструктор? От шаблонного параметра любого не пойдет? Да, от шаблонного параметра,
[02:33:07.920 --> 02:33:13.440]  а дальше выберется оптимальная перегрузка. Как это она выберется? А нет, сейчас при
[02:33:13.440 --> 02:33:18.720]  постановке. Будет ровно эта проблема, то есть, если мы опять заведем здесь шаблон, то есть,
[02:33:18.720 --> 02:33:24.080]  мы эту всю байду с наследованием затеяли как раз для того, чтобы у нас перегрузка в конструкторах
[02:33:24.080 --> 02:33:35.680]  правильно работала. Если мы сейчас опять напишем вот так и здесь будем делать констракт, то как он
[02:33:35.680 --> 02:33:50.640]  поймет, какой ты активировать? Нет, очень плохо, что эта пара не очень. Я сам очень жалею, на самом
[02:33:50.640 --> 02:33:57.600]  деле. Ну вот давайте тогда сделаем, что у нас у специализации вариант чойса. Чего еще у тебя?
[02:33:57.600 --> 02:34:03.800]  Мы можем сделать у варианта чойса специализацию, что если это, конечно, самый последний вариант
[02:34:03.800 --> 02:34:14.120]  чойс, то тогда у него будет как раз-таки этот массивчик, а не у самого. Какой массивчик? Что? Так,
[02:34:14.120 --> 02:34:21.080]  подожди. Сейчас, а что значит специализацию вариант чойса? Специализацию для каких типов? То есть,
[02:34:21.080 --> 02:34:26.000]  ты хочешь сделать специализацию вариант чойса на случай, если ты это последний в пакете types.
[02:34:26.000 --> 02:34:33.320]  Давайте создадим статистическую версию бушера. Подожди, подожди, подожди, подожди. Как это вообще
[02:34:33.320 --> 02:34:39.520]  синтоксически напишешь? Специализация может быть только для как? Ты хочешь написать вот здесь
[02:34:39.520 --> 02:34:45.520]  что? Допустим, я специализацию пишу. Как это написать? Вариант чойс от каких-то конкретных… Ну,
[02:34:45.520 --> 02:34:52.840]  то есть, что здесь написать специализацию? Давайте еще третий параметр номер. Несколько осталось.
[02:34:52.840 --> 02:35:08.080]  Так, и что? И я не понимаю, все равно как это написать? Как частичная специализация, она может
[02:35:08.080 --> 02:35:16.160]  быть если ты фиксируешь какие-то параметры или если ты там у тебя… Я совершенно не понимаю,
[02:35:16.160 --> 02:35:22.840]  как это сделать. Мы зафиксируем, что если у нас… Ну, самый первый вариант чойса будем создавать…
[02:35:22.840 --> 02:35:30.920]  Первый параметр делать size of многоточие types. Так что ли? Типа специализация на случай,
[02:35:30.920 --> 02:35:36.720]  если первое число это size of многоточие types, а дальше эти сами types пошли, да? Так что ли?
[02:35:36.720 --> 02:35:42.000]  Ну да. Я не уверен, что это скомпилируется. Я не уверен, что можно expression делать там.
[02:35:42.000 --> 02:35:50.280]  Нет, нельзя, но можно типа сделать ровно обратную штуку, что не с какой индекс,
[02:35:50.280 --> 02:35:54.720]  а сколько до конца осталось, чтобы оно скомпилировалось со специализацией для нуля,
[02:35:54.720 --> 02:36:04.040]  видимо. И в такой специализации уже делать буфер? Типа того. Кажется, буфер надо делать
[02:36:04.920 --> 02:36:11.640]  чтобы он сконструировался раньше всех. Я предложу вам идею попроще. Как вы хотите
[02:36:11.640 --> 02:36:18.280]  конструировать буфер до того, как мы начали вариант? Я предложу вам идею попроще. На
[02:36:18.280 --> 02:36:27.840]  самом деле я просто сделаю еще одного наследника. Жесть, что? Да нет, все нормально как раз.
[02:36:27.840 --> 02:36:37.080]  У меня будет вот такое наследование. У меня будет отдельный класс VariantStorage,
[02:36:37.080 --> 02:36:43.120]  который будет хранить буфер и заодно предоставлять разные удобные методы для доступа к этому буферу.
[02:36:43.120 --> 02:36:54.040]  И он все равно уничтожится раньше, чем наши типы? Нет, он не уничтожится раньше, чем наши типы.
[02:36:54.040 --> 02:37:08.920]  Дестрои? Нет, он уничтожится позже. И вот сюда перенесу вот это.
[02:37:12.920 --> 02:37:15.400]  Да и CurrentIndex тоже мне перенести надо будет сюда,
[02:37:15.400 --> 02:37:20.120]  потому что к нему я тоже хочу обращаться из VariantChoice.
[02:37:24.040 --> 02:37:41.480]  Вот и на самом деле, теперь, когда я создаю Variant, в первую очередь создается VariantStorage,
[02:37:41.480 --> 02:37:49.000]  потом начинаются создаваться VariantChoice, потом только сам Variant. Если я теперь из VariantChoice
[02:37:49.000 --> 02:37:54.320]  обращаюсь к буферу или CurrentIndex, то это корректно, потому что к моменту,
[02:37:54.320 --> 02:38:03.600]  когда создаются VariantChoice, VariantStorage уже создан. Если я из Дестроя обращаюсь к вот этим штукам,
[02:38:03.600 --> 02:38:10.320]  но это тем более корректно, потому что у меня еще Variant существует, а значит и Buffer и CurrentIndex существуют.
[02:38:10.320 --> 02:38:17.320]  То есть вот теперь я, сейчас я правда не уверен, что это скомпилируется, как обычно. Нет, компилируется нормально,
[02:38:17.320 --> 02:38:23.880]  но потому что эти поля Buffer и CurrentIndex, они есть у Variant, потому что есть у VariantStorage, там все публичное.
[02:38:23.880 --> 02:38:38.320]  А, минуточку, нет, подождите, мне надо вот это удалить. Ну да, компилируется. Даже C++17 компилируется.
[02:38:40.320 --> 02:38:51.720]  А, вопросы. Ну раз теперь есть storage, то можно и без дестроя. Да, дестрои можно. Сейчас,
[02:38:51.720 --> 02:38:56.200]  он будет уничтожаться от последнего родителя к первому. А как без дестроя это сделать? Подождите,
[02:38:56.200 --> 02:38:59.960]  я не понимаю как это без дестроя сделать? В плане, у нас же storage будет уничтожаться.
[02:38:59.960 --> 02:39:04.640]  Будет уничтожаться от последнего родителя к первому или как? Да, он уже после первого
[02:39:04.640 --> 02:39:08.920]  уничтожает родителей, поэтому storage уже последний, поэтому он всегда будет.
[02:39:08.920 --> 02:39:18.280]  Ну тогда variant storage нужно тоже... Нет, подождите, не понимаю, как вы предлагаете сделать без
[02:39:18.280 --> 02:39:23.200]  destroy? Я не понимаю, вы предлагаете в variant storage написать destroy или что?
[02:39:23.200 --> 02:39:30.480]  Вернуть обратно destroy в destructora, потому что они будут вызываться до того,
[02:39:30.480 --> 02:39:37.800]  как будет уничтожен variant storage. В смысле, вот здесь сделать просто destructor, что ли?
[02:39:37.800 --> 02:39:46.720]  Ну да, как мы изначально это в destructora делали, потому что теперь там убэ не будет,
[02:39:46.720 --> 02:39:56.400]  потому что buffer еще не будет уничтожен. Сейчас, давайте подумаем, правда ли это?
[02:39:56.400 --> 02:40:05.520]  Вообще кажется, правда. В смысле, мы же здесь quarantine index обращаемся, а не к buffer. У нас убэ из-за этого.
[02:40:05.520 --> 02:40:15.440]  Не, ну quarantine index тоже в storage лежит теперь. Ну так это не with variant, а сейчас.
[02:40:15.440 --> 02:40:30.000]  Да, ну вообще кажется, что... И вам нужно будет делать эту штуку не от варианта, а от variant storage,
[02:40:30.000 --> 02:40:33.480]  тогда, видимо, deriving. Ну или сделать просто using другой.
[02:40:33.480 --> 02:40:43.800]  Мне все равно не очень нравится это, потому что мы как бы обращаемся к this variant, как будто это variant,
[02:40:43.800 --> 02:40:49.840]  хотя на самом деле destructor variant уже вызвался. И так нельзя, я думаю.
[02:40:49.840 --> 02:40:55.280]  Сейчас еще как мы адрес получим в этой штуке? Ведь тут-то мы его пользовали.
[02:40:55.280 --> 02:41:01.080]  Смотрите, почему мне кажется, почему мне не нравится то, что вы предлагаете.
[02:41:01.080 --> 02:41:09.520]  Как я могу кастовать к storage, если я не наследник storage?
[02:41:09.520 --> 02:41:13.960]  Не, ну может, конечно, reinterpret custom кастовать к storage.
[02:41:13.960 --> 02:41:17.120]  Мы же точно животной памяти, поэтому давайте reinterpret custom.
[02:41:17.120 --> 02:41:26.200]  Мы не знаем, что с адресом. Там же, может быть, все что угодно, еще size of и так далее.
[02:41:26.200 --> 02:41:35.840]  Сейчас, вы говорите, что можно сделать reinterpret custom к variant storage, потому что мы это точно variant storage,
[02:41:35.840 --> 02:41:42.720]  и мы начинаемся на той же памяти. Ну потому что, кроме как variant storage, ни у чего болей нет.
[02:41:42.720 --> 02:41:58.560]  Ну, наверное, да. Наверное, так можно. Наверное, так должно сработать.
[02:41:58.560 --> 02:42:07.480]  Ну, так или иначе, в общем, есть разные способы это сделать. Наверное, способ
[02:42:07.480 --> 02:42:12.880]  через reinterpret custom variant storage работает. Но работает и то, что здесь написано. Вот.
[02:42:12.880 --> 02:42:19.080]  Из деструктора обращаться к thisVariant как к derived, мне кажется, это все равно уб,
[02:42:19.080 --> 02:42:28.440]  потому что формально thisVariant уже не является variant, поскольку его деструктор
[02:42:28.440 --> 02:42:34.080]  как variant уже был вызван, и обращаться к нему через точку, как будто он объект variant,
[02:42:34.080 --> 02:42:41.040]  кажется неправильно. Кажется, формально это может быть уб. Хотя я не до конца уверен,
[02:42:41.040 --> 02:42:47.440]  но на всякий случай я бы лучше так не писал. Сейчас, у нас приватное наследование от variant storage, так?
[02:42:47.440 --> 02:42:57.000]  У нас вот написано, и что? Поэтому variant choice не видит, что у нас есть поля из variant storage.
[02:42:57.000 --> 02:43:04.320]  Естественно. Но мы при этом не обращаемся внутри. Потому что thisVariant это derived,
[02:43:04.320 --> 02:43:09.840]  derived это variant. Мы скастовали себя к варианту, а у варианта уже есть поля variant storage.
[02:43:27.000 --> 02:43:32.640]  Так, ну ладно, господа. На самом деле, мы почти все обсудили, что касалось варианта.
[02:43:32.640 --> 02:43:39.200]  Мы, правда, не обсудили, как visit реализовать. Мы не обсудили еще одну важную проблему,
[02:43:39.200 --> 02:43:45.960]  которая присуща не только нашей реализации в variant, но и нашей реализации в function.
[02:43:45.960 --> 02:43:55.400]  Я не буду, ну сейчас, на сегодня все, давайте, то есть до конца мы все-таки не успели,
[02:43:55.400 --> 02:44:01.880]  но ничего страшного. Давайте вам анонсирую проблему, которую нам предстоит решить следующей.
[02:44:01.880 --> 02:44:09.080]  На самом деле, последнее время мы с вами занимаемся такой интересной вещью. Мы берем и
[02:44:09.080 --> 02:44:20.160]  заводим массив чаров, вызываем там конструктор некоторого типа, потом вызываем деструктор этого
[02:44:20.160 --> 02:44:28.240]  типа и конструктор другого типа. По сути, мы это делаем, правда? На самом деле, так делать это UB.
[02:44:28.240 --> 02:44:42.840]  Вообще говоря, по стандарту нельзя брать на какие-то байты класть некоторый тип,
[02:44:42.840 --> 02:44:52.960]  уничтожать его, а потом класть другой тип на эти же байты. Компилятор имеет право, если вы положили
[02:44:52.960 --> 02:45:00.160]  какой-то тип туда, то без некоторых дополнительных оговорок, предположений, компилятор имеет право
[02:45:00.160 --> 02:45:07.760]  считать, что этот тип там дальше и лежит. И нельзя по этой же памяти динамической убрать,
[02:45:08.280 --> 02:45:13.280]  даже не обязательно динамической, нельзя. Если вы сделали плейсинг-дю на какой-то адрес какого-то
[02:45:13.280 --> 02:45:18.840]  типа, то в дальнейшем коде компилятор имеет право предполагать, что там он и лежит, этот тип,
[02:45:18.840 --> 02:45:29.200]  и оптимизировать обращение к нему, как если бы он там продолжал. Компилятор предполагает,
[02:45:29.200 --> 02:45:34.520]  так давно это изначально было так сделано, была такая оптимизация, компилятор предполагает,
[02:45:34.520 --> 02:45:39.760]  вообще говоря, что тип по данному адресу, по которому вы плейсинг-дю сделали, до тех пор,
[02:45:39.760 --> 02:45:46.120]  пока переменная живет, не меняется. Если вы завели переменную какую-то, под ней что-то лежит,
[02:45:46.120 --> 02:45:51.440]  компилятор предполагает, что тип не меняется. Ну потому что смотрите, иначе что можно было
[02:45:51.440 --> 02:45:59.040]  бы делать. Представьте, что я такое сделал и сказал, ну я не знаю, типа, вот я сказал там,
[02:45:59.040 --> 02:46:20.520]  char, буфер размера 16, потом сказал new, буфер, не знаю, int от 5, потом я вызвал какую-нибудь
[02:46:20.520 --> 02:46:33.280]  функцию g, а потом решил вывести, я вот так сказал, int звездочка pr равно new, буфер int 5,
[02:46:33.280 --> 02:46:47.160]  а потом я решил, что сделать. Сейчас я подумаю, как мне бы пример написать, чтобы это было
[02:46:51.360 --> 02:47:08.320]  не так. Пример другой должен быть. Вот представим, что у меня был класс b и класс derived. Вот я сделал
[02:47:08.320 --> 02:47:21.000]  derived d, допустим, на какой-то памяти, derived d равно new derived от чего-то, потом вызвал какую-то
[02:47:21.000 --> 02:47:35.760]  функцию, а потом сделал d, стрелочка метод. Вот. Вот если бы вы были компилятором, вы бы предполагали,
[02:47:35.800 --> 02:47:43.720]  что по d лежит derived или нет, или возможно там что-то другое сейчас лежит, например, base.
[02:47:43.720 --> 02:47:58.560]  Смысл в чем? Если derived это полиморфный класс, то вызов его методов требует
[02:47:58.560 --> 02:48:07.200]  прыжка в проходах в таблицу виртуальных функций. Но если у вас вот такой код написан,
[02:48:07.200 --> 02:48:14.640]  компилятор делает так называемую девиртуализацию, ну точнее имеет право делать. Он увидел, что вы
[02:48:14.640 --> 02:48:22.920]  изначально создали это d как derived, дальше вы что-то поделали, а потом к этому d обращаетесь
[02:48:22.920 --> 02:48:27.520]  как к методу. Если при этом у вас derived — это наследник base и больше никого в иерархии наследования
[02:48:27.520 --> 02:48:34.280]  нет, компилятор здесь имеет право сразу вызывать нужный метод, а не идти в таблицу виртуальных
[02:48:34.280 --> 02:48:40.680]  методов смотреть, какой именно вызвать. Потому что вы создали d как derived и вызываете сразу
[02:48:40.680 --> 02:48:46.760]  же у него, спустя некоторое время в той же области видимости вызываете у него какой-то метод. Зачем
[02:48:46.760 --> 02:48:49.920]  компилятору идти в таблицу виртуальных функций? Если компилятор так знает, что вы уже создали
[02:48:49.920 --> 02:48:57.360]  derived на этой памяти, от derived никто больше не наследуется, и вы d вызываете, как полагается,
[02:48:57.360 --> 02:49:04.200]  через стрелочку. Но это логичное предположение, не так ли? А если бы от derived кто-то наследовался?
[02:49:04.200 --> 02:49:13.680]  Даже если никто не наследовался, тем более. Это логичное предположение, не правда ли?
[02:49:13.680 --> 02:49:22.240]  Казалось бы, если вы сделали так и вот потом так, то не нужно идти в таблицу виртуальных функций,
[02:49:22.240 --> 02:49:27.640]  чтобы узнать, кто там лежит на самом деле. Вы там derived создали, зачем идти в таблицу виртуальных
[02:49:27.640 --> 02:49:34.560]  функций проверять? Это оптимизация, которая называется девиртуализация, которую компиляторы из поколен веков
[02:49:34.560 --> 02:49:43.840]  умеют делать. Так? Давайте кто-нибудь скажите, да, типа вот мне нужны возгласы одобрительные.
[02:49:43.840 --> 02:49:59.640]  Они, возможно, так умеют делать. Вот, умеют. Но если бы мы с вами разрешили динамически менять тип того,
[02:49:59.640 --> 02:50:07.040]  что лежит по данному адресу через пару вызов диструктора, вызов конструктора, компилятор от
[02:50:07.040 --> 02:50:12.880]  функции g, представьте, что функция g выглядит так теперь. Вот смотрите, у меня функция g допустим
[02:50:12.880 --> 02:50:23.200]  выглядит так. Ну туда можно передать, видимо, указатель на d. Да, функция g, которая берет,
[02:50:23.200 --> 02:50:34.920]  ну да, функция g, допустим, от этого d, ну или от самого d. Функция g от d, которая говорит,
[02:50:34.920 --> 02:50:43.760]  не знаю, она принимает ссылку на base и делает следующее. Она говорит,
[02:50:50.880 --> 02:51:04.240]  или даже ссылку на derived, и говорит d, стрелочка tilde derived, а потом new по адресу d,
[02:51:04.240 --> 02:51:16.880]  base и все. Как вам такое? Ну, компилятор подразумевает, что такого не происходит,
[02:51:16.880 --> 02:51:22.640]  что если вы создали derived, то вы внезапно не вызовете диструктор и не подложите новый тип
[02:51:22.640 --> 02:51:27.320]  ему, потому что компилятор хочет уметь оптимизировать вызовы виртуальной функции,
[02:51:27.320 --> 02:51:36.080]  например, вот в такой ситуации. Отсюда следующее правило, если вы по данному адресу имели
[02:51:36.080 --> 02:51:44.360]  какой-то тип, а потом уничтожили его диструктором и плейсментом u, положили другой тип, то вообще
[02:51:44.360 --> 02:51:51.280]  говоря, обращение потом к методам этого типа, это уб, потому что компилятор имеет право предполагать,
[02:51:51.280 --> 02:51:56.800]  что вы не подменяете тип вот так вот незаметно для него, пока он в одной и той же области
[02:51:56.800 --> 02:52:05.760]  видимости к нему обращается. Сейчас, но если в другую область видимости? И если в другой области
[02:52:05.760 --> 02:52:12.040]  видимости тоже. Если вы создали как derived, компилятор имеет право, с некоторыми оговорками,
[02:52:12.040 --> 02:52:17.440]  это сложный разговор, но он имеет право запомнить некоторыми оговорками, что там лежал именно такой
[02:52:17.440 --> 02:52:27.200]  тип. И если вдруг в какой-то момент тип поменялся, компилятор офигеет. Короче, нельзя так просто
[02:52:27.200 --> 02:52:33.320]  брать и подменять тип того, что лежит по данному адресу. То есть, короче, если я сазал char вот этот
[02:52:33.320 --> 02:52:41.080]  массив из чаров, то все, я тогда не могу класть ничего. Нет, если ты по адресу массива из чаров
[02:52:41.280 --> 02:52:49.480]  в частности наш лист это сплошное b. Нет. Чего? Какой лист? А где у вас там массив из чаров?
[02:52:49.480 --> 02:53:05.200]  Где у вас лист? Там аллокатор. Что? Какой аллокатор? Аллокатор и внутри массив из чаров. И что? Как он не
[02:53:05.200 --> 02:53:15.040]  переиспользует память с другими типами? Ну, если вы вызвали конструктор некоторого
[02:53:15.040 --> 02:53:20.760]  типа на какой-то памяти, а потом сделали деструктор конструктор другого типа, вот это убе. Нет,
[02:53:20.760 --> 02:53:27.320]  на массив чаров можно класть. Но чар это же тоже тип, и он вызвал свой конструктор,
[02:53:27.320 --> 02:53:33.200]  когда я его... Нет, на массив чаров можно класть. Короче. Как это работает, я не понимаю.
[02:53:33.200 --> 02:53:41.520]  Формально и правильно очень сложно. Так, давайте на сегодня все. У нас время ушло. Если на массив
[02:53:41.520 --> 02:53:49.200]  стрингов, то уже будет убе. Ну, типа, блин. На массив чаров класть другой тип можно. Если вы на
[02:53:49.200 --> 02:53:56.280]  массив чаров вызвали конструктор какого-то типа, конструктор именно, не просто int положили,
[02:53:56.280 --> 02:54:01.680]  а конструктор чего-то вызвали, а потом вызвали деструктор и конструктор чего-то другого,
[02:54:01.680 --> 02:54:08.360]  и стали обращаться к нему как к чему-то другому. Вот это убе. И на массив int-ов аналогично. На
[02:54:08.360 --> 02:54:14.360]  массив int-ов я не уверен. С массивом чаров там особое правило, по-моему. Но, по-моему, на массив
[02:54:14.360 --> 02:54:23.960]  int-ов нормально тоже. В общем, это проблема. Ну, я ее сейчас озвучил, а решать ее будем мы в
[02:54:23.960 --> 02:54:31.280]  следующий раз. Вот. Но пока на сегодня все. А Валатай, он не поможет? Оно же заставляет бегать в память каждый раз.
[02:54:31.280 --> 02:54:53.960]  Не знаю, кстати. Думаю, что нет, но не уверен. Ну, короче, давайте все на сегодня. Я не уверен,
[02:54:53.960 --> 02:55:02.760]  что Валатайл это исправит. Хотя, может быть. Ну да, я согласен, что Валатайл решает похожую
[02:55:02.760 --> 02:55:15.960]  проблему, но все-таки там немного другая проблема. Вот. Могу ли я прислать код, который могу прислать?
[02:55:15.960 --> 02:55:28.720]  Честно говоря, мне не хочется прислать вам этот код, потому что мне кажется, что полезно написать код самому.
[02:55:28.720 --> 02:55:35.160]  Главное, запись выложу. Запись-то, понятно, я выложу. Мне просто кажется, что когда вы пишете код сами,
[02:55:35.160 --> 02:55:39.760]  вы его лучше понимаете. Просто когда вы, если вы просто скопипастите все то, что я написал,
[02:55:39.760 --> 02:55:47.520]  вы не очень можете осознать, как оно работает. Я переписывал с доски, но у меня не компилируется.
[02:55:47.520 --> 02:55:55.120]  А вот когда вы сами начнете писать, повторять все это своими руками, это гораздо лучше. Вы задумываетесь
[02:55:55.120 --> 02:55:59.680]  невольно над каждой строчкой, и таким образом вы понимаете. Я не хочу прислать код именно поэтому,
[02:55:59.680 --> 02:56:05.800]  потому что мне кажется, полезно напечатать это самому хотя бы раз, чтобы понять, что происходит.
[02:56:05.800 --> 02:56:11.760]  Иначе вы просто такие, а я скопипастил, ничего не понял, но вроде работает. Потому что вам нужно,
[02:56:11.760 --> 02:56:16.280]  конечно, будет добавлять туда свои функции, свои методы и так далее. И лучше для этой цели,
[02:56:16.280 --> 02:56:24.520]  мне кажется, чтобы вы сами это напечатали. Код по лямбдо-функциям. Код по лямбдо-функциям,
[02:56:24.520 --> 02:56:36.400]  да, это я могу прислать. Ну вот, такие дела. На сегодня все.
