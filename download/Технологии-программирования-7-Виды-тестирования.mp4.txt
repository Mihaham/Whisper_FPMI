[00:00.000 --> 00:10.520]  Всем доброго дня! Мы с вами продолжаем наш курс. В прошлый раз мы начали говорить про тестирование,
[00:10.520 --> 00:15.280]  точнее продолжили детально говорить. И, наверное, где-то еще полторы лекции мы с вами будем
[00:15.280 --> 00:20.920]  говорить про тестирование, потому что тема достаточно обширная и обычно не очень хорошо
[00:20.920 --> 00:27.560]  покрывается. Значит, организационное объявление. Как раз после темы тестирования у нас будет
[00:27.560 --> 00:33.560]  первая контрольная работа. То есть все темы, которые мы пройдем, выключая тестирование,
[00:33.560 --> 00:39.360]  они попадут в контрольную работу. Чтобы у вас не было переживаний по поводу того, что что-то
[00:39.360 --> 00:44.520]  непонятное будет в контрольной, мы пришлем пробный вариант, который можно будет посмотреть и
[00:44.520 --> 00:53.880]  который можно будет решить, если можно будет задавать вопросы по этому варианту. Это у нас
[00:53.880 --> 01:00.880]  получается 3 апреля в 10.45. По аудиториям мы еще попытаемся вас развести, наверное, где-то по
[01:00.880 --> 01:08.840]  двум-трём аудиториям в лекционное время, чтобы у нас не было вот такого большого хаоса. Потому
[01:08.840 --> 01:14.120]  что я представлю, что будет, если сюда придет 400 человек, писать контрольную. Это будет...
[01:14.120 --> 01:26.880]  Это очень плохой опыт. Как говорится, тесноте да не в обиде. Мы постараемся все-таки развести,
[01:26.880 --> 01:33.080]  найти аудиторию, заранее написать, кто в какую аудиторию пойдет. Это что касается контроля.
[01:33.080 --> 01:42.560]  Давайте сразу, есть ли еще какие-то организационные вопросы. У кого нет организационных вопросов.
[01:42.560 --> 01:54.240]  У меня есть организационный вопрос, что... Да, вопрос какой-то? Это просто слишком громкий
[01:54.240 --> 01:58.720]  разговор. Хорошо, значит, мы в прошлый раз с вами остановились на том, что у нас есть разные уровни
[01:58.720 --> 02:05.360]  тестирования. И мы поговорили о том, что у нас с вами по факту есть четыре уровня. Так, секунду,
[02:05.360 --> 02:12.240]  сейчас мне Visual Studio CAD кажется задолбет сегодня, если я его не закрою. Это мы сделаем вот так.
[02:12.240 --> 02:19.080]  Значит, мы сказали, что у нас с вами есть unit-тестирование, у нас с вами есть интеграционное
[02:19.080 --> 02:25.160]  тестирование, после этого у нас идет системное тестирование и в конце у нас с вами идет приемочное
[02:25.160 --> 02:32.320]  тестирование. То есть, мы по факту с вами можем расширять наши уровни тестирования до максимально
[02:32.320 --> 02:40.680]  высокого уровня. Приемочное тестирование является самым неприятным, потому что, как ни странно,
[02:41.080 --> 02:47.440]  не выполнение приемочного тестирования обычно приводит к штрафам. Но не к штрафам за сдачу
[02:47.440 --> 02:56.040]  задания, образно говоря, а к физическим штрафам на энную сумму денег. Потому что там как раз
[02:56.040 --> 03:00.840]  проверяются условия договоров. Так, значит, смотрите, теперь про каждый уровень тестирования
[03:00.840 --> 03:06.920]  мы вкратце пробежим. Я не хочу детально тут останавливаться на всех аспектах, потому что
[03:07.080 --> 03:14.560]  это, наверное, будет большое количество теорий, которые сейчас, наверное, не особо нужно. Хотя
[03:14.560 --> 03:24.040]  неплохо было бы понять. Если мы говорим про каждый уровень, то для каждого уровня тестирования нам
[03:24.040 --> 03:29.840]  необходимо задаться 5 вопросов. Во-первых, первое, это задаваемые цели, то есть, что мы хотим проверить
[03:30.440 --> 03:37.160]  уровне тестирования. Второе, это входные данные для данного уровня тестирования. Это называется
[03:37.160 --> 03:42.720]  базисом тестирования. Вот смотрите, тут важный момент будет состоять в том, что иногда для
[03:42.720 --> 03:50.900]  некоторых уровней базис тестирования – это как ни странно не то, что мы с вами тестируем. То есть это
[03:50.900 --> 03:56.580]  не объект тестирования. Иногда может показаться, что что-то может являться объектом тестирования.
[03:56.580 --> 04:03.020]  но на самом деле мы это не тестируем мы это подаем на вход что вы понимали после этого мы говорим
[04:03.020 --> 04:10.140]  про типичные дефекты и сбои давайте я спрашиваю с прошлой лекции что такое дефект а что такое сбои
[04:10.140 --> 04:33.300]  да да только уточню значит дефект это то что нашли в процессе разработки не обязательно в
[04:33.300 --> 04:39.340]  процессе отладки это могло произойти и в процессе тестирования а программный сбои это то что нашли
[04:39.660 --> 04:44.620]  конечные пользователи вот и последний момент который здесь есть это подходы к решению то есть
[04:44.620 --> 04:51.680]  кто является проверяющим на этом уровне тестирования кто проводит тестирование и так далее то есть мы
[04:51.680 --> 04:58.740]  будем говорить с вами про эти пять пунктов давайте начнем следующего значит начнем мы с первого
[04:58.740 --> 05:04.940]  тестирования unit тестирование или компонентное тестирование значит и цели этого уровня тестирования
[05:04.940 --> 05:08.300]  заключается в следующем, что, во-первых, мы даем некоторую уверенность в том
[05:08.300 --> 05:12.980]  качестве компонента, который мы с вами тестируем, проверяем модуля. Дальше мы
[05:12.980 --> 05:18.820]  говорим следующее, что у нас с вами должен быть, мы должны находить дефекты в
[05:18.820 --> 05:24.940]  компоненте, ну и сбоя, да, ну сбоя мы не находим, да, потому что сбоя нам сообщают.
[05:24.940 --> 05:30.060]  И более того, мы для каждого уровня тестирования будем говорить следующее,
[05:30.060 --> 05:36.780]  что он как бы является опорой в верхнем уровне тестирования и сбоем, точнее основой,
[05:36.780 --> 05:41.300]  смотри, то есть он является основой для более верхнего уровня тестирования, и при этом,
[05:41.300 --> 05:50.260]  если у нас находится сбои в уровне x, то на уровне x-1, собственно, скорее всего у нас есть баг. Вот это
[05:50.260 --> 05:55.860]  цель тестирования. Вот теперь важный момент, который касается того, что является базисом
[05:55.860 --> 06:03.380]  тестирования, и как ни странно нам на вход подают код. Вот это очень важно, то есть мы не код
[06:03.380 --> 06:08.740]  тестируем, мы наоборот на вход получаем код. Значит, дополнительно, что нам может еще прийти,
[06:08.740 --> 06:15.820]  это проработанный дизайн компонента, да, то есть как у нас компонент выглядит. Можно, кстати, это,
[06:15.820 --> 06:23.220]  я не знаю, взять ту же самую CRC-карточку или диаграмму классов в определенном компоненте,
[06:23.220 --> 06:30.060]  то есть вы видите взаимосвязь. Дальше, у нас должна быть некоторая модель данных. Что это означает,
[06:30.060 --> 06:37.580]  я сейчас расскажу. Смотрите, у вас есть, допустим, какие-то наборы полей, образно говоря, вы начали
[06:37.580 --> 06:43.940]  уже работать с проектом. У вас есть какие-то классы, которые хотелось бы сохранять и
[06:43.940 --> 06:49.820]  использоваться ими именно как данными. Вот как раз модели данных, это вот эти вот классы и их
[06:49.820 --> 06:54.860]  хранение. Нам про их хранение пока мы не говорим, здесь мы пока говорим про бизнес логику нашего
[06:54.860 --> 06:59.580]  процесса. И должна быть еще дополнительная спецификация компонента, то есть application
[06:59.580 --> 07:05.140]  programming interface, то есть каким образом мы можем к этому компоненту подключиться. Объекты
[07:05.140 --> 07:10.620]  тестирования, вот это важно. Значит, первое, это компоненты и модули. Ну, модули это имеется в
[07:10.780 --> 07:18.860]  классы в том числе. Структуры данных, классы и модули баз данных. Пока что мы не затрагиваем
[07:18.860 --> 07:23.980]  базу данных, но давайте поймем каким образом мы с вами можем протестировать структуру данных.
[07:23.980 --> 07:33.660]  Давайте попробуем написать определенный тест. Как протестировать то, что перед нами stack?
[07:41.380 --> 07:46.020]  Тут именно нужно конкретно. Давайте я даже при помощи Google теста напишу.
[07:46.020 --> 08:12.780]  Так, не знаю, checkorder. Значит, у нас есть, не знаю, допустим, stack and of a,
[08:12.780 --> 08:26.900]  я пишу однобуквенные переменные. Итак, и немного псевдокод. Что нам нужно сделать с этим stack,
[08:26.900 --> 08:32.260]  чтобы проверить, что это stack? Так, давайте пусть это не будет stack and of, а пусть это будет
[08:32.260 --> 08:43.580]  наш stack какой-нибудь, который мы хотим протестировать. Сколько нам элементов нам нужно будет?
[08:43.580 --> 09:01.300]  Давайте проголосуем. Кто за 3? Кто за 2? Там нужно проверить, что перед нами stack.
[09:02.260 --> 09:17.860]  Каким свойством обладает stack? First in, last in, first out. То есть тот элемент, который последним
[09:17.860 --> 09:22.180]  заходит, тот первым и выходит. Соответственно, можем ли мы проверить это при помощи одного
[09:22.180 --> 09:38.940]  элемента? Нет, если мы положим два элемента. Ну да, минимальный тест, если чисто задаваться,
[09:38.940 --> 09:42.380]  то это будет два элемента. Понятно, что можно сделать более сложный тест, допустим, для того,
[09:42.380 --> 09:48.820]  чтобы отличить его от другой структуры данных, которая связана с каким-то порядком. Так, давайте
[09:48.820 --> 10:04.340]  как раз реализуем. Значит, у нас получается stack push 1, stack push 2. Так, дальше что нам нужно сделать?
[10:04.340 --> 10:13.820]  Надо посмотреть топовые элементы. Давайте я использую питоновский синтаксис для того,
[10:13.820 --> 10:21.180]  чтобы код сократить. То есть с поп возвращается элемент сразу с нашей структуры. Ну и тогда нам
[10:21.180 --> 10:43.020]  нужно написать что-то в духе assert equal. Так, двойки stack top, stack pop и assert equal 1 stack.pop.
[10:43.020 --> 10:56.940]  Вот у нас тест, который проверяет последовательность лифа. То есть для очереди это не пройдет.
[10:56.940 --> 11:08.620]  Кстати, вопрос. Затронем тоже интересную тему, связанную с тем, что будет в реализации в
[11:08.620 --> 11:15.380]  зависимости от того, что мы попробуем вытащить еще один элемент из стека после того, как вытащили этот.
[11:15.380 --> 11:24.060]  Как поведут себя разные языки программирования? Давайте поговорим про этот аспект. У кого какие
[11:24.060 --> 11:41.340]  варианты? Кто-то сёкфолкнется. Давайте с точки зрения реализации. В одном из случаев у нас может
[11:41.340 --> 11:56.980]  прилететь exception. Если мы говорим про C-подобные языки. Там не то что undefined behavior,
[11:56.980 --> 12:05.180]  либо используется специальный флаг. Это флаг ерно. То есть мы можем задать флаг,
[12:05.180 --> 12:16.220]  с которым мы по факту дадим код возврата для нашей функции. Кажется, кто-то уже задавал такие вопросы,
[12:16.220 --> 12:24.620]  о как в UML диаграбе реализовывать возврат ошибки. Некоторые языки программирования делают следующее.
[12:24.620 --> 12:37.660]  Они возвращают пару. Error, exception и result. Что означает этот вывод? Это означает, что если у
[12:37.660 --> 12:45.700]  нас есть какая-то ошибка, то вот здесь ошибка становится не нулевой, и мы можем получить код
[12:45.700 --> 12:57.060]  исключения. А если у нас нет никакой ошибки, то возвращается результат. В Rust, в JavaScript вот такой
[12:57.060 --> 13:05.700]  код пишется. Просто всегда это работает по-разному. В зависимости от языка программирования и как раз
[13:05.700 --> 13:13.700]  обработка исключительных событий производится по-разному. Так, хорошо. Про тест понятно?
[13:15.700 --> 13:24.460]  Как пишется для стека? Такой простой достаточно пример. Понятно, что у нас тесты могут быть
[13:24.460 --> 13:31.500]  намного сложнее. Так, теперь смотрите, типичные ошибки, которые у нас могут быть. Первая типичная
[13:31.500 --> 13:40.500]  ошибка это некорректная логика. Грубо говоря, мы в каком-то месте поставили больше, а должны были
[13:40.500 --> 13:47.260]  поставить меньше. То есть какие-то простые знаки где-то опечатались в каком-то значении. Вот,
[13:47.260 --> 13:50.980]  дополнительно у нас может быть проблема с потоком передачи данных и управления. Это,
[13:50.980 --> 13:59.500]  образно говоря, if и else местами поменяли. Можешь такое случиться в коде, когда вы пишете код?
[13:59.500 --> 14:08.980]  Нет, нет, нет. Условия, которые вы написали, то есть вы написали условия внутри if, если оно
[14:08.980 --> 14:13.860]  выполнено идет в одно место, если не выполнено идет в другое место. Да, понятно, что эти условия
[14:13.860 --> 14:22.500]  можно поменять. Или, допустим, вы забыли, чем while do отличается от do while. Такое тоже вполне возможно.
[14:24.500 --> 14:30.060]  А еще, возможно, вы используете какие-то более продвинутые операторы. Кстати,
[14:30.060 --> 14:43.180]  про вот такой момент. Наверное, вы знаете, что это делает. A равно b++. Такой код сложно
[14:43.180 --> 14:56.940]  читать, если, особенно, не посвященный человек. Ну, честно, иногда вас могут не понять. Это,
[14:56.940 --> 15:02.820]  опять же, сугубо субъективная вещь. И, опять же, такие вещи в том числе проверяются на стадии
[15:02.820 --> 15:08.020]  верификации. То есть команда разработчиков, с которой вы работаете, готова читать такое или
[15:08.020 --> 15:15.100]  не готова читать такое. Если готова, то окей. Если не готова, то придется корректировать это все
[15:15.100 --> 15:21.660]  дело. Значит, смотрите, для специфика. Блин, я вспомню, что я книги забыл. Надо себе напоминание
[15:21.660 --> 15:33.500]  поставить. Специфика компонентного тестирования заключается в том, что требование, которое у нас
[15:33.500 --> 15:39.100]  появляется для тестирования, выявляется, на самом деле, через процесс code review или через демо
[15:39.100 --> 15:45.180]  продукты. То есть, когда вы идете с заказчиком и показываете ему разные функциональности. А потом,
[15:45.180 --> 15:52.860]  представьте себе, ваш заказчик вбивает формочку поля, и у него программа падает.
[15:54.660 --> 16:00.380]  Значит, если мы говорим про гибкие методологии разработки, то тут зачастую применяется так
[16:00.380 --> 16:06.220]  называемый тест driven development. Собственно, что такое тест driven development? Это методика,
[16:06.220 --> 16:12.380]  которая позволяет делать следующее. Сначала вы пишете тесты, потом пишете минимальный код,
[16:12.380 --> 16:17.420]  который проходят эти тесты. Давайте в качестве эксперимента попробуем это сделать.
[16:17.420 --> 16:32.140]  Сейчас секунду. Так, давайте я открою. Где у меня? Green Feed Patterns Collection, да. Давай, перезагружай.
[16:38.740 --> 16:40.020]  Сейчас у меня проект загрузится.
[16:40.020 --> 16:53.660]  Я использую библиотеку Pytest для демонстрации. И после этого мы с вами как раз покажем пример.
[16:53.660 --> 17:07.180]  Грузит, грузит, грузит, грузит, грузит. Давайте, короче, удаленное исполнение сегодня нам
[17:07.180 --> 17:19.420]  сказала привет, поэтому мы напишем все в командной строке. Или сделаем... Да. Отлично.
[17:19.420 --> 17:37.660]  Значит, как работает методика тестирования? Так, я открываю новую сессию. Сейчас активирую
[17:37.660 --> 17:48.620]  и поставлю библиотеку Pytest, чтобы быстрее написать. Все, она стоит. Значит, смотрите,
[17:48.620 --> 18:00.300]  давайте мы напишем с вами код в файле test.py. Значит, fromTriangle import isTriangle. Сейчас я...
[18:00.300 --> 18:16.620]  Кстати, обращу внимание. Сразу... Так, я не знаю, видно или нет. Мне кажется, плохо видно, да? Так,
[18:16.620 --> 18:34.060]  сейчас поменяем. Так, лучше. Ладно, from не видно, ну и ладно. И вы не поверите, это первый тест.
[18:34.060 --> 18:56.060]  Почему он у нас не выполнится? Кто понимает? Ну, смотрите, мы написали с вами модуль под
[18:56.060 --> 19:11.180]  названием Triangle. Ну да, можно, кстати, вот видите, то есть у нас вообще framework не запустился,
[19:11.180 --> 19:15.740]  нам явно выдают ошибку. То есть, мы первый функциональный, с которым можем вообще проверить,
[19:15.740 --> 19:33.300]  это test import. Да, это бред, но все-таки это... О, видите, тест провалился. Один тест failed. Отлично.
[19:33.300 --> 19:52.580]  Как его починить? Нам, наверное, нужно создать Triangle. Смотрите, у нас методика red, то есть у нас
[19:52.580 --> 20:00.340]  тест не прошел. Дальше мы пишем минимальный код, который проходит тест. Тест прошел. Так, теперь
[20:00.340 --> 20:06.980]  давайте, наверное, что-нибудь более умное сделаем. И как раз тут важно именно минимальность тех
[20:06.980 --> 20:18.380]  итераций, которые у нас проходят. Значит, дальше давайте тест... Сделаем следующее. Теперь мы
[20:18.380 --> 20:28.380]  можем сделать три фактор, потому что у нас код есть. Я пока что продублирую код. А дальше мы с
[20:28.380 --> 20:44.620]  вами сделаем следующее. Assert 3, 4, 5. Является ли это треугольником? Да, является, но тест у нас не
[20:44.620 --> 20:51.220]  прошел. У нас тест не прошел, потому что мы не передали большое количество аргументов. Смотрите,
[20:51.220 --> 21:07.980]  дальше мы переходим с вами к концепции ABC. Вот. Почему у нас тест не прошел? Ну, потому что у нас
[21:07.980 --> 21:20.580]  none возвращается. Как сделать минимальный код, который проходит этот тест? Да, бинго.
[21:21.220 --> 21:31.980]  Нам нужно всегда возвращать true. Так, давайте я перенос в конце строки поставлю, потому что это
[21:31.980 --> 21:52.540]  важно. Вот. Да, тест проходит. Теперь какой тест нам нужно это написать? Да, некорректный. Not
[21:52.540 --> 22:03.300]  triangle. Да, тесты при этом стараемся писать triangle. Что там? Какой-нибудь треугольник. Надо было в
[22:03.300 --> 22:12.740]  прошлый раз записать все ответы, которые у нас были. Так, смотрите, тест не проходит. Как его
[22:12.740 --> 22:39.660]  починить? Минимальный код, который учинят. Да, кстати. Да, кстати, проблемы с логикой и про то,
[22:39.660 --> 22:56.220]  что я говорил. Ты что? Вы сохранили? Нет, не сохранил. Спасибо. О, тест проет. Так, смотрите,
[22:56.220 --> 23:05.860]  вы написали один тест на true, один тест на false. И дальше возникает методика в методологии TDD,
[23:05.860 --> 23:13.780]  называется триангуляция. То есть у нас получается, смотрите, у нас есть вершина треугольника 1,
[23:13.780 --> 23:23.380]  в ней ответ true, допустим. Вершина треугольника 2, в ней ответ false. И есть вершина 3,
[23:23.380 --> 23:29.860]  которая определит, правильно у нас логика или нет. Давайте придумаем тест.
[23:29.860 --> 23:59.500]  Не-не, пока полтора. Так, назовем его. Пока назовем его middle, конечно,
[23:59.500 --> 24:06.940]  видите, у нас провалился тест и, наверное, здесь уже надо применять какую-то логику.
[24:06.940 --> 24:17.420]  Да, какая минимальная логика теперь? Нет-нет-нет, ну понятно, что ефать уже здесь, наверное,
[24:17.420 --> 24:29.220]  не надо. Ну, то есть надо. Наверное, хочется сказать return a plus b больше c. Четыре,
[24:29.220 --> 24:35.460]  четыре теста пройдено. И вот, смотрите, здесь наступает, вот поп-ти, в прошлый раз говорили
[24:35.460 --> 24:43.940]  про принцип тестирования, наступает парадокс пестицида. То есть, как бы, тот код, который мы
[24:43.940 --> 24:49.340]  с вами уже добавили, на самом деле, для этой реализации некоторая функциональность уже не нужна.
[24:49.340 --> 24:57.020]  Какой тест мы можем выкинуть после того, как появилась вот эта реализация? Ну, на самом деле,
[24:57.020 --> 25:02.780]  можно либо выкинуть, либо первый тест. Ой, получается, во-первых, первый тест можно выкинуть,
[25:02.780 --> 25:08.580]  потому что у нас есть импорты. И вот один из, первый тот, который на импорт, либо один из этих.
[25:08.580 --> 25:19.900]  А, наверное, лучше выкинуть. Давайте, допустим, мы сделаем refactoring и уберем вот этот тест.
[25:19.900 --> 25:28.380]  И тест импорт. Да, тестов стало меньше, но при этом функциональность у них стала ровно такой же.
[25:28.380 --> 25:42.140]  Хорошо. Так, и теперь еще один тест, который нам нужен. Какой? Да, кстати, тест.
[25:42.140 --> 26:04.660]  Не, не 1.511, 1.511 пройдет. 2.111. Вот, то есть, мы пишем вот такой тест.
[26:04.660 --> 26:17.620]  Что? Ну, на самом деле, зависит от того, который мы напишем. Поскольку мы все-таки пишем на
[26:17.620 --> 26:28.500]  питоне, то реализация, которая поменяет это все, она очень такая. Опять же, ай, дайте выйти.
[26:28.500 --> 26:45.420]  Вот так вот. Все, вот нашлись мы. На самом деле, мы сделаем вот такое вот. Опять же,
[26:45.420 --> 26:52.340]  этот код не читабельный, сразу говорю. То есть, вот, тест. Теста пройденным,
[26:52.340 --> 27:04.820]  наш функциональность есть. Ну, теперь смотрите, я включу статический анализатор кода. Это вещь,
[27:04.820 --> 27:12.500]  которая проверит наш код на качество. То есть, есть статический анализатор кода вида Flake 8,
[27:12.500 --> 27:18.140]  по которому я, в принципе, старался мой код оформлять. Но если мы с вами запустим как раз
[27:18.140 --> 27:38.060]  вот этот код, как вы думаете, на что он сругнется? Слишком короткие названия переменных. Да, он еще
[27:38.060 --> 27:50.060]  любит оценки ставить. Ну, кстати, он сругнулся, что у нас не хватает dot string, лишний перевод строки
[27:50.060 --> 27:58.540]  в конце. О, видите, нам оценку повесили. То есть, здесь некоторые штуки можно игнорировать.
[27:58.540 --> 28:07.940]  Давайте тесты пройдемся статическим анализатором кода. Да, что-то у меня тут много переносов
[28:07.940 --> 28:15.500]  строк. Кстати, странно, что он не сругнулся на однобуквенные переменные. Хотя, по идее,
[28:15.500 --> 28:30.980]  должен был сделать это все. Вот. Но есть еще другой анализатор кода. Аккуратнее. Flake 8 triangle pi.
[28:30.980 --> 28:42.220]  О, и вот он нам уже сказал, что single letter variables like a нельзя использовать. Ну,
[28:42.220 --> 28:58.300]  или мы можем использовать Flake 8 для тестов. Он, наверное, сказал, что это однобуквенные
[28:58.780 --> 29:04.220]  переменные. То есть, имеется в виду аргументы функции, он не позволяет. Так, и смотрите,
[29:04.220 --> 29:11.900]  здесь он сказал, что нам нужно сделать два переноса строки. Вот. То есть, это уже статический анализ кода.
[29:11.900 --> 29:21.180]  Во, все. Ну, здесь, в принципе, можно оставить abc. Главное, что аккуратнее делать. То есть,
[29:21.180 --> 29:29.180]  можно прямо поставить, образно говоря, Flake 8 ignore на такую-то строку, чтобы статический анализатор
[29:29.180 --> 29:35.460]  кода понимал, что ему не надо проверять эту функциональность, и он пробежал бы дальше. Вот.
[29:35.460 --> 29:41.980]  Вот такая методология. Понятно, что чем больше у нас опыт в этой штуке, тем больше мы можем
[29:41.980 --> 29:47.220]  проскакивать некоторые шаги. То есть, я сейчас просто показал, так сказать, для новичков, как это
[29:47.220 --> 29:54.940]  работает. Да, понятно, что там, чем больше человек, тем больше у нас с вами как раз тестов будет
[29:54.940 --> 29:59.700]  написано. Да, причем имеем хорошую основу на тестов, вы можете спокойно проводить рефакторинг,
[29:59.700 --> 30:07.660]  потому что, в принципе, если что, вы в гитте потом откатитесь. Так, понятно суть? Вот это,
[30:07.660 --> 30:13.860]  что, вот эта методология. Хорошо. Так, фасад нам. Лево. Давайте дальше. Следующий уровень.
[30:13.860 --> 30:19.900]  Поднимаемся выше. Интеграционное тестирование. Цель удостоверится, во-первых, что два уровня,
[30:19.900 --> 30:26.940]  которые ниже, унит и системный, у нас с вами является фундаментом. То есть, у нас получается,
[30:26.940 --> 30:31.740]  интеграционное тестирование является фундаментом для системного, и при этом, если у нас есть
[30:31.740 --> 30:37.500]  ошибки на интеграционном уровне, то мы спускаемся с вами на унит уровень. Вот. Дальше нам нужно будет
[30:37.500 --> 30:42.260]  убеждаться в качестве интерфейсов наших, и дополнительно мы можем с вами проверить здесь,
[30:42.460 --> 30:48.820]  что какие-то функциональные требования к определенным сервисам, взаимосвязи между ними как раз
[30:48.820 --> 30:53.940]  корректно проведены. Значит, какие бывают виды интеграционного тестирования? Значит, если мы
[30:53.940 --> 31:00.260]  говорим про обычные интеграционные тесты, то они идут либо между компонентами, то есть, у нас
[31:00.260 --> 31:07.660]  код есть, у нас компонента A есть, есть компонента B, и есть взаимосвязь между сервисами или микросервисом.
[31:07.660 --> 31:12.500]  Про сервисы мы будем говорить чуть дальше, мы будем поднимать свои маленькие серверы, между которыми
[31:12.500 --> 31:20.180]  будет происходить взаимодействие между собой. Вот. Значит, при этом базис тестирования, кстати,
[31:20.180 --> 31:27.740]  здесь уже некоторые знакомые вещи есть. Значит, первое это дизайн системы и софта, второе это
[31:27.740 --> 31:33.540]  диаграмма последовательности, то есть можно использовать их. Варианты использования тоже можно
[31:33.540 --> 31:38.540]  смотреть их, дать пример с регистрацией, я не помню прислал или нет, если не прислал, напишите,
[31:38.540 --> 31:44.460]  пожалуйста. Спецификации протоколов, то есть по какому протоколу вы отправляете данные и при
[31:44.460 --> 31:50.060]  помощи какого формата вы принимаете данные между сервисами. И последнее это описание внешних
[31:50.060 --> 31:55.340]  интерфейсов, то есть у вас есть описание, у вас есть диаграммы и все такое. Значит, вы тестируете
[31:55.340 --> 32:03.060]  либо под систему, либо уже целую базу данных, а не табличку допустим одну, вы тестируете интерфейсы,
[32:03.060 --> 32:10.620]  микросервисы и вообще application programming interface, то есть мы с вами тестируем как раз уже полностью
[32:10.620 --> 32:19.540]  наши взаимодействия. Значит, типичные дефекты, это не совпадение интерфейсов, то есть образно
[32:19.540 --> 32:45.060]  говоря, здесь возникает интересная картинка, не знаю, знаете вы, сейчас. Круг. Во.
[32:49.540 --> 33:07.460]  Дреугольник квадрат мем. Да, то есть, а? Все смотрели теократию. Вот, и дальше, если мы говорим,
[33:07.460 --> 33:12.820]  то в технических вещах лучше настроить сразу инструмент непрерывной интеграции и определить
[33:12.820 --> 33:16.900]  связи между компонентными сервисами. Про непрерывную интеграцию мы будем говорить с вами как на
[33:16.900 --> 33:22.220]  семинарах, так и, возможно, на лекции, затронем эту тему. Значит, как проводить интеграционное
[33:22.220 --> 33:26.660]  тестирование? Как раз здесь нужно будет создавать некоторые заглушки, про заглушки мы поговорим чуть
[33:26.660 --> 33:32.820]  позже, и цель будет как раз сделать так, чтобы заглушить все, кроме самого механизма передачи
[33:32.820 --> 33:41.020]  данных, то есть вы по факту делаете, грубо говоря, стену, то есть вы отправляете запрос на какой-то
[33:41.020 --> 33:51.460]  сервис, да, то есть у вас есть А, вы отправляете запрос сервису В, а посередине вместо В ставите
[33:51.460 --> 34:01.460]  С, который вам будет возвращать конкретный ответ. Вот, и как раз такое можно делать при помощи заглушек.
[34:01.460 --> 34:07.260]  Вот, собственно, когда вам нужно протестировать взаимодействие между сервисом А и, допустим,
[34:07.260 --> 34:13.340]  между остальными сервисами, допустим, у нас был еще какой-то сервис Д, и нам нужно протестировать
[34:13.340 --> 34:19.420]  взаимодействие, но при этом у нас от А перед тем, как мы отправить информацию в Д, должны
[34:19.420 --> 34:26.020]  отправить что-то внутри сервиса В, и с А должна произойти отправка в В, это означает следующее,
[34:26.020 --> 34:33.660]  что нам нужно по факту заглушить механизм, посмотреть, что нам возвращается, и с этими как раз
[34:33.660 --> 34:39.620]  данными прийти в сервис Д. И вот как раз видно, что если попытаться просто нарисовать это все на
[34:39.620 --> 34:45.300]  диаграмме, на той, которой я показал, что это вообще непонятно, что происходит, и в данном случае как
[34:45.300 --> 34:50.500]  раз будет более полезно использовать диаграмму последовательности, то есть как бы давайте как раз
[34:50.500 --> 35:00.540]  проведем ее, значит, пример, у нас есть объект А класса А, значит, у нас дальше есть, значит, кто
[35:00.540 --> 35:12.300]  получается объект B класса D, и есть экземпляр D класса D, значит, я тут не буду специфицировать
[35:12.300 --> 35:18.380]  именно то, в каком порядке они вызываются, точнее, как, с какими параметрами они вызываются,
[35:18.380 --> 35:26.020]  но в целом следующее, значит, у нас получается идет вызов сервиса D, а нет, сначала у нас идет вызов
[35:26.020 --> 35:42.300]  сервиса D, дальше у нас возвращается определенный результат, то есть это шаг 1, а после этого у нас
[35:42.300 --> 36:01.740]  идет вызов к сервису D, вот, да, кстати, тут тоже стрелочки, вот такие, да, и как раз вы вот сюда в
[36:01.740 --> 36:09.380]  качестве менедзе мидла вставляем объект C, который перехватывает наши запросы и будет возвращать какие-то
[36:09.380 --> 36:18.660]  готовые результаты, вот, и видно, что вот то, что я рисовал на вот этой диаграмме, оно не является достаточно
[36:18.660 --> 36:24.180]  точным, но на вот этой диаграмме, кажется, это стало понятнее, давайте проголосуем, кому понятно,
[36:24.180 --> 36:39.180]  что, кому понятнее вот эта диаграмма, кому понятнее вот эта диаграмма, ну, остальные воздержались,
[36:39.180 --> 36:49.380]  или не поняли обе две диаграммы, так, кто не понял обе две эти диаграммы, не стесняйтесь,
[36:49.380 --> 37:07.460]  тогда давайте вопроса, ну, как-нибудь я помогу переформулировать, вот эти блоки на вот этой
[37:07.460 --> 37:13.220]  диаграмме означают, когда эта функция или когда этот объект является активным, то есть когда по
[37:13.220 --> 37:21.300]  линии жизни, если мы посмотрим, наложим ось T, это означает, когда эти объекты реально выполняют
[37:21.300 --> 37:28.180]  какую-то роль, функцию, то есть в другое время объекты просто существуют и не выполняют никакую
[37:28.180 --> 37:46.900]  функциональность, да, вызов функции, да-да-да, вызов ведется с функцией функцию D, вначале функцию B,
[37:46.900 --> 37:52.980]  потом вот пунктирная стрелочка означает, что у нас идет результат, да, кстати, правильно еще вот
[37:52.980 --> 38:01.460]  эту штуку заштриховать, да, потому что у нас объект A тоже как бы ждет результатов вызовов других
[38:01.460 --> 38:27.340]  функций. Ну да, ответ приходит не сразу, то есть оно могло быть сделано так, смотрите,
[38:27.340 --> 38:35.500]  тут еще есть некоторый важный аспект, но он касается именно UML, обычно его не четко обрисовывают,
[38:35.500 --> 38:41.580]  значит, если у вас стрелочка такая, это означает, что у вас функция синхронная, это означает,
[38:41.580 --> 38:48.580]  что вы же ожидаете результаты ответов, если у вас стрелочка не синхронная, то тогда у вас могло
[38:48.580 --> 38:54.580]  произойти следующее, у вас могло, я не знаю образно говоря, вот эта функция когда-то работает и
[38:54.580 --> 39:02.420]  не обязательно вам приходит ответ от этого объекта, то есть это допустим мы запускаем что-то в отдельном
[39:02.420 --> 39:08.540]  потоке, то есть делаем отложенный вызов, то есть нам результат функции не обязательно вернет,
[39:08.540 --> 39:16.700]  а возврат обычно происходит при помощи другого механизма уже, но это нам надо будет тоже немного
[39:16.700 --> 39:21.420]  про будущее поговорить, потому что я тут уже, если я сейчас начну рассказывать это, мы начнем
[39:21.420 --> 39:28.940]  говорить про сетевое взаимодействие, прямо здесь и на месте, так, я ответил на вопрос,
[39:28.940 --> 39:36.980]  все, хорошо, давайте двигаться тогда дальше, значит, поднимаемся еще на уровень выше,
[39:36.980 --> 39:43.580]  системное тестирование, это уже иногда их называют end-to-end тестами, потому что мы запускаем нашу
[39:43.580 --> 39:49.100]  систему от самого начала до самого конца, и цель этого уровня тестирования заключается в том,
[39:49.100 --> 39:52.940]  что мы валидируем то, что система готова к работе и то, что система работает корректно,
[39:52.940 --> 40:00.420]  далее мы пытаемся с вами находить дефекты в работе всей системы целиком, то есть вы запускаете,
[40:00.420 --> 40:04.020]  грубо говоря, сайт локально, либо какое-то приложение и начинаете его тестировать,
[40:04.020 --> 40:10.420]  кнопочки, а дальше вы пытаетесь уменьшить риски, то есть то, что если у вас есть хоть какие-то
[40:10.420 --> 40:17.500]  тесты и при этом это тесты не простые совсем тесты, какие-то даже нормальные тесты, грубо говоря,
[40:17.500 --> 40:24.060]  что у вас программа запускается, вы можете ввести какие-то поля, нажать на enter, это уже, знаете,
[40:24.060 --> 40:31.540]  успех, потому что, кстати, проводили исследования, брали, значит, по-моему, гитхаб, брау,
[40:31.540 --> 40:38.340]  джупитер ноутбуки людей, джупитер ноутбук это тетрадка, в которой люди пишут код, ну, грубо
[40:38.340 --> 40:43.860]  говоря, на питоне, дальше интерактивно его исполнять, так вот, оказалось, что 35 процентов джупитер ноутбуков,
[40:43.860 --> 40:49.460]  которые лежат в сети, они выполняются неверно, то есть их начинаем прогонять с самого начала
[40:49.460 --> 41:00.260]  до самого конца и там возникают ошибки, вуаля, то есть запустите проверить, что все подряд
[41:00.260 --> 41:08.180]  выполняется, это уже хорошо, так, теперь что касается системного тестирования, какой тут базы
[41:08.180 --> 41:12.780]  тестировать, во-первых, спецификация системы, это функциональные и не функциональные требования,
[41:12.780 --> 41:18.220]  дальше отчет анализа рисков, то есть, грубо говоря, вы приходите, вам присылают следующую
[41:18.220 --> 41:25.060]  информацию, вы запускали систему и вам говорят, образно говоря, у вас, значит, существует риск,
[41:25.060 --> 41:36.140]  на улице сейчас будет минус 30 и, возможно, вы останетесь без отопления, вот, где может прорвать,
[41:36.140 --> 41:42.260]  просто говоря, дальше, значит, у нас могут быть эпики, это большие наборы задач в agile,
[41:42.260 --> 41:47.860]  прямо, типа, от начала до конца, линия жизни, так сказать, и user stories, то есть, у нас можно
[41:47.860 --> 41:53.420]  использовать как раз фичи, которые просят от нас заказчик, собственно, мы идем по этим фичам,
[41:53.420 --> 42:00.140]  раскладываем этот вариант использования и идем и просто по вариантам использования проверяем то,
[42:00.140 --> 42:05.980]  что у нас происходит, ну и, конечно же, не надо забывать гайды и мануалы, потому что если у вас
[42:05.980 --> 42:13.260]  есть, представьте себе, вы открываете мануал, читаете его, пытаетесь выполнить по шагам и у вас
[42:13.260 --> 42:24.140]  не работает, будет интересно, как такой продукт сертифицировали, значит, что мы тестируем с
[42:24.900 --> 42:31.420]  вы? Мы тестируем с вами здесь приложения, все целиком, все целиком, далее системы под различными тестовыми
[42:31.420 --> 42:37.500]  нагрузками, то есть вы проверяете, образно говоря, справляется ли ваша система с разными нагрузками,
[42:37.500 --> 42:42.340]  то есть, вы делаете пять запросов в секунду, десять запросов в секунду, двадцать запросов в секунду,
[42:42.340 --> 42:48.080]  сорок запросов в секунду и так далее, вот, как ни странно на выходных система не справилась
[42:48.080 --> 42:51.040]  правила с нагрузкой из-за неправильного распределения
[42:51.040 --> 42:52.040]  ресурсов.
[42:52.040 --> 42:55.080]  Но про это вам уже будут говорить на курсе распределенных
[42:55.080 --> 42:58.520]  вычислений, потому что тут уже тематика связана
[42:58.520 --> 43:01.360]  с тем, что на самом деле АКЧЕКТО находится не на одном
[43:01.360 --> 43:03.640]  компьютере, а на большом количестве компьютеров.
[43:03.640 --> 43:06.920]  Вот, и конфигурация системы, то есть вы можете допустить
[43:06.920 --> 43:10.120]  допустим вашу систему в одном режиме, в другом режиме,
[43:10.120 --> 43:13.080]  в третьем режиме, то есть у вас всегда, если вы запускаете
[43:13.080 --> 43:16.440]  какую-то нормальную систему, у вас возможно не то чтобы
[43:16.440 --> 43:19.440]  отладка, у вас существует механизм логирования действия,
[43:19.440 --> 43:22.240]  то есть когда вы пишете, что, образно говоря, куда
[43:22.240 --> 43:25.480]  каждый пользователь зашел, какая функция вызывается,
[43:25.480 --> 43:29.160]  более того, можно отслеживать время работы этих функций.
[43:29.160 --> 43:32.520]  Вот, это объект нашего тестирования.
[43:32.520 --> 43:35.460]  Значит, типичные ошибки, значит, неверное поведение
[43:35.460 --> 43:39.960]  системы в различных ситуациях, да, просто появляется какая-то
[43:39.960 --> 43:42.520]  нештатная ситуация, в которую мы не могли вызвать.
[43:42.840 --> 43:46.720]  Очень легко, на самом деле, в данном случае, проамулировать
[43:46.720 --> 43:49.280]  какое-нибудь тестовое взаимодействие.
[43:49.280 --> 43:56.480]  И давайте, кстати, я вам покажу один из примеров тестирования.
[43:56.480 --> 43:59.720]  Зайдем на check и откроем вкладку разработчиков.
[43:59.720 --> 44:06.400]  Ну, кстати, эмулировать тут даже ничего не надо.
[44:06.400 --> 44:07.600]  У меня медленный интернет.
[44:12.760 --> 44:15.240]  Да, но если вы действительно хотите протестировать
[44:15.240 --> 44:17.520]  медленный интернет, то у вас есть кнопочка слоу 3G.
[44:17.520 --> 44:19.720]  Или кнопочка оффлайн.
[44:19.720 --> 44:27.800]  Да, либо кнопкой mipton.g, то есть мы, кстати, можем сделать
[44:27.800 --> 44:28.800]  ноутротлинг.
[44:28.800 --> 44:33.040]  Типа, это вот те системы, которые загружаются именно
[44:33.040 --> 44:34.360]  так, как она должна.
[44:34.360 --> 44:39.000]  Дополнительно вы можете здесь использовать разную
[44:39.000 --> 44:40.000]  функциональность.
[44:40.000 --> 44:42.880]  О, наконец-таки он начал что-то грузить.
[44:42.880 --> 44:47.320]  Ура!
[44:47.320 --> 44:51.680]  О, отгрузилось.
[44:51.680 --> 44:56.040]  Да, ну и дополнительно вы можете сделать, кстати,
[44:56.040 --> 44:58.560]  по-моему, где-то тут есть вкладочка.
[44:58.560 --> 45:00.360]  Вот такая.
[45:00.360 --> 45:01.360]  Оба.
[45:01.360 --> 45:06.000]  И вы можете протестировать, как это будет выглядеть на
[45:06.000 --> 45:08.040]  одном из устройств.
[45:08.040 --> 45:09.040]  Ваш сайт.
[45:09.600 --> 45:10.600]  Или ваше приложение.
[45:10.600 --> 45:20.200]  То есть на iPhone SE видно, что юзер-тестинг, юзабилити-тестирование
[45:20.200 --> 45:21.200]  не проходит.
[45:21.200 --> 45:25.080]  Да, потому что оно выглядит вот таким корявым образом.
[45:25.080 --> 45:26.080]  Надо это чинить.
[45:26.080 --> 45:27.080]  Как это чиниться?
[45:27.080 --> 45:31.480]  Это обычно выводится специально, так сказать, кнопочка.
[45:31.480 --> 45:32.480]  Я забыл, как называется.
[45:32.480 --> 45:33.480]  Бредкам, по-моему.
[45:33.480 --> 45:34.480]  Нет, не бредкам.
[45:34.480 --> 45:38.480]  Короче, вылетающее окошко сбоку, чтобы можно было
[45:38.480 --> 45:41.400]  зайти и как раз на него кликнуть.
[45:41.400 --> 45:42.400]  Вот.
[45:42.400 --> 45:46.000]  То есть, видите, здесь тоже можно что-то тестировать.
[45:46.000 --> 45:48.360]  То есть на личных устройствах посмотреть, как это работает.
[45:48.360 --> 45:49.360]  Вот.
[45:49.360 --> 45:54.720]  Дополнительно, значит, невозможность выполнить антуэт задачи.
[45:54.720 --> 45:59.000]  То есть мы как бы хотим пройтись по всему варианту использования,
[45:59.000 --> 46:00.000]  он у нас не работает.
[46:00.000 --> 46:01.880]  Ну и система работает не по гайдам.
[46:01.880 --> 46:04.160]  Тоже вполне корректный вариант.
[46:04.160 --> 46:07.280]  Значит, про решающую таблицу поговорим позже.
[46:07.640 --> 46:11.040]  Выяснить, система работает корректно или нет.
[46:11.040 --> 46:13.640]  Максимально важно прорабатывать альтернативные сценарии
[46:13.640 --> 46:14.640]  вариантов использования.
[46:14.640 --> 46:19.240]  Мы с вами сказали, что альтернативных сценариев у нас порядка
[46:19.240 --> 46:22.240]  90% случаев.
[46:22.240 --> 46:25.200]  Ну и больше используется статическое тестирование.
[46:25.200 --> 46:28.440]  То есть это улучшаем спецификации, улучшаем мануалы, варианты
[46:28.440 --> 46:29.440]  использования.
[46:29.440 --> 46:30.440]  Видите, user story.
[46:30.440 --> 46:36.800]  Значит, хочется всегда, так сказать, я не знаю, творить,
[46:36.960 --> 46:37.960]  писать какой-то код.
[46:37.960 --> 46:41.480]  Но зачастую вам придется сидеть и писать документацию.
[46:41.480 --> 46:44.680]  Ну или писать мануал для того, чтобы это визуально
[46:44.680 --> 46:45.680]  представить.
[46:45.680 --> 46:47.080]  Нет, конечно, есть люди под названием технические
[46:47.080 --> 46:50.960]  писатели, которые это могут делать, но все-таки лучше,
[46:50.960 --> 46:53.920]  если ваш код хоть немного задокументирован, его читать
[46:53.920 --> 46:54.920]  намного проще.
[46:54.920 --> 46:58.240]  Так, и последний уровень тестирования, это приемочное
[46:58.240 --> 46:59.240]  тестирование.
[46:59.240 --> 47:01.440]  Вы проверяете то, как работает у вас операционная составляющая.
[47:01.440 --> 47:04.640]  И в приемочном тестировании как раз есть спецификация
[47:04.640 --> 47:05.640]  по видам.
[47:05.640 --> 47:10.680]  Первое пользовательское, user acceptance testing, это система
[47:10.680 --> 47:13.640]  работает, ультворяя потребности пользователям, может вообще
[47:13.640 --> 47:15.960]  установиться на его компьютере.
[47:15.960 --> 47:18.120]  В образе говоря, вам там, не знаю, нужно запустить
[47:18.120 --> 47:19.120]  сайт.
[47:19.120 --> 47:22.360]  Кстати, такое было до недавнего времени.
[47:22.360 --> 47:26.400]  Вам нужно было запускать всякие сайты госструктур,
[47:26.400 --> 47:29.400]  именно финансовых структур, связать с бухгалтерией,
[47:29.400 --> 47:31.560]  вы не поверите на интернет-эксплоре 11.
[47:31.560 --> 47:37.960]  Да, потому что там было достаточно, то есть в свое
[47:37.960 --> 47:40.160]  время интернет-эксплоры, это был достаточно большой
[47:40.160 --> 47:43.280]  комбайн, в котором было все намешано.
[47:43.280 --> 47:47.840]  То есть иногда было проще ножками топать, чем идти
[47:47.840 --> 47:51.360]  и что-то тыкать в интернет-эксплоре, вот честно, я даже сам с таким
[47:51.360 --> 47:52.360]  столкнулся.
[47:52.360 --> 47:56.320]  Однажды, когда я пытался что-то сделать в банковской
[47:56.320 --> 47:58.960]  экосистеме, когда это было там года три еще назад.
[47:59.960 --> 48:04.440]  То есть модные кнопочные приложения, это далеко
[48:04.440 --> 48:08.240]  там не старые технологии, это достаточно современные
[48:08.240 --> 48:09.240]  технологии.
[48:09.240 --> 48:11.640]  Дальше, значит, операционные тестирования, это очень
[48:11.640 --> 48:14.840]  важно, тестирование бэкапов, установки, развертывание
[48:14.840 --> 48:17.040]  приложений, обновление до новой версии, то есть
[48:17.040 --> 48:19.800]  правильно ли обновляется, либо бенчмарки, то есть,
[48:19.800 --> 48:21.960]  грубо говоря, тестирование производительности.
[48:21.960 --> 48:24.240]  Оно тоже здесь может идти.
[48:24.240 --> 48:25.640]  Дальше, контрактное.
[48:25.640 --> 48:27.720]  Вот это очень важный вид тестирования, пока что
[48:27.720 --> 48:31.720]  кажется, что это не важно с точки зрения по, но когда
[48:31.720 --> 48:35.680]  вот мы выходим на приемку, это имеет очень важный фактор.
[48:35.680 --> 48:39.360]  Тестирование, что не нарушены никакие лицензии, условия
[48:39.360 --> 48:43.280]  контрактов между разработчиками и тестировщиками, разработчиками
[48:43.280 --> 48:44.280]  и заказчиками.
[48:44.280 --> 48:50.320]  Так, давайте честно, есть такая вещь, как лицензионные
[48:50.320 --> 48:51.320]  соглашения.
[48:51.320 --> 48:53.520]  Наверное, вы видели их.
[48:53.520 --> 49:03.160]  Да, как вы думаете, почему заставляют вас поставить
[49:03.160 --> 49:04.160]  галочку?
[49:04.160 --> 49:14.240]  Да, то, что какие-то предложения не являются афертой, побуждением
[49:14.240 --> 49:17.440]  к какому-то действию, ну и просто описывают регламент.
[49:17.440 --> 49:20.080]  То, что вы согласны на то, что если вы сделаете какое-нибудь
[49:20.080 --> 49:24.080]  санкционерное действие, допустим, у вас будет какой-то,
[49:24.080 --> 49:26.320]  понесет вам какой-то ущерб, вы согласны с этим.
[49:26.320 --> 49:30.320]  Если вы положите стать, то виноват, то вы и они будут.
[49:30.320 --> 49:33.240]  Ну, тут опять же, это уже будет обсуждаться в судебном
[49:33.240 --> 49:34.240]  порядке.
[49:34.240 --> 49:38.360]  Опять же, вот эти лицензионные соглашения должны регулироваться
[49:38.360 --> 49:41.480]  законодательством, поэтому это очень важно.
[49:41.480 --> 49:46.280]  И последнее, это альфа и бета-тестирование.
[49:46.280 --> 49:49.040]  То есть, мы про них уже говорили, альфа-тестирование
[49:49.040 --> 49:52.520]  выполняется внутренними сотрудниками, бета-тестирование
[49:52.520 --> 49:55.040]  выполняется внештатным сотрудником.
[49:55.040 --> 49:58.720]  И базис тестирования, это уже самый высокий уровень,
[49:58.720 --> 50:01.920]  это бизнес-процессы, требования системы, пользовки и соглашения,
[50:01.920 --> 50:04.760]  установочные процедуры, описание процедуры бэкапов.
[50:04.760 --> 50:08.600]  Объекты тестирования системы под различными тестовыми
[50:08.600 --> 50:13.600]  нагрузками, там, образно говоря, в ночь перед дедлайном
[50:13.600 --> 50:15.520]  или в спокоен или в летние каникулы.
[50:16.360 --> 50:20.960]  Отчеты производительности, их тоже можно получать,
[50:20.960 --> 50:24.360]  мы, кстати, их выводили, в свою очередь, и поведение
[50:24.360 --> 50:26.680]  системы после намеренного падения.
[50:26.680 --> 50:29.840]  То есть, тем может падать.
[50:29.840 --> 50:31.280]  И как она восстанавливается.
[50:31.280 --> 50:37.120]  Так, а теперь, а, еще типичные ошибки.
[50:37.120 --> 50:40.120]  Значит, рабочий процесс кеолитворяет требованиям,
[50:40.120 --> 50:43.520]  то есть, грубо говоря, вообще бизнес-процессы в компании
[50:43.520 --> 50:46.680]  нарушены, образно говоря, вам пишут обратную связь,
[50:46.680 --> 50:47.680]  а вам не отвечают.
[50:47.680 --> 50:54.640]  Вот, возможный взлом системы, тоже, кстати, вполне возможное
[50:54.640 --> 50:55.640]  поведение.
[50:55.640 --> 50:58.840]  Да, и поэтому важно следить за ошибками в безопасности.
[50:58.840 --> 51:02.880]  Или сайт упал под нагрузкой 100 тысяч человек в онлайне.
[51:02.880 --> 51:06.520]  Так типичный кейс вообще, когда система не выдерживает
[51:06.520 --> 51:07.520]  нагрузки.
[51:07.520 --> 51:10.360]  То есть, по идее, нагрузки надо считать и рассчитывать.
[51:10.360 --> 51:15.120]  Особенности, значит, кто тестирует?
[51:15.120 --> 51:19.360]  Если говорится про Agile, то тестирует Product Owner, заказчики
[51:19.360 --> 51:20.360]  и пользователи.
[51:20.360 --> 51:23.080]  Если мы говорим про Scrum, то это хороший вариант.
[51:23.080 --> 51:27.600]  Это вы берете Sprint Demo, либо день релиза, и у вас все
[51:27.600 --> 51:28.600]  падает.
[51:28.600 --> 51:32.520]  Очень хороший тест, вообще, все замечательно.
[51:32.520 --> 51:35.280]  Но, конечно, лучше тестировать нагрузку на альфа и бета
[51:35.280 --> 51:36.280]  тестирования.
[51:36.280 --> 51:39.680]  Вы получаете отчет о производительности, а дальше уже их выкатываете.
[51:40.520 --> 51:44.280]  Так, дальше, по-моему, будет пример приемочного тестирования.
[51:44.280 --> 51:46.000]  Да, чтобы вы понимали.
[51:46.000 --> 51:48.280]  Значит, картинка.
[51:48.280 --> 51:49.680]  Что мы видим на картинке?
[51:53.680 --> 51:57.680]  А, ну, программу, которая ломает некоторые сервера,
[51:57.680 --> 52:01.680]  и ты проверяешь, выйдет ли программа работать, если
[52:01.680 --> 52:02.680]  что-то пойдет не так.
[52:02.680 --> 52:04.680]  Да, если часть серверов будет отключена.
[52:04.680 --> 52:07.680]  Это так называемое хаос-тестирование.
[52:07.680 --> 52:10.680]  Разумеется, мы видим здесь обезьянку, которая берет
[52:10.680 --> 52:12.680]  что-то шалить с проводами и выключает некоторые
[52:12.680 --> 52:13.680]  компьютеры и системы.
[52:13.680 --> 52:17.680]  И дальше вы проверяете, работает ли система или
[52:17.680 --> 52:18.680]  нет.
[52:18.680 --> 52:21.680]  Ну, то есть какие-то вносить неполадки в эту систему.
[52:21.680 --> 52:24.680]  Значит, это методология, которая была разработана
[52:24.680 --> 52:31.680]  в Netflix, и она как раз активно применяется именно в Netflix.
[52:31.680 --> 52:34.680]  Слышали ли вы когда-нибудь, что Netflix падал?
[52:34.680 --> 52:36.680]  Именно надолго и серьезно.
[52:37.680 --> 52:50.680]  Ну, это у вас, а у большого количества пользователей?
[52:50.680 --> 52:58.680]  Да, ну, то есть обычно, кстати, если бы упал и у вас,
[52:58.680 --> 53:01.680]  этих поддержков вам бы ничем не помогло, ну, тогда
[53:01.680 --> 53:04.680]  нет, конечно, если это только незаконодательно каким-то
[53:04.680 --> 53:05.680]  образом было запрещено.
[53:05.680 --> 53:09.680]  Допустим, вам написали, что ваше устройство, увы,
[53:09.680 --> 53:15.680]  мы не будем поддерживать, потому что, я не знаю, 0,1%
[53:15.680 --> 53:18.680]  пользователей, которые операционную систему обладает
[53:18.680 --> 53:20.680]  такой, возможно, что не стоит поддерживать.
[53:20.680 --> 53:24.680]  То есть смотрите, система после намеренного падения
[53:24.680 --> 53:25.680]  вполне спокойно живет.
[53:25.680 --> 53:30.680]  Так, это что касается про уровни тестирования.
[53:30.680 --> 53:33.680]  И теперь давайте немножко попрактикуем и разберем
[53:33.680 --> 53:34.680]  пример.
[53:34.680 --> 53:38.680]  Пример, вам нужно будет назвать уровень тестирования.
[53:38.680 --> 53:42.680]  Тестируем, что класс, принимая в качестве входа три стороны
[53:42.680 --> 53:45.680]  треугольника, является он устроугольным или нет.
[53:48.680 --> 53:51.680]  Какой это уровень тестирования?
[53:53.680 --> 53:56.680]  Ну, да, говорят, что это unit-тестирование.
[53:56.680 --> 53:58.680]  Действительно, это unit-тестирование.
[53:58.680 --> 54:00.680]  Так, второе.
[54:00.680 --> 54:03.680]  Тестируем, что сервис получения курса доллара.
[54:03.680 --> 54:05.680]  Значит, это какая-то подсистема.
[54:05.680 --> 54:08.680]  Отдает там показатели курса доллара,
[54:08.680 --> 54:12.680]  которые вы получите сегодня, или которые вы получите завтра.
[54:12.680 --> 54:15.680]  Да, это интеграционный уровень.
[54:15.680 --> 54:17.680]  Следующий.
[54:17.680 --> 54:19.680]  Блин, черт, пропалился.
[54:19.680 --> 54:22.680]  Тестируем, что программа запускается на Core i5
[54:22.680 --> 54:25.680]  какого-то железа с 512 МБ амперативной памяти.
[54:25.680 --> 54:28.680]  Это уже больше приемочное тестирование, потому что
[54:28.680 --> 54:30.680]  вы под конкретное железо говорите.
[54:30.680 --> 54:35.680]  Вот не зря на компьютерах, на дисках и так далее,
[54:35.680 --> 54:38.680]  на ПО пишут минимальные системные требования,
[54:38.680 --> 54:41.680]  с которых у вас вообще программа запустится.
[54:41.680 --> 54:44.680]  Так, и последнее.
[54:44.680 --> 54:47.680]  Тестируем, что при заходе на страницу МИПТРУ
[54:47.680 --> 54:50.680]  можно кликнуть по ссылке расписания.
[54:53.680 --> 54:56.680]  Смотрите, если бы это был на реальном сайте,
[54:56.680 --> 54:59.680]  под нагрузкой, грубо говоря, 100 тысяч человек,
[54:59.680 --> 55:02.680]  ну, не знаю, вряд ли 100 тысяч человек пойдет
[55:02.680 --> 55:04.680]  нажимать на расписание.
[55:04.680 --> 55:06.680]  Это было приемочное тестирование.
[55:06.680 --> 55:09.680]  А так вы можете локально развернуть сайт МИПТРУ,
[55:09.680 --> 55:11.680]  версию сайта, и так разработчики делают,
[55:11.680 --> 55:14.680]  и они проверяют, что действительно можно зайти
[55:14.680 --> 55:16.680]  на кнопку расписания и получить ее.
[55:16.680 --> 55:18.680]  И получить конкретное расписание.
[55:18.680 --> 55:21.680]  Как раз я предлагаю, вот этот сценарий мы с вами
[55:21.680 --> 55:24.680]  рассмотрим, как можно протестировать автоматически
[55:24.680 --> 55:26.680]  на следующей лекции.
[55:26.680 --> 55:29.680]  Я даже покажу, как это можно делать.
[55:29.680 --> 55:31.680]  Это с тем тестированием.
[55:31.680 --> 55:34.680]  Так, давайте вопросы по уровням тестирования.
[55:37.680 --> 55:40.680]  Конечно, немножко галопом по Европам, но...
[55:47.680 --> 55:50.680]  Хорошо, двигаться дальше можем?
[55:52.680 --> 55:55.680]  Так, давайте поговорим про фреймворк и тестирование,
[55:55.680 --> 55:58.680]  которые существуют. Поскольку у нас курс
[55:58.680 --> 56:02.680]  зачетую заточен именно под C++, Python и Java,
[56:02.680 --> 56:05.680]  то у нас в качестве фреймворка и unit-тестирования
[56:05.680 --> 56:07.680]  мы перечисляем именно эти языки.
[56:07.680 --> 56:10.680]  В C++ известно два...
[56:10.680 --> 56:13.680]  Ранее всего дела два популярных фреймворка
[56:13.680 --> 56:15.680]  и unit-тестирования. Первый это Google Test,
[56:15.680 --> 56:19.680]  с которым вы, кажется, уже начали знакомство свое.
[56:19.680 --> 56:22.680]  Кто-то начнет знакомство, кто-то даже, возможно,
[56:22.680 --> 56:25.680]  начал с ним знакомиться через CMake Advanced задание.
[56:25.680 --> 56:28.680]  Ну и вообще, через CMake, если вы будете делать
[56:28.680 --> 56:31.680]  базовую версию задания, вам нужно будет подключить пару тестов.
[56:31.680 --> 56:35.680]  Это сделано специально, чтобы вы смогли адаптироваться
[56:35.680 --> 56:37.680]  к теме, связанной с тестированием.
[56:37.680 --> 56:43.680]  И, как бы говоря, вот такой вот код у вас не вызывал страха.
[56:43.680 --> 56:47.680]  А это, в принципе, код тестов написан на Google Test.
[56:47.680 --> 56:51.680]  И другая библиотека, если она тоже является популярной,
[56:51.680 --> 56:54.680]  но не настолько популярная, это библиотека Catch2.
[56:54.680 --> 56:56.680]  У нее немножко другая парадигма.
[56:56.680 --> 56:59.680]  В качестве Python мы используем две библиотеки.
[56:59.680 --> 57:03.680]  Одна, встроенная, это unit-тест, вторая, внешняя, это PyTest.
[57:03.680 --> 57:08.680]  Кстати, вы, наверное, могли заметить, что тесты для TDD
[57:08.680 --> 57:12.680]  я написал на PyTest, потому что она поддерживает функциональный стиль.
[57:12.680 --> 57:16.680]  И третий фреймворк, третий, это Java.
[57:16.680 --> 57:19.680]  И в Java как раз используется G-unit.
[57:20.680 --> 57:24.680]  Да, и понимаете, насколько этот формат стал достаточно важным?
[57:24.680 --> 57:27.680]  На том, что все отчеты по тестированию,
[57:27.680 --> 57:30.680]  то есть, если вы хотите запустить результаты тестов,
[57:30.680 --> 57:34.680]  то они называются G-unit.xml формат.
[57:34.680 --> 57:36.680]  Давайте как раз и покажу.
[57:36.680 --> 57:41.680]  То есть, если мы с вами попробуем запустить
[57:41.680 --> 57:47.680]  minus-minus-help, то мы с вами видите G-unit, G-unit, G-unit.
[57:58.680 --> 58:03.680]  И у нас получается отчет о пройденных тестах.
[58:03.680 --> 58:07.680]  Вот он не полностью выводится,
[58:07.680 --> 58:14.680]  но в целом, как мы видим, все test-yout и test-yout у нас тут есть.
[58:16.680 --> 58:20.680]  А, подождите, а что, он теста не нашел?
[58:20.680 --> 58:25.680]  А, мы правильно, потому что не указали модуль, который тестировался.
[58:34.680 --> 58:37.680]  test.py
[58:40.680 --> 58:42.680]  Вот тест-report.
[58:42.680 --> 58:44.680]  Тут его можно привести в красивый вид,
[58:44.680 --> 58:48.680]  и, в принципе, видно, что вот у нас тесты именно такие.
[58:50.680 --> 58:53.680]  То есть, это полезный вывод.
[58:53.680 --> 58:56.680]  Так, то есть, с этими фрейворками можно использовать.
[58:56.680 --> 58:58.680]  И когда будет задание по тестированию,
[58:58.680 --> 59:02.680]  вы сможете написать его на одном из трех языков.
[59:03.680 --> 59:04.680]  Реализовать.
[59:04.680 --> 59:07.680]  Там будет код, нужно будет его протестировать.
[59:07.680 --> 59:11.680]  У нас есть три версии задания для Python, Java и C++.
[59:15.680 --> 59:16.680]  Какой?
[59:18.680 --> 59:19.680]  Goa.
[59:19.680 --> 59:21.680]  Ну ладно, попробуем.
[59:21.680 --> 59:23.680]  Если время будет, постараемся.
[59:25.680 --> 59:27.680]  Просто надо код написать на Goa еще.
[59:27.680 --> 59:31.680]  И подключить все фреймворы, все кавереджи и так далее.
[59:31.680 --> 59:34.680]  Так, значит, еще раз.
[59:34.680 --> 59:36.680]  Это больше напоминание не семинарской части,
[59:36.680 --> 59:39.680]  что, значит, жизненный цикл unit-тестов.
[59:39.680 --> 59:43.680]  Что у нас unit-тест запускается следующим образом.
[59:43.680 --> 59:47.680]  У нас с вами есть test-case или test-suit,
[59:47.680 --> 59:49.680]  и у нас есть некоторые вызовы методов.
[59:49.680 --> 59:51.680]  То есть, у нас есть setup for test-case,
[59:51.680 --> 59:53.680]  который запускается один раз перед всеми тестами
[59:53.680 --> 59:55.680]  в наборе тест-кейсов.
[59:57.680 --> 59:59.680]  Дальше у нас запускается метод setup,
[59:59.680 --> 01:00:02.680]  который работает перед каждым тестом,
[01:00:02.680 --> 01:00:05.680]  и потом по циклу у нас все происходит.
[01:00:05.680 --> 01:00:07.680]  То есть у нас запускается unit-тест,
[01:00:07.680 --> 01:00:09.680]  после этого teardown-test-case,
[01:00:09.680 --> 01:00:11.680]  и мы повторяем эту процедуру.
[01:00:11.680 --> 01:00:13.680]  После того, как у нас все тесты закончились,
[01:00:13.680 --> 01:00:15.680]  мы вызываем этот teardown-test-case.
[01:00:15.680 --> 01:00:17.680]  То есть он запускается после всех тестов.
[01:00:17.680 --> 01:00:21.680]  Опять же, детальнее на семинарах это будет рассматриваться.
[01:00:23.680 --> 01:00:28.680]  И мы переходим еще с вами к одной важной модели.
[01:00:28.680 --> 01:00:31.680]  В методологиях разработки, про которую я показывал,
[01:00:31.680 --> 01:00:34.680]  но здесь надо про нее рассказать чуть подробнее.
[01:00:34.680 --> 01:00:37.680]  Значит, если мы с вами вдохновились
[01:00:37.680 --> 01:00:39.680]  всеми методологиями, которые были,
[01:00:39.680 --> 01:00:43.680]  и обнаружили следующее, что, как ни странно,
[01:00:43.680 --> 01:00:46.680]  пирамида тестирования очень хорошо
[01:00:46.680 --> 01:00:49.680]  можно разложиться на составные части.
[01:00:49.680 --> 01:00:51.680]  То есть на самом деле приемочные тестирования
[01:00:51.680 --> 01:00:53.680]  проверяют бизнес-требования.
[01:00:53.680 --> 01:00:57.680]  Дальше системные тесты проверяют вашу систему целиком.
[01:00:57.680 --> 01:00:59.680]  То есть это называется system-design.
[01:00:59.680 --> 01:01:02.680]  То есть как вашу систему функционирует.
[01:01:02.680 --> 01:01:05.680]  Дальше, если мы спускаемся на более низкий уровень,
[01:01:05.680 --> 01:01:07.680]  то у нас работает интеграционное тестирование.
[01:01:07.680 --> 01:01:10.680]  И как раз мы тестируем с вами взаимодействие между компонентами.
[01:01:10.680 --> 01:01:13.680]  А взаимодействие между компонентами
[01:01:13.680 --> 01:01:15.680]  описывается архитектурой нашего PO.
[01:01:15.680 --> 01:01:17.680]  То есть мы проверяем архитектуру.
[01:01:17.680 --> 01:01:20.680]  И последнее это unit-test и module-design.
[01:01:20.680 --> 01:01:22.680]  То есть дизайн конкретных компонентов.
[01:01:22.680 --> 01:01:24.680]  И смотрите, что у нас получается.
[01:01:24.680 --> 01:01:27.680]  У нас в правой части возникает стадия валидации.
[01:01:27.680 --> 01:01:31.680]  Да, смотрите, здесь, как ни странно,
[01:01:31.680 --> 01:01:34.680]  очень хорошо помогает нам английский язык,
[01:01:34.680 --> 01:01:36.680]  потому что он показывает разницу.
[01:01:36.680 --> 01:01:42.680]  В стадии валидации проверяют, что мы сделали right-product.
[01:01:42.680 --> 01:01:46.680]  То есть это продукт, который сделан вроде по спецификации.
[01:01:46.680 --> 01:01:48.680]  И вроде как работает.
[01:01:48.680 --> 01:01:52.680]  Но если мы поменяем слово product-right и right-product,
[01:01:52.680 --> 01:01:57.680]  то внезапно у нас все поменяется.
[01:01:57.680 --> 01:02:01.680]  Потому что мы специфицируем,
[01:02:01.680 --> 01:02:04.680]  что мы строим наш продукт правильно.
[01:02:04.680 --> 01:02:09.680]  То есть именно с учетом тех рекомендаций, которые у нас есть.
[01:02:09.680 --> 01:02:13.680]  Вот это очень важно.
[01:02:13.680 --> 01:02:17.680]  То есть, грубо говоря, автоматические тесты могут проверить одно,
[01:02:17.680 --> 01:02:20.680]  а человек дополнительно может проверить и другое.
[01:02:20.680 --> 01:02:25.680]  То есть сразу скажу, что стадии верификации происходят зачастую в выручном режиме.
[01:02:25.680 --> 01:02:32.680]  То есть автоматика возможна только при стадии верификации нашего процесса.
[01:02:32.680 --> 01:02:35.680]  Опять же, не путать, пожалуйста, эти термины.
[01:02:35.680 --> 01:02:38.680]  Они очень похожи, но они...
[01:02:38.680 --> 01:02:40.680]  они всю про проверку.
[01:02:40.680 --> 01:02:45.680]  Но именно верификация зачастую важнее именно валидации.
[01:02:45.680 --> 01:02:49.680]  Так, теперь поговорим про виды тестирования.
[01:02:49.680 --> 01:02:52.680]  У нас бывают несколько видов тестирования.
[01:02:52.680 --> 01:02:54.680]  Первый – это статическое тестирование,
[01:02:54.680 --> 01:02:56.680]  второй – это динамическое тестирование.
[01:02:56.680 --> 01:03:02.680]  Статическое тестирование – это то тестирование, которое не запускает наш код.
[01:03:02.680 --> 01:03:05.680]  А динамическое тестирование, которое запускает наш код.
[01:03:05.680 --> 01:03:09.680]  И в статическом тестировании обычно выделяют 2 подаспекта.
[01:03:09.680 --> 01:03:12.680]  Первый инструмент – это код review.
[01:03:12.680 --> 01:03:17.680]  Но не только review – мы можем review-ить код, дизайн, веб-страницу.
[01:03:17.680 --> 01:03:22.160]  можем посмотреть на диаграмму и понять, допустим, что у нас с вами границы в
[01:03:22.160 --> 01:03:27.680]  системе выстроены неверно. И статический анализатор кода. Он же называется линтер.
[01:03:27.680 --> 01:03:31.360]  То есть мы как раз с вами запустили два статических анализатора кода, которые
[01:03:31.360 --> 01:03:36.960]  проверили, что наш код оформлен согласно требованиям. Как вы думаете, почему важно
[01:03:36.960 --> 01:03:40.440]  оформлять код согласно требованиям?
[01:03:40.440 --> 01:03:53.680]  Что-что? Ну да, в том числе. То есть мы как бы поддерживаем наш код на хорошем
[01:03:53.680 --> 01:04:01.000]  уровне, чтобы другие коллеги могли его тоже выполнять. Так, хорошо. Это что касается
[01:04:01.000 --> 01:04:04.840]  статического тестирования. Дальше будем говорить не только про статическое
[01:04:04.840 --> 01:04:09.400]  тестирование, но будем говорить про другие вещи. Так, начинаем интересный
[01:04:09.400 --> 01:04:13.960]  момент, в котором мы будем говорить следующее. Мы разделим наши виды
[01:04:13.960 --> 01:04:20.080]  тестирования и сейчас мы будем говорить про виды тестирования по методам и по
[01:04:20.080 --> 01:04:26.640]  доступности. То есть по методам тестирования, если мы говорим про
[01:04:26.640 --> 01:04:33.800]  стандарта СТКБ. Но про доступность, как раз это типа доступен код или нет.
[01:04:33.800 --> 01:04:39.800]  Здесь выделяет три метода. Это whitebox-тестинг, тестирование белого ящика, когда у нас
[01:04:39.800 --> 01:04:43.640]  программа вся видна. Greybox-тестинг, то есть когда у нас в отчестве видна
[01:04:43.640 --> 01:04:47.960]  программа. И blackbox-тестинг, это тестирование черного ящика. И для каждого из них
[01:04:47.960 --> 01:04:56.200]  разные методики. Значит whitebox-тестинг. Белая коробка, все видно. Я бы сказал,
[01:04:56.200 --> 01:05:01.280]  лучше назвать не whitebox, а transparentbox. То есть мы видим, как у нас взаимодействуют
[01:05:01.280 --> 01:05:09.080]  модули между собой и можем смотреть весь код. И как мы видим, статик тестирования
[01:05:09.080 --> 01:05:14.480]  обычно относится к whitebox-тестингу, потому что у нас как раз наш код виден. И здесь
[01:05:14.480 --> 01:05:19.200]  выделяет три основных аспекта, которые мы можем проверять. Первое это execution
[01:05:19.200 --> 01:05:24.880]  testing, то есть мы проверяем после запуска. Второе это mutation testing, это
[01:05:24.880 --> 01:05:32.240]  тестирование мутантами. Мутантами или мутационное тестирование его называют.
[01:05:32.240 --> 01:05:37.240]  То есть цель будет такая, что мы будем наш код изменять автоматическом режиме
[01:05:37.240 --> 01:05:41.880]  таким образом, чтобы проверять те тесты, которые мы написали, выпускают,
[01:05:41.880 --> 01:05:48.040]  пропускают какие-то дефекты или не пропускают. То есть насколько у нас хорошая
[01:05:48.040 --> 01:05:55.080]  база для тестирования задана. Так, значит теперь основным инструментом execution
[01:05:55.080 --> 01:06:01.480]  testing, тестирования именно выполнения, является код coverage. Значит покрытие кода тестами.
[01:06:01.480 --> 01:06:06.840]  И здесь выделяет, вы не поверите, четыре вида тестирования, четыре вида coverage.
[01:06:06.840 --> 01:06:11.880]  Первый это statement coverage, второй это branch coverage, третий это decision coverage по
[01:06:11.880 --> 01:06:17.440]  решениям и четвертый это pass coverage. Значит сразу скажу, что здесь на этой
[01:06:17.440 --> 01:06:21.880]  штуке будет нарисовано частичного порядочное множество. Да, то есть они,
[01:06:21.880 --> 01:06:25.320]  некоторые из них между собой связаны, некоторые из них не связаны. То есть
[01:06:25.320 --> 01:06:29.040]  какой это является более строгим, какой это является менее строгим. Поехали.
[01:06:29.040 --> 01:06:35.240]  Значит первое statement coverage, он замеряет следующую метрику. Количество
[01:06:35.240 --> 01:06:43.520]  statement, которое у вас есть, количество statement, которые у вас прошли тесты. То
[01:06:43.520 --> 01:06:49.240]  есть что вы делаете? Вы запускаете код ваш тестов, каждую строчку помечаете,
[01:06:49.240 --> 01:06:55.520]  пройдена она была или нет. Важно всеми тестами. То есть хотя бы одним тестом эта
[01:06:55.520 --> 01:07:00.280]  строчка была пройдена или нет. После этого вы замеряете процент statement.
[01:07:00.280 --> 01:07:04.360]  Да, к сожалению, здесь некорректные результаты именно по statement, но в целом
[01:07:04.360 --> 01:07:11.440]  смотрите, давайте оценим. Вот мы зашли в функцию. Раз, два, это result a plus b.
[01:07:11.440 --> 01:07:17.680]  Третье if result больше нуля. Это statement. Четвертый результат, это у нас
[01:07:17.680 --> 01:07:22.360]  print. Пятым иногда можно в принципе оценивать его, можно не оценивать его.
[01:07:22.360 --> 01:07:26.960]  Здесь как раз у нас так сказать line coverage. То есть какие строки кода мы прошли.
[01:07:26.960 --> 01:07:32.680]  Если мы говорим про statement, то мы покроем раз, два, три. Три строки из пяти. То есть
[01:07:32.680 --> 01:07:38.320]  это вторая, третья и четвертая строка. Всего у нас строк statement будет шесть. Ой,
[01:07:38.320 --> 01:07:49.440]  пять. Поэтому в этом примере coverage будет три пятых. 60 процентов. То есть какие три у нас?
[01:07:49.440 --> 01:07:58.360]  Это два, три, четыре. Всего у нас получается два, три, четыре, пять, шесть. То есть statement
[01:07:58.360 --> 01:08:05.200]  coverage считать обычно проще всего. То есть у вас инструмент должен позволять
[01:08:05.200 --> 01:08:13.760]  уметь считать сколько веток вы прошли. Точнее не столько веток, сколько statement вы прошли.
[01:08:13.760 --> 01:08:21.120]  Кстати, важный момент. В зависимости от языка программирования statement coverage может отличаться.
[01:08:21.120 --> 01:08:33.080]  Так, вот это понятно? Вот этот coverage. Как обеспечить coverage 100 процентов?
[01:08:33.080 --> 01:08:51.360]  Какие тесты надо запустить? Ну да, ну тут обычно когда говорят какие тесты,
[01:08:51.360 --> 01:08:58.560]  это значит конкретные тесты. Да, значит нам нужно запустить тест минус один, минус один и допустим
[01:08:58.560 --> 01:09:06.480]  тест два ноль. Ну вот мы получаем statement coverage 100 процентов. Ну что мы начнем проходить и по
[01:09:06.480 --> 01:09:16.520]  пятой, и по шестой строке тоже. Так, это понятно? Вот вам один из номеров твой контрольный, кстати.
[01:09:16.520 --> 01:09:23.560]  Вам будет код дан, вам будут даны тесты, вам нужно будет посчитать statement coverage.
[01:09:23.560 --> 01:09:36.440]  Так, вторая branch coverage. Каждая ветвь исполнения пройдена один раз. То есть мы в нашем коде выделяем
[01:09:36.440 --> 01:09:44.120]  количество ветвей исполнения и считаем сколько ветвей исполнения мы с вами прошли. Тут важно
[01:09:44.120 --> 01:09:51.240]  именно рисовать четкую схему алгоритма действий. Значит и считать именно количество ветвей,
[01:09:51.240 --> 01:09:57.680]  которые у нас есть. Здесь количество ветвей равняется, не поверите, восьми в этом участке кода.
[01:09:57.680 --> 01:10:06.640]  Смотрите, первая ветка это как раз от входа функции до if. Дальше у нас идет разветвление if на да и нет.
[01:10:06.640 --> 01:10:13.400]  И обращу внимание, что вот обычно забывают следующее. Не количество ветвлений, а количество веток,
[01:10:13.400 --> 01:10:17.120]  то есть количество путей. То есть у нас есть стрелочка связанная с двойкой, с четверкой,
[01:10:17.120 --> 01:10:22.800]  с пятеркой, с шестеркой, с семеркой, с восьмеркой. То есть у нас все условия считаются. На самом деле
[01:10:22.800 --> 01:10:29.600]  после if, если у нас идет return, тут вообще идет девятая инструкция, которая есть. Давайте попробуем
[01:10:29.600 --> 01:10:50.800]  посчитать branch coverage для такой штуки. Кстати, если мы подадим тест 50-50. То есть мы даем x
[01:10:50.800 --> 01:11:01.240]  равной 50 и x равной 50. Сколько веток мы с вами проходим? Давайте считать. Какие ветки мы проходим?
[01:11:01.240 --> 01:11:27.920]  5, 6 или 7? 7. У нас сумма ровная 100. 7 и 9. Вот тут вот девятое. Ой, извините.
[01:11:27.920 --> 01:11:35.680]  Тут типа ее не хватает. Ее неплохо было бы дорисовать. То есть тут вот у нас как раз есть
[01:11:35.680 --> 01:11:46.000]  девятая ветка. Вот. То есть смотрите, мы прошли 5 веток. Всего 9 веток. То есть branch coverage у
[01:11:46.000 --> 01:12:00.120]  нас 5 девятых. Это приблизительно 55,6 процентов. Смотрите, если мы к этому тесту даваем дополнительно
[01:12:00.120 --> 01:12:14.440]  тест 51,50, то что у нас произойдет? Какие дополнительные ветки мы с вами покроем?
[01:12:14.440 --> 01:12:31.240]  Да. 24 только. И в итоге общий coverage. Посмотрите, мы меряем coverage не по каждому тесту, а общий.
[01:12:31.240 --> 01:12:45.760]  Он уже будет 7 девятых. Это 7,7-8 процентов. Ну и как добить слой coverage в 100 процентов?
[01:12:45.760 --> 01:13:12.080]  Получаем 100 процентов. Давайте скажем так. Скажите, пожалуйста, какое количество кода нам нужно
[01:13:12.080 --> 01:13:22.760]  будет добиться для того, чтобы получить statement coverage 100 процентов? Какое количество тестовых сценариев?
[01:13:22.760 --> 01:13:40.480]  Нет, не три. Statement coverage, не branch coverage. Предыдущий. Что мы по всем statement'ам пройдем?
[01:13:40.480 --> 01:13:56.560]  Или три? С одной стороны, да. Но утверждается, что мы можем пройти по всем statement, но не по всем развилкам.
[01:13:56.560 --> 01:14:09.960]  Смотрите, что такое statement coverage? Нам нужно в каждый оператор попасть. Смотрите, в statement
[01:14:09.960 --> 01:14:17.120]  coverage нам будет достаточно два теста пройти, чтобы получить statement coverage 100 процентов. Это нам
[01:14:17.120 --> 01:14:23.920]  нужно будет взять вот этот тест и вот этот тест. Но при этом, чтобы получить branch coverage 100
[01:14:23.920 --> 01:14:35.520]  процентов, кстати, какие нам тесты? Нам, кажется, те же самые два теста понадобятся, да? Да-да-да. Нам
[01:14:35.520 --> 01:14:39.360]  те же самые два теста понадобятся, главное, нам надо будет пройти по всем веткам. Но утверждение,
[01:14:39.360 --> 01:14:46.240]  что ивристически можно сказать, что branch coverage это более строгая вещь, чем statement coverage.
[01:14:46.240 --> 01:14:57.000]  Так, следующий coverage. Decision coverage. Количество пройденных логических операторов. Логических
[01:14:57.000 --> 01:15:02.840]  операторов это имеется в виду те, которые стоят внутри ИФА, внутри ИЛСА и так далее. Да,
[01:15:03.680 --> 01:15:11.960]  внутри ФОРОВ. Итак, интересный кейс, который показывает, чем decision coverage отличается от
[01:15:11.960 --> 01:15:37.400]  branch coverage. В чем особенность? В чем отличие этих двух функций? Да, побитывая И. Да,
[01:15:37.720 --> 01:15:42.680]  смотрите, чтобы обеспечить decision coverage 100 процентов, нам нужно будет проверить,
[01:15:42.680 --> 01:15:48.960]  что каждый из внутренних скобок в каждом операнте выполняется хотя бы один раз. То есть нам
[01:15:48.960 --> 01:15:56.600]  нужно будет привести примеры, что A меньше 5, A больше 15 и так далее. А вот у нас получается,
[01:15:56.600 --> 01:16:12.360]  чтобы достигнуть decision coverage в 100 процентов, нам нужна пара A меньше 5, B больше 15. Кажется,
[01:16:12.360 --> 01:16:27.000]  такая. Для того, чтобы получить decision coverage и там, и там 100 процентов. Decision,
[01:16:27.000 --> 01:16:41.040]  то есть что мы каждый логический оперант пройдем как минимум один раз. Нет, я имеется в виду,
[01:16:41.040 --> 01:17:01.680]  хочется сказать сейчас. Хорошо, но по крайней мере точно можно сказать, что код с точки зрения
[01:17:01.680 --> 01:17:12.000]  обветвления coverage будет сильно разным. То есть справа, грубо говоря, branch coverage можно получить
[01:17:12.000 --> 01:17:22.520]  достаточно легко, закинув один тест. Здесь же нам одного теста не хватит. Ну да, нам нужен тест,
[01:17:22.520 --> 01:17:27.840]  где A больше 5, а второй тест, который нам нужен на самом деле, нам нужен еще один тест, в котором A
[01:17:27.840 --> 01:17:42.240]  меньше 5. Ну потому что нам нужно разматывать эту логику. Нет, для decision, сейчас давайте подумаем,
[01:17:42.240 --> 01:17:54.240]  сколько нам. А для decision 2 тоже нужно. Ну смотрите, нам нужно, чтобы у нас все операнты были хотя бы
[01:17:54.240 --> 01:18:05.160]  один раз true выполнены. То есть получается у нас первый тест, допустим, A больше 5, B получается
[01:18:05.160 --> 01:18:20.480]  меньше 15, A меньше 5, B больше 15. Вот два теста. Тут иногда бывает разная трактовка. В некоторых
[01:18:20.520 --> 01:18:27.040]  трактовках говорят следующее, что давайте мы с вами попробуем именно тестировать в outcome,
[01:18:27.040 --> 01:18:32.360]  то есть что каждое решение было принято как минимум один раз. То есть решение там связанное
[01:18:32.360 --> 01:18:38.600]  с true и с false. Иногда нам нужно именно все логические операторы проверять. А в branch coverage
[01:18:38.600 --> 01:18:45.520]  тоже на самом деле те же самые тесты будут проходить. На самом деле здесь нужно будет больше тестов.
[01:18:45.520 --> 01:19:07.040]  Вот. И A меньше 5. Вот. То есть в decision coverage нам хватит двух тестов. В обоих случаях. В двух
[01:19:07.040 --> 01:19:13.960]  случаях. А вот в этом случае для branch coverage нужно будет три теста. Нам нужно будет пройти по всем
[01:19:13.960 --> 01:19:21.600]  веткам. И последний есть coverage, который обычно никто не измеряет, потому что избыточное тестирование
[01:19:21.600 --> 01:19:37.360]  невозможно. Это path coverage. Количество пройденных путей. От начала до конца процент. Опять же видно,
[01:19:37.360 --> 01:19:41.760]  что процент пройденных путей может быть очень большой. Очень маленький. То есть все пути вы
[01:19:41.760 --> 01:19:49.680]  точно не пройдете. А еще непонятно, что делать с циклами. То есть там нужно считать, типа,
[01:19:49.680 --> 01:19:57.080]  прошли вы ноль раз, один раз или больше одного раза. Вот. Какая строгая сложение, как вы думаете?
[01:19:57.080 --> 01:20:09.120]  Какой самый строгий coverage? Path coverage. Path, да. Path coverage самое строгое. Остальные могут быть
[01:20:09.120 --> 01:20:14.680]  между собой не взаимосвязаны. То есть существуют такие примеры, когда один вид coverage перекрывает
[01:20:14.680 --> 01:20:21.920]  другой вид coverage и наоборот. Так, сто процентов path coverage. Как вы думаете, стоит ли добиваться
[01:20:21.920 --> 01:20:28.800]  сто процентов path coverage? Конечно нет, потому что избыточное тестировать невозможно. Отлично.
[01:20:28.800 --> 01:20:36.000]  Вот. И давайте последний момент, который разберем. Сегодня я сделаю затравку. В следующий раз мы с
[01:20:36.000 --> 01:20:45.440]  вами... Ой, блин. Кажется, тут все плохо. Ладно, надо будет его переводить на какую-нибудь другую тему. Да,
[01:20:45.440 --> 01:20:50.480]  мутант. Смотрите, давайте я скажу следующее. У вас слева есть функция add, которая возвращает
[01:20:50.480 --> 01:20:58.880]  a плюс b. Сверху функция, которую вы делаете следующее. Вы пишете просто a плюс b и потом возвращаете
[01:20:58.880 --> 01:21:05.920]  null. То есть вы забываете ключевое слово return. Ну просто дайте return, зачеркиваете в вашем коде.
[01:21:05.920 --> 01:21:14.480]  Во второй части вы передаете... Господи, что там? Вы меняете public на protected, а в третьем
[01:21:14.480 --> 01:21:20.880]  кейсе вы плюс на минус меняете. То есть вы реально это можете автоматически запрограммировать. То
[01:21:20.880 --> 01:21:27.280]  есть каким образом вы меняете операнды. И дальше вы проверяете ваши тесты. Значит, если внезапно
[01:21:27.280 --> 01:21:37.240]  ваш framework, ну или ваши тесты пропускают один из этих вариантов, то у вас появляется мутант.
[01:21:37.240 --> 01:21:44.720]  Да, и это как раз говорится, какой процент мутирующих вариантов у вас не проит. То есть
[01:21:44.720 --> 01:21:53.960]  mutation coverage это как раз процент тестов, который был, точнее процент мутантов, который не был
[01:21:53.960 --> 01:22:06.200]  определен, не отломлен ни одним тестом. Не отловлен ни одним тестом. В чем заключаются цели
[01:22:06.200 --> 01:22:11.440]  мутационного тестирования? Цель заключается в том, что слабо протестированные участки у нас есть,
[01:22:11.440 --> 01:22:20.000]  и при этом у нас остаются мутанты. После этого мы можем слабые тесты обнаружить, потому что,
[01:22:20.000 --> 01:22:25.640]  если у нас есть слабые тесты, то есть у нас каркас маленький, и мы грубо говоря тестировали наш код,
[01:22:25.640 --> 01:22:32.600]  грубо говоря, нашу систему на скорости ветра 1 метр в секунду, 2 метра в секунду, 4 метра в секунду.
[01:22:32.600 --> 01:22:39.280]  Не протестировали на 8 метров в секунду. Берем 4 на 8 и меняем, у нас вылетает все в их хлонину.
[01:22:39.280 --> 01:22:45.560]  И дополнительно мы можем проверить, какие ошибки могут внести в программу. То есть потенциально
[01:22:45.560 --> 01:22:55.400]  какая именно проблема с логикой нашего процесса может существовать. Это что касается тестирования
[01:22:55.400 --> 01:23:02.280]  белого ящика. В следующий раз мы поговорим про методики тестирования и добьем тему,
[01:23:02.280 --> 01:23:07.560]  связанную с тестированием, и, собственно, после этого напишем контрольную. Ну, имеется в виду
[01:23:07.560 --> 01:23:11.720]  через раз, не в следующий раз контрольную. Если есть вопросы, задавайте.
