[00:00.000 --> 00:12.000]  Я предстоит обсудить следующие два контейнера, а если успеем, то и три.
[00:12.000 --> 00:17.000]  Мы сейчас начнем обсуждать, как устроен лист, потом мы пообсуждаем, как устроен STD map,
[00:17.000 --> 00:21.000]  а если повезет и мы успеем, то еще и обсудим, как устроен STD unordered map.
[00:21.000 --> 00:24.000]  А на второй паре Федя вам дальше порассказывает про итераторы.
[00:25.000 --> 00:30.000]  Значит 8.8.5.
[00:30.000 --> 00:42.000]  Поясняю, у вас параграф 8.3 это был вид итераторов и advanced distance категории итераторов.
[00:42.000 --> 00:44.000]  Вот, примеры использования итераторов.
[00:44.000 --> 00:50.000]  Параграф 8.4 это был пример реализации итераторов для класса Vector.
[00:50.000 --> 00:53.000]  Константный и неконстантный итератор, реверс итераторы.
[00:53.000 --> 01:00.000]  Вот, поэтому параграф 8.5 это STD list и STD forward list.
[01:00.000 --> 01:02.000]  В этом же пункте обсудим.
[01:02.000 --> 01:05.000]  Лист будет вашей следующей задачей, кстати.
[01:05.000 --> 01:11.000]  Но там основная сложность будет не в самом листе, а кое в чем другом, но пока...
[01:11.000 --> 01:14.000]  Ну exception set это тоже проблема будет.
[01:14.000 --> 01:17.000]  Там еще будут аллокаторы, но это мы потом обсудим.
[01:19.000 --> 01:22.000]  Пока что мы просто обсуждаем, как устроен лист.
[01:22.000 --> 01:26.000]  Ну, лист это связанный список, как вы знаете, двусвязанный.
[01:26.000 --> 01:29.000]  Это значит, что в нем что поддерживается?
[01:29.000 --> 01:33.000]  В нем поддерживается push-back.
[01:36.000 --> 01:40.000]  Ну, push, pop, back, front.
[01:40.000 --> 01:46.000]  Вот и push и pop, и в начало и в конец есть и работает оно за вот единицы.
[01:46.000 --> 01:49.000]  А еще есть insert в середину по итератору.
[01:49.000 --> 01:52.000]  И race из середины по итератору.
[01:53.000 --> 01:55.000]  Вот, что такое insert?
[01:55.000 --> 01:57.000]  То есть вы передаете итератор.
[01:57.000 --> 02:03.000]  Вот, именно по этой причине нужно было итераторы изучить до обсуждения листа.
[02:03.000 --> 02:08.000]  Потому что уже рассказывать, как устроен лист, без понимания, что итераторы нельзя.
[02:08.000 --> 02:13.000]  Вот, ну теперь вы уже знаете, что итераторы, поэтому мы можем полноценно обсудить, как устроен лист.
[02:13.000 --> 02:16.000]  Ну, потому что в связанном списке нет никакой индексации.
[02:16.000 --> 02:20.000]  Нельзя по индексу обращаться к элементам связанного списка.
[02:20.000 --> 02:23.000]  Если бы и можно было, то это бы работало за линейное время.
[02:23.000 --> 02:29.000]  Ну, потому что понятно почему, это же связанный список, там хранятся вершины указателями провязанные.
[02:29.000 --> 02:35.000]  Поэтому обращаться к элементам списка, если как-то и можно, то обычно по итератору.
[02:35.000 --> 02:43.000]  Вот, и как правило, если у вас и есть какая-то работа со связанным листом, то вы имеете дело с итераторами.
[02:43.000 --> 02:48.000]  Так вот, insert вы делаете по итератору, вот.
[02:48.000 --> 02:52.000]  И вставляете, значит, туда какой-то элемент.
[02:52.000 --> 02:55.000]  И race вы можете делать по итератору.
[02:55.000 --> 02:58.000]  Вот, ну еще вы можете вставлять диапазон.
[02:58.000 --> 03:03.000]  То есть вы можете сделать insert по итератору и еще пару итераторов передать.
[03:03.000 --> 03:07.000]  Тогда он просто скопируя, вставит все элементы данного диапазона.
[03:07.000 --> 03:08.000]  Да.
[03:08.000 --> 03:09.000]  У меня сбилась номерация.
[03:09.000 --> 03:12.000]  Итераторы, какая была итераторская?
[03:12.000 --> 03:13.000]  8.3, да.
[03:13.000 --> 03:16.000]  Дальше 8.4, это была реализация итераторов.
[03:16.000 --> 03:19.000]  Например, vector, а также constant и reverse итераторы.
[03:19.000 --> 03:22.000]  Вот, 8.5, test the list.
[03:22.000 --> 03:25.000]  Да, в этом году у нас будет такая сквозная номерация.
[03:25.000 --> 03:32.000]  То, что вам рассказывает Федя, будет, значит, вписываться в общий список того, что вам рассказываю я.
[03:32.000 --> 03:35.000]  И race тоже можно делать по диапазону.
[03:35.000 --> 03:37.000]  То есть можно делать и race, и пару итераторов передать.
[03:37.000 --> 03:39.000]  Тогда он долит все из этого диапазона.
[03:39.000 --> 03:41.000]  Разумеется, это работа за линейное время и длины диапазона.
[03:41.000 --> 03:42.000]  Вот.
[03:42.000 --> 03:45.000]  Ну, все вот это работает, загарантированное от единицы.
[03:45.000 --> 03:48.000]  Потому что это связанный список.
[03:48.000 --> 03:50.000]  Вот.
[03:50.000 --> 03:52.000]  Как это реализовано?
[03:52.000 --> 03:56.000]  Ну, в принципе, с точки зрения алгоритмов-то понятно как, я думаю.
[03:56.000 --> 04:00.000]  Тут нечего особо обсуждать, что как связанный список реализовался с алгоритмической точки зрения.
[04:00.000 --> 04:05.000]  Как это реализовать с точки зрения красивого кода, скорее, стоит обсудить.
[04:05.000 --> 04:10.000]  У нас в листе, какие есть...
[04:10.000 --> 04:14.000]  Ну, вот давайте представим, что я так реализую класс-лист.
[04:14.000 --> 04:17.000]  Вот у меня есть темплейт.
[04:17.000 --> 04:20.000]  TypeName.t
[04:21.000 --> 04:24.000]  Class-List.
[04:24.000 --> 04:27.000]  Что в нем примерно находится внутри?
[04:27.000 --> 04:29.000]  Так упрощенно.
[04:29.000 --> 04:33.000]  Ну, будем считать, что private-часть пока мы пишем.
[04:33.000 --> 04:34.000]  Вот.
[04:34.000 --> 04:39.000]  В листе должны быть какие-то ноды.
[04:39.000 --> 04:45.000]  Да, ну, элементы связанного списка, которые хранят указатель на предыдущий элемент и на следующий элемент.
[04:45.000 --> 04:50.000]  То есть, на самом деле, в листе должен быть еще внутренний класс.
[04:50.000 --> 04:54.000]  StructNode.
[04:54.000 --> 04:57.000]  Кстати, к вопросу о...
[04:57.000 --> 05:04.000]  Вопрос, который в чате задавал господин Барыкин про приватность полей у приватных классов.
[05:04.000 --> 05:07.000]  Вот у меня в листе есть приватная структура Node.
[05:07.000 --> 05:09.000]  И у нее публичные поля.
[05:09.000 --> 05:17.000]  Вот, а когда я по итератору обращаюсь к листу, я таким образом получаю доступ к публичному полю структуры, хотя структура-то приватная.
[05:17.000 --> 05:22.000]  Ну, вот тебе еще один пример, почему это так не должно работать, как ты хотел бы.
[05:22.000 --> 05:24.000]  Ну...
[05:24.000 --> 05:27.000]  Нет, сама структура-то публичная, поэтому в чем проблема?
[05:27.000 --> 05:29.000]  Нет, структура приватная.
[05:29.000 --> 05:31.000]  Ну, мы же в мире...
[05:31.000 --> 05:33.000]  Мы получили объект этой структуры.
[05:33.000 --> 05:34.000]  Да, да, да.
[05:34.000 --> 05:43.000]  Но вопрос был... Да, конечно, вопрос был в том, почему, имея, значит, доступ к публичным полям приватной структуры, мы, тем не менее, не получаем ошибку доступа.
[05:43.000 --> 05:45.000]  Так вот, структура Node, что в ней лежит?
[05:45.000 --> 05:49.000]  В ней лежит, собственно, t-value.
[05:49.000 --> 05:51.000]  Вот это вот значение листа.
[05:51.000 --> 05:53.000]  А еще два указателя.
[05:53.000 --> 05:55.000]  Node звездочка prev и node звездочка next.
[05:55.000 --> 05:57.000]  Ну...
[05:57.000 --> 05:59.000]  Скорее...
[05:59.000 --> 06:01.000]  Вряд ли там Node что-то другое.
[06:03.000 --> 06:05.000]  Ну...
[06:05.000 --> 06:07.000]  Там...
[06:07.000 --> 06:09.000]  Скажем так, вряд ли, вот...
[06:09.000 --> 06:11.000]  Прям так, как я напишу, на самом деле.
[06:11.000 --> 06:13.000]  В STL, конечно, все гораздо сложнее.
[06:15.000 --> 06:17.000]  Нет, я хочу именно указатели хранить.
[06:17.000 --> 06:19.000]  Вот.
[06:19.000 --> 06:21.000]  А...
[06:21.000 --> 06:23.000]  И...
[06:23.000 --> 06:25.000]  Кстати говоря...
[06:25.000 --> 06:27.000]  Мм...
[06:27.000 --> 06:29.000]  Сейчас...
[06:29.000 --> 06:31.000]  Через некоторое время станет понятно, что вот это
[06:31.000 --> 06:33.000]  не совсем хорошо
[06:33.000 --> 06:35.000]  так делать, как я сделал.
[06:39.000 --> 06:41.000]  Причем самый лучший?
[06:41.000 --> 06:43.000]  Причем самый лучший.
[06:43.000 --> 06:45.000]  Ну...
[06:45.000 --> 06:47.000]  А...
[06:47.000 --> 06:49.000]  Я не знаю.
[06:49.000 --> 06:51.000]  Я не знаю.
[06:51.000 --> 06:53.000]  Возможно, там точно не это.
[06:53.000 --> 06:55.000]  Вот 100% там не так.
[06:55.000 --> 06:57.000]  Там все гораздо сложнее и хуже.
[06:57.000 --> 06:59.000]  Там куча оптимизаций.
[06:59.000 --> 07:01.000]  Наверняка там еще какой-нибудь
[07:01.000 --> 07:03.000]  стоит шаблонный
[07:03.000 --> 07:05.000]  мета-проверяльщик.
[07:05.000 --> 07:07.000]  Если здесь там какой-нибудь тип маленький,
[07:07.000 --> 07:09.000]  то это можно как-нибудь получше упаковать.
[07:09.000 --> 07:11.000]  Там поля переупорядочить.
[07:11.000 --> 07:13.000]  Там все, конечно же, гораздо сложнее написано.
[07:13.000 --> 07:15.000]  Вот.
[07:15.000 --> 07:17.000]  Но мы не будем париться о таком.
[07:17.000 --> 07:19.000]  Пока на простом уровне считаем.
[07:19.000 --> 07:21.000]  На уровне средней школы, да.
[07:21.000 --> 07:23.000]  Совершенно верно.
[07:23.000 --> 07:25.000]  Так вот.
[07:25.000 --> 07:27.000]  Хорошо.
[07:27.000 --> 07:29.000]  Есть такая структура.
[07:29.000 --> 07:31.000]  У меня вопрос.
[07:31.000 --> 07:33.000]  Что
[07:33.000 --> 07:35.000]  хранится в полях листа?
[07:35.000 --> 07:37.000]  Ну, указатель на начало и конец?
[07:37.000 --> 07:39.000]  Вот.
[07:39.000 --> 07:41.000]  Указатель на начало и конец.
[07:41.000 --> 07:43.000]  А если лист
[07:43.000 --> 07:45.000]  пустой, то что там должно быть?
[07:45.000 --> 07:47.000]  Вот. Я вам могу сразу сказать
[07:47.000 --> 07:49.000]  самую распространенную ошибку.
[07:49.000 --> 07:51.000]  Ну, одну из самых распространенных ошибок в реализации листа.
[07:51.000 --> 07:53.000]  Половина из вас ее точно сделает,
[07:53.000 --> 07:55.000]  несмотря на то, что я это сказал.
[07:55.000 --> 07:57.000]  Значит, если лист
[07:59.000 --> 08:01.000]  пустой,
[08:01.000 --> 08:03.000]  то он не должен аллоцировать никакую память.
[08:03.000 --> 08:05.000]  И никакие объекты value, конечно же,
[08:05.000 --> 08:07.000]  он не должен создавать.
[08:07.000 --> 08:09.000]  Тем не менее, это все равно каждый год кто-нибудь так сделает.
[08:09.000 --> 08:11.000]  Если лист пустой,
[08:11.000 --> 08:13.000]  то никаких ноут создано быть не должно.
[08:13.000 --> 08:15.000]  Конечно же.
[08:15.000 --> 08:17.000]  Потому что вообще у Тэни обязан быть конструктор
[08:17.000 --> 08:19.000]  по умолчанию.
[08:19.000 --> 08:21.000]  Что же делать?
[08:21.000 --> 08:23.000]  Ну, надо, можно хранить
[08:23.000 --> 08:25.000]  NullPTR. Хорошо, давайте будем
[08:25.000 --> 08:27.000]  хранить NullPTR. То есть
[08:27.000 --> 08:29.000]  ну, мы как бы
[08:29.000 --> 08:31.000]  ну,
[08:31.000 --> 08:33.000]  будем, пока считаешь это
[08:33.000 --> 08:35.000]  указатели, будет у меня
[08:35.000 --> 08:37.000]  такое поле бег.
[08:37.000 --> 08:39.000]  Ну,
[08:39.000 --> 08:41.000]  бегин я не могу его называть, потому что
[08:43.000 --> 08:45.000]  это название метода, будет коллизия
[08:45.000 --> 08:47.000]  с ним.
[08:47.000 --> 08:49.000]  Я буду вот так делать.
[08:49.000 --> 08:51.000]  Ну, так покороче
[08:51.000 --> 08:53.000]  просто.
[08:53.000 --> 08:55.000]  На доске
[08:55.000 --> 08:57.000]  можно, на доске разрешено
[08:57.000 --> 08:59.000]  в целой краткости сокращать переменные. В коде
[08:59.000 --> 09:01.000]  Нет.
[09:01.000 --> 09:03.000]  Нет, если
[09:03.000 --> 09:05.000]  ты напишешь распознавалку,
[09:05.000 --> 09:07.000]  и оно еще тесты будет проходить.
[09:09.000 --> 09:11.000]  Можно пробовать, как сейчас модно,
[09:11.000 --> 09:13.000]  чат GPT.
[09:13.000 --> 09:15.000]  Вот я на лекции услышал вот это.
[09:15.000 --> 09:17.000]  Не можешь ли, пожалуйста, написать мне код, который
[09:17.000 --> 09:19.000]  бы в контест прошел согласно вот этим вот
[09:19.000 --> 09:21.000]  рассказам лектора. И чат GPT такая, конечно.
[09:23.000 --> 09:25.000]  Что, вы не следите за трендами?
[09:25.000 --> 09:27.000]  Чат GPT?
[09:27.000 --> 09:29.000]  Да ладно.
[09:31.000 --> 09:33.000]  Спроси у них, они тебе расскажут.
[09:35.000 --> 09:37.000]  Хорошо.
[09:37.000 --> 09:39.000]  Тогда вопрос. Если
[09:39.000 --> 09:41.000]  я создаю
[09:41.000 --> 09:43.000]  пустой лист,
[09:43.000 --> 09:45.000]  и беру...
[09:47.000 --> 09:49.000]  Ну, короче, вопрос такой. Как мне
[09:49.000 --> 09:51.000]  что из себя
[09:51.000 --> 09:53.000]  будет представлять итератор на начало и итератор
[09:53.000 --> 09:55.000]  на конец листа?
[09:59.000 --> 10:01.000]  Ну, вот если лист пустой, то что должен из себя
[10:01.000 --> 10:03.000]  представлять итератор? Он должен хранить
[10:03.000 --> 10:05.000]  на OPTR?
[10:05.000 --> 10:07.000]  Вообще говоря, конец
[10:07.000 --> 10:09.000]  это всегда.
[10:09.000 --> 10:11.000]  Ну, почему бы, кстати, и нет?
[10:13.000 --> 10:15.000]  Проблема
[10:15.000 --> 10:17.000]  с хранением NullPtr в итераторе заключается
[10:17.000 --> 10:19.000]  вот в чем.
[10:19.000 --> 10:21.000]  Из End надо уметь
[10:21.000 --> 10:23.000]  декремент делать. У нас в листе
[10:23.000 --> 10:25.000]  bidirectional итераторы.
[10:25.000 --> 10:27.000]  А bidirectional итераторы, они должны
[10:27.000 --> 10:29.000]  позволять
[10:29.000 --> 10:31.000]  делать плюс-млюс-минус-минус. В частности,
[10:31.000 --> 10:33.000]  есть требование, что если вы декрементируете
[10:33.000 --> 10:35.000]  End, вы обязательно получаете последний элемент,
[10:35.000 --> 10:37.000]  чтобы reverse итератор работал.
[10:55.000 --> 10:57.000]  Декрементировать это называется.
[10:59.000 --> 11:01.000]  А begin
[11:01.000 --> 11:03.000]  декрементировать ты, да, не обязан.
[11:05.000 --> 11:07.000]  И begin, если список пустой.
[11:07.000 --> 11:09.000]  И begin, я не обязан.
[11:09.000 --> 11:11.000]  Нет, если список не пустой,
[11:11.000 --> 11:13.000]  то что такое итератор N?
[11:19.000 --> 11:21.000]  Если у меня хранится
[11:21.000 --> 11:23.000]  в End NullPtr
[11:23.000 --> 11:25.000]  и мне делают minus-minus-end,
[11:25.000 --> 11:27.000]  я должен вернуть указатель на последний элемент
[11:27.000 --> 11:29.000]  списка, где я его возьму. И это должно за вот единицы
[11:29.000 --> 11:31.000]  делаться.
[11:31.000 --> 11:33.000]  А что хранить-то?
[11:33.000 --> 11:35.000]  В End.
[11:35.000 --> 11:37.000]  В итераторе End хранить последний элемент?
[11:39.000 --> 11:41.000]  Так это и есть.
[11:41.000 --> 11:43.000]  Хорошо, а там что хранится?
[11:43.000 --> 11:45.000]  Erbegin это просто другое слово.
[11:45.000 --> 11:47.000]  Нет, Erbegin, как мы выяснили
[11:47.000 --> 11:49.000]  в прошлый раз, хранит как раз End,
[11:49.000 --> 11:51.000]  просто он декрементирует при обращении
[11:51.000 --> 11:53.000]  к нему.
[12:03.000 --> 12:05.000]  Ага, это идея, которая часто
[12:05.000 --> 12:07.000]  приходит людям.
[12:07.000 --> 12:09.000]  Я вам сказал, что очень популярная ошибка
[12:09.000 --> 12:11.000]  это попробовать в листе в пустом
[12:11.000 --> 12:13.000]  хранить фейковую ноду.
[12:13.000 --> 12:15.000]  Самый популярный способ ее исправления,
[12:15.000 --> 12:17.000]  когда людям говоришь, так нельзя делать
[12:17.000 --> 12:19.000]  и говорят, хорошо, давайте тогда в нодах будем
[12:19.000 --> 12:21.000]  хранить не ты, а ты звездочку.
[12:21.000 --> 12:23.000]  У нас будет как бы лист, в котором в нодах
[12:23.000 --> 12:25.000]  хранятся не сами объекты, а указатели
[12:25.000 --> 12:27.000]  на объекты. А эти объекты мы
[12:27.000 --> 12:29.000]  то инициализируем, то нет.
[12:29.000 --> 12:31.000]  Нет, это конечно плохая идея, потому что
[12:31.000 --> 12:33.000]  это очень, ну, это накладные расходы
[12:33.000 --> 12:35.000]  на производительность, совершенно ненужные.
[12:35.000 --> 12:37.000]  Потому что вам придется, обращаясь
[12:37.000 --> 12:39.000]  к вершине листа, каждый раз делать прыжок по указателю.
[12:39.000 --> 12:41.000]  Вам и так-то
[12:41.000 --> 12:43.000]  когда вы ходите по листу,
[12:43.000 --> 12:45.000]  нужно постоянно прыгать по указателям.
[12:45.000 --> 12:47.000]  А так, вам обращаясь к элементам листа, каждый раз надо
[12:47.000 --> 12:49.000]  два прыжка по указателям делать.
[12:49.000 --> 12:51.000]  А мы можем сделать вот эту память
[12:51.000 --> 12:53.000]  не инициализированную просто?
[12:53.000 --> 12:55.000]  Сделать фейковую ноду, над ней хранить не инициализированную память?
[12:55.000 --> 12:57.000]  Да, это третья идея.
[12:57.000 --> 12:59.000]  Вот.
[12:59.000 --> 13:01.000]  А вы сами понимаете, какими недостатками
[13:01.000 --> 13:03.000]  было? Ну вы можете, то есть здесь можно
[13:03.000 --> 13:05.000]  сделать пример следующий. Здесь можно сделать
[13:05.000 --> 13:07.000]  массив чаров размера size of t,
[13:07.000 --> 13:09.000]  там с нужным выравниванием,
[13:09.000 --> 13:11.000]  но про выравниваем пока не говорили.
[13:11.000 --> 13:13.000]  И да, просто в нужный момент
[13:13.000 --> 13:15.000]  натравливать на него конструктор, ну а если список пустой,
[13:15.000 --> 13:17.000]  то просто в нем фейковая нода есть, которая
[13:17.000 --> 13:19.000]  в ней
[13:19.000 --> 13:21.000]  массив чаров,
[13:21.000 --> 13:23.000]  да, но там объекта t не
[13:23.000 --> 13:25.000]  создана.
[13:25.000 --> 13:27.000]  Ну, мы хотим создать
[13:27.000 --> 13:29.000]  фейковую ноду, которая бы как бы существовала
[13:29.000 --> 13:31.000]  всегда,
[13:31.000 --> 13:33.000]  даже в пустом списке, но мы не должны
[13:33.000 --> 13:35.000]  создавать объект t в пустом списке.
[13:35.000 --> 13:37.000]  Чего?
[13:41.000 --> 13:43.000]  Чего?
[13:55.000 --> 13:57.000]  В общем, слушайте, давайте я...
[13:57.000 --> 13:59.000]  Ну,
[13:59.000 --> 14:01.000]  то есть ты предлагаешь по-прежнему хранить NullPtr
[14:01.000 --> 14:03.000]  в Энде?
[14:03.000 --> 14:05.000]  В Энде?
[14:05.000 --> 14:07.000]  В Энде хранить последний элемент?
[14:07.000 --> 14:09.000]  Да.
[14:09.000 --> 14:11.000]  И как тогда сравнивать с End?
[14:11.000 --> 14:13.000]  То есть каждый раз при сравнении итераторов,
[14:13.000 --> 14:15.000]  ты проверяешь, если это последний элемент,
[14:15.000 --> 14:17.000]  то надо отдельно проверить это End или это настоящий
[14:17.000 --> 14:19.000]  последний элемент?
[14:19.000 --> 14:21.000]  Что?
[14:21.000 --> 14:23.000]  К чему?
[14:25.000 --> 14:27.000]  Как ты поймешь, что это End?
[14:27.000 --> 14:29.000]  Вот тебя сравнивают два итератора.
[14:29.000 --> 14:31.000]  Нет, у тебя есть метод сравнения
[14:31.000 --> 14:33.000]  итераторов на равенство, например.
[14:33.000 --> 14:35.000]  И оба итератора указывают
[14:35.000 --> 14:37.000]  на одну и ту же вершину,
[14:37.000 --> 14:39.000]  но один из них реально указывает на последнюю вершину,
[14:39.000 --> 14:41.000]  а другой итератор это End, который у тебя тоже указывает
[14:41.000 --> 14:43.000]  на последнюю вершину.
[14:47.000 --> 14:49.000]  Что значит во внешнем мире?
[14:49.000 --> 14:51.000]  То есть ты хранишь флаг, это End или это настоящий
[14:51.000 --> 14:53.000]  итератор?
[14:53.000 --> 14:55.000]  Ну, тебе в итераторе...
[14:55.000 --> 14:57.000]  Что хранить в итераторе?
[14:57.000 --> 14:59.000]  Ну, в итераторе, по идее, мы храним тоже указатель
[14:59.000 --> 15:01.000]  на ноду.
[15:01.000 --> 15:03.000]  То есть в структуре итератор...
[15:03.000 --> 15:05.000]  Ну, я напоминаю, что на самом деле
[15:05.000 --> 15:07.000]  это не структура итератора, а структура
[15:07.000 --> 15:09.000]  Base Iterator, которая параметризована
[15:09.000 --> 15:11.000]  шаблонным параметром const или не const.
[15:11.000 --> 15:13.000]  Ну, давайте я для простоты
[15:13.000 --> 15:15.000]  назову ее просто Iterator.
[15:15.000 --> 15:17.000]  Это тоже внутренняя структура листа, и в ней тоже
[15:17.000 --> 15:19.000]  хранится указатель на ноду.
[15:21.000 --> 15:23.000]  ПТР.
[15:23.000 --> 15:25.000]  Вот. И вы предлагаете...
[15:25.000 --> 15:27.000]  Вот проблема с тем, как
[15:27.000 --> 15:29.000]  красиво обработать случай End.
[15:29.000 --> 15:31.000]  Короче, я не буду вас больше
[15:31.000 --> 15:33.000]  допытывать вопросами, я просто расскажу, как...
[15:33.000 --> 15:35.000]  В общем, наиболее
[15:35.000 --> 15:37.000]  красиво известный мне способ это делать,
[15:37.000 --> 15:39.000]  который будет рекомендоваться вам всем.
[15:39.000 --> 15:41.000]  На самом деле есть такая хитрость,
[15:41.000 --> 15:43.000]  и так, кстати, сделано, по-моему, в STL в том числе.
[15:43.000 --> 15:45.000]  У нас будет две
[15:45.000 --> 15:47.000]  структуры. У нас будет структура Node,
[15:47.000 --> 15:49.000]  а будет структура Base Node.
[15:51.000 --> 15:53.000]  Очень красиво. Сейчас вы увидите,
[15:53.000 --> 15:55.000]  почему.
[15:55.000 --> 15:57.000]  У нас будет структура Base Node,
[15:59.000 --> 16:01.000]  которая хранит
[16:01.000 --> 16:03.000]  Node звездочка,
[16:03.000 --> 16:05.000]  которая, в общем, хранит два указателя.
[16:09.000 --> 16:11.000]  А структура Node,
[16:15.000 --> 16:17.000]  она наследница
[16:17.000 --> 16:19.000]  Base Node,
[16:21.000 --> 16:23.000]  и хранит еще
[16:23.000 --> 16:25.000]  две.
[16:27.000 --> 16:29.000]  А теперь мы следующую вещь
[16:29.000 --> 16:31.000]  делаем. Мы храним список
[16:31.000 --> 16:33.000]  в закольцованном виде.
[16:33.000 --> 16:35.000]  У нас есть всегда
[16:35.000 --> 16:37.000]  вот эта фейковая вершина, Base Node,
[16:37.000 --> 16:39.000]  которая есть у любого
[16:39.000 --> 16:41.000]  списка,
[16:41.000 --> 16:43.000]  и мы начинаем...
[16:43.000 --> 16:45.000]  Когда у нас
[16:45.000 --> 16:47.000]  в списке появляются реальные элементы,
[16:47.000 --> 16:49.000]  то у нас Begin
[16:49.000 --> 16:51.000]  это вот этот вот элемент,
[16:51.000 --> 16:53.000]  а End это вот этот вот элемент.
[16:55.000 --> 16:57.000]  И указывают они вот так
[16:57.000 --> 16:59.000]  друг на друга. То есть вот это Next.
[17:03.000 --> 17:05.000]  Следующий за
[17:07.000 --> 17:09.000]  Node это фейковая
[17:09.000 --> 17:11.000]  вершина. В ней не лежит
[17:11.000 --> 17:13.000]  T, и она
[17:15.000 --> 17:17.000]  является таким маркером конца
[17:17.000 --> 17:19.000]  списка.
[17:21.000 --> 17:23.000]  Вот.
[17:23.000 --> 17:25.000]  А храним мы теперь не указатель
[17:25.000 --> 17:27.000]  на Node, а указатель на Base Node.
[17:27.000 --> 17:29.000]  И здесь мы храним указатель на Base Node,
[17:29.000 --> 17:31.000]  конечно.
[17:31.000 --> 17:33.000]  Смысл в том,
[17:33.000 --> 17:35.000]  чтобы у тебя
[17:35.000 --> 17:37.000]  End и вычитание из End работало
[17:37.000 --> 17:39.000]  корректно и без костылей.
[17:39.000 --> 17:41.000]  Чтобы тебе, во-первых, не приходилось создавать
[17:41.000 --> 17:43.000]  End указатель на NullPtr,
[17:43.000 --> 17:45.000]  который непонятно как декрементировать.
[17:45.000 --> 17:47.000]  Еще у тебя End от разных списков,
[17:47.000 --> 17:49.000]  это по идее должны быть разные указатели.
[17:49.000 --> 17:51.000]  Ну, по крайней мере, если
[17:51.000 --> 17:53.000]  ты копируешь до End одного списка,
[17:53.000 --> 17:55.000]  то ты не должен...
[17:55.000 --> 17:57.000]  Кстати, я не уверен,
[17:57.000 --> 17:59.000]  что это формальное требование стандарта. Может, этого и не должно быть.
[17:59.000 --> 18:01.000]  Но в любом случае у тебя должно...
[18:07.000 --> 18:09.000]  Ну да, наверное, такого требования нет,
[18:09.000 --> 18:11.000]  что End от разных списков это разная штука.
[18:11.000 --> 18:13.000]  Но вот в нашей реализации это будет.
[18:15.000 --> 18:17.000]  Из Base Node никак?
[18:17.000 --> 18:19.000]  А, в смысле, как вы...
[18:19.000 --> 18:21.000]  Ну, вы
[18:21.000 --> 18:23.000]  будете Cast делать, да.
[18:23.000 --> 18:25.000]  Static Cast.
[18:25.000 --> 18:27.000]  Чего?
[18:27.000 --> 18:29.000]  Оно и так публичное.
[18:29.000 --> 18:31.000]  Структуры.
[18:33.000 --> 18:35.000]  Это лист с одним элементом так выглядит.
[18:35.000 --> 18:37.000]  У листа с одним элементом
[18:37.000 --> 18:39.000]  на самом деле две вершины,
[18:39.000 --> 18:41.000]  и они в кольцевой список закручены.
[18:41.000 --> 18:43.000]  Вот это Begin, а вот это End.
[18:43.000 --> 18:45.000]  Но в End не хранится значение.
[18:47.000 --> 18:49.000]  Если это End, то я пытаюсь сделать Static Cast,
[18:49.000 --> 18:51.000]  и если не удалось...
[18:51.000 --> 18:53.000]  Когда ты проверяешь на End,
[18:53.000 --> 18:55.000]  тебе на самом деле теперь в полях
[18:55.000 --> 18:57.000]  достаточно хранить всего один указатель.
[18:57.000 --> 18:59.000]  Ты можешь хранить в полях самого листа
[18:59.000 --> 19:01.000]  тебе достаточно хранить
[19:01.000 --> 19:03.000]  просто указатель на
[19:03.000 --> 19:05.000]  вот, не знаю, как хочешь его назови,
[19:05.000 --> 19:07.000]  Start. Ты знаешь, что
[19:07.000 --> 19:09.000]  если в твоем листе есть один элемент,
[19:09.000 --> 19:11.000]  то он следующий после вот этого.
[19:11.000 --> 19:13.000]  Ну, мы храним вот этот вот
[19:13.000 --> 19:15.000]  элемент, который на самом деле указывает
[19:15.000 --> 19:17.000]  на, я не знаю, на fake node.
[19:21.000 --> 19:23.000]  Да, и это base node, конечно.
[19:23.000 --> 19:25.000]  То есть мы
[19:25.000 --> 19:27.000]  от другого костыля пришли к другому.
[19:27.000 --> 19:29.000]  Но мы
[19:29.000 --> 19:31.000]  не хотели создавать фейковую вершину,
[19:31.000 --> 19:33.000]  поэтому создали ее тупо без значения.
[19:33.000 --> 19:35.000]  Мы хотели...
[19:35.000 --> 19:37.000]  Ну, фейковая вершина,
[19:37.000 --> 19:39.000]  я бы не сказал, что это костыль.
[19:39.000 --> 19:41.000]  Чего?
[19:41.000 --> 19:43.000]  Мы реально создали фейковую вершину.
[19:43.000 --> 19:45.000]  Но просто мы не
[19:45.000 --> 19:47.000]  положили в нее t.
[19:47.000 --> 19:49.000]  Нам нужно, чтобы была
[19:49.000 --> 19:51.000]  какая-то штука, маркер конца списка,
[19:51.000 --> 19:53.000]  в которой бы не лежала t.
[19:53.000 --> 19:55.000]  Но мы не можем создать объект типа node
[19:55.000 --> 19:57.000]  для этого, потому что объект типа node
[19:57.000 --> 19:59.000]  подразумевает создание объекта t.
[19:59.000 --> 20:01.000]  И дальше мы могли бы пытаться сделать
[20:01.000 --> 20:03.000]  массив чаров вместо t и вручную new
[20:03.000 --> 20:05.000]  туда пихать каждый раз и delete.
[20:05.000 --> 20:07.000]  Чего?
[20:07.000 --> 20:09.000]  Потому что нам теперь не нужно хранить...
[20:09.000 --> 20:11.000]  Потому что мы теперь даже сэкономили память на список.
[20:11.000 --> 20:13.000]  Нам теперь не нужно хранить указатель на начало и конец.
[20:13.000 --> 20:15.000]  У нас всегда один указатель.
[20:15.000 --> 20:17.000]  У нас у любого списка есть вот это вот,
[20:17.000 --> 20:19.000]  маркер конца списка.
[20:19.000 --> 20:21.000]  Фейковая вершина.
[20:21.000 --> 20:23.000]  А если список начинает пополняться элементами,
[20:23.000 --> 20:25.000]  то они вот так вот в круг выстраиваются.
[20:25.000 --> 20:27.000]  И в конце он закольцован.
[20:27.000 --> 20:29.000]  Следующий элемент он всегда
[20:29.000 --> 20:31.000]  приводит к base node.
[20:37.000 --> 20:39.000]  Ну, от base node мы формально не имеем права
[20:39.000 --> 20:41.000]  брать.
[20:41.000 --> 20:43.000]  Но вот если мы берем преф от base node...
[20:43.000 --> 20:45.000]  Да, если мы берем преф от fake node, то мы получим begin
[20:45.000 --> 20:47.000]  в случае одной элементного списка, как и должны.
[20:49.000 --> 20:51.000]  Next это детали нашей реализации.
[20:51.000 --> 20:53.000]  Next мы тоже получим, но это не по стандарту.
[20:55.000 --> 20:57.000]  Нет, мы должны получать...
[20:59.000 --> 21:01.000]  И мы должны предыдущий элемент от end получать
[21:01.000 --> 21:03.000]  нормальным элементом. Вот это у нас теперь
[21:03.000 --> 21:05.000]  обеспечено.
[21:05.000 --> 21:07.000]  Нет, не на lptr там.
[21:07.000 --> 21:09.000]  Там вот указатель
[21:09.000 --> 21:11.000]  на эту вершину, которая создается...
[21:11.000 --> 21:13.000]  Вот в конструкторе надо написать,
[21:13.000 --> 21:15.000]  как она создается.
[21:15.000 --> 21:17.000]  Кого выделять в куче?
[21:17.000 --> 21:19.000]  А я не сказал, что в куче
[21:19.000 --> 21:21.000]  выделяется.
[21:23.000 --> 21:25.000]  В итераторе?
[21:25.000 --> 21:27.000]  А, вот здесь.
[21:27.000 --> 21:29.000]  Да, это правда.
[21:29.000 --> 21:31.000]  Совершенно верно. Это я забыл сказать.
[21:31.000 --> 21:33.000]  Это следующая идея.
[21:33.000 --> 21:35.000]  Правильная идея. Теперь мы понимаем,
[21:35.000 --> 21:37.000]  что нам даже не нужно указатель...
[21:37.000 --> 21:39.000]  Нам ее можно просто на стеке выделить.
[21:39.000 --> 21:41.000]  Нам не нужно даже хранить указатель на нее.
[21:41.000 --> 21:43.000]  Нам достаточно хранить просто ее саму
[21:45.000 --> 21:47.000]  в полях листа.
[21:47.000 --> 21:49.000]  Саму эту вершину можно
[21:49.000 --> 21:51.000]  хранить в полях листа, а не указатель на нее.
[21:51.000 --> 21:53.000]  Потому что...
[21:57.000 --> 21:59.000]  Пустой лист использует два указателя
[21:59.000 --> 22:01.000]  памяти, да.
[22:01.000 --> 22:03.000]  Бейсноут, как это было и раньше.
[22:03.000 --> 22:05.000]  Ну, сайз хорошо.
[22:05.000 --> 22:07.000]  Еще 4 байта. Класс.
[22:07.000 --> 22:09.000]  Ну, все равно
[22:09.000 --> 22:11.000]  из-за выравнивания будет
[22:11.000 --> 22:13.000]  24 байта, да.
[22:13.000 --> 22:15.000]  Да, что?
[22:15.000 --> 22:17.000]  На стеке.
[22:19.000 --> 22:21.000]  В пустом случае одна нода.
[22:21.000 --> 22:23.000]  В случае одного элемента две.
[22:23.000 --> 22:25.000]  Вот.
[22:25.000 --> 22:27.000]  Да.
[22:27.000 --> 22:29.000]  Нам нужно еще хранить
[22:29.000 --> 22:31.000]  size.
[22:31.000 --> 22:33.000]  Size t нам нужно
[22:33.000 --> 22:35.000]  хранить, потому что
[22:35.000 --> 22:37.000]  если бы мы не хранили size,
[22:37.000 --> 22:39.000]  то нам бы золото n его вычитать
[22:39.000 --> 22:41.000]  приходилось. Вот. В списке
[22:41.000 --> 22:43.000]  хранится еще размер, чтобы
[22:43.000 --> 22:45.000]  в метод size работал золото единицы.
[22:45.000 --> 22:47.000]  Вот.
[22:47.000 --> 22:49.000]  Да.
[22:49.000 --> 22:51.000]  То мы получим
[22:51.000 --> 22:53.000]  уб.
[22:53.000 --> 22:55.000]  А что мы получим в нашей реализации?
[22:55.000 --> 22:57.000]  Ну, видимо, да.
[22:57.000 --> 22:59.000]  Begin.
[22:59.000 --> 23:01.000]  По стандарту это уб.
[23:01.000 --> 23:03.000]  Да.
[23:03.000 --> 23:05.000]  Если список пустой, то у нас только
[23:05.000 --> 23:07.000]  одна фейковая вершина и больше ничего.
[23:07.000 --> 23:09.000]  Да.
[23:13.000 --> 23:15.000]  Ну, это будет неудобно, скорее всего.
[23:15.000 --> 23:17.000]  Ну, можно, наверное.
[23:23.000 --> 23:25.000]  Вот. Зато
[23:25.000 --> 23:27.000]  инкрементация, декрементация итераторов и сравнение
[23:27.000 --> 23:29.000]  сработает теперь очень красиво,
[23:29.000 --> 23:31.000]  очень коротко. Мы просто
[23:31.000 --> 23:33.000]  идем вперед по указателям всегда.
[23:33.000 --> 23:35.000]  Если нам надо инкрементировать, декрементировать итератор.
[23:35.000 --> 23:37.000]  Да.
[23:37.000 --> 23:39.000]  Если это фейк ноут,
[23:39.000 --> 23:41.000]  значит это он.
[23:41.000 --> 23:43.000]  Вот.
[23:43.000 --> 23:45.000]  Кстати, каким
[23:45.000 --> 23:47.000]  важным
[23:49.000 --> 23:51.000]  итератор
[23:51.000 --> 23:53.000]  в каком смысле?
[23:53.000 --> 23:55.000]  Страт итератор.
[23:55.000 --> 23:57.000]  Ну, я пишу в STL стиле,
[23:57.000 --> 23:59.000]  но вам надо будет писать
[23:59.000 --> 24:01.000]  ну, юзинга вам надо будет
[24:01.000 --> 24:03.000]  писать тоже в STL стиле с маленькой буквы.
[24:03.000 --> 24:05.000]  Юзинг итератор равно бейс итератор.
[24:07.000 --> 24:09.000]  Кстати, еще
[24:09.000 --> 24:11.000]  важный
[24:11.000 --> 24:13.000]  момент.
[24:13.000 --> 24:15.000]  Каким важным свойством обладает лист
[24:15.000 --> 24:17.000]  связанным с итераторами?
[24:17.000 --> 24:19.000]  Он их не инвалидирует
[24:19.000 --> 24:21.000]  никогда, ни при каких
[24:21.000 --> 24:23.000]  обстоятельствах. Лист? Лист, да.
[24:23.000 --> 24:25.000]  То есть мы с вами раньше говорили, вот помните, что
[24:25.000 --> 24:27.000]  вектор, он таким плохим
[24:27.000 --> 24:29.000]  свойством обладает, что если вы что-нибудь
[24:29.000 --> 24:31.000]  вектор положите, то у вас
[24:31.000 --> 24:33.000]  сломаются указатели и ссылки на
[24:33.000 --> 24:35.000]  элементы.
[24:35.000 --> 24:37.000]  Вообще говоря, сломаются, то есть нет гарантий,
[24:37.000 --> 24:39.000]  что не сломаются. Если вы в дек
[24:39.000 --> 24:41.000]  что-нибудь положите,
[24:41.000 --> 24:43.000]  не обязательно в серединку, хоть в конец.
[24:45.000 --> 24:47.000]  Если вы в дек что-нибудь положите, хоть в конец,
[24:47.000 --> 24:49.000]  хоть в начало,
[24:49.000 --> 24:51.000]  у вас тоже могут сломаться, но
[24:51.000 --> 24:53.000]  не указатели и ссылки, а только
[24:53.000 --> 24:55.000]  итераторы. Вот про дек мы, кстати,
[24:55.000 --> 24:57.000]  не обсудили как следует.
[24:57.000 --> 24:59.000]  В деке при добавлении элемента
[24:59.000 --> 25:01.000]  ломаются
[25:01.000 --> 25:03.000]  итераторы,
[25:03.000 --> 25:05.000]  а указатели и ссылки не ломаются. Это не тривиальный факт,
[25:05.000 --> 25:07.000]  над которым я вам предлагаю вам подумать.
[25:07.000 --> 25:09.000]  То есть указатели и ссылки не ломаются, это мы обсуждали
[25:09.000 --> 25:11.000]  в прошлый раз. Но итераторы все-таки ломаются
[25:11.000 --> 25:13.000]  при добавлении в дек, вот это
[25:13.000 --> 25:15.000]  не тривиально. Понимаете, почему
[25:15.000 --> 25:17.000]  ломаются при добавлении в дек?
[25:17.000 --> 25:19.000]  Потому что может реалоцироваться внешний
[25:19.000 --> 25:21.000]  массив, а итератор он как-то
[25:21.000 --> 25:23.000]  ну, итератор дек он хранит в себе
[25:23.000 --> 25:25.000]  скорее всего индекс во внешнем массиве
[25:25.000 --> 25:27.000]  и индекс вот в том
[25:27.000 --> 25:29.000]  блоке, который
[25:29.000 --> 25:31.000]  на который указывается внешний массив.
[25:31.000 --> 25:33.000]  Вот.
[25:33.000 --> 25:35.000]  Ну, короче, ты можешь попробовать
[25:35.000 --> 25:37.000]  в общем
[25:37.000 --> 25:39.000]  в общем
[25:39.000 --> 25:41.000]  в общем
[25:41.000 --> 25:43.000]  Сейчас итераторы инвалидируются, а указатели
[25:43.000 --> 25:45.000]  указатели и ссылки нет, а итераторы
[25:45.000 --> 25:47.000]  да, потому что у вас сбивается индексация
[25:47.000 --> 25:49.000]  и вы там ничего не придумаете хорошего
[25:49.000 --> 25:51.000]  только если не создадите дополнительный
[25:51.000 --> 25:53.000]  уровень дирекции. В общем, long story short
[25:55.000 --> 25:57.000]  не получится, короче, сделать дек
[25:57.000 --> 25:59.000]  со всеми требованиями, как я сказал
[25:59.000 --> 26:01.000]  с неинвалидирующимися итераторами, если
[26:01.000 --> 26:03.000]  только не добавить туда еще накладных расходов
[26:03.000 --> 26:05.000]  на разыменование дополнительное. Но этого мы
[26:05.000 --> 26:07.000]  не хотим делать. В общем, когда
[26:07.000 --> 26:09.000]  вы будете писать дек, вы
[26:09.000 --> 26:11.000]  помните о том, что
[26:11.000 --> 26:13.000]  итераторы дек инвалидируют
[26:13.000 --> 26:15.000]  при добавлении элементов, а вот
[26:15.000 --> 26:17.000]  указатели и ссылки не обязательно.
[26:17.000 --> 26:19.000]  Но лист не инвалидирует ничего
[26:19.000 --> 26:21.000]  ни итераторы, ни указатели, ни ссылки.
[26:21.000 --> 26:23.000]  То есть вы можете безопасно заводить ссылку
[26:23.000 --> 26:25.000]  или указательный элемент листа
[26:25.000 --> 26:27.000]  и
[26:27.000 --> 26:29.000]  что угодно
[26:29.000 --> 26:31.000]  с листом делать, добавлять в него, что-нибудь
[26:31.000 --> 26:33.000]  вставлять, только не удалять
[26:33.000 --> 26:35.000]  этот самый элемент, на который вы ссылку завели.
[26:35.000 --> 26:37.000]  Понятно, что если вы удалите его сам из листа
[26:37.000 --> 26:39.000]  вот меня очень веселит всегда вопрос,
[26:39.000 --> 26:41.000]  но если я удалю этот элемент из листа,
[26:41.000 --> 26:43.000]  он же инвалидируется? Да, конечно, если вы удалите
[26:43.000 --> 26:45.000]  тот элемент, на который у вас итератор,
[26:45.000 --> 26:47.000]  то итератор инвалидируется. Под неинвалидацией
[26:47.000 --> 26:49.000]  подразумевается, что операция над всеми
[26:49.000 --> 26:51.000]  остальными элементами не
[26:51.000 --> 26:53.000]  портит указатель, ссылку или итератор
[26:53.000 --> 26:55.000]  на ваш элемент.
[26:55.000 --> 26:57.000]  То есть у меня в листе
[26:57.000 --> 26:59.000]  ноды, они однажды
[26:59.000 --> 27:01.000]  аллоцировавшись, никогда не
[27:03.000 --> 27:05.000]  не перекладываются никуда.
[27:05.000 --> 27:07.000]  На каждую новую ноду
[27:07.000 --> 27:09.000]  лист заново вызывает
[27:09.000 --> 27:11.000]  оператор new и аллоцирует новый
[27:11.000 --> 27:13.000]  кусочек маленькой динамической памяти именно под
[27:13.000 --> 27:15.000]  эту ноду.
[27:15.000 --> 27:17.000]  Если вы в лист делаете 500
[27:17.000 --> 27:19.000]  пушбеков, то у вас
[27:19.000 --> 27:21.000]  500 раз будет вызван оператор new.
[27:21.000 --> 27:23.000]  Это замедляет
[27:23.000 --> 27:25.000]  работу, конечно, но это
[27:25.000 --> 27:27.000]  гарантирует вам, что у вас не инвалидируются
[27:27.000 --> 27:29.000]  итераторы, если вы будете сколько угодно
[27:29.000 --> 27:31.000]  добавлять в лист. Ноды эти никогда
[27:31.000 --> 27:33.000]  никуда не перекладываются.
[27:35.000 --> 27:37.000]  Такие дела.
[27:37.000 --> 27:39.000]  Так.
[27:39.000 --> 27:41.000]  Сейчас я проверю, не забыл я что-нибудь еще сказать про
[27:41.000 --> 27:43.000]  лист, наверняка забыл.
[27:45.000 --> 27:47.000]  Чего?
[27:49.000 --> 27:51.000]  Стоп, а мы будем свою мапу писать, да?
[27:51.000 --> 27:53.000]  Unordered map.
[27:53.000 --> 27:55.000]  А свою мапу не будет?
[27:55.000 --> 27:57.000]  Ну, unordered.
[27:57.000 --> 27:59.000]  Красно-черная не будет?
[27:59.000 --> 28:01.000]  Нет.
[28:01.000 --> 28:03.000]  А где?
[28:03.000 --> 28:05.000]  А вы в первом семестре не писали его?
[28:05.000 --> 28:07.000]  Нет.
[28:07.000 --> 28:09.000]  Я думал, что в первом
[28:09.000 --> 28:11.000]  семестре вы...
[28:11.000 --> 28:13.000]  Ну ладно.
[28:13.000 --> 28:15.000]  Разве не в листе?
[28:15.000 --> 28:17.000]  В листе, да.
[28:25.000 --> 28:27.000]  Вот.
[28:27.000 --> 28:29.000]  У листа есть
[28:29.000 --> 28:31.000]  несколько
[28:31.000 --> 28:33.000]  особых методов.
[28:37.000 --> 28:39.000]  Вот на такие...
[28:39.000 --> 28:41.000]  Вот если вы откроете сейчас
[28:41.000 --> 28:43.000]  страницу
[28:43.000 --> 28:45.000]  list, sdlist на cp-reference,
[28:45.000 --> 28:47.000]  там вы найдете несколько особых методов,
[28:47.000 --> 28:49.000]  которых нет у других контейнеров.
[28:49.000 --> 28:51.000]  Есть только метод splice.
[28:51.000 --> 28:53.000]  Splice, нет.
[28:53.000 --> 28:55.000]  Splice это...
[28:55.000 --> 28:57.000]  Это...
[28:59.000 --> 29:01.000]  Если я правильно помню перевод с английского,
[29:01.000 --> 29:03.000]  это значит что-то типа
[29:03.000 --> 29:05.000]  нарезать кусочками.
[29:05.000 --> 29:07.000]  Типа вот так вот.
[29:07.000 --> 29:09.000]  Что такое splice?
[29:11.000 --> 29:13.000]  А, да, сплетать концы.
[29:13.000 --> 29:15.000]  А нарезать кусочками значит перепутать с каким-то другим словом.
[29:15.000 --> 29:17.000]  Блин, а с каким словом я перепутал?
[29:17.000 --> 29:19.000]  А, splice нарезать кусочками.
[29:19.000 --> 29:21.000]  Splice это наоборот, да.
[29:21.000 --> 29:23.000]  Сейчас.
[29:23.000 --> 29:25.000]  Ох уж, это английский язык.
[29:25.000 --> 29:27.000]  Сейчас, а где я тогда...
[29:27.000 --> 29:29.000]  Какой же метод был такой? Ну ладно, неважно.
[29:29.000 --> 29:31.000]  Splice. Это у меня с питоном, что ли?
[29:31.000 --> 29:33.000]  Так, все, ладно.
[29:33.000 --> 29:35.000]  Splice, короче, это значит... Что такое splice?
[29:35.000 --> 29:37.000]  Это... У вас есть лист?
[29:41.000 --> 29:43.000]  Да, стыдно, конечно.
[29:45.000 --> 29:47.000]  Перепутать такие слова,
[29:47.000 --> 29:49.000]  ну ладно.
[29:49.000 --> 29:51.000]  У вас есть лист, что вы можете сделать?
[29:51.000 --> 29:53.000]  Вы можете взять кусок другого листа
[29:55.000 --> 29:57.000]  и завод едини... ну, как бы...
[29:57.000 --> 29:59.000]  и вклеить сюда.
[29:59.000 --> 30:01.000]  Вырезав отсюда.
[30:01.000 --> 30:03.000]  Со связанными списками такая операция, возможно.
[30:05.000 --> 30:07.000]  Вот, вырезать отсюда кусок листа
[30:07.000 --> 30:09.000]  и всклеить сюда.
[30:09.000 --> 30:11.000]  При этом, по-прежнему, никакие итераторы не инвалидируются.
[30:13.000 --> 30:15.000]  Вот.
[30:15.000 --> 30:17.000]  За какой этим точкой это работает?
[30:17.000 --> 30:19.000]  Вот это хитрый вопрос.
[30:19.000 --> 30:21.000]  В свое время там...
[30:23.000 --> 30:25.000]  Вопрос наподумать.
[30:25.000 --> 30:27.000]  На самом деле это работает за линию от числа элементов.
[30:27.000 --> 30:29.000]  Почему-то. Хотя, казалось бы.
[30:29.000 --> 30:31.000]  Вот. Это работает за линию от числа вот этих элементов.
[30:31.000 --> 30:33.000]  Почему?
[30:33.000 --> 30:35.000]  Потому что надо поддержать size.
[30:35.000 --> 30:37.000]  Правильно.
[30:39.000 --> 30:41.000]  Так это кусок листа.
[30:41.000 --> 30:43.000]  Ты же не знаешь, сколько между ними.
[30:43.000 --> 30:45.000]  У вас бы directional итератор.
[30:45.000 --> 30:47.000]  Все бы хорошо, казалось бы, просто вырежешь отсюда
[30:47.000 --> 30:49.000]  и вклей сюда.
[30:49.000 --> 30:51.000]  Но, к сожалению, как я сказал ранее,
[30:51.000 --> 30:53.000]  нужно поддерживать size за от единицы.
[30:53.000 --> 30:55.000]  И size как поле.
[30:55.000 --> 30:57.000]  А значит, придется пройти и посчитать, сколько их было.
[30:57.000 --> 30:59.000]  Вот.
[30:59.000 --> 31:01.000]  Считается, что size это более важно
[31:01.000 --> 31:03.000]  должно за от единицы, чем вот это.
[31:03.000 --> 31:05.000]  То есть, выбор.
[31:05.000 --> 31:07.000]  Либо это за от единицы, но тогда size за линию.
[31:07.000 --> 31:09.000]  Либо наоборот.
[31:09.000 --> 31:11.000]  Но, очевидно, size это более нужная вещь, чем это.
[31:11.000 --> 31:13.000]  Поэтому size решили за единицу, а это за линию.
[31:13.000 --> 31:15.000]  Вы смеетесь,
[31:15.000 --> 31:17.000]  а вот forward листа
[31:17.000 --> 31:19.000]  примерно так и есть.
[31:21.000 --> 31:23.000]  Ну, у него вообще нет метода size.
[31:31.000 --> 31:33.000]  Вот.
[31:33.000 --> 31:35.000]  Еще какие есть методы.
[31:35.000 --> 31:37.000]  Вот у листа есть метод sort.
[31:39.000 --> 31:41.000]  У листа есть метод sort.
[31:41.000 --> 31:43.000]  Sort это метод листа.
[31:43.000 --> 31:45.000]  Это не внешняя функция stdsort,
[31:45.000 --> 31:47.000]  а это метод листа. List1.sort.
[31:47.000 --> 31:49.000]  Sort. Да, у листа такой метод.
[31:49.000 --> 31:51.000]  Опять-таки вопрос на понимание,
[31:51.000 --> 31:53.000]  почему это отдельный метод?
[31:53.000 --> 31:55.000]  Почему бы не...
[31:55.000 --> 31:57.000]  Сортирует лист.
[31:59.000 --> 32:01.000]  Чего?
[32:03.000 --> 32:05.000]  Ну, там не contiguous же нужны.
[32:05.000 --> 32:07.000]  Не random access.
[32:07.000 --> 32:09.000]  Не random access итераторы.
[32:09.000 --> 32:11.000]  Stdsort нужны random access итераторы.
[32:11.000 --> 32:13.000]  Дело в том, что stdsort
[32:13.000 --> 32:15.000]  требует random access итераторы.
[32:15.000 --> 32:17.000]  Потому что stdsort
[32:17.000 --> 32:19.000]  это же quick sort,
[32:19.000 --> 32:21.000]  с оптимизациями, но тем не менее.
[32:21.000 --> 32:23.000]  А ей нужны random access итераторы,
[32:23.000 --> 32:25.000]  потому что она там
[32:25.000 --> 32:27.000]  ходит назад вперед, потом прыгает куда-то там
[32:27.000 --> 32:29.000]  в середину, еще куда-то.
[32:29.000 --> 32:31.000]  Чего?
[32:31.000 --> 32:33.000]  Насильно написать сюда merge sort.
[32:33.000 --> 32:35.000]  А вот сюда написано... А здесь merge sort?
[32:35.000 --> 32:37.000]  Вот. То есть у листа
[32:37.000 --> 32:39.000]  merge sort работает не так, как stdsort.
[32:39.000 --> 32:41.000]  Потому что в листе sort
[32:41.000 --> 32:43.000]  вынужден обходиться лишь
[32:43.000 --> 32:45.000]  bidirectional итераторами,
[32:45.000 --> 32:47.000]  и поэтому там написан merge sort.
[32:47.000 --> 32:49.000]  Потому что вот для merge sort bidirectional итераторов достаточно.
[32:49.000 --> 32:51.000]  Хорошо вопрос.
[32:51.000 --> 32:53.000]  А там merge sort за единицу памяти допомнился?
[32:53.000 --> 32:55.000]  Вот, кстати,
[32:55.000 --> 32:57.000]  не знаю.
[32:57.000 --> 32:59.000]  Fun fact, in place merge
[32:59.000 --> 33:01.000]  метод, который есть востояние,
[33:01.000 --> 33:03.000]  он
[33:03.000 --> 33:05.000]  использует не от единицы
[33:05.000 --> 33:07.000]  в памяти.
[33:07.000 --> 33:09.000]  Ага.
[33:09.000 --> 33:11.000]  Интересно, почему это новое,
[33:11.000 --> 33:13.000]  типа неизвестное алгоритм,
[33:13.000 --> 33:15.000]  судя по интернету.
[33:15.000 --> 33:17.000]  Чего-чего-чего метод?
[33:17.000 --> 33:19.000]  Если вы пробуете погуглить сюда merge
[33:19.000 --> 33:21.000]  за единицу памяти дополнительной,
[33:21.000 --> 33:23.000]  то это что-то неизвестное.
[33:23.000 --> 33:25.000]  Известное алгоритм за mbox
[33:25.000 --> 33:27.000]  квадрат вместо дополнительной памяти.
[33:27.000 --> 33:29.000]  Merge sort.
[33:31.000 --> 33:33.000]  Ладно.
[33:33.000 --> 33:35.000]  Я не буду спорить, потому что я не уверен
[33:35.000 --> 33:37.000]  на сто процентов.
[33:37.000 --> 33:39.000]  Ну да, да.
[33:41.000 --> 33:43.000]  Давайте дальше.
[33:43.000 --> 33:45.000]  Какие еще есть методы?
[33:45.000 --> 33:47.000]  Еще есть метод reverse
[33:47.000 --> 33:49.000]  развернуть лист.
[33:53.000 --> 33:55.000]  Вот.
[33:55.000 --> 33:57.000]  Метод reverse.
[33:57.000 --> 33:59.000]  Метод reverse.
[34:03.000 --> 34:05.000]  Опять-таки,
[34:05.000 --> 34:07.000]  почему reverse это метод листа,
[34:07.000 --> 34:09.000]  а не стандартный алгоритм?
[34:09.000 --> 34:11.000]  Потому что действие у него принципиально другое,
[34:11.000 --> 34:13.000]  там указатели переставлять надо.
[34:13.000 --> 34:15.000]  А почему нельзя бы просто reverse делать за вот единицы?
[34:15.000 --> 34:17.000]  Кстати, за какую симптотику reverse работает?
[34:19.000 --> 34:21.000]  Можно сделать за вот единицы,
[34:21.000 --> 34:23.000]  просто, казалось бы, свопнув вот эти два указательных.
[34:23.000 --> 34:25.000]  Просто считаем, что начало списка тут, а конец тут.
[34:25.000 --> 34:27.000]  Да.
[34:27.000 --> 34:29.000]  Но тогда у нас
[34:29.000 --> 34:31.000]  сломаются вот эти.
[34:31.000 --> 34:33.000]  И тогда нам надо либо хранить каждый раз флаг,
[34:33.000 --> 34:35.000]  у нас reverse нет лист или нет,
[34:35.000 --> 34:37.000]  а если потом кусок листа будет вырезан
[34:37.000 --> 34:39.000]  и всклеен в другой, то все, до свидания.
[34:39.000 --> 34:41.000]  В общем, нет, reverse за вот единицы не получится.
[34:43.000 --> 34:45.000]  В общем,
[34:45.000 --> 34:47.000]  можно заменить еще это на указатели
[34:47.000 --> 34:49.000]  на члены, как я вам рассказывал в первом семестре, но нет.
[34:49.000 --> 34:51.000]  В общем, reverse приходится за линию делать.
[34:51.000 --> 34:53.000]  И какой-то еще метод merge,
[34:53.000 --> 34:55.000]  по-моему, слияние списков.
[34:57.000 --> 34:59.000]  Да.
[35:01.000 --> 35:03.000]  Что такое глобальный бул?
[35:05.000 --> 35:07.000]  Поле бул?
[35:07.000 --> 35:09.000]  Когда
[35:09.000 --> 35:11.000]  ты берешь итератор
[35:11.000 --> 35:13.000]  на лист и инкрементируешь итератор,
[35:13.000 --> 35:15.000]  откуда ты будешь узнавать
[35:15.000 --> 35:17.000]  лист reverse-нутый или нет?
[35:17.000 --> 35:19.000]  У тебя есть
[35:19.000 --> 35:21.000]  итератор, в нем хранится указатель
[35:21.000 --> 35:23.000]  на base-note, ты делаешь
[35:23.000 --> 35:25.000]  плюс-плюс итератора. Как итератор будет понимать?
[35:25.000 --> 35:27.000]  Нужно next брать или pref у той вершины,
[35:27.000 --> 35:29.000]  на которую он указывает?
[35:29.000 --> 35:31.000]  В итераторе хранить ссылку на лист?
[35:31.000 --> 35:33.000]  Нет, зачем?
[35:33.000 --> 35:35.000]  Ну, тогда
[35:35.000 --> 35:37.000]  может быть, это дешево.
[35:37.000 --> 35:39.000]  Нет, не надо так делать.
[35:39.000 --> 35:41.000]  Нет, в итераторе хранить ссылку на
[35:41.000 --> 35:43.000]  лист не надо.
[35:43.000 --> 35:45.000]  Тем более,
[35:45.000 --> 35:47.000]  я напоминаю, что итератор может
[35:47.000 --> 35:49.000]  пережить лист.
[35:49.000 --> 35:51.000]  Вершина может быть вырезана из одного листа
[35:51.000 --> 35:53.000]  и вклеена в другой.
[35:53.000 --> 35:55.000]  А итератор на нее
[35:55.000 --> 35:57.000]  должен продолжать быть валидным.
[35:57.000 --> 35:59.000]  Нет,
[35:59.000 --> 36:01.000]  ты же когда это делаешь,
[36:01.000 --> 36:03.000]  ты же всем...
[36:03.000 --> 36:05.000]  Я завел итератор на эту вершину
[36:05.000 --> 36:07.000]  и сохранил его где-то, потом
[36:07.000 --> 36:09.000]  сделал splice, как я вот этот итератор
[36:09.000 --> 36:11.000]  куда-то вне сохраненный
[36:11.000 --> 36:13.000]  изменю.
[36:15.000 --> 36:17.000]  Я завел примерную. Итератор
[36:17.000 --> 36:19.000]  бла-бла-бла равно вот указатель
[36:19.000 --> 36:21.000]  на это. Отлично.
[36:21.000 --> 36:23.000]  Потом листу вызываю splice.
[36:23.000 --> 36:25.000]  Потом обращаюсь по этому итератору.
[36:25.000 --> 36:27.000]  Что произойдет?
[36:27.000 --> 36:29.000]  Откуда в этом
[36:29.000 --> 36:31.000]  итераторе хранится ссылка уже на
[36:31.000 --> 36:33.000]  битый лист?
[36:33.000 --> 36:35.000]  Этот-то итератор уже не изменился.
[36:35.000 --> 36:37.000]  Как бы он изменился, если ты в нем хранишь ссылку
[36:37.000 --> 36:39.000]  на лист? Тот лист уже стал
[36:39.000 --> 36:41.000]  другим.
[36:41.000 --> 36:43.000]  Все.
[36:43.000 --> 36:45.000]  Есть еще forward list.
[36:45.000 --> 36:47.000]  Что такое forward list?
[36:47.000 --> 36:49.000]  Это как лист, только односвязанный.
[36:49.000 --> 36:51.000]  Вот forward list довольно странный
[36:51.000 --> 36:53.000]  контейнер.
[36:53.000 --> 36:55.000]  В нем нет очень многого.
[36:55.000 --> 36:57.000]  Например, в нем, если я правильно помню, нет
[36:57.000 --> 36:59.000]  метода size. Если вы только не добавили,
[36:59.000 --> 37:01.000]  проверьте, что его нет.
[37:03.000 --> 37:05.000]  Forward list это минималистичный
[37:05.000 --> 37:07.000]  до предела лист,
[37:07.000 --> 37:09.000]  который можно только pushFront
[37:09.000 --> 37:11.000]  и popFront делать.
[37:11.000 --> 37:13.000]  У него нет
[37:13.000 --> 37:15.000]  указателя на последний...
[37:15.000 --> 37:17.000]  Вы не можете
[37:17.000 --> 37:19.000]  делать
[37:19.000 --> 37:21.000]  минус-минус и вы не можете класть в конец.
[37:21.000 --> 37:23.000]  Этот лист хранит
[37:23.000 --> 37:25.000]  только...
[37:25.000 --> 37:27.000]  У него есть maxSize.
[37:27.000 --> 37:29.000]  MaxSize это у
[37:29.000 --> 37:31.000]  всех контейнеров есть. Это сколько
[37:31.000 --> 37:33.000]  максимально теоретически вам позволяет
[37:33.000 --> 37:35.000]  система в контейнер положить. Я, честно
[37:35.000 --> 37:37.000]  говоря, не очень знаю откуда берется это число.
[37:37.000 --> 37:39.000]  Сейчас у него еще есть
[37:39.000 --> 37:41.000]  этот resize.
[37:41.000 --> 37:43.000]  Ну resize понятно.
[37:43.000 --> 37:45.000]  Это вы просто за o от n кладете
[37:45.000 --> 37:47.000]  ровно столько элементов, инициализируя их
[37:47.000 --> 37:49.000]  нужными значениями.
[37:49.000 --> 37:51.000]  Вот.
[37:51.000 --> 37:53.000]  Хорошо.
[37:53.000 --> 37:55.000]  У forward
[37:55.000 --> 37:57.000]  листа конечно же forward
[37:57.000 --> 37:59.000]  итераторы.
[37:59.000 --> 38:01.000]  Ну короче, можете сами посмотреть, что там есть.
[38:03.000 --> 38:05.000]  Так, есть ли вопросы про лист
[38:05.000 --> 38:07.000]  или forward-лист?
[38:09.000 --> 38:11.000]  Тогда map.
[38:11.000 --> 38:13.000]  У него maxSize
[38:13.000 --> 38:15.000]  1E15.
[38:15.000 --> 38:17.000]  Ну maxSize это
[38:17.000 --> 38:19.000]  я не очень сам... Я никогда не пользовался
[38:19.000 --> 38:21.000]  медным maxSize. Это метод
[38:21.000 --> 38:23.000]  нужный для проверки того
[38:23.000 --> 38:25.000]  сколько максимально теоретически
[38:25.000 --> 38:27.000]  вы можете в данной конфигурации
[38:27.000 --> 38:29.000]  положить элементов в лист. Я не очень
[38:29.000 --> 38:31.000]  знаю откуда берется это число.
[38:35.000 --> 38:37.000]  Следующий пункт
[38:37.000 --> 38:39.000]  это map.
[38:41.000 --> 38:43.000]  Ассоциативные контейнеры
[38:43.000 --> 38:45.000]  и первый из них это
[38:45.000 --> 38:47.000]  std map.
[38:47.000 --> 38:49.000]  Так мы вроде для листа
[38:49.000 --> 38:51.000]  локатора еще не изучили.
[38:51.000 --> 38:53.000]  Нет, не изучили.
[38:53.000 --> 38:55.000]  И не будем пока.
[38:55.000 --> 38:57.000]  Локатор
[38:57.000 --> 38:59.000]  отдельная тема, на которую мы две пары
[38:59.000 --> 39:01.000]  потратим.
[39:01.000 --> 39:03.000]  Я ничего не говорил.
[39:03.000 --> 39:05.000]  То есть мы изучили листы?
[39:05.000 --> 39:07.000]  Мы изучили лист, да.
[39:07.000 --> 39:09.000]  Мы еще ему в семантику не изучили.
[39:09.000 --> 39:11.000]  Мы еще и выравнивание. Знаешь, сколько всего для листа
[39:11.000 --> 39:13.000]  еще не изучили. Мы еще о-хо-хо не изучили.
[39:13.000 --> 39:15.000]  Мы как бы...
[39:15.000 --> 39:17.000]  Мы не претендуем написать лист сразу в версии
[39:17.000 --> 39:19.000]  как он в STL реализован, знаешь ли.
[39:19.000 --> 39:21.000]  Там много есть проблем, которые мы еще не изучили.
[39:21.000 --> 39:23.000]  Но мы не пытаемся изучить их все
[39:23.000 --> 39:25.000]  сразу. std map мы теперь
[39:25.000 --> 39:27.000]  изучаем. А что такое
[39:27.000 --> 39:29.000]  std map вы наверняка знаете. Это
[39:29.000 --> 39:31.000]  красно-черное дерево. Это ассоциативный
[39:31.000 --> 39:33.000]  контейнер. Что он позволяет делать?
[39:33.000 --> 39:35.000]  Он позволяет, ну давайте вспоминать.
[39:35.000 --> 39:37.000]  Какие у него есть операции?
[39:37.000 --> 39:39.000]  Ну insert
[39:39.000 --> 39:41.000]  по
[39:41.000 --> 39:43.000]  value. Значит
[39:43.000 --> 39:45.000]  erase
[39:45.000 --> 39:47.000]  по значению
[39:47.000 --> 39:49.000]  или erase по итератору.
[39:53.000 --> 39:55.000]  Вот.
[39:55.000 --> 39:57.000]  Что еще можно делать с
[39:57.000 --> 39:59.000]  мэпом? Можно делать квадратные
[39:59.000 --> 40:01.000]  скобочки по ключу.
[40:01.000 --> 40:03.000]  Да. Кстати
[40:03.000 --> 40:05.000]  insert нужно не value
[40:05.000 --> 40:07.000]  делать, а пару k value.
[40:07.000 --> 40:09.000]  Потому что мы же
[40:09.000 --> 40:11.000]  мэп хранит пары ключ значения.
[40:11.000 --> 40:13.000]  Поэтому insert как бы
[40:13.000 --> 40:15.000]  мы делаем пару ключ значения.
[40:17.000 --> 40:19.000]  Вот. I erase мы делаем
[40:19.000 --> 40:21.000]  тоже по ключу.
[40:23.000 --> 40:25.000]  Квадратные скобочки
[40:25.000 --> 40:27.000]  по ключу.
[40:27.000 --> 40:29.000]  Давайте напишу оператор квадратной
[40:29.000 --> 40:31.000]  скобочки.
[40:35.000 --> 40:37.000]  Что еще?
[40:37.000 --> 40:39.000]  Push back, push front
[40:39.000 --> 40:41.000]  никакого нету. А, но есть еще
[40:41.000 --> 40:43.000]  find по ключу.
[40:45.000 --> 40:47.000]  По-моему еще есть lower bound.
[40:47.000 --> 40:49.000]  Ну да, еще есть lower bound, upper bound.
[40:53.000 --> 40:55.000]  Count. Ну я не буду перечислять
[40:55.000 --> 40:57.000]  все методы. Это слишком
[40:59.000 --> 41:01.000]  Да. Кажется, с то ли 17,
[41:01.000 --> 41:03.000]  то ли 20 добавили contains.
[41:03.000 --> 41:05.000]  Теперь можно не писать count, потому что
[41:05.000 --> 41:07.000]  как-то тупо. Вот. Потому что
[41:07.000 --> 41:09.000]  в мэпе
[41:09.000 --> 41:11.000]  может быть
[41:11.000 --> 41:13.000]  только один элемент с уникальным ключом.
[41:13.000 --> 41:15.000]  Тихо.
[41:15.000 --> 41:17.000]  В мэпе может быть только один элемент с уникальным ключом.
[41:17.000 --> 41:19.000]  Вот. Что происходит, когда
[41:19.000 --> 41:21.000]  вы добавляете
[41:21.000 --> 41:23.000]  Ну, это понятно,
[41:23.000 --> 41:25.000]  что делает. Что такое erase по ключу?
[41:25.000 --> 41:27.000]  Он находит элемент по этому ключу,
[41:27.000 --> 41:29.000]  и если он есть, то удаляет его,
[41:29.000 --> 41:31.000]  а если нет, то возвращает
[41:31.000 --> 41:33.000]  вам, ну, ничего не делает,
[41:33.000 --> 41:35.000]  а вам возвращает он
[41:35.000 --> 41:37.000]  пару,
[41:37.000 --> 41:39.000]  вот что insert, что erase.
[41:39.000 --> 41:41.000]  Он возвращает вам пару,
[41:41.000 --> 41:43.000]  в которые первый элемент от итератора,
[41:43.000 --> 41:45.000]  второй элемент bool.
[41:45.000 --> 41:47.000]  Если я ничего не путаю.
[41:47.000 --> 41:49.000]  Ну в insert, по крайней мере, точно.
[41:49.000 --> 41:51.000]  Первый элемент
[41:51.000 --> 41:53.000]  от итератора, который вам говорит, куда
[41:53.000 --> 41:55.000]  был вставлен в итоге этот элемент,
[41:55.000 --> 41:57.000]  а bool был ли он вставлен,
[41:57.000 --> 41:59.000]  а почему он может не быть вставлен,
[41:59.000 --> 42:01.000]  потому что такой уже был с таким ключом.
[42:01.000 --> 42:03.000]  Вот.
[42:03.000 --> 42:05.000]  А там возвращается типа false, да,
[42:05.000 --> 42:07.000]  если он поменял значение?
[42:07.000 --> 42:09.000]  Нет, он не поменяет значение. Если элемент с таким ключом уже был,
[42:09.000 --> 42:11.000]  то он ничего не сделает
[42:11.000 --> 42:13.000]  и вернет вам вторым элементом пары false,
[42:13.000 --> 42:15.000]  а первым элементом не определено, что.
[42:15.000 --> 42:17.000]  Или определено, но я не помню,
[42:17.000 --> 42:19.000]  потому что не нужно прольтиваться этим.
[42:19.000 --> 42:21.000]  А этот, по-моему, вам возвращает
[42:21.000 --> 42:23.000]  пару итератор bool, где второй элемент опять
[42:23.000 --> 42:25.000]  говорит, был ли такой элемент,
[42:25.000 --> 42:27.000]  а первым элементом
[42:27.000 --> 42:29.000]  дает вам итератор на следующий за ним.
[42:29.000 --> 42:31.000]  А erase с кейними, разве не все значения
[42:31.000 --> 42:33.000]  с ключом кейни?
[42:33.000 --> 42:35.000]  Такое только одно может быть.
[42:35.000 --> 42:37.000]  В мэпе, я же говорю.
[42:37.000 --> 42:39.000]  Есть multimap,
[42:39.000 --> 42:41.000]  но в нем все хуже.
[42:41.000 --> 42:43.000]  Я даже не помню,
[42:43.000 --> 42:45.000]  если там erase по ключу,
[42:45.000 --> 42:47.000]  разве что erase по итератору
[42:47.000 --> 42:49.000]  и по диапазону.
[42:49.000 --> 42:51.000]  А, ну хорошо, да, ладно.
[42:55.000 --> 42:57.000]  Erase по итератору
[42:59.000 --> 43:01.000]  понятно, что делает.
[43:01.000 --> 43:03.000]  Оператор квадратной скобочки,
[43:03.000 --> 43:05.000]  что делает?
[43:05.000 --> 43:07.000]  Дает вам ссылку на value.
[43:07.000 --> 43:09.000]  То есть,
[43:09.000 --> 43:11.000]  оператор квадратной скобочки
[43:11.000 --> 43:13.000]  дает вам ссылку
[43:13.000 --> 43:15.000]  на значение, соответствующее этому ключу.
[43:15.000 --> 43:17.000]  Вот, тонкий момент.
[43:17.000 --> 43:19.000]  А что, если вы обращаетесь
[43:19.000 --> 43:21.000]  к квадратным скобочкам по ключу,
[43:21.000 --> 43:23.000]  которого нет?
[43:23.000 --> 43:25.000]  Да, вот это очень интересная особенность мэпа,
[43:25.000 --> 43:27.000]  что когда вы обращаетесь к квадратным скобочкам
[43:27.000 --> 43:29.000]  по ключу, которого нет,
[43:29.000 --> 43:31.000]  то вы не получаете UB как в векторе.
[43:31.000 --> 43:33.000]  А было бы прикольно, правда?
[43:33.000 --> 43:35.000]  А вместо этого
[43:35.000 --> 43:37.000]  создается элемент со значением value
[43:37.000 --> 43:39.000]  по умолчанию
[43:39.000 --> 43:41.000]  и возвращается ссылка на него.
[43:41.000 --> 43:43.000]  А что будет, если у value нет конструктора
[43:43.000 --> 43:45.000]  по умолчанию?
[43:47.000 --> 43:49.000]  Ты меня
[43:49.000 --> 43:51.000]  расстраиваешь. Ты такие вещи говоришь,
[43:51.000 --> 43:53.000]  что плохо.
[43:53.000 --> 43:55.000]  CE будет.
[43:55.000 --> 43:57.000]  Какой exception?
[43:57.000 --> 43:59.000]  CE, потому что нет такого метода.
[43:59.000 --> 44:01.000]  Просто нельзя вызывать
[44:01.000 --> 44:03.000]  квадратные скобочки у
[44:03.000 --> 44:05.000]  мэпа, у которого
[44:05.000 --> 44:07.000]  value не имеет конструктора по умолчанию.
[44:07.000 --> 44:09.000]  То есть вообще даже если
[44:09.000 --> 44:11.000]  он не поймет...
[44:11.000 --> 44:13.000]  Вот, я не уверен, написано ли там
[44:13.000 --> 44:15.000]  это под и в constexpr. Возможно написано.
[44:15.000 --> 44:17.000]  Но если такого ключа не будет,
[44:17.000 --> 44:19.000]  то это точно будет CE.
[44:19.000 --> 44:21.000]  А, правильно, это и будет CE,
[44:21.000 --> 44:23.000]  потому что он же не может в compile time
[44:23.000 --> 44:25.000]  проверить, есть такой ключ или нет.
[44:25.000 --> 44:27.000]  Поэтому это в любом случае CE.
[44:27.000 --> 44:29.000]  Понятно логика, да?
[44:33.000 --> 44:35.000]  Можно, только квадратные скобочки не будут работать.
[44:35.000 --> 44:37.000]  Значит, квадратные скобочки в мэпе
[44:37.000 --> 44:39.000]  они проверяют,
[44:39.000 --> 44:41.000]  есть ли такой элемент, если нет,
[44:41.000 --> 44:43.000]  то создают его по умолчанию.
[44:43.000 --> 44:45.000]  Но узнать, есть ли такой элемент, может только в run time.
[44:45.000 --> 44:47.000]  А значит, это не получится
[44:47.000 --> 44:49.000]  под и в constexpr загнать.
[44:49.000 --> 44:51.000]  А значит, у вас обязательно должен быть код,
[44:51.000 --> 44:53.000]  в котором вызывается конструктор по умолчанию
[44:53.000 --> 44:55.000]  на этапе компиляции должен компилироваться.
[44:55.000 --> 44:57.000]  А если значит его нет, то это будет CE.
[44:57.000 --> 44:59.000]  Поэтому квадратные скобочки в мэпе,
[44:59.000 --> 45:01.000]  у которого value не имеет конструктора по умолчанию,
[45:01.000 --> 45:03.000]  это CE.
[45:03.000 --> 45:04.440]  И nouvelle метод,
[45:04.440 --> 45:06.440]  есть add.
[45:08.440 --> 45:09.240]  А еще квадратные скобочки, это CE в константном контейнере,
[45:09.240 --> 45:10.760]  по той же причине.
[45:10.760 --> 45:14.760]  Квадратные скобочки это не константный метод,
[45:14.760 --> 45:16.760]  а если у вас мэп константный,
[45:16.760 --> 45:18.760]  то вы не можете вызывать у него квадратные скобочки,
[45:18.760 --> 45:20.760]  это CE.
[45:20.760 --> 45:22.760]  Потому, что квадратные скобочки,
[45:22.760 --> 45:24.760]  они потенциально меняют мэп.
[45:24.760 --> 45:26.760]  А значит это не константный метод,
[45:26.760 --> 45:28.760]  а константного аналога квадратных скобочек не существует.
[45:28.760 --> 45:30.760]  Можно иди в узкий вshaw if case?
[45:30.760 --> 45:32.760]  А у 인тalomShell there is constructor по умолчанию.
[45:32.760 --> 45:38.840]  там нет конструктора. Это не называется конструктор. Это называется default initialization.
[45:38.840 --> 45:58.000]  Вот. Нет. Там вызывается, ну, если написать вот так, то получится 0. Если написать просто int
[45:58.000 --> 46:03.720]  x, ну, это я про обычный код говорю в стеке. Если написать так, то это будет неопределенное
[46:03.720 --> 46:10.080]  значение. А если, если написать так, то будет 0, потому что это называется default initialization,
[46:10.080 --> 46:17.800]  это называется value initialization, по-моему. Если я ничего не путаю. Ну, короче, я не помню,
[46:17.800 --> 46:21.800]  как это формально называется, но суть в том, что если вы так напишете, будет 0. А там момент так
[46:21.800 --> 46:27.400]  описано, что t круглые скобочки. Ну, поэтому синтом это тоже так работает. Да, ну, синтом это
[46:27.400 --> 46:35.800]  тоже так работает. Int по умолчанию вы создаете. Ну да, если ты явно говоришь, что хочешь int
[46:35.800 --> 46:39.560]  пронициализировать дефолтным значением, то оно нулевое. Но если ты не говоришь ничего,
[46:39.560 --> 46:46.720]  то это это разные понятия. Так вот, есть метод add, как и в векторе.
[46:46.720 --> 46:56.680]  Я думаю, многие очень часто, когда тебе передают мэп по константной ссылке куда-нибудь,
[46:56.680 --> 47:09.520]  вот он и константный у тебя. Так, ну мы возвращаемся к вопросу, почему нужно принимать объекты,
[47:09.520 --> 47:14.280]  функцию по константной ссылке. Нет, я не готов возвращаться к этому разговору, это было очень
[47:14.400 --> 47:36.520]  давно. Мы уже должны к этому привыкнуть. Да, но зато можно использовать add. Что делает add? Он
[47:36.520 --> 47:41.560]  также вам возвращает ссылку на value, если такой элемент был, а если такого элемента не было,
[47:41.560 --> 47:52.240]  кидает исключение, конечно. Как и в векторе. Вот. И вот у add есть константный аналог. То есть add
[47:52.240 --> 47:56.040]  есть версия как для константного, так и для неконстантного мэпа. Если у вас мэп константный,
[47:56.040 --> 48:00.200]  или вы его приняли по константной ссылке, то вы не можете использовать квадратные скобочки,
[48:00.200 --> 48:07.760]  зато можете add использовать. А что такое find? Он находит элемент с таким ключом и возвращает
[48:07.760 --> 48:13.120]  итератор на него. А если не нашел, то возвращает end. Что такое lower bound? Он находит элемент с
[48:13.120 --> 48:19.040]  ключом. Значит, сейчас надо правильно сформулировать, не ошибиться. Первый элемент,
[48:19.040 --> 48:26.760]  у которого ключ больше или равен данного. И возвращает итератор на него, а если такого нет,
[48:26.760 --> 48:32.400]  то end. Upper bound это первый элемент, который строго больше данного, а если такого нет, то end.
[48:32.400 --> 48:39.960]  Я когда переопределял upper bound... Что ты переопределял upper bound? У кого? У стд мэпа?
[48:39.960 --> 48:47.880]  Нет, просто upper bound. Ничего не понял. Ты переопределял upper bound у upper bound?
[48:47.880 --> 48:53.400]  Нет, функция upper bound. А, стд upper bound в смысле из алгоритма?
[48:53.400 --> 48:56.800]  Он очень странно что-то делал. Кто, твой upper bound или тот,
[48:56.800 --> 49:04.240]  который ты переопределял? Я передавал туда лямбю функцию. Ага. Если я передавал lower bound,
[49:04.240 --> 49:09.680]  то он искал по ней. А если я передавал его upper bound, то... Вот я приравен стд upper bound.
[49:09.680 --> 49:17.440]  Чтобы приравен со значением true или false удавался. Короче, не знаю. Я не готов быстро на это ответить.
[49:17.440 --> 49:38.040]  Вот lower bound, upper bound. Вот. Все эти операции работают за... Одну и ту же асимптотику за какую?
[49:38.040 --> 49:46.960]  За гарантированный логорифм. Нет, за логорифм. А, и рейс по итератору за единицу. Да, вот это
[49:46.960 --> 49:53.520]  вот единица. Да, и рейс по итератору за еди... Что? Нет, минуточку. Нет, нет, нет, ты меня сбил.
[49:53.520 --> 50:00.640]  И рейс по итератору за... Потому что деревья поворота же делать надо. Это же... Это же удаление из красно-черного
[50:00.640 --> 50:07.160]  дерева. А, хотя нет, мы сейчас доказывали, что удаление от одного работает. Амортизировано.
[50:07.160 --> 50:14.720]  Из красно-черного дерева? Да, да. А, амортизировано за вот единицу. Потому что нам не надо спускаться,
[50:14.720 --> 50:29.000]  это можно учетом чейсь и инсерта, например. Так все, амортизировано. Сейчас. Еще раз, подожди,
[50:29.000 --> 50:33.680]  еще раз, почему и рейс за вот единица работает амортизированно по итератору? Потому что и рейс
[50:33.680 --> 50:42.680]  у нас сначала спускается. Спускается, чтобы найти. Да, а потом он поднимается и чинит, если не надо чинить.
[50:42.680 --> 50:49.880]  Да. Если мы сделаем поворот, то потом очень долго его... Но, кажется, там нужно сделать лишь
[50:49.880 --> 50:54.080]  константное число поворотов. Да, да, да. То есть, кажется, он все-таки за вот единицу будет работать.
[50:54.080 --> 50:58.560]  Нет, он не честный от единицы, потому что сначала нужно подняться до момента, когда мы делаем поворот, кажется.
[50:59.560 --> 51:04.640]  А, ну, то есть, все-таки лагари... То есть, там нужно константное число поворотов, но, возможно, лагарифмическое
[51:04.640 --> 51:09.680]  число подъемов. Короче, давайте я просто напишу, что это за работа за лагарифом, и не буду уточнить. Это
[51:09.680 --> 51:18.200]  точно верно. Вот это точно верно. Ну, и рейс по ключу, понятно, работает точно за лагарифом, а это,
[51:18.200 --> 51:28.240]  может быть, как-то можно лучше оценить, но мы не будем. Вот, это отличный вопрос. Давайте его
[51:28.240 --> 51:39.200]  как раз и обсудим. А как работает инкремент итераторов в мэпе и в сете? Да, что? Это написано на
[51:39.200 --> 51:55.680]  себе переференс. А, ну, хорошо, ладно. Давайте обсудим, как работает дикремент, инкремент...
[51:58.240 --> 52:06.800]  итератора. Вот, проблема в том, что инкремент итератора может в худшем случае работать лагарифом.
[52:06.800 --> 52:13.320]  Такая проблемка. Вы инкрементируете итератор, а это лагарифом времени занимает, потому что...
[52:13.320 --> 52:29.400]  Вот, тем не менее, проход по всему мэпу от начала до конца работает за линейное время от размера
[52:29.400 --> 52:35.920]  мэпа. Вот стандарт не предъявляет требований на то, чтобы инкремент отдельного итератора был
[52:35.920 --> 52:40.120]  быстрый, потому что он относительно быстрый. Инкремент отдельного итератора может занимать
[52:40.120 --> 52:47.000]  лагарифом. Но обязательно проход по всему мэпу должен работать линейное время относительно
[52:47.000 --> 52:50.840]  размера мэпа, если вы пробегаетесь. А инкремент, это следующий получается по возрастанию?
[52:50.840 --> 52:55.960]  Следующий по возрастанию. Да, конечно же, ключи хранятся в порядке возрастания. И поддерживается
[52:55.960 --> 53:03.440]  упорядоченная структура дерева красно-черного, когда мы, значит, туда что-то кладем. Почему
[53:03.440 --> 53:13.400]  проход итератором всего мэпа работает за линейное время от размера мэпа? Потому что каждую вершину
[53:13.400 --> 53:19.880]  мы посещаем... Ну, потому что в каждую вершину мы один раз заходим, один раз выходим по каждому
[53:19.880 --> 53:28.200]  из ребер, которые в нее ведут, так попросту говоря. То есть там это 6 умножить на количество элементов,
[53:28.200 --> 53:37.440]  в худшем случае. Да, значит, еще раз, мы обходим дерево поиска от начала до конца, от меньшего
[53:37.440 --> 53:44.280]  ключа к большему. Но в каждую вершину мы входим и выходим ровно по три раза суммарно. Ну, значит,
[53:44.280 --> 53:50.880]  суммарно мы линейное по количеству вершин число операции проделываем для того, чтобы обойти все
[53:50.880 --> 53:57.000]  дерево. Хотя отдельный инкремент итератора может занимать лагарифмическое время, если мы там,
[53:57.000 --> 54:02.640]  если нам нужно вот с самой правой вершины левого под дерево попасть в самую левую вершину правого
[54:02.640 --> 54:07.440]  под дерево, то нам придется подняться по всей этой дороге, а потом спуститься вот сюда. Это один
[54:07.440 --> 54:16.200]  инкремент итератора будет столько времени занимать. Зато мэп, как и лист, не инвалидирует итераторы
[54:16.200 --> 54:26.280]  никогда. Как и указатели и ссылки. Потому что все хранится в нодах и ноды никогда никуда не
[54:26.280 --> 54:31.040]  перекладываются. То есть на них могут переставляться указатели при поворотах дерева. Вот это очень важно
[54:31.040 --> 54:38.440]  понимать. Это некоторые путаются, когда так не очень, значит, хорошо себе представлять, что происходит.
[54:38.440 --> 54:44.000]  В мэпе, кстати, по-моему, кто-то из вас мне заявлял тут еще в конце первого семестра, что в мэпе все
[54:44.320 --> 54:53.360]  ломается при итераторы, если что-то там делается. Нет, указатели тоже не ломаются. Ни указатели,
[54:53.360 --> 54:58.760]  ни ссылки, ни итераторы не инвалидируются ни при вставке, ни при удалении из мэпа, да. Потому
[54:58.760 --> 55:05.360]  что никто не перекладывает никуда вершины. Вершины лежат, они выделены один раз и все. Все,
[55:05.360 --> 55:10.360]  что происходит, что такое повороты красно-черного дерева на самом деле, это просто перестановка
[55:10.360 --> 55:14.640]  каких-то указателей внутри дерева. Но сами вершины, они остаются в памяти по тем же адресам,
[55:14.640 --> 55:24.320]  по которым мы были. Просто переставляются указатели друг на дружку. Да, я именно это и хочу
[55:24.320 --> 55:37.600]  сказать. Открой себе переференс. Если ты обходишь с этой параллельной, ты получишь странные
[55:37.600 --> 55:44.800]  результаты. Это мы уже обсуждали. Но у тебя ничто не инвалидируется в процессе. Ты получишь
[55:44.800 --> 55:50.400]  странный результат, потому что у тебя столько того дерева меняется. Да. Нет, ну короче, окей. Но
[55:50.400 --> 55:56.280]  это просто не работает. Все, хорошо. Это работает просто странно. Нет, просто не так, как ты
[55:56.280 --> 56:01.720]  ожидаешь. Инвалидация значит, что если ты завел указатель в ссылку или итератор на элемент сета,
[56:01.720 --> 56:06.800]  а потом что-то повставлял в этот сет, то что бы ты там не вставлял или не удалял из сета,
[56:06.800 --> 56:10.720]  кроме этого собственного элемента, твои указатели или ссылка или итератор будут указывать на ту же
[56:10.720 --> 56:21.480]  вершину, что и раньше после всего этого. Вот. Но если ты это делаешь в алгоритме, что? Да. Нам
[56:21.480 --> 56:27.160]  снова пригодится этот трюк. Сейчас увидите почему. Потому что нам нужно энд поддержать. Опять,
[56:27.160 --> 56:34.600]  собственно, опять поэтому. Ну давайте обсудим, как это реализовано. Что хранится в мэпе на самом
[56:34.600 --> 56:45.480]  деле. А, еще одна важная деталь, которую я забыл. А у мэпа есть еще одна интересная штука. Это
[56:45.480 --> 57:08.160]  компаратор. Вот, когда я пишу тимплейт type name t, во-первых, там type name key, type name value и type
[57:08.160 --> 57:22.480]  name, ну давайте назову cmp, который по умолчанию равен std less от key. На самом деле там еще есть
[57:22.480 --> 57:29.360]  значит четвертый параметр локатор, но локатор мы пока не обсуждаем. А компаратор у мэпа есть,
[57:29.360 --> 57:33.840]  как шаблонный параметр. Что это такое? Это функция, с помощью которой он сравнивает ключи. Ну как он
[57:33.840 --> 57:38.800]  понимает кто меньше. Вот ключи он должен уметь сравнивать. Значит у ключей должен быть определен
[57:38.800 --> 57:49.720]  оператор меньше. Либо вы должны передать кастомный компаратор вместо std less. Лист он не упорядоченный.
[57:49.720 --> 57:57.040]  Ну если вы вызовете sort у листа, то тогда уже должен быть. Ну как? Сам лист не требует компаратор
[57:57.040 --> 58:02.040]  для того, чтобы лист создать. Ну метод sort требует компаратора. Точно так же, как оператор квадратной
[58:02.040 --> 58:17.160]  скобочки требует конструктор по умолчанию. Хотя сам мэп не требует. Что создается? Допустим я могу
[58:17.160 --> 58:26.400]  создать лист от объекта без компаратора, если я нигде не вызываю sort. Конечно, можешь. Потому что
[58:26.400 --> 58:34.880]  нигде в коде листа не вызывается компаратор. Потому что тела не инстанцируются. Инстанцируются только
[58:34.880 --> 58:47.360]  объявления. А да, мы про это поговорим поподробнее ближе к концу, когда будем шаблонное метапрограммирование
[58:47.360 --> 58:55.520]  изучать. В смысле, да, у вас ленивое инстанцирование. Если вы инстанцируете класс, то инстанцируется только
[58:55.520 --> 58:59.960]  объявления методов, а определение не инстанцируется, пока вы их не начнете использовать. Это правда.
[58:59.960 --> 59:15.200]  А есть один вопрос. Да. Почему тут ЦМП и тайтнейм? Что значит нельзя функцию? А куда передавать
[59:15.200 --> 59:25.440]  функцию? Что ты предлагаешь здесь написать вместо тайтнейм? Напоминаю, параметры мэшаблона
[59:25.440 --> 59:32.360]  могут быть типы, числа, а также другие шаблоны. Что ты предлагаешь здесь написать? Ну, начиная с
[59:32.360 --> 59:40.640]  C++20 еще кое-что, но мы пока про это не говорим. Указатель там нельзя? Нет. Ну, указатель на функцию. Нет,
[59:40.640 --> 59:49.080]  нельзя. Ну, начиная с C++20, там стало можно много чего. Может быть даже указатель, я не помню. Но нет,
[59:49.080 --> 01:00:01.920]  нельзя пока что. До C++20 по крайней мере нельзя. В смысле, ты хочешь, чтобы функция была константой
[01:00:01.920 --> 01:00:10.200]  времени компиляции? Ты понимаешь, что ты просишь? Ты точно уверен в своем желании? Будь аккуратен со
[01:00:10.200 --> 01:00:17.880]  своими желаниями. Указатель, то, что ты, то, что ты передаешь в шаблон, должно быть константой
[01:00:17.880 --> 01:00:22.560]  времени компиляции. Если ты делаешь параметром шаблона указатель, этот указатель должен быть,
[01:00:22.560 --> 01:00:30.520]  как число захардкожен в шаблон еще в моменте компиляции. И ты хардкодишь указатель на область
[01:00:30.520 --> 01:00:34.280]  памяти в процессе компиляции, то есть ты еще компилируешь и знаешь, какой будет адрес этой функции.
[01:00:34.280 --> 01:00:41.640]  Параметрами шаблонов указатель не могут быть, потому что это абсурд, ну, потому что нельзя в
[01:00:41.640 --> 01:00:54.240]  compile-time знать, каким будет указатель. Нет, нельзя, потому что разыменование указателя так не работает.
[01:00:54.240 --> 01:01:01.720]  Ну, как указатель, это runtime-концепция. Вы в runtime-е проходите в какую-то ячейку памяти и там
[01:01:01.720 --> 01:01:08.840]  смотрите, что лежит. А если вы в compile-time-е хотите захардкодить указатель, это очень странно. Но ты
[01:01:08.840 --> 01:01:13.800]  можешь, подожди, ты можешь передать функцию в качестве, ты понимаешь, что ты опять путаешь,
[01:01:13.800 --> 01:01:24.640]  а на это была задача в зачете предпоследнее, там надо было написать, что там, из, не помню. Там
[01:01:24.640 --> 01:01:31.080]  была именно эта ошибка, мало кто исправил, не все. Надо было вместо int написать type name,
[01:01:31.080 --> 01:01:34.800]  чтобы все заработало, если вы помните. Во втором варианте была такая проблема, да и в первом,
[01:01:34.800 --> 01:01:39.360]  по-моему, была. Вот это тот самый вопрос, который ты сейчас задаешь, потому что если передать число
[01:01:39.360 --> 01:01:46.920]  или указатель, это бред какой-то. Ты можешь передать указатель на функцию в качестве компаратора,
[01:01:46.920 --> 01:01:54.800]  просто это будет type name и тип будет указателем на функцию, а не сам указатель на функцию ты
[01:01:54.800 --> 01:02:04.360]  хардкодишь как константу. Ну начинай с 20, я думаю. Ну начинай с 20, там стало много чего,
[01:02:04.360 --> 01:02:10.720]  можно, там и строки можно, но мы не будем сейчас об этом. Вот, я пока говорю только про нормальный,
[01:02:10.720 --> 01:02:20.400]  плюсы здорового человека. Давай потом мы с тобой это обсудим, потому что иначе это надолго. Да.
[01:02:20.400 --> 01:02:45.200]  Чего? Нет, не понял. Слушайте, давайте может после пары, потому что сейчас мы, я пока отвечаю на ваши
[01:02:45.200 --> 01:02:51.440]  вопросы, у нас пара закончится, а мы еще не успели мэп обсудить. Давайте все-таки поговорим о том,
[01:02:51.440 --> 01:03:02.480]  что в мэпе находится. Вот class map. В нем опять есть внутренняя структура node. Да, ну мы уже умные,
[01:03:02.480 --> 01:03:14.320]  давайте мы сразу напишем base node. Что лежит в base node? Ой. Что лежит в base node? Там должен лежать,
[01:03:14.320 --> 01:03:22.520]  собственно, ну да, там должен быть, значит, base node left,
[01:03:22.520 --> 01:03:43.920]  левый сын, base node правый сын и base node звездочка parent. Parent нужен, потому что,
[01:03:43.920 --> 01:03:48.840]  когда у вас будет итератор, вы должны инкрементировать его уметь. Как вы будете
[01:03:48.840 --> 01:04:05.600]  это делать? А что тогда ты в итераторе будешь хранить? Указатель на начало или что? На какую? Ну,
[01:04:05.600 --> 01:04:12.160]  в итераторе у тебя будет храниться указатель на саму вершину. Как инкрементировать итератор
[01:04:12.160 --> 01:04:17.240]  тогда? Вот у тебя данный итератор сверху, что такое верх? Подожди, подожди, что такое, тихо,
[01:04:17.240 --> 01:04:26.880]  что такое верх? Что такое корень? У тебя в итераторе хранится указатель на твою вершину. Ты не знаешь
[01:04:26.880 --> 01:04:30.880]  корня и он мог поменяться, ты ему не можешь его даже сохранить в итераторе, потому что он мог
[01:04:30.880 --> 01:04:38.280]  поменяться, пока ты, пока твой итератор не... Ну, мы уже обсуждали почему это плохо, потому что у тебя
[01:04:38.280 --> 01:04:52.080]  вершину, ну нет, из мэпа конечно нельзя вырезать, из мэпа вырезать. Нет, нет, давайте, сразу нет,
[01:04:52.080 --> 01:05:02.400]  все, давайте нет. Что еще хранить? Блин, то что ты предлагаешь, это уже, мне проще родители сохранить,
[01:05:02.400 --> 01:05:09.600]  нет, вот вам так не кажется? А алгоритмы как раз обсуждали подробно, ну не очень подробно, но обсуждали,
[01:05:09.600 --> 01:05:18.040]  что можно сделать, если не иметь родители. Ну, мы хотели хранить в состоянии DFS, ну как бы у нас есть итератор,
[01:05:18.040 --> 01:05:23.680]  и мы можем в нем хранить текущие состояния DFS. Ну, в общем, вроде у нас получилось там,
[01:05:23.680 --> 01:05:38.240]  но кажется, можно сделать, я верю, что это теоретически возможно, но кажется,
[01:05:38.240 --> 01:05:50.360]  что это не стоит того, чтобы этим заниматься в STD-мэпе. Еще что надо? Да, но он может быть бул просто.
[01:05:53.680 --> 01:06:12.160]  Чего? Чего? В смысле, у меня два всего значения, я говорил, что енам надо, когда у вас больше двух их,
[01:06:12.160 --> 01:06:21.400]  а у меня их два всего. Нет, я, бул из позитив как раз нормально, вот бул сайн это плохо,
[01:06:21.400 --> 01:06:27.000]  потому что что такое true непонятно. Бул из позитив это нормально, потому что он всего два значения
[01:06:27.000 --> 01:06:32.040]  принимает и отвечает на понятный вопрос. Точно так же бул красная вершина или нет, но если не красная,
[01:06:32.040 --> 01:06:46.120]  то понятно какая. Ну нет, можно просто red, потому что empty у вас же не из empty. Чего? Что значит в
[01:06:46.120 --> 01:07:01.160]  указатель зашить? А, типа сюда последним битиком, чтобы 8, что это есть? А что вы еще на алгосах делаете,
[01:07:01.160 --> 01:07:07.320]  мне интересно, я просто какие-то новые открытия делаю. Мне кажется, раньше Филипп таким не занимался,
[01:07:07.320 --> 01:07:20.280]  он мне кажется изменился за годы преподавания. Нет, ну просто нет, ничего плохого, просто это
[01:07:20.280 --> 01:07:26.040]  казалось бы вопрос уже плюсовой реализации, то есть понятно, что можно битиком запихнуть в указатель,
[01:07:26.040 --> 01:07:35.800]  но казалось бы это не вопрос алгоритмов, но это понятно, что может. Да, чего? Ну можно, да. Что,
[01:07:35.800 --> 01:07:45.160]  хочешь big integer переделать? Так, подожди, так, смотрите, теперь я говорю struct node,
[01:07:45.160 --> 01:07:59.560]  наследница base node, и в ней лежит что еще дополнительно? В ней лежит пара k-value. Почему
[01:07:59.560 --> 01:08:07.000]  пара? Потому что у вас разыменование итератора должно давать mstd pair именно k-value,
[01:08:07.000 --> 01:08:11.520]  поэтому вы и в структуре должны хранить пару k-value, чтобы не создавать ее каждый раз заново.
[01:08:11.520 --> 01:08:17.120]  Вы именно объект пара k-value храните, не отдельно k-value, а пару k-value.
[01:08:17.120 --> 01:08:36.220]  В плюсах и map и set и multi-map и multi-set это все наследники каких-то стрёмных классов,
[01:08:36.220 --> 01:08:44.160]  которые реализованы в других файлах в bits slash что-то там, strb3.h, и вот там, короче,
[01:08:44.960 --> 01:08:52.200]  с определенными юзингами они называются map, set и так далее. Так не работает, что map это
[01:08:52.200 --> 01:09:05.840]  прям вот map нет, это все через другие внутренние классы реализовано. Так, ну стд pair, понятное дело.
[01:09:15.040 --> 01:09:30.080]  Что значит в вершине, а мы где храним? Ну фейковая вершина у нас тоже может быть,
[01:09:30.080 --> 01:09:38.000]  что у нас фейковой вершины это такие вот эти вот нил листочки. Короче, это детали,
[01:09:38.000 --> 01:09:47.600]  это не интересно. Давайте существенные вещи обсуждаем. Как реализовать end? Ну да,
[01:09:47.600 --> 01:09:53.480]  как работает begin? Вот у мэпа есть метод begin, begin возвращает указатель, ну итератор на
[01:09:53.480 --> 01:10:04.880]  начальный элемент мэпа, на наименьший. Как он работает, откуда он берет begin? То есть мэп
[01:10:04.880 --> 01:10:16.720]  хранит, вы предлагаете хранить корень и идти вниз, чтобы получить begin. Вот, я думаю begin
[01:10:16.720 --> 01:10:24.800]  обязан работать вот еници, да, или что? Это ты прочитал или ты знаешь это? Я просто не помню сам,
[01:10:24.800 --> 01:10:30.000]  он обязан или не обязан, но если обязан, то нам надо просто хранить самого левого сына, понятно?
[01:10:30.000 --> 01:10:39.400]  Когда вы изучали? Где? Без меня, да? А я думал, мы сегодня изучать будем.
[01:11:00.000 --> 01:11:06.960]  Ну я сейчас примерно что-то похожее хотел бы сказать, то есть что такое begin? Ну begin это,
[01:11:06.960 --> 01:11:15.440]  ну мы хотим хранить begin как самого левого сына, да, или ну давайте пока считать, что begin это
[01:11:15.440 --> 01:11:20.560]  просто самый левый сын честный. Вот, что такое end тогда? end это должен быть опять,
[01:11:21.040 --> 01:11:30.160]  какая-то фейковая вершина правее всех, больше всех наших. Ну давайте сделаем фейкового,
[01:11:30.160 --> 01:11:38.560]  то есть давайте, что сделаем? Вот у нас есть дерево, давайте ему сделаем,
[01:11:38.560 --> 01:12:05.320]  кстати, вот это правильное замечание, они наверное относительно операции на t опять считают
[01:12:05.320 --> 01:12:14.480]  количество. Спускай, да, это как с деком проблема. Смотрите, как нам end организовать,
[01:12:14.480 --> 01:12:20.920]  давайте сделаем, что фейковый корень видимо, ну то есть мы, нет, даже не фейковый корень,
[01:12:20.920 --> 01:12:27.200]  мы сделаем фейковый корень и все реальное дерево будет фейковое дно.
[01:12:35.320 --> 01:12:46.680]  Не, то, что там внизу какие-то фейковые листья, это не очень удобно. Удобнее в качестве end
[01:12:46.680 --> 01:12:58.560]  сохранить просто фейковый корень и все. Мы просто забиваем, мы поддерживаем вот только
[01:12:58.560 --> 01:13:07.480]  здесь структуру, а на это просто забиваем, я думаю. Я понимаю, да, но мы можем забить и
[01:13:07.480 --> 01:13:14.080]  поддерживать у человека красно-черное дерево только вот для вот этого поддерева, просто при поворотах,
[01:13:14.080 --> 01:13:17.680]  зачем нам поддерживать для фейкового корня. Мы просто знаем, что у нас фейковый корень и он end,
[01:13:17.680 --> 01:13:27.120]  а условия красно-черного дерева только для вот этого поддерева поддерживаем. Вот, и декремент
[01:13:27.120 --> 01:13:41.840]  end дает нам крайнего правого сына. Вот, и последнее. Ну как в тупую? Это не то, чтобы в тупую.
[01:13:41.840 --> 01:13:51.280]  End это мы, для шип энд работал, мы заводим фейковую вершину и делаем ее фейковым корнем. Кого?
[01:13:51.280 --> 01:14:02.600]  End мы делаем за единицу, у нас фейковый корень. End это фейковый корень. А Begin мы можем хранить,
[01:14:02.600 --> 01:14:07.080]  и тогда будет завод единицы, а можем делать за логарифом. Я не знаю, честно говоря, это сделано.
[01:14:07.080 --> 01:14:29.920]  Чего? Я понимаю, да. А вопрос-то в чем? Кто сказал, что end-минус-минус, это вот единицы.
[01:14:29.920 --> 01:14:48.280]  Декремент итератора, вообще говоря, log n в худшем случае. И последнее. Это exception safety. Мы, кстати,
[01:14:48.280 --> 01:14:55.840]  в листе забыли про него поговорить, а вам это будет надо, вам это предстоит на себе ощутить.
[01:14:55.840 --> 01:15:06.960]  В качестве упражнения, да. Как поддержать exception safety в листе? Там не сложно, потому что вы
[01:15:06.960 --> 01:15:12.000]  просто когда лист создаете, если вы создаете лист от многих объектов сразу и к такой-то
[01:15:12.000 --> 01:15:16.480]  объект кидает исключение, то вам надо все алоцированные уже к данному моменту вершины
[01:15:16.480 --> 01:15:26.080]  диалоцировать и уничтожить. Знаете, new это оператор, который делает алокацию.
[01:15:26.080 --> 01:15:43.600]  Вы умеете пользу к операторам new пока что. Ну и malloc еще. Запрещено. Кажется нет. Короче,
[01:15:43.600 --> 01:15:47.240]  в листе понятно, что при всех операциях модифицирующих лист, в том числе при создании
[01:15:47.240 --> 01:15:51.720]  листа, вы должны поддерживать exception safety строгую. Причем вы должны, ну если у вас,
[01:15:51.720 --> 01:15:58.040]  вы создаете какой-то набор объектов, например insert диапазона делаете, занимаетесь копированием,
[01:15:58.040 --> 01:16:02.240]  вот тут у вас конструктор кидает исключение, вы должны все предыдущие уничтожить по одному и
[01:16:02.240 --> 01:16:08.200]  вернуть лист в старое состояние. Только потом выйти из метода. Вот. В мэпе все то же самое,
[01:16:08.200 --> 01:16:17.400]  но только есть интересный момент. Вот кто отгадает в чем заключается особый прикол с exception
[01:16:17.400 --> 01:16:24.320]  safety в мэпе? Да нет, он есть. Тут просто есть дополнительная тонкость, которую надо учитывать,
[01:16:24.320 --> 01:16:33.480]  что вот у вас может, да, у вас может, да, вам нужно все повернуть обратно, когда, если вы
[01:16:33.480 --> 01:16:39.560]  вставили и у вас кто-то кинул исключение, то вам нужно вернуть все как было. Как у вас кто-то
[01:16:39.560 --> 01:17:01.000]  мог кинуть исключение? А есть вот этот вот пацан. Будете? Ну вы будете unordered map писать,
[01:17:01.000 --> 01:17:11.840]  там тоже есть компаратор. Там есть hash и компаратор, там еще хуже. Вот. Так, осознание номер один,
[01:17:11.840 --> 01:17:17.560]  компаратор тоже может кидать исключение, и это надо учитывать. Теперь все должны напоследок
[01:17:17.560 --> 01:17:24.440]  получить осознание номер два, на самом деле это не проблема. Все посмеялись, а теперь все поймите,
[01:17:24.440 --> 01:17:42.320]  что это не проблема и почти ничего не меняет в реализации. Потому что вы никогда не делаете
[01:17:42.320 --> 01:17:49.480]  сравнения после поворотов. Вы сначала делаете все нужные вам сравнения, и только потом решаете
[01:17:49.480 --> 01:17:55.960]  повернуть что-то или нет в красно-черном дереве. И никогда не бывает такого, что вам нужно, вы уже
[01:17:55.960 --> 01:18:11.040]  что-то повернули и вам нужно опять что-то сравнить. Что такое прошлой стадии? У вас константное число
[01:18:11.040 --> 01:18:16.160]  поворотов, вы дошли до какого-то места, поняли где и что нужно повернуть, и вот пока вы это понимали,
[01:18:16.160 --> 01:18:21.600]  у вас могло случиться исключение. Но у вас дерево еще не попорчено, вы еще ничего не повернули. Когда
[01:18:21.600 --> 01:18:25.480]  вы уже дошли до места, где нужно что-то повернуть, вы больше компаратором пользоваться с этого момента
[01:18:25.480 --> 01:18:29.720]  не будете. После этого вы поворачиваете, переставляете указатели, то есть исключения уже нет и все.
[01:18:29.720 --> 01:18:41.240]  Возможно даже так, возможно вам даже сравнений не нужно делать, пока вы делаете поворот.
[01:18:41.240 --> 01:18:52.640]  Возможно это правда. То есть на самом деле мое утверждение в том, что вам никогда не нужно
[01:18:52.640 --> 01:18:58.960]  пользоваться компаратором после того, как вы сделали повороты. Поэтому тот факт, что компаратор
[01:18:58.960 --> 01:19:04.280]  может кидать исключения, не представляет себя большую проблему. Хотя надо конечно это учитывать,
[01:19:04.280 --> 01:19:10.440]  и если компаратор кинул исключения, это нужно вам вершину диалоцировать и вернуть как было все.
[01:19:10.440 --> 01:19:14.880]  Но вернуть как было не подразумевает повернуть дерево обратно, потому что вы
[01:19:14.880 --> 01:19:21.520]  еще не успели повернуть к тому времени. Ну вы алоцировали вершину и начали что-то сравнивать,
[01:19:21.520 --> 01:19:31.240]  вам нужно диалоцировать вершину. Ну еще есть сет, мульти мэп и мульти сет. Ну можно их оставить в
[01:19:31.240 --> 01:19:36.680]  качестве упражнения на самостоятельное изучение. Ну понятно, что такое сет. Сет это то же самое,
[01:19:36.680 --> 01:19:41.320]  только нет value, есть просто ключи и все. И в сете нету обращения квадратными скобками,
[01:19:41.320 --> 01:19:49.160]  вот, потому что нету value опять же, и add нету. Что такое мульти мэп? Это как мэп,
[01:19:49.160 --> 01:19:52.800]  только несколько значений с одним ключом может быть. Там опять же нет квадратных скобок,
[01:19:52.800 --> 01:20:02.960]  и там нету, что там еще нету, ну и add нету. Вот, и там в основном lower bound upper bound вам
[01:20:02.960 --> 01:20:11.680]  нужны будут методы. А еще в мульти мэпе есть такой метод equal range, в котором возвращается
[01:20:11.680 --> 01:20:21.520]  сразу пару, начало и конец диапазона, где начинается и кончается элемент с вашим ключом. Вот,
[01:20:21.520 --> 01:20:28.080]  мульти сет это как мульти мэп, только без value. Итераторы везде там bidirectional и во всех этих
[01:20:28.080 --> 01:20:32.360]  штуках. Вот такие дела. Вот мы с вами разобрали листы мэп, как и планировали.
