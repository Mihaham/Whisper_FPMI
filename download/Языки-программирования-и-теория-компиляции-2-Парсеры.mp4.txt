[00:00.000 --> 00:09.640]  Всем доброго дня! Мы с вами продолжаем изучение компилятора, и сегодня у нас
[00:09.640 --> 00:14.400]  случился некоторый форс-мажор, связанный с тем, что мы не могли долго подключить
[00:14.400 --> 00:19.400]  проектор, точнее чтобы запись выводилась на проектор, поэтому сегодня лекция будет
[00:19.400 --> 00:25.800]  короткой, но ничего страшного. План этой лекции был запланирован растянуться на две лекции,
[00:25.800 --> 00:31.920]  поэтому будем считать, что здесь не лекция 0.2, а лекция 0.2-0.3. Еще один важный момент,
[00:31.920 --> 00:37.520]  который у нас есть, там будут в некоторый момент выходные, вот подумаем, что с ними сделать. Там
[00:37.520 --> 00:43.120]  причем из-за того, что год высокосный, как ни странно, там две лекции подряд выпадут в выходной
[00:43.120 --> 00:50.560]  день на пятницу. Раньше, когда год не высокосный, получается обычно так, что все праздники,
[00:50.560 --> 00:56.440]  которые есть, они ровно выбивают по одному дню в неделю. То есть, там один вылетает понедельник,
[00:56.440 --> 00:59.960]  вторник, среда, четверть, пятница, суббот. Ну, сейчас не повезло, будет две пятницы.
[00:59.960 --> 01:05.200]  Значит, давайте вспомним, где мы сейчас находимся. Мы в прошлый раз с вами обсудили то, каким образом
[01:05.200 --> 01:12.520]  писать сканер, и сегодня мы с вами обсудим достаточно важную тему, но раскроем ее немного
[01:12.520 --> 01:16.800]  с другой стороны по сравнению с курсом формальных языков. Наверное, вы помните, что на формальных
[01:16.800 --> 01:23.480]  ППК был такой замечательный алгоритм под названием LL-алгоритм. Вот, но мы с вами посмотрим еще сегодня
[01:23.480 --> 01:30.560]  другой тип алгоритма, который называется LL-алгоритм. То есть, он сейчас намного проще, во-первых,
[01:30.560 --> 01:35.460]  в реализации, а во-вторых, почему мы его рассматриваем, потому что в библиотеке Ant-LR,
[01:35.460 --> 01:43.840]  которую мы начали с вами рассматривать, в ней используется следующий алгоритм. Это алгоритм
[01:43.840 --> 02:04.520]  LL со звездой. Как расшифровывается этот алгоритм? На самом деле, если говорить исторически,
[02:04.520 --> 02:13.200]  то сначала появился LL-алгоритм, то есть появилось семейство алгоритмов вида LLK. После этого появился
[02:13.200 --> 02:20.680]  язык parser LL со звездой, который учитывает контекст. И на самом деле, когда мы будем смотреть Ant-LR,
[02:20.680 --> 02:26.400]  мы увидим, где этот контекст учитывается. То есть, в Ant-LR можно вносить семантический
[02:26.400 --> 02:34.880]  смысл в правила грамматики. Вот, это важно. Вот, этим как раз занимается звездочка. А LL — это adaptive LL
[02:34.880 --> 02:42.720]  со звездой. И вот сейчас, в последней версии как раз Ant-LR, который Ant-LR 4.13, используется алгоритм
[02:42.720 --> 02:52.440]  parsing LL со звездой. И как пишут разработчики Ant-LR, он очень имеет похожий функционал на тоже
[02:52.440 --> 03:01.200]  популярную вещь под названием PEC. Значит, PEC — это parsing expression grammar. Вот, он сейчас используется
[03:01.200 --> 03:11.120]  в выпитоне, начиная с версии 3.10. И в версии 3.12 там уже есть веселые приколы, когда можно в
[03:11.120 --> 03:17.840]  f-литералах скобочки внутри скобочек, кавычки писать внутри кавычек. Вот, это будет считаться
[03:17.840 --> 03:24.880]  правильным выражением. Вот, то есть, это мы тоже можем посмотреть. Давайте все-таки поговорим про
[03:24.880 --> 03:31.320]  теорию. Значит, цель лекции сегодня — это понять математическую сущность парсеров. Вообще определить,
[03:31.320 --> 03:36.720]  что такое парсер. Дальше научиться представлять код в виде синтоксических структур, которые мы
[03:36.720 --> 03:41.920]  дальше будем разбирать. После этого узнать алгоритм разбора кода на синтоксические структуры.
[03:41.920 --> 03:50.240]  В деталях понять, чем отличаются восходящие парсеры и нисходящие парсеры. И на самом деле разобрать
[03:50.240 --> 03:57.480]  реализацию не то чтобы восходящего подхода. Восходящий подход все, наверное, так или иначе
[03:57.480 --> 04:03.440]  помнят, поскольку это было несколько месяцев назад. Ну, для кого-то там те, кто раньше сдавал,
[04:03.440 --> 04:09.160]  те еще раньше помнят. Вот. Мы все-таки посмотрим сегодня нисходящий подход, который идет сверху вниз.
[04:09.160 --> 04:16.120]  То есть, рассмотрим, как пишется алгоритм. Давайте вспомним, где мы сейчас находимся. У нас имеется
[04:16.120 --> 04:23.320]  некоторый набор токенов. То есть, вспомните, мы с вами в прошлый раз в теме сканеров взяли произвольный
[04:23.320 --> 04:27.080]  текст и разбили его на набор токенов. Кто может напомнить, что такое токен?
[04:33.440 --> 04:41.440]  Да, это лексема со смыслом. То есть, у нас у токена обычно есть тип и внутри токена у нас может
[04:41.440 --> 04:46.880]  скрываться определенное значение, которое называется лексемой. Вот. Значит, нам необходимо
[04:46.880 --> 04:53.280]  теперь задать правила, которые разберут эти токены. Для того, чтобы мы построили дерево вывода,
[04:53.280 --> 04:59.400]  так сказать. И есть классический пример с русским языком. Я не помню, приводил я его на лекциях по
[04:59.400 --> 05:03.880]  формальным языкам или я его привожу на семинарах чисто. Представим себе, что у нас есть простое
[05:03.880 --> 05:09.440]  предложение. В нем есть подлежащее и сказуемое. И к существительному может быть привязана именная
[05:09.440 --> 05:16.200]  группа, дополнительное определение. А к глагольной группе мы можем привязать либо дополнение,
[05:16.200 --> 05:21.920]  либо обстоятельства. Например, красное яблоко долго висело на дерево. Что мы здесь видим? Мы с
[05:21.920 --> 05:28.280]  вами здесь видим, что у нас есть именная группа. Она состоит из определения сабджекта. Да, извините,
[05:28.360 --> 05:35.720]  я должен был написать эджектеф или аналог английского слова. Плохо. Применяю транслитерацию.
[05:35.720 --> 05:42.720]  Как называется? Транслитерацию, да? Да, транслитерацию применяю. Вот. И вторая часть это обстоятельства
[05:42.720 --> 05:48.400]  определения дополнения. Ой, обстоятельства глагола дополнения. Понятно, что мы могли бы сказать,
[05:48.400 --> 05:53.720]  что у нас есть предложение именная группа и глагольная группа. Вот. А глагольную группу разбить
[05:53.720 --> 05:59.880]  дальше на вот эту вот составную часть обстоятельства определения. А почему его
[05:59.880 --> 06:04.200]  определением называют глагол дополнения? Вот. Таким образом, одним из способов
[06:04.200 --> 06:07.800]  простояния простого предложения является такое, что у нас простое предложение состоит из
[06:07.800 --> 06:15.880]  определения существительного, точнее подлежащего обстоятельства глагола и сказуемого. Ой, как
[06:15.880 --> 06:23.080]  называется? Это не глагол называется. Сказуемо. Все. Наполнение. Вот. То есть вот такой пример. И,
[06:23.080 --> 06:29.480]  соответственно, да, тут немножко верстка поехала. Мы можем сказать, что на самом деле
[06:29.480 --> 06:34.960]  члена предложения, в примере выше, это не терминальные символы в нашем контексте. Как вы думаете,
[06:34.960 --> 06:43.520]  что будет в данном случае терминальными символами? Нет слова на самом деле, потому что от слов мы с
[06:43.520 --> 06:54.400]  вами уже избавились. Там у нас были определения дополнения обстоятельства. А чем обычно выражаются
[06:54.400 --> 07:02.360]  определения дополнения обстоятельства? Либо прилагательными, либо существительными, либо
[07:02.360 --> 07:08.920]  предлогами. То есть у нас получается, смотрите, что у нас простое предложение. Это набор не терминальных
[07:08.920 --> 07:14.160]  символов раскрывается. А дальше каждый из терминальных символов, допустим, мы видим, что здесь
[07:14.160 --> 07:24.360]  у нас дополнение. Это, допустим, предлог и существительное. Конечно, лучше сказать,
[07:24.360 --> 07:31.960]  что это обстоятельство, потому что обстоятельство обычно отвечает на вопрос «где». Допустим,
[07:31.960 --> 07:36.360]  можно считать, что и дополнение таким образом можно выражать. Вот. И здесь, в данном случае,
[07:36.360 --> 07:41.240]  simple sentence является стартовым символом. Он является не терминальным. То есть то,
[07:41.240 --> 07:47.200]  от чего мы с вами будем порождать нашу грамматику. Вот. Поэтому мы можем с вами ввести
[07:47.200 --> 07:51.480]  определение контекста свободной грамматики. И здесь только такие грамматики будут рассматриваться.
[07:51.480 --> 07:56.600]  Первое – это множество не терминальных символов. Второе – это множество символов алфавита,
[07:56.600 --> 08:00.680]  терминальных символов. Далее у нас есть множество прав от грамматики и есть стартовый не
[08:00.680 --> 08:09.920]  терминальный символ. Все помнят это определение. Все, отлично. Тогда давайте рассмотрим пример
[08:09.920 --> 08:22.840]  простой грамматики. Что он у нас с вами задает? Как это понять? Да, это работа с выражения не
[08:22.840 --> 08:29.680]  числовыми. Причем, как мы видим с вами интересную вещь, что не все числовые выражения здесь
[08:29.680 --> 08:40.360]  поддерживаются. Или все? Не, скобки есть. А, префиксная запись. Да, то есть видите, в принципе,
[08:40.360 --> 08:48.120]  у нас есть с вами префиксная запись, которая это все раскрывает. Да, казалось, должны быть все. Вот.
[08:48.120 --> 08:53.320]  И давайте рассмотрим как раз разбор этого выражения. Значит, я здесь сразу скажу, что a плюс b
[08:53.320 --> 08:58.720]  умножить на c разбирается приблизительно вот таким образом. Важно, что в терминалах у нас
[08:58.720 --> 09:05.040]  в данном случае будут находиться токены. То есть, видите, у нас есть токен плюс, собственно,
[09:05.040 --> 09:11.440]  который скрывает, собственно, Алексеем плюс. И мы видим с вами здесь, что у нас имя a есть и имя b. То
[09:11.440 --> 09:19.920]  есть, на самом деле, токен это не терминальный символ. Name.a, name.b. Вот. Поэтому, когда мы будем
[09:19.920 --> 09:27.760]  говорить про грамматики, мы будем говорить, в первую свою очередь, про токены. И, значит, вот эта
[09:27.760 --> 09:33.240]  вот последовательность действий, которая нам показывает все это в визуальном виде, а называется
[09:33.240 --> 09:39.580]  деревом вывода. Да. Но, правильно, если мы говорим формально про дерево вывода, это последовательность того,
[09:39.580 --> 09:45.960]  каким образом мы каждый не терминал раскрываем в левую часть правила, раскрываем в виде правой
[09:45.960 --> 09:53.240]  части правила. Если мы говорим формально, то правосторонний дерево вывода — это такое дерево вывода,
[09:53.240 --> 09:58.080]  в котором на каждом шаге раскрывается самый правый не терминал. Левосторонний дерево вывода — это дерево
[09:58.080 --> 10:05.280]  вывода, в котором на каждом шаге раскрывается самый левый не терминал. Вот. Вопрос. Какое дерево вывода
[10:05.280 --> 10:14.000]  было нарисовано на прошлом слайде? Вообще не угадывается. Потому что нам нужно порядок действий
[10:14.000 --> 10:18.440]  проставить для того, чтобы понять, какое это дерево — правосторонний или левосторонний. Да, просто
[10:18.440 --> 10:24.040]  дерево вывода — это картинка. Если мы официально отображаем, нам нужен порядок действий. Хорошо.
[10:24.040 --> 10:29.880]  Давайте поймем следующее, что грамматика называется неоднозначной, если она имеет для какого-то
[10:29.880 --> 10:36.800]  слова более одного левостороннего или правостороннего вывода. Замечание. Значит, в курсе формальных
[10:36.800 --> 10:42.120]  языков у нас не было требования на вид дерева разбора. Да, то есть влевосторонний или правосторонний
[10:42.120 --> 10:48.820]  дерево вывода. Важно следующее, что когда мы будем с вами работать в данном курсе, нам вид дерева
[10:48.820 --> 10:54.800]  разбора не будет важным, потому что именно парсером будет задаваться вид разбора. Если мы говорим
[10:54.800 --> 11:01.080]  про восходящие парсеры, которые будут разбирать слово снизу вверх, то вопрос на знание, какое у
[11:01.080 --> 11:08.960]  нас дерево вывода будет, если мы идем снизу вверх, то будет правостороннее дерево вывода. Потому что
[11:08.960 --> 11:15.920]  мы как раз берем наш набор нетерминалов и поднимаем его кверху. Значит, если у нас с вами дерево
[11:15.920 --> 11:22.160]  вывода, если мы двигаемся слева сверху вниз, как вы думаете, какое дерево вывода будет у нас?
[11:22.160 --> 11:30.960]  Левостороннее. Потому что мы будем с вами рассматривать первый нетерминал. Хорошо. Вот. И классический
[11:30.960 --> 11:37.760]  пример, наверное, если вы с ним не сталкивались, то, пожалуйста, надо познакомиться с ним, что на
[11:37.760 --> 11:44.200]  практике могут встречаться неоднозначные грамматики. Собственно, что у нас здесь? У нас есть здесь
[11:44.200 --> 11:52.360]  раскрытие условных выражений, часть правила для раскрытия условных выражений. То есть мы говорим,
[11:52.360 --> 11:59.920]  что у нас есть statement. Если у нас есть expression, то тогда мы выполняем statement, иначе выполняем
[11:59.920 --> 12:05.840]  еще один statement. Или мы говорим, что у нас есть условие if, в котором есть if expression, then
[12:05.840 --> 12:12.200]  statement. Либо какой-то другой оператор. Здесь, допустим, это оператор присваивания. И давайте
[12:12.200 --> 12:17.840]  посмотрим на вот это, например, вот такого предложения. If expression 1, then if expression 2,
[12:17.840 --> 12:23.360]  then assign 1, else assign 2. Давайте поймем, каким образом мы с вами его можем разобрать.
[12:23.360 --> 12:31.800]  Да, как к первому и фу, так и ко второму и фу. Соответственно, каким образом это можно решать?
[12:31.800 --> 12:36.920]  Это можно решать следующим образом. Либо мы добавляем фигурные скобки везде, то есть
[12:36.920 --> 12:45.600]  меняем нашу грамматику. Либо мы пытаемся перевернуть этот вывод. Вот здесь будут два
[12:45.600 --> 12:52.800]  дерева вывода. То есть что мы здесь видим? Здесь у нас if, then, кто раскрывается вот это выражение,
[12:52.800 --> 12:57.960]  выполняется if export 2, if then else. То есть if then else здесь относится к первому выражению,
[12:57.960 --> 13:06.640]  здесь if then else относится ко второму выражению. А в других языках программирования, каких же?
[13:06.640 --> 13:16.080]  В Питоне даже есть правило, что есть специальный не терминал под названием elif. То есть он явно
[13:16.080 --> 13:22.760]  нам покажет, какому не терминалу, какому правилу это все соотносится. Но и здесь на самом деле это
[13:22.760 --> 13:29.440]  можно решить. Для этого нам нужно левый вывод распространить правый вывод. То есть что мы
[13:29.440 --> 13:37.480]  говорим? Мы говорим, что сначала мы пытаемся раскрыть выражения, в которых нет else, а потом
[13:37.480 --> 13:44.440]  раскрываем выражения, в которых будет else. То есть что мы говорим? То есть мы говорим if
[13:44.440 --> 13:52.160]  expression, then statement. Потом мы говорим, либо if expression, then with else. То есть мы ожидаем,
[13:52.160 --> 13:58.520]  что следующие выражения, которые внутри будут, они будут с else. Иначе сделаем statement. То есть
[13:58.520 --> 14:06.360]  получается мы фиксируем с вами для выражения с else определенный прямо вид expression, определенный
[14:06.360 --> 14:13.680]  не терминал. То есть иногда полезно будет в нашем правиле грамматики четко задавать вид не терминала
[14:13.680 --> 14:19.960]  под то, что оно задает. На самом деле, если мы говорим про формальные языки, то в семинарах
[14:19.960 --> 14:25.000]  по формальным языкам мы, конечно, строили не такие вещи, но мы все равно делали специальные
[14:25.000 --> 14:29.440]  не терминалы, которые отвечали за определенные требования. Допустим, не терминал, в котором
[14:29.440 --> 14:33.920]  количество буква равняется удвоенному количеству букв Б, или не терминал, в которых количество
[14:33.920 --> 14:40.000]  буква там было на единичку на два больше, чем количество букв Б. Все помнят эти примеры.
[14:40.000 --> 14:47.840]  Здесь мы будем их задавать для своих собственных целей. Хорошо, то есть это таким образом можно
[14:47.840 --> 14:55.320]  разрешать неоднозначность. Здесь нам нужно наконец-таки вести такое понятие, как грамматический
[14:55.320 --> 15:00.880]  парсер. Что такое парсер? Это алгоритм, который по входному предложению будет определять,
[15:00.880 --> 15:06.120]  принадлежит ли предложение грамматике. Сразу я буду говорить, что я буду говорить не принадлежит
[15:06.120 --> 15:13.920]  слово грамматики, а принадлежит предложение, то есть наша программа. И парсеру в процессе
[15:13.920 --> 15:19.840]  разбора предложений ему необходимо будет, смотрите, что сделать. Ему необходимо будет построить дерево
[15:19.840 --> 15:27.080]  разбора по способу построения дерева разбора. Они делятся как на нисходящие парсеры, топ-даун сверху-вниз,
[15:27.080 --> 15:33.280]  или в восходящие, bottom-up парсеры. И мы с вами, наверное, сегодня успеем только рассмотреть
[15:33.280 --> 15:41.280]  нисходящие парсеры, а восходящие будем исследовать на следующей лекции, сделаем часть нашего алгоритма.
[15:41.280 --> 15:52.240]  Да, если холодно кому-то, можно это окошечко прикрыть. Вот, собственно, вот такая вещь. Но
[15:52.240 --> 16:00.120]  давайте поймем с точки зрения задачи компиляции, достаточно ли нам будет ответить на вопрос да или
[16:00.120 --> 16:22.080]  нет. Принадлежит ли наше предложение грамматики или не принадлежит? Ну все равно, если мы смотрим на
[16:22.080 --> 16:28.440]  разные литеры, он пытается что-то сделать, любой компилятор, он пытается не только сказать,
[16:28.440 --> 16:33.720]  скомпилируется ваша программа или нет, но представьте себе интерфейс, пишете там г, плюс, плюс что-то
[16:33.720 --> 16:42.320]  там, где говорят, ой, у вас ошибка компиляции, а где, ну неважно, разбирайтесь сами. То есть никакого
[16:42.320 --> 16:53.440]  визуального интерфейса, никаких валидаторов нету, вот давайте. Да, и корд дамп, причем непонятно,
[16:53.440 --> 17:01.200]  что в этом ядре находится. Вот, и поэтому, во-первых, ладно, можно сделать так, но даже представьте,
[17:01.200 --> 17:10.240]  мы найдем место, в котором есть ошибка компиляции. Одна. Ну что за ошибка, говорим, что за ошибка
[17:10.240 --> 17:18.000]  компиляции. Все, да, во-первых, надо определить тип этой ошибки, а еще что-то необходимо, если,
[17:18.000 --> 17:44.080]  допустим, ну совсем у нас с кодом беда. Да, наша цель за одну стадию компиляции найти, как можно
[17:44.080 --> 17:50.400]  больше ошибок. Вот, и, соответственно, нам в парсере необходимо будет заложить опцию,
[17:50.400 --> 17:57.880]  по каким образом исправлять ошибки компиляции, и это можно сделать прямо на этапе написания
[17:57.880 --> 18:03.080]  парсера. Это важно, то есть, и вы не поверите, и в LL-алгоритме, который мы будем рассматривать,
[18:03.080 --> 18:13.760]  и в LL-алгоритме есть подход, но правда, они разные. Вот. Весело будет.
[18:13.760 --> 18:23.840]  Так, и, на самом деле, первый тупой алгоритм, который нужно рассмотреть, это алгоритм
[18:23.840 --> 18:33.600]  экспоненциальный. Собственно, в чем, а? Да, это рекурсивный спуск. То есть, в чем суть? Мы пытаемся
[18:33.600 --> 18:39.040]  спуститься сверху вниз и пытаемся перебрать все правила грамматики, которые могут присоединиться
[18:39.040 --> 18:45.320]  к данному инди-терминалу. Ну, собственно, мы пытаемся присоединить правила. Если у нас правило
[18:45.320 --> 18:51.200]  определенное не присоединяется, мы его отдираем шпателем, возвращаемся в предыдущее состояние.
[18:51.200 --> 18:58.560]  То есть, здесь есть псевдокод. То есть, мы говорим, смотрим, какое у нас следующее слово, дальше делаем
[18:58.560 --> 19:06.160]  wall-true. Фокус — это как раз текущая вершина, по которой мы хотим подвесить правила. Собственно,
[19:06.160 --> 19:12.040]  перебираем следующее правило, подвешиваем наше правило к дереву. При этом мы храним стэк текущих
[19:12.040 --> 19:19.880]  символов, которые у нас есть вот так сказать. Как это назвать? Кронодерево, текущая кронодерево.
[19:19.880 --> 19:39.640]  То есть, у нас есть а. Вот, мы храним на стэке в порядке справа налево. Точнее, слева направо,
[19:39.640 --> 19:46.200]  чтобы вынимать справа налево. Первый не терминал, который нам нужен. Дальше говорим, что если это у
[19:46.200 --> 19:52.800]  нас внезапно не терминал, точнее, если терминальный символ, то мы, собственно, его обрабатываем,
[19:52.800 --> 20:01.240]  кладем, двигаем указатель. Иначе, если при этом у нас больше символов нету, мы дошли до конца
[20:01.240 --> 20:07.960]  слова и все принимается, то мы выдаем accept. Иначе, смотрите, здесь есть функция backtrack.
[20:07.960 --> 20:14.600]  Собственно, что она должна сделать? Она должна отмотаться до того состояния, пока мы с вами не
[20:14.600 --> 20:20.280]  будем готовы принимать этот символ. Подкольку у нас здесь есть функция backtrack, то время работы алгоритма
[20:20.280 --> 20:27.760]  будет... Каким? Экспонициальным.
[20:27.760 --> 20:40.560]  Да, нужно... Собственно... А?
[20:40.560 --> 20:58.800]  Не-не-не-не. Ну, важно в следующее, чтобы у нас циклической зависимости тоже не было. Да, если у
[20:58.800 --> 21:05.440]  нас нет циклической зависимости, то сложность будет экспоненциальной. Если у нас есть циклическая
[21:05.440 --> 21:12.400]  зависимость, то, увы, сложность нашего алгоритма – бесконечность. То есть мы его разобрать не
[21:12.400 --> 21:22.720]  можем. Значит, смотрите, а в каком случае это может возникать? Да, ну нет, бесконечный кейс.
[21:22.720 --> 21:36.080]  Но смотрите, это означает следующее, когда у нас это может бесконечно быть, когда у нас из какого-то
[21:36.080 --> 21:45.600]  ни терминала А может за какое-то количество шагов вывестись А альфа. То есть у нас тот же самый
[21:45.600 --> 21:52.000]  ни терминал в левой части, а альф – это то, что находится в правой части. Ну, здесь за какое-то
[21:52.000 --> 21:56.960]  количество шагов. Обычно штопором обозначается вывод за определенное количество шагов. Это я
[21:56.960 --> 22:04.240]  рассказываю тем, кто не смотрел курс по формальным языкам. Я думаю, такие будут. Вот. И вот этот вот
[22:04.240 --> 22:10.040]  контекст называется левой рекурсией, суть. То есть у нас есть ни терминал, в котором выводится тот
[22:10.040 --> 22:16.200]  же самый левый ни терминал. Бывают два типа рекурсий. Бывает прямая рекурсия, явная рекурсия и бывает
[22:16.200 --> 22:24.520]  неявной рекурсия. То есть когда у нас, допустим, из А выводится Б, из Б выводится С, из С выводится А. Вот.
[22:24.520 --> 22:32.360]  Значит, смотрите следующая вещь. Вам с точки зрения написаний именно парсеров придется руками
[22:32.360 --> 22:39.000]  избавляться от неявной левой рекурсии. То есть когда из А выводится Б, из Б выводится С, а тут есть
[22:39.000 --> 22:44.840]  тряпка. Ну что, мне хочется все-таки писать на доске. Тряпка сухая.
[22:44.840 --> 23:07.600]  Да, да, да. Нет, за один шаг причем. Это явное, да. То есть это когда у нас есть правило А, выводит А,
[23:07.600 --> 23:22.880]  бета. Не явно. Это когда у нас из А выводится, допустим, Б альфа, а Б альфа дальше раскрывается в А,
[23:22.880 --> 23:39.680]  а Б альфа. Собственно, у нас из А получается А за два шага. Вот такую рекурсию нам придется избавляться.
[23:39.680 --> 23:48.480]  Руками причем. От этой рекурсии, сразу скажу, парсеры умеют избавляться автоматически, потому что там
[23:48.480 --> 23:56.640]  правила для перестройки грамматики не очень сложные. Как раз мы сейчас это рассмотрим. Вопрос. Как
[23:56.640 --> 24:03.680]  такой флешбек курсу формальных языков? В каком месте мы избавлялись с вами от левой рекурсии в курсе?
[24:03.680 --> 24:19.200]  Не NFH, другая. Да, нормально в форме грейбах. Если мы рассмотрим нормальную форму грейбах не в том
[24:19.200 --> 24:25.480]  термине, в котором мы смотрели, а просто чтобы выводится первый символ, который выводится, это
[24:25.480 --> 24:31.880]  терминал, то там алгоритм, который не математический, который мы строили, он будет заключаться в том,
[24:31.880 --> 24:43.200]  что нужно убирать левую рекурсию руками. Поэтому это важно. Смотрите, здесь есть пример грамматики
[24:43.200 --> 24:49.080]  для разбора арифметики. Здесь есть операции плюс и умножить, а при этом здесь видно, что операции
[24:49.080 --> 24:56.520]  плюс и умножить стоят в правильном порядке, то есть приоритет операции здесь зад. Сначала мы
[24:56.520 --> 25:01.440]  пытаемся выполнить плюс вверху вниз. Соответственно, снизу вверх, когда мы будем раскрывать правила, то
[25:01.440 --> 25:06.360]  правила умножить и поделить, они будут в первую очередь по сравнению с правилом плюс и минус.
[25:06.360 --> 25:20.680]  Аскопки самые низкие, в самом низу, поэтому они имеют максимальный. Хороший вопрос. Давайте
[25:20.680 --> 25:25.660]  расскажу. Обычно палочками, когда мы обозначали на семинаpekopat instability по формальным
[25:25.660 --> 25:44.220]  языкам, это означает правила или или или. То есть у нас есть правила из экспрSl
[25:44.220 --> 25:48.400]  в смысле, что это нормальная форма грамматика, это нормальная
[25:48.400 --> 25:52.440]  форма записи этих грамматик, и это называется формальная
[25:52.440 --> 25:53.440]  форма Б-кусонаура.
[25:53.440 --> 26:06.640]  Да, то есть мы пишем обычно следующее, что у нас не
[26:06.640 --> 26:10.480]  терминал А, допустим, у нас было правило какое-то
[26:11.480 --> 26:15.820]  А выводится Альфа-Бета, А выводится Бета-Гамма и так
[26:15.820 --> 26:16.820]  далее.
[26:16.820 --> 26:22.660]  Мы их пишем так, А выводится Альфа-Бета, а дальше пишем
[26:22.660 --> 26:25.700]  ИЛИ, чтобы показать, что это у нас идет перенос на
[26:25.700 --> 26:26.700]  следующую строку.
[26:26.700 --> 26:37.440]  Альфа-Гамма, Бета-Гамма, допустим, А вводит Эпсилон,
[26:37.440 --> 26:40.040]  и в конце, чтобы закрыть это правило, обычно ставят
[26:40.040 --> 26:41.040]  точку запятой.
[26:41.040 --> 26:46.640]  То есть, вот это именно код, который можно написать
[26:46.640 --> 26:47.640]  на практике.
[26:47.640 --> 26:52.640]  Вот, дополнительно, какие здесь фишки бывают, здесь
[26:52.640 --> 26:56.560]  обычно вставляют фигурные скобки и пишут, какой код
[26:56.560 --> 27:01.160]  нужно вставить при случае совпадения этого правила.
[27:01.160 --> 27:03.360]  То есть, если вы раскрываете это правило, то какой код
[27:03.360 --> 27:04.360]  надо применять.
[27:04.360 --> 27:11.480]  Ну, подробнее, наверное, мы это еще посмотрим.
[27:11.480 --> 27:16.520]  Так, понятно, что эта запись обозначает.
[27:16.520 --> 27:20.240]  Вот, поэтому приятнее писать это таким именно образом.
[27:20.240 --> 27:25.480]  Ну, собственно, каким образом удалять можно левостроение
[27:25.480 --> 27:26.480]  рекурсию?
[27:26.480 --> 27:31.480]  Значит, мы уже ввели определение, и здесь мы видим неявную
[27:31.480 --> 27:32.480]  левую рекурсию.
[27:32.480 --> 27:35.480]  Из f выводится a, из a выводится s.
[27:35.480 --> 27:36.480]  Хорошо.
[27:36.480 --> 27:40.480]  А каким образом удаляется прямая левостроенная рекурсия?
[27:40.480 --> 27:43.320]  Значит, представьте себе, что у вас есть в последовательности
[27:43.320 --> 27:47.000]  цепочек вывода, и у вас есть нетерминал f, который
[27:47.000 --> 27:49.880]  выводит f альфа, и из f выводится f бета.
[27:49.880 --> 27:51.760]  Тогда что мы можем сделать?
[27:51.760 --> 27:57.000]  Мы с вами можем посмотреть цепочку выводов, которые
[27:57.000 --> 28:01.840]  из f выводят что-то, и потом из этого нетерминала мы
[28:01.840 --> 28:04.440]  с вами выводим какой-то другой, то есть терминал.
[28:04.440 --> 28:08.920]  Это, опять же, напоминает нам удаление epsilon правил
[28:08.920 --> 28:09.920]  в грамматике.
[28:09.920 --> 28:12.480]  Собственно, тогда смотрите внимательно на картинку,
[28:12.480 --> 28:14.120]  что мы с вами можем сделать.
[28:14.120 --> 28:16.720]  Тут, по-моему, кстати, количество нетерминалов, я ошибся,
[28:16.720 --> 28:17.720]  или...
[28:17.720 --> 28:19.400]  Нет, по-моему, не ошибся.
[28:19.400 --> 28:24.720]  Мы берем и подвешиваем вот этот последний терминал,
[28:24.720 --> 28:27.840]  который раскрылся у нас в другой символ, мы его
[28:27.840 --> 28:32.000]  берем и подвешиваем за корень дерева.
[28:32.000 --> 28:36.560]  Мы его подвешиваем за корень дерева, и получается у нас,
[28:36.560 --> 28:40.520]  так сказать, вот эти все f-ки, которые были, уходят в правую
[28:40.520 --> 28:41.520]  часть.
[28:41.520 --> 28:45.240]  То есть у нас теперь из нетерминала f выводит другой
[28:45.240 --> 28:50.160]  терминальный символ бета, это первый символ, и дальше
[28:50.160 --> 28:53.880]  у нас вводится специальный новый нетерминал f-штрих,
[28:53.880 --> 28:57.200]  который будет указывать, что мы раскрываем не стартовую
[28:57.200 --> 29:00.040]  часть, а уже дополнительную часть нашего правила.
[29:00.040 --> 29:07.240]  Сделаем из левой рекурсии правую рекурсию.
[29:07.240 --> 29:12.360]  В итоге у нас уберется правило из f выводится f альфа, но
[29:12.360 --> 29:15.040]  при этом у нас добавится новое правило из f выводится
[29:15.040 --> 29:19.840]  b f-штрих, из f-штрих выводится альфа f-штрих, и из f-штрих
[29:19.840 --> 29:20.840]  выводится епсел.
[29:20.840 --> 29:26.360]  Доказывать я это не буду, потому что у нас практически
[29:26.360 --> 29:29.720]  курс, можно подумать на досоке, почему это работает.
[29:29.720 --> 29:30.720]  Понятно суть?
[29:30.720 --> 29:43.560]  Нет, я тут решил прочитать про алгоритм ml звездочка,
[29:43.560 --> 29:47.840]  первый раз я не осилил, потому что там каждый раздел это
[29:47.840 --> 29:52.040]  введение нового определения, причем какого-то крайне
[29:52.040 --> 29:53.040]  нетривиально.
[29:53.040 --> 29:56.680]  Я боюсь, что произойдет, когда я буду читать алгоритм
[29:56.680 --> 30:01.440]  ml со звездой, там еще один трактат на 10 страниц.
[30:01.440 --> 30:14.040]  Ну сколько тысяч звезд у нас в антеллере?
[30:15.040 --> 30:19.480]  Смотрите, каким образом грамматика превращается
[30:19.480 --> 30:23.040]  после избавления левосторонней рекурсии, то есть у нас
[30:23.040 --> 30:25.920]  появляется правило терм экспорт со звездой, экспорт
[30:25.920 --> 30:28.920]  со звездой плюс терм экспорт со звездой и так далее,
[30:28.920 --> 30:32.040]  и тут видно, что по каждому раскрытию правой части
[30:32.040 --> 30:34.680]  мы можем однозначно восстановить, какая левая часть была
[30:34.680 --> 30:35.680]  раскрыта.
[30:35.680 --> 30:38.500]  То есть на самом деле антеллер тот же самый, он будет это
[30:38.500 --> 30:42.440]  делать под капотом, не будет спрашивать нас.
[30:42.440 --> 30:45.560]  Непрямую левостороннюю рекурсию он раскрыть ему
[30:45.560 --> 30:46.560]  будет крайне сложно.
[30:46.560 --> 30:51.000]  Так, вот такой пример, собственно, а каким образом убирать
[30:51.000 --> 30:53.960]  непрямую левостороннюю рекурсию, давайте мы упорядочим
[30:53.960 --> 30:57.800]  терминалы, а не терминалы по возрастанию и будем
[30:57.800 --> 31:00.080]  искать следующую вещь.
[31:00.080 --> 31:05.920]  Мы будем с вами сделать следующее, что если у нас
[31:05.920 --> 31:10.200]  встречается правило с неправильным порядком, то есть у нас
[31:10.200 --> 31:15.520]  из аитого выводится ажитое b, то мы будем делать следующее,
[31:15.520 --> 31:21.640]  мы берем и подставляем правую часть правила ажитое все
[31:21.640 --> 31:23.240]  возможные выводы ажитоа.
[31:23.240 --> 31:25.960]  То есть в нашем случае, если мы с вами рассмотрим
[31:25.960 --> 31:37.400]  наш пример, где у нас тут есть рекурсия, то есть у
[31:37.400 --> 31:48.360]  нас было правило, так, а выводится b айфа, и что у нас
[31:48.360 --> 31:57.320]  еще было, b выводится a бета, хочется избавиться от вот
[31:57.320 --> 32:01.320]  этого правила, потому что b идет после а, что мы делаем,
[32:01.320 --> 32:05.560]  мы делаем очень простую вещь, какую, мы берем и
[32:05.720 --> 32:10.280]  подставляем все, что здесь было с а, мы вот это правило
[32:10.280 --> 32:19.280]  стираем и добавляем правило из b выводится b альфа бета,
[32:19.280 --> 32:21.120]  то есть для всех таких правил добавляем новое правило.
[32:21.120 --> 32:31.520]  То есть у нас остается прямая левосторонняя рекурсия,
[32:31.520 --> 32:35.760]  но при этом не остается непрямой левосторонней
[32:35.760 --> 32:36.760]  рекурсии.
[32:36.760 --> 32:39.080]  При этом можно заметить, что после каждого шага
[32:39.080 --> 32:43.840]  у нас для аитоа, если мы индуктивно идем по аи, остаются только
[32:43.840 --> 32:44.840]  прямые рекурсии.
[32:44.840 --> 32:45.840]  Вот, хорошо.
[32:45.840 --> 32:46.840]  Так, понятно суть?
[32:46.840 --> 32:47.840]  Хорошо, так, хорошо.
[32:47.840 --> 32:54.840]  Что-то я начал слишком много раз заговорить «хорошо».
[32:54.840 --> 33:05.600]  Идеальным случаем, когда мы говорим, что у нас все
[33:05.600 --> 33:12.280]  отлично, у нас нету состояния вида бэктрек, то есть нам
[33:12.280 --> 33:16.440]  никогда не приходится отматываться назад, и вот наша цель
[33:16.440 --> 33:19.780]  будет состоять в том, чтобы в предиктивных парсерах
[33:19.780 --> 33:21.720]  максимально избавиться от бэктреков.
[33:22.080 --> 33:25.480]  То есть надо предсказывать, в какой ветке пойдем, то
[33:25.480 --> 33:27.480]  есть она подбросит курт нечего.
[33:27.480 --> 33:31.080]  То есть надо прощать правильных ларон и не помнить, как
[33:31.080 --> 33:32.080]  они это пропустят?
[33:32.080 --> 33:36.600]  Ну, на самом деле, первый кейс, который достаточно
[33:36.600 --> 33:39.280]  простой, это использовать те знания, которые были
[33:39.280 --> 33:41.640]  у нас на курсе формальных языков, а именно постараться
[33:41.640 --> 33:44.080]  предсказать, какая будет следующая буква.
[33:44.080 --> 33:46.880]  То есть посмотреть правила грамматики на следующую
[33:46.880 --> 33:50.960]  букву и понять, может быть, мы сможем каким-то образом
[33:50.960 --> 33:53.160]  выявить правила в нашей грамматике.
[33:53.160 --> 33:58.880]  Это называется LL как раз алгоритм, который это
[33:58.880 --> 34:03.720]  будет делать, он называется LLK, то есть K это количество
[34:03.720 --> 34:05.200]  символов, которые мы смотрим наперед.
[34:05.200 --> 34:09.760]  Значит, сразу скажу, тут возникнет вопрос, что
[34:09.760 --> 34:10.760]  такое LL со звездой.
[34:10.760 --> 34:14.960]  Значит, как я предварительно понял, я еще буду это уточнять,
[34:14.960 --> 34:18.720]  это алгоритм, в котором вместо просмотра на K букв
[34:18.720 --> 34:22.960]  вперед мы пытаемся просмотреть контекст, который строится
[34:22.960 --> 34:25.160]  в виде детерминированного конечного автомата.
[34:25.160 --> 34:30.520]  То есть как бы мы пытаемся предсказать, по какой ветке
[34:30.520 --> 34:32.960]  детерминированного конечного автомата мы дальше пойдем.
[34:32.960 --> 34:37.440]  И в зависимости от этого принять решение о выводе
[34:37.440 --> 34:38.440]  определенного правила.
[34:38.440 --> 34:44.400]  Причем там суть в том, что алгоритм, который сейчас
[34:44.400 --> 34:48.040]  мы будем изначально рассматривать, он линейный, а алгоритм
[34:48.280 --> 34:49.920]  LL со звездой будет квадратичный.
[34:49.920 --> 34:54.240]  Но при этом суть в том, что квадратичность будет зависеть
[34:54.240 --> 34:58.200]  от того, сколько мы в этом контексте пробудем времени.
[34:58.200 --> 35:03.840]  Обычно там получается, сложность будет не квадратичной,
[35:03.840 --> 35:05.840]  а порядка в среднем 2-3n.
[35:05.840 --> 35:08.440]  Потому что в контексте мы больше, чем на два символа
[35:08.440 --> 35:09.440]  залезать не будем.
[35:09.440 --> 35:12.720]  Это именно практические вычисления, то есть обычно
[35:12.720 --> 35:16.400]  когда пишут такие компиляторы, парсеры, люди просто начинают
[35:16.400 --> 35:18.400]  гонять их на разных языках.
[35:18.400 --> 35:20.840]  Тем более, давайте практический вопрос.
[35:20.840 --> 35:25.600]  Каким образом проверить сложность своего алгоритма
[35:25.600 --> 35:26.600]  на практике?
[35:26.600 --> 35:36.600]  А где кучу разных объектов взять?
[35:37.200 --> 35:40.200]  Ну, если, по-моему, издание есть.
[35:40.200 --> 35:44.200]  Ну, да.
[35:44.200 --> 35:46.600]  Ну, на самом деле, делать все очень просто.
[35:46.600 --> 35:52.080]  Открываем гитхаб и начинаем парсить примеры кодов
[35:52.080 --> 35:53.080]  с разными языками.
[35:53.080 --> 35:56.520]  То есть у нас есть определенная грамматика для определенного
[35:56.520 --> 35:59.400]  языка программирования, мы идем в интернет, тыкаем
[35:59.400 --> 36:03.080]  в какую-нибудь кнопочку trending или делаем поиск по репозиториям
[36:03.080 --> 36:04.480]  и выкачиваем эти репозитории.
[36:04.480 --> 36:10.080]  Вот, датал сет готов, остается запустить.
[36:10.080 --> 36:14.080]  Вот, собственно, для того, чтобы просмотреть букву,
[36:14.080 --> 36:16.080]  нам нужно ввести множество ферст.
[36:16.080 --> 36:20.080]  Значит, ферст от терминала не терминала, напоминая,
[36:20.080 --> 36:23.880]  это первый символ, который может быть выведен из раскрытия
[36:23.880 --> 36:24.880]  нашего правила.
[36:24.880 --> 36:28.580]  То есть, какой первый символ может быть цепочки выводов.
[36:28.580 --> 36:34.280]  Вот, и, значит, здесь возникает еще одно понятие, оно называется
[36:34.280 --> 36:35.280]  follow.
[36:35.280 --> 36:36.280]  Что такое follow?
[36:36.280 --> 36:40.980]  Follow определяется для не терминалов и это первый символ, который
[36:40.980 --> 36:43.720]  может быть выведен с дерева разбора после определенного
[36:43.720 --> 36:44.720]  не терминала.
[36:44.720 --> 36:47.720]  То есть, давайте еще картинку нарисую.
[36:47.720 --> 36:53.160]  Собственно, давайте я покажу, что такое ферст.
[37:18.160 --> 37:19.160]  То есть, что у нас есть?
[37:19.160 --> 37:23.160]  У нас не терминал А, собственно, если у нас первый символ,
[37:23.160 --> 37:27.160]  который выводится, и это А, то это ферст от А.
[37:31.160 --> 37:34.160]  Но при этом еще у нас А принадлежит ферст.
[37:38.160 --> 37:39.160]  Вот самая буква А.
[37:41.160 --> 37:44.160]  А вот follow определяется числением терминала.
[37:45.160 --> 37:46.160]  Что такое follow?
[37:46.600 --> 37:50.600]  Это у нас есть А, дальше мы выводим какое-то дерево,
[37:50.600 --> 37:54.600]  нам не важно, и дальше смотрим на правую часть дерева вывода,
[37:54.600 --> 37:57.600]  и здесь первый символ А, который мы выводим.
[37:57.600 --> 37:59.600]  Тогда мы говорим, что...
[38:06.600 --> 38:09.600]  А будет принадлежать follow от А.
[38:09.600 --> 38:12.600]  Это первый символ, который может быть выведен из правила.
[38:13.040 --> 38:16.040]  Соответственно, нам нужно учиться считать first и follow,
[38:16.040 --> 38:19.040]  но здесь, на самом деле,
[38:19.040 --> 38:24.040]  надо аккуратно пройтись BFS или DFS по не терминалу.
[38:24.040 --> 38:27.040]  Для того, чтобы посчитать это first.
[38:27.040 --> 38:29.040]  Ну и follow считается похожим образом.
[38:29.040 --> 38:32.040]  То есть, это делается заранее перед шагом алгоритма.
[38:32.040 --> 38:36.040]  Значит, дальше мы вводим следующую вещь.
[38:36.040 --> 38:40.040]  Собственно, это множество first plus.
[38:40.480 --> 38:43.480]  Это первый терминал, который может вывестись
[38:43.480 --> 38:46.480]  начиная с нашей части правила.
[38:46.480 --> 38:50.480]  И мы говорим, что first plus от правила A в стрелочка B
[38:50.480 --> 38:52.480]  это либо first от B.
[38:52.480 --> 38:55.480]  А если пустое слово не принадлежит first от B,
[38:55.480 --> 38:58.480]  то это означает, что наш терминал раскрылся,
[38:58.480 --> 39:00.480]  и дальше у него есть символ.
[39:00.480 --> 39:05.480]  Либо у нас с вами это first от B и follow от A.
[39:05.480 --> 39:09.480]  То есть, у нас из A может быть выведено пустое слово,
[39:09.920 --> 39:12.920]  и дальше мы смотрим наш символ,
[39:12.920 --> 39:15.920]  который у нас идет после этого.
[39:15.920 --> 39:17.920]  И в итоге, по факту, говорится следующее,
[39:17.920 --> 39:20.920]  что множество first plus
[39:20.920 --> 39:23.920]  определяется для фиксированного правила.
[39:23.920 --> 39:25.920]  И что это означает?
[39:25.920 --> 39:29.920]  Это означает, что если мы начинаем подцеплять в алгоритме
[39:29.920 --> 39:31.920]  нашим какое-то правило,
[39:31.920 --> 39:33.920]  то, зная следующую букву,
[39:33.920 --> 39:35.920]  мы можем оценить,
[39:35.920 --> 39:37.920]  подходит это правило нам или нет.
[39:38.360 --> 39:40.360]  И в итоге, говорится следующее,
[39:40.360 --> 39:43.360]  что грамматика точно будет свободна от возвратов,
[39:43.360 --> 39:47.360]  если множество first plus не пересекаются
[39:47.360 --> 39:50.360]  ни для каких правых частей правил,
[39:50.360 --> 39:52.360]  которые выводят из них терминала A.
[39:52.360 --> 39:55.360]  То есть, они у нас, все эти множество first plus,
[39:55.360 --> 39:59.360]  разбивают наше множество терминалов
[39:59.360 --> 40:01.360]  на определенные подмножества.
[40:03.360 --> 40:06.360]  То есть, мы явно можем понять по следующей букве,
[40:06.800 --> 40:10.800]  какое у нас должно быть правило.
[40:12.800 --> 40:14.800]  Вот эта мысль понятна?
[40:16.800 --> 40:18.800]  Если что, спрашивайте.
[40:18.800 --> 40:20.800]  То есть, у нас получается,
[40:20.800 --> 40:23.800]  видим букву, сразу к нему делаем соответствующий first plus
[40:23.800 --> 40:25.800]  или вводим ошибку.
[40:25.800 --> 40:27.800]  То есть, у нас в цикле,
[40:27.800 --> 40:30.800]  давайте тогда я все-таки промотаю,
[40:30.800 --> 40:32.800]  вот он.
[40:32.800 --> 40:35.800]  Видите, мы не начинаем смотреть
[40:36.240 --> 40:38.240]  этот.
[40:38.240 --> 40:40.240]  Что тут получается?
[40:42.240 --> 40:44.240]  In focus or in non terminals
[40:44.240 --> 40:46.240]  и смотреть, видите, тут есть rule,
[40:46.240 --> 40:48.240]  равно next rule at focus.
[40:48.240 --> 40:50.240]  Мы запрашиваем следующие правила,
[40:50.240 --> 40:53.240]  а потом запрашиваем следующий терминал,
[40:53.240 --> 40:55.240]  который у нас есть,
[40:55.240 --> 40:57.240]  а потом и к него достаем правила,
[40:57.240 --> 40:59.240]  которые мы дальше прицепляем.
[40:59.240 --> 41:01.240]  То есть, порядок действий другой.
[41:01.680 --> 41:03.680]  Хорошо.
[41:03.680 --> 41:05.680]  Значит, это множество first plus.
[41:05.680 --> 41:07.680]  Значит, сразу скажу,
[41:07.680 --> 41:09.680]  что если оказывается,
[41:09.680 --> 41:11.680]  что правила грамматики
[41:11.680 --> 41:13.680]  изначально не принадлежит first plus,
[41:13.680 --> 41:15.680]  ну, такое может быть вполне,
[41:15.680 --> 41:17.680]  то нужно объединить в общий не терминал
[41:17.680 --> 41:19.680]  в единый префикс.
[41:19.680 --> 41:21.680]  То есть, мы вносим новый не терминал
[41:21.680 --> 41:23.680]  для того, чтобы сделать дальнейшее раскрытие.
[41:23.680 --> 41:25.680]  Потому что грамматика,
[41:25.680 --> 41:27.680]  которая перечислена слева,
[41:27.680 --> 41:29.680]  часть грамматики,
[41:30.120 --> 41:32.120]  она явно не выводит пары символов.
[41:32.120 --> 41:34.120]  То есть, явно видно,
[41:34.120 --> 41:36.120]  что first plus
[41:36.120 --> 41:38.120]  от правила a, стрелочка alpha b1
[41:38.120 --> 41:40.120]  и a, стрелочка alpha b2
[41:40.120 --> 41:42.120]  будут пересекаться.
[41:42.120 --> 41:44.120]  Поэтому делаем такой контекст.
[41:44.120 --> 41:46.120]  Вот, собственно,
[41:46.120 --> 41:48.120]  здесь приведен пример того,
[41:48.120 --> 41:50.120]  каким образом строится грамматика
[41:50.120 --> 41:52.120]  по определенному правилу.
[41:52.120 --> 41:54.120]  Тут ничего не видно на слайде,
[41:54.120 --> 41:56.120]  но в презентации есть пример.
[41:56.120 --> 41:58.120]  Если что, я могу его даже скинуть.
[41:58.120 --> 42:00.120]  Он из книжки, которая была первая у нас.
[42:00.120 --> 42:02.120]  Вот, тут...
[42:02.120 --> 42:04.120]  Давайте, чтобы было на слайде видно.
[42:06.120 --> 42:08.120]  Я сделаю вот так вот.
[42:08.120 --> 42:10.120]  А ничего не видно на презентации, да?
[42:10.120 --> 42:12.120]  Ай.
[42:16.120 --> 42:18.120]  А?
[42:18.120 --> 42:20.120]  Пал лучше, да.
[42:20.120 --> 42:22.120]  Все-таки скриншоты надо делать лучше.
[42:22.120 --> 42:24.120]  То есть, смотрите, здесь указывается,
[42:24.120 --> 42:26.120]  что вот эта вот штука,
[42:26.120 --> 42:28.120]  она разбирает правила
[42:28.120 --> 42:30.120]  эксперт, звездочка, плюс терм
[42:30.120 --> 42:32.120]  и минус терм.
[42:32.120 --> 42:34.120]  И дальше вот как раз
[42:36.120 --> 42:38.120]  идет разбор
[42:40.120 --> 42:42.120]  вот этого правила.
[42:42.120 --> 42:44.120]  Так, давайте я вернусь.
[42:44.120 --> 42:46.120]  Здесь уже... а?
[42:46.120 --> 42:48.120]  Ух, да.
[42:48.120 --> 42:50.120]  Но при этом все работает за линию,
[42:50.120 --> 42:52.120]  у нас нет никаких возврат.
[42:52.120 --> 42:54.120]  Этим пользоваться невозможно,
[42:54.120 --> 42:56.120]  поэтому люди придумали таблицу.
[42:58.120 --> 43:00.120]  Мы говорим следующее,
[43:00.120 --> 43:02.120]  что давайте составим таблицу,
[43:02.120 --> 43:04.120]  она будет похожа на LR таблицу,
[43:04.120 --> 43:06.120]  только это будет LL таблица.
[43:06.120 --> 43:08.120]  Мы по строкам, мы с вами
[43:08.120 --> 43:10.120]  пишем не терминал, а по столбцам
[43:10.120 --> 43:12.120]  символы для просмотра вперед,
[43:12.120 --> 43:14.120]  которые используются для этого
[43:14.120 --> 43:16.120]  правила. И вот, смотрите,
[43:16.120 --> 43:18.120]  здесь, допустим, есть правило
[43:18.120 --> 43:20.120]  экспорт с штрих
[43:20.120 --> 43:22.120]  выводят у нас плюс терм
[43:22.120 --> 43:24.120]  экспорт.
[43:24.120 --> 43:26.120]  То есть у нас экспорт штрих это плюс терм экспорт.
[43:26.120 --> 43:28.120]  Значит, первый символ,
[43:28.120 --> 43:30.120]  который у нас выводится для этого правила, это плюс,
[43:30.120 --> 43:32.120]  и вот мы получаем на пересечении двойку.
[43:32.120 --> 43:34.120]  Давайте посмотрим, что у нас
[43:34.120 --> 43:36.120]  происходит для правила терм звездочка
[43:36.120 --> 43:38.120]  эпсилон. Вот это, кстати, интересное.
[43:38.120 --> 43:40.120]  Эпсилон это у нас
[43:42.120 --> 43:44.120]  тое слово
[43:44.120 --> 43:46.120]  собственно... где тут
[43:46.120 --> 43:48.120]  кто-нибудь видеть восьмерку?
[43:48.120 --> 43:50.120]  Вот они, да, видите, терм
[43:50.120 --> 43:52.120]  штрих и эпсилон. То есть
[43:52.120 --> 43:54.120]  восьмое правило грамматики.
[43:54.120 --> 43:56.120]  Это у нас будет
[43:56.120 --> 43:58.120]  ферст от
[43:58.120 --> 44:00.120]  ферст от этого правила
[44:00.120 --> 44:02.120]  будет либо конец слова,
[44:02.120 --> 44:04.120]  либо закрывающая скобка.
[44:04.120 --> 44:06.120]  Ну, собственно, почему так
[44:06.120 --> 44:08.120]  происходит? Потому что у нас
[44:08.120 --> 44:10.120]  терм на самом деле это операция
[44:10.120 --> 44:12.120]  умножения,
[44:12.120 --> 44:14.120]  когда нам уже не надо ничего
[44:14.120 --> 44:16.120]  лишнего разбирать.
[44:16.120 --> 44:18.120]  То есть у нас терм это для умножения,
[44:20.120 --> 44:22.120]  фактор это
[44:22.120 --> 44:24.120]  для скобочек.
[44:28.120 --> 44:30.120]  Так, сейчас, секунду, я, кажется,
[44:30.120 --> 44:32.120]  запутался.
[44:32.120 --> 44:34.120]  А, не, фактор это для скобок.
[44:40.120 --> 44:42.120]  Я запутался
[44:42.120 --> 44:44.120]  в порядке операции.
[44:46.120 --> 44:48.120]  Фактор это для умножения?
[44:48.120 --> 44:50.120]  Угу.
[44:54.120 --> 44:56.120]  Терм штрих это когда мы умножаем?
[44:56.120 --> 44:58.120]  Да, да, да.
[45:00.120 --> 45:02.120]  Да, терм штрих это когда мы умножаем
[45:02.120 --> 45:04.120]  и когда у нас заканчивается умножение,
[45:04.120 --> 45:06.120]  мы должны либо скобку закрыть, либо слово закрыть.
[45:06.120 --> 45:08.120]  А вот
[45:08.120 --> 45:10.120]  экспор
[45:10.120 --> 45:12.120]  да, он таким же правилам соответствует.
[45:12.120 --> 45:14.120]  То есть для экспор-штрих мы тоже
[45:14.120 --> 45:16.120]  можем построить либо закрывающую скобку,
[45:16.120 --> 45:18.120]  либо эпсилон.
[45:20.120 --> 45:22.120]  Тут надо помедитировать, но главное
[45:22.120 --> 45:24.120]  когда мы строим эту таблицу у нас нет пересечений.
[45:24.120 --> 45:26.120]  Вот это важно.
[45:26.120 --> 45:28.120]  То есть нет пересечений означает
[45:28.120 --> 45:30.120]  мы можем явно смотреть на следующий
[45:30.120 --> 45:32.120]  символ и двинуться в него.
[45:32.120 --> 45:34.120]  Хорошо.
[45:34.120 --> 45:36.120]  Теперь давайте рассмотрим
[45:36.120 --> 45:38.120]  алгоритм разбора по таблице.
[45:38.120 --> 45:40.120]  Сохраним стэк, вершину
[45:40.120 --> 45:42.120]  этого стэка кладем
[45:42.120 --> 45:44.120]  и стартовый символ.
[45:44.120 --> 45:46.120]  И дальше у нас есть две ситуации.
[45:46.120 --> 45:48.120]  Либо у нас вершина стэка это не терминал
[45:48.120 --> 45:50.120]  и тогда мы смотрим на
[45:50.120 --> 45:52.120]  ферст плюс от этого правила
[45:52.120 --> 45:54.120]  для следующего символа и пытаемся его раскрыть.
[45:54.120 --> 45:56.120]  Либо вершина стэка это терминал
[45:56.120 --> 45:58.120]  и смотрим, собственно, совпадает ли
[45:58.120 --> 46:00.120]  текущая буква, текущий токен
[46:00.120 --> 46:02.120]  с тем, который мы хотим разобрать.
[46:02.120 --> 46:04.120]  Если совпадаем, то все отлично.
[46:04.120 --> 46:06.120]  Двигаем стэк, все снимаем.
[46:06.120 --> 46:08.120]  Либо говорим, что у нас ошибка компиляции.
[46:08.120 --> 46:10.120]  В тот момент
[46:10.120 --> 46:12.120]  времени, когда мы не можем продвинуть
[46:12.120 --> 46:14.120]  определенный терминал,
[46:14.120 --> 46:16.120]  мы говорим, что у нас ошибка компиляции.
[46:16.120 --> 46:18.120]  Важно, что ошибка компиляции
[46:18.120 --> 46:20.120]  здесь детактируется по терминалам.
[46:20.120 --> 46:22.120]  Вот это важно.
[46:22.120 --> 46:24.120]  Если мы с вами читаем какой-то терминал
[46:24.120 --> 46:26.120]  и
[46:26.120 --> 46:28.120]  это означает, что мы знаем позицию
[46:28.120 --> 46:30.120]  того места, где у нас
[46:30.120 --> 46:32.120]  происходит ошибка компиляции.
[46:32.120 --> 46:34.120]  То есть мы явно ее можем отследить.
[46:34.120 --> 46:36.120]  Правда, здесь
[46:36.120 --> 46:38.120]  для того, чтобы отхватить позицию этого символа
[46:38.120 --> 46:40.120]  нам нужно понять, в каком правиле
[46:40.120 --> 46:42.120]  какое правило мы хотим с вами разобрать.
[46:42.120 --> 46:44.120]  Для того, чтобы
[46:44.120 --> 46:46.120]  его вывести, так сказать.
[46:46.120 --> 46:48.120]  Подсказку сделать,
[46:48.120 --> 46:50.120]  правильно это мы делаем или нет.
[46:50.120 --> 46:52.120]  Вот, значит, алгоритм
[46:52.120 --> 46:54.120]  здесь будет выглядеть вот таким образом.
[46:54.120 --> 46:56.120]  Собственно,
[46:56.120 --> 46:58.120]  каким образом разбирается слово.
[46:58.120 --> 47:00.120]  А у нас с вами есть выражение
[47:00.120 --> 47:02.120]  A plus B умножить на C
[47:02.120 --> 47:04.120]  как раз.
[47:04.120 --> 47:06.120]  Мы сначала что делаем?
[47:06.120 --> 47:08.120]  Смотрим. Следующий символ у нас
[47:08.120 --> 47:10.120]  угол это name.
[47:10.120 --> 47:12.120]  Нам нужно раскрыть верхнюю часть
[47:12.120 --> 47:14.120]  по правилу 0.
[47:14.120 --> 47:16.120]  Мы раскрываем, у нас кладется export на stack.
[47:16.120 --> 47:18.120]  Потом, значит, что у нас происходит?
[47:18.120 --> 47:20.120]  У нас export следующий
[47:20.120 --> 47:22.120]  name. Куда мы двинемся с вами?
[47:26.120 --> 47:28.120]  Что у нас на пересечении export name стоит?
[47:28.120 --> 47:30.120]  Значит,
[47:30.120 --> 47:32.120]  на пересечении export name у нас стоит
[47:32.120 --> 47:34.120]  единичка. Это означает, что мы раскрываем
[47:34.120 --> 47:36.120]  первое правило. Причем правило
[47:36.120 --> 47:38.120]  кладем на stack в обратном порядке.
[47:38.120 --> 47:40.120]  То есть сначала term, export.
[47:40.120 --> 47:42.120]  Дальше term раскрываем единичку,
[47:42.120 --> 47:44.120]  term и name.
[47:44.120 --> 47:46.120]  Что у нас term и name? Это пятое
[47:46.120 --> 47:48.120]  правило. Оно еще раз раскрывает.
[47:48.120 --> 47:50.120]  Term и factor. И вот factor
[47:50.120 --> 47:52.120]  еще раз раскроется в name.
[47:52.120 --> 47:54.120]  То есть на пересечении factor и name у нас
[47:54.120 --> 47:56.120]  11. И дальше у нас идет символ
[47:56.120 --> 47:58.120]  name. Наконец-таки у нас с вами терминал.
[47:58.120 --> 48:00.120]  Мы двигаем наш
[48:00.120 --> 48:02.120]  указатель с совходного символа.
[48:02.120 --> 48:04.120]  И повторяем до тех пор,
[48:04.120 --> 48:06.120]  пока у нас весь вывод
[48:06.120 --> 48:08.120]  не закончится.
[48:08.120 --> 48:10.120]  Здесь можно поставить на паузу, посмотреть
[48:10.120 --> 48:12.120]  и посидеть с бумажкой и порисовать.
[48:14.120 --> 48:16.120]  Так, ну и наконец-таки
[48:16.120 --> 48:18.120]  мы с вами должны посмотреть пример
[48:18.120 --> 48:20.120]  ошибка компиляции.
[48:20.120 --> 48:22.120]  Если у нас a++ умножить,
[48:22.120 --> 48:24.120]  то вы правили
[48:24.120 --> 48:26.120]  и следующий символ plus у нас term.
[48:26.120 --> 48:28.120]  Term plus на пересечении
[48:28.120 --> 48:30.120]  у нас ничего нету.
[48:30.120 --> 48:32.120]  И мы понимаем тогда, что у нас ошибка компиляции
[48:32.120 --> 48:34.120]  в том месте,
[48:34.120 --> 48:36.120]  когда мы считываем plus.
[48:36.120 --> 48:38.120]  И мы можем относительно понять,
[48:38.120 --> 48:40.120]  в каком правиле грамматики мы зависли.
[48:40.120 --> 48:42.120]  Мы с вами зависли в правиле грамматики
[48:42.120 --> 48:44.120]  export plus term export.
[48:44.120 --> 48:46.120]  То есть на обратном
[48:46.120 --> 48:48.120]  отмотке,
[48:48.120 --> 48:50.120]  поскольку это правило у нас
[48:50.120 --> 48:52.120]  с удалением левосторонней рекурсии,
[48:52.120 --> 48:54.120]  мы обратно возвращаем
[48:54.120 --> 48:56.120]  эту рекурсию и восстанавливаем
[48:56.120 --> 48:58.120]  исходное правило, в котором у нас была ошибка.
[49:00.120 --> 49:02.120]  У нас есть соответствие
[49:02.120 --> 49:04.120]  в каком моменте времени это произошло.
[49:04.120 --> 49:06.120]  Хорошо, вопрос
[49:06.120 --> 49:08.120]  теперь, который
[49:08.120 --> 49:10.120]  я хочу задать,
[49:10.120 --> 49:12.120]  пока мы не хотим его задать,
[49:12.120 --> 49:14.120]  подумать на ним, наверное, стоит.
[49:14.120 --> 49:16.120]  Мы построили с вами алгоритм, который
[49:16.120 --> 49:18.120]  называется LL1 алгоритм.
[49:18.120 --> 49:20.120]  И вы не поверите,
[49:20.120 --> 49:22.120]  если сейчас действительно
[49:22.120 --> 49:24.120]  задуматься и попытаться доказать
[49:24.120 --> 49:26.120]  его корректность,
[49:26.120 --> 49:28.120]  то я думаю его корректность
[49:28.120 --> 49:30.120]  и его полнота
[49:30.120 --> 49:32.120]  будет доказываться намного быстрее,
[49:32.120 --> 49:34.120]  чем корректность и полнота LL1 алгоритма.
[49:34.120 --> 49:36.120]  То есть на это реально
[49:36.120 --> 49:38.120]  минут 10 понадобится.
[49:38.120 --> 49:40.120]  Ну, не 10, но где-то пол пары
[49:40.120 --> 49:42.120]  всего лишь.
[49:42.120 --> 49:44.120]  Потому что мы явно увидели,
[49:44.120 --> 49:46.120]  когда мы можем или не можем
[49:46.120 --> 49:48.120]  спуститься.
[49:48.120 --> 49:50.120]  Скорее всего, опять,
[49:50.120 --> 49:52.120]  на грани очевидного,
[49:52.120 --> 49:54.120]  мы потеряли.
[49:54.120 --> 49:56.120]  Когда разобрали,
[49:56.120 --> 49:58.120]  да,
[49:58.120 --> 50:00.120]  да.
[50:00.120 --> 50:02.120]  Но проблема в том,
[50:02.120 --> 50:04.120]  что алгоритм LL1 намного
[50:04.120 --> 50:06.120]  мало по сравнению с алгоритмом LR1.
[50:06.120 --> 50:08.120]  И нам приходилось просто делать
[50:08.120 --> 50:10.120]  модификации с разными грамматиками
[50:10.120 --> 50:12.120]  для того, чтобы это работало.
[50:12.120 --> 50:14.120]  То есть, как минимум, мы убрали левостороннюю рекурсию
[50:14.120 --> 50:16.120]  в грамматике.
[50:16.120 --> 50:18.120]  Ну, собственно, LL со звездой
[50:18.120 --> 50:20.120]  как раз позволяет сильно расширить класс,
[50:20.120 --> 50:22.120]  но при этом
[50:22.120 --> 50:24.120]  лишая линейности этого алгоритма.
[50:24.120 --> 50:26.120]  Вот.
[50:26.120 --> 50:28.120]  Ну, и как раз давайте,
[50:28.120 --> 50:30.120]  чтобы, собственно,
[50:30.120 --> 50:32.120]  закончим наше занятие
[50:32.120 --> 50:34.120]  на том, что рассмотрим
[50:34.120 --> 50:36.120]  тот кейс, связанный с ошибками компиляции.
[50:36.120 --> 50:38.120]  Значит, в ошибках компиляции
[50:38.120 --> 50:40.120]  есть два сценария.
[50:40.120 --> 50:42.120]  Первый сценарий — это мы можем
[50:42.120 --> 50:44.120]  вставлять некоторые
[50:44.120 --> 50:46.120]  правила грамматики, некоторые
[50:46.120 --> 50:48.120]  ошибочные токены.
[50:48.120 --> 50:50.120]  То есть, образно говоря, мы можем
[50:50.120 --> 50:52.120]  написать, что у нас есть правила
[50:52.120 --> 50:54.120]  из
[50:54.120 --> 50:56.120]  export
[50:58.120 --> 51:00.120]  там
[51:00.120 --> 51:02.120]  допустим
[51:06.120 --> 51:08.120]  name
[51:08.120 --> 51:10.120]  и error.
[51:10.120 --> 51:12.120]  То есть, мы вставляем специальный
[51:12.120 --> 51:14.120]  error-токен, который мы просто
[51:14.120 --> 51:16.120]  будем игнорировать
[51:16.120 --> 51:18.120]  до того момента.
[51:18.120 --> 51:20.120]  Прочтение этого токена будем игнорировать
[51:20.120 --> 51:22.120]  до того момента, пока мы не дойдем
[51:22.120 --> 51:24.120]  до закрывающей скобки.
[51:24.120 --> 51:26.120]  То есть, в скобках написали,
[51:26.120 --> 51:28.120]  да, начали писать какое-то выражение,
[51:28.120 --> 51:30.120]  потом написали еще что-то, еще что-то, еще что-то.
[51:30.120 --> 51:32.120]  И вот это еще что-то просто игнорируется.
[51:32.120 --> 51:34.120]  Вот.
[51:34.120 --> 51:36.120]  А второй способ делается следующим.
[51:36.120 --> 51:38.120]  А давайте мы попробуем
[51:38.120 --> 51:40.120]  удалять следующие символы, пока они
[51:40.120 --> 51:42.120]  нам не подходят.
[51:42.120 --> 51:44.120]  Да.
[51:44.120 --> 51:46.120]  То есть, просто идет следующий символ,
[51:46.120 --> 51:48.120]  давайте удалим его.
[51:48.120 --> 51:50.120]  Как вы думаете, какой лучший подход
[51:50.120 --> 51:52.120]  использовать для LL-парсеров?
[51:52.120 --> 51:54.120]  Вставлять ошибочный токен в
[51:54.120 --> 51:56.120]  правила? Или пытаться удалять
[51:56.120 --> 51:58.120]  символы до тех пор, пока
[51:58.120 --> 52:00.120]  мы не сможем продвинуться дальше?
[52:06.120 --> 52:08.120]  Смотрите, так, кто
[52:08.120 --> 52:10.120]  за первое?
[52:12.120 --> 52:14.120]  Кто за вставку?
[52:14.120 --> 52:16.120]  Кто за удаление?
[52:18.120 --> 52:20.120]  Правильный ответ – это удаление.
[52:20.120 --> 52:22.120]  Почему? Потому что, когда мы пытаемся
[52:22.120 --> 52:24.120]  вставлять правила, да, то мы
[52:24.120 --> 52:26.120]  двигаем указатель, который у нас есть.
[52:26.120 --> 52:28.120]  В нашем случае мы сверху вниз
[52:28.120 --> 52:30.120]  ставим, поэтому нам нужно сразу подцеплять те
[52:30.120 --> 52:32.120]  правила, которые есть.
[52:32.120 --> 52:34.120]  Практически в режиме рентайма.
[52:34.120 --> 52:36.120]  Вот. А если
[52:36.120 --> 52:38.120]  мы будем вставлять символы и не сможем
[52:38.120 --> 52:40.120]  их разбирать, то это большая проблема.
[52:42.120 --> 52:44.120]  Вот. Потому что, собственно,
[52:44.120 --> 52:46.120]  интерцей может вызвать еще один кат разборов,
[52:46.120 --> 52:48.120]  а здесь мы пропускаем символ до тех пор,
[52:48.120 --> 52:50.120]  пока не нашли полу символ.
[52:50.120 --> 52:52.120]  Как раз, если мы вспомним с вами
[52:52.120 --> 52:54.120]  алгоритм перенос свертка, который
[52:54.120 --> 52:56.120]  поднимается правило снизу наверх,
[52:56.120 --> 52:58.120]  то в нем как раз удобно просто. Мы двигаем
[52:58.120 --> 53:00.120]  следующий символ до тех пор, пока мы не найдем
[53:00.120 --> 53:02.120]  символ, который нам раскрывает
[53:02.120 --> 53:04.120]  правило, которое идет вверх.
[53:06.120 --> 53:08.120]  Вот. Ну, наверное, мы про это уже
[53:08.120 --> 53:10.120]  будем говорить в следующий раз.
[53:10.120 --> 53:12.120]  Значит, давайте тогда план
[53:12.120 --> 53:14.120]  на следующее занятие. Мы с вами
[53:14.120 --> 53:16.120]  вкратце пробежимся по восходящим парсерам,
[53:16.120 --> 53:18.120]  как они работают.
[53:18.120 --> 53:20.120]  Это, собственно, LR-алгоритм.
[53:20.120 --> 53:22.120]  Долго на нем заостряться не будем.
[53:22.120 --> 53:24.120]  Наша цель – главное понять,
[53:24.120 --> 53:26.120]  каким образом можно
[53:26.120 --> 53:28.120]  переписывать грамматики
[53:28.120 --> 53:30.120]  и каким образом можно
[53:30.120 --> 53:32.120]  будет понимать то, что выводит
[53:32.120 --> 53:34.120]  парсер на выводе
[53:34.120 --> 53:36.120]  и уметь править эти ошибки.
[53:36.120 --> 53:38.120]  Потому что наша цель
[53:38.120 --> 53:40.120]  не написать алгоритм парсига,
[53:40.120 --> 53:42.120]  а сделать так, чтобы
[53:42.120 --> 53:44.120]  он правильно разобрал нашу грамматику.
[53:44.120 --> 53:46.120]  То есть мы даем грамматику на вход,
[53:46.120 --> 53:48.120]  наша цель – ее разобрать.
[53:48.120 --> 53:50.120]  Вот. Давайте на этом, наверное, закончим.
[53:50.120 --> 53:52.120]  Да, надеюсь, что следующими
[53:52.120 --> 53:54.120]  лекциями у нас проблем не будет.
[53:54.120 --> 53:56.120]  Всем спасибо и вопросы.
[53:58.120 --> 54:00.120]  Есть вопросы?
[54:00.120 --> 54:02.120]  Ну и хорошо.
