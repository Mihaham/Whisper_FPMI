[00:00.000 --> 00:12.760]  Здравствуйте, давайте начинать потихоньку.
[00:12.760 --> 00:17.680]  Давайте закончим сначала с рейзом в байдереве.
[00:17.680 --> 00:20.680]  Мы в прошлый раз многое сказали, осталось довести
[00:20.680 --> 00:21.680]  до конца.
[00:21.680 --> 00:26.160]  Значит, кратенько напомню, что в вершине байдерева
[00:26.160 --> 00:29.200]  у нас хранится набор ключей в порядке возрастания.
[00:29.200 --> 00:41.000]  И между каждой парой ключей и слева от первого, справа
[00:41.000 --> 00:44.520]  от последнего есть указатель на другие вершины.
[00:44.520 --> 00:47.880]  Мы говорим, что в корне у нас количество ключей
[00:47.880 --> 00:57.560]  от 1 до 2t-1, в остальных вершинах от t-1 до 2t-1.
[00:57.560 --> 01:02.320]  Нам надо научиться делать рейс.
[01:02.320 --> 01:09.480]  Какого-то х.
[01:09.480 --> 01:13.600]  Идея такая, нам хотелось бы просто прийти в какую-то
[01:13.600 --> 01:17.120]  вершину, желательно лист, и если этот х находится
[01:17.120 --> 01:21.760]  в листе, и там хотя бы t ключей, не t-1, а хотя бы t, то можно
[01:21.760 --> 01:24.560]  смело просто х из листа удалить, и дерево останется
[01:24.560 --> 01:25.560]  корректным байдеревом.
[01:26.560 --> 01:28.160]  Но у нас две проблемы.
[01:28.160 --> 01:31.600]  Во-первых, у нас может быть в вершине ключей строго
[01:31.600 --> 01:35.400]  по нижней границе, во-вторых, возможно, нас просят удалить
[01:35.400 --> 01:39.440]  не из листа, а из какой-то внутренней вершины, не из
[01:39.440 --> 01:40.440]  листовой вершины.
[01:40.440 --> 01:43.360]  И тогда надо тоже что-то с этим сделать.
[01:43.360 --> 01:46.320]  Начали мы с того, что мы будем поддерживать вариант,
[01:46.320 --> 01:50.720]  что мы будем идти в поисках х и поддерживать условия,
[01:50.720 --> 01:52.520]  что в текущей вершине, в которой мы стоим, хотя бы
[01:52.520 --> 01:53.520]  t ключей.
[01:54.480 --> 01:58.160]  Значит, наш вариант, то, что мы хотим поддерживать
[01:58.160 --> 02:12.800]  насильно в текущей вершине, хотя бы t ключей, ну либо
[02:12.800 --> 02:15.240]  это корень, потому что в корне мы такого условия
[02:15.240 --> 02:19.740]  выполнить не можем, это адекватное условие для каких-то
[02:19.740 --> 02:23.080]  некорнивых вершин, для корня у меня отдельное ограничение,
[02:23.080 --> 02:25.880]  оно не может быть там вплоть до одного ключа, поэтому
[02:25.880 --> 02:28.360]  я напишу, что в текущей вершине хотя бы t ключей
[02:28.360 --> 02:29.960]  или же текущей вершины это корень.
[02:38.960 --> 02:40.400]  Хочу поддерживать такой вариант.
[02:40.400 --> 02:42.440]  Ну и мы вроде обсудили, как его поддерживать, давайте
[02:42.440 --> 02:46.240]  просто спускаться сверху вниз, давайте считать, что
[02:46.240 --> 02:49.600]  для предыдущей вершины на пути это условие уже выполнено,
[02:49.600 --> 02:52.040]  то есть у меня есть какой-то родитель, который является
[02:52.040 --> 02:54.040]  либо корнем, либо в нем хотя бы t ключей.
[02:54.040 --> 03:01.400]  Вот, я из него как-то спустился в новую вершину, и пусть
[03:01.400 --> 03:05.920]  здесь мне не повезло, здесь ровно t-1 ключ, вот мне не
[03:05.920 --> 03:08.000]  повезло, здесь минимально возможное количество ключей
[03:08.000 --> 03:11.000]  t-1.
[03:11.000 --> 03:13.580]  Тогда что, тогда мы можем либо позаимствовать ключ
[03:13.580 --> 03:17.280]  у одного из братьев, либо с кем-то из братьев склеится.
[03:17.280 --> 03:20.740]  Например, если у меня есть левый брат и в нем хотя
[03:20.740 --> 03:23.860]  бы t ключей, то я могу взять максимальный элемент в
[03:23.860 --> 03:24.860]  нем.
[03:24.860 --> 03:28.500]  Так, давайте здесь аккуратнее напишу, что пусть есть какой-то
[03:28.500 --> 03:31.480]  разделитель между ними m, этот указатель ссылается
[03:31.480 --> 03:34.300]  вот на этого сына, этот на этого, куда мы хотим поместить
[03:34.300 --> 03:35.300]  хотя бы t ключей.
[03:35.300 --> 03:38.220]  Ну и вот мы сказали, что можно тогда x поднять на
[03:38.220 --> 03:40.540]  место m, а m спустить в качестве минимального элемента вот
[03:40.540 --> 03:41.540]  сюда.
[03:41.540 --> 03:44.420]  То есть такую конструкцию можно перерисовать вот в
[03:44.420 --> 03:49.380]  такую, что вместо m стоит x, слева находится все кроме
[03:49.380 --> 03:55.260]  вот этого x, а справа мы дорисовали m в начало нашего
[03:55.260 --> 03:56.260]  списка ключей.
[03:56.260 --> 04:00.780]  Ну и так мы собственно перетянули, как бы x подняли сюда, m спустили
[04:00.780 --> 04:03.700]  сюда, тогда у меня в этой вершине стало ровно t ключей,
[04:03.700 --> 04:04.700]  как и хотелось.
[04:04.700 --> 04:10.340]  То же самое, если справа есть брат, в котором хотя
[04:10.340 --> 04:12.740]  бы t ключей, тогда мы так можем сделать.
[04:12.740 --> 04:16.900]  В плохом случае, когда и во мне, и в каждом из братьев
[04:16.900 --> 04:19.780]  всего t-1 ключ, мы можем их, наоборот, склеить.
[04:19.780 --> 04:23.660]  Что если у меня есть родитель, есть два брата, в которых
[04:23.660 --> 04:30.220]  ровно t-1 ключ, тогда я могу выщипить вот этот вот m из
[04:30.220 --> 04:32.340]  родителя и объединить все это безобразие в одну новую
[04:32.340 --> 04:33.340]  метавершинку.
[04:33.340 --> 04:38.020]  Могу взять склеить, значит m спустить вниз, в родителе
[04:38.020 --> 04:40.540]  останется как раз, я это могу сделать, потому что родитель
[04:40.540 --> 04:42.620]  это либо корень, либо в нем хотя бы t ключей, поэтому
[04:42.620 --> 04:44.340]  я m могу точно оттуда удалить.
[04:44.780 --> 04:47.660]  Я m оттуда спускаю и вот эти объединяю, получается
[04:47.660 --> 04:53.020]  одна новая большая вершинка с в точности 2 t-1 ключом.
[04:53.020 --> 04:57.060]  Здесь t-1, здесь t-1, еще плюс один, как раз 2 t-1.
[04:57.060 --> 04:59.620]  Вот, я m отсюда просто так вот спустил.
[04:59.620 --> 05:02.900]  Ну и это могу сделать, потому что в этой родительской
[05:02.900 --> 05:05.620]  вершине либо было хотя бы t ключей, либо это корень,
[05:05.620 --> 05:08.540]  в этом случае я могу смело спускать, в этом случае
[05:08.540 --> 05:11.940]  если у меня был корень и я оттуда что-то спустил,
[05:11.940 --> 05:13.940]  то у меня это либо остался корректным корнем, если
[05:14.000 --> 05:17.080]  есть хотя бы один ключ, если это был корень, в котором
[05:17.080 --> 05:19.920]  был всего один ключ и я спустил оттуда единственный ключ,
[05:19.920 --> 05:24.000]  представьте что у меня m это единственный ключ в корне,
[05:24.000 --> 05:25.320]  то есть, тут ничего нет, m это единственный ключ.
[05:25.320 --> 05:28.480]  Я его взял, спустил сюда, но тогда давайте вот эту
[05:28.480 --> 05:31.040]  новую вершину назначаем ключом, потому что это опустела,
[05:31.040 --> 05:34.600]  здесь ничего нет,tight yoar sorry, назначим корнем, тогда
[05:34.600 --> 05:36.540]  я могу вот это вот назначить просто корнем.
[05:36.540 --> 05:38.880]  Потому, что у меня теперь корень пустой, нет смысла
[05:38.880 --> 05:40.940]  его хранить, давайте его отбросим, это будет нашим
[05:40.940 --> 05:41.940]  новым корнем.
[05:41.940 --> 05:46.580]  Вот, значит, мы добились такого, что мы можем поддерживать
[05:46.580 --> 05:50.900]  инвариант, что в текущей вершине хотя бы t ключей.
[05:50.900 --> 05:52.740]  Да, окей?
[05:52.740 --> 05:56.040]  Вот, хорошо, и так давайте будем идти до тех пор, пока
[05:56.040 --> 05:57.040]  не найдем x.
[05:57.040 --> 05:59.540]  Вот мы идем-идем-идем, поддерживаем наш инвариант, в какой-то
[05:59.540 --> 06:02.780]  момент мы дошли до какой-то вершины, где среди ключей
[06:02.780 --> 06:03.780]  обнаружился x.
[06:03.780 --> 06:06.740]  Ну, мы можем сделать так, что в этой вершине, если
[06:06.740 --> 06:11.260]  надо, хотя бы t ключей.
[06:11.260 --> 06:14.220]  Ну, понятно, что делать, потому что просто так удалить
[06:14.220 --> 06:17.380]  эту вершину я не могу, потому что слева и справа от нее
[06:17.380 --> 06:19.940]  есть указатель на какие-то другие, ну, там, на поддеревья,
[06:19.940 --> 06:20.940]  вообще говоря.
[06:20.940 --> 06:23.500]  Если я хочу x просто как бы выщипать из дерева, то
[06:23.500 --> 06:25.980]  мне пришлось бы два поддерева склеить, потому что, ну,
[06:25.980 --> 06:29.220]  мне нужно, если я x удаляю, то мне нужно, чтобы только
[06:29.220 --> 06:31.300]  один указатель сходил вот из этих границ, потому
[06:31.300 --> 06:32.300]  что они склеятся.
[06:32.300 --> 06:34.340]  Поддеревья склеивать я быстро не умею.
[06:34.340 --> 06:37.020]  Поэтому надо бы делать что-то другое.
[06:37.020 --> 06:40.460]  Что мы делаем вообще в обычном случае, если мы хотим удалить
[06:40.460 --> 06:41.460]  x?
[06:41.460 --> 06:42.780]  У меня есть два сына, слева и справа.
[06:42.780 --> 06:47.420]  Как мы обычно в таких ситуациях поступаем, когда просто
[06:47.420 --> 06:50.620]  так удалить x мы не можем?
[06:50.620 --> 06:56.700]  Да, поднимаем что-то из… Что именно?
[06:56.700 --> 07:00.700]  Да, мы можем взять и либо в этом поддереве найти минимальный
[07:00.700 --> 07:03.900]  элемент, поднять его в x и отсюда удалить, либо
[07:03.900 --> 07:06.420]  же отсюда достать максимальный, поставить его на место x и
[07:06.420 --> 07:07.420]  отсюда удалить.
[07:08.260 --> 07:10.620]  И как раз за счет того, что у меня максимальный…
[07:10.620 --> 07:12.900]  Как найти максимальный элемент, скажем, вот в этом
[07:12.900 --> 07:13.900]  поддереве?
[07:13.900 --> 07:16.020]  Я встаю сюда и постоянно иду в самого правого сына.
[07:16.020 --> 07:17.780]  То есть у меня здесь вершина.
[07:17.780 --> 07:18.780]  Где максимум?
[07:18.780 --> 07:22.220]  Ну, понятно, справа от последнего ключа, это самый последний
[07:22.220 --> 07:23.220]  указатель.
[07:23.220 --> 07:24.220]  Здесь тоже.
[07:24.220 --> 07:25.220]  Если есть самый правый сын, то я спускаюсь туда и
[07:25.220 --> 07:26.220]  так далее.
[07:26.220 --> 07:27.580]  То есть у меня максимум точно находится где-то
[07:27.580 --> 07:28.580]  в листе.
[07:28.580 --> 07:30.540]  И наоборот, здесь минимум в этом поддереве тоже находится
[07:30.540 --> 07:31.540]  где-то в листе.
[07:31.540 --> 07:35.020]  Поэтому можно было бы спуститься в любого из них, найти там
[07:35.020 --> 07:37.460]  максимум здесь или минимум здесь, поднять его на место
[07:37.460 --> 07:39.180]  x и удалить рекурсивно вот эту штуку.
[07:39.180 --> 07:40.860]  А удалять из листа мы как раз уже умеем.
[07:40.860 --> 07:44.460]  Ну, давайте так попробуем сделать.
[07:44.460 --> 07:48.700]  Давайте я назову вот эти вот поддеревья, это левая,
[07:48.700 --> 07:49.700]  это правая.
[07:49.700 --> 08:08.700]  Значит, если в вершине L хотя бы T ключей, то удаляем,
[08:08.700 --> 08:18.180]  давайте назовем M равное максимуму в левом поддереве,
[08:19.180 --> 08:25.180]  заменяем x на M.
[08:25.180 --> 08:28.060]  Если я вот отсюда достал максимум, то есть удалил
[08:28.060 --> 08:30.980]  из левого поддерева, то я могу просто смело теперь
[08:30.980 --> 08:33.380]  x затереть и написать, что здесь стоит M.
[08:33.380 --> 08:37.100]  Это будет корректное B-дерево, потому что все элементы
[08:37.100 --> 08:40.180]  здесь они меньше, чем M, потому что M был здесь максимальным,
[08:40.180 --> 08:42.100]  и здесь все элементы под A будут больше, чем M, потому
[08:42.100 --> 08:44.980]  что они были больше, чем x, а x еще больше, чем M.
[08:44.980 --> 08:47.660]  Поэтому такая замена, она корректна не только в произвольном
[08:47.660 --> 08:51.020]  поддере, как у нас раньше было в A-VL-дереве и так далее,
[08:51.020 --> 08:53.380]  в B-дереве тоже так можно делать, потому что вот это
[08:53.380 --> 08:56.420]  число больше, чем все вот эти, поэтому смело можно
[08:56.420 --> 08:57.420]  его сюда переписать.
[08:57.420 --> 09:03.180]  Ну и как раз, если у меня в вершине L хотя бы T ключей,
[09:03.180 --> 09:05.660]  значит, я могу смело туда спускаться, и мой вариант
[09:05.660 --> 09:09.060]  будет выполнен, что в вершине хотя бы T ключей я могу смело
[09:09.060 --> 09:12.820]  идти из нее в поисках M, и M уже тогда смогу из листа
[09:12.820 --> 09:13.820]  удалить.
[09:13.820 --> 09:18.620]  То же самое с права, значит, аналогично с R, с R только
[09:18.620 --> 09:21.500]  там ищем минимум, ищем минимум.
[09:21.500 --> 09:28.420]  Вот, проблема может быть только в том случае, если
[09:28.420 --> 09:31.420]  у меня у обоих сыновей по T-минус одному ключу.
[09:31.420 --> 09:36.940]  Вот у меня был какой-то здесь x, который я хочу удалить,
[09:36.940 --> 09:40.900]  слева у меня сын с T-минус одним ключом, справа у меня
[09:40.900 --> 09:42.220]  тоже сын с T-минус одним ключом.
[09:42.220 --> 09:45.500]  Что делать?
[09:45.500 --> 09:48.900]  Ну давайте сделаем то, что мы любим, давайте возьмем
[09:48.900 --> 09:52.780]  и склеим вот это вот все в одну новую вершину, то
[09:52.780 --> 09:53.780]  есть опять спустим x вниз.
[09:53.780 --> 09:58.660]  Это я имею право сделать, потому что в этой вершине
[09:58.660 --> 10:02.660]  хотя бы T ключей по предположению, да, я поддерживаю наш вариант,
[10:02.660 --> 10:05.740]  я этот x могу спустить, ну и соответственно сделать
[10:05.740 --> 10:08.380]  вот такую картинку, что у меня левый сын, вот это
[10:08.380 --> 10:11.420]  вот l, которая раньше была l, потом x, потом r, и вот это
[10:11.420 --> 10:13.220]  все одна большая новая вершина.
[10:13.220 --> 10:15.420]  И дальше удалять уже x не отсюда, а вот отсюда.
[10:15.420 --> 10:19.900]  Вот, то есть здесь делаю ту же самую проверку, да,
[10:19.900 --> 10:21.900]  вот у меня есть x, который я хочу удалить, я смотрю
[10:21.900 --> 10:25.060]  на левого правого его сына, если там сын размера хотя
[10:25.060 --> 10:27.700]  бы T, если есть, то там удаляю минимум или максимум, иначе
[10:27.700 --> 10:29.980]  опять x спускаю вниз и объединяю с детьми и так далее.
[10:29.980 --> 10:41.500]  Вот, значит, в плохом случае спускаю x и объединяю с lr.
[10:41.500 --> 10:50.540]  Вот, все, вот так работает концерт.
[10:50.540 --> 10:56.220]  Значит, соответственно, еще раз давайте кратко скажу,
[10:56.220 --> 10:59.740]  я, во-первых, спускаюсь от корня до вершины, содержащей
[10:59.740 --> 11:06.220]  в этой вершине хотя бы T ключей, ну, тут там какими-то
[11:06.220 --> 11:09.460]  переливаниями или, наоборот, сливаниями двух братьев.
[11:09.460 --> 11:12.020]  Значит, теперь в этой вершине хотя бы T ключей.
[11:12.020 --> 11:15.580]  Пока у меня есть ситуация плохая, и у обоих сыновей
[11:15.580 --> 11:18.980]  с левой справа, вот вокруг этого x, который я хочу удалить,
[11:18.980 --> 11:22.420]  если и с левой справа по T минус одному ключу в вершинах,
[11:22.420 --> 11:25.460]  то я могу x спустить вниз и склеить вот это вот все
[11:25.460 --> 11:27.900]  в одну большую вершину, и дальше удалять x уже не отсюда,
[11:27.900 --> 11:28.900]  а отсюда.
[11:29.380 --> 11:32.900]  До тех пор, пока у обоих сыновей по T минус одному
[11:32.900 --> 11:35.820]  ключу я могу их склеить, спустив туда x.
[11:35.820 --> 11:38.060]  Иначе же я дошел до такой вершины, что ну, либо вообще
[11:38.060 --> 11:41.140]  x в листе находится, тогда можно смело его оттуда вычеркнуть.
[11:41.140 --> 11:44.700]  Либо у меня хотя бы один из двух сыновей большой,
[11:44.700 --> 11:49.500]  там хотя бы T ключей, значит, я могу извлечь туда либо
[11:49.500 --> 11:51.420]  максимум, либо минимум, поставить его на место x,
[11:51.420 --> 11:53.620]  ну, а удалять максимум или минимум я рекурсивно
[11:53.620 --> 11:56.660]  делаю в этом по дереву, потому что здесь много ключей,
[11:56.660 --> 11:59.700]  хотя бы T, мне нужно удалить какое-то число из этого
[11:59.700 --> 12:00.700]  по дереву.
[12:00.700 --> 12:04.140]  То есть, как бы, ну, рекурсивно вызываю рейс другого числа
[12:04.140 --> 12:05.140]  уже.
[12:05.140 --> 12:07.140]  Как-то так.
[12:07.140 --> 12:12.860]  Вот, ну и работа эта все получается опять-таки за глубину,
[12:12.860 --> 12:15.060]  потому что на каждом шаге я спускаюсь вниз, ну, либо
[12:15.060 --> 12:19.060]  я x вниз спустил, вот как в этом примере, и вместе
[12:19.060 --> 12:21.620]  с тем же спускаюсь на один уровень вниз, либо просто
[12:21.620 --> 12:22.940]  перехожу в одно из двух по деревьев.
[12:22.940 --> 12:26.740]  Вот, поэтому время работы опять-таки будет что-то
[12:26.740 --> 12:31.420]  типа T на логарифм N по основанию T, потому что это наша глубина,
[12:31.420 --> 12:33.940]  а это время работы в вершине, да, ну, там, чтобы просмотреть
[12:33.940 --> 12:36.140]  список ключей в вершине, мне нужно время пропорционально
[12:36.140 --> 12:37.140]  это.
[12:37.140 --> 12:38.140]  Вот.
[12:38.140 --> 12:39.140]  Все.
[12:39.140 --> 12:40.140]  Вопросы?
[12:40.140 --> 12:41.140]  Так.
[12:41.140 --> 13:02.260]  Ну, потому что если я просто скажу, типа, давайте спустимся
[13:02.260 --> 13:05.220]  сюда, найдем здесь максимум, то я не могу так сделать,
[13:05.260 --> 13:07.980]  потому что мне нужно, вот, мне нужен мой вариант, чтобы
[13:07.980 --> 13:09.820]  в текущей вершине был хотя бы тех ключей.
[13:09.820 --> 13:13.300]  Если здесь T-1 ключ, то я пытаюсь сделать задачу, где в этой
[13:13.300 --> 13:15.380]  вершине T-1, а мне нужно что-то спускать.
[13:15.380 --> 13:17.660]  Я такой задачи решать, ну, не умею или не хочу уметь
[13:17.660 --> 13:18.660]  точнее.
[13:18.660 --> 13:20.740]  Знаешь что, я сюда спускаюсь, мне для этого надо что-то
[13:20.740 --> 13:31.900]  куда-то пере… Сейчас, я вас понял.
[13:31.900 --> 13:35.260]  Ну, смотрите, например, если мы делали аналогично
[13:35.260 --> 13:38.300]  тому, что делали до этого, скажем, здесь мало ключей,
[13:38.300 --> 13:41.700]  я беру и какой-нибудь вот это вот поднимаю сюда,
[13:41.700 --> 13:43.540]  а X спускаю сюда, чтобы здесь нарастить количество
[13:43.540 --> 13:44.540]  ключей.
[13:44.540 --> 13:47.700]  Тогда у меня удаляемый X куда-то сюда перемещается,
[13:47.700 --> 13:50.420]  и мне нужно следить еще за тем, как движется X.
[13:50.420 --> 13:53.300]  А мне хочется, чтобы он где-то в стабильном месте, где-то
[13:53.300 --> 13:54.820]  стоял, чтобы я понимал, где он находится.
[13:54.820 --> 13:58.420]  То есть, вот это все работало в те моменты времени, когда
[13:58.420 --> 13:59.900]  я X еще не нашел, когда X где-то внизу.
[14:00.900 --> 14:04.260]  А если у меня X где-то сверху, и мне его нужно как-то перетаскивать,
[14:04.260 --> 14:08.020]  то это не очень приятно, ну, как бы надо еще за X-ом
[14:08.020 --> 14:09.020]  стоять.
[14:09.020 --> 14:10.660]  А если не следить, то можно просто склеить и спустить
[14:10.660 --> 14:11.660]  его.
[14:11.660 --> 14:16.660]  Тогда мы понимаем, где он.
[14:16.660 --> 14:26.940]  Так, ну, вроде тогда все с B-деревом, давайте тогда
[14:26.980 --> 14:28.220]  про Дикартова еще поговорим.
[14:28.220 --> 14:39.100]  Ну, давайте определение.
[14:39.100 --> 14:53.380]  Значит, ну, бинарное дерево, бинарное корневое дерево,
[14:53.820 --> 14:54.820]  называется Дикартовым.
[14:54.820 --> 15:04.420]  Если верно следующее, давайте скажем, что в каждой вершине
[15:04.420 --> 15:13.940]  у меня хранится два параметра, X и Y, в каждой вершине хранятся
[15:13.940 --> 15:14.940]  какие-то параметры.
[15:14.940 --> 15:17.900]  Ну, давайте напишу X в это, и Y в это, то есть в каждой
[15:17.900 --> 15:18.900]  вершине свои.
[15:18.900 --> 15:23.300]  Да, для каждой вершины V есть какой-то X, какой-то Y.
[15:24.220 --> 15:26.420]  Так вот, мне нужно, чтобы выполнялись два условия.
[15:26.420 --> 15:36.860]  Во-первых, по X-ам наше дерево – это дерево поиска, а по
[15:36.860 --> 15:40.740]  Y-кам это куча с минимумом в корне.
[16:11.180 --> 16:13.180]  Вот, да, давайте какой-нибудь примерчик.
[16:13.180 --> 16:22.060]  Ну, смотрите, раз по Y-кам мы куча, то, значит, в частности,
[16:22.060 --> 16:24.940]  в корне находится минимально возможный Y.
[16:24.940 --> 16:27.660]  Давайте я еще буду, давайте я скажу, что я X-ы буду называть
[16:27.660 --> 16:30.220]  ключами, а Y-ки – приоритетами.
[16:30.220 --> 16:35.380]  Вот, значит, в корне находится совершенно с минимальным
[16:35.380 --> 16:36.380]  приоритетом.
[16:36.380 --> 16:38.620]  И дальше, при движении вниз, у меня приоритет будет
[16:38.620 --> 16:39.620]  возрастать.
[16:39.620 --> 16:42.460]  Ну, потому что в куче, чем ниже спускаюсь, тем больше
[16:42.460 --> 16:44.460]  у меня приоритет.
[16:44.460 --> 16:46.620]  А по X-ам это дерево поиска, ну, собственно, как бы, если
[16:46.620 --> 16:49.500]  мне нужно сделать find, то я смотрю только на X-ы.
[16:49.500 --> 16:53.660]  Вот, и оно, в частности, D-карту, потому что его можно изобразить
[16:53.660 --> 16:58.300]  на горизонтальной плоскости, X, Y, вот такой вот.
[16:58.300 --> 16:59.300]  Давайте какой-нибудь пример.
[16:59.300 --> 17:02.700]  Пусть у меня есть вершина, корень с координатами там,
[17:02.700 --> 17:08.380]  не знаю, 10, 1, дальше здесь какой-нибудь 5, 3.
[17:08.380 --> 17:12.660]  14, 5.
[17:12.660 --> 17:20.540]  Ну, здесь какие-нибудь дети, давайте, пусть будут 1, 4, 7,
[17:20.540 --> 17:21.540]  8.
[17:21.540 --> 17:22.540]  Ну, что-то такое, например.
[17:22.540 --> 17:23.540]  Вот.
[17:23.540 --> 17:30.180]  Да, то есть, смотрите, если мы сфокусируемся только
[17:30.180 --> 17:33.860]  на X-ах, на первых элементах каждой пары, то это дерево
[17:33.860 --> 17:38.300]  поиска, да, в корне у меня 10, слева 1, 5, 7, справа 14.
[17:38.300 --> 17:40.100]  Все нормально, да, слева меньше и справа больше,
[17:40.100 --> 17:41.100]  как обычно.
[17:41.100 --> 17:43.500]  То же самое для всех под деревьев работает, слева
[17:43.500 --> 17:47.020]  от пятерки единица, справа семерка, а по Y-м это куча.
[17:47.020 --> 17:51.660]  Минимум у меня в корне единичка, в корне, все остальные только
[17:51.660 --> 17:53.380]  больше, да, 3, 4, 8, 5.
[17:53.380 --> 17:55.740]  То же самое для этой вершины, верно, что все, что в под
[17:55.740 --> 17:57.020]  дереве, оно больше.
[17:57.020 --> 18:00.540]  Тройка меньше, чем 4, меньше, чем 8, поэтому куча по Y-кам.
[18:00.540 --> 18:01.540]  Вот.
[18:01.540 --> 18:04.260]  Ну, соответственно, можно изобразить на плоскости,
[18:04.260 --> 18:07.940]  в точности, как бы, отмечая X по такому-то, то есть,
[18:07.940 --> 18:10.660]  если у меня есть конкретный ключ, я могу поставить точку
[18:10.660 --> 18:12.140]  с такими-то корнеатами XY.
[18:12.140 --> 18:14.660]  Если у меня XY даны, то я просто на плоскости отмечаю
[18:14.660 --> 18:15.660]  эту точку и получаю такое дерево.
[18:15.660 --> 18:16.660]  Вот.
[18:16.660 --> 18:20.260]  Ну, то есть, в частности, у меня получается верно следующее,
[18:20.260 --> 18:23.620]  что если где-то находится вершина В, то все ее под
[18:23.620 --> 18:26.380]  дерево, оно выглядит как-то так, что оно, ну, вот есть
[18:26.380 --> 18:29.460]  левое под дерево, есть правое под дерево.
[18:29.460 --> 18:32.260]  Тогда именно, что все вершины, которые находятся в левом
[18:32.260 --> 18:35.660]  под дереве, они левее и ниже, потому что с одной стороны
[18:35.660 --> 18:38.700]  у них X меньше, а Y больше.
[18:38.700 --> 18:43.220]  То есть, вот все левое под дерево, все левое под дерево
[18:43.220 --> 18:50.580]  левее и ниже.
[18:50.580 --> 18:51.580]  Вершины В.
[18:51.580 --> 18:55.340]  Левее, то есть, меньше по X-ам, ниже, то есть, больше
[18:55.340 --> 18:56.340]  по Y-кам.
[18:56.340 --> 18:58.380]  Если Y ориентировал вниз, то больше по Y-кам.
[18:58.380 --> 19:00.500]  Ну, больше по Y-кам в куче как раз больше находится
[19:00.500 --> 19:01.500]  в под дереве.
[19:01.820 --> 19:05.940]  И, аналогично с правым под деревом, правое под дерево
[19:05.940 --> 19:13.940]  это правее и ниже, потому что правее для больших X-ов,
[19:13.940 --> 19:16.380]  как раз у меня в правом под дереве больше X-ы находятся,
[19:16.380 --> 19:19.620]  и ниже больше Y-ки, опять то же самое, в под дереве
[19:19.620 --> 19:20.820]  большие приоритеты у меня лежат.
[19:20.820 --> 19:29.420]  Вот, ну, давайте теорема без доказательства говорит
[19:29.420 --> 19:31.900]  следующее, что если у вас есть какой-то фиксированный
[19:31.900 --> 19:35.300]  набор ключей, скажем, у вас есть N ключей, теорема
[19:35.300 --> 19:39.100]  говорит, что если вы сгенерируете им случайные приоритеты,
[19:39.100 --> 19:46.780]  то, и потом построите дикартовое дерево, то у вас получится
[19:46.780 --> 19:48.660]  обязательно дерево примерно алгоритмической глубины.
[19:48.660 --> 20:00.740]  Значит, пусть X1 и так далее, XN это ключи, пусть Y1 и так
[20:00.740 --> 20:06.420]  далее, YN случайные назначенные им приоритеты, случайные
[20:06.420 --> 20:07.420]  приоритеты.
[20:07.420 --> 20:14.140]  То есть, смотрите, да, вообще, как бы, откуда берутся приоритеты.
[20:14.140 --> 20:16.540]  Вообще говоря, не откуда, мы их сами придумываем,
[20:16.540 --> 20:17.540]  берем из воздуха.
[20:17.900 --> 20:21.740]  Обычные запросы, это запросы к X, там вставка, удаление,
[20:21.740 --> 20:23.860]  нахождение, это запрос к X, потому что дерево поиска
[20:23.860 --> 20:24.860]  на X.
[20:24.860 --> 20:25.860]  Откуда приоритеты?
[20:25.860 --> 20:28.380]  Ну, давайте мы их случайно будем генерируем.
[20:28.380 --> 20:30.660]  Каждый раз, когда, скажем, приходит новый элемент,
[20:30.660 --> 20:33.460]  мы ему в пару сразу автоматически случайно назначаем какой-то
[20:33.460 --> 20:34.460]  приоритет.
[20:34.460 --> 20:35.460]  Да.
[20:35.460 --> 20:36.780]  Просто случайное число.
[20:36.780 --> 20:43.060]  Так вот, тогда утверждается, начну, во-первых.
[20:43.060 --> 20:54.500]  Декартово дерево с такими X, Y единственно, декартово
[20:54.500 --> 21:06.060]  дерево на точках X1, Y1 и так далее, XN, YN, единственно.
[21:06.060 --> 21:12.740]  Во-вторых, это дерево имеет логарифмическую глубину.
[21:12.740 --> 21:15.100]  Точнее, математическое ожидание глубины дерева
[21:15.100 --> 21:16.100]  будет логарифмическим.
[21:16.100 --> 21:29.140]  Мат ожидания глубины этого дерева есть вот логарифма.
[21:29.140 --> 21:48.340]  Ну и тогда, собственно, оказывается, что нам даже
[21:48.340 --> 21:51.140]  не нужно будет следить за какими-то, нам не нужно
[21:51.140 --> 21:52.820]  будет ничего поворачивать, нам не нужно будет следить
[21:52.820 --> 21:53.820]  за глубиной.
[21:53.820 --> 21:56.900]  Если мы в какой-то момент случайно сгенерили все
[21:57.700 --> 22:00.380]  то дальше у нас всегда будет дерево логарифмической
[22:00.380 --> 22:01.380]  глубины.
[22:01.380 --> 22:03.700]  Вот по этой теореме, у меня глубина всегда небольшая,
[22:03.700 --> 22:07.220]  поэтому можно не думать о том, как бы ее восстанавливать.
[22:07.220 --> 22:10.060]  Если мы просто будем соблюдать наши два свойства, что это
[22:10.060 --> 22:13.380]  дерево поиска по X и куча по приоритетам, тогда автоматически
[22:13.380 --> 22:15.500]  будет маленькая глубина, потому что дерево единственное
[22:15.500 --> 22:16.660]  и значит, у него маленькая глубина.
[22:16.660 --> 22:20.580]  Вот, собственно, вот этот факт без доказательства.
[22:20.580 --> 22:24.700]  Давайте докажем первое утверждение, что дерево
[22:24.700 --> 22:25.700]  единственное.
[22:26.380 --> 22:28.900]  Ну здесь, на самом деле, надо оговориться, что оно
[22:28.900 --> 22:31.380]  единственное, коль скоро у вас все приоритеты различные.
[22:31.380 --> 22:37.300]  Если все Y-ты попарно различны.
[22:37.300 --> 22:43.940]  Вот, но я этого не стал указывать в самом начале, потому что
[22:43.940 --> 22:46.660]  если вы сгенерируете N-чисел, то у вас скорее всего они
[22:46.660 --> 22:48.020]  так все будут попарно различны.
[22:48.020 --> 22:52.460]  Да, ну представьте, вы сгенерили N-чисел, не знаю, представьте,
[22:52.460 --> 22:55.420]  что числа там от 0 до 10 в 9 целые случайные, и вы
[22:55.420 --> 22:57.380]  сгенерили N-чисел, с какой вероятностью будут какие-то
[22:57.380 --> 22:58.380]  совпадающие?
[22:58.380 --> 22:59.380]  Ну, с маленькой.
[22:59.380 --> 23:03.020]  Ну, на самом деле, с какой-то, ну, неважно, ну, с небольшой,
[23:03.020 --> 23:04.020]  скажем так.
[23:04.020 --> 23:08.620]  Вообще, конечно, теорема, она скорее про какой-то
[23:08.620 --> 23:12.060]  идеальный мир, где приоритеты генерировали бы как вещественные
[23:12.060 --> 23:14.900]  числа, скажем, из отрезка от 0 до 10 в 9, и тогда уже
[23:14.900 --> 23:16.780]  точно совпадений там не будет.
[23:16.780 --> 23:20.300]  Ну, давайте, значит, ограничимся на случай, когда они все
[23:20.300 --> 23:21.300]  различны.
[23:21.300 --> 23:24.540]  Тут все просто, смотрите, мы понимаем, кто корень.
[23:24.540 --> 23:27.100]  Корень это всегда вершина с минимальным приоритетом,
[23:27.100 --> 23:30.020]  потому что у меня должна быть куча, в куче корень
[23:30.020 --> 23:31.660]  всегда вершина с минимальным приоритетом.
[23:31.660 --> 23:32.660]  Давайте ее найдем.
[23:32.660 --> 23:36.180]  На, это какая-то вершина, какая-то пара х и ты, у которой
[23:36.180 --> 23:37.180]  у минимальный.
[23:37.180 --> 23:43.980]  Какая-то х и ты, где у минимально.
[23:43.980 --> 23:46.300]  Поскольку все у различны, то такой корень единственный.
[23:46.300 --> 23:50.780]  А дальше все однозначно, дальше мы понимаем, что,
[23:51.180 --> 23:54.460]  если это корень, то вопрос, кто слева, кто справа.
[23:54.460 --> 23:58.200]  Но слева должны быть те, у которых ключ меньше, приоритет
[23:58.200 --> 23:59.200]  больше.
[23:59.200 --> 24:02.300]  На, вот как я здесь рисовал, ключ меньше, приоритет больше,
[24:02.300 --> 24:04.800]  а здесь ключ больший, приоритет больше.
[24:04.800 --> 24:08.860]  Ну, значит, у меня все пары х и ты автоматически разбились
[24:08.860 --> 24:09.860]  на два по дереву.
[24:09.860 --> 24:14.860]  Значит, здесь те х ж и ты, для которых х ж меньше,
[24:14.860 --> 24:21.860]  А здесь такие пары, скажем, x-каты и y-каты, в которых x-каты больше, чем x-ыты.
[24:21.860 --> 24:24.860]  Ну и всё.
[24:24.860 --> 24:28.860]  То есть я однозначно знаю корень, я понимаю дальше, как разбиваются все остальные элементы,
[24:28.860 --> 24:31.860]  кто идёт влево, кто идёт вправо.
[24:31.860 --> 24:34.860]  Значит, я знаю индукции по n.
[24:34.860 --> 24:37.860]  Можно сказать, что индукция по n дерево единственная.
[24:37.860 --> 24:42.860]  Я знаю корень, здесь меньше, чем n вершин, значит, здесь дерево единственное определяется.
[24:42.860 --> 24:45.860]  И здесь меньше, чем n вершин, здесь дерево единственное определяется.
[24:45.860 --> 24:49.860]  Получается, вот единственное возможное дерево на n вершинах.
[24:49.860 --> 24:52.860]  Нормально?
[24:52.860 --> 24:54.860]  Хорошо.
[24:54.860 --> 24:58.860]  Давайте мы тогда ещё заодно поймём, как это дерево можно было бы строить за линейное время,
[24:58.860 --> 25:01.860]  если все ключи отсортированы.
[25:01.860 --> 25:07.860]  Построение декартового дерева я буду сокращать до dd.
[25:07.860 --> 25:14.860]  Если x1 меньше x2 меньше и так далее меньше xn.
[25:14.860 --> 25:17.860]  Если все ключи отсортированы уже.
[25:19.860 --> 25:22.860]  За линейное время.
[25:37.860 --> 25:51.860]  Так, ну давайте будем просто идти слева направо и поддерживать декартовое дерево на первых, скажем, i точках.
[25:51.860 --> 25:55.860]  У меня были первые i точек, там x1 и так далее, x и t.
[25:55.860 --> 25:58.860]  Я на них построил какое-то декартовое дерево.
[25:58.860 --> 26:05.860]  Дальше, когда я рассматриваю следующую i плюс первую точку, x и плюс 1, y и плюс 1,
[26:05.860 --> 26:09.860]  то я точно понимаю, что она лежит гарантированно справа от всего того, что я уже нарисовал,
[26:09.860 --> 26:13.860]  потому что у него x больше, чем все предыдущие, потому что они будут в порядке возрастания.
[26:13.860 --> 26:17.860]  Это точка точно справа от всего того, что уже было.
[26:17.860 --> 26:23.860]  Значит, в частности, она должна лежать правее вот этого корня.
[26:23.860 --> 26:31.860]  То есть, если, например, корень у меня остаётся, то у меня эта штука лежит в правом его поддереве.
[26:31.860 --> 26:34.860]  То же самое. Давайте посмотрим на корень правого поддерева.
[26:34.860 --> 26:41.860]  Если здесь приоритет меньше, чем здесь, то значит, эта вершина должна лежать в правом поддереве вот этой штуки.
[26:41.860 --> 26:45.860]  Ну и так далее. То есть, на самом деле, мне достаточно хранить следующую штуку.
[26:45.860 --> 26:52.860]  Значит, мне достаточно хранить корень его правого сына, его правого сына, его правого сына и так далее,
[26:52.860 --> 26:55.860]  вплоть до последней вершины вот на этом пути.
[26:55.860 --> 27:00.860]  Ну, в общем, как я максимум бы искал, я шёл бы слева направо просто, каждый раз спускаюсь направо.
[27:00.860 --> 27:02.860]  Давайте всю эту ветку поддерживать целиком.
[27:02.860 --> 27:07.860]  Тогда приходит новая вершина. Вот она на плоскости где-то здесь располагается.
[27:07.860 --> 27:10.860]  Я утверждаю, что нужно сделать следующее перестроение.
[27:10.860 --> 27:15.860]  Нужно вот здесь вот сказать, что теперь правым сыном этой вершины выступает вот это,
[27:15.860 --> 27:19.860]  а левым сыном новой вершины выступает вот это.
[27:19.860 --> 27:23.860]  И всё. Вот так перестроить.
[27:23.860 --> 27:28.860]  Как понять? Очень просто.
[27:28.860 --> 27:35.860]  Смотрите, давайте мы вот эти вот вершины на правой ветке будем хранить, скажем, в стеке с вершиной вот здесь.
[27:35.860 --> 27:41.860]  То есть, верх sadness так вот эта вершина, вот это вот точка на плоскости, потом вот это, потом вот это, вот эта, потом вот эта.
[27:41.860 --> 27:47.860]  Давайте тогда мы просто из стека будем удалять те верхние вершины, которые лежат ниже чем эта точка.
[27:47.860 --> 27:50.860]  Скажем, вот это лежало в стеке и ниже чем это.
[27:50.860 --> 27:55.860]  Вот у меня есть так направление по y, здесь y больше, чем здесь, удаляю.
[27:55.860 --> 28:00.660]  удаляем.��. Дальше. Теперь верхние вершины стека это вот это. У него опять shaky приоритет
[28:00.660 --> 28:05.620]  больше, чем здесь удаляем, и так я несколько вершин удалил, пока не дошел до первой вершины,
[28:05.620 --> 28:10.700]  то есть до самой глубокой вершины правые ветки, у которой приоритет меньше, чем вот у этой вершинки.
[28:10.700 --> 28:16.060]  То есть здесь приоритет был какой-то ysec, здесь приоритет огромный.
[28:17.560 --> 28:23.940]  Тогда я говорю, что окей, теперь вот 오, у меня ранее была вот такая стрелка, и я ее удаляю, то
[28:23.940 --> 28:29.180]  то есть правым сыном выступала эта вершина, теперь он говорит, что правым сыном это новая вершина и плюс один,
[28:29.180 --> 28:33.620]  а левым сыном и плюс первая вершина означает то, что было раньше правым сыном вот этой вот катой.
[28:33.620 --> 28:39.740]  То есть так перенаправляю стрелки. Ну и соответственно эту вершину добавляем на вершину стека,
[28:39.740 --> 28:44.020]  потому что теперь это максимальный элемент. Это конец правой ветки.
[28:44.020 --> 28:52.740]  Работает. Но смотрите, если у меня суммарно было n точек,
[28:52.740 --> 28:58.580]  значит у меня суммарно было n добавлений, значит и суммарно удалений стека было тоже у от n.
[28:58.580 --> 29:03.300]  Поэтому да, хотя каждая конкретная операция может работать долго, но суммарно удалений у от n
[29:03.300 --> 29:05.460]  значит суммарно построение работает за линейное время.
[29:05.460 --> 29:20.660]  Нет, не надо, потому что теперь смотрите, я вот эти удалил,
[29:20.660 --> 29:27.340]  а мне нужно поддерживать только правую ветку. Корень его правого сына, его правого сына и так далее
[29:27.340 --> 29:32.460]  вплоть до конца. Но теперь правая ветка будет вот эта вот. Это уже в правой ветке не лежит,
[29:32.460 --> 29:36.820]  у меня правая ветка сузилась вот на эту штуку. Я ее теперь опять-таки корректно буду поддерживать.
[29:36.820 --> 29:46.540]  Давайте коротенько напишу, что я храню стек вершин в правой нисходящей ветке.
[29:46.540 --> 29:58.820]  Дальше удаляю вершины с большим приоритетом, чем новая вершина,
[29:58.820 --> 30:13.780]  с большим приоритетом, чем соответственно у и плюс первая. И теперь говорю,
[30:13.780 --> 30:24.060]  что у и плюс первая это вершина стека. А в конце добавляем на вершину стека.
[30:24.060 --> 30:41.620]  Вот такой простой алгоритм получился. Так, вопросы можете? Почему за линейное время?
[30:41.620 --> 30:46.620]  Смотрите, у меня суммарно, давайте посмотрим на размер стека, грубо говоря. Суммарно у меня
[30:46.620 --> 30:50.060]  может быть из него много удалений, потому что на каждом шаге я могу удалять много вершин,
[30:50.060 --> 30:54.820]  но добавление в него всегда ровно n, потому что я прохожусь с первым вершином слева направо,
[30:54.820 --> 30:59.260]  и плюс первую вершину всегда в конце добавляю. Значит у меня размер стека, точнее в стек
[30:59.260 --> 31:05.220]  добавляется максимум n вершин. Значит удаление из него, раз в нем всего n элементов когда-либо
[31:05.220 --> 31:10.860]  побывал за всю его жизнь, значит удаление суммарно тоже максимум n. Ну а какое время
[31:10.860 --> 31:16.340]  работ нашего алгоритма? Это что-то как бы зависище от числа удаления из стека. Раз
[31:16.340 --> 31:31.580]  этих было вплоть до n, то значит время работы общей тоже у отн. Вот, хорошо. Смотрите,
[31:31.580 --> 31:36.780]  у меня очень мало изменений происходит. Вот эта вот вершина стека, то есть я вот эти удалил,
[31:36.780 --> 31:44.180]  это на вершине стека теперь, это как бы вершина с перересетом меньше, чем вот это вот. У него был
[31:44.360 --> 31:49.300]  правый сын какой-то до этого. Я его запоминаю, давайте это r назову. Теперь говорю, что у
[31:49.300 --> 31:54.180]  этой штуки вместо вот этого правого сына становится вот вот эта новая вершина. И у него левый сын,
[31:54.180 --> 31:59.160]  это то, что раньше было правым сыном, все, я перенаправил две стрелки. Я сказал что вместо
[31:59.160 --> 32:03.620]  вот этого правого сына теперь правый это вот это, а вместо... ну как бы теперь говорю,
[32:03.620 --> 32:09.780]  что левым сыном вот этой вершины выступает вот эта вершина. Правого잔 가 некоу. Я у меня нет
[32:09.780 --> 32:13.860]  никаких элементов с большим ключом чем вот это вот, потому что по этому правому у него не может
[32:13.860 --> 32:34.900]  даже. Да, просто было бы вот здесь довешивание. Вот. Ну и, кстати говоря,
[32:34.900 --> 32:39.780]  насчет размера стека, по теореме, которую я только что стер, можно было бы сказать,
[32:39.780 --> 32:43.100]  что длина вот этого пути всегда алгоритмическая, потому что это длина какого-то
[32:43.100 --> 32:48.580]  нисходящего пути. Значит, не больше, чем глубина дерева, значит, здесь точно максимум от
[32:48.580 --> 32:55.780]  логарифма вершин. Поэтому стек всегда, кстати, даже небольшой, что можно заметить. Вот. Ну хорошо.
[32:55.780 --> 33:04.580]  Так, едем дальше. Значит, вот у нас есть такая штука. Давайте мы поступим несколько необычно.
[33:04.580 --> 33:11.100]  Давайте мы сначала реализуем не insert и erase, а давайте сначала реализуем merge и split.
[33:11.100 --> 33:20.300]  Значит, ну давайте начнем с merge. Представьте себе, что у меня есть два дикартовых дерева. Давайте
[33:20.300 --> 33:26.820]  их назову A большое, B большое. И как это я предполагал и раньше, пусть все ключи левого меньше
[33:26.820 --> 33:39.940]  всех ключей правого. Все ключи A меньше всех ключей B. Значит, это разумное предположение,
[33:40.340 --> 33:45.460]  которое почти всегда выполняется во всех нормальных задачах. Вот. Что это значит с точки
[33:45.460 --> 33:51.180]  зрения нашей картинки на плоскости? Это значит, что существует какая-то разделяющая вертикальная
[33:51.180 --> 33:57.780]  прямая такая, что все A где-то слева от этой прямой, все B где-то справа от этой прямой. На раз ключи
[33:57.780 --> 34:03.100]  слева меньше ключей справа, значит, между ними есть какой-то зазор их разделяющий. Вот есть какая-то
[34:03.100 --> 34:10.060]  вертикальная прямая их разделяющая такое, что A слева, B справа. Хорошо. Давайте поймем тогда,
[34:10.060 --> 34:14.780]  если мне их нужно склеить, то есть у меня есть два дикартовых дерева, хочу построить одно большое
[34:14.780 --> 34:21.420]  новое, которое содержит все вот эти старые точки. Ну склеить все это в одно. Кто может быть корнем
[34:21.420 --> 34:29.820]  нового дерева? Один из корней, да, это у нас где-то уже было такое, что если у меня есть два дерева,
[34:29.860 --> 34:34.460]  две кучи и я знаю минимум здесь, минимум здесь, тогда минимум во всем объединении,
[34:34.460 --> 34:39.380]  это минимум из двух минимумов. Если я знаю, что здесь минимальный приоритет лежит в корне,
[34:39.380 --> 34:43.980]  здесь минимальный приоритет лежит в корне, я хочу объединить, то корнем выступает вершина с
[34:43.980 --> 34:58.420]  минимальным приоритетом, то есть один из корней, на корень объедения один из корней А или B.
[34:58.420 --> 35:00.420]  Давайте тогда сравним их приоритеты и
[35:00.420 --> 35:02.420]  поймем, кто из них должен быть корнем.
[35:02.420 --> 35:04.420]  Ну, на этой картинке у меня получилось,
[35:04.420 --> 35:06.420]  что здесь приоритет меньше, значит, эта
[35:06.420 --> 35:08.420]  штука должна быть корнем. Давайте я скажу, что здесь
[35:08.420 --> 35:10.420]  эта вершина A, эта вершина B.
[35:10.420 --> 35:12.420]  Значит,
[35:12.420 --> 35:14.420]  пусть A точка Y,
[35:14.420 --> 35:16.420]  давайте так напишу, приоритет
[35:16.420 --> 35:18.420]  вершины A меньше
[35:18.420 --> 35:20.420]  приоритета вершины B.
[35:22.420 --> 35:24.420]  A точка Y меньше B точка Y.
[35:24.420 --> 35:26.420]  Тогда я понимаю,
[35:26.420 --> 35:28.420]  что корнем нового дерева обязательно
[35:28.420 --> 35:30.420]  должно выступать A.
[35:30.420 --> 35:32.420]  Более того, я понимаю, что
[35:32.420 --> 35:34.420]  все левое под дерево A не изменяется,
[35:34.420 --> 35:36.420]  потому что слева от A, да, в левом
[35:36.420 --> 35:38.420]  под дереве A, лежат только те товарищи,
[35:38.420 --> 35:40.420]  у которых ключ меньше, чем у вершины
[35:40.420 --> 35:42.420]  A. Но это просто вот все те,
[35:42.420 --> 35:44.420]  кто были слева, понятно, они не меняются,
[35:44.420 --> 35:46.420]  с ними ничего не произошло, они ни с кем не объединились.
[35:46.420 --> 35:48.420]  То есть у меня левое под дерево сохраняется.
[35:48.420 --> 35:50.420]  Изменения происходят
[35:50.420 --> 35:52.420]  только в правом под дереве, потому что справа
[35:52.420 --> 35:54.420]  теперь мне нужно содержать не только
[35:54.420 --> 35:56.420]  то, что было раньше справа от A,
[35:56.420 --> 35:58.420]  но и все B. Поэтому мне нужно
[35:58.420 --> 36:00.420]  эти два дерева слить в одно.
[36:00.420 --> 36:02.420]  То есть теперь правым сыном
[36:02.420 --> 36:04.420]  A будет выступать не то, что было раньше,
[36:04.420 --> 36:06.420]  а объединение вот этого,
[36:06.420 --> 36:08.420]  что было раньше, и B.
[36:08.420 --> 36:10.420]  Поэтому я напишу вот так.
[36:10.420 --> 36:12.420]  Я напишу, что A точка
[36:12.420 --> 36:14.420]  right,
[36:14.420 --> 36:16.420]  правый сын, правого под дерево,
[36:16.420 --> 36:18.420]  равно объединению
[36:18.420 --> 36:20.420]  того, что было раньше,
[36:20.420 --> 36:22.420]  то есть A точка right, и B.
[36:24.420 --> 36:26.420]  Потому что справа от корня
[36:26.420 --> 36:28.420]  должно лежать вот это вот все,
[36:28.420 --> 36:30.420]  то, что было раньше справа, A точка right,
[36:30.420 --> 36:32.420]  и все под дерево B.
[36:32.420 --> 36:34.420]  Вот.
[36:34.420 --> 36:36.420]  Ну, когда я пишу A точка right,
[36:36.420 --> 36:38.420]  B, я имею ввиду под дерево
[36:38.420 --> 36:40.420]  начинающейся в этой вершине.
[36:40.420 --> 36:42.420]  То есть A точка right это все вот это вот под дерево,
[36:42.420 --> 36:44.420]  B это все вот это вот под дерево.
[36:44.420 --> 36:46.420]  Вот я их теперь рекурсивно объединяю
[36:46.420 --> 36:48.420]  и подвешиваю в качестве правого сына
[36:48.420 --> 36:50.420]  справа, подвешиваю к A.
[36:50.420 --> 36:52.420]  Вот.
[36:52.420 --> 36:54.420]  Потому что это ровно те, вот здесь
[36:54.420 --> 36:56.420]  должны быть ровно те элементы, которые либо пришли отсюда,
[36:56.420 --> 36:58.420]  либо отсюда. Вот я их давайте рекурсивно объединю
[36:58.420 --> 37:00.420]  и подвешиваю в качестве правого сына к A.
[37:00.420 --> 37:02.420]  Получится корректное одекартовое дерево, потому что
[37:02.420 --> 37:04.420]  у меня, значит, ну здесь приоритет
[37:04.420 --> 37:06.420]  минимальный, слева все ключи меньше,
[37:06.420 --> 37:08.420]  справа все ключи больше, ну с приоритетами тоже можно
[37:08.420 --> 37:10.420]  слышать, что все хорошо. Главное, что я в корень
[37:10.420 --> 37:12.420]  подвесил минимальный приоритет,
[37:12.420 --> 37:14.420]  если у меня по индукции мерч работает корректно,
[37:14.420 --> 37:16.420]  то и справа будут все больше, слева будут все больше.
[37:16.420 --> 37:18.420]  Вот.
[37:18.420 --> 37:20.420]  Согласны здесь?
[37:20.420 --> 37:22.420]  Далее?
[37:22.420 --> 37:24.420]  Еще раз?
[37:24.420 --> 37:26.420]  Да, мы считаем, что все приоритеты разные,
[37:26.420 --> 37:28.420]  они сгенерировались так, что они все попарно различны.
[37:28.420 --> 37:30.420]  На самом деле можно об этом,
[37:30.420 --> 37:32.420]  с точки зрения аккуратной теории мы считаем,
[37:32.420 --> 37:34.420]  что они все разные, на практике
[37:34.420 --> 37:36.420]  можно над этим не заморачиваться,
[37:36.420 --> 37:38.420]  можно просто сгенерировать случайные числа,
[37:38.420 --> 37:40.420]  если что-то внезапно совпало,
[37:40.420 --> 37:42.420]  то все равно все будет корректно работать
[37:42.420 --> 37:44.420]  чуть-чуть дольше, но, ой, бог с ним,
[37:44.420 --> 37:46.420]  там будет очень мало коллизий в любом случае.
[37:46.420 --> 37:48.420]  То есть они, возможно, будут, но
[37:48.420 --> 37:51.740]  препятствий, можно про это вообще не думать. Но с точки зрения строгой теории,
[37:51.740 --> 37:58.740]  здесь всегда значение сравнения строгие. Иначе, приоритет у нас относится по-другому,
[37:58.740 --> 38:05.340]  и наоборот, корнем должен выступать B, потому что у него меньше приоритет. B обязательно
[38:05.340 --> 38:10.180]  должен стать корнем. То есть картинка должна быть вот такой. B, вот здесь какое-то правое
[38:10.180 --> 38:14.660]  поддерево, здесь какое-то левое поддерево. Тут уже ситуация противоположная. Давайте я
[38:14.660 --> 38:25.940]  здесь же это нарисую. У меня было вот такое A, у меня было вот такое B. Здесь уже, смотрите,
[38:25.940 --> 38:31.340]  здесь не должно поменяться правое поддерево B, потому что все, что лежало справа от B,
[38:31.340 --> 38:35.300]  но там же остается ничего нового, там не подливается. Поэтому в этом случае у меня
[38:35.300 --> 38:39.860]  сохраняется правое поддерево B, оно не изменяется. Какое справа было, что справа висело, то справа
[38:39.860 --> 38:44.740]  остается. Здесь меня наоборот слева, потому что вот теперь, если у меня B это корень всего
[38:44.740 --> 38:49.540]  объединения, то в левом поддереве должны лежать не только то, что раньше лежало. Вот здесь должно
[38:49.540 --> 38:54.500]  лежать не только B left, не только то, что лежало слева раньше, но и все A. Поэтому мне нужно,
[38:54.500 --> 39:02.620]  наоборот, объединить вот это вот B.left и все A. Будьте здоровы, я надеюсь, ты был чих. Вот все,
[39:02.620 --> 39:17.940]  значит B.left равно merge, а запятая B.left. Я рекурсивно объединяю все дерево A с тем,
[39:17.940 --> 39:27.060]  что висело слева от B, и это подвешиваю в качестве левого сына к B. Получается корректно
[39:27.060 --> 39:30.620]  декарта в дерево, потому что я правильно разбивался с ключами, значит приоритет им там аналогично.
[39:30.620 --> 39:46.580]  Нормально? Хорошо. Я это явно не проговорил, но условия выхода из рекурсии, то есть я здесь
[39:46.580 --> 39:50.900]  говорю, что я делаю все рекурсивно, условия выхода из рекурсии такое, если A пустой,
[39:50.900 --> 39:54.460]  то return B, если B пустой, то return A. Если одно из деревьев пустой, то его лишать нечего,
[39:54.460 --> 40:05.220]  в смысле делать нечего. Ну и тогда понятно, что все это действие работает за сумму глубин A и B,
[40:05.220 --> 40:09.940]  потому что каждый момент времени я либо спускаюсь в поддереве A, либо в поддереве B, тем самым
[40:09.940 --> 40:13.700]  уменьшаю глубину хотя бы одного из деревьев. Поэтому время работы давайте так напишем,
[40:13.700 --> 40:22.500]  что это ограничено глубиной A плюс глубиной B, но мы знаем, что глубина логарифмически,
[40:22.500 --> 40:28.820]  поэтому это будет все от логарифма. Поэтому мерч работает за логарифм.
[40:28.820 --> 40:41.860]  Так, ну теперь операция сплит. Сплит, давайте какое-нибудь дерево, так же пусть будет A, по
[40:41.860 --> 40:51.460]  ключу K. Напоминаю, у меня есть одно дикартовое дерево, есть какой-то ключ K, какой-то элемент,
[40:51.460 --> 40:56.900]  какое-то число. Мне нужно разбить мое A на два под дерево. Слева все ключи меньше либо равны K,
[40:56.900 --> 41:02.100]  справа все больше. Нужно разбить его так, что слева все меньше либо равны K, справа все больше K.
[41:02.100 --> 41:14.260]  По ключам, да, сплит всегда по ключам. Так, ну давайте думать, давайте посмотрим на корень
[41:14.260 --> 41:18.900]  нашего дерева, давайте назову его вершинкой, пусть будет A так же. Вот у нас корень. Есть
[41:18.900 --> 41:28.420]  счет слева, есть счет справа. Ну давайте поймем. Во-первых, если мы сравним A точка X с K,
[41:28.420 --> 41:34.900]  то мы поймем в какое из вот этих двух деревьев должно пойти A, налево или направо. Если мы знаем,
[41:34.900 --> 41:42.340]  что A точка X меньше либо равно K, то A точно здесь, иначе точно здесь. Более того, если вот это все
[41:42.340 --> 41:47.140]  как бы на плоскости нарисовать, вот если это моя картинка на плоскости, то по факту мне нужно
[41:47.140 --> 41:52.700]  что сделать? Мне нужно провести вертикальную прямую X равно K, и все, что слева поместить в левое
[41:52.700 --> 41:59.620]  под дерево, все, что справа вправо. Значит, тогда, если я сравню A точка X с K, я еще и пойму,
[41:59.620 --> 42:03.620]  с какой стороны вот этого значения происходит разделение, вот эта вот линия разделения,
[42:03.620 --> 42:10.420]  где она проходит. Вот если, скажем, A точка X меньше либо равно K, то картинка какая-то такая,
[42:10.420 --> 42:17.320]  что у меня линия разделения проходит правее. То есть мне нужно A ставить вот в левой части,
[42:17.320 --> 42:22.060]  там где ключи не больше, чем K, провести вот эту вертикальную линию, и все,
[42:22.060 --> 42:26.860]  что осталось справа, то если какая-то часть правого под ext' a, вот то что остаётся справа — это будет
[42:26.860 --> 42:31.980]  мое правое под дерево. То есть у меня корень остается слева, и мне нужно будет рекурсивно
[42:31.980 --> 42:36.780]  посплитить правого сына. То есть я понимаю, что линия разделения не пересекает левое под
[42:36.780 --> 42:38.780]  мне достаточно рассечь правое под дерево,
[42:38.780 --> 42:40.780]  рассечь правого сына.
[42:40.780 --> 42:42.780]  Вот я ровно так это и сделаю.
[42:42.780 --> 42:44.780]  Давайте напишем,
[42:44.780 --> 42:46.780]  что если
[42:46.780 --> 42:48.780]  a.x меньше бравнука,
[42:48.780 --> 42:50.780]  тогда давайте мы рекурсивно
[42:50.780 --> 42:52.780]  посплитим правого сына.
[42:52.780 --> 42:54.780]  Давайте я скажу,
[42:54.780 --> 42:56.780]  что сплит у меня всегда выучает
[42:56.780 --> 42:58.780]  пару деревьев, скажем, L и R.
[42:58.780 --> 43:00.780]  Значит, пусть
[43:00.780 --> 43:02.780]  L' R'
[43:02.780 --> 43:04.780]  это сплит
[43:04.780 --> 43:06.780]  a.right
[43:08.780 --> 43:10.780]  по ключу K.
[43:10.780 --> 43:12.780]  То есть я рекурсивно поспличу
[43:12.780 --> 43:14.780]  правое под дерево по ключу K,
[43:14.780 --> 43:16.780]  и он мне вернет пару деревьев
[43:16.780 --> 43:18.780]  L и R. То есть когда вот это посплитил,
[43:18.780 --> 43:20.780]  я вызвался рекурсивно
[43:20.780 --> 43:22.780]  от всего правого под дерево,
[43:22.780 --> 43:24.780]  он посплитил мне вот на это L'
[43:24.780 --> 43:26.780]  и вот на это R'.
[43:26.780 --> 43:28.780]  Тогда как мне теперь получить ответ
[43:28.780 --> 43:30.780]  для всего дерева?
[43:30.780 --> 43:32.780]  Ну понятно, мне нужно, чтобы в L попало
[43:32.780 --> 43:34.780]  вот это, вот это и вот это,
[43:34.780 --> 43:36.780]  все что левее линии разделения.
[43:36.780 --> 43:38.780]  То есть это a, все что раньше было слева,
[43:38.780 --> 43:40.780]  и теперь остается L' справа подвесить.
[43:40.780 --> 43:42.780]  А справа остается только L'.
[43:42.780 --> 43:44.780]  Тогда я могу назначить,
[43:44.780 --> 43:46.780]  давайте скажем так, что
[43:50.780 --> 43:52.780]  давайте я вот так
[43:52.780 --> 43:54.780]  напишу неформально, что пусть L
[43:54.780 --> 43:56.780]  это то, что раньше было слева
[43:56.780 --> 43:58.780]  от a, вот это
[43:58.780 --> 44:00.780]  левое под дерево,
[44:00.780 --> 44:02.780]  затем сама вершина a,
[44:02.780 --> 44:04.780]  затем L'.
[44:04.780 --> 44:06.780]  Вот мне нужно вот это вот дерево.
[44:06.780 --> 44:08.780]  Вот. Ну, с точки зрения кода,
[44:08.780 --> 44:10.780]  мне нужно на самом деле просто
[44:10.780 --> 44:12.780]  переназначить правого сына
[44:12.780 --> 44:14.780]  у a, сказать, что теперь a.right
[44:14.780 --> 44:16.780]  это вот это вот.
[44:16.780 --> 44:18.780]  То есть если L',
[44:18.780 --> 44:20.780]  это было вот то самое,
[44:20.780 --> 44:22.780]  что находится левее линия разделения
[44:22.780 --> 44:24.780]  в правом сыне, я это все посплитил,
[44:24.780 --> 44:26.780]  то теперь я могу смело назначить
[44:26.780 --> 44:28.780]  правым сыном a вот это самое L'.
[44:28.780 --> 44:30.780]  То есть я просто делаю a.right
[44:30.780 --> 44:32.780]  равно L',
[44:32.780 --> 44:34.780]  потому что
[44:34.780 --> 44:36.780]  вот это теперь
[44:36.780 --> 44:38.780]  правый сын a.
[44:38.780 --> 44:40.780]  Знаете, когда вот это посплитил,
[44:40.780 --> 44:42.780]  у меня вот это вот лежит правее, чем a.
[44:42.780 --> 44:44.780]  Ну, а R' просто R.
[44:44.780 --> 44:46.780]  Return LR.
[44:50.780 --> 44:52.780]  R это то, что лежит правее
[44:52.780 --> 44:54.780]  линии разделения, это в точности
[44:54.780 --> 44:56.780]  совпадает с R', потому что больше никаких других
[44:56.780 --> 44:58.780]  ну, и я просто его возвращаю.
[45:00.780 --> 45:02.780]  Так.
[45:02.780 --> 45:04.780]  Ну и теперь наоборот, пусть
[45:04.780 --> 45:06.780]  сняются в другую сторону.
[45:08.780 --> 45:10.780]  Кого?
[45:12.780 --> 45:14.780]  Кого мержить хотите?
[45:22.780 --> 45:24.780]  А смотрите, это вот за счет
[45:24.780 --> 45:26.780]  что делается на самом деле.
[45:26.780 --> 45:28.780]  Потому что мы и так уже поняли, что a должно быть
[45:28.780 --> 45:30.780]  корнем вот этого вот L.
[45:30.780 --> 45:32.780]  Левое по дереву
[45:32.780 --> 45:34.780]  его не меняется,
[45:34.780 --> 45:36.780]  произошли изменения только вправо. У меня правое по дереву
[45:36.780 --> 45:38.780]  как-то рассеклось на два.
[45:38.780 --> 45:40.780]  Давайте тогда вместо, вот у меня раньше
[45:40.780 --> 45:42.780]  правым сыном выступало все вот это по дереву,
[45:42.780 --> 45:44.780]  теперь я говорю, что правым сыном a
[45:44.780 --> 45:46.780]  выступает просто L'.
[45:46.780 --> 45:48.780]  Ну и это корректно, потому что
[45:48.780 --> 45:50.780]  то есть раньше у меня в правом по дереву были все вот эти чуваки,
[45:50.780 --> 45:52.780]  а теперь станет только
[45:52.780 --> 45:54.780]  те чуваки, которые меньше, чем K.
[45:54.780 --> 45:56.780]  Меньше лобновича, чем K.
[45:56.780 --> 45:58.780]  Их можно подвесить в качестве правого сына,
[45:58.780 --> 46:00.780]  потому что если они раньше были справа,
[46:00.780 --> 46:02.780]  то теперь тоже их можно подвесить справа.
[46:02.780 --> 46:04.780]  И вот это будет корректно на дикартовое дерево.
[46:04.780 --> 46:06.780]  Вот.
[46:06.780 --> 46:08.780]  Ну а R' остается, потому что там
[46:08.780 --> 46:10.780]  ничем не надо склеивать.
[46:10.780 --> 46:12.780]  Вот.
[46:12.780 --> 46:14.780]  Теперь наоборот, да?
[46:14.780 --> 46:16.780]  Случай a' больше, чем K.
[46:16.780 --> 46:18.780]  Вот.
[46:20.780 --> 46:22.780]  Значит, тут...
[46:24.780 --> 46:26.780]  Тут такая картинка.
[46:26.780 --> 46:28.780]  Здесь, наоборот, линия разделения,
[46:28.780 --> 46:30.780]  вот эта вот X равная K,
[46:30.780 --> 46:32.780]  будет у меня рассекать левого сына.
[46:32.780 --> 46:34.780]  Значит, вот если я рисую такую прямую,
[46:34.780 --> 46:36.780]  то у меня линия разделения как раз будет слева уже.
[46:36.780 --> 46:38.780]  Значит, мне нужно, наоборот,
[46:38.780 --> 46:40.780]  рекурсивно сплитить ни правого сына левого.
[46:42.780 --> 46:44.780]  Я понимаю, что вот это вот все,
[46:44.780 --> 46:46.780]  я понимаю, что должно быть справа,
[46:46.780 --> 46:48.780]  это должно быть R, потому что это в точности
[46:48.780 --> 46:50.780]  вершина с ключом больше, чем K.
[46:50.780 --> 46:52.780]  А вот то, что у меня отсечется от левого сына
[46:52.780 --> 46:54.780]  и будет слева,
[46:54.780 --> 46:56.780]  это будет как раз ответ L.
[46:56.780 --> 46:58.780]  Ну, поэтому я рекурсивно,
[46:58.780 --> 47:00.780]  давайте сначала скажу, что L' R',
[47:02.780 --> 47:04.780]  это результат рекурсивного запуска
[47:04.780 --> 47:06.780]  сплита правого,
[47:06.780 --> 47:08.780]  левого сына с ключом K.
[47:10.780 --> 47:12.780]  Поскольку линия разделения слева,
[47:12.780 --> 47:14.780]  то левого сына по параметру K.
[47:14.780 --> 47:16.780]  L' это вот это вот,
[47:16.780 --> 47:18.780]  все, что левее линия разделения.
[47:18.780 --> 47:20.780]  R' это вот это,
[47:20.780 --> 47:22.780]  все, что слева, но правее линии разделения.
[47:26.780 --> 47:28.780]  Ну, и теперь тоже самое,
[47:28.780 --> 47:30.780]  у меня получается L', это то, что надо вернуть в качестве L,
[47:30.780 --> 47:32.780]  потому что только L' лежит
[47:32.780 --> 47:34.780]  левее линии разделения.
[47:34.780 --> 47:36.780]  А правее линии разделения у меня R',
[47:36.780 --> 47:38.780]  А, ну и все, что было правее, чем А.
[47:38.780 --> 47:40.780]  В этом случае мне просто достаточно
[47:40.780 --> 47:47.400]  изменить левого сына у А. Если раньше это было все вот это, то теперь будет вот это. Нужно просто
[47:47.400 --> 48:00.140]  сказать, что А... ну давайте в тех же терминах напишу, что R это r'A.right. Да, это делается,
[48:00.140 --> 48:08.620]  собственно, просто переназначением левого сына у А. A.left равно r'. L это l', потому что только
[48:08.620 --> 48:25.180]  l' левее линия разделения. Ну и все, return lr. Вот такой сплит. Ну и опять условия выхода из рекурсии.
[48:25.180 --> 48:29.300]  Когда, скажем, дерево пустое, тогда сплитить нечего, и левое, и правое под деревья пустые.
[48:29.300 --> 48:36.300]  На, если у меня приходит сплит для пустого дерева А, тогда нужно вернуть пустое l, пустое r. Это условие
[48:36.300 --> 48:44.820]  выхода из рекурсии. Вот, а иначе можно куда-то спускаться и вот так вот делать. Понятно? Ну вот,
[48:44.820 --> 48:49.020]  опять же, здесь время работает логарифмическое, потому что в каждый момент времени я спускаюсь
[48:49.020 --> 48:53.780]  рекурсивно либо в левого сына, либо в правого сына. Значит, работает за глубину, а глубина логарифмическая.
[48:53.780 --> 49:00.700]  Так, отлично.
[49:00.700 --> 49:18.420]  Ну, хорошо вопрос. Я имею ввиду, что в качестве правого дерева мне хочется вернуть то,
[49:18.420 --> 49:25.260]  что вернулось вот здесь r' и все, что раньше было правым под деревом А. То есть, это скорее
[49:25.260 --> 49:30.020]  как бы математическое обозначение, что вот то r, которое, которое лежит правее линии разделения,
[49:30.020 --> 49:36.380]  это все вот это вот r', а и a'. Все вот это под деревом. В коде это отражается просто тем, вот
[49:36.380 --> 49:40.460]  таким способом, что вы изменяете левого сына у А, просто говоришь, что теперь, если раньше было все
[49:40.460 --> 49:49.140]  вот это, теперь только r', это ваш левый сын. И, ну, r это А просто будет. То есть, под дерево
[49:49.140 --> 49:56.540]  точки А. После того, как вы это сделали, у вас r это просто А. Ну, я так не хочу писать, я вот...
[49:56.540 --> 50:06.220]  В коде просто вот так вот пишете и побеждаете. Да, конечно, конечно. Я здесь как бы смешиваю
[50:06.220 --> 50:11.900]  вершину и под дерево, которое вот она задает, что все, что ниже, все, что в подделье вершины,
[50:11.900 --> 50:23.420]  я отразделяю с нее самой. А для r', ну, смотрите, здесь все очень просто. У вас корень всегда
[50:23.420 --> 50:31.460]  вершина с минимальным приоритетом среди вот этих вот всех. Но если А был корнем всего дерева,
[50:31.460 --> 50:37.900]  то есть у него был минимальный приоритет среди вообще всех, то теперь он же и будет корнем вот
[50:37.900 --> 50:45.540]  этого меньшего дерева. А неважно, что там, там какое-то под дерево, то есть оно там как-то,
[50:45.540 --> 50:49.980]  ну, оно переподвешиваться не будет, но будет какое-то вот, там будут какие-то точки, на которых
[50:49.980 --> 50:55.860]  будет построено единство возможное декартового дерева. r' вернется корнем. Давайте скажу так,
