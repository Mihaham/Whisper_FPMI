[00:00.000 --> 00:10.000]  Так, да, всем добрый день.
[00:10.000 --> 00:17.000]  Ну и в прошлый раз мы с вами закончили,
[00:17.000 --> 00:25.000]  на самом деле почти закончили обсуждение темы поиска кратчайших путей в графе.
[00:25.000 --> 00:27.000]  То есть мы рассмотрели две постановки.
[00:27.000 --> 00:33.000]  Первая постановка – это single source задача, то есть задача поиска кратчайших путей из одной вершины до всех остальных.
[00:33.000 --> 00:39.000]  Ну и рассмотрели задачу поиска кратчайших путей между, вообще говоря, всеми парами вершин.
[00:39.000 --> 00:44.000]  Мы рассмотрели несколько постановок, что делать если у нас там граф разрежный, если у нас граф плотный,
[00:44.000 --> 00:50.000]  соответственно в графе есть отрицательные ребра, если нет отрицательных ребра, что делать если есть циклы отрицательного веса,
[00:50.000 --> 00:53.000]  что делать если их нет, ну и так далее.
[00:53.000 --> 01:01.000]  В целом полный спектр задач, которые касаются кратчайших путей мы с вами рассмотрели.
[01:01.000 --> 01:06.000]  И мы в следующий раз еще коротко к этой задаче вернемся.
[01:06.000 --> 01:13.000]  Ну в целом такие основные результаты, основные алгоритмы мы с вами рассмотрели.
[01:13.000 --> 01:20.000]  Чем хочется заняться сегодня, так это рассмотреть последнюю на самом деле в нашем курсе постановку задачи,
[01:20.000 --> 01:25.000]  а именно поиска потока оптимальной величины.
[01:25.000 --> 01:29.000]  Вот это тоже задача, ну и тоже считается задачей на взвешенную графику.
[01:29.000 --> 01:35.000]  То есть я напоминаю, что после последних лекций мы с вами рассматриваем алгоритмы, которые принимают не только граф,
[01:35.000 --> 01:40.000]  но и соответственно некоторую функцию, там неважно это весовая функция, там функция на ребрах, функция на вершинах,
[01:40.000 --> 01:49.000]  ну так или иначе, в общем, некоторая функция, которая хранит полезную информацию, полезную информацию там на всяких сущностях в графе,
[01:49.000 --> 01:56.000]  соответственно с помощью этого можно сказать либо минимально остальные деревья, либо там кратчайшее стояние и там подобное.
[01:56.000 --> 02:01.000]  Так вот в чем заключается задача поиска потока максимальной величины.
[02:01.000 --> 02:08.000]  Задача на самом деле довольно-таки, ну тоже по своей постановке довольно-таки понятна, довольно-таки понятно, какие у нее могут быть применения и так далее.
[02:08.000 --> 02:15.000]  То есть самое простое, это, не знаю, у нас есть какая-то транспортная, транспортная сеть, собственно такие графы, на которых заданы там пропускные способности,
[02:15.000 --> 02:18.000]  пропускные способности сейчас называют именно транспортными сетями.
[02:18.000 --> 02:24.000]  Вот, значит, вам даны некоторые графы, соответственно есть некоторые дороги, неважно, что могут быть односторонние, на самом деле бусторонние,
[02:24.000 --> 02:30.000]  ну как правило предполагается, что дороги односторонние, в смысле можем продвигаться только из одной вершины в другую.
[02:30.000 --> 02:36.000]  Ну и соответственно на этих дорогах или, если угодно, ребрах, соответственно написана некоторая пропускная способность,
[02:36.000 --> 02:44.000]  то есть сколько, ну давайте так считать, грубо говоря, единиц товара или единиц чего-либо, какой-то жидкости, жижи и тому подобного,
[02:44.000 --> 02:49.000]  может протекать вот по этой трубе, по этой дороге и тому подобное.
[02:49.000 --> 02:58.000]  Вот, соответственно, да, ну соответственно здесь, например, изображен некоторый граф, в нем, как обычно, есть вершины, есть соответственно ребра,
[02:58.000 --> 03:02.000]  и на каждом ребре записана некоторая чиселка, это пропускная способность этого ребра.
[03:02.000 --> 03:09.000]  То есть пропускная способность говорит о том, какое максимальное количество единиц товара мы можем проточить вот по этому ребру.
[03:09.000 --> 03:12.000]  И также в этом графе у нас есть две выделенные вершины.
[03:12.000 --> 03:17.000]  Ну на самом деле может быть такое, что вершин на самом деле не две, а может быть несколько.
[03:17.000 --> 03:21.000]  Ну там в классической обстановке у нас есть две выделенные вершины.
[03:21.000 --> 03:24.000]  Одна называется источником, а другая называется стоком.
[03:24.000 --> 03:29.000]  Из источника, то есть источник может, грубо говоря, произвести сколько угодно единиц товара,
[03:29.000 --> 03:38.000]  то есть из источника мы товары, грубо говоря, испускаем, а в сток это, собственно, наша целевая точка, то место, куда мы хотим этот самый товар доставить.
[03:38.000 --> 03:41.000]  Ну и собственно задача довольно-таки понятна.
[03:41.000 --> 03:46.000]  Мы хотим максимизировать количество перевозимого Тамара в товар в единицу времени.
[03:46.000 --> 03:49.000]  Мы хотим назначить такой маршрут.
[03:49.000 --> 03:53.000]  При этом важно понимать, что должен быть не обязательно путь, то есть не обязательно просто путь.
[03:53.000 --> 03:57.000]  Это может быть просто несколько ручейков, которые выходят из источника в сток,
[03:57.000 --> 04:04.000]  так чтобы суммарное количество товара из источника в сток было, может, больше.
[04:04.000 --> 04:09.000]  Но при этом, естественно, мы хотим, чтобы по каждому ребру провозилось не более, то есть не более,
[04:09.000 --> 04:13.000]  количество товара не больше, чем та самая профессиональная способность, которая написана на нем.
[04:13.000 --> 04:17.000]  Ну вот, собственно, довольно-таки простая обстановка.
[04:17.000 --> 04:22.000]  Ну давайте, собственно, подумать, как ее, как соответственную задачу можно пережить.
[04:22.000 --> 04:29.000]  Ну для начала давайте, чтобы решить задачу, давайте, значит, для начала ее формализуем,
[04:29.000 --> 04:31.000]  то есть запишем в каких-то математических терминах,
[04:31.000 --> 04:34.000]  введем какие-то обозначения, чтобы можно было к этому обращаться при описании алгоритмов
[04:34.000 --> 04:37.000]  и вообще при доказательствах и тому подобного.
[04:37.000 --> 04:39.000]  Как я уже сказал, у нас есть транспортная сеть.
[04:39.000 --> 04:43.000]  Транспортная сеть мы будем называть некоторой граф G с выделенной парой вершин,
[04:43.000 --> 04:46.000]  которая называется источником и стоком.
[04:46.000 --> 04:49.000]  И также на этом графе введена функция прописной способности.
[04:49.000 --> 04:53.000]  Причем мы будем считать, что функция прописной способности задана не просто на ребрах,
[04:53.000 --> 04:55.000]  она задана именно на парах вершин.
[04:55.000 --> 05:02.000]  То есть для каждой пары вершин мы знаем, сколько товара можно за единицу времени провести
[05:02.000 --> 05:04.000]  из первой вершины во вторую.
[05:04.000 --> 05:08.000]  Ну причем будем считать, что если в нашем графе нет соответствующего ребра,
[05:08.000 --> 05:11.000]  то просто соответствующая пропускная способность равна нулю.
[05:11.000 --> 05:12.000]  Ну это довольно разумно.
[05:12.000 --> 05:15.000]  То есть если между парами вершин нет никакого ребра, то, соответственно,
[05:15.000 --> 05:18.000]  нисколько единиц товара мы между ними пропустить не можем.
[05:18.000 --> 05:21.000]  Вот, соответственно, вот это условие здесь и записано.
[05:22.000 --> 05:23.000]  Окей.
[05:23.000 --> 05:25.000]  Ну и, собственно, поток.
[05:25.000 --> 05:27.000]  С каким объектом мы на самом деле будем работать?
[05:27.000 --> 05:30.000]  Ну поток тоже можно вести математически.
[05:30.000 --> 05:34.000]  То есть потоком будем называть тоже функцию на парах вершин.
[05:34.000 --> 05:37.000]  Тоже, соответственно, не отрицательно значную,
[05:37.000 --> 05:41.000]  которая, соответственно, будет предварять двум соотношениям.
[05:41.000 --> 05:44.000]  Довольно понятным, про который я уже сказал, для любой пары вершин.
[05:44.000 --> 05:46.000]  Ну, во-первых, поток у нас не отрицательный.
[05:46.000 --> 05:50.000]  Во-вторых, соответственно, тот поток, который мы проводим из одной вершины в другую,
[05:50.000 --> 05:53.000]  не должен превосходить пропускной способности этого ребра.
[05:53.000 --> 05:54.000]  Вот.
[05:54.000 --> 05:56.000]  Ну и, соответственно, второй.
[05:56.000 --> 05:58.000]  Ну это, собственно, первое условие.
[05:58.000 --> 06:05.000]  Это условие, ну не знаю, значит, в физике это называется правило сохранения заряда.
[06:05.000 --> 06:07.000]  Ну у нас как бы правило сохранения потока.
[06:07.000 --> 06:13.000]  То есть сколько потока у нас вошло в узел, столько потока и должно выйти из узла.
[06:13.000 --> 06:17.000]  То есть мы считаем, что в узле, в промежуточному узле у нас поток не накапливается
[06:17.000 --> 06:19.000]  и не возникает из ниоткуда.
[06:19.000 --> 06:23.000]  То есть единственные вершины, из которых поток может продуктироваться сколько угодно
[06:23.000 --> 06:25.000]  и в которые поток может теряться сколько угодно,
[06:25.000 --> 06:29.000]  это, соответственно, источник-исток из стока я могу воспользоваться, да,
[06:29.000 --> 06:31.000]  сколько угодно потока.
[06:31.000 --> 06:35.000]  То есть поэтом там поток рождается, да, потому там баланс, естественно, не сохраняется.
[06:35.000 --> 06:38.000]  А в стоке, соответственно, этот поток, грубо, накапливается, да,
[06:38.000 --> 06:40.000]  поэтому там тоже баланс не сохраняется.
[06:40.000 --> 06:41.000]  там тоже баланс не сохраняется.
[06:41.000 --> 06:44.000]  А во всех промежутках вершинок этот баланс должен сохраняться.
[06:44.000 --> 06:46.000]  Давайте, например, рассмотрим эту вершину.
[06:46.000 --> 06:49.000]  То есть тут мы видим, что входит в него поток 1,1,1,
[06:49.000 --> 06:51.000]  и выходит поток равный 3.
[06:51.000 --> 06:55.000]  То есть 3 потока вошло, 3 единицы потока и вышло.
[06:55.000 --> 06:58.000]  То есть поток у нас в промежутках вершинок не накапливается.
[06:58.000 --> 07:02.000]  Это тоже довольно-таки естественное требование.
[07:02.000 --> 07:05.000]  Понятны ли данные определения? Есть ли вопросы?
[07:10.000 --> 07:12.000]  Окей.
[07:12.000 --> 07:14.000]  Будем считать, что все ясно.
[07:14.000 --> 07:17.000]  Определение, как мне кажется, довольно простое.
[07:17.000 --> 07:20.000]  Но как мы в дальнейшем поймем,
[07:20.000 --> 07:25.000]  этим определением нам будет довольно неудобно пользоваться при построении алгоритма.
[07:25.000 --> 07:28.000]  То есть несмотря на то, что кажется, что,
[07:28.000 --> 07:31.000]  как я уже сказал, довольно-таки естественное определение,
[07:31.000 --> 07:33.000]  мы будем пользоваться немного другим.
[07:33.000 --> 07:35.000]  Прежде чем мы перейдем к другому определению,
[07:35.000 --> 07:37.000]  давайте для начала поймем, что не так с этим определением.
[07:37.000 --> 07:41.000]  Почему с помощью него нам не удастся сразу сходу решить
[07:41.000 --> 07:45.000]  задачу поиска потока максимальной величины.
[07:45.000 --> 07:48.000]  Давайте рассмотрим пример.
[07:48.000 --> 07:51.000]  Для начала давайте закончим с определениями.
[07:51.000 --> 07:54.000]  Нужно ввести еще пару важных понятий.
[07:54.000 --> 07:56.000]  Во-первых, величина потока.
[07:56.000 --> 08:00.000]  Я все это время говорил, что мы решаем задачу поиска потока максимальной величины.
[08:00.000 --> 08:02.000]  А что вообще такое величина потока?
[08:02.000 --> 08:05.000]  Есть величина исходящего потока и есть величина входящего потока.
[08:05.000 --> 08:08.000]  По названию, я думаю, уже понятно, что величина исходящего потока
[08:08.000 --> 08:12.000]  это количество потока, которое выходит из источника,
[08:12.000 --> 08:19.000]  а величина входящего потока – это количество потока, которое входит в Восток.
[08:19.000 --> 08:26.000]  Соответственно, если мы решим задачу поиска потока максимальной величины,
[08:26.000 --> 08:31.000]  то величина входящего потока – это количество потока, которое входит в Восток.
[08:31.000 --> 08:34.000]  Есть два обозначения.
[08:34.000 --> 08:37.000]  Величина исходящего потока и величина входящего потока.
[08:37.000 --> 08:42.000]  Я думаю, интуитивно довольно ясно, что если у нас в промежутных вершинах поток
[08:42.000 --> 08:46.000]  не накапливается и не продуцируется, то весь исходящий поток,
[08:46.000 --> 08:50.000]  который генерируется в источнике, должен в итоге пойти в сток.
[08:50.000 --> 08:55.000]  На самом деле чиселка f плюс и чиселка модуль f минус – это две одинаковые чиселки.
[08:55.000 --> 08:57.000]  Действительно, мы это в будущем докажем.
[08:57.000 --> 09:02.000]  Поэтому, соответственно, это подтверждение мы докажем чуть позже.
[09:02.000 --> 09:07.000]  Но в целом важно понимать, что такое величина потока.
[09:07.000 --> 09:11.000]  То есть величину потока можно считать либо как тот суммарный поток,
[09:11.000 --> 09:15.000]  который генерируется в источнике, либо тот суммарный поток, который заходит в Восток.
[09:15.000 --> 09:20.000]  Чтобы не уточнять, какую чиселку я имею в виду, я буду говорить просто величину потока.
[09:21.000 --> 09:25.000]  Все понимают, что неважно, обчитаем исходящий поток или входящий поток.
[09:25.000 --> 09:28.000]  Это все одно и то же.
[09:34.000 --> 09:37.000]  Задача формулируется следующим образом.
[09:37.000 --> 09:43.000]  Нам дана транспортная сеть, нам дана некоторый граф, нам дана функция пропускной способности.
[09:43.000 --> 09:47.000]  И, соответственно, нам нужно найти такой поток, такую функцию на парах вершин,
[09:47.000 --> 09:51.000]  который бы максимизировал поток, при этом максимизировал величину потока.
[09:51.000 --> 09:54.000]  При этом неважно, на исходящий поток или входящий поток.
[09:54.000 --> 09:55.000]  Это все одно и то же.
[09:55.000 --> 10:00.000]  То есть необходимо найти Fs звездой, который бы давал максимум этому самому потоку.
[10:00.000 --> 10:04.000]  Но, соответственно, для графа, который изображен здесь на рисунке,
[10:04.000 --> 10:09.000]  один из возможных вариантов максимального потока изображен здесь.
[10:09.000 --> 10:16.000]  То есть мы видим, что из источника исходит 12 единиц потока и в сток входит 12 единиц потока.
[10:16.000 --> 10:21.000]  Видно, что больше мы никак поток сгенерировать не сможем,
[10:21.000 --> 10:28.000]  потому что нам не позволяют это сделать пропускные способности из источника и в сток.
[10:28.000 --> 10:31.000]  А все остальные конфигурации представлены здесь.
[10:31.000 --> 10:39.000]  Во-первых, все чиселки, которые написаны красным цветом, они, во-первых, никак не больше черных чиселок.
[10:39.000 --> 10:45.000]  А во-вторых, соответственно, мы видим, что для любой промежуточной вершины без меток
[10:45.000 --> 10:50.000]  величина входящего потока строго равна величине исходящего потока конкретно в эту вершину.
[10:50.000 --> 10:56.000]  Ну и величина протока, естественно, тут в данном примере равна 12.
[10:56.000 --> 11:01.000]  Вот. Окей.
[11:01.000 --> 11:06.000]  Соответственно, давайте попробуем придумать какой-нибудь алгоритм,
[11:06.000 --> 11:09.000]  который бы помог нам искать потоки максимально величины.
[11:09.000 --> 11:13.000]  Давайте пока не думать об эффективности, а пока просто-напросто попробуем что-нибудь придумать.
[11:13.000 --> 11:17.000]  Ну и соответственно, первая идея, которая приходит в голову, это действовать жадным.
[11:17.000 --> 11:20.000]  Давайте, собственно, будем действовать жадным образом.
[11:20.000 --> 11:28.000]  То есть просто-напросто возьмем источник, найдем какой-нибудь произвольный путь из источника в сток,
[11:28.000 --> 11:30.000]  и вот по этому пути пустим какой-то поток.
[11:30.000 --> 11:36.000]  Понятное дело, что если я из источника могу добраться до стока, то соответственно, вот по этому пути, который я нашел,
[11:36.000 --> 11:40.000]  я, соответственно, могу пустить поток какой-то величины.
[11:40.000 --> 11:42.000]  Ну, например, давайте, соответственно, тут изобразим.
[11:42.000 --> 11:48.000]  Вот, допустим, я нашел путь по этому ребру, по этому ребру.
[11:48.000 --> 11:51.000]  По этому ребру и вот по этому ребру.
[11:51.000 --> 11:53.000]  Вот, соответственно, я нашел вот такой путь.
[11:53.000 --> 11:59.000]  Ну и, соответственно, я вижу, что по этому пути я могу пустить, например, 3 единицы потока.
[11:59.000 --> 12:04.000]  Давайте опущу 3 единицы потока.
[12:04.000 --> 12:06.000]  И все.
[12:06.000 --> 12:08.000]  Что я сделаю дальше?
[12:08.000 --> 12:18.000]  Давайте снова найду какой-нибудь путь, например, не знаю, у меня есть путь вот такой, потом снова пойду вот по этому ребру и снова пойду вот по этому ребру.
[12:18.000 --> 12:22.000]  Вот вижу, что по этому пути я могу пустить еще три дополнительные единицы потока.
[12:22.000 --> 12:28.000]  Пускаю тут 3, тут 3, плюс 3, 6, тут 3, плюс 3, 6.
[12:28.000 --> 12:36.000]  Ну и соответственно и так далее, пока у меня на пути будут встречаться, пока я могу построить путь по незаполненным ребрам.
[12:36.000 --> 12:48.000]  Вот такой простой жадный алгоритм. Постоянно буду искать путь из источника в сток и, соответственно, что называется, дополнять этот путь новым потоком.
[12:48.000 --> 12:54.000]  И соответственно алгоритм останавливается в тот момент, когда у меня не получится найти путь из источника в сток.
[12:54.000 --> 13:01.000]  Понятное дело, что если у меня там какой-то момент, я вижу, что у меня вот это ребро насытилось полностью, то есть я не могу по нему пройти.
[13:01.000 --> 13:17.000]  Если я вообще не смогу найти путь из источника в сток такой, что я не смогу пройти по насыщенным ребрам, по не насыщенным ребрам, то соответственно в этом случае алгоритм останавливается.
[13:17.000 --> 13:26.000]  Ну тоже довольно простой алгоритм, жадный, и при этом кажется, что нам вообще не нужно никаких дополнительных алгоритмов тогда придумать.
[13:26.000 --> 13:39.000]  Потому что мы знаем, как искать пути, банально, наверное, знаем поиском глубину, поиском ширину, можем найти произвольный путь, вдоль этого пути пустить какой-то поток и так далее, повторять до тех пор, пока, соответственно, не остановимся.
[13:39.000 --> 13:52.000]  Но, как вы понимаете, проблема в том, проблема, как и практически любого жадного алгоритма, заключается в том, что если мы делаем все в тупую, то понятно дело, что на каждом шаге, пока мы дополняем путь, наш поток увеличиваем.
[13:52.000 --> 14:00.000]  Но проблема в том, что, допустим, в какой-то момент мы остановились, в какой-то момент мы не смогли дополнить наш поток.
[14:00.000 --> 14:08.000]  А кто, вообще говоря, сказал, что этот поток будет максимален? То есть то, что мы не можем дополнить текущий поток, вообще говоря, не означает, что мы нашли максимальный поток.
[14:08.000 --> 14:13.000]  А вдруг мы как-то находили неоптимальные пути, вдруг мы как-то поток пускали по неоптимальным сетям.
[14:13.000 --> 14:24.000]  Вдруг мы как-то для какого-то пути пустили слишком много потока, а на самом деле там можно было пустить какой-то более мелкий поток, и тогда, соответственно, в целом нам было лучше.
[14:24.000 --> 14:30.000]  То есть для такого жадного алгоритма непонятно, почему мы в итоге придем к правильному ответу.
[14:30.000 --> 14:38.000]  Ну и на самом деле мы не придем к правильному ответу, потому что довольно-таки просто придумать контрпример.
[14:38.000 --> 14:46.000]  То есть контрпример изображен здесь. То есть изображен граф, транспортная сеть, и у него у каждого ребра, соответственно, по единичной пропускной способности.
[14:46.000 --> 14:52.000]  И, значит, допустим, мы на том рахе выполняем первый путь, находим первый путь.
[14:52.000 --> 14:58.000]  Допустим, нашли вот такое ребро, вот такое ребро и вот такое ребро.
[14:58.000 --> 15:04.000]  И, соответственно, вот по этому пути мы, соответственно, пустили поток величины 1.
[15:04.000 --> 15:09.000]  Ну и, соответственно, что мы после этого видим? Переходим в следующие итерации.
[15:09.000 --> 15:19.000]  То есть снова пытаемся найти путь, и мы видим, что, соответственно, теперь в полученной транспортной сети, точнее, в полученной остаточной сети, у нас никаких дополнительных путей нет.
[15:19.000 --> 15:23.000]  То есть мы просто-напросто не можем пустить путь из источника в сток.
[15:23.000 --> 15:27.000]  Такой, чтобы он проходил по незаполненным ребрам.
[15:27.000 --> 15:30.000]  Потому что у нас есть незаполненное ребро. Вот это ребро, вот это ребро.
[15:30.000 --> 15:34.000]  Вот это ребро у нас, соответственно, между ними, то есть от одного к другому мы добраться не можем.
[15:34.000 --> 15:36.000]  Ну, соответственно, всё. На этом наш алгоритм останавливается.
[15:36.000 --> 15:41.000]  Но при этом мы видим, что очевидно, что наш поток не является потоком максимальной величины.
[15:41.000 --> 15:50.000]  Потому что можно было пустить, например, если мы, наверное, опустили два потока, один по верхней ветке, другой по нижней ветке, то, соответственно, мы получили поток равный двум.
[15:50.000 --> 15:53.000]  Что, во-первых, явно больше, чем то, что мы нашли до этого.
[15:53.000 --> 16:02.000]  А, во-вторых, он явно является потоком максимальной величины, потому что пропускная способность источника и пропускная способность стока, они равны двум.
[16:02.000 --> 16:10.000]  То есть проблема же одного подхода, который мы только что описали, состоит в том, что если мы в какой-то момент нашли плохой ручеёк,
[16:10.000 --> 16:17.000]  что если в какой-то момент мы нашли плохой путь, то в будущем мы это никак не исправим.
[16:17.000 --> 16:23.000]  То есть хотелось бы сказать, что вот этот путь мы использовали в какой-то момент зря.
[16:23.000 --> 16:29.000]  Окей, мы его нашли, но хотелось бы в какой-то момент как-то понять, что этот путь мы нашли зря,
[16:29.000 --> 16:37.000]  и если бы мы его не использовали, мы бы получили дополнительную возможность пустить поток вот так и пустить поток вот так.
[16:37.000 --> 16:40.000]  Хотелось бы исправлять ошибки прошлого.
[16:40.000 --> 16:48.000]  Если бы мы в какой-то момент пустили плохой ручеёк, хотелось бы как-то либо от него избавиться, либо его как-то исправить и так далее.
[16:48.000 --> 16:56.000]  Ну и смотрите, в целом какая идея. Идея в том, что даже если у нас есть такой ручеёк плохой,
[16:56.000 --> 17:03.000]  мы же что на самом деле можем сказать? Можем сказать, что давайте пустим поток вот здесь, потом поток пойдёт вот сюда в обратном направлении,
[17:03.000 --> 17:10.000]  и потом пойдёт вот сюда. Мы тут видим, что в целом у нас встречаются два потока, которые текут в разных направлениях.
[17:10.000 --> 17:15.000]  Но в целом баланс сохраняет. Если у меня один поток течёт в одну сторону, второй поток течёт в другую сторону,
[17:15.000 --> 17:23.000]  то они друг друга взаимно уничтожают, и поэтому по этому пути, по центральному течёт 0 единиц потока.
[17:23.000 --> 17:27.000]  А это нас устраивает, потому что 0 явно меньше равно, чем единица.
[17:27.000 --> 17:35.000]  То есть хотелось бы уметь пускать потоки либо в обратном направлении, либо коротко говоря, исправлять какие-то плохие потоки или ручейки.
[17:35.000 --> 17:43.000]  Вот. Идея понятна? Ну то есть в целом, да? Чего бы хотелось?
[17:43.000 --> 17:50.000]  Чего бы хотелось и соответственно, чем нас не устраивает текущий алгоритм жадный?
[17:57.000 --> 18:24.000]  Ну, собственно.
[18:24.000 --> 18:34.000]  Да. Далее мотивация. Ну, смотрите. В чём изъян данного подхода?
[18:34.000 --> 18:45.000]  Вот, допустим, вот для этого графа я нашёл вот такой путь.
[18:45.000 --> 18:51.000]  Вот. Что нам говорит этот самый жадный алгоритм? Жадный алгоритм говорит следующее.
[18:51.000 --> 18:58.000]  Давайте снова посмотрим наш граф. Вот. Ну, с уже введённым на нём потоком.
[18:58.000 --> 19:04.000]  Вот. И попробуем вот в остаточной сети. То есть в той конфигурации, которая у нас есть.
[19:04.000 --> 19:07.000]  Давайте попробуем в ней пустить ещё какой-то путь.
[19:07.000 --> 19:13.000]  Но давайте посмотрим вот на этот граф. Можем ли мы в этом графе пустить какой-то путь, который проходит по незаполненным ребрам?
[19:13.000 --> 19:21.000]  И кажется, что нет. Кажется, что нет. Почему? Потому что сюда я из С пустить путь не могу.
[19:21.000 --> 19:27.000]  Могу пустить вот сюда. Но когда я добрался вот сюда, вот до этой вершины, из неё я уже никуда деться не могу.
[19:27.000 --> 19:31.000]  Почему? Потому что сюда я двигаться не могу, потому что это ребро заполнено.
[19:31.000 --> 19:37.000]  Сюда я двигаться не могу, потому что у меня в принципе нет ребра из этой вершины Х в вершину Y.
[19:37.000 --> 19:42.000]  Ну и соответственно всё. То есть в итоге получается, что из вершины С я никак не могу добраться до вершины Т.
[19:42.000 --> 19:51.000]  А всё почему? Потому что я изначально выбрал неправильный ручьёк. Изначально вот этот путь мне в принципе был не нужен.
[19:51.000 --> 20:06.000]  Но с другой стороны, если бы я изначально выбрал вот такой путь хороший, сначала вот так, а потом вот так, то я бы получил подок максимальной вершины.
[20:06.000 --> 20:11.000]  Вот. Но вот меня не повезло, и я выбрал вот такой путь.
[20:12.000 --> 20:20.000]  И хотелось бы иметь какой-то способ по этому алгоритме довольно простому, хотелось бы иметь какой-то способ исправлять плохие ручьёки.
[20:20.000 --> 20:27.000]  То есть вот я вижу что я получил плохой ручьёк, ну вот хотелось бы уметь как-то его исправлять.
[20:27.000 --> 20:33.000]  То есть хотелось бы во-первых понимать, что он, наверное, плохой, да, что он мне не позволяет поучить дополнительные пути.
[20:33.000 --> 20:37.000]  Вот, а во-вторых, если я понял, что он плохой, хотелось бы уметь его как-то исправить.
[20:37.000 --> 20:42.000]  Скажем, заменить вот это ребро там, вот это ребро, и добавить вот это ребро.
[20:42.000 --> 20:46.000]  Ну, точнее, поток. Понятно?
[20:55.000 --> 20:59.000]  Окей. Соответственно, каким образом мы это будем делать?
[20:59.000 --> 21:03.000]  Ну, значит, чтобы научиться это делать, давайте, собственно, как я уже сказал,
[21:03.000 --> 21:07.000]  ведем несколько иное определение потока.
[21:07.000 --> 21:12.000]  Оно полностью эквивалентно тому, что было до этого, да, то есть в нем, на самом деле,
[21:12.000 --> 21:16.000]  получаются те же самые величины потоков и так далее, но просто вот это определение потока,
[21:16.000 --> 21:21.000]  чуть более сложное, которое мы сейчас рассмотрим, оно просто более удобно на практике, на самом деле.
[21:21.000 --> 21:24.000]  И это, соответственно, понятие симметризованного потока.
[21:24.000 --> 21:27.000]  Значит, другое определение потока.
[21:27.000 --> 21:33.000]  Значит, поток мы будем называть функцию, потом мы будем называть функцию, кстати,
[21:33.000 --> 21:38.000]  тут надо брать R+, просто, из пар вершин в действительные числа,
[21:38.000 --> 21:41.000]  которые удовлетворяют следующим соотношениям.
[21:41.000 --> 21:47.000]  Во-первых, будем использовать следующую, выполняется первое соотношение.
[21:47.000 --> 21:52.000]  Поток антисимметричен, то есть если из вершины В, вершины У течет поток F,
[21:52.000 --> 21:55.000]  то в обратном направлении течет поток минус F.
[21:55.000 --> 22:00.000]  То есть, грубо говоря, если у вас есть две вершины, У и В,
[22:00.000 --> 22:06.000]  и в одном направлении течет поток 10, то мы считаем, что в обратном направлении течет поток минус 10.
[22:06.000 --> 22:11.000]  И вот тут работает чистая аналогия, не знаю, прошу прощения студентов,
[22:11.000 --> 22:15.000]  но тут работает чистая аналогия с протеканием электрического тока.
[22:15.000 --> 22:22.000]  Почему? Потому что если у вас есть провод, то считается, что положительные частицы двигаются в одну сторону,
[22:22.000 --> 22:25.000]  или можно считать, что отрицательные заряж 게стицы двигаются в обратную сторону,
[22:25.000 --> 22:27.000]  это абсолютно эквалентная история.
[22:27.000 --> 22:31.000]  Тут тоже самое, то есть если положительный поток течет в одном направлении,
[22:31.000 --> 22:35.000]  то можно таким же успехом считать, что и отрицательный поток течет в обратном направлении.
[22:35.000 --> 22:39.000]  Соответственно, поток симметризован.
[22:39.000 --> 22:47.000]  То есть мы считаем важный момент, что между каждой парой вершин у нас обязательно есть какое-то ребро.
[22:47.000 --> 22:50.000]  Точнее так. Между каждой парой виши у нас есть два ребра.
[22:50.000 --> 22:53.000]  Одно в одном направлении, второе в обратном направлении.
[22:53.000 --> 22:56.000]  И если по этому ребру в одном направлении течет какой-то положительный поток,
[22:56.000 --> 22:59.000]  то в обратном направлении течет отрицательный поток точно такой же величины.
[22:59.000 --> 23:02.000]  Второй момент.
[23:02.000 --> 23:05.000]  Ну, второй момент, естественно, мы должны гарантировать,
[23:05.000 --> 23:09.000]  что поток никак не больше, чем пропускная способность.
[23:09.000 --> 23:15.000]  Значит, на этом тоже нужно остановиться подробнее.
[23:15.000 --> 23:19.000]  Смотрите, я избавляюсь от требований, что у меня поток обязательно должен быть больше равен нуля.
[23:19.000 --> 23:23.000]  Почему? Потому что у меня в обратном направлении всегда течет поток отрицательной величины.
[23:23.000 --> 23:25.000]  Это во-первых.
[23:25.000 --> 23:30.000]  А во-вторых, отрицательные вершины, то есть отрицательные потоки мне тоже ничего не портят.
[23:30.000 --> 23:34.000]  Почему? Давайте посмотрим, например, вот сюда.
[23:34.000 --> 23:38.000]  Что я тут вижу? Я тут вижу, что у меня есть обычное ребро,
[23:38.000 --> 23:40.000]  которое идет сверху вниз.
[23:41.000 --> 23:45.000]  И вот сверху вниз, соответственно, течет поток величины 1.
[23:45.000 --> 23:50.000]  Но в то же время у меня есть такое же обратное ребро снизу вверх.
[23:50.000 --> 23:53.000]  Напоминаю, что такое пропускная способность 0.
[23:53.000 --> 23:57.000]  Пропускная способность 0 просто означает, что в исходном графе этого ребра просто нет.
[23:57.000 --> 24:01.000]  Но я просто это ребро добавляю эффективно, чтобы было удобнее анализировать.
[24:01.000 --> 24:05.000]  То есть я просто-напросто для каждого ребра добавляю эффективное обратное ему.
[24:05.000 --> 24:07.000]  Просто нулевой пропускной способности.
[24:07.000 --> 24:09.000]  И оно на самом деле ничего не портит. Почему?
[24:09.000 --> 24:14.000]  Потому что вот по этому ребру снизу вверх у меня теперь течет поток минус единицы,
[24:14.000 --> 24:16.000]  ну а минус единицы меньше ребра на нуля.
[24:16.000 --> 24:21.000]  То есть что сверху вниз, что снизу вверх, у меня соответственно выполняется соотношение
[24:21.000 --> 24:23.000]  на максимальный размер потока.
[24:27.000 --> 24:30.000]  То есть тут как бы тоже все кажется нормально.
[24:30.000 --> 24:32.000]  Ну и наконец третий пункт.
[24:32.000 --> 24:37.000]  Давайте сравним третий пункт с пунктом, который у нас был в определении обычного потока.
[24:37.000 --> 24:40.000]  О чем у нас был второй пункт по обычному определению потока?
[24:40.000 --> 24:47.000]  Значит мы говорили, что ни в какой промежутке на вершине у нас поток не накапливается и соответственно не производится.
[24:47.000 --> 24:49.000]  И для этого мы записывали вот такой раз.
[24:49.000 --> 24:58.000]  Мы записывали, что сумма по ребрам, которые исходят из вершины В,
[24:58.000 --> 25:01.000]  равна сумме потоков по ребрам, которые входят В.
[25:01.000 --> 25:03.000]  То есть возникает некоторая несимметричность.
[25:03.000 --> 25:06.000]  То есть мы отдельно должны учитывать ребра, которые исходят из вершины
[25:06.000 --> 25:09.000]  и отдельно должны учитывать ребра, которые входят в вершину.
[25:09.000 --> 25:12.000]  В случае симметризованного потока все записывается гораздо проще.
[25:12.000 --> 25:18.000]  То есть так как у меня теперь каждому исходящему ребру соответствует входящее ребро,
[25:18.000 --> 25:25.000]  то мне достаточно всего лишь написать, что сумма по всем ребрам, которые исходят из вершины равна 0.
[25:27.000 --> 25:30.000]  Ну понятно почему, потому что давайте посмотрим.
[25:30.000 --> 25:32.000]  У меня допустим был какой-то граф.
[25:33.000 --> 25:40.000]  И у него были какие-то такие потоки.
[25:49.000 --> 25:53.000]  Так вот я на самом деле утверждаю, что теперь мне достаточно всего лишь учитывать только исходящие ребра.
[25:53.000 --> 25:54.000]  Почему?
[25:54.000 --> 25:59.000]  Потому что я знаю, что для каждого ребра у меня есть соответствующее обратное ребро.
[26:00.000 --> 26:03.000]  И соответственно если в эту вершину у меня входят 2 единицы потока,
[26:03.000 --> 26:06.000]  то это означает что по этому же ребру у меня исходит 2 единицы потока,
[26:06.000 --> 26:12.000]  или если минус 2 единиц потока, или если по этому ребру у меня входят 6 единиц потока в эту вершину
[26:12.000 --> 26:18.000]  то по обратному ребру выходит минус 6 единиц потока.
[26:19.000 --> 26:23.000]  Ну и соответственно мне теперь достаточно посчитать 5 плюс 3,
[26:23.000 --> 26:25.000]  минус 2, минус 6.
[26:25.000 --> 26:33.000]  И, соответственно, условия баланса, условия того, что у меня в никакой вершине не накапливается поток и не производится поток,
[26:33.000 --> 26:42.000]  собственно, заключается в том, что у меня сумма зарядов, которые исходят из данного узла, из данной вершины, просто равна нулю.
[26:42.000 --> 26:46.000]  То есть у меня заряды не производятся, то есть не возникают из ниоткуда.
[26:46.000 --> 26:53.000]  И поток в вершине тоже не возникает из ниоткуда. Вот такие дела.
[26:53.000 --> 26:56.000]  Понятно определение симметризованного потока?
[26:56.000 --> 27:02.000]  Понятен смысл каждого из трёх пунктов и в целом, для чего они нужны.
[27:06.000 --> 27:10.000]  В целом, на всё это определение можно смотреть чисто с формальной точки зрения,
[27:10.000 --> 27:16.000]  что у нас есть некоторая функция, которая, во-первых, антисимметрична, во-вторых, она ограничена, специально ограничена функцией С,
[27:16.000 --> 27:25.000]  ну и в-третьих, сумма для любой вершины В, сумма по РВУ равна нулю, кроме естественной вершины СТ.
[27:25.000 --> 27:34.000]  То есть СТ это отдельные выделенные вершины, которым можно генерировать новый поток и, соответственно, принимать в себя поток.
[27:34.000 --> 27:42.000]  В целом, как мне кажется, тут работает идеальная аналогия с электрическими цепями.
[27:42.000 --> 27:52.000]  Во-первых, по каждому проводнику, сколько положительного заряда течёт в одном направлении, столько отрицательного заряда течёт в обратном направлении.
[27:52.000 --> 27:57.000]  Плюс в узлах электрической цепи у нас не накапливается заряд, это, соответственно, третий пункт.
[27:58.000 --> 28:03.000]  Ну а второе, собственно, ограничение просто на пропускную способность каждого проводника.
[28:08.000 --> 28:10.000]  Так, есть вопросы по определению?
[28:10.000 --> 28:11.000]  Окей.
[28:26.000 --> 28:35.000]  Да, ну и, соответственно, первое, про что мы поговорим, это, собственно, как раз таки с помощью симметризованного потока давайте докажем утверждение, которое я анонсировал.
[28:35.000 --> 28:40.000]  Давайте накажем, что величина исходящего потока в точности равна величине входящего потока.
[28:40.000 --> 28:50.000]  А напомнили, что величина исходящего потока – это сумма потоков,...
[28:50.000 --> 29:02.980]  Давайте просто напомним, что эти два подока равны, fundamentals only for enhancing the
[29:02.980 --> 29:14.980]  Давайте я возьму все возможные пары v и u, все возможные пары вершин, и просуммирую функцию потока вот этих пар.
[29:14.980 --> 29:18.980]  Я утверждаю, что нам будет равна 0. Почему?
[29:22.980 --> 29:27.980]  Почему сумма f по всем парам v и u равна 0?
[29:27.980 --> 29:29.980]  Откуда это следует?
[29:32.980 --> 29:39.980]  У нас каждому ребру есть противоположное, которое его в ноль уводит.
[29:39.980 --> 29:58.980]  По первому свойству потока. Для любой пары v и u есть пара v и v. У меня все слагаемые разбиваются на пары f1-2, f2-1, f1-3 и 3-1.
[29:58.980 --> 30:01.980]  Соответственно они взаимно уничтожатся, потому что у меня поток антисимметричен.
[30:01.980 --> 30:06.980]  То есть можно считать, что просто по антисимметричности потока.
[30:06.980 --> 30:15.980]  Теперь я возьму эту же сумму и выделю слагаемые с первой координатой s и с первой координатой t.
[30:15.980 --> 30:20.980]  То есть просто вытащу соответствующую сумму из этой двойной суммы.
[30:20.980 --> 30:27.980]  В итоге останется такая сумма, в которой первая координата не равна s и не равна t.
[30:27.980 --> 30:32.980]  Я утверждаю, что эта сумма тоже равна нулю. А это почему?
[30:36.980 --> 30:45.980]  То есть если я возьму исходную двойную сумму и выделю из нее все f, которые в качестве первой координаты выступают s или t,
[30:45.980 --> 30:50.980]  и оставлю только двойную сумму без первой координаты s и t, то у меня тоже останется 0. Почему?
[30:50.980 --> 31:01.980]  Это будет сумма по всем ребрам, которые входят и исходят из не вершины s и t, а для каждой вершины это 0.
[31:01.980 --> 31:05.980]  Ну да, то есть можно написать вот так.
[31:05.980 --> 31:15.980]  Можно взять в скобке и сказать, что для любого слагаемого отсюда, то есть любое слагаемое, которое указано в скобках, оно равно нулю. Почему?
[31:15.980 --> 31:18.980]  А это просто по третьему свойству.
[31:18.980 --> 31:27.980]  То есть если первая координата не равна s или не равна t, то сумма по всем u, fvu, равна нулю.
[31:27.980 --> 31:31.980]  Но окажется, что у нас тут ровно это написано. То есть это вот третье свойство.
[31:31.980 --> 31:39.980]  Отлично. То есть у нас в итоге осталась сумма по всем su и сумма по всем tu.
[31:39.980 --> 31:42.980]  По всем возможным u.
[31:42.980 --> 31:52.980]  Ну и соответственно, чтобы завершить доказательство, что нужно понять, нужно понять, что fsu, точнее,
[31:52.980 --> 31:55.980]  ну короче говоря, я утверждаю, что на самом деле мы уже все доказали.
[31:55.980 --> 31:59.980]  Почему? Потому что у нас есть вот такая вот сумма, и эта сумма равна нулю.
[31:59.980 --> 32:01.980]  Но окажется, это ровно то, чего мы хотели.
[32:01.980 --> 32:07.980]  То есть единственное, тут можно поменять местами координаты и получить вот такую штуку.
[32:07.980 --> 32:18.980]  То есть из этого следует, давайте допишем, сумма fsu всевозможным u равна сумме fut всевозможным u.
[32:18.980 --> 32:22.980]  Но это, кажется, ровно то, чего мы хотели.
[32:22.980 --> 32:27.980]  Величина исходящих потоков точно все равно величине входящего потока.
[32:27.980 --> 32:29.980]  Ну вот.
[32:32.980 --> 32:34.980]  Ну вот.
[32:36.980 --> 32:39.980]  Так, вопросов нет, да? Все хорошо.
[32:46.980 --> 32:48.980]  Окей.
[32:48.980 --> 32:50.980]  Идем дальше.
[32:50.980 --> 32:54.980]  И, соответственно, давайте вернемся к алгоритму.
[32:54.980 --> 32:56.980]  Вот мы ввели симметризованный поток.
[32:56.980 --> 32:59.980]  Даже с помощью понятия симметризованного потока доказали.
[32:59.980 --> 33:04.980]  Но остается непонятным, что изменилось.
[33:04.980 --> 33:12.980]  Почему понятие симметризованного потока позволяет нам, скажем так, решить исходную задачу простыми способами?
[33:12.980 --> 33:20.980]  Вот на самом деле утверждаю, что я могу оставить тот алгоритм, который мы обсуждали в самом начале, без изменений, вообще никак.
[33:20.980 --> 33:26.980]  Всего лишь ведя понятие симметризованного потока, и при этом мы получим хороший алгоритм, который будет решать нашу исходную задачу.
[33:26.980 --> 33:28.980]  Давайте посмотрим как.
[33:28.980 --> 33:31.980]  Ну вот, соответственно, я изобразил то, что было у нас до этого.
[33:31.980 --> 33:39.980]  То есть у нас снова есть граф с простыми способностями 1, 1, 1, 1, 1.
[33:39.980 --> 33:42.980]  Ну и плюс дополнительно я нарисовал еще обратные ребра.
[33:42.980 --> 33:44.980]  То есть для каждого ребра.
[33:44.980 --> 33:48.980]  Точнее, я нарисовал еще несуществующие ребра в обратном направлении.
[33:48.980 --> 33:50.980]  Теперь пропускную способность 0.
[33:53.980 --> 34:01.980]  Любимый Another.
[34:01.980 --> 34:03.980]  вкусноvisee illness()
[34:03.980 --> 34:05.980]  по этому ребру, пустил поток
[34:05.980 --> 34:07.980]  Вот нашёл какой-то путь
[34:07.980 --> 34:15.000]  пустил по этому пути ручеёк
[34:15.000 --> 34:17.000]  сам поток написан красным цветом
[34:17.000 --> 34:19.000]  при этом обращу внимание, что
[34:19.000 --> 34:23.000]  если в прямом направлении течёт единиц потока, то в обратном течёт минус единица
[34:23.000 --> 34:25.000]  тут течёт к прямому направлению единиц потока
[34:25.000 --> 34:27.000]  в обратном направлении минус единица
[34:27.000 --> 34:30.000]  вот have и так далее
[34:30.000 --> 34:40.000]  Напоминаю, до этого, без симметризации потока, мы на этом просто останавливались и говорили,
[34:40.000 --> 34:51.000]  что в нашем графе больше нет никакого пути. Давайте вернемся и покажем, что мы изобразили какой-то поток.
[34:51.000 --> 35:00.000]  И, соответственно, на этом останавливались и говорили, что в этом графе больше нечего добавлять,
[35:00.000 --> 35:06.000]  поэтому, соответственно, алгоритм останавливается. А вот в этом новом графе, в случае симметризованного потока, это не так.
[35:06.000 --> 35:10.000]  Потому что в этом графе я могу пустить еще дополнительный поток. Давайте подумаем, какой.
[35:10.000 --> 35:16.000]  Смотрите, во-первых, из S я могу пустить поток вот по этой дуге.
[35:17.000 --> 35:22.000]  Почему? Потому что профессиональная способность этой дуге равна 1, а по ней сейчас счет 0.
[35:22.000 --> 35:25.000]  Поэтому по ней я еще могу пустить дополнительную единицу.
[35:25.000 --> 35:30.000]  Теперь находимся вот в этой вершине. Давайте подумаем, могу ли я куда-то двигаться из этой вершины.
[35:30.000 --> 35:33.000]  Смотрите, поэтому рибро я двигаться не могу, потому что это рибро заполнено.
[35:33.000 --> 35:37.000]  Поэтому рибро я двигаться не могу, потому что оно в другом направлении.
[35:37.000 --> 35:44.000]  Но, смотри, теперь я могу использовать вот это рибро внезапно. Вот это фиктивное рибро.
[35:44.000 --> 35:50.000]  Почему я могу его использовать? Потому что его профессиональная способность равна 0, но по нему сейчас течет минус 1.
[35:50.000 --> 35:55.000]  Согласитесь, что я к минусу единицы могу добавить еще единицу потока, и все равно я не буду превосходить 0.
[35:55.000 --> 36:00.000]  У меня теперь появилась возможность как бы исправить старый поток.
[36:00.000 --> 36:07.000]  Сверху вниз я пустил поток, но мне он не нужен.
[36:07.000 --> 36:14.000]  Вот у меня самый алгоритм в итоге подсказал мне, что давай-ка я опущу поток снизу вверх и убью этот поток, который течет сверху вниз.
[36:14.000 --> 36:19.000]  То есть, грубо говоря, просто скажу, что вот этот поток в середине мне просто не нужен.
[36:19.000 --> 36:25.000]  Ну и, соответственно, вот тут, понятно дело, тоже могу пустить единицу потока.
[36:25.000 --> 36:30.000]  Ну и, соответственно, что вот тут происходит? Тут теперь течет единица потока в обратном направлении минус 1.
[36:30.000 --> 36:35.000]  Тут теперь течет ноль потока, и тут теперь течет ноль потока.
[36:35.000 --> 36:41.000]  Почему? Потому что я снизу вверх пустил единицу потока, минус 1 плюс 1 ноль, а 1 минус 1 тоже ноль.
[36:41.000 --> 36:45.000]  Здесь я пустил единицу потока, тут минус единица.
[36:45.000 --> 36:50.000]  Ну и вот, соответственно, если вы посмотрите, то все ребра разбиваются на пары.
[36:50.000 --> 36:55.000]  То есть поток антисимметричен, то есть если в одном направлении течет единица, то в обратном минус единица.
[36:55.000 --> 37:00.000]  Ну и при этом все потоки, они не превосходят пропускной способности каждого ребра.
[37:00.000 --> 37:04.000]  И при этом, смотрите, действительно мы получили поток максимальной величины.
[37:04.000 --> 37:09.000]  Давайте, кстати, убедимся, что в этом графе больше ничего дополнить нельзя.
[37:09.000 --> 37:12.000]  Давайте просто посмотрим и попробуем что-то добавить.
[37:12.000 --> 37:16.000]  Ну, смотрите, вот сюда я ничего добавить не могу, потому что тут уже ребро заполнено.
[37:16.000 --> 37:19.000]  И вот поэтому ребро тоже пустить ничего не могу, потому что тут все заполнено.
[37:19.000 --> 37:22.000]  Ну все, как бы ничего дополнительного пустить не могу.
[37:22.000 --> 37:25.000]  И плюс, действительно, я получил поток максимальной величины.
[37:25.000 --> 37:27.000]  Вот.
[37:27.000 --> 37:30.000]  Пример понятен?
[37:30.000 --> 37:33.000]  Понятно, как нам тут могла симметризация потока.
[37:33.000 --> 37:37.000]  То есть, грубо говоря, симметризация нам помогла тем, что у нас появились эффективные ребра в обратном направлении,
[37:37.000 --> 37:40.000]  с помощью которых мы как раз и можем исправлять старые плохие пути.
[37:40.000 --> 37:42.000]  Да, какой-то вопрос был?
[37:45.000 --> 37:47.000]  Кажется, все понятно.
[37:47.000 --> 37:48.000]  А, ну окей, отлично.
[37:48.000 --> 37:49.000]  Все понятно, да.
[37:49.000 --> 37:53.000]  Да, ну единственное, ну все понятно, я надеюсь, про пример, да,
[37:53.000 --> 37:56.000]  потому что, на самом деле, даже тут не очень понятно.
[37:56.000 --> 37:59.000]  Ну хорошо, вот я привел конкретный пример, да, когда у нас было все плохо.
[37:59.000 --> 38:02.000]  И вот привел конкретный пример, когда у нас стало все хорошо.
[38:02.000 --> 38:07.000]  С помощью симметризации мы смогли найти в данном конкретном графе оптимальный поток.
[38:07.000 --> 38:10.000]  Но вообще говоря, непонятно, почему это работает всегда.
[38:10.000 --> 38:14.000]  Ну а что, если я смогу привести еще пример, в котором даже это не помогает?
[38:14.000 --> 38:19.000]  Ну, на самом деле, не могу, потому что есть соответствующая...
[38:19.000 --> 38:21.000]  Ну да.
[38:21.000 --> 38:23.000]  Короче, план, на самом деле, алгоритм.
[38:23.000 --> 38:24.000]  Давайте еще раз напомню алгоритм.
[38:24.000 --> 38:26.000]  Алгоритм очень простой.
[38:26.000 --> 38:27.000]  Действуешь одним образом.
[38:27.000 --> 38:29.000]  Просто ищете произвольный путь.
[38:29.000 --> 38:30.000]  Пускайте поток.
[38:30.000 --> 38:31.000]  Ну, пускайте ручеек.
[38:31.000 --> 38:32.000]  Снова ищете какой-нибудь путь.
[38:32.000 --> 38:33.000]  Пускайте ручеек.
[38:33.000 --> 38:35.000]  Ну и так далее, пока вы можете найти путь.
[38:35.000 --> 38:39.000]  Как только вы пути найти не можете, то это означает, что вы, по сути, решили задачу.
[38:39.000 --> 38:41.000]  И вот, собственно, главный вопрос, а почему это...
[38:41.000 --> 38:45.000]  Ну, почему, если вы не смогли найти путь, почему вы на самом деле решили задачу?
[38:45.000 --> 38:48.000]  Почему же один алгоритм действительно работает?
[38:48.000 --> 38:51.000]  Ну, соответственно, давайте разбираться.
[38:51.000 --> 38:58.000]  Ну, то есть сейчас мы переходим к тому, что мы докажем утверждение о том, что действительно все работает так, как надо.
[38:58.000 --> 39:04.000]  И отсутствие дополнительных путей действительно будет давать нам правильный результат.
[39:04.000 --> 39:11.000]  Ну, давайте докажем лему до перерыва, а после перерыва, соответственно, перейдем к утверждению.
[39:11.000 --> 39:13.000]  В общем, перерыв будет.
[39:13.000 --> 39:17.000]  Так, давайте ведем несколько определений.
[39:17.000 --> 39:20.000]  Значит, первое определение – это остаточная сеть для графа G.
[39:20.000 --> 39:30.000]  Остаточная сеть для сети G и потока F называется сеть с теми же самыми вершинами,
[39:30.000 --> 39:34.000]  возможно, с другим набором ребер и другой пропускной способностью,
[39:34.000 --> 39:41.000]  в котором пропускная способность ребер просто равна исходной способности минус текущий поток.
[39:41.000 --> 39:45.000]  Короче говоря, все довольно просто.
[39:45.000 --> 39:53.000]  Вот у меня был исходный граф G или исходная пропускная транспортная сеть G.
[39:53.000 --> 39:56.000]  Черным цветом обозначены исходные пропускные способности.
[39:56.000 --> 40:01.000]  Красным цветом обозначен текущий поток.
[40:01.000 --> 40:04.000]  Что такое остаточная сеть?
[40:04.000 --> 40:09.000]  Остаточная сеть – это просто-напросто некоторые новые графы,
[40:09.000 --> 40:14.000]  в котором на ребрах написано, сколько еще поток я могу пустить по этому ребру.
[40:14.000 --> 40:19.000]  Вот у меня есть ребро пропускной способностью 3 по которому течет поток 1.
[40:19.000 --> 40:20.000]  Что это означает?
[40:20.000 --> 40:26.000]  Это означает, что в остаточной сети будет тоже самое ребро, но с пропускной способностью 2.
[40:26.000 --> 40:31.280]  Это означает, что в остаточной сети будет обратное ребро с пропускной способностью 1.
[40:31.280 --> 40:32.280]  Почему?
[40:32.280 --> 40:35.280]  С歷olt мы сами же понимаем, что есть эффективное ребро,
[40:35.280 --> 40:39.280]  по которому течет минус 1 dagegen из-за пропускной способности в 0.
[40:39.280 --> 40:43.280]  Это означает, что в обратном направлении, я могу пустить 1 — с потока.
[40:43.280 --> 40:49.480]  Давайте посмотрим вот сюда. В исходном графе у меня пропускная способность 5, и в этом направлении
[40:49.480 --> 40:54.440]  у меня уже течет 2 единицы потока. Что это означает? Это значит, что в остаточной сети у меня будет
[40:54.440 --> 40:59.360]  это ребро с пропускной способностью 3, и в обратном направлении будет ребро с пропускной способностью 2.
[40:59.360 --> 41:05.240]  Остаточная сеть – это просто-напросто сколько еще поток я могу пустить по этому ребру, и все.
[41:05.240 --> 41:14.760]  Когда я говорю про остаточную сеть, я просто-напросто говорю про граф,
[41:14.760 --> 41:18.520]  в котором, соответственно, у меня уже, грубо говоря, обновились пропускные способности.
[41:18.520 --> 41:31.480]  Ну и, соответственно, арифметика потоков. Мы с вами говорили про ручейки всякие,
[41:31.560 --> 41:35.680]  про то, что мы ищем какой-то путь, добавляем поток графа и так далее. Давайте, собственно,
[41:35.680 --> 41:38.680]  докажем, что мы действительно можем взять два потока и сложить их. И более того,
[41:38.680 --> 41:44.360]  можем взять два потока и вычесть один поток из другого. Арифметика потоков.
[41:44.360 --> 41:52.720]  Потоки можно складывать и потоки можно вычитать. Первая лемма. Пусть у меня есть f-поток в g и h-поток
[41:52.720 --> 41:57.880]  в остаточной сети g. Вот на это прошу очень сильно обратить внимание. Смотрите, арифметика потоков
[41:57.880 --> 42:01.900]  работает только тогда, ну точнее, сумма потоков работает только когда у меня f.
[42:01.900 --> 42:07.560]  Это поток в исходной графе g, а h это поток в остаточной сети от f.
[42:07.640 --> 42:14.880]  То есть f- это поток в исходной сети, h- это поток уже в остаточной сети.
[42:14.880 --> 42:22.400]  Вот тогда, если у меня f-поток в g, а h-поток в gf, тогда f, плюс h... Ну просто-напросто
[42:22.400 --> 42:26.160]  арифметическая сумма по координатам, то есть просто арифметическая сумма двух
[42:26.160 --> 42:36.640]  будет являться потоком в исходном графеже и при этом величина этого потока будет
[42:36.640 --> 42:49.760]  просто равна сумме величин двух потоков. давайте еще раз f в графеже плюс h в графеже f
[42:49.760 --> 43:03.040]  равно потоку f плюс h в графеже. если у вас уже есть какой-то готовый поток в графеже и вы
[43:03.040 --> 43:08.960]  к нему добавили вот этот вот самый дополнительный ручеек h, то получите нормальный поток в графеже.
[43:08.960 --> 43:15.800]  доказательства просто по определению. что проверить по определению, нужно проверить
[43:15.800 --> 43:20.200]  выполнение трех свойств. ну первое свойство это свойство антисимметричности. ну я думаю оно очевидно.
[43:20.200 --> 43:24.720]  то есть так у меня функция f и функция h они антисимметричны, ну так как f является потоком
[43:24.720 --> 43:29.200]  и h является потоком, то f и h они антисимметричны, соответственно их сумма тоже антисимметрична.
[43:29.200 --> 43:36.000]  вот я думаю все очевидно. вот дальше. теперь нам нужно проверить, что f плюс h,
[43:36.000 --> 43:49.680]  и так напишем, что f в плюс h в будет меньше равно, чем c в любой пары в. вот мы то, что этот поток
[43:49.680 --> 43:54.400]  не будет превосходить пропускной способности для каждого ребра. тоже доказывается очень просто.
[43:54.400 --> 44:00.400]  у нас есть вот такое условие. откуда это следует? это следует из того, что у меня h это поток в gf.
[44:00.400 --> 44:06.040]  так как h это поток в gf, то значит его величина для каждого ребра не превосходит вот такой
[44:06.040 --> 44:11.680]  пропускной способности. то есть напоминаю, что в gf у меня пропускная способность c минус f.
[44:11.680 --> 44:19.880]  c минус f это пропускная способность графа gf. ну и все. я теперь вычитаю и переношу в левую
[44:19.880 --> 44:27.920]  часть и получаю, что f плюс h меньше равно, чем c. ровно то, чего я хотел. ну и треть свойство тоже
[44:27.920 --> 44:35.600]  очевидно. мне нужно показать, что для всех промежутных вершин сумма исходящих потоков равна нулю.
[44:35.600 --> 44:44.800]  ну очень просто. давайте просто просуммируем f плюс h от vu. так у меня сложение ассоциативно.
[44:44.800 --> 44:50.160]  я могу сначала сложить все f, а потом сложить все h. но так как f это поток и h это поток,
[44:50.160 --> 44:55.000]  то сумма всех f равна нулю и сумма всех h равна нулю. соответственно сумма тоже равна нулю.
[44:57.920 --> 45:04.120]  ну вот мы просто тупо проверили все по определению и получили результат. все понятно.
[45:11.840 --> 45:20.800]  то есть тут важные, даже нельзя сказать не самые сложные и так далее, просто самое важное тут
[45:20.800 --> 45:27.120]  это понять условия. понять условия леммы. что нельзя просто взять два потока из графа и
[45:27.120 --> 45:32.160]  сложить их. у вас обязательно один поток должен быть в исходном графе, а второй поток должен
[45:32.160 --> 45:37.760]  быть в остаточной сети от этого первого потока и только тогда их можно сложить. просто взять два
[45:37.760 --> 45:44.960]  потока произвольных и сложить их нельзя. но я думаю вы понимаете почему. дайте не знаю, самый простой
[45:44.960 --> 45:50.280]  пример приведем. вот у меня есть s, вот у меня есть t и пусть тут профессиональная способность равна единице.
[45:50.280 --> 46:05.400]  и соответственно вот у меня f просто равен. я не могу просто так взять и сказать что f
[46:05.400 --> 46:12.320]  плюс f это поток. почему? потому что f плюс f это не поток. потому что если я возьму f плюс f,
[46:12.320 --> 46:18.720]  то у меня получится что вот тут будет протекать 3 единицы потока, а это запрещено. вот это вот так
[46:18.720 --> 46:23.840]  делать нельзя. поэтому просто взять произвольного потока и сложить я не могу. у меня обязательно
[46:23.840 --> 46:28.600]  должен быть поток f в исходном графе и плюс должен быть поток в остаточной сети. то есть, грубо говоря,
[46:28.600 --> 46:33.960]  краски это самый ручеек, про который мы говорили все это время. что вы пускаете дополнительный поток
[46:33.960 --> 46:43.320]  и вот этот дополнительный поток краски ищете уже учитывая начальный поток. ну и лемма 2 оказывается
[46:43.320 --> 46:49.720]  аналогично про разность потоков. вот тут условие уже чуть другое. пусть f1 и f2 это потоки в g.
[46:49.720 --> 46:58.920]  то есть f1 и f2 это потоки именно в исходном графе g. тогда их разность f2 минус f1 будет
[46:58.920 --> 47:10.680]  потоком в графе gf1. снова f2 поток в графе g минус f1 поток в графе g. и в итоге я получаю поток f2
[47:10.680 --> 47:21.720]  минус f1 в графе gf1. то есть в графе, у которого пропускные способности записаны с учетом
[47:21.720 --> 47:28.440]  потока f1. доказывается абсолютно аналогично. тоже просто-напросто в лоб проверяются
[47:28.440 --> 47:33.360]  вот эти самые три условия. вот вопросы.
[47:42.240 --> 47:42.880]  все понятно.
[47:42.880 --> 48:02.160]  так ну отлично. давайте тогда сделаем перерыв 5 минут. до 16 часов и потом продолжим.
[48:13.360 --> 48:25.480]  продолжим. и собственно вот на основе понятия о синтезованном потоке и о понятии об арифметике
[48:25.480 --> 48:32.600]  потоков. то есть 5 минут назад мы говорили про сложение потоков, разность потоков. вот на основе
[48:32.600 --> 48:41.280]  краски этих утверждений можно построить сразу большое количество алгоритмов. и первый
[48:41.280 --> 48:45.280]  классический из них алгоритм порда палкерсона, который мы на самом деле уже, можно сказать,
[48:45.280 --> 48:52.720]  обсудили. потому что он устроен довольно просто и устроен жадным образом. так как мы знаем,
[48:52.720 --> 48:59.120]  что потоки можно ассумировать, то из этого следует довольно-таки простой алгоритм. для начала мы
[48:59.120 --> 49:04.120]  говорим, что изначально у нас поток это просто обсуждательственный ноль. поток для каждой
[49:04.120 --> 49:10.960]  пары вершин равен нулю. то есть нигде он не протекает. дальше берем остаточную сеть. на самом
[49:10.960 --> 49:15.320]  деле строить, как вы понимаете, остаточную сеть не обязательно. достаточно просто-напросто
[49:15.320 --> 49:20.080]  учитывать, чем остаточная сеть отличается от исходной сети. то есть просто-напросто она
[49:20.080 --> 49:27.000]  отличается величной способностью. если в исходной графе у меня пропускная способность это c,
[49:27.000 --> 49:31.880]  то в остаточной сети пропускная способность c-f. то есть у меня просто-напросто достаточно
[49:31.880 --> 49:37.240]  соответствующим образом учитывать пропускную способность. если у меня по ребру уже течет поток
[49:37.240 --> 49:43.240]  2, то соответственно пропускная способность уменьшается на две единицы. для формальности
[49:43.240 --> 49:49.120]  я буду говорить, что мы ищем остаточной сети или в графе с измененными пропускными способностями,
[49:49.120 --> 49:56.960]  я ищу путь из источника восток. при этом понятное дело, что путь я могу искать только вдоль
[49:56.960 --> 50:01.280]  ребер, у которых все еще есть положительная пропускная способность, по которым я действительно
[50:01.280 --> 50:09.280]  могу этот поток пустить. и этот путь можно искать с помощью dfs. алгоритм форда фалкса предлагает
[50:09.280 --> 50:14.640]  искать этот путь с помощью поиска в глубину. понятное дело, что с помощью поиска в глубину вы
[50:14.640 --> 50:22.280]  можете найти путь из одной вершины в другую. и соответственно после того, как вы нашли путь,
[50:22.440 --> 50:30.860]  вот есть источник s здесь ток t нашли путь. допустим тут пропускная способность 7, тут
[50:30.860 --> 50:36.940]  пропускная способность 5, тут соответственно 8 и так далее. и соответственно вот вдоль этого пути
[50:36.940 --> 50:42.600]  вы можете пустить величайший поток равным минимуму из MercedesX disposNT на этом пути. понятное дело,
[50:42.600 --> 50:47.360]  что пропускную способность 8 вы пустить на этом пути. не можете сеть все. потому что у вас есть
[50:47.360 --> 50:51.200]  рябро, по которому вы можете пустить только величину потока равной 5.
[50:51.200 --> 50:56.000]  Вы вдоль этого пути пускаете поток, равный максимально возможной величине.
[50:56.000 --> 51:03.120]  Соответственно, и соответствующим образом обновляете ваш текущий поток.
[51:03.120 --> 51:12.280]  То есть вы по каждому рябру пустили 5 емец потока, и соответственно обновляете ваш текущий поток f.
[51:12.280 --> 51:22.960]  Повторяете алгоритм, берете полученуостаточную сеть, пускаете в нем DFS, ищите какой-то путь,
[51:22.960 --> 51:26.480]  снова по этому пути пускаете поток максимальной величины, и так далее,
[51:26.480 --> 51:29.640]  продолжаете до тех пор, пока у вас существует путь из SFD.
[51:29.640 --> 51:36.760]  Я не сказал, но путь, который мы нашли на шаге 2, этот ручеек, который мы говорим,
[51:36.760 --> 51:43.720]  он еще называется дополняющим путем. То есть мы итеративно ищем дополняющий путь, пока этот путь на самом деле находится.
[51:43.720 --> 51:50.200]  Ну и как вы понимаете, соответственно, сложность этого алгоритма равна вот такой величине.
[51:50.200 --> 51:54.320]  Почему такой? Потому что DFS работает в целом за V плюс E,
[51:54.320 --> 52:00.160]  но тут я член с V опускаю, потому что считаю, что изолированных вершин у нас все-таки в графе нет.
[52:00.160 --> 52:04.800]  Поэтому количество рябра, хотя бы как минимум, равно количеству вершин.
[52:04.840 --> 52:12.040]  Поэтому соответственно, сложность алгоритма это E умножена на величину максимального потока.
[52:12.040 --> 52:15.720]  Почему? Потому что в худшем случае вы просто к пот elку приближаетесь по одному шагу.
[52:15.720 --> 52:19.720]  Увеличиваете поток на единицу, потом снова увеличиваете поток на единицу, потом снова на единицу,
[52:19.720 --> 52:23.680]  и так далее, до максимального потока. Но это понятное дело в худшем случае.
[52:23.680 --> 52:28.540]  Поэтому algorithm работает за E, умнож
[52:28.540 --> 52:32.320]  на величину максимального потока. И это на самом деле не то, чтобы очень хорошо,
[52:32.320 --> 52:38.320]  а в том смысле, что, вообще говоря, строго говоря, этот алгоритм нельзя назвать полинамиальным.
[52:38.320 --> 52:44.320]  Почему? Потому что все-таки полинамиальные алгоритмы считаются алгоритмами, которые работают за полином от входных данных.
[52:44.320 --> 52:55.320]  А тут мы не можем каким-то образом ограничить время работы какой-то функции от начальной конфигурации графа.
[52:55.320 --> 52:58.320]  То есть у нас время работы зависит от ответа.
[52:58.320 --> 53:05.320]  То есть нам нужно предъявить какую-то функцию, которая бы зависела только от характеристик исходного графа.
[53:05.320 --> 53:09.320]  То есть, например, от количества ребер, от количества вершин и так далее.
[53:09.320 --> 53:14.320]  Но, к сожалению, ничего более хорошего в алгоритме Порда-Павловича нам предложить нельзя.
[53:14.320 --> 53:16.320]  Вот такая вот оценка.
[53:16.320 --> 53:23.320]  Но мы рассмотрим алгоритмы, которые будут давать более оптимистичные оценки независящие от того, что мы делаем.
[53:23.320 --> 53:25.320]  Так, алгоритм ясен.
[53:53.320 --> 54:03.320]  Ну и, соответственно, все, что нам осталось доказать, это то, что...
[54:03.320 --> 54:13.320]  Давайте докажем, что если мы действительно не сможем найти дополнящий путь, то это, по сути, означает, что мы уже нашли максимальный поток.
[54:13.320 --> 54:19.320]  То есть из дополнящего пути мы не можем найти в том и только в том случае, если мы уже нашли поток максимальной величины.
[54:20.320 --> 54:28.320]  Ну, собственно, теорема Порда-Павловича на правом на это утверждает, что поток в сети G максимален тогда и только тогда, когда в сети GF просто-напросто нет дополнящего пути.
[54:28.320 --> 54:31.320]  Ну, давайте доказать это очень просто.
[54:31.320 --> 54:33.320]  Опирается просто-напросто на алемы оба арифметики потока.
[54:33.320 --> 54:38.320]  Начинаем докажем одну сторону.
[54:38.320 --> 54:43.320]  Вот и закажем, что если поток в сети G максимален, то в нем нет...
[54:43.320 --> 54:49.320]  То в нем мы уже никак не сможем найти дополнящие пути.
[54:49.320 --> 54:51.320]  Ну, давайте предположим противное.
[54:51.320 --> 54:59.320]  Вот, допустим, F это максимальный поток в G и в GF мы смогли найти некоторый дополнящий путь H.
[54:59.320 --> 55:03.320]  То есть, допустим, мы смогли построить еще один ручей.
[55:03.320 --> 55:05.320]  Тогда, что это означает?
[55:05.320 --> 55:10.320]  Ну, это означает, что мы можем воспользоваться алемой о сумме потоков и прибавить к текущему потоку поток H.
[55:10.320 --> 55:15.320]  Смотрите, F это поток в G, а H это, получается, мы нашли новый поток в дополнительности GF.
[55:15.320 --> 55:17.320]  Ну, соответственно, мы можем их сложить.
[55:17.320 --> 55:20.320]  Вот, мы их складываем, получаем некоторый новый поток в G,
[55:20.320 --> 55:25.320]  и при этом величина этого потока равна величине потока F плюс величине потока H.
[55:25.320 --> 55:28.320]  И при этом она строго больше, чем величина потока F.
[55:28.320 --> 55:31.320]  Почему? Ну, потому что H – это некоторый дополнящий путь.
[55:31.320 --> 55:35.320]  Да, дополнящий путь проходит только по ребрам с положительной профессиональной способностью.
[55:35.320 --> 55:40.320]  Ну, это значит, что мы по нему можем пустить какой-то не отрицательный, не точнее, строго положительный поток.
[55:40.320 --> 55:42.320]  Но тут мы сразу же приходим к противоречию.
[55:42.320 --> 55:47.320]  Почему? Потому что по условию мы говорили, что F – это максимально возможный поток в графе G.
[55:47.320 --> 55:49.320]  Поэтому противоречия.
[55:49.320 --> 55:52.320]  Все, соответственно, никакого дополнительного пути в графе GF мы найти не могли.
[55:52.320 --> 55:57.320]  Собственно, поэтому если поток в графе G максимален, то дополнящего пути нет.
[55:57.320 --> 55:59.320]  Ну, теперь давай докажем в обратную сторону.
[55:59.320 --> 56:04.320]  Верно ли, что если мы не смогли найти дополнительные пути, верно ли, что в этом случае поток максимален?
[56:04.320 --> 56:07.320]  Ну, соответственно, давайте доказывать.
[56:07.320 --> 56:15.320]  Отказать тоже простое и тоже опирается на лему об 잘 Communication потоков, но только уже на лему разности потоков.
[56:15.320 --> 56:19.320]  Ну, ну, соответственно, давайте рассмотрим просто некоторый максимальный поток.
[56:19.320 --> 56:24.320]  То есть мы сказали, что мы нашли какой-то поток F, для которого нет дополнящего пути.
[56:24.320 --> 56:29.320]  Соответственно, мы не знаем, максимальный он или нет, но давайте просто рассмотрим какой-то максимальный поток.
[56:29.320 --> 56:35.320]  Вот просто возьмем какой-то максимальный поток, про который мы еще ничего не знаем.
[56:35.320 --> 56:41.320]  Соответственно, что можем сделать? Давайте построим разность этих потоков.
[56:41.320 --> 56:45.320]  Построим разность к максимальному потоку и того потока, который мы нашли.
[56:45.320 --> 56:50.320]  Полемия о разности потоков. Этот поток будет как раз потоком, заполняющим сети GF.
[56:50.320 --> 56:53.320]  При этом, что мы еще знаем?
[56:53.320 --> 57:01.320]  Мы знаем, что величина разности этих двух потоков будет равна просто арифметической разности величины этих двух потоков.
[57:01.320 --> 57:11.320]  Но эта величина потока больше либо равна нуля. Почему? Потому что F, Fmax – это предположение максимальный поток.
[57:15.320 --> 57:22.320]  Но с другой стороны, что мы знаем? Мы знаем, что в потоке GF мы вообще, говоря, никак не можем найти дополняющего пути.
[57:22.320 --> 57:28.320]  А если в потоке GF мы не можем найти дополняющего пути, то это означает, что эта разность никак не может быть положительной.
[57:28.320 --> 57:32.320]  Почему? Потому что если бы эта разность была положительной, то мы бы так сказали.
[57:32.320 --> 57:38.320]  Вот есть разность между Fmax и F, и этот поток имеет положительную стоимость.
[57:38.320 --> 57:40.320]  Значит, это дополняющий путь в GF.
[57:40.320 --> 57:44.320]  А мы сказали, по предположению, что у нас в GF нет дополняющих пути.
[57:44.320 --> 57:48.320]  То есть это означает, что у меня величина разности потоков меньше равна нуля.
[57:48.320 --> 57:58.320]  То есть что мы получаем? Мы получаем, что с одной стороны Fmax минус F больше равна нуля, а с другой стороны мы получаем, что Fmax минус F меньше равна нуля.
[57:58.320 --> 58:05.320]  Но кажется, что из этого следует, что как раз как у меня Fmax, точнее, величина потока Fmax совпадает с величиной потока F.
[58:05.320 --> 58:08.320]  Но это означает, что F – это поток максимальной величины.
[58:08.320 --> 58:12.320]  При этом заметьте, что я не доказал, что у меня Fmax строго равен F.
[58:12.320 --> 58:17.320]  То есть я не доказал, что функция Fmax равна функции F.
[58:17.320 --> 58:21.320]  Нет, я просто доказал, что величина потока F совпадает с величиной максимального потока.
[58:21.320 --> 58:24.320]  Ну соответственно, по определению F – это максимальный поток.
[58:24.320 --> 58:28.320]  То есть на самом деле в графе не обязательно единственный максимальный поток.
[58:28.320 --> 58:36.320]  Таким образом я доказал, что какой-то максимальный поток, возможно отличающийся от Fmax, я нашел.
[58:36.320 --> 58:40.320]  Но, так или иначе, этот поток имеет максимальную величину, максимально возможную величину.
[58:40.320 --> 58:45.320]  Так, тут есть вопросы?
[59:10.320 --> 59:30.320]  Ну вот, таким образом мы рассмотрели простейший алгоритм поиска потока максимальной величины.
[59:30.320 --> 59:34.320]  Это первый алгоритм.
[59:34.320 --> 59:42.320]  Но, соответственно, хорошая новость заключается в том, что все, что существует целая рослик алгоритмов, которые основаны на вот этой теореме for-default.
[59:42.320 --> 59:52.320]  В общем, с помощью этой теоремы доказывается корректность произвольного алгоритма, который мы будем рассматривать в нашем курсе.
[59:53.320 --> 59:59.320]  То есть вот сейчас мы будем рассматривать еще кое-какие, соответственно, алгоритмы поиска потока максимальной величины.
[59:59.320 --> 01:00:07.320]  И, собственно, я сразу говорю, что все эти алгоритмы, которые мы рассмотрим в ближайшее время, они опираются вот ровно на эту теорему.
[01:00:07.320 --> 01:00:13.320]  В чем может быть разница до алгоритма?
[01:00:13.320 --> 01:00:15.320]  То есть на самом деле алгоритм довольно прост.
[01:00:15.320 --> 01:00:16.320]  То есть что утверждает эта теорема?
[01:00:16.320 --> 01:00:20.320]  Теорема, грубо говоря, утверждает следующее, что вы просто таким-то образом ищете дополняющие пути.
[01:00:20.320 --> 01:00:29.320]  Ищете их до тех пор, пока они ищутся, пока у вас есть какой-то дополняющий путь.
[01:00:29.320 --> 01:00:33.320]  И вся разница с алгоритмом заключается в том, а каким образом я все-таки ищу дополняющий путь.
[01:00:37.320 --> 01:00:41.320]  То есть алгоритм for-default лично предлагает искать дополняющий путь с помощью алгоритма DFS.
[01:00:41.320 --> 01:00:44.320]  Но на самом деле дополняющий путь можно искать и другими способами.
[01:00:44.320 --> 01:00:48.320]  С помощью каких-то других алгоритмов поиска пути или каким-то более умным способом.
[01:00:48.320 --> 01:00:50.320]  Давайте их рассмотрим.
[01:00:50.320 --> 01:00:53.320]  Следующий алгоритм — это алгоритм Edmond-Scarpe.
[01:00:53.320 --> 01:00:59.320]  И самый прикол в том, что алгоритм Edmond-Scarpe отличается от алгоритма Forth Bellman.
[01:00:59.320 --> 01:01:01.320]  Уберем.
[01:01:01.320 --> 01:01:03.320]  Тут стоит BFS.
[01:01:03.320 --> 01:01:07.320]  То есть алгоритм Edmond-Scarpe отличается от алгоритма Forth Bellman всего лишь одной деталью.
[01:01:07.320 --> 01:01:09.320]  Точнее одной буквой.
[01:01:09.320 --> 01:01:11.320]  Это вот наречим буквы B вместо буквы D.
[01:01:11.320 --> 01:01:17.320]  То есть алгоритм Edmond-Scarpe абсолютно точно такой же, как алгоритм Forth Bellman.
[01:01:17.320 --> 01:01:23.320]  Но вместо алгоритма DFS есть алгоритм BFS.
[01:01:24.320 --> 01:01:26.320]  Как и алгоритм Forth Bellman.
[01:01:26.320 --> 01:01:33.320]  Но вместо алгоритма DFS в качестве поиска дополняющего пути он использует алгоритм BFS.
[01:01:33.320 --> 01:01:35.320]  Ну, почему алгоритм?
[01:01:35.320 --> 01:01:37.320]  То есть чем отличается алгоритм BFS от алгоритма DFS?
[01:01:37.320 --> 01:01:50.320]  Ну, алгоритм BFS просто ищет дополняющий путь с наиболее короткий, наиболее короткий, рёберный, наиболее рёберно-короткий дополняющий путь.
[01:01:50.320 --> 01:01:56.320]  Дополняющий путь с наименьшим количеством рёбер.
[01:01:56.320 --> 01:02:03.320]  И всего лишь вот такое изменение одной буквы, всего лишь изменение алгоритма DFS на алгоритм BFS,
[01:02:03.320 --> 01:02:15.320]  приводит к тому, что сложность алгоритма, я напомню, что у меня алгоритм Forth Bellman работал за E умноженное на модуль на величину потока F.
[01:02:15.320 --> 01:02:24.320]  А вот алгоритм Эдман Сакарпа, соответственно, гарантирует, что он найдет решение за VL умноженное на E квадрат,
[01:02:24.320 --> 01:02:27.320]  причем вне зависимости от величины потока.
[01:02:27.320 --> 01:02:35.320]  Ну, собственно, давайте покажем, почему так, почему, соответственно, замена алгоритма DFS на алгоритм BFS приводит к тому,
[01:02:35.320 --> 01:02:44.320]  что у меня, соответственно, сложность алгоритма меняется вот таким вот кардинальным, можно сказать, образом.
[01:02:44.320 --> 01:02:46.320]  Начну.
[01:02:47.320 --> 01:02:53.320]  Для начала нам нужно доказать лему, давайте докажем тоже, почему это полетело.
[01:02:54.320 --> 01:02:56.320]  Вёрска, ну ладно.
[01:02:59.320 --> 01:03:02.320]  Давайте, чтобы не смущало, напишу.
[01:03:03.320 --> 01:03:05.320]  Откручивается.
[01:03:10.320 --> 01:03:12.320]  Откручивается.
[01:03:15.320 --> 01:03:17.320]  Появляется.
[01:03:21.320 --> 01:03:24.320]  Значит, в чем состоит лемма?
[01:03:25.320 --> 01:03:28.320]  Лемма заключается в следующем. Ну, смотрите, как работает алгоритм.
[01:03:28.320 --> 01:03:32.320]  Ну, вот я инициализирую, то есть сначала у меня поток равен нулю,
[01:03:32.320 --> 01:03:37.320]  дальше, соответственно, я запускаю алгоритм BFS, ищу какой-то путь из источника в сток,
[01:03:37.320 --> 01:03:44.320]  дальше, соответственно, обновляю мой поток и снова ищу с помощью BFS путь из источника в сток, ну и так далее.
[01:03:44.320 --> 01:03:49.320]  И вот утверждение краски заключается в том, что после каждой итерации алгоритма,
[01:03:49.320 --> 01:03:54.320]  то есть на каждой итерации поиска пути из источника в сток,
[01:03:54.320 --> 01:04:01.320]  то у меня реберная длина пути от источника в сток не уменьшается.
[01:04:01.320 --> 01:04:07.320]  То есть, грубо говоря, если я на первой итерации попытался найти путь из источника в сток
[01:04:07.320 --> 01:04:12.320]  и нашел путь длины 3, ну длины 3 в смысле проходя по трем ребрам,
[01:04:12.320 --> 01:04:19.320]  то на следующей итерации я не смогу найти путь равный 2, то есть либо 3, либо 4, либо 5 и так далее.
[01:04:19.320 --> 01:04:29.320]  На следующей там 5, 6, 7. То есть у меня длина реберного пути из источника в сток всегда не уменьшается.
[01:04:29.320 --> 01:04:36.320]  Ну и в какой-то момент, естественно, надо достигать своего максимума, и в какой-то момент просто я пути найти не смогу.
[01:04:36.320 --> 01:04:40.320]  Давайте, собственно, поймем, почему это так.
[01:04:40.320 --> 01:04:44.320]  Ну, все, на самом деле, довольно прозаично и довольно просто.
[01:04:45.320 --> 01:04:49.320]  Ну, давайте посмотрим вот на эту конфигурацию.
[01:04:49.320 --> 01:04:53.320]  Вот, допустим, у меня был такой граф, да, вот тут ребра граф изображены черным цветом,
[01:04:53.320 --> 01:05:06.320]  и, допустим, вот вдоль этого пути, вот, соответственно, допустим, вдоль этого пути я смог найти дополнящий путь величины 3.
[01:05:06.320 --> 01:05:11.320]  Вот, что у меня, да, ну и, соответственно, после этого я обновляю свой поток и обновляю старшую сеть.
[01:05:11.320 --> 01:05:14.320]  Что в итоге у меня произойдет? Ну, смотрите, что у меня может произойти.
[01:05:14.320 --> 01:05:19.320]  Во-первых, у меня существует ребро, которое из графа исчезнет, ну вот оно.
[01:05:19.320 --> 01:05:26.320]  Почему? Потому что это ребро я запомнил полностью, то есть у него прописанная способность равно 3, я полностью его заполнил.
[01:05:26.320 --> 01:05:33.320]  Какие-то ребра у меня остались, ну, вот 다른 ребра два, вот это ребро, вот это ребро, вот это, вот это,
[01:05:33.320 --> 01:05:38.320]  то есть вот эти ребра у меня они остались, да, так они заполнены, так они заполнены Мне до конца.
[01:05:38.320 --> 01:05:44.320]  А какие-то ребра у меня появились. Вот этого ребра раньше не было,
[01:05:44.320 --> 01:05:46.320]  то есть тут была парусная способность равную нулю.
[01:05:46.320 --> 01:05:49.320]  Но так как я в прямом направлении пустил поток равной 3,
[01:05:49.320 --> 01:05:53.320]  то теперь у меня в обновленном графе появился обратный ребро,
[01:05:53.320 --> 01:05:58.320]  в котором я могу пустить дополнительный путь.
[01:05:58.320 --> 01:06:01.320]  То есть у меня может произойти всего лишь две вещи.
[01:06:01.320 --> 01:06:06.320]  На самом деле три, но третье – это то, что у меня ребра не меняются.
[01:06:06.320 --> 01:06:08.320]  Но это нас не интересует.
[01:06:08.320 --> 01:06:10.320]  Глобально может произойти две вещи.
[01:06:10.320 --> 01:06:13.320]  Первое – у меня может исчезнуть ребро вдоль пути.
[01:06:13.320 --> 01:06:18.320]  Я нашёл какой-то короткий путь, и вдоль этого пути у меня может исчезнуть какое-то ребро.
[01:06:18.320 --> 01:06:21.320]  А второе, что может произойти – это у меня есть короткий путь,
[01:06:21.320 --> 01:06:28.320]  и на этом пути может появиться обратное ребро, то есть ребро в обратном направлении.
[01:06:28.320 --> 01:06:30.320]  То есть зафиксировали.
[01:06:30.320 --> 01:06:34.320]  Я с помощью BFS нашёл какой-то короткий реберный путь,
[01:06:34.320 --> 01:06:40.320]  и дкcakes пос><лиIG рв crabbrotherb.
[01:06:40.320 --> 01:06:43.320]  Дополнительно опустил по нему дополнительный подог,
[01:06:43.320 --> 01:06:46.320]  и всё, что может пройти на этом пути, это либо ребра могут не измениться,
[01:06:46.320 --> 01:06:51.320]  во-вторых, какие-то ребра из источника в сток могут исчезнуть,
[01:06:51.320 --> 01:06:56.320]  а какие-то ребра, которые идут наоборот из стока в источник, могут появиться.
[01:06:56.320 --> 01:06:58.320]  Так вот, в чём утверждение?
[01:06:58.320 --> 01:07:02.320]  Утверждение заключает в том, что ни удаление ребр не может укоротить этот путь.
[01:07:02.320 --> 01:07:06.320]  ну, в смысле, количество ребр, никак не может стать короче.
[01:07:06.320 --> 01:07:08.320]  И это довольно понятно почему.
[01:07:08.320 --> 01:07:16.320]  Ну, снова тут все поехало, но давайте проще поступим.
[01:07:16.320 --> 01:07:25.320]  Удаление, удаление, добавление.
[01:07:25.320 --> 01:07:33.320]  Почему это так?
[01:07:33.320 --> 01:07:35.320]  Ну, с удалением все довольно просто.
[01:07:35.320 --> 01:07:38.320]  Вот у вас был какой-то короткий путь, у вас есть короткий путь.
[01:07:38.320 --> 01:07:40.320]  Вот отсюда, вот сюда.
[01:07:40.320 --> 01:07:43.320]  И вы вдоль этого пути удалили ребро.
[01:07:43.320 --> 01:07:45.320]  Но согласитесь, что путь, короче, никак стать не мог.
[01:07:45.320 --> 01:07:48.320]  То есть удаление ребер никак не может привести к корачиванию пути.
[01:07:48.320 --> 01:07:51.320]  Поэтому это очевидно.
[01:07:51.320 --> 01:07:52.320]  А теперь второй момент.
[01:07:52.320 --> 01:07:54.320]  Вот представьте, у вас был короткий путь.
[01:07:54.320 --> 01:08:00.320]  Ну, допустим, у вас есть короткий путь от общаги до НК, до ЛК.
[01:08:00.320 --> 01:08:05.320]  И, собственно, представьте себе, что вам построили еще одну дорожку,
[01:08:05.320 --> 01:08:07.320]  которая ведет, наоборот, в обратном направлении.
[01:08:07.320 --> 01:08:10.320]  Ну, не знаю, как это так получилось, что она односторонняя.
[01:08:10.320 --> 01:08:14.320]  То есть, наоборот, укротиться ли от этого ваш путь от общаги до ЛК?
[01:08:14.320 --> 01:08:16.320]  При условии, что вы до них ходите.
[01:08:16.320 --> 01:08:18.320]  Ну, в общем, укротиться этот путь или нет?
[01:08:18.320 --> 01:08:19.320]  Ну, нет.
[01:08:19.320 --> 01:08:20.320]  Понятно, что он не укротится.
[01:08:20.320 --> 01:08:24.320]  Почему? Потому что вам в обратном направлении двигаться не нужно было.
[01:08:24.320 --> 01:08:26.320]  Ну и формально это тоже можно показать.
[01:08:26.320 --> 01:08:29.320]  Ну, вот пример.
[01:08:29.320 --> 01:08:37.320]  Пусть у меня был какой-то короткий путь из С до У.
[01:08:37.320 --> 01:08:46.320]  Ну, и представьте себе, что у меня вот это вот ребро исчезло.
[01:08:46.320 --> 01:08:48.320]  Да, и появилось...
[01:08:48.320 --> 01:08:50.320]  Точнее так, оно не исчезло, конечно.
[01:08:50.320 --> 01:08:55.320]  Вот представьте себе, что у меня появилось обратное ребро.
[01:08:55.320 --> 01:09:00.320]  Откуда В? Вот.
[01:09:00.320 --> 01:09:04.320]  Мог ли у меня путь до В стать короче?
[01:09:04.320 --> 01:09:08.320]  Ну, давайте подумаем, как он мог стать короче за счет этого ребра.
[01:09:08.320 --> 01:09:10.320]  Ну, за счет этого ребра он мог стать короче,
[01:09:10.320 --> 01:09:18.320]  только если я сначала дойду до вот этой вершины У,
[01:09:18.320 --> 01:09:21.320]  а потом пройду по этому новому ребру В.
[01:09:21.320 --> 01:09:23.320]  Ну, смотрите, что получается.
[01:09:23.320 --> 01:09:29.320]  Чтобы дойти от С до У, мне нужно пройти вот такой путь.
[01:09:29.320 --> 01:09:31.320]  Ройс У.
[01:09:31.320 --> 01:09:36.320]  А потом за счет единицы дойти до ребра В.
[01:09:36.320 --> 01:09:42.320]  А что я знаю про кратчайший путь до У?
[01:09:42.320 --> 01:09:50.320]  А про кратчайший путь до У я знаю, что, соответственно, он никак...
[01:09:50.320 --> 01:09:53.320]  Он никак не мог стать короче. Почему?
[01:09:53.320 --> 01:09:56.320]  Потому что по предположению, другие ребра никак не изменились.
[01:09:56.320 --> 01:10:02.320]  Поэтому это больше равно, чем Ройс У плюс единица.
[01:10:02.320 --> 01:10:07.320]  И это как раз таки Ро штриха св.
[01:10:15.320 --> 01:10:17.320]  Ну и смотрите, что получается.
[01:10:17.320 --> 01:10:24.320]  Получается у меня следующая вещь, что новый путь от С до В
[01:10:24.320 --> 01:10:29.320]  у меня больше равен, чем исходный путь от С до У плюс 1.
[01:10:32.320 --> 01:10:36.320]  Новый путь от С до У плюс 1.
[01:10:36.320 --> 01:10:38.320]  Но что я знаю?
[01:10:38.320 --> 01:10:44.320]  Я знаю, что кратчайший путь из С до У проходит по ребру ВУ.
[01:10:44.320 --> 01:10:52.320]  То есть это просто означает, что это в свою очередь больше равно, чем Ройс В плюс 1.
[01:10:52.320 --> 01:10:53.320]  Что у меня получилось?
[01:10:53.320 --> 01:10:58.320]  У меня получилось, что есть некоторые новые короткие путь до В.
[01:10:58.320 --> 01:11:01.320]  И он больше равен, чем старый путь плюс 1.
[01:11:01.320 --> 01:11:05.320]  Согласитесь, что он никак не укоротился.
[01:11:05.320 --> 01:11:09.320]  Ну все, соответственно, получили противоречие.
[01:11:09.320 --> 01:11:14.320]  То есть с помощью этого обратного ребра дополнительного у меня путь никак не мог стать короче.
[01:11:14.320 --> 01:11:18.320]  Давайте еще раз проговорю, что у нас есть.
[01:11:18.320 --> 01:11:24.320]  У нас был некоторый исходный кратчайший путь от С до У.
[01:11:24.320 --> 01:11:29.320]  Я хочу проверить, верно ли, что при добавлении такого ребра, например,
[01:11:29.320 --> 01:11:33.320]  у меня путь до В не мог стать короче.
[01:11:33.320 --> 01:11:35.320]  Ну действительно, он не мог стать короче. Почему?
[01:11:35.320 --> 01:11:38.320]  Потому что, ну, давайте посмотрим как.
[01:11:38.320 --> 01:11:42.320]  Это означает, что у меня есть некоторый новый путь до В, который проходит вот по этому ребру.
[01:11:42.320 --> 01:11:45.320]  Почему? Так как это ребро появилось, то, наверное, я должен его как-то заиспользовать.
[01:11:45.320 --> 01:11:47.320]  Ну, соответственно, я пытаюсь его заиспользовать.
[01:11:47.320 --> 01:11:50.320]  То есть я должен каким-то образом, оптимальным образом добраться до У,
[01:11:50.320 --> 01:11:54.320]  а потом сделать плюс один шаг вот по этому новому ребру.
[01:11:54.320 --> 01:11:55.320]  Ну что я знаю?
[01:11:55.320 --> 01:11:59.320]  Я знаю, что кроме вот этого ребра, у меня никакие другие ребра не поменялись.
[01:11:59.320 --> 01:12:05.320]  Поэтому новый путь до У никак, соответственно, не мог стать короче, чем исходный путь от С до У.
[01:12:05.320 --> 01:12:11.320]  Ну а исходный путь от С до У проходил через вершину В.
[01:12:11.320 --> 01:12:17.320]  Ну вот, соответственно, я получил, что новое расстояние от С до В больше равно, чем...
[01:12:17.320 --> 01:12:19.320]  Ну, короче говоря, больше равно, чем...
[01:12:19.320 --> 01:12:22.320]  Ну, кстати, плюс один, на самом деле, уже не играет роли.
[01:12:22.320 --> 01:12:25.320]  Больше равен, чем исходный путь от С до В.
[01:12:25.320 --> 01:12:27.320]  То есть путь явно не стал короче.
[01:12:27.320 --> 01:12:30.320]  Более того, он даже стал длиннее, на самом деле, на две единицы.
[01:12:32.320 --> 01:12:39.320]  Поэтому, соответственно, появление обратных ребер никак не укорочивает путь.
[01:12:44.320 --> 01:12:45.320]  Понятна мысль?
[01:12:47.320 --> 01:12:48.320]  Есть ли вопросы?
[01:13:18.320 --> 01:13:19.320]  Ну окей.
[01:13:31.320 --> 01:13:40.320]  Ну и наконец, давайте, собственно, покажем, что действительно алгоритм Edmund Scarpe работает за побольшое Ве квадрата.
[01:13:40.320 --> 01:13:44.320]  Для этого мне понадобится следующий теорема, который говорит следующее.
[01:13:44.320 --> 01:13:47.820]  Давайте называть ребро критическим, если его насытил поток.
[01:13:47.820 --> 01:13:49.320]  Что значит насытил поток?
[01:13:49.320 --> 01:13:52.320]  Вот у меня было какое-то ребро с пустной способностью С.
[01:13:52.320 --> 01:13:55.320]  Вот, и я по нему пустил поток в точность равной С.
[01:13:55.320 --> 01:13:59.320]  Вот, это, собственно, означает, что ребро стало критическим.
[01:13:59.320 --> 01:14:02.320]  Вот, значит, что ребро стало критическим.
[01:14:02.320 --> 01:14:06.320]  То есть оно просто исчезло из сети.
[01:14:06.320 --> 01:14:11.320]  Но понятное дело, что это ребро, если какое-то ребро стало критическим, то оно стало критическим не навсегда.
[01:14:11.320 --> 01:14:13.320]  Да, почему?
[01:14:13.320 --> 01:14:19.320]  Потому что даже если у меня ребро стало насыщенным, то я в какой-то момент могу в обратном направлении пустить дополнительные 2 единицы потока,
[01:14:19.320 --> 01:14:28.320]  и тогда, соответственно, означает, что в этом направлении потечет минус 2 единицы потока,
[01:14:28.320 --> 01:14:32.320]  и тогда у меня величина потока в этом направлении будет равна c-2.
[01:14:32.320 --> 01:14:34.320]  c-2 будет меньше, чем c.
[01:14:34.320 --> 01:14:37.320]  То есть у меня на самом деле каждый ребро может становиться ограниченным несколько раз.
[01:14:37.320 --> 01:14:45.320]  Допустим, может исчезать, в какой-то момент появляться за счет того, что я могу пускать потоки в обратном направлении, вот так далее.
[01:14:45.320 --> 01:14:47.320]  Но что утверждает терема?
[01:14:47.320 --> 01:14:52.320]  Терема утверждает то, что каждое ребро может стать критическим не более, чем в 1.5 раз.
[01:14:52.320 --> 01:14:58.320]  То есть у меня какое-то ребро может быть насыщенным, потом, соответственно, оно может снова появляться, потом снова насыщаться, снова исчезать, и так далее.
[01:14:58.320 --> 01:15:05.320]  Но такое не может происходить бесконечно количество раз, а именно не может происходить больше, чем в 1.5 раз.
[01:15:05.320 --> 01:15:10.320]  Ну, давайте, собственно, докажем.
[01:15:10.320 --> 01:15:15.320]  Давайте рассмотрим некоторые ребро в ВУ.
[01:15:15.320 --> 01:15:18.320]  И, допустим, какой-то момент стал критическим.
[01:15:18.320 --> 01:15:20.320]  Вот вопрос. Как оно могло стать критическим?
[01:15:20.320 --> 01:15:25.320]  Ну, ребро могло стать критическим только в тот момент, когда оно находится на кратчайших пути от СДУ.
[01:15:25.320 --> 01:15:34.320]  То есть я напоминаю, что алгоритмами Эдман-Скарпа мы пускаем дополнящие потоки или ручейки только вдоль кратчайших путей.
[01:15:34.320 --> 01:15:39.320]  Это значит, что ВУ лежит на кратчайшем пути от СДУ.
[01:15:39.320 --> 01:15:45.320]  Ну, и, соответственно, давайте предположим, что в этот момент времени у меня расстояние до У равно РОСУ,
[01:15:45.320 --> 01:15:48.320]  соответственно, в точности равно РОСВ плюс один.
[01:15:48.320 --> 01:15:54.320]  Почему? Потому что если до РОСУ расстояние минимальное, то, соответственно, и до ВУ у меня тоже расстояние найдено.
[01:15:54.320 --> 01:15:58.320]  То есть путь до ВУ у меня тоже минимальный.
[01:15:58.320 --> 01:16:08.320]  Это значит первый момент времени, когда у меня ребро ВУ, не первый момент, но какой-то момент времени, когда ребро ВУ стало критическим.
[01:16:08.320 --> 01:16:10.320]  То есть в этот момент я ребро ВУ заполнил.
[01:16:10.320 --> 01:16:19.320]  Теперь давайте рассмотрим следующий момент времени. Давайте рассмотрим момент, когда это ребро ВУ снова вернется в мой граф.
[01:16:19.320 --> 01:16:29.320]  Значит, когда это произойдет? А это произойдет только тогда, когда я по ребру УВ, то есть в обратном направлении, пущу какой-то поток.
[01:16:29.320 --> 01:16:33.320]  Ну а что это означает? Что означает, что я по ребру УВ пустил дополнительный поток?
[01:16:33.320 --> 01:16:41.320]  А это означает, что я нашел кратчайший путь от СДВ, который проходит через вершину У.
[01:16:41.320 --> 01:16:49.320]  Да, и вот это, собственно, верно по ЛЕМЕ 1, то есть по предыдущей ЛЕМЕ.
[01:16:49.320 --> 01:17:01.320]  Так как у меня кратчайшие пути не уменьшаются, то новый короткий путь до У больше бы равен, чем старый короткий путь до У.
[01:17:01.320 --> 01:17:07.320]  Ну все, теперь смотрите, что произошло. У меня ребро ВУ стало критическим, исчезло из графа.
[01:17:07.320 --> 01:17:10.320]  Теперь я смотрел момент, когда оно снова появилось в графе.
[01:17:10.320 --> 01:17:15.320]  А появиться оно могло только в тот момент, когда я пустил поток в обратном направлении.
[01:17:15.320 --> 01:17:22.320]  И вот когда я пускал поток в обратном направлении, у меня расстояние до В было равно исходному расстоянию до У,
[01:17:22.320 --> 01:17:29.320]  плюс один. Ну и давайте рассмотрим второй момент, когда ребро ВУ стало критическим.
[01:17:29.320 --> 01:17:39.320]  Что произойдет в этот момент? В этот момент у меня кратчайшее расстояние от С до У будет равно кратчайшему расстоянию от С до В,
[01:17:39.320 --> 01:17:47.320]  плюс один. И у меня будет кратчайшее расстояние от С до В, плюс один.
[01:17:47.320 --> 01:17:52.320]  И у меня будет равно кратчайшее расстояние от С до В, плюс один.
[01:17:52.320 --> 01:17:56.320]  Соответственно, я понимаю, что это больше либо равно, чем Ро штрих СВ.
[01:17:56.320 --> 01:18:03.320]  Снова поле М1. Так кратчайшее расстояние не уменьшается.
[01:18:03.320 --> 01:18:09.320]  А Ро штрих СВ в свою очередь больше либо равно, чем Ро СУ.
[01:18:09.320 --> 01:18:15.320]  Плюс один, плюс один. То есть плюс два.
[01:18:15.320 --> 01:18:20.320]  То есть смотрите, что я получил.
[01:18:25.320 --> 01:18:34.320]  В начале моем тремени, когда у меня ребро ВУ стало критическим, у меня расстояние от С до У было равно Ро СУ.
[01:18:34.320 --> 01:18:41.320]  А в следующий момент, когда ребро СУ стало критическим, у меня уже расстояние было Ро штрих СУ,
[01:18:41.320 --> 01:18:48.320]  которое было как минимум на 2 единицы, больше, чем исходное расстояние от С до У.
[01:18:48.320 --> 01:18:55.320]  Что это означает? Это означает, что между двумя последовательными событиями, когда ребро ВУ становится критическим,
[01:18:55.320 --> 01:19:00.320]  у меня расстояние до У увеличивается хотя бы на 2.
[01:19:00.320 --> 01:19:04.320]  Вопрос, а может ли расстояние до У увеличиваться бесконечно на 2?
[01:19:04.320 --> 01:19:09.860]  Нет, у меня у графе всего V вершин.
[01:19:09.860 --> 01:19:15.320]  то максимальная длина пути графе не больше, чем В.
[01:19:15.320 --> 01:19:19.320]  Но увеличивать расстояние я могу не больше, чем на В.
[01:19:19.320 --> 01:19:28.320]  Но мне каждый раз расстояние увеличивается на 2, то увеличивать это расстояние я могу не больше, чем в bajалом раз.
[01:19:28.320 --> 01:19:33.320]  Ну и соответственно означает, что у меня ребро может быть критическими больше, чем в полном раз.
[01:19:33.320 --> 01:19:37.320]  Потому что между двумя последовательными критическими моментами у меня
[01:19:37.320 --> 01:19:45.320]  расстояние до вершины, конкретной U, увеличивается на 2 единицы.
[01:19:45.320 --> 01:19:47.320]  Вот.
[01:19:51.320 --> 01:20:08.320]  Ну, если совсем коротко, давайте скажем, что первый момент, когда ребро ВУ критическое,
[01:20:08.320 --> 01:20:16.320]  у меня расстояние от S до U, ну не знаю, было равно, давайте скажем, РО.
[01:20:16.320 --> 01:20:20.320]  Во второй момент
[01:20:25.320 --> 01:20:31.320]  расстояние от S до U было больше брано, чем РО плюс 2.
[01:20:31.320 --> 01:20:41.320]  Вот. То есть увеличилось минимум на 2.
[01:20:41.320 --> 01:20:51.320]  Ну и соответственно из этого следует, что ВУ критическое не более, чем в полном раз.
[01:20:51.320 --> 01:21:00.320]  Ну, давайте напишем, что так как РО с U обязательно должно быть меньше брано, чем В.
[01:21:00.320 --> 01:21:02.320]  Ну это очевидно, да.
[01:21:08.320 --> 01:21:10.320]  Так, все в порядке, вопросов нет?
[01:21:30.320 --> 01:21:40.320]  Так, ну окей. Ну и соответственно, давайте на этом подойдем итог, у нас осталось еще пара алгоритмов,
[01:21:40.320 --> 01:21:43.320]  но их мы, собственно, оставим на следующий раз.
[01:21:43.320 --> 01:21:49.320]  Ну а пока давайте завершим анализ алгоритма Эдмонс Карпа, и давайте, собственно, наконец-таки
[01:21:49.320 --> 01:21:55.320]  ну, собственно, докажем, почему у него время работы к краске O от VE2.
[01:21:55.320 --> 01:22:01.320]  Ну, смотрите, да. За сколько работает BFS?
[01:22:01.320 --> 01:22:07.320]  BFS работает за O.
[01:22:07.320 --> 01:22:15.320]  Ну, в общем-то, у нас осталось еще пару алгоритмов, но их мы оставим на следующий раз.
[01:22:15.320 --> 01:22:20.320]  BFS работает за O от E.
[01:22:20.320 --> 01:22:24.320]  Ну, опять же, давайте считать, что у нас нет изолированных вершин и так далее.
[01:22:24.320 --> 01:22:27.320]  Все-таки, если у нас есть транспортная сеть, то она действительно сеть,
[01:22:27.320 --> 01:22:30.320]  то есть у нас всегда вершины связаны и так далее.
[01:22:30.320 --> 01:22:36.320]  Поэтому алгоритм BFS работает за O от количества ребр.
[01:22:36.320 --> 01:22:41.320]  Сколько всего будет итераций?
[01:22:41.320 --> 01:22:50.320]  Сколько всего дополняющих путей найдено?
[01:22:50.320 --> 01:22:52.320]  Ну, давайте проанализируем это так.
[01:22:52.320 --> 01:23:00.320]  Каждый дополняющий путь делает какое-то ребро критическим.
[01:23:00.320 --> 01:23:04.320]  Вот я нашел какой-то путь.
[01:23:04.320 --> 01:23:08.320]  И вот на этом пути обязательно найдется какое-то ребро, которое будет полностью заполнено.
[01:23:08.320 --> 01:23:10.320]  Ну, просто так алгоритм устроен.
[01:23:10.320 --> 01:23:13.320]  Я опускаю путь, я опускаю поток максимально личный, который могу.
[01:23:13.320 --> 01:23:16.320]  Соответственно, у меня обязательно какое-то ребро становится критическим.
[01:23:16.320 --> 01:23:17.320]  Ну вот.
[01:23:17.320 --> 01:23:18.320]  Ну, что я знаю?
[01:23:18.320 --> 01:23:20.320]  Я знаю, что у меня ребро может стать критическим не больше, чем V раз.
[01:23:20.320 --> 01:23:23.320]  V пополам раз.
[01:23:23.320 --> 01:23:24.320]  А сколько у меня всего ребра?
[01:23:24.320 --> 01:23:26.320]  А всего ребра у меня E.
[01:23:26.320 --> 01:23:30.320]  То есть это означает, что у меня общее количество итераций или общее количество дополняющих путей
[01:23:30.320 --> 01:23:33.320]  не может быть больше, чем E умножить на V, деленное на 2.
[01:23:33.320 --> 01:23:34.320]  Согласны?
[01:23:34.320 --> 01:23:36.320]  Ну, смотрите, простое соответствие.
[01:23:36.320 --> 01:23:40.320]  Каждый дополняющий путь делает хотя бы одно ребро критическим.
[01:23:40.320 --> 01:23:43.320]  Я знаю, что каждое ребро может стать критическим не больше, чем V пополам раз.
[01:23:43.320 --> 01:23:44.320]  А всего ребра у меня E.
[01:23:44.320 --> 01:23:48.320]  Значит, общее количество дополняющих путей у меня не больше, чем E умножить на V пополам.
[01:23:48.320 --> 01:23:52.320]  Ну, соответственно, я беру E умножить на V пополам и умножаю на E.
[01:23:52.320 --> 01:23:55.320]  Ну, это как раз идет BFS.
[01:23:55.320 --> 01:23:58.320]  Да, это доп. путей.
[01:23:58.320 --> 01:24:02.320]  Ну, и получаю, соответственно, V умножить на E квадрат.
[01:24:02.320 --> 01:24:03.320]  Ну, пополам еще.
[01:24:03.320 --> 01:24:04.320]  Вот.
[01:24:07.320 --> 01:24:12.320]  Вот отсюда я получил нужную мне асимпточку.
[01:24:19.320 --> 01:24:23.320]  Так, ну, алгоритм делится и алгоритм...
[01:24:23.320 --> 01:24:27.320]  Ну, еще пару алгоритмов мы рассмотрим уже в следующий раз.
[01:24:27.320 --> 01:24:30.320]  Этого, я думаю, пока достаточно.
[01:24:30.320 --> 01:24:32.320]  Остались себе какие-то вопросы.
[01:24:32.320 --> 01:24:35.320]  Может, что-то еще нужно повторить, проговорить?
[01:25:03.320 --> 01:25:09.320]  Так, ну, тогда лекцию по алгоритму мы предлагаем закончить.
[01:25:09.320 --> 01:25:11.320]  Сейчас давайте сделаем перерыв.
[01:25:11.320 --> 01:25:15.320]  Ну, до 15, до без 15, до 16,45.
[01:25:15.320 --> 01:25:20.320]  Вот. И потом, оставшийся, оставшийся сейчас час 2, сейчас 15.
[01:25:20.320 --> 01:25:24.320]  Отсудим вопросы, связанные с C++.
[01:25:24.320 --> 01:25:26.320]  Вот. Перерыв.
[01:25:32.320 --> 01:25:33.320]  Вот.
