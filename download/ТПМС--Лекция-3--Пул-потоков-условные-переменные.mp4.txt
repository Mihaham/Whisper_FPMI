[00:00.000 --> 00:07.000]  Ну что, приветствую всех, давайте начинать.
[00:15.000 --> 00:24.000]  Прежде чем мы перейдем к сегодняшней теме, я хочу сказать пару слов про вашу домашнюю работу, которую вы решаете, возможно, прямо сейчас.
[00:24.000 --> 00:37.000]  Я на самой первой лекции, на нулевой, говорил, что мы в конце концов собираемся написать свой собственный ГО с каналами, с селектами, со всем, что там бывает, с файберами, с какими-то примитивами синхронизации для них.
[00:37.000 --> 00:42.000]  И я говорил, что мы собираемся это сделать буквально с помощью одного атомика.
[00:42.000 --> 00:51.000]  Вот нам его функциональности достаточно, чтобы потом построить собственный планировщик, свои собственные легковесные потоки и примитивы синхронизации для них.
[00:51.000 --> 00:59.000]  И вот в связи с этим я очень хочу обратить ваше внимание на две задачи, которые в вашей домашней работе есть, и на два аспекта в них.
[00:59.000 --> 01:02.000]  Эти две задачи — это Mutex и Spinlock.
[01:02.000 --> 01:13.000]  Что мне важно от Mutex, чтобы вы очень основательно разобрались, что такое Mutex, что он из себя представляет.
[01:13.000 --> 01:17.000]  Потому что это единственный способ блокироваться из визу спейса.
[01:17.000 --> 01:21.000]  Это единственный способ сказать планировщику, что вы чего-то ждете, а кто-то потом вас уведомит.
[01:21.000 --> 01:31.000]  И сложно здесь не только в том, чтобы с помощью этого фьютекса написать блокирующий Mutex, а чтобы понять, какие гарантии фьютекс вам дает.
[01:31.000 --> 01:34.000]  А чтобы это сделать, нужно разобраться, как он устроен.
[01:34.000 --> 01:40.000]  И единственный честный и, мне кажется, самый хороший способ разобраться в том, как устроен Mutex,
[01:40.000 --> 01:51.000]  это пойти по этой ссылке в ядро линукса, где, собственно, фьютекса написан, и прочесть комментарий там, где описаны его гарантии этого фьютекса и некоторые псевдокоды.
[01:51.000 --> 01:57.000]  Понимания этого псевдокода достаточно для того, чтобы хорошо осознать гарантии.
[01:57.000 --> 02:06.000]  Ну а поскольку мы дальше собираемся писать свои потоки, свои Mutex, нам и фьютекс потребуется самим самостоятельно написать,
[02:06.000 --> 02:08.000]  поэтому полезно разобраться уже сейчас.
[02:08.000 --> 02:14.000]  Ну и дополнительный приятный бонус у этого комментария в том, что если вы начнете его читать до конца,
[02:14.000 --> 02:18.000]  то, возможно, вы придете в глубокую кроличную нору, связанную с моделями памяти.
[02:18.000 --> 02:25.000]  Опять же, не предполагается, что мы сейчас способны понять вот эти картинки, но в будущем они нас коснутся.
[02:25.000 --> 02:30.000]  К тому же, тут есть некоторая пасхалочка про пример, который я показывал на прошлой лекции.
[02:30.000 --> 02:33.000]  Про сценарий, когда процессор довольно странно себя ведет.
[02:33.000 --> 02:38.000]  Вот оказывается, что внутри фьютекса такая проблема возникает, такой сценарий синхронизации.
[02:38.000 --> 02:44.000]  Но про это вы поговорите еще раз на семинаре, так что вот сфокусируйте, пожалуйста, внимание свое на этом, когда будете решать задачу.
[02:44.000 --> 02:49.000]  И вторая задача, которая мне важна, это атомик, потому что...
[02:49.000 --> 02:53.000]  Ой, простите, спинлог, потому что там нужно написать, конечно, не спинлог, а атомик,
[02:53.000 --> 02:57.000]  и разобраться, что мы понимаем под атомарными операциями.
[02:57.000 --> 03:00.000]  Exchange, FetchEd, какими-то другими.
[03:00.000 --> 03:06.000]  И вот вас, мне кажется, это немного сбивает с толку, что в задачу уже как будто написана реализация.
[03:06.000 --> 03:10.000]  Ну, задача написана не реализацией, в задаче описана семантика на ассембляре этих операций.
[03:10.000 --> 03:12.000]  Вот мы читаем и пишем.
[03:12.000 --> 03:16.000]  Но это не значит, что атомарный Exchange вот именно так реализован.
[03:16.000 --> 03:22.000]  Вот вы будете решать эту задачу, и вот, во-первых, познакомитесь с какими-то другими инструкциями процессора.
[03:22.000 --> 03:28.000]  Во-вторых, ну просто осознайте, почему они атомарные, какие гарантии вам даются.
[03:28.000 --> 03:34.000]  И вот самое хитрое, что в этой задаче есть, и что даже непонятно, в какой степени вы способны сейчас осознать,
[03:34.000 --> 03:42.000]  это различные варианты решения этой задачи, потому что можно пройти тесты и написать разный код.
[03:42.000 --> 03:47.000]  Ну и что бы это означало? Наверняка же это что-то значит.
[03:47.000 --> 03:55.000]  Наверное, какие-то гарантии у этого кода, у этих разных решений, какие-то гарантии будут отличаться у одного и другого решения.
[03:55.000 --> 04:00.000]  И вот про эти гарантии и про эти разные решения вам задают два вопроса в условии.
[04:00.000 --> 04:04.000]  Вот попробуйте на них ответить, по крайней мере подумайте над ними, покопайте.
[04:04.000 --> 04:11.000]  Задача не про то, чтобы пройти тесты, конечно, задача про то, чтобы провести маленькое исследование и разобраться самому, почему оно именно так.
[04:11.000 --> 04:17.000]  Вот если вы написали реализацию и вам кажется, что она тамарна, ну вот как-то убедите себя в первую очередь, что она тамарна.
[04:17.000 --> 04:24.000]  Но на защите вам потребуется это сделать еще и со своими семинаристами, своими преподавателями.
[04:24.000 --> 04:32.000]  Ну хорошо, про это мы поговорили, а сегодня у нас другая тема, сегодня мы поговорим про потоки.
[04:32.000 --> 04:37.000]  Вот на прошлой лекции кто-то спрашивал, мы говорим про Mutex, как потоки синхронизируются,
[04:37.000 --> 04:40.000]  а при этом мы их почему-то не запускаем до сих пор, что довольно странно.
[04:40.000 --> 04:42.000]  Было такое, кажется.
[04:42.000 --> 04:47.000]  Вот, и я эту тему избегал, вот уже две лекции избегаю, почти что, ну как избегаю.
[04:47.000 --> 04:54.000]  Я вам показывал очень простой пример на самом первом занятии, где мы запускали потоки для того, чтобы обслуживать клиентов.
[04:54.000 --> 05:00.000]  Вот мы создавали STDetright, передавали туда функцию, которая будет исполняться с аргументом,
[05:00.000 --> 05:05.000]  и говорили Detach, то есть мы отвязывали исполнение потока от вот этого объекта STDetright.
[05:05.000 --> 05:10.000]  Этот объект разрушался, а поток в фоне продолжал бежать.
[05:10.000 --> 05:15.000]  И при этом мы сказали, что вроде бы нам так не нравится, мы так не хотим делать,
[05:15.000 --> 05:21.000]  потому что операционная система не способна для каждого отдельного клиента нашего сетевого сервиса заводить целый поток.
[05:21.000 --> 05:23.000]  Слишком дорогое удовольствие.
[05:23.000 --> 05:26.000]  И нам нужно, видимо, делать что-то иначе.
[05:26.000 --> 05:32.000]  Мы сказали, что нам нужно придумать некоторые файберы, которые будут выглядеть для пользователя так же,
[05:32.000 --> 05:38.000]  но почему-то они будут более легковесными, видимо, потому что операционная система не будет их обслуживать
[05:38.000 --> 05:44.000]  и запуск этих файберов и их планирование будет осуществляться в пространстве пользователя.
[05:44.000 --> 05:48.000]  Но тем не менее, мы потоки все-таки запускать хотим в этом курсе,
[05:48.000 --> 05:56.000]  потому что потоки, как я уже говорил раньше, это виртуальный ядропроцессор, это доступ к физическому параллелизму.
[05:56.000 --> 06:01.000]  Так вот, мы хотим запускать потоки, безусловно, чтобы исполняться параллельно,
[06:01.000 --> 06:04.000]  чтобы утилизировать наши вычислительные ресурсы, наш процессор,
[06:04.000 --> 06:08.000]  но в то же время запускать потоки совершенно наивным образом.
[06:08.000 --> 06:11.000]  Вот так вот конструируется Детраида и каждый раз, когда нам нужен поток,
[06:11.000 --> 06:16.000]  когда нам нужна какая-то конкурентная активность, мы не хотим, мы не можем себе позволить.
[06:16.000 --> 06:23.000]  И сегодня мы поговорим о том, как мы будем делать, как мы будем запускать потоки в этом курсе.
[06:23.000 --> 06:29.000]  И решение называется «Пул потоков». Давайте перейдем в подходящий нам репозиторий сейчас.
[06:31.000 --> 06:37.000]  Мы хотим сделать «Пул потоков», и вот предупреждение — это единственный способ,
[06:37.000 --> 06:41.000]  которым мы будем запускать потоки в этом курсе. Больше мы к этому вопросу возвращаться не будем.
[06:41.000 --> 06:50.000]  «Пул потоков» выглядит вот так вот. Мы конструируем его, мы передаем в конструктор число потоков,
[06:50.000 --> 06:54.000]  которые будут выполнять некоторые задачи, а дальше у нас есть метод Submit,
[06:54.000 --> 06:59.000]  который способен одному из этих потоков каким-то потоком передать задачу,
[06:59.000 --> 07:05.000]  и эти потоки эту задачу исполнят. Вот мы просто фиксируем набор потоков, которые у нас будут в программе,
[07:05.000 --> 07:11.000]  фиксируем их количество, и мы хотим всю работу, которую у нас есть,
[07:11.000 --> 07:16.000]  исполнять в этом фиксированном наборе потоков. Новых потоков мы заводить не хотим.
[07:16.000 --> 07:22.000]  Программа у нас может работать очень долго, она может быть демоном, она может работать недели, месяцы, не выключаясь,
[07:22.000 --> 07:28.000]  но при этом новых потоков в ней не появится. Вот они на старте создаются, а дальше переиспользуются просто.
[07:28.000 --> 07:34.000]  Что наш пул потоков будет уметь?
[07:34.000 --> 07:44.000]  Он умеет буквально один метод, Submit. В него мы передаем какую-то лямду, в общем случае мы называем это задачей,
[07:44.000 --> 07:52.000]  то есть некоторую функцию без аргументов и без возвращаемого значения, и пул потоков обязуется
[07:52.000 --> 08:00.000]  после вызова Submit исполнить переданную задачу, переданную лямду в одном из своих потоков.
[08:00.000 --> 08:06.000]  Какому именно мы не знаем. Когда именно это случится, мы тоже не знаем.
[08:06.000 --> 08:11.000]  Вот если у вас есть вопросы, задавайте их сразу, я сейчас буду показывать вам пример.
[08:11.000 --> 08:17.000]  Сделайте что-нибудь покрупнее, как вы думаете.
[08:17.000 --> 08:23.000]  Ну, про реализацию мы сейчас поговорим. Мы скажем, что вот число задач может быть любым.
[08:23.000 --> 08:29.000]  Число потока фиксировано, число задач, конечно же, не от пула зависит, мы этим не управляем.
[08:29.000 --> 08:35.000]  Как правило, число задач растет с размером задачи или еще с чем-то, или с количеством пользователей.
[08:35.000 --> 08:41.000]  Вызов Submit, когда он завершается, мы не знаем, как это будет работать.
[08:41.000 --> 08:47.000]  Вызов Submit означает, что мы запланировали задачу на исполнение в пуле потоков.
[08:47.000 --> 08:53.000]  Гарантировать что, прости?
[08:53.000 --> 08:59.000]  Но если мы вызвали Submit, и он вернул нам управление, и пул, забегая вперед, не остановлен,
[08:59.000 --> 09:05.000]  то задача должна обязана Eventual и выполнится в этом пуле.
[09:05.000 --> 09:11.000]  Нет, верхней границы на время исполнения нет.
[09:11.000 --> 09:17.000]  Поскольку мы собираемся нагружать пул задачами, которые эксплуатирует процессор,
[09:17.000 --> 09:23.000]  видимо, число потоков там будет измеримо из числа физических ядер.
[09:23.000 --> 09:29.000]  То есть, это вот представление, это вот представление, что если мы собираемся нагрузить
[09:29.000 --> 09:35.000]  то число потоков там будет измеримо из числа физических ядер.
[09:35.000 --> 09:41.000]  Это физическая параллельность для нас пул потоков, это вот виртуальные ядра.
[09:41.000 --> 09:47.000]  Не совсем понятно, причем здесь глобальные переменные.
[09:47.000 --> 09:53.000]  Кажется, это какой-то перпендикулярный вопрос.
[09:53.000 --> 09:57.000]  Глобально ли так тоже тебя помешает? Не понятно, как это связано с потоками.
[09:57.000 --> 10:03.000]  Нет, причем здесь... Сейчас, стойте, давайте не будем говорить про другие языки.
[10:03.000 --> 10:08.000]  Мы пишем на C++, и вот это пул потоков с языком программирования мало связан.
[10:08.000 --> 10:12.000]  Но, с другой стороны, если говорить про Python, то там нет смысла потоки запускать
[10:12.000 --> 10:16.000]  в стиле реализации интерплитатора, так что это просто не очень подходящий пример.
[10:16.000 --> 10:20.000]  У нас C++, давай все-таки про него.
[10:20.000 --> 10:24.000]  Я покажу, когда придет время, но вот пока у нас такой пример.
[10:24.000 --> 10:30.000]  Здесь нет... Я пока не говорю о слове join, и такого слова у нас вообще в поле потоков
[10:30.000 --> 10:34.000]  нет нигде, поэтому вопрос не принимается, к сожалению.
[10:34.000 --> 10:40.000]  Смотрите, что у нас пока пул умеет. Он умеет submit, и вот мы кладем в него три задачи.
[10:40.000 --> 10:45.000]  Во-первых, мы кладем первую задачу, которая как будто бы изображает какую-то деятельность,
[10:45.000 --> 10:49.000]  как будто бы изображает какая-то просто процессор сном, вот она блокирует поток.
[10:49.000 --> 10:53.000]  Тут могло быть какое-то тяжелое вычисление, но вот тут написан slip.
[10:53.000 --> 10:57.000]  Есть вторая задача, которая сразу печатает что-то на экран, и есть третья задача,
[10:57.000 --> 11:02.000]  которая сначала спит, а потом из самой себя обращается к текущему пулу потоку
[11:02.000 --> 11:07.000]  с помощью свободной функции current. То есть мы из пул потоков находим этот самый
[11:07.000 --> 11:11.000]  пул потоков текущий, и в него планируем новую задачу.
[11:11.000 --> 11:14.000]  То есть мы можем делать это снаружи, можем делать это прямо изнутри.
[11:14.000 --> 11:20.000]  И у нас есть метод wait. Метод wait блокирует вызывающий его поток до тех пор,
[11:20.000 --> 11:26.000]  пока в пуле остаются задачи. Вот когда пул закончит выполнять все задачи,
[11:26.000 --> 11:30.000]  которые в нем уже есть или которые в нем появятся, то есть когда счетчик задач
[11:30.000 --> 11:34.000]  такой логически опустится до нуля, этот вызов wait разблокируется и вернет
[11:34.000 --> 11:37.000]  управление пользователя, до тех пор он будет поток блокировать.
[11:37.000 --> 11:41.000]  То есть мы здесь вызываем wait и останавливаемся до тех пор, пока не будут
[11:41.000 --> 11:44.000]  выполнены все задачи. А сколько их тут всего?
[11:47.000 --> 11:51.000]  Четыре задачи. Вот мы должны увидеть один, два и три. Вопрос только в том,
[11:51.000 --> 11:55.000]  в каком порядке. Ну вот давайте запустим и...
[11:55.000 --> 12:01.000]  Нет, здесь никаких файберов нет. Здесь есть только вот потоки, есть метод submit
[12:01.000 --> 12:07.000]  и есть вот задача. Задача, она абсолютно абстрактная, но тут мог бы быть STD
[12:07.000 --> 12:10.000]  function, тут написано немного другой класс, потому что STD function имеет
[12:10.000 --> 12:14.000]  свои ограничения, а именно он должен быть капельным.
[12:14.000 --> 12:20.000]  И мы можем делать это снаружи, снаружи, снаружи, снаружи, снаружи.
[12:20.000 --> 12:24.000]  Вот такой класс, потому что STD function имеет свои ограничения, а именно он
[12:24.000 --> 12:29.000]  должен быть копируемым, а, скажем, лямбды, которые, замыкания, которые
[12:29.000 --> 12:33.000]  захватывают move-on-ly объект, они не могут копироваться, поэтому STD function
[12:33.000 --> 12:36.000]  с ними не работает, поэтому мы используем другой класс.
[12:36.000 --> 12:40.000]  Ну, не суть. Это вот некоторый контейнер, который содержит функцию без
[12:40.000 --> 12:44.000]  аргументов и возвращаемого значения. Вот все сущности, которыми мы
[12:44.000 --> 12:50.000]  оперируем пока. Набор статических потоков, задача и вот метод submit,
[12:50.000 --> 12:54.000]  который каким-то образом запускает планирование.
[12:54.000 --> 12:58.000]  Вот к этому примеру еще раз вернемся, смотрите, что тут произошло.
[12:58.000 --> 13:03.000]  Мы бросили в пул три задачи, там было четыре потока, и вот первая задача,
[13:03.000 --> 13:07.000]  она заснула на каком-то потоке, а вот вторая задача, она запланировалась
[13:07.000 --> 13:11.000]  на другой поток, раз у нас их всего четыре, и выполнилось сразу,
[13:11.000 --> 13:17.000]  напечатала два. Дальше мы запланировали третью задачу, не дожидаясь,
[13:17.000 --> 13:20.000]  пока вот эти две завершились, ну или параллельно с ними.
[13:20.000 --> 13:26.000]  И третья задача запланировала четвертую и запланировала через секунду
[13:26.000 --> 13:31.000]  после submita, так что вот вывод у нас получился в таком порядке.
[13:31.000 --> 13:36.000]  Да, она заблокировала поток пула. Ну и давайте сразу договоримся,
[13:36.000 --> 13:40.000]  что вот такой код писать неприемлемо. Вот этот код написан здесь для примера,
[13:40.000 --> 13:44.000]  но когда мы будем говорить про какие-то полезные сценарии
[13:44.000 --> 13:48.000]  использования пулопотоков, мы договоримся вот сразу, раз и навсегда,
[13:48.000 --> 13:54.000]  что мы никогда не блокируем потоки пула. Это очень плохой, очень плохой
[13:54.000 --> 13:58.000]  сценарий, потому что мы сначала договорились, что этих потоков
[13:58.000 --> 14:02.000]  будет фиксированное количество, что мы новых заводить не будем,
[14:02.000 --> 14:06.000]  и если мы поток заблокируем, один из этих потоков во всем приложении,
[14:06.000 --> 14:12.000]  то мы у себя отнимем целое ядро процессора. Это не то, чего мы хотим, конечно.
[14:12.000 --> 14:16.000]  То есть блокироваться ни в коем случае нельзя. Ни на слипах, ни на каких-то,
[14:16.000 --> 14:20.000]  не знаю, ожидания других задач, ни на какие-то другие задачи.
[14:20.000 --> 14:24.000]  Вот такие сценарии должны быть у нас исключены.
[14:31.000 --> 14:37.000]  Ну, технически можно, насколько это полезно, это отдельный вопрос.
[14:37.000 --> 14:39.000]  Вот пока мы к этому не стремимся.
[14:39.000 --> 14:44.000]  Ну вот я пока акцентирую внимание именно на блокировке, что мы не можем
[14:44.000 --> 14:48.000]  позволить себе заблокировать, чтобы не было таких ситуаций,
[14:48.000 --> 14:51.720]  мы не можем позволить себе заблокироваться в потоке транпула,
[14:51.720 --> 14:55.280]  потому что их ограниченное количество и все сценарии использования,
[14:55.280 --> 15:00.500]  которые у нас будут дальше, там, карутины, файберы, какие-то вычисления, пусть неважно,
[15:00.500 --> 15:04.000]  все они прямой блокировки потока должны будут избегать.
[15:04.000 --> 15:10.000]  Блокировка в смысле фьютакса. У нас есть единственный способ заблокировать поток.
[15:10.000 --> 15:13.500]  У нас есть ограниченное число способов заблокировать поток.
[15:13.500 --> 15:16.000]  Это сисколы, которые обращаются к планировщику.
[15:16.000 --> 15:18.000]  Например, слип или это фьютакс.
[15:18.000 --> 15:21.000]  Вот слип мы просто, безусловно, блокируемся на некоторое время.
[15:21.000 --> 15:25.000]  Во фьютаксе мы блокируемся на время ожидания какого-то уведомления
[15:25.000 --> 15:28.000]  через фьютакс вейк из другого потока.
[15:28.000 --> 15:32.000]  Но вот все эти механизмы для нас в пуле потоков должны быть исключены.
[15:36.000 --> 15:42.000]  Ну да, иначе мы придем вот сюда, разрушим пул потоков, а задача еще не выполнится.
[15:42.000 --> 15:46.000]  Еще раз, сабмит завершается вот почти сразу.
[15:46.000 --> 15:49.000]  Он возвращает управление, когда задача запланирована на исполнение.
[15:49.000 --> 15:52.000]  Завершение сабмита не означает, что у нас задача исполнилась.
[15:52.000 --> 15:56.000]  У нас три сабмита завершаются очень быстро, а потом мы блокируемся на три секунды,
[15:56.000 --> 16:02.000]  пока не завершатся все задачи, которые были в пул потоков, которые попали в пул потоков.
[16:02.000 --> 16:04.000]  Или попадут.
[16:05.000 --> 16:09.000]  Семантика вызова стоп следующая.
[16:09.000 --> 16:16.000]  Мы хотим завершить все потоки, независимо от того, остаются ли в пуле задачи еще не выполненные.
[16:16.000 --> 16:19.000]  Ну и просто вернуть управление.
[16:19.000 --> 16:23.000]  То есть задачи, которые не успели выполниться, они просто выбрасывают, сигналируют сплом,
[16:23.000 --> 16:25.000]  и потоки останавливаются.
[16:31.000 --> 16:33.000]  Да, именно так.
[16:35.000 --> 16:40.000]  Но это namespace с пулом потоков, который мы сегодня собираемся написать.
[16:43.000 --> 16:46.000]  Нет, и кажется, до 26-го года не будет.
[16:46.000 --> 16:49.000]  Вот оказывается, что очень сложно написать пул потоков.
[16:49.000 --> 16:55.000]  Мы напишем сегодня какой-то, а вот прям идеальный пул потоков пишут бесконечное время в данный момент.
[16:55.000 --> 17:01.000]  Ну вот мы с вами научимся писать идеальный пул потоков, кажется, к концу семестра, но это потребует усилий.
[17:05.000 --> 17:11.000]  Итак, что мы хотим сделать, понятно, да?
[17:14.000 --> 17:18.000]  Ну потому что стоп выполняет некоторую нетривиальную работу,
[17:18.000 --> 17:22.000]  а выполнять нетривиальную работу в диструктуре по разным причинам не очень хорошая идея.
[17:22.000 --> 17:26.000]  Лучше сложные вещи делать явными.
[17:26.000 --> 17:34.000]  Ну это вопрос дискуссионный, это вопрос вкуса на самом деле, но мне кажется, что разумнее так.
[17:42.000 --> 17:48.000]  Нет, почему? Просто current из разных потоков, разных пулов будет возвращать разные указатели.
[17:49.000 --> 17:53.000]  Вот. Для этого требуется так называемые threadlock-переменные.
[17:53.000 --> 17:56.000]  Вот про threadlock-переменные, кажется, мы ничего не знаем еще, да?
[17:59.000 --> 18:02.000]  А здесь они где-то должны быть.
[18:09.000 --> 18:13.000]  Случится неопределенное поведение, ну либо какой-нибудь ассерт упадет.
[18:13.000 --> 18:19.000]  Ну это такие вопросы, которые мелкие инженерные подробности, они не влияют на суть происходящего.
[18:19.000 --> 18:23.000]  Поэтому давайте перейдем к сути, а именно как этот пул потоков устроен.
[18:23.000 --> 18:27.000]  Ну вообще, а что такое пул потоков для нас? Для нас это планировщик.
[18:27.000 --> 18:33.000]  Он планирует задачи, простые функции без аргументов и без возвращаемого значения
[18:33.000 --> 18:39.000]  на наши вычислительные ресурсы, виртуальные ядра в виде поток, операционной системы.
[18:39.000 --> 18:42.000]  Как это планирование происходит?
[18:42.000 --> 18:46.000]  Оно происходит с помощью очень простым механизмом, с помощью глобальной очереди.
[18:46.000 --> 18:49.000]  Вот где-то у нас здесь есть картинка.
[18:49.000 --> 18:52.000]  Вот это самый простой механизм планирования на свете.
[18:52.000 --> 18:54.000]  Разделяемая очередь.
[18:54.000 --> 19:00.000]  Вот здесь кружочки, это вот эти пустые кружочки, это потоки, которые мы называем
[19:00.000 --> 19:04.000]  воркеры, которые выполняют задачи, работают.
[19:04.000 --> 19:08.000]  Снаружи находятся клиенты, цветные кружочки, это задача.
[19:08.000 --> 19:13.000]  И вот клиент, когда он говорит Submit, кладет свою задачу в некоторую общую очередь,
[19:13.000 --> 19:18.000]  а все потоки воркеров внутри пула разбирают эту общую очередь.
[19:18.000 --> 19:22.000]  То есть они блокируются до тех пор, пока в этой очереди не появится доступная задача.
[19:22.000 --> 19:26.000]  После этого они ее берут и запускают.
[19:26.000 --> 19:30.000]  Это очень разумный механизм планирования, потому что он хорошо балансирует нагрузку.
[19:30.000 --> 19:34.000]  Если у вас какой-то поток простаивает, он простаивает только потому, что
[19:34.000 --> 19:37.000]  на данный момент задач не остается, которых нужно выполнять.
[19:37.000 --> 19:40.000]  То есть прямо сейчас работы больше нет.
[19:40.000 --> 19:43.000]  Если работа есть, то все потоки нагружены уже.
[19:43.000 --> 19:47.000]  Ну и кроме того, очередь это довольно разумный способ планирования,
[19:47.000 --> 19:52.000]  в смысле FIFO-планирование. Чем раньше задача попала в пул потоков, тем раньше она исполнится.
[19:52.000 --> 19:57.000]  Звучит разумно, правда? Согласны или нет?
[19:57.000 --> 20:01.000]  На самом деле нет, это не разумно, потому что приложения бывают разными.
[20:01.000 --> 20:05.000]  И где-то разумно FIFO-планирование такое естественное, а где-то разумно почему-то
[20:05.000 --> 20:08.000]  покажем планирование. Есть разные сценарии синхронизации.
[20:08.000 --> 20:13.000]  Но вот наш пул потоков планирует быть довольно универсальным и подходить под разные задачи.
[20:13.000 --> 20:19.000]  И вообще говоря, под разные задачи нужно немного свои алгоритмы планирования иметь.
[20:19.000 --> 20:22.000]  Ну вот у нас сегодня очень простой механизм, это общая очередь.
[20:22.000 --> 20:26.000]  Ну, разумеется, настоящий планировщик устроен сложно.
[20:26.000 --> 20:31.000]  Ну и забегая вперед, у нас будет лекция про планировщик Go.
[20:31.000 --> 20:36.000]  И там мы разберем DesignDoc, ну и реализацию посмотрим.
[20:36.000 --> 20:40.000]  Настоящий планировщик сложный устроен, конечно, сложнее, чем одна глобальная очередь.
[20:40.000 --> 20:45.000]  Это не самый разумный алгоритм планирования для некоторых задач, для наших задач.
[20:45.000 --> 20:50.000]  Как работает пул потоков, точнее, как пользоваться пулом потоков примерно понятно.
[20:50.000 --> 20:53.000]  Как он устроен в первом приближении тоже должно быть понятно сейчас.
[20:53.000 --> 20:57.000]  Давайте поговорим о том, что мы с ним собираемся делать.
[20:57.000 --> 21:00.000]  Как мы будем его использовать? Какие задачи мы будем решать?
[21:00.000 --> 21:05.000]  Ну вот какой-то очевидный пример, который приходит в голову.
[21:05.000 --> 21:08.000]  Ну просто независимый пример.
[21:09.000 --> 21:13.000]  Ну вот какой-то очевидный пример, который приходит в голову.
[21:13.000 --> 21:16.000]  Ну просто независимые тяжелые вычисления.
[21:16.000 --> 21:22.000]  Нам нужно, не знаю, принимать из сети какие-то блобики и там распаковывать их, декодировать как-то.
[21:22.000 --> 21:25.000]  Вот мы бросаем задачу в Threadpool, там эта задача независима от других,
[21:25.000 --> 21:29.000]  исполняется, декодирует что-то, возвращает нам результат каким-то образом, пока не понятно.
[21:29.000 --> 21:34.000]  Вот можно себе такую задачу представить, а можно представить себе задачу чуть интереснее.
[21:34.000 --> 21:41.000]  Вот, например, пусть вы пишете сортировку, и вот вам хочется ее распараллелить.
[21:41.000 --> 21:47.000]  Вот если вы будете делать очень наивно, скажем, вы пишете QuickSort,
[21:47.000 --> 21:51.000]  и на каждое разбиение вы запускаете по два потока, на две подзадачи,
[21:51.000 --> 21:55.000]  то получится, что если вы запустили много сортировок, то у вас получится безумное количество потоков,
[21:55.000 --> 22:01.000]  они все будут в ядре соревноваться за процессоры, будет очень много переключений контекста совершенно бесполезных.
[22:01.000 --> 22:06.000]  Вот мы бы хотели, скажем, алгоритм сортировки упаковать его исполнение в пул потоков.
[22:06.000 --> 22:11.000]  Причем этот пул потоков будет, пусть будет общий на разные сортировки.
[22:11.000 --> 22:16.000]  Вот подходит ли наш пул потоков для задач, например, QuickSort или MergeSort?
[22:18.000 --> 22:20.000]  Что, прости?
[22:22.000 --> 22:26.000]  Ну, не знаю, почему.
[22:31.000 --> 22:41.000]  Не совсем понятно. Что мы оптимизируем здесь?
[22:46.000 --> 22:50.000]  Так у нас число потоков фиксированное.
[22:50.000 --> 22:55.000]  Вот здесь проблема-то другая.
[22:55.000 --> 23:00.000]  Что с таким интерфейсом проще написать QuickSort или MergeSort?
[23:03.000 --> 23:05.000]  Почему?
[23:09.000 --> 23:12.000]  Вот, а случай с MergeSort, какие у нас проблемы будут?
[23:12.000 --> 23:16.000]  Ну вот, случай с MergeSort написать алгоритм довольно сложно здесь,
[23:16.000 --> 23:22.000]  потому что мы породим две подзадачи, они завершатся,
[23:22.000 --> 23:26.000]  а теперь нужно после завершения двух подзадач сделать еще какую-то третью.
[23:26.000 --> 23:31.000]  И как нельзя делать ни в коем случае?
[23:31.000 --> 23:36.000]  Породить задачу, которая породит две подзадачи, а потом заблокируется до их завершения.
[23:36.000 --> 23:39.000]  Потому что блокироваться в пуле потоков мы не можем.
[23:39.000 --> 23:43.000]  А значит, нужно каким-то образом запланировать третью задачу Merge
[23:43.000 --> 23:47.000]  после того, как завершатся обе дочерние подзадачи.
[23:47.000 --> 23:50.000]  И вот в задачах появляются зависимости.
[23:58.000 --> 24:01.000]  Ну как, поток могут снять с ядра, то есть поток операционной системы,
[24:01.000 --> 24:04.000]  а стедетрат могут снять с ядра просто планировщик операционной системы.
[24:04.000 --> 24:06.000]  Такое может быть.
[24:06.000 --> 24:11.000]  Ну вот, сами задача, это произвольные функции, что ты в них написал, то и будет.
[24:13.000 --> 24:18.000]  Ну при блокировке заблокируется поток, а их всего там четыре.
[24:18.000 --> 24:22.000]  То есть никакой магии-то не произойдет.
[24:22.000 --> 24:27.000]  Кажется, что если мы знаем про PuTX и про потоки, то произойдет то, что должно.
[24:27.000 --> 24:29.000]  Поток заблокируется.
[24:29.000 --> 24:32.000]  Так вот, здесь мы видим, что возникают какие-то естественным образом задачи,
[24:32.000 --> 24:35.000]  в которых нужно чуть больше, чем просто Submit иметь.
[24:35.000 --> 24:39.000]  В некоторых задачах хочется, скажем, получить из функции результат.
[24:39.000 --> 24:42.000]  Мы хотим запустить ее в пуле асинхронно, как говорят,
[24:42.000 --> 24:46.000]  но при этом получить ответ из нее, то есть получить результат вычисления.
[24:46.000 --> 24:50.000]  Пул потоков этого не умеет, у него есть просто Submit.
[24:50.000 --> 24:56.000]  А в некоторых задачах у нас появляется еще одна, нам требуется еще одна функциональность,
[24:56.000 --> 25:00.000]  а именно мы хотим в пуле потоков планировать не просто отдельные независимые задачи,
[25:00.000 --> 25:03.000]  мы хотим планировать целый граф из задач.
[25:03.000 --> 25:07.000]  Как-то их связывать, чтобы они синхронировались между собой,
[25:07.000 --> 25:10.000]  чтобы одна вызывала другую.
[25:10.000 --> 25:13.000]  И опять пул потоков ничего такого не умеет.
[25:13.000 --> 25:17.000]  Значит ли это, что мы хотим доработать пул потоков? Нет, не значит.
[25:17.000 --> 25:20.000]  Значит ли это, что мы рано или поздно научимся это делать?
[25:20.000 --> 25:22.000]  Конечно, научимся.
[25:22.000 --> 25:24.000]  Но вот пул потоков меняться не планирует.
[25:24.000 --> 25:27.000]  Пул потоков хочет оставаться таким же простым.
[25:27.000 --> 25:30.000]  И в этом будет его достоинство, мы об этом чуть позже.
[25:32.000 --> 25:34.000]  Так вот же мы делаем.
[25:34.000 --> 25:38.000]  Не, мы внутри сабмита делаем сабмиты, мы внутри сабмита мы в сабмите
[25:38.000 --> 25:41.000]  передаем задачу, которая внутри себя может сделать еще один сабмит.
[25:41.000 --> 25:43.000]  Вот она это и делает.
[25:45.000 --> 25:47.000]  Хорошо.
[25:48.000 --> 25:52.000]  Вот этот пример с вычислениями и зависимости между ними, он про что?
[25:52.000 --> 25:56.000]  Про параллелизм, про то, как эксплуатировать тот факт, что у нас много ядер
[25:56.000 --> 25:58.000]  и как-то их нагружать равномерно.
[25:58.000 --> 26:02.000]  Но с другой стороны, мы же говорили, что в нашем курсе нас параллелизм
[26:02.000 --> 26:05.000]  и ускорение за счет параллелизма не очень сильно беспокоит.
[26:05.000 --> 26:07.000]  Это не наша тема.
[26:07.000 --> 26:13.000]  Мы в этом курсе стремимся не ускорить исполнение ассортировки.
[26:13.000 --> 26:17.000]  Нас беспокоит масштабируемость, нас беспокоит конкарнси.
[26:17.000 --> 26:21.000]  Как именно упаковать в маленькое количество потоков в наш процессор
[26:21.000 --> 26:25.000]  очень много активности пользователей, то есть обработчиков их запросов.
[26:25.000 --> 26:27.000]  Вот как здесь вот.
[26:27.000 --> 26:29.000]  Здесь мы делаем это очень неэффективно.
[26:29.000 --> 26:31.000]  Мы хотим как-то эффективнее.
[26:31.000 --> 26:36.000]  Мы не будем писать с вами сортировки на пуле потоков.
[26:39.000 --> 26:41.000]  Наши задачи будут другую природу иметь.
[26:41.000 --> 26:46.000]  Давайте подумаем, что в нашем курсе будет являться задачей.
[26:46.000 --> 26:50.000]  Для пула потоков задача — это некоторая абстрактная функция.
[26:50.000 --> 26:54.000]  Пул не понимает, что это задача, что она делает, зачем она нужна.
[26:54.000 --> 26:57.000]  Как же будут выглядеть наши задачи?
[26:57.000 --> 26:59.000]  Понимаете ли вы?
[27:01.000 --> 27:05.000]  Звучит очень абстрактно.
[27:09.000 --> 27:11.000]  Такого слова в курсе не было еще.
[27:16.000 --> 27:19.000]  Так, а что будет таской? Что будет задачей?
[27:19.000 --> 27:23.000]  Нет. Нет, не получится.
[27:23.000 --> 27:27.000]  Потому что в запрос клиента он же, смотри, он же блокируется.
[27:27.000 --> 27:31.000]  Вот он заблокировался на чтении сокета, потом заблокировался на запись сокета.
[27:31.000 --> 27:35.000]  А задачи в пуле потоков не могут блокироваться.
[27:39.000 --> 27:41.000]  Что будет задачей?
[27:47.000 --> 27:49.000]  Трэдпул — это уже планировщик.
[27:49.000 --> 27:51.000]  Куда еще больше планировщиков?
[27:51.000 --> 27:53.000]  Тут уже есть операционная система.
[27:53.000 --> 27:55.000]  На дне юзерспейса есть трэдпул.
[27:55.000 --> 27:59.000]  Планировщик виртуальных ресурсов, виртуальных ядер.
[27:59.000 --> 28:01.000]  Нет?
[28:03.000 --> 28:05.000]  Ну вот, смотрите.
[28:05.000 --> 28:07.000]  Мы это обсудим через две лекции.
[28:07.000 --> 28:09.000]  У нас же файберы есть, да?
[28:09.000 --> 28:11.000]  И зачем они нам нужны?
[28:11.000 --> 28:13.000]  Ну не для того, чтобы, конечно, иил-то не делали.
[28:13.000 --> 28:15.000]  Или что-то такое бестолковое.
[28:15.000 --> 28:19.000]  Нам они нужны для того, чтобы они запускались в большом количестве.
[28:19.000 --> 28:21.000]  А исполнялись в маленьком количестве потоков.
[28:21.000 --> 28:25.000]  Но в данном случае файбер исполняется вообще в одном потоке.
[28:25.000 --> 28:27.000]  И при этом как-то его эффективно используют.
[28:27.000 --> 28:31.000]  Так вот, эти файберы, ну пока они ничего не умеют,
[28:31.000 --> 28:35.000]  но однажды они научатся воду-выводу работать с сетью.
[28:35.000 --> 28:37.000]  Или синхронизации.
[28:37.000 --> 28:41.000]  И вот, смотрите, такое интересное наблюдение.
[28:41.000 --> 28:45.000]  Вот файбер сам по себе — это не что иное как цепочка задач.
[28:45.000 --> 28:49.000]  Вот мы говорили, что в трэдпуле мы хотим запускать цепочки графа задач.
[28:49.000 --> 28:53.000]  Вот этот файбер отдельный, легковесный поток наш,
[28:53.000 --> 28:55.000]  он и будет графом задач, цепочкой задач.
[28:55.000 --> 28:59.000]  Он будет исполняться некоторое время, а потом будет встречать запись socket.
[28:59.000 --> 29:01.000]  Или чтение из socket.
[29:01.000 --> 29:03.000]  Или блокировку на мьютоксе.
[29:03.000 --> 29:05.000]  И что он будет делать? Он не будет блокировать поток, разумеется.
[29:05.000 --> 29:11.000]  Он будет каким-то образом подписываться на результат вот этой разблокировки,
[29:11.000 --> 29:15.000]  или чтения, и поток освобождать.
[29:15.000 --> 29:19.000]  А когда чтение завершится или мьютокс освободится,
[29:19.000 --> 29:21.000]  то этот файбер запланирует обратно.
[29:21.000 --> 29:27.000]  То есть нашими задачами будут кусочки кода между блокирующими операциями в файбере.
[29:27.000 --> 29:29.000]  Но блокировок потоков при этом не будет.
[29:29.000 --> 29:31.000]  И вот сами файберы будут для нас графами задач.
[29:31.000 --> 29:37.000]  И вот именно поэтому трэдпул претендует для нас на универсальность.
[29:37.000 --> 29:39.000]  Ему не нужно знать про задачи.
[29:39.000 --> 29:41.000]  Какую они природу имеют?
[29:41.000 --> 29:45.000]  Такое вычисление – это фрагменты файберов между точками блокировки.
[29:45.000 --> 29:47.000]  Для нашего трэдпула это просто задача.
[29:47.000 --> 29:53.000]  И мы увидим, что такая декомпозиция на самом деле очень разумна.
[29:53.000 --> 29:59.000]  То есть мы сможем с вами параллельно развивать трэдпул как планировщик
[29:59.000 --> 30:01.000]  и параллельно делать файберы, скажем.
[30:01.000 --> 30:07.000]  Добавлять в них мьютоксы, контвары, каналы, селекты, все, что ГО умеет.
[30:07.000 --> 30:09.000]  При этом трэдпул нам менять не потребуется.
[30:09.000 --> 30:13.000]  Вот файберы будут знать про трэдпул буквально одно –
[30:13.000 --> 30:15.000]  что в трэдпуле есть метод Submit.
[30:15.000 --> 30:17.000]  Этого будет достаточно.
[30:27.000 --> 30:29.000]  Да, а пул потоков про это ничего не знают.
[30:29.000 --> 30:31.000]  Ему просто дают задачи.
[30:31.000 --> 30:33.000]  А в этих задачах происходит некоторая сложная магия.
[30:33.000 --> 30:37.000]  Но вот пул потоков, как планировщик и файберы,
[30:37.000 --> 30:40.000]  как средство выражения конкурентных активностей,
[30:40.000 --> 30:43.000]  будут разделены вот такой очень простой границей.
[30:43.000 --> 30:46.000]  Вот одним методом Submit, который дает гарантию,
[30:46.000 --> 30:48.000]  что задачи, запланированные на выполнение,
[30:48.000 --> 30:50.000]  будут однажды где-то кем-то выполнены.
[30:54.000 --> 30:56.000]  Ну, это долгая история.
[30:56.000 --> 30:58.000]  Не то, чтобы планировать сейчас это объяснять.
[30:58.000 --> 31:01.000]  И скорее объясняю, что пул потоков для нас – это очень важный механизм.
[31:01.000 --> 31:03.000]  Это, собственно, планировщик в Visual Space.
[31:03.000 --> 31:07.000]  И он артагонален конкретному приложению.
[31:07.000 --> 31:09.000]  Ну, почти что.
[31:09.000 --> 31:11.000]  Не совсем справедливо, конечно, так говорить.
[31:11.000 --> 31:14.000]  Но можно будет придумать инструменты для того,
[31:14.000 --> 31:17.000]  чтобы писать квиксорты какие-нибудь поверх пула.
[31:17.000 --> 31:20.000]  Можно будет придумать инструменты, чтобы запускать легковесные потоки.
[31:20.000 --> 31:22.000]  Ну, в общем, трэдпул для всего сгодится.
[31:22.000 --> 31:25.000]  И вот поэтому я говорил на первой лекции,
[31:25.000 --> 31:27.000]  что у нас есть две такие большие сюжетные линии в курсе.
[31:27.000 --> 31:30.000]  Одна про то, как конкурентные активности выражать в коде
[31:30.000 --> 31:33.000]  и у нас будут файверы, у нас будут фьюч, разные способы.
[31:33.000 --> 31:36.000]  А параллельно с этим мы будем говорить про то,
[31:36.000 --> 31:39.000]  как эффективно задачи исполнять.
[31:39.000 --> 31:42.000]  И это история про внутренности трэдпула, в конце концов.
[31:42.000 --> 31:46.000]  У нас там будет много маленьких, ну, много больших маленьких шагов
[31:46.000 --> 31:48.000]  на этом пути.
[31:48.000 --> 31:51.000]  И вот этот дизайн, он, на самом деле, очень разумен.
[31:51.000 --> 31:54.000]  Ну, потому что он развязывает две большие задачи –
[31:54.000 --> 32:00.000]  исполнение и выражение в вашей логике.
[32:00.000 --> 32:04.000]  И этот дизайн, вот эта декомпозиция, она, конечно, справедлива
[32:04.000 --> 32:06.000]  не только для нашего курса, в смысле, она универсальна.
[32:06.000 --> 32:08.000]  Поэтому мы здесь ее и изучаем.
[32:08.000 --> 32:12.000]  Вот, скажем, я показывал вам на первой лекции пример эхосервера на Расте.
[32:14.000 --> 32:18.000]  Вот тут снова мы принимаем соединение клиентские с точки await.
[32:18.000 --> 32:20.000]  Я про него уже упоминал.
[32:20.000 --> 32:22.000]  Мы в будущем разберемся, что это значит.
[32:22.000 --> 32:26.000]  И запускаем задачи, которые для каждого клиента запускаем задачу,
[32:26.000 --> 32:30.000]  которая в цикле читает из socket и пишет socket.
[32:30.000 --> 32:34.000]  Но вот это выглядит немного иначе, чем мы будем делать, чем наши файберы.
[32:34.000 --> 32:36.000]  У наших файберов не будут никаких специальных ключевых слов.
[32:36.000 --> 32:40.000]  Но, тем не менее, под капотом у этого фреймворка что происходит?
[32:40.000 --> 32:44.000]  Смотрите, все вот это исполняется в некотором пуле потоков.
[32:46.000 --> 32:48.000]  Тут его мы явно не видим, но он есть.
[32:48.000 --> 32:52.000]  Ну или, скажем, мы говорим про корутины C++.
[32:52.000 --> 32:54.000]  Вот на них тоже можно...
[32:54.000 --> 32:56.000]  На корутины C++ 20.
[32:56.000 --> 32:58.000]  На них тоже можно написать эхосервер.
[32:58.000 --> 33:00.000]  Тоже с какими-то await-ами, ключевыми словами специальными.
[33:00.000 --> 33:02.000]  И опять же, где это все будет выполняться?
[33:02.000 --> 33:06.000]  Это все будет выполняться в некотором пуле потоков.
[33:08.000 --> 33:12.000]  Или мы говорим про язык Kotlin с его корутинами,
[33:12.000 --> 33:16.000]  которые умеют запускаться и блокироваться тоже умеют.
[33:16.000 --> 33:18.000]  Так вот, где они исполняются?
[33:18.000 --> 33:20.000]  Вот они исполняются в так называемых диспетчерах.
[33:24.000 --> 33:28.000]  Если вы не указываете, где именно корутина исполняется,
[33:28.000 --> 33:30.000]  она запускается в некотором фоновом пуле потоков.
[33:32.000 --> 33:34.000]  Или мы говорим про файберы, которые делают Java.
[33:36.000 --> 33:40.000]  И вот файберы файберами, но для них нужен планировщик,
[33:40.000 --> 33:44.000]  и это вот просто готовый планировщик из библиотеки Java,
[33:44.000 --> 33:46.000]  который уже написан, fork-join-pool.
[33:48.000 --> 33:52.000]  Короче говоря, декомпозиция разумная, и мы будем дальше ей пользоваться.
[33:52.000 --> 33:54.000]  То есть мы будем отдельно делать файберы, отдельно делать пул потоков,
[33:54.000 --> 33:58.000]  и то и другое будем развивать, ну почти что независимо друг от друга.
[33:58.000 --> 34:02.000]  В какой-то момент мы увидим, что все-таки нужно какие-то связи учитывать,
[34:02.000 --> 34:04.000]  но до этого нужно еще добраться.
[34:04.000 --> 34:08.000]  Итак, почему нам важен пул? Мы выяснили, что такое пул потоков,
[34:08.000 --> 34:10.000]  как мы собираемся с потоками вообще в курсе работать.
[34:10.000 --> 34:14.000]  Мы выяснили примерно, как он реализован и почему нас он интересует.
[34:14.000 --> 34:16.000]  Осталось только написать.
[34:18.000 --> 34:20.000]  Ну вот давайте мы этим и займемся.
[34:20.000 --> 34:24.000]  Итак, у нас есть пул потоков с предсказуемым API.
[34:24.000 --> 34:28.000]  Submit, fade, stop, которые мы обсудили.
[34:28.000 --> 34:32.000]  И вот мы хотим, чтобы этот threadpool мог работать вот с такими вот примерами.
[34:34.000 --> 34:38.000]  Давайте запустим этот пример, посмотрим, как это работает.
[34:38.000 --> 34:42.000]  Ну вот, у нас есть пул потоков с предсказуемым API.
[34:42.000 --> 34:46.000]  И вот мы хотим, чтобы этот threadpool мог работать вот с такими вот примерами.
[34:46.000 --> 34:52.000]  Давайте запустим этот пример, посмотрим, что он напечатает.
[34:56.000 --> 35:00.000]  1, 2. Что вы про это скажете?
[35:02.000 --> 35:06.000]  Это не похоже на threadpool, потому что threadpool должен запустить задачи параллельно
[35:06.000 --> 35:09.000]  на разных потоках, потому что всего их 4, задача 2, одна спит,
[35:09.000 --> 35:12.000]  но почему другая в это время не исполнилась на другом потоке?
[35:12.000 --> 35:18.000]  Ну, это в общем не странно, потому что threadpool пока реализован очень лаконично.
[35:18.000 --> 35:21.000]  Вот он в методе Submit просто запускает задачу синхронно.
[35:21.000 --> 35:23.000]  Ну потоков у нас нет просто.
[35:23.000 --> 35:27.000]  Ну вот давайте мы начнем с того, что заведем в threadpool потоки.
[35:27.000 --> 35:29.000]  Пока у нас такая заглушка, тут ничего нет.
[35:29.000 --> 35:34.000]  Submit исполнение задачи, fade пустой, stop пустой, threadpool ничего не умеет.
[35:34.000 --> 35:39.000]  Ну раз уж мы сказали, что в threadpool должны быть потоки, то давайте мы заведем потоки.
[35:42.000 --> 35:50.000]  Вот, я буду писать какие-то ошибки к имперации, поэтому, пожалуйста, поправляйте мне, если буду так делать.
[35:59.000 --> 36:05.000]  Потоки называются worker, они вот рабочие потоки запускают и исполняют задачи.
[36:09.000 --> 36:11.000]  Почему бы и нет?
[36:12.000 --> 36:18.000]  В смысле, почему мы не используем framework для тестирования, потому что мы не пишем домашнюю работу сейчас.
[36:18.000 --> 36:23.000]  Ну можно было бы использовать, тут просто короче будет так писать.
[36:23.000 --> 36:26.000]  Окей, пишем конструктор.
[36:26.000 --> 36:30.000]  Что мы здесь напишем? Ну давайте заведем отдельный метод, что ли.
[36:30.000 --> 36:32.000]  А может быть даже и не будем, напишем прямо здесь.
[36:32.000 --> 36:34.000]  Нет, не хочу.
[36:42.000 --> 36:44.000]  Чем эти потоки будут заниматься?
[37:12.000 --> 37:18.000]  Ну пока не интересно, они будут выполнять какую-то функцию.
[37:18.000 --> 37:22.000]  Рабочая функция для каждого потока.
[37:22.000 --> 37:26.000]  Вот давайте мы напишем EU.
[37:26.000 --> 37:40.000]  Итак, worker исполняет вот эту пока пустую функцию.
[37:40.000 --> 37:44.000]  И у нас есть submit, ну вот давайте мы submit это тоже.
[37:44.000 --> 37:46.000]  Изменим в правильном направлении.
[37:46.000 --> 37:50.000]  Итак, что делают worker?
[37:50.000 --> 37:54.000]  Они, наверное, ждут, когда им сюда идет вопрос.
[37:54.000 --> 37:58.000]  Но судя по картинке, что делают worker и что делают клиенты в submite?
[37:58.000 --> 38:00.000]  Они работают с очередью.
[38:00.000 --> 38:02.000]  Вот клиенты кладут в очередь,
[38:02.000 --> 38:04.000]  worker забирают задачи из очереди и исполняют их.
[38:04.000 --> 38:08.000]  Поэтому, видимо, нам нужно написать очередь.
[38:08.000 --> 38:14.000]  И для этого у нас есть заготовка, отдельный header, в котором будет очередь задач.
[38:14.000 --> 38:20.000]  Но смотрите, очередь задач, она нужна не только для пулопотоков.
[38:20.000 --> 38:24.000]  Просто примитив коммуникации и синхронизации для потоков довольно общий.
[38:24.000 --> 38:28.000]  Поэтому очередь у нас будет, конечно, шаблоном.
[38:34.000 --> 38:38.000]  Назовем ее пока так, чуть позже пересмотрим это название.
[38:38.000 --> 38:40.000]  Что она будет уметь?
[38:50.000 --> 38:54.000]  Здесь? Не знаю.
[38:54.000 --> 38:58.000]  Почему мы копируем его?
[38:58.000 --> 39:02.000]  Мы пишем шаблон.
[39:02.000 --> 39:06.000]  Тут класс T.
[39:06.000 --> 39:10.000]  Это могут быть копируемые объекты, могут быть move-only.
[39:10.000 --> 39:14.000]  Вот, кажется, такая сигнатура позволяет нам работать и с move-only объектами.
[39:14.000 --> 39:18.000]  Если клиент хочет копировать, он просто копирует, передает по значению.
[39:18.000 --> 39:22.000]  Если клиент хочет помувать, он пишет put std move и свой объект.
[39:22.000 --> 39:26.000]  Кажется, что это довольно универсально.
[39:26.000 --> 39:34.000]  И в пуле потоков мы собираемся эту блокирующую очередь использовать для того, чтобы передавать задачи.
[39:34.000 --> 39:38.000]  Вот у нас есть задача, это std function.
[39:38.000 --> 39:42.000]  И что мы сделаем в Submitty?
[39:42.000 --> 39:46.000]  Мы положим туда задачу.
[39:46.000 --> 39:52.000]  Что мы сделаем в процедуре потока?
[39:52.000 --> 39:58.000]  Мы положим туда задачу.
[39:58.000 --> 40:02.000]  Ну, это процедура, которая выполняет каждый поток worker.
[40:02.000 --> 40:06.000]  Вот, смотри, мы завели потоки в конструкторе.
[40:06.000 --> 40:10.000]  Завели count потоков.
[40:10.000 --> 40:14.000]  Создали в массиве workers, в векторе workers потоки.
[40:14.000 --> 40:18.000]  И каждый из них исполняет вот такую вот лямду.
[40:18.000 --> 40:22.000]  Ну, вот, вот.
[40:22.000 --> 40:26.000]  Такое вот замыкание.
[40:26.000 --> 40:30.000]  Понятно или нужно пояснить что-то?
[40:46.000 --> 40:50.000]  Ну, можем. Мне просто...
[40:50.000 --> 40:54.000]  Мне кажется, так...
[40:54.000 --> 40:58.000]  Ну, там нужно будет все эти байнды писать. Вот не хочется.
[40:58.000 --> 41:04.000]  Лямбда... Короче, в C++ какого-то, не знаю, с какого-то года не нужно писать все эти байнды, нужно писать лямбда.
[41:04.000 --> 41:08.000]  Это правильный способ, по разной причине.
[41:12.000 --> 41:16.000]  Что?
[41:16.000 --> 41:20.000]  Во-первых, не надо, потому что я могу и так, и так делать.
[41:20.000 --> 41:24.000]  Я могу ему-ить, когда я захочу, и копировать, когда я захочу.
[41:24.000 --> 41:28.000]  Я всем управляю. Мне не надо, например.
[41:28.000 --> 41:32.000]  Вот. Значит, пока понятно, да, что происходит?
[41:32.000 --> 41:36.000]  Пока только не написана очередь.
[41:36.000 --> 41:40.000]  Ну, вот мы уже научились ей пользоваться, пока не написана очередь.
[41:40.000 --> 41:44.000]  А вот смотрите, нужны ли в этой очереди какие-то другие методы?
[41:44.000 --> 41:48.000]  Ну, скажем...
[41:48.000 --> 41:52.000]  Ну, вот да. Хотелось бы какой-нибудь метод из empty, да?
[41:52.000 --> 41:56.000]  Да я его вообще писать не хочу, потому что это бессмыслится.
[41:56.000 --> 42:02.000]  В блокирующей очереди не нужны ни методы empty, ни методы size, ничего подобного.
[42:02.000 --> 42:06.000]  Это не контейнер для хранения данных.
[42:06.000 --> 42:10.000]  Это примитив коммуникации. У него совсем другие сценарии использования.
[42:10.000 --> 42:14.000]  Вот вы... Зачем вам метод empty? Вы вызвали его и получили true. Что это означает?
[42:14.000 --> 42:18.000]  Да ничего, потому что после вызова через миллисекунду очередь снова может стать пустой.
[42:18.000 --> 42:22.000]  Для вас это абсолютно бесполезный сигнал.
[42:22.000 --> 42:26.000]  Вы не можете на него надеяться. Все слишком мимолетно.
[42:26.000 --> 42:30.000]  Поэтому метод empty... Констат такие... Просто сотрем это все.
[42:30.000 --> 42:34.000]  У нас ни empty, ни size ничего не будет. Вот здесь мы кладем задачу в очередь,
[42:34.000 --> 42:38.000]  здесь мы дожидаемся очередной задачи. Вот и все, что нам нужно.
[42:38.000 --> 42:44.000]  Вот, ничем другим нам пользоваться. И в эту задачу не потребуется, и в принципе не потребуется.
[42:44.000 --> 42:48.000]  Ну что, давайте писать теперь вот эту самую очередь.
[42:48.000 --> 42:52.000]  Потому что сам предпул кажется пока слишком прост, чтобы его как-то комментировать.
[42:52.000 --> 42:56.000]  Но метод wait не написан, к этому вернемся еще.
[42:56.000 --> 43:00.000]  Итак, очередь... Для нее нужен контейнер.
[43:00.000 --> 43:04.000]  Давайте возьмем контейнер.
[43:08.000 --> 43:12.000]  Ну и что этому контейнеру не хватает еще?
[43:12.000 --> 43:16.000]  Не хватает Mutex, потому что, смотрите, разные потоки вызывают take
[43:16.000 --> 43:20.000]  на одной и той же очереди, разные воркеры, и разные клиенты вызывают submit.
[43:20.000 --> 43:26.000]  И все работают с одной очередью, с одним контейнером buffer внутри.
[43:26.000 --> 43:32.000]  Так что его нужно защитить. Для этого мы используем Mutex.
[43:38.000 --> 43:44.000]  Вот, к сожалению, для Mutex имя Mutex лучше всего походит,
[43:44.000 --> 43:48.000]  но это буквально единственное исключение в жизни, кажется, когда такая ситуация возникает.
[43:48.000 --> 43:52.000]  Во всех остальных случаях можно подобрать какое-то более подходящее имя,
[43:52.000 --> 43:56.000]  но вот здесь сойдет такое.
[43:56.000 --> 44:00.000]  Окей, давайте напишем put теперь.
[44:00.000 --> 44:04.000]  Что?
[44:08.000 --> 44:12.000]  Не очень понял.
[44:12.000 --> 44:16.000]  Ну, во-первых, этот класс, которого нет в std, мы пишем сейчас на std.
[44:16.000 --> 44:20.000]  Во-вторых, нет, не подойдет. Ну, почему мы сейчас не понимаем пока...
[44:20.000 --> 44:24.000]  Ладно, мы можем это понимать, но, видимо, пока не понимаем.
[44:24.000 --> 44:28.000]  Давайте допишем put.
[44:30.000 --> 44:34.000]  Пут готов, да?
[44:34.000 --> 44:38.000]  Давайте напишем take теперь.
[44:38.000 --> 44:42.000]  Что в нем должно быть?
[44:42.000 --> 44:48.000]  Так, я вот руками Mutex не захватываю, я использую Rybert. Отлично.
[44:48.000 --> 44:52.000]  Ну, давайте я напишу сейчас такой вспомогательный метод, который потом мне пригодится,
[44:52.000 --> 44:56.000]  пока он может выглядеть немного лишним.
[45:00.000 --> 45:04.000]  Вот метод, который извлекает из головы очереди элемент в предположении,
[45:04.000 --> 45:08.000]  что эта очередь не пустая, буфер не пустой.
[45:30.000 --> 45:34.000]  Потому что я хочу Assert.
[45:34.000 --> 45:38.000]  Нет, не очень понял.
[45:38.000 --> 45:42.000]  Извини за мой тупой ответ. Это precondition для функции.
[45:42.000 --> 45:46.000]  То есть функция вызывается в предположении, что буфер не пуст.
[45:46.000 --> 45:50.000]  Ну, потому что было бы странно, если бы я move-ал из головы буфера что-то, когда он пустой.
[45:50.000 --> 45:54.000]  То есть это не то, что я проверяю, я вот предполагаю, что функцию иначе бы не вызвали.
[45:54.000 --> 45:58.000]  Вот. А теперь что мне написать в take?
[45:58.000 --> 46:04.000]  В общем, какая семантика подходит потоку воркеру?
[46:04.000 --> 46:10.000]  Ну, чтобы оно блокировалось до сих пор пока либо в YouTube заплачено,
[46:10.000 --> 46:14.000]  либо пока заплачен в YouTube или очень пустая.
[46:14.000 --> 46:18.000]  То есть смотрите, мы вот в этом месте, в этой строчке хотим,
[46:18.000 --> 46:22.000]  чтобы поток воркер блокировался, если очередь пустая.
[46:22.000 --> 46:26.000]  Поэтому, собственно, у нас blocking queue называется это все.
[46:26.000 --> 46:30.000]  Ну вот, что же мы тут напишем?
[46:30.000 --> 46:36.000]  Ладно, прежде чем мы что-то напишем, у меня есть некоторые комментарии к именованию этого класса,
[46:36.000 --> 46:40.000]  потому что, возможно, название можно улучшить.
[46:40.000 --> 46:44.000]  Дело в том, что очередей в мире великое множество.
[46:44.000 --> 46:52.000]  В смысле, очередей десинхронизации потоков, потому что они все предназначены для немного разных сценариев.
[46:53.000 --> 46:58.000]  Вот бывают очереди неограниченной ёмкости, бывают ограниченной ёмкости,
[46:58.000 --> 47:02.000]  вот наша очередь будет неограниченна.
[47:02.000 --> 47:06.000]  По некоторым причинам так разумно. Вообще говоря, теория массовое обслуживание говорит,
[47:06.000 --> 47:10.000]  что если у вас система обслуживает пользователей и в ней бесконечные очереди,
[47:10.000 --> 47:14.000]  тогда это бесконечное время ожидания, и вот это так не нужно делать.
[47:14.000 --> 47:18.000]  Нужно явно отказывать, они увеличивают время ожидания для бесконечности,
[47:18.000 --> 47:21.000]  но вот здесь нам подойдет такая семантика.
[47:21.000 --> 47:28.000]  Кроме того, есть сценарии в зависимости от того, различают сценарий в зависимости от того,
[47:28.000 --> 47:31.000]  какое количество потоков кладет элементы в очередь и какого извлекает.
[47:31.000 --> 47:35.000]  Потоки, которые кладут элементы в очередь, их называют продюсерами.
[47:40.000 --> 47:42.000]  Потоки, которые извлекают, называют консюмерами.
[47:42.000 --> 47:54.000]  Вот тут верно. Поэтому мы скажем, что это мультипродюсер, мультиконсюмер.
[47:54.000 --> 48:00.000]  Ну или пишут так вот. Или бывает там мультипродюсер сингл консюмер.
[48:00.000 --> 48:03.000]  Такие у нас очереди тоже будут. Ну она блокирующая.
[48:03.000 --> 48:07.000]  То есть если очередь пустая, то поток, который извлекает, у него что-то,
[48:07.000 --> 48:10.000]  который ждет из нее элементов, он заблокируется.
[48:10.000 --> 48:17.000]  Вот такая вот штука. Так вот, хорошо бы это все отразить название.
[48:30.000 --> 48:34.000]  Вот вы читаете код, и вы сразу понимаете поведение этой очереди.
[48:34.000 --> 48:37.000]  Это довольно разумно. Правда, очередей бывает много разных.
[48:37.000 --> 48:42.000]  Я не шучу сейчас. В смысле, это хорошее, это лучшее название для этой очереди.
[48:42.000 --> 48:46.000]  Ну и вот, она должна заблокироваться в методе take, если очередь пустая.
[48:46.000 --> 48:47.000]  Что делать-то?
[48:52.000 --> 48:55.000]  Да-да-да. Продюсеры-консюмеры.
[48:58.000 --> 49:05.000]  Ну вот, если буфер не пустой, то мы так уж и быть вызовем функцию takeLocked.
[49:08.000 --> 49:13.000]  Простите. А иначе что нам делать?
[49:15.000 --> 49:17.000]  Нет, не просится.
[49:18.000 --> 49:22.000]  Фютекс не просится. Давайте я сразу объясню, наверное, почему.
[49:22.000 --> 49:26.000]  Потому что фютекс, это очень низкоуровневый приметив синхронизации, очень низкоуровневый.
[49:26.000 --> 49:29.000]  И у него семантика такая, она связана с ячейкой памяти.
[49:29.000 --> 49:34.000]  То есть мы заснем мы или не заснем зависит от содержимого ячейки.
[49:34.000 --> 49:37.000]  А здесь заснем мы или не заснем зависит не от содержимого ячейки.
[49:37.000 --> 49:40.000]  Здесь это зависит от состояния дека.
[49:40.000 --> 49:42.000]  Это несколько более сложный объект.
[49:42.000 --> 49:46.000]  Поэтому фютекс, в конечном итоге вы правы.
[49:46.000 --> 49:50.000]  В смысле, операционная система ничего, кроме фютекса, для блокирующего ожидания не дает.
[49:50.000 --> 49:54.000]  Но, тем не менее, вот прямо фютекс мы здесь использовать не хотим.
[49:54.000 --> 49:57.000]  Давайте мы напишем сначала очень тупое решение без знания фютекса.
[49:57.000 --> 50:00.000]  Допустим, про фютекс в первый раз в нум вообще не знаю ничего.
[50:00.000 --> 50:03.000]  Вот напишем следующее.
[50:10.000 --> 50:13.000]  Заменим это все на униклог, во-первых.
[50:15.000 --> 50:19.000]  Который умеет разблокироваться вручную.
[50:19.000 --> 50:24.000]  То есть он в конструкторе тоже захватывает мютекс, диструктор освобождает, но у него есть минутанлог.
[50:24.000 --> 50:27.000]  И вот если очередь была не пустая, то что мы сделаем?
[50:27.000 --> 50:30.000]  Мы заберем элемент и вернем его.
[50:30.000 --> 50:33.000]  А иначе как нам быть?
[50:33.000 --> 50:36.000]  Мы пришли в очередь, взяли мютекс.
[50:36.000 --> 50:39.000]  Видим, что очередь пустая.
[50:39.000 --> 50:42.000]  Пока мы мютекс держим, новый элемент никто не положит.
[50:42.000 --> 50:45.000]  Поэтому мы должны лог отпустить.
[50:52.000 --> 50:56.000]  Так нам же нужно время дать другим потокам, чтобы они сделали что-то полезное.
[50:58.000 --> 51:01.000]  Зачем?
[51:01.000 --> 51:04.000]  Чтобы они тоже имели доступ к этой очереди.
[51:04.000 --> 51:07.000]  Я сейчас напишу какой-то скверный код.
[51:09.000 --> 51:12.000]  По разным причинам он скверный.
[51:13.000 --> 51:17.000]  Например, не пишите using numspace в заголовочных файлах.
[51:19.000 --> 51:23.000]  Но все равно этот код стелеть придется, так что не страшно.
[51:23.000 --> 51:26.000]  Вот такая реализация.
[51:27.000 --> 51:30.000]  Мне кажется, что она лучше, чем ничего.
[51:30.000 --> 51:33.000]  То есть она должна примерно работать.
[51:33.000 --> 51:36.000]  Может быть, это не самый эффективный способ делать синхронизацию.
[51:36.000 --> 51:39.000]  В смысле, спать 10 мс.
[51:39.000 --> 51:42.000]  Потому что, может быть, через 1 мс. элемент появится.
[51:42.000 --> 51:45.000]  Пока так.
[51:45.000 --> 51:48.000]  Мне кажется, что очередь мы в целом написали.
[51:48.000 --> 51:51.000]  Трэдпул тоже мы почти написали.
[51:51.000 --> 51:55.000]  Вот здесь мы ждем задачу, исполняем задачу, игнорируем исключение правды.
[51:55.000 --> 51:58.000]  Здесь мы планируем задачу на исполнение.
[51:58.000 --> 52:01.000]  Ну и давайте напишем тест для нашего трэдпула.
[52:06.000 --> 52:09.000]  Тест будет с датарейсом, простите меня.
[52:09.000 --> 52:12.000]  Аккуратные люди.
[52:20.000 --> 52:24.000]  Я бросаю в пул задачи, которые будут просто увеличивать счетчик.
[52:25.000 --> 52:28.000]  А потом я, видимо, хочу дождаться их завершения.
[52:30.000 --> 52:33.000]  Кажется, мы не написали эту функцию, да?
[52:33.000 --> 52:36.000]  Ну ничего.
[52:39.000 --> 52:42.000]  К этому вы вернетесь к домашней работе.
[52:45.000 --> 52:48.000]  Вот. Ну и у нас не хватает еще метода stop.
[52:48.000 --> 52:51.000]  Ну или даже пока напишем еще проще.
[52:51.000 --> 52:54.000]  Напишем в деструкторе, что у нас...
[53:02.000 --> 53:05.000]  Потоков не осталось.
[53:07.000 --> 53:10.000]  Что?
[53:10.000 --> 53:13.000]  Что?
[53:14.000 --> 53:17.000]  Что?
[53:17.000 --> 53:20.000]  Сломается? Ну так и должно быть, мы же не написали метод.
[53:24.000 --> 53:27.000]  Нет, еще раз. Не еще раз, в смысле, я обозначу нашу цель.
[53:27.000 --> 53:30.000]  Наша цель написать какой-то пул потоков.
[53:30.000 --> 53:33.000]  Хороший вы напишите дома сами.
[53:33.000 --> 53:36.000]  Вот все, что вам не нравится, вы можете потом исправить.
[53:38.000 --> 53:41.000]  В смысле, почему он сейчас должен задачу запускать уже?
[53:41.000 --> 53:44.000]  Ну деструктор это не совсем не работает, не упривыречивай.
[53:47.000 --> 53:50.000]  Вот давайте мы запустим сейчас этот пример.
[53:58.000 --> 54:01.000]  Ну он что-то вывел и сломался, да?
[54:01.000 --> 54:04.000]  Насколько разумно то, что он вывел?
[54:06.000 --> 54:09.000]  Давайте вот убедимся, что задачи все выполнились уже к этому моменту.
[54:09.000 --> 54:12.000]  Просто, может быть, он какие-то задачи потерял, их было 100 500,
[54:12.000 --> 54:15.000]  а получилось вот 9 9 3.
[54:15.000 --> 54:18.000]  Нет, судя по осердту, у нас просто деструктор упал,
[54:18.000 --> 54:21.000]  потому что мы потоки не остановили.
[54:23.000 --> 54:26.000]  Я сейчас ожидаю, что числа совпадут.
[54:28.000 --> 54:31.000]  Отлично. Значит, наш пул потоков
[54:31.000 --> 54:34.000]  он работает, потому что числа совпадут.
[54:34.000 --> 54:37.000]  Задачи кончились в нем.
[54:37.000 --> 54:40.000]  Но ответ не 100 500, потому что он работает параллельно.
[54:40.000 --> 54:43.000]  И вот эти счетчики, они между другом,
[54:43.000 --> 54:46.000]  эти инкременты гоняются и получается, что какие-то два инкремента
[54:46.000 --> 54:49.000]  читают в регистре одно и то же. В регистрах увеличивают,
[54:49.000 --> 54:52.000]  потом пишут дважды одно и то же. То есть, инкременты теряются.
[54:52.000 --> 54:55.000]  То есть, то, что у нас число меньше, чем 100 500, это наоборот хорошо.
[54:55.000 --> 54:58.000]  Значит, пул работает параллельно. Запускать задачи в разных потоках.
[54:58.000 --> 55:01.000]  Ну так сложили, так вот выстроились планеты, я не знаю.
[55:04.000 --> 55:07.000]  Я бы не стал здесь, короче,
[55:07.000 --> 55:10.000]  это не то, что нужно делать.
[55:10.000 --> 55:13.000]  Насколько много у вас гонок получилось в программе?
[55:13.000 --> 55:16.000]  Должно быть ноль просто.
[55:19.000 --> 55:22.000]  Ну, я не знаю.
[55:22.000 --> 55:25.000]  Ну, тут от многих вещей это зависит.
[55:25.000 --> 55:28.000]  Пока планируем задачи, мы планируем их в один поток,
[55:28.000 --> 55:31.000]  а исполняются они в четыре потока.
[55:31.000 --> 55:34.000]  Но, может быть, их просто много там не накапливается в пуле.
[55:34.000 --> 55:37.000]  Ладно, пул работает в целом.
[55:37.000 --> 55:40.000]  Пока у нас очередь плохо написана.
[55:40.000 --> 55:43.000]  Вот давайте мы это место исправим.
[55:43.000 --> 55:46.000]  Ну, давайте мы это место исправим.
[55:46.000 --> 55:49.000]  Пока у нас очередь плохо написана.
[55:49.000 --> 55:52.000]  Вот давайте мы это место исправим.
[55:52.000 --> 55:55.000]  И смотрите, я утверждаю, что здесь задача довольно общая.
[55:55.000 --> 55:58.000]  Вот смотрите, у нас было некоторое...
[55:58.000 --> 56:01.000]  Что происходит у нас?
[56:01.000 --> 56:04.000]  У нас есть очередь, в ней есть буфер.
[56:04.000 --> 56:07.000]  Мы берем mutex, смотрим на буфер.
[56:07.000 --> 56:10.000]  Если он не пуст, то извлекаем элемент.
[56:10.000 --> 56:13.000]  Если он пуст, то мы должны mutex отпустить, чтобы дождаться,
[56:13.000 --> 56:16.000]  пока в буфере появится новый элемент.
[56:16.000 --> 56:19.000]  Проснуться и этот элемент забрать.
[56:19.000 --> 56:22.000]  Забрать mutex обратно, забрать этот элемент.
[56:22.000 --> 56:25.000]  Можно здесь увидеть некоторую общую задачу.
[56:25.000 --> 56:28.000]  Вот у вас есть разделяемое состояние.
[56:28.000 --> 56:31.000]  У вас есть mutex, который вас защищает.
[56:31.000 --> 56:34.000]  У вас есть потоки, которые ждут
[56:34.000 --> 56:37.000]  выполнения некоторого условия на этом разделяемом состоянии.
[56:37.000 --> 56:40.000]  И у вас есть потоки, которые это состояние меняют
[56:40.000 --> 56:43.000]  и это условие реализуют.
[56:43.000 --> 56:46.000]  И им нужен примитив для синхронизации.
[56:46.000 --> 56:49.000]  Вот мы здесь... Чего бы хотели в идеальном решении?
[56:49.000 --> 56:52.000]  Вот в этом месте, в этом else.
[56:52.000 --> 56:55.000]  Мы бы хотели заблокировать текущий поток.
[56:55.000 --> 56:58.000]  Мы бы хотели отпустить mutex
[56:58.000 --> 57:01.000]  и заблокировать текущий поток до тех пор,
[57:01.000 --> 57:04.000]  пока другой поток не захватит mutex сам
[57:04.000 --> 57:07.000]  и не положит в буфер новый элемент.
[57:08.000 --> 57:11.000]  Задача довольно общая.
[57:11.000 --> 57:14.000]  Эта очередь с этим буфером, это просто частная иллюстрация этой общей задачи.
[57:14.000 --> 57:17.000]  Ждем исполнение предиката на разделяемом состоянии,
[57:17.000 --> 57:20.000]  выполняем предикат и уведомляем другой поток.
[57:20.000 --> 57:23.000]  Ну и вот для этой общей задачи есть
[57:23.000 --> 57:26.000]  общее решение, которое называется condition variable
[57:26.000 --> 57:30.000]  или условная переменная или кондвар, просто говорят.
[57:30.000 --> 57:33.000]  Вот у этого самого кондвара есть,
[57:33.000 --> 57:36.000]  ну, можно сказать, три метода.
[57:36.000 --> 57:39.000]  С одной стороны это wait для блокирующего ожидания
[57:39.000 --> 57:42.000]  и с другой стороны два вызова notify one и all
[57:42.000 --> 57:45.000]  для того, чтобы уведомлять другой поток,
[57:45.000 --> 57:48.000]  что условие некоторое выполнено.
[57:48.000 --> 57:51.000]  Какова семантика этих операций?
[57:51.000 --> 57:55.000]  Семантика wait. Давайте перейдем
[57:55.000 --> 57:58.000]  в условия одной из домашних задач ваших.
[57:58.000 --> 58:01.000]  Все, что мы видим в этом курсе,
[58:01.000 --> 58:04.000]  мы потом делаем руками, поэтому и кондвар не станет исключением.
[58:06.000 --> 58:09.000]  Вызов wait.
[58:09.000 --> 58:12.000]  Вызов wait мы передаем,
[58:12.000 --> 58:15.000]  ну, в наш wait в домашней работе мы передаем
[58:15.000 --> 58:18.000]  прямо захваченный mutex, в std condition variable
[58:18.000 --> 58:21.000]  мы передаем
[58:21.000 --> 58:24.000]  unique lock с захваченным mutex.
[58:24.000 --> 58:27.000]  И семантика такова.
[58:27.000 --> 58:30.000]  Мы отпускаем lock внутри вызова wait
[58:30.000 --> 58:33.000]  и засыпаем в некоторые очереди внутри ядра.
[58:33.000 --> 58:36.000]  Ну, под капотом там все равно будет mutex, вы это сами увидите
[58:36.000 --> 58:39.000]  в домашней работе. Ничего другого вы все равно нет.
[58:39.000 --> 58:42.000]  И когда другой поток
[58:42.000 --> 58:45.000]  вызывает notify one, он вас будет
[58:45.000 --> 58:48.000]  и вы из wait возвращаетесь обратно,
[58:48.000 --> 58:51.000]  обратно захватывая lock.
[58:54.000 --> 58:57.000]  То есть снаружи wait вы всегда
[58:57.000 --> 59:00.000]  lock'ом владеете, внутри wait вы его отпускаете,
[59:00.000 --> 59:03.000]  заходите и забираете обратно,
[59:03.000 --> 59:06.000]  когда вы возвращаетесь из вызова.
[59:10.000 --> 59:13.000]  Один из ждущих потоков.
[59:18.000 --> 59:21.000]  Условные перемены, как ты видишь,
[59:21.000 --> 59:24.000]  просто по сигнатурам вызовов, ни про какие предикаты,
[59:24.000 --> 59:27.000]  это можно стереть из своей памяти,
[59:27.000 --> 59:30.000]  чтобы закрыть глаза и не видеть этого.
[59:30.000 --> 59:33.000]  Вот у вызова wait нет никакого предиката.
[59:33.000 --> 59:36.000]  Условная переменная про предикат ничего не знает.
[59:36.000 --> 59:39.000]  Состояние, условие, буфер, пуст, не пуст.
[59:39.000 --> 59:42.000]  Кондвар про это ничего не знает.
[59:42.000 --> 59:45.000]  У него есть просто wait.
[59:45.000 --> 59:48.000]  Это неправильный вывод,
[59:48.000 --> 59:51.000]  правильный ответ сложнее.
[59:51.000 --> 59:54.000]  Но вот в нашей домашней работе в кондваре не будет этого предиката,
[59:54.000 --> 59:57.000]  это просто некоторое,
[59:57.000 --> 01:00:00.000]  ну не знаю, не сахар, не так не говорят,
[01:00:00.000 --> 01:00:03.000]  некоторая маленькая утерита,
[01:00:03.000 --> 01:00:06.000]  которая помогает использовать кондвар, чтобы это было проще немножко.
[01:00:06.000 --> 01:00:09.000]  Но это не фундаментальный метод кондвара.
[01:00:09.000 --> 01:00:12.000]  Операция основная кондвара это wait, notify one, notify all.
[01:00:12.000 --> 01:00:15.000]  Wait с одним аргументом захваченный mutex.
[01:00:15.000 --> 01:00:18.000]  И очень важно, пока мы этого не понимаем, наверное,
[01:00:18.000 --> 01:00:21.000]  что когда мы вызываем wait,
[01:00:21.000 --> 01:00:24.000]  то мы атомарно отпускаем блокировку и встаем на очередь ожидания.
[01:00:24.000 --> 01:00:27.000]  Конечно, на уровне процессора это не атомарно все,
[01:00:27.000 --> 01:00:30.000]  но вот атомарность, как она достигается,
[01:00:30.000 --> 01:00:33.000]  вы опять же в домашней работе увидите.
[01:00:33.000 --> 01:00:36.000]  Когда мы вызываем notify one, мы будем один из ждущих потоков.
[01:00:36.000 --> 01:00:39.000]  Он просыпается, захватывает mutex обратно,
[01:00:39.000 --> 01:00:42.000]  и выходит. Если мы зовем notify all,
[01:00:42.000 --> 01:00:45.000]  то мы будем все потоки, которые ждали на кондваре,
[01:00:45.000 --> 01:00:48.000]  и они все пытаются выйти из wait,
[01:00:48.000 --> 01:00:51.000]  но они не могут, потому что mutex один.
[01:00:51.000 --> 01:00:54.000]  Но они все по очереди его захватят и выйдут из этого кондвара,
[01:00:54.000 --> 01:00:57.000]  из этого wait.
[01:00:57.000 --> 01:01:00.000]  Осталось теперь кондварам воспользоваться, чтобы написать
[01:01:00.000 --> 01:01:03.000]  блокирующую очередь чуть получше.
[01:01:03.000 --> 01:01:06.000]  Давайте ее назовем пока вот так,
[01:01:06.000 --> 01:01:09.000]  вот это плохая идея, мы имя скоро исправим.
[01:01:09.000 --> 01:01:12.000]  Какой код мы здесь напишем?
[01:01:12.000 --> 01:01:15.000]  Опять захватываем mutex.
[01:01:18.000 --> 01:01:21.000]  А теперь мы будем их исправить.
[01:01:21.000 --> 01:01:24.000]  Я неаю, неаю, неаю, неаю.
[01:01:24.000 --> 01:01:27.000]  Я неаю, неаю, неаю.
[01:01:27.000 --> 01:01:35.500]  Опять захватываем Mutex, а теперь нам нужна не пустая очередь.
[01:01:42.500 --> 01:01:47.000]  Что делать? Видимо, мы хотим Mutex и дождаться, пока очередь станет не пустой.
[01:01:48.000 --> 01:01:49.000]  Отлично.
[01:01:49.000 --> 01:01:52.000]  А в методе Mutex мы напишем на tf1.
[01:01:54.000 --> 01:01:59.000]  Мы положили элемент в очередь и разбудили один из потоков, который ждал, возможно, этого элемента.
[01:02:04.000 --> 01:02:06.000]  Сейчас, повтори вопрос, пожалуйста.
[01:02:07.000 --> 01:02:09.000]  Сейчас, повтори вопрос, пожалуйста.
[01:02:19.000 --> 01:02:28.000]  Wait отомарно. Wait, во-первых, отпустит Mutex, во-вторых, заснет в очереди.
[01:02:29.000 --> 01:02:41.000]  В-третьих, когда другой поток вызовет на tf1, проснется, захватит Mutex заново и выйдет из Wait.
[01:02:46.000 --> 01:02:51.000]  То есть, когда мы выйдем из Wait, мы снова владеем Mutex. Мы снова в критической секции.
[01:02:51.000 --> 01:02:55.000]  Кондвар, это такое примитив синхронизации.
[01:03:03.000 --> 01:03:07.000]  Так мы его даже используем не то, что в пуле, а мы его в очереди используем.
[01:03:08.000 --> 01:03:12.000]  Вообще, кондвар – это довольно низкоуровневый примитив синхронизации.
[01:03:13.000 --> 01:03:16.000]  В смысле, в каком-то прикладном коде вы его не должны использовать.
[01:03:17.000 --> 01:03:20.000]  Как правило, кондвар появляется в реализации каких-то других примитивов синхронизации.
[01:03:21.000 --> 01:03:24.000]  В домашней работе вы напишете несколько таких штук.
[01:03:25.000 --> 01:03:33.000]  Вы напишете барьер для потоков. Вы напишете симафор.
[01:03:36.000 --> 01:03:40.000]  Вы напишете, ну, future напишете, вы с помощью кондвара или нет, я не знаю.
[01:03:41.000 --> 01:03:45.000]  Ну, в общем, с помощью кондвара можно разные вещи делать.
[01:03:45.000 --> 01:03:48.000]  Ну, вот в данном случае мы с помощью кондвара делаем очередь.
[01:03:49.000 --> 01:03:52.000]  Ну, а в свою очередь сам кондвар сделан, разумеется, через Mutex.
[01:03:53.000 --> 01:03:56.000]  И вы всю эту цепочку отследите, кажется, разберетесь в домашней работе.
[01:03:59.000 --> 01:04:02.000]  Кондвар и Mutex, они помогают друг другу. Вот здесь они работают в связке.
[01:04:03.000 --> 01:04:07.000]  Здесь нам одного Mutex мало. Нам нужно дожидаться в выполнении некоторого условия.
[01:04:08.000 --> 01:04:12.000]  Вот мы здесь отпускаем Mutex, встаем в очередь и делаем это атомарно. Это важно.
[01:04:12.000 --> 01:04:16.000]  Почему это важно? Потому что представьте себе, что мы проверили, что очередь пустая,
[01:04:17.000 --> 01:04:20.000]  буфер пуст, отпустили Mutex внутри вызова Wait.
[01:04:21.000 --> 01:04:25.000]  Пришел другой поток, сделал put целиком, взял освободившийся Mutex,
[01:04:26.000 --> 01:04:28.000]  положил элемент в очереди, сделал natify1.
[01:04:29.000 --> 01:04:31.000]  Natify1 никого не разбудил, потому что никто не спал еще.
[01:04:32.000 --> 01:04:36.000]  А потом управление вернулось вот этому потоку Teiko, и он наконец заснул на втором шаге.
[01:04:37.000 --> 01:04:38.000]  Вот такого быть не должно.
[01:04:38.000 --> 01:04:39.000]  Такого быть не должно.
[01:04:40.000 --> 01:04:43.000]  Wait и natify, они относительно друг другу должны быть атомарными.
[01:04:44.000 --> 01:04:47.000]  Не может быть так, что между шагами Wait выполнится natify.
[01:04:49.000 --> 01:04:51.000]  Ну, по крайней мере, между первыми двумя шагами.
[01:04:52.000 --> 01:04:53.000]  Как это реализовано, ну, вот вы увидите.
[01:04:54.000 --> 01:04:57.000]  Ладно, давайте, во-первых, переменную и переименуем.
[01:04:59.000 --> 01:05:02.000]  Вот условная переменная, она для того, чтобы дожидаться
[01:05:03.000 --> 01:05:04.000]  в выполнении некоторого предиката на разделяемых данных.
[01:05:05.000 --> 01:05:07.000]  В данном случае, что буфер не пуст.
[01:05:08.000 --> 01:05:11.000]  Ну, вот давайте мы так и назовем.
[01:05:13.000 --> 01:05:16.000]  Вот для кундвара всегда нужно давать разумные имена.
[01:05:17.000 --> 01:05:19.000]  Вот по тому условию, которое вы на них ждете.
[01:05:20.000 --> 01:05:22.000]  Потому что здесь нет слова task вообще нигде.
[01:05:23.000 --> 01:05:25.000]  У нас просто очередь для каких-то элементов.
[01:05:26.000 --> 01:05:28.000]  Ну, там hasValues, hasItems тоже подойдет.
[01:05:29.000 --> 01:05:31.000]  Вот тут получается not empty, wait.
[01:05:32.000 --> 01:05:35.000]  То есть я жду, пока очередь не станет не пустой.
[01:05:35.000 --> 01:05:37.000]  Вот такая реализация.
[01:05:38.000 --> 01:05:42.000]  Прежде чем запустить код, давайте я покажу вам картинку,
[01:05:43.000 --> 01:05:45.000]  которая, мне кажется, хорошо объясняет кундвары.
[01:05:46.000 --> 01:05:48.000]  Как это можно себе визуально представлять.
[01:05:49.000 --> 01:05:51.000]  Вот смотрите, ну, картинка тупая, но вот она дает хорошую модель,
[01:05:52.000 --> 01:05:53.000]  на самом деле, для понимания.
[01:05:54.000 --> 01:05:55.000]  Вот у вас есть разделяемые данные.
[01:05:56.000 --> 01:05:58.000]  И у вас есть mutex, который их защищает.
[01:05:59.000 --> 01:06:01.000]  Вот здесь данные – это вот очередь, буфер,
[01:06:01.000 --> 01:06:03.000]  а mutex – он в такой виде комнаты.
[01:06:04.000 --> 01:06:06.000]  И чтобы зайти в эту комнату, вы должны mutex захватить.
[01:06:07.000 --> 01:06:09.000]  То есть внутри этой комнаты находится только один поток.
[01:06:10.000 --> 01:06:12.000]  Вот он приходит и видит, что очередь пустая.
[01:06:13.000 --> 01:06:14.000]  Что ему делать?
[01:06:15.000 --> 01:06:17.000]  Он хочет заснуть, дождаться, пока очередь перестанет быть пустой.
[01:06:18.000 --> 01:06:20.000]  Для этого он говорит not empty, wait.
[01:06:21.000 --> 01:06:22.000]  Отпускает mutex.
[01:06:23.000 --> 01:06:25.000]  И как будто бы переходит в кладовку и сидит там.
[01:06:26.000 --> 01:06:27.000]  И вот в этой кладовке может быть много поток.
[01:06:28.000 --> 01:06:29.000]  И они все без mutex уже.
[01:06:29.000 --> 01:06:32.000]  То есть mutex освобождается и может зайти в другой поток,
[01:06:33.000 --> 01:06:37.000]  захватить mutex, положить элемент в буфер и сказать notify1.
[01:06:39.000 --> 01:06:42.000]  И тогда этот notify1 разбудит один из потоков, который идет в кладовке.
[01:06:44.000 --> 01:06:45.000]  И этот поток попытается выйти.
[01:06:46.000 --> 01:06:49.000]  Но чтобы ему зайти обратно, то есть выйти из wait,
[01:06:50.000 --> 01:06:53.000]  ему нужно снова захватить буфировку.
[01:06:55.000 --> 01:06:56.000]  Да?
[01:06:56.000 --> 01:06:58.000]  Если эта картинка понятна, то давайте запустим код
[01:06:59.000 --> 01:07:01.000]  и посмотрим, как он работает у нас.
[01:07:06.000 --> 01:07:08.000]  В смысле порядка пробуждения?
[01:07:09.000 --> 01:07:10.000]  Я думаю, что никаких.
[01:07:12.000 --> 01:07:16.000]  Ну вот, у нас есть стредпул, у нас есть более совершенная очередь.
[01:07:17.000 --> 01:07:19.000]  Можно запустить теперь пример.
[01:07:19.000 --> 01:07:20.000]  Он сломался.
[01:07:24.000 --> 01:07:25.000]  Но сломался по-другому.
[01:07:28.000 --> 01:07:29.000]  Он сломался на этом ассерте.
[01:07:32.000 --> 01:07:33.000]  А это был precondition для функции.
[01:07:34.000 --> 01:07:38.000]  То есть мы вызывали takeLogged, если мы были уверены, что он будет работать.
[01:07:39.000 --> 01:07:40.000]  И мы его не делали.
[01:07:41.000 --> 01:07:42.000]  И мы его не делали.
[01:07:43.000 --> 01:07:44.000]  И мы его не делали.
[01:07:45.000 --> 01:07:46.000]  И мы его не делали.
[01:07:46.000 --> 01:07:50.000]  То есть мы вызывали takeLogged, если мы были уверены, что очередь не пустая.
[01:07:51.000 --> 01:07:53.000]  А почему-то в нашем исполнении метод вызвался,
[01:07:54.000 --> 01:07:55.000]  но очередь пустая, буфер пустой.
[01:07:57.000 --> 01:07:59.000]  Это довольно странно, потому что если буфер был пустой,
[01:08:00.000 --> 01:08:01.000]  то мы зашли в wait и заблокировали до тех пор,
[01:08:02.000 --> 01:08:03.000]  пока нам не просигнали, что буфер не пустой.
[01:08:04.000 --> 01:08:05.000]  А, а давайте while делаем.
[01:08:06.000 --> 01:08:07.000]  Ну вот.
[01:08:09.000 --> 01:08:10.000]  Вот, так рассуждать нельзя.
[01:08:11.000 --> 01:08:13.000]  Так рассуждают люди, не слишком осведомленные в кунварах.
[01:08:13.000 --> 01:08:17.000]  Вот вы идете в документацию по кунвару и читаете, что, оказывается,
[01:08:18.000 --> 01:08:20.000]  оказывается, из wait вас могут вывести просто так.
[01:08:21.000 --> 01:08:22.000]  Вот просто, просто так.
[01:08:23.000 --> 01:08:24.000]  Это называется spurious wakeup.
[01:08:25.000 --> 01:08:29.000]  Вот вам не просигналили, никто не сделал на TI5.1, но вы проснулись.
[01:08:30.000 --> 01:08:33.000]  И вы такие, ну ладно, какой-то баг в реализации, нужно написать while.
[01:08:37.000 --> 01:08:39.000]  И вы пишете этот while, запускаете снова пример.
[01:08:39.000 --> 01:08:40.000]  И все работает.
[01:08:41.000 --> 01:08:42.000]  То есть вы починили.
[01:08:43.000 --> 01:08:44.000]  Но вы думаете, странно, ерунда какая-то, да?
[01:08:45.000 --> 01:08:47.000]  Почему вы не починили кунвар вместо этого?
[01:08:48.000 --> 01:08:50.000]  Так вот, кунвар чинить не нужно, потому что проблема на самом деле не в этом.
[01:08:51.000 --> 01:08:53.000]  И код упал у нас не потому что там spurious wakeup.
[01:08:54.000 --> 01:08:55.000]  Спулю свейкапов здесь не было.
[01:08:56.000 --> 01:08:57.000]  Вот почти наверняка не было.
[01:08:58.000 --> 01:08:59.000]  То есть, то, что почти не было в этом исполнении spurious wakeup.
[01:09:00.000 --> 01:09:01.000]  Проблема в другом.
[01:09:02.000 --> 01:09:05.000]  Вот такой код, который мы делали, он был в этом исполнении спулю свейкапов.
[01:09:05.000 --> 01:09:06.000]  Но он не был в этом исполнении спулю свейкапов.
[01:09:07.000 --> 01:09:08.000]  Проблема в другом.
[01:09:09.000 --> 01:09:10.000]  Вот такой код.
[01:09:11.000 --> 01:09:12.000]  В нем не спулю свейкапы, в нем race condition просто.
[01:09:13.000 --> 01:09:17.000]  То есть, можно запланировать ходы потоков так, что все развалится.
[01:09:18.000 --> 01:09:19.000]  Вот смотрите.
[01:09:20.000 --> 01:09:23.000]  Пришел поток в метод take, взял блокировку.
[01:09:24.000 --> 01:09:25.000]  Посмотрел на буфер.
[01:09:26.000 --> 01:09:27.000]  Буфер пустой.
[01:09:28.000 --> 01:09:29.000]  Ушел спать в wait.
[01:09:30.000 --> 01:09:31.000]  Mutex освободил.
[01:09:32.000 --> 01:09:33.000]  Пришел другой поток.
[01:09:33.000 --> 01:09:34.000]  Ушел Mutex освободившийся.
[01:09:35.000 --> 01:09:36.000]  Положил элемент в буфер.
[01:09:37.000 --> 01:09:38.000]  Просигналил.
[01:09:39.000 --> 01:09:40.000]  Первый поток.
[01:09:41.000 --> 01:09:42.000]  Этот сигнал получил.
[01:09:43.000 --> 01:09:44.000]  Сигнал в смысле не сигнал операционной системы, разумеется.
[01:09:45.000 --> 01:09:46.000]  Я так условно говорю.
[01:09:47.000 --> 01:09:48.000]  Уведомление, нотификацию.
[01:09:49.000 --> 01:09:50.000]  Mutex wake получил.
[01:09:51.000 --> 01:09:52.000]  Он проснулся.
[01:09:53.000 --> 01:09:56.000]  В смысле, он проснулся из ожидания внутри wait.
[01:09:57.000 --> 01:09:58.000]  Но из самого вызова wait он еще не вышел.
[01:09:59.000 --> 01:10:00.000]  Почему?
[01:10:01.000 --> 01:10:02.000]  Потому что Mutex нужно захватить.
[01:10:03.000 --> 01:10:04.000]  При выходе из wait нужно вернуть себе Mutex.
[01:10:05.000 --> 01:10:08.000]  А теперь представим себе, что появляется третий поток,
[01:10:09.000 --> 01:10:10.000]  который приходит в take.
[01:10:13.000 --> 01:10:15.000]  И вот смотрите на картинке.
[01:10:16.000 --> 01:10:17.000]  У вас теперь есть...
[01:10:18.000 --> 01:10:21.000]  У вас есть буфер, в нем есть один элемент.
[01:10:22.000 --> 01:10:23.000]  И есть два потока.
[01:10:24.000 --> 01:10:25.000]  Один приходит в take отсюда.
[01:10:26.000 --> 01:10:27.000]  Просто первый раз в него заходит.
[01:10:28.000 --> 01:10:30.000]  А другой выходит из кладовки.
[01:10:30.000 --> 01:10:33.000]  И вот они борются за общий Mutex.
[01:10:34.000 --> 01:10:35.000]  И кто его захватит первым, непонятно.
[01:10:36.000 --> 01:10:37.000]  Но если вы Mutex писали, то вы понимаете,
[01:10:38.000 --> 01:10:39.000]  что никаких гарантий нет, кто его первым захватит.
[01:10:40.000 --> 01:10:41.000]  Вот они конкурируют между собой.
[01:10:42.000 --> 01:10:46.000]  И если получится так, что первым возьмет блокировку поток из wait,
[01:10:47.000 --> 01:10:50.000]  то он видит в буфере элемент, возьмет его и завершится успешно.
[01:10:51.000 --> 01:10:54.000]  Но если выиграет другой поток, который просто заходит в take,
[01:10:55.000 --> 01:10:56.000]  то он зайдет в take.
[01:11:00.000 --> 01:11:01.000]  Он увидит, что в буфере есть один элемент,
[01:11:02.000 --> 01:11:03.000]  сразу его заберет и уйдет.
[01:11:04.000 --> 01:11:05.000]  А потом мы проснемся,
[01:11:06.000 --> 01:11:08.000]  ну, в смысле, а потом, наконец, мы в выходе из wait
[01:11:09.000 --> 01:11:10.000]  заберем себе блокировку обратно,
[01:11:11.000 --> 01:11:13.000]  выйдем из wait и увидим, что буфер снова пустой.
[01:11:16.000 --> 01:11:17.000]  Ну, мы этого не увидим, потому что...
[01:11:18.000 --> 01:11:19.000]  Да, мы этого не увидим и сломаемся просто.
[01:11:20.000 --> 01:11:21.000]  Ну, в смысле, увидим в ассерте.
[01:11:22.000 --> 01:11:23.000]  Что?
[01:11:25.000 --> 01:11:26.000]  В смысле, он решает проблему эту.
[01:11:26.000 --> 01:11:29.000]  Мы, если нас разбудили, мы должны снова перепроверить условия,
[01:11:30.000 --> 01:11:32.000]  потому что нас могли подрезать.
[01:11:33.000 --> 01:11:34.000]  Тут другой поток нас опередил.
[01:11:35.000 --> 01:11:37.000]  И никакого с пулю своей капы не было,
[01:11:38.000 --> 01:11:39.000]  никакой проблемы в кондварах не было.
[01:11:40.000 --> 01:11:41.000]  Тут проблема именно в race condition.
[01:11:42.000 --> 01:11:44.000]  Просто вот так упорядочились шаги потоков.
[01:11:47.000 --> 01:11:49.000]  Так что мы обязаны писать while, и поэтому, пожалуйста,
[01:11:50.000 --> 01:11:51.000]  пожалуйста, пожалуйста, раз и навсегда запомните,
[01:11:52.000 --> 01:11:54.000]  что кондвары нужно использовать с while
[01:11:54.000 --> 01:11:55.000]  и поймите, почему.
[01:11:56.000 --> 01:12:00.000]  Вот забегая сильно вперед, на зачете невозможно получить зачет,
[01:12:01.000 --> 01:12:02.000]  не понимая этого.
[01:12:03.000 --> 01:12:05.000]  Вот все, кому удается не получить зачет, не понимают этого.
[01:12:20.000 --> 01:12:21.000]  Ну, потому что как это...
[01:12:21.000 --> 01:12:22.000]  Mutex, он сам по себе.
[01:12:23.000 --> 01:12:24.000]  Сам Mutex не может этого гарантировать.
[01:12:26.000 --> 01:12:28.000]  Я предлагаю тебе написать решение задачи
[01:12:29.000 --> 01:12:31.000]  kundvar, slash kundvar, там, где нужно написать kundvar.
[01:12:32.000 --> 01:12:35.000]  И тогда ты ответишь себе на свой вопрос.
[01:12:36.000 --> 01:12:37.000]  Возможно, не стоит с этого начинать домашку,
[01:12:38.000 --> 01:12:39.000]  потому что как бы это...
[01:12:40.000 --> 01:12:42.000]  Ну, в общем, задача для того, чтобы разобраться,
[01:12:43.000 --> 01:12:44.000]  почему возникают с пулю свои капы,
[01:12:45.000 --> 01:12:46.000]  но почему может произойти что-то странное,
[01:12:47.000 --> 01:12:48.000]  и вот почему гарантии именно такие.
[01:12:49.000 --> 01:12:50.000]  Ты напишешь и поймешь.
[01:12:51.000 --> 01:12:52.000]  В смысле, зачем еще один Mutex?
[01:12:53.000 --> 01:12:54.000]  У нас состояние одно.
[01:12:55.000 --> 01:12:56.000]  Mutex должен быть общий, разумеется.
[01:12:57.000 --> 01:12:58.000]  Взаимное исключение.
[01:13:00.000 --> 01:13:01.000]  Да нет.
[01:13:02.000 --> 01:13:03.000]  Все...
[01:13:04.000 --> 01:13:05.000]  Кажется, здесь все...
[01:13:06.000 --> 01:13:07.000]  Все уместно. Так, стоп.
[01:13:08.000 --> 01:13:09.000]  Это...
[01:13:10.000 --> 01:13:11.000]  Ну черт возьми.
[01:13:17.000 --> 01:13:18.000]  Возвращаемся к второй пулу.
[01:13:18.000 --> 01:13:19.000]  Возвращаемся к второй пулу.
[01:13:24.000 --> 01:13:25.000]  Нет, я сейчас...
[01:13:26.000 --> 01:13:27.000]  Был момент на лекции, когда я говорил,
[01:13:28.000 --> 01:13:29.000]  что Race Condition это не то же самое,
[01:13:30.000 --> 01:13:31.000]  что DataRace, это вообще разные вещи,
[01:13:32.000 --> 01:13:33.000]  я говорил, что Race Condition это нарушение вариантов
[01:13:34.000 --> 01:13:35.000]  в нашем коде.
[01:13:36.000 --> 01:13:39.000]  Ну вот, поток пришел делать Popfront из пустого дека.
[01:13:40.000 --> 01:13:41.000]  И это происходит, потому что
[01:13:42.000 --> 01:13:44.000]  вот так сложилось планирование потоков.
[01:13:45.000 --> 01:13:47.000]  DataRace это ситуация, когда у вас есть
[01:13:48.000 --> 01:13:49.000]  ящика памяти, и вы с ней работаете
[01:13:50.000 --> 01:13:51.000]  без синхронизации из разных потоков,
[01:13:52.000 --> 01:13:53.000]  и в некоторых потоках вы пишете.
[01:13:54.000 --> 01:13:55.000]  Вот это Race Condition.
[01:13:56.000 --> 01:13:57.000]  А вот...
[01:13:58.000 --> 01:13:59.000]  Вот это, это DataRace.
[01:14:04.000 --> 01:14:05.000]  Одна ящика памяти, мы с ней работаем
[01:14:06.000 --> 01:14:07.000]  несинхронизированно.
[01:14:10.000 --> 01:14:11.000]  Здесь несинхронизированного доступа
[01:14:12.000 --> 01:14:13.000]  нет нигде.
[01:14:14.000 --> 01:14:15.000]  Здесь синхронизации все OK,
[01:14:16.000 --> 01:14:17.000]  здесь DataRace нет.
[01:14:18.000 --> 01:14:19.000]  Ну что ж, у нас осталось три минуты, да?
[01:14:22.000 --> 01:14:24.000]  Наверняка я забыл сказать, что это важное.
[01:14:26.000 --> 01:14:28.000]  Ну вот, давайте подведем итог,
[01:14:29.000 --> 01:14:30.000]  чему мы научились.
[01:14:32.000 --> 01:14:34.000]  Ну, наше локальное достижение.
[01:14:35.000 --> 01:14:36.000]  Мы поговорили...
[01:14:37.000 --> 01:14:38.000]  Мы на примере пулопотоков увидели
[01:14:39.000 --> 01:14:41.000]  некоторые новые сценарии синхронизации.
[01:14:42.000 --> 01:14:43.000]  Мы увидели, что мютоксов мало,
[01:14:44.000 --> 01:14:45.000]  ну, разумеется, их мало,
[01:14:46.000 --> 01:14:47.000]  и увидели, что возникают какие-то очереди,
[01:14:48.000 --> 01:14:49.000]  какие-то ожидания на каких-то предкатах.
[01:14:50.000 --> 01:14:51.000]  Ну и вот для этого у нас есть кондвары
[01:14:52.000 --> 01:14:53.000]  для того, чтобы
[01:14:54.000 --> 01:14:55.000]  решать больно общую задачу, дожидаться
[01:14:56.000 --> 01:14:57.000]  выполнений некоторого условия,
[01:14:58.000 --> 01:14:59.000]  дожидаться выполнений некоторого...
[01:15:00.000 --> 01:15:01.000]  дожидаться выполнения предката
[01:15:02.000 --> 01:15:03.000]  на разделимых данных.
[01:15:04.000 --> 01:15:05.000]  Для этого у нас вот есть кондвар.
[01:15:06.000 --> 01:15:07.000]  Ну, и надеюсь, чтобы вы увидели,
[01:15:08.000 --> 01:15:09.000]  как примерно с ним правильне
[01:15:10.000 --> 01:15:11.000]  обращаться.
[01:15:12.000 --> 01:15:13.000]  А второе более...
[01:15:14.000 --> 01:15:15.000]  Второе более важное наше достижение,
[01:15:16.000 --> 01:15:17.000]  более глобальное, мы увидели, что
[01:15:18.000 --> 01:15:25.040]  потоки, мы не собираемся в этом курсе запускать, вместо этого мы хотим использовать пул потоков, и вот пул потоков когда-нибудь
[01:15:25.640 --> 01:15:32.080]  на самом деле уже довольно скоро станет для нас таким вот универсальным планировщиком, в котором будут запускаться все те
[01:15:33.320 --> 01:15:39.520]  все те средства выражения конкурентности, которые мы в курсе изучаем. Файберы, карутины, фьючи,
[01:15:40.440 --> 01:15:43.240]  вот все будет исполняться там. Так что
[01:15:44.040 --> 01:15:51.120]  с одной стороны Домашка сейчас будет про то, чтобы разобраться, как там на низком уровне все это синхронизируется и работает, а
[01:15:51.440 --> 01:15:57.320]  дальше мы перейдем к пулу потоков как такому базовому инфраструктурному компоненту для всего нашего курса.
[01:15:58.040 --> 01:16:03.120]  Вот пожалуйста, отслеживайте такие вот глобальные сюжетные линии. Спасибо большое, на сегодня это все.
