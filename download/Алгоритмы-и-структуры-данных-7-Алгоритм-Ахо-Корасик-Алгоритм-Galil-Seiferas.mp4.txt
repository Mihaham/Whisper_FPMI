[00:00.000 --> 00:06.880]  Какую задачу мы сейчас будем решать?
[00:06.880 --> 00:11.160]  Ну, будем решать поискать в тексте t много подстрок
[00:11.160 --> 00:12.160]  сразу.
[00:12.160 --> 00:13.160]  То есть не одну.
[00:13.160 --> 00:17.560]  Ну, простая нот, но какая-нибудь простая версия, могла бы
[00:17.560 --> 00:20.040]  работать, конечно, за сумму длин строк, плюс текст
[00:20.040 --> 00:22.600]  умножить на их количество, соответственно.
[00:22.600 --> 00:25.320]  Ну, просто условно говоря, для каждой из них найдем
[00:25.880 --> 00:28.360]  префикс функции, или z, чего угодно.
[00:28.360 --> 00:35.360]  Но, на самом деле, нот, прежде чем запускать какого-то
[00:35.360 --> 00:39.400]  полномасштабного ахакарасика, нужно, конечно, сделать пару
[00:39.400 --> 00:40.400]  оговорочек.
[00:40.400 --> 00:41.400]  Каких?
[00:41.400 --> 00:44.560]  Ну, первое, например, предположим, что все строки у нас имеют
[00:44.560 --> 00:45.560]  одинаковую длину.
[00:45.560 --> 00:47.320]  Вот совершенно случайно.
[00:47.320 --> 00:54.200]  Тогда у нас есть неожиданный лайфхак.
[00:54.200 --> 00:58.120]  Лайфхак называется, давайте посчитаем, ну, разные методы
[00:58.120 --> 00:59.120]  могут быть.
[00:59.120 --> 01:02.760]  Ну, например, можно предподсчитать хэши всех подстрок длины
[01:02.760 --> 01:06.160]  и лен и сложить их в какой-нибудь там мульти-сет.
[01:06.160 --> 01:10.720]  И тогда для каждой подстроки мы лезем в мульти-сет, проверяем,
[01:10.720 --> 01:12.800]  есть ли такие хэши, если да, то где.
[01:12.800 --> 01:18.000]  Ну, в принципе, логарифом можно даже убить, если мульти-сет
[01:18.000 --> 01:19.800]  вы замерите на анортерет-сет.
[01:19.800 --> 01:22.720]  Ну, тупо от него отказываться, если мы все равно понятия
[01:22.720 --> 01:24.160]  хэши используем.
[01:24.160 --> 01:27.360]  Ну, пока здесь все просто.
[01:27.360 --> 01:34.560]  Пока у нас получается, что у нас получается, ОАТ,
[01:34.560 --> 01:38.160]  плюс СЛОГТ, плюс размер ответа, хотя, нет, это неправда.
[01:38.160 --> 01:43.560]  Почему неправда, потому что, наверное, все-таки хэши
[01:43.560 --> 01:45.320]  мы кладем в мульти-сет, все-таки за логариф.
[01:45.320 --> 01:50.120]  Ну, не суть, суть, в общем-то, одна.
[01:50.120 --> 01:52.560]  Да, но если использовать хэш-таблицу, то как бы можно
[01:52.560 --> 01:55.120]  вообще прям идеально за линию все делать, это прям вот
[01:55.120 --> 01:56.120]  оптимально.
[01:56.120 --> 01:58.960]  Но возникает маленькая проблема, строки бывают,
[01:58.960 --> 02:00.440]  к сожалению, разной длины.
[02:00.440 --> 02:04.560]  Что в этом случае делать?
[02:04.560 --> 02:10.840]  Ну, тут тоже, на самом деле, возникает такой неожиданный,
[02:10.840 --> 02:17.000]  но такой классический момент, что часто, когда нам дают
[02:17.000 --> 02:19.560]  как много строчек, выясняется, что их суммарная длина,
[02:19.560 --> 02:21.160]  наверное, не очень большая какая-то.
[02:21.560 --> 02:24.560]  Ну, как-то классика бывает, там нам дают 10 в пятый строчек,
[02:24.560 --> 02:27.160]  суммарная длина не происходит, там 3 на 10 в пятый, например,
[02:27.160 --> 02:29.160]  или там 2 на 10 в пятый.
[02:29.160 --> 02:30.160]  Вот.
[02:30.160 --> 02:33.160]  Но тут тогда выясняется следующее, оказывается,
[02:33.160 --> 02:35.660]  что среди этих строчек принципиально различных длин, в общем-то,
[02:35.660 --> 02:36.660]  не сильно много.
[02:36.660 --> 02:40.560]  А именно, вот, например, можно так вот написать, не более
[02:40.560 --> 02:44.160]  чем корень их суммарной длины умножить на 2.
[02:44.160 --> 02:47.160]  И это оценка я еще не точно написал, это я так для красоты.
[02:48.160 --> 02:52.160]  На самом деле можно даже более точную оценку написать,
[02:52.160 --> 02:54.160]  это двойку занести под корень.
[02:55.160 --> 02:57.160]  Да, корень из двух длин, да.
[02:57.160 --> 02:58.160]  Вот.
[02:58.160 --> 03:01.160]  Ну, доказательства, так, ну, по-моему, вот, что-то подобное
[03:01.160 --> 03:03.160]  мы уже даже обсуждали когда-то, да.
[03:03.160 --> 03:05.160]  Ну, то есть доказательства базируются на том, что если
[03:05.160 --> 03:09.160]  у нас, например, там L различных длин, то тогда, то есть,
[03:09.160 --> 03:12.160]  строчки включаются строчки хотя бы L различных длин,
[03:12.160 --> 03:15.160]  то есть суммарная длина как минимум 1 плюс 2 плюс и так далее плюс L.
[03:16.160 --> 03:17.160]  Вот.
[03:17.160 --> 03:19.160]  Это не превосходит вот суммарной длины, ну, а сумма
[03:19.160 --> 03:22.160]  этой получается L на L плюс 1 пополам, следовательно, L меньше
[03:22.160 --> 03:25.160]  чем корень из двух суммарных длин, ну, тут, в общем, все
[03:25.160 --> 03:27.160]  понятно, думаю, расписывать не надо, да.
[03:27.160 --> 03:28.160]  Вот.
[03:28.160 --> 03:30.160]  Тут все понятно.
[03:30.160 --> 03:31.160]  Вот.
[03:31.160 --> 03:37.160]  И в результате может получиться уже не самая плохая симпатика.
[03:37.160 --> 03:42.160]  То есть, идея такая, давайте что-нибудь разделим.
[03:43.160 --> 03:46.160]  То есть, давайте вот просто тупо возьмем и разделим
[03:46.160 --> 03:50.160]  действительно у нас, соответственно, строки на...
[03:50.160 --> 03:54.160]  А, все, можно о хакарасике дальше не рассказывать, да?
[03:54.160 --> 03:56.160]  Нет, можно другое теперь рассказывать.
[03:56.160 --> 03:58.160]  Да, все так, убираем это все безобразие.
[03:58.160 --> 04:00.160]  Но поздно, уже начали, да.
[04:01.160 --> 04:02.160]  Ладно.
[04:02.160 --> 04:04.160]  Как говорится, надо же разомнуться на чем-то, почему
[04:04.160 --> 04:05.160]  мне на хакарасике, да.
[04:05.160 --> 04:06.160]  Ну, вот.
[04:06.160 --> 04:08.160]  Но, действительно, тут идея, что получается, уже без
[04:08.160 --> 04:12.160]  хакарасика можно получить асимптотику вида там n корень
[04:12.160 --> 04:13.160]  из n.
[04:13.160 --> 04:14.160]  Ну, что-то в этом роде.
[04:14.160 --> 04:17.160]  То есть, суммарная длина всех строчек на корень из
[04:17.160 --> 04:18.160]  суммарной длины там всех s.
[04:18.160 --> 04:20.160]  Уже, в принципе, неплохо.
[04:20.160 --> 04:21.160]  Вот.
[04:21.160 --> 04:23.160]  В чем более того, можно обратить внимание.
[04:23.160 --> 04:25.160]  Тут мы пишем как корень, но с другой стороны, там,
[04:25.160 --> 04:28.160]  знаете, вот, например, бывают еще там всякие задачи,
[04:28.160 --> 04:31.160]  что нужно там просят описать вроде хакарасика, но говорят,
[04:31.160 --> 04:33.160]  что длины всех этих строчек не превосходят, например,
[04:33.160 --> 04:34.160]  80.
[04:34.160 --> 04:37.160]  И тогда, в принципе, это означает, что вы можете
[04:37.160 --> 04:41.160]  решать задачу за 80 на, соответственно, суммарную длину.
[04:41.160 --> 04:43.160]  И это, в общем-то, тоже неплохо.
[04:43.160 --> 04:44.160]  Вот.
[04:44.160 --> 04:48.160]  То есть, иногда совсем сложных алгоритмов писать не надо.
[04:48.160 --> 04:50.160]  Вот это вот там.
[04:50.160 --> 04:51.160]  Да.
[04:51.160 --> 04:54.160]  Ну, конечно, да, у нас будут алгоритмы и посложнее.
[04:54.160 --> 04:58.160]  Но нет, ну, как бы, традиционно почему-то хакарасик считается
[04:58.160 --> 04:59.160]  сложным алгоритмом.
[04:59.160 --> 05:02.160]  Хотя, с другой стороны, давайте проведем эксперимент.
[05:02.160 --> 05:05.160]  Да, тут, конечно, уже не самая репрезентативная выборка,
[05:05.160 --> 05:06.160]  но все-таки.
[05:06.160 --> 05:08.160]  Ну-ка, кто когда-нибудь писал хакарасик?
[05:13.160 --> 05:14.160]  Вот.
[05:14.160 --> 05:15.160]  Ну, вот проблема, да.
[05:17.160 --> 05:20.160]  Нет, ну, тут парадокс, потому что, по логике, хакарасик
[05:20.160 --> 05:22.160]  должен быть до суфмассива даже.
[05:23.160 --> 05:24.160]  Ну вот.
[05:24.160 --> 05:27.160]  В идеале вроде да, потому что вроде повышаем уровень.
[05:27.160 --> 05:30.160]  То есть, одну подстроку в одной строке, много подстрок статическим
[05:30.160 --> 05:33.160]  образом в одной строке или много подстрок в одной строке,
[05:33.160 --> 05:34.160]  но в онлайне.
[05:34.160 --> 05:35.160]  Да?
[05:35.160 --> 05:37.160]  То есть, казалось бы, вот все постепенно так должно расти.
[05:37.160 --> 05:40.160]  Но просто традиционно оказывается, но просто практически оказывается,
[05:40.160 --> 05:43.160]  что алгоритм хакарасик оказывается сложнее для понимания,
[05:43.160 --> 05:46.160]  чем даже алгоритм поиска суфмассива, а Zn log n, который...
[05:46.160 --> 05:47.160]  Вот.
[05:47.160 --> 05:49.160]  А кто суфмассив Zn log n когда-нибудь писал?
[05:49.160 --> 05:50.160]  Вот.
[05:50.160 --> 05:52.160]  Да, в два раза больше людей.
[05:52.160 --> 05:53.160]  Да.
[05:53.160 --> 05:54.160]  Вот, да.
[05:54.160 --> 05:55.160]  Ну, вот, логично.
[05:55.160 --> 05:56.160]  Да.
[05:56.160 --> 05:57.160]  В чем дело?
[05:57.160 --> 05:58.160]  Там, оказывается, просто.
[05:58.160 --> 06:00.160]  А если еще вспомнить, что там кто-то прям так и рассказывает,
[06:00.160 --> 06:02.160]  как его строить, то давайте это Zn log квадрат.
[06:02.160 --> 06:03.160]  Хешами и бинпоискам.
[06:03.160 --> 06:06.160]  Просто вот STD-сорт забабахаем, и вот.
[06:06.160 --> 06:10.160]  Тоже, в принципе, варианты, если ограничения позволяют, конечно.
[06:10.160 --> 06:11.160]  Вот.
[06:11.160 --> 06:13.160]  Но, правда, удачи попихать.
[06:13.160 --> 06:14.160]  Вот.
[06:14.160 --> 06:15.160]  Поэтому, да.
[06:15.160 --> 06:18.160]  Поэтому часто алгоритм хакарасик даже опускают.
[06:18.160 --> 06:20.160]  Ну, там много чего так опускают.
[06:20.160 --> 06:21.160]  Вот.
[06:21.160 --> 06:24.160]  И в результате получается, что там куки хорошего не знаем.
[06:24.160 --> 06:25.160]  Ну, вот.
[06:25.160 --> 06:27.160]  Но мы его пропускать не будем.
[06:27.160 --> 06:30.160]  То есть у нас, конечно, все-таки цель, какая у нас цель?
[06:30.160 --> 06:34.160]  Найти все вхождения всех под строчек S в текст T.
[06:34.160 --> 06:35.160]  За асимптотику какую?
[06:35.160 --> 06:39.160]  Суммарная длина всех строчек S плюс длина строки T
[06:39.160 --> 06:41.160]  плюс суммарный размер ответа.
[06:43.160 --> 06:44.160]  Вот.
[06:44.160 --> 06:45.160]  Почему это важно?
[06:45.160 --> 06:47.160]  Ну, потому что, как мы помним, да, что, может быть,
[06:47.160 --> 06:50.160]  каждая строчка входит в текст T там от T раз.
[06:50.160 --> 06:53.160]  Нам же не суммарный размер ответа, видимо.
[06:53.160 --> 06:55.160]  Ну, в плане количества, а не суммарный.
[06:55.160 --> 06:56.160]  Нет.
[06:56.160 --> 06:59.160]  Ну, в нашей постановке задачи мы хотим найти все вхождения.
[07:00.160 --> 07:01.160]  Да.
[07:01.160 --> 07:02.160]  То есть у нас будет такая.
[07:02.160 --> 07:04.160]  Поэтому без суммарного размера ответа не получится.
[07:04.160 --> 07:05.160]  Да.
[07:05.160 --> 07:07.160]  Понятно, имеется в виду, что каждое вхождение мы будем
[07:07.160 --> 07:10.160]  кодировать, конечно, информации в духе, там, какая строчка,
[07:10.160 --> 07:12.160]  где начинается ее вхождение, естественно.
[07:12.160 --> 07:13.160]  Да, вот, единицы.
[07:13.160 --> 07:14.160]  Да.
[07:14.160 --> 07:15.160]  Вот.
[07:15.160 --> 07:17.160]  То есть, конечно же, там могут быть более какие-то
[07:17.160 --> 07:19.160]  постановки задачи, что для каждой строчки посчитаем,
[07:19.160 --> 07:22.160]  входит ли она вообще просто, да или нет, сколько раз
[07:22.160 --> 07:25.160]  она входит, где там находится ее там 57-й вхождение,
[07:25.160 --> 07:27.160]  или что-нибудь еще в этом роде.
[07:27.160 --> 07:28.160]  Вот.
[07:28.160 --> 07:31.160]  Нет, 57-й вхождение, это, конечно, сложнее будет.
[07:31.160 --> 07:32.160]  Вот.
[07:32.160 --> 07:33.160]  Но не суть.
[07:33.160 --> 07:34.160]  Итак.
[07:34.160 --> 07:37.160]  Значит, ну, соответственно, чтобы это делать, то есть
[07:37.160 --> 07:40.160]  там уже, конечно, не требуется размер ответа, то есть
[07:40.160 --> 07:42.160]  тогда уже будет там честная линия.
[07:42.160 --> 07:43.160]  Итак.
[07:43.160 --> 07:44.160]  Но как же это делать?
[07:44.160 --> 07:46.160]  Ну, для этого нам нужен борт.
[07:46.160 --> 07:47.160]  То есть там нужна структура данных.
[07:47.160 --> 07:50.160]  То есть это такая структура данных, которая позволяет
[07:50.160 --> 07:52.160]  вам добавлять строку в множество, удалить строку
[07:52.160 --> 07:55.160]  из множества и проверить, присутствует ли строка
[07:55.160 --> 07:56.160]  С в множестве.
[07:56.160 --> 07:58.160]  Что вы понимаете под чистой линией?
[07:58.160 --> 08:01.160]  У вас же размер ответа никогда не превышает суммарную
[08:01.160 --> 08:02.160]  длину С.
[08:02.160 --> 08:03.160]  Нет.
[08:03.160 --> 08:04.160]  Я имел в виду, что если постановка задачи требует
[08:04.160 --> 08:06.160]  просто для каждой строки сказать, сколько раз она
[08:06.160 --> 08:09.160]  входит в текст Т, то как бы уже размер ответа у вас
[08:09.160 --> 08:10.160]  адекватный.
[08:10.160 --> 08:14.160]  То есть тебе не требуется прям все вхождение выписывать,
[08:14.160 --> 08:15.160]  а надо только сказать…
[08:15.160 --> 08:18.160]  Нет, если выписывать индексы, то это все еще уже суммарная
[08:18.160 --> 08:19.160]  длина.
[08:19.160 --> 08:20.160]  Умножить на Т.
[08:20.160 --> 08:21.160]  Почему?
[08:21.160 --> 08:22.160]  Только у тебя Т – это все буквы А.
[08:22.160 --> 08:23.160]  И что?
[08:23.160 --> 08:25.160]  А каждая С – это одна.
[08:25.160 --> 08:28.160]  Это входит в суммарную длину строк.
[08:28.160 --> 08:29.160]  Нет.
[08:29.160 --> 08:34.160]  В плане, у нас с каждого символа строка Т может начинаться
[08:34.160 --> 08:35.160]  ровно одним способом.
[08:35.160 --> 08:40.160]  Либо входить с него, либо не входить с него.
[08:40.160 --> 08:41.160]  Ну и что?
[08:41.160 --> 08:42.160]  Значит ответ не больше, чем суммарную длину.
[08:42.160 --> 08:45.160]  Нет, это означает, что каждая строка входит в текст
[08:45.160 --> 08:48.160]  Т не более, чем модуль Т раз.
[08:48.160 --> 08:52.160]  Но проблема в том, что строчек у тебя больше, чем одна.
[08:52.160 --> 08:53.160]  Так, сейчас.
[08:53.160 --> 08:54.160]  Вы много строк ищем?
[08:54.160 --> 08:55.160]  Много строк ищем в одной?
[08:55.160 --> 08:56.160]  Да.
[08:56.160 --> 08:58.160]  А, я говорю про одно строк ищем в одной.
[08:58.160 --> 09:00.160]  О, так, вот просыпаемся.
[09:00.160 --> 09:03.160]  Мы уже решали эту задачу в прошлый раз.
[09:03.160 --> 09:04.160]  Это другая задача.
[09:04.160 --> 09:08.160]  У нас много строчек, мы вон Бор даже вводим зачем-то.
[09:08.160 --> 09:11.160]  А именно потому, что мы ищем много строчек.
[09:11.160 --> 09:12.160]  Вот.
[09:12.160 --> 09:14.160]  Итак, ну что ж такое Бор?
[09:14.160 --> 09:16.160]  Ну да, редкий случай, когда тут это…
[09:16.160 --> 09:18.160]  Можно ввести формальное определение, но как-то
[09:18.160 --> 09:19.160]  очень не хочется.
[09:19.160 --> 09:20.160]  Не вот.
[09:20.160 --> 09:23.160]  Ну, тем более, что, собственно, я думаю, как мы уже выясняли,
[09:23.160 --> 09:25.160]  там многие из вас так знают, что это.
[09:25.160 --> 09:26.160]  Ну, то есть формальное…
[09:26.160 --> 09:28.160]  То есть, можно сказать, что это такое подвешенное дерево.
[09:28.160 --> 09:30.160]  На каждом ребре написана буква.
[09:30.160 --> 09:33.160]  Там на ребрах и сходящих из вершины все буквы парно различные.
[09:33.160 --> 09:35.160]  Ну, то есть, можно сказать, что это такой автомат, но
[09:35.160 --> 09:36.160]  древесного типа.
[09:36.160 --> 09:37.160]  Вот.
[09:37.160 --> 09:39.160]  Ну, вот, что уж тут.
[09:39.160 --> 09:41.160]  Как говорится, вместо тысячи слов.
[09:41.160 --> 09:45.160]  В общем-то, я думаю, эта картинка как раз дает полное
[09:45.160 --> 09:46.160]  понимание.
[09:46.160 --> 09:47.160]  Вот.
[09:47.160 --> 09:48.160]  Ну, дальше там…
[09:48.160 --> 09:49.160]  Ну, понятно.
[09:49.160 --> 09:50.160]  Можно делать там такое.
[09:50.160 --> 09:53.160]  То есть, в каждой вершине еще можно насчитывать,
[09:53.160 --> 09:57.160]  сколько слов начинается с такого префекса, например.
[09:57.160 --> 09:59.160]  Искать какую-нибудь там катую.
[09:59.160 --> 10:01.160]  Можно еще там искать катую или в психографическом
[10:01.160 --> 10:04.160]  порядке строчку и так далее и тому подобное.
[10:04.160 --> 10:07.160]  Ну, и здесь вот и прочая классика такого рода.
[10:07.160 --> 10:08.160]  Вот.
[10:08.160 --> 10:11.160]  Ну, здесь, конечно, да, нужно говорить, конечно, два…
[10:11.160 --> 10:12.160]  Чего?
[10:12.160 --> 10:13.160]  Мапы.
[10:13.160 --> 10:15.160]  А что не так?
[10:15.160 --> 10:18.160]  Ну, я люблю писать с мапом.
[10:18.160 --> 10:20.160]  Ну, это-то, да, конечно, да.
[10:20.160 --> 10:21.160]  А что?
[10:21.160 --> 10:22.160]  Вот.
[10:22.160 --> 10:25.160]  Нет, ну, в принципе, логично.
[10:25.160 --> 10:27.160]  На самом деле, если алфавит большой, то на самом деле…
[10:27.160 --> 10:30.160]  То есть, если алфавит хотя бы 26, то у вас там Бор может
[10:30.160 --> 10:32.160]  вызвать там проблемы с памяти.
[10:32.160 --> 10:35.160]  Нет, алфавит больше, чем 26.
[10:35.160 --> 10:36.160]  Сколько может?
[10:36.160 --> 10:37.160]  Ну, 50.
[10:37.160 --> 10:38.160]  Ну, бывает 52.
[10:38.160 --> 10:39.160]  Бывает там…
[10:39.160 --> 10:40.160]  Ну, бывает на сотку.
[10:40.160 --> 10:41.160]  Там все что угодно.
[10:41.160 --> 10:42.160]  Ну, по-разному бывает.
[10:42.160 --> 10:45.160]  То есть, там как бы всякое такое.
[10:45.160 --> 10:47.160]  Просто проблема в том, что, да, то есть, у вас там по
[10:47.160 --> 10:50.160]  памяти это будет 26 на суммарную длину строчек.
[10:50.160 --> 10:53.160]  Иногда, если у вас суммарная длина строчек все-таки там
[10:53.160 --> 10:55.160]  пара миллионов, то там с памятью могут быть проблемы.
[10:55.160 --> 10:58.160]  Ну, найти задачу, в которой суммарная длина строчек,
[10:58.160 --> 11:02.160]  миллион и алфавит длины 100 – это все-таки задача,
[11:02.160 --> 11:04.160]  где нужно прямо… Ну, типа это специальная задача
[11:04.160 --> 11:05.160]  на упих.
[11:05.160 --> 11:06.160]  Ну, бывает.
[11:06.160 --> 11:07.160]  Ну, вся…
[11:07.160 --> 11:08.160]  Ну, всегда бывает.
[11:08.160 --> 11:09.160]  Как показывает практика прошлого четверть финала,
[11:09.160 --> 11:11.160]  задачу на упих по памяти вам подсунуть могут.
[11:11.160 --> 11:14.160]  То есть, как выясняется, да, оказывается, алгоритм
[11:14.160 --> 11:15.160]  Хишберга нужен.
[11:15.160 --> 11:16.160]  Оказывается.
[11:16.160 --> 11:20.160]  Ну, да, ну вот, да.
[11:20.160 --> 11:22.160]  Ну, ну, что делать?
[11:22.160 --> 11:27.160]  Да, кто-то может, конечно, вызапить от этого, но в
[11:27.160 --> 11:30.160]  конце концов, да, если вы случайно прогуляли соответствующую
[11:30.160 --> 11:32.160]  лекцию на первом курсе, то это ваши проблемы.
[11:32.160 --> 11:34.160]  Ну, вот, ну, или там соответственно.
[11:34.160 --> 11:36.160]  Ну, тем более, что, в общем, это не тот алгоритм, который
[11:36.160 --> 11:38.160]  прям вообще нигде никто никогда не рассказывает
[11:38.160 --> 11:39.160]  и не упоминает.
[11:39.160 --> 11:40.160]  Все-таки да.
[11:40.160 --> 11:41.160]  Так вот.
[11:41.160 --> 11:44.160]  Ну, в нашем случае, значит, да, то есть, по памяти
[11:44.160 --> 11:45.160]  по-разному бывает.
[11:45.160 --> 11:48.160]  То есть, и, конечно, чаще всего, чаще, конечно, используют
[11:48.160 --> 11:49.160]  действительно массив детей.
[11:49.160 --> 11:52.160]  Ну, там вёрток-звёздочка или там, может быть, если
[11:52.160 --> 11:55.160]  вы храните все вершины в массиве, то там инты можно
[11:55.160 --> 11:56.160]  писать.
[11:56.160 --> 11:57.160]  Вот.
[11:57.160 --> 12:00.160]  Но если вы хотите, чтоб память у вас была не O от M умножить
[12:00.160 --> 12:03.160]  на размер алфавита, а именно O от N, то вас приветствует
[12:03.160 --> 12:04.160]  мапчик.
[12:04.160 --> 12:05.160]  Вот.
[12:05.160 --> 12:06.160]  Вот.
[12:06.160 --> 12:11.160]  Ну, при желании там, если не хотите, чтоб был алгоритм
[12:11.160 --> 12:13.160]  размер алфавита, то, конечно, можно и хэш-мапчик.
[12:13.160 --> 12:16.160]  Но, по-моему, в данном случае, по-моему, ни по времени,
[12:16.160 --> 12:18.160]  ни по памяти он, скорее всего, вам погоды не сделает.
[12:18.160 --> 12:19.160]  Ну вот.
[12:19.160 --> 12:22.160]  По памяти это не будет алгоритм размер алфавита?
[12:22.160 --> 12:23.160]  По памяти...
[12:23.160 --> 12:24.160]  Как это у него?
[12:24.160 --> 12:25.160]  Киганск.
[12:25.160 --> 12:26.160]  Когда он маленького...
[12:26.160 --> 12:27.160]  Кого?
[12:27.160 --> 12:32.160]  Он говорит, МАП типа работает одинаково по времени почти.
[12:32.160 --> 12:35.160]  Ну, нет, ну, на мелких, думаю, скорее, да.
[12:35.160 --> 12:36.160]  На мелких мапчика?
[12:36.160 --> 12:37.160]  На крупных?
[12:37.160 --> 12:38.160]  Ну, на крупных, ну, там, да.
[12:38.160 --> 12:39.160]  Ну ладно.
[12:39.160 --> 12:41.160]  На мелких не знаю, но на крупных, типа, ну, там, может,
[12:41.160 --> 12:42.160]  два раза разница.
[12:42.160 --> 12:43.160]  Ну...
[12:43.160 --> 12:45.160]  Нет, ну, иногда бывает.
[12:45.160 --> 12:46.160]  Ну, формально.
[12:46.160 --> 12:47.160]  Ну, формально говорим.
[12:47.160 --> 12:48.160]  Но тут говорим так.
[12:48.160 --> 12:51.160]  На самом деле, мы здесь не хотим использовать unordered
[12:51.160 --> 12:53.160]  map по одной простой причине.
[12:53.160 --> 12:56.160]  Мы ставим себе целью решить нашу задачу без всяких
[12:56.160 --> 12:58.160]  этих хэшей и предположений, что у нас там есть какие-то
[12:58.160 --> 12:59.160]  коллизии.
[12:59.160 --> 13:00.160]  Вот.
[13:00.160 --> 13:01.160]  Или там, вероятности.
[13:01.160 --> 13:02.160]  Ну, там.
[13:02.160 --> 13:03.160]  Ну, как всегда, коллизии у нас как.
[13:03.160 --> 13:06.160]  Либо мы верим, что коллизии нет, а если есть, то, ну
[13:06.160 --> 13:08.160]  ладно, в этом маловероятном случае мы скажем, что ладно,
[13:08.160 --> 13:09.160]  нам не повезло.
[13:09.160 --> 13:10.160]  А можно строить хэш-мапу.
[13:10.160 --> 13:13.160]  Там, типа, unordered-мапа таким образом, чтобы, там, если
[13:13.160 --> 13:15.160]  есть коллизия, значит, перестраиваем хэш-мапу.
[13:15.160 --> 13:16.160]  Вот.
[13:16.160 --> 13:17.160]  Ну, в принципе, так можно.
[13:17.160 --> 13:18.160]  Ну, вот.
[13:18.160 --> 13:19.160]  То есть, ну, просто разные подходы.
[13:19.160 --> 13:20.160]  Ну, вот.
[13:20.160 --> 13:21.160]  Ну, они...
[13:21.160 --> 13:22.160]  Ну, тогда там просто...
[13:22.160 --> 13:24.160]  Тогда проблема в том, что он теоретически может
[13:24.160 --> 13:25.160]  по времени долго работать.
[13:25.160 --> 13:26.160]  Да.
[13:26.160 --> 13:27.160]  Ну, это уже другой вопрос.
[13:27.160 --> 13:28.160]  Да, там.
[13:28.160 --> 13:29.160]  Ну, проблема в том, что...
[13:29.160 --> 13:32.160]  Даже не столько проблема, что он там дольше, не дольше,
[13:32.160 --> 13:35.160]  а проблема еще в том, что он может долго работать,
[13:35.160 --> 13:37.160]  потому что вам не повезло.
[13:37.160 --> 13:38.160]  Вот.
[13:38.160 --> 13:41.160]  Ну, понятно, что вероятность, конечно, там крайне мала
[13:41.160 --> 13:42.160]  и все такое, но...
[13:42.160 --> 13:45.160]  Ну, если мы хотим перестраивать, если есть хотя бы одна коллизия,
[13:45.160 --> 13:48.160]  типа, нам нужен квадрат от размера ввода,
[13:48.160 --> 13:50.160]  и у нас столько времени будет.
[13:52.160 --> 13:53.160]  Ну, возможно.
[13:53.160 --> 13:54.160]  Ну, пожалуй, да.
[13:54.160 --> 13:55.160]  Вот.
[13:55.160 --> 13:56.160]  Да.
[13:56.160 --> 13:58.160]  Ну, мы в любом случае хотим таких хэшей избегать,
[13:58.160 --> 14:00.160]  хотим все надежно, поэтому пишем мап.
[14:00.160 --> 14:01.160]  Вот.
[14:01.160 --> 14:04.160]  Ну, мап, конечно, будет проблема, что у вас все операции
[14:04.160 --> 14:06.160]  с каждой строкой будут работать не за отдлинные строки,
[14:06.160 --> 14:10.160]  а отдлинные строки на логарифам алфавита,
[14:10.160 --> 14:14.160]  но логарифам 26 обычно не проблема.
[14:14.160 --> 14:16.160]  Но, правда, если алфавит у вас большой,
[14:16.160 --> 14:19.160]  потому что, знаете, вот, до первых парадоксис,
[14:19.160 --> 14:22.160]  с одной стороны, все наслышаны, что суффиксный массив строится
[14:22.160 --> 14:24.160]  за линию теоретически, да?
[14:24.160 --> 14:26.160]  Более того, есть много алгоритмов, которые строят.
[14:26.160 --> 14:29.160]  Ну, он же за линию алфавита либо за логарифом.
[14:29.160 --> 14:30.160]  Ну, вот.
[14:30.160 --> 14:32.160]  Ну, на самом деле, да.
[14:32.160 --> 14:33.160]  Ну, хотя...
[14:33.160 --> 14:35.160]  Ну, не совсем так.
[14:35.160 --> 14:36.160]  Ну, хотя...
[14:36.160 --> 14:38.160]  А, ну, вот.
[14:38.160 --> 14:41.160]  Нет, он не за n алфавит.
[14:41.160 --> 14:44.160]  Не, ну, как это наш алгоритм, он честно n логан,
[14:44.160 --> 14:46.160]  который мы будем изучать.
[14:46.160 --> 14:49.160]  Но, на самом деле, там есть алгоритмы, которые будут честно строить за o от n,
[14:49.160 --> 14:55.160]  но только с оговоркой, что все элементы алфавита – это числа от 1 до n.
[14:55.160 --> 14:57.160]  Ну, или от 0 до n-1.
[14:57.160 --> 14:59.160]  Вот.
[14:59.160 --> 15:03.160]  Потому что, да, если нам в качестве алфавита подсовывают камешки
[15:03.160 --> 15:05.160]  со сравнениями, то быстрее, чем за n логан,
[15:05.160 --> 15:08.160]  вы не можете построить суффиксный массив принципиально.
[15:08.160 --> 15:09.160]  Ну, вот.
[15:09.160 --> 15:11.160]  Потому что в противном случае, если вы можете
[15:11.160 --> 15:13.160]  принципиально быстрее построить, тогда у вас появляется
[15:13.160 --> 15:15.160]  suffix array sort.
[15:15.160 --> 15:17.160]  То есть как бы, да.
[15:17.160 --> 15:19.160]  То есть как отсортировать n камешков?
[15:19.160 --> 15:21.160]  Правильно. Давайте построим суффиксный массив.
[15:21.160 --> 15:23.160]  Вот вам сортировка. Ура. Да.
[15:23.160 --> 15:25.160]  Вот.
[15:25.160 --> 15:26.160]  Вот.
[15:26.160 --> 15:28.160]  Поэтому тут, конечно, важно иметь в виду
[15:28.160 --> 15:30.160]  такого рода оговорки.
[15:30.160 --> 15:31.160]  Вот.
[15:31.160 --> 15:33.160]  Так что вот, то есть, на самом деле,
[15:33.160 --> 15:35.160]  по-разному, дальше как всегда.
[15:35.160 --> 15:37.160]  Тут trade-off именно пожертвовать чуть-чуть временем
[15:37.160 --> 15:39.160]  или пожертвовать чуть-чуть памятью.
[15:39.160 --> 15:41.160]  Ну, все зависит, конечно, от размера алфавита.
[15:41.160 --> 15:43.160]  Потому что там бывают задачи, в которых алфавит – 26,
[15:43.160 --> 15:45.160]  бывают задачи, в которых алфавит – 10,
[15:45.160 --> 15:47.160]  бывают задачи, в которых алфавит – 2.
[15:47.160 --> 15:50.160]  То есть там при двух, ну, уж понятно, что мапчик бессмысленен.
[15:50.160 --> 15:51.160]  Да.
[15:51.160 --> 15:53.160]  Так что тут, ну, как бы в конце концов,
[15:53.160 --> 15:55.160]  ну, потому что задачи на какие-нибудь строчки
[15:55.160 --> 15:57.160]  из 0 и 1 – это святое дело обычно.
[15:57.160 --> 15:59.160]  Вот.
[15:59.160 --> 16:01.160]  Значит, мы, тем не менее, будем считать
[16:01.160 --> 16:03.160]  размер алфавита константной,
[16:03.160 --> 16:05.160]  поэтому, как бы, нод,
[16:05.160 --> 16:07.160]  поэтому, как бы, эта техническая деталь нас парить не будет.
[16:07.160 --> 16:09.160]  Вот.
[16:09.160 --> 16:11.160]  Итак.
[16:11.160 --> 16:13.160]  Ну, давайте смотреть, что мы,
[16:13.160 --> 16:15.160]  что у нас будет в боре.
[16:15.160 --> 16:17.160]  Ну, давайте нод.
[16:17.160 --> 16:19.160]  Ну, то есть, чаще всего, конечно, прям столько не надо,
[16:19.160 --> 16:21.160]  но давайте вот, например, писать.
[16:21.160 --> 16:23.160]  Что у нас будет? У нас будут дети.
[16:23.160 --> 16:25.160]  В виде так и быть мапчика.
[16:25.160 --> 16:27.160]  У нас будет родитель.
[16:27.160 --> 16:29.160]  Что у нас еще будет? У нас еще будет
[16:29.160 --> 16:31.160]  буковка, по которой мы из родителя пришли к нам.
[16:33.160 --> 16:35.160]  Значит, будет еще там, скажем,
[16:35.160 --> 16:37.160]  пометочка,
[16:37.160 --> 16:39.160]  а не конец ли это строки,
[16:39.160 --> 16:41.160]  ну, и заодно, если это конец строки,
[16:41.160 --> 16:43.160]  то мы еще и будем хранить
[16:43.160 --> 16:45.160]  какой.
[16:45.160 --> 16:47.160]  Ну, будем предполагать, что их нет.
[16:47.160 --> 16:49.160]  Да.
[16:49.160 --> 16:51.160]  Ну, как-то туповато предполагать, что они есть.
[16:51.160 --> 16:53.160]  Ну, вот.
[16:53.160 --> 16:55.160]  Но, в принципе, этот вопрос, как бы, можно и
[16:55.160 --> 16:57.160]  порешать.
[16:57.160 --> 16:59.160]  Потому что когда вы строите борт, вы можете
[16:59.160 --> 17:01.160]  неожиданно выяснить, что у вас строчек,
[17:01.160 --> 17:03.160]  что у вас есть несколько одинаковых строчек.
[17:03.160 --> 17:05.160]  Ну, вот. Ну, а на самом деле, когда встретите
[17:05.160 --> 17:07.160]  второй одинаковый, так и говорите так. Значит,
[17:07.160 --> 17:09.160]  у нее ответ такой, как у того
[17:09.160 --> 17:11.160]  товарища. Все.
[17:11.160 --> 17:13.160]  Ну, да.
[17:13.160 --> 17:15.160]  Ну, какая-то просто копипасти в ответ с того товарища
[17:15.160 --> 17:17.160]  в любом случае.
[17:19.160 --> 17:21.160]  Ну, вот. Так что, как бы, да.
[17:21.160 --> 17:23.160]  Ну, или как угодно решать, но это, в общем,
[17:23.160 --> 17:25.160]  такой технический момент, который мы тоже будем
[17:25.160 --> 17:27.160]  опускать. Вот.
[17:27.160 --> 17:29.160]  То есть, да, формально нам отбоя, конечно, могут
[17:29.160 --> 17:31.160]  задать вопрос, что, как бы, если Вася задумал 10
[17:31.160 --> 17:33.160]  чисел, то некоторые из них могут быть и одинаковые,
[17:33.160 --> 17:35.160]  да. Но
[17:35.160 --> 17:37.160]  не здесь мы будем заниматься.
[17:37.160 --> 17:39.160]  Вот. Так.
[17:39.160 --> 17:41.160]  Еще важное понятие, которое мы введем,
[17:41.160 --> 17:43.160]  это, конечно, путевая метка.
[17:43.160 --> 17:45.160]  Pest от V. То есть, что это такое?
[17:45.160 --> 17:47.160]  Это строчка, по которой мы можем дойти
[17:47.160 --> 17:49.160]  из корня до вершины V.
[17:49.160 --> 17:51.160]  Ну, вроде, естественная.
[17:51.160 --> 17:53.160]  Но скорее от корня до этой вершины.
[17:53.160 --> 17:55.160]  А я что сказал?
[17:55.160 --> 17:57.160]  Там написано, наоборот просто.
[17:57.160 --> 17:59.160]  Ой-ой-ой.
[17:59.160 --> 18:01.160]  Ой-ой-ой.
[18:01.160 --> 18:03.160]  Каш.
[18:19.160 --> 18:21.160]  Да. Тогда, ну,
[18:21.160 --> 18:23.160]  тогда уже формально притеряться.
[18:23.160 --> 18:25.160]  Тогда и тут, наверное, Pest не ее предка, и ее родитель.
[18:27.160 --> 18:29.160]  Ой-ой-ой.
[18:29.160 --> 18:35.160]  Кошмар, за столько лет багу никто не нашел, ничего себе.
[18:35.160 --> 18:38.160]  Ну, видимо, да.
[18:38.160 --> 18:40.160]  Ну, все-таки.
[18:40.160 --> 18:42.160]  Ну, вы же вот нашли.
[18:42.160 --> 18:44.160]  Так понятно.
[18:44.160 --> 18:49.160]  Итак, что же мы будем делать?
[18:49.160 --> 18:52.160]  Ну, как это ни странно, мы говорим, так, у нас есть префикс-функция,
[18:52.160 --> 18:54.160]  так давайте ее обобщим.
[18:54.160 --> 18:58.160]  То есть, по большому счету, мы сейчас просто возьмем алгоритм кнута Мориса Пратта
[18:58.160 --> 19:03.160]  в той версии, когда мы префикс-функцию построили только для строки P,
[19:03.160 --> 19:06.160]  а потом строку S только по ней ходили, условно,
[19:06.160 --> 19:09.160]  и будем ее обобщать.
[19:09.160 --> 19:13.160]  Так, это сейчас понятно, о чем я говорю?
[19:13.160 --> 19:17.160]  То есть, версия тут такая.
[19:17.160 --> 19:22.160]  Мы берем строку P, брали строку P, построили для нее префикс-функцию,
[19:22.160 --> 19:26.160]  а потом идем по этой префикс-функции текстом T.
[19:26.160 --> 19:28.160]  Ну, или в нашем случае текстом S.
[19:28.160 --> 19:31.160]  То есть, просто в каждый момент времени мы проходим очередной символ
[19:31.160 --> 19:34.160]  и как бы знаем максимальную длину строчки заканчивающей в этом символе
[19:34.160 --> 19:37.160]  совпадающую с префиксом строки P.
[19:37.160 --> 19:40.160]  То есть, там, ну, запоминать мы ее не будем, потому что нам просто в онлайне
[19:40.160 --> 19:44.160]  надо понимать, что если это совпало с длиной P, значит, ура, вхождение нашли.
[19:44.160 --> 19:47.160]  Если нет, то нет.
[19:47.160 --> 19:50.160]  То есть, в принципе, вот так можно искать под строку в строке,
[19:50.160 --> 19:55.160]  и вот ровно этот подход мы попробуем обобщить.
[19:55.160 --> 19:58.160]  Как мы его обобщим?
[19:58.160 --> 20:00.160]  А практически так же.
[20:00.160 --> 20:05.160]  То есть, вместо одного шаблона P у нас есть куча строчек S-итых,
[20:05.160 --> 20:10.160]  мы их будем хранить в боре.
[20:10.160 --> 20:11.160]  Вот.
[20:11.160 --> 20:14.160]  И нам будет интересно ровно то же самое.
[20:14.160 --> 20:16.160]  Мы хотим пройтись по тексту T.
[20:16.160 --> 20:18.160]  Вот у нас какая идея будет.
[20:18.160 --> 20:21.160]  Мы хотим пройтись по тексту T.
[20:21.160 --> 20:24.160]  И в каждый момент времени мы хотим пройти очередной символ
[20:24.160 --> 20:27.160]  и найти максимальные длины под строку текста T,
[20:27.160 --> 20:30.160]  который заканчивается в этой позиции
[20:30.160 --> 20:35.160]  и который является префиксом хоть кого-нибудь из этого бора.
[20:39.160 --> 20:43.160]  То есть, или что то же самое является префиксом хоть кого-нибудь в боре,
[20:43.160 --> 20:47.160]  или что то же самое, чтобы эта строчка была представлена в боре,
[20:47.160 --> 20:49.160]  то есть в какой-то вершины.
[20:49.160 --> 20:51.160]  Понятно, да?
[20:51.160 --> 20:53.160]  То есть, короче, мы для строки T,
[20:53.160 --> 20:56.160]  если мы сейчас находимся в символе I,
[20:56.160 --> 21:03.160]  мы поддерживаем максимальный суффикс до символа I,
[21:03.160 --> 21:05.160]  под какого-то.
[21:05.160 --> 21:11.160]  Такой, что он является префиксом какой-то строки.
[21:11.160 --> 21:12.160]  Ну да.
[21:12.160 --> 21:13.160]  Я бы даже сказал так,
[21:13.160 --> 21:15.160]  что мы находим такую вершину V,
[21:15.160 --> 21:17.160]  можно сказать V и T.
[21:17.160 --> 21:18.160]  Такая что?
[21:18.160 --> 21:20.160]  Значит, pass от V и T,
[21:20.160 --> 21:23.160]  то есть pass от V и T это строка,
[21:23.160 --> 21:27.160]  которая совпадает с подстрокой соответствующей длины,
[21:27.160 --> 21:30.160]  которая заканчивается в этом символе строки T.
[21:30.160 --> 21:34.160]  Нам тогда еще надо хранить какую-нибудь ДВшку,
[21:34.160 --> 21:38.160]  видя сколько из наших суффиксных ссылок
[21:38.160 --> 21:42.160]  является окончанием хотя бы одной из строки.
[21:42.160 --> 21:45.160]  Для этого надо ввести саму суффиксную ссылку.
[21:45.160 --> 21:47.160]  Я пока, потому что я еще не все сказал,
[21:47.160 --> 21:48.160]  потому что первая идея такая,
[21:48.160 --> 21:51.160]  то есть мы хотим делать точно такой же проход.
[21:51.160 --> 21:53.160]  Вот.
[21:53.160 --> 21:55.160]  Мы ищем строки S1 и так далее,
[21:55.160 --> 21:57.160]  S, N, T, в строке T.
[21:57.160 --> 21:58.160]  Да.
[21:58.160 --> 22:01.160]  Мы для каждой строки хотим выписать все ее вхождения.
[22:01.160 --> 22:03.160]  Короче, запомнить, как работает,
[22:03.160 --> 22:06.160]  так красить легче, чем запомнить, что он делает.
[22:08.160 --> 22:11.160]  По-моему, ты сказал сейчас одно и то же.
[22:11.160 --> 22:13.160]  Как работает алгоритм,
[22:13.160 --> 22:16.160]  понять легче, запомнить чем.
[22:16.160 --> 22:20.160]  Вхождение что во что он еще.
[22:20.160 --> 22:22.160]  Ну да.
[22:22.160 --> 22:24.160]  Остался кое-что, как использовать их карасик,
[22:24.160 --> 22:26.160]  если ты не знаешь, что он делает.
[22:26.160 --> 22:29.160]  Я не очень понимаю, как можно использовать алгоритм,
[22:29.160 --> 22:30.160]  не зная, что он делает.
[22:30.160 --> 22:33.160]  Нет, ну в плане, вот если ты вспоминаешь про аккарасик,
[22:33.160 --> 22:35.160]  ты помнишь, что он исчез в хождение чего-то во что-то.
[22:35.160 --> 22:36.160]  Ага.
[22:36.160 --> 22:38.160]  А если не думать себе направленно,
[22:38.160 --> 22:40.160]  то не можешь вспомнить.
[22:41.160 --> 22:43.160]  Ну понятно.
[22:43.160 --> 22:45.160]  Так вот.
[22:45.160 --> 22:49.160]  Мы говорили, мечту мы себе описали.
[22:49.160 --> 22:51.160]  Ищем максимальную подстроку,
[22:51.160 --> 22:54.160]  которая заканчивается в этом символе,
[22:54.160 --> 22:56.160]  является префиксом кого-то из эссок.
[22:56.160 --> 23:00.160]  Ищем, причем храним это в виде соответствующей вершины бора.
[23:00.160 --> 23:05.160]  И мечтаем, чтобы у нас удалось сделать такого рода проход.
[23:05.160 --> 23:07.160]  Но как нам это сделать?
[23:07.160 --> 23:09.160]  Давайте вспоминать.
[23:09.160 --> 23:12.160]  Откуда берется понятие суффиксной ссылки?
[23:12.160 --> 23:17.160]  Берется оно, можно сказать, вот откуда.
[23:17.160 --> 23:19.160]  Потому что давайте вспомним, как мы это делали,
[23:19.160 --> 23:22.160]  когда у нас была префикс-функция.
[23:22.160 --> 23:26.160]  То есть у нас была идея такая,
[23:26.160 --> 23:29.160]  что вот у нас был текст t, вот у нас было p.
[23:29.160 --> 23:32.160]  Вот мы дошли до этого символа и нашли вот эту подстрочку,
[23:32.160 --> 23:34.160]  которая является префиксом.
[23:34.160 --> 23:38.160]  Теперь нам для и плюс первого символа надо найти такую строчку.
[23:38.160 --> 23:40.160]  Что мы делали?
[23:40.160 --> 23:43.160]  Мы перебирали все, даже начиная с максимальной,
[23:43.160 --> 23:46.160]  все подстроки заканчиваем в этой позиции
[23:46.160 --> 23:48.160]  и тут совпадающие с префиксами.
[23:48.160 --> 23:50.160]  И нам было жутко интересно.
[23:50.160 --> 23:53.160]  То есть перебирали в порядке убывания,
[23:53.160 --> 23:57.160]  искали ту из них, за которой
[23:57.160 --> 24:00.160]  следующий символ совпадает с и плюс первым.
[24:00.160 --> 24:02.160]  Помните было дело, да?
[24:02.160 --> 24:05.160]  Или мы как-то по-другому это делали?
[24:09.160 --> 24:11.160]  Есть кто живой?
[24:15.160 --> 24:17.160]  Так, подъем, ребят.
[24:21.160 --> 24:23.160]  Так, ну кто-то из вас был?
[24:26.160 --> 24:28.160]  Понятно, так, Гриш.
[24:30.160 --> 24:32.160]  Так, вот давайте вспоминать.
[24:38.160 --> 24:40.160]  И вы делали как-то иначе?
[24:40.160 --> 24:42.160]  Нет, мы доказывали двумя указателями,
[24:42.160 --> 24:44.160]  что это работает за лигию.
[24:44.160 --> 24:46.160]  Потому что оказывалось, что по большому счету
[24:46.160 --> 24:48.160]  у нас вот тут это левый указатель так двигается,
[24:48.160 --> 24:50.160]  а тут правый.
[24:50.160 --> 24:52.160]  Но это надо было для доказательства того,
[24:52.160 --> 24:54.160]  что это работает за лигию.
[24:54.160 --> 24:56.160]  Но идейно мы делали следующее.
[24:56.160 --> 24:58.160]  Что такое подстрока заканчивающейся в и плюс первом символе
[24:58.160 --> 25:00.160]  и совпадающая с префиксом?
[25:00.160 --> 25:03.160]  Это подстрока заканчивающейся в этой позиции
[25:03.160 --> 25:05.160]  и совпадающейся с префиксом,
[25:05.160 --> 25:16.640]  префикса идёт символ x. Логично, да? Логично, да. Вот. И ноты. То есть мы
[25:16.640 --> 25:21.440]  их перебирали. Как мы их перебирали? А ровно для этого мы насчитали префикс
[25:21.440 --> 25:27.000]  функцию. Что такое префикс функция? Префикс функция нот говорит там, что
[25:27.000 --> 25:33.640]  для каждого префикса мы находим максимальный суффикс,
[25:33.680 --> 25:38.600]  собственный, который совпадает с префиксом. То есть заметим, что он зависит в этой
[25:38.600 --> 25:45.400]  строке только от самой строки P, от текста T он не зависит от слова никак. Вот. И тогда
[25:45.400 --> 25:49.960]  получалось, что мы его скаканули и получилось. То есть мы там, то есть идея была
[25:49.960 --> 25:53.400]  такая, что достаточно для каждого префикса просто вот эту вот префикс функцию, то
[25:53.400 --> 25:57.360]  есть следующий в списке хранить. Потому что, если он нам не подойдет, мы возьмём
[25:57.360 --> 26:00.960]  префикс функцию от префикс функции, потом префиксу заберём и так далее. То есть вот это
[26:00.960 --> 26:06.760]  пи от пи от пи, вот это вот. Вот. То есть так мы их будем перебирать и, соответственно,
[26:06.760 --> 26:11.720]  но пока, когда мы выясним, что после очередной у нас там есть символ х, значит
[26:11.720 --> 26:17.680]  это оно и есть. Вот. Ровно такой подход мы сейчас применим, когда у нас много
[26:17.680 --> 26:25.280]  строчек. Разница будет только в том, что, конечно, у нас теперь уже P, у нас
[26:25.280 --> 26:35.520]  нет одной строки P, а у нас есть целый BOR. Вот. Вот. А тексты тот же. То есть вот у нас есть
[26:35.520 --> 26:44.680]  какая-то, допустим, строка. Вот. И ей соответствует вот эта вершина. Опа. А.
[26:44.680 --> 26:52.800]  Чё, думаешь, так лучше, да? Ну, хорошо. Ну, хорошо, хорошо. Ну, валали. Потому что есть то, что там
[26:52.800 --> 27:08.240]  камера на ночное видение настроена. Вот. Вот. Хорошо. Значит, смотрите. Что у нас сейчас тут будет? Сейчас у нас тут будет красота. Вот. То есть мы говорим, то есть как нам выяснить,
[27:08.240 --> 27:13.520]  что подходит ли прям, то есть вот эта строка. Ну, то есть что такое, действительно, под строка и плюс один,
[27:13.520 --> 27:18.840]  которая представлена в BOR-е. Эта подстрока заканчивается в этом символе и представлена в BOR-е, причём из
[27:18.920 --> 27:29.520]  этой вершины BOR-а можно пройти по символу X. Логично, да? Поэтому проверяем, можно ли из этой вершины пойти по символу X. Ну, там, если выяснилось, что случайно да,
[27:29.520 --> 27:42.320]  ну, значит, поздравляю. Вот сюда мы переходим и радуемся жизни. Да? Если нет, значит, нам нужно перебрать. Что? Да. Значит, нам нужно перебрать подстроки заканчиваться в этой позиции в порядке убывания,
[27:42.320 --> 27:54.240]  которые представлены в BOR-е. И из каждой из них, и перебирать их пока не найдём очередную, из которой можно перейти по символу X. Но для этого, для каждой такой вершины надо хранить вот этот переход.
[27:54.240 --> 28:07.520]  То есть где находится следующая по длине строка, то есть типа суффикс этой, какое у нас следующее по длине суффикс этой строки, который представлен в BOR-е? Именно это мы назовём суффиксной ссылкой.
[28:07.520 --> 28:21.920]  Просто вот. То есть просто вот, прям вот в явном виде определения. Вот так и пишем, что суффиксная ссылка, это указатель на такую вершину BOR-а U, что P-satu это собственный суффикс, помните, то есть не совпадающий с самой строкой V, да?
[28:21.920 --> 28:23.920]  Который не меняет ориентацию пространства.
[28:23.920 --> 28:25.920]  Чего?
[28:27.920 --> 28:33.920]  Какая ориентация? Какое пространство? Нет, давайте, собственный суффикс, собственный вектор, это разные вещи, да?
[28:34.320 --> 28:48.320]  Нет, собственный вектор, это другая, это третья вещь. Это которая, который не меняет управление вектором. Действие на которого нашему оператора является растяжением.
[28:48.320 --> 28:52.320]  О господи. Кошмар. Действие оператора является...
[28:52.720 --> 28:58.720]  Ну, то есть, короче, тот, у которой, если мы возьмём A, умножить на этот вектор...
[28:58.720 --> 29:04.720]  Ну, понятно. Так, ладно, давайте математику из соседнего предмета сюда привлекать не будем без необходимости, да?
[29:04.720 --> 29:12.720]  Если очень хочется линала, можем когда-нибудь в конце обсудить что-нибудь типа галса. Ну, там, я не знаю, но пока в этом необходимости нет.
[29:12.720 --> 29:14.720]  Что-то просим пиксмена, слушай.
[29:14.720 --> 29:16.720]  Ой-ой-ой, я тоже.
[29:17.120 --> 29:19.120]  Вот.
[29:19.120 --> 29:25.120]  И так, значит, у нас тут всё просто. То есть, собственный, в нашем случае собственный суффикс, это суффикс, не совпадающий с самой строкой.
[29:25.120 --> 29:33.120]  Вот. Ну и понятно, что из этих собственных суффиксов мы находим максимально. То есть, это корректно определено для всех некорневых вершин. Почему?
[29:33.120 --> 29:37.120]  Потому что пустая строка и соответствующий ей корень точно подходит.
[29:39.120 --> 29:45.120]  Вот. Так, ну, говорим, соответственно, прописываю, что для корня суффиксная ссылка, увы, не определена.
[29:45.520 --> 29:47.520]  Вот.
[29:47.520 --> 29:59.520]  И тогда оказывается, что такого рода проход, то есть, находить для каждой подстроки такую вершину, теперь мы можем теми же, абсолютно теми же самыми двумя указателями за о от единиц.
[30:01.520 --> 30:05.520]  Ну, если суффиксная ссылка откуда-то была прислана к нам с небес по факсу, естественно.
[30:05.520 --> 30:07.520]  Вот просто.
[30:07.920 --> 30:11.920]  Ну, по какому? По длине как?
[30:17.920 --> 30:21.920]  Ну, можно поглубнее, лишь тот же самый, да, по длине самой подстроки, да.
[30:23.920 --> 30:25.920]  Что? Ну, получается...
[30:27.920 --> 30:35.920]  Ну, да, можно мыслить, что, да, каждый конкретный шаг амортизированный от единицы, а можно просто сказать, что это два указателя, поэтому суммарно проход будет за о от т.
[30:37.920 --> 30:41.920]  Ну, вот, да, то есть, да, можно насчитать, и это будет автоматах Карасик.
[30:43.920 --> 30:47.920]  Да, вот, да, где-то там в презентации такое словосочетание тоже прозвучит.
[30:47.920 --> 30:49.920]  Значит, хорошо.
[30:51.920 --> 30:53.920]  Ну, вот. Ну, вот, ну, как всегда.
[30:53.920 --> 30:59.920]  Значит, как вы уж сказали, да, как, во-первых, да, как всегда, как эти суффиксные ссылки вычитают, зачем они нам нужны?
[30:59.920 --> 31:01.920]  Ну, мы поняли, зачем они нам примерно нужны, да.
[31:02.320 --> 31:10.320]  Более того, то есть мы поняли, что мы можем проделать такой проход, но сам по себе проход нам как бы еще не поможет, потому что теперь возникает вопрос.
[31:10.320 --> 31:12.320]  Как находить все вхождения?
[31:14.320 --> 31:16.320]  Хочется, конечно, вот как вы делали это в преферс-функции?
[31:16.320 --> 31:22.320]  Мы говорили, что если у нас вот эта подстрока совпала со всей строкой P, значит, поздравляю, мы нашли вхождения.
[31:22.320 --> 31:24.320]  А если нет, то нет.
[31:26.320 --> 31:28.320]  Сейчас же мы имеем нод.
[31:28.720 --> 31:37.720]  Сейчас, конечно, тоже хочется сказать, что если вот в вершине, в которую мы пришли, имеет место, то есть это конец какой-то строки, значит, ура, мы нашли вхождение, записываем.
[31:39.720 --> 31:41.720]  Но есть одна маленькая подлянка.
[31:43.720 --> 31:57.720]  То есть мало того, во-первых, мало того, что как бы может так случиться, что вот есть вот это, у нас в списке есть еще строки, которые являются суффиксами этой строки, да, и мы их в этом месте всех тогда должны как-то учесть, правда?
[31:58.720 --> 32:06.720]  Так еще и может быть подлянка, что сама эта строка не является строкой из нашего списка, а ее суффиксы являются.
[32:08.720 --> 32:16.720]  То есть, например, там может оказаться там какое-нибудь слово sister и рядом где-то слово ist.
[32:17.120 --> 32:31.120]  Тогда если у нас окажется, что вот у нас здесь тут какое-нибудь слово там, допустим, sister, то мы говорим, так, sister, значит, такого, так, такого слова у нас нет, значит, продолжаем дальше, а зря, потому что слова sister нет, а слово ist есть.
[32:33.120 --> 32:35.120]  И мы его должны как-то учесть.
[32:37.120 --> 32:39.120]  Вот возникает вопрос, как его учесть?
[32:39.520 --> 32:47.520]  Так, ну как бы в идеале, то есть учесть можно следующим образом.
[32:48.520 --> 33:02.520]  Каждый раз, когда мы находимся в вершине i, давайте из этой вершины пробежимся по суффиксным ссылкам до корня, пробежимся просто тупо по суффиксным ссылкам до корня, и все вершины, которые помечены как конец, мы, значит, идентифицируем как вхождение.
[33:03.520 --> 33:05.520]  То есть это нам как минимум даст правильный ответ, правда?
[33:05.920 --> 33:09.920]  Но маленькая проблема, амортизация вылетает в трубу, правда?
[33:12.920 --> 33:14.920]  Что же делать?
[33:15.920 --> 33:17.920]  Вот, значит, что же делать?
[33:18.920 --> 33:26.920]  Но идея, да, но идея на самом деле такая, тут чуть позже тоже будет, мы введем такое понятие, как длинные суффиксные ссылки.
[33:27.320 --> 33:39.320]  То есть предположим, что у нас суффиксные ссылки есть, тогда для каждой вершины мы можем предпочитать, что я хочу из этой вершины идти по суффиксным ссылкам до тех пор, пока не наткнусь на какое-то вхождение строки.
[33:40.320 --> 33:42.320]  А, ну если у нас нужно не количество всех вхождений, то да.
[33:43.320 --> 33:45.320]  Да, то есть если мы хотим все вхождения, то вот можно так сделать.
[33:46.320 --> 33:47.320]  Понятно, да?
[33:48.320 --> 33:51.320]  Ну мы основную задачу это решаем, это будет называться длинные суффиксные ссылки.
[33:52.320 --> 33:55.320]  То есть если есть суффиксные ссылки, вы такое можете заранее предпочитать легко, правда?
[33:57.320 --> 33:59.320]  Или даже ленивость сделать, если там.
[34:00.320 --> 34:01.320]  СНМ какой-то.
[34:01.320 --> 34:02.320]  Чего?
[34:02.320 --> 34:03.320]  СНМ какой-то.
[34:04.320 --> 34:05.320]  Почему СНМ, причем тут?
[34:06.320 --> 34:07.320]  Ну мы типа так, сжимаем.
[34:08.320 --> 34:09.320]  Как, куда? Нет.
[34:10.320 --> 34:14.320]  А, ну СНМ в смысле сжатия, а, эвристика сжатия путей, ну да.
[34:16.320 --> 34:17.320]  Да, да, да.
[34:18.320 --> 34:19.320]  Хорошо, да, да.
[34:20.320 --> 34:25.320]  С сжатия путей можно получить даже алгоритм, когда мы с тобой приблигаемся, только там нож не находит.
[34:25.720 --> 34:26.720]  Ну там...
[34:26.720 --> 34:27.720]  Чего?
[34:28.720 --> 34:33.720]  Ну потому что очевидно нам интересно только самое низкое вхождение с переходом по каждой букве.
[34:34.720 --> 34:39.720]  Соответственно до следующего вхождения, а, даже не до множества алгорита, плюс алгорита.
[34:40.720 --> 34:47.720]  Ну короче нам имеет смысл хранить во-первых терминальные вершины в суффиксилтах, а во-вторых те, из которых есть переход по символову, по которому ниже перехода нет.
[34:48.720 --> 34:52.720]  Соответственно суммарно таких вершин это количество терминальных плюс размер алгорита.
[34:53.120 --> 34:55.120]  Сейчас, чего, чего, чего, чего?
[34:56.120 --> 34:57.120]  Ммм, чего, сейчас.
[34:58.120 --> 35:03.120]  Ну то есть еще раз, если у нас есть вот путь по суффиксилкам, какие вершины нам вообще интересны?
[35:04.120 --> 35:06.120]  Первый тип вершин это где кончаются слова.
[35:07.120 --> 35:13.120]  Второй тип вершин это из которых появился переход по какому-то символу, по которому ниже перехода не было.
[35:14.120 --> 35:15.120]  А, нет, ну это по-моему это...
[35:16.120 --> 35:18.120]  Нет, ну упради, автомат это уже другой немножко.
[35:19.120 --> 35:21.120]  Вершин второго типа размер алгорита.
[35:21.520 --> 35:22.520]  Нет, ну...
[35:23.520 --> 35:30.520]  Нет, ну по-моему второе сжатие правильно, что ты просто хочешь для каждой вершины говорить, где мы окажемся, если мы находимся в этой вершине следующий символ Х.
[35:31.520 --> 35:35.520]  Нет, я хочу сжать все вершины, которые не являются вершинами этих двух типов.
[35:36.520 --> 35:38.520]  Ну сжать, в смысле, в дереве суффиксных ссылок.
[35:39.520 --> 35:41.520]  Ну да, и после этого просто переходить в такую.
[35:42.520 --> 35:45.520]  А, ну можно и так, конечно, но тогда уже легче автомат просто построить.
[35:46.520 --> 35:47.520]  Это правда.
[35:47.520 --> 35:49.520]  Особенно, потому что если он концент алфаит, то лучше автомат построить.
[35:51.520 --> 35:53.520]  Ну да, не, ну сжатие путей да, ну тут просто да.
[35:54.520 --> 35:56.520]  Вот, ну тут не сжатие путей, тут как бы просто...
[35:57.520 --> 35:58.520]  Тут что-то более конкретное.
[35:59.520 --> 36:00.520]  Вот, значит, что у нас тут еще?
[36:01.520 --> 36:03.520]  Значит, с длинными, ну вот, с длинными разобрались.
[36:06.520 --> 36:12.520]  Вот, то есть получается, то есть тогда получается заметим, что если суффиксные ссылки у нас откуда-то вообще уже взялись,
[36:13.520 --> 36:15.520]  то тогда мы делаем вот этот проход за ОАТ,
[36:15.920 --> 36:23.920]  и при этом в каждой позиции еще скачем под длинным суффиксным ссылком и обновляем ответ за О от единицы плюс сколько там реально обхождения было.
[36:24.920 --> 36:25.920]  Понятно, да?
[36:26.920 --> 36:29.920]  То есть в принципе вот у нас уже есть вроде даже не сильно сложный алгоритм,
[36:30.920 --> 36:32.920]  но который просто требует, чтобы мы еще откуда-то,
[36:33.920 --> 36:38.920]  то есть откуда-то еще, конечно, нашли сами суффиксные ссылки.
[36:39.920 --> 36:41.920]  Так, тут, конечно, текст немножко другой.
[36:42.320 --> 36:46.320]  А, ну да, потому что мы тут немножко вперед идем относить на презентации,
[36:47.320 --> 36:49.320]  потому что тут имеется в виду, собственно, вот этот вот проход.
[36:50.320 --> 36:51.320]  Видно, да?
[36:52.320 --> 36:57.320]  Так, то есть это проход по тексту Т и суффиксным ссылкам, которые мы с вами обсуждали.
[36:58.320 --> 37:00.320]  Вот, то есть это у нас проход.
[37:01.320 --> 37:06.320]  То есть тут проход, тут, соответственно, там аккуратные леммы, но, думаю, там суть, в общем, понятна, да?
[37:06.720 --> 37:09.720]  Да, ну, если вы пришли только что, вам сложно, конечно, это понять слету, да?
[37:10.720 --> 37:11.720]  Да, ну, все понятно.
[37:12.720 --> 37:16.720]  Да, ну, все, да, но думаете, что все понятно, особенно если с этим алгоритмом сталкивались уже, да?
[37:17.720 --> 37:20.720]  Вот, то есть проход по строке Т, вот это вот мести...
[37:21.720 --> 37:23.720]  Вот, опять же, наша любимая can-go и-go, да?
[37:24.720 --> 37:25.720]  Вот она.
[37:26.720 --> 37:27.720]  То есть очень простой проход.
[37:28.720 --> 37:29.720]  Вот.
[37:30.720 --> 37:32.720]  Вот, и длинные суффиксные ссылки.
[37:33.120 --> 37:38.120]  Вот, и длинные суффиксные ссылки тут тоже описаны, да, тут, конечно, красота в этом плане.
[37:40.120 --> 37:43.120]  Так, да, да, да, да, да, да.
[37:44.120 --> 37:46.120]  В общем, короче говоря, остается только...
[37:51.120 --> 37:54.120]  Вот, остается только вычислить суффиксные ссылки, которые мы пока не знаем, как вычислять.
[37:56.120 --> 37:58.120]  А действительно, как вычислить суффиксные ссылки?
[37:58.520 --> 38:00.520]  Наверное, аналогично полиэндромам.
[38:01.520 --> 38:03.520]  Да? Это каким образом?
[38:04.520 --> 38:06.520]  Ну, в полиэндромах не совсем, там все в онлайне было.
[38:09.520 --> 38:14.520]  Вот. Но суть, на самом деле, примерно та же, даже не в аналогичных полиэндромах, а аналогичной префикс-функции.
[38:16.520 --> 38:19.520]  То есть давайте вспомним, как мы вычисляли...
[38:20.520 --> 38:23.520]  То есть, допустим, мы вычислили префикс-функцию тоже для житой позиции в строке P.
[38:24.520 --> 38:26.520]  Как мы вычисляли префикс-функции в строке P?
[38:26.920 --> 38:28.920]  Как мы вычисляли префикс-функцию в G плюс первой позиции?
[38:30.920 --> 38:32.920]  В общем-то, так же, как и вот в тексте T, да?
[38:33.920 --> 38:38.920]  Потому что мы говорим, что... Что такое подстрока, допустим, что такое вот эта вот подстрока, да?
[38:39.920 --> 38:40.920]  Которая совпадает с префиксом.
[38:41.920 --> 38:43.920]  И эта вот подстрока заканчивается в житой позиции, совпадающей с префиксом.
[38:44.920 --> 38:46.920]  И после которой идет, соответственно, вот этот вот символ.
[38:47.920 --> 38:51.920]  Ну, то есть мы поддерживаем просто указатель на второе P по длине вхождения?
[38:52.920 --> 38:54.920]  Да нет. Ну, там мы поддерживаем.
[38:55.320 --> 38:59.320]  Ну, поддерживали. Причем, более того, это и была как раз определение префикс-функции в строке P.
[39:00.320 --> 39:02.320]  И в нашем случае суффиксные ссылки, да?
[39:03.320 --> 39:10.320]  То есть вот здесь мы вот от G скакали по префикс-функциям, пока очередной префикс не продолжается Y.
[39:11.320 --> 39:13.320]  Соответственно, то есть мы тут скакали, скакали, скакали.
[39:14.320 --> 39:16.320]  Тут дальше идет символ Y. Ура!
[39:17.320 --> 39:21.320]  Вот. Ну, заметим, что буквально это же мы можем сделать и в боре.
[39:21.720 --> 39:25.720]  То есть как посчитать префикс-функцию для вот такой, для этой вершины?
[39:26.720 --> 39:32.720]  Для этого мы берем, берем, значит, родителя, скачем из него по суффиксной ссылке.
[39:33.720 --> 39:36.720]  Вот. Начиная с этого момента мы скачем по суффиксной ссылке,
[39:37.720 --> 39:41.720]  до тех пор, пока из очередной вершины мы не сможем пройти по вот этому символу.
[39:42.720 --> 39:45.720]  Как только сможем, значит, мы по нему проходим и говорим, что это и есть суффиксная ссылка.
[39:46.120 --> 39:47.120]  Суффиксная ссылка.
[39:51.120 --> 39:52.120]  Вроде логично, да?
[39:53.120 --> 39:55.120]  Вроде логично, да вот.
[39:56.120 --> 39:58.120]  То есть, по крайней мере, это находит, это находит правильный ответ,
[39:59.120 --> 40:03.120]  особенно если вы ищете суффиксную ссылку в порядке BFS.
[40:06.120 --> 40:08.120]  Ну, тут два варианта, как их, как их обычно ищут.
[40:09.120 --> 40:10.120]  Ну, значит, три варианта есть.
[40:11.120 --> 40:15.120]  Есть вариант, честно, в порядке BFS, да, тогда, когда вы ищете для очередной вершины суффиксную ссылку,
[40:16.120 --> 40:18.120]  вы знаете, что вот эти вот все скачки уже определены.
[40:19.120 --> 40:20.120]  Понятно, да?
[40:21.120 --> 40:24.120]  Есть другой вариант, есть вариант делать это лениво.
[40:26.120 --> 40:30.120]  Ну, в том плане, что типа, дай мне суффиксную ссылку, а я еще не насчитал,
[40:31.120 --> 40:32.120]  ну, так вот, давай рекурсивно насчитай.
[40:33.120 --> 40:36.120]  Тоже, в принципе, можно будет работать ровно за столько же.
[40:37.120 --> 40:40.120]  Кстати, пока отдельный, отдельный вопрос за сколько, кстати.
[40:40.520 --> 40:41.520]  Вот.
[40:42.520 --> 40:45.520]  Ну, и третий вариант на самом деле надо строить.
[40:46.520 --> 40:48.520]  Третий вариант был бы надо строить автомат.
[40:51.520 --> 40:52.520]  Ну, не суффиксный автомат, а автомат.
[40:53.520 --> 40:56.520]  Ну, мы уже обсуждали, да, что мы для каждой вершины можем предпочитать,
[40:57.520 --> 40:58.520]  и каждого вершины, и каждого символа можем посчитать,
[40:59.520 --> 41:02.520]  что если мы находимся в этой вершине, и у нас следующий символ X, то куда мы попадем, да?
[41:05.520 --> 41:06.520]  То есть как мы это вообще обычно делаем?
[41:07.520 --> 41:09.520]  Ну, с помощью суффиксных ссылок мы это делали легко.
[41:10.520 --> 41:12.520]  То есть если у нас из вершины можно пройти по символу X,
[41:13.520 --> 41:14.520]  значит мы приходим сюда.
[41:15.520 --> 41:16.520]  Если нет, то мы идем по суффиксной ссылке и спрашиваем,
[41:17.520 --> 41:20.520]  а если бы к этой вершине пришел символ X, куда бы мы из нее попали?
[41:23.520 --> 41:25.520]  То есть так по суффиксной ссылке мы бы строили автомат, правда?
[41:28.520 --> 41:32.520]  Но теперь заметим, что мы можем идти, в принципе, BFS-ом по бору
[41:33.520 --> 41:37.520]  и строить одновременно и автомат, и суффиксные ссылки.
[41:38.520 --> 41:39.520]  Почему?
[41:40.520 --> 41:42.520]  Потому что вот у нас есть вот такой переход.
[41:45.520 --> 41:47.520]  Тогда утверждается следующее, что для того, чтобы понять,
[41:48.520 --> 41:50.520]  то есть действительно для того, чтобы понять,
[41:51.520 --> 41:52.520]  куда у нас ведет суффиксная ссылка отсюда,
[41:53.520 --> 41:56.520]  мы должны пойти в родителя, пойти по суффиксной ссылке ранее найденной
[41:57.520 --> 42:00.520]  и спросить, а куда мы из этой вершины перешли бы по символу X?
[42:02.520 --> 42:03.520]  Понятно, да?
[42:04.520 --> 42:05.520]  То есть просто вот.
[42:05.920 --> 42:07.920]  Вот, соответственно, и все.
[42:08.920 --> 42:10.920]  И получается, что мы прям и суффиксную ссылку, и все переходы
[42:11.920 --> 42:13.920]  ищем за O от единицы, причем честно.
[42:22.920 --> 42:26.920]  Нам, короче, нужно сначала попробовать пройти из нашей вершины по символу X.
[42:27.920 --> 42:29.920]  Если этого перехода нет, тогда уже спрашивайте.
[42:30.920 --> 42:32.920]  Ну, когда мы насчитываем автомат, да.
[42:33.320 --> 42:35.320]  То есть скажем, куда из нее пройти по нужному символу?
[42:36.320 --> 42:38.320]  Да, если можно перейти из нее в BORE, то мы переходим,
[42:39.320 --> 42:44.320]  если нет, то спрашиваем, куда в нее пойти из суффиксной ссылки.
[42:45.320 --> 42:47.320]  А суффиксная ссылка ищется вот таким образом.
[42:48.320 --> 42:53.320]  То есть это самый надежный пока с точки зрения симптотики способ.
[42:54.320 --> 42:56.320]  Потому что мы тогда и автомат из суффиксной ссылки
[42:57.320 --> 43:00.320]  насчитываем честно за размер BORE, умноженный на размер алфавита.
[43:00.720 --> 43:06.720]  И переходы, то есть сами скачки в этом тексте T тоже делаются
[43:07.720 --> 43:10.720]  теперь за O от единицы честно, а не амортизировано.
[43:11.720 --> 43:15.720]  Но что делать, если мы согласны на амортизацию, но не согласны
[43:16.720 --> 43:18.720]  на домножение на алфавит?
[43:19.720 --> 43:22.720]  Ну, тогда можно, конечно, считать только суффиксные ссылки
[43:23.720 --> 43:25.720]  и все вот эти переходы делать, вот скакать по суффиксным ссылкам
[43:26.720 --> 43:28.720]  здесь можно предельно честно.
[43:29.120 --> 43:31.120]  Ну вот в порядке BFS, да?
[43:32.120 --> 43:35.120]  Но возникает тогда вопрос, ведь с амортизацией тут напряг,
[43:36.120 --> 43:38.120]  казалось бы, потому что тут же из каждой вершины мы идем
[43:39.120 --> 43:41.120]  сюда-сюда-сюда, и получается, что вроде как амортизация
[43:42.120 --> 43:44.120]  должна вылетать в трубу, правда?
[43:45.120 --> 43:47.120]  Ну, возникает такое ощущение.
[43:48.120 --> 43:50.120]  Поэтому как бы да, и действительно, то есть сказать, верно ли
[43:51.120 --> 43:54.120]  что мы все сделаем за O от размера BORE, мы не можем.
[43:54.520 --> 43:57.520]  Вы имеете в виду, что у нас может указывать на один
[43:58.520 --> 44:00.520]  длинный путь без лицов очень много суффиксных ссылок?
[44:01.520 --> 44:03.520]  Ну да, то есть там можно...
[44:04.520 --> 44:06.520]  Ну, типа того, да.
[44:08.520 --> 44:10.520]  Да, потому что была бы это одна строчка, тогда амортизация
[44:11.520 --> 44:13.520]  на лицо, потому что каждый скачок типа уменьшает нам
[44:14.520 --> 44:16.520]  соответственно длину, вот, и там это как потенциал.
[44:17.520 --> 44:19.520]  Но так как у нас здесь есть развилки, то мы так
[44:20.520 --> 44:22.520]  возрадоваться не можем.
[44:22.920 --> 44:24.920]  Вот.
[44:25.920 --> 44:28.920]  Но, на самом деле, мы можем догадать кое-что точнее.
[44:29.920 --> 44:31.920]  Если мы рассмотрим одну из строчек BORE
[44:32.920 --> 44:34.920]  и рассмотрим время, которое мы потратили
[44:35.920 --> 44:37.920]  на то, чтобы таким образом найти
[44:38.920 --> 44:40.920]  суффиксные ссылки именно для вот вершин
[44:41.920 --> 44:43.920]  соответствующей ей пути,
[44:44.920 --> 44:46.920]  тогда я утверждаю, что суммарное время
[44:47.920 --> 44:49.920]  поиска суффиксных ссылок именно для этого пути
[44:50.320 --> 44:52.320]  есть.
[44:55.320 --> 44:57.320]  Вот. Почему?
[44:58.320 --> 45:00.320]  Ну, просто метод на самом деле тот же, да,
[45:01.320 --> 45:03.320]  тут можно формально ввести потенциал,
[45:04.320 --> 45:06.320]  но суть та же, потому что для каждой следующей вершины
[45:07.320 --> 45:09.320]  мы начинаем как бы искать
[45:10.320 --> 45:12.320]  суффиксную ссылку примерно там же,
[45:13.320 --> 45:15.320]  где мы закончили ее искать в прошлый раз.
[45:16.320 --> 45:18.320]  То есть для родителей.
[45:18.720 --> 45:20.720]  Как мы ищем для следующей вершины?
[45:21.720 --> 45:23.720]  Тогда мы с этого момента скачем сколько-то по суффиксным ссылкам,
[45:24.720 --> 45:26.720]  потом делаем один переход, правда?
[45:27.720 --> 45:29.720]  Понятна логика, да?
[45:36.720 --> 45:38.720]  Или нет?
[45:39.720 --> 45:41.720]  Сейчас, мне что-то не очень нравится.
[45:42.720 --> 45:44.720]  Так, ну давайте.
[45:45.720 --> 45:47.720]  Короче говоря, если у нас из родителей была длинная суффиксная ссылка,
[45:48.720 --> 45:50.720]  то значит сам родитель достаточно глубоко
[45:51.720 --> 45:53.720]  и значит
[45:54.720 --> 45:56.720]  каждый раз чтобы воспользоваться,
[45:57.720 --> 45:59.720]  чтобы пройти по этому пути суффиксным ссылкам,
[46:00.720 --> 46:02.720]  нужно до этого родителям дойти по новой строчке
[46:03.720 --> 46:05.720]  и мы собственно длиной это окупаем, да?
[46:06.720 --> 46:08.720]  Ну, ну сложно сказать.
[46:09.720 --> 46:11.720]  Я б так не мыслил.
[46:12.720 --> 46:14.720]  Ну, в плане если картинка представляет в голове,
[46:15.720 --> 46:17.720]  что типа такой длинный путь,
[46:18.720 --> 46:20.720]  нет, а это тут ни при чем.
[46:21.720 --> 46:23.720]  Еще раз, нет, это тут ни при чем.
[46:24.720 --> 46:26.720]  То есть пока глобальному бору мы еще вывод сделаем.
[46:27.720 --> 46:29.720]  Пока я просто говорю, что жила была длинная строчка,
[46:30.720 --> 46:32.720]  которую мы добавили в бор.
[46:33.720 --> 46:35.720]  Конкретно на этом пути суффиксные ссылки находятся
[46:36.720 --> 46:38.720]  от его пути.
[46:39.720 --> 46:41.720]  Вот.
[46:44.720 --> 46:46.720]  Из той же префикс функции.
[46:47.120 --> 46:49.120]  Нет, я имею в виду, что если мы проведем бор вместе,
[46:50.120 --> 46:52.120]  подумаем, что это логично вообще.
[46:53.120 --> 46:55.120]  То есть у тебя же ровно те же баллы.
[46:56.120 --> 46:58.120]  Нет, в смысле для каждой отдельной строчки это понятно.
[46:59.120 --> 47:01.120]  Ну вот.
[47:02.120 --> 47:04.120]  Но физический смысл этого доказательства тоже
[47:05.120 --> 47:07.120]  становится неплохо.
[47:08.120 --> 47:10.120]  Типа, когда у нас может быть плохая ситуация,
[47:11.120 --> 47:13.120]  когда у нас очень длинный путь,
[47:14.120 --> 47:16.120]  а потом из нижней вершины куча листов исходит.
[47:17.120 --> 47:19.120]  Тогда мы с каждым из этих листов будем очень высоко подниматься,
[47:20.120 --> 47:22.120]  но чтобы дойти до этого листа нам нужно пройти
[47:23.120 --> 47:25.120]  вот этот длинный путь в начале.
[47:26.120 --> 47:28.120]  Ну да, причем по другим строчкам, что характерно.
[47:29.120 --> 47:31.120]  Да, хорошо, можно так срулировать.
[47:32.120 --> 47:34.120]  Да, то есть смысл такой.
[47:35.120 --> 47:37.120]  Отсюда же подчеркиваем, что мы работаем не за количество вершин в боре,
[47:38.120 --> 47:40.120]  потому что количество вершин в боре может быть значительно меньше,
[47:41.120 --> 47:43.120]  чем суммарная длина строчки.
[47:44.120 --> 47:46.120]  Потому что у строчек может быть какой-то длинный общий префикс и развилочки.
[47:47.120 --> 47:49.120]  Но гарантировать, что вот таким образом,
[47:50.120 --> 47:52.120]  что суммарно вычисляется за от сумму длин, мы можем.
[47:53.120 --> 47:55.120]  То есть просто подчеркиваю еще раз,
[47:56.120 --> 48:00.120]  между размером бора и суммарной длиной строчек разница существенная.
[48:03.120 --> 48:08.120]  Так что вот такая вот не очень хитрая идея.
[48:17.120 --> 48:19.120]  Вот, ну что?
[48:20.120 --> 48:24.120]  Так, в принципе тогда это означает, что мы победили тем или иным образом.
[48:25.120 --> 48:27.120]  Динамический авторатик.
[48:28.120 --> 48:30.120]  Ну, в смысле, где он динамический?
[48:31.120 --> 48:33.120]  К сожалению, он не динамический, он статический.
[48:34.120 --> 48:37.120]  Можете еще раз поговорить, как это следует из предыдущего утверждения?
[48:38.120 --> 48:40.120]  Ну, в смысле, если, ну как сказать, бор состоит,
[48:41.120 --> 48:43.120]  что такое бор, как вы составляли бор?
[48:44.120 --> 48:46.120]  Мы каждую строчку туда аккуратненько добавляли, да?
[48:47.120 --> 48:49.120]  Мы вот посчитали суффиксные ссылки, да?
[48:50.120 --> 48:54.120]  Теперь говорим, что бор покрывается, по идее, путями этих строчек.
[48:55.120 --> 48:58.120]  Ну, каждая вершина покрывается одним или большим числом путей, да?
[49:00.120 --> 49:02.120]  Но тогда это означает, что каждую...
[49:03.120 --> 49:05.120]  Но заметим, что если взять путь в соответствующей строке,
[49:06.120 --> 49:09.120]  то суффиксные ссылки на нем искали за от длины этой строки, да?
[49:10.120 --> 49:12.120]  Тогда получается, если мы возьмем все строчки,
[49:13.120 --> 49:15.120]  то есть мы с одной стороны покроем весь бор,
[49:15.520 --> 49:17.520]  время, не превосходящие суммы длины этих строчек.
[49:22.520 --> 49:24.520]  А, стоп, я думал, сих бывает размер алфавита.
[49:25.520 --> 49:26.520]  Не, это сумма.
[49:27.520 --> 49:29.520]  Размер алфавита у нас alphabet size, напоминаю.
[49:32.520 --> 49:34.520]  Сейчас сюда сумма длины строк, ну да.
[49:35.520 --> 49:37.520]  Вот, нет, сумма длины строчек, конечно.
[49:38.520 --> 49:40.520]  Получается, суффиксные ссылки мы из-за этого времени насчитали,
[49:41.520 --> 49:43.520]  если давно что-то разбил алфавит, там можно еще автомат построить.
[49:43.920 --> 49:45.920]  После этого мы ходим по тексту,
[49:46.920 --> 49:48.920]  значит, делаем проход по тексту t у этого бора,
[49:49.920 --> 49:52.920]  это делаем за от t, и там еще какие-то дополнения на размер ответа.
[49:55.920 --> 49:57.920]  Но это если у нас прям такая экзотическая задача,
[49:58.920 --> 50:00.920]  это если у нас такая вот экзотическая задача,
[50:01.920 --> 50:03.920]  в которой прям все обхождения надо честно выписать.
[50:04.920 --> 50:06.920]  Вот давайте, например, подумаем, какие тут еще задачи есть.
[50:07.920 --> 50:09.920]  А, вот тут еще про автомат сказано,
[50:10.920 --> 50:12.920]  но про автомат мы уже все поняли,
[50:13.920 --> 50:15.920]  что это все, да.
[50:16.920 --> 50:18.920]  Вот, то на самом деле есть еще веселые задачи.
[50:19.920 --> 50:21.920]  Можно вопрос? Давай.
[50:22.920 --> 50:24.920]  Давай.
[50:25.920 --> 50:27.920]  Вот мы выписывали оценку на время работы 1 на единичной сети.
[50:28.920 --> 50:30.920]  Ну.
[50:31.920 --> 50:33.920]  Я правильно понимаю, что если нас мент-код запускать в единичной сети,
[50:34.920 --> 50:36.920]  то работают те же оценки?
[50:39.920 --> 50:41.920]  Не уверен.
[50:42.320 --> 50:44.320]  Ну, то есть они не совсем такие же, но...
[50:45.320 --> 50:47.320]  Нет, ну не уверен.
[50:48.320 --> 50:50.320]  То есть ты не будешь там искать пути, кратчайшие по количеству ребер?
[50:57.320 --> 50:59.320]  А, у нас оценка была из того, что мы нашли до корня,
[51:00.320 --> 51:02.320]  а тут мы не ищем до корня, а просто какие.
[51:03.320 --> 51:05.320]  Тут просто ищем кратчайшие пути по суммарной длине ребер.
[51:06.320 --> 51:08.320]  Сколько ребер нас не волнует.
[51:09.320 --> 51:11.320]  То есть нам такие.
[51:12.320 --> 51:14.320]  Да, причем тут суффиксные ссылки.
[51:15.320 --> 51:17.320]  Но теперь давайте тут подумаем.
[51:18.320 --> 51:20.320]  Прежде чем я открыл другие задачи, давайте еще подумаем.
[51:21.320 --> 51:23.320]  А если нас действительно попросили
[51:24.320 --> 51:26.320]  просто для каждой строки из этого списка сказать,
[51:27.320 --> 51:29.320]  сколько раз она входит в текст Т?
[51:30.320 --> 51:32.320]  Для каждой строки из списка?
[51:33.320 --> 51:35.320]  Да. То есть данные строки С1, С2 и так далее СК.
[51:36.320 --> 51:38.320]  То есть вы видите К чисел, житое из них,
[51:39.320 --> 51:41.320]  это сколько раз строчка житое входит в текст Т?
[51:42.320 --> 51:44.320]  Единицу складывать и вершину.
[51:45.320 --> 51:46.320]  Ну да.
[51:47.320 --> 51:49.320]  То есть наше решение исходно было бы какое?
[51:50.320 --> 51:52.320]  То есть мы проходим по текстам Т, по этому Бору
[51:53.320 --> 51:55.320]  с суффиксными ссылками и когда находим там вершину,
[51:56.320 --> 51:58.320]  то есть мы должны прибежаться по всем длинным суффиксным ссылкам
[51:59.320 --> 52:02.320]  и поприбавлять во всех терминальных вершинках единичку.
[52:03.320 --> 52:05.320]  Так это не очень.
[52:06.320 --> 52:08.320]  Ну это по крайней мере так было бы правильно, но долго.
[52:08.720 --> 52:10.720]  Но с другой стороны,
[52:11.720 --> 52:13.720]  после этого мы просто вспоминаем,
[52:14.720 --> 52:16.720]  что суффиксные ссылки образуют подвешенное дерево с корнем в корне.
[52:19.720 --> 52:21.720]  И тогда у нас идея такая,
[52:22.720 --> 52:24.720]  то есть тогда идея такая,
[52:25.720 --> 52:27.720]  дано дерево и у нас периодически приходят запросы,
[52:28.720 --> 52:30.720]  увеличить на единичку весь путь от какой-то вершины до корня.
[52:33.720 --> 52:35.720]  И потом когда-нибудь в конце сообщи результат.
[52:36.120 --> 52:38.120]  Как мы это делаем?
[52:39.120 --> 52:41.120]  Сейчас увеличить на единичку?
[52:42.120 --> 52:44.120]  Нет, стоп, почему нет?
[52:45.120 --> 52:47.120]  Не путь от вершины до корня, а наоборот кажется под дерево.
[52:48.120 --> 52:50.120]  Нет, именно путь.
[52:51.120 --> 52:53.120]  Потому что мы же говорим,
[52:54.120 --> 52:56.120]  текст Т привел нас в какую-то вершину,
[52:57.120 --> 52:59.120]  то есть в этом символе он привел нас в какую-то вершину.
[53:00.120 --> 53:02.120]  И мы должны прибежаться из нее по суффиксным ссылкам
[53:03.120 --> 53:05.120]  и всем вершинам, можно только терминальным,
[53:06.120 --> 53:08.120]  и всем вершинам прибавить по единичке до корня.
[53:11.120 --> 53:13.120]  А как у нас в подвешенном дереве прибавлять к пути единичку?
[53:16.120 --> 53:18.120]  Ну да, то есть просто сделать отложенную вершину,
[53:19.120 --> 53:21.120]  прибавить только к вершине, а потом в конце пробежаться от детей до корня
[53:22.120 --> 53:24.120]  и все прибавления передать в родителя.
[53:30.120 --> 53:32.120]  То есть вы пробежитесь по тексту Т,
[53:33.120 --> 53:35.120]  за ОАТ,
[53:36.120 --> 53:40.120]  и размер бора в конце протолкнете все эти единички по суффиксным ссылкам.
[53:41.120 --> 53:43.120]  Размер бора может быть очень большой.
[53:44.120 --> 53:46.120]  Но учитывая, что вы в самом начале решения тратили время
[53:47.120 --> 53:49.120]  на то, чтобы его построить, и построить суффиксный ссылк.
[53:50.120 --> 53:52.120]  У нас же строчки Т могут приходить много раз.
[53:53.120 --> 53:55.120]  У нас строчка Т может приходить много раз,
[53:56.120 --> 53:58.120]  и каждый из них мы работаем за ОАТ Т, поэтому все нормально.
[53:59.120 --> 54:01.120]  А, ну нет, хорошо, тогда да.
[54:02.120 --> 54:04.120]  То есть модификация да,
[54:04.520 --> 54:06.520]  и надо для каждого текста Т выводить к отчисел, да?
[54:07.520 --> 54:09.520]  Хочется тарить.
[54:10.520 --> 54:12.520]  А, ну я понял, я понял.
[54:13.520 --> 54:15.520]  Ну хорошо, ну тогда два варианта есть.
[54:16.520 --> 54:18.520]  Ну нет, самый тупой вариант это давай проталкивать единичку
[54:19.520 --> 54:21.520]  не по суффиксным ссылкам, а по длинным суффиксным ссылкам.
[54:22.520 --> 54:24.520]  Тогда вот этот вот проход будет, то есть дерево
[54:25.520 --> 54:27.520]  на длинных суффиксных ссылках будет размера К.
[54:28.520 --> 54:30.520]  К – это количество строк?
[54:31.520 --> 54:33.520]  Да.
[54:34.520 --> 54:36.520]  Ну мы берем такое сжатое дерево?
[54:37.520 --> 54:39.520]  Ну по сути, да.
[54:40.520 --> 54:42.520]  Сейчас,
[54:45.520 --> 54:47.520]  сейчас,
[54:48.520 --> 54:50.520]  в плане, у нас есть просто отдельно дерево,
[54:51.520 --> 54:53.520]  которое построено на терминальных вершинах,
[54:54.520 --> 54:56.520]  и у него размер К,
[54:57.520 --> 54:59.520]  и отдельно есть забросы, но забросы почему-то на К,
[55:00.520 --> 55:02.520]  и у него размер К,
[55:02.920 --> 55:04.920]  но забросов, очевидно, не больше, чем Т,
[55:05.920 --> 55:07.920]  и каждый запрос подвешивается к какой-то вершине из этого дерева.
[55:08.920 --> 55:10.920]  Нет, запросов-то у нас все еще Т.
[55:11.920 --> 55:13.920]  Другой вопрос, тут понятно, что конкретно эта вершина
[55:14.920 --> 55:16.920]  не обязана быть терминальной,
[55:17.920 --> 55:19.920]  но мы говорим, что давайте прибавлять единичку,
[55:20.920 --> 55:22.920]  если она не терминальная не ей, а ее длинные суффиксные ссылки.
[55:23.920 --> 55:25.920]  Ну то есть у нас получается как раз К плюс Т?
[55:26.920 --> 55:28.920]  Ну для каждого конкретного текста получается Т плюс К,
[55:29.920 --> 55:31.920]  ну не считая исходное построение бора из суффиксных ссылок.
[55:32.920 --> 55:34.920]  Да, можно так.
[55:35.920 --> 55:37.920]  Ну или если вы хотите там какие-то онлайновые запросы
[55:38.920 --> 55:40.920]  в духе там, вот вам текст Т и вас там периодически кого-то спрашивают,
[55:41.920 --> 55:43.920]  то что в этом случае можно сделать?
[55:44.920 --> 55:46.920]  Ну в конце концов построите хевилайт
[55:47.920 --> 55:49.920]  на этом дереве суффиксных ссылок, господи.
[55:52.920 --> 55:54.920]  Да, о боже, хевилайт на дереве суффиксных ссылок.
[55:55.920 --> 55:57.920]  Вообще интересно придумать задачу, в которую это надо делать, конечно.
[55:58.920 --> 56:00.920]  Что-то мне не нравится идея с хевилайтом.
[56:01.320 --> 56:03.320]  А чего тебе не нравится?
[56:04.320 --> 56:08.320]  В том, что там у нас мы прибавляли, а потом в конце пробегались и суммировали.
[56:09.320 --> 56:11.320]  А если у нас онлайн, то мы не можем пробегаться и суммировать.
[56:12.320 --> 56:14.320]  Да, но хевилайт-то позволяет вам прибавлять единичку на пути.
[56:15.320 --> 56:17.320]  Нам не нужно прибавлять единичку, нам нужно сразу уговорить.
[56:22.320 --> 56:26.320]  Ну типа, ну я не очень понимаю какой у нас конкретный запрос.
[56:27.320 --> 56:30.320]  Ну запрос ты прибыл, да оно дерево отдам, допустим, то ли суффиксных ссылок.
[56:31.320 --> 56:34.320]  И там тебе дают вершину и говорят прибавь на всем пути от вершины до корня плюс один.
[56:35.320 --> 56:36.320]  Это какая-то странная задача.
[56:37.320 --> 56:38.320]  Нормальная задача.
[56:39.320 --> 56:41.320]  В плане, она уже плохо связывается со строчкой Т.
[56:43.320 --> 56:45.320]  Нет, почему? Она гениально связывается.
[56:46.320 --> 56:49.320]  Более того, у тебя вообще дан текст Т и у тебя два типа запросов.
[56:50.320 --> 56:51.320]  Первый, припиши к тексту Т символ.
[56:52.320 --> 56:58.320]  И второй тип запроса, дано число жи, скажи, пожалуйста, сколько сейчас вхождений,
[56:58.720 --> 57:00.720]  житое строчка из того списка имеет в тексте.
[57:03.720 --> 57:06.720]  То есть с Хэви-Лайтом ты это даже в онлайне делать умеешь.
[57:09.720 --> 57:10.720]  Сейчас.
[57:12.720 --> 57:15.720]  Ну то есть нам нужно будет суммировать количество единичку под дерево.
[57:16.720 --> 57:17.720]  Ну можно и так.
[57:18.720 --> 57:19.720]  Нет, зачем?
[57:20.720 --> 57:24.720]  Хэви-Лайт это такая структура данных, которая умеет прибавлять единичку на дерево.
[57:25.720 --> 57:26.720]  У нас атака-то уже есть.
[57:27.120 --> 57:28.120]  Да, то есть Хэви-Лайт сам по себе это умеет.
[57:29.120 --> 57:31.120]  Нет, при желании, да, на самом деле абсолютно правильно.
[57:32.120 --> 57:35.120]  Можно делать единички под дерево, на самом деле мы это можем делать без Хэви-Лайта,
[57:36.120 --> 57:39.120]  просто запустив DFS по бору и перенумеровав правильные вершины.
[57:40.120 --> 57:42.120]  Ну, чтобы ДО-шку построить.
[57:43.120 --> 57:44.120]  Можно и так.
[57:45.120 --> 57:47.120]  Да, конечно, не надо писать Хэви-Лайт там, где его не надо писать,
[57:48.120 --> 57:51.120]  но хотя с точки зрения теории у нас есть Хэви-Лайт, который умеет все делать за логарифом, напоминаю.
[57:52.120 --> 57:55.120]  То есть не за лог квадрат, а за логарифом, помните?
[57:55.520 --> 57:58.520]  Ну и другое. Ну, пожалуйста, можно линкат использовать.
[57:59.520 --> 58:00.520]  Который быстрее работает, да.
[58:01.520 --> 58:04.520]  Но он работает за логарифом, просто надо писать с плей дерева, все нормально, да.
[58:05.520 --> 58:08.520]  Я вам сказал, когда тоже работает за логарифом, надо за логарифом дольше, чем лог квадрат.
[58:09.520 --> 58:10.520]  Да, пробовал.
[58:11.520 --> 58:12.520]  Мне сказали.
[58:13.520 --> 58:14.520]  Кто сказал?
[58:15.520 --> 58:18.520]  Тут всех таких вопросов, да, если это надо, то пробовал.
[58:20.520 --> 58:21.520]  То есть как бы ты пробовал.
[58:22.520 --> 58:23.520]  По-моему, ты пробовал.
[58:23.920 --> 58:25.920]  Айд, ты сказал? А ты пробовал?
[58:26.920 --> 58:27.920]  А мне кто-то сказал.
[58:28.920 --> 58:29.920]  А этот кто-то пробовал?
[58:30.920 --> 58:31.920]  Да, да, да.
[58:32.920 --> 58:33.920]  Ну да.
[58:34.920 --> 58:36.920]  Нет, ну там просто, да, знаете как.
[58:37.920 --> 58:42.920]  То есть когда вы делаете такое утверждение, вас как бы могут неожиданно спросить, про это ты проверял.
[58:43.920 --> 58:45.920]  То есть знаете, классическая разминка.
[58:46.920 --> 58:48.920]  Нет, другая ситуация.
[58:49.920 --> 58:50.920]  В этом смысле большая подстава.
[58:51.320 --> 58:55.320]  Как-то давным-давно, когда в высшей лиге КВН играли украинские команды.
[58:56.320 --> 58:58.320]  Да, очень было давно, там год 2010.
[58:59.320 --> 59:02.320]  Но там, собственно, украинская команда хорошо прикололась на разминке.
[59:03.320 --> 59:05.320]  Потому что там выходит девушка и задает вопрос.
[59:06.320 --> 59:07.320]  Звучит он так.
[59:08.320 --> 59:13.320]  Во время поездки по России премьер-министр посещает не только крупные города, но и трудодоступные деревни.
[59:14.320 --> 59:15.320]  Пока все нормально.
[59:15.720 --> 59:20.720]  Но приходит в том, что когда человек выходит отвечать, она ему начинает говорить что-нибудь там.
[59:21.720 --> 59:26.720]  Премьер-министр посещает не только крупные города, но и трудодоступные деревни.
[59:27.720 --> 59:30.720]  Ну вот, то есть человек как минимум сбивается.
[59:31.720 --> 59:32.720]  Чего?
[59:33.720 --> 59:36.720]  Премьер-министр посещает не только крупные города, но и трудодоступные деревни.
[59:37.720 --> 59:38.720]  Мило говорит девушка.
[59:39.720 --> 59:40.720]  А вас ничего не смущает, да?
[59:41.720 --> 59:42.720]  О, она ошиблась.
[59:43.120 --> 59:47.120]  Да, но фишка в том, что она делает это несколько раз подряд, причем в разных местах.
[59:48.120 --> 59:51.120]  То есть приходит там очередной парень и она ему там.
[59:52.120 --> 59:55.120]  Он посещает не только крупные города, но и трудодоступные деревни.
[59:56.120 --> 59:57.120]  Вот.
[59:58.120 --> 59:59.120]  Я не понял, что происходит.
[01:00:00.120 --> 01:00:01.120]  Какие парни приходят?
[01:00:02.120 --> 01:00:03.120]  Так.
[01:00:05.120 --> 01:00:06.120]  Понятно.
[01:00:07.120 --> 01:00:09.120]  Украиновская разминка, знакомое словосочетание вообще?
[01:00:10.120 --> 01:00:12.120]  Так ладно, тогда бесполезно рассказывать.
[01:00:13.120 --> 01:00:14.120]  Ой, кошмар.
[01:00:15.120 --> 01:00:17.120]  Ничего себе, люди уже не знают, что такое КВНовская разминка вообще.
[01:00:18.120 --> 01:00:19.120]  Ну вообще, да.
[01:00:20.120 --> 01:00:21.120]  Но это я не знал, а догадался.
[01:00:26.120 --> 01:00:27.120]  Когда-то было, да.
[01:00:28.120 --> 01:00:31.120]  Не отправляй, что люди уже могут не помнить, что КВН вообще еще существует в природе вообще.
[01:00:32.120 --> 01:00:33.120]  И даже по первому каналу еще показывают.
[01:00:34.120 --> 01:00:37.120]  Я знаю, где надо стихотворение дополнить, причем не смешно, а что бы поверить.
[01:00:38.120 --> 01:00:39.120]  Ой, ой, ой.
[01:00:40.120 --> 01:00:41.120]  В КВН такое, по-моему, в 2005 последний раз практиковалось.
[01:00:41.520 --> 01:00:42.520]  Да.
[01:00:43.520 --> 01:00:45.520]  Нет, таких вопросов там нет.
[01:00:46.520 --> 01:00:48.520]  Не, максимум, что там предлагал, это...
[01:00:49.520 --> 01:00:50.520]  Это вписывается в концепцию.
[01:00:51.520 --> 01:00:52.520]  Не, но там было страшнее.
[01:00:53.520 --> 01:00:57.520]  Когда-то нам на разминке предложили, уважаемые капитаны, за 30 секунд напишите стихотворение,
[01:00:58.520 --> 01:01:00.520]  которое заканчивается строчкой «смотрите на первом канале».
[01:01:03.520 --> 01:01:04.520]  Да, 30 секунд.
[01:01:05.520 --> 01:01:08.520]  Не, но там первый капитан вышел через 15 секунд на самом деле.
[01:01:09.520 --> 01:01:10.520]  И при...
[01:01:10.920 --> 01:01:11.920]  Почему вышел?
[01:01:12.920 --> 01:01:13.920]  Нет, зачем?
[01:01:14.920 --> 01:01:15.920]  Честно вышел и заявил.
[01:01:16.920 --> 01:01:17.920]  Так, тот, кто много где бывал, очень много повидал.
[01:01:18.920 --> 01:01:19.920]  А все, что вы не видали, смотрите на первом канале.
[01:01:20.920 --> 01:01:21.920]  Все.
[01:01:22.920 --> 01:01:23.920]  Но команда чемпиона, кстати, стала.
[01:01:24.920 --> 01:01:25.920]  Вот.
[01:01:26.920 --> 01:01:27.920]  Так что было классно.
[01:01:28.920 --> 01:01:29.920]  Так, ладно.
[01:01:30.920 --> 01:01:31.920]  Понятно.
[01:01:32.920 --> 01:01:33.920]  Все с вами.
[01:01:34.920 --> 01:01:35.920]  Так.
[01:01:36.920 --> 01:01:37.920]  Вот.
[01:01:38.920 --> 01:01:39.920]  Так вот.
[01:01:40.920 --> 01:01:41.920]  Ну вот.
[01:01:42.920 --> 01:01:43.920]  Значит, какие у нас еще есть задачи?
[01:01:44.920 --> 01:01:45.920]  Вот.
[01:01:46.920 --> 01:01:47.920]  Ну, на самом деле, да.
[01:01:48.920 --> 01:01:49.920]  То есть, в принципе, оно есть такие пара классических задач,
[01:01:50.920 --> 01:01:51.920]  что-то из них видели, но они обсудить нельзя.
[01:01:52.920 --> 01:01:53.920]  Значит, вот какие у нас строчки есть?
[01:01:54.920 --> 01:01:55.920]  Есть вот строчки, например, такие.
[01:01:56.920 --> 01:01:57.920]  Вот, например, такая неожиданная задача.
[01:01:58.920 --> 01:01:59.920]  Дана строка «с».
[01:02:00.920 --> 01:02:01.920]  Ну, например, пока еще без...
[01:02:02.920 --> 01:02:03.920]  Ах, карасик.
[01:02:04.920 --> 01:02:07.920]  Спрашивает, а сколько существует строк длины «н» над заданным алфавитом?
[01:02:08.320 --> 01:02:11.320]  Ну, он там двоичный, троичный и так далее, да.
[01:02:12.320 --> 01:02:15.320]  Который содержит ровно «к» в хождении строки «с».
[01:02:17.320 --> 01:02:20.320]  Что значит «содержать в хождении»?
[01:02:21.320 --> 01:02:22.320]  Ну, то и означает.
[01:02:23.320 --> 01:02:24.320]  Входит.
[01:02:25.320 --> 01:02:30.320]  Сколько существует строк, у которых строка «с» входит в эту строку как подстрока?
[01:02:31.320 --> 01:02:32.320]  Причем «к» раз.
[01:02:33.320 --> 01:02:34.320]  Короче, это не как питание регулярно.
[01:02:35.320 --> 01:02:36.320]  Вот.
[01:02:36.720 --> 01:02:39.720]  Ну, правда, в хождении могут пересекаться, естественно, да?
[01:02:40.720 --> 01:02:41.720]  Вот задача.
[01:02:41.720 --> 01:02:42.720]  Как такое решать?
[01:02:43.720 --> 01:02:44.720]  Вот запредлагаемую асимптотику.
[01:02:45.720 --> 01:02:46.720]  Что с... еще асимптотика?
[01:02:47.720 --> 01:02:50.720]  Не, ну асимптотика должна по-моему сразу палить ответ.
[01:02:55.720 --> 01:02:57.720]  Можно «дп» сделать.
[01:02:58.720 --> 01:02:59.720]  Так, какое «дп»?
[01:03:00.720 --> 01:03:01.720]  «Дп» и «жи».
[01:03:02.720 --> 01:03:03.720]  Что?
[01:03:04.720 --> 01:03:05.720]  И «жк».
[01:03:06.720 --> 01:03:07.720]  Что?
[01:03:08.720 --> 01:03:09.720]  Мы сделали строчку длины «и».
[01:03:10.720 --> 01:03:11.720]  Так.
[01:03:12.720 --> 01:03:14.720]  Входит «жи» в строк «с» целиком.
[01:03:15.720 --> 01:03:16.720]  А в конце...
[01:03:17.720 --> 01:03:18.720]  Да.
[01:03:19.720 --> 01:03:20.720]  А в конце префикс-функция «к».
[01:03:21.720 --> 01:03:22.720]  Ну да.
[01:03:23.720 --> 01:03:24.720]  Совершенно верно.
[01:03:24.720 --> 01:03:25.720]  Понятно, о чем речь, да?
[01:03:26.720 --> 01:03:27.720]  Вот.
[01:03:28.720 --> 01:03:29.720]  Ну, классика, на самом деле, потому что в двоичном виде...
[01:03:30.720 --> 01:03:31.720]  А нет.
[01:03:32.720 --> 01:03:35.720]  То есть в принципе заметим, что это решение с префикс-функцией прекрасно обобщается и на борт.
[01:03:36.720 --> 01:03:38.720]  Потому что заметим, что сбором мы делаем буквально то же самое,
[01:03:39.720 --> 01:03:41.720]  только в состоянии динамики у нас ходит уже не...
[01:03:42.720 --> 01:03:45.720]  То есть вместо «жи» получается вершина бора, соответственно.
[01:03:46.720 --> 01:03:47.720]  Вот, понимаете, да?
[01:03:48.720 --> 01:03:50.720]  Ну, самое глубокое имеется в виду, конечно.
[01:03:51.720 --> 01:03:52.720]  Вот.
[01:03:55.720 --> 01:03:57.720]  Так, а вот это уже должно быть что-то знакомое, да?
[01:03:58.720 --> 01:04:01.720]  Да, но это тоже одна из классических задач на «карасик», конечно.
[01:04:02.720 --> 01:04:04.720]  То есть существует ли строка бесконечной длины,
[01:04:05.120 --> 01:04:07.120]  несодержащая в себе запрещённых подстрок?
[01:04:14.120 --> 01:04:15.120]  Да.
[01:04:16.120 --> 01:04:17.120]  За «о» от суммарной длины строчек, пожалуйста, такой на эти.
[01:04:18.120 --> 01:04:19.120]  Вот существует ли она?
[01:04:20.120 --> 01:04:21.120]  Или можно даже еще, если нет, то насколько...
[01:04:22.120 --> 01:04:24.120]  Какой максимальной длины такая строка может быть?
[01:04:35.120 --> 01:04:42.120]  Ну, типа можно банить все вершины, из которых по сути все ссылки достижены концы?
[01:04:43.120 --> 01:04:44.120]  Ну да.
[01:04:45.120 --> 01:04:46.120]  То есть строим борт, строим автомат,
[01:04:47.120 --> 01:04:50.120]  и баним все вершины, из которых по сути ссылка может дойти до терминальных.
[01:04:51.120 --> 01:04:53.120]  И теперь остается в внимание вопрос,
[01:04:54.120 --> 01:04:56.120]  какой максимальный длинный путь вы можете...
[01:04:57.120 --> 01:04:58.120]  Путь, возможно, непростой.
[01:04:59.120 --> 01:05:02.120]  Вы можете забабахать, начиная с корня, по незабаненным вершинам.
[01:05:02.520 --> 01:05:05.520]  В смысле, с переходами, возможно, по суффиксам ссылки или что?
[01:05:06.520 --> 01:05:07.520]  Нет.
[01:05:08.520 --> 01:05:09.520]  Граф, я имею в виду не борт, а автомат.
[01:05:12.520 --> 01:05:13.520]  Паша, карасик.
[01:05:18.520 --> 01:05:19.520]  Ну вот.
[01:05:20.520 --> 01:05:23.520]  То есть можно ли ходить по этому автомату бесконечно,
[01:05:24.520 --> 01:05:25.520]  не заскакивая в запрещённые вершины?
[01:05:26.520 --> 01:05:27.520]  Да или нет?
[01:05:28.520 --> 01:05:29.520]  Но определить это очень просто.
[01:05:30.520 --> 01:05:31.520]  Надо просто понять, доступен ли искорний цикл.
[01:05:32.520 --> 01:05:33.520]  Просто.
[01:05:34.520 --> 01:05:35.520]  Ну вот, да или нет.
[01:05:36.520 --> 01:05:39.520]  Если доступен, значит, вот, пожалуйста, вот вам и бесконечная строка.
[01:05:40.520 --> 01:05:42.520]  Если нет, ну значит, тогда всё, что вам остаётся,
[01:05:43.520 --> 01:05:45.520]  это в этом циклическом графе найти самый длинный путь и сказать вот.
[01:05:47.520 --> 01:05:49.520]  Так что вот такая вот тоже классическая задача.
[01:05:51.520 --> 01:05:53.520]  Вот. Это у нас что касается...
[01:05:56.520 --> 01:05:57.520]  Ну как будет?
[01:05:58.520 --> 01:06:01.520]  Уже некорректно говорить будет, потому что большие задания у вас уже есть.
[01:06:02.520 --> 01:06:05.520]  Так что и вообще, по-моему, я такое ставил.
[01:06:07.520 --> 01:06:08.520]  Ага.
[01:06:09.520 --> 01:06:10.520]  Починились задачи?
[01:06:11.520 --> 01:06:13.520]  Да, ну мы с вами в прошлый раз сидели и чинили.
[01:06:14.520 --> 01:06:17.520]  А, ну да, не с вами, но мы в прошлый раз сидели и чинили, да.
[01:06:18.520 --> 01:06:21.520]  Можно сейчас зачинить, потому что там последние несколько задач не отмечены,
[01:06:22.520 --> 01:06:23.520]  как стринка, просто E и F.
[01:06:24.520 --> 01:06:25.520]  А, ну это мелочи уже.
[01:06:26.520 --> 01:06:27.520]  Некрасиво выглядит.
[01:06:28.520 --> 01:06:29.520]  А, ну в этом плане, но не судим.
[01:06:29.920 --> 01:06:31.920]  Вот. Это уже такое, да.
[01:06:32.920 --> 01:06:33.920]  Так что вот.
[01:06:34.920 --> 01:06:36.920]  Так что это был ХКРСик.
[01:06:38.920 --> 01:06:40.920]  Так, есть ли тут ещё какие-то вопросы?
[01:06:45.920 --> 01:06:46.920]  Нет.
[01:06:47.920 --> 01:06:48.920]  Так, ну ладно.
[01:06:49.920 --> 01:06:50.920]  Ну, значит, ладно.
[01:06:51.920 --> 01:06:52.920]  К суффиксному массиву мы тогда пока переходить не будем.
[01:06:53.920 --> 01:06:54.920]  Значит, вместо этого так.
[01:06:55.920 --> 01:06:57.920]  Пока у нас перерыв, после которого мы перейдём в Галилу Сейфересу.
[01:06:58.320 --> 01:06:59.320]  Кому?
[01:07:00.320 --> 01:07:01.320]  Что сейферес?
[01:07:02.320 --> 01:07:03.320]  Сейферес.
[01:07:04.320 --> 01:07:05.320]  Вот Галил Сейферес.
[01:07:06.320 --> 01:07:09.320]  Это значит, мы будем искать все вхождения под строки в строку.
[01:07:10.320 --> 01:07:11.320]  Одной под строки в одну строку.
[01:07:12.320 --> 01:07:13.320]  Это один человек или два?
[01:07:14.320 --> 01:07:15.320]  Два.
[01:07:16.320 --> 01:07:17.320]  Вхождения одной под строки в одну строку?
[01:07:18.320 --> 01:07:19.320]  Да.
[01:07:20.320 --> 01:07:21.320]  Но за линию. Времени.
[01:07:22.320 --> 01:07:23.320]  И завод единицы дополнительной памяти.
[01:07:24.320 --> 01:07:25.320]  И без хэшей.
[01:07:25.720 --> 01:07:27.720]  Хэшей нужно дополнительной памяти.
[01:07:30.720 --> 01:07:31.720]  Нет, на самом деле нет.
[01:07:32.720 --> 01:07:35.720]  Если ты ищешь под строку в строке с помощью хэшей, доп-память тебе не нужна.
[01:07:36.720 --> 01:07:39.720]  Потому что хэш всей строки P ты можешь найти без доп-памяти, правда?
[01:07:42.720 --> 01:07:48.720]  А в TXT тебе нужно просто взять все под строки P, длины модуль P и найти у них хэши.
[01:07:49.720 --> 01:07:51.720]  Ты их можешь плавающим окном так аккуратненько находить.
[01:07:52.120 --> 01:07:57.120]  Так что в принципе хэшами это без лишней памяти делается при желании.
[01:07:58.120 --> 01:07:59.120]  Но мы это сделаем без хэшей.
[01:08:00.120 --> 01:08:01.120]  А почему хэшами за линию?
[01:08:02.120 --> 01:08:03.120]  Ну, в смысле, вот мы нашли.
[01:08:04.120 --> 01:08:06.120]  Вот мы поняли, что хэши совпадают.
[01:08:07.120 --> 01:08:12.120]  Нет, ну, в смысле, имейте в виду, это, конечно, в предположении, что мы не верим в коллизии хэшей.
[01:08:13.120 --> 01:08:14.120]  Вот так.
[01:08:15.120 --> 01:08:17.120]  Да, если мы, конечно, перепроверяем коллизии, то, конечно, да, у нас проблемы.
[01:08:17.520 --> 01:08:18.520]  Да.
[01:08:19.520 --> 01:08:20.520]  Вот.
[01:08:20.520 --> 01:08:21.520]  Но в любом случае мы порешаем задачу без хэшей.
[01:08:22.520 --> 01:08:23.520]  Ладно, пока перегрев.
[01:08:24.520 --> 01:08:26.520]  Так, значит, давайте сейчас включаемся.
[01:08:27.520 --> 01:08:29.520]  Да, сейчас будет заведомо неизвестный алгоритм.
[01:08:30.520 --> 01:08:32.520]  Возможно, будет также сложно, как от софт-хиппи.
[01:08:36.520 --> 01:08:40.520]  Ну, скажем так, нет, алгоритм, который сейчас будет иметь место, он не вполне тривиален.
[01:08:41.520 --> 01:08:46.520]  Ну, нет, как показала практика в понедельник, там, видимо, софт-хиппи, то тоже не очень сложно алгоритм на самом деле.
[01:08:47.520 --> 01:08:48.520]  Да.
[01:08:49.520 --> 01:08:50.520]  Ну, да, лайфхак стандартный.
[01:08:51.520 --> 01:08:54.520]  Да, если параллельно не сидеть в телефоне, то любой алгоритм, оказывается, не такой сложный.
[01:08:57.520 --> 01:09:00.520]  А как софт-хиппи же в октябре?
[01:09:01.520 --> 01:09:02.520]  У нас был в ноябре.
[01:09:03.520 --> 01:09:04.520]  Ну, видимо.
[01:09:05.520 --> 01:09:06.520]  Мы уже три лекции пропустили.
[01:09:09.520 --> 01:09:10.520]  Ну, видимо, я не знаю.
[01:09:11.520 --> 01:09:16.520]  Нет, ну, не знаю, видимо, мы как-то быстрее идем, я не знаю, или что-то пропустили.
[01:09:17.520 --> 01:09:18.520]  Я случайно забыл, я не знаю.
[01:09:19.520 --> 01:09:20.520]  Но, не знаю.
[01:09:23.520 --> 01:09:24.520]  Пока хорошо идем.
[01:09:25.520 --> 01:09:30.520]  То есть, мы так, вроде, софт-хиппи уложили, там за два занятия прошли, еще и в качестве довеску успели обсудить ОВЛи краснокердые.
[01:09:33.520 --> 01:09:34.520]  Вот.
[01:09:36.520 --> 01:09:37.520]  Ну, видимо, нет.
[01:09:39.520 --> 01:09:40.520]  Ну, вот так же, не знаю.
[01:09:41.520 --> 01:09:42.520]  Ладно, так же, давайте смотреть.
[01:09:43.520 --> 01:09:44.520]  Значит, что мы делаем?
[01:09:45.520 --> 01:09:46.520]  Значит, задача.
[01:09:47.520 --> 01:09:48.520]  Ну, допустим, ищем.
[01:09:49.520 --> 01:09:53.520]  Значит, под строку P, там, видимо, где-то в тексте T.
[01:09:54.520 --> 01:09:56.520]  Ладно, буквы могут меняться, но по умолчанию это P и T.
[01:09:57.520 --> 01:10:02.520]  Мы хотим найти все вхождения P в тексте T, используя от единицы дополнительной памяти.
[01:10:04.520 --> 01:10:05.520]  В чем, имейте в виду, что...
[01:10:07.520 --> 01:10:10.520]  То есть, имейте в виду что-то типа машины тюринга.
[01:10:11.520 --> 01:10:16.520]  То есть, в том плане, когда мы найдем очередное вхождение, мы там соответствующую чиселку отправляем куда-то в ответ.
[01:10:17.520 --> 01:10:19.520]  Прям отправляем и больше и никогда не пользуемся.
[01:10:20.520 --> 01:10:24.520]  То есть, наша цель от N времени от единицы дополнительной памяти.
[01:10:25.520 --> 01:10:29.520]  Как уже было правильно сказано, в принципе, можно найти все вхождения за от единицы дополнительной памяти за квадрат.
[01:10:31.520 --> 01:10:32.520]  Прям в тупую.
[01:10:34.520 --> 01:10:35.520]  Логично, да?
[01:10:37.520 --> 01:10:38.520]  Ну, за Pt.
[01:10:39.520 --> 01:10:40.520]  Ну, в смысле за Pt, да.
[01:10:41.520 --> 01:10:42.520]  В смысле за Pt.
[01:10:43.520 --> 01:10:44.520]  Вот.
[01:10:45.520 --> 01:10:46.520]  Итак, ну, значит, как же мы будем жить?
[01:10:47.520 --> 01:10:48.520]  Ну, давайте так.
[01:10:49.520 --> 01:10:55.520]  Будем сейчас идти просто аккуратненько по статье, поэтому я сейчас дам некоторое обозначение, определение из нее.
[01:10:56.520 --> 01:10:57.520]  А у тебя номер какая?
[01:10:57.520 --> 01:10:58.520]  Чего?
[01:10:59.520 --> 01:11:00.520]  Почему номер?
[01:11:00.520 --> 01:11:01.520]  Причем тут номер?
[01:11:02.520 --> 01:11:03.520]  Нет, там нет номера.
[01:11:04.520 --> 01:11:05.520]  Да, авторы.
[01:11:06.520 --> 01:11:07.520]  То есть, авторы вот такие.
[01:11:08.520 --> 01:11:09.520]  Вот.
[01:11:09.920 --> 01:11:18.920]  А, это такой каламбур, да?
[01:11:18.920 --> 01:11:19.920]  Ну, понятно, да.
[01:11:20.920 --> 01:11:21.920]  Да, да, да.
[01:11:21.920 --> 01:11:22.920]  Вот, значит, Галил Сейферс.
[01:11:23.920 --> 01:11:24.920]  Вот.
[01:11:25.920 --> 01:11:29.920]  Ну, формально получается так, да.
[01:11:31.920 --> 01:11:32.920]  Да.
[01:11:32.920 --> 01:11:34.920]  То есть, ну, авторы статьи вот такие, да.
[01:11:35.920 --> 01:11:36.920]  Итак.
[01:11:37.320 --> 01:11:38.320]  Так.
[01:11:38.320 --> 01:11:40.320]  Ну, во-первых, первое обозначение.
[01:11:44.320 --> 01:11:45.320]  Во.
[01:11:47.320 --> 01:11:48.320]  Что?
[01:11:49.320 --> 01:11:52.320]  Ну, вот у нас будет такая константа K, которая равна 4.
[01:11:54.320 --> 01:11:55.320]  Вот.
[01:11:56.320 --> 01:11:57.320]  Ну.
[01:12:00.320 --> 01:12:01.320]  Не-не-не-не-не.
[01:12:01.320 --> 01:12:03.320]  Обратной функции кермана там не будет никакой.
[01:12:03.720 --> 01:12:04.720]  Ну, вот.
[01:12:04.720 --> 01:12:05.720]  Ну, скажем так.
[01:12:05.720 --> 01:12:08.880]  Просто будет удобно использовать параметр K, ну, потому что
[01:12:08.880 --> 01:12:11.320]  он будет, ну, это делать для того, чтобы было удобно
[01:12:11.320 --> 01:12:13.880]  понимать, о какой конкретно четверке, в каком конкретном
[01:12:13.880 --> 01:12:14.880]  контексте идет речь.
[01:12:14.880 --> 01:12:16.880]  Так, просто сильно удобнее.
[01:12:16.880 --> 01:12:17.880]  Ну, вот.
[01:12:17.880 --> 01:12:18.880]  Сейферас.
[01:12:18.880 --> 01:12:19.880]  Вот как написано.
[01:12:19.880 --> 01:12:20.880]  Да.
[01:12:20.880 --> 01:12:22.880]  Ну, нет, да.
[01:12:22.880 --> 01:12:27.680]  Да, это два парня, если что, так что, как бы, да.
[01:12:27.680 --> 01:12:30.880]  Хотя, я не знаю, там Зви Галил и кто-то там Сейферас,
[01:12:31.440 --> 01:12:35.120]  так что, может, конечно, и девушки, я не знаю, если
[01:12:35.120 --> 01:12:36.120]  честно, да.
[01:12:36.120 --> 01:12:38.120]  А девушку с фамилией Сейферас?
[01:12:38.120 --> 01:12:39.120]  А что не так?
[01:12:41.120 --> 01:12:42.120]  Что?
[01:12:42.120 --> 01:12:44.120]  Нет, я не пойму, а в чем противоречие, честно?
[01:12:44.120 --> 01:12:46.120]  Что бы ты с ней делал?
[01:12:46.120 --> 01:12:48.120]  Да, что тебе дарит?
[01:12:48.120 --> 01:12:50.120]  В чем проблема девушке иметь фамилию Сейферас?
[01:12:50.120 --> 01:12:52.120]  Может, это не проблема?
[01:12:52.120 --> 01:12:54.120]  Ну, не знаю.
[01:12:54.120 --> 01:12:57.120]  О, господи, что-то у тебя странные ассоциации какие-то,
[01:12:57.120 --> 01:12:58.120]  да, ну.
[01:12:58.360 --> 01:13:00.360]  Вот.
[01:13:03.360 --> 01:13:05.360]  А то так помолчание уже начинаешь думать, а если
[01:13:05.360 --> 01:13:07.360]  у девушки там фамилия Саватеева, напрямую, к чему проблема?
[01:13:07.360 --> 01:13:09.360]  Хы-хы.
[01:13:09.360 --> 01:13:11.360]  И что?
[01:13:11.360 --> 01:13:13.360]  Это все проверяет.
[01:13:13.360 --> 01:13:14.360]  И что?
[01:13:14.360 --> 01:13:16.360]  Зато и там, и там первая буква С, и что?
[01:13:16.360 --> 01:13:18.360]  Садовничий тоже, да.
[01:13:18.360 --> 01:13:19.360]  Ну, вот.
[01:13:19.360 --> 01:13:20.360]  Хы-хы.
[01:13:20.360 --> 01:13:22.360]  У кого круче фамилии?
[01:13:22.360 --> 01:13:26.360]  О, господи, нет, я против того, чтобы вычитать это решать.
[01:13:26.600 --> 01:13:31.600]  Если считать хэш, по модулю 179.57.179.57.101.
[01:13:31.600 --> 01:13:32.600]  И что?
[01:13:32.600 --> 01:13:35.600]  И посмотрите, у кого больше хэш, у того и фамилия круче.
[01:13:35.600 --> 01:13:37.600]  Ничего себе.
[01:13:37.600 --> 01:13:39.600]  Ну, так.
[01:13:39.600 --> 01:13:41.600]  Просто скорее дедушка, чем девушка.
[01:13:41.600 --> 01:13:43.600]  Да?
[01:13:43.600 --> 01:13:45.600]  О, господи.
[01:13:45.600 --> 01:13:47.600]  Господи.
[01:13:47.600 --> 01:13:49.600]  Так, ладно.
[01:13:49.600 --> 01:13:51.600]  Ай.
[01:13:51.600 --> 01:13:53.600]  Ну, это...
[01:13:53.600 --> 01:13:55.600]  Так, значит.
[01:13:55.600 --> 01:13:56.600]  Неадекватно.
[01:13:56.600 --> 01:13:58.600]  Значит, мы будем жить в один адоксации.
[01:13:58.600 --> 01:14:00.600]  Так, ну ладно.
[01:14:00.600 --> 01:14:02.600]  Да, под строку они как-то странно вводят.
[01:14:02.600 --> 01:14:04.600]  Это я вводить не буду.
[01:14:04.600 --> 01:14:05.600]  Так.
[01:14:05.600 --> 01:14:07.600]  Значит, еще.
[01:14:07.600 --> 01:14:09.600]  Значит, тоже.
[01:14:09.600 --> 01:14:11.600]  Определение.
[01:14:11.600 --> 01:14:14.600]  Значит, строка Z является периодом строки S.
[01:14:17.600 --> 01:14:19.600]  Если...
[01:14:19.600 --> 01:14:21.600]  Угадайте, что?
[01:14:21.600 --> 01:14:23.600]  Существует такой х, что...
[01:14:23.600 --> 01:14:25.600]  Существует такой х, что...
[01:14:25.600 --> 01:14:27.600]  Нет, нет, нет.
[01:14:27.600 --> 01:14:29.600]  Если...
[01:14:29.600 --> 01:14:31.600]  Срока S...
[01:14:31.600 --> 01:14:33.600]  Это периодично?
[01:14:33.600 --> 01:14:35.600]  Нет.
[01:14:35.600 --> 01:14:37.600]  Нет, смотрите, у нас будет два определения таких.
[01:14:37.600 --> 01:14:39.600]  Если S...
[01:14:39.600 --> 01:14:41.600]  Это префикс...
[01:14:43.600 --> 01:14:45.600]  Z в бесконечной степени.
[01:14:49.600 --> 01:14:51.600]  Во.
[01:14:53.600 --> 01:14:55.600]  То есть, разница в том, что, конечно же, длина Z
[01:14:55.600 --> 01:14:57.600]  не обязана быть делителем S.
[01:14:59.600 --> 01:15:01.600]  Так вы вводили периодично,
[01:15:01.600 --> 01:15:03.600]  с напрошенным нанятием равно даже.
[01:15:03.600 --> 01:15:05.600]  Или периодично, если
[01:15:05.600 --> 01:15:07.600]  S от I равно S от L плюс I?
[01:15:07.600 --> 01:15:09.600]  Ну, вот да.
[01:15:09.600 --> 01:15:11.600]  Ну, значит, это определение сразу стоит.
[01:15:11.600 --> 01:15:13.600]  То есть, вот так, тут я написал одно из определений, которое прям честно авторы так пишут.
[01:15:13.600 --> 01:15:15.600]  Более того, они на самом деле
[01:15:15.600 --> 01:15:17.600]  вводят их просто целых два определения сразу.
[01:15:17.600 --> 01:15:19.600]  Ну, правда, эквивалентные.
[01:15:19.600 --> 01:15:21.600]  Второе определение звучит так.
[01:15:23.600 --> 01:15:25.600]  Значит, Z
[01:15:25.600 --> 01:15:27.600]  период
[01:15:27.600 --> 01:15:29.600]  S
[01:15:29.600 --> 01:15:31.600]  если
[01:15:31.600 --> 01:15:33.600]  S префикс
[01:15:35.600 --> 01:15:37.600]  ZS.
[01:15:37.600 --> 01:15:39.600]  Ну, да, определение.
[01:15:51.600 --> 01:15:53.600]  Еще они два раза определяют.
[01:15:53.600 --> 01:15:55.600]  Вот. Ну, так, просто
[01:15:55.600 --> 01:15:57.600]  видимо, для лучшего понимания, да, то есть
[01:15:57.600 --> 01:15:59.600]  это, заметим, что эти определения эквиваленты.
[01:15:59.600 --> 01:16:01.600]  Ну, на самом-то деле.
[01:16:01.600 --> 01:16:03.600]  Но, правда, здесь
[01:16:03.600 --> 01:16:05.600]  вот маленькая оговорочка,
[01:16:05.600 --> 01:16:07.600]  которую мы в прошлый раз не использовали.
[01:16:07.600 --> 01:16:09.600]  Оговорочка заключается в том, что
[01:16:09.600 --> 01:16:11.600]  Z вообще по длине может оказаться даже
[01:16:11.600 --> 01:16:13.600]  больше S вполне.
[01:16:13.600 --> 01:16:15.600]  Понятно.
[01:16:15.600 --> 01:16:17.600]  Ну, оба этих определения это спокойно кушают.
[01:16:17.600 --> 01:16:19.600]  Да, у нас она периодично
[01:16:19.600 --> 01:16:21.600]  по строке, а там мы определили
[01:16:21.600 --> 01:16:23.600]  периодично по числу.
[01:16:23.600 --> 01:16:25.600]  Ну, да. Вот.
[01:16:25.600 --> 01:16:27.600]  Ну, здесь тоже аналогичное понятие
[01:16:27.600 --> 01:16:29.600]  будет, будет оно называться shift.
[01:16:29.600 --> 01:16:31.600]  Вот. Ну, об этом позже.
[01:16:31.600 --> 01:16:33.600]  Об этом мы тоже, естественно, напишем.
[01:16:33.600 --> 01:16:35.600]  Вот.
[01:16:35.600 --> 01:16:37.600]  Ну, тут можно пример рассмотреть.
[01:16:37.600 --> 01:16:39.600]  То есть, на самом деле, вот если рассмотреть
[01:16:39.600 --> 01:16:41.600]  там строки,
[01:16:41.600 --> 01:16:43.600]  строки, допустим, ab-ab-ab
[01:16:43.600 --> 01:16:45.600]  и ab-ab-ab. Ну, вот. То, значит,
[01:16:45.600 --> 01:16:47.600]  у строки ab-ab-ab какие периоды есть?
[01:16:49.600 --> 01:16:51.600]  Значит, у строки ab-ab-ab есть
[01:16:51.600 --> 01:16:53.600]  период ab
[01:16:53.600 --> 01:16:55.600]  и, соответственно, еще ab-ab.
[01:16:55.600 --> 01:16:57.600]  А еще ab-ab-aba.
[01:16:57.600 --> 01:16:59.600]  Вот.
[01:16:59.600 --> 01:17:01.600]  Вот.
[01:17:01.600 --> 01:17:03.600]  То есть, вот такой еще
[01:17:03.600 --> 01:17:05.600]  момент есть.
[01:17:05.600 --> 01:17:07.600]  Вот.
[01:17:07.600 --> 01:17:09.600]  Значит, далее.
[01:17:09.600 --> 01:17:11.600]  Что, значит, еще какое понятие
[01:17:11.600 --> 01:17:13.600]  есть?
[01:17:13.600 --> 01:17:15.600]  Значит, еще введем такое даже
[01:17:15.600 --> 01:17:17.600]  обозначение.
[01:17:17.600 --> 01:17:19.600]  Для P меньше либо равного
[01:17:19.600 --> 01:17:21.600]  модуле S
[01:17:21.600 --> 01:17:23.600]  мы введем такое понятие
[01:17:23.600 --> 01:17:25.600]  reach с индексом
[01:17:25.600 --> 01:17:27.600]  S от P.
[01:17:27.600 --> 01:17:29.600]  Которое равно...
[01:17:31.600 --> 01:17:33.600]  Ну, напишу формально.
[01:17:33.600 --> 01:17:35.600]  Напишу формально.
[01:17:35.600 --> 01:17:37.600]  Это максимальному
[01:17:37.600 --> 01:17:39.600]  такому Q
[01:17:39.600 --> 01:17:41.600]  меньше либо
[01:17:41.600 --> 01:17:43.600]  равному, видимо, модуль
[01:17:43.600 --> 01:17:45.600]  S
[01:17:45.600 --> 01:17:47.600]  такому, что
[01:17:47.600 --> 01:17:49.600]  значит
[01:17:49.600 --> 01:17:51.600]  S от 1 до P
[01:17:51.600 --> 01:17:53.600]  это период
[01:17:53.600 --> 01:17:55.600]  S,
[01:17:55.600 --> 01:17:57.600]  1,
[01:17:57.600 --> 01:17:59.600]  Q,
[01:17:59.600 --> 01:18:01.600]  4.
[01:18:05.600 --> 01:18:07.600]  Ну-ка, давай.
[01:18:13.600 --> 01:18:15.600]  Нет.
[01:18:15.600 --> 01:18:17.600]  Нужно брать...
[01:18:17.600 --> 01:18:19.600]  Наверное, нужно брать Q
[01:18:19.600 --> 01:18:21.600]  больше, чем P.
[01:18:21.600 --> 01:18:23.600]  Не обязательно.
[01:18:23.600 --> 01:18:25.600]  Потому что Q
[01:18:25.600 --> 01:18:27.600]  нужно максимально,
[01:18:27.600 --> 01:18:29.600]  потому что Q равно P нам по-любому подходит.
[01:18:29.600 --> 01:18:31.600]  То есть, по сути, следующее.
[01:18:31.600 --> 01:18:33.600]  Если P равно, допустим,
[01:18:33.600 --> 01:18:35.600]  5 и оказалось, что строка
[01:18:35.600 --> 01:18:37.600]  S начинается с, допустим,
[01:18:37.600 --> 01:18:39.600]  ABCDE,
[01:18:39.600 --> 01:18:41.600]  то что такое reach?
[01:18:41.600 --> 01:18:43.600]  Reach, это мы идем по строке S
[01:18:43.600 --> 01:18:45.600]  и смотрим. Вот у нас ABCDE.
[01:18:45.600 --> 01:18:47.600]  И дальше смотрим. Вот она идет
[01:18:47.600 --> 01:18:49.600]  сначала по циклу ABCDE,
[01:18:49.600 --> 01:18:51.600]  ABCX.
[01:18:53.600 --> 01:18:55.600]  И это означает, что reach
[01:18:59.600 --> 01:19:01.600]  от 5 находится вот ровно в этом месте.
[01:19:03.600 --> 01:19:05.600]  И он равен 18.
[01:19:13.600 --> 01:19:15.600]  Вот, понятно?
[01:19:15.600 --> 01:19:17.600]  То есть, вот такая вот красота.
[01:19:21.600 --> 01:19:23.600]  Вот.
[01:19:23.600 --> 01:19:25.600]  То есть, на самом деле, я...
[01:19:25.600 --> 01:19:27.600]  В уже имеющейся у нас терминологии,
[01:19:27.600 --> 01:19:29.600]  я бы, конечно, этот reach мог написать
[01:19:29.600 --> 01:19:31.600]  сильно проще.
[01:19:31.600 --> 01:19:33.600]  Вот каким образом.
[01:19:37.600 --> 01:19:39.600]  Ну, это да.
[01:19:39.600 --> 01:19:41.600]  Да, максимальный префикс P периодичный.
[01:19:41.600 --> 01:19:43.600]  Я бы мог написать это гораздо меньше символов.
[01:19:43.600 --> 01:19:45.600]  Я бы написал, что reach от P
[01:19:45.600 --> 01:19:47.600]  это равно P
[01:19:47.600 --> 01:19:49.600]  плюс Z функция
[01:19:49.600 --> 01:19:51.600]  от P плюс 1.
[01:19:55.600 --> 01:19:57.600]  Где коллизия?
[01:19:57.600 --> 01:19:59.600]  Где Z?
[01:19:59.600 --> 01:20:01.600]  Сверху.
[01:20:01.600 --> 01:20:03.600]  А, ну там Z-строчка, а тут Z-Z-функция.
[01:20:03.600 --> 01:20:05.600]  Да, проблема.
[01:20:05.600 --> 01:20:07.600]  Вот.
[01:20:09.600 --> 01:20:11.600]  Да.
[01:20:11.600 --> 01:20:13.600]  Не то чтобы спасать, но...
[01:20:13.600 --> 01:20:15.600]  Не, ну я могу тут, конечно,
[01:20:15.600 --> 01:20:17.600]  игрок написать.
[01:20:17.600 --> 01:20:19.600]  Но это не...
[01:20:19.600 --> 01:20:21.600]  На самом деле, это как бы принципиально
[01:20:21.600 --> 01:20:23.600]  погоды, я думаю, делать не должно.
[01:20:23.600 --> 01:20:25.600]  Бум-бум-бум-бум-бум.
[01:20:35.600 --> 01:20:37.600]  Во.
[01:20:37.600 --> 01:20:39.600]  Вот.
[01:20:39.600 --> 01:20:41.600]  Ну да, тут, конечно, с игроками, да,
[01:20:41.600 --> 01:20:43.600]  идеально было бы P плюс ZP, но у нас
[01:20:43.600 --> 01:20:45.600]  один индексация, напоминаю.
[01:20:45.600 --> 01:20:47.600]  Вот. Так это вот понятно,
[01:20:47.600 --> 01:20:49.600]  откуда я беру, да?
[01:20:49.600 --> 01:20:51.600]  Вот. То есть просто вот идентично.
[01:20:51.600 --> 01:20:53.600]  Так.
[01:20:53.600 --> 01:20:55.600]  Давайте, как еще? Значит, дальше сейчас
[01:20:55.600 --> 01:20:57.600]  начнутся еще веселые определения.
[01:20:57.600 --> 01:20:59.600]  Значит, смотрите внимательно.
[01:20:59.600 --> 01:21:01.600]  Значит, определение.
[01:21:01.600 --> 01:21:03.600]  Просто
[01:21:03.600 --> 01:21:05.600]  выводится куча определений, потом
[01:21:05.600 --> 01:21:07.600]  старый с алгоритмом такой, ну он работает
[01:21:07.600 --> 01:21:09.600]  и докажется.
[01:21:09.600 --> 01:21:11.600]  Если бы.
[01:21:11.600 --> 01:21:13.600]  Нет, ну до него придется еще доходить.
[01:21:13.600 --> 01:21:15.600]  Не будет работать.
[01:21:17.600 --> 01:21:19.600]  Чего это не будет работать?
[01:21:23.600 --> 01:21:25.600]  Ага. Да.
[01:21:25.600 --> 01:21:27.600]  Вот это вот.
[01:21:27.600 --> 01:21:29.600]  Какие вопросы.
[01:21:31.600 --> 01:21:33.600]  Чего это?
[01:21:33.600 --> 01:21:35.600]  Итак. Значит, говорим.
[01:21:35.600 --> 01:21:37.600]  Будем называть строку S, вот сейчас появится не тривиальное определение.
[01:21:37.600 --> 01:21:39.600]  Базовая.
[01:21:41.600 --> 01:21:43.600]  Еще одна база.
[01:21:43.600 --> 01:21:45.600]  Да.
[01:21:45.600 --> 01:21:47.600]  Если
[01:21:47.600 --> 01:21:49.600]  не существует
[01:21:49.600 --> 01:21:51.600]  такой строки, ну хорошо-хорошо,
[01:21:51.600 --> 01:21:53.600]  Y
[01:21:53.600 --> 01:21:55.600]  и такого
[01:21:55.600 --> 01:21:57.600]  числа
[01:21:57.600 --> 01:21:59.600]  к
[01:21:59.600 --> 01:22:01.600]  и больше единицы,
[01:22:01.600 --> 01:22:03.600]  ну да, можно и, у нас тут нет комплексных чисел,
[01:22:03.600 --> 01:22:05.600]  что S
[01:22:05.600 --> 01:22:07.600]  равно Y
[01:22:07.600 --> 01:22:09.600]  записанной и раз.
[01:22:11.600 --> 01:22:13.600]  Что, что такое это звездочка?
[01:22:13.600 --> 01:22:15.600]  Альфа звездочка.
[01:22:15.600 --> 01:22:17.600]  Алфавит.
[01:22:17.600 --> 01:22:19.600]  Это то, что у нас сигназ
[01:22:19.600 --> 01:22:21.600]  ну алфавит у нас
[01:22:21.600 --> 01:22:23.600]  альфа.
[01:22:23.600 --> 01:22:25.600]  Вот давайте тут напишем.
[01:22:25.600 --> 01:22:27.600]  Альфа, алфа.
[01:22:27.600 --> 01:22:29.600]  То есть если просто S, не периодическая.
[01:22:29.600 --> 01:22:31.600]  Нет, нет, нет, это не совсем так.
[01:22:31.600 --> 01:22:33.600]  Вот строка, обратите внимание, строка
[01:22:33.600 --> 01:22:35.600]  АБАБАБА периодическая не является.
[01:22:35.600 --> 01:22:37.600]  Базовой является.
[01:22:37.600 --> 01:22:39.600]  А строка
[01:22:39.600 --> 01:22:41.600]  АБАБАБ базовой не является.
[01:22:41.600 --> 01:22:43.600]  Потому что ее можно распилить на три экземпляра АБАБА.
[01:22:43.600 --> 01:22:45.600]  Не нормальная периодическая.
[01:22:45.600 --> 01:22:47.600]  Ну, так.
[01:22:47.600 --> 01:22:49.600]  Нет, вот так. Вот аккуратно.
[01:22:49.600 --> 01:22:51.600]  Нормально периодическая.
[01:22:51.600 --> 01:22:53.600]  Потому что да.
[01:22:53.600 --> 01:22:55.600]  То есть мы как бы не путать.
[01:22:55.600 --> 01:22:57.600]  То есть строка, то есть у строки
[01:22:57.600 --> 01:22:59.600]  АБАБАБ и АБАБАБА
[01:22:59.600 --> 01:23:01.600]  обе имеют период 2,
[01:23:01.600 --> 01:23:03.600]  ну один из периодов.
[01:23:03.600 --> 01:23:05.600]  Но при этом
[01:23:05.600 --> 01:23:07.600]  АБАБАБ
[01:23:07.600 --> 01:23:09.600]  не является базовой строкой,
[01:23:09.600 --> 01:23:11.600]  а АБАБАБА является. Это для нас будет
[01:23:11.600 --> 01:23:13.600]  принципиально.
[01:23:13.600 --> 01:23:15.600]  Вот.
[01:23:15.600 --> 01:23:17.600]  Так.
[01:23:17.600 --> 01:23:19.600]  Ну, это еще пока смахивает на общее.
[01:23:19.600 --> 01:23:21.600]  Так, вот сейчас будет прям ключевое
[01:23:21.600 --> 01:23:23.600]  определение.
[01:23:23.600 --> 01:23:25.600]  Да, вот вы прям записывайте, потому что мы
[01:23:25.600 --> 01:23:27.600]  потом всеми этими определениями как начнем
[01:23:27.600 --> 01:23:29.600]  пользоваться.
[01:23:29.600 --> 01:23:31.600]  Определение.
[01:23:31.600 --> 01:23:33.600]  Значит,
[01:23:33.600 --> 01:23:35.600]  Т.
[01:23:35.600 --> 01:23:37.600]  Префиксный период С.
[01:23:41.600 --> 01:23:43.600]  Внимание.
[01:23:43.600 --> 01:23:45.600]  Префиксный период С.
[01:23:45.600 --> 01:23:47.600]  Вот это прям
[01:23:47.600 --> 01:23:49.600]  вот определение имеет отношение именно только
[01:23:49.600 --> 01:23:51.600]  к этой статье, конечно.
[01:23:51.600 --> 01:23:53.600]  Потому что все предыдущие, то есть в остальной терминологии
[01:23:53.600 --> 01:23:55.600]  в принципе можно мыслить в целом
[01:23:55.600 --> 01:23:57.600]  в теории строки. Вот префиксный период возникает
[01:23:57.600 --> 01:23:59.600]  именно прям здесь.
[01:23:59.600 --> 01:24:01.600]  Значит, префиксный период С.
[01:24:01.600 --> 01:24:03.600]  Если, внимание.
[01:24:03.600 --> 01:24:05.600]  Т.
[01:24:05.600 --> 01:24:07.600]  Базовая.
[01:24:11.600 --> 01:24:13.600]  Если Т. Базовая.
[01:24:13.600 --> 01:24:15.600]  И.
[01:24:15.600 --> 01:24:17.600]  Т.
[01:24:17.600 --> 01:24:19.600]  В степени К.
[01:24:19.600 --> 01:24:21.600]  Да, вот то само ЕК.
[01:24:21.600 --> 01:24:23.600]  Это не коллизия, а именно вот.
[01:24:23.600 --> 01:24:25.600]  Это префикс С.
[01:24:25.600 --> 01:24:27.600]  Вон то.
[01:24:27.600 --> 01:24:29.600]  Который 4.
[01:24:33.600 --> 01:24:35.600]  Вы-то чего
[01:24:35.600 --> 01:24:37.600]  уже говорили, что мы вводим константу К,
[01:24:37.600 --> 01:24:39.600]  которая у нас будет равна 4.
[01:24:39.600 --> 01:24:41.600]  Там было
[01:24:41.600 --> 01:24:43.600]  чего уровня easy
[01:24:43.600 --> 01:24:45.600]  и чего уровня medium?
[01:24:45.600 --> 01:24:47.600]  Так,
[01:24:47.600 --> 01:24:49.600]  это я
[01:24:49.600 --> 01:24:51.600]  тупнячок.
[01:24:51.600 --> 01:24:53.600]  Я просто начал писать префикс
[01:24:53.600 --> 01:24:55.600]  и не смог остановиться на автомате.
[01:24:55.600 --> 01:24:57.600]  А почему тут слово
[01:24:57.600 --> 01:24:59.600]  период?
[01:24:59.600 --> 01:25:01.600]  Не знаю.
[01:25:01.600 --> 01:25:03.600]  Вот тут я говорю, вот
[01:25:03.600 --> 01:25:05.600]  девушка с дедушкой
[01:25:05.600 --> 01:25:07.600]  сказали, вот мы и думаем.
[01:25:07.600 --> 01:25:09.600]  Они это так назвали, я не знаю.
[01:25:09.600 --> 01:25:11.600]  Я не знаю,
[01:25:11.600 --> 01:25:13.600]  я не знаю,
[01:25:13.600 --> 01:25:15.600]  Питерским гамбургером.
[01:25:15.600 --> 01:25:17.600]  Т. является Питерским гамбургером С.
[01:25:17.600 --> 01:25:19.600]  Или там
[01:25:19.600 --> 01:25:21.600]  четырехслойным
[01:25:21.600 --> 01:25:23.600]  гамбургером С, если
[01:25:23.600 --> 01:25:25.600]  соответственно.
[01:25:25.600 --> 01:25:27.600]  Пожалуйста.
[01:25:27.600 --> 01:25:29.600]  Вот они назвали префиксный период почему-то.
[01:25:33.600 --> 01:25:35.600]  Да, причем обратите внимание
[01:25:35.600 --> 01:25:37.600]  у этого определения важная
[01:25:37.600 --> 01:25:39.600]  приятная вещь, что
[01:25:39.600 --> 01:25:41.600]  периодом всей строки С
[01:25:41.600 --> 01:25:43.600]  Т быть не обязана от слова совсем.
[01:25:43.600 --> 01:25:45.600]  Т в степени какая-то префикс?
[01:25:45.600 --> 01:25:47.600]  Да.
[01:25:47.600 --> 01:25:49.600]  То есть Т не обязана быть
[01:25:49.600 --> 01:25:51.600]  префиксом С, боже упаси.
[01:25:53.600 --> 01:25:55.600]  Т не обязаны быть
[01:25:55.600 --> 01:25:57.600]  префиксом С.
[01:25:59.600 --> 01:26:01.600]  Эквивалентное
[01:26:01.600 --> 01:26:03.600]  определение.
[01:26:03.600 --> 01:26:05.600]  Еще определение
[01:26:05.600 --> 01:26:07.600]  два.
[01:26:07.600 --> 01:26:09.600]  Значит Т
[01:26:09.600 --> 01:26:11.600]  префиксный период Ф.
[01:26:11.600 --> 01:26:13.600]  Хочется написать преф период,
[01:26:13.600 --> 01:26:15.600]  но как бы сейчас
[01:26:15.600 --> 01:26:17.600]  кто-то начнет ругаться словами типа преферанс.
[01:26:17.600 --> 01:26:19.600]  Вы там
[01:26:19.600 --> 01:26:21.600]  в преферансы не играете?
[01:26:21.600 --> 01:26:23.600]  Неским.
[01:26:25.600 --> 01:26:27.600]  Префиксный период С.
[01:26:27.600 --> 01:26:29.600]  Если
[01:26:29.600 --> 01:26:31.600]  ну можно вот еще
[01:26:31.600 --> 01:26:33.600]  вот так написать.
[01:26:33.600 --> 01:26:35.600]  Если reach
[01:26:35.600 --> 01:26:37.600]  с индексом С
[01:26:41.600 --> 01:26:43.600]  от модуль Т
[01:26:45.600 --> 01:26:47.600]  больше либо равно
[01:26:47.600 --> 01:26:49.600]  к модуль Т
[01:26:51.600 --> 01:26:53.600]  ну тут придется еще написать,
[01:26:53.600 --> 01:26:55.600]  что Т базовая
[01:26:57.600 --> 01:26:59.600]  и конечно же Т
[01:26:59.600 --> 01:27:01.600]  префикс С.
[01:27:03.600 --> 01:27:05.600]  Вот так.
[01:27:05.600 --> 01:27:07.600]  Можно еще вот так.
[01:27:07.600 --> 01:27:09.600]  Ну здесь как бы думаю там все
[01:27:09.600 --> 01:27:11.600]  очевидно, то есть так скорее
[01:27:11.600 --> 01:27:13.600]  как бы там
[01:27:13.600 --> 01:27:15.600]  более удобно пользоваться.
[01:27:15.600 --> 01:27:17.600]  Речь от Т?
[01:27:17.600 --> 01:27:19.600]  От модуль Т, да.
[01:27:19.600 --> 01:27:21.600]  Речь.
[01:27:23.600 --> 01:27:25.600]  Стоп.
[01:27:25.600 --> 01:27:27.600]  Мы же
[01:27:27.600 --> 01:27:29.600]  речи
[01:27:29.600 --> 01:27:31.600]  определения для префикса С.
[01:27:31.600 --> 01:27:33.600]  Ну вот я и описываю, что Т префикс С.
[01:27:33.600 --> 01:27:35.600]  Вот именно поэтому
[01:27:35.600 --> 01:27:37.600]  это вот тут и прописывает.
[01:27:37.600 --> 01:27:39.600]  То есть Т префикс С
[01:27:39.600 --> 01:27:41.600]  естественно базовая
[01:27:41.600 --> 01:27:43.600]  и reach от этого префикса оказывается
[01:27:43.600 --> 01:27:45.600]  больше либо равен к К на длину этого префикса.
[01:27:45.600 --> 01:27:47.600]  Вот.
[01:27:47.600 --> 01:27:49.600]  То есть можно говорить,
[01:27:49.600 --> 01:27:51.600]  что даже не Т префиксный период С,
[01:27:51.600 --> 01:27:53.600]  а П префиксный период С, где П это уже чиселка.
[01:27:53.600 --> 01:27:55.600]  А не строка.
[01:27:55.600 --> 01:27:57.600]  В общем суть. То есть возможно нам придется
[01:27:57.600 --> 01:27:59.600]  этот период там шаманивать, но суть
[01:27:59.600 --> 01:28:01.600]  вот такая.
[01:28:01.600 --> 01:28:03.600]  Так что вот на этом понятии префиксного
[01:28:03.600 --> 01:28:05.600]  периода мы тут и будем жить.
[01:28:05.600 --> 01:28:07.600]  Чего?
[01:28:07.600 --> 01:28:09.600]  Да, вот так. А это они говорят, да, вот мы
[01:28:09.600 --> 01:28:11.600]  введем константу К, которая будет равна 4.
[01:28:11.600 --> 01:28:13.600]  Если вам не нравится вводить константу 7,
[01:28:13.600 --> 01:28:15.600]  тоже в принципе будет работать.
[01:28:15.600 --> 01:28:17.600]  В принципе кстати.
[01:28:17.600 --> 01:28:19.600]  Ну как всегда,
[01:28:19.600 --> 01:28:21.600]  тут как в алгоритме
[01:28:21.600 --> 01:28:23.600]  этих вот это,
[01:28:23.600 --> 01:28:25.600]  Блюма, Флойда, Пратта и компании.
[01:28:25.600 --> 01:28:27.600]  То есть тоже мы там делим
[01:28:27.600 --> 01:28:29.600]  строчку на пятерке, хотя в принципе могли бы и на семерке,
[01:28:29.600 --> 01:28:31.600]  и на девятке, и там на
[01:28:31.600 --> 01:28:33.600]  пятидесяти семерке тоже бы работало.
[01:28:33.600 --> 01:28:35.600]  Трой, потому что константа
[01:28:35.600 --> 01:28:37.600]  там не очень тогда будет.
[01:28:37.600 --> 01:28:39.600]  Вот.
[01:28:39.600 --> 01:28:41.600]  Ну да, то есть будет это что-то.
[01:28:41.600 --> 01:28:43.600]  То есть константа не очень.
[01:28:43.600 --> 01:28:45.600]  Как это? Я умею печатать слов там
[01:28:45.600 --> 01:28:47.600]  257 символов в минуту.
[01:28:47.600 --> 01:28:49.600]  Да, да. Ну правда такая безобразная
[01:28:49.600 --> 01:28:51.600]  такая фигня получается.
[01:28:51.600 --> 01:28:53.600]  Вот.
[01:28:53.600 --> 01:28:55.600]  Обыкновение какой-то, правда,
[01:28:55.600 --> 01:28:57.600]  да.
[01:29:07.600 --> 01:29:09.600]  Да, это как искать катовую порядковую
[01:29:09.600 --> 01:29:11.600]  статистику за линию без рандома.
[01:29:15.600 --> 01:29:17.600]  Нет.
[01:29:17.600 --> 01:29:19.600]  Если выбрать константу 7, 9, 11
[01:29:19.600 --> 01:29:21.600]  или больше, то будет нормально.
[01:29:21.600 --> 01:29:23.600]  Если выбрать 3, то получается аналогия.
[01:29:23.600 --> 01:29:25.600]  Ну или, по крайней мере, там
[01:29:25.600 --> 01:29:27.600]  надо сильнее думать, чтобы
[01:29:27.600 --> 01:29:29.600]  доказывать, что это линия.
[01:29:29.600 --> 01:29:31.600]  Потому что это тоже самое рассуждение.
[01:29:31.600 --> 01:29:33.600]  Если брать чисто то же рассуждение,
[01:29:33.600 --> 01:29:35.600]  там можно показать, что у решения этой рекуррента
[01:29:35.600 --> 01:29:37.600]  это аналогия. Так что вот.
[01:29:37.600 --> 01:29:39.600]  Так. Значит, это я все
[01:29:39.600 --> 01:29:41.600]  написал. Это вы все написали.
[01:29:41.600 --> 01:29:43.600]  Это я все стер. Вы, пожалуйста, это
[01:29:43.600 --> 01:29:45.600]  не стирайте.
[01:29:45.600 --> 01:29:47.600]  Вот.
[01:29:47.600 --> 01:29:49.600]  А то да.
[01:29:49.600 --> 01:29:51.600]  Как это когда-то прозвучала бы как смешная шутка,
[01:29:51.600 --> 01:29:53.600]  и у вас есть возможность это все стереть теперь.
[01:30:01.600 --> 01:30:03.600]  Слушайте, я сегодня
[01:30:03.600 --> 01:30:05.600]  такие сложные шутки говорю, да?
[01:30:07.600 --> 01:30:09.600]  Нет, я понимаю, что
[01:30:09.600 --> 01:30:11.600]  на втором курсе все, особенно на втором курсе,
[01:30:11.600 --> 01:30:13.600]  приходят в этот стейк, когда задаешь вопросы,
[01:30:13.600 --> 01:30:15.600]  что?
[01:30:15.600 --> 01:30:17.600]  Я не понял, как это стереть можно.
[01:30:17.600 --> 01:30:19.600]  Что можно стереть?
[01:30:19.600 --> 01:30:21.600]  Дважды два.
[01:30:23.600 --> 01:30:25.600]  Ну мало ли.
[01:30:45.600 --> 01:30:47.600]  Вот. Так вот.
[01:30:47.600 --> 01:30:49.600]  Ну давайте попробуем.
[01:30:49.600 --> 01:30:51.600]  На чисто ответственность.
[01:30:51.600 --> 01:30:53.600]  Так.
[01:30:53.600 --> 01:30:55.600]  Ну, конечно, там одной из простеретических
[01:30:55.600 --> 01:30:57.600]  основ.
[01:30:57.600 --> 01:30:59.600]  Этим алгоритмом является знаменитая
[01:30:59.600 --> 01:31:01.600]  лемма о периодичности.
[01:31:17.600 --> 01:31:19.600]  Значит, я ее буду говорить так.
[01:31:19.600 --> 01:31:21.600]  Если строка S.
[01:31:23.600 --> 01:31:25.600]  Значит, P1 периодично.
[01:31:31.600 --> 01:31:33.600]  И P2 периодично.
[01:31:39.600 --> 01:31:41.600]  Ну, я буду говорить, что строка S
[01:31:41.600 --> 01:31:43.600]  P периодично, если префикс длины P
[01:31:43.600 --> 01:31:45.600]  является периодом строки S.
[01:31:47.600 --> 01:31:49.600]  Так, что? Опять черная магия?
[01:31:53.600 --> 01:31:55.600]  Чего? Что?
[01:31:55.600 --> 01:31:57.600]  Так, что из этого ты где не знаешь?
[01:32:05.600 --> 01:32:07.600]  Нет, есть вероятность такой, что я не просто слышал,
[01:32:07.600 --> 01:32:09.600]  потому что ты ее даже придумывал. Так.
[01:32:11.600 --> 01:32:13.600]  Значит, пусть у нас строка S
[01:32:13.600 --> 01:32:15.600]  периодично, а также
[01:32:17.600 --> 01:32:19.600]  верно еще, что модуль S
[01:32:19.600 --> 01:32:21.600]  больше либо равен, чем P1
[01:32:21.600 --> 01:32:23.600]  плюс P2,
[01:32:25.600 --> 01:32:27.600]  то тогда я утверждаю,
[01:32:27.600 --> 01:32:29.600]  что S
[01:32:29.600 --> 01:32:31.600]  нод P1
[01:32:31.600 --> 01:32:33.600]  P2 периодично.
[01:32:41.600 --> 01:32:43.600]  То есть вот такая вот лемма.
[01:32:47.600 --> 01:32:49.600]  Ну, спрашивается, откуда я ее взял?
[01:32:51.600 --> 01:32:53.600]  Ну, по большому счету,
[01:32:53.600 --> 01:32:55.600]  надо доказать, что вот в этой ситуации
[01:32:55.600 --> 01:32:57.600]  надо просто доказать, что S
[01:32:57.600 --> 01:32:59.600]  модуль P2 минус P1 периодично.
[01:33:05.600 --> 01:33:07.600]  Ну, потому что если мы это докажем, то дальше
[01:33:07.600 --> 01:33:09.600]  в дело тупо вступит алгоритм Евклида.
[01:33:11.600 --> 01:33:13.600]  Но как же доказать, что у нас строка S
[01:33:13.600 --> 01:33:15.600]  P2 минус P1 периодично?
[01:33:15.600 --> 01:33:17.600]  Ну, положим без ограничений обществе, что P2
[01:33:17.600 --> 01:33:19.600]  больше, чем P1.
[01:33:19.600 --> 01:33:21.600]  Ну, что значит у нас строка P2 периодично?
[01:33:23.600 --> 01:33:25.600]  В принципе, это означает, что любые
[01:33:25.600 --> 01:33:27.600]  два символа на расстоянии P2
[01:33:27.600 --> 01:33:29.600]  они равны.
[01:33:31.600 --> 01:33:33.600]  И любые два символа на расстоянии
[01:33:33.600 --> 01:33:35.600]  P1 равны.
[01:33:37.600 --> 01:33:39.600]  Но тогда я утверждаю, отсюда надо просто вывести,
[01:33:39.600 --> 01:33:41.600]  что любые два символа
[01:33:41.600 --> 01:33:43.600]  на расстоянии P2 минус P1
[01:33:43.600 --> 01:33:45.600]  уже равны. Как я это сделаю?
[01:33:45.600 --> 01:33:47.600]  Очень просто. Чтобы скакнуть на P2 минус P1
[01:33:47.600 --> 01:33:49.600]  я должен скакнуть на P2
[01:33:49.600 --> 01:33:51.600]  в одну сторону и потом вернуться
[01:33:51.600 --> 01:33:53.600]  на P1.
[01:33:59.600 --> 01:34:01.600]  Да, мы так можем делать не всегда,
[01:34:01.600 --> 01:34:03.600]  потому что может так случиться,
[01:34:03.600 --> 01:34:05.600]  что справа у меня
[01:34:05.600 --> 01:34:07.600]  нет P2 символов, хотя вот если там
[01:34:07.600 --> 01:34:09.600]  P2 символов есть, то я так скакнуть
[01:34:09.600 --> 01:34:11.600]  могу. Логично, да?
[01:34:11.600 --> 01:34:13.600]  Что я еще могу сделать?
[01:34:13.600 --> 01:34:15.600]  Второй вариант.
[01:34:15.600 --> 01:34:17.600]  Я еще могу скакнуть
[01:34:17.600 --> 01:34:19.600]  на самом деле на P2,
[01:34:19.600 --> 01:34:21.600]  то есть на самом деле на P1
[01:34:21.600 --> 01:34:23.600]  могу скакнуть вот сюда, а потом
[01:34:23.600 --> 01:34:25.600]  на P2 вот сюда. Я еще вот так могу сделать.
[01:34:29.600 --> 01:34:31.600]  То есть если я смогу сделать или так,
[01:34:31.600 --> 01:34:33.600]  то тогда эти два символа очевидно равны.
[01:34:33.600 --> 01:34:35.600]  Возникает естественный вопрос.
[01:34:37.600 --> 01:34:39.600]  Какой?
[01:34:39.600 --> 01:34:41.600]  А что делать, если я
[01:34:41.600 --> 01:34:43.600]  не смогу так сделать
[01:34:43.600 --> 01:34:45.600]  ни туда, ни туда?
[01:34:45.600 --> 01:34:47.600]  Да, но такого у нас
[01:34:47.600 --> 01:34:49.600]  не бывает. Почему? Потому что тогда мы вынуждены
[01:34:49.600 --> 01:34:51.600]  заключить, что здесь
[01:34:51.600 --> 01:34:53.600]  справа от... То есть как бы вот есть
[01:34:53.600 --> 01:34:55.600]  вот этот вот х, вот этот, и тогда получается
[01:34:55.600 --> 01:34:57.600]  здесь меньше, чем
[01:34:57.600 --> 01:34:59.600]  P2 символов, и здесь меньше,
[01:34:59.600 --> 01:35:01.600]  чем P1. И тогда в сумме их
[01:35:01.600 --> 01:35:03.600]  получается меньше, чем P1
[01:35:05.600 --> 01:35:07.600]  там меньше либо равно, чем P1
[01:35:07.600 --> 01:35:09.600]  плюс
[01:35:09.600 --> 01:35:11.600]  P2 минус 1 плюс
[01:35:11.600 --> 01:35:13.600]  1. Понятно, да?
[01:35:15.600 --> 01:35:17.600]  Вот.
[01:35:17.600 --> 01:35:19.600]  То есть получается...
[01:35:19.600 --> 01:35:21.600]  То есть именно поэтому мы тут и требовали,
[01:35:21.600 --> 01:35:23.600]  чтобы у нас длина была такая.
[01:35:23.600 --> 01:35:25.600]  Вот. Соответственно.
[01:35:29.600 --> 01:35:31.600]  Так что получается
[01:35:31.600 --> 01:35:33.600]  так.
[01:35:33.600 --> 01:35:35.600]  Хотя с другой стороны
[01:35:35.600 --> 01:35:37.600]  сейчас тут надо почистаться, потому что
[01:35:37.600 --> 01:35:39.600]  вообще... То есть вообще
[01:35:39.600 --> 01:35:41.600]  при желании как-то выясняется, что
[01:35:41.600 --> 01:35:43.600]  на самом деле, если тут я напишу P1
[01:35:43.600 --> 01:35:45.600]  плюс P2 минус 1, то это утверждение
[01:35:45.600 --> 01:35:47.600]  вроде как тоже работает.
[01:35:51.600 --> 01:35:53.600]  Что?
[01:35:53.600 --> 01:35:55.600]  Кстати, P1 плюс P2 минус 1?
[01:35:55.600 --> 01:35:57.600]  Да.
[01:35:57.600 --> 01:35:59.600]  Ну, в такой формулировке
[01:35:59.600 --> 01:36:01.600]  леммы нет, но просто теперь возникает вопрос,
[01:36:01.600 --> 01:36:03.600]  а нельзя ли ее усилить?
[01:36:03.600 --> 01:36:05.600]  Ну типа, вот у вас снизу
[01:36:05.600 --> 01:36:07.600]  оценка точная.
[01:36:07.600 --> 01:36:09.600]  Да, но это точная оценка. Это P1 плюс P2 минус 1.
[01:36:11.600 --> 01:36:13.600]  И получается... Нет, а как я еще тут
[01:36:13.600 --> 01:36:15.600]  это усилю? То есть я вот... Я вот это
[01:36:15.600 --> 01:36:17.600]  доказательство не могу провернуть, когда у меня
[01:36:17.600 --> 01:36:19.600]  тут меньше, чем P... То есть когда у меня тут
[01:36:19.600 --> 01:36:21.600]  P минус 1 и тут P2
[01:36:21.600 --> 01:36:23.600]  минус 1.
[01:36:23.600 --> 01:36:25.600]  И получается... Ну вот. То есть это означает,
[01:36:25.600 --> 01:36:27.600]  что получается для
[01:36:27.600 --> 01:36:29.600]  P2... То есть получается
[01:36:29.600 --> 01:36:31.600]  следующее, что для строки длины
[01:36:31.600 --> 01:36:33.600]  P1 плюс P2 минус 1, по крайней мере такое доказательство
[01:36:33.600 --> 01:36:35.600]  я провернуть не могу.
[01:36:35.600 --> 01:36:37.600]  Ну да.
[01:36:37.600 --> 01:36:39.600]  Вот. Ну вот, внимание, вопрос.
[01:36:39.600 --> 01:36:41.600]  А почему я не могу? То есть это как бы...
[01:36:41.600 --> 01:36:43.600]  То есть это скажешь так, теперь она действительно не верна?
[01:36:43.600 --> 01:36:45.600]  При такой длине? Или...
[01:36:45.600 --> 01:36:47.600]  Или у меня просто доказательство слабое?
[01:36:51.600 --> 01:36:53.600]  Вот как вы думаете?
[01:36:53.600 --> 01:36:55.600]  Я думаю, что не верна.
[01:37:01.600 --> 01:37:03.600]  Так.
[01:37:17.600 --> 01:37:19.600]  Сейчас, а в чем фокус?
[01:37:19.600 --> 01:37:21.600]  В вернали это ляма,
[01:37:21.600 --> 01:37:23.600]  если заменить P1 плюс P2 на P1 плюс P2
[01:37:23.600 --> 01:37:25.600]  минус 1? Да.
[01:37:25.600 --> 01:37:27.600]  А зачем нам это?
[01:37:27.600 --> 01:37:29.600]  Ну вот, а вот...
[01:37:29.600 --> 01:37:31.600]  Это называется интересно.
[01:37:41.600 --> 01:37:43.600]  Ломается.
[01:37:43.600 --> 01:37:45.600]  То-то и прикол, смотри. Допустим, у меня строка длины
[01:37:45.600 --> 01:37:47.600]  P1 плюс P2 минус 1.
[01:37:47.600 --> 01:37:49.600]  То есть у меня есть вот тут символ X.
[01:37:49.600 --> 01:37:51.600]  И допустим, тут P1 с его участием,
[01:37:51.600 --> 01:37:53.600]  и тут ровно P2 с его участием.
[01:37:53.600 --> 01:37:55.600]  Тогда получается, я ни сюда не могу
[01:37:55.600 --> 01:37:57.600]  скакнуть на P1, ни сюда не могу.
[01:37:57.600 --> 01:37:59.600]  Я не понимаю, в чем проблема. Давайте возьмем строку
[01:37:59.600 --> 01:38:01.600]  ABABAX.
[01:38:03.600 --> 01:38:05.600]  Чего? ABABAX.
[01:38:05.600 --> 01:38:07.600]  Нет, ABABAX.
[01:38:07.600 --> 01:38:09.600]  ABABAX. И что?
[01:38:09.600 --> 01:38:11.600]  Это строка...
[01:38:11.600 --> 01:38:13.600]  Она не четыре периодичные, пять периодичные.
[01:38:13.600 --> 01:38:15.600]  Нет, она не четыре периодичные, ни черта.
[01:38:15.600 --> 01:38:17.600]  Потому что X.
[01:38:19.600 --> 01:38:21.600]  Сейчас у нас один проблемный символ,
[01:38:21.600 --> 01:38:23.600]  с которым мы никуда не можем
[01:38:23.600 --> 01:38:25.600]  скакнуть. Да.
[01:38:25.600 --> 01:38:27.600]  Ни с кем вообще не связан
[01:38:27.600 --> 01:38:29.600]  никакие ограничения?
[01:38:31.600 --> 01:38:33.600]  В ноте он же будет.
[01:38:33.600 --> 01:38:35.600]  Нет, он кое-каким ограничениям он связан.
[01:38:35.600 --> 01:38:37.600]  Потому что смотри.
[01:38:37.600 --> 01:38:39.600]  Потому что мы можем пройти вот так,
[01:38:39.600 --> 01:38:41.600]  пусть P1 меньше,
[01:38:41.600 --> 01:38:43.600]  тогда я могу пройти на P1 вперед,
[01:38:43.600 --> 01:38:45.600]  и у меня тут X будут.
[01:38:45.600 --> 01:38:47.600]  Более того,
[01:38:47.600 --> 01:38:49.600]  я могу
[01:38:49.600 --> 01:38:51.600]  этот X еще
[01:38:51.600 --> 01:38:53.600]  сдвинуть на P2.
[01:38:53.600 --> 01:38:55.600]  Вот. То есть это у меня
[01:38:55.600 --> 01:38:57.600]  P2,
[01:38:57.600 --> 01:38:59.600]  и тогда у меня получается
[01:38:59.600 --> 01:39:01.600]  еще тут X. Но тут
[01:39:01.600 --> 01:39:03.600]  X, он порождает вот тут X и тут
[01:39:03.600 --> 01:39:05.600]  X. Видно, да?
[01:39:09.600 --> 01:39:11.600]  Мы сейчас...
[01:39:11.600 --> 01:39:13.600]  Ну хорошо, идиотский пример. Давайте возьмем
[01:39:13.600 --> 01:39:15.600]  строку ABAXCA.
[01:39:17.600 --> 01:39:19.600]  Что? ABAXCA.
[01:39:19.600 --> 01:39:21.600]  Она шесть периодичная
[01:39:21.600 --> 01:39:23.600]  и пять периодичная.
[01:39:25.600 --> 01:39:27.600]  Да, но у нее длина-то совсем шесть.
[01:39:27.600 --> 01:39:29.600]  А нам бы тогда...
[01:39:29.600 --> 01:39:31.600]  Для нашей теоремы должна была быть длина
[01:39:31.600 --> 01:39:33.600]  десять.
[01:39:33.600 --> 01:39:35.600]  Мы как раз спрашиваем, верно ли,
[01:39:35.600 --> 01:39:37.600]  что если мы уменьшим длину,
[01:39:37.600 --> 01:39:39.600]  теорема останется?
[01:39:39.600 --> 01:39:41.600]  Уменьшим длину хотя бы на один.
[01:39:41.600 --> 01:39:43.600]  Понятно, что если совсем глобально уменьшим,
[01:39:43.600 --> 01:39:45.600]  то теорема не останется.
[01:39:45.600 --> 01:39:47.600]  Да, но ты уменьшил прям совсем жестко.
[01:39:47.600 --> 01:39:49.600]  Да. Уменьшать совсем
[01:39:49.600 --> 01:39:51.600]  под воду не получится, согласен.
[01:39:51.600 --> 01:39:53.600]  Это да.
[01:39:53.600 --> 01:39:55.600]  Ну хорошо, а если мы допишем в конец
[01:39:55.600 --> 01:39:57.600]  ABAXCA, например, еще...
[01:39:57.600 --> 01:39:59.600]  Нет, ну не ABAXCA,
[01:39:59.600 --> 01:40:01.600]  просто A. Ну и что?
[01:40:03.600 --> 01:40:05.600]  Все еще не работает.
[01:40:05.600 --> 01:40:07.600]  Не работает.
[01:40:07.600 --> 01:40:09.600]  Пять-восемь периодично. И вроде
[01:40:09.600 --> 01:40:11.600]  это уже мы достигли. Правда, это строка уже не
[01:40:11.600 --> 01:40:13.600]  шесть периодично.
[01:40:13.600 --> 01:40:15.600]  Она...
[01:40:15.600 --> 01:40:17.600]  Восемь периодично тоже плохо.
[01:40:17.600 --> 01:40:19.600]  Ну да.
[01:40:21.600 --> 01:40:23.600]  Да.
[01:40:23.600 --> 01:40:25.600]  Нет, по один плюс по два минус один
[01:40:25.600 --> 01:40:27.600]  мы уже уже получили, что можно
[01:40:27.600 --> 01:40:29.600]  из доказательств.
[01:40:29.600 --> 01:40:31.600]  Хочется по один плюс по два минус два.
[01:40:31.600 --> 01:40:33.600]  Нет, там не получили мы.
[01:40:33.600 --> 01:40:35.600]  Там почему-то здесь
[01:40:35.600 --> 01:40:37.600]  меньше либо равно
[01:40:37.600 --> 01:40:39.600]  написано со стороны.
[01:40:39.600 --> 01:40:41.600]  Там должно быть...
[01:40:43.600 --> 01:40:45.600]  На плане на доске сейчас написано
[01:40:45.600 --> 01:40:47.600]  доказательство для минус один.
[01:40:47.600 --> 01:40:49.600]  Ну, попытка доказательства.
[01:40:49.600 --> 01:40:51.600]  Пока это еще начало
[01:40:51.600 --> 01:40:53.600]  доказательства.
[01:40:53.600 --> 01:40:55.600]  То есть мы говорим, что вот этот символ
[01:40:55.600 --> 01:40:57.600]  должен был быть каким-то вот таким символом,
[01:40:57.600 --> 01:40:59.600]  и тут еще вот этот, видимо,
[01:40:59.600 --> 01:41:01.600]  последний символ можно на минус два
[01:41:01.600 --> 01:41:03.600]  на P2 перекинуть.
[01:41:05.600 --> 01:41:07.600]  Ну ладно, там есть конечно оговорочка,
[01:41:07.600 --> 01:41:09.600]  хотя...
[01:41:11.600 --> 01:41:13.600]  Ну вот, то есть там...
[01:41:15.600 --> 01:41:17.600]  То есть его там, видимо,
[01:41:17.600 --> 01:41:19.600]  скорее всего он попадет в какой-то
[01:41:19.600 --> 01:41:21.600]  вот такой суффикс,
[01:41:21.600 --> 01:41:23.600]  то есть там он попадет...
[01:41:23.600 --> 01:41:25.600]  То есть он либо попадет в...
[01:41:25.600 --> 01:41:27.600]  Если он попадет в последние
[01:41:27.600 --> 01:41:29.600]  P1 минус один символов,
[01:41:29.600 --> 01:41:31.600]  там P1 минус один символов,
[01:41:31.600 --> 01:41:33.600]  то значит он тогда равен
[01:41:33.600 --> 01:41:35.600]  еще какому-то из этих символов.
[01:41:35.600 --> 01:41:37.600]  Тут тоже его можно так проскакивать,
[01:41:37.600 --> 01:41:39.600]  проскакивать. Ну и так до тех пор,
[01:41:39.600 --> 01:41:41.600]  пока этот х не попадет уже здесь
[01:41:41.600 --> 01:41:43.600]  в P1 с права символ.
[01:41:45.600 --> 01:41:47.600]  Хотя, с другой стороны, тут уже...
[01:41:47.600 --> 01:41:49.600]  Ну да.
[01:41:51.600 --> 01:41:53.600]  Сейчас, ну что мы хотим получить?
[01:41:53.600 --> 01:41:55.600]  Мы хотим получить для семи или для восьми?
[01:41:55.600 --> 01:41:57.600]  Ой, в смысле...
[01:41:57.600 --> 01:41:59.600]  Ну короче говоря, утверждается,
[01:41:59.600 --> 01:42:01.600]  что если поставить P1 плюс P2 минус два,
[01:42:01.600 --> 01:42:03.600]  то уже не работает.
[01:42:03.600 --> 01:42:05.600]  Ну у нас...
[01:42:05.600 --> 01:42:07.600]  Плюс один уже не работает.
[01:42:07.600 --> 01:42:09.600]  На минус один у нас вот доказательство или...
[01:42:09.600 --> 01:42:11.600]  В каком месте это доказательство?
[01:42:11.600 --> 01:42:13.600]  Там...
[01:42:13.600 --> 01:42:15.600]  Пока это еще не доказательство.
[01:42:15.600 --> 01:42:17.600]  Пока это что х кому-то там равен.
[01:42:17.600 --> 01:42:19.600]  Но почему как бы он так...
[01:42:19.600 --> 01:42:21.600]  То есть вот эти вот механизмы
[01:42:21.600 --> 01:42:23.600]  позволят ему пробежать всю строчку,
[01:42:23.600 --> 01:42:25.600]  непонятно.
[01:42:25.600 --> 01:42:27.600]  Так, у нас есть доказательство
[01:42:27.600 --> 01:42:29.600]  для P1 плюс P2?
[01:42:29.600 --> 01:42:31.600]  Да.
[01:42:31.600 --> 01:42:33.600]  Значит, доказательство такое.
[01:42:33.600 --> 01:42:35.600]  Рассмотрим любые два символа
[01:42:35.600 --> 01:42:37.600]  на расстоянии P2 минус P1.
[01:42:37.600 --> 01:42:39.600]  Значит, я утверждаю, что мы...
[01:42:39.600 --> 01:42:41.600]  И вот возьмем этот левый крестер.
[01:42:41.600 --> 01:42:43.600]  Либо влево P2,
[01:42:43.600 --> 01:42:45.600]  либо вправо P2, либо влево P1.
[01:42:45.600 --> 01:42:47.600]  Так.
[01:42:47.600 --> 01:42:49.600]  Вот. Допустим, мы можем пойти вправо P2.
[01:42:49.600 --> 01:42:51.600]  Тогда пойдем вправо P2 и пойдем влево P1.
[01:42:51.600 --> 01:42:53.600]  Получится, что вот этот символ равен этому.
[01:42:53.600 --> 01:42:55.600]  Потому что P2 периодично,
[01:42:55.600 --> 01:42:57.600]  а этот символ равен этому, потому что P1 периодично.
[01:42:57.600 --> 01:42:59.600]  Окей, дальше. Почему мы можем
[01:42:59.600 --> 01:43:01.600]  пойти вправо P2?
[01:43:01.600 --> 01:43:03.600]  Ну либо вправо P2, либо влево P1.
[01:43:03.600 --> 01:43:05.600]  Потому что предположим,
[01:43:05.600 --> 01:43:07.600]  что мы не можем ни пойти вправо,
[01:43:07.600 --> 01:43:09.600]  ни пойти влево.
[01:43:09.600 --> 01:43:12.640]  чем p1 символов, и справа меньше, чем p2 символов.
[01:43:12.640 --> 01:43:16.520]  То есть всего у нас символов не более, чем p1-1, плюс p2-1,
[01:43:16.520 --> 01:43:18.320]  и еще плюс 1 наш.
[01:43:18.320 --> 01:43:27.640]  Это в сумме… там p2 плюс p1 минус 1.
[01:43:27.640 --> 01:43:29.920]  Вот такое у нас было доказательство.
[01:43:29.920 --> 01:43:30.920]  Хорошо.
[01:43:30.920 --> 01:43:31.920]  Вот.
[01:43:31.920 --> 01:43:39.400]  Но при этом у нас еще есть упражнения для p1 плюс p2-2.
[01:43:39.400 --> 01:43:40.400]  Ну вот.
[01:43:40.400 --> 01:43:44.160]  Мы пока думаем хотя бы на p1 плюс p2 минус 1.
[01:43:44.160 --> 01:43:47.640]  Это единственный случай, который остался.
[01:43:47.640 --> 01:43:48.640]  Почему?
[01:43:48.640 --> 01:43:49.640]  Так.
[01:43:49.640 --> 01:43:51.400]  Но на p1 плюс p2 минус 2…
[01:43:51.400 --> 01:43:55.400]  Мы можем взять сначала p1 минус 1 символ A, потом символ B,
[01:43:55.400 --> 01:43:57.400]  а потом снова все символы A.
[01:44:02.400 --> 01:44:03.400]  Так.
[01:44:03.400 --> 01:44:04.400]  И что нам это даст?
[01:44:04.400 --> 01:44:05.400]  Тогда…
[01:44:05.400 --> 01:44:08.400]  А у нас две последние строки, а она будет для них и для
[01:44:08.400 --> 01:44:09.400]  них периодично.
[01:44:09.400 --> 01:44:10.400]  Вот.
[01:44:10.400 --> 01:44:11.400]  Но очевидно…
[01:44:11.400 --> 01:44:12.400]  Сейчас.
[01:44:12.400 --> 01:44:13.400]  Что такое соседний?
[01:44:13.400 --> 01:44:14.400]  Нет.
[01:44:14.400 --> 01:44:15.400]  Смотри.
[01:44:15.400 --> 01:44:16.400]  А что брать?
[01:44:16.400 --> 01:44:17.400]  Сейчас.
[01:44:17.400 --> 01:44:18.400]  Короче, я беру очень много символов A, потом символ
[01:44:18.400 --> 01:44:19.400]  B, а потом снова куча символов A.
[01:44:19.400 --> 01:44:20.400]  Сколько-то?
[01:44:20.400 --> 01:44:21.400]  Столько же или…
[01:44:21.400 --> 01:44:22.400]  На 1 меньше.
[01:44:22.400 --> 01:44:23.400]  И что?
[01:44:23.400 --> 01:44:24.400]  И что это даст?
[01:44:24.400 --> 01:44:27.400]  Даже не на 1 меньше, а да, можно столько же.
[01:44:27.400 --> 01:44:28.400]  Вот.
[01:44:28.400 --> 01:44:30.400]  Если мы берем столько же, тогда у нас есть строка длинной…
[01:44:30.400 --> 01:44:33.400]  А на 5 периодично и 6 периодично?
[01:44:33.400 --> 01:44:34.400]  Ну да.
[01:44:34.400 --> 01:44:35.400]  Вот.
[01:44:35.400 --> 01:44:36.400]  Но не 1 периодично.
[01:44:36.400 --> 01:44:37.400]  Да, но это 9.
[01:44:37.400 --> 01:44:38.400]  Это не 10.
[01:44:38.400 --> 01:44:39.400]  Да.
[01:44:39.400 --> 01:44:43.400]  5 плюс 6 это 11, минус 2 это 9 как раз.
[01:44:43.400 --> 01:44:44.400]  Ну хорошо, да.
[01:44:44.400 --> 01:44:45.400]  Но так опровергается.
[01:44:45.400 --> 01:44:46.400]  Вот.
[01:44:46.400 --> 01:44:47.400]  Ну хотя…
[01:44:47.400 --> 01:44:48.400]  Ну да.
[01:44:48.400 --> 01:44:49.400]  Ну тут…
[01:44:49.400 --> 01:44:50.400]  Это правда для минус…
[01:44:50.400 --> 01:44:53.400]  А для минус 1 это несколько случаев.
[01:44:53.400 --> 01:44:54.400]  А почему?
[01:44:54.400 --> 01:44:55.400]  И почему это правда?
[01:44:55.400 --> 01:44:56.400]  Потому что по индукции.
[01:44:56.400 --> 01:44:57.400]  Короче, доказывают.
[01:44:57.400 --> 01:44:58.400]  По длинней строке.
[01:44:58.400 --> 01:44:59.400]  Да?
[01:44:59.400 --> 01:45:00.400]  Да.
[01:45:00.400 --> 01:45:01.400]  Ух ты.
[01:45:01.400 --> 01:45:02.400]  Это как?
[01:45:02.400 --> 01:45:03.400]  Это как?
[01:45:03.400 --> 01:45:04.400]  Давайте…
[01:45:04.400 --> 01:45:07.400]  Ну для начала вот…
[01:45:07.400 --> 01:45:14.400]  Случей, короче, когда их ГЦД равняется единицам.
[01:45:14.400 --> 01:45:15.400]  Так.
[01:45:15.400 --> 01:45:23.400]  Я утверждаю, что можно из первого чувака прийти во второго.
[01:45:23.400 --> 01:45:24.400]  Так.
[01:45:24.400 --> 01:45:28.400]  Из первого можно прийти во второго.
[01:45:28.400 --> 01:45:29.400]  Так.
[01:45:29.400 --> 01:45:31.400]  То к чему же это можно?
[01:45:31.400 --> 01:45:33.400]  Ну мы поступаем алгоритмом.
[01:45:33.400 --> 01:45:38.400]  Типа добавляем P1 и почитаем P2.
[01:45:38.400 --> 01:45:39.400]  А.
[01:45:39.400 --> 01:45:40.400]  Ну да.
[01:45:40.400 --> 01:45:41.400]  Доказательство очень простое.
[01:45:41.400 --> 01:45:43.400]  Как доказывать, что из первого можно прийти во второго?
[01:45:43.400 --> 01:45:44.400]  Скачем по… Да.
[01:45:44.400 --> 01:45:48.400]  То есть скачем из первого по P1, P1, P1.
[01:45:48.400 --> 01:45:51.400]  Утверждается, что мы проскачем… То есть скачков мы этих сделаем
[01:45:51.400 --> 01:45:52.400]  сколько?
[01:45:52.400 --> 01:45:55.400]  Ровно P2 минус 1 скачок.
[01:45:55.400 --> 01:45:56.400]  Нет?
[01:45:56.400 --> 01:45:57.400]  А нет.
[01:45:57.400 --> 01:45:58.400]  Не настой.
[01:45:58.400 --> 01:46:01.400]  Там же не произведение.
[01:46:01.400 --> 01:46:04.400]  А да, там не произведение.
[01:46:04.400 --> 01:46:05.400]  Хорошо.
[01:46:05.400 --> 01:46:06.400]  И что так?
[01:46:06.400 --> 01:46:07.400]  А откуда тогда мы возьмем, чтобы мы во второй попадем
[01:46:07.400 --> 01:46:08.400]  как-то?
[01:46:08.400 --> 01:46:11.400]  Что мы не доказали?
[01:46:11.400 --> 01:46:14.400]  Что мы не доказали?
[01:46:14.400 --> 01:46:15.400]  Так.
[01:46:15.400 --> 01:46:16.400]  Ну хорошо.
[01:46:16.400 --> 01:46:17.400]  Да.
[01:46:17.400 --> 01:46:18.400]  То есть мы замечаем, что… Да.
[01:46:18.400 --> 01:46:19.400]  Что мы не доказали.
[01:46:19.400 --> 01:46:22.400]  Вообще пока ничего мы не доказали.
[01:46:22.400 --> 01:46:24.400]  Что мы в этом случае еще не доказали.
[01:46:24.400 --> 01:46:25.400]  Так.
[01:46:25.400 --> 01:46:30.400]  Мы можем просто вот для разности доказать, что мы очевидно
[01:46:30.400 --> 01:46:34.400]  из первого чувака можем… Из первого чувака плюс
[01:46:34.400 --> 01:46:35.400]  разность.
[01:46:35.400 --> 01:46:36.400]  Да?
[01:46:36.400 --> 01:46:37.400]  Так.
[01:46:37.400 --> 01:46:38.400]  Ну не совсем.
[01:46:38.400 --> 01:46:39.400]  Так.
[01:46:39.400 --> 01:46:40.400]  Вот мы знаем, что если нот P1, там P2 равно 1, тогда мы
[01:46:40.400 --> 01:46:42.400]  из этого пользуемся тем, что у нас есть какие-то
[01:46:42.400 --> 01:46:44.400]  мексические там K и L.
[01:46:44.400 --> 01:46:45.400]  Нет, ладно.
[01:46:45.400 --> 01:46:48.400]  Там P1L плюс P2M.
[01:46:48.400 --> 01:46:53.400]  То есть P1L минус P2M равно 1.
[01:46:53.400 --> 01:46:55.400]  Где LM положительные числа.
[01:46:55.400 --> 01:46:56.400]  Вот.
[01:46:56.400 --> 01:46:57.400]  И что мы делаем?
[01:46:57.400 --> 01:47:04.400]  Если мы не отобрали P1, то добавляем P1 пока можем.
[01:47:04.400 --> 01:47:09.400]  Как только уперлись в хвост, начинаем вычитать P2.
[01:47:09.400 --> 01:47:15.400]  Очевидно, не может быть такого момента, когда мы
[01:47:15.400 --> 01:47:17.400]  не можем сделать ни первого, ни второго.
[01:47:17.400 --> 01:47:22.400]  И поэтому в конце концов мы придем в нужную нам единичку.
[01:47:22.400 --> 01:47:23.400]  Так.
[01:47:23.400 --> 01:47:24.400]  Нет.
[01:47:24.400 --> 01:47:36.400]  Из каждого элемента, кроме одного вот этого плохого
[01:47:36.400 --> 01:47:41.400]  по центру, мы всегда хоть что-нибудь можем сделать.
[01:47:41.400 --> 01:47:44.400]  Для каждого элемента кроме человека по центру мы
[01:47:44.400 --> 01:47:47.400]  ровно в тем же способом доказали.
[01:47:47.400 --> 01:47:48.400]  Ну да.
[01:47:48.400 --> 01:47:51.400]  Остается только конкретно для него доказать, что вот
[01:47:51.400 --> 01:47:52.400]  так.
[01:47:52.400 --> 01:47:55.400]  Доказать, что он равен следующему через пока 2 минус
[01:47:55.400 --> 01:47:56.400]  P1.
[01:47:56.400 --> 01:47:57.400]  Да, хотелось бы.
[01:47:57.400 --> 01:47:58.400]  Да.
[01:47:58.400 --> 01:47:59.400]  Ну как же это?
[01:47:59.400 --> 01:48:00.400]  Да.
[01:48:00.400 --> 01:48:03.400]  Ну хоть что, только как мы это делаем, пока вообще
[01:48:03.400 --> 01:48:04.400]  непонятно.
[01:48:04.400 --> 01:48:05.400]  И сейчас.
[01:48:05.400 --> 01:48:06.400]  То есть все.
[01:48:06.400 --> 01:48:11.400]  Уже согласны с тем, что вот заветную единицу мы
[01:48:11.400 --> 01:48:12.400]  получили.
[01:48:12.400 --> 01:48:13.400]  Какая заветная?
[01:48:13.400 --> 01:48:14.400]  Ну вот.
[01:48:14.400 --> 01:48:19.400]  Ну в смысле, что вот мы предвзяли, что первый элемент
[01:48:19.400 --> 01:48:20.400]  равен второму.
[01:48:20.400 --> 01:48:22.400]  Пока вообще не согласен.
[01:48:22.400 --> 01:48:25.400]  А что не так в обсуждении?
[01:48:25.400 --> 01:48:26.400]  Ну.
[01:48:26.400 --> 01:48:29.400]  В общем, что-то вообще нечем.
[01:48:29.400 --> 01:48:30.400]  Видимо, да.
[01:48:30.400 --> 01:48:32.400]  Потому что вообще не понятно.
[01:48:32.400 --> 01:48:34.400]  Мы можем как-то применять какой-то жадный алгоритм
[01:48:34.400 --> 01:48:36.400]  утверждать, что он рано или поздно придет во второй
[01:48:36.400 --> 01:48:37.400]  символ.
[01:48:37.400 --> 01:48:39.400]  Почему он туда придет, лично мне непонятно от слова
[01:48:39.400 --> 01:48:40.400]  совсем.
[01:48:40.400 --> 01:48:41.400]  То есть мы говорим следующее.
[01:48:41.400 --> 01:48:44.400]  Либо P1 равно P2, и тогда это верно?
[01:48:44.400 --> 01:48:46.400]  Ну тогда нот у них не равен 1.
[01:48:46.400 --> 01:48:48.400]  Ну я имею в виду в самой лемме.
[01:48:48.400 --> 01:48:51.400]  Либо P1 равно P2, или это верно?
[01:48:51.400 --> 01:48:52.400]  Ну.
[01:48:52.400 --> 01:48:56.400]  Либо P1 не равно P2, тогда у нас P1 меньше, чем P2 без
[01:48:56.400 --> 01:48:57.400]  ограничений в обществе.
[01:48:57.400 --> 01:49:01.400]  И тогда из этого символа мы можем прыгнуть на P1
[01:49:01.400 --> 01:49:02.400]  направо.
[01:49:02.400 --> 01:49:04.400]  Ну из этого?
[01:49:04.400 --> 01:49:05.400]  Ну не обязательно.
[01:49:05.400 --> 01:49:08.400]  Хотя нет, направо мы можем, да.
[01:49:08.400 --> 01:49:09.400]  Так.
[01:49:09.400 --> 01:49:11.400]  Ну нужно из этого что-то вводить, да?
[01:49:11.400 --> 01:49:12.400]  Ну да.
[01:49:12.400 --> 01:49:13.400]  Так.
[01:49:13.400 --> 01:49:14.400]  Ну заметим, да, что...
[01:49:14.400 --> 01:49:15.400]  Хорошо.
[01:49:15.400 --> 01:49:16.400]  Ну давайте так.
[01:49:16.400 --> 01:49:17.400]  Да.
[01:49:17.400 --> 01:49:21.400]  А хотим упрыгнуть на P1 минус P2?
[01:49:21.400 --> 01:49:24.400]  Ну в идеале хотим, да.
[01:49:24.400 --> 01:49:25.400]  На P1 минус.
[01:49:25.400 --> 01:49:26.400]  То есть там нужно прыгнуть...
[01:49:26.400 --> 01:49:27.400]  Стоп.
[01:49:27.400 --> 01:49:28.400]  Сейчас.
[01:49:28.400 --> 01:49:29.400]  На P2 минус P1.
[01:49:29.400 --> 01:49:30.400]  Наоборот.
[01:49:30.400 --> 01:49:31.400]  Нет.
[01:49:31.400 --> 01:49:32.400]  Ну там видимо...
[01:49:32.400 --> 01:49:33.400]  Да.
[01:49:33.400 --> 01:49:34.400]  Так.
[01:49:34.400 --> 01:49:37.400]  Ну там видимо логика такая.
[01:49:37.400 --> 01:49:38.400]  То есть...
[01:49:38.400 --> 01:49:39.400]  Да.
[01:49:39.400 --> 01:49:40.400]  Ну хотя нет.
[01:49:40.400 --> 01:49:43.400]  То есть нет, у нас как бы проблема, что мы вот так
[01:49:43.400 --> 01:49:45.400]  прыгнуть не можем, потому что строчка заканчивается
[01:49:45.400 --> 01:49:46.400]  буквально здесь.
[01:49:46.400 --> 01:49:47.400]  Поэтому...
[01:49:47.400 --> 01:49:52.400]  То есть как бы, да, на P1 мы прыгнуть можем.
[01:49:52.400 --> 01:49:53.400]  То есть как бы вот этот...
[01:49:53.400 --> 01:49:56.400]  То есть мы можем буквально там прыгнуть на P1.
[01:49:56.400 --> 01:49:59.400]  Более того, может быть, даже если P1 сильно меньше,
[01:49:59.400 --> 01:50:00.400]  чем...
[01:50:00.400 --> 01:50:01.400]  Ну в данном случае вот так скорее, да.
[01:50:01.400 --> 01:50:03.400]  Вот на P1 можем так прыгнуть.
[01:50:03.400 --> 01:50:08.400]  Сейчас я, возможно, Жаня как-то плохо сказал.
[01:50:08.400 --> 01:50:12.400]  Вот давайте мы просто разобьем...
[01:50:12.400 --> 01:50:18.400]  Вот все, мы считаем, что n сравняется P1 плюс P2 минус
[01:50:18.400 --> 01:50:19.400]  1.
[01:50:19.400 --> 01:50:20.400]  Да.
[01:50:20.400 --> 01:50:23.400]  Вот у нас есть этот плохой центральный элемент, да?
[01:50:23.400 --> 01:50:24.400]  Так.
[01:50:24.400 --> 01:50:25.400]  Жадник-то такой.
[01:50:25.400 --> 01:50:31.400]  Если мы сейчас находимся левее этого плохого чувака,
[01:50:31.400 --> 01:50:34.400]  то всегда добавляем P1.
[01:50:34.400 --> 01:50:38.400]  А если мы находимся правее, то вы читаем.
[01:50:38.400 --> 01:50:39.400]  Добавляем P1 или P2?
[01:50:39.400 --> 01:50:40.400]  P1.
[01:50:40.400 --> 01:50:43.400]  То нет, я извиняюсь, тогда...
[01:50:43.400 --> 01:50:45.400]  Тогда, извиняюсь, мы вот из этого символа пойдем вот
[01:50:45.400 --> 01:50:47.400]  сюда на P1, вернемся на P1.
[01:50:47.400 --> 01:50:48.400]  То есть они будут...
[01:50:48.400 --> 01:50:49.400]  Да.
[01:50:49.400 --> 01:50:52.400]  Слева направо мы добавляем P1, справа налево мы...
[01:50:52.400 --> 01:50:53.400]  Ты не сможешь почитать...
[01:50:53.400 --> 01:50:56.400]  Ты не сможешь учесть P2, потому что у тебя может быть
[01:50:56.400 --> 01:50:59.400]  2 по 1 меньше, чем по 2.
[01:50:59.400 --> 01:51:00.400]  Да.
[01:51:00.400 --> 01:51:01.400]  Сейчас у нас...
[01:51:01.400 --> 01:51:05.400]  Мы как построили центральный...
[01:51:05.400 --> 01:51:07.400]  Ну это P1.
[01:51:07.400 --> 01:51:09.400]  У нас слева по 1 символ, а справа по 2.
[01:51:09.400 --> 01:51:10.400]  Ой, ну на...
[01:51:10.400 --> 01:51:11.400]  Поэтому да.
[01:51:11.400 --> 01:51:12.400]  На...
[01:51:12.400 --> 01:51:19.400]  Я думал, что слева P2, справа P1.
[01:51:19.400 --> 01:51:20.400]  Нет, чего...
[01:51:20.400 --> 01:51:21.400]  А, ну хорошо, да.
[01:51:21.400 --> 01:51:22.400]  Хорошо, то есть хорошо.
[01:51:22.400 --> 01:51:28.400]  Справа мы идем на P2, влево мы идем всегда на P1.
[01:51:28.400 --> 01:51:29.400]  Хорошо.
[01:51:29.400 --> 01:51:30.400]  Зачем вообще жаль?
[01:51:30.400 --> 01:51:31.400]  Ну...
[01:51:31.400 --> 01:51:34.400]  То есть у меня идея появилась, типа давайте просто рассмотрим
[01:51:34.400 --> 01:51:36.400]  первые P1-1 символы.
[01:51:36.400 --> 01:51:37.400]  И что?
[01:51:38.400 --> 01:51:39.400]  И...
[01:51:39.400 --> 01:51:43.400]  Будем искать из них просто вправо на P2.
[01:51:43.400 --> 01:51:48.400]  И тогда каждый раз мы будем привылять P2 по модулю P1 к нему.
[01:51:48.400 --> 01:51:52.400]  То есть у нас был индекс, мы привыляем к нему P2 по модулю P1.
[01:51:52.400 --> 01:51:58.400]  Вмечаем, что он равен элементу, у которого индекс будет
[01:51:58.400 --> 01:52:00.400]  И плюс P2.
[01:52:00.400 --> 01:52:09.400]  Итак, мы делаем для всех P1-1 первым.
[01:52:09.400 --> 01:52:10.400]  Нет, что...
[01:52:10.400 --> 01:52:11.400]  Что делаем?
[01:52:11.400 --> 01:52:12.400]  Куда делаем?
[01:52:12.400 --> 01:52:13.400]  Ничего не понимаю.
[01:52:13.400 --> 01:52:14.400]  Ну, просто...
[01:52:14.400 --> 01:52:15.400]  Сейчас.
[01:52:15.400 --> 01:52:22.400]  Я предлагаю рассмотреть префикс для P1.
[01:52:22.400 --> 01:52:23.400]  Ну?
[01:52:23.400 --> 01:52:28.400]  Мы хотим доказать, что у него все буквы одинаковые.
[01:52:29.400 --> 01:52:32.400]  Если нот равен 1...
[01:52:32.400 --> 01:52:35.400]  Да, мы сейчас рассматриваем, что нот равен 1.
[01:52:35.400 --> 01:52:39.400]  Если мы от каждой из них будем искать на P2 вправо,
[01:52:39.400 --> 01:52:43.400]  тогда мы приравняем ее к какой-то другой.
[01:52:43.400 --> 01:52:45.400]  Ну, хорошо, да.
[01:52:45.400 --> 01:52:50.400]  Ну, хорошо, этот префикс равен, допустим, суффиксу, и что?
[01:52:50.400 --> 01:52:55.400]  Ну, я утверждаю, что этого должно платить.
[01:52:55.400 --> 01:52:56.400]  Почему?
[01:52:58.400 --> 01:53:03.400]  Потому что мы его сдвигаем на какое-то число,
[01:53:03.400 --> 01:53:06.400]  которое взаимно простое, с P1.
[01:53:06.400 --> 01:53:08.400]  И что?
[01:53:15.400 --> 01:53:16.400]  Нет, ну просто...
[01:53:16.400 --> 01:53:17.400]  Ну и что?
[01:53:17.400 --> 01:53:19.400]  Ну, сдвинулось оно само по себе куда-то еще.
[01:53:19.400 --> 01:53:21.400]  Нет, в смысле, циклическо сдвигаем.
[01:53:21.400 --> 01:53:26.400]  У нас строка, получается, равна, грубо говоря, своему циклическому сдвиганию.
[01:53:26.400 --> 01:53:28.400]  Ну и что?
[01:53:31.400 --> 01:53:32.400]  А, жесть.
[01:53:32.400 --> 01:53:34.400]  Нет, ну да, то есть, в принципе, сейчас...
[01:53:34.400 --> 01:53:36.400]  Нет, или это...
[01:53:43.400 --> 01:53:47.400]  Сейчас P1 сохраняется при циклическом сдвиге?
[01:53:47.400 --> 01:53:49.400]  Ну не понятно. Нет.
[01:53:49.400 --> 01:53:53.400]  Потому что мы сдвигаем на число, которое взаимно простое, с длинной строки.
[01:53:53.400 --> 01:53:55.400]  Да-да-да, она сохраняется при циклическом сдвиге.
[01:53:55.400 --> 01:53:58.400]  Сейчас сдвигаем на что, не понял?
[01:53:58.400 --> 01:54:00.400]  Сдвигаем на P2, судя по всему.
[01:54:00.400 --> 01:54:02.400]  Ну сдвинули, и что?
[01:54:03.400 --> 01:54:06.400]  Нет, ну можно хорошо сказать, что мы можем сдвигать не на P2,
[01:54:06.400 --> 01:54:09.400]  а на P2%P1, да, и что нам это дает?
[01:54:09.400 --> 01:54:13.400]  Ну то есть у нас, допустим, первый элемент сдвинулся на P2...
[01:54:13.400 --> 01:54:15.400]  Стал P2 п...
[01:54:15.400 --> 01:54:16.400]  Нет.
[01:54:16.400 --> 01:54:17.400]  P2 плюс один.
[01:54:17.400 --> 01:54:18.400]  Чего?
[01:54:18.400 --> 01:54:20.400]  А, ну да, и что?
[01:54:20.400 --> 01:54:23.400]  P2 плюс один стал 2P2 плюс один.
[01:54:24.400 --> 01:54:26.400]  2P2 плюс один у нас нет такого.
[01:54:26.400 --> 01:54:28.400]  Ну по-моему, это будет пойти.
[01:54:31.400 --> 01:54:34.400]  Вот, и так далее. Я утверждаю, что это все будут разные индексы.
[01:54:36.400 --> 01:54:38.400]  Но из-за этого еще не следующее пройдут все.
[01:54:39.400 --> 01:54:41.400]  Потому что, может, оно там зациклется.
[01:54:47.400 --> 01:54:50.400]  Почему нельзя использовать линейное представление?
[01:54:51.400 --> 01:54:55.400]  Потому что ты не можешь скакнуть вправо на L, L раз по P1, а потом вправо,
[01:54:55.400 --> 01:54:58.400]  а потом влево там P2 раз, например.
[01:54:59.400 --> 01:55:00.400]  Ну надо.
[01:55:03.400 --> 01:55:06.400]  Ну тут не очень очевидно, почему у тебя там не кончится,
[01:55:06.400 --> 01:55:09.400]  когда надо скакать P1, а тебе не вынудится скакать P1.
[01:55:09.400 --> 01:55:12.400]  Проблема в том, что мы можем в какой-то момент
[01:55:12.400 --> 01:55:14.400]  скакнуть случайно в кресте.
[01:55:22.400 --> 01:55:24.400]  А, нет, стоп, ну с другой стороны,
[01:55:24.400 --> 01:55:27.400]  тогда мы докажем, что первый чувак и певаляется на кресте.
[01:55:28.400 --> 01:55:29.400]  Ну, тут...
[01:55:39.400 --> 01:55:40.400]  Нет.
[01:55:40.400 --> 01:55:42.400]  Ну в принципе, ну и что это даст?
[01:55:49.400 --> 01:55:52.400]  Ну а это не в обмоте, чего у нас не получалось сделать?
[01:55:58.400 --> 01:56:02.400]  У нас не получалось скакнуть от крестика кому-то.
[01:56:03.400 --> 01:56:06.400]  Нет, кому-то мы могли, мы могли в какую-то право.
[01:56:07.400 --> 01:56:09.400]  Нет, ну крестер это символ,
[01:56:09.400 --> 01:56:12.400]  ну как сказать, если мы смотря куда мы скачем.
[01:56:27.400 --> 01:56:28.400]  Чего?
[01:56:28.400 --> 01:56:31.400]  Строка из первых P2 минус одного символа,
[01:56:31.400 --> 01:56:33.400]  конечно, P2 периодично, ну и что?
[01:56:36.400 --> 01:56:38.400]  Э-э-э...
[01:56:49.400 --> 01:56:50.400]  Ща.
[01:56:53.400 --> 01:56:55.400]  Так, щас.
[01:56:56.400 --> 01:56:58.400]  Ну первое, ну ладно,
[01:56:58.400 --> 01:57:00.400]  тут видимо на этом картинке удобнее,
[01:57:00.400 --> 01:57:03.400]  последнее P2 минус один символ, ну конечно.
[01:57:03.400 --> 01:57:06.400]  Так, ну они, да, они видимо P2, да, они конечно P2,
[01:57:06.400 --> 01:57:08.400]  то есть ладно, хорошо,
[01:57:08.400 --> 01:57:10.400]  вот этот, вот этот суффикс,
[01:57:10.400 --> 01:57:13.400]  он точно P2 минус P1 периодично, это да.
[01:57:15.400 --> 01:57:17.400]  Да, почему он P2 минус P1?
[01:57:17.400 --> 01:57:19.400]  Ну, ну здесь суффикс, получи.
[01:57:20.400 --> 01:57:23.400]  Ну, префикс тоже на самом деле не глобально, но вот.
[01:57:23.400 --> 01:57:25.400]  Ну ладно, что важно, что вот мы
[01:57:25.400 --> 01:57:27.400]  получили префикс
[01:57:27.400 --> 01:57:29.400]  длины...
[01:57:30.400 --> 01:57:32.400]  длины P2 минус один.
[01:57:32.400 --> 01:57:33.400]  Так.
[01:57:34.400 --> 01:57:35.400]  И...
[01:57:35.400 --> 01:57:37.400]  теперь у нас есть периодичность P1
[01:57:37.400 --> 01:57:39.400]  и P2 минус P1.
[01:57:41.400 --> 01:57:42.400]  Да, и?
[01:57:42.400 --> 01:57:45.400]  Ну, хочется применить там, сложные бутсы.
[01:57:50.400 --> 01:57:51.400]  Так.
[01:57:52.400 --> 01:57:54.400]  Так, и сказать, ну вот, и сказать, ага.
[01:57:56.400 --> 01:57:57.400]  Ну да.
[01:57:57.400 --> 01:57:59.400]  И сказать, что все эти символы...
[01:58:03.400 --> 01:58:04.400]  Ага.
[01:58:05.400 --> 01:58:06.400]  Так.
[01:58:07.400 --> 01:58:09.400]  Ага, то есть предположение индукции, да.
[01:58:09.400 --> 01:58:11.400]  Ну, значит, хорошо, давайте попробуем, значит.
[01:58:11.400 --> 01:58:14.400]  Суффикс у нас P2 минус P1 периодичен,
[01:58:14.400 --> 01:58:17.400]  так, а также этот суффикс еще и P1
[01:58:17.400 --> 01:58:18.400]  периодичен.
[01:58:18.400 --> 01:58:20.400]  Длина, длина этой...
[01:58:20.400 --> 01:58:22.400]  Ну вот, ну рассмотрим вот строку длины
[01:58:22.400 --> 01:58:24.400]  P1 плюс P2 минус P1, рассмотрим ее суффикс.
[01:58:24.400 --> 01:58:26.400]  Утверждение, этот суффикс
[01:58:26.400 --> 01:58:28.400]  P1 периодичен, ну понятно, да.
[01:58:28.400 --> 01:58:31.400]  А еще утверждает, что он P2 минус P1 периодичен.
[01:58:33.400 --> 01:58:35.400]  Потому что вот это вот рассуждение
[01:58:35.400 --> 01:58:37.400]  для любых двух символов в этой части
[01:58:37.400 --> 01:58:39.400]  прекрасно прокатывает.
[01:58:40.400 --> 01:58:41.400]  Ага.
[01:58:46.400 --> 01:58:47.400]  Ну...
[01:58:48.400 --> 01:58:49.400]  Да.
[01:58:49.400 --> 01:58:51.400]  И префикс тоже по 2 минус 1 периодичен?
[01:58:51.400 --> 01:58:54.400]  Ну префикс там даже уже не принципиальным,
[01:58:54.400 --> 01:58:56.400]  что дальше рассуждение звучит так.
[01:58:56.400 --> 01:58:57.400]  Итак, у нас внутри...
[01:58:57.400 --> 01:58:59.400]  У этой строки есть 2 периода,
[01:58:59.400 --> 01:59:02.400]  тоже HCD их равно 1,
[01:59:02.400 --> 01:59:06.400]  и длина этой строки равна сумме этих периодов минус 1.
[01:59:06.400 --> 01:59:08.400]  Вот, следует, можно предположить,
[01:59:08.400 --> 01:59:11.400]  то есть можно взять некое предположение индукции
[01:59:11.400 --> 01:59:13.400]  и сказать, что из этого следует,
[01:59:13.400 --> 01:59:15.400]  что все эти символы равны.
[01:59:17.400 --> 01:59:18.400]  А дальше все просто,
[01:59:18.400 --> 01:59:19.400]  что если эти все символы равны,
[01:59:19.400 --> 01:59:21.400]  то очевидно, что все вот эти символы
[01:59:21.400 --> 01:59:22.400]  тоже им равны,
[01:59:22.400 --> 01:59:24.400]  просто равны тому же самому символу.
[01:59:33.400 --> 01:59:34.400]  Ну вот.
[01:59:35.400 --> 01:59:36.400]  Ну вот.
[01:59:36.400 --> 01:59:38.400]  Ну да, то есть выводится по сути...
[01:59:38.400 --> 01:59:41.400]  Ладно, давай так не будем бежать, да.
[01:59:43.400 --> 01:59:46.400]  Пока для нода получается доказали.
[01:59:46.400 --> 01:59:47.400]  Ну вот.
[01:59:47.400 --> 01:59:49.400]  Но, соответственно...
[01:59:49.400 --> 01:59:50.400]  А вот даже интересно,
[01:59:50.400 --> 01:59:51.400]  а если у вас известно,
[01:59:51.400 --> 01:59:54.400]  что нод P1 плюс P2 равно 1,
[01:59:54.400 --> 01:59:56.400]  и у вас оказалось все-таки,
[01:59:56.400 --> 01:59:59.400]  что длина строки P1 плюс P2 минус 2?
[02:00:00.400 --> 02:00:01.400]  Ну это...
[02:00:01.400 --> 02:00:03.400]  Что-то мне тут хочется спросить,
[02:00:03.400 --> 02:00:04.400]  можно ли его обобщить,
[02:00:04.400 --> 02:00:07.400]  может это конкретные свойства чисел 5 и 6?
[02:00:08.400 --> 02:00:10.400]  В смысле, дописываете влево буквы,
[02:00:10.400 --> 02:00:12.400]  а вправо буквы А,
[02:00:12.400 --> 02:00:14.400]  а по центру В?
[02:00:15.400 --> 02:00:17.400]  Даже не дописывайте.
[02:00:22.400 --> 02:00:23.400]  Нет, ну хорошо,
[02:00:23.400 --> 02:00:24.400]  а если я возьму не 5 и 6,
[02:00:24.400 --> 02:00:25.400]  я не знаю, 4 и 9,
[02:00:25.400 --> 02:00:27.400]  то что я тогда сделаю?
[02:00:27.400 --> 02:00:29.400]  Зачем брать 4 и 9?
[02:00:31.400 --> 02:00:32.400]  Ну для того, чтобы посмотреть,
[02:00:32.400 --> 02:00:34.400]  существует ли строка длины 4 плюс 9 минус 2,
[02:00:34.400 --> 02:00:35.400]  то есть 11,
[02:00:35.400 --> 02:00:37.400]  которое 4 периодично, 9 периодично,
[02:00:37.400 --> 02:00:38.400]  но состоит не из одного символа.
[02:00:38.400 --> 02:00:40.400]  В плане, вы хотите...
[02:00:40.400 --> 02:00:42.400]  Для любой пары P1, P2.
[02:00:42.400 --> 02:00:45.400]  С таким нодом, да, подумать вообще, да.
[02:00:47.400 --> 02:00:49.400]  Ну нужно просто несколько раз расставить.
[02:00:49.400 --> 02:00:51.400]  Ну, можно проверить.
[02:00:52.400 --> 02:00:55.400]  Нет, ну такой-то, например, уже понятно, не работает.
[02:00:55.400 --> 02:00:57.400]  Нет, но работает, если...
[02:00:57.400 --> 02:00:58.400]  А, размножить букву В.
[02:00:58.400 --> 02:00:59.400]  Да-да-да.
[02:00:59.400 --> 02:01:01.400]  Надо на каждую позицию букву В ставить.
[02:01:02.400 --> 02:01:04.400]  Да, но тогда у нас проблемы.
[02:01:04.400 --> 02:01:06.400]  Нет, тогда все нормально.
[02:01:06.400 --> 02:01:09.400]  Так, хорошо, конкретно здесь проблем нет, согласен.
[02:01:09.400 --> 02:01:10.400]  Мне кажется, вообще не будет,
[02:01:10.400 --> 02:01:13.400]  потому что у нас обязана...
[02:01:14.400 --> 02:01:18.400]  У нас строка кончается после последней буквы В.
[02:01:21.400 --> 02:01:24.400]  Больший строк кончается после последней буквы В.
[02:01:24.400 --> 02:01:29.400]  Ммм...
[02:01:29.400 --> 02:01:30.400]  Вот.
[02:01:30.400 --> 02:01:33.400]  А количество букв А, которые к ней можно написать,
[02:01:33.400 --> 02:01:35.400]  это в точности период минус 1.
[02:01:37.400 --> 02:01:38.400]  Меньший.
[02:01:39.400 --> 02:01:41.400]  Ммм...
[02:01:43.400 --> 02:01:44.400]  Сейчас, погодите.
[02:01:44.400 --> 02:01:45.400]  Так, сейчас вот тут.
[02:01:45.400 --> 02:01:48.400]  Ну точнее, ну я немножко с конца сказал,
[02:01:48.400 --> 02:01:50.400]  ну короче, если мы возьмем период P1,
[02:01:50.400 --> 02:01:54.400]  запишем его несколько раз.
[02:01:56.400 --> 02:01:58.400]  Да, запишем его несколько раз.
[02:01:59.400 --> 02:02:02.400]  Ну ладно, до 4.7 это, наверное, не будет работать.
[02:02:02.400 --> 02:02:03.400]  А ну-ка, давайте смотри.
[02:02:03.400 --> 02:02:04.400]  Ну давайте посмотрим.
[02:02:04.400 --> 02:02:05.400]  Вот P1, P1, P1.
[02:02:05.400 --> 02:02:06.400]  Давайте вот посмотрим.
[02:02:07.400 --> 02:02:08.400]  До 4.7 не будет.
[02:02:09.400 --> 02:02:10.400]  Вот.
[02:02:11.400 --> 02:02:13.400]  Так, до 4.7 не будет?
[02:02:13.400 --> 02:02:14.400]  Не будет.
[02:02:14.400 --> 02:02:15.400]  Да?
[02:02:15.400 --> 02:02:16.400]  А что там будет?
[02:02:20.400 --> 02:02:21.400]  Ну да.
[02:02:21.400 --> 02:02:24.400]  Потому что тут 7 можно вычесть, к сожалению, да.
[02:02:26.400 --> 02:02:29.400]  Ну ладно, тут, видимо, тогда особо не покопаешься.
[02:02:29.400 --> 02:02:31.400]  Ну то есть, на самом деле, просто действительно.
[02:02:31.400 --> 02:02:33.400]  Лемма, конечно, нам потребуется в таком виде.
[02:02:33.400 --> 02:02:37.400]  На самом деле, как уже кто-то заметил, можно ее доказать вот в таком виде.
[02:02:44.400 --> 02:02:45.400]  Почему?
[02:02:45.400 --> 02:02:47.400]  Ну потому что, смотрите, если нот P1, P2 равен 1,
[02:02:47.400 --> 02:02:48.400]  мы это только что сделали.
[02:02:49.400 --> 02:02:50.400]  Вот.
[02:02:50.400 --> 02:02:52.400]  А если нот равен чему-то нетривиальному,
[02:02:52.400 --> 02:02:55.400]  то заметим, что эти периоды говорят нам,
[02:02:55.400 --> 02:02:58.400]  ну допустим, там оба этих периода делятся на 57, да?
[02:02:58.400 --> 02:03:04.400]  Тогда, в принципе, это означает, что строку можно разбить там на блоке по 57
[02:03:04.400 --> 02:03:07.400]  и, по большому счету, сравниваются между собой только символы
[02:03:07.400 --> 02:03:10.400]  с индексами одинаковыми по модулю 57.
[02:03:10.400 --> 02:03:12.400]  И тогда просто по каждому остатку, по большому счету,
[02:03:12.400 --> 02:03:14.400]  мы вытеркиваем соответствующие символы
[02:03:14.400 --> 02:03:17.400]  и сводим задачу к ноду, равному 1.
[02:03:19.400 --> 02:03:26.400]  Так, то есть мы доказали для P1 плюс 2, плюс P2 минус 1?
[02:03:26.400 --> 02:03:27.400]  По сути, да.
[02:03:27.400 --> 02:03:31.400]  Ну короче, нужно будет иметь доказыватель для суммы.
[02:03:31.400 --> 02:03:33.400]  Ну да, тут суть такая, то есть возьмем там,
[02:03:33.400 --> 02:03:38.400]  если они оба делятся там на 57, то как бы давайте найдем там, допустим,
[02:03:38.400 --> 02:03:40.400]  каждый 57 символ, начиная с какого-то,
[02:03:40.400 --> 02:03:44.400]  и по сути нам надо доказать, что теория ему, что если соответствующая строка
[02:03:44.400 --> 02:03:47.400]  там P1 делится 57 периодично,
[02:03:47.400 --> 02:03:50.400]  P2 делится 57 периодично,
[02:03:50.400 --> 02:03:53.400]  то она будет периодично и с периодом P1 делится 57,
[02:03:53.400 --> 02:03:56.400]  плюс P2 делится 57, минус 1.
[02:03:56.400 --> 02:04:00.400]  Вот, но если мы как бы для каждой из 57 строк это аккуратненько доказываем
[02:04:00.400 --> 02:04:03.400]  и в результате у нас получилось хорошо.
[02:04:08.400 --> 02:04:10.400]  На самом деле так.
[02:04:10.400 --> 02:04:11.400]  Вот.
[02:04:12.400 --> 02:04:14.400]  Так что вот такая вот красивая лемма.
[02:04:14.400 --> 02:04:18.400]  Сейчас, а есть лемма, что если еще вычислить, то плохо.
[02:04:18.400 --> 02:04:21.400]  Ну вот, а вот такой леммы вот, да, с лед пока мне доказать не удалось,
[02:04:21.400 --> 02:04:24.400]  у меня в кармане она не лежит.
[02:04:24.400 --> 02:04:27.400]  Потому что как выясняется, да, бывает плохо, бывает нормально,
[02:04:27.400 --> 02:04:29.400]  там видимо всякое бывает.
[02:04:29.400 --> 02:04:32.400]  Хотя вот интересно, да, 47,
[02:04:32.400 --> 02:04:34.400]  то есть 4 там,
[02:04:34.400 --> 02:04:38.400]  нет, ну тут смотрите, на самом деле, то есть для 47 конечно делается так,
[02:04:38.400 --> 02:04:40.400]  по большому счету.
[02:04:40.400 --> 02:04:44.400]  Вот вложили были 9 этих,
[02:04:44.400 --> 02:04:48.400]  а давайте просто соединим ребрами те, кто должен быть равен.
[02:04:48.400 --> 02:04:51.400]  Вот 4, вот эти вот равны.
[02:04:51.400 --> 02:04:53.400]  Вот как-то вот так, да.
[02:04:53.400 --> 02:04:59.400]  И теперь еще давайте ведем 3 семерочки.
[02:04:59.400 --> 02:05:04.400]  Так, ведем 3 семерочки, как мы их ведем?
[02:05:04.400 --> 02:05:09.400]  Значит их ведем мы вот так вот, и вот так вот.
[02:05:09.400 --> 02:05:13.400]  Остается только выяснить, является ли этот жрав связанным.
[02:05:19.400 --> 02:05:21.400]  Ответ, не является. Почему?
[02:05:21.400 --> 02:05:24.400]  Потому что вот эти два символа, к этим двум символам на расстоянии 4,
[02:05:24.400 --> 02:05:27.400]  семерка неприменима от слова никак.
[02:05:27.400 --> 02:05:31.400]  Ну вывод, ну означает, что пример можно привести какой-нибудь вот,
[02:05:31.400 --> 02:05:35.400]  а, а, б, а, а, б, а, а.
[02:05:38.400 --> 02:05:42.400]  Нет, это я написал, но это не имеет длину.
[02:05:42.400 --> 02:05:45.400]  То есть это означает, что это имеет длину 4 плюс 7,
[02:05:45.400 --> 02:05:47.400]  минус 2, 9.
[02:05:55.400 --> 02:05:59.400]  Нет, на самом деле можно действительно задуматься еще,
[02:05:59.400 --> 02:06:01.400]  задуматься еще вот о чем.
[02:06:01.400 --> 02:06:04.400]  Смотрите, знаете, как можно мыслить?
[02:06:04.400 --> 02:06:08.400]  Вот если мыслить вот в этой графовой терминологии.
[02:06:09.400 --> 02:06:11.400]  Так, что? В чем вопрос?
[02:06:13.400 --> 02:06:15.400]  То есть на самом деле, если у вас тут P1 плюс P2,
[02:06:15.400 --> 02:06:17.400]  то на самом деле еще вот вопрос.
[02:06:17.400 --> 02:06:20.400]  Мы можем соединить ребрами два равных символа,
[02:06:20.400 --> 02:06:22.400]  сидит на расстоянии P1 или P2.
[02:06:22.400 --> 02:06:23.400]  Внимание, вопрос.
[02:06:23.400 --> 02:06:26.400]  А сколько ребер мы вообще проведем?
[02:06:27.400 --> 02:06:28.400]  Ну, очевидно.
[02:06:28.400 --> 02:06:31.400]  То есть заметим, что если у нас длина строки равна,
[02:06:31.400 --> 02:06:35.400]  допустим, L, и она больше либо равна подлине,
[02:06:35.400 --> 02:06:40.400]  чем максимум из P1, P2.
[02:06:42.400 --> 02:06:44.400]  Ну, наверное, понятно, что меньшей длины
[02:06:44.400 --> 02:06:46.400]  мы вряд ли будем рассматривать строки.
[02:06:46.400 --> 02:06:48.400]  Тогда сколько ребер мы тогда проведем?
[02:06:48.400 --> 02:06:53.400]  Тогда ребер по P1 мы проведем ровно, получается, L минус P1.
[02:06:54.400 --> 02:06:58.400]  А вторых, ребер мы проведем L минус P2.
[02:06:58.400 --> 02:07:00.400]  Логично, да?
[02:07:00.400 --> 02:07:02.400]  Теперь проверяем.
[02:07:02.400 --> 02:07:04.400]  Пусть у нас...
[02:07:04.400 --> 02:07:06.400]  Итак, смотрите.
[02:07:06.400 --> 02:07:08.400]  И тогда можно было сказать,
[02:07:08.400 --> 02:07:10.400]  пусть у нас L оказалось меньше либо равно...
[02:07:12.400 --> 02:07:13.400]  Ну, вот.
[02:07:13.400 --> 02:07:15.400]  Теперь пусть у нас L меньше либо равно,
[02:07:15.400 --> 02:07:17.400]  чем P1 плюс P2 минус 2.
[02:07:18.400 --> 02:07:20.400]  Тогда у нас получается...
[02:07:21.400 --> 02:07:23.400]  Вот эта вот штука,
[02:07:23.400 --> 02:07:25.400]  тогда получается какая?
[02:07:25.400 --> 02:07:27.400]  Тогда мы тут...
[02:07:27.400 --> 02:07:29.400]  P1 плюс P2 минус 2,
[02:07:29.400 --> 02:07:32.400]  плюс P1 плюс P2 минус 2,
[02:07:32.400 --> 02:07:34.400]  минус P1 минус P2,
[02:07:34.400 --> 02:07:37.400]  шлеп, шлеп, шлеп, шлеп.
[02:07:37.400 --> 02:07:40.400]  И это равно получается P1 плюс P2,
[02:07:40.400 --> 02:07:42.400]  минус даже 4.
[02:07:44.400 --> 02:07:46.400]  То есть это означает, что мы провели
[02:07:46.400 --> 02:07:48.400]  очень мало ребер.
[02:07:49.400 --> 02:07:51.400]  То есть это означает, что
[02:07:51.400 --> 02:07:53.400]  граф заведом...
[02:07:53.400 --> 02:07:55.400]  То есть граф на...
[02:07:55.400 --> 02:07:57.400]  Ну вот.
[02:07:57.400 --> 02:07:59.400]  Нет, ну нам одного ребра...
[02:07:59.400 --> 02:08:01.400]  Чего?
[02:08:01.400 --> 02:08:02.400]  Ну почему?
[02:08:02.400 --> 02:08:04.400]  Ну да, по большому счету да.
[02:08:04.400 --> 02:08:06.400]  То есть если у нас L равно вот этому,
[02:08:06.400 --> 02:08:08.400]  то в принципе да.
[02:08:08.400 --> 02:08:10.400]  Из этого автоматически следует,
[02:08:10.400 --> 02:08:12.400]  что действительно нам получается,
[02:08:12.400 --> 02:08:14.400]  этот граф заведом и не может быть связан,
[02:08:14.400 --> 02:08:16.400]  и это получается, что предъявить строку
[02:08:16.400 --> 02:08:18.400]  и два различных символа
[02:08:18.400 --> 02:08:20.400]  вполне можно всегда.
[02:08:20.400 --> 02:08:22.400]  То есть более того...
[02:08:22.400 --> 02:08:24.400]  Нет, если P1, P2 небольшие,
[02:08:24.400 --> 02:08:26.400]  то вы в явном виде строите граф,
[02:08:26.400 --> 02:08:28.400]  запускаете DFS и все.
[02:08:28.400 --> 02:08:30.400]  То есть более того, знаете там...
[02:08:30.400 --> 02:08:32.400]  То есть там же...
[02:08:32.400 --> 02:08:34.400]  Ну вот.
[02:08:34.400 --> 02:08:36.400]  То есть...
[02:08:36.400 --> 02:08:38.400]  Ну да.
[02:08:38.400 --> 02:08:40.400]  То есть я вам больше скажу,
[02:08:40.400 --> 02:08:42.400]  это на самом деле так можно...
[02:08:42.400 --> 02:08:44.400]  Вот есть задача,
[02:08:44.400 --> 02:08:46.400]  или...
[02:08:46.400 --> 02:08:48.400]  Или...
[02:08:48.400 --> 02:08:50.400]  Или есть... Нет.
[02:08:50.400 --> 02:08:52.400]  Или на самом деле вот знаете,
[02:08:52.400 --> 02:08:54.400]  вот есть классическая задача,
[02:08:54.400 --> 02:08:56.400]  дана Z функция.
[02:08:56.400 --> 02:08:58.400]  Да.
[02:08:58.400 --> 02:09:00.400]  Нет, смотрите.
[02:09:00.400 --> 02:09:02.400]  Ну вот.
[02:09:02.400 --> 02:09:04.400]  Либо дана Z функция, либо дана
[02:09:04.400 --> 02:09:06.400]  префикс функция.
[02:09:06.400 --> 02:09:08.400]  И вам говорят, скажите, пожалуйста,
[02:09:08.400 --> 02:09:10.400]  существует ли строчка,
[02:09:10.400 --> 02:09:12.400]  в которой префикс функция вот такая?
[02:09:12.400 --> 02:09:14.400]  Нет.
[02:09:14.400 --> 02:09:16.400]  Ну, можно ограничить.
[02:09:16.400 --> 02:09:18.400]  Ну, сейчас давайте для простоты
[02:09:18.400 --> 02:09:20.400]  предположим, что неограниченный.
[02:09:20.400 --> 02:09:22.400]  Тогда задача звучит так.
[02:09:22.400 --> 02:09:24.400]  То есть пусть он неограниченный.
[02:09:24.400 --> 02:09:26.400]  Тогда как решается такая задача?
[02:09:26.400 --> 02:09:28.400]  Запускаем для этой виртуальной строки
[02:09:28.400 --> 02:09:30.400]  алгоритм поиска префикс функции.
[02:09:30.400 --> 02:09:32.400]  Для того, чтобы он сработал
[02:09:32.400 --> 02:09:34.400]  ровно в том виде,
[02:09:34.400 --> 02:09:36.400]  чтобы этот алгоритм нашел именно такую
[02:09:36.400 --> 02:09:38.400]  префикс функцию, вы воображаете себе,
[02:09:38.400 --> 02:09:40.400]  что он сравнивает какие-то символы
[02:09:40.400 --> 02:09:42.400]  вот эти, вот такие-то пары символов должны быть равны,
[02:09:42.400 --> 02:09:44.400]  а вот такие-то пары символов должны быть
[02:09:44.400 --> 02:09:46.400]  неравны. Правда?
[02:09:46.400 --> 02:09:48.400]  Вот. И тогда, по сути,
[02:09:48.400 --> 02:09:50.400]  ну вот, то есть вы там получается
[02:09:50.400 --> 02:09:52.400]  строите граф равенств, что в Z функции,
[02:09:52.400 --> 02:09:54.400]  что в префикс функции, и он
[02:09:54.400 --> 02:09:56.400]  тогда говорит, то есть если
[02:09:56.400 --> 02:09:58.400]  тогда сжимаете компоненты связности, выяснилось,
[02:09:58.400 --> 02:10:00.400]  что там два символа из одной компоненты
[02:10:00.400 --> 02:10:02.400]  связности должны быть неравны, значит, поздравляю,
[02:10:02.400 --> 02:10:04.400]  вы пофейлились.
[02:10:04.400 --> 02:10:06.400]  А если нет и размер алфавита у вас
[02:10:06.400 --> 02:10:08.400]  неограниченный, то, собственно,
[02:10:08.400 --> 02:10:10.400]  тогда вы просто там каждую компоненту своим символом
[02:10:10.400 --> 02:10:12.400]  рисуете, и вот он, строчка.
[02:10:14.400 --> 02:10:16.400]  Вот. Понятно, да?
[02:10:16.400 --> 02:10:18.400]  Ну, конечно, если у вас размер алфавита равно 2,
[02:10:18.400 --> 02:10:20.400]  то эта задача становится тоже достаточно простой,
[02:10:20.400 --> 02:10:22.400]  потому что тогда у вас после сжатия
[02:10:22.400 --> 02:10:24.400]  получается граф, и вам нужно просто выяснить,
[02:10:24.400 --> 02:10:26.400]  является ли этот граф двудольным.
[02:10:28.400 --> 02:10:30.400]  Ну, потому что, когда вы сжимаете компоненты
[02:10:30.400 --> 02:10:32.400]  связности по равным символам, остаются
[02:10:32.400 --> 02:10:34.400]  еще требования, что какие-то символы должны быть неравны.
[02:10:34.400 --> 02:10:36.400]  То есть у вас есть требования,
[02:10:36.400 --> 02:10:38.400]  что какие-то компоненты неравны,
[02:10:38.400 --> 02:10:40.400]  и возникает вопрос, можно ли их покрасить в два цвета
[02:10:40.400 --> 02:10:42.400]  так, чтобы любое неравенство соединяло
[02:10:42.400 --> 02:10:44.400]  две разные компоненты.
[02:10:44.400 --> 02:10:46.400]  Ну, таким алгоритмом не умеем,
[02:10:46.400 --> 02:10:48.400]  потому что можно ли покрасить граф
[02:10:48.400 --> 02:10:50.400]  в три цвета, это, к сожалению,
[02:10:50.400 --> 02:10:52.400]  задача непополная.
[02:10:52.400 --> 02:10:54.400]  Да.
[02:10:54.400 --> 02:10:56.400]  Вот.
[02:10:56.400 --> 02:10:58.400]  По-моему, для трех цветов она чуть меньше,
[02:10:58.400 --> 02:11:00.400]  чем непополная.
[02:11:00.400 --> 02:11:02.400]  Нет, по-моему,
[02:11:02.400 --> 02:11:04.400]  в явном виде непополная.
[02:11:04.400 --> 02:11:06.400]  Более того, и два линии через нее
[02:11:06.400 --> 02:11:08.400]  непополнота остальных и доказывается.
[02:11:08.400 --> 02:11:10.400]  Мне казалось, что, типа, если красить
[02:11:10.400 --> 02:11:12.400]  больше, чем в три цвета, то прям непополная.
[02:11:12.400 --> 02:11:14.400]  Нет, нет, нет.
[02:11:14.400 --> 02:11:16.400]  Нет, нет, нет.
[02:11:16.400 --> 02:11:18.400]  Нет, нет, нет.
[02:11:18.400 --> 02:11:20.400]  Не могу сейчас, конечно, перевоспроизвести
[02:11:20.400 --> 02:11:22.400]  все доказательства со всеми определениями,
[02:11:22.400 --> 02:11:24.400]  но как бы классическая непополная задача является
[02:11:24.400 --> 02:11:26.400]  именно задача про
[02:11:26.400 --> 02:11:28.400]  покраску графа в три цвета.
[02:11:28.400 --> 02:11:30.400]  Вот.
[02:11:30.400 --> 02:11:32.400]  То есть, в принципе, построить, скажем, строчку
[02:11:32.400 --> 02:11:34.400]  и префикс функ
[02:11:34.400 --> 02:11:36.400]  вот таким вот образом нехитрым.
[02:11:36.400 --> 02:11:38.400]  Вот.
[02:11:38.400 --> 02:11:40.400]  Соответственно.
[02:11:40.400 --> 02:11:42.400]  Ну вот.
[02:11:42.400 --> 02:11:44.400]  Чего?
[02:11:44.400 --> 02:11:46.400]  Ну вот. Так что вот такая красота.
[02:11:46.400 --> 02:11:48.400]  Значит,
[02:11:48.400 --> 02:11:50.400]  что у нас тогда еще?
[02:11:50.400 --> 02:11:52.400]  Вот. То есть, получается, что
[02:11:52.400 --> 02:11:54.400]  если у нас тут, действительно, P1 плюс P2
[02:11:54.400 --> 02:11:56.400]  и минус 2, то, получается, ребер тупо не хватает,
[02:11:56.400 --> 02:11:58.400]  граф не связан.
[02:11:58.400 --> 02:12:00.400]  А если P1 плюс P2 и минус P1,
[02:12:00.400 --> 02:12:02.400]  тогда граф, как раз, становится
[02:12:02.400 --> 02:12:04.400]  адекватно связан, двойчики добегают.
[02:12:04.400 --> 02:12:06.400]  И после этого, тогда мы выясняем,
[02:12:06.400 --> 02:12:08.400]  что... То есть,
[02:12:08.400 --> 02:12:10.400]  не граф связан, а количество ребер
[02:12:10.400 --> 02:12:12.400]  адекватное.
[02:12:12.400 --> 02:12:14.400]  Потому что, в принципе, может, там просто произошел
[02:12:14.400 --> 02:12:16.400]  какой-то хороший цикл.
[02:12:16.400 --> 02:12:18.400]  Ну, с другой стороны, там, видимо,
[02:12:18.400 --> 02:12:20.400]  возможно, достаточно легко показать, что никакого цикла
[02:12:20.400 --> 02:12:22.400]  там быть не может.
[02:12:22.400 --> 02:12:24.400]  Потому что цикл может состоять только из
[02:12:24.400 --> 02:12:26.400]  P2 ребер длинный P1
[02:12:26.400 --> 02:12:28.400]  и P1 ребер длинный P2, потому что у нас тут вот
[02:12:28.400 --> 02:12:30.400]  диафантовое уравнение.
[02:12:30.400 --> 02:12:32.400]  Но, на самом деле, можно это не обсуждать,
[02:12:32.400 --> 02:12:34.400]  а можно без этого просто аккуратненько доказать,
[02:12:34.400 --> 02:12:36.400]  как мы сделали.
[02:12:36.400 --> 02:12:38.400]  Вот. Так что вот такой вот
[02:12:38.400 --> 02:12:40.400]  интересный момент.
[02:12:40.400 --> 02:12:42.400]  Вот.
[02:12:42.400 --> 02:12:44.400]  Вот. Но, на самом деле, более того,
[02:12:44.400 --> 02:12:46.400]  бывает, на самом деле, еще более
[02:12:46.400 --> 02:12:48.400]  красивый момент, конечно.
[02:12:48.400 --> 02:12:50.400]  Сейчас вот, жалко, мне так с лету
[02:12:50.400 --> 02:12:52.400]  сложно вспомнить задачу на это. Но, на самом деле,
[02:12:52.400 --> 02:12:54.400]  из вот этой леммы,
[02:12:54.400 --> 02:12:56.400]  с нод...
[02:12:56.400 --> 02:12:58.400]  То есть, там, бывает с нод периодичностью.
[02:12:58.400 --> 02:13:00.400]  На самом деле, можно сделать
[02:13:00.400 --> 02:13:02.400]  еще маленький приятный вывод.
[02:13:02.400 --> 02:13:04.400]  То есть, идея такая. Предположим, что у вас есть строчка
[02:13:04.400 --> 02:13:06.400]  и вы скачете по префикс функции.
[02:13:06.400 --> 02:13:08.400]  Спрашивается,
[02:13:08.400 --> 02:13:10.400]  какие числа вы там увидите?
[02:13:14.400 --> 02:13:16.400]  Но они убывают
[02:13:16.400 --> 02:13:18.400]  или возвращаются? Нет, они постоянно
[02:13:18.400 --> 02:13:20.400]  убывают, да. То есть, вы можете из каждой
[02:13:20.400 --> 02:13:22.400]  чиселки скакать, скакать, скакать,
[02:13:22.400 --> 02:13:24.400]  скакать, скакать, скакать. Но фишка
[02:13:24.400 --> 02:13:26.400]  в другом. Я утверждаю, что это не просто
[02:13:26.400 --> 02:13:28.400]  рандомная убывающая последовательность,
[02:13:28.400 --> 02:13:30.400]  а я утверждаю, что это будет
[02:13:30.400 --> 02:13:32.400]  на самом деле последовательность
[02:13:32.400 --> 02:13:34.400]  не более чем логарифма арифметических
[02:13:34.400 --> 02:13:36.400]  прогрессий.
[02:13:40.400 --> 02:13:42.400]  Может быть, кто-нибудь из вас сейчас задачу
[02:13:42.400 --> 02:13:44.400]  вспомнит, но я сейчас сформулирую еще
[02:13:44.400 --> 02:13:46.400]  одну леммочку.
[02:13:46.400 --> 02:13:48.400]  Может, она не сильно нам поможет, конечно, в нашем
[02:13:48.400 --> 02:13:50.400]  алгоритме, но это одна из причин,
[02:13:50.400 --> 02:13:52.400]  в которой я люблю рассказывать этот алгоритм, потому что
[02:13:52.400 --> 02:13:54.400]  попутно вот такие крутые вещи появляются,
[02:13:54.400 --> 02:13:56.400]  которые пригодятся
[02:13:56.400 --> 02:13:58.400]  везде.
[02:14:02.400 --> 02:14:04.400]  Мистическое утверждение такое,
[02:14:08.400 --> 02:14:10.400]  пусть
[02:14:10.400 --> 02:14:12.400]  s равно, допустим,
[02:14:12.400 --> 02:14:14.400]  от 1 до n,
[02:14:18.400 --> 02:14:20.400]  и x равен
[02:14:22.400 --> 02:14:24.400]  ну, допустим,
[02:14:24.400 --> 02:14:26.400]  n минус
[02:14:26.400 --> 02:14:28.400]  префикс функция
[02:14:28.400 --> 02:14:30.400]  от n.
[02:14:34.400 --> 02:14:36.400]  Чего?
[02:14:36.400 --> 02:14:38.400]  Префикс функция.
[02:14:38.400 --> 02:14:40.400]  Ну, стандартное обозначение префикс функции буквой p.
[02:14:40.400 --> 02:14:42.400]  Да, или что
[02:14:42.400 --> 02:14:44.400]  то же самое, кстати, на самом деле
[02:14:44.400 --> 02:14:46.400]  вот это x еще можно заметить, что вот это число
[02:14:46.400 --> 02:14:48.400]  это минимальный период
[02:14:48.400 --> 02:14:50.400]  строки f.
[02:14:52.400 --> 02:14:54.400]  Ну, пока просто
[02:14:54.400 --> 02:14:56.400]  халявные утверждения.
[02:14:56.400 --> 02:14:58.400]  Пусть
[02:14:58.400 --> 02:15:00.400]  значит, x меньше
[02:15:00.400 --> 02:15:02.400]  модуль s.
[02:15:02.400 --> 02:15:04.400]  Тогда, очевидно,
[02:15:08.400 --> 02:15:10.400]  тогда как бы очевидно, что
[02:15:10.400 --> 02:15:12.400]  значит у нас
[02:15:12.400 --> 02:15:14.400]  строка x и x периодично,
[02:15:18.400 --> 02:15:20.400]  тогда и только тогда,
[02:15:20.400 --> 02:15:22.400]  когда s от
[02:15:22.400 --> 02:15:24.400]  x плюс 1 пум-пум n
[02:15:24.400 --> 02:15:26.400]  равно s от
[02:15:26.400 --> 02:15:28.400]  1 пум-пум n минус x.
[02:15:50.400 --> 02:15:52.400]  Вот.
[02:15:52.400 --> 02:15:54.400]  Ну, ничего.
[02:15:54.400 --> 02:15:56.400]  Такие вещи можно еще
[02:15:56.400 --> 02:15:58.400]  приупомянуть.
[02:15:58.400 --> 02:16:00.400]  Так вот.
[02:16:00.400 --> 02:16:02.400]  Но я просто из этого хочу сейчас могу
[02:16:02.400 --> 02:16:04.400]  и хочу немножко другое вывести.
[02:16:04.400 --> 02:16:06.400]  Что такое p от n?
[02:16:06.400 --> 02:16:08.400]  Префикс функция
[02:16:08.400 --> 02:16:10.400]  в n символе.
[02:16:10.400 --> 02:16:12.400]  Вот.
[02:16:12.400 --> 02:16:14.400]  Тогда я утверждаю,
[02:16:14.400 --> 02:16:16.400]  то есть из этого следует, что
[02:16:16.400 --> 02:16:18.400]  минимальное такое число x,
[02:16:18.400 --> 02:16:20.400]  ровно вот этой штуке.
[02:16:22.400 --> 02:16:24.400]  Ну, да.
[02:16:24.400 --> 02:16:26.400]  Логично, да?
[02:16:26.400 --> 02:16:28.400]  Но утверждение мое не в это.
[02:16:28.400 --> 02:16:30.400]  Это просто типа пока вроде должна быть простая вещь.
[02:16:32.400 --> 02:16:34.400]  Так вот.
[02:16:34.400 --> 02:16:36.400]  Мне хочется, конечно, вывести немножко другое.
[02:16:36.400 --> 02:16:38.400]  Ну, короче, да. Три раскраски тоже.
[02:16:38.400 --> 02:16:40.400]  Значит, пусть
[02:16:40.400 --> 02:16:42.400]  тогда я хочу сказать,
[02:16:42.400 --> 02:16:44.400]  пусть x меньше,
[02:16:44.400 --> 02:16:46.400]  чем
[02:16:46.400 --> 02:16:48.400]  то меньше либо равно, чем
[02:16:48.400 --> 02:16:50.400]  нечто. Вот сейчас подумаем,
[02:16:50.400 --> 02:16:52.400]  чего.
[02:16:52.400 --> 02:16:54.400]  Тогда
[02:16:56.400 --> 02:16:58.400]  тогда я утверждаю,
[02:17:00.400 --> 02:17:02.400]  тогда я утверждаю,
[02:17:02.400 --> 02:17:04.400]  что
[02:17:04.400 --> 02:17:06.400]  p от
[02:17:06.400 --> 02:17:08.400]  n
[02:17:08.400 --> 02:17:10.400]  равно
[02:17:10.400 --> 02:17:12.400]  да, вот тут, смотрите,
[02:17:12.400 --> 02:17:14.400]  тут мы можем написать, что
[02:17:14.400 --> 02:17:16.400]  p от n равно n-x.
[02:17:16.400 --> 02:17:18.400]  Да?
[02:17:18.400 --> 02:17:20.400]  Ну, то есть вот это вот и вот это,
[02:17:20.400 --> 02:17:22.400]  это одно и то же, да?
[02:17:22.400 --> 02:17:24.400]  Тогда я утверждаю, что p от p от
[02:17:24.400 --> 02:17:26.400]  это, то есть пока x, если x достаточно
[02:17:26.400 --> 02:17:28.400]  маленькая, то я могу жестко
[02:17:28.400 --> 02:17:30.400]  гарантировать, что p от p равно
[02:17:30.400 --> 02:17:32.400]  n-2x.
[02:17:44.400 --> 02:17:46.400]  Вот такое
[02:17:46.400 --> 02:17:48.400]  я неожиданно утверждаю.
[02:17:48.400 --> 02:17:50.400]  То есть оно тоже,
[02:17:50.400 --> 02:17:52.400]  то есть как бы следующее, то есть в принципе
[02:17:52.400 --> 02:17:54.400]  из этого следует так, что пока
[02:17:54.400 --> 02:17:56.400]  строчка s не станет достаточно маленькой,
[02:17:56.400 --> 02:17:58.400]  это p будет уменьшать
[02:17:58.400 --> 02:18:00.400]  длину на x,
[02:18:00.400 --> 02:18:02.400]  x, x, x, x, x.
[02:18:02.400 --> 02:18:04.400]  Наоборот. Да?
[02:18:04.400 --> 02:18:06.400]  Ну, на x, на x, на x, на x, на x, ну да.
[02:18:06.400 --> 02:18:08.400]  Что такое x? Ой, нет, сейчас,
[02:18:08.400 --> 02:18:10.400]  я имею ввиду.
[02:18:10.400 --> 02:18:12.400]  Ну,
[02:18:12.400 --> 02:18:14.400]  так p это требует
[02:18:14.400 --> 02:18:16.400]  скунуть, а? Да.
[02:18:20.400 --> 02:18:22.400]  Ну, утверждаю.
[02:18:34.400 --> 02:18:36.400]  Ой, сейчас.
[02:18:38.400 --> 02:18:40.400]  У нас есть
[02:18:40.400 --> 02:18:42.400]  есть вот у нас есть
[02:18:42.400 --> 02:18:44.400]  строчка s,
[02:18:46.400 --> 02:18:48.400]  в нем в ней
[02:18:48.400 --> 02:18:50.400]  p от n символов.
[02:18:50.400 --> 02:18:52.400]  Первые совпадают с p от n последнего.
[02:18:54.400 --> 02:18:56.400]  Б-б-б-б-б.
[02:18:56.400 --> 02:18:58.400]  Если x уменьшили одну,
[02:18:58.400 --> 02:19:00.400]  n пополам.
[02:19:00.400 --> 02:19:02.400]  Да. Ну, к сожалению,
[02:19:02.400 --> 02:19:04.400]  на p пополам, там можно,
[02:19:04.400 --> 02:19:06.400]  там не прокатить, может.
[02:19:06.400 --> 02:19:08.400]  Нет, там
[02:19:08.400 --> 02:19:19.620]  нет их смешали бы ровно и пополам это не многовато вот потому что не сейчас
[02:19:19.620 --> 02:19:36.100]  многовато у нас если x меньше чем это пополам то с это хотя бы 3 таких вот x откусим от конца один из них
[02:19:39.940 --> 02:19:41.460]  все еще будет хотя бы 2
[02:19:41.460 --> 02:19:58.180]  сейчас нет ну породите вот тут вот давайте аккуратненько доказывать а ты хорошо допустим
[02:19:58.180 --> 02:20:05.860]  то есть допустим мы пытаемся тут написать n пополам так то есть это означает что у нас
[02:20:05.860 --> 02:20:16.420]  что минус 1 ну пожалуйста хорошо прям что прям строго меньше но хорошо строго
[02:20:16.420 --> 02:20:31.500]  меньше это пополам хорошо так и что это нам дает да кто сказал нет это никто не сказал потому что
[02:20:31.500 --> 02:20:37.460]  может быть что это x x и еще чуть-чуть 3 x никто не обещал
[02:20:37.460 --> 02:20:50.540]  получается так да минимальный да то есть по большому счету вот это утверждение будет
[02:20:50.540 --> 02:20:55.020]  означать следующее что строки длины n-x минимальный период тоже x
[02:21:01.500 --> 02:21:06.980]  чего
[02:21:18.980 --> 02:21:30.340]  но но да но давайте так давайте давайте возьмем x прям очень-очень маленьким давайте вот давайте
[02:21:30.340 --> 02:21:37.300]  убедимся в том что как бы это верно если x прям очень-очень маленький чего да да совсем
[02:21:37.300 --> 02:21:43.340]  на 10 на 100 неважно то есть давайте выяснилось что вот у нас вот этот маленький бедный x и оказалось
[02:21:43.340 --> 02:21:53.100]  что вот это вот равно вот этому вот да видно да но если x прям очень маленький да то есть заметил
[02:21:53.100 --> 02:22:00.540]  что вся эта строка x периодичной как следствие вот эта строка тоже x периодичной то есть это
[02:22:00.540 --> 02:22:09.500]  означает что но вот то есть на но но но теперь вы скажете хорошо x период этой строки давай
[02:22:09.500 --> 02:22:26.300]  сейчас чего где справа слева что слева что какая разница
[02:22:26.300 --> 02:22:39.900]  начала строки у вас слева начала конечно слева но строка x да ну да нет ну как бы и ладно перейдем
[02:22:39.900 --> 02:22:45.100]  ну хорошо там да он конечно не является периодом то есть вот эта строка не является периодом строки
[02:22:45.100 --> 02:22:52.180]  в том смысле в котором мы с вами говорили конечно вначале ну x ну x маленький строка
[02:22:52.180 --> 02:23:02.540]  большая но вот эта строка без x ровно вот этой строке без x я имел ввиду x периодично
[02:23:02.540 --> 02:23:08.980]  слева то есть
[02:23:08.980 --> 02:23:20.860]  а почему x потому что мы все так ну потому что x это число не строка
[02:23:28.540 --> 02:23:35.500]  ну да то есть я как бы могу сказать что как бы раз строка x периодична строка она так вот вот
[02:23:35.500 --> 02:23:44.700]  это с точка такая же тут копии копии копии копии копии тут какой а это уже неважно нет причем
[02:23:44.700 --> 02:23:54.940]  где голем это вот вот это строка x периодично это сомнений не вызывает сейчас потому что любые
[02:23:54.940 --> 02:23:57.820]  два символа на расстоянии x внутри нее совпадают
[02:23:57.820 --> 02:24:04.780]  как у нас вот так
[02:24:04.780 --> 02:24:26.620]  я просто понимаю почему вы с конца то надо выйти но мне так удобно
[02:24:26.620 --> 02:24:44.260]  ну вообще ну вообще говорят да конечно но правда если x достаточно маленький то как бы там скорее
[02:24:44.260 --> 02:24:57.660]  всего это то есть просто это хотя но это да ну то есть да если если рассматривать период как
[02:24:57.660 --> 02:25:04.900]  строчку туда этот суффикс длины x он как скорее циклический сдвиг периода это да но здесь удобно
[02:25:04.900 --> 02:25:13.260]  мыслить что x период это смысле x число так что вот хорошо то есть вот эта строка x периодично
[02:25:13.260 --> 02:25:19.100]  тут вроде сомнений нет все что нам теперь то есть это означает что в ней кандидат на префикс
[02:25:19.100 --> 02:25:26.140]  функцию это то есть раз вот длина вот длина вот этой статьи это вот n-6 тогда получается что
[02:25:26.140 --> 02:25:44.740]  n-2 x это кандидат на ее префикс функции да да именно поэтому да теперь выскакать вопрос
[02:25:44.740 --> 02:26:03.540]  а почему у нее не может быть большей префикс функции а кто сказал что он делится никто это
[02:26:03.540 --> 02:26:15.260]  вообще не сказал n delete x не обязана а какая нам разница но
[02:26:33.540 --> 02:26:43.700]  мы говорим что первые
[02:26:43.700 --> 02:27:06.020]  но если x минимальный период формально говоря то есть я так сказал x это то есть строка x
[02:27:06.020 --> 02:27:12.540]  периодично тогда и только тогда когда n-6 кандидат на префикс функции вот так скажем
[02:27:14.540 --> 02:27:21.460]  но вот и x минимальный минимальный такой что строка x периодично тогда и только
[02:27:21.460 --> 02:27:26.820]  тогда когда n-6 это максимальный среди кандидатов на префикс функции то есть
[02:27:26.820 --> 02:27:37.780]  собственно сама префикс функции так не умирать я не понимаю как все можно осознать все понятно
[02:27:37.780 --> 02:28:01.420]  нету что именно я не знаю ну мы пока мы говорим в процессе но дальше мы говорим так пусть у
[02:28:01.420 --> 02:28:06.420]  нас x прям совсем совсем совсем мало потом наша задача будет подогнать там насколько оно должно
[02:28:06.420 --> 02:28:11.980]  быть мало чтобы наши рассуждения прокатывала но пусть и прям очень мало тогда мы говорим
[02:28:11.980 --> 02:28:17.180]  следующее что строка мы знаем что строка x периодично тогда это означает что вот этот
[02:28:17.180 --> 02:28:26.580]  префикс длины n-6 он тоже x периодичен отсюда следует что n-2 x это кандидат на префикс
[02:28:26.580 --> 02:28:34.940]  функцию вот в точке n-6 логично да то есть следовательно вот в этом месте больше либо равно можно
[02:28:35.260 --> 02:28:43.980]  остается только один вопрос а почему не может быть действительно строго больше почему тут не
[02:28:43.980 --> 02:28:51.780]  может оказаться какой-нибудь там n-6 минус и как почему здесь не может оказаться какого-нибудь
[02:28:51.780 --> 02:29:08.380]  более мелкого периода игрок который меньше икс но вот но сейчас прийдет то есть если у нас
[02:29:08.380 --> 02:29:12.620]  все совсем маленько это тогда заметим следующее что если тут есть какой-то период игрок то
[02:29:12.620 --> 02:29:18.420]  утверждается что это строке игрок период не только вот этого префикса но и всей строки
[02:29:21.780 --> 02:29:33.380]  вот почему потому что как бы игрок это тогда период вот этой строки и вот этой строки а
[02:29:33.380 --> 02:29:40.500]  тогда получается но тут основная идея что так как игрок лежит внутри прям целиком внутри
[02:29:40.500 --> 02:29:47.300]  пересечения то получается что игрок и то тогда получается что вся строка игрок периодично
[02:29:47.300 --> 02:29:54.420]  я не понимаю почему у вас нормально склеиваются если игрок не делит если длина игрок не делит
[02:29:54.420 --> 02:30:04.460]  длину строки ну вот мне очень сложно понять какое вот какая у тебя но какая у тебя идея внутри
[02:30:04.460 --> 02:30:13.020]  прям так упирает тебя в это деление но в плане если y не является делителем длины вот этой длины
[02:30:13.020 --> 02:30:24.740]  n-6 ну и что тогда мы когда пойдем справа отчитываясь не состыкуемся с тем что мы
[02:30:24.740 --> 02:30:34.060]  слева отчитывали что вот что означает словосочетание не состыкуемся с тем что мы отчитывали слева но не
[02:30:34.060 --> 02:30:40.300]  состыкуемся так так бы тут тут как бы да идет идет идет идет идет и да вот тут какая-то
[02:30:40.300 --> 02:30:48.540]  частичка будет да вот здесь пересечения тоже мы знаем что следующий игрок символов строке вот
[02:30:48.540 --> 02:30:58.260]  если мы направо пойдем ну пойдем еще следующий игрок символ нас совпадает потому что у нас
[02:30:59.260 --> 02:31:11.780]  ну и что ну я утверждаю что не совпадают почему потому что раз это строка игр периодично то и
[02:31:11.780 --> 02:31:17.900]  это строка игр периодично потому что они тупо они тупо равны следовательно вот эти игр символов
[02:31:17.900 --> 02:31:38.340]  равны вот этим игр символом вот сейчас но тогда получается сейчас тогда они получаются не
[02:31:38.340 --> 02:31:48.180]  ровные почему или вы утверждаете что если игре чем-нибудь период но да нет просто да да нет
[02:31:48.180 --> 02:31:54.420]  но то уже не причем это уже не важно нет уже не важно вау потому что важно уже на уровне что-то
[02:31:54.420 --> 02:31:59.780]  игр как это период всей строке s а тогда это означает что у нас неправильно посчитан на префикс
[02:31:59.780 --> 02:32:06.260]  функция для всей строки я скажу почему важно у нас у нас первые самые первые вот самые последние
[02:32:06.260 --> 02:32:15.540]  y символов строке x если мы игрек мне если мы вот этот вот остаток длины x если вот это
[02:32:15.540 --> 02:32:23.060]  значит остаток длины x не делится на y то что а то получится что у нас первые игрек символов
[02:32:23.060 --> 02:32:30.740]  вот это вот левые строки на они не совпадают с первыми они не совпадают первыми игрек символов
[02:32:30.740 --> 02:32:37.380]  той же самой строки вот этой двинтой которая правая еще противоречит ну что ну из этого
[02:32:37.380 --> 02:32:40.980]  ну и следователь может следует что там ну может там следует что там еще у них какой-то период
[02:32:40.980 --> 02:32:52.020]  то есть мы на самом деле доказали что что игрек обязан быть ну да не обе нет да господи это уже
[02:32:52.420 --> 02:32:58.100]  все равно уже перемасло масляные уже там есть потому что мы уже сказали что как бы игрек является
[02:32:58.100 --> 02:33:03.420]  периодом всей строки с это уже противоречие с тем что минимальным таким периодом был x все уже
[02:33:03.420 --> 02:33:10.060]  мы пофейли я же правильно понимаю что тогда у нас есть в том числе период который является
[02:33:10.060 --> 02:33:21.820]  делителя который является делителем но там нету можно и так сказать да что если у тебя есть два
[02:33:21.820 --> 02:33:26.180]  периода и они достаточно мелкие например там меньше чем и пополам то как бы есть перед то
[02:33:26.180 --> 02:33:33.460]  тогда у строки есть период который является их нодом да это правда ну вот так теперь
[02:33:33.460 --> 02:33:37.620]  есть какой-то вопрос насколько маленьким должен быть их чтобы это рассуждение про канала
[02:33:49.780 --> 02:33:53.660]  ну что хотя бы это рассуждение про канала может быть есть более сильные я не знаю
[02:33:56.980 --> 02:34:06.960]  ну у нас тонкий тонкий момент был на самом деле как вы доказывали что игрок период не только
[02:34:06.960 --> 02:34:13.060]  вот этой строки но и соответственно вот этой но и всей строке мы этим мы на самом деле если
[02:34:13.060 --> 02:34:20.620]  внимательно посмотреть только а как бы вывели что игрок это период всей строки на самом деле
[02:34:20.620 --> 02:34:24.620]  Мы воспользовались тем, что этот Y целиком попадает в пересечение.
[02:34:33.620 --> 02:34:40.620]  Если вот этот какой-то период Y попадал внутрь пересечения,
[02:34:40.620 --> 02:34:44.620]  тогда мы его как бы влево можем внутри этой строки размножить, то есть раскопировать.
[02:34:44.620 --> 02:34:46.620]  И внутри этой строки раскопировать вправо.
[02:34:46.620 --> 02:34:49.620]  Отсюда исследуют, что строка полностью играет периодично.
[02:34:50.620 --> 02:34:52.620]  А если не впадал, то что?
[02:34:52.620 --> 02:34:55.620]  Ну тогда не очень понятно.
[02:34:55.620 --> 02:35:02.620]  Но тогда может оказаться, что есть какие-то два символа на расстоянии Y.
[02:35:02.620 --> 02:35:05.620]  Один из которых находится здесь, а другой здесь.
[02:35:05.620 --> 02:35:07.620]  И почему они между собой равны?
[02:35:07.620 --> 02:35:09.620]  Непонятно от слова совсем.
[02:35:09.620 --> 02:35:19.620]  Поэтому желательно чтобы игры были здесь, но и желательно чтобы X тоже должен быть здесь.
[02:35:19.620 --> 02:35:24.620]  Поэтому мы здесь для надежности пишем N поделить на 3.
[02:35:24.620 --> 02:35:30.620]  Вот, но в принципе это уже достаточно мощно.
[02:35:30.620 --> 02:35:32.620]  То есть что это в принципе означает?
[02:35:32.620 --> 02:35:36.620]  Это означает, что если вы будете из точки N скакать по префикс-функции,
[02:35:36.620 --> 02:35:41.620]  то вы говорите, что на первом шаге у вас префикс-функция уменьшила N на X.
[02:35:41.620 --> 02:35:49.620]  Тогда утверждается, что у вас будет арифметическая прогрессия шагом X как минимум до тех пор,
[02:35:49.620 --> 02:35:53.620]  пока вы не дойдете до числа меньше чем 3X.
[02:35:53.620 --> 02:36:01.620]  И только там может быть у вас шаг поменьше, там станет поменьше.
[02:36:01.620 --> 02:36:03.620]  Вот такая вот неожиданная идея.
[02:36:03.620 --> 02:36:11.620]  В данном случае это нам нужно было чтобы рассмотреть интересную идею,
[02:36:11.620 --> 02:36:14.620]  которая в некоторых задачах на строчке неожиданно проявляется.
[02:36:14.620 --> 02:36:20.620]  Что когда вы скачете по префикс-функциям, то на самом деле получается выйти с крышки,
[02:36:20.620 --> 02:36:25.620]  а потом вы скачете по префикс-функциям, а потом вы скачете по префикс-функциям.
[02:36:25.620 --> 02:36:28.620]  Неожиданно проявляется, что когда вы скачете по префикс-функциям,
[02:36:28.620 --> 02:36:32.620]  то на самом деле получается выйти с последовательности от N до 0,
[02:36:32.620 --> 02:36:36.620]  можете разбить на несколько арифметических прогрессий.
[02:36:36.620 --> 02:36:42.620]  И даже не просто несколько, а их не более чем O от логарифма.
[02:36:42.620 --> 02:36:45.620]  Каждый следующий делитель X.
[02:36:45.620 --> 02:36:48.620]  Каждый следующий делитель.
[02:36:48.620 --> 02:36:51.620]  Нет, ну если X мелкий, конечно.
[02:36:51.620 --> 02:36:54.620]  Но там...
[02:36:54.620 --> 02:36:58.620]  После первого, например, шага, когда X стал меньше, чем N3.
[02:36:58.620 --> 02:37:01.620]  Нет.
[02:37:01.620 --> 02:37:03.620]  Следующего будет делителем предыдущего, так?
[02:37:03.620 --> 02:37:06.620]  Ты знаешь, нет, это не факт.
[02:37:06.620 --> 02:37:12.620]  Потому что бывает, например, строчка A, A, A, там какая-нибудь, там A, A,
[02:37:12.620 --> 02:37:15.620]  сейчас как-то тут вот можно...
[02:37:15.620 --> 02:37:18.620]  Нет или нет? Нет, ну...
[02:37:19.620 --> 02:37:24.620]  Хотя да, если X в какой-то момент был длиной меньше, хотя нет.
[02:37:26.620 --> 02:37:29.620]  Ну, может это неправда, но откуда тогда берется логарифм?
[02:37:29.620 --> 02:37:31.620]  Логарифм берется оттуда.
[02:37:31.620 --> 02:37:34.620]  Что для того, чтобы X перестал быть меньше либо равно N3,
[02:37:34.620 --> 02:37:40.620]  вы должны поскакать таким образом, чтобы A, у вас длина строки уменьшилась хотя бы в полтора раза.
[02:37:42.620 --> 02:37:44.620]  Нет?
[02:37:44.620 --> 02:37:46.620]  Хотя ладно, ну давай так.
[02:37:46.620 --> 02:37:48.620]  Изначально мог быть очень большой.
[02:37:54.620 --> 02:37:56.620]  Изначально мог быть очень большой.
[02:37:56.620 --> 02:37:58.620]  Сейчас.
[02:37:58.620 --> 02:38:00.620]  Нет, ну как очень большой?
[02:38:16.620 --> 02:38:18.620] орошо
[02:38:38.620 --> 02:38:41.620]  Да, тогда замечаем, что то к X ты будешь...
[02:38:41.620 --> 02:38:54.660]  ты будешь ну вот но вот тогда сколько ты будешь скакать по иксу но вот ну вот то есть ну то есть
[02:38:54.660 --> 02:39:00.500]  шаг вот то есть пока у нас тут да пока мы тут не дойдем до точки когда он меньше чем 3x то есть
[02:39:01.100 --> 02:39:08.340]  но вот мы ждем когда пока икс меньше чем на 3 но да нет но да сейчас
[02:39:08.340 --> 02:39:22.380]  нет ну типа того да нет ну не совсем нет но там может так случиться что если уже икс стал больше
[02:39:22.380 --> 02:39:26.740]  то есть икс стал больше чем вот это строка на 3 то икс мог уже и поменяться он мог неожиданно
[02:39:26.740 --> 02:39:40.260]  уменьшится сейчас ну давайте допилим да так нет ну просто скажи сейчас скоро но скажем так
[02:39:40.260 --> 02:39:52.300]  сколько то скачков мы сделали да сколько то скачков мы сделали нету если не были прям очень
[02:39:52.300 --> 02:39:56.460]  маленькими то понятно что там видимо длина строки уже во сколько-то раз доуменьшилось
[02:39:56.460 --> 02:40:08.700]  но если икс был ну давай давай ну давай так если смотри давай так если икс было меньше
[02:40:08.700 --> 02:40:16.860]  либо ровно чем n на 6 то тогда получается наши скачки видимо там хотя бы у вас скачки хотя
[02:40:16.860 --> 02:40:24.260]  видимо хотя бы половину строки да съели да да то есть если икс меньше либо ровно
[02:40:24.260 --> 02:40:30.540]  нделит на 6 то значит в два раза уменьшили а если он больше то на каждом шаге мы уменьшаем в 6
[02:40:30.540 --> 02:40:36.460]  пятых раз да так что лога это логарифом получается хоть не потому оснований потому хотелось бы но
[02:40:36.460 --> 02:40:41.860]  суть такая но тем более что как бы это мы еще там то есть может быть на самом деле эту лему как-то
[02:40:41.860 --> 02:40:49.500]  может чуть-чуть усилить вот но такая вот идея есть здесь периодически она нет нет да и проявляется
[02:40:49.500 --> 02:41:04.660]  вот так ну что сколько там времени то вообще ой ой ой так ну хорошо так ну ладно это просто
[02:41:04.660 --> 02:41:10.140]  по времени нам вроде пришло время тоже немножко перерывы сделать или не пришло
[02:41:10.140 --> 02:41:15.980]  а то я нет нет судя по вам пришло так что тогда я конечно не ожидал что это вам на столько взорвет
[02:41:15.980 --> 02:41:22.420]  мозг потому что мне это не казалось прям сложными вещами но но видимо видимо вы с ними там совсем не
[02:41:22.420 --> 02:41:27.060]  сталкивались нет ну мы с ними сталкивались сколько угодно раз но они все равно интенсивно абсолютно
[02:41:27.500 --> 02:41:34.380]  да странно нет страны этом запросто на то что она в сервисе там дают задачи где вам вот это надо
[02:41:34.380 --> 02:41:41.540]  либо знать либо знать либо придумать но на все все бывают задачи на строчке где вот подобные там
[02:41:41.540 --> 02:41:52.180]  ну да ну вы же ну вы же крутой вы же не так есть подозрение что вы вы возможно это не совсем те
[02:41:52.180 --> 02:42:00.100]  люди которые там зацепили последнего призера и ушли но последний повидло до нету обычно это
[02:42:00.100 --> 02:42:04.660]  уже уровень где как бы вроде как бы там уже надо какие-то очень не тривиальные группы уже на
[02:42:04.660 --> 02:42:10.820]  все если надо брать можно брать не тривиальные группы на всех темах которых ты селёшь ну так
[02:42:10.820 --> 02:42:14.740]  смотри какие темы дадут вон на последнем серии был скандал что вам там надо что-то что там
[02:42:14.740 --> 02:42:21.820]  для детей закидали конструктивами чего ну тебе кайфа кому-то вот кто-то наоборот взвыл я целый
[02:42:21.820 --> 02:42:26.260]  день я там многие годы ходил учил там все эти модификации деревья потреска в дикарте к и так
[02:42:26.260 --> 02:42:30.900]  далее она выяснила что я должен знать только дфс и уметь думать про то зачем я учился столк
[02:42:30.900 --> 02:42:40.820]  да нет вот вот поэтому я поржал когда я буквально такой комментарий прочитал на
[02:42:40.820 --> 02:42:50.820]  крутфорсе поиск идеи один раз ну хотя ну я не знаю нет ну как по мне я не знаю то есть
[02:42:50.820 --> 02:42:56.060]  думать когда-то на липяде дают задачи в которые надо думать и придумать что какую-то новую идею не
[02:42:56.060 --> 02:43:07.860]  пользоваться старыми это нормально ну окей так давайте перерыв нет поэтому это с чего мы
[02:43:07.860 --> 02:43:15.220]  начали функция является функцией от же если да можно так сказать что мы с этого вообще начали
[02:43:15.220 --> 02:43:24.220]  да ну ляма периодичности важна дальнейшее утверждение нет это скорее просто ответвление
[02:43:24.220 --> 02:43:31.740]  которое просто хотелось тоже обсудить значит смотрите значит просто из леммы о периодичности
[02:43:31.740 --> 02:43:36.660]  но это просто такое общие там общие такое очень важное утверждение действительно про историю
[02:43:36.660 --> 02:43:47.980]  строк на самом деле из этой леммы есть маленькое приятное следствие значит следствие из леммы
[02:43:47.980 --> 02:44:07.780]  периодичности но вот но вот я его сформулирую так или не сформулирую различные префиксные периоды
[02:44:17.980 --> 02:44:47.060]  строки с различаются не менее чем в к-1 раз да где карта 4 да возвращаемся в этот
[02:44:47.060 --> 02:44:56.820]  сладостный чарующий упоительный мир где кара вну 4 есть понятие префиксный период так что
[02:44:56.820 --> 02:45:07.100]  давайте вспоминаем так что давайте аккуратненько вспоминаем что такое префиксный период так все
[02:45:07.100 --> 02:45:24.940]  сразу все ушел да так давайте так давайте да сначала вспомним еще что такое префиксный
[02:45:24.940 --> 02:45:34.020]  период значит мы говорим что у нас строка что там какая-то строка длины п1 префикс является
[02:45:34.020 --> 02:45:41.220]  префиксным периодом если тут если она тут если у нее строка я начинается с в нашем случае
[02:45:41.220 --> 02:45:51.900]  четырех экземпляров этой строки ну в смысле к и при этом еще важно что этот префикс базовый что
[02:45:51.900 --> 02:46:00.620]  такое базовая строка но напоминаю строка это базовый если ее нельзя распилить на несколько
[02:46:00.620 --> 02:46:08.380]  копий одного и того же причем на этот раз четких копий без там всяких лишних остатков да то есть
[02:46:08.380 --> 02:46:12.620]  мы помним да что для того чтобы строка была п периодично не обязательно чтобы длина делилась
[02:46:12.620 --> 02:46:17.700]  на п то есть она то есть это то есть строка п периодично это означает что строку можно распилить
[02:46:17.700 --> 02:46:22.700]  на кусочек на одинаковые кусочки по п и мелкий кусочек в конце который является префиксом
[02:46:22.700 --> 02:46:29.500]  этого кусочка да вот по большому счету так но мы говорим что строка не является базовой когда
[02:46:29.500 --> 02:46:36.020]  ее можно распилить на кусочки без на одинаковые кусочки без этого лишнего остатка вот ну как бы
[02:46:36.020 --> 02:46:41.220]  если не буду переписывать формальное определение да оно у вас и так записано уже так вот и вот
[02:46:41.220 --> 02:46:45.860]  у нас ключевую роль играет понятие префиксный период и мы говорим что эти префиксные периоды
[02:46:45.860 --> 02:46:57.420]  различаются не менее чем в к-1 раз ну подлине естественно то есть другими словами что если
[02:46:57.420 --> 02:47:09.340]  у вас есть префиксные периоды п-1 и п-2 причем п-1 меньше п-2 то это будет означать что ну вот
[02:47:09.340 --> 02:47:18.060]  то есть это будет означать что п-2 больше либо равно чем п-1 умножить на к-1 это нам будет как-то
[02:47:18.060 --> 02:47:25.140]  помогать но прежде чем нам будет помогать а давайте поймем а почему вообще это так
[02:47:25.140 --> 02:47:40.380]  и казалось бы причем тут лема а периодичность
[02:47:40.380 --> 02:47:54.580]  ну давайте посмотрим допустим значит давайте как всегда как у нас говорят на латыни ато абсурда
[02:47:54.580 --> 02:48:01.500]  значит пусть у нас оказалось что п-1 меньше п-2 но п-2 при этом меньше либо равно чем к-1
[02:48:01.500 --> 02:48:15.900]  п-1 что это означает означает следующее что жил был п-2 вот он маленькую строчку нарисовал
[02:48:15.900 --> 02:48:24.460]  вот но нам там да что там в конце нас вообще не интересует нас интересует вот эти четыре
[02:48:24.460 --> 02:48:40.620]  копии п-2 ну типа предположим что вот так не отрицание хорошо хорошо можно пожалуйста пожалуйста
[02:48:40.620 --> 02:48:52.340]  ага именно так значит смотрите сейчас давайте включаем логику значит предположим выяснилось
[02:48:52.340 --> 02:49:05.420]  что п-2 меньше либо равно чем к-1 п-1 что это в принципе означает то есть значит то есть это
[02:49:05.420 --> 02:49:12.580]  означает в принципе что п-2 но вот что в 3 копии п-1 п-2 точно уложится то есть это вот будет
[02:49:12.580 --> 02:49:21.260]  выглядеть примерно то есть вот п-1 будет выглядеть примерно вот так вот
[02:49:21.260 --> 02:49:38.660]  п-2 укладывается вот такое ну в принципе из этого следует что четыре копии п-1 прекрасно
[02:49:38.660 --> 02:49:49.940]  уложится в две копии п-2 правда что нет да нет у вас могло быть п-2 меньше чем 2 п-1
[02:49:49.940 --> 02:49:59.420]  чего п-2 не могло быть меньше чем п-1 сейчас п-2 меньше чем 2 п-1 а
[02:49:59.420 --> 02:50:13.580]  ну хорошо да это мог так это могло быть так но только только это из цикличи и
[02:50:13.580 --> 02:50:24.580]  шо это нам даст вот нет ну по большому счету нас ну по большому счету ладно для нас это
[02:50:24.580 --> 02:50:33.620]  интересует следующее то есть это то есть там нас это интересует в принципе таким образом то
[02:50:33.620 --> 02:50:39.820]  есть смотрите это 3 давай так три копии п-1 укладываются в две копии п-2 правда
[02:50:39.820 --> 02:50:45.780]  тоже не факт почему что нас по два может быть меньше чем полтора по один
[02:50:45.780 --> 02:50:58.660]  никакого ограничения снизу нет может быть по два это по один плюс один нет так ну хорошо ладно
[02:50:58.660 --> 02:51:07.900]  хорошо ладно п-2 укладывается в три копии п-1 это точно верно да ну вот
[02:51:07.900 --> 02:51:16.180]  отлично но тогда это но вот но тогда можем ли мы из этого сделать вывод можем ли мы из
[02:51:16.180 --> 02:51:26.540]  этого тогда сделать вывод что тогда получается 4 но хотя делаем ли мы из этого вывод так
[02:51:26.540 --> 02:51:38.900]  так сейчас вот как нам ну понятно то есть идея в общем понятно хочется конечно сказать что вот
[02:51:38.900 --> 02:51:47.660]  это вот вся строчка она конечно и п-2 периодичный п-1 периодично ну ну тогда доказательство будет
[02:51:47.660 --> 02:51:54.420]  но тогда будет доказательство работать так же если мы докажем что это строка п-1 периодично то
[02:51:54.420 --> 02:52:00.660]  тогда она получится п-1 периодично п-2 периодично а как следствие она гцд от п-1 и п-2 периодично
[02:52:00.660 --> 02:52:06.220]  причем это гцд меньше чем п-2 и мы как следствие получим противоречие с тем что п-2 базовая
[02:52:06.220 --> 02:52:22.300]  вот то есть вот в чем тут возникнет идея да мы доказываем следствие да мы очень хотим доказать
[02:52:22.300 --> 02:52:26.380]  что действительно из вот энот то есть очень хочется сказать что действительно вот у нас
[02:52:26.380 --> 02:52:37.500]  вся вот эта строка она п-1 периодично ну или хотя бы ну то есть по большому счету нет нам
[02:52:37.500 --> 02:52:43.340]  но нам достаточно доказать на самом деле что префикс длины п-2 плюс п-1 точно п-1 периодический
[02:52:43.340 --> 02:52:52.700]  нам на самом деле этого достаточно доказать спрашивается почему это ну вот ну тут идея
[02:52:52.700 --> 02:53:00.580]  такая 4 п-1 ки они то есть вот это то есть 4 п-1 ки но вот ну тут да тут конечно видимо я
[02:53:00.580 --> 02:53:09.700]  не вот но тут действительно идея такая что п-2 укладывается в 3 п-1 ки да то есть значит вот
[02:53:09.700 --> 02:53:17.300]  это вот строка то есть вот эта строка она как бы получается п-1 периодично и п-2 периодично да
[02:53:17.300 --> 02:53:26.900]  сейчас топ что происходит а мы говорим что у нас префикс п-2 а по два сейчас по два так это
[02:53:26.900 --> 02:53:32.220]  префиксные периоды значит у нас картинка выглядит ровно так ну поводлю того что там
[02:53:32.220 --> 02:53:39.900]  п-1 может конечно быть подлиннее да но вот этот ну вот это вот а теперь припишем вот сюда еще
[02:53:39.900 --> 02:53:50.060]  вот эти п-1 символов заметим что но вот что строка останется п-1 периодичной да то есть да то есть
[02:53:50.060 --> 02:53:57.380]  вот это вот строка она п-1 периодично и п-2 периодично а еще вот это вот длина она больше
[02:53:57.380 --> 02:54:08.180]  либо равна чем п-1 плюс п-2 вывод то есть отсюда следует что вот эта вот строка то есть вот эта
[02:54:08.180 --> 02:54:21.260]  строка она нод п-1 п-2 периодично как мы выяснили да но тогда отсюда следует что вот эта строка вот
[02:54:22.260 --> 02:54:34.460]  она получается нод п-1 п-2 периодично только маленькая проблема внимание то есть у нас
[02:54:34.460 --> 02:54:40.180]  есть строка п-2 и у нее есть период который меньше п-2 меньше ну потому что п-1 меньше
[02:54:40.180 --> 02:54:51.060]  п-2 и этот нод и причем это строка п-2 делится на этот период да следовательно мы получаем
[02:54:51.060 --> 02:55:06.500]  противоречие с тем что п-2 базовая ну да то есть мы то есть мы рассмотрели префикс длины 4 п-1
[02:55:07.300 --> 02:55:14.700]  да мы показали две вещи во-первых это строка п-1 периодично и п-2 периодично но очевидно
[02:55:14.700 --> 02:55:21.620]  потому что это префиксы а во-вторых заметили что 4 к п-1 это ну то есть мы заметили что вот давайте
[02:55:21.620 --> 02:55:28.820]  я допишу к п-1 это больше чем п-1 плюс п-2 больше либо равно почему потому что у нас
[02:55:28.820 --> 02:55:37.900]  п-2 более меньше либо равно как минус 1 п-1 и вот следовательно получается что вся вот эта
[02:55:37.900 --> 02:55:44.780]  строка имеет периоды и п-2 и п-1 и она достаточно длинная тогда получается что вся эта строка
[02:55:44.780 --> 02:55:54.740]  имеет период гцд от п-1 п-2 то есть получается и префикс длины п-2 тоже имеет такой период но
[02:55:54.740 --> 02:56:03.740]  этот период является делителем п-2 и меньше п-2 то есть следовательно этот эту строчку можно
[02:56:03.740 --> 02:56:11.300]  распилить на несколько одинаковых кусочек и чем без остатков то есть кстати обратите внимание мы
[02:56:11.300 --> 02:56:18.060]  здесь даже не пользовались тем что по один на самом деле вообще что вот это вот по один это вообще
[02:56:18.060 --> 02:56:28.500]  базовая строка то есть по большому счету мы утверждения могли сформируют так пусть п-1
[02:56:28.500 --> 02:56:39.300]  меньше п-2 пусть п-2 это префиксный период рич от п-1 там больше либо равно чем там 4 п-1 тогда
[02:56:39.300 --> 02:56:48.380]  п-1 он меньше чем п-2 поделить на там к-1 то есть на самом деле можно было даже в таком
[02:56:48.380 --> 02:57:00.060]  более сильном виде это сформирует вот понятно вот ты прям на языке интегралов от записываешь
[02:57:00.060 --> 02:57:13.500]  о господи о господи ну окей ну нет ну смотри конечно я не особо я не особо верю что это
[02:57:13.500 --> 02:57:22.700]  можно воспринять и там параллельно с дз но а но это да ну хорошо ладно ну в принципе да ладно
[02:57:22.700 --> 02:57:35.900]  если все понял 15 минут назад то окей донесите хорошо классно а ну да да да нету если тебе
[02:57:35.900 --> 02:57:43.020]  поможет потом это сделать то окей конечно да вот так в общем такая такая вот интересная
[02:57:43.020 --> 02:57:52.780]  лемма которая нам будет помогать так у меня еще или мы есть так хорошо по-фиксу и периоды
[02:57:52.780 --> 02:58:01.980]  поняли но как бы значит смотрите сейчас тут будет таки слюшеке другую другую лему сейчас их будет
[02:58:01.980 --> 02:58:30.260]  ну сейчас хуже сейчас еще одно понятие введу значит еще одно понятие было нету как было я по
[02:58:30.260 --> 02:58:39.220]  моему еще не обозвал это шифтом хотя ровно такую вещь мы обсудили да то есть по-форошему я должен
[02:58:39.220 --> 02:58:45.300]  сказать что шифт от ку это минимальное то есть минимальное такое число л что префикс длины
[02:58:45.300 --> 02:58:56.420]  л это период префикса длины ку строки с ну потому что сдвиг типа ну типа если сдвинешь строчку на
[02:58:56.420 --> 02:59:02.860]  ку типа там все совпадает будет вот ну видимо они-то так воспринимают и в принципе кажется
[02:59:02.860 --> 02:59:30.860]  интуитивно это логично так вот значит то есть это такой да то есть можно сказать что шифт от
[02:59:30.860 --> 02:59:39.580]  ку это минимальный период префикса длины ку строки с так вот мистическая лемма возможно тупая
[02:59:39.580 --> 02:59:50.100]  ну потому что по фирмировке она какая-то тупая если шифт с от ку меньше либо равен ку поделить
[02:59:50.100 --> 03:00:15.660]  на к то с от 1 шифт с от ку префиксный период а ну ладно тупая но не совсем вот такая вот
[03:00:16.660 --> 03:00:35.420]  нет ну действительно давайте просто вот тут доказательств по сути следует из картинки да
[03:00:35.420 --> 03:00:41.220]  вот он ку и как бы что значит шифт шифт это означает что вот вот это совпадает с вот этим да то есть
[03:00:41.220 --> 03:00:46.020]  вот сдвиг вот на этот вот шифт но в принципе этот сдвиг означает что вот тут вот вот эти вот
[03:00:46.020 --> 03:00:51.380]  шифт шифт шифт вот столько совпадает вот это неравенство означает что как минимум на четыре
[03:00:51.380 --> 03:00:58.260]  копии мы тут наткнемся да ну в смысле на к копии остается только одно потому что для того чтобы
[03:00:58.260 --> 03:01:02.620]  доказать что это префиксный период нужно еще доказать что это строка не является там случайно
[03:01:02.620 --> 03:01:21.380]  то есть она что она является базовой ну да ну вот ну в принципе да заметим что вот этот вот
[03:01:21.380 --> 03:01:26.620]  шифт он обязан быть базовой строчкой он да он обязан быть базовой почему потому что если
[03:01:26.620 --> 03:01:31.620]  ее можно распилить там скажем на три копии ну потому что мне так удобнее рисовать там если их будет
[03:01:31.620 --> 03:01:38.380]  57 суть будет та же вот то тогда мы заметим что мы шифт могли бы сделать на одну из этих копий
[03:01:38.380 --> 03:01:46.620]  видно да прям явно в виде поэтому да кстати да маленькое приятное свойство как бы эти префикс
[03:01:46.620 --> 03:02:08.940]  длины шифт отку заведомо базовая строка да что не может не радовать нет как то делительку вот
[03:02:08.940 --> 03:02:14.700]  этот вот шифт он конечно не обязан быть никаким делителем ку тогда почему когда мы вот эти
[03:02:14.700 --> 03:02:24.700]  маленькими шашками а потому что что такое базовая строка мы говорим что строка не является базовой
[03:02:24.700 --> 03:02:29.740]  если ее можно распилить на строчке так что вот именно перескока перескока через границу не
[03:02:29.740 --> 03:02:38.260]  будет нет нет я имею в виду вот там в конце вот здесь а так а потому что потому что у нас здесь
[03:02:38.580 --> 03:02:45.340]  есть перескок через границу ведь у нас тут кончик поэтому раз тут как бы распил по
[03:02:45.340 --> 03:02:57.900]  середине то и тут мог быть распил по середине непонно какая разница ну что строка все равно от
[03:02:57.900 --> 03:03:09.940]  этого не перестает быть вот столько периодичный ну конечно вот вот так что вроде да не самая
[03:03:09.940 --> 03:03:17.260]  сложная лемма но чуть-чуть почесаться пришлось так сейчас будет такая лемма немножко странного вида
[03:03:17.260 --> 03:03:32.060]  сейчас будет ну вот да значит так вот если оказалось что s от 1 до l это префиксный период
[03:03:32.060 --> 03:03:52.100]  с при фиксный период с то то что то я то тогда эквивалентные следующие утверждения значит
[03:03:52.100 --> 03:04:02.900]  первое утверждение l равно shift значит и не просто равно этот shift ну то есть для какого-то q
[03:04:02.900 --> 03:04:09.020]  получается утверждается следующее что значит l являет то есть это это этот префиксный период
[03:04:09.020 --> 03:04:16.620]  является для кого-то с двигом и этот и более того еще и с вот таким приятным свойством тогда и
[03:04:16.620 --> 03:04:37.580]  только тогда когда к умножить на l меньше либо равно q меньше либо равно reach вот такой вот красота
[03:04:37.580 --> 03:04:58.340]  но то есть утверждается ну то есть там говорит так пусть у нас s 1 l префиксный период с пусть
[03:04:58.340 --> 03:05:05.580]  у нас есть какой-то q да тогда утверден вот и пусть есть какой-то вот q видимо от одного
[03:05:05.580 --> 03:05:12.140]  до модулес тогда вот эти два утверждения верны тогда и только тогда когда верны вот эти два
[03:05:12.140 --> 03:05:40.660]  утверждения да да видимо правильно писать да ну так-то да ну как сказать на самом деле
[03:05:40.660 --> 03:05:45.540]  можно взять его и маленький потому что для q для слишком маленьких q эти утверждения оба
[03:05:45.540 --> 03:05:52.900]  не верны ровно в силу того что слику слишком маленькая так же я бы наверное вот так
[03:05:52.900 --> 03:06:06.140]  сформулировал а впрочем хотя на самом деле если слишком большое тут уже никаких проблем нет
[03:06:06.140 --> 03:06:11.860]  я вообще вот так может заявить вообще для любого натурального кувер на вот это
[03:06:25.860 --> 03:06:34.940]  так ну давайте разбираться в принципе если видимо если адекватно понять что-то такое то
[03:06:34.940 --> 03:06:42.340]  вроде утверждение должно быть почти очевидно так но опять давайте в эту сторону попробуем
[03:06:42.340 --> 03:06:52.100]  вот вправо жил так ну допустим у нас действительно какой-то есть мелкий l да то есть пусть у нас
[03:06:52.100 --> 03:06:58.340]  l оказался совершенно случайно шифтом от q и более того это тель оказался меньше либо
[03:06:59.340 --> 03:07:05.340]  что это в принципе означает тогда если я вот сейчас нарисую эту строчку то у меня получится
[03:07:05.340 --> 03:07:17.540]  примерно следующее вот то как бы тогда что это означает вот жил был q и в принципе если у
[03:07:17.540 --> 03:07:24.460]  него шифтом оказался вот этот l то в принципе вот это неравенство означает 4 копии тут как-нибудь
[03:07:24.460 --> 03:07:40.180]  найдутся вот но тогда это автоматически означает что рич от l то есть это как бы наскоро то есть
[03:07:40.180 --> 03:07:45.820]  максимальная длина префикса которая имеет период и то есть который или периодично она
[03:07:45.820 --> 03:07:51.460]  распространяется как минимум на как минимум на q но это в общем-то здесь очевидно
[03:07:51.460 --> 03:08:08.620]  да то есть вот я вот уже что вот и то есть из этого вот это прям вот очевидно следует
[03:08:08.620 --> 03:08:22.140]  если вот это если сейчас если м равно шифт а
[03:08:22.140 --> 03:08:38.060]  так у нас есть как копии ну каннельмейшли бравнукует понятно да но теперь давайте
[03:08:38.060 --> 03:08:46.060]  просто возьмем это l и сделаем отсюда рич да но тогда он как бы рич дойдет как минимум до q
[03:08:46.060 --> 03:08:54.460]  потому что ну потому что это l это шифт да ну значит получается что рич это отель как минимум q ура то
[03:08:54.460 --> 03:08:59.420]  есть в общем-то да обычно в ту сторону очень-то совсем очевидно в общем тут ничем и то есть
[03:08:59.420 --> 03:09:04.940]  пока формулировка то есть давайте попробуем в обратную сторону так внимание то есть пробуем
[03:09:04.940 --> 03:09:14.340]  в обратную сторону значит неожиданно выяснилось каннель то есть предположим неожиданно выяснилось
[03:09:14.340 --> 03:09:22.340]  что каннель меньше либо равно q но при этом рич отель дотянулся до q и пошел дальше да ну что
[03:09:22.340 --> 03:09:32.740]  мы из этого можем сделать какой мы из этого вывод можем сделать ну да нам не хватает да
[03:09:32.780 --> 03:09:40.140]  то есть фактически ну нет не совсем так нам нужно теперь доказать что по сути что l равно шифт от q
[03:09:40.140 --> 03:09:52.420]  что нет меньшего периода ну по сути да ну то есть конечно l являет то есть это строка заведома
[03:09:52.420 --> 03:09:58.020]  l периодична это l меньше либо равно q делить на к но высказать вопрос а почему бы у q а почему бы
[03:09:58.020 --> 03:10:10.260]  тут не завести какой-нибудь еще меньше шифт да в принципе q больше либо равно к умножить
[03:10:10.260 --> 03:10:18.940]  л это означает что 4 копии эля тут найдется да нужно по сути доказать что шифт от ку равно
[03:10:19.300 --> 03:10:27.980]  шифт откуда как это доказать ну давайте отред предположим выяснилось что есть шифт поменьше
[03:10:27.980 --> 03:10:40.540]  какой-нибудь вот такой вот этот пункт как всегда л штрих так но если тут период но
[03:10:40.540 --> 03:10:47.180]  заметим что так как l это меньше чем q поделить даже на 4 л штрих еще меньше то тогда получается
[03:10:47.220 --> 03:10:59.300]  есть период длины нод от л штриха и понятно да отсюда тогда но этот нод он как бы делитель
[03:10:59.300 --> 03:11:05.700]  l меньше l то есть и опять получается что вот этот префикс длины l не базовая строчка и как
[03:11:05.700 --> 03:11:12.460]  следствие вот противоречие с исходной то есть вы вот такой вот у нас получается такой очень простой
[03:11:12.600 --> 03:11:18.300]  то есть вот то есть такая в excusе yahoo да то есть вот здесь мы наконец
[03:11:18.300 --> 03:11:24.980]  используем что это грей퍼 этих период с Borlear вот то есть получается что на
[03:11:24.980 --> 03:11:31.680]  самом деле да то есть в принципе что это лемма вообще нам на что это лемма нам намекает что в
[03:11:31.680 --> 03:11:37.500]  принципе под достаточно то есть если мы знаем что у нас есть префикс ты период да какую-то что
[03:11:37.500 --> 03:11:43.680]  что вот элит у нас какой-то префиксный период то при достаточно больших ку при достаточно больших
[03:11:43.680 --> 03:11:56.220]  ку мы в принципе можем там можем уже просто shift себе сразу гарантировать мы продолжаем
[03:11:56.220 --> 03:12:03.300]  идти по статье галилла сейферса которая леммы я оттуда взял их оттуда честно переписал и там
[03:12:04.300 --> 03:12:11.060]  но тут как всегда смотрите мы тут просматривали некоторые факты сейчас из этих фактов мы
[03:12:11.060 --> 03:12:19.060]  неожиданно скомпонуем алгоритм ну скажите как они-то придумали я не знаю нет но на самом деле
[03:12:19.060 --> 03:12:23.780]  когда придумываешь алгоритм так всегда получается на самом деле что тебе там пришла в голову какая-то
[03:12:23.780 --> 03:12:28.500]  идея ты ее как-то там допилила потом тебе ты там понял доказательства для себя а потом начал
[03:12:28.500 --> 03:12:33.020]  писать статью но когда-то я стал писать статью выяснилось что просто вот какие-то то есть ты там
[03:12:33.020 --> 03:12:38.420]  в процессе там доказал подобного рода утверждения да но от линии для тебя были из каких-то интуитивных
[03:12:38.420 --> 03:12:46.220]  там соображений они тебе были понятны но тебе пришлось это сформулировать для статьи вот
[03:12:46.220 --> 03:12:53.300]  но тем более что там половина этих утверждений на самом деле бывает из цикла что все их знают что
[03:12:53.300 --> 03:12:58.660]  типа там научное сообщество их в принципе там более-менее знает но кто думал над строчками в
[03:12:58.660 --> 03:13:04.260]  этом направлении они это все в принципе более-менее понимают вот более-менее вопрос но понятно что
[03:13:04.260 --> 03:13:09.820]  специальная статья на тему этих утверждений никто естественно не писал потому что это не того уровня
[03:13:09.820 --> 03:13:16.140]  достижения но соответственно то есть поэтому так то есть это может быть немножко там то есть поэтому
[03:13:16.140 --> 03:13:23.180]  поэтому тут вот как это придумать вот вопрос такой ашки можете повторить как вот слева направо
[03:13:23.180 --> 03:13:31.460]  доказываем что кумин шли б равно чем рич так в смысле вот как вот картинка как бы строка вот
[03:13:31.460 --> 03:13:37.460]  это строка для префиг зеленый кул он эль периодичен ну все из этого уже следует шури ч то есть как бы
[03:13:37.460 --> 03:14:01.900]  рич от эль значит дойдет хотя бы таку нет потому что эль равно шифта тку вот когда мы слева направо
[03:14:01.900 --> 03:14:14.140]  идем еще вот этим утверждением пользуемся ну и что он разве может скушать до рич ничего не требует
[03:14:14.140 --> 03:14:20.540]  на эту тему то есть фактически это так то есть рич от эль это максимальная длина префикса строки
[03:14:20.540 --> 03:14:27.600]  с которая является эль пере который является эль периодичен то есть там определение было
[03:14:28.200 --> 03:14:33.800]  эль плюс z функция здесь она не обязана заканчиваться какой-то позиции делящейся на
[03:14:33.800 --> 03:14:50.160]  эль вот так что вот такая красота а теперь внимание те рема о декомпозиции да вот сейчас мы вообще
[03:14:50.360 --> 03:14:57.840]  как бы да как бы мистическая те рема о декомпозиции
[03:14:57.840 --> 03:15:20.960]  смотрите абсолютно произвольную строку п можно разбить как хочется в этом смысле поставить
[03:15:20.960 --> 03:15:37.920]  точку но вы значит разбить на короче п равно ув где у в не более одного префиксного периода
[03:15:37.920 --> 03:16:07.680]  префиксного периода а длина у это от длины сейчас упадете не шифт но от
[03:16:07.920 --> 03:16:25.120]  мечта да шифт с индексом в от модуль в ну как сказать ну почему иногда наоборот знаете
[03:16:25.120 --> 03:16:33.080]  иногда там ничего не понятно но по фонда по форме на вот знаете такое не видели мультик с
[03:16:33.080 --> 03:16:40.360]  такой песенкой да именно именно да там тоже у вас первая реакция скорее всего тоже будет
[03:16:40.360 --> 03:16:56.760]  и потом да вот а вот так вот значит что тут написано ага то есть давайте возьмем строчку
[03:16:56.760 --> 03:17:08.160]  в и возьмем ее shift так вот утверждается что длина у маленькая то есть маленькая
[03:17:08.160 --> 03:17:13.400]  смысле о от шифта то есть там какая-то константа то есть там ее длина не превосходит этого шифта
[03:17:13.400 --> 03:17:22.880]  умножить какую-то все это всеобщую константу честно пока не помню какую вот то есть вот
[03:17:22.880 --> 03:17:38.960]  такая вот неожиданная заява так вот да тут в этом месте мы сломая нот мы сделаем слом потому
[03:17:38.960 --> 03:17:43.760]  что как всегда в такое время у нас возникает два вопроса как ее доказывать и какого хрена мы
[03:17:43.760 --> 03:17:52.640]  ее вообще написали еще что она значит ну да это вообще нулевой вопрос что она значит вообще
[03:17:52.640 --> 03:17:59.400]  но зарослишь что такое что она значит она значит вот это а все остальное так вопросу зачем она в
[03:17:59.400 --> 03:18:09.400]  таком виде нам нужна чего ну применима себе ну хорошо там видимо скажешь так авторы не
[03:18:09.400 --> 03:18:14.880]  стали тут убиваться формализм но видимо там можно было сформируйте что модуль у не превосходит там
[03:18:14.880 --> 03:18:24.360]  5 шифтов там ну в общем там ну 5 там 10 я не помню сколько но в общем короче там константа есть вот
[03:18:24.360 --> 03:18:31.760]  вот вот в этом плане да в этом смысле да нет мы сейчас пойдем делать мы сейчас как бы мы
[03:18:31.760 --> 03:18:53.700]  значит закончим тем что докажем эту теорию ждем то есть мы берем мы берем да вот мы берем
[03:18:53.700 --> 03:19:03.300]  минимальный период строке в да откуда-то его предварительно узнав вот ну вот то есть на самом
[03:19:03.300 --> 03:19:07.540]  деле алгоритм то есть на самом деле теорема подразумевает конечно но так как мы алгоритм
[03:19:07.540 --> 03:19:13.340]  ищем теорема будет подозревать следующим это разбиение не просто существует а существует
[03:19:13.340 --> 03:19:20.420]  алгоритм с от единицы дополнительной памяти который найдет вот это разбиение и еще и скажет есть ли
[03:19:20.420 --> 03:19:33.660]  префиксный период если дату сколько сейчас ну вот мы найдем вот такое разбиение вот вот утверждается
[03:19:33.660 --> 03:19:39.300]  что вот сейчас мы как бы вот то есть мы сейчас ответим на просьбу чем теорема нужна теперь вот
[03:19:39.300 --> 03:19:50.620]  потому что мы сейчас делаем так да ладно нормальный алгоритм что за уныние сразу вот
[03:19:50.620 --> 03:20:04.020]  значит смотрите то есть то есть идея будет такая что если мы по заданной строке п найдем ну как
[03:20:04.020 --> 03:20:10.980]  бы не случайно по шпонте мы ищем под строку п строке с да если мы найдем если вы строку
[03:20:10.980 --> 03:20:31.380]  п распилим вот на это вот чего какой пси бонус где пси бонус да боже мой прям принципиально ну и
[03:20:31.380 --> 03:20:37.540]  что я вам больше скажу знаете в прошлом году я вам даже скажу в предыдущем поколении был
[03:20:37.540 --> 03:20:42.460]  студент который получил от этом отл 10 без оси pc бонусов написав на отл вот это
[03:20:42.460 --> 03:20:55.060]  по моему кстати насколько помню у александр хоцко взывали кстати с интересно но вот так
[03:20:55.060 --> 03:20:59.620]  что соответственно если возникает вопрос и вот можете его спрашивать он разобрался может
[03:20:59.620 --> 03:21:07.060]  он конечно уже ничего не помнит конечно но но с формулируем так на самом деле да спе с
[03:21:07.060 --> 03:21:11.140]  первого раза взрыв мозга но на самом деле как бы так как бы эти все равно пока возникает
[03:21:11.140 --> 03:21:24.060]  ощущение что в совокупности софт хипа мозгов взрывательнее но на самом деле да ну правда
[03:21:24.660 --> 03:21:30.660]  такие вопросы вызывает но тут нет но тут вопрос кому как то есть может сейчас еще
[03:21:30.660 --> 03:21:35.100]  напишите вы сидите вечером во вторых как бы традиционно до студенты второго курса более
[03:21:35.100 --> 03:21:42.940]  являются более уставшими чем те же самые студенты но на первом курсе может программу
[03:21:42.940 --> 03:21:48.260]  с конца не пробовал но сформулируем так строчки но я уже рассказывать почему я строчки рассказываю
[03:21:48.260 --> 03:21:58.740]  на втором курсе потому что там автомат то есть можно крыша на это забить да нет нет там нет там
[03:21:58.740 --> 03:22:04.220]  просто две идеи первое хочется строки рассказывать единым блоком а во вторых строках есть автомат
[03:22:04.220 --> 03:22:10.220]  который хочется рассказывать когда вы уже там на формалках его там с ним поработали вот то есть
[03:22:10.220 --> 03:22:14.300]  принципе если забить на то что строки должны идти единым образом то конечно да я могу там
[03:22:14.300 --> 03:22:23.020]  вообще в любом порядке рассказывать да я это все могу вам и там нет этого я тоже не могу но там
[03:22:23.020 --> 03:22:28.220]  совсем так нельзя потому что все-таки как бы я должен ввести вас в амортизационный анализ и
[03:22:28.220 --> 03:22:35.020]  асимпотики я как-то должен то есть после этого в принципе да уже можно там развлекаться уже в
[03:22:35.020 --> 03:22:44.500]  любом порядке это да вот так вот так смотреть сейчас я напишу зелененьким ну давайте зелененьким
[03:22:44.500 --> 03:22:50.300]  напишу алгоритм такие внимание мета алгоритм с помощью которого мы будем искать под строк в
[03:22:50.300 --> 03:22:56.900]  строке возможно он вам даже покажется знакомым да я буду писать на псевдокоде в котором есть
[03:22:56.900 --> 03:23:16.740]  кортежики да это кортежик новый шпитон изучали да ну не совсем ну еще сейчас все увидите то есть
[03:23:16.740 --> 03:23:23.300]  у нас будет я сейчас пишу мета алгоритм да почему мета потому что в нем опять будет какая-то одна
[03:23:23.300 --> 03:23:32.360]  маленькая мелочь которую мы но от которой придется допиливать алгоритм вот нет мета это
[03:23:32.360 --> 03:23:38.860]  приставка в русском языке такая но то что она то что там кто-то там случайно ее запретил по каким-то
[03:23:38.860 --> 03:23:53.940]  причинам вот почему ругательный пристава приставка ругательная ну как-то знаете вот значит
[03:23:53.940 --> 03:24:02.040]  смотрите пока у нас п не превосходит т значит идея у нас такая значит ну смысл на самом деле
[03:24:02.040 --> 03:24:08.020]  очень простой смысл у меня будет такой как бы пара п ку в каждый момент времени означает что
[03:24:08.020 --> 03:24:20.900]  под строка текста т от п плюс один до п плюс ку но тут так удобно мыслить это премьер
[03:24:20.900 --> 03:24:33.620]  нот то есть она равна на самом деле вот так то есть глубокий смысл вот такой
[03:24:33.620 --> 03:24:44.820]  но мы ищем под строку п большое в тексте т так вот у меня будет идея такая то есть как бы
[03:24:44.820 --> 03:24:49.820]  п ку это те самые два указателя по сути то есть п указывает перед началом строки а п плюс ку
[03:24:49.820 --> 03:25:00.980]  наконец но как мы ищем но как мы ищем префир как мы ищем под строк в строке там вот была идея
[03:25:00.980 --> 03:25:09.780]  такая что мы значит начинаем находим тут вот максимальный префикс да потом сдвигаем но потом
[03:25:09.780 --> 03:25:16.220]  переходим ну в префикс функции было так потом сдвигаем значит этот указатель так чтобы это
[03:25:16.220 --> 03:25:21.660]  был префикс и теперь вот этот указатель начинаем двигать это у нас была такая идея мы
[03:25:21.660 --> 03:25:27.780]  его попытаемся обобщить я прям но я сейчас код напишу прям полностью да но суть будет
[03:25:27.780 --> 03:25:33.540]  следующее просто на каждом шаре переходить мы будем как-то вот непонятно как то есть каждое
[03:25:33.540 --> 03:25:37.820]  то есть ну то есть понятно что мы у нас будет п ку то есть вот сейчас первое что я сейчас
[03:25:37.820 --> 03:25:44.420]  делаю это у меня вайликом я буду увеличивать ку пока могу вот прям в тупую вот ты там найду
[03:25:44.420 --> 03:25:48.460]  вот это а потом после этого я п ку куда-то сдвину то есть на п штрих который будет
[03:25:48.460 --> 03:25:54.980]  больше чем п и на какой-то ку штрих ну короче давайте сейчас пишем видимо я уже код напишу и
[03:25:54.980 --> 03:26:06.500]  просто уже понятнее смотрите значит пишем while q меньше модуль п я уж думал миша пошел свет
[03:26:06.500 --> 03:26:23.140]  выключать так меньше либо равно модуль т и что еще п от куплю сойдем п плюс ку плюс
[03:26:23.140 --> 03:26:36.180]  1 плюс плюс вот это мы просто увеличиваем ку так ну естественно если оказалось что ку равно
[03:26:36.180 --> 03:27:01.740]  модуль п то как бы сохранить вхождение и наконец п ку присвоить п штрих ку штрих все
[03:27:07.060 --> 03:27:09.100]  да
[03:27:09.100 --> 03:27:21.620]  ну типа того ну про маленькое про большое да вот давайте ну давайте чтобы это было про
[03:27:21.620 --> 03:27:24.540]  большое вот так вот
[03:27:24.540 --> 03:27:46.980]  ну да то формально бред получается да вот да вот почему это не алгоритм а металгоритм
[03:27:46.980 --> 03:27:59.780]  ну там ну ну сохранить вхождение я имею ввиду давайте в кавычках напишу ну там что-то типа
[03:27:59.780 --> 03:28:05.100]  что значит это означает что мы нашли вхождение который заканчивает который вот тут с п плюс
[03:28:05.100 --> 03:28:11.900]  1 до п плюс к ну его надо как-то обработать ну как либо там напечатать куда-нибудь либо там плюсы
[03:28:12.500 --> 03:28:22.340]  типа сказать что мы нашли плюс 1 вхождение там и так далее ну там вот а вот это именно
[03:28:22.340 --> 03:28:28.900]  главная интрига этого вот главный интриг именно именно благодаря этому это алгоритм мы называем
[03:28:28.900 --> 03:28:33.500]  металгоритм а не алгоритм потому что как искать п штрих ку штрих вот в этом и самый магический
[03:28:33.500 --> 03:28:53.300]  вопрос это какие-то следующие числа желательно чтоб п штрих был больше чем п вот ну то есть ну
[03:28:53.300 --> 03:28:57.660]  точнее так на каждой это рация нам говорят что вот п ку это точно под строка то есть там префикс
[03:28:58.260 --> 03:29:04.940]  то есть теперь дальше мы вайликом увеличиваем куда упора вот но вот а после этого переходим
[03:29:04.940 --> 03:29:12.020]  к какой-то следующей паре значит какие у нас варианты есть тупой вариант тупой значит к
[03:29:12.020 --> 03:29:20.380]  чему равно п штрих ку штрих значит вариант первый п штрих ку штрих равно п плюс 1 0
[03:29:20.380 --> 03:29:31.260]  вот у этого значит у этого алгоритма есть преимущество он работает он точно работает
[03:29:31.260 --> 03:29:36.380]  правда другой вопрос да он в тупую да но это правда как раз тот самый алгоритм поиска под
[03:29:36.380 --> 03:29:45.180]  строк строке за за квадрат просто в явном виде то есть как бы и память хорошая время плохое
[03:29:45.180 --> 03:30:00.460]  давайте вместо один напишем как чего а почему к тогда будет ва вот потому что вот есть другой
[03:30:00.460 --> 03:30:25.860]  способ что его мое тут-то чего его мое
[03:30:30.460 --> 03:30:41.260]  а я знаю что вас смущает на вас вот это смущает вот теперь да вот теперь все понятно
[03:30:41.260 --> 03:30:49.740]  ну как бы шифт у нас все-таки с индексом строчки они числа
[03:30:49.740 --> 03:31:05.260]  так ну как это называется да как это как называется алгоритм который мы ищем под
[03:31:05.260 --> 03:31:14.780]  строку строке с используя вот такие равенства правильно да ну или да алгоритм кнута мориса
[03:31:14.780 --> 03:31:26.060]  праттов явно ведь сейчас мы прибавили длину мобильного периода префикса длины ку строки п да
[03:31:26.060 --> 03:31:37.700]  вот а вот вот а вот в этом и проблема да как искать шесты точнее так как сказать шесты понятно
[03:31:37.700 --> 03:31:42.020]  насчитай префикс функцию для строки п и порадуйся но они потребуют памяти до
[03:31:42.020 --> 03:31:48.380]  проблемы вот но так это заметим что это фактический алгоритм кнута мориса пратта
[03:31:48.380 --> 03:31:56.780]  может сказать почти в первозданном виде ты теперь нам нужно просто научиться
[03:31:56.780 --> 03:32:07.460]  нет мы просто не будем применять не этот метод не этот метод я просто это я просто
[03:32:07.460 --> 03:32:12.580]  предложил вслед за авторами просто такие иллюстрацию того что этот вообще металл
[03:32:12.580 --> 03:32:17.980]  алгоритм означает то есть как бы подставим вот этот метод получится алгоритм который ищет
[03:32:17.980 --> 03:32:23.420]  вхождение вполне себе за линию ну в предположении конечно что эти шифты вам присылаются небес по
[03:32:23.420 --> 03:32:37.700]  факсу конечно вот да оттуда да в 72 году кстати кстати о западе с удовлетворением могу отметить
[03:32:37.700 --> 03:32:43.580]  что запад успешно загнивает но не будем на этом останавливаться это в конце концов их нравы зато
[03:32:43.580 --> 03:32:58.980]  мы здесь на истребла так я это вам помпом я это уже воспроизводил нет ну ладно 72 год да да да
[03:32:58.980 --> 03:33:03.860]  кстати надо еще вспомнить галил сейферас это вообще какого года алгоритм по-моему даже не
[03:33:03.860 --> 03:33:22.020]  72 галил сейферас ну гуглонить там да что-то находится только какой репетиторий на
[03:33:22.020 --> 03:33:37.540]  кит хабе и скины на галил арис к изго два чего так вы господи во-первых сейферас во-вторых
[03:33:37.540 --> 03:33:53.100]  ну вы по-английски то гуглите как вы знаете я думал чего да да да да да господи рекламодателем
[03:33:53.100 --> 03:34:05.220]  до рекламодателем в наших лекциях нет рекламы да вот это лекции дорушает я не знаю что там
[03:34:05.220 --> 03:34:11.900]  это требуется авторские отчисления авторам этой статьи или что я знаю ладно значит смотрите
[03:34:11.900 --> 03:34:18.900]  итак значит мы будем п штриха ку штрих выкапывать немножко по-другому мы будем говорить что у нас
[03:34:18.900 --> 03:34:27.780]  есть вот это наша мистическая строка п и мы напоминаем что строка п у нас равно ув то есть
[03:34:27.780 --> 03:34:38.500]  вот это вот у а это у нас в у которой есть shift то есть вот этот вот shift так сказать shift
[03:34:38.500 --> 03:34:50.820]  в от модуль в вот вот и мы знаем что у она типа относительно этого шифта мелкая и что мы еще
[03:34:50.820 --> 03:34:59.260]  будем делать но вот а еще мы знаем что этой штуки в внезапно есть какой-то префиксный период
[03:34:59.260 --> 03:35:09.780]  какой вот какой-то префиксный период у нее есть а может и нет кстати но тут два варианта он
[03:35:09.780 --> 03:35:21.380]  либо есть он равен п либо его нет и все вот значит давайте начнем с простого попробуем
[03:35:21.380 --> 03:35:26.820]  значит начать с простого случая предположим что выяснилось что этой в нет префиксного периода
[03:35:26.820 --> 03:35:37.900]  да то есть да это будет означать что у нас потом будет алгоритм который значит для строки п за
[03:35:37.900 --> 03:35:48.020]  у от п это сделает вот соответственно так давайте предположим чтоб но вот теперь предположим
[03:35:48.020 --> 03:35:56.660]  что вот нам фантастически повезло и префиксного периода нет и так значит да то есть давайте
[03:35:56.660 --> 03:36:04.260]  такое предположен тогда смотрите давайте так я и буду писать значит первая допусть у вот этой
[03:36:04.260 --> 03:36:25.340]  вот п нет префиксного периода тогда утверждать тогда я утверждаю весьма неожиданную вещь вообще
[03:36:25.340 --> 03:36:33.980]  нет вот это тогда я утверждаю такой даже в отдельную лему это не буду выносить шифт вот
[03:36:33.980 --> 03:36:41.820]  этот вот мистический шифт короче но ладно же неважно шифт от абсолютно произвольного q утверждаю
[03:36:41.820 --> 03:36:58.860]  я больше строго больше даже чем q делить на к нет то там официальная ссылка идет на лему 1 в
[03:36:58.860 --> 03:37:04.500]  которой было что как бы если шифт от q меньше либо равно q делить на к то этот шифт является
[03:37:04.500 --> 03:37:11.820]  префиксным периодом то есть да то есть в общем вывод простой да то есть как бы если префиксное
[03:37:11.820 --> 03:37:20.340]  периода не значит любой шифт больше чем q делить на к и тогда идея и тогда идея очень простая тогда
[03:37:20.340 --> 03:37:30.780]  п штрих ку штрих знаете что должно быть я утверждаю что оно должно быть просто п плюс
[03:37:30.780 --> 03:37:35.260]  q делить на к ноль все
[03:37:35.260 --> 03:38:02.020]  ну что вы так занудствуйте ну вот вам пожалуйста тогда я утверждаю что наш алгоритм ну то есть
[03:38:02.020 --> 03:38:08.380]  наш алгоритм по такому раскладу сработает за там то есть пройдется получается за от
[03:38:08.380 --> 03:38:18.460]  точнее плюс от за от умножить на к но ка у нас константа поэтому соответственно вот догадываетесь
[03:38:18.460 --> 03:38:32.700]  почему да что а потому что важно потому что вот как потому что есть интеллектуальный момент я
[03:38:32.700 --> 03:38:41.620]  забыл сказать прошу прощения да потому что во первых тогда тут надо не упе а ув а в той самой
[03:38:41.620 --> 03:38:50.900]  главной смотрите тут эпическая идея смотрите сейчас будет это эпическая идея мы дело в том
[03:38:50.900 --> 03:39:04.900]  что мы будем искать вхождение не строки п а строки в вот значит мы будем искать да мы будем искать
[03:39:04.900 --> 03:39:13.300]  по факту вхождение строки в и просто если мы найдем какое-нибудь вхождение строки в то мы
[03:39:13.300 --> 03:39:19.100]  просто в этом месте быстрый нот то мы в этом месте тогда проверим а нет ли перед этим вхождением
[03:39:19.100 --> 03:39:30.860]  строки в вхождение строки почему это быстро работает а вот почему смотри дело в том что допустим
[03:39:31.040 --> 03:39:37.500]  везде где у нас должно быть вхождение строки п должно быть вхождение строки в правда а теперь
[03:39:37.500 --> 03:39:44.940]  заметим следующие пусть у нас в строке т вот жила была строка т и мы тут неожиданно нашли вхождение
[03:39:44.940 --> 03:39:55.540]  строки в внимание вопрос где должно быть следующее оно должно быть на каком-то расстоянии больше
[03:39:55.540 --> 03:40:07.380]  либо равном вот этого шифта. Правда? Логично, да? Тогда я утверждаю, что если мы найдем
[03:40:07.380 --> 03:40:11.660]  все вхождения строки V и только для этих вхождений будем проверять вот это вот U,
[03:40:11.660 --> 03:40:19.900]  то в принципе отсюда следует, что вхождений строки V самих по себе вхождений не более,
[03:40:19.900 --> 03:40:28.700]  чем модуль T делить на вот этот вот шифт. И тогда, ну вот самих вхождений вот столько,
[03:40:28.700 --> 03:40:36.740]  и тогда получается, что если мы для каждого вхождения будем работать за U, а U у нас,
[03:40:36.740 --> 03:40:41.860]  в свою очередь, от этого шифта, то тогда получается, что все эти проверки U суммарно
[03:40:41.860 --> 03:40:52.140]  сработают за O от T, и это нас устраивает. То есть вот такая вот неожиданная идея.
[03:40:52.140 --> 03:41:12.060]  Вот. Вот. То есть таким образом получается, что мы, начиная с этого момента, считаем,
[03:41:12.060 --> 03:41:18.060]  что P это на самом деле V. Потому что как бы проверка вот этого префикса U,
[03:41:18.060 --> 03:41:27.660]  это просто получается для нас за бесплатно. Понятно? Так, ну что тут, понятно, да?
[03:41:27.660 --> 03:41:38.020]  Да, и даже все гораздо понятнее стало. Вот. Отлично. Ну вот, поэтому теперь ищем V. Значит,
[03:41:38.020 --> 03:41:43.220]  как мы теперь ищем вхождение V? Ну, вхождение V, если выяснилось, что у V еще нет префиксного
[03:41:43.220 --> 03:41:58.980]  периода, то запускаем вот этот металгоритм на предельного тупничка. Что? Значит, по нот.
[03:41:58.980 --> 03:42:07.340]  Значит, почему? Так, ну давайте, да. Как бы это, как бы это так максимально легко увидеть?
[03:42:07.340 --> 03:42:31.380]  Сейчас еще раз. Чего говоришь? Нет, shift V от Q это период префикса Q. Он, естественно,
[03:42:31.380 --> 03:42:39.660]  меньше либо равен, чем период всей строки. Ну, потому что если у всей строки есть период 57,
[03:42:39.660 --> 03:42:50.500]  то и у префикса есть период 57. То есть, что вот так. То есть, ну меньше либо равна. Чем меньше строчка,
[03:42:50.500 --> 03:43:18.620]  тем меньше у нее период. А, сейчас. Да ладно. Нет, у строки A-A-B период 3. У строки A-A период 1.
[03:43:18.620 --> 03:43:32.500]  То есть, чем меньше строка, тем период меньше. То есть, мы минимальный период берем. Вот.
[03:43:32.500 --> 03:43:53.700]  То есть, короче говоря, если у нас, сейчас, если у нас, ну да, если у нас у строки есть период, то у нас тоже есть, если у нас меньше равен. Ну да, тогда понятно, почему работает.
[03:43:53.900 --> 03:44:01.300]  Да. Так. Ну, почему работает, понятно. Теперь более интересно, почему это работает за адекватное время.
[03:44:01.300 --> 03:44:07.900]  Тоже понятно. У нас просто, ну, потенциал камонеток на каждое увеличение в Q ходит.
[03:44:07.900 --> 03:44:20.500]  Ну, то да. Ну, это не совсем потенциал, потому что мы сначала скачем на Q, а потом продвигаемся вперед. То есть, как бы такие, на самом деле, просто можно обратно во времени сказать.
[03:44:21.300 --> 03:44:32.300]  То есть, ну, можно просто сказать, что на каждом шаге мы увеличиваем P на сколько-то, да, и гарантируем, что Q при этом прошло шаров не более, чем это. Сколько-то умножить на K.
[03:44:35.300 --> 03:44:45.300]  Ну, вот, следовательно, суммарно Q прошло не более, чем для нас строки T умножить на K. Ну, а K у нас константа, поэтому победа. Вот. Понятно, да?
[03:44:46.100 --> 03:44:57.100]  Можно еще раз, что мы сделали? То есть, у нас, ну, вот, находится в этом байле, мы выполнили одну итерацию, а сейчас оставляем PQ, так?
[03:44:57.100 --> 03:45:00.100]  Да. Вот и предлагается это делать вот так.
[03:45:00.900 --> 03:45:20.900]  Да, утверждаем мы. То есть, это означает, что если мы P увеличим на, значит, что-то меньшее, чем Q делить на K, то тогда в этой позиции вхождения точно не будет, это можно пропустить.
[03:45:21.700 --> 03:45:24.700]  Если P увеличить на что-то меньшее?
[03:45:24.700 --> 03:45:25.700]  Да.
[03:45:26.700 --> 03:45:36.700]  Поэтому у меня идея такая, давайте увеличим на Q делить на K, округленный вверх, и будем начинать с этого момента искать вхождение в тупую. То есть, вот Q, видите, я даже сохранять не буду.
[03:45:36.700 --> 03:45:47.700]  Ну, в плане, у нас shift Q больше Q делить на K, shift V больше правильно, чем shift Q, а расстояние между соседними shift V.
[03:45:48.500 --> 03:45:58.500]  Хотя бы shift V. Ну, вот. Ну, хотя бы shift V, а shift V это хотя бы Q делить на K, поэтому давайте просто сдвигаем Q делить на K, и это нам хватит.
[03:45:58.500 --> 03:46:07.500]  То есть, мы не знаем, чему равен shift от Q, естественно, да? Но нас это и не волнует, мы просто берем Q делить на K, и не паримся.
[03:46:07.500 --> 03:46:10.500]  То, что больше, чем Q делить на K, это следствие изменит.
[03:46:10.500 --> 03:46:14.500]  Да. То есть, у нас была Lemma 1, которая заявляла, да, что...
[03:46:15.300 --> 03:46:24.300]  А, мы не знаем, чему равен shift V. Сейчас, стоп, а как мы посчитаем shift V от Q? А, стоп, нам его не нужно считать?
[03:46:26.300 --> 03:46:32.300]  Чего? Shift не нужно. Нам достаточно знать, что он хотя бы вот столько.
[03:46:32.300 --> 03:46:38.300]  Сейчас, но у нас в частности shift Q больше равен, чем V делить на K, да?
[03:46:39.100 --> 03:46:44.100]  Ой, не так. Сейчас. А можно же прибавлять вместо Q делить на K, V делить на K просто?
[03:46:44.100 --> 03:46:49.100]  Нет. Нет-нет-нет. Потому что мы знаем только вот это про V делить на K, а мы ничего не знаем.
[03:46:54.100 --> 03:46:56.100]  Так, стоп. Подождите, что такое Q?
[03:46:58.100 --> 03:47:02.100]  А, мы говорим, что в следующее обхождение... А, мы знаем, что у нас Q входит уже, да?
[03:47:02.100 --> 03:47:03.100]  Да.
[03:47:03.100 --> 03:47:05.100]  Тогда в следующее обхождение Q через shift.
[03:47:05.100 --> 03:47:06.100]  Ну да.
[03:47:06.900 --> 03:47:08.900]  И поэтому можно прибавить...
[03:47:08.900 --> 03:47:10.900]  Да. Ну да, давайте еще раз нарисуем.
[03:47:10.900 --> 03:47:17.900]  Вот жила строка T, вот мы находимся... Тут позиция P, тут позиция... Тут вот набралось Q, да?
[03:47:17.900 --> 03:47:20.900]  И тут мы остановились. Теперь мы хотим перейти.
[03:47:20.900 --> 03:47:24.900]  Но заметим, что нас теперь интересует следующее вхождение вот этой подстроки.
[03:47:24.900 --> 03:47:27.900]  Вот это является префиксом строки V, да?
[03:47:28.700 --> 03:47:29.700]  Вот.
[03:47:29.700 --> 03:47:31.700]  Но тогда утверждается, что следующий...
[03:47:31.700 --> 03:47:33.700]  Так как у строки V нет префиксного периода,
[03:47:33.700 --> 03:47:38.700]  то там по лемме получалось, что следующее вхождение будет хотя бы через Q делить на K.
[03:47:39.700 --> 03:47:42.700]  Стоп, а мы умеем определять, есть QV в префиксном периоде?
[03:47:42.700 --> 03:47:43.700]  Ну вот, да.
[03:47:43.700 --> 03:47:46.700]  То есть, да, в этой теории мы на самом деле найдем...
[03:47:46.700 --> 03:47:49.700]  Даже отличим в случае, есть ли префиксный период.
[03:47:49.700 --> 03:47:52.700]  И Q-not, и not, или нет.
[03:47:53.700 --> 03:47:54.700]  Так что вот такая вот идея.
[03:47:54.700 --> 03:47:56.700]  То есть так как вот этот префикс точно нужен,
[03:47:57.500 --> 03:47:59.500]  но значит нам сдвиг хотя бы Q делить на K.
[03:48:00.500 --> 03:48:02.500]  То есть когда мы дошли до конца цикла,
[03:48:02.500 --> 03:48:05.500]  то Q это такая же позиция, что Q равно...
[03:48:06.500 --> 03:48:09.500]  Ну в смысле, что Q это позиция, где у нас есть вхождение.
[03:48:10.500 --> 03:48:13.500]  Ну Q это не позиция. Q это как бы длина подстроки,
[03:48:13.500 --> 03:48:15.500]  начинающаяся после этой позиции,
[03:48:15.500 --> 03:48:17.500]  которая совпадает с префиксом строки V.
[03:48:17.500 --> 03:48:19.500]  А то есть когда мы дошли до конца цикла,
[03:48:19.500 --> 03:48:23.500]  то мы гарантируем, что у нас есть вхождение?
[03:48:24.500 --> 03:48:25.500]  Нет.
[03:48:26.300 --> 03:48:28.300]  Вот это совпадает с префиксом.
[03:48:28.300 --> 03:48:30.300]  То есть это не вся строка V, но это ее префикс.
[03:48:33.300 --> 03:48:35.300]  Если Q станет длиной модуль V,
[03:48:35.300 --> 03:48:37.300]  то да, мы нашли вхождение строки V.
[03:48:38.300 --> 03:48:40.300]  А все, мы смотрим максимально.
[03:48:40.300 --> 03:48:42.300]  Да, то есть вопрос, насколько мы тут дойдем.
[03:48:43.300 --> 03:48:45.300]  Но оказывается, что следующее будет как бы как минимум
[03:48:45.300 --> 03:48:47.300]  через Q делить на K шаров,
[03:48:47.300 --> 03:48:49.300]  поэтому сдвигаемся на Q делить на K,
[03:48:49.300 --> 03:48:52.300]  и ищем следующее Q уже в ту пую.
[03:48:56.300 --> 03:48:57.300]  Вот.
[03:48:59.300 --> 03:49:01.300]  Так что вот такая радость.
[03:49:04.300 --> 03:49:06.300]  Так что оказывается, что если нет префиксного периода,
[03:49:06.300 --> 03:49:09.300]  то как бы мы победили на халяву.
[03:49:10.300 --> 03:49:11.300]  Вот.
[03:49:13.300 --> 03:49:15.300]  Теперь давайте посмотрим,
[03:49:16.300 --> 03:49:18.300]  что у нас будет второе.
[03:49:19.300 --> 03:49:21.300]  Теперь второй случай.
[03:49:22.100 --> 03:49:28.100]  Пусть у V есть единственный префиксный период.
[03:49:43.100 --> 03:49:48.100]  Период P и равен он P1.
[03:49:48.900 --> 03:49:50.900]  Да, в те время мы его еще и находить будем
[03:49:50.900 --> 03:49:52.900]  в явном виде, если он есть.
[03:49:53.900 --> 03:49:54.900]  Понятно, да?
[03:50:01.900 --> 03:50:02.900]  Тогда,
[03:50:03.900 --> 03:50:06.900]  значит, тот алгоритм пишет вот простую вещь.
[03:50:07.900 --> 03:50:08.900]  Значит, смотрите.
[03:50:08.900 --> 03:50:11.900]  Оказалось, что при K P1 меньше либо равно Q
[03:50:12.700 --> 03:50:17.700]  меньше либо равно rich V от P1.
[03:50:28.700 --> 03:50:29.700]  Вот.
[03:50:34.700 --> 03:50:36.700]  Ну, скажем так, rich V от P1
[03:50:36.700 --> 03:50:39.700]  мы эту чиселку можем заранее предподсчитать, правда?
[03:50:42.700 --> 03:50:44.700]  Ну, если мы знаем V и знаем P1,
[03:50:44.700 --> 03:50:47.700]  то rich мы как чиселку можем один раз
[03:50:47.700 --> 03:50:49.700]  там когда-то посчитать и сохранить, правда?
[03:50:50.700 --> 03:50:52.700]  Да, просто в тупую пробежаться, конечно.
[03:50:53.700 --> 03:50:54.700]  Вот.
[03:50:54.700 --> 03:50:55.700]  Так вот.
[03:50:56.700 --> 03:50:58.700]  Если совершенно случайно окажется,
[03:50:58.700 --> 03:51:00.700]  что Q попало, ну, понятно будет,
[03:51:00.700 --> 03:51:02.700]  что rich V от P1 будет больше либо равно,
[03:51:02.700 --> 03:51:03.700]  чем K P1.
[03:51:04.700 --> 03:51:05.700]  Так вот.
[03:51:05.700 --> 03:51:07.700]  Если Q у вас, оказывается,
[03:51:07.700 --> 03:51:09.700]  попадет в этот подотрезок,
[03:51:10.500 --> 03:51:11.500]  понятно, да?
[03:51:13.500 --> 03:51:15.500]  Ну, при полу может же быть такое,
[03:51:15.500 --> 03:51:16.500]  что Q попало, правда?
[03:51:17.500 --> 03:51:18.500]  Тогда что?
[03:51:20.500 --> 03:51:23.500]  Тогда я утверждаю, что надо сделать P,
[03:51:23.500 --> 03:51:24.500]  значит,
[03:51:24.500 --> 03:51:26.500]  тогда надо просто P' Q'
[03:51:29.500 --> 03:51:30.500]  должно быть равно
[03:51:33.500 --> 03:51:34.500]  P plus P1
[03:51:36.500 --> 03:51:37.500]  соответственно
[03:51:38.300 --> 03:51:40.300]  и Q минус P1
[03:51:48.300 --> 03:51:49.300]  Потому что, по идее,
[03:51:49.300 --> 03:51:51.300]  что это неравенство значит?
[03:51:52.300 --> 03:51:54.300]  Это неравенство значит следующее.
[03:51:56.300 --> 03:51:57.300]  То есть это означает,
[03:51:57.300 --> 03:51:58.300]  что мы тут нашли какой-то Q.
[03:51:58.300 --> 03:52:00.300]  Так, давайте я тут под линией нарисую.
[03:52:01.300 --> 03:52:02.300]  Это означает,
[03:52:02.300 --> 03:52:03.300]  что мы тут
[03:52:05.300 --> 03:52:06.300]  теоретически
[03:52:06.300 --> 03:52:07.300]  оп-оп-оп-оп
[03:52:09.300 --> 03:52:10.300]  Ну, по крайней мере,
[03:52:11.300 --> 03:52:13.300]  у строки V есть вот
[03:52:13.300 --> 03:52:14.300]  оп-оп-оп-оп
[03:52:18.300 --> 03:52:19.300]  длины P1
[03:52:21.300 --> 03:52:23.300]  И может быть еще там
[03:52:23.300 --> 03:52:25.300]  сколько-то вот до какого-то момента,
[03:52:25.300 --> 03:52:27.300]  но хотя бы 4 опа есть.
[03:52:28.300 --> 03:52:29.300]  Видно, да?
[03:52:32.300 --> 03:52:34.300]  Так вот, если неожиданно выяснилось,
[03:52:34.300 --> 03:52:35.300]  что Q у нас оказалось
[03:52:35.300 --> 03:52:36.300]  такой длины,
[03:52:36.300 --> 03:52:38.300]  что вот тут оп-оп-оп-оп
[03:52:38.300 --> 03:52:39.300]  налицо
[03:52:41.300 --> 03:52:42.300]  и более того,
[03:52:42.300 --> 03:52:44.300]  Q еще не достаточно большое,
[03:52:44.300 --> 03:52:45.300]  чтобы за пределы
[03:52:45.300 --> 03:52:48.300]  периодичности P1 мы вышли,
[03:52:49.300 --> 03:52:51.300]  то тогда утверждается,
[03:52:51.300 --> 03:52:54.300]  что редкий случай,
[03:52:54.300 --> 03:52:57.300]  но shift от этого Q мы тупо знаем.
[03:52:57.300 --> 03:52:58.300]  И он равен именно P1.
[03:53:05.300 --> 03:53:06.300]  Ну, потому что тут,
[03:53:06.300 --> 03:53:08.300]  ну, потому что тут, видимо,
[03:53:08.300 --> 03:53:09.300]  надо правильно сослаться
[03:53:09.300 --> 03:53:10.300]  на какую-то лему.
[03:53:11.300 --> 03:53:12.300]  Забыл, на какую.
[03:53:12.300 --> 03:53:14.300]  Но рассуждение такое,
[03:53:14.300 --> 03:53:15.300]  потому что, смотрите,
[03:53:15.300 --> 03:53:17.300]  P1 это кандидат на shift,
[03:53:17.300 --> 03:53:18.300]  правда?
[03:53:18.300 --> 03:53:19.300]  А теперь
[03:53:19.300 --> 03:53:20.300]  предположим,
[03:53:20.300 --> 03:53:22.300]  что здесь есть shift меньше.
[03:53:23.300 --> 03:53:24.300]  Но тогда очевидно,
[03:53:24.300 --> 03:53:25.300]  что...
[03:53:25.300 --> 03:53:26.300]  shift в строке V?
[03:53:27.300 --> 03:53:28.300]  Нет.
[03:53:28.300 --> 03:53:29.300]  Ну, это shift в строке V.
[03:53:29.300 --> 03:53:30.300]  Ну, это шифт в строке V.
[03:53:30.300 --> 03:53:31.300]  Это шифт в строке V.
[03:53:31.300 --> 03:53:32.300]  Это шифт в строке V.
[03:53:32.300 --> 03:53:33.300]  Это шифт в строке V.
[03:53:33.300 --> 03:53:34.300]  Нет.
[03:53:34.300 --> 03:53:36.300]  Ну, это шифт в префиксе
[03:53:36.300 --> 03:53:37.300]  длины Q.
[03:53:37.300 --> 03:53:38.300]  Длины Q.
[03:53:38.300 --> 03:53:39.300]  Строки P, конечно.
[03:53:39.300 --> 03:53:41.300]  Ну, тогда я утверждаю...
[03:53:41.300 --> 03:53:42.300]  Ну, точнее так.
[03:53:42.300 --> 03:53:43.300]  Это не Q.
[03:53:43.300 --> 03:53:44.300]  Это, конечно,
[03:53:44.300 --> 03:53:47.300]  reach с индексом V
[03:53:47.300 --> 03:53:49.300]  от P1, конечно.
[03:53:49.300 --> 03:53:51.300]  Но в этой строке,
[03:53:51.300 --> 03:53:53.300]  если в ней найдется shift от Q
[03:53:53.300 --> 03:53:54.300]  поменьше,
[03:53:54.300 --> 03:53:56.300]  то тогда мы сделаем вывод,
[03:53:56.300 --> 03:53:57.300]  что тогда...
[03:53:57.300 --> 03:53:58.300]  То есть, как бы,
[03:53:58.300 --> 03:53:59.300]  еще меньше период,
[03:53:59.300 --> 03:54:00.300]  чем P1 найдется.
[03:54:01.300 --> 03:54:03.300]  Сд от P1 этого меньше.
[03:54:03.300 --> 03:54:04.300]  И он будет тогда
[03:54:04.300 --> 03:54:05.300]  делителем P1.
[03:54:05.300 --> 03:54:06.300]  Тогда P1...
[03:54:06.300 --> 03:54:07.300]  То есть, вот это вот
[03:54:07.300 --> 03:54:08.300]  это не базовая строка.
[03:54:08.300 --> 03:54:09.300]  Значит, префиксный период.
[03:54:09.300 --> 03:54:10.300]  Я вот просто не помню,
[03:54:10.300 --> 03:54:11.300]  в какой конкретной лемме
[03:54:11.300 --> 03:54:12.300]  мы забабахивали
[03:54:12.300 --> 03:54:13.300]  такие конкретно утверждения.
[03:54:14.300 --> 03:54:15.300]  Может быть, кстати,
[03:54:15.300 --> 03:54:16.300]  лемма 2 и была.
[03:54:18.300 --> 03:54:19.300]  А, ну, смотрите.
[03:54:19.300 --> 03:54:20.300]  Да, у нас же...
[03:54:20.300 --> 03:54:21.300]  Обратите внимание.
[03:54:21.300 --> 03:54:22.300]  Тут у нас прямо в явном виде
[03:54:22.300 --> 03:54:23.300]  лемма 2, да?
[03:54:23.300 --> 03:54:24.300]  То есть, мы говорим,
[03:54:24.300 --> 03:54:25.300]  что если у нас P1
[03:54:25.300 --> 03:54:26.300]  это префиксный период,
[03:54:26.300 --> 03:54:27.300]  то вот это вот
[03:54:27.300 --> 03:54:28.300]  верно тогда
[03:54:28.300 --> 03:54:29.300]  и только тогда,
[03:54:29.300 --> 03:54:30.300]  когда шифтом от Q
[03:54:30.300 --> 03:54:31.300]  является в точности
[03:54:31.300 --> 03:54:32.300]  префиксный период.
[03:54:33.300 --> 03:54:34.300]  То есть, это мы прям
[03:54:34.300 --> 03:54:35.300]  лемма 2.
[03:54:37.300 --> 03:54:38.300]  Тут лемма 1,
[03:54:38.300 --> 03:54:39.300]  а тут прям лемма 2.
[03:54:40.300 --> 03:54:41.300]  Зачем нам были
[03:54:41.300 --> 03:54:42.300]  эти утверждения в явном виде?
[03:54:43.300 --> 03:54:44.300]  Вот, понятно?
[03:54:47.300 --> 03:54:48.300]  Да, нет, наверное.
[03:54:50.300 --> 03:54:51.300]  Ну, типа.
[03:54:53.300 --> 03:54:54.300]  Вот.
[03:54:55.300 --> 03:54:56.300]  Вот.
[03:54:57.300 --> 03:54:58.300]  Вот.
[03:55:00.300 --> 03:55:01.300]  А что мы делаем?
[03:55:02.300 --> 03:55:03.300]  То есть, это вот такой
[03:55:03.300 --> 03:55:04.300]  единственный случай,
[03:55:04.300 --> 03:55:05.300]  когда мы знаем шифт.
[03:55:05.300 --> 03:55:06.300]  Потому что, как вы думаете,
[03:55:06.300 --> 03:55:07.300]  что мы сделаем?
[03:55:07.300 --> 03:55:08.300]  В противном случае...
[03:55:13.300 --> 03:55:14.300]  А, нет.
[03:55:14.300 --> 03:55:15.300]  Так.
[03:55:16.300 --> 03:55:17.300]  То есть, иначе
[03:55:17.300 --> 03:55:19.300]  тогда мы объявим, что...
[03:55:19.300 --> 03:55:21.300]  Давайте P'Q'.
[03:55:23.300 --> 03:55:25.300]  Это максимум
[03:55:25.300 --> 03:55:26.300]  из...
[03:55:26.300 --> 03:55:27.300]  Точнее, так.
[03:55:28.300 --> 03:55:29.300]  Это, значит,
[03:55:29.300 --> 03:55:31.300]  P'Q' максимум
[03:55:31.300 --> 03:55:32.300]  из единицы
[03:55:32.300 --> 03:55:34.300]  и вот этого Q'Q'
[03:55:34.300 --> 03:55:35.300]  в правильную сторону.
[03:55:36.300 --> 03:55:37.300]  Ну, в смысле, вверх.
[03:55:39.300 --> 03:55:40.300]  И ноль.
[03:55:41.300 --> 03:55:42.300]  То есть, просто на Q'Q'.
[03:55:56.300 --> 03:55:57.300]  Вот.
[03:56:06.300 --> 03:56:07.300]  Ну, давайте разбираться.
[03:56:08.300 --> 03:56:09.300]  Что там в округлении стоит?
[03:56:10.300 --> 03:56:11.300]  Q'Q'.
[03:56:11.300 --> 03:56:12.300]  Ну, как и ранее.
[03:56:19.300 --> 03:56:20.300]  Ну, идея очень простая.
[03:56:21.300 --> 03:56:22.300]  Ну, идея такая.
[03:56:22.300 --> 03:56:23.300]  Но, на самом деле, у нас тут
[03:56:23.300 --> 03:56:24.300]  два случая.
[03:56:24.300 --> 03:56:25.300]  Вот, как Q может
[03:56:25.300 --> 03:56:26.300]  не попасть в этот отрезок?
[03:56:28.300 --> 03:56:29.300]  Двумя способами.
[03:56:29.300 --> 03:56:30.300]  Либо Q слишком маленькая,
[03:56:30.300 --> 03:56:32.300]  либо Q слишком большое.
[03:56:32.300 --> 03:56:33.300]  Правда?
[03:56:33.300 --> 03:56:34.300]  Но, заметим, что
[03:56:34.300 --> 03:56:36.300]  если Q слишком большое,
[03:56:36.300 --> 03:56:37.300]  то тогда у этого префикса
[03:56:37.300 --> 03:56:39.300]  длины Q строки V
[03:56:39.300 --> 03:56:40.300]  нет префиксного периода.
[03:56:40.300 --> 03:56:41.300]  Правда?
[03:56:42.300 --> 03:56:43.300]  Но, раз у него нет
[03:56:43.300 --> 03:56:44.300]  префиксного периода,
[03:56:44.300 --> 03:56:46.300]  то вот этот переход валиден.
[03:56:47.300 --> 03:56:49.300]  Сейчас, если у него нет
[03:56:49.300 --> 03:56:50.300]  префиксного периода,
[03:56:50.300 --> 03:56:52.300]  то мы бы сюда не попали.
[03:56:52.300 --> 03:56:53.300]  Чего?
[03:56:53.300 --> 03:56:54.300]  Нет, почему?
[03:56:54.300 --> 03:56:55.300]  Попали.
[03:56:55.300 --> 03:56:56.300]  Потому что, я говорю,
[03:56:56.300 --> 03:56:57.300]  Q просто оказалось
[03:56:57.300 --> 03:56:58.300]  меньше, чем K'1.
[03:56:59.300 --> 03:57:01.300]  Поэтому P'1 не является
[03:57:01.300 --> 03:57:03.300]  префиксным периодом
[03:57:03.300 --> 03:57:07.300]  префикса маленькой длины V.
[03:57:07.300 --> 03:57:08.300]  То есть, чтобы он
[03:57:08.300 --> 03:57:09.300]  являлся префиксным,
[03:57:09.300 --> 03:57:10.300]  нужно, чтобы Q
[03:57:10.300 --> 03:57:11.300]  было хотя бы 4P'1.
[03:57:12.300 --> 03:57:13.300]  То есть, поэтому если оно...
[03:57:14.300 --> 03:57:15.300]  Да, то есть, смотрите,
[03:57:15.300 --> 03:57:16.300]  если оно...
[03:57:16.300 --> 03:57:17.300]  То есть, что получается?
[03:57:17.300 --> 03:57:18.300]  Если оно мелкое,
[03:57:18.300 --> 03:57:19.300]  то все в порядке, да?
[03:57:19.300 --> 03:57:20.300]  Сейчас, если мелкое,
[03:57:20.300 --> 03:57:21.300]  то у Q вообще
[03:57:21.300 --> 03:57:23.300]  нет префиксных периодов, так?
[03:57:24.300 --> 03:57:25.300]  Да.
[03:57:25.300 --> 03:57:26.300]  Поэтому, да.
[03:57:26.300 --> 03:57:27.300]  Поэтому, на самом деле,
[03:57:27.300 --> 03:57:28.300]  вот...
[03:57:28.300 --> 03:57:29.300]  Поэтому переход...
[03:57:29.300 --> 03:57:30.300]  Поэтому переход
[03:57:30.300 --> 03:57:31.300]  просто происходит
[03:57:31.300 --> 03:57:32.300]  абсолютно такой же, как здесь.
[03:57:33.300 --> 03:57:34.300]  Так что это, если Q
[03:57:34.300 --> 03:57:35.300]  было мелкое.
[03:57:36.300 --> 03:57:37.300]  А теперь, внимание,
[03:57:37.300 --> 03:57:38.300]  вопрос, что же делать,
[03:57:38.300 --> 03:57:40.300]  если Q оказалось большое?
[03:57:46.300 --> 03:57:47.300]  Что тогда?
[03:57:47.300 --> 03:57:48.300]  Стоп, еще раз.
[03:57:48.300 --> 03:57:49.300]  Если Q мелкое,
[03:57:49.300 --> 03:57:51.300]  то у префикса длины Q
[03:57:51.300 --> 03:57:52.300]  строки V
[03:57:52.300 --> 03:57:53.300]  нет префиксного периода.
[03:57:55.300 --> 03:57:56.300]  Ну ладно, да.
[03:57:56.300 --> 03:57:57.300]  И это означает,
[03:57:57.300 --> 03:57:58.300]  что можно сделать
[03:57:58.300 --> 03:57:59.300]  переход на Q
[03:57:59.300 --> 03:58:00.300]  делить на K.
[03:58:02.300 --> 03:58:03.300]  А теперь, внимание,
[03:58:03.300 --> 03:58:04.300]  вопрос.
[03:58:06.300 --> 03:58:07.300]  Ой, нет, не туда.
[03:58:07.300 --> 03:58:08.300]  А теперь, внимание,
[03:58:08.300 --> 03:58:09.300]  вопрос.
[03:58:09.300 --> 03:58:10.300]  Вот так надо.
[03:58:10.300 --> 03:58:11.300]  Вот.
[03:58:11.300 --> 03:58:12.300]  Вот.
[03:58:14.300 --> 03:58:15.300]  Значит, что теперь?
[03:58:16.300 --> 03:58:17.300]  Ну вот так.
[03:58:17.300 --> 03:58:18.300]  А что делать,
[03:58:18.300 --> 03:58:19.300]  если Q
[03:58:19.300 --> 03:58:20.300]  наоборот оказалось
[03:58:20.300 --> 03:58:21.300]  прям очень-очень-очень-очень
[03:58:21.300 --> 03:58:22.300]  большое?
[03:58:22.300 --> 03:58:23.300]  Прям больше,
[03:58:23.300 --> 03:58:24.300]  чем этого рычага.
[03:58:24.300 --> 03:58:25.300]  Ну вот.
[03:58:25.300 --> 03:58:26.300]  Верно ли,
[03:58:26.300 --> 03:58:27.300]  что в этом случае
[03:58:27.300 --> 03:58:28.300]  мы тоже можем
[03:58:28.300 --> 03:58:29.300]  заявлять,
[03:58:29.300 --> 03:58:30.300]  что, на самом деле,
[03:58:30.300 --> 03:58:31.300]  с шифтом
[03:58:31.300 --> 03:58:32.300]  тут все в порядке?
[03:58:32.300 --> 03:58:33.300]  То есть, шифт,
[03:58:33.300 --> 03:58:34.300]  как минимум,
[03:58:34.300 --> 03:58:35.300]  Q делить на K.
[03:58:35.300 --> 03:58:36.300]  Ну вот.
[03:58:36.300 --> 03:58:37.300]  Вот.
[03:58:37.300 --> 03:58:38.300]  Ну вот.
[03:58:38.300 --> 03:58:39.300]  Ну вот.
[03:58:39.300 --> 03:58:40.300]  Ну вот.
[03:58:40.300 --> 03:58:41.300]  Ну вот.
[03:58:41.300 --> 03:58:42.300]  Ну вот.
[03:58:42.300 --> 03:58:43.300]  Ну вот.
[03:58:43.300 --> 03:58:44.300]  Ну вот.
[03:58:44.300 --> 03:58:45.300]  Ну вот.
[03:58:45.300 --> 03:58:46.300]  Ну вот.
[03:58:46.300 --> 03:58:47.300]  Ну я не знаю.
[03:58:47.300 --> 03:58:48.300]  Можно ли
[03:58:48.300 --> 03:58:49.300]  тут сослаться
[03:58:49.300 --> 03:58:50.300]  прям на четкую лему?
[03:58:50.300 --> 03:58:51.300]  Или там
[03:58:51.300 --> 03:58:52.300]  лема 2
[03:58:52.300 --> 03:58:53.300]  тоже имела
[03:58:53.300 --> 03:58:54.300]  в виду
[03:58:54.300 --> 03:58:55.300]  на зад Warning
[03:58:55.300 --> 03:58:56.300]  чуть другое.
[03:58:56.300 --> 03:58:57.300]  Но глубокий смысл,
[03:58:57.300 --> 03:58:58.300]  на самом деле,
[03:58:58.300 --> 03:58:59.300]  остается неизменным.
[03:58:59.300 --> 03:59:00.300]  А именно?
[03:59:00.300 --> 03:59:01.300]  Ну вот.
[03:59:01.300 --> 03:59:02.300]  Чего мы?
[03:59:02.300 --> 03:59:03.300]  А, ну понятно.
[03:59:03.300 --> 03:59:04.300]  Ну вот.
[03:59:04.300 --> 03:59:05.300]  Потому что
[03:59:05.300 --> 03:59:06.300]  мы уже вышли,
[03:59:06.300 --> 03:59:07.300]  если
[03:59:07.300 --> 03:59:08.300]  оно меньше
[03:59:08.300 --> 03:59:09.300]  рычага,
[03:59:09.300 --> 03:59:10.300]  если шифт меньше,
[03:59:10.300 --> 03:59:11.300]  по чем мы будем
[03:59:11.300 --> 03:59:12.300]  это делать?
[03:59:12.300 --> 03:59:13.300]  Ну вот.
[03:59:13.300 --> 03:59:14.300]  А если
[03:59:14.300 --> 03:59:15.300]  этоín меньше,
[03:59:15.300 --> 03:59:28.300]  Если шифт меньше, чем кудрить на к, то у нас в поле есть какой-то шифт, но этот шифт не совпадает с П1, потому что мы уже вышли из пределов его влияния.
[03:59:28.300 --> 03:59:36.300]  Да, он не совпадает. Причем более этот шифт, чем четыре этого шифта, тоже является префиксным переводом, что важно.
[03:59:36.300 --> 03:59:38.300]  Ну да.
[03:59:38.300 --> 03:59:50.300]  Ну хотя да, ну вот. А, ну да. А, да-да, все, рассуждение очень простое. Есть шифт, то есть к чему равен шифт? Если шифт меньше либо равно кудрить на к, то он обязан быть префиксным периодом.
[03:59:50.300 --> 04:00:02.300]  Префиксный период у нас только один, это П1. Но на П1 мы сдвинуться не можем, потому что у нас ку слишком большое. Вывод. Значит шифт не может быть кудрить на к.
[04:00:02.300 --> 04:00:11.300]  Сейчас, откуда мы получили, что если шифт меньше либо равно, чем кудрить на к, тогда мы сказали, что у нас...
[04:00:11.300 --> 04:00:27.300]  Тогда я утверждаю, что это префиксный период. Почему? Потому что, во-первых, как бы взятый карас этот шифт, это есть префикс строки, это мы понимаем, да?
[04:00:27.300 --> 04:00:31.300]  А во-вторых, мы понимаем, что строка шифт базовая.
[04:00:31.300 --> 04:00:32.300]  Да, базовая.
[04:00:32.300 --> 04:00:38.300]  Потому что если бы она была не базовая, то там, очевидно, еще более мелкий период бы нашелся.
[04:00:38.300 --> 04:00:39.300]  Взятый карас...
[04:00:39.300 --> 04:00:40.300]  То есть просто лучший шифт.
[04:00:40.300 --> 04:00:42.300]  Нет, стоп. Взятый карас уже за нас перевалит.
[04:00:42.300 --> 04:00:43.300]  Чего?
[04:00:43.300 --> 04:00:51.300]  А, стоп. Мы говорим, что к... Сейчас. Мы говорим, что если шифт меньше либо равно, чем кудрить...
[04:00:51.300 --> 04:00:52.300]  Да.
[04:00:52.300 --> 04:00:57.300]  То есть значит, у нас тут как бы есть период-период, значит и тут 4 экземпляра хотя бы, да?
[04:00:57.300 --> 04:00:59.300]  Тогда пусть шифт меньше.
[04:00:59.300 --> 04:01:04.300]  Тогда шифт, этот меньше шифт, тоже префиксный период.
[04:01:04.300 --> 04:01:06.300]  Понятно, да?
[04:01:06.300 --> 04:01:08.300]  Почему?
[04:01:08.300 --> 04:01:16.300]  Ну, нет, то есть утверждение такое, шифт, это тогда будет префиксный период, если там меньше кудрить, делить на к, почему?
[04:01:16.300 --> 04:01:19.300]  Потому что столько экземпляров есть, и этот шифт еще и базовый.
[04:01:19.300 --> 04:01:21.300]  Почему он базовый?
[04:01:21.300 --> 04:01:32.300]  Потому что, если я тут еще, у меня есть период, допустим, P1, и я распилю его еще на 3 части, ну или там, насколько там, по 5, одинаково от частей, то тогда получается, что это тоже будет период.
[04:01:32.300 --> 04:01:34.300]  И это...
[04:01:34.300 --> 04:01:43.300]  Ну, значит так, если есть меньше какой-то период, то тогда есть период, который является делителем P1, потому что у нас там ХЦДшка.
[04:01:43.300 --> 04:01:48.300]  Вот.
[04:01:48.300 --> 04:01:50.300]  Поэтому получается так.
[04:01:50.300 --> 04:01:58.300]  Ну, просто конкретно в нашем случае получается, что, то есть как бы шифт должен быть префиксным периодом, префиксный период у нас у строки только один, и это P1.
[04:01:58.300 --> 04:02:01.300]  То есть получается, нам надо проверить, P1 подходит или нет.
[04:02:01.300 --> 04:02:10.300]  Мы убеждаемся, что вот P1, вот если этот случай верен, то P1 подходит, а вот этот случай говорит нам, что не подходит.
[04:02:10.300 --> 04:02:20.300]  То есть если P1 не подходит, значит получается меньше, чем QdLT на K, меньше либо равно, чем QdLT на K, у нас периодов нету.
[04:02:20.300 --> 04:02:22.300]  То есть шифтов нет.
[04:02:22.300 --> 04:02:30.300]  Может есть и больше, но мы уже не заморачиваемся, просто перескакиваем на QdLT на K и радуемся жизни.
[04:02:31.300 --> 04:02:34.300]  Хочу меч, чтобы он не порвался.
[04:02:34.300 --> 04:02:38.300]  А зачем там МАКС? У нас не может быть округления.
[04:02:38.300 --> 04:02:43.300]  Ну, вдруг Q равно нулю.
[04:02:43.300 --> 04:02:46.300]  Так-то да, так-то да.
[04:02:46.300 --> 04:02:49.300]  Но Q бывает нулю равно, иногда.
[04:02:49.300 --> 04:02:52.300]  Так случается.
[04:02:52.300 --> 04:02:54.300]  Поэтому-то такую аккуратность пишут.
[04:02:54.300 --> 04:03:04.300]  Так что получается, если у нас вот эта мистическая теорема декомпозиции, откуда-то верна,
[04:03:04.300 --> 04:03:09.300]  каким-то вот мистическим образом она верна, мы откуда-то эти УИВ выкопали,
[04:03:09.300 --> 04:03:13.300]  то тогда после этого мы за ОАТ легко побеждаем.
[04:03:13.300 --> 04:03:16.300]  Ну здесь, я думаю, понятно, что тут тем более ОАТ.
[04:03:16.300 --> 04:03:20.300]  Нам, наверное, еще нужен алгоритм, как это построить.
[04:03:20.300 --> 04:03:23.300]  Как нам вот это построить, да.
[04:03:23.300 --> 04:03:25.300]  Совершенно верно.
[04:03:25.300 --> 04:03:27.300]  Ну тут у нас как бы два варианта.
[04:03:27.300 --> 04:03:29.300]  Мы как бы сидим здесь еще до полвосьмого.
[04:03:29.300 --> 04:03:32.300]  У нас есть вариант, что 8 парам.
[04:03:32.300 --> 04:03:34.300]  У кого? У вас?
[04:03:34.300 --> 04:03:35.300]  У всех.
[04:03:35.300 --> 04:03:36.300]  А что?
[04:03:36.300 --> 04:03:37.300]  Что?
[04:03:37.300 --> 04:03:38.300]  Да.
[04:03:38.300 --> 04:03:39.300]  Чего?
[04:03:39.300 --> 04:03:40.300]  Да, кстати.
[04:03:40.300 --> 04:03:41.300]  Чего?
[04:03:41.300 --> 04:03:43.300]  У нас препод заболел.
[04:03:43.300 --> 04:03:44.300]  Так.
[04:03:46.300 --> 04:03:49.300]  У нас препод заболел и перенес пару в онлайн.
[04:03:49.300 --> 04:03:52.300]  А, ну понятно.
[04:03:52.300 --> 04:03:54.300]  Нет, ну как сказать.
[04:03:54.300 --> 04:03:55.300]  Нет, ну как хотите.
[04:03:55.300 --> 04:03:57.300]  Нет, смотрите, можно сделать и так и так.
[04:03:57.300 --> 04:04:00.300]  Можно в принципе сейчас остановиться и как бы эту теорию доказать в следующий раз.
[04:04:00.300 --> 04:04:02.300]  Давайте я остановлюсь.
[04:04:02.300 --> 04:04:03.300]  Мы все понятно.
[04:04:03.300 --> 04:04:05.300]  Мы выяснили, зачем она нужна.
[04:04:05.300 --> 04:04:06.300]  Да.
[04:04:06.300 --> 04:04:09.300]  То есть мы выяснили, что по модуле эти теории мы бы победили вообще, да.
[04:04:09.300 --> 04:04:12.300]  Мы выяснили, зачем она нужна, а как это доказывать, это уже не так важно.
[04:04:12.300 --> 04:04:13.300]  Ну, точнее, как ее строить.
[04:04:13.300 --> 04:04:15.300]  Потому что это тоже часть алгоритма, извините.
[04:04:15.300 --> 04:04:16.300]  Вот этот раз спил найти.
[04:04:16.300 --> 04:04:18.300]  Так что, да.
[04:04:18.300 --> 04:04:19.300]  Вот, потом выяснится, да.
[04:04:19.300 --> 04:04:21.300]  Я сейчас, конечно, не готов это сказать.
[04:04:21.300 --> 04:04:23.300]  Я сейчас как высушу это 5 минут делов.
[04:04:23.300 --> 04:04:25.300]  Ну ладно, вряд ли, если честно.
[04:04:25.300 --> 04:04:27.300]  Там содержательная часть алгоритма.
[04:04:27.300 --> 04:04:28.300]  Ну ладно.
[04:04:28.300 --> 04:04:29.300]  Значит, тогда остановимся.
