[00:00.000 --> 00:11.200]  Тема, в принципе, не сложная. Просто здесь скорее понимание. Это последний блок,
[00:11.200 --> 00:21.800]  который нам будет важен с точки зрения геометрии. Это выпуклость. Мы чаще всего в, действительно,
[00:21.800 --> 00:28.480]  не знаю там, в современном мире вряд ли вы очень часто встретите какие-нибудь не выпуклые вещи.
[00:28.480 --> 00:34.360]  С точки зрения того, когда что-то обрабатываете, какой-то массив данных на какой-то карте и так далее,
[00:34.360 --> 00:39.400]  вы обычно выделяете там какую-нибудь соту, что-нибудь с ней анализируете и смотрите.
[00:39.400 --> 00:49.800]  И вот очень часто выпуклость здесь может помогать. И выпуклые многоугольники в принципе. Поэтому
[00:49.800 --> 00:57.200]  существует несколько алгоритмов того, как строить такую выпуклую оболочку. Мы сегодня об этом поговорим.
[00:57.200 --> 01:02.840]  И вообще, как проверить, что у нас любой многоугольник является выпуклым или нет. И
[01:02.840 --> 01:09.200]  вообще, что с ним можно делать. Но для начала, что такое выпуклый многоугольник? Выпуклый
[01:09.200 --> 01:14.960]  многоугольник это просто, на самом деле, определений достаточно много. Можно взять
[01:14.960 --> 01:20.360]  определение следующее, что если вы возьмете любую сторону и проделите ее до прямой,
[01:20.360 --> 01:27.240]  то все точки этого многоугольника должны лежать по одну сторону. В этом случае этот
[01:27.240 --> 01:34.120]  многоугольник считается выпуклым. Можно говорить, что если мы возьмем две любые точки внутри
[01:34.120 --> 01:39.040]  многоугольника и проведем между ними прямую, то они не должны пересекать ничего. Вот такое
[01:39.040 --> 01:44.040]  определение тоже существует, но оно очень плохо ложится с точки зрения программирования, потому
[01:44.040 --> 01:51.960]  что что такое любая точка, когда высок бесконечно, это плохо, это беда. И с ней работать сложно.
[01:51.960 --> 02:00.480]  Поэтому мы пока что используем это определение. И вот вопрос. У нас есть какой-то многоугольник,
[02:00.480 --> 02:06.960]  вроде бы все хорошо. А что нам сделать и как нам проверить эту самую выпуклость?
[02:06.960 --> 02:19.520]  Первым способом, в смысле вот этим. Самое простое и единственное, что у меня написано
[02:19.520 --> 02:30.400]  сегодня для вас псевдокодом, это вот это. В действительности, что мы говорим про выпуклые
[02:30.400 --> 02:35.120]  многоугольники, мы говорим следующее, что да, мы с вами можем взять и проверить,
[02:35.120 --> 02:41.960]  является ли многоугольником выпуклым, мы с вами умеем проверять, лежит ли точка слева,
[02:41.960 --> 02:51.040]  ну то есть лежит ли точка по какую-то там сторону от нашей прямой. Нам нужно делать это для всех
[02:51.040 --> 02:58.720]  точек, это по сути от каждой стороны нужно просматривать для всех точек, это будет занимать
[02:58.720 --> 03:08.160]  N квадрат времени. Неприкольно, но наивно, просто понятно, откуда получилось понятно. Понятно,
[03:08.160 --> 03:17.200]  почему за N квадрат? Всем понятно? Или прям нужно очень строгое доказательство? Хорошо. Здесь
[03:17.200 --> 03:23.680]  меня чуть-чуть съехало, ну ладно, извините. Продолжение про выпуклые многоугольники. Смотрите,
[03:23.680 --> 03:32.800]  вроде бы можно делать за N квадрат, но хочется быстрее, потому что N квадрат, ну как бы мы еще
[03:32.800 --> 03:37.240]  по сортировкам знаем, что это не самое прикольное, что у нас есть, это я наверное чуть-чуть потом
[03:37.240 --> 03:45.240]  подправлю, картиночка слишком большая. Для этого, для того чтобы ускорить процесс, мы просто сделаем
[03:45.240 --> 03:52.640]  следующее. Воспользуемся утверждением таким, что у нас многоугольник является строго выпуклым,
[03:52.640 --> 04:01.720]  а если все внутренние углы у нас меньше 180 градусов. Но это все тоже понятно, откуда берется,
[04:01.720 --> 04:05.560]  я думаю вы представляете. То есть вот это утверждение, что тогда и только тогда,
[04:05.560 --> 04:10.400]  позволяет нам сделать следующее. Когда у нас есть какой-то многоугольник,
[04:10.400 --> 04:20.520]  и вот мы смотрим на те углы поворота, которые у нас есть, мы просто будем
[04:20.520 --> 04:28.800]  последовательно рассматривать, а насколько мы поворачиваемся. Когда мы поворачиваемся там
[04:28.800 --> 04:33.920]  против часовой стрелки, мы должны повернуться на сколько и более чем на сколько, как вы думаете.
[04:33.920 --> 04:44.440]  Вот мы вот все это векторочками таким смотрим. Не больше, чем на 180 градусов. Именно поэтому в
[04:44.440 --> 04:51.440]  этом случае мы скажем, что у нас все будет хорошо. Мы смотрим именно ориентированные эти углы. А что
[04:51.440 --> 04:57.840]  это означает для нас с точки зрения программира? Как понять, поворачиваемся мы на 180 или больше
[04:57.840 --> 05:11.560]  или меньше? Еще раз? Кто-то сказал какое произведение? Какое нам нужно сделать? Векторное
[05:11.560 --> 05:21.240]  или скалярное? Ладно, векторное. Да, в действительности нам здесь поможет векторное произведение. Причем нам
[05:21.240 --> 05:27.480]  не нужно вычислять угол. Пожалуйста, вот уберите у себя из головы паттерн, а поведение,
[05:27.480 --> 05:32.520]  что везде нужно считать угол, и тогда будет понятно, на какой угол мы поворачиваемся. Нет,
[05:32.520 --> 05:37.520]  вам нужно от этого уходить, потому что арксинус и арккосинус и так далее. Это, во-первых, очень
[05:37.520 --> 05:44.000]  долгая операция, очень неточная операция будет для вас. И в некоторых моментах она, наоборот,
[05:44.000 --> 05:54.160]  будет мешаться. Поэтому здесь все, что вам нужно, просто посмотреть на последовательность векторочков
[05:54.160 --> 06:03.000]  между собой и посчитать между ними то самое векторное произведение. Если у вас все углы будут одного
[06:03.000 --> 06:09.840]  и того же знака. Обычно многоугольник задается все-таки последовательностью какой-то. Если у вас
[06:09.840 --> 06:15.120]  будут все углы одного и того же знака, причем он может как в одну сторону идти, то есть слева-направо,
[06:15.120 --> 06:22.320]  почасовой, может быть и противчасовой. Поэтому у вас все векторные произведения должны быть
[06:22.320 --> 06:30.360]  просто одного знака. Вы считаете все их, смотрите, что там происходит. Если они все одного знака,
[06:30.360 --> 06:39.560]  то все хорошо, если нет, то все грустно. Работает это все чудо за тет-а-тен. Все достаточно просто,
[06:39.560 --> 06:46.840]  потому что у вас сколько будет векторных произведений? Ладно, оставлю этот вам вопрос на
[06:46.840 --> 07:00.720]  экзамен. Посидите, посчитайте. Хорошо, предположим. Но в действительности как бы так или иначе это все
[07:00.720 --> 07:09.720]  уходит около n. Это все работает за тет-а-тен, потому что вы умеете считать векторное произведение за
[07:09.720 --> 07:21.080]  за единицу. Помните как, я надеюсь, правда? Отлично. Вот вы умеете считать все это за единицу,
[07:21.080 --> 07:25.920]  поэтому все векторные произведения вы просто смотрите, заводите какую-нибудь более
[07:25.920 --> 07:32.520]  вопеременную. Все у вас все получилось, все хорошо, вы молодцы. Так можно проверять выпуклые
[07:32.520 --> 07:41.080]  многоугольники. И это нам позволяет как раз таки все это рассматривать и смотреть. Есть ли тут
[07:41.080 --> 07:53.600]  вопросы? Нет тут вопросов. А теперь давайте вернемся с вами к интересному моменту. Когда
[07:53.600 --> 07:58.720]  мы говорили с вами про принадлежность точки, это было две недели назад, я надеюсь вы это помните,
[07:58.720 --> 08:08.240]  вот еще. У нас была принадлежность точки внутренности нашего какого-то многоугольника. Давайте
[08:08.240 --> 08:15.800]  будем рассматривать именно выпуклые многоугольники. Я хочу попробовать сделать это быстрее, чем мы с
[08:15.800 --> 08:22.640]  вами делали или просто не лучом. Потому что проверять, пересекает ли луч все подряд стороны,
[08:22.640 --> 08:31.720]  тоже не самое прикольное занятие. Какая есть здесь идея? Идея начальная следующая. Давайте рассмотрим,
[08:31.720 --> 08:40.800]  ну возьмем какую-то точку и рассмотрим все вектора до остальных вершин, которые у нас есть
[08:40.800 --> 08:47.480]  многоугольники. Что мы можем сказать про эти вектора? Вот так последовательно, если смотреть.
[08:47.480 --> 08:51.080]  Что происходит с углами у этой последовательности векторов?
[08:51.080 --> 09:03.160]  Она возрастает, то есть у нас углы поворота вот от самой, ну от оси у х можно сказать,
[09:03.160 --> 09:14.120]  можно просто сказать там от нижнего вектора, как удобнее. Она возрастает. То есть это возрастающая
[09:14.120 --> 09:23.440]  последовательность вот уголков будет, правда? А теперь следующий вопрос. Когда у нас, ну то есть
[09:23.440 --> 09:28.480]  это грубо говоря, вот эта последовательность, она отсортирована. А мы можем ее воспринимать так.
[09:28.480 --> 09:38.840]  Что мы умеем делать в отсортированных массивах? Бинпоиск умеем. А зачем нам будет нужен бинпоиск,
[09:38.840 --> 09:50.520]  как ты думаешь? Да, то есть смотрите, что я хочу сделать? Я хочу сделать примерно следующее. Вот у
[09:50.520 --> 09:55.480]  меня есть вот эта последовательность векторов. Я знаю, на какие углы они грубо говоря повернуты
[09:55.480 --> 10:03.400]  между собой. Ну какими-то значениями я их буду сравнивать. Это чудесно. Я хочу понять, где,
[10:03.400 --> 10:10.480]  между какими векторочками лежит моя p' или p2', здесь в зависимости от того, какую точку выберете.
[10:10.480 --> 10:16.800]  Ну, предположим, что p'. Что мне это даст? Ну, в действительности здесь несколько будет вариантов.
[10:16.800 --> 10:24.080]  Можно посмотреть, является ли точка внутри треугольника, если она внутри него. Можно посмотреть,
[10:24.080 --> 10:31.880]  пересекаются ли отрезки. Можно посмотреть, является ли p' и p0 по одну сторону относительно там. Ну,
[10:31.880 --> 10:43.280]  здесь p4 по 3, грубо говоря. Вот. Такие варианты есть. То есть, первое, что мы делаем, у нас они
[10:43.280 --> 10:51.480]  расположены в порядке возрастания. Печатал и ошибся. Ну ладно, извините. Вот. Рассмотрим,
[10:51.480 --> 10:58.440]  точку p' проводим этот вектор, смотрим, между какими оно лежит. Это чудесно. Мы с помощью бинарного
[10:58.440 --> 11:03.680]  поиска, так как у нас все отсортировано, находим залогариф. Дальше проверяем, пересекается,
[11:03.680 --> 11:09.360]  не пересекается, ну или лежит по одну сторону, не лежит и так далее. За o от единички получается,
[11:09.360 --> 11:22.760]  за сколько работает алгоритм? Я либо слишком... У вас всегда многоугольник задан о конкретной
[11:22.760 --> 11:31.000]  последовательности, соединяющей друг к дружку. Ну, то есть, грубо говоря, вот у вас есть вот такая,
[11:31.000 --> 11:37.160]  вот такая вещь. Если вдруг вам дадут вот эту точку, ну типа, вот у вас есть p0, а p1 скажут,
[11:37.160 --> 11:44.640]  что вот это, а вот это будет p2, тогда у вас будет вот так соединяться. Вот. Многоугольник всегда
[11:44.640 --> 11:51.520]  дан последовательностью такой, которую мы можем соединить подряд. Вот. Если мы заходим все
[11:51.520 --> 11:59.000]  залогариф, то залогариф. Либо сейчас половина не понимает, что происходит, либо вы сонны,
[11:59.000 --> 12:10.600]  либо вы делаете что-нибудь другое. Это просто слишком... Хорошо, значит скоро мы дойдем до сложных. Вот.
[12:10.600 --> 12:18.480]  А у меня вопрос, а как сравнивать углы между собой? То есть вы так согласились, что все отсортировано,
[12:18.480 --> 12:23.240]  все классно, все хорошо. А как сравнивать вот углы между собой? То есть нам нужно же попасть все
[12:23.240 --> 12:34.080]  равно по штриху как-то. Посмотреть p1 и p2, что посмотреть? Направление ориентированного угла. Да.
[12:34.080 --> 12:43.080]  Суть своей это правда. То есть нам достаточно здесь посмотреть p0, ну то есть, просто скалярное
[12:43.080 --> 12:51.520]  произведение p0, ой, господи, векторное произведение, p0 по штриху и p0 по it. То есть мы поймем,
[12:51.520 --> 13:03.840]  какой у нас угол поворота. Согласны? Вот мы и сравнили наши углы. И все, что вам нужно
[13:03.840 --> 13:09.880]  делать в компараторе, вот в таких задачках, все, что вам нужно сделать, это взять просто,
[13:10.240 --> 13:18.840]  он меньше 0, больше 0. И это будет вашим компаратором. То есть, грубо говоря, именно сама суть
[13:18.840 --> 13:23.640]  компаратора, что она делает? Она возвращает этот левее находится или это правее находится? Меньше,
[13:23.640 --> 13:31.520]  больше. Вот это и будет меньше, больше. Понятно? Не нужно придумывать косинусы, пожалуйста,
[13:31.520 --> 13:40.440]  уходим, уходим от этой концепции в этом мире, в мире алгоритмов. Поверьте, считать их неприкольно,
[13:40.440 --> 13:57.320]  даже если вы думаете, что это просто. Вот. Принято, принято. Я что-то прямо это, чтобы вы понимали,
[13:57.320 --> 14:03.080]  половина презентации закончила. Я понял, я опаздывал, сейчас могу очень спешить. Пожалуйста,
[14:03.080 --> 14:08.960]  если что, останавливайте, приостанавливайте, спрашивайте. Теперь переходим к основной части,
[14:08.960 --> 14:17.040]  на самом деле, того, что у нас есть. Называется эта штука выпуклой оболочкой. Выпуклая оболочка,
[14:17.040 --> 14:24.800]  множество каких-то точек S. Называется минимальная по включению выпуклая множество. То есть,
[14:24.800 --> 14:31.800]  по факту, это множество. Важно здесь помнить следующее, что если вдруг у вас есть множество,
[14:31.800 --> 14:41.080]  ну какая-то пара точек, вы их соединяете, у вас все хорошо, но на ней лежит еще какая-то точка,
[14:41.080 --> 14:48.360]  то вот она не будет входить в выпуклую оболочку. Выпуклая оболочка — это минимальная такая часть,
[14:48.360 --> 14:55.640]  которая вас покрывает все остальные точки. Можете воспринимать это именно так. Что важно
[14:55.640 --> 15:01.240]  осознавать с точки зрения математики? Количество точек может быть какое?
[15:04.240 --> 15:11.040]  Ну бесконечное почти никогда не бывает, вам все-таки задают их чиселками. Какое?
[15:11.040 --> 15:19.560]  Счетное количество точек. Вот когда у вас находится счетное число точек,
[15:19.560 --> 15:25.840]  а в действительности вам там нужно будет исхитряться, ну вообще такое вы не зададите просто
[15:25.840 --> 15:32.040]  в программировании, либо у вас будет бесконечное, потому что у вас будет действительное число,
[15:32.040 --> 15:38.240]  либо у вас будет конечное число. Но для счетного числа это будет такой небольшой кружочек по факту,
[15:38.240 --> 15:45.080]  потому что ну там рациональными чиселками вы можете вот это все добить. Вот, а если же мы с вами
[15:45.080 --> 15:55.880]  говорим про, не обязательно прям кружочек, хорошо, типа, ты осмутила это. Счет на это бесконечно,
[15:55.880 --> 16:01.200]  я не отрицаю. Я имею ввиду количество вещественных чисел типа все-таки больше,
[16:01.360 --> 16:08.320]  вот. Либо мы уходим вещественные числа, ну да, был у вас все-таки вещественные числа пытается
[16:08.320 --> 16:18.720]  покрыть, а либо мы работаем с целыми числами, вот, одно из двух. Но мы будем рассматривать вообще в
[16:18.720 --> 16:24.520]  курсе, ну и в принципе вы в жизни скорее столкнетесь с несчетным количеством, тем более с...
[16:24.520 --> 16:37.680]  Прошу прощения, не сильно, еще быстрее, видимо. В общем-то мы будем сталкиваться с конечным
[16:37.680 --> 16:44.320]  числом точек, почти всегда, но все-таки считать-то вам их как-то надо, что будет
[16:44.320 --> 16:52.600]  означать следующее. Если у вас конечное число точек, то у вас выпуклая оболочка это всегда
[16:52.600 --> 17:04.320]  многоугольник выпуклый. Просто некоторый многоугольник, который у вас будет,
[17:04.320 --> 17:11.200]  и с ним необходимо работать. И вот вопрос самый главный с выпуклыми оболочками, а как это делать?
[17:11.200 --> 17:21.400]  Смотрите, про выпуклые оболочки. Чего есть интересного? Есть интересного,
[17:21.400 --> 17:26.440]  стоят два алгоритма, которые мы с вами сегодня пройдем. Это алгоритм Джарвиса,
[17:26.440 --> 17:30.920]  алгоритм Грехома. Может быть, кто-то из вас что-то такое слышал, может быть, нет.
[17:30.920 --> 17:39.440]  Вот. Дальше, если кого-то очень сильно увлечет эта тема, вы можете подумать на тему того,
[17:39.440 --> 17:48.800]  а как строить выпуклую оболочку в 3D. У вас такой задачи не будет. Раньше, по-моему,
[17:48.800 --> 17:55.200]  сейчас ее убрали даже из программы и основного потока. Возможно, продвинутым она осталась.
[17:55.200 --> 18:07.520]  Вот. Там забавно. Я просто помню, как у меня сосед делал эту 3D оболочку. Ушло у него две с
[18:07.520 --> 18:14.680]  половиной недели, наверное, потому что тот white paper, который был и по которому можно было бы все
[18:14.680 --> 18:20.400]  сделать, там был написан неправильный алгоритм. За это вы дебажите еще больше. Но здесь все будет
[18:20.400 --> 18:26.680]  написано правильно, но никакого псевдокода и кода тем более. Начнем мы с алгоритма Джарвиса на самом
[18:26.680 --> 18:34.480]  деле и поймем, что вообще с ним можно делать. Смотрите, алгоритм Джарвиса очень часто называют
[18:34.480 --> 18:42.920]  еще заворачивание подарка. Почему? Потому что, предположим, то у меня есть какой-то набор точек.
[18:42.920 --> 18:57.400]  Вот. А что делается в алгоритме Джарвиса? Фиксируется сначала самая нижняя левая точка,
[18:57.400 --> 19:08.200]  потому что она 100% лежит в нашей выпуклой оболочке. Можно зафиксировать самую правую
[19:08.200 --> 19:14.120]  верхнюю точку, но просто так повело, что фиксирует самую левую. Ну она точно будет,
[19:14.120 --> 19:20.640]  почему? Ну нам нужно же покрыть все множество, ниже нее ничего не бывает и левее ее ничего не
[19:20.640 --> 19:29.840]  бывает. Поэтому она точно входит. Окей? Вот. И что подразумевается, как родился вообще этот алгоритм?
[19:29.840 --> 19:36.200]  Смотрите, мы представим, что у вас есть какая-нибудь огромная нитка, а вот эти все точки – это гвоздики.
[19:36.200 --> 19:45.560]  Как вам с помощью этой ниточки построить эту выпуклую оболочку? Просто завернуть ее. Ну то есть
[19:45.560 --> 19:52.400]  вы просто вот так вот пойдете по кругу и попытаетесь все завернуть. И благодаря этому у вас
[19:52.400 --> 19:56.880]  появится та самая выпуклая оболочка. Поэтому этот алгоритм иногда называют алгоритмом
[19:56.880 --> 20:02.240]  заворачивания подарка. Давайте все-таки отдавать дань тому, кто это придумал. Это был Джарвис.
[20:02.240 --> 20:12.840]  Вот. Поэтому в действительности алгоритм звучит очень просто. Смотрите, мы берем точку P0,
[20:13.040 --> 20:22.200]  которую у нас здесь есть. Дальше выбираем точку P1. Как мы выбираем? Как вы думаете?
[20:22.200 --> 20:39.480]  Да, чтобы у нас просто был минимальный угол сам по себе. С осью X. А после этого в действительности
[20:39.560 --> 20:48.760]  мы с вами пытаемся найти еще одну точку, которая будет образовывать с нашим новым
[20:48.760 --> 20:55.080]  каким-то векторочком. В этом случае это вот этот векторочек. Минимальный угол поворота. То есть
[20:55.080 --> 21:04.960]  вот мы рассматриваем все возможные такие вот лучи, смотрим где у нас минимальная и добавляем
[21:04.960 --> 21:13.120]  эту точку. Минимальная будет вот здесь. Поэтому добавляем эту точку. Потом от нее опять же смотрим
[21:13.120 --> 21:21.320]  на все остальные точки. И так мы просто по чуть-чуть идем. То есть мы смотрим минимальный угол этого
[21:21.320 --> 21:38.800]  поворота, который у нас есть. Звучит просто. Что, как вы думаете, здесь сложно? Минимальный угол
[21:38.800 --> 21:53.160]  каждый раз искать. Сколько это стоит, как вы думаете? А? Ага. N квадрат, N квадрат. За сколько
[21:53.160 --> 21:59.320]  работает алгоритм? Давайте, хорошо. Остальные, как вы думаете, за сколько работает алгоритм? N квадрат.
[21:59.320 --> 22:09.840]  Хорошо. Вопрос следующий. Все ли точки входят в вашу выпуклую оболочку? Не обязательно. Поэтому
[22:09.840 --> 22:19.640]  не работает он за N квадрат. Что еще раз? Да не работает он за N квадрат. Ну хорошо. Тогда он из
[22:19.640 --> 22:25.000]  того от N куп работает. Давайте, если вы уж в такие дебри пошли. Знаете, в действительности у нас все
[22:25.000 --> 22:33.880]  зависит от того, сколько точек в нашей выпуклой оболочке. Именно в зависимости от этого мы и смотрим,
[22:33.880 --> 22:43.120]  что у нас происходит. И для каждой этой точки мы ищем минимальный угол. По минимальному углу мы
[22:43.120 --> 22:48.160]  уже поняли, как это найти. Это все очень просто и очень быстро. Поэтому, да, для каждой точки это
[22:48.160 --> 22:55.800]  за O от единички всего точек N, за O от N. Поэтому у нас будет O от N действий на каждую из, ну там,
[22:55.800 --> 23:06.280]  H из нашей выпуклой оболочки. То есть это работает за O от N H. А в каком случае алгоритм Джарвиса
[23:06.280 --> 23:15.840]  хороший? Ну смотрите, возможно, у вас будет условие какое-нибудь такое, что у вас будет обязательно
[23:15.840 --> 23:22.080]  покрываться это треугольником. Может быть такое? Может быть такое. Тогда в этом случае это будет
[23:22.080 --> 23:30.960]  работать за O от N. А может быть такое, что все точки будут лежать в вашей выпуклой оболочке. В этом
[23:30.960 --> 23:40.480]  случае это будет работать за N квадрат. Еще раз. Еще раз. Давайте так. Мы отказываемся от концепции
[23:40.480 --> 23:50.960]  углов. Хорошо? А как мы считаем эти величины? Как мы сравниваем между собой углы? Давайте еще
[23:50.960 --> 23:57.720]  раз я напомню это. Мы сравниваем между собой углы просто по векторному произведению. У нас
[23:57.720 --> 24:03.680]  один вектор есть. То есть мы же рассматриваем относительно вот этого вектора, какой у нас
[24:03.680 --> 24:09.880]  есть поворот. Давайте относительно него и рассматриваем все, что у нас есть. Мы только что сравнивали.
[24:10.040 --> 24:18.840]  Мы только что говорили, что можем сделать за O от логарифма бинпоиск, потому что мы
[24:18.840 --> 24:28.960]  легко умеем подряд это сделать. Сейчас, смотрите. Смотрите, давайте еще раз. Концепция следующая.
[24:28.960 --> 24:39.400]  Вот скажите мне. Вот у меня есть вот этот векторочек. Я относительно него смотрю все повороты,
[24:39.400 --> 24:48.800]  которые у меня есть. Как я могу сравнить, типа, у меня поворот корректен или некорректен? Ну,
[24:48.800 --> 24:57.200]  типа, подходит к ней или нет? Буду ли я считать прям... Что там? Косинус, синус, угла. Что хотите?
[24:57.200 --> 25:06.640]  Косинус хотите. Очень хочется. Только есть... А, нет, нет проблемы. Ладно, хорошо. Здесь не будет
[25:06.640 --> 25:20.240]  проблем. Давайте. У нас есть векторное произведение, у нас есть скалярное произведение. Скалярным
[25:20.240 --> 25:27.960]  произведением не часто вы можете работать. Здесь скорее векторное произведение. Можем ли мы между
[25:28.080 --> 25:34.920]  собой сравнить, насколько мы повернемся вот к этой точке, грубо говоря, и вот к этой точке?
[25:34.920 --> 25:48.760]  Между собой мы можем сравнить? Можем сравнить. Отлично. Мы сравнили. Мы такие, ага. Вот давайте так,
[25:48.760 --> 25:55.600]  не так. Вот эту точку у меня есть. Теперь давайте следующую возьму. Вот эту точку. Могу ли я сказать,
[25:55.600 --> 26:06.000]  что в этом случае... Вот раз и вот два. Могу ли я сказать, что вот в этом случае у меня поворот
[26:06.000 --> 26:15.680]  меньше, просто сравнив их? Могу. То есть, я говорю, вот эта точка минимальна. Я прохожусь по всем
[26:15.680 --> 26:22.880]  точкам и смотрю. Вот все, что ниже нее, оно минимально. Оно меньше него. Давайте выше смотреть. Я не
[26:22.880 --> 26:28.680]  смотрю на сам угол. Я смотрю на это векторное произведение. Куда я поворачиваюсь? Влево поворачиваюсь.
[26:28.680 --> 26:35.360]  Классно. Право поворачиваюсь. Значит, вот эта точка, в которой она находится меньше. Понятно,
[26:35.360 --> 26:42.040]  что я делаю? То есть, я еще раз. Я не смотрю на сам угол. Я не смотрю на синус. Я просто умею
[26:42.040 --> 26:49.880]  сравнивать между собой уголочки, а значит, я между собой могу сравнивать и углы. Я между собой
[26:49.880 --> 26:54.720]  сравниваю вот эти вектора, как у меня поворот выглядит, и так сравниваю углы. То есть, я не
[26:54.720 --> 27:02.600]  отталкиваюсь от синусов и косинусов. Я отталкиваюсь от того, у меня будет левый или правый поворот. Ага. Вот.
[27:02.600 --> 27:14.360]  Окей. Про сложность. Понятно, что за NH. Не говорите никому, что за N квадрат. И за N тоже не говорите.
[27:14.360 --> 27:27.400]  Вот это совсем будет беда. Хорошо? За N dash. Кайф. А теперь, смотрите, интересный факт. Как вы думаете,
[27:27.400 --> 27:41.680]  какое минимальное время, за которое, в общем случае, можно найти выпуклую оболочку? N. Log N. N log N.
[27:41.680 --> 28:01.000]  Порядочим по какой-то координате. N квадрат. N log N. Давайте голосование. Мне очень нравится вот это.
[28:01.000 --> 28:15.320]  У нас есть кандидаты N. N log N. N квадрат. За сколько минимальное время работы, в общем случае, ниже
[28:15.320 --> 28:21.480]  которого невозможно быстрее сделать, грубо говоря. Давайте, типа, кто за O от N. Мне просто интересно.
[28:21.480 --> 28:32.760]  Дальше человек, который был за нее, отказался. Кто за N log N? А кто за N квадрат? А как в это сделать?
[28:32.760 --> 28:47.880]  Грустная история. Вот здесь у нас получается максимум. А почему? Да. N совсем мало так. А в
[28:47.880 --> 28:55.640]  действительности, смотрите. Но нужно это очень хорошо доказать, в общем-то, в случае. И мы с вами
[28:55.640 --> 29:00.640]  сейчас этим займемся. Там есть отдельный слайд, но там прям все написано, поэтому вернемся к нему,
[29:00.640 --> 29:08.600]  когда мы уже все это сделаем. А на что похоже N. Log N? Где еще минимальную оценку встречали N. Log N?
[29:08.600 --> 29:16.600]  Тортировках. Помните, мы говорили о том, что невозможно ниже, чем N. Log N. Этот нижний барьер
[29:16.600 --> 29:23.560]  преодолеть на сортировке сравнению. Давайте попробуем свести задачу с выпуклой оболочкой
[29:23.560 --> 29:35.960]  к задаче сортировки. Вы на меня так смотрите? Лучше всегда все сводить к чему-то известному,
[29:35.960 --> 29:39.840]  потому что тогда вы получите какой-нибудь факт. Предположим, что у меня есть точки.
[29:39.840 --> 29:49.720]  В том порядке, в котором они идут, иначе это бессмысленно. Вот так у нас получится.
[29:49.720 --> 30:02.680]  Иначе это очень странная гипотеза. Называю это так. Вот у нас есть такие точки. Давайте, давайте.
[30:02.680 --> 30:21.880]  Что будем? Ну нет, это ужасно. Давайте возьмем следующие. Возьмем точку x0 в квадрате, x1 в квадрате
[30:21.880 --> 30:41.120]  и так далее. Что у нас тут получается? Ну хорошо, да, действительно не гипер было, все-таки пора было.
[30:41.120 --> 30:53.280]  Вот у нас получается такой вот некоторый график. Восточно с мотоном, с линавом все хорошо, да?
[30:53.280 --> 31:01.960]  Хорошо. Ладно, ну как бы у нас есть вот эти вот отсортированные точки. Ну я их здесь укажу,
[31:01.960 --> 31:06.200]  как уже отсортированные. В действительности мы просто смотрим, что у нас здесь есть какие-то
[31:06.200 --> 31:19.320]  точки. И у нас будет действительно такая вот какая-то параболка. А точки как-то хаотично,
[31:19.320 --> 31:23.880]  но все равно они образуют вот такую параболу. Скажите, все ли точки будут лежать в выпуклой оболочке?
[31:23.880 --> 31:31.360]  Ну у нас прямых линий все-таки тут не предвидится, правда? И они будут всегда идти поверх. Ну то есть
[31:31.360 --> 31:43.600]  у нас выпуклая оболочка будет какая-то вот такая. Там я утрированно рисую, ну вы поняли. То есть
[31:43.600 --> 31:49.360]  будет такая. И вот она замкнется как-то вот так. То есть у нас появится вот такая вот выпуклая
[31:49.360 --> 31:56.840]  оболочка сама по себе. Смотрите, я упорядочил эти числа между собой. Согласны? Ну я точки в
[31:56.840 --> 32:04.720]  нужном порядке расставил. Даже если я начну с P0, который на нуле находится, я пойму,
[32:04.720 --> 32:15.520]  когда я туда уже пришел. Согласны? А теперь смотрите, могу ли я сделать быстрее, чем Зейн Луген?
[32:15.520 --> 32:25.040]  Сортировку чисел. А ровно так же выпуклая оболочка я не смогу сделать Зейн Луген быстрее. Х0 это
[32:25.040 --> 32:32.640]  число, которое у тебя было дано здесь. Х0 в квадрате это по Y. Сейчас подождите. Мы отталкиваемся от
[32:32.640 --> 32:39.960]  другого случая. Я пытаюсь свести задачу к тому, что у нас должна быть сортировка чисел, грубо
[32:39.960 --> 32:45.800]  говоря. У меня даны какие-то числа на вход, я должен получить их на выход. Я могу отсортировать
[32:45.800 --> 32:56.400]  с помощью выпуклой оболочки. Ну вот я тебе привел пример, как я могу это сделать. Да? У нас было
[32:56.400 --> 33:00.840]  с вами утверждение про вот этот минимальный барьер, что нельзя сделать это быстрее, чем Зейн Луген.
[33:00.840 --> 33:06.800]  Значит, здесь мы не можем сделать быстрее, чем Зейн Луген. Поэтому в действительности нельзя
[33:06.800 --> 33:16.640]  сделать выпуклую оболочку быстрее, чем Зейн Луген. Окей? Механизм принятия решений понятен?
[33:16.640 --> 33:29.880]  Вот. Поэтому да, никакую выпуклую оболочку нельзя сделать быстрее. То есть у вас есть ограничение
[33:29.880 --> 33:39.480]  снизу. Это омега большой, это Н Луген. Поэтому мы должны подумать, существует ли такой алгоритм.
[33:39.480 --> 33:45.640]  И вот там назвали один такой алгоритм. В действительности это алгоритм Грехема. Давайте с ним разбираться.
[33:45.640 --> 33:52.200]  По чуть-чуть. Алгоритм Грехема первоначально будет очень похож на алгоритм Джарвиса. И там,
[33:52.200 --> 34:01.280]  и там в начале выбирается самая точка, которая обязательно лежит в вашей выпуклой оболочке.
[34:01.280 --> 34:11.560]  Я беру также самую левую и нижнюю. Вот. А дальше делают следующее. Вот здесь, кстати,
[34:11.560 --> 34:18.840]  у меня Н потерялось. Ну ладно. А дальше делают следующее. Давайте отсортируем все точки по
[34:18.840 --> 34:25.960]  величине угла относительно там P0, P1. Ну то есть все также возьмем там первую точку. Первую точку легко
[34:25.960 --> 34:41.200]  найти там за УАТ. А дальше отсортируем все точки относительно вот этого вектора. Мы сортируем.
[34:41.200 --> 34:48.840]  Если вдруг у точек одинаковый одинаковый угол, то нужно смотреть по величине вектора. Но это
[34:48.840 --> 34:53.480]  связано с тем, что точки, лежащие на одной и той же прямой, должны вот вы должны брать дальнюю самую.
[34:53.480 --> 35:02.880]  Окей? Окей. Я отсортировал. Что делаю дальше? Да, я говорю Н потерял. За N лог N. Смотрите,
[35:02.880 --> 35:10.520]  я сортирую все точки относительно вектора P0, P1. То есть какой они образуются с ними угол.
[35:10.520 --> 35:24.240]  Берем минимальную. Так. Минимальная точно лежит. Хорошо, а что дальше? Повторяем сортировку. Звучит
[35:24.240 --> 35:33.440]  грустно. Берем следующую и смотрим, куда она поворачивает. Так. Убираем P2, предлагаем P3. Да.
[35:33.440 --> 35:39.760]  С помощью чего это лучше реализовывать? Так, все правильно. Объясните мне,
[35:39.760 --> 35:46.120]  вам на семинаре что-нибудь рассказывали? Все, я понял. Все от этого достаточно просто и стало.
[35:46.120 --> 35:57.120]  Да, смотрите, мы с вами, когда отсортировали все точки, мы будем перебирать точки по возрастанию.
[35:57.120 --> 36:05.600]  Если вдруг у нас объявляется тот самый правый поворот, а не левый поворот, то мы начинаем
[36:05.600 --> 36:13.720]  выкидывать точки сами по себе из нашего стека. А зачем мы это делаем? А мы делаем это затем,
[36:13.720 --> 36:22.840]  чтобы у нас образовался именно правый поворот. Потому что левый поворот, sorry. Левый поворот
[36:22.840 --> 36:31.560]  для того, чтобы у нас с вами как раз таки было вот то, то мы с вами вот таким вот образом будем
[36:31.560 --> 36:43.680]  ходить везде. Грубо говоря, если мы с вами рассматриваем все точки, то в этом случае мы с
[36:43.680 --> 36:52.480]  вами говорим о том, что мы просто ходим. Давайте я где-нибудь это порисую, чуть понятнее может
[36:52.480 --> 37:00.600]  будет. Хотя, видимо, вам там все и так понятно. Ну что же, в субботу я нагоню, а дальше вам
[37:00.600 --> 37:10.680]  будет уже не так все просто. Я надеюсь. Хотя, если вам все просто, то жизнь удалась, я считаю.
[37:10.680 --> 37:22.280]  Ну в общем-то, смотрите, предположим, что у меня уже есть какая-то там выпуклая оболочка, а дальше
[37:22.280 --> 37:38.640]  пусть будет вот так и вот так. Так лучше. Вот так просто сделаем. Мы уберемся с одну просто точку.
[37:38.640 --> 37:52.080]  Такое может быть. Отлично. Да, мы это делаем постоянно. Вот мы видим такое, видим, что у нас
[37:52.080 --> 37:59.520]  здесь уже вот сюда вектор есть. Здесь слишком большой поворот. Тогда в этом случае мы просто
[37:59.520 --> 38:04.520]  баним ту точку, которая у меня есть. Она находится в стеке на самом верху, поэтому выкинуть из стека
[38:04.520 --> 38:11.360]  нам достаточно просто. А дальше мы соединяем со следующим и смотрим, у меня будет здесь необходимый
[38:11.360 --> 38:18.320]  мне поворот или нет. Но причем, заметьте, стект хорошо, но вам нужно хранить не только верхнюю вершину,
[38:18.320 --> 38:31.240]  иметь доступ к ней, но еще и к предыдущей. Как так можно сделать? Весь в этом. В стеке два значения.
[38:31.240 --> 38:55.080]  Смотрите. У вас в стеке лежат точки P0, P1, P2, P3. Выкину я P3, хорошо, предположим. Я смотрю на точку P2,
[38:55.080 --> 39:08.080]  а я не знаю точки P1. Вот вы в стеке умеете обращаться к предыдущему элементу? Так, хорошо.
[39:08.080 --> 39:31.720]  Проходили ли вы контейнеры? Нет, контейнеры, значит, все не проходили. Викторан? Пока что да. Ну,
[39:31.720 --> 39:37.680]  значит, будете, если что, делать просто вам динамический массив на максимальное количество вершин,
[39:37.840 --> 39:43.280]  дальше добавлять, ну, убавлять сайс, увеличивать сайс, и все равно по индексу вы можете ходить.
[39:43.280 --> 39:52.560]  Вот. Это то же самое. Виктора просто умеют менять размер вашего массива. Двухсвязный
[39:52.560 --> 40:01.080]  список получается. Потому что, потому что. Не, ну, в действительности вы можете это сделать. Но
[40:01.080 --> 40:13.800]  только в этом случае это уже не стек, а все-таки, ну, просто такой обрезанный дек, я бы сказал. Вот. А? Ну,
[40:13.800 --> 40:20.120]  лист, да. Просто используйте лист. Но, а в общем случае это звучит именно как стек. То есть,
[40:20.120 --> 40:24.600]  предложение первое, которое вводилось в данный алгоритм, это было со стеком. Теперь давайте
[40:24.600 --> 40:30.800]  рассмотрим с вами, за сколько будет работать данный алгоритм. Я специально не писал сегодня вам
[40:30.800 --> 40:37.240]  типа код, еще что-то. Не прикольно. Вам нужно самим. Я думаю, вы на семинарах это, видимо, уже сделали.
[40:37.240 --> 40:53.720]  Да? Да. Почему n log n? Сортировка за n log n. Дальше. Почему обход за n? Да. А каждую точку мы либо
[40:53.720 --> 40:58.600]  один раз добавим, либо один раз удалим. Из-за этого всего у нас происходит это именно таким вот образом,
[40:58.600 --> 41:07.360]  что у нас работает это за у от n. Потому что не больше, чем два n действия мы сделаем. Удивительно
[41:07.360 --> 41:16.680]  рядом, из-за того, что вы все знаете. Блин, аж сложно. Но да, мы сегодня с вами закончили с алгоритмом
[41:16.680 --> 41:24.320]  Грехема тоже. Совсем, что у нас есть. Что у нас будет дальше? Давайте порассказываю чуть-чуть такого
[41:24.320 --> 41:32.480]  интересного. Смотрите, следующее, что у нас будет, это хэш функции. Дальше у вас будет еще всякие потом
[41:32.480 --> 41:37.680]  хэштаблички, вы тоже с ними познакомитесь и так далее, что с ними делается, что такое коллизии,
[41:37.680 --> 41:44.880]  как с ними вообще работают и так далее. После хэш функции у нас будет, скорее всего, амортизационный
[41:44.880 --> 41:51.800]  анализ еще раз. И на экзамене он будет у вас еще раз. Потому что ко мне пришел следующий фидбек.
[41:51.800 --> 42:01.800]  Судя по экзамену, вы не знаете амортизационный анализ. Цитата. Еще одна лекция будет просто не
[42:01.800 --> 42:08.040]  с теми структурами данных, которые были там. Она будет немного связана с плюсами, с динамически
[42:08.040 --> 42:14.640]  расширяющимся массивом, с вектором по факту. Мы будем его оценивать, будем смотреть, что там
[42:14.640 --> 42:23.240]  происходит. Вернемся к этому опять. Потому что, видимо, вы на экзаменах представляете, что алгоритмы
[42:23.240 --> 42:30.720]  это только алгоритмы и забываете о такой важной вещи, как анализ алгоритмов, что грустно. Кроме
[42:30.720 --> 42:36.840]  того, у нас будет еще, возможно, здесь я на сто процентов вам не скажу, я думаю об этом, как раз
[42:36.840 --> 42:44.840]  таки та теоретическая лекция, которая должна была быть на прошлом семестре. Про всякие фибоначевые
[42:44.840 --> 42:54.040]  кучи, что это такое, как с этим работать. Ну а дальше графы. Много-много графов. Окей.
[42:54.040 --> 43:01.680]  На этом, в принципе, сегодня все. Предлагаю сделать все-таки фотку и отправить ее в чат.
[43:01.680 --> 43:07.600]  Ничего не знаю, потому что что это такое. Поэтому давайте сделаем селфи и
[43:07.600 --> 43:11.960]  на сегодня закончим. И хорошего вам вечера. Сразу пожелаю.
