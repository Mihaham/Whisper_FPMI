[00:00.000 --> 00:22.240]  Так, ну мы завершаем наш увлекательный, судя по количеству слушателей,
[00:22.240 --> 00:25.920]  разговор про диаграмм Вороновой, дрангуляции Дилане.
[00:25.920 --> 00:28.560]  Значит, мне остался небольшой долг с прошлого раза.
[00:28.560 --> 00:32.480]  Мы, к сожалению, не успели, собственно, самое важное свойство диаграммы
[00:32.480 --> 00:36.120]  дрангуляции Дилана доказать, что в ней максимизируется минимальный угол.
[00:36.120 --> 00:39.400]  Давайте напомним, что у нас уже есть. Значит, давайте очень быстро.
[00:39.400 --> 00:46.600]  Что такое флип-ребра? Это если у нас есть два треугольника, разделяющие общую сторону,
[00:46.600 --> 00:53.280]  тогда флип – это, по сути, изменение диагонали в этом выпуком четырехугольнике.
[00:54.280 --> 01:00.080]  Было два треугольника, осталось два треугольника. Мы говорим, что такой флип
[01:00.080 --> 01:04.120]  бывает полезный. То есть, такой флип легализует вот это вот ребро, Pj,
[01:04.120 --> 01:12.360]  если минимум среди вот этих шести углов вырос. Мы меряем три угла в этом треугольникеETM
[01:12.360 --> 01:16.100]  и, соответственно, эти же шесть углов в этих треугольниках. Если минимум из них вырос строго,
[01:16.100 --> 01:20.540]  то флип легализует это ребро. То есть, ребро было плохим, минимум вырос,
[01:20.540 --> 01:22.600]  как раз минимальный угол увеличился. Значит, мы говорим,
[01:22.600 --> 01:29.240]  что флип хороший, флип легализует ребро. Дальше, это получается легализация, давайте напишу
[01:29.240 --> 01:46.180]  легализация ребра. Минимальный угол увеличивается. Дальше, значит, легализация триангуляции это
[01:46.380 --> 02:07.300]  легализация всех ребер. Мы доказали критерий того, что триангуляция является триангуляцией деланой,
[02:07.300 --> 02:12.900]  если только если она легальная. То есть, триангуляция является триангуляцией деланой,
[02:12.900 --> 02:17.860]  если в ней больше нечего легализовывать. То есть, нет вот таких флипов, которые бы увеличивали
[02:17.860 --> 02:25.580]  минимум. Это теорема, второй критерий с прошлой лекции, что деланы, если только если легальная
[02:25.580 --> 02:34.420]  триангуляция. Ну и это, собственно, критерий легальности. Мы сформулировали в термах окружностей,
[02:34.420 --> 02:40.220]  что триангуляция является легальной, если только если окружность, описанная вокруг любого
[02:40.220 --> 02:44.060]  треугольника, не содержит вот эту как раз четвертую вершину. То есть, если вы описываете вот
[02:44.060 --> 02:51.060]  здесь вот окружность какую-нибудь. Ох, ну давайте я вот так вот нарисую. Будем считать, что это
[02:51.060 --> 02:56.700]  окружность. Вот в ней не должно быть четвертой вершины этого четырехугольника. То есть, вершины
[02:56.700 --> 03:04.940]  напротив этой стороны общей, в другом треугольнике. В термах окружности давайте я так кратко напишу.
[03:04.940 --> 03:13.980]  У нас было, что ребро легальное, если только если в окружности, описанной вокруг одного треугольника,
[03:13.980 --> 03:22.900]  нет вершины другого треугольника. Вот, ну и наконец, самое главное, зачем нам все это было нужно,
[03:22.900 --> 03:26.300]  я утверждаю, что триангуляция отделана максимизирует минимальный угол.
[03:34.940 --> 03:48.940]  То есть, среди всех возможных триангуляций, если мы рассмотрим самый маленький угол,
[03:48.940 --> 03:52.780]  то максимальное его значение достигается ровно на этой треангуляции отделаны и только на них.
[03:52.780 --> 03:57.460]  Значит, ну доказательства пусть не так. Давайте рассмотрим какие-нибудь две треангуляции.
[03:57.460 --> 04:10.260]  Значит, пусть Т1, Т2 это какая-то треангуляция, которая максимизирует минимальный угол.
[04:10.260 --> 04:21.180]  Треангуляция, максимизирующая минимальный угол.
[04:21.180 --> 04:33.940]  Тогда давайте мы на треангуляции Т2 проведем процедуру легализации. То есть давайте просто
[04:33.940 --> 04:39.900]  делать edge flip пока можно. Ну пока эти операции легальны. Давайте просто легализовывать все
[04:39.900 --> 04:44.300]  ребра одно с другим в произвольном порядке. Я утверждаю, что мы в конце дойдем, во-первых,
[04:44.300 --> 04:48.620]  до легальной треангуляции. Ну потому что в конце нельзя будет сделать ни одного legalize,
[04:48.620 --> 04:53.420]  ни одного flip-а легализующего ребро. Значит, ну в конце получится легальная треангуляция.
[04:53.420 --> 04:57.980]  То есть, после какого-то количества действий я получу легальную треангуляцию, а легальная
[04:57.980 --> 05:02.220]  является треангуляция деланэ по теореме. Ну и значит, нам надо еще доказать, чтобы в любой
[05:02.220 --> 05:08.900]  треангуляции деланэ минимальный угол один и тот же. Ну это мы замечали, потому что все многоугольники
[05:08.900 --> 05:14.140]  вписаны, и значит, после треангуляции минимальный угол это минимальная дуга просто в этой описанной
[05:14.140 --> 05:27.620]  окружности. Ну давайте легализуем T2. Значит, просто будем делать edge flip для каждого нелегального
[05:27.620 --> 05:47.740]  ребра в любом порядке. Для каждого нелегального ребра в любом порядке. Я утверждаю, что такой алгоритм,
[05:47.740 --> 05:53.860]  то есть алгоритм просто while существует нелегальное ребро, сделает вот такой flip. На этом мы делаем
[05:53.980 --> 06:00.100]  треангуляцию T2. Я утверждаю, что этот алгоритм конечен. Что рано или поздно мы придем из T2 к
[06:00.100 --> 06:08.620]  легальной треангуляции, где больше ничего флипать нельзя. Скажите, пожалуйста, почему. Делаем,
[06:08.620 --> 06:20.180]  делаем флипы. Почему рано или поздно точно остановимся? Я бы сказал, что возможно,
[06:20.260 --> 06:26.780]  потому что когда мы здесь что-то делаем, у нас меняется структура треугольников. Возможно,
[06:26.780 --> 06:29.300]  мы как-то так поменяли, что у нас поменялись вот эти два треугольника,
[06:29.300 --> 06:42.860]  прилежащие к данному конкретному ребру. Нужен какой-то чуть другой аргумент. В
[06:42.860 --> 06:50.980]  каком-то смысле да. Что будет потенциалом? Да, да, да. Действительно, можно просто сказать,
[06:50.980 --> 06:55.140]  что давайте я следующее сделаю. Минимальный угол может не увеличиваться формально,
[06:55.140 --> 06:59.380]  поэтому не совсем хорошо. Давайте я скажу следующее. Давайте я для каждой треангуляции
[06:59.380 --> 07:07.300]  построю набор углов всех треугольников. Вот есть у меня какая-то треангуляция. Я померю все углы,
[07:07.300 --> 07:16.940]  вообще все, во всех треугольниках, и отсортирую их в порядке возрастания. То есть напишу такой
[07:16.940 --> 07:26.020]  последователь, ну как бы кортеж углов, отсортированный в порядке возрастания. Вот,
[07:26.020 --> 07:31.660]  значит, я у каждой треангуляции могу рассмотреть набор углов. Дальше понимаю, что каждая легализация,
[07:31.660 --> 07:36.300]  каждый флип, легализующий ребро, он этот вектор, очевидно, увеличивает строго. Если вектор просто
[07:36.300 --> 07:41.660]  лексик графически будет сравнен с собой, то каждый флип, конечно, вектор увеличивает, потому что минимальный
[07:41.660 --> 07:46.100]  элемент увеличивается. Значит, здесь, если я рассмотрю первое различие между двумя последовательными
[07:46.100 --> 07:50.660]  векторами, то в них как раз отличие будет в том самом минимальном, который я увеличу. Значит,
[07:50.660 --> 08:06.860]  флип лексикографически увеличивает вектор углов. Лексикографически увеличивает вектор углов.
[08:06.860 --> 08:15.420]  Вот, ну и остается доказать, что потенциальных векторов углов конечное количество. Ну это просто
[08:15.460 --> 08:18.480]  сделать у вас просто straight langexcaseziękuję конечное количество данного mesure точек.
[08:18.480 --> 08:21.820]  Если явно это должна была быть задача, какая-то верхняя оценка на начала triangulation. Значит,
[08:21.820 --> 08:25.700]  с таких векторов тоже конечное количество, значит, мы не можем бесконечно долго увеличиваться.
[08:25.820 --> 08:31.860]  По какой-то цепочке мы двигаемся, увеличиваем потенциал. То есть увеличиваем текущий вектор.
[08:31.860 --> 08:36.360]  Бесконечно увеличиваться не можем, потому что в возможное количество векторов конечно —
[08:36.360 --> 08:45.720]  значит процедура конечна, процедура конечна, вот, и того в конце мы получили
[08:45.720 --> 08:51.080]  какое-то t2 со звездочкой, это новая треангуляция, полученная из t2
[08:51.080 --> 08:55.560]  несколькими edge flips, значит с одной стороны угол я точно не уменьшил
[08:55.560 --> 08:59.560]  минимальный, потому что минимальный у меня точно мог только
[08:59.560 --> 09:04.800]  расти, каждый edge flip увеличивает минимальный угол, значит угол не
[09:04.800 --> 09:12.880]  изменился минимальный, ну, точнее не уменьшился, минимальный угол не уменьшился, вот, и
[09:12.880 --> 09:23.800]  при этом t2 со звездочкой стало легальной, легальная треангуляция, а значит треангуляция деланная,
[09:26.200 --> 09:33.120]  треангуляция деланная, вот, ну и все, и дальше вот тот аргумент, который я проговаривал, что во
[09:33.120 --> 09:35.720]  всех треангуляциях деланой минимальный угол один и тот же, потому что как он
[09:35.720 --> 09:40.720]  получается, у нас есть, ну, вообще откуда возникает неоднозначность треангуляции деланая,
[09:40.720 --> 09:44.040]  только из-за того, что у нас могут быть вот такие вот вписанные в окружность
[09:44.040 --> 09:49.080]  грани в графе деланая, дальше я их как угодно треангулирую, говорю, что результаты
[09:49.080 --> 09:54.160]  произвольного треангуляции деланая, ну и понятно, что вот как бы я не треангулировал, найдется угол,
[09:54.160 --> 09:58.960]  опирающийся на самую маленькую дугу, давайте скажем вот это вот самая маленькая дуга, вот этот угол,
[09:58.960 --> 10:04.640]  соответственно, он самый маленький, поэтому минимальный угол в любой треангуляции деланой
[10:04.640 --> 10:11.000]  это просто длина, ну, как бы радианная мера самой маленькой дуги среди всех окружностей,
[10:11.000 --> 10:15.160]  описанных вокруг всех многогольников, во всех треангуляциях деланой минимальный угол одинаковый.
[10:28.960 --> 10:37.360]  Ну вот вроде все, то есть мы показали, что если у нас была исходная треангуляция деланая t1 и какая-то
[10:37.360 --> 10:42.080]  другая t2, которая на самом деле максимизировала минимальный угол, то я могу еще в этой t2
[10:42.080 --> 10:47.120]  минимальный угол еще не уменьшить, ну если исходно был максимальный, то он такой останется,
[10:47.120 --> 10:51.560]  больше быть не может, и при этом мы получим треангуляции деланая, в которой минимальный угол такой же
[10:51.560 --> 10:56.800]  как здесь, значит у них просто минимальные углы одинаковые, в t1 и t2 звездочка, поэтому лучше,
[10:56.800 --> 11:04.320]  чем в треангуляции деланой мы такого получить не можем. Вот, ну собственно все, что надо было
[11:04.320 --> 11:09.920]  доказать. Да, вот в обратную сторону, видимо, я погречился, действительно, тут не означает,
[11:09.920 --> 11:14.440]  что если мы нашли какую-то треангуляцию, в которой максимальный минимальный угол такой-то, то это
[11:14.440 --> 11:18.160]  деланая, наверное, я погречился, давайте не будем доказывать, я думаю, что это не так в общем случае.
[11:18.160 --> 11:24.760]  То есть именно, что, как бы если я, ну то есть утверждение такое, что если мы построим треангуляцию
[11:24.760 --> 11:30.120]  деланой, вот тем нашим алгоритмом из Воронова, просто по определению построим, то это треангуляция,
[11:30.120 --> 11:34.640]  в которой минимальный угол максимально возможен среди всех треангуляций. Возможно какие-то еще есть,
[11:34.640 --> 11:45.560]  но это точно максимизирует. Окей? Обратно я неосторожно сказал, что ровно такие, значит
[11:45.560 --> 11:51.680]  максимизация минимального угла достигается ровно в треангуляции деланой. Или все-таки верно?
[11:55.760 --> 12:02.640]  Вроде верно. Не, не, не, минимальный максимизировать.
[12:09.320 --> 12:14.280]  Сумма чего? Не, сумма глав у нас константа, я...
[12:14.280 --> 12:26.040]  Мне кажется вы что-то путаете нас про сумму, я, конечно, ничего не говорил. Я рисовал,
[12:26.040 --> 12:29.040]  собственно, откуда у нас мотивировка вот того, что нам нужно максимизировать минимальный угол.
[12:29.040 --> 12:33.720]  Я рисовал такую картиночку, говорю, что здесь уровень 0, здесь уровень 0, здесь уровень 100. И
[12:33.720 --> 12:40.200]  тогда плохие треугольники, это вот такие, добивающиеся того, что на вот этом вот у нас
[12:40.200 --> 12:46.880]  горном рифе у нас здесь 0, а хочется, чтобы было сотни или около того. Вот, поэтому мне нужно
[12:46.880 --> 12:50.480]  просто избавиться от таких маленьких углов, значит, я его пытаюсь максимизировать. Про сумму углов,
[12:50.480 --> 12:59.360]  я, конечно, ничего не говорил. Да, да, да, да, да, то есть я как бы по всем треугольникам измеряю
[12:59.360 --> 13:03.840]  минимальный угол, и вот он должен быть как можно больше. Собственно, про это и есть максимизация
[13:03.840 --> 13:07.440]  минимального угла. Среди всех треугольников берем минимальный угол и его максимизируем.
[13:07.440 --> 13:24.880]  Так, окей. Да, да. Обратно можно то же самое сделать. Возьмем произвольный максимизирующий
[13:24.880 --> 13:33.560]  минимальный угол, легализуем, она будет деланной и угол не изменится. Да, это правда. Нет, я бы
[13:33.560 --> 13:40.440]  сказал, ее можно легализация ребер преобразовать сделанной. Ну, потому что, например, смотрите,
[13:40.440 --> 13:49.440]  у нас может быть такое, что вот, то есть в обратную сторону, короче, это неверно, но можно
[13:49.440 --> 13:52.200]  преобразовать, как она является деланной, потому что, скажем, у нас может быть какая-нибудь такая
[13:52.200 --> 13:59.080]  картинка, где вот такая, что вот это вот минимальный угол, а дальше есть какие-то два треугольника такие,
[13:59.080 --> 14:04.200]  что их выгодно флипнуть, но они не влияют на минимальный угол. Поэтому как бы минимальный угол
[14:04.200 --> 14:08.480]  все равно достигается здесь, здесь ничего флипать нельзя, но можно флипнуть где-то во внешности этого
[14:08.480 --> 14:13.640]  треугольника. Поэтому как бы это не деланной, потому что нелегальная, но при этом минимальный угол
[14:13.640 --> 14:18.640]  все равно один и тот же максимально возможен, поэтому в обратную сторону все-таки неверно. Вот,
[14:18.640 --> 14:23.800]  ну хорошо, все, собственно, вот мораль такая, что если мы построили деланной, то у нас есть
[14:24.520 --> 14:29.720]  максимирующий минимальный угол. Круто. Значит, давайте еще раз повторим, как можно строить
[14:29.720 --> 14:37.320]  эту треугольницу деланной алгоритм. Ну, во-первых, если у нас есть диаграмма Воронова, мы можем
[14:37.320 --> 14:49.560]  просто по определению диаграммы Воронова построить граф, граф деланной, граф деланной.
[14:49.560 --> 14:57.320]  Надо просто смотреть на то, какие ячейки имеют общий кусок границы, и тогда, соответственно,
[14:57.320 --> 15:02.360]  мы проводим ребро в триангуляции между соответствующими сайтами. Вот, просто по
[15:02.360 --> 15:06.320]  определению строим граф деланной, а потом его уже до конца дотреангулируем, треангуляция деланной.
[15:06.320 --> 15:14.400]  Вот, но на самом деле можно избавиться от вот этого первого шага, можно диаграмму Воронова явно не
[15:14.400 --> 15:19.800]  строить, а вспомнить, как работает алгоритм Форчуна и, собственно, в нем сразу строить граф деланной.
[15:19.800 --> 15:26.280]  Давайте кратко напомним, что делает алгоритм Форчуна. У нас есть некая сканирующая прямая,
[15:26.280 --> 15:32.000]  есть некая береговая линия, состоящая из каких-то ветвей парабол. Давайте я что-нибудь здесь довольно
[15:32.000 --> 15:40.200]  произвольно нарисую. Вот, события двух типов. Первый тип – это какие-то три парабола подряд
[15:40.200 --> 15:45.480]  предыдущие схлопываются в вершину диаграмма Воронова, либо события приходит новый сайт и,
[15:45.480 --> 15:49.760]  соответственно, он вставляет новый парабол в нашу береговую линию. Вот, а что нам нужно? Смотрите,
[15:49.760 --> 15:55.320]  давайте вспомним граф деланной, мы проводим ребро между сайтами, если они разделяют общий
[15:55.320 --> 16:00.360]  кусок границы положительной длины. То есть это как раз случай, когда две параболы пересеклись в
[16:00.360 --> 16:04.440]  какой-то точке, и потом в течение какого-то небольшого времени, то есть когда я чуть-чуть
[16:04.440 --> 16:10.240]  подвиную эту прямую, у меня, соответственно, параболы немножечко сдвинутся вниз, и вершина
[16:10.240 --> 16:15.600]  пересечения двух средних парабол вычертит какой-то кусочек как раз границ между двумя ячейками
[16:15.600 --> 16:20.320]  диаграмма Воронова. Значит, тогда на самом деле, чтобы построить граф деланной, мне нужно просто
[16:20.320 --> 16:26.760]  запоминать, какие пары парабол когда-либо пересекались, потому что пара пересекающихся парабол
[16:26.760 --> 16:33.040]  значит, что они соседние вот в этой береговой линии при проходе слева направо. Ну, значит,
[16:33.040 --> 16:39.520]  как раз при опускании сканируешь прямой чуть-чуть вниз, эта точка вычертит некую кусок границы,
[16:39.520 --> 16:45.360]  значит, мне нужно эти сайты, сайты, отвечающие этим параболам, соединить ребром в графе деланной. И
[16:45.360 --> 16:51.640]  никакие здесь даже не нужно, то есть этот алгоритм даже будет чуть проще, чем алгоритм для диаграмма
[16:51.640 --> 16:56.800]  Воронова, потому что мне не нужно там явным образом хранить какие-то точки, которые являются
[16:56.800 --> 17:01.480]  вершинами диаграмма Воронова, мне не нужно там какие-то с полубесконечными ребрами что-то делать
[17:01.480 --> 17:18.520]  отдельно. Поэтому я просто, значит, делаю следующее. Каждый раз, когда параболы, отвечающие
[17:18.520 --> 17:39.800]  пыжи, являются соседними в береговой линии, я просто добавляю ребро пыжи,
[17:39.800 --> 17:55.440]  добавляем ребро пыжи. Всё. Ну и поскольку у меня этот алгоритм вычерчивает все ребра диаграммы
[17:55.440 --> 17:59.320]  Воронова, значит, все вот эти вот вершины, да, попарные пересечения, которые мы здесь видим,
[17:59.320 --> 18:04.600]  они вычерчают все ребра, значит, в частности, мы рассмотрим все пары сайтов, которые разделяют
[18:04.600 --> 18:29.360]  какой-то общий кусок границев в терминах диаграмм Воронова. Хорошо. Вопрос, да,
[18:29.360 --> 18:34.920]  формально мы получим граф, формально мы получим граф Дилане, но потом надо еще его дотреангулировать,
[18:34.920 --> 18:46.040]  да. Ну давайте, давайте я скажу так, смотрите, действительно, мы здесь получим только граф,
[18:46.040 --> 18:51.960]  потому что мы проводим ребра между сайтами, которые отвечают как бы соседним ячейкам диаграмм Воронова,
[18:51.960 --> 18:56.760]  только граф. Значит, как его потом треангулировать? Ну смотрите, у нас вот, давайте просто выполним
[18:56.760 --> 19:00.920]  этот алгоритм, в конце у нас получит какая-то такая картинка. Давайте я что-нибудь здесь довольно
[19:00.920 --> 19:07.280]  вольное нарисую. Ну вот, ну вот, что-нибудь такое. Есть какая-то такая, есть какой-то такой граф на
[19:07.280 --> 19:13.400]  плоскости. Значит, мы можем сделать следующее. Смотрите, мне нужно как бы по сути выделить грани
[19:13.400 --> 19:17.240]  в этом планарном графе и все их произвольным образом дотреангулировать, потому что я знаю,
[19:17.240 --> 19:22.080]  что можно как угодно это делать. Значит, то есть что у меня есть? У меня есть набор сайтов на
[19:22.080 --> 19:26.680]  плоскости, какие-то ребра между ними проведены. Я знаю, что граф планарный, мне нужно выделить
[19:26.680 --> 19:33.520]  грани. Значит, это делать очень просто. Давайте мы в каждой вершине отсортируем по полярному углу
[19:33.520 --> 19:38.840]  все векторы, исходящие из данной точки. То есть вот из этой точки, скажем, 3 ребра выходят. Ну понятно,
[19:38.840 --> 19:43.200]  в каком порядке они идут. Сначала это, потом это, потом это. Это легко сделать, ну просто там, грубо
[19:43.200 --> 19:48.800]  говоря, там посчитаем угол с положительным направлением оси ОХ и в этом порядке их отсортируем
[19:48.800 --> 19:52.400]  как раз таки. Ну или просто по векторному произведению. Вот в таком порядке их все пройдем.
[19:52.400 --> 19:58.080]  И дальше, чтобы выделить одну конкретную грань, я встаю в произвольную точку и начинаю идти,
[19:58.080 --> 20:03.200]  собственно, ну там вот взял произвольный вектор, давайте пойдем сюда. Значит дальше,
[20:03.200 --> 20:07.760]  какой вектор у нас будет следующим? Ну мне нужно встать в эту точку и найти вектор следующий
[20:07.760 --> 20:12.720]  за вот этим. Это, соответственно, либо какой-то бинпоиск, либо мне нужно просто подвязать,
[20:12.720 --> 20:17.480]  указать ссылочку, что вот это ребро справа налево соответствует этому ребру слева направо.
[20:17.480 --> 20:22.280]  Соответственно, за ним идет, скажем, вот это. Ну просто там увеличить номер на один. Дальше,
[20:22.280 --> 20:26.600]  я понимаю, что за этим ребром идет вот это. Опять, пришел в эту вершинку, у меня есть
[20:26.600 --> 20:30.000]  какое-то текущее входящее ребро, надо понять какое следующее. Ну опять, я понимаю,
[20:30.000 --> 20:33.880]  какой номер имело обратное ребро, значит мне нужно просто следующее ребро взять, а это вот это
[20:33.880 --> 20:38.760]  ребро. Потом вот это и мы вернулись туда, откуда начали. Тем самым выделили грань, и соответственно,
[20:38.760 --> 20:43.880]  которая ограничена четырьмя ребрами. Вот, и так делаем просто, пока не обойдем все ребра, тем самым
[20:43.880 --> 20:48.480]  у нас как раз выделятся все грани, и затем просто каждый из них является выпукланногоугольником,
[20:48.480 --> 20:52.800]  который я знаю состоит из тех вершин, я могу его спокойно дотреангулировать. То есть, по сути,
[20:52.800 --> 21:00.840]  в конце нужно просто выделить грани в планарном графе. Выделить грани в плоском графе, давайте
[21:00.840 --> 21:28.840]  напишем. Плюс дотреангулировать их. Сейчас, сейчас, ну смотрите еще раз, что у нас есть,
[21:28.840 --> 21:34.400]  у нас есть какая-то точка, в нее пришел некий вектор, я хочу понять, какой вектор ему как бы,
[21:34.400 --> 21:38.880]  ну обратно, в обратную сторону ведет, чтобы находиться следующий к нему. То есть, у меня вот
[21:38.880 --> 21:43.800]  из этой точки все векторы направлены из этой точки, а здесь наоборот из нее, поэтому мне нужно как бы
[21:43.800 --> 21:47.760]  обратный вектор найти. Ну, давайте тогда сделаем следующее, давайте каждое ребро, которое мы видим,
[21:47.760 --> 21:57.320]  скажем из ПИ в ПЖ. Вот мы увидели ребро из ПИ в ПЖ, оно там соответствует какому-то ребру в порядке
[21:57.320 --> 22:02.840]  обхода вокруг ПИ. И оно же, точнее от ПЖ к ПИ, соответствует какому-то ребру в порядке обхода
[22:02.840 --> 22:08.300]  вокруг ПЖ. Ну, вы давайте тогда просто для каждого конкретного ребра между парой вершин, мы скажем,
[22:08.300 --> 22:13.560]  что, ну то есть там еще сделаем один бинпоиск, один раз предпочитаем бинпоиском, какие здесь ребра
[22:13.560 --> 22:17.560]  друг другу соответствуют. То есть, у меня есть вот это вот ребро из ПИ в ПЖ, оно, не знаю, имеет
[22:17.560 --> 22:23.160]  второй номер здесь, и первый номер в порядке от ПЖ к ПИ. Значит, тогда просто я сделаю один бинпоиск
[22:23.160 --> 22:29.240]  по обратному ребру, пойму, что второе ребро отсюда, то есть первое ребро отсюда, и свяжу их просто,
[22:29.240 --> 22:34.360]  что если я пришел по второму ребру сюда, то я нахожусь в первом ребре вот отсюда. То есть, я один
[22:34.360 --> 22:39.240]  раз предпочитаю все такие пары соответствует ребро и обратный к нему, просто, ну, как бы там
[22:39.240 --> 22:45.800]  указателями или номерами. Ну, можно, да, но скорее, действительно, это не очень полезно, можно просто
[22:45.800 --> 22:53.240]  явным образом каждый раз делать бинпоиск. Да, пока все ребра не обошли. То есть, вот мы обошли одну
[22:53.240 --> 22:57.240]  грань, можем опять встать сюда, взять первый неиспользованный ребро, это вот это, пройти вот эту
[22:57.240 --> 23:13.000]  гранью и так далее. Окей? Нет, нет, нет, нет, у нас будет еще вот такая внешняя грань. Не надо, мы
[23:13.000 --> 23:18.760]  всегда, ну, давайте, значит, на этой картинке я всегда кручусь вот так, просто существовой, тогда
[23:18.760 --> 23:23.560]  на самом деле здесь, ну, и здесь, если я пойду по этому ребру, я на самом деле обойду как раз внешнюю
[23:23.560 --> 23:29.360]  грань, то есть я обойду вот так вот, у меня получится внешняя грань нашего многоугольника. Да, если я вот
[23:29.360 --> 23:33.600]  встану вот здесь вот и буду обходить просто существователь, я как раз вот эту гранью обойду, то есть у меня будет
[23:33.600 --> 23:43.160]  вот эта грань, вот эта грань, и внешняя получится, например, вот таким обходом. Как понять, получили мы
[23:43.160 --> 23:59.480]  нужную грань или внешнюю? Сейчас, одну секунду. Ну, смотрите, мы в конце получаем многоугольник как
[23:59.960 --> 24:05.680]  вершин, если это внутренняя грань, то как вот было здесь, он получается обойден в порядке против часовой
[24:05.680 --> 24:10.480]  стрелки, а вот эта штука на самом деле обойдется в порядке по, вот этот многоугольник обойдется в
[24:10.480 --> 24:14.840]  порядке по часовой стрелке, потому что мы как бы обходим его внешность, то есть я встал вот сюда,
[24:14.840 --> 24:26.120]  сейчас, или это обман, одну секунду. Да, то есть, нет, окей, окей, окей, секунду. Ну, можно, скажем,
[24:26.800 --> 24:32.340]  по площади считать, потому что это выпуклая оболочка, то есть внешняя грань, она, как раз,
[24:32.340 --> 24:37.160]  ограничена выпуклой оболочкой исхода многоугольника, и просто та грань, которая, собственно, ограничена
[24:37.160 --> 24:46.520]  выпуклой оболочкой, это внешний, ее можно игнорировать. Ну, можно просто площадь посчитать,
[24:46.520 --> 24:54.200]  сказать, что самая большая, это есть выпуклая оболочка. Ну, потому что еще раз. Как у нас
[24:54.200 --> 25:02.080]  выглядит картинка у нас граф делане он он является значит каким каким-то
[25:02.080 --> 25:06.440]  разбиением выпукло оболочки на на грани есть что внешняя грань но вот как раз
[25:06.440 --> 25:09.960]  если мы тогда все эти грани объединим то больше ты выпукла оболочка и самая
[25:09.960 --> 25:13.160]  большая грань ее границы в точности выступает выпукла оболочка у всех
[25:13.160 --> 25:17.400]  остальных граней что-то поменьше
[25:17.400 --> 25:20.400]  окей
[25:22.400 --> 25:30.160]  ну вот мне вроде тут как раз вроде ничего страшного нет в отделении
[25:30.160 --> 25:33.440]  выделение грани если у нас такой очень хороший планарный граф все все
[25:33.440 --> 25:37.040]  грани выпукла многоугольника нет никаких отростков то как бы все все вполне
[25:37.040 --> 25:44.200]  легко делать из любых ну просто там не знаю у меня точки
[25:44.200 --> 25:48.280]  нумировано от нулевой до минус первой давайте от из нулевой есть не не
[25:48.280 --> 25:53.120]  пройденное ребро пойдем по нему есть есть еще пойдем по нему и так далее пока
[25:53.120 --> 25:56.640]  есть не пройденные рёбра запускаем просто до фэс из них не до фэс даже
[25:56.640 --> 26:01.440]  просто там обход какой-то ну рекурс и так вы говорите
[26:01.680 --> 26:08.600]  так ну а давайте двигаться дальше есть давайте еще такой краткий обзор
[26:08.600 --> 26:13.720]  какие есть алгоритмы рядышком вот с этой тренировка с деланой и диаграмма
[26:13.720 --> 26:22.320]  воронова значит есть алгоритмы с выходом в 3d которые сводят наши задачи к
[26:22.320 --> 26:27.720]  задачам более ну как бы формулируем более просто но в трехмерном случае
[26:27.720 --> 26:32.080]  скажем вот здесь довольно тяжело формулируется ну там вороной еще
[26:32.080 --> 26:36.160]  относительно просто но деланая формулировка довольно тяжело вот значит можно
[26:36.160 --> 26:39.320]  выйти в трехмере трехмерное пространство и там задача будет
[26:39.320 --> 26:43.120]  проще но легче они к сожалению не особенно решаются то есть там есть конечно
[26:43.120 --> 26:47.760]  алгоритмы какие-то тоже за инлоген вот но они скорее так для для общего
[26:47.760 --> 26:53.520]  развития что ли итак давайте напишу выход в 3
[26:54.120 --> 27:00.000]  мы сделаем следующую странную штуку вот есть у нас наша плоскость где нам
[27:00.000 --> 27:05.720]  нужно было скажем построить риангуляцию деланая давайте мы добавим осет
[27:05.720 --> 27:10.080]  направленную вверх и на этой картинке соответственно тут есть какие-то
[27:10.080 --> 27:13.000]  координаты x и y на этой картинке давайте я еще нарисую
[27:13.000 --> 27:16.000]  параболоид сдаваем уравнением z равно x квадрат
[27:16.000 --> 27:21.000]  плюс y квадрат ну это будет какая-то вот такая картинка давайте просто параболе
[27:21.000 --> 27:32.480]  его нарисую вот и дальше сделаю следующее все точки плоскости точнее сайты
[27:32.480 --> 27:36.600]  которые мне лежали в моей исходной плоскости r2 я подниму просто на наш
[27:36.600 --> 27:40.600]  параболоид то есть если у меня была такая точка точка x и y на то я ей в
[27:40.600 --> 27:47.640]  соответствии поставлю точку x y x квадрат плюс y квадрат x квадрат
[27:47.640 --> 27:52.680]  плюс y квадрат просто поднял на параболе значит тогда я утверждаю
[27:52.680 --> 28:00.200]  следующее значит ну давайте тоже теория мы скажем что если я подниму все сайты
[28:00.200 --> 28:07.200]  на параболоид и найду нижнюю часть выпуклой оболочки всех этих поднятых
[28:07.200 --> 28:12.560]  точек так вот проекция этой нижней выпуклой оболочки на плоскость x и y
[28:12.560 --> 28:20.600]  является в точности графом деланэ значит
[28:21.200 --> 28:31.680]  проекция нижней выпуклой оболочки
[28:35.360 --> 28:38.920]  точек на параболоиде
[28:38.920 --> 28:52.200]  в плоскость x и y это в точности граф деланэ
[28:56.120 --> 29:02.760]  поэтому ну там либо докажем либо я как-нибудь коротко обрисую доказательства
[29:02.760 --> 29:07.960]  поэтому да если теперь мы взять на веру мы могли бы свести задачу построения
[29:07.960 --> 29:12.360]  треангуляции деланэ к задаче нахождения выпуклой оболочки точек в трехмерном
[29:12.360 --> 29:15.920]  пространстве но выпуклая оболочка определяется так же как всегда да это
[29:15.920 --> 29:18.760]  минимально выпуклое множество все их содержащие соответственно если есть тут
[29:18.760 --> 29:24.640]  много точек на нашем параболоиде ну что это какой-то многогранник будет
[29:24.640 --> 29:30.040]  многогранник гранями выступают как раз вот гранями там выступают ну в основном
[29:30.040 --> 29:34.440]  треугольники да но иногда бывают какие-то тут конечно я не смогу это
[29:34.440 --> 29:40.440]  никак нарисовать короче какая-то такая сложная штука будет многогранником
[29:40.440 --> 29:44.040]  многогранник машина которого лежат на параболоиде вот какая-то такая штука я
[29:44.040 --> 29:47.960]  же что нижний его как бы проекция нижней выпукло оболочки это точности
[29:47.960 --> 29:51.360]  граф деланэ поэтому да если бы научились вдруг внезапно находить
[29:51.360 --> 29:56.840]  выпукло оболочку в 3d то мы бы могли найти граф деланэ ну соответственно его в конце
[29:56.840 --> 30:00.600]  до треангулирует собственно выдели в грани и опять-таки проведя все необходимые
[30:00.600 --> 30:07.920]  диагонали до треангуляции вот значит простых алгоритмов у выпукло оболочки в
[30:07.920 --> 30:12.760]  3d особенно нет есть довольно простой заин квадрат путем заворачивания просто
[30:12.760 --> 30:16.480]  подарка так же как у нас есть заворачивание подарка в двумерном
[30:16.480 --> 30:20.720]  случае мы просто там скажем ну давайте кратко в двумерном случае как мы можем
[30:20.720 --> 30:25.640]  строить выпукло оболочку заворачивания подарка мы берем одну сторону дальше из
[30:25.640 --> 30:29.400]  всех точек выбираем самую крайнюю и говорим что следующая сторона потом у
[30:29.400 --> 30:32.760]  нас вот эта сторона опять из всех точек выбираем самую крайнюю то есть
[30:32.760 --> 30:35.520]  рисуем все вот такие векторы понимаем что это самый крайний но соответственно
[30:35.520 --> 30:41.360]  это будет следующая сторона так просто идем да и строим самую самую крутую
[30:41.360 --> 30:45.800]  возможную касательную к нашему нашу точку значит ну вы три примерно что что-то
[30:45.800 --> 30:49.400]  то же самое мы взяли некую одну плоскость ограничивающую наш
[30:49.400 --> 30:53.560]  многогранник с одной стороны ну и дальше там давайте просто вокруг какого-то
[30:53.560 --> 30:55.760]  ребра попытаемся построить следующую возможную
[30:55.760 --> 31:00.040]  плоскость которая наиболее точно сужает наше наше множество точек ну то есть
[31:00.040 --> 31:04.120]  отделяет как можно больше пространство от наших точек тем самым получим как
[31:04.120 --> 31:08.000]  раз новую брать вот это будет за н квадрат потому что у нас если грани
[31:08.000 --> 31:13.160]  линейное количество грани линейное количество то все равно чтобы проверить
[31:13.160 --> 31:16.160]  что будет следующей грани мне нужно все точки перебрать и так n раз поэтому
[31:16.160 --> 31:21.080]  будет квадрат к сожалению вот но есть алгоритм за н луген ну там он какой-то
[31:21.080 --> 31:24.760]  какой-то страшный то есть грубо говоря еще на лекцию но вообще да если бы мы
[31:24.760 --> 31:27.680]  научились здесь находить выпукла оболочку то в принципе магнитных игров
[31:27.680 --> 31:35.960]  деланы еще раз ну конечно выпукла облачка всегда единственная это минимальная
[31:35.960 --> 31:39.480]  выпуклая фигура такая что она всегда по определению просто единственно ну
[31:39.480 --> 31:44.520]  точнее следствия определение что она всегда существует единственная
[31:44.520 --> 31:59.640]  не понял еще раз пожалуйста да не на самом деле смотреть на самом деле откуда
[31:59.640 --> 32:04.160]  у нас чем опять отличается треангуляция от графа тем что выпукла оболочки у нас
[32:04.160 --> 32:09.160]  могут быть грани не треугольные скажем есть у нас там четырехугольная грань она
[32:09.160 --> 32:13.000]  спроецировалась в четырехугольную грань графа деланы если я отреагулирую
[32:13.000 --> 32:16.360]  то мы просто поднимется будет ребро просто на грани и все ничего страшного
[32:16.360 --> 32:24.280]  ну если поднять то это будет граф просто с диагональями на граних да да да ничего
[32:24.280 --> 32:33.760]  страшного так значит ну давайте значит факт а что существует алгоритм за н луген
[32:34.360 --> 32:49.160]  строящий выпукла бочков 3d что алгоритм строящий выпукла оболочку в 3 за вот он
[32:49.160 --> 32:53.600]  луган ну давайте сейчас уже будет просто какая-то обзорный кусок
[32:53.600 --> 33:02.240]  лекции доказывать ну как бы какой-то сложный алгоритм он есть и хорошо так
[33:02.240 --> 33:07.720]  давайте я немножко попробую доказать вот это утверждение что действительно нам
[33:07.720 --> 33:21.200]  достаточно спроцировать нижний выпукла оболочку так я начну со следующего давайте
[33:21.200 --> 33:25.160]  я рассмотрю касательную в какой-нибудь точке к нашей параболе нашим параболой
[33:25.160 --> 33:33.960]  вот скажем пусть у меня есть точка с координатами а б а квадрат давайте напишем
[33:33.960 --> 33:38.560]  уравнение касательной плоскости касающийся вот здесь вот наша парабола то есть ну вот
[33:38.560 --> 33:49.800]  что-то вот такое будет что-то вот такое как-то вот так наш наш параболы касается значит это
[33:49.800 --> 33:56.720]  будет плоскость задаваемым каким-то таким уравнением z равно что-то там на x плюс что-то
[33:56.720 --> 34:05.040]  там на y плюс что-то там да она будет явно не не горизонтальная поэтому она может иметь такой
[34:05.040 --> 34:14.040]  вид ну то есть кроме вот этой вот она собственно это будет затронулю сейчас да она будет явно не
[34:14.040 --> 34:18.840]  вертикальная да у параболы нет вертикальных касательных плоскостей поэтому можно точно
[34:18.840 --> 34:23.280]  написать в таком виде вот но на самом деле коэффициенты при x и при y легко останавливаются
[34:23.280 --> 34:26.920]  просто из того что это касательная а значит коэффициенты здесь должны быть просто равны
[34:26.920 --> 34:32.560]  производным до частным производным вот этого нашего уравнения задающего наш параболой по
[34:32.560 --> 34:39.400]  x и по y а потому что по сути касательная плоскость это приближение первой степени к нашей фигуре
[34:39.400 --> 34:45.720]  значит мне нужно просто взять производные частные по x и по y поэтому здесь коэффициенты будут 2 a и 2
[34:45.800 --> 34:55.320]  но это просто частные производные частные производные уравнения z равно x квадрат
[34:55.320 --> 35:08.040]  плюс y квадрат точки а б а квадрат б квадрат вот это доказываем нет это сложный факт это там
[35:08.040 --> 35:17.000]  на отдельную лекцию вот мы доказываем теоремы значит эти эти коэффициенты понятно ну и
[35:17.000 --> 35:21.040]  соответственно свободный коэффициент здесь восстановился просто из того что если это
[35:21.040 --> 35:25.000]  фиксировано то у меня эта плоскость должна проходить собственно через эту точку поэтому
[35:25.000 --> 35:28.680]  я могу ее подставить наш уравнение и понять что свободный коэффициент должен быть вот такой
[35:28.680 --> 35:35.880]  минус а квадрат квадрат если его поставлю таким то как раз при подстановке вместо
[35:35.880 --> 35:43.680]  x а вместо y б у меня как раз получше 2 квадрат 2 b квадрат минус сумма то есть
[35:43.680 --> 35:46.680]  просто сумма квадратов равно как раз а квадрата квадрат поэтому это уравнение
[35:46.680 --> 35:55.400]  действительно касательная и в этой точке действительно происходит касание так хорошо
[35:55.400 --> 36:11.600]  теперь давайте рассмотрим плоскость с теми же самыми коэффициентами при иксе и при игреке
[36:11.600 --> 36:21.360]  поднятую вверх на некое ну давайте пишу r квадрат я увеличу свободный коэффициент
[36:21.360 --> 36:27.600]  на r квадрат соответственно моя плоскость поднимется немножечко выше давайте новую
[36:27.600 --> 36:34.240]  картиночку поднимется немножечко выше и будет как-то пересекать наш парабол наш парабол
[36:34.240 --> 36:38.920]  давайте я нарисую какой-то такое вот сечение да соответственно плоскость она вот содержит
[36:38.920 --> 36:47.280]  этот вот окружный на самом деле в общем случае будет эллипс да пересекающий ну как раз являющийся
[36:47.280 --> 36:54.640]  сечением нашего параболой да вот и плоскость на как как-то вот так вот проходит да продлевает
[36:54.640 --> 37:05.200]  наш наш эллипс куда-то вверх вниз причем расстояние вот такое вертикальное расстояние от этого эллипса
[37:05.200 --> 37:11.280]  до точки касания равно r квадрат то есть я я поднял точку вот у меня было здесь касание я
[37:11.280 --> 37:17.760]  поднял плоскость на r квадрат стало сечение ну такое вот эллиптическое отстоящие по вертикали
[37:17.760 --> 37:26.240]  на r квадрат от точки касания вот хорошо значит тогда отуждаю следующее я отуждаю следующее что
[37:26.240 --> 37:40.320]  значит точка пл лежит внутри описанной окружности
[37:40.320 --> 37:54.800]  треугольника pi pj пока то есть как раз точка пл нарушает легальность если только если
[37:54.960 --> 38:02.960]  после поднятия точка пл лежит ниже плоскости задаваемой вот этими вот тремя точками то есть
[38:02.960 --> 38:09.200]  смотрите еще раз да это было что-то подготовительное теперь рассматриваем сначала ситуацию в плоскости
[38:09.200 --> 38:13.520]  вот у нас есть какие-то три точки образующий треугольник я описываю вокруг вокруг них
[38:13.520 --> 38:19.240]  окружность получается пи пж пк окружность вокруг треугольник я говорю что точка пл в нем лежит в
[38:19.240 --> 38:25.000]  этой окружности лежит в этой окружности если только если после поднятия давайте я буду поднятия
[38:25.000 --> 38:34.400]  обозначать волной как бы ну поднятие на парабалоид pl лежит ниже плоскости
[38:34.400 --> 38:47.520]  пи пж пк вот волна значит поднятие поднятие на парабалоид поднятие на парабалоид
[38:47.520 --> 39:01.640]  у меня были какие-то точки здесь в плоскости да там не знаю пи пж пк я тут построил какую-то
[39:01.640 --> 39:06.880]  окружность в ней оказалась точка пл тогда утверждаю что пл будет лежать ниже плоскости
[39:06.880 --> 39:13.120]  после поднятия ниже вот этой плоскости после поднятия их в r3 на парабалоид вот и тогда
[39:13.120 --> 39:19.160]  как раз если мы докажем то у нас точности получится что вот это вот это корректный
[39:19.160 --> 39:23.480]  треугольник ну то есть формально эти вершины лежат в одной грани граха дилане если только
[39:23.480 --> 39:28.920]  если вот это вот это плоскость ограничиваясь ни ограничивающаясь ниже нас наш многогранник
[39:28.920 --> 39:34.240]  то есть точности это является гранью выпуклой оболочки потому что выпукла оболочка снизу она
[39:34.240 --> 39:39.200]  просто ограничена какими-то гранями если приведу плоскости через эти грани то как раз ниже них
[39:39.200 --> 39:43.120]  никого будет не может ну просто просто просто так работает выпуклая оболочка вот мне с некий
[39:43.120 --> 39:50.520]  выпуклый многогранник так я не представляю как это рисовать честно говоря не вот что-нибудь
[39:50.520 --> 39:58.520]  такое да вот такой вот многогранник если я провожу плоскости через его грани то они как
[39:58.520 --> 40:03.800]  раз отделяют ну точнее они таковы что все остальные точки лежат как бы выше да выше этой
[40:03.800 --> 40:08.520]  полуплости выше этой плоскости а ниже никого нет соответственно вот как раз здесь точности
[40:08.520 --> 40:14.240]  написано что треугольник корректный то есть лежит в одной грани графа делана если только если вот
[40:14.240 --> 40:19.920]  это вот штука задает грань нашего выпукла ну нашего многоугольника то есть наша выпукла оболочки
[40:19.920 --> 40:26.200]  вот ну и тем самым тогда у нас вот то вот утверждение будет верно значит почему это верно
[40:26.200 --> 40:32.720]  да почему наличие точки в окружности равносилен тому что точка ниже какой там плоскости но
[40:32.720 --> 40:42.400]  давайте мы посмотрим на эти три точки по ипожпк поднимем их на парабалоид это будет как раз какая-то
[40:42.400 --> 40:48.360]  вот такая вот плоскость ну то есть для каких-то коэффициентов а б а квадрат ну точнее для
[40:48.360 --> 40:54.120]  каких-то а б р квадрат у меня как раз получится что вот эта вот плоскость да проходит через точки
[40:54.120 --> 41:03.480]  п и с волной пока с волной так сейчас немножко их поднимаю да п и с волной выглядно там лежит
[41:03.480 --> 41:15.640]  сейчас п и с волной вот то есть я могу поднять эти точки построить по ним плоскость сечение
[41:15.640 --> 41:22.800]  этой плоскости с нашим на парабалоидом будет как раз эллипсом до которой я вот после проекции
[41:22.960 --> 41:27.700]  на по Tolstoy да otros怕 как раз перейдет в эту самую апис Executed нашего треугольника
[41:27.700 --> 41:34.440]  то есть я тоже даже если спроекцировать теперь этот эллипс получается с сечением получается
[41:34.440 --> 41:39.760]  с сечением этой окружности тьфуты получается с сечением плоскости и парабалоид и Josie на
[41:39.760 --> 41:44.900]  плоскость то у меня как раз получиться окружности описан Madam why понятно что
[41:44.900 --> 41:48.320]  она будет проходить через эти наши точки просто потому что через них проходит в
[41:48.320 --> 41:56.800]  в R3. А почему это будет окружность? Так, почему после проекции будет окружность?
[41:56.800 --> 42:02.520]  Потому что вот этот z на самом деле, это x квадрат плюс y квадрат, да, то есть что
[42:02.520 --> 42:07.080]  такое вот этот эллипс? Это такие точки x и z, что выполняется вот это вот равенство,
[42:07.080 --> 42:10.600]  да, потому что они еще и на проболоде лежат. Но если я вот здесь вот аккуратненько все
[42:10.600 --> 42:20.240]  сгруппирую, у меня получится уравнение x минус a в квадрате плюс y минус b в квадрате равно
[42:20.240 --> 42:27.480]  r в квадрате. Она просто перенес вот эти штуки туда, это туда, r квадрат оставил справа. Получается,
[42:27.480 --> 42:32.080]  что проекция этого конического сечения на самом деле действительно является окружностью,
[42:32.920 --> 42:41.600]  треугольника. Ну и все, собственно, тогда понятно, что точки, лежащие внутри окружности,
[42:41.600 --> 42:47.400]  точки, лежащие внутри окружности, это такие точки, где здесь значок меньше. То есть точка,
[42:47.400 --> 42:55.560]  вот если я скажу, что x и y это координаты точки PL, то ее принадлежность внутри окружности,
[42:55.560 --> 43:00.680]  это значит, что здесь значок меньше, это как раз значит, что она лежит ниже этой плоскости,
[43:00.680 --> 43:07.120]  а PL внутри окружности, если только, если в этом равнении здесь меньше, значит в этом равнении
[43:07.120 --> 43:15.560]  здесь меньше, значит просто PL лежит ниже нашей плоскости. Ну все. То есть у нас получается не
[43:15.560 --> 43:20.760]  просто точки поднимаются на параболлоид, но еще и окружности вот этих вот, описанных как любого
[43:20.760 --> 43:26.640]  треугольника, они поднимаются в эллипсы, такие, что все, что под ними, это как раз внутренность
[43:26.640 --> 43:34.440]  нашей окружности. Ну и все, соответственно, чтобы найти все вот эти вот валидные треугольники,
[43:34.440 --> 43:41.640]  мне нужно найти все плоскости, которые снизу ограничивают наши поднятые точки на параболлоиде,
[43:41.640 --> 44:08.520]  это в точности нижнего паклоболочка, вот и все. Ну как? Отлично. Так, да,
[44:08.520 --> 44:35.280]  да. Да, да, конечно. Нам нужно фиксировать ребро. Да, да, да. Вот. Хорошо. Так, это у нас получается
[44:35.280 --> 44:41.480]  сведение делане к чему-то в 3D, на самом деле к выпаколобочке в 3D. Значит, дальше я могу еще
[44:41.480 --> 44:46.920]  сделать что-то похожее для Воронова. Значит, смотрите, вот здесь мы уже описали уравнения
[44:46.920 --> 44:54.760]  касательных, уравнения касательных полкласскостей в данной конкретной точке. Так вот теорема. Ну
[44:54.760 --> 45:07.320]  давайте я напишу пусть P, точек PN, это множество сайтов. Дальше пусть H и T это плоскость,
[45:07.320 --> 45:14.800]  давайте не так, давайте напишу касательная плоскость к параболлоиду, касательная плоскость
[45:14.800 --> 45:31.040]  к параболлоиду, точке P с волной. То есть у меня есть набор сайтов на плоскости,
[45:31.040 --> 45:36.000]  я их все поднял на параболлоид и в каждой из них как бы провел касательную плоскость. Так вот
[45:36.000 --> 45:46.960]  тогда я утверждаю, что проекция верхней огибающей всех этих касательных плоскостей является диаграмм
[45:46.960 --> 46:15.480]  Воронова. Проекция верхней огибающей всех этих N плоскостей на плоскость XY. Есть
[46:15.480 --> 46:26.760]  сущности Грамм Воронова исходного множества сайтов. Вот здесь мы уже рассматриваем не точки,
[46:26.760 --> 46:33.600]  а плоскости касательные в этих точках и вот берем их верхнюю огибающую. Это когда я,
[46:33.600 --> 46:40.280]  вот давайте картиночка опять в меру моих художественных способностей, у меня в некоторых
[46:40.280 --> 46:44.960]  точках проведены касательные плоскости. Здесь такая штучка, здесь штучка, короче какие-то
[46:44.960 --> 46:50.920]  штучки здесь нарисованы, спереди есть еще такая плоскость. Верхняя огибающая, это когда вы для
[46:50.920 --> 46:58.360]  произвольной точки плоскости XY проводите вертикальный луч вверх, смотрите какие плоскости она
[46:58.360 --> 47:02.360]  пересекает, какие из вот этих вот касательных полплоскостей она пересекает, и брать просто
[47:02.360 --> 47:08.080]  самую верхнюю. Она пересекла вот эту с точки здесь, пересекла вот эту с точки здесь, ну и там еще
[47:08.080 --> 47:12.160]  какую-нибудь вот такую в точке вот здесь. Значит вот это как раз самая верхняя в этой конкретной
[47:12.160 --> 47:17.240]  точке. То есть вы как бы в каждой точке, по каждой каранаде XY берете самую высокую точку,
[47:17.240 --> 47:21.720]  принадлежащей хотя бы одной плоскости и говорите, что вот она как раз лежит в верхней огибающей.
[47:21.720 --> 47:27.120]  Ну то есть такая картинка сверху. Представьте, у вас есть такой стакан, вот такой параболический,
[47:27.120 --> 47:32.360]  он как-то обрублен некими полуплоскостями, вы смотрите сверху и вот как бы то, что у вас видно,
[47:32.360 --> 47:37.040]  та плоскость, которая видна сверху, это есть вот верхняя огибающая всего ваше множество.
[47:37.040 --> 47:44.480]  Вот. Ну и соответственно опять мы свели задачу по строению Диаграмма Воронова к
[47:44.480 --> 47:50.200]  чему-то в трехмерном пространстве. Задачу формулируется сильно проще, чем сама Диаграмма
[47:50.200 --> 47:53.880]  Воронова. Есть просто набор плоскостей, надо найти их в верхней огибающей. Там тоже есть,
[47:53.880 --> 48:00.720]  конечно, алгоритм Зейн Луган, но он тоже неприятный. Вот и так, доказательства. Доказательства.
[48:00.720 --> 48:27.880]  Да. Не совсем, не совсем, не совсем. Не совсем, ну смотрите, вот есть у вас вот такой стакан.
[48:27.880 --> 48:35.640]  Вот так посекли, и вот так посекли, скажем. Понятно, что вот эта плоскость, она вот здесь вот
[48:35.640 --> 48:41.560]  доминирует, а здесь она проигрывает. Поэтому если вы снизу станете, вы будете видеть вот эту как раз,
[48:41.560 --> 48:49.400]  поэтому на верх не нужна. Вот. Доказательства на самом деле простое. Давайте мы вот возьмем точку
[48:49.400 --> 49:01.120]  x, y в плоскости и поймем, что именно вот эта вот плоскость, которая самая верхняя, соответствующая этой
[49:01.120 --> 49:08.360]  точке. То есть мне нужно среди всех плоскостей h1 и так далее hn найти такую, в которой z-координата
[49:08.360 --> 49:14.240]  для точки x, y максимально возможна. Да, но я знаю, чему равна z-координата в точке x, y. z это всегда
[49:14.240 --> 49:23.720]  2ax плюс 2by минус a квадрат плюс b квадрат, где ab это координаты очередного сайта,
[49:23.720 --> 49:36.920]  где ab координаты сайта, координаты очередного сайта. Вот. Тогда что происходит в случае,
[49:36.920 --> 49:42.760]  если это z максимально возможная среди всех всех сайтов с координатами ab? Значит,
[49:42.840 --> 49:50.080]  вот это выражение больше, чем все остальные для всех других h' и b'. Давайте напишу, что 2ax
[49:50.080 --> 50:03.000]  плюс 2by минус a квадрат плюс b квадрат больше, чем 2ax плюс 2by минус h' квадрат плюс b' квадрат,
[50:03.000 --> 50:11.200]  где ab это некий сайт, а h' и b' любой другой сайт. То есть вот эта плоскость самая высока в точке
[50:11.200 --> 50:17.120]  x, y. Значит, она больше, чем все остальные. Вот. Ну, здесь, если как-то сгруппировать,
[50:17.120 --> 50:29.080]  то у нас как раз получится... Я хочу получить a-h' в квадрате плюс b-b' в квадрате. Нет,
[50:29.080 --> 50:35.400]  не так, не совсем. Сейчас, сейчас, сейчас. Я хочу получить a-x в квадрате плюс b-x в квадрат
[50:35.400 --> 50:47.200]  против h' минус x квадрат плюс b' минус y квадрат. И тем самым я получу расстояние от одного сайта
[50:47.200 --> 50:52.440]  до точки x, y и от другого сайта до точки x, y. Значит, они отличаются на x... Окей, да. Значит,
[50:52.440 --> 50:57.120]  давай тогда в обе части добавим x квадрат плюс y квадрат. От этого неравенство не изменится,
[50:57.120 --> 51:03.080]  но зато я смогу здесь выделить полный квадрат. Здесь будет написано минус a квадрат плюс 2ax.
[51:03.080 --> 51:12.800]  Минус x квадрат. Минус, значит, вот есть такая штука. А дальше плюс минус b квадрат плюс 2by
[51:12.800 --> 51:22.680]  минус y квадрат. Больше, но все то же самое, только h' и b'. Окей, я вычел из обеих частей x квадрат
[51:22.680 --> 51:27.360]  плюс y квадрат. Значит, дальше тогда я могу здесь написать полный квадрат, и у меня как раз
[51:27.360 --> 51:35.400]  получается что... Что написано здесь? Здесь написано минус расстояние от x, y до ab в квадрате.
[51:35.400 --> 51:42.640]  Минус квадрат расстояния от x, y до ab. А здесь написано тоже минус квадрат расстояния от x,
[51:42.640 --> 51:49.520]  y до a' и b'. Поэтому написано вот здесь вот. Вот это вот неравенство означает, что точка ab
[51:49.520 --> 51:57.520]  самое близкое к точке x и y. Так, ну придется все-таки новую доску заюзать.
[51:57.520 --> 52:18.840]  Значит, давайте я еще раз напишу аккуратненько, минус x квадрат плюс y квадрат меньше, чем минус
[52:18.840 --> 52:42.960]  x квадрат. Значит, просто dist от x, y до a, b меньше dist от x, y до a, b. Ну, собственно, все.
[52:42.960 --> 52:49.640]  Это означает, что вот та самая верхняя плоскость в соответствии с точкой x и y, она соответствует
[52:49.640 --> 52:56.200]  самому ближайшему сайту. Поэтому, когда я проецирую мою верхнюю огибающую на плоскости x и y,
[52:56.200 --> 53:02.480]  у меня как раз что будут ребрами и вершинами? Ребра – это пересечение плоскостей, да, таких,
[53:02.480 --> 53:08.840]  что там одна – это ближайшая к одному сайту, а соседняя – ближайшая к другому сайту. Тогда их
[53:08.840 --> 53:14.560]  пересечение – это как раз точки на границе между сайтами, на границе между ячейками сайтов. Ну,
[53:14.560 --> 53:20.760]  вот тогда, соответственно, как раз прямой отрезка пересечения двух плоскостей – это в
[53:20.760 --> 53:24.320]  точности граница между двумя ячейками. Если у меня три плоскости пересекают в одной точке,
[53:24.320 --> 53:27.800]  то, соответственно, проекция – это точки вершины диаграмма Воронова. То есть у меня как раз… Ну,
[53:27.800 --> 53:35.240]  по сути, самое главное – это что вот эта вот подстановка x, y в уравнение плоскостей – они в
[53:35.240 --> 53:40.960]  каком-то смысле задают расстояние от точки до сайтов. И если я беру верхнюю огибающую,
[53:40.960 --> 53:45.920]  то есть самую высокую плоскость в данной точке, пересекающей наш луч, то у меня как раз вот она
[53:45.920 --> 53:50.640]  соответствует тому сайту, который ближе всего к точке x, y. Значит, соответственно, здесь просто
[53:50.640 --> 53:57.960]  автоматически возникает диаграмма Воронова. Ок? Ну и все, значит, соответственно, если научиться
[53:57.960 --> 54:02.880]  внезапно откуда-то находить верхнюю огибающую, то мы сможем после проекции получить диаграмму
[54:02.880 --> 54:21.400]  Воронова. Но опять это там какой-то сложный англичан еще. Так. Вот. Ну все, тогда вроде с Вороным и
[54:21.400 --> 54:30.120]  Диланэ мы все сказали. Последний сюжет рядом с геометрией лежащей – это так называемое
[54:30.120 --> 54:42.480]  кд-дерево. Начнем мы будем рассматривать 2d-дерево. D от слова dimension, ну, то есть как бы 2d-дерево,
[54:42.480 --> 54:51.000]  2-мерное дерево, 3d-трехмерное, kd, соответственно, k-мерное. Вот. Значит, это такая общая, некая общая
[54:51.000 --> 54:56.000]  структура, которая позволяет отвечать на разные запросы для данного множества точек. Все, значит,
[54:56.000 --> 54:59.720]  Вороной и Диланэ осталось позади. Теперь еще вот отдельный кусочек программы. Давайте на нем
[54:59.720 --> 55:08.120]  сконцентрируемся теперь. Просто такой отдельный сюжет. Значит, давайте именно жить в случае 2d,
[55:08.120 --> 55:17.240]  то есть в случае двухмерной плоскости. У нас есть две координатные оси x и y. И в ней есть некие
[55:17.240 --> 55:22.480]  точки. В этой плоскости есть некие точки. Ну, скажем, давайте они фиксированы и не меняются.
[55:22.480 --> 55:31.160]  Есть фиксировано множество точек. И давайте скажем, что поступают два типа запросов. В каждой
[55:31.160 --> 55:35.680]  точке ассоциировано какое-то еще число, то есть в каждой точке написано некое число, аи-тое какое-то,
[55:35.680 --> 55:43.440]  ажитое и так далее. И запрос это либо изменение значения в точке, либо подсчет суммы в прямоугольнике.
[55:43.440 --> 55:54.680]  Значит, изменение аи в точке, либо сумма в прямоугольнике.
[56:04.520 --> 56:09.240]  Вот. Ну, на самом деле, если у нас задача статическая, то это можно было бы решать просто
[56:09.240 --> 56:15.080]  деревом Фенлика и деревом Фенлика. У вас, вроде, была такая задача в первом семестре. Ну, если,
[56:15.080 --> 56:21.880]  то есть, на самом деле, лучше два дерева ничем не лучше здесь. Оно лучше, только если у вас множество
[56:21.880 --> 56:26.000]  может расширяться. Ну, пока давайте вот именно такую постановку посмотрим, когда множество точек
[56:26.000 --> 56:31.680]  фиксировано, изменяя в точке и сумма в прямоугольнике. Значит, смотрите, здесь, на самом деле, идея весьма
[56:31.680 --> 56:39.600]  простая. Единственное, что здесь сложное, это анализ симптотики. Значит, идея. Давайте мы,
[56:39.600 --> 56:44.480]  так же как в каком-нибудь дереве отрезков, будем делить наши точки пополам. Вот есть у нас набор
[56:44.480 --> 56:50.400]  точек на плоскости. Давайте поделим их на две равные части какой-нибудь вертикальной прямой.
[56:50.400 --> 56:58.080]  Ну вот, у меня так хорошо получилось, что здесь 6 точек и здесь 6 точек. Нет, да, все правильно.
[56:58.080 --> 57:04.400]  Поделил вертикальной прямой. Да, и дальше, соответственно, у меня есть два куска. В каждом из них
[57:04.400 --> 57:10.120]  я делаю то же самое, только делю уже не вертикальной прямой, а горизонтальной. То есть, здесь у меня есть,
[57:10.120 --> 57:17.160]  скажем, по 6 точек в каждой штуке. Вот здесь вот эта прямая разделяет их на куски одинакового
[57:17.160 --> 57:23.760]  размера. А здесь, ну, например, сейчас я их поярче нарисую, вот эта прямая. Они уже заметили,
[57:23.760 --> 57:28.800]  совсем не обязательно одна и та же прямая. То есть, это какие-то куски прямых. Дальше,
[57:28.800 --> 57:33.280]  рекурсивно, у меня есть некие кусочки. Я каждый из них опять как-то подразбиваю,
[57:33.280 --> 57:38.320]  но теперь уже опять вертикальный прямой. Так чтобы с левой справа лежало примерно поровну. Здесь
[57:38.320 --> 57:44.160]  уже будет у нас нечетное количество точек, поэтому я буду делить на примерно равные куски. Вот,
[57:44.160 --> 57:48.480]  ну, здесь, скажем, будет одна точка, здесь две точки. И опять, вот эта штука нужно горизонтально
[57:48.480 --> 57:54.920]  прямой разбить на две равные части. У меня будет вот такое доделение. Вот, ну и так далее. То есть,
[57:54.920 --> 58:00.480]  у меня в каждом куске, в каждом текущем куске я провожу либо вертикальную прямую, либо
[58:00.480 --> 58:05.480]  горизонтальную, чередуясь так, чтобы все множество точек разбилось примерно пополам. Если,
[58:05.480 --> 58:11.200]  соответственно, какой-нибудь плохой случай, что у меня много точек на медианном иксе,
[58:11.200 --> 58:16.800]  мне нужно провести вот такую прямую. И, короче, не получается, что как бы надо что-то вот такое
[58:16.800 --> 58:21.040]  провести в каком-то смысле. Ну давай тогда просто формально считать, что я провожу все равно вот
[58:21.040 --> 58:26.640]  такую прямую, но только вот эти вот точки я отношу влево, а эти точки отношу вправо. То есть,
[58:26.640 --> 58:31.760]  это не обязательно прямая разделяющая прямая, но, по сути, у меня точки, порядочные по х и по y,
[58:31.760 --> 58:37.120]  я провожу вот такую штуку, и они еще и по y как-то ограничены. То есть, либо так, либо давайте,
[58:37.120 --> 58:40.880]  для удобства буду говорить, что нет точек с одинаковыми х и с одинаковыми y. То есть,
[58:40.880 --> 58:44.640]  всегда можно так разбить, вот так вот хорошо, чтобы не было таких проблем. Но, на самом деле,
[58:44.640 --> 58:48.480]  они тоже не являются проблемой. Надо просто взять вот эту прямую и сказать, что первые,
[58:48.480 --> 58:55.320]  сколько точек идут влево, остальные идут вправо. В итоге у меня получается такое дерево, повторюсь,
[58:55.320 --> 59:00.040]  у меня чередуются прямые, которые разделяют наш текущий кусок плоскости, либо вертикальные,
[59:00.040 --> 59:06.240]  либо горизонтальные. Но каждый раз при спуске в дочернюю ситуацию у меня число точек делится
[59:06.240 --> 59:13.440]  примерно вдвое. Я примерно пополам разбиваю нашу множество точек. Одно множество точек идет влево,
[59:13.440 --> 59:18.040]  другое идет вправо. Я каждый раз примерно в два раза уменьшаю число точек. Поэтому глубина
[59:18.040 --> 59:21.880]  такой структуры будет логарифмическая. Каждый раз число точек делится в два раза. Глубина
[59:21.880 --> 59:30.880]  логарифмическая, конечно. Глубина логарифмическая. Ну и время построения будет n log n, потому что раз
[59:30.880 --> 59:34.560]  глубина логарифмическая, то каждая конкретная точка лежит примерно в логарифмичных уровнях,
[59:34.560 --> 59:49.600]  поэтому это все можно построить на самом деле n log n. Надо только пояснить, почему можно за
[59:49.600 --> 59:55.840]  линейное время проводить вот такую разделяющую прямую в данном множестве точек. И это вопрос
[59:55.840 --> 01:00:02.200]  уже к вам. Как, если у нас есть множество точек, найти вертикальную прямую, разделяющую на два
[01:00:02.200 --> 01:00:20.480]  равных куска? За линию хотим. Бин пояс, там будет логарифм еще лишний, тогда будет лог квадрат.
[01:00:20.480 --> 01:00:28.600]  Нет, всем не обязательно, потому что может быть какая-то очень далекая точка, которая портит вам
[01:00:28.600 --> 01:00:39.080]  все. Так, ну тут я хочу, чтобы вы мне все-таки сами ответили. Вот смотрите, давайте я прошу задачу,
[01:00:39.080 --> 01:00:47.200]  давайте я рассмотрю одномерный случай. Все точки находятся на прямой, я хочу их разделить на два
[01:00:47.200 --> 01:01:02.240]  равных куска. Хорошая идея, можно действительно посортировать и просто вывести n пополам на
[01:01:02.240 --> 01:01:09.400]  статистику, но проблема в том, что у вас, когда вы меняете вот это направление прямой, у вас
[01:01:09.400 --> 01:01:14.840]  меняется порядок, и причем довольно непредсказуемо. То есть вам нужно как бы хранить, и при этом еще
[01:01:14.840 --> 01:01:24.160]  но что точек сужается, ну короче такое. Мне очень приятно. Вот без сортировки хочу.
[01:01:24.160 --> 01:01:49.960]  Да ладно, я же даже сказал уже правильные слова. Да, за сколько мы ищем? За линию, да,
[01:01:49.960 --> 01:01:57.280]  конечно, поэтому как бы просто ищем вот эту, ну по сути мы ищем медиану, да, медиана. У нас
[01:01:57.280 --> 01:02:02.200]  есть алгоритм, который делает за линию, даже детерминированно невероятно. Вот, ну и все,
[01:02:02.200 --> 01:02:07.400]  соответственно, чтобы найти очередную разделяющую прямую, я там смотрю либо на все х, либо на все
[01:02:07.400 --> 01:02:12.480]  y, в зависимости от того, какую прямую провожу, нахожу медиану за линию, вот и собственно тем самым
[01:02:12.480 --> 01:02:19.720]  разделяем наш точек на два примерно равных. Так, хорошо, значит построение будет аналоген. Вот,
[01:02:19.720 --> 01:02:28.320]  запрос, ну, значит, давай еще скажем, что, то есть у меня по сути что есть, смотрите, у меня есть,
[01:02:28.320 --> 01:02:35.960]  по сути, каждый вот, на каждом шаге у меня есть набор точек, да, которые лежат в некоторой,
[01:02:35.960 --> 01:02:39.200]  вот давайте еще нарисуем на каждом шаге баундинг бокс текущий. Вот у меня был множество точек,
[01:02:39.200 --> 01:02:43.800]  какой это изначально. Чтобы найти его баундинг бокс, мне нужно взять минимальный х, максимальный х,
[01:02:43.800 --> 01:02:48.800]  минимальный х, максимальный х, ну, то есть ограничивать со всех четырех сторон такими прямыми
[01:02:48.800 --> 01:02:54.440]  параллельными сам координатами. Значит, это у меня был баундинг бокс в начале. Дальше, я как-то разбил
[01:02:54.440 --> 01:02:59.440]  вот такой прямой и опять у меня есть, то есть, по сути, я как бы спускаюсь на уровень ниже,
[01:02:59.440 --> 01:03:03.400]  у меня есть два на что точек, в каждом из них давайте опять посчитаем баундинг бокс. Значит,
[01:03:03.400 --> 01:03:13.560]  здесь он будет, какой-то вот, сейчас будем учиться. Давайте я сначала баундинг бокс нарисую,
[01:03:13.560 --> 01:03:20.240]  да, вот здесь будет такой, здесь будет такой какой-нибудь, вот, ну, что-то такое, ну и так далее. То есть,
[01:03:20.240 --> 01:03:27.400]  каждый раз у меня сужается баундинг бокс моего множества точек. Так вот, как тогда отвечать на
[01:03:27.400 --> 01:03:33.880]  запрос, скажем, первого типа? Давайте я буду в каждом вот этом текущем баундинг боксе, то есть,
[01:03:33.880 --> 01:03:39.040]  на каждом уровне моего вот этого рекурсивного спуска, я буду хранить сумму тех чисел, которые
[01:03:39.040 --> 01:03:43.960]  лежат в нашем прямоугольнике текущем. Тогда, если мне, скажем, поступит запрос суммы в
[01:03:43.960 --> 01:03:47.960]  прямоугольнике, который, например, целиком содержит весь наш прямоугольник, весь наш баундинг
[01:03:47.960 --> 01:03:51.680]  бокс, то мне нужно просто вернуть сумму в этом прямоугольнике. Если он как-то там пересекает,
[01:03:51.680 --> 01:03:56.680]  то давайте просто рекурсивно запустимся слева и справа с учетом пересечения нашего большого
[01:03:57.560 --> 01:04:01.560]  прямоугольника запроса с нашим большим прямоугольником. Это будет там какой-то кусок здесь,
[01:04:01.560 --> 01:04:05.080]  какой-то кусок здесь и так далее. То есть, еще раз, главное, что я хочу сказать,
[01:04:05.080 --> 01:04:21.160]  что мы в каждой вершине два дерева храним сумму чисел в текущем баундинг боксе.
[01:04:21.160 --> 01:04:36.600]  Сумму чисел в текущем баундинг боксе. Вот. Тогда запрос первого типа оборваться за алгорифом
[01:04:36.600 --> 01:04:42.760]  просто, потому что мне нужно проследить, как АИТ разбивается в этом нашем, то есть мы каждый раз
[01:04:42.760 --> 01:04:47.640]  делим множество на два, надо проследить путь конкретной точки АИ и, соответственно, во всех
[01:04:47.640 --> 01:04:52.080]  вершинах нашего КД дерева, во всех баундинг боксах, в которых она содержалась, нужно там
[01:04:52.080 --> 01:05:02.760]  изменить сумму на дельточку. Поэтому запрос первого типа обрабатывается просто за алгорифом.
[01:05:02.760 --> 01:05:15.160]  Просто проследить путь АИ в этом самом интерактивном разбиении рекурсивном и везде сделать изменение
[01:05:15.160 --> 01:05:21.560]  суммы на дельточку. Новая минус старая. Вопрос, что делать с запросами суммы в прямоугольнике.
[01:05:21.560 --> 01:05:28.120]  По сути, ровно так же, как мы делаем в дереве отрезков. Вот у меня есть текущий баундинг бокс.
[01:05:28.120 --> 01:05:35.440]  Давайте его нарисую вот так. Есть текущий баундинг бокс и есть текущий запрос. Давайте его нарисую
[01:05:35.440 --> 01:05:44.760]  вот так, жирным. Тогда, ну простые ситуации. Если запрос полностью содержит баундинг бокс,
[01:05:44.760 --> 01:05:50.920]  то мне нужно просто вернуть значение из баундинг бокса, сумму во всем прямоугольнике. Первый
[01:05:50.920 --> 01:05:56.200]  просто случай. Второй просто случай. Если они не пересекаются, давайте нарисуем. Вот был баундинг
[01:05:56.200 --> 01:06:01.760]  бокс такой и он был целиком вложен в прямоугольник, который нас интересует. Тогда нужно просто вернуть
[01:06:01.760 --> 01:06:07.400]  сумму из этого баундинг бокса. Все, что у нас доступно, это входит в наш прямоугольник. Второй
[01:06:07.400 --> 01:06:13.320]  просто случай. Если наш текущий баундинг бокс не пересекается с запросом, тогда надо вернуть ноль
[01:06:13.320 --> 01:06:19.080]  просто. Там много точек, лежащих здесь и здесь, а он имеет сумму ноль. Ну и интересный случай,
[01:06:19.080 --> 01:06:28.240]  когда он как-то пересекается, но не вложены они. Ну вот что-то такое как раз. В смысле маленький
[01:06:28.240 --> 01:06:34.320]  вложен в большой. Если такое, то можно сразу сузить и сказать, что они вот так пересекаются,
[01:06:34.320 --> 01:06:37.920]  потому что вот эти точки все равно у нас не влияют. То есть у меня в любом случае получается некое
[01:06:37.920 --> 01:06:45.880]  пересечение баундинг бокса с прямоугольником запроса. И тогда я его, соответственно, что
[01:06:45.880 --> 01:06:53.280]  делать? Я рассекаю наш прямоугольник некой вертикальной прямой, медианной по x или горизонтальной
[01:06:53.280 --> 01:07:00.440]  по y. И дальше иду либо влево, либо вправо, либо и туда, и туда, если существует пересечение нашего
[01:07:00.440 --> 01:07:06.400]  прямоугольника с баундинг боксом внутри каждого из детей. То есть алгоритм на самом деле очень
[01:07:06.400 --> 01:07:12.440]  простой. У нас есть текущий баундинг бокс и запрос прямоугольника. Эти две ситуации отдельно
[01:07:12.440 --> 01:07:17.520]  и файм. То есть либо сразу завершаемся добавив к ответу либо ноль, либо сумма в всем баундинг
[01:07:17.520 --> 01:07:24.280]  боксе. А дальше, если ни то ни то не произошло, я перехожу на уровень ниже, я знаю, как мой
[01:07:24.280 --> 01:07:27.600]  баундинг бокс рассечется на два более маленьких. Скажем, здесь будет такой баундинг бокс, здесь вот
[01:07:27.600 --> 01:07:34.160]  такой. Ну и соответственно, просто рекурсивно запускаюсь от обоих детей, то есть вот от этого
[01:07:34.160 --> 01:07:38.280]  баундинг бокса и прямоугольника запроса, от этого баундинг бокса и этого прямоугольника запроса.
[01:07:38.280 --> 01:07:43.360]  И там они дальше, собственно, рекурсивно также делаются. То есть по сути ровно так же, как в
[01:07:43.360 --> 01:07:51.440]  дереве отрезков. У нас есть все множество точек и некий запрос. Я либо сразу завершаюсь,
[01:07:51.440 --> 01:07:56.080]  либо иду в тех детей, где переченье не пусто. То есть я просто иду в тех детей,
[01:07:56.080 --> 01:08:12.040]  иду в детей, где переченье не пусто. Такой тоже очень простой для реализации алгоритм. У нас есть
[01:08:12.040 --> 01:08:16.960]  баундинг бокс слева и справа. Смотрим, пересекается ли запрос с этими баундинг боксами. Если да,
[01:08:16.960 --> 01:08:22.680]  то идем в соответствующий ребенка. Если нет, то не идем. И здесь, как ни странно, асимботика будет
[01:08:22.680 --> 01:08:27.800]  гораздо хуже, чем алгоритм. На самом деле, асимботика будет корневая. Корень визан.
[01:08:27.800 --> 01:08:39.000]  Так, вроде время есть, поэтому можно доказать или по крайней мере частично доказать. Я утверждаю,
[01:08:39.000 --> 01:08:44.280]  что если так в тупую делать, то количество баундинг боксов, то есть вершин в кадре дерева,
[01:08:44.280 --> 01:08:51.920]  которые мы обойдем, будут корневыми. Для этого нужно аккуратно проанализировать то,
[01:08:51.920 --> 01:08:57.320]  как у нас пересекается прямоугольник запроса с текущим баундинг боксом. По сути, давайте вспомним
[01:08:57.320 --> 01:09:02.400]  временно, как мы действовали в дереве отрезков. Дерево отрезков мы делали примерно так. Мы встали
[01:09:02.400 --> 01:09:08.280]  в корень, и нам нужно найти пересечение с каким-нибудь отрезком. Мы сначала идем вниз, пока этот отрезок
[01:09:08.280 --> 01:09:12.680]  запроса лежит целиком в одном из сценовей. То есть мы сначала спускаемся куда-то. Затем у нас
[01:09:12.680 --> 01:09:17.920]  происходит реальное пересечение нашего отрезка. То есть у нас отрезок разбивается на два под отрезка,
[01:09:17.920 --> 01:09:23.560]  и прямоугольник запроса, отрезок запроса, он как-то вот так вот пересекается и с левым, и с правым.
[01:09:23.560 --> 01:09:28.720]  Вот здесь мы раздвайливаемся, а дальше у меня вот здесь у нас получается, что текущий запрос это
[01:09:28.720 --> 01:09:33.360]  суффикс, а здесь текущий запрос это префикс. Дальше мы доказываем, что тогда, если я иду здесь вниз,
[01:09:33.360 --> 01:09:38.560]  то я либо иду влево, а справа беру целиком, либо влево вообще не иду, и справа запускаюсь
[01:09:38.560 --> 01:09:43.240]  рекурсивно. То есть вот здесь вот как только у меня расщепляется наш запрос, он становится сразу
[01:09:43.240 --> 01:09:47.760]  либо суффиксом, либо префиксом, и в этом случае уже легко доказать, что оставшееся число вершин,
[01:09:47.760 --> 01:09:51.960]  которые мы рассмотрим, он логарифмичный. Вот логарифм. Давайте что-то такое же сделаем здесь. То есть
[01:09:51.960 --> 01:09:57.180]  тут по сути смотрите, что мы сделали. У нас было изначально все в общем положении, то есть есть
[01:09:57.180 --> 01:10:07.580]  некий отрезок, есть некий запрос внутри него. Вот мы либо оставляем ситуацию такой же, пока отрезок
[01:10:07.580 --> 01:10:12.580]  запрос лежит целиком либо слева, либо справа, то есть это как раз первая начальная ветка. А впервые,
[01:10:12.580 --> 01:10:16.740]  когда мы расщепились, мы переходим к суффиксу и префиксу. То есть у нас есть ситуация вот такая
[01:10:16.740 --> 01:10:22.060]  общая, когда отрезок это не суффикс, не префикс. Есть вот такая ситуация, когда отрезок это суффикс,
[01:10:22.060 --> 01:10:29.780]  есть вот такая ситуация, когда отрезок это префикс. Ну и дальше, собственно, у нас есть по сути
[01:10:29.780 --> 01:10:33.980]  три возможных ситуации. Дальше мы доказываем, что время работы для каждой из них логарифмичный.
[01:10:34.820 --> 01:10:35.700]  Что-то такое сделаем здесь.
[01:10:49.020 --> 01:10:58.460]  Значит, давайте обозначу, у меня будет такое обозначение, т с индексом прямоугольник и запрос от m.
[01:10:58.460 --> 01:11:06.500]  Это значит, что мы сейчас находимся в уровне кд-дерева, который содержит n вершин, то есть
[01:11:06.500 --> 01:11:10.900]  на верхнем уровне n вершин, на втором n пополам, потом n4 и так далее. То есть сколько вершин на
[01:11:10.900 --> 01:11:17.380]  текущем уровне в каждой вешине нашего кд-дерева. А это наиболее полная информация, которую мы
[01:11:17.380 --> 01:11:23.380]  гарантированно знаем про наш запрос. То есть изначально мы ничего не знаем, кроме того,
[01:11:23.380 --> 01:11:31.420]  что по сути мы ничего не знаем. То есть вот там, в дереве отрезков, я в какой-то момент знаю,
[01:11:31.420 --> 01:11:34.980]  что он суфикс, в какой-то момент знаю, что он префикс. Тогда я могу точно нарисовать,
[01:11:34.980 --> 01:11:40.580]  что они вот здесь вот касаются. А вот здесь вот, изначально, я ничего не знаю, он никого не касается,
[01:11:40.580 --> 01:11:45.620]  ни сверху, ни снизу, ни слева, ни справа. То есть он может быть как-то там, как-то вот так вот пересекаться.
[01:11:45.620 --> 01:11:51.460]  Во-первых, я могу заведомо выкинуть все, что находится вне нашего баунинбокса. Во-вторых,
[01:11:51.460 --> 01:11:56.420]  это больше информации, чем вот это. Здесь как бы написано, что он касается справа. А
[01:11:56.420 --> 01:12:01.780]  здесь написано, что фиг его знает. Вот поэтому давайте рисовать так. То есть общая ситуация будет
[01:12:01.780 --> 01:12:08.460]  такая. Значит, какие здесь есть случаи? Давайте рисовать вертикальную разделяющую прямую. Значит,
[01:12:08.460 --> 01:12:16.820]  ну может быть такое, что я имею какую-то вот такую картинку, тогда после проведения вертикальной
[01:12:16.820 --> 01:12:21.980]  прямой мне нужно идти только в левого сына, и в нем ситуация такая же. То есть опять есть некий
[01:12:21.980 --> 01:12:28.980]  прямоугольник, который где-то внутри лежит. Либо интересная ситуация, когда мы пересекаемся вот так.
[01:12:28.980 --> 01:12:38.660]  То есть давайте я напишу, что мы либо идем... Так, давайте вот так нарисую. Либо мы идем в
[01:12:38.660 --> 01:12:49.820]  аналогичную картинку с параметром n пополам плюс 100 единицы. Либо у нас этот прямоугольник запроса
[01:12:49.820 --> 01:12:55.940]  рассекся на два, и я запускаюсь от обоих сыновей, но с новым допусловием, что здесь есть привязка к
[01:12:55.940 --> 01:13:02.380]  границе. То есть по сути вот этот прямоугольник запроса сейчас привязан к границе нашей баунинбокса.
[01:13:02.380 --> 01:13:07.460]  Это уже хорошо. То есть это как бы новая информация, которую мы здесь сейчас будем отображать. Но смотрите
[01:13:07.460 --> 01:13:12.220]  здесь дальше, когда я спускаюсь в рекурсию, у меня меняется направление разделяющей прямой.
[01:13:12.220 --> 01:13:18.580]  Если сейчас она была вертикален, то после этого будет горизонтальная. Я не хочу рисовать отдельно
[01:13:18.580 --> 01:13:23.100]  случай для вертикальных и горизонтальных прямых. Давайте я лучше вместо этого поверну мою картинку
[01:13:23.100 --> 01:13:30.820]  на 90 градусов там по часовой стрелке. И тогда следующее, как бы то, что было горизонтально
[01:13:30.820 --> 01:13:34.460]  разделяющей, станет вертикально разделяющей. Поэтому вот здесь вот я могу написать, что это
[01:13:34.460 --> 01:13:47.380]  время равно времени вот такому вот, а там пополам. Плюс времени. Здесь я, видимо, должен
[01:13:47.380 --> 01:13:52.940]  нарисовать, где прямоугольник сверху нарисован. Привязан к верхней границе. Ну как бы понятно,
[01:13:52.940 --> 01:14:00.140]  что это одно и то же время. А поэтому я пишу здесь просто двойку. То есть еще раз, после спуска в
[01:14:00.140 --> 01:14:07.100]  рекурсию у меня по факту прямоугольник привязан к правой или левой стороне, но прямая
[01:14:07.100 --> 01:14:11.980]  проводится горизонтально. Если я поверну 90 градусов, то у меня картинка будет такая. У меня
[01:14:11.980 --> 01:14:16.980]  прямоугольник привязан снизу или сверху и проводится вертикальная прямая. Ну понятно,
[01:14:16.980 --> 01:14:22.460]  что это одно и то же. Похоже, что это одно и то же. На самом деле действительно так и будет. Но давайте
[01:14:22.460 --> 01:14:27.620]  я для простоты и скажу, что и случай симметричный одинаковый. Хорошо, появилась новая картинка,
[01:14:27.620 --> 01:14:34.820]  когда прямоугольник привязан к нижней стороне. Давайте поймем, чему равно время работы на n
[01:14:34.820 --> 01:14:43.780]  точках в этом случае. Опять я провожу вертикальную прямую. Надо понять, как у меня рассекается эта
[01:14:43.780 --> 01:14:51.580]  штука. Ну первое, давайте опять здесь буду рисовать. Простой случай, когда у меня отделяется целиком
[01:14:51.580 --> 01:14:55.220]  наш прямоугольный запрос и идет в одну из двух сторон, тогда мы свойствуемся к той же ситуации
[01:14:55.220 --> 01:15:07.860]  с n пополам вершинами. Либо же, либо у меня наш прямоугольный запрос и пересекается с линии
[01:15:07.860 --> 01:15:12.660]  разреза. И соответственно, когда я запускаюсь слева от вот такого уголочка и справа вот от такого
[01:15:12.660 --> 01:15:17.060]  уголочка. Надо только не забыть их повернуть. Значит здесь, когда я поворачиваю, у меня будет
[01:15:17.420 --> 01:15:26.500]  запрос, скажем, вот такой вот, на левый нижний уголок. Давайте вот так поверну, а там пополам.
[01:15:26.500 --> 01:15:31.660]  Ну и здесь тоже, если перейду на 90 градусов вот так вот, то у меня будет верхний левый уголок,
[01:15:31.660 --> 01:15:35.060]  но понятно, что с точки зрения вертикальной прямой это одно и то же. Поэтому здесь напишу опять-таки
[01:15:35.060 --> 01:15:45.660]  двойку. Согласны? Вот. Ну что, появилась новая штука. Давайте ее напишем.
[01:16:05.060 --> 01:16:11.020]  Значит опять, вот картинка сейчас такая. Я знаю, что прямоугольник привязан к левой нижней,
[01:16:11.020 --> 01:16:17.820]  к левой и к нижней сторонам. Я пробую вертикальную прямую. Ну здесь опять, либо у меня прямое
[01:16:17.820 --> 01:16:22.100]  разделение вообще его не затрагивает, тогда я остаюсь в такой же картинке, только уже с n
[01:16:22.100 --> 01:16:30.060]  пополам точками. Так, кстати, я здесь пишу глупость, потому что я вот здесь забыл повернуть. Да, вот,
[01:16:30.060 --> 01:16:35.820]  я же провел вертикальную прямую и повернул, поэтому на самом деле здесь картинка вот такая.
[01:16:35.820 --> 01:16:41.780]  У меня касание будет с левой стороны, а не с правой. Вот. Ну на самом деле все несущественно,
[01:16:41.780 --> 01:16:47.100]  потому что у меня будет все равно, короче, здесь все медики будут, ну в общем, давайте так для
[01:16:47.100 --> 01:16:52.300]  правильности сделают. Итак, здесь я прошу вертикальную прямую, справа, например, никого нет,
[01:16:52.300 --> 01:16:56.900]  а левый чувак тогда поворачивает на 90 градусов, у меня получается верхний левый треугольник,
[01:16:56.900 --> 01:17:01.380]  но опять-таки с точки зрения вертикальной прямой это то же самое, что левый нижний треугольник,
[01:17:01.380 --> 01:17:09.340]  поэтому я здесь оставлю ту же самую картинку. Вот. Либо же я рассекаю наш уголочек как-нибудь,
[01:17:09.340 --> 01:17:18.740]  вот так вот. Вот так его рассек. Вот. И у меня тогда остается после вращения опять ситуация,
[01:17:18.740 --> 01:17:24.140]  что у меня, смотрите, здесь привязка к трем сторонам, левая, нижняя и правая. После вращения
[01:17:24.540 --> 01:17:31.820]  это будет, видимо, что-то вот такое. А если это первое на 90, у меня будет как раз, да,
[01:17:31.820 --> 01:17:40.700]  будет как раз вот эти стороны, вот он пополам, плюс вот эта штука при повороте на 90 останется
[01:17:40.700 --> 01:17:54.100]  уголочком, поэтому я оставлю здесь уголочек. Ну, если действовать так дальше, если рассматривать
[01:17:54.100 --> 01:18:00.740]  все возможные конфигурации вложенности прямоугольника запроса в bounding box, то вот здесь
[01:18:00.740 --> 01:18:04.780]  все было хорошо. В DO все было идеально, а у меня было как бы все в 103 ситуации. Либо никуда,
[01:18:04.780 --> 01:18:09.980]  либо влево, либо вправо. Но если слева и справа, то это сразу зовут и не сработает, потому что
[01:18:09.980 --> 01:18:14.940]  целиком отрезок вложен в bounding box. Здесь как бы случаев побольше, ну потому что у нас сторон
[01:18:14.940 --> 01:18:20.540]  побольше, да, и 2,5 сторон многовато что-то. Вот. Ну давайте, то есть что у меня еще есть? У меня
[01:18:20.540 --> 01:18:28.660]  остается вот это вот, да, не прописанное, и вот это не прописанное. Давайте я скажу, что вот это
[01:18:28.660 --> 01:18:33.580]  примерно аналогично вот этому, не буду делать, времени все равно не остается, ну в общем, на пальцах
[01:18:33.580 --> 01:18:40.620]  давайте остаток доведем. Вот с этим разберемся. Там все равно все довольно аналогично. Значит,
[01:18:40.620 --> 01:18:46.900]  от этой штуки опять давайте посмотрим, что будет, если я прожу вертикальную прямую. Значит,
[01:18:46.900 --> 01:18:52.900]  вертикальная прямая, она либо не пересекает наш прямоугольник запроса и его поворачивает,
[01:18:52.900 --> 01:19:14.980]  то есть у меня будет картинка. Сложно мне. Да, низ короче, нижняя сторона. Так, либо он его
[01:19:14.980 --> 01:19:21.660]  пересекает, да, медианный х его пересекает, у нас получается что-то такое. Т от полностью закрашенного
[01:19:21.660 --> 01:19:37.060]  бауненбокса плюс, ну то же самое, где эта штука, это там нижняя какая-то часть, левая нижняя правая.
[01:19:37.060 --> 01:19:43.420]  Вот, но при этом понятно, что вот эта штука это вот единица, да, потому что алгоритм работает так,
[01:19:43.420 --> 01:19:47.900]  что как только прямоугольник запроса вложен в бауненбокс, мы просто сразу возвращаем всю
[01:19:47.900 --> 01:19:54.700]  сумму из бауненбокса. Вот, ну и остается, смотрите, вот эта вот штука, и они на самом деле друг
[01:19:54.700 --> 01:20:02.300]  через друга будут выражаться, и оттуда как раз получится корневая асимптотика. Значит,
[01:20:02.300 --> 01:20:10.780]  давайте нарисуем последнюю такую рекурренту. Значит, здесь, если я прожу вертикальную прямую,
[01:20:10.780 --> 01:20:24.980]  ой, вот просто, видимо, два, а нет, я прожу такую и вращаю, да, забыл, что я вращаю,
[01:20:24.980 --> 01:20:29.660]  значит, я провожу вертикально, мы точно знаем, как она рассечется, это будет просто левый нижний
[01:20:29.660 --> 01:20:33.820]  и правый нижний угол, вот, но только после вращения мы опять вернемся к такой картинке,
[01:20:33.820 --> 01:20:45.060]  поэтому будет две вот такие конскурации. Вот, вот это самый важный момент, что у нас есть такая
[01:20:45.060 --> 01:20:55.700]  картинка, она сводится к одной такой, а она вот этого сводится к двум предыдущим, то есть у нас
[01:20:55.700 --> 01:21:01.940]  получилась рекуррента, выражаешь, то есть первая через вторую и вторая через первую, видно? Вот,
[01:21:01.940 --> 01:21:07.460]  хорошо, значит, ну давайте здесь напишем, что, то есть, посмотрите, у меня вот эта штука выразилась,
[01:21:07.460 --> 01:21:11.780]  эта штука от единицы, поэтому у меня остается просто в любом случае вот это вот выражение,
[01:21:11.780 --> 01:21:18.020]  а потому что это одно и то же, отличается оно от единицы, поэтому это от единицы плюс, когда у
[01:21:18.020 --> 01:21:23.420]  нас левая нижняя верхняя, левая нижняя правая привязка, ну вот, значит, я могу опять эту штуку
[01:21:23.420 --> 01:21:33.380]  расписать, вот это вот, могу расписать через вот это, будет два, t от нижняя левая правая,
[01:21:33.380 --> 01:21:41.140]  вот n на 4 плюс от единицы, и я наконец-то замкнул нашу рекурренту, то есть я просто вот это вот
[01:21:41.140 --> 01:21:46.700]  расписал по этой формуле, и тем самым написал замкнутое выражение для рекуррента, когда у нас
[01:21:46.700 --> 01:21:51.660]  привязка к левой нижней и правой сторонам, вот, ну а решение такой рекуррент, то есть что у меня
[01:21:51.660 --> 01:22:00.460]  тут написано, что f от n, это 2 f от n на 4 плюс от единицы, ну это просто, например, по мастер-тиореме
[01:22:00.460 --> 01:22:10.140]  корень из n, то есть либо мастер-тиорема, либо как-нибудь руками можно доказать индукцией,
[01:22:10.140 --> 01:22:19.260]  то есть мы берем логарифм двойки по основанию 4, это будет как раз на степени одна вторая, вот это
[01:22:19.260 --> 01:22:23.300]  вот это там что-то бесконечно мало по сравнению с от корнем из n, поэтому асимптотика просто берется
[01:22:23.300 --> 01:22:32.540]  из ну как бы n в степени логарифм двойки по сравнению 4, тоже напишу это, n в степени логарифм двойки по
[01:22:32.540 --> 01:22:38.740]  сравнению 4, ну вот и все, теперь если аккуратно все это проанализировать с конца в начало,
[01:22:38.740 --> 01:22:45.500]  можно показать, что все симптотики на самом деле тоже корневые, ну давайте немножко это сделаем,
[01:22:45.500 --> 01:22:49.540]  значит тут понятно, что корень, вот это мы уже доказали, здесь смотрите, эта штука, то есть я знаю,
[01:22:49.540 --> 01:22:55.900]  что вот это от корня из n, дальше t, когда у меня привязка к верхней левой нижней сторонам от n,
[01:22:55.900 --> 01:23:02.980]  это то же самое для n пополам и левая нижняя правая, но я знаю, что эта штука, это примерно корень
[01:23:02.980 --> 01:23:11.820]  из n пополам, плюс шоут и низ, значит это просто корень от корня из n, просто потому что выражается
[01:23:11.820 --> 01:23:16.460]  через что-то корневое с коэффициентом пополам, ну остается корень из n зависимость. Дальше,
[01:23:16.460 --> 01:23:23.900]  здесь мы либо делимся пополам и сводимся к той же задаче, либо мы, вот здесь вот написано от
[01:23:23.900 --> 01:23:30.940]  корень из n и сводимся к той же задаче, то есть смотрите, у меня задача сводится рекурсительно
[01:23:30.940 --> 01:23:35.140]  сама к себе, когда у меня уголочек покрашен, я либо сразу свожусь к задаче в два раза меньше,
[01:23:35.140 --> 01:23:40.300]  либо прибавляю корень и свожусь к задаче в два раза меньше, поэтому суммарное время работы не
[01:23:40.300 --> 01:23:45.340]  больше, чем корень из n, плюс корень из n пополам, плюс корень из n на 4, корень из n на 8 и так далее,
[01:23:45.340 --> 01:23:50.140]  потому что я каждый раз делюсь на два и в худшем случае прибавляю корень от текущего значения.
[01:23:50.140 --> 01:24:07.980]  Если я скажу, что вот здесь вот корень, это конкретно c корня из n, время работы для уголочка не
[01:24:07.980 --> 01:24:15.500]  больше, чем c корня из n, плюс c корня из n пополам, плюс c корня из n на 4, ну в общем по всем
[01:24:15.500 --> 01:24:32.940]  степеням двойки. Это будет геометрическая прогрессия, что все сворачивается просто
[01:24:32.940 --> 01:24:38.620]  от корни из n. Геометрическая прогрессия с шагом меньше единицы, которая имеет какую-то конечную сумму,
[01:24:38.620 --> 01:24:45.180]  поэтому все опять корень из n. Здесь корень из n, ну и тогда если я здесь все докручу, то тоже
[01:24:45.180 --> 01:24:49.660]  аналогично, собственно используя то же самое соотношение про геометрическую прогрессию. Здесь
[01:24:49.660 --> 01:24:55.940]  будет от корня, здесь будет от корня. Последнее, мы получили структуру, которая отвечает на все за корень,
[01:24:56.460 --> 01:25:01.900]  но на реальных данных, вот давайте последнее, на реальных данных работает хорошо, давайте вот так
[01:25:01.900 --> 01:25:12.980]  просто скажу. На реальных данных, работает быстро. Ну потому что, грубо говоря, понятно, что на
[01:25:12.980 --> 01:25:19.300]  реальных данных тот прямоугольник запроса который нам поступает, он, ну то есть вот здесь мы оценили
[01:25:19.300 --> 01:25:24.720]  всегда худший случай, что прямоугольник запроса он всегда как бы, ну вот типа мы рассматриваем
[01:25:24.720 --> 01:25:28.000]  всегда худший случай, что он как бы напополам
[01:25:28.000 --> 01:25:30.040]  рассекается влево и вправо, но понятно, что рано или
[01:25:30.040 --> 01:25:32.040]  поздно, если примогулик какой-то нормальный, случайный,
[01:25:32.040 --> 01:25:34.200]  грубо говоря, то он рассечет, ну как бы уйдет в одну из
[01:25:34.200 --> 01:25:37.040]  двух половин, и поэтому ассистентрика будет сильно лучше, чем
[01:25:37.040 --> 01:25:38.040]  корень.
[01:25:38.040 --> 01:25:39.640]  То есть теоретически можно показать только корень,
[01:25:39.640 --> 01:25:41.760]  но как бы на практике получается, что эта штука работает
[01:25:41.760 --> 01:25:42.760]  весьма-весьма-весьма быстро.
[01:25:42.760 --> 01:25:43.760]  Все.
[01:25:43.760 --> 01:25:43.780]  Спасибо.
