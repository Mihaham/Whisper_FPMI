[00:00.000 --> 00:16.120]  На самом деле, даже вам в каком-то смысле повезло, что именно эта фара попадет под
[00:16.120 --> 00:21.720]  запись, потому что именно здесь и в этот и в следующий раз я буду рассказывать
[00:21.720 --> 00:29.080]  наиболее важные вещи для того, чтобы первые две большие задачи сдать получилось. Так что,
[00:29.080 --> 00:36.480]  возможно, вы еще потом будете это пересматривать. В поводу добавления в контест я не буду добавлять
[00:36.480 --> 00:44.480]  по одному, но у вас таких, кто не смог добавиться в контест, человек, не знаю, 50 может быть. Вот я в
[00:44.480 --> 00:49.160]  какой-то момент зайду еще раз таблицу, еще раз копипащу все логини, кто повторно туда
[00:49.160 --> 00:56.440]  писал и добавлю в контест. Я, наверное, сделаю это сегодня после пары. Писать мне в личку по одному,
[00:56.440 --> 01:00.480]  добавь меня в контест, не надо, пожалуйста. Я же не могу каждый раз открываться и по одному
[01:00.480 --> 01:17.800]  вас добавлять. Добавлю всех разом. Так, мы продолжаем ООП. В прошлый раз мы начали тему третью,
[01:17.800 --> 01:27.840]  которая называется «Ведение в ООП» и разобрали первые два пункта из нее. Вот, а сегодня
[01:34.680 --> 01:43.880]  мы переходим к следующему, и пункт называется «Конструкторы и деструкторы».
[01:48.800 --> 01:52.120]  Возможно, надо светлую тему сделать или не надо, и так нормально.
[01:52.120 --> 02:03.920]  Если темная тема плохо, то можно светлую сделать. Ну ладно, никто не жалуется, поэтому оставлю так.
[02:03.920 --> 02:15.560]  Ну так вот, напомню, можно объявлять свои классы. Ну, я давайте, чтобы не париться с приватностью,
[02:15.560 --> 02:20.800]  я буду объявлять структуру вместо классов пока что, чтобы не писать паблик постоянно. Вот,
[02:20.800 --> 02:30.840]  такая структура. Ну, если в ней есть какие-то поля, да и даже если нет никаких полей,
[02:30.840 --> 02:38.680]  я могу просто объявить, проинциализировать по умолчанию. При таком сознании создается объект
[02:38.680 --> 02:45.920]  данной структуры, у которого все поля проинциализированы по умолчанию. Что значит
[02:45.920 --> 02:50.920]  «проинциализированы по умолчанию»? Это значит, как если бы они локально были объявлены, вот так,
[02:50.920 --> 02:56.000]  как написано, так и проинциализированы, в данном случае в X будет рандомное значение. А если бы
[02:56.000 --> 03:02.240]  тут было написано вот так, то это бы означало, что X по умолчанию, в случае, когда структура
[03:02.240 --> 03:10.840]  следуется по умолчанию, это поле равно нулю. Кстати, такой синтаксис только c++11 появился,
[03:10.840 --> 03:18.240]  как-то странно. Поля по умолчанию имциализированы с значениями. Вот, но тем не менее, если я хочу
[03:20.240 --> 03:29.920]  явно указать, чему равны поля, это я все напоминаю, то я могу использовать вот такой синтаксис. Я
[03:29.920 --> 03:35.760]  могу написать там 1, запытаю 2.0, скажем, в фигурных скобках. Порядку перечислю. Тогда каждое поле
[03:35.760 --> 03:44.600]  проинциализируется соответствующим значениям. Вот, но если у меня это уже класс, а не структура,
[03:44.600 --> 03:57.280]  то такое дело не сработает. Вот. Почему это не сработало? Ну, то есть пока это было структурой,
[03:57.280 --> 04:03.040]  так можно делать было, а когда стало классом, нельзя. Ну, вы скажете, ну как же так, я же говорил,
[04:03.040 --> 04:07.400]  что класс и структура ничем друг от друга не отличаются. Да, это правда. Ничем не отличаются.
[04:07.400 --> 04:14.960]  Дело в том, что здесь причина в том, что это приватные поля. Вот приватные поля инициализировать
[04:14.960 --> 04:21.680]  таким способом нельзя. Это, я напомню, называется агрегатная инициализация. И если поля публичные
[04:21.680 --> 04:27.680]  были бы все. И структура, вот это называется plane. Ну, есть такое формальное определение.
[04:27.680 --> 04:41.520]  Plane. Plane old data что ли. Ну, короче, структура, в которой просто данные лежат какие-то,
[04:41.520 --> 04:46.440]  и можно напрямую к ним обращаться. Я не помню формальных определений этих всех,
[04:46.440 --> 04:52.480]  как и при каких условиях можно агрегатно инициализацию делать. Но если вкратце,
[04:52.480 --> 05:03.120]  то когда все поля публичные и нет каких-то непривиальных методов, нет всяких наследований
[05:03.120 --> 05:08.040]  непонятных виртуальных и прочего, тогда можно. Если это класс, то так его пронициализировать не
[05:08.040 --> 05:15.040]  получится. В смысле, с приватными полями как минимум. И нам нужно какой-то другой синтаксис для
[05:15.040 --> 05:22.080]  того, чтобы создавать объект класса от данных параметров. Вот, допустим, я хочу создать объект.
[05:22.080 --> 05:32.560]  Я хочу уметь создавать объекты этого класса с какими-то изначальными параметрами. Не просто
[05:32.560 --> 05:41.000]  по умолчанию, а с какими-то параметрами. Ну, типичный пример. Давайте я напишу класс
[05:41.000 --> 05:58.480]  комплексных чисел. Ну и у него будут приватные поля. Какие у него будут приватные поля?
[05:58.480 --> 06:09.280]  Вещественная часть, минимая часть. Вот, и я хочу научиться создавать объекты этого класса от
[06:09.280 --> 06:15.840]  разных параметров. Например, я могу хотеть создавать комплексные числа просто от одного дабла.
[06:15.840 --> 06:23.960]  Тогда вещественная часть должна быть равна этому даблу, а комплексная нуню. Вот. Могу хотеть
[06:23.960 --> 06:29.000]  создавать от двух даблов. Тогда, соответственно, будет вещественная и минимая часть. А могу по
[06:29.000 --> 06:38.320]  умолчанию. Тогда, чтобы все нуню стало равно. Вот. Такую вещь хочу сделать. Вот, чтобы объяснить
[06:38.320 --> 06:45.440]  компилятору, как должен создаваться объект класса от данных параметров, что должно происходить,
[06:45.440 --> 06:50.120]  как должны иницивизироваться поля и, возможно, что-то еще должно происходить. Когда вы объект
[06:50.120 --> 06:56.320]  класса пытаетесь иницивизировать такими-то параметрами, вот. Для этого используется
[06:56.320 --> 07:03.400]  конструктор. Конструктор — это специальный метод, смысл которого в том, что он описывает,
[07:03.400 --> 07:10.600]  как создается объект от данных параметров. Конструкторы. Это пишут следующим образом.
[07:10.600 --> 07:22.800]  Давайте, например, напишу, как мне создать объект класса комплекса от двух даблов. Я пишу
[07:22.800 --> 07:32.200]  прям внутри класса метод с названием, как у этого класса, комплекс. Если метод в классе называется
[07:32.200 --> 07:42.280]  в точности так же, так и сам класс, то этот метод является конструктором. Ну, я пока напишу
[07:42.280 --> 07:48.600]  его с плохим очень кодстайлом, потом постепенно я буду шаг за шагом делать лучше. Ну вот, я написал
[07:48.600 --> 07:53.600]  конструктор, и в этом теле конструктора я напоминаю, что это сейчас очень плохой кодстайл. Вот. Ну,
[07:53.600 --> 08:02.720]  я могу написать что? Я могу сказать, значит, что мой Re — это тот Re, который мне дали, и мой Im — это
[08:02.720 --> 08:11.720]  тот Im, который мне дали. Вот. Я объявил конструктор от двух параметров. Правда, он приватный, вот его
[08:11.720 --> 08:19.600]  надо сделать публичным. А теперь я могу из FunctionMain создавать комплекс от двух даблов, например,
[08:19.600 --> 08:34.160]  1.0, 2.0. Вот. Теперь у меня комплексы умеют создаваться от двух даблов. Ну, я могу вывести,
[08:34.160 --> 08:41.480]  в принципе, на экран поля, сделать их публичными, проверить, что он создался. Ну, может, мне поверить,
[08:41.480 --> 08:48.760]  все корректно. Вот. Неважно, поля были бы публичными или приватными. Вот. На самом деле,
[08:48.760 --> 08:57.480]  конструктор можно определять у структур, конечно, и даже если у них все поля публичные,
[08:57.480 --> 09:01.160]  тоже можно определить конструкторы. Вот. И если вы хоть один конструктор определили,
[09:01.160 --> 09:05.160]  то агрегатная идентилизация, по-моему, тоже перестанет работать. То есть, вот если я сейчас
[09:05.320 --> 09:17.720]  сделаю все поля публичными, то, по идее, должна работать агрегатная идентилизация. Ну, у меня же
[09:17.720 --> 09:23.080]  все поля публичные, все просто... Нет, агрегатная идентилизация все еще работает. То есть, у меня
[09:23.080 --> 09:31.440]  получается поля вот так идентилизируются, несмотря на то, что конструктор есть. Но если я вот так пишу,
[09:31.440 --> 09:50.080]  это значит, я вызываю свой конструктор. Так. Ну, хорошо. Как только я определил хотя бы один
[09:50.080 --> 10:03.720]  конструктор, у меня уже пропадает возможность создавать комплекс по умолчанию. Вот. Агрегатные,
[10:03.720 --> 10:07.840]  ну, фигурные скобочки не пропадают возможность использовать, но если есть хоть один конструктор,
[10:07.840 --> 10:14.040]  который я сам написал, то вот такое уже не будет работать. Сейчас будет CE. Почему так? Ну, потому
[10:14.040 --> 10:18.800]  что компилятор считает, что если вы сами решили определять способы создания вашего класса от
[10:18.800 --> 10:27.080]  параметров, то уже способ по умолчанию он не будет вам за вас создавать. Вот. Ну, значит, вот это
[10:27.080 --> 10:35.200]  ошибка компиляции. Можно, конечно, делать перегрузку конструкторов. То есть, написать несколько
[10:35.200 --> 10:42.160]  конструкторов от разных параметров. Например, вот будет конструктор, который принимает только один
[10:42.160 --> 10:53.480]  дабл. И будет он делать вот это. Вот. Теперь я могу создавать конструкторы, ой, создавать комплексные
[10:53.480 --> 11:06.400]  числа от одних только даблов. Да, но мне нужно здесь сказать, что им я проинцелизирую нулем. Вот. Теперь,
[11:06.400 --> 11:11.160]  если я создаюсь от одного числа, то это получается, что вещественная часть равна не этому числу,
[11:11.160 --> 11:25.960]  а мнимой нулю. Вот. Это была эта перегружка конструктора. Вот. Значит, люблю вареные яйца,
[11:25.960 --> 11:30.720]  спрашивают, обязательно ли писать здесь стрелочка Ре или можно просто писать Ре. Ну,
[11:30.720 --> 11:40.840]  здесь я пишу здесь стрелочка Ре, потому что у меня вот это имя локальное, оно запмевает поле.
[11:40.840 --> 11:49.480]  Если бы меня было, да, то есть, если бы параметр назывался иначе, то я бы мог без звезд к нему
[11:49.480 --> 11:53.080]  обращаться. Поэтому я говорю, что у меня плохой подстайл, я сейчас это поправлю, я сейчас скажу,
[11:53.080 --> 11:59.040]  как правильно писать. Вот. Чтобы таких коллизий не возникало, даже если у вас параметр запмевает
[11:59.040 --> 12:07.440]  поле. Вот. Это была перегрузка конструктора. Вот. Но я могу и конструктор без параметров
[12:07.440 --> 12:19.240]  захотеть определить сам, как я это буду делать. Ну, логично, что вот так. Вот. Ну, тут я могу написать,
[12:19.240 --> 12:29.880]  значит, вис стрелочка Ре равно нулю и вис стрелочки просто Ре равно нулю, им равно нулю. Но я могу
[12:29.880 --> 12:35.680]  сделать и проще. Я могу просто здесь по умолчанию проставить эти значения, и тогда мне не придется
[12:35.680 --> 12:41.340]  проставлять, чему они равны, в случае, когда я не написал, чему они равны. Вот. Если у меня здесь
[12:41.340 --> 12:45.880]  проставлено значение по умолчанию, то когда вызывается конструктор, они по умолчанию этим
[12:45.880 --> 12:51.680]  инициализируются. И дальше, если я что-то им присваиваю, то за значение заменяется на это. Вот.
[12:51.680 --> 12:55.560]  Но чтобы мне не писать присваивание нуля каждый раз каждому конструктору, я просто могу по
[12:55.560 --> 13:00.840]  умолчанию сделать его полям. Как бы считать, что если ничем не фринциализируем, то инициализирую
[13:00.840 --> 13:09.120]  этим. Вот. И вот теперь я снова смогу создавать комплекс без параметров. Впрочем, если я так
[13:09.120 --> 13:14.200]  напишу, это будет некорректно, потому что это с точки зрения синтаксиса объявление функции
[13:14.200 --> 13:19.360]  с возвращаемым типом комплекс именем C3 без параметров. Вот. Чтобы создать комплекс без параметров,
[13:19.360 --> 13:26.520]  надо просто вот так написать. Вот это я сейчас объявил. Комплекс без параметров. Если бы я вот
[13:26.520 --> 13:30.800]  этого не написал, то это была бы ошибка компиляции, я напоминаю, потому что после того, как вы хотя
[13:30.800 --> 13:37.800]  бы один свой конструктор определили, компилятор перестает за вас определять... компилятор перестает
[13:37.800 --> 13:43.320]  генерировать за вас конструктор без параметра. Вот этот конструктор, который называется... который
[13:43.320 --> 13:49.840]  без параметров, он называется default constructor. Ну, default constructor. Конструктор по умолчанию по-русски
[13:49.840 --> 13:59.920]  переводится. Вот. Конструктор по умолчанию, он, значит, это тот самый конструктор, который вызывается,
[13:59.920 --> 14:07.480]  когда вы вот так вот свой объект создаете. И он по умолчанию существует и без вас, если вы ничего
[14:07.480 --> 14:15.560]  не напишете, никаких конструкторов. Компилятор генерирует конструктор по умолчанию сам, даже
[14:15.680 --> 14:21.780]  если вы сами не объявили конструктор. Но если вы объявили конструкторы хоть какие-то, то конструктор
[14:21.780 --> 14:25.560]  по умолчанию будете добры тоже сами написать, потому что компилятор за вас там даже не будет ничего
[14:25.560 --> 14:31.200]  додумывать. Что делает конструктор по умолчанию, который генерирует компилятор? Он просто все
[14:31.200 --> 14:35.360]  поля нициализирует значениями по умолчанию. В частности, если поля это тоже объектically классов,
[14:35.360 --> 14:43.840]  то у них будут вызваны конструкторы по умолчанию. А... вопрос. Ад двигательная нициализация от 2 параметров
[14:43.840 --> 14:50.880]  как и раньше, или вызывает конструктор? Вот да, это хороший вопрос на самом деле, я и сам не знаю,
[14:50.880 --> 14:58.120]  давайте проверим, потому что вопрос на самом деле интересный. Давайте я вот так вот сделаю, чтобы
[14:58.120 --> 15:17.720]  проверить. Да, то есть смотрите, вот я сейчас создал комплекс от двух чисел и посмотрел,
[15:17.720 --> 15:24.920]  что создалось. Ну, конструктор у меня переставил местами поля, а если я фигурную скобкин напишу,
[15:24.920 --> 15:35.840]  знаете, мне кажется может, что и конструктор вызовется. Да, спасибо за вопрос, на самом деле да,
[15:35.840 --> 15:40.760]  когда у вас определен конструктор, все-таки это неправда, что агрегатная инициализация продолжает
[15:40.760 --> 15:45.960]  работать, даже если вы будете фигурную скобкин ставить, это будет конструктор вызываться. Да,
[15:45.960 --> 15:52.440]  вот так это работает на самом деле. То есть, когда вы определили конструктор, а уже агрегатной
[15:52.440 --> 15:57.040]  инициализации, вы пользоваться не можете. Ну, то есть вы можете фигурную скобкун инициализировать,
[15:57.040 --> 16:02.960]  но это будет все равно, как будто конструктор вызывается, и соответственно поля будут в обратном
[16:02.960 --> 16:12.480]  порядке. Ну, я проверил это. Вот, ну хорошо, вот у меня есть несколько конструкторов.
[16:22.440 --> 16:33.400]  Теперь поговорим вот о чем. Я вам сказал, что когда компилятор, ну, когда не написано,
[16:33.400 --> 16:40.000]  чем инициализировать ваши поля, они инициализированы значением по умолчанию. Но дело в том,
[16:40.000 --> 16:49.560]  что когда вы входите в тело конструктора, вот здесь, к этому моменту поля уже должны быть чем-то
[16:49.800 --> 16:56.500]  инициализированы. Вот. Перед входом в тело конструктора, поля уже должны быть
[16:56.500 --> 17:03.520]  инициализированы, потому что они входят в область видимости, ну, как бы, сейчас
[17:03.520 --> 17:07.680]  уже начатая область видимости, когда вы в тело конструктора войдете. А раз начатая область
[17:07.680 --> 17:11.760]  видимости, они должны быть как-то инициализированы. Они будут инициализированы рандомным
[17:11.760 --> 17:18.240]  значением, а можно быть чем-то, что вы написали. Если эти поля сами являются объектами, например string.
[17:18.240 --> 17:24.800]  то она тоже должна быть проницелизирована чем-то, то есть она должна быть создана,
[17:24.800 --> 17:30.000]  сам должен быть создан этот объект, потому что здесь вы уже имеете полное право к нему обращаться,
[17:30.000 --> 17:35.920]  что-нибудь у него спрашивать. Отсюда вывод. Когда вы заходите в тело конструктора,
[17:35.920 --> 17:41.760]  перед тем как вы заходите в тело конструктора, вызывают, что сначала конструкторы всех ваших
[17:41.760 --> 17:48.960]  полей, если это объекты, а если это обычные переменные, то происходит их вентилизация чем написано.
[17:48.960 --> 17:55.680]  А дальше, когда вы уже в теле конструктора вот этим вот занимаетесь, вы на самом деле делаете
[17:55.680 --> 18:01.840]  присваивание. То есть вы не создаете изначально поле с таким параметром, а вы присваиваете ему
[18:01.840 --> 18:09.000]  новое значение. Так я вдруг понял, что я говорю в микрофон, который у меня болтается с другого
[18:09.000 --> 18:16.920]  уха, а теперь меня наверное стало громче слышно гораздо, да? Ага, ну тогда я сейчас убавлю громкость
[18:16.920 --> 18:35.640]  микрофона и будет как раньше. А вот так нормально? Все, хорошо. Так вот, возвращаясь к конструкторам.
[18:35.640 --> 18:50.480]  Вот когда я в теле конструктора что-то присваиваю... А, вот оно что. Все, понятно. Ну хорошо. А изначально
[18:50.480 --> 18:59.560]  перед тем, как я уже в тело конструктора, поля уже проенциализированы, а если они сами объекты,
[18:59.560 --> 19:04.360]  вызывают все их конструкторы до этого. И когда я из тела конструктора начинаю делать присваивание,
[19:04.360 --> 19:10.800]  я на самом деле делаю лишнее действие. То есть я бы мог сразу... Ну, я вообще-то хочу сразу,
[19:10.800 --> 19:16.640]  чтобы мое поле вот это вот было проенциализировано нужным мне значением. А то, что я сейчас делаю,
[19:16.640 --> 19:22.440]  это примерно следующее. Я сначала инициализирую его нулем, а потом присваиваю ему новое значение.
[19:22.440 --> 19:28.520]  Ну, в случае дабла это пофигу, к тому же компилятор скорее всего соптимизирует. Если там какой-нибудь
[19:28.520 --> 19:34.600]  класс в качестве поля, ну какой-нибудь объект в качестве поля лежит, например, вектор, и у него
[19:34.600 --> 19:41.840]  создание вектора по умолчанию это не тривиальная какая-то операция, то на самом деле, когда вы
[19:41.840 --> 19:48.240]  будете поля вот так вот присваивать в теле уже конструктора, это неэффективно. Эффективнее
[19:48.240 --> 19:53.040]  сразу проенциализировать поля, чем надо, перед тем, как в тело войти. Вот для этого существуют
[19:53.040 --> 19:58.480]  так называемые списки инициализации. Вот, не путайте их с другими списками инициализации,
[19:58.480 --> 20:06.560]  которые в C++11 появились. Значит, к сожалению, есть некоторая амонемия в терминологии. Есть
[20:06.560 --> 20:18.000]  списки инициализации конструкторов. Да, они называются constructor initializer lists. Короче,
[20:18.000 --> 20:22.400]  ну списки инициализации в конструкторах. А есть еще так называемые brace and close initializer
[20:22.400 --> 20:29.640]  lists. Это другие initializer lists. Не путайте с ними, про них я скажу попозже. Как пишутся списки
[20:29.640 --> 20:35.600]  инициализации в конструкторах? Вот так я пишу. Вот здесь я пишу имя своего поля, а здесь, чем его
[20:35.600 --> 20:45.680]  проенциализировать. И теперь мне вот это можно убрать. То есть, смотрите, я написал, а после
[20:45.680 --> 20:50.600]  закрывающей круглоскопки я пишу двоеточие, если это конструктор, и дальше идет список инициализации.
[20:50.600 --> 20:56.400]  В списке инициализации я перечисляю, какое поле, чем проенциализировать, прежде чем в тело
[20:56.400 --> 21:01.560]  конструктора войти. И вот здесь мне уже не нужно писать list.re, потому что здесь однозначно партится
[21:01.560 --> 21:10.520]  эта конструкция. Вот это re берется из полей, а вот это re берется уже из параметров. А если
[21:10.520 --> 21:18.720]  цикл появится при вызове конструктора? Если цикл появится при вызове... Вы так не сделаете.
[21:18.720 --> 21:31.320]  Вы не сможете добиться такого. Не, ну если, например, у нас у класса А есть поле объектов класса
[21:31.320 --> 21:41.200]  В и наоборот. Вы не можете создавать... Вам нужно чтобы класс использовать как поле в другом классе,
[21:41.200 --> 21:47.200]  не только объявить, но и определить класс до этого. Вот, и поэтому так сделать просто не получится.
[21:47.200 --> 21:59.200]  А, то есть тут как с функциями уже нельзя, да? Нет, нельзя. Ну, вы можете... Вот что сделать. Вы
[21:59.200 --> 22:06.880]  можете... Ну, давайте немножечко про это расскажу. Есть такое понятие не полный тип, incomplete type.
[22:06.880 --> 22:17.280]  Ну, значит, такое формальное понятие. К нему относятся типы классов... Ну, это тип void,
[22:17.280 --> 22:26.280]  а еще там некоторые типы, и тип класса, который объявлен, но не определен. Вот, да, указатели
[22:26.280 --> 22:31.360]  друг на друга могут быть, но вот как поле, один класс внутри другого, а другой внутри первого,
[22:31.360 --> 22:35.680]  вы просто физически не сможете добиться, потому что если вы объявляете какой-то класс,
[22:35.680 --> 22:41.920]  то чтобы его использовать как поле в другом классе, вы должны его определить. Вот,
[22:41.920 --> 22:53.200]  если я попробую вот так сделать... Сейчас у меня будет CE со словами field has incomplete type. Нельзя
[22:53.200 --> 23:00.000]  объявлять переменные неполных типов, то есть таких типов, которые еще не определено, что за тип.
[23:00.000 --> 23:05.640]  По этой причине такая конструкция не выйдет. Но указатель на A вы можете объявить, это правда.
[23:05.640 --> 23:11.760]  Вот, чтобы объявить указатель или ссылку на A, вам не нужно определение класса A иметь выше себя.
[23:11.760 --> 23:20.600]  Вот. Это, кстати, довольно, да, интересный феномен, но мы с таким еще, я думаю, столкнемся. Вот,
[23:20.600 --> 23:27.000]  чтобы объявить указатель на A, вам нужно только лишь объявление класса A выше иметь, а чтобы
[23:27.000 --> 23:42.280]  сам объект A, вам нужно и определение иметь уже. Вот. Вынужденная мера. Какая вынужденная мера?
[23:42.280 --> 23:55.720]  Не понимаю. В смысле, что указатели можно друг на друга объявлять? Ну да, это... Ну как,
[23:56.040 --> 24:03.280]  указатели разрешено делать. Вот. А вот так... Ну, в общем, ладно, давайте дальше. Так вот,
[24:03.280 --> 24:11.560]  списки инициализации. И здесь уже не возникает конфликта имен. Точно так же здесь я пишу
[24:11.560 --> 24:18.120]  ре-ре и не пишу, чем пронициализировать им. Я не написал, чем пронициализировать, это значит,
[24:18.960 --> 24:26.280]  пронициализируется. Вот. Если у меня поля это сами по себе какие-то объекты, то здесь в скобочках
[24:26.280 --> 24:35.600]  я просто им передаю параметры их конструкторов. Вот. И есть еще такой момент. Тонкий. Вот. Если
[24:35.600 --> 24:46.560]  я здесь попробую в другом порядке перечислить, то будет warning. Нет, не будет warning.
[24:46.560 --> 25:00.000]  Вот теперь будет. Значит, warning со словами «такое-то поле will be initialized after – w reorder».
[25:00.000 --> 25:08.320]  Вот. В чем прикол? Дело в том, что поля всегда инициализируются всегда в том порядке,
[25:08.320 --> 25:12.880]  в каком они объявлены, а не в том, в каком вы их перечисли в конструкторе или в инициализаторах.
[25:12.880 --> 25:17.120]  Вот. И когда вы в списке инициализации перечисляете поля в неправильном порядке,
[25:17.120 --> 25:24.640]  вы тем самым самого себя обманываете на самом деле. Вы пишете «так», но на самом деле сначала
[25:24.640 --> 25:31.560]  будет ре-пронициализировано, потом им. Если у вас инициализация одних полей зависит от других,
[25:31.560 --> 25:38.080]  это может привести к проблеме. То есть вам, может быть, обязательно нужно сначала пронициализировать
[25:38.080 --> 25:44.320]  одно поле, чтобы потом результатом каким-то его инициализации пронициализировать другое. И вот
[25:44.320 --> 25:49.480]  если у вас поля в неправильном порядке перечислены, вы этого не сможете добиться. Вам нужно объявлять
[25:49.480 --> 25:55.120]  поля в правильном порядке, а списк инициализации нужно писать в порядке согласованном с порядком
[25:55.120 --> 26:01.040]  объявления полей. Вот компилятор выдает такой warning, потому что, ну, это может вести в заблуждение,
[26:01.040 --> 26:05.120]  когда вы в списке инициализации перечисляете не в том порядке, в каком нереально будут
[26:05.120 --> 26:15.200]  пронициализированы. Вот. Соответственно, вот в этой ситуации компилятор, ну, сначала будет
[26:15.200 --> 26:24.080]  пронициализировано тем, что вы дали, потом им будет пронициализировано нулем. Использовать
[26:24.080 --> 26:29.560]  списки инициализации настоятельно рекомендуется. Если вы будете присваивать, значит, это одна из
[26:29.560 --> 26:34.120]  самых частых ошибок на review, за которую просто мы всех хейтим, и я буду вас сильно хейтить,
[26:34.120 --> 26:40.240]  и проверяющие вас будут сильно хейтить. Вот, когда вы будете писать свою первую задачу, да и вторую, да и все
[26:40.240 --> 26:44.960]  остальные, вот, мы будем хейтить вас вплоть до самого конца года. В конце года, если вы до сих пор так
[26:44.960 --> 26:51.800]  будете писать, вы можете сильно хейтить. Так, у нас Zoom бесплатный, поэтому нам придется через 10 минут
[26:51.800 --> 26:58.640]  выходить и новую встречу создавать. Значит, обязательно используйте списки инициализации,
[26:58.640 --> 27:05.080]  а не присваивайте полям значения в телеконструкторе. Это и по код-стайлу правильнее, и эффективнее,
[27:05.080 --> 27:17.400]  и еще и безопаснее в некоторых ситуациях. Вот, хорошо. Еще один пример разберу. Вот, смотрите,
[27:17.400 --> 27:28.240]  допустим, у меня класс, в котором есть в полях ссылка или константа. Ну вот, я не буду тут
[27:28.240 --> 27:34.680]  выдумывать. Вот такой класс я заведу. Ну, не класс, а структуру, чтобы не возиться с приватностью.
[27:34.680 --> 27:41.640]  В чем особенность ссылок и константов? В том, что их обязательно нужно пронициализировать при
[27:41.640 --> 27:49.640]  создании. Вот. Вот я объявил класс с такими полями, ну и все пока хорошо, но если я попытаюсь создать
[27:49.640 --> 27:56.200]  объект такого класса, то будет CE, потому что компилятор не в состоянии сгенерировать для него
[27:56.200 --> 28:03.080]  конструктор по умолчанию. Конструктор по умолчанию может быть сгенерирован компилятором автоматически
[28:03.080 --> 28:06.960]  только для тех классов, для которых понятно, что из себя представляют инициализации по умолчанию
[28:06.960 --> 28:14.400]  для каждого поля. Но если там в полях какие-то типы, которые не допускают сами свое конструирование
[28:14.400 --> 28:19.200]  по умолчанию или ссылки или константы, которым обязательно нужно что-то при создании сразу
[28:19.200 --> 28:25.760]  присвоить, ну типа пронициализировать, то это будет еще компиляция. Вот. И я, конечно, могу
[28:25.760 --> 28:34.120]  написать здесь по умолчанию что-то, и это будет работать. Но что, если я конструктор для такого
[28:34.120 --> 28:38.800]  класса определяю? Вот я, допустим, говорю, вот я определяю конструктор, и мне дали, значит,
[28:38.800 --> 28:47.520]  ссылку на Y и какой-то другой double. И мне надо ссылку мою на X пронициализировать этим Y,
[28:47.520 --> 28:55.960]  а мой D пронициализировать этим DD. Вот здесь просто физически не получится вот так написать.
[28:55.960 --> 29:02.880]  То есть присваивание полям просто не сработает. В случае со ссылкой оно скомпилируется,
[29:02.880 --> 29:13.920]  но будет делать не то. Что такое присваивание полям? Допустим, у меня здесь бы был какой-то
[29:13.920 --> 29:21.920]  глобальный R, и по умолчанию бы вот эта X указывала на R. Тогда что бы произошло,
[29:21.920 --> 29:28.200]  когда я так написал? Ну, здесь произошло следующее. У меня X пронициализировался бы R,
[29:28.200 --> 29:33.400]  и теперь X — это то же самое, что R. И когда я так пишу, я R присваиваю Y, а вовсе не
[29:33.400 --> 29:43.080]  инициализирую поле X с ссылкой на Y. Вот. И поэтому здесь существенно и очень принципиально,
[29:43.080 --> 29:47.800]  чтобы было написано именно так. Вот написать вот так — это совсем другое. Это означает,
[29:47.800 --> 29:54.240]  что вот это будет проигнорировано, а X будет сразу проинциализирован Y. Вот. А это просто
[29:54.240 --> 29:59.760]  не скомпилируется, потому что в константе по-прежнему ничего не присвоено. Ну, если я
[29:59.760 --> 30:06.560]  здесь напишу вот так, допустим, то ошибка компиляции из-за того, что не пронициализировано, исчезнет,
[30:06.560 --> 30:11.000]  но присваивание все равно делать нельзя константе. Поэтому для константа тоже принципиально,
[30:11.000 --> 30:17.520]  чтобы вы использовали именно списки инициализации, а не присваивание полям делали. Вот это пример класса,
[30:17.520 --> 30:21.480]  которому необходимы списки инициализации. Без них он просто работать не будет.
[30:21.480 --> 30:32.040]  Списк инициализации в конструкторах. Да, у меня все еще ошибка компиляции,
[30:32.040 --> 30:39.000]  потому что нет конструктора по умолчанию для такого класса. Ну и боксинг. Вот. Ну хорошо.
[30:39.000 --> 30:53.360]  Еще одна ситуация интересная, про которую хочу рассказать. Вот какая. Представьте,
[30:53.360 --> 31:11.600]  что у вас в полях есть константная ссылка. И здесь вы говорите. Ну, вы, я надеюсь,
[31:11.600 --> 31:16.400]  помните, что константные ссылки можно инициализировать R-value значениями. Вот.
[31:16.400 --> 31:30.800]  И допустим, я решил эту константную ссылку проинциализировать R-value значениям. Да,
[31:30.800 --> 31:45.280]  то есть что я написал? Я написал конструктор по умолчанию инициализирует x0 и double, чем написано
[31:45.280 --> 31:50.800]  там. Вот вопрос. Дальше, в дальнейшем, использовать этот x это корректно или нет? То есть,
[31:50.800 --> 32:03.760]  нормальный ли это код? Вот. Ответ нет. Это будет ube, хотя компилятор мне об этом и не сообщает.
[32:03.760 --> 32:12.800]  А, нет. Сообщает. Вот смотрите. Видите, я добавил minus и extra. И компилятор мне таки сообщил этот
[32:12.800 --> 32:24.760]  warning, что временная связь сx поддерживается только пока конструктор выполняется. То есть,
[32:24.760 --> 32:33.080]  вот это вот временное значение 0, оно не считается, ну, его время жизни заканчивается,
[32:33.080 --> 32:42.080]  когда заканчивается код конструктора, а не все время, что существует x. Ну, чтобы это было
[32:42.080 --> 32:49.960]  понятнее, проще, наверное, STD-стринги объяснить. Вот у меня, значит, вот если я вот так напишу,
[32:49.960 --> 33:01.160]  то потом из какого-нибудь метода s обращаться к x, это будет ube, потому что временная строка,
[33:01.160 --> 33:12.760]  к которой привязывается вот эта константная ссылка, она не живет до конца жизни объекта
[33:12.760 --> 33:31.080]  класса. Она живет лишь до конца выполнения вот этого тела конструктора. Вот. Не x,
[33:31.880 --> 33:38.280]  вот until the constructor exits. То есть, пока мы, когда мы выйдем из конструктора, эта временная
[33:38.280 --> 33:43.560]  связь уничтожится. Константные ссылки продлевают жизнь объектам, которым они привязаны и временным,
[33:43.560 --> 33:50.560]  но только в случае, если это локальные переменные, если это поля классов, то это не сработает и будет
[33:50.560 --> 34:00.080]  ube. Поэтому аккуратнее со ссылками полями класса, в качестве полей класса. Так, у нас еще...
[34:07.080 --> 34:11.880]  А, тут еще кто-то вопрос задал, я не заметил. Агрегатная интеллизация будет работать при
[34:11.880 --> 34:14.560]  отсутствии значений по умолчанию? Будет, конечно. Почему нет?
[34:14.560 --> 34:25.880]  А, про ссылки и константы не помню. Вероятно, нет. Вот, вероятно, со ссылками и константами
[34:25.880 --> 34:31.400]  агрегатная интеллизация не работает. Но я не уверен. Попробуйте. Не хочу тратить время тестировать
[34:31.400 --> 34:38.080]  это. Ну, вообще, это плохой код-стайл, довольно так писать. То есть, так, ну, не надо так делать.
[34:38.080 --> 34:42.000]  Класс со ссылками и константами, это не такой класс, который обычно агрегатная интеллизация
[34:42.000 --> 34:46.520]  и интеллизирует. Если там что-то такое в полях, то, скорее всего, нужно конструктор полноценный писать.
[34:46.520 --> 34:58.960]  Вот. Так, ну ладно, такие у нас... Ну ладно, давайте все-таки продолжать пока. Выкинет,
[34:58.960 --> 35:26.000]  так выкинет. Значит, дальше... Дальше вот что. Ну вот, как вы могли заметить, все вот эти конструкторы,
[35:26.000 --> 35:31.480]  которые до сих пор написал, они пустое тело имеют на самом деле. То есть, по сути, все, что делают
[35:31.480 --> 35:38.560]  конструкторы, это поля инициализируют меня. Вот. А тело конструктора тогда зачем? То есть, что такое
[35:38.560 --> 35:48.560]  в теле конструктора может происходить, что мне надо, я не знаю, значит, какой-то нетривиальный код
[35:48.560 --> 35:55.120]  писать конструкторами. Вот. Что это может быть такое? Вот. Сейчас мы разберем пример класса,
[35:55.120 --> 35:59.280]  в котором конструктор выполняет какие-то содержательные действия, а не просто служит
[35:59.280 --> 36:05.400]  для инициализации полей. И пример такого класса, это, конечно же, вектор, ну или стринг. Это, по сути,
[36:05.400 --> 36:12.720]  очень близкие по смыслу вещи. Вот. Как выглядит класс... Ну, давайте я буду на примере класса стринг
[36:12.720 --> 36:18.240]  показывать. Вот. Как выглядит класс стринг, который вам, кстати, предстоит писать скоро. Вот. Прямо
[36:18.240 --> 36:27.120]  уже на этой неделе. Прям, вот, возможно, даже сегодня или завтра задача появится. Значит,
[36:27.120 --> 36:38.280]  там есть поля. Какие там поля? Там указатель на вот этот массив символов, а также два числа.
[36:38.280 --> 36:57.240]  Размер, как мы уже обсуждали, и capacity. Так, давайте двигаться вперед, потому что мы в прошлый раз
[36:57.240 --> 37:09.120]  не закончили говорить о конструкторах, на самом деле, даже. Вот. И сегодня надо уж точно закончить.
[37:09.120 --> 37:18.200]  Значит, ну я почти все рассказал. И закончили мы на том, что есть, значит, слова default и delete,
[37:18.200 --> 37:25.600]  насколько я помню. Про них я тоже все, что хотел, сказал. Вот. Осталось две вещи, которые я не сказал
[37:25.600 --> 37:31.320]  в этом пункте. Первый пункт, значит, первая из этих двух вещей, это так называемые initializer
[37:31.320 --> 37:40.600]  листы. Я вам говорил, что есть списки инициализации, так называемые, member initializer lists. Вот они. Но
[37:40.600 --> 37:48.400]  это другое. А есть еще, скажем так, амонемичный термин initializer листы C++, он появился,
[37:48.400 --> 37:57.160]  начиная с C++11. Это когда вы делаете конструктор от чего-то, списка чего-то в фигурных скобках.
[37:57.160 --> 38:04.040]  Ну, например, когда вы говорите vector int v равно, а дальше пишете 1, 2, 3, 4, 5, то как это работает?
[38:04.040 --> 38:13.880]  Это же, ну это что такое? Это конструктор от чего по-вашему здесь вызывается? Вот это и есть так
[38:13.880 --> 38:22.600]  называемые initializer lists. То есть, начиная с C++11, классы можно создавать от списков каких-то
[38:22.600 --> 38:29.320]  штук в фигурных скобочках. Вот. И это вносит дополнительную путаницу, потому что еще есть
[38:29.320 --> 38:34.160]  агрегатная инициализация, как вы помните, в фигурных скобочках. Вот. Но фигурные скобочки
[38:34.160 --> 38:39.680]  могут означать не обязательно агрегатную инициализацию. Да, ну, во-первых, как мы с вами уже выяснили,
[38:39.680 --> 38:44.240]  если у вас есть свой собственный конструктор, и вы фигурные скобочки пишете, то все равно вызывается
[38:44.240 --> 38:52.160]  он, а не происходит агрегатная инициализация. А хуже того, еще может быть специальный конструктор
[38:52.160 --> 38:58.160]  от initializer-листа, и тогда, если вы напишете фигурные скобочки, он будет пытаться вызвать его
[38:58.160 --> 39:08.120]  обязательно. Ну, давайте, например, я реализую конструктор. Ну, я не знаю, на примере чего тут
[39:08.120 --> 39:15.400]  можно реализовать этот конструктор. Ну, на примере строки это довольно странно. Ну, давайте
[39:15.400 --> 39:21.640]  на примере строки покажу. Представим, что я хочу строку уметь создавать от списка
[39:21.640 --> 39:30.840]  символов фигурных скобочков. Ну, в принципе, вполне допустимое желание. Я могу захотеть
[39:30.840 --> 39:39.200]  написать вот так, то есть свою строку, уметь создавать следующим образом. String s от... ну,
[39:39.200 --> 39:58.680]  либо я так пишу, либо я пишу равно, а дальше пишу там a, b, c, d, e. Вот. Как тогда это будет выглядеть?
[39:58.680 --> 40:13.480]  Значит, принимаемый тип должен быть std initializer-лист. От чего? От char. Давайте я назову его lst.
[40:13.480 --> 40:25.440]  И, соответственно, что я могу с initializer-листом делать? Ну, initializer-лист, он чем-то похож на...
[40:25.440 --> 40:44.120]  на вектор по своему функционалу. А именно у него можно спрашивать, ну, как бы указатель на начало,
[40:44.120 --> 40:53.240]  указатель на конец. Вот. Размер. Вот. Но обращаться с квадратными скобочками, по-моему, нельзя. Вот.
[40:53.240 --> 40:58.840]  Но это нам и не понадобится, на самом деле, потому что есть же range-based for. Ну, смотрите,
[40:58.840 --> 41:07.080]  как это можно было бы сделать. То есть, я сначала хочу выделить, сколько мне надо памяти. Сколько...
[41:07.080 --> 41:13.840]  как мне узнать, сколько мне надо? Ну, lst.size я могу спросить. Это сколько в нем элементов?
[41:13.840 --> 41:30.400]  Сейчас я вас на всякий случай проверю, что не обманываю, что все правильно. Что size...
[41:30.400 --> 41:34.400]  А почему просто вектором его было не сделать?
[41:34.400 --> 41:38.080]  Вот. Почему вектором не сделать? Ну, потому что вектор сам по себе,
[41:38.080 --> 41:43.840]  он динамическую память выделяет. А Neuralizer List — это как бы такая встроенная в язык штука.
[41:43.840 --> 41:51.480]  То есть, на самом деле, все эти A, B, C, D, E — они нигде ни в какой памяти не выделяют. Они, ну,
[41:51.480 --> 41:58.080]  как бы на стэке, может быть, выделяются, но точно не в динамической памяти. То есть Neuralizer List — это
[41:58.080 --> 42:05.120]  такой очень хитрый тип. Это как бы не... это не контейнер. Это нечто такое, что реализовать самим
[42:05.120 --> 42:10.080]  не получится, скорее всего. То есть, это какая-то штука, которую компилятор как-то реализовывает
[42:10.080 --> 42:16.320]  внутри себя очень хитрым образом, так что на самом деле никакой динамической памяти не выделяется.
[42:16.320 --> 42:23.440]  Ну, то есть, оно вот как бы хранится вот у него где-то там, прям вот, не знаю, в недрах. Я не знаю,
[42:23.440 --> 42:29.360]  на самом деле, как компилятор хранит Neuralizer List. Можно погуглить, наверное, покопаться в этом.
[42:29.360 --> 42:36.880]  Но вот я глупо не разбирался. Но смысл в том, что это всё не занимает выделение никакой памяти в
[42:36.880 --> 42:41.400]  runtime, не создается никакой полноценный объект, чтобы там из него что-то доставать. Никакого
[42:41.400 --> 42:46.440]  конструктора там специального не вызывается. Просто это вот такая как бы обёрточка, что по факту
[42:46.440 --> 42:54.040]  у вас есть пять этих самых чаров. Вот. А оно так обёрнуто, как будто это вот типа контейнер, хотя на
[42:54.040 --> 42:59.920]  самом деле никого контейнера не создалось. Вот. Чтобы можно было в фигурных скобках писать.
[42:59.920 --> 43:07.800]  Вот. И, соответственно, когда я спрашиваю у него size, компилятор как-то это внутри реализовывает
[43:07.800 --> 43:14.120]  сам, что вот он отвечает, сколько их было штук в этом списке. Вот. Причём это всё известно в
[43:14.120 --> 43:20.720]  Compile Time это число. То есть, size – это число, которое Neuralizer List понятно ещё в момент
[43:20.720 --> 43:41.600]  компиляции. Вот. Соответственно, я нитилизирую массив таким образом. Вот. Ну, значит, СЗ, ну то
[43:41.600 --> 43:46.440]  же самое я делаю. Значит, да, кстати, вот смотрите, у меня какая ситуация возникла. Я вот начинаю
[43:46.440 --> 43:51.960]  писать список инициализации, который не Neuralizer List, а Member Neuralizer List. У меня слишком
[43:51.960 --> 43:59.480]  длинная строка кода получается. Как мне правильно перенос сделать? А вот как. Я возьму и перенесу на
[43:59.480 --> 44:09.920]  следующую строку с двойным отступом. Вот. Есть такое правило CodeStyle, удобное на мой взгляд,
[44:09.920 --> 44:15.000]  и я вас буду просить его придерживаться. Когда вы хотите перенести что-то на другую строку,
[44:15.000 --> 44:18.840]  потому что у вас не влезает длинная строка, то вы делаете двойной отступ и потом продолжаете
[44:18.840 --> 44:25.480]  сединарным отступом. Таким образом не путается продолжение кода с продолжением вашей строки.
[44:25.480 --> 44:32.440]  Вот. А ещё есть хитрость. Когда вы так пишете, вы запятую оставляете в начале следующей строки,
[44:32.440 --> 44:38.120]  а не в конце предыдущей. Это и удобно читаемость даёт, и удобство добавлять новые элементы в это
[44:38.120 --> 44:46.920]  перечисление. Вот. Значит, CZ я тоже инициализирую вот этим, и Capacity я тоже инициализирую вот этим
[44:46.920 --> 44:55.760]  же. Всё. После этого фигурная скобка открывается, и тут я пишу код конструктора. Ну, фигурную скобку
[44:55.760 --> 45:05.560]  я вот здесь уже открою, чтобы она видна была. Вот. Если строка слишком длинная, то её надо
[45:05.560 --> 45:11.200]  переносить. Не лучше, а надо. По код стайлу обычно там, ну, кто какие требования устанавливает,
[45:11.200 --> 45:17.600]  кто 80, но это слишком жёстко. Ну, обычно там 100 символов ограничений на длину строки такое. Ну,
[45:17.600 --> 45:24.200]  100, может быть 120, но 120 многовато. Вот у меня здесь стоит, кажется, 80. Да, вот эта черта.
[45:24.200 --> 45:30.120]  Вертикальная полоска в селайне это 100-160 или сколько? 160 многовато. Ну, обычно 100,
[45:30.120 --> 45:34.800]  мне кажется, разумно. Ну, или 120. 100-120. Короче, на код review будем разворачивать,
[45:34.800 --> 45:44.240]  если у вас супер длинные строки. Селайне по умолчанию 120. Ну, вот, значит, 120 считайте и надо. Вот.
[45:44.240 --> 45:50.040]  Ну, докладно. Хорошо, я вот это проинициализировал, а теперь что я делаю? А теперь я просто, ну, я могу,
[45:50.040 --> 46:01.280]  как бы, сказать for. Ну, у меня есть, у листа есть begin и end. Ну, то есть, это как контейнер. Если вы
[46:01.280 --> 46:04.840]  умеете итераторами пользоваться, я забегаю вперед, да, вы знаете, что у контейнера можно
[46:04.840 --> 46:09.560]  вызвать begin и end, и это будет как бы указатели на начало и на конец. Ну, не указатели, а итератор,
[46:09.560 --> 46:13.480]  на самом деле. Их можно разыменовывать под ним и брать элементы, их можно инкрементировать.
[46:13.480 --> 46:21.200]  Ну, можно писать и так. Можно писать range-based-for так называемый. Вы, возможно, тоже им умеете
[46:21.200 --> 46:25.400]  пользоваться, хотя я вам про for не рассказывал. Range-based-for, он как работает? Он для всех контейнеров
[46:25.400 --> 46:34.880]  работает. Я говорю for элемент, где в контейнере, ну, длиннейшая лазер листов тоже работает. Да, и что я
[46:34.880 --> 46:44.440]  делаю? Типа, ну, мне тут надо, правда, завести счетчик, там, неприятность. То есть, я буду заполнять,
[46:44.440 --> 46:52.960]  как бы, значит, вот этот вот R по индексу E++ равно C. Вот типа такая у меня будет конструкция.
[46:52.960 --> 47:03.920]  Да, ну, вот я заполнил, в общем-то, строкулу элементами этого листа. Но можно было сделать
[47:03.920 --> 47:13.160]  еще лучше. Можно было использовать алгоритм std-copy. У вас же есть такой алгоритм, который берет
[47:13.160 --> 47:24.080]  сначала куда, по-моему, потом откуда, значит, я куда, я начало и конец диапазона ему передаю,
[47:24.080 --> 47:33.280]  потом откуда, а откуда это я передаю вот начало этого диапазона. И что происходит? У меня, значит,
[47:34.280 --> 47:41.840]  элементы второго диапазона копируются в первый диапазон по элементам.
[47:41.840 --> 47:57.640]  Работает эффективно и универсально. Нет, я все-таки перепутал. Надо написать сначала откуда, потом куда.
[47:57.640 --> 48:09.040]  Значит, вот начало конец диапазона, а это начало диапазона куда копировать. Соответственно,
[48:09.040 --> 48:14.240]  он по элементам скопирует все значения из диапазона вот в другой диапазон. Ну,
[48:14.240 --> 48:16.720]  это указатель, как бы, на начало второго диапазона.
[48:16.720 --> 48:28.880]  А еще вопрос. Вот это двоеточие после… Ну, стринг, скобочки, после него двоеточие.
[48:28.880 --> 48:44.120]  Она под код style должна быть типа вплотную, да? Еще раз я прослушал, что вплотную. После вот стринг,
[48:44.120 --> 48:52.040]  скобочки, после него двоеточие, дальше лист. Да, по нашему код style оно должно быть вплотную или
[48:52.040 --> 48:56.760]  через пробел. Мы не ставим пробел. Вот как я пишу, так и надо. Мы не ставим пробел между открывающей
[48:56.760 --> 49:03.920]  скобкой и содержимым. Сработает ли здесь Memcpi? Меня в чате кто-то спрашивает. Я не знаю. По-моему,
[49:03.920 --> 49:12.040]  я не уверен, короче. Я не знаю, как хранится внутри initializer-лист. Кажется, что не должен,
[49:12.040 --> 49:18.520]  потому что динамическая память… Ты делаешь там никакой динамической памяти? Нет. Какой динамической
[49:18.520 --> 49:26.280]  памяти? В смысле? Memcpi с динамической памятью работает. В смысле? Memcpi вообще без разницы,
[49:26.280 --> 49:30.640]  какая там память. Он просто принимает пару указателей и еще указателей, копирует диапазоны
[49:30.640 --> 49:35.480]  из одного в другой. Точно так же. Просто Memcpi надо, чтобы элементы подряд в памяти лежали. Он
[49:35.480 --> 49:40.600]  как бы блок памяти копирует. Какая-то память ему совершенно без разницы. Он чисто с указателями
[49:40.600 --> 49:53.680]  работает. Вот. Это что касается initializer-листов. Тут есть разные интересные нюансы, связанные
[49:53.680 --> 50:05.560]  с этими initializer-листами. Например, когда у вас появились initializer-листы, у вас начинают
[50:05.640 --> 50:24.160]  возникать вопросы такого характера. Вот, допустим, вы говорите, вот вы решили создать вектор 10.1. Что
[50:24.160 --> 50:31.240]  это такое? Как вы думаете? Если бы я так написал, понятно, что это значит. Это я решил вызвать
[50:31.240 --> 50:40.400]  конструктор вектора с двумя параметрами 10n равно 10 и значение 1. А если я написал фигурные скобки,
[50:40.400 --> 50:45.760]  что это будет означать? Ну вот правило таковы, что initializer-лист приоритетнее, чем обычный
[50:45.760 --> 50:49.400]  конструктор. То есть, если у вас конструктор initializer-листа, то предпочитается по правилам
[50:49.400 --> 50:55.400]  перегрузки on. То есть, если вы решите вот такой вектор создать, то у вас получится вектор из двух
[50:55.400 --> 51:07.280]  int, первый из которых равен 10, а второй 1. Еще веселее, это работает вот когда. Вот представьте,
[51:07.280 --> 51:15.480]  что вы создали такой вектор, у вас есть, значит, вектор из 10 int, каждый из которых равен 1. А потом
[51:15.480 --> 51:23.000]  вы решили создать еще один вектор. Ну, вектор, как, впрочем, из строку, можно создавать тоже из
[51:23.000 --> 51:34.600]  диапазона. То есть, вы можете написать начало и конец диапазона, и он скопирует все элементы в
[51:34.600 --> 51:38.000]  этом диапазоне. То есть, сейчас я, по сути, создал второй вектор копию исходного вектора.
[51:38.000 --> 51:50.880]  Но если бы я написал здесь фигурные скобки, то это получился бы вектор не int of. Это бы получился
[51:50.880 --> 51:55.280]  вектор из двух элементов, но это было бы CE, потому что здесь вектор int написан. На самом деле,
[51:55.280 --> 52:01.720]  я вектор не из int of создал. Это был бы вектор из двух элементов, являющихся итераторами на другой
[52:01.720 --> 52:07.480]  вектор. Первый из которых это тот begin, а второй это тот end. Если бы здесь не написал тип, то это
[52:07.480 --> 52:15.760]  оказался бы вектор из двух элементов вот с такими значениями. Короче, initializer листы добавили
[52:15.760 --> 52:40.000]  много путаницы. Начиная с C++20. История такая. Начиная с C++11 все... Было модно использовать
[52:40.000 --> 52:44.400]  фигурные скобки при инициализации, потому что все говорили, смотрите, это initializer листы,
[52:44.400 --> 52:51.360]  это новомодно, круто. Они у вас будут вызывать нужный вам конструктор, если вам хочется конструктор.
[52:51.360 --> 52:56.600]  А если есть initializer лист, то вызовут initializer лист. Пишите всегда фигурные скобки вместо круглых,
[52:56.600 --> 53:09.240]  будет вам счастье. Но в C++17 там следующее произошло. Начиная с C++17 ввели автоматический вывод
[53:09.240 --> 53:16.280]  параметров класса вот этих вот. То есть вы начиная с C++17 можете не уточнять от чего вектор. Он сам
[53:16.280 --> 53:21.400]  догадается, исходя из того, от чего вы его создаете, если это однозначный выбор. Когда это
[53:21.400 --> 53:27.280]  появилось, уже в C++20 люди поняли, что с initializer листами это сочетается весьма плохо, потому что
[53:27.280 --> 53:32.200]  если раньше вы по крайней мере явно писали от чего вектор, у вас таких проблем не возникало. Но
[53:32.200 --> 53:36.960]  когда вам можно не писать от чего вектор, а вы продолжаете пользоваться фигурными скобками,
[53:36.960 --> 53:42.600]  как раньше, у вас возникает внезапность, типа той, что я сейчас описал. И поэтому,
[53:42.600 --> 53:54.160]  начиная с C++20, мода поменялась. И теперь современные самые лидеры мнений в комитете по
[53:54.160 --> 53:58.600]  стандартизации C++ говорят, что наоборот, фигурные скобки лучше не использовать, а использовать круглые,
[53:58.600 --> 54:03.720]  а фигурное использование, когда вы явно хотите initializer лист. Потому что иначе может произойти
[54:03.720 --> 54:12.920]  вот такой конфуз. Я был однажды на лекции действующего члена комитета по стандартизации,
[54:12.920 --> 54:22.280]  не российского причем, и вот он сформулировал такое правило, что сейчас стало не модно.
[54:22.280 --> 54:27.720]  Начиная с 2020 года считается, что фигурные скобки стоит все-таки не предпочитать круглые,
[54:27.720 --> 54:35.960]  из-за таких проблем. Вот, но по крайней мере вы теперь знаете, что есть initializer листы и как они
[54:35.960 --> 54:40.280]  себя ведут. Так, это была первая вещь из двух, которые я хотел сказать. Напомню, теперь вторая.
[54:40.280 --> 54:49.760]  Вторая вещь – это делегирующие конструкторы. Смотрите, вам зачастую бывает нужно, чтобы из
[54:49.760 --> 55:06.160]  одного конструктора вызвать другой. Ну, например, вот, допустим, у меня есть вот такой конструктор.
[55:06.160 --> 55:15.440]  Значит, конструктор, который просто отчисла. Что он делает? Он говорит…
[55:25.440 --> 55:27.560]  Ну, конструктор просто отчисла, он, конечно…
[55:27.560 --> 55:42.040]  Ну, нет, это плохой пример, потому что конструктор просто отчисла, он заполнит нулями. Давайте я другой
[55:42.040 --> 55:47.000]  пример покажу. Вот, смотрите, у меня есть конструктор копирования. По сути, этот конструктор,
[55:47.000 --> 55:56.200]  но он в каком-то смысле выполняет… У меня здесь есть повторение кода небольшое, то есть я опять
[55:56.200 --> 56:04.360]  выделяю вот это все, а потом делаю мем-копию. Я мог бы теоретически захотеть сделать следующее,
[56:04.360 --> 56:09.000]  типа давайте вместо того, чтобы сделать, повторять вот это все, вот эти все действия,
[56:09.000 --> 56:14.280]  я сначала вызову вот этот конструктор, а потом доделаю за него оставшуюся работу. То есть,
[56:14.280 --> 56:17.880]  я могу захотеть написать как бы, чтобы сконструировать стринга другого стринга.
[56:17.880 --> 56:23.880]  Сначала нужно вызвать конструктор с этого стринга от его размера и, допустим, символа 0,
[56:23.880 --> 56:31.000]  а потом сделать только мем-копию. Это называется делегирующий конструктор и это тоже фича начиная
[56:31.000 --> 56:36.360]  C++11. То есть, раньше вам приходилось, если у вас много конструкторов имеет общий код,
[56:36.360 --> 56:41.280]  это вам приходилось в общую функцию выносить. А сейчас, если у вас… Ну, стринг — это не очень
[56:41.280 --> 56:45.520]  хороший пример, потому что тут я бы так не стал писать, неэффективно. Но на будущее,
[56:45.520 --> 56:50.440]  если вам нужно будет один конструктор выражать через другой, а вам нужно будет, это пишется так.
[56:50.440 --> 56:55.440]  Вы говорите, когда вам нужен стринг, когда вам нужно сначала вызвать один конструктор,
[56:55.440 --> 57:09.320]  вы говорите, давайте я сделаю вот так, а вот это удалю все, а потом просто доделаю вот это. То есть,
[57:09.320 --> 57:16.560]  я сократил код таким образом. Вместо того, чтобы повторять все эти действия, я написал,
[57:16.560 --> 57:21.880]  что стринг от другого стринга — это как стринг вот от этого создать, но потом еще дополнительно
[57:21.880 --> 57:28.360]  сделать вот это. При этом, инициализацию полей тут никакую уже писать я не имею права. Инициализация
[57:28.360 --> 57:32.960]  полей должна только один раз произойти вот в том самом конструкторе, который вот в итоге и вызовется.
[57:32.960 --> 57:39.880]  Вот. Но это не очень кажется эффективно, потому что тут придется заполнить это нулями, а потом
[57:39.880 --> 57:45.360]  заполнить еще в дважды, короче, пробежаться. Сначала нулями будет заполнение memset, а потом
[57:45.360 --> 57:51.640]  memcopy. То есть, это лишний вызов, поэтому я бы так не стал делать. Но в каких-то других ситуациях это
[57:51.640 --> 57:57.440]  вполне себе правильный выход — выразить один конструктор через другой, чтобы не повторять логику.
[57:57.440 --> 58:12.800]  Это называется delegating constructors. Делегирующие конструктора. Начиная с C++11. Распространенная
[58:12.800 --> 58:17.480]  ошибка у людей, которые не понимают C++, — это написать что-нибудь в таком духе.
[58:25.480 --> 58:34.960]  Типа, ну давайте вот так этот конструктор вызовем. Я надеюсь, вы не будете так писать. Вот. Ну,
[58:34.960 --> 58:42.320]  возможно, на зачете или на экзамене какой-нибудь из задач у вас будет каверзный вопрос, что будет,
[58:42.320 --> 58:47.800]  если так написать. Вот. Ну, те, кто так пишут, это значит, они не понимают вообще, как работает язык,
[58:47.800 --> 58:52.720]  потому что, конечно же, никакой конструктор... Ну, то есть, это будет вызов конструктора,
[58:52.720 --> 58:58.960]  только это не то, что вы хотите. Это будет вызов... Это будет создание новой строки вот от таких
[58:58.960 --> 59:03.760]  параметров на стеке временно и сразу же ее уничтожение. Эта строка ничего общего с вашей текущей
[59:03.760 --> 59:09.720]  строкой иметь не будет. Это ни в коем случае не вызов конструктора для вашей строки. Вообще,
[59:09.720 --> 59:15.920]  вызвать конструктор явно для текущего объекта нельзя, потому что, если вы находитесь в теле
[59:15.920 --> 59:21.320]  конструктора, это значит, что у вас уже поля проницелизированы, и вы не можете второй раз,
[59:21.320 --> 59:26.160]  как бы, это сделать. Вы уже в теле, и все, что может делать, такое выражение. Ну, то есть,
[59:26.160 --> 59:31.040]  присваивать им что-то. Вот. А это будет просто создание новой временной строки. И это хоть
[59:31.040 --> 59:36.520]  скомпилируется, но будет делать совсем не то, что надо. Вот. И вот так вы написать, конечно,
[59:36.520 --> 59:41.400]  тоже не можете. Значит, вызывать конструктор у себя явно нельзя. Это будет просто ошибка
[59:41.400 --> 01:00:02.280]  компиляции. Вот. Нельзя так вызывать конструктор. Ну вот. Кажется, теперь это все уж теперь точно,
[01:00:02.280 --> 01:00:17.880]  что я хотел вам рассказать о конструкторах. Вот. И мы переходим к следующему параграфу,
[01:00:17.880 --> 01:00:40.600]  который называется оператор присваивания и правила 3. Мы с вами обсудили, как определять
[01:00:40.600 --> 01:00:58.720]  конструкторы и деструкторы. Теперь пора поговорить о том, как определять для своего класса еще один
[01:00:58.720 --> 01:01:08.880]  очень важный метод, называемым оператором присваивания. Значит, параграф 3.4 AssignmentOperator
[01:01:08.880 --> 01:01:30.800]  and the rule of 3. Правило трех, так называемое. Вот. Ну, лишнее я удалю, пожалуй. Оставлю только стрим.
[01:01:30.800 --> 01:01:43.200]  Вот. Это я тоже удалю. Ну, на самом деле, мне вот, собственно, этих двух вещей будет
[01:01:43.200 --> 01:01:49.560]  достаточно. Будут рассматривать только вот класс стрим, который вам реализовывать уже на этой
[01:01:49.560 --> 01:01:56.800]  неделе надо будет. Уже в контесте появится задача завтра, я думаю. Это будет ваша первая
[01:01:56.800 --> 01:02:03.360]  задача по опе реализовать стринг полноценный. Ну, почти полноценный, конечно, урезанный в версии
[01:02:03.360 --> 01:02:14.880]  очень, но какую бы то ни было имеющую право нажить. Вот. Ну, когда мы пишем вот так, значит, стринг
[01:02:14.880 --> 01:02:22.240]  s, а потом стринг ms2 равно s, вызывается конструктор копирования, как вы уже должны знать. Несмотря на
[01:02:22.240 --> 01:02:28.200]  то, что написано равно, это не оператор присваивания. Но если я решу написать вот так,
[01:02:28.200 --> 01:02:40.520]  то это уже оператор присваивания. И оператор присваивания, как и конструктор копирования,
[01:02:40.520 --> 01:02:49.440]  как и деструктор, он генерирует с компилятором автоматически по умолчанию. Так, надо бы мне,
[01:02:49.440 --> 01:02:57.760]  значит, здесь это написать, а то у меня код не правильно будет работать. Он генерирует с
[01:02:57.760 --> 01:03:01.200]  компилятором автоматически. То есть я его не определил для своего класса, но тем не менее
[01:03:01.200 --> 01:03:16.200]  он будет в нем присутствовать. Давайте я это продемонстрирую. Так, ну, у меня нет конструктора
[01:03:16.200 --> 01:03:29.320]  по умолчанию. Давайте он будет вот таким. И у меня, говорит он, все штуки приватные. Ну,
[01:03:29.320 --> 01:03:38.280]  давайте я их сделаю публичными. Логично, я их все... я не написал слово паблик. Вот, это компилируется,
[01:03:38.280 --> 01:03:43.920]  то есть конструктор этот есть, этот конструктор монореализован, деструктор монореализован,
[01:03:43.920 --> 01:03:46.960]  оператор присваиваемый, но не реализован, но он тем не менее срабатывает, потому что компилятор
[01:03:46.960 --> 01:03:58.280]  вот тоже генерирует автоматически. Что же будет, если это запустить? И опаньки, опять РЕ. Почему так?
[01:03:58.280 --> 01:04:02.160]  Да потому что оператор присваивания, который генерируется по умолчанию, он тоже тупой,
[01:04:02.160 --> 01:04:07.720]  как и конструктор копирования по умолчанию. Оператор присваивания по умолчанию копирует все
[01:04:07.720 --> 01:04:12.800]  поля. Ну, он просто берет, присваивает по элементам все поля. В моем случае это значит,
[01:04:12.800 --> 01:04:19.240]  что он присваивает этому указателю тот указатель, этому размеру тот размер, этой capacity, ту capacity.
[01:04:19.240 --> 01:04:24.680]  Получается, что у меня опять две стринг, но каждый из них указатель на одно и то же. И когда мейн
[01:04:24.680 --> 01:04:32.000]  заканчивается, у обоих вызывается деструктор, у той и у другой, и первый раз дилит нормально,
[01:04:32.000 --> 01:04:41.880]  а второй раз double free detected aborted core dumped. Поэтому мне нужно определить оператор присваивания
[01:04:41.880 --> 01:04:50.600]  для строк, свой собственный, чтобы он не по элементу копировал поля, а делал так называемое
[01:04:50.600 --> 01:04:57.880]  глубокое копирование, полноценно перевделял память. Опять обращу ваше внимание, что если у меня класс
[01:04:57.880 --> 01:05:04.760]  ну типа комплексные числа, вот которые я удалил, в котором поля это даблы просто, то ему не надо
[01:05:04.760 --> 01:05:10.080]  писать свой оператор присваивания, потому что там и дефолтный будет нормально работать. Но ему и свой
[01:05:10.080 --> 01:05:13.640]  конструктор копирования было писать не надо, и свой деструктор писать не надо, там дефолтный
[01:05:13.640 --> 01:05:19.800]  будет нормально работать, потому что там нету никакой нетривиальной логики в этих действиях,
[01:05:19.800 --> 01:05:28.600]  оператор присваивания, значит конструктор копирования деструктора делают триреальные вещи,
[01:05:28.600 --> 01:05:33.000]  копируют все поля там, а деструктор просто ничего не делает, просто потом всё со стэка снимается.
[01:05:33.000 --> 01:05:42.800]  Если у вас класс таков, что в нём либо конструктор копирования, либо деструктор, либо оператор
[01:05:42.800 --> 01:05:49.400]  присваивания делает нетривиальную логику, это значит, что вам нужно явно реализовывать все три,
[01:05:49.880 --> 01:05:55.720]  остальные сгенерированные компиляторы вам не подойдут. Вот это и называется правило трёх. Это
[01:05:55.720 --> 01:06:05.680]  евристическое правило, оно не задокументировано в стандарте, вот насколько я знаю, это просто
[01:06:05.680 --> 01:06:12.600]  правило не то что хорошего кода, это правило как не убить себя, пока вы пишете на C++, если еще раз,
[01:06:12.600 --> 01:06:20.000]  если у вас в классе хоть одно из этих трёх вещей, конструктор копирования, или деструктор,
[01:06:20.000 --> 01:06:25.160]  или оператор присваивания нетривиальные, то есть вы сами вынуждены их реализовать,
[01:06:25.160 --> 01:06:30.200]  потому что дефолтный по умолчанию вам не подойдёт, значит вам нужно все три реализовать,
[01:06:30.200 --> 01:06:38.040]  остальные вам тоже не подойдут с вероятностью 99%. Вот сейчас я продемонстрирую, как реализовывать
[01:06:38.040 --> 01:06:42.440]  оператор присваивания для строк, ну я демонстрирую на примере строк, потому что,
[01:06:42.440 --> 01:06:45.720]  как я уже сказал, комплексных чисел нечего демонстрировать, там как бы все тривиальное,
[01:06:45.720 --> 01:06:50.000]  дефолт не просто подойдёт. Давайте какой-нибудь не тривиальный оператор присваивать реализуем,
[01:06:50.000 --> 01:06:57.640]  например для строк. Ну хорошо, тут мы приходим к разговору о том, а что вообще значит реализовать
[01:06:57.640 --> 01:07:05.200]  для своего класса какой-то оператор. C++ поддерживается, то что называется, перегрузка операторов,
[01:07:05.200 --> 01:07:16.560]  operators overloading. В отличие от, например, джавы, в которой нельзя переопределять операции плюс,
[01:07:16.560 --> 01:07:24.600]  минус, для своих классов, в плюсах можно, то есть я могу для своего класса, для своего типа,
[01:07:24.600 --> 01:07:30.480]  по-своему определить действие оператора равно, ну и любого на самом деле оператора, кроме некоторых,
[01:07:30.480 --> 01:07:36.600]  это мы в следующем пункте обсудим. Но сейчас обсудим, как определить своего класса действие
[01:07:36.600 --> 01:07:48.720]  оператора равно. Я сделаю его членом класса, то есть объявлю и определю прямо в телекласс.
[01:07:48.720 --> 01:07:56.480]  По сути, оператор это такая же функция, просто у неё имя особенное, а в общем-то она ничем не
[01:07:57.380 --> 01:08:04.480]  отличается, просто такая функция со странным названием. А работает также, как перегрузка функции,
[01:08:04.480 --> 01:08:09.420]  нельзя перегрузить точку, ну да, точку нельзя перегрузить, еще нельзя перегрузить знак вопроса
[01:08:09.420 --> 01:08:14.780]  двоеточия, еще нельзя перегрузить точку со звездочкой, еще нельзя перегрузить двойной двоеточия
[01:08:14.780 --> 01:08:23.680]  и еще какие-то вещи, возможно, которые я сходу не вспомнил. Ну в общем, почти все остальное можно.
[01:08:23.680 --> 01:08:27.440]  перегрузить можно, и это даже нам в какой-то момент предстоит сделать.
[01:08:27.440 --> 01:08:35.760]  Так, ну все, сейчас люди начали соревноваться, кто больше знает, молодцы, это мы все обсудим в
[01:08:35.760 --> 01:08:45.560]  следующем пункте. Правда, нельзя поменять приоритет операции. Значит, что мне надо написать? Ну,
[01:08:45.560 --> 01:08:48.960]  мне надо написать сначала возвращаемый тип, как обычно, но я на его месте три знака вопроса
[01:08:48.960 --> 01:08:54.400]  поставлю, мы потом подумка возвращаемый тип. Дальше название метода, но вот, собственно,
[01:08:54.400 --> 01:08:58.760]  здесь единственная особенность, надо просто написать слово оператор, а дальше какой,
[01:08:58.760 --> 01:09:07.080]  равно в моем случае. Ну, по код-стайлу, кто-то ставит пробел между вот этим словом, кто-то
[01:09:07.080 --> 01:09:13.320]  не ставит. Я, наверное, предпочитаю ставить, хотя, по-моему, нет строгих требований,
[01:09:13.320 --> 01:09:22.600]  давайте не буду ставить. И дальше, что он принимает? Надо понимать, что мы, поскольку в телекласс его
[01:09:22.600 --> 01:09:29.080]  реализуем, то у него левый оперант, левый аргумент, то есть это мы сами. Мы реализуем для своего класса
[01:09:29.080 --> 01:09:35.560]  оператор равно от какого-то правого аргумента. Левым аргументом является this для него. Вот,
[01:09:35.560 --> 01:09:38.760]  и мы должны принять правый аргумент. А что правым аргументом мы будем принимать? Ну,
[01:09:38.760 --> 01:09:42.440]  другую строку. Как мы ее будем принимать? Ну, конечно же, по константной ссылке,
[01:09:42.440 --> 01:09:50.720]  потому что по значению это будет означать, что она будет лишний раз копироваться, по неконстантной
[01:09:50.720 --> 01:09:54.200]  ссылке будет означать, что мы не сможем присваивать себе константные строки, поэтому по константной
[01:09:54.200 --> 01:10:03.760]  ссылке. Ну, хорошо, тело функции. Вот здесь уже никаких списков инициализации быть не может,
[01:10:03.760 --> 01:10:07.720]  потому что это не конструктор, это метод обычный, это оператор присваивания. Никаких списков
[01:10:07.720 --> 01:10:11.640]  инициализации нет. У нас уже все поля проницилизированы и у нас уже все поля
[01:10:11.640 --> 01:10:20.680]  какое-то осмысленное значение имеют. Что должен сделать наш оператор присваивания? Он должен
[01:10:20.680 --> 01:10:28.480]  сначала освободить память, занимаемую нашей текущей строкой, затем перевыделить памяти
[01:10:28.480 --> 01:10:40.560]  столько, сколько нужно под новую строку и, значит, переприсвоить. Ну, это не самое оптимальное.
[01:10:40.560 --> 01:10:50.560]  О, люди задают вопросы, почему должна быть ссылка. Так, вот, началось. Ну, давайте еще раз, почему
[01:10:50.560 --> 01:10:57.640]  ссылка? Я говорил, что ссылки это будут преследовать вас надолго. Еще раз, почему по ссылке? Потому что
[01:10:57.640 --> 01:11:01.960]  есть три способа принять. По значению, по неконстантной ссылке и по константной ссылке.
[01:11:01.960 --> 01:11:06.680]  По значению, мы не хотим, потому что тогда при передаче сюда будет создаваться копия второй
[01:11:06.680 --> 01:11:10.720]  строки. Лишняя копия. Зачем нам это нужно? Нам не нужна лишняя копия перед тем,
[01:11:10.720 --> 01:11:17.080]  как ее присвоить. Если мы примем неконстантную ссылку, это значит, что мы не сможем присваивать
[01:11:17.080 --> 01:11:20.620]  себя к константной строке. Но мы хотим и к константной строке тоже присваивать. Поэтому
[01:11:20.620 --> 01:11:24.780]  мы принимаем константную ссылку, как и принято в большинстве ситуаций делается, плюсов.
[01:11:24.780 --> 01:11:41.380]  Ссылка нужна не только там, я пока не понял, о чем вы, ну ладно, но ссылка нужна много где,
[01:11:41.380 --> 01:11:54.820]  да. Сейчас увидим. Так, что я делаю сначала? Сначала я освобождаю память, которая занимает
[01:11:54.820 --> 01:12:04.340]  моя текущая строка. Я сразу предупреждаю, что это пока не лучшая реализация, я пока делаю
[01:12:04.340 --> 01:12:09.660]  наивную реализацию, что называется. Сейчас мы постепенно ее превратим в хорошую. Я освобождаю
[01:12:09.660 --> 01:12:17.400]  память, которая занимает мою предыдущую строку. Дальше я переведеляю память столько,
[01:12:17.400 --> 01:12:22.540]  сколько нужно, чтобы хранить ту строку. Как я это делаю? Ну теперь я говорю заново. R это new
[01:12:22.540 --> 01:12:35.860]  char размера s.cz. После этого я говорю cz равно s.cz cap равно, ой, что же я пишу, s.cap. Я
[01:12:35.860 --> 01:12:40.820]  переведеляю памяти не как размер той строки, а как количество выделенной памяти у той строки.
[01:12:40.820 --> 01:12:53.340]  Cz равно s.cz cap равно s.cap. А дальше делаю memcpi. Сначала куда, потом откуда и потом сколько.
[01:12:53.340 --> 01:13:00.940]  Вот memcpi обратный порядок, это неприятно. Значит, куда var, откуда s.ar и сколько cz.
[01:13:00.940 --> 01:13:11.180]  Ну вот, как будто бы и все.
[01:13:11.180 --> 01:13:24.620]  Чего не хватает? Ну мы, во-первых, не поняли, какой должен быть возвращаемый тип. Ну,
[01:13:24.620 --> 01:13:30.220]  хочется наивно написать, что void, но это неправильно. Ну то есть можно написать void,
[01:13:30.700 --> 01:13:36.060]  оно так будет работать, но это не канонично, я бы сказал. Оно будет работать не всегда,
[01:13:36.060 --> 01:13:39.740]  когда хотелось бы. В некоторых ситуациях это будет работать не так, как ожидается.
[01:13:39.740 --> 01:13:47.820]  Дело в том, что стандартная семантика оператора присваивания позволяет вызывать
[01:13:47.820 --> 01:13:53.500]  его в цепочку, я напомню. То есть для стандартных типов оператор присваивания позволяет себя
[01:13:53.500 --> 01:14:01.380]  вызывать вот так вот, раз за разом, друг за другом. И даже делать вот так. Если у нас
[01:14:01.380 --> 01:14:09.140]  возвращаемый тип будет void, то такие схемы не будут работать. Потому что понятно почему.
[01:14:09.140 --> 01:14:23.340]  Вот. Почему нельзя выделить только s.cz? А почему вот некий Федор телефон мне почему-то
[01:14:23.340 --> 01:14:27.300]  все время в direct message пишет? Может паблик надо писать? Я не знаю.
[01:14:35.140 --> 01:14:40.980]  Почему нельзя выделить только s.cz? Наверное, можно, но я хочу полноценную копию строки
[01:14:40.980 --> 01:14:46.540]  создать, то есть в точности копию той строки. Как она была со всеми аналогичными характеристиками,
[01:14:46.660 --> 01:14:52.300]  в том числе с кпейстом такой. Поэтому я и выделю столько, сколько у нее выделено.
[01:14:59.020 --> 01:15:03.780]  Cap – это то, сколько выделено. У нас динамически расширяющаяся штука.
[01:15:03.780 --> 01:15:08.780]  Вы понимаете, что у нас cap – это зарезервированное количество, а s.cz – это реально занятое символ.
[01:15:08.780 --> 01:15:26.980]  Так вот. Поэтому мы хотим, чтобы возвращался не void, а строка. Но опять же, если мы напишем просто
[01:15:26.980 --> 01:15:36.540]  string в возвращаемом типе, это будет означать, что при возврате создается копия нашей строки. То
[01:15:36.540 --> 01:15:44.220]  есть мы возвращаем не нас самих, а копию себя. То есть при выходе отсюда должен будет еще раз
[01:15:44.220 --> 01:15:51.820]  вызваться конструктор копирования нашей строки, чтобы вот ту копию вернуть наружу и уже ее отдать
[01:15:51.820 --> 01:16:00.380]  в то выражение. Ну и при этом не будет работать вот такая вот схема, потому что это будет означать,
[01:16:00.400 --> 01:16:08.660]  что мы не себе, после того как присвоили s2, присвоили s3, а копию себя присвоили s3, то есть
[01:16:08.660 --> 01:16:13.660]  это будет работать, не так, как ожидали. Ну либо вообще не будет компилириваться, либо будет работать
[01:16:13.660 --> 01:16:20.420]  не так, как мы хотим. То есть не не себе будет присваиваться s3, а копию себя. Поэтому мы не
[01:16:20.420 --> 01:16:26.380]  хотим возвращать копию. Мы опять хотим возвращать ссылку. Мы хотим возвращать ссылку на строку,
[01:16:26.380 --> 01:16:32.340]  и вот мы будем возвращать себя. То есть мы будем возвращать наружу из оператора присваивания ссылку
[01:16:32.340 --> 01:16:39.780]  на себя самого. Это позволит извне этот оператор присваивания считать, что он возвращает строку,
[01:16:39.780 --> 01:16:45.540]  но этой же строке можно присваивать, и от этого сама она поменяется. Соответственно, что я должен
[01:16:45.540 --> 01:16:51.220]  написать после return? Я должен написать return, напоминаю vis это указатель на себя, нам нужна ссылка
[01:16:51.220 --> 01:17:02.180]  на себя, поэтому я разминовываю vis. Вот, теперь это более-менее нормальный оператор присваивания уже
[01:17:02.180 --> 01:17:19.300]  куда не шло, так скажем. Впрочем, тут есть еще некоторые проблемы. Ну, он не очень оптимальный,
[01:17:19.300 --> 01:17:28.500]  его можно было бы сделать оптимальнее. Каким образом? Если бы я заметил, что у СЗ, что у той строки,
[01:17:28.500 --> 01:17:37.260]  короче, что памяти, которая у меня сейчас выделена, хватает, чтобы ту строку вместить,
[01:17:37.260 --> 01:17:41.620]  то я мог бы соптимизировать и не делать delete и снова new. Я напоминаю, что вызвать delete и new
[01:17:41.620 --> 01:17:50.580]  это очень дорогие операции, они там примерно порядка сто раз дороже, чем обычные операции над
[01:17:50.580 --> 01:18:00.300]  числами. Вот, то есть вот эти операции мы хотим минимизировать их количество в нашем коде. Вот,
[01:18:00.300 --> 01:18:06.260]  и можно было бы, значит, от них избавиться, если у нас проверить, что тот размер, он меньше, чем наш,
[01:18:06.260 --> 01:18:17.580]  только paste меньше немножко. Но это ладно. Есть еще один такой интересный случай, когда вот такая
[01:18:17.580 --> 01:18:32.940]  вещь написана. Вот что, если я попытаюсь строку присвоить самой себе? Ну, ничто не запрещает
[01:18:32.940 --> 01:18:40.860]  мне такое написать в коде в мейне пользователям моего класса. Причем он может не осознать написать,
[01:18:40.860 --> 01:18:45.840]  то есть тут может быть какое-то выражение, которое там что-то там вычисляет и либо равно
[01:18:45.840 --> 01:18:51.700]  одному, либо другому, то есть строке я присваиваю либо ее саму, либо другую какую-то строку. Вот такая
[01:18:51.700 --> 01:18:56.500]  конструкция. И вот, допустим, у меня в какой-то момент в коде возникло выражение присваивания
[01:18:56.500 --> 01:19:02.420]  строки самой себе. Что тогда будет делать так реализованный оператор присваивания? Ну, получится,
[01:19:02.420 --> 01:19:08.660]  что сначала я удаляю свой собственный массив, потом выделяю новый массив такого же размера,
[01:19:08.660 --> 01:19:15.500]  как был, переприсваиваю себе старые же значения, а потом начинаю копировать из старого массива,
[01:19:15.500 --> 01:19:26.140]  ну, а потом начинаю, значит, из R в SR копировать. Но, минуточку, R и SR это у меня уже новый массив,
[01:19:26.140 --> 01:19:31.380]  а не старый. То есть это один и тот же массив новый. Получается, что после такого присваивания
[01:19:31.380 --> 01:19:37.460]  самому себе у меня будут некорректные поведения, у меня в строке начнут лежать рандомные символы,
[01:19:37.460 --> 01:19:46.940]  потому что я скопировал их же на них же самих. Вот. А, кстати, еще и Memcpi у меня тут, тут у меня
[01:19:46.940 --> 01:19:54.860]  еще проблема с тем, что это пересекающиеся диапазоны. Вот. И Memcpi, я не уверен, даже будет ли
[01:19:54.860 --> 01:20:00.900]  корректно работать при таком, при пересекающих диапазонах. Вот. Ну, короче, в любом случае я не
[01:20:00.900 --> 01:20:05.420]  получу корректное поведение, в лучшем случае я получу рандомные символы вместо того, что в строке
[01:20:05.420 --> 01:20:13.940]  лежало раньше. Вот, понятно. Ну, если не понятно, внимательно проследите, что происходит, осознайте
[01:20:13.940 --> 01:20:26.820]  еще раз, и поймите. Вот. Поэтому мне можно исключить изменение под константной ссылкой. Это
[01:20:26.820 --> 01:20:34.580]  что значит изменение? Что значит под ссылкой? Я не понимаю, что значит под ссылкой. Вы, если можете,
[01:20:34.580 --> 01:20:40.300]  голосом вопрос задавайте. Да, если у меня был элемент X, я создал на него касанную ссылку и
[01:20:40.300 --> 01:20:48.260]  изменил X. На кого? На X? Ну нет, в смысле изменил значение X. Ну да, у меня был X, я создал константную
[01:20:48.260 --> 01:21:01.340]  ссылку на X и изменил значение X. Если у тебя был какой-то объект X, ты создал константную ссылку
[01:21:01.340 --> 01:21:15.020]  на X и изменил X. Так что ли? Да. Ну все окей, по Y ты будешь видеть новое значение и по X новое
[01:21:15.020 --> 01:21:25.060]  значение. Вот плюс плюс Y, видимо, не получится. Плюс плюс Y не получится, да. Хорошо, спасибо. Так,
[01:21:25.060 --> 01:21:33.300]  ну вот вы уже начали задавать вопросы, которые мы подробно разбирали на прошлых парах. Вот,
[01:21:33.300 --> 01:21:38.740]  я, конечно, могу на такие вопросы отвечать, но если таких вопросов будет много, то я буду
[01:21:38.740 --> 01:21:45.740]  говорить, идите пересматривайте или... ахаха, у вас лекции не... а лекции все еще не выложены. Вот,
[01:21:45.740 --> 01:21:51.060]  да. Ну короче, да, если вы будете много вопросов задавать, что было раньше, то мне придется вам в
[01:21:51.060 --> 01:21:56.060]  какой-то момент начинать отвечать, идите пересматривайте лекцию такую. Вот, а то мы...
[01:21:56.060 --> 01:22:03.340]  Все еще не будет, скорее всего. Чего? Которой в записи, скорее всего, не будет, потому что вас
[01:22:03.340 --> 01:22:11.500]  как-то очень странно выкладывают. В смысле, их так и не выложат? Ну есть шанс, что многие лекции
[01:22:11.500 --> 01:22:18.180]  будут выкладываться задержкой просто месяц-два, такими темпами. А, понятно. Ну, идите пересматривайте
[01:22:18.180 --> 01:22:23.900]  лекции прошлого года, что могу вам сказать в том плейлисте, который я скинул. Ну там не настолько
[01:22:23.900 --> 01:22:28.260]  подробно было, как мы с вами разбирали. Мы с вами подробнее разбирали, чем я в прошлом году рассказывал,
[01:22:28.260 --> 01:22:41.500]  но хотя бы эти случаи были там разобраны, конечно. Вот, окей. Ладно. Так вот, я хочу исключить случай
[01:22:41.500 --> 01:22:46.940]  присваивания самому себе. Для этого я просто в начале допишу костыль. Если я обнаружил, что я
[01:22:46.940 --> 01:22:52.860]  присваиваюсь самому себе, то сразу возвращаю, выхожу, ничего не делая. Как мне это проверить? Как
[01:22:52.860 --> 01:22:58.700]  проверить, что я присваиваюсь самому себе? Это вопрос в зал. Чего надо написать?
[01:22:58.700 --> 01:23:11.180]  z и с равно, видимо, ссылка от s. Не ссылка, а адрес. Давайте не называть оператор ссылкой. Значит да,
[01:23:11.180 --> 01:23:19.660]  мне нужно проверить, что this равен адресу s. Ну, я могу написать сразу return звездочка this.
[01:23:19.660 --> 01:23:36.100]  Да, if и однострочники короткие у нас разрешены, если что. Вот. Такое можно делать иногда. Вот. То
[01:23:36.100 --> 01:23:48.660]  есть, я исключил этот случай, потом сделал все, как полагается. У вас, правда, мог возникнуть вопрос,
[01:23:48.660 --> 01:23:56.380]  а почему мы, когда писали конструктор копирования, не предусмотрели копирование
[01:23:56.380 --> 01:24:16.940]  от самого себя? Вот что, если я так напишу? Ну, или вот так. Ну, так это же неопределенного мы себя
[01:24:16.940 --> 01:24:26.700]  еще не создали. Как вы думаете, что будет, если так написать? Ну, c и v, видимо. Ну,
[01:24:26.700 --> 01:24:37.460]  либо r e. Бесконечная рекурсия. Да, ну, будет бред какой-то. c и e не будет. Ну, дело в том,
[01:24:37.460 --> 01:24:45.020]  что... А почему c и e не будут? Это ж вроде можно отловить в compile time. Можно, но по правилам языка
[01:24:45.020 --> 01:24:51.180]  это не ошибка. Если вы припомните, вот когда мы разбирали... Опять-таки, я возвращаюсь к тому,
[01:24:51.180 --> 01:25:02.180]  что мы уже обсуждали. Когда вы пишете вот так, я, если вы вспомните, мы такое разбирали. Область
[01:25:02.180 --> 01:25:06.740]  действия x начинается сразу же после знака равно, поэтому этот x здесь уже действует. Когда вы пишете
[01:25:06.740 --> 01:25:12.700]  int x равно x, считается, что вы... Это все равно, что написать просто int x. Ну, такие правила. Поэтому,
[01:25:12.700 --> 01:25:17.660]  когда вы написали string s равно s, это значит, что вы вызвали конструктор копирования от
[01:25:17.660 --> 01:25:26.140]  себя самого, но вы сами при этом еще не созданы. То есть, у вас в полях лежит мусор, но вы скопировали
[01:25:26.140 --> 01:25:36.140]  мусор. То есть, у вас будет... У вас действительно вызовется вот этот конструктор, но в полях мусор,
[01:25:36.140 --> 01:25:43.540]  поэтому вы вызоветесь... То есть, будет ub, фактически. Вы вызоветесь, вы сделаете new char от
[01:25:43.540 --> 01:25:52.460]  рандомного числа, и дальше будет бред полный. Это почти гарантированная реакция. Но можно попробовать
[01:25:52.460 --> 01:26:06.020]  посмотреть, что будет. Да, кто понимает, что произошло? Что означает эта ошибка? Мы попытались
[01:26:06.020 --> 01:26:11.540]  селлоцировать непонятную память, получили палкой в лог. Нет, мы попытались селлоцировать слишком
[01:26:11.540 --> 01:26:18.740]  много. Или отрицательное число. Или отрицательное число, может быть, да. То есть, bdelog — это ошибка,
[01:26:18.740 --> 01:26:24.420]  которая кидается оператором new в случае, когда запросили либо слишком много, так что операционная
[01:26:24.420 --> 01:26:30.940]  система отказала в выделении памяти, либо запросили, да, отрицательное число. Вот. Я не уверен,
[01:26:30.940 --> 01:26:36.220]  кстати, отрицательное число там, по-моему, sizeT принимается в качестве параметра, но, возможно,
[01:26:36.220 --> 01:26:41.380]  оно переконвертировалось в int. Оказалось, что там запрошено сколько-то гигабайт, много миллиардов байт,
[01:26:41.380 --> 01:26:52.220]  и всё. Bdelog. Эта ошибка означает, что... Ну вот, это, по сути, и произошло. Я вот здесь, вот в этом
[01:26:52.220 --> 01:26:57.220]  месте просто в качестве CZ подставилось рандомное число, которое там лежало в этот момент, и произошла
[01:26:57.220 --> 01:27:07.580]  вот эта вот ошибка. Вот. Сейчас, то есть, после того, как мы написали string s, у нас в s уже
[01:27:07.580 --> 01:27:14.700]  пронициализированы все значения? Нет. В том-то и дело, что в s здесь не пронициализированы все
[01:27:14.700 --> 01:27:21.620]  значения. s сейчас объект, у которого не пронициализированы по s, фактически конструктор ещё не отработал
[01:27:21.620 --> 01:27:27.500]  никакой. Паля еще не пронициализированы, но я вызываю конструктор копирования от этого, аж. Я
[01:27:27.500 --> 01:27:33.940]  правильно понимаю, что у нас фактически упало на строчке error в no new char s? Да-да, вот в этом месте.
[01:27:33.940 --> 01:27:45.260]  А если в полях есть ссылка? Ну, будет рандомным значением пронициализировано также. Давайте
[01:27:45.260 --> 01:27:53.140]  проверим. Сейчас только. У нас фактически работает инициализатор, а не оператор.
[01:27:53.140 --> 01:28:02.060]  Какой инициализатор? Конструктор работает. Это я уже повторял несколько раз, что если вы пишете
[01:28:02.060 --> 01:28:10.940]  string s равно что-то, то это не оператор присваивания, это конструктор. Потому что это declaration,
[01:28:10.940 --> 01:28:18.820]  а не expression. Ну, если в полях будет ссылка, это ничего не изменит. У вас будет
[01:28:18.820 --> 01:28:25.700]  не пронициализированный объект. Ну, короче, просто так писать не надо и всё. Как он поймет,
[01:28:25.700 --> 01:28:33.620]  от какого конструктора вызывается? От какого пора? Ну, как? Справа же string. Да. С какой?
[01:28:33.620 --> 01:28:38.460]  String. Значит, мы создаем string от string. Значит, нужно идти в конструктор копирования.
[01:28:46.820 --> 01:28:53.540]  Вот после string s у нас все поля заполнены мусором или их вообще ещё нет? Что значит после string s?
[01:28:53.540 --> 01:29:04.820]  Ну, вот у нас string s, вот по символе string s и вот до равно. Нет, у вас точка запятой является границей
[01:29:04.820 --> 01:29:11.620]  команды. Вот когда что-то происходит, это точка запятой. Вот после string s точка запятой я могу
[01:29:11.620 --> 01:29:16.220]  сказать, что у вас конструктор по умолчанию отрабатывает. После string s перед равно ничего
[01:29:16.220 --> 01:29:21.820]  не происходит, происходит продолжение синтоксического парсинга предложения. Когда компилятор распаршивает
[01:29:21.820 --> 01:29:26.420]  его до конца, до точки запятой, он понимает, что здесь сказано сделать и делает это. Здесь сказано
[01:29:26.420 --> 01:29:33.780]  создать s от s. Вторая s справа, это вот она сама. Ну, у неё ещё ничего не принадлежит. Ну, пофиг. Мы
[01:29:33.780 --> 01:29:40.620]  вызываем конструктор копирования от неё же. А если мы запретили у s конструктор, то когда мы так
[01:29:40.620 --> 01:29:47.220]  напишем? Какой конструктор? Обычный, дефолтный? Ну да. Параметров? Нет, ничего. Мы же не вызываем
[01:29:47.580 --> 01:30:00.700]  дефолтный конструктор. Мы вызываем конструктор. Мы в операторе конструктора же. Что такое оператор
[01:30:00.700 --> 01:30:03.040]  конструктора? Мы здесь не вызываем дефолlene конструктор. Мы внутри оператора копирования вызываем
[01:30:03.040 --> 01:30:10.040]  мы вызываем только конструкторы. Внутри конструктора копирования мы... Нет, мы не вызываем дефолтный
[01:30:10.040 --> 01:30:19.080]  конструктор. Мы вызываем вот этот конструктор. Вот этот конструктор мы не вызываем. Его и нет,
[01:30:19.080 --> 01:30:23.720]  он не сгенерирован, его фактически и нет. А то, что я напишу string-crowed-delete, ничего не поменяется,
[01:30:23.720 --> 01:30:30.080]  потому что его и так нет, если вы про этот конструктор. Я правильно понимаю, что если мы
[01:30:30.080 --> 01:30:37.040]  зашли в оператор копирования... Мы не зашли в какой оператор, мы не зашли. Но не оператор,
[01:30:37.040 --> 01:30:41.480]  в копирование. Конструкторы мы зашли, заходим только. Так, конструктор копирования. У нас есть
[01:30:41.480 --> 01:30:51.160]  const-3-comper-sant-s. Да. Оно еще не пронициализировано. Ну, ссылка пронициализирована, а то,
[01:30:51.160 --> 01:30:58.320]  что под ней нет, не пронициализировано. Окей. А если мы обращаемся к аргументу, то оно
[01:30:58.320 --> 01:31:06.120]  пронициализируется. С.сз это какое-то рандомное число, туда еще ничего не написано. Там рандомное
[01:31:06.120 --> 01:31:15.920]  число лежит. А, это вообще... А, ладно. То есть оно пронициализировано, рандомное число? Нет,
[01:31:15.920 --> 01:31:20.480]  оно ничем не пронициализировано. Там просто лежит последовательство с byte, которое мы прочитаем
[01:31:20.480 --> 01:31:31.480]  как число, так? Да. Ну, пронициализировано. Есть понятие default initialization, а есть как бы
[01:31:31.480 --> 01:31:38.720]  никакая неинциализация. Одно дело, когда у вас написано int x, вы как бы считаете, что вы создали
[01:31:38.720 --> 01:31:49.040]  x, но просто оно пронициализировано. Но, значит, вот эта default-инциализация для int работает,
[01:31:49.040 --> 01:31:54.240]  как там рандомное число лежит. А тут никакой инициализации не было. Вы просто взяли память,
[01:31:54.240 --> 01:31:59.200]  которая лежит под string, у вас формально ни один конструктор еще не вызвался для этого объекта,
[01:31:59.200 --> 01:32:05.240]  поэтому никакое поле не пронициализировано. И там лежат рандомные числа по его полям,
[01:32:05.240 --> 01:32:10.080]  но формально и даже default-нинициализации не произошло. Вот.
[01:32:10.080 --> 01:32:19.880]  Ну, как не произошло, если у нас ws.soz лежит случайное число?
[01:32:19.880 --> 01:32:27.000]  Нет, не произошло, потому что инициализация полей происходит тогда, когда вызывается конструктор.
[01:32:27.000 --> 01:32:33.440]  Там лежит случайная память. Мы не вызвали конструктор string. Чтобы пронициализировать поля,
[01:32:33.440 --> 01:32:39.440]  должен отработать какой-то конструктор. Перед входом в конструктор происходит инициализация
[01:32:39.440 --> 01:32:44.240]  полей. Пока нет вызова конструктора, никакой инициализации полей не происходит.
[01:32:44.240 --> 01:32:51.040]  Короче, там лежит случайная память, которая как бы нам была выделена, но мы вообще никак с ней
[01:32:51.040 --> 01:32:59.960]  не взаимодействовали, так? Да. Ну, формально это убе, потому что время жизни cz еще не началось.
[01:32:59.960 --> 01:33:07.520]  Вот я даже так скажу. Я могу это скомпилировать с санитайзерами, и он мне должен сказать это,
[01:33:07.520 --> 01:33:29.320]  по идее. Ну, это он мне сказал, что я запросил слишком много, а если я попрошу его undefined...
[01:33:29.320 --> 01:33:43.200]  Нет, не говорит. Может, Seleng скажет. Ну, Seleng мне говорит warning еще до...
[01:33:43.200 --> 01:33:52.840]  Seleng без всяких санитайзеров мне warning кидает. Я мог бы, кстати, наверное, из JCC warning попросить
[01:33:52.840 --> 01:34:03.720]  включить, и он мне тоже сказал, что это убе, так писать. Нет, не сказал. Тоже собака не сказал.
[01:34:03.720 --> 01:34:11.280]  Ну, короче, GCC не говорит, а Seleng говорит, вот это убе я то, что здесь делаю. Я использую
[01:34:11.280 --> 01:34:18.000]  неинициализированную переменную в конструкторе. Обращаюсь к полю s.sz, время жизни,
[01:34:18.000 --> 01:34:22.760]  которого еще не началось, потому что для него не вызвана инициализация никакая,
[01:34:22.760 --> 01:34:29.240]  потому что конструктор не начал отрабатывать для него. Я обращаюсь к полю объекта, у которого
[01:34:29.240 --> 01:34:34.440]  не был вызван конструктор, а значит, поле не проинициализировано. Так, ну ладно, долго мы
[01:34:34.440 --> 01:34:42.760]  сидим на этом примере, давайте дальше. Ну, не надо так писать, короче. Вот, что теперь про этот
[01:34:42.760 --> 01:34:54.480]  оператор присваивания еще можно сказать. Ну, он реализован не очень умно, потому что можно было
[01:34:54.480 --> 01:35:06.440]  бы покороче. Давайте я научу вас реализовывать оператор присваивания покороче. Ну, во-первых,
[01:35:06.440 --> 01:35:15.240]  вот что хочу сказать. Вот кто-то мог бы сказать, зачем нам здесь писать delete r,
[01:35:15.240 --> 01:35:26.240]  можно просто деструктор вызвать. Это то же самое. Ну, для стринг, кажется, это без разницы,
[01:35:26.240 --> 01:35:30.800]  там всего одна строчка в теле деструктора. Но если это было бы что-то более сложное, чем стринг,
[01:35:30.800 --> 01:35:36.040]  например, это было бы какое-нибудь, ну, я не знаю, у вас дерево, и в нем было бы много указателей,
[01:35:36.040 --> 01:35:41.560]  которые каждый нужно было бы дилитнуть, когда вы уничтожаете старое дерево. Вам бы не хотелось
[01:35:41.560 --> 01:35:46.400]  писать много раз delete, delete, delete, у вас в деструкторе это и так написано. Вот, поэтому
[01:35:46.400 --> 01:35:53.760]  можно захотеться здесь написать просто деструктор, а дальше уже вот это. Это неправильно, так нельзя.
[01:35:53.760 --> 01:36:03.480]  Почему так нельзя? Кто знает? Кто смотрел лекции наперед? Я смотрел лекции, которые вы нам скинули.
[01:36:03.480 --> 01:36:10.920]  Нельзя два раза уничтожать у одного объекта. Значит, по стандарту, если у одного и того же
[01:36:10.920 --> 01:36:19.560]  объекта два раза вызывается деструктор, это уб. Вот, поэтому, когда вы так написали, если вы
[01:36:19.560 --> 01:36:25.320]  скомпилируете с оптимизацией, компилятор имеет право после того, как вы деструктор первый раз
[01:36:25.320 --> 01:36:29.880]  вызвали, вообще игнорировать все дальнейшие действия над полями, потому что компилятор считает,
[01:36:29.880 --> 01:36:33.800]  что после того, как деструктор хоть один раз вызван, больше обращений к полям объекта не будет
[01:36:33.800 --> 01:36:40.680]  никогда. И, де-факто, если GCC с оптимизацией скомпилировать вот такое, то вы с удивлением
[01:36:40.680 --> 01:36:47.880]  обнаружите, что вот эти поля, вот эти инструкции просто проигнорированы. Ничего не делается,
[01:36:47.880 --> 01:36:51.600]  полям ничего не присваивается, потому что компилятор считает, уже деструктор отработал,
[01:36:51.600 --> 01:36:58.760]  нет смысла что-то полям присваивать. Уже объект умер, только деструктор отработал. Поэтому так писать
[01:36:58.760 --> 01:37:08.680]  нельзя. Вот, а как можно написать? Есть такой хитрый способ реализовать оператор присваивания,
[01:37:08.680 --> 01:37:18.080]  который называется copy and swap. Сейчас я о нем расскажу. Смотрите, я это все удалю, короче,
[01:37:18.080 --> 01:37:30.480]  и напишу вот что. Давайте я создам копию текущей строки и назову ее copy.
[01:37:30.480 --> 01:37:51.880]  Вот. Дальше я сделаю следующую интересную вещь. Я сделаю swap с этой копией. Что такое swap?
[01:37:51.880 --> 01:37:58.440]  Это у меня еще не было написано, но я поясню. Swap это просто swap всех полей. Вот если мне дали
[01:37:58.440 --> 01:38:17.320]  какую-то строку swap, то я сделал, я могу вызвать std swap. Значит, r s.r std swap cz s.cz и std swap
[01:38:17.320 --> 01:38:30.160]  cap s.cap. Ну, метод swap, он есть на самом деле у всех стандартных контейнеров, включая строки,
[01:38:30.160 --> 01:38:35.960]  и он именно так работает. Он просто берет и свопает все поля. Вы меня спрашивали, как swap работает
[01:38:35.960 --> 01:38:41.880]  с векторами в завод единицы. Вот так и работает. Как вектор свопнуть с другим вектором завода единицы.
[01:38:41.880 --> 01:38:47.560]  Ну, например, так он просто указатель переставляет и размеры переставляет, соответственно. Так и swap
[01:38:47.560 --> 01:38:53.000]  строк работает. То есть этот метод, он в любом случае полезен. Так вот, я взял, вызвал swap от этой
[01:38:53.000 --> 01:39:04.040]  копии и все. Дальше написал return this. Вот вам и весь оператор присваивания. Извините, а мы почему-то в
[01:39:04.040 --> 01:39:09.440]  операторе присваивания с вообще не используем. Мы не должны стринг-копию с бано-звездочкой сделать?
[01:39:09.440 --> 01:39:19.680]  А, равно с, наверное, а не vis. Ну да. Давайте посмотрим. Да, это странно, конечно. Не vis, а с.
[01:39:19.680 --> 01:39:26.920]  Я затутнился сомневаться. Что произошло? Ну, я создал копию той строки, которую мне дали.
[01:39:26.920 --> 01:39:35.720]  Конструктором копирования. Потом завод единицы поменял свое текущее значение, текущую строку с
[01:39:35.720 --> 01:39:45.400]  этой копией. Теперь моя строка стала тем, чем раньше была копия, а то, что раньше было моей строкой,
[01:39:45.400 --> 01:39:51.240]  теперь называется копия. Но поскольку копия локальный объект, он уничтожается, когда эта функция
[01:39:51.240 --> 01:39:59.560]  заканчивается. Вот и получается, что у меня как бы то, что копия, то есть строки продолжают жить во мне,
[01:39:59.560 --> 01:40:07.000]  а я, будучи свопнутый с копией, уничтожаюсь, когда выхожу из этой функции, потому что деструктор
[01:40:07.000 --> 01:40:12.600]  копии вызывается. Это называется копиен своп. И это хитрый такой способ реализовать оператор
[01:40:12.600 --> 01:40:19.440]  присваивания коротко и красиво. И заметьте, что здесь мне не нужно даже делать проверку на то,
[01:40:19.440 --> 01:40:27.720]  равно ли с. Короче, присваивание самому себе тоже работает корректно теперь. Потому что присваивание
[01:40:27.720 --> 01:40:32.840]  самому себе, это означает, что я просто создаю копию себя же и свопу у себя же с собой же, но это
[01:40:32.840 --> 01:40:38.040]  корректно. То есть просто, ну это лишнее действие, я мог бы его не делать, но оно корректно. Я просто
[01:40:38.040 --> 01:40:43.440]  создал копию того, чем был я. У меня две эквивалентных копии себя, но я переставил указатель,
[01:40:43.440 --> 01:40:51.200]  одну удалил, другую оставил. Это все еще корректно работает. Вот и в такой ситуации я могу еще сократить
[01:40:51.200 --> 01:41:02.040]  код и сюда принять стринг вообще по значению, а не по константной ссылке. Зачем мне создавать
[01:41:02.040 --> 01:41:10.200]  копию отдельной строкой в коде, если я могу сразу принять s по значению, и копия уже будет
[01:41:10.200 --> 01:41:15.240]  создана за меня. То есть я взял копию, принял сразу той строки, которую хочу присвоить, свопнулся с
[01:41:15.240 --> 01:41:31.000]  ней и все. Вот весь оператор присваивания. Вот. Понятно. Вот это красивая реализация оператора
[01:41:31.000 --> 01:41:42.960]  присваивания. Вот. Такие дела.
[01:42:02.000 --> 01:42:06.880]  Ну, наверное, это все, что я хочу сказать про оператор присваивания. Сейчас я про правила
[01:42:06.880 --> 01:42:17.280]  трех. Еще момент, который я хочу здесь упомянуть, это что вообще-то, что в случае оператора присваивания,
[01:42:17.280 --> 01:42:20.880]  что в случае конструктора копирования, у вас имеют право одновременно существовать и такой
[01:42:20.880 --> 01:42:29.280]  конструктор, и такой конструктор. Ну, если у вас есть вот такой, то компилятор этот уже не будет
[01:42:29.320 --> 01:42:35.660]  сгенерировать. Но вообще-то вы можете явно попросить сгенерировать компилятор вот такой конструктор,
[01:42:35.660 --> 01:42:40.000]  и тогда конструктор от неконстантной ссылки будет работать так как по умолчанию работает. То есть
[01:42:40.000 --> 01:42:46.680]  неправильно. Вот, но иногда, очень редко, но иногда бывает нужно, чтобы конструктор, там, от
[01:42:46.680 --> 01:42:51.760]  неконстантной ссылки, от неконстантного стринга работали иначе, чем конструктора константного
[01:42:51.760 --> 01:42:56.800]  стринга. Их можно перегружать. Аналогично, если у вас есть конструктор от неконстантной ссылки на
[01:42:56.800 --> 01:43:02.160]  стринг, то компилятор не будет уже генерировать вам конструктор от const-string-compersand, если вы
[01:43:02.160 --> 01:43:05.960]  явно не попросите. То же самое с оператором присваивания. Если вы сделали оператор от
[01:43:05.960 --> 01:43:13.200]  string-compersand, то от const-string-compersand уже не будет генерироваться. Вот. И оператор присваивания
[01:43:13.200 --> 01:43:16.600]  тоже относится к функциям, которые компилятору можно явно попросить за вас сгенерировать,
[01:43:16.600 --> 01:43:22.720]  то есть написать равно default. Если по какой-то причине компилятор не сгенерирует их сам,
[01:43:22.720 --> 01:43:26.320]  если почему-то вам нужен оператор присваивания с генерированным компилятором, можно написать
[01:43:26.320 --> 01:43:31.860]  равно default и компилятор сгенерирует, если, конечно, ему что-нибудь не будет запрещать это сделать. А
[01:43:31.860 --> 01:43:39.920]  что ему может запрещать это сделать? Вот если вы попросите равно default у класса, у которого полями
[01:43:39.920 --> 01:43:44.000]  являются ссылки или константы, то компилятор вам откажет. Он не сможет ничего сгенерировать.
[01:43:44.000 --> 01:43:48.960]  То есть оператор присваивания не получится сгенерировать, даже если вы явно попросили,
[01:43:48.960 --> 01:43:54.280]  у класса, у которого в полях есть ссылки или константы. Потому что непонятно, как их присвоить.
[01:43:54.280 --> 01:44:00.000]  Он не может по-члену присвоить. Ну, ссылку он как бы может, но это будет не то, что ожидается,
[01:44:00.000 --> 01:44:06.240]  скорее всего. А константу, в принципе, присвоить нельзя. Поэтому он просто откажется генерировать
[01:44:06.240 --> 01:44:13.880]  этот оператор. Так, ну всё. Это всё, что я хотел рассказать пока про оператор присваивания.
[01:44:13.880 --> 01:44:20.440]  Про вот это вот, кто там сильно наперёд, я не буду сейчас говорить там про LVLU и RLU,
[01:44:20.440 --> 01:44:27.400]  значит, квалификаторы не будем пока. Это ещё успеем обсудить. Пока и так хватит вам
[01:44:27.400 --> 01:44:41.400]  у головы чем заморочить. Хорошо, давайте пойдём дальше. У нас ещё 15 минут. И давайте следующий
[01:44:41.400 --> 01:44:50.640]  пункт. Ну, собственно, следующий пункт, он про перегрузку остальных операторов.
[01:44:58.200 --> 01:45:01.240]  Значит, перегрузка прочих операторов.
[01:45:01.240 --> 01:45:16.320]  Так, у меня уже есть какой-то файлик. Ну, давайте я его, да, удалю это в чёртом матери,
[01:45:16.320 --> 01:45:35.800]  сделаю новый файлик. Ну, теперь я уже буду, значит, на примере какого-нибудь другого класса
[01:45:35.800 --> 01:45:44.080]  показывать перегрузку. Мне кажется, что как раз можно показывать перегрузку, либо на примере
[01:45:44.080 --> 01:45:49.080]  класса комплекс, либо на примере следующего класса, в котором предстоит реализовывать класс
[01:45:49.080 --> 01:45:53.320]  длинных чисел Big Integer. Ну, давайте я буду показывать на примере класса длинных чисел. Ну,
[01:45:53.320 --> 01:46:02.920]  вы все, наверное, в своей жизни писали длинную арифметику хоть раз. Overloading, да, я пропустил
[01:46:02.920 --> 01:46:12.400]  буквой R, не знаю почему. Overloading. Да, все вы наверняка знаете, что такое длинная арифметика.
[01:46:12.400 --> 01:46:19.720]  Вот, и питоня у вас длинная арифметика встроенная, там сколько угодно длинные числа могут быть,
[01:46:19.720 --> 01:46:27.320]  а в плюсах нет, и вам надо её реализовывать самим. И вот, значит, вторая задача, которая у вас будет
[01:46:27.320 --> 01:46:33.920]  после стринг, это написать Big Integer, то есть класс длинных чисел, который будет поддерживать там
[01:46:33.920 --> 01:46:40.120]  все операции плюс-минус, может разделить, быстро умножить, быстро разделить, там и так далее. Вот,
[01:46:40.120 --> 01:46:45.120]  и с правильной семантикой, с присваиванием составным, и так далее. Вот, сейчас мы еще раз вкратце
[01:46:45.120 --> 01:46:52.440]  обсудим все, значит, основные операторы, которые мы обсуждали так упорно в пункте 1.4, но теперь мы
[01:46:52.440 --> 01:46:56.760]  уже на новом уровне их обсудим, а именно как их сами реализовывать, и как правильно, что из них
[01:46:56.760 --> 01:47:02.520]  должен кто возвращать, чтобы вся семантика сохранялась корректно, чтобы виды value были
[01:47:02.520 --> 01:47:15.800]  правильными, и так далее. Ну вот, если говорить про класс длинной арифметики, что в нем в качестве
[01:47:15.800 --> 01:47:29.240]  полей можно хранить? Ну можно хранить вектор чисел, да, не знаю, назовем его digits. Ну там, я не буду
[01:47:29.240 --> 01:47:33.800]  сейчас писать прям, как полагается, ну вот, допустим, я реализовываю длинную арифметику, там у меня
[01:47:33.800 --> 01:47:38.920]  наверное еще какие-то поля надо будет, но это мы потом сами догадаетесь. Вот, у меня сейчас интересно,
[01:47:38.920 --> 01:47:43.800]  допустим, конструкторы все уже написаны, там система числения, все с ней понятно, вот, мне
[01:47:43.840 --> 01:47:48.520]  интересно, как реализовать именно операторы? Вот как правильно реализовать плюс, например?
[01:47:48.520 --> 01:47:52.280]  Да, ну, во-первых, как реализовать оператор присваиванием? Оператор присваивания, тут
[01:47:52.280 --> 01:47:56.360]  дофолт не подойдет, потому что у меня в полях вектор. Вектор сам корректно умеет присваиваться,
[01:47:56.360 --> 01:48:01.960]  поэтому мне присваивать ничего по-умному не надо, у меня поля, и так ими умеют присваивать друг
[01:48:01.960 --> 01:48:11.780]  друга корректно. Давайте обсудим, как, например, плюс реализовать. Ну как реализовать плюс? Ну,
[01:48:11.780 --> 01:48:25.820]  арифметических операторов. Я сейчас напишу комментарий, арифметические операторы, но понятно,
[01:48:25.820 --> 01:48:32.060]  что в своем коде не надо писать, конечно, такие комментарии – это глупости, это тавтология, это видно
[01:48:32.060 --> 01:48:38.900]  и так, что они арифметические, это просто я, чтобы разделить, так сказать, в учебных целях. Как
[01:48:38.900 --> 01:48:51.100]  перегрузить оператор плюс от двух bigintegers? Ну, что должен возвращать плюс? Плюс должен возвращать
[01:48:51.100 --> 01:48:58.460]  новый biginteger. Не ссылку на старый biginteger, а именно новый biginteger, потому что плюс,
[01:48:58.460 --> 01:49:05.900]  он возвращает новое временное значение по семантике. Когда вы написали a плюс b,
[01:49:05.900 --> 01:49:13.780]  вы создали новый объект, вы не какому-то из a и b присвоили эту сумму, а вы создали новый объект,
[01:49:13.780 --> 01:49:21.260]  являющийся суммой этих двух, его вернули. Не ссылку на него, а копию. Потому что у вас объект
[01:49:21.260 --> 01:49:29.180]  временный, вы его только что создали, и вот он в воздухе подвешен. А ссылаться не на что,
[01:49:29.180 --> 01:49:35.620]  у вас нет той переменной, на что вернуть ссылку. Понимаете, вам нужно создать новое нечто,
[01:49:35.620 --> 01:49:41.420]  и вот его вернуть. Поэтому, когда мы реализовываем операторы бинарные арифметические типа плюс,
[01:49:41.420 --> 01:49:54.660]  мы возвращаем копию, ну то есть значение. Принимают они, конечно, аргументы по
[01:49:54.660 --> 01:50:03.020]  константной ссылке. Опять же, почему? Потому что копию мы не хотим лишнюю создавать,
[01:50:03.020 --> 01:50:09.740]  когда второй аргумент прибавляем к себе, и не константную ссылку тоже плохо,
[01:50:09.740 --> 01:50:16.220]  потому что константные тоже должны уметь. Вот, и здесь пишем соответственно код сложения. Ну,
[01:50:16.300 --> 01:50:21.940]  у вас будет код выглядеть примерно так. Вы тут создаете big integer, не знаю,
[01:50:21.940 --> 01:50:28.820]  c, ну или сумма. Тут делаете собственно сложение и возвращаете эту сумму.
[01:50:28.820 --> 01:50:36.700]  Ну, аналогично вы реализуете минус, там умножить, разделить. Вот.
[01:50:36.700 --> 01:50:52.460]  Тут есть несколько тонкостей. Первая тонкость такая. Как правильно выразить составные
[01:50:52.460 --> 01:51:03.180]  присваивания? Мне нужно, например, еще выразить плюс равно. Что должен возвращать плюс равно? А вот
[01:51:03.180 --> 01:51:08.140]  плюс равно должен возвращать ссылку, как и любое присваивание, потому что плюс равно дает мне
[01:51:08.140 --> 01:51:13.460]  ссылку на то, что получилось, и ему я снова могу присваивать. А void ему не по госту делать, да? Да.
[01:51:13.460 --> 01:51:35.700]  Оператор плюс равно от const big integer another. А что я тут делаю? А тут я делаю сумму,
[01:51:35.700 --> 01:51:43.060]  ну и пишу return with, потому что я вот здесь как раз проявляется разница между плюс равно
[01:51:43.060 --> 01:51:52.420]  себе, это вам в строках тоже надо будет делать, и плюс. А плюс равно эффективней, чем плюс должен
[01:51:52.420 --> 01:52:01.660]  быть. Почему? Потому что я себе, ну я в себе же что-то меняю и возвращаю ссылку на себя.
[01:52:01.660 --> 01:52:13.300]  Но тут, как вы можете догадаться, будет один и тот же код. Вот здесь вот будет код, ну это ладно
[01:52:13.300 --> 01:52:19.060]  еще, сложение, там один цикл. А если умножение, там фурьешка будет у вас, допустим, или какой-нибудь
[01:52:19.060 --> 01:52:25.780]  там, ну хоть даже обычное умножение в столбика, но там два цикла уже. Ну короче, тут много кода.
[01:52:25.780 --> 01:52:32.540]  И вот тут и вот тут он одинаковый. Понятно, что мы не хотим дублирования кода, поэтому один из
[01:52:32.540 --> 01:52:40.020]  операторов плюс и плюс равно нужно через другое выразить. Вопрос важный на понимание, какой из
[01:52:40.020 --> 01:52:48.100]  операторов плюс и плюс равно нужно реализовать, скажем так, в каком из этих операторов нужно
[01:52:48.100 --> 01:52:55.020]  написать код самого сложения, а какой оператор нужно выразить через второй? Ну очевидно,
[01:52:55.020 --> 01:53:02.620]  если мы будем выражать плюс равно через плюс, то мы потеряем все ускорения. Да, именно. Вот,
[01:53:02.620 --> 01:53:07.900]  ну если вам это очевидно, то хорошо. Да, замечательно, если вам это очевидно, то хорошо,
[01:53:07.900 --> 01:53:19.740]  а если не очевидно, то плохо. Вот, но многим не очевидно, я уверен. Поэтому объясняю, если вы,
[01:53:19.980 --> 01:53:26.340]  интуитивно первое, что хочется сделать, первое наивное желание, это выражать плюс равно через
[01:53:26.340 --> 01:53:31.820]  плюс, потому что кажется, что плюс это что-то фундаментальное, а плюс равно это присваивание
[01:53:31.820 --> 01:53:36.340]  с плюсом дополнительным. Если вы, не дай бог, выразите присваивание как А равно А плюс Б,
[01:53:36.340 --> 01:53:42.500]  то вы создадите лишнюю копию еще, возможно, дважды, потому что у вас будет сначала А плюс Б
[01:53:42.500 --> 01:53:48.100]  лишняя копия, потом еще лишнее присваивание, это копирование. То есть у вас будет О от Н,
[01:53:48.100 --> 01:53:54.700]  причем не то, что у нас будет двукратное О от Н, сначала создание копии, когда вы сделали плюс,
[01:53:54.700 --> 01:54:02.300]  а потом присваивание этой копии себе по элементу. Вот, поэтому, конечно же, нужно плюс выражать
[01:54:02.300 --> 01:54:09.140]  через плюс равно. Поэтому вот здесь вот реально код сложения, а оператор плюс, он буквально
[01:54:09.140 --> 01:54:17.020]  выражается вот так в три строчки. Сум плюс равно another, то есть я изначально сумму делаю равной себе,
[01:54:17.340 --> 01:54:25.860]  потом плюс равно и делаю второй аргумент и возвращаю ее, то что получилось. Фактически
[01:54:25.860 --> 01:54:31.020]  реализация оператора плюс вот так и должна выглядеть. Как и всех бинарных обычных операторов,
[01:54:31.020 --> 01:54:35.900]  минус умножить разделить вот так же. А вот плюс равно, тут уже логика какая-то содержится.
[01:54:35.900 --> 01:54:50.380]  Но это не все проблемы. Есть еще такая проблема. Вот вы заметили, что я пока все операторы делаю
[01:54:50.380 --> 01:54:56.860]  членами класса. Но вообще-то операторы могут и не быть членами класса и понимать, когда операторы
[01:54:56.860 --> 01:55:03.420]  должны быть, а когда нет членами класса, это тоже нужно. Вот на что это влияет? Ну, например,
[01:55:03.420 --> 01:55:12.940]  вот я пишу, ну, у меня есть конструктор, ну, должен быть конструктор, big integer от обычного
[01:55:12.940 --> 01:55:17.340]  импа. Я же могу создать big integer от каким-то интовым значением. Я могу сказать big integer,
[01:55:17.340 --> 01:55:35.180]  там bi равно 5. Вот. Потом могу сказать big integer, не знаю, ci равно bi плюс 5. Вот. И здесь у меня
[01:55:35.180 --> 01:55:42.540]  будет вызван оператор плюс. Но как он будет вызван? Да, у меня оператор плюс, у него левый оператор
[01:55:42.540 --> 01:55:49.980]  bi. То есть big integer правый оперант int. И тут начнет происходить неявное приведение типов. Если у меня,
[01:55:49.980 --> 01:55:56.300]  у big integer есть конструктор от int, то это значит, что он позволяет неявный каст из int в big integer.
[01:55:56.300 --> 01:56:05.460]  Это значит, что, когда я так пишу, вызывается оператор плюс от двух big integers, от левого
[01:56:05.460 --> 01:56:17.620]  аргумента big integer и правого аргумента big integer. Вот. И он, значит,
[01:56:22.340 --> 01:56:32.300]  делает неявный каст пятерки к big integer, а потом выполняет вот этот код. Но такое может сработать,
[01:56:32.300 --> 01:56:37.900]  только если левый аргумент это big integer. Если левый аргумент это int, а правый аргумент big
[01:56:37.900 --> 01:56:43.660]  integer, то такое не сработает. Потому что вот этот оператор, он всегда подразумевает, что левый
[01:56:43.660 --> 01:56:50.820]  аргумент, то есть первый оперант, это this. И неявный каст левого операнда не рассматривается.
[01:56:50.820 --> 01:56:58.420]  Рассматривается только неявный каст правого операнда. Если я напишу вот здесь вот не bi плюс 5,
[01:56:58.420 --> 01:57:05.580]  а 5 плюс bi, это не будет работать. Это не скомпилируется, потому что нет у int операции
[01:57:05.580 --> 01:57:11.220]  сложений с big integer. А с кастить int к big integer сейчас нельзя, потому что оператор плюс — это
[01:57:11.220 --> 01:57:16.940]  член класса big integer. А если он член класса big integer, то у него всегда первый аргумент — это big
[01:57:16.940 --> 01:57:24.660]  integer должен быть, чтобы он попал в рассмотрение. Поэтому, если вы хотите, чтобы ваш оператор
[01:57:24.660 --> 01:57:30.660]  работал симметрично для левого операнда и для правого операнда, вам нужно этот оператор делать
[01:57:30.660 --> 01:57:36.980]  не членом класса, а внешней функции. И вот именно таким должен быть оператор плюс. Я его отсюда
[01:57:36.980 --> 01:57:46.780]  убираю, а вставляю сюда. Как он должен работать? У него должно быть два аргумента теперь уже,
[01:57:46.780 --> 01:57:52.180]  потому что он не член класса. И вот когда оператор не является членом класса, у него нет неявного
[01:57:52.180 --> 01:57:58.340]  первого операнда viz. У него все операнды нужно явно указать. Поэтому у него сейчас у меня два
[01:57:58.340 --> 01:58:15.940]  аргумента уже. Я могу сказать a и b. И могу сказать, что здесь сумма равна a, потом сумма плюс равно b,
[01:58:16.220 --> 01:58:30.940]  и вернуть сумму. Но я могу это сделать похитрее. Я могу опять избежать, чуть сэкономить и сказать,
[01:58:30.940 --> 01:58:39.140]  что сразу я просто принимаю по значению вот этот вот левый оперант и просто возвращаю то,
[01:58:39.140 --> 01:58:45.420]  что получилось. Но только имена a и b, наверное, не очень хорошо писать. First, second лучше,
[01:58:45.500 --> 01:58:52.420]  потому что однобуквенно имена это плохо. Вот так выглядит оператор плюс в двух видах. Тоже
[01:58:52.420 --> 01:58:58.500]  самое с оператором минус и так далее. Со всеми симметричный оператор. Оператор присваивания я
[01:58:58.500 --> 01:59:04.380]  уже не могу сделать не членом, потому что мне для оператора присваивания нужно, чтобы обязательно
[01:59:04.380 --> 01:59:11.420]  был viz. Если я нахожусь не в классе, то viz не имеет смысла. Только вам нужно в паблик вынести
[01:59:11.420 --> 01:59:19.340]  плюс равно. Понятно, что это все должно быть паблик. Я не пишу паблик, потому что забываю
[01:59:19.340 --> 01:59:23.340]  про него. Понятно, что я подразумеваю, что операторы у меня публичные. Можно писать
[01:59:23.340 --> 01:59:32.540]  стракт вместо класс. Вот так вот выражаются правильно бинарные операторы. Во-первых,
[01:59:32.540 --> 01:59:39.300]  бинарные операторы не являются членом класса, присваивания являются членом класса, а операторы
[01:59:39.300 --> 01:59:46.780]  выражаются через присваивания, а не наоборот. Есть еще унарный плюс, унарный минус. Я напомню. Вот
[01:59:46.780 --> 01:59:55.100]  и эти операторы они... Ну вот, например, что такое унарный минус? Он возвращает новый big integer,
[01:59:55.100 --> 02:00:04.460]  и у него нету параметров. Ну, если его делать членом класса, то у него нет параметров,
[02:00:04.460 --> 02:00:10.580]  потому что у унарных операторов первый аргумент. Итак, не явно this, а правого нет,
[02:00:10.580 --> 02:00:16.140]  второго нет. Если я бы написал второй параметр здесь, то это был бы бинарный минус. А я не
[02:00:16.140 --> 02:00:20.980]  написал параметров и сделал членом класса. Поэтому это получился унарный минус. И что должен делать
[02:00:20.980 --> 02:00:27.020]  этот минус? Я могу выразить его через бинарный минус. Например, я могу сказать return 0 minus this.
[02:00:27.020 --> 02:00:42.140]  Это будет, значит, ну, как бы бинарный минус. Ну или могу скорее тут правильнее сделать не так,
[02:00:42.140 --> 02:00:48.500]  а у меня еще должно быть поле sign, которое отвечает за знак, и я его поменяю на противоположное и верну
[02:00:48.500 --> 02:00:54.460]  копию того, что получилось. Варианты разные, но смысл в том, что вот этот унарный минус,
[02:00:54.460 --> 02:00:59.740]  если он член класса, то у него нет параметров. А если вы унарный оператор делаете не членом
[02:00:59.740 --> 02:01:04.340]  класса, то тогда у него надо явно прописывать параметр. Вот этот единственный параметр и
[02:01:04.340 --> 02:01:18.620]  будет вашим единственным параметром, от которого оператор называется. Ну, давайте последнее,
[02:01:18.620 --> 02:01:23.500]  что я за сегодня расскажу, это как перегружать инкременты. А где предпочтительнее писать
[02:01:23.500 --> 02:01:28.300]  вне класса или внутри? Я же вам сказал, это зависит от того, какой оператор вы реализовываете.
[02:01:28.300 --> 02:01:37.820]  Ну понятно, но если типа при прочих равных. Ну, я не знаю, что значит прочие равные. Если ваш
[02:01:37.820 --> 02:01:45.060]  оператор должен симметрично себя вести по отношению к левому и правому операторам, значит вне класса.
[02:01:45.060 --> 02:01:51.380]  Если у вам принципиально, чтобы левым аргументом был именно объект вашего класса, то есть как бы они
[02:01:51.380 --> 02:01:59.860]  неравноправны в вашем операторе. То есть вам нужно, чтобы левым оператором был именно настоящий
[02:01:59.860 --> 02:02:08.740]  объект, как присваивание. Тогда вам надо, чтобы это был член класса. Я не знаю, что прочие равные.
[02:02:08.740 --> 02:02:13.820]  Либо у вас такая ситуация, либо другая. Либо вам принципиально, чтобы одним из аргументов был вис,
[02:02:13.820 --> 02:02:36.220]  либо нет. Ну как реализовать инкременты, давайте обсудим. Ну вот с инкрементами,
[02:02:36.220 --> 02:02:43.220]  например, что делать? Инкрементов два. Бывают префиксные инкременты и постфиксные инкременты.
[02:02:43.220 --> 02:02:48.140]  Давайте сначала обсудим, как реализовать префиксный инкремент. Что должен возвращать
[02:02:48.140 --> 02:02:57.180]  префиксный инкремент? Я напоминаю, что префиксный инкремент, его результат это lvalue. И вы снова
[02:02:57.180 --> 02:03:02.180]  можете присваивать ему. То есть вы возвращаете себя самого, а не копию себя. Значит вы возвращаете
[02:03:02.180 --> 02:03:13.220]  срочку. Да. Оператор плюс-плюс. И у вас нет аргументов больше, потому что вы унарный оператор.
[02:03:13.220 --> 02:03:25.020]  Что вы делаете? Вы просто добавляете к себе единицу и возвращаете же себя. То есть вы можете
[02:03:25.100 --> 02:03:43.420]  по сути написать так. А можете написать еще короче. Потому что результат этого же и так
[02:03:43.420 --> 02:03:53.980]  ссылка на себя. Вы можете прям так написать. Вот. Никакой копии при этом не создается. И вы
[02:03:53.980 --> 02:03:57.940]  вызываете именно плюс-равно. А плюс-равно тоже эффективно работает. Если вам всю единичку
[02:03:57.940 --> 02:04:06.340]  добавить, то вы за единицу это делаете в среднем. Что такое постфиксный инкремент? С постфиксным
[02:04:06.340 --> 02:04:12.300]  инкрементом весело. Дело в том, что постфиксный инкремент у него также нет больше оперантов,
[02:04:12.300 --> 02:04:21.780]  кроме как вы сами. И он тоже унарный. Но как же его отличать от префиксного тогда? Если я напишу
[02:04:21.780 --> 02:04:26.340]  снова оператор плюс-плюс без рубля, это будет считаться префиксным инкрементом. Тут просто
[02:04:26.340 --> 02:04:33.620]  создатель пошел на беспрецедентный шаг. То есть нужно было придумать какой-то костыль, как в
[02:04:33.620 --> 02:04:38.140]  сигнатуре оператора отличать постфиксный инкремент от префиксного. То же самое с декрементом.
[02:04:38.140 --> 02:04:46.500]  Ну, значит, создатель наш принял гениальное решение. Давайте постфиксным инкрементом добавить
[02:04:46.500 --> 02:05:00.900]  эффективный аргумент int. Можно смеяться. Закадровый смех. А плакать. Да, вот если бы мы очень сейчас
[02:05:00.900 --> 02:05:07.940]  сидели, то сейчас должен был быть закадровый смех в зале. Ну, короче, как объявить постфиксный
[02:05:07.940 --> 02:05:15.540]  инкремент? Надо объявить инкремент с аргументом int. И это будет постфиксный инкремент тогда. Вот
[02:05:15.540 --> 02:05:25.620]  постфиксный инкремент в отличие от префиксного копию возвращает. И что он делает? Ну, вы говорите,
[02:05:25.620 --> 02:05:41.540]  big integer copy равно this, plus plus this, а вернуть копию. И теперь вы понимаете, почему постфиксный
[02:05:41.540 --> 02:05:45.980]  инкремент работает за линию в отличие от префиксного. И теперь вы понимаете, почему постфиксный
[02:05:45.980 --> 02:05:53.140]  инкремент менее предпочтительно, чем префиксный. В случае обычных int это без разницы, но в случае
[02:05:53.140 --> 02:06:00.500]  длинных каких-то больших объектов, инкремент префиксный — это очень быстрая операция, а постфикс
[02:06:00.500 --> 02:06:05.340]  инкремент — это линейное время, занимающее операцию. Потому что в постфиксном инкременте вам
[02:06:05.340 --> 02:06:10.500]  обязательно нужно создать копию старого значения, прежде чем вы сможете увеличить,
[02:06:10.500 --> 02:06:15.100]  ну вам надо старое значение увеличить, а вернуть то, что было. Поэтому вам приходится
[02:06:15.100 --> 02:06:21.740]  создавать копию старого и ее возвращать, а старое вот this — инкрементировать.
[02:06:21.740 --> 02:06:33.820]  То есть вот это int — это как бы абсолютный костыль. Это просто костыль, да, это просто тупой костыль,
[02:06:33.820 --> 02:06:40.220]  просто способ максимально тупой, как отличить префиксный от постфиксного по сигнатуре — фиктивный
[02:06:40.220 --> 02:06:50.300]  int. Давайте на сегодня все, потому что мне уже пора заканчивать. Ну и встретимся,
[02:06:50.300 --> 02:06:56.460]  мы, видимо, в понедельник. Ну а до этого времени вы уже можете начинать, будете кодить стринг.
[02:06:56.460 --> 02:07:04.060]  Вот нам в понедельник мы уже, я думаю, ну в понедельник у нас будет две пары,
[02:07:04.060 --> 02:07:12.020]  получается, с вами опять и утренняя и вечерняя, и значит мы там продвигемся еще достаточно
[02:07:12.020 --> 02:07:16.980]  существенно вперед. Ну все, на сегодня.
