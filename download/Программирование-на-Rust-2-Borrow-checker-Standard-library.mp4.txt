[00:00.000 --> 00:07.020]  Мне бы хотелось ответить на некоторые анонимные
[00:07.020 --> 00:10.240]  вопросы, которые были в форме.
[00:10.240 --> 00:13.140]  Например, спрашивали, как же так 20 часов в неделях
[00:13.140 --> 00:14.140]  курс занимает.
[00:14.140 --> 00:15.140]  Вот.
[00:15.140 --> 00:17.500]  Я как-то поспрашивал специально, сколько там в шаде курс
[00:17.500 --> 00:21.240]  занимает, подобные вещи, и выяснил, что на самом
[00:21.240 --> 00:25.140]  деле, конечно, курс будет занимать в это ожидание
[00:25.140 --> 00:27.580]  примерно до 10 часов в неделю, на самом деле даже
[00:27.580 --> 00:28.580]  меньше.
[00:28.580 --> 00:30.660]  Но если вы будете рассчитывать на 20 часов в неделю, то
[00:30.660 --> 00:33.860]  у вас точно все получится со отлом 10.
[00:33.860 --> 00:39.860]  Но учитывайте, что он в общем-то такое в ожидании
[00:39.860 --> 00:43.220]  10 часов, больше вы точно успеете.
[00:43.220 --> 00:49.180]  Так, ну давайте, может, перейдем к лекции.
[00:49.180 --> 00:52.980]  Чисто такой вопрос, в ожидании для студента шада?
[00:52.980 --> 00:54.980]  Ну получается, что да, для студента шада.
[00:54.980 --> 00:57.660]  Но они на самом деле говорили чисто меньше, кто-то говорил
[00:57.660 --> 01:00.180]  3 часа в неделю, кто-то говорил 6 часов в неделю.
[01:00.180 --> 01:02.940]  То есть до 10 часов не доходило, это я уже и сам рулю.
[01:02.940 --> 01:05.460]  А это на какую цепь?
[01:05.460 --> 01:08.460]  Это на максимум, на отл.
[01:08.460 --> 01:09.460]  Вот.
[01:09.460 --> 01:12.260]  Ну, может быть, у вас, конечно, будет больше, но, я думаю,
[01:12.260 --> 01:13.260]  несчастно.
[01:13.260 --> 01:15.020]  Еще раз, конечно, в лекциях были некоторые непоследовательности
[01:15.020 --> 01:17.940]  и, к сожалению, как я не пытался, ну, я делал вторую лекцию
[01:17.940 --> 01:19.820]  и выяснился, что на самом деле, конечно, лучше было
[01:19.820 --> 01:24.940]  чуть-чуть по-другому прочитать материал, поэтому мы чуть-чуть
[01:24.940 --> 01:26.940]  будем теряться на второй лекции, но я постараюсь вам
[01:26.940 --> 01:31.100]  по-другому на вопросы отвечать, чтобы вы все поняли.
[01:31.100 --> 01:33.780]  Ну, просто такая проблема, что курс первый раз читается
[01:33.780 --> 01:37.300]  и могут быть запросто какие-то ошибки в нем.
[01:37.300 --> 01:38.300]  Вот.
[01:38.300 --> 01:41.340]  Ну, давайте, наверное, перейдем к баррелчекеру, про который
[01:41.340 --> 01:44.100]  мы не успели поговорить на первой лекции, до конца.
[01:44.100 --> 01:48.740]  Так, кто у нас сделал первую домашню присутствующих?
[01:48.740 --> 01:54.060]  Ну, то есть, в принципе, все можно считать, да, буквально,
[01:54.060 --> 01:55.060]  с редким исключением.
[01:55.060 --> 02:01.060]  Столкнулись ли вы с баррелчекером в домашней лекции?
[02:01.060 --> 02:04.060]  Что, что еще?
[02:04.060 --> 02:13.060]  Столкнулись ли вы с баррелчекером в домашней лекции?
[02:13.060 --> 02:15.900]  Ну, он говорит обычно что-то вроде там использования
[02:15.900 --> 02:16.900]  Borrowed Value.
[02:16.900 --> 02:17.900]  Что это такое?
[02:17.900 --> 02:23.340]  Ну, амперсанды вроде бы там ставить нужно было
[02:23.340 --> 02:25.180]  только в единичных строчках.
[02:25.180 --> 02:26.180]  Ну, то есть, там одна строчка.
[02:26.180 --> 02:27.180]  Ну, можно понять, куда именно там эти амперсанды вставить.
[02:27.180 --> 02:28.180]  Проходилось прииграть в переборки.
[02:28.180 --> 02:29.180]  Там компилятор же обычно говорит просто, куда поставить.
[02:29.180 --> 02:30.180]  Что-то он плохо там говорил в одном месте точно.
[02:30.180 --> 02:31.180]  Что-то не знаю.
[02:31.180 --> 02:32.180]  Вот вся домашка должна была быть такой достаточно
[02:32.180 --> 02:33.180]  простой.
[02:33.180 --> 02:34.180]  Даже компилятор бы справился справить ошибки.
[02:34.180 --> 02:35.180]  Ну, ладно, было бы интересно увидеть, что ты конкретно
[02:35.180 --> 02:36.180]  сделал в домашке.
[02:36.180 --> 02:37.180]  Ну, то есть, чтобы понять, где я накосячил, потому что
[02:37.180 --> 02:38.180]  я постарался сделать так, чтобы с баррелчекером
[02:38.180 --> 02:39.180]  первой домашней лекции просто не столкнулись.
[02:39.180 --> 02:40.180]  Ну, что вы думаете?
[02:40.180 --> 02:41.180]  Ну, что вы думаете?
[02:53.340 --> 02:55.380]  В общем, она была бы для вас простой.
[02:55.380 --> 03:02.340]  Ну, и какую код вы писали, можно будет потом посмотреть.
[03:02.340 --> 03:04.340]  То есть, чтобы сделать какие-то выводы.
[03:04.340 --> 03:05.340]  Интересно.
[03:05.340 --> 03:06.340]  Вот.
[03:06.340 --> 03:08.780]  Ну, баррелчекер предназначен для того, чтобы, собственно,
[03:08.780 --> 03:11.780]  у нас получилась memory-safety-vrasti.
[03:11.780 --> 03:13.460]  Это одна из составляющих частей.
[03:13.460 --> 03:17.660]  Ну, насколько мы помним, memory-safety-vrasti – это такая
[03:17.660 --> 03:20.620]  вещь, которая дает нам гарантию о том, что мы не будем,
[03:21.620 --> 03:24.620]  что у нас не будет double-free и подобных ошибок.
[03:24.620 --> 03:27.620]  Ну, то есть, мы смотрели на сижный код, смотрели
[03:27.620 --> 03:32.620]  на примеры, ошибок, которые у нас могли возникнуть,
[03:32.620 --> 03:36.620]  и что у нас мог, от чего нас мог спасать раст.
[03:36.620 --> 03:39.620]  Давайте конкретно на это посмотрим.
[03:39.620 --> 03:42.620]  Вот давайте посмотрим на такой код.
[03:42.620 --> 03:44.620]  Те, кто делали домашку.
[03:44.620 --> 03:47.620]  Что не так в этом коде с точки зрения раста?
[03:50.620 --> 03:55.620]  Мы сначала, ну как-то, мы сохраняем подписывку
[03:55.620 --> 03:58.620]  на первый элемент, ну, нулевой элемент векторе,
[03:58.620 --> 04:01.620]  но вызываем метод push, который должен
[04:01.620 --> 04:04.620]  изменить состояние вектора.
[04:04.620 --> 04:08.620]  Ну, я не знаю лексику, это как-то захватить…
[04:08.620 --> 04:11.620]  Ну да, да, ты на самом деле правильно говоришь.
[04:11.620 --> 04:14.620]  Ну, то есть, мы уже заборули вектор,
[04:14.620 --> 04:18.620]  и push мы его тоже хотим сделать, а два раза…
[04:18.620 --> 04:21.620]  Так, да, действительно, у нас получается такая
[04:21.620 --> 04:24.620]  проблема, что у нас есть вектор, мы берем ссылку,
[04:24.620 --> 04:26.620]  а после этого делаем push.
[04:26.620 --> 04:29.620]  Например, в плюсах этот код прекрасно бы сработал,
[04:29.620 --> 04:32.620]  но у нас бы стала ссылка потенциально невалидной,
[04:32.620 --> 04:35.620]  потому что у нас мог бы реалуцироваться вектор.
[04:35.620 --> 04:38.620]  Раст этого просто не позволит сделать.
[04:38.620 --> 04:41.620]  У нас есть вот такая вот ошибочка.
[04:41.620 --> 04:44.620]  Что наш вектор уже немутабельно заборвен,
[04:44.620 --> 04:47.620]  то есть, мы взяли на него ссылочку,
[04:47.620 --> 04:49.620]  которую мы хотим изменить.
[04:49.620 --> 04:52.620]  Это потенциально опасно, это Раст запрещает.
[04:52.620 --> 04:55.620]  Это общая на самом деле правила для Раста, то,
[04:55.620 --> 04:58.620]  что если у нас на структуру внутри есть какая-нибудь
[04:58.620 --> 05:01.620]  любая ссылочка, она может быть обычной, может быть
[05:01.620 --> 05:04.620]  mute-ссылочка, про которую мы говорили на первой лекции,
[05:04.620 --> 05:07.620]  у нас вектор будет становиться немутабельным в самом себе.
[05:07.620 --> 05:10.620]  Ну и любая структура данных. Мы еще на этой лекции
[05:10.620 --> 05:13.620]  успеем обсудить и посмотрим другие структуры данных,
[05:13.620 --> 05:16.620]  которые у нас есть в Расте, кроме вектора.
[05:16.620 --> 05:19.620]  Вот такая вот у нас возникла ошибочка.
[05:19.620 --> 05:22.620]  Давайте посмотрим еще на какой-нибудь примерчик.
[05:24.620 --> 05:28.620]  Этот пример исправить нужно просто удалить вот этот
[05:28.620 --> 05:31.620]  letx и просто взять println x0.
[05:34.620 --> 05:37.620]  Да, это сработает, потому что у нас
[05:37.620 --> 05:40.620]  letx Раст посмотрит на эту ссылочку
[05:40.620 --> 05:43.620]  и решит, что ее время жизни оно будет до vpush.
[05:43.620 --> 05:46.620]  То есть у нас есть вектор,
[05:46.620 --> 05:49.620]  если бы у нас не было println, тогда бы он жил до push
[05:49.620 --> 05:52.620]  следующего. Ну и то, что по центру x
[05:52.620 --> 05:55.620]  он инициализируется и сразу
[05:55.620 --> 05:58.620]  дезинфицилизируется, Раст решит, что это безопасно,
[05:58.620 --> 06:01.620]  потому что ей дальше электроника не пользуется.
[06:04.620 --> 06:07.620]  Дальше у нас есть такой код, который делает
[06:07.620 --> 06:10.620]  сумму элементов в векторе. Вот мы создаем
[06:10.620 --> 06:13.620]  какой-то вектор, считаем сумму,
[06:13.620 --> 06:16.620]  push что-то вектор и считаем вторую сумму.
[06:17.620 --> 06:20.620]  У нас здесь на самом деле есть сразу несколько проблем.
[06:21.620 --> 06:24.620]  Как вы думаете, какие?
[06:27.620 --> 06:30.620]  Да, во-первых, мы умувнули вектор
[06:30.620 --> 06:33.620]  в сумму и умувнули вектор.
[06:35.620 --> 06:38.620]  Соответственно он будет у нас недоступен в main.
[06:38.620 --> 06:41.620]  В плюсах, насколько вы помните, если мы
[06:41.620 --> 06:44.620]  напишем подобную вещь, то в таком случае у нас произойдет
[06:44.620 --> 06:47.620]  копирование вектора. То есть если бы у нас было
[06:47.620 --> 06:50.620]  написано какая-то функция intsum,
[06:50.620 --> 06:53.620]  которая принимает на вход istd-вектор, то в таком случае
[06:53.620 --> 06:56.620]  мы бы скопировали вектор, просуммировали,
[06:56.620 --> 06:59.620]  а в Rast по умолчанию у нас move-семантика. То есть
[06:59.620 --> 07:02.620]  то же самое, что вы в плюсах напишете istd-move.
[07:02.620 --> 07:05.620]  Он будет забирать владение, скажем так.
[07:05.620 --> 07:08.620]  Посмотрим, что такое владение.
[07:09.620 --> 07:12.620]  У нас вот такая вот будет прекрасная ошибка компиляции.
[07:12.620 --> 07:15.620]  Rast очень подробно, как видите,
[07:15.620 --> 07:18.620]  показывает. Вот у нас есть ошибка
[07:18.620 --> 07:21.620]  такого рода. У нас есть V.
[07:22.620 --> 07:25.620]  Он объясняет, что он имплементирует trade-копию.
[07:26.620 --> 07:29.620]  У нас были, кстати, вот вопросы в чатике
[07:29.620 --> 07:32.620]  по поводу того, что такое копии clone. Это тоже мой промах,
[07:32.620 --> 07:35.620]  который я объяснил на первой лекции. Наверное, стоило сразу сделать.
[07:35.620 --> 07:38.620]  Все ли поняли разницу между копией clone?
[07:38.620 --> 07:41.620]  Нет, не очень.
[07:41.620 --> 07:44.620]  Ну, смотрите, копия — это когда у нас
[07:44.620 --> 07:47.620]  для того, чтобы что-то скопировать, достаточно просто скопировать
[07:47.620 --> 07:50.620]  саму структуру. В случае вектора это
[07:50.620 --> 07:53.620]  неправда, потому что если вы скопируете вот этот вот буфер,
[07:53.620 --> 07:56.620]  скопируете его длину, скопируете его capacity,
[07:56.620 --> 07:59.620]  то в таком случае вы получите такой же вектор,
[07:59.620 --> 08:02.620]  который указывает на тот же самый буфер.
[08:02.620 --> 08:05.620]  Это не прямо будет копия. Вам нужно будет скопировать буфер
[08:05.620 --> 08:08.620]  сам по себе, то есть сделать новую локацию,
[08:08.620 --> 08:11.620]  перекопировать туда все элементы.
[08:11.620 --> 08:14.620]  Поэтому он имплементирует не копию, а clone.
[08:14.620 --> 08:17.620]  Копия — это когда вы копируете
[08:17.620 --> 08:20.620]  сами байтики, из которых состоит структура.
[08:20.620 --> 08:23.620]  Например, просто можно скопировать int и 32,
[08:23.620 --> 08:26.620]  но просто для того, чтобы его склонировать, достаточно
[08:26.620 --> 08:29.620]  повторить байтики, из которых он состоит.
[08:33.620 --> 08:36.620]  Конструктор копирования перемещения в плюсах — это более
[08:36.620 --> 08:39.620]  общая вещь.
[08:49.620 --> 08:52.620]  Если структура тяжелая, в частности, если она владеет
[08:52.620 --> 08:55.620]  какими-то данными на куче, то в таком случае
[08:55.620 --> 08:58.620]  у нас будет клоун, например.
[08:58.620 --> 09:01.620]  Я могу сходу придумать такой пример.
[09:01.620 --> 09:04.620]  Например, у нас будет структура хранить, какой будет
[09:04.620 --> 09:07.620]  идентификатор U64. Казалось бы, просто
[09:07.620 --> 09:10.620]  скопировать этот U64 внутри копии.
[09:10.620 --> 09:13.620]  А мы можем сделать так, чтобы у нас по умолчанию
[09:13.620 --> 09:16.620]  вот этот идентификатор на самом деле сначала идентификатор
[09:16.620 --> 09:19.620]  на каком-то внешнем сервере. И он что-то значит
[09:19.620 --> 09:22.620]  для внешнего сервера. И для того, чтобы склонировать
[09:22.620 --> 09:25.620]  структуру, мы можем сделать такой пример.
[09:25.620 --> 09:28.620]  В таком случае по умолчанию РАС на самом деле
[09:28.620 --> 09:31.620]  не имплементирует даже копии и клоун для структуры.
[09:31.620 --> 09:34.620]  Потому что это просто небезопасно, он не понимает,
[09:34.620 --> 09:37.620]  как вы пользуетесь этой структурой.
[09:37.620 --> 09:40.620]  Соответственно, для того, чтобы
[09:40.620 --> 09:43.620]  вам нужно явно показать, что тип
[09:43.620 --> 09:46.620]  является копией, либо указать явно, что тип
[09:46.620 --> 09:49.620]  является клоуном. Возможно, даже имплементирует
[09:49.620 --> 09:52.620]  механику клонирования, если она у вас особенная.
[09:52.620 --> 09:55.620]  Примерно понятно объяснил?
[09:55.620 --> 09:58.620]  Особенная механика это,
[09:58.620 --> 10:01.620]  давай на следующей лекции, у нас там будет
[10:01.620 --> 10:04.620]  TradeClone, мы прямо посмотрим на функцию клонирования.
[10:04.620 --> 10:07.620]  Вот, а сами разница между CopyClone.
[10:07.620 --> 10:10.620]  Тут он пишет, что он
[10:10.620 --> 10:13.620]  move-нул, потому что не реализовал CopyTrade.
[10:13.620 --> 10:16.620]  То есть, если бы мы его реализовали, он бы move-нул?
[10:16.620 --> 10:19.620]  Нет, на самом деле он бы просто скопировал.
[10:19.620 --> 10:22.620]  Да, он понимает, что это дешевая структурка,
[10:22.620 --> 10:25.620]  но почему бы ее в сумму просто не скопировать?
[10:25.620 --> 10:28.620]  И он ее скопирует, и дальше он посмотрит, и дальше используется.
[10:28.620 --> 10:31.620]  Значит, у нас будет здесь Copy.
[10:31.620 --> 10:34.620]  Я не могу понять, например, зачем, но если мы хотим
[10:34.620 --> 10:37.620]  именно move-нуть, то это никак не сделаем.
[10:37.620 --> 10:40.620]  А именно move-нуть то, что Copy?
[10:40.620 --> 10:43.620]  Чтобы он не Copy, не копировал.
[10:43.620 --> 10:46.620]  Кажется, это невозможно.
[10:46.620 --> 10:49.620]  То есть, если Copy, тогда это обязательно какая-то дешевая штука.
[10:59.620 --> 11:02.620]  Может быть только у подтипов?
[11:02.620 --> 11:05.620]  Копии может быть не у произвольного типа.
[11:05.620 --> 11:08.620]  Копии, конечно, это бы на третьей лекции рассказывать,
[11:08.620 --> 11:11.620]  но вообще это маркерный трейд.
[11:11.620 --> 11:14.620]  Он говорит Расту, вот эту структурку нужно просто
[11:14.620 --> 11:17.620]  по байту скопировать, сделать нам мем-код.
[11:17.620 --> 11:20.620]  И все.
[11:20.620 --> 11:23.620]  То есть, если вы что-то хотите более произвольное,
[11:23.620 --> 11:26.620]  там более сложная структурка, тогда вы можете
[11:26.620 --> 11:29.620]  сделать мем-код.
[11:29.620 --> 11:32.620]  То есть, если вы что-то хотите более произвольное,
[11:32.620 --> 11:35.620]  там более сложная структурка, тогда обязательно Copy.
[11:35.620 --> 11:38.620]  Примерно ответил на вопрос,
[11:38.620 --> 11:41.620]  или я все-таки неправильно тебя понял?
[11:41.620 --> 11:44.620]  Мы можем написать дирайв-копии у конституции,
[11:44.620 --> 11:47.620]  и так будет работать даже в сейфе.
[11:47.620 --> 11:50.620]  В плане, если ты написал?
[11:50.620 --> 11:53.620]  Ну, если у тебя там 10 интов,
[11:53.620 --> 11:56.620]  то ты можешь написать дирайв-копию,
[11:56.620 --> 11:59.620]  и она будет прекрасно работать.
[12:04.620 --> 12:07.620]  Ну, socket это уже такая вещь,
[12:07.620 --> 12:10.620]  которую даже планировать нельзя.
[12:10.620 --> 12:13.620]  Повтори, пожалуйста, еще раз.
[12:18.620 --> 12:21.620]  Да, мы не можем приметировать для стринга Copy.
[12:21.620 --> 12:24.620]  Там еще есть прикольная
[12:24.620 --> 12:27.620]  такая штука у трейтов, что вы τрейт
[12:27.620 --> 12:30.620]  можете имплементировать
[12:30.620 --> 12:33.620]  только для структуры, которую вы только что
[12:33.620 --> 12:36.620]  объявили. Либо для трейта,
[12:36.620 --> 12:50.880]  что вы только что объявили. То есть, имплементация трейта
[12:50.880 --> 12:52.360]  существует для одного, либо другого.
[12:52.360 --> 12:58.160]  про трейд. Вот, ну там, в общем, может быть, такая фигня, что у нас раз
[12:58.160 --> 13:02.100]  не будет знать какую функцию просто вызвать. Вы будете вызывать, например, клоун, и если
[13:02.100 --> 13:06.580]  у вас там клоун имплементирован для типа как-то по-другому, в другом
[13:06.580 --> 13:11.220]  библиотеке, в общем-то, крейте, то он не будет понимать, какую из двух вариантов
[13:11.220 --> 13:18.660]  вызвать. Ну, мы посмотрим на третью лекцию такой пример. Вот. Так, а вот с этим вот
[13:18.660 --> 13:22.380]  примером на слайдах есть вопрос?
[13:23.900 --> 13:28.900]  Просто с move и вот этим вот push, который у нас был.
[13:32.900 --> 13:40.380]  Да-да, у нас тут вот и push есть, и sum. То есть у нас вторая проблема, это то, что мы
[13:40.380 --> 13:50.140]  пытаемся еще со концом потом посчитать. Тут вообще лучше всего оптимальнее
[13:50.140 --> 13:56.580]  написать сумму так, чтобы она принимала на вход slices и 32. Это оптимально. Потому что
[13:56.580 --> 14:00.420]  тогда вы будете на слайсах работать и на векторах. Просто вектор можно будет передать по ссылке и все
[14:01.020 --> 14:08.020]  А slice не move-ается? А что еще? Slice не move-ается? Ну, то есть если бы у нас B было не электром, а slice-ом?
[14:08.020 --> 14:14.820]  Slice, ну, именно ссылочка slice move-ается, потому что это обычный копий-тип. Это
[14:14.820 --> 14:19.420]  просто два указателя, по сути, начало-конец где-то. Они отлично копируются и все.
[14:19.420 --> 14:26.420]  Ну вот, получается, если бы B было бы slice-ом, и мы бы сумму запихивали B, то он бы тоже move-ался.
[14:26.420 --> 14:33.500]  Если бы это было slice-ом, ну да, это бы работало, потому что на slice-у копий-тип. А можно как-то сказать не move-ой?
[14:33.500 --> 14:43.620]  Нельзя. Если это копия, то тогда копия. Все. То есть, ну, это дешевая тогда штука. Наверное,
[14:43.620 --> 14:49.660]  это, кажется, вопрос, который вызывает самые обширные у вас эмоции копии и клоун.
[14:49.660 --> 14:55.660]  Ну, клоун, понятно, но то, что он move-ает, когда он не хочется, это грустно.
[14:55.660 --> 14:58.940]  Ну, ты имеешь в виду...
[14:58.940 --> 15:04.660]  Если ты допускаешь копирование, то ты его разрешаешь, и потом как-то выиграться с ним как хочешь.
[15:04.660 --> 15:07.660]  Потому что это значит какое-то странное применение.
[15:07.660 --> 15:18.100]  Так, давайте мы поговорим о правилах вообще владения. У нас до этого были такие примеры, что у нас
[15:18.100 --> 15:24.460]  был владеющий, например, вектор. Владеющий вектор, мы его move-аем отсюда, и теперь мы не можем
[15:24.460 --> 15:29.140]  с ним взаимодействовать. До этого у нас был пример, что, опять же, владеющий вектор, мы берем на него
[15:29.140 --> 15:36.780]  ссылочку, а теперь мы пытаемся его изменить. То есть у нас v — это владеющий тип здесь является.
[15:36.780 --> 15:47.380]  Сейчас я покажу более хороший пример. У нас у каждого значения в расти есть один момент времени,
[15:47.780 --> 15:55.380]  owner, владелец. Owner — это тот, кто владеет аллокацией на объект. То есть он, как все плюс-плюс, если у вас есть
[15:55.380 --> 16:02.860]  какой-то тип STD-вектор, то в таком случае он ответственный за то, чтобы очистить за собой память.
[16:02.860 --> 16:11.380]  В один момент времени может быть только один owner. Понятным причинам, потому что иначе мы бы могли,
[16:11.380 --> 16:18.740]  например, дважды освободить память. Ну и вот когда у нас owner уходит из копота, в таком случае у нас
[16:18.740 --> 16:29.300]  сам owner дропается, то есть становится неволидным значением. Вот смотрите, у нас есть какой-то вектор,
[16:29.300 --> 16:36.380]  потом у нас есть u, равняется s. И смотрите, в данном случае у нас владение этим вот векторами,
[16:36.380 --> 16:47.140]  за 1,488, передается в u. И в таком случае, когда мы пытаемся запринтить u, это отлично сработает,
[16:47.140 --> 16:52.420]  а когда мы пытаемся запринтить s, то в таком случае у нас уже будет ошибка, потому что мы передали владение.
[16:52.420 --> 17:01.100]  Ладно, ошибка комбинации не вставил в слайды, но вот в общем-то он скажет, что это не работает,
[17:01.100 --> 17:07.420]  потому что уже s, как бы деинтилизированная переменная, владение было передано u.
[17:07.420 --> 17:17.420]  Вот, то есть вот запомните то, что у нас до этого было self, те, что просто значение типа t, они все
[17:17.420 --> 17:28.780]  владеющие, они владеют локацией, они владеют объектом. Вот. Так, ну это еще раз мы повторяем,
[17:28.780 --> 17:39.060]  у нас есть правило ownership. Каждый владелец имеет право, у него есть ответственность очистить за
[17:39.060 --> 17:46.420]  собой память. Это мы поговорили. И потом дальше пример. Когда мы что-то move в s, то вот это вот s
[17:46.420 --> 17:52.540]  внутри становится, собственно, владельцем. То есть мы move-нули, соответственно, у нас уже s не
[17:52.540 --> 18:02.740]  владелец внутри функции. Так? Технически получается, что s это у нас own теперь. Ну и, соответственно,
[18:02.740 --> 18:08.780]  мы не можем это не использовать. А вот c++, опять же, мы здесь в этом моменте создадим копию.
[18:08.780 --> 18:22.780]  Да, получается, что у нас было s вот это вот, и мы его передали во владение вот сюда.
[18:22.780 --> 18:38.140]  Да, он скажет, что я там съел s, да, и после этого, где вот эта закрывающая скобочка,
[18:38.140 --> 18:44.580]  он уже дропнет, собственно, сам s, и все. То есть того же самого в плюсах можно было бы добиться,
[18:44.580 --> 18:55.060]  если бы вы сделали steady move. То же самое произошло бы. Абсолютно. Так. Ну и, опять же,
[18:55.060 --> 19:01.940]  вот, вспомним про копии clone. Посмотрим вот на то, что здесь происходит. У нас есть какой-то int n,
[19:01.940 --> 19:09.540]  потом мы делаем m равное n, и абсолютно спокойно и n, и m, и, в общем-то, и выводим. Ну как,
[19:09.540 --> 19:15.700]  уже десять раз мы в этом поговорили. Скажите, в чем проблема, почему это работает возле счет
[19:15.700 --> 19:23.900]  вектора? Верно, потому что это копия типа. То есть, ну, они вот копируются абсолютно спокойно,
[19:23.900 --> 19:35.260]  и, соответственно, оно работает не так, как у нас должен был бы работать вектор. Так. И еще давайте
[19:35.260 --> 19:41.620]  теперь подумаем про ссылочки. Давайте представим такую вымышленную ситуацию, что у нас есть группы
[19:41.620 --> 19:49.140]  каких-то юристов, которые смотрят на какой-то контракт в Google Docs. Кто-то пытается его
[19:49.140 --> 19:56.460]  подписать, кто-то его пытается заревьюить, да. И какие мы должны установить правила для того,
[19:56.460 --> 20:01.940]  чтобы у нас не получился хаос. То есть, что кто-то нашел ошибку, а другой уже подписал, например,
[20:01.940 --> 20:09.780]  контракт. Что-нибудь вот такое вот. Это будет нормально, если мы будем модифицировать до того,
[20:09.780 --> 20:18.260]  как, ну, сейчас-сейчас. Если мы будем модифицировать наш контракт до того,
[20:18.260 --> 20:23.460]  как его кто-то подпишет, тогда это нормально. Но если кто-то подпишет его, а потом мы будем
[20:23.460 --> 20:31.780]  модифицировать, то это уже плохо. Ну, чем-то напоминает конкарнти, да. Соответственно,
[20:31.780 --> 20:38.100]  мы должны разрешить только одному человеку одновременно менять, либо всем читать. Похоже
[20:38.100 --> 20:44.460]  на конкарнти, да. Вот какие-то, если вы помните курс, что у нас есть. Часто мы хотим,
[20:44.460 --> 20:52.340]  чтобы у нас только один кто-то менял, либо много кто читал. Так, у нас получилось два
[20:52.340 --> 21:01.180]  немного слабее, но не важно. Таким образом, мы хотим, ну, вот если мы это как-то сформулируем в
[21:01.180 --> 21:07.940]  терминах языков программирования, то мы хотим иметь либо сколько угодно константных указателей,
[21:07.940 --> 21:14.820]  либо если у меня есть какой-то неконстантный указатель, то есть мутабельный, то в таком случае
[21:14.820 --> 21:23.940]  мы, как сказать, в таком случае это может инвалидировать константные указатели другие,
[21:23.940 --> 21:30.060]  которые у нас уже есть. Так, давайте чуть-чуть приостановимся, все ли понятно пока что,
[21:30.060 --> 21:39.740]  что я говорю. Смотри, если у нас есть константные указатели, их может быть сколько угодно,
[21:39.740 --> 21:44.620]  а если у нас есть кто-то, кто умеет модифицировать, то есть мутабельные, ну, указатель,
[21:44.620 --> 21:49.060]  который умеет мутировать, то это уже плохо, да. То есть мы просто попробовали интуицию перенести на
[21:49.060 --> 21:58.620]  языки программирования сейчас. Так. Соответственно, если у меня в любом момент ремни не больше такого,
[21:58.620 --> 22:07.540]  не больше одного неконстантного указателя, то это должно быть окей, хорошо. Так, теперь давайте
[22:07.540 --> 22:14.700]  вообще в термных раз тогда поговорим. У нас может быть сколько угодно немутабельных ссылок в любой
[22:14.700 --> 22:20.020]  момент времени, то есть за то, что мы брали просто амперсандик, это просто ссылка. Мы могли сколько
[22:20.020 --> 22:25.420]  угодно раз в векторе взять на элементы, ссылки обычные, там на B0 хоть десять раз берите,
[22:25.420 --> 22:37.380]  такую ссылочку. Потом. Но мы можем иметь только одну мутабельную ссылку за раз. И это уже на самом
[22:37.380 --> 22:42.820]  деле важно, потому что если мы, например, возьмем мутабельную ссылочку на B0, то в таком случае
[22:42.820 --> 22:48.300]  взять немутабельную ссылочку мы уже не сможем, потому что она ожидает того, что элемент не будет
[22:48.300 --> 22:53.820]  меняться. Вот так мы сможем его поменять. И, соответственно, в Rust появляется контракт,
[22:53.820 --> 22:59.700]  что у нас в любой момент времени есть либо одна мутабельная ссылка, либо много немутабельных
[22:59.700 --> 23:09.140]  обычных ссылок. То есть как раз либо один писатель, либо много читателей. Это вот как раз то,
[23:09.140 --> 23:20.300]  что мы, типа, MSO изучали и то, что у нас возникает у Rust. Так. Потом у нас есть такое понятие,
[23:20.300 --> 23:28.860]  как lifetime значение. Lifetime это, ну, пока что давайте мы конкретно этом слайде подумаем про это,
[23:28.860 --> 23:37.540]  как про scope, чуть более упрощенно. Ну, вот мы видели, как у нас виктора, например, когда выходит за
[23:37.540 --> 23:44.020]  границы scope, то они дропаются. Например, когда мы move им какую-то функцию, тогда у них заканчивается
[23:44.020 --> 23:56.980]  их lifetime. В общем, lifetime значение заканчивается, оно дропается. Соответственно, Rust не разрешает
[23:56.980 --> 24:04.660]  вам иметь ссылки, которые имеют больше lifetime, чем само значение живет, само уноразначение живет,
[24:04.660 --> 24:14.580]  потому что иначе у вас будет висяча ссылка. Так. Потом Rust это очень хитрая такая штука,
[24:14.580 --> 24:19.700]  она проверяет lifetime прямо в compile time. Мы очень подробно будем говорить про lifetime в какой-то
[24:19.700 --> 24:25.580]  момент попозже, где-то около шестой лекции. Пока что мы посмотрим такую интуицию скорее.
[24:25.580 --> 24:33.580]  Естественно, когда мы вычисляем lifetime на этапе компиляции, вот есть такая проблема у всяких
[24:33.580 --> 24:41.500]  статических инструментов, что они частенько дают ложноположительное срабатывание. Ну, то есть,
[24:41.500 --> 24:47.100]  если у нас, ну, код может быть валидным, но при этом он не скомпилируется, потому что раз подумаешь,
[24:47.100 --> 24:52.540]  что что-то в нем не так. В роучекер со временем становится умнее, и он начинает пропускать какие-то
[24:52.540 --> 24:58.980]  вещи. Например, вы могли видеть, как Андрей разов в чате скидывал пример того, как в
[24:58.980 --> 25:06.180]  Knightly компилятор у него что-то компилировалось с каким-то флагом, а без этого всего не компилировалось
[25:06.180 --> 25:13.300]  тейбл. Здесь как раз пример того, как роучекер становится умнее со временем. То есть, соответственно,
[25:13.300 --> 25:17.940]  возможно, когда-нибудь он практически не будет реджектировать правильный код, но сейчас пока что
[25:17.940 --> 25:24.420]  иногда приходится с роучекером как-то дружить и находить какие-то входные пути. Раньше прямо
[25:24.420 --> 25:30.460]  часто приходилось. Сейчас уже, я бы не сказал, что часто, но бывает такое. Например, там всякие временные
[25:30.460 --> 25:36.460]  переменные. Иногда приходится сначала объявить временную переменную, потом, например, у нее взять
[25:36.460 --> 25:45.500]  итератор, просто чтобы она жила достаточно долго. Ну и, соответственно, вот последняя строчка у нас
[25:45.500 --> 25:52.500]  раст вызывает специальную функцию drop, когда у нас lifetime заканчивается. Вот то, что называется в
[25:52.500 --> 25:59.140]  расти drop, это как раз наш деструктор в плюсах. Просто у него другое название. Там, конечно, есть еще
[25:59.140 --> 26:07.860]  небольшие нюансы, но мы их посмотрим успеем. В принципе, это деструктор просто. Как
[26:07.860 --> 26:15.140]  имплементировать drop? Как вы думаете? То есть вот мы написали, и после этой строчки я ожидаю,
[26:15.140 --> 26:23.700]  что drop скажет, что, в общем-то, если, например, я попробую у вектора взять нулевой элемент,
[26:23.700 --> 26:31.900]  то в таком случае это не должно скомпилироваться. Я хочу, чтобы у меня drop было значение. Да, правильно,
[26:31.900 --> 26:40.140]  это нужно просто узнать функцию. А какая будет сигнатура? Нет-нет-нет, все очень-очень просто,
[26:40.140 --> 26:56.300]  Андрей, это же раст. Да, self, давай вспомним, что не self является, скажем так. Ну, чтобы мы приняли
[26:56.300 --> 27:07.100]  любой аргумент, а не просто именно саму структуру. Так, давайте подскажем, нам просто по значению,
[27:07.100 --> 27:14.740]  грубо говоря, принятия надо, ничего внутренне делать. Как написать такой drop? Смотри, вот я хочу,
[27:14.740 --> 27:22.540]  чтобы после этого я написал век 0, мне сказал раст, а я и век уже, век съели. Да, и мы хотим
[27:22.540 --> 27:24.540]  просто drop имплементировать.
[27:52.540 --> 28:02.540]  Конечно, это не век, вот это drop, self, это общий. А, черт, я не написал генерику. Ну, тут это тоже нормально, в принципе.
[28:02.540 --> 28:08.900]  Ну, если это в генерике, то будет то же самое, что ты сказал, просто будет drop t, внутри будет
[28:08.900 --> 28:14.540]  какое-то value t. Внутри будет такая пустая имплементация, просто ничего не будет абсолютно.
[28:14.540 --> 28:20.540]  Ну, естественно, просто move не туда, раст, ничего с этим не сделай, и все будет хорошо. В общем, то, что мы хотим.
[28:21.540 --> 28:23.540]  Да.
[28:27.540 --> 28:32.540]  Да, он просто все так вот имплементирован, drop ничего не делает. Он даже по-дефолту это...
[28:32.540 --> 28:41.540]  в std-прилют, это то, что у нас по-дефолту раст импортит, он даже есть, просто вот, можно вот так вот написать в коде, drop из значения.
[28:41.540 --> 28:43.540]  И он будет вот так вот работать.
[28:47.540 --> 28:49.540]  Да, он просто съедает.
[28:51.540 --> 28:56.540]  Да. Ну, он диалоцируется прям, все, drop вот.
[29:15.540 --> 29:17.540]  Не, при выходе из кова по drop происходит.
[29:21.540 --> 29:23.540]  Мы применили по значению.
[29:24.540 --> 29:28.540]  Ты про то, как вообще раз понимаешь, что он уже drop-нет, drop-нет по значению.
[29:29.540 --> 29:32.540]  Когда, конечно, происходит локация, если у нас вообще ничего не оптимизируется?
[29:32.540 --> 29:34.540]  Это, кажется, диалокация, наверное.
[29:35.540 --> 29:42.540]  Вот смотрите, мы говорим, что по выходу из скопа у нас происходит drop, и по выходу из скопа у нас происходит диалокация.
[29:42.540 --> 29:44.540]  Поэтому если мы напишем так drop...
[29:44.540 --> 29:49.540]  Не, ну диалокация, то, что я имел в виду диалокация, это как раз drop происходит.
[29:49.540 --> 29:52.540]  Drop, на самом деле, когда что-то съедается, он там...
[29:52.540 --> 29:54.540]  То, почему drop рекурсивно...
[29:54.540 --> 29:56.540]  Почему рекурсивно называется drop?
[29:56.540 --> 29:59.540]  Почему не происходит цепочки после...
[29:59.540 --> 30:02.540]  А, почему drop не вызывает drop от полей?
[30:02.540 --> 30:04.540]  Нет, нет.
[30:04.540 --> 30:07.540]  Там тоже заканчивается область видимости.
[30:07.540 --> 30:10.540]  И в конце области видимости функции drop должен вызваться drop.
[30:11.540 --> 30:14.540]  А, ну это опять же, это то, что я проговорил...
[30:15.540 --> 30:21.540]  Я вот спросил вслух, это про то, как раз определяет, что нужно переменной drop-ать вопрос.
[30:21.540 --> 30:23.540]  Да?
[30:23.540 --> 30:25.540]  Там есть drop flex.
[30:25.540 --> 30:27.540]  Мы сейчас поговорим, там есть drop flex.
[30:27.540 --> 30:32.540]  Такая штука, это битки на стеке, за счет которых раз понимает, что что-то drop не то.
[30:32.540 --> 30:35.540]  Конкретно в данном случае, конечно, ему даже битки на стеке не понадобится.
[30:35.540 --> 30:38.540]  Он просто поймет, что вектор диалацируется раньше, потому что все линейно.
[30:38.540 --> 30:41.540]  А если там будет нелинейный код, то там будут флаги.
[30:41.540 --> 30:43.540]  Ну, мы сейчас посмотрим.
[30:44.540 --> 30:51.540]  Что происходит с self, когда мы заканчиваем drop?
[30:52.540 --> 30:56.540]  Смотри, внутри drop-а у тебя должна быть какая-то произвольная логика.
[30:56.540 --> 30:58.540]  На самом деле drop- это тоже trade какой-то.
[31:00.540 --> 31:02.540]  По умолчанию в нем ничего нет.
[31:02.540 --> 31:05.540]  Просто пустая имплементация, в которую запускается self.
[31:05.540 --> 31:09.540]  Когда self умирает, у нас же self-владейший объект, владейший объект умер.
[31:09.540 --> 31:11.540]  Просто понимает, ага, нужна диалокация.
[31:11.540 --> 31:14.540]  Он запускает диалокацию, но drop от всех полей.
[31:14.540 --> 31:17.540]  Ну и диалокацию, соответственно.
[31:19.540 --> 31:24.540]  По ходу drop- это какая-то магическая вещь, которая усиленно drop не допускает.
[31:24.540 --> 31:26.540]  Ну, усиленно от того же объекта.
[31:26.540 --> 31:32.540]  Ну да, видимо раз отличается, что это именно drop, а не какая-то другая функция.
[31:32.540 --> 31:35.540]  Наверное, вот этот drop- это все-таки пользуется?
[31:35.540 --> 31:39.540]  Это в любом случае пользуется функцией, потому что она уже есть в дублятеке.
[31:39.540 --> 31:43.540]  Это не то, что конкретно подставляет книг-копы.
[31:43.540 --> 31:45.540]  Он явно это подставляет.
[31:45.540 --> 31:47.540]  Но не это же drop, есть в ОМВ.
[31:47.540 --> 31:50.540]  Да, но там drop-ы вызывают trade-овый.
[31:50.540 --> 31:54.540]  Короче, свой библиотечный, но он вызывает drop, действительно.
[31:54.540 --> 32:00.540]  Мы сейчас это увидим, дальше как раз будут примеры про drop flex и все такое.
[32:00.540 --> 32:04.540]  Надеюсь, давайте мы попробуем сейчас приостановить вопросы, пойдем дальше.
[32:04.540 --> 32:08.540]  Посмотрим другие примеры, если вопросы останутся, продолжим на тех слайдах обсуждать.
[32:08.540 --> 32:16.540]  Так, вот как раз вопрос про drop flex.
[32:16.540 --> 32:18.540]  Вот у нас бокс.
[32:18.540 --> 32:20.540]  Бокс, насколько мы помним, это что-то на хиппе.
[32:20.540 --> 32:28.540]  То есть это, грубо говоря, int, указатель на int x, равняется new int 92.
[32:28.540 --> 32:32.540]  А можно прятаться над знанием шляпки бокса?
[32:32.540 --> 32:36.540]  Бокс это просто, это как юник-пойнтер, только без нула.
[32:36.540 --> 32:38.540]  Обязательно не нул.
[32:38.540 --> 32:42.540]  Потом мы какое-то условие проверяем.
[32:42.540 --> 32:48.540]  В зависимости от условий либо y при своем значении x, либо z при своем значении x.
[32:48.540 --> 32:50.540]  Это будет компилироваться, это будет работать.
[32:50.540 --> 32:56.540]  Но как раз-то понять, что ему надо диалоцировать, y или z?
[32:56.540 --> 33:01.540]  Тут, конечно, он пользуется невидимыми флагами, такими на стеке.
[33:01.540 --> 33:06.540]  Он указывает, какая переменная была инициализирована из двух.
[33:06.540 --> 33:10.540]  Соответственно, либо y он будет диалоцировать, либо z.
[33:10.540 --> 33:14.540]  В зависимости от того, какая из них инициализирована.
[33:14.540 --> 33:17.540]  А это все уже в рентале?
[33:17.540 --> 33:19.540]  Ну, конечно, в рентале.
[33:19.540 --> 33:22.540]  Диалокация, но локация-диалокация, это все рентально.
[33:22.540 --> 33:26.540]  Ну, он же не может заранее по условию понять.
[33:26.540 --> 33:30.540]  Ну, если оно, конечно, константное, он это соптимизирует.
[33:30.540 --> 33:34.540]  Но если не константное, например, в зависимости от какого-то инпота, то он уже не поймет.
[33:34.540 --> 33:36.540]  Ему нужно не поймать.
[33:36.540 --> 33:38.540]  А если после этого кода мы напишем print z?
[33:38.540 --> 33:41.540]  Он будет ругаться на то, что я использую инициализируем?
[33:41.540 --> 33:46.540]  Да, он скажет, что она maybe initialized.
[33:46.540 --> 33:48.540]  Ну, конечно, такой код лучше не писать.
[33:48.540 --> 33:50.540]  Лучше написать там, не знаю, в рентале.
[33:50.540 --> 33:51.540]  Лучше не писать.
[33:51.540 --> 33:56.540]  Лучше написать там, не знаю, let t равняется if condition x.
[33:56.540 --> 33:58.540]  Хотя там в любом случае x уравняется.
[33:58.540 --> 34:00.540]  Поэтому код в любом случае странный.
[34:00.540 --> 34:04.540]  Вообще это странная фигня, потому что у нас нет муд, как минимум.
[34:06.540 --> 34:08.540]  В плане нет муд.
[34:08.540 --> 34:11.540]  У нас RAST позволяет просто неинтилизированное переменное создавать.
[34:11.540 --> 34:13.540]  Там есть несколько этапов.
[34:13.540 --> 34:15.540]  Есть это pattern matching вообще.
[34:15.540 --> 34:17.540]  Да, это правда.
[34:17.540 --> 34:20.540]  Я как-то не понимаю, что он здесь делал и почему это работает.
[34:20.540 --> 34:25.540]  Ну, когда он let y, он просто создает неинтилизированную переменную.
[34:25.540 --> 34:28.540]  Там есть несколько этапов в жизни перемен.
[34:28.540 --> 34:30.540]  Неинтилизированная, неинтилизированная не используется,
[34:30.540 --> 34:33.540]  инициализированная используется, и потом диалацирована.
[34:33.540 --> 34:36.540]  Какого типа неинтилизированного?
[34:36.540 --> 34:39.540]  Ну, смотря какой ты укажешь.
[34:39.540 --> 34:43.540]  Ну, то есть либо ты какой укажешь, либо какой выведет RAST с помощью type inference.
[34:43.540 --> 34:44.540]  А если он не может вымесить?
[34:44.540 --> 34:46.540]  Он пожалуется на тебя.
[34:46.540 --> 34:48.540]  Годей.
[34:48.540 --> 34:51.540]  Скажет, я сам не могу, укажешь мне какой тип.
[34:55.540 --> 34:57.540]  Ну, просто в любом случае тогда не будет знать,
[34:57.540 --> 35:00.540]  сколько ему нужно на стейки байтов выделить.
[35:06.540 --> 35:09.540]  Вот это вот, кстати, прекрасный пример с такой прекрасной книжки.
[35:09.540 --> 35:11.540]  Называется RAST for Ostasians.
[35:11.540 --> 35:14.540]  Если у вас есть прям фанатизм RAST, то я очень рекомендую эту книжку.
[35:14.540 --> 35:19.540]  она очень глубокая и в ней очень много полезного материала.
[35:19.540 --> 35:21.420]  Давайте мы посмотрим такую вот штуку.
[35:21.420 --> 35:26.340]  Мы создаем применную x, потом мы присваиваем значение,
[35:26.340 --> 35:28.980]  мы пока что не обращаем внимания на комментарии.
[35:28.980 --> 35:32.420]  x присваиваем значение 42, потом у нас y это какая-то
[35:32.420 --> 35:38.940]  ссылка на x, и к сумму присваиваем значение 43, и это компилируется.
[35:38.940 --> 35:44.300]  И примерим, что ссылка на y равняется 42.
[35:44.300 --> 35:46.500]  Как же это работает?
[35:46.500 --> 35:47.820]  Это все добро.
[35:47.820 --> 35:53.620]  Почему оно компилируется?
[35:53.620 --> 36:00.980]  Ну, это на самом деле не помнится.
[36:00.980 --> 36:03.420]  На самом деле давайте мы подумаем, как Borrow Checker.
[36:03.420 --> 36:04.700]  Да, это он говорил упрощенно.
[36:04.700 --> 36:08.220]  Вот у нас есть какие-то скопы, в которых все что-то проверяет раз,
[36:08.260 --> 36:10.460]  что у нас время lifetime это scope.
[36:10.460 --> 36:14.660]  На самом деле lifetime это целый flow, то есть вы знаете control flow, что такое,
[36:14.660 --> 36:19.940]  да, там UEFI, например, вы либо в одну веточку пошли, либо в другую, да.
[36:19.940 --> 36:26.260]  Да, и вот по сути то, что проверяет раз, это на самом деле не просто scope, а целый flow.
[36:26.260 --> 36:29.700]  То есть то, куда может пойти переменная, и где она может деинцелидироваться,
[36:29.700 --> 36:32.060]  всевозможные варианты.
[36:32.060 --> 36:38.060]  У нас разве не было гарантий, что у нас в одно время может быть либо мутабельная ссылка, либо...
[36:38.060 --> 36:43.060]  А мы сейчас как раз проверим, почему это компилируется, мы прямо увидим.
[36:43.060 --> 36:50.660]  Мы сейчас проговорим, как она там работает, эти flow, да, какое у нас есть.
[36:50.660 --> 36:54.340]  Так, смотрите, для начала у нас есть первая штука.
[36:54.340 --> 36:58.100]  Мы сначала пытаемся X присваивать значение...
[36:58.100 --> 37:03.140]  Давайте так, sRTQLX42, это, естественно, не сработает, потому что раз, понимаете,
[37:03.140 --> 37:09.700]  X дальше используется, соответственно, как минимум вот такой вот у него будет flow,
[37:09.700 --> 37:12.780]  то есть он будет жить вот в этот момент.
[37:12.780 --> 37:16.540]  И в этот момент X обязательно будет неинцелизирован.
[37:16.540 --> 37:22.420]  Раз, пожалуй, он скажет, что он пользуется неинцелизированной переменной.
[37:22.420 --> 37:27.500]  Да, он просто не скомпилирует этот код, он скажет, что X неинцелизирован, как же так.
[37:27.500 --> 37:31.860]  То есть, например, в СИБе этот код скомпилировался, и мы бы могли потенциально получить CV-шку
[37:31.860 --> 37:36.460]  с прошлой лекции, которую я показывал как раз.
[37:36.460 --> 37:38.060]  Вот.
[37:38.060 --> 37:41.260]  Потом дальше.
[37:41.260 --> 37:46.340]  Мы можем, естественно, взять ссылочку на X, потому что у нас X все еще живет.
[37:46.340 --> 37:51.660]  X у нас, как мы видим, живет вот аж до этого момента, да.
[37:51.660 --> 37:59.820]  Это окей, потому что мы можем взять из этого flow, то есть взять ссылочку на X и присваивать значение Y.
[37:59.820 --> 38:07.820]  Y в таком случае имеет тип ссылка на Y32.
[38:07.820 --> 38:14.900]  И вот это вот уже здесь создается второй мутабельный flow.
[38:14.900 --> 38:19.660]  То есть у нас flow до этого был не мутабельный, а сейчас он становится мутабельный.
[38:19.660 --> 38:22.820]  И это важно, у нас два типа flow.
[38:22.820 --> 38:25.500]  Flow может быть не мутабельным, flow может быть мутабельным.
[38:25.500 --> 38:29.900]  То, что мы хотим, это чтобы не пересекались два мутабельных flow одновременно.
[38:29.900 --> 38:35.300]  Сколько угодно не мутабельных, мы не хотим, чтобы пересекалось много мутабельных одновременно.
[38:35.300 --> 38:43.100]  Иначе мы нарушим гарантии раста.
[38:43.100 --> 38:48.300]  Да, до этого у нас просто был X, но мы инцелизировали перемен, но это пока что не мутабельность.
[38:48.300 --> 38:50.500]  Просто инцелизация переменной.
[38:50.500 --> 38:54.380]  Вот мы берем какую-то ссылку, а дальше мы уже начинаем мутировать.
[38:54.380 --> 38:59.260]  Соответственно, раст уже такой, ага, значит мы у нас мутируем переменную, мутабельный flow.
[38:59.260 --> 39:06.460]  Но нужно, чтобы у нас в этот момент ссылочки не жили, которые у нас обычные.
[39:06.460 --> 39:09.380]  Так, дальше вот будет момент, сейчас мне самому нужно вспомнить.
[39:09.380 --> 39:16.380]  Вот так.
[39:16.380 --> 39:19.380]  Так, ну вот мы как раз вот делали все.
[39:19.380 --> 39:29.380]  Так, а почему это, почему это так?
[39:29.380 --> 39:31.380]  Просто вроде бы мы изменили X.
[39:31.380 --> 39:34.380]  Сейчас, секундочку, я вот сам запутался.
[39:34.380 --> 39:38.380]  И при этом у нас мутабельный flow, у нас вроде бы закончился.
[39:38.380 --> 39:47.380]  Но дальше я не совсем понимаю, почему у нас тогда вот это вот так сердце работает на 42.
[39:47.380 --> 39:51.380]  Да, у нас все-таки два объекта, и у них разные омеры.
[39:51.380 --> 39:56.380]  Может быть, все-таки 223 разные объекты, если считать.
[39:56.380 --> 40:00.380]  Ну или кто-то у нас ссылается на один тот же X.
[40:00.380 --> 40:02.380]  Не, не ссылается, да, на один тот же X.
[40:02.380 --> 40:07.380]  Ссылка на X я вот сейчас, я сейчас чуть-чуть потерялся.
[40:24.380 --> 40:26.380]  Так, знаете, я вот пока что запутался.
[40:26.380 --> 40:29.380]  Давайте я потом пересмотрю в книжке, почему это работает.
[40:29.380 --> 40:31.380]  Просто наскажу, подзабыл.
[40:35.380 --> 40:37.380]  Ну посмотрим сейчас.
[40:37.380 --> 40:40.380]  Ну не сейчас, а переменка будет, она буквально совсем скоро.
[40:40.380 --> 40:42.380]  Я посмотрю в книжечке, я вам сразу же отвечу.
[40:42.380 --> 40:44.380]  Свернемся к этому слайду, вернемся.
[40:44.380 --> 40:48.380]  Просто я не пересмотрел эти слайды, если честно, и в итоге вот сейчас путаюсь.
[40:48.380 --> 40:50.380]  Все хорошо с таким решением, да?
[40:50.380 --> 40:53.380]  Все равно отвечу на ваш вопрос, просто чуть попозже.
[40:53.380 --> 40:55.380]  Вот.
[40:56.380 --> 40:58.380]  Так.
[40:58.380 --> 41:00.380]  Потом у нас есть X1 равное 42.
[41:00.380 --> 41:01.380]  Так.
[41:01.380 --> 41:04.380]  Потом у нас Y1 это какой-то бокс.
[41:04.380 --> 41:06.380]  У нас он создает новый скоп.
[41:06.380 --> 41:08.380]  Ну он создается новый скоп.
[41:08.380 --> 41:10.380]  У нас можно делать точно так же, как в плюсах, скажем.
[41:10.380 --> 41:13.380]  То есть вот такое создание скопа.
[41:13.380 --> 41:18.380]  Внутри у нас есть Z, которое состоит из X1 и Y1.
[41:18.380 --> 41:24.380]  И так как оно выходит из этого скопа, оно должно быть дропнуто.
[41:24.380 --> 41:28.380]  Ну и соответственно он дропает X1 на X2.
[41:31.380 --> 41:32.380]  Так.
[41:32.380 --> 41:37.380]  Ну и соответственно, так как X1 это копит, в таком случае оно не было мувнуто в Z.
[41:37.380 --> 41:42.380]  То есть оно было там внутри, где тюпол, оно было скопировано.
[41:42.380 --> 41:46.380]  Поэтому у нас будет работать X2 равнятия X1.
[41:46.380 --> 41:50.380]  Но при этом сделать Y2 равнятия Y1 мы не сможем.
[41:50.380 --> 41:54.380]  Потому что у нас бокс это не копий тип.
[41:54.380 --> 41:57.380]  И раз, соответственно, это как-то не скомпилирует.
[41:57.380 --> 41:59.380]  Потому что мы мувнули на третью тюпол.
[41:59.380 --> 42:01.380]  Этот пример достаточно простой.
[42:01.380 --> 42:03.380]  Мы уже много раз говорили про копийку.
[42:08.380 --> 42:11.380]  Да, Y1 мы муваем, а X1 мы копируем.
[42:11.380 --> 42:15.380]  И вот получается, на этом первая лекция у нас заканчивается.
[42:18.380 --> 42:19.380]  Так.
[42:19.380 --> 42:23.380]  Ну, в общем-то мы на нее успели узнать, почему у нас...
[42:23.380 --> 42:25.380]  Раз тут.
[42:25.380 --> 42:27.380]  Который вот этот?
[42:27.380 --> 42:29.380]  Сейчас.
[42:29.380 --> 42:30.380]  Вот этот?
[42:30.380 --> 42:31.380]  Значит там...
[42:31.380 --> 42:33.380]  А попробуй сорок раз.
[42:33.380 --> 42:35.380]  Ну, в общем-то, мы на нее успели узнать, почему у нас...
[42:35.380 --> 42:37.380]  Раз тут.
[42:37.380 --> 42:39.380]  Который вот этот?
[42:39.380 --> 42:40.380]  Значит там...
[42:40.380 --> 42:42.380]  А попробуй сорок три поставить.
[42:42.380 --> 42:44.380]  Или там как-то другая ошибка.
[43:09.380 --> 43:12.380]  В общем, давай я посмотрю это конкретно на переменке.
[43:12.380 --> 43:14.380]  И прямо вот хорошо объясню.
[43:14.380 --> 43:16.380]  Что здесь произошло.
[43:16.380 --> 43:18.380]  Вот прямо останемся на этом слайде.
[43:18.380 --> 43:20.380]  И передвинемся к следующему.
[43:28.380 --> 43:31.380]  Ну, давайте, может, чуть-чуть еще позанимаемся.
[43:31.380 --> 43:33.380]  Потому что еще только шесть, прошло меньше часа.
[43:33.380 --> 43:35.380]  Ну, давайте, может, чуть-чуть еще позанимаемся.
[43:35.380 --> 43:37.380]  Потому что еще только шесть, прошло меньше часа.
[43:37.380 --> 43:39.380]  Потому что еще только шесть, прошло меньше часа.
[43:39.380 --> 43:41.380]  Ну, и потом перерывчик идем.
[43:41.380 --> 43:43.380]  Так.
[43:48.380 --> 43:50.380]  Так.
[43:50.380 --> 43:52.380]  Если мы пришли ко второй лекции,
[43:52.380 --> 43:54.380]  на ней мы поговорим про стандартную библиотеку РАСТа.
[43:54.380 --> 43:56.380]  И то, что она из себя представляет.
[43:56.380 --> 43:58.380]  И даже сравнимую с Пельсовой библиотекой.
[44:00.380 --> 44:02.380]  Что там у нее есть?
[44:08.380 --> 44:10.380]  Так.
[44:10.380 --> 44:13.380]  Конкретно мы посмотрим на опцион и результат.
[44:13.380 --> 44:15.380]  На век и век дек.
[44:15.380 --> 44:17.380]  Ну, соответственно, B3M, B3Set,
[44:17.380 --> 44:19.380]  HashMap и HashSet.
[44:19.380 --> 44:21.380]  Бинарная куча, LinkItList.
[44:21.380 --> 44:23.380]  Строка ее Slice.
[44:23.380 --> 44:25.380]  А еще, еще раз посмотрим.
[44:25.380 --> 44:27.380]  Чуть-чуть буквально на бокс.
[44:27.380 --> 44:29.380]  И на IRC.
[44:29.380 --> 44:31.380]  Вот.
[44:31.380 --> 44:33.380]  Это такие ключевые вещи
[44:33.380 --> 44:35.380]  в библиотеке РАСТа.
[44:35.380 --> 44:37.380]  И вы знаете писать какие-то вещи,
[44:37.380 --> 44:39.380]  которые связаны больше с алгоритмами.
[44:41.380 --> 44:43.380]  Так. Ну, начнем мы, конечно, с опцион и результат.
[44:43.380 --> 44:45.380]  Так. Вы же, наверное, встретились
[44:45.380 --> 44:47.380]  с ними в домашке. Особенно во второй домашке.
[44:49.380 --> 44:51.380]  Так.
[44:51.380 --> 44:53.380]  А что-что?
[44:53.380 --> 44:55.380]  Ну, как минимум, в ком точно было.
[45:01.380 --> 45:03.380]  Ну, я там в первой домашке
[45:03.380 --> 45:05.380]  очень точно делал результат.
[45:05.380 --> 45:07.380]  Я немножечко игнорировал.
[45:07.380 --> 45:09.380]  Ну, во второй домашке он уже появился.
[45:13.380 --> 45:15.380]  Первая, которая первая, вторая.
[45:23.380 --> 45:25.380]  Не, вообще, SDDCollections
[45:25.380 --> 45:27.380]  это которая вторая домашка.
[45:29.380 --> 45:31.380]  Так. Давайте вспомним
[45:31.380 --> 45:33.380]  в первой лекции как же они выглядят.
[45:33.380 --> 45:35.380]  Это просто вот такие вот янамчики.
[45:35.380 --> 45:37.380]  Самые-самые глупые янамчики.
[45:39.380 --> 45:41.380]  Ну, опшена себя представляет опять же какое-то значение
[45:41.380 --> 45:43.380]  либо наум.
[45:43.380 --> 45:45.380]  А результат это либо какое-то значение
[45:45.380 --> 45:47.380]  либо ошибка
[45:47.380 --> 45:49.380]  с каким-то типом. То есть ошибка тоже
[45:49.380 --> 45:51.380]  является какой-то структуркой.
[45:53.380 --> 45:55.380]  Так.
[45:55.380 --> 45:57.380]  Что мы умеем делать с опшеном?
[45:57.380 --> 45:59.380]  Во-первых, мы умеем матчить.
[45:59.380 --> 46:01.380]  Вы это, наверное, делали
[46:01.380 --> 46:03.380]  в домашке.
[46:03.380 --> 46:05.380]  Мы уже почти наверно.
[46:05.380 --> 46:07.380]  Ну, на самом деле, это не самый
[46:07.380 --> 46:09.380]  эффективный способ работать с опшеном.
[46:09.380 --> 46:11.380]  Мы сейчас посмотрим немножко на его афи.
[46:11.380 --> 46:13.380]  Вот.
[46:23.380 --> 46:25.380]  Это не функция. Это один из вариантов янамы.
[46:25.380 --> 46:27.380]  У нас же вот, смотри.
[46:27.380 --> 46:29.380]  Смотри, опшен это либо самти
[46:29.380 --> 46:31.380]  либо наум.
[46:31.380 --> 46:33.380]  Вот, видишь?
[46:35.380 --> 46:37.380]  Мы же хотим
[46:37.380 --> 46:39.380]  по матче. То есть мы хотим
[46:39.380 --> 46:41.380]  в одном случае пойти либо
[46:41.380 --> 46:43.380]  сам какое-то значение
[46:43.380 --> 46:45.380]  и в другом случае если наум.
[46:53.380 --> 46:55.380]  Это паттерн матчинг здесь
[46:55.380 --> 46:57.380]  подходит. Смотри, у нас
[46:57.380 --> 46:59.380]  результат какой-то опшен либо
[46:59.380 --> 47:01.380]  сам либо наум. И он пытается
[47:01.380 --> 47:03.380]  поматчить результат сам с.
[47:03.380 --> 47:05.380]  Если там наум, то тогда сам с и наум
[47:05.380 --> 47:07.380]  они друг под друга не подходят.
[47:07.380 --> 47:09.380]  Правильно?
[47:09.380 --> 47:11.380]  Ну, наум и сам это разные вещи.
[47:11.380 --> 47:13.380]  Это название.
[47:13.380 --> 47:15.380]  Это название.
[47:15.380 --> 47:17.380]  На исполе.
[47:25.380 --> 47:27.380]  Это не очень правильно
[47:27.380 --> 47:29.380]  описать это, потому что
[47:29.380 --> 47:31.380]  могло быть третье
[47:31.380 --> 47:33.380]  поле.
[47:33.380 --> 47:35.380]  Да, могло быть третье поле, которое
[47:35.380 --> 47:37.380]  бы тоже конструировалось.
[47:37.380 --> 47:39.380]  Да, это все разные конструкты, все хорошо.
[47:39.380 --> 47:41.380]  Ну, тут можно просто путать.
[47:41.380 --> 47:43.380]  То есть можно было написать
[47:43.380 --> 47:45.380]  сам а.
[47:45.380 --> 47:47.380]  В смысле, имеется бы другое имя.
[47:47.380 --> 47:49.380]  Да, можно сам а написать,
[47:49.380 --> 47:51.380]  можно написать свое имя.
[47:51.380 --> 47:53.380]  Что угодно.
[47:55.380 --> 47:57.380]  Так.
[47:59.380 --> 48:01.380]  Вот так вот примерно работает
[48:01.380 --> 48:03.380]  матча. Вы их наверняка писали.
[48:03.380 --> 48:05.380]  Вот.
[48:05.380 --> 48:07.380]  Потом
[48:07.380 --> 48:09.380]  у нас есть очень важные
[48:09.380 --> 48:11.380]  две функции.
[48:11.380 --> 48:13.380]  Вы ими тоже, наверное, пользуетесь.
[48:13.380 --> 48:15.380]  Expert не факт, а Unwrap, наверное, использовали.
[48:15.380 --> 48:17.380]  Вот. Unwrap
[48:17.380 --> 48:19.380]  у нас паникует, если у нас наум,
[48:19.380 --> 48:21.380]  иначе он возвращает тип T.
[48:21.380 --> 48:23.380]  То есть он применяется в том случае,
[48:23.380 --> 48:25.380]  если вы прямо уверены, уверены, что
[48:25.380 --> 48:27.380]  у вас внутри лежит сам T.
[48:27.380 --> 48:29.380]  Ну, иначе он будет считать, что это фатальная
[48:29.380 --> 48:31.380]  ошибка и будет пениковать, что вы
[48:31.380 --> 48:33.380]  где-то нарушили свои же инвериенты.
[48:33.380 --> 48:35.380]  Expert это то же самое, что Unwrap,
[48:35.380 --> 48:37.380]  только он будет еще сообщение
[48:37.380 --> 48:39.380]  в панике выводить, то, которое вы ему дадите.
[48:39.380 --> 48:41.380]  То есть не просто там
[48:41.380 --> 48:43.380]  Unwrap on a non-value,
[48:43.380 --> 48:45.380]  а какое-то более
[48:45.380 --> 48:47.380]  информативное, которое вы сами зададите.
[48:47.380 --> 48:49.380]  Это бывает полезно.
[48:49.380 --> 48:51.380]  Ну, примерно вот такие
[48:51.380 --> 48:53.380]  вот давайте
[48:53.380 --> 48:55.380]  посмотрим, например, использование.
[48:55.380 --> 48:57.380]  У нас есть
[48:57.380 --> 48:59.380]  какой-то OPT, это сам
[48:59.380 --> 49:01.380]  от нашей сегодняшней даты,
[49:01.380 --> 49:03.380]  которая кстати, зеркальная.
[49:03.380 --> 49:05.380]  Вот. Соответственно, она имеет тип
[49:05.380 --> 49:07.380]  Option от I32.
[49:09.380 --> 49:11.380]  Естественно, это сам
[49:11.380 --> 49:13.380]  и это не наум.
[49:13.380 --> 49:15.380]  То есть у нас есть такая функция и сам есть наум,
[49:15.380 --> 49:17.380]  которая позволяет узнать, какой
[49:17.380 --> 49:19.380]  из вариантов Unwrap перед нами на данный момент
[49:19.380 --> 49:21.380]  находится.
[49:21.380 --> 49:23.380]  Потом
[49:23.380 --> 49:25.380]  можем сделать Unwrap
[49:25.380 --> 49:27.380]  и посмотреть на значение внутри.
[49:27.380 --> 49:29.380]  Причем,
[49:29.380 --> 49:31.380]  вот здесь вот вы можете обратить внимание
[49:31.380 --> 49:33.380]  на то, что Let X равняется
[49:33.380 --> 49:35.380]  Opt Unwrap тоже сработает.
[49:35.380 --> 49:37.380]  Но как же так? У нас же Unwrap принимал
[49:37.380 --> 49:39.380]  на вход Self. То есть мы
[49:39.380 --> 49:41.380]  по сути передали ему владение
[49:41.380 --> 49:43.380]  и забрали T. А здесь
[49:43.380 --> 49:45.380]  это скомпилировалось, да?
[49:45.380 --> 49:47.380]  Потому что у нас если тип
[49:47.380 --> 49:49.380]  3 это копия, то в таком случае
[49:49.380 --> 49:51.380]  Option это тоже копия.
[49:51.380 --> 49:53.380]  Он наследует.
[49:53.380 --> 49:55.380]  Вот.
[49:55.380 --> 49:57.380]  То у нас есть какой-то
[49:57.380 --> 49:59.380]  другой Option. Ну я назвал его
[49:59.380 --> 50:01.380]  там Option I32, который
[50:01.380 --> 50:03.380]  будет пусть вариантом наум.
[50:03.380 --> 50:05.380]  Ну и соответственно, я вам примерчик
[50:05.380 --> 50:07.380]  такой дал того, как работает
[50:07.380 --> 50:09.380]  Expect.
[50:09.380 --> 50:11.380]  Он выдаст сообщение I'll panic.
[50:11.380 --> 50:13.380]  Потом
[50:13.380 --> 50:15.380]  давайте еще какой-то New Opt
[50:15.380 --> 50:17.380]  сделаем. Это будет сам от какого-то
[50:17.380 --> 50:19.380]  вектора I32.
[50:19.380 --> 50:21.380]  И попробуем Unwrap.
[50:21.380 --> 50:23.380]  Оно точно так же
[50:23.380 --> 50:25.380]  сработает хорошо. Но когда мы попробуем
[50:25.380 --> 50:27.380]  Unwrap еще раз,
[50:27.380 --> 50:29.380]  как мы это сделали сверху,
[50:29.380 --> 50:31.380]  то это не сработает. Потому что у нас
[50:31.380 --> 50:33.380]  тип вообще-то Vector это clone, и поэтому
[50:33.380 --> 50:35.380]  когда мы Unwrap,
[50:35.380 --> 50:37.380]  то мы действительно уже передаем владение.
[50:37.380 --> 50:39.380]  А не просто копию.
[50:39.380 --> 50:41.380]  В плане
[50:41.380 --> 50:43.380]  определить методы
[50:43.380 --> 50:45.380]  для Enum.
[50:45.380 --> 50:47.380]  В плане
[50:47.380 --> 50:49.380]  определить методы для Enum.
[50:49.380 --> 50:51.380]  Вот я написал там свой Enum,
[50:51.380 --> 50:53.380]  но методы для него я не смог
[50:53.380 --> 50:55.380]  написать, чтобы вот точкой
[50:55.380 --> 50:57.380]  выискать. У нас же Option
[50:57.380 --> 50:59.380]  это Enum.
[50:59.380 --> 51:01.380]  Да, ну в смысле ты говоришь
[51:01.380 --> 51:03.380]  сделал какой-то свой
[51:03.380 --> 51:05.380]  MyOption, да, и там.
[51:05.380 --> 51:07.380]  Ну ты же можешь написать ему IMPAL
[51:07.380 --> 51:09.380]  типа MyOptionT внутри сделать.
[51:09.380 --> 51:11.380]  Тебе это должно было компилироваться.
[51:11.380 --> 51:13.380]  У нас даже примеры
[51:13.380 --> 51:15.380]  будут даже, по-моему,
[51:15.380 --> 51:17.380]  когда имплы есть.
[51:17.380 --> 51:19.380]  По крайней мере, такое точно было в первой лекции,
[51:19.380 --> 51:21.380]  оно должно было компилироваться.
[51:21.380 --> 51:23.380]  Так.
[51:23.380 --> 51:25.380]  Есть еще такая вот волшебная функция
[51:25.380 --> 51:27.380]  SRF. Она вам понадобится,
[51:27.380 --> 51:29.380]  когда вы будете писать такие
[51:29.380 --> 51:31.380]  домашки, активно использующие
[51:31.380 --> 51:33.380]  Option. У нас такие будут.
[51:33.380 --> 51:35.380]  Она делает
[51:35.380 --> 51:37.380]  так. Если у нас есть ссылка на OptionT,
[51:37.380 --> 51:39.380]  то в таком случае она превращает
[51:39.380 --> 51:41.380]  это в Option от ссылки на T.
[51:41.380 --> 51:43.380]  То есть ссылочку внутрь загоняет.
[51:45.380 --> 51:47.380]  Это весьма и весьма полезно.
[51:47.380 --> 51:49.380]  То есть позволяет, например, сделать
[51:49.380 --> 51:51.380]  Unwrap после этого SRF, Unwrap,
[51:51.380 --> 51:53.380]  и после этого мы получаем ссылку на T, не просто
[51:53.380 --> 51:55.380]  T. То есть мы с одной стороны не сломали
[51:55.380 --> 51:57.380]  Option, мы его
[51:57.380 --> 51:59.380]  не съели, и с другой стороны
[51:59.380 --> 52:01.380]  мы получили ссылку на T, как хотели.
[52:01.380 --> 52:03.380]  Почему мы не съели?
[52:03.380 --> 52:05.380]  Потому что передали нас.
[52:05.380 --> 52:07.380]  Смотри, SRF у тебя до этого
[52:07.380 --> 52:09.380]  был какой-то Option.
[52:09.380 --> 52:11.380]  Сейчас посмотрю пример.
[52:11.380 --> 52:13.380]  Давай посмотрим сразу на код,
[52:13.380 --> 52:15.380]  который я написал. У нас есть NewOpt
[52:15.380 --> 52:17.380]  какой-то. Это сам от вектора.
[52:17.380 --> 52:19.380]  Если мы Unwrap, мы получим
[52:19.380 --> 52:21.380]  соответственно вектор.
[52:21.380 --> 52:23.380]  Если мы попробуем Unwrap еще раз,
[52:23.380 --> 52:25.380]  мы получим ошибку. Это ровно то же самое,
[52:25.380 --> 52:27.380]  что мы делали на прошлом слайде.
[52:27.380 --> 52:29.380]  А теперь давайте попробуем SRF.
[52:29.380 --> 52:31.380]  У нас есть NewOpt SRF Unwrap.
[52:33.380 --> 52:35.380]  Мы передаем NewOpt наш
[52:35.380 --> 52:37.380]  Option по ссылке.
[52:37.380 --> 52:39.380]  То есть у нас там ссылка на Option по T.
[52:39.380 --> 52:41.380]  Когда мы сделаем Unwrap,
[52:41.380 --> 52:43.380]  то мы получим ссылку
[52:43.380 --> 52:45.380]  на T.
[52:45.380 --> 52:47.380]  Соответственно мы здесь получили
[52:47.380 --> 52:49.380]  ссылку на T, и мы не сломали NewOpt.
[52:49.380 --> 52:51.380]  Потому что мы убрали
[52:51.380 --> 52:53.380]  по ссылке, соответственно его никто не
[52:53.380 --> 52:55.380]  закомсюмил, никто не съел, и поэтому можем
[52:55.380 --> 52:57.380]  дальше сделать Unwrap LetX.
[52:59.380 --> 53:01.380]  Это даже будет работать.
[53:03.380 --> 53:05.380]  Сейчас я в этом примере еще не
[53:05.380 --> 53:07.380]  использую SRF Unwrap.
[53:07.380 --> 53:09.380]  А, вот, не использую.
[53:09.380 --> 53:11.380]  Вон там есть SRF Unwrap.
[53:13.380 --> 53:15.380]  Какое качество?
[53:15.380 --> 53:17.380]  Там, где нижний ассерт, там должен был быть
[53:17.380 --> 53:19.380]  Opt-Ref.
[53:19.380 --> 53:21.380]  Какой еще раз нижний ассерт, который
[53:21.380 --> 53:23.380]  NewOpt? А, да, Opt-Ref.
[53:23.380 --> 53:25.380]  Здесь обсяточка.
[53:25.380 --> 53:27.380]  Опт-Реф.
[53:29.380 --> 53:31.380]  Да, да, это обсяточка получилась.
[53:31.380 --> 53:33.380]  Это не Opt-Ref, это Opt-Ref.
[53:33.380 --> 53:35.380]  Да, вот здесь Opt-Ref, Opt-Ref, Opt-Ref.
[53:35.380 --> 53:37.380]  Сейчас, а во втором ассерте
[53:37.380 --> 53:39.380]  еще раз, если SRF убрать,
[53:39.380 --> 53:41.380]  то что будет?
[53:41.380 --> 53:43.380]  Если убрать SRF,
[53:43.380 --> 53:45.380]  вот здесь вот.
[53:45.380 --> 53:47.380]  В таком случае ты просто, смотри,
[53:47.380 --> 53:49.380]  передашь по ссылке Unwrap.
[53:49.380 --> 53:51.380]  Вот, видишь, Self. Он законсюмит в таком
[53:51.380 --> 53:53.380]  случае.
[53:53.380 --> 53:55.380]  А у нас SRF работает как ссылка
[53:55.380 --> 53:57.380]  на Self.
[53:57.380 --> 53:59.380]  Ну, мы же сделаем Unwrap,
[53:59.380 --> 54:01.380]  мы получим, соответственно,
[54:01.380 --> 54:03.380]  вектор I32NU.
[54:03.380 --> 54:05.380]  Обратите внимание, что здесь просто
[54:05.380 --> 54:07.380]  вектор I32NU.
[54:07.380 --> 54:09.380]  То, что мы получим здесь вот
[54:09.380 --> 54:11.380]  T, а вот здесь получим ссылку
[54:11.380 --> 54:13.380]  на T.
[54:13.380 --> 54:15.380]  Сейчас, просто вектор I32NU
[54:15.380 --> 54:17.380]  он создаст абсолютно новый вектор,
[54:17.380 --> 54:19.380]  там основы и ссылки
[54:19.380 --> 54:21.380]  на кучу. Почему?
[54:21.380 --> 54:23.380]  Ну, сравнивается, что они не побитые.
[54:25.380 --> 54:27.380]  Из-за того, что они пустые.
[54:27.380 --> 54:29.380]  Сейчас, подожди.
[54:31.380 --> 54:33.380]  Вектор на равенство проверяется
[54:33.380 --> 54:35.380]  по элементам просто.
[54:35.380 --> 54:37.380]  И все.
[54:37.380 --> 54:39.380]  Здесь то же самое, здесь, правда, там будет чуть хитрее,
[54:39.380 --> 54:41.380]  там будет trade DRF.
[54:41.380 --> 54:43.380]  Ну, короче, в общем, по ссылке он тоже
[54:43.380 --> 54:45.380]  будет сравнить их.
[54:45.380 --> 54:47.380]  Вот, корректно.
[54:51.380 --> 54:53.380]  Так, потом.
[54:53.380 --> 54:55.380]  Есть такая прекрасная функция
[54:55.380 --> 54:57.380]  Web. Это, наверное, самое частое, что
[54:57.380 --> 54:59.380]  я использую.
[54:59.380 --> 55:01.380]  Она превращает option T в option U.
[55:01.380 --> 55:03.380]  Сейчас.
[55:03.380 --> 55:05.380]  А мы не будем обсуждать, как работает
[55:05.380 --> 55:07.380]  под роботом SRF?
[55:07.380 --> 55:09.380]  SRF, на самом деле, очень просто работает.
[55:09.380 --> 55:11.380]  Там внутри, но я могу тебе даже
[55:11.380 --> 55:13.380]  сказать, что там происходит.
[55:13.380 --> 55:15.380]  Там вот SRF написан, option T.
[55:15.380 --> 55:17.380]  Внутри написан match self.
[55:17.380 --> 55:19.380]  Ну, self – это ссылка на self,
[55:19.380 --> 55:21.380]  то есть ссылка на option.
[55:21.380 --> 55:23.380]  Если это сам X, то возвращается X,
[55:23.380 --> 55:25.380]  все.
[55:25.380 --> 55:27.380]  Ну, просто там получается по системе типа фразы,
[55:27.380 --> 55:29.380]  что когда ты матчишь ссылку на
[55:29.380 --> 55:31.380]  self, то в таком случае он не
[55:31.380 --> 55:33.380]  consumes option. Он просто
[55:33.380 --> 55:35.380]  уберет по ссылке и вернет ссылку
[55:35.380 --> 55:37.380]  на внутренность.
[55:37.380 --> 55:39.380]  То есть в матче фор они как бы прогрессуют ссылку
[55:39.380 --> 55:41.380]  на элемент.
[55:41.380 --> 55:43.380]  Матч, да, ты про фор сейчас
[55:43.380 --> 55:45.380]  сказал. Да, и фор
[55:45.380 --> 55:47.380]  по умолчанию он тоже по значению
[55:47.380 --> 55:49.380]  забирает. Там можно по ссылке, по мутабельной
[55:49.380 --> 55:51.380]  ссылке передавать, и в матче то же самое.
[55:53.380 --> 55:55.380]  Вот.
[55:55.380 --> 55:57.380]  Ну, соответственно у вас конечно
[55:57.380 --> 55:59.380]  будет меньше прав, да, вы сможете
[55:59.380 --> 56:01.380]  только читать элемент.
[56:01.380 --> 56:03.380]  Ну, это никакой проблем.
[56:03.380 --> 56:05.380]  Еще я, кстати, забыл сказать, кроме
[56:05.380 --> 56:07.380]  SRF есть еще SMUTE. Это то же самое,
[56:07.380 --> 56:09.380]  только будет мутабельная ссылка на option
[56:09.380 --> 56:11.380]  и возвращается мутабельная ссылка на T.
[56:11.380 --> 56:13.380]  Просто мутабельность.
[56:13.380 --> 56:15.380]  Так.
[56:15.380 --> 56:17.380]  Смотрите, у нас дальше есть
[56:17.380 --> 56:19.380]  option и
[56:19.380 --> 56:21.380]  ну, мы пытаемся
[56:21.380 --> 56:23.380]  перевести из одного типа в другое, с T в U.
[56:23.380 --> 56:25.380]  Это очень-очень полезно.
[56:25.380 --> 56:27.380]  Часто нужно, на самом деле, на практике.
[56:27.380 --> 56:29.380]  Особенно
[56:29.380 --> 56:31.380]  когда у вас там всякие error-handling
[56:31.380 --> 56:33.380]  и даже без них иногда хочется
[56:33.380 --> 56:35.380]  просто поменять типа option.
[56:35.380 --> 56:37.380]  Вы можете написать мэп
[56:37.380 --> 56:39.380]  и внутри него закинуть, ну, пока что
[56:39.380 --> 56:41.380]  можете читать лямбду. На самом деле это называется
[56:41.380 --> 56:43.380]  closure. Такая штука.
[56:43.380 --> 56:45.380]  Вот.
[56:45.380 --> 56:47.380]  Ну, то есть вы пишете через вот такие вот
[56:47.380 --> 56:49.380]  палочки
[56:49.380 --> 56:51.380]  понимаемое значение.
[56:51.380 --> 56:53.380]  Ну, и там, соответственно, внутри уже
[56:53.380 --> 56:55.380]  саму лямбду. Если она однострочная,
[56:55.380 --> 56:57.380]  то можно без фигурных скобочек либо фигурных
[56:57.380 --> 56:59.380]  скобочков.
[56:59.380 --> 57:01.380]  Вот. Ну, работает, в принципе,
[57:01.380 --> 57:03.380]  как лямбда в плюсах. На самом деле
[57:03.380 --> 57:05.380]  чуть-чуть по-другому, потому что она
[57:05.380 --> 57:07.380]  все-таки zero-cost abstraction.
[57:07.380 --> 57:09.380]  Но мы пока что не будем
[57:09.380 --> 57:11.380]  подробно останавливаться. Можете это
[57:11.380 --> 57:13.380]  смотреть как на лямбду.
[57:13.380 --> 57:15.380]  Вот.
[57:15.380 --> 57:17.380]  Ну, и здесь у нас в примере
[57:17.380 --> 57:19.380]  мы берем string from HelloWorld,
[57:19.380 --> 57:21.380]  маппим строчку,
[57:21.380 --> 57:23.380]  изменяем наш
[57:23.380 --> 57:25.380]  auction, маппим в SLAM.
[57:25.380 --> 57:27.380]  То есть у нас...
[57:27.380 --> 57:29.380]  Так, вот
[57:29.380 --> 57:31.380]  мы как раз когда будем говорить про строки,
[57:31.380 --> 57:33.380]  мы как раз поговорим про это.
[57:33.380 --> 57:35.380]  Ну, смотри, у нас просто
[57:35.380 --> 57:37.380]  HelloWorld, это, я в двух
[57:37.380 --> 57:39.380]  словах наперед скажу, это на самом деле строковый
[57:39.380 --> 57:41.380]  slice просто. А для того, чтобы получить
[57:41.380 --> 57:43.380]  именно саму строчку, владеющий тип,
[57:43.380 --> 57:45.380]  ну, у нас же есть вот вектор, есть slice
[57:45.380 --> 57:47.380]  вектор. Вот это тоже самое.
[57:47.380 --> 57:49.380]  У нас есть строка, есть slice строчки.
[57:49.380 --> 57:51.380]  Чтобы из slice строчки HelloWorld
[57:51.380 --> 57:53.380]  получить владеющий тип, нужно сделать string from.
[57:53.380 --> 57:55.380]  То есть прямо пролатировать.
[57:55.380 --> 57:57.380]  Вот.
[57:59.380 --> 58:01.380]  Так. Ну, вот
[58:01.380 --> 58:03.380]  мы маппим в SLAM. После этого,
[58:03.380 --> 58:05.380]  как вы можете заметить, я
[58:05.380 --> 58:07.380]  проверяю, что это действительно сам 13.
[58:07.380 --> 58:09.380]  Сейчас обводую я
[58:09.380 --> 58:11.380]  еще один спирт.
[58:11.380 --> 58:13.380]  Это называется closure, это типа лямбда.
[58:13.380 --> 58:15.380]  Вот. Вот это вот типа на вход
[58:15.380 --> 58:17.380]  принимается. Это то, что у нас внутри
[58:17.380 --> 58:19.380]  само опциону лежит.
[58:21.380 --> 58:23.380]  А это где?
[58:23.380 --> 58:25.380]  В маппе не нужен. Как я запутаю?
[58:25.380 --> 58:27.380]  Сейчас это
[58:27.380 --> 58:29.380]  а, это дальше
[58:29.380 --> 58:31.380]  тема.
[58:31.380 --> 58:33.380]  Так.
[58:33.380 --> 58:35.380]  Вот.
[58:35.380 --> 58:37.380]  Ну,
[58:37.380 --> 58:39.380]  у нас на вход здесь принимается тип T,
[58:39.380 --> 58:41.380]  а потом возвращается тип U. Вот эта вот
[58:41.380 --> 58:43.380]  строчка, она будет иметь тип string.
[58:43.380 --> 58:45.380]  Это будет иметь тип, соответственно,
[58:45.380 --> 58:47.380]  U-size, потому что LAM возвращает
[58:47.380 --> 58:49.380]  U-size. Соответственно, мы изменили тип
[58:49.380 --> 58:51.380]  из option string
[58:51.380 --> 58:53.380]  в option U-size.
[58:53.380 --> 58:55.380]  Вот здесь.
[58:55.380 --> 58:57.380]  Так.
[58:57.380 --> 58:59.380]  Здесь вот это вот просто, чтобы вас
[58:59.380 --> 59:01.380]  показать все, что
[59:01.380 --> 59:03.380]  умеет option, умеет очень много.
[59:03.380 --> 59:05.380]  И это настолько, вот
[59:05.380 --> 59:07.380]  вы...
[59:07.380 --> 59:09.380]  Кто-нибудь из вас знаком хотя бы издали
[59:09.380 --> 59:11.380]  функциональными языками.
[59:11.380 --> 59:13.380]  Так.
[59:13.380 --> 59:15.380]  Так, давайте
[59:15.380 --> 59:17.380]  вернемся к Расту.
[59:17.380 --> 59:19.380]  Раст, кстати, это
[59:19.380 --> 59:21.380]  такая
[59:21.380 --> 59:23.380]  зажигательная
[59:23.380 --> 59:25.380]  функциональность.
[59:25.380 --> 59:27.380]  Так, давайте
[59:27.380 --> 59:29.380]  вернемся к Расту.
[59:29.380 --> 59:31.380]  Раст, кстати, это такая
[59:31.380 --> 59:33.380]  зажигательная
[59:33.380 --> 59:35.380]  функциональность.
[59:35.380 --> 59:37.380]  Так, давайте
[59:37.380 --> 59:39.380]  вернемся к Расту.
[59:39.380 --> 59:41.380]  Раст, кстати, это такая
[59:41.380 --> 59:43.380]  забавная информация.
[59:43.380 --> 59:45.380]  Раст, на самом деле, можно рассматривать
[59:45.380 --> 59:47.380]  как в каком-то смысле
[59:47.380 --> 59:49.380]  функциональный язык без garbage collection.
[59:49.380 --> 59:51.380]  Да, по некоторым причинам, просто в
[59:51.380 --> 59:53.380]  функциональных языках, я, честно, примеров
[59:53.380 --> 59:55.380]  так не могу вспомнить, но они прям есть.
[59:55.380 --> 59:57.380]  Когда в функциональных языках
[59:57.380 --> 59:59.380]  просто нельзя обойтись без garbage collection,
[59:59.380 --> 01:00:01.380]  потому что они вот так вот устроены.
[01:00:05.380 --> 01:00:07.380]  Ну, я сам, честно говоря, не шарю.
[01:00:07.380 --> 01:00:09.380]  Ну, Раст вот устроен так,
[01:00:09.380 --> 01:00:11.380]  что, в принципе, можно смотреть в него как
[01:00:11.380 --> 01:00:13.380]  функциональный язык без garbage collection.
[01:00:13.380 --> 01:00:15.380]  Вот.
[01:00:15.380 --> 01:00:17.380]  И вот, смотрите, здесь вот можем с option вот
[01:00:17.380 --> 01:00:19.380]  такой вот машинелью делать. Можем его преобразовывать
[01:00:19.380 --> 01:00:21.380]  так, что у нас в итоге
[01:00:21.380 --> 01:00:23.380]  получается
[01:00:23.380 --> 01:00:25.380]  на самом деле прикольный код.
[01:00:25.380 --> 01:00:27.380]  Вот.
[01:00:27.380 --> 01:00:29.380]  Не, ну, это пока что для вас смешно, типа, но потом
[01:00:29.380 --> 01:00:31.380]  вам понравится.
[01:00:31.380 --> 01:00:33.380]  Да, там может быть
[01:00:33.380 --> 01:00:35.380]  map, потом можно преобразовать это
[01:00:35.380 --> 01:00:37.380]  в result, потом из result,
[01:00:37.380 --> 01:00:39.380]  если ошибка вот это, если
[01:00:39.380 --> 01:00:41.380]  вот это.
[01:00:41.380 --> 01:00:43.380]  И это все через pattern matching.
[01:00:43.380 --> 01:00:45.380]  Да, это внутри там pattern matching, это
[01:00:45.380 --> 01:00:47.380]  на самом деле все zero-cost, то есть тут работает
[01:00:47.380 --> 01:00:49.380]  быстро. Давайте я про эти функции
[01:00:49.380 --> 01:00:51.380]  в паре слов что-то скажу.
[01:00:51.380 --> 01:00:53.380]  Они
[01:00:53.380 --> 01:00:55.380]  все прекрасные, они на самом деле умеют
[01:00:55.380 --> 01:00:57.380]  такие штуки. Например, map,
[01:00:57.380 --> 01:00:59.380]  or, в случае, если у вас
[01:00:59.380 --> 01:01:01.380]  какое-то значение t внутри хранится, он применит
[01:01:01.380 --> 01:01:03.380]  вот этот лямуток f,
[01:01:03.380 --> 01:01:05.380]  вот функция, в которую
[01:01:05.380 --> 01:01:07.380]  вы передадите. А в противном случае, если там
[01:01:07.380 --> 01:01:09.380]  now, то тогда он запомнит его каким-то
[01:01:09.380 --> 01:01:11.380]  дефолтным значением u.
[01:01:11.380 --> 01:01:13.380]  И это на самом деле удобно
[01:01:13.380 --> 01:01:15.380]  бывает. То есть у нас в таком случае получается
[01:01:15.380 --> 01:01:17.380]  в конце просто u, как вы видите.
[01:01:17.380 --> 01:01:19.380]  То есть даже не option, просто типа u.
[01:01:21.380 --> 01:01:23.380]  Map or else там делает
[01:01:23.380 --> 01:01:25.380]  еще какую-то вещь, то есть он смотрит
[01:01:27.380 --> 01:01:29.380]  по-моему там просто вторая функция,
[01:01:29.380 --> 01:01:31.380]  то есть там дефолтное значение задается
[01:01:31.380 --> 01:01:33.380]  функцией.
[01:01:33.380 --> 01:01:35.380]  А не просто значением.
[01:01:35.380 --> 01:01:37.380]  То есть там получается
[01:01:37.380 --> 01:01:39.380]  уже два closure, а не closure и значение.
[01:01:39.380 --> 01:01:41.380]  Есть всякие end.
[01:01:41.380 --> 01:01:43.380]  То есть это логические операции. Если у вас
[01:01:43.380 --> 01:01:45.380]  option это sum, и второй option это sum,
[01:01:45.380 --> 01:01:47.380]  тогда он возвращает
[01:01:47.380 --> 01:01:49.380]  первый option.
[01:01:49.380 --> 01:01:51.380]  Например.
[01:01:51.380 --> 01:01:53.380]  В первом случае функция
[01:01:53.380 --> 01:01:55.380]  должна вернуть типа u?
[01:01:55.380 --> 01:01:57.380]  Да, она должна вернуть типа u.
[01:01:57.380 --> 01:01:59.380]  Обязательно.
[01:01:59.380 --> 01:02:01.380]  Просто преобразуемся в u, и тогда
[01:02:01.380 --> 01:02:03.380]  все раз пожалуются.
[01:02:03.380 --> 01:02:05.380]  Вот.
[01:02:05.380 --> 01:02:07.380]  Ну или там or, например.
[01:02:07.380 --> 01:02:09.380]  Если у нас первое это sum,
[01:02:09.380 --> 01:02:11.380]  то тогда возвращает первое, иначе возвращает
[01:02:11.380 --> 01:02:13.380]  второе значение.
[01:02:13.380 --> 01:02:15.380]  То есть можно
[01:02:15.380 --> 01:02:17.380]  писать, по сути, это такой декларативный язык,
[01:02:17.380 --> 01:02:19.380]  на котором можно написать такую произвольную
[01:02:19.380 --> 01:02:21.380]  логику.
[01:02:21.380 --> 01:02:23.380]  Я вам очень советую почитать документацию.
[01:02:23.380 --> 01:02:25.380]  То есть у нас там есть, например, ссылочки,
[01:02:25.380 --> 01:02:27.380]  буквально там, я прямо покажу,
[01:02:27.380 --> 01:02:29.380]  в каждой главе у нас есть
[01:02:29.380 --> 01:02:31.380]  option documentation и result documentation.
[01:02:31.380 --> 01:02:33.380]  Считайте их, это очень полезно.
[01:02:33.380 --> 01:02:35.380]  И постарайтесь, когда вы будете
[01:02:35.380 --> 01:02:37.380]  писать код,
[01:02:37.380 --> 01:02:39.380]  минимизировать число матчей.
[01:02:39.380 --> 01:02:41.380]  Сначала будет очень больно, но потом вы поймете,
[01:02:41.380 --> 01:02:43.380]  что от этого код гораздо короче.
[01:02:43.380 --> 01:02:45.380]  Гораздо короче, гораздо красивее,
[01:02:45.380 --> 01:02:47.380]  и на самом деле гораздо даже понятнее.
[01:02:49.380 --> 01:02:51.380]  Ну и даже безопаснее, на самом деле,
[01:02:51.380 --> 01:02:53.380]  потому что это функциональный код.
[01:02:55.380 --> 01:02:57.380]  Такой с точки зрения телевизора типов
[01:02:57.380 --> 01:02:59.380]  что появляется.
[01:02:59.380 --> 01:03:01.380]  Так.
[01:03:01.380 --> 01:03:03.380]  У нас на самом деле в option есть еще
[01:03:03.380 --> 01:03:05.380]  такие вот вещи, которые связаны уже с
[01:03:05.380 --> 01:03:07.380]  ownership'ом. Это take, replace,
[01:03:07.380 --> 01:03:09.380]  insert.
[01:03:09.380 --> 01:03:11.380]  Такая вот отличная функция,
[01:03:11.380 --> 01:03:13.380]  которая нам частенько будут нужна, когда мы будем писать всякие
[01:03:13.380 --> 01:03:15.380]  структуры данных на расти.
[01:03:15.380 --> 01:03:17.380]  Take, если у нас есть
[01:03:17.380 --> 01:03:19.380]  option, то в таком случае он берет мутабельную ссылку
[01:03:19.380 --> 01:03:21.380]  на этот option.
[01:03:21.380 --> 01:03:23.380]  И если этот option noun,
[01:03:23.380 --> 01:03:25.380]  то в таком случае он возвращает noun,
[01:03:25.380 --> 01:03:27.380]  иначе он возвращает сам te
[01:03:27.380 --> 01:03:29.380]  и оставляет на месте
[01:03:29.380 --> 01:03:31.380]  это option, в котором мы это вызвали, noun.
[01:03:33.380 --> 01:03:35.380]  Верно?
[01:03:37.380 --> 01:03:39.380]  Еще раз.
[01:03:41.380 --> 01:03:43.380]  Ну он возвращает option te.
[01:03:43.380 --> 01:03:45.380]  Он возвращает option te,
[01:03:45.380 --> 01:03:47.380]  просто по сути он возвращает этот же
[01:03:47.380 --> 01:03:49.380]  option.
[01:03:51.380 --> 01:03:53.380]  И ставит там noun.
[01:03:53.380 --> 01:03:55.380]  То есть он вернет текущий option и оставит
[01:03:55.380 --> 01:03:57.380]  noun на том месте, в котором мы это вызвали.
[01:03:59.380 --> 01:04:01.380]  Это полезно, когда вы хотите забрать
[01:04:01.380 --> 01:04:03.380]  владение над типом, но при этом
[01:04:03.380 --> 01:04:05.380]  не хотите уничтожать сам option.
[01:04:05.380 --> 01:04:07.380]  Это полезно, например, во всяких бинарных деревьях.
[01:04:07.380 --> 01:04:09.380]  Потому что иногда у вас есть только
[01:04:09.380 --> 01:04:11.380]  мутабельная ссылка, когда вы там по нему
[01:04:11.380 --> 01:04:13.380]  интерируетесь, и
[01:04:13.380 --> 01:04:15.380]  владение вы не можете забрать.
[01:04:17.380 --> 01:04:19.380]  Просто так. То есть у вас есть take, который
[01:04:19.380 --> 01:04:21.380]  это позволяет сделать.
[01:04:21.380 --> 01:04:23.380]  В том есть replace.
[01:04:23.380 --> 01:04:25.380]  Реплейс это, знаете, частенько
[01:04:25.380 --> 01:04:27.380]  когда рассказывают про всякие стд мемы
[01:04:27.380 --> 01:04:29.380]  replace, которые еще есть в Rust, и вот этот вот
[01:04:29.380 --> 01:04:31.380]  replace показывает такую картинку с
[01:04:31.380 --> 01:04:33.380]  Индиана Джонсом. Наверное, помните, где он так
[01:04:33.380 --> 01:04:35.380]  менял вот, там быстро
[01:04:37.380 --> 01:04:39.380]  какой-то там грааль, вроде бы, точно
[01:04:39.380 --> 01:04:41.380]  не помню. Но в общем, replace
[01:04:41.380 --> 01:04:43.380]  это такое, то что inplace, оно быстро
[01:04:43.380 --> 01:04:45.380]  меняет значение на te и возвращает то, что было.
[01:04:45.380 --> 01:04:47.380]  То есть оставляет на нашем
[01:04:47.380 --> 01:04:49.380]  типущем месте сам te
[01:04:49.380 --> 01:04:51.380]  и возвращает то, что было.
[01:04:51.380 --> 01:04:53.380]  Так?
[01:04:53.380 --> 01:04:55.380]  И опять же, это все происходит
[01:04:55.380 --> 01:04:57.380]  так, что мы ни в какой момент
[01:04:57.380 --> 01:04:59.380]  времени не оставляем неинициализированного
[01:04:59.380 --> 01:05:01.380]  пустого значения.
[01:05:01.380 --> 01:05:03.380]  То есть, например, если бы мы в каких-нибудь
[01:05:03.380 --> 01:05:05.380]  плюсах хотели сделать вот такой вот, ну, допустим
[01:05:05.380 --> 01:05:07.380]  take. Take чуть попроще.
[01:05:07.380 --> 01:05:09.380]  То мы бы
[01:05:09.380 --> 01:05:11.380]  наткнулись на то, что пытаясь взять значение,
[01:05:11.380 --> 01:05:13.380]  оно в какой-то момент было бы неинициализированным.
[01:05:13.380 --> 01:05:15.380]  Мы move-нули его оттуда и оп, и у нас
[01:05:15.380 --> 01:05:17.380]  в какой-то момент остался неинициализированным. Как-то
[01:05:17.380 --> 01:05:19.380]  небезопасно.
[01:05:19.380 --> 01:05:21.380]  В какой-то момент времени там не будет
[01:05:21.380 --> 01:05:23.380]  неинициализировано. Это ладно для многопоточного кода.
[01:05:23.380 --> 01:05:25.380]  В плане
[01:05:25.380 --> 01:05:27.380]  чего?
[01:05:27.380 --> 01:05:29.380]  Ну, вы сказали то, что replace, он как-то
[01:05:29.380 --> 01:05:31.380]  вот так, сразу. Да, он для нас
[01:05:31.380 --> 01:05:33.380]  так со стороны выглядит, как-то мы Indiana Jones.
[01:05:33.380 --> 01:05:35.380]  Ну, в однопоточном коде нам не
[01:05:35.380 --> 01:05:37.380]  важно.
[01:05:37.380 --> 01:05:39.380]  Если что, в общем
[01:05:39.380 --> 01:05:41.380]  многопоточном коде так не получится.
[01:05:41.380 --> 01:05:43.380]  С ним работать, он не многопоточный.
[01:05:43.380 --> 01:05:45.380]  Это просто для того,
[01:05:45.380 --> 01:05:47.380]  чтобы с barrel-checker-ом это хорошо работало.
[01:05:47.380 --> 01:05:49.380]  И чтобы в любой момент времени у нас был
[01:05:49.380 --> 01:05:51.380]  какой-то инициализированный, хороший
[01:05:51.380 --> 01:05:53.380]  auction-сохранящий вариант.
[01:05:53.380 --> 01:05:55.380]  То есть либо там sum-t, либо num.
[01:05:55.380 --> 01:05:57.380]  А не sum и bit-t.
[01:05:57.380 --> 01:05:59.380]  Которые нам нельзя исполнить.
[01:06:01.380 --> 01:06:03.380]  Ну, insert даже проще.
[01:06:03.380 --> 01:06:05.380]  Он вставляет просто значение.
[01:06:05.380 --> 01:06:07.380]  И возвращает на него мутабельную ссылку.
[01:06:07.380 --> 01:06:09.380]  А то, что у нас там было внутри, он просто
[01:06:09.380 --> 01:06:11.380]  съедает и ничего с ним не делает.
[01:06:11.380 --> 01:06:13.380]  С этим значением.
[01:06:15.380 --> 01:06:17.380]  Давайте посмотрим такой пример.
[01:06:17.380 --> 01:06:19.380]  Я думаю, на этом сладе мы задержимся
[01:06:19.380 --> 01:06:21.380]  дольше всего.
[01:06:21.380 --> 01:06:23.380]  Потому что это попытка
[01:06:23.380 --> 01:06:25.380]  посмотреть на single-linked-list
[01:06:25.380 --> 01:06:27.380]  на Rasti.
[01:06:27.380 --> 01:06:29.380]  Как вы, возможно, когда-то слышали, на Rasti
[01:06:29.380 --> 01:06:31.380]  очень сложно писать такие структуры данных.
[01:06:31.380 --> 01:06:33.380]  Но здесь был настолько сладкий пример, что я не мог просто
[01:06:33.380 --> 01:06:35.380]  устоять и решил вам показать, как можно
[01:06:35.380 --> 01:06:37.380]  воспользоваться общем.
[01:06:39.380 --> 01:06:41.380]  Давайте для начала посмотрим на структуру ноды.
[01:06:41.380 --> 01:06:43.380]  Ну, у нас же есть ноды.
[01:06:43.380 --> 01:06:45.380]  Она хранит какой-то тип T.
[01:06:45.380 --> 01:06:47.380]  Вот элемент T.
[01:06:47.380 --> 01:06:49.380]  То есть у нас есть следующий элемент.
[01:06:49.380 --> 01:06:51.380]  Это option-box-not-T.
[01:06:51.380 --> 01:06:53.380]  Вот.
[01:06:53.380 --> 01:06:55.380]  Насколько вы должны помнить с первой лекции, option-box
[01:06:55.380 --> 01:06:57.380]  это как unique-pointer.
[01:06:57.380 --> 01:06:59.380]  То есть это либо next у нас
[01:06:59.380 --> 01:07:01.380]  now, то есть нет следующего элемента.
[01:07:01.380 --> 01:07:03.380]  Либо сам box-not-T.
[01:07:03.380 --> 01:07:05.380]  То есть что-то есть.
[01:07:05.380 --> 01:07:07.380]  Box нам нужен для того, чтобы следующая
[01:07:07.380 --> 01:07:09.380]  локация была на хипе.
[01:07:09.380 --> 01:07:11.380]  То есть чтобы у нас каждый следующий элемент был
[01:07:11.380 --> 01:07:13.380]  на кучу.
[01:07:13.380 --> 01:07:15.380]  Ну и соответственно, потому что следующий элемент
[01:07:15.380 --> 01:07:17.380]  у нас not-S, соответственно not-T.
[01:07:17.380 --> 01:07:19.380]  Вот эта вот конструкция из
[01:07:19.380 --> 01:07:21.380]  четырех типов. Понятно?
[01:07:21.380 --> 01:07:23.380]  В принципе, должен быть
[01:07:23.380 --> 01:07:25.380]  присутствовать. Понятно.
[01:07:25.380 --> 01:07:27.380]  То у нас есть лист.
[01:07:27.380 --> 01:07:29.380]  Спрашивается, а почему мы там не храним просто
[01:07:29.380 --> 01:07:31.380]  box-not-T, казалось бы, да?
[01:07:31.380 --> 01:07:33.380]  Лиза у нас может быть пустым, да?
[01:07:33.380 --> 01:07:35.380]  Например.
[01:07:35.380 --> 01:07:37.380]  Поэтому у нас либо нет хеда, либо
[01:07:37.380 --> 01:07:39.380]  есть какой-то там.
[01:07:39.380 --> 01:07:41.380]  У нас тут тоже вот такая структура.
[01:07:41.380 --> 01:07:43.380]  Еще скажу, что частенько прописывают
[01:07:43.380 --> 01:07:45.380]  option-box-not-T как
[01:07:45.380 --> 01:07:47.380]  type какой-то, там type-link.
[01:07:47.380 --> 01:07:49.380]  Наверное, знаком с таким
[01:07:49.380 --> 01:07:51.380]  ключевым словом, но просто это
[01:07:51.380 --> 01:07:53.380]  способ написать это все
[01:07:53.380 --> 01:07:55.380]  кратко.
[01:07:55.380 --> 01:07:57.380]  То есть сделать алиэс.
[01:07:57.380 --> 01:07:59.380]  Все это в длинной машинейре.
[01:08:01.380 --> 01:08:03.380]  То у нас есть функция. Давайте посмотрим
[01:08:03.380 --> 01:08:05.380]  на pop.
[01:08:05.380 --> 01:08:07.380]  Это такой вот очень правильный растовский
[01:08:07.380 --> 01:08:09.380]  дизайн. Возвращать
[01:08:09.380 --> 01:08:11.380]  если у нас лист пустой, то возвращать
[01:08:11.380 --> 01:08:13.380]  науны. Не паниковать, например,
[01:08:13.380 --> 01:08:15.380]  выдавать УБ как в плюсах.
[01:08:15.380 --> 01:08:17.380]  Поэтому встречаем либо науны, если у нас ничего
[01:08:17.380 --> 01:08:19.380]  не было, либо Т.
[01:08:19.380 --> 01:08:21.380]  Вот мы смотрим на наш self-head.
[01:08:21.380 --> 01:08:23.380]  Забираем хед.
[01:08:23.380 --> 01:08:25.380]  Если
[01:08:27.380 --> 01:08:29.380]  если у нас нода, в общем-то
[01:08:29.380 --> 01:08:31.380]  не пустая, то в таком случае у нас
[01:08:31.380 --> 01:08:33.380]  работает мэп и мы
[01:08:33.380 --> 01:08:35.380]  скажем, self-head это теперь node-next.
[01:08:35.380 --> 01:08:37.380]  И возвращаем
[01:08:37.380 --> 01:08:39.380]  элемент, который у нас есть.
[01:08:39.380 --> 01:08:41.380]  То есть таким образом мы
[01:08:41.380 --> 01:08:43.380]  преобразовали option-T.
[01:08:43.380 --> 01:08:45.380]  с option-box-node.
[01:08:47.380 --> 01:08:49.380]  Все полностью повторить?
[01:08:49.380 --> 01:08:51.380]  Нет, отличная стейк.
[01:08:51.380 --> 01:08:53.380]  Не можете наполнить стейк?
[01:08:55.380 --> 01:08:57.380]  Take он собственно дает
[01:08:57.380 --> 01:08:59.380]  текущий option и оставляет
[01:08:59.380 --> 01:09:01.380]  на месте старого науны. То есть у нас
[01:09:01.380 --> 01:09:03.380]  в тот момент, когда мы сделали self-head-take,
[01:09:03.380 --> 01:09:05.380]  head стал наун.
[01:09:05.380 --> 01:09:07.380]  То есть мы забрали просто его.
[01:09:11.380 --> 01:09:13.380]  Да, мы его маппим.
[01:09:13.380 --> 01:09:15.380]  Если у нас наун, то
[01:09:15.380 --> 01:09:17.380]  наун. То есть мы забрали наун
[01:09:17.380 --> 01:09:19.380]  с хеда, у нас пустой список, нам нечего
[01:09:19.380 --> 01:09:21.380]  делать, мы возвращаем наун. То есть у нас мэп просто
[01:09:21.380 --> 01:09:23.380]  не сработает, потому что он работает на сам.
[01:09:23.380 --> 01:09:25.380]  Мы вернем наун
[01:09:25.380 --> 01:09:27.380]  в общем-то. Если же
[01:09:27.380 --> 01:09:29.380]  там было сам какое-то значение,
[01:09:29.380 --> 01:09:31.380]  тогда мы посмотрим на эту ноду.
[01:09:31.380 --> 01:09:33.380]  Принимаем наход.
[01:09:33.380 --> 01:09:35.380]  И делаем, мы захватываем
[01:09:35.380 --> 01:09:37.380]  наш self отсюда.
[01:09:37.380 --> 01:09:39.380]  Мы говорим self-head, теперь это node-next.
[01:09:39.380 --> 01:09:41.380]  То есть мы берем
[01:09:41.380 --> 01:09:43.380]  первую голову списка.
[01:09:45.380 --> 01:09:47.380]  У нас был лист, мы забираем
[01:09:47.380 --> 01:09:49.380]  голову списка себе.
[01:09:49.380 --> 01:09:51.380]  Потом мы говорим, что у нас теперь
[01:09:51.380 --> 01:09:53.380]  если оно не нам, то в таком случае у нас
[01:09:53.380 --> 01:09:55.380]  self-head. Self-head это теперь
[01:09:55.380 --> 01:09:57.380]  node-next. То есть мы делаем ссылку
[01:09:57.380 --> 01:09:59.380]  сюда с листа теперь.
[01:09:59.380 --> 01:10:01.380]  А следующий элемент.
[01:10:01.380 --> 01:10:03.380]  И возвращаем элемент отсюда.
[01:10:03.380 --> 01:10:05.380]  То есть тем самым мы диалацируем это все.
[01:10:05.380 --> 01:10:07.380]  И эта вот ссылка, все это пропадает.
[01:10:07.380 --> 01:10:09.380]  Бокс диалацируется.
[01:10:09.380 --> 01:10:11.380]  Мы забрали отсюда t.
[01:10:15.380 --> 01:10:17.380]  Так.
[01:10:17.380 --> 01:10:19.380]  Поскокнуло?
[01:10:19.380 --> 01:10:21.380]  А там так и реализовывали?
[01:10:21.380 --> 01:10:23.380]  Где там?
[01:10:25.380 --> 01:10:27.380]  Ну, вообще там
[01:10:27.380 --> 01:10:29.380]  double-linked-list в Rastia.
[01:10:31.380 --> 01:10:33.380]  На single-linked-list
[01:10:33.380 --> 01:10:35.380]  мало значения имеет, потому что
[01:10:35.380 --> 01:10:37.380]  можно в деку просто написать.
[01:10:37.380 --> 01:10:39.380]  Там нет конструкции unsafe, или там они
[01:10:39.380 --> 01:10:41.380]  на unsafe все написали?
[01:10:41.380 --> 01:10:43.380]  Там на unsafe
[01:10:43.380 --> 01:10:45.380]  скорее всего, потому что
[01:10:45.380 --> 01:10:47.380]  производительность была высокая, там наверное
[01:10:47.380 --> 01:10:49.380]  лишние байтики эти
[01:10:49.380 --> 01:10:51.380]  не держат с опшены.
[01:10:51.380 --> 01:10:53.380]  Прям пишут на unsafe.
[01:10:53.380 --> 01:10:55.380]  Мы используем
[01:10:55.380 --> 01:10:57.380]  нода.
[01:10:57.380 --> 01:10:59.380]  А нод это не отличная структура.
[01:11:03.380 --> 01:11:05.380]  Это хороший вопрос,
[01:11:05.380 --> 01:11:07.380]  но это вопрос, наверное, при четвертую лекцию
[01:11:07.380 --> 01:11:09.380]  про cargo.
[01:11:09.380 --> 01:11:11.380]  Ну, вообще, даже если мы здесь беру папу,
[01:11:11.380 --> 01:11:13.380]  вот эту беру папу, она все равно будет работать.
[01:11:13.380 --> 01:11:15.380]  Это просто будет означать, что
[01:11:15.380 --> 01:11:17.380]  вот это все находится в одном файлике, как можно
[01:11:17.380 --> 01:11:19.380]  догадаться, да, весь этот код.
[01:11:19.380 --> 01:11:21.380]  И он будет доступен
[01:11:21.380 --> 01:11:23.380]  с любой точки этого файла, будет доступен
[01:11:23.380 --> 01:11:25.380]  с любой код с этого файла.
[01:11:25.380 --> 01:11:27.380]  Папа
[01:11:27.380 --> 01:11:29.380]  для кода вокруг, типа, то, что
[01:11:29.380 --> 01:11:31.380]  вне этого файла.
[01:11:31.380 --> 01:11:33.380]  Ну, там
[01:11:33.380 --> 01:11:35.380]  я не знаю, как джаг работает.
[01:11:47.380 --> 01:11:49.380]  Нет, они
[01:11:49.380 --> 01:11:51.380]  все приватные, то есть если хочется сделать публичный
[01:11:51.380 --> 01:11:53.380]  поэк, то нужно написать pub elem, например.
[01:11:53.380 --> 01:11:55.380]  Я же обращаюсь к элементу
[01:11:55.380 --> 01:11:57.380]  ноды.
[01:11:57.380 --> 01:11:59.380]  А здесь внутри, я говорю, файла,
[01:11:59.380 --> 01:12:01.380]  ты можешь как угодно обращаться, то есть ему
[01:12:01.380 --> 01:12:03.380]  без разницы, но то написал ты pub или нет.
[01:12:03.380 --> 01:12:05.380]  Это будет иметь значение.
[01:12:05.380 --> 01:12:07.380]  Elem, next, они публичные
[01:12:07.380 --> 01:12:09.380]  в рамках файла.
[01:12:09.380 --> 01:12:11.380]  Да, в рамках файла, да, если ты с соседнего файла заимпортишь
[01:12:11.380 --> 01:12:13.380]  лист, вот он как раз pub struct, да,
[01:12:13.380 --> 01:12:15.380]  и вот здесь как раз pub fnpub,
[01:12:15.380 --> 01:12:17.380]  то при попытке, например,
[01:12:17.380 --> 01:12:19.380]  заинтересировать какую-то ноду, он скажет, что
[01:12:19.380 --> 01:12:21.380]  структура приватная.
[01:12:21.380 --> 01:12:23.380]  Сделайте публичную, либо изменить свою.
[01:12:23.380 --> 01:12:25.380]  Растяжение туда классное.
[01:12:25.380 --> 01:12:27.380]  Да, вот это вот struct,
[01:12:27.380 --> 01:12:29.380]  struct и trader, все.
[01:12:33.380 --> 01:12:35.380]  Здесь вот написаны какие-то
[01:12:35.380 --> 01:12:37.380]  страшные вещи,
[01:12:37.380 --> 01:12:39.380]  часть из них не обязательно понимать
[01:12:39.380 --> 01:12:41.380]  прямо на данном этапе.
[01:12:41.380 --> 01:12:43.380]  Да, раз гарантирует
[01:12:43.380 --> 01:12:45.380]  нам то, что option будет
[01:12:45.380 --> 01:12:47.380]  оптимизировать,
[01:12:47.380 --> 01:12:49.380]  ну, option будет оптимизировать
[01:12:49.380 --> 01:12:51.380]  свою репрезентацию для
[01:12:51.380 --> 01:12:53.380]  некоторых структур. Например, для бокса.
[01:12:53.380 --> 01:12:55.380]  Бокс у нас, например, насколько
[01:12:55.380 --> 01:12:57.380]  мы помним, не null, да. Соответственно,
[01:12:57.380 --> 01:12:59.380]  если мы сделаем option box,
[01:12:59.380 --> 01:13:01.380]  то в таком случае у нас
[01:13:01.380 --> 01:13:03.380]  null-овый указатель
[01:13:03.380 --> 01:13:05.380]  в боксе будет означать, что у нас вариант
[01:13:05.380 --> 01:13:07.380]  null. Ну, то есть он
[01:13:07.380 --> 01:13:09.380]  раст это, будет учитывать
[01:13:09.380 --> 01:13:11.380]  и не создавать новое
[01:13:11.380 --> 01:13:13.380]  повали в дискриминанте.
[01:13:13.380 --> 01:13:15.380]  Это как раз то, что мы обсуждали в первой лекции.
[01:13:15.380 --> 01:13:17.380]  Аналогично, про ссылку. Ссылка не может
[01:13:17.380 --> 01:13:19.380]  указывать на null
[01:13:19.380 --> 01:13:21.380]  элемент, только на нейтализированный.
[01:13:21.380 --> 01:13:23.380]  Соответственно, option
[01:13:23.380 --> 01:13:25.380]  отсылки на t тоже
[01:13:25.380 --> 01:13:27.380]  оптимизируется. То же самое
[01:13:27.380 --> 01:13:29.380]  с мутабельной ссылкой.
[01:13:29.380 --> 01:13:31.380]  Вот это дальше. Можно всякие функции
[01:13:31.380 --> 01:13:33.380]  внутри держать. Функции, естественно, тоже
[01:13:33.380 --> 01:13:35.380]  не могут быть пустыми, потому что вы указываете
[01:13:35.380 --> 01:13:37.380]  какую-то конкретную функцию, которая будет в option.
[01:13:37.380 --> 01:13:39.380]  Если вы какую-то функцию
[01:13:39.380 --> 01:13:41.380]  сишную вызываете, то она тоже
[01:13:41.380 --> 01:13:43.380]  не пустая. То есть, ну, там не
[01:13:43.380 --> 01:13:45.380]  сишная, какую-то внешнюю функцию,
[01:13:45.380 --> 01:13:47.380]  она тоже какая-то не пустая,
[01:13:47.380 --> 01:13:49.380]  она тоже будет проницилизирована. Соответственно,
[01:13:49.380 --> 01:13:51.380]  раз этим пользуется, раз оптимизирует
[01:13:51.380 --> 01:13:53.380]  репрезентацию option.
[01:13:53.380 --> 01:13:55.380]  Чтобы он занимал ровно столько же байтов, сколько
[01:13:55.380 --> 01:13:57.380]  занимает указатель на
[01:13:57.380 --> 01:13:59.380]  функцию.
[01:14:07.380 --> 01:14:09.380]  Сейчас еще раз. Почему?
[01:14:13.380 --> 01:14:15.380]  Почему
[01:14:15.380 --> 01:14:17.380]  не можно написать option
[01:14:17.380 --> 01:14:19.380]  от node.t? У нас бы тогда
[01:14:19.380 --> 01:14:21.380]  все было на стеке.
[01:14:21.380 --> 01:14:23.380]  Вообще все, весь лист.
[01:14:23.380 --> 01:14:25.380]  Просто бокс, нам же нужно, чтобы
[01:14:25.380 --> 01:14:27.380]  у нас указатель все на хипе было.
[01:14:27.380 --> 01:14:29.380]  Мы бы могли, конечно, это сделать, но
[01:14:29.380 --> 01:14:31.380]  тогда бы просто...
[01:14:33.380 --> 01:14:35.380]  Ну, если у нас хотя бы одна нода
[01:14:35.380 --> 01:14:37.380]  выйдет тогда за
[01:14:37.380 --> 01:14:39.380]  радиус видимости, раз нам скажет,
[01:14:39.380 --> 01:14:41.380]  за свою область видимости, тогда раз нам скажет,
[01:14:41.380 --> 01:14:43.380]  что лист
[01:14:43.380 --> 01:14:45.380]  живет слишком мало
[01:14:45.380 --> 01:14:47.380]  для того, чтобы это содержать значение.
[01:14:47.380 --> 01:14:49.380]  В общем-то нам
[01:14:49.380 --> 01:14:51.380]  наверное мало смысла имеет содержать
[01:14:51.380 --> 01:14:53.380]  такой option node.t.
[01:14:55.380 --> 01:14:57.380]  Еще, кстати, есть одна проблема.
[01:14:57.380 --> 01:14:59.380]  Она не скомпилируется...
[01:14:59.380 --> 01:15:01.380]  Да, я вот это хотел сказать.
[01:15:01.380 --> 01:15:03.380]  Это рекурсивный тип, поэтому он не скомпилируется
[01:15:03.380 --> 01:15:05.380]  на самом деле.
[01:15:05.380 --> 01:15:07.380]  Если просто убрать бокс, то это не скомпилируется.
[01:15:07.380 --> 01:15:09.380]  Потому что это рекурсивный тип
[01:15:09.380 --> 01:15:11.380]  потому что node, node, node, node, node
[01:15:11.380 --> 01:15:13.380]  типа option же он должен занимать
[01:15:13.380 --> 01:15:15.380]  как минимум место node.t
[01:15:15.380 --> 01:15:17.380]  и оно будет рекурсивно вычисляться
[01:15:17.380 --> 01:15:19.380]  и расскажет этот рекурсивный тип.
[01:15:29.380 --> 01:15:31.380]  Вот.
[01:15:31.380 --> 01:15:33.380]  Так видите, презентация транспорта.
[01:15:33.380 --> 01:15:35.380]  Это означает просто то, что
[01:15:35.380 --> 01:15:37.380]  у нас структурка
[01:15:37.380 --> 01:15:39.380]  будет иметь тот же самый вид
[01:15:41.380 --> 01:15:43.380]  что... Смотрите, структурку, например
[01:15:43.380 --> 01:15:45.380]  создал с одним полем.
[01:15:45.380 --> 01:15:47.380]  Структуру с полем X
[01:15:47.380 --> 01:15:49.380]  какого-то типа.
[01:15:49.380 --> 01:15:51.380]  Если он представит репорт транспорта,
[01:15:51.380 --> 01:15:53.380]  то в таком случае эта структура будет иметь
[01:15:53.380 --> 01:15:55.380]  абсолютно точно такую же репрезентацию,
[01:15:55.380 --> 01:15:57.380]  как и само поле X в памяти.
[01:15:57.380 --> 01:15:59.380]  А по умолчанию, раз, не дают никаких
[01:15:59.380 --> 01:16:01.380]  гарантий по поводу того, как этот тип
[01:16:01.380 --> 01:16:03.380]  будет выглядеть.
[01:16:03.380 --> 01:16:05.380]  То есть он может перемешать их.
[01:16:05.380 --> 01:16:07.380]  Казалось бы, одно поле из одного
[01:16:07.380 --> 01:16:09.380]  типа. Казалось бы,
[01:16:09.380 --> 01:16:11.380]  просто вставляя репрезентацию этого типа,
[01:16:11.380 --> 01:16:13.380]  он на самом деле нас может перемешать, потому что
[01:16:13.380 --> 01:16:15.380]  ему так захотелось.
[01:16:17.380 --> 01:16:19.380]  Репорт транспорт нужен
[01:16:19.380 --> 01:16:21.380]  скорее для оптимизации
[01:16:21.380 --> 01:16:23.380]  и для того, чтобы быть
[01:16:23.380 --> 01:16:25.380]  уверенным в том, как это будет все работать.
[01:16:25.380 --> 01:16:27.380]  То есть уверенным репрезентацией
[01:16:27.380 --> 01:16:29.380]  когда ты хочешь,
[01:16:29.380 --> 01:16:31.380]  чтобы ты был уверен, тогда ты это пишешь.
[01:16:31.380 --> 01:16:33.380]  Вот.
[01:16:33.380 --> 01:16:35.380]  Я думаю, что мы сейчас досмотрим
[01:16:35.380 --> 01:16:37.380]  на опшен и пойдем на перерывчик.
[01:16:39.380 --> 01:16:41.380]  А, мы досмотрели
[01:16:41.380 --> 01:16:43.380]  на опшен.
[01:16:43.380 --> 01:16:45.380]  Идем на перерывчик. Давайте
[01:16:45.380 --> 01:16:47.380]  через 10 минут,
[01:16:47.380 --> 01:16:49.380]  ну 35 минут.
[01:16:49.380 --> 01:16:51.380]  Так, для начала
[01:16:51.380 --> 01:16:53.380]  вернемся к этому примеру. Давайте.
[01:16:53.380 --> 01:16:55.380]  Самая большая проблема,
[01:16:55.380 --> 01:16:57.380]  когда я на нее смотрел, я с одной стороны
[01:16:57.380 --> 01:16:59.380]  вижу, что он не должен компилироваться,
[01:16:59.380 --> 01:17:01.380]  а с другой стороны у меня в голове мысль о том,
[01:17:01.380 --> 01:17:03.380]  что это пример должен компилироваться.
[01:17:03.380 --> 01:17:05.380]  То есть, я думал, что у меня где-то
[01:17:05.380 --> 01:17:07.380]  противоречие в голове. Казалось, что он
[01:17:07.380 --> 01:17:09.380]  не должен компилироваться. То есть, это
[01:17:09.380 --> 01:17:11.380]  пример того, как пересекаются
[01:17:11.380 --> 01:17:13.380]  мьютабл флоу и мьютабл флоу.
[01:17:13.380 --> 01:17:15.380]  Смотрите, у нас есть
[01:17:15.380 --> 01:17:17.380]  let mute x, вот там x 42,
[01:17:17.380 --> 01:17:19.380]  и здесь x 43.
[01:17:19.380 --> 01:17:21.380]  Вот с этой строчки по этой строчке,
[01:17:21.380 --> 01:17:23.380]  с x по 43, это все
[01:17:23.380 --> 01:17:25.380]  мьютабл флоу. То есть,
[01:17:25.380 --> 01:17:27.380]  вы увидите, у нас есть x, и мы его мутируем.
[01:17:27.380 --> 01:17:29.380]  Вот мы его здесь не перемутируем.
[01:17:29.380 --> 01:17:31.380]  Там мы присваиваем, вот здесь x
[01:17:31.380 --> 01:17:33.380]  создается. Вот это все
[01:17:33.380 --> 01:17:35.380]  мьютабл флоу, вот эти вот три строчки получается.
[01:17:35.380 --> 01:17:37.380]  Так?
[01:17:37.380 --> 01:17:39.380]  И здесь у нас есть
[01:17:39.380 --> 01:17:41.380]  мьютабл флоу. То есть, у нас есть
[01:17:41.380 --> 01:17:43.380]  let y, это ссылка на x.
[01:17:43.380 --> 01:17:45.380]  Дальше с артикул y
[01:17:45.380 --> 01:17:47.380]  и 42. Здесь у нас уже
[01:17:47.380 --> 01:17:49.380]  получается мьютабл флоу.
[01:17:49.380 --> 01:17:51.380]  И они пересеклись, как вы видите.
[01:17:51.380 --> 01:17:53.380]  То есть, у нас есть имутабельное
[01:17:53.380 --> 01:17:55.380]  и имутабельное флоу, и имутабельное флоу они
[01:17:55.380 --> 01:17:57.380]  пересеклись, и раз, закономерно, наш код
[01:17:57.380 --> 01:17:59.380]  блокчет. Говорят, что так нельзя делать.
[01:18:01.380 --> 01:18:03.380]  Так понятно, да?
[01:18:05.380 --> 01:18:07.380]  Оказалось, я просто-просто
[01:18:07.380 --> 01:18:09.380]  не противоречиваю голове, извините.
[01:18:09.380 --> 01:18:11.380]  Так. Вернемся
[01:18:11.380 --> 01:18:13.380]  к результатам.
[01:18:15.380 --> 01:18:17.380]  Так.
[01:18:17.380 --> 01:18:19.380]  Мы обычно, ну, вообще
[01:18:19.380 --> 01:18:21.380]  результат это один из способов
[01:18:21.380 --> 01:18:23.380]  фарер хендинга. Ему же относятся
[01:18:23.380 --> 01:18:25.380]  в принципе.
[01:18:25.380 --> 01:18:27.380]  Но результат это уже такой для того, чтобы
[01:18:27.380 --> 01:18:29.380]  посмотреть, какая ошибка была.
[01:18:29.380 --> 01:18:31.380]  То есть, если у вас их там может быть много, например,
[01:18:31.380 --> 01:18:33.380]  ошибки EO. Какая конкретно там ошибка?
[01:18:33.380 --> 01:18:35.380]  Например, файлы не смогли открыть.
[01:18:35.380 --> 01:18:37.380]  Я не буду, наверное, перечислять
[01:18:37.380 --> 01:18:39.380]  миллиарды файлов все.
[01:18:39.380 --> 01:18:41.380]  Вот.
[01:18:41.380 --> 01:18:43.380]  Вот, например, ошибка EO может быть
[01:18:43.380 --> 01:18:45.380]  одной из этих.
[01:18:45.380 --> 01:18:47.380]  Вот.
[01:18:47.380 --> 01:18:49.380]  Собственно, в SDCrate
[01:18:49.380 --> 01:18:51.380]  результат преимущественно используется для EO.
[01:18:51.380 --> 01:18:53.380]  Вот.
[01:18:53.380 --> 01:18:55.380]  Еще есть такая вот штука. Результат
[01:18:55.380 --> 01:18:57.380]  обязательно должен быть использован.
[01:18:57.380 --> 01:18:59.380]  Мы не можем скипнуть его использование.
[01:18:59.380 --> 01:19:01.380]  Вы, наверное, знаете, у нас
[01:19:01.380 --> 01:19:03.380]  в плюсах есть такой атрибут.
[01:19:05.380 --> 01:19:07.380]  Что-то я, честно говоря, название подзабыл.
[01:19:07.380 --> 01:19:09.380]  Нолдискар.
[01:19:09.380 --> 01:19:11.380]  Вот.
[01:19:11.380 --> 01:19:13.380]  И, наверное, на курсе TPCC
[01:19:13.380 --> 01:19:15.380]  вы вспоминаете про эхо.
[01:19:15.380 --> 01:19:17.380]  Задачку.
[01:19:17.380 --> 01:19:19.380]  Файберную.
[01:19:21.380 --> 01:19:23.380]  Он кидает варнинги,
[01:19:23.380 --> 01:19:25.380]  насколько я помню.
[01:19:25.380 --> 01:19:27.380]  А потом...
[01:19:29.380 --> 01:19:31.380]  Вот.
[01:19:31.380 --> 01:19:33.380]  Ну, в общем-то,
[01:19:33.380 --> 01:19:35.380]  как раз в этой дачке
[01:19:35.380 --> 01:19:37.380]  у вас появлялся результат.
[01:19:37.380 --> 01:19:39.380]  Как такая структурка.
[01:19:39.380 --> 01:19:41.380]  Это как раз был результат из Rust.
[01:19:41.380 --> 01:19:43.380]  То есть был с нолдискартами
[01:19:43.380 --> 01:19:45.380]  такой, конечно, немножечко обрезанный,
[01:19:45.380 --> 01:19:47.380]  но уже очень похоже на то,
[01:19:47.380 --> 01:19:49.380]  что у нас есть
[01:19:49.380 --> 01:19:51.380]  в Rust.
[01:19:55.380 --> 01:19:57.380]  Я в прошлом году помню,
[01:19:57.380 --> 01:19:59.380]  что-то говорил Липовский про то,
[01:19:59.380 --> 01:20:01.380]  что Rust — это наше светлое будущее.
[01:20:01.380 --> 01:20:03.380]  Мне больше всего запомнилось.
[01:20:05.380 --> 01:20:07.380]  Должна была быть заставка курса.
[01:20:07.380 --> 01:20:09.380]  Да, я, кстати, думал
[01:20:09.380 --> 01:20:11.380]  что-нибудь скриншотик сделать субтитрами.
[01:20:13.380 --> 01:20:15.380]  Ладно.
[01:20:15.380 --> 01:20:17.380]  В общем, здесь у нас
[01:20:17.380 --> 01:20:19.380]  есть такой атрибут mustUse.
[01:20:19.380 --> 01:20:21.380]  Тоже есть атрибут.
[01:20:21.380 --> 01:20:23.380]  И он говорит нам о том, что мы не можем
[01:20:23.380 --> 01:20:25.380]  скипнуть с пользы резалта.
[01:20:25.380 --> 01:20:27.380]  Мы точно так же будем получать варнинги.
[01:20:27.380 --> 01:20:29.380]  Он будет говорить, что вы должны явно
[01:20:29.380 --> 01:20:31.380]  что-то сделать с резалтом.
[01:20:31.380 --> 01:20:33.380]  Один из вариантов — это, например, сделать
[01:20:33.380 --> 01:20:35.380]  let underscope.
[01:20:35.380 --> 01:20:37.380]  Помните, нижнее подчеркивание,
[01:20:37.380 --> 01:20:39.380]  то, что игнорирование значения равняется
[01:20:39.380 --> 01:20:41.380]  какое-то выражение с резалтом.
[01:20:41.380 --> 01:20:43.380]  Или, например, просто поработать с резалтом.
[01:20:43.380 --> 01:20:45.380]  Например, сделать sunwrap,
[01:20:45.380 --> 01:20:47.380]  вот.
[01:20:47.380 --> 01:20:49.380]  Я очень советую такую статью,
[01:20:49.380 --> 01:20:51.380]  если вы ее на курсе конкарнации
[01:20:51.380 --> 01:20:53.380]  не читали.
[01:20:53.380 --> 01:20:55.380]  Там как раз примерно половина статьи
[01:20:55.380 --> 01:20:57.380]  подводит к тому, как устроен
[01:20:57.380 --> 01:20:59.380]  собственно резалт в Rust.
[01:20:59.380 --> 01:21:01.380]  И так, как он устроен, по-моему, в одном из фрейнворков
[01:21:01.380 --> 01:21:03.380]  C-sharp. Я могу
[01:21:03.380 --> 01:21:05.380]  соврать, если честно. Я ее давно не читал
[01:21:05.380 --> 01:21:07.380]  и перечитывал.
[01:21:07.380 --> 01:21:09.380]  Но она очень хорошая.
[01:21:09.380 --> 01:21:11.380]  Она прямо хорошо вам объяснит, почему
[01:21:11.380 --> 01:21:13.380]  такая модель обработки ошибок
[01:21:13.380 --> 01:21:15.380]  на хорошее.
[01:21:19.380 --> 01:21:21.380]  Конечно же, резалт можно точно
[01:21:21.380 --> 01:21:23.380]  так же мачить, как и обычный любую янам.
[01:21:23.380 --> 01:21:25.380]  Вот у нас есть matchVersion.
[01:21:25.380 --> 01:21:27.380]  Это ок, какая-то версия.
[01:21:27.380 --> 01:21:29.380]  Вот мы принтим версию.
[01:21:29.380 --> 01:21:31.380]  Или, например, если какая-то ошибка,
[01:21:31.380 --> 01:21:33.380]  то мы принтим ошибку.
[01:21:35.380 --> 01:21:37.380]  Честно скажу, этот код, наверное, не скомпилируется,
[01:21:37.380 --> 01:21:39.380]  потому что у нас не видно, какой у нас
[01:21:39.380 --> 01:21:41.380]  тип error янама.
[01:21:41.380 --> 01:21:43.380]  То есть там нужно явно прописать,
[01:21:43.380 --> 01:21:45.380]  что это std.evr.
[01:21:45.380 --> 01:21:47.380]  А так раз скажет, что
[01:21:47.380 --> 01:21:49.380]  вывел здесь вот в этом янамочке
[01:21:51.380 --> 01:21:53.380]  А, ну у нас просто очень далеко
[01:21:53.380 --> 01:21:55.380]  в начале лекции, вывел янамочки
[01:21:55.380 --> 01:21:57.380]  тип ten и не вывел тип e.
[01:21:57.380 --> 01:21:59.380]  Ну, в целом, наверное, понятно,
[01:21:59.380 --> 01:22:01.380]  как мачить янамы.
[01:22:01.380 --> 01:22:03.380]  Возможно, вы это даже сделали в домашней ком
[01:22:03.380 --> 01:22:05.380]  какой-нибудь, если вы ее
[01:22:05.380 --> 01:22:07.380]  уже делали.
[01:22:07.380 --> 01:22:09.380]  Вот.
[01:22:09.380 --> 01:22:11.380]  Тут тоже есть миллиард всяких функций.
[01:22:11.380 --> 01:22:13.380]  Это, на самом деле,
[01:22:13.380 --> 01:22:15.380]  если возвращаться к функциональным
[01:22:15.380 --> 01:22:17.380]  программированию, то все дело называется
[01:22:17.380 --> 01:22:19.380]  монады.
[01:22:19.380 --> 01:22:21.380]  Вот. Монады.
[01:22:21.380 --> 01:22:23.380]  Ну, это
[01:22:23.380 --> 01:22:25.380]  просто забейте, я не буду рассказать.
[01:22:25.380 --> 01:22:27.380]  Функциональное программирование,
[01:22:27.380 --> 01:22:29.380]  если вы хотите вспомнить,
[01:22:29.380 --> 01:22:31.380]  можете почитать про монады.
[01:22:31.380 --> 01:22:33.380]  Вот.
[01:22:33.380 --> 01:22:35.380]  Потом
[01:22:35.380 --> 01:22:37.380]  есть всякие функции.
[01:22:37.380 --> 01:22:39.380]  Можно точно так же, как и самый знал,
[01:22:39.380 --> 01:22:41.380]  было выяснить ошибку у нас
[01:22:41.380 --> 01:22:43.380]  или окей.
[01:22:43.380 --> 01:22:45.380]  Unwrap сделать или Unwrap ошибки.
[01:22:45.380 --> 01:22:47.380]  То есть на этот раз мы, если мы
[01:22:47.380 --> 01:22:49.380]  ожидаем ошибку, то мы можем сделать Unwrap error
[01:22:49.380 --> 01:22:51.380]  и получить тип ошибки.
[01:22:51.380 --> 01:22:53.380]  То есть то, что у нас
[01:22:53.380 --> 01:22:55.380]  внутри лежит.
[01:22:55.380 --> 01:22:57.380]  То же самое с экспектом.
[01:22:57.380 --> 01:22:59.380]  К тому же у нас тут есть
[01:22:59.380 --> 01:23:01.380]  SRF и SMU точно так же.
[01:23:01.380 --> 01:23:03.380]  То есть он превращает ссылку
[01:23:03.380 --> 01:23:05.380]  на result в result от
[01:23:05.380 --> 01:23:07.380]  ссылки на T и ссылку на E.
[01:23:09.380 --> 01:23:11.380]  То же бывает полезно, но редко
[01:23:11.380 --> 01:23:13.380]  в случае result.
[01:23:13.380 --> 01:23:15.380]  Так.
[01:23:15.380 --> 01:23:17.380]  Ну и есть тоже очень полезная функция
[01:23:17.380 --> 01:23:19.380]  map, которая часто нужна.
[01:23:19.380 --> 01:23:21.380]  И map error. То есть
[01:23:21.380 --> 01:23:23.380]  map изменит тип
[01:23:23.380 --> 01:23:25.380]  сам T, а
[01:23:25.380 --> 01:23:27.380]  map error изменит тип ошибки.
[01:23:27.380 --> 01:23:29.380]  Ну и там так далее
[01:23:29.380 --> 01:23:31.380]  есть всякие функции.
[01:23:31.380 --> 01:23:33.380]  Тоже рекомендую почитать.
[01:23:35.380 --> 01:23:37.380]  Так, ну давайте для начала посмотрим
[01:23:37.380 --> 01:23:39.380]  на такую структуру.
[01:23:39.380 --> 01:23:41.380]  Она очень простая, в ней есть
[01:23:41.380 --> 01:23:43.380]  имя этой строка и edgeState32.
[01:23:45.380 --> 01:23:47.380]  Так.
[01:23:47.380 --> 01:23:49.380]  Давайте мы попробуем записать какую-то
[01:23:49.380 --> 01:23:51.380]  информацию.
[01:23:51.380 --> 01:23:53.380]  Вот. Нам передали инфо.
[01:23:53.380 --> 01:23:55.380]  И сейчас мы
[01:23:55.380 --> 01:23:57.380]  пытаемся сделать на самом деле
[01:23:57.380 --> 01:23:59.380]  не очень дематично. Попробовать
[01:23:59.380 --> 01:24:01.380]  записать что-то в
[01:24:01.380 --> 01:24:03.380]  myBestFranceTxt.
[01:24:03.380 --> 01:24:05.380]  Помните, что это за результат?
[01:24:05.380 --> 01:24:07.380]  Круглоскобочки это
[01:24:07.380 --> 01:24:09.380]  то, что unitType, который просто
[01:24:09.380 --> 01:24:11.380]  пустой, пустотюбный.
[01:24:11.380 --> 01:24:13.380]  Вот.
[01:24:13.380 --> 01:24:15.380]  Ну то есть в случае, если у нас нет ошибки,
[01:24:15.380 --> 01:24:17.380]  то у нас просто возвращается
[01:24:17.380 --> 01:24:19.380]  unit.
[01:24:19.380 --> 01:24:21.380]  Вот.
[01:24:21.380 --> 01:24:23.380]  Ну смотрите, если у нас
[01:24:23.380 --> 01:24:25.380]  есть ошибка при создании файла, то есть
[01:24:25.380 --> 01:24:27.380]  есть такая функция библиотеки
[01:24:27.380 --> 01:24:29.380]  FileCreate. Если
[01:24:29.380 --> 01:24:31.380]  случилась ошибка, то мы возвращаем ошибку.
[01:24:31.380 --> 01:24:33.380]  Иначе мы возвращаем файл.
[01:24:33.380 --> 01:24:35.380]  Дальше. Если
[01:24:35.380 --> 01:24:37.380]  у нас есть ошибка
[01:24:37.380 --> 01:24:39.380]  при
[01:24:39.380 --> 01:24:41.380]  записи файла,
[01:24:41.380 --> 01:24:43.380]  то в таком случае мы вернем ошибку.
[01:24:43.380 --> 01:24:45.380]  Если у нас опять же есть
[01:24:45.380 --> 01:24:47.380]  при записи файла какая-то ошибка,
[01:24:47.380 --> 01:24:49.380]  то мы еще раз и вернем.
[01:24:49.380 --> 01:24:51.380]  Ну как видите, много более плейта.
[01:24:51.380 --> 01:24:53.380]  Главное, что мы здесь увидим на этом слайде.
[01:24:53.380 --> 01:24:55.380]  У нас с самого начала какой-то матч, а дальше
[01:24:55.380 --> 01:24:57.380]  мы и FlatError, то есть проверяем
[01:24:57.380 --> 01:24:59.380]  является ли это ошибкой.
[01:24:59.380 --> 01:25:01.380]  Очень некрасиво.
[01:25:01.380 --> 01:25:03.380]  На самом деле у Rasta есть решение
[01:25:03.380 --> 01:25:05.380]  назвать оператор вопросительный знак.
[01:25:05.380 --> 01:25:07.380]  Это можно переписать вот так.
[01:25:07.380 --> 01:25:09.380]  И это прекрасно.
[01:25:09.380 --> 01:25:11.380]  Вот.
[01:25:11.380 --> 01:25:13.380]  Ну как он работает?
[01:25:13.380 --> 01:25:15.380]  На самом деле он просто делает матч, если
[01:25:15.380 --> 01:25:17.380]  если у вас там ошибка, то он
[01:25:17.380 --> 01:25:19.380]  делает ретурн ошибки
[01:25:19.380 --> 01:25:21.380]  в функции.
[01:25:21.380 --> 01:25:23.380]  А если там окей, то он возвращает
[01:25:23.380 --> 01:25:25.380]  тип T.
[01:25:25.380 --> 01:25:27.380]  И все.
[01:25:27.380 --> 01:25:29.380]  Ну то есть это на самом деле просто такая
[01:25:29.380 --> 01:25:31.380]  синтоксическая вещь, которая как-то обесахаривается
[01:25:31.380 --> 01:25:33.380]  в один матч.
[01:25:33.380 --> 01:25:35.380]  Вот.
[01:25:35.380 --> 01:25:37.380]  Здесь вот я когда готовил лекцию,
[01:25:37.380 --> 01:25:39.380]  я очень хотел вам показать такой пример
[01:25:39.380 --> 01:25:41.380]  того, как на самом деле происходит
[01:25:41.380 --> 01:25:43.380]  рэхендлинг в ГО и в Rasta.
[01:25:43.380 --> 01:25:45.380]  То есть показать вам пример
[01:25:45.380 --> 01:25:47.380]  двух
[01:25:47.380 --> 01:25:49.380]  подходов.
[01:25:49.380 --> 01:25:51.380]  Если вы работали с ГО, то вы наверное помните, что у вас
[01:25:51.380 --> 01:25:53.380]  если функция возвращает
[01:25:53.380 --> 01:25:55.380]  что-то,
[01:25:55.380 --> 01:25:57.380]  допустим вы там пишете
[01:25:57.380 --> 01:25:59.380]  значение error
[01:25:59.380 --> 01:26:01.380]  равняется и там какая-то функция.
[01:26:01.380 --> 01:26:03.380]  И дальше if error
[01:26:03.380 --> 01:26:05.380]  не равняется new return error.
[01:26:05.380 --> 01:26:07.380]  У вас много
[01:26:07.380 --> 01:26:09.380]  такого кода может быть.
[01:26:09.380 --> 01:26:11.380]  Вот у меня был такой, где-то вот я видел
[01:26:11.380 --> 01:26:13.380]  такую прекрасную картиночку, в которой
[01:26:13.380 --> 01:26:15.380]  взяли произвольную функцию на ГО с какого-то
[01:26:15.380 --> 01:26:17.380]  большего проекта.
[01:26:17.380 --> 01:26:19.380]  И взяли произвольную функцию на Rasta с произвольного проекта.
[01:26:19.380 --> 01:26:21.380]  И подчеркнули желтым
[01:26:21.380 --> 01:26:23.380]  все, что касается рэхендлинга.
[01:26:23.380 --> 01:26:25.380]  Но в ГО это было больше половины кода.
[01:26:25.380 --> 01:26:27.380]  Там просто все if и вот эти вот
[01:26:27.380 --> 01:26:29.380]  if error не равняется
[01:26:29.380 --> 01:26:31.380]  new return error.
[01:26:31.380 --> 01:26:33.380]  Это вот бесконечное. А в Rasta весь
[01:26:33.380 --> 01:26:35.380]  рэхендлинг был просто вот в вопросике.
[01:26:35.380 --> 01:26:37.380]  Подчеркивали где-то в конце и все.
[01:26:37.380 --> 01:26:39.380]  Если у нас
[01:26:39.380 --> 01:26:41.380]  возвращается ошибка,
[01:26:41.380 --> 01:26:43.380]  мы же потом не сможем сделать
[01:26:43.380 --> 01:26:45.380]  рэхендлинг.
[01:26:45.380 --> 01:26:47.380]  Вот если у нас
[01:26:47.380 --> 01:26:49.380]  возвращается ошибка из правил
[01:26:49.380 --> 01:26:51.380]  кэйки, то у нас же не сработает
[01:26:51.380 --> 01:26:53.380]  на райдол, на край.
[01:26:53.380 --> 01:26:55.380]  Ну да, у нас же вопрос
[01:26:55.380 --> 01:26:57.380]  вернет ошибку. Он вернет ошибку
[01:26:57.380 --> 01:26:59.380]  из функции. Функция, смотри, видишь,
[01:26:59.380 --> 01:27:01.380]  его result имеет сигнатуру.
[01:27:01.380 --> 01:27:03.380]  Она вернет ошибку, припыхнет выше.
[01:27:09.380 --> 01:27:11.380]  Что еще?
[01:27:13.380 --> 01:27:15.380]  Если видишь, у нас return
[01:27:15.380 --> 01:27:17.380]  так вот возвращает ошибку.
[01:27:17.380 --> 01:27:19.380]  Вот этот match сверху есть,
[01:27:19.380 --> 01:27:21.380]  это то же самое, что делает вопросик
[01:27:21.380 --> 01:27:23.380]  в точности.
[01:27:27.380 --> 01:27:29.380]  А, то есть он сразу возвращает?
[01:27:29.380 --> 01:27:31.380]  А если этими функциями?
[01:27:31.380 --> 01:27:33.380]  В плане функции.
[01:27:35.380 --> 01:27:37.380]  Вот там return третьей строчки
[01:27:37.380 --> 01:27:39.380]  это return из функции?
[01:27:39.380 --> 01:27:41.380]  Да, да.
[01:27:41.380 --> 01:27:43.380]  Это return
[01:27:43.380 --> 01:27:45.380]  всегда работает
[01:27:45.380 --> 01:27:47.380]  в изратость функции.
[01:27:47.380 --> 01:27:49.380]  То есть если у вас там будут циклы,
[01:27:49.380 --> 01:27:51.380]  все равно у вас все из функции возвращаться.
[01:27:51.380 --> 01:27:53.380]  Ну как и в C, в C++, там точно
[01:27:53.380 --> 01:27:55.380]  такая же логика.
[01:27:55.380 --> 01:27:57.380]  А если мы в main
[01:27:57.380 --> 01:27:59.380]  напишем?
[01:27:59.380 --> 01:28:01.380]  О, кстати, если вы в main, такое тоже бывает.
[01:28:01.380 --> 01:28:03.380]  В получении main у вас, конечно, возвращает unit.
[01:28:03.380 --> 01:28:05.380]  Но вы можете в main, я так сделал в Rover,
[01:28:05.380 --> 01:28:07.380]  в нашей тулзе, он возвращает
[01:28:07.380 --> 01:28:09.380]  тоже какой-то result
[01:28:09.380 --> 01:28:11.380]  от unit.
[01:28:11.380 --> 01:28:13.380]  Вот, и вы можете пропихивать
[01:28:13.380 --> 01:28:15.380]  даже в main дальше ошибки.
[01:28:15.380 --> 01:28:17.380]  И куда они пропихиваются?
[01:28:17.380 --> 01:28:19.380]  Они пропихиваются в трамплин, а там все по умолчанию
[01:28:19.380 --> 01:28:21.380]  просто ангрэпами делается.
[01:28:21.380 --> 01:28:23.380]  И он поймет, что вы ему пропихнули ошибку
[01:28:23.380 --> 01:28:25.380]  из main и вывезет ее на экран.
[01:28:25.380 --> 01:28:27.380]  Все.
[01:28:29.380 --> 01:28:31.380]  Правда, там на самом деле
[01:28:31.380 --> 01:28:33.380]  в Rover хитрее, там используется такой крейт
[01:28:33.380 --> 01:28:35.380]  называется Anyhow.
[01:28:35.380 --> 01:28:37.380]  То есть в Rust у нас, как вы могли
[01:28:37.380 --> 01:28:39.380]  заметить,
[01:28:39.380 --> 01:28:41.380]  используется template для ошибок.
[01:28:41.380 --> 01:28:43.380]  То есть там T и E есть,
[01:28:43.380 --> 01:28:45.380]  тип T и тип E.
[01:28:45.380 --> 01:28:47.380]  Но дело в том, что иногда бывает такое,
[01:28:47.380 --> 01:28:49.380]  что у вас в одной функции очень много разных
[01:28:49.380 --> 01:28:51.380]  типов ошибок. У вас может быть там ошибка
[01:28:51.380 --> 01:28:53.380]  IO, еще какая-то ошибка
[01:28:53.380 --> 01:28:55.380]  из библиотеки там своя
[01:28:55.380 --> 01:28:57.380]  и так далее.
[01:28:57.380 --> 01:28:59.380]  Это не очень удобно
[01:28:59.380 --> 01:29:01.380]  бывает, когда вы
[01:29:01.380 --> 01:29:03.380]  пытаетесь привести все к какому-то
[01:29:03.380 --> 01:29:05.380]  одному result. У вас тогда появляются
[01:29:05.380 --> 01:29:07.380]  свои какие-то янамы ошибок, это больно.
[01:29:09.380 --> 01:29:11.380]  Нет, поэтому там просто
[01:29:11.380 --> 01:29:13.380]  динамический result.
[01:29:13.380 --> 01:29:15.380]  То есть там просто динамически приводится
[01:29:15.380 --> 01:29:17.380]  все к типу ошибки.
[01:29:17.380 --> 01:29:19.380]  Там как там называется?
[01:29:19.380 --> 01:29:21.380]  Похоже на T и E.
[01:29:25.380 --> 01:29:27.380]  В общем, виртуально
[01:29:27.380 --> 01:29:29.380]  это все.
[01:29:29.380 --> 01:29:31.380]  Я забыл слова, если честно, как они там
[01:29:31.380 --> 01:29:33.380]  называются точнее.
[01:29:33.380 --> 01:29:35.380]  Похоже на T и E.
[01:29:35.380 --> 01:29:37.380]  Ну, что-то типа того.
[01:29:37.380 --> 01:29:39.380]  Тогда это TypeRanger, мы стираем тип.
[01:29:39.380 --> 01:29:41.380]  Да, но там просто
[01:29:41.380 --> 01:29:43.380]  динамически врантами все происходит.
[01:29:43.380 --> 01:29:45.380]  Так и T и E.
[01:29:45.380 --> 01:29:47.380]  Тоже врантами.
[01:29:47.380 --> 01:29:49.380]  Так.
[01:29:49.380 --> 01:29:51.380]  Давайте пойдем дальше.
[01:29:51.380 --> 01:29:53.380]  У нас есть еще
[01:29:53.380 --> 01:29:55.380]  вот такая вот функция, которую знают
[01:29:55.380 --> 01:29:57.380]  очень мало даже профи Раста.
[01:29:57.380 --> 01:29:59.380]  Звается Transpose.
[01:29:59.380 --> 01:30:01.380]  Вы можете о ней прочитать даже документацию.
[01:30:01.380 --> 01:30:03.380]  Я сама не узнал, на самом деле только тогда,
[01:30:03.380 --> 01:30:05.380]  когда сходил на одну конференцию по Расту.
[01:30:05.380 --> 01:30:07.380]  Там рассказывали про...
[01:30:07.380 --> 01:30:09.380]  Ну, один такой
[01:30:09.380 --> 01:30:11.380]  достаточно розумный парень
[01:30:11.380 --> 01:30:13.380]  рассказывал про то, как можно
[01:30:13.380 --> 01:30:15.380]  делать какое-то на Расте более дематичное и красивое.
[01:30:15.380 --> 01:30:17.380]  Потом он сказал про Transpose.
[01:30:17.380 --> 01:30:19.380]  Transpose — такая штука,
[01:30:19.380 --> 01:30:21.380]  которая между собой представляет
[01:30:21.380 --> 01:30:23.380]  Option и Result.
[01:30:23.380 --> 01:30:25.380]  То есть если вот, например, у вас тип
[01:30:25.380 --> 01:30:27.380]  Option и Result от T и E,
[01:30:27.380 --> 01:30:29.380]  то в таком случае у вас появляется
[01:30:29.380 --> 01:30:31.380]  функция Transpose от Self.
[01:30:31.380 --> 01:30:33.380]  И то, что она делает, она
[01:30:33.380 --> 01:30:35.380]  выпихивает Result вверх,
[01:30:35.380 --> 01:30:37.380]  а Option засовывает внутрь.
[01:30:37.380 --> 01:30:39.380]  И то же самое
[01:30:39.380 --> 01:30:41.380]  в случае ошибки. Если у вас Result
[01:30:41.380 --> 01:30:43.380]  Option от T и E, в таком случае
[01:30:43.380 --> 01:30:45.380]  у вас тоже меняются местами.
[01:30:45.380 --> 01:30:47.380]  Это порой бывает очень удобно.
[01:30:49.380 --> 01:30:51.380]  Так, у меня даже есть пример.
[01:30:51.380 --> 01:30:53.380]  Отлично.
[01:30:53.380 --> 01:30:55.380]  Смотрите, вот, например, мы
[01:30:55.380 --> 01:30:57.380]  читаем что-то вот из CDIn.
[01:30:57.380 --> 01:30:59.380]  Мы взяли строчки из CDIn.
[01:30:59.380 --> 01:31:01.380]  Какая-то output-строчка.
[01:31:01.380 --> 01:31:03.380]  Я просто напомню.
[01:31:03.380 --> 01:31:05.380]  InputNext — это у нас итератор.
[01:31:05.380 --> 01:31:07.380]  Мы с итераторами особенно не работали пока что.
[01:31:07.380 --> 01:31:09.380]  Но он будет возвращать.
[01:31:09.380 --> 01:31:11.380]  Каждая строчка у нас ResultString.
[01:31:11.380 --> 01:31:13.380]  И так как итератор
[01:31:13.380 --> 01:31:15.380]  сам по себе либо нам возвращает,
[01:31:15.380 --> 01:31:17.380]  либо сам значение, тогда это OptionResult от String.
[01:31:19.380 --> 01:31:21.380]  Понимаете, да?
[01:31:21.380 --> 01:31:23.380]  То есть у нас Result от String,
[01:31:23.380 --> 01:31:25.380]  потому что у нас может быть
[01:31:25.380 --> 01:31:27.380]  ошибка при чтении из CDIn.
[01:31:27.380 --> 01:31:29.380]  Ну и Option, потому что у нас строчки
[01:31:29.380 --> 01:31:31.380]  могли закончиться.
[01:31:31.380 --> 01:31:33.380]  Смотрите, вот что мы
[01:31:33.380 --> 01:31:35.380]  делаем здесь.
[01:31:39.380 --> 01:31:41.380]  До тех пор, пока мы какую-то строчку
[01:31:41.380 --> 01:31:43.380]  прочитали, мы Line
[01:31:43.380 --> 01:31:45.380]  зачем-то, если у нас Result
[01:31:45.380 --> 01:31:47.380]  с Error, то в таком случае мы припихнем
[01:31:47.380 --> 01:31:49.380]  дальше с учетом вопросика.
[01:31:51.380 --> 01:31:53.380]  В плане Line
[01:31:53.380 --> 01:31:55.380]  у нас будет сейчас ResultString.
[01:31:55.380 --> 01:31:57.380]  Когда мы сделаем вопросик, то это просто String станет.
[01:31:57.380 --> 01:31:59.380]  Типа Shadowing будет.
[01:31:59.380 --> 01:32:01.380]  Вот.
[01:32:01.380 --> 01:32:03.380]  Если строка пустая, тогда мы
[01:32:03.380 --> 01:32:05.380]  брейкнемся, да, иначе мы в Output
[01:32:05.380 --> 01:32:07.380]  запушим строчку.
[01:32:07.380 --> 01:32:09.380]  В самом деле с помощью Transpose
[01:32:09.380 --> 01:32:11.380]  можно сделать чуть красивее.
[01:32:11.380 --> 01:32:13.380]  — Это наша домашка?
[01:32:13.380 --> 01:32:15.380]  — Нет, не наша домашка.
[01:32:15.380 --> 01:32:17.380]  У нас комму,
[01:32:17.380 --> 01:32:19.380]  там нужно еще хэштаблиться и пользоваться,
[01:32:19.380 --> 01:32:21.380]  чтобы помочь строчке.
[01:32:21.380 --> 01:32:23.380]  — Хэштаблиться.
[01:32:23.380 --> 01:32:25.380]  — Так.
[01:32:25.380 --> 01:32:27.380]  Здесь у нас, смотрите,
[01:32:27.380 --> 01:32:29.380]  используется Next и Transpose,
[01:32:29.380 --> 01:32:31.380]  и вопросик сразу же.
[01:32:31.380 --> 01:32:33.380]  И мы получаем просто Line, это String.
[01:32:33.380 --> 01:32:35.380]  То есть у нас Next — это OptionResult от String,
[01:32:35.380 --> 01:32:37.380]  потом я делаю Result,
[01:32:37.380 --> 01:32:39.380]  ну Transpose, я получаю Result от Option
[01:32:39.380 --> 01:32:41.380]  от String.
[01:32:41.380 --> 01:32:43.380]  Соответственно, я потом
[01:32:43.380 --> 01:32:45.380]  делаю вопросик, получаю просто Option
[01:32:45.380 --> 01:32:47.380]  от String,
[01:32:47.380 --> 01:32:49.380]  матчу с самым Line и получаю просто String.
[01:32:49.380 --> 01:32:51.380]  Какая машинерия хитрая.
[01:32:55.380 --> 01:32:57.380]  Одна вот строчечка —
[01:32:57.380 --> 01:32:59.380]  оп, и у вас так красивее становится.
[01:32:59.380 --> 01:33:01.380]  Сколько я помню, в ровере в одном месте даже используется.
[01:33:03.380 --> 01:33:05.380]  Где-то было полезно.
[01:33:07.380 --> 01:33:09.380]  Давайте, наверное, прежде чем
[01:33:09.380 --> 01:33:11.380]  контейнером перейдем, есть
[01:33:11.380 --> 01:33:13.380]  какие-то вопросы по Option и Result?
[01:33:19.380 --> 01:33:21.380]  — Получается от двух типов всегда.
[01:33:21.380 --> 01:33:23.380]  — Да, там два типа.
[01:33:23.380 --> 01:33:25.380]  — То есть аналог для STD-варианта нет?
[01:33:25.380 --> 01:33:27.380]  — STD-варианта,
[01:33:27.380 --> 01:33:29.380]  напомню, это что, пожалуйста?
[01:33:29.380 --> 01:33:31.380]  — Это вот, по сути, то же самое,
[01:33:31.380 --> 01:33:33.380]  только с несколькими типами.
[01:33:35.380 --> 01:33:37.380]  — По-моему, туда
[01:33:37.380 --> 01:33:39.380]  можно запихнуть какие-то произвольные типы.
[01:33:39.380 --> 01:33:41.380]  — Да.
[01:33:41.380 --> 01:33:43.380]  — Это, по-моему, вообще никак
[01:33:43.380 --> 01:33:45.380]  не сходится с Result
[01:33:45.380 --> 01:33:47.380]  логически.
[01:33:47.380 --> 01:33:49.380]  — А, ну,
[01:33:49.380 --> 01:33:51.380]  я не знаю.
[01:33:51.380 --> 01:33:53.380]  — Не, ну, можно считать Result
[01:33:53.380 --> 01:33:55.380]  какой-то особо интерфейсным вариантом
[01:33:55.380 --> 01:33:57.380]  от результатов и ошибки, собственно.
[01:33:59.380 --> 01:34:01.380]  — Я бы сказал, что это там
[01:34:01.380 --> 01:34:03.380]  скорее Union внутри Unum.
[01:34:03.380 --> 01:34:05.380]  Вот.
[01:34:05.380 --> 01:34:07.380]  — Просто проблема Union в том, что
[01:34:07.380 --> 01:34:09.380]  Union не знает, что в себе хранение.
[01:34:09.380 --> 01:34:11.380]  — Да, поэтому деструктор не вызывается.
[01:34:11.380 --> 01:34:13.380]  — Поэтому есть вариант.
[01:34:13.380 --> 01:34:15.380]  Это Union с паниточками.
[01:34:15.380 --> 01:34:17.380]  — Как
[01:34:17.380 --> 01:34:19.380]  вернуть ошибки?
[01:34:19.380 --> 01:34:21.380]  Меня Синцева за счет писал
[01:34:21.380 --> 01:34:23.380]  не сконструировать ошибки?
[01:34:23.380 --> 01:34:25.380]  — Смотри.
[01:34:25.380 --> 01:34:27.380]  — По-хорошему, без практики.
[01:34:27.380 --> 01:34:29.380]  — Ну, сконструировать ошибку
[01:34:29.380 --> 01:34:31.380]  тебе это нужно только тогда,
[01:34:31.380 --> 01:34:33.380]  когда ты хочешь сконструировать свой тип ошибки.
[01:34:33.380 --> 01:34:35.380]  Ну, если у тебя не свои типы ошибки,
[01:34:35.380 --> 01:34:37.380]  то они просто пропихиваются какие-то чужие
[01:34:37.380 --> 01:34:39.380]  наверх, чаще всего, да?
[01:34:41.380 --> 01:34:43.380]  Если у тебя свой тип ошибки,
[01:34:43.380 --> 01:34:45.380]  тогда у тебя, чаще всего, какой-то свой Unum.
[01:34:45.380 --> 01:34:47.380]  Ведем какие-то свои варианты
[01:34:47.380 --> 01:34:49.380]  ошибок. И чтобы создать,
[01:34:49.380 --> 01:34:51.380]  ты просто пишешь Error
[01:34:51.380 --> 01:34:53.380]  и внутри один из вариантов Unum.
[01:34:53.380 --> 01:34:55.380]  — Просто есть какой-то
[01:34:55.380 --> 01:34:57.380]  стандартный Unum
[01:34:57.380 --> 01:34:59.380]  для ошибок?
[01:34:59.380 --> 01:35:01.380]  — Ну, стандартный Unum,
[01:35:01.380 --> 01:35:03.380]  дело в том, что каждая ошибка
[01:35:03.380 --> 01:35:05.380]  из разного рода,
[01:35:05.380 --> 01:35:07.380]  скажем так. Его ошибка, они
[01:35:07.380 --> 01:35:09.380]  одни. Ошибки
[01:35:09.380 --> 01:35:11.380]  какие-нибудь в библиотеке,
[01:35:11.380 --> 01:35:13.380]  другие, например, там могут быть ошибки,
[01:35:13.380 --> 01:35:15.380]  неправильно распаршен
[01:35:15.380 --> 01:35:17.380]  конфига, там свои Unum добавляются.
[01:35:17.380 --> 01:35:19.380]  То есть, ну, по каждому
[01:35:19.380 --> 01:35:21.380]  случаю добавляются свои Unum,
[01:35:21.380 --> 01:35:23.380]  если нужно.
[01:35:25.380 --> 01:35:27.380]  Вот, я еще, наверное, не
[01:35:27.380 --> 01:35:29.380]  проговорил, option, над option
[01:35:29.380 --> 01:35:31.380]  на самом деле тоже вопросик работает.
[01:35:31.380 --> 01:35:33.380]  То есть, он точно так же
[01:35:33.380 --> 01:35:35.380]  либо пропихивает Unum наверх, либо
[01:35:35.380 --> 01:35:37.380]  возвращает то, что он там
[01:35:37.380 --> 01:35:39.380]  есть. Совершенно точно так же.
[01:35:41.380 --> 01:35:43.380]  — В общем, чтобы свое описание
[01:35:43.380 --> 01:35:45.380]  определить, знаю вопрос.
[01:35:47.380 --> 01:35:49.380]  — Не, это только вещь, которая работает
[01:35:49.380 --> 01:35:51.380]  для optional result.
[01:35:55.380 --> 01:35:57.380]  Ну, там просто custom на обе сахары
[01:35:57.380 --> 01:35:59.380]  у меня, да? Там в одном случае сам она,
[01:35:59.380 --> 01:36:01.380]  а в другом случае OK Error.
[01:36:01.380 --> 01:36:03.380]  — Ну, как-то ведь
[01:36:03.380 --> 01:36:05.380]  создана эта сахарка просто
[01:36:05.380 --> 01:36:07.380]  дебрик-компилятор.
[01:36:07.380 --> 01:36:09.380]  — Что конкретно
[01:36:09.380 --> 01:36:11.380]  дебрик-компилятор?
[01:36:13.380 --> 01:36:15.380]  — Ну, да, это синтоктический сахар
[01:36:15.380 --> 01:36:17.380]  и там
[01:36:17.380 --> 01:36:19.380]  его нельзя перекрутить
[01:36:19.380 --> 01:36:21.380]  на свои Unum какие-нибудь.
[01:36:21.380 --> 01:36:23.380]  — Ну, если ты припишешь компилятор, наверное...
[01:36:23.380 --> 01:36:25.380]  — Ну, на свои Unum
[01:36:25.380 --> 01:36:27.380]  не сказать, что это дебрик-компилятор,
[01:36:27.380 --> 01:36:29.380]  это просто вставляется какой-то
[01:36:29.380 --> 01:36:31.380]  заранее определенный, вполне определенный матч
[01:36:31.380 --> 01:36:33.380]  внутрь. Ну да,
[01:36:33.380 --> 01:36:35.380]  ты не можешь написать для своих типов
[01:36:35.380 --> 01:36:37.380]  вопросик.
[01:36:37.380 --> 01:36:39.380]  — Компилятор...
[01:36:39.380 --> 01:36:41.380]  ...
[01:36:41.380 --> 01:36:43.380]  ...
[01:36:43.380 --> 01:36:45.380]  ...
[01:36:45.380 --> 01:36:47.380]  ...
[01:36:47.380 --> 01:36:49.380]  — Так, перейдем к контейнерам.
[01:36:49.380 --> 01:36:51.380]  На самом деле, это будет достаточно прикольно,
[01:36:51.380 --> 01:36:53.380]  на мой взгляд.
[01:36:55.380 --> 01:36:57.380]  Давайте для начала поговорим
[01:36:57.380 --> 01:36:59.380]  об общих свойствах контейнера в Rasty.
[01:37:01.380 --> 01:37:03.380]  Во-первых, мы чаще всего боимся
[01:37:03.380 --> 01:37:05.380]  локации в Rasty.
[01:37:05.380 --> 01:37:07.380]  На самом деле, во многих функциях
[01:37:07.380 --> 01:37:09.380]  пытаемся как-то переиспользовать локации.
[01:37:09.380 --> 01:37:11.380]  Ну, мы это заметим, когда мы посмотрим
[01:37:11.380 --> 01:37:13.380]  на то, как работать с его в Rasty.
[01:37:13.380 --> 01:37:15.380]  В общем,
[01:37:15.380 --> 01:37:17.380]  стараемся по максимуму не вызывать всякие омолоки,
[01:37:17.380 --> 01:37:19.380]  потому что это зачастую
[01:37:19.380 --> 01:37:21.380]  очень сильно понижает производительность программы.
[01:37:23.380 --> 01:37:25.380]  Вот.
[01:37:25.380 --> 01:37:27.380]  Потом, мы не хотим как в плюсах,
[01:37:27.380 --> 01:37:29.380]  если у нас какой-то некорректный импут,
[01:37:29.380 --> 01:37:31.380]  например, на пустом векторе мы попросили
[01:37:31.380 --> 01:37:33.380]  попнуть последний элемент.
[01:37:35.380 --> 01:37:37.380]  Мы хотим вернуть просто наум,
[01:37:37.380 --> 01:37:39.380]  что такого элемента нет.
[01:37:39.380 --> 01:37:41.380]  Поэтому мы активно используем
[01:37:41.380 --> 01:37:43.380]  OptionResult во всех стандартных контейнерах.
[01:37:45.380 --> 01:37:47.380]  Ну, и особенно OptionResult,
[01:37:47.380 --> 01:37:49.380]  я там сходы не вспомню, где есть,
[01:37:49.380 --> 01:37:51.380]  но, по-моему, где-то есть контейнеры.
[01:37:53.380 --> 01:37:55.380]  Потом некоторые
[01:37:55.380 --> 01:37:57.380]  для удобства,
[01:37:57.380 --> 01:37:59.380]  например, вот вектор, если вы будете
[01:37:59.380 --> 01:38:01.380]  написать в квадратной скобочке,
[01:38:01.380 --> 01:38:03.380]  то в таком случае у вас
[01:38:03.380 --> 01:38:05.380]  будет возвращаться сам тип T,
[01:38:05.380 --> 01:38:07.380]  ссылка на тип T.
[01:38:07.380 --> 01:38:09.380]  Для того, чтобы вам было...
[01:38:09.380 --> 01:38:11.380]  Это же удобнее, чем, например,
[01:38:11.380 --> 01:38:13.380]  написать в квадратной скобочке
[01:38:13.380 --> 01:38:15.380]  и возвращался бы в Option,
[01:38:15.380 --> 01:38:17.380]  но все равно нужно было бы писать какие-то андрэпы.
[01:38:17.380 --> 01:38:19.380]  Поэтому раз, делай так. Если у вас
[01:38:19.380 --> 01:38:21.380]  ничего там, например, не было,
[01:38:21.380 --> 01:38:23.380]  например, в случае вектора вы вышли за границу массива,
[01:38:23.380 --> 01:38:25.380]  в таком случае квадратные скобочки
[01:38:25.380 --> 01:38:27.380]  просто паникуют, они не делают никаких проверок.
[01:38:29.380 --> 01:38:31.380]  То есть это
[01:38:31.380 --> 01:38:33.380]  точнее проверки делают,
[01:38:33.380 --> 01:38:35.380]  за счет этого паникуют, просто что
[01:38:35.380 --> 01:38:37.380]  не возвращают Option для вашего удобства.
[01:38:39.380 --> 01:38:41.380]  Это хороший вопрос.
[01:38:41.380 --> 01:38:43.380]  Замедляет ли это код? На самом деле нет
[01:38:43.380 --> 01:38:45.380]  по замерам. Даже в какие-то моменты
[01:38:45.380 --> 01:38:47.380]  выяснялось, что почему-то код с проверками
[01:38:47.380 --> 01:38:49.380]  работает быстрее. Ну там есть
[01:38:49.380 --> 01:38:51.380]  branch prediction, просто зачастую он
[01:38:53.380 --> 01:38:55.380]  работает процессор очень эффективно,
[01:38:55.380 --> 01:38:57.380]  и в итоге эти все бранчи просто даже
[01:38:57.380 --> 01:38:59.380]  никак не замедляют процессор
[01:38:59.380 --> 01:39:01.380]  с проверкой того, входите вы
[01:39:01.380 --> 01:39:03.380]  или нет в границы.
[01:39:05.380 --> 01:39:07.380]  В плюсах у нас есть такие вот произвольные
[01:39:07.380 --> 01:39:09.380]  итераторы. Мы там можем взять 10 итераторов
[01:39:09.380 --> 01:39:11.380]  в разные части вектора.
[01:39:11.380 --> 01:39:13.380]  У нас нет таких произвольных
[01:39:13.380 --> 01:39:15.380]  итераторов, как
[01:39:15.380 --> 01:39:17.380]  C++, потому что у нас есть
[01:39:17.380 --> 01:39:19.380]  ownership. Мы можем, например,
[01:39:19.380 --> 01:39:21.380]  на мапу взять несколько
[01:39:21.380 --> 01:39:23.380]  мутабельных
[01:39:23.380 --> 01:39:25.380]  entries, то есть
[01:39:25.380 --> 01:39:27.380]  ссылочки на хэшмап.
[01:39:27.380 --> 01:39:29.380]  Поэтому у нас
[01:39:29.380 --> 01:39:31.380]  это влияет на то, как у нас будут
[01:39:31.380 --> 01:39:33.380]  устроены контейнеры. Сейчас мы как раз на это
[01:39:33.380 --> 01:39:35.380]  будем смотреть и сравниваться.
[01:39:37.380 --> 01:39:39.380]  И это очень сильно на самом деле влияет
[01:39:39.380 --> 01:39:41.380]  на то, как устроена у нас стандартная библиотека.
[01:39:41.380 --> 01:39:43.380]  И как-то странно, в лучшую сторону.
[01:39:43.380 --> 01:39:45.380]  У нас гораздо более быстрая алгоритма, чем в плюсах
[01:39:45.380 --> 01:39:47.380]  в стандартной библиотеке.
[01:39:51.380 --> 01:39:53.380]  Кстати, вот интересный такой факт.
[01:39:53.380 --> 01:39:55.380]  В расти, например, если вы делаете
[01:39:55.380 --> 01:39:57.380]  push, он внезапно может запаниковать.
[01:39:59.380 --> 01:40:01.380]  Почему может запаниковать push?
[01:40:01.380 --> 01:40:03.380]  Потому что у вас, например, локация не удалась.
[01:40:03.380 --> 01:40:05.380]  Почему еще он может запаниковать?
[01:40:05.380 --> 01:40:07.380]  Или, например, если вы пытаетесь залоцировать
[01:40:07.380 --> 01:40:09.380]  больше, чем усайс элементов.
[01:40:09.380 --> 01:40:11.380]  Даже не усайс, а усайс максимум.
[01:40:11.380 --> 01:40:13.380]  Точно не припомню.
[01:40:13.380 --> 01:40:15.380]  Только, конечно, не залоцируйте
[01:40:15.380 --> 01:40:17.380]  числа там во вселенной.
[01:40:19.380 --> 01:40:21.380]  На самом деле, такие вещи, как
[01:40:21.380 --> 01:40:23.380]  fallible locations, они на самом деле очень мешают
[01:40:23.380 --> 01:40:25.380]  работать
[01:40:25.380 --> 01:40:27.380]  прямо в ядре линукса, например.
[01:40:27.380 --> 01:40:29.380]  Ну и сейчас одна из вещей,
[01:40:29.380 --> 01:40:31.380]  которая преграждает
[01:40:31.380 --> 01:40:33.380]  расту попасть в ядро линукса, это то,
[01:40:33.380 --> 01:40:35.380]  что fallible locations
[01:40:35.380 --> 01:40:37.380]  случаются иногда.
[01:40:37.380 --> 01:40:39.380]  Поэтому добавляют векторы try push.
[01:40:39.380 --> 01:40:41.380]  В боксе есть try new.
[01:40:41.380 --> 01:40:43.380]  То есть они возвращают
[01:40:43.380 --> 01:40:45.380]  option, если удалась локация.
[01:40:45.380 --> 01:40:47.380]  То тогда он возвращает
[01:40:47.380 --> 01:40:49.380]  сам бокс, например, в случае бокса.
[01:40:49.380 --> 01:40:51.380]  Либо наоборот, если она не удалась.
[01:40:53.380 --> 01:40:55.380]  Просто было бы плохо, на самом деле, если вы пишете ядро,
[01:40:55.380 --> 01:40:57.380]  и оно там из-за того, что вы
[01:40:57.380 --> 01:40:59.380]  запустились на каком-то ужасном железе, на котором мало памяти,
[01:40:59.380 --> 01:41:01.380]  у вас запаниковало ядро, да?
[01:41:01.380 --> 01:41:03.380]  Как-то плохо.
[01:41:03.380 --> 01:41:05.380]  Поэтому...
[01:41:11.380 --> 01:41:13.380]  Тут есть как раз
[01:41:13.380 --> 01:41:15.380]  РФС,
[01:41:15.380 --> 01:41:17.380]  РФС 21.16, это как раз про то,
[01:41:17.380 --> 01:41:19.380]  как поддерживать fallible locations,
[01:41:19.380 --> 01:41:21.380]  и есть
[01:41:21.380 --> 01:41:23.380]  письмо Торвальдзу об этом еще.
[01:41:23.380 --> 01:41:25.380]  Можете почитать в свободное время,
[01:41:25.380 --> 01:41:27.380]  если вам будет интересно.
[01:41:33.380 --> 01:41:35.380]  Давайте посмотрим, собственно,
[01:41:35.380 --> 01:41:37.380]  на нашу стандартную структуру.
[01:41:37.380 --> 01:41:39.380]  Вектор, с которым вы уже очень хорошо знакомы.
[01:41:39.380 --> 01:41:41.380]  Он, в принципе, устроен уже так же, как плюсакт,
[01:41:41.380 --> 01:41:43.380]  не учитывая то, что там есть какие-то
[01:41:43.380 --> 01:41:45.380]  разницы, например,
[01:41:45.380 --> 01:41:47.380]  связанные с тем, что
[01:41:47.380 --> 01:41:49.380]  move в плюсах внезапно может провалиться,
[01:41:49.380 --> 01:41:51.380]  поэтому вам приходится это
[01:41:51.380 --> 01:41:53.380]  поддерживать. В Расте у вас такого
[01:41:53.380 --> 01:41:55.380]  не может быть, потому что это просто копирование байтов.
[01:42:03.380 --> 01:42:05.380]  Нет-нет, я хочу сказать про то,
[01:42:05.380 --> 01:42:07.380]  что элементы вектора, если когда-то их
[01:42:07.380 --> 01:42:09.380]  move вышли из одной локации в другую, могут...
[01:42:15.380 --> 01:42:17.380]  Ну, потому что
[01:42:17.380 --> 01:42:19.380]  в плюсах у тебя в move может быть
[01:42:19.380 --> 01:42:21.380]  произвольная логика,
[01:42:21.380 --> 01:42:23.380]  а в Расте у тебя это просто
[01:42:23.380 --> 01:42:25.380]  мем-копия элемента самой структурки.
[01:42:25.380 --> 01:42:27.380]  И все.
[01:42:27.380 --> 01:42:29.380]  Поэтому там не может быть никаких ошибок,
[01:42:29.380 --> 01:42:31.380]  если локация уже случилась,
[01:42:31.380 --> 01:42:33.380]  ты просто приписываешь байтики, никаких ошибок
[01:42:33.380 --> 01:42:35.380]  быть не может.
[01:42:35.380 --> 01:42:37.380]  Ну,
[01:42:37.380 --> 01:42:39.380]  то есть, конечно, мы это все проговорим,
[01:42:39.380 --> 01:42:41.380]  потом на лекции про unsafe
[01:42:41.380 --> 01:42:43.380]  мы прям посмотрим на импрементацию вектора внутри.
[01:42:43.380 --> 01:42:45.380]  Если кому-то тоже интересно,
[01:42:45.380 --> 01:42:47.380]  можете посмотреть наперед, есть такая книжка
[01:42:47.380 --> 01:42:49.380]  Rastamamecon, там
[01:42:49.380 --> 01:42:51.380]  объясняется, как вектор внутри устроен.
[01:42:51.380 --> 01:42:53.380]  Растовский.
[01:42:53.380 --> 01:42:55.380]  Вот. Давайте поговорим...
[01:42:55.380 --> 01:42:57.380]  Ну, конечно, не будем говорить про всякие там
[01:42:57.380 --> 01:42:59.380]  индексации, все такое, это все достаточно скучно.
[01:42:59.380 --> 01:43:01.380]  Давайте посмотрим
[01:43:01.380 --> 01:43:03.380]  на базовые алгоритмы. Очень прикольные.
[01:43:03.380 --> 01:43:05.380]  Во-первых,
[01:43:05.380 --> 01:43:07.380]  есть sort. Ну, sort стабильная, естественно,
[01:43:07.380 --> 01:43:09.380]  сортировка, но от нее это
[01:43:09.380 --> 01:43:11.380]  ожидаем. Там используется какой-то
[01:43:11.380 --> 01:43:13.380]  модифицированный team sort, я сильно не разбираюсь в этом.
[01:43:13.380 --> 01:43:15.380]  Работает за аналогенную
[01:43:15.380 --> 01:43:17.380]  в среднем, в худшем случае.
[01:43:21.380 --> 01:43:23.380]  Про описание этого модифицированного
[01:43:23.380 --> 01:43:25.380]  team sort. Честно говоря, я не знаю
[01:43:25.380 --> 01:43:27.380]  конкретно про team sort. Вот про следующую сортировку
[01:43:27.380 --> 01:43:29.380]  я могу тебе даже накидать.
[01:43:33.380 --> 01:43:35.380]  Нет, там книжка про unsafe,
[01:43:35.380 --> 01:43:37.380]  она не про эти алгоритмы.
[01:43:41.380 --> 01:43:43.380]  Они уже есть. Вы зайдите
[01:43:43.380 --> 01:43:45.380]  в репозиторию, посмотрите на
[01:43:45.380 --> 01:43:47.380]  additional reading.
[01:43:47.380 --> 01:43:49.380]  Там целый список, есть интересных книжечек
[01:43:49.380 --> 01:43:51.380]  и статей надо почитать.
[01:43:51.380 --> 01:43:53.380]  Особенно очень много книжек всяких.
[01:43:55.380 --> 01:43:57.380]  Да, сейчас я расскажу.
[01:43:59.380 --> 01:44:01.380]  Вот есть sort unstable.
[01:44:01.380 --> 01:44:03.380]  Нестабильная сортировка,
[01:44:03.380 --> 01:44:05.380]  напоминаю, стабильная сортировка,
[01:44:05.380 --> 01:44:07.380]  она ни в коем случае не понимает
[01:44:07.380 --> 01:44:09.380]  порядок элементов, которые равны.
[01:44:09.380 --> 01:44:11.380]  Нестабильная сортировка может
[01:44:11.380 --> 01:44:13.380]  поменять, и за счет этого она быстрее
[01:44:13.380 --> 01:44:15.380]  может работать, потому что она дает меньше гарантий.
[01:44:15.380 --> 01:44:17.380]  В Rust используется
[01:44:17.380 --> 01:44:19.380]  PDQ sort, это pattern defeating
[01:44:19.380 --> 01:44:21.380]  quick sort.
[01:44:21.380 --> 01:44:23.380]  Это крайне дикий алгоритм, очень
[01:44:23.380 --> 01:44:25.380]  быстрый.
[01:44:25.380 --> 01:44:27.380]  Я снизу сделал
[01:44:27.380 --> 01:44:29.380]  на Данилу Кутене насылочку.
[01:44:29.380 --> 01:44:31.380]  Это такой очень шаристый чувак
[01:44:31.380 --> 01:44:33.380]  с Google, синьор, и, возможно, вы даже
[01:44:33.380 --> 01:44:35.380]  знаете его.
[01:44:35.380 --> 01:44:37.380]  Когда-нибудь экспериментал.
[01:44:37.380 --> 01:44:39.380]  Он рассказывает про то,
[01:44:39.380 --> 01:44:41.380]  как они
[01:44:41.380 --> 01:44:43.380]  что делают в Google,
[01:44:43.380 --> 01:44:45.380]  и так далее.
[01:44:45.380 --> 01:44:47.380]  У него есть пост про
[01:44:47.380 --> 01:44:49.380]  PDQ sort. Его комментарии
[01:44:49.380 --> 01:44:51.380]  это, похоже, самая лучшая сортировка,
[01:44:51.380 --> 01:44:53.380]  и сейчас его вообще делать лучше не могут.
[01:44:53.380 --> 01:44:55.380]  PDQ sort это просто стандартная
[01:44:55.380 --> 01:44:57.380]  библиотека, используется sort unstable,
[01:44:57.380 --> 01:44:59.380]  и вот там самая быстрая сортировка,
[01:44:59.380 --> 01:45:01.380]  которая только может быть.
[01:45:01.380 --> 01:45:03.380]  В худшем случае она работает
[01:45:03.380 --> 01:45:05.380]  за nlog n, но на практике она работает
[01:45:05.380 --> 01:45:07.380]  так же, потому что она учитывает
[01:45:07.380 --> 01:45:09.380]  всякие паттерны, которые частенько
[01:45:09.380 --> 01:45:11.380]  возникают на практике.
[01:45:11.380 --> 01:45:13.380]  Там всякие уже отсортированные массивы,
[01:45:13.380 --> 01:45:15.380]  куски отсортированных массивов,
[01:45:15.380 --> 01:45:17.380]  и так далее.
[01:45:17.380 --> 01:45:19.380]  Это практически очень-очень быстрый алгоритм.
[01:45:23.380 --> 01:45:25.380]  В плане, что
[01:45:25.380 --> 01:45:27.380]  ее лучший кейс это просто oAten работа.
[01:45:31.380 --> 01:45:33.380]  Еще, кстати, Данилу Кутене
[01:45:33.380 --> 01:45:35.380]  писал в блоге про то, как они
[01:45:35.380 --> 01:45:37.380]  пушили, есть такая еще сортировка bitset sort,
[01:45:37.380 --> 01:45:39.380]  я с разницей
[01:45:39.380 --> 01:45:41.380]  с PDQ sort не разбираюсь,
[01:45:41.380 --> 01:45:43.380]  я не разбирался с этим алгоритмом.
[01:45:43.380 --> 01:45:45.380]  Это тоже какая-то очень быстрая сортировка,
[01:45:45.380 --> 01:45:47.380]  и они хотели ее в lvm
[01:45:47.380 --> 01:45:49.380]  libcxx в гугле
[01:45:49.380 --> 01:45:51.380]  пропушить.
[01:45:51.380 --> 01:45:53.380]  Данилу в своем канале жаловался
[01:45:53.380 --> 01:45:55.380]  про то, как же сложно
[01:45:55.380 --> 01:45:57.380]  что-то пропушить в lvm,
[01:45:57.380 --> 01:45:59.380]  потому что люди очень-очень
[01:45:59.380 --> 01:46:01.380]  настроены консервативно.
[01:46:01.380 --> 01:46:03.380]  То есть они отправляют непонятно куда.
[01:46:07.380 --> 01:46:09.380]  Я очень советую почитать
[01:46:09.380 --> 01:46:11.380]  это интересное такое наблюдение,
[01:46:11.380 --> 01:46:13.380]  что в плюсы очень сложно,
[01:46:13.380 --> 01:46:15.380]  даже с учетом того, что это соответствует стандарту,
[01:46:15.380 --> 01:46:17.380]  запихнуть самый лучший данный алгоритм сортировки.
[01:46:31.380 --> 01:46:33.380]  Дальше есть бинарный поиск,
[01:46:33.380 --> 01:46:35.380]  но с бинарным поиском все понятно,
[01:46:35.380 --> 01:46:37.380]  если массив отсортирован, но ищем за логин.
[01:46:37.380 --> 01:46:39.380]  Потом есть select-enfance-table,
[01:46:39.380 --> 01:46:41.380]  это quick-selector, основанно
[01:46:41.380 --> 01:46:43.380]  PDQ sort, как вы понимаете,
[01:46:43.380 --> 01:46:45.380]  тоже работает очень быстро.
[01:46:45.380 --> 01:46:47.380]  Я, кстати, не уверен,
[01:46:47.380 --> 01:46:49.380]  пытается ли он это понять.
[01:46:49.380 --> 01:46:51.380]  Я могу только сказать...
[01:47:15.380 --> 01:47:17.380]  Возможно,
[01:47:17.380 --> 01:47:19.380]  тоже умеет.
[01:47:19.380 --> 01:47:21.380]  Можно просто почитать документацию,
[01:47:21.380 --> 01:47:23.380]  выясните.
[01:47:27.380 --> 01:47:29.380]  Я могу только сказать,
[01:47:29.380 --> 01:47:31.380]  что будет в кейсе,
[01:47:31.380 --> 01:47:33.380]  если вы дадите некорректные входные данные
[01:47:33.380 --> 01:47:35.380]  к этому алгоритму. Он в таком случае
[01:47:35.380 --> 01:47:37.380]  гарантирует, я не дам никакого undefined behavior,
[01:47:37.380 --> 01:47:39.380]  я вам не дам memory unsafety,
[01:47:39.380 --> 01:47:41.380]  unspecialized результат,
[01:47:41.380 --> 01:47:43.380]  который вы получите.
[01:47:43.380 --> 01:47:45.380]  Вы можете получить аборт программы,
[01:47:45.380 --> 01:47:47.380]  вы можете получить панику,
[01:47:47.380 --> 01:47:49.380]  вы можете получить неправильный ответ
[01:47:49.380 --> 01:47:51.380]  binary-search. То есть у вас будет
[01:47:51.380 --> 01:47:53.380]  корректно продолжать работа программы,
[01:47:53.380 --> 01:47:55.380]  у вас даже не сломаются никакие варианты,
[01:47:55.380 --> 01:47:57.380]  которые вокруг, конечно,
[01:47:57.380 --> 01:47:59.380]  кроме binary-search.
[01:47:59.380 --> 01:48:01.380]  Но при этом
[01:48:01.380 --> 01:48:03.380]  у вас может произойти
[01:48:03.380 --> 01:48:05.380]  произвольная фигня.
[01:48:05.380 --> 01:48:07.380]  То есть лучше так не делать, конечно,
[01:48:07.380 --> 01:48:09.380]  а то
[01:48:09.380 --> 01:48:11.380]  мало что может случиться.
[01:48:11.380 --> 01:48:13.380]  Это выбрать n-перемент
[01:48:13.380 --> 01:48:15.380]  по...
[01:48:15.380 --> 01:48:17.380]  Это я сейчас еще про binary-search был вопрос,
[01:48:17.380 --> 01:48:19.380]  я чуть-чуть рассказал про то,
[01:48:19.380 --> 01:48:21.380]  как он хендлит кейсы, когда
[01:48:21.380 --> 01:48:23.380]  у него ошибки.
[01:48:23.380 --> 01:48:25.380]  Да, я имел в виду фуксы, которые мы и поняли.
[01:48:25.380 --> 01:48:27.380]  Select nfrontstable,
[01:48:27.380 --> 01:48:29.380]  это просто quick-selection
[01:48:29.380 --> 01:48:31.380]  PDQ-сварт, который работает даже в курсе
[01:48:31.380 --> 01:48:33.380]  случаев за OAuthn, очень быстро
[01:48:33.380 --> 01:48:35.380]  такая штука.
[01:48:35.380 --> 01:48:37.380]  Выбирать n,
[01:48:37.380 --> 01:48:39.380]  она сортирует точно так же,
[01:48:39.380 --> 01:48:41.380]  в плюсах частично сортирует массив.
[01:48:41.380 --> 01:48:43.380]  И у тебя
[01:48:43.380 --> 01:48:45.380]  после вызова этой функции
[01:48:45.380 --> 01:48:47.380]  на n-м месте гарантированно будет
[01:48:47.380 --> 01:48:49.380]  n-ный элемент. Все остальные элементы
[01:48:49.380 --> 01:48:51.380]  как-то возможно подвинутся.
[01:48:55.380 --> 01:48:57.380]  Потом еще есть...
[01:48:57.380 --> 01:48:59.380]  Так как все эти алгоритмы основаны на сортировках,
[01:48:59.380 --> 01:49:01.380]  вы хотите, возможно, пользоваться
[01:49:01.380 --> 01:49:03.380]  компаратором, который вы сами сдадите.
[01:49:03.380 --> 01:49:05.380]  Для этого есть buy и buykey варианты,
[01:49:05.380 --> 01:49:07.380]  которые позволяют констамизировать компаратор.
[01:49:07.380 --> 01:49:09.380]  Например, sort-buy
[01:49:09.380 --> 01:49:11.380]  или sort-unstable-buykey
[01:49:15.380 --> 01:49:17.380]  Вот такие вот варианты.
[01:49:17.380 --> 01:49:19.380]  Еще есть легендарное
[01:49:19.380 --> 01:49:21.380]  rotate-left и rotate-right.
[01:49:21.380 --> 01:49:23.380]  Я скинул going-native.
[01:49:23.380 --> 01:49:25.380]  Возможно, вы помните эту пражу
[01:49:25.380 --> 01:49:27.380]  it's-a-rotate.
[01:49:27.380 --> 01:49:29.380]  Не помните?
[01:49:29.380 --> 01:49:31.380]  В общем, там фанат
[01:49:31.380 --> 01:49:33.380]  переиспользовать код.
[01:49:33.380 --> 01:49:35.380]  Говорил про то, как можно
[01:49:35.380 --> 01:49:37.380]  в банальные алгоритмы
[01:49:37.380 --> 01:49:39.380]  в плюсах писать короче.
[01:49:39.380 --> 01:49:41.380]  И там почти все решалось rotate-ом.
[01:49:43.380 --> 01:49:45.380]  На самом деле
[01:49:45.380 --> 01:49:47.380]  прикольный толк. Советую посмотреть.
[01:49:55.380 --> 01:49:57.380]  Так.
[01:49:57.380 --> 01:49:59.380]  Потом есть veg-deck.
[01:49:59.380 --> 01:50:01.380]  Асимптотики... Ну, я не буду
[01:50:01.380 --> 01:50:03.380]  прописывать конкретные асимптотики.
[01:50:03.380 --> 01:50:05.380]  Те, которые вы ожидаете.
[01:50:05.380 --> 01:50:07.380]  Вот единицы на пуши,
[01:50:07.380 --> 01:50:09.380]  мактизированные на попы единицы,
[01:50:09.380 --> 01:50:11.380]  вот единицы
[01:50:11.380 --> 01:50:13.380]  рандомный аксесс.
[01:50:13.380 --> 01:50:15.380]  Но тем не менее
[01:50:15.380 --> 01:50:17.380]  внутри алгоритм не тот же, что в плюсах.
[01:50:19.380 --> 01:50:21.380]  Давайте мы об этом поговорим.
[01:50:23.380 --> 01:50:25.380]  Есть, во-первых, те же самые функции,
[01:50:25.380 --> 01:50:27.380]  что в векторе деке.
[01:50:27.380 --> 01:50:29.380]  Во-вторых, есть те же самые
[01:50:29.380 --> 01:50:31.380]  отличия от unsafe-языков.
[01:50:31.380 --> 01:50:33.380]  То самое, что мы обсудили
[01:50:33.380 --> 01:50:35.380]  в начале главы про коллекции.
[01:50:35.380 --> 01:50:37.380]  То есть, про ссылочки,
[01:50:37.380 --> 01:50:39.380]  про итераторы, все такое.
[01:50:39.380 --> 01:50:41.380]  То, что мы пытаемся меньше локаций делать.
[01:50:45.380 --> 01:50:47.380]  Потом.
[01:50:47.380 --> 01:50:49.380]  Дело в том, что veg-deck
[01:50:49.380 --> 01:50:51.380]  расловски основано
[01:50:51.380 --> 01:50:53.380]  просто в циклическом деке.
[01:50:53.380 --> 01:50:55.380]  То есть, вы, наверное, на первом курсе
[01:50:55.380 --> 01:50:57.380]  заставляли писать какой-нибудь
[01:50:57.380 --> 01:50:59.380]  дек простейший, в котором был
[01:50:59.380 --> 01:51:01.380]  был вектор и просто два указателя,
[01:51:01.380 --> 01:51:03.380]  которые с ширеалистом по кругу ходили.
[01:51:03.380 --> 01:51:05.380]  Вот это вот просто расловский дек.
[01:51:05.380 --> 01:51:07.380]  Он не выпиандривается.
[01:51:09.380 --> 01:51:11.380]  На самом деле, из-за этого мы получаем
[01:51:11.380 --> 01:51:13.380]  очень много хороших пропорций.
[01:51:13.380 --> 01:51:15.380]  Во-первых, есть make-continuous.
[01:51:15.380 --> 01:51:17.380]  Так как мы знаем, что
[01:51:17.380 --> 01:51:19.380]  дек в памяти расположен
[01:51:19.380 --> 01:51:21.380]  так вот хорошо,
[01:51:21.380 --> 01:51:23.380]  беспрерывно,
[01:51:23.380 --> 01:51:25.380]  то мы можем просто его зареаренджить
[01:51:25.380 --> 01:51:27.380]  и сделать одним большим слайсом.
[01:51:27.380 --> 01:51:29.380]  Мы можем, например, использовать всякие
[01:51:29.380 --> 01:51:31.380]  SIMD инструкции.
[01:51:31.380 --> 01:51:33.380]  В плюсах мы сейчас обсудим, почему это невозможно.
[01:51:33.380 --> 01:51:35.380]  Еще есть всякие функции,
[01:51:35.380 --> 01:51:37.380]  вроде as-slices.
[01:51:37.380 --> 01:51:39.380]  Если make-continuous делает один большой слайс,
[01:51:39.380 --> 01:51:41.380]  то as-slices возвращает слайс
[01:51:41.380 --> 01:51:43.380]  до одного конца,
[01:51:43.380 --> 01:51:45.380]  а слайс после другого конца.
[01:51:45.380 --> 01:51:47.380]  То есть, из этих двух слайсов у вас
[01:51:47.380 --> 01:51:49.380]  получится весь дек.
[01:51:49.380 --> 01:51:51.380]  Представляете, да?
[01:51:51.380 --> 01:51:53.380]  В плане,
[01:51:53.380 --> 01:51:55.380]  валидируется или ссылки?
[01:51:55.380 --> 01:51:57.380]  В плане,
[01:51:57.380 --> 01:51:59.380]  валидируется или ссылки?
[01:52:01.380 --> 01:52:03.380]  Ты просто не можешь валидировать ссылки
[01:52:03.380 --> 01:52:05.380]  в Rast, потому что если ты попробуешь мутировать,
[01:52:05.380 --> 01:52:07.380]  когда у тебя есть ссылка, то Rast тебе забанит код.
[01:52:15.380 --> 01:52:17.380]  Это очень-очень хорошее замечание.
[01:52:17.380 --> 01:52:19.380]  Мы сейчас будем про это говорить.
[01:52:21.380 --> 01:52:23.380]  Вот смотрите,
[01:52:23.380 --> 01:52:25.380]  вот буквально следующий слайд.
[01:52:25.380 --> 01:52:27.380]  Тут буквально человек посмотрел будущее
[01:52:27.380 --> 01:52:29.380]  и сказал нам, что у нас интераторы не валидируются
[01:52:29.380 --> 01:52:31.380]  в плюсах. Действительно, это так.
[01:52:31.380 --> 01:52:33.380]  У нас в лицо на стандарте написано,
[01:52:33.380 --> 01:52:35.380]  мы ожидаем на стандарте дека,
[01:52:35.380 --> 01:52:37.380]  что когда мы его модифицируем,
[01:52:37.380 --> 01:52:39.380]  у него не ломается интератор.
[01:52:39.380 --> 01:52:41.380]  И в итоге,
[01:52:41.380 --> 01:52:43.380]  ну как вы понимаете, циклический дек
[01:52:43.380 --> 01:52:45.380]  мы просто не используем,
[01:52:45.380 --> 01:52:47.380]  потому что если вдруг реаллокация,
[01:52:47.380 --> 01:52:49.380]  то в таком случае у вас ломаются все указатели,
[01:52:49.380 --> 01:52:51.380]  ломаются все индексы.
[01:52:51.380 --> 01:52:53.380]  Вы никак не можете просто оставить там
[01:52:53.380 --> 01:52:55.380]  интераторы. Приходится использовать
[01:52:55.380 --> 01:52:57.380]  другую имплементацию.
[01:52:57.380 --> 01:52:59.380]  Вот.
[01:52:59.380 --> 01:53:01.380]  Ну, это вот как раз проблема, о которой мы не воткнулись.
[01:53:01.380 --> 01:53:03.380]  Давайте мы пробуем решить.
[01:53:03.380 --> 01:53:05.380]  Как мы решим?
[01:53:05.380 --> 01:53:07.380]  Ну, какой-нибудь простой вариант.
[01:53:09.380 --> 01:53:11.380]  Не-не.
[01:53:11.380 --> 01:53:13.380]  Это плюсовый дек как раз решает эту проблему.
[01:53:19.380 --> 01:53:21.380]  Ну, кучки это уже следующий шаг.
[01:53:21.380 --> 01:53:23.380]  Давай мы сделаем чуть-чуть попроще.
[01:53:23.380 --> 01:53:25.380]  Мы будем вместо самого элемента
[01:53:25.380 --> 01:53:27.380]  в циклическом деке хранить
[01:53:27.380 --> 01:53:29.380]  указательный этот элемент, да.
[01:53:29.380 --> 01:53:31.380]  И допустим,
[01:53:31.380 --> 01:53:33.380]  в простом варианте будем хранить
[01:53:33.380 --> 01:53:35.380]  из этого,
[01:53:35.380 --> 01:53:37.380]  будем даже хранить не самый элемент,
[01:53:37.380 --> 01:53:39.380]  а указательную структуру,
[01:53:39.380 --> 01:53:41.380]  которая содержит элемент
[01:53:41.380 --> 01:53:43.380]  и указательную его позицию в деке.
[01:53:43.380 --> 01:53:45.380]  Давай, допустим, так сделаем.
[01:53:45.380 --> 01:53:47.380]  Да, у нас все вообще медленнее работает.
[01:53:47.380 --> 01:53:49.380]  Ну, за счет этого у нас получается так,
[01:53:49.380 --> 01:53:51.380]  что если у нас есть итератор,
[01:53:51.380 --> 01:53:53.380]  ну, понятно, как работает
[01:53:53.380 --> 01:53:55.380]  random access, тут итераторы у нас
[01:53:55.380 --> 01:53:57.380]  не инвелидируются, потому что если мы
[01:53:57.380 --> 01:53:59.380]  содернем ссылку на элемент,
[01:53:59.380 --> 01:54:01.380]  то когда мы возвращаемся обратно
[01:54:01.380 --> 01:54:03.380]  в дек,
[01:54:03.380 --> 01:54:05.380]  нам достаточно просто вернуться обратно в дек,
[01:54:05.380 --> 01:54:07.380]  посмотреть следующий элемент
[01:54:07.380 --> 01:54:09.380]  и пойти вниз, да.
[01:54:09.380 --> 01:54:11.380]  Обратно, если можно.
[01:54:11.380 --> 01:54:13.380]  Ну, вот.
[01:54:13.380 --> 01:54:15.380]  Обратно, если мы
[01:54:17.380 --> 01:54:19.380]  ну, когда мы пишем на таком деке
[01:54:19.380 --> 01:54:21.380]  итераторы.
[01:54:21.380 --> 01:54:23.380]  Но есть проблема, что это все работает медленно.
[01:54:23.380 --> 01:54:25.380]  Ну, захотим мы, допустим, проитерировать
[01:54:25.380 --> 01:54:27.380]  по этому деку.
[01:54:27.380 --> 01:54:29.380]  И выясним проблему, что у нас на каждый элемент
[01:54:29.380 --> 01:54:31.380]  получается,
[01:54:31.380 --> 01:54:33.380]  что мы идем по указателю.
[01:54:33.380 --> 01:54:35.380]  Какой-то бред получается.
[01:54:35.380 --> 01:54:37.380]  У нас все работает очень медленно, мы постоянно
[01:54:37.380 --> 01:54:39.380]  ходим по указателю, это ничем не лучше
[01:54:39.380 --> 01:54:41.380]  списка. Ну, давайте мы чуть-чуть
[01:54:41.380 --> 01:54:43.380]  улучшим. Мы скажем,
[01:54:43.380 --> 01:54:45.380]  ну, вот.
[01:54:45.380 --> 01:54:47.380]  Мы не кошлокальны, да.
[01:54:47.380 --> 01:54:49.380]  Забываю слайды листать.
[01:54:49.380 --> 01:54:51.380]  У нас есть еще такая
[01:54:51.380 --> 01:54:53.380]  проблема.
[01:54:53.380 --> 01:54:55.380]  Ну, не такая проблема, я так говорю.
[01:54:55.380 --> 01:54:57.380]  Давайте вместо одного элемента будем
[01:54:57.380 --> 01:54:59.380]  хранить, скажем, тысячу элементов.
[01:54:59.380 --> 01:55:01.380]  Ну, и теперь, когда мы будем
[01:55:01.380 --> 01:55:03.380]  проходить по указателю, мы будем
[01:55:03.380 --> 01:55:05.380]  получать сразу же тысячу элементов.
[01:55:05.380 --> 01:55:07.380]  И, соответственно, там
[01:55:07.380 --> 01:55:09.380]  чуть-чуть изменится механика, например,
[01:55:09.380 --> 01:55:11.380]  Access, потому что нам нужно будет посмотреть
[01:55:11.380 --> 01:55:13.380]  сначала на первый
[01:55:13.380 --> 01:55:15.380]  наш буфер. Возможно,
[01:55:15.380 --> 01:55:17.380]  будет где-то там слева недозаполнен.
[01:55:17.380 --> 01:55:19.380]  Нам нужно будет знать, сколько
[01:55:19.380 --> 01:55:21.380]  элементов. Ну, чуть-чуть изменится, но при этом
[01:55:21.380 --> 01:55:23.380]  от единиц как было так осталось.
[01:55:23.380 --> 01:55:25.380]  Вот.
[01:55:25.380 --> 01:55:27.380]  Ну, и вот, в общем-то,
[01:55:27.380 --> 01:55:29.380]  будем хранить чанки,
[01:55:29.380 --> 01:55:31.380]  и у нас все станет хорошо.
[01:55:31.380 --> 01:55:33.380]  Давайте мы сейчас посмотрим
[01:55:33.380 --> 01:55:35.380]  на картиночку и заодно
[01:55:35.380 --> 01:55:37.380]  выясним, все ли поняли,
[01:55:37.380 --> 01:55:39.380]  как это все устроено в плюсах.
[01:55:39.380 --> 01:55:41.380]  Сейчас это разве уже не STDDEC?
[01:55:41.380 --> 01:55:43.380]  Да, это STDDEC.
[01:55:43.380 --> 01:55:45.380]  Теперь понятно, почему ссылки
[01:55:45.380 --> 01:55:47.380]  не лидируются.
[01:55:47.380 --> 01:55:49.380]  Как итераторы.
[01:55:49.380 --> 01:55:51.380]  Ну, ты понимаешь,
[01:55:51.380 --> 01:55:53.380]  random access на обычном
[01:55:53.380 --> 01:55:55.380]  циклическом деке, да?
[01:55:55.380 --> 01:55:57.380]  Ну, просто самый левый кусочек, да?
[01:55:57.380 --> 01:55:59.380]  Разберемся.
[01:55:59.380 --> 01:56:01.380]  Вот.
[01:56:01.380 --> 01:56:03.380]  Вот.
[01:56:03.380 --> 01:56:05.380]  Вот.
[01:56:05.380 --> 01:56:07.380]  Вот.
[01:56:07.380 --> 01:56:09.380]  Вот.
[01:56:09.380 --> 01:56:11.380]  Вот.
[01:56:11.380 --> 01:56:13.380]  Вот.
[01:56:13.380 --> 01:56:15.380]  Вот.
[01:56:15.380 --> 01:56:17.380]  Вот.
[01:56:17.380 --> 01:56:19.380]  Разберемся.
[01:56:19.380 --> 01:56:21.380]  Вот.
[01:56:21.380 --> 01:56:23.380]  Вот такая вот у нас структура.
[01:56:23.380 --> 01:56:25.380]  Все ли понятны?
[01:56:33.380 --> 01:56:35.380]  Ну, получается, да.
[01:56:39.380 --> 01:56:41.380]  Ну, это все, на самом деле, чисто техническое.
[01:56:41.380 --> 01:56:43.380]  Если ты хочешь на какое-то произвольное,
[01:56:43.380 --> 01:56:45.380]  ты просто, например, вернешься,
[01:56:45.380 --> 01:56:47.380]  в каком-то элемент сейчас находишься,
[01:56:47.380 --> 01:56:49.380]  вернешься в деку, знаешь глобально на каком-то элементе,
[01:56:49.380 --> 01:56:51.380]  добавишь число и попрошу дека
[01:56:51.380 --> 01:56:53.380]  указательного элемента. Ну, допустим.
[01:56:53.380 --> 01:56:55.380]  Это, возможно, самое эффективное,
[01:56:55.380 --> 01:56:57.380]  но зато работает.
[01:57:07.380 --> 01:57:09.380]  Нет, по чанку ты никак не поймешь,
[01:57:09.380 --> 01:57:11.380]  конечно. Тебе нужно будет узнать,
[01:57:11.380 --> 01:57:13.380]  где ты находишься в чанке, а потом вернуться
[01:57:13.380 --> 01:57:15.380]  в деку. Где-то в чанке ты можешь узнать.
[01:57:23.380 --> 01:57:25.380]  У него же указатель глобально на чанк
[01:57:25.380 --> 01:57:27.380]  и номер какой-то, где он там находится
[01:57:27.380 --> 01:57:29.380]  внутри чанка.
[01:57:31.380 --> 01:57:33.380]  Этот номер внутри чанка
[01:57:33.380 --> 01:57:35.380]  не ломается.
[01:57:37.380 --> 01:57:39.380]  Внутри чанка не ломается, только в циклическом деке
[01:57:39.380 --> 01:57:41.380]  самом сверху сломается, но мы же не пользуемся
[01:57:41.380 --> 01:57:43.380]  номерами уже.
[01:57:45.380 --> 01:57:47.380]  В общем,
[01:57:47.380 --> 01:57:49.380]  не будем особенно подробно опускаться.
[01:57:49.380 --> 01:57:51.380]  Примерно поняли структуру, что у нас
[01:57:51.380 --> 01:57:53.380]  на самом деле
[01:57:53.380 --> 01:57:55.380]  таким вот чанком все хранится.
[01:57:57.380 --> 01:57:59.380]  Несмотря на то, что этот дек
[01:57:59.380 --> 01:58:01.380]  достаточно сложный,
[01:58:01.380 --> 01:58:03.380]  если вы посмотрите всякие перформанс-тенсы,
[01:58:03.380 --> 01:58:05.380]  то выяснится, что он на самом деле не так
[01:58:05.380 --> 01:58:07.380]  медленно работает. Возможно, это хорошая
[01:58:07.380 --> 01:58:09.380]  цена для того, чтобы у вас
[01:58:09.380 --> 01:58:11.380]  не было инвалидации итераторов.
[01:58:13.380 --> 01:58:15.380]  Ну, конечно, радость в кидек будет
[01:58:15.380 --> 01:58:17.380]  гораздо быстрее, более того, он будет настолько
[01:58:17.380 --> 01:58:19.380]  быстрый, что вы его сможете использовать вместо вектора.
[01:58:19.380 --> 01:58:21.380]  Ну, если вы при условии,
[01:58:21.380 --> 01:58:23.380]  что вы не делаете поп-фронт,
[01:58:23.380 --> 01:58:25.380]  он вообще будет работать как раз с кидек
[01:58:25.380 --> 01:58:27.380]  1 в 1.
[01:58:27.380 --> 01:58:29.380]  Ну, там с фронтом, только с бэком не становится.
[01:58:31.380 --> 01:58:33.380]  И тем не менее, еще в плюсах
[01:58:33.380 --> 01:58:35.380]  со счет такой обрывистой структуры вы не можете
[01:58:35.380 --> 01:58:37.380]  использовать всякие символи инструкции.
[01:58:37.380 --> 01:58:39.380]  То есть вы не можете работать
[01:58:39.380 --> 01:58:41.380]  с деком как с единой
[01:58:41.380 --> 01:58:43.380]  такой непрерывной
[01:58:43.380 --> 01:58:45.380]  фигней в памяти
[01:58:45.380 --> 01:58:47.380]  локации.
[01:58:47.380 --> 01:58:49.380]  Наверное, если бы мы умели настраивать
[01:58:49.380 --> 01:58:51.380]  длину чанка.
[01:58:51.380 --> 01:58:53.380]  Ну, это бы ничем нам не помогло,
[01:58:53.380 --> 01:58:55.380]  в принципе.
[01:58:55.380 --> 01:58:57.380]  Ну, если, конечно, сделать достаточно
[01:58:57.380 --> 01:58:59.380]  большой чанк,
[01:58:59.380 --> 01:59:01.380]  то, в принципе, внутри симдинструкции
[01:59:01.380 --> 01:59:03.380]  внутри этих чанков и там
[01:59:03.380 --> 01:59:05.380]  между ними, но это в любом случае требует
[01:59:05.380 --> 01:59:07.380]  кастомного дека.
[01:59:11.380 --> 01:59:13.380]  Да, ну, внутри чанков мы можем,
[01:59:13.380 --> 01:59:15.380]  но в рамках всего дека нам придется
[01:59:15.380 --> 01:59:17.380]  прыгать, он же по памяти где-то
[01:59:17.380 --> 01:59:19.380]  хрен знает как прыгнет.
[01:59:35.380 --> 01:59:37.380]  Как будто бы можно
[01:59:37.380 --> 01:59:39.380]  прыгнуть.
[01:59:39.380 --> 01:59:41.380]  Ну, в общем, она, наверное,
[01:59:41.380 --> 01:59:43.380]  не очень удобна,
[01:59:43.380 --> 01:59:45.380]  потому что, типа, у нас
[01:59:45.380 --> 01:59:47.380]  в границе вот этих патчей
[01:59:47.380 --> 01:59:49.380]  патчей для... Ну, все равно хуже, чем просто
[01:59:49.380 --> 01:59:51.380]  иметь на беспрерывной деке все.
[01:59:53.380 --> 01:59:55.380]  Так.
[01:59:55.380 --> 01:59:57.380]  Ну, там максимум два
[01:59:57.380 --> 01:59:59.380]  слайса будет.
[01:59:59.380 --> 02:00:01.380]  А если ты сделаешь Make Continuous, то это
[02:00:01.380 --> 02:00:03.380]  вообще, наверное, с одним слайсом.
[02:00:03.380 --> 02:00:05.380]  А, видимо, будет как-то переписывать.
[02:00:05.380 --> 02:00:07.380]  Переписывать это у ATTEN там
[02:00:07.380 --> 02:00:09.380]  и там будет чисто копирование.
[02:00:09.380 --> 02:00:11.380]  То есть это It's a Rotate.
[02:00:11.380 --> 02:00:13.380]  А? It's a Rotate.
[02:00:13.380 --> 02:00:15.380]  Да.
[02:00:15.380 --> 02:00:17.380]  It's a Rotate.
[02:00:17.380 --> 02:00:19.380]  У ATTEN, ну, там
[02:00:19.380 --> 02:00:21.380]  быстро и достаточно, в принципе.
[02:00:25.380 --> 02:00:27.380]  Ну, всегда можно на двух слайсах просто пуститься,
[02:00:27.380 --> 02:00:29.380]  но два это не миллион слайсов, так что
[02:00:29.380 --> 02:00:31.380]  все хорошо.
[02:00:31.380 --> 02:00:33.380]  А так?
[02:00:33.380 --> 02:00:35.380]  Знаете, у нас с деком еще не было
[02:00:35.380 --> 02:00:37.380]  каких-то особых проблем. В принципе, перетерпеть
[02:00:37.380 --> 02:00:39.380]  можно. Работает плюс-минус быстро
[02:00:39.380 --> 02:00:41.380]  симбод инструкции, но, может, не надо в конце концов
[02:00:41.380 --> 02:00:43.380]  использовать вектор, если он вам...
[02:00:43.380 --> 02:00:45.380]  они вам нужны. Но тут
[02:00:45.380 --> 02:00:47.380]  мы приходим к сету и мэпу.
[02:00:49.380 --> 02:00:51.380]  Раз у нас включается в себя
[02:00:51.380 --> 02:00:53.380]  bitremap и bitreset,
[02:00:53.380 --> 02:00:55.380]  это коллекция сортированная по ключу.
[02:00:55.380 --> 02:00:57.380]  Точно так же, как сет и мэп в плюсах.
[02:00:57.380 --> 02:00:59.380]  Вот.
[02:00:59.380 --> 02:01:01.380]  Во-первых,
[02:01:01.380 --> 02:01:03.380]  как можно назвать это название, там внутри
[02:01:03.380 --> 02:01:05.380]  B-дерево. B-дерево, если вы
[02:01:05.380 --> 02:01:07.380]  знакомы с этой структуры данных, ну,
[02:01:07.380 --> 02:01:09.380]  вы можете даже, наверное, не задумываться о том,
[02:01:09.380 --> 02:01:11.380]  как оно там конкретно работает. Вам важно только то,
[02:01:11.380 --> 02:01:13.380]  что оно кэш-локально. То есть там
[02:01:13.380 --> 02:01:15.380]  кусками элементы хранятся.
[02:01:15.380 --> 02:01:17.380]  Это достаточно быстро.
[02:01:17.380 --> 02:01:19.380]  Modern CPU сработает быстро.
[02:01:19.380 --> 02:01:21.380]  Современные процессоры
[02:01:21.380 --> 02:01:23.380]  за счет этих кусочков
[02:01:23.380 --> 02:01:25.380]  все кладут в кэш и быстренько делают поиски.
[02:01:25.380 --> 02:01:27.380]  Плюс ко всему, там еще
[02:01:27.380 --> 02:01:29.380]  проходов меньше по памяти,
[02:01:29.380 --> 02:01:31.380]  потому что там лог-бэя симптомтика,
[02:01:31.380 --> 02:01:33.380]  а не просто лог под логи.
[02:01:35.380 --> 02:01:37.380]  Вот. Ну и
[02:01:37.380 --> 02:01:39.380]  еще мне нравится
[02:01:39.380 --> 02:01:41.380]  название, но это просто мой
[02:01:41.380 --> 02:01:43.380]  хамбал ампийин. Он написал, что
[02:01:43.380 --> 02:01:45.380]  std-мэп и std-сет как-то не
[02:01:45.380 --> 02:01:47.380]  показывают, какая там структура данных внутри.
[02:01:47.380 --> 02:01:49.380]  То есть сразу не поймешь, что там
[02:01:49.380 --> 02:01:51.380]  красно-черное дерево обычно используется.
[02:01:51.380 --> 02:01:53.380]  Ну и тем более, что
[02:01:53.380 --> 02:01:55.380]  еще std-мэп и std-сет.
[02:01:55.380 --> 02:01:57.380]  Ладно, еще красно-черное дерево.
[02:01:57.380 --> 02:01:59.380]  Непонятно, что там вообще дерево.
[02:01:59.380 --> 02:02:01.380]  Там может быть хэштаблица, а может вообще
[02:02:01.380 --> 02:02:03.380]  и декартач сидеть, и ты не поймешь
[02:02:03.380 --> 02:02:05.380]  вообще по названию что там.
[02:02:09.380 --> 02:02:11.380]  А, да-да, хэштаблица я конечно соврал.
[02:02:11.380 --> 02:02:13.380]  Нужно убрать вообще.
[02:02:13.380 --> 02:02:15.380]  Да.
[02:02:15.380 --> 02:02:17.380]  Так.
[02:02:19.380 --> 02:02:21.380]  Да, и вот очень
[02:02:21.380 --> 02:02:23.380]  важный момент, я говорил
[02:02:23.380 --> 02:02:25.380]  то, что с бинарным поиском.
[02:02:25.380 --> 02:02:27.380]  Если вы любым способом
[02:02:27.380 --> 02:02:29.380]  поменяете внутри мапа
[02:02:29.380 --> 02:02:31.380]  или сета, то почему он сортируется?
[02:02:31.380 --> 02:02:33.380]  На самом деле, такие способы есть даже
[02:02:33.380 --> 02:02:35.380]  в SafeRust, то есть даже не нужно использовать
[02:02:35.380 --> 02:02:37.380]  unsafe, там есть такие читерские способы.
[02:02:39.380 --> 02:02:41.380]  Ну, на самом деле, это
[02:02:41.380 --> 02:02:43.380]  читерские способы, они используют
[02:02:43.380 --> 02:02:45.380]  InterimMetability,
[02:02:45.380 --> 02:02:47.380]  с счетом того, что InterimMetability
[02:02:47.380 --> 02:02:49.380]  это редкая штука, и
[02:02:49.380 --> 02:02:51.380]  в общем, там, где вы ее
[02:02:51.380 --> 02:02:53.380]  используете, она будет явно, и
[02:02:53.380 --> 02:02:55.380]  более того, вы сами себя малейшего
[02:02:55.380 --> 02:02:57.380]  сбратины, если вы так сделаете.
[02:02:57.380 --> 02:02:59.380]  Так что не беспокойтесь, вы просто так эту ошибку
[02:02:59.380 --> 02:03:01.380]  не сделаете, вы не будете модифицировать ключ,
[02:03:01.380 --> 02:03:03.380]  который лежит в мапе.
[02:03:03.380 --> 02:03:05.380]  Но если вы вдруг так сделаете, то
[02:03:05.380 --> 02:03:07.380]  мап вам говорит, что результат
[02:03:07.380 --> 02:03:09.380]  unspecified, это
[02:03:09.380 --> 02:03:11.380]  не будет никого на DefinedBehaviour,
[02:03:11.380 --> 02:03:13.380]  не будет MemoryOnSafety, ну, вы можете
[02:03:13.380 --> 02:03:15.380]  например, Abort, Panic и так далее.
[02:03:15.380 --> 02:03:17.380]  Словите какую-то
[02:03:17.380 --> 02:03:19.380]  произвольную ошибку, которая
[02:03:21.380 --> 02:03:23.380]  программу вам сломает,
[02:03:23.380 --> 02:03:25.380]  но тем не менее, она не
[02:03:25.380 --> 02:03:27.380]  принесет никаких там
[02:03:27.380 --> 02:03:29.380]  MemoryOnSafety, там, произвольным
[02:03:29.380 --> 02:03:31.380]  к CV-шкам
[02:03:31.380 --> 02:03:33.380]  каким-нибудь, то есть ошибкам безопасности
[02:03:33.380 --> 02:03:35.380]  и так далее.
[02:03:35.380 --> 02:03:37.380]  Ну, то есть это хорошая гарантия Rust,
[02:03:37.380 --> 02:03:39.380]  несмотря на то, что вы ломаете структуру, все равно
[02:03:39.380 --> 02:03:41.380]  что-то хорошее гарантирует.
[02:03:43.380 --> 02:03:45.380]  Так,
[02:03:45.380 --> 02:03:47.380]  C++
[02:03:47.380 --> 02:03:49.380]  у нас тоже есть
[02:03:49.380 --> 02:03:51.380]  MAP и SET, они имплементированы обычно как
[02:03:51.380 --> 02:03:53.380]  красно-черное дерево. Если по стандарту
[02:03:53.380 --> 02:03:55.380]  можно еще EVL-дерево использовать,
[02:03:55.380 --> 02:03:57.380]  но красно-черное дерево, конечно, в практике
[02:03:57.380 --> 02:03:59.380]  работает быстрее, поэтому они, наверное,
[02:03:59.380 --> 02:04:01.380]  поэтому и написаны.
[02:04:01.380 --> 02:04:03.380]  Ну, спрашивается, а почему, если B-дерево
[02:04:03.380 --> 02:04:05.380]  такое классное, вы не используете
[02:04:05.380 --> 02:04:07.380]  пресса? Это же, конечно, локальное, быстрое, классное,
[02:04:07.380 --> 02:04:09.380]  однозначно лучшее. Почему не используете?
[02:04:13.380 --> 02:04:15.380]  Нет, нет, там есть явная причина.
[02:04:23.380 --> 02:04:25.380]  На самом деле, мы ответ на этот вопрос уже проговорили
[02:04:25.380 --> 02:04:27.380]  в деке. Там тоже требуется
[02:04:27.380 --> 02:04:29.380]  не инвалидация итератора.
[02:04:29.380 --> 02:04:31.380]  Причина это то, что в стандарте
[02:04:31.380 --> 02:04:33.380]  есть ли мы меняем
[02:04:33.380 --> 02:04:35.380]  с SET и MAP?
[02:04:37.380 --> 02:04:39.380]  Мы не можем больше одного элемента
[02:04:39.380 --> 02:04:41.380]  эффективно хранить в одной музее.
[02:04:41.380 --> 02:04:43.380]  Да, иначе они перестают с местами.
[02:04:43.380 --> 02:04:45.380]  Без плохого.
[02:04:47.380 --> 02:04:49.380]  Так как бы деревья они
[02:04:51.380 --> 02:04:53.380]  как я уже говорил в чанках содержат
[02:04:53.380 --> 02:04:55.380]  элементы, поэтому незаметно быстрее,
[02:04:55.380 --> 02:04:57.380]  чем обычные BST-шки.
[02:04:57.380 --> 02:04:59.380]  Но тем не менее в плюсах мы не можем
[02:04:59.380 --> 02:05:01.380]  использовать эту всю фигню, потому что
[02:05:03.380 --> 02:05:05.380]  в общем-то стандарт нам это запрещает.
[02:05:05.380 --> 02:05:07.380]  И у нас в плюсах нет
[02:05:07.380 --> 02:05:09.380]  быстрого MAP и SET.
[02:05:19.380 --> 02:05:21.380]  Ну, почему это не добавили в стандарт?
[02:05:21.380 --> 02:05:23.380]  Ну, я не знаю. Наверное, никому не надо.
[02:05:23.380 --> 02:05:25.380]  Все написали все, что нужно, и все.
[02:05:25.380 --> 02:05:27.380]  Да.
[02:05:33.380 --> 02:05:35.380]  Да, ты не можешь иметь одновременно ссылочку
[02:05:35.380 --> 02:05:37.380]  на структуру и имитируйте одновременно.
[02:05:37.380 --> 02:05:39.380]  А в плюсах именно это
[02:05:39.380 --> 02:05:41.380]  мы разрешаем и даже поддерживаем.
[02:05:43.380 --> 02:05:45.380]  Причем, если
[02:05:45.380 --> 02:05:47.380]  знаете, в деке мы еще могли
[02:05:47.380 --> 02:05:49.380]  как-то с этим пожить.
[02:05:49.380 --> 02:05:51.380]  В MAP-е еще плюс-минус тоже могли пожить.
[02:05:51.380 --> 02:05:53.380]  Но сейчас
[02:05:53.380 --> 02:05:55.380]  мы дошли до hashMAP и hashSET.
[02:05:55.380 --> 02:05:57.380]  И сейчас мы будем плакать, потому что в плюсах
[02:05:57.380 --> 02:05:59.380]  здесь просто все ужасно.
[02:05:59.380 --> 02:06:01.380]  Так.
[02:06:01.380 --> 02:06:03.380]  Что у нас за язык без хештаблицы?
[02:06:03.380 --> 02:06:05.380]  У нас есть целых две. Это hashMAP и hashSET.
[02:06:05.380 --> 02:06:07.380]  Симпатики, естественно, предсказуемые,
[02:06:07.380 --> 02:06:09.380]  какие мы ожидаем.
[02:06:09.380 --> 02:06:11.380]  Эти хештаблицы достаточно
[02:06:11.380 --> 02:06:13.380]  быстрые, универсальные.
[02:06:13.380 --> 02:06:15.380]  И хештаблица, которая внутри
[02:06:15.380 --> 02:06:17.380]  используется, она
[02:06:17.380 --> 02:06:19.380]  буквально очень быстрая.
[02:06:19.380 --> 02:06:21.380]  Она использует квадратичное прорабирование
[02:06:21.380 --> 02:06:23.380]  и симпт внутри инструкции.
[02:06:23.380 --> 02:06:25.380]  Поэтому она очень быстрая.
[02:06:25.380 --> 02:06:27.380]  А если быть более конкретным, то внутри
[02:06:27.380 --> 02:06:29.380]  там используется растовый порт,
[02:06:29.380 --> 02:06:31.380]  называемый hashBrown,
[02:06:31.380 --> 02:06:33.380]  Google Swiss Table.
[02:06:33.380 --> 02:06:35.380]  Google Swiss Table это такая универсальная хештаблица,
[02:06:35.380 --> 02:06:37.380]  которая на данный момент считается самой быстрой в мире.
[02:06:37.380 --> 02:06:39.380]  Она написана на плюсах.
[02:06:39.380 --> 02:06:41.380]  Вот. Ну, если вам интересно,
[02:06:41.380 --> 02:06:43.380]  вы можете построить конференцию в Cpp.com
[02:06:43.380 --> 02:06:45.380]  и там рассказывать более конкретно, как работает
[02:06:45.380 --> 02:06:47.380]  алгоритм.
[02:06:47.380 --> 02:06:49.380]  Вот.
[02:06:51.380 --> 02:06:53.380]  B3set точно
[02:06:53.380 --> 02:06:55.380]  проходится, но hashMap, hashSet,
[02:06:55.380 --> 02:06:57.380]  ну, хештаблица проходится,
[02:06:57.380 --> 02:06:59.380]  но алгоритм гонотильный.
[02:07:01.380 --> 02:07:03.380]  Не, B дерево проходили.
[02:07:03.380 --> 02:07:05.380]  С ним кроме F2 его прям железно
[02:07:05.380 --> 02:07:07.380]  проходится. Это вопрос на хор вроде.
[02:07:17.380 --> 02:07:19.380]  Так.
[02:07:19.380 --> 02:07:21.380]  Давайте продолжим.
[02:07:21.380 --> 02:07:23.380]  У нас есть
[02:07:23.380 --> 02:07:25.380]  может быть потенциальная та же
[02:07:25.380 --> 02:07:27.380]  самая ошибка, что и в всяких
[02:07:27.380 --> 02:07:29.380]  структурах данных, которые
[02:07:29.380 --> 02:07:31.380]  за счет сортировки работают.
[02:07:31.380 --> 02:07:33.380]  Здесь мы если изменим ключ
[02:07:33.380 --> 02:07:35.380]  так, что из него изменится hash
[02:07:35.380 --> 02:07:37.380]  или изменится равенство,
[02:07:37.380 --> 02:07:39.380]  то в таком случае мы опять же сломаем хештаблицу.
[02:07:39.380 --> 02:07:41.380]  Ну, и все то же самое.
[02:07:41.380 --> 02:07:43.380]  Никакого B, никакой вариант
[02:07:43.380 --> 02:07:45.380]  safety, но результат он спешифает.
[02:07:45.380 --> 02:07:47.380]  Опять же
[02:07:47.380 --> 02:07:49.380]  хорошая гарантия
[02:07:49.380 --> 02:07:51.380]  даже тогда, когда вы все делаете плохо.
[02:07:51.380 --> 02:07:53.380]  Хештаблица.
[02:07:53.380 --> 02:07:55.380]  Итак, вспоминаете ли вы
[02:07:55.380 --> 02:07:57.380]  AnordertMap и AnordertSet?
[02:07:57.380 --> 02:07:59.380]  Они имплементированы
[02:07:59.380 --> 02:08:01.380]  очень страшно.
[02:08:01.380 --> 02:08:03.380]  По крайней мере, когда я открыл лекцию
[02:08:03.380 --> 02:08:05.380]  ли мещерина, то мне стало страшно,
[02:08:05.380 --> 02:08:07.380]  поэтому я решил
[02:08:07.380 --> 02:08:09.380]  про это не рассказывать.
[02:08:09.380 --> 02:08:11.380]  Давайте еще раз. Если у нас Google
[02:08:11.380 --> 02:08:13.380]  Sustain был такой крутой, то почему мы его не
[02:08:13.380 --> 02:08:15.380]  используем в плюсовом стандарте?
[02:08:15.380 --> 02:08:17.380]  А, инвалидация итератора.
[02:08:17.380 --> 02:08:19.380]  Давайте еще раз поддержим то, что никому не надо.
[02:08:19.380 --> 02:08:21.380]  Поддержим это.
[02:08:21.380 --> 02:08:23.380]  Да,
[02:08:23.380 --> 02:08:25.380]  сидим за счет этого
[02:08:25.380 --> 02:08:27.380]  с метом разрешения цепочек.
[02:08:27.380 --> 02:08:29.380]  Цепочками коллизии.
[02:08:29.380 --> 02:08:31.380]  Вот.
[02:08:31.380 --> 02:08:33.380]  Это в итоге приводит к тому,
[02:08:33.380 --> 02:08:35.380]  что мы не можем использовать хештаблицы,
[02:08:35.380 --> 02:08:37.380]  которые с YouTube и production.
[02:08:37.380 --> 02:08:39.380]  В плюсах.
[02:08:39.380 --> 02:08:41.380]  До этого структуру данных
[02:08:41.380 --> 02:08:43.380]  мы реально могли еще потерпеть.
[02:08:43.380 --> 02:08:45.380]  Но хештаблицы это никому не нужно, чтобы
[02:08:45.380 --> 02:08:47.380]  итераторы не инвалидировались.
[02:08:47.380 --> 02:08:49.380]  Поэтому в конечном итоге получается,
[02:08:49.380 --> 02:08:51.380]  что у нас бесполезная хештаблица в плюсах.
[02:08:51.380 --> 02:08:53.380]  Которую используют разве что
[02:08:53.380 --> 02:08:55.380]  тогда, когда лень писать свою.
[02:08:55.380 --> 02:08:57.380]  Когда не лень,
[02:08:57.380 --> 02:08:59.380]  тогда используют какую-то стороннюю,
[02:08:59.380 --> 02:09:01.380]  потому что она горит гораздо быстрее.
[02:09:01.380 --> 02:09:03.380]  Вот.
[02:09:03.380 --> 02:09:05.380]  Кстати говоря, я еще...
[02:09:05.380 --> 02:09:07.380]  Это тема больше для лекции по
[02:09:07.380 --> 02:09:09.380]  оптимизации кода на раз,
[02:09:09.380 --> 02:09:11.380]  когда вы сравните по производительности
[02:09:11.380 --> 02:09:13.380]  unorderedMap
[02:09:13.380 --> 02:09:15.380]  и hashMapRust,
[02:09:15.380 --> 02:09:17.380]  то вы неожиданно выясните, что они с
[02:09:17.380 --> 02:09:19.380]  одинаковой скоростью работают.
[02:09:19.380 --> 02:09:21.380]  Почему так?
[02:09:21.380 --> 02:09:23.380]  Да, вот прям одинаково
[02:09:23.380 --> 02:09:25.380]  с скоростью работают. А как же так?
[02:09:25.380 --> 02:09:27.380]  Вы спрашиваете. Такая быстрая хештаблица
[02:09:27.380 --> 02:09:29.380]  столько всего раз гарантировал.
[02:09:29.380 --> 02:09:31.380]  На самом деле раз просто
[02:09:31.380 --> 02:09:33.380]  использует очень-очень хороший хеш.
[02:09:33.380 --> 02:09:35.380]  Но этот хеш
[02:09:35.380 --> 02:09:37.380]  на самом деле очень хорошо
[02:09:37.380 --> 02:09:39.380]  распределяет элементы.
[02:09:39.380 --> 02:09:41.380]  За счет этого получается так, что
[02:09:41.380 --> 02:09:43.380]  сломать только хештаблицу в плане за счет
[02:09:43.380 --> 02:09:45.380]  хеша практически нереально.
[02:09:45.380 --> 02:09:47.380]  То есть она стабильно очень работает.
[02:09:47.380 --> 02:09:49.380]  А прессовую очень даже легко можно сломать,
[02:09:49.380 --> 02:09:51.380]  потому что там простой хеш.
[02:09:51.380 --> 02:09:53.380]  Если вы хотите, чтобы она работала действительно
[02:09:53.380 --> 02:09:55.380]  как Google SwissTable, то вам нужно будет
[02:09:55.380 --> 02:09:57.380]  поменять хеш на какой-нибудь попроще,
[02:09:57.380 --> 02:09:59.380]  вычислительно простой.
[02:09:59.380 --> 02:10:01.380]  Это мы поговорим, конечно, на лекции
[02:10:01.380 --> 02:10:03.380]  по оптимизации Rust кода.
[02:10:03.380 --> 02:10:05.380]  Тогда у вас получится прям такая
[02:10:05.380 --> 02:10:07.380]  оптимизирована под средний случай для
[02:10:07.380 --> 02:10:09.380]  обычного родового пользователя.
[02:10:13.380 --> 02:10:15.380]  Еще у нас есть binary heap.
[02:10:15.380 --> 02:10:17.380]  Так же, как и в плюсах, у нас это
[02:10:17.380 --> 02:10:19.380]  max heap.
[02:10:19.380 --> 02:10:21.380]  Работает точно так же, как в плюсах,
[02:10:21.380 --> 02:10:23.380]  только используется
[02:10:23.380 --> 02:10:25.380]  и vector тоже используется
[02:10:25.380 --> 02:10:27.380]  в template.
[02:10:27.380 --> 02:10:29.380]  А мой взгляд то же самое.
[02:10:29.380 --> 02:10:31.380]  Название гораздо лучше
[02:10:31.380 --> 02:10:33.380]  у Rust, потому что binary heap
[02:10:33.380 --> 02:10:35.380]  она точно говорит, какой алгоритм
[02:10:35.380 --> 02:10:37.380]  используется внутри. А здесь у нас не понятно,
[02:10:37.380 --> 02:10:39.380]  что. У нас может там binomial куча
[02:10:39.380 --> 02:10:41.380]  или Fibonacci куча в плюсах. Вообще не понятно.
[02:10:41.380 --> 02:10:43.380]  Конечно, priority queue
[02:10:43.380 --> 02:10:45.380]  очень много говорит на такое название.
[02:10:45.380 --> 02:10:47.380]  Но это такое просто.
[02:10:47.380 --> 02:10:49.380]  Я вам решил пожаловаться очередью.
[02:10:51.380 --> 02:10:53.380]  Потом.
[02:10:53.380 --> 02:10:55.380]  Абсолютно то же самое.
[02:10:55.380 --> 02:10:57.380]  Если вы меняете каким-то образом
[02:10:57.380 --> 02:10:59.380]  что-то binary heap,
[02:10:59.380 --> 02:11:01.380]  то у вас не происходит
[02:11:01.380 --> 02:11:03.380]  ничего особенно плохого.
[02:11:03.380 --> 02:11:05.380]  Не буду проговорять.
[02:11:05.380 --> 02:11:07.380]  Это очередной Rust, но это правда и для нее.
[02:11:09.380 --> 02:11:11.380]  За концов у нас есть еще
[02:11:11.380 --> 02:11:13.380]  linked list.
[02:11:13.380 --> 02:11:15.380]  Нужно было наверное тоже сделать, чтобы
[02:11:15.380 --> 02:11:17.380]  он открывался подряд.
[02:11:19.380 --> 02:11:21.380]  Симптотики такие же, как вы от них ожидаете.
[02:11:21.380 --> 02:11:23.380]  Push front, push back,
[02:11:23.380 --> 02:11:25.380]  pop front, pop back.
[02:11:25.380 --> 02:11:27.380]  Rust
[02:11:27.380 --> 02:11:29.380]  Во-первых, на Rust
[02:11:29.380 --> 02:11:31.380]  линкет-лист очень сложно.
[02:11:31.380 --> 02:11:33.380]  Мы увидели какой-то пример,
[02:11:33.380 --> 02:11:35.380]  конечно, но написать
[02:11:35.380 --> 02:11:37.380]  сейф Rust и линкет-лист сложно.
[02:11:37.380 --> 02:11:39.380]  Но на самом деле
[02:11:39.380 --> 02:11:41.380]  правда в том, что он почти никогда не линкет.
[02:11:43.380 --> 02:11:45.380]  Вот так вот сложилось, что пофигу
[02:11:45.380 --> 02:11:47.380]  на линкет-лист.
[02:11:47.380 --> 02:11:49.380]  Но он тем не менее стандартной библиотеки есть
[02:11:49.380 --> 02:11:51.380]  и на самом деле в случае Rust практически
[02:11:51.380 --> 02:11:53.380]  ничего особенного не умеет.
[02:11:53.380 --> 02:11:55.380]  Поэтому я рекомендую его обходить
[02:11:55.380 --> 02:11:57.380]  стороной, если только у вас не
[02:11:57.380 --> 02:11:59.380]  есть специальный алгоритм.
[02:12:01.380 --> 02:12:03.380]  И за счет второго пункта
[02:12:03.380 --> 02:12:05.380]  у нас в плюсах нет итераторов,
[02:12:05.380 --> 02:12:07.380]  поэтому список тем более
[02:12:07.380 --> 02:12:09.380]  становится бесполезным, потому что случайные элементы
[02:12:09.380 --> 02:12:11.380]  вы из него просто так не удалите.
[02:12:11.380 --> 02:12:13.380]  Нужно его прямо искать.
[02:12:17.380 --> 02:12:19.380]  Ну и советую вам прочитать такую-то
[02:12:19.380 --> 02:12:21.380]  тоже книжечку.
[02:12:21.380 --> 02:12:23.380]  Это такая онлайн-книжка,
[02:12:23.380 --> 02:12:25.380]  как же вы говорите, Rust Doc.
[02:12:25.380 --> 02:12:27.380]  Learn Rust, with and without
[02:12:27.380 --> 02:12:29.380]  to many linked lists.
[02:12:29.380 --> 02:12:31.380]  Там человек пишет несколько листов.
[02:12:31.380 --> 02:12:33.380]  Это простеньких стеков,
[02:12:33.380 --> 02:12:35.380]  unsaved,
[02:12:35.380 --> 02:12:37.380]  persistent,
[02:12:37.380 --> 02:12:39.380]  очень на самом деле полезная штука.
[02:12:39.380 --> 02:12:41.380]  Вы очень хорошо подружитесь с Barrow Checker
[02:12:41.380 --> 02:12:43.380]  после этого.
[02:12:43.380 --> 02:12:45.380]  Советую.
[02:12:45.380 --> 02:12:47.380]  Так, есть ли вопрос по контейнеру?
[02:12:47.380 --> 02:12:49.380]  Нет вопроса по контейнеру.
[02:12:49.380 --> 02:12:51.380]  Давайте перейдем к строке
[02:12:51.380 --> 02:12:53.380]  и ее слайсу.
[02:12:53.380 --> 02:12:55.380]  Я думаю, мы как раз, кстати,
[02:12:55.380 --> 02:12:57.380]  на лекцию успели прочитать.
[02:12:59.380 --> 02:13:01.380]  Это такой способ
[02:13:01.380 --> 02:13:03.380]  в Rust
[02:13:03.380 --> 02:13:05.380]  сохранить строку,
[02:13:05.380 --> 02:13:07.380]  но это тотально отличается
[02:13:07.380 --> 02:13:09.380]  от способа сохранить строку в плюсах.
[02:13:09.380 --> 02:13:11.380]  В плюсах у нас есть DString.
[02:13:11.380 --> 02:13:13.380]  Ключевая разница, конечно же,
[02:13:13.380 --> 02:13:15.380]  сразу же.
[02:13:15.380 --> 02:13:17.380]  Потому что ETA 8.
[02:13:17.380 --> 02:13:19.380]  В случае Rust
[02:13:19.380 --> 02:13:21.380]  строк у вас ETA 8.
[02:13:21.380 --> 02:13:23.380]  ETA 8, напоминаю,
[02:13:23.380 --> 02:13:25.380]  это формат,
[02:13:25.380 --> 02:13:27.380]  в котором у вас разная длина
[02:13:27.380 --> 02:13:29.380]  у символов.
[02:13:29.380 --> 02:13:31.380]  То есть таким образом вы не можете, например,
[02:13:31.380 --> 02:13:33.380]  random access на строчке сделать.
[02:13:33.380 --> 02:13:35.380]  Потому что если вы возьмете
[02:13:35.380 --> 02:13:37.380]  random access символ какой-то,
[02:13:37.380 --> 02:13:39.380]  то на самом деле вы можете взять
[02:13:39.380 --> 02:13:41.380]  только byte.
[02:13:41.380 --> 02:13:43.380]  А чтобы найти символ, вам нужно прочитать всю строчку,
[02:13:43.380 --> 02:13:45.380]  распарсить и выяснить,
[02:13:45.380 --> 02:13:47.380]  где же он находится,
[02:13:47.380 --> 02:13:49.380]  потому что у вас символы могут быть
[02:13:49.380 --> 02:13:51.380]  до 4 byte.
[02:13:51.380 --> 02:13:53.380]  На самом деле
[02:13:53.380 --> 02:13:55.380]  так все современные языки делают,
[02:13:55.380 --> 02:13:57.380]  потому что со строчками вы работаете с UTF 8.
[02:13:57.380 --> 02:13:59.380]  В плюсах то, что есть DString,
[02:13:59.380 --> 02:14:01.380]  это фигня,
[02:14:01.380 --> 02:14:03.380]  которая из себя представляет
[02:14:03.380 --> 02:14:05.380]  просто вектор чаров,
[02:14:05.380 --> 02:14:07.380]  без каких-либо инвариантов.
[02:14:07.380 --> 02:14:09.380]  То есть там хранится только
[02:14:09.380 --> 02:14:11.380]  ASCII текст.
[02:14:11.380 --> 02:14:13.380]  В общем,
[02:14:13.380 --> 02:14:15.380]  никакими хорошими
[02:14:15.380 --> 02:14:17.380]  свойствами
[02:14:17.380 --> 02:14:19.380]  плюсовая строка не обладает,
[02:14:19.380 --> 02:14:21.380]  в отличие от растовской.
[02:14:21.380 --> 02:14:23.380]  На самом деле, если вам нужно
[02:14:23.380 --> 02:14:25.380]  работать с ASCII,
[02:14:25.380 --> 02:14:27.380]  то во-первых, у вас есть OString,
[02:14:27.380 --> 02:14:29.380]  мы попозже посмотрим.
[02:14:29.380 --> 02:14:31.380]  Он убирает этот инвариант UTF 8.
[02:14:31.380 --> 02:14:33.380]  Во-вторых,
[02:14:33.380 --> 02:14:35.380]  у вас есть возможность
[02:14:35.380 --> 02:14:37.380]  просто работать с byte.
[02:14:37.380 --> 02:14:39.380]  То есть вы можете написать строки sbytes.
[02:14:39.380 --> 02:14:41.380]  Это вам, кстати,
[02:14:41.380 --> 02:14:43.380]  почти наверно пригодится в домашке,
[02:14:43.380 --> 02:14:45.380]  когда будете писать за дачку префикс.
[02:14:49.380 --> 02:14:51.380]  Эта строчка
[02:14:51.380 --> 02:14:53.380]  растет
[02:14:53.380 --> 02:14:55.380]  как вектор,
[02:14:55.380 --> 02:14:57.380]  и она точно так же, как вектор,
[02:14:57.380 --> 02:14:59.380]  созданная из каких-то bytes, длины и capacity.
[02:14:59.380 --> 02:15:01.380]  Соответственно, у нас
[02:15:01.380 --> 02:15:03.380]  из этого очень много функций,
[02:15:03.380 --> 02:15:05.380]  похожих на вектор.
[02:15:05.380 --> 02:15:07.380]  Так,
[02:15:07.380 --> 02:15:09.380]  но это я уже приговорил,
[02:15:09.380 --> 02:15:11.380]  так получилось.
[02:15:11.380 --> 02:15:13.380]  Вот.
[02:15:13.380 --> 02:15:15.380]  Вот смотрите на эту вот.
[02:15:15.380 --> 02:15:17.380]  Посмотрите на первую строчку.
[02:15:17.380 --> 02:15:19.380]  Это прям пример хорошего
[02:15:19.380 --> 02:15:21.380]  растовского дизайна.
[02:15:21.380 --> 02:15:23.380]  Это буквально скопировано
[02:15:23.380 --> 02:15:25.380]  в стандартной библиотеке.
[02:15:25.380 --> 02:15:27.380]  Я зашел в стандартную библиотеку Rasta
[02:15:27.380 --> 02:15:29.380]  и скопировал определение строки.
[02:15:29.380 --> 02:15:31.380]  Просто вектор U8,
[02:15:31.380 --> 02:15:33.380]  вектор byte.
[02:15:33.380 --> 02:15:35.380]  Как лучше писать
[02:15:35.380 --> 02:15:37.380]  new self
[02:15:37.380 --> 02:15:39.380]  или new style?
[02:15:39.380 --> 02:15:41.380]  Что еще раз?
[02:15:41.380 --> 02:15:43.380]  Вот style.
[02:15:43.380 --> 02:15:45.380]  А, писать лучше
[02:15:45.380 --> 02:15:47.380]  new self, конечно.
[02:15:47.380 --> 02:15:49.380]  Можно было
[02:15:49.380 --> 02:15:51.380]  на слайде и так написать,
[02:15:51.380 --> 02:15:53.380]  но у меня просто уже такой вариант.
[02:15:53.380 --> 02:15:55.380]  То есть, и то, и то валидно,
[02:15:55.380 --> 02:15:57.380]  но если есть возможность, лучше и self использовать.
[02:15:57.380 --> 02:15:59.380]  Он для того и сделан.
[02:15:59.380 --> 02:16:01.380]  Есть такие важные методы.
[02:16:01.380 --> 02:16:03.380]  Можно создать новую строчку.
[02:16:03.380 --> 02:16:05.380]  По умолчанию она не алоцирует.
[02:16:05.380 --> 02:16:07.380]  Кстати говоря, как и вся коллекция Rasta,
[02:16:07.380 --> 02:16:09.380]  как и вектор, век, дек и все что угодно,
[02:16:09.380 --> 02:16:11.380]  они все не алоцируют по умолчанию.
[02:16:11.380 --> 02:16:13.380]  Только тогда, когда вы начинаете добавлять туда элементы.
[02:16:15.380 --> 02:16:17.380]  Потом можно вив capacity.
[02:16:17.380 --> 02:16:19.380]  Ну, когда вы создаете вектор, то
[02:16:19.380 --> 02:16:21.380]  вы же можете...
[02:16:21.380 --> 02:16:23.380]  вы строчки можете capacity вообще задать, да.
[02:16:23.380 --> 02:16:25.380]  При создании вам точно также вернется строчка,
[02:16:25.380 --> 02:16:27.380]  которая уже алоцирована с каким-то
[02:16:27.380 --> 02:16:29.380]  размером байтов.
[02:16:29.380 --> 02:16:31.380]  Вот. Вы можете создать строчку
[02:16:31.380 --> 02:16:33.380]  из UTF-8.
[02:16:33.380 --> 02:16:35.380]  Вот.
[02:16:35.380 --> 02:16:37.380]  Вы принимаете на вход вектор byte.
[02:16:37.380 --> 02:16:39.380]  Заметьте, что вы его кушаете, скажем так.
[02:16:39.380 --> 02:16:41.380]  И вы возвращаете
[02:16:41.380 --> 02:16:43.380]  либо строчку,
[02:16:43.380 --> 02:16:45.380]  либо какую-нибудь from UTF-8 error.
[02:16:45.380 --> 02:16:47.380]  Это как раз то, что вместо
[02:16:47.380 --> 02:16:49.380]  UoError у вас может быть
[02:16:49.380 --> 02:16:51.380]  какой-нибудь UTF-8 error.
[02:16:51.380 --> 02:16:53.380]  Тоже вот, ну, такой.
[02:16:55.380 --> 02:16:57.380]  Дополнительный тип ошибки.
[02:16:57.380 --> 02:16:59.380]  Ну, просто может так получиться, что у вас
[02:16:59.380 --> 02:17:01.380]  вектор byte,
[02:17:01.380 --> 02:17:03.380]  он UTF-8, тогда у вас будет ошибка.
[02:17:05.380 --> 02:17:07.380]  Кто-нибудь знает, почему вектор здесь
[02:17:07.380 --> 02:17:09.380]  именно consume?
[02:17:09.380 --> 02:17:11.380]  То есть мы забираем над ним
[02:17:11.380 --> 02:17:13.380]  обыкновенные ошибки здесь.
[02:17:17.380 --> 02:17:19.380]  Ну, давай конкретнее.
[02:17:19.380 --> 02:17:21.380]  Замугал вот туда.
[02:17:23.380 --> 02:17:25.380]  Да, ну, чтобы замугал вот туда,
[02:17:25.380 --> 02:17:27.380]  ты скажи так чуть более конкретно.
[02:17:33.380 --> 02:17:35.380]  Да, буферу вектора забрать
[02:17:35.380 --> 02:17:37.380]  мы не хотим алоцировать.
[02:17:37.380 --> 02:17:39.380]  Мы не хотим аллокацию.
[02:17:39.380 --> 02:17:41.380]  Поэтому мы говорим, отдайте нам вектор
[02:17:41.380 --> 02:17:43.380]  уже готовый, пожалуйста.
[02:17:43.380 --> 02:17:45.380]  Тогда будет работать быстрее.
[02:17:45.380 --> 02:17:47.380]  Потом есть UTF-16
[02:17:47.380 --> 02:17:49.380]  скодировка. UTF-16 скодировка
[02:17:49.380 --> 02:17:51.380]  это не variable length,
[02:17:51.380 --> 02:17:53.380]  она состоит из 2 byte.
[02:17:53.380 --> 02:17:55.380]  Ну, и создает на ее основе UTF-8.
[02:17:55.380 --> 02:17:57.380]  Здесь мы, к сожалению,
[02:17:57.380 --> 02:17:59.380]  так как она не variable length,
[02:17:59.380 --> 02:18:01.380]  она там по-другому устроена,
[02:18:01.380 --> 02:18:03.380]  то, к сожалению, мы можем только слать принять.
[02:18:03.380 --> 02:18:05.380]  Мы не можем принять на вход
[02:18:05.380 --> 02:18:07.380]  веку U16 или U8, потому что нам
[02:18:07.380 --> 02:18:09.380]  придется перестраивать.
[02:18:09.380 --> 02:18:11.380]  В любом случае алоцировать что-то.
[02:18:11.380 --> 02:18:13.380]  Потом мы можем
[02:18:13.380 --> 02:18:15.380]  into byte сделать.
[02:18:15.380 --> 02:18:17.380]  То есть мы consume self,
[02:18:17.380 --> 02:18:19.380]  съедаем свою строчку
[02:18:19.380 --> 02:18:21.380]  и возвращаем вектор byte,
[02:18:21.380 --> 02:18:23.380]  который внутри находится.
[02:18:23.380 --> 02:18:25.380]  It's byte это то же самое, только возвращает
[02:18:25.380 --> 02:18:27.380]  ссылку на slice внутри byte.
[02:18:33.380 --> 02:18:35.380]  Потому что мы не хотим алоцировать.
[02:18:35.380 --> 02:18:37.380]  Ты как раз на этот вопрос пытался ответить.
[02:18:45.380 --> 02:18:49.380]  Вот, как вы думаете, что этот код запринтит?
[02:18:55.380 --> 02:18:57.380]  Так, варианты есть 6 и есть 12.
[02:18:57.380 --> 02:18:59.380]  Давайте, кто за 6?
[02:18:59.380 --> 02:19:01.380]  Поднимите руку, кто за 6?
[02:19:03.380 --> 02:19:05.380]  Так, а кто за 12?
[02:19:07.380 --> 02:19:09.380]  Так, за 12 чуть больше людей
[02:19:09.380 --> 02:19:11.380]  и 12 это правильный вариант ответа.
[02:19:11.380 --> 02:19:13.380]  Потому что length возвращает число bytes
[02:19:13.380 --> 02:19:15.380]  в строке, а не число символов.
[02:19:15.380 --> 02:19:17.380]  Чтобы узнать число символов, то нужно
[02:19:17.380 --> 02:19:19.380]  за o от n они проинтеррироваться.
[02:19:31.380 --> 02:19:33.380]  Не, на самом деле это более правильно
[02:19:33.380 --> 02:19:35.380]  так делать.
[02:19:35.380 --> 02:19:37.380]  Если ты хочешь узнать число в чарах,
[02:19:37.380 --> 02:19:39.380]  тогда тебе нужно вызвать chars, это
[02:19:39.380 --> 02:19:41.380]  итератор, и сделать count.
[02:19:41.380 --> 02:19:43.380]  Тогда это o от n будет.
[02:19:45.380 --> 02:19:47.380]  Да, это будет o от n.
[02:19:47.380 --> 02:19:49.380]  Тогда ты будешь явно понимать, у меня
[02:19:49.380 --> 02:19:51.380]  итератор по chars, у меня variable length строка,
[02:19:51.380 --> 02:19:53.380]  я должен проинтеррироваться.
[02:19:53.380 --> 02:19:55.380]  А здесь length непонятно, что оно будет,
[02:19:55.380 --> 02:19:57.380]  o от n, не o от n, но в Rust всегда
[02:19:57.380 --> 02:19:59.380]  отвечайте на вопрос так.
[02:19:59.380 --> 02:20:01.380]  Мы не хотим алоцировать, мы не хотим делать
[02:20:01.380 --> 02:20:03.380]  лишнюю работу, мы хотим, чтобы все было
[02:20:03.380 --> 02:20:05.380]  быстро.
[02:20:05.380 --> 02:20:07.380]  Почему они не могли поддерживать щутчатку?
[02:20:07.380 --> 02:20:09.380]  Есть подозревающий щутчик, нигде
[02:20:09.380 --> 02:20:11.380]  кроме ввода вывода особо не пригодится,
[02:20:11.380 --> 02:20:13.380]  а там тому можно, нам привезут и кратя
[02:20:13.380 --> 02:20:15.380]  все равно идти.
[02:20:19.380 --> 02:20:21.380]  Потом есть еще, про chars я
[02:20:21.380 --> 02:20:23.380]  как раз сказал.
[02:20:23.380 --> 02:20:25.380]  Мы можем взять строчку
[02:20:25.380 --> 02:20:27.380]  привет, проинтеррироваться по символам
[02:20:27.380 --> 02:20:29.380]  и вывести наш вектор.
[02:20:29.380 --> 02:20:31.380]  Это такая функция,
[02:20:31.380 --> 02:20:33.380]  которая возвращает итератор по chars.
[02:20:33.380 --> 02:20:35.380]  А что такое char?
[02:20:35.380 --> 02:20:37.380]  Ты его вообще понимает?
[02:20:43.380 --> 02:20:45.380]  О, точный ответ.
[02:20:45.380 --> 02:20:47.380]  Это UTF-8
[02:20:47.380 --> 02:20:49.380]  CodePoint.
[02:20:51.380 --> 02:20:53.380]  Хотя стой.
[02:20:53.380 --> 02:20:55.380]  Это не то же самое.
[02:20:55.380 --> 02:20:57.380]  Я попытал, там раз в следующий слайд
[02:20:57.380 --> 02:20:59.380]  CodePoint был.
[02:20:59.380 --> 02:21:01.380]  CodePoint другой.
[02:21:01.380 --> 02:21:03.380]  CodePoint это что-то типа символа,
[02:21:03.380 --> 02:21:05.380]  но я сейчас покажу пример.
[02:21:05.380 --> 02:21:07.380]  Читали ли вы задачу Prefix?
[02:21:07.380 --> 02:21:09.380]  Там как раз был пример такой,
[02:21:09.380 --> 02:21:11.380]  про кэфе, кофеина.
[02:21:15.380 --> 02:21:17.380]  Да, вот.
[02:21:17.380 --> 02:21:19.380]  Ну там задача как раз была
[02:21:19.380 --> 02:21:21.380]  объяснение, что довольно
[02:21:21.380 --> 02:21:23.380]  сложно сравнивать UTF-8
[02:21:23.380 --> 02:21:25.380]  строчки, и там даже одна и та же
[02:21:25.380 --> 02:21:27.380]  строка может за двумя разными способами
[02:21:27.380 --> 02:21:29.380]  написана.
[02:21:29.380 --> 02:21:31.380]  Вот как раз у нас есть такой примерчик.
[02:21:31.380 --> 02:21:33.380]  Давайте посмотрим.
[02:21:33.380 --> 02:21:35.380]  С виду два одинаковых символа.
[02:21:35.380 --> 02:21:37.380]  E с ударением, E до ударением.
[02:21:37.380 --> 02:21:39.380]  В одном случае это,
[02:21:39.380 --> 02:21:41.380]  как вы видите,
[02:21:41.380 --> 02:21:43.380]  какая-то UTF-8 строчка,
[02:21:43.380 --> 02:21:45.380]  chars next, она работает.
[02:21:45.380 --> 02:21:47.380]  А в втором случае
[02:21:47.380 --> 02:21:49.380]  это будет наум.
[02:21:49.380 --> 02:21:51.380]  То есть мы притеремся по char, мы получим один char.
[02:21:51.380 --> 02:21:53.380]  Логично, да?
[02:21:53.380 --> 02:21:55.380]  Заметьте, что просто E это строчка,
[02:21:55.380 --> 02:21:57.380]  я итерируюсь по ее символу.
[02:21:57.380 --> 02:21:59.380]  Это просто получаю наум
[02:21:59.380 --> 02:22:01.380]  во второй раз. То есть тут один символ.
[02:22:01.380 --> 02:22:03.380]  А когда я буду итерироваться
[02:22:03.380 --> 02:22:05.380]  по второй строчке,
[02:22:05.380 --> 02:22:07.380]  то в таком случае
[02:22:07.380 --> 02:22:09.380]  я выясню, что символов уже два.
[02:22:09.380 --> 02:22:11.380]  То есть потому что один символ
[02:22:11.380 --> 02:22:13.380]  в первом случае у нас был просто
[02:22:13.380 --> 02:22:15.380]  E with acute,
[02:22:15.380 --> 02:22:17.380]  то есть, короче, E с ударением.
[02:22:17.380 --> 02:22:19.380]  Это был один символ. В втором случае у нас это
[02:22:19.380 --> 02:22:21.380]  суррогатные символы. Это у нас там E
[02:22:21.380 --> 02:22:23.380]  и есть ударение.
[02:22:23.380 --> 02:22:25.380]  И UTF-8 это все приплесовывает в
[02:22:25.380 --> 02:22:27.380]  E с ударением.
[02:22:27.380 --> 02:22:29.380]  Вот так.
[02:22:33.380 --> 02:22:35.380]  Я не эксперт, у тебя 8 на самом деле.
[02:22:51.380 --> 02:22:53.380]  Вроде бы тут два кодпоинта как раз.
[02:22:53.380 --> 02:22:55.380]  Это один кодпоинт, но два
[02:22:55.380 --> 02:22:57.380]  в первом случае.
[02:22:59.380 --> 02:23:01.380]  Вроде бы так.
[02:23:01.380 --> 02:23:03.380]  Я честно скажу, я такой не эксперт,
[02:23:03.380 --> 02:23:05.380]  у тебя 8.
[02:23:11.380 --> 02:23:13.380]  Еще чар размера 4
[02:23:13.380 --> 02:23:15.380]  байта всегда.
[02:23:19.380 --> 02:23:21.380]  Но если бы он был 1 байта,
[02:23:21.380 --> 02:23:23.380]  то в лучшем случае он бы, конечно,
[02:23:23.380 --> 02:23:25.380]  был 1 байта.
[02:23:25.380 --> 02:23:27.380]  А так он может хранить какой-то
[02:23:27.380 --> 02:23:29.380]  UTF-8.
[02:23:33.380 --> 02:23:35.380]  В том стримке есть.
[02:23:35.380 --> 02:23:37.380]  Он очень похож на стримвью.
[02:23:37.380 --> 02:23:39.380]  Я бы даже сказал, что очень
[02:23:39.380 --> 02:23:41.380]  похож на. Практически одинаково.
[02:23:41.380 --> 02:23:43.380]  Просто что одно плюсовое, другое
[02:23:43.380 --> 02:23:45.380]  растовское, соответствующими различиями.
[02:23:47.380 --> 02:23:49.380]  Смотрите, до этого у нас был вот вектор
[02:23:49.380 --> 02:23:51.380]  и есть слайс вектора.
[02:23:51.380 --> 02:23:53.380]  Потом мы делаем какую-то строчку
[02:23:53.380 --> 02:23:55.380]  hello и у нее
[02:23:55.380 --> 02:23:57.380]  берем
[02:23:57.380 --> 02:23:59.380]  с первого по третьего символа и получаем
[02:23:59.380 --> 02:24:01.380]  L.
[02:24:03.380 --> 02:24:05.380]  Я вам сказал, с первого по третьего
[02:24:05.380 --> 02:24:07.380]  символа.
[02:24:11.380 --> 02:24:13.380]  Сейчас мы посмотрим. На самом деле
[02:24:13.380 --> 02:24:15.380]  это слайс байта.
[02:24:15.380 --> 02:24:17.380]  Я специально это сказал, потому что в данном случае
[02:24:17.380 --> 02:24:19.380]  это выглядит как слайс символа.
[02:24:19.380 --> 02:24:21.380]  Тут есть хитрость.
[02:24:21.380 --> 02:24:23.380]  Давайте возьмем UTF-8 слайс.
[02:24:23.380 --> 02:24:25.380]  Привет и мы берем
[02:24:25.380 --> 02:24:27.380]  1.3.
[02:24:27.380 --> 02:24:29.380]  Что вы думаете
[02:24:29.380 --> 02:24:31.380]  будет?
[02:24:39.380 --> 02:24:41.380]  Раз не может
[02:24:41.380 --> 02:24:43.380]  просто такое сделать.
[02:24:45.380 --> 02:24:47.380]  Говорит, трейдмейн паникт.
[02:24:47.380 --> 02:24:49.380]  Границу не входит, извини.
[02:24:49.380 --> 02:24:51.380]  Он в рентамент проверяет.
[02:24:51.380 --> 02:24:53.380]  Он просто смотрит на начало
[02:24:53.380 --> 02:24:55.380]  и проверяет, что вы действительно дали байтик, который
[02:24:55.380 --> 02:24:57.380]  соответствует началу символа.
[02:25:01.380 --> 02:25:03.380]  На самом деле это дает гарантию вам,
[02:25:03.380 --> 02:25:05.380]  что ваш слайс это тоже
[02:25:05.380 --> 02:25:07.380]  UTF-8.
[02:25:07.380 --> 02:25:09.380]  Это удобно, это хорошо.
[02:25:17.380 --> 02:25:19.380]  Если вы захотите взять по символам,
[02:25:19.380 --> 02:25:21.380]  в таком случае вам придется
[02:25:21.380 --> 02:25:23.380]  проэтерироваться честно
[02:25:23.380 --> 02:25:25.380]  и сделать слайс. Вам хочется
[02:25:25.380 --> 02:25:27.380]  за 1. Поэтому раздает вам возможность
[02:25:27.380 --> 02:25:29.380]  с байтов сделать.
[02:25:29.380 --> 02:25:31.380]  Если вы уже вычислили,
[02:25:31.380 --> 02:25:33.380]  то вы просто оставляете байты.
[02:25:33.380 --> 02:25:35.380]  Номера байтов. И все очень быстро
[02:25:35.380 --> 02:25:37.380]  за 1. А так нужно
[02:25:37.380 --> 02:25:39.380]  этерироваться, и это очень плохо.
[02:25:39.380 --> 02:25:41.380]  Я не представляю.
[02:25:41.380 --> 02:25:43.380]  Он это в рентамент проверяет?
[02:25:43.380 --> 02:25:45.380]  Да, но это 1. Он же смотрит
[02:25:45.380 --> 02:25:47.380]  за соседей байтов.
[02:26:07.380 --> 02:26:09.380]  Он не хранит, но он имеет такой вью.
[02:26:09.380 --> 02:26:11.380]  Он имеет ссылку на нашу текущую
[02:26:11.380 --> 02:26:13.380]  строку, два указателя.
[02:26:13.380 --> 02:26:15.380]  И мы дали по сути байтовых.
[02:26:15.380 --> 02:26:17.380]  И он рядышком проверяет,
[02:26:17.380 --> 02:26:19.380]  все ли хорошо во время своего создания.
[02:26:25.380 --> 02:26:27.380]  Он просто дает нам гарантию,
[02:26:27.380 --> 02:26:29.380]  что если строка UTF-8,
[02:26:29.380 --> 02:26:31.380]  то слайс тоже UTF-8.
[02:26:33.380 --> 02:26:35.380]  Соответственно, вот так это работает.
[02:26:35.380 --> 02:26:37.380]  Где-то я помню,
[02:26:37.380 --> 02:26:39.380]  в Fifth Community недавно был
[02:26:39.380 --> 02:26:41.380]  там был просто пост
[02:26:41.380 --> 02:26:43.380]  про то,
[02:26:43.380 --> 02:26:45.380]  что не все знают,
[02:26:45.380 --> 02:26:47.380]  мол, что в ГО, если вы проэтерируетесь
[02:26:47.380 --> 02:26:49.380]  по строчке, то будете этерироваться по байтам
[02:26:49.380 --> 02:26:51.380]  на самом деле. И там был комментарий
[02:26:51.380 --> 02:26:53.380]  от кого-то, мол, чего вы ожидали?
[02:26:53.380 --> 02:26:55.380]  Это же UTF-8-строчка.
[02:26:55.380 --> 02:26:57.380]  Здесь, кстати,
[02:26:57.380 --> 02:26:59.380]  если вы попробуете проэтерироваться по строчке,
[02:26:59.380 --> 02:27:01.380]  расскажете, что этерироваться по строчке нельзя.
[02:27:01.380 --> 02:27:03.380]  Вы напишите либо чарс уже,
[02:27:03.380 --> 02:27:05.380]  чтобы по символу этерироваться, либо байт,
[02:27:05.380 --> 02:27:07.380]  чтобы по байтам. Укажите явно,
[02:27:07.380 --> 02:27:09.380]  пожалуйста, что вы хотите.
[02:27:17.380 --> 02:27:19.380]  Так.
[02:27:19.380 --> 02:27:21.380]  У нас у стринга есть
[02:27:21.380 --> 02:27:23.380]  некоторые функции,
[02:27:23.380 --> 02:27:25.380]  которые есть и в строчке тоже.
[02:27:25.380 --> 02:27:27.380]  Например, sbyte,
[02:27:27.380 --> 02:27:29.380]  chars или trim.
[02:27:29.380 --> 02:27:31.380]  Например, с sbyte понятно,
[02:27:31.380 --> 02:27:33.380]  и с chars, в принципе.
[02:27:33.380 --> 02:27:35.380]  Stream — это функция, которая убирает
[02:27:35.380 --> 02:27:37.380]  пробелечки в начале и в конце просто.
[02:27:37.380 --> 02:27:39.380]  Наверное, пользуются.
[02:27:39.380 --> 02:27:41.380]  В питоне мне особенно часто пригождается,
[02:27:41.380 --> 02:27:43.380]  когда я что-то пишу.
[02:27:45.380 --> 02:27:47.380]  А может быть и даже trim.
[02:27:47.380 --> 02:27:49.380]  Помню, что там что-то депрекирует, а что-то работает.
[02:27:49.380 --> 02:27:51.380]  Я могу и соврать.
[02:27:59.380 --> 02:28:01.380]  Есть split.
[02:28:01.380 --> 02:28:03.380]  Кстати, вот здесь уже
[02:28:03.380 --> 02:28:05.380]  появляются какие-то страшные
[02:28:05.380 --> 02:28:07.380]  закорючки в виде кавычки a.
[02:28:07.380 --> 02:28:09.380]  Это называется lifetime.
[02:28:09.380 --> 02:28:11.380]  Вы его именем прям прописываете.
[02:28:11.380 --> 02:28:13.380]  Конкретно тут написано что?
[02:28:13.380 --> 02:28:15.380]  Здесь вы просто его в дженерике объявили,
[02:28:15.380 --> 02:28:17.380]  а дальше говорите,
[02:28:17.380 --> 02:28:19.380]  что вы берете ссылку с lifetime a на self,
[02:28:19.380 --> 02:28:21.380]  то есть вы берете строчку, которая есть
[02:28:21.380 --> 02:28:23.380]  какой-то lifetime a.
[02:28:23.380 --> 02:28:25.380]  И вы говорите, что split живет столько же,
[02:28:25.380 --> 02:28:27.380]  не больше, чем столько.
[02:28:27.380 --> 02:28:29.380]  Мы конкретно
[02:28:29.380 --> 02:28:31.380]  поговорим об этом, когда будем говорить
[02:28:31.380 --> 02:28:33.380]  о именованных lifetime, их чуть попозже.
[02:28:41.380 --> 02:28:43.380]  И в сплите просто там внутри
[02:28:43.380 --> 02:28:45.380]  в объявлении структуры ссылочка должна быть
[02:28:45.380 --> 02:28:47.380]  на строчку, естественно.
[02:28:49.380 --> 02:28:51.380]  Да, мы lifetime посмотрим.
[02:28:55.380 --> 02:28:57.380]  У нас вообще будет лекция
[02:28:57.380 --> 02:28:59.380]  целая по memory safety, даже будем одну статью разбирать.
[02:29:01.380 --> 02:29:03.380]  Ну и с replace тоже самое,
[02:29:03.380 --> 02:29:05.380]  в принципе.
[02:29:05.380 --> 02:29:07.380]  Берем какую-то строчку,
[02:29:07.380 --> 02:29:09.380]  здесь это replace, как вы понимаете,
[02:29:09.380 --> 02:29:11.380]  а да, replace и split.
[02:29:11.380 --> 02:29:13.380]  Здесь, видите, pattern есть какой-то
[02:29:13.380 --> 02:29:15.380]  и в том и в том случае.
[02:29:15.380 --> 02:29:17.380]  Здесь проблема как курица и яйца.
[02:29:17.380 --> 02:29:19.380]  Что вы ожидаете? То, что строка ищет
[02:29:19.380 --> 02:29:21.380]  себе pattern или то, что
[02:29:21.380 --> 02:29:23.380]  pattern себя ищет в строке.
[02:29:23.380 --> 02:29:25.380]  Или кто-то третий вообще ищет
[02:29:25.380 --> 02:29:27.380]  pattern в строке.
[02:29:27.380 --> 02:29:29.380]  Раз решает проблему так, что вы делаете
[02:29:29.380 --> 02:29:31.380]  pattern, внутри него есть search.
[02:29:31.380 --> 02:29:33.380]  Мы чуть попозже обсудим,
[02:29:33.380 --> 02:29:35.380]  как оно устроено.
[02:29:37.380 --> 02:29:39.380]  В общем-то, здесь pattern
[02:29:39.380 --> 02:29:41.380]  ищет себе строчки.
[02:29:41.380 --> 02:29:43.380]  В принципе, это так работает.
[02:29:49.380 --> 02:29:51.380]  Тут можно в качестве pattern просто указать
[02:29:51.380 --> 02:29:53.380]  строчку, потому что они имплементируют нужный
[02:29:53.380 --> 02:29:55.380]  trait pattern и оно там
[02:29:55.380 --> 02:29:57.380]  превратится в pattern.
[02:29:59.380 --> 02:30:01.380]  Да, можно написать что-то произвольное.
[02:30:01.380 --> 02:30:03.380]  Там просто что-то, что имплементирует
[02:30:03.380 --> 02:30:05.380]  pattern trait. Мы попозже поговорим.
[02:30:09.380 --> 02:30:11.380]  Везде, где можно искать pattern.
[02:30:11.380 --> 02:30:13.380]  Я думаю, что
[02:30:13.380 --> 02:30:15.380]  можно даже векторами написать.
[02:30:15.380 --> 02:30:17.380]  В общем, я и сам сейчас
[02:30:17.380 --> 02:30:19.380]  еще посмотрю, как это конкретно устроено.
[02:30:23.380 --> 02:30:25.380]  To,
[02:30:25.380 --> 02:30:27.380]  replace, куда?
[02:30:27.380 --> 02:30:29.380]  То есть это как бы буфер.
[02:30:31.380 --> 02:30:33.380]  Сейчас, подожди, replace.
[02:30:33.380 --> 02:30:35.380]  Я могу тебя собрать сейчас.
[02:30:35.380 --> 02:30:37.380]  Конечно, буфер.
[02:30:39.380 --> 02:30:41.380]  Ты ищешь
[02:30:41.380 --> 02:30:43.380]  pattern что-то заменяешь,
[02:30:43.380 --> 02:30:45.380]  а потом to на что-то заменяешь.
[02:30:45.380 --> 02:30:47.380]  А string — это, ну, потому что тебе
[02:30:47.380 --> 02:30:49.380]  возвращается именно string, потому что
[02:30:49.380 --> 02:30:51.380]  тебе потенциально нужна будет локация.
[02:30:51.380 --> 02:30:53.380]  Ты же можешь менять длина
[02:30:53.380 --> 02:30:55.380]  произвольного что-то.
[02:30:57.380 --> 02:30:59.380]  Это важный еще момент.
[02:30:59.380 --> 02:31:01.380]  Все строковые константы — это
[02:31:01.380 --> 02:31:03.380]  ссылочки на string.
[02:31:03.380 --> 02:31:05.380]  Если вы пишете hello world, то на самом деле
[02:31:05.380 --> 02:31:07.380]  он имеет тип ссылочки на string.
[02:31:07.380 --> 02:31:09.380]  И поэтому не очевидно, когда
[02:31:09.380 --> 02:31:11.380]  вы пишете hello world.to string.
[02:31:11.380 --> 02:31:13.380]  В смысле, строков к строке
[02:31:13.380 --> 02:31:15.380]  провести. Вообще непонятно, что происходит
[02:31:15.380 --> 02:31:17.380]  в начале.
[02:31:17.380 --> 02:31:19.380]  На самом деле, вы привозите
[02:31:19.380 --> 02:31:21.380]  к строке, то есть к владеющему
[02:31:21.380 --> 02:31:23.380]  типу
[02:31:23.380 --> 02:31:25.380]  в данном случае.
[02:31:25.380 --> 02:31:27.380]  То есть to string и to own it делают, по сути,
[02:31:27.380 --> 02:31:29.380]  одно и то же.
[02:31:29.380 --> 02:31:31.380]  Человеки разные?
[02:31:31.380 --> 02:31:33.380]  Когда они разные?
[02:31:33.380 --> 02:31:35.380]  В смысле, когда?
[02:31:35.380 --> 02:31:37.380]  В случае строчки — никогда.
[02:31:37.380 --> 02:31:39.380]  To own it — оно просто
[02:31:39.380 --> 02:31:41.380]  к какому-то владеющему типу
[02:31:41.380 --> 02:31:43.380]  привозит.
[02:31:43.380 --> 02:31:45.380]  Это не странно, то что to string приводит
[02:31:45.380 --> 02:31:47.380]  к string.
[02:31:47.380 --> 02:31:49.380]  В смысле, to string приводит не к str,
[02:31:49.380 --> 02:31:51.380]  а к string. То есть он берет
[02:31:51.380 --> 02:31:53.380]  ссылочку на str и привозит
[02:31:53.380 --> 02:31:55.380]  в стринг владеющий тип, то есть
[02:31:55.380 --> 02:31:57.380]  в локацию.
[02:31:57.380 --> 02:31:59.380]  Str — это просто что-то не у владеющего
[02:31:59.380 --> 02:32:01.380]  локации, просто ссылочка.
[02:32:01.380 --> 02:32:03.380]  Вот, наверное,
[02:32:03.380 --> 02:32:05.380]  осталось только 9 слайдов. Давайте мы их добьем.
[02:32:05.380 --> 02:32:07.380]  Тут box и rc.
[02:32:07.380 --> 02:32:09.380]  Это достаточно быстро.
[02:32:09.380 --> 02:32:11.380]  С box мы уже хорошо знакомы.
[02:32:13.380 --> 02:32:15.380]  Давайте мы проверим
[02:32:15.380 --> 02:32:17.380]  одну такую...
[02:32:17.380 --> 02:32:19.380]  Посмотрим на
[02:32:19.380 --> 02:32:21.380]  advanced функции. Во-первых, есть такая функция
[02:32:21.380 --> 02:32:23.380]  leak.
[02:32:23.380 --> 02:32:25.380]  Как вы думаете, что она делает?
[02:32:25.380 --> 02:32:27.380]  Течку памяти. Yes.
[02:32:27.380 --> 02:32:29.380]  Она просто
[02:32:29.380 --> 02:32:31.380]  берет и делает течку памяти.
[02:32:31.380 --> 02:32:33.380]  Такая наглая функция.
[02:32:33.380 --> 02:32:35.380]  Ну, еще есть inturall,
[02:32:35.380 --> 02:32:37.380]  который вообще берет
[02:32:37.380 --> 02:32:39.380]  в box и превращает его в указатель.
[02:32:39.380 --> 02:32:41.380]  То есть leak она превращает хотя бы
[02:32:41.380 --> 02:32:43.380]  в какую-то строчку,
[02:32:43.380 --> 02:32:45.380]  ссылочку на t.
[02:32:45.380 --> 02:32:47.380]  А inturall вообще
[02:32:47.380 --> 02:32:49.380]  меняет на указатель.
[02:32:49.380 --> 02:32:51.180]  Вы думаете, что leak может быть в
[02:32:51.180 --> 02:32:53.180]  advanced моде?
[02:32:53.180 --> 02:32:55.180]  Нет, это save функция.
[02:32:55.180 --> 02:32:57.180]  Вот смотри.
[02:32:57.180 --> 02:32:59.180]  Вот смотри, вот твой вопрос
[02:32:59.180 --> 02:33:01.180]  на слайде. Как же так?
[02:33:01.180 --> 02:33:03.180]  Раз безопасно. У нас тут memory leak и просто
[02:33:03.180 --> 02:33:05.180]  в save берем leak.
[02:33:05.180 --> 02:33:07.180]  Так.
[02:33:07.180 --> 02:33:09.180]  Зачем там?
[02:33:09.180 --> 02:33:11.180]  Стрих что?
[02:33:11.180 --> 02:33:13.180]  Смотри, ты просто
[02:33:13.180 --> 02:33:15.180]  должен явно указать, какой ты lifetime
[02:33:15.180 --> 02:33:17.180]  хочешь. Сколько должна
[02:33:17.180 --> 02:33:19.180]  жить эта ссылка?
[02:33:19.180 --> 02:33:21.180]  В любом случае, можешь не заняться, пока что мы
[02:33:21.180 --> 02:33:23.180]  ставим статик. Это означает, что он живет всю программу.
[02:33:23.180 --> 02:33:25.180]  Сколько хочешь.
[02:33:25.180 --> 02:33:27.180]  Все вообще.
[02:33:27.180 --> 02:33:29.180]  Вот.
[02:33:29.180 --> 02:33:31.180]  Подождите, у нас раз такое безопасное,
[02:33:31.180 --> 02:33:33.180]  мы взяли и memory leak сделали.
[02:33:33.180 --> 02:33:35.180]  В save раз.
[02:33:35.180 --> 02:33:37.180]  На самом деле,
[02:33:37.180 --> 02:33:39.180]  когда вы пишете на системе
[02:33:39.180 --> 02:33:41.180]  в языке программирования,
[02:33:41.180 --> 02:33:43.180]  то вы ожидаете того, что вы должны
[02:33:43.180 --> 02:33:45.180]  делать leak. Потому что, например, если
[02:33:45.180 --> 02:33:47.180]  вы взаимодействуете с другим языком
[02:33:47.180 --> 02:33:49.180]  программирования, то вы хотите
[02:33:49.180 --> 02:33:51.180]  салоцировать какую-то вещь.
[02:33:51.180 --> 02:33:53.180]  А потом, да, и отдать другой язык,
[02:33:53.180 --> 02:33:55.180]  чтобы он менеджил эту память, не вы.
[02:33:55.180 --> 02:33:57.180]  Вот.
[02:33:57.180 --> 02:33:59.180]  Поэтому, на самом деле, вы должны
[02:33:59.180 --> 02:34:01.180]  делать leak и должны уметь их делать в
[02:34:01.180 --> 02:34:03.180]  save языке. Более того, почему
[02:34:03.180 --> 02:34:05.180]  это Rast вообще разрешает? Потому что это считается
[02:34:05.180 --> 02:34:07.180]  безопасным в Rast.
[02:34:07.180 --> 02:34:09.180]  То есть memory leak, почему он безопасен?
[02:34:09.180 --> 02:34:11.180]  Потому что
[02:34:11.180 --> 02:34:13.180]  он не дает memory on save, он не дает
[02:34:13.180 --> 02:34:15.180]  уб, он просто плохой, согласен.
[02:34:15.180 --> 02:34:17.180]  Если у нас leak, то мы негодяи.
[02:34:17.180 --> 02:34:19.180]  Но при этом он
[02:34:19.180 --> 02:34:21.180]  безопасен, он не ломает нам программу,
[02:34:21.180 --> 02:34:23.180]  он не ломает никаких гарантий. Все хорошо.
[02:34:25.180 --> 02:34:27.180]  Вот.
[02:34:27.180 --> 02:34:29.180]  А мы изучим,
[02:34:29.180 --> 02:34:31.180]  как передавать память с другой программой?
[02:34:31.180 --> 02:34:33.180]  Да, у нас будет FFI
[02:34:33.180 --> 02:34:35.180]  в конце.
[02:34:37.180 --> 02:34:39.180]  Будем с плюсами и си работать.
[02:34:39.180 --> 02:34:41.180]  Ну, даже, наверное, си просто.
[02:34:41.180 --> 02:34:43.180]  С плюсами числа.
[02:34:43.180 --> 02:34:45.180]  Ну, да.
[02:34:47.180 --> 02:34:49.180]  Так.
[02:34:49.180 --> 02:34:51.180]  Потом у нас есть RC.
[02:34:51.180 --> 02:34:53.180]  До этого мы работали с боксом.
[02:34:53.180 --> 02:34:55.180]  Бокс просто был каким-то указателем.
[02:34:55.180 --> 02:34:57.180]  RC это тоже не нул указатель, но это
[02:34:57.180 --> 02:34:59.180]  reference counting указатель.
[02:34:59.180 --> 02:35:01.180]  Он однопоточенный.
[02:35:01.180 --> 02:35:03.180]  То есть у нас есть
[02:35:03.180 --> 02:35:05.180]  какой-то указатель,
[02:35:05.180 --> 02:35:07.180]  который, в общем-то, менеджит,
[02:35:07.180 --> 02:35:09.180]  сколько локаций было сделано.
[02:35:09.180 --> 02:35:11.180]  Ну, да,
[02:35:11.180 --> 02:35:13.180]  shared pointer, только shared pointer
[02:35:13.180 --> 02:35:15.180]  шарить может тогда не можно, да, Андрей?
[02:35:15.180 --> 02:35:17.180]  Нет.
[02:35:17.180 --> 02:35:19.180]  А?
[02:35:19.180 --> 02:35:21.180]  Шарить pointer там, ну, с трудами сложно,
[02:35:21.180 --> 02:35:23.180]  потому что там только атомарная операция
[02:35:23.180 --> 02:35:25.180]  на этом счетчике всего.
[02:35:25.180 --> 02:35:27.180]  Я там просто помню atomic shared pointer.
[02:35:27.180 --> 02:35:29.180]  Shared pointer, честно говоря, уже чуть попутано.
[02:35:29.180 --> 02:35:31.180]  Ну, с 20-х плюсов, да, для атомика появилась
[02:35:31.180 --> 02:35:33.180]  специализация по shared pointer,
[02:35:33.180 --> 02:35:35.180]  которая, чему более нормальная,
[02:35:35.180 --> 02:35:37.180]  чем была раньше.
[02:35:37.180 --> 02:35:39.180]  Вы можете брать RC.
[02:35:41.180 --> 02:35:43.180]  Когда вы создаете новый RC,
[02:35:43.180 --> 02:35:45.180]  то вы его можете склонировать.
[02:35:45.180 --> 02:35:47.180]  Если вы пишете RC clone,
[02:35:47.180 --> 02:35:49.180]  то вы копируете сам reference counting pointer.
[02:35:49.180 --> 02:35:51.180]  То есть у вас становится два указателя на память.
[02:35:51.180 --> 02:35:53.180]  Внутри это выглядит так.
[02:35:53.180 --> 02:35:55.180]  Когда вы создаете новую RC,
[02:35:55.180 --> 02:35:57.180]  то у вас алоцируется память
[02:35:57.180 --> 02:35:59.180]  под тип T, который вы алоцируете.
[02:35:59.180 --> 02:36:01.180]  И внутри там есть
[02:36:01.180 --> 02:36:03.180]  два счетчика.
[02:36:03.180 --> 02:36:05.180]  Один strong pointers, другой weak pointers.
[02:36:05.180 --> 02:36:07.180]  Что такое weak pointers, мы сейчас поговорим.
[02:36:07.180 --> 02:36:09.180]  Ну, про strong pointers, в принципе, понятно.
[02:36:09.180 --> 02:36:11.180]  Просто число RC, чтобы мы знали,
[02:36:11.180 --> 02:36:13.180]  в какой момент мы алоцируемся.
[02:36:15.180 --> 02:36:17.180]  Ну и дальше RC
[02:36:17.180 --> 02:36:19.180]  дропается, когда
[02:36:19.180 --> 02:36:21.180]  все инстанции RC дропнут.
[02:36:21.180 --> 02:36:23.180]  Ну, это при условии, что у вас нет weak pointers.
[02:36:25.180 --> 02:36:27.180]  Есть такие вот самые ключевые функции.
[02:36:27.180 --> 02:36:29.180]  Во-первых, getMute, она
[02:36:29.180 --> 02:36:31.180]  возвращает мутабельную ссылку
[02:36:31.180 --> 02:36:33.180]  опционально на T. Если мы узнаем
[02:36:33.180 --> 02:36:35.180]  то, что мы сейчас единственные, у кого есть
[02:36:35.180 --> 02:36:37.180]  ссылочка на тип T,
[02:36:37.180 --> 02:36:39.180]  то в таком случае мы можем
[02:36:39.180 --> 02:36:41.180]  взять не мутабельную ссылку.
[02:36:41.180 --> 02:36:43.180]  Логично, никакие гарантии не ломаем,
[02:36:43.180 --> 02:36:45.180]  раз это проверяет в runtime
[02:36:45.180 --> 02:36:47.180]  сколько у нас там ссылочек.
[02:36:49.180 --> 02:36:51.180]  Есть downgrade, который превращает нас в weak.
[02:36:51.180 --> 02:36:53.180]  Weak я сейчас покажу прямо
[02:36:53.180 --> 02:36:55.180]  хороший слайд.
[02:36:55.180 --> 02:36:57.180]  То у нас есть weak count
[02:36:57.180 --> 02:36:59.180]  и strong count. Это, собственно, то, что у нас
[02:36:59.180 --> 02:37:01.180]  внутри есть.
[02:37:01.180 --> 02:37:03.180]  Ну, наш count.
[02:37:07.180 --> 02:37:09.180]  Давайте посмотрим еще
[02:37:09.180 --> 02:37:11.180]  то, как пользуется RC.
[02:37:11.180 --> 02:37:13.180]  Вот, допустим, мы создали RC,
[02:37:13.180 --> 02:37:15.180]  выводим его на экран.
[02:37:15.180 --> 02:37:17.180]  Ну, и потом
[02:37:21.180 --> 02:37:23.180]  так как у нас RC 1, мы можем
[02:37:23.180 --> 02:37:25.180]  вызвать getMute.
[02:37:25.180 --> 02:37:27.180]  Соответственно, у нас он вернет сам,
[02:37:27.180 --> 02:37:29.180]  так как мы одни, и мы сможем
[02:37:29.180 --> 02:37:31.180]  модифицировать. Я отнял 41, например,
[02:37:31.180 --> 02:37:33.180]  и получил, соответственно, единичку.
[02:37:33.180 --> 02:37:35.180]  Первый раз я выведу до 42, второй раз я выведу
[02:37:35.180 --> 02:37:37.180]  единичку.
[02:37:37.180 --> 02:37:39.180]  Потом я сделаю RC clone.
[02:37:39.180 --> 02:37:41.180]  И еще раз выведу.
[02:37:41.180 --> 02:37:43.180]  Оно все еще будет работать.
[02:37:43.180 --> 02:37:45.180]  То есть у меня хоть и несколько
[02:37:45.180 --> 02:37:47.180]  ссылок, но я беру
[02:37:47.180 --> 02:37:49.180]  какую-то не мутабельную ссылку в очередной раз
[02:37:49.180 --> 02:37:51.180]  и что-то увожу.
[02:37:51.180 --> 02:37:53.180]  Но если я пробую взять еще
[02:37:53.180 --> 02:37:55.180]  одну мутабельную ссылку, то на этот раз
[02:37:55.180 --> 02:37:57.180]  он скажет, что
[02:37:57.180 --> 02:37:59.180]  он опционен в драг.
[02:37:59.180 --> 02:38:01.180]  Потому что у нас
[02:38:01.180 --> 02:38:03.180]  2 RC теперь.
[02:38:03.180 --> 02:38:05.180]  RC и RC 1.
[02:38:05.180 --> 02:38:07.180]  Соответственно, мы не можем иметь мутабельное владение,
[02:38:07.180 --> 02:38:09.180]  потому что иначе мы бы могли иметь две мутабельные ссылки
[02:38:09.180 --> 02:38:11.180]  и нарушили бы гарантии раз.
[02:38:11.180 --> 02:38:13.180]  То есть она же уже
[02:38:13.180 --> 02:38:15.180]  две мутабельные?
[02:38:15.180 --> 02:38:17.180]  Нет.
[02:38:17.180 --> 02:38:19.180]  GetMute дает мутабельную
[02:38:19.180 --> 02:38:21.180]  ссылку, он дает ее только тогда, когда RC
[02:38:21.180 --> 02:38:23.180]  только один.
[02:38:23.180 --> 02:38:25.180]  А вот то, что мы
[02:38:25.180 --> 02:38:27.180]  делали в GetMute?
[02:38:29.180 --> 02:38:31.180]  Ну, смотри, дело в том, что
[02:38:31.180 --> 02:38:33.180]  когда мы сделали GetMute, то у нас
[02:38:33.180 --> 02:38:35.180]  эта мутабельная ссылочка, она стерлась.
[02:38:35.180 --> 02:38:37.180]  У нас мутабельный flow, как мы говорили,
[02:38:37.180 --> 02:38:39.180]  пропал. Теперь мы можем снова
[02:38:39.180 --> 02:38:41.180]  сделать клаун.
[02:38:41.180 --> 02:38:43.180]  Мы делаем клаун, и дальше
[02:38:43.180 --> 02:38:45.180]  делаем изменения.
[02:38:45.180 --> 02:38:47.180]  Мы пытаемся еще раз вывести
[02:38:47.180 --> 02:38:49.180]  и на этот раз сломаемся, потому что
[02:38:49.180 --> 02:38:51.180]  у нас уже две RC, и мы не можем мутировать
[02:38:51.180 --> 02:38:53.180]  элемент внутри RC, когда мы
[02:38:53.180 --> 02:38:55.180]  имеем несколько ссылок на элементы.
[02:39:01.180 --> 02:39:03.180]  Я думаю, осталось
[02:39:03.180 --> 02:39:05.180]  пять действий.
[02:39:05.180 --> 02:39:07.180]  RC – это сильный
[02:39:07.180 --> 02:39:09.180]  указатель.
[02:39:09.180 --> 02:39:11.180]  В то время как WIC – это слабый указатель.
[02:39:11.180 --> 02:39:13.180]  Они оба имеют
[02:39:13.180 --> 02:39:15.180]  властвование,
[02:39:15.180 --> 02:39:17.180]  владение над локацией.
[02:39:19.180 --> 02:39:21.180]  Но только RC имеет
[02:39:21.180 --> 02:39:23.180]  право на значение внутри.
[02:39:23.180 --> 02:39:25.180]  Ну, как сказать, если
[02:39:25.180 --> 02:39:27.180]  у вас есть 10 RC
[02:39:27.180 --> 02:39:29.180]  и 10 WIC pointers,
[02:39:29.180 --> 02:39:31.180]  то в таком случае у вас
[02:39:31.180 --> 02:39:33.180]  аллокация будет продолжать
[02:39:33.180 --> 02:39:35.180]  жить. Если у вас
[02:39:35.180 --> 02:39:37.180]  умрут все 10 RC, останутся только
[02:39:37.180 --> 02:39:39.180]  10 WIC, то у вас
[02:39:39.180 --> 02:39:41.180]  диалоцируется значение
[02:39:41.180 --> 02:39:43.180]  внутри T, она дропнется,
[02:39:43.180 --> 02:39:45.180]  прям дроп вызовется.
[02:39:45.180 --> 02:39:47.180]  Но при этом аллокация будет жить
[02:39:47.180 --> 02:39:49.180]  сама. То есть, ну, я имею в виду аллокация,
[02:39:49.180 --> 02:39:51.180]  что на T и вот эти вот две ссылочки.
[02:39:55.180 --> 02:39:57.180]  А если вы уже диалоцируете и все WIC,
[02:39:57.180 --> 02:39:59.180]  тогда у вас диалоцируется вообще
[02:39:59.180 --> 02:40:01.180]  все. То есть, идеалокация
[02:40:01.180 --> 02:40:03.180]  произойдет самого этого
[02:40:03.180 --> 02:40:05.180]  на хипе двух кантров и
[02:40:05.180 --> 02:40:07.180]  вместо под тип T.
[02:40:15.180 --> 02:40:17.180]  Вик, тебе иногда хочется, чтобы у тебя продолжала
[02:40:17.180 --> 02:40:19.180]  жить аллокация, да, и проверить то, что
[02:40:19.180 --> 02:40:21.180]  у тебя там ничего нет.
[02:40:21.180 --> 02:40:23.180]  Потому что если у тебя RC
[02:40:23.180 --> 02:40:25.180]  все умрут и диалокация тоже произойдет,
[02:40:25.180 --> 02:40:27.180]  тогда попытка использовать WIC приведет
[02:40:27.180 --> 02:40:29.180]  к аллокации.
[02:40:29.180 --> 02:40:31.180]  Но WIC просто так значение
[02:40:31.180 --> 02:40:33.180]  не дает доступа.
[02:40:37.180 --> 02:40:39.180]  Вот. Есть еще upgrade
[02:40:39.180 --> 02:40:41.180]  функция. Она WIC превращает в RC.
[02:40:41.180 --> 02:40:43.180]  Ну, при условии, если у вас все
[02:40:43.180 --> 02:40:45.180]  RC умерли, то в таком случае
[02:40:45.180 --> 02:40:47.180]  у вас вернется NAO. Ну, потому что уже значение
[02:40:47.180 --> 02:40:49.180]  диалоцировано, извините. Вы не можете
[02:40:49.180 --> 02:40:51.180]  получить RC обратно.
[02:40:51.180 --> 02:40:53.180]  А если RC хотя бы одна живая,
[02:40:53.180 --> 02:40:55.180]  тогда у вас вернется
[02:40:55.180 --> 02:40:57.180]  самый RC какой-то.
[02:40:57.180 --> 02:40:59.180]  Вот.
[02:41:01.180 --> 02:41:03.180]  Ну, вот и здесь вот прекрасный такой слайд,
[02:41:03.180 --> 02:41:05.180]  в котором объясняется, как
[02:41:05.180 --> 02:41:07.180]  происходит это все дело.
[02:41:07.180 --> 02:41:09.180]  Ну, смотрите, я создаю какую-то RC,
[02:41:09.180 --> 02:41:11.180]  в которой хранится строка.
[02:41:11.180 --> 02:41:13.180]  Я клонирую
[02:41:13.180 --> 02:41:15.180]  эту RC.
[02:41:15.180 --> 02:41:17.180]  Потом я делаю WIC.
[02:41:17.180 --> 02:41:19.180]  Два WIC указателя.
[02:41:19.180 --> 02:41:21.180]  Я делаю downgrade RC1, еще раз downgrade RC1.
[02:41:21.180 --> 02:41:23.180]  Сам RC1, если что,
[02:41:23.180 --> 02:41:25.180]  это не модифицирует.
[02:41:25.180 --> 02:41:27.180]  То есть это просто создает новый WIC pointer.
[02:41:27.180 --> 02:41:29.180]  Ну, то есть вы можете там и RC1, RC1,
[02:41:29.180 --> 02:41:31.180]  и RC2, RC2 написать,
[02:41:31.180 --> 02:41:33.180]  и RC1, RC2, вообще неважно, что.
[02:41:33.180 --> 02:41:35.180]  Так.
[02:41:35.180 --> 02:41:37.180]  Потом мы дропаем RC1.
[02:41:37.180 --> 02:41:39.180]  Ну, строка не
[02:41:39.180 --> 02:41:41.180]  диалоцируется, потому что у нас все еще есть
[02:41:41.180 --> 02:41:43.180]  еще один RC.
[02:41:43.180 --> 02:41:45.180]  Вот мы можем даже попробовать WIC1 апгрейднуть
[02:41:45.180 --> 02:41:47.180]  и получим даже какое-то значение в том, что у нас
[02:41:47.180 --> 02:41:49.180]  живая локация.
[02:41:49.180 --> 02:41:51.180]  Что такое downgrade и downgrade?
[02:41:51.180 --> 02:41:53.180]  Downgrade
[02:41:53.180 --> 02:41:55.180]  возвращает из RC
[02:41:55.180 --> 02:41:57.180]  WIC, а
[02:41:57.180 --> 02:41:59.180]  Upgrade из WIC возвращает option RC.
[02:42:01.180 --> 02:42:03.180]  Ну, это то, что
[02:42:03.180 --> 02:42:05.180]  проверяет, если у нас
[02:42:05.180 --> 02:42:07.180]  локация.
[02:42:11.180 --> 02:42:13.180]  Вот.
[02:42:13.180 --> 02:42:15.180]  Дропаем WIC1, у нас ничего не происходит, естественно.
[02:42:15.180 --> 02:42:17.180]  Совсем. А вот если мы
[02:42:17.180 --> 02:42:19.180]  дропим RC2, то тогда уже диалоцируется
[02:42:19.180 --> 02:42:21.180]  строка в этот момент. То есть вместе
[02:42:21.180 --> 02:42:23.180]  с дропом RC2 происходит локация строки.
[02:42:23.180 --> 02:42:25.180]  Так.
[02:42:25.180 --> 02:42:27.180]  Ну и вот дальше
[02:42:27.180 --> 02:42:29.180]  давайте мы посчитаем число
[02:42:29.180 --> 02:42:31.180]  7 указателей, выясним, что оно 0.
[02:42:31.180 --> 02:42:33.180]  Логично. А дальше вот эта вот строчка,
[02:42:33.180 --> 02:42:35.180]  если мы посчитаем WIC count,
[02:42:35.180 --> 02:42:37.180]  вы, конечно, ожидаете значения 1.
[02:42:37.180 --> 02:42:39.180]  Я тоже ожидал, Тимур, значения 1.
[02:42:39.180 --> 02:42:41.180]  Так скажу.
[02:42:41.180 --> 02:42:43.180]  Я получил 0 и в самом начале не понял,
[02:42:43.180 --> 02:42:45.180]  почему. Решил обратиться к документации
[02:42:45.180 --> 02:42:47.180]  и вижу, что если никаких сильных
[02:42:47.180 --> 02:42:49.180]  указателей не осталось, то это вернет 0.
[02:42:49.180 --> 02:42:51.180]  Поэтому
[02:42:51.180 --> 02:42:53.180]  несмотря на то, что WIC count остался
[02:42:53.180 --> 02:42:55.180]  1, WIC count вернет 0.
[02:42:55.180 --> 02:42:57.180]  Потому что RC
[02:42:57.180 --> 02:42:59.180]  закончились. Извините.
[02:42:59.180 --> 02:43:01.180]  В чем смысл функции WIC count
[02:43:01.180 --> 02:43:03.180]  когда я исполняю?
[02:43:03.180 --> 02:43:05.180]  WIC count, ну, просто
[02:43:05.180 --> 02:43:07.180]  посчитать число слабых ссылок.
[02:43:07.180 --> 02:43:09.180]  Но оно работает,
[02:43:09.180 --> 02:43:11.180]  возвращает какое-то не нулевое значение
[02:43:11.180 --> 02:43:13.180]  в том случае, если у тебя есть WIC count
[02:43:13.180 --> 02:43:15.180]  и если у тебя RC живое есть.
[02:43:15.180 --> 02:43:17.180]  А иначе возвращает 0.
[02:43:17.180 --> 02:43:19.180]  Вы прям очень хорошо это, кстати, проработаете.
[02:43:19.180 --> 02:43:21.180]  Когда будет такая сдача,
[02:43:21.180 --> 02:43:23.180]  как ГЦ называется.
[02:43:23.180 --> 02:43:25.180]  Хорошая сдача.
[02:43:25.180 --> 02:43:27.180]  Да, ГЦ. Ну, там типа
[02:43:27.180 --> 02:43:29.180]  garbage collection такой.
[02:43:29.180 --> 02:43:31.180]  Ну, на самом деле не garbage collection,
[02:43:31.180 --> 02:43:33.180]  там просто забавная такая
[02:43:33.180 --> 02:43:35.180]  штука получается.
[02:43:37.180 --> 02:43:39.180]  Ну, дальше давайте
[02:43:39.180 --> 02:43:41.180]  пытаемся прообновить
[02:43:41.180 --> 02:43:43.180]  WIC2,
[02:43:43.180 --> 02:43:45.180]  получаем наун, потому что все RC
[02:43:45.180 --> 02:43:47.180]  умерли и дропаем WIC2.
[02:43:49.180 --> 02:43:51.180]  Еще я сделаю
[02:43:51.180 --> 02:43:53.180]  замечание, есть еще такой
[02:43:53.180 --> 02:43:55.180]  среди всех показателей, box,
[02:43:55.180 --> 02:43:57.180]  RC, есть еще ARC.
[02:43:57.180 --> 02:43:59.180]  ARC – это Atomic Recurrence
[02:43:59.180 --> 02:44:01.180]  Counting. Его можно
[02:44:01.180 --> 02:44:03.180]  шарить между тридами.
[02:44:03.180 --> 02:44:05.180]  Мы в этом подробно поговорим попозже.
[02:44:05.180 --> 02:44:07.180]  Просто упоминание для вас, чтобы
[02:44:07.180 --> 02:44:09.180]  вы знали, что это
[02:44:09.180 --> 02:44:11.180]  все одна вещь.
[02:44:11.180 --> 02:44:13.180]  Еще
[02:44:13.180 --> 02:44:15.180]  один момент, последний.
[02:44:15.180 --> 02:44:17.180]  Из RC-шек,
[02:44:17.180 --> 02:44:19.180]  если вы захотите, ну, можете сделать
[02:44:19.180 --> 02:44:21.180]  RC-option внутри
[02:44:21.180 --> 02:44:23.180]  и внутри какой-нибудь,
[02:44:23.180 --> 02:44:25.180]  не знаю, в общем, RC-option
[02:44:25.180 --> 02:44:27.180]  сделать и
[02:44:27.180 --> 02:44:29.180]  можете сделать цикл на локациях.
[02:44:29.180 --> 02:44:31.180]  То есть сделать так, чтобы
[02:44:31.180 --> 02:44:33.180]  один RC владел другим RC,
[02:44:33.180 --> 02:44:35.180]  тот другим, и этот владел
[02:44:35.180 --> 02:44:37.180]  первым.
[02:44:37.180 --> 02:44:39.180]  Так можно сделать.
[02:44:39.180 --> 02:44:41.180]  И дело в том, что в таком случае
[02:44:41.180 --> 02:44:43.180]  диалокации никогда не произойдет, они же друг другом
[02:44:43.180 --> 02:44:45.180]  владеют, верно?
[02:44:45.180 --> 02:44:47.180]  Поэтому, будьте осторожны,
[02:44:47.180 --> 02:44:49.180]  на RC-шках можно тоже получить
[02:44:49.180 --> 02:44:51.180]  memory WIC.
[02:44:51.180 --> 02:44:53.180]  Потому что, ну,
[02:44:53.180 --> 02:44:55.180]  можно просто...
[02:44:55.180 --> 02:44:57.180]  Нет, WIC не нужно использовать
[02:44:57.180 --> 02:44:59.180]  для этого вообще.
[02:44:59.180 --> 02:45:01.180]  Просто на RC-шках можно сделать цикл.
[02:45:01.180 --> 02:45:03.180]  Ну, то есть сделать так, чтобы оно никогда
[02:45:03.180 --> 02:45:05.180]  не делал отсылывалось, потому что там всегда
[02:45:05.180 --> 02:45:07.180]  не нулевые RC.
[02:45:07.180 --> 02:45:09.180]  Имеет в виду, чтобы
[02:45:09.180 --> 02:45:11.180]  решить проблему можно использовать WIC.
[02:45:11.180 --> 02:45:13.180]  Да, вот как раз
[02:45:13.180 --> 02:45:15.180]  у ГЦА вы увидите, что решить, чтобы
[02:45:15.180 --> 02:45:17.180]  решить проблему нужно использовать WIC, там как раз
[02:45:17.180 --> 02:45:19.180]  будут циклы на RC-шках всякие.
[02:45:19.180 --> 02:45:21.180]  Посмотрите.
[02:45:21.180 --> 02:45:23.180]  Но это будет тогда, когда мы хотя бы
[02:45:23.180 --> 02:45:25.180]  разберемся с макросом, потому что там задача еще есть
[02:45:25.180 --> 02:45:27.180]  макрос.
[02:45:27.180 --> 02:45:29.180]  Вот.
[02:45:29.180 --> 02:45:31.180]  Ну, получается, это все,
[02:45:31.180 --> 02:45:33.180]  что мы хотели сегодня изучить.
[02:45:33.180 --> 02:45:35.180]  Мы изучили Option и Result.
[02:45:35.180 --> 02:45:37.180]  Мы изучили всякие
[02:45:37.180 --> 02:45:39.180]  дефолтные коллекции Rasta
[02:45:39.180 --> 02:45:41.180]  и изучили Smart Pointer.
[02:45:41.180 --> 02:45:43.180]  Какие-нибудь вопросы есть?
