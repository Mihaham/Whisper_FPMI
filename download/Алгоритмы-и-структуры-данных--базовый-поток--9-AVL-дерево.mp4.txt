[00:00.000 --> 00:27.000]  Объясню, а вроде бы да, с одной стороны вы их прошли, но вы знаете слово контейнер? Нет, ну типа официально нет, давайте так, тот кто официально да, ой, тот кто да, вы молодцы, я очень за вас рад, но это не означает, что это да, и вы не знаете прям может быть всех тонкостей контейнеров, как только вы их пройдете, пожалуйста.
[00:27.000 --> 00:56.000]  Вам о них рассказали на плюсах? Вы написали свои стринги? Си-стринг и стринг-вью это разные вещи, как только вы доходите до того момента, когда вы это написали, то в принципе после этого вы можете это использовать.
[00:56.000 --> 01:10.000]  Пока нет, зачем оно вам? В смысле, у вас там нет таких задач, которых типа вы без стрингов не выживете.
[01:10.000 --> 01:21.000]  Библиотеку си-стринг можно, ну то есть там типа кмп-кмп, вот это вот восхитительный стыр-стыр, вот это вот все, можете использовать, пожалуйста, я не против.
[01:21.000 --> 01:35.000]  Ну то есть вот такие вещи, ок, но опять же типа если вы мне попытаетесь STD-сорт запихнуть в задачу сортировки, я скажу нет, и любой ассистент вам скажет нет.
[01:35.000 --> 01:47.000]  Что если попытаешься? Напиши ты лист. Еще раз, ты вот это все прошел, ты хоть раз это написал?
[01:48.000 --> 02:01.000]  Еще раз, то, что ты прошел, ты хоть раз написал? Ты вектор прошел? На лекцию? По-моему нет.
[02:01.000 --> 02:11.000]  Ну так, и если ты считаешь, что ты прошел вектор, хорошо, ты можешь подойти ко мне после, я вот тебе задам миллиард вопросов про вектор.
[02:12.000 --> 02:19.000]  Вот ответишь мне по каким схемам он работает, почему за столько, почему именно так, как это происходит, вот.
[02:19.000 --> 02:28.000]  Тогда я пойму, ты знаешь хотя бы векторы или нет. Если знаешь, впихнешь свой класс вектора типа в задачу, используй его.
[02:28.000 --> 02:34.000]  Ты же его прошел, значит ты написал. Еще есть вопрос.
[02:34.000 --> 02:50.000]  Смотрите, объясню, вы знаете как работает STD-своп? Как? Нет, никогда в жизни, ну то есть нет, да, но нет.
[02:50.000 --> 02:56.000]  Вы мув-семантику знаете? Нет, вы таких слов еще не слышали.
[02:56.000 --> 03:07.000]  Мув-семантика это то, что типа используется в STD-свопе, потому что тот своп, который мы с вами рассматривали, не является каноничным и не является правильным.
[03:07.000 --> 03:14.000]  В принципе, вы можете использовать STD-своп, предполагая, что он работает вот именно таким вот образом.
[03:15.000 --> 03:22.000]  Ну еще раз, хотя бы в одной задаче реализуйте его, ну типа блин, вы серьезно что ли, не можете эти четыре строчки написать?
[03:22.000 --> 03:31.000]  Ну друзья, ну пять ладно, извините. Объявление, три переменных и скобочка, да, в конце, пять.
[03:31.000 --> 03:40.000]  Шаблонный напишите, это вообще нормальная тема, тогда вас ко всему подойдет. Тогда шесть.
[03:41.000 --> 03:55.000]  То есть друзья, еще раз, я повторюсь, типа, когда вы считаете, что вы что-то знаете, не будьте уверены в этом, потому что даже я не всегда уверен в том, что я что-то знаю.
[03:55.000 --> 04:05.000]  Вот, типа не знаю, мне когда-то говорили, типа вот человек, который ничего не знает, он всегда уверен, что он прав, потому что вокруг него очень маленький орел того, что он не знает.
[04:05.000 --> 04:11.000]  Чем больше вы узнаете, тем больше вы понимаете, что вообще ничего не понятно. Это нормально.
[04:11.000 --> 04:20.000]  Но опять же, типа, мой вам посыл, реализуйте, типа, господи, ну реально, четыре строчки, ну вы серьезно, мы за них торговаться будем.
[04:20.000 --> 04:28.000]  Еще скажите, что вам обязательно нужна функция минимума, потому что вы тернартником пользоваться не умеете, строчку тоже написать.
[04:29.000 --> 04:31.000]  Ну реально.
[04:35.000 --> 04:43.000]  Хорошо. Ну еще раз, типа, ты можешь объяснить ассистенту, что ты не знаешь, как работает СТДСВОП.
[04:43.000 --> 04:52.000]  Но как СВОП написать, типа, обычно, ну, во всяком случае, когда я проверял задачи, я просил, типа, либо мне объяснить, либо хотя бы в одной поменять.
[04:52.000 --> 04:54.000]  И все.
[04:55.000 --> 04:58.000]  Просто показать, что ты понимаешь, как это выглядит.
[04:58.000 --> 05:15.000]  Хорошо. Давайте еще раз, типа, нет, важный момент, если мы говорим про СТДСВОП, то да, я понимаю, но если мы говорим про СТДСОРТ, то нет, это означает везде бан.
[05:15.000 --> 05:17.000]  Окей?
[05:18.000 --> 05:20.000]  Господи.
[05:20.000 --> 05:22.000]  Как же вам с ним сложно-то?
[05:22.000 --> 05:24.000]  Хорошо.
[05:24.000 --> 05:26.000]  Что-то есть с пожеланиями.
[05:26.000 --> 05:29.000]  Мне прям страшно, но ваши ряды все равно редиуют.
[05:29.000 --> 05:31.000]  Я вам скажу так.
[05:31.000 --> 05:33.000]  Можно.
[05:35.000 --> 05:37.000]  Скоро.
[05:39.000 --> 05:41.000]  Зачем?
[05:41.000 --> 05:43.000]  У вас был перерыв в самом начале?
[05:44.000 --> 05:50.000]  Ну, у вас был там колок, мы все понимаем, поэтому не трогали вас.
[05:50.000 --> 05:55.000]  Смотрите, нет, еще раз, с контестами дела обстоят следующим образом.
[05:55.000 --> 05:58.000]  Да, они у вас будут идти чуть ли не бесперерывно.
[05:58.000 --> 06:06.000]  Потому что самое лучшее, как вас попросить что-то делать, это всегда что-то попробовать.
[06:06.000 --> 06:09.000]  Вас по-другому не попросить.
[06:09.000 --> 06:14.000]  Потому что вы скажете, блин, у меня матан, блин, у меня физика, надо скатать или ее сделать.
[06:14.000 --> 06:19.000]  Вот это мне тоже нужно с этим что-то сделать, как-то жить.
[06:19.000 --> 06:23.000]  Потом у меня еще начинаются какие-нибудь новые вещи.
[06:23.000 --> 06:26.000]  И вы скажете, ну а зачем?
[06:26.000 --> 06:30.000]  Если я питон выучу, то зачем мне вообще плюсы?
[06:30.000 --> 06:34.000]  Скажете, вы мне, и я с вами не соглашусь.
[06:34.000 --> 06:38.000]  Но вы так подумайте, если у вас не будет какого-то конкретного дедлайна.
[06:38.000 --> 06:41.000]  Давайте уж честными будем друг с другом.
[06:41.000 --> 06:43.000]  Я представляю, как работает дедлайн.
[06:43.000 --> 06:47.000]  И когда вам говорят, что у вас три недели, вы такие, классно, две недели ничего не делаю,
[06:47.000 --> 06:51.000]  но последние ничего не досделаю.
[06:51.000 --> 06:57.000]  Я не встречал людей, которые начинают сразу же что-то делать.
[06:57.000 --> 07:00.000]  Если они существуют среди вас, я бедмерно за вас рад.
[07:00.000 --> 07:04.000]  Я таких не знаю в своем окружении.
[07:04.000 --> 07:07.000]  У меня не получалось так тоже у самого.
[07:07.000 --> 07:12.000]  Потому что у тебя до этого дедлайна будут какие-то другие дедлайны, которые тоже нужно закрыть обязательно.
[07:12.000 --> 07:16.000]  Вот они вот так вот идут друг за дружкой, вот ты пытаешься от одного к другому прийти.
[07:24.000 --> 07:28.000]  Еще раз, вам засчитывают задачу с каким-то баллом.
[07:28.000 --> 07:30.000]  С каким-то баллом всегда.
[07:30.000 --> 07:36.000]  Кроме того, что когда вы используете стд-сорт, вам ноль за него, сразу же поставите, друзья.
[07:36.000 --> 07:42.000]  Но если вам сказали, что вот этот косяк, вот этот косяк, вот этот косяк, вот этот косяк,
[07:42.000 --> 07:47.000]  ну типа sorry, у тебя получается 0,6 за задачу, то у тебя 0,6 коэффициент за эту задачу.
[07:47.000 --> 07:51.000]  И потом ты можешь еще переделать и как-то ее апгрейднуть.
[07:51.000 --> 07:57.000]  Ну вот еще раз, типа вам пишут, что у вас вот так косяки, ты можешь с этим что-то сделать.
[08:00.000 --> 08:04.000]  Еще раз, у вас когда проверили, вам обычно дается неделя.
[08:04.000 --> 08:09.000]  Поговорите в группе, господи, спросите, почему вот вы так это...
[08:09.000 --> 08:15.000]  Смотрите, вы говорите семинаристу ассистенту, типа пожалуйста, вот типа если у меня такое происходит,
[08:15.000 --> 08:18.000]  я могу передать? Чаще всего мы говорим да.
[08:18.000 --> 08:22.000]  Но злоупотреблять этим тоже, типа очень-очень глупо.
[08:22.000 --> 08:26.000]  Максимум один раз, пожалейте ассистентов тоже.
[08:26.000 --> 08:32.000]  Им читать код, а потом плакать, типа давайте это, чуть-чуть сбавим обороты.
[08:33.000 --> 08:36.000]  Еще есть вопрос?
[08:37.000 --> 08:39.000]  Нет.
[08:39.000 --> 08:41.000]  Давайте о ВЛ-дерево.
[08:41.000 --> 08:47.000]  Отлично, 15 минут поговорили обо всем, надеюсь теперь все стало понятнее.
[08:47.000 --> 08:51.000]  Сталось, чтобы вам понятно было, что такое ВЛ-дерево.
[08:51.000 --> 08:57.000]  Смотрите, на всякий случай напомню про бинарное дерево поиска.
[08:57.000 --> 08:59.000]  Бинарным деревом поиска что у нас называлось?
[08:59.000 --> 09:04.000]  Это некоторая структура данных, которая работает с упорядочными по сути множествами.
[09:04.000 --> 09:08.000]  Мы брали за множество числа некоторые, которые могли сравнивать.
[09:08.000 --> 09:11.000]  Можно сравнить все что угодно между собой.
[09:11.000 --> 09:15.000]  Хоть строчки, типа сравнивайте, не знаю, по какому-нибудь,
[09:15.000 --> 09:19.000]  стройте по ней хэш-функцию для тех, кто знает такие слова тоже.
[09:19.000 --> 09:23.000]  Ну или просто по количеству символов.
[09:23.000 --> 09:25.000]  Всегда можно делать по-разному.
[09:25.000 --> 09:31.000]  В бинарном дереве слева все меньше, справа все больше, правильно?
[09:31.000 --> 09:33.000]  Помните такое.
[09:33.000 --> 09:39.000]  Для облегчения жизни я считаю, что в бинарном дереве у нас нет никаких повторяющихся элементов.
[09:39.000 --> 09:43.000]  В чем проблема, на чем мы с вами остановились бинарным деревом поиска?
[09:46.000 --> 09:48.000]  Что не так?
[09:49.000 --> 09:52.000]  Работает с высоту и чего?
[09:56.000 --> 10:01.000]  Да, то есть смотрите, существуют некоторые проблемы,
[10:01.000 --> 10:06.000]  когда у нас будет высота дерева равна просто количеству элементов.
[10:06.000 --> 10:10.000]  Это не круто, это ничем не помогает, это очень похоже на лист.
[10:10.000 --> 10:14.000]  Работает все за ОАТН, что поиск, что еще что-то.
[10:16.000 --> 10:19.000]  Ты там контест делаешь, я не понимаю.
[10:21.000 --> 10:23.000]  Понимаете, так делать не надо.
[10:24.000 --> 10:30.000]  В этом начинаются как раз-таки проблемы с тем, что у нас вообще происходит.
[10:30.000 --> 10:36.000]  Потому что если у нас что-то работает за ОАТН, это нехорошо с точки зрения бинарного дерева поиска.
[10:36.000 --> 10:41.000]  Потому что, я думаю, вы еще с Бинпоиска помните, что отлично, когда что-то работает за логарифом.
[10:41.000 --> 10:43.000]  Чудесно, восхитительно.
[10:44.000 --> 10:47.000]  И хотелось бы попробовать это сделать.
[10:47.000 --> 10:57.000]  И мы хотим сделать так, построить как-то наше дерево таким образом, чтобы вставка элементов,
[10:57.000 --> 11:01.000]  удаление элементов, поиск элементов был за логарифом.
[11:01.000 --> 11:08.000]  Здесь есть такое слово, возможно, амортизационно, воспринимайте пока это слово как в среднем.
[11:10.000 --> 11:15.000]  Мы с вами рассмотрим, что такое амортизационно, попозже, на следующей лекции.
[11:15.000 --> 11:18.000]  У нас будет лекция про амортизационный анализ.
[11:19.000 --> 11:23.000]  Примерами вообще таких деревьев, на самом деле их множество.
[11:23.000 --> 11:26.000]  Здесь вот просто некоторые из них прописаны.
[11:26.000 --> 11:30.000]  Авель дерево, правда, всегда работает за логарифом.
[11:30.000 --> 11:33.000]  Даже не амортизационно, вот просто работает за логарифом.
[11:33.000 --> 11:36.000]  Красно-черное работает за логарифом.
[11:36.000 --> 11:44.000]  Вот декартовое дерево с рандомными какими-то ключами и сплей дерева будет работать амортизационно в среднем за логарифом.
[11:44.000 --> 11:48.000]  То есть не всегда, но в среднем оно будет вот примерно такое.
[11:48.000 --> 11:52.000]  Встают еще различные версии красно-черного дерева, а-а дерево оттуда.
[11:52.000 --> 11:55.000]  Встают а-би дерево и так далее.
[11:55.000 --> 11:57.000]  И по названию миллион.
[11:57.000 --> 12:01.000]  Мы рассмотрим какие-то основные и интересные для нас случаи.
[12:01.000 --> 12:04.000]  И первый случай для нас – авель дерева.
[12:04.000 --> 12:06.000]  Как вообще можно сбалансировать дерево?
[12:06.000 --> 12:08.000]  Давайте зададимся таким вопросом.
[12:15.000 --> 12:18.000]  Найти часть, которая является бамбуком и перерисовать.
[12:18.000 --> 12:20.000]  Вопрос.
[12:20.000 --> 12:25.000]  В момент построения дерева, что мы можем с ним такого сделать для того, чтобы этого не было?
[12:25.000 --> 12:27.000]  Чтобы бамбука в принципе не было?
[12:30.000 --> 12:33.000]  Мы вставляем по итеративно элементы.
[12:33.000 --> 12:35.000]  Мы не можем медиану взять.
[12:37.000 --> 12:39.000]  Еще есть идея?
[12:40.000 --> 12:42.000]  Ну давайте.
[12:42.000 --> 12:44.000]  Ну смотрите.
[12:44.000 --> 12:47.000]  А что для меня балансировка дерева?
[12:47.000 --> 12:50.000]  Части между собой равны, правда, по высоте?
[12:50.000 --> 12:54.000]  Если они равны по высоте, то я пытаюсь как-то с ними что-то сделать, правда?
[13:09.000 --> 13:13.000]  Ну вот мы будем пытаться сделать так, чтобы мы это балансировали.
[13:13.000 --> 13:17.000]  Вообще первым приближением авель дерева можно назвать следующее.
[13:17.000 --> 13:26.000]  Мы будем требовать то, чтобы высота левого и правого по дереву была одинакова.
[13:26.000 --> 13:31.000]  Но это проблемная вещь, потому что что делать, если вот четное число?
[13:31.000 --> 13:33.000]  И мы добавим еще один элементик.
[13:33.000 --> 13:36.000]  У нас начинается проблема, разница какая-то появляется, правда?
[13:36.000 --> 13:39.000]  Непонятно, куда лучше вставить в этом случае.
[13:39.000 --> 13:43.000]  И авель дерева немного работает по-другому.
[13:43.000 --> 13:46.000]  Оно названо здесь в двух советских ученых.
[13:46.000 --> 13:49.000]  Я обычно не останавливаюсь на том, кто придумал что.
[13:49.000 --> 13:52.000]  Но здесь важно знать, важно знать свои корни.
[13:52.000 --> 13:58.000]  А в общем-то авель дерева действительно было придумано еще в советские времена.
[13:58.000 --> 14:05.000]  И особенностью авель дерева и в принципе сбалансировано в смысле авель дерева
[14:05.000 --> 14:11.000]  является следующее правило, что для любого узла дерева
[14:11.000 --> 14:18.000]  высота его правого по дереву и левого по дереву отличается не более чем на единицу.
[14:22.000 --> 14:23.000]  Ну то есть по модулю.
[14:23.000 --> 14:27.000]  То есть может быть и правое чуть побольше, левое чуть побольше и так далее.
[14:27.000 --> 14:30.000]  Побольше именно в плане высоты, не количестве элементов.
[14:30.000 --> 14:32.000]  Я думаю вы это прекрасно понимаете.
[14:32.000 --> 14:35.000]  И вот это выполняться должно для каждого узла.
[14:35.000 --> 14:38.000]  Вот это характеристика авель дерева.
[14:38.000 --> 14:42.000]  Вот это является сбалансированностью в смысле авель дерева.
[14:42.000 --> 14:47.000]  Важный момент, сбалансированность бывает в разных смыслах.
[14:49.000 --> 14:54.000]  Мы остановимся с вами еще на пары деревьев и вы поймете, что там другое вообще происходит.
[14:55.000 --> 14:56.000]  Вот.
[14:57.000 --> 15:02.000]  Поэтому да, с точки зрения авель дерева оно вот именно такая вот балансировка.
[15:03.000 --> 15:04.000]  Пока понятно?
[15:06.000 --> 15:07.000]  Что?
[15:09.000 --> 15:12.000]  Хорошо. Пусть будет так.
[15:13.000 --> 15:14.000]  Да.
[15:14.000 --> 15:18.000]  Для каждого узла сумма разницы левого и правого по дереву высот.
[15:19.000 --> 15:21.000]  Именно не более чем единица.
[15:23.000 --> 15:24.000]  Для каждого узла.
[15:25.000 --> 15:28.000]  Для каждого узла левое и правое по дереву.
[15:28.000 --> 15:31.000]  Пока никаких детей и родителей.
[15:32.000 --> 15:33.000]  Чуть попозже, скоро они появятся.
[15:34.000 --> 15:37.000]  Смотрите, как из бинарным деревом поиска.
[15:37.000 --> 15:39.000]  Мы начнем от обратного.
[15:40.000 --> 15:45.000]  Мы не будем сначала смотреть, как нам вообще что сделать с деревом и так далее.
[15:45.000 --> 15:50.000]  Мы ведем некоторые понятия, которые нам будут необходимы для балансировки.
[15:51.000 --> 15:56.000]  А для того, чтобы каждый раз мы могли сказать, что дерево действительно сбалансировано.
[15:56.000 --> 15:58.000]  Действительно его высота такая-то.
[15:58.000 --> 16:00.000]  И как-то с ней балансировать.
[16:00.000 --> 16:02.000]  На всякий случай я скажу.
[16:03.000 --> 16:07.000]  Давайте отвлекитесь сейчас от своих нотов почти все.
[16:08.000 --> 16:13.000]  Потому что я специально пишу код на плюсах для того, чтобы вам было проще потом в жизни.
[16:14.000 --> 16:16.000]  В отличие от бинарного дерева поиска.
[16:17.000 --> 16:19.000]  А оно достаточно простое.
[16:20.000 --> 16:21.000]  Это раз.
[16:22.000 --> 16:23.000]  Это раз.
[16:24.000 --> 16:25.000]  Это раз.
[16:26.000 --> 16:27.000]  Это раз.
[16:27.000 --> 16:29.000]  А оно достаточно простое.
[16:29.000 --> 16:30.000]  Это раз.
[16:30.000 --> 16:32.000]  Во-вторых, контесты вы порешайте успеть.
[16:32.000 --> 16:35.000]  И поговорить с кем-нибудь в телеге или в ВК тоже.
[16:38.000 --> 16:39.000]  Так вот.
[16:39.000 --> 16:42.000]  Для начала мы остановимся все так же на структуре узла.
[16:44.000 --> 16:46.000]  Узла, что будет вообще храниться здесь.
[16:46.000 --> 16:49.000]  Здесь мне в принципе не будут нужны перронты.
[16:50.000 --> 16:51.000]  То есть я откажусь от них.
[16:51.000 --> 16:53.000]  Мне они особо-то не нужны.
[16:53.000 --> 16:55.000]  Я буду как-нибудь это по-другому вычислять.
[16:55.000 --> 16:57.000]  Вот мы специально на этом сегодня остановимся.
[16:57.000 --> 17:00.000]  Кроме того, большинство функций сегодня будут написаны рекурсивно.
[17:01.000 --> 17:03.000]  Мы с вами писали их итеративно на прошлой лекции.
[17:04.000 --> 17:05.000]  Сейчас посмотрим рекурсию.
[17:06.000 --> 17:08.000]  В принципе, сильной разницы не будет.
[17:09.000 --> 17:11.000]  А будет все плюс-минус понятное, думаю, для вас.
[17:12.000 --> 17:14.000]  Так вот, что хранится в этой ноде?
[17:14.000 --> 17:16.000]  В этой ноде хранится сам ключ.
[17:17.000 --> 17:20.000]  Высота самого поддерева с корнем в этом узле.
[17:22.000 --> 17:23.000]  Я буду ее поддерживать.
[17:24.000 --> 17:26.000]  Корректный. Всегда.
[17:27.000 --> 17:31.000]  Ссылка на левого ребенка, ссылка на правого ребенка и конструктор.
[17:32.000 --> 17:35.000]  Я думаю, с конструктором вы теперь знакомы, правда?
[17:36.000 --> 17:38.000]  Правда, здесь написано не через двоеточие.
[17:38.000 --> 17:41.000]  Как должно быть и красиво должно быть сделано, а просто внутри.
[17:42.000 --> 17:44.000]  Потому что я не знал, до какого именно части вы дойдете конструкторов.
[17:45.000 --> 17:47.000]  Может, вы сегодня их просто чуть-чуть бы затронули.
[17:47.000 --> 17:48.000]  Поэтому я написал так.
[17:50.000 --> 17:52.000]  Вот у нас есть такая структура ноды.
[17:52.000 --> 17:54.000]  Есть ли к ней вопросы пока?
[17:56.000 --> 17:58.000]  Нету. Понятно, что в ней хранится.
[18:00.000 --> 18:01.000]  Вот до этого сейчас дойдем.
[18:02.000 --> 18:05.000]  Но, на самом деле, с точки зрения высоты.
[18:06.000 --> 18:07.000]  Что такое высота?
[18:07.000 --> 18:10.000]  Если мы рассмотрим это в некоторой такой рекурсии.
[18:10.000 --> 18:12.000]  Вот на данном этапе высота узла.
[18:12.000 --> 18:15.000]  Чему она равна, если я знаю высоту левого и высоту правого поддерева?
[18:15.000 --> 18:18.000]  Высота левого или высота правого плюс один.
[18:18.000 --> 18:20.000]  В зависимости от того, что из них больше.
[18:20.000 --> 18:23.000]  Вот именно так мы и будем фиксировать, на самом деле, эту высоту.
[18:23.000 --> 18:25.000]  Для начала я напишу функцию.
[18:26.000 --> 18:27.000]  Можно.
[18:29.000 --> 18:30.000]  А?
[18:32.000 --> 18:33.000]  Выложу, выложу.
[18:33.000 --> 18:34.000]  Презентацию выложу.
[18:34.000 --> 18:35.000]  Даже записывают.
[18:35.000 --> 18:36.000]  Все, смотрите.
[18:36.000 --> 18:37.000]  Чудесно.
[18:37.000 --> 18:39.000]  А в этот раз у вас все будет.
[18:39.000 --> 18:40.000]  Так вот.
[18:41.000 --> 18:43.000]  Простейшая функция высоты.
[18:44.000 --> 18:46.000]  Для чего я делаю функцию высоты?
[18:48.000 --> 18:50.000]  Ну потому что я просто буду проверять,
[18:50.000 --> 18:51.000]  вообще эта нода существует или нет.
[18:51.000 --> 18:53.000]  Она не на lptr или на lptr.
[18:53.000 --> 18:57.000]  Мне это нужно будет с точки зрения дальнейшей такой архитектуры кода.
[18:57.000 --> 18:59.000]  Это достаточно просто.
[18:59.000 --> 19:00.000]  Я не буду в этом делать.
[19:00.000 --> 19:01.000]  Я не буду в этом делать.
[19:03.000 --> 19:04.000]  Но я буду в этом делать.
[19:05.000 --> 19:06.000]  Я буду в этом делать.
[19:06.000 --> 19:11.440]  длиннейшей такой архитектуры кода, это достаточно просто и понятно. Вы могли
[19:11.440 --> 19:16.280]  возвращать здесь просто высоту, но у NALPTR вершинки не существует такого
[19:16.280 --> 19:20.240]  понятия, как высота, потому что вы не можете ее разыменовать NALPTR.
[19:20.240 --> 19:27.840]  Окей? Поэтому я делаю это именно в таком вот виде и смотрю на это все. Все же
[19:27.840 --> 19:34.280]  понимают, что если P не NALPTR, тогда вернется высота иначе ноль. Вот то есть
[19:34.280 --> 19:39.960]  вот эта P, это будет означать, что она либо NALPTR, либо не NALPTR. Просто так
[19:39.960 --> 19:49.400]  легче написать кратко. Окей? Давайте, чуть-чуть синтаксиса языка. А?
[19:50.880 --> 19:59.000]  Можно. Смотрите, вот когда вы, грубо говоря, с ИФами работали, давайте туда
[19:59.000 --> 20:06.080]  кунемся. И вот если я пишу ИФХ, в каком случае будет выполняться ветка true, в
[20:06.080 --> 20:16.120]  каком else? Когда не ноль, аналогично будет с указателями. Когда указатель не
[20:16.120 --> 20:23.120]  нулевой, у вас будет ветка true. Аналогично для тернарного оператора. Если у вас
[20:23.120 --> 20:32.960]  P не нулевой, тогда он вернет высоту узла. А? P это некоторый корень вот узла. Вот то
[20:32.960 --> 20:37.040]  есть мы просто смотрим на узел и пытаемся понять, какая высота узла, если
[20:37.040 --> 20:42.920]  корнем является P, для некоторого поддеревываю его.
[20:42.920 --> 20:53.760]  Смотрите, я с вами работаю с конкретными нодами. Давайте сейчас как-нибудь, вот так
[20:53.760 --> 21:01.720]  пойдет. Я могу в качестве P подать любой из этих элементов. P просто указатель на
[21:01.720 --> 21:06.760]  некоторую ноду, на некоторый узел. И я возвращаю его в высоту.
[21:07.600 --> 21:16.040]  Ну нет, еще раз. У меня в каждом узле хранится высота уже. У меня есть это поле.
[21:16.040 --> 21:22.160]  Время работы, я думаю, вы не сомневаетесь, что у вас есть нички, правда? Это чудесно.
[21:22.160 --> 21:29.360]  Чтобы вы дальше тоже не сомневались. Второе, balance factor. Вот это одно из самых
[21:29.360 --> 21:36.640]  важных, что есть у нас в ВВЛ дереве. Balance factor поможет нам при балансировке
[21:36.640 --> 21:42.880]  деревьев, так как именно по нему мы будем понимать, где происходит дисбаланс. Так как мы
[21:42.880 --> 21:47.920]  будем вычитать высоту из правого по дереву минус высоту из левого по дереву.
[21:47.920 --> 21:55.640]  Если это положительное число и больше единички, то у нас что? Что больше? Правое.
[21:55.640 --> 22:02.600]  Причем дисбаланс у нас существует у этого дерева, согласны? Вот. Если же у меня будет
[22:02.640 --> 22:11.240]  оно отрицательное, тогда в этом случае я говорю, что у меня левая часть его больше и дисбаланс
[22:11.240 --> 22:24.080]  идет в сторону левого кусочка. Согласны? Понятно? Все равно, как много людей с нотами,
[22:24.080 --> 22:32.800]  все еще у меня интригов. Что еще? Ошибка, извините. Так как я пишу в Markdown, у меня не всегда
[22:32.800 --> 22:38.480]  правильно весь код компилируется, поэтому я не могу вам точно здесь делать. Да, это нужно
[22:38.480 --> 22:50.200]  исправить. Нода здесь большой буквки. Название типа данных. Вот. Если balance factor у нас равен 1,
[22:50.200 --> 22:58.640]  0 или минус 1, то дерево считается сбалансированным в плане AVL, с корнем в NODP. Согласны? Вот.
[22:58.640 --> 23:06.240]  У нас есть это некоторая балансировка. Согласны, что это работает тоже за у от единички? Отлично.
[23:06.240 --> 23:17.400]  Хоть что-то я вас научил. Вот. Уже мне нравится. Что еще? Восстановление корректности высоты. Вот
[23:17.400 --> 23:21.720]  fix height — это как раз-таки восстановление некоторой корректности. Мы предполагаем,
[23:21.720 --> 23:26.680]  что для левого и правого по деревьев уже все корректно, потому что мы всегда будем работать с
[23:26.680 --> 23:32.720]  низу вверх. Мы будем восстанавливать рекурсивно. Это означает, что мы будем фиксировать те самые
[23:32.720 --> 23:38.600]  высоты, которые есть. Тут нода тоже с маленькой буковки. Прошу прощения. Вот. У меня есть высота
[23:38.600 --> 23:45.000]  левого, высота правого. Но это просто. И, кстати, height тоже с маленькой буквой. Кошмар. Столько ошибок
[23:45.000 --> 23:50.960]  сделал. Ужас. Вот. Вот это бы не зашло, понимаете? Но зато поможет вам с точки зрения того,
[23:50.960 --> 23:58.200]  что сделать. Я это перепишу и выложу сегодня. Так вот. Когда мы с вами говорим про то, что мы
[23:58.200 --> 24:04.240]  фиксируем высоту, мы хотим ее пересчитать, у нас есть корректная левая, корректная правая. Я смотрю,
[24:04.240 --> 24:08.600]  какой из них больше, и делаю плюс один. Смотрите, никакой формулы максимум мне здесь не нужно.
[24:08.600 --> 24:14.280]  Никакой библиотеки алгоритм мне здесь не нужно. И написано все в строчку, друзья, представляете?
[24:14.280 --> 24:25.520]  Чудеса. Так тоже можно. Вот. Поэтому, да, можно делать это таким образом. И так мы восстанавливаем
[24:25.520 --> 24:35.240]  высоту. Мы точно знаем, что когда мы делаем ноду, у нее высота какая? Ноль. Правильно? Вот одна нода.
[24:35.240 --> 24:46.240]  Какая высота? Смотрите, значит, вы не уловили типа еще в самом начале. А, хорошо, да, высота 1,
[24:46.240 --> 24:54.440]  извините. Меня переклинило. Я тоже бывает, потому что... Я объясню, почему меня иногда переклинивает
[24:54.440 --> 25:00.940]  в этом плане. Корман, дискретная математика, они немного идут по-разному, и корман считает
[25:00.940 --> 25:11.180]  количество ребер. Я иногда подлагиваю, потом пишу что-нибудь другое. Да, у нода 1 высота. Мы
[25:11.180 --> 25:18.740]  будем считать количество нод. Прошу прощения, важно признавать свои ошибки. Вот. Поехали дальше.
[25:18.740 --> 25:25.540]  У нас с вами есть вот это фиксирование высоты. А согласны, что работает тоже завод единички?
[25:25.540 --> 25:37.300]  Смотри. Представь следующее, что я добавляю куда-нибудь вершинку. Ну, вот куда-нибудь,
[25:37.300 --> 25:46.740]  вот. Блин, оно у меня все будет тогда уже несбалансированное. Вот так. И вот так. Вот,
[25:46.740 --> 25:55.100]  я добавил вот эту ноду. Да. Я пытаюсь пересчитать вот здесь высоту. Какая была высота до этого у
[25:55.100 --> 26:04.340]  ноды вот этой? Она была единичка. Но я же добавил вершинку. Я попытаюсь сделать ее два. Потом
[26:04.340 --> 26:11.540]  попытаюсь пересчитать еще выше что-то и выше, на всякий случай. То есть фикс hate это будет то,
[26:11.540 --> 26:20.260]  что мы передаем сюда одну лишь ноду. Одну. И мы говорим, что у левой и правой его части корректная
[26:20.260 --> 26:29.380]  высота, поэтому пересчитаем для нее высоту. Это просто пересчет высоты. Ну, то есть, грубо говоря,
[26:29.380 --> 26:37.220]  представь, что у тебя есть дерево. Ты знаешь, что высота здесь равна х, что высота здесь равна у.
[26:37.220 --> 26:51.220]  Какая высота здесь? Ну, вот у меня h left и h right. Высота левого кусочка, высота правого кусочка.
[26:51.220 --> 27:04.500]  Видишь, это hate от p left и p right. Это высоты. Вот это и есть x и y. Тогда высота вот этого чему равна?
[27:08.220 --> 27:22.940]  Откуда сумме-то? Чему равна здесь высота? Она максимуму равна из x и y плюс 1. Не сумме.
[27:22.940 --> 27:31.460]  Потому что мы рекурсию будем записывать в другой момент. Мы до этого дойдем. Это будет
[27:31.460 --> 27:38.020]  отдельный момент. Хорошо? Мы просто делаем вот некоторые такие функции, которые нам понадобятся,
[27:38.020 --> 27:46.700]  просто при вызове. Мы все сделаем. Теперь что касается балансировки узлов. Нам нужен хороший
[27:46.700 --> 27:53.180]  баланс в том, чтобы высота была логарифм. Мы с вами в конце докажем, что высота вл-дерево,
[27:53.180 --> 28:00.780]  логарифм. Это в конце. Пока мы просто с ним живем. А в действительности строго доказывается,
[28:00.780 --> 28:09.460]  что при добавлении нового одного узла у нас баланс-фактор у всего может поменяться на 2 или
[28:09.460 --> 28:18.940]  минус 2. Максимум. Не может быть такое, что там будет минус 3 или 3 или еще что-то. Баланс-фактор
[28:18.940 --> 28:26.820]  будет по абсолютной величине более двойки. Больше быть не может. И вот это возникает так
[28:26.820 --> 28:33.020]  называемая разбалансировка дерева. Как работать в тех или иных случаях? Что же нам делать вообще,
[28:33.020 --> 28:39.140]  когда у нас происходит разбалансировка? Кто представляет? У другого есть идея?
[28:39.140 --> 28:46.820]  Правильно. Перенести, поворачивать. Это вот все об одном. Действительно нужно чуть-чуть
[28:46.820 --> 28:54.980]  повернуть дерево, чтобы это было хорошо. Представим следующее. Вот у меня есть некоторая такая ситуация,
[28:54.980 --> 29:01.380]  нужно понять, что с ней делать. И вообще для выпрямления ситуации, в управление того,
[29:01.380 --> 29:09.700]  чтобы у нас было сбалансировано дерево, применяются повороты вокруг тех или иных узлов. Смотрите,
[29:09.700 --> 29:17.220]  у меня есть A, B, C. Это по деревьям. И Q, P. Я точно знаю. Х и Y это внутри,
[29:17.220 --> 29:24.860]  которые ключи лежат. Q и P. Я думаю, вы их видите. Правда? На всякий случай, я думаю, вы прекрасно
[29:24.860 --> 29:33.580]  помните, что если я опущу все на ось все чиселки, тогда они лягут в ровную последовательность. То есть
[29:33.580 --> 29:38.540]  возрастающую последовательность. Вот здесь аналогично, что A будет меньше X, A меньше B,
[29:38.540 --> 29:45.820]  меньше Y, меньше C. Я думаю, вы это понимаете. Потому что это является бинарным деревом поиска.
[29:45.820 --> 29:53.060]  И вот что такое правый поворот вокруг P или левый поворот? Если мы говорим про правый поворот,
[29:53.060 --> 30:02.420]  тогда смотрите, Q и P по сути меняются местами. И у P левым его ребенком становится B. То есть в
[30:02.420 --> 30:08.300]  одну сторону повернуть, это вот вправо пойти. Потом влево можно пойти. Вот здесь мы можем с вами
[30:08.300 --> 30:14.740]  менять и самый поворот. То есть правый поворот, когда я Q и P меняю местами, то есть место P становится Q
[30:14.740 --> 30:26.380]  сверху. Левый поворот наоборот. Окей? Понятно пока? Вот схематично. Что?
[30:26.380 --> 30:37.060]  Переподвешивание. Ну смотрите, все, что нужно переподвесить. Нам нужно сказать, что у Q теперь
[30:37.060 --> 30:44.780]  ребенок P правый. Ну вот если я говорю про правый поворот, что у Q становится правым ребенком P,
[30:44.780 --> 30:55.020]  левое остается все также A. А у P левым ребенком становится B. Все. Только вот эти две вещи нам
[30:55.020 --> 31:04.340]  нужно как-то обозначить. Мы не делаем здесь родителей. Я специально не брал эти указатели. Я
[31:04.340 --> 31:12.300]  специально немного поменял формат самой ноды для того, чтобы хоть было что-то интересное. То есть
[31:12.300 --> 31:18.980]  у бинарного дерева поиска мы брали парантов специально. Здесь я хочу без них вам показать,
[31:18.980 --> 31:29.500]  как что будет жить. А, в этом плане, в этом плане, ну там не так уж это будет проблематично,
[31:29.500 --> 31:35.780]  потому что мы будем опять же рекурсивно что-то делать. Вы увидите. Вот. Если мы говорим вот именно
[31:35.780 --> 31:41.580]  такой вот концепции, как у нас происходит. А что мы можем сделать? Ну как бы еще раз. Все,
[31:41.580 --> 31:51.620]  что нам нужно сделать. B переподвесить к P, а Q сказать, что у него ребенок теперь P. Вот. Если мы
[31:51.620 --> 31:59.380]  говорим про тот самый правый поворот вокруг ноды P, тогда я говорю, что нода какая-нибудь Q равна
[31:59.380 --> 32:05.380]  P левт. Для того, чтобы сбалансировать то самое дело. Почему я вообще вот начинаю эти повороты? Давайте
[32:05.380 --> 32:10.060]  с вами посмотрим. Вот когда, в каком случае происходит правый поворот? Давайте начнем с этого
[32:10.060 --> 32:21.020]  момента, то я боюсь, что я это не очень рассказал. Вот смотрите, у нас есть P, у нас есть Q, у нас есть
[32:21.020 --> 32:45.660]  A, B, C. Я беру и поворачиваю и делаю следующее, что у меня будет здесь Q, B, B, A. Для чего я это
[32:45.660 --> 32:53.580]  делаю? Для того, чтобы попытаться сбалансировать то самое дерево. Представим, что у меня вот эта часть
[32:53.580 --> 33:05.340]  это H плюс 2, а вот эта часть H. Здесь, возможно, различные случаи между A и B. Я считаю, что вот
[33:05.340 --> 33:14.340]  эта часть у меня сбалансирована. То есть у меня здесь, возможно, минус 1, 0, 1. Правильно? Вот такая
[33:14.340 --> 33:22.700]  вот, возможно, штука. И мы рассмотрим различные его версии между собой. Но давайте возьмем, что пока
[33:22.700 --> 33:29.460]  0. Посмотрим на 0, что будет происходить в этом случае. Если я скажу, что они одинаковые, тогда высота
[33:29.460 --> 33:38.460]  каждой из этих частей, вот эта, это H плюс 1, согласна? И вот эта, это H плюс 1. Тогда, когда я вот
[33:38.460 --> 33:45.940]  это сделаю, вот этот правый поворот, в этом случае высота здесь это H плюс 1, высота здесь это H плюс 1,
[33:45.940 --> 33:59.820]  ну а здесь какая-то H осталось. Да, если balance factor 0, тогда в этом случае с P какая высота? H
[33:59.820 --> 34:05.740]  плюс 2. Согласны ли вы с тем, что здесь H плюс 1, здесь H плюс 2, дерево стало сбалансированным в
[34:05.740 --> 34:15.740]  плане ВЛ? Потому что разница не более чем на единицу. Окей? Понятно, что я сделал этим поворотом.
[34:15.740 --> 34:33.660]  Вот это вот в случае нуля. А что будет происходить в случае, к примеру, минус 1? А если я это раз сделаю,
[34:33.660 --> 34:48.900]  давайте еще раз это перепишу. У меня очень странно это выглядит, потому что высота вот этого H плюс 2,
[34:48.900 --> 35:00.300]  вот этого H, но это ладно. А, дайте P, Q. Здесь H плюс 2, здесь также H. Я говорю, что у меня
[35:00.300 --> 35:09.620]  минус 1 balance factor. Минус 1 означает, что правый меньше левого, согласны? Если я говорю,
[35:09.620 --> 35:22.660]  что правый меньше левого, и он равен минус 1, тогда что? Все правильно, это H плюс 1, это H.
[35:22.660 --> 35:45.820]  Я беру и поворачиваю, делаю правый поворот. У меня здесь Q, P, A, B. Вот это высота H плюс 1,
[35:45.820 --> 35:55.700]  вот это высота H, вот это H. Согласны? Значит, высота вот этого сколько? Плюс 1. Значит,
[35:55.700 --> 36:05.660]  вот здесь вот balance factor равен нулю. Согласны? Вот здесь вот balance factor равен 1. Остался
[36:05.660 --> 36:13.140]  последний случай. Как вы думаете, он будет аналогичен этим? Кто считает, что да?
[36:16.420 --> 36:21.700]  Просто повернул, да и все. Все так же вот и повернул, и у меня все хорошо.
[36:26.900 --> 36:29.740]  Когда у меня balance factor вот здесь, вот единичка.
[36:29.740 --> 36:45.020]  Это не так там. А это фактика, правда. Но мы сейчас до этого дойдем отдельно, посмотрим.
[36:45.020 --> 36:52.260]  Пока считается, что у меня правый поворот, он разбирает вот этот случай по факту и вот этот
[36:52.260 --> 36:58.460]  случай. Он отлично на них работает. У меня благодаря этому восстанавливается балансировка,
[36:58.460 --> 37:03.580]  если у меня нижние уже были сбалансированы. Согласны? Кроме быть, может, одного случая.
[37:03.580 --> 37:15.020]  Один случай мы рассмотрим отдельно. А? В смысле A и B поменять местами? Что еще раз?
[37:15.020 --> 37:27.820]  Подожди. Что это? Куда это? Куда ты гонишь? Давай по это, по чуть-чуть. Так вот,
[37:27.820 --> 37:34.460]  сбалансировка узлов с точки зрения того, как работает поворот направо. Поворот направо что
[37:34.460 --> 37:41.980]  делает? Вот у меня есть вот это P, Q и так далее. Я говорю, что Q это P left. Левая его часть. Ну вот
[37:41.980 --> 37:57.420]  оно. Водку и водку. Согласны? Я говорю, отлично, я нашел это. Дальше я говорю, что P left равен теперь Q
[37:57.420 --> 38:04.580]  right. То есть, вот это B переподвешиваю к P. То есть, то, что я делаю, это вот я затираю,
[38:04.580 --> 38:19.340]  я делаю вот так вот и затираю вот эту связь. Согласны? Чего еще раз? Так нет, еще раз. Я говорю,
[38:19.340 --> 38:27.020]  что P left равно Q right. Значит, вот этой связи больше нет. У меня же связь односторонняя в ту сторону.
[38:27.020 --> 38:36.540]  Вот поэтому эта связь исчезает, появляется вот это пунктиром. Согласны? Отлично, вот этой связи
[38:36.540 --> 38:43.900]  у нас больше нет. Чего у нас осталось сделать? У меня у P теперь висит B и P. Осталось сказать,
[38:43.900 --> 38:53.500]  что у этот B теперь правый ребенок Q. Согласны? Вот я это и делаю дальше. Я говорю, что Q right равно
[38:53.500 --> 39:05.940]  P. После этого, смотрите, у A высота изменилась как-то у A, у B как-то изменилась, а у C нет. А вот
[39:05.940 --> 39:13.020]  у P изменилась, да, и у Q изменилась. И так как я делаю вот этот вот восстановление корректности
[39:13.020 --> 39:21.140]  высоты, я должен идти снизу вверх. Поэтому я сначала делаю P, затем делаю Q. Согласны?
[39:24.140 --> 39:25.100]  Вопросы есть?
[39:31.940 --> 39:38.620]  Презентация будет, правда, прям сегодня. Вот, если хочешь писать, пиши. Смотрите,
[39:38.620 --> 39:45.460]  еще раз, A, B и C остаются ровно такой же высоты, как были с самого начала. Согласен? То есть,
[39:45.460 --> 39:53.020]  как были здесь, так и остались. А вот у P и у Q поменялись высоты. Поэтому я в начале пересчитаю
[39:53.020 --> 40:04.420]  P, а потом пересчитаю Q. Все. Вот. Это и будет делать вот это fixate. Ну а дальше я верну новый корень у
[40:04.420 --> 40:10.220]  этого поддерева, окей? Этот новый корень, он будет потом переподвешивать на самом деле все,
[40:10.220 --> 40:16.260]  что нам нужно. То есть, вот это восстановление связи с родителем, вот как ты говорила,
[40:16.260 --> 40:27.900]  вот оно вот будет вот благодаря этому возвращению. В смысле, как родителю становится у Q новым
[40:27.900 --> 40:35.560]  ребенком вместо P? Мы до этого дойдем. Давайте, по чуть-чуть. Мы здесь не просто так возвращаем
[40:35.560 --> 40:40.860]  новый корень. Если мы вернули новый корень, мы сможем легко его переделать. Понятно?
[40:41.380 --> 40:51.900]  Вопросы к этому есть? К правому повороту. Смотрите, левый поворот делается аналогичнейшим. Просто в другую
[40:51.900 --> 40:59.060]  сторону вам нужно сделать. То есть, вот из этого случая получить вон тот. Все очень просто. Давайте
[40:59.060 --> 41:08.380]  сначала разберем, за сколько работает этот поворот. За у от единичку. Потому что создать указатель
[41:08.380 --> 41:15.340]  у от единички, присваивание, присваивание у от единички, а фиксировать высоту у от единички.
[41:15.340 --> 41:21.700]  Вернуть у от единички. Все за у от единички. Вот левый поворот. Там будет происходить просто ровно
[41:21.700 --> 41:28.420]  то же самое. Понятно? Здесь я специально, вот здесь тоже с маленькой буковки, тоже мне нужно переделать.
[41:28.420 --> 41:36.020]  Здесь аналогично. То есть, я специально здесь взял Q как корень, чтобы вы могли спокойно,
[41:36.020 --> 41:44.660]  симметрично друг друга вот эти случаи отображать. Вот вроде бы здесь все становится хорошо для левого и
[41:44.660 --> 41:50.660]  правого поворота. Но мы с вами уже проговорили, я уже с вами порисовал, что мы один случай не можем
[41:50.660 --> 41:57.220]  сделать. Почему мы не можем сделать? Давайте его отдельно рассмотрим сейчас с вами. У нас
[41:57.220 --> 42:20.140]  случаи, когда у нас баланс фактор единичка. Давайте с вами это посмотрим. Да. Это действие,
[42:20.140 --> 42:25.900]  вот здесь аналогично. Вот смотрите, у меня здесь УП. Вот это В я должен переподвесить Q.
[42:26.900 --> 42:33.420]  Вот я отсюда это В. У него П левт, видишь? Становится Q райт.
[42:38.060 --> 42:46.780]  Q райт у его правый ребенок становится В. А для того, чтобы на В я брал, вот это вот является P левт.
[42:46.780 --> 43:08.060]  P левт должно стать Q райтом. Нет, почему? У нас что здесь будет? Я что должен сделать?
[43:08.140 --> 43:17.980]  Сказать должен, что у Q теперь правый ребенок В и забить на эту связь. Ой, не на эту, на вот эту.
[43:17.980 --> 43:30.660]  Q райт, вот она связь, равен P левт. Для того, чтобы у меня у Q был A ребенок и B ребенок. Понял?
[43:30.660 --> 43:47.940]  Q райт это было вот это. Он указывал на П. А теперь он должен указывать на В. Это левый, это левый.
[43:47.940 --> 43:58.660]  Вот. Окей. А давайте рассмотрим теперь тот самый случай отдельно. Вот у меня есть П, у меня есть
[43:58.660 --> 44:08.860]  некоторая Q. А те, кто говорит, он уже все это, все в Эльдерево шарит. Кто-нибудь сможет мне
[44:08.860 --> 44:19.220]  написать за 20 минут, пока я это рассказываю? Тогда чего? Окей, вот у нас есть этот случай B,
[44:19.220 --> 44:32.020]  C. Я говорю, что у меня высота вот этого H, высота вот этого H плюс 2 и balance factor равен единичке.
[44:32.020 --> 44:40.180]  Вот здесь вот. Если он здесь равен единичке, то что это значит? Что у кого? У B какая высота?
[44:42.180 --> 44:49.100]  У B высота больше, чем у A, правильно? Правый минус левый. Значит высота вот этого H плюс 1,
[44:49.100 --> 44:55.900]  высота вот этого H, согласны? Правильно я понимаю? Делаю тот самый правый поворот,
[44:55.900 --> 45:09.100]  который мы с вами делали. Что я с вами получу? Я получу с вами Q. Здесь у меня будет P, здесь A,
[45:09.180 --> 45:25.980]  A, B, C. У A высота H, у B высота H плюс 1, у C высота H. Значит высота вот этого сколько? H плюс 2.
[45:25.980 --> 45:32.980]  Смотрите, я его перебалансировал так, что теперь у меня правая сторона перевешивает. Не прикольно,
[45:32.980 --> 45:41.660]  согласна? Вот вообще не прикольно. Чего в этом случае делать? В этом случае на самом деле нужно
[45:41.660 --> 45:49.980]  рассмотреть еще одну вещь. Нужно уйти еще ниже. Здесь я рассматриваю на самом деле, когда левый
[45:49.980 --> 45:56.620]  поворот симметричен тому случаю, который здесь. Как хотите, давайте я по рисункам пойду лучше.
[45:56.620 --> 46:02.700]  Вот здесь я с вами показал правый поворот, я покажу аналогичную ситуацию для левого поворота.
[46:02.700 --> 46:08.660]  Левый поворот будет аналогичен, что у нас все перевесится. Что сюда я буду перевешивать,
[46:08.660 --> 46:20.820]  что сюда. Давайте рассмотрим еще один узел чуть пониже. То есть вот то, что здесь написано,
[46:20.820 --> 46:36.180]  я говорю, что h-a-hq равно 2. Сейчас будем рисовать тот самый левый поворот. У меня что там?
[46:50.820 --> 47:11.140]  h-a-hq равно 2. Хорошо. Хорошо. Ладно. Вопрос нескорее не об этом? Ну да ладно. Окей, это правда.
[47:12.020 --> 47:20.740]  Давайте смотреть, что у нас будет происходить. В чем у нас с вами будут проблемы и что мы захотим
[47:20.740 --> 47:27.540]  сделать. В действительности, если я просто поверну в ту сторону, у меня ничего не изменится,
[47:27.540 --> 47:32.180]  у меня будут какие-то проблемы. Почему? Потому что высота вот у этого кусочка у меня будет h
[47:32.180 --> 47:42.420]  плюс 1, вот у этого h, вот у этого h. В этом вся проблема. Согласны? Давайте мы сделаем чуть-чуть
[47:42.420 --> 47:50.780]  другие итерации. Я вначале возьму и поверну относительно вот этого кусочка. Что я с вами получу?
[47:50.780 --> 48:15.660]  Я получу здесь p, здесь a, здесь s, у которого будет здесь b, аq, c, d. Я это поверну. В зависимости
[48:15.660 --> 48:20.900]  от ситуации вот этого h плюс 1, где здесь больше, где здесь меньше, на самом деле здесь не сыграть
[48:20.900 --> 48:27.540]  ничего из этого роли, потому что вот здесь у меня высота h, у меня высота c может быть какая,
[48:27.540 --> 48:45.540]  ну либо h, либо h минус 1. Здесь высота какая? h может быть, h минус 1. В зависимости от
[48:45.540 --> 48:50.980]  того, какую комбинацию мы просто здесь берем, у нас что-то получится. Либо h, h, либо h, h минус 1,
[48:50.980 --> 49:00.060]  либо h минус 1, h. Но в любых из этих ситуаций, если вот здесь высота h, h минус 1, вот здесь высота h,
[49:00.060 --> 49:08.580]  или h минус 1, вот здесь высота всегда h, согласны? Значит, баланс-фактор вот у этой части теперь
[49:08.580 --> 49:26.300]  какой? Либо 0, либо 2. Не может быть. Еще раз, вот здесь высота h плюс 1 всегда. Сейчас, если мы с вами
[49:26.300 --> 49:31.700]  вот таким вот образом поменяем, то вообще какой следующий шаг к этому всему? Давайте по отдельности
[49:31.700 --> 49:38.900]  будем просто это делать. Sorry, я что-то... конец вечера, видимо, все, сломался. Вот здесь вот s,
[49:38.900 --> 49:47.180]  вот здесь вот у меня будет a, ой, нет, вот здесь вот у меня будет, получается,
[49:47.180 --> 50:07.900]  c, p, вот здесь вот будет a, вот здесь вот будет a, b, вот здесь вот у меня q, c, d. Согласны? Да. Высота
[50:07.900 --> 50:20.100]  вот этого чему равна? h, вот этого h, вот этого h, или h минус 1, этого h, или h минус 1. Согласны?
[50:20.100 --> 50:26.820]  Вот, теперь все будет хорошо. Да, вот этот случай нам не важно в середине, потому что я по итогу
[50:26.820 --> 50:36.860]  получу то, что мне необходимо будет в любом случае. Мы повернули вот это s сюда. Ну, смотрите,
[50:36.860 --> 50:55.340]  у меня сохранился порядок, у меня был порядок a, p, b, s, c, q, d. Давайте a, p, b, s, c, q, d.
[50:55.940 --> 51:06.500]  A, p, b, s, c, q, d. Порядок не изменился. Я просто поменял вот это сюда. Когда я сюда вот это поверну,
[51:06.500 --> 51:13.300]  что это означает? Что в p просто перенесется вот этот кусочек. Понятно? А вот эта связь уйдет,
[51:13.300 --> 51:19.100]  и она будет вот так показывать. Ну, представьте, что я сделал левый поворот здесь.
[51:19.100 --> 51:28.860]  Не, ну, смотри, представь, вот это все большим таким под деревом. Тебе нужно сделать левый поворот.
[51:28.860 --> 51:36.860]  Левый поворот это означает, что ты должен вот из этой части вот сюда прийти. Не смотри здесь на
[51:36.860 --> 51:50.740]  q, не смотри на c, d, вот возьми, что это большое-большое под дерево x. Так понятнее? Вот, ну типа все,
[51:50.740 --> 51:58.660]  это повернется и будет так же. Хорошо? Вот. Ну вот, если говорить про x, то вот это вот будет
[51:58.660 --> 52:10.780]  большое-большое под дерево. Окей? Теперь стало чуть яснее. Хорошо. Вот, то есть, смотрите,
[52:10.780 --> 52:17.260]  в случае, когда у нас с вами возникает вот тот самый дисбаланс, когда по сути мы сделаем поворот,
[52:17.260 --> 52:25.540]  и ничего не произойдет, мы сможем сначала сделать правый поворот вокруг p, а потом левый поворот туда.
[52:25.540 --> 52:33.220]  Понятно? Я сначала вот сюда перенес, потом туда, и тогда в этом случае у меня баланс восстанавливается,
[52:33.220 --> 52:42.580]  потому что тут h, тут h, тут h или h-1, тут h или h-1, тут h, здесь баланс сохранен, здесь баланс сохранен,
[52:42.580 --> 52:50.060]  в общем баланс тоже сохранен, потому что высота вот этого h-1, вот этого h-1. Согласны? Всегда.
[52:50.060 --> 52:59.460]  Понятно? Именно для этого случая. Задайте вопросы. Я, возможно, вас случайно убил, когда сам запутался.
[52:59.460 --> 53:17.340]  Два. Еще раз. S, P, Q, потом вот сюда, потом S, P. Кого? Нет. Где? Еще раз. Вот этот случай.
[53:17.340 --> 53:29.980]  Где я здесь поворачиваю? Просто рассматриваю этот случай отдельно. Я S поворачиваю в Q, получаю вот это,
[53:29.980 --> 53:37.860]  потом S поворачиваю в P. То, что я здесь повернул и получил типа из одного случая в другой, я
[53:37.860 --> 53:44.180]  специально вам показал, что они не работают. Простые повороты здесь не работают. Вот этот
[53:44.180 --> 53:50.060]  поворот, когда мы поворачиваем сначала влево, потом вправо, или вправо, потом влево, называются
[53:50.060 --> 54:04.940]  большие повороты. Либо большой правый поворот, либо большой левый поворот. А? Да. Вот. А в чем вообще
[54:04.940 --> 54:11.620]  суть? Но эти повороты большие, состоят из маленьких, согласны, из двух маленьких. Причем, смотрите,
[54:11.700 --> 54:15.820]  в каком случае нам необходимо будет выполнять большой левый или большой правый поворот.
[54:15.820 --> 54:28.580]  Смотрите, balance factor вот здесь, вот какой был УП? Нет, ну здесь H плюс 2, здесь H. Минус 2. И у нас
[54:28.580 --> 54:37.620]  не балансировалось дерево при единичке. Согласны? Аналогично здесь будет balance factor у Q будет
[54:37.620 --> 54:51.180]  минус 2, а у правого или левого кусочка будет 1. Плюс 2, да, извините, плюс 2 и минус 1. То есть,
[54:51.180 --> 54:59.380]  смотрите, здесь ситуация аналогична, то есть знаки различаются, у нас проблемы. Понятно? Запомните
[54:59.380 --> 55:06.260]  таким образом. Почти уверен, что это помогает. Я в всяком случае всегда так понимаю, поэтому я
[55:06.260 --> 55:13.300]  знал, какие случаи с вами разобраться. Вот. Но это просто удобно. Тоже касается большого левого,
[55:13.300 --> 55:18.980]  большого правого поворота. Вот здесь, смотрите, я поворачиваю вправо, поворачиваю влево потом.
[55:18.980 --> 55:24.700]  Вот это большой левый был. Большой правый аналогичен. Выглядит все достаточно просто. Я
[55:24.700 --> 55:29.780]  не выписывал отдельно эти повороты, потому что они состоят из маленьких. Я лишь написал саму
[55:29.780 --> 55:37.420]  балансировку. Смотрите, я пытаюсь сбалансировать некоторую ноду. Я для начала беру и фиксирую
[55:37.420 --> 55:44.260]  у него высоту. На всякий случай, потому что мне нужна корректная высота будет. Так или иначе.
[55:44.260 --> 55:50.580]  А фиксирование высоты повлечет за собой там еще некоторые вещи. Дальше я смотрю. Если у меня
[55:50.580 --> 56:00.140]  баланс-фактор в П равен 2, то есть у меня правый кусок больше левого, тогда я в общем случае точно
[56:00.140 --> 56:05.740]  буду делать rotate left. Согласно, левый поворот всегда будет присутствовать. Но в случае,
[56:05.740 --> 56:14.180]  если я нахожу, что у меня баланс-фактор был у правого кусочка меньше нуля, то есть минус один
[56:14.180 --> 56:23.620]  по факту, тогда я должен буду сделать большой левый поворот. Согласно? А для большого левого
[56:23.620 --> 56:28.620]  поворота что я должен сделать? Вот если именно левый, вот здесь он указан. Я должен сначала вправо
[56:28.620 --> 56:37.940]  повернуть вот здесь. Правильно? Это вот этот вот rotate right от P right. Вот он по сути. Это Q. Понятно?
[56:37.940 --> 56:47.500]  Вот я делаю большой правый поворот относительно этой вершинки от P right. А дальше я делаю большой
[56:47.500 --> 56:58.660]  просто левый поворот относительно P. Причем смотрите, вот спрашивали как связь восстановить. Вот то
[56:58.660 --> 57:07.780]  есть у меня что тесс встала. Я просто пишу что P right равно rotate right или rotate left. Там не
[57:07.780 --> 57:16.580]  есть разница. Rotate right от P right. Вот все просто. Так как он возвращает мне тот самый новый корень.
[57:16.580 --> 57:22.260]  То есть еще раз я поворачиваю в одну сторону, потом в другую. Вот здесь вот эта балансировка
[57:22.260 --> 57:30.100]  работает. Дальше я делаю следующее, что я просто смотрю. Если у меня баланс-фактор равен минус два,
[57:30.100 --> 57:37.300]  тогда в этом случае я должен буду делать либо просто правый поворот, либо большой правый поворот.
[57:37.300 --> 57:52.580]  Если большой правый поворот, то я сначала делаю поворот лево, а потом вправо. Все. Вот этот
[57:52.580 --> 58:01.660]  if. Вот если if выполняется, значит мне нужен большой левый поворот. Тогда я делаю сначала
[58:01.660 --> 58:12.420]  rotate left, а потом делаю rotate right. Большой правый поворот. Тогда у меня этот баланс-фактор не
[58:12.420 --> 58:18.860]  может быть больше нуля. Еще раз говорю, у вас большой поворот в случае, если у вас баланс-фактор
[58:18.860 --> 58:25.540]  в самой вершине, если он положительный, тогда в другой вершине он должен быть отрицательный.
[58:25.540 --> 58:32.220]  И наоборот, если он отрицательный, тогда в другой вершине положительный. Большие повороты только в
[58:32.220 --> 58:38.260]  этом случае. Мы рассматривали это здесь на примере, что для минус один и для нуля было все правильно,
[58:38.260 --> 58:45.140]  для единички было плохо. Все. Ну вот эти if, я, возможно, из-за того, что не взял их в скобочки,
[58:45.140 --> 58:50.020]  просто чтобы поместился код покрасивший, а из-за того, что не взял скобочки, возможно,
[58:50.020 --> 58:59.060]  непонятно. По отступам поймите, пожалуйста. Понятно? Да, это мы сейчас дойдем. Это будет
[58:59.060 --> 59:07.060]  происходить при insert или при delete. Если if не выполняется, у нас просто написано return
[59:07.060 --> 59:17.660]  rotate right. Видишь? Rotate right это означает правый поворот. Он же не в if. Понятно?
[59:21.020 --> 59:29.260]  То в то if зайдем, да. Вот. Все просто. Согласны, что это балансировка происходит за вот единички?
[59:29.260 --> 59:36.980]  Потому что поворот правый, поворот лево они за вот единички. Поехали дальше. Давайте поговорим
[59:36.980 --> 59:45.780]  теперь про вставку ключа. Вставку ключа мы будем делать рекурсивно и не будем забывать про ту самую
[59:45.780 --> 59:57.020]  балансировку, которая нам необходима. Смотрите, я беру и вставляю какую-то ноду P с ключом K. Вот.
[59:57.020 --> 01:00:04.980]  Если у меня нода P равна NALPTR, тогда я просто создам эту ноду. Если она не была равна,
[01:00:04.980 --> 01:00:11.580]  тогда оставлю ту, которая была. Не суть важна, просто буду так сравнивать. Дальше я говорю,
[01:00:11.580 --> 01:00:19.980]  что если у меня ключ меньше, чем ключ в вершинке, который нахожусь, тогда я иду куда? В левую его
[01:00:19.980 --> 01:00:26.940]  часть. Потому что ключ меньше, значит то необходимое место, куда мне вставить ключ находится слева,
[01:00:26.940 --> 01:00:34.700]  правильно? Если он больше, тогда иду вправо. Согласны? До каких пор я это повторяю? Я это
[01:00:34.700 --> 01:00:42.500]  повторяю до тех пор, пока не наткнусь на NALPTR. Вот эта остановка рекурсии в P равна NALPTR и есть
[01:00:42.500 --> 01:00:51.980]  та самая. То есть, смотрите, у меня есть некоторое дерево. Я вот сейчас рандомно рисую его, не обязательно,
[01:00:51.980 --> 01:00:57.700]  что оно будет сходиться с тем, что там необходимо будет СВЛ-деревом, например. Так вот, у меня есть
[01:00:57.700 --> 01:01:03.340]  это дерево и я нахожу, где мне найти это место? Ну, я пойду сюда, сюда и вот я вижу, что вот здесь
[01:01:03.340 --> 01:01:12.060]  у меня образовался вот этот NALPTR. Я такой, ну туда и вставлю. Я вставляю этот элемент. Согласны,
[01:01:12.060 --> 01:01:19.100]  что вот это дерево разбалансировалось? Проблема. Что в этом случае делать? Я вставил этот элемент,
[01:01:19.100 --> 01:01:26.020]  поэтому в конце рекурсии я делаю balanceP. Так как я это делаю в конце рекурсии, у меня же стэк
[01:01:26.020 --> 01:01:32.940]  вызовов рекурсии, как идет? Сначала вызов большой функции для корня, согласны? Потом вызов для
[01:01:32.940 --> 01:01:43.500]  этого, давайте я это пронумерую. Там 0, 1, потом вот это 2, а вот это будет 3. Согласны? Ну,
[01:01:43.500 --> 01:01:53.980]  вот эти вот инсерты как пойдут друг за дружкой, рекурсивно. Ну да, там return написано, так что нет,
[01:01:53.980 --> 01:02:04.100]  не будет. Хорошо. 0, 1, 2. И дальше что он делает? Он делает return balanceP. То есть он просто берет и
[01:02:04.100 --> 01:02:13.180]  сбалансирует сначала 2, потому что он идет в обратном порядке, потом 1, потом 0. И он будет
[01:02:13.180 --> 01:02:17.980]  их сбалансировать между собой, так как я иду снизу вверх, у меня будет вся балансировка корректно,
[01:02:17.980 --> 01:02:24.820]  потому что если этот не сбалансирован элемент, то он его сбалансирует, и значит для вот этого
[01:02:24.820 --> 01:02:30.540]  элемента теперь все нижнее тоже сбалансировано. Я тоже его балансирую и так далее. Согласны?
[01:02:30.540 --> 01:02:37.260]  Понятно, что я сделал? Не уверен, что для всех понятно. Это меня пугает.
[01:02:37.260 --> 01:02:50.140]  Потому что в конце у вас может поменяться вообще корень.
[01:02:50.140 --> 01:02:57.140]  Но у вас инсерт будет специально возвращать эту ноду со звездочкой.
[01:02:57.140 --> 01:03:15.940]  На новую ноду в каждом разе. То есть смотрите, это не то что только для последнего случая. Смотри,
[01:03:15.940 --> 01:03:23.380]  я сбалансировал вот этот кусок и предположим у меня здесь поменялся корень. Согласны? Я именно
[01:03:23.380 --> 01:03:30.660]  для этого там пишу p-left или p-right равно инсерт чего-то. Почему? Потому что если у меня
[01:03:30.660 --> 01:03:37.420]  здесь поменялся корень, то я должен заново его связать. Согласны? Вот я это и делаю здесь. То есть
[01:03:37.420 --> 01:03:42.340]  вот здесь как-то поменялась структура, и я связываю это с корнем того, что у меня есть.
[01:03:42.340 --> 01:03:51.060]  Балансировку мы обязаны делать каждый раз.
[01:03:59.620 --> 01:04:08.940]  Можно, но когда ты делаешь вайлом, ты не раскрутишься назад. А как ты переподвешивать
[01:04:08.940 --> 01:04:14.500]  будешь? Смотри, мне нужно вот это дерево, которое вот здесь. Нужно будет его перебалансировать. У
[01:04:14.500 --> 01:04:21.580]  тебя поменяется структура дерева. Ну, например, господи, сейчас давайте я где-нибудь порисую.
[01:04:21.580 --> 01:04:28.620]  Возможно, в прошлый раз я вас чуть раньше отпустил, в этот раз я вас чуть задержу. Так сказать,
[01:04:28.620 --> 01:04:35.980]  закон сохранения времени. А если кому-то очень нужно будет спешить, станете уйдете. Я не обижусь.
[01:04:35.980 --> 01:04:44.500]  В этот раз. Вдруг я обижаюсь. Короче, смотрите, представим, что у меня было следующее дерево.
[01:04:44.500 --> 01:04:50.780]  Оно сбалансировано в плане АВЛ. Ну, вроде сбалансировано. Согласны? А, представим,
[01:04:50.780 --> 01:04:56.620]  что я вставляю сюда элементы. Оно становится дебалансным. Я пытаюсь сбалансировать вот
[01:04:56.620 --> 01:05:08.380]  этот элемент. Сбалансирую его. А? А вот тут? Здесь нет. Здесь нет проблемы. Я оставляю его таким же.
[01:05:08.380 --> 01:05:16.300]  И вот эту связь я заново сохраняю. Вот эту. Окей? Потом я смотрю выше. Вот это сбалансированный кусочек,
[01:05:16.300 --> 01:05:23.460]  но сбалансированный. Баланс не изменится. Я беру и вот эту штуку оставляю. Вот это теперь
[01:05:23.460 --> 01:05:29.500]  часть сбалансирована. Вот эта часть сбалансирована между собой. Смотрим вот это и пытаемся
[01:05:29.500 --> 01:05:37.700]  сбалансировать. Согласны, что у меня здесь разные вещи между собой? Согласны? Отлично. Мне нужно
[01:05:37.700 --> 01:05:44.880]  сбалансировать. Эта часть больше этой. Ой, вот эта часть больше вот этой. Согласны? Что мне в этом
[01:05:44.880 --> 01:05:51.700]  случае нужно делать? По-хорошему, повернуть налево. Либо сделать большой поворот налево. Здесь
[01:05:51.700 --> 01:06:01.580]  хватит просто поворота налево то есть я должен получить здесь давайте я сделаю здесь 0 1 2 3 4 5
[01:06:01.580 --> 01:06:26.100]  я должен сделать здесь 2 0 1 3 или мы каждый раз будем это переделывать то есть смотри
[01:06:26.100 --> 01:06:33.380]  если бы у меня здесь нарушился баланс я бы здесь поменял да так как рекурсии стек
[01:06:33.380 --> 01:06:39.700]  рекурсии раскручивается снизу вверх вверх вниз на самом деле рекурсивные функции друг на дружку
[01:06:39.700 --> 01:06:46.380]  наслаиваться до тех пор пока не остановится понятно поэтому мне нужна рекурсия свайлом было
[01:06:46.380 --> 01:06:55.420]  бы немного неприятнее но можно прислать это на байл указатель на какую-то на какую-то
[01:06:55.420 --> 01:07:03.260]  ноду которая является корнем какого-то поддерево все поэтому я в начале буду балансировать 4 потом
[01:07:03.260 --> 01:07:14.180]  2 потом 0 согласны что время работы это уатаж правда как бы логично вы вот инсертами ходите
[01:07:14.180 --> 01:07:21.580]  туда сюда что касается удаления ключа удаление ключа аналогично тому что у нас с вами было мы
[01:07:21.580 --> 01:07:27.220]  берем минимум пытаемся его вставить куда нам нужно но что происходит балансировка в этот момент
[01:07:27.220 --> 01:07:36.260]  вопрос именно в этом то что у минимума а всего один ребенок я думаю вы это прекрасно понимаете
[01:07:36.260 --> 01:07:41.520]  если один ребенок то ну как бы удалил вставил вот там максимум изменилось на единичку нужно
[01:07:41.520 --> 01:07:49.240]  понять что с этим делать тогда в этом случае а если мы с вами говорим про поиск минимума то это
[01:07:49.240 --> 01:07:57.160]  просто вот ну как бы все также рекурсивно находится очень просто find минимумом до тех пор пока я не
[01:07:57.160 --> 01:08:06.280]  найду что слева у меня пусто то есть пока плф не пуст я минимум нахожу согласны друзья все вас
[01:08:06.280 --> 01:08:14.760]  под конец убила я понял все нормально дальше хуже что касается удаление узла удаление узла будет
[01:08:14.760 --> 01:08:24.120]  за собой подтягивать только одно я опять же здесь смотри смотрите remove mean я беру у конкретного
[01:08:24.120 --> 01:08:30.800]  под дерево буду брать то есть я к примеру пошел вот в этот кусочек искать минимум я по нему
[01:08:30.800 --> 01:08:36.720]  пойду здесь путем который происходит там как я еще минимум я просто иду вот так вот так вот так и
[01:08:36.720 --> 01:08:44.280]  дохожу до этого момента рекурсивно после чего я беру и балансирую все это дерево заново потому
[01:08:44.280 --> 01:08:50.040]  что я удалил один элемент структура дерева изменилась оно могло стать дисбалансным понятно
[01:08:50.040 --> 01:09:00.280]  поэтому я опять делу баланс по ок вот так я удаляю тот самый минимум ну а дальше просто удаление
[01:09:00.280 --> 01:09:07.280]  ключа но удаление ключа очень простая вещь здесь становится с точки зрения того что вы уже знаете
[01:09:07.280 --> 01:09:16.880]  про бинарное дерево поиска но грубо говоря если вы нашли на лптр но я буду возвращать 0 по факту
[01:09:16.880 --> 01:09:23.520]  это нулевой указатель можно писать ретер на лптр то есть не существует такой ну типа все закончили
[01:09:23.520 --> 01:09:31.600]  на лптр теперь все равно а дальше я смотрю что если я ну это если я не нашел это вершина
[01:09:31.600 --> 01:09:39.680]  которую удалить дальше я смотрю я пойду влево пойду вправо опять же рекурсивно видите ка меньше
[01:09:39.680 --> 01:09:49.520]  ключа ка больше ключа окей окей что же касается удаления вот самого удаления то есть когда
[01:09:49.520 --> 01:09:54.960]  мы нашли этот ключ когда мы нашли этот ключ я говорю что у меня есть левое по дерево есть правое
[01:09:54.960 --> 01:10:08.320]  по дерево вначале я точно удаляю это вершинку п окей просто беру и удаляю и говорю что если у
[01:10:08.320 --> 01:10:16.280]  меня справа на лптр то есть у меня нету справа ребенка есть только слева тогда я возвращаю
[01:10:16.280 --> 01:10:24.040]  левт и в принципе почти все хорошо почему потому что левт всего один он лист согласны
[01:10:24.040 --> 01:10:34.880]  то есть нам ничего не произойдет даже особо вот а дальше если это не так тогда я буду искать
[01:10:34.880 --> 01:10:42.680]  минимум справа по дерево у этого правого по дерево убирать этот минимум перебалансировать
[01:10:42.680 --> 01:10:51.800]  этот правый кусочек который у меня есть и сказать что у этой минимальной вершинки теперь левое
[01:10:51.800 --> 01:11:00.960]  под дерево равно левту минимум райт он равен рему в минимума почему потому что рему в минимум он
[01:11:00.960 --> 01:11:07.720]  удаляет эту вершину и перебалансирует все дерево согласны и возвращает корень этого кусочка если
[01:11:07.720 --> 01:11:14.920]  я делаю рему в минимум правого кусочка то он вернет мне корень этого кусочка ок то есть у меня
[01:11:14.920 --> 01:11:23.640]  минимум райт равен вот этому рему в минимум теперь левый ну минимум левого равен левому кусочку просто
[01:11:23.640 --> 01:11:35.320]  и все окей вот у меня произошло удаление судя по всему вы взгрустнули это грустно
[01:11:37.320 --> 01:11:44.360]  возможно есть проблему а мой вам совет пересмотрите презентацию в случае чего задайте мне вопросы к
[01:11:44.360 --> 01:11:57.200]  этому всему чатике вл с как хотите окей а да будет будет будет а в чатике базы базового потока время
[01:11:57.200 --> 01:12:06.600]  работы этого всего уатаж теперь мы приходим к самому забавному и интересному сколько это все работает
[01:12:06.600 --> 01:12:21.240]  ему равна высота смотрите для высоты нам нужны числа фибоначи а очевидно очевидно что в
[01:12:21.240 --> 01:12:32.320]  действительности вл дерево высоты аж содержит не менее чем ф аж плюс 3 минус одна вершинка где
[01:12:32.320 --> 01:12:39.000]  f это число фибоначи порядковая с аж плюс 3 f нулевой нулев от единички 1 в два это единичка и
[01:12:39.000 --> 01:12:44.680]  так далее вот существует такая теорема для доказательств этой теоремы существует два
[01:12:44.680 --> 01:12:48.720]  утверждения первое утверждение возможно вы сталкивались когда-нибудь что число фибоначи
[01:12:48.720 --> 01:12:55.040]  представим вот в таком вот виде с корнями из пяти а второе утверждение что вот это вот
[01:12:55.040 --> 01:13:07.080]  все отен по модуле не более чем единичка вот ну типа плюс минус пока хорошо правда то
[01:13:07.080 --> 01:13:15.880]  нормально чудесно как-то доказывает смотрите это доказывается индуктивно первое возьмем базу аж
[01:13:15.880 --> 01:13:23.480]  равно нулю все пусто или это одинокая вершина ну типа если одинокая аж равно единичке тогда в
[01:13:23.480 --> 01:13:30.640]  этом случае мы с вами должны сказать что не под аж плюс 3 а таж плюс 4 сорят тоже лагал чуть-чуть
[01:13:30.640 --> 01:13:36.920]  вот я говорю у меня иногда в одну сторону и в другую короче здесь аж на единицу меньше чем
[01:13:36.920 --> 01:13:43.760]  должен быть но не суть важна само доказательство важнее какой здесь будет переход переход будет
[01:13:43.760 --> 01:13:51.760]  следующий если дерево имеет высоту аж то 1 1 из его потомкам имеет высоту аж минус 1 согласны
[01:13:51.760 --> 01:14:02.320]  и потому он содержит не менее чем f от аж плюс 2 минус 1 вершинок ну это наше предположение индукция
[01:14:02.320 --> 01:14:11.760]  она должна работать согласны другой должен иметь высоту не менее чем аж минус 2 может он имеет
[01:14:11.760 --> 01:14:22.480]  больше но это неважно согласны может он имеет аж минус 1 также или что-то такое тогда он имеет
[01:14:22.480 --> 01:14:33.760]  не менее чем f от аж плюс одну вершинку ага окей ну да минус один всего с учетом корня мы с
[01:14:33.760 --> 01:14:41.480]  вами получаем что у нас есть корень 1 плюс f от аж плюс 2 минус 1 с одной стороны и f от аж плюс
[01:14:41.480 --> 01:14:47.240]  1 минус 1 с другой стороны согласны ну видите сумму двух чисел фибоначчо
[01:14:51.240 --> 01:14:58.160]  это количество это количество я говорю про количество количество вершин я суммирую
[01:14:58.160 --> 01:15:05.000]  получает два числа фибоначчо подряд правильно значит получает 3 f от аж плюс 3 согласны ну и
[01:15:05.000 --> 01:15:12.120]  один минус один минус один это минус один вот у меня получается что столько вершинок хорошая
[01:15:12.120 --> 01:15:19.240]  теория мы доказали согласны ну достаточно индуктивно просто какое из этого следствие
[01:15:19.240 --> 01:15:26.560]  этой теория мое следствие из этого всего что высота дерева это логарифм почему потому что
[01:15:26.560 --> 01:15:34.760]  если мы с вами говорим что а n у меня больше чем f аж плюс 3 минус 1 но больше либо равно хорошо
[01:15:34.760 --> 01:15:42.560]  не страшно окей больше либо равно тогда с учетом предыдущих двух утверждений которые у меня были
[01:15:42.560 --> 01:15:50.440]  здесь я могу сказать что n плюс 2 то есть я минус 1 перенес f и psi в степени n перенес
[01:15:50.440 --> 01:15:59.200]  окей понятно получая n плюс 2 оно больше чем один делить на корень из пяти фи в степени аж
[01:15:59.200 --> 01:16:11.440]  плюс 3 и вот вот это вот ага чудесно тогда если мы про логарифмируем все и там вот все чиселки
[01:16:11.440 --> 01:16:17.040]  подставим которые нам нужны в действительности мы получим что высота нашего дерева не более
[01:16:17.040 --> 01:16:25.280]  чем вот 1 точка 44 логарифм двоичная тен плюс 2 минус там 0 32 но в действительности важно что оно
[01:16:25.280 --> 01:16:34.400]  меньше чем логарифм высота согласны оно меньше чем высота это чудесно ой меньше чем логарифм значит
[01:16:34.400 --> 01:16:35.200]  мы уже говорим
