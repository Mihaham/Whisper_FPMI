[00:00.000 --> 00:09.280]  Так переходим к еще одной структуре. Судерева я оставил только на семинар,
[00:09.280 --> 00:13.320]  потому что они с автоматом очень похожи. Давайте попробуем в этот раз только с автоматом работать.
[00:13.320 --> 00:17.760]  Так, поднимите, пожалуйста, руки у кого сейчас есть курс формальных языков.
[00:17.760 --> 00:27.600]  Хорошо, спасибо. Ну, как я понимаю, он теперь не обязательный, поэтому я все равно должен
[00:27.600 --> 00:33.040]  буду вести всякие определения, но постараюсь по минимуму и больше на картинках.
[00:33.040 --> 00:39.280]  Значит, что такое вообще автомат? Мы будем говорить про детерминированный конечный автомат.
[00:39.280 --> 00:57.160]  По факту это просто граф с ребрами, со стрелочками, и на стрелочках написаны какие-то буквы.
[00:57.160 --> 01:06.680]  Что-нибудь вот такое, например. На каждом ребре будет написана какая-то буква,
[01:06.680 --> 01:17.640]  и какие-то вершины будут помешаны терминальными. Я буду вот такой вот
[01:17.640 --> 01:30.960]  штриховкой обозначать терминальные вершины. Формально, автомат – это граф ориентированный,
[01:30.960 --> 01:35.560]  где на ребрах написаны буквы. Причем, чтобы он был детерминированный, не может быть такого,
[01:35.560 --> 01:40.240]  что из вершины ведет два ребра с одинаковой меткой. То есть не бывает, так же, как у нас было в
[01:40.240 --> 01:45.920]  боре. Например, не бывает такого, что из вершины выходят два ребра с одинаковой меткой. Такое нам
[01:45.920 --> 01:50.840]  запрещено. Детерминированный в том плане, что если мы стоим в вершине, мне нужно прочитать букву,
[01:50.840 --> 01:57.680]  то я знаю, куда идти. Например, если приходит А, то я иду сюда, если приходит Б, то я иду сюда. А если
[01:57.680 --> 02:02.600]  приходит С, то мне идти некуда. Я сразу завершаюсь и говорю «все, вы меня просите прочитать слово,
[02:02.600 --> 02:07.040]  которого в автомате нет». Я сразу завершаюсь и говорю «дальше не иду». Если вот здесь меня просит
[02:07.040 --> 02:14.320]  прочитать С, я дальше не иду. Ну и, соответственно, пути ведущие из стартовой вершины. Вот есть
[02:14.320 --> 02:22.960]  какая-то стартовая вершина, тоже отдельно выделенная в автомате. Значит, пути ведущие из
[02:22.960 --> 02:28.080]  стартовой вершины в какую-либо терминальную соответствуют принимаемым словам. Например,
[02:28.080 --> 02:34.080]  можно прочитать АС попасть сюда, можно прочитать ББ попасть сюда, можно прочитать БА попасть сюда.
[02:34.080 --> 02:40.280]  Все эти слова, которые я могу прочитать на пути от старта до терминальной вершины,
[02:40.280 --> 02:58.560]  это принимаемые слова. На этом конкретном примере это будет АС, ББ и БА. Тот автомат,
[02:58.560 --> 03:08.200]  который мы будем строить, если цикл достижим из старта и из него достижим из терминальной,
[03:08.200 --> 03:16.360]  то да. Я еще нарисую картинку, но автомат, который мы будем строить в этот раз, он будет
[03:16.360 --> 03:22.920]  ациклический, поэтому на циклами не надо будет думать даже, что происходит с циклами. Но если
[03:22.920 --> 03:27.000]  они какие-то есть, в принципе, определение пока не противоречит. А может быть, например, что-то
[03:27.000 --> 03:37.880]  вот такое. Представьте себе. Вот, ну, какой-нибудь х. Да, например, вот это вот терминальное. Ну,
[03:37.880 --> 03:42.360]  еще что-нибудь, давайте вот это терминальное. Тогда, например, до этой вершинки можно дойти так.
[03:42.360 --> 03:55.800]  На вот этот вот старт можно, например, просчитать А, Б, Ц, Х. Можно просчитать А, Б, Ц, А. А можно
[03:55.800 --> 04:02.000]  прокрутиться по всему этому циклу и опять пройти по Ху. То есть, что тогда будет? Будет А, Б, Ц, А, Б,
[04:02.000 --> 04:07.760]  Б, Ц, Х. Вот все это принимаемые слова. Ну, их там, соответственно, будет даже бесконечно много,
[04:07.760 --> 04:11.680]  потому что раз есть цикл, то мы можем по нему сколько угодно раз пропетлять, да, и потом дойти
[04:11.680 --> 04:16.680]  до сюда, до терминальной. Вот, это все принимаемые. То есть, принимаемые слова — это в точной сети,
[04:16.680 --> 04:20.400]  которые соответствуют какому-то пути от старта до терминальной вершины. Это все принимаемые
[04:20.400 --> 04:32.600]  слова. Соответственно, отвергаемые — это все остальные. Отвергаемые слова. Все остальные. Это
[04:32.600 --> 04:38.560]  те, либо которые я вообще даже не могу просчитать в автомате, как, например, здесь А, Б, А. Я могу
[04:38.560 --> 04:43.520]  просчитать А, могу просчитать Б, но отсюда А я не вижу, я сразу здесь сломаюсь, говорю, все,
[04:43.520 --> 04:47.480]  дальше читать не могу, я слово отвергаю. То есть, если я из вершины пытаюсь просчитать букву,
[04:47.480 --> 04:52.800]  которой нет, по которой нет перехода, я говорю, что все слово отвергается. Ну, либо это слово,
[04:52.800 --> 04:57.840]  дошедшее просто до нетерминальной вершины, например, А, Б, Ц. Давайте примеры, значит, А, Б, А, А,
[04:57.840 --> 05:03.240]  Б, Ц. Они будут отвергаться. А, Б, А, потому что мы даже не можем его прочитать, А, Б, Ц просчитать
[05:03.240 --> 05:09.000]  можем, но заканчиваемся в нетерминальной вершине, значит, слово не непринимаемое, то есть отвергаемое.
[05:09.000 --> 05:18.960]  Окей? Концепция очень простая. Так, ну, вроде определил. Значит, да, повторяю, это неформальное
[05:18.960 --> 05:28.600]  определение. Вот на картинке нам такого хватит. Дальше. Значит, я скажу следующее, что если А — это
[05:28.600 --> 05:44.600]  автомат, то, ну, через L от А я буду обозначать множество всех принимаемых слов. Всех принимаемых
[05:44.600 --> 05:59.600]  им слов. Будем мы решать обратную задачу, мы, наоборот, хотим по языку построить автомат,
[05:59.600 --> 06:04.680]  потому что, ну, вот если автомат задан, то понятно, какие слова он принимает, какие не принимает.
[06:04.680 --> 06:09.840]  Будем решать обратную задачу, мы будем строить по языку какой-то автомат такой, что его язык
[06:09.840 --> 06:17.000]  совпадает в точности с L. Вот. Язык, уточню для тех, кому это непривычно, язык — это просто множество слов.
[06:17.000 --> 06:28.000]  А язык — это просто множество слов. Множество всех слов, которые наш автомат должен принимать. Так,
[06:28.000 --> 06:41.200]  хорошо. Значит, определение. Пустель — произвольный язык. Тогда через, ну, просто давайте, значит, такое
[06:41.200 --> 06:55.840]  обозначение RL от X — это все такие Y, что X конкретонация Y принадлежит L. И это я буду называть правым
[06:55.840 --> 07:10.560]  контекстом X относительно L. Правый контекст X относительно L. То есть, вот есть какое-то слово X,
[07:10.560 --> 07:18.880]  тогда в его правом контексте лежат все его дополнения до какого-то слова из L.
[07:18.880 --> 07:36.200]  Да, да, да. Тогда что будет? Ой. А, я понял, я понял вас, да. Да, это правда. У нас, конечно, все конечное,
[07:36.200 --> 07:40.200]  мы же алгоритмисты, у нас вообще все всегда конечное. Вот. Значит, это все возможные способы,
[07:40.200 --> 07:47.600]  как можно слово дополнить, чем можно слово дополнить справа, чтобы это слово лежало в языке L. Называется
[07:47.600 --> 07:53.440]  правый контекст. Значит, пример. Когда вы у себя в среде разработки что-нибудь там печатаете,
[07:53.440 --> 07:58.120]  какую-нибудь функцию, пытаетесь вызвать, например, встроенную или ту, которую вы уже напечатали,
[07:58.120 --> 08:02.440]  вы обычно несколько первых букв печатаете, и потом вам вылазит такое окошко, где написано,
[08:02.440 --> 08:06.800]  как можно продолжить, да, как бы, ну, чем можно завершить до того, что уже есть. Вот представьте,
[08:06.800 --> 08:12.480]  что L — это, как бы, пространство всех имен, которые есть в программе, и именно, что среда
[08:12.480 --> 08:17.280]  разработки вам подсказывает, как можно дополнить до слова из языка. Вот, вот ровно оно. Да, это все
[08:17.280 --> 08:23.080]  доступные команды. Вы уже что-то ввели, вопрос, как можно дозакончиться до какого-то слова из языка.
[08:23.080 --> 08:29.760]  Вот. Значит, это называется правый контекст, да, как бы, как можно справа дополнить до элемента из L.
[08:29.760 --> 08:41.480]  Значит, дальше пустель язык. Значит, тогда вводим отношение эквивалентности, говорим, что x L
[08:41.480 --> 08:49.360]  эквивалентно y, ну, либо тильдочка с нижними nxml, либо я скоро буду просто писать без L,
[08:49.360 --> 08:54.640]  а вот так буду просто писать. Ну, пока давайте так обозначим. Значит, если у них одинаковые правые
[08:54.640 --> 09:05.640]  контексты. Два слова эквивалентны, если они одинаковы с точки зрения дополнений справа. Понятно,
[09:05.640 --> 09:09.480]  что это отношение эквивалентности, потому что оно порождено отношением эквивалентности, да,
[09:09.480 --> 09:14.400]  ну, по факту он просто задается равенством. Это очевидно отношение эквивалентности. Вот.
[09:14.400 --> 09:30.800]  Значит, ну, есть такая теорема Махилла Нероуда. Ну, давайте я ее в урезанной версии напишу. Значит,
[09:30.800 --> 09:50.360]  я скажу так, что минимальный автомат, принимающий L, принимающий L, имеет ровно столько состояний,
[09:50.520 --> 10:04.760]  столько вершин, ровно столько вершин, сколько классов эквивалентности относительно вот этого l,
[10:04.760 --> 10:14.500]  вот классов эквивалентности по этому отношению. Значит, сколько есть классов эквивалентности
[10:14.500 --> 10:19.500]  по введенному только что отношению тильда.
[10:19.500 --> 10:23.500]  Так, это знакомо?
[10:23.500 --> 10:27.500]  Тем, у кого были... Ага, вы и до этого еще не дошли.
[10:27.500 --> 10:30.500]  А что же там делать, интересно, ну ладно.
[10:30.500 --> 10:32.500]  Скоро будет у вас такая телем, значит.
[10:32.500 --> 10:34.500]  У кого есть формалки.
[10:34.500 --> 10:37.500]  То есть, вот это отношение,
[10:37.500 --> 10:41.500]  оно в каком-то смысле задает в точности вершины автомата.
[10:41.500 --> 10:45.500]  Минимальные, здесь я имею в виду, минимальные поочисла вершин.
[10:45.500 --> 10:48.500]  Поочисла вершин.
[10:50.500 --> 10:53.500]  Вот. То есть, на самом деле,
[10:53.500 --> 10:56.500]  минимальность числа вершин достигается ровно в том случае,
[10:56.500 --> 11:00.500]  когда у вас состояниями автомата, вот этими вот вершинами,
[11:00.500 --> 11:05.500]  выступают в точности класса эквалентности по вот этой вот тильде.
[11:05.500 --> 11:08.500]  Вот, это теорема Махилни Роуд.
[11:08.500 --> 11:11.500]  Доказывается, на самом деле, очень просто.
[11:11.500 --> 11:14.500]  Но мы не будем ее доказывать.
[11:14.500 --> 11:17.500]  Нам это не надо.
[11:27.500 --> 11:30.500]  Но мы из нее понимаем следующее.
[11:30.500 --> 11:35.500]  Следствие, что если мы хотим строить какой-то минимальный автомат для какого-то языка,
[11:35.500 --> 11:38.500]  то нам вот, как я уже сказал, нужно в качестве вершин
[11:38.500 --> 11:43.500]  рассматривать классы эквалентности по отношению тильда.
[11:43.500 --> 11:46.500]  В качестве вершин
[11:49.500 --> 11:52.500]  в минимальном автомате
[11:54.500 --> 11:57.500]  выступают
[11:58.500 --> 12:01.500]  классы эквалентности.
[12:05.500 --> 12:08.500]  Вступают классы эквалентности. То есть, вершина,
[12:08.500 --> 12:11.500]  это будет на самом деле классы эквалентности.
[12:11.500 --> 12:14.500]  Ну, соответствовать будет классы эквалентности, да.
[12:17.500 --> 12:20.500]  Конечно, конечно, да. То есть, у нас есть язык.
[12:20.500 --> 12:24.500]  Мы хотим в точности по нему построить автомат, который принимает слова из L и только их.
[12:24.500 --> 12:27.500]  Все остальные отвергают.
[12:27.500 --> 12:30.500]  Так. Ну, давайте в простую сторону это докажем.
[12:30.500 --> 12:33.500]  Почему это верно?
[12:33.500 --> 12:36.500]  Ну, типа доказательства не знаю.
[12:36.500 --> 12:39.500]  Да, вот давайте, например, посмотрим на два слова, которые эквалентны друг другу.
[12:39.500 --> 12:42.500]  Пусть X эквалентна Y.
[12:44.500 --> 12:47.500]  Есть ли им какой-то смысл быть в разных вершинах?
[12:47.500 --> 12:51.500]  То есть, может ли быть такое, что из старта при прочтении X я попадаю в одну вершину,
[12:51.500 --> 12:54.500]  а при прочтении Y попадаю в другую вершину?
[12:54.500 --> 12:57.500]  Есть ли какой-то смысл им быть различными?
[12:57.500 --> 13:02.500]  Вот я утверждаю, что нет, потому что, раз они эквивалентны с точки зрения вот этой тильды,
[13:02.500 --> 13:06.500]  значит, все их продолжения до слова из L,
[13:06.500 --> 13:10.500]  то есть, все возможные их пути до терминальной вершины одинаковые.
[13:10.500 --> 13:13.500]  То есть, если отсюда есть какой-то путь до терминала, значит,
[13:13.500 --> 13:17.500]  и здесь есть точно такой же длины, из таких же символов состоящих,
[13:17.500 --> 13:19.500]  потому что у них одинаковые правые контексты.
[13:19.500 --> 13:23.500]  То есть, их поведение вперед, при продолжении, оно одинаковое.
[13:23.500 --> 13:26.500]  Поэтому я могу просто смело склеить эти две вершины.
[13:26.500 --> 13:30.500]  Ну и вот эти все возможные ветвления склеить тоже в...
[13:33.500 --> 13:36.500]  Ну просто склеить и сделать, чтобы не было повторений.
[13:36.500 --> 13:39.500]  То есть, я могу вершины склеить, если они эквивалентны. Понятно?
[13:39.500 --> 13:42.500]  Потому что как раз продолжения, вот эти все возможные пути,
[13:42.500 --> 13:45.500]  дополняющие до слова из L, то есть до терминальной вершины,
[13:45.500 --> 13:48.500]  они у них одинаковые, поэтому можно вершины склеить всегда.
[13:48.500 --> 13:52.500]  Потому что с точки зрения остатка графа, с точки зрения достижимости, они будут эквивалентны.
[13:52.500 --> 13:54.500]  Значит, их можно склеить.
[13:55.500 --> 13:56.500]  Вот.
[13:56.500 --> 13:58.500]  Но это мы доказали, видимо, что...
[14:00.500 --> 14:01.500]  Что?
[14:01.500 --> 14:03.500]  Что вершин не больше, чем классы эквивалентности, правильно?
[14:03.500 --> 14:05.500]  Потому что эквивалентные слова можно склеить,
[14:05.500 --> 14:07.500]  значит, вершин не больше, чем классы эквивалентности.
[14:07.500 --> 14:10.500]  Ну и легко показать, что если слова не эквивалентны,
[14:10.500 --> 14:13.500]  то они не могут быть в одной вершине.
[14:13.500 --> 14:18.500]  Не может быть такого, что у вас х, давайте там, у, не эквивалентно у.
[14:19.500 --> 14:22.500]  Тогда не может быть такое, что вы, прочитав...
[14:22.500 --> 14:23.500]  Продон.
[14:23.500 --> 14:24.500]  У не эквивалентно в.
[14:24.500 --> 14:27.500]  Не может быть такое, что, прочитав из старта у и в, вы пришли в одну вершину.
[14:27.500 --> 14:29.500]  Потому что раз они не эквивалентны,
[14:29.500 --> 14:31.500]  ну значит, они должны как-то различаться.
[14:31.500 --> 14:34.500]  Значит, из у должен быть какой-то путь до терминала,
[14:34.500 --> 14:35.500]  которого нет в.
[14:35.500 --> 14:38.500]  Но раз вы их склеили, вы не можете их уже отличить друг от друга.
[14:38.500 --> 14:39.500]  Они для вас одинаковые.
[14:39.500 --> 14:41.500]  С точки зрения правого контекста,
[14:41.500 --> 14:44.500]  с точки зрения продолжения до терминалов, они одинаковые.
[14:44.500 --> 14:46.500]  Поэтому не могут различаться.
[14:47.500 --> 14:50.500]  Ну значит, вроде мы доказали, что
[14:50.500 --> 14:53.500]  одинаковые слова, то есть, эквивалентные слова,
[14:53.500 --> 14:56.500]  можно склеить вершинки, а разные склеить нельзя.
[14:56.500 --> 14:59.500]  Ну, поэтому, как бы, число класса эквивалентности в точности число вершин.
[14:59.500 --> 15:00.500]  Да.
[15:00.500 --> 15:02.500]  Да, есть каких слов?
[15:02.500 --> 15:04.500]  Есть слов, ну...
[15:04.500 --> 15:06.500]  Ну, есть слов языка только, но в плане...
[15:06.500 --> 15:08.500]  Нет, вообще...
[15:08.500 --> 15:09.500]  Сейчас.
[15:09.500 --> 15:12.500]  Ну, вообще говоря, вот в этой общей теории вообще, вообще,
[15:12.500 --> 15:13.500]  из всех слов сигма звездочки.
[15:13.500 --> 15:15.500]  То есть, есть какой-то объемлющий алфавит.
[15:15.500 --> 15:16.500]  Сигма.
[15:16.500 --> 15:18.500]  Да, мы рассматриваем, как бы, ну вот, х и у,
[15:18.500 --> 15:20.500]  и у, это все были элементы сигма звездочки.
[15:23.500 --> 15:24.500]  Да.
[15:25.500 --> 15:27.500]  Да, какое-то слово просто.
[15:27.500 --> 15:29.500]  Какой-то набор символов.
[15:30.500 --> 15:32.500]  Это в общем случае, да.
[15:37.500 --> 15:39.500]  Ну, для префиксов слов из языка вы имеете ввиду.
[15:39.500 --> 15:41.500]  Это хорошее замечание, мы сейчас ровно к этому перейдем.
[15:41.500 --> 15:43.500]  Скажу так, что в общей теории,
[15:44.500 --> 15:45.500]  это, ну как бы,
[15:46.500 --> 15:47.500]  не уточняется.
[15:47.500 --> 15:49.500]  То есть, мы для всех вообще слов рассматриваем.
[15:49.500 --> 15:50.500]  Да.
[15:50.500 --> 15:53.500]  Возможно, скажем, если х не является префиксом никакого слова,
[15:53.500 --> 15:55.500]  возможно, у него пустой правый контекст.
[15:55.500 --> 15:57.500]  Да, р или от х равно пустого множества.
[15:57.500 --> 15:58.500]  Такие слова тоже есть.
[15:58.500 --> 15:59.500]  Как бы, в общем случае, да.
[15:59.500 --> 16:01.500]  И именно эта теорема, она работает именно в случае,
[16:01.500 --> 16:03.500]  когда у вас есть такой кла...
[16:03.500 --> 16:05.500]  Ну, как бы, разрешены такие классы.
[16:05.500 --> 16:09.500]  Поэтому, в общем случае, х и у могут быть даже не префиксом никакого слова.
[16:09.500 --> 16:11.500]  У них могут быть пустые правые контексты.
[16:11.500 --> 16:13.500]  Но вот мы сейчас перейдем к рассмотрению
[16:13.500 --> 16:16.500]  только хороших слов, которые продолжаются хоть как-то.
[16:16.500 --> 16:18.500]  Это пока было в общем случае.
[16:20.500 --> 16:21.500]  Так.
[16:29.500 --> 16:30.500]  Не-не-не.
[16:30.500 --> 16:33.500]  Вот она как раз работает, если вообще все рассматривать.
[16:33.500 --> 16:35.500]  А мы один класс уберем, у нас станет меньше.
[16:38.500 --> 16:40.500]  Ну, потому что вот здесь, вот в этой теореме,
[16:40.500 --> 16:42.500]  на самом деле подразумевается, что у вас автомат полный.
[16:45.500 --> 16:47.500]  Ну, я не хочу это проговаривать, чтобы никого не путать,
[16:47.500 --> 16:49.500]  если кто-то не поймет просто.
[16:50.500 --> 16:51.500]  А?
[16:52.500 --> 16:53.500]  Да.
[16:55.500 --> 16:56.500]  Да.
[16:58.500 --> 17:00.500]  Давайте скепнем, пожалуйста.
[17:03.500 --> 17:04.500]  Вот.
[17:04.500 --> 17:06.500]  Значит, смотрите, с этого момента, давайте,
[17:06.500 --> 17:09.500]  раз мы вот про это как раз вы почувствовали,
[17:09.500 --> 17:11.500]  что здесь что-то не так, давайте я сразу скажу,
[17:11.500 --> 17:14.500]  что пусть L у нас будет множество всех суффиксов
[17:14.500 --> 17:16.500]  какой-то фиксированной строки.
[17:17.500 --> 17:23.500]  Множество всех суффиксов строки S.
[17:27.500 --> 17:29.500]  И я буду хотеть строить автомат,
[17:29.500 --> 17:32.500]  принимающий в точности только суффиксы S.
[17:34.500 --> 17:36.500]  Вот есть какая-то строка, я по ней построил L,
[17:36.500 --> 17:38.500]  как множество всех суффиксов.
[17:39.500 --> 17:42.500]  И хочу строить автомат, распознающий только суффикс L.
[17:43.500 --> 17:44.500]  Вот.
[17:44.500 --> 17:47.500]  И здесь я сразу говорю, давайте отныне
[17:49.500 --> 17:51.500]  не будем рассматривать
[17:56.500 --> 17:57.500]  строки,
[17:59.500 --> 18:01.500]  не являющиеся под строками S.
[18:09.500 --> 18:11.500]  Потому что, если X это не под строка S,
[18:11.500 --> 18:14.500]  то ее невозможно добить до суффикса S справа,
[18:14.500 --> 18:16.500]  нельзя к ней ничего приписать, чтобы получить суффикс,
[18:17.500 --> 18:19.500]  и значит, у нее пустой правый контекст.
[18:19.500 --> 18:21.500]  Если X это не под строка S,
[18:23.500 --> 18:27.500]  на самом деле это верно, если и только если у нее пустой правый контекст.
[18:29.500 --> 18:31.500]  То есть ее никак нельзя добить до суффикса,
[18:31.500 --> 18:34.500]  ровно в том случае, когда она не под строка.
[18:35.500 --> 18:36.500]  Вот.
[18:36.500 --> 18:37.500]  Поэтому давайте мы такие строки выкинем.
[18:37.500 --> 18:40.500]  Это вот как раз те случаи, когда я пытаюсь читать что-то в автомате,
[18:40.500 --> 18:43.500]  и в какой-то момент пытаюсь читать несуществующий символ.
[18:43.500 --> 18:45.500]  Вот как было на картинке, я прочитал, прочитал,
[18:45.500 --> 18:47.500]  потом из вершины пытаюсь читать что-то, чего нет.
[18:48.500 --> 18:50.500]  Это как раз соответствует тому, что мы не под строка.
[18:50.500 --> 18:51.500]  То есть я пытаюсь прочитать символ,
[18:52.500 --> 18:54.500]  ну, такой, что вот такой по строке нет просто у меня в строке.
[18:55.500 --> 18:56.500]  S.
[18:57.500 --> 18:59.500]  Вообще говоря, вот как раз в этой общей теореме
[18:59.500 --> 19:01.500]  для таких товарищей нужна была бы отдельная вершинка,
[19:02.500 --> 19:04.500]  куда бы я переходил, как только понимал, что
[19:04.500 --> 19:10.300]  что у меня плохое слово, мне нужно перейти в слово с пустым классом эквалентности.
[19:10.300 --> 19:16.700]  Но, поскольку я их дропаю, то есть я избавляюсь от этого класса и у меня станет на одну вершинку поменьше.
[19:16.700 --> 19:17.700]  Да.
[19:17.700 --> 19:22.700]  А у нас, если строчка не дает пустой, то у меня там контекст, пустой или пустой?
[19:22.700 --> 19:24.700]  Как минимум пустое слово там есть?
[19:24.700 --> 19:25.700]  Да.
[19:25.700 --> 19:27.700]  Да, давайте пример.
[19:27.700 --> 19:33.700]  Если я напишу строчку abc ab, чему равен правый контекст строки ab?
[19:33.900 --> 19:36.900]  Во-первых, епсилон, во-вторых, cab.
[19:38.900 --> 19:41.900]  То есть, раз она суфикс, то епсилон всегда подходит.
[19:41.900 --> 19:45.900]  Да, можно приписать пустое слово, то есть ничего не приписываешь, чтобы получить суфикс.
[19:45.900 --> 19:46.900]  Либо можно написать вот это.
[19:46.900 --> 19:51.900]  Ну, в случае, если эта строка еще где-то входит, мы получаем еще какое-то другое дополнение до конца.
[19:53.900 --> 19:54.900]  Вот.
[19:54.900 --> 19:59.900]  Ну, а, например, если бы мы взяли что-нибудь типа, там, не знаю, cb, мы бы взяли пустое множество.
[19:59.900 --> 20:00.900]  Вот.
[20:00.900 --> 20:02.900]  И такие слова мы не хотим рассматривать, но это в точности не под строка.
[20:03.100 --> 20:04.100]  Мы такие не рассматриваем.
[20:05.100 --> 20:07.100]  Не рассматриваем, так как это не под строка.
[20:09.100 --> 20:10.100]  Вот.
[20:22.100 --> 20:27.100]  Значит, тогда как будет выглядеть наш автомат?
[20:27.300 --> 20:30.300]  Как выглядит это, собственно, и будет суфиксный автомат, да?
[20:30.300 --> 20:32.300]  Суфиксный автомат строки s.
[20:37.300 --> 20:42.300]  То есть, минимальный автомат, принимающий в точности все ее суффиксы.
[20:49.300 --> 20:51.300]  Принимающий в точности суффиксы s.
[20:51.500 --> 20:53.500]  Принимающий в точности суффиксы s.
[21:00.500 --> 21:01.500]  Да, в точности.
[21:01.500 --> 21:03.500]  Да, суффиксы и только их.
[21:04.500 --> 21:05.500]  Вот.
[21:05.500 --> 21:07.500]  Ну, с вершинами мы уже разобрались.
[21:07.500 --> 21:11.500]  Мы поняли, что в минимальном автомате вершины это в точности класса эквивалентности.
[21:13.500 --> 21:16.500]  Поэтому вершины соответствуют однозначно классам эквивалентности.
[21:16.700 --> 21:18.700]  Значит, если я научусь находить классы эквивалентности,
[21:18.700 --> 21:21.700]  я, по крайней мере, знаю, сколько вершин в моем автомате.
[21:21.700 --> 21:23.700]  Теперь, что происходит с ребрами?
[21:23.700 --> 21:25.700]  Нас с переходами.
[21:27.700 --> 21:28.700]  Так.
[21:28.700 --> 21:30.700]  Ну, надо разбираться.
[21:30.700 --> 21:32.700]  Давайте я пока оставлю это под вопросом.
[21:32.700 --> 21:35.700]  Пока мне нужно какие-то свойства автомата вообще понять,
[21:35.700 --> 21:39.700]  как устроен класс эквивалентности и так далее.
[21:39.700 --> 21:41.700]  Давайте пока это оставим.
[21:41.700 --> 21:43.700]  Потом к этому вернемся.
[21:43.900 --> 21:45.900]  Так, пара простых утверждений.
[21:45.900 --> 21:46.900]  Не буду нумеровать.
[21:46.900 --> 21:47.900]  Значит, утверждения.
[21:47.900 --> 21:53.900]  Пусть для двух строк у и в их правые контексты внезапно совпали.
[21:57.900 --> 22:00.900]  Тогда скажите, пожалуйста, что можно сказать про соотношение у и в.
[22:03.900 --> 22:04.900]  Ну, я не знаю.
[22:04.900 --> 22:05.900]  Я не знаю.
[22:05.900 --> 22:06.900]  Я не знаю.
[22:06.900 --> 22:07.900]  Я не знаю.
[22:07.900 --> 22:08.900]  Я не знаю.
[22:08.900 --> 22:09.900]  Я не знаю.
[22:09.900 --> 22:10.900]  Я не знаю.
[22:11.100 --> 22:13.100]  Что можно сказать про соотношение у и в?
[22:21.100 --> 22:22.100]  Ну, эквивалентность понятна.
[22:22.100 --> 22:23.100]  Это не утверждение.
[22:23.100 --> 22:24.100]  Это определение тогда.
[22:24.100 --> 22:26.100]  Что можно еще про них сказать с точки зрения?
[22:26.100 --> 22:27.100]  Ну, вот все.
[22:27.100 --> 22:28.100]  Теперь L это набор суффиксов.
[22:28.100 --> 22:29.100]  Строки S.
[22:29.100 --> 22:31.100]  Что можно сказать, как они соотносятся?
[22:31.100 --> 22:33.100]  А более точно?
[22:33.100 --> 22:35.100]  Одно под строка другого.
[22:35.100 --> 22:36.100]  А более точно?
[22:36.100 --> 22:37.100]  Суффикс другого.
[22:37.300 --> 22:44.300]  Тогда либо у это суффикс v, либо v это суффиксу.
[22:47.300 --> 22:48.300]  Доказательство.
[22:48.300 --> 22:49.300]  Очень простое.
[22:50.300 --> 22:53.300]  Поскольку мы рассматриваем только под слова S, только
[22:53.300 --> 22:55.700]  под строки S, я сказал, вот отныне я не рассматриваю
[22:55.700 --> 22:56.700]  ни под строки.
[22:56.700 --> 22:58.700]  Я рассматриваю только какие-то под строки.
[22:59.700 --> 23:02.700]  Причем я знаю, что у и в это под строки S, у них одинаковые
[23:02.700 --> 23:03.700]  правые контексты.
[23:04.300 --> 23:08.300]  Полезно понимать, полезно думать о правом контексте
[23:08.300 --> 23:12.300]  в терминах вхождений.
[23:12.300 --> 23:14.300]  Потому что, по факту, что такое элементы правого
[23:14.300 --> 23:15.300]  контекста?
[23:15.300 --> 23:16.300]  Вот r от u это что такое?
[23:16.300 --> 23:18.300]  Это все такие дополнения до суффикса.
[23:21.300 --> 23:26.300]  В этом плане r задает в точности множество вхождений,
[23:26.300 --> 23:28.300]  позиции всех вхождений вот этого слова.
[23:28.300 --> 23:30.300]  Потому что, что такое дополнение до суффикса?
[23:30.300 --> 23:32.500]  Значит, вот где-то есть u, и если я вот это вот допишу
[23:32.500 --> 23:34.500]  до конца, то у меня получил суффикс.
[23:34.500 --> 23:37.500]  Дальше, если есть какой-то другой элемент правого контекста,
[23:37.500 --> 23:39.500]  то вот у меня было u, я еще что-то дописал, получил
[23:39.500 --> 23:40.500]  суффикс.
[23:40.500 --> 23:42.500]  То есть r в точности описывает на самом деле множество вхождений.
[23:44.500 --> 23:46.500]  Окей, причем они равны.
[23:46.500 --> 23:47.500]  Что это значит?
[23:47.500 --> 23:48.500]  Значит, есть какое-то слово, вот есть какой-то конкретный
[23:48.500 --> 23:52.500]  элемент, давай скажем, w, лежащий одновременно в r от
[23:52.500 --> 23:54.500]  u и в r от v.
[23:54.500 --> 23:55.500]  Что это такое?
[23:55.500 --> 23:58.500]  Значит, вот есть какой-то суффикс w, такой, что перед
[23:58.500 --> 24:03.500]  ним в нашей строке встречается u.
[24:03.500 --> 24:06.500]  Да, ну это в точности определение того, что w лежит в правом
[24:06.500 --> 24:08.500]  контексте u.
[24:08.500 --> 24:10.500]  Значит, у меня вот такая картинка, что s выглядит так,
[24:10.500 --> 24:12.500]  она заканчивается на uw.
[24:12.500 --> 24:16.500]  С другой стороны, то же самое w лежит в r от v.
[24:16.500 --> 24:19.500]  Значит, вот опять же, здесь же заканчивается очередное
[24:19.500 --> 24:20.500]  вхождение v.
[24:20.500 --> 24:24.500]  Поэтому v либо какое-то вот такое, либо какое-то вот такое.
[24:24.500 --> 24:27.500]  Поэтому очевидно одно суффикс другого.
[24:27.500 --> 24:28.500]  Согласны?
[24:30.500 --> 24:31.500]  Хорошо.
[24:43.500 --> 24:44.500]  Суждение следующее.
[24:47.500 --> 24:49.500]  Пусть c какой-то классик эволюционности.
[24:57.500 --> 25:12.500]  Тогда существует такое u, такая строка u, что c это в точности
[25:12.500 --> 25:14.500]  u и несколько ее самых длинных суффиксов.
[25:27.500 --> 25:38.500]  То есть, если я рассматриваю классик эволюционности и
[25:38.500 --> 25:41.500]  изучаю все слова, которые в нем лежат.
[25:41.500 --> 25:43.500]  Вот, например, классик эволюционности – это слова, у которых
[25:43.500 --> 25:45.500]  одинаковый правый контекст.
[25:45.500 --> 25:47.500]  Я рассматриваю слова с каким-то фиксированным правым
[25:47.500 --> 25:50.500]  контекстом, они образуют некие классики эволюционности.
[25:50.500 --> 25:52.500]  Так вот, я утверждаю, что его структура такая.
[25:52.500 --> 25:55.500]  Есть какая-то самая длинная в этом классе строка u,
[25:55.500 --> 25:58.500]  а потом несколько ее суффиксов в порядке убывания
[25:58.500 --> 25:59.500]  времени на один.
[25:59.500 --> 26:02.500]  То есть, второй по максимальности, дальше третий по максимальности,
[26:02.500 --> 26:05.500]  четвертый, ну и так далее, вплоть до какого-то.
[26:05.500 --> 26:07.500]  И на этом класс заканчивается.
[26:07.500 --> 26:08.500]  Вот это вот c.
[26:08.500 --> 26:11.500]  То есть, что есть такая самая длинная в этом классе строка,
[26:11.500 --> 26:14.500]  что все остальные получаются отбрасыванием от нее
[26:14.500 --> 26:15.500]  самого левого символа.
[26:15.500 --> 26:17.500]  Ну, вплоть до какого-то момента.
[26:17.500 --> 26:21.500]  Я тоже, что любой c выглядит ровно так.
[26:21.500 --> 26:22.500]  Ну, почему это так?
[26:22.500 --> 26:24.500]  Во-первых, легко заметить, что в одном классе не может
[26:24.500 --> 26:26.500]  быть двух строк равной длины.
[26:26.500 --> 26:33.500]  Ну, значит, не может быть двух строк равной длины.
[26:38.500 --> 26:40.500]  Ну, потому что мы доказали, что если у двух строк
[26:40.500 --> 26:43.500]  одинаковый класс эквивалентности, да, вот предыдущее утверждение,
[26:43.500 --> 26:46.500]  если у двух строк одинаковый класс, то одно суффикс другого.
[26:46.500 --> 26:48.500]  Ну, значит, они не могут иметь одинаковую длину.
[26:48.500 --> 26:50.500]  Один точно короче, чем другой.
[26:51.500 --> 26:53.500]  Значит, длины всех строк различны.
[26:53.500 --> 26:56.500]  Хорошо, давай тогда определим у как самую длинную.
[26:56.500 --> 26:59.500]  Значит, пусть у самая длинная строка в c.
[27:05.500 --> 27:08.500]  Ну, а давайте скажем, что v самая короткая.
[27:08.500 --> 27:13.500]  Во-первых, очевидно, что v и все остальные строки, лежащие в этом классе,
[27:13.500 --> 27:15.500]  они конечно суффиксы u.
[27:15.500 --> 27:21.500]  По предыдущему утверждению, что если две строки эквивалентны,
[27:21.500 --> 27:22.500]  то одна суффикс другого.
[27:22.500 --> 27:24.500]  Раз это самая длинная, то все суффиксы u.
[27:24.500 --> 27:28.500]  То есть все строки, лежащие в c, точно суффиксы u.
[27:28.500 --> 27:32.500]  Ну, значит, у всех у всех строк, лежащих в u,
[27:32.500 --> 27:35.500]  все у всех строк, лежащих в c, точно суффиксы u.
[27:35.500 --> 27:41.580]  в С, точные суффиксы У. Вот. Ну, значит, вот это В тоже в частности, конечно. И теперь единственное,
[27:41.580 --> 27:47.020]  что мне осталось доказать, это что именно вот здесь вот все суффиксы непрерывно идут. То есть,
[27:47.020 --> 27:52.500]  если есть В, самое короткое, то между ними получается все суффиксы длины от У до В. То есть,
[27:52.500 --> 27:57.740]  именно вот, ну, не бывает такого, что есть какие-то пропуски. Скажем, не знаю, здесь длина 10, 9, 8, 7, 6, 5,
[27:57.740 --> 28:01.380]  не может быть такого, что какая-то из них пропущена. Не может не быть какого-то суффикс.
[28:01.380 --> 28:12.460]  Надо достаточно показать, что все суффиксы, ну, что все суффиксы длины хотя бы такой,
[28:12.460 --> 28:22.460]  лежат в этом же классе. Все суффиксы У длины хотя бы такой, как УВ, лежат в С.
[28:22.540 --> 28:41.540]  Тем самым мы утверждение полностью докажем. Ну, это несложно. Пусть ВВ какой-то вот этот
[28:41.540 --> 28:48.620]  промежуточный суффикс. Ну, не так, да? То есть, пусть ВВ это какая-то строка, какой-то суффикс У,
[28:48.620 --> 28:58.820]  длины хотя бы В. Давайте докажем, что он в этом классе лежит. Пусть ВВ это суффикс У, причем его
[28:58.820 --> 29:06.900]  длина хотя бы такая, как УВ. Давайте докажем, что он лежит в этом классе. Вот, то есть, картинка такая,
[29:06.900 --> 29:12.380]  есть какая-то длинная У, есть более короткий его суффикс ВВ и есть самый короткий суффикс В.
[29:12.380 --> 29:25.860]  Тогда давайте заметим следующее. Давайте заметим, что РЛ от В содержит в себе РЛ от В и содержит в себе
[29:25.860 --> 29:37.100]  РАТУ. Почему? Ну, потому что, повторю, правый контекст в каком-то смысле задает множество всех
[29:37.100 --> 29:45.980]  вхождений строки. Понятное дело, что у В вхождений только больше, чем у В и еще больше, чем у У. Да, ну,
[29:45.980 --> 29:50.740]  или там более формально. Почему правый контекст В содержит целиком правый контекст ВВ? Потому что,
[29:50.740 --> 29:57.580]  если внезапно где-то в моей длинной строке С я увидел В в правом контексте, в котором лежит
[29:57.580 --> 30:04.260]  какой-то Х, то, очевидно, вот здесь же я получил В и Х. То есть, если Х лежала в правом контексте В,
[30:04.260 --> 30:09.900]  то оно же лежит в правом контексте В. Ну, очевидно, да? То есть, если я укорачиваю строчку,
[30:09.900 --> 30:14.100]  ну, перехожу к суффиксу строки, то правый контекст может только вырасти, потому что все,
[30:14.100 --> 30:18.940]  что было раньше, оно остается в правом контексте. Значит, верна такая цепочка вложений, но поскольку
[30:18.940 --> 30:23.940]  мы знаем, что R от В равно R от У, а они же в одном классе, значит, у них одинаковые контексты,
[30:24.020 --> 30:44.380]  значит, здесь они тоже все одинаковые, значит, В тоже в классе. Согласны? Чудно. Так, ну тогда я
[30:44.380 --> 30:55.580]  могу записать, что такое рёбра в нашем автомате. Значит, рёбра у меня выглядит следующим образом.
[30:55.580 --> 31:01.740]  Ну, давайте я буду писать, откуда, куда и какая метка на этом ребре. Значит, рёбра – это все такие
[31:01.740 --> 31:10.020]  тройки С1, С2, Д, где С1, С2 – это классы, а Д – это символ. Значит, давайте напишу, что это классы. Это
[31:10.020 --> 31:27.460]  какой-то символ алфавита. Если существует у из С1 такое, что у Д лежит в С2. Вот. Очень естественное
[31:27.460 --> 31:31.260]  определение, потому что, смотрите, что такое ребро из… Вот как бы у меня есть один класс,
[31:31.260 --> 31:39.020]  одна вершинка. И с другой класс, вторая вершинка. Я провожу ребро Д между ними. Если вот здесь
[31:39.020 --> 31:45.660]  есть какое-то слово у, продолжающиеся буквой Д вот сюда. Ну, весьма естественно, да? Потому что
[31:45.660 --> 31:52.780]  что такое у из С1? Это значит, что я мог из стартовой вершинки, прочитав у, попасть в С1. А вот,
[31:52.780 --> 31:58.740]  прочитывая у, я попадаю в С1. И мне что нужно? Я хочу теперь у2 прочитать с помощью С2. То есть,
[31:58.740 --> 32:04.980]  прочитав у2, попасть в С2. Но я просто провожу такое ребро, попадаю в точность в С2. Вот. Значит,
[32:04.980 --> 32:14.980]  почему это верно? На самом деле, здесь нужно просто понять следующее, что если я провожу такое
[32:14.980 --> 32:20.700]  ребро из С1 в С2, то оно верно не только для вот этого у, да? Не только это у я могу продолжить
[32:20.700 --> 32:27.460]  буквой Д. Но и все другие пути, приходящие в С1, также можно было бы продлить буквой Д. Потому
[32:27.460 --> 32:32.620]  что, ну то есть, я здесь беру только для некоторого у. Надо доказать, что как бы я сюда не пришел,
[32:32.620 --> 32:46.100]  я могу приписать буквой Д, и окажусь в том же классе. Да. Из всех строк, да. Не, еще раз,
[32:46.100 --> 32:52.340]  С1, С2 это классы. Классы это вершины. Да, да, да. Вот, вот же, вот же. Вершины это класс
[32:52.340 --> 32:59.100]  эквивалентности. Вот. Соответственно, это класс. Ну, вершины, отвечающие там нескольким, вот. На
[32:59.100 --> 33:04.220]  самом деле, вот таким вот строчкам. Да, мы знаем, как устроен класс. Это вот это вот. Тут несколько
[33:04.220 --> 33:09.740]  слов. Что это значит? Значит, что из старта до сюда есть много путей, которые на самом деле задают
[33:09.740 --> 33:13.540]  с точностью вот эти вот строки. Какая-то самая длинная и несколько ее самых, несколько ее самых
[33:13.540 --> 33:17.940]  длинных суффиксов. И вот я утверждаю, что если к одной из них можно написать Д, то и к ним ко всем
[33:17.940 --> 33:30.700]  тоже можно написать Д. Вот. Ну, это вроде просто. Значит, смотрите, что значит, что существует у С1 такое,
[33:30.700 --> 33:37.340]  что у Д лежит в С2. Я хочу написать следующее, что если вот это вот верно, то пусть В это произвольная
[33:37.340 --> 33:48.780]  строка С1, я хочу показать, что ВД тоже лежит в С2. Ну, то есть, если верно для какой-то строки С1,
[33:48.780 --> 33:56.420]  то это верно для всех, что приписывание буквы оставляет, ну, переводит меня в класс С2. То есть,
[33:56.420 --> 34:03.100]  я мог бы здесь написать квантер для любого месту существования. Так.
[34:26.420 --> 34:37.820]  Давайте докажем, что у них одинаковые правые контексты. Давайте докажем, что вот этих двух строк
[34:37.820 --> 34:43.980]  одинаковые правые контексты. Значит, они лежат в одном классе. Давайте рассмотрим какой-то конкретный
[34:43.980 --> 34:56.140]  х из Р от УД. Значит, докажем, что этот же х лежит в Р от ВД. А если мы докажем, то мы по факту,
[34:56.140 --> 35:08.780]  ну, как бы, докажем одно вложение, второе будет аналогично. Картинка. Была длинная строка С. Здесь
[35:08.780 --> 35:21.100]  где-то было УДХ. Но при этом мы с вами знаем, что У и В лежат в одном классе С. С1. Значит,
[35:21.100 --> 35:29.820]  в частности, вот здесь же заканчивается какое-то вхождение В. Ну, то есть, я знаю, что, то есть,
[35:29.820 --> 35:35.500]  как можно вот это написать? Можно было бы это переписать так, что ДХ лежит в Р от У. То есть,
[35:35.500 --> 35:40.980]  У можно продолжить до суффикса строкой ДХ. Ну, и поскольку они в одном классе лежат,
[35:40.980 --> 35:48.180]  значит, это же самое ДХ лежит в правом контексте строки В. Вот. Но это формально. На картинке
[35:48.180 --> 35:52.300]  можно нарисовать так, что если вот здесь У заканчивается, заканчивает какое-то свое вхождение,
[35:52.300 --> 35:56.260]  то значит, здесь же заканчивает какое-то свое вхождение В. Будь оно более короткое или
[35:56.260 --> 36:12.660]  более длинное, это неважно. Значит, ВД можно дополнить Х. Что хотели, получили. Вот. Мы тем самым
[36:12.660 --> 36:18.100]  доказали, что правый контекст УД вложен в правом контекст ВД. Ну и обратно верно, потому что мы
[36:18.100 --> 36:22.900]  никого в предположении на У и В не накладывали. То есть, получается, что вот такое определение
[36:22.900 --> 36:27.940]  ребер, которые я ввожу, то есть, как они выглядят в автомате, оно действительно соответствует тому
[36:27.940 --> 36:34.220]  пониманию, что как бы я не дошел от старта до С1, я при помощи буквы Д попадаю в класс С2. Вот мы
[36:34.220 --> 36:42.340]  доказали, что как бы я не попал в С1, приписывание Д приводит меня в один тот же класс С2. Вот. Вопрос
[36:42.340 --> 37:02.980]  есть? Да. Вот это? Так. Про утверждение классикой валентности. Да. Не, смотрите, то У и это У, могут
[37:02.980 --> 37:07.180]  быть разные У. То утверждение было следующее, что если есть какой-то классикой валентности,
[37:07.180 --> 37:11.380]  то существует такое У, что ведь классикой валентности это У и несколько самых длинных
[37:11.420 --> 37:19.500]  суффиксов. Вы про это? Несколько это один У или даже новый У. Только сама У может быть? Может быть,
[37:19.500 --> 37:24.380]  да. Но возможно какие-то еще. Несколько, значит, ну как бы она и возможно кто-то еще. Да. Но главное,
[37:24.380 --> 37:31.900]  что там непрерывный отрезок идет. Непрерывный отрезок длинный. Хорошо. Значит, ну все, мы на самом
[37:31.900 --> 37:36.940]  деле тогда поняли, как, если что, выглядит наш автомат. То есть, мы знаем, как устроены вершинки,
[37:36.940 --> 37:41.940]  как устроены ребра. Да, и вот если там, если нам все это известно, мы можем его построить.
[37:41.940 --> 37:51.900]  Ну давайте пример попробуем. Давайте попробуем построить автомат для строки вот этой вот,
[37:51.900 --> 38:06.140]  которую я уже рисовал. А, Б, Ц, А, Б. Пусть это будет С. Ой, будет непросто. Ну давайте попробуем.
[38:06.140 --> 38:13.940]  Значит, смотрите, давайте напишем. Я буду рисовать множество строк и правый контекст это для каждой
[38:13.940 --> 38:22.260]  из этих строк. Давайте начнем с суффикса Б. Давайте начнем с пустой строки, точнее. Пустая строка,
[38:22.260 --> 38:30.260]  понятно, будет соответствовать корню нашего автомата, да, стартовой вершинки. И ее правый
[38:30.260 --> 38:39.700]  контекст это все суффиксы. То есть, это пустой суффикс Б, А, Б, Ц, А, Б. Ну и так далее. Короче,
[38:39.700 --> 38:45.260]  все суффиксы. И понятно, что она такая одна, нет никакой другой строки, у которой правый контекст
[38:45.260 --> 38:51.460]  содержал бы вообще все суффиксы строки С. Едем дальше. Вот давайте рассмотрим суффикс Б. Какой у
[38:51.460 --> 38:58.620]  него правый контекст? Во-первых, вот одно вхождение Б, значит, можно с помощью эпсилона добить до суффикса.
[38:58.620 --> 39:08.700]  Либо вот оно, Б, можно с помощью Ц, А, Б добить до суффикса. Здесь же можно заметить, что, например,
[39:08.860 --> 39:17.700]  у строки А, Б ровно такой же правый контекст. Вот оно, А, Б, ее можно дополнить эпсилоном до суффикса.
[39:17.700 --> 39:23.340]  Либо вот оно, А, Б, можно дополнить Ц, А, Б до суффикса. Поскольку у них одинаковые правые контексты,
[39:23.340 --> 39:30.100]  значит, они лежат в одном классе. И кажется, больше таких строк нет. Значит, следующая строка будет Ц,
[39:30.100 --> 39:42.180]  А, Б. У нее правый контекст просто эпсилон. Вот единственное вхождение Ц, А, Б в строчку добить до суффикса
[39:42.180 --> 39:46.660]  можно, только ничего не приписав. То же самое происходит вот с этими всеми более длинными строчками,
[39:46.660 --> 39:56.340]  Б, Ц, А, Б и А, Б, Ц, А, Б. У них у всех одинаковый правый контекст, значит, все они в одном классе
[39:56.340 --> 40:04.420]  эквивалентности. Согласны? Так, еду дальше. Какие у меня еще остались подстрочки? Ну, давайте А посмотрим.
[40:04.420 --> 40:20.700]  Какой у нее правый контекст? Б и Б, Ц, А, Б. Видимо, она здесь сама по себе. Других строк с таким классом я не вижу,
[40:20.700 --> 40:28.260]  с таким правым контекстом, точнее, я не вижу. Дальше рассмотрим Ц, А. У Ц, А правый контекст только Б,
[40:28.260 --> 40:36.860]  потому что единственное вхождение Ц, А, вот оно добить до суффикса можно только прочитав Б. И то же самое
[40:36.860 --> 40:44.060]  будет у всех этих более длинных строк заканчиваться в этой Ашке, то есть Б, Ц, А и А, Б, Ц, А. Как видим,
[40:44.060 --> 40:50.380]  все они заканчиваются только вот здесь, вот в этой позиции Б, Ц, А, А, Б, Ц, А, Ц. Вот они все только здесь
[40:50.380 --> 40:55.660]  заканчиваются. Их правый контекст состоит только из Б. Правый контекст у них одинаковый, они все
[40:55.660 --> 41:02.980]  дойдут в одном множестве, в одном классе эквивалентности. Так, хорошо, мы разобрали все суффиксы, все заканчиваются
[41:02.980 --> 41:14.380]  вот здесь. Теперь есть строка Ц, и видимо все более длинные заканчиваются здесь. Ц, Б, Ц и А, Б, Ц. У них у всех правый
[41:14.380 --> 41:23.020]  контекст это только строка А, Б. На ко всем строчкам можно написать только А, Б, чтобы получить суффикс.
[41:23.020 --> 41:33.580]  Больше ничего нельзя. Так, Б, А, Б у меня уже написано, А написано. Все, кажется, все перебрал. Проверяйте.
[41:33.580 --> 41:44.940]  Вот, значит это множество вершин моего автомата. Теперь, ну я провожу ребра вот по тому правилу.
[41:44.940 --> 41:55.460]  Вот у меня есть Эпсилон, например, сюда будет ребро по букве Б. Да, потому что я могу взять Эпсилон,
[41:55.460 --> 42:03.140]  написать Б и получить вот это вот Б. Дальше отсюда я могу куда перейти, например. Ну или давайте вот
[42:03.140 --> 42:08.420]  отсюда, я еще могу перейти вот сюда написав А. Я беру Эпсилон, приписываю А, получаю вот это слово А.
[42:08.420 --> 42:14.060]  И могу отсюда перейти вот сюда, приписав букву С. Я беру Эпсилон, дописываю С, получаю вот это вот С.
[42:14.060 --> 42:21.580]  Хорошо, теперь ребра отсюда. Можно написать ребро отсюда-сюда по букве Б. У меня было А,
[42:21.580 --> 42:29.980]  я дописываю Б, получаю А-Б. Можно ли еще что-то дописать к А? Видимо нет, потому что после А
[42:29.980 --> 42:35.420]  всегда идет Б, да, как как видим. Значит ничего другого после А дописать нельзя. Дальше, какие
[42:35.420 --> 42:41.780]  ребра отсюда идут? Например, вот сюда есть ребро по букве С, потому что можно было взять Б,
[42:41.780 --> 42:48.500]  дописать С, получить Б-С. Либо, как видим, взять А-Б, написать С, получить А-Б-С. То есть,
[42:48.500 --> 42:54.580]  какую бы строчку я отсюда не взял, дописав С, я обязательно оказываюсь в этом классе. Опять же,
[42:54.580 --> 42:59.860]  никакую другую букву нельзя дописать, потому что после Б всегда идет либо С, либо ничего.
[42:59.860 --> 43:04.900]  Поэтому отсюда больше ребр нету. Так, ну давайте я дальше уже без комментариев что-нибудь доведу.
[43:04.900 --> 43:14.500]  Отсюда после СА есть только Б, такое вот ребро. Отсюда никуда нельзя, потому что это все уже
[43:14.500 --> 43:20.660]  суффиксы, да, правее некуда. Ну и из вот этого С можно только в СА попасть. Вот сюда вот есть
[43:20.660 --> 43:33.500]  такое ребро по букве А. Конец. Вот. Значит, ну да, не очень красиво, но тем не менее вот как-то так
[43:33.500 --> 43:38.740]  автомат строится, на самом деле. Хороший вопрос. Давайте отметим. Давайте, скажите мне вообще,
[43:38.740 --> 43:50.060]  пожалуйста, какие вершины, какие классы должны быть терминальными? Да, те, которые содержат суффиксы.
[43:50.060 --> 44:00.180]  Ну здесь это только вот это, вот это и вот это. Потому что у меня суффиксы какие есть? Эпсилон,
[44:00.180 --> 44:05.980]  есть Б, есть АБ есть ЦАБ, есть Б ЦАБ, есть АБ ЦАБ. Все сейчас. Ровно они являются терминальными,
[44:05.980 --> 44:11.220]  потому что терминальные то что? Значит мы дошли от старта до терминали мы должны прояснить только
[44:11.220 --> 44:15.980]  суффикс. Потому что автомат принимать только суффиксы. Как раз вот ровно вершины содержащие
[44:15.980 --> 44:21.940]  суффиксы только суффиксы. Это как раз будут терминальные терминальные вершины. Вот, хорошо.
[44:21.940 --> 44:30.420]  все значит наша цель теперь как-то научиться строить такой автомат побыстрее потому что это
[44:30.420 --> 44:47.780]  конечно мучительно ну когда ничего не прочитали еще можно все читать вот так значит теперь
[44:47.780 --> 44:56.780]  давайте введем некоторые обозначения начну во первых через x в квадратных скобках относительно
[44:56.780 --> 45:06.820]  строки s я обозначаю класс эквивалентности куда входит x класс эквивалентности x ну вроде как
[45:06.820 --> 45:10.980]  обычно да есть у нас есть отношение эквивалентности мы по ним факторизуем то квадратные скобки это
[45:10.980 --> 45:24.580]  класс эквивалентности элемента дальше если c это класс то longest от c это самая длинная строка
[45:24.580 --> 45:35.900]  в этом классе мы помним что каждый класс устроен как это какая-то строка и ее суффиксы в порядке
[45:35.900 --> 45:44.500]  убывание на 1 да убывают убывают длины на 1 вот пусть longest это та самая длинная из них обозначение
[45:44.500 --> 45:57.620]  просто значит и также скажу лену ц это длина этого longest так и кажется последний линка ц мне
[45:57.620 --> 46:05.180]  еще будет нужно это следующее смотрите вот давайте нарисую ц это какая-то самая длинная строка
[46:05.180 --> 46:13.620]  то есть longest от ц затем ее суффикс без первого символа потом опять без второго символа без третьего
[46:13.620 --> 46:20.020]  и так далее ну вплоть до какой-то строки вот они все лежат в классе ц вопрос а что будет если я
[46:20.020 --> 46:25.660]  откушу от вот этой самой короткой строки в этом классе опять первый символ ну по предположению раз
[46:25.660 --> 46:32.420]  это была самая короткая значит я попаду в какой-то другой класс ц-штрих так вот пусть это будет
[46:32.420 --> 46:46.900]  линка ц это такой класс ц-штрих который содержит самый длинный суффикс longest не не лежащий в
[46:46.900 --> 47:01.460]  классе ц который содержит самый длинный суффикс строки longest от ц не лежащий при этом в ц
[47:01.460 --> 47:11.700]  ну определение более громоздко чем картинка вот у меня есть все строки лежащие в ц что будет
[47:11.700 --> 47:15.580]  если откушу первый символ от самой короткой строки я попадаю в другой класс и это и будет
[47:15.580 --> 47:24.580]  линк от ц а значит это будет суффиксная ссылка суффиксная ссылка класса ц
[47:45.580 --> 48:01.420]  так утверждение критерий longest я утверждаю следующее что есть очень простой критерий проверки того
[48:01.420 --> 48:09.060]  что строка является longest в своем классе значит 40 у давайте я напишу прямо так максимально
[48:09.060 --> 48:25.260]  формально равна longest в своем классе если только если если только если верно хотя бы одно из
[48:25.260 --> 48:40.980]  двух условий либо у это префикс с либо существует два таких разных символа а и б что а у и б у это
[48:40.980 --> 48:55.700]  под строки с значит longest это в точности следующие строки префиксы или же строки
[48:55.700 --> 49:03.940]  продлевающиеся налево разными буквами хотя бы двумя разными буквами еще раз строка является
[49:03.940 --> 49:10.580]  longest в своем классе если только если верно одно из двух либо у это префикс с либо существует
[49:10.580 --> 49:18.140]  две разные буквы из алфавита такие что ау и б у это обе под строки с то есть ушку можно продлить
[49:18.140 --> 49:27.700]  влево двумя разными буквами то есть есть вхождение скажем ау есть вхождение б у нашу строку с
[49:27.700 --> 49:38.980]  так доказательства давайте например слева направо тут на самом деле почти одинаковое
[49:38.980 --> 49:44.660]  рассуждение то есть слева направо пусть у это longest в своем классе то есть вот есть некий класс в
[49:44.660 --> 49:53.140]  ней у самая длинная строка остальные получаются все на длины там поменьше это вот класс эквивалентности
[49:53.140 --> 50:03.220]  для с на самом деле надо было в обратную сторону ну ладно я хочу тогда сказать что у либо префикс
[50:03.700 --> 50:10.780]  можно продолжить двумя разными способами налево пусть не так пусть для у неверно не то не то то что
[50:10.780 --> 50:18.700]  есть у не префикс и не существует двух различных продолжений влево пусть у не префикс и не
[50:18.700 --> 50:29.100]  существует и б таких что блаблабла вот что здесь написано пусть это неверно что это тогда значит
[50:29.100 --> 50:33.100]  На самом деле это означает, что любое вхождение U
[50:33.100 --> 50:36.100]  предваряется слева одной и той же буквой.
[50:36.100 --> 50:39.100]  То есть, где бы я U в моей большой строке S не увидел,
[50:39.100 --> 50:43.100]  слева от нее одна и та же C всегда.
[50:43.100 --> 50:46.100]  Все вхождения U слева одинаково предваряются буквой C.
[50:46.100 --> 50:48.100]  Ну, потому что, поскольку U не префиг,
[50:48.100 --> 50:50.100]  значит, я могу всегда говорить про предваряющую букву,
[50:50.100 --> 50:52.100]  то есть всегда есть буква слева.
[50:52.100 --> 50:55.100]  И раз нет двух раз листьев, значит, они все одинаковые.
[50:55.100 --> 50:59.100]  То есть, все вхождения U предваряются слева одинаковой буквой C.
[51:00.100 --> 51:03.100]  Но, извините, тогда U не могла бы быть лонгистом в своем классе,
[51:03.100 --> 51:07.100]  потому что U строк U и C U одинаково множество вхождений.
[51:07.100 --> 51:10.100]  А раз я сказал, что любое вхождение U предваряется C,
[51:10.100 --> 51:13.100]  значит, у U и C U одинаково множество вхождений.
[51:13.100 --> 51:15.100]  Значит, у них одинаковые правые контексты,
[51:15.100 --> 51:17.100]  значит, они должны быть в одном классе.
[51:18.100 --> 51:19.100]  Противоречие.
[51:19.100 --> 51:21.100]  Что? Да, конечно.
[51:25.100 --> 51:27.100]  Так, значит, любое...
[51:28.100 --> 51:30.100]  Значит, да, значит,
[51:30.100 --> 51:40.100]  любое вхождение U в S предваряется одинаковой буквой C.
[51:47.100 --> 51:49.100]  Значит,
[51:49.100 --> 51:52.100]  значит, у них одинаковые правые контексты.
[51:54.100 --> 51:56.100]  U и C U.
[51:56.100 --> 52:00.100]  Ну, как бы, множество вхождений у них одинаковое,
[52:00.100 --> 52:02.100]  множество окончаний вхождений у них одинаковое,
[52:02.100 --> 52:04.100]  да, везде, где есть U, есть и C U.
[52:04.100 --> 52:07.100]  Значит, они просто заканчиваются в одном и том же множестве индексов.
[52:07.100 --> 52:09.100]  Поэтому у них одинаковые правые контексты,
[52:09.100 --> 52:12.100]  значит, U не может быть лонгистом в своем классе.
[52:12.100 --> 52:14.100]  U
[52:14.100 --> 52:17.100]  не лонгист в своем классе. Противоречие.
[52:27.100 --> 52:29.100]  Да?
[52:30.100 --> 52:32.100]  Так, обратно.
[52:33.100 --> 52:35.100]  Почему, если верно, вот это вот,
[52:35.100 --> 52:37.100]  то U обязательно лонгист.
[52:38.100 --> 52:40.100]  Ну, пусть не лонгист.
[52:46.100 --> 52:47.100]  Что это значит?
[52:47.100 --> 52:50.100]  Значит, что если я рассмотрю ее класс,
[52:50.100 --> 52:52.100]  то U
[52:52.100 --> 52:57.100]  лежит в том же классе, что и какая-то более длинная строка
[52:57.100 --> 52:59.100]  с суффиксом которой она является.
[52:59.100 --> 53:01.100]  У
[53:01.100 --> 53:05.100]  лежит в том же классе, что и какая-то более длинная строка
[53:05.100 --> 53:07.100]  с суффиксом которой она является.
[53:07.100 --> 53:09.100]  Давайте, ну, то есть, как бы вот,
[53:09.100 --> 53:11.100]  картинка будет такая,
[53:11.100 --> 53:13.100]  ну, и какая-то,
[53:13.100 --> 53:15.100]  и вот здесь, на каком-то шаге U, то есть,
[53:15.100 --> 53:17.100]  U не самая длинная в своем классе.
[53:17.100 --> 53:19.100]  Тогда, смотрите, вот, если я в качестве C
[53:19.100 --> 53:21.100]  рассмотрю вот эту букву,
[53:21.100 --> 53:24.100]  ну, вот, в точности тот символ, который получается
[53:24.100 --> 53:26.100]  перед отбрасыванием, да, перед получением U,
[53:26.100 --> 53:29.100]  тогда U U и C U одинаково множество вхождений,
[53:29.100 --> 53:31.100]  то есть, они в одном классе лежат.
[53:32.100 --> 53:35.100]  Лежит в одном классе C.
[53:35.100 --> 53:37.100]  Значит, U не префикс,
[53:37.100 --> 53:41.100]  потому что всегда левее от U можно написать C.
[53:41.100 --> 53:43.100]  И не существует двух различных продолжений U влево,
[53:43.100 --> 53:48.100]  потому что U входит только там, где входит C U.
[53:49.100 --> 53:51.100]  Противоречие.
[53:53.100 --> 53:55.100]  Значит, пусть U это не лонгест,
[53:55.100 --> 53:57.100]  тогда
[53:57.100 --> 53:59.100]  U и C U
[53:59.100 --> 54:01.100]  лежат в одном классе C.
[54:01.100 --> 54:03.100]  Да, ну, вот еще раз, U это вот,
[54:03.100 --> 54:04.100]  вот она сама U.
[54:04.100 --> 54:06.100]  C это тот символ, который находится, ну,
[54:06.100 --> 54:08.100]  перед, перед ней, в строке на один повыше,
[54:08.100 --> 54:10.100]  самый левый символ, который я отбрасываю,
[54:10.100 --> 54:12.100]  чтобы получить U.
[54:12.100 --> 54:13.100]  Вот.
[54:13.100 --> 54:15.100]  Тогда они в одном классе,
[54:15.100 --> 54:17.100]  значит, любое вхождение U, опять-таки,
[54:17.100 --> 54:19.100]  предваряется символом C.
[54:20.100 --> 54:22.100]  Значит, любое вхождение U
[54:22.100 --> 54:24.100]  предваряется символом C.
[54:29.100 --> 54:31.100]  Значит, не может быть такого, что U префикс
[54:31.100 --> 54:33.100]  и не может быть такого, что U
[54:33.100 --> 54:34.100]  предваряется слева двумя разными символами.
[54:34.100 --> 54:36.100]  Ну, потому что любое вхождение U,
[54:36.100 --> 54:38.100]  где бы оно ни располагалось,
[54:38.100 --> 54:40.100]  слева автоматически влечет C.
[54:40.100 --> 54:42.100]  Значит, U не префикс, потому что слева
[54:42.100 --> 54:43.100]  должно быть что-то.
[54:43.100 --> 54:45.100]  И нет двух разных продолжений влево.
[54:45.100 --> 54:47.100]  Нет A и B, есть только C.
[54:47.100 --> 54:48.100]  Конец.
[55:11.100 --> 55:12.100]  Да.
[55:12.100 --> 55:15.100]  Вы доказали, что в том классе
[55:15.100 --> 55:17.100]  есть не только строка,
[55:17.100 --> 55:19.100]  а и все остальные.
[55:21.100 --> 55:23.100]  Для любого класса,
[55:23.100 --> 55:25.100]  какой бы я цени рассмотрел,
[55:25.100 --> 55:27.100]  это строка, ну, как бы,
[55:27.100 --> 55:29.100]  самая длинная строка в классе
[55:29.100 --> 55:31.100]  и несколько ее самых длинных суффиксов.
[55:31.100 --> 55:33.100]  Какой бы класс я не рассмотрел.
[55:33.100 --> 55:35.100]  Это для любого класса верно.
[55:35.100 --> 55:37.100]  Так.
[55:37.100 --> 55:39.100]  Вопросы какие-то?
[55:39.100 --> 55:41.100]  Хорошо.
[55:41.100 --> 55:43.100]  Значит, смотрите,
[55:43.100 --> 55:45.100]  как это было нужно.
[55:45.100 --> 55:47.100]  Давайте я скажу следующее.
[55:47.100 --> 55:49.100]  Давайте мы начнем,
[55:49.100 --> 55:51.100]  попробуем строить алгоритм.
[55:51.100 --> 55:53.100]  Как строить суффиксный автомат
[55:53.100 --> 55:55.100]  по строке S.
[55:55.100 --> 55:57.100]  Ну, такая попытка делать алгоритм.
[55:57.100 --> 55:59.100]  Во-первых,
[55:59.100 --> 56:01.100]  я его буду, наш автомат,
[56:01.100 --> 56:03.100]  строить инкрементально.
[56:03.100 --> 56:05.100]  То есть я иду по строке слева направо,
[56:05.100 --> 56:07.100]  дописываю символ
[56:07.100 --> 56:09.100]  и хочу перестроить автомат.
[56:09.100 --> 56:11.100]  То есть, вот я имел какой-то S,
[56:11.100 --> 56:13.100]  я дописываю справок S,
[56:13.100 --> 56:15.100]  новый символ C,
[56:15.100 --> 56:17.100]  и хочу перестроить автомат.
[56:17.100 --> 56:19.100]  Ну, перестраиваем автомат.
[56:21.100 --> 56:23.100]  Побуквенно.
[56:23.100 --> 56:25.100]  Вот написал букву, перестроил автомат,
[56:25.100 --> 56:27.100]  написал букву, перестроил автомат.
[56:27.100 --> 56:29.100]  Вот. И второе, я пока что
[56:29.100 --> 56:31.100]  не буду следить за терминальностью.
[56:31.100 --> 56:33.100]  Да, на протяжении всего алгоритма
[56:33.100 --> 56:35.100]  я терминальности проставлять не буду,
[56:35.100 --> 56:37.100]  вообще не буду над ними задумываться.
[56:37.100 --> 56:39.100]  Только в самом конце, когда весь автомат
[56:39.100 --> 56:41.100]  для все строки построю,
[56:41.100 --> 56:43.100]  только тогда я проставлю все терминальности.
[56:43.100 --> 56:45.100]  Пока про это вообще не думаю.
[56:45.100 --> 56:47.100]  И вам не советую.
[56:51.100 --> 56:53.100]  И, смотрите, что я могу сделать.
[56:53.100 --> 56:55.100]  Я могу сделать,
[56:55.100 --> 56:57.100]  я могу сделать,
[56:57.100 --> 56:59.100]  я могу сделать,
[56:59.100 --> 57:01.100]  и смотрите,
[57:01.100 --> 57:03.100]  что мы будем делать? Мы на самом деле
[57:03.100 --> 57:05.100]  будем делать вот этот переход,
[57:05.100 --> 57:07.100]  рассматривая множество лонгестов
[57:07.100 --> 57:09.100]  всех классов эквивалентности.
[57:09.100 --> 57:11.100]  То есть, я буду
[57:11.100 --> 57:13.100]  смотреть на то, как меняются
[57:13.100 --> 57:15.100]  все лонгесты, то есть какие строки там
[57:15.100 --> 57:17.100]  появляются, становятся лонгестами,
[57:17.100 --> 57:19.100]  какие строки перестают быть лонгестами
[57:19.100 --> 57:21.100]  при дописывание одной новой буквы.
[57:21.100 --> 57:23.100]  То есть, при переходе к новой строке,
[57:23.100 --> 57:25.100]  как меняются все лонгесты.
[57:25.100 --> 57:27.100]  То есть, как меняются,
[57:27.100 --> 57:40.540]  множество лонгест при дописывании c, при переходе от s к sc. Вопрос первый,
[57:40.540 --> 57:45.340]  могла ли какая-то строка перестать быть лонгестом, то есть она была лонгестом,
[57:45.340 --> 57:53.300]  потом внезапно перестала. Нет, потому что критерий. Если строка была лонгестом относительно
[57:53.300 --> 58:00.980]  старой строки s, то есть для нее было верно что-то из этого, то значит обязательно она остается
[58:00.980 --> 58:06.820]  лонгестом в sc. Потому что префикс остался префиксом, предварение влево осталось
[58:06.820 --> 58:09.980]  предварением влево. Мы только справа что-то дописали, никакие вхождения не сломались.
[58:09.980 --> 58:23.780]  Значит первое замечание, что лонгесты не пропадают. Ну и вообще почему нам
[58:23.780 --> 58:27.860]  достаточно смотреть на лонгесты? Потому что если я знаю набор лонгестов, то я на самом деле знаю
[58:27.860 --> 58:36.300]  все классы эквивалентности. Потому что лонгест задает классы эквивалентности, это какая-то строка
[58:36.300 --> 58:42.460]  пусть будет лонгестом в своем классе. Вот это u, лонгест в своем классе. Тогда что такое ее класс?
[58:42.460 --> 58:49.420]  Это все ее суффиксы, которые не лонгесты. То есть я вот отбрасываю по одному символу и дожидаюсь,
[58:49.420 --> 58:55.940]  когда я получу очередной лонгест. Значит тогда это старый класс, это уже новый класс начинается.
[58:55.940 --> 59:00.900]  Поэтому мне реально достаточно смотреть только за лонгестами. Лонгесты однозначно определяют
[59:00.900 --> 59:05.460]  всю структуру классов. Если я знаю какие строки являются лонгестами, значит я знаю разбиение вот
[59:05.460 --> 59:10.140]  этих суффиксов по классам эквивалентности. Что вот эти вот в одном классе, внутри с u, а когда
[59:10.140 --> 59:15.860]  я отбрасываю первый символ, попадаю в новый лонгест, это уже новый класс. Причем один является
[59:15.860 --> 59:27.820]  суффиксом другого. Еще раз, я взял какой-то лонгест u, отбрасываю первый символ. Это все не лонгесты,
[59:27.820 --> 59:32.580]  не лонгесты, не лонгесты, внезапно попал в лонгесты. Еще раз, я знаю все лонгесты, я отбрасывал
[59:32.580 --> 59:39.060]  первый символ, и когда ты попал в новый лонгест, тогда это обязательно новый класс. А вы что говорите?
[59:39.060 --> 59:51.380]  Еще раз. Потому что они не лонгесты. А если они лежали в каком-то другом классе, то это должен
[59:51.380 --> 59:57.620]  быть лонгестом в своем классе. То есть лонгест в своем классе задает как раз отсечение между вот этой
[59:57.620 --> 01:00:02.900]  строкой и ее более длинной версией. Если здесь есть какое-то сечение, то есть если эти строки в
[01:00:02.900 --> 01:00:08.900]  разных классах, то это должна быть... А, вы про то, что не может быть такого, что вот... Все, все, все,
[01:00:08.900 --> 01:00:26.460]  я понял, я понял. Да, сейчас один момент. Да, сейчас секу. Тогда это было бы лонгестом как раз.
[01:00:26.460 --> 01:00:33.700]  Потому что то, что вы сказали, продолжается разными буквами. То есть здесь есть какой-то x, что вот эта
[01:00:33.700 --> 01:00:38.420]  строка, к этой строке можно слева дописать x. А если есть какое-то другое, то есть вот другое,
[01:00:38.420 --> 01:00:42.860]  другое продолжение ее налево, так что это уходит в другой класс, то как раз здесь был бы другой
[01:00:42.860 --> 01:00:49.260]  символ y. Значит это должно было быть лонгестом, потому что есть два продолжения. Ага. Вот,
[01:00:49.260 --> 01:00:53.380]  значит действительно таких сечений вот посреди не может. Именно что вот они, они, мы просто отбрасываем
[01:00:53.380 --> 01:00:59.340]  первый символ, дожидаемся, когда будет следующий лонгест. Так, теперь давай следить только за
[01:00:59.340 --> 01:01:07.700]  лонгестами. Мы поняли, что они как бы нам порождают в точности все классы эквивалентности. Достаточно
[01:01:07.700 --> 01:01:08.740]  следить только за лонгестами.
[01:01:26.740 --> 01:01:32.340]  Ну, вопрос первый. Скажите, пожалуйста, при переходе от СКС, какая строка точно станет новым
[01:01:32.340 --> 01:01:42.660]  лонгестом? Еще раз? Вся. Да, вся СС точно становится новым лонгестом. Значит опять при переходе
[01:01:42.660 --> 01:02:04.820]  СКС, СС точно становится новым лонгестом. Ну, просто потому что для нее тривиально выполнен критерий
[01:02:04.820 --> 01:02:10.940]  лонгест. Она является префиксом на всей строке. И при этом раньше ее нигде не было. Это самая длинная
[01:02:10.940 --> 01:02:14.940]  строка, которая сейчас есть. Ее раньше в С не было, значит она раньше в автомате не присутствовала.
[01:02:14.940 --> 01:02:21.260]  Только сейчас СС стала префиксом, то есть стала лонгестом. Поэтому как минимум одна строка СС точно
[01:02:21.260 --> 01:02:24.820]  становится лонгестом всегда. Не зависимо ни от чего. Это точно новый класс эквивалентности, которого
[01:02:24.820 --> 01:02:33.340]  раньше не было. Вот. На самом деле иногда появляется еще класс эквалентности. Но давай сначала поймем,
[01:02:33.340 --> 01:02:43.140]  что за класс у вот этого СС. Кто здесь лежит? Какие здесь лежат слова? Какие здесь есть слова?
[01:02:43.140 --> 01:02:52.340]  Сначала давайте определим, а чему вообще равен правый контекст вот этой строки СС относительно
[01:02:52.340 --> 01:03:02.340]  вот этой нашей новой строки СС. Да, только Эпсилон. Надо дополнить строчку до суффикса
[01:03:02.340 --> 01:03:07.660]  само себя, можно только приписав пустое слово. Значит здесь лежат в точности все такие слова,
[01:03:07.660 --> 01:03:14.300]  у которых правый контекст это только Эпсилон. Ну класс эквивалентности это те, у которых
[01:03:14.300 --> 01:03:20.340]  правый контекст только Эпсилон. Это можно характеризовать так. Это в точности все суффиксы СС.
[01:03:20.340 --> 01:03:26.620]  Которые не входят в С, как под строки.
[01:03:42.220 --> 01:03:48.020]  Потому что у них у всех правый контекст это Эпсилон. То есть вот есть длинная строка СС.
[01:03:48.020 --> 01:03:54.420]  Вот последний символ будет С. Что за такие строки, у которых правый контекст только Эпсилон?
[01:03:54.420 --> 01:03:58.500]  Ну во-первых понятно, что это обязательно суффиксы. Потому что если это не суффикс, то можно что-то
[01:03:58.500 --> 01:04:04.580]  дописать недревеленно до суффикса. Значит это только такие суффиксы, у которых больше никаких
[01:04:04.580 --> 01:04:08.660]  вхождений нету. Потому что каждый элемент правого контекста это по факту обозначение
[01:04:08.660 --> 01:04:14.340]  какого-то вхождения строки в слово, в большую строчку. То есть больше нигде вот эти вот все
[01:04:14.340 --> 01:04:18.900]  суффиксы, лежащие в одном классе эквалинации СС, больше они нигде вхождений не имеют.
[01:04:18.900 --> 01:04:23.820]  Но это вот в сущности то, что я написал. Это все такие суффиксы, вот от такого до там какого-то
[01:04:23.820 --> 01:04:29.660]  самого короткого из них, которые только что получили вхождение, то есть вот здесь вот заканчивается,
[01:04:29.660 --> 01:04:37.820]  но раньше нигде не были. То есть которые не являются под строчками С. То есть они сейчас
[01:04:37.820 --> 01:04:41.980]  получили вхождение, вот здесь они заканчиваются так, что можно написать Эпсилон. То есть вот здесь
[01:04:41.980 --> 01:04:47.420]  заканчиваются. И больше в правом контексте ничего нет. Значит раньше их не было. Это вот такие строки,
[01:04:47.420 --> 01:05:03.180]  которые я в первый раз увидел. Супер. Дальше давайте введем обозначение. Пусть С0 это самый длинный
[01:05:03.180 --> 01:05:29.260]  суффикс СС, который входил в С как под строка. То есть у меня несколько самых длинных суффиксов
[01:05:29.260 --> 01:05:35.500]  в строке СС не входили в С, как под строки. То есть вот эти вот самые длинные, они лежали в одном классе
[01:05:35.500 --> 01:05:40.940]  таком же как СС. А вот давайте рассмотрим самый длинный, который входил. Но это соответственно
[01:05:40.940 --> 01:05:45.900]  получается вот это вот. Это самый длинный суффикс, который раньше входил в С. То есть он будет ровно
[01:05:45.900 --> 01:05:54.140]  длины на один меньше, чем самый короткий из вот этого класса. Согласны? Вот. То есть я вот
[01:05:54.140 --> 01:06:01.420]  рассматриваю все не имевшие вхождения в С раньше, а они все не имели. А вот следующие, длины еще на один
[01:06:01.420 --> 01:06:09.940]  поменьше, будет самым длинным имевшим вхождение. Вот. Значит я так обозначил. Ну и можно заметить
[01:06:09.940 --> 01:06:21.460]  сразу, что линк от СС будет у меня гарантированно С0. Ну собственно по картинке, потому что вот есть
[01:06:21.460 --> 01:06:27.140]  большой СС. Дальше я несколько первых символов могу отбросить, так что это все еще будут не под
[01:06:27.140 --> 01:06:33.940]  строки С, то есть вот в том же самом классе находиться. А потом я отбрасываю очередной символ и попадаю
[01:06:33.940 --> 01:06:39.060]  в строчку, которая уже имела раньше вхождение. То есть у меня вот был самый длинный суффикс,
[01:06:39.060 --> 01:06:43.420]  я отбрасываю по одному символу, они не имеют вхождения в С, потом отбросил один символ и
[01:06:43.420 --> 01:06:49.780]  получил вхождение в С. Это строка С0 и это в точности самый длинный суффикс СС, который
[01:06:49.780 --> 01:07:01.460]  лежит в другом классе. Чего? Ну потому что линк у меня на классах определен. Линк от класса это
[01:07:01.460 --> 01:07:06.860]  класс, формально. Ну по смыслу, да, можно опустить скобки, имеется в виду, что именно что суффсылка
[01:07:06.860 --> 01:07:21.540]  для класса этой строки это вот этот вот класс. Окей? Так, хорошо. Теперь давайте попробуем понять,
[01:07:21.540 --> 01:07:30.100]  могут ли быть еще какие-то другие лонгесты. Вот я уверен, что в общем случае может. Давайте
[01:07:30.100 --> 01:07:42.860]  скажем следующее. Пусть Т это какой-то новый лонгест. Отличный от всего это СС. Отличный
[01:07:42.860 --> 01:07:52.020]  от СС. То есть я понял, что СС обязательно новый лонгест. Вопрос, а могут ли другие еще появиться?
[01:07:52.020 --> 01:07:56.060]  Ну вот пусть какой-то появился. Пусть Т это еще какой-то новый лонгест, который раньше не был,
[01:07:56.060 --> 01:08:04.180]  а теперь он стал лонгестом. То есть он раньше не был лонгестом, а теперь стал. Когда такое могло
[01:08:04.180 --> 01:08:09.100]  произойти? Вспоминаем критерий лонгест. Критерий лонгест. Строка Т может быть лонгестом в СС.
[01:08:09.100 --> 01:08:16.460]  Если верно одно из двух, либо Т это префикс СС, значит это может быть только в случае, если Т это
[01:08:16.460 --> 01:08:24.860]  префикс СС. Либо существуют две разные буквы А и Б, такие что АТ и БТ это под сроки СС.
[01:08:24.860 --> 01:08:35.260]  Я просто написал критерий. Но смотрите, вот этого быть не может. Потому что если Т было префиксом СС,
[01:08:35.260 --> 01:08:43.460]  то оно было бы и префиксом С. Значит оно и раньше было бы лонгестом. А я предполагаю, что это новый
[01:08:43.460 --> 01:08:47.380]  лонгест. То есть раньше не был лонгестом, а теперь стал лонгестом. Поэтому этого быть не
[01:08:47.380 --> 01:08:58.500]  может. Ну, формально, если бы Т было префиксом СС, то это либо префикс С, либо вся СС. То есть как
[01:08:58.500 --> 01:09:04.060]  выглядит префикс? Это либо вся строка, либо что-то, что является префиксом С. Ну, все СС. Я уже
[01:09:04.060 --> 01:09:08.700]  сказал, что Т отлично от СС, значит Т это префикс С, значит он раньше должен был быть лонгестом.
[01:09:08.700 --> 01:09:15.340]  Поэтому этот случай я отвергаю. Получается, что теперь верно вот это, что Т продолжается влево
[01:09:15.340 --> 01:09:24.740]  двумя разными символами. А раньше этого не было. То есть раньше, в момент, когда у меня был
[01:09:24.740 --> 01:09:31.940]  построен автомат для С, раньше Т всегда предварялось только одним символом. Т предварялось
[01:09:31.940 --> 01:09:42.020]  влево только одинаковым символом С. Т всегда предварялось одним и тем же символом.
[01:09:42.020 --> 01:09:53.580]  Ну, то есть раньше оно не было лонгестом. Значит, вот это все было неверно. Значит,
[01:09:53.580 --> 01:10:01.420]  оно продлевалось влево всегда одинаково. Всегда перед Т было какое-то А. А теперь внезапно появилось
[01:10:01.420 --> 01:10:07.980]  еще вхождение В. То есть перед Т можно теперь еще и В написать. Давайте нарисуем картинку тогда.
[01:10:07.980 --> 01:10:18.140]  Вот вся моя строка СС. Раньше все вхождения Т продлевались влево только А. То есть вот было
[01:10:18.140 --> 01:10:23.860]  какое-то там АТ. Вот здесь там было какое-то АТ. Ну, и там еще где-то вот здесь могло быть АТ. Они
[01:10:23.860 --> 01:10:31.380]  могли пересекаться вполне. А теперь внезапно появились два разных символа. Такие, что они
[01:10:31.380 --> 01:10:37.380]  предваряют Т. Ну, тогда понятно, что это вот здесь опять-таки. То есть мы получили, по факту,
[01:10:37.380 --> 01:10:42.020]  мы получили новое вхождение строки БТ. Это могло произойти только в суффиксе, потому что новые
[01:10:42.020 --> 01:10:47.380]  вхождения, они вот обязательно только что закончились. Я дописал один новый символ. Строки,
[01:10:47.380 --> 01:10:51.660]  получившие вхождение, обязательно являются суффиксами. То есть картинка такая. Какие-то были
[01:10:51.660 --> 01:11:03.820]  раньше вхождения АТ, и теперь только что появилось вхождение БТ. Еще раз? Ну, не обязательно.
[01:11:03.820 --> 01:11:19.860]  Пример вам какой-то вы хотите, чтобы я нарисовал или что? Давайте попробуем.
[01:11:21.660 --> 01:11:30.380]  Сейчас, секунду, подождите, пожалуйста. АТС, АТС. А теперь представьте вот так вот. То есть у меня
[01:11:30.380 --> 01:11:39.940]  была вот такая строка. Как видим, вот здесь, а, извините, давайте тогда побольше нарисую. Вот так.
[01:11:39.940 --> 01:11:48.420]  Как видим, раньше, вот если я в качестве Т возьму вот это вот, оно раньше всегда продлевалось только
[01:11:48.420 --> 01:11:54.260]  Ашкой. Никаких других вхождений ДЦ не имеет. Но если я внезапно дописываю здесь С, то опа,
[01:11:54.260 --> 01:11:59.220]  появляется новое вхождение, предваряемое другой буквой. Оно не обязательно за одного символа стоит.
[01:11:59.220 --> 01:12:16.820]  Но что из этого можно заключить? Чему равно Т? В частности. В частности. Но какому? Вот С0 я утверждаю.
[01:12:16.820 --> 01:12:23.700]  Потому что что такое Т? Давайте посмотрим. Да, мы правильно поняли, что это суффикс С. Т
[01:12:23.700 --> 01:12:30.020]  обязательно суффикс С. Но это не абы какой суффикс. А такой суффикс, что его расширение влево на одну
[01:12:30.020 --> 01:12:37.540]  букву раньше не встречалось в С. Потому что, ну вот как я сказал, БТ раньше нигде не встречалось.
[01:12:37.540 --> 01:12:47.980]  Значит, Т это самый длинный суффикс С, который является под строкой С. То есть это С0. Потому что
[01:12:47.980 --> 01:12:52.540]  перед ним идет такая буква, что раньше такая комбинация БТ нигде не встречалась. Значит,
[01:12:52.540 --> 01:13:09.740]  Т это С0 в точности. Самый длинный суффикс С, встречавшийся в С. Итого, что мы поняли? Мы поняли,
[01:13:09.740 --> 01:13:15.900]  что если какой-то новый лонгест и появился, вот этот Т, если он и появился, то он обязательно равен С0.
[01:13:15.900 --> 01:13:22.380]  Все, никаких других лонгестов не бывает. Один лонгест, это всегда С. Он обязательно
[01:13:22.380 --> 01:13:27.380]  появляется. И, возможно, еще в качестве нового лонгеста появляется С0. Больше ничего нет. Потому
[01:13:27.380 --> 01:13:31.540]  что мы доказали, что, то есть мы рассмотрели произвольный новый лонгест, мы доказали,
[01:13:31.540 --> 01:13:43.460]  что он равен в точности С0. То есть если он есть, то он только С0. Вывод. Всегда появляется новый
[01:13:43.460 --> 01:14:03.340]  лонгест СС и, возможно, С0. То есть всегда максимум плюс две вершинки, плюс два класса. Согласны? Да.
[01:14:03.340 --> 01:14:13.820]  Потому что я предположил, пусть Т какой-то новый лонгест. Бла-бла-бла значит Т равно С0. Еще раз,
[01:14:13.820 --> 01:14:26.020]  давайте это рассудение проведем. Значит пусть Т какой-то новый лонгест отличный от СС. Так,
[01:14:26.020 --> 01:14:32.740]  сейчас. Наверное, надо повторить. Еще раз. Смотрите, вот я в этот момент понял, что вот этот Т,
[01:14:32.740 --> 01:14:36.020]  который новый лонгест, то еще раз пусть Т какой-то новый лонгест. Один из тех новых,
[01:14:36.020 --> 01:14:42.900]  которые появились. Я доказываю, что раньше он всегда предварялся одним и тем же А. Теперь
[01:14:42.900 --> 01:14:50.700]  внезапно научился предваряться Б. Значит, в частности, в частности, Т это такой суффикс СС,
[01:14:50.700 --> 01:14:57.140]  что его более длинные суффиксы, ну то есть если рассмотреть любой другой суффикс большей длины,
[01:14:57.140 --> 01:15:04.700]  он уже в С не встречался. Ну потому что если перед Т идет Б и БТ раньше не было, то какой бы
[01:15:04.700 --> 01:15:11.380]  более длинный суффикс я не рассмотрел, он раньше в С не входил. Поэтому в качестве Т может выступать
[01:15:11.380 --> 01:15:21.220]  только самый длинный ранее встречавшийся. Потому что любой другой более длинный, чем Т, уже
[01:15:21.220 --> 01:15:27.300]  встречался. Продон, наоборот, не встречался. То есть еще раз. Т это такой суффикс, что если его хотя бы
[01:15:27.300 --> 01:15:32.100]  на один символ продлить, то это уже не встречалось. Значит, Т может быть только самым длинным
[01:15:32.100 --> 01:15:36.140]  встречавшимся, потому что если возьму какой-то более короткий встречавшийся, то его продолжение
[01:15:36.140 --> 01:15:41.380]  влево тоже будет встречаться. И это противоречит вот этой картинке. Потому что продолжение Т влево на
[01:15:41.380 --> 01:15:49.300]  один не встречалось. Значит, Т только С0. Ну все, давайте закончим продолжение в следующий раз.
