[00:00.000 --> 00:11.280]  Всем доброго дня! Мы с вами заканчиваем наш курс и сегодня мы с вами поговорим
[00:11.280 --> 00:16.480]  про такую интересную тему, на самом деле, которая по идее должна была быть где-то
[00:16.480 --> 00:24.200]  в середине нашего курса, но мы ее по факту проскочили голопу по Европам, задронув в ней буквально
[00:24.200 --> 00:31.480]  два-три блока, поэтому нужно все-таки эту тему закрыть более детально и нам необходимо
[00:31.480 --> 00:37.320]  сегодня решить такую тему, как работать с объектно-ориентированными языками, потому что
[00:37.320 --> 00:42.960]  мы так или иначе уже посмотрели с вами, как работать с функциональными языками, значит,
[00:42.960 --> 00:47.480]  я сразу скажу, что если вы хотите понять, как работают функциональные языки, мы это детально
[00:47.480 --> 00:53.760]  разбирали на одном из семинаров, Виталий нам детально рассказывал, Виталий Пребейник нам
[00:53.760 --> 00:58.520]  детально рассказывал про то, как он пишет интерпретатор функционального языка и как нам все
[00:58.520 --> 01:04.400]  преобразовывается. Наша цель сегодня будет еще и закрыть тему, связанную с объектно-ориентированным
[01:04.400 --> 01:09.000]  программированием. Итак, цель наша сегодня будет заключиться в том, чтобы разобрать работу
[01:09.000 --> 01:15.440]  компиляторов ООП языков и узнать, каким образом транслировать код для ООП языков таким образом,
[01:15.440 --> 01:20.280]  чтобы он у нас с вами работал, то есть мы с вами сейчас пойдем еще в Godbolt и посмотрим примеры
[01:20.280 --> 01:28.480]  того, как это работает все в Godbolt. Поехали, значит, давайте подумаем вообще, в чем особенность у
[01:28.480 --> 01:30.160]  нас с объектно-ориентированных языков.
[01:30.160 --> 01:37.840]  Да, какие именно ООП приколы?
[01:37.840 --> 01:44.680]  Да, так давайте.
[01:44.680 --> 01:49.680]  Так, собственно, у нас что есть?
[01:49.680 --> 01:55.680]  И тот не ООП, в той части не ООП.
[01:55.680 --> 02:03.680]  Так, первый это полимаркетинг, второй это последователь.
[02:03.680 --> 02:10.680]  Ну, видите, именкапсуляция.
[02:10.680 --> 02:18.680]  Ну, с точки зрения незнакомых, это значит, что у нас у объектов есть методы.
[02:18.680 --> 02:26.680]  Да, значит, у нас появляется новая сущность, которая называется объектом, у объектов у нас есть методы,
[02:26.680 --> 02:32.680]  у нас есть у объектов поля, и нам нужно явно образом понять, какие в них есть проблемы и где их можно
[02:32.680 --> 02:38.680]  решать. Напоминаю, что скорее всего мы все это будем решать. Как вы думаете, на какой этап?
[02:38.680 --> 02:44.680]  Да, конечно же, это все будет решаться на фронт-энде, потому что смысла нет это все решать на бэк-энде.
[02:44.680 --> 02:47.680]  Вот, и знаете, что я могу сказать?
[02:47.680 --> 02:49.680]  Ну, это протягивается на бэк-энде.
[02:49.680 --> 02:56.680]  Ну да, конечно же, это все протягивается на бэк-энде, и нам нужно правильным образом все реализовывать в промежуточном представлении.
[02:56.680 --> 03:03.680]  Условно, что даже они меняются по-другому, даже они меняются по-другому по языке, потому что по интернозуся,
[03:04.680 --> 03:15.680]  Ну да, это да. Вот, и давайте вот как раз поймем, какие концепции нам здесь будут полезны с точки зрения предыдущих блоков.
[03:15.680 --> 03:27.680]  Давайте сразу подчеркнем, вот давайте подумаем, какие идеи из предыдущих блоков нам помогут реализовать некоторые из пунктов.
[03:27.680 --> 03:29.680]  Вот, у нас есть...
[03:46.680 --> 03:52.680]  Да, то есть мы с вами понимаем, скорее всего, что инкапсуляция дает чек.
[03:57.680 --> 04:14.680]  Да, это новая иерархия символ тейпл. То есть если мы с вами вспомним, как у нас это все работает в классических языках программирования,
[04:14.680 --> 04:20.680]  то у нас таблица символов была одноуровневая, то есть у нас именно были атрибуты.
[04:20.680 --> 04:24.680]  Здесь у нас появляется еще второй уровень, это уровень наследования.
[04:24.680 --> 04:29.680]  Вот, как раз сегодня покажу некоторые примеры, которые нам помогут посмотреть, как работают они по языке.
[04:29.680 --> 04:39.680]  Итак, план. Надо посмотреть, каким образом можно реализовывать методы, каким образом пишется код методов, каким образом вызываются методы,
[04:39.680 --> 04:46.680]  и каким образом реализуется наследование. И в полях нам необходимо посмотреть следующее, как их располагать в памяти.
[04:46.680 --> 04:55.680]  Раз, для того чтобы у нас был плоский лаяут. Дальше, конечно же, мы должны рассмотреть вравнование этих полей.
[04:55.680 --> 05:00.680]  И третье, это рассмотреть, как работает тоже наследование в этих полях.
[05:00.680 --> 05:13.680]  Давайте начнем сразу со следующего, чтобы вы понимали, как вы думаете, на какой язык программирования будет больше похож ER для объектно-эритерных языков?
[05:13.680 --> 05:17.680]  На обычный ER?
[05:17.680 --> 05:20.680]  Нет, нет, из высокоуровных языков программирования.
[05:20.680 --> 05:23.680]  Ну, типа Си, на Си?
[05:23.680 --> 05:27.680]  Ну, во-первых, на Си, а во-вторых, есть более точный ответ на этот вопрос.
[05:27.680 --> 05:29.680]  Си-90?
[05:29.680 --> 05:31.680]  Нет.
[05:31.680 --> 05:33.680]  На Питон?
[05:33.680 --> 05:35.680]  На Питон, да.
[05:35.680 --> 05:42.680]  Что у нас в Питоне происходит, когда мы вызываем любой метод класса?
[05:42.680 --> 05:45.680]  Какая у нас сигматура метода класса?
[05:45.680 --> 05:47.680]  Как объект?
[05:47.680 --> 05:50.680]  Нет, нет, как определение этого метода идет?
[05:50.680 --> 05:55.680]  Оргумент на себя, да.
[05:55.680 --> 05:58.680]  Собственно, в любом Яре так и происходит.
[05:58.680 --> 06:02.680]  То есть у нас будет первый аргумент, а вызов у нас может успеть.
[06:02.680 --> 06:09.680]  Вот там методы тогда делаются тем, что у тебя объект буквально хранит функцию, это не важно.
[06:09.680 --> 06:13.680]  Ну, это да. Мы с вами говорили в прошлый раз, что функция это...
[06:13.680 --> 06:17.680]  Там еще известно, что можно сделать метод...
[06:17.680 --> 06:23.680]  Этот метод на самом деле, это просто другой объект, у которого есть операция по выиску.
[06:23.680 --> 06:31.680]  То есть метод в Питоне, метод класса, это другой класс, только супер-класс.
[06:31.680 --> 06:40.680]  А сейчас в Питоне ты можешь в классе свой объект в другой тип, и у него если поменяются все методы.
[06:40.680 --> 06:45.680]  Ждем Питон 4 с хистической типизацией.
[06:45.680 --> 06:47.680]  Моджер, да, моджер.
[06:47.680 --> 06:52.680]  Моджер, да, кстати, по-моему, у них недавно новая версия вышла.
[06:52.680 --> 06:54.680]  Какая-то ИС.
[06:54.680 --> 06:58.680]  А, и первая бета Питон 3.13 вышла на нее.
[06:58.680 --> 07:04.680]  В которой попытаются сломать Global Interpreter Log.
[07:04.680 --> 07:07.680]  Ладно, давайте посмотрим.
[07:07.680 --> 07:12.680]  Первое, что нам, кстати, необходимо понять, я это в презентацию не вставил,
[07:12.680 --> 07:19.680]  что у нас с вами, значит, необходимо каким-то образом транслировать наш код ВИА.
[07:19.680 --> 07:22.680]  И в данном случае здесь у нас есть две подхода.
[07:22.680 --> 07:28.680]  Первый подход используется для реализации шаблонных функций, а второй подход используется для ООП.
[07:28.680 --> 07:33.680]  Значит, подход, который реализуется для шаблонных функций, называется static dispatcher.
[07:33.680 --> 07:40.680]  То есть, когда мы все методы, все типы определяем, и все касты у нас определяются на этапе компиляции,
[07:40.680 --> 07:45.680]  понятно, что для как раз темплейтов это сделать достаточно просто.
[07:45.680 --> 07:50.680]  Мы просто сигнализируем, смотрим на наш код, понимаем, с какими аргументами они называются,
[07:50.680 --> 07:52.680]  каким методом для этих кодов.
[07:52.680 --> 08:00.680]  Ну, собственно, static dispatcher это любой язык, который поддерживает парадигму шаблонного программирования.
[08:00.680 --> 08:05.680]  Но в чем проблема так сделать для объектно-уриентированных языков?
[08:07.680 --> 08:09.680]  Сразу определить.
[08:09.680 --> 08:10.680]  Что сразу определить?
[08:10.680 --> 08:14.680]  Типа, со которыми все вызывается.
[08:14.680 --> 08:19.680]  Ну, типа у нас может быть шаблонная функция, которая типа неизвестна, пока мы не член объектноцивировали.
[08:19.680 --> 08:25.680]  А, да-да. Там, условно, имя, имя – это не имя.
[08:25.680 --> 08:30.680]  У нас непонятно, какое имя является, имя не переменной, а какое имя типа.
[08:30.680 --> 08:32.680]  Ну, да, тоже имя такое.
[08:32.680 --> 08:40.680]  И, соответственно, здесь мы на этапе компиляции, ну, как бы, можем не определить, что у нас происходит, да?
[08:40.680 --> 08:46.680]  Мы можем не отличить метод с переобделенным на другом, кроме стопами, от функции.
[08:46.680 --> 08:49.680]  Да. Вот, поэтому нам нужен другой механизм.
[08:49.680 --> 08:52.680]  Этот механизм называется динамит-диспачок, динамической диспетчеризации.
[08:52.680 --> 09:02.680]  Вот, и для того, чтобы как раз использовать динамит-диспачок, нам нужна одна из важных парадигмных языков, парадигм реализации языков.
[09:02.680 --> 09:09.680]  Собственно, те, кто так или иначе писал хотя бы раз ткот на C++, знают этот механизм.
[09:09.680 --> 09:12.680]  Да, понятно, что те, кто не писал ни разу на C++, его не знают.
[09:12.680 --> 09:17.680]  Ну, вроде, как на нашем факультете всегда начинают писать C++.
[09:17.680 --> 09:19.680]  Ну, или по C.
[09:19.680 --> 09:22.680]  Вот, поэтому вы знакомы с ключевым словом virtual.
[09:22.680 --> 09:24.680]  Вертальные функции.
[09:31.680 --> 09:34.680]  Вот, собственно, в чем состоит суть?
[09:34.680 --> 09:39.680]  Значит, у нас с вами, помимо нашего объекта, будут представляться следующие вещи.
[09:39.680 --> 09:44.680]  У нас с вами будет, напоминаю, что объект типа класса мы определяем в таблице символов.
[09:44.680 --> 09:49.680]  Представим себе, что у нас есть некоторый объект, который называется 3D.
[09:49.680 --> 09:51.680]  Я взял некоторые примеры.
[09:51.680 --> 09:53.680]  Значит, класс PTR.
[09:53.680 --> 09:55.680]  Значит, это по факту диаграмма класс V.
[09:55.680 --> 10:00.680]  У него есть метод, представляющий этот класс 3D.
[10:00.680 --> 10:03.680]  При этом он включает некоторую таблицу диспетчеризации.
[10:03.680 --> 10:07.680]  То есть у нас с вами по факту будет репрезентация этой штуки.
[10:07.680 --> 10:09.680]  То есть у нас с вами будет метод getX.
[10:09.680 --> 10:12.680]  Дальше у него будет лежать метод norm.
[10:12.680 --> 10:16.680]  После этого у нас будет лежать еще один метод, еще один метод, еще один метод.
[10:16.680 --> 10:20.680]  То есть у нас получается вот такой набор методов, которые есть.
[10:20.680 --> 10:24.680]  И дальше они, собственно, ссылаются на некоторый определенный код.
[10:24.680 --> 10:31.680]  То есть мы можем легко достаточно посчитать offset, если нам нужно для этой таблицы, для того чтобы получить результат.
[10:31.680 --> 10:33.680]  Единственный момент сразу скажу.
[10:33.680 --> 10:38.680]  Понятно, что здесь на презентации указано, что у нас будет использоваться код этого метода.
[10:38.680 --> 10:41.680]  На самом деле у нас будет ссылка на фрейм.
[10:41.680 --> 10:43.680]  Который мы дальше будем трансформировать.
[10:43.680 --> 10:44.680]  То есть что такое фрейм?
[10:44.680 --> 10:48.680]  Это у нас функция, это у нас набор архиментов, которые мы принимаем.
[10:48.680 --> 10:50.680]  Ну и инструкция.
[10:50.680 --> 10:55.680]  И по факту, когда мы транслируем наш код в код промышленного представления, мы транслируем его по фрейму.
[10:58.680 --> 11:00.680]  То есть мы берем функцию, транслируем для.
[11:00.680 --> 11:02.680]  Берем функцию, транслируем для.
[11:02.680 --> 11:05.680]  Понятно, что для этого нам нужна таблица символов.
[11:05.680 --> 11:10.680]  Вот, то есть у нас получается вот такое вот представление нашего класса 3D.
[11:10.680 --> 11:13.680]  В нашей таблице диспетчеризации.
[11:13.680 --> 11:15.680]  Значит каким образом это все хранили?
[11:15.680 --> 11:21.680]  На самом деле здесь представим себе вот у нас вот такой вот класс есть.
[11:21.680 --> 11:26.680]  То есть у нас с вами есть класс A, у которого есть метод foo, void.
[11:26.680 --> 11:30.680]  А дальше у нас есть класс B, который расширяет класс A.
[11:30.680 --> 11:33.680]  И у нас с вами есть методы bar и методы bas.
[11:33.680 --> 11:36.680]  И дальше класс C, который реализует метод B.
[11:36.680 --> 11:38.680]  Значит что в нем есть?
[11:38.680 --> 11:41.680]  У нас с вами есть метод foo, у нас есть метод bas.
[11:41.680 --> 11:45.680]  И у нас с вами есть метод какой-то еще qx.
[11:45.680 --> 11:49.680]  Что мы с вами здесь видим интересного на этом слайде?
[11:55.680 --> 11:57.680]  Каким образом у нас объекты расположены?
[11:57.680 --> 11:59.680]  Друг за другом.
[11:59.680 --> 12:03.680]  Друг за другом. То есть то, как они определялись в базовую реализацию.
[12:03.680 --> 12:05.680]  То есть у нас есть метод foo, у нас есть метод bas.
[12:15.680 --> 12:17.680]  Ну, это да.
[12:17.680 --> 12:19.680]  Ну, не, ну ты просто пиши.
[12:19.680 --> 12:21.680]  Леонидовческий символ table.
[12:21.680 --> 12:22.680]  Да.
[12:22.680 --> 12:23.680]  Ты можешь...
[12:23.680 --> 12:24.680]  Ты так же говоришь.
[12:24.680 --> 12:28.680]  Ты смотришь как у нас C, идешь в символ table, символ table в свою маку.
[12:28.680 --> 12:30.680]  Если в своей маке нет, идешь в маку позже.
[12:30.680 --> 12:31.680]  Да, да, да.
[12:31.680 --> 12:33.680]  То есть у нас получается еще один символ table.
[12:33.680 --> 12:35.680]  Так символ table структура.
[12:35.680 --> 12:36.680]  Да, да.
[12:36.680 --> 12:38.680]  То есть символ table структура, в котором есть методы.
[12:38.680 --> 12:40.680]  Понятно, что еще важно будет...
[12:40.680 --> 12:43.680]  Ну, кстати, для обычных языков программирования.
[12:43.680 --> 12:45.680]  Сейчас, дайте, конечно.
[12:45.680 --> 12:50.680]  Наследуемые A, B классы, методы, они должны иметь ту же сигнатуру.
[12:50.680 --> 12:52.680]  Они должны иметь совместимость.
[12:52.680 --> 12:53.680]  Ну, в плюсах должны иметь совместимость.
[12:53.680 --> 12:54.680]  Да.
[12:54.680 --> 12:57.680]  То есть можно в плюсах extend быть возвращаемым типом.
[12:57.680 --> 12:59.680]  Если возвращаемым типом, то реально...
[12:59.680 --> 13:00.680]  Ну, типа...
[13:00.680 --> 13:03.680]  В базовый класс можно возвращать, типа, кое звездочка.
[13:03.680 --> 13:06.680]  На следовый класс можно держать drag звездочка.
[13:06.680 --> 13:11.680]  Ну, можно, типа, вспоминать принципы соли, типа...
[13:11.680 --> 13:13.680]  Это принцип варбара лесков.
[13:13.680 --> 13:14.680]  Да.
[13:14.680 --> 13:15.680]  Принцип варбара лесков.
[13:15.680 --> 13:17.680]  То есть, если он...
[13:17.680 --> 13:19.680]  Да, я согласен с этим.
[13:19.680 --> 13:22.680]  А можно чуть-чуть менять, но...
[13:22.680 --> 13:24.680]  Должна запорядиться.
[13:24.680 --> 13:25.680]  Ну, в целом, да.
[13:25.680 --> 13:26.680]  Хорошо.
[13:26.680 --> 13:27.680]  Вот.
[13:27.680 --> 13:28.680]  То есть у нас вот такая вот реализация.
[13:28.680 --> 13:32.680]  В принципе, таблица диспетчеризации мы можем с вами как раз таким образом исправить.
[13:32.680 --> 13:34.680]  То есть у нас есть foo.
[13:34.680 --> 13:35.680]  У нас есть bar.
[13:35.680 --> 13:36.680]  У нас есть qx.
[13:36.680 --> 13:37.680]  Отлично.
[13:37.680 --> 13:40.680]  То есть кажется, с методами мы с вами разобрались.
[13:40.680 --> 13:41.680]  Да.
[13:41.680 --> 13:43.680]  Единственное, конечно, в чем есть проблема.
[13:43.680 --> 13:50.680]  Когда мы вызываем метод, да, то нам нужно будет решить что.
[13:50.680 --> 13:53.680]  Вот у нас есть какой-то класс C.
[13:53.680 --> 13:54.680]  Да.
[13:54.680 --> 13:56.680]  И мы вызываем с вами...
[14:05.680 --> 14:11.680]  Вот у нас вот такой код.
[14:11.680 --> 14:14.680]  То есть мы с вами соберем объект класса A.
[14:14.680 --> 14:18.680]  У нас объект new класс C.
[14:18.680 --> 14:20.680]  С класс C является наследником класса A.
[14:20.680 --> 14:22.680]  То есть первое, что нам нужно будет проверить.
[14:22.680 --> 14:23.680]  Давайте подумаем.
[14:23.680 --> 14:27.680]  У нас с вами в нашей грамматике появится new...
[14:27.680 --> 14:28.680]  Знаете, ну...
[14:28.680 --> 14:29.680]  А?
[14:29.680 --> 14:30.680]  Оператор new.
[14:30.680 --> 14:31.680]  Да.
[14:31.680 --> 14:32.680]  Оператор new.
[14:32.680 --> 14:36.680]  У него в AST деревню соответствуют некоторые...
[14:36.680 --> 14:40.680]  Это просто унарный префикс оператора.
[14:40.680 --> 14:43.680]  Унарный префикс оператора, который возвращает объект определенного типа.
[14:43.680 --> 14:46.680]  То есть у нас есть оператор на типо металлический объект.
[14:46.680 --> 14:47.680]  Да.
[14:47.680 --> 14:51.680]  Ну, собственно, дальше в операторе присваивания нам нужно будет проверять.
[14:51.680 --> 14:52.680]  Ну, нет.
[14:52.680 --> 14:55.680]  Просто очередная дайчет-проверка, что у нас тип триггажа приводится.
[14:55.680 --> 14:58.680]  А в том числе автоматически приводится к нужному.
[14:58.680 --> 14:59.680]  Да, да, да.
[14:59.680 --> 15:03.680]  А дальше что-то нужно будет делать, когда мы будем вызывать этот метод foo.
[15:03.680 --> 15:05.680]  Давайте подумаем.
[15:05.680 --> 15:07.680]  Пойти в...
[15:07.680 --> 15:11.680]  Смотреть в таблицу на A и посмотреть, есть ли у него foo.
[15:11.680 --> 15:13.680]  Да, есть ли у этого штуки метод foo.
[15:13.680 --> 15:16.680]  А кого будем вызывать?
[15:16.680 --> 15:19.680]  Мы смотрим на тип нашего объекта A.
[15:19.680 --> 15:23.680]  Вот это важно, что нам нужно будет посмотреть на конкретный тип.
[15:23.680 --> 15:27.680]  То есть нам нужно будет фолдить две структуры.
[15:27.680 --> 15:29.680]  Зачем будет приобретение?
[15:29.680 --> 15:31.680]  А так, а у A есть вот...
[15:31.680 --> 15:35.680]  У нас бы таблица на A.
[15:35.680 --> 15:38.680]  Нет, ну если у нас A вызывает метод foo,
[15:38.680 --> 15:42.680]  то по идее мы должны вызывать все-таки метод у класса C.
[15:42.680 --> 15:44.680]  А, это такой виртуальный метод.
[15:44.680 --> 15:47.680]  Ну, мы просто делаем педагогический код.
[15:47.680 --> 15:51.680]  Идем из первого поля A, достаем диспочты.
[15:51.680 --> 15:54.680]  Без диспочтей мы достаем offset и вызываем A.
[15:54.680 --> 15:59.680]  А, ну да, в принципе, у нас у каждого объекта есть диспочт тейпл.
[15:59.680 --> 16:02.680]  А там как раз этот метод foo.
[16:02.680 --> 16:08.680]  Это уже, наверное, не спектруализация, если мы будем заниматься декастингом.
[16:08.680 --> 16:11.680]  Ну, типатический спектр.
[16:11.680 --> 16:14.680]  То есть, в принципе, мы видим с вами, что как раз для этого
[16:14.680 --> 16:17.680]  индексы нашего метода они сохраняются и добавляются.
[16:17.680 --> 16:20.680]  Это уже можно, короче, даже делать.
[16:21.680 --> 16:25.680]  Ну, это, в принципе, да.
[16:25.680 --> 16:28.680]  То есть, у нас получается вот такая абфракция.
[16:28.680 --> 16:30.680]  В принципе, она достаточно удобна.
[16:30.680 --> 16:34.680]  В принципе, у нас в методе добавляются чистые вверх.
[16:34.680 --> 16:36.680]  Так, хорошо.
[16:36.680 --> 16:40.680]  Дополнительно, кстати, нам нужно будет проверять модификаторы доступа.
[16:40.680 --> 16:44.680]  Понятно, каким причинам нужно проверять модификаторы доступа.
[16:44.680 --> 16:46.680]  Ага, конечно.
[16:46.680 --> 16:49.680]  Мы живем в Питоне. Замечательно.
[16:49.680 --> 16:52.680]  Ну, хотя по горнику надо будет кидать.
[16:56.680 --> 16:59.680]  Вот, значит, у нас вызывается метод foo, соответственно.
[16:59.680 --> 17:03.680]  Нам нужно будет проверить, зайти в публицию диспатченную метода a.
[17:03.680 --> 17:07.680]  Посмотрите, является ли она private или является protected методом.
[17:07.680 --> 17:10.680]  Да, типа где он у нас вообще может вызываться.
[17:10.680 --> 17:15.680]  Ну, это еще одни дополнительные проверки, которые мы можем делать на стадии runtime.
[17:15.680 --> 17:19.680]  Ой, нет, на стадии преобразования v и r.
[17:19.680 --> 17:21.680]  Вот, так.
[17:21.680 --> 17:23.680]  Эта картинка понятна?
[17:23.680 --> 17:25.680]  Хорошо.
[17:25.680 --> 17:27.680]  Давайте поговорим про поля.
[17:27.680 --> 17:30.680]  Ну, на самом деле, с полями все намного проще.
[17:30.680 --> 17:34.680]  Да, то есть у полей ровно такая же структура.
[17:34.680 --> 17:40.680]  То есть у нас с вами есть класс 2д точки, который имплементирует объект почт.
[17:40.680 --> 17:45.680]  И, собственно, у нас, на самом деле, вы не поверите, все реализуется в виде структуры.
[17:47.680 --> 17:49.680]  Да, то есть у нас есть...
[17:49.680 --> 17:51.680]  Чудеса.
[17:51.680 --> 17:54.680]  Чудеса. А структура это на самом деле будет массив.
[17:54.680 --> 17:57.680]  Ну, которая будет у структуры.
[17:57.680 --> 17:59.680]  Разнотипизованный массив.
[17:59.680 --> 18:02.680]  Да, то есть у нас как раз, если мы сейчас...
[18:02.680 --> 18:04.680]  Чупол.
[18:04.680 --> 18:06.680]  Времени в структуре только чупол, на самом деле.
[18:06.680 --> 18:08.680]  Да, да, да.
[18:08.680 --> 18:10.680]  Ну, мы это сейчас как раз посмотрим.
[18:10.680 --> 18:14.680]  То есть у нас как раз у нашего объекта будет 2д.x, 2д.y и 3д.z.
[18:14.680 --> 18:19.680]  То есть у нас получаются дополнительные точки, которые мы с вами как раз будем добавлять в конце.
[18:19.680 --> 18:21.680]  Вот.
[18:21.680 --> 18:26.680]  И, собственно, здесь, кстати, нужно будет еще задуматься при еще одной абстракции.
[18:26.680 --> 18:30.680]  Давайте подумаем при нем про статические методы.
[18:32.680 --> 18:34.680]  Что такое статические методы?
[18:35.680 --> 18:37.680]  Ну, типа...
[18:37.680 --> 18:40.680]  Функция, которая владеет сам тип.
[18:40.680 --> 18:43.680]  Ну, можно сказать, что...
[18:43.680 --> 18:46.680]  У изомственничественных функций можно налетать апелляции,
[18:46.680 --> 18:49.680]  у меня нечетко функцию вызываемой, если мы взяли какой-то тип.
[18:49.680 --> 18:51.680]  Ну, в целом, да.
[18:51.680 --> 18:55.680]  Один из вариантов создается функцию глупой, мы ее будем перегрузить.
[18:56.680 --> 19:01.680]  Ну, да. То есть мы по факту берем и демонтируем наше название.
[19:01.680 --> 19:03.680]  И их создаем в функцию определенного типа.
[19:03.680 --> 19:05.680]  Вот. И определенный аргумент.
[19:05.680 --> 19:09.680]  Главное, чтобы любые другие методы не имели доступ к этой функции.
[19:09.680 --> 19:11.680]  И к этим переменам.
[19:11.680 --> 19:14.680]  То есть нам нужно будет с вами декодировать нашу информацию.
[19:14.680 --> 19:21.680]  Вот. Значит, мы с вами сказали, что на этапе фронт-энда нам необходим страницу
[19:21.680 --> 19:24.680]  реализовать таблицу символов на несколько уровней.
[19:24.680 --> 19:28.680]  То есть первая у нас по объектам, вторая у нас по полям.
[19:28.680 --> 19:33.680]  И для каждого поля объекты необходимо иметь доступ к эротическим узлам.
[19:33.680 --> 19:37.680]  То есть у нас все должно именно аккуратно все наследоваться.
[19:37.680 --> 19:40.680]  Вот. Значит, я тут еще взял определенный пример.
[19:40.680 --> 19:42.680]  Вот. Как это может реализовываться.
[19:42.680 --> 19:44.680]  Давайте посмотрим на этот пример.
[19:44.680 --> 19:46.680]  Собственно, что мы здесь видим?
[19:46.680 --> 19:49.680]  Мы с вами здесь видим, что у нас в...
[19:49.680 --> 19:53.680]  Это я взял пример, кстати, из книжки инжинирика Капайлер,
[19:53.680 --> 19:57.680]  в которой, как ни странно, все хорошо написано по этому поводу.
[19:57.680 --> 20:00.680]  Итак, у нас что говорится?
[20:00.680 --> 20:03.680]  У нас с вами есть класс.
[20:03.680 --> 20:05.680]  Значит, это ему название.
[20:05.680 --> 20:07.680]  Он ссылается на сам себя.
[20:07.680 --> 20:09.680]  У классов есть методы.
[20:09.680 --> 20:14.680]  У классов есть ссылка на родительский класс.
[20:14.680 --> 20:18.680]  Да, потому что мы могли, если что, обратиться к родительскому классу
[20:18.680 --> 20:20.680]  и вызвать у него метод.
[20:20.680 --> 20:22.680]  То есть сделать таблицу диспетчеризации.
[20:22.680 --> 20:25.680]  Вот он, кстати. Вот он на части.
[20:25.680 --> 20:27.680]  Есть класс метода.
[20:27.680 --> 20:29.680]  Значит, что такое класс метода?
[20:29.680 --> 20:31.680]  Это статический метод в данном случае.
[20:31.680 --> 20:33.680]  Вот. Конечно, их можно преобразовать.
[20:33.680 --> 20:35.680]  Но, в принципе, в некоторых языках есть статические методы.
[20:35.680 --> 20:37.680]  Есть класс метода.
[20:37.680 --> 20:41.680]  Вот. Дальше у нас с вами есть класс метода упойнта.
[20:41.680 --> 20:44.680]  Это draw и move, допустим.
[20:44.680 --> 20:48.680]  Вот. И дальше у нас с вами есть ссылка на родительский класс.
[20:48.680 --> 20:53.680]  То есть у нас получается с вами, что это ссылка на...
[20:53.680 --> 20:54.680]  саму в сущность вида класса.
[20:54.680 --> 20:56.680]  Это ссылка на родительский класс.
[20:56.680 --> 20:58.680]  То есть здесь по факту джавовская реализация,
[20:58.680 --> 21:02.680]  которая говорит, что у нас тип Object есть.
[21:02.680 --> 21:04.680]  Ну, в принципе, хороший пример для того,
[21:04.680 --> 21:07.680]  чтобы там не плодить, допустим, ромбовинного наследования,
[21:07.680 --> 21:11.680]  когда все есть от Object, то и следующие вещи.
[21:11.680 --> 21:12.680]  То есть суперкласс.
[21:12.680 --> 21:14.680]  У нас суперкласс идет вот сюда.
[21:14.680 --> 21:16.680]  И мы идем на пуэнты.
[21:16.680 --> 21:17.680]  И у него есть класс метод.
[21:17.680 --> 21:19.680]  То есть у нас добавляется понятный метод.
[21:19.680 --> 21:22.680]  Вот. И дальше у нас уже есть наследование.
[21:22.680 --> 21:25.680]  То есть у нас с вами вот это colorPoint.
[21:25.680 --> 21:27.680]  У него есть некоторые поля.
[21:27.680 --> 21:29.680]  И дальше у нас есть реализация.
[21:29.680 --> 21:33.680]  Есть simplePoint, то есть которая наследуется от простого 포인та.
[21:33.680 --> 21:35.680]  И у него есть собственные методы draw и move,
[21:35.680 --> 21:37.680]  в котором есть координаты.
[21:37.680 --> 21:42.680]  И есть классы под названием leftCorner и rightCorner.
[21:42.680 --> 21:44.680]  У которых тоже есть свои собственные методы,
[21:44.680 --> 21:48.680]  которые реализуются от класс-методов.
[21:48.680 --> 21:50.680]  Вот. И у нас получается вот эти вот Object.
[21:50.680 --> 21:51.680]  То есть в принципе,
[21:51.680 --> 21:55.680]  когда нам нужно будет обратиться к какому-то методу move,
[21:55.680 --> 21:57.680]  и если нам, допустим, вызывается супер,
[21:57.680 --> 22:01.680]  то есть нам нужно будет добавить новое ключевое слово под именем супер,
[22:01.680 --> 22:02.680]  что мы делаем?
[22:02.680 --> 22:04.680]  Мы просто идем по указательам,
[22:04.680 --> 22:07.680]  обращаемся к родительскому классу.
[22:07.680 --> 22:11.680]  Да, кстати, в битоне в этом плане очень смешно,
[22:11.680 --> 22:15.680]  что там же метод супер, он работает,
[22:15.680 --> 22:18.680]  он может принимать в качестве аргумента класс.
[22:21.680 --> 22:22.680]  Там что угодно может быть.
[22:22.680 --> 22:23.680]  А?
[22:23.680 --> 22:24.680]  Кто-нибудь что угодно там может быть.
[22:24.680 --> 22:28.680]  Нет, и тогда можно прыгнуть на несколько уровней вверх.
[22:28.680 --> 22:32.680]  Вот. Более того, я не знаю, мы сталкиваемся с вторым битоном.
[22:32.680 --> 22:33.680]  С чем?
[22:33.680 --> 22:35.680]  Со вторым битоном.
[22:35.680 --> 22:37.680]  Но на каком уровне нет?
[22:37.680 --> 22:40.680]  Нет, просто в третьем байтоне есть метод супер,
[22:40.680 --> 22:42.680]  просто, без аргументов.
[22:42.680 --> 22:49.680]  А в третьем, во втором битоне нужно было явно кастить эти типы.
[22:49.680 --> 22:50.680]  То есть, если я сейчас открою...
[22:50.680 --> 22:52.680]  А, кстати, забавная история.
[22:52.680 --> 22:55.680]  Я вчера собирал из исходников, поэтому 3х8.
[22:57.680 --> 23:00.680]  Но на старом ноутбуке своем, 14-го или года.
[23:00.680 --> 23:03.680]  Есть мем с функцией супер.
[23:03.680 --> 23:06.680]  То есть, если у вас на стеке метода есть функция супер,
[23:06.680 --> 23:11.680]  то вам в унической направлении накидывается некая локальная переменная.
[23:13.680 --> 23:15.680]  Кто-то просто заходил.
[23:16.680 --> 23:17.680]  Во.
[23:20.680 --> 23:23.680]  Вот так оно развивалось.
[23:39.680 --> 23:43.680]  Класс B наследуется от класса C, и вам не важно, в общем,
[23:43.680 --> 23:47.680]  что принимается супер, это была просто built-in переменная.
[23:47.680 --> 23:49.680]  Built-in функция.
[23:49.680 --> 23:50.680]  Класс.
[23:50.680 --> 23:51.680]  Да.
[23:51.680 --> 23:53.680]  Это built-in переменная, которая...
[23:53.680 --> 23:55.680]  Вы знали о некотором направлении?
[23:55.680 --> 23:58.680]  Говорят, что направлении представляется на две дополнительные перемены,
[23:58.680 --> 24:02.680]  которые в функции супер, но при себя сочетаются с предыдущего проема.
[24:02.680 --> 24:03.680]  Ну да.
[24:03.680 --> 24:05.680]  Они запустили это дело.
[24:05.680 --> 24:06.680]  Да.
[24:06.680 --> 24:09.680]  В общем, вот такая вот вещь.
[24:12.680 --> 24:14.680]  То есть, это тоже нужно учитывать.
[24:14.680 --> 24:17.680]  Итак, значит, это что касается вот этого примера реализации.
[24:17.680 --> 24:21.680]  Давайте я предлагаю сейчас с вами сделать небольшую практику
[24:21.680 --> 24:23.680]  по поводу вот этого всего блока.
[24:23.680 --> 24:28.680]  И посмотреть, каким образом это все транслируется в промежуточное представление.
[24:29.680 --> 24:33.680]  Давайте для этого мы откроем с вами наш любимый getBolt.
[24:39.680 --> 24:41.680]  И напишем что-нибудь.
[24:41.680 --> 24:42.680]  Так.
[24:45.680 --> 24:49.680]  Давайте как раз возьмем пример вот этого объекта.
[24:49.680 --> 24:51.680]  У нас получается есть класс A.
[24:53.680 --> 24:55.680]  VoidFull.
[25:11.680 --> 25:13.680]  В смысле noisemdegenerated.
[25:14.680 --> 25:16.680]  Что-то я не то делал.
[25:24.680 --> 25:25.680]  Почему?
[25:38.680 --> 25:40.680]  А, минус C, я понял, да?
[25:45.680 --> 25:47.680]  Не, минус C и мы не получаем.
[26:00.680 --> 26:02.680]  Ладно, короче, будет быстрее так сделать.
[26:09.680 --> 26:10.680]  Во.
[26:14.680 --> 26:15.680]  А.
[26:23.680 --> 26:26.680]  А, подождите, я понял, паблик.
[26:37.680 --> 26:38.680]  Не-не-не.
[26:39.680 --> 26:40.680]  Итак.
[26:42.680 --> 26:44.680]  Давайте посмотрим, что он сделал.
[26:46.680 --> 26:50.680]  Значит он, во-первых, нам сгенерировал инструкцию link1 с one definition role.
[26:51.680 --> 26:53.680]  Да, то есть для метода вот этой штуки.
[26:55.680 --> 26:59.680]  И дальше он начал принимать аргумент X.
[26:59.680 --> 27:00.680]  Вот, смотрите.
[27:01.680 --> 27:03.680]  То есть у него есть аргумент %0.
[27:05.680 --> 27:07.680]  А подождите, а почему здесь дебаг флаги есть?
[27:09.680 --> 27:11.680]  А как можно убрать дебаг флаг?
[27:16.680 --> 27:18.680]  Может тут лишние эти?
[27:22.680 --> 27:24.680]  Вот эти 21 и 23 строка.
[27:31.680 --> 27:33.680]  Ладно, пусть останутся.
[27:33.680 --> 27:35.680]  То есть смотрите, что у нас происходит.
[27:35.680 --> 27:37.680]  У нас с вами алоцируются.
[27:37.680 --> 27:39.680]  Вот первое, что мы здесь видим,
[27:39.680 --> 27:42.680]  это у нас с вами есть некоторые патеры.
[27:42.680 --> 27:43.680]  Вот этот вот.
[27:43.680 --> 27:48.680]  No-undef, no-null, assign, differentiable 0.
[27:54.680 --> 27:55.680]  Чего?
[28:02.680 --> 28:03.680]  Да, на себя.
[28:06.680 --> 28:10.680]  Давайте вот так intX равно Y.
[28:17.680 --> 28:20.680]  Так, давайте посмотрим, что произошло.
[28:33.680 --> 28:34.680]  4, да.
[28:35.680 --> 28:38.680]  Говорит, что класс не может 0.0.5.
[28:41.680 --> 28:42.680]  Да.
[28:44.680 --> 28:45.680]  То есть на что он делает?
[28:52.680 --> 28:54.680]  Вот, дальше что у нас происходит.
[28:54.680 --> 28:55.680]  У нас алоцируются патеры.
[28:55.680 --> 28:57.680]  Вот это вот, то есть видите.
[28:57.680 --> 28:59.680]  Первая инструкция, которая у нас здесь автоматически есть,
[28:59.680 --> 29:03.680]  у нас тег алоцируется вот эта переменная sys.
[29:03.680 --> 29:06.680]  И у нас копируется вот эта переменная sys в 25 строке.
[29:29.680 --> 29:31.680]  Почему нельзя это?
[29:33.680 --> 29:34.680]  А?
[29:41.680 --> 29:42.680]  Не знаю.
[29:42.680 --> 29:44.680]  Возможно, что это неоптимизированный код.
[29:44.680 --> 29:46.680]  Да, скорее всего это неоптимизированный код.
[29:49.680 --> 29:51.680]  Вот, дальше что у нас происходит.
[29:51.680 --> 29:54.680]  Видите, мы загружаем данные по указателю %2.
[29:54.680 --> 29:57.680]  И дальше первое, что мы с вами видим,
[29:57.680 --> 29:59.680]  у нас есть get элемент ptr-inbounds.
[29:59.680 --> 30:04.680]  То есть мы берем и берем значение по 0-ому указателю.
[30:19.680 --> 30:20.680]  Вот, хорошо.
[30:20.680 --> 30:21.680]  Что, давайте это.
[30:30.680 --> 30:31.680]  Да.
[30:41.680 --> 30:42.680]  Вот, да.
[30:44.680 --> 30:45.680]  Вон, wisp-tr.
[30:59.680 --> 31:00.680]  А, звездочка.
[31:10.680 --> 31:12.680]  Так, давайте на 18.
[31:13.680 --> 31:14.680]  Вот, то есть вот он.
[31:16.680 --> 31:17.680]  Чего?
[31:18.680 --> 31:19.680]  А, это main.
[31:19.680 --> 31:20.680]  Я всегда забываю, что это функция main.
[31:20.680 --> 31:23.680]  Итак, давайте посмотрим, что у нас с классом B происходит.
[31:24.680 --> 31:27.680]  Да, которые будут публично наследоваться от класса A.
[31:30.680 --> 31:31.680]  Есть.
[31:33.680 --> 31:34.680]  Итак, вот он на реализации.
[31:34.680 --> 31:37.680]  Кстати, видите, какой у него location.
[31:37.680 --> 31:41.680]  Итак, давайте мы с вами объявим функцию виртуальной.
[31:47.680 --> 31:48.680]  Ага.
[31:49.680 --> 31:52.680]  И что у нас появляется с вами в VR?
[31:54.680 --> 31:56.680]  Да, у нас появляется vtable.
[31:57.680 --> 32:01.680]  Собственно, у нас появляется type-info for A.
[32:01.680 --> 32:04.680]  То есть у нас явно теперь объявляется.
[32:04.680 --> 32:07.680]  Кстати, смотрите, тип какой у класса A.
[32:17.680 --> 32:18.680]  Да, да, да.
[32:18.680 --> 32:19.680]  Вот, и дальше.
[32:22.680 --> 32:24.680]  Вот, и собственно, что мы здесь видим?
[32:24.680 --> 32:27.680]  Мы видим, тут сохраняется имя нашей функции.
[32:27.680 --> 32:29.680]  Так, это что у нас такое?
[32:37.680 --> 32:38.680]  А, да.
[32:39.680 --> 32:42.680]  Вот, то есть у нас type-name for A сохраняется.
[32:43.680 --> 32:46.680]  И дальше у нас есть, кстати, type-info for A.
[32:46.680 --> 32:49.680]  У нас опять же getElementPatternBounds.
[32:55.680 --> 32:57.680]  Вот, то есть у нас есть такая вещь.
[32:57.680 --> 32:58.680]  Так, что теперь?
[32:58.680 --> 33:00.680]  Давайте попробуем реализовать.
[33:17.680 --> 33:19.680]  Так получается.
[33:20.680 --> 33:21.680]  Так, а что?
[33:24.680 --> 33:27.680]  А, подождите, паблик забыл, как обычно.
[33:33.680 --> 33:35.680]  Стоп, а что он тупит?
[33:37.680 --> 33:39.680]  Может я неправильно написал?
[33:40.680 --> 33:42.680]  А, приватные методы, господи.
[33:42.680 --> 33:44.680]  Давайте protected сделаем.
[33:47.680 --> 33:50.680]  Итак, давайте посмотрим, что у нас произошло.
[33:50.680 --> 33:53.680]  Значит, давайте посмотрим, что у нас произошло.
[33:53.680 --> 33:56.680]  Значит, давайте здесь мы будем вызывать new-bay теперь.
[33:57.680 --> 34:01.680]  Вот, и у нас, видите, в чем особенность?
[34:01.680 --> 34:06.680]  Мы можем прямо явно зашить виртуальную таблицу в RLVM.
[34:08.680 --> 34:10.680]  То есть, видите, мы прямо ее зашиваем.
[34:10.680 --> 34:12.680]  Понятно, что ее можно самостоятельно реализовать,
[34:12.680 --> 34:15.680]  но, видите, оно здесь нам тоже позволяет это сделать.
[34:15.680 --> 34:20.680]  Кстати, смотрите, как оно реализует новый класс.
[34:20.680 --> 34:23.680]  То есть, у нас с вами есть выравнивание, да?
[34:23.680 --> 34:26.680]  А класс B это тип класса A и IN32.
[34:29.680 --> 34:30.680]  Дополнительный.
[34:30.680 --> 34:33.680]  А вот, и добавляется у нас класс ABase.
[34:33.680 --> 34:35.680]  Это PTR и IN32.
[34:35.680 --> 34:37.680]  IN32 это наша переменная K.
[34:38.680 --> 34:39.680]  Дополнительно.
[34:40.680 --> 34:43.680]  Вот, значит, здесь у нас виртуальная таблица идет.
[34:43.680 --> 34:45.680]  И теперь давайте посмотрим, что у нас происходит.
[34:45.680 --> 34:47.680]  Какой у нас метод вызывается?
[34:51.680 --> 34:54.680]  Вот, мы вызываем call void BB.
[34:54.680 --> 34:56.680]  И, кстати, смотрите, в чем особенность.
[34:56.680 --> 34:58.680]  Особенность в том, что когда у нас есть PTR,
[34:58.680 --> 35:00.680]  нам не нужно биткаст сделать.
[35:02.680 --> 35:06.680]  Потому что если бы он откатился в 12 версии какой-нибудь,
[35:08.680 --> 35:11.680]  да, видите, то есть нам пришлось бы кастить.
[35:12.680 --> 35:14.680]  И сначала IN звездочку, да?
[35:14.680 --> 35:20.680]  Дальше у нас, кстати, замечу, что у нас есть метод Bedset.
[35:24.680 --> 35:25.680]  Memset.
[35:34.680 --> 35:35.680]  То есть, что он делает?
[35:35.680 --> 35:38.680]  Он берет вот этот аргумент, вот этот тип,
[35:38.680 --> 35:43.680]  и заливает нулями значения в этой всей штуке.
[35:43.680 --> 35:45.680]  Вот, и дальше нам бы пришлось кастовать.
[35:45.680 --> 35:48.680]  А, да, и, кстати, смотрите, все равно, когда мы делаем alloc,
[35:48.680 --> 35:52.680]  нам пришлось бы лоцировать вот это все дело в метод fo.
[35:52.680 --> 35:56.680]  Значит, и теперь давайте посмотрим, как это все происходит.
[35:56.680 --> 35:58.680]  То есть мы кастим вот эту всю штуку.
[35:58.680 --> 36:00.680]  Загружаем переменную.
[36:01.680 --> 36:04.680]  И дальше смотрите, что у нас происходит.
[36:04.680 --> 36:07.680]  Давайте я вернусь на новую версию все-таки.
[36:08.680 --> 36:09.680]  Во.
[36:09.680 --> 36:13.680]  Обратите внимание, значит, у нас с вами идет,
[36:13.680 --> 36:18.680]  во-первых, мы с вами загружаем вот эту переменную.
[36:18.680 --> 36:21.680]  И мы явно здесь не вызываем метод fo.
[36:21.680 --> 36:24.680]  Обратите внимание, здесь у нас нет нигде вызова метода fo.
[36:40.680 --> 36:42.680]  Да, да, да, да.
[36:42.680 --> 36:46.680]  То есть из-за того, что мы с вами зашили vtable вот сюда,
[36:46.680 --> 36:50.680]  а он вызывает как раз метод из виртуальной функции.
[36:50.680 --> 36:54.680]  То есть он обращается, смотрите, то есть он обращается к нашему полю,
[36:54.680 --> 36:57.680]  он обращается к нулевому методу
[36:58.680 --> 37:00.680]  и делает результат.
[37:04.680 --> 37:06.680]  А вот они реализации метод.
[37:06.680 --> 37:09.680]  Господи, тут еще и конструкторы классов какие-то тяжелые.
[37:09.680 --> 37:12.680]  Да, вы, кстати, конструкторы класса они посмотрели?
[37:12.680 --> 37:14.680]  А, да, понятно.
[37:14.680 --> 37:16.680]  Дело в том, что у нас есть vtable,
[37:16.680 --> 37:21.680]  то надо разгонять конструктор, который будет в первое поле класть vtable.
[37:21.680 --> 37:25.680]  Да, вот, в первое поле у нас как раз кладется vtable.
[37:28.680 --> 37:30.680]  Для этой штуки.
[37:30.680 --> 37:33.680]  Вот, и, собственно, здесь мы видим с вами,
[37:33.680 --> 37:37.680]  что у нас идет обращение к нашим переменным.
[37:37.680 --> 37:41.680]  Кстати, обращу внимание, как он генерирует код.
[37:41.680 --> 37:46.680]  То есть он явно каким-то образом понимает,
[37:46.680 --> 37:49.680]  что, вот, на стадии front-end,
[37:49.680 --> 37:54.680]  что нам нужно у класса A вызвать первый аргумент, да,
[37:54.680 --> 37:59.680]  то есть это Y, и у класса второго вызвать аргумент K.
[38:00.680 --> 38:02.680]  Ну, аргумент K.
[38:02.680 --> 38:06.680]  Итак, давайте мы с вами еще вызовем суперметод.
[38:07.680 --> 38:09.680]  Так, сейчас, секунду.
[38:09.680 --> 38:11.680]  Как это делается?
[38:12.680 --> 38:14.680]  А, тут нет, по-моему.
[38:19.680 --> 38:22.680]  Давайте посмотрим, что он именно генерирует.
[38:22.680 --> 38:24.680]  Итак.
[38:27.680 --> 38:29.680]  Вот оно, то есть у нас...
[38:29.680 --> 38:33.680]  А, да, и, кстати, конструктор класса A у нас тоже вызывается вот здесь, да,
[38:33.680 --> 38:35.680]  то есть вот у нас класс B паблика,
[38:35.680 --> 38:40.680]  и здесь как раз мы тоже зашиваем bitable для символов A,
[38:40.680 --> 38:42.680]  то есть не забываем ту же штуку делать.
[38:42.680 --> 38:44.680]  А вот как вызывается foo.
[38:44.680 --> 38:46.680]  Кстати, обратите внимание,
[38:47.680 --> 38:50.680]  что здесь явно у нас вызывается метод foo.
[38:50.680 --> 38:52.680]  Кстати.
[38:54.680 --> 38:55.680]  А, не-не-не.
[38:55.680 --> 38:57.680]  Блин.
[39:01.680 --> 39:03.680]  А, понял.
[39:03.680 --> 39:05.680]  Нет такой штуки.
[39:08.680 --> 39:10.680]  Я хочу вспомнить,
[39:10.680 --> 39:12.680]  если метод супер,
[39:12.680 --> 39:14.680]  если метод супер,
[39:14.680 --> 39:16.680]  если метод супер,
[39:16.680 --> 39:18.680]  если метод супер,
[39:18.680 --> 39:20.680]  метод супер в C++,
[39:20.680 --> 39:22.680]  по-моему, нет.
[39:24.680 --> 39:27.680]  Супер, это ты просто делаешь шифт
[39:27.680 --> 39:29.680]  на гольде.
[39:30.680 --> 39:32.680]  В C++ здесь статикаст,
[39:32.680 --> 39:34.680]  отзыск, класс уранитера.
[39:34.680 --> 39:38.680]  Он делает даже принимать двери, если нужно.
[39:38.680 --> 39:40.680]  Ну, да.
[39:41.680 --> 39:44.680]  Ну, там, конечно, это...
[39:44.680 --> 39:46.680]  Если есть, конечно, тротуарная база,
[39:46.680 --> 39:48.680]  то табля начинается полная,
[39:49.680 --> 39:51.680]  что надо посмотреть,
[39:51.680 --> 39:53.680]  опять же, пойти в битейбл,
[39:53.680 --> 39:55.680]  и найти базу.
[39:55.680 --> 39:57.680]  Ну, да.
[39:57.680 --> 40:00.680]  Кстати, давайте попробуем отключить метод void.
[40:00.680 --> 40:02.680]  Сейчас виртуальная база,
[40:02.680 --> 40:04.680]  она прикасит базу...
[40:04.680 --> 40:07.680]  А, он в битейбле ищет offset на базу.
[40:09.680 --> 40:11.680]  Во, кстати.
[40:11.680 --> 40:13.680]  Если мы отключаем виртуальную таблицу,
[40:13.680 --> 40:15.680]  то все становится намного проще,
[40:15.680 --> 40:17.680]  но при этом у нас на стадии компиляции...
[40:19.680 --> 40:21.680]  Кстати, а какой метод тогда он вызывает?
[40:21.680 --> 40:23.680]  Он вызывает afo.
[40:23.680 --> 40:25.680]  Да, конечно, он вызывает afo,
[40:25.680 --> 40:27.680]  а не bffo, потому что он...
[40:27.680 --> 40:29.680]  Классно.
[40:29.680 --> 40:31.680]  Да.
[40:39.680 --> 40:42.680]  Вот, то есть у нас получается вот такая штука.
[40:42.680 --> 40:44.680]  То есть что нам нужно сделать?
[40:44.680 --> 40:46.680]  Значит, нам нужно будет с вами
[40:46.680 --> 40:48.680]  алоцировать таблицу символов
[40:48.680 --> 40:50.680]  для класса A.
[40:50.680 --> 40:52.680]  Дальше у нас с вами есть класс B,
[40:52.680 --> 40:54.680]  собственно, в котором int32.
[40:54.680 --> 40:56.680]  Давайте intT если мы добавим,
[40:56.680 --> 40:58.680]  то что у нас происходит?
[40:58.680 --> 41:00.680]  Видите, у нас добавляется еще один тип.
[41:02.680 --> 41:04.680]  И в конце у нас идет выравнивание
[41:04.680 --> 41:06.680]  как раз наших полей.
[41:08.680 --> 41:10.680]  И, собственно, здесь мы с вами
[41:10.680 --> 41:12.680]  говорим, что у нас будет
[41:12.680 --> 41:14.680]  виртуальная таблица,
[41:14.680 --> 41:16.680]  в которой у нас с вами
[41:16.680 --> 41:18.680]  будет следующее,
[41:18.680 --> 41:20.680]  что typeInfo у нас будет здесь,
[41:20.680 --> 41:22.680]  а дальше у нас будет getElementPatternBounds.
[41:22.680 --> 41:24.680]  То есть у нас получается второй аргумент
[41:24.680 --> 41:26.680]  здесь,
[41:26.680 --> 41:28.680]  и, собственно, у нас получается
[41:28.680 --> 41:30.680]  есть виртуальная таблица
[41:30.680 --> 41:32.680]  для afo.
[41:32.680 --> 41:34.680]  Понятно, что...
[41:34.680 --> 41:36.680]  Да, вот у нас ее имя.
[41:36.680 --> 41:38.680]  Понятно, что это можно
[41:38.680 --> 41:40.680]  писать все руками.
[41:40.680 --> 41:42.680]  И, допустим, здесь можно
[41:42.680 --> 41:44.680]  еще, кстати, делать virtual.
[41:44.680 --> 41:46.680]  И тогда у нас...
[41:46.680 --> 41:48.680]  Да, the table for where
[41:48.680 --> 41:50.680]  тоже у нас будет генерироваться.
[41:50.680 --> 41:52.680]  То есть это метода.
[41:52.680 --> 41:54.680]  То есть их, в принципе, можно использовать
[41:54.680 --> 41:56.680]  и использовать по...
[41:56.680 --> 41:58.680]  так сказать, назначим.
[41:58.680 --> 42:00.680]  Вот, значит, давайте посмотрим, как это все
[42:00.680 --> 42:02.680]  компилируется в Assembler.
[42:02.680 --> 42:04.680]  Так, вот он метод
[42:04.680 --> 42:06.680]  b.foo.
[42:08.680 --> 42:10.680]  Да, и видите, здесь явно...
[42:10.680 --> 42:12.680]  Подождите, а где main?
[42:12.680 --> 42:14.680]  А, вот они.
[42:14.680 --> 42:16.680]  Вот они, секция данных у нас
[42:16.680 --> 42:18.680]  появляется.
[42:18.680 --> 42:20.680]  То есть у нас появляется
[42:20.680 --> 42:22.680]  секция данных,
[42:22.680 --> 42:24.680]  а здесь есть
[42:24.680 --> 42:26.680]  секция данных,
[42:26.680 --> 42:28.680]  а здесь есть
[42:28.680 --> 42:30.680]  секция данных.
[42:30.680 --> 42:32.680]  То есть у нас появляется секция данных,
[42:32.680 --> 42:34.680]  в которых есть xword.
[42:38.680 --> 42:40.680]  То есть специальные символы, которые нам помогают
[42:40.680 --> 42:42.680]  определить, что это за таблица.
[42:42.680 --> 42:44.680]  То есть у нас тут есть как раз ASCII символы.
[42:44.680 --> 42:46.680]  То есть каким образом у нас называется
[42:46.680 --> 42:48.680]  тип. Вот, и дополнительно
[42:48.680 --> 42:50.680]  видно, что у нас есть
[42:50.680 --> 42:52.680]  typeInfo, то есть
[42:52.680 --> 42:54.680]  объект типа typeInfo.
[42:54.680 --> 42:56.680]  То есть у нас получается
[42:56.680 --> 42:58.680]  вот такая.
[42:58.680 --> 43:00.680]  А где main?
[43:00.680 --> 43:02.680]  То есть смотрите, мы вызываем
[43:02.680 --> 43:04.680]  оператор new,
[43:04.680 --> 43:06.680]  а здесь мы вызываем оператор
[43:06.680 --> 43:08.680]  b,
[43:08.680 --> 43:10.680]  и дальше у нас с вами идет
[43:10.680 --> 43:12.680]  где?
[43:12.680 --> 43:14.680]  Вот он метод foo,
[43:14.680 --> 43:16.680]  что такое blr, это у нас
[43:18.680 --> 43:20.680]  как он
[43:20.680 --> 43:22.680]  загружает это все?
[43:22.680 --> 43:24.680]  Да, это col.
[43:24.680 --> 43:26.680]  Давайте посмотрим, как он реализуется.
[43:26.680 --> 43:28.680]  То есть у нас здесь ldr есть, loadRegister.
[43:36.680 --> 43:38.680]  Foo нету.
[43:38.680 --> 43:40.680]  Давайте, кстати, сделаем их.
[43:52.680 --> 43:54.680]  Вот,
[43:54.680 --> 43:56.680]  мы внизу еще
[43:56.680 --> 43:58.680]  мы их назначаем.
[44:02.680 --> 44:04.680]  Вот,
[44:04.680 --> 44:06.680]  вот файлент в вашем документе.
[44:06.680 --> 44:08.680]  В x8
[44:08.680 --> 44:10.680]  он достал
[44:10.680 --> 44:12.680]  просто 3.
[44:12.680 --> 44:14.680]  Вот так на ZZ
[44:14.680 --> 44:16.680]  уже можно перейти сам к себе.
[44:16.680 --> 44:18.680]  Да, да, да, да.
[44:18.680 --> 44:20.680]  А нет, сейчас мы же
[44:20.680 --> 44:22.680]  в X0 скорее
[44:22.680 --> 44:24.680]  сейчас.
[44:24.680 --> 44:26.680]  Да, в X0 лежит pointer на ZZ
[44:26.680 --> 44:28.680]  потому что
[44:28.680 --> 44:30.680]  потом он достает из адреса
[44:30.680 --> 44:32.680]  на x8, он достал
[44:34.680 --> 44:36.680]  кусок на
[44:36.680 --> 44:38.680]  кусок с
[44:40.680 --> 44:42.680]  дальше он достал
[44:42.680 --> 44:44.680]  первое поле, это видимо первое поле.
[44:46.680 --> 44:48.680]  x8, x8.
[44:50.680 --> 44:52.680]  Да, да, да, да.
[44:56.680 --> 44:58.680]  Интересно, конечно,
[44:58.680 --> 45:00.680]  это все описать.
[45:00.680 --> 45:02.680]  Когда идет трансляция в Assembler
[45:02.680 --> 45:04.680]  нужно четко прописывать
[45:04.680 --> 45:06.680]  про логи,
[45:06.680 --> 45:08.680]  эпилоги
[45:08.680 --> 45:10.680]  и всякие такие вещи.
[45:10.680 --> 45:12.680]  Обычно сейчас это доверяют
[45:12.680 --> 45:14.680]  другим
[45:14.680 --> 45:16.680]  абстракциям.
[45:16.680 --> 45:18.680]  То есть видим мы с вами, что
[45:18.680 --> 45:20.680]  у нас с вами есть такая реализация.
[45:20.680 --> 45:22.680]  Ну и, собственно, опять же
[45:22.680 --> 45:24.680]  для проверки здесь можно сделать следующее.
[45:24.680 --> 45:26.680]  Если мы хотим оверрадить какие-то методы
[45:26.680 --> 45:28.680]  то
[45:28.680 --> 45:30.680]  тут
[45:30.680 --> 45:32.680]  опять же у нас ошибка эмпиляции.
[45:32.680 --> 45:34.680]  Python в принципе такое позволяет.
[45:34.680 --> 45:36.680]  Python это Python, как мы с вами сказали сегодня.
[45:38.680 --> 45:40.680]  И, собственно, мы видим с вами, что
[45:40.680 --> 45:42.680]  класс это по факту это и есть структура.
[45:42.680 --> 45:44.680]  Питоник у вас
[45:44.680 --> 45:46.680]  словарь почему-нибудь
[45:46.680 --> 45:48.680]  один поле по имени класс
[45:48.680 --> 45:50.680]  в котором появится указательный объект
[45:50.680 --> 45:52.680]  класса. Причем указательный объект
[45:52.680 --> 45:54.680]  класса который словарь
[45:54.680 --> 45:56.680]  у всех объектов.
[45:56.680 --> 45:58.680]  И методы определенные для этого
[45:58.680 --> 46:00.680]  класса это просто поля в
[46:00.680 --> 46:02.680]  основаре в котором лежат функции.
[46:02.680 --> 46:04.680]  Ага.
[46:04.680 --> 46:06.680]  Вот. И видно, что здесь у нас
[46:06.680 --> 46:08.680]  полное название нашего класса
[46:08.680 --> 46:10.680]  должно быть для того, чтобы
[46:10.680 --> 46:12.680]  это все работало.
[46:12.680 --> 46:14.680]  Вот. Такая вот интересная
[46:14.680 --> 46:16.680]  магия происходит.
[46:16.680 --> 46:18.680]  Ну, не то что магия.
[46:18.680 --> 46:20.680]  Вот.
[46:20.680 --> 46:22.680]  Но, кстати, смотрите, давайте еще в последний момент
[46:22.680 --> 46:24.680]  для того, чтобы мы понимали с вами, что
[46:24.680 --> 46:26.680]  мы можем обращаться именно к структуре.
[46:26.680 --> 46:28.680]  Я поменял тип.
[46:28.680 --> 46:30.680]  Да, и
[46:30.680 --> 46:32.680]  мы с вами видим
[46:32.680 --> 46:34.680]  куда это все идет.
[46:34.680 --> 46:36.680]  То есть у нас идет y плюс t.
[46:38.680 --> 46:40.680]  Это у нас метод foo. Так, стоп.
[46:40.680 --> 46:42.680]  Вот метод foo.
[46:44.680 --> 46:46.680]  Ну, метод b, метод foo.
[46:46.680 --> 46:48.680]  То есть на get элемент patternBound здесь мы обращаемся
[46:48.680 --> 46:50.680]  уже ко второму полю.
[46:50.680 --> 46:52.680]  А, не к первому.
[46:54.680 --> 46:56.680]  Вот.
[46:56.680 --> 46:58.680]  Вот такая вот интересная вещь.
[46:58.680 --> 47:00.680]  Так, хорошо.
[47:00.680 --> 47:02.680]  Значит, давайте
[47:02.680 --> 47:04.680]  поймем. Это понятно?
[47:04.680 --> 47:06.680]  Что мы рассмотрели?
[47:06.680 --> 47:08.680]  А это что писать? Это самостоятельно.
[47:08.680 --> 47:10.680]  Там некоторое...
[47:10.680 --> 47:12.680]  А?
[47:12.680 --> 47:14.680]  Ну, да.
[47:14.680 --> 47:16.680]  Но понятно, что это можно сделать в простом варианте.
[47:16.680 --> 47:18.680]  То есть не создавать виртуальные
[47:18.680 --> 47:20.680]  таблицы, а в базовом варианте их
[47:20.680 --> 47:22.680]  сразу
[47:22.680 --> 47:24.680]  написать. Просто, видите,
[47:24.680 --> 47:26.680]  в LVM есть собственная структура для
[47:26.680 --> 47:28.680]  поддержки таблиц. Ой, виртуальных
[47:28.680 --> 47:30.680]  таблиц.
[47:30.680 --> 47:32.680]  Вот. Значит, куда...
[47:32.680 --> 47:34.680]  Давайте тогда
[47:34.680 --> 47:36.680]  подытожим. По блоку объект-ориентированного
[47:36.680 --> 47:38.680]  программирования мы с вами, в принципе,
[47:38.680 --> 47:40.680]  поняли, как работают
[47:40.680 --> 47:42.680]  ВООП языки и как происходит
[47:42.680 --> 47:44.680]  трансляция ВООП языки.
[47:44.680 --> 47:46.680]  Но теперь нам нужно понять, куда
[47:46.680 --> 47:48.680]  мы можем двигаться дальше
[47:48.680 --> 47:50.680]  по поводу тех
[47:50.680 --> 47:52.680]  знаний, которые у нас были получены.
[47:52.680 --> 47:54.680]  Ну, первая, на самом деле, самая
[47:54.680 --> 47:56.680]  интересная вещь, в которую прибегают
[47:56.680 --> 47:58.680]  люди, это, конечно же, оптимизация
[47:58.680 --> 48:00.680]  всякого рода.
[48:00.680 --> 48:02.680]  Да, тут и сидят коллеги,
[48:02.680 --> 48:04.680]  которые прямо пошли на кафедру.
[48:04.680 --> 48:06.680]  Связаны с этим
[48:06.680 --> 48:08.680]  оптимизацией.
[48:08.680 --> 48:10.680]  Ну, понятно, что
[48:10.680 --> 48:12.680]  зачастую, конечно,
[48:12.680 --> 48:14.680]  если даже компилятор работает, ну,
[48:14.680 --> 48:16.680]  типа, нам, так или иначе, на практике
[48:16.680 --> 48:18.680]  сейчас иногда бывает даже
[48:18.680 --> 48:20.680]  не полезно использовать именно
[48:20.680 --> 48:22.680]  более оптимизированные компиляторы,
[48:22.680 --> 48:24.680]  а некоторые люди пытаются просто
[48:24.680 --> 48:26.680]  написать компилятор
[48:26.680 --> 48:28.680]  для своих собственных нужд.
[48:28.680 --> 48:30.680]  То есть, для своих собственных нужд,
[48:30.680 --> 48:32.680]  для domain-specific language и так далее.
[48:32.680 --> 48:34.680]  Значит, а что нам нужно,
[48:34.680 --> 48:36.680]  что нам важно для domain-specific
[48:36.680 --> 48:38.680]  language обычно?
[48:38.680 --> 48:40.680]  Вот это domain-specific language.
[48:40.680 --> 48:42.680]  Ну, кстати, это
[48:42.680 --> 48:44.680]  язык под свою
[48:44.680 --> 48:46.680]  кутэ сделан.
[48:46.680 --> 48:48.680]  Ну, например, это кутэ
[48:48.680 --> 48:50.680]  и его при процессе.
[48:50.680 --> 48:52.680]  Угу. Что нам будет
[48:52.680 --> 48:54.680]  важнее даже для вот этих языков?
[48:54.680 --> 48:56.680]  Ну,
[48:56.680 --> 48:58.680]  помимо, конечно, скорости его работы,
[48:58.680 --> 49:00.680]  ну, это даже может быть...
[49:00.680 --> 49:02.680]  Возможно, прикручивают ключи.
[49:02.680 --> 49:04.680]  Возможно, прикручивают ключи.
[49:04.680 --> 49:06.680]  Возможно, прикручивают ключи.
[49:06.680 --> 49:08.680]  Раз. Ну ладно, даже если мы
[49:08.680 --> 49:10.680]  не сможем
[49:10.680 --> 49:12.680]  прикручивать ключи,
[49:12.680 --> 49:14.680]  это ладно с ним.
[49:14.680 --> 49:16.680]  Угу.
[49:16.680 --> 49:18.680]  Давайте поймем. У нас могут быть
[49:18.680 --> 49:20.680]  интерпретированные языки, у нас могут быть компилированные языки.
[49:20.680 --> 49:22.680]  Да, для интерпретированных
[49:22.680 --> 49:24.680]  языков, в принципе,
[49:24.680 --> 49:26.680]  ну, чего-то особо не надо.
[49:26.680 --> 49:28.680]  Понятно, что для компилированных языков у нас
[49:28.680 --> 49:30.680]  должна быть система сборки
[49:30.680 --> 49:32.680]  нашего проекта, то есть нам
[49:32.680 --> 49:34.680]  должна быть система, которая бы смогла
[49:34.680 --> 49:36.680]  трансформировать это все в объектные файлы,
[49:36.680 --> 49:38.680]  да, ну, и дальше
[49:38.680 --> 49:40.680]  линковать эти объектные файлы
[49:40.680 --> 49:42.680]  с учетом того манглинга, который нам нужен.
[49:44.680 --> 49:46.680]  Ну, что нам еще нужно?
[49:48.680 --> 49:50.680]  Вы как на этом языке
[49:50.680 --> 49:52.680]  собрались писать?
[49:52.680 --> 49:54.680]  А, ну, нам нужна, получается,
[49:54.680 --> 49:56.680]  среда разработки, ну, либо
[49:56.680 --> 49:58.680]  своя, либо создаем,
[49:58.680 --> 50:00.680]  либо используем существующие.
[50:00.680 --> 50:02.680]  Нам нужны всякие, допустим,
[50:04.680 --> 50:06.680]  так сказать,
[50:06.680 --> 50:08.680]  всякие, ну, типа дебакеры,
[50:08.680 --> 50:10.680]  линкеры,
[50:12.680 --> 50:14.680]  форматеры,
[50:14.680 --> 50:16.680]  там расширение для популярных редакторов,
[50:16.680 --> 50:18.680]  которые мы делаем.
[50:18.680 --> 50:20.680]  Вопрос, как вы думаете,
[50:20.680 --> 50:22.680]  есть ли общий механизм,
[50:22.680 --> 50:24.680]  который уже это поддерживает?
[50:24.680 --> 50:26.680]  Ну, есть такая вещь, как СЛАМГД.
[50:26.680 --> 50:28.680]  Ну, это
[50:28.680 --> 50:30.680]  вообще так.
[50:30.680 --> 50:32.680]  Есть такая вещь, как
[50:32.680 --> 50:34.680]  демон языка,
[50:34.680 --> 50:36.680]  то есть это сервер, который работает
[50:36.680 --> 50:38.680]  как акултерик, к которому может
[50:38.680 --> 50:40.680]  выключаться редактор, СЛАМГД,
[50:40.680 --> 50:42.680]  как раз отлимитация этого демона
[50:42.680 --> 50:44.680]  к языку с сейфусбуком.
[50:44.680 --> 50:46.680]  Да, да, да. А вообще я хочу
[50:46.680 --> 50:48.680]  показать следующую вещь. Есть
[50:48.680 --> 50:50.680]  language server protocol, не знаю,
[50:50.680 --> 50:52.680]  слышали вы или нет про него.
[50:52.680 --> 50:54.680]  Да.
[50:54.680 --> 50:56.680]  Собственно,
[50:56.680 --> 50:58.680]  как раз
[50:58.680 --> 51:00.680]  специальный
[51:00.680 --> 51:02.680]  сервер,
[51:02.680 --> 51:04.680]  который позволяет вам
[51:04.680 --> 51:06.680]  сделать автокомплет
[51:06.680 --> 51:08.680]  всяких разных вещей.
[51:08.680 --> 51:10.680]  У него, значит, есть спецификация этого
[51:10.680 --> 51:12.680]  языка. Как видно, что он разработан
[51:12.680 --> 51:14.680]  поддерживается
[51:14.680 --> 51:16.680]  Микрософтом.
[51:16.680 --> 51:18.680]  Ну и, собственно, здесь как раз указываются
[51:18.680 --> 51:20.680]  заголовки. То есть вам, когда
[51:20.680 --> 51:22.680]  нужно будет отправлять какие-то запросы на сервер,
[51:22.680 --> 51:24.680]  да, он работает
[51:24.680 --> 51:26.680]  по RPC протоколу.
[51:26.680 --> 51:28.680]  Ну и, собственно, здесь
[51:28.680 --> 51:30.680]  нужно будет указывать
[51:30.680 --> 51:32.680]  определенные типы.
[51:32.680 --> 51:34.680]  То есть какие у нас запросы идут.
[51:34.680 --> 51:36.680]  Да, то есть видно, что здесь у нас
[51:36.680 --> 51:38.680]  запрос по умолчанию
[51:38.680 --> 51:40.680]  не базового языка. У нас
[51:40.680 --> 51:42.680]  точнее запрос не
[51:42.680 --> 51:44.680]  по простому протоколу HTTP, у нас
[51:44.680 --> 51:46.680]  по протоколу RPC здесь идет взаимодействие.
[51:46.680 --> 51:48.680]  Remote процедуру call.
[51:48.680 --> 51:50.680]  То есть у нас в вами здесь есть
[51:50.680 --> 51:52.680]  интерфейс, в котором
[51:52.680 --> 51:54.680]  должны расширить наши сообщения.
[51:54.680 --> 51:56.680]  Вот, собственно, здесь есть
[51:56.680 --> 51:58.680]  спецификация
[51:58.680 --> 52:00.680]  о том, что у нас есть. То есть нам нужно
[52:00.680 --> 52:02.680]  научиться писать вот такие вот серверы.
[52:02.680 --> 52:04.680]  Вот, и вот у него есть, допустим,
[52:04.680 --> 52:06.680]  ошибки. То есть у нас
[52:06.680 --> 52:08.680]  может быть ошибка парсинга, у нас
[52:08.680 --> 52:10.680]  может быть invalid request,
[52:10.680 --> 52:12.680]  у нас может быть метод not found,
[52:12.680 --> 52:14.680]  invalid params и так далее. То есть видно,
[52:14.680 --> 52:16.680]  что здесь
[52:16.680 --> 52:18.680]  есть разные способы. Можно, кстати,
[52:18.680 --> 52:20.680]  отправлять нотификации.
[52:20.680 --> 52:22.680]  Вот, и
[52:22.680 --> 52:24.680]  собственно,
[52:24.680 --> 52:26.680]  даже для систем сборки, видите,
[52:26.680 --> 52:28.680]  есть механизм,
[52:28.680 --> 52:30.680]  который нам позволяет
[52:30.680 --> 52:32.680]  оповестить о том, насколько мы
[52:32.680 --> 52:34.680]  сильно обработали наш запрос.
[52:34.680 --> 52:36.680]  Вот, дальше
[52:36.680 --> 52:38.680]  здесь рассказывается про URI,
[52:38.680 --> 52:40.680]  собственно, каким образом он работает.
[52:40.680 --> 52:42.680]  То есть, в принципе, видите,
[52:42.680 --> 52:44.680]  вот он URI. То есть это у нас
[52:44.680 --> 52:46.680]  в каком папке, в каком месте
[52:46.680 --> 52:48.680]  у нас наш код находится.
[52:48.680 --> 52:50.680]  Вот, и это чем удобно?
[52:50.680 --> 52:52.680]  Когда вы отлашиваете код, вот, допустим,
[52:52.680 --> 52:54.680]  в том же самом Visual Studio код или в любом
[52:54.680 --> 52:56.680]  сексом редактора, у вас есть внизу
[52:56.680 --> 52:58.680]  ссылка на файл, на который вы можете
[52:58.680 --> 53:00.680]  кликнуть и перейти на определенную строку.
[53:00.680 --> 53:02.680]  Да, это удобно.
[53:02.680 --> 53:04.680]  То есть, когда у вас ошибки сыпятся,
[53:04.680 --> 53:06.680]  вы просто CTRL-клик и делаете.
[53:06.680 --> 53:08.680]  То есть, на самом деле, вы как раз можете
[53:08.680 --> 53:10.680]  указать, где эти ошибки есть.
[53:10.680 --> 53:12.680]  В общем, тут
[53:12.680 --> 53:14.680]  спецификация огромнющая, как видно,
[53:14.680 --> 53:16.680]  сколько уже пролистал,
[53:16.680 --> 53:18.680]  чего тут есть.
[53:18.680 --> 53:20.680]  И, собственно,
[53:20.680 --> 53:22.680]  есть идентификатор языков,
[53:22.680 --> 53:24.680]  которые можно использовать.
[53:28.680 --> 53:30.680]  Вот.
[53:30.680 --> 53:32.680]  Здесь это можно уже
[53:34.680 --> 53:36.680]  как раз использовать.
[53:40.680 --> 53:42.680]  Видно, что прямо это.
[53:42.680 --> 53:44.680]  Сейчас это прямо расширяется
[53:44.680 --> 53:46.680]  и все такое. По-моему, кстати, JetBrains
[53:46.680 --> 53:48.680]  поддерживает LSP.
[53:48.680 --> 53:50.680]  Должен поддерживать.
[53:50.680 --> 53:52.680]  Пока знаю,
[53:52.680 --> 53:54.680]  есть расширение для GIMP
[53:54.680 --> 53:56.680]  для лампочных протоколов.
[53:56.680 --> 53:58.680]  Что?
[53:58.680 --> 54:00.680]  Для GIMP вроде как есть расширение
[54:00.680 --> 54:02.680]  для лампочных протоколов.
[54:02.680 --> 54:04.680]  Это, по идее, да.
[54:04.680 --> 54:06.680]  То есть, в принципе, у нас
[54:06.680 --> 54:08.680]  поднимается сервер
[54:08.680 --> 54:10.680]  и при помощи него мы как раз работаем.
[54:10.680 --> 54:12.680]  То есть, это
[54:12.680 --> 54:14.680]  еще куда можно развивать
[54:14.680 --> 54:16.680]  эту всю вещь. Понятно, что
[54:16.680 --> 54:18.680]  если вы, допустим, работаете
[54:18.680 --> 54:20.680]  с новой архитектурой,
[54:20.680 --> 54:22.680]  то понятно, что вам нужно будет
[54:22.680 --> 54:24.680]  писать лавринг под эту архитектуру.
[54:24.680 --> 54:26.680]  Т.е. трансформировать ваш код таким образом,
[54:26.680 --> 54:28.680]  чтобы он работал под письвичную
[54:28.680 --> 54:30.680]  архитектуру.
[54:30.680 --> 54:32.680]  Вот. То есть, видно, что...
[54:32.680 --> 54:34.680]  Люди, которые из ACST,
[54:34.680 --> 54:36.680]  они и помешали бы
[54:36.680 --> 54:38.680]  подошел в NPR
[54:39.680 --> 54:41.680]  Нормально.
[54:42.680 --> 54:44.680]  Тоже, в принципе, рабочее.
[54:44.680 --> 54:46.680]  Вот.
[54:46.680 --> 54:48.680]  Что еще рассказать такого интересного?
[54:48.680 --> 54:50.680]  Вроде, наверное,
[54:50.680 --> 54:52.680]  из основных моментов все,
[54:52.680 --> 54:54.680]  куда это можно копать.
[54:54.680 --> 54:56.680]  Ну и в целом, понятно, что
[54:56.680 --> 54:58.680]  пока что
[54:58.680 --> 55:00.680]  можно это все еще
[55:00.680 --> 55:02.680]  использовать для разных трансляторов.
[55:02.680 --> 55:04.680]  В принципе, трансляторов сейчас много.
[55:04.680 --> 55:06.680]  Возможно, что, кстати,
[55:06.680 --> 55:08.680]  что-нибудь интересное появится
[55:08.680 --> 55:10.680]  из мира веба.
[55:10.680 --> 55:12.680]  Если говорить, то сейчас...
[55:12.680 --> 55:14.680]  Ну, во-первых, да.
[55:14.680 --> 55:16.680]  Во-вторых, есть сейчас
[55:16.680 --> 55:18.680]  вот такая вещь.
[55:18.680 --> 55:20.680]  Не знаю, слышали или нет.
[55:20.680 --> 55:22.680]  htmx
[55:22.680 --> 55:24.680]  О, ну это
[55:24.680 --> 55:26.680]  обзор с NPR
[55:26.680 --> 55:28.680]  Угу.
[55:28.680 --> 55:30.680]  То есть, оно, на самом деле,
[55:30.680 --> 55:32.680]  немножко транслирует это все
[55:32.680 --> 55:34.680]  одновременно
[55:34.680 --> 55:36.680]  код
[55:36.680 --> 55:38.680]  на фронт-энде плюс код
[55:38.680 --> 55:40.680]  на джампскрипте.
[55:40.680 --> 55:42.680]  Вот.
[55:42.680 --> 55:44.680]  Кстати, возможно, что браузеры в какой-то версии
[55:44.680 --> 55:46.680]  начнут поддерживать htmx.
[55:46.680 --> 55:48.680]  Но пока вроде такого не замечено.
[55:48.680 --> 55:50.680]  Ну а что, если
[55:50.680 --> 55:52.680]  в чем-то получится?
[55:52.680 --> 55:54.680]  Ну, как-то так и будет
[55:54.680 --> 55:56.680]  подойдет. Ну, типа,
[55:56.680 --> 55:58.680]  я вижу, конечно, код.
[55:58.680 --> 56:00.680]  Ну, давайте посмотрим,
[56:00.680 --> 56:02.680]  что у нас происходит. У нас здесь есть скрипт.
[56:02.680 --> 56:04.680]  Загружается. Ну, специально.
[56:04.680 --> 56:06.680]  А дальше мы
[56:06.680 --> 56:08.680]  через отдельные атрибуты делаем следующее.
[56:08.680 --> 56:10.680]  У нас кнопка. Значит, при нажатии на кнопку
[56:10.680 --> 56:12.680]  мы отправляем пост-запрос
[56:12.680 --> 56:14.680]  на кликт.
[56:14.680 --> 56:16.680]  Вот.
[56:16.680 --> 56:18.680]  То есть, когда пользователь кликает
[56:18.680 --> 56:20.680]  на кнопку, у нас идет
[56:20.680 --> 56:22.680]  отжаг с реквеста на сервер и
[56:22.680 --> 56:24.680]  дальше replace
[56:24.680 --> 56:26.680]  entireButton
[56:26.680 --> 56:28.680]  viss html.Response. То есть,
[56:28.680 --> 56:30.680]  мы заменяем всю кнопку с
[56:30.680 --> 56:32.680]  весь атрибут кнопки на вот этот результат.
[56:36.680 --> 56:38.680]  Ну, то есть, то, что приходит с сервера,
[56:38.680 --> 56:40.680]  тот шаблон, который рендерится,
[56:40.680 --> 56:42.680]  мы вставляем его полностью.
[56:44.680 --> 56:46.680]  Там теперь результат формушки приходит.
[56:46.680 --> 56:48.680]  То есть, у нас кнопка берет, убирается.
[56:48.680 --> 56:50.680]  Вместо нее рисуется холм.
[56:54.680 --> 56:56.680]  Вот. То есть, в принципе,
[56:56.680 --> 56:58.680]  видно, кто их
[56:58.680 --> 57:00.680]  поддерживает.
[57:00.680 --> 57:02.680]  Кто этих ребят поддерживает.
[57:02.680 --> 57:04.680]  Песель какой-то.
[57:04.680 --> 57:06.680]  Я цепился, поддерживаю.
[57:06.680 --> 57:08.680]  Значит, хороший продукт.
[57:08.680 --> 57:10.680]  Да. Вот.
[57:10.680 --> 57:12.680]  Собственно, и дополнительный
[57:12.680 --> 57:14.680]  здесь идет кликин.
[57:14.680 --> 57:16.680]  И вот пока что это, конечно,
[57:16.680 --> 57:18.680]  не очень такая
[57:18.680 --> 57:20.680]  проднутая система. Может быть, на нее перейдут.
[57:20.680 --> 57:22.680]  Но в целом как бы здесь нам придется
[57:22.680 --> 57:24.680]  делать трансляцию в два разных языка.
[57:24.680 --> 57:26.680]  Да.
[57:26.680 --> 57:28.680]  Да, первое это в HTML, второе это...
[57:28.680 --> 57:30.680]  Давайте вспомним DLSX, JSX и GD.
[57:32.680 --> 57:34.680]  Там у кого-то то самое.
[57:34.680 --> 57:36.680]  Ну, в целом, да. То есть, бывает, что у нас
[57:36.680 --> 57:38.680]  трансляция идет не в один язык, а в несколько разных языках.
[57:40.680 --> 57:42.680]  Вот. Ну, в целом,
[57:42.680 --> 57:44.680]  можете мне поверить, вот этот вот код,
[57:44.680 --> 57:46.680]  на самом деле, вот этой странички
[57:46.680 --> 57:48.680]  он превращается где-то в...
[57:48.680 --> 57:50.680]  Значит, в...
[57:50.680 --> 57:52.680]  Получается такой же код на HTML,
[57:52.680 --> 57:54.680]  плюс еще, ну, наверное, где-то строк
[57:54.680 --> 57:56.680]  30-40 на Javascript.
[58:00.680 --> 58:02.680]  Вот.
[58:02.680 --> 58:04.680]  Javascript больше не
[58:04.680 --> 58:06.680]  язык выхода для компилятора.
[58:06.680 --> 58:08.680]  А? Javascript больше
[58:08.680 --> 58:10.680]  не язык написания в программе
[58:10.680 --> 58:12.680]  язык выхода для компилятора.
[58:12.680 --> 58:14.680]  Ну, да, да, да. Очень странное
[58:14.680 --> 58:16.680]  и нежное слово.
[58:16.680 --> 58:18.680]  Не знаю, что это.
[58:18.680 --> 58:20.680]  Надо было тогда
[58:20.680 --> 58:22.680]  просто, чтобы в браузере отражались
[58:22.680 --> 58:24.680]  какие-то условно новые...
[58:24.680 --> 58:26.680]  Так это VimAssembly есть.
[58:26.680 --> 58:28.680]  Это универсальный ассендер.
[58:28.680 --> 58:30.680]  В него конфиденция
[58:30.680 --> 58:32.680]  раз, например,
[58:32.680 --> 58:34.680]  если будет, чтобы раз в браузере работать.
[58:34.680 --> 58:36.680]  Да.
[58:36.680 --> 58:38.680]  Ну, и последняя вещь, где это еще может быть
[58:38.680 --> 58:40.680]  полезно, ну, это, конечно, совсем
[58:40.680 --> 58:42.680]  веселая вещь, это опускация кода.
[58:44.680 --> 58:46.680]  Это весело.
[58:46.680 --> 58:48.680]  Ну, да.
[58:48.680 --> 58:50.680]  Да.
[58:50.680 --> 58:52.680]  Проблема в том, что из JSPack
[58:52.680 --> 58:54.680]  достаточно легко написать
[58:54.680 --> 58:56.680]  где компилятор.
[58:56.680 --> 58:58.680]  Ну, типа, по крайней мере, на
[58:58.680 --> 59:00.680]  компиляторе, который валяется
[59:00.680 --> 59:02.680]  в открытом доступе, там
[59:02.680 --> 59:04.680]  где компилятор включится.
[59:04.680 --> 59:06.680]  Ну, на самом деле, это опускация,
[59:06.680 --> 59:08.680]  во-первых, для того, чтобы страничка бы быстрее загружалась.
[59:08.680 --> 59:10.680]  Не, а опускация
[59:10.680 --> 59:12.680]  занимается закутыванием
[59:12.680 --> 59:14.680]  кода в общем виде.
[59:14.680 --> 59:16.680]  А дальше есть разные применения.
[59:16.680 --> 59:18.680]  Другие применения, это всякие webpack
[59:18.680 --> 59:20.680]  которые позволяют страничке загружаться быстрее.
[59:20.680 --> 59:22.680]  Ну, не опускация.
[59:22.680 --> 59:24.680]  А вторая вещь,
[59:24.680 --> 59:26.680]  это именно искусственное закутывание
[59:26.680 --> 59:28.680]  кода внутри бинарявств,
[59:28.680 --> 59:30.680]  в его независимой версии.
[59:30.680 --> 59:32.680]  Ну, это опускация именно вторая, первая,
[59:32.680 --> 59:34.680]  это не опускация, скорее, это оптимизация.
[59:34.680 --> 59:36.680]  Да, оптимизация.
[59:36.680 --> 59:38.680]  Да, вид оптимизации, да, просто сжимаешь,
[59:38.680 --> 59:40.680]  как все пробелы видеть выше, и так далее.
[59:40.680 --> 59:42.680]  И еще все пайлы инстрируются на один,
[59:42.680 --> 59:44.680]  чтобы не загрузиться.
[59:44.680 --> 59:46.680]  То есть, в принципе,
[59:46.680 --> 59:48.680]  область применения вот этого
[59:48.680 --> 59:50.680]  всего добра, она есть
[59:50.680 --> 59:52.680]  в многих языках, то есть, поэтому
[59:52.680 --> 59:54.680]  у нас тут тоже важно
[59:54.680 --> 59:56.680]  говорить не только про код, но и
[59:56.680 --> 59:58.680]  про языки программирования вообще в целом.
[59:58.680 --> 01:00:00.680]  Вот, понятно, что это такой
[01:00:00.680 --> 01:00:02.680]  базовый курс, так сказать,
[01:00:02.680 --> 01:00:04.680]  именно введение, да, более продвинутые
[01:00:04.680 --> 01:00:06.680]  вещи, куда-то тут еще можно копать.
[01:00:06.680 --> 01:00:08.680]  Конечно же, если мы говорим
[01:00:08.680 --> 01:00:10.680]  про ER, то это SSA
[01:00:10.680 --> 01:00:12.680]  форма, это
[01:00:12.680 --> 01:00:14.680]  инструкции, детально
[01:00:14.680 --> 01:00:16.680]  рассматриваете, и так далее.
[01:00:16.680 --> 01:00:18.680]  Поэтому, если мы говорим про какие-то другие
[01:00:18.680 --> 01:00:20.680]  парадигмы, то понятно, что
[01:00:20.680 --> 01:00:22.680]  это там трансляция кодов
[01:00:22.680 --> 01:00:24.680]  именно в эту конкретную парадигму, но
[01:00:24.680 --> 01:00:26.680]  все равно мы так или иначе вскатываемся
[01:00:26.680 --> 01:00:28.680]  в императивную сущность.
[01:00:28.680 --> 01:00:30.680]  Ну и в целом
[01:00:30.680 --> 01:00:32.680]  можно, конечно, и
[01:00:32.680 --> 01:00:34.680]  дальше развивать всю эту историю.
[01:00:34.680 --> 01:00:36.680]  Все равно, кстати,
[01:00:36.680 --> 01:00:38.680]  интересным направлением
[01:00:38.680 --> 01:00:40.680]  будет, скорее всего, понимание
[01:00:40.680 --> 01:00:42.680]  того, смогут ли
[01:00:42.680 --> 01:00:44.680]  в какую-нибудь диффузионную,
[01:00:44.680 --> 01:00:46.680]  ой, в какую-нибудь large model
[01:00:46.680 --> 01:00:48.680]  внедрить понимание
[01:00:48.680 --> 01:00:50.680]  не на базовом уровне
[01:00:50.680 --> 01:00:52.680]  языка, а
[01:00:52.680 --> 01:00:54.680]  где-то в промежуточном представлении.
[01:00:54.680 --> 01:00:56.680]  В смысле, если
[01:00:56.680 --> 01:00:58.680]  обучить нас в различных
[01:00:58.680 --> 01:01:00.680]  материалах про ER,
[01:01:00.680 --> 01:01:02.680]  она, наверное, будет его понимать.
[01:01:02.680 --> 01:01:04.680]  Опять же, понимать в смысле машины.
[01:01:04.680 --> 01:01:06.680]  Сразу скажу, что, поскольку
[01:01:06.680 --> 01:01:08.680]  я в этой сфере работаю, на самом деле
[01:01:08.680 --> 01:01:10.680]  вот эти большие языковые модели
[01:01:10.680 --> 01:01:12.680]  работают немножко не по той парадигму,
[01:01:12.680 --> 01:01:14.680]  по которой работают классические нейросети.
[01:01:14.680 --> 01:01:16.680]  У нее, из-за того, что
[01:01:16.680 --> 01:01:18.680]  количество параметров большое, у нее
[01:01:18.680 --> 01:01:20.680]  по факту возникает механизм притинга.
[01:01:20.680 --> 01:01:22.680]  То есть запечатление
[01:01:22.680 --> 01:01:24.680]  информации. То есть она по факту достает
[01:01:24.680 --> 01:01:26.680]  все, что у нее загрузили из памяти и немного
[01:01:26.680 --> 01:01:28.680]  синтезирует. Но уровень этого
[01:01:28.680 --> 01:01:30.680]  синтеза пока не очень высокий.
[01:01:32.680 --> 01:01:34.680]  Это просто, считаю,
[01:01:34.680 --> 01:01:36.680]  на эксклюзивной
[01:01:36.680 --> 01:01:38.680]  уровне будет все.
[01:01:38.680 --> 01:01:40.680]  Использует все, что есть в этом мире.
[01:01:40.680 --> 01:01:42.680]  Да.
[01:01:42.680 --> 01:01:44.680]  Возможно, чуть-чуть преобразовать.
[01:01:44.680 --> 01:01:46.680]  Чуть в смысл понимать.
[01:01:46.680 --> 01:01:48.680]  С этим были
[01:01:48.680 --> 01:01:50.680]  возможные вещи, что
[01:01:50.680 --> 01:01:52.680]  люди же смогли потом
[01:01:52.680 --> 01:01:54.680]  декомпельнуть, так сказать,
[01:01:54.680 --> 01:01:56.680]  эти языковые модели
[01:01:56.680 --> 01:01:58.680]  и начинать подавать
[01:01:58.680 --> 01:02:00.680]  языковые заявления.
[01:02:00.680 --> 01:02:02.680]  Да.
[01:02:02.680 --> 01:02:04.680]  Найти на чем она столбается и начать
[01:02:04.680 --> 01:02:06.680]  в принципе. Ну да.
[01:02:06.680 --> 01:02:08.680]  Хотя это в принципе
[01:02:08.680 --> 01:02:10.680]  с той временной
[01:02:10.680 --> 01:02:12.680]  индигенцией модели, конечно, вопрос
[01:02:12.680 --> 01:02:14.680]  о вопросном правиле.
[01:02:14.680 --> 01:02:16.680]  Кстати.
[01:02:16.680 --> 01:02:18.680]  Потому что
[01:02:18.680 --> 01:02:20.680]  слишком похожи на людей.
[01:02:30.680 --> 01:02:32.680]  Не пользуются уголом.
[01:02:32.680 --> 01:02:34.680]  Да, да, да.
[01:02:58.680 --> 01:03:00.680]  Да, кстати, при процессинг тоже
[01:03:00.680 --> 01:03:02.680]  про грамматику.
[01:03:08.680 --> 01:03:10.680]  Я не знаю, рассказываю
[01:03:10.680 --> 01:03:12.680]  или нет.
[01:03:12.680 --> 01:03:14.680]  Это как бы
[01:03:14.680 --> 01:03:16.680]  все эти дурацкие тесты
[01:03:16.680 --> 01:03:18.680]  очень хорошо углубляются кавычками.
[01:03:18.680 --> 01:03:20.680]  Обычно, когда ученые проверяют,
[01:03:20.680 --> 01:03:22.680]  что тесты не углубляются, они просто вставляют,
[01:03:22.680 --> 01:03:24.680]  ты просто берешь тест
[01:03:24.680 --> 01:03:26.680]  и включаешь кавычки в первую
[01:03:26.680 --> 01:03:28.680]  кавычку.
[01:03:28.680 --> 01:03:30.680]  Да, да, да, да.
[01:03:30.680 --> 01:03:32.680]  Собственно, еще такой важный
[01:03:32.680 --> 01:03:34.680]  момент. Я, по-моему, что-то хотел сказать.
[01:03:34.680 --> 01:03:36.680]  А, да.
[01:03:36.680 --> 01:03:38.680]  Ну, на самом деле,
[01:03:38.680 --> 01:03:40.680]  когда нужны парси
[01:03:40.680 --> 01:03:42.680]  инструкции,
[01:03:42.680 --> 01:03:44.680]  всегда они заточены на тексты,
[01:03:44.680 --> 01:03:46.680]  поэтому нам делают
[01:03:46.680 --> 01:03:48.680]  навертки над всякими
[01:03:48.680 --> 01:03:50.680]  текстами.
[01:03:50.680 --> 01:03:52.680]  То есть там, говорят, промты,
[01:03:52.680 --> 01:03:54.680]  которые сейчас генерироваются, они иногда
[01:03:54.680 --> 01:03:56.680]  очень веселые. То есть там придумали
[01:03:56.680 --> 01:03:58.680]  свою собственную грамматику для того, чтобы
[01:03:58.680 --> 01:04:00.680]  вот это все закидывать.
[01:04:00.680 --> 01:04:02.680]  Там есть типа
[01:04:02.680 --> 01:04:04.680]  самое забавное, что там есть, это круглые скобки.
[01:04:04.680 --> 01:04:06.680]  Выделяете текст в круглые скобки,
[01:04:06.680 --> 01:04:08.680]  это означает,
[01:04:08.680 --> 01:04:10.680]  что нужно вес этого
[01:04:10.680 --> 01:04:12.680]  куска промта множить
[01:04:12.680 --> 01:04:14.680]  на один и один.
[01:04:16.680 --> 01:04:18.680]  Да, да, да.
[01:04:18.680 --> 01:04:20.680]  Я просто сработаю в этой сфере.
[01:04:20.680 --> 01:04:22.680]  Я фото о какой-нибудь beautiful
[01:04:22.680 --> 01:04:24.680]  и beautiful в трех
[01:04:26.680 --> 01:04:28.680]  круглых скобках.
[01:04:28.680 --> 01:04:30.680]  То есть увеличить на 33%.
[01:04:30.680 --> 01:04:32.680]  Ну, где-то так получилось.
[01:04:32.680 --> 01:04:34.680]  В принципе,
[01:04:34.680 --> 01:04:36.680]  так или иначе, ДСЛ языки
[01:04:36.680 --> 01:04:38.680]  жили, жить и будут жить.
[01:04:38.680 --> 01:04:40.680]  Вот, то есть это куда можно двигаться.
[01:04:40.680 --> 01:04:42.680]  Ну, и в целом, я думаю,
[01:04:42.680 --> 01:04:44.680]  что на этом мы, наверное,
[01:04:44.680 --> 01:04:46.680]  наш рассмотр курса
[01:04:46.680 --> 01:04:48.680]  закончим. На самом деле, в этот курс у нас,
[01:04:48.680 --> 01:04:50.680]  в этом году у нас курс какой-то
[01:04:50.680 --> 01:04:52.680]  даже более продвинутый вышел.
[01:04:52.680 --> 01:04:54.680]  Видимо, тут уже собрались просто
[01:04:54.680 --> 01:04:56.680]  плюс-минус специалисты, которые
[01:04:56.680 --> 01:04:58.680]  уже с этим работают.
[01:04:58.680 --> 01:05:00.680]  Так или иначе,
[01:05:00.680 --> 01:05:02.680]  изучают языки, это отлично.
[01:05:02.680 --> 01:05:04.680]  То есть в этот раз уже даже
[01:05:04.680 --> 01:05:06.680]  было две целых новых темы.
[01:05:06.680 --> 01:05:08.680]  Даже несмотря на то, что у нас количество лекций
[01:05:08.680 --> 01:05:10.680]  было чуть меньше.
[01:05:10.680 --> 01:05:12.680]  Мы смотрим на Волг Волшебный
[01:05:12.680 --> 01:05:14.680]  на выходные дни.
[01:05:14.680 --> 01:05:16.680]  Особенно на
[01:05:16.680 --> 01:05:18.680]  Волшебный, значит, 20 апреля,
[01:05:18.680 --> 01:05:20.680]  который был.
[01:05:20.680 --> 01:05:22.680]  20 апреля, значит, Волшебный был,
[01:05:22.680 --> 01:05:24.680]  когда сделали рабочую субботу.
[01:05:24.680 --> 01:05:26.680]  Ветка встанет, что-то такое, когда
[01:05:26.680 --> 01:05:28.680]  встанет.
[01:05:28.680 --> 01:05:30.680]  Ну, наверное,
[01:05:30.680 --> 01:05:32.680]  на этом все тогда.
[01:05:32.680 --> 01:05:34.680]  Если есть вопросы,
[01:05:34.680 --> 01:05:36.680]  задавайте.
[01:05:36.680 --> 01:05:38.680]  Всем, кто внезапно на YouTube
[01:05:38.680 --> 01:05:40.680]  досмотрел
[01:05:40.680 --> 01:05:42.680]  эту штуку в конце, вы большие
[01:05:42.680 --> 01:05:44.680]  молодцы.
