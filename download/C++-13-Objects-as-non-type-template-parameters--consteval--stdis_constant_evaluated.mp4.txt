[00:00.000 --> 00:17.760]  Ну начнем мы с чего-то достаточно безобидного. В прошлый раз мы, кажется, пообсуждали,
[00:17.760 --> 00:27.320]  что можно делать в Compile Time, начиная с C++20. Давайте в этот раз мы поговорим вот о чем.
[00:27.320 --> 00:45.520]  Пункт 16.2 я назову objects as non-type template parameters.
[00:45.520 --> 00:59.960]  Ну вы уже поняли по названию, что это такое. Начиная с C++20 параметрами шаблонов могут быть
[00:59.960 --> 01:11.080]  объекты классов. Ну почему бы и нет, ведь мы же уже научились все это создавать в Compile Time,
[01:11.080 --> 01:18.200]  строки создавать в Compile Time, векторы создавать в Compile Time, мы объекты умеем создать в Compile Time,
[01:18.200 --> 01:24.360]  конструкторы, деструкторы, constexpr делать, new вызывать в конце концов в Compile Time мы умеем.
[01:24.360 --> 01:32.280]  Вот так почему бы тогда не сделать следующий логичный шаг и не разрешить параметрам шаблонов
[01:32.280 --> 01:48.600]  быть объектами классов. Вот. Ну я здесь, наверное, даже не буду сам код писать,
[01:48.600 --> 01:59.200]  а просто покажу пример из книжки. Вот есть такая книжка C++20 complete guide. Она, впрочем,
[01:59.200 --> 02:07.720]  бесплатно не скачивается, и нужно иметь еще нероссийскую карточку, чтобы ее оплатить,
[02:07.720 --> 02:15.000]  даже если вы хотите. Но, тем не менее, примеры из нее вот я вам сейчас покажу. Вот пример того,
[02:15.000 --> 02:23.480]  как мы можем использовать, например, какой-то объект как параметр шаблона. Смотрите,
[02:23.480 --> 02:36.760]  что здесь происходит. У меня есть функция addText, которая принимает число, а в качестве шаблонного
[02:36.760 --> 02:49.480]  параметра она принимает объект. Вот. У меня есть структура, которая содержит... структура,
[02:49.520 --> 02:54.400]  которая содержит... не, пока это еще нормально, это еще не так страшно. Структура,
[02:54.400 --> 03:04.920]  которая содержит double. Вот. И поскольку я объект этой структуры передаю в... создаю
[03:04.920 --> 03:17.880]  как constexpr, я могу его использовать как шаблонный параметр функции. Ну вы поняли, да? Ну то есть это
[03:17.880 --> 03:28.000]  некоторое... до этого вас должно было такое возмущать. У вас должна была возникать мысль,
[03:28.000 --> 03:34.400]  что так же нельзя, это же не скомпилируется. Ну вот, начиная с C++20, это должно компилироваться. То есть
[03:34.400 --> 03:41.640]  мы спокойненько constexpr объекты как шаблонные параметры отдаем параметр шаблона. Нормально.
[03:41.640 --> 03:51.840]  Можно даже вот так. Да-да, даблы тоже можно делать. Во-первых, начиная с C++20 можно делать
[03:51.840 --> 03:58.480]  шаблонными параметрами не только целочисленной величины, но и даблы и все прочее. С каким округлением?
[03:58.480 --> 04:10.200]  Я все еще не понимаю вопроса, а что с ним работать-то? Она будет как обычно, ну а что? Что такое?
[04:10.200 --> 04:21.720]  Если мы передадим в tracks 3 и передадим 1 плюс 2, ну или что-то 0.3 или 0.1 плюс 0.2, это же будут разные tracks.
[04:21.720 --> 04:32.000]  Ну, я думаю, да. Это твои проблемы просто. Вот, и даже я могу вот здесь undervalue написать,
[04:32.000 --> 04:36.680]  то есть я написал некоторые expression здесь внутри шаблонных внутриугловых скобок,
[04:36.680 --> 04:46.240]  который ну просто в compile-time-е вычислился. Поскольку конструктор text у меня тоже constexpr,
[04:46.240 --> 04:53.600]  я могу в compile-time-е вычислить такой expression и отдать его как шаблонный параметр туда. Вот,
[04:53.600 --> 05:01.160]  следующий пример. Это, да, ну во-первых, теперь приходит в голову следующая идея. Окей,
[05:01.160 --> 05:06.920]  мы поняли, что шаблонными параметрами могут быть, может быть, уже много чего.
[05:06.920 --> 05:09.840]  Давайте делать шаблонные стримги, шаблонные виктороны.
[05:09.840 --> 05:16.400]  Не-не, другая идея, более радикальная. А нельзя ли сделать шаблонным параметром?
[05:16.400 --> 05:19.680]  Шаблонным. Это мы еще до 7 плюс 11 умели.
[05:19.680 --> 05:24.760]  Нельзя ли заставить компилятор сам отгадать, что мы передали в шаблонный параметр?
[05:24.760 --> 05:28.480]  Типа авто. Конечно. Ну, ведь у нас шаблонным
[05:28.480 --> 05:33.040]  параметром теперь, как и параметром функций, могут быть int, double, char и все что угодно,
[05:33.040 --> 05:40.160]  объекты. Давайте разрешим шаблонным параметром делать авто, и пусть компилятор сам отгадывает,
[05:40.160 --> 05:45.280]  что стало шаблонным параметром. Так тоже можно делать, начиная си плюс плюс 20. Вот,
[05:45.280 --> 05:53.120]  мы прекрасным образом, значит, это пишем. Вот, но надо здесь сказать, что когда мы пишем авто в
[05:53.120 --> 05:57.480]  шаблонном параметре, подразумевается, что это должен быть именно объект. Ну, это должен быть
[05:57.480 --> 06:07.240]  переменная. То есть, если мы отдадим typeName, шаблонный параметр, то мы не сможем... ну,
[06:07.240 --> 06:12.840]  авто не выведется. Логично. Да, ну давайте, вот давайте этот пример я разберу. Так,
[06:12.840 --> 06:16.080]  для начала надо понять, у нас вообще этот код компилируется с прошлого раза или нет.
[06:16.080 --> 06:32.080]  Да, это хороший вопрос. Сейчас, у нас тут, значит, какие-то были артефакты с прошлого раза,
[06:32.080 --> 06:42.360]  я уже забыл, что мы тут. Ну, короче, я просто вот эту удалю и эту тоже удалю. Теперь я ни от
[06:42.360 --> 06:46.680]  чего не вызываюсь, я должен компилироваться. Отлично. Вот, ну давайте, я попробую завести
[06:46.680 --> 06:58.440]  какой-нибудь шаблон с шаблонным параметром авто. AfterX. Вот. StructTest. А constexpr-seout есть?
[06:58.440 --> 07:03.840]  constexpr-seout бессмысленный, потому что ты не можешь в compile-time его выводить. Ты уже задавал,
[07:03.840 --> 07:10.280]  кажется, этот вопрос. Что? Ну, кто-то в прошлый раз задавал вопрос. constexpr-seout нет, нету constexpr.
[07:10.520 --> 07:17.960]  Ну, в смысле, оператор вывода не constexpr, потому что это уже, ну, вопрос, что бессмысленно,
[07:17.960 --> 07:23.240]  а что бессмысленно, конечно, уже такой немного философский. Кто-то может сказать, что пять лет
[07:23.240 --> 07:29.240]  назад, что и new в compile-time дело бессмысленно, но, в общем, пока мы считаем, что нет. Вывод
[07:29.240 --> 07:38.840]  seout в compile-time делать нельзя. Так, ну, я не знаю, давайте там вот напишем value. Вот, и какое-нибудь
[07:38.840 --> 07:52.760]  там сделаем. Ну, не знаю. Ну, хотя бы просто так напишем. То есть вот давайте я, например, скажу,
[07:52.760 --> 08:12.360]  что у меня будет тест с шаблонным параметром 5 и тест с шаблонным параметром 2.07. Вот, и,
[08:12.360 --> 08:22.440]  так не работает. Ай, да, я ерунду написал. Ну, давайте тогда какой бы пример здесь
[08:22.440 --> 08:37.800]  сделать, какой надо сделать пример. декл-тайп от X. Да, декл-тайп от X, почему бы и нет. Замечательно.
[08:37.800 --> 08:48.040]  Компилируем. Работает. Ничего не выводит. Вот, ну, я могу попробовать написать здесь
[08:48.040 --> 09:06.640]  какой-нибудь статик ассерт, что это is-same, is-same-v, а, ой, Господи, декл-тайп. Так, нет, плохо.
[09:06.640 --> 09:13.320]  Что же мне написать-то? Ладно, я не придумал, что здесь написать, но, в общем, ничего не буду.
[09:13.320 --> 09:34.360]  Где? Ну, можно, а зачем? Ну, от этого, по идее, ничего не поменяется. Ну, смысл в том, что я объект
[09:34.480 --> 09:45.280]  создал, Господи, в ран-тайме, просто авто все равно в компилтайме подставилось. В каком компиляторе?
[09:45.280 --> 09:57.320]  Вот, видите, а g++11 ты уже поддерживаешь. Ну, вот здесь еще один пример от Николая Джасатиса,
[09:57.320 --> 10:05.360]  который показывает это на примере использования строк. А, я понял, Silaim подчеркивает, но он уже
[10:05.360 --> 10:13.560]  справляется. Примере использования строк. Ну, давайте посмотрим, что здесь происходит. Во, здесь
[10:13.560 --> 10:21.200]  есть темплейт с шаблонным параметром prefix. Logger. Что делает Logger? Он берет message, он, короче,
[10:21.200 --> 10:26.680]  логирует все сообщения, но каждый из них предваряет некоторым префиксам. Отличный класс. И этот префикс
[10:26.680 --> 10:34.200]  это шаблонный параметр, который авто. Вот. И вот, я говорю, Logger с шаблонным параметром вот таким.
[10:34.200 --> 10:49.360]  Сделай Log. А str это класс, который в себе содержит массив чаров и умеет конструироваться от массива
[10:49.360 --> 10:54.880]  чаров. Да, можно было бы и str. То есть, можно было бы сюда передать объект. То есть, я мог бы здесь
[10:54.880 --> 11:03.560]  написать constexpr, там, str, s равно чему-то, и отдать ее в Logger. И получился бы Logger, который... два
[11:03.560 --> 11:17.640]  разных Logger. Один от такого класса, другой от str. Ну, думаю, тоже можно. Я, правда, не знаю,
[11:17.640 --> 11:21.360]  как это бы работало. Ну, указатели тоже можно делать с шаблонными параметрами, начиная с
[11:21.440 --> 11:37.880]  20. Ну, кажется, да. Кажется, это должно работать. Вот. Ну, давайте проверим просто. Я сейчас просто
[11:37.880 --> 11:53.520]  этот код скопипащу. Не знаю, давайте nttp objects. Ну, я хочу попробовать обычную строку,
[11:53.520 --> 12:05.600]  сишную, отдать туда как шаблонный параметр. Logger, abcd, Logger2. Вот. Ну, давайте проверим,
[12:05.600 --> 12:21.920]  что это компилируется. Значит, nttp objects. Нет, const char звездочкой не может почему-то. Вот.
[12:21.920 --> 12:29.720]  Строковые литералы, значит, он все-таки не разрешает. Но str string он, по идее,
[12:29.720 --> 12:35.480]  должен разрешить. Правда str string, как мы знаем, он меня не поддерживает, g plus 11, как const export,
[12:35.480 --> 12:41.160]  поэтому он не разрешит вместо str. Но вот это вполне разрешило. Вот. Ну, и совсем бронебойный
[12:41.160 --> 12:49.480]  пример. Вот. Прежде чем вам показать совсем бронебойный пример, надо вспомнить про то,
[12:49.480 --> 12:59.400]  что такое constant expressions. Помните, я вам показывал список того, чем не могут быть constant
[12:59.400 --> 13:15.080]  expressions. Так, сейчас давайте я все-таки откроюсь периференс один раз. Чего? Не-не, recurrent template
[13:15.080 --> 13:27.240]  pattern это другом. У меня есть вот такое вот, значит, constant expressions. И здесь был такой
[13:27.240 --> 13:33.480]  замечательный пункт, что до C++17, ну, вот это список того, что не является core constant expressions.
[13:33.480 --> 13:39.640]  То есть, что не может быть, что не может использована в const export контексте. И тут написано лямда
[13:39.640 --> 13:46.320]  expression до C++17. Кто-то в прошлый раз спрашивал, можно ли лямду делать const export. Начиная с C++17
[13:46.320 --> 13:56.160]  можно. То есть, лямду можно трактовать как const, ну, как compile time, ну, короче, как
[13:56.160 --> 14:04.080]  constant expression. То есть, можно инициализировать объект лямбы, лямды в compile time. Можно писать
[14:04.080 --> 14:12.840]  const export auto f равно некоторой лямбда. И лямда, корректный constant expression, он вполне себе в
[14:12.840 --> 14:24.440]  compile time инициализируется. Вот. Отсюда интересное следствие. Начиная с C++20, ну, там есть еще
[14:24.440 --> 14:30.400]  некоторые ограничения. Не вообще все объекты могут быть параметрами шаблона. Там есть список того,
[14:30.400 --> 14:37.080]  какие должны удовлетворять свойствами, а не чтобы были. Вот, кстати, можно попробовать вот здесь
[14:37.080 --> 14:53.400]  вот спросить structural type site in cpp-reference.com. Нет, он не понимает, что это такое. Ладно,
[14:53.400 --> 15:15.240]  давайте так спросим. Да. Значит... Начиная с C++20, здесь где-то должно быть написано...
[15:15.240 --> 15:24.760]  Не написано. Короче, я не помню, на какой именно страничке это написано.
[15:25.360 --> 15:53.360]  template non-type arguments. Начиная с C++17. Не знаю, почему здесь на этой странице не написано.
[15:53.360 --> 16:01.920]  Ладно, бог с ним. Ну, короче, есть некоторый набор ограничений, каким не может быть этот объект.
[16:01.920 --> 16:08.680]  Но, в общем, лямда удовлетворяет этим ограничениям. Я к чему? Я к тому, что объект лямды, сам в себе
[16:08.680 --> 16:21.680]  объект лямды, может быть аргументом шаблона. Не тип, а объект. И lambda expression может выступать
[16:21.680 --> 16:30.760]  в роли шаблонного параметра. Ну, короче, что просто тут тянуть? Вот вам пример. То есть,
[16:30.760 --> 16:36.560]  смотрите, что... А, да, во-первых, здесь еще один интересный момент. Я могу не просто авто писать,
[16:36.560 --> 16:44.800]  а концепт в шаблоне писать. Авто. Напоминаю, просто авто это означает, что сам догадайся,
[16:44.800 --> 16:50.000]  какой тип я передал. Но также мы с вами в прошлый раз обсуждали концепты, и я говорил, что можно
[16:50.000 --> 16:56.440]  в шаблонах писать, шаблонными параметрами делать концепты. Вот нужно понимать разницу между
[16:56.440 --> 17:02.960]  просто авто как параметром шаблона, stdinvokable как параметр шаблона и stdinvokable авто как
[17:02.960 --> 17:10.200]  параметр шаблона. Все ли понимают это? Три разных вещи. stdinvokable без авто означало бы, что параметром
[17:10.200 --> 17:16.240]  шаблона является некий тип, который обязан удовлетворять концепту stdinvokable. Авто означает,
[17:16.240 --> 17:21.360]  что параметром шаблона является некий объект без каких-либо ограничений, ну кроме тех, что
[17:21.360 --> 17:27.520]  стандартом наложены. А stdinvokable авто означает, что параметром шаблона является объект, тип
[17:27.520 --> 17:35.520]  которого удовлетворяет концепту stdinvokable. И вот мы в качестве параметра шаблона передаем объект,
[17:35.520 --> 17:43.760]  объект лямбда. Причем здесь очень интересно, что, вот это кстати я сам до конца не понимаю,
[17:44.000 --> 17:49.920]  это очень интересно, что здесь констэкспорт не написано. Ну видимо он констэкспорт. Кажется,
[17:49.920 --> 17:54.360]  там есть какое-то правило в стандарте, что лямбды являются констэкспорами по умолчанию, начиная с
[17:54.360 --> 17:59.960]  какой-то версии. Если я даже не написал авто, да вот здесь вот почему-то не написано констэкспорт,
[17:59.960 --> 18:05.600]  тем не менее оно компилируется. Почему вообще можем верить, что лямбда это констэкспорт?
[18:05.600 --> 18:10.600]  Я не знаю, почему это работает. Согласно какому-то пункту стандарта, так можно.
[18:36.600 --> 18:44.600]  Вот. Ну, короче, я могу эту штуку сюда вставить и проверить, что она тоже компилируется.
[18:44.600 --> 18:48.600]  Только мне мейн придется, правда, заменить. Ну, ничего страшного.
[18:52.600 --> 18:56.600]  Все, компилируется, и видите, даже выводят числа нужные.
[18:59.600 --> 19:01.600]  Так, я тут что-то намутан, конечно. Да.
[19:01.600 --> 19:05.600]  Да. Ладно, давайте я это просто удалю.
[19:09.600 --> 19:14.600]  Вот так. Нормально?
[19:18.600 --> 19:29.600]  Вот. Я мог бы, я думаю, передать в качестве шаблонного аргумента лямбду просто безпеременной.
[19:29.600 --> 19:38.600]  Вот это я, скорее всего, мог бы сделать вообще без проблем. То есть я могу здесь сказать return 0.35 и нормально.
[19:38.600 --> 19:45.600]  То есть я передал в шаблон лямбда expression. Все, компилируется.
[19:45.600 --> 19:50.600]  Получается, можно написать все четыре дискобыча подряд. Ну, почти подряд.
[19:50.600 --> 20:08.600]  Вот, на самом деле этот, на самом деле C++20, вот Николай Джасатис, который является одним из членов комитета и который как раз написал большую книжку про C++20 и все его возможности,
[20:08.600 --> 20:21.600]  он там в предисловии говорит, что, возможно, даже не в предисловии, а в аннотации, что C++20, он огромный и, возможно, он изменит то, как мы пишем код на C++ еще сильнее, чем C++11.
[20:21.600 --> 20:25.600]  Просто пока еще очень мало кто в мире знает все его возможности.
[20:25.600 --> 20:40.600]  То есть, на самом деле, они дофига чего добавили. И вот то, что я вам сейчас показываю, это такое вот, ну, это вещи, которые мало где используются, но вот, скорее всего, в ближайшие 5 лет люди будут активно их изучать везде, во всех компаниях и начинать внедрять.
[20:40.600 --> 20:53.600]  И прям, вероятно, код на плюсах, который будет писаться где-либо через 5 лет, человек, который учился 5 лет назад, уже не узнает, что происходит.
[20:53.600 --> 20:57.600]  C++20 это действительно очень большой...
[20:57.600 --> 20:59.600]  То есть, это мы сейчас учимся 5 лет назад?
[20:59.600 --> 21:07.600]  Не-не, 5 лет по сравнению с вами. Вы-то уже, видите, вы-то уже ознакомились, вы хотя бы будете понимать, что это здесь написано, вот, но...
[21:07.600 --> 21:09.600]  Почему это принципиально меняется?
[21:09.600 --> 21:10.600]  Вот непонятно, да?
[21:10.600 --> 21:11.600]  Почему?
[21:11.600 --> 21:12.600]  Почему?
[21:12.600 --> 21:16.600]  Понятно, что такое std move, std, все на свете, и т.д.
[21:16.600 --> 21:17.600]  А здесь...
[21:17.600 --> 21:22.600]  Ну, во-первых, сами по себе концепты очень много добавляют, ну...
[21:22.600 --> 21:24.600]  Это просто какие-то ограничения?
[21:24.600 --> 21:29.600]  Концепты, это новый элемент синтаксиса, который просто...
[21:29.600 --> 21:33.600]  С помощью которых можно переосмыслить многие части стандарта и написать их лучше.
[21:33.600 --> 21:38.600]  Ну, там, написать многие части стандарта библиотеки лучше, чем они ранее были написаны.
[21:38.600 --> 21:40.600]  Вот, просто мы еще пока не...
[21:40.600 --> 21:44.600]  Не-не-не смотрели на все вот эти вот части.
[21:44.600 --> 21:54.600]  Ну, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то, в общем-то.
[21:55.600 --> 22:00.600]  Не-не-не смотрели на все вот эти вот части с новой точки зрения.
[22:00.600 --> 22:05.600]  Вот если мы, зная концепты, снова проанализировали все, что мы ранее писали,
[22:05.600 --> 22:08.600]  и везде подумали, какой бы концепт добавить,
[22:08.600 --> 22:11.600]  то, возможно, код бы сильно видоизменился.
[22:11.600 --> 22:14.600]  То есть представьте просто, что всякий раз, когда вы добавляете шаблонный параметр,
[22:14.600 --> 22:18.600]  вы не просто type name пишете, а концепт пишете.
[22:18.600 --> 22:23.600]  Или вы добавляете шаблонный параметр, вы помните, что он может быть и объектом.
[22:23.600 --> 22:28.600]  И вы, например, некоторые вещи, которые и так можно в compile-time заранее предугадать,
[22:28.600 --> 22:31.600]  делаете просто объектами, которые являются шаблонными параметрами.
[22:31.600 --> 22:33.600]  Представьте, что вы лямды можете делать шаблонными параметрами.
[22:33.600 --> 22:38.600]  Ну, короче, это открывает большую свободу и может видоизменить логику кода сильно.
[22:38.600 --> 22:40.600]  Ладно, с объектами, шаблонными параметрами.
[22:40.600 --> 22:44.600]  Не, ну, подожди, Илья, вот у нас, например, раньше были constexpr функции,
[22:44.600 --> 22:47.600]  которые мы в compile-time равно также могли передавать аргументы.
[22:47.600 --> 22:50.600]  Только теперь мы аргументы пишем не в круглых скобочках, а в углу.
[22:50.600 --> 22:52.600]  Ну а какая разница?
[22:52.600 --> 22:56.600]  Слушай, ну, ты говоришь, по сути, ну...
[22:58.600 --> 23:01.600]  Ну, я не знаю, непонятно, о чем спор.
[23:02.600 --> 23:09.600]  Я утверждаю, что просто синтоксически сильно много чего стало по-другому можно делать.
[23:09.600 --> 23:11.600]  И, возможно, это стало удобнее.
[23:11.600 --> 23:18.600]  И, возможно, код через пять лет будет выглядеть иначе принципиально, чем он выглядел там пять лет назад.
[23:18.600 --> 23:23.600]  Просто некоторые идеи, как можно выражать мысли в коде, они вот...
[23:25.600 --> 23:29.600]  Ты, как бы, и до 7++11 функционально ничего не добавилось.
[23:29.600 --> 23:34.600]  У тебя и до 7++11 из-за шаблонового метапрограммирования был полон по тюрингу.
[23:34.600 --> 23:38.600]  До прихода constexpr ты мог также говорить, ну, что добавилось со шаблонов constexpr?
[23:38.600 --> 23:42.600]  Я же и раньше мог шаблонную рекурсию делать, и как бы все бы тоже самое было.
[23:42.600 --> 23:45.600]  Мог-то ты мог, но просто синтоксис был уродский.
[23:45.600 --> 23:49.600]  Вот, то же самое здесь. Вот, например, у тебя были концепты, а раньше был enable их.
[23:50.600 --> 23:53.600]  Ты и раньше мог все то же самое делать, просто уродским синтоксисом.
[23:54.600 --> 23:56.600]  А вот это что красивее?
[23:56.600 --> 23:57.600]  Да.
[23:59.600 --> 24:01.600]  Не, ну концепты точно красивее.
[24:01.600 --> 24:05.600]  Помни проверку на простопу, которую приходилось писать в матриксе?
[24:05.600 --> 24:08.600]  И пойми, что сейчас это буквально одна трансляция.
[24:09.600 --> 24:10.600]  Что?
[24:10.600 --> 24:11.600]  Кстати, да.
[24:16.600 --> 24:23.600]  Ну, ты можешь, вообще ты можешь просто делать, как будто даже концепт просто, чтобы просто принимать простое число каким-то.
[24:23.600 --> 24:24.600]  Да.
[24:24.600 --> 24:25.600]  Да.
[24:25.600 --> 24:26.600]  Конечно.
[24:26.600 --> 24:29.600]  Ты можешь буквально сделать концепт, принимающий только простое число.
[24:30.600 --> 24:32.600]  О, как это сделать?
[24:32.600 --> 24:34.600]  Ну, ты же делал как-то.
[24:35.600 --> 24:38.600]  Ну, у тебя была эта функция...
[24:38.600 --> 24:42.600]  Не, ну, тебе надо там не концепт, концепт это все-таки ограничение на тип.
[24:42.600 --> 24:43.600]  Ну, вот именно концепт.
[24:43.600 --> 24:44.600]  Да.
[24:44.600 --> 24:49.600]  Тебе нужно скорее написать какой-нибудь requires там будет, а не концепт просто.
[24:49.600 --> 24:50.600]  Концепт, да.
[24:50.600 --> 24:54.600]  С этим мы в прошлый раз не разобрались, как писать requires, не в контексте.
[24:54.600 --> 24:55.600]  По-моему, разобрались.
[24:55.600 --> 24:57.600]  Не в контексте шаблонного типа...
[24:57.600 --> 24:58.600]  А, это да?
[24:58.600 --> 24:59.600]  Да.
[24:59.600 --> 25:01.600]  Ну, например, в mining мы не смогли написать.
[25:01.600 --> 25:03.600]  Ну, потому что у нас шаблона не было никакого.
[25:03.600 --> 25:05.600]  Так не в контексте шаблона и нельзя, да.
[25:06.600 --> 25:08.600]  Не в контексте шаблона будет CE просто.
[25:08.600 --> 25:09.600]  Ну, он...
[25:09.600 --> 25:11.600]  Ну, в контексте шаблона...
[25:11.600 --> 25:12.600]  В контексте...
[25:12.600 --> 25:14.600]  Ну, просто requires оценивается в момент...
[25:14.600 --> 25:16.600]  Вычисляется в момент, когда делает шаблонная подстановка.
[25:17.600 --> 25:21.600]  И в зависимости от того, корректная она или нет, он либо CE кидает, либо не кидает.
[25:21.600 --> 25:23.600]  Ну, в смысле, либо true, либо false возвращает.
[25:24.600 --> 25:27.600]  А если requires это в...
[25:28.600 --> 25:31.600]  В сигнатуре функции, да, то он либо включает ее, либо включает.
[25:32.600 --> 25:34.600]  Ну ладно, короче, можно долго языком болтать.
[25:35.600 --> 25:39.600]  Все понятно, что много чего теперь можно писать по-другому.
[25:39.600 --> 25:40.600]  Вот.
[25:40.600 --> 25:46.600]  Кто будет на плюсах писать после того, как этот курс закончится.
[25:47.600 --> 25:48.600]  Вот.
[25:48.600 --> 25:51.600]  Вы знаете, что можно и так тоже.
[25:51.600 --> 25:52.600]  Вот, живите с этим.
[25:52.600 --> 25:54.600]  Думайте, как это использовать.
[25:55.600 --> 26:01.600]  А еще пара вещей тоже про C++20.
[26:02.600 --> 26:06.600]  А следующая вещь, которую я хочу рассказать, это...
[26:06.600 --> 26:10.600]  Еще одно важное, на мой взгляд, слово называется const-eval.
[26:13.600 --> 26:16.600]  И давайте это будет пункт 16.3.
[26:21.600 --> 26:26.600]  const-eval и std isConstantEvaluated.
[26:27.600 --> 26:28.600]  Evaluated.
[26:34.600 --> 26:45.600]  До C++20 у нас было, по сути, только одно слово, которое обозначало, что функция или переменная должна быть...
[26:48.600 --> 26:50.600]  Вычислена проинтересированный этап компиляции.
[26:50.600 --> 26:51.600]  constexpr.
[26:51.600 --> 26:52.600]  Вот.
[26:52.600 --> 26:58.600]  Но, как вы помните, constexpr применительно к функции означает, что она может быть вычислена как в компайлтайме, так и в рантайме.
[26:59.600 --> 27:02.600]  Зависит от того, в каком контексте она вызвана.
[27:02.600 --> 27:03.600]  Вот.
[27:03.600 --> 27:10.600]  Спустя некоторое время может возникнуть естественное желание для некоторых функций запретить, чтобы они могли вызываться в рантайме.
[27:10.600 --> 27:18.600]  То есть, вы хотите написать функцию, которую хотите вызывать только в компайлтайме, и не позволять ее вызывать не из компайлтайма контекста.
[27:18.600 --> 27:19.600]  Из правил.
[27:20.600 --> 27:22.600]  Ну, какую угодно.
[27:22.600 --> 27:23.600]  Вот.
[27:23.600 --> 27:25.600]  constexpr это не то.
[27:25.600 --> 27:29.600]  constexpr позволяет вам себя вызывать из не компайлтайма контекста.
[27:29.600 --> 27:34.600]  Таким образом, вы не проверите, что любое использование этой функции делается только в компайлтайме.
[27:34.600 --> 27:41.600]  В C++20 появилось новое ключевое слово, которое позволяет вам делать именно это, называется consteval.
[27:41.600 --> 27:45.600]  У меня, скорее всего, он тоже не подсветит его, к сожалению.
[27:45.600 --> 27:47.600]  О, у вас тынит еще какой-то есть.
[27:47.600 --> 27:50.600]  Еще есть consteнит, о нем я расскажу в следующем пункте.
[27:50.600 --> 27:51.600]  Сначала...
[27:51.600 --> 27:53.600]  consteval это питоновский вал завезли?
[27:53.600 --> 27:55.600]  consteval.
[27:55.600 --> 27:58.600]  Ну, давайте, блин, зря я, наверное, этот...
[27:59.600 --> 28:01.600]  Зря я новый файл создал.
[28:01.600 --> 28:03.600]  Я лучше вернусь вот к этому файлу.
[28:03.600 --> 28:06.600]  Здесь у нас есть функция constexpr.
[28:06.600 --> 28:09.600]  У нас есть несколько constexpr функций, да.
[28:09.600 --> 28:11.600]  Давайте я...
[28:11.600 --> 28:13.600]  какие-то из них назову consteval функциями.
[28:13.600 --> 28:15.600]  Например...
[28:15.600 --> 28:18.600]  Ну, например, вот эту функцию я сейчас consteval объявлю.
[28:18.600 --> 28:23.600]  К сожалению, я не успел наладить, чтобы у меня подсветка была для C++20, но это тоже ключевое слово.
[28:23.600 --> 28:26.600]  Оно тоже как и constexpr зелененьким, по идее, должно быть подсвечено.
[28:26.600 --> 28:28.600]  Только с функцией.
[28:28.600 --> 28:31.600]  Да, consteval для переменных, насколько я знаю, не применим.
[28:33.600 --> 28:39.600]  Функция, которая объявлена как consteval, это так называемое, есть такой термин immediate function.
[28:39.600 --> 28:41.600]  Функция немедленная.
[28:41.600 --> 28:43.600]  Ну вот, immediate.
[28:43.600 --> 28:45.600]  Please proceed to the gate immediately.
[28:45.600 --> 28:47.600]  Ну вот.
[28:47.600 --> 28:49.600]  Если я попробую...
[28:49.600 --> 28:52.600]  эту функцию вызвать в обычном...
[28:52.600 --> 28:54.600]  в рантайме.
[28:54.600 --> 28:59.600]  std seout isPrime от, не знаю, 11.
[28:59.600 --> 29:02.600]  Часто будет ошибка компиляции.
[29:02.600 --> 29:05.600]  Потому что я не должен вызывать...
[29:07.600 --> 29:10.600]  Нет, это не ошибка компиляции, почему?
[29:11.600 --> 29:13.600]  Может быть, потому что мой...
[29:13.600 --> 29:15.600]  компилятор не поддерживает это.
[29:15.600 --> 29:18.600]  А почему он тогда consteval распознал?
[29:19.600 --> 29:21.600]  У меня тоже скомпилировался.
[29:24.600 --> 29:26.600]  Любопытно.
[29:26.600 --> 29:29.600]  Что, я неправильно понимаю, как работать consteval?
[29:41.600 --> 29:43.600]  Хорошо, давайте...
[29:45.600 --> 29:47.600]  Давайте откроем.
[29:47.600 --> 29:50.600]  Может есть какой-нибудь более правильный пример.
[29:50.600 --> 29:52.600]  Я, наверное, что-то забыл.
[30:05.600 --> 30:07.600]  А, ну...
[30:08.600 --> 30:10.600]  Значит...
[30:10.600 --> 30:12.600]  Вот сейчас это точно должно упасть.
[30:12.600 --> 30:14.600]  Я...
[30:14.600 --> 30:17.600]  сделаю что-нибудь такое, а потом проверю ifPrime от n.
[30:21.600 --> 30:23.600]  Да, вот это уже падает.
[30:25.600 --> 30:27.600]  Ну, я могу даже seout не делать.
[30:27.600 --> 30:29.600]  Я просто сказать intn равно...
[30:29.600 --> 30:30.600]  Нет, это понятно.
[30:30.600 --> 30:33.600]  Почему он с seout работал от единицы?
[30:33.600 --> 30:35.600]  От 11.
[30:35.600 --> 30:37.600]  От 11.
[30:37.600 --> 30:39.600]  Да.
[30:39.600 --> 30:41.600]  Значит...
[30:41.600 --> 30:43.600]  Пример был неправильный, вот правильный пример.
[30:43.600 --> 30:46.600]  Если я ifPrime вызываю от conste,
[30:46.600 --> 30:48.600]  то он...
[30:48.600 --> 30:50.600]  Ну, как бы...
[30:50.600 --> 30:55.600]  ifPrime это функция, которая может вычисляться только на этапе компиляции.
[30:55.600 --> 30:57.600]  И...
[30:57.600 --> 30:59.600]  контекст, которым она используется...
[30:59.600 --> 31:03.600]  Ну, не контекст, которым она используется, значит, а вот...
[31:04.600 --> 31:06.600]  Любое ее использование...
[31:06.600 --> 31:08.600]  должно...
[31:12.600 --> 31:14.600]  должно приводить к учтениям на этапе компиляции.
[31:14.600 --> 31:17.600]  Если я вызываю ее от константы, от 11,
[31:17.600 --> 31:19.600]  то он просто...
[31:19.600 --> 31:21.600]  вот это вычтение isPrime от 11
[31:21.600 --> 31:25.600]  в compile-time делает и в compile-time подставляет результат.
[31:25.600 --> 31:26.600]  Вот, то есть...
[31:26.600 --> 31:27.600]  Смотрите, как это работает.
[31:27.600 --> 31:29.600]  Получается, я...
[31:29.600 --> 31:32.600]  даже не обязательно в compile-time-контексте ее должен вызывать.
[31:32.600 --> 31:34.600]  В каком бы контексте я ее не вызвал,
[31:34.600 --> 31:37.600]  компилятор будет пытаться делать вычтение на этапе компиляции.
[31:37.600 --> 31:40.600]  Но если я ее вызвал от чего-то,
[31:40.600 --> 31:43.600]  что само не является constant expression,
[31:43.600 --> 31:44.600]  то вот это будет CE.
[31:44.600 --> 31:46.600]  Потому что он как бы видит,
[31:46.600 --> 31:48.600]  что isPrime от N должен вычислить в compile-time,
[31:48.600 --> 31:51.600]  но N не constant expression,
[31:51.600 --> 31:53.600]  поэтому от него нельзя в compile-time вычисляться.
[31:53.600 --> 31:55.600]  Вот, поэтому это падает.
[31:56.600 --> 31:59.600]  Вот, еще есть такой интересный...
[32:00.600 --> 32:01.600]  пример.
[32:01.600 --> 32:03.600]  Ну, на самом деле, довольно полезно, на мой взгляд,
[32:03.600 --> 32:05.600]  потому что, получается, вы можете гарантировать себе,
[32:05.600 --> 32:09.600]  что некоторые вещи вы всегда в compile-time будете вычислять.
[32:10.600 --> 32:13.600]  И есть такой достаточно интересный...
[32:16.600 --> 32:18.600]  А, ну вот, пример с...
[32:21.600 --> 32:23.600]  пример с...
[32:25.600 --> 32:27.600]  с CVPerference,
[32:27.600 --> 32:29.600]  factorial,
[32:29.600 --> 32:31.600]  CE.
[32:34.600 --> 32:36.600]  Вот.
[32:45.600 --> 32:48.600]  И еще одно интересное, на мой взгляд, нововведение,
[32:48.600 --> 32:51.600]  о котором хочется рассказать,
[32:51.600 --> 32:56.600]  это вот такая вот функция из constant evaluated.
[32:57.600 --> 33:00.600]  Это встроенная в компилятор функция, начиная с C++20.
[33:00.600 --> 33:03.600]  Раньше она была compiling intrinsic,
[33:03.600 --> 33:07.600]  то есть в C++17 можно было писать двойное подчеркивание
[33:07.600 --> 33:08.600]  и какое-то там заклинание,
[33:08.600 --> 33:10.600]  ну, как раньше, может, для некоторых вещей было.
[33:10.600 --> 33:13.600]  Сейчас это является частью стандарта.
[33:13.600 --> 33:15.600]  Это проверка того,
[33:15.600 --> 33:17.600]  вы сейчас в compile-time вычисляетесь или нет.
[33:17.600 --> 33:19.600]  Опа.
[33:20.600 --> 33:22.600]  Опа.
[33:23.600 --> 33:25.600]  Что? А, стоп.
[33:25.600 --> 33:28.600]  То есть эта функция возвращает true тогда и только тогда,
[33:28.600 --> 33:31.600]  когда вы сейчас вычисляете ее в compile-time.
[33:31.600 --> 33:34.600]  А вот это уже полезно.
[33:35.600 --> 33:38.600]  И эта функция реализована компилятором,
[33:38.600 --> 33:40.600]  то есть ее реализовать самим нельзя, конечно.
[33:40.600 --> 33:41.600]  А вот это уже полезно.
[33:41.600 --> 33:43.600]  Она реализована как-то внутри компилятора.
[33:43.600 --> 33:45.600]  Типа, как лонгер?
[33:46.600 --> 33:48.600]  Нет, хуже.
[33:48.600 --> 33:51.600]  Ну, компилятор просто обязан эту функцию
[33:51.600 --> 33:53.600]  ее оценить в true,
[33:53.600 --> 33:56.600]  если он сейчас делает вычисление в момент компиляции
[33:56.600 --> 33:58.600]  и оценить ее вызов в false,
[33:58.600 --> 34:01.600]  если это вычисление...
[34:01.600 --> 34:03.600]  Место, где он ее встретил,
[34:03.600 --> 34:05.600]  является вычислением не на этапе компиляции.
[34:05.600 --> 34:07.600]  Вот это мне кажется.
[34:07.600 --> 34:08.600]  Вот это тоже полезно.
[34:08.600 --> 34:10.600]  В STD, а не просто какое-то ключевое слово.
[34:10.600 --> 34:12.600]  Не знаю.
[34:12.600 --> 34:14.600]  А лонгер разве не в STD лежит?
[34:14.600 --> 34:15.600]  Нет, ну, существует много функций,
[34:15.600 --> 34:17.600]  которые вы не можете реализовать сами.
[34:17.600 --> 34:19.600]  Раньше это было compiler-intrinsic, я говорю.
[34:19.600 --> 34:22.600]  То есть это раньше можно было написать, значит,
[34:22.600 --> 34:24.600]  с двумя подчеркивания, что-то там.
[34:24.600 --> 34:26.600]  А сейчас это часть стандарта стала.
[34:26.600 --> 34:28.600]  Вот.
[34:28.600 --> 34:30.600]  Давайте покажу вам пример.
[34:34.600 --> 34:36.600]  Ну, скажем.
[34:39.600 --> 34:41.600]  Я хочу написать возведение в степень.
[34:42.600 --> 34:45.600]  Число double в целую степень возвести.
[34:46.600 --> 34:48.600]  Смотрите, что я могу делать.
[34:49.600 --> 34:51.600]  Ну, классический пример.
[34:51.600 --> 34:53.600]  Если я сейчас в compile-time,
[34:53.600 --> 34:55.600]  то я пишу руками.
[34:55.600 --> 34:58.600]  А иначе вызываю STD пол
[34:58.600 --> 35:00.600]  от каких-то двух вещей.
[35:00.600 --> 35:03.600]  Ну, то есть у меня могут быть какие-то функции,
[35:03.600 --> 35:07.600]  которые не constexpr.
[35:07.600 --> 35:11.600]  Или какие-то алгоритмы сложные, например.
[35:11.600 --> 35:13.600]  Ну, первый пример.
[35:13.600 --> 35:15.600]  У меня функция, которая не constexpr, STD пол.
[35:15.600 --> 35:17.600]  Она не constexpr, насколько я помню.
[35:17.600 --> 35:19.600]  Пока еще.
[35:19.600 --> 35:21.600]  Счастье, хоть что-то не constexpr.
[35:21.600 --> 35:23.600]  Да.
[35:23.600 --> 35:25.600]  И ее я не могу в compile-time вызвать.
[35:25.600 --> 35:27.600]  Поэтому, если я пытаюсь там делать какую-то обертку
[35:27.600 --> 35:29.600]  над возведением...
[35:29.600 --> 35:31.600]  Если мне где-то нужно в каком-то своем коде обратиться
[35:31.600 --> 35:33.600]  к функции возведения в степень,
[35:33.600 --> 35:35.600]  я, конечно, понимаю, что STD пол, наверное,
[35:35.600 --> 35:37.600]  это делает эффективно.
[35:37.600 --> 35:39.600]  Или там STD, не знаю, сим, какое-нибудь вычление,
[35:39.600 --> 35:41.600]  какое-нибудь математическое синусо.
[35:41.600 --> 35:43.600]  Оно, наверное, это дело хорошо, эффективно, быстро,
[35:43.600 --> 35:45.600]  но не constexpr.
[35:45.600 --> 35:47.600]  А я не знаю, я в compile-time сейчас нахожусь
[35:47.600 --> 35:49.600]  или нет.
[35:49.600 --> 35:51.600]  Вот я в constexpr функции
[35:51.600 --> 35:53.600]  могу не знать, я в compile-time
[35:53.600 --> 35:55.600]  или нет нахожусь сейчас.
[35:55.600 --> 35:57.600]  Я могу написать такое, если
[35:57.600 --> 35:59.600]  я в compile-time,
[35:59.600 --> 36:01.600]  то я
[36:01.600 --> 36:03.600]  ручками вычисляю, а иначе вызываю
[36:03.600 --> 36:05.600]  функцию, которая в compile-time бы у меня
[36:05.600 --> 36:07.600]  кинула CE.
[36:07.600 --> 36:09.600]  Сейчас, а если я напишу
[36:09.600 --> 36:11.600]  и в constexpr, это другое немножко будет?
[36:11.600 --> 36:13.600]  Вот.
[36:13.600 --> 36:15.600]  Популярная
[36:15.600 --> 36:17.600]  заблуждение, я сам эту ошибку
[36:17.600 --> 36:19.600]  делал пару раз,
[36:19.600 --> 36:21.600]  прежде чем запомнил.
[36:21.600 --> 36:23.600]  Значит, из constant evaluated
[36:23.600 --> 36:25.600]  есть классическая
[36:25.600 --> 36:27.600]  наивная мысль,
[36:27.600 --> 36:29.600]  которая неверная.
[36:29.600 --> 36:31.600]  Почему не и в constexpr, ведь казалось бы,
[36:31.600 --> 36:33.600]  мы в compile-time должны проверять.
[36:33.600 --> 36:35.600]  Ну типа понятно, что там два варианта.
[36:35.600 --> 36:37.600]  Вот, на самом деле, если я пишу и в constexpr
[36:37.600 --> 36:39.600]  и пишу STD из constant evaluated
[36:39.600 --> 36:41.600]  под и в constexpr, то это
[36:41.600 --> 36:43.600]  нигда true.
[36:43.600 --> 36:45.600]  Потому что то, что вы под и в constexpr
[36:45.600 --> 36:47.600]  загнали,
[36:47.600 --> 36:49.600]  обязано быть вычислено на этапе компиляции.
[36:49.600 --> 36:51.600]  А значит,
[36:51.600 --> 36:53.600]  если вы под и в constexpr спросите
[36:53.600 --> 36:55.600]  из constant evaluated, вы получите
[36:55.600 --> 36:57.600]  true, независимо то, в каком контексте вы находитесь.
[36:57.600 --> 36:59.600]  Ладно, можно было
[36:59.600 --> 37:01.600]  генерировать две разные функции,
[37:01.600 --> 37:03.600]  в зависимости от, но да.
[37:03.600 --> 37:05.600]  Поэтому constexpr
[37:05.600 --> 37:07.600]  функции, где а смысл
[37:07.600 --> 37:09.600]  использовать из constant evaluated?
[37:09.600 --> 37:11.600]  В constexpr функции под
[37:11.600 --> 37:13.600]  обычным if, не под и в constexpr,
[37:13.600 --> 37:15.600]  а под обычным if.
[37:15.600 --> 37:17.600]  Тогда, если вы сейчас вычисляете
[37:17.600 --> 37:19.600]  эту функцию, находясь в compile-time,
[37:19.600 --> 37:21.600]  вы получите true
[37:21.600 --> 37:23.600]  и пойдете сюда,
[37:23.600 --> 37:25.600]  а это все не будет...
[37:25.600 --> 37:27.600]  Ой, наоборот, вы получите true и пойдете сюда,
[37:27.600 --> 37:29.600]  это не будет вызовано,
[37:29.600 --> 37:31.600]  и тем самым вы не получите CE.
[37:31.600 --> 37:33.600]  Вы не дойдете до вызова не constexpr
[37:33.600 --> 37:35.600]  функции в compile-time
[37:35.600 --> 37:37.600]  контексте.
[37:37.600 --> 37:39.600]  Да, ну, по сути, да,
[37:39.600 --> 37:41.600]  вы в compile-time
[37:41.600 --> 37:43.600]  не дойдете
[37:43.600 --> 37:45.600]  до этой строки, и поэтому
[37:45.600 --> 37:47.600]  это не будет CE. То есть у вас
[37:47.600 --> 37:49.600]  в constexpr функции есть вызов,
[37:49.600 --> 37:51.600]  не constexpr функции, но вы
[37:51.600 --> 37:53.600]  до него не добираетесь, поэтому это не CE.
[37:53.600 --> 37:55.600]  Повод это не constexpr функция?
[37:55.600 --> 37:57.600]  Повод это не constexpr, это статичная функция.
[37:57.600 --> 37:59.600]  Если бы я записал
[37:59.600 --> 38:01.600]  то, что под
[38:01.600 --> 38:03.600]  вычисляется
[38:03.600 --> 38:05.600]  в compile-time, и там написал
[38:05.600 --> 38:07.600]  что-то с const eval.
[38:07.600 --> 38:09.600]  Вот.
[38:09.600 --> 38:11.600]  Он бы, когда
[38:11.600 --> 38:13.600]  уже скомбилировал код,
[38:13.600 --> 38:15.600]  он бы все равно увидел этот
[38:15.600 --> 38:17.600]  const eval. Сейчас, я не понимаю, const eval
[38:17.600 --> 38:19.600]  ты где хочешь? Внутри части, которая
[38:19.600 --> 38:21.600]  в compile-time вычисляется.
[38:21.600 --> 38:23.600]  const eval, то как функция применима?
[38:23.600 --> 38:25.600]  Ну, там вызываю какую-то const eval функцию.
[38:25.600 --> 38:27.600]  Тогда, когда я скомбилировал
[38:27.600 --> 38:29.600]  код,
[38:29.600 --> 38:31.600]  там уже не runtime
[38:31.600 --> 38:33.600]  проверка, и он смотрит, что
[38:33.600 --> 38:35.600]  я эту функцию вызываю.
[38:35.600 --> 38:37.600]  Когда ты скомпилировал этот код,
[38:37.600 --> 38:39.600]  вместо вызова const eval функции, должна быть
[38:39.600 --> 38:41.600]  некоторая константа.
[38:41.600 --> 38:43.600]  В runtime не бывает вызова в const eval функции.
[38:43.600 --> 38:45.600]  Если ты скомпилировал
[38:45.600 --> 38:47.600]  код, в котором был вызов в const eval функции,
[38:47.600 --> 38:49.600]  то, когда компиляция закончилась,
[38:49.600 --> 38:51.600]  на месте этого вызова, некоторая константа должна стоять.
[38:51.600 --> 38:53.600]  В этом смысл const eval.
[38:53.600 --> 38:55.600]  Там я внутри написал
[38:55.600 --> 38:57.600]  const eval expr от x.
[38:57.600 --> 38:59.600]  Внутри чего?
[38:59.600 --> 39:01.600]  Внутри вот этого? Да, внутри вот этого блока,
[39:01.600 --> 39:03.600]  который на этапе компиляции вычисляется.
[39:03.600 --> 39:05.600]  Давай я просто копипащу
[39:05.600 --> 39:07.600]  этот код, и мы
[39:07.600 --> 39:09.600]  проделаем то, что ты предлагаешь.
[39:17.600 --> 39:19.600]  Так, вот у меня есть такая функция.
[39:21.600 --> 39:23.600]  И что ты предлагаешь делать?
[39:23.600 --> 39:25.600]  Я хочу внутрь compile time
[39:25.600 --> 39:27.600]  части засунуть
[39:27.600 --> 39:29.600]  вызов какой-то const eval функции
[39:29.600 --> 39:31.600]  от параметра,
[39:31.600 --> 39:33.600]  который
[39:33.600 --> 39:35.600]  может быть
[39:35.600 --> 39:37.600]  runtime-овским.
[39:37.600 --> 39:39.600]  Вот simf.
[39:39.600 --> 39:41.600]  Сейчас я проверю, что это так компилируется.
[39:41.600 --> 39:43.600]  Ты хочешь вот здесь
[39:43.600 --> 39:45.600]  написать что-то?
[39:45.600 --> 39:47.600]  Не здесь. А где?
[39:47.600 --> 39:49.600]  Внутри ifr. Хорошо.
[39:49.600 --> 39:51.600]  Что ты хочешь написать?
[39:51.600 --> 39:53.600]  Например, написать bool flag
[39:53.600 --> 39:55.600]  из prime от x,
[39:55.600 --> 39:57.600]  которая const eval у нас.
[39:59.600 --> 40:01.600]  Из prime от x.
[40:01.600 --> 40:03.600]  Она же const eval у нас?
[40:03.600 --> 40:05.600]  Из prime у нас const eval, да.
[40:05.600 --> 40:07.600]  И ты спрашиваешь, что будет,
[40:07.600 --> 40:09.600]  если ты вызовешься в runtime-е?
[40:09.600 --> 40:11.600]  Я могу вызваться ее
[40:11.600 --> 40:13.600]  и в runtime, и в compile time.
[40:13.600 --> 40:15.600]  В compile time все будет нормально.
[40:15.600 --> 40:17.600]  Нет, ты не можешь вызваться в runtime.
[40:17.600 --> 40:19.600]  А в runtime-е как раз вопрос
[40:19.600 --> 40:21.600]  типа, что...
[40:21.600 --> 40:23.600]  Если ты
[40:23.600 --> 40:25.600]  находишься в compile time,
[40:25.600 --> 40:27.600]  если ты находишься в runtime-е,
[40:27.600 --> 40:29.600]  то ты не попадешь в эту ветку ifr.
[40:29.600 --> 40:31.600]  Да, но она же все равно скомпилирует эту часть кода
[40:31.600 --> 40:33.600]  и увидит, что я вызываю вот эту const eval функцию.
[40:33.600 --> 40:35.600]  Скорее всего, нет.
[40:37.600 --> 40:39.600]  Если находишься
[40:39.600 --> 40:41.600]  в runtime-е,
[40:41.600 --> 40:43.600]  то ты...
[40:51.600 --> 40:53.600]  Да, хороший вопрос. Не знаю.
[40:53.600 --> 40:55.600]  Давайте проверим.
[40:55.600 --> 40:57.600]  Да, ты прав.
[40:57.600 --> 40:59.600]  Так нельзя.
[40:59.600 --> 41:01.600]  Вот ее уже придется по const eval занести.
[41:01.600 --> 41:03.600]  Как бы.
[41:03.600 --> 41:05.600]  Ну, вопрос.
[41:05.600 --> 41:07.600]  Вопрос был такой.
[41:07.600 --> 41:09.600]  Я вот в этой функции...
[41:09.600 --> 41:11.600]  Вот я вот здесь решил вызвать
[41:11.600 --> 41:13.600]  const eval функцию.
[41:13.600 --> 41:15.600]  Под ifr,
[41:15.600 --> 41:17.600]  что я из const eval.
[41:17.600 --> 41:19.600]  От x.
[41:19.600 --> 41:21.600]  Где x, это не
[41:21.600 --> 41:23.600]  const expression, вообще говоря.
[41:23.600 --> 41:25.600]  Ну да, это ce.
[41:25.600 --> 41:27.600]  Потому что
[41:27.600 --> 41:29.600]  я не могу скомпилировать этот код
[41:29.600 --> 41:31.600]  if у меня не const export.
[41:31.600 --> 41:33.600]  if обычный.
[41:33.600 --> 41:35.600]  Не важно, что я из const eval.
[41:35.600 --> 41:37.600]  Важно, что я здесь пытаюсь вызвать
[41:37.600 --> 41:39.600]  const eval функцию
[41:39.600 --> 41:41.600]  от неконстанты.
[41:41.600 --> 41:43.600]  Что я пытаюсь вызвать
[41:43.600 --> 41:45.600]  const eval функцию
[41:45.600 --> 41:47.600]  от неконстант экспрешена.
[41:47.600 --> 41:49.600]  Под ifr, который сам
[41:49.600 --> 41:51.600]  не const export. Вот если бы ifr был const export,
[41:53.600 --> 41:55.600]  то было бы нормально. Я бы не пытался
[41:55.600 --> 41:57.600]  это компилировать, но тогда
[41:57.600 --> 41:59.600]  if const eval это всегда бы оценивалось в true,
[41:59.600 --> 42:01.600]  и я бы сюда никогда не попадал.
[42:01.600 --> 42:03.600]  А если вот эту штуку вы
[42:03.600 --> 42:05.600]  обратите в if const export
[42:05.600 --> 42:07.600]  от if const eval.
[42:07.600 --> 42:09.600]  А у меня все равно не работает, кажется.
[42:09.600 --> 42:11.600]  if const export от std.
[42:11.600 --> 42:13.600]  Можно просто от true тогда уже.
[42:13.600 --> 42:15.600]  Так, кстати, это очень
[42:17.600 --> 42:19.600]  Но у меня все равно полномородается.
[42:19.600 --> 42:21.600]  Не, не.
[42:21.600 --> 42:23.600]  В чем проблема?
[42:23.600 --> 42:25.600]  Кажется, что
[42:27.600 --> 42:29.600]  Кажется, что if const export
[42:29.600 --> 42:31.600]  от true
[42:31.600 --> 42:33.600]  Ну, я думаю, что
[42:33.600 --> 42:35.600]  это не должно помочь, это было бы странно.
[42:35.600 --> 42:37.600]  А вот тогда непонятно, как использовать вообще.
[42:37.600 --> 42:39.600]  Да, это
[42:41.600 --> 42:43.600]  Мы же много CE
[42:43.600 --> 42:45.600]  тогда очень будем ловить.
[42:45.600 --> 42:47.600]  Нет, в плане просто мы не сможем использовать
[42:47.600 --> 42:49.600]  вот это вот.
[42:49.600 --> 42:51.600]  Да, это тоже не помогает.
[42:51.600 --> 42:53.600]  Мы знаем, что мы находимся
[42:53.600 --> 42:55.600]  на этом кюфлятце, но не можем выслезать
[42:55.600 --> 42:57.600]  const eval в функции.
[42:59.600 --> 43:01.600]  Ну да, вот так вот.
[43:01.600 --> 43:03.600]  Вот это уже
[43:03.600 --> 43:05.600]  просто странно. Как это чинить?
[43:05.600 --> 43:07.600]  И как оно предполагается,
[43:07.600 --> 43:09.600]  что должно работать в целом?
[43:09.600 --> 43:11.600]  В смысле компилятор считает, что
[43:11.600 --> 43:13.600]  теоретически мы можем зайти в эту ветку
[43:13.600 --> 43:15.600]  внутри
[43:15.600 --> 43:17.600]  runtime, да?
[43:17.600 --> 43:19.600]  Вопрос в том, что компилятор
[43:19.600 --> 43:21.600]  делает раньше. Проверку того, что
[43:21.600 --> 43:23.600]  здесь делается
[43:23.600 --> 43:25.600]  вызов const eval функции от
[43:25.600 --> 43:27.600]  нужного выражения, или
[43:27.600 --> 43:29.600]  от запрещенного выражения,
[43:29.600 --> 43:31.600]  или проверку, или if const export
[43:31.600 --> 43:33.600]  обрабатывает.
[43:41.600 --> 43:43.600]  Нет, подождите.
[43:43.600 --> 43:45.600]  Кажется, что неважно даже, в каком
[43:45.600 --> 43:47.600]  порядке это делает, важно, что
[43:47.600 --> 43:49.600]  для него означает вызов const eval функции.
[43:49.600 --> 43:51.600]  Он просто...
[43:53.600 --> 43:55.600]  Вот если бы я так написал...
[43:57.600 --> 43:59.600]  Сейчас. Господи.
[44:01.600 --> 44:03.600]  Я ерунду какую-то написал, конечно.
[44:03.600 --> 44:05.600]  Вот так это по идее с компиль
[44:05.600 --> 44:07.600]  все равно не... То есть даже
[44:07.600 --> 44:09.600]  так.
[44:11.600 --> 44:13.600]  Как раз так не должно теперь.
[44:13.600 --> 44:15.600]  Ну, просто вопрос в том, насколько
[44:15.600 --> 44:17.600]  рано он обрабатывает const expry.
[44:19.600 --> 44:21.600]  А типа, что раньше const expry
[44:21.600 --> 44:23.600]  или проверка? Что он раньше
[44:23.600 --> 44:25.600]  делает const expr проверку и
[44:25.600 --> 44:27.600]  убирает, как бы, код одной из
[44:27.600 --> 44:29.600]  веток EFA, или вот это вот
[44:29.600 --> 44:31.600]  проверяет, что здесь const eval. Похоже,
[44:31.600 --> 44:33.600]  что он... Даже если я const expr
[44:33.600 --> 44:35.600]  сделаю вот здесь,
[44:35.600 --> 44:37.600]  это не спасет.
[44:39.600 --> 44:41.600]  Слушайте, не знаю, это запутанная история. Короче,
[44:41.600 --> 44:43.600]  надо подумать.
[44:49.600 --> 44:51.600]  И в const expr,
[44:51.600 --> 44:53.600]  и здесь, по идее,
[44:53.600 --> 44:55.600]  должно быть всегда false. То есть я, по сути,
[44:55.600 --> 44:57.600]  написал ему, не компилируй это.
[44:57.600 --> 44:59.600]  Вот.
[44:59.600 --> 45:01.600]  И он все равно
[45:01.600 --> 45:03.600]  выдал CE, все равно
[45:03.600 --> 45:05.600]  скомпилировал это.
[45:05.600 --> 45:07.600]  То есть это означает, что проверку того, что
[45:07.600 --> 45:09.600]  const eval функция делается, вызывается
[45:09.600 --> 45:11.600]  от правильного выражения
[45:11.600 --> 45:13.600]  до того,
[45:13.600 --> 45:15.600]  как выключает
[45:15.600 --> 45:17.600]  одну из детей const exp... и в const expry.
[45:19.600 --> 45:21.600]  Ну, очевидно, довольно часто нужно
[45:21.600 --> 45:23.600]  пользоваться какими-то...
[45:23.600 --> 45:25.600]  Но, я вам скажу так,
[45:25.600 --> 45:27.600]  в C++23 появится и в const eval.
[45:29.600 --> 45:31.600]  Так они вот все, они думают,
[45:31.600 --> 45:33.600]  как я.
[45:33.600 --> 45:35.600]  Да, я думаю, что...
[45:35.600 --> 45:37.600]  Вот так это можно будет реализовать
[45:37.600 --> 45:39.600]  в C++23.
[45:39.600 --> 45:41.600]  Этого же не будет на экзазе.
[45:41.600 --> 45:43.600]  Этого нет.
[45:43.600 --> 45:45.600]  Нет, не будет.
[45:45.600 --> 45:47.600]  Как работает const eval?
[45:47.600 --> 45:49.600]  Реализуйте.
[45:49.600 --> 45:51.600]  Я не знаю, в общем,
[45:51.600 --> 45:53.600]  это упражнение
[45:53.600 --> 45:55.600]  на самостоятельное изучение.
[45:55.600 --> 45:57.600]  Я не знаю,
[45:57.600 --> 45:59.600]  это упражнение
[45:59.600 --> 46:01.600]  на самостоятельное изучение.
[46:01.600 --> 46:03.600]  Я не знаю,
[46:03.600 --> 46:05.600]  это упражнение
[46:05.600 --> 46:07.600]  на самостоятельное изучение.
[46:07.600 --> 46:09.600]  Хватит с меня этого.
[46:09.600 --> 46:11.600]  Давайте дальше.
[46:11.600 --> 46:13.600]  Короче, вы поняли, что есть const eval
[46:13.600 --> 46:15.600]  и есть функция
[46:15.600 --> 46:17.600]  из const eval edit,
[46:17.600 --> 46:19.600]  но с их использованием есть вопросики.
[46:19.600 --> 46:21.600]  Последнее, о чем я расскажу,
[46:21.600 --> 46:23.600]  это const init. Последнее, о чем я расскажу
[46:23.600 --> 46:25.600]  в теме const expry и прочего.
[46:25.600 --> 46:27.600]  Илья, можно ли делать перегрузки
[46:27.600 --> 46:29.600]  по const eval?
[46:29.600 --> 46:31.600]  Это как, в смысле?
[46:31.600 --> 46:33.600]  Ну, без этого, но без этих приколов.
[46:33.600 --> 46:35.600]  Ну, то есть, явно написали...
[46:35.600 --> 46:37.600]  То есть, одна версия const eval, другая нет?
[46:37.600 --> 46:39.600]  Я думаю, нет.
[46:39.600 --> 46:41.600]  Но вряд ли это часть сигнатуры.
[46:41.600 --> 46:43.600]  Перегрузку уже можно делать, если это часть сигнатуры.
[46:45.600 --> 46:47.600]  То есть, ты говоришь,
[46:47.600 --> 46:49.600]  то, что мы хотели сделать,
[46:49.600 --> 46:51.600]  адекватно сделать невозможно.
[46:51.600 --> 46:53.600]  До C++23.
[46:53.600 --> 46:55.600]  А что именно мы хотели сделать?
[46:55.600 --> 46:57.600]  Из const expry функции вызывать const eval?
[46:57.600 --> 46:59.600]  Есть какая-то реализованная нами
[46:59.600 --> 47:01.600]  const eval функция pow,
[47:01.600 --> 47:03.600]  которая вызывается, если наша не доступна.
[47:03.600 --> 47:05.600]  Ну, чтобы ветвление было...
[47:05.600 --> 47:07.600]  И мы ее хотим просто вызывать.
[47:07.600 --> 47:09.600]  Чтобы ветвление было на этапе компиляции,
[47:09.600 --> 47:11.600]  а не на...
[47:11.600 --> 47:13.600]  в runtime.
[47:13.600 --> 47:15.600]  Ну, то есть, чтобы у нас не if
[47:15.600 --> 47:17.600]  решала какая версия,
[47:17.600 --> 47:19.600]  чтобы связывалась сразу с нужной версией.
[47:19.600 --> 47:21.600]  То есть, короче, просто весь этот код, который мы написали,
[47:21.600 --> 47:23.600]  вынести в отдельную функцию.
[47:23.600 --> 47:25.600]  И вызывать либо runtime, либо нашу.
[47:25.600 --> 47:27.600]  Ну, в общем, может быть,
[47:27.600 --> 47:29.600]  способ сделать это есть, но я не знаю.
[47:29.600 --> 47:31.600]  Вот так.
[47:31.600 --> 47:33.600]  Из const expry функции вызывать const eval?
[47:33.600 --> 47:35.600]  Ну, видимо...
[47:35.600 --> 47:37.600]  Видимо, да. Видимо, вот, нельзя.
[47:37.600 --> 47:39.600]  Может быть, как-то можно, но я не знаю.
[47:41.600 --> 47:43.600]  Последний это const init.
[47:45.600 --> 47:47.600]  Чтобы рассказать, что такое const init,
[47:47.600 --> 47:49.600]  мне придется вам
[47:49.600 --> 47:51.600]  сначала рассказать
[47:51.600 --> 47:53.600]  о том,
[47:53.600 --> 47:55.600]  о чем, возможно, стоило бы рассказать
[47:55.600 --> 47:57.600]  даже в первом семестре.
[47:57.600 --> 47:59.600]  У нас, короче, такая есть тема,
[47:59.600 --> 48:01.600]  еще одна тонкая,
[48:01.600 --> 48:03.600]  которую мы как-то всегда в стороне оставляем.
[48:09.600 --> 48:11.600]  Сейчас, момент.
[48:11.600 --> 48:13.600]  Никто ничего не написал.
[48:13.600 --> 48:15.600]  Важно.
[48:15.600 --> 48:17.600]  Вопрос
[48:17.600 --> 48:19.600]  в том,
[48:19.600 --> 48:21.600]  как происходит
[48:21.600 --> 48:23.600]  инициализация
[48:23.600 --> 48:25.600]  глобальных истетических переменных.
[48:27.600 --> 48:29.600]  Вот, чтобы понять,
[48:29.600 --> 48:31.600]  что такое const init,
[48:31.600 --> 48:33.600]  надо понять,
[48:35.600 --> 48:37.600]  что еще нам
[48:37.600 --> 48:39.600]  дает const expry,
[48:39.600 --> 48:41.600]  помимо того, что он обязывает
[48:41.600 --> 48:43.600]  правую часть быть
[48:43.600 --> 48:45.600]  const expry.
[48:45.600 --> 48:47.600]  Ну, вот, когда мы пишем const expry,
[48:47.600 --> 48:49.600]  это какая-то переменная.
[48:49.600 --> 48:51.600]  А что это означает,
[48:51.600 --> 48:53.600]  помимо того, что
[48:53.600 --> 48:55.600]  справа должно быть const expry?
[48:57.600 --> 48:59.600]  И это, на самом деле, означает нечто большее.
[48:59.600 --> 49:01.600]  Это означает,
[49:01.600 --> 49:03.600]  что у переменной...
[49:03.600 --> 49:05.600]  Сейчас я вам открою статью одну,
[49:05.600 --> 49:07.600]  только я для этого
[49:07.600 --> 49:09.600]  проверю, что...
[49:09.600 --> 49:11.600]  Нет, это не та статья.
[49:11.600 --> 49:13.600]  Где тут у меня была открыта статья?
[49:13.600 --> 49:15.600]  У меня тут много чего открыто,
[49:15.600 --> 49:17.600]  все не то, что надо.
[49:23.600 --> 49:25.600]  У меня все почему-то не дают вызвать
[49:25.600 --> 49:27.600]  из const evaluator
[49:27.600 --> 49:29.600]  из const expry.
[49:45.600 --> 49:47.600]  Я нашел.
[49:47.600 --> 49:49.600]  Вот оно.
[49:49.600 --> 49:51.600]  Значит, вот есть такая статья хорошая.
[49:51.600 --> 49:53.600]  Я вам ее, наверное, скину.
[49:53.600 --> 49:55.600]  А про то,
[49:55.600 --> 49:57.600]  как вообще происходит инициализация статических
[49:57.600 --> 49:59.600]  и глобальных переменных.
[49:59.600 --> 50:01.600]  На самом деле есть
[50:01.600 --> 50:03.600]  инициализация,
[50:03.600 --> 50:05.600]  как и много еще в этом мире,
[50:05.600 --> 50:07.600]  бывает статической и динамической.
[50:11.600 --> 50:13.600]  Как вы, наверное, догадываетесь,
[50:13.600 --> 50:15.600]  что статическая инициализация так,
[50:15.600 --> 50:17.600]  которая на этапе компиляции происходит,
[50:17.600 --> 50:19.600]  а динамическая так, которая в рантайме происходит.
[50:19.600 --> 50:21.600]  Вот, например, написали вы
[50:23.600 --> 50:25.600]  объявили вы какую-то глобальную переменную.
[50:25.600 --> 50:27.600]  Вы написали, например,
[50:27.600 --> 50:29.600]  std string s равно
[50:29.600 --> 50:31.600]  и что-то справа.
[50:31.600 --> 50:33.600]  Вот вопрос.
[50:33.600 --> 50:35.600]  На этапе чего
[50:35.600 --> 50:37.600]  будет инициализирована эта переменная?
[50:37.600 --> 50:39.600]  На этапе компиляции
[50:39.600 --> 50:41.600]  или в рантайме?
[50:41.600 --> 50:43.600]  Наверное, в рантайме.
[50:43.600 --> 50:45.600]  А справа у вас какое-то выражение,
[50:45.600 --> 50:47.600]  где надо создать string.
[50:47.600 --> 50:49.600]  Да, кажется, что это должно быть
[50:49.600 --> 50:51.600]  сделано в рантайме, потому что
[50:53.600 --> 50:55.600]  иначе это бы означало,
[50:55.600 --> 50:57.600]  что компилятору в compile-time
[50:57.600 --> 50:59.600]  нужно создать объект string
[50:59.600 --> 51:01.600]  и
[51:01.600 --> 51:03.600]  его
[51:03.600 --> 51:05.600]  чем-то пронициализировать, куда-то положить.
[51:05.600 --> 51:07.600]  Но это со string
[51:07.600 --> 51:09.600]  ладно, со string понятно.
[51:09.600 --> 51:11.600]  Пример написали. У меня есть там
[51:11.600 --> 51:13.600]  static
[51:15.600 --> 51:17.600]  А вот, кстати,
[51:17.600 --> 51:19.600]  давайте я вам как раз такой
[51:19.600 --> 51:21.600]  примеры покажу. Вот, смотрите.
[51:21.600 --> 51:23.600]  Да, это будет пункт
[51:23.600 --> 51:25.600]  16.4
[51:25.600 --> 51:27.600]  static
[51:27.600 --> 51:29.600]  and dynamic
[51:29.600 --> 51:31.600]  initialization
[51:33.600 --> 51:35.600]  const init
[51:35.600 --> 51:37.600]  16.3
[51:37.600 --> 51:39.600]  это был const eval
[51:39.600 --> 51:41.600]  и из const evaluate
[51:51.600 --> 51:53.600]  Вот, у меня
[51:53.600 --> 51:55.600]  давайте я верну const eval
[51:55.600 --> 51:57.600]  на const export, здесь обратно верну
[51:57.600 --> 51:59.600]  const export был из prime
[52:01.600 --> 52:03.600]  И напишу следующую вещь
[52:05.600 --> 52:07.600]  Я все удалю
[52:13.600 --> 52:15.600]  Я напишу
[52:15.600 --> 52:17.600]  a
[52:17.600 --> 52:19.600]  bool
[52:19.600 --> 52:21.600]  b
[52:21.600 --> 52:23.600]  равно is prime
[52:23.600 --> 52:25.600]  от
[52:27.600 --> 52:29.600]  ну, 37
[52:31.600 --> 52:33.600]  Я хочу понять
[52:33.600 --> 52:35.600]  Вот эта функция is prime
[52:35.600 --> 52:37.600]  Вот если я так напишу
[52:37.600 --> 52:39.600]  bool b равно is prime от 37
[52:39.600 --> 52:41.600]  Где будет инициализировано?
[52:41.600 --> 52:43.600]  В какой момент будет вычислено is prime от 37?
[52:43.600 --> 52:45.600]  В compile-time или в run-time?
[52:47.600 --> 52:49.600]  Как мне это понять?
[52:49.600 --> 52:51.600]  Теперь я уже знаю как
[52:55.600 --> 52:57.600]  Нет, я не могу
[52:57.600 --> 52:59.600]  спросить
[52:59.600 --> 53:01.600]  Значит
[53:01.600 --> 53:03.600]  Ну, seeout из const eval
[53:03.600 --> 53:05.600]  это, конечно, довольно странно
[53:05.600 --> 53:07.600]  Ну, вы можете разное значение вернуть
[53:07.600 --> 53:09.600]  а потом b вывести
[53:09.600 --> 53:11.600]  В смысле, просто чтобы функция вернула
[53:11.600 --> 53:13.600]  Так нельзя seeout делать
[53:13.600 --> 53:15.600]  на этапе
[53:15.600 --> 53:17.600]  В смысле, return сделать
[53:19.600 --> 53:21.600]  Ладно, давайте я напишу другую
[53:21.600 --> 53:23.600]  const export функцию is prime
[53:23.600 --> 53:25.600]  Почему плохо делать seeout, а вот затем?
[53:31.600 --> 53:33.600]  Вот, такая функция
[53:33.600 --> 53:35.600]  где я напишу
[53:35.600 --> 53:37.600]  if std is
[53:37.600 --> 53:39.600]  constant
[53:39.600 --> 53:41.600]  evaluated
[53:43.600 --> 53:45.600]  то return
[53:45.600 --> 53:47.600]  true, а иначе false
[53:47.600 --> 53:49.600]  Господи
[53:49.600 --> 53:51.600]  Да, вопрос
[53:51.600 --> 53:53.600]  Это что вы сейчас написали?
[53:55.600 --> 53:57.600]  Я не уверен, что
[53:57.600 --> 53:59.600]  Ну, да
[53:59.600 --> 54:01.600]  У меня просто искажение
[54:01.600 --> 54:03.600]  потому что я думаю об if const export
[54:03.600 --> 54:05.600]  и if const export нельзя писать так
[54:05.600 --> 54:07.600]  Вы же понимаете, что
[54:07.600 --> 54:09.600]  если писать if const export, то там нельзя
[54:09.600 --> 54:11.600]  его в тернарный оператор превратить
[54:11.600 --> 54:13.600]  Я просто мыслю
[54:13.600 --> 54:15.600]  if в compile-time, поэтому так пишу
[54:15.600 --> 54:17.600]  Наверное, здесь можно написать просто так
[54:17.600 --> 54:19.600]  А нельзя написать b равно
[54:19.600 --> 54:21.600]  std is constant evaluated?
[54:21.600 --> 54:23.600]  Ну, зачем мы об этом
[54:23.600 --> 54:25.600]  сделали?
[54:25.600 --> 54:27.600]  Да, ну, изначально, потому что я хотел проверить
[54:29.600 --> 54:31.600]  Наверное, да
[54:31.600 --> 54:33.600]  Наверное, можно и так
[54:33.600 --> 54:35.600]  Наверное, если мы не исправим делаем, то можно и так
[54:35.600 --> 54:37.600]  написать
[54:37.600 --> 54:39.600]  Вот, давайте
[54:39.600 --> 54:41.600]  теперь выведем b
[54:43.600 --> 54:45.600]  И это мы можем сделать
[54:45.600 --> 54:47.600]  То есть, вопрос в том, b
[54:47.600 --> 54:49.600]  пронициализирована была в compile-time или в run-time?
[54:49.600 --> 54:51.600]  Ну, кажется, понятно, что сейчас она будет
[54:51.600 --> 54:53.600]  пронициализирована
[54:53.600 --> 54:55.600]  в compile-time
[54:55.600 --> 54:57.600]  Она вообще не проницает в compile-time
[54:57.600 --> 54:59.600]  Она ничего не вывела?
[54:59.600 --> 55:01.600]  Или что?
[55:01.600 --> 55:03.600]  Вывела единицу
[55:03.600 --> 55:05.600]  Вот, возможно, поэтому
[55:05.600 --> 55:07.600]  все-таки мне надо было функцию вызывать
[55:07.600 --> 55:09.600]  Потому что if constant evaluated
[55:09.600 --> 55:11.600]  возможно, это как раз
[55:11.600 --> 55:13.600]  штука, которая всегда на этапе компиляции
[55:13.600 --> 55:15.600]  вычисляется
[55:15.600 --> 55:17.600]  В смысле, ее истинность или ложность
[55:17.600 --> 55:19.600]  определяется на этапе компиляции
[55:19.600 --> 55:21.600]  Я вызвал const export функцию,
[55:21.600 --> 55:23.600]  которая обертана в if constant evaluated
[55:23.600 --> 55:25.600]  Получил то же самое?
[55:25.600 --> 55:27.600]  Да
[55:27.600 --> 55:29.600]  Можете, конечно, как-нибудь еще
[55:29.600 --> 55:31.600]  пооборачиваться
[55:31.600 --> 55:33.600]  Если не const export
[55:33.600 --> 55:35.600]  Ну, все, на этапе компиляции
[55:39.600 --> 55:41.600]  Хорошо, давайте
[55:41.600 --> 55:43.600]  попробуем по-другому
[55:43.600 --> 55:45.600]  Давайте я попробую сделать статическую
[55:45.600 --> 55:47.600]  статический bool b
[55:47.600 --> 55:49.600]  Да, то же самое
[55:49.600 --> 55:51.600]  Подожди, Илья, вот если
[55:51.600 --> 55:53.600]  мне написать cout if constant evaluated
[55:53.600 --> 55:55.600]  то оно выйдет 0
[55:57.600 --> 55:59.600]  Да
[55:59.600 --> 56:01.600]  Ну это логично
[56:01.600 --> 56:03.600]  Потому что cout может происходить
[56:03.600 --> 56:05.600]  только в runtime
[56:05.600 --> 56:07.600]  Нет, ну и до этого у нас был пример
[56:07.600 --> 56:09.600]  когда мы делали cout какой-то
[56:09.600 --> 56:11.600]  какой-то он сдавал штуки
[56:11.600 --> 56:13.600]  и оно корректно работало, потому что
[56:13.600 --> 56:15.600]  он в compile-time уже считал значение
[56:15.600 --> 56:17.600]  а в runtime уже просто
[56:17.600 --> 56:19.600]  выводил значение
[56:19.600 --> 56:21.600]  Ну, ребят, вы понимаете
[56:21.600 --> 56:23.600]  из
[56:23.600 --> 56:25.600]  он, грубо говоря
[56:25.600 --> 56:27.600]  проверяет, типа statement
[56:27.600 --> 56:29.600]  выполняется в такой момент
[56:33.600 --> 56:35.600]  Так в чем проблема выполнить statement раньше?
[56:35.600 --> 56:37.600]  Потому что
[56:37.600 --> 56:39.600]  он всегда выполняет в compile-time
[56:39.600 --> 56:41.600]  Подожди, Никита, если из constant evaluated
[56:41.600 --> 56:43.600]  всегда будет выполняться
[56:43.600 --> 56:45.600]  в compile-time, то он просто вместо него
[56:45.600 --> 56:47.600]  везде и нет
[56:47.600 --> 56:49.600]  Это бессмысленно
[57:07.600 --> 57:09.600]  Да, это странно, потому что мне казалось, что
[57:09.600 --> 57:11.600]  для
[57:11.600 --> 57:13.600]  не константных
[57:13.600 --> 57:15.600]  не constexpr
[57:15.600 --> 57:17.600]  даже не константных переменных
[57:17.600 --> 57:19.600]  это должно происходить в runtime
[57:19.600 --> 57:21.600]  Возможно, дело в том, что я тип неправильный
[57:21.600 --> 57:23.600]  Возможно, если бы я сделал string
[57:23.600 --> 57:25.600]  Ну, если бы я хотя бы double сделал
[57:25.600 --> 57:27.600]  Давайте попробую сделать double
[57:29.600 --> 57:31.600]  Вот, я сейчас сверну double отсюда
[57:33.600 --> 57:35.600]  Возможно, double не так сработает
[57:35.600 --> 57:37.600]  Потому что, возможно, целочисленный он
[57:37.600 --> 57:39.600]  Господи
[57:39.600 --> 57:41.600]  Наоборот, здесь 1.0, а здесь 0.0
[57:45.600 --> 57:47.600]  Если сейчас будет 1, то я не знаю
[57:47.600 --> 57:49.600]  Ладно, я не знаю
[57:51.600 --> 57:53.600]  Ну хорошо, для string уж точно
[57:53.600 --> 57:55.600]  это не должно работать
[57:55.600 --> 57:57.600]  Давайте string проверим
[57:57.600 --> 57:59.600]  Ну, история
[57:59.600 --> 58:01.600]  в чем, в чем, что я пытался показать
[58:01.600 --> 58:03.600]  Я посмотрел, что он
[58:03.600 --> 58:05.600]  не работает
[58:05.600 --> 58:07.600]  В чем, в чем, что я пытался показать
[58:07.600 --> 58:09.600]  Я пытался сказать, что
[58:09.600 --> 58:11.600]  у меня есть иногда
[58:11.600 --> 58:13.600]  бывает иногда проблема
[58:13.600 --> 58:15.600]  Ну, по крайней мере, я думал, что у меня бывает проблема, а как будто бы ее нет
[58:15.600 --> 58:17.600]  Проблема в том, что
[58:17.600 --> 58:19.600]  когда вы инициализируете некоторую
[58:19.600 --> 58:21.600]  статическую переменную
[58:21.600 --> 58:23.600]  в
[58:25.600 --> 58:27.600]  и не делаете ее константой
[58:27.600 --> 58:29.600]  и вы ее инициализируете каким-то
[58:29.600 --> 58:31.600]  выражением
[58:31.600 --> 58:33.600]  которое, например, содержит вызов
[58:33.600 --> 58:35.600]  функции, то вот это выражение
[58:35.600 --> 58:37.600]  оно в рандайме вычисляется
[58:37.600 --> 58:39.600]  особенно если оно
[58:47.600 --> 58:49.600]  не констант экспрешу
[58:49.600 --> 58:51.600]  не констант экспрешу
[58:53.600 --> 58:55.600]  да
[58:55.600 --> 58:57.600]  да
[58:59.600 --> 59:01.600]  и
[59:19.600 --> 59:21.600]  да, что-то у меня не удался пример
[59:21.600 --> 59:23.600]  вообще
[59:23.600 --> 59:25.600]  грустно, да
[59:27.600 --> 59:29.600]  ну, значит, надо признать, что я не знаю, как работает константинит
[59:29.600 --> 59:31.600]  просто и все, я закончу
[59:31.600 --> 59:33.600]  а нам тоже можно?
[59:33.600 --> 59:35.600]  да, вам тоже можно, конечно
[59:35.600 --> 59:37.600]  можно, конечно
[59:37.600 --> 59:39.600]  не, я не буду вас спрашивать то, что я сам не понял, это очевидно
[59:39.600 --> 59:41.600]  ну, мало ли
[59:41.600 --> 59:43.600]  на некоторых предметах, пожалуйста
[59:43.600 --> 59:45.600]  не, не, я так не делаю
[59:45.600 --> 59:47.600]  вопрос на уровне 11
[59:47.600 --> 59:49.600]  объясните, как оно работает
[59:49.600 --> 59:51.600]  а
[59:51.600 --> 59:53.600]  ну, может
[59:53.600 --> 59:55.600]  значит
[59:57.600 --> 59:59.600]  давайте я вам расскажу, как я это понимаю
[59:59.600 --> 01:00:01.600]  возможно, мое понимание неправильное
[01:00:01.600 --> 01:00:03.600]  и
[01:00:03.600 --> 01:00:05.600]  вы можете
[01:00:05.600 --> 01:00:07.600]  потом мне рассказать, как вы это
[01:00:07.600 --> 01:00:09.600]  поняли сами, если
[01:00:09.600 --> 01:00:11.600]  более правильно поймете
[01:00:11.600 --> 01:00:13.600]  проблема в том, что когда вы инициализируете
[01:00:13.600 --> 01:00:15.600]  глобальные или статические
[01:00:15.600 --> 01:00:17.600]  переменные
[01:00:17.600 --> 01:00:19.600]  у вас
[01:00:19.600 --> 01:00:21.600]  вычтение их значений
[01:00:21.600 --> 01:00:23.600]  может происходить
[01:00:25.600 --> 01:00:27.600]  в рантайме
[01:00:31.600 --> 01:00:33.600]  а, ну вот, скажем
[01:00:33.600 --> 01:00:35.600]  вот такой пример
[01:00:37.600 --> 01:00:39.600]  это правда пример актуальный до
[01:00:39.600 --> 01:00:41.600]  C++20
[01:00:41.600 --> 01:00:43.600]  потому что сейчас C++20
[01:00:43.600 --> 01:00:45.600]  и конструктор SdString
[01:00:45.600 --> 01:00:47.600]  тоже стал constexpr
[01:00:49.600 --> 01:00:51.600]  но вот представьте, что у вас есть какая-то глобальная константа
[01:00:51.600 --> 01:00:53.600]  возможно, это все в C++20
[01:00:53.600 --> 01:00:55.600]  просто само стало constexpr и все
[01:00:55.600 --> 01:00:57.600]  и проблема исчезла
[01:00:59.600 --> 01:01:01.600]  короче, не знаю
[01:01:01.600 --> 01:01:03.600]  ну, до C++20
[01:01:03.600 --> 01:01:05.600]  была такая проблема, что
[01:01:05.600 --> 01:01:07.600]  если я хочу, например, строку глобальную
[01:01:07.600 --> 01:01:09.600]  инициализировать каким-то значением
[01:01:09.600 --> 01:01:11.600]  то
[01:01:11.600 --> 01:01:13.600]  вычтение этого значения в рантайме
[01:01:13.600 --> 01:01:15.600]  происходит
[01:01:15.600 --> 01:01:17.600]  и вместо того, чтобы зашиться
[01:01:17.600 --> 01:01:19.600]  в динарник
[01:01:19.600 --> 01:01:21.600]  вычтенная компиляция значения
[01:01:21.600 --> 01:01:23.600]  в начале рантайма, перед main
[01:01:23.600 --> 01:01:25.600]  вычисляется это значение
[01:01:25.600 --> 01:01:27.600]  вот
[01:01:27.600 --> 01:01:29.600]  и
[01:01:31.600 --> 01:01:33.600]  мы могли бы написать
[01:01:33.600 --> 01:01:35.600]  constexpr
[01:01:35.600 --> 01:01:37.600]  и тем самым заставить
[01:01:37.600 --> 01:01:39.600]  компилятор
[01:01:39.600 --> 01:01:41.600]  гарантировать нам, что он это инициализирует в compile-time
[01:01:41.600 --> 01:01:43.600]  что нам говорит слово constexpr
[01:01:43.600 --> 01:01:45.600]  перед глобальной переменной
[01:01:45.600 --> 01:01:47.600]  локальной, да, хотя бы, переменной
[01:01:47.600 --> 01:01:49.600]  оно нам говорит, что мы
[01:01:49.600 --> 01:01:51.600]  гарантируем, что
[01:01:51.600 --> 01:01:53.600]  справа стоит constexpr
[01:01:53.600 --> 01:01:55.600]  и что значение этой перемены будет вычислено
[01:01:55.600 --> 01:01:57.600]  в compile-time, что в рантайме
[01:01:57.600 --> 01:01:59.600]  не будет тратиться время на вычтение
[01:01:59.600 --> 01:02:01.600]  того, что справа
[01:02:01.600 --> 01:02:03.600]  вот
[01:02:03.600 --> 01:02:05.600]  у constexpr, правда, есть один недостаток
[01:02:05.600 --> 01:02:07.600]  он обязывает перемену быть
[01:02:07.600 --> 01:02:09.600]  само у const
[01:02:09.600 --> 01:02:11.600]  смысл слова constexpr
[01:02:11.600 --> 01:02:13.600]  в том, чтобы
[01:02:13.600 --> 01:02:15.600]  у нас была такая как constexpr, только без const
[01:02:15.600 --> 01:02:17.600]  короче, const
[01:02:17.600 --> 01:02:19.600]  и need, это constexpr минус const
[01:02:19.600 --> 01:02:21.600]  если совсем короткая формула
[01:02:21.600 --> 01:02:23.600]  а
[01:02:23.600 --> 01:02:25.600]  что такое constexpr
[01:02:25.600 --> 01:02:27.600]  это штука, которая одновременно говорит вам
[01:02:27.600 --> 01:02:29.600]  что выражение справа является
[01:02:29.600 --> 01:02:31.600]  константом выражением
[01:02:31.600 --> 01:02:33.600]  и обязана быть вычислено
[01:02:33.600 --> 01:02:35.600]  в compile-time
[01:02:35.600 --> 01:02:37.600]  в то же время оно делает вашу переменную
[01:02:37.600 --> 01:02:39.600]  константой
[01:02:39.600 --> 01:02:41.600]  и это не всегда удобно, иногда вы хотите, чтобы
[01:02:41.600 --> 01:02:43.600]  даже переменная гарантировала, что она
[01:02:43.600 --> 01:02:45.600]  пронициализируется на этапе компиляции
[01:02:45.600 --> 01:02:47.600]  но при этом сама не была константой, чтобы
[01:02:47.600 --> 01:02:49.600]  ее менять могли
[01:02:49.600 --> 01:02:51.600]  чтобы значение выражения вычислилось в compile-time
[01:02:51.600 --> 01:02:53.600]  и в бинарнике
[01:02:53.600 --> 01:02:55.600]  изначально хранилось значение этой
[01:02:55.600 --> 01:02:57.600]  вычисленное значение
[01:02:57.600 --> 01:02:59.600]  этой переменной, но при этом
[01:02:59.600 --> 01:03:01.600]  ее менять можно было, то есть она
[01:03:01.600 --> 01:03:03.600]  не была константой, вот это вам позволяет
[01:03:03.600 --> 01:03:05.600]  сделать слово const и need
[01:03:05.600 --> 01:03:07.600]  а это обязательно для глобальных
[01:03:07.600 --> 01:03:09.600]  это обязательно для глобальных и статических
[01:03:09.600 --> 01:03:11.600]  что именно?
[01:03:11.600 --> 01:03:13.600]  ну для просто локальных переменных
[01:03:13.600 --> 01:03:15.600]  нельзя так делать?
[01:03:15.600 --> 01:03:17.600]  можно и для локальных, да
[01:03:19.600 --> 01:03:21.600]  вот я к сожалению
[01:03:21.600 --> 01:03:23.600]  не могу воспроизвести, почему-то все в compile-time
[01:03:23.600 --> 01:03:25.600]  инициализируется
[01:03:25.600 --> 01:03:27.600]  и я что-то как-то не знаю
[01:03:27.600 --> 01:03:29.600]  он вас боится?
[01:03:29.600 --> 01:03:31.600]  может он просто еще и компилятор вложает
[01:03:31.600 --> 01:03:33.600]  это тоже возможно, но мне кажется
[01:03:33.600 --> 01:03:35.600]  нет
[01:03:35.600 --> 01:03:37.600]  а в каком случае мы можем
[01:03:37.600 --> 01:03:39.600]  сделать глобальных переменных?
[01:03:39.600 --> 01:03:41.600]  Илья, у тебя есть примеры
[01:03:41.600 --> 01:03:43.600]  когда тебе
[01:03:43.600 --> 01:03:45.600]  а можно синтаксис хотя бы?
[01:03:45.600 --> 01:03:47.600]  как это называть?
[01:03:47.600 --> 01:03:49.600]  нет, у меня к сожалению нет рабочего примера
[01:03:49.600 --> 01:03:51.600]  поэтому я не знаю, что вам показать здесь
[01:03:51.600 --> 01:03:53.600]  могу только слова сказать
[01:03:53.600 --> 01:03:55.600]  просто синтаксис, напишите const и need
[01:03:55.600 --> 01:03:57.600]  я пишу точно так же
[01:03:57.600 --> 01:03:59.600]  const и need, как const export, только const и need
[01:03:59.600 --> 01:04:01.600]  у меня вообще не подсветит
[01:04:01.600 --> 01:04:03.600]  я думал const и need этот набор
[01:04:03.600 --> 01:04:05.600]  const и need std string
[01:04:05.600 --> 01:04:07.600]  не знаю, str равно
[01:04:07.600 --> 01:04:09.600]  std string
[01:04:09.600 --> 01:04:11.600]  равно, я не знаю, abc
[01:04:13.600 --> 01:04:15.600]  вот, эта штука делает
[01:04:15.600 --> 01:04:17.600]  мою строку
[01:04:17.600 --> 01:04:19.600]  она обязывает правую часть быть
[01:04:19.600 --> 01:04:21.600]  константным выражением, но при этом сама строка
[01:04:21.600 --> 01:04:23.600]  константной не становится
[01:04:23.600 --> 01:04:25.600]  вот
[01:04:25.600 --> 01:04:27.600]  ха-ха-ха, нет
[01:04:27.600 --> 01:04:29.600]  я дурак, я неправильно сказал
[01:04:29.600 --> 01:04:31.600]  const и need мне не надо локальных перемен
[01:04:31.600 --> 01:04:33.600]  ну значит я совсем не знаю, что такое const и need
[01:04:33.600 --> 01:04:35.600]  забьем на это
[01:04:37.600 --> 01:04:39.600]  до этого я и не тоже
[01:04:39.600 --> 01:04:41.600]  собирался туда добавлять
[01:04:41.600 --> 01:04:43.600]  вот, это я вам просто рассказываю фичи
[01:04:43.600 --> 01:04:45.600]  которые недавно появились, но я в них еще сам не до конца
[01:04:45.600 --> 01:04:47.600]  разобрался
[01:04:47.600 --> 01:04:49.600]  но через 5 лет все изменится
[01:04:49.600 --> 01:04:51.600]  конечно, и это обязательно будет
[01:04:51.600 --> 01:04:53.600]  const и need, end, sin, end
[01:04:55.600 --> 01:04:57.600]  мне кажется
[01:04:57.600 --> 01:04:59.600]  больше я вам ничего не хочу
[01:04:59.600 --> 01:05:01.600]  рассказать про вот это, про const export
[01:05:01.600 --> 01:05:03.600]  вот
[01:05:03.600 --> 01:05:05.600]  сейчас мы с вами
[01:05:05.600 --> 01:05:07.600]  может быть сейчас уместно сделать перерыв
[01:05:07.600 --> 01:05:09.600]  у нас как раз почти пара закончилась
[01:05:09.600 --> 01:05:11.600]  вот, а на второй части
[01:05:11.600 --> 01:05:13.600]  мы наконец-то с вами
[01:05:13.600 --> 01:05:15.600]  начнется часть 18
[01:05:15.600 --> 01:05:17.600]  это пока не была часть 18+,
[01:05:17.600 --> 01:05:19.600]  это была нормальная еще часть
[01:05:19.600 --> 01:05:21.600]  это были достаточно полезные
[01:05:21.600 --> 01:05:23.600]  фичи
[01:05:23.600 --> 01:05:25.600]  вот, сейчас на второй паре
[01:05:25.600 --> 01:05:27.600]  начнется часть 18+, и
[01:05:27.600 --> 01:05:29.600]  мы с вами напишем мета-контейнер
[01:05:29.600 --> 01:05:31.600]  ну, точнее мы напишем
[01:05:31.600 --> 01:05:33.600]  прототип мета-контейнера
[01:05:33.600 --> 01:05:35.600]  typelist
[01:05:35.600 --> 01:05:37.600]  вот
[01:05:37.600 --> 01:05:39.600]  а сам его целиком
[01:05:39.600 --> 01:05:41.600]  вы напишете, возможно
[01:05:41.600 --> 01:05:43.600]  дома
[01:05:43.600 --> 01:05:45.600]  вы заставляете нас заниматься 18+, вещами
[01:05:45.600 --> 01:05:47.600]  конечно
[01:05:51.600 --> 01:05:53.600]  короче, вы поняли, что
[01:05:53.600 --> 01:05:55.600]  все мы пока плохо
[01:05:55.600 --> 01:05:57.600]  знаем C++20, включая меня
[01:05:57.600 --> 01:05:59.600]  тем не менее, мы сейчас
[01:05:59.600 --> 01:06:01.600]  попробуем
[01:06:01.600 --> 01:06:03.600]  написать нечто
[01:06:05.600 --> 01:06:07.600]  нечто 18+.
[01:06:07.600 --> 01:06:09.600]  давайте
[01:06:09.600 --> 01:06:11.600]  для начала я вам покажу одну
[01:06:11.600 --> 01:06:13.600]  забавную штуку, которую
[01:06:13.600 --> 01:06:15.600]  я еще давным-давно
[01:06:15.600 --> 01:06:17.600]  на лекциях показывал
[01:06:17.600 --> 01:06:19.600]  еще до того, как
[01:06:19.600 --> 01:06:21.600]  вышел C++20
[01:06:27.600 --> 01:06:29.600]  чтобы вы
[01:06:29.600 --> 01:06:31.600]  немножко морально подготовились
[01:06:31.600 --> 01:06:33.600]  смотрите
[01:06:37.600 --> 01:06:39.600]  что нам
[01:06:39.600 --> 01:06:41.600]  позволяет делать шаблонные метапрограмми...
[01:06:41.600 --> 01:06:43.600]  ну, мы до этого с вами
[01:06:43.600 --> 01:06:45.600]  занимались
[01:06:45.600 --> 01:06:47.600]  шаблонным метапрограммировать
[01:06:47.600 --> 01:06:49.600]  C++ только что смог это
[01:06:49.600 --> 01:06:51.600]  сделать
[01:06:51.600 --> 01:06:53.600]  вот почему-то у нас
[01:06:53.600 --> 01:06:55.600]  на trunk GCC
[01:06:55.600 --> 01:06:57.600]  не получалось
[01:06:57.600 --> 01:06:59.600]  GCC 12
[01:06:59.600 --> 01:07:01.600]  и может
[01:07:01.600 --> 01:07:03.600]  12.2 работает
[01:07:03.600 --> 01:07:05.600]  от ранга ты сейчас 13.1 кажется
[01:07:05.600 --> 01:07:07.600]  возможно они что-то сломали
[01:07:07.600 --> 01:07:09.600]  возможно
[01:07:09.600 --> 01:07:11.600]  возможно на 12 работает
[01:07:11.600 --> 01:07:13.600]  а на 13 снова нет
[01:07:13.600 --> 01:07:15.600]  12.2 у меня все еще не работает
[01:07:15.600 --> 01:07:17.600]  так, давайте
[01:07:17.600 --> 01:07:19.600]  я покажу то, что собирался
[01:07:19.600 --> 01:07:21.600]  короче
[01:07:21.600 --> 01:07:23.600]  теперь мы с вами
[01:07:23.600 --> 01:07:25.600]  что такое constexpr
[01:07:25.600 --> 01:07:27.600]  и это открывает нам
[01:07:27.600 --> 01:07:29.600]  больше возможностей для
[01:07:29.600 --> 01:07:31.600]  развлечений
[01:07:31.600 --> 01:07:33.600]  для разного метапрограммирования
[01:07:33.600 --> 01:07:35.600]  вот, и то, что я вам сейчас покажу
[01:07:35.600 --> 01:07:37.600]  это
[01:07:37.600 --> 01:07:39.600]  вещь, которая
[01:07:39.600 --> 01:07:41.600]  еще
[01:07:41.600 --> 01:07:43.600]  в C++14 работала
[01:07:43.600 --> 01:07:45.600]  это
[01:07:45.600 --> 01:07:47.600]  метафункция
[01:07:47.600 --> 01:07:49.600]  для определения того
[01:07:49.600 --> 01:07:51.600]  сколько полей в структуре
[01:07:51.600 --> 01:07:53.600]  чего?
[01:07:53.600 --> 01:07:55.600]  как пункт называется
[01:07:55.600 --> 01:07:57.600]  как пункт называется
[01:07:57.600 --> 01:07:59.600]  давайте
[01:07:59.600 --> 01:08:01.600]  16.5
[01:08:01.600 --> 01:08:03.600]  только что-нибудь смешное
[01:08:03.600 --> 01:08:05.600]  1 C++
[01:08:05.600 --> 01:08:07.600]  5 stretch functions
[01:08:07.600 --> 01:08:09.600]  ну
[01:08:09.600 --> 01:08:11.600]  давайте я
[01:08:11.600 --> 01:08:13.600]  это назову
[01:08:17.600 --> 01:08:19.600]  сейчас я придумаю как это назвать
[01:08:19.600 --> 01:08:21.600]  да, давайте так
[01:08:21.600 --> 01:08:23.600]  и назову
[01:08:41.600 --> 01:08:43.600]  сейчас я вам расскажу, что такое reflection
[01:08:43.600 --> 01:08:45.600]  кто из вас пишет на джабе?
[01:08:45.600 --> 01:08:47.600]  ваша задача
[01:08:47.600 --> 01:08:49.600]  я когда-то писал
[01:08:49.600 --> 01:08:51.600]  значит
[01:08:51.600 --> 01:08:53.600]  reflection это на самом деле еще
[01:08:53.600 --> 01:08:55.600]  такая общепрограммистский термин
[01:08:55.600 --> 01:08:57.600]  как лямбда функции
[01:08:57.600 --> 01:08:59.600]  возможно, как шаблоны
[01:08:59.600 --> 01:09:01.600]  reflection это такая
[01:09:01.600 --> 01:09:03.600]  штука, которой на самом деле SuperFuse до сих пор отсутствует
[01:09:03.600 --> 01:09:05.600]  это возможность из кода
[01:09:05.600 --> 01:09:07.600]  задавать вопросы о нем
[01:09:07.600 --> 01:09:09.600]  в джабе это есть
[01:09:09.600 --> 01:09:11.600]  например, вы можете спросить
[01:09:11.600 --> 01:09:13.600]  правда ли я сейчас
[01:09:13.600 --> 01:09:15.600]  нахожусь в
[01:09:15.600 --> 01:09:17.600]  методе
[01:09:17.600 --> 01:09:19.600]  который называется так-то
[01:09:19.600 --> 01:09:21.600]  или правда ли там
[01:09:21.600 --> 01:09:23.600]  этот класс обладает полем, который называется так
[01:09:23.600 --> 01:09:25.600]  правда ли у этого класса
[01:09:25.600 --> 01:09:27.600]  в котором я сейчас
[01:09:27.600 --> 01:09:29.600]  столько-то полей
[01:09:29.600 --> 01:09:31.600]  вот это то, что называется reflection
[01:09:31.600 --> 01:09:33.600]  в джабе это есть
[01:09:33.600 --> 01:09:35.600]  поддержка в языке
[01:09:37.600 --> 01:09:39.600]  в C++ пока этого нет
[01:09:39.600 --> 01:09:41.600]  и там все время идут разговоры о том, чтобы такую поддержку
[01:09:41.600 --> 01:09:43.600]  добавить вот-вот
[01:09:43.600 --> 01:09:45.600]  то ли в 23-х, то ли в 26-х
[01:09:45.600 --> 01:09:47.600]  это было еще разничественное усилие
[01:09:47.600 --> 01:09:49.600]  тем не менее, я вам сейчас покажу
[01:09:49.600 --> 01:09:51.600]  великолепнейшее изобретение
[01:09:51.600 --> 01:09:53.600]  штаб-авторства этого кода
[01:09:55.600 --> 01:09:57.600]  придумал это
[01:09:57.600 --> 01:09:59.600]  человек, которого зовут Антон Полухин
[01:09:59.600 --> 01:10:01.600]  он является
[01:10:01.600 --> 01:10:03.600]  членом
[01:10:03.600 --> 01:10:05.600]  комитета к санкционизации от России
[01:10:07.600 --> 01:10:09.600]  и придумал это еще много лет назад
[01:10:09.600 --> 01:10:11.600]  в общем, это пример того
[01:10:11.600 --> 01:10:13.600]  как с помощью шамлона программирования
[01:10:13.600 --> 01:10:15.600]  можно реализовывать уже сейчас
[01:10:15.600 --> 01:10:17.600]  уже тогда можно было
[01:10:17.600 --> 01:10:19.600]  некоторые
[01:10:19.600 --> 01:10:21.600]  рефлексивные штуки, например
[01:10:21.600 --> 01:10:23.600]  узнать сколько полей в структуре
[01:10:23.600 --> 01:10:25.600]  вот смотрите, вот у меня есть структура
[01:10:25.600 --> 01:10:27.600]  давайте
[01:10:27.600 --> 01:10:29.600]  у меня будет структура S, в которой
[01:10:29.600 --> 01:10:31.600]  два поля
[01:10:35.600 --> 01:10:37.600]  и будет структура SS
[01:10:37.600 --> 01:10:39.600]  в которой
[01:10:43.600 --> 01:10:45.600]  в которой будет три поля
[01:10:51.600 --> 01:10:53.600]  я сейчас проверю, что у первой структуры
[01:10:53.600 --> 01:10:55.600]  два поля, а у второй три
[01:10:55.600 --> 01:10:57.600]  как мне этим пользоваться
[01:10:57.600 --> 01:10:59.600]  ну, мне надо
[01:10:59.600 --> 01:11:01.600]  вызвать
[01:11:05.600 --> 01:11:07.600]  STDCOUT
[01:11:07.600 --> 01:11:09.600]  Detect
[01:11:09.600 --> 01:11:11.600]  ну, на самом деле это в Conspect Store
[01:11:11.600 --> 01:11:13.600]  можно сделать
[01:11:13.600 --> 01:11:15.600]  давайте я STDCOUT
[01:11:15.600 --> 01:11:17.600]  сделаю
[01:11:17.600 --> 01:11:19.600]  DetectFieldScout
[01:11:19.600 --> 01:11:21.600]  с шаблонным параметром A
[01:11:21.600 --> 01:11:23.600]  тут еще есть некоторые шаблонные параметры
[01:11:25.600 --> 01:11:27.600]  которые
[01:11:29.600 --> 01:11:31.600]  которые
[01:11:33.600 --> 01:11:35.600]  передать количество полей
[01:11:35.600 --> 01:11:37.600]  кажется
[01:11:37.600 --> 01:11:39.600]  могут мне
[01:11:41.600 --> 01:11:43.600]  я могу вот так сделать
[01:11:43.600 --> 01:11:45.600]  чтобы мы индексикум
[01:11:45.600 --> 01:11:47.600]  отставили
[01:11:51.600 --> 01:11:53.600]  вот
[01:11:53.600 --> 01:11:55.600]  и это должно быть равно
[01:11:59.600 --> 01:12:01.600]  сейчас я объясню, что такое индексиканс
[01:12:01.600 --> 01:12:03.600]  я просто пока пример показываю
[01:12:03.600 --> 01:12:05.600]  да
[01:12:05.600 --> 01:12:07.600]  что?
[01:12:07.600 --> 01:12:09.600]  да
[01:12:09.600 --> 01:12:11.600]  надо в
[01:12:11.600 --> 01:12:13.600]  sizeT записать результат
[01:12:13.600 --> 01:12:15.600]  так, мне очень удобно эта функция устроена
[01:12:15.600 --> 01:12:17.600]  ну, хорошо
[01:12:17.600 --> 01:12:19.600]  а, виноват
[01:12:19.600 --> 01:12:21.600]  с шаблонным параметром
[01:12:21.600 --> 01:12:23.600]  мне же не нужно передавать это
[01:12:23.600 --> 01:12:25.600]  я же могу передать просто вот сюда
[01:12:25.600 --> 01:12:27.600]  индексиканс отстав
[01:12:29.600 --> 01:12:31.600]  все, так, давайте проверим
[01:12:33.600 --> 01:12:35.600]  и STDCOUTX
[01:12:35.600 --> 01:12:37.600]  что?
[01:12:37.600 --> 01:12:39.600]  он посудеет?
[01:12:39.600 --> 01:12:41.600]  как еще так сделать?
[01:12:41.600 --> 01:12:43.600]  ну, давайте проверим
[01:12:43.600 --> 01:12:45.600]  так, DetectFieldScout
[01:12:45.600 --> 01:12:47.600]  на самом деле
[01:12:47.600 --> 01:12:49.600]  не важно какой
[01:12:49.600 --> 01:12:51.600]  DetectFieldScout
[01:12:51.600 --> 01:12:53.600]  а
[01:12:57.600 --> 01:12:59.600]  нужно include
[01:12:59.600 --> 01:13:01.600]  ну, хотя бы у стрима будет нормально
[01:13:03.600 --> 01:13:05.600]  и, видимо, еще include
[01:13:05.600 --> 01:13:07.600]  какой-нибудь
[01:13:07.600 --> 01:13:09.600]  type traits
[01:13:13.600 --> 01:13:15.600]  кажется, понадобится CSTDD
[01:13:15.600 --> 01:13:17.600]  чтобы CSTDD был
[01:13:17.600 --> 01:13:19.600]  making the sequence is not a number of STD
[01:13:19.600 --> 01:13:21.600]  хорошо
[01:13:25.600 --> 01:13:27.600]  making the sequence
[01:13:27.600 --> 01:13:29.600]  это штука, которая объявлена
[01:13:29.600 --> 01:13:31.600]  в утилите
[01:13:31.600 --> 01:13:33.600]  что такое
[01:13:33.600 --> 01:13:35.600]  индексиканс?
[01:13:35.600 --> 01:13:37.600]  это такой класс, который представляет
[01:13:37.600 --> 01:13:39.600]  всякую таймпоследовательность чисел
[01:13:39.600 --> 01:13:41.600]  индексиканс
[01:13:41.600 --> 01:13:43.600]  это просто класс, у которого
[01:13:43.600 --> 01:13:45.600]  шаблонные аргументы
[01:13:45.600 --> 01:13:47.600]  ладно, давайте я вам покажу
[01:13:47.600 --> 01:13:49.600]  его
[01:13:49.600 --> 01:13:51.600]  что такое индексиканс?
[01:13:51.600 --> 01:13:53.600]  это
[01:13:55.600 --> 01:13:57.600]  класс, у которого
[01:13:57.600 --> 01:13:59.600]  просто есть
[01:13:59.600 --> 01:14:01.600]  переменное число
[01:14:01.600 --> 01:14:03.600]  шаблонных аргументов
[01:14:03.600 --> 01:14:05.600]  интов
[01:14:05.600 --> 01:14:07.600]  но есть шаблонный класс integer sequence
[01:14:07.600 --> 01:14:09.600]  который первый шаблонный параметр
[01:14:09.600 --> 01:14:11.600]  имеет t, а дальше
[01:14:11.600 --> 01:14:13.600]  значит
[01:14:13.600 --> 01:14:15.600]  переменное количество
[01:14:15.600 --> 01:14:17.600]  типа в t
[01:14:17.600 --> 01:14:19.600]  как
[01:14:19.600 --> 01:14:21.600]  числовые шаблонные параметры
[01:14:21.600 --> 01:14:23.600]  у него есть специализация для int
[01:14:23.600 --> 01:14:25.600]  которая называется
[01:14:25.600 --> 01:14:27.600]  индексиканс
[01:14:27.600 --> 01:14:29.600]  индексиканс это пустой
[01:14:29.600 --> 01:14:31.600]  класс, у него просто пустое тело
[01:14:31.600 --> 01:14:33.600]  в котором
[01:14:33.600 --> 01:14:35.600]  у него есть параметр size, который
[01:14:35.600 --> 01:14:37.600]  возвращает сайзов
[01:14:37.600 --> 01:14:39.600]  количество этих чисел в последовательности
[01:14:39.600 --> 01:14:41.600]  класс тривиальный
[01:14:41.600 --> 01:14:43.600]  просто это compile-time
[01:14:43.600 --> 01:14:45.600]  понятно?
[01:14:45.600 --> 01:14:47.600]  вот, и есть
[01:14:47.600 --> 01:14:49.600]  функция makeIndexSequence
[01:14:49.600 --> 01:14:51.600]  которая просто генерирует по
[01:14:51.600 --> 01:14:53.600]  числу n последовательность
[01:14:53.600 --> 01:14:55.600]  0, 1, 2 и т.д. и минус 1
[01:14:55.600 --> 01:14:57.600]  вот
[01:14:57.600 --> 01:14:59.600]  что я здесь делаю
[01:14:59.600 --> 01:15:01.600]  я вот говорю
[01:15:01.600 --> 01:15:03.600]  вызываю на тегфилдс каунт
[01:15:03.600 --> 01:15:05.600]  с шаблонным параметром
[01:15:05.600 --> 01:15:07.600]  умываю структура
[01:15:07.600 --> 01:15:09.600]  от x запятая std makeIndexSequence
[01:15:09.600 --> 01:15:11.600]  от 100, давайте проверим еще раз
[01:15:13.600 --> 01:15:15.600]  так
[01:15:15.600 --> 01:15:17.600]  а, ну потому что мы с имп пытаемся передать
[01:15:17.600 --> 01:15:19.600]  туда посылки, а сайз ты ожидает
[01:15:19.600 --> 01:15:21.600]  а, да, нужно сайз ты
[01:15:23.600 --> 01:15:25.600]  хорошо, давайте еще раз проверим
[01:15:27.600 --> 01:15:29.600]  ого
[01:15:31.600 --> 01:15:33.600]  ну вот здесь
[01:15:33.600 --> 01:15:35.600]  сайз ты не делал
[01:15:35.600 --> 01:15:37.600]  почему ты 98?
[01:15:37.600 --> 01:15:39.600]  что?
[01:15:39.600 --> 01:15:41.600]  почему
[01:15:41.600 --> 01:15:43.600]  почему на 98 микс
[01:15:43.600 --> 01:15:45.600]  тихо?
[01:15:45.600 --> 01:15:47.600]  мне кажется, что у нас
[01:15:47.600 --> 01:15:49.600]  нет тут
[01:15:49.600 --> 01:15:51.600]  перегрузки
[01:15:57.600 --> 01:15:59.600]  мне кажется, нам не хватает
[01:15:59.600 --> 01:16:01.600]  окончания шаблонной рекурсии
[01:16:01.600 --> 01:16:03.600]  потому что то, что здесь происходит, это просто
[01:16:03.600 --> 01:16:05.600]  бесконечная шаблонная рекурсия
[01:16:05.600 --> 01:16:07.600]  давайте я попробую объяснить, как это работает
[01:16:07.600 --> 01:16:09.600]  сейчас мы
[01:16:09.600 --> 01:16:11.600]  вспомним, как это работает
[01:16:11.600 --> 01:16:13.600]  ну или поймем заново, кто это в первый раз видит
[01:16:13.600 --> 01:16:15.600]  и поймем, чего не хватает, чтобы это правильно работало
[01:16:15.600 --> 01:16:17.600]  что называется функция detectFieldScout
[01:16:17.600 --> 01:16:19.600]  которая первым аргументом принимает x, а вторым
[01:16:19.600 --> 01:16:21.600]  аргументом принимает makeIndexSequence
[01:16:21.600 --> 01:16:23.600]  makeIndexSequence это значит
[01:16:23.600 --> 01:16:25.600]  std makeIndexSequence от навора чисел
[01:16:25.600 --> 01:16:27.600]  вопрос
[01:16:27.600 --> 01:16:29.600]  в какую функцию мы попадаем? в первую или во вторую?
[01:16:29.600 --> 01:16:31.600]  в первом делу
[01:16:31.600 --> 01:16:33.600]  ну, дело в том, что
[01:16:33.600 --> 01:16:35.600]  одна из них более предпочтительна, другая менее предпочтительна
[01:16:35.600 --> 01:16:37.600]  какая более предпочтительна?
[01:16:37.600 --> 01:16:39.600]  первая
[01:16:39.600 --> 01:16:41.600]  а
[01:16:41.600 --> 01:16:43.600]  какая из них более предпочтительна?
[01:16:43.600 --> 01:16:45.600]  ну в первой
[01:16:45.600 --> 01:16:47.600]  у нас уже ясно первая база
[01:16:47.600 --> 01:16:49.600]  а вторая
[01:16:49.600 --> 01:16:51.600]  значит
[01:16:51.600 --> 01:16:53.600]  предпочтительна первая
[01:16:53.600 --> 01:16:55.600]  makeIndexSequence делает от 1 до 100
[01:16:55.600 --> 01:16:57.600]  от 0 до 99
[01:16:57.600 --> 01:16:59.600]  от 0 до 98
[01:16:59.600 --> 01:17:01.600]  откуда мы число 100 вообще взяли?
[01:17:01.600 --> 01:17:03.600]  от балды
[01:17:03.600 --> 01:17:05.600]  сейчас
[01:17:05.600 --> 01:17:07.600]  я расскажу, как это работает
[01:17:07.600 --> 01:17:09.600]  это видимо максимально коллибситва
[01:17:09.600 --> 01:17:11.600]  ну, я просто написал 100
[01:17:11.600 --> 01:17:13.600]  я считаю, что
[01:17:13.600 --> 01:17:15.600]  больше 100 балет точно не будет, поэтому
[01:17:15.600 --> 01:17:17.600]  написал 100
[01:17:17.600 --> 01:17:19.600]  в любом случае можно пихнуть туда
[01:17:19.600 --> 01:17:21.600]  sizeOfA
[01:17:21.600 --> 01:17:23.600]  можно побольше написать
[01:17:23.600 --> 01:17:25.600]  послушайте, пожалуйста,
[01:17:25.600 --> 01:17:27.600]  как это работает
[01:17:27.600 --> 01:17:29.600]  DetectFieldsCount
[01:17:29.600 --> 01:17:31.600]  вот эта версия предпочтительней
[01:17:31.600 --> 01:17:33.600]  потому что
[01:17:33.600 --> 01:17:35.600]  она более частная, чем эта
[01:17:35.600 --> 01:17:37.600]  почему она более частная версия, чем эта?
[01:17:37.600 --> 01:17:39.600]  потому что
[01:17:39.600 --> 01:17:41.600]  это принимает Т
[01:17:41.600 --> 01:17:43.600]  и какие угодно шумовые аргументы
[01:17:43.600 --> 01:17:45.600]  а это принимает Т, число
[01:17:45.600 --> 01:17:47.600]  и какие угодно шумовые аргументы
[01:17:47.600 --> 01:17:49.600]  первая версия более частная, чем вторая
[01:17:49.600 --> 01:17:51.600]  значит, мы идем в нее, и тут срабатывает стена E
[01:17:51.600 --> 01:17:53.600]  каким образом оно срабатывает?
[01:17:53.600 --> 01:17:55.600]  оно
[01:17:55.600 --> 01:17:57.600]  это функция
[01:17:57.600 --> 01:17:59.600]  она constexpr
[01:17:59.600 --> 01:18:01.600]  и тип этот
[01:18:01.600 --> 01:18:03.600]  это дегалтайк вот такого экспрешена
[01:18:05.600 --> 01:18:07.600]  что такое убик?
[01:18:07.600 --> 01:18:09.600]  а, я не написал, что такое убик конструктор
[01:18:09.600 --> 01:18:11.600]  все понятно
[01:18:11.600 --> 01:18:13.600]  я не написал
[01:18:13.600 --> 01:18:15.600]  нет, не написал, что такое убик конструктор
[01:18:15.600 --> 01:18:17.600]  нет, не написал, что такое убик конструктор
[01:18:17.600 --> 01:18:19.600]  а
[01:18:19.600 --> 01:18:21.600]  скрипастил код не целиком
[01:18:21.600 --> 01:18:23.600]  ну, давайте напишем
[01:18:23.600 --> 01:18:25.600]  template, typename, T
[01:18:25.600 --> 01:18:27.600]  значит
[01:18:27.600 --> 01:18:29.600]  что мне нужно?
[01:18:29.600 --> 01:18:31.600]  ну, я просто напишу using
[01:18:41.600 --> 01:18:43.600]  убик конструктор
[01:18:43.600 --> 01:18:45.600]  это будет штука, которая
[01:18:45.600 --> 01:18:47.600]  просто
[01:18:47.600 --> 01:18:49.600]  создает template sizeT
[01:18:49.600 --> 01:18:51.600]  и sizeTindex
[01:18:53.600 --> 01:18:55.600]  using
[01:18:57.600 --> 01:18:59.600]  конструктор
[01:18:59.600 --> 01:19:01.600]  равно
[01:19:03.600 --> 01:19:05.600]  убик
[01:19:05.600 --> 01:19:07.600]  что значит убик?
[01:19:07.600 --> 01:19:09.600]  убик, а слово убик пишется
[01:19:09.600 --> 01:19:11.600]  вездесущий
[01:19:11.600 --> 01:19:13.600]  все влащающий
[01:19:15.600 --> 01:19:17.600]  убик, сейчас давайте поймем,
[01:19:17.600 --> 01:19:19.600]  чему здесь надо сделать
[01:19:23.600 --> 01:19:25.600]  по-моему, вот так надо сделать
[01:19:25.600 --> 01:19:27.600]  а, нет, просто вот так
[01:19:29.600 --> 01:19:31.600]  давайте еще раз
[01:19:35.600 --> 01:19:37.600]  да, смотрите
[01:19:37.600 --> 01:19:39.600]  пока не компилируется, но сейчас мы это исправим
[01:19:39.600 --> 01:19:41.600]  что здесь написано?
[01:19:41.600 --> 01:19:43.600]  здесь я пытаюсь под деплтайпом создать
[01:19:43.600 --> 01:19:45.600]  T от вот таких аргументов
[01:19:45.600 --> 01:19:47.600]  вот это агрегатная инициализация
[01:19:49.600 --> 01:19:51.600]  я делаю агрегатную инициализацию T
[01:19:51.600 --> 01:19:53.600]  от
[01:19:53.600 --> 01:19:55.600]  некоторого набора
[01:19:55.600 --> 01:19:57.600]  аргументов
[01:19:57.600 --> 01:19:59.600]  убик это штука, которая умеет
[01:19:59.600 --> 01:20:01.600]  каститься к любому вообще типу
[01:20:03.600 --> 01:20:05.600]  это такая структура
[01:20:05.600 --> 01:20:07.600]  ну, вот такое название
[01:20:07.600 --> 01:20:09.600]  если я даю Антону Полухину, значит убик
[01:20:09.600 --> 01:20:11.600]  вездесущий
[01:20:11.600 --> 01:20:13.600]  штука, которая определенна для произвольного
[01:20:13.600 --> 01:20:15.600]  T каста к темперсанду
[01:20:17.600 --> 01:20:19.600]  что здесь написано дальше?
[01:20:19.600 --> 01:20:21.600]  дальше я написал шаблонный
[01:20:21.600 --> 01:20:23.600]  класс
[01:20:23.600 --> 01:20:25.600]  шаблонный юзинг убик конструктор
[01:20:25.600 --> 01:20:27.600]  который для всех
[01:20:27.600 --> 01:20:29.600]  для любого индекса это просто убик
[01:20:29.600 --> 01:20:31.600]  без каких-либо параметров
[01:20:31.600 --> 01:20:33.600]  теперь я
[01:20:33.600 --> 01:20:35.600]  вот здесь вот создаю
[01:20:35.600 --> 01:20:37.600]  такую распаковку
[01:20:37.600 --> 01:20:39.600]  я говорю
[01:20:39.600 --> 01:20:41.600]  T создаю я
[01:20:41.600 --> 01:20:43.600]  от набора убик конструктора
[01:20:43.600 --> 01:20:45.600]  и ноль без параметров
[01:20:45.600 --> 01:20:47.600]  запитаю убик конструктор
[01:20:47.600 --> 01:20:49.600]  от и без параметров многоточия
[01:20:49.600 --> 01:20:51.600]  то есть я как бы создаю
[01:20:51.600 --> 01:20:53.600]  много штук
[01:20:53.600 --> 01:20:55.600]  убик
[01:20:55.600 --> 01:20:57.600]  вот столько сколько их было в пакете
[01:20:57.600 --> 01:20:59.600]  и вызываю агрегатную инициализацию
[01:20:59.600 --> 01:21:01.600]  T от этого
[01:21:01.600 --> 01:21:03.600]  убик это тип, у которого есть каст к любому типу
[01:21:03.600 --> 01:21:05.600]  это значит
[01:21:05.600 --> 01:21:07.600]  что какие бы ни были
[01:21:07.600 --> 01:21:09.600]  типы полей T, если T это структура
[01:21:09.600 --> 01:21:11.600]  допускающая агрегатную инициализацию
[01:21:11.600 --> 01:21:13.600]  если я угадал число полей, то это
[01:21:13.600 --> 01:21:15.600]  корректная инициализация
[01:21:19.600 --> 01:21:21.600]  но я вызвался make integer sequence
[01:21:21.600 --> 01:21:23.600]  от 100
[01:21:23.600 --> 01:21:25.600]  и это означает
[01:21:25.600 --> 01:21:27.600]  что здесь я попытался инициализировать T
[01:21:27.600 --> 01:21:29.600]  сотней таких штук
[01:21:29.600 --> 01:21:31.600]  убик конструктор, каждый из которых кастится к любому типу
[01:21:31.600 --> 01:21:33.600]  но это как бы
[01:21:33.600 --> 01:21:35.600]  некорректная инициализация
[01:21:35.600 --> 01:21:37.600]  потому что
[01:21:37.600 --> 01:21:39.600]  полей я пытаюсь инициализировать больше
[01:21:39.600 --> 01:21:41.600]  чем их там есть на самом деле
[01:21:41.600 --> 01:21:43.600]  поэтому по SFINAE вот эта версия
[01:21:43.600 --> 01:21:45.600]  отваливается и я иду в менее
[01:21:45.600 --> 01:21:47.600]  предпочтительную версию
[01:21:47.600 --> 01:21:49.600]  что делает менее предпочтительная версия
[01:21:49.600 --> 01:21:51.600]  она делает
[01:21:51.600 --> 01:21:53.600]  все то же самое, просто
[01:21:53.600 --> 01:21:55.600]  make index sequence передает от меньшего числа
[01:21:55.600 --> 01:21:57.600]  аргументов
[01:21:57.600 --> 01:21:59.600]  соответственно, впервые
[01:21:59.600 --> 01:22:01.600]  в момент, когда я передам правильное
[01:22:01.600 --> 01:22:03.600]  число полей
[01:22:03.600 --> 01:22:05.600]  вот эта штука
[01:22:05.600 --> 01:22:07.600]  наконец-то будет
[01:22:07.600 --> 01:22:09.600]  корректным выражением, потому что я здесь
[01:22:09.600 --> 01:22:11.600]  пронициализирую T ровно от такого количества
[01:22:11.600 --> 01:22:13.600]  штуковин как можно
[01:22:13.600 --> 01:22:15.600]  это получается
[01:22:15.600 --> 01:22:17.600]  количество полей в T
[01:22:17.600 --> 01:22:19.600]  как будто количество
[01:22:19.600 --> 01:22:21.600]  полей конструктора
[01:22:21.600 --> 01:22:23.600]  нет, это агрегатная инициализация
[01:22:23.600 --> 01:22:25.600]  я инициализирую
[01:22:25.600 --> 01:22:27.600]  каждое поле чем-то
[01:22:27.600 --> 01:22:29.600]  а если в структурке у нас
[01:22:29.600 --> 01:22:31.600]  первые точки написаны private
[01:22:31.600 --> 01:22:33.600]  или какие-то кастомные конструкторы
[01:22:33.600 --> 01:22:35.600]  то кажется у нас уже не работает
[01:22:35.600 --> 01:22:37.600]  это правда, это работает только для структур
[01:22:37.600 --> 01:22:39.600]  напускающих агрегатную инициализацию
[01:22:39.600 --> 01:22:41.600]  я сделал
[01:22:41.600 --> 01:22:43.600]  конечно
[01:22:43.600 --> 01:22:45.600]  многообещающее заявление
[01:22:45.600 --> 01:22:47.600]  но это не совсем так
[01:22:47.600 --> 01:22:49.600]  это работает только для структуры
[01:22:49.600 --> 01:22:51.600]  напускающих агрегатную инициализацию
[01:22:51.600 --> 01:22:53.600]  давайте поймем почему это не работает
[01:22:53.600 --> 01:22:55.600]  вот это
[01:22:55.600 --> 01:22:57.600]  а
[01:22:57.600 --> 01:22:59.600]  returning to non-void
[01:22:59.600 --> 01:23:01.600]  returning to non-void
[01:23:01.600 --> 01:23:03.600]  а
[01:23:05.600 --> 01:23:07.600]  а вот и не умеет код упасть
[01:23:07.600 --> 01:23:09.600]  а сейчас
[01:23:09.600 --> 01:23:11.600]  ну видите
[01:23:11.600 --> 01:23:13.600]  а мы написали стрелочку decal type ot
[01:23:13.600 --> 01:23:15.600]  да, я написал стрелочку decal type ot
[01:23:15.600 --> 01:23:17.600]  давайте я здесь добавлю
[01:23:17.600 --> 01:23:19.600]  запятая void
[01:23:19.600 --> 01:23:21.600]  запятая
[01:23:21.600 --> 01:23:23.600]  throw 1
[01:23:23.600 --> 01:23:25.600]  что?
[01:23:25.600 --> 01:23:27.600]  ну throw type void
[01:23:27.600 --> 01:23:29.600]  все
[01:23:29.600 --> 01:23:31.600]  подождите
[01:23:31.600 --> 01:23:33.600]  ну я должен был
[01:23:33.600 --> 01:23:35.600]  ну как, comma 3
[01:23:35.600 --> 01:23:37.600]  я должен после запятой написать выражение
[01:23:37.600 --> 01:23:39.600]  того типа, который я хочу чтобы был возвращен
[01:23:39.600 --> 01:23:41.600]  void круглые скобки, нельзя там
[01:23:41.600 --> 01:23:43.600]  void нельзя конструировать
[01:23:43.600 --> 01:23:45.600]  это не отчего
[01:23:45.600 --> 01:23:47.600]  throw это выражение
[01:23:47.600 --> 01:23:49.600]  типа которого void
[01:23:49.600 --> 01:23:51.600]  если вы напишете decal type от throw 1
[01:23:51.600 --> 01:23:53.600]  звездочка, то у вас будет вот звездочка
[01:23:53.600 --> 01:23:55.600]  а почему не просто
[01:23:55.600 --> 01:23:57.600]  вот давайте проверим, что
[01:23:57.600 --> 01:23:59.600]  выбилось 2
[01:23:59.600 --> 01:24:01.600]  вот это не плохо, сейчас было
[01:24:01.600 --> 01:24:03.600]  о, все, два поля
[01:24:05.600 --> 01:24:07.600]  а кстати, бить сайзов
[01:24:07.600 --> 01:24:09.600]  чего-чего?
[01:24:09.600 --> 01:24:11.600]  а бить сайзов же даже в общем случае не работает
[01:24:11.600 --> 01:24:13.600]  сайзов?
[01:24:13.600 --> 01:24:15.600]  в качестве вот вместо
[01:24:15.600 --> 01:24:17.600]  ну да, там могут быть какие-нибудь полезные
[01:24:17.600 --> 01:24:19.600]  на 8
[01:24:19.600 --> 01:24:21.600]  в смысле
[01:24:21.600 --> 01:24:23.600]  сколько угодно блогов болеете
[01:24:23.600 --> 01:24:25.600]  пустых структур
[01:24:25.600 --> 01:24:27.600]  плаков и микодрес
[01:24:27.600 --> 01:24:29.600]  ну да
[01:24:29.600 --> 01:24:31.600]  вот, а теперь 3, понятно?
[01:24:31.600 --> 01:24:33.600]  мы научились определять количество полезных структур
[01:24:33.600 --> 01:24:35.600]  ну может отсутствие
[01:24:35.600 --> 01:24:37.600]  адреса, отсутствие наследования
[01:24:37.600 --> 01:24:39.600]  вот
[01:24:39.600 --> 01:24:41.600]  ну как, нормально?
[01:24:41.600 --> 01:24:43.600]  а кстати, как это работает с наследованием?
[01:24:43.600 --> 01:24:45.600]  никак
[01:24:45.600 --> 01:24:47.600]  значит, это работает для тех
[01:24:47.600 --> 01:24:49.600]  и только тех структур, которые допускают вреда к вентилизации
[01:24:49.600 --> 01:24:51.600]  все
[01:24:51.600 --> 01:24:53.600]  какие структуры я допускаю, мы обсуждали в 1-м месяце в октябре
[01:24:53.600 --> 01:24:55.600]  ну, это
[01:24:55.600 --> 01:24:57.600]  все, давайте закончим на этом
[01:24:57.600 --> 01:24:59.600]  значит, это пример того
[01:24:59.600 --> 01:25:01.600]  какие прикольные штуки можно делать
[01:25:01.600 --> 01:25:03.600]  с помощью, значит
[01:25:03.600 --> 01:25:05.600]  SFINAE с использованием
[01:25:05.600 --> 01:25:07.600]  constexpr и
[01:25:09.600 --> 01:25:11.600]  метапродагмических штуков
[01:25:11.600 --> 01:25:13.600]  кстати, как будто бы
[01:25:13.600 --> 01:25:15.600]  constexpr здесь и не нужно
[01:25:15.600 --> 01:25:17.600]  но тот факт, что
[01:25:17.600 --> 01:25:19.600]  это constexpr позволяет нам
[01:25:19.600 --> 01:25:21.600]  ну, результат этой функции используется
[01:25:21.600 --> 01:25:23.600]  в constexpr функция, правда же
[01:25:23.600 --> 01:25:25.600]  если я хочу в compile-time понять
[01:25:25.600 --> 01:25:27.600]  сколько у меня полезных структур
[01:25:27.600 --> 01:25:29.600]  в зависимости от того, что я что-то сделал
[01:25:29.600 --> 01:25:31.600]  ну представьте, я и пишу в constexpr функцию
[01:25:31.600 --> 01:25:33.600]  в которой делаю вот это
[01:25:33.600 --> 01:25:35.600]  и дальше if
[01:25:35.600 --> 01:25:37.600]  в зависимости от того, чему равно x
[01:25:37.600 --> 01:25:39.600]  что-то продолжается
[01:25:39.600 --> 01:25:41.600]  на самом деле, это что-то круче будет, если сделать
[01:25:41.600 --> 01:25:43.600]  что-то, которое перебирает вот этот вот
[01:25:43.600 --> 01:25:45.600]  типа
[01:25:45.600 --> 01:25:47.600]  сколько мы
[01:25:47.600 --> 01:25:49.600]  каковый размер у нас interger sequence, пока у нас ответ
[01:25:49.600 --> 01:25:51.600]  не окажется меньше, чем поданный размер
[01:25:57.600 --> 01:25:59.600]  ну, да, наверное, можно
[01:25:59.600 --> 01:26:01.600]  вот, ладно
[01:26:01.600 --> 01:26:03.600]  давайте, наконец, напишем tightlist
[01:26:03.600 --> 01:26:05.600]  Илья, какая ситуация
[01:26:05.600 --> 01:26:07.600]  это вообще может определиться?
[01:26:07.600 --> 01:26:09.600]  вопрос снимается
[01:26:09.600 --> 01:26:11.600]  не снимается и снимается
[01:26:11.600 --> 01:26:13.600]  ну, я не знаю
[01:26:13.600 --> 01:26:15.600]  ну, может
[01:26:15.600 --> 01:26:17.600]  вот приходишь ты на
[01:26:17.600 --> 01:26:19.600]  собеседование, тебе скажут
[01:26:19.600 --> 01:26:21.600]  что у нас есть структура
[01:26:21.600 --> 01:26:23.600]  ты говоришь
[01:26:23.600 --> 01:26:25.600]  сейчас напишу
[01:26:25.600 --> 01:26:27.600]  так
[01:26:27.600 --> 01:26:29.600]  тебе вдруг
[01:26:29.600 --> 01:26:31.600]  собеседование
[01:26:31.600 --> 01:26:33.600]  тебе говорят
[01:26:33.600 --> 01:26:35.600]  я тебе не пустил
[01:26:35.600 --> 01:26:37.600]  напоследок
[01:26:37.600 --> 01:26:39.600]  мы с вами
[01:26:39.600 --> 01:26:41.600]  позанимаемся так называемым
[01:26:41.600 --> 01:26:43.600]  value-based metaprogramming
[01:26:43.600 --> 01:26:45.600]  ну, по сути, предыдущее, что
[01:26:45.600 --> 01:26:47.600]  я вам показал, это уже и было, но
[01:26:47.600 --> 01:26:49.600]  что такое
[01:26:49.600 --> 01:26:51.600]  value-based metaprogramming
[01:26:51.600 --> 01:26:53.600]  это когда мы делаем
[01:26:53.600 --> 01:26:55.600]  метапрограммирование не за счет шаблонной рекурсии
[01:26:55.600 --> 01:26:57.600]  а за счет использования консистенции функций
[01:26:57.600 --> 01:26:59.600]  вот
[01:26:59.600 --> 01:27:01.600]  до того, как
[01:27:01.600 --> 01:27:03.600]  мы изучили консистенцию функций
[01:27:03.600 --> 01:27:05.600]  мы могли бы с вами делать шаблонное метапрограммирование
[01:27:05.600 --> 01:27:07.600]  ну
[01:27:07.600 --> 01:27:09.600]  мы могли бы, типа, сказать, что у нас есть
[01:27:09.600 --> 01:27:11.600]  структура
[01:27:11.600 --> 01:27:13.600]  type-list
[01:27:13.600 --> 01:27:15.600]  у которой переменная числа шаблонных аргументов
[01:27:15.600 --> 01:27:17.600]  и она в себе содержит
[01:27:17.600 --> 01:27:19.600]  голову и еще
[01:27:19.600 --> 01:27:21.600]  type-list отменьшила числа шаблонных аргументов
[01:27:21.600 --> 01:27:23.600]  вот
[01:27:23.600 --> 01:27:25.600]  делать с помощью шаблонной рекурсии
[01:27:25.600 --> 01:27:27.600]  подобные штуки, то есть
[01:27:29.600 --> 01:27:31.600]  метаконтейнеры, хранящие типы
[01:27:31.600 --> 01:27:33.600]  и это довольно неудобно
[01:27:33.600 --> 01:27:35.600]  и главное это неэффективно, потому что
[01:27:35.600 --> 01:27:37.600]  компилятору генерировать
[01:27:37.600 --> 01:27:39.600]  много типов
[01:27:39.600 --> 01:27:41.600]  и вообще разворачивать шаблонную рекурсию
[01:27:41.600 --> 01:27:43.600]  это медленно
[01:27:43.600 --> 01:27:45.600]  быстрее ему создавать
[01:27:45.600 --> 01:27:47.600]  объекты типов
[01:27:47.600 --> 01:27:49.600]  которые
[01:27:55.600 --> 01:27:57.600]  сами по себе
[01:27:57.600 --> 01:27:59.600]  типы это пустые структуры
[01:27:59.600 --> 01:28:01.600]  ну вот я вам сейчас
[01:28:01.600 --> 01:28:03.600]  давайте я покажу вам
[01:28:03.600 --> 01:28:05.600]  type-list
[01:28:05.600 --> 01:28:07.600]  как он был
[01:28:07.600 --> 01:28:09.600]  написан
[01:28:09.600 --> 01:28:11.600]  нет, тоже плохой type-list
[01:28:11.600 --> 01:28:13.600]  в смысле
[01:28:13.600 --> 01:28:15.600]  тоже хороший type-list
[01:28:15.600 --> 01:28:17.600]  а плохой type-list
[01:28:17.600 --> 01:28:19.600]  у меня был написан
[01:28:19.600 --> 01:28:21.600]  ладно, я забыл, он был написан
[01:28:21.600 --> 01:28:23.600]  не могу вам его показывать
[01:28:23.600 --> 01:28:25.600]  а можно код там пролистать один раз
[01:28:25.600 --> 01:28:27.600]  я вам сразу покажу хороший type-list
[01:28:27.600 --> 01:28:29.600]  нет, то что там было написано я сейчас задно напишу
[01:28:29.600 --> 01:28:31.600]  вот
[01:28:31.600 --> 01:28:33.600]  я вам просто покажу
[01:28:33.600 --> 01:28:35.600]  не буду показывать плохой type-list, сразу покажу хороший
[01:28:35.600 --> 01:28:37.600]  то есть смотрите еще раз, идея в чем
[01:28:37.600 --> 01:28:39.600]  я хочу написать мне
[01:28:39.600 --> 01:28:41.600]  класс, который будет основан
[01:28:41.600 --> 01:28:43.600]  на шаблонной рекурсии
[01:28:43.600 --> 01:28:45.600]  а я хочу написать
[01:28:47.600 --> 01:28:49.600]  такой вот класс
[01:28:53.600 --> 01:28:55.600]  у которого будет на самом деле пустое тело
[01:28:55.600 --> 01:28:57.600]  и пользоваться мы им будем так
[01:28:57.600 --> 01:28:59.600]  мы будем просто
[01:28:59.600 --> 01:29:01.600]  объекты этого класса создавать
[01:29:01.600 --> 01:29:03.600]  по умолчанию
[01:29:03.600 --> 01:29:05.600]  ну
[01:29:05.600 --> 01:29:07.600]  например давайте напишем
[01:29:07.600 --> 01:29:09.600]  функцию size для такого
[01:29:09.600 --> 01:29:11.600]  type-листа
[01:29:11.600 --> 01:29:13.600]  и мы будем писать функции для него
[01:29:13.600 --> 01:29:15.600]  как внешние функции
[01:29:15.600 --> 01:29:17.600]  то есть вот я пишу
[01:29:17.600 --> 01:29:19.600]  template, например
[01:29:19.600 --> 01:29:21.600]  type-name многоточие types
[01:29:21.600 --> 01:29:23.600]  а
[01:29:23.600 --> 01:29:25.600]  constexpr
[01:29:25.600 --> 01:29:27.600]  size
[01:29:27.600 --> 01:29:29.600]  size
[01:29:29.600 --> 01:29:31.600]  от type-list
[01:29:31.600 --> 01:29:33.600]  от types
[01:29:33.600 --> 01:29:35.600]  многоточие
[01:29:35.600 --> 01:29:37.600]  и я возвращаю
[01:29:37.600 --> 01:29:39.600]  size of
[01:29:39.600 --> 01:29:41.600]  многоточие
[01:29:41.600 --> 01:29:43.600]  от types
[01:29:43.600 --> 01:29:45.600]  вот
[01:29:45.600 --> 01:29:47.600]  соответственно в main я могу делать
[01:29:47.600 --> 01:29:49.600]  разные статикасерты, например какие
[01:29:49.600 --> 01:29:51.600]  я могу сказать
[01:29:51.600 --> 01:29:53.600]  статикасерп
[01:29:53.600 --> 01:29:55.600]  size
[01:29:55.600 --> 01:29:57.600]  от type-list
[01:29:57.600 --> 01:29:59.600]  int
[01:29:59.600 --> 01:30:01.600]  double char
[01:30:01.600 --> 01:30:03.600]  по умолчанию
[01:30:05.600 --> 01:30:07.600]  равно равно 3
[01:30:07.600 --> 01:30:09.600]  то есть
[01:30:09.600 --> 01:30:11.600]  моя семантика будет такой
[01:30:11.600 --> 01:30:13.600]  я не буду делать шаблонную рекурсию
[01:30:13.600 --> 01:30:15.600]  я буду использовать
[01:30:15.600 --> 01:30:17.600]  constexpr функции
[01:30:17.600 --> 01:30:19.600]  что-то говорить про вот этот пакет типов
[01:30:19.600 --> 01:30:21.600]  но не буду создавать вот это вот
[01:30:21.600 --> 01:30:23.600]  голову, хвост
[01:30:23.600 --> 01:30:25.600]  откусывать там что-то
[01:30:25.600 --> 01:30:27.600]  вот это мне не нравится
[01:30:29.600 --> 01:30:31.600]  сейчас мы оптимизируем фактически
[01:30:31.600 --> 01:30:33.600]  время
[01:30:33.600 --> 01:30:35.600]  да
[01:30:35.600 --> 01:30:37.600]  я именно на этом занимаюсь
[01:30:37.600 --> 01:30:39.600]  я утверждаю, что это будет гораздо быстрее
[01:30:39.600 --> 01:30:41.600]  чем делать
[01:30:41.600 --> 01:30:43.600]  через шаблонную рекурсию
[01:30:43.600 --> 01:30:45.600]  так сказать
[01:30:45.600 --> 01:30:47.600]  оптимизируем
[01:30:47.600 --> 01:30:49.600]  мы хотим написать метаконтейнер
[01:30:49.600 --> 01:30:51.600]  как вектор
[01:30:51.600 --> 01:30:53.600]  только для типов
[01:30:53.600 --> 01:30:55.600]  у нас есть последовательность типов
[01:30:55.600 --> 01:30:57.600]  что такое type-list
[01:30:57.600 --> 01:30:59.600]  это такая сущность, которая хранит
[01:30:59.600 --> 01:31:01.600]  последовательность типов
[01:31:01.600 --> 01:31:03.600]  в эту последовательность типов
[01:31:03.600 --> 01:31:05.600]  мы хотим уметь делать
[01:31:05.600 --> 01:31:07.600]  что мы с вектором умеем делать
[01:31:07.600 --> 01:31:09.600]  и чуть больше
[01:31:09.600 --> 01:31:11.600]  например pushback, popback, pushfront, popfront
[01:31:11.600 --> 01:31:13.600]  pushback по индексу
[01:31:13.600 --> 01:31:15.600]  какой тип на таком-то месте
[01:31:15.600 --> 01:31:17.600]  reverse
[01:31:17.600 --> 01:31:19.600]  sort
[01:31:19.600 --> 01:31:21.600]  find
[01:31:21.600 --> 01:31:23.600]  filter, sort
[01:31:23.600 --> 01:31:25.600]  stable sort
[01:31:25.600 --> 01:31:27.600]  и так далее
[01:31:27.600 --> 01:31:29.600]  я вам сегодня покажу sort
[01:31:29.600 --> 01:31:31.600]  кстати
[01:31:31.600 --> 01:31:33.600]  все эти
[01:31:33.600 --> 01:31:35.600]  апокемы наши сегодняшние
[01:31:35.600 --> 01:31:37.600]  здесь будет quick sort
[01:31:37.600 --> 01:31:39.600]  для набора типов
[01:31:39.600 --> 01:31:41.600]  вопрос
[01:31:41.600 --> 01:31:43.600]  как вы сравниваете
[01:31:43.600 --> 01:31:45.600]  так тихо
[01:31:45.600 --> 01:31:47.600]  это мы пока вопросы
[01:31:47.600 --> 01:31:49.600]  и вопроса ставим
[01:31:49.600 --> 01:31:51.600]  типа можно по-разному сравнить
[01:31:51.600 --> 01:31:53.600]  например у кого сайзеров больше
[01:31:53.600 --> 01:31:55.600]  можно
[01:31:55.600 --> 01:31:57.600]  по-разному
[01:31:57.600 --> 01:31:59.600]  давайте начнем
[01:31:59.600 --> 01:32:01.600]  с чего-нибудь простого
[01:32:01.600 --> 01:32:03.600]  давайте напишем
[01:32:03.600 --> 01:32:05.600]  самое простое, что можно написать для такого
[01:32:05.600 --> 01:32:07.600]  метаконтейнера
[01:32:07.600 --> 01:32:09.600]  popfront и pushfront
[01:32:09.600 --> 01:32:11.600]  ну сайзер написали
[01:32:11.600 --> 01:32:13.600]  давайте напишем popfront и pushfront
[01:32:13.600 --> 01:32:15.600]  а
[01:32:15.600 --> 01:32:17.600]  я хочу чтобы у меня была функция
[01:32:17.600 --> 01:32:19.600]  popfront
[01:32:19.600 --> 01:32:21.600]  которая работает так
[01:32:21.600 --> 01:32:23.600]  вот например если я
[01:32:23.600 --> 01:32:25.600]  сделаю popfront
[01:32:25.600 --> 01:32:27.600]  от
[01:32:27.600 --> 01:32:29.600]  чтобы в compile-time
[01:32:29.600 --> 01:32:31.600]  проверять корректность
[01:32:31.600 --> 01:32:33.600]  я хочу проверить, что popfront от
[01:32:33.600 --> 01:32:35.600]  такого type-листа
[01:32:35.600 --> 01:32:37.600]  это
[01:32:37.600 --> 01:32:39.600]  вот такой type-лист
[01:32:39.600 --> 01:32:41.600]  мне надо сначала написать
[01:32:41.600 --> 01:32:43.600]  оператор равно для type-листов
[01:32:43.600 --> 01:32:45.600]  сейчас
[01:32:45.600 --> 01:32:47.600]  у нас сайз
[01:32:47.600 --> 01:32:49.600]  точно правильно
[01:32:49.600 --> 01:32:51.600]  написан
[01:32:51.600 --> 01:32:53.600]  я проверил, я это скомпинировал
[01:32:53.600 --> 01:32:55.600]  и скомпинировал
[01:32:55.600 --> 01:32:57.600]  а что
[01:32:57.600 --> 01:32:59.600]  не понятно
[01:32:59.600 --> 01:33:01.600]  как он складывается
[01:33:01.600 --> 01:33:03.600]  сайтов многоточия это
[01:33:03.600 --> 01:33:05.600]  оператор
[01:33:05.600 --> 01:33:07.600]  он проверяет количество типов в пакете
[01:33:07.600 --> 01:33:09.600]  смотрите
[01:33:15.600 --> 01:33:17.600]  мне хочется сначала
[01:33:17.600 --> 01:33:19.600]  заиметь оператор равно равно для type-листов
[01:33:19.600 --> 01:33:21.600]  он будет просто
[01:33:21.600 --> 01:33:23.600]  вдавать true
[01:33:23.600 --> 01:33:25.600]  если типы type-листов совпадают
[01:33:25.600 --> 01:33:27.600]  и false иначе
[01:33:27.600 --> 01:33:29.600]  конечно
[01:33:29.600 --> 01:33:31.600]  constexpr был оператор равно равно
[01:33:33.600 --> 01:33:35.600]  для двух type-листов
[01:33:45.600 --> 01:33:47.600]  как мне написать равно равно для type-листов
[01:33:47.600 --> 01:33:49.600]  кто понимает
[01:33:49.600 --> 01:33:51.600]  что здесь надо написать
[01:33:51.600 --> 01:33:53.600]  нет
[01:33:53.600 --> 01:33:55.600]  здесь надо написать return false
[01:33:55.600 --> 01:33:57.600]  а еще надо сделать вот такую перегрузку
[01:33:57.600 --> 01:33:59.600]  это уже скатывается
[01:33:59.600 --> 01:34:01.600]  как обычно
[01:34:01.600 --> 01:34:03.600]  в смысле скатывается
[01:34:03.600 --> 01:34:05.600]  я не делаю шаблонную рекурсию
[01:34:05.600 --> 01:34:07.600]  идея как раз
[01:34:07.600 --> 01:34:09.600]  то что ты сказал
[01:34:09.600 --> 01:34:11.600]  это как раз плохое метапрограммирование
[01:34:11.600 --> 01:34:13.600]  я вынужден был бы делать шаблонную рекурсию
[01:34:13.600 --> 01:34:15.600]  я не хочу делать шаблонную рекурсию
[01:34:15.600 --> 01:34:17.600]  я хочу чтобы вот
[01:34:17.600 --> 01:34:19.600]  все в одну строчку работало
[01:34:19.600 --> 01:34:21.600]  а у нас же кажется
[01:34:21.600 --> 01:34:23.600]  точно так что сработает там
[01:34:23.600 --> 01:34:25.600]  условный
[01:34:25.600 --> 01:34:27.600]  я не хочу заставлять
[01:34:27.600 --> 01:34:29.600]  вот этот оператор равно равно
[01:34:29.600 --> 01:34:31.600]  работает за линейное время
[01:34:31.600 --> 01:34:33.600]  если бы я делал шаблонную рекурсию
[01:34:33.600 --> 01:34:35.600]  откусывая по куску
[01:34:35.600 --> 01:34:37.600]  это бы работало за квадрат
[01:34:37.600 --> 01:34:39.600]  потому что комператору по ходу дела
[01:34:39.600 --> 01:34:41.600]  пришлось бы создать n type-листов
[01:34:41.600 --> 01:34:43.600]  для каждого с откушенным типом
[01:34:43.600 --> 01:34:45.600]  можно же
[01:34:45.600 --> 01:34:47.600]  такую же штуку сделать
[01:34:47.600 --> 01:34:49.600]  но только сделав
[01:34:49.600 --> 01:34:51.600]  проверить что одинаковый сайз
[01:34:51.600 --> 01:34:53.600]  и дальше false expression
[01:34:53.600 --> 01:34:55.600]  из сейм
[01:34:55.600 --> 01:34:57.600]  из сейм
[01:34:57.600 --> 01:34:59.600]  из сейм
[01:34:59.600 --> 01:35:01.600]  а если
[01:35:01.600 --> 01:35:03.600]  разные сайзы
[01:35:03.600 --> 01:35:05.600]  то у тебя false expression как сработает
[01:35:05.600 --> 01:35:07.600]  я сказал сначала
[01:35:07.600 --> 01:35:09.600]  size of
[01:35:09.600 --> 01:35:11.600]  size of разный
[01:35:11.600 --> 01:35:13.600]  и turn false
[01:35:13.600 --> 01:35:15.600]  а иначе
[01:35:15.600 --> 01:35:17.600]  иначе false expression
[01:35:17.600 --> 01:35:19.600]  и сейм
[01:35:19.600 --> 01:35:21.600]  а как ты параллельно
[01:35:21.600 --> 01:35:23.600]  выжим
[01:35:23.600 --> 01:35:25.600]  не очень понятно
[01:35:25.600 --> 01:35:27.600]  а если у них
[01:35:27.600 --> 01:35:29.600]  ну короче я не знаю
[01:35:29.600 --> 01:35:31.600]  наверное можно
[01:35:31.600 --> 01:35:33.600]  но я убеждаю что так тоже
[01:35:33.600 --> 01:35:35.600]  вот я
[01:35:35.600 --> 01:35:37.600]  теперь еще напишу оператор не равно
[01:35:37.600 --> 01:35:39.600]  который будет просто отрицать
[01:35:39.600 --> 01:35:41.600]  равность
[01:35:41.600 --> 01:35:43.600]  а его компилятор за нас не напишет?
[01:35:43.600 --> 01:35:45.600]  размечтался
[01:35:45.600 --> 01:35:47.600]  тут мне надо будет все таки
[01:35:47.600 --> 01:35:49.600]  вот так сделать
[01:35:51.600 --> 01:35:53.600]  ну вот
[01:35:53.600 --> 01:35:55.600]  я хочу
[01:35:55.600 --> 01:35:57.600]  когда я умею сравнивать
[01:35:57.600 --> 01:35:59.600]  тайплисты на равенство
[01:35:59.600 --> 01:36:01.600]  то есть я говорю что один тайплист как равен другому
[01:36:01.600 --> 01:36:03.600]  если
[01:36:03.600 --> 01:36:05.600]  и только если
[01:36:05.600 --> 01:36:07.600]  у них последовательности типов совпадают
[01:36:07.600 --> 01:36:09.600]  m
[01:36:09.600 --> 01:36:11.600]  теперь я могу
[01:36:11.600 --> 01:36:13.600]  захотеть
[01:36:13.600 --> 01:36:15.600]  написать поп-фронт
[01:36:15.600 --> 01:36:17.600]  что такое поп-фронт
[01:36:17.600 --> 01:36:19.600]  если я из тайплиста один дабл чар
[01:36:19.600 --> 01:36:21.600]  то должен получиться тайплист дабл чар
[01:36:21.600 --> 01:36:23.600]  поп-фронт
[01:36:23.600 --> 01:36:25.600]  ну и push-фронт
[01:36:25.600 --> 01:36:27.600]  push-фронт
[01:36:27.600 --> 01:36:29.600]  это что если я
[01:36:29.600 --> 01:36:31.600]  к тайплисту дабл чар сделаю
[01:36:31.600 --> 01:36:33.600]  push-фронт
[01:36:33.600 --> 01:36:35.600]  получится тайплист int-дабл чар
[01:36:35.600 --> 01:36:37.600]  push-фронт только еще нужно сказать
[01:36:37.600 --> 01:36:39.600]  какой тип
[01:36:39.600 --> 01:36:41.600]  так давайте с push-фронт потом разберемся
[01:36:41.600 --> 01:36:43.600]  как мы типом будем указывать
[01:36:43.600 --> 01:36:45.600]  сначала поп-фронт
[01:36:45.600 --> 01:36:47.600]  как написать поп-фронт кто понимает
[01:36:47.600 --> 01:36:49.600]  во-первых специализация пистолы
[01:36:55.600 --> 01:36:57.600]  что надо написать
[01:36:57.600 --> 01:36:59.600]  мы хотим делать
[01:36:59.600 --> 01:37:01.600]  head tail
[01:37:01.600 --> 01:37:03.600]  понимать тайплист head tail
[01:37:03.600 --> 01:37:05.600]  да нам здесь потребуется
[01:37:05.600 --> 01:37:07.600]  head tail
[01:37:07.600 --> 01:37:09.600]  это правда
[01:37:09.600 --> 01:37:11.600]  constexpr auto я не хочу повторять
[01:37:11.600 --> 01:37:13.600]  тип того что вернется
[01:37:13.600 --> 01:37:15.600]  constexpr auto
[01:37:15.600 --> 01:37:17.600]  поп-фронт от
[01:37:17.600 --> 01:37:19.600]  тайплист head
[01:37:19.600 --> 01:37:21.600]  tail
[01:37:21.600 --> 01:37:23.600]  многоточие
[01:37:23.600 --> 01:37:25.600]  что мне надо вернуть
[01:37:25.600 --> 01:37:27.600]  не надо вернуть до
[01:37:27.600 --> 01:37:29.600]  tail
[01:37:29.600 --> 01:37:31.600]  многоточие
[01:37:31.600 --> 01:37:33.600]  да очень просто
[01:37:33.600 --> 01:37:35.600]  вот так реализовывается
[01:37:35.600 --> 01:37:37.600]  да
[01:37:37.600 --> 01:37:39.600]  так реализовывается
[01:37:39.600 --> 01:37:41.600]  я думаю что последний знач проще
[01:37:41.600 --> 01:37:43.600]  я не знаю
[01:37:43.600 --> 01:37:45.600]  вам надо будет вверх что-то написать
[01:37:45.600 --> 01:37:47.600]  проще чем дэк
[01:37:47.600 --> 01:37:49.600]  дэк
[01:37:49.600 --> 01:37:51.600]  а дальше давайте
[01:37:51.600 --> 01:37:53.600]  push-фронт как будет выглядеть
[01:37:55.600 --> 01:37:57.600]  как будет выглядеть push-фронт
[01:37:57.600 --> 01:37:59.600]  или я
[01:37:59.600 --> 01:38:01.600]  а если пустой
[01:38:01.600 --> 01:38:03.600]  ну сами разберитесь с этим случаем
[01:38:03.600 --> 01:38:05.600]  я не буду
[01:38:05.600 --> 01:38:07.600]  ну тип
[01:38:07.600 --> 01:38:09.600]  поставьте кассет пол
[01:38:09.600 --> 01:38:11.600]  тут все идеи что мы хотим
[01:38:11.600 --> 01:38:13.600]  да
[01:38:13.600 --> 01:38:15.600]  поскольку
[01:38:15.600 --> 01:38:17.600]  это все бессмысленно в рентайме
[01:38:17.600 --> 01:38:19.600]  то логично что мы хотим
[01:38:19.600 --> 01:38:21.600]  ци
[01:38:21.600 --> 01:38:23.600]  поп-фронт от пустого нам даст ци
[01:38:23.600 --> 01:38:25.600]  да потому что у нас нет специфика
[01:38:25.600 --> 01:38:27.600]  у нас нет хэда
[01:38:27.600 --> 01:38:29.600]  возможно мы хотим ци с более смысленным сообщением
[01:38:31.600 --> 01:38:33.600]  возможно
[01:38:33.600 --> 01:38:35.600]  у нас специализация перегрузки этой функции
[01:38:35.600 --> 01:38:37.600]  которая ставит кассет фолс и текст
[01:38:37.600 --> 01:38:39.600]  которая ставит кассет какой-нибудь
[01:38:39.600 --> 01:38:41.600]  я не знаю
[01:38:41.600 --> 01:38:43.600]  хорошо как push-фронт теперь работает
[01:38:43.600 --> 01:38:45.600]  ну push-фронт мы должны добавить еще
[01:38:45.600 --> 01:38:47.600]  один шамлонный аргумент
[01:38:47.600 --> 01:38:49.600]  ну понимаешь
[01:38:49.600 --> 01:38:51.600]  я понимаю
[01:38:51.600 --> 01:38:53.600]  видишь он мне тоже не нравится
[01:38:53.600 --> 01:38:55.600]  да
[01:38:55.600 --> 01:38:57.600]  да здесь уже хэда тейл кажется
[01:38:57.600 --> 01:38:59.600]  не нужен
[01:38:59.600 --> 01:39:01.600]  ну только его не хэд
[01:39:01.600 --> 01:39:03.600]  надо называть
[01:39:03.600 --> 01:39:05.600]  здесь просто т
[01:39:05.600 --> 01:39:07.600]  а здесь тайпс
[01:39:07.600 --> 01:39:09.600]  мы получаем тайплист от типов
[01:39:11.600 --> 01:39:13.600]  и возвращаем тайплист
[01:39:13.600 --> 01:39:15.600]  от т и от тех самых типов
[01:39:15.600 --> 01:39:17.600]  как нам пользоваться push-фронтом
[01:39:17.600 --> 01:39:19.600]  мы пишем push-фронт
[01:39:19.600 --> 01:39:21.600]  с каким-то шамлоном
[01:39:21.600 --> 01:39:23.600]  параметром
[01:39:23.600 --> 01:39:25.600]  логично
[01:39:25.600 --> 01:39:27.600]  от тайплиста
[01:39:27.600 --> 01:39:29.600]  и получаем тайплист
[01:39:29.600 --> 01:39:31.600]  от вот этих трех типов
[01:39:31.600 --> 01:39:33.600]  правильно
[01:39:37.600 --> 01:39:39.600]  запускать бессмысленно
[01:39:41.600 --> 01:39:43.600]  идем дальше
[01:39:43.600 --> 01:39:45.600]  что мы еще хотим написать
[01:39:45.600 --> 01:39:47.600]  pop-back push-back
[01:39:49.600 --> 01:39:51.600]  давайте pop-back и push-back я оставлю
[01:39:51.600 --> 01:39:53.600]  на самостоятельное упражнение
[01:39:53.600 --> 01:39:55.600]  одну из них
[01:39:55.600 --> 01:39:57.600]  написать легко
[01:39:57.600 --> 01:39:59.600]  а второе нелегко
[01:39:59.600 --> 01:40:01.600]  вот pop-back написать
[01:40:01.600 --> 01:40:03.600]  да push-back написать легко
[01:40:03.600 --> 01:40:05.600]  а pop-back пока непонятно написать
[01:40:05.600 --> 01:40:07.600]  да вроде что
[01:40:07.600 --> 01:40:09.600]  потому что
[01:40:09.600 --> 01:40:11.600]  в чем проблема написать pop-back
[01:40:11.600 --> 01:40:13.600]  потому что
[01:40:13.600 --> 01:40:15.600]  по pop-back мне придется
[01:40:15.600 --> 01:40:17.600]  принять тайплист от тайпс многоточия
[01:40:17.600 --> 01:40:19.600]  запятая т
[01:40:19.600 --> 01:40:21.600]  чтобы потом откусить его с конца
[01:40:21.600 --> 01:40:23.600]  но так у типов не работает
[01:40:23.600 --> 01:40:25.600]  я не могу после пакета через запятую
[01:40:25.600 --> 01:40:27.600]  еще т написать
[01:40:27.600 --> 01:40:29.600]  он не выведет тогда пакет
[01:40:29.600 --> 01:40:31.600]  т запятая тайпс он может вывести
[01:40:31.600 --> 01:40:33.600]  а вот тайпс многоточие
[01:40:33.600 --> 01:40:35.600]  он не выведет
[01:40:35.600 --> 01:40:37.600]  а какой оператор равно передал?
[01:40:37.600 --> 01:40:39.600]  реверс
[01:40:39.600 --> 01:40:41.600]  у нас пока нет реверс
[01:40:41.600 --> 01:40:43.600]  как вы оператор равно передали?
[01:40:43.600 --> 01:40:45.600]  это не очень легко
[01:40:45.600 --> 01:40:47.600]  оператор равно я не передавал
[01:40:47.600 --> 01:40:49.600]  пакет
[01:40:49.600 --> 01:40:51.600]  я не
[01:40:51.600 --> 01:40:53.600]  где это здесь видишь?
[01:40:53.600 --> 01:40:55.600]  два пакета
[01:40:55.600 --> 01:40:57.600]  да он однозначно понимает
[01:40:57.600 --> 01:40:59.600]  что является собой каждый из пакетов
[01:40:59.600 --> 01:41:01.600]  потому что первый пакет
[01:41:01.600 --> 01:41:03.600]  который в первом тайплисте
[01:41:03.600 --> 01:41:05.600]  второй пакет в том списке
[01:41:05.600 --> 01:41:07.600]  таким образом он понимает
[01:41:07.600 --> 01:41:09.600]  чем является каждый из этих пакетов
[01:41:09.600 --> 01:41:11.600]  ему не приходится
[01:41:11.600 --> 01:41:13.600]  брать пакет
[01:41:13.600 --> 01:41:15.600]  и в конце
[01:41:15.600 --> 01:41:17.600]  из пакета выкусывать с конца тип
[01:41:17.600 --> 01:41:19.600]  он понимает что у него первый пакет
[01:41:19.600 --> 01:41:21.600]  и второй пакет
[01:41:21.600 --> 01:41:23.600]  так дедакшн сделал сначала
[01:41:23.600 --> 01:41:25.600]  тут все что он делает это тайп дедакшн
[01:41:25.600 --> 01:41:27.600]  называется процесс догадывания
[01:41:27.600 --> 01:41:29.600]  какие именно типы верены
[01:41:29.600 --> 01:41:31.600]  о чем проблема сделать реверс
[01:41:31.600 --> 01:41:33.600]  у нас есть поп фронт и push back
[01:41:33.600 --> 01:41:35.600]  значит мы можем сделать реверс
[01:41:35.600 --> 01:41:37.600]  да можем сделать реверс
[01:41:37.600 --> 01:41:39.600]  но эффективно сделать надо
[01:41:41.600 --> 01:41:43.600]  можно как нибудь разделяйкой
[01:41:43.600 --> 01:41:45.600]  поп фронт
[01:41:45.600 --> 01:41:47.600]  push pop фронт
[01:41:47.600 --> 01:41:49.600]  push back сделать
[01:41:49.600 --> 01:41:51.600]  пока он не опустит
[01:41:51.600 --> 01:41:53.600]  сколько это будет времени работать?
[01:41:53.600 --> 01:41:55.600]  если разделяйкой
[01:41:55.600 --> 01:41:57.600]  и реверс сделать
[01:41:57.600 --> 01:41:59.600]  тебе придется создать
[01:41:59.600 --> 01:42:01.600]  кучу тейп листов
[01:42:01.600 --> 01:42:03.600]  для всех последних листов
[01:42:03.600 --> 01:42:05.600]  я умею создавать кучу тейп листов
[01:42:05.600 --> 01:42:07.600]  и за квадрат делать сразу
[01:42:07.600 --> 01:42:09.600]  поп фронт и push back
[01:42:11.600 --> 01:42:13.600]  так господа
[01:42:13.600 --> 01:42:15.600]  давайте напишем что нибудь еще
[01:42:15.600 --> 01:42:17.600]  я буду идти
[01:42:17.600 --> 01:42:19.600]  в том порядке в котором
[01:42:19.600 --> 01:42:21.600]  в итоге push back и pop back
[01:42:21.600 --> 01:42:23.600]  за линию?
[01:42:23.600 --> 01:42:25.600]  да
[01:42:25.600 --> 01:42:27.600]  он так и будет работать
[01:42:27.600 --> 01:42:29.600]  pop back
[01:42:29.600 --> 01:42:31.600]  ну push back мы и так можем
[01:42:31.600 --> 01:42:33.600]  за линию сделать
[01:42:33.600 --> 01:42:35.600]  а pop back
[01:42:37.600 --> 01:42:39.600]  ну за квадрат
[01:42:39.600 --> 01:42:41.600]  это очевидно
[01:42:43.600 --> 01:42:45.600]  вообще звучит как будто
[01:42:45.600 --> 01:42:47.600]  pop back проще сделать через рейс
[01:42:47.600 --> 01:42:49.600]  по индексу и все
[01:42:53.600 --> 01:42:55.600]  по дурацки
[01:42:55.600 --> 01:42:57.600]  за квадрат
[01:42:57.600 --> 01:42:59.600]  мне кажется что
[01:43:01.600 --> 01:43:03.600]  push back у нас
[01:43:03.600 --> 01:43:05.600]  все равно будет за квадрат в итоге
[01:43:05.600 --> 01:43:07.600]  а в стандаче его нет
[01:43:07.600 --> 01:43:09.600]  тейп листа
[01:43:09.600 --> 01:43:11.600]  в эсстрель нет
[01:43:11.600 --> 01:43:13.600]  какая жалость
[01:43:13.600 --> 01:43:15.600]  есть густия правда
[01:43:15.600 --> 01:43:17.600]  подождите
[01:43:17.600 --> 01:43:19.600]  так давайте дальше
[01:43:19.600 --> 01:43:21.600]  пока давайте дальше
[01:43:21.600 --> 01:43:23.600]  это значит отклоняемся от курса
[01:43:23.600 --> 01:43:25.600]  давайте в прочей некого идут
[01:43:25.600 --> 01:43:27.600]  нет, сначала мы напишем
[01:43:27.600 --> 01:43:29.600]  идея для квадрата C++
[01:43:29.600 --> 01:43:31.600]  звучать густой
[01:43:33.600 --> 01:43:35.600]  сейчас я скажу что мы сначала напишем
[01:43:35.600 --> 01:43:37.600]  сначала мы напишем find
[01:43:37.600 --> 01:43:39.600]  по значению
[01:43:39.600 --> 01:43:41.600]  по типу то бишь
[01:43:41.600 --> 01:43:43.600]  сначала мы напишем такое
[01:43:43.600 --> 01:43:45.600]  я хочу
[01:43:45.600 --> 01:43:47.600]  в тейп листе за линию
[01:43:47.600 --> 01:43:49.600]  уметь проверять присутствует
[01:43:49.600 --> 01:43:51.600]  на самом деле
[01:43:51.600 --> 01:43:53.600]  это достаточно полезная штука
[01:43:53.600 --> 01:43:55.600]  вот вы спрашивали
[01:43:55.600 --> 01:43:57.600]  где это надо
[01:43:57.600 --> 01:43:59.600]  вот я лично с этим
[01:43:59.600 --> 01:44:01.600]  сталкивался в продакшене
[01:44:01.600 --> 01:44:03.600]  у вас есть последовательность типов
[01:44:03.600 --> 01:44:05.600]  есть ли в ней такой то
[01:44:05.600 --> 01:44:07.600]  но хочется это сделать не через шамлонную
[01:44:07.600 --> 01:44:09.600]  рекурсию, понятно что это можно сделать
[01:44:09.600 --> 01:44:11.600]  шамлонной рекурсией
[01:44:11.600 --> 01:44:13.600]  хочется это сделать не создавая
[01:44:13.600 --> 01:44:15.600]  промежуточных
[01:44:15.600 --> 01:44:17.600]  квадрат типов
[01:44:17.600 --> 01:44:19.600]  можно это сделать и не за квадрат
[01:44:19.600 --> 01:44:21.600]  да, можно это сделать
[01:44:21.600 --> 01:44:23.600]  fold expression
[01:44:23.600 --> 01:44:25.600]  давайте попробуем
[01:44:25.600 --> 01:44:27.600]  я пишу
[01:44:41.600 --> 01:44:43.600]  я хочу проверить есть ли
[01:44:43.600 --> 01:44:45.600]  в списке типов данный тип
[01:44:45.600 --> 01:44:47.600]  например я пишу
[01:44:47.600 --> 01:44:49.600]  static assert
[01:44:49.600 --> 01:44:51.600]  find
[01:44:51.600 --> 01:44:53.600]  даже не так
[01:44:53.600 --> 01:44:55.600]  я хочу индекс его вывести
[01:44:55.600 --> 01:44:57.600]  я хочу не просто узнать где он
[01:44:57.600 --> 01:44:59.600]  а назвать его индекс
[01:44:59.600 --> 01:45:01.600]  либо если его нет, то
[01:45:01.600 --> 01:45:03.600]  find
[01:45:03.600 --> 01:45:05.600]  от int
[01:45:05.600 --> 01:45:07.600]  type list
[01:45:07.600 --> 01:45:09.600]  от int double char
[01:45:11.600 --> 01:45:13.600]  равно 0
[01:45:15.600 --> 01:45:17.600]  find double int double char
[01:45:17.600 --> 01:45:19.600]  равно
[01:45:19.600 --> 01:45:21.600]  1
[01:45:21.600 --> 01:45:23.600]  find char double char
[01:45:23.600 --> 01:45:25.600]  равно 0
[01:45:25.600 --> 01:45:27.600]  и find
[01:45:27.600 --> 01:45:29.600]  и find
[01:45:29.600 --> 01:45:31.600]  и давайте да
[01:45:31.600 --> 01:45:33.600]  find
[01:45:33.600 --> 01:45:35.600]  find
[01:45:37.600 --> 01:45:39.600]  void
[01:45:39.600 --> 01:45:41.600]  type list
[01:45:41.600 --> 01:45:43.600]  double char
[01:45:43.600 --> 01:45:45.600]  теперь он точно
[01:45:47.600 --> 01:45:49.600]  вот, хотим чтобы это за линию
[01:45:49.600 --> 01:45:51.600]  работало, а не за квадрат, как если
[01:45:51.600 --> 01:45:53.600]  мы делали через шамлонную рекурсию, как же
[01:45:53.600 --> 01:45:55.600]  этого добиться
[01:45:59.600 --> 01:46:01.600]  это чуть менее, просто проверить
[01:46:01.600 --> 01:46:03.600]  наличие это тривиально
[01:46:03.600 --> 01:46:05.600]  а проверить наличие как?
[01:46:05.600 --> 01:46:07.600]  и same
[01:46:07.600 --> 01:46:09.600]  и same fold expression
[01:46:09.600 --> 01:46:11.600]  а можно какой-нибудь хитрый
[01:46:11.600 --> 01:46:13.600]  и same fold expression
[01:46:13.600 --> 01:46:15.600]  давайте пинплоиском проверять наличие
[01:46:15.600 --> 01:46:17.600]  а мы можем сделать какой-нибудь
[01:46:17.600 --> 01:46:19.600]  пинплоиск как зализать?
[01:46:19.600 --> 01:46:21.600]  откуда?
[01:46:21.600 --> 01:46:23.600]  проверяем что есть в квасте длины половины
[01:46:23.600 --> 01:46:25.600]  потом разделяемся
[01:46:25.600 --> 01:46:27.600]  а нет, стоп
[01:46:27.600 --> 01:46:29.600]  это за линию суммары
[01:46:31.600 --> 01:46:33.600]  звучит конечно круто, но как
[01:46:33.600 --> 01:46:35.600]  ну как половину найти
[01:46:35.600 --> 01:46:37.600]  да, как найти половину
[01:46:37.600 --> 01:46:39.600]  это отличный вопрос, как найти середину
[01:46:39.600 --> 01:46:41.600]  ты пил в рандомный элемент
[01:46:41.600 --> 01:46:43.600]  вероятно
[01:46:43.600 --> 01:46:45.600]  а как пил в рандомный элемент, у нас пока нет обращения
[01:46:45.600 --> 01:46:47.600]  а есть констэкспор
[01:46:47.600 --> 01:46:49.600]  рандомный
[01:46:49.600 --> 01:46:51.600]  нет
[01:46:51.600 --> 01:46:53.600]  скорее интересно, есть ли констэкспор
[01:46:53.600 --> 01:46:55.600]  какой-нибудь минимум
[01:46:55.600 --> 01:46:57.600]  можем ли мы какой-нибудь хитрый
[01:46:57.600 --> 01:46:59.600]  fold expression с логикой
[01:46:59.600 --> 01:47:01.600]  написать
[01:47:05.600 --> 01:47:07.600]  так, смотрите, нам надо создать
[01:47:07.600 --> 01:47:09.600]  мы хотим сделать
[01:47:09.600 --> 01:47:11.600]  некоторые fold expression, это правда
[01:47:11.600 --> 01:47:13.600]  который бы
[01:47:13.600 --> 01:47:15.600]  работал просто и притерми
[01:47:15.600 --> 01:47:17.600]  для каждого элемента
[01:47:17.600 --> 01:47:19.600]  нет, который бы просто для каждого элемента
[01:47:19.600 --> 01:47:21.600]  хорошо, если бы нам надо было
[01:47:21.600 --> 01:47:23.600]  просто проверить есть ли идти
[01:47:23.600 --> 01:47:25.600]  ну мы бы просто сказали
[01:47:25.600 --> 01:47:27.600]  isSameV по всем t
[01:47:27.600 --> 01:47:29.600]  сделали бы fold expression и его сделали
[01:47:29.600 --> 01:47:31.600]  сейчас, я не умею это сделать
[01:47:31.600 --> 01:47:33.600]  так, мы хотим
[01:47:33.600 --> 01:47:35.600]  длинное выражение
[01:47:35.600 --> 01:47:37.600]  плюс isSameV умножить на 10
[01:47:37.600 --> 01:47:39.600]  плюс isSameV умножить на 10
[01:47:39.600 --> 01:47:41.600]  типа так, количество нулей в числе
[01:47:41.600 --> 01:47:43.600]  это есть на наш индекс
[01:47:43.600 --> 01:47:45.600]  но
[01:47:45.600 --> 01:47:47.600]  здесь небольшая проблема
[01:47:47.600 --> 01:47:49.600]  я не буду
[01:47:49.600 --> 01:47:51.600]  говорить, что это немножечко
[01:47:51.600 --> 01:47:53.600]  странная идея, потому что все идеи
[01:47:53.600 --> 01:47:55.600]  будут странные
[01:47:55.600 --> 01:47:57.600]  есть просто проблема, что мы не можем достаточно
[01:47:57.600 --> 01:47:59.600]  большие typelist это можно поддерживать
[01:47:59.600 --> 01:48:01.600]  да, проблема в том, что
[01:48:01.600 --> 01:48:03.600]  довольно быстро
[01:48:03.600 --> 01:48:05.600]  довольно быстро typelist
[01:48:05.600 --> 01:48:07.600]  во-первых, почему на 10?
[01:48:07.600 --> 01:48:09.600]  на 2?
[01:48:09.600 --> 01:48:11.600]  да, частичная система
[01:48:11.600 --> 01:48:13.600]  счастления
[01:48:13.600 --> 01:48:15.600]  потому что так мы всегда
[01:48:15.600 --> 01:48:17.600]  так ты поймешь, на каком месте он стоял
[01:48:17.600 --> 01:48:19.600]  можно так?
[01:48:19.600 --> 01:48:21.600]  так нам нужно понять, на каком месте он стоял
[01:48:21.600 --> 01:48:23.600]  смотрите, что
[01:48:25.600 --> 01:48:27.600]  я что предлагаю
[01:48:27.600 --> 01:48:29.600]  смотрите, какая идея, давайте попробуем
[01:48:29.600 --> 01:48:31.600]  завести
[01:48:33.600 --> 01:48:35.600]  что мы можем в концентрации сделать?
[01:48:35.600 --> 01:48:37.600]  вот такой вопрос
[01:48:37.600 --> 01:48:39.600]  смотрите, мы можем, разворачивая
[01:48:39.600 --> 01:48:41.600]  вот этот folder expression, вот что делать
[01:48:41.600 --> 01:48:43.600]  у нас будет какой-то булливый флаг
[01:48:43.600 --> 01:48:45.600]  и мы
[01:48:45.600 --> 01:48:47.600]  ну просто если мы встретим
[01:48:47.600 --> 01:48:49.600]  true, то мы этот флаг переключим
[01:48:49.600 --> 01:48:51.600]  каждый раз мы будем на этот флаг домножать
[01:48:51.600 --> 01:48:53.600]  то есть мы будем прибавлять
[01:48:53.600 --> 01:48:55.600]  и умноженное на флаг, и в какой-то момент
[01:48:55.600 --> 01:48:57.600]  флаг станет нулем
[01:48:57.600 --> 01:48:59.600]  и умноженное на
[01:48:59.600 --> 01:49:01.600]  флаг это плохо
[01:49:01.600 --> 01:49:03.600]  нет
[01:49:03.600 --> 01:49:05.600]  ну в смысле
[01:49:05.600 --> 01:49:07.600]  мы же можем вот с запятой несколько штук написать
[01:49:07.600 --> 01:49:09.600]  типа одна штука будет
[01:49:09.600 --> 01:49:11.600]  да, ладно, давайте я
[01:49:11.600 --> 01:49:13.600]  вам напишу просто, что
[01:49:13.600 --> 01:49:15.600]  предлагается сделать
[01:49:15.600 --> 01:49:17.600]  мы можем, давайте я вам скажу
[01:49:17.600 --> 01:49:19.600]  одно слово, массивы, мы можем
[01:49:19.600 --> 01:49:21.600]  заводить массивы
[01:49:23.600 --> 01:49:25.600]  о господи
[01:49:25.600 --> 01:49:27.600]  давайте заведем массив
[01:49:31.600 --> 01:49:33.600]  который
[01:49:37.600 --> 01:49:39.600]  который будет устроен так
[01:49:51.600 --> 01:49:53.600]  вот
[01:49:53.600 --> 01:49:55.600]  значит это будет массив размера
[01:49:55.600 --> 01:49:57.600]  сайза от многоточия types
[01:49:57.600 --> 01:49:59.600]  ну а теперь
[01:49:59.600 --> 01:50:01.600]  надо просто пройти
[01:50:01.600 --> 01:50:03.600]  по массиву и найти в нем
[01:50:03.600 --> 01:50:05.600]  первая true
[01:50:07.600 --> 01:50:09.600]  прекрасно
[01:50:09.600 --> 01:50:11.600]  а это же мы можем уже
[01:50:11.600 --> 01:50:13.600]  просто
[01:50:13.600 --> 01:50:15.600]  не первая true
[01:50:15.600 --> 01:50:17.600]  можно просто
[01:50:17.600 --> 01:50:19.600]  фориком написать
[01:50:19.600 --> 01:50:21.600]  ну можно просто фориком написать
[01:50:21.600 --> 01:50:23.600]  ну на самом деле, начиная с
[01:50:23.600 --> 01:50:25.600]  SuperTools 20, у нас есть STD
[01:50:25.600 --> 01:50:27.600]  да
[01:50:31.600 --> 01:50:33.600]  то есть получается таким образом
[01:50:33.600 --> 01:50:35.600]  мы можем в массив запихать любую функцию
[01:50:35.600 --> 01:50:37.600]  от этих типов и уже работать
[01:50:37.600 --> 01:50:39.600]  с результатом этой функции
[01:50:41.600 --> 01:50:43.600]  нет, это шикарно вообще
[01:50:47.600 --> 01:50:49.600]  минус B очередь
[01:50:51.600 --> 01:50:53.600]  так
[01:50:53.600 --> 01:50:55.600]  мне нужно сказать
[01:50:55.600 --> 01:50:57.600]  return
[01:50:57.600 --> 01:50:59.600]  вот это
[01:50:59.600 --> 01:51:01.600]  да, все будет работать
[01:51:05.600 --> 01:51:07.600]  вот, что вернет STD
[01:51:07.600 --> 01:51:09.600]  если там не было true
[01:51:09.600 --> 01:51:11.600]  ну он вернет кажется
[01:51:11.600 --> 01:51:13.600]  конец
[01:51:13.600 --> 01:51:15.600]  мы разный сетератор
[01:51:15.600 --> 01:51:17.600]  таким образом получим
[01:51:19.600 --> 01:51:21.600]  у нас есть проблема в том, что это вроде как
[01:51:21.600 --> 01:51:23.600]  тип будет не с ICT конечно
[01:51:23.600 --> 01:51:25.600]  ну да это остановить надо
[01:51:25.600 --> 01:51:27.600]  проверим
[01:51:27.600 --> 01:51:29.600]  нет, все работает
[01:51:29.600 --> 01:51:31.600]  давайте я на следующий случай
[01:51:31.600 --> 01:51:33.600]  проверю, что если я здесь что-нибудь
[01:51:33.600 --> 01:51:35.600]  поменяю, то не будет работать
[01:51:35.600 --> 01:51:37.600]  а то вдруг я что-нибудь неправильно
[01:51:37.600 --> 01:51:39.600]  не, вот статик
[01:51:39.600 --> 01:51:41.600]  так что именно так как мы хотим
[01:51:41.600 --> 01:51:43.600]  это и работает
[01:51:45.600 --> 01:51:47.600]  отлично
[01:51:47.600 --> 01:51:49.600]  следующее
[01:51:49.600 --> 01:51:51.600]  что я хочу научиться делать
[01:51:51.600 --> 01:51:53.600]  давайте научимся
[01:51:53.600 --> 01:51:55.600]  делать алгоритмы
[01:51:55.600 --> 01:51:57.600]  с предикатами
[01:51:57.600 --> 01:51:59.600]  find if
[01:51:59.600 --> 01:52:01.600]  смотрите
[01:52:01.600 --> 01:52:03.600]  я могу искать не тип
[01:52:03.600 --> 01:52:05.600]  а какое-то свойство
[01:52:05.600 --> 01:52:07.600]  например
[01:52:07.600 --> 01:52:09.600]  у меня будет
[01:52:09.600 --> 01:52:11.600]  такая штука
[01:52:11.600 --> 01:52:13.600]  ну нужно передать
[01:52:13.600 --> 01:52:15.600]  лямбу как параметр
[01:52:15.600 --> 01:52:17.600]  не-не-не
[01:52:17.600 --> 01:52:19.600]  это шаблон надо передать
[01:52:19.600 --> 01:52:21.600]  вот, смотрите
[01:52:21.600 --> 01:52:23.600]  я говорю
[01:52:23.600 --> 01:52:25.600]  хочу уметь искать
[01:52:25.600 --> 01:52:27.600]  в наборе типов
[01:52:27.600 --> 01:52:29.600]  по свойству типа
[01:52:29.600 --> 01:52:31.600]  у меня есть метафункция из pointer
[01:52:31.600 --> 01:52:33.600]  которая говорит мне что-то про тип
[01:52:33.600 --> 01:52:35.600]  и я хочу
[01:52:35.600 --> 01:52:37.600]  чтобы в списке типов она находила
[01:52:37.600 --> 01:52:39.600]  первый тип, являющийся pointer
[01:52:39.600 --> 01:52:41.600]  видимо мы хотим просто сделать
[01:52:41.600 --> 01:52:43.600]  буквально
[01:52:43.600 --> 01:52:45.600]  добавить туда что
[01:52:45.600 --> 01:52:47.600]  мы хотим туда
[01:52:47.600 --> 01:52:49.600]  template еще раз принять
[01:52:49.600 --> 01:52:51.600]  шаблонный параметр
[01:52:51.600 --> 01:52:53.600]  что нам надо тогда сделать
[01:52:53.600 --> 01:52:55.600]  что принять надо
[01:52:55.600 --> 01:52:57.600]  объект этой функции
[01:52:57.600 --> 01:52:59.600]  нет, неправильно
[01:52:59.600 --> 01:53:01.600]  как мы в этот объект функции передадим тип
[01:53:01.600 --> 01:53:03.600]  нет, мы хотим сделать именно метафункцию
[01:53:03.600 --> 01:53:05.600]  то есть шаблон
[01:53:05.600 --> 01:53:07.600]  мы хотим передать в качестве шаблонного параметра метафункцию
[01:53:07.600 --> 01:53:09.600]  ну и шаблон
[01:53:09.600 --> 01:53:11.600]  что мы должны написать
[01:53:11.600 --> 01:53:13.600]  template
[01:53:13.600 --> 01:53:15.600]  template
[01:53:15.600 --> 01:53:17.600]  type name
[01:53:17.600 --> 01:53:19.600]  type name
[01:53:19.600 --> 01:53:21.600]  что
[01:53:21.600 --> 01:53:23.600]  стоп
[01:53:27.600 --> 01:53:29.600]  что
[01:53:29.600 --> 01:53:31.600]  что вас удивляет, в первом семестре мы проходили вообще
[01:53:31.600 --> 01:53:33.600]  в первом семестре
[01:53:33.600 --> 01:53:35.600]  по-моему мы говорили
[01:53:35.600 --> 01:53:37.600]  тогда не было нифига понятно
[01:53:37.600 --> 01:53:39.600]  что сейчас нифига не понятно
[01:53:39.600 --> 01:53:41.600]  по-моему только с 17 плюсов
[01:53:41.600 --> 01:53:43.600]  шаблонные аргументы
[01:53:43.600 --> 01:53:45.600]  являющиеся шаблонами были еще до 7 плюс плюс 11
[01:53:45.600 --> 01:53:47.600]  именно с type name
[01:53:47.600 --> 01:53:49.600]  там же до 17
[01:53:49.600 --> 01:53:51.600]  мы обязаны были писать вот здесь класс
[01:53:51.600 --> 01:53:53.600]  а в чем это?
[01:53:53.600 --> 01:53:55.600]  ну вот такой вот костынь
[01:53:55.600 --> 01:53:57.600]  а вообще
[01:53:57.600 --> 01:53:59.600]  существует ли сейчас
[01:53:59.600 --> 01:54:01.600]  где-то разница
[01:54:01.600 --> 01:54:03.600]  между тем чтобы написать type name и класс
[01:54:03.600 --> 01:54:05.600]  шаблонных type name и класс эквивалентны полностью
[01:54:07.600 --> 01:54:09.600]  так
[01:54:09.600 --> 01:54:11.600]  мы передаем в качестве шаблонного параметра
[01:54:11.600 --> 01:54:13.600]  шаблон
[01:54:13.600 --> 01:54:15.600]  почему шаблон?
[01:54:15.600 --> 01:54:17.600]  потому что
[01:54:17.600 --> 01:54:19.600]  изпойнтер это шаблон
[01:54:19.600 --> 01:54:21.600]  быть пойнтером
[01:54:21.600 --> 01:54:23.600]  это шаблонный
[01:54:23.600 --> 01:54:25.600]  класс
[01:54:25.600 --> 01:54:27.600]  стд изпойнтер это шаблонная структура
[01:54:27.600 --> 01:54:29.600]  у которой
[01:54:29.600 --> 01:54:31.600]  шаблонным аргумент является
[01:54:31.600 --> 01:54:33.600]  вот
[01:54:33.600 --> 01:54:35.600]  значит
[01:54:35.600 --> 01:54:37.600]  я могу передать в качестве шаблонного
[01:54:37.600 --> 01:54:39.600]  аргумента шаблон
[01:54:39.600 --> 01:54:41.600]  и
[01:54:41.600 --> 01:54:43.600]  что я теперь должен проверить?
[01:54:43.600 --> 01:54:45.600]  я должен вот здесь
[01:54:45.600 --> 01:54:47.600]  но я должен то же самое сделать
[01:54:47.600 --> 01:54:49.600]  просто вместо и same way написать что?
[01:54:49.600 --> 01:54:51.600]  f
[01:54:51.600 --> 01:54:53.600]  f от
[01:54:53.600 --> 01:54:55.600]  f с шаблонным параметром
[01:54:55.600 --> 01:54:57.600]  types
[01:54:57.600 --> 01:54:59.600]  вточие
[01:54:59.600 --> 01:55:01.600]  вл
[01:55:01.600 --> 01:55:03.600]  и многоточие
[01:55:03.600 --> 01:55:05.600]  правда?
[01:55:05.600 --> 01:55:07.600]  таким образом
[01:55:07.600 --> 01:55:09.600]  я получу true
[01:55:09.600 --> 01:55:11.600]  когда тип из пакета соответственно
[01:55:11.600 --> 01:55:13.600]  был пойнтером
[01:55:23.600 --> 01:55:25.600]  а вот в каком случае
[01:55:25.600 --> 01:55:27.600]  вообще нам может быть интересно
[01:55:27.600 --> 01:55:29.600]  какие такие штуки
[01:55:29.600 --> 01:55:31.600]  вы хотите опять спросить
[01:55:31.600 --> 01:55:33.600]  где это применяется?
[01:55:33.600 --> 01:55:35.600]  я не понимаю
[01:55:35.600 --> 01:55:37.600]  я запишу
[01:55:37.600 --> 01:55:39.600]  я запишу
[01:55:39.600 --> 01:55:41.600]  я баню вопрос
[01:55:41.600 --> 01:55:43.600]  где это применяется
[01:55:43.600 --> 01:55:45.600]  до конца
[01:55:45.600 --> 01:55:47.600]  я чувствую
[01:55:47.600 --> 01:55:49.600]  нет, если это густее
[01:55:49.600 --> 01:55:51.600]  можно через час
[01:55:51.600 --> 01:55:53.600]  я тебе еще и победу
[01:55:55.600 --> 01:55:57.600]  окей, давайте теперь напишем
[01:55:57.600 --> 01:55:59.600]  обращение по индексу
[01:56:01.600 --> 01:56:03.600]  какой смысл несется в фразе
[01:56:03.600 --> 01:56:05.600]  я хочу
[01:56:05.600 --> 01:56:07.600]  получать
[01:56:07.600 --> 01:56:09.600]  каким образом мы хотим его получать?
[01:56:11.600 --> 01:56:13.600]  да, это отличный вопрос
[01:56:13.600 --> 01:56:15.600]  что значит получить тип?
[01:56:15.600 --> 01:56:17.600]  да
[01:56:17.600 --> 01:56:19.600]  у меня будет функция
[01:56:21.600 --> 01:56:23.600]  давайте я назову ее
[01:56:23.600 --> 01:56:25.600]  get
[01:56:25.600 --> 01:56:27.600]  которая будет по индексу
[01:56:27.600 --> 01:56:29.600]  например 1 от type list
[01:56:29.600 --> 01:56:31.600]  type list
[01:56:31.600 --> 01:56:33.600]  int double
[01:56:33.600 --> 01:56:35.600]  char
[01:56:35.600 --> 01:56:37.600]  мне возвращать
[01:56:37.600 --> 01:56:39.600]  что?
[01:56:39.600 --> 01:56:41.600]  вот что такое
[01:56:41.600 --> 01:56:43.600]  может быть это
[01:56:43.600 --> 01:56:45.600]  должен быть using
[01:56:45.600 --> 01:56:47.600]  а может быть этот get
[01:56:47.600 --> 01:56:49.600]  должен быть using
[01:56:49.600 --> 01:56:51.600]  что должен возвращать get?
[01:56:51.600 --> 01:56:53.600]  если мы продолжаем
[01:56:53.600 --> 01:56:55.600]  такой же темантикой
[01:56:55.600 --> 01:56:57.600]  как я пользоваться
[01:56:57.600 --> 01:56:59.600]  что?
[01:56:59.600 --> 01:57:01.600]  у нас на самом деле уже есть
[01:57:01.600 --> 01:57:03.600]  как называется?
[01:57:03.600 --> 01:57:05.600]  type identity
[01:57:05.600 --> 01:57:07.600]  type identity
[01:57:07.600 --> 01:57:09.600]  уже есть класс
[01:57:09.600 --> 01:57:11.600]  который представляет собой
[01:57:11.600 --> 01:57:13.600]  одиночный тип
[01:57:13.600 --> 01:57:15.600]  это type identity
[01:57:15.600 --> 01:57:17.600]  от double
[01:57:19.600 --> 01:57:21.600]  нет
[01:57:21.600 --> 01:57:23.600]  я просто сейчас
[01:57:23.600 --> 01:57:25.600]  напишу оператор равно
[01:57:25.600 --> 01:57:27.600]  для type identity
[01:57:27.600 --> 01:57:29.600]  я, кстати, не уверен
[01:57:29.600 --> 01:57:31.600]  может быть их и можно сравнивать
[01:57:31.600 --> 01:57:33.600]  давайте проверим
[01:57:33.600 --> 01:57:35.600]  но сначала
[01:57:35.600 --> 01:57:37.600]  на get написать
[01:57:39.600 --> 01:57:41.600]  я думаю, что
[01:57:41.600 --> 01:57:43.600]  оператор равно
[01:57:43.600 --> 01:57:45.600]  для них не определен
[01:57:45.600 --> 01:57:47.600]  а
[01:57:47.600 --> 01:57:49.600]  ну get не определен
[01:57:49.600 --> 01:57:51.600]  давайте сначала get
[01:57:51.600 --> 01:57:53.600]  с оператором равно
[01:57:53.600 --> 01:57:55.600]  все понятно
[01:57:55.600 --> 01:57:57.600]  я хочу
[01:57:57.600 --> 01:57:59.600]  написать get
[01:57:59.600 --> 01:58:01.600]  за линию
[01:58:01.600 --> 01:58:03.600]  без шансов
[01:58:03.600 --> 01:58:05.600]  без шансов
[01:58:05.600 --> 01:58:07.600]  без шансов
[01:58:07.600 --> 01:58:09.600]  без шаблонной кути
[01:58:15.600 --> 01:58:17.600]  get
[01:58:17.600 --> 01:58:19.600]  задний
[01:58:19.600 --> 01:58:21.600]  да
[01:58:25.600 --> 01:58:27.600]  все так
[01:58:27.600 --> 01:58:29.600]  можем
[01:58:29.600 --> 01:58:31.600]  создать объект
[01:58:31.600 --> 01:58:33.600]  type identity, кажется можем?
[01:58:33.600 --> 01:58:35.600]  да
[01:58:35.600 --> 01:58:41.600]  Возьмем type-list из объектов type-addentive и возьмем у него id.idx
[01:58:41.600 --> 01:58:44.600]  type-list делать не из объектов, а из типов
[01:58:44.600 --> 01:58:47.600]  Кстати, а блин, нет
[01:58:47.600 --> 01:58:53.600]  У меня здесь будет первым шаблонным аргументом size-t
[01:58:53.600 --> 01:59:01.600]  и возвращаться будет std type-auto
[01:59:02.600 --> 01:59:08.600]  Будет get и type-list от типов
[01:59:08.600 --> 01:59:11.600]  Здесь нам вернут нечто
[01:59:11.600 --> 01:59:14.600]  А почему тюркс массивно сработает?
[01:59:14.600 --> 01:59:17.600]  Потому что мы его сейчас реализовываем
[01:59:17.600 --> 01:59:19.600]  Как? Ну что написать надо?
[01:59:19.600 --> 01:59:20.600]  Ну то же самое, что...
[01:59:20.600 --> 01:59:23.600]  Что значит то же самое? Bool, B, квадратная сеть
[01:59:23.600 --> 01:59:25.600]  Ну что дальше?
[01:59:25.600 --> 01:59:26.600]  А, сейчас
[01:59:26.600 --> 01:59:29.600]  Ну один
[01:59:30.600 --> 01:59:33.600]  Сейчас
[01:59:33.600 --> 01:59:37.600]  Ну понятно, что мы можем сделать get путем шаблонной рекурсии
[01:59:37.600 --> 01:59:42.600]  Нам нужен какой-то type-list, который будет содержать в себе
[01:59:42.600 --> 01:59:45.600]  Так, ладно
[01:59:45.600 --> 01:59:48.600]  А мы можем?
[01:59:48.600 --> 01:59:53.600]  Сейчас у нас же был какой-то std condition
[01:59:53.600 --> 01:59:55.600]  Мы знаем, что у нас два степеней
[01:59:55.600 --> 01:59:58.600]  плюс два степеней минус один, плюс два степеней минус два и так далее
[01:59:58.600 --> 02:00:00.600]  это два степеней плюс один
[02:00:00.600 --> 02:00:02.600]  Сейчас Илья не знает, как сделать
[02:00:02.600 --> 02:00:05.600]  У нас же был этот std conditional
[02:00:05.600 --> 02:00:07.600]  если начали true
[02:00:07.600 --> 02:00:14.600]  и сделать full expression std conditional от index минус минус
[02:00:14.600 --> 02:00:17.600]  и там times by times
[02:00:17.600 --> 02:00:20.600]  Сейчас, аж стол
[02:00:20.600 --> 02:00:22.600]  А какой буль ты в него передашь?
[02:00:22.600 --> 02:00:25.600]  И индекс минус минус, когда он отойдет до нуля
[02:00:25.600 --> 02:00:28.600]  В смысле, больше ли он нуля?
[02:00:28.600 --> 02:00:30.600]  Ну, я не верю, что
[02:00:30.600 --> 02:00:33.600]  Во-первых, это какой-то вложенный
[02:00:33.600 --> 02:00:38.600]  Смотри full expression, ты можешь только для операторов сделать
[02:00:38.600 --> 02:00:42.600]  Да
[02:00:42.600 --> 02:00:44.600]  Вань, там проблема
[02:00:44.600 --> 02:00:47.600]  Ты можешь только для операторов делать full expression
[02:00:47.600 --> 02:00:49.600]  и непонятно, какой оператор ты делаешь
[02:00:49.600 --> 02:00:51.600]  Там проблема еще хуже
[02:00:51.600 --> 02:00:54.600]  Непонятно, куда идти, если он false
[02:00:54.600 --> 02:00:59.600]  Сейчас, а мы не можем сделать какую-нибудь дурацкую вещь
[02:00:59.600 --> 02:01:03.600]  типа через оператор запятую
[02:01:03.600 --> 02:01:07.600]  сделать full expression на оператор запятую
[02:01:07.600 --> 02:01:12.600]  а внутри сделать типа ternarник
[02:01:12.600 --> 02:01:16.600]  на is потом
[02:01:16.600 --> 02:01:18.600]  А, у нас индекса опять нет
[02:01:18.600 --> 02:01:22.600]  Лука, ты точно не предлагаешь, что это станет таланец?
[02:01:22.600 --> 02:01:25.600]  Может быть, после мною что-нибудь?
[02:01:25.600 --> 02:01:28.600]  Ну да
[02:01:28.600 --> 02:01:31.600]  Нет, сейчас
[02:01:31.600 --> 02:01:36.600]  Я не знаю даже, как
[02:01:36.600 --> 02:01:38.600]  Как это написать?
[02:01:38.600 --> 02:01:41.600]  Как подвести к этой мысли
[02:01:41.600 --> 02:01:42.600]  Скажи первое
[02:01:42.600 --> 02:01:45.600]  Я не знаю, как это можно придумать
[02:01:45.600 --> 02:01:48.600]  Плохой начало
[02:01:48.600 --> 02:01:51.600]  Такая себе новость, на самом деле
[02:01:51.600 --> 02:01:56.600]  Давайте я попробую воспроизвести то, что я знаю
[02:01:56.600 --> 02:02:00.600]  Но как это можно было придумать, я не знаю
[02:02:00.600 --> 02:02:04.600]  Значит, мне, наверное, потребуется
[02:02:09.600 --> 02:02:12.600]  Сейчас
[02:02:12.600 --> 02:02:15.600]  Расскажу
[02:02:15.600 --> 02:02:18.600]  Мне, наверное, потребуется
[02:02:18.600 --> 02:02:21.600]  template.typeName
[02:02:21.600 --> 02:02:24.600]  template.sizeToIndex
[02:02:30.600 --> 02:02:32.600]  Вот
[02:02:32.600 --> 02:02:36.600]  И это будет такая штука
[02:02:37.600 --> 02:02:40.600]  constexpr, естественно
[02:02:56.600 --> 02:02:59.600]  В которой будет
[02:02:59.600 --> 02:03:02.600]  О, сейчас
[02:03:02.600 --> 02:03:05.600]  И я могу последнюю идею?
[02:03:05.600 --> 02:03:08.600]  Мы можем создать какой-нибудь тип
[02:03:08.600 --> 02:03:12.600]  У которого будет шаблонный sizeT и другой тип
[02:03:12.600 --> 02:03:15.600]  Сейчас, мне надо посмотреть
[02:03:15.600 --> 02:03:18.600]  И создать метафункцию
[02:03:18.600 --> 02:03:21.600]  Сейчас еще раз шаблонный тип
[02:03:21.600 --> 02:03:26.600]  В чем идее хочется получить массив типов?
[02:03:26.600 --> 02:03:30.600]  Короче, хочется сделать индексированный
[02:03:30.600 --> 02:03:33.600]  Хочется наши типы прииндексировать
[02:03:33.600 --> 02:03:36.600]  Можно сделать параллельную распаковку
[02:03:36.600 --> 02:03:39.600]  двух пакетов индексов и типов
[02:03:39.600 --> 02:03:42.600]  И дальше как бы пройтись по этой штуке
[02:03:42.600 --> 02:03:45.600]  И вернуть тот тип, который соответствует
[02:03:45.600 --> 02:03:48.600]  индексу, номер которого, равен тому, который мы ищем
[02:03:48.600 --> 02:03:51.600]  Да, это рабочая идея
[02:03:51.600 --> 02:03:54.600]  Да, это рабочая идея
[02:03:54.600 --> 02:03:57.600]  Да, это рабочая идея
[02:03:57.600 --> 02:04:00.600]  Да
[02:04:00.600 --> 02:04:03.600]  Да, это рабочая идея
[02:04:03.600 --> 02:04:06.600]  И так получится, но я хочу показать
[02:04:06.600 --> 02:04:09.600]  Совершенно бодибонную идею
[02:04:09.600 --> 02:04:12.600]  Сможешь потом показать эту идею?
[02:04:12.600 --> 02:04:15.600]  Потому что я не понял
[02:04:15.600 --> 02:04:18.600]  Сейчас
[02:04:18.600 --> 02:04:21.600]  Я сейчас
[02:04:21.600 --> 02:04:24.600]  Открою тот файл, который я хочу показывать
[02:04:30.600 --> 02:04:33.600]  Сколько домов с проявленными работами?
[02:04:33.600 --> 02:04:36.600]  Сколько домов с проявленными работами?
[02:04:53.600 --> 02:04:57.600]  В общем так, давайте я могу написать
[02:04:57.600 --> 02:05:00.600]  Идею, которая
[02:05:01.600 --> 02:05:04.600]  Которую
[02:05:07.600 --> 02:05:10.600]  Не знаю, в чем это прокомментировать
[02:05:10.600 --> 02:05:13.600]  У меня будет переменное число шаблонных аргументов
[02:05:20.600 --> 02:05:23.600]  Но принимательно будет
[02:05:23.600 --> 02:05:26.600]  sqd.index.sequence
[02:05:26.600 --> 02:05:29.600]  Я вам не просто так показывал
[02:05:29.600 --> 02:05:32.600]  Я вам не просто так показывал
[02:05:32.600 --> 02:05:35.600]  sqd.index.sequence
[02:05:38.600 --> 02:05:41.600]  Вот
[02:05:41.600 --> 02:05:44.600]  Ой, ой, ой, ой
[02:05:44.600 --> 02:05:47.600]  Что?
[02:05:47.600 --> 02:05:50.600]  Тимплей
[02:05:50.600 --> 02:05:53.600]  Тимплей type name
[02:05:53.600 --> 02:05:56.600]  Мне нужна специализация
[02:05:56.600 --> 02:05:59.600]  Которая не определена
[02:05:59.600 --> 02:06:02.600]  Которую я не буду использовать
[02:06:05.600 --> 02:06:08.600]  В смысле я хочу в github передавать
[02:06:08.600 --> 02:06:11.600]  index.sequence
[02:06:11.600 --> 02:06:14.600]  А зачем нам?
[02:06:14.600 --> 02:06:17.600]  Вот эта пустая
[02:06:17.600 --> 02:06:20.600]  Непонятно, зачем первая?
[02:06:20.600 --> 02:06:23.600]  Потому что это специализация класса
[02:06:23.600 --> 02:06:26.600]  Я не могу специализировать шаблон, пока не объявил общую версию
[02:06:26.600 --> 02:06:29.600]  Я не могу специализировать шаблон, пока не объявил общую версию
[02:06:29.600 --> 02:06:32.600]  Вот, и тут будет у меня такая функция
[02:06:32.600 --> 02:06:35.600]  Которая будет называться darmi
[02:06:35.600 --> 02:06:38.600]  Она будет шаблонной
[02:06:38.600 --> 02:06:41.600]  Она будет шаблонной
[02:06:41.600 --> 02:06:44.600]  Шаблонным параметром t
[02:06:44.600 --> 02:06:47.600]  И возвращать она будет
[02:06:47.600 --> 02:06:50.600]  Три
[02:06:50.600 --> 02:06:53.600]  Ну, не совсем
[02:06:53.600 --> 02:06:56.600]  Ну, короче, я сейчас
[02:06:56.600 --> 02:06:59.600]  Я в свое время, конечно, об этом подумал
[02:06:59.600 --> 02:07:02.600]  Но у меня сейчас вопрос возник
[02:07:02.600 --> 02:07:05.600]  А почему мы все это как функции пишем
[02:07:05.600 --> 02:07:08.600]  А не как методы класса
[02:07:08.600 --> 02:07:11.600]  Я говорил в самом начале
[02:07:11.600 --> 02:07:14.600]  Потому что я хочу, чтобы это было в LBase
[02:07:14.600 --> 02:07:17.600]  А в смысле методы класса?
[02:07:17.600 --> 02:07:20.600]  Ты хочешь, чтобы это были, типа, что?
[02:07:20.600 --> 02:07:23.600]  Методы, чтобы мы писали
[02:07:23.600 --> 02:07:26.600]  TypeList от types.
[02:07:26.600 --> 02:07:29.600]  .finds, .get
[02:07:29.600 --> 02:07:32.600]  Нет, не очень понятно
[02:07:32.600 --> 02:07:35.600]  Может, это просто идеально
[02:07:35.600 --> 02:07:38.600]  Ну, тебе бы приходилось писать
[02:07:38.600 --> 02:07:41.600]  Ну, не точку, а 2.2.2
[02:07:41.600 --> 02:07:44.600]  Чтобы легко создавать
[02:07:44.600 --> 02:07:47.600]  Вот
[02:07:47.600 --> 02:07:50.600]  Ну, кажется, небольшая разница между статическими
[02:07:50.600 --> 02:07:53.600]  .finds
[02:07:53.600 --> 02:07:56.600]  Ну, наверное, можно было бы это методами
[02:07:56.600 --> 02:07:59.600]  Ну, кажется, небольшая разница между статическими методами класса и просто функциями
[02:07:59.600 --> 02:08:02.600]  Ну, просто чтобы это не валялось глобально в namespace
[02:08:02.600 --> 02:08:05.600]  Создай свой namespace
[02:08:05.600 --> 02:08:08.600]  И каждый раз к нему обращаться, когда это получается работать
[02:08:09.600 --> 02:08:12.600]  Не нравится, как вы быстро решаете все проблемы
[02:08:12.600 --> 02:08:15.600]  Так, короче, сейчас я делаю смертельный номер
[02:08:15.600 --> 02:08:18.600]  Это будет, пожалуй, последний смертельный номер
[02:08:21.600 --> 02:08:24.600]  Смотрите, что я сейчас напишу
[02:08:24.600 --> 02:08:27.600]  Успешный смертельный номер, да?
[02:08:27.600 --> 02:08:30.600]  Я надеюсь
[02:08:30.600 --> 02:08:33.600]  Успешный в плане смертельности?
[02:08:33.600 --> 02:08:36.600]  Может, Федю позвать, типа, чтобы он как каскадер
[02:08:37.600 --> 02:08:40.600]  Как тестировщик скорее
[02:08:40.600 --> 02:08:43.600]  Стоп, что происходит?
[02:08:43.600 --> 02:08:46.600]  Так
[02:08:46.600 --> 02:08:49.600]  Чего?
[02:08:49.600 --> 02:08:52.600]  Дальше
[02:08:52.600 --> 02:08:55.600]  Что это такое?
[02:08:55.600 --> 02:08:58.600]  Зато быстро
[02:08:58.600 --> 02:09:01.600]  Зато смертельно
[02:09:01.600 --> 02:09:04.600]  Зато надежно
[02:09:04.600 --> 02:09:07.600]  Я хочу вернуть отсюда typeIdentity
[02:09:07.600 --> 02:09:10.600]  С шаблонным параметром
[02:09:10.600 --> 02:09:13.600]  DecalType
[02:09:13.600 --> 02:09:16.600]  С шаблонным параметром DecalType
[02:09:16.600 --> 02:09:19.600]  А если вас попросить не изучать, объясни, как это работает
[02:09:19.600 --> 02:09:22.600]  На экзамене?
[02:09:22.600 --> 02:09:25.600]  Меня попросить? В смысле, я вам сейчас попробую это объяснить
[02:09:25.600 --> 02:09:28.600]  А на экзамене я уже вас буду сказать
[02:09:28.600 --> 02:09:31.600]  Мы на экзамене тоже тебя попробуем
[02:09:31.600 --> 02:09:34.600]  GetImpal
[02:09:34.600 --> 02:09:37.600]  С шаблонным параметром
[02:09:37.600 --> 02:09:40.600]  std makeIndexSequence
[02:09:40.600 --> 02:09:43.600]  от index
[02:09:43.600 --> 02:09:46.600]  Минус один, наверное
[02:09:46.600 --> 02:09:49.600]  Сейчас
[02:09:49.600 --> 02:09:52.600]  Нет, от index
[02:09:52.600 --> 02:09:55.600]  GetImpal от std makeIndexSequence
[02:09:55.600 --> 02:09:58.600]  от index
[02:09:58.600 --> 02:10:01.600]  От чего?
[02:10:01.600 --> 02:10:04.600]  Чего?
[02:10:04.600 --> 02:10:07.600]  Куда?
[02:10:07.600 --> 02:10:10.600]  От Decal
[02:10:10.600 --> 02:10:13.600]  И сюда мне надо передать
[02:10:22.600 --> 02:10:25.600]  Types многоточие
[02:10:25.600 --> 02:10:28.600]  На lttr
[02:10:28.600 --> 02:10:31.600]  Вот как-то так
[02:10:31.600 --> 02:10:34.600]  Что?
[02:10:34.600 --> 02:10:37.600]  Как-то отопать или запустить?
[02:10:37.600 --> 02:10:40.600]  Подожди, подожди, подожди
[02:10:40.600 --> 02:10:43.600]  Давайте я вам сейчас объясню идею, а потом мы будем отсыпускать
[02:10:43.600 --> 02:10:46.600]  А потом мы это одебажить будем, скорее всего
[02:10:46.600 --> 02:10:49.600]  Ну да, скорее всего я написал что-то неправильно
[02:10:49.600 --> 02:10:52.600]  Например, почему далее двоеточие, если оно не статическое?
[02:10:52.600 --> 02:10:55.600]  А, ну значит нужно статик
[02:10:55.600 --> 02:10:58.600]  Ну сначала хотя бы вообще понять, что происходит
[02:10:58.600 --> 02:11:01.600]  Да, я сейчас попробую объяснить
[02:11:01.600 --> 02:11:04.600]  Смотрите, у меня есть
[02:11:04.600 --> 02:11:07.600]  У меня есть в крайнем случае рабочая версия на стене вкладки
[02:11:07.600 --> 02:11:10.600]  У меня есть, ну я просто хотел вас произвести по памяти
[02:11:10.600 --> 02:11:13.600]  И вот рассказать, как это происходит, если в чем мы введем
[02:11:13.600 --> 02:11:16.600]  У меня есть функция Dummy
[02:11:16.600 --> 02:11:19.600]  которая принимает
[02:11:19.600 --> 02:11:22.600]  Она принимает
[02:11:22.600 --> 02:11:25.600]  Она принимает
[02:11:25.600 --> 02:11:28.600]  некоторое количество параметров
[02:11:28.600 --> 02:11:31.600]  типа void-звездочка
[02:11:31.600 --> 02:11:34.600]  и дальше тип t-звездочка
[02:11:34.600 --> 02:11:37.600]  Смотрите, что такое Dummy?
[02:11:37.600 --> 02:11:40.600]  Это функция, у которой переменны аргументы
[02:11:40.600 --> 02:11:43.600]  обычных аргументов
[02:11:43.600 --> 02:11:46.600]  Причем первые несколько аргументов у нее void-звездочки
[02:11:46.600 --> 02:11:49.600]  А на каком-то месте у нее аргумент t-звездочка
[02:11:49.600 --> 02:11:52.600]  После этого что угодно
[02:11:52.600 --> 02:11:53.600]  Так, сейчас
[02:11:53.600 --> 02:11:54.600]  Чего?
[02:11:54.600 --> 02:11:56.600]  Что здесь происходит? Только здесь многоточие надо
[02:11:56.600 --> 02:11:59.600]  Вот здесь вот надо многоточие, его я забыл точно
[02:11:59.600 --> 02:12:02.600]  Здесь два многоточия
[02:12:02.600 --> 02:12:05.600]  Индисис, это для того как раз чтобы распаковать
[02:12:05.600 --> 02:12:08.600]  У меня индисис
[02:12:08.600 --> 02:12:11.600]  Это пакет чисел
[02:12:11.600 --> 02:12:14.600]  Мне кажется, или мы полчаса назад обсуждали, что после многоточия
[02:12:14.600 --> 02:12:17.600]  Мы не можем написать запятая t
[02:12:17.600 --> 02:12:20.600]  А здесь мы пишем запятая t-звездочка
[02:12:20.600 --> 02:12:23.600]  Это другой пакет
[02:12:23.600 --> 02:12:26.600]  Я не понимаю, да
[02:12:26.600 --> 02:12:29.600]  Здесь индисис конкретный
[02:12:29.600 --> 02:12:32.600]  Потому что он выводит
[02:12:32.600 --> 02:12:35.600]  Чему равен пакет индисис в момент, когда
[02:12:35.600 --> 02:12:38.600]  делает шаблонную постановку в класс
[02:12:38.600 --> 02:12:41.600]  Он заменяет каждый индекс на void-звездочку
[02:12:41.600 --> 02:12:44.600]  И этот индекс превращается в void-звездочку
[02:12:44.600 --> 02:12:47.600]  Смысл этой функции в том, что в ней ровно size of indices
[02:12:47.600 --> 02:12:50.600]  Раз аргумент void-звездочка принимается
[02:12:50.600 --> 02:12:53.600]  И на n-ом месте t-звездочка
[02:12:53.600 --> 02:12:56.600]  Хорошо, и зачем?
[02:12:56.600 --> 02:12:59.600]  А потому что моя функция get
[02:12:59.600 --> 02:13:02.600]  Она возвращает такой тип, какой был бы
[02:13:02.600 --> 02:13:05.600]  Если бы мы вызвали эту функцию
[02:13:05.600 --> 02:13:08.600]  С пакетом makeIndexSequence от индекс
[02:13:08.600 --> 02:13:11.600]  Где в этом пакете ровно столько
[02:13:11.600 --> 02:13:14.600]  Аргументов, в каком месте нас спросили
[02:13:14.600 --> 02:13:17.600]  Какой тип стоит
[02:13:17.600 --> 02:13:20.600]  Эта функция возвращает t, где t
[02:13:20.600 --> 02:13:23.600]  Это тип указателя
[02:13:23.600 --> 02:13:26.600]  Стоящего на n-ом месте
[02:13:26.600 --> 02:13:29.600]  Еще раз, вот я вызвался
[02:13:29.600 --> 02:13:32.600]  Допустим, мне сказали size of indices 3
[02:13:32.600 --> 02:13:35.600]  Я вызвал getImpl
[02:13:35.600 --> 02:13:38.600]  MakeIndexSequence от 3, 0, 1, 2
[02:13:38.600 --> 02:13:41.600]  То есть здесь indices стали
[02:13:41.600 --> 02:13:44.600]  0, 1, 2
[02:13:44.600 --> 02:13:47.600]  И функция dummy превратилась в такую функцию
[02:13:47.600 --> 02:13:50.600]  У нее сигнатура void-звездочка void-звездочка void-звездочка
[02:13:50.600 --> 02:13:53.600]  t-звездочка многоточие
[02:13:53.600 --> 02:13:56.600]  Она три раза принимает void-звездочку
[02:13:56.600 --> 02:13:59.600]  А t там что еще?
[02:13:59.600 --> 02:14:02.600]  И на третьем месте у нее аргумент t-звездочка
[02:14:03.600 --> 02:14:06.600]  Таким образом, когда я вызываюсь
[02:14:06.600 --> 02:14:09.600]  Когда я делаю getImpl от вот такой makeIndexSequence
[02:14:09.600 --> 02:14:12.600]  Здесь индексы забыли
[02:14:12.600 --> 02:14:15.600]  У нас индексы нигде не используют
[02:14:15.600 --> 02:14:18.600]  Я так понимаю, не даем ни в каком виде
[02:14:18.600 --> 02:14:21.600]  Я просто не понимаю
[02:14:21.600 --> 02:14:24.600]  А почему у нас нет функции, которые возвращают n?
[02:14:24.600 --> 02:14:27.600]  Так, вы поняли идею
[02:14:27.600 --> 02:14:30.600]  Кто понял идею?
[02:14:31.600 --> 02:14:34.600]  Я почти понял идею
[02:14:34.600 --> 02:14:37.600]  Идея в том, что я за счет того
[02:14:37.600 --> 02:14:40.600]  Что у меня ровно n индексов
[02:14:40.600 --> 02:14:43.600]  С помощью вот этой консью
[02:14:43.600 --> 02:14:46.600]  Обеспечил себе n раз свой звездочку здесь
[02:14:46.600 --> 02:14:49.600]  И на n месте t звездочку
[02:14:49.600 --> 02:14:52.600]  Таким образом, возвращаемый тип этой штуки
[02:14:52.600 --> 02:14:55.600]  Будет такой, какой стоял на третьем месте
[02:14:55.600 --> 02:14:58.600]  В списке типов
[02:14:58.600 --> 02:15:01.600]  А зачем мне будет звездочку до этого?
[02:15:01.600 --> 02:15:04.600]  Чтобы ты мог скастовать к ней
[02:15:04.600 --> 02:15:07.600]  Я вызываю от type звездочка
[02:15:07.600 --> 02:15:10.600]  Из продублированного n раз
[02:15:10.600 --> 02:15:13.600]  Ну, PTR это нечто
[02:15:13.600 --> 02:15:16.600]  Я мог бы здесь написать decalval
[02:15:16.600 --> 02:15:19.600]  Но только это не работало, потому что decalval я не могу вызывать
[02:15:19.600 --> 02:15:22.600]  Мне нужно вызвать какие-то фейковые параметры
[02:15:22.600 --> 02:15:25.600]  Типа type звездочку
[02:15:25.600 --> 02:15:28.600]  Тип звездочки
[02:15:28.600 --> 02:15:31.600]  Стащится все предыдущие
[02:15:31.600 --> 02:15:34.600]  А вот здесь будет шаблонный аргумент
[02:15:34.600 --> 02:15:37.600]  В точности такой, какой тип стоял
[02:15:37.600 --> 02:15:40.600]  На n катом месте
[02:15:40.600 --> 02:15:43.600]  И он именно и будет возвращаемым типом
[02:15:43.600 --> 02:15:46.600]  И я верну type identity вот с таким типом
[02:15:46.600 --> 02:15:49.600]  Который и был на n месте
[02:15:49.600 --> 02:15:52.600]  Я скину это
[02:15:53.600 --> 02:15:56.600]  Все вообще ничего
[02:15:56.600 --> 02:15:59.600]  Так вы даже посмотрели подсказку
[02:15:59.600 --> 02:16:02.600]  Ваня, я случаю сейчас
[02:16:02.600 --> 02:16:05.600]  У тебя есть вопросы какие-то?
[02:16:05.600 --> 02:16:08.600]  Я даже синтоксически это не понимаю
[02:16:08.600 --> 02:16:11.600]  Просто местами
[02:16:11.600 --> 02:16:14.600]  Я не понимаю откуда у нас в Даме ваше дедакшн
[02:16:14.600 --> 02:16:17.600]  Появился
[02:16:17.600 --> 02:16:20.600]  Откуда мы все его знаем
[02:16:20.600 --> 02:16:23.600]  Здесь написано какие-то комментарии
[02:16:23.600 --> 02:16:26.600]  Вот
[02:16:26.600 --> 02:16:29.600]  Это не считая то, что я не очень понимаю
[02:16:29.600 --> 02:16:32.600]  Какая-то функция должна быть реализована
[02:16:32.600 --> 02:16:35.600]  Type list best
[02:16:35.600 --> 02:16:38.600]  Я не помню уже, чей это type list
[02:16:38.600 --> 02:16:41.600]  Или это пащенный мой type list
[02:16:41.600 --> 02:16:44.600]  Вот хорошая реализация
[02:16:44.600 --> 02:16:47.600]  Мы можем проверить сейчас
[02:16:47.600 --> 02:16:50.600]  Давайте я попробую это скомпилировать
[02:16:56.600 --> 02:16:59.600]  Type list
[02:16:59.600 --> 02:17:02.600]  Как у меня фаза называется?
[02:17:02.600 --> 02:17:05.600]  Тут конечно много чего
[02:17:05.600 --> 02:17:08.600]  Не сработало
[02:17:08.600 --> 02:17:11.600]  А чего не сработало?
[02:17:11.600 --> 02:17:14.600]  Давайте для начала посмотрим
[02:17:14.600 --> 02:17:17.600]  Давайте вообще закомментируем вот это
[02:17:17.600 --> 02:17:20.600]  Посмотрим компилируется ли
[02:17:20.600 --> 02:17:23.600]  Что
[02:17:23.600 --> 02:17:26.600]  Я прекрасно понимаю компилятор
[02:17:26.600 --> 02:17:29.600]  Потому что у меня не подключено
[02:17:29.600 --> 02:17:32.600]  У меня не подключено утилити
[02:17:32.600 --> 02:17:35.600]  Зачем утилити?
[02:17:38.600 --> 02:17:41.600]  Дальше
[02:17:42.600 --> 02:17:45.600]  Type well и mismatch
[02:17:45.600 --> 02:17:48.600]  Кто понимает почему type well и mismatch
[02:17:48.600 --> 02:17:51.600]  Какой type well и mismatch
[02:17:51.600 --> 02:17:54.600]  Некравильный шаблонный аргумент
[02:17:54.600 --> 02:17:56.600]  Потому что здесь должно быть type name t
[02:17:56.600 --> 02:17:59.600]  Я специализирую шаблон не с тем набором шаблонных аргументов
[02:17:59.600 --> 02:18:02.600]  С которым был основной шаблон
[02:18:02.600 --> 02:18:05.600]  Чего?
[02:18:05.600 --> 02:18:08.600]  Я в github передаю один тип
[02:18:08.600 --> 02:18:11.600]  Так нельзя
[02:18:11.600 --> 02:18:14.600]  Шаблон должен быть произвольного типа
[02:18:14.600 --> 02:18:17.600]  А специализация конкретного типа
[02:18:17.600 --> 02:18:20.600]  Нет, я что-то не понял
[02:18:20.600 --> 02:18:23.600]  Нет аргументов для declval
[02:18:23.600 --> 02:18:26.600]  Которые зависят на template параметр
[02:18:26.600 --> 02:18:29.600]  Поэтому declaration declval must be available
[02:18:29.600 --> 02:18:32.600]  Type traits
[02:18:32.600 --> 02:18:35.600]  Наверное еще надо подключить
[02:18:36.600 --> 02:18:39.600]  В крайнем случае я сделаю каст
[02:18:39.600 --> 02:18:42.600]  В крайнем случае можно подключить пиццы
[02:18:45.600 --> 02:18:48.600]  Ладно, давайте я не буду declval здесь использовать
[02:18:48.600 --> 02:18:51.600]  А буду использовать просто каст про звездочки
[02:18:51.600 --> 02:18:54.600]  Не можно просто
[02:18:54.600 --> 02:18:57.600]  Я кладу звездочки, кащу на lptr
[02:18:57.600 --> 02:19:00.600]  Внимание, плохой каст
[02:19:00.600 --> 02:19:03.600]  Стоп, что это же аргумент
[02:19:03.600 --> 02:19:06.600]  Мы так больше раз не можем
[02:19:06.600 --> 02:19:09.600]  Это же объявление функции
[02:19:09.600 --> 02:19:12.600]  Я под decltype все загоняю
[02:19:12.600 --> 02:19:15.600]  Илья, а в чем была проблема declval?
[02:19:15.600 --> 02:19:18.600]  Я не знаю, я не стал разбираться
[02:19:18.600 --> 02:19:21.600]  Expected primary expression
[02:19:26.600 --> 02:19:29.600]  Getimple
[02:19:29.600 --> 02:19:32.600]  Значит у меня закончился getimple
[02:19:32.600 --> 02:19:35.600]  Getimple от std
[02:19:35.600 --> 02:19:38.600]  Makeindex.sequence от index
[02:19:38.600 --> 02:19:41.600]  И это у меня getimple структура такая
[02:19:41.600 --> 02:19:44.600]  2.2.darmie
[02:19:44.600 --> 02:19:47.600]  Вот в таких аргументах
[02:19:47.600 --> 02:19:50.600]  А, потому что непонятно что это type 11
[02:19:50.600 --> 02:19:53.600]  Надо использовать std type 11
[02:19:56.600 --> 02:19:59.600]  Все еще expect primary expression
[02:20:00.600 --> 02:20:03.600]  Так, давайте
[02:20:03.600 --> 02:20:06.600]  Я вот это пытаюсь сейчас проверить
[02:20:13.600 --> 02:20:16.600]  А, меня decltype не закрыли
[02:20:16.600 --> 02:20:19.600]  А, все, понятно, меня decltype не закрыли
[02:20:19.600 --> 02:20:22.600]  Так, что дальше
[02:20:22.600 --> 02:20:25.600]  Find was not declared in bespoke
[02:20:25.600 --> 02:20:28.600]  Почему?
[02:20:28.600 --> 02:20:31.600]  Я же определял файл
[02:20:31.600 --> 02:20:34.600]  А мы его изменили
[02:20:34.600 --> 02:20:37.600]  А я вообще удалил файл, что ли?
[02:20:37.600 --> 02:20:40.600]  Жесть, зачем я так сделал?
[02:20:40.600 --> 02:20:43.600]  Ну ладно
[02:20:43.600 --> 02:20:46.600]  А здесь find was not declared
[02:20:46.600 --> 02:20:49.600]  А зачем удалил файл?
[02:20:49.600 --> 02:20:52.600]  О, все
[02:20:52.600 --> 02:20:55.600]  А можно вы все-таки получите
[02:20:55.600 --> 02:20:58.600]  И давайте проверим, что это работает, конечно
[02:20:58.600 --> 02:21:01.600]  Давайте напишем
[02:21:01.600 --> 02:21:04.600]  оператор равно для typeIdentity
[02:21:04.600 --> 02:21:07.600]  typeNameT, typeNameU
[02:21:07.600 --> 02:21:10.600]  Научусь сравнить typeIdentity
[02:21:10.600 --> 02:21:13.600]  constexpr
[02:21:13.600 --> 02:21:16.600]  bool оператора равно равно
[02:21:16.600 --> 02:21:19.600]  от std typeIdentity
[02:21:19.600 --> 02:21:22.600]  std typeIdentity
[02:21:22.600 --> 02:21:25.600]  std typeIdentity
[02:21:25.600 --> 02:21:28.600]  typeIdentityU
[02:21:28.600 --> 02:21:31.600]  return false
[02:21:31.600 --> 02:21:34.600]  и специализацию
[02:21:34.600 --> 02:21:37.600]  которая возвращает true
[02:21:37.600 --> 02:21:40.600]  У нее будет всего один тип
[02:21:40.600 --> 02:21:43.600]  шаблонный
[02:21:43.600 --> 02:21:46.600]  она принимает typeIdentity
[02:21:46.600 --> 02:21:49.600]  от выхода одинаковых типов
[02:21:49.600 --> 02:21:52.600]  и возвращает true
[02:21:52.600 --> 02:21:55.600]  Давайте проверим, что это компилируется
[02:21:55.600 --> 02:21:58.600]  Теперь я хочу проверить, что...
[02:21:58.600 --> 02:22:01.600]  А, все, это компилируется
[02:22:01.600 --> 02:22:04.600]  Подождите, а как-то раньше компилировалось, что это обычный
[02:22:04.600 --> 02:22:07.600]  Мало закаменичный
[02:22:07.600 --> 02:22:10.600]  Кто закаменичный был?
[02:22:10.600 --> 02:22:13.600]  А, все, так работает получается
[02:22:13.600 --> 02:22:16.600]  Давайте проверю, что это int
[02:22:16.600 --> 02:22:19.600]  Тогда должен упасть
[02:22:19.600 --> 02:22:22.600]  Ну или что это char
[02:22:22.600 --> 02:22:25.600]  Падает
[02:22:25.600 --> 02:22:28.600]  Точно на первом элементе double стоит
[02:22:28.600 --> 02:22:31.600]  Точно будет не работать для кратера равно для typeIdentity
[02:22:31.600 --> 02:22:34.600]  Давайте это я не буду проверять
[02:22:34.600 --> 02:22:37.600]  Может и будет, но я не хочу проверять
[02:22:37.600 --> 02:22:40.600]  Ну что ж, работает, я вас не обманул
[02:22:40.600 --> 02:22:43.600]  Почему это работает за линию, а не за квадрат?
[02:22:43.600 --> 02:22:46.600]  Да потому что makeIndexSequence и indexSequence
[02:22:46.600 --> 02:22:49.600]  Это компайлы рентринские
[02:22:49.600 --> 02:22:52.600]  Они разворачиваются в последовательных чисел
[02:22:52.600 --> 02:22:55.600]  И при этом не генерируются промежуточные
[02:22:55.600 --> 02:22:58.600]  Не делается шаблонной рекурсией
[02:22:58.600 --> 02:23:01.600]  Конечно же makeIndexSequence можно писать самому
[02:23:01.600 --> 02:23:04.600]  Это упражнение на оценку по 5
[02:23:04.600 --> 02:23:07.600]  Но у вас оно получится шаблонной рекурсией
[02:23:07.600 --> 02:23:10.600]  Нет, в смысле makeIndexSequence шаблонной рекурсией написать
[02:23:10.600 --> 02:23:13.600]  Просто надо откусывать по одному
[02:23:13.600 --> 02:23:16.600]  Там будет indexSequence меньше
[02:23:16.600 --> 02:23:19.600]  Но в компайле оно встроено без шаблонной рекурсии
[02:23:19.600 --> 02:23:22.600]  И это работает за линию
[02:23:22.600 --> 02:23:25.600]  Когда у нас есть get, чего мы можем добиться?
[02:23:25.600 --> 02:23:28.600]  Мы можем легко написать reverse
[02:23:28.600 --> 02:23:31.600]  Реверс будет за квадрат
[02:23:31.600 --> 02:23:34.600]  У нас будет reverse без шаблонной рекурсии
[02:23:34.600 --> 02:23:37.600]  Но за квадрат
[02:23:37.600 --> 02:23:40.600]  Реверс как написать?
[02:23:40.600 --> 02:23:43.600]  Просто get по индексу
[02:23:43.600 --> 02:23:46.600]  Вот
[02:23:46.600 --> 02:23:49.600]  Что мы теперь можем сделать?
[02:23:49.600 --> 02:23:52.600]  Ваши задачи TypeList
[02:23:52.600 --> 02:23:55.600]  Будет написать не только это
[02:23:55.600 --> 02:23:58.600]  А еще много разного
[02:23:58.600 --> 02:24:01.600]  Например, разные алгоритмы из ASTL
[02:24:01.600 --> 02:24:04.600]  Перенесенные на TypeList
[02:24:04.600 --> 02:24:07.600]  Какие алгоритмы можно перенести на TypeList?
[02:24:07.600 --> 02:24:10.600]  Count
[02:24:10.600 --> 02:24:13.600]  AllOfAnyOf
[02:24:13.600 --> 02:24:16.600]  ForEach
[02:24:16.600 --> 02:24:19.600]  Отличный алгоритм
[02:24:19.600 --> 02:24:22.600]  У вас есть метафункция
[02:24:22.600 --> 02:24:25.600]  И вы применяете ее к каждому элементу TypeList
[02:24:25.600 --> 02:24:28.600]  Например, forEach is the addPointer от TypeList
[02:24:28.600 --> 02:24:31.600]  Вы получаете TypeList, который на каждый тип навешан Pointer
[02:24:31.600 --> 02:24:34.600]  Снимайте ссылку с каждого элемента TypeList
[02:24:34.600 --> 02:24:37.600]  Я еще подумаю
[02:24:37.600 --> 02:24:40.600]  Какие из этих алгоритмов я вам попрошу
[02:24:40.600 --> 02:24:43.600]  Генереи
[02:24:43.600 --> 02:24:46.600]  Нужно создать TypeList с N раз повторяющимся типом
[02:24:46.600 --> 02:24:49.600]  Но тоже без шаблонной рекурсии
[02:24:49.600 --> 02:24:52.600]  Вот, кстати, почему нет
[02:24:52.600 --> 02:24:55.600]  Есть последовательность секвенсов
[02:24:55.600 --> 02:24:58.600]  Но нет последовательности
[02:24:58.600 --> 02:25:01.600]  Н подряд водозвездочек
[02:25:01.600 --> 02:25:04.600]  Где?
[02:25:04.600 --> 02:25:07.600]  Если бы была функция, как MaxQ,
[02:25:07.600 --> 02:25:10.600]  которая делает N подряд водозвездочек
[02:25:10.600 --> 02:25:13.600]  Это вот она и есть
[02:25:13.600 --> 02:25:16.600]  Generate
[02:25:16.600 --> 02:25:19.600]  В плане, можно ее использовать вместо MakeIndex
[02:25:19.600 --> 02:25:22.600]  И кастить к водозвездочке
[02:25:22.600 --> 02:25:25.600]  Сразу и делать последовательность из N подряд водозвездочек
[02:25:25.600 --> 02:25:28.600]  Она делает не последовательность N подряд водозвездочек,
[02:25:28.600 --> 02:25:31.600]  а TypeList, который содержит N водозвездочек подряд
[02:25:31.600 --> 02:25:34.600]  Что такое последовательность?
[02:25:34.600 --> 02:25:37.600]  Вот она и есть
[02:25:37.600 --> 02:25:40.600]  MakeSequence
[02:25:40.600 --> 02:25:43.600]  Она содержит подряд чисел
[02:25:43.600 --> 02:25:46.600]  Она содержит тип
[02:25:46.600 --> 02:25:49.600]  Тип, в шамоновых параметрах которого последовательность чисел
[02:25:49.600 --> 02:25:52.600]  Да
[02:25:52.600 --> 02:25:55.600]  И мы потом кастуем каждый из этих чисел к водозвездочке
[02:25:55.600 --> 02:25:58.600]  Не кастуем мы к водозвездочке
[02:25:58.600 --> 02:26:01.600]  Мы вызываем вот такую штуку
[02:26:01.600 --> 02:26:04.600]  Индис используется только для того, чтобы пакет остаковывать
[02:26:04.600 --> 02:26:07.600]  А водозвездочка мы за счет комнаты их получаем
[02:26:07.600 --> 02:26:10.600]  Ну короче, Дин, подумай над этим еще
[02:26:10.600 --> 02:26:13.600]  Так, напоследок я вам покажу
[02:26:13.600 --> 02:26:16.600]  Вершину инженерной мысли
[02:26:16.600 --> 02:26:19.600]  А именно, сортировку TypeList
[02:26:19.600 --> 02:26:22.600]  Покажи, пожалуйста, код моего
[02:26:22.600 --> 02:26:25.600]  Какого? Моего? Моего?
[02:26:25.600 --> 02:26:28.600]  Вот
[02:26:28.600 --> 02:26:31.600]  Почему у нас с первым индексом чар?
[02:26:31.600 --> 02:26:34.600]  Это как раз я проверил, что он падает
[02:26:34.600 --> 02:26:37.600]  А, падает, что он не компинируется
[02:26:37.600 --> 02:26:40.600]  Если здесь 2,50, то что?
[02:26:40.600 --> 02:26:43.600]  Итак, вершина инженерной мысли
[02:26:43.600 --> 02:26:46.600]  QuickSort для TypeList
[02:26:47.600 --> 02:26:50.600]  QuickSort для TypeList
[02:26:53.600 --> 02:26:56.600]  Ну я ее не буду писать, я вам покажу ее просто
[02:26:56.600 --> 02:26:59.600]  Если бы я начал ее писать, то было бы удобно
[02:27:03.600 --> 02:27:05.600]  За сколько ZLG?
[02:27:05.600 --> 02:27:09.600]  Значит, QuickSort для TypeList, к сожалению, работает не ZLG, а скорее ZL2
[02:27:09.600 --> 02:27:12.600]  Ну, потому что
[02:27:12.600 --> 02:27:15.600]  Ну, потому что пузырек бы работал за куб
[02:27:15.600 --> 02:27:18.600]  Ну, в смысле, у вас обращение по индексу за линию работает
[02:27:18.600 --> 02:27:21.600]  Как вы сделаете за ZLG что-либо?
[02:27:21.600 --> 02:27:24.600]  Зачем все это работает за квадрат?
[02:27:24.600 --> 02:27:27.600]  Давайте сначала поймем, что вообще такое
[02:27:27.600 --> 02:27:30.600]  Что вообще идея на такое сортировка TypeList
[02:27:30.600 --> 02:27:33.600]  Что такое, например, компаратор для типа
[02:27:33.600 --> 02:27:36.600]  Ну, как мы уже видели
[02:27:36.600 --> 02:27:39.600]  Компаратор это просто
[02:27:39.600 --> 02:27:42.600]  Это просто метафункция
[02:27:42.600 --> 02:27:45.600]  Которая
[02:27:45.600 --> 02:27:48.600]  Ну, вот для примера здесь у меня делается
[02:27:48.600 --> 02:27:51.600]  Сортировка для вот такой структуры
[02:27:51.600 --> 02:27:54.600]  Для краткости
[02:27:54.600 --> 02:27:57.600]  Shorter Than Rising Integral
[02:27:57.600 --> 02:28:00.600]  То есть у меня есть структура и маленькая
[02:28:00.600 --> 02:28:03.600]  Которая принимает шаблоны параметров и большое
[02:28:03.600 --> 02:28:06.600]  Вот, и для двух этих структур определен компаратор
[02:28:06.600 --> 02:28:09.600]  Ну, выше определяя его общая версия
[02:28:09.600 --> 02:28:12.600]  Тут по старинке написано Class
[02:28:12.600 --> 02:28:15.600]  Я могу везде забыть TypeName
[02:28:15.600 --> 02:28:18.600]  Это метафункция, которая для двух типов отвечает
[02:28:18.600 --> 02:28:21.600]  Какой меньше
[02:28:21.600 --> 02:28:24.600]  Ну, например, можно сравнивать типа
[02:28:24.600 --> 02:28:27.600]  Какой сайзов какого меньше
[02:28:27.600 --> 02:28:30.600]  Вот эти структурки сравниваются так
[02:28:30.600 --> 02:28:33.600]  Меньше из них та, у которой число в шаблонном параметре меньше
[02:28:33.600 --> 02:28:36.600]  Понятно?
[02:28:36.600 --> 02:28:39.600]  Ну, и вот мы проверяем, что sort
[02:28:39.600 --> 02:28:42.600]  Вот в такой последовательности
[02:28:42.600 --> 02:28:45.600]  Этот type list вот такой
[02:28:45.600 --> 02:28:48.600]  Ваша задача будет написать stable sort
[02:28:48.600 --> 02:28:51.600]  Ну, то есть множество
[02:28:51.600 --> 02:28:54.600]  Ну, так вот тут написано
[02:28:54.600 --> 02:28:57.600]  В вашем случае параметром sort
[02:28:57.600 --> 02:29:00.600]  Будет являться type list, а не последовательность
[02:29:00.600 --> 02:29:03.600]  Здесь параметром sort является сама последовательность типов
[02:29:03.600 --> 02:29:06.600]  Давайте попробуем понять, что делает sort
[02:29:09.600 --> 02:29:12.600]  Где у нас определен sort?
[02:29:12.600 --> 02:29:15.600]  Sort это просто тип
[02:29:18.600 --> 02:29:21.600]  Который имеет метод result
[02:29:21.600 --> 02:29:24.600]  У quick sort
[02:29:24.600 --> 02:29:27.600]  Вот от этих типов
[02:29:27.600 --> 02:29:30.600]  Осталось понять, что такое quick sort
[02:29:30.600 --> 02:29:33.600]  Что такое quick sort?
[02:29:36.600 --> 02:29:39.600]  Неспециализированный шаблон
[02:29:39.600 --> 02:29:42.600]  Это просто type list
[02:29:42.600 --> 02:29:45.600]  Вот тех аргументов, которые передали
[02:29:45.600 --> 02:29:48.600]  Он называется, видимо, когда мы от пустого
[02:29:48.600 --> 02:29:51.600]  Когда мы не от пустого
[02:29:51.600 --> 02:29:54.600]  То есть когда у нас есть какой-то тип и еще пакет типов
[02:29:54.600 --> 02:29:57.600]  То что такое quick sort?
[02:29:57.600 --> 02:30:00.600]  Это просто partition и trivial join
[02:30:00.600 --> 02:30:03.600]  Что такое join, кстати?
[02:30:03.600 --> 02:30:06.600]  Join это просто
[02:30:06.600 --> 02:30:09.600]  Вот у нас есть оператор плюс для двух type lists
[02:30:09.600 --> 02:30:12.600]  Он берет type list и другой type list
[02:30:12.600 --> 02:30:15.600]  И создает вот такой type list
[02:30:15.600 --> 02:30:18.600]  Ну, конкатинация type lists делается trivial
[02:30:18.600 --> 02:30:21.600]  Что делается не trivial?
[02:30:21.600 --> 02:30:24.600]  Что такое join?
[02:30:24.600 --> 02:30:27.600]  Вот здесь написано, что такое join
[02:30:27.600 --> 02:30:30.600]  Это мы отсортировали левую половинку
[02:30:30.600 --> 02:30:33.600]  Что такое join?
[02:30:33.600 --> 02:30:36.600]  У нас есть partition, который берет тип pivot
[02:30:36.600 --> 02:30:39.600]  Левый набор типов и правый набор типов
[02:30:39.600 --> 02:30:42.600]  И partition вызывается от pivot
[02:30:42.600 --> 02:30:45.600]  И двух type lists
[02:30:45.600 --> 02:30:48.600]  Что такое join?
[02:30:48.600 --> 02:30:51.600]  Это мы сделали конкатинацию левого набора типов и пивота
[02:30:51.600 --> 02:30:54.600]  Значит, самое главное понять
[02:30:54.600 --> 02:30:57.600]  Что вот здесь написано
[02:30:57.600 --> 02:31:00.600]  Здесь написаны какие-то операторы присваивания
[02:31:00.600 --> 02:31:03.600]  У меня здесь написан fold expression
[02:31:03.600 --> 02:31:06.600]  С оператором присваивания
[02:31:06.600 --> 02:31:09.600]  Помните ли вы, как это работает?
[02:31:09.600 --> 02:31:12.600]  Fold expression
[02:31:12.600 --> 02:31:15.600]  У которого есть пакет
[02:31:15.600 --> 02:31:18.600]  А здесь многоточие
[02:31:18.600 --> 02:31:21.600]  А здесь многоточие
[02:31:21.600 --> 02:31:24.600]  И слева еще инициализатор
[02:31:33.600 --> 02:31:36.600]  И вот на этом заканчивается fold expression
[02:31:36.600 --> 02:31:39.600]  То есть он берет type identity
[02:31:39.600 --> 02:31:42.600]  По всем типам, которые мы передали
[02:31:42.600 --> 02:31:45.600]  Quick sort от всех типов
[02:31:45.600 --> 02:31:48.600]  И делает присваивание
[02:31:48.600 --> 02:31:51.600]  По очереди
[02:31:51.600 --> 02:31:54.600]  Partition одного type identity
[02:31:54.600 --> 02:31:57.600]  Другого type identity
[02:31:57.600 --> 02:32:00.600]  Вот partition присваивается сначала один type identity
[02:32:00.600 --> 02:32:03.600]  Потом следующий, потом следующий и так далее
[02:32:03.600 --> 02:32:06.600]  Что делает оператор присваивания
[02:32:06.600 --> 02:32:09.600]  У которого левый аргумент partition
[02:32:09.600 --> 02:32:12.600]  А правый аргумент type identity
[02:32:13.600 --> 02:32:16.600]  А вот что он делает
[02:32:16.600 --> 02:32:19.600]  Тут написано requires
[02:32:19.600 --> 02:32:22.600]  Если
[02:32:22.600 --> 02:32:25.600]  Тот тип, который нам передали
[02:32:25.600 --> 02:32:28.600]  Аргументом меньше, чем наш
[02:32:28.600 --> 02:32:31.600]  То мы попадаем в эту версию, а иначе в эту
[02:32:31.600 --> 02:32:34.600]  Значит, если нам делает присваивание
[02:32:34.600 --> 02:32:37.600]  Вот у нас есть partition, это штука
[02:32:37.600 --> 02:32:40.600]  Которая уже себе какие-то типы выбрала
[02:32:41.600 --> 02:32:44.600]  Значит, мы
[02:32:44.600 --> 02:32:47.600]  Если нам сейчас присваивает какой-то новый тип
[02:32:47.600 --> 02:32:50.600]  У нас при этом есть левая половина
[02:32:50.600 --> 02:32:53.600]  Левый пакет типов и правый пакет типов
[02:32:53.600 --> 02:32:56.600]  Если нашему классу partition присваивают тип
[02:32:56.600 --> 02:32:59.600]  Который меньше, чем наш pivot
[02:32:59.600 --> 02:33:02.600]  То наш тип это partition
[02:33:02.600 --> 02:33:05.600]  У которого все еще тот же pivot
[02:33:05.600 --> 02:33:08.600]  Но в левой половине дописан этот тип
[02:33:08.600 --> 02:33:11.600]  А если наоборот
[02:33:11.600 --> 02:33:14.600]  То у нас partition, у которого в правой половине дописан
[02:33:14.600 --> 02:33:17.600]  Типа в левой половине ничего не дописан
[02:33:17.600 --> 02:33:20.600]  Стоп, а как мы смогли создать
[02:33:20.600 --> 02:33:23.600]  Пакетист от IOS 3.0
[02:33:23.600 --> 02:33:26.600]  Нет, это ты
[02:33:26.600 --> 02:33:29.600]  Это ты распаковываешь пакеты
[02:33:29.600 --> 02:33:32.600]  Распаковывать мы можем пакет всегда
[02:33:32.600 --> 02:33:35.600]  То есть у тебя IOS уже на этот момент
[02:33:35.600 --> 02:33:38.600]  Однозначно
[02:33:38.600 --> 02:33:41.600]  Ты его просто взял и распаковывал
[02:33:41.600 --> 02:33:44.600]  Ну вот, соответственно, я взял
[02:33:44.600 --> 02:33:47.600]  Для всех этих pivot'ов
[02:33:47.600 --> 02:33:50.600]  Для всех типов сделал
[02:33:56.600 --> 02:33:59.600]  По сути мы просто по очередной все элементы добавили
[02:33:59.600 --> 02:34:02.600]  Вот просто partition
[02:34:02.600 --> 02:34:05.600]  Ну partition
[02:34:05.600 --> 02:34:08.600]  Да, то есть я сделал...
[02:34:08.600 --> 02:34:11.600]  Сейчас
[02:34:11.600 --> 02:34:14.600]  Ну то есть мы взяли partition
[02:34:14.600 --> 02:34:17.600]  Состоящий из pivot'а
[02:34:17.600 --> 02:34:20.600]  И эта штука сначала первый тип
[02:34:20.600 --> 02:34:23.600]  Да, по сути здесь делается
[02:34:23.600 --> 02:34:26.600]  То, что называется процедура partition
[02:34:26.600 --> 02:34:29.600]  Я как бы взял pivot
[02:34:29.600 --> 02:34:32.600]  Вот этот тип
[02:34:32.600 --> 02:34:35.600]  Это просто такой type list
[02:34:35.600 --> 02:34:38.600]  Это некоторая штука partition
[02:34:38.600 --> 02:34:41.600]  У которой слева некоторые набор типов
[02:34:41.600 --> 02:34:44.600]  И вот и справа некоторые набор типов
[02:34:44.600 --> 02:34:47.600]  Я взял, вот каждое это присваивание
[02:34:47.600 --> 02:34:50.600]  Это я либо в type list слева от pivot'а доплагываю тип
[02:34:50.600 --> 02:34:53.600]  Либо в type list справа от pivot'а доплагываю тип
[02:34:53.600 --> 02:34:56.600]  И после этого я делаю join
[02:34:56.600 --> 02:34:59.600]  Я делаю sort левой половины
[02:34:59.600 --> 02:35:02.600]  Конкатинирую с pivot и конкатинирую с sort правой половины
[02:35:02.600 --> 02:35:05.600]  Вот это вот один проход
[02:35:05.600 --> 02:35:08.600]  Который раскидывает кто меньше, кто больше
[02:35:08.600 --> 02:35:11.600]  Вот это рекурсивный вызов
[02:35:11.600 --> 02:35:14.600]  Теперь мы делаем рекурсивный sort для левой половины, sort для правой половины и конкатинируем
[02:35:14.600 --> 02:35:17.600]  Почему это работает не за линией?
[02:35:17.600 --> 02:35:20.600]  Ну вот сам процедура partition
[02:35:20.600 --> 02:35:23.600]  Ну короче до вызова рекурсии
[02:35:23.600 --> 02:35:26.600]  Потому что на каждом присваивании
[02:35:26.600 --> 02:35:29.600]  Мне приходится создавать type list
[02:35:29.600 --> 02:35:32.600]  Под все большего и большего числа аргументов
[02:35:32.600 --> 02:35:35.600]  Это вот за квадрат получается
[02:35:35.600 --> 02:35:38.600]  То есть мне приходится делать логарифм рекурсивных вызовов
[02:35:38.600 --> 02:35:41.600]  Но каждый вызов работает за квадрат
[02:35:41.600 --> 02:35:44.600]  А почему логарифм? Мы вообще pivot берем первый элемент
[02:35:44.600 --> 02:35:47.600]  Тут в худшем случае может быть
[02:35:47.600 --> 02:35:50.600]  Ну понятно, что я мог бы сгенерировать рандомное число
[02:35:50.600 --> 02:35:53.600]  Нет этого элемента
[02:35:53.600 --> 02:35:56.600]  А как бы ты сгенерировал рандомное число?
[02:35:56.600 --> 02:35:59.600]  Я бы написал constexpr функцию
[02:35:59.600 --> 02:36:02.600]  Которая делает линиейный конкурентный генератор
[02:36:02.600 --> 02:36:05.600]  Или mt19937, какой хочешь
[02:36:05.600 --> 02:36:08.600]  Конечно очень некрасиво, что нам пришлось перегрузить
[02:36:08.600 --> 02:36:11.600]  Оператор равно, потому что он тут вообще делает не то что
[02:36:11.600 --> 02:36:14.600]  Ну как бы он
[02:36:14.600 --> 02:36:17.600]  Но он делает как бы докладывание в
[02:36:17.600 --> 02:36:20.600]  Какая разница?
[02:36:20.600 --> 02:36:23.600]  В каком месте, когда вы видите
[02:36:23.600 --> 02:36:26.600]  Оператора равно, можете предположить такое поведение?
[02:36:26.600 --> 02:36:29.600]  Мне кажется никто не может
[02:36:29.600 --> 02:36:32.600]  Действительно лучше было бы перегрузить
[02:36:32.600 --> 02:36:35.600]  Но разницы-то никакой фактически
[02:36:35.600 --> 02:36:38.600]  Вопросы есть?
[02:36:38.600 --> 02:36:41.600]  А так с видом сдвигов будет понятно
[02:36:41.600 --> 02:36:44.600]  Какого черта здесь происходит
[02:36:44.600 --> 02:36:47.600]  Я думаю, что это разница
[02:36:47.600 --> 02:36:50.600]  Значит у вас будет задание написать
[02:36:50.600 --> 02:36:53.600]  Merge sort
[02:36:53.600 --> 02:36:56.600]  А не click sort, то есть stable sort
[02:36:56.600 --> 02:36:59.600]  И я подумал, может еще что-нибудь делать
[02:36:59.600 --> 02:37:02.600]  Может нам условия все-таки уже выложить?
[02:37:02.600 --> 02:37:05.600]  Я по тобой не выкладываю
[02:37:05.600 --> 02:37:08.600]  Там как бы меньше месяца осталось
[02:37:08.600 --> 02:37:11.600]  Почему?
[02:37:11.600 --> 02:37:14.600]  Ну так, ну что
[02:37:14.600 --> 02:37:17.600]  Видимо
[02:37:17.600 --> 02:37:20.600]  Видимо
[02:37:20.600 --> 02:37:23.600]  Видимо на этом все
[02:37:23.600 --> 02:37:26.600]  Но не совсем
[02:37:26.600 --> 02:37:29.600]  Я так и не успел вам показать
[02:37:29.600 --> 02:37:32.600]  Одну вещь, которую я еще хотел показать
[02:37:41.600 --> 02:37:44.600]  Да, короче
[02:37:44.600 --> 02:37:47.600]  Ну я и в прошлом году не успел
[02:37:47.600 --> 02:37:50.600]  И в этом году не успел, ну и ладно
[02:37:50.600 --> 02:37:53.600]  Ну давайте я вам просто скажу
[02:37:53.600 --> 02:37:56.600]  Я вам просто скажу
[02:37:56.600 --> 02:37:59.600]  Вы все
[02:38:09.600 --> 02:38:12.600]  Финальный аккорд
[02:38:12.600 --> 02:38:15.600]  Совсем финальный
[02:38:15.600 --> 02:38:18.600]  Уже не относящийся к теме type-листов
[02:38:18.600 --> 02:38:21.600]  В общем C++11
[02:38:21.600 --> 02:38:24.600]  Была такая интересная вещь
[02:38:24.600 --> 02:38:27.600]  Вот есть такая статья
[02:38:27.600 --> 02:38:30.600]  Которая называется Non-Constant Expressions
[02:38:30.600 --> 02:38:33.600]  Это замечательный заголовок
[02:38:33.600 --> 02:38:36.600]  Просто типа
[02:38:36.600 --> 02:38:39.600]  Весь цепочный слабом предложение
[02:38:39.600 --> 02:38:42.600]  Это как вы можете заметить с веб-архива
[02:38:42.600 --> 02:38:45.600]  Потому что по-моему этой статьи на сайте уже нет
[02:38:45.600 --> 02:38:48.600]  Тем не менее там был когда-то русский перевод
[02:38:48.600 --> 02:38:51.600]  История в чем?
[02:38:51.600 --> 02:38:54.600]  Я вот все мечтаю, чтобы когда-то у нас хватило времени
[02:38:54.600 --> 02:38:57.600]  Но видимо не в этом году
[02:38:57.600 --> 02:39:00.600]  История в чем?
[02:39:00.600 --> 02:39:03.600]  Ну вот в общем вопрос
[02:39:03.600 --> 02:39:06.600]  Загадка
[02:39:06.600 --> 02:39:09.600]  Правда ли, что нельзя так написать некоторую функцию f
[02:39:09.600 --> 02:39:12.600]  Чтобы вот это скомпилировалось?
[02:39:12.600 --> 02:39:15.600]  Ну наверное не правда
[02:39:15.600 --> 02:39:18.600]  Мне казалось бы
[02:39:18.600 --> 02:39:21.600]  Что когда мы говорим constexpr i и вызываем f без параметров
[02:39:21.600 --> 02:39:24.600]  У нас не должно быть возможности
[02:39:24.600 --> 02:39:27.600]  Сделать так, что при втором вызове f без параметров
[02:39:27.600 --> 02:39:30.600]  Выдаст другое число
[02:39:30.600 --> 02:39:33.600]  constexpr и глобальная переменная
[02:39:33.600 --> 02:39:36.600]  constexpr переменные они const
[02:39:36.600 --> 02:39:39.600]  Их нельзя менять
[02:39:39.600 --> 02:39:42.600]  А f-то может меняться у себя?
[02:39:42.600 --> 02:39:45.600]  Ну f зависит от какой-нибудь глобальной переменной
[02:39:45.600 --> 02:39:48.600]  Какой? Которая constexpr?
[02:39:48.600 --> 02:39:51.600]  Не может constexpr функция зависеть
[02:39:51.600 --> 02:39:54.600]  А не constexpr функция
[02:39:54.600 --> 02:39:57.600]  constexpr только
[02:39:57.600 --> 02:40:00.600]  Какой-нибудь mutable static
[02:40:00.600 --> 02:40:03.600]  Поле constexpr класса и нормально
[02:40:03.600 --> 02:40:06.600]  О кстати мы не можем
[02:40:06.600 --> 02:40:09.600]  constexpr функцию там не знаю
[02:40:10.600 --> 02:40:13.600]  Илья
[02:40:13.600 --> 02:40:16.600]  Какой-нибудь static mutable
[02:40:16.600 --> 02:40:19.600]  Поле у класса
[02:40:19.600 --> 02:40:22.600]  Который мы как constexpr глобальную переменную взяли
[02:40:25.600 --> 02:40:28.600]  И в их обращаться туда и все
[02:40:28.600 --> 02:40:31.600]  Я думаю ты не можешь mutable писать
[02:40:31.600 --> 02:40:34.600]  Нет кажется у нас может быть еще какой-нибудь прикол
[02:40:34.600 --> 02:40:37.600]  Как constexpr с указателями работает?
[02:40:39.600 --> 02:40:42.600]  Ну const же обычно
[02:40:42.600 --> 02:40:45.600]  Навешивается на указания справа
[02:40:45.600 --> 02:40:48.600]  Короткая история в том что
[02:40:48.600 --> 02:40:51.600]  По задумке так нельзя делать
[02:40:51.600 --> 02:40:54.600]  Должно было по идее
[02:40:54.600 --> 02:40:57.600]  Все то что умеет constexpr функция
[02:40:57.600 --> 02:41:00.600]  Оно не дает вам возможности менять глобальное состояние
[02:41:00.600 --> 02:41:03.600]  Если f сама не зависит от чего
[02:41:03.600 --> 02:41:06.600]  Тем не менее было обнаружено
[02:41:06.600 --> 02:41:09.600]  Что существует hack
[02:41:09.600 --> 02:41:12.600]  Это не static, не mutable
[02:41:12.600 --> 02:41:15.600]  Все продумано нормально
[02:41:15.600 --> 02:41:18.600]  Вы в constexpr функции можете менять только constexpr
[02:41:18.600 --> 02:41:21.600]  Но они сами const
[02:41:21.600 --> 02:41:24.600]  А hack в стандарте нашли дыру
[02:41:24.600 --> 02:41:27.600]  Которая позволяет сделать компилируемую
[02:41:27.600 --> 02:41:30.600]  И эта дыра она
[02:41:30.600 --> 02:41:33.600]  Основывается на том
[02:41:34.600 --> 02:41:37.600]  Объявления friend методов
[02:41:37.600 --> 02:41:40.600]  Имеют некоторые побочные эффекты
[02:41:47.600 --> 02:41:50.600]  Стоп снято
[02:41:50.600 --> 02:41:53.600]  Если вкратце то
[02:41:53.600 --> 02:41:56.600]  Существует некоторый способ
[02:41:56.600 --> 02:41:59.600]  Заставить компилятор поменять
[02:41:59.600 --> 02:42:02.600]  Глобальное состояние компилятора
[02:42:02.600 --> 02:42:05.600]  И тем самым завести constexpr счетчик
[02:42:05.600 --> 02:42:08.600]  Который позволяет узнавать компилятор
[02:42:08.600 --> 02:42:11.600]  На какой стадии
[02:42:11.600 --> 02:42:14.600]  Существует способ hack
[02:42:14.600 --> 02:42:17.600]  Компилятор так
[02:42:17.600 --> 02:42:20.600]  Чтобы иметь внутреннее состояние счетчик
[02:42:20.600 --> 02:42:23.600]  Который по мере компиляции вы увеличиваете
[02:42:23.600 --> 02:42:26.600]  Когда вам надо
[02:42:26.600 --> 02:42:29.600]  Некоторый глобальный счетчик
[02:42:29.600 --> 02:42:32.600]  В стандарте есть дыра
[02:42:32.600 --> 02:42:35.600]  Которая позволяет это сделать
[02:42:35.600 --> 02:42:38.600]  И работает она за счет того
[02:42:38.600 --> 02:42:41.600]  Что объявление friend функции имеет побочный эффект
[02:42:41.600 --> 02:42:44.600]  С помощью объявления friend
[02:42:44.600 --> 02:42:47.600]  Хитрым образом в некоторых местах
[02:42:47.600 --> 02:42:50.600]  Можно добиться того
[02:42:50.600 --> 02:42:53.600]  Что вы узнаете
[02:42:53.600 --> 02:42:56.600]  Некоторый глобальный стейт компилятора
[02:42:56.600 --> 02:42:59.600]  Сейчас чуть подробнее
[02:42:59.600 --> 02:43:02.600]  А может ссылку на статью?
[02:43:02.600 --> 02:43:05.600]  Мы не торопимся
[02:43:05.600 --> 02:43:08.600]  Нет, мы торопимся, потому что время закупились
[02:43:08.600 --> 02:43:11.600]  В смысле?
[02:43:11.600 --> 02:43:14.600]  Я скину вам эту статью
[02:43:14.600 --> 02:43:17.600]  Здесь есть некоторая структура
[02:43:17.600 --> 02:43:20.600]  Я не в состоянии сейчас вам рассказать
[02:43:20.600 --> 02:43:23.600]  Как это работает, потому что я не
[02:43:23.600 --> 02:43:26.600]  Подготовился до такой степени
[02:43:26.600 --> 02:43:29.600]  Чтобы рассказать
[02:43:29.600 --> 02:43:32.600]  Нужно еще сидеть и залипать
[02:43:32.600 --> 02:43:35.600]  Здесь есть некоторая магия
[02:43:35.600 --> 02:43:38.600]  Которая основывается на том
[02:43:38.600 --> 02:43:41.600]  Что friend функции обладают некоторыми побочными эффектами
[02:43:41.600 --> 02:43:44.600]  Когда вы их объявляете
[02:43:44.600 --> 02:43:47.600]  Так называемый writer
[02:43:47.600 --> 02:43:50.600]  Он объявляет friend функцию
[02:43:50.600 --> 02:43:53.600]  Он как-то влияет
[02:43:53.600 --> 02:43:56.600]  На глобальное состояние компилятора
[02:43:56.600 --> 02:43:59.600]  У вас еще dependant writer
[02:43:59.600 --> 02:44:02.600]  Который наследуется от writer
[02:44:02.600 --> 02:44:05.600]  И тем самым вы...
[02:44:09.600 --> 02:44:12.600]  Это какой-то огромный хак
[02:44:12.600 --> 02:44:15.600]  Да, это огромный хак
[02:44:15.600 --> 02:44:18.600]  Но его последствия довольно интересные
[02:44:18.600 --> 02:44:21.600]  Вы можете рассказать
[02:44:24.600 --> 02:44:27.600]  Господи
[02:44:27.600 --> 02:44:30.600]  Compile time counter
[02:44:30.600 --> 02:44:33.600]  Мы что здесь...
[02:44:33.600 --> 02:44:36.600]  По сути таким образом мы можем там допустим
[02:44:36.600 --> 02:44:39.600]  Compile time полноценно сделать
[02:44:39.600 --> 02:44:42.600]  M3997
[02:44:42.600 --> 02:44:45.600]  То есть мы по сути таким образом
[02:44:45.600 --> 02:44:48.600]  Мы можем написать какую-то функцию next
[02:44:48.600 --> 02:44:51.600]  Которая в compile time меняет
[02:44:51.600 --> 02:44:54.600]  На глобальный состояние
[02:44:54.600 --> 02:44:57.600]  И мы столько раз уже вызвали функцию next
[02:44:57.600 --> 02:45:00.600]  Компилятору
[02:45:00.600 --> 02:45:03.600]  Мы можем написать функцию next
[02:45:03.600 --> 02:45:06.600]  Которая в compile time
[02:45:06.600 --> 02:45:09.600]  Меняет на глобальный состояние
[02:45:09.600 --> 02:45:12.600]  И мы столько раз уже вызвали
[02:45:12.600 --> 02:45:15.600]  По задумке так не должно было быть
[02:45:15.600 --> 02:45:18.600]  Потому что вы не можете
[02:45:18.600 --> 02:45:21.600]  В compile time иметь глобальные переменные
[02:45:21.600 --> 02:45:24.600]  Которые неконстантные
[02:45:24.600 --> 02:45:27.600]  Но за счет этого хака можете
[02:45:27.600 --> 02:45:30.600]  И тем самым...
[02:45:30.600 --> 02:45:33.600]  Можно вопрос
[02:45:33.600 --> 02:45:36.600]  У меня есть ощущение, что есть
[02:45:36.600 --> 02:45:39.600]  Составитель стандарта
[02:45:39.600 --> 02:45:42.600]  Составители стандарта не представляют правила
[02:45:42.600 --> 02:45:45.600]  А все остальные пытаются их надурить
[02:45:45.600 --> 02:45:48.600]  Примерно так и есть
[02:45:48.600 --> 02:45:51.600]  Ты только сейчас это понял
[02:45:51.600 --> 02:45:54.600]  Но в плане тебя пытаются в чем-то ограничить
[02:45:54.600 --> 02:45:57.600]  Я не понимаю, почему мы играем против
[02:45:57.600 --> 02:46:00.600]  Составителей стандарта, если мы вместе хотим
[02:46:00.600 --> 02:46:03.600]  Создать хороший язык с их дискуссией
[02:46:03.600 --> 02:46:06.600]  Мы не против
[02:46:06.600 --> 02:46:09.600]  У нас не противоположные цели
[02:46:09.600 --> 02:46:12.600]  Одинаковые
[02:46:12.600 --> 02:46:15.600]  Эта штука называется stateful metaprogramming
[02:46:15.600 --> 02:46:18.600]  Это метапрограммирование
[02:46:18.600 --> 02:46:21.600]  В котором у вас присутствует
[02:46:21.600 --> 02:46:24.600]  Глобальный стейт
[02:46:24.600 --> 02:46:27.600]  В стадии компиляции
[02:46:27.600 --> 02:46:30.600]  И вы можете на него влиять
[02:46:30.600 --> 02:46:33.600]  Здесь есть
[02:46:33.600 --> 02:46:36.600]  Такой дисклеймер
[02:46:42.600 --> 02:46:45.600]  Core Working Group of 3D21
[02:46:45.600 --> 02:46:48.600]  Is trying its best to make the technique
[02:46:48.600 --> 02:46:51.600]  describing this and previous post informed
[02:46:51.600 --> 02:46:54.600]  Когда комитет узнал, что
[02:46:54.600 --> 02:46:57.600]  Составитель стандарта не представляет правила
[02:46:57.600 --> 02:47:00.600]  Когда комитет узнал, что так можно
[02:47:00.600 --> 02:47:03.600]  Они сказали, что это полный ужас
[02:47:03.600 --> 02:47:06.600]  И мы постараемся как-то исправить стандарт
[02:47:06.600 --> 02:47:09.600]  Это примерно как я, который вам говорит
[02:47:09.600 --> 02:47:12.600]  Я исправлю тесты
[02:47:12.600 --> 02:47:15.600]  Они сказали, что они постараются
[02:47:15.600 --> 02:47:18.600]  trying its best to make the technique
[02:47:18.600 --> 02:47:21.600]  Но этот пост он от 2015 года
[02:47:21.600 --> 02:47:24.600]  И с тех пор стандарты
[02:47:24.600 --> 02:47:27.600]  Все еще позволяет
[02:47:27.600 --> 02:47:30.600]  Просто автор пропал типа
[02:47:30.600 --> 02:47:33.600]  И удалили статьи
[02:47:33.600 --> 02:47:36.600]  А так вот как они решили проблему
[02:47:36.600 --> 02:47:39.600]  В комитете шли какие-то дискуссии
[02:47:39.600 --> 02:47:42.600]  Стоит ли оставлять такую дыру
[02:47:42.600 --> 02:47:45.600]  В стандарте, который позволяет это делать или нет
[02:47:45.600 --> 02:47:48.600]  Видимо решили, что нужно
[02:47:48.600 --> 02:47:51.600]  Золотать, но пока не золотать
[02:47:51.600 --> 02:47:54.600]  Скорее всего они сказали, что надо золотать
[02:47:54.600 --> 02:47:57.600]  А сейчас думают
[02:47:57.600 --> 02:48:00.600]  Как это полноценный фичой ввести
[02:48:00.600 --> 02:48:03.600]  Я не следил
[02:48:03.600 --> 02:48:06.600]  Возможно это замороженная штука
[02:48:06.600 --> 02:48:09.600]  И она так и существует
[02:48:09.600 --> 02:48:12.600]  Можно и можно
[02:48:12.600 --> 02:48:15.600]  Кто хочет, тот использует
[02:48:15.600 --> 02:48:18.600]  Можно просто сделать эту штуку бесполезной
[02:48:18.600 --> 02:48:21.600]  Почему мы в комитете смотрим
[02:48:21.600 --> 02:48:24.600]  Как кто хочет нас
[02:48:24.600 --> 02:48:27.600]  Ограничить функционально
[02:48:27.600 --> 02:48:30.600]  Потому что ты со стороны пользы
[02:48:30.600 --> 02:48:33.600]  Часто не ожидаешь, что вызов
[02:48:33.600 --> 02:48:36.600]  Будет менять глобальные штыки
[02:48:36.600 --> 02:48:39.600]  Это случайно не произойдет
[02:48:39.600 --> 02:48:42.600]  Если не весь код пишешь
[02:48:42.600 --> 02:48:45.600]  Если случайно взять библиотепу
[02:48:45.600 --> 02:48:48.600]  Ты в какой-то момент получаешь
[02:48:48.600 --> 02:48:51.600]  Очень большое удивление
[02:48:57.600 --> 02:49:00.600]  Мы как и в прошлом году не успели
[02:49:00.600 --> 02:49:03.600]  Досконально разобрать эту штуку
[02:49:03.600 --> 02:49:06.600]  Ну и бог с ним
[02:49:06.600 --> 02:49:09.600]  У нас в прошлом году был на экзамене
[02:49:09.600 --> 02:49:12.600]  Один человек, который заботал вот это
[02:49:13.600 --> 02:49:16.600]  На аутол 10
[02:49:16.600 --> 02:49:19.600]  На аутол 10 нам что бы это рассказать
[02:49:19.600 --> 02:49:22.600]  Нет, не обязательно, это был вопрос по выбору
[02:49:22.600 --> 02:49:25.600]  Он сказал, я готов это рассказать
[02:49:25.600 --> 02:49:28.600]  Если кто-нибудь из вас готов заботать вот эти три статьи
[02:49:28.600 --> 02:49:31.600]  И объяснить, что здесь происходит
[02:49:31.600 --> 02:49:34.600]  Возможно
[02:49:34.600 --> 02:49:37.600]  Мы вам добавим бонус
[02:49:37.600 --> 02:49:40.600]  Почему три
[02:49:40.600 --> 02:49:43.600]  Человек рассказывает сначала как идею
[02:49:43.600 --> 02:49:46.600]  В следующей статье он рассказывает
[02:49:46.600 --> 02:49:49.600]  Как это можно превратить в Compile Time счетчик
[02:49:49.600 --> 02:49:52.600]  А в следующей статье как это можно сделать Compile Time контейнером
[02:49:52.600 --> 02:49:55.600]  С глобальным стейтом
[02:49:55.600 --> 02:49:58.600]  А потом как сделать коктейль молота
[02:49:58.600 --> 02:50:01.600]  Вот у него здесь есть
[02:50:01.600 --> 02:50:04.600]  Это после коктейля молота
[02:50:04.600 --> 02:50:07.600]  Что-то более опасное
[02:50:07.600 --> 02:50:10.600]  Видите, что здесь происходит
[02:50:10.600 --> 02:50:13.600]  У него есть некоторый
[02:50:13.600 --> 02:50:16.600]  Метаконтейнер
[02:50:16.600 --> 02:50:19.600]  Который он докладывает
[02:50:19.600 --> 02:50:22.600]  Потом по индексу 0 присваивает
[02:50:22.600 --> 02:50:25.600]  То есть у него есть контейнер
[02:50:25.600 --> 02:50:28.600]  Который в Compile Time изменяемый
[02:50:28.600 --> 02:50:31.600]  Как бы
[02:50:31.600 --> 02:50:34.600]  Нет
[02:50:34.600 --> 02:50:37.600]  Мы каждый раз создаем новый объект
[02:50:37.600 --> 02:50:40.600]  Новый тип
[02:50:40.600 --> 02:50:43.600]  А тут у него есть
[02:50:43.600 --> 02:50:46.600]  Некоторый металист
[02:50:46.600 --> 02:50:49.600]  Который туда делает
[02:50:49.600 --> 02:50:52.600]  И после этого у него
[02:50:52.600 --> 02:50:55.600]  Какой-то глобальный стейт меняется
[02:50:55.600 --> 02:50:58.600]  Наоборот
[02:50:58.600 --> 02:51:01.600]  Мы же этого и хотим
[02:51:01.600 --> 02:51:04.600]  Ну
[02:51:04.600 --> 02:51:07.600]  То есть нужно будет реализовать вот это
[02:51:07.600 --> 02:51:10.600]  Нет, вам не нужно будет реализовывать это
[02:51:10.600 --> 02:51:13.600]  Потому что мы не успели разобрать свою технику
[02:51:13.600 --> 02:51:16.600]  Поэтому, к сожалению, задачу Type List я в этом году это снова не включу
[02:51:16.600 --> 02:51:19.600]  Когда-нибудь
[02:51:19.600 --> 02:51:22.600]  Помянем тех, кто будет первым или будет очень жалко
[02:51:22.600 --> 02:51:25.600]  Господа, на этом наш курс торжественно завершен
[02:51:25.600 --> 02:51:28.600]  Всем спасибо
[02:51:28.600 --> 02:51:31.600]  Спасибо
