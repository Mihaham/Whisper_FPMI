[00:00.000 --> 00:09.640]  мы сегодня с вами будем говорить про потоки кто как воспринимает потоки что это кого еще в голове
[00:09.640 --> 00:26.120]  вот вывод водопаде про машины что-нибудь хорошо а перелистывайте смотрите фактически с потоками
[00:26.120 --> 00:33.000]  мы встречаемся очень часто а грубо говоря если вы будете делать не знаю вот кто-нибудь из вас
[00:33.000 --> 00:38.600]  захочет побыть все-таки сантехником например нужно вот трубы перекладывать правильно вот и
[00:38.600 --> 00:45.040]  там есть некоторые там поток воды не знаю может кто-то из вас станет крутым физиком и будет
[00:45.040 --> 00:52.240]  типа не воду так делать а что-нибудь другое не знаю там электрончики в коллайдере разгонять это
[00:52.240 --> 00:58.640]  тоже некоторая труба кросс с магнитами для того чтобы они правильно разгонялись вот и в
[00:58.640 --> 01:05.040]  действительности потоки вы увидите на индекс картах если захотите вот типа как машинки двигаются и
[01:05.040 --> 01:12.800]  почему сейчас 9 бальные пробки или нет там когда как вот и в действительности вы когда работаете
[01:12.800 --> 01:19.840]  с потоками вы смотрите ага вот например вы решили не знаю там пойти куда-нибудь вы смотрите я
[01:19.840 --> 01:24.120]  могу пойти вот так я могу пойти вот так и выбирайте там например кратчайший пути представьте
[01:24.120 --> 01:31.080]  что вам нужно покрыть все вот вы такие экспериментаторы вы хотите взять и пройтись по максимуму того что
[01:31.080 --> 01:37.440]  увидеть что-то на улице не знаю вон траву вы разглядывали вот вы захотели увидеть траву вот
[01:37.440 --> 01:43.360]  во всех местах где она есть к примеру и вы понимаете что вот это вот дорожка сейчас загружена вот это
[01:43.360 --> 01:48.720]  нет вот это будет столько-то времени идти и так далее в действительности задача связанная с
[01:48.720 --> 01:53.920]  потоками выглядит скорее здесь нужна ассоциация с какими-нибудь действительно водопроводными
[01:53.920 --> 01:59.920]  системами когда у вас есть труба поменьше труба побольше пропускается в одной не знаю там три
[01:59.920 --> 02:05.600]  литра в секунду в другой там типа 10 литров в секунду и так далее вот и вы хотите понять а
[02:05.600 --> 02:12.720]  сколько вообще вот в этой системе вы можете взять и перевести воду из одной точки в другую
[02:12.720 --> 02:18.600]  первая точка называется как раз таки источник это считайте что бесконечное количество воды
[02:18.600 --> 02:27.040]  чего-то еще и есть сток это то что просто всасывает эту воду вот куда-то бы в ней ее испаряет и вам
[02:27.040 --> 02:32.400]  нужно понимать вообще а сколько максимум воды то я могу передать вот сколько от одной точки в
[02:32.400 --> 02:45.960]  другую и вот это и есть та самая задача перелистывайте слайдик а смотрите это вот
[02:45.960 --> 02:51.760]  все что связано здесь потоками с транспортной сетью вот это вот всем очень хорошо формализовать
[02:51.760 --> 02:57.680]  для того чтобы это как-то использовать какая какое первое приближение такой формализации можно
[02:57.680 --> 03:05.480]  сделать смотрите как бы транспортной сетью мы зовем некоторые граф вот где у нас будут
[03:05.480 --> 03:13.680]  определенные вершины и сток и сток буковка с будет исток сток это буковка т вот и ведем
[03:13.680 --> 03:19.960]  некоторую функцию пропускных способностей причем заметьте это функция пропускных способностей не
[03:19.960 --> 03:27.120]  от ребер идет от пары вершин то есть сколько я могу не знаю передать какой-то жиджи вот я
[03:27.120 --> 03:31.680]  думаю вы все играли в minecraft там есть не только вода вы можете там мне передавать там не знать
[03:31.680 --> 03:44.200]  какие-то соки а есть такое зря так там и лаву можно так передавать все можно делать вот в общем-то
[03:44.200 --> 03:51.680]  это именно расстояние между парами вершин то есть сколько вы можете передать между парой вершин
[03:51.680 --> 03:59.680]  какого-то там вот объекта причем если вдруг вашего ребра нету в графе то в этом случае мы
[03:59.680 --> 04:07.480]  говорим что это просто что вот это пропускная способность между этой парой вершин просто
[04:07.480 --> 04:17.120]  ноль то есть я не могу ничего передать вот и все как-то так потоком в транспортной сети мы будем
[04:17.120 --> 04:24.680]  называть некоторую функцию f это функция из двух вершин в какие-то там числа вот а каких двух
[04:24.680 --> 04:31.320]  вершин до любых на самом деле вот и мы будем смотреть что у нас здесь связано с потоком первое
[04:31.320 --> 04:38.000]  свойство потока следующее что для любых двух вершин из в принципе у нас поток больше нуля
[04:38.000 --> 04:43.760]  логично что если мы начали переливать там воду больше либо равно нуля мы передали вот этот поток
[04:43.760 --> 04:48.680]  между этими вершинами он либо есть либо его нет вы не можете кинуть это в обратную сторону и
[04:48.680 --> 04:52.520]  естественно он будет меньше либо равен чем пропускная способность потому что если вы
[04:52.520 --> 04:59.160]  попробуете не знаю какую-нибудь маленькую трубу запихнуть много-много воды но что с ней произойдет
[04:59.160 --> 05:03.840]  она лопнет я думаю в детстве у всех могло быть такое что вы положили бутылку в морозилку она
[05:03.840 --> 05:10.080]  чуть-чуть это расширилась вот если стеклянная то она могла разбиться видимо нет это видимо
[05:10.080 --> 05:17.560]  у меня трудное детство было ладно хорошо пусть будет окей и второе есть свойство
[05:17.560 --> 05:25.520]  свойство следующее что для любой вершины кроме стока и стока мы говорим что количество входного
[05:25.520 --> 05:33.920]  потока равно количество выходного потока то есть ни одна из вершин не накапливает вот эту вот то
[05:33.920 --> 05:41.320]  что вы хотите передать давайте буду так обозначать то есть ни в одной вершине не застаивается потом
[05:41.320 --> 05:49.200]  и сток и сток он генерирует бесконечное количество какого-то материала сток может
[05:49.200 --> 05:54.560]  вбирать бесконечное количество материала вот в них оно накапливается само по себе а вот
[05:54.560 --> 06:00.920]  между ними вот вершины которые мы не можем сказать что у нас там хоть что-то есть определение
[06:00.920 --> 06:08.080]  понятно она достаточно естественно но оно оказывается неудобным в случае когда мы будем
[06:08.080 --> 06:13.760]  работать с алгоритмом поэтому будем использовать немного другой но об этом чуть попозже давайте
[06:13.760 --> 06:21.720]  дальше что еще важно знать из таких вот определений есть величина исходящего потока есть величина
[06:21.720 --> 06:28.720]  входящего потока оно исходящего это то что выходит из вершины из нашего и стока именно
[06:28.720 --> 06:37.520]  входящего это то что входит у нас в сток понятно лишь что по числам это одинаковые
[06:37.520 --> 06:45.200]  чиселки сколько вышло из стока столько должно прийти в сток потому что мы не накапливаем никакие
[06:45.200 --> 06:50.920]  вершины посерединке все достаточно просто согласны вот чуть-чуть попозже мы докажем это
[06:50.920 --> 06:56.840]  для другого некоторого определения вот ну грубо говоря на той картинке который вы сейчас видите
[06:56.840 --> 07:03.720]  между собой вот из стока вышло 2 пошло по пути где 5 максимальная пропускная способность 3 пошло
[07:03.720 --> 07:11.600]  по пути где было 7 то есть вышло 5 изошло в сток аналогично 5 вот ничего у нас не осталось по
[07:11.600 --> 07:20.240]  середине окей давайте дальше а что важно здесь понимать важно понимать здесь следующее что мы
[07:20.240 --> 07:25.280]  исходящий поток и входящий поток сами по себе так они равны будем обозначать просто вот
[07:25.760 --> 07:31.640]  заметьте модулев не означает что это положительное число будет в дальнейшем мы не будем этого
[07:31.640 --> 07:41.480]  использовать окей вот это просто вот это обозначение того суммарного потока который у вас будет вот
[07:41.480 --> 07:48.360]  ну и как бы какая формальная задача формальная задача звучит так для данной транспортной сети
[07:48.360 --> 07:53.440]  которую мы с вами не знаю там считали что-то с ней сделали и так далее необходимо найти
[07:53.440 --> 08:05.760]  максимальный такой вот путь для того чтобы был максимальный поток ну вот мы argmax там максим да
[08:05.760 --> 08:14.880]  да да да то есть как нам нужно это сделать вот и как вообще с этим жить вот такая вот задача какой
[08:14.880 --> 08:24.800]  первый алгоритм приходит вам в голову или не приходит что-то типа прима по минимальном идти
[08:24.800 --> 08:49.320]  хорошо а дальше окей а еще есть какие-то дать самое простое что приходит коф
[08:49.320 --> 08:59.600]  в эф что еще раз перебор кидываем один кидываем два кидываем три и так далее
[08:59.600 --> 09:10.920]  бинарный поиск по ответу такой понял хорошо а бфс что сделается бф оценку
[09:10.920 --> 09:20.320]  самое простое действительности самое простое давайте попробуем следующим образом частично
[09:20.320 --> 09:27.480]  будет связано с бфс но мы дойдем до этого чуть попозже пусть у нас будет некоторые некоторые
[09:27.480 --> 09:34.600]  наши транспортная сеть и мы найдем какой-то путь вот я нашел в этой транспортной сети какой-то
[09:34.600 --> 09:43.000]  путь сколько максимум воды могу налить минимальное ребро давайте это и попробуем сделать это будет
[09:43.000 --> 09:51.560]  жадный такой алгоритм можно перелистывать вот там слово план написано давайте найдем некоторые
[09:51.560 --> 09:58.960]  вот этот вот произвольный путь из истока в сток и вот бахнем по максимуму сколько можем воды и
[09:58.960 --> 10:06.400]  будем повторять эти действия пока у нас этот путь будет находиться алгоритм сам понятен что мы
[10:06.400 --> 10:23.440]  хотим сделать просто выглядит вроде просто кто понимает чем беда вы читаем конечно вы читаем то
[10:23.440 --> 10:33.360]  есть у нас остается какое-то место мы пытаемся идти ну мы будем все пути проходить
[10:33.360 --> 10:40.600]  два пути 1 так хорошо и чего
[10:40.600 --> 10:49.840]  вот тебе два пути
[10:49.840 --> 11:14.440]  5 3 3 3 3 почему нет смотрите я нашел один путь давайте еще раз закидываю здесь у меня 3 из 5 здесь
[11:14.440 --> 11:21.840]  3 из 3 здесь 3 из трех я такой ага хорошо а теперь я такой максиме могу вот здесь два осталось здесь
[11:21.840 --> 11:35.640]  3 здесь три значит я делаю 5 2 2 да да да конечно мы обновляем нашу весовую вот эту функцию там
[11:35.640 --> 11:48.000]  может еще быть бак кто-нибудь представляет видит абстрактно назовем так нет так нельзя так не
[11:48.000 --> 11:56.160]  интересно но вот если я буду просто жадно находить вот эти вот пути в чем у нас будет
[11:56.160 --> 12:18.600]  проблема и будет ли она вообще давайте я нарисую то что вообще сломает систему полностью нам
[12:18.600 --> 12:19.880]  нужен максимальный поток
[12:32.240 --> 12:39.840]  пока здесь максимальный поток 2 то есть я вот так должен повести вот так повести вот это
[12:40.840 --> 12:48.880]  верно теперь смотрите я взял и вот сказал что вот эти вот я же любой путь беру я взял вот этот
[12:48.880 --> 12:59.560]  путь у меня здесь один есть один есть один могу ли я еще прокинуть вот понимаете в чем беда
[12:59.560 --> 13:08.080]  здесь жадным алгоритмом можно дальше вот какой изъян в плане а именно вот такие вот плохие какие-то
[13:08.080 --> 13:15.280]  вещи у нас появляются и хочется сделать что-то с ними таким вот образом чтобы вот это мы могли
[13:15.280 --> 13:24.000]  как-то отменять потому что я хочу сделать здесь два здесь два логично логично вот что-то с этим
[13:24.000 --> 13:31.880]  необходимо подумать и придумать поэтому здесь у нас получаются какие-то вот такие вот вещи так
[13:31.880 --> 13:42.800]  это можно избежать давайте дальше смотрите а давайте ведем более удобное правило более
[13:42.800 --> 13:49.400]  понятной и нет не более понятная более удобная с точки зрения алгоритма давайте ведем так так
[13:49.400 --> 13:56.440]  называемый симметризованный поток что это такое смотрите я буду говорить следующее если я пустил
[13:56.440 --> 14:04.120]  воду в одну сторону то пусть в обратную сторону льется отрицательное число то есть грубо говоря
[14:04.120 --> 14:12.080]  вот у меня есть обратный какой-то поток у него пропускная способность ноль согласны правда вот
[14:12.080 --> 14:21.000]  но будет минус один еще то есть если я один сделал по ребру то в этом случае я обратно пускаю отрицательный
[14:21.000 --> 14:28.600]  поток отрицательный вот эту весовую у меня все выполняется то есть у меня выше чем пропускная
[14:28.600 --> 14:35.000]  способность ничего не делается и все хорошо чем это полезно ну вот если тут прям дорисовать то
[14:35.000 --> 14:42.800]  тут будет 0 0 ну и так далее давайте какую-нибудь большую картиночку сделаем чтобы можно было
[14:42.800 --> 14:43.720]  красиво рисовать
[14:43.720 --> 15:13.680]  я говорю что у меня здесь один здесь один здесь один здесь один
[15:13.680 --> 15:23.200]  и вот здесь вот а здесь у меня как бы 0 0 0 0 и 0 все обратную сторону у меня ничего не
[15:23.200 --> 15:31.520]  происходит и вот здесь я буду сделать следующее что как только я по одному из потоков делаю
[15:31.520 --> 15:38.040]  что-то то есть пропускаю вот эту воду грубо говоря в один из по одной из по одному из
[15:38.040 --> 15:44.000]  пути то в этом случае я пускаю грубо говоря обратный поток с отрицательным значением тогда
[15:44.000 --> 15:51.240]  у меня суммарно оно будет хлопаться грубо говоря поэтому здесь если я сделаю один один и вот
[15:51.240 --> 16:00.840]  здесь один в этом случае у меня здесь будет минус один а минус один здесь минус один согласны
[16:00.840 --> 16:15.200]  фактически потоком мы назовем все также функцию из вершин из пар вершин какие-то числа мы говорим
[16:15.200 --> 16:20.760]  что если у меня есть поток в какую-то одну сторону то в обратную сторону идет отрицательный кроме
[16:20.760 --> 16:28.760]  того все весь этот поток он всегда не больше чем пропускная способность который у нас есть что
[16:28.760 --> 16:34.160]  тоже логично минус один меньше нуля один меньше единички меньше либо равен согласны как бы ничего
[16:34.160 --> 16:40.840]  пока не нарушается вот и последнее я говорю что суммарно вот суммарно если я смотрю поток в
[16:40.840 --> 16:49.720]  какой-то вершине в конкретной то из нее выходит ноль в ней опять же ничего не застаивается то есть
[16:49.720 --> 16:55.280]  благодаря вот этой вот симметризованные штуки я получаю вот такую вот вещь чем это полезно как
[16:55.280 --> 17:08.480]  вы думаете да то есть смотрите в случае если я пойду вот таким вот образом у меня вот
[17:08.480 --> 17:24.080]  здесь сколько осталось пропускной способности 1 0 минус минус один один то есть смотрите я
[17:24.080 --> 17:32.320]  могу взять и пойти по вот этому пути согласны потому что вот здесь у меня 0 единички и вот
[17:32.320 --> 17:46.240]  здесь 0 я могу сделать вот так вот так и вот так и пустить единицу потому что если я прибавлю
[17:46.240 --> 17:51.680]  единицу то у меня ничего не изменится ну изменить то есть вот здесь будет единица вот здесь будет
[17:51.680 --> 18:06.440]  ну и с 0 здесь будет единица ага понятно что входит в понятие симметризованного потока и зачем я
[18:06.440 --> 18:13.600]  это вел вот а фактически отличие от предыдущего определения почти никаких кроме вот этого вот
[18:13.600 --> 18:23.160]  обратных ребер которые у нас есть принято хорошо тогда если нет вопросов давайте дальше то у нас
[18:23.160 --> 18:28.760]  здесь будет происходить давайте докажем что у нас величина исходящего потока равна величине
[18:28.760 --> 18:35.840]  входящего потока а как это сделать ну смотри достаточно просто согласны ли вы с тем что если
[18:35.840 --> 18:42.000]  я возьму потоки во всех вершинах абсолютно во всех которые у нас есть то в этом случае оно
[18:42.040 --> 18:50.520]  эта сумма всех потоков равна нулю потому что у нас как бы мы туда смотрим и сюда смотрим
[18:50.520 --> 18:56.320]  смотрим сколько выходит входит все достаточно просто а и сток со стоком они будут друг друга
[18:56.320 --> 19:04.600]  заменитажать по факту окей давайте возьмем оттуда отдельно из этой суммы вытащим следующее что мы
[19:04.600 --> 19:18.480]  возьмем всю сумму от всех стоков и стоков и посмотрим еще и выделим сумму всех и стоков то есть
[19:18.480 --> 19:28.840]  все что входит то есть я смотрю все что выходит из s и все что входит в те я смотрю сколько максимум
[19:28.840 --> 19:35.880]  я выливаю воды сколько я вливаю воду и у меня остается еще некоторая сумма сумма сумм по
[19:35.880 --> 19:47.200]  всем вершинам кроме вот первая сумма у меня идет кроме вершин s и t а теперь смотрите у меня давайте
[19:47.200 --> 19:59.040]  у меня вот здесь вот кроме вершин там в без ст грубо говоря здесь у меня сумма по всем у из в
[19:59.040 --> 20:03.680]  ему вот это равно
[20:03.680 --> 20:14.800]  почему
[20:14.800 --> 20:26.880]  мы говорили с вами что вершине не должно ничего застаиваться в действительности мы можем с вами
[20:26.880 --> 20:34.200]  открыть предыдущую предыдущий слайд там третьим свойствам написано что для всех вершин для всех
[20:34.200 --> 20:43.480]  вершин вот из этого множества мы говорим что вот эта сумма это ноль согласны тогда получается
[20:43.480 --> 20:53.680]  следующее что сумма потока из вершины s и сумма входящего потока вершину t в сумме они дают 0
[20:53.680 --> 21:04.320]  хорошо а теперь давайте я хочу понять сколько у меня сумма входящего в s и входящего в t а теперь
[21:04.320 --> 21:10.080]  я разворачиваю просто у t что у меня теперь не входит а выходит потому что я могу вот это правило
[21:10.080 --> 21:15.360]  симметричности здесь делать сколько входит столько и выходит ну то есть тут один тут минус один я
[21:15.360 --> 21:29.360]  меняю знак получаю что у меня сумма по всем f от su минус сумма по всем вершинам из у т по всем у
[21:29.360 --> 21:35.800]  который у нас есть она равна 0 значит эти потоки равны все достаточно просто есть ли вопросы к этому
[21:35.800 --> 21:44.200]  доказательству утверждения нет очень сложно без презентации но надеюсь вы все видите теперь давайте
[21:44.200 --> 21:50.120]  следующий слайд почему вообще симметризация вот это решает проблему того что у нас есть мы
[21:50.120 --> 21:58.200]  немножко с вами говорили на тему того что у нас происходит можно еще один слайд сделать ну все
[21:58.200 --> 22:02.880]  очень просто в этой симметризации мы можем исправлять вот те самые плохие ручейки которые
[22:02.880 --> 22:09.160]  у нас есть вот эти вот плохие вот обходы которые у нас были потому что мы можем ходить теперь
[22:09.160 --> 22:15.360]  обратно мы можем в одну сторону и в другую ходить и и наши потоки как раз таки делать кстати вот
[22:15.360 --> 22:21.600]  здесь должно стать 0 я прошу прощения ошибся потому что если мы провели вот так здесь минус
[22:21.600 --> 22:36.520]  один на ноль пустился значит здесь мы прибавили здесь убавили понятно что еще раз нужно
[22:36.520 --> 22:39.080]  нужно
[22:39.080 --> 22:50.000]  теперь когда мы смотрим на этот граф можем ли мы что-нибудь еще пустить мы скажем что не можем
[22:50.000 --> 23:04.840]  окей вот в общем-то все достаточно просто теперь поехали дальше перейдите там на два слайда вперед
[23:04.840 --> 23:10.920]  рифметика потоков как это вообще все работает смотрите мы ведем еще одно понятие которое
[23:10.920 --> 23:18.760]  называется остаточной сетью для графа какого-то же а вот у нас есть граф же остаточной сетью
[23:18.760 --> 23:28.200]  жи называется вот такая вот тройка е в и цен и поток f вот у нас вот есть некоторые графы на
[23:28.200 --> 23:33.240]  нем задана вот это вот функция пропускной способности у нас есть некоторые потоки f и вот
[23:33.240 --> 23:42.400]  остаточной сетью для него называется такая вот тройка f и е ф цф и вот этого тройка она
[23:42.400 --> 23:52.400]  формирует следующим образом вы еф они фактически такие же будут как и у предыдущего графа с точки
[23:52.400 --> 23:58.880]  зрения того как они выглядят но единственное что если вдруг у нас есть некоторый поток то в этом
[23:58.880 --> 24:04.840]  случае мы с вами смотрим вот эту остаточную пропускную способность то есть вот это цф она
[24:04.840 --> 24:11.000]  равна ц-ф ну давайте какой-нибудь граф нарисуем пустим какой-нибудь поток и вы поймете что я имею
[24:11.000 --> 24:34.600]  в виду пусть у меня есть вот такой вот какой-то граф диктуйте какие чиселки ваш любимая 3 4 5 6
[24:34.600 --> 24:45.680]  1 2 на хорошо смотрите предположим что я пустил некоторый поток вот поэтому своему графу пока
[24:45.680 --> 24:51.840]  вот не смотрю симметризацию ничего а ну что я могу сделать но давайте я предположим сделаю
[24:51.840 --> 25:02.840]  следующее здесь я пущу один здесь один вот сюда это один беру есть мне будет один а еще я пущу не
[25:02.840 --> 25:12.840]  знаю здесь я захотел не полностью его пустить например а вот два два два вот так что у меня
[25:12.840 --> 25:17.800]  будет здесь с точки зрения остаточной сети смотрите статочная сеть будет выглядеть
[25:17.800 --> 25:38.840]  следующим образом так так так вот смотрите тех предыдущих я во-первых вычитают те потоки
[25:38.840 --> 25:45.880]  которые уже идут поэтому у меня здесь будет два здесь будет 4 здесь будет 0 и фактически этого
[25:45.880 --> 25:58.720]  ребра как будто бы нет в моем уже графе здесь будет 1 здесь будет 15 4 2 но кроме того я пускаю
[25:58.720 --> 26:05.320]  обратные потоки с какими-то конкретными значениями если у меня было в одну сторону один то я пускаю что
[26:05.320 --> 26:12.920]  у меня в обратную сторону двигается если у меня было вот в ту сторону тоже один я вот в эту сторону
[26:13.880 --> 26:27.240]  если у меня здесь было два то я в обратную сторону делаю два у меня это выглядит вот так вот и вот это
[26:27.240 --> 26:34.400]  будет называться как раз той самой остаточной сетью то есть мы с вами просто берем а строим нашу
[26:34.400 --> 26:39.760]  симметризованный граф и вот когда мы ставили там отрицательные чиселки это как бы одно один
[26:40.240 --> 26:44.760]  второй вариант давайте строить прямо остаточную сеть и как будто бы можем пускать что-то назад
[26:44.760 --> 26:49.880]  чем это нам помогает это нам помогает просто работать действительно положительными числами
[26:49.880 --> 26:57.820]  часть всего они целые потому что с не целыми очень сложно работать spoiler здесь но в тоже
[26:57.820 --> 27:02.480]  время у нас вот есть этот остаточная сеть где мы можем еще пробовать искать пути вот
[27:02.480 --> 27:06.680]  будем искать пути будем пробовать что-то переделывать будем запускать новые потоки
[27:06.680 --> 27:12.560]  и будем опять что-то делать. Вот. Это называется вот той самой остаточной сетью. Понятно?
[27:12.560 --> 27:20.280]  Следующий слайд. Какие есть две вещи про остаточную сеть и, в принципе,
[27:20.280 --> 27:27.040]  про транспортную сеть, которая у вас есть? Пусть у нас есть некоторый поток в g, а h – это
[27:27.040 --> 27:35.160]  некоторый поток в нашей остаточной сети gf. Тогда, если я беру поток с вами из действительности,
[27:35.160 --> 27:41.800]  из своей транспортной сети, плюс добавляю поток некоторые в остаточной сети, то сумма этих
[27:41.800 --> 27:48.400]  потоков является потоком в g. Причем сам по себе этот поток, он может разбиваться. То есть,
[27:48.400 --> 27:52.600]  вот этот вот модуль, грубо говоря, выкидывается. Суммарный поток, он будет равен сумме этих потоков.
[27:52.600 --> 28:07.800]  Почему так сложно? Почему я не мог, к примеру, сказать следующее? Как вы думаете, почему я не
[28:07.800 --> 28:12.720]  мог сказать, ну пусть у меня поток f – это в g, пусть у меня h – это поток в g,
[28:12.720 --> 28:34.520]  почему я не могу сказать, что f плюс h – это поток в g? Ну ладно, почему это не так?
[28:34.520 --> 28:45.080]  Может. Смотрите, в действительности, как бы не забывается транспортная сеть,
[28:45.080 --> 28:50.160]  называется просто вот эти числа, поставленные, ну мы ставим их на ребра, они между парами сидят.
[28:50.160 --> 29:01.600]  Ну, представьте следующий случай. У меня здесь вершина, здесь 1. Согласны, что поток 1 является
[29:01.600 --> 29:12.400]  здесь нужным мне. Правда? Согласны, что поток 1 является потоком здесь. Но вот поток 2, кажется,
[29:12.400 --> 29:21.960]  не подходит сюда. Правда? Что-то в этом есть, правда? Какая-то здесь изюминка скрытая. Нужно
[29:21.960 --> 29:28.080]  подумать, размыслить, вечером выпить чаю и вот пофилософствовать. Но в действительности, как бы,
[29:28.080 --> 29:33.760]  вот это нам не подходит. Но если мы говорим про остаточную сеть, что у меня h именно в остаточной
[29:33.760 --> 29:40.000]  сети, тогда в этом случае мы говорим, что вот это уже будет правдой. Как это проверить? Проверить
[29:40.000 --> 29:45.360]  все достаточно просто. Давайте сложим эти два потока и проверим три свойства, которые у нас
[29:45.360 --> 29:50.360]  есть. То есть вот определение у нас состоит просто из трех свойств, которые нам необходимы. Первое,
[29:50.360 --> 29:57.160]  мы говорим, что для любой вершины v и u это должно являться потоком. То есть оно, давайте я буду
[29:57.160 --> 30:04.200]  чуть-чуть здесь писать, повторять вот то, что там написано. Чтобы вам было проще.
[30:04.200 --> 30:19.840]  Вот. А что я говорю здесь? Я говорю здесь следующее, что для любой вершины v и u. Как
[30:19.840 --> 30:33.680]  звучало первое свойство? Кто помнит? Нет, это не первое свойство. Давайте вот отталкиваемся
[30:33.680 --> 30:41.560]  назад. Вот идем. Там было сказано следующее, что у нас поток из u в v равен минус потоку из v в u.
[30:41.560 --> 30:48.440]  Но обратная симметрика. Вот в симметризованном потоке. Мы ввели же это понятие, правда? Вот.
[30:48.440 --> 30:56.400]  Ага. Вот. Тогда, поэтому возвращаемся сюда. То есть мне нужно доказать, что вот это вот есть
[30:56.400 --> 31:08.320]  обратное. Ну, то есть я должен сказать, что у меня f от v в u плюс, ой, h от v в u. Чему равно?
[31:08.320 --> 31:24.920]  Вот вы смотрите на презентацию, не понимаете буковки или смыслов. Давайте типа со смыслами
[31:24.920 --> 31:32.240]  разберемся. Смотрите, согласны, что вот это вот тот самый поток f плюс h, правда? Вместе. Давайте
[31:32.240 --> 31:38.480]  их рассмотрим раздельно. Ну, как бы скопки-то могу эти глобальные снять, правда? Вот. Получаю это
[31:38.480 --> 31:44.960]  просто два потока f от v в u плюс h от v в u. Согласны, что вот это является потоком и вот это является
[31:44.960 --> 31:53.560]  потоком? Логично. Значит, для них работают те самые свойства, которые были. То есть я говорю,
[31:53.560 --> 32:04.640]  что это минус f от u v минус f, ой, h от u v. Ну, теперь, смотрите, я выношу этот минус и получаю здесь
[32:04.640 --> 32:19.480]  f от u v плюс h от u v. Вот. То есть, смотрите, вот это равно минус вот это. Потоки, первое
[32:19.480 --> 32:24.880]  свойство, вот это доказано, которое у нас есть. За вторым свойством нам нужно доказать, что у
[32:24.880 --> 32:32.040]  нас он не больше, чем пропускная способность. Как это сделать? Почему это не больше, чем пропускная
[32:32.040 --> 32:53.960]  способность? Так. Ну, вот там вот такая формула. f равно c минус f. Фактически это то, что у меня
[32:53.960 --> 33:09.800]  написано h от u v, равняется c минус f от u v. Согласны? Вот. Ну, на самом деле, это поток меньше
[33:09.800 --> 33:17.240]  либо равно. Да, у нас же это поток. Тут если бы c стояло, то да. Поток не больше. Ну, вот. Перенесите
[33:17.240 --> 33:23.280]  это сюда, получится меньше либо равно c. Работает, работает. Отлично. И последнее, что у нас есть,
[33:23.280 --> 33:30.840]  что для левых вершин, которые не являются стоком и истоком, мы говорим что? Что сумма всего потока
[33:30.840 --> 33:37.880]  равна нулю. Ну, давайте эту f плюс h, типа, возьмем какой-то вершины v, как это разбивается? Ну,
[33:37.880 --> 33:43.640]  мы возьмем поток f, возьмем поток h. Ну, мы говорим, что это и там, и там является потоком, поэтому это
[33:43.640 --> 33:52.120]  там ноль, и там ноль, сумма нуля и ноль. Понятно? То есть, вот это правда. Вы должны запомнить следующее,
[33:52.240 --> 33:57.120]  что если вы хотите добавить какой-то поток, то в этом случае вы смотрите на остаточную сеть,
[33:57.120 --> 34:04.360]  и в этой остаточной сети ищите какой-то путь и добавляете его к первому потоку, который есть. И
[34:04.360 --> 34:11.160]  тогда у нас все хорошо. Про разность потоков, аналогичная ситуация почти что. Мы говорим,
[34:11.160 --> 34:19.480]  что если у нас есть два потока v, каких-то, тогда их разность лежит потоком в остаточной сети. То
[34:19.480 --> 34:25.160]  здесь ситуация чуть-чуть наоборот. Мы должны взять два потока из обычной сети транспортной,
[34:25.160 --> 34:31.600]  тогда их разность будет лежать в остаточной сети. Окей? Доказывается, полностью аналогично,
[34:31.600 --> 34:38.120]  ничего не меняется. Давайте дальше. Ну и теперь мы переходим к первому алгоритму. Алгоритм
[34:38.120 --> 34:43.320]  Фордов-Халкерсона. Он работает вот ровно на тех леммах, которые мы сейчас с вами озвучили.
[34:43.320 --> 34:48.520]  Пусть у нас в начале поток равен нулю. Ну, то есть у нас просто существует транспортная сеть,
[34:48.520 --> 34:54.520]  у нас есть остаточная сеть, которая совпадает с транспортной сетью. Согласны? Вот ровно такая же.
[34:54.520 --> 35:03.000]  Давайте в этой остаточной сети найдем какой-то путь. Любой. Как можно найти путь? Ну DFS вам
[35:03.000 --> 35:10.080]  в помощь. Давайте DFS, найдем какой-то путь из S в T. Это вот проход. Не знаю, типа вот,
[35:10.080 --> 35:18.160]  смотрите вы куда-нибудь, типа на какой-нибудь корпус, вы хотите туда дойти, вот вы как будете идти?
[35:18.160 --> 35:24.240]  Ну вот смотрите, ну как-то вот по дорожкам идете. Вы не думаете про кратчайшие пути, хотя вы думаете
[35:24.240 --> 35:28.640]  немножко про кратчайшие пути, но все-таки простраиваете маршрут просто по видимым каким-то
[35:28.640 --> 35:35.400]  элементам. Вряд ли вы пойдете типа вот так вот по диагонали через дорогу, когда едут машины.
[35:35.400 --> 35:43.320]  Не прикольно будет, правда? Вот. Поэтому здесь в действительности мы с вами находим какой-то
[35:43.320 --> 35:50.920]  путь. И дальше, так как мы нашли этот путь в нашей остаточной сети, давайте пустим там максимальный
[35:50.920 --> 35:57.640]  поток по этому пути, то есть минимальное ребро возьмем. И так как это является потоком в остаточной
[35:57.640 --> 36:06.680]  сети, то я его могу добавить в свой основной поток. Согласны? Ну вот по предыдущей лейме как раз.
[36:06.680 --> 36:14.600]  Ну и все. После этого давайте повторим еще раз. Мы обновили остаточную сеть, мы получили с вами
[36:14.600 --> 36:20.120]  новую транспортную сеть и опять повторяем. И повторяем до тех пор, пока мы находим тот самый
[36:20.120 --> 36:33.280]  путь в нашей остаточной сети. Понятно пока как это выглядит? Хорошо. Вот этот путь сам по себе,
[36:33.280 --> 36:40.160]  который у нас есть, он является дополняющим путем. Такой вот дополнительный поток, грубо говоря,
[36:40.160 --> 36:46.840]  который вы ищете. И что есть интересное? Есть проблема с этим алгоритмом следующая, что она
[36:46.840 --> 36:54.840]  будет зависеть от максимального потока. Потому что здесь, ну как бы как вы ищете вот эти вот пути,
[36:54.840 --> 37:01.160]  оно может искать как раз таки и проходить через этот максимальный поток. То есть мы каждый раз вот
[37:01.160 --> 37:06.880]  будем вот впихиваться и делать. Максимум, ну то есть самый худший случай, когда мы по единичке
[37:06.880 --> 37:13.400]  добавляем какой-то в наш поток. А если вдруг вас кто-нибудь спросит, не знаю, ночи разбудит его и
[37:13.400 --> 37:20.480]  спросит, а приведите мне контрпример для алгоритма Форда Фалкерсона, когда он работает очень долго,
[37:20.480 --> 37:34.440]  что вы должны ответить? Мы уже с вами рисовали такой граф.
[37:34.440 --> 37:54.680]  Представьте, что не знаю, тут 10 шестой, 10 шестой, 10 шестой, 10 шестой, один. Я буду вот так схожу один,
[37:54.680 --> 38:02.120]  вот так схожу один, вот так схожу один, вот так схожу один. И буду бесконечно это делать,
[38:02.120 --> 38:08.080]  по сути, ну 10 шестой раз, точнее, 2 на 10 шестой. Потому что я буду выбирать вот, ну как бы не оптимальные
[38:08.080 --> 38:14.520]  пути. Сначала я пойду вот так, потом у меня в остаточной сети появится ребро обратно один,
[38:14.520 --> 38:21.440]  согласны? А тут будет ноль. Я пойду в обратную сторону, вот так один. И так я буду повторять,
[38:21.440 --> 38:26.680]  повторять, повторять, повторять постоянно. И вот это является, по сути, контрпримером
[38:26.680 --> 38:32.880]  к алгоритму Фалкерсона. В зависимости от того, как вы ищете этим DFS. DFS же в любую сторону
[38:32.880 --> 38:39.720]  ходит. И для него не важно, мы ищем какой-то путь, и не крочайший, например. Согласны? Вот из-за этого у
[38:39.720 --> 38:49.040]  нас возникает эта проблема. Поэтому здесь эта работа за O от E умножить на F max. Откуда E получилось?
[38:49.040 --> 39:09.160]  DFS. Мы DFS запускаем много-много раз. И все. Окей? Тя проблема в том, что это не полимиальный алгоритм
[39:09.160 --> 39:14.360]  сам по себе. Что это означает? Это означает, что он не зависит от входящих значений, он зависит от
[39:14.360 --> 39:20.240]  результата. Мы не можем предсказать, сколько это будет работать. Поэтому алгоритм Форда Фалкерсона
[39:20.240 --> 39:29.720]  как бы не то чтобы самый-самый крутой, но он рабочий. Вот. Перелистывайте дальше. Для того, чтобы
[39:29.720 --> 39:35.280]  доказать, что алгоритм Форда Фалкерсона работает, сам по себе нам нужна некоторая теорема Форда
[39:35.280 --> 39:41.920]  Фалкерсона, которая звучит следующим образом. То есть мы должны доказать корректность. Как это
[39:41.920 --> 39:49.440]  доказать? Ну давайте мы скажем, что наш поток будет максимален тогда и только тогда, когда в
[39:49.440 --> 39:57.160]  остаточной сети у нас нет дополняющего пути. То есть мы не можем найти путь из S в T. Ну как бы
[39:57.160 --> 40:04.440]  давайте рассуждать в одну сторону. Пусть у нас есть максимальный поток в нашей транспортной сети.
[40:04.440 --> 40:14.360]  Вот это F. Хорошо. Допустим, что у нас есть какой-то дополняющий путь в нашей остаточной сети. Вот он
[40:14.360 --> 40:21.120]  есть и его размер больше нуля, потому что мы его нашли. Отлично. Тогда по лиме потоков я говорю,
[40:21.120 --> 40:29.040]  что F, который у нас является максимальным плюс H, это поток в G. Мы же доказывали с вами это,
[40:29.040 --> 40:37.920]  доказывали отдельно. А значит F не был максимальным. Беда. Противоречия, к которым мы пришли. Теперь
[40:37.920 --> 40:44.640]  в обратную сторону. Пусть у нас есть некоторый максимальный поток. Мы говорим, что в GF нет
[40:44.640 --> 40:53.760]  дополняющего пути. Вот у нас есть этот максимальный поток. Хорошо. Какой-то, который не равен нашему F.
[40:53.760 --> 41:00.080]  Тогда в этом случае мы говорим, что Fmax-F, вот максимальный, который существовал в нашем G, пусть он не
[41:00.080 --> 41:07.160]  такой, то он больше либо равен нуля. И по разности, по лиме разности этих потоков мы говорим,
[41:07.160 --> 41:13.080]  что они просто сами вычитаются друг из друга, они больше либо равны нуля. То есть Fmax-F больше
[41:13.080 --> 41:21.720]  либо равен нуля. Это первое мое предположение. Отлично. Но мы с вами знаем, что в GF нету дополняющих
[41:21.720 --> 41:28.640]  путей. Что это само по себе означает? Это означает следующее, что я не могу провести ни одно h,
[41:28.640 --> 41:34.560]  которое мне необходимо. И вот в лиме разности путей мы говорили, что разность потоков в нашем
[41:34.560 --> 41:41.880]  транспортной сети, она создает поток в остаточной сети. Если потока в остаточной сети нет, значит он
[41:41.880 --> 41:51.120]  равен нулю. Меньше нуля. Ну вообще равен нулю. Значит у нас эти потоки равны. Это алгоритм Эдманса
[41:51.120 --> 42:01.640]  Карпа. Аналогичен тому, что у нас происходит с алгоритмом Форда Фалкерсона. Кроме одного факта,
[42:01.640 --> 42:15.160]  какого? У нас вместо DFS становится BFS. Все. Буковку поменяли, создатель поменялся. И как бы алгоритм
[42:15.160 --> 42:19.880]  сам поменялся, теперь это новый алгоритм. И удивительный факт следующий. Если мы с вами
[42:19.880 --> 42:27.600]  будем запускать не DFS и искать рандомные пути, а BFS, то в этом случае у нас с вами будет все работать
[42:27.600 --> 42:34.240]  неплохо в этом случае. И оно будет работать полимиально. Мы будем работать с вами за VE квадрат.
[42:34.240 --> 42:41.080]  И это мы с вами сейчас будем доказывать. Все, что у нас есть. Я там тоже все чуть-чуть поехал.
[42:41.080 --> 42:50.680]  Смотрите. Следующий слайдик можно. Лемма звучит следующим образом. После каждой итерации,
[42:50.680 --> 42:59.000]  то есть шагов 1 и 2, когда мы вот ищем путь и выкидываем его из остаточных путей, длина
[42:59.000 --> 43:06.320]  кратчайших пути в смысле количество ребер, вот именно количество ребер. Не потому, что мы тут
[43:06.320 --> 43:11.480]  смотрим какие-то веса, есть ребер, ничего такого нет. Просто именно количество ребер. Оно не убывает.
[43:11.480 --> 43:19.200]  Все только возрастает. Либо остается таким же. Но как это сделать? Ну смотрите, если у меня было
[43:19.200 --> 43:24.920]  некоторое ребро в остаточной сети и я нашел поток по нему, вот я нашел вот здесь поток,
[43:24.920 --> 43:31.000]  что у меня произойдет с транспортной сетью в этот момент? То есть я вот нашел какое-то
[43:31.000 --> 43:35.560]  ребро, по которому я нахожу этот путь. У меня здесь станет ноль, и я убираю это
[43:35.560 --> 43:44.040]  ребро, правильно? Какое-то минимальное. И пускаю в обратную сторону. Вот. То есть фактически у меня
[43:44.040 --> 43:51.560]  два случая возможны. Первое, я беру и убираю ребро. Второе, я добавляю ребро обратное. Согласны?
[43:51.560 --> 43:55.720]  Вот. Обратное относительно того пути, которое было.
[43:55.720 --> 44:14.600]  Если мы его убираем, мы обязаны его добавить. А это не совсем всегда правда. Смотрите. Вот у
[44:14.600 --> 44:21.440]  меня видите, вот здесь ребро ноль, его пока нет. Вот. А представьте следующую картину. Ну вот у меня
[44:21.440 --> 44:30.880]  вот здесь вот четыре. Вот здесь у меня было ноль. Было бы. У меня не было этого ребра. Вот только я
[44:30.880 --> 44:38.040]  пустил сюда, у меня добавилось ребро. Вот. То есть оно просто взяло и само добавилось. Не обязательно,
[44:38.040 --> 44:42.680]  что я должен был убрать ребро. У меня же остаточная сеть, она первоначально равна транспортной сети,
[44:42.680 --> 44:48.560]  всей которой было. Поэтому максимум можем вот такие вот два случая разобрать. И два случая
[44:48.560 --> 44:57.560]  смотреть. Поехали дальше. Нам нужно показать, что при удалении или добавлении ребер мы не могли
[44:57.560 --> 45:04.040]  взять и уменьшить кратчайшие пути. Но как это сделать? Ну если мы удалили ребро, вот мы нашли
[45:04.040 --> 45:09.680]  какой-то кратчайший путь. Мы же BFS-ом ищем кратчайшие пути. Если мы нашли с помощью этого кратчайшего
[45:09.680 --> 45:19.440]  пути. Какое-то... Мы нашли какой-то кратчайший путь и удалили ребро из этого кратчайшего пути.
[45:19.440 --> 45:28.040]  Согласно, что у нас не мог уменьшиться кратчайший путь. Вот у нас он был, там не знаю, из пяти ребер.
[45:28.040 --> 45:33.000]  Вот я удалил ребро и такой, а я нашел новый кратчайший путь из четырех ребер. Кажется это странно,
[45:33.000 --> 45:38.080]  потому что до этого я искал тоже кратчайший путь. Поэтому я мог его только увеличить. В случае
[45:38.080 --> 45:43.720]  добавления ребер, мы можем рассуждать чуть-чуть по-другому. Вот у нас есть некоторый путь.
[45:43.720 --> 45:56.480]  И так далее. Представьте, что я добавляю новое ребро в обратную сторону. Вот это убираю. Ну или не
[45:56.480 --> 46:02.960]  убираю, а добавляю просто. Вот. Что у меня происходит? Ну вот у меня когда добавилось какое-то новое
[46:02.960 --> 46:12.800]  ребро, у меня появилось там, не знаю, новое расстояние вот это РОС от С до В. Вот мы это делали.
[46:12.800 --> 46:21.600]  Отлично. А у меня была какая-то вершинка У, стал какая-то вершинка В. Вот. А мне нужно прийти
[46:21.600 --> 46:27.160]  в эту вершину В. Первоначально мы говорили с вами, что мы можем вот это вот ребро убрать,
[46:27.160 --> 46:32.160]  там добавить какое-то новое. То есть у нас есть предыдущий путь, оно никак не влияет. Согласны?
[46:32.160 --> 46:41.040]  Вот. Поэтому здесь я могу четко и уверенно себе сказать следующее. Что у меня при добавлении было
[46:41.040 --> 46:50.320]  так, не знаю, РОС от С до В до У. Штрих. Тут РОС штрих. Плюс один. В чем плюс один? Вот это еще одно
[46:50.320 --> 46:56.640]  ребро, которое у меня было. Согласны? Вот. Отлично. Вот это получилось. Согласны ли вы,
[46:56.640 --> 47:05.440]  что при добавлении обратного ребра, вот это РОС от С до У, не могло тоже уменьшиться. Вот. Поэтому
[47:05.440 --> 47:11.840]  оно из предыдущего, я говорю, что вот это больше либо равно. Тут я так пишу криво, но как есть.
[47:11.840 --> 47:32.440]  Больше либо равно, чем РОС от С. У плюс один. Вот. Ага. Стриховая, да, это когда, да, РО. Вдруг он есть
[47:32.440 --> 47:41.400]  вот как-то вот так. У меня же новые кратчайшие пути могли появиться. Я одно ребро убрал,
[47:41.400 --> 47:46.320]  получил новое. Одно ребро добавил, у меня получился какой-то новый граф, там могло быть другое что-то.
[47:46.320 --> 48:06.960]  Так вот, вопрос. А, я понял. Вот это правда это или нет? А что там будет?
[48:16.320 --> 48:22.240]  То есть ты хочешь сказать, что здесь будет больше? Больше. А меньше могло быть хоть раз?
[48:22.240 --> 48:39.840]  Сейчас спроси. Меньше не могло быть. А больше? Да ладно. Кратчайший путь мог. Или не мог? Да.
[48:47.320 --> 48:52.560]  Да, здесь смотрите, вот это вот равенство, оно возникает в случае, если мы не убираем это
[48:52.560 --> 48:56.000]  ребро. Мы говорили только про добавление, добавление может произойти без убирания.
[48:56.000 --> 49:06.520]  Да. Вот. Поэтому оно так. Окей. В этом случае мы говорим, что ну мы же только это ребро добавили,
[49:06.520 --> 49:14.920]  правильно? Все остальное не трогали. Поэтому я говорю, что это больше, чем РОС от С. У плюс один. Вот. А почему
[49:14.960 --> 49:29.160]  это равно РОС от С. В плюс один плюс один? Или точно ли это так? Вот у меня есть РОС от С. У и вот у меня
[49:29.160 --> 49:40.360]  там написано следующее. РОС от С. В плюс один плюс один. Что вот это вот равно. А? В действительности мы можем
[49:40.360 --> 49:44.120]  сказать следующее. Смотрите, у нас кратчайший путь, вот когда мы не добавляли никакие ребра,
[49:44.120 --> 49:52.600]  проходил через У в В. Правильно? Вот последний шаг такой был. Вот это РОС от С. У плюс один. Оно что сделает?
[49:52.600 --> 50:04.040]  Оно фактически добавляет новое ребро. Ну вот. А действительно следует плюс один? Не надо. Вот.
[50:04.040 --> 50:11.920]  Просто это будет больше, чем РОС от С. В. То есть мы все равно увеличиваем, не убиваем с точки зрения вот
[50:11.920 --> 50:17.640]  этого кратчайшего пути. Нам главное следующее, что мы здесь получили. Мы получили с вами следующее,
[50:17.640 --> 50:28.360]  что РОС от С. В. Оно будет больше либо равно, чем РОС от С. В. Вот РОС, которое новое, здесь старое.
[50:28.360 --> 50:40.040]  Понятно? Окей. Смотрите. Давайте поймем, за сколько работает алгоритм advanced carp. Как нам это сделать? Ну,
[50:40.080 --> 50:48.840]  для начала мы введем такое понятие, как критическое ребро. Что такое критическое насыщение? Ну,
[50:48.840 --> 50:57.200]  представьте, не знаю, что у вас есть некоторые от У до В. Не знаю, там, какой-нибудь пропускной
[50:57.200 --> 51:04.440]  способностью С. И вы пустили поток С. Вот это называется критическим. Вы же нельзя. Вот. И мы
[51:04.440 --> 51:10.200]  говорим с вами следующее. Вот в данной теореме Эдмонса Карпа, что в процессе работы алгоритма,
[51:10.200 --> 51:18.680]  каждое ребро может стать критическим не более чем в пополам раз. Интересный такой вот факт,
[51:18.680 --> 51:26.440]  замечен был. Что это означает само по себе? Давайте с вами думать. Вы же согласны, что я могу пустить
[51:26.440 --> 51:31.520]  максимальный поток по ребро, а потом пустить в обратную сторону, потом опять пустить и так далее.
[51:31.520 --> 51:37.800]  Вот я могу его вот так вот постоянно критически насыщать. Я говорю следующее, что каждое ребро я вот
[51:37.800 --> 51:44.240]  так вот критически буду насыщать не больше, чем в пополам раз. Почему это так? Ну, смотрите,
[51:44.240 --> 51:52.040]  пусть у нас некоторое ребро стало критическим, а критическим оно стало в какой-то момент,
[51:52.040 --> 51:56.720]  когда вот мы нашли вот этот кратчайший путь. И мы говорим, что в этом случае у нас Роатес У
[51:56.720 --> 52:11.920]  равно Роатес В плюс 1. У нас здесь вот есть некоторая вершинка В, есть У. И мы вот так вот типа
[52:11.920 --> 52:18.680]  делаем. Вот у нас здесь вот это ребро становится критическим. Мы находим БФС, поэтому находим
[52:18.680 --> 52:27.720]  вот эти кратчайшие пути. То есть Роатес У равно Роатес В плюс 1. Чудесно. А оно вернется вот данное
[52:27.720 --> 52:36.440]  ребро в нашу остаточную сеть в каком случае? Только в одном. В случае, если мы с вами... Что сделаем?
[52:36.440 --> 52:47.400]  Или ничего не сделаем? В случае, если мы направим поток в другую сторону. То есть мы его переноситили,
[52:47.400 --> 52:52.680]  мы убрали его из остаточной сети. Мы должны сделать поток в остаточной сети теперь в обратную
[52:52.680 --> 53:01.480]  сторону данного ребра. То есть в случае, когда у нас вот это ребро УВ, не В, а УВ, то есть в обратную
[53:01.480 --> 53:12.920]  сторону, пойдет в какой-то кратчайший путь. Согласны? Ну потому что я запущу БФС. Правильно? Отлично.
[53:12.920 --> 53:21.200]  Вот. Ну оно будет лежать на каком-то кратчайшем пути. То есть у нас вот будет вот эта новая
[53:21.200 --> 53:28.520]  остаточная сеть. Мы делаем этот новый кратчайший путь. Я говорю, что Роатес В...
[53:28.520 --> 53:42.360]  Почему он равен Роатес У плюс 1? Почему так? Потому что у нас больше нет вот этого критического
[53:42.360 --> 53:52.080]  ребра, и у нас есть только в другую теперь сторону. Согласны? Отлично. А вот что-то для У поменялось или нет?
[53:52.080 --> 54:03.560]  Ну максимум, что могло быть при удалении ребра, что увеличится кратчайший путь. Согласны? Поэтому
[54:03.560 --> 54:17.520]  это больше либо равно, чем Роатес У из предыдущей остаточности. Согласны? Так, а что нам это дает?
[54:17.520 --> 54:28.800]  Или пока ничего не дает? Понятно ли, откуда вот это хорошее утверждение появилось?
[54:28.800 --> 54:54.320]  Давайте с вами продолжать. А? Еще раз? Одно действие. Ну, типа того. Ну, вот смотрите, мы с вами
[54:54.320 --> 55:01.840]  получили следующее. Чили два пункта. Каких мы получили с вами два пункта? Ну, для начала мы с
[55:01.840 --> 55:20.520]  вами говорим, что Роатес У равно Роатес В один и Роатес Ро штрихатес В, но больше либо равно,
[55:20.520 --> 55:31.560]  чем Роатес У плюс один. Ага. Согласны? Ну, как бы это то, что мы с вами уже имели. Теперь
[55:31.560 --> 55:39.000]  смотрите, я, если я пустил что-то обратно, у меня возвращается это ребро. Согласны? Ну, вот это вот
[55:39.000 --> 55:44.400]  ребро, которое я отменил. Я пустил назад единичку, значит, сюда будет хотя бы единичка. Новое ребро
[55:44.400 --> 55:54.000]  появится. А в каком случае оно опять станет насыщенным? Критическим. Когда мы опять кинем
[55:54.000 --> 55:59.880]  типа максимальный поток по этому ребру, правильно? В этом случае я повторю ровно те же действия,
[55:59.880 --> 56:08.280]  которые делают здесь. Вот ровно те же действия. И что я с вами получу? Я получу следующее, что Ро
[56:08.280 --> 56:18.840]  два штриха от Су, оно будет больше либо равно, чем Роатес У плюс два. Потому что тут было плюс один,
[56:18.840 --> 56:26.680]  я сделаю аналогичную ситуацию, получу еще и еще одно плюс один. Ага. Буду так вот увеличиваться.
[56:26.680 --> 56:53.960]  Вот. Из этих двух пунктов Роатес В, да, но мы ищем до У. То есть мы смотрели до какой-то
[56:53.960 --> 57:00.640]  конкретной вершинки У. И брали, что перед ней есть вершина В. Вот. Ну как бы в действительности там
[57:00.640 --> 57:05.560]  нужно применить просто часть СЛЕМ, часть вот этих утверждений, которые у нас здесь есть. Мы получим,
[57:05.560 --> 57:12.840]  что у нас будет плюс два. Когда она станет плюс два, что это означает? Что у нас между критическим
[57:12.840 --> 57:19.840]  моментом одним и вторым увеличивается кратчайший путь на два минимум. Согласны? Какой максимальный
[57:19.840 --> 57:34.720]  путь по длине? Количество ребер может быть. В. Ну В-1, если быть точнее. Ну это когда у нас просто
[57:34.720 --> 57:47.280]  вот такая вот цепочка. Кратчайшие пути. Роа это же кратчайшие пути? Ну кратчайший путь,
[57:47.280 --> 58:02.080]  максимальную длину какую имеет? В-1. Ну расстояние между вершинами не может быть больше, чем В. В-1.
[58:02.080 --> 58:08.320]  Отлично. Ну значит мы делим пополам, потому что у нас плюс два все время делает. Получаем В пополам.
[58:08.320 --> 58:15.600]  То есть В пополам раз мы делаем каждое ребро критически максимум. Что мы можем делать? Что
[58:15.600 --> 58:23.800]  нам это даст? Как вы думаете? Ограничение на критическое переполнение. Вот то, что у нас есть. Да,
[58:23.800 --> 58:31.400]  в действительности у нас после каждой итерации, когда мы будем искать BFS-ом какой-то путь, у нас
[58:31.400 --> 58:41.040]  каждый раз какое-то ребро становится критическим. Правильно? Вот. Всего ребер у нас Е. Каждый из
[58:41.040 --> 58:46.320]  них может быть критическим не более, чем В пополам раз. Ну то есть у нас уже Е на В пополам раз
[58:46.320 --> 58:55.880]  итерации. И в каждую эту итерацию мы запускаем BFS. BFS работает за О от Е. Ну получаем что? Получаем В Е
[58:55.880 --> 59:08.160]  квадрат. Ага. Есть ли тут вопросы? Нет. Теперь смотрите, у нас с вами осталось 14 минут и у нас с
[59:08.160 --> 59:14.960]  вами остался алгоритм Диницы. Вот. А, ладно, давайте с вами чуть-чуть поговорим про алгоритм Диницы. Я
[59:14.960 --> 59:19.640]  попрошу семинаристов с вами ее разобрать, вот это все написать. На самом деле, все алгоритмы пишут
[59:19.640 --> 59:25.680]  достаточно просто. Там нет никаких проблем в том, чтобы это найти. Смотрите, в чем суть алгоритма
[59:25.680 --> 59:30.560]  Диницы? Вы там пролесните до алгоритма Диницы, где написано в чем проблема Эдмонса Карп. Смотрите,
[59:30.560 --> 59:37.320]  мы каждый раз в Эдмонсе Карпе ищем BFS-ом путь, убираем его, потом ищем новый путь. Кажется,
[59:37.320 --> 59:47.560]  что это не всегда имеет смысл. Почему? Потому что, смотрите, а давайте с вами чуть-чуть по-другому
[59:47.560 --> 59:58.040]  поступим. Поступим следующим образом. У нас есть некоторая вершина и стока. И что делает BFS?
[59:58.040 --> 01:00:05.160]  BFS же находит, по сути, все вершины, которые находятся на расстоянии 1, правда? Потом от них
[01:00:05.160 --> 01:00:15.760]  находят еще на расстоянии 2. И вот он фактически строит вот такие вот слои, которые шаг за шагом,
[01:00:15.760 --> 01:00:26.200]  какое-то там, не знаю, X, они в конце будут все смотреть в наш исток. Согласны? Вот эти слои
[01:00:26.200 --> 01:00:32.120]  будут как-то между собой связаны. Зачем нам выкидывать по одному пути из этого всего,
[01:00:32.200 --> 01:00:38.680]  если я могу найти разные пути между этими слоями? Тут вершинка, не знаю, пойду вот так,
[01:00:38.680 --> 01:00:46.080]  здесь я пойду вот так и так далее. Давайте я сразу буду все пути, которые у меня есть,
[01:00:46.080 --> 01:00:53.840]  переделывать. И в этом случае я возьму и переделаю это, и получу новую статичную сеть,
[01:00:53.840 --> 01:00:59.960]  для которой опять построю свои слои. И это будет делать каждый раз. Смотрите, я буду с самого
[01:00:59.960 --> 01:01:06.240]  начала брать и вот эти вот все пути различные использовать. Можно так делать? Почему нет?
[01:01:06.240 --> 01:01:15.320]  Вот. И вот мы строим эту слоистую сеть, и дальше что мы делаем? Смотрите, ищем все эти дополняющие
[01:01:15.320 --> 01:01:25.200]  пути в нашей слоистой сети из S в T, и обновляем наш поток F. И только после этого, когда мы делаем,
[01:01:25.280 --> 01:01:33.320]  мы обновляем на GF и заново строим вот эту слоистую сеть. То есть мы обновили все слои,
[01:01:33.320 --> 01:01:37.480]  которые у нас есть, и только после этого, когда нет уже нового пути, мы с вами это делаем.
[01:01:37.480 --> 01:01:45.840]  То есть мы будем запускать меньшее количество BFS, чем в Edmund C. Carpe. Но все равно будем
[01:01:45.840 --> 01:02:04.720]  убирать каждый путь по-своему. Окей? Да. А меньше BFS? Нет, нет, нет, нет, нет. У нас есть
[01:02:04.720 --> 01:02:12.640]  некоторые пути вот здесь. Мы с BFS находим эти все пути. Правда? Вот я нашел путь, выкинул его,
[01:02:12.800 --> 01:02:17.320]  нашел путь, выкинул его и так далее. У нас в этой слоистой сети мы можем сказать,
[01:02:17.320 --> 01:02:25.000]  что вот эта вершина с этой, с этой сюда приводит, это с этой, с этой, с этой и так далее. Между 1 и 2
[01:02:25.000 --> 01:02:31.520]  слоистой сети, мне главное найти ребро, и это легко сделать, между 2 и 3, между 3 и 4, между 4 и 5
[01:02:31.520 --> 01:02:40.840]  и так далее. И вот итог будет такой. Подождите, мы же смотрим на конкретную вершину и смотрим на путь от нее
[01:02:40.840 --> 01:03:01.320]  ее в начале в BFS. Нет? Ну вот, не совсем, не совсем. Для того, чтобы найти какой-то
[01:03:01.320 --> 01:03:06.920]  конкретный путь, ты всегда заново запускала BFS в Эдмонсе Карпе и перестраивала свою
[01:03:06.920 --> 01:03:13.280]  остаточную сеть. А здесь ты ее фиксируешь и убираешь путь, фиксируешь,
[01:03:13.280 --> 01:03:17.160]  убираешь путь, фиксируешь, убираешь путь, запоминаешь, ты заново перестраиваешь
[01:03:17.160 --> 01:03:26.200]  остаточную сеть. То есть, ты вот эти слои оставляешь. Ну, фактически, да, только
[01:03:26.200 --> 01:03:29.600]  запоминаем, что мы их убрали, значит, слоистая сеть и новая где-то должна у
[01:03:29.600 --> 01:03:35.360]  вас хранится. И вот пока по этой слоистой сети вы можете идти, все отлично.
[01:03:35.360 --> 01:03:41.680]  Как только нет, заново строите и смотрите. Вот, здесь важные вопросы следующие.
[01:03:41.680 --> 01:03:46.080]  К корректности здесь все просто, оно все работает на тех же теоремах, которые были
[01:03:46.080 --> 01:03:51.200]  до этого. Тут ничего сложного не будет. Вопрос следующий. Сколько раз нужно будет
[01:03:51.200 --> 01:03:55.160]  перестраивать эту слоистую сеть? Сколько времени будет занимать вообще поиск пути
[01:03:55.160 --> 01:03:59.560]  в слоистой сети? То есть, вот то, что ты сейчас задавала, как раз-таки BFS мы будем
[01:03:59.560 --> 01:04:04.400]  опять запускать или нет? И сколько всего путей можно найти в слоистой сети? Ну, как бы,
[01:04:04.400 --> 01:04:09.560]  давайте это все смотреть. На самом деле, сколько раз перестраивать? Не больше, чем
[01:04:09.560 --> 01:04:15.480]  в раз. Сколько времени занимает поиск пути по слоистой сети? Не больше, чем в
[01:04:15.480 --> 01:04:21.680]  а сколько всего путей можно найти в какой-то слоистой сети? Не больше, чем E. Все просто.
[01:04:21.680 --> 01:04:29.000]  Ну, как бы, первое, почему так? Потому что после каждой итерации расстояние от S до T
[01:04:29.000 --> 01:04:34.640]  увеличивает. Согласны? То есть, я выкинул что-то из слоистой сети, вот, и она у меня
[01:04:34.640 --> 01:04:38.840]  перестраивается, у меня путь должен увеличиваться. Значит, у меня максимальное
[01:04:38.840 --> 01:04:48.000]  количество увеличений в пути какое? Ну, это если все вершины выстрою. А по длине?
[01:04:48.000 --> 01:04:52.840]  В смысле или что? Так еще раз, мы же слоистую сеть сначала все обработали, все
[01:04:52.840 --> 01:04:58.040]  выкинули, только потом перестраиваем ее. Мы же не делаем это сразу в моменте. Вот,
[01:04:58.040 --> 01:05:04.880]  поэтому это первый момент, который мы видим. Поэтому здесь не больше, чем V. Второе. Сколько
[01:05:04.880 --> 01:05:10.000]  занимает поиск пути? Ну, мы просто от слоя к слою идем. Это количество слоев не больше,
[01:05:10.000 --> 01:05:16.920]  чем V. Вот, я взял тут вершину, пошел в эту вершину, пошел в эту вершину и так далее. Сколько всего
[01:05:16.920 --> 01:05:25.360]  путей? Ну, не больше, чем E. То есть, между слоем к слою не больше, чем E вершинок. Понятно? Вот.
[01:05:25.360 --> 01:05:39.800]  И тогда в этом случае мы получаем асимптотику V2E. То есть, не V2E, а V2E. Понятно? Вот это и есть
[01:05:39.800 --> 01:05:46.440]  алгоритм Диница. Что у нас есть еще? Давайте там последний слайд, последний слайд. Честно,
[01:05:46.440 --> 01:05:51.160]  не буду рассказывать сильно много про эти алгоритмы. Смотрите, что еще интересно было
[01:05:51.160 --> 01:05:55.720]  по потоку. Ну, существует еще несколько алгоритмов. Есть алгоритм, который работает с
[01:05:55.720 --> 01:06:03.720]  V-куб. И вот в 2013 году появился новый еще алгоритм, который работает с VE. Писать ли мы их будем?
[01:06:03.720 --> 01:06:10.440]  Не будем. Вот. Это такая информация для вас. Интересности всякие. Вот. Но, в принципе,
[01:06:10.440 --> 01:06:15.680]  это на сегодня, скорее всего, все. Всем хорошего дня, вечера, пока-пока.
