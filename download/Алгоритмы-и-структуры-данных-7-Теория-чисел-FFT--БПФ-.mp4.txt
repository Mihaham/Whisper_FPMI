[00:00.000 --> 00:07.880]  Давайте я напомню, что в конце сделали насчет симптотики.
[00:07.880 --> 00:11.320]  То есть, что с автомат у нас получилась такая симптотика.
[00:11.320 --> 00:17.640]  Линия, если алфавит считать константным.
[00:17.640 --> 00:24.000]  Если алфавит, ну алфавит размера, считать константой.
[00:24.000 --> 00:27.800]  Ну то есть, скажем там, то есть, наше самоодобное допущение,
[00:27.800 --> 00:29.480]  что алфавит – это маленький латинский буквы.
[00:30.480 --> 00:34.600]  Вот, тогда за длину строки мы можем построить автомат.
[00:34.600 --> 00:39.920]  Это вот следует из того, что когда мы, ну там, если
[00:39.920 --> 00:42.120]  аккуратно анализировать, сколько итераций цикловая
[00:42.120 --> 00:44.600]  каждый раз мы делаем, когда мы стрелочки перенаправляем,
[00:44.600 --> 00:46.480]  то каждое перенаправление стрелочек – это сокращение
[00:46.480 --> 00:49.360]  пути по суфсылкам до последней вершинки.
[00:49.360 --> 00:51.280]  Ну и соответственно, этот путь очень долго нельзя
[00:51.280 --> 00:53.520]  увеличивать, нельзя долго уменьшать.
[00:53.520 --> 00:56.120]  Каждое уменьшение значит, что потом мы это уменьшение
[00:56.120 --> 00:57.120]  не сделаем.
[00:57.520 --> 00:58.520]  Вот.
[00:58.520 --> 01:05.840]  Ну и соответственно, если алфавит не константа, то
[01:05.840 --> 01:08.000]  в общем-то все так же, как в боре.
[01:08.000 --> 01:10.920]  Например, мы можем сделать симпатику что-то типа n лог
[01:10.920 --> 01:13.800]  сигма, если в каждой вершинке будем хранить не массив,
[01:13.800 --> 01:14.800]  а мапу.
[01:21.800 --> 01:23.120]  На лог сигму.
[01:24.120 --> 01:27.960]  Если в каждой вершине множество переходов из нее ведущих
[01:27.960 --> 01:35.520]  будем хранить как мап из, ну там, чар в, ну нод-звездочка
[01:35.520 --> 01:38.280]  или инт в номер вершинки.
[01:38.280 --> 01:41.920]  Давайте я напишу нод-звездочка для как бы, чтобы было понятно.
[01:41.920 --> 01:42.920]  Вот.
[01:42.920 --> 01:47.840]  Ну а если повторюсь алфавит константа, то как бы это
[01:47.840 --> 01:48.840]  линейное время.
[01:49.560 --> 01:53.240]  И, например, зачем нужен сухвавтомат, помимо тех
[01:53.240 --> 01:55.920]  задач, которые я надеюсь вы рассматриваете на семинарах,
[01:55.920 --> 01:58.840]  мы можем с его помощью построить суффиксный массив за линейное время.
[02:10.840 --> 02:13.120]  Напоминаю, мы разбирали алгоритм, который делает
[02:13.120 --> 02:14.120]  за n лог n.
[02:14.120 --> 02:15.120]  Вот.
[02:15.120 --> 02:17.400]  А теперь, используя сухвавтомат, мы это можем сделать за
[02:17.400 --> 02:18.400]  линию.
[02:18.400 --> 02:20.240]  То есть явным образом его не строить, там как мы делали
[02:20.240 --> 02:23.200]  по классам эквивалентности два степенька, вот, а напрямую
[02:23.200 --> 02:24.200]  из сухвавтомата.
[02:24.200 --> 02:26.000]  То есть алгоритм очень простой.
[02:26.000 --> 02:41.020]  Ну, строим автомат для строки s, дальше сжимаем проходные
[02:41.020 --> 02:42.020]  вершины.
[02:48.400 --> 02:50.400]  Проходные не терминальные вершины.
[02:56.400 --> 02:59.520]  Вот прям так же, как мы делали в сухдереве, когда проходная
[02:59.520 --> 03:01.580]  вершина – это в которой входит одно ребро и выходит
[03:01.580 --> 03:04.880]  одно ребро, то есть как бы если направление движения
[03:04.880 --> 03:08.400]  понятно и однозначно определено, если мы в эту вершинку пришли.
[03:08.400 --> 03:13.680]  То есть здесь она, ну, одно входящее ребро и исходящее
[03:13.680 --> 03:14.680]  тоже ровно одно.
[03:14.680 --> 03:17.160]  Вот если такая картинка, то есть вершина проходная,
[03:17.160 --> 03:21.040]  что называется, проходная, то можем ее сжать и нарисовать
[03:21.040 --> 03:24.760]  просто одно длинное ребро, на котором написано конкретинация
[03:24.760 --> 03:25.760]  этих двух строк.
[03:25.760 --> 03:28.160]  А то есть если здесь была альфа, здесь была бета,
[03:28.160 --> 03:29.960]  можно просто нарисовать такое длинное ребро, на котором
[03:29.960 --> 03:30.960]  написано альфа бета.
[03:30.960 --> 03:33.960]  Конкретинация строк.
[03:33.960 --> 03:39.480]  Вот, значит, проходные вершинки сжали, а дальше у нас получится,
[03:39.480 --> 03:42.640]  ну давайте какой-нибудь, набросаю что-нибудь.
[03:47.160 --> 03:50.400]  Например, какой-нибудь такой автомат получится.
[03:50.400 --> 03:57.640]  Да, действительно, так, ну, тогда вот так нарисую.
[03:57.640 --> 04:01.400]  Значит, что-нибудь такое будет.
[04:01.400 --> 04:04.840]  Дальше, как обычно у нас все ребра, исходящие из вершины,
[04:04.840 --> 04:08.480]  отсортированы по первым символам, да, из-за того,
[04:08.480 --> 04:10.320]  что опять возникают вот эти конкретинации, то ребра
[04:10.320 --> 04:12.600]  у нас отличаются не как вот эти вот строки различные
[04:12.600 --> 04:15.240]  на этих ребрах, а первые символы у них различные,
[04:15.240 --> 04:18.160]  потому что изначально вот у них были первые символы
[04:18.160 --> 04:20.480]  различные, потом они как-то склеились как угодно, ну
[04:20.480 --> 04:23.040]  и это свойство сохранило, что первые символы у всех
[04:23.040 --> 04:24.040]  различные.
[04:24.040 --> 04:27.600]  А дальше мы запустим на этом графе лексикографический
[04:27.600 --> 04:29.920]  ДФС, но без пометок юст.
[04:29.920 --> 04:31.600]  Значит, давайте я так напишу.
[04:31.600 --> 04:48.040]  Значит, лексикографическое значит, что ребра мы рассматриваем
[04:48.040 --> 04:50.440]  в порядке лексикографического возрастания, да, если есть
[04:50.440 --> 04:52.880]  несколько переходов, то мы в первую очередь берем
[04:52.880 --> 04:55.000]  тот, у которого, на котором буквы поменьше, первые буквы,
[04:55.000 --> 04:56.680]  на котором меньше, то есть вот эти вот ребра, исходящие
[04:56.680 --> 04:59.520]  из вершины, упорядочены по первой букве, сначала
[04:59.520 --> 05:01.880]  мы используем это ребро, потом, когда рекурс вернется
[05:01.880 --> 05:05.360]  сюда, это ребро, потом вот это ребро.
[05:05.360 --> 05:07.920]  А без пометок юст, значит, ну как у нас работает обычный
[05:07.920 --> 05:08.920]  ДФС.
[05:08.920 --> 05:11.160]  ДФС, когда заходит в вершинку, помечает ее использованный
[05:11.160 --> 05:14.520]  юст, и больше юст не пытается идти, потому что в обычном
[05:14.520 --> 05:17.280]  ДФС нет смысла заходить заново в те вершины, где
[05:17.280 --> 05:18.280]  мы уже были.
[05:18.280 --> 05:21.720]  А вот здесь мы не будем эти пометки хранить и будем,
[05:21.720 --> 05:24.440]  ну как если бы мы вообще об этом не задумывались,
[05:24.440 --> 05:26.600]  будем, возможно, многократно проходить одну и ту же вершину
[05:26.600 --> 05:27.600]  много раз.
[05:27.600 --> 05:31.680]  Скажем, например, здесь, я, например, сначала пройду
[05:31.680 --> 05:34.800]  вот такой вот путь, потом у меня рекурс и вернется
[05:34.800 --> 05:36.760]  сюда и пройду вот такой вот путь.
[05:36.760 --> 05:39.360]  То есть это ребро у меня пройдется дважды, соответственно,
[05:39.360 --> 05:41.320]  эта вершина дважды, эта вершина дважды.
[05:41.320 --> 05:43.440]  И это нормально, типа так и надо.
[05:43.440 --> 05:46.240]  А в отличие от обычного ДФС, когда мы так не делаем
[05:46.240 --> 05:49.320]  и мы не ходим по ребрам многократно, здесь мы можем ходить по
[05:49.320 --> 05:50.320]  ребрам много раз.
[05:50.320 --> 05:57.280]  Ну и соответственно, в процессе этого ДФС мы посещаем
[05:57.280 --> 06:00.480]  какие-то вершинки, какие-то из них были терминальными,
[06:00.480 --> 06:03.000]  ну, например, там вот эти вот были терминальными.
[06:03.000 --> 06:05.880]  И каждый раз, когда мы посещаем терминальную вершину, мы
[06:05.880 --> 06:09.720]  знаем, какую длину пути мы сейчас преодолели.
[06:09.720 --> 06:11.880]  То есть если мы находимся в вершине, то мы знаем, каким
[06:11.880 --> 06:13.800]  путем мы в нее попали, мы знаем, сколько символов
[06:13.800 --> 06:14.800]  прочитано.
[06:14.800 --> 06:16.680]  Значит, мы знаем, в какой суффикс мы попали.
[06:16.680 --> 06:19.080]  И вот утверждается, что порядок, в который мы обходим
[06:19.080 --> 06:21.080]  все эти суффиксы, и будет порядок совмасс.
[06:21.080 --> 06:44.600]  Значит, сейчас запишу, храним прочитанную длину строки.
[06:44.600 --> 06:49.000]  Если оказались в терминальной вершине, то передной суффикс
[06:49.000 --> 06:51.200]  порядка совмасса, это вот та самая длина, которую
[06:51.200 --> 06:52.200]  мы прочитали.
[06:52.200 --> 07:07.560]  Если оказались в терминальной вершине, то вот эта вот длина,
[07:07.560 --> 07:09.240]  это есть очередной суффикс порядка совмасса.
[07:09.240 --> 07:26.080]  В порядке, который нужен в совмассиве, да?
[07:26.080 --> 07:28.760]  Нам нужен первый символ и длина, да, первый символ
[07:28.760 --> 07:29.760]  и длина только нам нужны.
[07:29.760 --> 07:36.040]  Вот, весь алгоритм, то есть это просто тупой DFS, который
[07:36.040 --> 07:37.040]  не использует юзды.
[07:37.200 --> 07:39.760]  В основном это просто DFS, который, ну вот, когда попал
[07:39.760 --> 07:41.600]  в терминальный, он написал какой-то суффикс.
[07:41.600 --> 07:44.800]  То есть почему это корректно, более-менее очевидно, потому
[07:44.800 --> 07:48.520]  что по сути, давайте раздожмем обратно все вот такие вот
[07:48.520 --> 07:53.120]  ребра, по сути мы просто обходим этот автомат без
[07:53.120 --> 07:54.120]  пометок юзды.
[07:54.120 --> 07:56.600]  В каком порядке мы обойдем все суффиксы?
[07:56.600 --> 07:58.520]  Ну понятно в лексографическом, да, потому что на каждом
[07:58.520 --> 08:01.680]  шаге мы из исходящих ребр, каждый раз выбираем минимально
[08:01.680 --> 08:02.680]  неиспользованные.
[08:02.680 --> 08:05.560]  Тогда первый суффикс, который мы обойдем, это будет лексографически
[08:05.560 --> 08:07.560]  минимальный, просто потому что мы каждый раз выбираем
[08:07.560 --> 08:08.560]  лекс-мин символ.
[08:08.560 --> 08:10.320]  Второй, соответственно, это второй по минимальности
[08:10.320 --> 08:11.320]  и так далее.
[08:11.320 --> 08:16.680]  То есть если даже не сжимать, или если сжимать, все равно
[08:16.680 --> 08:20.160]  пути от этого не изменятся, проходные вершинки, мы понятно
[08:20.160 --> 08:21.960]  дело обойдем суффиксы ровно в том порядке, в котором
[08:21.960 --> 08:22.960]  нужно.
[08:22.960 --> 08:24.840]  Просто вот в порядке лексографического возрастания.
[08:24.840 --> 08:27.960]  Значит, вопрос только со симптотикой.
[08:27.960 --> 08:33.720]  Ну давайте так, корректность, я напишу.
[08:33.720 --> 08:40.640]  Корректность тривиальна, так как обходим все в лекс
[08:40.640 --> 08:43.720]  порядке, обходим в лексографическом порядке.
[08:43.720 --> 08:50.160]  Вот, значит, что здесь со симптотикой?
[08:50.160 --> 08:52.480]  Здесь уже непонятная симптотика, да, мы не можем просто сказать,
[08:52.480 --> 08:55.320]  что это линия, потому что мы просто DFS на графе, поскольку
[08:55.320 --> 08:58.040]  мы иногда многократно проходим какие-то вершины и ребра.
[08:58.040 --> 09:00.360]  Это не обычный DFS, а DFS без юздов.
[09:00.360 --> 09:03.400]  И даже так это будет все равно линия.
[09:03.400 --> 09:05.080]  Потому что, смотрите, давайте я напишу следующее.
[09:05.080 --> 09:27.520]  Время работы пропорционально числу суффиксов плюс числу
[09:28.280 --> 09:33.720]  посещений тех не сжатых вершин.
[09:33.720 --> 09:40.040]  Плюс числу посещений тех непроходных вершин.
[09:40.040 --> 09:51.200]  Значит, ну по сути время работы это просто, то есть
[09:51.200 --> 09:53.240]  откуда число суффиксов, это вот то, что мы их печатаем
[09:53.240 --> 09:55.560]  здесь, да, каждое попадание в терминальное это напечатает
[09:55.560 --> 09:56.560]  суффикс.
[09:56.560 --> 09:58.320]  А также это просто число посещений всех вершин.
[09:58.320 --> 10:00.360]  Ну просто потому, что DFS так работает, каждый как бы
[10:00.360 --> 10:03.040]  шаг DFS это попасть в вершину.
[10:03.040 --> 10:04.800]  Когда мы встаем в вершину, мы просто берем первое
[10:04.800 --> 10:06.360]  неиспользованное ребро и идем вдоль него.
[10:06.360 --> 10:09.120]  То есть время работы, ну по сути, просто пропорционально
[10:09.120 --> 10:11.520]  числу посещений всех вот этих вершин, которые мы
[10:11.520 --> 10:12.520]  не сжали.
[10:12.520 --> 10:18.560]  Но каждое посещение вершины, это на самом деле, ну все
[10:18.560 --> 10:20.200]  посещения вершины, они на самом деле разные, потому
[10:20.200 --> 10:21.720]  что они шли по разным путям.
[10:21.720 --> 10:23.560]  Понятно, что в этом графе нет циклов, поэтому мы как
[10:23.560 --> 10:26.520]  бы не будем петлять многократно поднимать тем же строком,
[10:26.640 --> 10:29.700]  и на самом деле каждое попадание в вершины, скажем в эту,
[10:29.700 --> 10:32.120]  вот первое попадание, вот второе, это на самом деле
[10:32.120 --> 10:34.660]  попадание, отвечающее разным строкам.
[10:34.660 --> 10:37.620]  Если это была какая-то вершина, какое-то состояние
[10:37.620 --> 10:40.080]  суффрамата, какой-то класс эквивалентности, то по
[10:40.080 --> 10:42.500]  сути мы попадем в него столько раз, сколько в нем
[10:42.500 --> 10:45.100]  был строк в этом классе эквивалентности.
[10:45.100 --> 10:48.420]  Сколько есть пути до него, много раз мы в него и попадем.
[10:48.420 --> 10:50.640]  Ну по крайней мере 사람이 больше, потому что попасть
[10:50.640 --> 10:53.680]  сюда можно только за счет строк, которые в этом состоянии
[10:53.680 --> 10:54.680]  лежат.
[10:54.680 --> 11:00.980]  Вот это число посещений заведомо не больше, чем
[11:00.980 --> 11:14.920]  суммарное количество под строк s, которые оказались
[11:14.920 --> 11:16.520]  в нежатом классе эквивалентности.
[11:16.520 --> 11:39.800]  То есть, еще раз, потому что каждое пещение вершины,
[11:39.800 --> 11:41.400]  вот как мы могли попасть в вершину, значит, мы от
[11:41.400 --> 11:43.280]  старта как-то дошли.
[11:43.280 --> 11:46.680]  И поскольку нет циклов, поскольку мы один тот же путь не можем
[11:46.680 --> 11:49.720]  дважды обойти, мы в вершину можем попасть точно не
[11:49.720 --> 11:51.840]  большее число раз, чем в принципе до него было
[11:51.840 --> 11:52.840]  путей.
[11:52.840 --> 11:55.280]  А каждый путь это своя строка вот в этом классе, потому
[11:55.280 --> 11:57.080]  что попасть в вершину можно только прочитав какую-то
[11:57.080 --> 11:58.080]  сроку из этого класса.
[11:58.080 --> 12:00.600]  То есть, время работы – это, по сути, суммарное число
[12:00.600 --> 12:03.080]  под строк, которые лежат вот в этих нежатых классах,
[12:03.080 --> 12:04.080]  в непроходных вершинах.
[12:04.080 --> 12:07.200]  Но осталось понять, что такое может быть нежатый класс.
[12:07.200 --> 12:11.400]  Нежатый – это когда есть два исходящих ребра.
[12:11.400 --> 12:17.480]  То есть, это некие классы эквивалентности, такой что
[12:17.480 --> 12:19.320]  есть по крайней мере два символа, давайте их назову
[12:19.320 --> 12:26.000]  там как-нибудь, х и у, такие что можно прочитать х, это
[12:26.000 --> 12:27.720]  будет под строка, можно прочитать у, это будет под
[12:27.720 --> 12:28.720]  строка.
[12:28.720 --> 12:37.640]  И кто тогда, какие строки альфа вот здесь вот лежат?
[12:37.640 --> 12:39.560]  Здесь лежат такие строки альфа, в частности, что альфа
[12:39.560 --> 12:44.400]  х – это под строка с, под строка с, и альфа у – это
[12:44.400 --> 12:45.400]  под строка с.
[12:45.400 --> 12:52.600]  Теперь у меня к вам вопрос.
[12:52.600 --> 13:01.560]  Вот знаем ли мы какое-нибудь свойство, что вот приписывание
[13:01.560 --> 13:03.800]  символа – это под строка?
[13:03.800 --> 13:06.320]  Вот где-то у нас было, когда мы говорили про софтомат,
[13:06.520 --> 13:10.360]  что приписывание символа, можно приписать два разных
[13:10.360 --> 13:16.480]  символа, х не равно у, что это остается под строкой?
[13:16.480 --> 13:18.480]  Где у нас такое было?
[13:18.480 --> 13:21.120]  Да, критерия лонгеста, только там приписывание с другого
[13:21.120 --> 13:22.120]  конца.
[13:22.120 --> 13:24.080]  Но смотрите, если я тогда буду приписывать с другого
[13:24.080 --> 13:37.360]  конца, и напишу вот так вот, то есть я просто вот это
[13:37.360 --> 13:40.080]  условие написал, ну как бы написал строчки справа-налево,
[13:40.080 --> 13:43.440]  понятно, что это теперь тогда будет под строки с-реверснутого.
[13:43.440 --> 13:47.400]  Тогда у меня вот такое условие, что неждатые вершины, то
[13:47.400 --> 13:49.120]  есть из которых есть два исходящих ребра, это вот
[13:49.120 --> 13:52.080]  такие вершины, то есть это вот такие строки, что слева
[13:52.120 --> 13:55.000]  можно приписать нечто, что это будут разные подстроки
[13:55.000 --> 13:56.000]  с-реверснутого.
[13:56.000 --> 13:57.720]  Ну и конечно, что исходно тоже альфа было под строкой
[13:57.720 --> 13:58.720]  с, конечно.
[13:58.720 --> 14:00.660]  Альфа-реверснутого – это под строка с-реверснутого.
[14:00.660 --> 14:04.440]  Значит, альфа-реверснутого – это лонгест в SR.
[14:04.440 --> 14:07.400]  У нас был критерий, что если вот это вот выполняется,
[14:07.400 --> 14:11.500]  то альфа-реверснутого – это лонгест в с-реверснутом.
[14:11.500 --> 14:14.460]  Вот это вот означает, что альфа-реверснутого – это
[14:14.460 --> 14:19.480]  лонгест, ну, лонгест в своем классе для софтомат, построенного
[14:19.480 --> 14:20.480]  для строки с-ревертснутого.
[14:20.480 --> 14:31.520]  Лонгест в своем классе, в автомате для s-реверснутого.
[14:31.520 --> 14:34.920]  Ну а все о лонгестов в автомате мы знаем, что их максимум
[14:34.920 --> 14:35.920]  линейное количество.
[14:35.920 --> 14:38.760]  Потому что лонгестов столько же, сколько класса эквивалентности,
[14:38.760 --> 14:40.720]  а классы эквивалентности столько же, сколько вершин,
[14:40.720 --> 14:41.720]  то есть линейное количество.
[14:41.720 --> 14:46.720]  Победа таких строк альфа, ведущих нас в то, что мы
[14:46.720 --> 14:50.160]  эту вершину повторно рассматриваем, их максимум линии.
[14:50.160 --> 14:51.480]  Значит, все время работа тоже линия.
[14:51.480 --> 14:57.080]  Давайте это запишем.
[14:57.080 --> 15:23.960]  Итак, если альфа ведет в нежатую вершину, то альфа-реверснутая
[15:23.960 --> 15:28.920]  лонгест для s-реверснутого.
[15:28.920 --> 15:30.720]  Следовательно, таких альфа максимум линиейное количество.
[15:30.720 --> 15:49.880]  Ну и все, значит, время работать в суммарную линию.
[15:50.880 --> 15:51.880]  Вопросы?
[15:51.880 --> 16:09.880]  Так, да, сейчас, одну секунду, надо, наверное, это переделать.
[16:09.880 --> 16:10.880]  Момент.
[16:10.880 --> 16:20.280]  Да, надо здесь аккуратнее сказать.
[16:20.280 --> 16:25.680]  Два входящих, одно из входящих, да, то есть, на самом деле,
[16:25.680 --> 16:30.880]  не совсем правильно я сказал.
[16:30.880 --> 16:31.880]  Сейчас, одну секунду.
[16:31.880 --> 16:32.880]  Такие прыжки.
[16:32.880 --> 16:39.880]  Ладно, на самом деле, окей.
[16:39.880 --> 16:41.880]  Я тогда неправильно это сказал, да.
[16:41.880 --> 16:44.680]  На самом деле, нам нужно только, чтобы одно изходящее
[16:44.680 --> 16:45.680]  было.
[16:45.680 --> 16:48.680]  Так, я это нигде не записывал, да, сейчас, жимая, проходная
[16:48.680 --> 16:49.680]  вершина.
[16:49.680 --> 16:50.680]  Проходная, это когда одно изходящее.
[16:50.680 --> 16:52.680]  Проходная, в скобочках, одно изходящее.
[16:52.680 --> 16:55.680]  Вот так.
[16:55.680 --> 16:56.680]  Вот.
[16:56.680 --> 16:58.680]  Ну, здесь нормально, потому что это была терминальная,
[16:58.680 --> 16:59.680]  и я ее не сжимал.
[16:59.680 --> 17:00.680]  Терминальная, я не сжимаю.
[17:00.680 --> 17:02.680]  А проходная, это именно когда одно изходящее.
[17:02.680 --> 17:03.680]  Вот.
[17:03.680 --> 17:07.640]  И тогда у нас, ну тогда такой алгоритм довольно просто
[17:07.640 --> 17:08.640]  сделать.
[17:08.740 --> 17:12.380]  Просто идти по нашему автомату снизу-верх в порядке от более
[17:12.380 --> 17:14.740]  глубоких тренировки, к менее глубоким, и для каждой
[17:14.740 --> 17:18.100]  вершины ещё одна изходящее, если у неё одно изходящее
[17:18.100 --> 17:19.100]  ребро.
[17:19.100 --> 17:22.240]  Давайте, для каждой вершины понимать, куда ведет этот
[17:22.240 --> 17:26.240]  длинный путь по, когда у нас однозначный путь восстанавливается,
[17:26.240 --> 17:29.540]  когда куда ведёт этот путь по стрелочкам, когда она
[17:29.540 --> 17:30.540]  одна, всего.
[17:30.540 --> 17:32.240]  Когда без разветвлений.
[17:32.240 --> 17:33.740]  Если мы знаем это.
[17:33.740 --> 17:36.740] ная.вершина, то есть скажем, есть вот такой путь, ведучий
[17:36.740 --> 17:37.740]  сюда.
[17:37.740 --> 17:39.740]  мы как бы храним вот такую ссылочку.
[17:39.740 --> 17:41.740]  Если для этой вершины у нас тоже
[17:41.740 --> 17:43.740]  только одно из входящих ребра, то я эту ссылочку
[17:43.740 --> 17:45.740]  перекопирую вот отсюда.
[17:45.740 --> 17:47.740]  То есть, если я знаю ссылку для вот этой
[17:47.740 --> 17:49.740]  конец такого нисходящего пути по единичным
[17:49.740 --> 17:51.740]  ребрам, то здесь я тоже его знаю.
[17:51.740 --> 17:53.740]  По сути, это значит, я сжал вот эту промежуточную
[17:53.740 --> 17:55.740]  вершинку. А если у меня из вершины есть
[17:55.740 --> 17:57.740]  хотя бы два из входящих ребра,
[17:57.740 --> 17:59.740]  то я ее не сжимаю, ну, потому что она
[17:59.740 --> 18:01.740]  непроходная. Да, то есть, виноват.
[18:01.740 --> 18:03.740]  Вот тут, когда я говорю, что одно входящее, это конечно
[18:03.740 --> 18:05.740]  неправда, потому что даже если вот она
[18:05.740 --> 18:07.740]  такая, есть какая-то альфа-альфа-штрих
[18:07.740 --> 18:09.740]  и все равно одно бета, то нет смысла ее
[18:09.740 --> 18:11.740]  оставлять, можно просто здесь написать альфа-бета,
[18:11.740 --> 18:13.740]  а здесь альфа-штрих-бета. А нет смысла ее оставлять,
[18:13.740 --> 18:15.740]  если она не терминальная.
[18:15.740 --> 18:17.740]  Да, спасибо.
[18:19.740 --> 18:21.740]  Так, ну вот, вот и все.
[18:35.740 --> 18:37.740]  Так.
[18:39.740 --> 18:41.740]  Теперь все,
[18:41.740 --> 18:43.740]  про софт-автомат можно забыть.
[18:43.740 --> 18:45.740]  А теперь давайте рассмотрим следующую задачу.
[18:47.740 --> 18:49.740]  Есть длинный текст
[18:49.740 --> 18:51.740]  и короткий шаблон.
[18:53.740 --> 18:55.740]  Давайте текст T,
[18:55.740 --> 18:57.740]  шаблон, ну, пусть будет
[18:57.740 --> 18:59.740]  S.
[18:59.740 --> 19:01.740]  А теперь
[19:01.740 --> 19:03.740]  давайте рассмотрим следующую задачу.
[19:03.740 --> 19:05.740]  Шаблон, ну, пусть будет S.
[19:07.740 --> 19:09.740]  В простой задаче мы хотели бы найти,
[19:09.740 --> 19:11.740]  ну, шаблон, в смысле просто строка.
[19:11.740 --> 19:13.740]  Строка.
[19:13.740 --> 19:15.740]  В простой постановке мы бы хотели
[19:15.740 --> 19:17.740]  найти просто все вхождения S в T.
[19:17.740 --> 19:19.740]  Все вхождения S в T мы знаем,
[19:19.740 --> 19:21.740]  как искать это, ну, например, там
[19:21.740 --> 19:23.740]  начинать префикс функцию такой строки,
[19:23.740 --> 19:25.740]  тогда мы знаем все вхождения S в T.
[19:25.740 --> 19:27.740]  Везде, где префикс функция равна
[19:27.740 --> 19:29.740]  длине S, мы получаем
[19:29.740 --> 19:31.740]  очередное окончание вхождения S.
[19:31.740 --> 19:33.740]  Вот.
[19:33.740 --> 19:35.740]  Но это так называемые точные вхождения.
[19:35.740 --> 19:37.740]  Число точных вхождений
[19:39.740 --> 19:41.740]  S в T
[19:45.740 --> 19:47.740]  это префикс функция.
[19:49.740 --> 19:51.740]  Вот. А что если мы будем
[19:51.740 --> 19:53.740]  хотеть делать неточные вхождения,
[19:53.740 --> 19:55.740]  скажем там, с одной, с двумя, с тремя ошибками?
[19:55.740 --> 19:57.740]  Ну, то есть понятно, что возможно где-то
[19:57.740 --> 19:59.740]  бывают опечатки, и это нормально.
[19:59.740 --> 20:01.740]  Есть какой-то текст T длинный,
[20:01.740 --> 20:03.740]  в нем, возможно, были какие-то
[20:03.740 --> 20:05.740]  опечатки, и мы хотим найти,
[20:05.740 --> 20:07.740]  где входит S с учетом того,
[20:07.740 --> 20:09.740]  что может быть не больше, чем там
[20:09.740 --> 20:11.740]  K опечаток, вот, в вхождении.
[20:11.740 --> 20:13.740]  То есть задача такая,
[20:13.740 --> 20:15.740]  нам нужно в тексте T
[20:15.740 --> 20:17.740]  найти все такие подстроки длины
[20:17.740 --> 20:19.740]  такой же, как S, что если
[20:19.740 --> 20:21.740]  я сюда приложу S, то отличие
[20:21.740 --> 20:23.740]  между вот этой подстрокой и S будет не больше, чем K.
[20:25.740 --> 20:27.740]  Значит, наша новая задача, это
[20:27.740 --> 20:29.740]  сделать число вхождений
[20:33.740 --> 20:35.740]  не больше, чем с K опечатками.
[20:43.740 --> 20:45.740]  Не больше, чем с K опечатками.
[20:45.740 --> 20:47.740]  То есть все такие подстройки T
[20:47.740 --> 20:49.740]  нужно найти, что они
[20:49.740 --> 20:51.740]  отличаются от S не больше, чем
[20:51.740 --> 20:53.740]  в K своих позициях, где K какое-то
[20:53.740 --> 20:55.740]  задное число, там, два, три, что-то такое.
[20:55.740 --> 20:57.740]  Вот такая задача.
[20:59.740 --> 21:01.740]  Ну, насколько я понимаю, задача,
[21:01.740 --> 21:03.740]  ну, мы ее уже обсудили в случае
[21:03.740 --> 21:05.740]  K равно нулю, это мы уже умеем решать,
[21:05.740 --> 21:07.740]  это просто число точных вхождений.
[21:07.740 --> 21:09.740]  Значит, вроде тоже несложно, она решается в случае
[21:09.740 --> 21:11.740]  K равно единице. Вот этот случай
[21:11.740 --> 21:13.740]  либо и так был
[21:13.740 --> 21:15.740]  семинарская мысточка, либо подумайте над ним,
[21:15.740 --> 21:17.740]  как находить вхождение не больше, чем с одной ошибкой.
[21:19.740 --> 21:21.740]  Вот это упражнение.
[21:21.740 --> 21:23.740]  А теперь будем рассматривать общий случай, когда
[21:23.740 --> 21:25.740]  какое-то произвольное задное число
[21:27.740 --> 21:29.740]  целое.
[21:29.740 --> 21:31.740]  И чтобы решить эту задачу, нам понадобится
[21:31.740 --> 21:33.740]  что-то совсем другое, а именно перемножение
[21:33.740 --> 21:35.740]  многочленов.
[21:35.740 --> 21:37.740]  И вот сейчас, вдохновившись этой задачей,
[21:37.740 --> 21:39.740]  мы перейдем к быстрому
[21:39.740 --> 21:41.740]  преображению фурье.
[21:49.740 --> 21:51.740]  Научимся перемножать многочлены
[21:51.740 --> 21:53.740]  быстро, два многочлена друг на друга умножим быстро.
[21:53.740 --> 21:55.740]  И потом решим вот эту задачу.
[22:01.740 --> 22:03.740]  Вот, поэтому опять же про строки
[22:03.740 --> 22:05.740]  можно пока забыть.
[22:05.740 --> 22:07.740]  И наша цель
[22:09.740 --> 22:11.740]  это имея два
[22:11.740 --> 22:13.740]  многочлена
[22:21.740 --> 22:23.740]  их как-нибудь друг на друга
[22:23.740 --> 22:25.740]  быстро перемножить.
[22:25.740 --> 22:27.740]  То есть получить многочлен
[22:27.740 --> 22:29.740]  равный их произведению.
[22:31.740 --> 22:33.740]  Ну где перемножаем многочлены?
[22:33.740 --> 22:35.740]  Мы, собственно, так как в школе учили.
[22:37.740 --> 22:39.740]  То есть это что такое?
[22:39.740 --> 22:41.740]  Это сумма.
[22:41.740 --> 22:43.740]  Ну давайте я так в тупую напишу
[22:43.740 --> 22:45.740]  сумму по всем и
[22:45.740 --> 22:47.740]  отглядываю.
[22:47.740 --> 22:49.740]  Ну давайте я так в тупую напишу сумму по всем и
[22:49.740 --> 22:51.740]  от нуля до м-1
[22:51.740 --> 22:53.740]  а и тх вытой
[22:53.740 --> 22:55.740]  на
[22:55.740 --> 22:57.740]  сумму по всем ж
[22:57.740 --> 22:59.740]  от нуля до м-1
[22:59.740 --> 23:01.740]  а ж тх ж
[23:01.740 --> 23:03.740]  ну просто вот эти скобки раскрыть.
[23:05.740 --> 23:07.740]  Вот, ну понятно, что
[23:07.740 --> 23:09.740]  есть решение этой задачи за время
[23:09.740 --> 23:11.740]  типа nm.
[23:11.740 --> 23:13.740]  Если считать, что n и m примерно
[23:13.740 --> 23:15.740]  одинаковые, то у нас есть
[23:15.740 --> 23:17.740]  реальное объектное перемножение за квадрат.
[23:17.740 --> 23:19.740]  Скажем, если n равно m, то можно и за квадрат перемножить,
[23:19.740 --> 23:21.740]  просто явно все эти скобочки раскрыв.
[23:21.740 --> 23:23.740]  И там приведя подобное.
[23:23.740 --> 23:25.740]  Это будет за квадрат.
[23:25.740 --> 23:27.740]  Вот, а мы научимся за n log n.
[23:29.740 --> 23:31.740]  Значит научимся
[23:33.740 --> 23:35.740]  перемножать
[23:35.740 --> 23:37.740]  многочлены
[23:39.740 --> 23:41.740]  за o от
[23:41.740 --> 23:43.740]  n log n.
[23:43.740 --> 23:45.740]  Ну где n это больше
[23:45.740 --> 23:47.740]  из двух nm.
[24:13.740 --> 24:15.740]  Так, значит, самый важный факт,
[24:15.740 --> 24:17.740]  который нам здесь нужен,
[24:17.740 --> 24:19.740]  следующее утверждение,
[24:19.740 --> 24:21.740]  какая-нибудь теорема Лагранда или что-нибудь такое,
[24:21.740 --> 24:23.740]  утверждение будет следующее, что если у нас
[24:23.740 --> 24:25.740]  есть значение
[24:25.740 --> 24:27.740]  многочлена в k точках,
[24:27.740 --> 24:29.740]  то сам многочлен,
[24:29.740 --> 24:31.740]  если он в степени не больше k-1, восстановляется
[24:31.740 --> 24:33.740]  однозначно.
[24:33.740 --> 24:35.740]  Давайте немножко перформирую.
[24:35.740 --> 24:37.740]  Если
[24:37.740 --> 24:39.740]  дег p
[24:39.740 --> 24:41.740]  не больше, чем k
[24:41.740 --> 24:43.740]  и известны
[24:45.740 --> 24:47.740]  его значения
[24:47.740 --> 24:49.740]  в k плюс 1 различные точки,
[24:49.740 --> 24:51.740]  p от x1 и так далее,
[24:51.740 --> 24:53.740]  p от xk плюс 1
[24:53.740 --> 24:55.740]  для попарно различных вот этих всяких
[24:55.740 --> 24:57.740]  x-ов,
[24:59.740 --> 25:01.740]  для попарно различных
[25:01.740 --> 25:03.740]  x1 и так далее,
[25:03.740 --> 25:05.740]  xk плюс 1,
[25:05.740 --> 25:07.740]  то сам многочлен p однозначно восстанавливается.
[25:11.740 --> 25:13.740]  Криво написал, но смысл такой,
[25:13.740 --> 25:15.740]  что если наложить
[25:15.740 --> 25:17.740]  на многочлен следующее ограничение,
[25:17.740 --> 25:19.740]  что во-первых, его степень не больше, чем k,
[25:19.740 --> 25:21.740]  а во-вторых, его значения в данных
[25:21.740 --> 25:23.740]  k плюс 1 точки такие-то,
[25:23.740 --> 25:25.740]  то есть мы знаем, что вот это какой-то y1
[25:25.740 --> 25:27.740]  и так далее, это какой-то yk плюс 1.
[25:27.740 --> 25:29.740]  То такой многочлен единственный.
[25:29.740 --> 25:31.740]  У нас существует ровно один многочлен,
[25:31.740 --> 25:33.740]  который удовлетворяет вот этому всему набору
[25:33.740 --> 25:35.740]  оборотов.
[25:35.740 --> 25:37.740]  Но если у нас есть значение,
[25:37.740 --> 25:39.740]  то у нас есть значение,
[25:39.740 --> 25:41.740]  что есть один многочлен, который удовлетворяет вот этому всему набору
[25:41.740 --> 25:43.740]  ограничений.
[25:43.740 --> 25:45.740]  Вот, ну это как, не знаю,
[25:45.740 --> 25:47.740]  возможно, из школы даже утверждение,
[25:47.740 --> 25:49.740]  что там есть какой-нибудь многочлен лижандра,
[25:49.740 --> 25:51.740]  интерполационный,
[25:51.740 --> 25:53.740]  или лагранжа, я их всегда путаю,
[25:53.740 --> 25:55.740]  лагранжа, да, спасибо, или ньютона.
[25:55.740 --> 25:57.740]  В общем, есть формула,
[25:57.740 --> 25:59.740]  в которой можно явно этот многочлен написать,
[25:59.740 --> 26:01.740]  ну и легко показать, что если два многочлена совпадают
[26:01.740 --> 26:03.740]  на k плюс 1 точки,
[26:03.740 --> 26:05.740]  и у них степень не больше k, то они идентичны.
[26:05.740 --> 26:07.740]  Потому что их разность
[26:07.740 --> 26:09.740]  имеет k плюс 1 ноль,
[26:09.740 --> 26:11.740]  а нельзя иметь в общем нулей
[26:11.740 --> 26:13.740]  большей степень плюс один.
[26:13.740 --> 26:15.740]  Вот, ну и все, значит,
[26:15.740 --> 26:17.740]  это как бы,
[26:17.740 --> 26:19.740]  считаем это пререквизитом,
[26:19.740 --> 26:21.740]  что как бы вы это где-то должны были слышать.
[26:21.740 --> 26:23.740]  Соответственно,
[26:23.740 --> 26:25.740]  наше перемножение будет работать так.
[26:25.740 --> 26:27.740]  Вместо того, чтобы явно перемножать
[26:27.740 --> 26:29.740]  по ику, мы сначала найдем
[26:29.740 --> 26:31.740]  значение p и значение q
[26:31.740 --> 26:33.740]  в каких-то достаточно удобных точках,
[26:33.740 --> 26:35.740]  вот эти вот иксы возьмем достаточно удобными,
[26:35.740 --> 26:37.740]  вот здесь написано, какие они, мы возьмем их просто удобными для нас.
[26:37.740 --> 26:39.740]  Вот, найдем значение p и q в этих точках,
[26:39.740 --> 26:41.740]  потом их поточечно перемножим,
[26:41.740 --> 26:43.740]  а дальше у нас будет значение r
[26:43.740 --> 26:45.740]  на этих точках известные,
[26:45.740 --> 26:47.740]  нам нужно будет наоборот восстановить
[26:47.740 --> 26:49.740]  вот, собственно, то, что тут написано.
[26:49.740 --> 26:51.740]  Нужно по значению яма многочлена r в точках
[26:51.740 --> 26:53.740]  нужно будет восстановить сам многочлен.
[26:55.740 --> 26:57.740]  Значит,
[26:57.740 --> 26:59.740]  ну, аутлайн алгоритма такой.
[27:05.740 --> 27:07.740]  Найти значение
[27:07.740 --> 27:09.740]  p и q в каких-то
[27:09.740 --> 27:11.740]  удобных точках.
[27:17.740 --> 27:19.740]  x1 и так далее, x, ну, давайте
[27:19.740 --> 27:21.740]  напишу k плюс 1.
[27:21.740 --> 27:23.740]  Затем поточечно перемножить
[27:23.740 --> 27:25.740]  вот эти значения.
[27:31.740 --> 27:33.740]  Ну, а то есть, если мы знаем значение p и значение q
[27:33.740 --> 27:35.740]  в этих точках, то мы знаем значение r в этих точках.
[27:35.740 --> 27:37.740]  Потому что r
[27:37.740 --> 27:39.740]  от x этого,
[27:39.740 --> 27:41.740]  это просто p от x этого, который нам известен,
[27:41.740 --> 27:43.740]  умножить на q от x этого, который тоже нам известен.
[27:45.740 --> 27:47.740]  И дальше уже восстановить r
[27:47.740 --> 27:49.740]  по значениям в этих точках.
[27:53.740 --> 27:55.740]  Восстановить r по набору значений.
[28:03.740 --> 28:05.740]  Вот.
[28:23.740 --> 28:25.740]  Чтобы
[28:25.740 --> 28:27.740]  вот это восстановление
[28:27.740 --> 28:29.740]  было корректным
[28:29.740 --> 28:31.740]  и ровно таким каким нам нужно.
[28:31.740 --> 28:39.180]  нам нужно, чтобы число точек, в которых мы берем значение, превосходило степень r.
[28:39.180 --> 28:46.780]  Давайте напишу, что число х, вот этих вот х1 и так далее, которые написал х кап плюс один,
[28:46.780 --> 28:54.460]  ну то есть ка плюс один, должно быть больше, чем степень r, должно быть больше, чем степень r,
[28:54.460 --> 29:04.700]  которая равна n плюс m минус два. Нам нужно выбрать достаточно большое число точек,
[29:04.700 --> 29:10.100]  а достаточно много точек нужно выбрать, чтобы этот многочлен, итоговый произведение,
[29:10.100 --> 29:14.660]  однозначно по ним восстанавливался, то есть нам нужно, чтобы степень r была хотя бы вот такой,
[29:15.500 --> 29:21.900]  чтобы число точек было, точнее больше, чем вот этот, больше, чем сумма степеней минус два. Ну вот.
[29:21.900 --> 29:33.780]  И соответственно, само FFT, быстрое преобразование Фурье, соответственно,
[29:33.780 --> 29:44.900]  Fast Fourier Transform, быстрое преобразование Фурье, оно делает следующее, оно берет многочлен p,
[29:44.900 --> 29:55.420]  берет некий параметр, ну пусть будет k и находит значение, значение этого многочлена во всех
[29:55.420 --> 30:17.860]  корнях из единицы степени k. По многочлену p и числу k находит значение p во всех корнях из единицы степени k.
[30:17.860 --> 30:30.460]  Начну корни комплексные. Так, кого пугает в словосочетании комплексные корни из единицы степени k?
[30:30.460 --> 30:37.420]  Никого. Хорошо. Вот. На всякий случай, давай что-нибудь порисуем, вспомним,
[30:37.420 --> 30:43.180]  что мы про них знаем, про эти корни из единицы. Мы теперь переходим в поле комплексных чисел,
[30:43.180 --> 30:51.940]  чтобы удобно было работать. Ну и у нас есть некое число k. Наш круг, вот этот единичный круг
[30:51.940 --> 30:58.900]  разбивается на дуги, на k равных дуг. Соответственно, вот будет один из корней,
[30:58.900 --> 31:03.140]  это будет единица сама по себе. Ну а дальше мы просто вот этот угол 2p делим на k равных
[31:03.140 --> 31:11.100]  частей и соответственно, вот с этим промежуточком k у нас будут все эти корни располагаться. Вот этот
[31:11.100 --> 31:20.220]  угол будет 2p делить на k. Вот в этих точках мы будем считать значение многошленов. Вот в этих вот
[31:20.220 --> 31:30.740]  корнях из единицы. Так, правильно? Правильно. Вот, ну давайте это сделаем. Значит, смотрите,
[31:30.740 --> 31:43.980]  пусть p это a0 плюс a1, плюс так далее, an-1, xn-1. Значит, угол fpt будет у нас делить многошлен
[31:43.980 --> 31:56.180]  p пополам следующим образом. Он заводит два многошлена, p0, во-первых, вот такой вот. То есть
[31:56.180 --> 32:02.540]  мы оставляем только коэффициенты с четными индексами, а степени x у нас будут такие же
[32:02.540 --> 32:07.300]  как раньше, нулевая, первая, вторая, третья и так далее. Правильно я говорю, что это наоборот,
[32:07.300 --> 32:16.180]  все нечетные индексы, ну а степени x такие же будут. a1 плюс a3x, плюс a5x2, a7x2 и так далее.
[32:16.180 --> 32:24.380]  Только нечетные коэффициенты, а степени x как обычно в порядке возрастания от 0 до, ну то есть
[32:24.380 --> 32:37.300]  без учет отчетности. Ну, примерно в два раза, да. Тогда есть следующее очень интересное соотношение
[32:37.300 --> 32:53.940]  на эти два, ну на эти три многошена. Я его запишу так. p от x это p0 от x2 плюс x умножено p1 от x2.
[32:53.940 --> 32:59.660]  Можно в этом легко непосредственно убедиться, потому что если я сюда поставлю вместо xax2,
[32:59.660 --> 33:08.980]  то у меня будут как раз все четные слагаемые. a0, a2x2, a4x4, a6x6 и так далее. Ну а здесь сюда
[33:08.980 --> 33:14.380]  давайте вместо xa поставим x2, будет a1, но я еще умножу его на x, будет a1 умножить на x,
[33:14.380 --> 33:20.220]  значит a3 на x2, но еще на x, значит a3 на x3 и так далее. В общем все слагаемые в точности у нас
[33:20.220 --> 33:33.300]  совпадут, поэтому будет верно такое представление. Вот, а дальше смотрите. Так, может k я здесь
[33:33.300 --> 33:41.140]  зря написал. Ну да, ладно, давайте вот я здесь сделаю дописочку, что k от степени 2, чтобы нам
[33:41.140 --> 33:47.460]  было удобно. То есть на самом деле вот это k нам же по сути не важно, какое конкретно k вот там
[33:47.460 --> 33:53.700]  брать, оно должно быть достаточно большое, больше чем там сумма степени минус 2. Давайте для удобства
[33:53.700 --> 33:59.900]  будем считать что k от степени 2, тогда смотрите, вот если я сюда подставляю корни из 1 степени k,
[33:59.900 --> 34:07.900]  то после возведения их в квадрат, я получаю корни из 1 степени k пополам. Вот если здесь корень k
[34:07.900 --> 34:13.420]  от степени из 1, то вот здесь он же, когда возвел в квадрат, это будет уже корень k пополам
[34:13.420 --> 34:19.380]  до степени из 1. Ну если k четная, то если k от степени 2, то можно всегда будет так делить.
[34:19.380 --> 34:26.940]  Ну просто потому что если у меня было число в k до степени дающей 1, то его квадрат в степени
[34:26.940 --> 34:32.900]  уже k пополам, всего лишь дает 1. k пополам умножить на 2, это будет k как раз. Ну и здесь то же самое,
[34:32.900 --> 34:39.020]  корень уже k пополам до степени из 1. А значит, чтобы найти значение p вот в этих k точках,
[34:39.020 --> 34:45.660]  достаточно знать значение p0 и p1 в k пополам точках. Потому что когда здесь подставляется
[34:45.660 --> 34:49.820]  одна из k точек, здесь подставляется уже одна из k пополам точек. Многие там склеиваются,
[34:49.820 --> 34:58.420]  потому что если я здесь поставляю k разных точек, то здесь их квадрат уже будет k пополам разных точек,
[34:58.420 --> 35:07.100]  там противоположные как бы склеются. Те, которые отличаются, ну не важно, в общем, что разных
[35:07.100 --> 35:11.260]  точек здесь будет k пополам. Вот, поэтому это будет такой.
[35:20.060 --> 35:29.740]  Значит, мы просим рекурсивно запустить вот fft для многочленов p0 параметра k пополам и p1 с
[35:29.740 --> 35:35.300]  параметром k пополам. То есть мы рекурсивно найдем значение p0 и p1 во всех корнях за единицей степени
[35:35.300 --> 35:43.220]  уже k пополам вдвое меньше. А затем просто по этой формуле за линейное от k время мы найдем значение
[35:43.220 --> 36:06.420]  p во всех вот этих вот k точках. Да, то есть дальше за окошко находим значение p во всех корнях k до степени за единицей.
[36:06.420 --> 36:18.220]  Вот, ну и собственно все. Тогда время работы нашего алгоритма подчиняется нашей любимой
[36:18.220 --> 36:27.700]  линте. А чтобы найти значение в k точках, нужно два раза найти значение в k пополам
[36:27.700 --> 36:32.980]  точках и потом еще за линию склеить ответы, чтобы получить самый ответ. Значит время работы это будет
[36:32.980 --> 36:57.380]  колока. Согласны? Ну хорошо. Первый шаг есть. Вот давайте я его пронумерую. Вот он первый шаг
[36:57.380 --> 37:01.900]  найти значение в удобных точках. Вот если в качестве удобных точек взять как раз корни за единицы,
[37:01.900 --> 37:09.500]  в достаточно большом количестве, то это можно сделать не за там линию на каждую точку, а суммарно
[37:09.500 --> 37:19.780]  за 0,0k. Вот пожалуйста алгоритм. Ну второй шаг тривиален. Если мы нашли по точке значение по яку в каких-то там
[37:19.780 --> 37:27.500]  корнях из единицы, то дальше их перемножить. Все пары трудно составлять. То есть этот шаг всегда работает за от
[37:27.500 --> 37:33.340]  числа точек, потому что мы просто перемножаем какие-то числа. Вот теперь третий шаг осталось понять, как наоборот
[37:33.340 --> 37:40.740]  по набору этих корнях за единицы вернуться к многочлену. То есть если есть значение в корнях за единицы,
[37:40.740 --> 37:51.700]  то как найти коэффициенты из многочлена? Вот иногда этим мы будем думать. Это сделать давайте мы немножко
[37:51.700 --> 37:59.220]  переформулируем то, что мы вот только что сделали. На языке матриц. А именно мы нашли следующее соотношение,
[37:59.220 --> 38:18.780]  весьма нехитрое, но очень полезное. Так сейчас. Я хочу написать видимо, что пусть ω это e в степени 2i
[38:18.780 --> 38:29.460]  делить на k. То есть это вот эта вот точечка. Ну первый содержательный корень из единицы степени k.
[44:18.780 --> 44:39.860]  А потому что я беру стройку с тем же номером 4,5, значит должен получить ипи-иди элемент. Вот эта правая
[44:39.860 --> 44:52.460]  марка, то это b. Давайте перемножим. Что такое идио строка марки cb? Марка cb у меня сложная, минус i на 0, минус i на 1 и так далее.
[44:52.460 --> 45:22.460]  Это все в ноль миксации. Это идио строка марки cb, а ипи слабее марки стуливые, но это все то же самое, как и снака брусья, и на 0, и на 1, и на 2 и так далее, и на 1, и на 2, и на 1, и на 1, и на 2, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1, и на 1,
[45:22.460 --> 45:22.600]  THIS C, Japanese NO, Japanese OK, Japanese NO ONLY ONLY ONLY ONLY ONLY ONLY ONLY NO центральный
[45:26.440 --> 45:32.400]  Belor, okay.
[45:32.400 --> 45:37.400]  и умножить. Поэтому перед столбеткой вот.
[45:37.400 --> 45:40.400]  Но если мы его, если мы веки два,
[45:40.400 --> 45:42.400]  две сетки перемножим в строку столбец,
[45:42.400 --> 45:45.400]  то у меня попарно все произведения будут равны единице,
[45:45.400 --> 45:47.400]  потому что я перемножаю число на его образ.
[45:47.400 --> 45:50.400]  Значит, все произведения это n,
[45:50.400 --> 45:52.400]  потому что складываю на x.
[45:52.400 --> 45:54.400]  Если я здесь не все знак умножить,
[45:54.400 --> 45:56.400]  то это будет просто про n.
[45:56.400 --> 45:58.400]  Что им нужно? Я все вот эти,
[45:58.400 --> 46:01.400]  и эти столбетки, и эти столбетки получу в n.
[46:01.400 --> 46:03.400]  Вот так должно быть вот здесь вот эти столбетки и и.
[46:03.400 --> 46:05.400]  Понятно?
[46:06.400 --> 46:09.400]  Вот. Ну а если я возьму и и здесь, и и здесь,
[46:09.400 --> 46:11.400]  чтобы они не равны и и,
[46:11.400 --> 46:13.400]  то там должно быть множество. Давайте просто.
[46:32.400 --> 46:37.400]  Перемножим опять и в строку в,
[46:37.400 --> 46:40.400]  нажимим столбец,
[46:40.400 --> 46:43.400]  дублью
[46:43.400 --> 46:46.400]  и неравножим.
[46:46.400 --> 46:49.400]  Добно получит все множество.
[46:49.400 --> 46:51.400]  Ну, давайте, например, что-то такое.
[46:51.400 --> 46:53.400]  Здесь на какой-нибудь здесь множество и на ноль.
[46:53.400 --> 46:55.400]  И так далее.
[46:55.400 --> 46:59.400]  Умножим столбец,
[46:59.400 --> 47:01.400]  омега,���oken,
[47:01.400 --> 47:03.400]  я нашел,
[47:03.400 --> 47:05.400]  and,
[47:05.400 --> 47:07.400]  умножим столбец,
[47:09.400 --> 47:11.400]  и да page.
[47:13.400 --> 47:15.400]  Так.
[47:15.400 --> 47:17.400]  И намра стороны.
[47:17.400 --> 47:19.400]  Уминем60
[47:19.400 --> 47:21.400]  а так далее.
[47:21.400 --> 47:23.400]  Уминем60
[47:23.400 --> 47:25.400]  &
[47:25.400 --> 47:27.400]  минус
[47:27.400 --> 47:29.400]  g-минус 2 нужная минус 2
[47:32.400 --> 47:34.400]  это геометрическая прогрессия
[47:34.400 --> 47:35.400]  в которой
[47:35.400 --> 47:36.400]  как это называется?
[47:36.400 --> 47:38.400]  в номинате по поводу
[47:38.400 --> 47:40.400]  почему он не равен геометрии?
[47:40.400 --> 47:42.400]  потому что он не равно z
[47:43.400 --> 47:45.400]  но это геометрическая прогрессия
[47:45.400 --> 47:46.400]  это геометрическая прогрессия
[47:46.400 --> 47:48.400]  как-то в номинате выступает только корень геометрии
[47:48.400 --> 47:49.400]  никак
[47:49.400 --> 47:50.400]  но теперь это не n
[47:50.400 --> 47:52.400]  и я складываю вот эту подводу
[47:52.400 --> 47:54.400]  давайте обогнать
[47:55.400 --> 47:57.400]  эта песня фиксирована
[47:59.400 --> 48:00.400]  с суммой x
[48:01.400 --> 48:03.400]  теперь мы на ступене
[48:04.400 --> 48:06.400]  мы знаем, что это такое
[48:09.400 --> 48:10.400]  так
[48:10.400 --> 48:11.400]  где?
[48:11.400 --> 48:12.400]  где?
[48:23.400 --> 48:24.400]  хорошо
[48:24.400 --> 48:25.400]  так, верно
[48:25.400 --> 48:27.400]  я никогда не буду думал о таком
[48:28.400 --> 48:29.400]  спасибо
[48:29.400 --> 48:30.400]  вот
[48:30.400 --> 48:31.400]  ну и что соответственно
[48:31.400 --> 48:32.400]  здесь будет модно
[48:32.400 --> 48:34.400]  там все в общем в корень функционной сети
[48:34.400 --> 48:35.400]  а там что?
[48:35.400 --> 48:37.400]  там всегда будет модно
[48:40.400 --> 48:41.400]  а, ну да
[48:41.400 --> 48:43.400]  потому что если я для вот этого нужна 1 уницепсия
[48:43.400 --> 48:45.400]  то у меня как раз получилась
[48:46.400 --> 48:48.400]  почему уницепсия на корень сети 1 единицы?
[48:48.400 --> 48:50.400]  потому что вот это вот
[48:50.400 --> 48:52.400]  это ω в какой-то степени
[48:52.400 --> 48:55.400]  ω сама подсказывала корень fn в степени 1
[48:55.400 --> 48:57.400]  а теперь я ее и ее еще вот так возвел
[48:57.400 --> 48:59.400]  ну тогда понятно, что она
[48:59.400 --> 49:01.400]  тем более в n степени 1
[49:01.400 --> 49:03.400]  если у меня было ω в n, это 1
[49:03.400 --> 49:05.400]  у ω в степени j и n в n
[49:05.400 --> 49:07.400]  тоже понятно 1
[49:07.400 --> 49:09.400]  потому что вот n умножен 1
[49:09.400 --> 49:12.400]  значит это корень уницепсия на степени
[49:12.400 --> 49:15.400]  поэтому здесь просто прогресс
[49:16.400 --> 49:18.400]  все, поэтому все откалили чеки
[49:18.400 --> 49:20.400]  которые могут быть уницепсиями
[49:23.400 --> 49:24.400]  ну вот
[49:24.400 --> 49:26.400]  значит мы по сути нашли обратную
[49:26.400 --> 49:28.400]  ну почти обратную
[49:28.400 --> 49:30.400]  мы с ней будем работать
[49:30.400 --> 49:32.400]  а в конце наделим надельное снимание
[49:34.400 --> 49:35.400]  извините
[49:35.400 --> 49:36.400]  да
[49:36.400 --> 49:38.400]  вам надо купить купитель
[49:39.400 --> 49:40.400]  передарить?
[50:09.400 --> 50:10.400]  да
[50:21.400 --> 50:22.400]  вот, значит смотрите
[50:22.400 --> 50:24.400]  теперь у нас получается такая
[50:24.400 --> 50:27.400]  если раньше мы умножали столбец
[50:27.400 --> 50:29.400]  коэффициентов на матку w
[50:29.400 --> 50:31.400]  то теперь нам нужно замножить
[50:31.400 --> 50:33.400]  опять на некий столбец на матку w
[50:33.400 --> 50:34.400]  где всюду ω
[50:34.400 --> 50:36.400]  заменена на ω в минус 1
[50:36.400 --> 50:38.400]  да, потому что по сути
[50:38.400 --> 50:39.400]  нам нужно просто вот здесь везде
[50:39.400 --> 50:41.400]  написать минус показатель
[50:41.400 --> 50:42.400]  значит
[50:42.400 --> 50:43.400]  раньше
[50:43.400 --> 50:45.400]  вот здесь раньше
[50:45.400 --> 50:47.400]  мы столбец
[50:47.400 --> 50:49.400]  коэффициентов
[50:49.400 --> 50:51.400]  столбец чеки
[50:51.400 --> 50:53.400]  замножали слева на матку w
[50:53.400 --> 50:55.400]  и перечеки на кисло ω
[50:55.400 --> 50:57.400]  кисло ω в стову
[50:58.400 --> 51:00.400]  и перечек
[51:00.400 --> 51:01.400]  у нас обратная задача
[51:01.400 --> 51:02.400]  там нам нужно наоборот
[51:02.400 --> 51:04.400]  по набору значений
[51:04.400 --> 51:06.400]  многощинных коэффициентов
[51:06.400 --> 51:08.400]  получите его по детке в центре
[51:08.400 --> 51:10.400]  то есть по коэффициентам
[51:10.400 --> 51:12.400]  можно обидеть на w слева
[51:12.400 --> 51:13.400]  то мне нужно просто
[51:13.400 --> 51:14.400]  это нужно на w
[51:14.400 --> 51:16.400]  и смотри чтобы не гнило
[51:16.400 --> 51:17.400]  то есть теперь мне нужно
[51:17.400 --> 51:19.400]  набор значений
[51:19.400 --> 51:21.400]  так они у меня уже нет
[51:23.400 --> 51:25.400]  да, может слева на матку
[51:25.400 --> 51:27.400]  где какие-то из этой чеки
[51:27.400 --> 51:29.400]  на кисло ω в степени в минус 1
[51:29.400 --> 51:30.400]  и можно
[51:30.400 --> 51:31.400]  и потом еще в конце не забыть
[51:31.400 --> 51:32.400]  поделить на n
[51:32.400 --> 51:33.400]  давайте вот так
[51:33.400 --> 51:34.400]  припишу в конце поделить на n
[51:34.400 --> 51:35.400]  тогда мы получим в точности
[51:35.400 --> 51:36.400]  набор коэффициентов
[51:36.400 --> 51:38.400]  исходного многочлена
[51:39.400 --> 51:40.400]  вот
[51:40.400 --> 51:41.400]  ну а эта задача
[51:41.400 --> 51:43.400]  она по сути ничем не отличается от этой
[51:43.400 --> 51:44.400]  только нужно всюду вместо ω
[51:44.400 --> 51:46.400]  писать ω в минус 1
[51:46.400 --> 51:48.400]  и если раньше у меня fft
[51:48.400 --> 51:49.400]  что у меня делал fft
[51:49.400 --> 51:51.400]  fft брало набор чисел
[51:51.400 --> 51:53.400]  то есть воспринимало это все
[51:53.400 --> 51:54.400]  как многочлен
[51:54.400 --> 51:56.400]  и умножало слева вот на такую матрицу
[51:56.400 --> 51:58.400]  у которой элементарный вот этот
[51:58.400 --> 51:59.400]  ну примитивный корень
[51:59.400 --> 52:01.400]  брался в качестве ω
[52:01.400 --> 52:03.400]  а теперь нам нужно делать то же самое
[52:03.400 --> 52:04.400]  только с ω в минус 1
[52:04.400 --> 52:05.400]  потому что есть
[52:05.400 --> 52:06.400]  опять некий столбец
[52:06.400 --> 52:08.400]  нужно умножить слева на матрицу
[52:08.400 --> 52:09.400]  где всюду вместо ω
[52:09.400 --> 52:11.400]  написано ω в минус 1
[52:11.400 --> 52:12.400]  тогда давайте мы считать
[52:12.400 --> 52:14.400]  что наша вот эта исходная fft
[52:20.400 --> 52:22.400]  может работать не только с ω
[52:22.400 --> 52:23.400]  но и ω в минус 1
[52:23.400 --> 52:24.400]  потому что по сути
[52:24.400 --> 52:25.400]  в том нашем алгоритме
[52:25.400 --> 52:26.400]  совершенно не важно
[52:26.400 --> 52:27.400]  какой именно мы выбирали
[52:27.400 --> 52:28.400]  примитивный корень
[52:28.400 --> 52:29.400]  мы все равно
[52:29.400 --> 52:31.400]  считали вот значение этого многочлена
[52:31.400 --> 52:32.400]  во всех точках
[52:32.400 --> 52:33.400]  во всех корнях
[52:33.400 --> 52:34.400]  задвинутой степени n
[52:34.400 --> 52:35.400]  там степени k
[52:35.400 --> 52:37.400]  ну здесь по сути происходит то же самое
[52:37.400 --> 52:39.400]  от замены ω на ω в минус 1
[52:39.400 --> 52:40.400]  у меня набор корней не меняется
[52:40.400 --> 52:41.400]  но все равно все
[52:41.400 --> 52:43.400]  давайте кружочек нарисую
[52:48.400 --> 52:50.400]  вот здесь у меня была ω
[52:50.400 --> 52:52.400]  а здесь будет ω в минус 1
[52:53.400 --> 52:54.400]  от того что я взял вместо ω
[52:54.400 --> 52:55.400]  ω в минус 1
[52:55.400 --> 52:57.400]  у меня набор корней не изменился
[52:57.400 --> 52:58.400]  все равно все корни
[52:58.400 --> 52:59.400]  это степени
[52:59.400 --> 53:00.400]  продон
[53:00.400 --> 53:01.400]  да все корни
[53:01.400 --> 53:03.400]  это все равно степень ω в минус 1
[53:04.400 --> 53:05.400]  раньше я считал что корни
[53:05.400 --> 53:07.400]  это степень ω
[53:07.400 --> 53:08.400]  но теперь тоже самое будет
[53:08.400 --> 53:09.400]  только корни это степени
[53:09.400 --> 53:11.400]  ω в минус 1
[53:11.400 --> 53:13.400]  от этого алгоритма не изменится
[53:15.400 --> 53:16.400]  вот для этого мы просто
[53:16.400 --> 53:17.400]  используем fft
[53:17.400 --> 53:19.400]  только с другим основанием
[53:19.400 --> 53:21.400]  с другим примитивным корнем
[53:21.400 --> 53:23.400]  используем
[53:25.400 --> 53:26.400]  fft
[53:28.400 --> 53:30.400]  с другим примитивным корнем
[53:31.400 --> 53:45.500]  То есть E в степени минус 2p делить на k, вместо просто
[53:45.500 --> 54:10.100]  2p делить на k. Ну и делим результат на n. Делим результат на n. Вот, тем самым мы с вами
[54:10.100 --> 54:18.260]  смогли от набора значения прийти к набору коэффициентов, профита. Давайте теперь еще
[54:18.260 --> 54:27.620]  раз все это напишем, что нам нужно от нашего FFT, какие он принимает аргументы, и еще раз проговорим,
[54:27.620 --> 54:38.220]  как перемножить два многочлена во всех тонкостях. FFT принимает многочлен P, принимает k,
[54:38.220 --> 54:48.380]  являющийся степенью двойки, степень двойки, и принимает примитивный корень омега. Так вот,
[54:48.380 --> 54:55.140]  что все его степени образуют как раз-таки корни из-за степени k. Значит, первое, что он делает,
[54:55.140 --> 55:01.420]  это добивает многочлен P до ровно k коэффициентов. То есть мы говорили, что у P может быть степень
[55:01.420 --> 55:06.780]  меньше, чем k. Такое нам бывает нужно из-за того, что при перемножении у меня нужно,
[55:07.100 --> 55:10.820]  степень увеличивается, нужно больше точек, значит исходная степень могла быть меньше,
[55:10.820 --> 55:15.300]  чем точечка точек, где нам нужно посчитаться. Поэтому мы предварительно наш многочлен P
[55:15.300 --> 55:28.460]  расширяем в точности k коэффициентов. Считаем, что оно равно вот такому многочлену. Здесь нам
[55:28.460 --> 55:34.180]  нужно в точности ровно k коэффициентов. Если что, дополняем вот эти старшие просто нулями.
[55:34.180 --> 55:45.900]  Дальше, ну там понятно, если k равно 1, то надо написать условия выхода. Если k – это 1,
[55:45.900 --> 55:54.260]  то что такое? Корень первой степени 1 – это просто 1. Тогда наш многочлен – это просто
[55:54.260 --> 56:02.060]  константа, значит нам нужно просто вернуть a0. Если k равно 1, то мы еще поддерживаем,
[56:02.060 --> 56:09.140]  что степень P не больше, чем k. Точнее, число коэффициентов в P не больше, чем k. Там всего
[56:09.140 --> 56:13.300]  одно число – это будет константа. И значение многочленов точек 1 – это будет просто a0.
[56:13.300 --> 56:19.900]  Ну условия выхода здесь тривиальные. Иначе мы вводим наши два многочлена P0 и P1.
[56:19.900 --> 56:43.700]  Давайте пропишу еще разочек их. Четные нечетные коэффициенты разбили на две группки. Запустили
[56:43.700 --> 56:58.820]  FFT, P0, k пополам, ω квадрат, и FFT, P1, k пополам, ω квадрат. Потому что когда я перехожу от k
[56:58.820 --> 57:04.420]  к квадрату, мне нужны уже корни не k той степени, а k пополам той степени. Но если ω был примитивным
[57:04.420 --> 57:09.780]  корнем в степени k, то ω квадрат – это примитивный корень в степени k пополам. Вот опять же в
[57:09.780 --> 57:15.980]  терминах круга, если вот это вот – это такая штука, что все ее k степени – это корни из единицы степени k,
[57:15.980 --> 57:24.500]  то вот этой вот штуке как раз все степени от 0 до k пополам той – это будут как раз корни k
[57:24.500 --> 57:29.460]  пополам той степени. Потому что каждый четный. Вот здесь вот берем – это будут как раз корни
[57:29.460 --> 57:35.060]  четной степени – ω квадрат, ω в четвертой, в шестой и так далее. Ровно это здесь нам нужно.
[57:35.060 --> 57:50.940]  Ну и дальше, p от ω итой – это p0 от ω в степени 2i плюс ω итой на p1 от ω в степени 2i. Все,
[57:50.940 --> 57:56.420]  и это будет ответ. Для каждого i насчитываем эту сумму – это будет ответ набор размещения нашего
[57:56.420 --> 58:17.780]  многочленов в нужных точках. Теперь умножение, да, ну не знаю, умножение многочленов. Давай так
[58:17.780 --> 58:42.260]  напишу – умножение многочленов. p и q. Во-первых, напоминаю, нужно выбрать достаточно много точек,
[58:42.260 --> 58:50.500]  так чтобы даже произведение p на q однозначно определялось в этих k точках. Ну для этого давайте
[58:50.500 --> 58:57.700]  скажем, что пусть k, выберем k, достаточно большой степень у двойки, чтобы оно было больше, чем n
[58:57.700 --> 59:05.660]  плюс m минус 2. Вот я тут писал когда-то, что число точек, в которых мы считаем значение, должно
[59:05.660 --> 59:10.860]  быть больше, чем степень. Потому что при произведении степени складываются, поэтому k должно
[59:10.860 --> 59:20.420]  быть такой степень у двойки, которая больше, чем n, давайте я так и напишу, больше, чем степень r
[59:20.420 --> 59:28.900]  плюс степень q, ну то есть там n плюс m минус 2. Давайте просто идти по степням двойки, там 2,
[59:28.900 --> 59:35.260]  4, 8, 16 и так далее, берем первую попавшуюся, которая больше, чем вот это, чем сумма степеней.
[59:35.260 --> 59:44.660]  Дальше запускаем FFT на наших двух многочленах, вот с этим самым k, и в качестве омега берем,
[59:44.660 --> 59:52.700]  ну давайте я так и напишу, 2p делить на k, на e в степени 2p делить на k, и то же самое для q,
[59:52.700 --> 01:00:04.460]  с тем же k и с той же омегой, 2p делить на k. В частности, вот здесь, в этом FFT у меня многочлены
[01:00:04.460 --> 01:00:09.500]  q и q автоматически дополняются до нужного числа коэффициентов, потому что раньше там было n и m
[01:00:09.500 --> 01:00:14.900]  коэффициентов, а нам нужно k, но вот здесь вот на первом шаге мы его дополняем нулями до нужного
[01:00:14.900 --> 01:00:19.900]  числа коэффициентов, поскольку k достаточно большой, больше, чем сумма n плюс m, то мы просто добиваем
[01:00:19.900 --> 01:00:26.420]  нулями до нужного количества. Вот, значит запустили FFT, дальше, ну по точно перемножили, давайте не
[01:00:26.420 --> 01:00:39.060]  буду это писать там в виде кода, просто напишу, что r от омега вжитой, это p от омега вжитой,
[01:00:39.060 --> 01:00:48.460]  умножить на q от омега вжитой для всех g. То есть запустили FFT, нашли значения в нужном наборе
[01:00:48.460 --> 01:00:54.060]  точек, потом их по точно перемножили, ну и теперь нам нужно просто обратно FFT на вот
[01:00:54.060 --> 01:00:59.300]  это многощение r, то есть теперь у меня как бы r хранится как набор чисел, я воспринимаю
[01:00:59.300 --> 01:01:05.380]  этот набор чисел как набор коэффициентов, вот собственно это столбец, вот он, и на нем просто
[01:01:05.380 --> 01:01:10.780]  делаю то же самое только с противоположной омегой, e в степени минус 2 pi делить на k,
[01:01:10.780 --> 01:01:23.260]  минус 2 pi делить на k, и не забывая что сделать, поделить на n, так давайте напишу, конечно,
[01:01:23.260 --> 01:01:50.220]  что это a, return a9 на n, все, все перемножение многошленов. Когда что еще раз? Уточните вопрос,
[01:01:50.220 --> 01:01:55.500]  пожалуйста, ну вот прям, ну типа нам надо написать там класс комплексных чисел, которые
[01:01:55.500 --> 01:02:00.220]  перемножаются, складываются, вообще это просто комплекс, комплекс от double кажется это называется,
[01:02:00.220 --> 01:02:11.100]  комплекс, это просто класс, который хранит там два поля, вещественную мнимую часть, каждый из
[01:02:11.100 --> 01:02:17.660]  которых вот в double, ну там double или long double тут пишете, вот, просто это там класс с двумя полями,
[01:02:17.660 --> 01:02:22.340]  вещественная мнимая часть, на которых определено умножение как надо, на комплексных чиселах
[01:02:22.340 --> 01:02:27.580]  сложение там, ну деление нам вроде тут не надо, но деление на n надо будет в конце, вот, ну либо
[01:02:27.580 --> 01:02:31.420]  сами пишете просто, если не верите встроенному, то можете просто сами свой класс комплекс написать,
[01:02:31.420 --> 01:02:39.780]  там ничего хитрого нет, просто формулки, вот, как вас учили, как перемножать там x1 плюс i y1 на x2
[01:02:39.780 --> 01:02:51.060]  плюс y2, ну там просто так и перемножаете, комплекс, include комплекс, ну или cmas в
[01:02:51.060 --> 01:03:04.100]  худшем случае, ну вроде комплекс просто отдельный, да, да, да, вот это хорошее замечание, давайте
[01:03:04.100 --> 01:03:10.980]  про это немножко поговорим, да, то есть на самом деле тут по ходу мы конечно переходим к вещественным
[01:03:10.980 --> 01:03:16.820]  числам, ну к даблам, к погрешностям округления и так далее, и как вы правильно сказали, даже если
[01:03:16.820 --> 01:03:21.140]  исходные два многочисленного были целочисленные, то вот здесь мы переходим в комплексные числа,
[01:03:21.140 --> 01:03:29.100]  в комплексные числа, корни из однице, там вообще ни капли, ни целые вот эти вот вещественные мнимые
[01:03:29.100 --> 01:03:34.980]  части, но понятно, что результат должен быть как бы целый, да, потому что мы взяли исходно два целых
[01:03:34.980 --> 01:03:44.620]  многочленов, точнее, от вещественных, вот, ну чего, надо округлить просто, да, вот, офигенный совет,
[01:03:44.620 --> 01:03:50.220]  но на самом деле тут как бы я могу только следующее сказать, значит, проблемы, проблемы округления,
[01:03:50.220 --> 01:04:03.020]  как они решаются? Проблемы округления, ну, проблемы погрешностей. Значит, первая мысль, следующая,
[01:04:03.020 --> 01:04:09.380]  что это все точно работает, то есть если вы просто в конце округлите до ближайшего целого, то у вас
[01:04:09.380 --> 01:04:14.500]  все будет корректно работать, если по дороге все числа, вот, которые вы считали были, ну, не больше
[01:04:14.500 --> 01:04:30.940]  чем 10 в 12 по модулю. Значит, пусть P и Q целочисленные, тогда R должен быть целочисленным,
[01:04:30.940 --> 01:04:45.740]  ну, значит, в конце, значит, добавим округление, в конце добавим, добавим округление. Вот это все
[01:04:45.740 --> 01:04:51.740]  точно работает, если все числа, которые у вас используются по дороге, по модулю не превосходит
[01:04:51.740 --> 01:05:13.580]  примерно 10 в 12. Это OK, если все используемые числа по модулю не превосходят 10 в 12. Ну, это такое
[01:05:13.580 --> 01:05:18.740]  эмпирическое, скорее, наблюдение, да, там, возможно, там, 10 в 11, ну, вот, примерно можно на это
[01:05:18.740 --> 01:05:23.700]  закладываться, то есть если у вас такая задача, что вы понимаете, что если у вас даны два
[01:05:23.700 --> 01:05:29.940]  многошлина P и Q, то коэффициенты в R, все коэффициенты в R не будут по модулю превосходить 10 в 12. Тогда
[01:05:29.940 --> 01:05:34.700]  можно смело писать в комплексных числах, здесь все и не парится, у вас, типа, будет, если вы округлите,
[01:05:34.700 --> 01:05:41.460]  у вас оно правильно округлится, потому что числа достаточно маленькие, чтобы их, чтобы на них еще
[01:05:41.460 --> 01:05:47.140]  не успело накопиться ошибка, скажем так. Вот это, как бы, эмпирическое наблюдение.
[01:05:47.140 --> 01:06:01.740]  Либо же второй подход, который чаще, ну, вот у нас там в контесте, возможно, будет, ну, и, как бы,
[01:06:01.740 --> 01:06:08.260]  в таких задачах, там, чисто олимпиадных, где нужно, по сути, многошлина перемножить, это вычисления
[01:06:08.260 --> 01:06:27.500]  в ZP. Переход в ZP для хороших P. Сейчас поясню, что это значит. Смотрите, вот мы до этого переходили
[01:06:27.500 --> 01:06:33.380]  в C, поликомплексный чисел, потому что там есть такие очень удобные точки, корни за единицей,
[01:06:33.380 --> 01:06:39.220]  к этой степени, что, ну, они, во-первых, ну, главное свойство, что есть такая омега, примитивный корень,
[01:06:39.220 --> 01:06:44.180]  что все ее степени это вот корни там какой-то большой степени из однице. И более того,
[01:06:44.180 --> 01:06:50.100]  там было верно, что для любого K есть свое омега, что все K степени этой омеги – это корни из
[01:06:50.100 --> 01:06:59.020]  однице степени K. Вот. Для некоторых P то же самое выполняется в ZP, что для достаточно больших K
[01:06:59.020 --> 01:07:06.140]  есть там такое хорошее омега, что все все ее степени задают тоже корни из единицы какой-то
[01:07:06.140 --> 01:07:10.500]  достаточно большой степени. Ну, вот корни в том же смысле, что омега в какой-то степени – это
[01:07:10.500 --> 01:07:17.100]  единица. Ну, поскольку ZP такое может быть там, где омега любое число из ZP. Вот. Значит,
[01:07:17.100 --> 01:07:36.060]  сейчас я. По-моему, следующее верное утверждение. Если P равно 2 в степени A умножить на B плюс 1,
[01:07:36.060 --> 01:07:49.820]  где B нечетная, то существует такое омега, которое обладает всеми свойствами вот того
[01:07:49.820 --> 01:07:56.700]  самого примитивного корня из поликомплексных чисел, вплоть до степени 2 в степени A. Существует
[01:07:56.700 --> 01:08:01.900]  такое омега, что, ну, во-первых, я напишу, что оно само по себе является корнем из единицы вот
[01:08:01.900 --> 01:08:07.540]  такой вот степени. Ну, конечно, в ZP. Если я уживу в ZP, то все вот эти вычисления производятся,
[01:08:07.540 --> 01:08:14.060]  конечно, в поле ZP. Ну и более того, все предыдущие степени – омега в нулевой,
[01:08:14.060 --> 01:08:20.540]  в первый, во второй и так далее – это различные числа с таким же свойством. То есть все числа
[01:08:20.540 --> 01:08:29.020]  омега в нулевой, омега в первой и так далее, омега в степени 2 в степени A минус 1 попарно
[01:08:29.020 --> 01:08:39.580]  различны. Вот, то есть, вот, собственно, ровно это свойство у нас было основополагающее для
[01:08:39.580 --> 01:08:45.940]  примитивного корня в поликомплексных чисел, что его нужная степень – это единица, а все меньшая
[01:08:45.940 --> 01:08:49.620]  степень – это вот разные числа, которые, ну, конечно, в той же степени дают тоже единицу,
[01:08:49.620 --> 01:08:53.540]  потому что, если я возвожу омега в какую-то степень, то это свойство, что возведение в степень
[01:08:53.540 --> 01:09:03.740]  2 в степени A дает единицу, оно сохраняется. Омега в степени 2A минус 1, 2 в степени A минус 1,
[01:09:03.740 --> 01:09:22.100]  то есть как бы все предыдущие, все до этой. Все числа, вот эти попарно различны. Вот, ну и,
[01:09:22.100 --> 01:09:26.940]  соответственно, если у нас P достаточно хорошая, что вот здесь вот выделяется достаточно большая
[01:09:26.940 --> 01:09:32.500]  степень двойки, то можно делать FFT для всех K, не превосходящих 2 в степени A.
[01:09:32.500 --> 01:09:51.700]  Нет, нет, я же с нуля начал. Вот это же единица, это тоже единица, поэтому только. Почему? Нет,
[01:09:51.700 --> 01:09:57.980]  их всего 2 в степени A, получается, ровно. От нулевой до 2 ватт и минус 1. Вроде все нормально.
[01:09:57.980 --> 01:10:06.020]  Вот так вот я и говорю, что если P, если вот здесь выделяется достаточно хорошая A, то есть если P
[01:10:06.020 --> 01:10:10.820]  удовлетворяет такому свойству, что здесь A достаточно большое, то мы можем выполнять FFT для
[01:10:10.820 --> 01:10:18.740]  всех K, не превосходящих 2 в степени A. Вот если K такое, то в ZP можно делать такой же FFT,
[01:10:18.740 --> 01:10:28.420]  можно делать такой же FFT. Ну, то есть, в смысле, там будет все то же самое по сути. Там такое
[01:10:28.420 --> 01:10:33.540]  же разбиение на 2 многочлены и так далее. Вот, и соответственно, если мы там сами вольны выбирать P,
[01:10:33.540 --> 01:10:39.900]  то просто давайте подберем P, что P минус 1 делится на большую степень двойки. Вот,
[01:10:39.900 --> 01:10:45.700]  ну либо надеяться, что P, которую нам дают, оно такое. Так, давайте я какой-нибудь пример напишу,
[01:10:45.700 --> 01:10:58.980]  я уже забыл, что там есть. Ну, самое мейнстримное для таких задач, как бы задачи, в которых прям,
[01:10:58.980 --> 01:11:03.300]  если вы видите, короче, такой модуль, то это скорее всего задача на FFT, но это не точно.
[01:11:03.300 --> 01:11:31.180]  Вот это я помню, я уже не помню. 119 на 2 в 23 плюс 1. Да, здесь ω равна 31. Что? Нет, главное 23. То есть,
[01:11:31.180 --> 01:11:37.100]  если у нас P вот такое, можно проявить, что оно простое, и можно заметить, что вот это вот
[01:11:37.100 --> 01:11:45.020]  выполняется, тогда вот по утверждению существует такое ω, что его все степени хорошие. Причем,
[01:11:45.020 --> 01:11:49.740]  смотрите, 2 в 23 – это весьма-весьма-весьма большое число. И если у нас там, скажем,
[01:11:49.740 --> 01:11:54.860]  исходные многочлены были степени, не знаю, 10 в 6 всего лишь, да, ну, не больше миллион,
[01:11:54.860 --> 01:12:01.980]  то их произведение, 10 в 6 – это примерно 2 в 20. Их произведение требует у нас 2 в 21 примерно,
[01:12:01.980 --> 01:12:06.620]  да, потому что сумма степеней спокойно сюда укладывается. Поэтому по такому модулю мы можем
[01:12:06.620 --> 01:12:14.700]  спокойно переменять многочлены степени до 10 в 6 примерно. Вот. И тут не будет никаких уже
[01:12:14.700 --> 01:12:19.260]  проблем с переполнением, потому, ну, точнее ошибок с погрешностями, потому что мы переменяем целые
[01:12:19.260 --> 01:12:23.940]  числа, ну, там, в ZP, окей, там, нужно из НТа выйти в лонг-лонг, тогда никаких вообще погрешностей не
[01:12:23.940 --> 01:12:29.300]  будет. Но это все, конечно, только мы работаем в ZP, соответственно, наш результатирующий многочлен
[01:12:29.300 --> 01:12:36.900]  тоже только в ZP мы знаем все его коэффициенты. Если нам вдруг очень хочется сделать целочисленный
[01:12:36.900 --> 01:12:45.180]  FFT в большом каком-то диапазоне чисел, то есть, то есть, провести обычное произведение, но не в ZP,
[01:12:45.180 --> 01:12:50.220]  да, и причем там никакой P нам не подойдет. Давайте несколько P возьмем, а потом бахнем к ТС и теряем
[01:12:50.220 --> 01:12:55.500]  об остатках. То есть, если мы знаем, скажем, то есть, вот, в таком, для такого P, можем перемножить
[01:12:55.500 --> 01:13:02.940]  наши два многочлена и узнать r от x по модулю P. То есть, по сути, это когда я все его, все его
[01:13:02.940 --> 01:13:08.580]  коэффициенты, так, ну, не по модулю P, это плохо говорить, ну, давайте я пишу процент P. То есть, по сути,
[01:13:08.580 --> 01:13:13.820]  это когда все его коэффициенты я взял остаток по модулю P. Окей, сделал это для вот этого P. Дальше,
[01:13:13.820 --> 01:13:18.540]  то же самое я делаю для какого-нибудь другого P, P штрих какого-нибудь, тоже возьму еще какое-нибудь
[01:13:18.540 --> 01:13:22.460]  другое простое, которое также раскладывается, да, на достаточно большую степень, вот здесь,
[01:13:22.460 --> 01:13:27.860]  у двойки выделяется. Сделаю то же самое, узнаю коэффициенты, точнее, остатки отделения всех
[01:13:27.860 --> 01:13:32.540]  коэффициентов r на код новый P штрих. Так сделаю для достаточного числа простых, ну, и дальше,
[01:13:32.540 --> 01:13:36.180]  соответственно, по-китайски теряем об остатках, я могу восстановить все коэффициенты уже без,
[01:13:36.180 --> 01:13:47.140]  без погрешности. Если, скажем, мы знаем, что, на столах, давайте скажу, то есть, если я знаю,
[01:13:47.140 --> 01:13:53.540]  что все коэффициенты вот этой штуки не превосходят там, скажем, 10-40, то мне достаточно взять, ну,
[01:13:53.540 --> 01:14:02.700]  там, пять разных P-шек, пять разных простых, порядка 10 в 10, 10 в 9, узнать, узнать остатки
[01:14:02.700 --> 01:14:07.100]  уделения этого многочлена по всем этим P-шкам, дальше, вот по этим пяти модулям я уже однозначно
[01:14:07.100 --> 01:14:11.420]  восстановлю коэффициенты всех, все коэффициенты в нашем многочлене, потому что просто знаю по
[01:14:11.420 --> 01:14:29.740]  достаточному числу модуля их, значит, знаю, как бы, ну, настоящие значения. Вот, ну, либо можно там
[01:14:29.740 --> 01:14:34.940]  просто написать какой-нибудь свой класс вещественных чисел, который не там восьми байтовый,
[01:14:34.940 --> 01:14:40.140]  а там чуть больше байтов это сделать, написать там свою какую-то длиночку и просто опять перейти в
[01:14:40.140 --> 01:14:44.820]  комплексные числа, просто чуть более точную, чем, чем вот обычные типы позволяют, и будет тоже,
[01:14:44.820 --> 01:14:50.820]  чем больше байт вы вкладываете в ваш дабл, руками написаны, тем больше, тем больше точность,
[01:14:50.820 --> 01:15:03.380]  тем больше приятность, что вы не ошибетесь при округлении. Так, хорошо. Тогда давайте,
[01:15:03.380 --> 01:15:07.340]  наверное, я сейчас обслужу еще, как делать Ft без рекурсии, и на этом мы закончим на сегодня,
[01:15:07.340 --> 01:15:13.580]  потом вернемся к той задаче про строки, к которой мы вдохновились в начале пары. Ft без рекурсии,
[01:15:13.580 --> 01:15:32.580]  Ft без рекурсии. Ну, как это иногда бывает, чтобы наш алгоритм работал быстрее, мы хотим его
[01:15:32.580 --> 01:15:36.380]  написать без рекурсии, потому что когда мы разбиваем наш массив на два куска, рекурсивно
[01:15:36.380 --> 01:15:40.060]  запускаемся на каждом из них, нам нужно будет куча памяти, у нас будут очень сильно вот эти
[01:15:40.060 --> 01:15:45.460]  вот скачки по памяти между двумя рекурсивными вызовами, и, в общем, это работает за нужную
[01:15:45.460 --> 01:15:50.660]  симпатику, но довольно долго, поэтому давайте попробуем от рекурсии избавиться. Для этого я
[01:15:50.660 --> 01:15:58.100]  построю вот такое дерево, того, как у нас разбиваются наши коэффициенты. Давайте представим,
[01:15:58.100 --> 01:16:04.020]  что исходно у меня был многочлен с 8 коэффициентами, давайте посмотрим, как эти 8 коэффициентов себя
[01:16:04.020 --> 01:16:13.460]  ведут. Изначально это все был 1 массив, а 0, а 1, а 2, а 3, а 4, а 5, а 6, а 7. Вот был такой массив коэффициентов.
[01:16:13.460 --> 01:16:20.180]  Дальше при первом же вызове мы разбиваем наши многочлены на четные и нечетные, точнее четные и
[01:16:20.180 --> 01:16:32.740]  нечетные индексы. Влево идем с а 0, а 2, а 4, а 6, вправо с а 1, а 3, а 5, а 7. Сюда пошли четные,
[01:16:32.740 --> 01:16:40.900]  сюда нечетные индексы. Дальше рекурсивно, когда мы оказываемся в этом многочлене, мы воспринимаем
[01:16:40.900 --> 01:16:45.820]  уже вот эти 4 числа как коэффициенты нормального многочлена, в левую часть отправляем те из них,
[01:16:45.820 --> 01:16:54.020]  которые четные, а 0, а 4, вправо и те, которые нечетные, а 2, а 6. Здесь то же самое, а 1, а 5,
[01:16:54.020 --> 01:17:03.860]  здесь а 3, а 7. Ну здесь уже мы спускаемся вот в такие вот одноэлементные массивы,
[01:17:03.860 --> 01:17:22.100]  а 0, а 4, а 2, а 6, а 1, а 7. Так это опять у меня было такое кривое, опять а 3, а 7. Вот. Ну нарисовали
[01:17:22.100 --> 01:17:28.500]  полную историю того, как все эти наши коэффициенты спускаются сверху вниз. Что здесь приятно?
[01:17:28.500 --> 01:17:33.140]  Приятно, например, то, что на нижнем уровне у меня написаны не просто коэффициенты многочленов,
[01:17:33.140 --> 01:17:38.940]  но и значения тех же самых многочленов. Потому что на нижнем уровне мы писали условия, если карбны
[01:17:38.940 --> 01:17:45.540]  единицы, то эти многочлены просто константы. И эти константы равны их значениям в любой точке.
[01:17:45.540 --> 01:17:51.980]  Поэтому это не просто, как я говорю, это не просто коэффициенты, но это сразу значения многочленов.
[01:17:51.980 --> 01:17:57.940]  Значит, я могу вот эти вот ячеечки воспринимать сразу как значения многочленов нужных в нужных
[01:17:57.940 --> 01:18:03.460]  точках. А дальше происходит следующее. Давайте мы как бы вот эту рекурсию сверху вниз развернем,
[01:18:03.460 --> 01:18:07.940]  будем считать, что здесь у меня написаны правильные значения нужных многочленов,
[01:18:07.940 --> 01:18:12.700]  и теперь я иду сверху вниз, и как бы пытаюсь склеить, зная значения вот здесь, вот попытаюсь
[01:18:12.700 --> 01:18:17.500]  найти значения вот здесь. Ну и, например, давайте переход отсюда-сюда. У нас был некий многочлен
[01:18:17.500 --> 01:18:23.860]  там, там, какой-то П, он разбился на многочлены П0, П1. Здесь дают значения П0 в одной точке,
[01:18:23.860 --> 01:18:29.460]  здесь П0 в другой точке, здесь П1 в одной точке, П1 в другой точке. Я хочу из этих значений склеить
[01:18:29.460 --> 01:18:35.860]  и получить значения П в этих четырех точках и сюда их прям записать. Давайте сделаем.
[01:18:47.500 --> 01:18:57.420]  Итак, представьте, что мы как-то так идем снизу вверх, и в какой-то момент у меня есть два вот
[01:18:57.420 --> 01:19:07.220]  таких блока, где лежат в нужном порядке значения двух многочленов П0, П1 в нужных точках, и я хочу
[01:19:07.220 --> 01:19:13.940]  из них склеить значения многочленов. Вот какой-то такой один из переходов сверху вниз, снизу вверх,
[01:19:13.940 --> 01:19:22.820]  снизу вверх, поднимаемся. Что здесь за значения? Здесь значения в точке... Так, сейчас я немножко
[01:19:22.820 --> 01:19:32.700]  потуплю. Тут нам нужны значения омега в нулевой, омега в первой и так далее, омега в n-1, а здесь
[01:19:32.700 --> 01:19:40.140]  у меня значения омега в нулевой, в квадрате и так далее. Окей, сейчас давайте это напишу. Здесь
[01:19:40.140 --> 01:19:47.860]  нужны значения вот в этих точках, а здесь есть значения в точках омега в нулевой, омега в квадрате
[01:19:47.860 --> 01:19:58.860]  и так далее, омега в степени, ну, видимо, n-2. Давайте попробуем найти значение какое-нибудь,
[01:19:58.860 --> 01:20:06.060]  вот, например, вот здесь. Что такое значение П в точке омега 1? Омега в первый. Ну, мы знаем,
[01:20:06.100 --> 01:20:13.820]  что это П0 от омега в квадрате. Я возлил в квадрат эту степень плюс омега в первый, умножить на П1 от
[01:20:13.820 --> 01:20:21.260]  омега в квадрате. То есть, чтобы посчитать, чтобы положить значение вот сюда, мне нужно взять вот
[01:20:21.260 --> 01:20:28.460]  это значение и вот это значение и с нужным коэффициентом их сложить. Поэтому я нарисую вот
[01:20:28.460 --> 01:20:37.660]  такие вот стрелочки, что это значение зависит от вот этого и от вот этого. То же самое давайте я
[01:20:37.660 --> 01:20:47.780]  напишу для П от омега в степени n-2 плюс 1. Оно будет вот здесь. То есть, 1 плюс n-2 на пол
[01:20:47.780 --> 01:20:53.580]  массива вправо. Чему вот равно это значение? Когда я возвожу в квадрат этот показатель,
[01:20:53.580 --> 01:20:59.420]  у меня n-2 превращается в n и соответственно уничтожается, потому что омега в n-2. Остается
[01:20:59.420 --> 01:21:07.020]  здесь П0 от омега в квадрате. Плюс здесь опять я это оставляю. Будет омега, ну давайте, окей,
[01:21:07.020 --> 01:21:12.580]  оставим омега в n-2, плюс 1, умножить на то же самое. П1 от омега в квадратной степени,
[01:21:12.580 --> 01:21:16.340]  когда я возвожу в квадрат, у меня это уничтожится, потому что омега в n-2 будет
[01:21:16.340 --> 01:21:22.660]  просто омега в квадрате. Получается, что эта точка зависит от тех же двух, вот этой и вот этой.
[01:21:22.660 --> 01:21:31.300]  Да, мне никакие другие значения не нужны. И так будет верно на самом деле для любой точке издвинутой
[01:21:31.300 --> 01:21:36.820]  вправо на n-2. То есть, если я возьму здесь произвольный омега в ж этой и омега в степени
[01:21:36.820 --> 01:21:43.740]  g плюс n-2, то они зависят от вот этой точки, которая прямо под ней идет, и от вот этой точки, которая
[01:21:43.740 --> 01:21:49.980]  идет прямо под вот этой омега в степени g плюс n-2. Соответственно, я их значения могу вычислить
[01:21:49.980 --> 01:21:52.900]  через вот эти два. То есть, мне нужно вот эти два значения, чтобы знать эти два значения.
[01:21:52.900 --> 01:22:00.620]  Вот. Поэтому на самом деле, ну, собственно, формула перешеда здесь и как бы написана.
[01:22:00.620 --> 01:22:05.980]  Если у меня есть содержимое вот этого массива на каком-то предыдущем уровне, вот оно,
[01:22:05.980 --> 01:22:11.260]  то чтобы посчитать на следующем уровне, мне нужно просто по вот этой вот формуле как-то их там
[01:22:11.260 --> 01:22:16.220]  склеить. То есть, если я беру вот это значение и из следующего куска на расстояние n пополам,
[01:22:16.220 --> 01:22:20.580]  то я их с нужными коэффициентами складываю. Вот он коэффициент, если что. Там, значит,
[01:22:20.580 --> 01:22:27.660]  тут такой, тут такой. И кладу одну сумму сюда, другую сумму сюда. Вот просто формула пересчета,
[01:22:27.660 --> 01:22:39.180]  как мы, собственно, вот главная форма, мы по ней просто все пересчитываем. Значит,
[01:22:39.180 --> 01:22:43.500]  просто если у меня есть вот один массив, я могу посчитать следующий просто там,
[01:22:43.500 --> 01:22:48.980]  какими-то достаточно аккуратными сложениями и ну, как бы, просто переложить в нужные ячейки,
[01:22:48.980 --> 01:22:55.140]  мне нужно значение. Но более того, это можно даже сделать без привлечения до памяти, потому что,
[01:22:55.140 --> 01:23:00.060]  смотрите, если у меня есть вот этот массив, считать, что все это находится в одном массиве подряд написано,
[01:23:00.060 --> 01:23:08.180]  тогда чтобы посчитать, скажем, вот это и вот это, я беру вот эти два числа, посчитываю их нужной
[01:23:09.140 --> 01:23:13.900]  линейной комбинации. То есть, я знаю вот это и вот это, я беру их нужной линейной комбинации с
[01:23:13.900 --> 01:23:19.500]  нужными коэффициентами и перезаписываю на те же самые места. То есть, я взял вот эти два числа,
[01:23:19.500 --> 01:23:24.500]  сложил их так как надо с нужными коэффициентами и положил сюда, сюда и сюда, то есть, по сути,
[01:23:24.500 --> 01:23:29.220]  я просто их перезаписал. Потому что они больше не нужны, они влияли только на вот
[01:23:29.220 --> 01:23:33.980]  эти два числа, я их посчитал и сразу туда же положил. То есть, по сути, я просто могу на
[01:23:33.980 --> 01:23:38.620]  на этом же массиве итеративно все пересчитывать. Разбивать
[01:23:38.620 --> 01:23:42.220]  его на нужные кусочки, брать два значения, складывать
[01:23:42.220 --> 01:23:44.100]  их с нужными коэффициентами и класть туда же, где они
[01:23:44.100 --> 01:23:47.540]  лежали. И так сделать log n раз снизу вверх пройдя
[01:23:47.540 --> 01:23:48.780]  и наш массив постоянно пересчитывать.
[01:23:48.780 --> 01:24:01.980]  Последнее, что надо сказать, это следующее. Это надо
[01:24:01.980 --> 01:24:04.440]  понять, в каком порядке эти коэффициенты лежат на
[01:24:04.440 --> 01:24:09.300]  нижнем уровне. Здесь они лежат в порядке развернутой
[01:24:09.300 --> 01:24:18.060]  обратной записи от 0 до n-1. Если я напишу вот эти
[01:24:18.060 --> 01:24:21.340]  индексы в двоичной системе счисления и прощаю их справа
[01:24:21.340 --> 01:24:24.940]  налево, то как раз получится 0, 1, 2, 3 и так далее. Например,
[01:24:24.940 --> 01:24:27.860]  4 записываю обратно, то есть 4 в двоичной системе
[01:24:27.860 --> 01:24:32.500]  это 1, 0, 0, читаю справа налево, будет 1. 2 в двоичной
[01:24:32.500 --> 01:24:37.180]  системе это 0, 1, 0, дополняю до трех битиков. Читаю справа
[01:24:37.180 --> 01:24:41.740]  налево, будет опять-таки 2. 6 это 1, 1, 0, читаю справа
[01:24:41.740 --> 01:24:47.260]  налево, будет 0, 1, 1. То есть как раз нужно просто
[01:24:47.260 --> 01:24:51.900]  инвертировать, прочитать справа налево индекс нашего
[01:24:51.900 --> 01:24:55.260]  элемента и будет написано ровно тот элемент, который
[01:24:55.260 --> 01:24:57.940]  нам нужен. Почему? Просто потому, что сначала идут
[01:24:57.940 --> 01:25:00.860]  те, у которых, налево идут те, которые четные, а направо
[01:25:00.860 --> 01:25:03.060]  те, которые нечетные. То есть здесь те, у которых
[01:25:03.060 --> 01:25:07.220]  последний 0. Дальше у этих предпоследний 0, у этих предпредпоследний
[01:25:07.220 --> 01:25:09.900]  0. То есть здесь должен быть те, у которых все нули. Кто
[01:25:09.900 --> 01:25:14.020]  здесь? Последний 0, предпоследний 0, а предпредпоследний 1,
[01:25:14.020 --> 01:25:16.740]  потому что мы в конце пришли в 1. То есть это как раз 0,
[01:25:16.740 --> 01:25:20.900]  0, 1. И если я прочитаю наоборот справа налево, то у меня
[01:25:20.900 --> 01:25:23.300]  получится ровно тот, кто здесь должен лежать. Из-за
[01:25:23.300 --> 01:25:25.740]  того, что я вот так удобно бью на четные и нечетные,
[01:25:25.740 --> 01:25:28.300]  у меня также, я однозначно определяю последний слой.
[01:25:28.300 --> 01:25:30.260]  Но если я знаю последний слой, то нужно просто логарифм
[01:25:30.260 --> 01:25:33.060]  N раз примить вот это преобразование, которое называется преобразование
[01:25:33.060 --> 01:25:36.860]  бабочки, потому что вот такая картиночка, преобразование
[01:25:36.860 --> 01:25:42.300]  бабочки. Ну и тем самым мы развернули рекурс сюда,
[01:25:42.300 --> 01:25:44.860]  то есть мы посчитали последний слой. Дальше логарифм N раз
[01:25:44.860 --> 01:25:49.260]  делаем преобразование бабочки ко всем элементам. И в конце
[01:25:49.260 --> 01:25:52.020]  у нас получается массив значений многочленов в наших
[01:25:52.020 --> 01:25:53.620]  н-точках. Все, спасибо.
