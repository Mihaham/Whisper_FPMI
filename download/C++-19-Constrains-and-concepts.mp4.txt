[00:00.000 --> 00:17.000]  Сегодня мы поговорим про концепты. У нас последние
[00:17.000 --> 00:23.080]  разы были посвящены всяким type trait'ам. Как вы помните,
[00:23.080 --> 00:27.880]  мы там обсудили реализации всякие упоротые. Из констрактебл,
[00:27.880 --> 00:34.520]  из бейзов, поговорили про enable live, как им пользоваться. Но с приходом C++20
[00:34.520 --> 00:43.800]  большинство из этого устарело на самом деле. То, о чем я сейчас буду рассказывать,
[00:43.800 --> 00:51.080]  вы наверняка слышали про это, может вы сами где-то читали. Много сейчас, каждый месяц там,
[00:51.080 --> 00:58.560]  понятно, люди пишут, появляются все новые и новые статьи. Это новая такая хайповая тема,
[00:58.560 --> 01:04.200]  примерно как когда Move Semantic появилась в 2011 году, там тоже все постепенно уезжали. Но вот в 2020
[01:04.200 --> 01:10.920]  году в стандарт внесли эту штуку, и с тех пор люди постепенно начинают ее осваивать, к ней привыкать.
[01:10.920 --> 01:22.600]  Сразу скажу, что еще мало кто умеет этим пользоваться, ну в том числе и я. То есть,
[01:22.600 --> 01:28.560]  ну я вам сейчас что-то расскажу, ну я вам расскажу так, ну, на плюс-минус базовом уровне,
[01:28.560 --> 01:34.640]  что вот есть такие-то языковые возможности, вот и не так-то можно пользоваться. Но понятно,
[01:34.640 --> 01:42.520]  что наверняка еще там в ближайшие месяцы люди откроют кучу новых способов, как это можно
[01:42.520 --> 01:47.640]  использовать, найдут баги, в C++ 23-м что-нибудь переиздадут. Ну то есть, короче говоря,
[01:47.640 --> 01:54.000]  это такая достаточно свежая прям вот новиночка стандарта уже, несмотря на то, что два года вроде
[01:54.000 --> 01:59.560]  как прошло, но люди, сообщество довольно медленно осваивает новые фичи стандарта. Компиляторы еще
[01:59.560 --> 02:04.400]  год назад не целиком умели это поддерживать, сейчас вроде плюс-минус поддерживают, но я, кстати,
[02:04.400 --> 02:09.840]  до сих пор не уверен, что все, что я сегодня буду писать у меня скомпилируется. Ну должно,
[02:09.840 --> 02:15.880]  но я не до конца уверен, что компиляторы вообще все умеют поддерживать, что там требуется от них.
[02:15.880 --> 02:25.440]  Вот, ну а где это сейчас используется? Ну там какие-нибудь флагманы IT-индустрии типа Яндекса там,
[02:25.440 --> 02:32.600]  наверное, ну не наверное, а точно уже используют, но далеко не все все равно умеют, даже в рамках
[02:32.600 --> 02:38.160]  этих компаний. Постепенно люди осваивают, кто-то быстрее, кто-то медленнее, постепенно переходят
[02:38.160 --> 02:45.480]  на C++20, во многих местах еще C++17, например, в Яндекс.Контесте еще только C++17, ну и так далее.
[02:45.480 --> 02:55.280]  Ну короче, это новая свежая штука, вот, не судите строго, если я что-то не знаю, еще мало кто хорошо
[02:55.280 --> 03:00.680]  в этом разбирается, ну и, соответственно, когда мы вас будем что-нибудь на экзамене про это спрашивать,
[03:00.680 --> 03:10.080]  то тоже это будет очень лояльно, потому что, ну, вглубь пока мало кто умеет. Вот, будем так основные
[03:10.080 --> 03:20.000]  возможности рассматривать. Ну так вот, концепты и констрейнты. Ну, сначала мы начнем с констрейнтов.
[03:20.000 --> 03:31.600]  Ну давайте, наверное, файл назову Concepts. Ой-ой-ой, извините, это у меня уже тут что-то лишнее, его я удалю.
[03:31.600 --> 03:44.560]  Так, дайте-ка я выведу список участников еще.
[03:44.560 --> 03:59.560]  Значит, у нас какая была история? Мы пользовались раньше Enable и Form, чтобы сделать перегрузку по
[03:59.560 --> 04:07.920]  принципу того, является ли тип, удовлетворяет ли тип какому-то свойству или нет. Вот, ну простейший
[04:07.920 --> 04:17.840]  пример, это мы хотим написать функцию, которая по-разному будет работать в зависимости от того,
[04:17.840 --> 04:24.600]  объект является объектом класса или нет. Ну вот, например, у меня есть std string s, и я вызываю f
[04:24.600 --> 04:33.840]  от s, а есть просто int x, и я вызываю f от x. Вот я хочу опять написать функцию, это мы уже с вами делали,
[04:33.840 --> 04:40.440]  но мы это делали старомодно. Сейчас я покажу новый, новомодный способ. Значит, написать функцию,
[04:40.440 --> 04:48.400]  которая в зависимости от того, является ли тип классовым, хайповый способ, да, делает либо одно,
[04:48.400 --> 04:55.400]  либо другое. Вот, ну способ с помощью Enable.if вы помните, я думаю, там еще была вот эта проблема,
[04:55.400 --> 05:03.160]  когда мы неправильно используем Enable.if, что функции различаются только дефолтным шаблонным
[05:03.160 --> 05:10.480]  параметром, это все неудобно для использования, но вот сейчас будет удобный для использования способ.
[05:10.480 --> 05:25.720]  Ах да, это пункт 15.157, чтобы поддерживать нумерацию. Какой у нас был последний пункт?
[05:25.720 --> 05:32.200]  Common Type был 15.6, да, значит это будет пункт 15.7 нашей программы, ну соответственно 15.8 будет
[05:32.200 --> 05:48.680]  Conceptor. Ну давайте я назову Requires keyword. Значит, ключевое слово Requires, появилось оно начиная с
[05:48.680 --> 06:04.400]  C++20. Что я могу написать, начиная с C++20? Я пишу template type name t, а вот дальше я пишу ограничение
[06:04.400 --> 06:12.520]  на t, то есть я не пишу вот этот вот стрёмный Enable.if, бла-бла-бла-бла, фиг пойми что, а я пишу
[06:12.520 --> 06:23.920]  Requires, и это новое ключевое слово, начиная с C++20, Requires и некоторое буллевское выражение,
[06:23.920 --> 06:30.880]  но здесь не любое буллевское выражение можно написать, я потом уточню какое, но я могу написать,
[06:30.880 --> 06:47.320]  например, std из класс v от t void f от const t ampersand, ну без const t ampersand, просто tx, и тут я выведу std
[06:47.320 --> 07:07.440]  out 1. Вот, а теперь я это всё скопирую, ой, что я не то сделал, и уберу здесь Requires, и тут выведу 2.
[07:07.440 --> 07:14.560]  Нет, не уберу Requires, оставлю Requires, просто сделаю отрицание его.
[07:14.560 --> 07:29.840]  Requires не std из класс v от t. Вот, ну тут, правда, скобочки надо поставить, потому что отрицание
[07:29.840 --> 07:38.960]  он иначе не распарсят. Вот, ну и давайте попробуем это затестить, как это работает, значит утверждается,
[07:38.960 --> 07:53.440]  что вот это слово Requires, оно a c++20 concept cpp, и кажется он справился, да, 1.2, ура, это даже
[07:53.440 --> 08:01.200]  g++10 справился, я приятно удивлён, я надеял, я думал, что мне 11 придётся использовать, но даже 10
[08:01.200 --> 08:08.640]  справился. Странный вопрос. Да. Как работает обратная совместимость в случае, когда в язык
[08:08.640 --> 08:20.600]  добавлено ключевое слово? Вдруг у меня переменная называлась Requires? Ну... Сорян, я не знаю, ну,
[08:20.600 --> 08:39.360]  я не думал об этом. Ну, наверное, плохо, да. Вот. Окей. Да, ну, во-первых, я здесь должен ставить скобочки,
[08:39.360 --> 08:51.320]  во-вторых, ну, я вот тут отступ поставил, ну так, вроде как люди обычно так пишут, а в-третьих,
[08:51.320 --> 08:59.520]  а что в-третьих, да, про скобочки всё-таки хочу ещё отдельно сказать. Вот, когда я написал
[08:59.520 --> 09:11.920]  Requires, после этого должно идти буллевское выражение, но с оговорочками, там может быть либо, вот если
[09:11.920 --> 09:16.520]  я хочу написать произвольное буллевское выражение, то мне скобочки надо ставить, а если без скобочек,
[09:16.520 --> 09:22.240]  то там есть список, что можно писать, и вот, в частности, вот именованные константы шаблонные
[09:22.240 --> 09:34.240]  можно писать без скобочек. Вот. Хорошо, вот вопрос. Если я уберу вот это вот, то есть я такое взял и
[09:34.240 --> 09:45.080]  в одном случае сделал Requires, в другом не сделал, что получится? А так вообще можно, в смысле,
[09:45.080 --> 09:51.640]  если бы у нас и сверху не было Requires, то у нас вообще была бы одинаковая функция? Да, если бы у нас
[09:51.640 --> 09:59.280]  не было Requires ни там ни там, то это было бы redefinition. Но вот утверждается, что чудесным образом в случае с
[09:59.280 --> 10:19.200]  Requires так можно. Давайте я это проверю, и это всё ещё работает. Вот, значит компилятор, вот в чём у нас
[10:19.200 --> 10:27.800]  была проблема с enable и form. У нас там были вот эти вот, ну, по сути, что там было? Там вот был вот
[10:27.800 --> 10:36.320]  этот template typeNameT, typeName, равно, короче, у нас функции отличались тем, какой там дефолтный
[10:36.320 --> 10:43.560]  шаблонный параметр, и это там работало плохо, потому что компилятор, в общем, он вычисляет,
[10:43.560 --> 10:52.080]  подставляет там шаблонные параметры слишком поздно, позже, чем он решает, какая сигнатура ему больше
[10:52.080 --> 11:00.000]  подходит, ну что-то такое. Ну вот, в случае с Requires, они решили все эти костыли похоронить и сказать,
[11:00.000 --> 11:12.900]  что Requires вычисляется прямо раньше всего, ну, то есть, вот это ключевое слово Requires и проверка
[11:12.900 --> 11:18.980]  того, что constraint выполнено, вот это называется constraints, то, что я сейчас написал, ограничение.
[11:18.980 --> 11:24.980]  Она делается, ну, на очень раннем этапе, то есть, она делается до выбора перегрузки, ну, то есть,
[11:24.980 --> 11:29.580]  я не могу вам точно сказать там, в какой последовательности, что делается, ну, в общем,
[11:29.580 --> 11:36.500]  вычисление оценка Requires и какой из них более подходит делается очень рано. И существует
[11:36.500 --> 11:40.980]  следующее правило, что если в одной функции Requires присутствует, а в другой отсутствует,
[11:40.980 --> 11:50.460]  то первая предпочтительней, ну, при условии, что Requires подходит. И вот это на очень раннем
[11:50.460 --> 11:56.680]  этапе комплятором оценивается, то есть, это там до, ну, грубо говоря, до всего того, что мы знали
[11:56.680 --> 12:01.300]  раньше, наверное, даже, вот до того, как он начнет шаблоны там какие-то вычислять и так далее.
[12:01.300 --> 12:09.340]  Вот такой вопрос. Да. Там под Requires стоит буллевское выражение, а можно ли под Requires поставить
[12:09.340 --> 12:14.460]  буллевское выражение, которое с некоторыми кt тупо не скомпилиться? Отличный вопрос. Сейчас
[12:14.460 --> 12:23.500]  мы как раз про это тоже поговорим. Ну, можно. Они и это предусмотрели. Значит, так, окей, мы два
[12:23.500 --> 12:27.980]  примера пока разобрали простеньких, значит, мы поняли, что если у нас есть два разных Requires,
[12:27.980 --> 12:35.420]  один подходит, другой не подходит, мы попадаем в тот, который подходит. Можно еще? Да. Скорее уже на
[12:35.420 --> 12:41.820]  месте. Если убрать вторую перегрузку, верно ли, что оно со стринг скомпилируется все равно,
[12:41.820 --> 12:47.660]  а со синтом просто не скомпилируется? Да, синтом не скомпилируется. Ну, давайте проверим.
[12:47.660 --> 12:56.580]  Очень интересно, что он именно расскажет. А, кстати, да. Давайте тогда начнем с этого
[12:56.580 --> 13:06.140]  примера. Вот что, если я просто оставлю одно требование и вызовусь от int? Еще одно важное
[13:06.140 --> 13:13.540]  преимущество, это преподносилось разработчиками компилятора, разработчиками стандарта, как чуть
[13:13.540 --> 13:19.100]  ли ни одна из важнейших причин переходить на вот это все дело, потому что ошибки компиляции
[13:19.100 --> 13:26.340]  становятся гораздо более читаемыми. Вот. Ну, силенго, вероятно, они еще более читаемые. Значит,
[13:26.340 --> 13:33.500]  раньше, когда у вас что-то не подставлялось в шаблон, то там был огромный какой-то просто поток
[13:33.500 --> 13:37.940]  сознания компилятора, который что-то пытался подставить, в него невозможно читать совершенно.
[13:37.940 --> 13:47.460]  С requires, одно из требований, как скажем, один из кпи, что ли, у них, короче, одна из целей,
[13:47.460 --> 13:53.100]  которые они преследовали, это чтобы можно было легко диагностику читать. Вот, если у вас не
[13:53.100 --> 14:00.940]  подходят невыполненные ограничения, то вам просто пишут, template sufficient failed, constraints not
[14:00.940 --> 14:10.220]  satisfied, и вам говорят, какой именно, constraint не выполнен с каким типом. Очень удобно.
[14:10.220 --> 14:20.260]  Прямо написано, что вот этот constraint оказался false. Вот, можно силенг из интереса, ну, кстати,
[14:20.260 --> 14:29.820]  можно из интереса g++10, g++10 тоже справился. Можно силенг спросить, что он скажет. Ну, то
[14:29.820 --> 14:36.780]  же самое, в принципе. Ну, то есть, и тот, и другой компилятор умеет нормальную диагностику выдавать,
[14:36.780 --> 14:54.740]  если constraint not satisfied. Вот. Вот. Дальше. Что будет, если я здесь напишу
[14:54.740 --> 15:07.260]  какое-нибудь, что-нибудь такое, что для некоторых t оно просто некорректно. Ну, например, вот,
[15:07.260 --> 15:21.540]  вот value type. В t же есть value type, да? Ну, вот давайте я потребую вот такую вещь, чтобы было не классом
[15:21.540 --> 15:31.180]  value type внутри t. Ну, внутри стринга это правда. Там value type, он char, наверное, он не класс. То есть,
[15:31.180 --> 15:38.980]  для стринга это требование выполнено. Но для int это просто некомпилируемое требование. Вот,
[15:38.980 --> 15:56.500]  что произойдет? Сейчас, это не работает, потому что я забыл type name. Ну, тут type name действительно
[15:56.500 --> 16:05.060]  нужно, потому что никак не понятно, это число или тип. Вот, это компилируется и работает. Ну,
[16:05.060 --> 16:17.020]  и с силенгом тоже самое. То есть, смотрите, какая магия. Это не просто вычисляет верно ли вот это
[16:17.020 --> 16:22.940]  булевское выражение. То есть, вот, помните, какая проблема была с noexcept? Мы там не могли просто
[16:22.940 --> 16:36.020]  написать тупо, что это конъюнкция, что isMoveConstructable и noexcept от blah blah blah. Мы так не могли написать,
[16:36.020 --> 16:43.660]  потому что обычная конъюнкция, она хоть и не вычисляется целиком, но компилируется, пытается
[16:43.660 --> 16:49.220]  целиком. И приводит к CE, если там что-то некорректное с точки зрения компиляции.
[16:49.220 --> 17:00.340]  А сейчас есть вероятность, что меня выкинут из зума. Какой-то аккаунт зашел вместо меня. Ну,
[17:00.340 --> 17:14.380]  что за дела? Ну да ладно. Будем надеяться, что нет. Вот, а requires умнее. Он работает не так. Он даже
[17:14.380 --> 17:20.060]  если у него некомпилируемые выражения, он просто считает, что это false. То есть, они и это предусмотрели.
[17:20.060 --> 17:32.460]  Вот, но при этом, если у вас, скажем, вот такая ситуация, давайте я, например, так напишу,
[17:32.460 --> 17:45.460]  что у меня есть вот такой requires и вот такой requires. Что сейчас будет? То есть constraints,
[17:45.660 --> 17:52.780]  внутри себя свиное содержит своего рода. Ну, в каком смысле содержит? Ну, по сути, да. То есть,
[17:52.780 --> 18:00.940]  если неудачная постановка в requires, то это не CE. То есть, он умный. Логично, что они это предусмотрели,
[18:00.940 --> 18:05.380]  потому что раньше это было болью, теперь перестало быть таковой. Вот, теперь смотрите,
[18:05.380 --> 18:11.700]  что я написал. Я написал вот здесь requires true, то есть любое требование подходит, а здесь какое-то
[18:11.700 --> 18:17.380]  более строгое. Вот, но, к сожалению, нет, так не работает. Компилятор определит какое из них
[18:17.380 --> 18:23.700]  предпочтительнее. Да, вот здесь уже не получится, потому что, когда у вас в одном есть requires в другом
[18:23.700 --> 18:30.820]  нет, то тут понятно. Просто по правилам такой, если там есть requires, там нет, значит, это
[18:30.820 --> 18:39.940]  предпочтительно. А когда у вас и там, и там есть, то тут уже так не скажешь. Поэтому это амбигиус.
[18:39.940 --> 18:48.140]  Если оба подходят. Да, вот такой вопрос. Я хочу сделать три перегрузки. Одна из которых вот та
[18:48.140 --> 18:56.860]  верхняя. Вторая про то, что у Т вообще есть value type. И третья, ну, типа, общий случай.
[18:56.860 --> 19:18.180]  Я думаю, что здесь как раз понадобятся концепты. Вот, с помощью чистой requires вот я сейчас сходу не
[19:18.180 --> 19:25.580]  могу сказать как. Вот сейчас мы до концептов дойдем, и тогда это будет реализуемо. Так,
[19:25.580 --> 19:37.260]  пока про requires я закончу. Значит, вот это один синтаксис. Есть и другой синтаксис. Значит,
[19:37.260 --> 19:51.060]  requires можно писать и после сигнатуры. То есть, я могу написать вот так. Нет, не так, а вот так как
[19:51.060 --> 20:02.900]  раз. Блин. Короче говоря, вот так я могу сделать. После того, как я написал сигнатуры, я могу написать
[20:02.900 --> 20:13.380]  requires. Это два разных синтаксис. Ну, не знаю, один ничуть не лучше другого. В принципе, зачем так
[20:13.380 --> 20:28.340]  сделали, не знаю. Ну, вот так сделали. Можно писать и до, и после. Ну, хорошо. Это было то,
[20:28.340 --> 20:43.460]  что называется requires clause. То есть, ну, такой спецификатор requires. Вот, а есть еще requires
[20:43.460 --> 20:58.500]  оператор. Это вам должно что-то напоминать. Что это вам напоминает? New. Нет. Ну, у нас уже была такая
[20:58.500 --> 21:04.980]  ситуация. У нас было нечто спецификатором и оператором одновременно. Это был noexcept.
[21:04.980 --> 21:18.580]  Вот requires он тоже бывает спецификатором и оператором. Значит, что такое requires оператор?
[21:18.580 --> 21:33.420]  Это такая конструкция, которая эволуетится в true или false в зависимости от того, корректно ли
[21:33.420 --> 21:40.780]  с точки зрения compile-time выражение, которое вы под ней напишете. Смотрите, как прикольно. Я
[21:40.780 --> 21:50.540]  могу написать. Вот, например, я хочу понять. Ну, давайте у меня будет какая-нибудь шаблонная функция
[21:50.540 --> 22:06.940]  g. Я сейчас рассказываю, что у нас есть, помимо requires clause, еще requires оператор. Вот это было
[22:06.940 --> 22:14.220]  requires clause. Подобно тому, как с noexcept было, у нас есть noexcept спецификатор и оператор. Также
[22:14.220 --> 22:25.820]  requires. Сейчас я продемонстрирую вам requires оператор. Вот, я сейчас вам выведу, правда ли,
[22:25.820 --> 22:49.580]  что у t есть value type? requires от t x, а тут я напишу t 2.2.value type не знаю, что-нибудь.
[22:49.580 --> 23:15.300]  Игрок. g от s. Сейчас, я надеюсь, нормально, например, сработает. g от s и g от x. Давайте проверим,
[23:15.300 --> 23:35.820]  что? Что-то у меня там. Type name. Фигурной скобочки нету здесь. А, возможно, кстати,
[23:35.820 --> 24:03.820]  type name нету. Это правда. Вот здесь type name нужно. Так. Сейчас.
[24:03.820 --> 24:26.460]  Noexcept оператор работал абсолютно по-другому. Да, это правда. Сейчас я, возможно, я не совсем
[24:26.460 --> 24:31.540]  правильно, ну, невозможно, а точно я не совсем правильно это использую. Сейчас я постараюсь это
[24:31.540 --> 24:38.740]  правильно заиспользовать. Где же?
[25:01.540 --> 25:25.900]  Да, я просто пишу type name и ничего не объявляю. Вот так. Довольно странно. Вот так должно
[25:25.900 --> 25:38.100]  работать. Да, вот так работает. О, смотрите, как прикольно. Так, что я сейчас написал? Вот у меня
[25:38.100 --> 25:48.700]  шаблонная функция. Вот это вот, то, что после cout, это буллевское выражение. Это expression,
[25:48.700 --> 25:54.820]  requires expression. Ну, я не уверен, кстати, можно requires назвать оператором, возможно, я вас
[25:54.820 --> 26:01.620]  немножечко обманул, и формально это не оператор. Но вот это вместе называется requires expression. Как
[26:01.620 --> 26:08.220]  он устроен? Он имеет следующий синтакс. Если вы пишете requires в месте, где ожидается expression,
[26:08.220 --> 26:16.180]  дальше в круглых скобочках как будто бы аргументы принимаете. Но здесь x я не использовал,
[26:16.180 --> 26:23.620]  поэтому я могу, наверное, от него избавиться. Логично, что я могу не передавать имя. А дальше
[26:23.620 --> 26:33.460]  открываете фигурную скобку, и в фигурной скобке вы пишете некоторую последовательность. Я бы даже
[26:33.460 --> 26:38.500]  не сказал бы, что инструкции, потому что вот это не инструкция. Вы пишете просто некоторую
[26:38.500 --> 26:50.300]  последовательность некоторых requirements. Я не знаю, как это. Это нельзя давать стейтнентами,
[26:50.300 --> 26:56.060]  потому что вот это, например, не стейтнент. Но вы можете писать нам обычные expression. Вы можете
[26:56.060 --> 27:04.140]  писать вот такие штуки. Мы сейчас через некоторое время откроем cpp-reference вместе и посмотрим
[27:04.140 --> 27:12.620]  список того, что писать можно. А разве объявление переменной это не expression? Но я сейчас не объявил
[27:12.620 --> 27:21.700]  переменную. Нет, я знаю, вы пытались, и у вас не получилось. Где? Нет, да, ну вот я пытался
[27:21.700 --> 27:27.260]  сделать declaration. Вот declaration значит нельзя было. Но там довольно странный список того,
[27:27.260 --> 27:33.420]  что можно. Не знаю, почему declaration нельзя. Я не выучил наизусть этот список, как видите. Но вот
[27:33.420 --> 27:38.700]  чтобы проверить, что тип присутствует, вот так можно написать. Я могу проверить, что какая-то
[27:38.700 --> 27:44.780]  операция присутствует. Ну то есть, как я могу сделать? Сначала я решил проверить, что у меня,
[27:44.780 --> 27:51.300]  например, value type присутствует. Я еще могу проверить, что какая-нибудь операция присутствует,
[27:51.300 --> 28:01.460]  x.size, например. Вот, еще я могу проверить, например, что складывать можно x плюс y. Ну то есть,
[28:01.460 --> 28:08.900]  я пишу некоторые экспрешены, и компилятор смотрит на них и оценивает, они вообще компилируем
[28:08.900 --> 28:20.700]  или нет. И если да, все они компилируем, то возвращает true. Вот. А вот в обычном requires,
[28:20.700 --> 28:28.100]  как можно проверить, допустим, что можно складывать такие типы? Вот. Ну так же,
[28:28.100 --> 28:37.140]  как с no accept. Вот у меня же после requires идет булевское выражение. Но requires это и есть
[28:37.140 --> 28:44.020]  булевское выражение. Вот после requires clause должно идти булевское выражение. Значит, я могу после
[28:44.020 --> 28:52.420]  этого requires написать еще requires. Ну давайте так и сделаю. Например, я напишу requires, что эти
[28:52.420 --> 29:02.900]  типы складывать можно. Вот напишу вот не так. Давайте-ка я вот что сделаю. Вот я сейчас потребую от
[29:02.900 --> 29:08.820]  типа t, чтобы можно было складывать, вычитать, умножать, ну, складывать, вычитать просто. Я пишу
[29:08.820 --> 29:19.360]  requires и еще раз requires, потому что это начинается requires expression. Здесь говорю tx ty, фигурная
[29:19.360 --> 29:27.920]  скобочка открывается, x плюс y, x минус y. Фигурная скобочка закрывается и точка запятой мне не нужна,
[29:27.920 --> 29:36.840]  кажется, потому что я был... потому что... потому что потому. Вот, значит, и давайте проверим,
[29:36.840 --> 29:49.040]  что сейчас будет. Так, вот здесь мне выведется 1 в случае строки, 0 в случае inta, потому что
[29:49.040 --> 29:58.360]  value type у него нет. А здесь что будет? Когда я вызываюсь от s, выводится 1, потому что этот
[29:58.360 --> 30:03.640]  requires не выполнен, строки вычитать нельзя. Когда я вызываюсь от inta, выведется 2. Давайте проверим,
[30:03.640 --> 30:12.040]  что все работает. Все работает. Вот, я после requires написал... я могу после requires написать
[30:12.040 --> 30:15.680]  произвольное... ну, вообще, я могу произвольное булевское выражение в скобочках написать,
[30:15.680 --> 30:24.320]  но могу написать и некоторую вот... ну, могу написать без скобочек либо булевскую константу,
[30:24.320 --> 30:33.000]  такую, например, из класс V или из base of V, не знаю, либо requires expression, который сам
[30:33.000 --> 30:48.400]  его лейтится в bool в compile time, в зависимости от того, правда ли что. Вот. Вот. Можно вопрос? Да,
[30:48.400 --> 31:01.600]  конечно. Можно написать requires внутри тела функции. Ну да. И если не выполнено выражение, то функция...
[31:01.600 --> 31:13.280]  комплятор переходит к другому определению функции. Нет. Нет, подождите. Если я... у меня есть requires
[31:13.280 --> 31:21.200]  clause, она вычисляется очень рано, в момент... еще до выбора версии перегрузки. Если он понимает,
[31:21.200 --> 31:25.440]  что requires clause... по вот этим требованиям он не удовлетворяет, то он пойдет искать другую
[31:25.440 --> 31:32.320]  версию функции. А вот это я показал. Это просто я показал, что бывает requires expression. Вот это вот
[31:32.320 --> 31:41.280]  requires expression. Я могу вычислять его... ну, это так как sizeof или как noexcept. Я могу брать requires
[31:41.280 --> 31:47.960]  от каких-то типов и дальше в фигурных скобочках что-то написать. И это все в compile time оценится в
[31:47.960 --> 31:55.920]  true или false, в зависимости от того, какие типы были. Но он равносилен тому, что мы писали раньше.
[31:55.920 --> 32:06.560]  Что значит равносилен? Ну, можно все то же самое взять и ctrl-x, ctrl-v в сигнализацию функции. Ну,
[32:06.640 --> 32:13.640]  это будут разные совершенно вещи. Здесь я просто попросил его вывести 1 или 0. А там бы я попросил
[32:13.640 --> 32:16.800]  его либо идти в эту функцию, либо нет, в зависимости от выполнения требований.
[32:16.800 --> 32:23.600]  А, понятно, окей.
[32:23.600 --> 32:33.840]  Это я просто попросил его сказать, мне выполнили требования здесь и вывести ответ. Вот, ну, я могу
[32:33.840 --> 32:39.080]  использовать это, например, как? Ну, я могу написать с другой стороны, что я могу сделать. Я
[32:39.080 --> 32:52.360]  могу сказать if constexpr requires вот это вот все. Вывести 1, иначе 2. Могу же я так поступить? Вот
[32:52.360 --> 33:01.240]  давайте-ка я так сделаю. Я скажу if constexpr requires вот это вот все добро. Ну, это, конечно, кривоватая
[33:01.240 --> 33:11.320]  конструкция. Я не знаю, это очень странно выглядит. Но, тем не менее, формально так можно,
[33:11.320 --> 33:23.720]  никто мне не запрещает. И фигурная скобочка открывается. Так, сейчас. Я даже не знаю,
[33:23.720 --> 33:43.000]  как здесь отступ правильно сделать. Ну, давайте std-seout 1 else std-seout 2. А почему я сказал,
[33:43.000 --> 33:49.400]  что это криво? В смысле, здесь выглядит криво, но звучит как валидное использование? Ну, потому что,
[33:49.400 --> 34:03.840]  я думаю, что... Пусть я хочу. Так, сейчас я как-нибудь вот так сделаю. Господи,
[34:03.840 --> 34:09.000]  как же мне отступы-то расставить? Правильно, вот так, короче, я сделаю. Вот так, наверное,
[34:09.000 --> 34:20.480]  правильней всего расставить отступы. Вот, ну... То есть, я могу заменить это вызовом функции,
[34:20.480 --> 34:29.560]  в которой будет написано requires-requires и дальше вот это вот свойство. Ну, наверное, да, наверное,
[34:29.560 --> 34:39.400]  это можно использовать. Я просто никогда не видел, чтобы такое где-то писали в реальном коде.
[34:39.400 --> 34:48.680]  Возможно... Ну, люди как-то лет 20 подряд писали вообще без стипус-20. Нет, я видел использование
[34:48.680 --> 34:52.840]  концептов и констрейнтов в реальном коде, но вот такого конкретно я как-то не встречал,
[34:52.840 --> 35:02.040]  и поэтому оно мне как-то пока не выглядит как что-то. Возможно, это нормальное использование,
[35:02.040 --> 35:08.960]  и так люди пишут, но просто мне сейчас как-то вот как-то оно мне эстетически вызывает неприязнь
[35:08.960 --> 35:15.280]  пока. Может быть... Короче, не знаю, никак не могу прокомментировать. Ну, реально,
[35:15.280 --> 35:22.640]  более красиво было бы просто вынести вот этот вот if в функцию. Ну, кажется, что было бы красивее
[35:22.640 --> 35:31.360]  написать выше constexpr-bool requirement-satisfied равно requires-blah-blah-blah, а потом if constexpr-requirement-satisfied
[35:31.360 --> 35:38.200]  сделать одно иначе другое. Вот так. Ну, под if писать вот эту вот огромную хрень, это очень
[35:38.200 --> 35:44.760]  странно выглядит. Поняли, что я имел в виду? Ну, то есть, логично завести здесь переменную.
[35:44.760 --> 35:51.880]  Я просто к тому, что под if писать вот эту странную конструкцию как-то очень криво
[35:51.880 --> 35:56.640]  выглядит. Но формально можно, должно заработать. Давайте проверим. Сейчас будет смешно, если оно
[35:56.640 --> 36:02.320]  не заработает. А, нет, оно заработало, мы уже проверили. Ну, то есть вот requires-expression.
[36:02.320 --> 36:18.920]  Вот. Давайте посмотрим, какие еще можно требования перечислять в requires-expression.
[36:18.920 --> 36:23.120]  Сейчас я открою соответствующую статью cpp-reference.
[36:35.040 --> 36:48.000]  Значит, так. Ну, давайте посмотрим на это перечисление. Действительно, лучше просто
[36:48.000 --> 36:58.360]  показать, чем я буду пытаться это все перечислять руками. Сейчас, значит, я расшарю экран. И вот эту
[36:58.360 --> 37:05.120]  вот статью, страницу мы посмотрим. Значит, это страница cpp-reference, которая называется constraints-and-concepts.
[37:05.120 --> 37:12.120]  Вот. Пока я не говорил о том, что концепт, пока мы игнорируем часть про концепту. Сейчас я как раз
[37:12.120 --> 37:17.440]  про нее следующим шагом расскажу. Вот. Пока мы говорим только про requirements. Вот смотрите,
[37:17.440 --> 37:25.320]  какие могут, можно делать requirements. Ну, пока что такое концепт мы игнорируем, мы смотрим только
[37:25.320 --> 37:31.880]  на вот это выражение. Вот. Можно потребовать существования внутреннего типа. TypeName t2.hinner.
[37:31.880 --> 37:40.200]  Вот это то, что я сделал. Можно потребовать typeName s от t. Потребовать, чтобы существовала специализация.
[37:47.440 --> 37:59.760]  Значит, or that a class template specialization names a type. Ну, что существует, значит, специализация s таким t.
[37:59.760 --> 38:09.560]  Наверное, это вряд ли означает, что существует... Да, это скорее всего означает, что просто такой
[38:09.560 --> 38:15.120]  тип validin. Не что существует специализация выделенная, что просто такой тип validin. Было бы странно.
[38:15.120 --> 38:24.480]  А как он может быть validin? Там тебе можно в шаблонах писать тоже requirements? Ну, например... Да-да,
[38:24.480 --> 38:34.800]  requirements можно в шаблонах писать, кстати. В общем, не знаю, что это значит. Не знаю, не буду гадать.
[38:34.800 --> 38:41.960]  Вот. Ну, давайте на другие примеры посмотрим. Вот, например, вот у меня есть common type. Что такое
[38:41.960 --> 38:50.600]  common type? Это sd common type t от tu. Да, понятно. Объявили такой alias. Значит, теперь мы пишем requires.
[38:50.600 --> 38:58.720]  Что мы хотим? typeName common type от tu. Да, вот хотим, чтобы common type от tu был valидным и names a type.
[38:58.720 --> 39:09.000]  Ну, например, вдруг common type от tu это не тип, а константа числовая. Банальный пример. Это может
[39:09.000 --> 39:16.080]  быть не names a type. Что-то другое. Что? Как это возможно? Ну, в смысле, я тебе сказал, что common type от tu это
[39:16.080 --> 39:25.480]  bool. Это не using, а bool. Я же пишу код, я же не знаю. Я хочу, чтобы common type это был тип. Чтобы common type
[39:25.480 --> 39:34.200]  от tu был корректный тип. Вот всё, что я сейчас здесь потребовал. Ну, пока не вижу проблем. Ну, типа,
[39:34.200 --> 39:42.240]  понятно вроде нормально. Ты сказал, что чем ещё он может быть? Ну, common type tu может быть bool. Я могу
[39:42.240 --> 39:53.160]  написать template typeName t typeName u bool. Const bool common type равно false. Ну, это булевская шаблонная
[39:53.160 --> 40:05.040]  константа, как из класс V, может быть. Вот, а дальше что я потребовал? Дальше я потребовал, что вот это я
[40:05.040 --> 40:23.160]  сделал, кстати говоря. Ну, я проверил, что common type конструируется от... ну да, я проверил,
[40:23.160 --> 40:29.520]  что common type tu можно создать от вот этого, и проверил, что common type tu может создать от вот этого.
[40:29.520 --> 40:43.480]  Вот. Непонятно, правда, почему я в фигурных скобочках во внешних это всё написал. Ну, здесь,
[40:43.480 --> 40:50.680]  наверное, перечислено. Да, собственно, simple requirement, type requirements, compound requirements,
[40:50.680 --> 40:58.400]  nested requirements. Вот, simple requirement это просто когда я написал expression. Type requirements это
[40:58.400 --> 41:14.280]  когда я написал... да, это вот считается type requirements. Не знаю, почему это во внешних
[41:14.280 --> 41:21.800]  фигурных скобочках написано здесь. Ну, значит, так надо. А не как? Ну, просто common type tu и вот это
[41:21.800 --> 41:28.160]  вот всё, казалось бы. А, я понял, потому что тогда бы он воспринял это как simple requirement, вероятно.
[41:28.160 --> 41:36.920]  Значит, simple requirement. Я могу просто потребовать, что expression валиден, а дальше я могу потребовать,
[41:36.920 --> 41:42.560]  что type валиден, что type существует и валиден либо написать type name, либо написать внешние
[41:42.560 --> 41:54.000]  фигурные скобочки и написать какой-то type. Видимо. Честно говоря, я всё ещё не понимаю,
[41:54.000 --> 42:01.000]  зачем здесь внешние фигурные скобочки. Ну, чёрт с ним. Вот, могу сделать compound requirement. Что
[42:01.000 --> 42:08.280]  такое compound requirement? Это я, значит, ну, вот тут придётся видимо пропустить эту секцию, потому
[42:08.280 --> 42:16.240]  что здесь я, ну, я могу потребовать, чтобы некоторое выражение было само удовлетворяло какому-то
[42:16.240 --> 42:22.680]  требованию. Вот, но для этого мне придётся объяснить что концепты. Вот, пока мы концепты ещё не
[42:22.680 --> 42:28.920]  обсудили, я, наверное, пропущу этот кусок. Ну, если вкратце, то здесь, да, написано, я могу
[42:28.920 --> 42:36.360]  потребовать, чтобы вот expression был удовлетворял концепту. Вот, ну и я могу делать nested requirements.
[42:36.360 --> 42:45.040]  Это я могу внутри requires написать ещё requires. То есть, вот у меня есть requires, а я внутри него
[42:45.040 --> 42:52.000]  пишу снова requires. Зачем я это пишу? Потому что, если бы я не написал requires, внутренний requires,
[42:52.000 --> 42:58.680]  то это бы означало, что я просто хочу проверить валидность вот этого вот. А когда я пишу внутренний
[42:58.680 --> 43:10.800]  requires, я требую, чтобы это было true. То есть, я говорю requires blah blah blah. И, например, requires
[43:10.800 --> 43:18.400]  is same where от чего-то там чего-то там. Если я просто напишу внутри requires is same where от чего-то там
[43:18.400 --> 43:24.320]  чего-то там, он просто проверит валидно ли это, а не проверит true это или false. А если я ещё
[43:24.320 --> 43:31.400]  под requires напишу это, то это будет означать, что я требую, что это true, а не просто что это
[43:31.400 --> 43:38.480]  валидная штука. Вот, я могу проверить, что что-то noexcept вот таким способом. Я могу говорю в
[43:38.480 --> 43:45.680]  фигурных скобочках noexcept. Тем самым, я проверяю, что вот эта вся штука это noexcept.
[43:50.760 --> 43:57.680]  Ну и вот то же самое. Я говорю requires там same blah blah blah requires same. И ещё проверяю,
[43:57.680 --> 44:10.680]  что вот такая вот вещь валидная. Ещё бы ещё раз мысль фигурных скобочек ещё одних.
[44:10.680 --> 44:19.760]  Всё, надеюсь, в лишних фигурных скобочках. Мы пока не поняли, что это. Да, я тоже пока не
[44:19.760 --> 44:28.600]  понял, что это. Видимо, я понял, но забыл в какой-то момент, зачем это нужно. Compound requirement.
[44:28.600 --> 44:42.400]  Почему это compound requirement? Так, сейчас. Сейчас, давайте быстренько посмотрим. Наверное,
[44:42.400 --> 44:48.280]  тут должно быть объяснено, что означают для него лишние фигурные скобочки. Значит,
[44:48.280 --> 45:00.560]  simple requirement. It asserts that expression is valid. Requirement blah blah blah. Type requirement.
[45:00.560 --> 45:21.600]  А, это compound requirement. Это не type requirement, это compound requirement называется. Вот если оно
[45:21.600 --> 45:25.500]  в фигурных скобочках, то это как раз третий вариант. Это называется compound requirement.
[45:25.500 --> 45:31.060]  Собственно, вот. В фигурных скобочках expression, а дальше, возможно, no accept и, возможно,
[45:31.060 --> 45:38.500]  требование к возвращаемому типу. Значит, я пишу в фигурных скобочках expression и это заставляет
[45:38.500 --> 45:48.340]  его проверить какие-то свойства данного выражения. В следующем порядке выполняется подстановка и
[45:48.340 --> 45:56.460]  проверка. Значит, сначала подставляются шаблонные аргументы в этот expression. Если no accept использован,
[45:56.460 --> 46:07.940]  то expression должен быть no accept. Если return type представлен, то еще проверяется это. А я думаю,
[46:07.940 --> 46:15.580]  вот зачем нужны фигурные скобочки, потому что я использую t внутри expression. Я думаю, вот зачем.
[46:15.580 --> 46:43.500]  А иначе бы что произошло? Потому что, видимо, иначе бы он не подставил. Нет,
[46:43.500 --> 46:48.420]  no accept понятно, как проверить. Вот здесь вот зачем фигурные скобочки, я все еще не понимаю.
[46:48.420 --> 46:55.220]  Ну, черт с ним. Ну, можно быстро проверить на самом деле, в чем разница. Но я не уверен,
[46:55.220 --> 47:02.780]  что сейчас мы это быстро распознаем. Ну, давайте, я не знаю, например, вот здесь вот. Ну, скажем,
[47:02.780 --> 47:16.980]  вот здесь. Давайте я проверю, что t обладает деструктором. Что x.tilde t это корректное выражение.
[47:16.980 --> 47:34.940]  Давайте проверим, что будет. 1, 2. Так, а если я фигурных скобочках напишу, то тоже, видимо,
[47:34.940 --> 47:43.140]  будет 1, 2. Ладно, я не знаю, в чем разница. Возможно, они, блин, для красоты это написали.
[47:43.140 --> 47:52.340]  А можно убрать все остальное? Все, кроме проверки деструктора? Да, пожалуйста.
[47:55.860 --> 48:06.220]  Ну и, понятное дело, опять с и без. Так, понятно, должно работать. А без?
[48:13.140 --> 48:26.180]  Ну, все одинаково. Сейчас, секунду. 1, 2, 1, 1. Мы вообще вызываем их в каком порядке?
[48:26.180 --> 48:33.460]  Так, там кто-то нам в чате что-то пишет явно. Нет, ничего не поменялось. Просто от того,
[48:33.460 --> 48:38.820]  что я... Теперь он стал под int подходить тоже. Вот что поменял. Под string стал подходить.
[48:38.820 --> 48:45.260]  У int есть деструктор? Да, вызов деструктора int это корректно. Иначе бы, когда ты писал вектор,
[48:45.260 --> 48:48.900]  у тебя было бы CE, как только ты вектор int'ов пытаешься делать. Убедительно.
[49:08.820 --> 49:34.460]  Что такое существование? Я все еще не понял. Разницу, мне кажется... Нет, мне кажется,
[49:34.460 --> 49:40.540]  что-то разница в чем-то другом, если она есть. Мы ее не видим. Но я предлагаю забить и начать
[49:40.540 --> 49:45.820]  говорить про концепты, потому что, значит, мы не успеем. Все, короче, про requires я все,
[49:45.820 --> 49:53.580]  что хотел, сказал. Вот. Если поймете, в чем разница, напишите в чат. Ну или кто-нибудь в комментариях
[49:53.580 --> 50:03.740]  напишет потом под этой лекцией, в чем разница. Теперь концепты. Что такое концепты? Концепты
[50:03.740 --> 50:18.700]  это, по сути, именованные наборы requirements. У меня есть requirement. Какой-нибудь. Вот,
[50:18.740 --> 50:27.460]  допустим, я хочу, чтобы мой тип был, ну, я не знаю, удовлетворял концепт под ключевое слово. Да. Я
[50:27.460 --> 50:38.420]  хочу, чтобы мой тип был, ну скажем, incrementable. Не знаю, вот хочу такое требование. Ну, я могу
[50:38.420 --> 50:45.980]  много там разных штук придумать. А, ну давайте, вот, давайте я, например, вот какую вещь сделаю,
[50:45.980 --> 50:57.700]  потребую от своего типа, чтобы он был, ну скажем, сравнимым на equality comparable. Вот я хочу написать
[50:57.700 --> 51:03.900]  такую штуку, вот, чтобы мне не повторять сто пятьсот раз, что вот моя функция должна работать только
[51:03.900 --> 51:12.700]  для типов, которые удовлетворяют следующему набору свойств. Я говорю, требую, чтобы мой тип был
[51:12.700 --> 51:26.260]  equality comparable от t. Equality comparable от t это некоторая новая сущность, она называется концептом. Я
[51:26.260 --> 51:33.980]  могу объявлять концепты, и концепты будут состоять из requirements. Я пишу template, type name t,
[51:33.980 --> 51:58.140]  concept equality comparable равно requires от t, x. Ну, вот так могу написать. Ну, или в одну строчку даже
[51:58.140 --> 52:16.140]  напишу t, x, t, y. Значит, x равно равно y, x не равно y. Вот я... Что-то не так. Так, и что же не так?
[52:16.140 --> 52:33.900]  Да, значит, концепт пишется так. Я говорю, template, type name t, concept, название концепта, а дальше равно и,
[52:33.900 --> 52:41.700]  ну, я могу вообще и bool написать. Я могу написать здесь std из класс v, что-нибудь там. Так тоже можно.
[52:41.700 --> 52:50.060]  Ну, вы и написали bool. Вы же и написали. Я понимаю, но я говорю, что кроме requires можно и другое
[52:50.060 --> 52:54.380]  писать. Здесь это не то, что требование обязательно requires писать. Я вам сейчас покажу некоторые
[52:54.380 --> 52:59.060]  стандартные концепты, вы увидите, как они определены. Это забавно будет. Например, есть стандартный
[52:59.060 --> 53:06.340]  концепт derived from. Он почти как из базов, только еще в него добавлено, что это публичное
[53:06.340 --> 53:10.980]  расследование неприватное. Да, он проверяет конструируемость. Мы даже видели только что на
[53:10.980 --> 53:26.140]  примере common type. А чем концепт отличается от просто using? Сейчас увидите. Если не подставляется,
[53:26.140 --> 53:35.420]  то false, скорее всего. Ну, давайте я продемонстрирую, что это работает. Вот у меня есть template,
[53:36.020 --> 53:44.900]  requires equality comparable t и какая-нибудь другая штука. Ну и давайте я сделаю структуру s,
[53:44.900 --> 53:56.860]  которая не equality comparable. Ну и продемонстрирую. Вызовусь от s и вызовусь от inta снова. И мы увидим,
[53:56.860 --> 54:07.620]  что сейчас я в одном случае попаду в одну версию, в другом в другую. В случае с s я попал
[54:07.620 --> 54:13.460]  во вторую, потому что на ней equality comparable. В первом случае я попал в первую версию,
[54:13.460 --> 54:21.140]  потому что на equality comparable. Концепты – это очень крутая штука, потому что она позволяет вам
[54:21.540 --> 54:31.340]  очень красиво писать. Во-первых, вот то, что я сейчас написал – это, так скажем,
[54:31.340 --> 54:39.580]  развернутая форма использования концепта. Существует сокращенная форма, которая мне кажется,
[54:39.580 --> 54:54.180]  и плюс-минус и будет всеми принята как стандартная. Я могу в шаблоне писать. Вот смотрите,
[54:54.180 --> 55:04.220]  вам наверняка хотелось раньше, когда вы пишете template typeNameT, typeNameU, если вы требуете от t и u
[55:04.220 --> 55:11.460]  быть какими-то особенными типами, а не просто произвольными типами, то вам, наверное, хотелось бы
[55:11.460 --> 55:17.900]  это как-то в самом заголовке шаблона указать. Наверняка вы уже, если вы достаточно долго этим
[55:17.900 --> 55:23.780]  занимались, то вас наверняка должно было раздражать, когда вы видите template typeNameInputEther,
[55:23.780 --> 55:35.300]  typeNameOutputEther, что-то там. Сами имена inputEther и outputEther никак не отражают смысл. То есть это
[55:35.300 --> 55:39.780]  просто договоренность, что мы так называем шаблонные параметры в стандартных алгоритмах,
[55:39.780 --> 55:47.140]  чтобы они соответствовали тому, что мы от них ожидаем. Но ведь назвать inputIterator шаблонный
[55:47.140 --> 55:50.780]  параметр в стандартном алгоритме – это просто договоренность. Я могу любое имя туда подставить.
[55:50.780 --> 55:58.060]  Но теперь в C++20 я могу говорить inputIterator прямо в заголовке шаблона. То есть я говорю
[55:58.060 --> 56:10.420]  templateEqualityComparableT без всякого requires void f of t, x. Это эквалентно тому, что раньше
[56:10.420 --> 56:18.300]  было написано. То есть я говорю, у меня есть template для equalityComparableT, а есть template для
[56:18.300 --> 56:31.260]  произвольного t. В частности, теперь я могу, например, написать такую... ну, я могу, например,
[56:31.260 --> 56:43.940]  определить концепт inputIterator, скажем. Да, вот я могу сказать, давайте я заведу концепт inputIterator.
[56:43.940 --> 56:52.620]  Ведь по сути inputIterator – это же концепт. Ведь это вот то, что нам очень долго не хватало. Мы
[56:52.620 --> 56:59.300]  хотели бы, чтобы у нас вот это вот название inputIterator было чем-то. У нас до сих пор были
[56:59.300 --> 57:05.180]  named requirements в языке. У нас был named requirement – контейнер, named requirement – аллокатор,
[57:05.180 --> 57:10.340]  named requirement – inputIterator. Теперь мы это все можем выразить в виде концептов. То есть если мы
[57:10.340 --> 57:17.980]  ожидаем от типа, что он говорит какому-то набору констрейнтов, то мы говорим, этот набор констрейнтов
[57:17.980 --> 57:23.580]  мы назовем концептом. Вот назовем концептом inputIterator штуку, которая умеет разыменовываться,
[57:23.580 --> 57:33.860]  инкрементироваться и еще что-нибудь делать. Разыменованному X можно что-нибудь присваивать,
[57:33.860 --> 57:51.140]  не знаю. Ну, звездочка X равно там что-нибудь. Звездочка X. Вот так, например, я могу делать.
[57:51.140 --> 57:59.820]  Вот. Ну, еще стрелочку надо проверить, наверное, как-нибудь. Ну, в общем, ну, неважно. В общем,
[57:59.820 --> 58:11.220]  мы перечисли какие-то штуки, которые я хочу здесь от inputIterator. Теперь, когда я пишу свой шаблонный
[58:11.220 --> 58:20.740]  алгоритм какой-нибудь inputIterator, там Iter. Ну, тут, конечно, проблемы с именами будет. Iter 1. Ну,
[58:20.740 --> 58:42.660]  я могу сказать inputIterator. Iter. OutputIterator. Неважно, вот так просто сделаю. И какой-нибудь
[58:42.660 --> 58:57.460]  алгоритм void что-нибудь, я не знаю. FindIf. А, например, вот FindIf. Я хочу, у меня есть inputIterator,
[58:57.460 --> 59:10.740]  а еще есть predicate. Я сделал концепт inputIterator и сделал концепт predicate. Унарный predicate,
[59:10.740 --> 59:22.060]  который там от какого-нибудь, ну, от чего-то умеет вызываться. Не знаю, isInvocable с какими-то там
[59:22.060 --> 59:29.340]  параметрами. Ну, тут надо подумать, как это выразить. Ну, в общем, to do. Ну, давайте я напишу,
[59:29.340 --> 59:38.820]  не знаю, true просто. Ну, вот у меня, допустим, есть концепт inputIterator, есть концепт унарный
[59:38.820 --> 59:47.300]  predicate. Теперь, когда я пишу FindIf, мне не надо вот этих вот искусственных имен, что input,
[59:47.300 --> 59:54.900]  что Iter это inputIterator, pred это действительно predicate. Я просто за счет концептов потребовал
[59:54.900 --> 01:00:01.900]  от типов того, чего мне нужно. И если я попробую вызваться, вызвать этот метод от не тех типов,
[01:00:01.900 --> 01:00:10.980]  от которых можно, то мне скажет компилятор, что requirement не выполнен, поэтому от такого
[01:00:10.980 --> 01:00:18.940]  типа вызываться нельзя. Илья, я сказал, что давайте проверим ещё, ну, тебе нужно ещё проверить,
[01:00:18.940 --> 01:00:35.860]  что существует стрелочка. Я задумался и не придумал, как. Вот стрелочку действительно непонятно,
[01:00:35.860 --> 01:00:48.540]  как проверить, потому что непонятно, чего её вызывать. Поэтому я не знаю действительно,
[01:00:48.540 --> 01:00:52.420]  как стрелочку проверить. Но, в принципе, как с унарным предикатом, не очень понятно,
[01:00:52.420 --> 01:00:58.260]  как его проверить, потому что предикат нужно от чего-то вызывать. Вот, написать что-то в стиле,
[01:00:58.260 --> 01:01:07.340]  существует такой тип, что унарный предикат от него будет нормально работать. Ну. Илья, можно
[01:01:07.340 --> 01:01:17.820]  просто ещё. Как работает? Это же есть find if, верно? Что в него передаётся? Два итератора и? Ну и предикат.
[01:01:17.820 --> 01:01:26.540]  Что такое предикат? Ну, в смысле, функциональный объект. И предикат от чего? От value type, верно? От
[01:01:26.540 --> 01:01:35.820]  value type, да. Фух, и мы идём и проверяем, что-что. Что? Предикат от очередного value type. А, разменование?
[01:01:35.820 --> 01:01:41.620]  Да, конечно, мы идём. Он не пользуется стрелочкой. Обычный find if не пользуется стрелочкой. Да нет,
[01:01:41.620 --> 01:01:47.500]  не пользуется. Это смешало. Понимаешь, окей. Да, ну возвращает он не void, а возвращает снова iter.
[01:01:47.500 --> 01:01:54.980]  Вот, тут надо не запутаться. Тут надо, значит, вот здесь может начаться путаница, потому что у
[01:01:54.980 --> 01:02:04.660]  нас возникла ещё одна сущность, концепт. Вот iter это тип, а input утератор это концепт. Я возвращаю
[01:02:04.660 --> 01:02:11.420]  именно iter, а не input утератор теперь. Input утератор это концепт. А принимаю я типы и возвращаю тип.
[01:02:11.420 --> 01:02:23.820]  Вот. Ну, давайте посмотрим на какие-нибудь стандартные концепты, которые есть в языке.
[01:02:23.820 --> 01:02:38.020]  Я ещё, правда, вижу, что поэтому есть перегрузка. Да, всё так, сейчас мы это обсудим. Да, так,
[01:02:38.020 --> 01:02:44.660]  сейчас только я потерял... где у меня... да что ж такое-то?
[01:02:44.660 --> 01:02:56.180]  Так, сейчас мы посмотрим на... да, замечательно, мы пришли туда же.
[01:02:56.180 --> 01:03:07.700]  Где? Concept library, вот она. Вот, давайте посмотрим на то, какие у меня есть концепты стандартные,
[01:03:07.700 --> 01:03:17.900]  уже определённые в языке, C++20. Вот есть std same-as. Вот. Что такое концепт same-as? Это
[01:03:17.900 --> 01:03:26.660]  такой концепт, который выполнен тогда и только тогда, когда ты и у одинаковый тип. Вот. Ну,
[01:03:26.660 --> 01:03:38.460]  по сути, это наш старый добрый isSame просто по-новому записанный. Ну, можно same-as выразить
[01:03:38.460 --> 01:03:46.620]  через него. Вот, собственно, здесь написано. Same-as. Что такое same-as? Это same-helper tu и same-helper ut.
[01:03:46.620 --> 01:03:57.580]  Не знаю, зачем они сделали в две стороны, честно говоря, но по сути same-as это и same-where. Вот есть
[01:03:57.580 --> 01:04:04.260]  концепт derivedFrom. Это наш старый добрый isBasedOf, только наоборот, и с дополнительным условием,
[01:04:04.260 --> 01:04:09.780]  что приватное наследование мы не распознаём теперь. Что такое концепт derivedFrom? Это isBasedOf
[01:04:09.780 --> 01:04:15.180]  where base derived наш старый добрый и конъюнкция. Кстати, конъюнкцию можно без скобок здесь
[01:04:15.180 --> 01:04:25.500]  использовать. И, кстати, конъюнкция здесь работает не так, как... Вот конъюнкция в
[01:04:25.500 --> 01:04:33.300]  requirement-ах работает не так, как конъюнкция в обычном смысле. Она не падает, если там CE. Вот это
[01:04:33.300 --> 01:04:42.260]  важно очень тоже. Ну вот, isBasedOf и isConvertible. Ну, то есть, как мы... У нас был isBasedOf,
[01:04:42.260 --> 01:04:48.500]  который распознаёт, в том числе, приватное и амбигиус наследования. Как мы из него... Как мы его
[01:04:48.500 --> 01:04:52.340]  исправим так, чтобы оно перестало распознавать приватное наследование? Мы просто добавим
[01:04:52.340 --> 01:05:00.500]  конъюнкцию, что ещё isConvertible, isConstDerived, constBased звёздочка. Вот. Note that this behaviour is different
[01:05:00.500 --> 01:05:07.260]  from isBasedOf, потому что если база — это приватная или защищенная база, то она не распознается. Вот вам
[01:05:07.260 --> 01:05:14.900]  примеры. Вот. Ну, много из концептов, которые тут есть стандартные. Вот, пожалуйста, common,
[01:05:14.900 --> 01:05:22.340]  common with, integral, sign-integral. Собственно, вот все эти вещи, copy-constructible, move-constructible. Вот,
[01:05:22.340 --> 01:05:29.220]  по сути, что такое концепт copy-constructible? Это move-constructible, и вот часть из этого концепта,
[01:05:29.220 --> 01:05:37.620]  часть из этого... Ну, это всё уже концепты. Часть из этого... Почему copy-constructible,
[01:05:37.620 --> 01:05:45.180]  это move-constructible и что-то ещё? Я не знаю, почему они так сделали. Ну, наверное, у них были какие-то
[01:05:45.180 --> 01:05:51.100]  весомые аргументы так сделать. Вот copy-constructible — это не просто из copy-constructible, который раньше,
[01:05:51.100 --> 01:05:57.900]  они добавили к нему ещё дополнительные требования, навесили. Ну, хорошо, вот destructible. Ну,
[01:05:57.900 --> 01:06:04.220]  destructible — это просто то, что раньше называлось isNullThroughDestructibleWay, а теперь называется просто destructible.
[01:06:04.220 --> 01:06:12.980]  Вот, но есть и более интересные концепты. А, вот, например, концепт copyable. Да, это copy-constructible,
[01:06:12.980 --> 01:06:19.300]  moveable, assignNullFrom. Ну, тут много всего. Но в конечном счёте это всё выражается через наши старые добрые
[01:06:20.060 --> 01:06:31.540]  просто более удобным способом. Вот, и давайте посмотрим на итераторы. Вот, я вам говорил, что есть...
[01:06:31.540 --> 01:06:39.500]  Значит... Так, сейчас у нас... Что, у нас интернет отваливается, что ли?
[01:06:39.500 --> 01:06:50.980]  Библиотека итераторов. Вот legacyInputIterator, legacyOutputIterator. Меня вы спрашивали там где-то зимой,
[01:06:50.980 --> 01:06:56.140]  почему они legacy. Ну, потому что их заменили концепты в C++20. Вот то, что раньше называлось
[01:06:56.140 --> 01:07:06.860]  namedRequirements, legacyInputIterator, legacyForwardIterator, сейчас стало заменено концептами. Например,
[01:07:06.860 --> 01:07:19.140]  есть концепт inputIterator. Это концепт, который... Ну, он много чего проверяет. Вот, тут... Сложно
[01:07:19.140 --> 01:07:24.500]  разобраться, но если вкратце, то он проверяет все требования inputIterator, которые можно проверить
[01:07:24.500 --> 01:07:30.060]  в compile-time, что у вас всё, что нужно, определено, что у вас input or outputIterator, то есть это общие
[01:07:30.060 --> 01:07:36.620]  требования для них indirectlyReadable, что-то ещё, и derivedFromInputIteratorTag, если взять
[01:07:36.620 --> 01:07:41.780]  там вот... Если, короче, в IteratorTrades взять вашу IteratorCategory, то, видимо, она будет
[01:07:41.780 --> 01:07:50.020]  наследницей stdinputIteratorTag. Вот, пожалуйста, inputIterator — это такой концепт. Что тут написано,
[01:07:50.020 --> 01:07:56.420]  секундочку. ForwardIterator — это вот такой концепт. Там какой-то очень непонятный синтез был. Где?
[01:07:56.420 --> 01:08:08.780]  Вот, например, std derivedFrom. Да, в inputIterator. Да. std derivedFrom, typeName, комментарий. Нет,
[01:08:08.780 --> 01:08:19.020]  requires. Нет, подожди, тут requires ещё вложенный. Да. А что оно required? Ну, IterConcept — это какой-то
[01:08:19.020 --> 01:08:24.380]  внутренний компиляторный тип, который мы не знаем, как называется. IterConcept — это штука,
[01:08:24.380 --> 01:08:32.580]  которая... Какой комментарий? В смысле, это то, что нельзя здесь назвать. Это некоторый внутренний
[01:08:32.580 --> 01:08:39.500]  компиляторный тип, который мы не знаем, как называется. Как-то он называется. Ну, в смысле,
[01:08:39.500 --> 01:08:48.980]  это псевдокод, а не обычный код, разумеется. А кода нет? Этот тип как-то называется внутри
[01:08:48.980 --> 01:08:55.900]  компилятора. Мы не знаем, как. Он нестандартный. Это тот тип, который бы у компилятора существует
[01:08:55.900 --> 01:09:01.460]  из-за того, что он operator.trades там инстанцировал. Сейчас, секунду. Концепт этот написан на языке
[01:09:01.460 --> 01:09:07.860]  C++, верно? Конечно. Просто вот этот тип... Это его код настоящий. Нет, это псевдокод, потому что
[01:09:07.860 --> 01:09:14.940]  IterConcept — это тип, который... Ну, хорошо, вот std.visit. Вы видели, как все переференс описан? Нет,
[01:09:14.940 --> 01:09:21.700]  потому что он сказал, что это очень страшно. Ну, здесь то же самое написано. Вот это же не настоящий
[01:09:21.700 --> 01:09:26.940]  код. Возвращаемый тип, который мы не можем здесь назвать, потому что он сложно очень
[01:09:26.940 --> 01:09:32.980]  определяется, и это компилятор решает, как его определить. То же самое с Invoke или с чем-нибудь
[01:09:32.980 --> 01:09:41.780]  еще там. Это псевдокод, потому что тип, который здесь... NoExcept в зависимости от... Смотрите вниз,
[01:09:41.780 --> 01:09:49.700]  от чего. Потому что это там... Забота компилятора. Правильно написать что-то там. Я не могу написать
[01:09:49.700 --> 01:09:56.060]  свою версию. Ты можешь написать свою версию, если ты напишешь свой Iterator.trades, аналогичный
[01:09:56.060 --> 01:10:01.460]  компиляторным Iterator.trades. В них у тебя будет какой-то мега супер-стрёмный тип, который обозначает
[01:10:01.460 --> 01:10:15.900]  то, что надо. Вот он здесь будет фигурировать. Вот. Чем круты концепты еще? Можно делать перегрузку
[01:10:15.900 --> 01:10:23.140]  по концептам. И здесь, поскольку у нас время почти закончилось, давайте я вам покажу тот самый файл,
[01:10:23.140 --> 01:10:39.540]  который у меня был заранее заготовлен. Я его снова скопирую из старой папки. Сюда. Не скопирую,
[01:10:39.540 --> 01:10:49.420]  потому что я затруэт. Ну, я просто покажу его. Смотрите, какая замечательная штука. Я могу делать
[01:10:49.420 --> 01:11:00.740]  концепты, которые включают в себя, в конъюнцию другие концепты. Вот в этой конъюнции, вот в этих
[01:11:00.740 --> 01:11:08.220]  вот Requirements, так вот это я затру, чтобы не смущало никого. Это прошлогодний просто код. Вот в этих
[01:11:08.220 --> 01:11:15.340]  концептах, когда я пишу равно и требования перечисляю, я в конъюнции могу другие концепты
[01:11:15.340 --> 01:11:20.820]  использовать. То есть, на самом деле, строго говоря, не только булевские выражения я могу здесь
[01:11:20.820 --> 01:11:26.660]  использовать. Я могу использовать булевские expression либо другой концепт. Когда я определяю концепт,
[01:11:26.660 --> 01:11:34.020]  ну или когда я делаю Requires, я могу использовать концепт. Например, я говорю bidirectional iterator
[01:11:34.020 --> 01:11:40.340]  это forward iterator и еще требование, что его декрементировать можно. А random access iterator
[01:11:40.340 --> 01:11:46.700]  это bidirectional iterator и еще требование, что можно прибавлять к нему число, вычитать, сравнивать
[01:11:46.700 --> 01:11:55.420]  на меньше. И давайте вернемся к старому нашему доброму примеру с advance и distance. Вот функция
[01:11:55.420 --> 01:12:06.580]  advance. У меня есть итератор, его нужно продвинуть на n. У меня есть две версии, одна для bidirectional
[01:12:06.580 --> 01:12:14.980]  iterator, другая для random access iterator. Но здесь forward iterator на самом деле, наверное, надо. Давайте
[01:12:14.980 --> 01:12:21.660]  скажем bidirectional. То есть, у нас там была какая проблема? В C++11 она решалась вообще с тремной
[01:12:21.660 --> 01:12:28.820]  перегрузкой. В C++17 появилась ifconstext. Но с концептами я могу вообще очень сделать красиво,
[01:12:28.820 --> 01:12:39.900]  без всякого if. Я пишу template bidirectional iterator и реализую одну версию, а template random access
[01:12:39.900 --> 01:12:45.940]  iterator реализую другую версию. И смотрите, это работает. То есть, если я сейчас вызовусь от
[01:12:45.940 --> 01:12:53.340]  листа, у которого bidirectional iterator, то my advance будет первой версией. А если я вызовусь от
[01:12:53.340 --> 01:12:59.740]  вектора, то my advance вызовется второй версией. Давайте я продемонстрирую, что действительно так
[01:12:59.740 --> 01:13:23.940]  работает. В первом случае вызвался, значит, my advance первой версии, во втором случае my advance
[01:13:23.940 --> 01:13:33.820]  второй версии. А как он догадался? Как компилятор понял, что вторая версия более частная, чем первая?
[01:13:33.820 --> 01:13:38.460]  Вот здесь опять сработало правило частное предпочтительнее общего. Но мы с вами говорили,
[01:13:38.460 --> 01:13:44.220]  что если написать requires и какую-то конъюнкцию, то он не поймет, что оно предпочтительнее. Но если
[01:13:44.220 --> 01:13:52.140]  написать на концепты, то он поймет. И это, кстати, ответ на твой вопрос. Как сделать, что сначала я
[01:13:52.140 --> 01:13:59.060]  проверяю, если у меня тип вообще, потом я проверяю, есть ли у меня этот тип и что-то еще, и третья версия
[01:13:59.060 --> 01:14:05.340]  для всего остального. На концептах это можно сделать. Для этого мне нужно, чтобы один концепт был,
[01:14:05.340 --> 01:14:13.460]  имел вид другой концепт, конъюнкция, что-то еще. Вот если у меня концепты представляют из себя
[01:14:13.460 --> 01:14:22.700]  другие концепты, объединенные конъюнкцией с какими-то дополнительными условиями, то он понимает,
[01:14:22.700 --> 01:14:30.980]  какой концепт более частный, какой более общий. Это называется, что один концепт subsumes другого.
[01:14:30.980 --> 01:14:36.460]  Он строит на самом деле частичный порядок на концептах. Это вообще просто пушка полная.
[01:14:36.460 --> 01:14:47.500]  Он, компилятор, на концептах устанавливает частичный порядок в зависимости от того, какие там были
[01:14:47.500 --> 01:14:58.140]  условия в этих концептах. Сейчас я вам покажу, ну давайте я опять открою страничку Concepts and
[01:14:58.140 --> 01:15:05.340]  Constraints, возможно я быстрее вот так на нее дойду. Нет, не быстрее, что-то себе переференс лежит.
[01:15:05.340 --> 01:15:14.820]  Да, значит Concepts and Constraints. Смотрите, есть понятие Atomic Constraints. Вот constraint,
[01:15:14.820 --> 01:15:25.740]  которое представляет в себе просто выражение, это Atomic Constraints. Ну, например, вот это вот
[01:15:25.740 --> 01:15:33.860]  requires что-то там, это атомарный constraint. Из атомарных констраинтов я строю концепты.
[01:15:33.860 --> 01:15:44.140]  И когда у меня концепт включает в себя другой концепт и еще какой-то Atomic Constraints, то он
[01:15:44.140 --> 01:15:52.460]  начинает упорядочивать констраинты по принципу, какое более частное, какое более общее. Это
[01:15:52.460 --> 01:15:58.420]  называется Constraint Normalization. Он берет, значит Constraint Normalization, это процесс, который
[01:15:58.420 --> 01:16:02.060]  трансформирует выражение с констраинтами в последовательность конъюнции и дизьюнции
[01:16:02.060 --> 01:16:09.380]  атомарных констраинтов. Дальше определяется, что нормальная форма этого выражения. Ну,
[01:16:09.380 --> 01:16:15.220]  по сути, он приводит его к какой-то конъюнтивной или дизюнтивной нормальной форме с этими
[01:16:15.220 --> 01:16:23.300]  констраинтами и упрощает, короче говоря, преобразовывает так, что понимает, кто из них более
[01:16:23.300 --> 01:16:31.260]  частный, какой более общий. Но вот утверждается, что если вы будете писать концепты, опираясь на
[01:16:31.260 --> 01:16:38.140]  другие концепты, то он справится. Вот компилятор, я не уверен, насколько это
[01:16:38.140 --> 01:16:42.980]  проформальное требование компилятору, что он должен уметь это все парсить, но на практике
[01:16:42.980 --> 01:16:49.980]  он уже справляется, что же плюс-плюс, что силенг. Если у вас одни концепты выражаются через другие,
[01:16:49.980 --> 01:16:58.180]  то он понимает, какие из них более частные. Вот такие дела. Таким образом, мы решили ту задачу
[01:16:58.180 --> 01:17:08.260]  гораздо лучше, чем раньше. Вот ну и последнее, это значит compound requirements, связанные с
[01:17:08.260 --> 01:17:14.300]  концептами. Вот здесь помните, когда мы говорили про compound requirements, здесь была возможность
[01:17:14.300 --> 01:17:20.860]  в requirements писать требование, что что-то выполнено над этим выражением. Вот здесь опять используются
[01:17:20.860 --> 01:17:27.100]  концепты. Я в requirements могу писать звездочка х, стрелочка, а дальше концепт. Вот здесь именно
[01:17:27.100 --> 01:17:34.780]  концепт нужно писать. Не какое-то тамбулевское выражение, а концепт. Я могу потребовать от внутри
[01:17:34.780 --> 01:17:41.020]  requirement составного, от какого-то выражения, чтобы оно удовлетворяло концепту. Например, что x плюс
[01:17:41.020 --> 01:17:58.180]  1 это same as int. А там x умножить на 1, то convertible, тут t. Вот такие дела с концептами. Ну,
[01:17:58.180 --> 01:18:07.180]  у нас, кажется, время закончилось, но, в принципе, я все, что хотел рассказал, там, за исключением мелких
[01:18:07.180 --> 01:18:13.100]  каких-то возможных деталей. Ну, возможно, я скину какую-нибудь еще пару статейчик вам почитать для,
[01:18:13.100 --> 01:18:25.300]  так сказать, более глубокого проникновения. Ну, и можно будет на этом закончить. В общем,
[01:18:25.300 --> 01:18:36.060]  начинайте пользоваться. Если будете писать последние задачи, да, условия варианта,
[01:18:36.140 --> 01:18:48.740]  я помню. В общем, если будете писать вариант или последнюю задачу, которую я еще тоже сейчас обдумаю
[01:18:48.740 --> 01:19:00.100]  и повыкладываю, то можно, наверное, будет пользоваться концептами уже там. Вот такие дела. Ну что,
[01:19:00.100 --> 01:19:12.940]  вопросы? Ну, тогда давай. У нас там было несколько неявных штук. У нас есть концепты от двух
[01:19:12.940 --> 01:19:17.140]  переменных. Мы, на самом деле, руками не писали ни одного концепта от двух переменных и не смотрели,
[01:19:17.140 --> 01:19:23.820]  как они работают. Вот, например, у нас есть концепт same as, который принимает два аргумента. А мы ему
[01:19:23.820 --> 01:19:31.140]  передаем один аргумент, а второй неявно. Вот у нас там есть стрелочка same as. Вот так что-то нам
[01:19:31.140 --> 01:19:48.140]  показывал. Сейчас. Сверху, чувствуешь? Нет. Да где? Так ладно, сейчас я поищу по странице просто. Да,
[01:19:48.140 --> 01:19:55.620]  вот оно. Same as, у которого два аргумента. Вторым не явно передается то, что получилось в результате
[01:19:55.620 --> 01:20:02.020]  выражения первого. Да, забавно. А вторым это с левой или справа? Я, кстати, не обращал на это внимание.
[01:20:02.020 --> 01:20:09.140]  Мы уже так делали, фактически. Когда у нас было ноль аргументов, и мы передавали один неявно,
[01:20:09.140 --> 01:20:15.980]  тогда все очевидно. Здесь у нас два аргумента, и мы один передаем неявно. Да, но вот тут... Да,
[01:20:15.980 --> 01:20:20.260]  кстати, это забавное замечание, потому что я даже не заметил. Я подумал, что там с одним... Да,
[01:20:20.260 --> 01:20:27.780]  значит, получается, что expression x plus one must be valid и same as... Ну да, вот он как это парсит,
[01:20:27.780 --> 01:20:34.500]  значит, decal type от вот этого и int must be satisfied. Ну да, это именно в requirements так делается,
[01:20:34.500 --> 01:20:40.340]  значит. Получается, что... Да, собственно, поэтому после стрелочки и должен идти requirement,
[01:20:40.340 --> 01:20:48.020]  потому что иначе он не понимает, что делать. Именно concept, да. Что-то Даниил Максимов говорит,
[01:20:48.020 --> 01:20:56.820]  код не компилится. Какой код не компилится? Вот этот? А у тебя плюсы двадцатые? А компилятор
[01:20:56.820 --> 01:21:03.900]  какой? Версию компилятора еще надо. Ну g plus plus десятый уже справляется. Кстати, год назад еще...
[01:21:03.900 --> 01:21:14.100]  Год назад еще не было std input-utterator. Ну то есть еще год назад, когда я рассказывал про вот это все на
[01:21:14.100 --> 01:21:22.860]  аналогичной лекции, не было... В STL еще не реализовали в моей, по крайней мере, версии STL, там с g plus
[01:21:22.860 --> 01:21:28.420]  plus, какими я не пробовал, или с C-Lang, не реализовали std input-utterator, std forward-utterator и так далее,
[01:21:28.420 --> 01:21:35.260]  поэтому свои я писал. Сейчас уже они есть, сейчас они уже распознаются и работают. Ну то есть это прям
[01:21:35.260 --> 01:21:41.740]  вот, ну вы понимаете, стандарты сдали два года назад, компиляторы, только вот в прошлом году более-менее
[01:21:41.740 --> 01:21:51.660]  начали поддерживать все то, что тут написано. Но наверняка еще очень много багов, то есть понятно,
[01:21:51.660 --> 01:22:00.900]  что такой фичи, как это, не может быть сразу с первого раза все идеально. Возможно, с 23-м что-нибудь
[01:22:00.900 --> 01:22:05.700]  придется чуть-чуть поменять, но это как с большим любым нововведением язык, как и с лямбдами было,
[01:22:05.700 --> 01:22:11.740]  как и с аллокаторами, как и с мосемантикой. Там через несколько лет обнаруживается, что некоторые
[01:22:11.740 --> 01:22:18.060]  идеи были не так уж хороши, и приходится чуть-чуть их корректировать. Ну то есть я думаю, здесь вы
[01:22:18.060 --> 01:22:24.300]  можете поэкспериментировать и открывать. Может быть, вы даже что-то придумаете, что-то сможете
[01:22:24.300 --> 01:22:33.820]  предложить в комитет, что они даже рассмотрят, потому что тут есть еще простор для корректировки
[01:22:33.820 --> 01:22:41.380]  и воображения и всего этого прочего довольно большой. Еще люди еще не наловчились с тем этим
[01:22:41.380 --> 01:22:51.900]  пользоваться, как полагается. Вот. Ну да, интересное замечание про вот это. Я даже не замечал, что здесь так.
[01:23:03.260 --> 01:23:03.760]  Ну ладно.
