[00:00.000 --> 00:15.000]  Сегодня у нас будет последняя лекция чисто по теории вычислимости. Дальше мы будем переходить к связи между вычислимостью и арифметикой.
[00:15.000 --> 00:28.000]  Мы сегодня изучим две теоремы. Одна теорема Райса Успенского о неразрешимости функциональных свойств программ.
[00:28.000 --> 00:40.000]  А вторая теорема Клиния о неподвижной точке. Одно из известных следствий из нее это то, что для любого языка программирования есть Куайм.
[00:40.000 --> 00:44.000]  То есть программа, которая печатает свой собственный текст.
[00:44.000 --> 00:56.000]  Начнем с одного важного определения, которое не явно мы раньше использовали, но сегодня будем использовать явно.
[00:56.000 --> 01:17.000]  Это определение называется главная универсальная вычислительная функция.
[01:17.000 --> 01:23.000]  По сравнению с тем, что уже было, первое слово новое, главное.
[01:23.000 --> 01:38.000]  Соответственно, это функция У из пар натуральных чисел, ну или обратите из пар строк на натуральные числа в строке, которая обладает тремя свойствами.
[01:38.000 --> 01:57.000]  Первое свойство это вычислимость. Это означает, что У вычислимо как функция двух аргументов.
[01:57.000 --> 02:09.000]  То есть есть программа, которая получает два аргумента и всегда возвращает значение, если функция определена и не останавливается, если функция не определена.
[02:09.000 --> 02:21.000]  Второе свойство, что оно универсальное, это оно как раньше, давайте я повторю для полноты.
[02:21.000 --> 02:40.000]  Для любой вычислимой Ф, 4 из натуральных чисел натуральные числа, существует такая программа, что для любого Х, 4Ф от Х равняется У от ПХ.
[02:40.000 --> 02:47.000]  Вот это свойство еще называют тюринг полнота языка программирования.
[02:47.000 --> 02:55.000]  Такую функцию можно понимать как язык программирования, где первый аргумент это программа, а второй аргумент это аргумент этой программы.
[02:55.000 --> 03:03.000]  А сама У это такой компилятор, который получает программу, получает входные данные и запускает эту программу на входных данных.
[03:04.000 --> 03:08.000]  Ну и соответственно, либо получается какой-то ответ, либо она не останавливается.
[03:08.000 --> 03:11.000]  Но мы не узнаем, что она не останавливается.
[03:11.000 --> 03:32.000]  Еще есть третье свойство, которое я на самом деле использовал неделю назад, когда мы обсуждали, что всякие свойства, типа всю доопределенности будут не перечислимые, не коперечислимые.
[03:32.000 --> 03:37.000]  Значит, там мы это использовали.
[03:37.000 --> 03:44.000]  Ну а общее определение того, что такое главная универсальна вычлемая функция, такое.
[03:44.000 --> 03:58.000]  Для любой В из Н на Н в Н, то есть неформально говоря, для любого другого языка программирования, который даже не обязательно универсальный,
[03:58.000 --> 04:04.000]  а просто какой-то язык, который получает текст программы, получает входные данные и получает какой-то ответ.
[04:04.000 --> 04:06.000]  Боже мать.
[04:06.000 --> 04:08.000]  Определенный, может неопределенный.
[04:08.000 --> 04:13.000]  Для любого такого языка программирования существует перекодирование.
[04:13.000 --> 04:18.000]  Значит, существует тотальная вычислимая функция.
[04:18.000 --> 04:37.000]  Значит, С из Н в Н такая, что для любого П и для любого Х мы получаем, что В от ПХ это У от С от ПХ.
[04:37.000 --> 04:46.000]  То есть есть как бы такой транслятор, переводчик, который программы для В переделывает, программы для У.
[04:46.000 --> 04:49.000]  Причем этот транслятор сам является вычислимой процедурой.
[04:49.000 --> 04:59.000]  Ну вот для обычных языков программирования, которые достаточно структурированные, ну все вот так вот и будет.
[04:59.000 --> 05:09.000]  И вообще довольно сложно придумать функцию, которая была бы универсальной, но не главная.
[05:09.000 --> 05:12.000]  Значит, неуниверсальность очень легко придумать.
[05:12.000 --> 05:18.000]  Да, просто случайную функцию более-менее возьмете вычислимой, она скорее всего универсальна не будет.
[05:18.000 --> 05:23.000]  Но придумать так, что она была универсальна, но третий свойств был не выполнен, довольно сложно.
[05:23.000 --> 05:27.000]  Потому что обычные языки программирования имеют какую-то структуру.
[05:27.000 --> 05:33.000]  Есть структура одного языка, а структура другого можно как-то регулярно переводить.
[05:33.000 --> 05:40.000]  Ну и в принципе реальные компиляторы более-менее это и делают.
[05:40.000 --> 05:51.000]  Они переделывают язык, текст программы на каком-то высокоуровнем языке, уже выполнимый файл, который стоит из команд для процессора.
[05:51.000 --> 06:03.000]  То есть это компиляторы настоящие, они скорее как раз как это функция сделают из одного языка, другой перекодируют.
[06:09.000 --> 06:17.000]  Но тем не менее, всякими изощрёнными методами можно придумать и не главные языки, и мы это сегодня сделаем.
[06:18.000 --> 06:20.000]  Так, хорошо.
[06:24.000 --> 06:31.000]  Значит, теперь смотрите, я нарисую такую диаграмму.
[06:31.000 --> 06:35.000]  Значит, вот это будут перечислимые языки.
[06:38.000 --> 06:42.000]  Значит, перечислимые языки, вот это вот, ну или множество.
[06:42.000 --> 06:46.000]  Да, языки это термин уже такой из теории формальных языков.
[06:46.000 --> 06:51.000]  Ну ладно, раз я написал, давайте как пояснение напишу множество.
[06:51.000 --> 06:56.000]  Просто когда множество слов, а не множество чисел, то его часто называют языком.
[06:56.000 --> 06:58.000]  Вот поэтому я так и написал.
[06:58.000 --> 07:02.000]  Значит, здесь будут копии перечислимые языки.
[07:07.000 --> 07:10.000]  То есть дополнение к перечислимым.
[07:12.000 --> 07:24.000]  Вот, значит, с пересечения будут разрешимые языки.
[07:28.000 --> 07:30.000]  Значит, про это говорит теорема Поста.
[07:30.000 --> 07:36.000]  Да, мы в какой-то момент доказывали, что множество разрешимо тогда и только тогда, когда оно и перечислимо, и ко перечислимо.
[07:37.000 --> 07:42.000]  Ну, значит, в прошлый раз было некоторое количество примеров.
[07:42.000 --> 07:49.000]  Значит, например, проблема остановки будет вот здесь.
[07:53.000 --> 07:55.000]  Перечислимо, но неразрешимо.
[07:58.000 --> 08:03.000]  Значит, бывает копии перечислимые, но неразрешимые.
[08:04.000 --> 08:07.000]  Я сейчас не помню, какой был пример в прошлый раз.
[08:07.000 --> 08:14.000]  Но, например, вот ИД, это я имею в виду empty domain.
[08:14.000 --> 08:17.000]  Значит, empty domain – это множество нигде неопределенных программ.
[08:19.000 --> 08:25.000]  Значит, множество нигде неопределенных программ.
[08:25.000 --> 08:35.000]  Ну, ко перечислимо, потому что где-то определенные программы будут перечислимыми по куче разных причин.
[08:35.000 --> 08:45.000]  Например, можно по очереди запускать на все большем числе входов, на все большее и большее число шагов и смотреть, остановится ли хоть где-то.
[08:45.000 --> 08:55.000]  Если хоть где-то, хоть какое-то число шагов остановится, то мы говорим, что да, эта программа где-то останавливается, и это будет перечисление как дополнение к ЕД.
[08:55.000 --> 09:09.000]  Ну, а вот, например, множество всюду определенных программ или множество программ конечной области определения,
[09:09.000 --> 09:19.000]  ну, дайте я про все прокомментирую, аж проблемы остановки.
[09:19.000 --> 09:35.000]  Ну, обычно, это множество пар из программы и входа. Такие, что эта программа останавливается на этом входе.
[09:35.000 --> 09:45.000]  Но можно рассмотреть, например, проблему остановки на конкретном входе. То есть верно ли, что данная программа останавливается на пустом слове, например.
[09:45.000 --> 09:53.000]  Вот, тогда уже здесь, как и во всех остальных, это будет именно множество программ, а не множество чего-то более хитрого.
[09:53.000 --> 10:13.000]  Так, значит, Т это множество всюду определенных программ, всюду определенных программ, значит, ЕД, ФД это множество программ с конечной области определения.
[10:13.000 --> 10:25.000]  Соответственно, смотрите, это все получается разной свойствой программ, и ни одно из них не попало в пересечение, в разрешимые языки.
[10:25.000 --> 10:31.000]  Ну, вот теорема Райс Успенска говорит, что это неспроста.
[10:31.000 --> 10:33.000]  Теорема Райса Успенского.
[10:33.000 --> 10:43.740]  Но коротко она говорит, что есть какой-то
[10:43.740 --> 10:52.900]  вопрос, что я могу делать.
[10:52.900 --> 11:08.020]  Успенского, но коротко она говорит, что любое нетривиальное
[11:08.100 --> 11:16.220]  функциональное свойство программ, свойство программ
[11:16.220 --> 11:19.220]  неразрешимо.
[11:19.220 --> 11:28.420]  Сейчас мы подробнее всё, тут очень много на самом
[11:28.420 --> 11:29.420]  деле оговорок.
[11:29.420 --> 11:34.900]  Так, значит краткая формулировка, значит полная формулировка.
[11:34.900 --> 11:50.860]  Что такое нетривиальная штука и функциональное
[11:50.860 --> 11:51.860]  свойство?
[11:51.860 --> 11:57.940]  Функционально это означает, что зависит от того, что
[11:57.940 --> 12:00.340]  эта программа делает, а не от того, как она выглядит.
[12:00.340 --> 12:03.940]  Например, свойство программы иметь чётную длину – это
[12:03.940 --> 12:07.300]  неразрешимые свойства, а свойство программы содержать
[12:07.300 --> 12:09.220]  конкретный символ – тоже разрешимые свойства.
[12:09.220 --> 12:13.540]  Но свойства вычислять данную функцию уже будут неразрешимыми.
[12:13.540 --> 12:16.340]  Или все вот те перечисленные.
[12:16.340 --> 12:20.860]  Соответственно, есть какое-то множество вычислимых функций.
[12:20.860 --> 12:27.380]  А это множество вычислимых функций.
[12:27.380 --> 12:32.380]  Значит такое, что оно не пусто, его дополнение тоже
[12:32.380 --> 12:33.380]  не пусто.
[12:33.820 --> 12:36.820]  Это означает нетривиальность.
[12:36.820 --> 12:42.820]  Такое, что А не пусто, и дополнение КА тоже не пусто.
[12:42.820 --> 12:47.820]  Значит вот это и означает нетривиальность.
[12:48.260 --> 13:04.340]  Далее, второй пункт, который в этой формулировке вообще
[13:04.340 --> 13:05.340]  под ковром.
[13:05.340 --> 13:10.220]  Второе предположение, что есть именно главные универсальные
[13:10.220 --> 13:11.220]  вычислимые функции.
[13:11.620 --> 13:21.620]  Пусть У – это главные универсальные вычислимые функции.
[13:21.620 --> 13:26.620]  Что же такое функциональность?
[13:26.620 --> 13:31.700]  Функциональность может сказать следующее, что две программы
[13:31.700 --> 13:34.720]  вычисляющие одну и ту же функцию, либо обе обладают
[13:34.720 --> 13:37.180]  этим свойством одновременно, либо обе не обладают.
[13:38.140 --> 13:47.140]  Соответственно рассматривается множество программ, таких
[13:47.140 --> 13:57.180]  что, если мы вот так фиксируем первый аргумент равный этой
[13:57.180 --> 14:02.560]  программе и второй аргумент варьируем, то есть эта точка
[14:02.560 --> 14:05.740]  означает, что мы эту запись понимаем как функцию от
[14:05.740 --> 14:07.580]  второго аргумента при фиксированном первом.
[14:07.580 --> 14:12.060]  Это получается, конечно, вычислимая функция, и соответственно
[14:12.060 --> 14:15.580]  она может лежать ва или не лежать.
[14:15.580 --> 14:19.020]  Соответственно, мы берем множество тех, при которых
[14:19.020 --> 14:23.780]  эта функция лежит ва, и говорим, что тогда она неразрешима.
[14:23.780 --> 14:35.500]  Вот это и есть арема Райса Успенского.
[14:35.500 --> 14:44.460]  Получается, что функциональность означает, что те программы
[14:44.460 --> 14:47.220]  для одной функции либо берем все вместе, либо не берем
[14:47.220 --> 14:48.220]  все вместе.
[14:48.220 --> 15:05.700]  Значит, функциональность свойства программ означает,
[15:05.700 --> 15:24.140]  что те программы для одной и той же функции либо одновременно
[15:24.140 --> 15:26.140]  обладают свойствами, либо одновременно не обладают.
[15:26.140 --> 15:40.500]  Но здесь так и получается либо одновременно.
[15:40.500 --> 16:03.740]  Ну что, я надеюсь, теперь понятна и полная формулировка.
[16:03.740 --> 16:07.260]  Если остались какие-то вопросы, то задавайте, сейчас
[16:07.260 --> 16:11.620]  будем доказывать в общем виде.
[16:11.620 --> 16:14.940]  То есть было некоторое число частных случаев для всех
[16:14.940 --> 16:17.940]  перечисленных.
[16:17.940 --> 16:21.060]  Для всех перечисленных здесь мы доказывали.
[16:21.060 --> 16:32.140]  Я помню, у нас было не определенные функции, а функции, которые
[16:32.140 --> 16:33.580]  константны на области определения.
[16:34.580 --> 16:41.580]  Да, такой у нас был пример этой самой функции, которая
[16:41.580 --> 16:43.700]  перечислила, но не разрешима.
[16:43.700 --> 16:44.700]  Не функция, а множество.
[16:44.700 --> 16:57.220]  Нет, это в этом теориям и заключается.
[16:57.220 --> 16:58.220]  Сейчас будем доказывать.
[16:58.220 --> 17:07.980]  Так, давайте, и тут как-то многое, это самое, я это
[17:07.980 --> 17:08.980]  выделю.
[17:08.980 --> 17:15.020]  Значит, как раз вот это вот, да, это утверждение теоремы.
[17:15.020 --> 17:24.140]  Так, ну, значит, доказательства.
[17:24.140 --> 17:43.340]  Ну, вот рассмотрим, рассмотрим нигде не определенную функцию.
[17:43.340 --> 17:48.020]  Да, это не если вполне конкретная функция, обозначен ее греческой
[17:48.020 --> 17:54.700]  буквой z, такая очень используемая в математике, да, там есть
[17:54.700 --> 17:57.860]  эта функция Риммана, z распределения и так далее.
[17:57.860 --> 18:04.060]  Вот, если не умеете писать, то поучитесь.
[18:04.060 --> 18:07.100]  Да, это на самом деле легко, такая петелька, да, я потом
[18:07.100 --> 18:08.100]  вот так вот.
[18:08.100 --> 18:14.060]  Вот, значит, z от x, значит, z от x это нигде не определенная
[18:14.060 --> 18:15.060]  функция.
[18:15.060 --> 18:32.500]  Значит, нигде не определенная функция, конечно, вычислима.
[18:32.500 --> 18:36.540]  Тривиальная программа стоит на месте, ничего не делать.
[18:36.540 --> 18:40.060]  Тогда она никогда не остановится и как раз вычислит нигде
[18:40.060 --> 18:41.060]  не определенную функцию.
[18:41.060 --> 18:45.220]  Вот, значит, раз она вычислима, то она либо обладает свойством
[18:45.220 --> 18:46.820]  вот этим аккорасивом, либо не обладает.
[18:46.820 --> 18:51.500]  Ну, без ограничений общности можно считать, что обладает.
[18:51.500 --> 19:02.100]  Без ограничений общности z лежит ва.
[19:02.100 --> 19:10.820]  Вот, но значит, также анетривиально это означает, что есть какие-то
[19:10.820 --> 19:12.260]  функции, которые в этом не обладают.
[19:12.260 --> 19:25.340]  А с чертой не пусто.
[19:25.340 --> 19:30.620]  Из этого следует, что существует x, который лежит, ну, который
[19:30.620 --> 19:31.620]  не лежит ва.
[19:31.620 --> 19:37.500]  Ну, и x конечно уже где-то будет определена.
[19:37.500 --> 20:00.260]  Так, значит, теперь рассмотрим какое-то перечислимо-неразрешимое
[20:00.260 --> 20:01.260]  множество k.
[20:02.260 --> 20:25.100]  Так, и теперь рассмотрим вот такую функцию v.
[20:26.100 --> 20:29.300]  Так, v от qx.
[20:29.300 --> 20:37.340]  Значит, v от qx будет выглядеть так.
[20:37.340 --> 20:44.220]  Значит, это будет вот это вот x.
[20:44.220 --> 20:53.100]  Если q у нас лежит в k, и z от x, если q не лежит в k.
[20:53.100 --> 21:04.780]  И это вычислимая функция, вычислимая функция двух
[21:04.780 --> 21:05.780]  аргументов.
[21:05.780 --> 21:10.740]  Значит, почему она вычислимая?
[21:10.740 --> 21:16.260]  Ну, например, можно сказать так, то мы перечисляем просто
[21:16.260 --> 21:21.180]  множество k и ждем, пока там появится число q.
[21:21.180 --> 21:24.460]  И как только появилось, запускаем программу x от
[21:24.460 --> 21:25.460]  x.
[21:25.460 --> 21:30.340]  Все, на этом программа закончилась.
[21:30.340 --> 21:32.860]  Но не закончился анализ программы.
[21:32.860 --> 21:35.420]  Теперь можно сказать так, что если q лежит в k, то действительно
[21:35.420 --> 21:38.060]  мы рано или поздно до него дойдем, и в этот момент
[21:38.060 --> 21:41.620]  начнем вычисление x от x и вычислим то, что нужно.
[21:41.620 --> 21:45.420]  Но если q не лежит в k, то мы никогда не дойдем до
[21:45.420 --> 21:50.100]  этого q, и все время будем ждать бесконечно долго.
[21:50.260 --> 21:52.220]  Но при этом вычислим именно то, что нужно, потому что
[21:52.220 --> 21:54.020]  нам тогда и нужно не остановиться.
[21:54.020 --> 21:57.660]  Поэтому это вычислимая функция.
[21:57.660 --> 22:08.740]  Когда я говорю, что x лежит в a, имеется в виду, что я беру
[22:08.740 --> 22:10.660]  именно вычислимую функцию не из a.
[22:10.660 --> 22:13.900]  А это вообще свойство вычислимых функций, это, можно сказать,
[22:13.900 --> 22:16.940]  разбиение множества вычислимых функций на два подмножества.
[22:16.940 --> 22:25.100]  Так что x будет по определению вычислим, а что вот к этой
[22:25.100 --> 22:28.620]  штуке можно применить это свойство.
[22:28.620 --> 22:52.020]  У нас получается, что существует s, так что у него отклик был
[22:52.020 --> 22:52.540]  долгим.
[22:59.500 --> 23:03.060]  Так, а что он перегрелся, что ли?
[23:03.060 --> 23:11.420]  Так, так я был долго писать.
[23:11.420 --> 23:16.460]  Ладно, хорошо, что есть получается, ну то, что там написано.
[23:16.460 --> 23:29.540]  Дальше для любого q получается, для любого q и для любого x,
[23:29.540 --> 23:42.620]  значит, соответственно, v от qx.
[23:53.380 --> 23:57.740]  Так, сейчас, если так будет, я не смогу энтузку использовать.
[23:57.740 --> 24:17.500]  Сейчас дорисую, v от qx, значит, равняется u от s от q и x.
[24:17.500 --> 24:26.540]  Так, ну ладно, сейчас посмотрим, если что, придется только на этой доске писать.
[24:26.540 --> 24:35.380]  Так, хорошо, значит, это именно для этого v, но тогда что же мы получаем?
[24:35.380 --> 24:55.300]  Значит, мы получаем, что если q лежит в k, то мы получаем, что v от q, вот я точку буду писать
[24:55.300 --> 24:57.740]  вместо аргументов, чтобы подчеркнуть, что я считаю аргументом.
[24:57.740 --> 25:03.140]  v от q и аргументы это будет q от аргумента.
[25:03.140 --> 25:18.140]  Значит, из этого следует, что u от s от q и аргумента это тоже будет q от этого аргумента.
[25:18.140 --> 25:29.460]  Вот, а из этого следует, что, так, давайте считать так, что вот a красиво это множество функций,
[25:29.460 --> 25:34.660]  а еще есть a простое. Значит, a простое это множество таких p, в общем, как раз то,
[25:34.660 --> 25:43.060]  которое там было написано. Значит, множество таких p, что u от p и второго аргумента лежит в a красивом.
[25:43.060 --> 25:58.620]  Вот, в общем, из этого следует, что у нас что? Значит, q у нас не лежит в a красивом, значит,
[25:58.620 --> 26:12.420]  s от q не лежит в a простому. Ну и симметрично получается, что если q не лежит в k, то тогда
[26:12.420 --> 26:27.100]  получается, что v от q и второго аргумента это z, то есть получается, что u от s от q и второго
[26:27.100 --> 26:37.700]  аргумента это z нигде не определенное. Вот, а тогда получается, что s от q у нас лежит в a простом.
[26:37.700 --> 26:44.020]  Да, то есть функция вот эта, вот как функция z лежит в a красивом,
[26:44.020 --> 26:51.820]  значит, программа, которая вычисляет относительно u, лежит в a простом. Вот, соответственно,
[26:51.820 --> 27:10.660]  итог. Значит, итог, получаем, что q лежит в k множестве k тогда и только тогда, когда s от q лежит в a. При этом,
[27:10.660 --> 27:16.340]  s у нас из определения главной универсальной вычислимой функции, s будет сюда определенная
[27:16.340 --> 27:23.700]  универсальной вычислимая. А у нас было определение в прошлый раз, что когда такое бывает, это означает,
[27:23.700 --> 27:42.380]  что k у нас m свелось к множеству a. Но поскольку мы же взяли k не просто так, а неразрешимым,
[27:42.380 --> 28:03.460]  то а получается тоже неразрешимым. Вот. А, да, вы правы, вы правы. Да, давайте перечеркнем. Тогда
[28:03.460 --> 28:10.140]  здесь сказка с чертой получилась, но для разрешимости это неважно. Да, спасибо за поправку. Надо было
[28:10.540 --> 28:14.740]  в самом начале взять, что z не лежит в a, тогда здесь бы не нужно подчеркивать. Но, в общем,
[28:14.740 --> 28:26.460]  все неважно. Это все неважно. Получается, что если k у нас взято неразрешимым, значит, если k
[28:26.460 --> 28:49.660]  неразрешимым, то а с чертой тоже неразрешимым. Но и а неразрешимым. Вот. Причем сказать,
[28:49.660 --> 28:53.820]  что это про перечислимость нельзя, потому что вот у нас там было безгорячение общности. Да,
[28:53.900 --> 29:00.580]  то есть так-то у нас, скажем, k у нас не коперечислимо, и поэтому а с чертой тоже не
[29:00.580 --> 29:06.020]  коперечислимо. Да, то есть а не перечислимо получилось. Но поскольку там было безгорячение
[29:06.020 --> 29:10.220]  общности, то в другом случае получилось бы не коперечислимо, и, соответственно,
[29:10.220 --> 29:20.340]  надежно ничего сказать про перечислимость а нельзя. А про разрешимость можно. Значит, а точно
[29:20.340 --> 29:43.300]  неразрешимо. Вот. Ну что, какие-нибудь вопросы? Так, давайте посмотрим, это починилось доска или
[29:43.300 --> 30:06.260]  она. Ничего, похоже, не починилось. Вообще не откликается. Да. Ну, потому что у нас здесь,
[30:06.260 --> 30:17.700]  по предположению, что здесь вот, так, а вон три страницы добавил. Так, невидимо,
[30:17.700 --> 30:43.140]  я тут не смогу писать, тут все зависло. Ну, так, ладно. Короче, что у нас там было? У нас там
[30:43.300 --> 30:55.140]  было, что ксия не лежит ва. Значит, вот это у нас не лежит ва красивом. Вот. Но если функция не лежит ва
[30:55.140 --> 31:09.580]  красивом, то программа для нее не лежит ва прямом. Вот. Тут снова что ли память забилась? Так, ладно.
[31:09.580 --> 31:18.540]  Эту доску я больше-то не буду использовать сегодня. Вот. Ну, а здесь, соответственно, вот этот
[31:18.540 --> 31:41.500]  z будет лежать у нас ва. Так. Ну, ладно. Значит, в частности, смотрите, что у нас получилось. Значит,
[31:41.580 --> 32:08.740]  следствие из теоремы. Значит, следствие из теоремы Райса Успенского будет таким. Значит,
[32:08.740 --> 32:15.140]  множество программ, которые вычисляют одну конкретную функцию. Да, то есть смотрите, значит,
[32:15.140 --> 32:26.260]  если f из n в n вычислимо, значит, а u это главная универсальная вычислимая функция, то тогда
[32:26.260 --> 32:40.260]  нож таких p, что для любого x, у от px равняется f от x, значит, это получается неразрешимо. Вот. И в том
[32:40.260 --> 32:59.660]  числе оно бесконечно. Значит, оно неразрешимо и в том числе бесконечно. В том числе бесконечно. То есть,
[32:59.660 --> 33:06.220]  как бы любую программу можно написать бесконечным числом способов. Ну, то есть, любое задание,
[33:06.220 --> 33:12.340]  любое программистское задание можно выполнить бесконечным числом способов. Так, ну это вы,
[33:12.340 --> 33:18.420]  возможно, и так понимаете. Значит, на любом нормальном языке программирования, значит,
[33:18.420 --> 33:24.140]  можно оставлять комментарии, какие угодно, с какой угодно большой длины и любого содержания.
[33:24.140 --> 33:43.820]  Так, хорошо. Но это следствие позволяет построить неглавную функцию. Вот. Значит, построим неглавную
[33:43.820 --> 33:58.540]  функцию. Значит, неглавную вирсально учитимую функцию, значит, которой вот это наше z от x,
[33:58.540 --> 34:19.700]  значит, негде неопределенная функция имеет ровно один номер. Так, тут что-то открылось, да. Так,
[34:19.780 --> 34:34.860]  по крайней мере, хорошо бы восстановить. Так, ладно, я с этим потом разберусь. Значит,
[34:34.860 --> 34:44.860]  как это будет устроено? Ну, значит, смотрите, у нас есть множество ЕД, которое множество негде
[34:44.860 --> 34:51.940]  неоплённых программ. Да, то есть сначала у нас есть какая-то обычная, обычная универсальная
[34:51.940 --> 35:02.260]  функция, да, из вирсально-машин-тюринга. Так, давайте я снова. Значит, пусть у, это
[35:02.260 --> 35:08.180]  главная универсальная учитимая функция. Значит, соответственно, ЕД это множество таких П,
[35:08.180 --> 35:19.220]  что для любого х у от Пх не определено. Значит, дальше, соответственно, есть, ну, получается,
[35:19.220 --> 35:30.260]  ЕД с чертой, но это наоборот. Значит, множество П таких, что существует х, то у от Пх определён.
[35:30.260 --> 35:45.300]  Вот, и этот ЕД с чертой перечислим, а с чертой перечислимо. Ну вот, перечислять будем,
[35:45.300 --> 35:58.340]  начиная соединиться. Значит, П1, П2, П3 и так далее. Так, а теперь, смотрите, рассмотрела такую
[35:58.340 --> 36:17.860]  функцию. В от И и х. Значит, это будет не определено, если И равно нулю, и это будет у от П и Т х,
[36:17.860 --> 36:29.500]  если и больше нуля. Вот, утверждается, что эта функция как раз универсальна, но не главное.
[36:29.500 --> 36:46.980]  Вот, это В, это универсально учитимая функция, но не главное. Так, значит, чего она вычислима,
[36:46.980 --> 36:52.740]  во-первых? Ну, вычислима, потому что вот это перечисление, да, то есть, конечно, мы можем
[36:52.740 --> 36:58.460]  сравнить ЕС нулём, конечно, можем зациклиться, если Е равно нулю, а если Е больше нуля, то мы
[36:58.460 --> 37:04.460]  начинаем вот это перечисление, ждём, пока ИТ программа встретится, её подставляем вот в эту
[37:04.460 --> 37:11.420]  функцию, и это получается такая, как бы большая композиция вычислимых функций. Так, она вычислима,
[37:11.420 --> 37:16.740]  дальше, почему она универсальна? Ну, универсальна, потому что, если функция нигде не определена,
[37:16.740 --> 37:22.860]  то тогда вот для неё есть И, равная нулю, а если функция где-то определена, то она встречается вот
[37:22.860 --> 37:27.300]  в этом перечислении, и, соответственно, под некоторым номером И она встретится, да, и будет
[37:27.300 --> 37:35.620]  здесь. Вот, поэтому она универсальная. А почему она не главная? А не главная, потому что, как раз
[37:35.620 --> 37:58.180]  нигде не определённо, имеет ровно один номер ноль. Не главное, потому что Z от X имеет один номер ноль.
[38:05.620 --> 38:23.700]  Вот. Нет, значит, смотрите, из V в U мы можем перекодировать, но наоборот мы не можем. Да, то есть,
[38:23.700 --> 38:28.260]  смотрите, почему мы не можем, почему так получается, что она не главная, почему мы не
[38:28.260 --> 38:35.700]  можем перекодировать из обычного языка вот в этот, потому что нам нужно понять по программе
[38:35.700 --> 38:42.980]  для обычного языка, будет она где-то определена или не будет. И если она нигде не определена,
[38:42.980 --> 38:52.660]  нам нужно вернуть обязательно И, равная нулю. Вот. А если, соответственно, определена, то что-то
[38:52.660 --> 39:00.860]  неравная нулю. Ну и получается, тогда бы мы для исходной задачи могли, для исходной универсальной
[39:00.860 --> 39:07.500]  функции, это нумерация называется, для исходной нумерации мы могли бы решить задачу о нигде
[39:07.500 --> 39:12.980]  неопределённости, что если перекодировка вот в эту функцию даёт ноль, то значит нигде не
[39:12.980 --> 39:17.500]  определена. Если больше, значит где-то определена. Вот. А раз мы это решить не можем, значит и
[39:17.500 --> 39:32.540]  перекодировок такой нет и поэтому она не главная. Вот. Но такая конструкция есть, на эту тему есть
[39:32.540 --> 39:39.940]  очень сложная теорема. Я как-то один раз пытался в ней разобраться, но это в принципе можно,
[39:39.940 --> 39:46.780]  там не нужно там два месяца что-то учить, но там довольно хитрое рассуждение, так что
[39:46.780 --> 39:56.300]  её только сформулирую. Называется теорема Фридберга. Значит теорема Фридберга
[39:56.300 --> 40:09.900]  заключается в следующем, что есть функция, есть универсальная функция, у которой у любой
[40:09.900 --> 40:19.020]  вычислимый есть ровно один номер. То есть получается существует такая В, то для любой
[40:19.020 --> 40:32.820]  F вычислимый существует единственная такая программа P, что для любого x равняется f от x.
[40:32.820 --> 40:44.820]  То есть это такая однозначная номерация вычислимых функций.
[40:44.820 --> 41:14.380]  Есть такая шутка, что в такой номерации очень просто было бы проверять задачи
[41:14.380 --> 41:19.620]  по программированию, что просто для любой функции есть ровно одна программа, которая вычисляет,
[41:19.620 --> 41:24.940]  и соответственно, если вы именно эту программу сдали, то значит зачет, если будет другую,
[41:24.940 --> 41:38.380]  то не зачет. Но конечно в реальности ее нельзя применять, ну как бы ничего хорошего в этой
[41:38.380 --> 41:45.780]  номерации нет, кроме красивой математики. Да, на практике, конечно, это очень затруднило бы такое
[41:45.780 --> 42:04.660]  написание программы. Так, хорошо, ну что, киньте вопросы. Так, я думал сейчас небольшой
[42:04.660 --> 42:10.420]  перерыв сделаю, потому что сейчас немножко другая тема начнется. Ну, дайте на 5 минут.
[42:10.420 --> 42:20.620]  Вторая тема это, значит, куайны и теоремы клиния. Значит, куайны это программы, которые печатают
[42:20.620 --> 42:43.220]  собственный текст. Программы, которые печатают собственный текст. Вот, значит, если писать инструкцию
[42:43.220 --> 43:01.020]  на естественном языке, то можно писать следующее. Значит, напечатать дважды. Я вторую копию в
[43:01.020 --> 43:20.780]  кавычке. Ну и дальше тоже самое. Напечатать дважды.
[43:31.020 --> 43:52.380]  Взяв вторую копию в кавычке. А если вы эту инструкцию исполните, то ровно такое тексте
[43:52.380 --> 44:00.060]  должен получиться. Ну, вот, аналогичные конструкции бывают и на разных других языках
[44:00.060 --> 44:10.220]  программирования. Ну, значит, утверждается следующее, что если у вас язык программирования
[44:10.220 --> 44:19.740]  производит главную универсальную учлимую функцию, то там такое можно сделать. Значит, теорема
[44:19.740 --> 44:30.300]  такая. Теорема о куайнах. То если у – это главная универсальная учлимая функция,
[44:30.300 --> 44:46.380]  значит, то тогда, ну, можно, например, так написать. Значит, существует п, такое что любого х,
[44:46.380 --> 45:02.100]  значит, у от pх равняется п. То есть это получается функция дается константой. И это не
[45:02.100 --> 45:16.900]  просто константа, а это константа равная номеру этой функции. Вот так. Значит, это теорема
[45:16.900 --> 45:23.700]  о существовании куайнов. Так, да, тогда я тебе это напишу. Значит, теорема о существовании куайнов.
[45:23.700 --> 45:33.460]  Значит, куайна – это тоже фамилия одного логика, но вот она стала нарисательным выражением.
[45:33.460 --> 45:43.740]  Так, значит, вот эта теорема о существовании куайнов следует из более сильной теоремы к линии о
[45:43.740 --> 46:07.260]  неподвижной точке. Теорема к линии о неподвижной точке. Так, значит, пусть у нас есть какое-то
[46:07.260 --> 46:17.100]  преобразование. Ну и как у нас тут всюду? Пусть у нас есть главная универсальная учлимая функция.
[46:17.100 --> 46:27.100]  Значит, пусть есть главная универсальная учлимая функция и есть какое-то преобразование h из n в n.
[46:27.100 --> 46:42.380]  Значит, это всюду определенная учлимая функция. Можно сказать, что это h – это
[46:42.380 --> 46:50.460]  преобразование программ. Значит, h – это преобразование программ.
[46:50.460 --> 47:06.300]  Значит, тогда неформально теорема говорит следующее, что есть такая программа,
[47:06.380 --> 47:09.140]  которая до преобразования делает то же самое, что после преобразования.
[47:09.140 --> 47:32.780]  Значит, есть программа, которая до преобразования делает то же
[47:32.780 --> 47:49.780]  то и после преобразования. Ну а формально получается следующее. Существует такое,
[47:49.780 --> 48:11.220]  что для любого x у от px равняется у от h от px. Значит, вот на любом x до преобразования
[48:11.660 --> 48:22.020]  то же самое, что после преобразования. Вот это есть неподвижная точка. Неподвижная точка
[48:22.020 --> 48:27.540]  преобразования. Обычно неподвижная точка – это прям, что h от x равно x. Но здесь, конечно,
[48:27.540 --> 48:32.860]  такого может не быть. Но если мы смотрим на то, что программа делает, а не на то,
[48:32.860 --> 48:45.900]  как она выглядит, то неподвижная точка будет. Так, значит, хорошо. Как из вот этой теоремы
[48:45.900 --> 48:53.060]  к линии получить теорему о сочетании Куайна? Ну смотрите, мы, конечно, используем, что у нас
[48:54.060 --> 49:20.580]  функция. Как теоремы к линии вывести теорему о существовании маленькой буквы. Так, ну смотрите,
[49:20.660 --> 49:29.380]  рассмотрим такую функцию v от px равняется p. Это, конечно, будет вычислимая функция двух
[49:29.380 --> 49:36.780]  аргументов. Из этого следует, что поскольку u – это главная универсальная вычислимая функция,
[49:36.780 --> 49:59.220]  то из этого следует, что существует s такое, что у любого x, v от px равняется u от s от px.
[49:59.220 --> 50:06.700]  И теперь вот эту вот функцию s, которая получается из определения главной универсального
[50:06.700 --> 50:12.980]  вычислимой функции, вот эту функцию s мы воспределим как функцию h из условий теоремы к линии.
[50:12.980 --> 50:30.020]  Значит, по теоремы к линии существует p, так же для любого x, u от px равняется u от s от px.
[50:30.020 --> 50:41.860]  Ну а дальше мы дописываем здесь, что это равняется v от px и это равняется p.
[50:41.860 --> 50:53.260]  Соответственно, итог получается как раз какой нужен. Существует p для любого x,
[50:53.260 --> 50:58.660]  значит, u от px равняется p.
[51:16.180 --> 51:22.100]  Значит, неформально можно сказать так, что мы рассматриваем такое преобразование программ,
[51:22.580 --> 51:27.280]  что из программы P делаем программу напечатать текст P,
[51:27.280 --> 51:31.780]  соответственно есть программа, которая до преобразования делает то же самое,
[51:31.780 --> 51:36.300]  что после преобразования, но после преобразования она напечатает текст P,
[51:36.300 --> 51:40.720]  значит, до преобразования она тоже напечатает текст P, то есть до преобразования она напечатает
[51:40.720 --> 51:42.620]  свой собственный текст, а это нам и нужно было.
[51:42.620 --> 52:06.260]  вот так ну что понятно ладно тогда будем доказывать теорему к линиям
[52:06.260 --> 52:36.220]  так ну на самом деле я не претендую на то чтобы объяснить там глубокую сущность
[52:36.220 --> 52:43.620]  его я сейчас ну сейчас будет некоторый такой кролик из шляпы да то есть я буду
[52:43.620 --> 52:48.500]  какие-то странные действия делать об итоге терема докажется вот значит
[52:48.500 --> 52:52.340]  почему так получается но в книжке речи один шиня там есть какой-то глубокое
[52:52.340 --> 52:58.660]  объяснение что нужно смотреть там на то что преобразование бывает какие там
[52:58.660 --> 53:06.980]  классы квалентности что он делает там и так далее вот но это так просто трудно
[53:06.980 --> 53:11.220]  двух словах сказать да то есть сейчас я расскажу них такой формальное
[53:11.220 --> 53:17.060]  рассуждение да где как бы все переходы я надеюсь что будет понятно но общая идея
[53:17.060 --> 53:27.740]  может ускользнуть и это нормально так хорошо так ну начнем с того что сделаем
[53:27.740 --> 53:39.500]  следующее значит вот такую вот транную функцию рассмотрим v от px это будет у от
[53:39.500 --> 53:52.180]  у от пп и икс вы смотрите что получается получается что программу п запускаем на
[53:52.180 --> 53:57.060]  своем собственном тексте дали там машину п запускаем в своем собственном номере и
[53:57.060 --> 54:02.900]  то что получилось тоже приспособляем как программу и уже ее запускаем на входе
[54:02.900 --> 54:07.980]  икс вот если у от пп не определено то тогда и такая штука тоже нигде не
[54:07.980 --> 54:13.220]  определена получается вот если у от пп какой результат дало то мы его теперь
[54:13.220 --> 54:19.340]  запускаем на икс да это наш программ в от п икс значит конечно вы от по икс
[54:19.340 --> 54:28.420]  будет вычислимой функции по крайней мере на вы от п икс будет вычислимой функции
[54:28.420 --> 54:35.740]  значит к ней можно применить условия главности так значит это вычислимая функция
[54:35.740 --> 54:51.900]  значит этого следует существует с значит такое что для любого значит существует
[54:51.900 --> 55:06.500]  с такое что для любого икс получаем что в от п икс равняется у от с от п икс значит
[55:06.500 --> 55:16.900]  это у нас поскольку главное значит поскольку у это главная висальима члены функция так
[55:16.900 --> 55:22.620]  значит теперь смотрите мы пока вообще про условия ничего не сказали у нас условия была
[55:22.620 --> 55:28.100]  функция но не у нас есть у условия да как главный но еще есть функция аж собственно
[55:28.100 --> 55:37.860]  само преобразование вот этот функция что же сюда подъемная вычислимая вот дальше мы
[55:37.860 --> 55:52.580]  делаем следующее дальше рассмотрим насчет т от икс т от икс которая будет равняться аж от
[55:52.580 --> 56:06.660]  икс от икс вот это у нас ну по крайней мере вычислимая функция даже сюда определенно но
[56:07.420 --> 56:20.740]  важно значит важно что просто вычислимая функция так
[56:20.740 --> 56:39.220]  сейчас успеем и доказать немножко обсудить значит рассмотрим т от икс до аж от с от икс
[56:39.300 --> 56:52.420]  вычислимая функция дальше дальше мы пользуемся просто универсальностью да вот это сейчас здесь
[56:52.420 --> 56:58.500]  мы пользуемся главностью главной универсальностью а дальше просто универсальностью да значит
[56:58.500 --> 57:15.180]  поскольку у это просто универсальничная функция то существует ку значит существует ку такое что
[57:15.180 --> 57:26.020]  для любого икс значит т от икс равняется у от ку икс
[57:26.020 --> 57:38.780]  так хорошо ну теперь тоже можно сказать что утверждается значит утверждается что
[57:39.260 --> 57:51.900]  и с от ку это неподвижная точка значит утверждение то и с от ку это неподвижная точка
[57:51.900 --> 58:09.300]  так я сейчас перелесну на следующий экран так понятно ли пока все ну совершенно непонятно
[58:09.300 --> 58:15.100]  зачем все нужно да но сейчас как бы да сейчас вот кролик вылезет из шляпы и все что здесь написано
[58:15.100 --> 58:20.580]  этом экране да значит понадобится вычислимки которые покажут что это действительно неподвижная
[58:20.580 --> 58:30.820]  точка сейчас это буду переключаться до сюда между экранами так но будем доказывать что это
[58:30.820 --> 58:45.140]  неподвижная точка рассмотрим у от и с от ку икс так ну что мы здесь можем применить
[58:45.460 --> 58:57.100]  ну вот это очень похожая да только весь п вместо ку но значит и здесь будет соответственно ку
[58:57.100 --> 59:07.460]  вместо п то есть это будет равняться значит в от ку икс если всю добру каждому равенству
[59:08.420 --> 59:22.700]  значит это получается из определения с так функция это будет верно так значит что
[59:22.700 --> 59:32.580]  дальше первый раз есть в в от ку икс данную можно теперь вот это вот определение вы применить
[59:32.580 --> 59:46.460]  значит тут будет у от у от ку ку икс так значит это определение в
[59:53.580 --> 01:00:02.500]  так значит дальше мы вот сюда вниз пойдем у нас там у от ку ку но это вот
[01:00:02.500 --> 01:00:13.820]  вот если их равно ку то у от ку ку будет равняться ты от ку и это определение ку на самом деле
[01:00:13.820 --> 01:00:29.540]  то есть это будет равняться на счет у от п от ку на счет икс
[01:00:29.540 --> 01:00:37.500]  значит это получается из определения ку
[01:00:37.500 --> 01:00:49.260]  так дальше что мы теперь используем на определение t наверное да значит
[01:00:49.260 --> 01:01:01.180]  t у нас вот нет вот это вот это h от s от икс и вроде сейчас уже все получится да то есть
[01:01:01.180 --> 01:01:15.820]  последний переход получаем что значит у от h от s от ку икс значит это получается из определения t
[01:01:31.180 --> 01:01:39.500]  значит смотрите мы здесь икс вообще никак не использовали да то есть икс был любой значит
[01:01:39.500 --> 01:01:51.420]  это верно для любого икс и это он то что нам нужно значит мы получаем что для любого икс значит у
[01:01:51.420 --> 01:02:04.940]  от с от ку икс равняется у от аж от с от ку икс это и значит что я садку это неподвижная точка
[01:02:12.940 --> 01:02:19.180]  ну вот то есть рем доказано да причем она конструктивно доказано да что не просто
[01:02:19.180 --> 01:02:25.580]  не просто мы утверждаем что она есть мы прямо предъявляем да я в нас показываем откуда ее найти
[01:02:41.100 --> 01:02:44.100]  так ну что какие-нибудь вопросы
[01:02:44.100 --> 01:02:56.660]  так у меня еще небольшое время остается значит я хотел бы чуть-чуть поговорить о вот таких ну не
[01:02:56.660 --> 01:03:01.620]  совсем таких игрушечных применениях да потому что куайна это вообще все такое развлечение да
[01:03:01.620 --> 01:03:12.900]  есть такой это мега куайн где взято там 50 разных языков программирования вот и грубо говоря там
[01:03:13.040 --> 01:03:18.740]  написано программа на s и которая пишет программу там на джабе да потом программа на джабе пишет
[01:03:18.740 --> 01:03:25.940]  программу напитония до програм Elizabethhta не пишет там программу на просте и так далее вот а
[01:03:25.940 --> 01:03:30.860]  последняя программа пишет еще самую первую программу на то есть это еще так эзоцикленно
[01:03:30.860 --> 01:03:38.500]  вот есть такой пример еще там как-то это еще и графически выстроено что ведь красивая
[01:03:38.500 --> 01:03:42.260]  и в картинку получается, на крайней мере, исходная
[01:03:42.260 --> 01:03:43.260]  программа.
[01:03:43.260 --> 01:03:48.460]  Но вообще, это всё пила, но это какие-то игрушечные
[01:03:48.460 --> 01:03:49.460]  применения.
[01:03:49.460 --> 01:03:53.860]  А если что-то более серьёзное?
[01:03:53.860 --> 01:04:01.220]  Давайте я расскажу, это не то, что прям теорема,
[01:04:01.220 --> 01:04:03.700]  ну хотя это можно сравнивать как теорема, но это скорее
[01:04:04.180 --> 01:04:06.180]  философское понимание.
[01:04:06.180 --> 01:04:16.180]  Наблюдение, давайте я так напишу, это можно сформировать
[01:04:16.180 --> 01:04:20.980]  как теорему, но теоремка эта будет скучноватая.
[01:04:20.980 --> 01:04:23.780]  А наблюдение само по себе полезное.
[01:04:24.260 --> 01:04:41.460]  Наблюдение, что за счёт теоремы к линии можно писать
[01:04:41.460 --> 01:04:43.460]  рекурсивные программы.
[01:04:43.460 --> 01:04:49.460]  Можно писать рекурсивные программы.
[01:04:49.460 --> 01:04:54.980]  На любом языке программирование, которое соответствует
[01:04:54.980 --> 01:04:58.980]  главной универсальному члену и функции.
[01:04:58.980 --> 01:05:11.780]  На любом языке программирования, соответствующем главной
[01:05:11.780 --> 01:05:14.300]  универсальному члену и функции.
[01:05:14.300 --> 01:05:18.620]  Неважно, есть ли прям синтактические средства для рекурсия,
[01:05:18.780 --> 01:05:21.780]  но всё равно по факту их писать можно.
[01:05:21.780 --> 01:05:23.780]  Значит, почему это так?
[01:05:23.780 --> 01:05:27.780]  Давайте рассмотрим какую-нибудь рекурсию.
[01:05:27.780 --> 01:05:37.780]  Например, для факториала, рекурсивная формула, что
[01:05:37.940 --> 01:05:45.940]  что факториал N, значит, это будет 1, если N равно 0.
[01:05:45.940 --> 01:05:53.940]  И факториал от N минус 1 умножить на N, значит, если N больше 0.
[01:05:55.940 --> 01:05:59.940]  Стандартное рекурсивное учление факториала.
[01:06:00.100 --> 01:06:10.100]  Смотрите, почему это правило что-то определяет.
[01:06:10.100 --> 01:06:17.100]  Тут получается, что мы функцию определяем через саму себя.
[01:06:17.100 --> 01:06:23.100]  То есть, можно сказать, что факториал – это решение
[01:06:23.100 --> 01:06:24.100]  этого уравнения.
[01:06:24.260 --> 01:06:41.260]  Значит, можно сказать, что это уравнение на неизвестную
[01:06:41.260 --> 01:06:42.260]  функцию факт.
[01:06:42.260 --> 01:06:53.260]  И вопрос, почему у этого уравнения есть решение.
[01:06:53.420 --> 01:07:11.420]  Если говорить о теории множеств, то теория мы доказывали
[01:07:11.420 --> 01:07:15.020]  от рассвидетельной рекурсии, что любое такое правило
[01:07:15.020 --> 01:07:18.100]  однозначно дает какую-то функцию во вполне упорядоченном
[01:07:18.100 --> 01:07:19.100]  множестве.
[01:07:19.940 --> 01:07:21.940]  А натуральный чисто, конечно, является вполне упорядоченным,
[01:07:21.940 --> 01:07:25.940]  но в каком-то другом, например, в целых числах уже не любое
[01:07:27.940 --> 01:07:30.940]  даже в принципе это определение, конечно, что задаст.
[01:07:30.940 --> 01:07:33.940]  Не, это, наверное, задаст за счет этой единицы, это
[01:07:33.940 --> 01:07:36.940]  задаст, но если произвольную такую написать.
[01:07:36.940 --> 01:07:39.940]  А, нет, сейчас, ничего не задаст, потому что, смотрите,
[01:07:39.940 --> 01:07:46.940]  если там должно быть что-то факториал нуля, что вообще
[01:07:46.940 --> 01:07:49.940]  для отрицательных вообще не понятно, что делать.
[01:07:49.940 --> 01:07:55.940]  В общем, да, ладно, короче говоря, если у вас не вполне
[01:07:55.940 --> 01:07:58.420]  упорядоченное множество, то к рекурсии нужно аккуратно
[01:07:58.420 --> 01:08:00.420]  подходить, и она может ничего не дать, может дать все
[01:08:00.420 --> 01:08:01.420]  угодно.
[01:08:01.420 --> 01:08:08.420]  И, соответственно, ничего не получится.
[01:08:08.420 --> 01:08:12.500]  Ну, хорошо, но даже пусть у нас с теорией множеств
[01:08:12.500 --> 01:08:15.420]  есть тярема, почему, собственно, программа есть, которая
[01:08:15.420 --> 01:08:16.420]  ее вычислит.
[01:08:16.900 --> 01:08:19.900]  Чего вычислимая функция получится?
[01:08:19.900 --> 01:08:20.900]  Вот.
[01:08:20.900 --> 01:08:22.900]  Ну, вот почему.
[01:08:22.900 --> 01:08:27.900]  Значит, смотрите, рассмотрим программу, такую не программу,
[01:08:27.900 --> 01:08:29.900]  да, функцию двух аргументов.
[01:08:29.900 --> 01:08:36.900]  Значит, v от p и n.
[01:08:36.900 --> 01:08:44.900]  Значит, это будет равняться как раз единице, если n равно
[01:08:45.380 --> 01:08:46.380]  е.
[01:08:46.380 --> 01:09:03.380]  Ну, значит, еn умножить на, я нет, сейчас, извините,
[01:09:03.380 --> 01:09:10.380]  здесь я не могу писать v, ну, наверное, надо написать.
[01:09:15.380 --> 01:09:22.380]  Так, ладно, сейчас, дайте попробую правильно написать,
[01:09:22.380 --> 01:09:29.380]  значит, тут, если n больше 0.
[01:09:29.380 --> 01:09:34.380]  Так, хорошо, значит, тогда что получается?
[01:09:34.380 --> 01:09:41.380]  Да, наверное, правильно, да, потому что тут я как бы
[01:09:41.860 --> 01:09:45.860]  не вращаю какую-то программу в ту, которая не на вот
[01:09:45.860 --> 01:09:48.860]  это воспринимает как правильную, ее применять к n-1, умножать
[01:09:48.860 --> 01:09:51.860]  на n, да, но теперь это тут уже не обязательно u.
[01:09:51.860 --> 01:09:52.860]  Вот.
[01:09:52.860 --> 01:09:55.860]  Но как раз тярема к линии говорит, что вот это v можно
[01:09:55.860 --> 01:09:56.860]  и на u тоже заменить.
[01:09:56.860 --> 01:09:57.860]  Значит, почему?
[01:09:57.860 --> 01:09:58.860]  Смотрите.
[01:09:58.860 --> 01:10:01.860]  Значит, если u это главная уникальная вычисленная
[01:10:01.860 --> 01:10:06.860]  функция, то тогда существует сюда определенная s, значит,
[01:10:06.860 --> 01:10:10.860]  такая, что для любого p, для любого n, значит, v вот
[01:10:11.340 --> 01:10:16.340]  u от p и n равняется u от s от p и n.
[01:10:19.340 --> 01:10:22.340]  Так, значит, дальше.
[01:10:22.340 --> 01:10:32.340]  По тяреме к линии теперь, по тяреме к линии у нас существует
[01:10:32.820 --> 01:10:39.820]  п, такое, что для любого n, u от p и n, значит, равняется
[01:10:42.820 --> 01:10:45.820]  u от s от p и n.
[01:10:45.820 --> 01:10:47.820]  Тут как раз очень удобно, да, что и в условиях тяремы
[01:10:47.820 --> 01:10:49.820]  к линии, и в определении главной универсальной
[01:10:49.820 --> 01:10:52.820]  вычисленной функции у нас функция вычисленной
[01:10:52.820 --> 01:10:53.820]  всегда определенная.
[01:10:53.820 --> 01:10:57.820]  Да, то есть вот эту s я осределяю как функцию h из условий
[01:10:57.820 --> 01:10:58.820]  тяремы к линии.
[01:10:59.300 --> 01:11:00.300]  Вот.
[01:11:00.300 --> 01:11:05.300]  После этого получаем следующее.
[01:11:05.300 --> 01:11:22.300]  Значит, получаем, что при этом p и любом n, значит,
[01:11:22.780 --> 01:11:30.780]  получаем следующее, то u от p и n равняется u от s от
[01:11:30.780 --> 01:11:43.780]  p, так, от s от p и n, это у нас равняется v от p и n, а это
[01:11:43.780 --> 01:11:48.780]  равняется как раз единице, если n равно 0, значит, и n
[01:11:49.260 --> 01:11:54.260]  умножить на u от p и n минус 1, если n больше 0.
[01:11:54.260 --> 01:11:55.260]  Вот.
[01:11:55.260 --> 01:12:00.260]  И теперь, если посмотреть на начало и на конец, то
[01:12:00.260 --> 01:12:04.260]  получается, что именно программа p удовлетворяет рекурсивному
[01:12:04.260 --> 01:12:05.260]  правилу.
[01:12:05.260 --> 01:12:10.260]  Но вот и получается, что есть программа, и так на
[01:12:10.260 --> 01:12:12.260]  самом деле не только для этого, а для любого правила,
[01:12:12.260 --> 01:12:15.260]  то есть отсюда уже недалеко до общей тяремы, что для
[01:12:15.740 --> 01:12:19.740]  вычислимого рекурсивного правила, надо там только,
[01:12:19.740 --> 01:12:21.740]  вот, чтобы это прям точно с теми получилось, нужно
[01:12:21.740 --> 01:12:23.740]  аккуратно сказать про условия завершения.
[01:12:23.740 --> 01:12:30.740]  Да, что нужно, ну, например, да, например, можно сказать,
[01:12:30.740 --> 01:12:35.740]  что значение в каждой точке зависит только от меньших,
[01:12:35.740 --> 01:12:38.740]  значений в меньших точках, тогда в 0 автоматически
[01:12:38.740 --> 01:12:40.740]  нужно взять конкретное значение задать, потому
[01:12:40.740 --> 01:12:41.740]  что меньших у него нету.
[01:12:42.220 --> 01:12:43.220]  Вот.
[01:12:43.220 --> 01:12:46.220]  Значит, соответственно, для любого рекурсивного
[01:12:46.220 --> 01:12:50.220]  правила существует программа, которая этому правилу соответствует.
[01:12:57.220 --> 01:12:58.220]  Ну вот.
[01:13:00.220 --> 01:13:02.220]  Вот такое применение.
[01:13:04.220 --> 01:13:06.220]  Ну что, есть какие-нибудь вопросы?
[01:13:12.220 --> 01:13:14.220]  Ну тогда на сегодня все.
[01:13:14.220 --> 01:13:17.220]  Спасибо за внимание, будем приходить к арифметике.
