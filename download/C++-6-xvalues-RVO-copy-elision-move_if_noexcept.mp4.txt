[00:00.000 --> 00:09.680]  В целом мы в принципе после вчерашнего, после прошлого
[00:09.680 --> 00:14.080]  раза должны уже полностью понимать муфсимантику.
[00:14.080 --> 00:15.080]  Вот.
[00:15.080 --> 00:19.680]  И на самом деле то, что я сейчас буду говорить, оно
[00:19.680 --> 00:25.440]  уже скорее не прям муфсимантика, а это скорее такие смежные
[00:25.440 --> 00:26.440]  вещи.
[00:27.440 --> 00:30.440]  Идей на вся муфсимантика уже нами пройдена, вместе
[00:30.440 --> 00:32.400]  с форвардом и тому подобное.
[00:32.400 --> 00:35.800]  Тем не менее есть еще одна очень смежная, очень родственная
[00:35.800 --> 00:43.320]  муфсимантики тема, а именно X-values, RVO и Copy Elision.
[00:43.320 --> 00:46.320]  Не больно, а приятно.
[00:46.320 --> 00:47.880]  Да-да-да, не больно, а приятно.
[00:47.880 --> 01:06.040]  Вот, как, значит, есть такое высказывание, не помню
[01:06.040 --> 01:07.040]  чьё.
[01:07.040 --> 01:09.160]  Pain is inevitable, suffering is optional.
[01:10.160 --> 01:11.160]  Вот.
[01:11.160 --> 01:19.040]  Смотрите, я до сих пор не произносил этого слова
[01:19.040 --> 01:22.680]  X-value, ну то есть я его произносил так осторожно, но не рассказывал
[01:22.680 --> 01:23.680]  что-то такое.
[01:23.680 --> 01:26.720]  Я вам рассказывал, что есть R-value и L-value, и мы в принципе
[01:26.720 --> 01:30.600]  все классифицировали и разобрались, как оно работает, но на самом
[01:30.600 --> 01:34.400]  деле внимательные слушатели могли заметить, что вообще-то
[01:35.240 --> 01:38.240]  есть еще один вид value в C++11, это X-value.
[01:38.240 --> 01:49.240]  И с ним еще два появляются, PR-value и JL-value.
[01:49.240 --> 01:57.040]  Сейчас я все напишу, не переживайте.
[01:57.040 --> 02:02.480]  Так, значит, смотрите, смотрите, на самом деле, вот, сакральное
[02:02.560 --> 02:03.560]  знание таково.
[02:03.560 --> 02:07.560]  Вот, для того, чтобы понимать муфсемантику, достаточно
[02:07.560 --> 02:09.240]  знать только две value-категории.
[02:09.240 --> 02:15.120]  Вот, вот это неочевидный факт, когда люди читают
[02:15.120 --> 02:18.560]  лекции какие-то по муфсемантике или когда люди пытаются
[02:18.560 --> 02:21.440]  заботиться сами по книжкам муфсемантики, пишут статьи,
[02:21.440 --> 02:25.600]  они зачем-то вводят все пять категорий, но если на самом
[02:25.600 --> 02:28.480]  деле глубоко разобраться, сам я разобрался, как я
[02:28.480 --> 02:32.640]  уже сказал не с первого далеко раза, вот, это, значит,
[02:32.640 --> 02:35.400]  вот, с вершином многолетнего опыта, так сказать, рассказываю
[02:35.400 --> 02:38.400]  вам истину, которая мне открыла сравнительно недавно.
[02:38.400 --> 02:41.400]  Чтобы понимать муфсемантику, нигде не нужно использовать
[02:41.400 --> 02:43.840]  понятие X-value, поэтому я до сих пор его не вводил.
[02:43.840 --> 02:47.080]  Все то, что мы до этого прошли, оно только лишь опирается
[02:47.080 --> 02:51.440]  на R-value и L-value, а понятие X-value, оно нужно на самом
[02:51.440 --> 02:55.200]  деле для другого, вот, для этого, для того, чтобы правильно
[02:55.200 --> 02:57.240]  понять, как работает RVO и копия Legion.
[02:57.240 --> 02:59.800]  Для того, чтобы пройти ревью до гейнтеза.
[02:59.800 --> 03:03.040]  Это смежная тема с муфсемантикой, но на самом деле муфсемантика
[03:03.040 --> 03:04.920]  и без X-value прекрасно бы работала.
[03:04.920 --> 03:11.400]  Так вот, мы, чтобы жизнь совсем скучной не казалась,
[03:11.400 --> 03:15.520]  ведем еще три value-категории сейчас вместе с комитетом
[03:15.520 --> 03:21.240]  C++11 и скажем, что вообще-то, начиная с C++11, у нас будет
[03:21.240 --> 03:30.040]  не только L-value и R-value, у нас будет L-value, так, какой
[03:30.040 --> 03:39.160]  из этих маркеров пишет, у нас будет L-value, X-value и
[03:39.160 --> 03:40.160]  PR-value.
[03:40.160 --> 03:45.240]  Это сейчас что?
[03:45.240 --> 03:48.840]  Я говорю, что выражения бывают одной из трех категорий,
[03:48.840 --> 03:55.160]  L-value, X-value, PR-value, X-value и PR-value вместе называются
[03:55.160 --> 03:56.160]  R-value.
[03:56.160 --> 03:59.520]  То есть, на самом деле, R-value подразделяется еще на
[03:59.520 --> 04:00.520]  два вида.
[04:00.520 --> 04:04.320]  Это бывает либо X-value, либо PR-value, L-value больше ни на
[04:04.320 --> 04:09.000]  что не подразделяется, но L-value и X-value вместе называются
[04:09.000 --> 04:10.000]  GL-value.
[04:10.000 --> 04:19.400]  Значит, я говорю, что теперь мы R-value классифицируем
[04:19.400 --> 04:22.440]  еще на две подразновидности, это будет либо X-value, либо
[04:22.440 --> 04:29.000]  PR-value, L-value — это наше старое L-value, как мы его знаем, R-value
[04:29.000 --> 04:32.480]  — это наше старое R-value, как мы его знаем, и L-value
[04:32.480 --> 04:36.320]  и X-value вместе называются GL-value.
[04:36.800 --> 04:41.120]  Значит, теперь я вам просто расскажу, что такое X-value,
[04:41.120 --> 04:43.160]  а все остальное будет называться PR-value.
[04:43.160 --> 04:47.120]  Так вы помните длинный список того, чем бывает R-value?
[04:47.120 --> 04:50.440]  Я сейчас просто перечислю вам, что называется X-value,
[04:50.440 --> 04:51.920]  а все остальное — это PR-value.
[04:51.920 --> 04:54.960]  То есть, PR-value формально определяется как все то
[04:54.960 --> 04:57.080]  R-value, которое не X-value.
[04:57.080 --> 05:00.240]  X-value давайте для начала я расшифрую.
[05:00.240 --> 05:02.480]  Это расшифруется как expired value.
[05:02.480 --> 05:06.840]  Слово expired, ну что значит expired?
[05:06.840 --> 05:11.880]  Ну такое просроченное, устаревшее, протухшее продукт в магазине, expired.
[05:11.880 --> 05:21.320]  Вот, expired value, которое выкинуть уже пора, оно, ну все, испортилось, пора его выкинуть.
[05:21.320 --> 05:26.240]  А PR-value в то же время — это pure R-value.
[05:26.240 --> 05:29.320]  Что значит pure?
[05:29.320 --> 05:30.840]  Нет.
[05:31.680 --> 05:36.760]  Pure — значит, ну pure, металлы бывают, pure, да, типа чистый металл.
[05:36.760 --> 05:40.520]  Pure — это такой настоящий, подлинный R-value.
[05:40.520 --> 05:44.120]  Не какой-то там с примесями, а самое, что ни на есть, — настоящее R-value.
[05:44.120 --> 05:49.160]  То есть R-value бывает настоящим R-value, ну вот таким вот самым, что ни на есть, правильным,
[05:49.160 --> 05:52.880]  и просроченным каким-то выкинуть, который пора.
[05:52.880 --> 05:56.120]  Вот, а что такое GL-value?
[05:56.120 --> 05:59.440]  GL-value означает generalized L-value, обобщенное L-value.
[06:01.520 --> 06:07.520]  Есть некоторые вопросы по поводу такого naming.
[06:07.520 --> 06:13.520]  То есть, короче, если L-value, она становится L-value.
[06:13.520 --> 06:17.800]  Отгадайте, что является X-value, вот исходя из этих названий.
[06:17.800 --> 06:24.800]  L-value, ой, X-value называются как бы то, что раньше было L-value, но его move-нули.
[06:24.800 --> 06:25.800]  Вот идея в чем.
[06:26.760 --> 06:33.760]  То есть X-value — это как раз либо статик каст к типу с двумя амперсандами.
[06:33.760 --> 06:44.760]  Либо результат вызова функции, которая возвращает тип с двумя амперсандами.
[06:44.760 --> 06:51.760]  Либо еще некоторые технические пункты, ну то есть либо это знак вопроса двоеточие,
[06:52.720 --> 06:56.720]  где один из оперантов или оба операнта X-value, я не помню.
[06:56.720 --> 07:01.720]  Либо это запятая, где правый оперант R-value, ну и так далее.
[07:01.720 --> 07:06.720]  Две основных вещи, которыми является X-value, это вот что.
[07:06.720 --> 07:09.720]  Ключевые два пункта при линии X-value — это вот эти два.
[07:09.720 --> 07:16.720]  Остальные — это технические пункты, понятно, очевидные.
[07:17.680 --> 07:21.680]  То есть вот как раз те R-value, которые связаны с двумя амперсандами,
[07:21.680 --> 07:24.680]  R-value у нас было и раньше, в C++03.
[07:24.680 --> 07:25.680]  Что?
[07:25.680 --> 07:27.680]  Возвращаемое значение из функции.
[07:27.680 --> 07:31.680]  Ну, это результат вызова функции, у которой возвращаемый тип с двумя амперсандами.
[07:31.680 --> 07:34.680]  Ну, понятие X-value видимо только с 1 стилем.
[07:34.680 --> 07:35.680]  Чем она протувшая тогда?
[07:35.680 --> 07:36.680]  Это что самое ее есть?
[07:36.680 --> 07:39.680]  Нет, это… Что такое?
[07:39.680 --> 07:42.680]  Это ссылка на какой-то объект, но R-value — ссылка.
[07:43.640 --> 07:45.640]  X-value — ссылка означает, что этот объект…
[07:45.640 --> 07:48.640]  Ну, выкинуть на свалку, можно у него забирать поляпора.
[07:48.640 --> 07:52.640]  Значит, X-value — идея в том, что это некоторый объект,
[07:52.640 --> 07:55.640]  который реально в памяти лежит, и он жил, существовал,
[07:55.640 --> 07:56.640]  но его move-нули.
[07:56.640 --> 08:00.640]  Ну, то есть его либо скастили, не обязательно static-cast,
[08:00.640 --> 08:02.640]  любой каст к типу с двумя амперсандами, разумеется.
[08:02.640 --> 08:05.640]  Его либо скастили к типу с двумя амперсандами,
[08:05.640 --> 08:09.640]  либо вернули из функции ссылку с двумя амперсандами.
[08:10.600 --> 08:13.600]  В частности, результат move-а — это X-value.
[08:13.600 --> 08:14.600]  Вот.
[08:14.600 --> 08:18.600]  Также X-value является, значит, знак вопроса двоеточие
[08:18.600 --> 08:20.600]  из опятая в понятных каких сценариях.
[08:20.600 --> 08:25.600]  А также еще некоторые выражения, которые мы с вами увидим.
[08:25.600 --> 08:27.600]  Ну, например…
[08:29.600 --> 08:33.600]  Ну, например, там, скажем, обращение по индексу
[08:33.600 --> 08:37.600]  к объекту, который был R-value, скажем.
[08:37.600 --> 08:38.600]  Ну, там что-то такое.
[08:38.600 --> 08:41.600]  Ну, если у вас был вектор из каких-то строк,
[08:41.600 --> 08:45.600]  и вы сделали std move от этого вектора, квадратные скобочки по индексу,
[08:45.600 --> 08:48.600]  то получится X-value, потому что оно…
[08:48.600 --> 08:50.600]  Ну, понятно, что его забирать можно.
[08:50.600 --> 08:53.600]  Вектор-то вы move-нули, значит, его содержимое как бы просроченное.
[08:53.600 --> 08:55.600]  Аналогично, если вы…
[08:55.600 --> 08:58.600]  Это вот как раз тот самый пример, который я в прошлый раз пытался было сказать,
[08:58.600 --> 09:01.600]  но позапрошлый даже, но не очень корректно сказал.
[09:01.600 --> 09:06.600]  Если вы взяли какой-то R-value и к полю обратились,
[09:06.600 --> 09:07.600]  причем это поле само было объектом.
[09:07.600 --> 09:08.600]  Вот там уточнение.
[09:08.600 --> 09:11.600]  Мы с вами выясняли, что если просто к полю обратиться,
[09:11.600 --> 09:12.600]  это еще не R-value.
[09:12.600 --> 09:15.600]  А если вы взяли R-value объекту и обратились к полю,
[09:15.600 --> 09:18.600]  и само поле было объектом, то это тоже X-value считается.
[09:18.600 --> 09:22.600]  Короче говоря, это когда вы точкой обращаетесь к R-value объекту
[09:22.600 --> 09:25.600]  или квадратными скобочками по индексу обращаетесь к R-value вектору.
[09:25.600 --> 09:27.600]  Или, видимо, стрелочкой.
[09:27.600 --> 09:28.600]  Или стрелочкой.
[09:28.600 --> 09:30.600]  Ну, и в общем, ну, и либо когда вы кастите.
[09:30.600 --> 09:33.600]  То есть идея в том, что это такие виды, такое value,
[09:33.600 --> 09:38.600]  которое было полноценным объектом, но его как бы move-нули.
[09:38.600 --> 09:44.600]  То есть вот это то value, для которого нужно вызывать R-value-шные операции.
[09:44.600 --> 09:48.600]  Хотя оно было, как казалось бы, полноценной переменной.
[09:48.600 --> 09:51.600]  В противоположность этому PR-value.
[09:51.600 --> 09:57.600]  Это штука, которая, ну, формально это просто все остальное R-value,
[09:57.600 --> 09:59.600]  а неформально.
[09:59.600 --> 10:07.600]  Вот это тоже довольно такая, не сразу пришедшая ко мне интуиция, я не знаю.
[10:07.600 --> 10:10.600]  А может быть не move-нутая R-value?
[10:10.600 --> 10:12.600]  Что с не move-нутой R-value? Что?
[10:12.600 --> 10:14.600]  Не move-нутая R-value.
[10:14.600 --> 10:16.600]  Ну, A плюс B у тебя.
[10:16.600 --> 10:18.600]  Вот A плюс B результат суммы. Это R-value.
[10:18.600 --> 10:22.600]  Его никто не move-ал, оно просто на месте создалось, и это R-value.
[10:22.600 --> 10:24.600]  Так вот.
[10:24.600 --> 10:26.600]  Ну?
[10:30.600 --> 10:33.600]  Ну, если тип поля M был классовым,
[10:33.600 --> 10:36.600]  например, у вас в поле была строка,
[10:36.600 --> 10:39.600]  и вы сделали вот такое точка M, где M это строка,
[10:39.600 --> 10:41.600]  тогда выражение будет считаться X-value.
[10:41.600 --> 10:46.600]  Если вы его передадите в функцию, которая может принимать const string&,
[10:46.600 --> 10:50.600]  или string 2&, вы попадете в версию со string 2&.
[10:50.600 --> 10:54.600]  Потому что эта штука, по логике вещей, должна быть move-нута.
[10:54.600 --> 10:57.600]  А как выражение из нескольких частей, где одна часть X-value,
[10:57.600 --> 11:00.600]  другая X-value, это будет R-value считаться?
[11:00.600 --> 11:02.600]  Что такое части? Какое выражение?
[11:02.600 --> 11:06.600]  Пусть у нас вот была какая-то строка, которая была X-value,
[11:06.600 --> 11:08.600]  мы к ней прибавили строку R-value.
[11:08.600 --> 11:10.600]  Строка... Не может.
[11:10.600 --> 11:12.600]  Это положение двух строк?
[11:12.600 --> 11:15.600]  R-value определяется для верхнего уровня.
[11:15.600 --> 11:17.600]  Для этого выражения?
[11:17.600 --> 11:20.600]  Бинарный плюс от R-value, я же вам говорил.
[11:20.600 --> 11:23.600]  Обычное R-value, причем не move-нута.
[11:25.600 --> 11:27.600]  Бинарный плюс вообще для строк.
[11:27.600 --> 11:29.600]  Это некоторый оператор переопределенный.
[11:29.600 --> 11:31.600]  У него есть возвращаемый тип, просто string.
[11:31.600 --> 11:33.600]  Тогда он по R-value.
[11:33.600 --> 11:35.600]  Вот.
[11:36.600 --> 11:38.600]  Зачем это все?
[11:38.600 --> 11:41.600]  Вопреки распространенному заблуждению,
[11:41.600 --> 11:43.600]  это, как я уже сказал, для понимания,
[11:43.600 --> 11:45.600]  как работает move или forward не нужно.
[11:45.600 --> 11:49.600]  Зато это нужно для понимания,
[11:49.600 --> 11:52.600]  как работает вот эта штука.
[11:52.600 --> 11:54.600]  Copy-elision.
[11:54.600 --> 11:56.600]  Что такое copy-elision?
[11:56.600 --> 11:58.600]  Давайте рассмотрим следующий код.
[11:58.600 --> 12:00.600]  Я пишу string...
[12:01.600 --> 12:03.600]  Например, я пишу string...
[12:03.600 --> 12:05.600]  О, какой хороший маркер.
[12:05.600 --> 12:07.600]  string s равно...
[12:07.600 --> 12:09.600]  Ну, если это string, я имею в виду,
[12:09.600 --> 12:11.600]  равно string круглые скобочки.
[12:11.600 --> 12:13.600]  Как это по-вашему должно работать?
[12:13.600 --> 12:15.600]  Оно вызовется...
[12:15.600 --> 12:17.600]  Сколько конструкторов вызовется?
[12:17.600 --> 12:19.600]  Ну, хотелось бы...
[12:19.600 --> 12:21.600]  А как это работает?
[12:21.600 --> 12:23.600]  Он возвращает move.
[12:23.600 --> 12:25.600]  То есть, если мы...
[12:25.600 --> 12:27.600]  Вызовется ли move-конструктор для нас?
[12:27.600 --> 12:29.600]  Да.
[12:29.600 --> 12:31.600]  Допустим, у строки есть move-конструктор.
[12:31.600 --> 12:33.600]  Вообще очень хотелось бы,
[12:33.600 --> 12:35.600]  чтобы это произошло просто как конструктор
[12:35.600 --> 12:37.600]  для строки.
[12:37.600 --> 12:39.600]  Кто считает, что вызовется move-конструктор?
[12:39.600 --> 12:41.600]  Ну, по идее ложечки.
[12:41.600 --> 12:43.600]  Ну, по идее ложечки.
[12:43.600 --> 12:45.600]  Я...
[12:45.600 --> 12:47.600]  Вы все никак не запомните,
[12:47.600 --> 12:49.600]  что если я задаю такой вопрос,
[12:49.600 --> 12:51.600]  на кто считает, то правильный ответ не такой.
[12:51.600 --> 12:53.600]  Нет, конечно, не вызовется
[12:53.600 --> 12:55.600]  никому move-конструктор.
[12:55.600 --> 12:57.600]  А, хорошо.
[12:57.600 --> 12:59.600]  Это похвально, да.
[13:03.600 --> 13:05.600]  Да.
[13:05.600 --> 13:07.600]  Если подходить к этому делу
[13:07.600 --> 13:09.600]  чисто формально, так сказать, педантично,
[13:09.600 --> 13:11.600]  то есть идея, что
[13:11.600 --> 13:13.600]  в нашем C++03 мире,
[13:13.600 --> 13:15.600]  как мы это себе видим,
[13:15.600 --> 13:17.600]  да даже в C++11 мире,
[13:17.600 --> 13:19.600]  в рамках того,
[13:19.600 --> 13:21.600]  что мы формально изучили,
[13:21.600 --> 13:23.600]  это некоторые expression,
[13:23.600 --> 13:25.600]  здесь называется конструктор по умолчанию,
[13:25.600 --> 13:27.600]  а это некоторые инициализации,
[13:27.600 --> 13:29.600]  то есть мы должны строку S конструировать
[13:29.600 --> 13:31.600]  от того, что справа,
[13:31.600 --> 13:33.600]  то есть как бы мы должны строку S
[13:33.600 --> 13:35.600]  сконструировать от вот этой штуки,
[13:35.600 --> 13:37.600]  которая является R-value строкой,
[13:37.600 --> 13:39.600]  конструктор строки.
[13:39.600 --> 13:41.600]  Но комитет давным-давно понял, что это какой-то бред
[13:41.600 --> 13:43.600]  и вообще-то незачем делать
[13:43.600 --> 13:45.600]  дважды вызов конструктора,
[13:45.600 --> 13:47.600]  когда можно один раз сделать.
[13:47.600 --> 13:49.600]  Но как это формально
[13:51.600 --> 13:53.600]  как формально сказать,
[13:53.600 --> 13:55.600]  в каком случае
[13:55.600 --> 13:57.600]  компилятор имеет право
[13:57.600 --> 13:59.600]  не вызывать
[14:01.600 --> 14:03.600]  второй конструктор. Другой пример.
[14:03.600 --> 14:05.600]  Давайте представим, что я сейчас
[14:05.600 --> 14:07.600]  делаю следующие. У меня есть некоторая функция,
[14:07.600 --> 14:09.600]  посмотрите, пожалуйста, на второй пример.
[14:09.600 --> 14:11.600]  У меня есть, я вам привожу
[14:11.600 --> 14:13.600]  еще один пример подобного рода,
[14:13.600 --> 14:15.600]  представьте, у меня есть функция, которая принимает
[14:15.600 --> 14:17.600]  строки, я не знаю, по ссылке,
[14:17.600 --> 14:19.600]  неважно, по какой даже,
[14:19.600 --> 14:21.600]  и я передаю в нее следующую вещь,
[14:21.600 --> 14:23.600]  string от
[14:23.600 --> 14:25.600]  string от
[14:25.600 --> 14:27.600]  вот так вот,
[14:27.600 --> 14:29.600]  от ничего. Сколько
[14:29.600 --> 14:31.600]  конструкторов вызовется?
[14:31.600 --> 14:33.600]  Один.
[14:33.600 --> 14:35.600]  Все еще. Создаться лишь одна строка.
[14:35.600 --> 14:37.600]  Эта штука будет просто
[14:37.600 --> 14:39.600]  как бы, забьет компилятор
[14:39.600 --> 14:41.600]  на нее.
[14:41.600 --> 14:43.600]  Да. Не важно, сколько раз
[14:43.600 --> 14:45.600]  я напишу, не важно, сколько раз
[14:45.600 --> 14:47.600]  я напишу string от string от
[14:47.600 --> 14:49.600]  string от чего-то.
[14:49.600 --> 14:51.600]  Компилятор, да, это
[14:51.600 --> 14:53.600]  по сути тот же самый пример.
[14:53.600 --> 14:55.600]  Компилятор в таких ситуациях просто
[14:55.600 --> 14:57.600]  забивает создавать
[14:57.600 --> 14:59.600]  промежуточный временный объект.
[14:59.600 --> 15:01.600]  Он сразу создает финальный объект, который
[15:01.600 --> 15:03.600]  должен у него в конце получиться
[15:03.600 --> 15:05.600]  сразу на нужном месте в памяти.
[15:05.600 --> 15:07.600]  Он не делает временный string,
[15:07.600 --> 15:09.600]  чтобы из него moveнуть сразу.
[15:09.600 --> 15:11.600]  Это явление как раз называется
[15:11.600 --> 15:13.600]  copy-elision. Вот вас где-нибудь
[15:13.600 --> 15:15.600]  на каком-нибудь
[15:15.600 --> 15:17.600]  собеседовании или экзамене сейчас могут
[15:17.600 --> 15:19.600]  спросить, copy-elision это
[15:19.600 --> 15:21.600]  как объяснить такое copy-elision
[15:21.600 --> 15:23.600]  в двух словах? Это когда вместо
[15:23.600 --> 15:25.600]  копий конструкторов вызывается move-конструктор, это
[15:25.600 --> 15:27.600]  неправильный ответ. Правильный ответ
[15:27.600 --> 15:29.600]  copy-elision это явление, когда компилятор
[15:29.600 --> 15:31.600]  избегает вызова и копии,
[15:31.600 --> 15:33.600]  и move-конструкторов. Он просто
[15:33.600 --> 15:35.600]  забивает на создание временного объекта.
[15:35.600 --> 15:37.600]  Вот что такое copy-elision.
[15:37.600 --> 15:39.600]  Какой вопрос?
[15:39.600 --> 15:41.600]  Там нет
[15:41.600 --> 15:43.600]  никакого труга, чтобы
[15:43.600 --> 15:45.600]  заставить его там попытаться
[15:45.600 --> 15:47.600]  в два объекта это сложить.
[15:47.600 --> 15:49.600]  Что-то в духе t равно s равно string.
[15:49.600 --> 15:51.600]  Вот, давайте я вам скажу,
[15:51.600 --> 15:53.600]  я не знаю, это какой-то
[15:53.600 --> 15:55.600]  сложный вопрос, не могу.
[15:55.600 --> 15:57.600]  Результат присваивания.
[15:57.600 --> 15:59.600]  Это же string от vector от string
[15:59.600 --> 16:01.600]  от одного
[16:01.600 --> 16:03.600]  от нуля.
[16:03.600 --> 16:05.600]  Я не очень понимаю, что такое string от vector от string.
[16:05.600 --> 16:07.600]  Это хороший вопрос,
[16:07.600 --> 16:09.600]  сейчас я тебе про это расскажу,
[16:09.600 --> 16:11.600]  сейчас я чуть позже расскажу про этот пример.
[16:13.600 --> 16:15.600]  Давай
[16:15.600 --> 16:17.600]  я запишу его.
[16:17.600 --> 16:19.600]  String от
[16:19.600 --> 16:21.600]  vector от string
[16:21.600 --> 16:23.600]  от vector из строк
[16:23.600 --> 16:25.600]  от одного
[16:25.600 --> 16:27.600]  от одного
[16:27.600 --> 16:29.600]  от нуля.
[16:29.600 --> 16:31.600]  Сколько раз
[16:31.600 --> 16:33.600]  вызовется конструктор? Это хороший вопрос.
[16:33.600 --> 16:35.600]  Да.
[16:35.600 --> 16:37.600]  Нет, здесь copy-elision уже не спасет,
[16:37.600 --> 16:39.600]  не сработает.
[16:39.600 --> 16:41.600]  И вот почему. Потому что существует
[16:41.600 --> 16:43.600]  как раз формальное правило, когда компилятор
[16:43.600 --> 16:45.600]  имеет право не создавать промежуточный
[16:45.600 --> 16:47.600]  временный объект. Отгадайте когда,
[16:47.600 --> 16:49.600]  для чего я вам рассказывал про эти категории,
[16:49.600 --> 16:51.600]  когда он pair-value.
[16:51.600 --> 16:53.600]  Значит, если у вас
[16:53.600 --> 16:55.600]  компилятор видит, что есть некоторое
[16:55.600 --> 16:57.600]  pair-value, из которого создается
[16:57.600 --> 16:59.600]  другое pair-value, из которого создается другое
[16:59.600 --> 17:01.600]  pair-value и так далее, из которого
[17:01.600 --> 17:03.600]  наконец-то создается объект,
[17:03.600 --> 17:05.600]  переменная какая-то, ну или
[17:05.600 --> 17:07.600]  финальное выражение,
[17:07.600 --> 17:09.600]  то все промежуточные pair-value
[17:09.600 --> 17:11.600]  компилятор имеет право просто не
[17:11.600 --> 17:13.600]  создавать.
[17:13.600 --> 17:15.600]  Можно еще раз формально
[17:15.600 --> 17:17.600]  ответить?
[17:17.600 --> 17:19.600]  Если у вас есть
[17:19.600 --> 17:21.600]  pair-value, из которого создается
[17:21.600 --> 17:23.600]  несколько раз pair-value,
[17:23.600 --> 17:25.600]  а в конце наконец что-то создается
[17:25.600 --> 17:27.600]  и выражение на этом заканчивается,
[17:27.600 --> 17:29.600]  то все эти промежуточные штуки, которые являются
[17:29.600 --> 17:31.600]  pair-value выражениями компилятор имеет
[17:31.600 --> 17:33.600]  право не создавать.
[17:33.600 --> 17:35.600]  Вот именно здесь это и происходит.
[17:35.600 --> 17:37.600]  Вот здесь вот
[17:37.600 --> 17:39.600]  создается pair-value, из которого
[17:39.600 --> 17:41.600]  создается string, который придется в строку.
[17:41.600 --> 17:43.600]  Если я здесь сколько угодно раз бы написал
[17:43.600 --> 17:45.600]  string от какого-то pair-value,
[17:45.600 --> 17:47.600]  от какого-то еще pair-value,
[17:47.600 --> 17:49.600]  то компилятор имел право просто это все соптимизировать
[17:49.600 --> 17:59.400]  только настоящий только финальный стринг нет потому что x value это сейчас потому что x value
[17:59.400 --> 18:06.800]  это по смыслу это то что реально существует в памяти вот x value это некоторая реально
[18:06.800 --> 18:13.680]  существующая вещь в памяти а pair value это штука которая вообще может не существовать она может
[18:13.680 --> 18:18.360]  только в каких-то промежуточных рассуждениях фигурировать но под нее может фактически не
[18:18.360 --> 18:25.480]  создаваться даже в памяти ничего не факта может быть и существовать если компилятор ну например
[18:25.480 --> 18:35.400]  вот это же компилятор в итоге должен создать чтобы его по ссылке отдать но я не понимаю что
[18:35.400 --> 18:40.600]  значит нужна это какой-то короче pair value это то что компилятор имеет право просто не создавать
[18:40.600 --> 18:47.440]  вот оно может как как выражение быть написано но реально в памяти ему ничего не соответствует так
[18:47.440 --> 19:02.880]  кто ну я не знаю давай ты стринг положим в смысле стринг от стринг от abc но abc это будет
[19:02.880 --> 19:07.480]  конс чар звездочка конс чар звездочка конечно же существует где-то в статической памяти и кстати
[19:07.480 --> 19:13.160]  возможно поэтому она и l value как раз потому что для под нее же нужно выделить статическую как минимум
[19:13.160 --> 19:18.360]  память строковые литералы нужно хранить статической константной памяти но промежуточный стринг все
[19:18.360 --> 19:22.240]  еще может быть не создан а этот стринг конечно будет создан потому что по ссылке нужно туда
[19:22.240 --> 19:30.720]  отдать промежуточный не будет создан да если вы напишите стринг от стринг от abc в кавычках то
[19:30.720 --> 19:36.880]  у вас лишь один раз выдается конструктор стринг это начиная си плюс 117 причем гарантированное
[19:36.880 --> 19:43.640]  поведение до си плюс 117 это было такое implementation defined но желательное поведение а начиная си
[19:43.640 --> 19:47.960]  плюс 117 это гарантированное поведение называется гарантированный копии лежан кстати наш
[19:47.960 --> 19:53.120]  соотечественный кантон полухин принял участие в разработке этой фичи стандарт насколько я помню
[19:53.120 --> 19:55.680]  вот если я ничего не путаю да
[20:06.880 --> 20:23.880]  если у тебя есть значит смотри если ты делаешь стринг сейчас давайте вы задаете правильные
[20:23.880 --> 20:33.040]  вопросы я давайте сначала расскажу все что хочу а потом вы у вас часть вопросов вот падет я еще
[20:33.040 --> 20:37.240]  пока не рассказала вот про этот пример я сейчас как раз про него и расскажу я его записал чтобы не
[20:37.240 --> 20:42.120]  забыть про него и про этот пример я тоже запишу потому что они все относятся к одному и тому же вот
[20:42.120 --> 20:55.760]  я скажу стринг от abc плюс а на самом деле это все об одном и том же а это еще одно явление
[20:55.760 --> 21:01.600]  которое называется temporary materialization существует следующие явления для того чтобы вот с такими
[21:01.600 --> 21:08.080]  ситуациями правильно разбираться в стандарт вели следующие понятия называется temporary
[21:08.080 --> 21:14.040]  materialization что такое temporary materialization это явление когда r-value превращается в x-value
[21:14.040 --> 21:37.560]  pair-value превращается в x-value смотрите temporary materialization вот смотрите у выражения есть
[21:38.160 --> 21:45.520]  категория и если вы почитаете формально стандарт то на самом деле когда у выражения меняется
[21:45.520 --> 21:49.760]  в л и категории это тоже считается кастом ну то есть вы существует например понятие неявный
[21:49.760 --> 21:57.680]  l-value to r-value cast вот существует понятие неявный pair-value to x-value cast и он как раз и называется
[21:57.680 --> 22:04.800]  temporary materialization что это значит это значит что в некоторых ситуациях выражение которое является
[22:05.720 --> 22:11.400]  pair-value при некоторых его использованиях должно быть компилятором сконвертировано
[22:11.400 --> 22:18.880]  в x-value а следовательно как последствия должно быть создан объект под него это происходит в
[22:18.880 --> 22:27.640]  частности когда вы обращаетесь к полю или обращаетесь к методу или когда вы скажем так
[22:27.640 --> 22:36.560]  когда это самое старшее я не помню как это формально сказать в общем когда это когда вы
[22:36.560 --> 22:46.720]  привязываете его к переменной ну вот когда у вас есть что-нибудь такое string&s равно string это
[22:46.720 --> 22:54.160]  тоже temporary materialization то есть вот это выражение само по себе pair-value но из-за контекста оно
[22:54.160 --> 22:58.680]  должно быть компилятором как бы трактовано как x-value то есть под него должно быть создан
[22:58.680 --> 23:03.680]  реальный объект если выражение реально если к выражению привязывается некоторая переменная
[23:03.680 --> 23:09.440]  должно произойти temporary materialization то есть реальное создание объекта под соответствующего
[23:09.440 --> 23:20.080]  это выражение как ну кон string&s да вот да ну или string&s то есть когда вы привязываете когда
[23:20.080 --> 23:25.480]  происходит когда вы привязываете переменную к выражению это кстати происходит здесь когда вы
[23:25.480 --> 23:30.440]  когда вы в передаете вот это там же у вас что-то принимается его фактически привязываете
[23:30.440 --> 23:36.080]  переменную к этому выражению происходит temporary materialization когда вы обращаетесь к полю или к
[23:36.080 --> 23:42.880]  методу вот например здесь происходит temporary materialization потому что что такое vector string
[23:42.880 --> 23:48.320]  от одного квадратной скобочки 0 ну вообще-то это x-value если уж так-то вообще вот это само по
[23:48.540 --> 23:53.560]  себе выражение x value потому что это один из примеров x value я же говорил помüllt про
[23:53.560 --> 23:57.080]  квадратные скобочки если я квадратными скобочками обращается к вредному объекту
[23:57.080 --> 24:01.640]  то это x values а значит для него не ра б не т я сказал это раньше про квадратные скобочки
[24:01.640 --> 24:06.320]  здесь я говорил про тύпс не только не записал вот это времlett vector который сам по себе
[24:06.320 --> 24:12.680]  пр väl но обращение квадратными скобочками к нему это уже выражение x value это означает что
[24:12.680 --> 24:17.040]  этот вектор реально должен быть создан он не может проглотить все это и как бы не
[24:17.040 --> 24:18.760]  не создать только финальный стринг.
[24:18.760 --> 24:26.640]  Чего?
[24:26.640 --> 24:28.640]  Здесь я должен создать хоть одну строку.
[24:28.640 --> 24:32.800]  Вот если бы это стринг передавалось куда-то там
[24:32.800 --> 24:36.800]  еще и не происходило, под стринг сам по себе вот
[24:36.800 --> 24:38.720]  этот создавать, можно ничего не создавать.
[24:38.720 --> 24:46.560]  Что значит просто стринг-амперсант?
[24:46.560 --> 25:03.720]  Если ваше pair value это и есть все выражение, то это как
[25:03.720 --> 25:06.320]  бы верхний синтоксический уровень expression, то это все
[25:06.320 --> 25:07.400]  равно оно создается.
[25:07.400 --> 25:10.960]  То есть стринг от стринг от стринг от стринг создастся
[25:10.960 --> 25:15.800]  один стринг, потому что на последнем уровне произойдет
[25:15.800 --> 25:16.800]  temporary materialization.
[25:16.800 --> 25:20.200]  Вот он все pair value проглотит сколько надо раз, и на последнем
[25:20.200 --> 25:23.480]  шаге он будет считать, что это x value, потому что это
[25:23.480 --> 25:25.960]  финальная стадия вычтения выражения.
[25:25.960 --> 25:27.680]  Здесь произойдет это, потому что мы к переменной
[25:27.680 --> 25:29.680]  привязались, здесь произойдет это, потому что мы к переменной
[25:29.680 --> 25:32.240]  привязались, когда функцию передали, здесь произойдет
[25:32.240 --> 25:35.240]  это, потому что мы к переменной привязались, здесь произойдет
[25:35.240 --> 25:38.240]  это, потому что мы к оператору обратились, то есть мы фактически
[25:38.240 --> 25:40.280]  сделали к этому вектору точка оператор квадратной
[25:40.280 --> 25:41.280]  скобочки от чего-то.
[25:41.280 --> 25:45.040]  И здесь произойдет тоже temporary materialization, потому что
[25:45.120 --> 25:48.160]  мы опять к оператору обратились, то есть мы либо мы вызвали
[25:48.160 --> 25:51.960]  метод плюс от чара у строки, либо мы вызвали функцию
[25:51.960 --> 25:56.600]  оператор плюс внешнюю от стрингом персанта чего-то,
[25:56.600 --> 25:58.680]  но мы в любом случае привязались к переменной.
[25:58.680 --> 26:02.480]  Вот здесь вот происходит temporary materialization, то есть здесь
[26:02.480 --> 26:09.800]  реально будет создана строка, а потом создана вторая строка.
[26:09.840 --> 26:17.120]  Но если при этом я напишу, скажем, стринг s равно вот
[26:17.120 --> 26:20.560]  такое, то будет создано всего две строки, а не три.
[26:20.560 --> 26:22.920]  Первый раз будет создано строка вот в этой ситуации,
[26:22.920 --> 26:26.520]  а второй раз будет создано строка, являющейся их суммой,
[26:26.520 --> 26:29.080]  и для нее произойдет copy lesion, потому что эта строка
[26:29.080 --> 26:30.640]  уже pr-value снова.
[26:30.640 --> 26:43.680]  Да, вот эта вот штука начинает считаться x-value, а следовательно
[26:43.680 --> 26:45.440]  под нее нужно реально создать объект.
[26:45.440 --> 26:47.160]  Из-за оператора плюс?
[26:47.160 --> 26:51.480]  Из-за того, что мы вызываем, по одному из правил, мы вызываем
[26:51.480 --> 26:56.240]  метод строки, но если это внешняя функция, то это
[26:56.240 --> 26:58.840]  значит, что мы стринг этот передаем по ссылке в какую-то
[26:58.880 --> 27:01.280]  внешнюю функцию, а это тоже temporary materialization.
[27:01.280 --> 27:02.280]  Да.
[27:02.280 --> 27:09.600]  Я имел в виду то, что тут у нас конструктор от другого
[27:09.600 --> 27:13.600]  стринга что-то делает, и наоборот он увеличивает
[27:13.600 --> 27:14.600]  какой-то счет.
[27:14.600 --> 27:16.600]  Что значит конструктор от другого стринга?
[27:16.600 --> 27:20.280]  В смысле, допустим, у меня не стринг, а какой-то метод,
[27:20.280 --> 27:22.720]  который в конструкторе выводит все ауты, я создался.
[27:22.720 --> 27:27.880]  Так, еще раз, тихо.
[27:27.960 --> 27:31.440]  Послушайте, вот если у меня конструктор этой строки,
[27:31.440 --> 27:34.520]  это вообще вопрос такой тоже, а-ля вопрос собеседований.
[27:34.520 --> 27:38.800]  У меня, допустим, тип таков, что он логирует свои конструкторы
[27:38.800 --> 27:39.800]  и деструкторы.
[27:39.800 --> 27:41.960]  В конструкторе он пишет «я создался», в деструкторе
[27:41.960 --> 27:43.520]  он пишет «я уничтожился».
[27:43.520 --> 27:46.240]  Сколько раз будет написано «я создался» в этом примере?
[27:46.240 --> 27:47.240]  Один.
[27:47.240 --> 27:48.240]  Один, да.
[27:48.240 --> 27:50.760]  Конструктор не будет сделан, в этом и прикол.
[27:50.760 --> 27:53.760]  Жаль вас.
[27:54.440 --> 27:56.440]  То есть, если мы окажемся на то, что…
[27:56.440 --> 27:59.680]  Вот, компилятор оптимизирует промежуточные вызовы объектов.
[27:59.680 --> 28:02.440]  Он считает, что ПРВЛ можно не создавать, если они
[28:02.440 --> 28:03.760]  ни к чему не привязываются.
[28:03.760 --> 28:05.120]  И сайд-эффекты не проверяют?
[28:05.120 --> 28:07.880]  И сайд-эффекты игнорируются, не будет сделано.
[28:07.880 --> 28:08.880]  А что еще?
[28:08.880 --> 28:09.880]  Кайф.
[28:09.880 --> 28:13.440]  Чтобы вот такой код работал и не создавал тебе промежуточный
[28:13.440 --> 28:14.440]  стринг.
[28:14.440 --> 28:16.840]  Вообще-то, он так-то много сайд-эффектов конструктор
[28:16.840 --> 28:17.840]  стринга делает.
[28:17.840 --> 28:18.840]  Он там…
[28:18.840 --> 28:22.320]  РВО, да, ну по сути, да.
[28:22.320 --> 28:25.760]  Мы считаем, что конструктор в копировании только копирует.
[28:25.760 --> 28:28.760]  Но вот только мы хотим, чтобы конструктор в копировании…
[28:28.760 --> 28:30.560]  Я слишком долго.
[28:30.560 --> 28:31.560]  Давайте дальше.
[28:31.560 --> 28:32.560]  Ну, типа, я все сказал.
[28:32.560 --> 28:34.320]  Ну, формально вот это так работает.
[28:34.320 --> 28:36.320]  А если вы…
[28:36.320 --> 28:37.320]  Чего?
[28:37.320 --> 28:38.320]  Подожди.
[28:38.320 --> 28:40.320]  Чего ты хотел спросить?
[28:40.320 --> 28:43.320]  Почему стринг, особенно стринг со скобочками, там
[28:43.320 --> 28:44.320]  что-то превращается?
[28:44.320 --> 28:45.320]  Что еще раз стринг?
[28:45.320 --> 28:47.320]  Правый, верхний, зеленый пример.
[28:47.320 --> 28:49.320]  Почему там…
[28:49.320 --> 28:53.320]  Потому что я инициализирую переменную посредством
[28:53.320 --> 28:54.320]  этого выражения.
[28:54.320 --> 28:56.320]  А, в смысле, само это выражение…
[28:56.320 --> 29:00.320]  Само это выражение используется для инициализации какой-то
[29:00.320 --> 29:01.320]  переменной.
[29:01.320 --> 29:02.320]  Это только так один move, так?
[29:02.320 --> 29:04.320]  Нету move, а тут один ровно конструктор.
[29:04.320 --> 29:05.320]  Даже так?
[29:05.320 --> 29:06.320]  Да.
[29:06.320 --> 29:10.320]  Если бы move, то это бы работал ровно так же, как бы не было.
[29:10.320 --> 29:11.320]  Правое выражение.
[29:11.320 --> 29:16.320]  Ну, я не знаю, как это в стандарте аккуратно написано.
[29:16.320 --> 29:21.320]  Здесь не делается… Не создается промежуточный стринг.
[29:21.320 --> 29:22.320]  Ну, я не знаю, как еще вам сказать.
[29:22.320 --> 29:24.320]  Создается ровно один стринг, вот этот.
[29:24.320 --> 29:26.320]  И он и считается этим S.
[29:26.320 --> 29:30.320]  Ты сначала сказал, что вот эта штука работает, когда
[29:30.320 --> 29:31.320]  pair value.
[29:31.320 --> 29:35.320]  А сейчас ты говоришь, что это превращается в X value.
[29:35.320 --> 29:43.320]  Формально для компилятора temporary materialization называется
[29:43.320 --> 29:45.320]  cast pair value X value.
[29:45.320 --> 29:48.320]  Во время этого каста происходит реальное создание объекта.
[29:48.320 --> 29:52.320]  В то же время, если мы… Это происходит, например,
[29:52.320 --> 29:56.320]  когда мы инициализируем переменную посредством этого
[29:56.320 --> 29:57.320]  выражения.
[29:57.320 --> 30:02.320]  В то же время… Ну, там как-то это написано.
[30:02.320 --> 30:04.320]  Я не могу дословно процитировать стандарт, но там написано
[30:04.320 --> 30:08.320]  так, что создается ровно одна стринг в этом случае,
[30:08.320 --> 30:10.320]  и она и является это S.
[30:10.320 --> 30:11.320]  Не создается второй.
[30:11.320 --> 30:12.320]  В этом вся идея.
[30:12.320 --> 30:13.320]  Чего?
[30:13.320 --> 30:29.320]  Не, давай не надо, мы сейчас это очень долго застрянем
[30:29.320 --> 30:30.320]  на этом.
[30:30.320 --> 30:38.320]  Возможно… Слушайте, возможно, я… Можете, пожалуйста…
[30:38.320 --> 30:41.320]  Возможно, я вас обманул в том плане, что это все-таки
[30:41.320 --> 30:45.320]  создается X value, несмотря на то, что… Ну, я не помню
[30:45.320 --> 30:47.320]  досконально, формально, вот как описано.
[30:47.320 --> 30:50.320]  Там очень запутанно описано это, потому что там написано
[30:50.320 --> 30:53.320]  много костылей в стандарте, как правильно, что, к чему,
[30:53.320 --> 30:56.320]  в какой момент, каким value считается, чтобы все работало
[30:56.320 --> 30:57.320]  как надо.
[30:57.320 --> 30:59.320]  Но работает это в конечном итоге так, что если у меня
[30:59.320 --> 31:01.320]  переменная с помощью этого инициализируется, то
[31:01.320 --> 31:04.320]  ровно один раз создается объект, а если у меня много
[31:04.320 --> 31:08.320]  раз делается pair value и ни к чему не присваивается,
[31:08.320 --> 31:11.320]  то в конце создается объект под него.
[31:11.320 --> 31:14.320]  Вот здесь создается объект, потому что это X value.
[31:14.320 --> 31:16.320]  Вот здесь создается объект, потому что вызывается
[31:16.320 --> 31:18.320]  оператор, это становится X value.
[31:18.320 --> 31:20.320]  Здесь создается только один объект.
[31:20.320 --> 31:22.320]  С оператором это X value.
[31:22.320 --> 31:26.320]  Да, вызов оператора у временного объекта делает его X value.
[31:26.320 --> 31:29.320]  И объект под него создается.
[31:29.320 --> 31:30.320]  Вот.
[31:30.320 --> 31:34.320]  В частности, еще, например, если вы говорите string…
[31:34.320 --> 31:35.320]  Вот смотрите такой пример.
[31:35.320 --> 31:46.320]  String s равно vector string от одного квадратной скобочки ноль.
[31:46.320 --> 31:49.320]  Сколько здесь вызывается конструкторов стринга?
[31:52.320 --> 31:56.320]  Нет, тут я говорю, я вот string нециализирую этим.
[32:00.320 --> 32:02.320]  Но он обязан создать объект vector?
[32:04.320 --> 32:07.320]  И оператор копирования.
[32:07.320 --> 32:10.320]  Во время вектора он создает, пока будет создавать вектор…
[32:10.320 --> 32:12.320]  String, наверное, один.
[32:12.320 --> 32:16.320]  Нет, пока он будет создавать вектор, он создает string.
[32:16.320 --> 32:19.320]  Значит, он создает string, когда будет создавать вектор,
[32:19.320 --> 32:23.320]  а дальше ему просят квадратные скобочки ноль.
[32:23.320 --> 32:27.320]  И по идее эти квадратные скобочки должны вернуть ему
[32:27.320 --> 32:30.320]  одиночный амперсант, то есть deal value.
[32:30.320 --> 32:33.320]  Ну вот, кстати, да, здесь ответ зависит от того,
[32:33.320 --> 32:36.320]  реализована ли R-value версия квадратных скобочек.
[32:38.320 --> 32:40.320]  Я думаю, что реализована.
[32:40.320 --> 32:41.320]  Чего?
[32:41.320 --> 32:43.320]  В любом случае, это будет уже X-value.
[32:43.320 --> 32:44.320]  Вот это выражение?
[32:44.320 --> 32:46.320]  Нет, потому что это перегруженный оператор.
[32:48.320 --> 32:50.320]  Если он возвращает ссылку…
[32:50.320 --> 32:52.320]  Если он возвращает L-value ссылку…
[32:52.320 --> 32:54.320]  Да, я вам неправильно сказал.
[32:54.320 --> 32:57.320]  Вот здесь результат этого оператора,
[32:57.320 --> 32:59.320]  он зависит от того, какой там тип возвращаемый.
[32:59.320 --> 33:02.320]  Если это L-value ссылка, то это будет L-value,
[33:02.320 --> 33:03.320]  и он скопирует его.
[33:03.320 --> 33:05.320]  Он же так natuurlijk не может возвращать
[33:05.320 --> 33:07.320]  одновременно L-value ссылку и R-value ссылку.
[33:07.320 --> 33:09.320]  Нет, у тебя мог бы быть две версии оператора.
[33:09.320 --> 33:11.320]  Один для L-value, другой для R-value.
[33:11.320 --> 33:12.360]  Возвращаем изначально типpants.
[33:12.360 --> 33:13.920]  Возвращаем его значение.
[33:14.320 --> 33:14.960]  Что?
[33:15.320 --> 33:17.320]  У тебя может быть два разных оператора квадратной скобочки,
[33:17.320 --> 33:19.320]  один для L-value векторов, другой для R-value векторов.
[33:19.320 --> 33:21.320]  Один будет возвращать L-value ссылку,
[33:21.320 --> 33:23.320]  и тогда это будет L-value выражение,
[33:23.320 --> 33:25.320]  другой будет возвращать R-value ссылку,
[33:25.320 --> 33:26.320]  и тогда будет R-value выражение.
[33:26.320 --> 33:27.320]  Наверное, так.
[33:27.320 --> 33:29.920]  Во втором случае это будет x-value, оно мувнется.
[33:29.920 --> 33:32.560]  А в первом случае, наверное, оно все-таки копернется.
[33:32.560 --> 33:34.880]  Но в случае вектора, я уверен, что будет правильно работать,
[33:34.880 --> 33:37.360]  потому что у вектора реализовано все, что надо.
[33:37.360 --> 33:39.360]  Правильно это будет?
[33:39.360 --> 33:41.920]  Ну да, должно мувнуться, я думаю.
[33:41.920 --> 33:46.280]  Я верю, что вектор реализован так, что там правильная версия.
[33:46.280 --> 33:50.160]  Вы сказали, что оно, в суть, это x-value, правда?
[33:50.160 --> 33:53.160]  Вот эта часть будет x-value, потому что к ней обратились
[33:53.160 --> 33:55.040]  квадратными скобочками, и временный вектор должен
[33:55.040 --> 33:56.040]  создаться по этому.
[33:56.080 --> 34:03.360]  А вот это будет, наверное, там ошибся, что это всегда
[34:03.360 --> 34:05.400]  x-value, это зависит от того, что возвращают квадратные
[34:05.400 --> 34:06.400]  скобочки.
[34:06.400 --> 34:08.960]  Квадратные скобочки могут вернуть l-value ссылку, и тогда
[34:08.960 --> 34:10.560]  это, наверное, будет l-value все-таки.
[34:10.560 --> 34:12.480]  Значит, это что угодно, как и pair value.
[34:12.480 --> 34:13.920]  Но это не pair value точно.
[34:13.920 --> 34:16.440]  Нет, если квадрат с копчика возвращает вам копию, то
[34:16.440 --> 34:18.240]  это будет pair value по обычным правилам.
[34:18.240 --> 34:21.840]  Но квадратный скобочек возвращает вам ссылку, это значит,
[34:21.840 --> 34:24.040]  будет либо l-value, либо x-value.
[34:24.040 --> 34:30.340]  тогда это мувница, вот если это будет x-value. Но если вы... если у вас был... я другой пример
[34:30.340 --> 34:35.760]  хотел показать... если у вас был вектор, если у вас был вектор, если у вас был какой-то тип и в нем
[34:35.760 --> 34:43.460]  было поле строка, вот что будет здесь? Вот здесь будет move. Ой, не так. Если у вас был, значит,
[34:43.460 --> 34:49.760]  какой-то объект и в нем поле... вот вы создали временные объекты, в нем было поле строка. Вот
[34:49.760 --> 34:55.240]  это будет move по вот этому правилу, потому что обращение к полю временного объекта, если это
[34:55.240 --> 35:01.160]  сам объект, то это x-value по вот этому пункту, и тогда это будет мувница, несмотря на то, что казалось бы
[35:01.160 --> 35:10.120]  там l-value. Но нет, это x-value по этому правилу. Вот. Я понимаю, что я все мог запутать, но да ладно.
[35:10.120 --> 35:22.360]  Так, давайте. Копии лижен обязательно происходит, начиная с 17, если вы pair-value,
[35:22.360 --> 35:27.280]  из него создаете pair-value, из него и так далее создаете pair-value, до тех пор, пока вы либо не
[35:27.280 --> 35:31.960]  создадите x-value наконец-то, либо вы не пронициализируете какую-то переменную этим,
[35:31.960 --> 35:39.000]  либо пока выражение не закончится. Так, еще раз, последний раз говорю, больше не возвращаюсь
[35:39.000 --> 35:43.160]  к этому. Если у вас есть выражение, в котором несколько раз из одного pair-value создается
[35:43.160 --> 35:48.920]  другое, то все эти вызовы pair-value компилятор обязан просто проигнорировать и сделать только
[35:48.920 --> 35:54.760]  самый последний, который наконец является собой присваиванием переменной, на котором вычтение
[35:54.760 --> 36:18.600]  выражения заканчивается. Или это x-value. Какой вопрос? Да. Где мы возвращаем копию? Что?
[36:19.200 --> 36:40.720]  Что? Нет, ты такого не говорил. Я сказал x-value это pair-value reference. Что? Где? Вот это. Я уже, блин,
[36:40.720 --> 36:46.880]  говорил это. Я уже говорил, что здесь будет. Здесь будет temporary immortalization один раз,
[36:46.880 --> 36:52.520]  потом вернется pair-value и произойдет copy-elision. Первый раз произойдет temporary
[36:52.520 --> 36:57.360]  immortalization, второй раз снова создается pair-value и оно не будет move-аться,
[36:57.360 --> 37:04.440]  потому что это pair-value произойдет copy-elision. Создаться две строки. Первый раз вот это,
[37:04.440 --> 37:13.120]  второй раз та, которая получилась в результате и произойдет copy-elision. Да, вот этого оператора.
[37:13.120 --> 37:25.160]  Да. Второй раз происходит copy-elision. Вот в словосочетании temporary materialization давайте
[37:25.160 --> 37:32.080]  сделаем, как в восьмом классе школы учили, анализ этого словосочетания. Это, значит,
[37:32.080 --> 37:47.640]  словосочетание со связью какой? Ну, тем не менее. У нас бывает словосочетание согласование,
[37:47.640 --> 37:53.480]  управление и примыкание. Вот это какая связь? Вот, значит, неправильно считать,
[37:53.480 --> 37:57.600]  что это словосочетание вот так вот разбирается, что это прилагательное, это существительное. Нет,
[37:57.600 --> 38:03.160]  значит, в этом словосочетании главное слово материализация, а это, значит, вот так вот это
[38:03.160 --> 38:11.040]  разбирается. Значит, здесь оба этих, оба этих слова существительные и связь здесь управлены. Ну,
[38:11.040 --> 38:18.960]  это сложно говорить про связь, потому что это английский. Temporary это существительное,
[38:18.960 --> 38:29.720]  материализация временного. Temporary это некоторая вещь, которая материализуется. Вот если вы
[38:29.720 --> 38:34.240]  правильно понимаете перевод этого словосочетания, то вы правильно понимаете, что это такое. Неправильно
[38:34.240 --> 38:38.560]  считать, что это временная материализация. Нет, это материализация временного объекта,
[38:38.560 --> 38:48.320]  который мог бы и не создаться, но создался, потому что стал x-value. Вот. Ну,
[38:48.800 --> 39:06.040]  вот не знаю. Так вот. Так. Что такое RVO? Что такое RVO теперь? Time for teletubbies. Ладно,
[39:06.040 --> 39:13.720]  вы слишком молодые, вы не знаете этих приколов. Что такое RVO? Ну, RVO это copy-leash,
[39:13.720 --> 39:18.880]  который при возврате из функции происходит. Так было до C++17. Начиная с C++17 чуть-чуть
[39:18.880 --> 39:26.720]  определение изменилось, но суть осталась той же. А когда вы из функции возвращаете pair value,
[39:26.720 --> 39:34.720]  ну, то есть у вас есть функция, которая возвращает какой-то t, и тут значит t значит x,
[39:34.720 --> 39:41.240]  что-то происходит, return x. Ой, нет, виноват. Вот для начала рассмотрим просто такой пример.
[39:41.360 --> 39:50.920]  Return t. Что происходит? Вот здесь вот создается всего 1t, а не 2. Потому что происходит опять
[39:50.920 --> 39:57.720]  copy-elision. Вот такая copy-elision, которая при возврате из функции происходит, называется return
[39:57.720 --> 40:09.120]  value optimization. Так. Ну, это тривиальный пример. Не тривиальный пример. Это когда у вас есть вот
[40:09.120 --> 40:18.200]  такая вещь t, x, и вы делаете return x. Это уже формально не считается copy-elision, начиная с C++17,
[40:18.200 --> 40:28.960]  если я ничего не путаю. Но это все технические детали стандарта, а суть в том, что компилятор опять
[40:28.960 --> 40:40.160]  скорее всего не сделает промежуточного x, а сразу создаст вот этот t на месте возврата. Да,
[40:40.160 --> 40:45.280]  скорее всего, потому что вот это уже не гарантирующаяся copy-elision. Это уже не гарантируется,
[40:45.280 --> 40:51.200]  но так делают почти все компиляторы. Ну, можно извратиться и попытаться написать такой код,
[40:51.200 --> 40:57.200]  в котором компилятор не догадается. Ну, например, если вы из разных путей из функции возвращаете
[40:57.200 --> 41:02.160]  разные объекты, то компилятор может не догадаться, это соптимизировать, и тогда у вас будет, значит,
[41:02.160 --> 41:08.240]  лишний объект создан. Но в таком стандартном сценарии, когда вы вначале объявили ответ и его же и вернули,
[41:08.240 --> 41:13.440]  чтобы не случилось, когда у вас нет разных return, разных вещей, компилятор сразу вот это создаст на
[41:13.440 --> 41:20.960]  месте возврата функции. Вот. Правда там, ну вот, например, если у вас функция кидает исключения в
[41:20.960 --> 41:24.960]  некоторых ситуациях и выходит нештатно, то тоже у компилятора может не получиться, потому что откуда
[41:24.960 --> 41:29.440]  он знает, ему, значит, что делать. Ну, в общем, можно придумать сценарий, в котором компилятор,
[41:29.440 --> 41:36.880]  наверное, это не соптимизирует. Но вообще он должен постараться, скажем так. Вот это называется
[41:36.880 --> 41:50.480]  nrvo named return value optimization. Вот это named rvo. А даже если компилятор не сумеет соптимизировать это,
[41:50.480 --> 42:00.160]  он обязан сделать move. То есть, если вы из функции возвращаете переменную, я не уверен насчет других
[42:00.160 --> 42:05.120]  lvalue, но если возвращаете просто переменную из функции, которая временная, ну, которая локальная
[42:05.120 --> 42:10.080]  переменная этой же функции, компилятор должен постараться это соптимизировать и не создавать
[42:10.080 --> 42:14.480]  вообще никакого лишнего объекта. Но если у него не получилось соптимизировать так, чтобы copy
[42:14.480 --> 42:24.480]  legion случился, то, по крайней мере, он обязан сделать move вместо копирования. Ну, move, в смысле move
[42:24.480 --> 42:29.440]  оператор, move конструктор, а не copy конструктор вызвать. Ну, а что там у вас реализовано, это к вам
[42:29.440 --> 42:35.320]  вопрос. В связи с этим является ошибкой, свидетельствующая непонимание. Вот это такой тоже
[42:35.320 --> 42:43.920]  хороший вопрос. Написать вот так. Некоторые так пишут и продалбываются. Написав так, вы делаете
[42:43.920 --> 42:51.120]  строго хуже, потому что компилятор и так бы попытался move-нуть, если у него не получится
[42:51.120 --> 42:57.720]  рво, но так вы не дали ему сделать рво уж точно, он не вынужден будет move-ать. Ну, потому что это
[42:57.720 --> 43:08.240]  xvalue. xvalue он должен move-нуть. Вот. То есть писать move вот в такой ситуации неправильно. А,
[43:08.240 --> 43:15.960]  если мы по какой-то странной причине хотим, чтобы он обязательно move-нул. С другой стороны,
[43:15.960 --> 43:23.160]  если у вас там есть какой-нибудь оператор, скажем, big integer, оператор плюс от, и вы такой
[43:23.160 --> 43:27.280]  оптимизированный оператор написали, который первый оператор по R-value ссылки принял,
[43:27.280 --> 43:37.920]  или который его вообще по значению принял, то вот тогда вам move имеет смысл написать,
[43:37.920 --> 43:44.920]  потому что это же не локальные перемены, но он не мог сразу ее создать на месте,
[43:44.920 --> 43:55.920]  где у него будет возврат. Да. Вот здесь вам можно писать move, да. Ну, когда вы big integer,
[43:55.920 --> 44:01.320]  оператор плюс. Кстати, сейчас надо подумать, вот если вы так, если вы по значению приняли big
[44:01.320 --> 44:06.920]  integer, то сможет он его move-нуть или нет? В смысле, сможет он его оптимизить на выход?
[44:06.920 --> 44:14.520]  Наверное, все-таки сможет. Наверное, да, вот в такой ситуации я бы move не писал,
[44:14.520 --> 44:20.720]  но вот в такой точно нужно move написать. Если я принял его как R-value, то надо move писать.
[44:20.720 --> 44:29.080]  Нет, если вы напишете return a и не сделаете move, то будет копирование. А если вы приняли
[44:29.080 --> 44:55.200]  pair-value с ссылки и хотите вернуть по значению, то вам надо move писать. Слушай, ну с lang-tidy мы уже
[44:55.200 --> 45:15.680]  выяснили, что иногда советуют странные вещи. Так, так, так, так. Все ли я сказал про RVO?
[45:25.200 --> 45:37.640]  Вроде все я сказал про RVO, что хотел. Обычное RVO, когда у вас было не X. Было обычное RVO до этого
[45:37.640 --> 45:51.320]  примера. Все, кажется, я все сказал по поводу этого. Так, нам остался последний пункт,
[45:51.320 --> 45:58.320]  связанный с move-семантикой, и он будет называться применение move-семантики для реализации pushback.
[45:58.320 --> 46:05.880]  Сейчас мы вернемся снова к вектору нашему старому доброму и перепишем pushback уже на уровне даже
[46:05.880 --> 46:14.120]  не средний и не старших классов, а почти на идеальном уровне. Вот сейчас мы, кажется,
[46:14.120 --> 46:24.520]  впредпоследний раз вернемся к pushback и напишем его почти как следует. Последний раз, ну типа да.
[46:24.520 --> 46:37.840]  Так, слушайте, мне тут надо ответить на телефончик.
[46:37.840 --> 47:01.000]  Да, здрасте. Слушайте, у меня для вас грустные новости, уже не актуально оказалось для нас.
[47:01.000 --> 47:12.600]  Да, да, да. Все, хорошо, до свидания. Такс.
[47:31.000 --> 47:56.440]  Пункт десять точка восемь, а move-семантика в векторе. Вектор pushback давайте прям конкретно скажу.
[47:56.440 --> 48:10.600]  Плохо видно? Давайте свет выключим. Нет, он включен там. Да, ну чуть-чуть получше стало.
[48:10.600 --> 48:23.920]  Получше стало? Давайте может желюзию задвинем, может чуть-чуть поможет. Стало лучше.
[48:26.440 --> 48:40.120]  Ну стало получше по-моему. Все прекрасно. Так, господа, теперь с нашими новыми знаниями давайте
[48:40.120 --> 48:51.400]  напишем pushback правильно. Я даже не поленюсь вот это все скопипастить. Да, напишем pushback
[48:51.400 --> 49:03.960]  почти правильно, значит. Во-первых, я скопипачу часть про локацию. Я напоминаю, что да, если capacity,
[49:03.960 --> 49:19.640]  давайте так, если capacity сейчас равно size, то мне надо сделать все вот это. Так? Вплоть
[49:19.640 --> 49:31.080]  докуда? Вплоть до? Вот это кажется нужно убрать, а сделать здесь вот так. Так? Если capacity равно
[49:31.080 --> 49:40.360]  size, то вот так. Писать-то писали, только господи, как же мне не нравится наше обозначение, это
[49:40.360 --> 49:49.400]  отвратительно, потому что у нас нет полей capacity и size. Мы выбрали другой путь. Слушайте, давайте
[49:49.400 --> 49:54.080]  я все-таки перейду на привычное мне обозначение. У меня будет два числа, ну потому что и так, и так
[49:54.080 --> 50:00.920]  умереть хочется. Давайте я просто скажу, что у меня все-таки есть массив и, значит, два числа с
[50:00.920 --> 50:17.520]  size и size cap, потому что иначе и так будет куча багов. Не-не-не-не, это будет неэффективно. Ты что?
[50:17.520 --> 50:25.760]  Зачем мы не платим за то, что мы не используем? Мы не хотим делать заранее реаллокацию, если она нам
[50:25.760 --> 50:36.960]  не нужна, прям сейчас. Нет. Так следующего раза может не быть. Ну вот если будет, тогда и сделаем.
[50:36.960 --> 50:50.160]  Господа, много вопросов нет, мы сейчас опять не успеем. Так, давайте заново смотреть. Мы выделяем
[50:50.160 --> 50:56.160]  новый массив. Как мы его выделяем? Ну теперь мы уже знаем, что надо через trades обращаться к
[50:56.160 --> 51:04.920]  локатору. У нас тут написано, что такое trades? Да, у нас написано, значит, alloc trades. Значит alloc
[51:04.920 --> 51:21.920]  trades allocate. От чего? Первым аргументом надо передать локатор. А как его передать? Ну надо
[51:21.920 --> 51:28.520]  передать себя, видимо. Я напоминаю, мы это и есть allocator на самом деле. Мы приватный наследник
[51:28.520 --> 51:40.600]  allocator. К сожалению, это не сработает, потому что, потому что, потому что, потому что мы приватный
[51:40.600 --> 51:46.600]  наследник с точки зрения allocator, мы не allocator. Давайте я сделаю, как это по C++20 все-таки делается.
[51:46.600 --> 51:56.600]  А именно, там есть аргумент. Кто помнит, как он называется? No unique address, да. Я вам про него
[51:56.600 --> 52:06.080]  говорил. Ну, я просто allocator объявляю своим полем, у которого может не быть уникального адреса.
[52:06.080 --> 52:19.560]  Ну, могли, но это, но это долго. Ну, в смысле, это некрасиво. В смысле, непонятно. Так,
[52:19.560 --> 52:26.680]  во-первых, давайте тишину создадим. Что непонятно? Это было уже, я про это рассказывал. Эта штука
[52:26.680 --> 52:33.080]  начинается C++20, которая позволяет вам пустое поле, чтобы не занимало ни одного байта. Да,
[52:33.080 --> 52:46.160]  более того, нужно. И те, кто так не сделает, будут правильно переделывать. Ну, если вы сделаете
[52:46.160 --> 52:50.120]  наследником, может быть, кстати, и засчитаем. А вам больше нравится приватный наследователь
[52:50.600 --> 53:06.400]  чем вот это, да? Я понял. Да, проходили, да. Прикинь. В каком пункте? В пункте 9.3, кажется. Когда
[53:06.400 --> 53:18.160]  я рассказывал про EBO в Allocator. Господа, мы сегодня должны закончить вовремя, а поэтому я хочу не
[53:18.160 --> 53:30.240]  отвлекаться на вопросы по предыдущим темам. Мы сделали Allocate. Дальше, мы сделали Constract опять
[53:30.240 --> 53:38.840]  через Allocator Trades. Мы говорим Alloc Trades, Constract, new R pluses. Ну, значит, Alloc первым
[53:38.840 --> 53:54.400]  аргументом опять new R pluses begin it. Не begin it, а что? R plus, R it. Теперь, если мы сделали Catch,
[53:54.400 --> 54:04.520]  то мы говорим Alloc Trades destroy new R pluses g. Только первым аргументом опять передаем Allocator.
[54:04.520 --> 54:13.280]  Дальше мы здесь опять говорим Alloc Trades deallocate и первым аргументом опять передаем Allocator.
[54:13.280 --> 54:19.640]  Здесь мы говорим опять Alloc Trades.destroy и первым аргументом передаем Allocator.
[54:19.640 --> 54:37.880]  Да, new cap отличный вопрос. А что такое? Да, new cap нам нужно сделать size t, давайте скажем new cap,
[54:37.880 --> 54:49.600]  равно 2 умножить на cap. Ну, я скажу это минимум, точнее максимум из 2 умножить на cap и единицы.
[54:49.600 --> 54:55.760]  Ну, потому что если у нас исходная к пейсте была ноль, то мы должны 1 сделать, правильно?
[54:55.760 --> 55:08.960]  Ну, я сейчас не пытаюсь соблюдать code style в идеальном варианте, поэтому,
[55:08.960 --> 55:22.880]  но если хотите могу написать вот так. Так поможет. Так, и последнее Alloc Trades deallocate.
[55:22.880 --> 55:38.560]  Значит Alloc Trades deallocate что? Первым аргументом опять Alloc, дальше R и какой параметр был? Cap.
[55:38.560 --> 55:49.480]  Вот. И в конце мы должны сделать cap равно new cap. Так? Правильно я ничего не забыл.
[55:49.480 --> 56:07.400]  Я переименовал поля, у меня есть, ну да, delete равно R, delete не равно R плюс CZ, плюс-плюс delete,
[56:07.400 --> 56:15.040]  вот так, да? Так, ну на самом деле я пока ничего нового не написал, это я просто переписал то,
[56:15.040 --> 56:22.760]  что мы и так знали, только через Allocator Trades. Вот, и теперь здесь я должен сделать снова Allocator Trades,
[56:22.760 --> 56:35.680]  Alloc Trades 2.2.construct. От чего? От R плюс CZ, а кстати, что такое R? Нам нужно еще сказать R
[56:35.680 --> 56:53.400]  равно new R, правильно? Правильно? Вот, R плюс CZ, value, ну и Allocator первым аргументом, и плюс-плюс CZ, так?
[56:53.400 --> 57:08.480]  Совершенно верно, да. А если у нас исключение вылетит где-нибудь здесь, ну нам надо на самом деле
[57:08.480 --> 57:21.960]  вот это перенести вверх, вот это нам нужно перенести сюда. Что? Значит, нам в pushback нужно,
[57:21.960 --> 57:26.840]  это проблема, почему мы pushback через reserve не можем выразить не тривиально, потому что нам
[57:26.840 --> 57:34.160]  нужно сделать констракт вот этого всего, потом констракт последнего, и только если все это произошло
[57:34.160 --> 57:49.760]  удачно, начать все освобождать, и только в самом конце сделать плюс-плюс CZ. Ну да, если мы что-то
[57:49.760 --> 57:55.440]  поймали, то мы делаем throw, вот это уже исключение не кидает, и мы просто вот здесь вот заходим,
[57:55.440 --> 58:02.840]  это если cap было равно CZ, ну а иначе мы просто должны сделать вот это, ну здесь, кстати, нам
[58:02.840 --> 58:10.560]  можно и не делать try, потому что если это кинет исключение, то мы просто сразу же вылетим, а вот
[58:10.560 --> 58:26.120]  это можно перенести за if, кажется, правда? Да, cap равно new cap нельзя, это правда. А, и саром согласен,
[58:26.120 --> 58:40.360]  да. Согласен. Какую ишку? Зачем? Этот же мы никогда не будем делать
[58:40.360 --> 58:59.880]  лоцировать, делать destroy. Какой? Что new R? Где? А, new R плюс CZ, да. Так, вот это то, как бы выглядел
[58:59.880 --> 59:11.840]  наш pushback до того, как мы придумали move семантику. Что? Что почему? Потому что мне
[59:11.840 --> 59:18.360]  нужно вот этот констракт последнего элемента сделать внутри try, и если он не удался, то мне
[59:18.360 --> 59:25.480]  нужно диалоцировать все то предыдущее. Reserve, допустим, я все реалоцировал, все переложил,
[59:25.480 --> 59:31.640]  и последний элемент кладу, и он exception кидает. Тогда мне нужно антиreserve делать, что ли? У меня
[59:31.640 --> 59:40.120]  нет такого. Я должен вот это все внутри try запихать, чтобы, если что, диалоцировать все. Я про insert
[59:40.120 --> 01:00:01.320]  вообще ничего не говорил. Ну можно, да. Так, ну вот. Хорошо. Теперь move семантика появилась. Что
[01:00:01.320 --> 01:00:07.680]  позволяет нам move семантика сделать? Мы, напоминаю, у нас была одна из проблем в pushback, и мы не хотели
[01:00:07.680 --> 01:00:15.040]  копировать при перекладывании, а вот здесь мы именно этим и занимаемся. Правда? Мы хотим здесь
[01:00:15.040 --> 01:00:23.240]  написать не RIT, а std move от RIT. Правильно? И здесь мы хотим, а вот здесь мы хотим написать std move
[01:00:23.240 --> 01:00:30.960]  от value или нет? Мы не можем, потому что, ну мы можем, но оно const, поэтому все равно это не будет
[01:00:30.960 --> 01:00:44.800]  работать как move. Вот здесь мы не должны писать move. Понятно, почему? Это правильный вопрос. Нам бы неплохо
[01:00:44.800 --> 01:00:56.720]  в pushback уметь принимать R-value тоже. Да, если бы мы приняли R-value, то мы могли бы сделать std move.
[01:00:56.720 --> 01:01:10.080]  Да. Мы могли бы написать универсальную ссылку здесь и делать forward в месте, где мы value
[01:01:10.080 --> 01:01:18.320]  передаем, в allocator. Да и в самом allocator нам надо forward делать. Вот здесь вот, теперь у нас тут
[01:01:18.320 --> 01:01:32.920]  allocator написано, я напомню. Здесь нам надо делать не так, а вот так. Я напоминаю. Правильно? Кстати,
[01:01:32.920 --> 01:01:44.720]  вот здесь можно же избавиться от reinterpret cast, потому что мы теперь знаем, что у нас есть вот
[01:01:44.720 --> 01:01:59.920]  такая функция. Нам больше не нужен reinterpret cast. Игейно. Да. И здесь мы делаем просто оператор delete,
[01:01:59.920 --> 01:02:07.040]  собственно так это и надо писать. Оператор delete, причем без квадратных скобочек, кстати,
[01:02:07.040 --> 01:02:25.120]  заметьте. Да. И что это доказывает? Я, видишь, делаю без квадратных и говорю, заметьте. Я тебе
[01:02:25.120 --> 01:02:28.760]  больше скажу, если ты в векторе проверишь, какой он вызывает оператор, то он вызывает new без
[01:02:28.760 --> 01:02:36.320]  квадратных скобочек. Проверь. По-моему, он вызывает оператор new без квадратных скобочек.
[01:02:36.320 --> 01:02:47.600]  Зачем? Он просто byte выделяет вот в таком количестве. Он выделил нужное количество byte,
[01:02:47.600 --> 01:02:52.800]  освободил нужное количество. Да, запоминает уже не он, да. Ему не нужно делать new с квадратными
[01:02:52.800 --> 01:03:11.760]  скобочками. Зачем? Это переусложнение. Так вот. Чего? Я не помню. Escape нажал, наверное. Так.
[01:03:11.760 --> 01:03:23.200]  Так вот. Здесь мы могли бы написать SD forward от value, но вот сейчас важный момент. Мы не хотим
[01:03:23.200 --> 01:03:27.280]  принимать в pushback универсальную ссылку, потому что это будет означать, что мы должны pushback
[01:03:27.280 --> 01:03:32.120]  сделать тоже шаблонным. А это значит, что он будет принимать не только T, а еще все подряд другие
[01:03:32.120 --> 01:03:39.600]  типы. И нам либо нужно писать шаблонную магию, чтобы он принимал только T, либо он будет уметь
[01:03:39.600 --> 01:03:45.560]  делать конверсии либо статик ассерт, либо он будет принимать и другие типы, делать какие-то
[01:03:45.560 --> 01:03:49.160]  неявные конверсии и будут странные ошибки компиляции. Короче, стандартный pushback так
[01:03:49.160 --> 01:03:54.200]  не написан. Стандартный pushback на самом деле просто в двух версиях написан. Один принимает
[01:03:54.200 --> 01:04:05.480]  const T&T, другой принимает T2&T. Я говорю, можно, но мы не хотим, потому что это переусложнение.
[01:04:05.480 --> 01:04:09.680]  Это будут какие-то непонятные ошибки для пользователя. Стандартная библиотека
[01:04:09.680 --> 01:04:15.320]  делая... стандартная библиотека разобатывается по принципу добавления функций, а не переписывания
[01:04:15.320 --> 01:04:22.160]  существующих. Да, так будет copy-pass, но это стандартная библиотека. В смысле нам надо выразить
[01:04:22.160 --> 01:04:27.280]  просто эти два pushbacks через одну общую функцию, какой-нибудь приватный pushback, который
[01:04:27.280 --> 01:04:31.800]  принимает уже универсальную ссылку, но переходить в него из этих двух pushbacks только с нужным типом.
[01:04:31.800 --> 01:04:41.360]  Вот. Ну, в принципе, можно так и сделать. Давайте я так и сделаю. Значит, template,
[01:04:41.360 --> 01:04:51.400]  type name, u. Давайте я скажу pushback private, который принимает u, двойной амперсант.
[01:04:51.400 --> 01:05:05.160]  Чего? Потому что мы его приняли по констей амперсанду, как мы его move-ить будем.
[01:05:05.160 --> 01:05:14.600]  Теперь мы будем делать forward от value, а не move. Значит, теперь у нас есть так,
[01:05:14.600 --> 01:05:18.640]  у меня тут отступы неправильно стоят что ли. Теперь мы сделаем void pushback
[01:05:18.640 --> 01:05:35.360]  от const t&value. Вот pushback. И здесь делаем, у нас есть pushback дома. И здесь делаем std forward,
[01:05:35.360 --> 01:05:42.840]  но здесь вообще нам не надо никого forward. Тут мы знаем и так, кого мы передаем. А здесь делаем
[01:05:42.840 --> 01:05:51.360]  pushback от std move от value. То есть здесь мы сделаем pushback от t&value. И сделаем pushback private
[01:05:51.360 --> 01:06:02.000]  от std move от value. Я уже объяснял, прости, пожалуйста, я не буду повторять, потому что иначе нам придется задержаться.
[01:06:02.000 --> 01:06:25.200]  Здесь мы делаем теперь forward. Все нормально в теории. Ну, очевидно, нет, нам еще много
[01:06:25.200 --> 01:06:39.600]  исправить предстоит. Но, по крайней мере, вот с точки зрения move-ов нормально? Вот. Где? А, вот здесь тоже forward, это правда.
[01:06:39.600 --> 01:06:54.920]  Все, мы победили. Мы победили лишнее копирование в pushback, в векторе. И при докладывании вектор самого
[01:06:54.920 --> 01:07:09.160]  вот этого объекта и при реалокации победили лишнее копирование. А, прежде чем вас расстроить, ну,
[01:07:09.160 --> 01:07:20.800]  спойлер, проблема. Тихо, не спойлери. Ну, я только что хотел заспойлерить, да, ну ладно. Подожди,
[01:07:21.000 --> 01:07:28.640]  подожди, подожди, пока забудьте про то, что он сказал. Давайте пока по-другому, о другом подумаем.
[01:07:28.640 --> 01:07:39.800]  Спокойно, не нервничайте, не надо нервничать заранее, еще ничего плохого не случилось.
[01:07:39.800 --> 01:07:52.040]  Тихо, тихо, спокойно, дышите ровно. У меня к вам вопрос. Значит, сейчас небольшое лирическое отступление.
[01:07:52.040 --> 01:08:02.040]  Как вам такая идея? Почему бы мне не написать pushback следующим образом? Я говорю void pushback
[01:08:02.040 --> 01:08:15.360]  от t в value принятого по значению и move там уже внутри. Не делать forward, а делать move вот здесь.
[01:08:15.360 --> 01:08:27.960]  Смотрите, если я в этот pushback передам l value, он скопируется, а потом я его move. Если я в
[01:08:27.960 --> 01:08:35.280]  этот pushback передам r value, он сразу же move-нется и потом я его снова move-ну. То есть я избежал
[01:08:35.280 --> 01:08:44.200]  снова лишних копирований и избежал еще и копипасты. Еще раз, я в pushback буду принимать t по значению
[01:08:44.200 --> 01:08:53.280]  вообще. Потому что таким образом одним махом я решу проблему и для r value и для l value и не буду
[01:08:53.280 --> 01:09:01.680]  нигде лишний раз копировать. И мне всего одной версии pushback достаточно будет. Подождите,
[01:09:01.680 --> 01:09:14.160]  мы не обсуждаем exception пока. Вот с точки зрения чисто move и копирований. Да, ну то есть я избегу
[01:09:14.160 --> 01:09:21.520]  лишних копирований, я буду просто move-ать лишний раз возможно. А до этого я не move-ал. Ну это
[01:09:21.520 --> 01:09:30.800]  аргумент. Я делаю на один move больше, но я все еще избавляюсь от копирований. Нет, функция move-то
[01:09:30.800 --> 01:09:43.440]  ничего не делает, но move-операция перекладывает поля. Я сейчас вам скажу некоторую мысль огорашивающую
[01:09:43.440 --> 01:09:49.080]  человека, к ней неподготовленного. Если вы будете когда-нибудь читать современный код на C++ каких
[01:09:49.080 --> 01:09:57.440]  нибудь крутых топовых разработчиков гугла или яндекса, вы можете обнаружить внезапно, что почему-то
[01:09:57.440 --> 01:10:02.880]  они по значению функции все время передают, они по ссылке. Потому что на самом деле то, что вот я
[01:10:02.880 --> 01:10:09.560]  сейчас предложил, это одна из идиом современного C++, которая позволяет не делать копипасту для r
[01:10:09.560 --> 01:10:15.760]  value ссылок и для l value ссылок. Если у вас все типы корректно поддержат move семантику, то вам просто
[01:10:15.760 --> 01:10:20.080]  выгоднее по значению принимать и не париться с копипастой. Вы можете просто принимать свои
[01:10:20.080 --> 01:10:27.080]  функции по значению и move-ать. Тогда если пользователь хочет вам передать l value, вы его один раз
[01:10:27.080 --> 01:10:31.200]  скопируете во время передачи, но потом move-ните. А если пользователь хочет передать вам r value, вы
[01:10:31.200 --> 01:10:37.000]  просто два раза move-ните. И вам не нужно копипастой делать для разных видов ссылок. Понимаете, как
[01:10:37.000 --> 01:10:43.240]  прикольно? То есть вы можете иногда действительно увидеть, и это тоже кстати такой вопрос на глубокое
[01:10:43.240 --> 01:10:53.080]  понимание, которое тоже задают иногда. Скорее это бывает так. Вы приходите работать и видите,
[01:10:53.080 --> 01:10:58.840]  что в коде все по значению принимается. Вы приходите к теми людьми и говорите, ты что дурак?
[01:10:58.840 --> 01:11:03.640]  Зачем ты по значению принимаешь? Ты же лишний раз копируешь. А потом вам объясняют, что вообще-то это
[01:11:03.640 --> 01:11:15.520]  это вы, дурак. Это современный C++, вы ничего не понимаете. То есть на самом деле в современном
[01:11:15.520 --> 01:11:21.840]  C++ принято принимать по значению. Если все типы корректно поддержат ему в семантику, то вам не
[01:11:21.840 --> 01:11:32.160]  нужно будет делать перегрузку для двух видов ссылок. Теперь следующий вопрос. Но почему же в
[01:11:32.160 --> 01:11:38.240]  Векторе-то мы так не сделали? В Векторе все-таки мы делаем две перегрузки. Одну для C++, другую для T2.
[01:11:38.240 --> 01:11:46.440]  Ну да, потому что там лишний move. В принципе это уже достаточно аргумент. Но мы тоже не можем так
[01:11:46.440 --> 01:11:51.120]  делать, потому что у нас нет гарантии, что T поддерживает move семантику. Это работает только,
[01:11:51.120 --> 01:11:55.440]  если все типы гарантированно поддержат move семантику. Но в Векторе далеко не обязательно
[01:11:55.440 --> 01:11:59.200]  лежит тип, который move семантику поддерживает. Если у вас тип не поддерживает move семантику,
[01:11:59.200 --> 01:12:03.440]  то лишний move для вас, то будет лишнее копирование. Вы не можете себе этого позволить. Понятно? То есть
[01:12:03.440 --> 01:12:08.120]  СТЛ-овский Вектор все равно делает перегрузку для двух видов ссылок. Но если вы пишете код на
[01:12:08.120 --> 01:12:12.520]  современных плюсах, а хотите избежать копипасты, то вот вы можете воспользоваться идиомой и просто
[01:12:12.520 --> 01:12:16.960]  передавать по значению. И не будет копипасты для разных видов ссылок. И не надо париться с
[01:12:16.960 --> 01:12:28.080]  универсальными ссылками. То есть да, мы вот эту вот все вот 0,75 года изучаем, чтобы прийти к
[01:12:28.080 --> 01:12:32.080]  выводу, что вообще-то принимать по значению норм тему можно было так и делать. В принципе так
[01:12:32.080 --> 01:12:40.240]  и так тоже работает. Главное move не забывать писать. А теперь, уважаемые господа, главный вопрос
[01:12:40.240 --> 01:12:49.040]  сегодняшнего вечера. Что мы испортили, сделав это? Конечно же мы потеряли exception safety. Потому
[01:12:49.040 --> 01:12:57.520]  что смотрите, когда мы раньше копировали, ну вот у меня есть резерв. Да, он перекладывает объекты.
[01:12:57.520 --> 01:13:09.840]  Да, я все еще не понял. Вот смотрите, я делаю pushback и начинаю move отсюда-сюда. И вот на третьем
[01:13:09.840 --> 01:13:22.880]  муве произошел exception. Я уже положил сюда два полноценных новых объекта и move их отсюда.
[01:13:22.880 --> 01:13:27.920]  То есть здесь лежат пустые объекты. И третий, третий был конструктор, не было у меня исключений.
[01:13:27.920 --> 01:13:34.000]  Теперь у меня неприятная ситуация, с которой я раньше еще не сталкивался. У меня в этом массиве
[01:13:34.000 --> 01:13:38.480]  половина объектов пустые, а половина еще не переложенные. В этом половина созданных объектов,
[01:13:38.480 --> 01:13:43.360]  половина нациализированной памяти. И я на третьем объекте споткнулся по штуке у исключения.
[01:13:43.360 --> 01:13:49.520]  Я не могу начать перекладывать эти объекты обратно, потому что будет второй exception. Что же делать?
[01:13:49.520 --> 01:13:57.520]  Как мне соблюсти move семантику, соблюсти exception safety при поддержке move семантики при резерве векторе?
[01:13:57.520 --> 01:14:14.560]  Вы принято!
[01:14:14.560 --> 01:14:22.560]  Ну по ощущениям там любят потом любить делать.
[01:14:22.560 --> 01:14:31.600]  Как же нам победить проблему лишних копирований? Мы ведем 3 дополнительных и the value. Вы принято.
[01:14:31.600 --> 01:14:41.600]  Тем не менее нет. На сей раз комитет пошел иным путем.
[01:14:41.600 --> 01:14:49.600]  Мы просто будем вот как себя вести. Если move конструктор кидает исключения, мы не будем move,
[01:14:49.600 --> 01:14:56.640]  мы будем копировать по старому. А как мы это проверим? А мы будем проверять, он no accept или нет?
[01:14:56.640 --> 01:15:08.640]  Для этого у нас есть следующая специальная функция, которая называется move if no accept.
[01:15:08.640 --> 01:15:14.640]  Действие этой функции следующее.
[01:15:14.640 --> 01:15:25.680]  Если move конструктор для данного типа no accept, то она возвращает рвл в ссылку, а иначе лвл в ссылку.
[01:15:25.680 --> 01:15:31.680]  Вы никогда не пробовали играть в КВН?
[01:15:31.680 --> 01:15:39.680]  Нет.
[01:15:39.680 --> 01:15:46.720]  Давайте я вам напишу, что делает функция move if no accept.
[01:15:46.720 --> 01:15:52.720]  Что делает функция move if no accept?
[01:15:52.720 --> 01:15:58.720]  У нее возвращаемый тип какой?
[01:15:58.720 --> 01:16:04.720]  Я хочу вернуть рвл в ссылку, если move конструктор был no accept и лвл в ссылку иначе.
[01:16:04.720 --> 01:16:10.720]  Что я должен написать?
[01:16:10.720 --> 01:16:15.760]  Я должен написать, если нечто, то вернуть одно иначе другое. Какой тип?
[01:16:15.760 --> 01:16:19.760]  STD conditional.
[01:16:19.760 --> 01:16:23.760]  STD conditional T.
[01:16:23.760 --> 01:16:29.760]  Тут проблема, потому что я не знаю, какой условий пока написать. Надо как-то проверить, является ли move конструктор no accept.
[01:16:29.760 --> 01:16:40.800]  Если вы внимательными слушателями были, то у нас было ключевое слово, которое проявляет некоторые выражения no accept.
[01:16:40.800 --> 01:16:46.800]  Ключевое слово no accept.
[01:16:46.800 --> 01:16:52.800]  Как я это могу сделать?
[01:16:52.800 --> 01:16:58.800]  Наивный способ сделать вот так.
[01:16:58.800 --> 01:17:05.840]  Это наивная реализация, она неправильная.
[01:17:05.840 --> 01:17:13.840]  Естественно, не смогу, но accept не вычисляет выражения под собой, он лишь проверяет no accept.
[01:17:13.840 --> 01:17:19.840]  Но accept проверяет, правда ли, что все думают, что есть no accept.
[01:17:19.840 --> 01:17:23.840]  Правильно.
[01:17:23.840 --> 01:17:29.840]  К сожалению, это некорректно, потому что tag может быть no accept, и тогда все вместе будет no accept.
[01:17:29.840 --> 01:17:35.840]  Вот.
[01:17:35.840 --> 01:17:41.840]  Давайте я не буду, короче, я оставлю здесь to do.
[01:17:41.840 --> 01:17:47.840]  Я сейчас не буду рассказывать, как это реализовать. Мы реализуем это попозже.
[01:17:47.840 --> 01:17:53.840]  У нас осталась to do, как реализовать.
[01:17:53.840 --> 01:17:59.840]  Проверка является move конструктор no accept, у изотронов ничего лишнего.
[01:17:59.840 --> 01:18:07.840]  Я могу здесь сказать так, для этого есть специальный tag trade, который называется is no fro move constructible.
[01:18:07.840 --> 01:18:13.840]  Я не буду сейчас.
[01:18:13.840 --> 01:18:19.840]  Нет, нельзя, но это слишком сложно, я сейчас не буду про это рассказывать.
[01:18:19.840 --> 01:18:25.840]  Нам нужно пройти еще кое-что, а потом мы сможем это реализовать.
[01:18:25.840 --> 01:18:31.840]  Is no fro move constructible where?
[01:18:31.840 --> 01:18:37.840]  Это tag trade, который проверяет правда ли move конструктор no accept.
[01:18:37.840 --> 01:18:43.840]  Если это правда, то мы что возвращаем?
[01:18:43.840 --> 01:18:49.840]  Что мы возвращаем?
[01:18:49.840 --> 01:18:55.840]  Что мы возвращаем?
[01:18:55.840 --> 01:19:01.840]  Точно ли?
[01:19:01.840 --> 01:19:07.840]  Да.
[01:19:07.840 --> 01:19:13.840]  Это такое возвращаем ити?
[01:19:13.840 --> 01:19:19.840]  А принимаем ити, у нас будет просто tempersum.
[01:19:19.840 --> 01:19:25.840]  А мы там дольше не должны где-то remove reference?
[01:19:25.840 --> 01:19:31.840]  Нет, не должны, потому что сюда я принимаю не по универсальной ссылке, а по обычной ссылке.
[01:19:31.840 --> 01:19:37.840]  Потому что сюда мне никогда не нужно передавать RBL.
[01:19:37.840 --> 01:19:43.840]  Потому что no accept принимает просто tempersum.
[01:19:43.840 --> 01:19:49.840]  И поэтому мне не нужно remove reference делать, у меня просто будет либо T2, либо const tempersum.
[01:19:49.840 --> 01:19:55.840]  Потому что я хочу либо возвращать RBL в ссылку, либо возвращать const tempersum как обычную ссылку для копирования.
[01:19:55.840 --> 01:20:01.840]  Что я здесь напишу?
[01:20:01.840 --> 01:20:07.840]  Ну то есть я возвращаю то, что мне вернул move,
[01:20:07.840 --> 01:20:13.840]  но оно становится const tempersum, если move конструктор был не no accept.
[01:20:13.840 --> 01:20:19.840]  И T2 tempersum иначе.
[01:20:19.840 --> 01:20:25.840]  А нормально ставить там T2 tempersum, а не remove reference?
[01:20:25.840 --> 01:20:29.840]  Да нормально, я только что объяснил почему.
[01:20:29.840 --> 01:20:33.840]  Сейчас секунду, а у нас мета была no accept?
[01:20:33.840 --> 01:20:37.840]  Да, это безусловно, это правда.
[01:20:43.840 --> 01:20:45.840]  Еще вопрос, ну кроме тех, на которые я уже отвечал.
[01:20:45.840 --> 01:20:47.840]  Ну хорошо, давайте еще раз скажу почему нормально.
[01:20:47.840 --> 01:20:51.840]  Потому что я принимаю не универсальную ссылку, а обычно RBL в ссылку.
[01:20:51.840 --> 01:20:55.840]  Мне поэтому не нужно remove reference.
[01:20:55.840 --> 01:20:59.840]  Вот именно эту функцию я здесь и использую.
[01:20:59.840 --> 01:21:07.840]  И теперь у меня соблюдена move семантика.
[01:21:07.840 --> 01:21:11.840]  Соблюдена exe в сети, извиняюсь.
[01:21:15.840 --> 01:21:19.840]  Так, сейчас я правда кое-что открою.
[01:21:19.840 --> 01:21:23.840]  А, нам это не важно писать.
[01:21:35.840 --> 01:21:39.840]  Давайте я вам следующий вопрос задам.
[01:21:39.840 --> 01:21:49.840]  А если у меня тип вообще не поддерживает копирование?
[01:21:49.840 --> 01:21:51.840]  А только move не поддерживает?
[01:21:51.840 --> 01:21:53.840]  Что тогда делать?
[01:21:53.840 --> 01:21:55.840]  Такие типы бывают уже, напоминаю.
[01:21:55.840 --> 01:22:01.840]  Например, uniquevtr, который мы правда еще не проходили, но пройдем через 15 минут.
[01:22:01.840 --> 01:22:03.840]  Или trap.
[01:22:03.840 --> 01:22:07.840]  Ну в общем бывают типы, которые не умеют копироваться, умеют только move-аться, мы с вами это обсуждаем.
[01:22:07.840 --> 01:22:09.840]  А физи не будет?
[01:22:09.840 --> 01:22:11.840]  Нет, сегодня я у этого пара.
[01:22:11.840 --> 01:22:15.840]  Но видимо надо требовать, чтобы у таких типов обязательно был move-конструктор на exe.
[01:22:15.840 --> 01:22:17.840]  Нет, все проще.
[01:22:17.840 --> 01:22:19.840]  Vector делает следующим образом.
[01:22:19.840 --> 01:22:23.840]  Если у вас, там написано следующее.
[01:22:23.840 --> 01:22:35.840]  Если move-конструктор не на exe, то если есть copy-конструктор, то используем его, а иначе move все равно и забиваем на exe сети.
[01:22:37.840 --> 01:22:39.840]  То есть Vector так делает.
[01:22:39.840 --> 01:22:41.840]  Он пытается move-ить, если там noexcept.
[01:22:41.840 --> 01:22:43.840]  Если нет, он пытается копировать.
[01:22:43.840 --> 01:22:47.840]  Но если нет copy-конструктора вообще, то он забивает на exe и move-ит, и тогда не до этого никакие границы.
[01:22:47.840 --> 01:22:49.840]  Это как за exe сети.
[01:22:49.840 --> 01:22:51.840]  Да, иначе вы тогда бы Vector не смогли копировать.
[01:22:51.840 --> 01:22:53.840]  Тогда не от этого.
[01:22:53.840 --> 01:22:55.840]  Дестрой не новый exe.
[01:22:55.840 --> 01:22:57.840]  Если дестрой не noexcept, то это вообще не свидание.
[01:22:57.840 --> 01:22:59.840]  Тут похоже.
[01:22:59.840 --> 01:23:01.840]  Да.
[01:23:01.840 --> 01:23:03.840]  Вот.
[01:23:03.840 --> 01:23:11.840]  В связи с этим, если мы посмотрим на определение move-ноexe в стандарте, мы увидим, что оно вот такое.
[01:23:11.840 --> 01:23:13.840]  Оно чуть сложнее, чем я написал.
[01:23:13.840 --> 01:23:19.840]  Оно std-conditional, но не просто из nofromove-constructible, а еще проверка, что из copy-constructible.
[01:23:19.840 --> 01:23:25.840]  То есть посмотрите, пожалуйста, при каком условии он возвращается в темп двойной персант и при каком какой-то темп персант.
[01:23:25.840 --> 01:23:35.840]  Если этот тип nofromove-constructible или не copy-constructible, то va вернет std-conditional, а иначе conditional.
[01:23:35.840 --> 01:23:37.840]  Да, это отрицание.
[01:23:37.840 --> 01:23:39.840]  Да, да, да. Ну, я сформулировал отрицание.
[01:23:39.840 --> 01:23:53.840]  Move-noexcept как раз проверяет, правда ли Vector, она специально для этого и существует, она проверяет, правда ли Vector не noexcept move-constructible или copy-constructible.
[01:23:55.840 --> 01:24:03.840]  Если что-то из этого, тогда он будет... Ой, я неправильно сформулировал.
[01:24:03.840 --> 01:24:13.840]  Да, и copy-constructible. Если что-то из этого верно, то он вернет lvl и иначе lvl.
[01:24:13.840 --> 01:24:15.840]  Почему?
[01:24:17.840 --> 01:24:20.840]  А тем, что тут constexpr добавилось.
[01:24:20.840 --> 01:24:22.840]  А мы не будем показывать.
[01:24:26.840 --> 01:24:36.840]  Вот, это вопрос тоже такой, ну, я не знаю, для продвы это может быть вопрос не на отл, но, в общем, это такой вопрос на глубокое понимание того, как Vector работает.
[01:24:36.840 --> 01:24:46.840]  Вот, допустим, вы реализовали строку и забыли написать noexcept move-constructible, вы с удивлением обнаружите, что Vector будет копировать вашу строку при перекладывании, а не move-ить все еще.
[01:24:46.840 --> 01:25:01.840]  Именно поэтому, если вы в вашем типе забудете написать noexcept move-constructible, то при использовании Vector вы обнаружите, что в pushback он копирует ваш тип полностью, а не move-ает, потому что он вот так вот устроен.
[01:25:01.840 --> 01:25:03.840]  Можно закупить copy-constructible.
[01:25:03.840 --> 01:25:05.840]  А если вы забудете, то закупим.
[01:25:05.840 --> 01:25:08.840]  Папа, если мы нарешим noexcept move-constructible?
[01:25:09.840 --> 01:25:15.840]  Так, давайте расскажу последнюю вещь, и мы на перелыв пойдем, красна в пара закончилась.
[01:25:16.840 --> 01:25:22.840]  Последняя вещь такая, вот это просто, я не знаю, это вопрос уже на отл 10, наверное.
[01:25:22.840 --> 01:25:24.840]  Угу.
[01:25:27.840 --> 01:25:30.840]  Ну, для вас это не будет вопрос, потому что я вам его засподню.
[01:25:30.840 --> 01:25:34.840]  Но вообще, для тех, кого я этого никогда не слышал, это, этим может быть, я не знаю.
[01:25:34.840 --> 01:25:40.840]  Значит, сейчас я вам расскажу, как завалить собеседующего на собеседовании, если он попросит вас реализовать pushback.
[01:25:42.840 --> 01:25:43.840]  Найс.
[01:25:43.840 --> 01:25:44.840]  Это полезно, это.
[01:25:44.840 --> 01:25:45.840]  Да, собеседуешься на собеседовании.
[01:25:45.840 --> 01:25:46.840]  Да, да, да.
[01:25:46.840 --> 01:25:52.840]  Просто, как правило, когда собеседующий просит вас реализовать pushback, он ожидает от вас не многого, но не этого.
[01:25:52.840 --> 01:25:55.840]  Вот сейчас, в общем, высший полотаж.
[01:25:55.840 --> 01:25:56.840]  Чего угодно, но нет.
[01:25:56.840 --> 01:26:00.840]  Что можно спросить у собеседующего по поводу реализации pushback?
[01:26:00.840 --> 01:26:01.840]  А как он просит?
[01:26:02.840 --> 01:26:04.840]  А что должен делать pushback?
[01:26:05.840 --> 01:26:06.840]  Смотрите.
[01:26:10.840 --> 01:26:12.840]  Смотрите, смотрите, пожалуйста.
[01:26:12.840 --> 01:26:14.840]  Давайте представим, что у меня есть вектор строк.
[01:26:14.840 --> 01:26:15.840]  Подожди.
[01:26:15.840 --> 01:26:16.840]  Тихо.
[01:26:16.840 --> 01:26:17.840]  Вот у меня есть вектор строк.
[01:26:19.840 --> 01:26:20.840]  Да.
[01:26:20.840 --> 01:26:24.840]  В, вот, допустим, четырех строк, каждый из которых равна овц.
[01:26:24.840 --> 01:26:25.840]  Ну, все понятно.
[01:26:25.840 --> 01:26:27.840]  И я говорю, v.pushback.
[01:26:30.840 --> 01:26:31.840]  Опять.
[01:26:32.840 --> 01:26:33.840]  В.
[01:26:35.840 --> 01:26:36.840]  Третий вопрос.
[01:26:39.840 --> 01:26:40.840]  Что произойдет?
[01:26:40.840 --> 01:26:41.840]  Что произойдет?
[01:26:44.840 --> 01:26:45.840]  Скопировать.
[01:26:45.840 --> 01:26:46.840]  Скопировать.
[01:26:47.840 --> 01:26:50.840]  Что произойдет, если вот буквально выполняет тот код, который мы написали?
[01:26:51.840 --> 01:26:53.840]  А мой move, потому что это...
[01:26:54.840 --> 01:26:55.840]  Что делает pushback?
[01:26:55.840 --> 01:26:58.840]  Он видит, а, место кончилось, надо реалацировать.
[01:26:58.840 --> 01:26:59.840]  String, отличный T.
[01:26:59.840 --> 01:27:02.840]  Поддержит move-семантику, move-конструктор, no accept.
[01:27:02.840 --> 01:27:04.840]  Значит, мы начинаем перекладывать.
[01:27:04.840 --> 01:27:06.840]  Перекладываем, классно.
[01:27:06.840 --> 01:27:09.840]  Берем этот массив, все move-ем.
[01:27:10.840 --> 01:27:12.840]  Значит, сюда вот это все кладем.
[01:27:12.840 --> 01:27:13.840]  Массив...
[01:27:13.840 --> 01:27:16.840]  Здесь лежат пустые объекты теперь.
[01:27:16.840 --> 01:27:20.840]  И теперь, наконец, мы можем положить сюда новую строку.
[01:27:20.840 --> 01:27:21.840]  По ссылочке.
[01:27:21.840 --> 01:27:24.840]  Она нам была передана вот так, по этой ссылочке.
[01:27:24.840 --> 01:27:25.840]  Откуда у нас эта ссылочка?
[01:27:25.840 --> 01:27:26.840]  Сюда.
[01:27:27.840 --> 01:27:28.840]  Что же мы положим?
[01:27:28.840 --> 01:27:29.840]  Пустую строку, да?
[01:27:31.840 --> 01:27:32.840]  Нет, а можно...
[01:27:32.840 --> 01:27:33.840]  Что же делать?
[01:27:33.840 --> 01:27:34.840]  Плакать.
[01:27:34.840 --> 01:27:36.840]  Что делать, если мы вектор?
[01:27:36.840 --> 01:27:38.840]  Пытаемся положить элемент от того же самого вектора.
[01:27:38.840 --> 01:27:39.840]  По ссылке.
[01:27:39.840 --> 01:27:42.840]  А разве мы не положили его куинем?
[01:27:42.840 --> 01:27:44.840]  Нет, мы по ссылке приняли.
[01:27:44.840 --> 01:27:46.840]  Мы его приняли по ссылке.
[01:27:46.840 --> 01:27:48.840]  А ссылку кладем сюда.
[01:27:48.840 --> 01:27:50.840]  А отсюда мы уже move-ем.
[01:27:50.840 --> 01:27:52.840]  Сколько можно?
[01:27:52.840 --> 01:27:56.840]  А можно перед вообще всем это move-ить куда-то в левое место?
[01:27:56.840 --> 01:27:58.840]  А можно создавать левое место?
[01:27:58.840 --> 01:28:00.840]  Значит, ответ такой.
[01:28:01.840 --> 01:28:02.840]  Это...
[01:28:02.840 --> 01:28:04.840]  Сначала история вопроса.
[01:28:04.840 --> 01:28:08.840]  Однажды этим вопросом задался один мой коллега у меня в андексе, когда мы уже там...
[01:28:08.840 --> 01:28:10.840]  Мы уже для работы, в общем.
[01:28:10.840 --> 01:28:13.840]  Просто что-то пришел и спросил, а вот я тут задумался.
[01:28:13.840 --> 01:28:15.840]  А как это работает?
[01:28:15.840 --> 01:28:18.840]  То есть вы поняли, что никто из нас не знает ответа, полезно читать исходники.
[01:28:18.840 --> 01:28:20.840]  Исходники гениальные.
[01:28:20.840 --> 01:28:23.840]  Просто когда вы делаете pushback, вы должны выделить массив
[01:28:23.840 --> 01:28:27.840]  и сначала покутаться на место, я не положил этот объект,
[01:28:27.840 --> 01:28:29.840]  а только потом перекладывать остальные.
[01:28:31.840 --> 01:28:33.840]  Тогда это будет работать корейки.
[01:28:34.840 --> 01:28:37.840]  Именно так и должен быть написан pushback,
[01:28:37.840 --> 01:28:39.840]  иначе вот этот пример будет валить тест.
[01:28:43.840 --> 01:28:46.840]  Правильный pushback реализован так.
[01:28:46.840 --> 01:28:48.840]  Сначала после того, как вы реализовали,
[01:28:48.840 --> 01:28:51.840]  вы кладете этот объект на место M,
[01:28:51.840 --> 01:28:53.840]  а потом только перекладываете остальные,
[01:28:53.840 --> 01:28:57.840]  и если не получилось, то все понятно.
[01:28:57.840 --> 01:28:59.840]  Но сначала вы кладете объект на место,
[01:28:59.840 --> 01:29:01.840]  потом перекладите остальные, а не наоборот,
[01:29:01.840 --> 01:29:03.840]  иначе у вас этот пример сломается.
[01:29:05.840 --> 01:29:07.840]  На этом мы закончили голодесятую.
