[00:00.000 --> 00:11.440]  Ну что ж мы начинаем пятую лекцию. Пятая лекция у нас будет про средства метапрограммирования,
[00:11.440 --> 00:16.640]  которые устроены в REST. На самом деле их больше, чем просто макросы, которые мы будем преимущественно
[00:16.640 --> 00:20.640]  изучать на этой лекции, но остальное у вас останется в домашней лекции как бонусное.
[00:20.640 --> 00:28.800]  То есть, например, как мы дальше узнаем, есть средства, с помощью которых можно делать на трейтах
[00:28.800 --> 00:32.720]  такие штуки, которые позволяют в Compile Time интерпретировать какие-нибудь языки.
[00:32.720 --> 00:38.360]  Ну то есть трейты, Turing Palme, проще говоря, в REST. Мы это изучать, конечно, на лекциях не будем,
[00:38.360 --> 00:44.560]  потому что есть прекрасная штука, называемая макросами, и template метапрограммирование,
[00:44.560 --> 00:50.360]  которое вы могли видеть в плюсах, что там пишут интерпретаторы языков. В общем-то,
[00:50.360 --> 00:55.600]  в REST есть гораздо более прикольные штуки. В этой лекции мы посмотрим на closures,
[00:55.600 --> 00:58.760]  буквально немножко поговорим про метапрограммирование в целом,
[00:58.760 --> 01:03.760]  про декларативные макросы, процедурные макросы, и немножечко посмотрим на те макросы,
[01:03.760 --> 01:06.080]  которые есть в стандартной библиотеке для упрощения нашей жизни.
[01:06.080 --> 01:15.280]  Вот closures. Ну и с ними уже однозначно сталкивались домашние. Выглядят они вот так вот.
[01:15.280 --> 01:21.880]  У нас есть какие-то палочки такие, а там внутри какой-то код. В данном случае у нас всего лишь
[01:21.880 --> 01:25.280]  одна строчка, поэтому мы можем, например, написать их без фигурных скобочек.
[01:25.280 --> 01:30.880]  Если вам захочется несколько строчек, то в таком случае нужно добавить фигурные скобки.
[01:30.880 --> 01:37.240]  Итак, ну я думаю, то, что происходит в коде, вам полностью понятно. Скажите,
[01:37.240 --> 01:39.880]  пожалуйста, в чем разница между closures и обычными функциями?
[01:39.880 --> 01:53.680]  Ну давайте так, я чуть-чуть изменю вопрос. Чем отличаются лямбды от функций плюсов?
[01:53.680 --> 02:00.720]  Да, closures захватывают окружение. Это такая анонимная функция,
[02:00.720 --> 02:07.640]  которая может использовать переменные из скопа. Например, в данном случае у нас equal to x захватывает
[02:07.640 --> 02:15.480]  x, и мы сравниваем там y с x в ассерте. Естественно, ассерт проходит. С обычными функциями так бы не
[02:15.480 --> 02:19.160]  получилось, потому что они умеют только что-то принимать на вход и что-то использовать из глобального
[02:19.160 --> 02:32.800]  скопа. Вот так. В отличие от обычных функций closures смогут выводить типы. То есть в расти мы обычно
[02:32.800 --> 02:37.520]  требуем от функций, чтобы мы написали конкретный тип, который они принимают. То есть ходные типы
[02:37.520 --> 02:44.000]  и выходной тип. Это нужно для того, чтобы type inference работал хорошо, чтобы мы в самом коде не писали
[02:44.000 --> 02:50.040]  никаких типов и писали только то, что возвращают сами функции. То есть там есть такая система типов,
[02:50.040 --> 02:56.240]  называется Hindley-Millner. Мы, конечно же, не проходим, потому что это математика. Это алгоритм такой,
[02:56.240 --> 03:01.560]  который позволяет выводить типы, которые используются в коде, основываясь на том,
[03:01.560 --> 03:05.440]  как они используются. Собственно, в расте используется вариация такой алгоритм.
[03:05.440 --> 03:14.360]  Скажи по-гробче. Да, я точно включил запись. Там есть оранжевая точечка сверху.
[03:14.360 --> 03:24.480]  Option.t map не помню, что такое. Вот мы как раз с option, как он переводит option.t в option.u.
[03:24.480 --> 03:32.280]  Map это такая штука, которая принимает на вход функцию. Если у тебя наун, то возвращайте наун.
[03:32.280 --> 03:43.080]  Как видите, в первом случае мы явно написали типы, которые мы хотим от Clojure. То есть точно так же,
[03:43.080 --> 03:48.600]  как и функции. Там двоеточие, такой-то тип, стрелочка, такой-то тип. Возвращаем. И с
[03:48.600 --> 03:55.200]  Infrared мы не написали никаких типов, раз все за нас вывел. Это сделано так потому,
[03:55.200 --> 04:00.040]  что Clojure используется в таких контекстах, в которых можно очень легко вывести типы
[04:00.040 --> 04:05.160]  используемых переменных, и потому они не требуются. То есть просто потому, что такое
[04:05.160 --> 04:13.360]  прагматичное решение, это удобно, и поэтому в отличие от функций все выводится. Давайте попробуем
[04:13.360 --> 04:18.800]  повторить функциональность option.map. Возможно, вы видели когда-нибудь даже
[04:18.800 --> 04:25.440]  определение, пока вы решали домашки. Ну, оно, конечно, чуть-чуть по-другому здесь написано,
[04:25.440 --> 04:30.440]  потому что в этом примере это не часть option, а это какая-то отдельная функция,
[04:30.440 --> 04:34.680]  которая принимает на вход option. Работает, в принципе, точно так же. У нас есть какой-то
[04:34.680 --> 04:41.160]  option, который мы принимаем на вход, потом есть transform. Мы матчим наш option, и если это сам,
[04:41.160 --> 04:47.000]  то возвращаем сам transform, иначе нам. Возникает вопрос, а что же на место точечек поставить?
[04:47.000 --> 04:59.960]  Какой тип у того, что принимается на вход мэпа? Нижнее подчеркивание, оно в этом контексте,
[04:59.960 --> 05:07.360]  конечно же, ничего не выедет. Функция должна быть конкретным, конкретный тип. Мы, конечно,
[05:07.360 --> 05:12.600]  хотим, чтобы transform был каким-то объектом, который callable, то есть, который мы можем вызывать.
[05:12.600 --> 05:19.000]  Когда мы хотим врасти, абстрагироваться относительно какого-то свойства, то мы используем
[05:19.000 --> 05:25.720]  trait всегда. Хочется придумать какой-то trait, который у нас transform будет каким-то типом T,
[05:25.720 --> 05:31.960]  и этот T будет исполнять какой-то trait, который будет означать, что у нас объект вызываемый.
[05:31.960 --> 05:40.280]  Давайте задизайним этот trait. Во-первых, у нас такая идея. Я заранее говорю о том,
[05:40.280 --> 05:44.520]  что она точно такая же, как и в плюсах. В плюсах лямбды работает точно так же,
[05:44.520 --> 05:54.040]  как closures. Идея такая. Компилятор генерирует структуру, которая имплементирует какой-то trait.
[05:54.040 --> 05:59.720]  То есть, если вы пишете closure, то на самом деле компилятор – это такой синтактический сахар
[05:59.720 --> 06:06.160]  для какой-то сгенерированной компилятором структурки, в котором будет класть объект со
[06:06.160 --> 06:12.120]  scope. Остальное будет с глобального scope, либо то, что на вход, мы принимать на вход, либо
[06:12.120 --> 06:17.360]  брать с глобального scope. Вы когда-то говорили, что closures – это зеро cost abstraction. Да,
[06:17.360 --> 06:23.120]  мы сейчас это увидим. Он даже еще более зеро cost abstraction, чем в плюсах, потому что мы на самом деле
[06:23.120 --> 06:33.040]  можем тип вывести. Вот. У нашего trait будет, естественно, только одна функция. Это значит
[06:33.040 --> 06:43.400]  вызвать функцию, собственно. Круглые скобочки. Так как в Rasty у нас нет вариадик. Вариадики есть
[06:43.400 --> 06:47.280]  некоторые преграды для того, чтобы их добавить. Подробно мы о них говорить не будем. Если
[06:47.280 --> 06:52.040]  интересно, можете погуглить. Есть люди, которые пишут целые списки того, почему не нужно добавлять
[06:52.240 --> 06:59.840]  вариадики в Rast. Вместо этого мы будем использовать tuple. Во время имплементации этого trait.
[06:59.840 --> 07:07.120]  Поэтому у нас на самом деле будет наш trait принимать на вход аргументы не в качестве
[07:07.120 --> 07:18.360]  какого-то списка вариадик аргументов, а какой-то tuple, как один аргумент. Ну давайте примерно так
[07:18.360 --> 07:25.640]  и сделаем. У нас есть какой-то trait, который принимает на вход input. Input generic. Output это
[07:25.640 --> 07:31.920]  какой-то ассоциированный тип. И вот функция transform есть. Ну это мы так назовем наши круглые
[07:31.920 --> 07:39.680]  скобочки. Вот. Ну соответственно какой-то input на вход приходит и output. Так. Ну скажите мне,
[07:39.680 --> 07:43.800]  почему мы должны в этом trait'е вообще писать self? Зачем нам тот нужен?
[07:43.800 --> 08:06.720]  Ещё раз повтори, пожалуйста. Да, как раз потому, что у нас self как раз сохраняет наш скоб
[08:06.720 --> 08:12.320]  текущий. Поэтому мы обязаны использовать self. Он является нашим storage для того,
[08:12.320 --> 08:22.040]  что мы приняли на вход. Вот. Если, кстати говоря, если вы будете внимательно посмотреть на этот
[08:22.040 --> 08:27.640]  вот trait, у вас возникнет вопрос, почему мы, например, input написали как generic, а вот как
[08:27.640 --> 08:33.400]  ассоциированный тип. Знаете, я честно вам скажу, я не знал ответа на этот вопрос. Я пытался погуглить,
[08:33.400 --> 08:39.400]  нашёл только два места, в котором про это можно почитать, и ни в одном из них не пришли никакому
[08:39.400 --> 08:47.240]  разумному решению. Вот. Поэтому, если вам интересно почему, то я не знаю точного ответа. Я могу
[08:47.240 --> 08:52.640]  только предположить, что, возможно, это для того, чтобы сэкономить, например, ну, запревентить
[08:52.640 --> 09:00.120]  quote-blood, например. Ну, то есть для того, чтобы у вас есть структурка, и вы могли для разных
[09:00.120 --> 09:06.240]  input'ов использовать одну и ту же структурку. То есть, если у него scope состоит из одинаковых
[09:06.240 --> 09:11.200]  типов переменных, в таком случае вы могли бы одну и ту же структурку использовать для разных
[09:11.200 --> 09:18.240]  input'ов. Это так. Ладно, в общем, забейте, если что, это такая вещь, которую всё равно никто,
[09:18.240 --> 09:24.760]  видимо, не знает ответ, поэтому... Это выглядит как такой отголосок того факта, что в плюсах нельзя
[09:24.760 --> 09:30.680]  делать перегрузку по типа возвращаемого значения. Ну, здесь можно было бы сделать так, что у тебя
[09:31.680 --> 09:38.440]  внутри type input и type output. И ты бы мог, грубо говоря, перегрузку сделать как... У тебя,
[09:38.440 --> 09:42.920]  с одной стороны, для одной структуры могла бы быть только одна имплементация трансформа.
[09:42.920 --> 09:50.080]  Мог бы быть только один input и один output указан. В такой вот имплементации ты можешь для одного
[09:50.080 --> 09:58.640]  output'а указать много input'ов для одной структурки и, соответственно, переиспользовать её. Я, правда,
[09:58.640 --> 10:03.040]  не знаю, зачем это нужно, но как есть. Возможно, для того, чтобы как раз уменьшить число типов.
[10:03.040 --> 10:10.680]  Возможно, какие-то ещё более глубокие вещи, связанные с теорией типов есть. Ну, я тут,
[10:10.680 --> 10:19.480]  конечно, не знаю. И никто, судя по всему, в Гугле тоже не знает. Сам факт, что у нас будет
[10:19.480 --> 10:26.560]  примерно вот так вот это выглядеть. Вопрос, а что нам нужно из этого точно? Нам нужен self,
[10:26.560 --> 10:46.120]  mute self или ссылочка на self? Ну, ты почти прав с точностью наоборот. На самом деле,
[10:46.120 --> 10:59.280]  подходит каждый из них по-своему. Смотрите, у нас юзер, если у нас будет self, то в таком случае,
[10:59.280 --> 11:03.040]  когда мы будем вызывать наш closure, то в таком случае она умрёт. Мы сможем её вызвать только
[11:03.040 --> 11:08.320]  один раз. Ну и с другой стороны, мы ещё будем при этом внутри closure владеть объектами, сможем
[11:08.320 --> 11:14.200]  их дропать и всё такое. Mute self мы с одной стороны не будем владеть объектами внутри closure,
[11:14.200 --> 11:23.680]  но сможем мутировать. У нас уникальный доступ, скажем так. И, соответственно, ссылка, мы не
[11:23.680 --> 11:28.120]  сможем ничего мутировать, но точно так же, как и в случае с mute self, сможем много раз вызывать наш
[11:28.120 --> 11:38.240]  closure. Получается, что кажется, что это зависит от того, какой у нас юзкейс. Как сказал, как тебя
[11:38.240 --> 11:44.000]  зовут, кстати? Данил. Как сказал Данил, у нас компилятор умный, он подстроится. Сейчас мы увидим,
[11:44.000 --> 11:49.400]  как это будет выглядеть, когда дойдём до реального применения. Ну, в общем-то, мы, естественно,
[11:49.400 --> 11:56.120]  хотим выбрать самую-самую высокую строчку из тех, что нам подходит. Потому что, если нам
[11:56.120 --> 12:02.360]  достаточно вызвать один раз closure, то почему бы её сразу же не съесть? Давайте попробуем
[12:02.360 --> 12:08.360]  имплементировать для селфа. Если мы для селфа это сделаем вот так вот, то у нас будет вот такой
[12:08.360 --> 12:13.240]  трейв с селфом внутри. У нас будет мэп, который будет принимать на вход какой-то тип тэ,
[12:13.240 --> 12:18.960]  который имплементирует, transform, с типом, соответственно, x в качестве входного и выходным в качестве
[12:18.960 --> 12:33.400]  входного y. У нас option x приходит option y. Как видите, тут понятно, да? А это ты специфицируешь, какой
[12:33.400 --> 12:40.600]  конкретно там ассоциированный тип? Просто там же t может быть самым разным, а входной тип может
[12:40.600 --> 12:46.160]  быть одинаковым, а выходной разным для разных типов. Поэтому тебе нужно специфицировать,
[12:46.160 --> 12:50.480]  какой ассоциированный тип ещё будет. Для этого такой синтаксис предназначен.
[12:50.480 --> 13:01.800]  Ну, generic ты можешь имплементировать для одной структуры разные трейты с разными
[13:01.800 --> 13:06.560]  generic. Ну, то есть в плане, что если ты для одной структурки, в случае transform,
[13:06.560 --> 13:13.840]  можешь для разных input'ов имплементировать свой структур, trade для своей структуры.
[13:13.840 --> 13:19.440]  Вот. А если бы это был ассоциированный тип, тогда бы ты смог только одну сделать
[13:19.440 --> 13:24.720]  имплементацию. Потому что generic ты как бы generic по всем input'ам, а ассоциированный тип он
[13:24.720 --> 13:29.080]  просто как бы фиксирован. Вот для этих входных параметров, для этого input'а ассоциированный
[13:29.080 --> 13:31.600]  тип output. Он только один, он не generic.
[13:31.600 --> 13:39.200]  Ну, это похоже на то, что нельзя перегружать только по украшаемому значению. То есть мы
[13:39.200 --> 13:44.160]  просто конкретно всегда по типам входных данных можем установить тип выходных. То есть мы
[13:44.160 --> 13:46.360]  каким образом социальное соответствие устанавливаем?
[13:46.360 --> 13:51.040]  Ну да, да. Я тоже думал, что про инъекцию-сюръекцию, может быть оно как-то из-за этого уводится.
[13:51.040 --> 13:59.560]  Ну да, да. Ну, как-то не знаю. С другой стороны, вроде бы почему бы не оставить type input? Не
[13:59.560 --> 14:05.840]  знаю. Вроде бы и так должен все работать. Ладно. Разве что только логично, что input
[14:05.840 --> 14:09.560]  параметры это generic, а output параметры это ассоциированный тип, то есть какая-то логика.
[14:09.560 --> 14:20.280]  Вот там есть, но она немножко туманная. Ну, давайте пойдем к тому, как это использовать.
[14:20.280 --> 14:29.000]  Вот мы сделали наш опцион. Это сам, двойка. Соответственно, x. И сделали map. Смотрите,
[14:29.000 --> 14:34.320]  как у нас map работает. Мы создаем тип adder. Кстати, adder же объявил здесь. Я продолбал adder.
[14:34.320 --> 14:41.560]  Как же так вышло? В общем, там должен был быть слайд, где еще объявляется структура adder,
[14:41.560 --> 14:45.960]  для которой имплементируется трансформа. Внутри трансформа просто происходит суммирование.
[14:45.960 --> 14:52.080]  Ну блин, я помню, что это писал, но куда-то продолбался слайд. Не знаю, как так вышло,
[14:52.080 --> 14:58.960]  но потерялся. Я думаю, что в принципе понятно, что там просто имплементируется trait для adder.
[14:58.960 --> 15:03.000]  Соответственно, когда мы его запихиваем, он работает. Мы внутри сможем вызвать трансформ
[15:03.000 --> 15:08.920]  от нашего adder. И все хорошо. Итак, с этим слайдом понятно?
[15:08.920 --> 15:22.960]  Здесь Rust еще использует, ну, реально Rust использует trait.fn.mute.fn.once. Они так называются.
[15:22.960 --> 15:30.320]  Они, конечно, называются intranform вот так вот. Они имеют вот такую вот сигнатурку.
[15:30.320 --> 15:38.120]  У них точно также input-параметры есть, которые называются args. Есть output-параметры. Ну output,
[15:38.120 --> 15:42.440]  как видите, только один в fn.once. А дальше вы можете обратить внимание, что fn.mute, например,
[15:42.440 --> 15:51.600]  от fn.once наследуется, а fn.fn.mute. Ну потому что вам ничего не мешает вызвать с владеющими
[15:51.600 --> 15:58.080]  значениями closure, если у вас fn. Просто вы не владеете значениями, у вас там только ссылки
[15:58.080 --> 16:03.800]  внутри. Почему бы эти ссылки не съесть? Никакой проблемы нет. В общем, это может немножко запутать,
[16:03.800 --> 16:10.320]  потому что казалось бы, что fn мы там можем выводить много раз, а здесь fn.once только один раз,
[16:10.320 --> 16:16.080]  и у нас получается вот такая вот последовательность. Но если вы внимательно посмотрите на self,
[16:16.080 --> 16:20.240]  то вы поймете, почему так происходит. Потому что self на самом деле нам дает
[16:20.240 --> 16:25.200]  самую маленькую власть, когда мы говорим про closures, а самую большую дает ссылка на self.
[16:25.200 --> 16:37.360]  Получается, если у нас тип реализует trait fn, то он также реализует fn.mute. Да, и fn.once тоже.
[16:37.360 --> 16:44.320]  Так, и как же на что? Внутри можно делать абсолютно то же самое,
[16:44.320 --> 16:50.200]  то есть внутри com.mute можно делать то же самое, что и внутри call. Просто что в том случае ты
[16:50.200 --> 16:58.960]  владеешь, мутабельную ссылку возьмешь, а там ты вообще заберешь объект в случае fn.mute.
[16:58.960 --> 17:13.240]  Мы можем выразить call через com.mute или наоборот? Мы можем выразить com.mute через call. Внутри мы
[17:13.240 --> 17:27.840]  просто call сделаем. Точно так же мы можем в call.once написать просто com.mute. Здесь вот как-то,
[17:27.840 --> 17:32.880]  мне кажется, реверсная такая зависимость, но если на self и посмотреть, становится понятно.
[17:32.880 --> 17:45.760]  Реальный мэп, конечно, полная имплементация, все в стандартной библиотеке, наслаждайтесь,
[17:45.760 --> 17:54.160]  вот она выглядит вот так. У нас есть option.tap, в котором мы generic есть, мы generic по типу U и по
[17:54.160 --> 18:00.500]  функции f. Причем у нас есть ограничение, что f представляет из себя какую-то структурку,
[18:00.500 --> 18:06.460]  которая имплементирует fn.once, которая переводит f, и соответственно у нас то же самое,
[18:06.460 --> 18:17.900]  что мы писали с transform, который мы придумали. Вот как-то так. Тут понятно. Это особый магический
[18:17.900 --> 18:24.740]  констрейн с стрелочкой. Да, кстати, я еще не сказал, вот это особый синтаксис для этого трейта.
[18:24.740 --> 18:28.700]  Вы пишете вот здесь вот в скобочках просто входные типы через запятую,
[18:28.700 --> 18:36.260]  а после этого в стрелочки выходный тип. Ну просто потому что это удобно.
[18:36.260 --> 18:45.900]  Так, точно так же как в плюсах, вы не можете взять реальный тип, ну в плюсах вы не могли взять тип
[18:45.900 --> 18:52.620]  лямбдф, в Rust вы не можете взять конкретный тип clause, а вообще никак. Потому что это... что?
[18:52.620 --> 18:56.500]  В плюсах можно взять. Такое там декл-тайф.
[18:56.500 --> 19:01.740]  Ну правда декл-тайф нормально там, заработал только 200 плюсов, но заработал.
[19:01.740 --> 19:12.500]  Так, ну в общем, так как это тип нельзя объявить, то в таком случае мы вынуждены использовать не конкретный
[19:12.500 --> 19:19.700]  тип clause, а использовать импл трейд или использовать дин трейд, ну то есть указывать через трейд что-то.
[19:20.660 --> 19:26.460]  Вот, например, у нас return closure возвращает closure, который принцит hello world если его вызвать.
[19:26.460 --> 19:31.620]  На имплимитирует fn от нуля аргументов и, соответственно, ничего не возвращает.
[19:31.620 --> 19:39.580]  Так, ну и соответственно точно так же можете использовать и дин трейд, как я сказал.
[19:39.580 --> 19:45.500]  Вот у нас, например, есть две closure, которые ничего не принимают на фото и что-то возвращают,
[19:45.700 --> 19:52.660]  то есть и 32. В одном случае у нас там что-то выводится, а потом чиселки считается, и в том случае просто чиселка.
[19:52.660 --> 19:58.220]  И в качестве ссылки на 1fn и 32 мы вот положили это вектор.
[20:00.220 --> 20:05.380]  Тут понятно? Просто самый обыкновенный трейд получается.
[20:05.380 --> 20:17.460]  Так, получается, что еще и любые функции имплимитируют эти трейды, то есть вы это не видите,
[20:17.460 --> 20:23.340]  но компиляторы для самых стандартных функций тоже его имплимитируют. Вот у нас есть fncast,
[20:23.340 --> 20:31.580]  который просто берет x и 32, добавляет единичку и перевозит в i64, ну просто какой-то пример такой.
[20:31.580 --> 20:37.860]  И функция, которая принимает на вход что-то, что имплимитирует fnonce из 32 в i64.
[20:37.860 --> 20:45.780]  И внезапно вы в мейне можете сделать funcatcast. Cast, как вы видите, это уже не какая-то closure,
[20:45.780 --> 20:51.380]  это глобальная функция, которую вы можете тоже запихать, потому что она тоже имплимитирует
[20:51.380 --> 20:58.460]  соответствующие трейды. Более того, они все имплимитируют и fnonce, и fnmute, и fn, то есть имплимитируют fn.
[20:58.460 --> 21:06.860]  Это какой-то уникальный синтакс из того, что мы после названия трейдеров пишем там скобочки,
[21:06.860 --> 21:11.980]  стрелочки. Да-да, я вот как раз приговорил, что у нас здесь в скобочках выходные типы,
[21:11.980 --> 21:19.580]  через запятую, здесь вот через стрелочку выходные типы. Это особенно для fn, fnonce, fnmute.
[21:19.580 --> 21:28.060]  То есть получается, что в расти оператор круглых скобочек, это определяется точно так же трейдерами,
[21:28.060 --> 21:34.900]  как и все вещи в расте, в принципе. И, конечно, мы бы хотели, возможно,
[21:34.900 --> 21:39.380]  ворлодить этот оператор для своих типов, но это пока что, возможно, только в nightly.
[21:39.380 --> 21:42.460]  То есть stable у вас не получится, вот если вы в nightly включите,
[21:42.460 --> 21:49.020]  там можно будет вполне перегрузить для какой-то своей структурки fnonce, fnmute, fn, если захотеть.
[21:49.020 --> 21:53.340]  Если это в nightly, то это через несколько месяцев?
[21:53.340 --> 22:00.460]  Ну, не обязательно, может быть несколько лет. Это как быстро пойдет разработка, когда решат,
[22:00.460 --> 22:04.980]  что фича там достаточно покрутилась, что уже поняли, что она ничего не ломает,
[22:04.980 --> 22:09.380]  что она протестировалась, там нет багов никаких, то она попадает в бету, потом stable.
[22:09.380 --> 22:15.900]  То есть когда они фичу решают замержить.
[22:15.900 --> 22:24.380]  Так, еще есть такое понятие как function pointers. Чтобы вы не путались, вот есть еще fn с маленькой буквы.
[22:24.380 --> 22:33.620]  Fn это уже function pointer, это уже конкретное указатель на конкретную функцию. Он не может быть null.
[22:33.620 --> 22:43.500]  Кстати, давайте я пока тоже вспомнил, вот такие вот штуки можно делать даже для всяких имплов структур.
[22:43.500 --> 22:50.260]  То есть там просто в качестве первого аргумента будет self. Причем self будет определену, естественно.
[22:50.260 --> 22:58.940]  Извините, что я так пришел. Только помню, нужно сказать, что вообще все функции имплементируют, которые вы видите.
[22:58.940 --> 23:06.540]  Так, ну, в общем, смотрите, у нас есть fnadd1, который добавляет единичку к usize,
[23:07.380 --> 23:20.300]  и у нас есть pointer на add1, это fn из usize в usize. Как вы можете заметить, я могу точно так же просто вызвать эту функцию.
[23:20.300 --> 23:31.500]  Fn это уже конкретный тип, в отличие от trait, который мы поговорили уже. Он тоже имплементирует trait fn с большой буквы, соответственно, можно его вызывать.
[23:31.580 --> 23:39.620]  Это самая полезная вещь для ffi, а вообще в целом в Rust вы, наверное, никогда не будете встречаться с function.pointer'ом.
[23:45.420 --> 23:53.220]  Вот как-то так. Ну и как вы можете заметить, еще у нас function.pointer для closures еще работает, но это в тот момент, когда мы знаем, где closure находится.
[23:53.220 --> 24:06.820]  Например, еще, кстати, здесь не смажь type, забыл сказать, смотрите, вот здесь так closure, который берет аргумент внешний, взял.
[24:06.820 --> 24:22.860]  Ну и, в общем-то, раз уж у нее появляется какая-то структура, какой-то input, там-то соответственно она уже не является function.pointer'ом каким-то, у нее есть кроме input типов еще какой-то scope, соответственно, fn она не имплементирует.
[24:23.860 --> 24:26.860]  А менять, соответственно, указатель на function нигде?
[24:27.860 --> 24:30.860]  Менять можно, но он никогда не может быть.
[24:30.860 --> 24:32.860]  То есть переприсвоить?
[24:32.860 --> 24:34.860]  Переприсвоить можно.
[24:40.860 --> 24:50.860]  Давайте сейчас поймем, как у нас Rust вообще захватывает переменные. В плюсах у нас там были квадратные скобчики, в квадратных скобчиках мы писали, как мы типа конкретно берем.
[24:51.860 --> 24:56.860]  Давайте сделаем такое объявление, структурка t и возьмем три функции.
[24:56.860 --> 25:01.860]  Нам будет владеющие брать, потом поументабельные ссылки и посылки t.
[25:05.860 --> 25:07.860]  Такое простенькое объявление.
[25:09.860 --> 25:14.860]  Что ж, соответственно, x, y, z у нас это т.
[25:14.860 --> 25:19.860]  И внутри closure у нас by-ref вызывается от всех трех ссылок.
[25:20.860 --> 25:24.860]  В этот момент closure еще является fn просто.
[25:24.860 --> 25:28.860]  Потому что все, что она берет, она берет все по ссылке.
[25:28.860 --> 25:32.860]  Соответственно, структура closure из себя представляет просто три ссылки.
[25:32.860 --> 25:35.860]  На x, на y, на z.
[25:37.860 --> 25:43.860]  Когда вы сделаете by-new to y и z, то в таком случае вам уже нужно будет взять мутабельную ссылку.
[25:43.860 --> 25:50.860]  И в этот момент раз решит, что вообще-то ваша closure должна брать y и z по мутабельной ссылке внутри.
[25:50.860 --> 25:55.860]  И будет их хранить также в структурке, которая там будет внутри создавать компилятор.
[25:57.860 --> 26:00.860]  И, соответственно, эта closure будет имплементировать уже fn mute.
[26:01.860 --> 26:08.860]  Ну и вот последнее, если вы допишете еще by-value z, то в таком случае z придется взять уже по значению.
[26:08.860 --> 26:12.860]  Closure начнет имплементировать только fn once.
[26:13.860 --> 26:19.860]  Ну и, соответственно, внутри там будет мутабельная ссылка на x, мутабельная ссылка на y и просто z.
[26:19.860 --> 26:21.860]  Это политический код?
[26:21.860 --> 26:24.860]  Да, это политический код. Просто какой-то примерчик.
[26:24.860 --> 26:29.860]  Примеров там же не было, ничего подобного. By-ref, оно само как-то...
[26:29.860 --> 26:35.860]  Ну, by-ref, это же мы сами просто что-то имплементировали, просто чтобы его повызывать как-то там.
[26:35.860 --> 26:37.860]  Наш тип t.
[26:39.860 --> 26:40.860]  Вот.
[26:40.860 --> 26:43.860]  Ну структура closure соответственно будет примерно такая.
[26:47.860 --> 26:52.860]  Ну там fn once будет как-то имплементирован, потому что у нас z это владеющий тип.
[26:53.860 --> 26:58.860]  И когда мы будем создавать эту closure, ну там компилятор за нас ставит нужный код,
[26:58.860 --> 27:02.860]  он создает наш environment вот с такими вот параметрами.
[27:02.860 --> 27:05.860]  Ну перед тем, как... В тот момент, когда вы будете создавать closure.
[27:06.860 --> 27:15.860]  А, то есть это означает, что в том примере кода z, оно во всех трех местах будет в копии из environment?
[27:15.860 --> 27:17.860]  Даже не копия, а мувница внутрь.
[27:18.860 --> 27:21.860]  То есть, смотри, когда ты будешь создавать себя, z будет z и scope.
[27:21.860 --> 27:24.860]  То есть оно мувница в closure в момент создания.
[27:24.860 --> 27:26.860]  Компилятор кто будет знать?
[27:26.860 --> 27:29.860]  Когда ты возьмешь мутабельную ссылку, если ты не будешь использовать closure,
[27:29.860 --> 27:33.860]  а дальше попробуешь еще что-то по мутабельной ссылке сделать, компилятор на тебя пожалуется.
[27:33.860 --> 27:38.860]  Скажет, что у тебя здесь мутабелл боровый, и здесь ты пытаешься еще один мутабелл боровый сделать, например.
[27:39.860 --> 27:44.860]  Ну то есть он все это трекает, соответственно, по всем правилам раста.
[27:44.860 --> 27:46.860]  Все работает очень банально.
[27:49.860 --> 27:54.860]  Ну вот если вы попробуете, раз что fn once имплементировали, попробуете ее дважды вызвать,
[27:54.860 --> 27:58.860]  то у вас это не получится, потому что z вы внутрь замували,
[27:58.860 --> 28:00.860]  и никак вызвать closure дважды не получится.
[28:02.860 --> 28:05.860]  Ну это логично, потому что у вас внутри какой-то боевой бью кол,
[28:05.860 --> 28:10.860]  у вас z мувница после первого вызова, и во время второго вызова вы уже ничего сделать не сможете.
[28:10.860 --> 28:12.860]  То есть z у вас просто нет, не существует.
[28:18.860 --> 28:24.860]  Поэтому вот тому, как раст определяет, как он захватит применное, понятно?
[28:25.860 --> 28:30.860]  Он захватывает минимальным необходимым образом, то есть по ссылке, мутабельной ссылке или по значению,
[28:30.860 --> 28:34.860]  в соответствии с тем, как вы пользуетесь внутри своими переменами.
[28:38.860 --> 28:43.860]  Ну и fn соответственно имплементирует тот, который соответствует тому, как вы захватили перемену.
[28:45.860 --> 28:50.860]  Ну смотрите, у нас здесь есть такой примерчик, что если мы хотим вернуть положение.
[28:51.860 --> 28:58.860]  У нас, например, есть здесь мой кадр, который принимает на вход x и возвращает какую-то функцию,
[28:58.860 --> 29:03.860]  которая прибавляет x к еще какому-то своему аргументу.
[29:03.860 --> 29:08.860]  Вот видите, вот в fn main я создаю эту closure, которая с тройкой будет.
[29:08.860 --> 29:13.860]  Если я вызову f1, то это будет 4, а если f10, то это 13.
[29:14.860 --> 29:18.860]  Самая интересная конечно здесь часть, это импл fn i32 в i32.
[29:18.860 --> 29:23.860]  Когда мы пишем импл, компилятор понимает, что возвращаемое значение должно быть каким-то таким типом.
[29:24.860 --> 29:30.860]  Ну и компилятор соответственно там подставляет какой-то свой компиляторный тип, и вы можете вернуть closure.
[29:31.860 --> 29:36.860]  В терминах плюсов вам понадобится использовать std function, то есть это была бы локация на стеке.
[29:37.860 --> 29:45.860]  Несмотря на то, что лямбды работают точно так же, как и closure, то есть там по сути структурка тоже все точно так же.
[29:45.860 --> 29:54.860]  А также, если вы хотите closure откуда-то вернуть, то вам нужно использовать std function для того, чтобы она хранила ваше closure.
[29:55.860 --> 30:00.860]  Вообще достаточно просто использовать авто, если надо пошло.
[30:01.860 --> 30:03.860]  Авто в ретурне, не мешайте.
[30:04.860 --> 30:06.860]  Ну типа да, сделать возвращаемый тип выводимый.
[30:07.860 --> 30:12.860]  Тут то же самое, тут вывод типа на сканскрайне видит дрейт.
[30:13.860 --> 30:14.860]  А это точно будет работать в плюсах?
[30:15.860 --> 30:16.860]  Авто на лямбды.
[30:17.860 --> 30:21.860]  Просто это немножко особенный тип по сравнению с окружающими.
[30:22.860 --> 30:27.860]  Ты про то, что будет ли работать попытка вернуть лямбду из функции, если пометить?
[30:28.860 --> 30:31.860]  Да, мне почему-то кажется, что кого-то не сработает.
[30:32.860 --> 30:33.860]  По-моему должно работать.
[30:34.860 --> 30:35.860]  Мы можем потом проверить.
[30:36.860 --> 30:37.860]  Окей.
[30:38.860 --> 30:39.860]  Так.
[30:40.860 --> 30:42.860]  Ну да, еще кстати говоря, видите импл?
[30:43.860 --> 30:48.860]  И здесь вот если вы попробуете это на самом деле скомпилировать, то в таком случае у вас возникнет такая проблема.
[30:49.860 --> 30:51.860]  Расскажет, что х внутри недостаточно много живет.
[30:52.860 --> 30:55.860]  Потому что closure может пережить собственно сам х.
[30:56.860 --> 31:00.860]  Х, заметьте, он, да, смотрите х, он здесь вот владеющий.
[31:02.860 --> 31:06.860]  Здесь вот вы для того, чтобы сделать плюс, вам достаточно ссылки.
[31:07.860 --> 31:11.860]  Ложе соответственно имплементирует fn, возьмет х по ссылке.
[31:12.860 --> 31:17.860]  Кто бы сядет сюда выходить из этого скопа, то в таком случае у вас х, ну он уже дропнется.
[31:18.860 --> 31:24.860]  Ну да, это в данном случае и 32, но если бы это была какая-то более сложная структурка, которая не копия даже, то это было бы даже очевиднее.
[31:25.860 --> 31:28.860]  У вас дропнется х и соответственно ссылка станет неволидной.
[31:29.860 --> 31:31.860]  Это ссылка на какую-то переменную на стеке, которую уже нет.
[31:32.860 --> 31:35.860]  Раз это ловит, говорит, что так.
[31:35.860 --> 31:36.860]  Так.
[31:37.860 --> 31:38.860]  Сейчас подождем.
[31:43.860 --> 31:52.860]  Вот, у нас здесь вот х, так как дропнется, у нас тараст вылавливает и говорит, что так нельзя, нельзя возвращать такое в closure.
[31:53.860 --> 31:57.860]  Если же вы хотите все-таки вернуть такое closure, то вам нужно использовать ключевое слово move.
[31:58.860 --> 32:02.860]  Move говорит, что все, что вы будете использовать внутри closure, нужно именно замувать внутрь.
[32:03.860 --> 32:06.860]  То есть строго все замувать, не брать никаких ссылок, ничего.
[32:07.860 --> 32:18.860]  Это полезно, например, когда вы как раз возвращаете closures, когда у вас речь про всякую многопоточность, вы там создаете какие-то объекты, например, на стеке, а потом внутрь их move и идти к новому 32, например.
[32:19.860 --> 32:21.860]  Потом вы видите более конкретно примеры.
[32:21.860 --> 32:31.860]  Это ключевое слово означает, возьми все из scope, именно как владеющее, то есть move не внутрь.
[32:32.860 --> 32:34.860]  Это к closure.
[32:35.860 --> 32:37.860]  Это, ну да.
[32:38.860 --> 32:40.860]  Это конкретно к самим значениям, которые находятся на scope.
[32:41.860 --> 32:42.860]  Они будут муваться внутрь closure.
[32:43.860 --> 32:45.860]  Сейчас я, наверное, даже покажу более конкретный пример.
[32:46.860 --> 32:49.860]  Это не тот move, про который есть EDMove или что-то такое.
[32:49.860 --> 32:50.860]  Немножко другое.
[32:51.860 --> 32:52.860]  Имейте в виду.
[32:53.860 --> 32:57.860]  Вы можете выполнить наш пример, который совсем еще недавно был.
[32:59.860 --> 33:01.860]  В принципе, environment будет вот такой вот.
[33:02.860 --> 33:03.860]  Если вы сделаете move.
[33:04.860 --> 33:06.860]  То есть, заметьте, я написал closure, move.
[33:07.860 --> 33:09.860]  То есть, здесь до этого не было move, а теперь появился.
[33:10.860 --> 33:11.860]  Environment теперь стал вот таким.
[33:12.860 --> 33:13.860]  Все по Т.
[33:15.860 --> 33:17.860]  Ну как вы можете понять, что это такое?
[33:17.860 --> 33:21.860]  Ну как вы можете понять, в Rust нет такого контроля, как в плюсах.
[33:22.860 --> 33:26.860]  Там очень-очень точно, что мы там возьмем по ссылке, что скопируем, что мувим.
[33:27.860 --> 33:28.860]  Могли указывать, а здесь нет такого.
[33:29.860 --> 33:33.860]  Но правда в том, что правил Rust на практике достаточно.
[33:34.860 --> 33:40.860]  Если вам хочется что-то более конкретное, то я вам даже могу сказать такую штуку.
[33:41.860 --> 33:43.860]  На крейт SEO есть такой крейт, называется closure.
[33:43.860 --> 33:48.860]  И он позволяет с помощью макроса брать именно такой fine-grained control.
[33:49.860 --> 33:52.860]  То есть, сказать, что возьмете по ссылке, что по мутабельной ссылке, что по значению.
[33:54.860 --> 33:57.860]  Правда в том, что у этого крейта всего лишь 11 тысяч скачиваний,
[33:58.860 --> 34:00.860]  против какого-нибудь стока, у которого 50 миллионов скачиваний.
[34:01.860 --> 34:03.860]  Поэтому, скорее всего, это никому не нужно.
[34:04.860 --> 34:07.860]  И в итоге то, что в плюсах там есть очень конкретный контроль,
[34:08.860 --> 34:11.860]  он, наверное, просто бесполезен на практике.
[34:13.860 --> 34:20.860]  Так, еще важный момент.
[34:21.860 --> 34:23.860]  У каждой closures разный тип, даже если они вообще одинаковые.
[34:24.860 --> 34:27.860]  Смотрите, у нас есть даже тут и функции, и closures.
[34:28.860 --> 34:30.860]  Можете такой примерчик сейчас посмотреть, пока я попью чуть-чуть.
[34:43.860 --> 34:46.860]  Тут у нас есть две функции какие-то абсолютно одинаковые,
[34:47.860 --> 34:52.860]  которые принимают на вход X и две closures, которые возвращают просто единички.
[34:56.860 --> 35:00.860]  И у всех этих IDM разный тип, абсолютно у всех.
[35:01.860 --> 35:03.860]  Даже несмотря на то, что это одинаковые функции.
[35:05.860 --> 35:08.860]  Более того, есть пример снизу, что если вы захотите все запихать вектор,
[35:09.860 --> 35:11.860]  то у вас не получится, потому что у всего этого разный тип.
[35:11.860 --> 35:16.860]  Вот make closure возвращает какую-то лямбду, которая просто берет n и возвращает n.
[35:17.860 --> 35:20.860]  Если вы возьмете make closure и make closure, то у вас это скомпилируется,
[35:21.860 --> 35:23.860]  потому что у вас это одинаковая лямбда с одним и тем же типом.
[35:24.860 --> 35:26.860]  Вы возвращаете одну и ту же лямбду здесь и здесь.
[35:30.860 --> 35:31.860]  Да, они просто разные моменты создались.
[35:32.860 --> 35:35.860]  А вот здесь вот именно две разные лямбды, потому что они в двух разных местах сделаны.
[35:36.860 --> 35:38.860]  То есть каждая лямбда, она разная.
[35:38.860 --> 35:39.860]  Так, вот был вопрос.
[35:40.860 --> 35:42.860]  У нас все же в расте такой зерокост.
[35:43.860 --> 35:45.860]  Здесь у нас вроде бы какие-то мувы происходят.
[35:47.860 --> 35:49.860]  Что-то с виду дорогое.
[35:50.860 --> 35:52.860]  Но на самом деле это конечно не так.
[35:53.860 --> 35:55.860]  Потому что на самом деле компилятор знает, как вы всем этим пользуетесь.
[35:56.860 --> 35:58.860]  Структурка на стэке находится.
[35:59.860 --> 36:01.860]  Если вы возвращаете, вы можете вернуть на стэке, как вы увидели,
[36:02.860 --> 36:04.860]  написать имплэлфэн и у вас остается.
[36:04.860 --> 36:05.860]  Все очень быстро.
[36:06.860 --> 36:08.860]  Ну и это на самом деле очень классно,
[36:09.860 --> 36:13.860]  потому что компилятор всякие, если вы напишете век, итер, мэп,
[36:14.860 --> 36:16.860]  эти штуки все заинлайнятся.
[36:17.860 --> 36:19.860]  Во-первых, во-вторых, они там викторизоваться будут.
[36:20.860 --> 36:22.860]  То есть это все очень быстро работает.
[36:23.860 --> 36:26.860]  И поэтому клоузжа это действительно зерокост абстракшн.
[36:27.860 --> 36:29.860]  Ну и это все очень классно.
[36:30.860 --> 36:33.860]  И поэтому клоузжа это действительно зерокост абстракшн.
[36:38.860 --> 36:40.860]  Вот как-то так получается.
[36:42.860 --> 36:44.860]  Какой вопрос, мы делали мув,
[36:45.860 --> 36:48.860]  потому что он не мог предсказать lifetime.
[36:49.860 --> 36:51.860]  А я мог ему предсказать lifetime?
[36:52.860 --> 36:54.860]  Нет, он же знает, что X дропается.
[36:55.860 --> 36:57.860]  Ты ему не мог никакой lifetime предсказать.
[36:57.860 --> 37:00.860]  А, да, поскольку у него посылки нет.
[37:01.860 --> 37:03.860]  Ну и более того, там нет такого контроля,
[37:04.860 --> 37:06.860]  и он не нужен на самом деле.
[37:09.860 --> 37:11.860]  Ну в общем плюсах, в принципе,
[37:12.860 --> 37:14.860]  лианды работают точно так же,
[37:15.860 --> 37:17.860]  за исключением одного момента, который называется std-фанкшн,
[37:18.860 --> 37:20.860]  и который, например, в курсе Рома Липовского
[37:21.860 --> 37:23.860]  просто переписан на какой-то уник-фанкшн.
[37:24.860 --> 37:26.860]  Я сейчас даже забыл причину конкретную.
[37:27.860 --> 37:29.860]  У него есть мув вон ли колбеки?
[37:30.860 --> 37:32.860]  Да, мув вон ли колбеки.
[37:33.860 --> 37:35.860]  Вот примерно что-то такое.
[37:36.860 --> 37:38.860]  Ну не знаю, это претензию не к плюсам,
[37:39.860 --> 37:41.860]  а к стандартной библиотеке.
[37:42.860 --> 37:44.860]  Ну это все-таки к плюсам, потому что это std.
[37:45.860 --> 37:47.860]  То есть если ты придешь в плюсы,
[37:48.860 --> 37:50.860]  то тебе придется писать что-то свое, если тебе захочется.
[37:51.860 --> 37:53.860]  Вместо того, чтобы в стандартной библиотеке пользоваться.
[37:54.860 --> 37:56.860]  Соответственно, это как-то не унифицирует между собой код,
[37:57.860 --> 37:59.860]  это хранение.
[38:00.860 --> 38:02.860]  Давайте еще сейчас скажу.
[38:03.860 --> 38:05.860]  std-фанкшн тлов, потому что он внутри
[38:06.860 --> 38:08.860]  использует локацию на хиппе,
[38:09.860 --> 38:11.860]  то есть там точно такой же фетпоинтер.
[38:12.860 --> 38:14.860]  Конечно, на практике там используется еще SO.
[38:15.860 --> 38:17.860]  Small Object Optimization.
[38:18.860 --> 38:20.860]  Но это не всегда работает.
[38:21.860 --> 38:23.860]  И зависит от use-case.
[38:24.860 --> 38:26.860]  В Rust все closures локируются на стеке.
[38:27.860 --> 38:29.860]  И если вы хотите стд-фанкшн,
[38:30.860 --> 38:32.860]  то используйте box-din-fn.
[38:33.860 --> 38:35.860]  И заметьте, что это очень хорошо абстрагирует.
[38:36.860 --> 38:38.860]  И стд-фанкшн как-то совсем ничего не говорит
[38:39.860 --> 38:41.860]  по сравнению с box-din-fn, что на самом деле происходит
[38:42.860 --> 38:44.860]  в этом объекте. Box-din-fn говорит,
[38:45.860 --> 38:47.860]  я там динамически храню, то есть у меня там какой-то
[38:48.860 --> 38:50.860]  трейд-объект fn, который можно вызвать.
[38:51.860 --> 38:53.860]  Вот это как раз уже еник-фанкшн получился.
[38:54.860 --> 38:56.860]  Box-это же exclusive ownership.
[38:57.860 --> 38:59.860]  То есть ты имеешь в виду, что
[39:00.860 --> 39:02.860]  можно и rss-ку написать.
[39:03.860 --> 39:05.860]  Это просто придергка, что не совсем одинаково.
[39:06.860 --> 39:08.860]  На самом деле это круто, потому что мы просто
[39:09.860 --> 39:11.860]  взяли и собрали еник-фанкшн с того, что есть.
[39:12.860 --> 39:14.860]  Ну да, мне это тоже очень нравится.
[39:15.860 --> 39:17.860]  То, что в Rust эти абстракции очень хорошо
[39:18.860 --> 39:20.860]  друг на друга накладываются, как будто мы пишем
[39:21.860 --> 39:23.860]  в каком-то функциональном языке с чистыми математическими абстракциями.
[39:24.860 --> 39:26.860]  И при этом это красиво и практично.
[39:27.860 --> 39:29.860]  А если говорить про closures, есть какие-то вопросы?
[39:34.860 --> 39:36.860]  Кажется, это должна быть достаточно простая тема.
[39:37.860 --> 39:39.860]  Потому что вы все знаете список.
[39:44.860 --> 39:46.860]  Давайте поговорим про метапрограммирование.
[39:47.860 --> 39:49.860]  Я так понимаю, в этой аудитории
[39:50.860 --> 39:52.860]  только один человек проходил курс про метапрограммирование.
[39:53.860 --> 39:55.860]  Это так?
[39:55.860 --> 39:57.860]  Ну ладно, я себя отрезаю.
[40:04.860 --> 40:06.860]  Знают ли слушатели курса по-раз,
[40:07.860 --> 40:09.860]  что такое метапрограммирование?
[40:10.860 --> 40:13.860]  У нас на плюсах были немножко всякие
[40:14.860 --> 40:16.860]  enable if максимум.
[40:17.860 --> 40:19.860]  Элементы метапрограммирования.
[40:20.860 --> 40:22.860]  Причем не самые красивые.
[40:22.860 --> 40:24.860]  Поэтому приходите в четвертом курсе
[40:25.860 --> 40:27.860]  на метапрогу, если она будет.
[40:28.860 --> 40:30.860]  Она должна быть лучше.
[40:31.860 --> 40:33.860]  Мне, если честно, метапрограммирование не понравилось
[40:34.860 --> 40:36.860]  на плюсах совсем.
[40:37.860 --> 40:39.860]  Вы поймете, почему мне она не понравилась,
[40:40.860 --> 40:42.860]  когда вы видите макросы.
[40:43.860 --> 40:45.860]  Макросы более сильный инструмент и удобный.
[40:46.860 --> 40:48.860]  Метапрограммирование – это код, который генерирует код,
[40:49.860 --> 40:51.860]  просто говоря.
[40:52.860 --> 40:54.860]  Есть всякие языки программирования.
[40:55.860 --> 40:57.860]  Я в них не разбираюсь, вроде BML или Lisp.
[40:58.860 --> 41:00.860]  Я, чтобы не соврать, не буду точно говорить.
[41:01.860 --> 41:03.860]  Где есть всякие инструменты, которые позволяют
[41:04.860 --> 41:06.860]  коду модифицировать самого себя в runtime.
[41:07.860 --> 41:10.860]  Это, конечно, прикольно, но кажется, не очень нужно.
[41:11.860 --> 41:13.860]  Мы вместо этого сфокусируемся на примере
[41:14.860 --> 41:16.860]  кода, который генерирует код.
[41:17.860 --> 41:19.860]  То есть более узким, в таком смысле, метапрограммирование,
[41:19.860 --> 41:21.860]  которое в плюсах реализовано на темплейтах
[41:22.860 --> 41:24.860]  и в расте, как мы видим, реализовано на макросах.
[41:25.860 --> 41:27.860]  Примерно понятно, что значит код генерирует код.
[41:28.860 --> 41:30.860]  А уже текст программ будет?
[41:31.860 --> 41:33.860]  Да.
[41:34.860 --> 41:36.860]  В смысле плюсов это были бы какие-то типы.
[41:39.860 --> 41:41.860]  Вот.
[41:42.860 --> 41:44.860]  Когда нам нужно метапрограммирование?
[41:45.860 --> 41:47.860]  Когда я лень писать.
[41:48.860 --> 41:50.860]  Ну, метапрограммирование, смотри.
[41:51.860 --> 41:53.860]  Раз, что код генерирует код, то первое, что хочется с ним сделать,
[41:54.860 --> 41:56.860]  скорее всего, сделать так, чтобы код сделал за тебя всю грязную работу.
[41:57.860 --> 41:59.860]  Всякие boilerplate, наверное.
[42:00.860 --> 42:02.860]  Это как минимум.
[42:03.860 --> 42:05.860]  Потом, в случае плюсов, есть всякие хаки, которые позволяют
[42:06.860 --> 42:08.860]  выбирать имплементации и все такое.
[42:09.860 --> 42:11.860]  В расте, кстати, тоже есть.
[42:12.860 --> 42:14.860]  Там называется trade specialization.
[42:14.860 --> 42:16.860]  Я надеюсь, у нас в Домашке будет на этой задачке.
[42:17.860 --> 42:19.860]  На следующей неделе.
[42:20.860 --> 42:22.860]  Еще всякие оптимизации.
[42:23.860 --> 42:25.860]  При калькуляции всяких значений, табличек.
[42:26.860 --> 42:28.860]  Там можно, например, идеальные хэш-таблицы делать в compile-time.
[42:29.860 --> 42:31.860]  С помощью этого программирования.
[42:32.860 --> 42:34.860]  Вы заранее знаете список значений, по которым вы будете по ключам идти.
[42:35.860 --> 42:37.860]  Соответственно, вы можете сделать в compile-time идеальную хэш-таблицу,
[42:38.860 --> 42:40.860]  которая будет все делать за вот единицу без коллегии.
[42:41.860 --> 42:43.860]  Вот.
[42:44.860 --> 42:46.860]  Ну и всякие другие можно оптимизации придумать.
[42:47.860 --> 42:50.860]  Например, сгенерировать заранее всякие таблички
[42:51.860 --> 42:53.860]  для каких-нибудь алгоритмов.
[42:54.860 --> 42:56.860]  Это алгоритм зависит, конечно.
[42:57.860 --> 43:02.860]  Например, алгоритмом всякие хэширования, разные таблички могут требовать.
[43:03.860 --> 43:05.860]  В зависимости от input-параметров.
[43:06.860 --> 43:08.860]  И поэтому их можно сгенерировать с помощью средств метапрограммирования.
[43:09.860 --> 43:11.860]  Вот.
[43:11.860 --> 43:13.860]  Ну, можно вставить части исходников прямо...
[43:14.860 --> 43:17.860]  Ну, какие-то данные из файлов прямо в исходный код программы.
[43:18.860 --> 43:21.860]  Например, если вам нужно вставить какую-то картинку прямо в исходный файл.
[43:22.860 --> 43:24.860]  Это иногда бывает полезно.
[43:25.860 --> 43:27.860]  Если вам хочется, чтобы все быстро работало и чтобы вам не...
[43:28.860 --> 43:31.860]  Ну, даже не быстро работало, чтобы клиенту дать только один бинарник, например.
[43:32.860 --> 43:36.860]  Вместо того, чтобы давать папку, в которой будет бинарник и какие-то картинки лежат.
[43:37.860 --> 43:39.860]  Чисто для примера.
[43:39.860 --> 43:41.860]  Так, ну, про boilerplate код мы сказали.
[43:42.860 --> 43:45.860]  Например, там если что-то очень часто повторяется, можно вместо этого сделать ползу,
[43:46.860 --> 43:48.860]  которая будет сдавать что-то генерировать.
[43:49.860 --> 43:51.860]  Или, например, диасельки.
[43:52.860 --> 43:54.860]  Диасельки это особенно...
[43:55.860 --> 44:00.860]  Особенно такая важная ерунда, когда мы говорим про всякие вещи, связанные с фронтэндом.
[44:01.860 --> 44:04.860]  Я тут не сильно разбираюсь, что это, потому что я не фронтэндов разработчик,
[44:05.860 --> 44:07.860]  но кажется, что это не фронтэндов.
[44:07.860 --> 44:09.860]  Я не фронтэндов разработчик, но кажется, что те,
[44:10.860 --> 44:12.860]  кто разрабатывает на таких больше бэкэндовых языках,
[44:13.860 --> 44:15.860]  то у них обязательно какие-то диасельки допоявляются,
[44:16.860 --> 44:18.860]  для того чтобы проще всякие разметки делать и все такое.
[44:19.860 --> 44:24.860]  Например, там JetBrains, я знаю, используют для ID-шек своих специально диасельки.
[44:30.860 --> 44:32.860]  Что ж, ну, какие у нас есть средства метапрограммирования в плюсах?
[44:33.860 --> 44:35.860]  У нас есть такие два главных средства.
[44:35.860 --> 44:38.860]  Это template-metaprogramming и defined AC.
[44:41.860 --> 44:44.860]  Ну, template в плюсах – это такая тюрем полная вещь,
[44:45.860 --> 44:49.860]  с помощью которой можно писать компилятор на C++, на C++-templates.
[44:50.860 --> 44:53.860]  Если сильно захотеть, то можно, только никому это не нужно.
[44:56.860 --> 44:58.860]  Ну, еще тут важное замечание на слайде есть,
[44:59.860 --> 45:01.860]  что вы можете написать любую программу в математическом смысле.
[45:02.860 --> 45:04.860]  То есть она из любого input может сделать любой output.
[45:05.860 --> 45:07.860]  Например, в более практическом смысле, например,
[45:08.860 --> 45:10.860]  сходить в базу данных, добыть какую-то строчку из таблички,
[45:11.860 --> 45:12.860]  вы, конечно, с помощью template-ов не сможете.
[45:13.860 --> 45:15.860]  Это нужно делать, например, на уровне системы сборки.
[45:17.860 --> 45:19.860]  Потому что плюсы так не умеют просто.
[45:22.860 --> 45:25.860]  Ну, и, наверное, если вы уже пользовались как-то template-ами,
[45:26.860 --> 45:28.860]  то вы могли заметить, что это какая-то такая джедайская техника,
[45:29.860 --> 45:31.860]  достаточно сложная, ее достаточно сложно изучать.
[45:32.860 --> 45:34.860]  Более того, она еще и редко применяется.
[45:35.860 --> 45:37.860]  То есть бывают такие случаи, когда нужно,
[45:38.860 --> 45:40.860]  но обычно обходится без метапрограммирования.
[45:42.860 --> 45:44.860]  Еще есть припроцессор Define.
[45:45.860 --> 45:47.860]  У него такая проблема.
[45:48.860 --> 45:51.860]  Дело в том, что он работает на уровне файла исходного кода.
[45:52.860 --> 45:54.860]  То есть он ничего не знает про то, что лежит в этом файле.
[45:55.860 --> 45:57.860]  Он просто берет и в тупую, и в глупую,
[45:58.860 --> 46:00.860]  меняет все обхождения какого-то слова,
[46:01.860 --> 46:03.860]  ну, паттерна, на то, что вы укажете.
[46:05.860 --> 46:06.860]  Вот.
[46:07.860 --> 46:09.860]  Ну, это, с одной стороны, это удобно бывает,
[46:10.860 --> 46:13.860]  но с другой стороны, за счет этого могут выстрелить самые рандомные ошибки,
[46:14.860 --> 46:16.860]  где у вас там, например, какая-нибудь скобочка куда-то пропала,
[46:17.860 --> 46:19.860]  или, не знаю, там Define-ы пересеклись,
[46:20.860 --> 46:22.860]  и в итоге у вас получается какая-то очень стрёмная ошибка в компиляции.
[46:23.860 --> 46:26.860]  Просто потому что у вас там в Includes как-то очень стрёмно Define-ы лежат.
[46:27.860 --> 46:29.860]  В общем, это такая небезопасная вещь,
[46:30.860 --> 46:32.860]  которую нужно пользоваться с осторожностью.
[46:33.860 --> 46:35.860]  Как-то так.
[46:36.860 --> 46:38.860]  Знакомы с этими инструментами?
[46:41.860 --> 46:43.860]  Ну, как-то так.
[46:44.860 --> 46:46.860]  Что же у нас в Raster?
[46:47.860 --> 46:49.860]  У нас, на самом деле, конечно, больше, чем макросы есть,
[46:50.860 --> 46:52.860]  но мы будем на лекциях изучать только макросы,
[46:53.860 --> 46:55.860]  потому что их, в принципе, достаточно для всяких юс-кейсов,
[46:56.860 --> 46:58.860]  а для большего, ну, это, наверное, какие-то приколы,
[46:59.860 --> 47:01.860]  например, то, что есть ссылка к снизу,
[47:03.860 --> 47:05.860]  макросы это супер мощная вещь.
[47:06.860 --> 47:08.860]  Это вплоть до того, что вы можете брать просто
[47:09.860 --> 47:11.860]  в произвольной последовательности токенов и превращать в произвольный Rust-код.
[47:12.860 --> 47:14.860]  Причём, по сути, это Rust-код, который генерирует Rust-код.
[47:15.860 --> 47:17.860]  Вам ничего не мешает в макросах читать файлы,
[47:18.860 --> 47:20.860]  ходить в сеть, там, не знаю,
[47:21.860 --> 47:23.860]  биткоины майнить на компьютере того,
[47:24.860 --> 47:26.860]  кто компилирует ваш код в собственной библиотеке.
[47:27.860 --> 47:29.860]  Ну, там есть какие-то, конечно, защиты от этого.
[47:29.860 --> 47:31.860]  Да, да, вот есть там какие-то сподвижки
[47:32.860 --> 47:34.860]  на то, чтобы сделать макросы более безопасными.
[47:35.860 --> 47:37.860]  В целом, конечно, можете не беспокоиться в упенсорсных библиотеках,
[47:38.860 --> 47:40.860]  что такое появится, ну, потому что не появится.
[47:41.860 --> 47:44.860]  Просто это всё очень в большом числом людей просматривается.
[47:45.860 --> 47:47.860]  Но вообще, в целом, будьте аккуратны с тем,
[47:48.860 --> 47:50.860]  чтобы компилировать произвольный Rust-код,
[47:51.860 --> 47:53.860]  потому что он может прямо что-то сломать.
[47:54.860 --> 47:56.860]  Да, и украсть там пароли и всё такое.
[47:56.860 --> 47:58.860]  На самом деле, в Rust можно всякую магию делать на трейтах и объектах.
[47:59.860 --> 48:02.860]  Ну, там, то есть, generic metaprogramming, всякие трейты объявлять прикольные.
[48:03.860 --> 48:05.860]  И так как это всё делает Turing полно,
[48:06.860 --> 48:08.860]  то в таком случае, вы можете писать тоже код,
[48:09.860 --> 48:11.860]  как вы хотите.
[48:12.860 --> 48:14.860]  Ну, в общем-то, да.
[48:15.860 --> 48:17.860]  Ну, в общем-то, да.
[48:18.860 --> 48:20.860]  Ну, в общем-то, да.
[48:21.860 --> 48:23.860]  Ну, в общем-то, да.
[48:24.860 --> 48:25.860]  Ну, в общем-то, да.
[48:26.860 --> 48:29.860]  Так что juste inauguration城 ana и, как и в плюсах, произвольный код.
[48:30.860 --> 48:32.860]  Более того, я вам скинул здесь два примерчика.
[48:33.860 --> 48:35.860]  Это вот на русском.
[48:36.860 --> 48:38.860]  От одного человека, который написал fist vive в compile time.
[48:39.860 --> 48:41.860]  Достаточно простая и при этом прикольная статья.
[48:42.860 --> 48:44.860]  А вторая она про то, что, там, «не помню, какой точно язык»,
[48:45.860 --> 48:47.860]  «какой-то язык Тюринг полный имплементируется на системе типа в Rust»,
[48:48.860 --> 48:51.860]  соответственно, доказывают, что система типа в Rust-а тюринг полна.
[48:52.860 --> 48:54.360]  То есть, эта статья, по- сути, сделана для того, чтобы доказать,
[48:54.360 --> 48:56.360]  Раста полна
[49:01.320 --> 49:03.320]  Все, мы закончили наш интро
[49:03.320 --> 49:05.320]  Надеюсь, вы поняли, что такое это программирует
[49:08.560 --> 49:11.280]  Ну давайте перейдем тогда к декларативным макросам
[49:12.800 --> 49:15.520]  Давайте перед тем, как мы перейдем, посмотрим такую мощь
[49:15.520 --> 49:17.520]  Смотрите, просто взяли произвольный синтез
[49:17.520 --> 49:19.520]  Запихали просто JSON в Rast код
[49:20.440 --> 49:22.440]  Это такой крейд, называется cert
[49:23.400 --> 49:25.400]  Про который мы уже говорили, кстати, в какой-то раз
[49:26.920 --> 49:31.560]  Он предназначен для того, чтобы всякие форматы серилизовывать и десерилизовывать
[49:31.560 --> 49:33.560]  Ну как вы можете заметить, это название даже CRD
[49:35.560 --> 49:43.000]  Собственно, в CRD JSON есть такой макрос, который позволяет вставлять JSON прямо в код
[49:44.200 --> 49:49.360]  В какой-то момент, даже в ровере, вместо того, чтобы использовать мультипарт в request
[49:50.240 --> 49:53.240]  Использовался просто JSON и отправлялся как строчка
[49:53.240 --> 49:55.240]  Это все прекрасно работало
[49:55.240 --> 50:01.240]  Ну то есть, я использовал CRD JSON, а потом просто вспомнил, ага, точно, тут есть мультипарт, можно воспользоваться
[50:05.240 --> 50:09.240]  Ну давайте посмотрим на то, как вообще их писать
[50:09.240 --> 50:13.240]  Смотрите, вот мы создаем вектор и делаем push push push единички
[50:15.240 --> 50:19.240]  Такс, ну нам хочется это как-то сократить, да, это какой-то boilerplate
[50:20.240 --> 50:22.240]  Ну давайте напишем макрос на это
[50:23.240 --> 50:26.240]  Ну то есть, он выглядит так в стандартной библиотеке
[50:26.240 --> 50:30.240]  Тут, например, единичка три раза или вот вектор из трех единичек
[50:30.240 --> 50:33.240]  Мы уже наверняка пользовались домашней этой штукой
[50:38.240 --> 50:40.240]  Так, ну что ж
[50:43.240 --> 50:44.240]  Страшно, да?
[50:44.240 --> 50:49.240]  Ну что ж, мы сейчас будем по частям разбирать вообще все непонятные моменты, что есть в этом макросе
[50:50.120 --> 50:54.120]  То есть, не пугайтесь, это далеко не последний слайд конкретно CreateVec, мы будем его постепенно рассматривать
[50:56.120 --> 50:58.120]  Итак, макросы декларативные
[50:58.120 --> 51:02.120]  У нас объявляется с помощью ключевого слова macro-rules
[51:02.120 --> 51:06.120]  Из себя оно тоже представляет макрос, но только специально для компилятора
[51:10.120 --> 51:14.120]  Кстати, вы когда смотрите на этот макрос, даже интересно, вы примерно понимаете, что в нем происходит?
[51:15.000 --> 51:21.000]  Ну это выглядит как pattern matching, что в зависимости от того, что написано после макроса, мы генерируем нужды нам кожи
[51:21.000 --> 51:25.000]  Да, а Маш, чуть-чуть конкретнее рассказать, что происходит в строчке
[51:25.000 --> 51:27.000]  Ну вот у нас CreateVec
[51:27.000 --> 51:31.000]  У нас был вот до этого Vec, который на стандартной библиотеке в двух формах
[51:31.000 --> 51:38.000]  И здесь нас подчислили обе формы за implementation, то есть сначала там элементы и сколько раз он должен повториться
[51:38.880 --> 51:43.880]  Ну, это конвертированный код, который делает new, resize
[51:43.880 --> 51:47.880]  Ну да, и resize он заполняет этот вектор
[51:47.880 --> 51:53.880]  На втором случае мы о чем-то не делаем, да?
[51:53.880 --> 51:56.880]  Ну мы про это поговорим, кстати
[51:56.880 --> 51:59.880]  Ну это пока что без резервов просто
[51:59.880 --> 52:01.880]  Вот здесь вот повторяется push
[52:01.880 --> 52:03.880]  Ну да, мы не знаем, во сколько, да
[52:03.880 --> 52:07.880]  Ну пока что мы просто push
[52:07.880 --> 52:10.880]  А потом у нас будет прорезерв
[52:10.880 --> 52:13.880]  Итак, с этим понятно
[52:13.880 --> 52:16.880]  Давайте посмотрим на частично удаленный код
[52:16.880 --> 52:20.880]  У нас есть CreateVec, который выглядит
[52:20.880 --> 52:22.880]  Ну вообще CreateVec сам себя выглядит как янам
[52:22.880 --> 52:25.880]  Какая-то часть слева, потом стрелочка, какая часть правого
[52:25.880 --> 52:28.880]  Часть слева называется matcher
[52:28.880 --> 52:32.880]  То есть это то, какой паттерн мы берем
[52:32.880 --> 52:37.880]  Ну, слева в общем паттерн, на котором мы пытаемся смачиться
[52:37.880 --> 52:40.880]  Вот здесь можно заметить первое паттерн это какое-то выражение
[52:40.880 --> 52:44.880]  Потом точка запятой, еще одно какое-то выражение
[52:44.880 --> 52:49.880]  В втором случае у нас будет здесь написано, что повторите какое-то выражение
[52:49.880 --> 52:52.880]  Через запятую произвольное число раз, ноль или больше
[52:54.880 --> 52:56.880]  Так, да
[52:56.880 --> 52:59.880]  То, что справа называется transcribers
[52:59.880 --> 53:02.880]  Это такие определения, которые не везде всплывают, но они есть
[53:02.880 --> 53:05.880]  Вот слева matcher, справа transcribers
[53:08.880 --> 53:11.880]  Да, и сам код, и код, зачем он поменял только
[53:11.880 --> 53:16.880]  А у нас есть слева вот эти вот аргументы, которые value, count
[53:16.880 --> 53:18.880]  То есть через доллары написано
[53:18.880 --> 53:21.880]  Это называется метапеременная, meta variables
[53:21.880 --> 53:24.880]  Они специфицированы с помощью доллара
[53:24.880 --> 53:31.880]  После самой переменной, ее название, это метапеременный
[53:31.880 --> 53:33.880]  Мы пишем ее тип
[53:33.880 --> 53:35.880]  Типов у нас несколько
[53:35.880 --> 53:37.880]  У нас есть export, что есть выражение
[53:37.880 --> 53:41.880]  Выражение это там 1, плюс 2, плюс 10, минус 3
[53:41.880 --> 53:44.880]  Поделить на 2 функции от всего этого и так далее
[53:44.880 --> 53:47.880]  То есть какое-то произвольное выражение
[53:47.880 --> 53:49.880]  Statement есть
[53:49.880 --> 53:51.880]  Есть тип произвольный
[53:51.880 --> 53:54.880]  То есть можно типы, в том числе макро составлять
[53:54.880 --> 53:56.880]  Идентификаторы
[53:56.880 --> 53:58.880]  Чуть-чуть более конкретно
[53:58.880 --> 54:00.880]  Например, если вы сделаете
[54:00.880 --> 54:02.880]  Хотя, наверное, там дальше будет пример
[54:02.880 --> 54:05.880]  Так что давайте я пока что скажу, что просто идентификатор
[54:05.880 --> 54:09.880]  Например, это когда вы делаете let x равняется 3, x это идентификатор
[54:09.880 --> 54:11.880]  Так
[54:11.880 --> 54:14.880]  Ну или какое-то ключевое слово можно вставить
[54:14.880 --> 54:18.880]  У нас есть expressions, есть statements
[54:18.880 --> 54:20.880]  Expression это какое-то выражение, какое-то число
[54:20.880 --> 54:22.880]  А statement это
[54:22.880 --> 54:24.880]  Через точку и запятое что-то
[54:24.880 --> 54:26.880]  То есть просто какой-то кусок кода
[54:26.880 --> 54:30.880]  Expression это выражение какое-то, которое имеет значение
[54:30.880 --> 54:32.880]  А statement это конкретно кусочек кода
[54:32.880 --> 54:34.880]  Как-то так
[54:37.880 --> 54:39.880]  Потом есть блок
[54:39.880 --> 54:41.880]  Блок это что-то в фигурных скобочках
[54:41.880 --> 54:43.880]  То есть scope, грубо говоря
[54:43.880 --> 54:45.880]  Есть token3
[54:45.880 --> 54:48.880]  Token3 это уже такая вещь, очень важная в теме макросов
[54:48.880 --> 54:50.880]  Token3 это какой-то код
[54:50.880 --> 54:52.880]  Который находится внутри круглых скобочек
[54:52.880 --> 54:55.880]  Квадратных скобочек либо фигурных скобочек
[54:55.880 --> 54:57.880]  То есть token3
[54:57.880 --> 54:59.880]  Наверное, когда мы дойдем до процедурных макросов
[54:59.880 --> 55:01.880]  Мы поподробнее поговорим
[55:01.880 --> 55:03.880]  Потому что декларативные макросы обычно
[55:03.880 --> 55:06.880]  По позиции expressions и типами
[55:06.880 --> 55:08.880]  Ну еще идентификаторами
[55:08.880 --> 55:10.880]  Ну и литералы там всякие
[55:10.880 --> 55:12.880]  Можно там чиселки, например, написать строчки
[55:12.880 --> 55:14.880]  Писать макросы
[55:14.880 --> 55:16.880]  Чтобы повторить какой-то паттерн
[55:16.880 --> 55:18.880]  Какое число раз
[55:18.880 --> 55:20.880]  У нас есть такой специальный паттерн
[55:20.880 --> 55:22.880]  Это доллар, скобочки
[55:22.880 --> 55:24.880]  И после этого звездочка, плюсик
[55:24.880 --> 55:26.880]  Либо вопросик
[55:26.880 --> 55:28.880]  Ну как может догадаться
[55:28.880 --> 55:30.880]  Звездочка ноль или больше раз
[55:30.880 --> 55:32.880]  Плюсик это один или больше раз
[55:32.880 --> 55:34.880]  А вопросик ноль или один раз
[55:34.880 --> 55:36.880]  То, что в скобочках
[55:36.880 --> 55:38.880]  Оно будет подразумеваться
[55:38.880 --> 55:40.880]  Что в скобочках есть
[55:40.880 --> 55:42.880]  Ну как можно догадаться
[55:42.880 --> 55:44.880]  В скобочках оно будет подразумеваться
[55:44.880 --> 55:46.880]  Что оно будет матчиться
[55:46.880 --> 55:48.880]  Как сколько-то раз повторяющийся
[55:52.880 --> 55:54.880]  Отличный вопрос
[55:54.880 --> 55:56.880]  Здесь вот видишь есть запята
[55:56.880 --> 55:58.880]  Если ты напишешь
[55:58.880 --> 56:00.880]  Ну мне кажется на следующем слайде это будет
[56:00.880 --> 56:02.880]  Да
[56:02.880 --> 56:04.880]  Можно как раз написать
[56:04.880 --> 56:06.880]  Сепаратор
[56:06.880 --> 56:08.880]  До того как ты напишешь звездочку плюсик
[56:08.880 --> 56:10.880]  Либо вопросик
[56:10.880 --> 56:12.880]  Звездую, точку запятой, стрелочку
[56:12.880 --> 56:14.880]  Ну тоже тебе нравится
[56:14.880 --> 56:16.880]  Не все разрешено
[56:16.880 --> 56:18.880]  Потому что
[56:18.880 --> 56:20.880]  Декларативные макросы у них
[56:20.880 --> 56:22.880]  Ограниченный синтакс сейчас по сравнению с процедурными
[56:22.880 --> 56:24.880]  Например после expression ты не можешь
[56:24.880 --> 56:26.880]  Секономерно написать палочку
[56:26.880 --> 56:28.880]  Но палочка потому что она OR
[56:28.880 --> 56:30.880]  И соответственно рас не будет знать
[56:30.880 --> 56:32.880]  А это конец выражения
[56:32.880 --> 56:34.880]  Или это продолжение его
[56:34.880 --> 56:36.880]  Не сможет просто поматчить и понять где что
[56:36.880 --> 56:38.880]  Ему нужна какая-то определенность
[56:38.880 --> 56:40.880]  Ты точно тебе скажешь что выражение закончилось
[56:40.880 --> 56:42.880]  А это нет
[56:42.880 --> 56:44.880]  Соответственно раз за этим следи
[56:44.880 --> 56:46.880]  То будешь давать compile time ошибки
[56:46.880 --> 56:48.880]  Если ты не сможешь это использовать в качестве сепаратора
[56:54.880 --> 56:56.880]  Если между ними ничего не будет
[56:56.880 --> 56:58.880]  То он разделяет по
[56:58.880 --> 57:00.880]  По пробельчику
[57:00.880 --> 57:02.880]  Ну или по табу
[57:02.880 --> 57:04.880]  Ему без разницы можно enter
[57:04.880 --> 57:08.880]  Ну как сказать
[57:08.880 --> 57:10.880]  Там просто чтобы главное
[57:10.880 --> 57:12.880]  Был какой-то промежуток
[57:12.880 --> 57:14.880]  Типа пустой промежуток
[57:16.880 --> 57:18.880]  Так
[57:18.880 --> 57:20.880]  Давайте напишем чтобы понять
[57:20.880 --> 57:22.880]  Repetitions чуть-чуть получше
[57:22.880 --> 57:24.880]  Такой немножечко странный макрос
[57:24.880 --> 57:26.880]  Но зато будет чуть-чуть понятнее
[57:26.880 --> 57:28.880]  Что происходит
[57:28.880 --> 57:30.880]  Посмотрите на него внимательно
[57:30.880 --> 57:32.880]  Попробуйте понять что происходит
[57:34.880 --> 57:36.880]  Кстати еще возможно вас может запутать
[57:36.880 --> 57:38.880]  Здесь это фигурные скобочки
[57:38.880 --> 57:40.880]  Видите?
[57:40.880 --> 57:42.880]  Это у нас были квадратные
[57:42.880 --> 57:44.880]  Теперь фигурные
[57:44.880 --> 57:46.880]  На самом деле нам без разницы что писать
[57:46.880 --> 57:48.880]  Круглые, квадратные или фигурные
[57:48.880 --> 57:50.880]  Макрос со всеми может работать
[57:50.880 --> 57:52.880]  В том числе если вы напишите фигурные
[57:52.880 --> 57:54.880]  Вы можете экземпл потом вызвать квадратные
[57:54.880 --> 57:56.880]  Как я например сделал
[57:56.880 --> 57:58.880]  Это не является частью матчинга
[57:58.880 --> 58:00.880]  То есть это просто то что вы ставите
[58:00.880 --> 58:02.880]  Для вашего удобства
[58:02.880 --> 58:04.880]  Чтобы было лучше видно что внутри
[58:04.880 --> 58:06.880]  Что-то происходит
[58:14.880 --> 58:16.880]  Абсолютно верно
[58:16.880 --> 58:18.880]  Сколько-то expression через запятую
[58:18.880 --> 58:20.880]  Кстати
[58:20.880 --> 58:22.880]  Точно так же как и везде
[58:22.880 --> 58:24.880]  Rust позволяет писать
[58:24.880 --> 58:26.880]  Вот эту запятую писать или не писать
[58:26.880 --> 58:28.880]  В конце этих expression
[58:28.880 --> 58:30.880]  Без разницы
[58:30.880 --> 58:32.880]  Если вы напишите один запятая, два запятая
[58:32.880 --> 58:34.880]  То же самое что один запятая, два
[58:34.880 --> 58:36.880]  Просто позволяет эти разделители
[58:36.880 --> 58:38.880]  Повторять в конце для вашего удобства
[58:40.880 --> 58:42.880]  Воскресательный знак означает что?
[58:44.880 --> 58:46.880]  Воскресательный знак это специальная штука для макроса
[58:46.880 --> 58:48.880]  То есть когда ты вызываешь макрос
[58:48.880 --> 58:50.880]  То ты должен с воскресательным знакомым вызывать
[58:52.880 --> 58:54.880]  Компилятор когда будет это партией
[58:54.880 --> 58:56.880]  Он поймет ага это макрос
[58:56.880 --> 58:58.880]  И будет по сравнению с ним работать
[58:58.880 --> 59:00.880]  Чуть конкретнее попозже поговорим
[59:04.880 --> 59:06.880]  Ну действительно тут какое число выражений
[59:06.880 --> 59:08.880]  Стрелочек какое число выражений
[59:10.880 --> 59:12.880]  Чуть-чуть усложнили задачу
[59:12.880 --> 59:14.880]  Что здесь?
[59:14.880 --> 59:16.880]  Буквально капельку
[59:18.880 --> 59:20.880]  Да просто скобочковый округ поставили
[59:20.880 --> 59:22.880]  А теперь мы еще зафигачили вот так
[59:28.880 --> 59:30.880]  Ну на самом деле там без разницы
[59:30.880 --> 59:32.880]  Ну конкретно в данном случае
[59:32.880 --> 59:34.880]  У нас чуть-чуть попозже
[59:34.880 --> 59:36.880]  Будут слова о том
[59:36.880 --> 59:38.880]  Почему нужно одну ставить
[59:38.880 --> 59:40.880]  Почему нужно ставить две
[59:40.880 --> 59:42.880]  Конкретно в данном случае без разницы
[59:42.880 --> 59:44.880]  Давай пока что скипнем
[59:44.880 --> 59:46.880]  Ну да в общем в скобочках
[59:46.880 --> 59:48.880]  Через запятую какие-то такие же выражения
[59:48.880 --> 59:50.880]  Просто повторили какое-то число раз
[59:50.880 --> 59:52.880]  То что было вот тут через запятую
[59:52.880 --> 59:54.880]  Ну то есть вы можете писать внутри
[59:54.880 --> 59:56.880]  Repetitions, еще repetitions, еще repetitions
[59:56.880 --> 59:58.880]  Но как вам нравится
[59:58.880 --> 01:00:00.880]  Все это раз будет мачить
[01:00:00.880 --> 01:00:02.880]  Подсвечивает только открывающийся
[01:00:02.880 --> 01:00:04.880]  И вот здесь вот
[01:00:04.880 --> 01:00:06.880]  И вот здесь вот
[01:00:06.880 --> 01:00:08.880]  И вот здесь вот
[01:00:08.880 --> 01:00:10.880]  И вот здесь вот
[01:00:10.880 --> 01:00:12.880]  И вот здесь вот
[01:00:12.880 --> 01:00:14.880]  Подсвечивает только открывающийся
[01:00:14.880 --> 01:00:16.880]  И скобка
[01:00:16.880 --> 01:00:18.880]  Ну это недостаток
[01:00:18.880 --> 01:00:20.880]  Синтаксиса
[01:00:20.880 --> 01:00:22.880]  Минтед для тех
[01:00:22.880 --> 01:00:24.880]  Он не умеет просто так делать
[01:00:26.880 --> 01:00:28.880]  Так у нас тут чуть-чуть
[01:00:28.880 --> 01:00:30.880]  Поврезался
[01:00:30.880 --> 01:00:32.880]  Не обратил даже внимания
[01:00:32.880 --> 01:00:34.880]  Ладно
[01:00:34.880 --> 01:00:36.880]  Что ж давайте вернем
[01:00:36.880 --> 01:00:38.880]  На место код
[01:00:38.880 --> 01:00:40.880]  Когда мы пишем
[01:00:40.880 --> 01:00:42.880]  Первые фигурные скобочки
[01:00:42.880 --> 01:00:44.880]  Для того чтобы означать, что у нас вот здесь начинается
[01:00:44.880 --> 01:00:46.880]  Собственно наш код
[01:00:46.880 --> 01:00:48.880]  Который мы вставляем
[01:00:48.880 --> 01:00:50.880]  А вот вторая нам нужна
[01:00:50.880 --> 01:00:52.880]  Если у нас внутри несколько выражений
[01:00:52.880 --> 01:00:54.880]  То есть у нас конкретно здесь
[01:00:54.880 --> 01:00:56.880]  В первом
[01:00:56.880 --> 01:00:58.880]  Мачере
[01:00:58.880 --> 01:01:00.880]  У нас вот здесь transcriber точнее
[01:01:00.880 --> 01:01:02.880]  У нас вот здесь два выражения
[01:01:02.880 --> 01:01:04.880]  Потом век возвращаем
[01:01:04.880 --> 01:01:06.880]  Как бы из скопа
[01:01:06.880 --> 01:01:08.880]  Вот этот вот скоп у нас означает эти вещи
[01:01:08.880 --> 01:01:10.880]  Если мы будем писать createVect
[01:01:10.880 --> 01:01:12.880]  Он грубо говоря
[01:01:12.880 --> 01:01:14.880]  Не совсем правда
[01:01:14.880 --> 01:01:16.880]  Но ставит в этих фигурных скобочках
[01:01:16.880 --> 01:01:18.880]  То, что он внутри сделал
[01:01:18.880 --> 01:01:20.880]  Просто заменит
[01:01:20.880 --> 01:01:22.880]  Хардение макроса вот этим
[01:01:22.880 --> 01:01:24.880]  Вот здесь смотрите
[01:01:24.880 --> 01:01:26.880]  У нас только одно выражение
[01:01:26.880 --> 01:01:28.880]  Поэтому давайте без фигурных скобочек
[01:01:28.880 --> 01:01:30.880]  Сразу же вернем
[01:01:30.880 --> 01:01:32.880]  И он заменит макрос на просто вот эту строчку
[01:01:38.880 --> 01:01:40.880]  Это был node.exemple
[01:01:42.880 --> 01:01:44.880]  А ну это node.exemple
[01:01:44.880 --> 01:01:46.880]  Это как раз потому, что здесь у нас нет фигурных скобочек
[01:01:46.880 --> 01:01:48.880]  Это в этом смысле
[01:01:48.880 --> 01:01:50.880]  А почему мы вообще рассматриваем
[01:01:50.880 --> 01:01:52.880]  Эти случаи, если звездочка
[01:01:52.880 --> 01:01:54.880]  Предполагает
[01:01:54.880 --> 01:01:56.880]  А вдруг тебе хочется сразу же просто век не увернуть
[01:01:56.880 --> 01:01:58.880]  То есть даже чтобы не было никаких вопросов в комплятуре
[01:01:58.880 --> 01:02:00.880]  Не на клип получится?
[01:02:00.880 --> 01:02:02.880]  Потому что матч ценей 1,5 и 3?
[01:02:02.880 --> 01:02:04.880]  А вот и нет, потому что
[01:02:04.880 --> 01:02:06.880]  Раз матчет их линейно
[01:02:06.880 --> 01:02:08.880]  Просто приходится твой патрон такой
[01:02:08.880 --> 01:02:10.880]  Ага, так, о, подошло
[01:02:10.880 --> 01:02:12.880]  Как-то так
[01:02:12.880 --> 01:02:14.880]  Ну как матч
[01:02:14.880 --> 01:02:16.880]  Да-да, как матч работает
[01:02:16.880 --> 01:02:18.880]  Именно так
[01:02:18.880 --> 01:02:20.880]  Поэтому ты можешь писать даже какие-то
[01:02:20.880 --> 01:02:22.880]  Повторяющиеся вещи
[01:02:22.880 --> 01:02:24.880]  Я, кстати, не уверен
[01:02:24.880 --> 01:02:26.880]  Если их поменять местами
[01:02:26.880 --> 01:02:28.880]  А, наверное, тоже скомпилируются
[01:02:28.880 --> 01:02:30.880]  Только тогда будет бесполезна эта строчка
[01:02:30.880 --> 01:02:32.880]  Если вы допишете
[01:02:32.880 --> 01:02:34.880]  А он не скажет, что я не знаю, что такое
[01:02:34.880 --> 01:02:36.880]  Где именно?
[01:02:36.880 --> 01:02:38.880]  Ну вот, если мы уберем вторую
[01:02:38.880 --> 01:02:40.880]  Только последнюю оставим
[01:02:40.880 --> 01:02:42.880]  И мы хотим создать пустой вектор
[01:02:42.880 --> 01:02:44.880]  Сейчас, ты хочешь убрать вот это?
[01:02:44.880 --> 01:02:46.880]  Ну да, я хочу создать пустой вектор
[01:02:46.880 --> 01:02:48.880]  Используя вот вторую
[01:02:48.880 --> 01:02:50.880]  А, ну он просто попробует повторить
[01:02:50.880 --> 01:02:52.880]  Он такой смотрит
[01:02:52.880 --> 01:02:54.880]  Когда он делает вот этот репетицион
[01:02:54.880 --> 01:02:56.880]  Мы сейчас поговорим, конечно, об этом
[01:02:56.880 --> 01:02:58.880]  Он смотрит на все вот эти значения внутри
[01:02:58.880 --> 01:03:00.880]  Он знает, что value это список каких-то выражений
[01:03:00.880 --> 01:03:02.880]  Если их там может быть и несколько
[01:03:02.880 --> 01:03:04.880]  На самом деле
[01:03:04.880 --> 01:03:06.880]  То есть ты можешь несколько списков взять
[01:03:06.880 --> 01:03:08.880]  И сюда запихнуть век push
[01:03:08.880 --> 01:03:10.880]  А потом еще век push
[01:03:10.880 --> 01:03:12.880]  Из какого-то второго списка
[01:03:12.880 --> 01:03:14.880]  Например
[01:03:14.880 --> 01:03:16.880]  Rast обратит внимание
[01:03:16.880 --> 01:03:18.880]  Что
[01:03:18.880 --> 01:03:20.880]  Ну, в общем, он просто будет повторять
[01:03:20.880 --> 01:03:22.880]  Какое число Rast
[01:03:22.880 --> 01:03:24.880]  И будет матчить между собой длинные этих двух вещей
[01:03:24.880 --> 01:03:26.880]  Как-то так
[01:03:26.880 --> 01:03:28.880]  Rast скажет не совпадающее
[01:03:28.880 --> 01:03:30.880]  Он будет это делать
[01:03:30.880 --> 01:03:32.880]  Но он в compile-time скажет
[01:03:32.880 --> 01:03:34.880]  Что что-то выдали неправильную длину
[01:03:34.880 --> 01:03:36.880]  И не могу в макросе этого
[01:03:36.880 --> 01:03:38.880]  Ну что ж, вот мы и нашли варядики
[01:03:38.880 --> 01:03:40.880]  Ну да, это что-то типа варядиков
[01:03:40.880 --> 01:03:42.880]  Это такой костыль, знаете
[01:03:42.880 --> 01:03:44.880]  Если вы хотите вас слушать про костыли
[01:03:44.880 --> 01:03:46.880]  Дело в том, что
[01:03:46.880 --> 01:03:48.880]  Вообще
[01:03:48.880 --> 01:03:50.880]  Все вот эти правила
[01:03:50.880 --> 01:03:52.880]  Macro rules
[01:03:52.880 --> 01:03:54.880]  Это первая версия макросов
[01:03:54.880 --> 01:03:56.880]  На данный момент
[01:03:56.880 --> 01:03:58.880]  В тот момент, когда их делали
[01:03:58.880 --> 01:04:00.880]  Ну, Rast еще не был 1.0
[01:04:00.880 --> 01:04:02.880]  Когда их начали делать
[01:04:02.880 --> 01:04:04.880]  А Macro rules были блокером для многих вещей
[01:04:04.880 --> 01:04:06.880]  Почему были блокером?
[01:04:06.880 --> 01:04:08.880]  Потому что было огромное число фичей
[01:04:08.880 --> 01:04:10.880]  Которые еще предстоялось дизайнить
[01:04:10.880 --> 01:04:12.880]  Что-то типа там варядики
[01:04:12.880 --> 01:04:14.880]  Еще какую-нибудь хольеру
[01:04:14.880 --> 01:04:16.880]  Принт LN, например
[01:04:16.880 --> 01:04:18.880]  Хочется запихнуть
[01:04:18.880 --> 01:04:20.880]  А синтаксиса в языке нормального для этого нет
[01:04:20.880 --> 01:04:22.880]  Соответственно, хотелось сделать
[01:04:22.880 --> 01:04:24.880]  Макросы, чтобы сделать какой-то
[01:04:24.880 --> 01:04:26.880]  Плейс холдер
[01:04:26.880 --> 01:04:28.880]  Чтобы какие-то фичи
[01:04:28.880 --> 01:04:30.880]  Уже можно было реализовать в виде макросов
[01:04:30.880 --> 01:04:32.880]  А чуть позже сделать нормально
[01:04:32.880 --> 01:04:34.880]  В каком-то смысле
[01:04:34.880 --> 01:04:36.880]  Macro rules это какой-то костыль
[01:04:36.880 --> 01:04:38.880]  Для того, чтобы дать себе возможность
[01:04:38.880 --> 01:04:40.880]  Для дизайна чуть попозже какую-то фичу
[01:04:40.880 --> 01:04:42.880]  Был 1.0
[01:04:42.880 --> 01:04:44.880]  Ну да, вместо этого
[01:04:44.880 --> 01:04:46.880]  Это было просто откладывание стандартов
[01:04:46.880 --> 01:04:48.880]  А в итоге просто не развивается
[01:04:48.880 --> 01:04:50.880]  Получается
[01:04:50.880 --> 01:04:52.880]  Нормально
[01:04:52.880 --> 01:04:54.880]  В 2011 году стандарты вышли
[01:04:54.880 --> 01:04:56.880]  Все поняли, наконец, что-то много
[01:04:56.880 --> 01:04:58.880]  Откладывали
[01:04:58.880 --> 01:05:00.880]  Раз в три года
[01:05:02.880 --> 01:05:04.880]  Да, ну сейчас делают
[01:05:04.880 --> 01:05:06.880]  Декларативные макросы 2.0
[01:05:06.880 --> 01:05:08.880]  Если интересно, тоже можете погуглить, почитать
[01:05:08.880 --> 01:05:10.880]  Там такой синтаксис
[01:05:10.880 --> 01:05:12.880]  Пишете макро, ну вместо fn пишете макро
[01:05:12.880 --> 01:05:14.880]  И там в скобочках примерно то же самое, что и здесь
[01:05:14.880 --> 01:05:16.880]  Там какие-то свои правила
[01:05:16.880 --> 01:05:18.880]  Гигиены, про которые мы поговорим
[01:05:18.880 --> 01:05:20.880]  Все такое, ну то есть решает
[01:05:20.880 --> 01:05:22.880]  Макро rules
[01:05:22.880 --> 01:05:24.880]  Не знаю совсем
[01:05:24.880 --> 01:05:26.880]  Наверное, не очень скоро
[01:05:26.880 --> 01:05:28.880]  Просто еще много работы
[01:05:30.880 --> 01:05:32.880]  Вот процедурные макросы, о котором будем говорить
[01:05:32.880 --> 01:05:34.880]  Их задизайнили уже после 1.0
[01:05:34.880 --> 01:05:36.880]  И задизайнили нормально, поэтому
[01:05:38.880 --> 01:05:40.880]  Не, процедурные макросы
[01:05:40.880 --> 01:05:42.880]  Они более сложные, чем эти
[01:05:42.880 --> 01:05:44.880]  Просто такое
[01:05:44.880 --> 01:05:46.880]  Найди и вставь, а там будет прям функция
[01:05:46.880 --> 01:05:48.880]  Раст код
[01:05:48.880 --> 01:05:50.880]  Давайте пойдем дальше
[01:05:50.880 --> 01:05:52.880]  Вопрос
[01:05:52.880 --> 01:05:54.880]  Почему это мы так вот
[01:05:54.880 --> 01:05:56.880]  Пишем два двоеточия, потом estd, vec, vec, new
[01:05:56.880 --> 01:05:58.880]  Там что-то такое сложное
[01:05:58.880 --> 01:06:00.880]  Дело в том, что
[01:06:00.880 --> 01:06:02.880]  Наш макрос, ну могут естественно
[01:06:02.880 --> 01:06:04.880]  Использовать какие-то сторонние библиотек
[01:06:04.880 --> 01:06:06.880]  В сторонних библиотеках, если вы
[01:06:06.880 --> 01:06:08.880]  Например, не напишете два двоеточия
[01:06:08.880 --> 01:06:10.880]  То
[01:06:10.880 --> 01:06:12.880]  Макрос уже просто вставляется на место
[01:06:12.880 --> 01:06:14.880]  На место кода, который его вызывает
[01:06:14.880 --> 01:06:16.880]  А вдруг у человека там
[01:06:16.880 --> 01:06:18.880]  Рядом лежит mod.estd, mod.vec
[01:06:18.880 --> 01:06:20.880]  И внутри структура vec
[01:06:20.880 --> 01:06:22.880]  И соответственно вы ее создадите
[01:06:22.880 --> 01:06:24.880]  Примерно так
[01:06:24.880 --> 01:06:26.880]  Двоеточие перед этим всем
[01:06:26.880 --> 01:06:28.880]  Это то, что не было на лекции про модули
[01:06:28.880 --> 01:06:30.880]  Означает список
[01:06:30.880 --> 01:06:32.880]  Текущих импортированных крейтов
[01:06:32.880 --> 01:06:34.880]  То есть
[01:06:34.880 --> 01:06:36.880]  Два двоеточия, если вы пишете, это означает
[01:06:36.880 --> 01:06:38.880]  Что вот сейчас вы будете
[01:06:38.880 --> 01:06:40.880]  Типа
[01:06:40.880 --> 01:06:42.880]  Вернулись прям настолько, что не прям в корень
[01:06:42.880 --> 01:06:44.880]  Ваш текущий крейт, а вообще из него
[01:06:44.880 --> 01:06:46.880]  Как-то так
[01:06:48.880 --> 01:06:50.880]  Не забывайте, что
[01:06:50.880 --> 01:06:52.880]  Все пути, которые вы врасти
[01:06:52.880 --> 01:06:54.880]  Они относительные всегда
[01:06:54.880 --> 01:06:56.880]  А если вы хотите такой абсолютный
[01:06:56.880 --> 01:06:58.880]  И если вы хотите, чтобы ваш макрос переиспользовали потом
[01:06:58.880 --> 01:07:00.880]  Пишите полные пути
[01:07:00.880 --> 01:07:02.880]  Чтобы точно можно было везде вставить
[01:07:02.880 --> 01:07:04.880]  Независимо от того, какие юзинги прописал человек
[01:07:08.880 --> 01:07:10.880]  Для примера, если Диму не заимпортировали
[01:07:10.880 --> 01:07:12.880]  То мы получим ошибку, конечно
[01:07:12.880 --> 01:07:14.880]  Еще есть такая штука, называется крейт
[01:07:14.880 --> 01:07:16.880]  Она везде всех макросов есть
[01:07:16.880 --> 01:07:18.880]  Она содержит просто название
[01:07:18.880 --> 01:07:20.880]  Текущего крейта
[01:07:26.880 --> 01:07:28.880]  У вас есть макрос
[01:07:28.880 --> 01:07:30.880]  Модюл экземпл
[01:07:30.880 --> 01:07:32.880]  Внутри у вас есть макрос
[01:07:32.880 --> 01:07:34.880]  В таком случае крейт, понятие на экземпл
[01:07:34.880 --> 01:07:36.880]  Модюл экземпл
[01:07:36.880 --> 01:07:38.880]  Как-то так
[01:07:38.880 --> 01:07:40.880]  То есть просто такой паттерн
[01:07:40.880 --> 01:07:42.880]  Там не абсолютный пик появится
[01:07:42.880 --> 01:07:44.880]  А вот просто название
[01:07:44.880 --> 01:07:46.880]  Да, это просто название
[01:07:46.880 --> 01:07:48.880]  Он просто вставит текущее название
[01:07:48.880 --> 01:07:50.880]  Типа того крейта, в котором ты
[01:07:50.880 --> 01:07:52.880]  Макрос этот уже
[01:07:52.880 --> 01:07:54.880]  Ну вставил
[01:07:56.880 --> 01:07:58.880]  Так
[01:07:58.880 --> 01:08:00.880]  Что же
[01:08:00.880 --> 01:08:02.880]  Что же я хотел тут сказать
[01:08:02.880 --> 01:08:04.880]  Сейчас
[01:08:04.880 --> 01:08:06.880]  А, ну да, так
[01:08:08.880 --> 01:08:10.880]  Да, если бы мне понять еще
[01:08:10.880 --> 01:08:12.880]  Что я хотел этим сказать
[01:08:12.880 --> 01:08:14.880]  В своем слайду
[01:08:16.880 --> 01:08:18.880]  У нас просто создается структура кс
[01:08:18.880 --> 01:08:20.880]  Потому что у нас два модуля
[01:08:20.880 --> 01:08:22.880]  Внутри структуры кс
[01:08:22.880 --> 01:08:24.880]  И в тесте используется макрос
[01:08:24.880 --> 01:08:26.880]  А, ну тут смотрите
[01:08:26.880 --> 01:08:28.880]  Тут есть имя nested s
[01:08:28.880 --> 01:08:30.880]  Внутри
[01:08:30.880 --> 01:08:32.880]  Внутри макроса nested s
[01:08:32.880 --> 01:08:34.880]  Если вы вот здесь вот
[01:08:34.880 --> 01:08:36.880]  Зайузуете
[01:08:36.880 --> 01:08:38.880]  New s, то оно
[01:08:38.880 --> 01:08:40.880]  Заработает
[01:08:40.880 --> 01:08:42.880]  Так
[01:08:42.880 --> 01:08:44.880]  Вот этих двух строчек не должно быть
[01:08:44.880 --> 01:08:46.880]  Я понял
[01:08:46.880 --> 01:08:48.880]  Это я скопировал сразу playground у себя
[01:08:48.880 --> 01:08:50.880]  Когда я делал лекцию
[01:08:50.880 --> 01:08:52.880]  И забыл эти две строчки удалить
[01:08:52.880 --> 01:08:54.880]  Когда вы увидите экземпл тест
[01:08:54.880 --> 01:08:56.880]  Вот здесь вот, то в таком случае
[01:08:56.880 --> 01:08:58.880]  Это сработает
[01:08:58.880 --> 01:09:00.880]  Потому что у вас nested s
[01:09:00.880 --> 01:09:02.880]  Вот здесь вот и заимпортируете
[01:09:02.880 --> 01:09:04.880]  В общем нужную структуру
[01:09:04.880 --> 01:09:06.880]  Создадите
[01:09:06.880 --> 01:09:08.880]  А если вы здесь вот new s создадите
[01:09:08.880 --> 01:09:10.880]  То он попытается вызвать nested s
[01:09:10.880 --> 01:09:12.880]  Которого здесь нет
[01:09:12.880 --> 01:09:14.880]  Такой вот примерчик
[01:09:16.880 --> 01:09:18.880]  Так
[01:09:20.880 --> 01:09:22.880]  Тоже
[01:09:22.880 --> 01:09:24.880]  Подзабыл что у нас тут
[01:09:26.880 --> 01:09:28.880]  Ну, по сути вот
[01:09:28.880 --> 01:09:30.880]  Про то, про что я говорил
[01:09:30.880 --> 01:09:32.880]  То, что у нас
[01:09:32.880 --> 01:09:34.880]  Вот это вот, если вы хотите repetition
[01:09:34.880 --> 01:09:36.880]  За expending, то в таком случае
[01:09:36.880 --> 01:09:38.880]  Используйте доллар, скобочку
[01:09:38.880 --> 01:09:40.880]  Сколько раз вы хотите повторить
[01:09:40.880 --> 01:09:42.880]  То есть 0 или больше, 1 или больше
[01:09:42.880 --> 01:09:44.880]  Либо 0 или 1
[01:09:44.880 --> 01:09:46.880]  Соответственно он будет по всем значениям
[01:09:46.880 --> 01:09:48.880]  Которые внутри написаны
[01:09:48.880 --> 01:09:50.880]  В нашем случае dollar value
[01:09:50.880 --> 01:09:52.880]  Это список значений
[01:09:52.880 --> 01:09:54.880]  Он будет его матчить
[01:09:54.880 --> 01:09:56.880]  Если там будет несколько
[01:09:56.880 --> 01:09:58.880]  Интересно, примерчик кстати есть
[01:09:58.880 --> 01:10:00.880]  Примерчика кажется здесь нет
[01:10:00.880 --> 01:10:02.880]  Так и
[01:10:02.880 --> 01:10:04.880]  Проекта приходит в себя
[01:10:04.880 --> 01:10:06.880]  Вшел в себя
[01:10:06.880 --> 01:10:08.880]  Ну, как я сказал, если будут не одинаковые
[01:10:08.880 --> 01:10:10.880]  По длине списка, то в таком случае
[01:10:10.880 --> 01:10:12.880]  Раст будет навозлиться
[01:10:18.880 --> 01:10:20.880]  Так, время пришло
[01:10:20.880 --> 01:10:22.880]  Улучшать
[01:10:22.880 --> 01:10:24.880]  Наш macros
[01:10:24.880 --> 01:10:26.880]  Как Андрей уже говорил
[01:10:26.880 --> 01:10:28.880]  У нас тут
[01:10:28.880 --> 01:10:30.880]  Не алоцируете вектор
[01:10:30.880 --> 01:10:32.880]  У нас постоянно делается push
[01:10:32.880 --> 01:10:34.880]  Пушу не эффективно, когда вставится в код
[01:10:34.880 --> 01:10:36.880]  Будут реалоцировать несколько раз
[01:10:36.880 --> 01:10:38.880]  Нам хочется заранее это алоцировать
[01:10:38.880 --> 01:10:40.880]  Сейчас будет true metaprogramming
[01:10:40.880 --> 01:10:42.880]  C++ like
[01:10:42.880 --> 01:10:44.880]  Вот, смотрите
[01:10:44.880 --> 01:10:46.880]  Как же мы хотим это сделать
[01:10:46.880 --> 01:10:48.880]  Как вы думаете
[01:10:48.880 --> 01:10:50.880]  Посчитать нам
[01:10:50.880 --> 01:10:52.880]  Давайте более конкретно
[01:10:52.880 --> 01:10:54.880]  Длину списковой лилы
[01:10:54.880 --> 01:10:56.880]  Как мы это сделаем, если догадка
[01:11:00.880 --> 01:11:02.880]  Да, давай чуть конкретнее
[01:11:02.880 --> 01:11:04.880]  Как будет работать macros
[01:11:04.880 --> 01:11:06.880]  Как он объявлен
[01:11:10.880 --> 01:11:12.880]  Реально объявить переменную после века
[01:11:12.880 --> 01:11:14.880]  А дублировать
[01:11:14.880 --> 01:11:16.880]  Не только push, но еще
[01:11:16.880 --> 01:11:18.880]  lplus равно 1
[01:11:18.880 --> 01:11:20.880]  Может создать переменную
[01:11:20.880 --> 01:11:22.880]  Дело в том, что если lplus равно 1
[01:11:22.880 --> 01:11:24.880]  Ну не знаю
[01:11:24.880 --> 01:11:26.880]  Это не лучший способ
[01:11:26.880 --> 01:11:28.880]  Она будет работать
[01:11:28.880 --> 01:11:30.880]  Мы хотим использовать переменную для macros
[01:11:30.880 --> 01:11:32.880]  Давайте так
[01:11:32.880 --> 01:11:34.880]  Мы хотим новый macros, который умеет считать длину
[01:11:34.880 --> 01:11:36.880]  Какого-то аргумента, который передали
[01:11:36.880 --> 01:11:38.880]  Максимально конкретно
[01:11:38.880 --> 01:11:40.880]  Мы можем сделать так, как ты сказал
[01:11:40.880 --> 01:11:42.880]  Но это будет не очень красиво
[01:11:42.880 --> 01:11:44.880]  Раскроется в том, что у тебя lplus 1 будет
[01:11:44.880 --> 01:11:46.880]  Прямо внутри вектора
[01:11:46.880 --> 01:11:48.880]  В создании вектора
[01:11:48.880 --> 01:11:50.880]  Сейчас, ну там match
[01:11:50.880 --> 01:11:52.880]  Есть что-то, и пустота
[01:11:52.880 --> 01:11:54.880]  Возвращает 0
[01:11:54.880 --> 01:11:56.880]  Когда есть что-то, возвращает 1
[01:11:56.880 --> 01:11:58.880]  А как есть что-то, где люди ездят
[01:12:00.880 --> 01:12:02.880]  Ну вот это
[01:12:02.880 --> 01:12:04.880]  Что-то в Китае
[01:12:04.880 --> 01:12:06.880]  Что там было?
[01:12:06.880 --> 01:12:08.880]  Ну в общем ладно, ты мыслишь правильно
[01:12:08.880 --> 01:12:10.880]  Давай мы это
[01:12:10.880 --> 01:12:12.880]  Прямо на слайде выразим
[01:12:12.880 --> 01:12:14.880]  Смотрите, у нас либо пустота
[01:12:14.880 --> 01:12:16.880]  И мы тогда возвращаем 0
[01:12:16.880 --> 01:12:18.880]  Есть какой-то head
[01:12:20.880 --> 01:12:22.880]  Я забыл поменять название
[01:12:22.880 --> 01:12:24.880]  Здесь используется dollar tail
[01:12:24.880 --> 01:12:26.880]  Снизу в описании
[01:12:26.880 --> 01:12:28.880]  Здесь нет head tail
[01:12:28.880 --> 01:12:30.880]  Как вы видите head у нас
[01:12:30.880 --> 01:12:32.880]  А это какой-то tail произвольной длины
[01:12:32.880 --> 01:12:34.880]  Мы заменяем на 1
[01:12:34.880 --> 01:12:36.880]  А macros можете рекурсивно вызывать
[01:12:36.880 --> 01:12:38.880]  Да, macros умеет рекурсивно вызывать
[01:12:38.880 --> 01:12:40.880]  Я думаю, как-нибудь из этого сделать
[01:12:44.880 --> 01:12:46.880]  Вот как раз know that our macro is recursive
[01:12:46.880 --> 01:12:48.880]  По ходу мы открыли husky
[01:12:48.880 --> 01:12:50.880]  Или lewkarp, или что-то похожее
[01:12:50.880 --> 01:12:52.880]  Потому что сейчас очень похоже
[01:12:54.880 --> 01:12:56.880]  Да, это все только declarative macros
[01:12:58.880 --> 01:13:00.880]  TT это токен 3
[01:13:00.880 --> 01:13:02.880]  Это произвольная деревья токенов
[01:13:02.880 --> 01:13:04.880]  Ну просто для того, чтобы наш код был максимально общим
[01:13:04.880 --> 01:13:06.880]  Мы пишем произвольные деревья токенов
[01:13:06.880 --> 01:13:08.880]  Вообще по факту можно expression написать
[01:13:08.880 --> 01:13:10.880]  Точно так же будет работать в данном случае
[01:13:10.880 --> 01:13:12.880]  Вот, ну как видите
[01:13:12.880 --> 01:13:14.880]  Пишу вместо new теперь with capacity
[01:13:14.880 --> 01:13:16.880]  И пишу здесь на 3 count длиной value
[01:13:22.880 --> 01:13:24.880]  Как-то так
[01:13:24.880 --> 01:13:26.880]  Как вы думаете, у нас есть какие-нибудь
[01:13:26.880 --> 01:13:28.880]  Лимиты по рекурсии?
[01:13:30.880 --> 01:13:32.880]  Ну было бы глупо, если бы не было
[01:13:32.880 --> 01:13:34.880]  Потому что если это даже не обрабатывает
[01:13:34.880 --> 01:13:36.880]  Тогда бы секвел целся компилятор
[01:13:36.880 --> 01:13:38.880]  И у юзера было бы очень очевидно
[01:13:38.880 --> 01:13:40.880]  Видеть секвел компилятора
[01:13:40.880 --> 01:13:42.880]  На этапе раскрытия максов
[01:13:42.880 --> 01:13:44.880]  Поэтому конечно же там есть
[01:13:44.880 --> 01:13:46.880]  Лимит, называется recursion limit
[01:13:48.880 --> 01:13:50.880]  Это является атрибутом
[01:13:50.880 --> 01:13:52.880]  Что такое атрибут, конкретно поговорим чуть попозже
[01:13:54.880 --> 01:13:56.880]  Вопрос with capacity
[01:13:56.880 --> 01:13:58.880]  Он требует умолчания?
[01:14:00.880 --> 01:14:02.880]  Что?
[01:14:02.880 --> 01:14:04.880]  Capacity это исключительно вектора
[01:14:10.880 --> 01:14:12.880]  Внутри
[01:14:12.880 --> 01:14:14.880]  Создается век, у которого
[01:14:14.880 --> 01:14:16.880]  Заданы capacity
[01:14:16.880 --> 01:14:18.880]  Нулевое число элементов текущего
[01:14:18.880 --> 01:14:20.880]  И буфер на capacity элемента
[01:14:20.880 --> 01:14:22.880]  Просто статическая функция такая
[01:14:26.880 --> 01:14:28.880]  Вот, чтобы
[01:14:28.880 --> 01:14:30.880]  Занесло лимит
[01:14:30.880 --> 01:14:32.880]  Это атрибуты
[01:14:32.880 --> 01:14:34.880]  Да, это тоже на самом деле макросы
[01:14:34.880 --> 01:14:36.880]  Ну мы чуть-чуть попозже это посмотрим
[01:14:36.880 --> 01:14:38.880]  А, погоди, что решетка
[01:14:38.880 --> 01:14:40.880]  Вот статский знак это макрос?
[01:14:40.880 --> 01:14:42.880]  Да, это все макросы
[01:14:42.880 --> 01:14:44.880]  Просто решетка тоже макрос
[01:14:44.880 --> 01:14:46.880]  Решетка квадратной скобочки
[01:14:46.880 --> 01:14:48.880]  Это все макросы
[01:14:48.880 --> 01:14:50.880]  Некоторые конечно специально для компилятора
[01:14:50.880 --> 01:14:52.880]  Но у них нет такого воплощения
[01:14:52.880 --> 01:14:54.880]  Но тем не менее
[01:14:54.880 --> 01:14:56.880]  Тоже макросы
[01:14:56.880 --> 01:14:58.880]  Что-то неожиданно
[01:14:58.880 --> 01:15:00.880]  Дополнительный лимит 128
[01:15:00.880 --> 01:15:02.880]  Если вы попробуете список
[01:15:02.880 --> 01:15:04.880]  Из 256 элементов
[01:15:04.880 --> 01:15:06.880]  Засуммирует так вот
[01:15:06.880 --> 01:15:08.880]  То компилятор зафейлится
[01:15:08.880 --> 01:15:10.880]  То есть скажет, что
[01:15:10.880 --> 01:15:12.880]  Не хватило глубины
[01:15:12.880 --> 01:15:14.880]  Пытались еще раз вызвать
[01:15:14.880 --> 01:15:16.880]  Recursion limit не только влияет на макросы
[01:15:16.880 --> 01:15:18.880]  Он влияет в том числе на всякие другие
[01:15:18.880 --> 01:15:20.880]  Compiled time операции, например, на деревы
[01:15:20.880 --> 01:15:22.880]  Чтобы не были бесконечными
[01:15:22.880 --> 01:15:24.880]  Все рекурсивные этапы на этапе компиляции
[01:15:24.880 --> 01:15:26.880]  Связанные как-то синтезом языка
[01:15:26.880 --> 01:15:28.880]  Они управляются с recursion limit
[01:15:28.880 --> 01:15:30.880]  Вот, управляются
[01:15:34.880 --> 01:15:36.880]  Так
[01:15:36.880 --> 01:15:38.880]  Еще важная такая штука
[01:15:38.880 --> 01:15:40.880]  Макросы достаточно сложная для дебага штука
[01:15:40.880 --> 01:15:42.880]  Потому что чтобы словить баг в макросе
[01:15:42.880 --> 01:15:44.880]  Вам нужно макрос вызвать
[01:15:44.880 --> 01:15:46.880]  То есть посмотреть то, что он вставит
[01:15:46.880 --> 01:15:48.880]  Конкретно
[01:15:48.880 --> 01:15:50.880]  By default trust он не дает никаких
[01:15:50.880 --> 01:15:52.880]  Возможностей посмотреть, что происходит
[01:15:52.880 --> 01:15:54.880]  Есть такая тулзан
[01:15:54.880 --> 01:15:56.880]  Звать Cargo Expand
[01:15:56.880 --> 01:15:58.880]  Она позволяет
[01:15:58.880 --> 01:16:00.880]  Позволяет раскрыть ваш код
[01:16:00.880 --> 01:16:02.880]  В том числе, если вы вызовете Cargo Expand
[01:16:02.880 --> 01:16:04.880]  И увидите Rust Prelude
[01:16:04.880 --> 01:16:06.880]  Например, который не явно вставляется
[01:16:06.880 --> 01:16:08.880]  Если вы вызовете
[01:16:08.880 --> 01:16:10.880]  То он в том числе раскроет вам макросы
[01:16:10.880 --> 01:16:12.880]  Например, такой вызов превратится вот в такой
[01:16:12.880 --> 01:16:14.880]  То есть ровно то, что мы делали
[01:16:18.880 --> 01:16:20.880]  Как-то так
[01:16:22.880 --> 01:16:24.880]  Да, это неважно
[01:16:26.880 --> 01:16:28.880]  Андрей, у нас гигиеничная макроса
[01:16:28.880 --> 01:16:30.880]  Мы сейчас посмотрим на это
[01:16:30.880 --> 01:16:32.880]  Это не Define
[01:16:32.880 --> 01:16:34.880]  Да, ты можешь забить
[01:16:34.880 --> 01:16:36.880]  Абсолютно на эти скобочки
[01:16:40.880 --> 01:16:42.880]  Но если ты count на count
[01:16:42.880 --> 01:16:44.880]  То все хорошо умножится
[01:16:44.880 --> 01:16:46.880]  Потому что
[01:16:46.880 --> 01:16:48.880]  Грубо говоря, не явные скобочки
[01:16:48.880 --> 01:16:50.880]  На самом деле, то что внутри макроса
[01:16:50.880 --> 01:16:52.880]  И то, что снаружи макроса живет
[01:16:52.880 --> 01:16:54.880]  Немножко в параллельных вселенных
[01:16:54.880 --> 01:16:56.880]  И там есть определенное правило
[01:16:56.880 --> 01:16:58.880]  Как взаимодействовать
[01:16:58.880 --> 01:17:00.880]  То есть гигиеничность есть такое понятие
[01:17:00.880 --> 01:17:02.880]  Да, Define это очень страшно
[01:17:04.880 --> 01:17:06.880]  Можно случайно сломать себе код
[01:17:06.880 --> 01:17:08.880]  Просто так
[01:17:08.880 --> 01:17:10.880]  Вот, ну смотрите
[01:17:10.880 --> 01:17:12.880]  Я могу написать такой вот макрос
[01:17:12.880 --> 01:17:14.880]  Который принимает какое-то приложение
[01:17:14.880 --> 01:17:16.880]  На английском со значением 42
[01:17:16.880 --> 01:17:18.880]  И даже выйдет
[01:17:18.880 --> 01:17:20.880]  То есть действительно выйдет
[01:17:20.880 --> 01:17:22.880]  Wow, the value is 32
[01:17:22.880 --> 01:17:24.880]  32
[01:17:28.880 --> 01:17:30.880]  Ну там конечно есть
[01:17:30.880 --> 01:17:32.880]  Как я говорил, некоторые ограничения
[01:17:32.880 --> 01:17:34.880]  Например, после expression нельзя ставить палочку
[01:17:34.880 --> 01:17:36.880]  Потому что эта часть expression
[01:17:36.880 --> 01:17:38.880]  Может быть, поэтому все должно быть
[01:17:38.880 --> 01:17:40.880]  Определено
[01:17:40.880 --> 01:17:42.880]  Конкретные правила
[01:17:42.880 --> 01:17:44.880]  Во-первых, лучше поработать именно с макросами
[01:17:44.880 --> 01:17:46.880]  Чтобы понять какие
[01:17:46.880 --> 01:17:48.880]  Во-вторых, ну, наверное
[01:17:48.880 --> 01:17:50.880]  Они прям нигде очень подробно не описаны
[01:17:50.880 --> 01:17:52.880]  А хотя, наверное, есть одно место
[01:17:52.880 --> 01:17:54.880]  Есть такая книжка, называется The Little Book of Macros
[01:17:54.880 --> 01:17:56.880]  Если вам очень интересно, можете почитать
[01:17:56.880 --> 01:17:58.880]  Она прям конкретно описывает
[01:17:58.880 --> 01:18:00.880]  Как работает макроса досконально
[01:18:00.880 --> 01:18:02.880]  Какие там понимают деревья токенов
[01:18:02.880 --> 01:18:04.880]  Какие стримы и как оно все преобразовывается
[01:18:04.880 --> 01:18:06.880]  И из этого должно быть примерно понятно
[01:18:06.880 --> 01:18:08.880]  Что можно вставлять и что нет
[01:18:08.880 --> 01:18:10.880]  Но я думаю, что вам это не особо понадобится
[01:18:12.880 --> 01:18:14.880]  Нет, там кстати маленькая книжка
[01:18:14.880 --> 01:18:16.880]  Она в несколько раз
[01:18:16.880 --> 01:18:18.880]  Меньше, чем Rustbook
[01:18:22.880 --> 01:18:24.880]  Но она вообще предназначена для продвинутых пользователей
[01:18:24.880 --> 01:18:26.880]  Но там ничего сложного вроде и нет
[01:18:26.880 --> 01:18:28.880]  Все готовы читать такие книжки
[01:18:30.880 --> 01:18:32.880]  Вот, а теперь пришли к гигиене
[01:18:32.880 --> 01:18:34.880]  Смотрите, у нас в СИШке
[01:18:34.880 --> 01:18:36.880]  Была такая фигня, что мы могли
[01:18:36.880 --> 01:18:38.880]  Написать, например, 5
[01:18:38.880 --> 01:18:40.880]  Внажение на 5
[01:18:40.880 --> 01:18:42.880]  Правда, здесь я, получается, написал скобочки
[01:18:42.880 --> 01:18:44.880]  Нет, тут все нормально
[01:18:46.880 --> 01:18:48.880]  Ну, в общем, этот ассорт зафелдится
[01:18:48.880 --> 01:18:50.880]  Это очень-очень плохо
[01:18:52.880 --> 01:18:54.880]  То есть у нас вместо вэлью подставится 2 плюс 3
[01:18:54.880 --> 01:18:56.880]  Соответственно будет 2 плюс 3 на 5
[01:18:56.880 --> 01:18:58.880]  И это 17
[01:18:58.880 --> 01:19:00.880]  И 17 неравно 25
[01:19:00.880 --> 01:19:02.880]  Хотя казалось бы
[01:19:02.880 --> 01:19:04.880]  Нужно в скобочки, оказывается, брать вэлью
[01:19:04.880 --> 01:19:06.880]  Все потому, что макросы
[01:19:06.880 --> 01:19:08.880]  То есть defined, которые СИШны
[01:19:08.880 --> 01:19:10.880]  Они совершенно ничего происходного не знают
[01:19:10.880 --> 01:19:12.880]  Они просто работают до того
[01:19:12.880 --> 01:19:14.880]  Как начинает работать компилятор
[01:19:14.880 --> 01:19:16.880]  И они заменяют сходение
[01:19:18.880 --> 01:19:20.880]  Вот, а вот тем временем в расти
[01:19:20.880 --> 01:19:22.880]  Например, это все сработает
[01:19:24.880 --> 01:19:26.880]  И почему же оно все-таки будет работать?
[01:19:30.880 --> 01:19:32.880]  Ну, мы говорим вообще, что
[01:19:32.880 --> 01:19:34.880]  Макросы расты гигиенично
[01:19:34.880 --> 01:19:36.880]  Когда мы говорим, что
[01:19:36.880 --> 01:19:38.880]  Макросы расты гигиенично
[01:19:38.880 --> 01:19:40.880]  В таком случае мы имеем в виду, что мы
[01:19:40.880 --> 01:19:42.880]  Здесь скобчик generally
[01:19:42.880 --> 01:19:44.880]  То есть там есть некоторые исключения
[01:19:44.880 --> 01:19:46.880]  Не можем никак влиять
[01:19:46.880 --> 01:19:48.880]  На переменную, которая находится
[01:19:48.880 --> 01:19:50.880]  Снаружи
[01:19:50.880 --> 01:19:52.880]  То есть мы не можем внутри макроса
[01:19:52.880 --> 01:19:54.880]  Как здесь написано, создать
[01:19:54.880 --> 01:19:56.880]  Здесь чуть-чуть переехала скобочка
[01:19:56.880 --> 01:19:58.880]  В принципе, это даже хорошо вместилось весь код
[01:20:00.880 --> 01:20:02.880]  Ну, вот здесь мы создаем какую-то переменную foo
[01:20:02.880 --> 01:20:04.880]  И представим значение x
[01:20:04.880 --> 01:20:06.880]  Казалось бы, если мы сделаем let foo
[01:20:08.880 --> 01:20:10.880]  Двойки, то мы внутри сделаем let foo
[01:20:10.880 --> 01:20:12.880]  Ровняется 2 и должен ассорт зафэдиться
[01:20:12.880 --> 01:20:14.880]  Но нет, потому что эти переменные
[01:20:14.880 --> 01:20:16.880]  Друг с другом никак не связаны
[01:20:20.880 --> 01:20:22.880]  В принципе, самое-самое простое способ
[01:20:22.880 --> 01:20:24.880]  Об этом думать, это
[01:20:24.880 --> 01:20:26.880]  То, что они живут немножко в параллельных вселенных
[01:20:26.880 --> 01:20:28.880]  В принципе, так и есть
[01:20:28.880 --> 01:20:30.880]  Там мы чуть-чуть попозже
[01:20:30.880 --> 01:20:32.880]  Подсмотрим наспэны, такая вещь, которая позволяет
[01:20:32.880 --> 01:20:34.880]  Прям точно в процентурных
[01:20:34.880 --> 01:20:36.880]  Макросах учитывать
[01:20:36.880 --> 01:20:38.880]  Относительно, чего будет рисовываться переменная
[01:20:38.880 --> 01:20:40.880]  Это мы чуть-чуть попозже разберемся
[01:20:42.880 --> 01:20:44.880]  Как-то так, но с этим примером понятно, да?
[01:20:44.880 --> 01:20:46.880]  И что такое гигиеничность
[01:20:46.880 --> 01:20:48.880]  Тоже примерно понятно пока
[01:20:48.880 --> 01:20:50.880]  Ну, еще примеры будем, конечно
[01:20:54.880 --> 01:20:56.880]  Вот, гигиеничность
[01:20:56.880 --> 01:20:58.880]  Она не действует
[01:20:58.880 --> 01:21:00.880]  На вещи, которые не связаны
[01:21:00.880 --> 01:21:02.880]  С идентификаторами переменных
[01:21:02.880 --> 01:21:04.880]  Прям что они шарят
[01:21:04.880 --> 01:21:06.880]  Типы, модули
[01:21:08.880 --> 01:21:10.880]  И функции, в общем
[01:21:10.880 --> 01:21:12.880]  Внутри call site это называется
[01:21:12.880 --> 01:21:14.880]  То место, где макрос вызвали
[01:21:14.880 --> 01:21:16.880]  Именно не где он объявлен
[01:21:16.880 --> 01:21:18.880]  То, что вы могли заметить, например
[01:21:18.880 --> 01:21:20.880]  Нам с stdvec пришлось тем не менее
[01:21:20.880 --> 01:21:22.880]  Писать полный список
[01:21:22.880 --> 01:21:24.880]  Полное имя
[01:21:24.880 --> 01:21:26.880]  Просто потому, что у нас макросы
[01:21:26.880 --> 01:21:28.880]  На самом деле шарят тем не менее
[01:21:28.880 --> 01:21:30.880]  То, что у нас заимпорчено
[01:21:30.880 --> 01:21:32.880]  Внутри
[01:21:34.880 --> 01:21:36.880]  Вот
[01:21:42.880 --> 01:21:44.880]  В общем, все тут понятно, да?
[01:21:52.880 --> 01:21:54.880]  Ну, давайте посмотрим, например
[01:21:54.880 --> 01:21:56.880]  На какой-нибудь шаринг бдтика
[01:21:58.880 --> 01:22:00.880]  Вот, ну, например, есть идент
[01:22:00.880 --> 01:22:02.880]  Как мы смотрели
[01:22:02.880 --> 01:22:04.880]  Там, среди типов
[01:22:04.880 --> 01:22:06.880]  Идентификатор и у нас будет
[01:22:06.880 --> 01:22:08.880]  И какой-то expression
[01:22:08.880 --> 01:22:10.880]  Смотрите, мы идентификатор
[01:22:10.880 --> 01:22:12.880]  И прорисовываем значение x
[01:22:12.880 --> 01:22:14.880]  И как-то не странно, здесь гигиеничность
[01:22:14.880 --> 01:22:16.880]  Не получается
[01:22:16.880 --> 01:22:18.880]  Потому что мы передали идентификатор
[01:22:18.880 --> 01:22:20.880]  В макрос я, то есть мы такое умеем тоже делать
[01:22:22.880 --> 01:22:24.880]  Как-то так
[01:22:26.880 --> 01:22:28.880]  Но еще есть такое понятие
[01:22:28.880 --> 01:22:30.880]  Как visibility макрос
[01:22:30.880 --> 01:22:32.880]  Ну, у них тоже немножко особенные
[01:22:32.880 --> 01:22:34.880]  В отличии от функции
[01:22:34.880 --> 01:22:36.880]  То есть, если у нас была бы функция count
[01:22:36.880 --> 01:22:38.880]  Тогда бы мы ее видели тем не менее в main
[01:22:38.880 --> 01:22:40.880]  Даже несмотря на то, что она позже
[01:22:40.880 --> 01:22:42.880]  А здесь это уже не работает
[01:22:42.880 --> 01:22:44.880]  Нам нужно, чтобы оно было объявлено
[01:22:44.880 --> 01:22:46.880]  Прямо по строчкам исходного кода раньше
[01:22:46.880 --> 01:22:48.880]  Чем сама функция main
[01:22:50.880 --> 01:22:52.880]  Ну, собственно, вот это не будет компилироваться
[01:22:52.880 --> 01:22:54.880]  Потому что у нас count объявлен позже
[01:22:56.880 --> 01:22:58.880]  Более того
[01:22:58.880 --> 01:23:00.880]  Вы не будете без
[01:23:00.880 --> 01:23:02.880]  макроэкспорт
[01:23:02.880 --> 01:23:04.880]  Макроэкспорт это тоже макрос
[01:23:04.880 --> 01:23:06.880]  Который, грубо говоря, выносит ваш макрос
[01:23:06.880 --> 01:23:08.880]  наверх в корневой каталог
[01:23:10.880 --> 01:23:12.880]  Он вам нужен для того, чтобы
[01:23:12.880 --> 01:23:14.880]  сделать ваш макрос видимым
[01:23:14.880 --> 01:23:16.880]  Ну, видимым, собственно, по вашему крейту
[01:23:16.880 --> 01:23:18.880]  Тоже такое выглядит
[01:23:18.880 --> 01:23:20.880]  Как очень костыльное решение
[01:23:20.880 --> 01:23:22.880]  Там нет никаких идентификаторов ак
[01:23:22.880 --> 01:23:24.880]  Нет никакого разграничения видимости
[01:23:24.880 --> 01:23:26.880]  У нас макросы работают достаточно странным образом
[01:23:28.880 --> 01:23:30.880]  Им очень важно, в каком порядке их объявили
[01:23:30.880 --> 01:23:32.880]  Примерно так же, как в плюсах
[01:23:32.880 --> 01:23:34.880]  идентификаторов в каком порядке объявлено
[01:23:34.880 --> 01:23:36.880]  имеет значение
[01:23:38.880 --> 01:23:40.880]  И приходится писать макроэкспорт для того, чтобы
[01:23:40.880 --> 01:23:42.880]  у нас стало видно идентификат
[01:23:42.880 --> 01:23:44.880]  Ну, видите, count
[01:23:44.880 --> 01:23:46.880]  Без макроэкспорта не будет видно
[01:23:46.880 --> 01:23:48.880]  А с макроэкспорт будет
[01:23:50.880 --> 01:23:52.880]  Примерно понятно?
[01:23:52.880 --> 01:23:54.880]  Как вы могли заметить, декларативная макроса
[01:23:54.880 --> 01:23:56.880]  это вещь, конечно
[01:23:56.880 --> 01:23:58.880]  такая подстановочная, приятная
[01:23:58.880 --> 01:24:00.880]  бывает
[01:24:00.880 --> 01:24:02.880]  Ну, не без недостатков, мы тоже их обсудили
[01:24:02.880 --> 01:24:04.880]  такое достаточно костыльное решение
[01:24:04.880 --> 01:24:06.880]  но тем не менее
[01:24:06.880 --> 01:24:08.880]  рабочее, по-моему
[01:24:08.880 --> 01:24:10.880]  У нас есть процедурная макроса
[01:24:10.880 --> 01:24:12.880]  Процедурная макроса это достаточно сильная вещь
[01:24:12.880 --> 01:24:14.880]  Вот
[01:24:14.880 --> 01:24:16.880]  И вот
[01:24:16.880 --> 01:24:18.880]  И вот
[01:24:18.880 --> 01:24:20.880]  И вот
[01:24:20.880 --> 01:24:22.880]  И вот
[01:24:22.880 --> 01:24:24.880]  У нас есть вот такой отмен
[01:24:24.880 --> 01:24:26.880]  по этому поводу
[01:24:26.880 --> 01:24:28.880]  В общем, процедурная макроса
[01:24:28.880 --> 01:24:30.880]  это такая вещь, это раст-код
[01:24:30.880 --> 01:24:32.880]  который пишет раст-код
[01:24:32.880 --> 01:24:34.880]  То есть вы можете написать произвольный раст-код
[01:24:34.880 --> 01:24:36.880]  который будет генерировать раст-код
[01:24:36.880 --> 01:24:38.880]  Ну, мы сейчас увидим
[01:24:38.880 --> 01:24:40.880]  Давайте перед тем, как перейти к процедурным макросам
[01:24:40.880 --> 01:24:42.880]  посмотрим на один из процедурных макросов
[01:24:44.880 --> 01:24:46.880]  Вау!
[01:24:46.880 --> 01:24:48.880]  Это реакно растя
[01:24:48.880 --> 01:24:50.880]  Там есть Ев
[01:24:54.880 --> 01:24:56.880]  На раст-коне были люди
[01:24:56.880 --> 01:24:58.880]  которые рассказывали про то, как они пишут
[01:24:58.880 --> 01:25:00.880]  фронтенд на расте и в том числе был пример
[01:25:00.880 --> 01:25:02.880]  как на Ев пишут
[01:25:02.880 --> 01:25:04.880]  Ну, это такой крейд, который представляет
[01:25:04.880 --> 01:25:06.880]  реакт на расте в WebAssembly
[01:25:06.880 --> 01:25:08.880]  В плане как читать
[01:25:08.880 --> 01:25:10.880]  Название крейтеска
[01:25:10.880 --> 01:25:12.880]  если читать как Ев
[01:25:12.880 --> 01:25:14.880]  Я не знаю, как это читать
[01:25:14.880 --> 01:25:16.880]  Я фронтендом не занимаюсь
[01:25:16.880 --> 01:25:18.880]  Если вам очень интересно
[01:25:18.880 --> 01:25:20.880]  то там есть
[01:25:20.880 --> 01:25:22.880]  толки про Ев
[01:25:22.880 --> 01:25:24.880]  и есть примеры того, как
[01:25:24.880 --> 01:25:26.880]  он взаимодействует даже с Javascript
[01:25:26.880 --> 01:25:28.880]  и всем таким
[01:25:28.880 --> 01:25:30.880]  И если посмотреть, там даже просматриваться не надо
[01:25:30.880 --> 01:25:32.880]  Код практически одинаковый, как вот на Javascript
[01:25:32.880 --> 01:25:34.880]  на реакте, только он на расте
[01:25:34.880 --> 01:25:36.880]  И все. Ну, то есть там конечно же
[01:25:36.880 --> 01:25:38.880]  это все не на макросов, там прямо раст-код
[01:25:40.880 --> 01:25:42.880]  Смотри, вот это
[01:25:42.880 --> 01:25:44.880]  HTML это макрос
[01:25:44.880 --> 01:25:46.880]  Фигурные скобки означают тело макроса
[01:25:46.880 --> 01:25:48.880]  А дальше вот это
[01:25:48.880 --> 01:25:50.880]  Это означает
[01:25:50.880 --> 01:25:52.880]  ставить раст-код
[01:25:52.880 --> 01:25:54.880]  То есть ты внутри можешь буквально
[01:25:54.880 --> 01:25:56.880]  сделать, например, 42 плюс 2
[01:25:56.880 --> 01:25:58.880]  и там ставится вот эта часть 44
[01:26:00.880 --> 01:26:02.880]  Это типа макрос ставить еще часть раст-код
[01:26:10.880 --> 01:26:12.880]  Нет, смотри, не через декоративный
[01:26:12.880 --> 01:26:14.880]  который вот там
[01:26:14.880 --> 01:26:16.880]  Омерли
[01:26:16.880 --> 01:26:18.880]  Это процедурная макроса, это уже произвольный раст-код
[01:26:18.880 --> 01:26:20.880]  который вот этот парсит
[01:26:20.880 --> 01:26:22.880]  Ты же можешь на расте написать парсию
[01:26:22.880 --> 01:26:24.880]  Вот ты его написал
[01:26:30.880 --> 01:26:32.880]  Короче говоря, это такая вот вещь
[01:26:32.880 --> 01:26:34.880]  Можете посмотреть
[01:26:34.880 --> 01:26:36.880]  Если вам интересно, можно написать на Entend на расте
[01:26:36.880 --> 01:26:38.880]  Backend на расте, все на расте
[01:26:38.880 --> 01:26:40.880]  В общем, раст это язык будущего, верите
[01:26:40.880 --> 01:26:42.880]  Точно совместно, они такие транскриптные
[01:26:42.880 --> 01:26:44.880]  Расы врумаешь
[01:26:44.880 --> 01:26:46.880]  Да-да, и пишешь на расте Frontend
[01:26:46.880 --> 01:26:48.880]  Так
[01:26:48.880 --> 01:26:50.880]  Давайте вернемся в реальность
[01:26:52.880 --> 01:26:54.880]  У нас есть всего 3 типа процедурных макросов
[01:26:54.880 --> 01:26:56.880]  Первый это Function-like макрос
[01:26:56.880 --> 01:26:58.880]  Они выглядят абсолютно точно так же
[01:26:58.880 --> 01:27:00.880]  как декоративные макросы
[01:27:00.880 --> 01:27:02.880]  Это просто вот какая-то вещь, которая вызывается
[01:27:02.880 --> 01:27:04.880]  в коде, но точно так же через восклицательный знак
[01:27:04.880 --> 01:27:06.880]  В скобочках на этот раз уже
[01:27:06.880 --> 01:27:08.880]  больше синтексиса
[01:27:08.880 --> 01:27:10.880]  Мы с этим сейчас разберемся
[01:27:12.880 --> 01:27:14.880]  Эти функциональные макросы вызываются
[01:27:14.880 --> 01:27:16.880]  как и декоративные, но
[01:27:16.880 --> 01:27:18.880]  гораздо более сильные
[01:27:18.880 --> 01:27:20.880]  и мощные
[01:27:20.880 --> 01:27:22.880]  Еще есть Derive-макросы
[01:27:22.880 --> 01:27:24.880]  С ними вы сталкивались с библиотечными
[01:27:24.880 --> 01:27:26.880]  Например, вы можете там написать Derive-клон
[01:27:26.880 --> 01:27:28.880]  Копи, а здесь можно написать
[01:27:28.880 --> 01:27:30.880]  Derive-макрос для произвольного своего трейта
[01:27:30.880 --> 01:27:32.880]  например
[01:27:34.880 --> 01:27:36.880]  Derive делает так, он принимает
[01:27:36.880 --> 01:27:38.880]  структуру Unum или Union
[01:27:38.880 --> 01:27:40.880]  Там будет произвольная
[01:27:40.880 --> 01:27:42.880]  токен-стрим, то есть просто последовательно с токенов
[01:27:42.880 --> 01:27:44.880]  Вы ее парсите
[01:27:44.880 --> 01:27:46.880]  Вы можете сделать что угодно
[01:27:46.880 --> 01:27:48.880]  И то, что вы делаете в конечном итоге
[01:27:48.880 --> 01:27:50.880]  это добавляете
[01:27:50.880 --> 01:27:52.880]  к своему коду что-то
[01:27:52.880 --> 01:27:54.880]  То есть добавляете, например
[01:27:54.880 --> 01:27:56.880]  имплементацию трейта к структурке
[01:27:56.880 --> 01:27:58.880]  Еще есть всякие Derive-helper
[01:27:58.880 --> 01:28:00.880]  Attributes, которые позволяют
[01:28:02.880 --> 01:28:04.880]  добавить, например, макросу что-то указать
[01:28:04.880 --> 01:28:06.880]  Вот это нужно чуть-чуть покастомизировать
[01:28:06.880 --> 01:28:08.880]  Например, если вы будете
[01:28:08.880 --> 01:28:10.880]  пользоваться Serda, то там есть
[01:28:10.880 --> 01:28:12.880]  SerdaSkip
[01:28:12.880 --> 01:28:14.880]  HelperAttribute
[01:28:14.880 --> 01:28:16.880]  который позволяет скипнуть поле
[01:28:16.880 --> 01:28:18.880]  и не сервизировать его
[01:28:18.880 --> 01:28:20.880]  Например
[01:28:20.880 --> 01:28:22.880]  Если вам интересно, можете посмотреть, погуглить
[01:28:24.880 --> 01:28:26.880]  Есть Attribute-макросы
[01:28:28.880 --> 01:28:30.880]  Это как раз то, что мы там
[01:28:30.880 --> 01:28:32.880]  видели, например
[01:28:32.880 --> 01:28:34.880]  Hello
[01:28:34.880 --> 01:28:36.880]  Если вы пишете
[01:28:36.880 --> 01:28:38.880]  Hello Clipping Needles Collect
[01:28:38.880 --> 01:28:40.880]  Возможно, вы пользовались им Виттер Тулс
[01:28:40.880 --> 01:28:42.880]  Это тоже просто custom attribute
[01:28:42.880 --> 01:28:44.880]  Называется Hello
[01:28:48.880 --> 01:28:50.880]  Да, и тесты тоже
[01:28:50.880 --> 01:28:52.880]  это custom attribute
[01:28:54.880 --> 01:28:56.880]  Они используют для того, чтобы как-то
[01:28:56.880 --> 01:28:58.880]  трансформировать объект
[01:28:58.880 --> 01:29:00.880]  Возможно, стереть даже
[01:29:00.880 --> 01:29:02.880]  переписать все что угодно
[01:29:02.880 --> 01:29:04.880]  Если вы будете внимательно
[01:29:04.880 --> 01:29:06.880]  обратить внимание, что первые и третьи макросы
[01:29:06.880 --> 01:29:08.880]  первые просто стирают
[01:29:08.880 --> 01:29:10.880]  то, что находится на его месте
[01:29:10.880 --> 01:29:12.880]  вставляют новый код
[01:29:12.880 --> 01:29:14.880]  Attribute-макрос
[01:29:14.880 --> 01:29:16.880]  позволяет что-то изменить
[01:29:16.880 --> 01:29:18.880]  то есть изменить там произвольным
[01:29:18.880 --> 01:29:20.880]  образом, а Zerif-макрос именно что-то
[01:29:20.880 --> 01:29:22.880]  дописывает
[01:29:22.880 --> 01:29:24.880]  Все это такие вот три типа
[01:29:24.880 --> 01:29:26.880]  макроса есть
[01:29:26.880 --> 01:29:28.880]  Они пишут всегда в специальных крейтах
[01:29:28.880 --> 01:29:30.880]  отдельных
[01:29:30.880 --> 01:29:32.880]  То есть если вы пишете для своей библиотеки
[01:29:32.880 --> 01:29:34.880]  какой-то процедурный макрос, то вы для этого
[01:29:34.880 --> 01:29:36.880]  создаете какой-то внутри крейт
[01:29:36.880 --> 01:29:38.880]  Внутри пишете ли проц макро равняется true
[01:29:38.880 --> 01:29:40.880]  И теперь раз знает, что вы используете
[01:29:40.880 --> 01:29:42.880]  процедурные макросы внутри
[01:29:42.880 --> 01:29:44.880]  Внутри будут находиться процедурные макросы
[01:29:44.880 --> 01:29:46.880]  Ну и он
[01:29:46.880 --> 01:29:48.880]  соответственно подключает для вас
[01:29:48.880 --> 01:29:50.880]  эстидичную дополнительную библиотеку
[01:29:50.880 --> 01:29:52.880]  которая называется проц макро
[01:29:54.880 --> 01:29:56.880]  Давайте напишем простее еще
[01:29:56.880 --> 01:29:58.880]  Проц макрос
[01:29:58.880 --> 01:30:00.880]  Я в main.rc
[01:30:00.880 --> 01:30:02.880]  ну в lib.rc точнее написал
[01:30:02.880 --> 01:30:04.880]  вот такой вот код
[01:30:04.880 --> 01:30:06.880]  То есть я импортировал проц макро
[01:30:06.880 --> 01:30:08.880]  Потом я прописал, что я использую
[01:30:08.880 --> 01:30:10.880]  проц макро токен стрим
[01:30:10.880 --> 01:30:12.880]  Все такое токен стрим сейчас будем разбираться
[01:30:14.880 --> 01:30:16.880]  Make Enswer это у меня какой-то процедурный
[01:30:16.880 --> 01:30:18.880]  макрос, который на свое место
[01:30:18.880 --> 01:30:20.880]  вставляет вот такую вот
[01:30:20.880 --> 01:30:22.880]  строчку FN Enswer
[01:30:22.880 --> 01:30:24.880]  которая возвращает 42
[01:30:24.880 --> 01:30:26.880]  и соответственно
[01:30:26.880 --> 01:30:28.880]  возвращает его в качестве
[01:30:28.880 --> 01:30:30.880]  токен стрима
[01:30:30.880 --> 01:30:32.880]  Ну если вы напишете в произвольном месте
[01:30:32.880 --> 01:30:34.880]  где-нибудь в другом крейте Make Enswer
[01:30:34.880 --> 01:30:36.880]  то в таком случае у вас
[01:30:38.880 --> 01:30:40.880]  вставится FN Enswer
[01:30:40.880 --> 01:30:42.880]  у 32
[01:30:42.880 --> 01:30:44.880]  на его место
[01:30:44.880 --> 01:30:46.880]  Сейчас то есть в Rust есть Eval
[01:30:46.880 --> 01:30:48.880]  Нет Eval, а в Rust нет
[01:30:48.880 --> 01:30:50.880]  потому что это все Compile Time
[01:30:50.880 --> 01:30:52.880]  В Rust не Eval
[01:30:52.880 --> 01:30:54.880]  Ну то есть для того чтобы
[01:30:54.880 --> 01:30:56.880]  Rust код запустить
[01:30:56.880 --> 01:30:58.880]  тебе нужно именно
[01:30:58.880 --> 01:31:00.880]  создать этот код и скомпилировать этот код
[01:31:00.880 --> 01:31:02.880]  А в Run Time у тебя это уже не получится
[01:31:02.880 --> 01:31:04.880]  сделать с помощью макросов
[01:31:04.880 --> 01:31:06.880]  Там еще должен быть
[01:31:06.880 --> 01:31:08.880]  какой-то текст
[01:31:08.880 --> 01:31:10.880]  У меня что-то подсказывает, что он
[01:31:10.880 --> 01:31:12.880]  потерялся
[01:31:12.880 --> 01:31:14.880]  Да
[01:31:14.880 --> 01:31:16.880]  Нужно будет это тоже чинить
[01:31:18.880 --> 01:31:20.880]  В общем как вы можете заметить процедурная макрос
[01:31:20.880 --> 01:31:22.880]  у нас это не гигиенично
[01:31:22.880 --> 01:31:24.880]  То есть они просто вставляют
[01:31:24.880 --> 01:31:26.880]  какие-то произвольные вещи
[01:31:26.880 --> 01:31:28.880]  в место где они вызываются
[01:31:28.880 --> 01:31:30.880]  Это означает, что они
[01:31:30.880 --> 01:31:32.880]  себя ведут таким образом, будто их
[01:31:32.880 --> 01:31:34.880]  OutputStream просто вставляется
[01:31:34.880 --> 01:31:36.880]  в место где они
[01:31:36.880 --> 01:31:38.880]  вызываются собственно
[01:31:38.880 --> 01:31:40.880]  Итак, давайте разбираться
[01:31:40.880 --> 01:31:42.880]  в подробностях
[01:31:42.880 --> 01:31:44.880]  Есть такая штука называется TokenStream
[01:31:44.880 --> 01:31:46.880]  TokenStream это последовательность
[01:31:46.880 --> 01:31:48.880]  Token3 деревья в токене
[01:31:48.880 --> 01:31:50.880]  TokenStream представляет вектор
[01:31:50.880 --> 01:31:52.880]  Token3, а Token3 это
[01:31:52.880 --> 01:31:54.880]  одна из четырех ищей
[01:31:54.880 --> 01:31:56.880]  Это либо идентификатор, либо пунктуация
[01:31:56.880 --> 01:31:58.880]  либо литерал, либо группа
[01:31:58.880 --> 01:32:00.880]  каких-то объектов
[01:32:00.880 --> 01:32:02.880]  Это какой-то TokenStream, но внутри
[01:32:02.880 --> 01:32:04.880]  скобочек
[01:32:04.880 --> 01:32:06.880]  Внутри TokenStream, а может быть
[01:32:06.880 --> 01:32:08.880]  группа и внутри еще один TokenStream
[01:32:08.880 --> 01:32:10.880]  Как-то так
[01:32:10.880 --> 01:32:12.880]  Группа означает, что у вас там фигурные
[01:32:12.880 --> 01:32:14.880]  скобочки, круглые либо квадратные
[01:32:14.880 --> 01:32:16.880]  скобочки, внутри еще один TokenStream
[01:32:16.880 --> 01:32:18.880]  А мы можем назвать какие-нибудь скобочки?
[01:32:18.880 --> 01:32:20.880]  Да
[01:32:20.880 --> 01:32:22.880]  Там можно посмотреть
[01:32:22.880 --> 01:32:24.880]  Сейчас увидим
[01:32:24.880 --> 01:32:26.880]  В общем, как вы можете
[01:32:26.880 --> 01:32:28.880]  зависеть, любой input к процедурным
[01:32:28.880 --> 01:32:30.880]  макросу это сбалансированная, правильно, скобочная
[01:32:30.880 --> 01:32:32.880]  последовательность
[01:32:32.880 --> 01:32:34.880]  Все остальное в принципе не специфицировано
[01:32:34.880 --> 01:32:36.880]  Вы можете писать
[01:32:36.880 --> 01:32:38.880]  все что захотите
[01:32:38.880 --> 01:32:40.880]  Нормально
[01:32:40.880 --> 01:32:42.880]  Вот
[01:32:42.880 --> 01:32:44.880]  Теперь появляется вопрос
[01:32:44.880 --> 01:32:46.880]  Какой TokenStream от этой
[01:32:46.880 --> 01:32:48.880]  строчки появился? То есть
[01:32:48.880 --> 01:32:50.880]  запихнул вот эту строчку
[01:32:50.880 --> 01:32:52.880]  в процедурный макрос, какой будет TokenStream?
[01:33:00.880 --> 01:33:02.880]  Говори вслух
[01:33:02.880 --> 01:33:04.880]  Первые два это indent
[01:33:04.880 --> 01:33:06.880]  потом punctuation
[01:33:08.880 --> 01:33:10.880]  так, с макросом
[01:33:10.880 --> 01:33:12.880]  наверное тоже indent
[01:33:12.880 --> 01:33:14.880]  потом
[01:33:14.880 --> 01:33:16.880]  групп
[01:33:16.880 --> 01:33:18.880]  и внутри группы
[01:33:18.880 --> 01:33:20.880]  литерал
[01:33:20.880 --> 01:33:22.880]  пунктуация
[01:33:22.880 --> 01:33:24.880]  внутри литерал
[01:33:24.880 --> 01:33:26.880]  пятерка
[01:33:26.880 --> 01:33:28.880]  ну то есть это значение, я так понимаю, литерала
[01:33:28.880 --> 01:33:30.880]  а, ну stop five times
[01:33:30.880 --> 01:33:32.880]  да, надо макросу вскрыть, поэтому я забыл
[01:33:32.880 --> 01:33:34.880]  потому что five times из себя представляет
[01:33:34.880 --> 01:33:36.880]  макрос, который умножение
[01:33:36.880 --> 01:33:38.880]  5 на 2 плюс 3 умножает
[01:33:38.880 --> 01:33:40.880]  литерал умножить, пунктуация
[01:33:40.880 --> 01:33:42.880]  2 из литерала, 2 плюс и 3
[01:33:42.880 --> 01:33:44.880]  вот
[01:33:44.880 --> 01:33:46.880]  как-то так
[01:33:46.880 --> 01:33:48.880]  выглядит вроде бы несложно, да?
[01:33:48.880 --> 01:33:50.880]  как-то парсится
[01:33:50.880 --> 01:33:52.880]  ну давайте посмотрим в каком-то реальном процедурном макросе
[01:33:52.880 --> 01:33:54.880]  вот мы написали какой-то
[01:33:54.880 --> 01:33:56.880]  просьмакро, который принимает TokenStream
[01:33:56.880 --> 01:33:58.880]  возвращает TokenStream
[01:33:58.880 --> 01:34:00.880]  и ходит по базе
[01:34:00.880 --> 01:34:02.880]  если он встречается с
[01:34:02.880 --> 01:34:04.880]  идентификатором пунктуации или литералом
[01:34:04.880 --> 01:34:06.880]  то выводит, ну иначе игнорирует просто
[01:34:06.880 --> 01:34:08.880]  и выводит соответственно
[01:34:08.880 --> 01:34:10.880]  просто пустой TokenStream
[01:34:10.880 --> 01:34:12.880]  ну мы тестируем просто
[01:34:12.880 --> 01:34:14.880]  что он нам придет на вход
[01:34:14.880 --> 01:34:16.880]  например, такой вот код
[01:34:16.880 --> 01:34:18.880]  выйдет вот такой вот
[01:34:18.880 --> 01:34:20.880]  то есть мы вызываем на шофу
[01:34:20.880 --> 01:34:22.880]  и внутрь подается на вход bar
[01:34:22.880 --> 01:34:24.880]  равно 123 точка запятой
[01:34:24.880 --> 01:34:26.880]  соответственно, bar это идент
[01:34:26.880 --> 01:34:28.880]  равно это пунктуация
[01:34:28.880 --> 01:34:30.880]  123 это литерал
[01:34:30.880 --> 01:34:32.880]  и точка запятой это пунктуация
[01:34:32.880 --> 01:34:34.880]  как-то так
[01:34:34.880 --> 01:34:36.880]  так
[01:34:36.880 --> 01:34:38.880]  ну группа
[01:34:38.880 --> 01:34:40.880]  это соответственно другой TokenStream
[01:34:40.880 --> 01:34:42.880]  еще один TokenStream
[01:34:42.880 --> 01:34:44.880]  внутри скобочка
[01:34:44.880 --> 01:34:46.880]  здесь у нас foo это идентификатор
[01:34:46.880 --> 01:34:48.880]  если полностью
[01:34:48.880 --> 01:34:50.880]  смотреть на эту строчку
[01:34:50.880 --> 01:34:52.880]  которая внутри foo
[01:34:52.880 --> 01:34:54.880]  у нас получится идентификатор foo
[01:34:54.880 --> 01:34:56.880]  bar это будет идентификатор
[01:34:56.880 --> 01:34:58.880]  bar
[01:34:58.880 --> 01:35:00.880]  ну это вот слева и справа соответственно
[01:35:00.880 --> 01:35:02.880]  2 и 2
[01:35:02.880 --> 01:35:04.880]  и 2 плюс 2 это группа
[01:35:04.880 --> 01:35:06.880]  которая состоит из фигурных скобочек
[01:35:06.880 --> 01:35:08.880]  TokenStream
[01:35:08.880 --> 01:35:10.880]  где TokenStream
[01:35:10.880 --> 01:35:12.880]  в себе содержит 2
[01:35:12.880 --> 01:35:14.880]  плюс и 2
[01:35:14.880 --> 01:35:16.880]  ну как видите
[01:35:16.880 --> 01:35:18.880]  мы еще даже не до конца
[01:35:18.880 --> 01:35:20.880]  дошли, но уже видим, что
[01:35:20.880 --> 01:35:22.880]  в Rust
[01:35:22.880 --> 01:35:24.880]  процедурные макросы принимают
[01:35:24.880 --> 01:35:26.880]  произвольный TokenStream
[01:35:26.880 --> 01:35:28.880]  и его как-то трудновато парсить
[01:35:30.880 --> 01:35:32.880]  давайте посмотрим
[01:35:32.880 --> 01:35:34.880]  например
[01:35:34.880 --> 01:35:36.880]  это то
[01:35:36.880 --> 01:35:38.880]  что из себя представляют
[01:35:38.880 --> 01:35:40.880]  структурки
[01:35:40.880 --> 01:35:42.880]  у нас здесь были
[01:35:42.880 --> 01:35:44.880]  идентификатор, пунктуация, элитерал
[01:35:44.880 --> 01:35:46.880]  группа
[01:35:46.880 --> 01:35:48.880]  а что эти структурки из себя представляют
[01:35:48.880 --> 01:35:50.880]  это вот это
[01:35:50.880 --> 01:35:52.880]  элитерал такая строка
[01:35:52.880 --> 01:35:54.880]  спэн
[01:35:54.880 --> 01:35:56.880]  в котором мы поговорим
[01:35:56.880 --> 01:35:58.880]  идентификатор тоже строка
[01:35:58.880 --> 01:36:00.880]  пунктуация
[01:36:00.880 --> 01:36:02.880]  если вы пока не понимаете, что такое спэн
[01:36:02.880 --> 01:36:04.880]  мы чуть-чуть позже поговорим
[01:36:04.880 --> 01:36:06.880]  когда побольше посмотрим на макросы
[01:36:06.880 --> 01:36:08.880]  чтобы нам было понятно, зачем он нужен
[01:36:08.880 --> 01:36:10.880]  пока что вы можете представить, что его нет
[01:36:10.880 --> 01:36:12.880]  потом у нас есть
[01:36:12.880 --> 01:36:14.880]  еще спэйсинг
[01:36:14.880 --> 01:36:16.880]  что же такое спэйсинг
[01:36:16.880 --> 01:36:18.880]  по слайду сверху понятно
[01:36:18.880 --> 01:36:20.880]  примеры того, что являются
[01:36:20.880 --> 01:36:22.880]  элитералами, идентификаторами, пунктуацией
[01:36:28.880 --> 01:36:30.880]  мы видим наличие
[01:36:30.880 --> 01:36:32.880]  продельного символа
[01:36:32.880 --> 01:36:34.880]  но с какой стороны
[01:36:34.880 --> 01:36:36.880]  да, наличие символа
[01:36:40.880 --> 01:36:42.880]  пунктуация, например, спэйсинг
[01:36:42.880 --> 01:36:44.880]  использование спэйсинг здесь
[01:36:44.880 --> 01:36:46.880]  спэйсинг выглядит вот так
[01:36:46.880 --> 01:36:48.880]  если мы вызовем FUBART
[01:36:48.880 --> 01:36:50.880]  в таком случае двоеточие
[01:36:50.880 --> 01:36:52.880]  первая будет пунктуация, которая
[01:36:52.880 --> 01:36:54.880]  двоеточие и loan
[01:36:54.880 --> 01:36:56.880]  а вторая будет двоеточие и joint
[01:36:58.880 --> 01:37:00.880]  ну это будет
[01:37:00.880 --> 01:37:02.880]  два отдельных токена в токен стриме
[01:37:02.880 --> 01:37:04.880]  и соответственно
[01:37:04.880 --> 01:37:06.880]  у двух этих двоеточий будет
[01:37:06.880 --> 01:37:08.880]  идент и идент, только первый будет loan, а второй будет joint
[01:37:10.880 --> 01:37:12.880]  что, показай, где первый, где второй
[01:37:14.880 --> 01:37:16.880]  а чем у тебя случается loan и joint?
[01:37:16.880 --> 01:37:18.880]  что-то непонятно
[01:37:18.880 --> 01:37:20.880]  это для того, чтобы показать относительно друг друга
[01:37:20.880 --> 01:37:22.880]  как они располагаются
[01:37:22.880 --> 01:37:24.880]  что не один и один
[01:37:24.880 --> 01:37:26.880]  а, это что, второй токен?
[01:37:26.880 --> 01:37:28.880]  это чтобы ты знал
[01:37:28.880 --> 01:37:30.880]  вот эти вот вместе
[01:37:30.880 --> 01:37:32.880]  то есть, что второй токен присоединяется к предыдущему
[01:37:32.880 --> 01:37:34.880]  да, что это прям часть
[01:37:34.880 --> 01:37:36.880]  FUBART, например, это два двоеточия
[01:37:36.880 --> 01:37:38.880]  означает, что ты хочешь
[01:37:38.880 --> 01:37:40.880]  модулинг что-то достать
[01:37:40.880 --> 01:37:42.880]  и тебе, наверное, хочется знать, что это часть модуля
[01:37:42.880 --> 01:37:44.880]  два двоеточия этих
[01:37:44.880 --> 01:37:46.880]  ты тоже хочешь знать эту информацию
[01:37:46.880 --> 01:37:48.880]  с точки зрения семантики, а не просто подряд
[01:37:48.880 --> 01:37:50.880]  двоеточие, двоеточие и все
[01:37:50.880 --> 01:37:52.880]  конечно же, парсит Rust code
[01:37:52.880 --> 01:37:54.880]  вот такой вот вообще неудобно
[01:37:54.880 --> 01:37:56.880]  слово совсем
[01:37:56.880 --> 01:37:58.880]  у нас есть create-sync
[01:37:58.880 --> 01:38:00.880]  я надеюсь, что я ничего не пропустил тут
[01:38:00.880 --> 01:38:02.880]  тут звучит пока что так, что я что-то пропустил
[01:38:02.880 --> 01:38:04.880]  ладно, давайте перейдем пока что к сину
[01:38:04.880 --> 01:38:06.880]  син это такой create
[01:38:06.880 --> 01:38:08.880]  тоже, естественно, какой-то
[01:38:08.880 --> 01:38:10.880]  сторонний Rust-crate, который принимает
[01:38:10.880 --> 01:38:12.880]  на вход токен stream
[01:38:12.880 --> 01:38:14.880]  ну, там есть разные функции
[01:38:14.880 --> 01:38:16.880]  он огромный вообще син
[01:38:16.880 --> 01:38:18.880]  предназначен для того, чтобы
[01:38:18.880 --> 01:38:20.880]  парсить именно Rust-code
[01:38:20.880 --> 01:38:22.880]  просто самый-самый частый use-case
[01:38:22.880 --> 01:38:24.880]  derived-macros
[01:38:24.880 --> 01:38:26.880]  это когда парсить именно Rust-code
[01:38:26.880 --> 01:38:28.880]  и соответственно он хочется как-то упростить
[01:38:28.880 --> 01:38:30.880]  себе жизнь. Вот умные люди придумали так
[01:38:30.880 --> 01:38:32.880]  они сделали
[01:38:32.880 --> 01:38:34.880]  create, который предназначен для того
[01:38:34.880 --> 01:38:36.880]  чтобы парсить токен стримы
[01:38:36.880 --> 01:38:38.880]  с условием, что токен stream это именно
[01:38:38.880 --> 01:38:40.880]  Rust-code
[01:38:40.880 --> 01:38:42.880]  то есть решает эту специфическую задачу
[01:38:44.880 --> 01:38:46.880]  ну, давайте напишем какой-то наш
[01:38:46.880 --> 01:38:48.880]  первый derived-macros
[01:38:48.880 --> 01:38:50.880]  пусть мы хотим
[01:38:50.880 --> 01:38:52.880]  написать derived-macros
[01:38:52.880 --> 01:38:54.880]  ну, вы помните, что это такое
[01:38:54.880 --> 01:38:56.880]  у нас есть какой-то wrapper вокруг int
[01:38:58.880 --> 01:39:00.880]  это называется helper-attribute
[01:39:00.880 --> 01:39:02.880]  и здесь я указал, что я хочу
[01:39:02.880 --> 01:39:04.880]  чтобы мой дерев
[01:39:04.880 --> 01:39:06.880]  деревался именно к внутреннему вот этому вот
[01:39:06.880 --> 01:39:08.880]  атрибуту
[01:39:08.880 --> 01:39:10.880]  к ссылке вот на этот атрибут
[01:39:10.880 --> 01:39:12.880]  то есть, если бы у меня здесь
[01:39:12.880 --> 01:39:14.880]  было еще 10 полей, то он бы все равно
[01:39:14.880 --> 01:39:16.880]  сделал дерев как ссылку
[01:39:16.880 --> 01:39:18.880]  на self-inner
[01:39:18.880 --> 01:39:20.880]  как-то так
[01:39:20.880 --> 01:39:22.880]  ну, давайте напишем
[01:39:22.880 --> 01:39:24.880]  как видите, у нас теперь не просто
[01:39:24.880 --> 01:39:26.880]  proc-macro, а proc-macro-derived
[01:39:26.880 --> 01:39:28.880]  мы указываем для какого трейта
[01:39:28.880 --> 01:39:30.880]  дерев и указываем какие атрибуты
[01:39:30.880 --> 01:39:32.880]  мы хотим
[01:39:32.880 --> 01:39:34.880]  в данном случае атрибют мы хотим дерев
[01:39:34.880 --> 01:39:36.880]  чтобы назывался дополнительный
[01:39:36.880 --> 01:39:38.880]  helper-attribute
[01:39:38.880 --> 01:39:40.880]  вот у нас input это
[01:39:40.880 --> 01:39:42.880]  parse-macro-input
[01:39:42.880 --> 01:39:44.880]  то есть мы parse-им наш input
[01:39:44.880 --> 01:39:46.880]  как
[01:39:46.880 --> 01:39:48.880]  sin parse-macro-input
[01:39:48.880 --> 01:39:50.880]  это такая специальная функция, которая предназначена для того
[01:39:50.880 --> 01:39:52.880]  чтобы парсить именно Rust-код
[01:39:52.880 --> 01:39:54.880]  когда нам на вход подается
[01:39:54.880 --> 01:39:56.880]  токен-стрим, мы же ничего про него не знаем
[01:39:56.880 --> 01:39:58.880]  но если мы предполагаем, что это Rust-код
[01:39:58.880 --> 01:40:00.880]  в таком случае нам
[01:40:00.880 --> 01:40:02.880]  как видите, удобно воспользоваться крейтом sin
[01:40:02.880 --> 01:40:04.880]  и воспользоваться таким вот macros-ом
[01:40:04.880 --> 01:40:06.880]  который за нас распарсит Rust-код
[01:40:06.880 --> 01:40:08.880]  и после этого нам будет удобно
[01:40:08.880 --> 01:40:10.880]  все делать
[01:40:10.880 --> 01:40:12.880]  насколько удобно
[01:40:12.880 --> 01:40:14.880]  например, мы дальше ожидаем
[01:40:14.880 --> 01:40:16.880]  что нам input-data это именно структурка
[01:40:16.880 --> 01:40:18.880]  то есть sin data-struct
[01:40:18.880 --> 01:40:20.880]  если у нас
[01:40:20.880 --> 01:40:22.880]  структура это действительно структура
[01:40:22.880 --> 01:40:24.880]  то все хорошо, иначе мы говорим
[01:40:24.880 --> 01:40:26.880]  что у нас только структурки поддерживаются
[01:40:26.880 --> 01:40:28.880]  потому что у нас может быть на входе union
[01:40:28.880 --> 01:40:30.880]  у нас может быть на входе enum
[01:40:34.880 --> 01:40:36.880]  и в этой строчке мы проверяем
[01:40:36.880 --> 01:40:38.880]  что нам действительно на вход структуры подали
[01:40:40.880 --> 01:40:42.880]  потом есть named-fields
[01:40:42.880 --> 01:40:44.880]  мы хотим получить сами
[01:40:44.880 --> 01:40:46.880]  название полей
[01:40:46.880 --> 01:40:48.880]  структуры
[01:40:48.880 --> 01:40:50.880]  и как вы помните
[01:40:50.880 --> 01:40:52.880]  у нас есть структуру
[01:40:52.880 --> 01:40:54.880]  в которой как tuple обозначается
[01:40:54.880 --> 01:40:56.880]  то есть в скобочках мы пишем просто
[01:40:56.880 --> 01:40:58.880]  типа через запятую, дальше через 0.1.2
[01:40:58.880 --> 01:41:00.880]  обращаемся
[01:41:00.880 --> 01:41:02.880]  а есть именно с именованными полями
[01:41:02.880 --> 01:41:04.880]  здесь мы ожидаем структурку с именованными полями
[01:41:06.880 --> 01:41:08.880]  если это так, то
[01:41:08.880 --> 01:41:10.880]  мы достаем эти поля
[01:41:10.880 --> 01:41:12.880]  иначе мы говорим, что только структуры
[01:41:12.880 --> 01:41:14.880]  с именованными полями
[01:41:14.880 --> 01:41:16.880]  поддерживаются
[01:41:16.880 --> 01:41:18.880]  понятно ли
[01:41:18.880 --> 01:41:20.880]  что здесь произошло?
[01:41:26.880 --> 01:41:28.880]  да, может быть например структурка
[01:41:28.880 --> 01:41:30.880]  вот давай здесь
[01:41:30.880 --> 01:41:32.880]  struct inwrapper в скобочках E32
[01:41:34.880 --> 01:41:36.880]  как tuple
[01:41:36.880 --> 01:41:38.880]  как tuple на пену с домашки
[01:41:38.880 --> 01:41:40.880]  было объявлено
[01:41:40.880 --> 01:41:42.880]  там имена полей нет
[01:41:42.880 --> 01:41:44.880]  так
[01:41:44.880 --> 01:41:46.880]  дальше дерев field
[01:41:46.880 --> 01:41:48.880]  мы берем named-fields
[01:41:48.880 --> 01:41:50.880]  если таба как-то не хватает
[01:41:50.880 --> 01:41:52.880]  куда-то он потерялся
[01:41:52.880 --> 01:41:54.880]  у нас есть named-fields
[01:41:54.880 --> 01:41:56.880]  мы превращаем их в Intuiter
[01:41:56.880 --> 01:41:58.880]  дальше мы фильтруем
[01:42:00.880 --> 01:42:02.880]  мы проходимся по полям
[01:42:02.880 --> 01:42:04.880]  и ищем именно то поле
[01:42:04.880 --> 01:42:06.880]  которое у нас содержит атрибут дерев
[01:42:08.880 --> 01:42:10.880]  вот такая вот очень хитрая
[01:42:10.880 --> 01:42:12.880]  как видите у нас у каждого поля
[01:42:12.880 --> 01:42:14.880]  есть field-atters
[01:42:14.880 --> 01:42:16.880]  и за нас Син все распарсил
[01:42:16.880 --> 01:42:18.880]  сказал нам где
[01:42:18.880 --> 01:42:20.880]  у какого поля атрибуты
[01:42:20.880 --> 01:42:22.880]  field-atters-iter
[01:42:22.880 --> 01:42:24.880]  мы интервируемся по атрибутам конкретного
[01:42:24.880 --> 01:42:26.880]  поля
[01:42:26.880 --> 01:42:28.880]  ищем среди них дерев
[01:42:28.880 --> 01:42:30.880]  если находим, то все хорошо
[01:42:30.880 --> 01:42:32.880]  как-то так
[01:42:34.880 --> 01:42:36.880]  если мы не нашли
[01:42:36.880 --> 01:42:38.880]  то в таком случае мы скажем, что
[01:42:38.880 --> 01:42:40.880]  поля с деревом нет нигде
[01:42:40.880 --> 01:42:42.880]  фильтр нам возвращает
[01:42:42.880 --> 01:42:44.880]  итератор на то, что
[01:42:44.880 --> 01:42:46.880]  возвращает все поля
[01:42:46.880 --> 01:42:48.880]  в общем фильтр возвращает
[01:42:48.880 --> 01:42:50.880]  все элементы
[01:42:50.880 --> 01:42:52.880]  которые подчиняются какому-то условию
[01:42:52.880 --> 01:42:54.880]  в нашу условию
[01:42:54.880 --> 01:42:56.880]  да, мы просто берем первые из них
[01:42:56.880 --> 01:42:58.880]  берем первые, которые содержат
[01:42:58.880 --> 01:43:00.880]  в себе атрибут дерев
[01:43:00.880 --> 01:43:02.880]  ну и дальше мы
[01:43:02.880 --> 01:43:04.880]  давайте просто отформатируем
[01:43:04.880 --> 01:43:06.880]  сделаем такую
[01:43:06.880 --> 01:43:08.880]  тиранду
[01:43:08.880 --> 01:43:10.880]  напишем импл-опс-дереф
[01:43:10.880 --> 01:43:12.880]  для нашей структурки
[01:43:12.880 --> 01:43:14.880]  внутри фигурной скобочки
[01:43:14.880 --> 01:43:16.880]  импл-идентифайер
[01:43:16.880 --> 01:43:18.880]  название нашего структурки
[01:43:18.880 --> 01:43:20.880]  в импуте
[01:43:20.880 --> 01:43:22.880]  у нас дерев-файл
[01:43:22.880 --> 01:43:24.880]  type-token-stream
[01:43:24.880 --> 01:43:26.880]  то есть мы вставляем
[01:43:26.880 --> 01:43:28.880]  тип нашего поля
[01:43:28.880 --> 01:43:30.880]  который содержит
[01:43:30.880 --> 01:43:32.880]  наш дерев-атрибут
[01:43:32.880 --> 01:43:34.880]  и соответственно его имя тоже
[01:43:34.880 --> 01:43:36.880]  на место ссылочки на салфе
[01:43:36.880 --> 01:43:38.880]  что делает формат?
[01:43:38.880 --> 01:43:40.880]  формат форматирует
[01:43:40.880 --> 01:43:42.880]  просто строчку
[01:43:42.880 --> 01:43:44.880]  вставляет на место фигурных скобочек
[01:43:44.880 --> 01:43:46.880]  одинарных, как здесь
[01:43:46.880 --> 01:43:48.880]  строчки
[01:43:48.880 --> 01:43:50.880]  в соответствующем порядке
[01:43:50.880 --> 01:43:52.880]  это означает, да
[01:43:52.880 --> 01:43:54.880]  чтобы
[01:43:54.880 --> 01:43:56.880]  видимо многострочные были, да?
[01:43:56.880 --> 01:43:58.880]  да
[01:44:00.880 --> 01:44:02.880]  соответственно мы это парсим
[01:44:02.880 --> 01:44:04.880]  чтобы приобретить именно в токен-стрим
[01:44:04.880 --> 01:44:06.880]  и анрэп
[01:44:06.880 --> 01:44:08.880]  естественно это не учитывает большинство юзкейсов
[01:44:08.880 --> 01:44:10.880]  но тем не менее уже делает дерев
[01:44:10.880 --> 01:44:12.880]  для нашей структурки
[01:44:12.880 --> 01:44:14.880]  для которой мы захотели
[01:44:14.880 --> 01:44:16.880]  то есть оно действительно прочитает нашу структурку
[01:44:16.880 --> 01:44:18.880]  оно найдет первое поле
[01:44:18.880 --> 01:44:20.880]  у которого есть дерев
[01:44:20.880 --> 01:44:22.880]  и напишет импл
[01:44:22.880 --> 01:44:24.880]  импл, где дерев
[01:44:24.880 --> 01:44:26.880]  от этого поля
[01:44:26.880 --> 01:44:28.880]  как-то так
[01:44:28.880 --> 01:44:30.880]  это конечно же не идеально
[01:44:30.880 --> 01:44:32.880]  у нас например могут быть структуры
[01:44:32.880 --> 01:44:34.880]  у которых есть дженерики
[01:44:34.880 --> 01:44:36.880]  естественно с ними нужно по-особенному работать
[01:44:36.880 --> 01:44:38.880]  у нас могут быть дженерики
[01:44:38.880 --> 01:44:40.880]  у которых еще к тому же есть какие-то
[01:44:40.880 --> 01:44:42.880]  ограничения на Т
[01:44:44.880 --> 01:44:46.880]  в общем вы уже представляете
[01:44:46.880 --> 01:44:48.880]  какая это боль писать процедурный макрос
[01:44:48.880 --> 01:44:50.880]  на самом деле конечно формат
[01:44:50.880 --> 01:44:52.880]  это не лучший способ
[01:44:52.880 --> 01:44:54.880]  вернуть импл
[01:44:54.880 --> 01:44:56.880]  у нас есть еще такой специальный крейд
[01:44:56.880 --> 01:44:58.880]  называется quote
[01:44:58.880 --> 01:45:00.880]  он предназначен для того чтобы
[01:45:00.880 --> 01:45:02.880]  вот так вот красивенько просто через
[01:45:02.880 --> 01:45:04.880]  решетку вставлять
[01:45:04.880 --> 01:45:06.880]  примерно из нашего текущего сколпта
[01:45:06.880 --> 01:45:08.880]  то есть он по сути делает то же самое
[01:45:08.880 --> 01:45:10.880]  что формат, но красивый
[01:45:10.880 --> 01:45:12.880]  и более того, как видите даже
[01:45:12.880 --> 01:45:14.880]  у нас есть джентльмены
[01:45:14.880 --> 01:45:16.880]  и у нас есть джентльмены
[01:45:16.880 --> 01:45:18.880]  красивый и более того, как видите даже
[01:45:18.880 --> 01:45:20.880]  минтет и слотеха
[01:45:20.880 --> 01:45:22.880]  справился подсветить весь синтаксис
[01:45:22.880 --> 01:45:24.880]  то есть вы действительно в IDE
[01:45:24.880 --> 01:45:26.880]  будете видеть такой-то внутри quote
[01:45:26.880 --> 01:45:28.880]  адекватный синтаксис и это достаточно удобно
[01:45:30.880 --> 01:45:32.880]  он вам понадобится в домашке
[01:45:32.880 --> 01:45:34.880]  потому что
[01:45:34.880 --> 01:45:36.880]  достаточно удобен
[01:45:36.880 --> 01:45:38.880]  понятно зачем нужен quote
[01:45:42.880 --> 01:45:44.880]  так мы дошли
[01:45:44.880 --> 01:45:46.880]  куда понять span
[01:45:48.880 --> 01:45:50.880]  все это время мы как-то его игнорировали
[01:45:50.880 --> 01:45:52.880]  но span это такая штука
[01:45:52.880 --> 01:45:54.880]  которая нужна для того чтобы привязать
[01:45:54.880 --> 01:45:56.880]  то что у нас происходит в macros
[01:45:56.880 --> 01:45:58.880]  и к тому что у нас
[01:45:58.880 --> 01:46:00.880]  находится на стороне вызывающего quote
[01:46:02.880 --> 01:46:04.880]  есть два use case
[01:46:04.880 --> 01:46:06.880]  во-первых
[01:46:06.880 --> 01:46:08.880]  давайте посмотрим
[01:46:08.880 --> 01:46:10.880]  на наш текущий intriper
[01:46:10.880 --> 01:46:12.880]  что если нам дали два дерева
[01:46:12.880 --> 01:46:14.880]  а мы хотим же только к одному делать
[01:46:14.880 --> 01:46:16.880]  ссылка self на поле
[01:46:18.880 --> 01:46:20.880]  в общем-то если мы
[01:46:20.880 --> 01:46:22.880]  оставим macros таким какой у нас сейчас есть
[01:46:22.880 --> 01:46:24.880]  то в таком случае он сделает ошибку
[01:46:24.880 --> 01:46:26.880]  то есть возникнет ошибка
[01:46:26.880 --> 01:46:28.880]  внутри macros
[01:46:28.880 --> 01:46:30.880]  в текущем macros нет потому что он просто берет
[01:46:30.880 --> 01:46:32.880]  первое поле дерев
[01:46:32.880 --> 01:46:34.880]  если мы делали проверку на то
[01:46:34.880 --> 01:46:36.880]  что в такое поле только одно и выдавали панику
[01:46:36.880 --> 01:46:38.880]  то в таком случае мы бы
[01:46:38.880 --> 01:46:40.880]  компилятор нам говорил что у нас
[01:46:40.880 --> 01:46:42.880]  есть паника внутри macros
[01:46:42.880 --> 01:46:44.880]  в общем-то это плохо
[01:46:44.880 --> 01:46:46.880]  а мы хотим говорить пользователю что у нас macros паниковал
[01:46:46.880 --> 01:46:48.880]  и что вот у тебя тут ошибка
[01:46:48.880 --> 01:46:50.880]  поправь пожалуйста
[01:46:50.880 --> 01:46:52.880]  в конкретном данном случае мы хотим сделать так чтобы пользователь
[01:46:52.880 --> 01:46:54.880]  явно увидел что у него два дерева
[01:46:56.880 --> 01:46:58.880]  давайте мы чуть-чуть поменяем наш код
[01:47:00.880 --> 01:47:02.880]  вот собственно это то зачем нам нужно span
[01:47:02.880 --> 01:47:04.880]  давайте сделаем примерно так
[01:47:06.880 --> 01:47:08.880]  если у нас дерев fills
[01:47:08.880 --> 01:47:10.880]  то мы вывели наши поля
[01:47:12.880 --> 01:47:14.880]  ну до того как мы начали выбирать первое поле
[01:47:14.880 --> 01:47:16.880]  мы получаем наши дерев fills
[01:47:16.880 --> 01:47:18.880]  и давайте проверим что
[01:47:18.880 --> 01:47:20.880]  дна действительно меньше либо равна
[01:47:20.880 --> 01:47:22.880]  равна точнее единицы
[01:47:22.880 --> 01:47:24.880]  если она равна единице
[01:47:24.880 --> 01:47:26.880]  ну больше единицы
[01:47:26.880 --> 01:47:28.880]  то в таком случае будем выдавать ошибку
[01:47:28.880 --> 01:47:30.880]  как видите мы делаем так
[01:47:30.880 --> 01:47:32.880]  мы во-первых пишем ошибку
[01:47:32.880 --> 01:47:34.880]  что мы нашли больше либо равно
[01:47:34.880 --> 01:47:36.880]  двух полей из дерев
[01:47:36.880 --> 01:47:38.880]  во-вторых
[01:47:38.880 --> 01:47:40.880]  мы с помощью span
[01:47:40.880 --> 01:47:42.880]  то есть мы берем дерев fill
[01:47:42.880 --> 01:47:44.880]  ноль span
[01:47:44.880 --> 01:47:46.880]  и вот как видите quote span
[01:47:46.880 --> 01:47:48.880]  это есть такой macros который позволяет нам вернуть
[01:47:50.880 --> 01:47:52.880]  ну quote он же понятное дело
[01:47:52.880 --> 01:47:54.880]  возвращает токен stream
[01:47:54.880 --> 01:47:56.880]  на самом деле то есть error представляет в себе токен stream
[01:47:56.880 --> 01:47:58.880]  когда мы пишем error extent
[01:47:58.880 --> 01:48:00.880]  то мы к текущему токен стриму
[01:48:00.880 --> 01:48:02.880]  который в себе представляет вот этот macros
[01:48:02.880 --> 01:48:04.880]  compile error
[01:48:04.880 --> 01:48:06.880]  дописываем еще один
[01:48:06.880 --> 01:48:08.880]  токен стрим
[01:48:08.880 --> 01:48:10.880]  и дописываем его вот с таким вот span
[01:48:12.880 --> 01:48:14.880]  ну со span вот
[01:48:14.880 --> 01:48:16.880]  поле вот этого вот нулевого
[01:48:16.880 --> 01:48:18.880]  дерев field
[01:48:18.880 --> 01:48:20.880]  и мы говорим что span
[01:48:20.880 --> 01:48:22.880]  это по сути просто кусочек
[01:48:22.880 --> 01:48:24.880]  исходного кода
[01:48:24.880 --> 01:48:26.880]  в исходном user коде
[01:48:26.880 --> 01:48:28.880]  то есть по сути мы говорим
[01:48:28.880 --> 01:48:30.880]  что у нас вот здесь вот ошибка
[01:48:30.880 --> 01:48:32.880]  вот в этом вот span
[01:48:32.880 --> 01:48:34.880]  в этом кусочке кода пользователя
[01:48:34.880 --> 01:48:36.880]  и соответственно
[01:48:36.880 --> 01:48:38.880]  во втором тоже
[01:48:38.880 --> 01:48:40.880]  у нас возникает два вопроса
[01:48:40.880 --> 01:48:42.880]  во-первых чуть-чуть более конкретно
[01:48:42.880 --> 01:48:44.880]  как span работает, во-вторых что такое compile error
[01:48:44.880 --> 01:48:46.880]  и что произошло
[01:48:46.880 --> 01:48:48.880]  что касается compile error
[01:48:48.880 --> 01:48:50.880]  для начала скажу что
[01:48:50.880 --> 01:48:52.880]  когда вы делаете quote
[01:48:52.880 --> 01:48:54.880]  потом вы делаете несколько раз
[01:48:54.880 --> 01:48:56.880]  error extent и возвращаете
[01:48:56.880 --> 01:48:58.880]  error into
[01:48:58.880 --> 01:49:00.880]  то вы пишете в качестве
[01:49:00.880 --> 01:49:02.880]  вывода своего макроса несколько строчек
[01:49:02.880 --> 01:49:04.880]  с compile error
[01:49:04.880 --> 01:49:06.880]  так
[01:49:06.880 --> 01:49:08.880]  это во-первых, во-вторых
[01:49:08.880 --> 01:49:10.880]  если компилятор раста находится
[01:49:10.880 --> 01:49:12.880]  где-то строчку с compile error
[01:49:12.880 --> 01:49:14.880]  им приходится эту строчку компилировать
[01:49:14.880 --> 01:49:16.880]  он выводит ошибку
[01:49:16.880 --> 01:49:18.880]  он говорит что здесь происходит compile error
[01:49:18.880 --> 01:49:20.880]  соответственно мы записали в поток пользователя
[01:49:20.880 --> 01:49:22.880]  то есть в код пользователя
[01:49:22.880 --> 01:49:24.880]  три строчки с compile error
[01:49:24.880 --> 01:49:26.880]  и он получил свою ошибку в
[01:49:26.880 --> 01:49:28.880]  правильном месте с помощью span
[01:49:28.880 --> 01:49:30.880]  вот так вот
[01:49:38.880 --> 01:49:40.880]  и эти макросы уже вскрылись еще раз
[01:49:40.880 --> 01:49:42.880]  да, эти макросы
[01:49:42.880 --> 01:49:44.880]  ну просто смотрите, раст код
[01:49:44.880 --> 01:49:46.880]  как работает
[01:49:46.880 --> 01:49:48.880]  как раз вот это вот я хотел сказать
[01:49:48.880 --> 01:49:50.880]  как код растовский работает
[01:49:50.880 --> 01:49:52.880]  он работает после того как у вас построилось абстрактное синтетическое дерево
[01:49:52.880 --> 01:49:54.880]  если вы ходили на курс компиляторов
[01:49:54.880 --> 01:49:56.880]  по шахтямову, вы наверное не ходили на
[01:49:56.880 --> 01:49:58.880]  компилятор по шахтямову
[01:49:58.880 --> 01:50:00.880]  если вдруг так происходило, то вы наверное знаете
[01:50:00.880 --> 01:50:02.880]  что такое AST
[01:50:02.880 --> 01:50:04.880]  ну AST на себе такие примерно вещи представляет
[01:50:04.880 --> 01:50:06.880]  например там у вас
[01:50:06.880 --> 01:50:08.880]  написано 2 плюс 3
[01:50:08.880 --> 01:50:10.880]  как парчится 2 плюс 3 в абстрактном синтетическом дереве
[01:50:10.880 --> 01:50:12.880]  у вас там получается
[01:50:12.880 --> 01:50:14.880]  бинарная операция плюс
[01:50:14.880 --> 01:50:16.880]  левая операнта это 2
[01:50:16.880 --> 01:50:18.880]  и правая операнта это 3
[01:50:18.880 --> 01:50:20.880]  у вас получается такое дерево
[01:50:20.880 --> 01:50:22.880]  если у вас там еще какие-то скобчики
[01:50:22.880 --> 01:50:24.880]  например 2 плюс 3
[01:50:24.880 --> 01:50:26.880]  и умножить на f от x
[01:50:26.880 --> 01:50:28.880]  в таком случае там получается
[01:50:28.880 --> 01:50:30.880]  раскрытие что типа бинарная операция
[01:50:30.880 --> 01:50:32.880]  бинарная операция 2
[01:50:32.880 --> 01:50:34.880]  плюс
[01:50:34.880 --> 01:50:36.880]  на 2, потом еще одна бинарная операция
[01:50:36.880 --> 01:50:38.880]  левая операнта 3
[01:50:38.880 --> 01:50:40.880]  ну и вы поняли как это работает
[01:50:40.880 --> 01:50:42.880]  вот когда компилятор
[01:50:42.880 --> 01:50:44.880]  это построил, на самом деле
[01:50:44.880 --> 01:50:46.880]  именно после того как он это построил, он вызывает
[01:50:46.880 --> 01:50:48.880]  макроса
[01:50:48.880 --> 01:50:50.880]  он просто запоминает то, что в этом месте должен быть
[01:50:50.880 --> 01:50:52.880]  другой токен 3, где макрос
[01:50:52.880 --> 01:50:54.880]  после этого он вызывает макрос
[01:50:54.880 --> 01:50:56.880]  и вставляет его в токен 3
[01:50:56.880 --> 01:50:58.880]  то есть где он там был
[01:50:58.880 --> 01:51:00.880]  в абстрактном синтетическом дереве
[01:51:00.880 --> 01:51:02.880]  он просто прикручивает уже
[01:51:02.880 --> 01:51:04.880]  вывод макроса
[01:51:04.880 --> 01:51:06.880]  то есть он работает уже на уровне синтаксиса
[01:51:06.880 --> 01:51:08.880]  и соответственно именно по той причине
[01:51:08.880 --> 01:51:10.880]  что мы с самого начала попарчили
[01:51:10.880 --> 01:51:12.880]  код пользователя, а потом вызываем макросы
[01:51:14.880 --> 01:51:16.880]  у нас получается таким образом
[01:51:16.880 --> 01:51:18.880]  что
[01:51:18.880 --> 01:51:20.880]  что у нас
[01:51:20.880 --> 01:51:22.880]  код как
[01:51:22.880 --> 01:51:24.880]  в Define
[01:51:24.880 --> 01:51:26.880]  не валится, что у нас 2 плюс 3
[01:51:26.880 --> 01:51:28.880]  умноженное на 5, потому что у нас
[01:51:28.880 --> 01:51:30.880]  заранее сказано, что
[01:51:30.880 --> 01:51:32.880]  умножение
[01:51:32.880 --> 01:51:34.880]  левая часть этого
[01:51:34.880 --> 01:51:36.880]  нашего макроса, а правая
[01:51:36.880 --> 01:51:38.880]  часть это пятерка, соответственно вы потом подвешиваете
[01:51:38.880 --> 01:51:40.880]  и все нормально работает
[01:51:42.880 --> 01:51:44.880]  какие-то такие дела
[01:51:44.880 --> 01:51:46.880]  это жесть
[01:51:46.880 --> 01:51:48.880]  уметь
[01:51:48.880 --> 01:51:50.880]  подсказывать
[01:51:50.880 --> 01:51:52.880]  конечно большая часть людей
[01:51:52.880 --> 01:51:54.880]  так не делает
[01:51:54.880 --> 01:51:56.880]  в каких-то самых популярных
[01:51:56.880 --> 01:51:58.880]  крейтах
[01:51:58.880 --> 01:52:00.880]  написаны такие вот крутые штуки
[01:52:00.880 --> 01:52:02.880]  это все равно
[01:52:02.880 --> 01:52:04.880]  это просто реально сложная штука
[01:52:04.880 --> 01:52:06.880]  там проработать все кейсы, чтобы пользователь
[01:52:06.880 --> 01:52:08.880]  получил
[01:52:08.880 --> 01:52:10.880]  правильную ошибку
[01:52:14.880 --> 01:52:16.880]  процедурные макросы
[01:52:16.880 --> 01:52:18.880]  кстати как компилируются
[01:52:18.880 --> 01:52:20.880]  раз с самого начала берет
[01:52:20.880 --> 01:52:22.880]  компилирует ваш крейт
[01:52:22.880 --> 01:52:24.880]  с процедурными макросами в такую динамическую библиотеку
[01:52:24.880 --> 01:52:26.880]  на линуксе SO
[01:52:26.880 --> 01:52:28.880]  а потом
[01:52:28.880 --> 01:52:30.880]  после этого он
[01:52:30.880 --> 01:52:32.880]  посылает токен стрим
[01:52:32.880 --> 01:52:34.880]  в динамическую библиотеку, то есть вызывает там функцию
[01:52:34.880 --> 01:52:36.880]  посылает в нее токен 3, получает свой токен 3
[01:52:36.880 --> 01:52:38.880]  и вставляет в код
[01:52:38.880 --> 01:52:40.880]  как-то так
[01:52:40.880 --> 01:52:42.880]  если более конкретным
[01:52:42.880 --> 01:52:44.880]  быть, то наверное лучше посмотреть
[01:52:44.880 --> 01:52:46.880]  попросить у меня
[01:52:46.880 --> 01:52:48.880]  и скину ссылку на толк
[01:52:48.880 --> 01:52:50.880]  одного человека из JetBrains
[01:52:50.880 --> 01:52:52.880]  который занимается
[01:52:52.880 --> 01:52:54.880]  их IDE
[01:52:54.880 --> 01:52:56.880]  для раста, я имею ввиду плагина
[01:52:56.880 --> 01:52:58.880]  он рассказывал как раз про то, как оно компилируется
[01:53:02.880 --> 01:53:04.880]  компайл-эррор
[01:53:04.880 --> 01:53:06.880]  мы вот так вот сделали
[01:53:06.880 --> 01:53:08.880]  таким образом, что если компайл-эррор
[01:53:08.880 --> 01:53:10.880]  компилируется, в одном случае у нас ошибка
[01:53:10.880 --> 01:53:12.880]  и мы как раз записали
[01:53:12.880 --> 01:53:14.880]  к пользователю то, что у нас компайл-эррор
[01:53:14.880 --> 01:53:16.880]  соответственно он получает свою ошибку
[01:53:18.880 --> 01:53:20.880]  итак, спэны
[01:53:20.880 --> 01:53:22.880]  спэны это такое
[01:53:22.880 --> 01:53:24.880]  когда мы пишем в токен 3
[01:53:24.880 --> 01:53:26.880]  мы конечно хоть и явно писали
[01:53:26.880 --> 01:53:28.880]  строчку с компайл-тайм
[01:53:28.880 --> 01:53:30.880]  компайл-эррор и внутри
[01:53:30.880 --> 01:53:32.880]  код, на самом деле код конечно
[01:53:32.880 --> 01:53:34.880]  это преобразует в токен 3
[01:53:34.880 --> 01:53:36.880]  и в токен 3, как мы уже видели
[01:53:36.880 --> 01:53:38.880]  там есть структурки, в которых есть спэны
[01:53:38.880 --> 01:53:40.880]  а спэн бывает разным
[01:53:40.880 --> 01:53:42.880]  он бывает кол-сайт
[01:53:42.880 --> 01:53:44.880]  это означает, что
[01:53:44.880 --> 01:53:46.880]  спэн работает точно так же
[01:53:46.880 --> 01:53:48.880]  как если бы он
[01:53:48.880 --> 01:53:50.880]  это означает, что этот
[01:53:50.880 --> 01:53:52.880]  идентификатор будет рисовываться так, будто
[01:53:52.880 --> 01:53:54.880]  он уже находился в пользовательском коде
[01:53:54.880 --> 01:53:56.880]  то есть пользователь будет его видеть
[01:53:56.880 --> 01:53:58.880]  и все такое
[01:53:58.880 --> 01:54:00.880]  ну и вы будете видеть соответствующий идентификатор
[01:54:00.880 --> 01:54:02.880]  который был уже в коде пользователя
[01:54:02.880 --> 01:54:04.880]  потом есть
[01:54:04.880 --> 01:54:06.880]  mixed-сайт, это то же самое, что в декларативных
[01:54:06.880 --> 01:54:08.880]  макросах, то есть часть видим, часть не видим
[01:54:08.880 --> 01:54:10.880]  в зависимости от того, какой идентификатор
[01:54:10.880 --> 01:54:12.880]  есть dev-сайт
[01:54:12.880 --> 01:54:14.880]  это то, что этот спэн
[01:54:14.880 --> 01:54:16.880]  будет не виден со стороны
[01:54:16.880 --> 01:54:18.880]  кода пользователя
[01:54:18.880 --> 01:54:20.880]  и в общем-то
[01:54:20.880 --> 01:54:22.880]  полезная штука иногда бывает
[01:54:22.880 --> 01:54:24.880]  она только внадль
[01:54:24.880 --> 01:54:26.880]  на данный момент
[01:54:26.880 --> 01:54:28.880]  понятно, что такое
[01:54:28.880 --> 01:54:30.880]  спэн?
[01:54:30.880 --> 01:54:32.880]  мы просто
[01:54:32.880 --> 01:54:34.880]  идентификатором присваиваем спэн, а спэн
[01:54:34.880 --> 01:54:36.880]  говорит, как нам рисовывать
[01:54:36.880 --> 01:54:38.880]  то есть как раз то, как у нас работает гигиен
[01:54:38.880 --> 01:54:40.880]  в расти
[01:54:40.880 --> 01:54:42.880]  что-то похоже на
[01:54:42.880 --> 01:54:44.880]  чуть-чуть похоже на дальнего роста
[01:54:44.880 --> 01:54:46.880]  из плюсов слуш-локейшн
[01:54:46.880 --> 01:54:48.880]  но он только похож
[01:54:48.880 --> 01:54:50.880]  откуда, не знаю
[01:54:50.880 --> 01:54:52.880]  слуш-локейшн
[01:54:52.880 --> 01:54:54.880]  это прикольный класс плюсов и плюсов
[01:54:54.880 --> 01:54:56.880]  который позволяет
[01:54:56.880 --> 01:54:58.880]  сохранить какую-то инфу
[01:54:58.880 --> 01:55:00.880]  о каком-то месте в коде, типа
[01:55:00.880 --> 01:55:02.880]  ими файлы, ими функции, ими строки
[01:55:02.880 --> 01:55:04.880]  и столбец
[01:55:04.880 --> 01:55:06.880]  получается
[01:55:06.880 --> 01:55:08.880]  и вот эту инфу передавать нам походу
[01:55:08.880 --> 01:55:10.880]  ну там у нас конечно не столбец
[01:55:10.880 --> 01:55:12.880]  не строка, а у нас именно к идентификатору что-то
[01:55:12.880 --> 01:55:14.880]  привешивается
[01:55:14.880 --> 01:55:16.880]  там по ошибке
[01:55:16.880 --> 01:55:18.880]  конфигурация
[01:55:18.880 --> 01:55:20.880]  смотри, у нас прям строчечка
[01:55:20.880 --> 01:55:22.880]  видишь, он показывает, типа, потому что у нас спэн начинается
[01:55:22.880 --> 01:55:24.880]  в этом атрибуте, а мы как раз к атрибуту
[01:55:24.880 --> 01:55:26.880]  спэн атрибуты, это приветствие
[01:55:26.880 --> 01:55:28.880]  ну как бы от спэна здесь у нас
[01:55:28.880 --> 01:55:30.880]  только, собственно
[01:55:30.880 --> 01:55:32.880]  что с этими вертикальными гардинами
[01:55:32.880 --> 01:55:34.880]  какими вертикальными, сейчас еще раз
[01:55:34.880 --> 01:55:36.880]  ну вот у нас тут 3 сегмента
[01:55:36.880 --> 01:55:38.880]  с вертикальными чертичками
[01:55:38.880 --> 01:55:40.880]  вот это все как раз
[01:55:40.880 --> 01:55:42.880]  что касается спэна
[01:55:42.880 --> 01:55:44.880]  да, ну вообще
[01:55:44.880 --> 01:55:46.880]  вот эта вот первая ошибка
[01:55:46.880 --> 01:55:48.880]  вот эта вот уже касается спэна
[01:55:48.880 --> 01:55:50.880]  вторая и третья, вот мы как раз писали, видишь
[01:55:50.880 --> 01:55:52.880]  draftField 0.span
[01:55:52.880 --> 01:55:54.880]  вот мы взяли спэн и указали, что здесь вот
[01:55:54.880 --> 01:55:56.880]  first draftField
[01:55:56.880 --> 01:55:58.880]  вот
[01:55:58.880 --> 01:56:00.880]  можно, кстати, наверное, сделать
[01:56:00.880 --> 01:56:02.880]  даже адекватнее
[01:56:02.880 --> 01:56:04.880]  но я уже искренне не эксперт
[01:56:04.880 --> 01:56:06.880]  процедурных макросов, чтобы такое делать
[01:56:06.880 --> 01:56:08.880]  но, наверное, можно сделать прям как компилятор
[01:56:08.880 --> 01:56:10.880]  error, ну, то есть, тоже такую же ошибку
[01:56:10.880 --> 01:56:12.880]  а после этого там note, the first
[01:56:12.880 --> 01:56:14.880]  то есть, именно чтобы не error, была note
[01:56:14.880 --> 01:56:16.880]  и оно было нормально
[01:56:16.880 --> 01:56:18.880]  а можно делать вот такие же
[01:56:18.880 --> 01:56:20.880]  хитрые
[01:56:20.880 --> 01:56:22.880]  и хитрую графику в консоли
[01:56:22.880 --> 01:56:24.880]  когда он...
[01:56:24.880 --> 01:56:26.880]  да, когда он
[01:56:26.880 --> 01:56:28.880]  с borrowing объясняет, где они там
[01:56:28.880 --> 01:56:30.880]  очередной раз ошибся, и такой
[01:56:30.880 --> 01:56:32.880]  о, фу
[01:56:32.880 --> 01:56:34.880]  тут borrow, тут borrow, хитрует
[01:56:34.880 --> 01:56:36.880]  и вот иди отсюда
[01:56:36.880 --> 01:56:38.880]  так, ну, как-то так
[01:56:38.880 --> 01:56:40.880]  в общем, спэна
[01:56:40.880 --> 01:56:42.880]  вот, такая вот штука
[01:56:42.880 --> 01:56:44.880]  работает точно так же, как будто
[01:56:44.880 --> 01:56:46.880]  она была объявлена именно
[01:56:46.880 --> 01:56:48.880]  в коде пользователя
[01:56:48.880 --> 01:56:50.880]  то есть, lightFoo равняется foo
[01:56:50.880 --> 01:56:52.880]  будет затенять наш
[01:56:52.880 --> 01:56:54.880]  будет foo в коде пользователя
[01:56:54.880 --> 01:56:56.880]  вот
[01:56:56.880 --> 01:56:58.880]  callSite это
[01:56:58.880 --> 01:57:00.880]  дефолтное значение
[01:57:00.880 --> 01:57:02.880]  для спэна у процедурных макросов
[01:57:02.880 --> 01:57:04.880]  то есть, процедурные макросы напоминают
[01:57:04.880 --> 01:57:06.880]  совершенно не гигиенично
[01:57:08.880 --> 01:57:10.880]  почему код spend принимает
[01:57:10.880 --> 01:57:12.880]  какой-то матч?
[01:57:12.880 --> 01:57:14.880]  ну, ты же хочешь сказать
[01:57:14.880 --> 01:57:16.880]  какой spend чему?
[01:57:18.880 --> 01:57:20.880]  типа, ну, просто так красиво
[01:57:20.880 --> 01:57:22.880]  а как ты хотел?
[01:57:22.880 --> 01:57:24.880]  типа, в скобочках написать
[01:57:24.880 --> 01:57:26.880]  то есть, получается, что, ну да
[01:57:26.880 --> 01:57:28.880]  код spend там свой парчер вот этих матчей
[01:57:28.880 --> 01:57:30.880]  да, там код spend, там
[01:57:30.880 --> 01:57:32.880]  именно парчер
[01:57:32.880 --> 01:57:34.880]  просто пока я
[01:57:34.880 --> 01:57:36.880]  видел все эти примеры
[01:57:36.880 --> 01:57:38.880]  там только одна стрельба
[01:57:38.880 --> 01:57:40.880]  а сейчас, почему спэны могут быть разными?
[01:57:40.880 --> 01:57:42.880]  ну да, ну там
[01:57:42.880 --> 01:57:44.880]  вот этот матч, почему несколько матча?
[01:57:44.880 --> 01:57:46.880]  смотри, у нас вот это три варианта
[01:57:46.880 --> 01:57:48.880]  еще у нас от полей там спэн
[01:57:48.880 --> 01:57:50.880]  давай покажу там
[01:57:50.880 --> 01:57:52.880]  наверное про это речь
[01:57:52.880 --> 01:57:54.880]  вот видишь, где спэны
[01:57:54.880 --> 01:57:56.880]  они влитраловывают в идентификаторах мактуации
[01:58:04.880 --> 01:58:06.880]  так
[01:58:06.880 --> 01:58:08.880]  ну, мы, кстати, подходим уже к концу
[01:58:08.880 --> 01:58:10.880]  нашей лекции, несмотря на то, что у нас
[01:58:10.880 --> 01:58:12.880]  целых 40 минут
[01:58:12.880 --> 01:58:14.880]  130 слайдов
[01:58:14.880 --> 01:58:16.880]  очень быстро пошли
[01:58:16.880 --> 01:58:18.880]  так, есть ли
[01:58:18.880 --> 01:58:20.880]  процедурное макросе у прочих?
[01:58:22.880 --> 01:58:24.880]  блин, ну крутая вещь
[01:58:24.880 --> 01:58:26.880]  ну да, процедурное макросе
[01:58:26.880 --> 01:58:28.880]  это круто, но писать их сложно
[01:58:28.880 --> 01:58:30.880]  подумайте несколько раз про чем это делать
[01:58:30.880 --> 01:58:32.880]  потому что их нужно будет поддерживать
[01:58:32.880 --> 01:58:34.880]  все такое
[01:58:34.880 --> 01:58:36.880]  нужно поддерживать, ну не экспортируем их
[01:58:36.880 --> 01:58:38.880]  или нормально
[01:58:38.880 --> 01:58:40.880]  поддерживать
[01:58:40.880 --> 01:58:42.880]  так не работает
[01:58:42.880 --> 01:58:44.880]  я написал, оно работает
[01:58:44.880 --> 01:58:46.880]  хорошо
[01:58:46.880 --> 01:58:48.880]  просто
[01:58:48.880 --> 01:58:50.880]  какой-то трейд-оп
[01:58:50.880 --> 01:58:52.880]  что мне лучше
[01:58:52.880 --> 01:58:54.880]  создать какой-то красивый макрос
[01:58:54.880 --> 01:58:56.880]  ну, словно я пишу библиотепу
[01:58:56.880 --> 01:58:58.880]  для ботов
[01:58:58.880 --> 01:59:00.880]  для телеграмм
[01:59:00.880 --> 01:59:02.880]  и так далее
[01:59:02.880 --> 01:59:04.880]  у меня есть два выбора
[01:59:04.880 --> 01:59:06.880]  либо я создаю макрос
[01:59:06.880 --> 01:59:08.880]  который мне создает объект ботас
[01:59:08.880 --> 01:59:10.880]  с которым я уже интерактирую
[01:59:10.880 --> 01:59:12.880]  либо я создаю фабрику
[01:59:12.880 --> 01:59:14.880]  ну это сильно зависит от ситуации
[01:59:14.880 --> 01:59:16.880]  какой у тебя бот
[01:59:16.880 --> 01:59:18.880]  если у тебя фабрика ботов
[01:59:18.880 --> 01:59:20.880]  ну если такой вариант есть
[01:59:20.880 --> 01:59:22.880]  то скорее всего тебе лучше так и написать
[01:59:22.880 --> 01:59:24.880]  чем макрос, макрос сложнее писать
[01:59:24.880 --> 01:59:26.880]  ну если тебе нужна прям какая-то внутри
[01:59:26.880 --> 01:59:28.880]  кастомизация сильно
[01:59:28.880 --> 01:59:30.880]  например, у меня на работе
[01:59:30.880 --> 01:59:32.880]  мы с помощью дирайвов
[01:59:32.880 --> 01:59:34.880]  ну это понятно все плюс-плюс
[01:59:34.880 --> 01:59:36.880]  но мы с помощью дирайвов объявляем
[01:59:36.880 --> 01:59:38.880]  gRPC сервер, у нас там тупая подстановка
[01:59:38.880 --> 01:59:40.880]  ну просто потому что gRPC сервер
[01:59:40.880 --> 01:59:42.880]  нам нужно много
[01:59:42.880 --> 01:59:44.880]  они достаточно у нас глупо выглядят
[01:59:44.880 --> 01:59:46.880]  поэтому у нас таким образом все устроено
[01:59:46.880 --> 01:59:48.880]  если тебе нужна какая-то кастомизация
[01:59:48.880 --> 01:59:50.880]  например, gRPC сервер
[01:59:50.880 --> 01:59:52.880]  что он возвращает
[01:59:52.880 --> 01:59:54.880]  каким-то образом
[01:59:54.880 --> 01:59:56.880]  что
[01:59:56.880 --> 01:59:58.880]  что сохраняет
[01:59:58.880 --> 02:00:00.880]  ну в общем
[02:00:00.880 --> 02:00:02.880]  в широком смысле кастомизации
[02:00:02.880 --> 02:00:04.880]  то возможно процедурный макрос
[02:00:04.880 --> 02:00:06.880]  будет гораздо лучше
[02:00:06.880 --> 02:00:08.880]  даже невозможно точно
[02:00:08.880 --> 02:00:10.880]  а если у тебя боты такие достаточно одинаковые
[02:00:10.880 --> 02:00:12.880]  то фабрика лучше
[02:00:14.880 --> 02:00:16.880]  ну то есть выбирай всегда самый простой инструмент
[02:00:16.880 --> 02:00:18.880]  который тебе подходит
[02:00:20.880 --> 02:00:22.880]  так, я еще хотел сказать про серд немножко
[02:00:24.880 --> 02:00:26.880]  вообще вся эта штука, все эти дирайвы
[02:00:26.880 --> 02:00:28.880]  они
[02:00:28.880 --> 02:00:30.880]  появились не в последнюю очередь
[02:00:30.880 --> 02:00:32.880]  потому что в расте есть такая библиотека
[02:00:32.880 --> 02:00:34.880]  собственно серд это такая
[02:00:34.880 --> 02:00:36.880]  state of the art библиотека
[02:00:36.880 --> 02:00:38.880]  она крутейшая сейчас
[02:00:38.880 --> 02:00:40.880]  и
[02:00:40.880 --> 02:00:42.880]  настолько крутая, что в принципе можно сказать
[02:00:42.880 --> 02:00:44.880]  что это лучшее в мире решение
[02:00:44.880 --> 02:00:46.880]  вы там можете с помощью дирайв макросов
[02:00:46.880 --> 02:00:48.880]  очень-очень быстро кастомизировать
[02:00:48.880 --> 02:00:50.880]  то как у вас
[02:00:50.880 --> 02:00:52.880]  это очень удобно и очень
[02:00:52.880 --> 02:00:54.880]  лаконично, многословно скажем так
[02:00:54.880 --> 02:00:56.880]  то как у вас будет
[02:00:56.880 --> 02:00:58.880]  децерилизоваться и децерилизоваться код
[02:00:58.880 --> 02:01:00.880]  я вам очень советую посмотреть на эту библиотеку
[02:01:00.880 --> 02:01:02.880]  чтобы понять
[02:01:02.880 --> 02:01:04.880]  как же все-таки выглядит процедурная макрос
[02:01:04.880 --> 02:01:06.880]  какая у них красота
[02:01:06.880 --> 02:01:08.880]  и в общем
[02:01:08.880 --> 02:01:10.880]  как-то приисполнится
[02:01:10.880 --> 02:01:12.880]  и порадоваться за то, что в расте есть такая прекрасная библиотека
[02:01:12.880 --> 02:01:14.880]  которая наверное сейчас самая лучшая в мире
[02:01:14.880 --> 02:01:16.880]  в смысле
[02:01:16.880 --> 02:01:18.880]  серилизация и децерилизация и не в последнюю очередь
[02:01:18.880 --> 02:01:20.880]  потому что есть механизм процедурных макросов
[02:01:20.880 --> 02:01:22.880]  который позволяет
[02:01:22.880 --> 02:01:24.880]  кастомизировать такие штуки
[02:01:26.880 --> 02:01:28.880]  давайте такую
[02:01:28.880 --> 02:01:30.880]  небольшую буквально заминочную часть лекции
[02:01:30.880 --> 02:01:32.880]  посмотрим
[02:01:32.880 --> 02:01:34.880]  есть макросы в стандартной библиотеке
[02:01:34.880 --> 02:01:36.880]  некоторые
[02:01:36.880 --> 02:01:38.880]  во-первых нам нужно поговорить
[02:01:38.880 --> 02:01:40.880]  о conditional compilation
[02:01:42.880 --> 02:01:44.880]  в общем-то бывает такое
[02:01:44.880 --> 02:01:46.880]  что нам нужно что-то компилировать
[02:01:46.880 --> 02:01:48.880]  одним образом под юнию, с другим образом под виндос
[02:01:48.880 --> 02:01:50.880]  в общем
[02:01:50.880 --> 02:01:52.880]  кфг как вы уже заметили
[02:01:52.880 --> 02:01:54.880]  это какой-то атрибутный макрос
[02:01:54.880 --> 02:01:56.880]  вот он
[02:01:56.880 --> 02:01:58.880]  смотрит в компайл тайме на наши
[02:01:58.880 --> 02:02:00.880]  фичи, которые мы объявили
[02:02:00.880 --> 02:02:02.880]  собственно
[02:02:02.880 --> 02:02:04.880]  уникс, когда мы пишем
[02:02:04.880 --> 02:02:06.880]  то мы имеем ввиду, что тарги то сравняются уникс
[02:02:06.880 --> 02:02:08.880]  то что делает кфг
[02:02:08.880 --> 02:02:10.880]  это по сути просто удаляет
[02:02:10.880 --> 02:02:12.880]  функцию
[02:02:12.880 --> 02:02:14.880]  если
[02:02:14.880 --> 02:02:16.880]  не выполнять условия внутри
[02:02:18.880 --> 02:02:20.880]  ну и в общем-то какой недостаток
[02:02:20.880 --> 02:02:22.880]  у этого всего дела есть
[02:02:22.880 --> 02:02:24.880]  у conditional compilation raster
[02:02:24.880 --> 02:02:26.880]  например
[02:02:26.880 --> 02:02:28.880]  если у вас
[02:02:28.880 --> 02:02:30.880]  в общем если вы разрабатываете
[02:02:30.880 --> 02:02:32.880]  например под линуксом
[02:02:32.880 --> 02:02:34.880]  и в том числе у вас есть код под виндос
[02:02:34.880 --> 02:02:36.880]  то вы не сможете найти ошибку
[02:02:36.880 --> 02:02:38.880]  в коде под виндос до того как вы
[02:02:38.880 --> 02:02:40.880]  скомпилируете этот код
[02:02:40.880 --> 02:02:42.880]  потому что буквально макросы вырезают
[02:02:42.880 --> 02:02:44.880]  кусок кода
[02:02:44.880 --> 02:02:46.880]  и соответственно даже если у вас
[02:02:46.880 --> 02:02:48.880]  будет синтактические ошибки
[02:02:48.880 --> 02:02:50.880]  раст на вас злиться не будет
[02:02:50.880 --> 02:02:52.880]  потому что он брен
[02:02:52.880 --> 02:02:54.880]  я это все вырезал
[02:02:54.880 --> 02:02:56.880]  а нет
[02:02:56.880 --> 02:02:58.880]  синтактические ошибки
[02:02:58.880 --> 02:03:00.880]  словят, а какие-то там
[02:03:00.880 --> 02:03:02.880]  еще нет
[02:03:02.880 --> 02:03:04.880]  которые идут уже после макросов
[02:03:04.880 --> 02:03:06.880]  я сам не припомню в каком порядке
[02:03:06.880 --> 02:03:08.880]  получается этот макрос
[02:03:08.880 --> 02:03:10.880]  вырубает из кода
[02:03:10.880 --> 02:03:12.880]  какую-то функцию
[02:03:12.880 --> 02:03:14.880]  примерно как работает Define
[02:03:14.880 --> 02:03:16.880]  только видишь гораздо красивее и лучше
[02:03:16.880 --> 02:03:18.880]  т.е. кфг, виндос,
[02:03:18.880 --> 02:03:20.880]  кфг, уникс, все красиво
[02:03:20.880 --> 02:03:22.880]  два слайда одинаковых
[02:03:22.880 --> 02:03:24.880]  получилось
[02:03:26.880 --> 02:03:28.880]  то, что он точно делает
[02:03:28.880 --> 02:03:30.880]  какие-то конфигурационные флаги
[02:03:30.880 --> 02:03:32.880]  какие-то Boolean условия
[02:03:32.880 --> 02:03:34.880]  на них проверяют
[02:03:34.880 --> 02:03:36.880]  более того, вы можете его вызывать
[02:03:36.880 --> 02:03:38.880]  не только как атрибут макрос
[02:03:38.880 --> 02:03:40.880]  но и как функционал-лайк макрос
[02:03:40.880 --> 02:03:42.880]  например, let my directory
[02:03:42.880 --> 02:03:44.880]  у нас есть пример
[02:03:44.880 --> 02:03:46.880]  если конфиг это виндос
[02:03:46.880 --> 02:03:48.880]  как вы понимаете, это в компайл тайме
[02:03:48.880 --> 02:03:50.880]  превратится в true либо false
[02:03:50.880 --> 02:03:52.880]  соответственно здесь будет
[02:03:52.880 --> 02:03:54.880]  специфичная для винды директория
[02:03:54.880 --> 02:03:56.880]  и здесь вы должны гарантировать
[02:03:56.880 --> 02:03:58.880]  то, что у вас обе ветки компилируются
[02:03:58.880 --> 02:04:00.880]  все с ними хорошо
[02:04:00.880 --> 02:04:02.880]  потому что они действительно
[02:04:02.880 --> 02:04:04.880]  обе будут компилироваться
[02:04:04.880 --> 02:04:06.880]  это удобно тогда, когда
[02:04:06.880 --> 02:04:08.880]  нужно какие-то константы
[02:04:08.880 --> 02:04:10.880]  прописать
[02:04:10.880 --> 02:04:12.880]  такой кфг удобен
[02:04:14.880 --> 02:04:16.880]  такие паттерны вы тоже видели в домашке
[02:04:16.880 --> 02:04:18.880]  у нас кфг-тест
[02:04:18.880 --> 02:04:20.880]  тест это тоже какое-то
[02:04:20.880 --> 02:04:22.880]  макрос
[02:04:22.880 --> 02:04:24.880]  тест это тоже какое-то
[02:04:24.880 --> 02:04:26.880]  условие
[02:04:26.880 --> 02:04:28.880]  во время компиляции программы
[02:04:30.880 --> 02:04:32.880]  тест это атрибут, который
[02:04:32.880 --> 02:04:34.880]  собственно
[02:04:34.880 --> 02:04:36.880]  превращает нашу функцию в тест
[02:04:36.880 --> 02:04:38.880]  добавляет там трамплин, который
[02:04:38.880 --> 02:04:40.880]  выводит в конце теста
[02:04:40.880 --> 02:04:42.880]  что он успешно идет
[02:04:42.880 --> 02:04:44.880]  либо если тест идет слишком долго
[02:04:44.880 --> 02:04:46.880]  работали больше 60 секунд
[02:04:46.880 --> 02:04:48.880]  возможно в домашке увидели когда-нибудь
[02:04:48.880 --> 02:04:50.880]  если у вас слишком долго
[02:04:50.880 --> 02:04:52.880]  умудрялась работать программу
[02:04:54.880 --> 02:04:56.880]  и кфг-тест будет его вырезать
[02:04:56.880 --> 02:04:58.880]  либо добавлять модуль в данном случае
[02:05:02.880 --> 02:05:04.880]  это из главы модули
[02:05:04.880 --> 02:05:06.880]  нас супер означает родителей
[02:05:06.880 --> 02:05:08.880]  то есть использует все из корневого модуля
[02:05:08.880 --> 02:05:10.880]  если учесть, что
[02:05:10.880 --> 02:05:12.880]  корневой модуль сразу же после теста
[02:05:12.880 --> 02:05:14.880]  ну как вы понимаете
[02:05:14.880 --> 02:05:16.880]  тесты никогда не будут
[02:05:16.880 --> 02:05:18.880]  в бинарнике
[02:05:18.880 --> 02:05:20.880]  в таком случае
[02:05:20.880 --> 02:05:22.880]  потому что у вас тест никогда не работает
[02:05:22.880 --> 02:05:24.880]  до тех пор, пока не напишете кфг-тест
[02:05:24.880 --> 02:05:26.880]  у вас просто не включена нужная фича
[02:05:26.880 --> 02:05:28.880]  ух ты
[02:05:28.880 --> 02:05:30.880]  это я забыл
[02:05:30.880 --> 02:05:32.880]  поставить обратный слэш
[02:05:32.880 --> 02:05:34.880]  на это
[02:05:34.880 --> 02:05:36.880]  но не подчеркиваю
[02:05:36.880 --> 02:05:38.880]  не собираюсь
[02:05:38.880 --> 02:05:40.880]  подчеркивать
[02:05:40.880 --> 02:05:42.880]  но нижнее подчеркивание
[02:05:42.880 --> 02:05:44.880]  тех пожаловаться
[02:05:44.880 --> 02:05:46.880]  таким образом
[02:05:46.880 --> 02:05:48.880]  очень необычным
[02:05:48.880 --> 02:05:50.880]  в общем
[02:05:50.880 --> 02:05:52.880]  есть такие еще макросы nth и option nth
[02:05:52.880 --> 02:05:54.880]  nth
[02:05:54.880 --> 02:05:56.880]  он проверяет во время компайл тайма
[02:05:56.880 --> 02:05:58.880]  то, что у вас есть в environmental variables
[02:05:58.880 --> 02:06:00.880]  и option nth
[02:06:00.880 --> 02:06:02.880]  соответственно делает то же самое, но только если nth
[02:06:02.880 --> 02:06:04.880]  он прям паникует во время компиляции
[02:06:04.880 --> 02:06:06.880]  то option nth возвращает option
[02:06:06.880 --> 02:06:08.880]  была ли такая опция во время компиляции
[02:06:08.880 --> 02:06:10.880]  вот
[02:06:10.880 --> 02:06:12.880]  ну как видите
[02:06:12.880 --> 02:06:14.880]  можно pf вывести
[02:06:14.880 --> 02:06:16.880]  который был во время компиляции
[02:06:16.880 --> 02:06:18.880]  примерно таким образом
[02:06:18.880 --> 02:06:20.880]  кстати
[02:06:20.880 --> 02:06:22.880]  вот здесь вот плохо, а вот здесь вот хорошо
[02:06:22.880 --> 02:06:24.880]  посмотрите на то
[02:06:24.880 --> 02:06:26.880]  как оно должно быть
[02:06:26.880 --> 02:06:28.880]  как-то у меня иногда
[02:06:28.880 --> 02:06:30.880]  бывают проблемы
[02:06:30.880 --> 02:06:32.880]  даже насправе на то, что пересматриваю слайды
[02:06:32.880 --> 02:06:34.880]  все равно как-то странно
[02:06:34.880 --> 02:06:36.880]  еще есть stringify
[02:06:36.880 --> 02:06:38.880]  даже хотелось бы отдаленно сказать
[02:06:38.880 --> 02:06:40.880]  eval, но на самом деле конечно же
[02:06:40.880 --> 02:06:42.880]  совсем не eval
[02:06:42.880 --> 02:06:44.880]  он просто превращает то, что внутри написано
[02:06:44.880 --> 02:06:46.880]  в строчку
[02:06:46.880 --> 02:06:48.880]  да, да
[02:06:48.880 --> 02:06:50.880]  просто
[02:06:50.880 --> 02:06:52.880]  превращает то, что ему выдали
[02:06:52.880 --> 02:06:54.880]  в строчку
[02:06:54.880 --> 02:06:56.880]  например, можно написать
[02:06:56.880 --> 02:06:58.880]  типа аргумента
[02:06:58.880 --> 02:07:00.880]  с помощью stringify
[02:07:00.880 --> 02:07:02.880]  с чем это может понравиться?
[02:07:02.880 --> 02:07:04.880]  просто кобычки
[02:07:04.880 --> 02:07:06.880]  в данном случае
[02:07:06.880 --> 02:07:08.880]  ты можешь захотеть кобычки
[02:07:08.880 --> 02:07:10.880]  а так вообще stringify
[02:07:10.880 --> 02:07:12.880]  может быть удобно
[02:07:12.880 --> 02:07:14.880]  если тебе хочется
[02:07:14.880 --> 02:07:16.880]  например, удобнее написать внутри типа аргумента
[02:07:16.880 --> 02:07:18.880]  в таком случае
[02:07:18.880 --> 02:07:20.880]  то есть это такая
[02:07:20.880 --> 02:07:22.880]  useful вещь, когда вы уже
[02:07:22.880 --> 02:07:24.880]  метапрограммированием каким-то занимаетесь
[02:07:24.880 --> 02:07:26.880]  тогда stringify будет полезен
[02:07:26.880 --> 02:07:28.880]  в таком примере искусственном
[02:07:28.880 --> 02:07:30.880]  конечно нет
[02:07:30.880 --> 02:07:32.880]  еще есть такие include string
[02:07:32.880 --> 02:07:34.880]  такие include string и include bytes
[02:07:34.880 --> 02:07:36.880]  как я говорил
[02:07:36.880 --> 02:07:38.880]  например, ставить картиночку
[02:07:38.880 --> 02:07:40.880]  там include bytes
[02:07:40.880 --> 02:07:42.880]  или, например, ставить какой-то текст
[02:07:42.880 --> 02:07:44.880]  словарик в программу
[02:07:44.880 --> 02:07:46.880]  прям исходный текст
[02:07:46.880 --> 02:07:48.880]  просто делать include string
[02:07:48.880 --> 02:07:50.880]  то, что он делает
[02:07:50.880 --> 02:07:52.880]  он в качестве правой части
[02:07:52.880 --> 02:07:54.880]  заменяет это на здоровенную строку
[02:07:54.880 --> 02:07:56.880]  которая себе представляет
[02:07:56.880 --> 02:07:58.880]  то, что находится в Spanish In
[02:07:58.880 --> 02:08:00.880]  во время компиляции
[02:08:02.880 --> 02:08:04.880]  если файл большой
[02:08:06.880 --> 02:08:08.880]  большой бинарник
[02:08:12.880 --> 02:08:14.880]  нужно думать, прежде чем
[02:08:14.880 --> 02:08:16.880]  стволить такие файлы
[02:08:18.880 --> 02:08:20.880]  это бывает полезно
[02:08:26.880 --> 02:08:28.880]  иногда бывает же, чтобы удобнее было клиенту
[02:08:28.880 --> 02:08:30.880]  просто передать бинарник
[02:08:30.880 --> 02:08:32.880]  без того, чтобы передавать
[02:08:32.880 --> 02:08:34.880]  все папки
[02:08:36.880 --> 02:08:38.880]  еще есть такие атрибуты разные
[02:08:38.880 --> 02:08:40.880]  hello, warn, deny, forbid
[02:08:40.880 --> 02:08:42.880]  с hello вы уже знакомы
[02:08:42.880 --> 02:08:44.880]  как я уже говорил
[02:08:44.880 --> 02:08:46.880]  в клипе на NeedlessCollect
[02:08:46.880 --> 02:08:48.880]  можно сделать hello
[02:08:48.880 --> 02:08:50.880]  в таком случае у вас разрешится
[02:08:50.880 --> 02:08:52.880]  использование
[02:08:52.880 --> 02:08:54.880]  в общем, разрешится этот warning
[02:08:54.880 --> 02:08:56.880]  в клипе
[02:08:56.880 --> 02:08:58.880]  можно всякие deprecation
[02:08:58.880 --> 02:09:00.880]  ноуты сделать
[02:09:00.880 --> 02:09:02.880]  то есть сказать, что эта функция
[02:09:02.880 --> 02:09:04.880]  будет скоро deprecated
[02:09:04.880 --> 02:09:06.880]  в скобочках
[02:09:06.880 --> 02:09:08.880]  эта функция будет скоро
[02:09:08.880 --> 02:09:10.880]  используется вместо это
[02:09:10.880 --> 02:09:12.880]  тогда, когда человек будет компилировать свой код
[02:09:12.880 --> 02:09:14.880]  он получит warning
[02:09:14.880 --> 02:09:16.880]  в котором будет это написано
[02:09:18.880 --> 02:09:20.880]  это бывает удобно
[02:09:20.880 --> 02:09:22.880]  особенно удобно, если вы разрабатываете какие-то библиотики
[02:09:28.880 --> 02:09:30.880]  это паника
[02:09:30.880 --> 02:09:32.880]  это ошибка
[02:09:32.880 --> 02:09:34.880]  которую раз
[02:09:34.880 --> 02:09:36.880]  не может обработать
[02:09:38.880 --> 02:09:40.880]  не перед каждым молоком
[02:09:40.880 --> 02:09:42.880]  а после молока
[02:09:42.880 --> 02:09:44.880]  он смотрит на NLPT
[02:09:46.880 --> 02:09:48.880]  насколько я помню
[02:09:48.880 --> 02:09:50.880]  в плюсах new делает
[02:09:50.880 --> 02:09:52.880]  exception
[02:09:52.880 --> 02:09:54.880]  можно в нескольких вариантах использовать
[02:09:54.880 --> 02:09:56.880]  по дефолту бросает
[02:09:56.880 --> 02:09:58.880]  по дефолту бросает
[02:09:58.880 --> 02:10:00.880]  в расе
[02:10:00.880 --> 02:10:02.880]  тоже нужно, кстати
[02:10:02.880 --> 02:10:04.880]  настроить
[02:10:04.880 --> 02:10:06.880]  там можно сделать так, чтобы
[02:10:06.880 --> 02:10:08.880]  паника получает
[02:10:08.880 --> 02:10:10.880]  unwinding
[02:10:10.880 --> 02:10:12.880]  она раскручивается
[02:10:12.880 --> 02:10:14.880]  можно сделать abort
[02:10:14.880 --> 02:10:16.880]  если происходит паника
[02:10:16.880 --> 02:10:18.880]  вместо stack unwinding происходит abort
[02:10:18.880 --> 02:10:20.880]  это даже не то, что удобно
[02:10:20.880 --> 02:10:22.880]  а жизненно необходимо
[02:10:22.880 --> 02:10:24.880]  когда вы с новой стедей разрабатываете
[02:10:24.880 --> 02:10:26.880]  и там вы панику не обрабатываете
[02:10:28.880 --> 02:10:30.880]  просто программу ломаете
[02:10:30.880 --> 02:10:32.880]  новой стедей это все еще зло или нет?
[02:10:34.880 --> 02:10:36.880]  в каком смысле зло?
[02:10:38.880 --> 02:10:40.880]  это же не зло
[02:10:40.880 --> 02:10:42.880]  я просто говорил, что есть люди, которые пишут
[02:10:42.880 --> 02:10:44.880]  в качестве фичи новой стедей
[02:10:44.880 --> 02:10:46.880]  но новой стедей это не одитеф фича
[02:10:48.880 --> 02:10:50.880]  если ты добавляешь стедей
[02:10:50.880 --> 02:10:52.880]  ты добавляешь стандартную библиотеку
[02:10:52.880 --> 02:10:54.880]  а если ты добавляешь новой стедей
[02:10:54.880 --> 02:10:56.880]  у тебя что-то удаляется
[02:10:56.880 --> 02:10:58.880]  а карга предполагает, что у тебя добавляется
[02:10:58.880 --> 02:11:00.880]  только с каждой фичой
[02:11:00.880 --> 02:11:02.880]  то есть отдельно получается фича карга
[02:11:02.880 --> 02:11:04.880]  и отдельно вот эта фича?
[02:11:06.880 --> 02:11:08.880]  новой стедей это просто какой-то макрос
[02:11:08.880 --> 02:11:10.880]  который говорит, что не нужно мне в прелюд
[02:11:10.880 --> 02:11:12.880]  писать стд
[02:11:14.880 --> 02:11:16.880]  colt это всякие оптимизации
[02:11:18.880 --> 02:11:20.880]  если вы знаете, что эта функция никогда не вызывается
[02:11:20.880 --> 02:11:22.880]  то вы можете сказать компилятору
[02:11:22.880 --> 02:11:24.880]  забей на эту функцию
[02:11:24.880 --> 02:11:26.880]  и оптимизируйте соответствующим образом
[02:11:26.880 --> 02:11:28.880]  мы еще будем смотреть
[02:11:28.880 --> 02:11:30.880]  на всякие вещи, надеюсь
[02:11:30.880 --> 02:11:32.880]  должна была быть всякая
[02:11:32.880 --> 02:11:34.880]  целая лекция про разоптимизация
[02:11:34.880 --> 02:11:36.880]  но мы не успеем
[02:11:36.880 --> 02:11:38.880]  в стандартной библиотеке есть всякие
[02:11:38.880 --> 02:11:40.880]  ансейв блоки, где вы пишете
[02:11:40.880 --> 02:11:42.880]  что вот
[02:11:42.880 --> 02:11:44.880]  есть такой вот инвариант
[02:11:44.880 --> 02:11:46.880]  вот в этом бронче
[02:11:46.880 --> 02:11:48.880]  есть такой инвариант
[02:11:48.880 --> 02:11:50.880]  это ансейв фигня
[02:11:50.880 --> 02:11:52.880]  он смотрит на нее и понимает
[02:11:52.880 --> 02:11:54.880]  вот мне человек написал с блоком ансейв
[02:11:54.880 --> 02:11:56.880]  что в этом бронче выполняется какой-то инвариант
[02:11:56.880 --> 02:11:58.880]  значит я могу использовать это для своих оптимизаций
[02:11:58.880 --> 02:12:00.880]  и соответственно
[02:12:00.880 --> 02:12:02.880]  код становится еще быстрее
[02:12:02.880 --> 02:12:04.880]  можно в подсказке
[02:12:08.880 --> 02:12:10.880]  deprecated
[02:12:10.880 --> 02:12:12.880]  must use например
[02:12:12.880 --> 02:12:14.880]  как это в resalte сделано
[02:12:14.880 --> 02:12:16.880]  опять постоянно забываю
[02:12:16.880 --> 02:12:18.880]  как называется это в плюсах
[02:12:20.880 --> 02:12:22.880]  no discard
[02:12:22.880 --> 02:12:24.880]  плюсах наоборот
[02:12:24.880 --> 02:12:26.880]  плюсах наоборот
[02:12:26.880 --> 02:12:28.880]  ты разрешаешь не использовать
[02:12:32.880 --> 02:12:34.880]  здесь тоже самое абсолютно
[02:12:34.880 --> 02:12:36.880]  просто название другое
[02:12:36.880 --> 02:12:38.880]  вот это другое
[02:12:44.880 --> 02:12:46.880]  если ты повесишь эту ерунду
[02:12:46.880 --> 02:12:48.880]  то если пользователь не воспользуется
[02:12:48.880 --> 02:12:50.880]  возвращаемым значением функции
[02:12:50.880 --> 02:12:52.880]  то в таком случае он возлится
[02:12:56.880 --> 02:12:58.880]  потому что он скажет прямым текстом
[02:12:58.880 --> 02:13:00.880]  помечена эта функция must use
[02:13:00.880 --> 02:13:02.880]  используй пожалуйста значение этой функции
[02:13:02.880 --> 02:13:04.880]  скорее всего это не просто так
[02:13:04.880 --> 02:13:06.880]  ну и inline если там можно
[02:13:06.880 --> 02:13:08.880]  inline точно так же как и в плюсах
[02:13:08.880 --> 02:13:10.880]  ключевое слово
[02:13:10.880 --> 02:13:12.880]  просто означает подсказку
[02:13:12.880 --> 02:13:14.880]  для компилятора
[02:13:14.880 --> 02:13:16.880]  не прям сделай это
[02:13:22.880 --> 02:13:24.880]  ну ладно будем считать что я не разбираюсь так сильно в плюсах
[02:13:24.880 --> 02:13:26.880]  и не будем говорить точно
[02:13:30.880 --> 02:13:32.880]  смотрите
[02:13:32.880 --> 02:13:34.880]  и при этом у нас осталось 20 пакет
[02:13:36.880 --> 02:13:38.880]  ну вот мы успели
[02:13:38.880 --> 02:13:40.880]  изучить что такое closures
[02:13:40.880 --> 02:13:42.880]  что такое декларативная макроса, процедурная
[02:13:42.880 --> 02:13:44.880]  и даже посмотрели что есть в стандартной библиотеке
[02:13:44.880 --> 02:13:46.880]  по макросу
[02:13:46.880 --> 02:13:48.880]  кажется это все что мы хотели изучить
[02:13:48.880 --> 02:13:50.880]  на этой лекции и мы исправились
[02:13:50.880 --> 02:13:52.880]  130 слайдов за это время
[02:13:52.880 --> 02:13:54.880]  кажется нам 150 нужно
[02:13:56.880 --> 02:13:58.880]  что хочется еще раз
[02:14:02.880 --> 02:14:04.880]  ну что
[02:14:04.880 --> 02:14:06.880]  есть какие-нибудь вопросы
[02:14:10.880 --> 02:14:12.880]  значит никаких вопросов нет
[02:14:14.880 --> 02:14:16.880]  тогда всем спасибо всем пока
