[00:00.000 --> 00:11.680]  О, чудеса! С вами в прошлый раз мы с вами построили конструкцию как SKS грамматики
[00:11.680 --> 00:20.040]  строить МП-автомат. Давайте быстренько напомним. Мы с вами сказали, что мы строим с вами, у нас есть
[00:20.040 --> 00:25.520]  правило видов грамматики, а выводит альфа, и мы решили построить с вами такой автомат с магазиной
[00:25.520 --> 00:32.360]  памяти. Что первый переход у нас будет? Эпсилон снимаем со стека, читаем со входа Эпсилон, снимаем
[00:32.360 --> 00:39.440]  со стека Эпсилон, на выход кладем С. Дальше мы с вами делаем следующее. Если у нас есть правило
[00:39.440 --> 00:48.720]  такого вида, то мы снимаем со стека Эпсилон, кладем альфа, читаем Эпсилон, снимаем со стека А,
[00:48.720 --> 00:57.440]  кладем альфа перевернутая, и для каждого символа алфавита добавляем правило, что мы читаем со
[00:57.440 --> 01:05.760]  входа А, пишем на вход А, читаем со стека А, пишем Эпсилон. Напоминаю, что для этого символа мы делаем
[01:05.760 --> 01:13.360]  копию, потому что у нас стекалфавит не может пересекаться с обычным алфавитом. Да, и теперь
[01:13.360 --> 01:22.160]  мы с вами делаем следующее утверждение. Мы с вами доказываем, что если у нас альфа принадлежит N
[01:22.160 --> 01:30.280]  объединить сигма, то альфа выводит слово W тогда и только тогда, когда у нас вот это у нас состояние
[01:30.280 --> 01:44.440]  Q1, Q1 получается на входе у нас слово W, альфа выводит в автомате Q1, Эпсилон, Эпсилон. И мы с
[01:44.440 --> 01:54.920]  вами в прошлый раз доказали переход с права налево, он был сложнее. Давайте доказывать
[01:54.920 --> 02:05.640]  переход слева направо. Ну, по классической традиции, как мы его доказываем, эндокс подлиннее
[02:05.640 --> 02:30.120]  число шагов. База. Давайте мы будем обозначать длину вывода решеткой, количество шагов. Чему равна
[02:30.120 --> 02:47.720]  решетка в базе? Ноль. Как ноль получить? Как из не терминала или символа алфавита вывести слово W?
[02:47.720 --> 03:01.720]  Да, значит у нас это может быть только если альфа равно W равно а. Ну, тогда нам надо показать,
[03:01.720 --> 03:12.040]  что, смотрите, что тогда Q1 такое W альфа. Мы можем просто подставить это все дело, мы получим Q1,
[03:12.040 --> 03:27.040]  а, а. А это выводит Q1, Эпсилон, Эпсилон. По какой причине? У нас есть правило такое замечательное.
[03:27.040 --> 03:41.680]  Так как у нас есть правило Q1, а, значит со стека снимаем а, то есть этот случай мы с вами разобрали.
[03:41.680 --> 03:59.920]  Давайте теперь переход. Пусть мы вывели, для всех шагов меньше чем K, утверждение доказано. Давайте
[03:59.920 --> 04:07.600]  рассмотрим вывод за K шагов. Тогда у нас есть какой-то не терминал, альфа тогда у нас является не
[04:07.600 --> 04:17.360]  терминалом, и он за K шагов выводит некоторое слово W. Тогда мы можем сказать, что рассмотрим первое
[04:17.360 --> 04:26.240]  правило, которое у нас появляется в дереве вывода. Тогда мы за А, из А за один шаг выводим альфа 1,
[04:26.240 --> 04:38.720]  альфа 2. Какое-то альфа K, давайте альфа МТ. Дальше мы каждый из альфа ИТ раскрываем какое-то
[04:38.720 --> 04:54.560]  слово WИТ. Так, WМТ, которое будет нашим словом W. Тогда что мы получаем? Напоминаю, что альфа ИТ
[04:54.560 --> 05:02.040]  у нас будут принадлежать N объединить сигма. То есть это наша правая часть правила. Тогда давайте
[05:02.040 --> 05:10.760]  соединять. Альфа ИТ выводит ВИТ. Следовательно, по предположению индукции у нас получается что?
[05:10.760 --> 05:29.400]  Q1, так получается ВИТ, альфа ИТ выводит Q1 и апсилон и апсилон. А дальше смотрите,
[05:29.400 --> 05:43.040]  что мы получаем. Давайте напишем, что такое Q1, W, A. За один шаг, поскольку у нас есть правило
[05:43.040 --> 05:55.440]  А, стрелочка альфа 1, альфа K, то мы выводим с вами Q1, W и перевернут эту штуку.
[05:55.440 --> 06:07.160]  Дальше смотрите внимательно, за ноль шагов. Вот мы раньше никогда не пользовались свойством
[06:07.160 --> 06:14.120]  рефлексивности в этом отношении. Никогда. Я просто покажу, что выводимость за ноль шагов. Мне
[06:14.120 --> 06:19.280]  просто надо раскрыть слово W, которое у нас есть. Только у нас не КТ, тут МТ было.
[06:19.280 --> 06:41.520]  За ноль шагов получаем Q1, WMT, альфа МТ, альфа 1. Теперь что мы с вами можем сделать
[06:41.520 --> 06:55.200]  из предположений индукции? Кто понимает? Проспаемся. У нас верхний символ на стеке,
[06:55.200 --> 07:00.840]  альфа 1. А первое слово, которое мы можем прочитать, W1, что мы можем с ним сделать?
[07:00.840 --> 07:19.760]  Мы можем его считать, со стека все снять и слово прочитать. То есть мы берем и отцепляем W1,
[07:19.760 --> 07:47.360]  альфа 1. Повторяем так некоторое количество раз. Получаем здесь Q1 и тем самым
[07:47.360 --> 07:55.560]  доказываем индукционный переход. Вот этот шаг понятен? Просто берем, разворачиваем правила по стеке.
[07:55.560 --> 08:17.760]  А теперь давайте докажем наше утверждение. Точнее, наш теорем. Что такое, что слово лежит в языке,
[08:17.760 --> 08:39.000]  задаваемым грамматикой. Это эквалютно чему? Давайте по порядку. Во-первых,
[08:39.000 --> 08:51.360]  из стартового терминала у нас вводит слово W. Из леммы, которую мы с вами доказали, как мы это можем
[08:51.360 --> 09:10.320]  переписать. Q1. Так ведь? А теперь смотрите, прикол в чем.
[09:21.920 --> 09:28.240]  За один шаг обязательно какое правило у нас появится при выводе любого слова.
[09:28.240 --> 09:42.160]  Посмотрим на нашу цепочку. Вот у нас Q0, вот у нас Q1, мы всегда на стек кладем S.
[09:51.360 --> 09:58.720]  Поскольку это всегда, то мы можем здесь написать эквивалентность. Потому что это правило всегда у
[09:58.720 --> 10:06.400]  нас первое. И тогда что у нас получается? Единственное нам надо написать вот так.
[10:06.400 --> 10:19.480]  А, Q1 у нас всегда завершает состояние. А это чему эквалентно у нас?
[10:19.480 --> 10:35.520]  Все, доказали теорему. То есть мы из любого K из языка получаем язык, задаваем им по автоанатам.
[10:35.520 --> 10:40.800]  И доказали, что языки совпадают. Так, понятно ли доказательство этого факта?
[10:40.800 --> 10:51.440]  Хорошо, теперь давайте подумаем немножечко наперед. Помните, мы в прошлый раз с вами
[10:51.440 --> 10:56.960]  конструкцию строили для автомата без эпсилом переходов. У нас была с вами нормальная форма
[10:56.960 --> 11:19.360]  гребах. У нас были правила A, A, B, C. И строили автомат следующего рода. Все правила вида,
[11:19.360 --> 11:24.320]  которые у нас были, они у нас всегда должны считывать один символ со стека. То есть это A,
[11:24.320 --> 11:41.920]  A получается для правила A, A, B, C. Вот так. Для правила A, A, эпсилом оно у нас всегда остается.
[11:41.920 --> 11:54.080]  И остаются такие правила для соответствующих выходов. И дальше мы делали следующее.
[11:54.560 --> 12:04.200]  Вот это состояние у нас становится завершающим. Если у нас есть правило S, эпсилом. Правила в нашем
[12:04.200 --> 12:11.480]  грамматике. И что еще мы с вами сделали? Мы сказали, что если у нас есть правило из S,
[12:11.480 --> 12:21.000]  выводится A, B, C, то вот сюда мы добавляем переход какой. Мы читаем со входа эпсилом,
[12:21.000 --> 12:35.320]  точнее мы читаем со входа букву A, снимаем эпсилом со стека и кладем букву C, B. Теперь давайте
[12:35.320 --> 12:49.800]  подумаем на следующем выражение, утверждение. Верно ли в этом утверждении следующий факт?
[12:49.800 --> 13:13.520]  Вот этот. Ровно тот же факт, который мы с вами доказывали.
[13:19.800 --> 13:32.320]  Давайте подумаем, верен он или нет. У нас из альфы выводится слово W,
[13:32.320 --> 13:37.080]  тогда и только тогда, когда мы берем, находимся в Q1, читаем слово W.
[13:37.080 --> 13:51.000]  Говорим только про Q1 состояние.
[13:51.000 --> 14:13.400]  Давайте сделаем альфа не S. Тогда это утверждение становится верным. Те же самые
[14:13.400 --> 14:16.680]  индукционные рассуждения необходимо провести для того, чтобы доказать этот факт.
[14:16.680 --> 14:23.680]  А теперь давайте немножечко разберемся с первым переходом, который у нас есть.
[14:23.680 --> 14:53.240]  С выводит W. В случае W равное эпсилом закрывается тем, что у нас Q0 завершающий
[14:53.240 --> 14:58.880]  состояние, поэтому слово читается. А второй случай, что у нас есть какая-то первая буква.
[14:58.880 --> 15:14.600]  У в нашем слове, и у нас есть правило следующее, например. Давайте без ограничений общности считать,
[15:14.600 --> 15:30.120]  что у нас первое правило будет из S выводится A,B,C. Тогда скажите мне, пожалуйста, какой у нас будет
[15:30.120 --> 15:46.280]  первый шаг. У нас с вами Q0. Слово W нас таки эпсилом. Дальше, за один шаг что мы получаем с вами?
[15:46.280 --> 16:07.160]  Если у нас правила такого вида. Мы считываем первую букву A в нашем слове. На выходе получаем U,
[16:07.160 --> 16:22.280]  на оставшемся входе. А здесь переворачиваем C,B. Давайте я на другую доску перейду. Мокрая,
[16:22.280 --> 16:41.120]  мокрая, практически сухая. Нет, она оказалась мокрой. Еще раз давайте повторим. У нас Q0,
[16:41.120 --> 17:01.160]  Q1, U,C,B. А теперь смотрите, у нас правило S выводит A,B,C. A,B,C выводит AU. Это значит,
[17:01.160 --> 17:12.400]  что мы можем разложить с вами U в виде UB и UC. Такое, что B выводит UB, а C выводит UC.
[17:12.400 --> 17:33.560]  Отлично. А тогда смотрите, опять же, за ноль шагов мы выводим из Q1 UB, UC,C,B. И опять же,
[17:33.560 --> 17:38.960]  здесь уже используем ту лему, которая будет доказана дополнительно. Вот по аналогии.
[17:38.960 --> 18:00.960]  Получаем следующее. Значит, из леммы у нас будет получаться, что Q1, UB выводит Q1,
[18:01.760 --> 18:27.080]  Q1, UC,C выводит Q1, UB. Мы, собственно, подставляем это все. Так, U,C,C. А это будет эквалент,
[18:27.080 --> 18:37.400]  потому что слово W выводится. В языке называем МП-автомат. То есть, по факту, что мы делаем? Мы,
[18:37.400 --> 18:44.640]  на самом деле, каждый раз просто снимаем букву со стека. Аккуратненько этот случай прорабатываем.
[18:44.640 --> 18:54.760]  И прорабатываем первый переход в нашем автомате. А в остальном доказательство ровно аналогичное.
[18:54.760 --> 19:02.080]  Так, давайте я остановлюсь и спрошу. Вот эта идея понятна?
[19:02.080 --> 19:10.040]  Такого упражнения осталось провести аккуратненько индукционный переход.
[19:10.040 --> 19:19.680]  Так, что, движемся дальше? Или еще вопросы есть какие-то? Если есть вопросы, задавайте обязательно.
[19:19.680 --> 19:30.080]  Так, смотрите, мы по КС грамматики построили МП-автомат. Теперь что нам охота сделать?
[19:30.080 --> 19:44.200]  Да, по автомату построить грамматику. Отлично. У вас были семинары по КС грамматикам уже?
[19:44.200 --> 19:53.680]  Строили картинки со скобочным балансом? Все, отлично. Сейчас мы будем их вспоминать.
[19:53.680 --> 20:03.960]  Давайте я, пожалуй, покажу их на презентации, потому что там они красиво нарисованы.
[20:03.960 --> 20:17.640]  Чудеса теха все-таки как-никак решают. Так, это мы пролистываем. Это пример, как это все строится.
[20:17.640 --> 20:29.480]  Смотрите, что мы понимаем? Какого у нас МП-автомат было вида? Мы всегда с вами договорились,
[20:29.480 --> 20:37.320]  что мы либо снимаем букву со стека, либо добавляем букву на стек. Помните, мы добавляли специальную заглушку,
[20:37.320 --> 20:42.960]  чтобы мы всегда либо что-то снимали со стека, либо что-то добавляли на стек. А теперь прикол.
[20:42.960 --> 20:53.560]  Давайте построим график длины стека относительно длины слова. Точнее, длина стека относительно
[20:53.560 --> 21:15.200]  количество правил, которые мы прошли. Глобально наша задача состоит в том, что у нас есть МП-автомат,
[21:15.200 --> 21:24.200]  для него надо КС-громатику построить. Давайте обсудим следующее. Где мы изначально находимся?
[21:24.200 --> 21:29.080]  Предполагаю, что у нас слово лежит в языке, задаваемым МП-автоматом М.
[21:29.080 --> 21:56.200]  Дальше давайте поймем, где мы заканчиваемся, на каком уровне.
[21:56.200 --> 22:10.600]  В конце мы заканчиваемся, но при чем мы должны прийти в завершающее состояние.
[22:10.600 --> 22:20.360]  А теперь давайте поймем. Кстати, если есть тут цветные мелы, это будет офигенно. А тут есть
[22:20.960 --> 22:32.240]  даже две штучки. Чудеса тихо откладываются. Предположим, что мы с вами поднялись по какой-то
[22:32.240 --> 22:47.160]  букве А по стеку. Давайте обозначим этот уровень плюс А. И предположим, что мы с вами
[22:47.160 --> 23:05.240]  прошли здесь из состояния куитое, некоторое состояние кужитое. Вопрос. Вот у нас на стеке
[23:05.240 --> 23:14.400]  лежит буква А. С учетом того, что мы где-то в конце слова, должны будем снять все буквы
[23:14.400 --> 23:22.680]  со стека. Что мы можем сказать про букву А? Да, мы в какой-то момент ее сняли. Причем мы понимаем,
[23:22.680 --> 23:29.320]  на каком уровне мы снимаем эту букву со стека. Да, мы находимся ровно на том же самом уровне,
[23:29.320 --> 23:49.240]  которое здесь было. Пусть это у нас состояние было куертое и квесттое.
[23:59.320 --> 24:07.560]  И дальше мы можем отследить тот момент, когда мы с стек сняли еще какую-то букву,
[24:07.560 --> 24:14.720]  когда мы ушли с этого уровня. Вы же должны были с этого уровня? Возможно, не сразу,
[24:14.720 --> 24:24.240]  но в какой-то момент мы еще с вами спустимся по другой букве В. Пусть это будет у нас буква ку.
[24:24.240 --> 24:37.120]  А теперь давайте подумаем в этой штуке. Интересный факт.
[24:37.120 --> 24:52.560]  Предположим, что у нас с вами мы находились... Вот у нас есть слово W,
[24:52.560 --> 24:58.800]  которое лежит в языке сдаваемого по автомату. А теперь вопрос, который я хочу вам задать.
[24:58.800 --> 25:08.000]  Вот у нас от этой точки до этой точки, если мы посмотрим, стек меняется. Вот здесь находимся
[25:08.000 --> 25:14.880]  со стеком, где буква А последняя. Здесь находимся в моменте, когда буква А последняя. У нас стек
[25:14.880 --> 25:22.400]  меняется, если мы посмотрим вот эти два снапшота. Нет, не меняемся. А поэтому давайте сделаем
[25:22.880 --> 25:47.200]  вариант. Мы будем заводить с вами пары состояний А, G, T, R, T. Это именно тот спуск, который снимает
[25:47.200 --> 25:54.920]  именно эту А. Смотрите, давайте мы сделаем следующее. Делаем отображение из пары состояний QG,
[25:54.920 --> 26:04.760]  QR. Сделаем правила грамматики А, G, R. Причем мы будем с вами делать следующее, что если у нас...
[26:04.760 --> 26:09.800]  Это тот вариант, который мы с вами будем доказывать, что если мы...
[26:09.800 --> 26:32.760]  Так, сейчас, секунду. Вводим слово U тогда и только тогда, когда с Q житого
[26:32.760 --> 26:53.800]  у Эпсилон выводится QR и Эпсилон, Эпсилон. То есть с ней меняется стек. А теперь прикол.
[26:53.800 --> 27:12.200]  Давайте посмотрим вот на эту картинку на следующий момент А и ТТ. Давайте подумаем,
[27:12.200 --> 27:19.560]  что оно должно выводить. Смотрите, у нас А и ТТ не меняет стек. Вот уровень,
[27:19.560 --> 27:23.680]  которым давали буква. А вот это первый момент, когда мы ушли с этого уровня.
[27:23.680 --> 27:30.400]  Да, давайте подумаем, как мы это можем написать красивым образом. Переход наш.
[27:30.400 --> 27:44.640]  Для этого нам нужно написать вот этот переход. Давайте напишем. Пусть у нас есть переход Q и Т.
[27:44.640 --> 27:56.560]  Сейчас, секунду. Q и Т, значит, по слову... Блин, у меня буква кончается. Вы не против,
[27:56.560 --> 28:01.320]  если мы русские буквы заиспользуем? Мне понравилась практика с прошлого раза.
[28:01.320 --> 28:17.480]  По твердому знаку, значит, получается Эпсилон. Переходим в состояние Q. Житое кладем на стеке А,
[28:17.480 --> 28:27.120]  принадлежит нашему правилам автомата. И второе правило, значит, QRT. Какая? Буква Э пусть будет.
[28:27.120 --> 28:39.720]  А снимаем со стека, выводим... Что? Переходим в состояние QS и кладем на стек слово пустое.
[28:39.720 --> 28:44.280]  То есть вот такие два правила зафиксируем. И теперь давайте подумаем, как эквивалентным
[28:44.280 --> 28:51.680]  способом переписать правила в нашей грамматике. То есть как вот эти вот штуки и вот эту картинку
[28:51.680 --> 29:07.640]  преобразовать в правила грамматики. Ну, смотрите, здесь мы на выходе какую букву пишем. Твердый знак.
[29:07.640 --> 29:18.880]  Мы поднимаемся на этот уровень. Дальше что у нас происходит? От Житого до Эртого. Стек не меняется.
[29:18.880 --> 29:35.760]  А это значит, что мы можем написать? Дальше. Какой S? Как мы обозначаем с вами переходы,
[29:35.760 --> 29:46.400]  в которых стек не меняется? Как мы можем трансформировать эти правила? Ну, не A, это AGR,
[29:46.400 --> 29:59.280]  потому что здесь у нас QGT, а здесь QRT. Дальше что? Мы переходим из Эртого в состояние WS.
[29:59.280 --> 30:11.440]  В состояние E. Так, и дальше. AST.
[30:11.440 --> 30:37.240]  Добавляем для всех переходов такого вида правила вот такое. Понятно вот эта идея? И тем самым
[30:37.240 --> 30:44.200]  мы будем доказывать вариант, что у нас так не меняется. Ну, по факту мы с вами, если честно написать,
[30:44.200 --> 30:54.920]  то мы с вами показываем переходы с правой стороны влево. Опять же напоминаю, помните, когда мы
[30:54.920 --> 30:58.680]  строили нормальную форму грейбах, мы такую же штуку, то есть построили конструкцию, а дальше из
[30:58.680 --> 31:05.560]  конструкции вывели индукционный переход, который получится справа налево. Так, база индукции какая?
[31:05.560 --> 31:21.080]  Давайте подумаем. Как построить базу индукции? Мы хотим сейчас построить следующую штуку,
[31:21.080 --> 31:32.760]  чтобы каждой паре переходов у нас строилась вот такой вот не терминал, из которого будет
[31:32.760 --> 31:38.520]  выводиться слово WF только в том случае, когда у нас по сути стэк будет пустой на том же самом уровне.
[31:38.520 --> 32:02.200]  Смотрите. Да-да-да, мы как раз строим алгоритм, как из переходов МП автоматик построить
[32:02.200 --> 32:11.760]  переходы в КС грамматики. Не-не-не, нам еще 201 надо доехать. Итак, смотрите, теперь давайте предположим,
[32:11.760 --> 32:24.040]  когда у нас слово лежит в языке, задаваемым по автоматам. Давайте вспоминать. Когда существует
[32:24.040 --> 32:37.480]  какое-то кукатое завершающее состояние, что из Q0 слово W epsilon мы читаем кукатое epsilon epsilon.
[32:37.480 --> 32:48.960]  Это в терминах нашего автомата. Какое правило в грамматике мы должны породить? Какой не терминал
[32:48.960 --> 32:59.120]  должен отвечать за вот это вот? Смотрим индексы. 0K. То есть это в соответствии ставится терминал A0K.
[32:59.120 --> 33:11.200]  И как сделать так, чтобы реально в нашей грамматике из слова, ну, из стартования терминала выводилось
[33:12.000 --> 33:13.440]  слово W. Какое правило добавить?
[33:13.440 --> 33:30.320]  Нет, ну мы понимаем, что здесь выводится у нас W, а откуда мы выводить это должно?
[33:30.320 --> 33:42.920]  То есть нам нужно прифигачить нашу конструкцию к стартовому состоянию в
[33:42.920 --> 33:46.520]  нашей грамматике. То есть будем добавлять вот это правило
[33:46.520 --> 33:54.560]  для любого кукатое, принадлежащего множеству завершающих состояний.
[33:54.560 --> 34:07.720]  Так, еще один кейс. Для того, чтобы сложилась наша картинка, нам нужна база индукции. То есть
[34:07.720 --> 34:12.080]  мы с вами построили индукционный переход, мы по факту с вами уже построили доказательство
[34:12.560 --> 34:17.040]  теперь нам надо базу индукции построить. За какое количество шагов вот эта вот конструкция
[34:17.040 --> 34:31.440]  минимальная может выполняться? Какую? Вот это? Да-да. Осталось вот это породить.
[34:31.440 --> 34:40.280]  Я утверждаю, что это можно сделать за ноль шагов.
[34:40.280 --> 35:00.600]  Смотрите. За ноль шагов. Тогда что мы можем получить с вами? Из этого у равно
[35:00.600 --> 35:10.080]  Эпсилон. Дальше что? И равно Р. И чтобы у нас реально база индукции сошлась,
[35:10.080 --> 35:27.240]  мы должны добавить такое правило. Почему? А, там же, да? Да, согласен.
[35:27.240 --> 35:48.720]  Так, давайте запишем теперь это все формально. Готовы? Давайте напишем. На самом деле мы
[35:48.720 --> 35:55.520]  доказали подтверждение справа, налево. То есть у нас есть база, у нас есть переход за ноль шагов,
[35:55.520 --> 36:00.440]  значит у нас есть такое правило, которое выводит слово Эпсилон. Построили с вами индукционный
[36:00.440 --> 36:05.720]  переход при помощи этой картинки. То есть нашли такую ситуацию, что мы поднялись по А,
[36:05.720 --> 36:11.320]  попустились по А, в последний раз нашли момент, вывели такое правило. И дальше доказали, что если у
[36:11.320 --> 36:19.080]  нас есть слово W-водящее слово, то мы выводим вот такой не терминал, а из него по доказанному факту
[36:19.080 --> 36:27.280]  вводят слово W. То есть понятно? Вопрос. Понятно, как из кс-громатики, из mp-автомата мы сразу
[36:27.280 --> 36:46.440]  доказываем выводимость в кс-громатике? Для каждой пары состояний мы вводим не терминал.
[36:49.720 --> 36:54.920]  А дальше это все подвязываем правилами так, чтобы у нас реально из выводимости в mp-автомате
[36:54.920 --> 37:02.480]  строилась выводимость в кс-громатике. Так, теперь давайте это формально напишем.
[37:02.480 --> 37:19.880]  Итак, значит теперь формально доказательство. Потому что если бы я сейчас ввел эту конструкцию,
[37:19.880 --> 37:27.520]  вообще бы не было понятно, что у нас есть. Итак, предположим, что у нас есть mp-автомат.
[37:32.480 --> 37:43.520]  Так sigma гамма дельта q0 f, в котором мы будем обозначать qkt, то есть проиндексируем их.
[37:43.520 --> 38:06.560]  Тогда смотрите, где мы сделаем следующее. Для любого куитова получается у альфа
[38:06.560 --> 38:15.440]  q житая бета, пролежащим правилам в громатике, фиксируем, что модуль альфа плюс модуль бета равно 1.
[38:15.440 --> 38:26.480]  То есть берем такой mp-автомат и строим громатику g, которая имеет следующий вид правил.
[38:26.480 --> 38:44.720]  Значит, во-первых, не терминала s, объединить а и житая, где q житая принадлежат нашим состояниям в автомате.
[38:44.720 --> 38:54.400]  Дальше у нас алфавит не меняется. Правило определим с в стартовании терминала s.
[38:54.400 --> 39:02.480]  Где? Правило громатики состоит из следующего вида. По-первых, правило такого вида.
[39:02.480 --> 39:31.920]  Объединить, объединить с, я вот тут страшная, а и т выводят
[39:31.920 --> 39:49.440]  твердый знак a, g, r, e, a, s, t, где у нас есть правило q i, t, твердый знак епсилон выводит q житая,
[39:49.600 --> 40:00.720]  тут надо написать, что существует такое а из нашего стека алфавита, что из этого выводится такое,
[40:00.720 --> 40:18.000]  а и получается из q, r, e, a выводится q, s, t, епсилон, вот так.
[40:18.000 --> 40:24.240]  Вот, теперь представьте, что я бы начал это рассказывать.
[40:24.240 --> 40:32.240]  Вот, ведем такую громатику и непонятно, как она построилась. Устроится она ровно вот таким вот
[40:32.240 --> 40:43.960]  рассуждениями. И дальше лему, которую нам надо доказать, это вот эта вот штука. Давайте я просто
[40:43.960 --> 41:13.000]  выпишу ее. Давайте я сейчас напишу лему. Так, выводят слово у,
[41:13.000 --> 41:19.400]  тогда и только тогда, когда из q.
[41:19.400 --> 41:35.160]  Так, контрольный вопрос, какую сторону уже доказали?
[41:35.160 --> 41:40.160]  Не, ну по факту.
[41:40.160 --> 42:03.960]  Длина вывода равна нулю. Тогда какие рассуждения мы применяем?
[42:03.960 --> 42:23.880]  Вот эти вот, которые у нас были. У равно епсилон, g равно r и тогда у нас получается,
[42:23.880 --> 42:44.760]  что g,r равняется a, g,g выводят епсилон. Вот так мы правила это выводили. Переход. Давайте напишу так.
[42:44.760 --> 42:59.720]  Смотри картинку. То есть у нас просто появляется цепочка вывода. Значит, что у нас правило раз
[42:59.720 --> 43:06.800]  появляется, потом мы снимаем всю эту штуку со штека, появляется правило два. А индукционный
[43:06.800 --> 43:16.280]  переход срабатывает вот именно на ажиры, на аст. То есть у нас есть. Что получается у нас?
[43:16.280 --> 43:36.160]  У нас q и t. Получается у. Что у нас там? Эпсилон выводит qt, епсилон, епсилон. Значит, существуют
[43:36.160 --> 43:59.520]  такие, что, собственно, блин, жаль, что тут нет копипасты. В общем, вот эти вот все знаки. Такие,
[43:59.520 --> 44:11.720]  что у нас выполняется вот эти соотношения, которые у нас есть. А, еще и а есть. Такие,
[44:11.720 --> 44:27.040]  что у нас один и два. Вот. Но тогда мы можем написать следующее, что у нас у может быть
[44:27.040 --> 44:43.760]  представимо в виде твердый знак. Чего там? x, e, y. Да, и получается следующее, что цепочка у
[44:43.760 --> 45:01.040]  нас получается такая. q и x, e, u. За один шаг мы снимаем q, g, t. Получается кладем на стек что?
[45:01.040 --> 45:12.520]  Получаем h, u, a. Потом за какое-то количество шагов мы снимаем эту букву со стека. Получаем q,
[45:12.520 --> 45:36.040]  r, t, e, u, епсилон. Дальше мы снимаем. Так, стоп, что-то лишнее сделал. А. Потом мы заходим в q,
[45:36.040 --> 45:47.240]  s, t. По букве a снимаем букву u, букву e. И дальше мы доходим до состояния q, s, t. Получаем
[45:47.240 --> 45:58.880]  епсилон, епсилон. Вот. Ну и выходит следующее. Смотрите. Значит, из вот этого у нас получается,
[45:58.880 --> 46:25.280]  что из q, z, t. Чего у нас получается? q, z, t, x, епсилон выводится q, r, t. Сейчас, секунду. q, r, t,
[46:25.280 --> 46:36.800]  епсилон, епсилон. Вот. А из вот этого соотношения, собственно, оно у нас есть. И по предположению индукции
[46:36.800 --> 46:52.880]  получаем, что из a, z, r у нас выводится x. А вот для вот этого у нас получается, что из a, z, t
[46:52.880 --> 47:20.840]  выводится y. Что? Мне кажется, вы все выпали уже. Что? Да, то есть мы смотрим путь наш в автомате
[47:20.840 --> 47:26.600]  от этой вершины до этой вершины, в которой в первый раз... Тут важно сказать, что мы смотрим первый
[47:26.600 --> 47:38.680]  момент в слове и смотрим именно такой переход, в котором буква а нас так добавляется. Да-да-да. То есть
[47:38.680 --> 47:42.640]  смотрим в момент, когда у нас добавляется буква, смотрим в момент, когда у нас эта буква слетает.
[47:42.640 --> 47:55.480]  Вот. И что у нас получается? Смотрите. У нас а, с, т выводит у, у, а, ж, р выводит х. Да? И у нас
[47:55.480 --> 48:06.040]  есть правило грамматики для такой штуки как раз. Какое? Господи. А, и, т, т выводит твердый знак а,
[48:06.040 --> 48:31.960]  ж, р, т, а, с, т. Твердый знак а, ж, р, т, а, а, с, т. А вот это уже предположение индукции получается,
[48:31.960 --> 48:43.040]  что из а, ж, р, т выводим х, а из а, ст выводим у. А это наше слово в W. Вот. Как бы это формально
[48:43.040 --> 48:50.720]  расписанный тот переход, который мы с вами обсуждали на картинке. Не поверите, в обратную
[48:50.720 --> 48:57.200]  сторону проще. Ну, собственно, как обычно, у нас доказательство в одну сторону простое,
[48:57.200 --> 49:06.480]  доказательство во вторую сторону. Надо это, надо включить мозги. Опять же индукция по длине вывода.
[49:06.480 --> 49:33.560]  Из а, и, т этого, да, выводит епсел. Ой, выводит славу. База какая? А? Как из них терминала
[49:33.560 --> 49:44.720]  можно что-то вывести за ноль шагов? Один шаг, да. Так, ну, что мы за один шаг мы можем выводить? Вот
[49:44.720 --> 49:50.800]  у нас есть правило, что мы можем вывести здесь за один шаг. Кажется, только пустое слово. Да ведь?
[49:50.800 --> 50:17.200]  Так, тогда и равно t. И что тогда мы из Куитова, имея на входе слово епсел. Сможем вы вывести
[50:17.280 --> 50:27.280]  вот это епсел на епсел. Но, кажется, сможем, потому что и равно t, и это выводит за ноль шагов.
[50:27.280 --> 50:44.160]  Честно, да? Переход. Так, рассмотрим первый вывод. Значит, у нас есть а, и, т, и тогда он обязан
[50:44.160 --> 50:57.160]  раскрываться у нас за один шаг по правилу нашему любимому. Твердый знак a, g, r, e, a, s, t. Я теперь
[50:57.160 --> 51:05.360]  понимаю в чем польза графических планшетов. Знаете в чем польза графических планшетов? Копипаста есть,
[51:05.360 --> 51:15.360]  да. Так, господи. Из этого следует, что у нас существует, давайте вот, опять же, выводят и,
[51:15.360 --> 51:26.560]  x, e, u. Вот так вот, да? Значит, из этого будет существовать у нас такое. Существует а,
[51:26.560 --> 51:50.880]  и существует правило q, что-то там. Я пропущу это. Такие, что q, e выводят. Давайте я буду писать за
[51:50.880 --> 52:14.160]  один шаг. q, g, t, ε. И дальше, что у нас q, r, t. Получается e, a. За один шаг выводят q, s, t.
[52:14.160 --> 52:28.120]  Вот такие штуки у нас есть. Теперь, смотрите, давайте писать следующее соотношение e. Значит,
[52:28.120 --> 52:37.920]  у нас с вами, тут надо, так, эту картинку я могу стирать? Мне кажется, она нам уже не понадобится.
[52:37.920 --> 52:51.280]  Итак, смотрите. Ох, поехали. Значит, давайте писать, что у нас получается из q и t.
[52:51.280 --> 53:19.040]  Соединяем вот это вот правило. Получаем следующее. Значит, что мы получаем? q, g, t, x, e, a. Дальше
[53:19.040 --> 53:27.920]  используем предположение индукции. И мы можем вывести. У нас a, g, r выводят x. А это значит,
[53:27.920 --> 53:38.520]  что мы можем здесь заменить g на r, прочитать x и букву a оставить на стеке. Потом за один шаг по
[53:38.520 --> 53:51.560]  второму правилу мы можем снять букву r со стека. О, qr заменить на q, s, u, e. Букву a снимаем со
[53:51.560 --> 53:59.200]  стека. И, опять же, используя предположение индукции, мы можем добраться из q, t, t, e, e.
[53:59.200 --> 54:20.800]  Лему доказали. Просто пишем руками. Говорю, имея графический планшет, можно сильно ускорить
[54:20.800 --> 54:28.240]  себе время. Я просто помню, я в прошлом году читал это на дистанте. Это просто ctrl-c, ctrl-v было.
[54:28.240 --> 54:39.760]  Вот, ладненько. А теперь давайте докажем теорему, собственно. Предположим, что у нас слово лежит в
[54:39.760 --> 54:53.680]  языке, сдаваемом грамматикой g. Тогда что у нас получается? Тогда у нас в СС каким-то образом
[54:53.680 --> 55:03.480]  выводится слово w. Но при этом количество переходов будет больше, чем один. Да, потому что у нас правила.
[55:03.480 --> 55:10.640]  А это значит, что это эквалентно тому, что существует такое q, k, t при лежащем завершающем состоянии,
[55:10.640 --> 55:22.040]  что из e за один шаг мы выводим слово a, 0, k, t, не терминал, а дальше выводим слово w. А это эквалентно тому,
[55:22.040 --> 55:31.240]  что существует такое q, k, t, не терминал, вот это как раз с использования леммы выходит,
[55:31.240 --> 55:54.480]  что из q, 0, в эпсилон выводится q, q, q. А это эквалентно чему? Да, что слово принимается?
[55:54.480 --> 56:21.280]  Ура. Так, ахалай махалай, просыпайся, понятно идея доказательства? Смотрите,
[56:21.280 --> 56:27.600]  сразу скажу, что у нас процедура такая, мы не требуем полностью формальные доказательства,
[56:27.600 --> 56:36.400]  мы требуем только понимания идей доказательства и основных переходов. Да, сразу скажу, что на
[56:36.400 --> 56:44.480]  колокве мы будет регламент такой, ну и на экзамене тоже. Главное понимать, какие основные ключики
[56:44.480 --> 56:50.160]  к решению проблемы, к доказательству теоремы, а дальше на самом деле дело техники.
[56:50.160 --> 56:58.880]  Вот, то есть, грубо говоря, вот эти все переходы, вы думаете я их запоминаю? Нет, я их не запоминаю,
[56:58.880 --> 57:03.680]  я просто понимаю, где основные ключевые позиции, и вот именно по основным ключевым позициям мы
[57:03.680 --> 57:11.040]  проходим. И сразу говорю, что экзаминаторы будут не злые дядями и тетями, они именно будут
[57:11.040 --> 57:17.480]  подсказывать в некоторых моментах, если, допустим, вы формально где-то чуть-чуть запутались в этом
[57:17.480 --> 57:27.600]  концепции. Так, что, докажем следствие? Следствие, на самом деле, вы уже пользовались не один раз.
[57:27.600 --> 57:39.520]  Опять же, я расскажу идею доказательства. Доказательства это две индукции, собственно,
[57:39.520 --> 58:03.520]  так, понимаем, кто ходит на семинары,
[58:09.520 --> 58:25.840]  да, и теперь мы это можем доказать. Давайте следствие тирей теоремы, потому что ее можно
[58:25.840 --> 58:35.920]  использовать как теоремы. Как доказываем? Да, ровно так же, как пересекаем обычные автоматы.
[58:35.920 --> 58:51.200]  Смотрите, давайте напишу идея. КС чему у нас эквивалентны? По автомату. Чему эквивалентны
[58:51.200 --> 58:59.800]  регулярки? Просто автоматы. Причем мы доказали, что существует автомат с однобуквенными переходами.
[58:59.800 --> 59:14.800]  А автомат существует с однобуквенным переходами? Ну, конечно, любой берем.
[59:14.800 --> 59:31.640]  Теперь смотрите, у нас есть автомат, автомат стэк. Пересекаем автомат, сбоку к нему стэк
[59:31.640 --> 59:35.240]  приделываем. Давайте сейчас формально напишем это.
[59:35.240 --> 01:00:04.440]  Формально. Значит, берем автомат. Пусть у нас есть М автоматный. Это у нас Q сигма дельта
[01:00:04.440 --> 01:00:18.640]  Q0F. Давайте будем обозначать Q. А ММП. П это, если что, то же самое, что Q, только другая буква.
[01:00:18.640 --> 01:00:28.760]  Просто так будет удобнее обозначать. Дельта гамма П0 ФП. Где все переходы однобуквенные.
[01:00:28.760 --> 01:00:44.320]  Тогда строим М пересечение. Это у нас будет дикартового произведения Q на П. Дальше строим сигма.
[01:00:44.320 --> 01:00:53.240]  Дельта сейчас определим. Давайте вот это обозначим. Дельта Q, вот это дельта П. Стартовые состояния какие
[01:00:53.240 --> 01:01:12.520]  будут у нас с вами. Ну, с 0 по 0, Дикартова, конечно, пара с 0 по 0. А завершающие.
[01:01:12.520 --> 01:01:32.560]  Пара Q, ФQ, ФП. Ну и дальше нам надо определить дельта. Дельта. Это переходы, ведь это Q1, П1.
[01:01:32.560 --> 01:01:53.520]  Давайте тут буква А. Снимаем, состояка альфа. Переходят в, получается, Q2, P2, бета. В том случае,
[01:01:53.520 --> 01:02:12.960]  если у нас есть два перехода. Получается Q1, А переходит в Q2. В автомате получается в обычном.
[01:02:12.960 --> 01:02:33.760]  П1, получается А, альфа, переходят в Q2, бета. Дальше открываем доказательства,
[01:02:33.760 --> 01:02:39.520]  которые у нас было для обычных автоматов. И за счет того, что у нас стэк пустой,
[01:02:39.520 --> 01:02:45.040]  должен быть в начале и в конце, просто везде добавляем вот то, что будет на стэке.
[01:02:45.040 --> 01:02:50.800]  В конфигурации просто. Мы просто в конфигурации сохраняем то, что происходит на стэке.
[01:03:09.520 --> 01:03:17.120]  У нас конфигурация есть. Мы всегда же работали с объектом конфигурации. У нас есть пара,
[01:03:17.120 --> 01:03:23.680]  тройка состояния, слово, текущий стэк. Когда мы доказывали пересечение автоматов,
[01:03:23.680 --> 01:03:29.120]  то мы хранили именно конфигурацию. Здесь двух. То есть просто надо переносить стэк аккуратненько.
[01:03:29.120 --> 01:03:48.280]  Чего? Чего не совпадает? Буквы? Нет, алфавит совпадает. Мы же пересекаем с одним алфавитом.
[01:03:48.280 --> 01:04:00.920]  Ну да, то есть это интересно. Мы же обычно работаем над конструкцией с одним алфавитом.
[01:04:00.920 --> 01:04:09.520]  Ну можно, да, так. Конечно же. Так.
[01:04:09.520 --> 01:04:19.320]  Идея ровно такая же. Так, понятно. То есть теперь мы можем пользоваться этим для того,
[01:04:19.320 --> 01:04:24.800]  чтобы доказывать, что языки неконтекстно свободные. Да, то есть если у нас этот язык
[01:04:24.800 --> 01:04:29.400]  неконтекстно свободный, а мы пересекаем с какой-то регуляркой, то мы получаем неконтекстно свободный язык.
[01:04:29.400 --> 01:04:40.840]  Так, ладно. Теперь мы вас будем немножко развлекать. Мы дошли до материала, так сказать,
[01:04:40.840 --> 01:04:44.560]  предновогодней лекции, но теперь это не предновогодняя лекция, а будет ноябрьская лекция.
[01:04:44.560 --> 01:04:54.240]  Значит, идея такая. Давайте попробуем подумать, а можем ли мы как-то явным образом отделить язык
[01:04:54.240 --> 01:05:04.760]  регулярный от контекстно свободного? Логичный вопрос. У нас есть два класса в иерархии хомского.
[01:05:04.760 --> 01:05:10.920]  У нас есть контекстно свободные языки, у нас есть регулярные языки. Вопрос. Можем ли мы придумать
[01:05:10.920 --> 01:05:19.920]  какое-то евристическое правило, которое позволит нам явно сказать, что вот эта штука не регулярная,
[01:05:19.920 --> 01:05:31.880]  контекст свободный, а вот эта штука, допустим, регулярная. Ну, понятно дело, проверка на автоматизм.
[01:05:31.880 --> 01:05:39.440]  Терема Махилла Нерода дает такой критерий, но при этом оно, так бы сказать, немножко трудноприменимо в теории.
[01:05:39.440 --> 01:06:03.680]  Да, евристически, а хотелось бы точно. Ну, это да, тут тоже можно над этим подумать.
[01:06:04.640 --> 01:06:13.400]  Давайте вот сейчас окунемся в историю развития этого всего. Что мы можем у любого слова достаточно точно быстро сделать?
[01:06:13.400 --> 01:06:23.760]  Длину посчитать, хорошо. Играли в Баки коровы?
[01:06:23.760 --> 01:06:36.240]  Ну, в общем, там есть последствия четырех цифр, и надо отгадать этот последствий за десять попыток.
[01:06:36.240 --> 01:06:44.040]  И дальше там говорилось, что либо позиция точно совпала, либо эта цифра где-то есть, но вот непонятно где.
[01:06:44.040 --> 01:07:00.280]  Что мы еще можем посчитать? Хэш, зашибись, да, вот не работает.
[01:07:00.280 --> 01:07:12.040]  Смотрите, мы можем посчитать количество букв? А, В, В, Г, Д, Е, Ё, Ж, З, и так далее. Можем же?
[01:07:12.040 --> 01:07:23.160]  Так вот, люди как раз пытались проработать теорию, связанную с тем, можно ли понять что-то, считая количество букв в словах.
[01:07:24.040 --> 01:07:29.720]  Как вы думаете, ответ на этот вопрос какой?
[01:07:29.720 --> 01:07:38.040]  Да, ну можно ли отличить контексты свободной языки от регулярных?
[01:07:38.040 --> 01:07:47.640]  Нет, нельзя. В общем, это как раз последняя тема, которую мы будем рассматривать перед колоком.
[01:07:48.120 --> 01:07:58.680]  Для этого нам нужно ввести некоторые определения. Сегодня не 31 октября, сегодня 32 октября, для которых немножко не умеют считать даты.
[01:07:58.680 --> 01:08:06.120]  Давайте построим отображение, которое считает количество букв в нашем слове.
[01:08:06.120 --> 01:08:15.960]  Обозначим его в С. И тогда у нас получается, что мы можем построить отображение языка.
[01:08:16.280 --> 01:08:21.560]  А как построить отображение языка?
[01:08:21.560 --> 01:08:26.360]  По сути, это образ при вот таком отображении.
[01:08:26.360 --> 01:08:28.520]  Примеры.
[01:08:28.520 --> 01:08:34.280]  А, Б, Б. Одна буква А, две буквы Б.
[01:08:34.280 --> 01:08:37.560]  Тут что получим?
[01:08:37.560 --> 01:08:41.320]  1, 2, 0, да, тут.
[01:08:42.120 --> 01:08:45.880]  2, 1, 2. Хорошо.
[01:08:45.880 --> 01:08:51.640]  Образы языков. Вообще это называется образ парик.
[01:08:51.640 --> 01:08:57.640]  Прошу внимания обратить на ударение.
[01:08:57.640 --> 01:09:01.640]  Ударение на первый слог.
[01:09:01.640 --> 01:09:07.880]  Давайте построим образы языков, образ парика.
[01:09:08.440 --> 01:09:12.440]  Для вот этой штуки как будет выглядеть образ?
[01:09:16.440 --> 01:09:18.440]  N.
[01:09:18.440 --> 01:09:22.440]  Множество неотрицательных целых чисел.
[01:09:26.440 --> 01:09:30.440]  Так, полиндромы четной длины.
[01:09:31.000 --> 01:09:35.000]  Тут надо алфавитом А, Б.
[01:09:35.560 --> 01:09:39.560]  Это будет множество видов 2n, 2m.
[01:09:43.560 --> 01:09:45.560]  Вот.
[01:09:45.560 --> 01:09:47.560]  Вот.
[01:09:47.560 --> 01:09:49.560]  Вот.
[01:09:49.560 --> 01:09:51.560]  Вот.
[01:09:51.560 --> 01:09:53.560]  Вот.
[01:09:53.560 --> 01:09:55.560]  Вот.
[01:09:55.560 --> 01:09:57.560]  Вот.
[01:09:57.560 --> 01:09:59.560]  Вот.
[01:09:59.560 --> 01:10:01.560]  Вот.
[01:10:02.120 --> 01:10:06.120]  ДНМ неотрицательные.
[01:10:12.120 --> 01:10:16.120]  Так, кажется я что-то обкурился.
[01:10:18.120 --> 01:10:22.120]  Кажется, давайте подберем регулярный этот.
[01:10:22.120 --> 01:10:26.120]  Подберем контекстный язык, который обладает образом N, N.
[01:10:26.680 --> 01:10:30.680]  Подберем контекстный язык, который обладает образом N, N.
[01:10:36.680 --> 01:10:38.680]  Да.
[01:10:42.680 --> 01:10:46.680]  Подумайте, есть регулярный язык такой же?
[01:10:48.680 --> 01:10:50.680]  Конечно же.
[01:10:51.240 --> 01:10:55.240]  Так, у нас закрадывается первое подозрение.
[01:10:59.240 --> 01:11:03.240]  То, что у нас существует регулярный язык и нерегулярный язык, образ парика,
[01:11:03.240 --> 01:11:05.240]  которого совпадают.
[01:11:05.240 --> 01:11:07.240]  Так.
[01:11:07.240 --> 01:11:09.240]  Собственно, А плюс Б со звездой так.
[01:11:09.240 --> 01:11:11.240]  Вот.
[01:11:11.240 --> 01:11:13.240]  И тут нам нужен немножко линал.
[01:11:13.240 --> 01:11:17.240]  Давайте будем работать с множеством, ну, количества букв.
[01:11:17.240 --> 01:11:19.240]  Да.
[01:11:19.800 --> 01:11:23.800]  То есть у нас пусть Х, это у нас такая последовательность,
[01:11:23.800 --> 01:11:27.800]  как линейная оболочка обычно определяется в линейной алгебре.
[01:11:29.800 --> 01:11:31.800]  Двух линейных пространств.
[01:11:31.800 --> 01:11:33.800]  А.
[01:11:33.800 --> 01:11:35.800]  Да, наименьшее это.
[01:11:35.800 --> 01:11:37.800]  Вот, единственное тут ограничение будет следующее,
[01:11:37.800 --> 01:11:41.800]  что у нас будут все числа неотрицательными и натуральными.
[01:11:41.800 --> 01:11:45.800]  То есть, если у нас есть
[01:11:46.360 --> 01:11:48.360]  х,
[01:11:48.360 --> 01:11:50.360]  хн,
[01:11:52.360 --> 01:11:54.360]  о, че там у нас х,
[01:11:54.360 --> 01:11:56.360]  блин, тут че, маппинг-определение плохое, да?
[01:11:56.360 --> 01:11:58.360]  Да.
[01:11:58.360 --> 01:12:00.360]  хк,
[01:12:00.360 --> 01:12:04.360]  под множество n-венной,
[01:12:04.360 --> 01:12:06.360]  n тут с нулем, сразу скажу.
[01:12:06.360 --> 01:12:10.360]  То, линейная оболочка х обозначим
[01:12:10.360 --> 01:12:14.360]  α, и, то, и, и, то.
[01:12:14.920 --> 01:12:16.920]  Где α иты больше равны нуля,
[01:12:16.920 --> 01:12:18.920]  а α иты принадлежат целым числам.
[01:12:20.920 --> 01:12:22.920]  И теперь мы сможем с вами определить
[01:12:22.920 --> 01:12:24.920]  некоторые штуки.
[01:12:24.920 --> 01:12:26.920]  Примером.
[01:12:26.920 --> 01:12:28.920]  Линейная оболочка 1,1 это n, n.
[01:12:30.920 --> 01:12:32.920]  Линейная оболочка вот такого множества
[01:12:32.920 --> 01:12:34.920]  это 2n плюс m, 2m плюс n.
[01:12:34.920 --> 01:12:36.920]  А?
[01:12:36.920 --> 01:12:38.920]  А?
[01:12:38.920 --> 01:12:40.920]  Да, да, да.
[01:12:41.480 --> 01:12:43.480]  Да, да, да, только оно конечное
[01:12:43.480 --> 01:12:45.480]  под множество.
[01:12:45.480 --> 01:12:47.480]  А?
[01:12:47.480 --> 01:12:49.480]  А, или в презентации, да?
[01:12:49.480 --> 01:12:51.480]  А, я поправил, тут их k,
[01:12:51.480 --> 01:12:53.480]  на самом деле, везде.
[01:12:53.480 --> 01:12:55.480]  Ну, то есть размерности не совпадают.
[01:12:55.480 --> 01:12:57.480]  Количество элементов в размерности.
[01:12:57.480 --> 01:12:59.480]  Угу.
[01:12:59.480 --> 01:13:01.480]  Так.
[01:13:01.480 --> 01:13:03.480]  2,1 и 1,1 это,
[01:13:03.480 --> 01:13:05.480]  оказывается,
[01:13:05.480 --> 01:13:07.480]  2,1 и 1,1 это, оказывается,
[01:13:07.480 --> 01:13:09.480]  2,1 и 1,1.
[01:13:09.480 --> 01:13:11.480]  1,1 и 1,1 это, оказывается,
[01:13:11.480 --> 01:13:13.480]  линейные оболочки n, m,
[01:13:13.480 --> 01:13:15.480]  где n от m до 2m.
[01:13:15.480 --> 01:13:17.480]  Я не знаю,
[01:13:17.480 --> 01:13:19.480]  вы решали задачу в домашнем задании
[01:13:19.480 --> 01:13:21.480]  задать контекстно свободной грамматике
[01:13:21.480 --> 01:13:23.480]  множество слов,
[01:13:23.480 --> 01:13:25.480]  в которых количество букфа зажато
[01:13:25.480 --> 01:13:27.480]  между количеством букф b и удвоенным количеством букф b?
[01:13:27.480 --> 01:13:29.480]  А?
[01:13:29.480 --> 01:13:31.480]  Нет.
[01:13:31.480 --> 01:13:33.480]  Там решается
[01:13:33.480 --> 01:13:35.480]  следующим образом эта задача.
[01:13:35.480 --> 01:13:37.480]  В общем, берется грамматика для количества букфа
[01:13:37.480 --> 01:13:39.480]  удвоенного количества букф b.
[01:13:39.480 --> 01:13:41.480]  Такое строили, наверное,
[01:13:41.480 --> 01:13:43.480]  на семинарах.
[01:13:43.480 --> 01:13:45.480]  Вот, количество букфа равного количества букф b.
[01:13:45.480 --> 01:13:47.480]  И берете, смешиваете
[01:13:47.480 --> 01:13:49.480]  эти все правила.
[01:13:49.480 --> 01:13:51.480]  Получается такую грамматику.
[01:13:51.480 --> 01:13:53.480]  Собственно, идея доказательства
[01:13:53.480 --> 01:13:55.480]  состоит вот в этом факте.
[01:13:55.480 --> 01:13:57.480]  То есть, что нам доказать, что линейная оболочка будет
[01:13:57.480 --> 01:13:59.480]  удовлетворять такому виду.
[01:13:59.480 --> 01:14:01.480]  Вот.
[01:14:01.480 --> 01:14:03.480]  Так.
[01:14:03.480 --> 01:14:05.480]  Понятие суммы множеств давайте ведем.
[01:14:05.480 --> 01:14:07.480]  Ну, собственно, тут гадать ничего не надо.
[01:14:07.480 --> 01:14:09.480]  То есть, у нас есть два множества.
[01:14:09.480 --> 01:14:11.480]  Мы берем по элементам складом.
[01:14:11.480 --> 01:14:13.480]  Только у нас это, по сути,
[01:14:13.480 --> 01:14:15.480]  эти вектора
[01:14:15.480 --> 01:14:17.480]  н-мерные, поэтому мы это можем сделать.
[01:14:17.480 --> 01:14:19.480]  Так.
[01:14:19.480 --> 01:14:21.480]  Собственно, тут можно
[01:14:21.480 --> 01:14:23.480]  колдовать.
[01:14:23.480 --> 01:14:25.480]  Кстати, как плюсик получается?
[01:14:25.480 --> 01:14:27.480]  То есть, мы берем
[01:14:27.480 --> 01:14:29.480]  вектор 1,1 и складываем
[01:14:29.480 --> 01:14:31.480]  с линейной оболочки вектора 1,1.
[01:14:31.480 --> 01:14:33.480]  Линейная оболочка вектора
[01:14:33.480 --> 01:14:35.480]  1,1 это n,n,
[01:14:35.480 --> 01:14:37.480]  где n не отрицательная.
[01:14:37.480 --> 01:14:39.480]  Поэтому мы получаем множество пары n,n,
[01:14:39.480 --> 01:14:41.480]  где n больше 0.
[01:14:41.480 --> 01:14:43.480]  Вот это понятно?
[01:14:43.480 --> 01:14:45.480]  Да?
[01:14:47.480 --> 01:14:49.480]  И еще,
[01:14:49.480 --> 01:14:51.480]  говорите, медленнее буду.
[01:14:51.480 --> 01:14:53.480]  Вот. И теперь нам надо
[01:14:53.480 --> 01:14:55.480]  с вами определить, что же такое
[01:14:55.480 --> 01:14:57.480]  линейное множество. Значит,
[01:14:57.480 --> 01:14:59.480]  линейное множество, вот это уже первое
[01:14:59.480 --> 01:15:01.480]  определение, которое нам надо дать,
[01:15:01.480 --> 01:15:03.480]  это такое множество,
[01:15:03.480 --> 01:15:05.480]  которое представимо в виде какого-то
[01:15:05.480 --> 01:15:07.480]  вектора,
[01:15:07.480 --> 01:15:09.480]  плюс линейные оболочки других векторов.
[01:15:31.480 --> 01:15:33.480]  Вот.
[01:15:33.480 --> 01:15:35.480]  И давайте второй пример дадим сразу.
[01:15:39.480 --> 01:15:41.480]  А, под множество n,n
[01:15:41.480 --> 01:15:43.480]  полулинейно,
[01:15:47.480 --> 01:15:49.480]  если
[01:15:49.480 --> 01:15:51.480]  если
[01:15:53.480 --> 01:15:55.480]  если
[01:16:01.480 --> 01:16:03.480]  где a и t
[01:16:05.480 --> 01:16:07.480]  это линейные.
[01:16:07.480 --> 01:16:09.480]  То есть это множество, которое
[01:16:09.480 --> 01:16:11.480]  представимо в виде
[01:16:11.480 --> 01:16:13.480]  конечного объединения линейных множеств.
[01:16:13.480 --> 01:16:15.480]  Что-то попахивает
[01:16:15.480 --> 01:16:17.480]  рихметическими прогрессиями. Вам так не кажется?
[01:16:19.480 --> 01:16:21.480]  Ну, собственно, это работа с рихметическими прогрессиями.
[01:16:23.480 --> 01:16:25.480]  Так, а теперь смотрите фишку,
[01:16:25.480 --> 01:16:27.480]  в чем. Значит, я сейчас пойму,
[01:16:27.480 --> 01:16:29.480]  у меня есть это. Примеры линейных множеств.
[01:16:31.480 --> 01:16:33.480]  Конечное множество
[01:16:33.480 --> 01:16:35.480]  можно задать всегда таким образом.
[01:16:35.480 --> 01:16:37.480]  Надо просто с нулем все сложить.
[01:16:37.480 --> 01:16:39.480]  n,n
[01:16:39.480 --> 01:16:41.480]  собственно, оно всегда
[01:16:41.480 --> 01:16:43.480]  представимо в таком виде.
[01:16:43.480 --> 01:16:45.480]  Вот.
[01:16:45.480 --> 01:16:47.480]  А чтобы получить пара n и m,n,
[01:16:47.480 --> 01:16:49.480]  то нам нужно взять вектор 0,0
[01:16:51.480 --> 01:16:53.480]  и сложить с линейной оболочкой
[01:16:53.480 --> 01:16:55.480]  векторов 0,1,1,0.
[01:16:59.480 --> 01:17:01.480]  Ну, мы берем линейную оболочку
[01:17:01.480 --> 01:17:03.480]  вектора 1,1. Это что у нас?
[01:17:09.480 --> 01:17:11.480]  Это у нас пара как раз n,n.
[01:17:11.480 --> 01:17:13.480]  Ну и дальше прибавляем
[01:17:13.480 --> 01:17:15.480]  нулевой вектор, получаем то же самое.
[01:17:17.480 --> 01:17:19.480]  Угу.
[01:17:21.480 --> 01:17:23.480]  Тут еще какие-то примеры были.
[01:17:23.480 --> 01:17:25.480]  О, пол линейное множество.
[01:17:25.480 --> 01:17:27.480]  Нас будут как раз о ней интересовать.
[01:17:27.480 --> 01:17:29.480]  И теперь смотрите,
[01:17:29.480 --> 01:17:31.480]  ведем два примера.
[01:17:31.480 --> 01:17:33.480]  Давайте как раз тогда сейчас буду финализировать,
[01:17:33.480 --> 01:17:35.480]  чтобы в следующий раз уже доказывать утверждение.
[01:17:35.480 --> 01:17:37.480]  Значит, давайте ведем понятие языка,
[01:17:37.480 --> 01:17:39.480]  который является линейным прообразом.
[01:17:43.480 --> 01:17:45.480]  Значит,
[01:17:45.480 --> 01:17:47.480]  говорим.
[01:17:47.480 --> 01:17:49.480]  Так, берем сухой мел.
[01:17:53.480 --> 01:17:55.480]  L, это язык L
[01:17:55.480 --> 01:17:57.480]  является линейным прообразом.
[01:18:05.480 --> 01:18:07.480]  Если
[01:18:07.480 --> 01:18:09.480]  psi от L
[01:18:09.480 --> 01:18:11.480]  линейно.
[01:18:15.480 --> 01:18:17.480]  Это второе определение.
[01:18:19.480 --> 01:18:21.480]  L, пол линейный прообраз.
[01:18:23.480 --> 01:18:25.480]  Прообраз парика.
[01:18:29.480 --> 01:18:31.480]  И если psi от L
[01:18:31.480 --> 01:18:33.480]  пол линейно.
[01:18:39.480 --> 01:18:41.480]  Два определения.
[01:18:41.480 --> 01:18:43.480]  Теперь факты.
[01:18:43.480 --> 01:18:45.480]  Первый факт
[01:18:45.480 --> 01:18:47.480]  это упражнение.
[01:18:49.480 --> 01:18:51.480]  Если
[01:18:53.480 --> 01:18:55.480]  сейчас
[01:18:55.480 --> 01:18:57.480]  R регулярный язык
[01:19:07.480 --> 01:19:09.480]  то R будет пол линейным прообразом.
[01:19:13.480 --> 01:19:15.480]  И в следующий раз
[01:19:15.480 --> 01:19:17.480]  мы будем доказывать две теоремы.
[01:19:17.480 --> 01:19:19.480]  Теорема 1.
[01:19:19.480 --> 01:19:21.480]  Если
[01:19:23.480 --> 01:19:25.480]  сейчас.
[01:19:31.480 --> 01:19:33.480]  Если x пол линейно
[01:19:37.480 --> 01:19:39.480]  то R
[01:19:39.480 --> 01:19:41.480]  пол линейный прообраз.
[01:19:43.480 --> 01:19:45.480]  То существует
[01:19:45.480 --> 01:19:47.480]  R регулярный
[01:19:47.480 --> 01:19:49.480]  такой, что
[01:19:53.480 --> 01:19:55.480]  он по сути является прообразом.
[01:19:57.480 --> 01:19:59.480]  То есть для любого пол линейного множества
[01:19:59.480 --> 01:20:01.480]  существует регулярный прообраз.
[01:20:05.480 --> 01:20:07.480]  А теперь теорема 2, которая
[01:20:07.480 --> 01:20:09.480]  имеет формулировку
[01:20:09.480 --> 01:20:11.480]  теоремы парика.
[01:20:13.480 --> 01:20:15.480]  Любой
[01:20:17.480 --> 01:20:19.480]  КС язык
[01:20:23.480 --> 01:20:25.480]  пол линейный прообраз.
[01:20:35.480 --> 01:20:37.480]  Так, вопрос.
[01:20:37.480 --> 01:20:39.480]  Теперь на понимание.
[01:20:39.480 --> 01:20:41.480]  Почему теперь мы не можем
[01:20:41.480 --> 01:20:43.480]  отличить КС языки
[01:20:43.480 --> 01:20:45.480]  от регулярных с точки зрения
[01:20:45.480 --> 01:20:47.480]  подсчета букв?
[01:20:49.480 --> 01:20:51.480]  Кто может сформулировать?
[01:20:51.480 --> 01:20:53.480]  Давайте попробуем сформулировать.
[01:21:01.480 --> 01:21:03.480]  Ну да, давайте
[01:21:03.480 --> 01:21:05.480]  предположим, что у нас есть какой-то КС язык
[01:21:05.480 --> 01:21:07.480]  и у нас есть какой-то критерий, который
[01:21:07.480 --> 01:21:09.480]  его отличает от другого.
[01:21:09.480 --> 01:21:11.480]  От код регулярного языка.
[01:21:11.480 --> 01:21:13.480]  Тогда возьмем его.
[01:21:13.480 --> 01:21:15.480]  Посмотрим.
[01:21:15.480 --> 01:21:17.480]  Он является пол линейным точно прообразом.
[01:21:17.480 --> 01:21:19.480]  Смотрим.
[01:21:19.480 --> 01:21:21.480]  Образ этого
[01:21:21.480 --> 01:21:23.480]  контекстно-свободного языка
[01:21:23.480 --> 01:21:25.480]  он оказывается пол линейным.
[01:21:25.480 --> 01:21:27.480]  И поскольку он является пол линейным, для него
[01:21:27.480 --> 01:21:29.480]  существует регулярный прообраз, который туда же
[01:21:29.480 --> 01:21:31.480]  маппится. То есть у нас есть
[01:21:31.480 --> 01:21:33.480]  получается
[01:21:33.480 --> 01:21:35.480]  LKS.
[01:21:35.480 --> 01:21:37.480]  Смотрим PSI от L.
[01:21:37.480 --> 01:21:39.480]  А потом
[01:21:39.480 --> 01:21:41.480]  берем R регулярный.
[01:21:41.480 --> 01:21:43.480]  Для него точно существует, который
[01:21:43.480 --> 01:21:45.480]  бьет в тот же самый образ при отображении
[01:21:45.480 --> 01:21:47.480]  PSI. Проиграли,
[01:21:47.480 --> 01:21:49.480]  не отличили.
[01:21:49.480 --> 01:21:51.480]  То есть у нас всегда существует
[01:21:51.480 --> 01:21:53.480]  регулярный прообраз в виде регулярного языка.
[01:21:53.480 --> 01:21:55.480]  В следующий раз
[01:21:55.480 --> 01:21:57.480]  мы эти факты будем доказывать.
[01:21:57.480 --> 01:21:59.480]  А чтобы было с вами
[01:21:59.480 --> 01:22:01.480]  быстрее и понятнее
[01:22:01.480 --> 01:22:03.480]  вкатиться, вспомните, как мы доказывали
[01:22:03.480 --> 01:22:05.480]  лему о разрастании для контекста
[01:22:05.480 --> 01:22:07.480]  и свободных грамматик. Это нам понадобится.
