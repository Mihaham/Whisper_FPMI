[00:00.000 --> 00:14.200]  Так, ну что, давайте попробуем быстренько бахнуть софикс на автомат до конца. Давайте быстро
[00:14.200 --> 00:18.800]  напомню, что мы в прошлый раз поняли. Во-первых, мы будем строить автомат инкрементально,
[00:18.800 --> 00:24.200]  добавляя по одной букве в конец строки одну с другой. И будем следить за тем,
[00:24.200 --> 00:28.600]  какие новые лонгесты появляются. Мы понимаем, что новые лонгесты однозначно определяют классик
[00:28.600 --> 00:33.800]  эвалентности. Мы понимаем, что sc это всегда новый лонгест, и потенциально у нас есть еще второй
[00:33.800 --> 00:39.160]  товарищ, который может стать новым лонгестом. Возможно, если он раньше не был, то теперь
[00:39.160 --> 00:43.240]  становится. А если он раньше был, то он не становится, но он так лонгестом остается.
[00:43.240 --> 00:55.600]  Значит, s0 это у меня был максимальный суффикс, суффикс sc, встречавшийся в s как под строка.
[00:55.600 --> 01:07.760]  Ну, хорошо, давайте разберемся сначала вот с этим вот классом, с классом, который порождается
[01:07.760 --> 01:14.880]  вот этим новым sc, новым лонгестом. Давайте поймем, как устроены ребра, входящие и сходящие из него,
[01:14.880 --> 01:19.680]  например. Ну, вроде понятно, что из него ребер быть не должно, потому что sc это самая длинная строка,
[01:19.680 --> 01:26.640]  нельзя получить никакую строчку длиннее, поэтому из sc точно ребер не выходит. Давайте поймем,
[01:26.640 --> 01:33.920]  какие ребра в sc входят. Ну, понятно, вот если в старом автомате было состояние, отвечающее строке
[01:33.920 --> 01:41.640]  s, то мы, наверное, должны провести ребро по букве c в новом состоянии sc. Ну, это вроде понятно,
[01:41.640 --> 01:46.440]  да, потому что, напоминаю, ребра мы проводим ровно в том случае, если в одном состоянии есть такое
[01:46.440 --> 01:53.800]  слово, которое после дописывания одной буквы справа становится одним из слов второго класса. Ну,
[01:53.800 --> 01:59.720]  понятно, если было s, то приписывание c дает sc. Дальше, вообще, вот скажите, а какие слова могут,
[01:59.720 --> 02:10.640]  ну, точнее, из каких вершин мы можем с помощью буквы c попасть в класс sc? Как устроены все такие
[02:10.640 --> 02:21.400]  слова? Да, это именно суффикс s, ну, потому что что такое слова, лежащие в этом классе? Это sc и
[02:21.400 --> 02:28.800]  несколько его самых длинных суффиксов, вот такие вот строчки. Значит, как я могу попасть в этот
[02:28.800 --> 02:33.600]  класс? Ну, во-первых, понятно, что я могу туда попасть только по букве c, потому что все последние
[02:33.600 --> 02:38.320]  буквы всех этих слов это c, значит, все ребра ведущие в этот класс, на них написано только
[02:38.320 --> 02:46.480]  букву c. Вот, и более того, это слова обязательно такого вида, что они либо вот это слово плюс c,
[02:46.480 --> 02:49.920]  либо вот это слово плюс c, либо вот это, либо вот это, ну и так далее. То есть это в любом случае
[02:49.920 --> 02:57.120]  суффикс s, к которому после дописывания c я попадаю в класс эквивалентности строки sc. Поэтому мне
[02:57.120 --> 03:02.320]  нужно в каком-то смысле перебрать все суффиксы s, которые были в старом автомате, и из них провести
[03:02.320 --> 03:08.480]  ребра в sc. Ну, давайте начнем это делать. Вот, мы начали с того, что из этого состояния провели
[03:08.480 --> 03:15.520]  ребра в sc. Дальше, меня интересует следующий суффикс s, который лежал бы уже в другом классе,
[03:15.520 --> 03:24.040]  чем s, и из него я буду хотеть проводить ребра в sc. Но, благо, у нас как раз хранится информация про
[03:24.040 --> 03:29.600]  вот этот вот максимальный суффикс, лежащий в другом классе. Это link. Да, потому что вот в этом классе
[03:29.600 --> 03:36.480]  и так лежит s и несколько его самых длинных суффиксов. Если я хочу взять самый длинный суффикс,
[03:36.480 --> 03:40.920]  лежащий в другом классе, ну потому что для этого класса я уже все все все все определил. Значит,
[03:40.920 --> 03:45.160]  мне нужен link. Да, link это в точности самый длинный суффикс из другого класса. Ну,
[03:45.160 --> 03:54.920]  значит, давайте возьмем ссылку этой вершины. Попадем в какую-то вершину p. В общем случае,
[03:54.920 --> 04:02.000]  если из этой вершины буквы не было перехода по c, то его нужно будет создать. Да, ну потому что
[04:02.000 --> 04:07.360]  если раньше отсюда не было перехода по c, то теперь, понятное дело, он точно должен появиться,
[04:07.360 --> 04:15.720]  потому что можно прочитать суффикс s и дописать c, тогда мы попадаем в точности вот сюда. Ну,
[04:15.720 --> 04:19.920]  давайте поймем, что такие переходы нужно провести именно сюда. Вот давайте я скажу,
[04:19.920 --> 04:24.280]  что давайте сразу я возьму несколько раз всю ссылку. Мы поняли, что вот все интересующие
[04:24.280 --> 04:31.480]  у меня классы, из которых ребро идет в s и c, они достигаются прыжками по суффсылкам из s. Вот давайте
[04:31.480 --> 04:40.400]  я из s несколько раз возьму суффсылку. Дошел до вершины p. Пусть из p не было перехода по c.
[04:40.400 --> 04:53.000]  Что это значит? Это значит, что здесь лежат такие строчки, давайте я их как-нибудь назову, пусть
[04:53.000 --> 04:58.400]  будет t. Тут лежат такие строчки, которые, во-первых, являются суффиксами s. Мы понимаем,
[04:58.400 --> 05:07.320]  что раз она достигнута по суффсылкам, то значит t это суффикс s. Но это такой суффикс, что к нему
[05:07.320 --> 05:13.560]  нельзя приписать c справа, оставшись под строкой s. Потому что ранее в автомате у меня
[05:13.560 --> 05:18.360]  было можно было прочитать все подстроки. Это автомат на всех суффиксах s, то есть там все
[05:18.360 --> 05:25.200]  подстроки точно читаются. И если раньше к t нельзя было приписать c, значит t, c уже не под строка s.
[05:25.200 --> 05:33.880]  Раз не было перехода, значит такой строки не было в старом автомате, не было в старой строке s.
[05:33.880 --> 05:43.160]  А теперь появляется, теперь понятное дело, что t, c это уже под строка s, c. Это под строка
[05:43.160 --> 05:48.040]  s, c. Потому что мы взяли какой-то суффикс s, приписали c, понятное дело, мы получили под строку
[05:48.040 --> 05:55.560]  s, c. Ну и причем это какой-то суффикс s, c, который ранее нигде не встречался. Более того, это какой-то
[05:55.560 --> 06:16.360]  суффикс s, c, который ранее не входил в s. Ну а мы знаем, что это за класс эквивалентности. Мы в
[06:16.360 --> 06:22.080]  прошлый раз описывали в точности множество суффиксов s, c, которые не являются под строками s.
[06:22.080 --> 06:30.880]  Это в точности само s, c. Здесь лежат в точности строки, которые только что получили первое
[06:30.880 --> 06:36.320]  единственное вхождение. Вот s, c, например, только что появилось впервые, его раньше нигде не было.
[06:36.320 --> 06:41.240]  И несколько самых длинных его суффиксов только что получили единственное вхождение. Можно так
[06:41.240 --> 06:50.800]  сказать, можно сказать, что у этого множества слов правый контекст это просто епсилон. Ну то есть,
[06:50.800 --> 06:55.120]  у s, c точно правый контекст это только епсилон, только пустую строчку можно дописать, чтобы стоять
[06:55.120 --> 06:59.920]  суффиксом. Значит, здесь, поскольку вершина это у меня класс эквивалентности, то здесь лежат в
[06:59.920 --> 07:04.280]  точности все такие строчки, у которых правый контекст это епсилон. Ну что такое строчка с
[07:04.280 --> 07:10.240]  правым контекстом епсилон? Это в точности те суффиксы s, c, которые раньше в s не встречались.
[07:10.240 --> 07:16.080]  Потому что если бы он встречался где-то левее, то значит к нему, если бы он был где-то вот здесь,
[07:16.080 --> 07:20.760]  то значит тогда вот это вот было бы в его правом контексте, можно было бы дописать справа. Но
[07:20.760 --> 07:24.360]  поскольку ничего дописать нельзя, то получается, что здесь такие строки, у которых ровно одно
[07:24.360 --> 07:32.080]  вхождение сейчас, и это вот в конце строки s, c. Окей? Ну вот, значит получается, что если я
[07:32.080 --> 07:36.800]  итерируюсь по вот этим вот вершинам, которые являются суффсылкой s в некотором поколении и
[07:36.800 --> 07:43.760]  нет перехода по c, то я его вынужден создать в состоянии s, c. Потому что для каждой строки отсюда
[07:43.920 --> 07:49.680]  приписывание к c возможно, и я точно попадаю в этот класс. Поэтому вот отсюда из всех этих вершин я
[07:49.680 --> 07:57.160]  провожу вот такие ребра. Да, пока не встретим вершину, из которой переход был. Именно так.
[07:57.160 --> 08:07.120]  Пока понятно вот это? Хорошо. Значит да, как вы правильно заметили, вот давайте мы будем идти по
[08:07.120 --> 08:12.680]  вот этим суффсылкам, потому что я понимаю, мне нужно провести все ребра ведущие в s, c. Такие
[08:12.680 --> 08:17.600]  ребра идут только из суффиксов s. Ну вот я их как раз все перебираю в порядке убывания длины.
[08:17.600 --> 08:23.760]  Давайте рассмотрим самый простой случай. Когда я так шел-шел-шел, дошел до корня и даже в корне,
[08:23.760 --> 08:33.200]  точнее даже из корня не было перехода по букве c. Случай первый. Во время вот этого вот
[08:33.200 --> 08:47.880]  итерирования по суффсылкам, значит во время итерирования по суффсылкам, то есть по линкам,
[08:47.880 --> 08:57.960]  дошли до корня и даже из корня не было перехода по букве c.
[08:57.960 --> 09:19.760]  Тогда на самом деле картинка очень простая. Вот здесь мы итерировались, итерировались по суффсылкам
[09:19.760 --> 09:28.520]  несколько раз и дошли до корня. Корень в смысле стартовая вершина. То, откуда мы начинаем читать
[09:28.520 --> 09:34.880]  все слова. Корень, он же старт. И ни заодно из этих вершин не было перехода по c. Значит,
[09:34.880 --> 09:39.360]  как мы только что поняли, мне их нужно все провести в только что добавленное состояние s, c.
[09:39.360 --> 09:49.240]  Я провожу все такие ребра. Ну и понятно, что в s, c больше других ребер нет, потому что что мне
[09:49.240 --> 09:55.800]  нужно было, какие вообще в принципе ребра могут сюда вести. Ребра, которые ведут из суффикса s и
[09:55.800 --> 10:00.280]  после дописывания c, становятся суффиксом s, c. Ну это вот в точности все такие ребра. Мы их только
[10:00.280 --> 10:05.520]  что провели. Других суффиксов у s нету. Мы их все перебрали. Значит, никаких других ребер добавлять
[10:05.520 --> 10:14.680]  в s, c не нужно, по крайней мере. Ну а дальше давайте заметим следующее. Вообще давайте
[10:14.680 --> 10:18.440]  поймем, когда такое может происходить. Я утверждаю, что такое происходит,
[10:18.440 --> 10:41.880]  если и только если s0 равно epsilon, что эквивалентно тому, что c не входит в s. То есть вот такой частный
[10:41.880 --> 10:47.280]  случай, что мы во время интервью дошли до самого начала, до самого корня нашего автомата и даже
[10:47.280 --> 10:52.640]  из него не было перехода по c. Может быть только в этом случае. Значит, ну вот это более-менее понятно,
[10:52.640 --> 10:58.800]  почему s0 это epsilon. Потому что s0 это самый длинный суффикс s, c, который раньше был в s.
[10:58.800 --> 11:10.840]  Ну если он какой-то был не тривиальный, не пустой, то есть представьте себе. Вот была s,
[11:10.840 --> 11:18.080]  c какая-то моя длинная. Пусть в ней был какой-то не пустой s0. Самый длинный суффикс, встречавшийся
[11:18.080 --> 11:26.240]  ранее. Вот даже какая-то такая строка. Ну тогда, если бы я взял вот этот вот суффикс s, он
[11:26.240 --> 11:31.080]  соответствует какой-то из этих решений, из него должен был быть переход по c, а его не было. Я все
[11:31.080 --> 11:36.560]  суффиксы перебрал, ни из одного суффикса не было перехода по c, а из такого, я предполагаю, был бы.
[11:36.560 --> 11:46.920]  Противоречие. Значит, s0 не может иметь длину больше нуля. Значит, s0 это epsilon. Ну и обратно,
[11:46.920 --> 11:53.280]  если s0 это epsilon, значит, что вообще значит, что s0 это epsilon? Это значит, что ну буквально,
[11:53.280 --> 11:58.120]  что c не входит в s, потому что я не могу взять даже c в качестве суффикса, встречавшегося ранее.
[11:58.120 --> 12:04.560]  Значит, c не входит в s. Даже вот такая вот строка из одного символа не является под строкой s.
[12:04.560 --> 12:09.880]  Хорошо. Ну то есть, я доказал, что из первых следов второе, из второго и третье. Почему,
[12:09.880 --> 12:15.480]  если c не входит, то происходит такая картинка. Но если c не входит, значит, у нас в старом автомате
[12:15.480 --> 12:21.840]  нет вообще ни одного ребра по букве c. Ну понятно, если c не было в старой строке, то у нас таких
[12:21.840 --> 12:25.920]  ребер в принципе не было. Мы не могли дописывать букву c. Значит, в частности из всех этих вершин не
[12:25.920 --> 12:32.040]  проходит ребро по букве c. Значит, из третьего следует первое. Вот. Получается, такой простой
[12:32.040 --> 12:36.760]  случай достигается ровно в ситуации, когда мы встретили новый символ, которого раньше в нашей
[12:36.760 --> 12:42.280]  строке не было. Вот там были a, b, a, b, a. Потом пришел новый c. Тогда я просто прыгаю по вот этим
[12:42.280 --> 12:53.480]  сусылкам и перепровожу все эти ребра. Да? Вот. Ну, а это значит, что больше лонгестов не появляется.
[12:53.480 --> 12:59.680]  Вот эта вот строка, она и так изначально была лонгестом. Эпсилон – это лонгест класса,
[12:59.680 --> 13:07.960]  который отвечает корню нашего автомата. Ну, потому что, что такое, что такое эпсилон? Ну,
[13:07.960 --> 13:13.640]  это как можно попасть в корень нашего дерева, начав из корня. Ну, не дерево, точнее автомата. Мы
[13:13.640 --> 13:18.640]  можем только посчитать пустую строчку. Никак по-другому в корень попасть нельзя. Или иными словами,
[13:18.640 --> 13:27.680]  что такое класс строк, для которых правый контекст состоит только… Нет, наоборот, извините. Давайте
[13:27.680 --> 13:35.440]  просто посчитаем, что такое рот эпсилон. Вот. Да, все суффиксы. Верно, верно, верно. Все суффиксы.
[13:35.440 --> 13:43.840]  Если я возьму здесь не эпсилон, то, понятное дело, все суффиксы я получить не могу. Ну, то есть,
[13:43.840 --> 13:49.080]  в частности, потому что здесь лежит вся строка. А если я возьму строчку, не равную эпсилон, то всю
[13:49.080 --> 13:54.080]  строку я к ней приписать точно не смогу. Значит, кроме как эпсилон, никто в его классе лежать не
[13:54.080 --> 14:03.120]  может. Значит, эпсилон всегда… эпсилон всегда отдельное состояние, с которым больше никого нет. Ну,
[14:03.120 --> 14:09.600]  значит, ну и так всегда было лонгестом. Значит, это лонгестом не становится. Значит, давайте запишем
[14:09.600 --> 14:36.800]  это. Эпсилон всегда составляет отдельный класс эквивалентности. С0 равно эпсилон было
[14:36.800 --> 14:47.840]  лонгестом ранее. Значит, новых лонгестов не появилось, значит, автомат уже построен.
[14:47.840 --> 14:59.320]  Автомат, ну напишу, перестроен. Потому что мы знаем, что у нас может всего два состояния возникнуть.
[14:59.320 --> 15:04.800]  С одним мы уже полностью разобрались, вот это СС. Да, мы, ну как бы, мы провели все рёбра,
[15:04.800 --> 15:09.120]  которые в него должны были вести. А больше состояния не появляется, потому что единственный
[15:09.120 --> 15:13.280]  кандидат на новое состояние уже и так раньше был отдельным состоянием. Соответственно,
[15:13.280 --> 15:20.040]  новых лонгестов не появляется, новых состояний не появляется. Да? Ну все, значит, первый случай
[15:20.040 --> 15:24.080]  разобран. Если мы вот так вот утерировались по су-всылкам и ни разу не нашли перехода по С,
[15:24.080 --> 15:32.040]  то мы автомат полностью правильно перестроили и победили. Так, ну случай, соответственно, второй.
[15:32.040 --> 15:39.600]  Пусть мы утерировались по су-всылкам и в какой-то момент уперлись в вершину,
[15:39.600 --> 15:51.040]  из которой был переход по С. Вот я дохожу до некоторой вершины П, из которой в старом автомате
[15:51.040 --> 16:06.600]  был переход по букве С в некоторое Q. Это П, по букве С есть переход в Q. Тогда я утверждаю
[16:06.600 --> 16:22.600]  следующее, что С0 обязательно это лонгест от П плюс С. То есть это строка, которая получается
[16:22.600 --> 16:29.120]  самым, ну точнее является самой длинной строкой из П, к которой справа еще приписан С. Значит,
[16:29.120 --> 16:34.200]  почему это верно? Ну вспоминаем, что такое С0. Это самый длинный суффикс С, который ранее встречался.
[16:34.320 --> 16:41.040]  Смотрите, вот эти вот все суффиксы, ну точнее вот эти вот все суффиксы С к ним раньше нельзя было
[16:41.040 --> 16:45.780]  приписать С. Самый длинный суффикс старой строки, к которой можно было бы приписать С,
[16:45.780 --> 16:50.700]  лежит вот здесь. Значит, если я возьму самую длинную строчку отсюда и припишу к ней С,
[16:50.700 --> 16:55.220]  то я как раз получу самый длинный суффикс, который раньше встречался. Просто потому,
[16:55.220 --> 16:59.360]  что все более длинные суффиксы к ним нельзя было дописать С, а к этому можно. Это самая длинная
[16:59.360 --> 17:05.720]  строка, которую дописать можно. Так, хорошо, ну и тогда, смотрите, у нас на самом деле
[17:05.720 --> 17:11.160]  опять раздваивается возможность. Давайте рассмотрим случай, когда s0 это
[17:11.160 --> 17:20.320]  лонгестат q. Значит, случай 2, это, соответственно, s0 равно лонгестат q. Это
[17:20.320 --> 17:26.200]  что значит? Значит, нового лонгеста опять не возникло. То есть, вот пусть
[17:26.200 --> 17:32.280]  внезапно так стало, пусть внезапно так произошло, значит, s0 остается лонгестом.
[17:32.280 --> 17:36.360]  Он и раньше был лонгестом, и сейчас лонгест. Поэтому опять новых
[17:36.360 --> 17:49.200]  состояний не возникло. Значит, опять новых состояний не возникает. Хорошо, ну
[17:49.200 --> 17:54.480]  давайте сразу уточню, как я проверяю вот это вот равенство в коде. Понятно, я не
[17:54.480 --> 17:57.800]  могу сравнивать строчки, потому что это долго. На самом деле, вот это вот условие
[17:57.800 --> 18:06.760]  просто эквивалентно тому, что лен от p плюс один равно лен от q. Ну а лены я
[18:06.760 --> 18:10.320]  договорился, что я храню. Да, лена это у меня как раз длина самой длинной строки в
[18:10.320 --> 18:16.800]  классе. s0 имеет длину лен p плюс один. Соответственно, они равны ровным в том
[18:16.800 --> 18:23.480]  случае, если у них одинаковый длин. Ну, потому что в здесь не бывает строк, ну
[18:23.480 --> 18:27.440]  короче, здесь не бывает одинаковых строк, разные длины, и если у строка равная длина,
[18:27.440 --> 18:34.120]  то они равны внутри вот этого состояния. Так, хорошо. Давайте поймем, что тогда
[18:34.120 --> 18:36.520]  происходит.
[18:43.760 --> 18:51.160]  Так, ну мы поняли, что вот из этих вершин, которые мы прошли вплоть до p,
[18:51.280 --> 18:56.000]  понятное дело, был переход в s, ну точнее, мы его создаем, нам и обязаны создать
[18:56.000 --> 19:01.320]  такой переход в состояние c. Теперь, что происходит здесь?
[19:03.560 --> 19:09.520]  Ну, смотрите, мы живем сейчас ситуации, когда у меня на самом деле, вот если я
[19:09.520 --> 19:14.080]  рассмотрю мой старый автомат, все кроме вот этого s, у меня этот автомат не
[19:14.080 --> 19:19.200]  поменялся, потому что в нем не изменился набор лонгестов, значит, набор вершин и
[19:19.200 --> 19:23.560]  ребер между ними остается такой же, как был. То есть, единственное, что меняется
[19:23.560 --> 19:27.080]  во втором случае, по сравнению с предыдущим автоматом, это добавляется новая вершина,
[19:27.080 --> 19:31.400]  и опять в нее проводятся какие-то ребра. Вот я утверждаю, что других ребер в s,
[19:31.400 --> 19:34.120]  проводить не нужно.
[19:34.120 --> 19:36.720]  Так, понятно ли почему?
[19:40.720 --> 19:45.640]  Ну, да, да, потому что, если вспомнить, какие мы проводим стрелки ведущие в s,
[19:45.640 --> 19:50.080]  это мы проводим такие стрелки, что раньше строка встречалась, но к ней нельзя было
[19:50.360 --> 20:14.200]  дописать, а теперь стало можно, да, потому что, напоминаю, в s, лежат те строки,
[20:14.200 --> 20:17.720]  которые только что получили первое вхождение, которые раньше нигде не встречались,
[20:17.720 --> 20:22.680]  откуда угодно пытаются проводить сюда ребра, то поскольку из них и так c читалось,
[20:22.680 --> 20:29.660]  да, ну значит оно было вот здесь, а не здесь, потому что ребра ведущие в s, c соответствуют
[20:29.660 --> 20:33.600]  словам, которые только что получили вхождение, а вот в частности вот это вот слово, да, s0,
[20:33.600 --> 20:39.560]  оно раньше имело вхождение, то есть дойти до p можно было, и при том прочитать c можно было,
[20:39.560 --> 20:44.440]  вот, ну соответственно все более короткие суффиксы тоже, к ним справа можно было дописать c,
[20:44.440 --> 20:49.840]  поэтому они попадали в q или там в какие-то еще более низкие вершины, а сюда мы проводим
[20:49.840 --> 21:00.400]  только такие слова, которых раньше не было, но таких больше нет. Ну я имею в виду, что если
[21:00.400 --> 21:07.320]  вдруг есть вот такая картинка, а нет, да, это верно, кстати, да, вы про то, что почему не
[21:07.320 --> 21:14.720]  появляется других ребер, ну да, да, ну а вдруг, не знаю, вдруг, например, из q внезапно получается,
[21:14.720 --> 21:19.600]  появляется переход в s, c, ну это бред, ну короче, да, ну в общем, да, действительно других не
[21:19.600 --> 21:24.080]  появляется, вот эти мы провели, больше ничего появиться не может. Так, ну и тогда все, автомат мы
[21:24.080 --> 21:31.240]  тоже перестроили, то есть если мы увидели такое p, из которого есть переход по c в q, удовлетворяющий
[21:31.240 --> 21:36.560]  такому равенству, то в этом случае автомат тоже очень просто перестроился. Так, давайте я еще вот
[21:36.560 --> 21:45.280]  здесь скажу, я забыл одну вещь добавить, что вот здесь вот линк s, c должно быть равно q, да,
[21:45.280 --> 21:50.000]  мы же не только стрелки проводим и вершины, мы еще линки подсчитываем, линки и лену везде подсчитываем,
[21:50.000 --> 21:57.560]  вот, значит, почему линк от s, c это q, ну мы вроде замечали, что линк от s, c это всегда s0,
[21:57.560 --> 22:08.000]  линк от s, c это всегда s0, потому что здесь лежат слова суффиксы s, c, которые раньше не встречались,
[22:08.000 --> 22:13.680]  а s0 это самый длинный, который ранее встречался, ну понятно, это как раз самый долинный суффикс вот
[22:13.680 --> 22:17.840]  этой строки, у которого другой правый контекст, потому что он ранее встречался, а эти не встречались,
[22:17.840 --> 22:23.800]  поэтому вот это у нас всегда будет верно, ну а мы знаем, что s0 это в точности лонгист вот этого q,
[22:23.800 --> 22:31.400]  поэтому суффсылка отсюда ведет вот сюда, да, вот, ну и давайте здесь тоже вернемся, в этом случае я
[22:31.400 --> 22:36.760]  тоже суффсылку забыл назначить, в этом случае по тем же причинам линк от s, c это корень,
[22:36.760 --> 22:49.400]  потому что s0 это эпсилон, линк от s, c должно вести в s0, значит в корень, потому что корень это
[22:49.400 --> 23:06.720]  эпсилон, окей, ну вот, все, второй случай разобрали, остался третий, давайте. Нет, смотрите,
[23:06.720 --> 23:11.400]  нет, нет, нет, нет, нет, мы здесь как раз ничего не делаем, потому что здесь и так были переходы по
[23:11.400 --> 23:18.480]  c, смотрите, вот в этом случае вот этот автомат, который старый, в нем ничего вообще не меняется,
[23:18.600 --> 23:24.000]  то есть новые ребра могут меняться только ведущими vsc, вот эти ребра их не было в старом автомате,
[23:24.000 --> 23:29.900]  но они вот добавляются в новом, а ребра, заключенные между старыми вершинами не меняются, потому что
[23:29.900 --> 23:34.240]  вот в этом автомате не поменялся набор лонгистов, значит не поменялись ребра, то есть как бы вот этот
[23:34.240 --> 23:38.400]  набор вершин, он ровно такой же, как был раньше, вершины в нем такие же, ребра такие же, там вообще
[23:38.400 --> 23:44.980]  ничего не поменялось, только ребра ведущие vsc появляются больше ничего, да, только dp проводим и
[23:44.980 --> 23:55.340]  и брейкаемся. Да. Так, ну третий случай. Соответственно, когда вот это равенство неверно.
[23:55.340 --> 24:18.300]  Я как-то допрыгал до P, здесь с помощью буквы C попал в Q. И внезапно S0 наконец-то становится
[24:18.300 --> 24:23.740]  лонгестом. Раньше не было, теперь становится. То есть это тот случай, когда S0 раньше не был лонгестом,
[24:23.740 --> 24:42.380]  а теперь стал. Ну, потому что я знаю, что S0 обязательно становится новым лонгестом. Ну,
[24:42.380 --> 24:46.460]  точнее он точно будет лонгестом, потому что он лежит в другом классе по сравнению с СС.
[24:46.460 --> 24:52.460]  Но в этом случае он именно что становится. Он раньше не был лонгестом, а теперь становится.
[24:52.460 --> 25:00.860]  Потому что он был раньше в классе, внутри которого была более длинная строка. Значит,
[25:00.860 --> 25:06.260]  здесь на самом деле он не лонгест. Был раньше, а теперь становится лонгестом. Так, давайте нарисуем
[25:06.260 --> 25:12.780]  картинку, что происходит в Q вообще. В Q, как мы знаем, то есть я сейчас хочу нарисовать набор строк,
[25:12.780 --> 25:16.940]  которые попадают в Q, которые лежат в этом классе эквивалентности. Как мы знаем, здесь будет
[25:16.940 --> 25:21.220]  несколько строк, которые получаются друг из друга отбрасыванием первого символа.
[25:21.220 --> 25:33.240]  Вот пусть вот это вот будет все строчки из Q. Значит, где-то здесь будет строка S0. Причем она
[25:33.240 --> 25:38.900]  будет не самая длинная. Я знаю, что она лежит в Q, потому что получается дописыванием буквы C к
[25:38.900 --> 25:43.780]  лонгесту от P. Но при этом, по предположению, это не самая длинная строка. Если бы она была
[25:43.780 --> 25:50.300]  самая длинная, мы были в втором случае. Значит, вот S0 где-то здесь. Теперь смотрите, мы же помним,
[25:50.300 --> 25:54.300]  что лонгест у нас никогда не пропадает. Если строка однажды лонгест, то у нас всегда лонгест.
[25:54.300 --> 26:01.620]  Поэтому вот эта строка, которая есть лонгест от Q, она лонгестом остается. Единственное,
[26:01.620 --> 26:09.540]  что происходит, это S0 становится новым лонгестом. Значит, что происходит? Значит,
[26:09.540 --> 26:18.300]  этот большой класс расшепляется на два. Вот это вот то, что раньше было в Q, а вот это то,
[26:18.300 --> 26:22.260]  что раньше было в Q и под линией не больше, чем S0. Ну, потому что оно стало новым лонгестом,
[26:22.260 --> 26:25.660]  оно расстекло большой класс на два. Значит, класс устроен ровно так.
[26:42.820 --> 26:50.500]  Что же делать? Ну, хочешь не хочешь, нам придется завести новую вершину, которая будет отвечать вот
[26:50.500 --> 26:57.540]  этим вот всем словам. S0 и более коротким, которые раньше лежали в Q. Давайте я заведу новую вершину,
[26:57.540 --> 27:05.540]  обзову ее клон и буду считать, что в ней как раз лежат все вот эти вот слова, которые более
[27:05.540 --> 27:11.340]  короткие, чем S0 и более и все более короткие. Клон, потому что она будет очень похожа на Q. Ну,
[27:11.340 --> 27:16.620]  и вообще раньше это была одна вершина. То есть, вот эти вот слова и вот эти, которые теперь остаются
[27:16.620 --> 27:24.260]  в Q. То есть, это новая Q. Они раньше были в одном множестве. И, скажем, раньше все ребра ведущие в них
[27:24.260 --> 27:28.940]  и, скажем, исходящие из них были абсолютно одинаковы. То есть, эти все слова были, на самом деле,
[27:28.940 --> 27:35.220]  склеены в одну вершину. А теперь я их расщепляю. То есть, представьте, картинка была такая. Вот было
[27:35.220 --> 27:40.860]  одно большое Q, в него там какие-то ребра входили, какие-то выходили и вот здесь вот лежали все вот
[27:40.860 --> 27:47.340]  эти вот слова. Теперь я делаю следующее. Я часть этих слов оставляю в Q, а часть отщепляю в другой
[27:47.340 --> 27:52.700]  класс. Ну, тогда картинка просто будет такой. У меня там Q чуть-чуть уменьшится, будет вот такой.
[27:52.700 --> 27:58.300]  Появится клон, где все остальные слова лежат. Ну и, соответственно, какие-то стрелки вот здесь
[27:58.300 --> 28:06.660]  перенаправятся будут вот такими. И какие-то надо понять, что со стрелками исходящими будет.
[28:06.660 --> 28:15.420]  То есть, по факту, я просто под расщепляю один большой класс на два поменьше. Так, давайте
[28:15.420 --> 28:22.980]  начнем с, например, исходящих ребер. Я утверждаю, что множество ребер, исходящих из клона, будет
[28:22.980 --> 28:26.780]  такое же, как множество ребер, исходящих ранее из Q. То есть, вот эти вот стрелки, которые исходили из Q,
[28:26.780 --> 28:32.940]  они наследуются и сюда, и сюда. Ну, это вроде очевидно, что значит, что у меня была стрелка отсюда по
[28:32.940 --> 28:39.100]  букве А. Значит, я мог взять какое-то слово из этих, дописать А и попасть в другую вершину. Более того,
[28:39.100 --> 28:43.460]  я мог взять любое слово из этих, дописать А и попасть в одну и ту же вершину. Мы говорили, что наличие
[28:43.460 --> 28:48.220]  ребра значит, что какое бы слово я отсюда не взял, после дописывания буквы я попадаю в другую вершину.
[28:48.220 --> 28:53.340]  Ну, значит, и здесь все вот эти вот переходы по А, ну, точнее, один переход по А в какую-то вершину,
[28:53.340 --> 29:01.540]  скажем, Х, они остаются из Q, из клона. Ну, то есть, на самом деле, картинка будет вот такой. Потому что,
[29:01.540 --> 29:06.460]  если раньше ко всем этим словам можно было дописать А и попасть в Х, то, значит, и отсюда, и отсюда
[29:06.460 --> 29:13.780]  должен быть переход по А в Х. Поэтому, как минимум, все очень просто. Ну, там, как минимум, поэтому это
[29:13.780 --> 29:17.420]  что-то называется клон, потому что у нее, по крайней мере, множество исходящих ребер будет такой же,
[29:17.420 --> 29:26.700]  как у Q. Давайте зафиксируем, что множество ребер, исходящих из клон,
[29:26.700 --> 29:46.900]  такое же, как у Q. Ну, значит, исходящими мы разобрались. Теперь давайте с входящими разберемся.
[29:46.900 --> 29:52.380]  Но здесь все тоже не очень сложно. Давайте вспомним, как устроены входящие ребра вообще в вершину,
[29:52.540 --> 30:05.820]  чему они соответствуют. Что такое входящие ребра? В Q есть какие-то входящие ребра. Что это значит?
[30:05.820 --> 30:11.980]  Значит, можно было начать в корне, дойти до какой-то из этих шин, потом по букве С попасть в Q.
[30:11.980 --> 30:21.180]  И получить все вот это вот возможное множество слов.
[30:21.180 --> 30:34.980]  Так, но здесь, видимо, тогда важно будет сказать следующее замечание. Давайте утверждение это скажем.
[30:34.980 --> 30:55.180]  Множество ребер, ведущих в Q, устроено так, что мне проще картинкой показать, чем словесно это формулировать.
[30:55.180 --> 31:02.700]  Значит, смотрите, вот я знаю какой-то Q. Рассмотрим все ребра, которые в него вели.
[31:02.700 --> 31:11.420]  Значит, я утверждаю, что, во-первых, на них на всех написана одна и та же буква. Ну, в нашем случае С.
[31:11.420 --> 31:19.300]  Во-вторых, вот эти вот вершины являются сувсылками друг друга, ну, если их расположить в правильном
[31:19.300 --> 31:23.820]  порядке. То есть, если рассматривать самую большую из них, то она будет ссылаться по сувсылке на вторую.
[31:23.820 --> 31:32.540]  Вторая будет ссылаться на третью. Третья будет ссылаться на четвертую. Ну, почему это так?
[31:32.540 --> 31:43.580]  Потому что давайте опять я нарисую картинку, какие слова лежат в Q. Во-первых, они все заканчиваются на
[31:43.580 --> 31:48.580]  одну и ту же букву С. Потому что здесь не может быть пустой строки. Пустая строка у меня только в корне
[31:48.580 --> 31:53.220]  лежит. Здесь пустой строки нет, поэтому, поскольку они все являются суффиксами одной и той же строки,
[31:53.220 --> 31:57.460]  они все заканчиваются на С. Значит, на всех этих ребрах может быть только одна и та же буква С.
[31:57.460 --> 32:06.340]  Во-вторых, ну, вообще, что такое ребра ведущая откуда-то сюда? Значит, я могу, там, возможно,
[32:06.340 --> 32:11.340]  несколькими способами от корни добраться до сюда, к каждому из этих слов дописать С и попасть в Q.
[32:11.340 --> 32:16.140]  Ну, если я рассмотрю в качестве этой вершины самую длинную, то есть ту, у которой лен максимально,
[32:16.140 --> 32:22.380]  то это будут несколько самых длинных слов вот в этом вот наборе для Q. Потому что, ну,
[32:22.380 --> 32:26.660]  какой самый длинный путь ведет в Q? Мне нужно из них выбрать самую длинную вершину с максимальным
[32:26.660 --> 32:32.500]  лен, взять в ней лонгест и приписать С. И несколько его самых длинных суффиксов будут, соответственно,
[32:32.500 --> 32:41.100]  появляться из вот этой вершины. То есть, скажем, вот это вот приходит из какой-то вершины В1. Затем
[32:41.100 --> 32:46.100]  следующие слова появляются опять-таки из какой-то из этих вершин. Если я смотрю самое длинное из них,
[32:46.100 --> 32:52.020]  то как оно появилось? Ну, там из какой-то другой вершины В2. Причем понятное дело, что тогда обязательно
[32:52.020 --> 32:58.700]  В1 ссылается на В2, ну, потому что просто В2 это вот как раз вот следующее слово, являющееся суффиксом
[32:58.700 --> 33:02.980]  все той же самой длинной строки, которая лежит внезапно в другом классе. Значит, друг на друга
[33:02.980 --> 33:11.700]  ссылаются. Потом несколько строк будут из В2, несколько из В3, ну и так далее. И поскольку все вот эти
[33:11.700 --> 33:17.300]  строчки являются суффиксами друг друга и при этом лежат в разных классах вот этих вершин, значит,
[33:17.300 --> 33:21.500]  они все друг на друга ссылаются по суффиксам. Хорошо.
[33:33.980 --> 33:40.420]  Ну, что мы тогда можем сказать? Тогда мы знаем, как устроено все множество вершин, в виды из которых есть
[33:40.420 --> 33:51.620]  переход в Q. Давайте его нарисуем. Вот есть Q, вот где-то было P, но мы точно можем сказать, что P это
[33:51.620 --> 33:57.900]  не самая высокая вершина, из которой есть переход в Q, потому что самая высокая, она соответствует
[33:57.900 --> 34:03.180]  вот этой вот строке, а P наоборот соответствует вот этой строке, не являющейся лонгестом. Поэтому
[34:03.180 --> 34:08.980]  где-то там еще выше точно есть другие вот такие вот вершины, ну по крайней мере одна такая вершина,
[34:08.980 --> 34:16.860]  которая тоже ведет в Q по переходу. Вот, значит, какие-то там такие есть, да, P точно не самая
[34:16.860 --> 34:23.460]  длинная, но еще возможно несколько вершин, которые получаются из P взятием суффсылки, вот из них
[34:23.460 --> 34:32.460]  тоже были переходы по C в Q. Тогда что я должен сделать? Вот эти вершины, из которых раньше
[34:32.460 --> 34:39.900]  вел переход в Q, они соответствовали вот этим вот более длинным, чем S0 слова. Давайте тоже нарисую.
[34:39.900 --> 34:49.260]  У меня было S0 и какие-то более короткие. Соответственно, все, что выше, это вот эти вот
[34:49.260 --> 34:55.980]  вершины, потому что P соответствует с точностью S0. Все, что выше, вот эти вот другие вершины,
[34:55.980 --> 35:01.700]  более длинные, с большим леном, с большим лонгестом, они отвечают вот этим словам. Значит,
[35:01.700 --> 35:07.660]  после расщепления класса Q на Q и клон у меня эти ребра сохраняются, потому что они вели в более
[35:07.660 --> 35:14.100]  длинные слова, чем S0, они остаются в классе Q, поэтому эти ребра сохраняются. А вот эти вот серебра,
[35:14.100 --> 35:19.140]  поскольку они соответствовали каким-то вот таким вот словам, более коротким, чем S0, они
[35:19.140 --> 35:27.540]  перенаправляются в клона. То есть картинка будет такой. После расщепления Q на две вот эти вот
[35:27.540 --> 35:39.460]  ростные вершинки Q и клон верхние стрелки мне остаются в Q, а все, начиная с P, перенаправляются в клона.
[35:39.460 --> 35:50.300]  Ну, потому что все вот, все, которые, начиная с P, получают по сувсылкам, шли с помощью перехода
[35:50.300 --> 35:56.180]  по C в Q, это вот эти вот все слова, ну там, без последнего символа. Все они теперь попадают в
[35:56.180 --> 36:02.900]  клон. То есть я расщепляю Q на Q и клон. Значит, если раньше вот эти вот стрелки соответствовали
[36:02.900 --> 36:08.460]  вот этим словам, то я их, ну, собственно, просто провожу теперь ребра в клона, а не в Q, потому что
[36:08.460 --> 36:12.860]  теперь это разные состояния. То есть раньше они были все склеены, вели сюда. Теперь я Q расщепил
[36:12.860 --> 36:24.340]  на длинные слова и короткие. Все короткие слова теперь лежат в клоне. Да? Вот. Все, автомат перестроен.
[36:24.340 --> 36:34.580]  Да, да, да, да. Ну, я про ребра пока говорил, про автомат, про линк, сейчас тоже все выставим. Вот,
[36:34.620 --> 36:40.260]  значит, смотрите. Мы разобрались со всеми ребрами ведущими из клона. Мы這樣子, почему мы разобрались
[36:40.260 --> 36:44.820]  со всеми вершины ведущими в Q и в клон? Ну, потому что мы расщепили вот это вот множество слов.
[36:44.820 --> 36:51.360]  Соответственно, мне нужно разобрать только те стрелки, которые раньше вели в Q. Ну
[36:51.360 --> 36:54.340]  и, соответственно, перенаправить их часть. Останется ввести в Q, часть останется ввести в
[36:54.340 --> 36:59.860]  клон. Новых ребер, понятно дело, не возникнет. Потому что только вот эти вот ребра, которые раньше были
[36:59.860 --> 37:02.900]  были в автомате, которые раньше соответствовали одну из этих строк,
[37:02.900 --> 37:06.820]  они остаются вот в этом новом автомате, то есть здесь только
[37:06.820 --> 37:11.580]  просто расщепилось Q на два состояния, Q и клон. Все, больше ребер не появляется.
[37:11.580 --> 37:17.580]  В частности, смотрите, возможно, такая картина, что несколько сувсылок P мы
[37:17.580 --> 37:22.340]  перенаправляем в клона, то есть создаем ребро по букве C в клон, а из какой-то еще
[37:22.340 --> 37:26.620]  вершины, возможно, был другой уже переход по букве C в какую-то еще другую вершину.
[37:26.620 --> 37:32.260]  И вот тогда такой переход я не исправляю, ну, потому что он вел куда-то в другое место,
[37:32.260 --> 37:38.300]  этого уже не связано никак с Q. Здесь в этой части автомата никакие ломгисты не поменялись,
[37:38.300 --> 37:47.580]  поэтому все ребра корректны. Так, давайте продолжать. Мне осталась здесь косметика какая-то,
[37:47.580 --> 37:52.700]  значит, я провел все вершины, создал новые вершины, новые ребра, все провел, остались
[37:52.700 --> 37:58.940]  линки и лены. Ну, давайте разберемся со всем вот этим вот. Значит, во-первых,
[37:58.940 --> 38:09.340]  наше любимое утверждение, скажите, пожалуйста, чему равно линк это с C? С0, а в терминах вершин?
[38:09.340 --> 38:18.580]  Клон. Да, потому что клон, это как раз вот с С0 начинается и все более короткие. Дальше,
[38:18.580 --> 38:32.500]  что такое линк от Q? Тоже скажите, пожалуйста, мне. Клон. Потому что, ну, что такое линк от Q,
[38:32.500 --> 38:37.660]  вспоминаем, это если я беру самую длинную строчку в этом классе, отбрасываю по одному символу и
[38:37.660 --> 38:42.220]  дожидаюсь, когда я перехожу в новое состояние. Ну, как мы знаем, несколько самых длинных строчек
[38:42.220 --> 38:47.780]  лежат в Q, а следующий уже лежит в склоне, поэтому линк от Q это клон. Ну, и наконец,
[38:47.780 --> 38:58.980]  надо написать, чему равно линк от клон. Это я, давайте так, как быдло напишу, old link от Q. Ну,
[38:58.980 --> 39:05.500]  в том смысле, что новая ссылка из клона такая же, как раньше была из Q. Это тоже вроде очевидно,
[39:05.500 --> 39:10.420]  вот опять же по этой картинке. Раньше в Q лежали все вот эти вот строчки, а link это вот эта вот
[39:10.420 --> 39:17.740]  строка следующая, да, вот следующая ниже, чем самая короткая в Q. Ну, значит, это будет новая линка
[39:17.740 --> 39:23.780]  для клона. Потому что опять отбрасываю, отбрасываю по одной букве, пока не попаду вот сюда, что ранее
[39:23.780 --> 39:31.660]  было линкой от всего этого класса, то есть old link от Q. Вот, значит, с линками разобрались,
[39:31.660 --> 39:43.460]  давайте с длиной еще все напишем, линк от клона, это линк от P плюс 1, потому что самая длинная
[39:43.460 --> 39:51.980]  строка в клоне это S0, а мы знаем, что у S0 такая длина. Линк от Q не меняется, да, потому что в Q
[39:51.980 --> 39:58.020]  остается вот эта самая длинная строка, линк от Q не меняется, ну и там линк от SC, тоже на самом
[39:58.020 --> 40:05.620]  деле везде это надо было писать, что линк от SC это линк от S плюс 1. То есть в момент, когда мы начинаем
[40:05.620 --> 40:11.060]  проводить ребра из S в SC, я сразу могу сказать, что линк от SC это линк от S плюс 1, ну потому что
[40:11.060 --> 40:23.740]  получается дописывание одного символа. Все, алгоритм закончился. Вопросы есть? Хорошо, тогда давайте
[40:23.740 --> 40:39.980]  анализировать асимптотику. Значит, здесь на самом деле два вопроса. Многое понятно, что работает за
[40:39.980 --> 40:45.140]  линейное время. Например, мы знаем, что поскольку на каждом шаге вершин добавляется максимум 2,
[40:45.140 --> 40:53.780]  то вершин точно всегда линейное количество, максимум 2n. Что еще можно сказать? Ну, на самом
[40:53.780 --> 40:58.860]  деле здесь есть два тонких места, которые надо проанализировать. Во-первых, это вот эти вот вайлы,
[40:58.860 --> 41:07.620]  пока я спускаюсь от S, многократно беря су-всылку и проводя ребра ведущие в SC. То есть я вот отсюда,
[41:07.620 --> 41:12.660]  там как в первом случае, у меня есть S, я провожу ребро, беру су-всылку, провожу ребро, беру су-всылку
[41:13.540 --> 41:18.020]  пока не найду либо вот такого ребра, либо пока не дадут до корня. То есть у меня есть, по крайней мере,
[41:18.020 --> 41:25.940]  один вайл, который вот проводит ребра в SC. Дальше аналогично, вот здесь вот происходит какой-то вайл.
[41:25.940 --> 41:33.500]  Пока, то есть я не дойду до вершины, из которой переход по C ведет в другую вершину, вот на этой
[41:33.500 --> 41:38.940]  картинке, я прыгаю по су-всылкам и перенаправляю все ребра, которые раньше ввели в Q, теперь они
[41:38.940 --> 41:48.780]  будут вести в клон. То есть это второй вайл. Вот вайл, вот здесь вайл, пока мы находим это
[41:48.780 --> 41:57.220]  самое P. Ну и третий, на самом деле, тонкий момент, это перекопирование ребер ведущих из Q в клон.
[41:57.220 --> 42:03.460]  Вот здесь у меня была картинка, что все эти ребра, которые раньше вели из Q, они остаются в Q,
[42:03.460 --> 42:08.740]  а также теперь ведут из клона. Ну и вообще говоря, непонятно, сколько там ребер. Хорошо,
[42:08.740 --> 42:17.980]  если их мало, но их может быть много. Так, давайте начнем вот с этого последнего момента. Докажем
[42:17.980 --> 42:38.140]  следующее. Так, сейчас один момент. Там сойдется. Да, должно сойтись. Значит, вершин в суффиксном
[42:38.140 --> 42:55.380]  автомате строки S, где длина S равна m, не больше, чем 2n, а ребер не больше, чем 3n.
[42:55.380 --> 43:09.260]  Поэтому, в частности, давайте проверюемся. Если я это докажу, то вот тот мой третий тонкий момент,
[43:09.260 --> 43:15.660]  когда я перекопирую ребра из Q так, чтобы они вели из клона, суммарно работает за линию, потому что
[43:15.660 --> 43:22.140]  когда я провожу ребра из клона, я увеличиваю число ребер в графе, а суммарно их максимум 3n. То есть у
[43:22.140 --> 43:27.300]  меня были ребра только из Q, я продублировал Q, сделал Q и клон, и все эти ребра перекопировал
[43:27.300 --> 43:32.140]  в клона. Каждое перекопирование увеличивает число ребер на 1, поэтому суммарно таких перекопирований
[43:32.140 --> 43:36.940]  максимум линейное время. Если мы это докажем, то мы поймем, что вот это перекопирование ребер из
[43:36.940 --> 43:44.100]  Q в клона работает суммарно за линию. Доказательства первые мы уже знаем, потому что на каждом шаге
[43:44.100 --> 43:52.100]  добавляется максимум две вершины. Второе. Так, ну сейчас попробую. Тут у меня обычно проблемы с этим.
[44:02.100 --> 44:12.580]  Хорошо, давайте сделаем следующее. У нас есть автомат, в котором из корня, то есть из старта вершины,
[44:12.580 --> 44:17.500]  достижимы все остальные. Ну понятно, у нас вершины только такие, что они достижимы из старта, они соответствуют
[44:17.500 --> 44:24.820]  подсрочку. Так вот, давайте в этом вот ориентированном графе, в котором из корня все
[44:24.820 --> 44:28.260]  достижимы. Давайте фиксируем какое-то ориентированное основное дерево.
[44:44.820 --> 44:54.500]  То есть, у нас есть где-то корень, старт наш. Давайте выберем такой набор ребер, чтобы по нему
[44:54.500 --> 45:04.940]  можно было из старта добраться до куда угодно. Ну и так далее. Понятно, что поскольку из старта можно
[45:04.940 --> 45:10.700]  с помощью ребер до куда угодно добраться, то я могу выбрать какое-то дерево. На самом деле это надо
[45:10.700 --> 45:15.060]  еще доказать, но давайте, давайте считать, что мы это знаем. Вроде естественно, кажется, раз можно
[45:15.060 --> 45:21.100]  добраться, то вот, ну, можно добраться с помощью ДФС, да, дерево ДФС, действительно. Вот, ну возьмем
[45:21.100 --> 45:32.780]  дерево ДФС. Сколько в нем ребер? Значит, ребер в этом дереве точно не больше, чем 2n-1, потому что
[45:32.780 --> 45:38.900]  вершин максимум столько, а ребер в дереве на 1 меньше. Значит, мне теперь хочется доказать,
[45:38.900 --> 45:42.340]  что ребер вне остого мало, не больше, чем n.
[45:42.340 --> 46:02.860]  Сейчас докажем, что ребер вне остого мало, не больше, чем n.
[46:02.860 --> 46:09.540]  Ну окей, давайте рассмотрим какое-то ребро вне остого.
[46:09.540 --> 46:22.420]  Давайте с этим ребром ассоциируем следующий путь. Во-первых, мы из корня по остовным
[46:22.420 --> 46:31.620]  ребрам дойдем до начала этого ребра. Ну, поскольку такой путь, как бы, поскольку он недостижимый,
[46:31.620 --> 46:37.460]  значит, есть путь по остовному. Потом используем это ребро и потом отсюда, как угодно, каким угодно
[46:37.460 --> 46:46.860]  образом дойдем до произвольной терминальной вершины. Причем, возможно, используя не остовные
[46:46.860 --> 46:50.940]  ребра. Возможно, остовные, возможно, не остовные. Что хотим, то и используем. Значит, здесь произвольные
[46:50.940 --> 47:00.500]  ребра. Почему так можно сделать? Ну, потому что эта вершина соответствует некоторой подстроке нашей
[47:00.500 --> 47:05.140]  строки. Понятно, что из любой подстроки можно дойти до терминала, потому что терминал это суффикс.
[47:05.140 --> 47:13.060]  Из подстроки можно дойти до суффикса всегда. Поэтому такой путь всегда есть. Итак, я каждое не остовное
[47:13.060 --> 47:20.300]  ребро ассоциировал с некоторым путем, который, в свою очередь, соответствует суффиксу. Ну, понятно,
[47:20.300 --> 47:24.540]  если прочитать вот эти вот все буквы, то я получу суффикс, потому что я от корня дошел до терминала.
[47:24.540 --> 47:37.860]  Значит, этот путь соответствует суффиксу. Причем, что несложно заметить, разные пути будут
[47:37.860 --> 47:43.340]  соответствовать разным суффиксам. Потому что, как минимум, у них будет отличаться вот это вот первое
[47:43.340 --> 47:44.060]  не остовное ребро.
[48:13.340 --> 48:30.420]  Понятно? Ну, это разные пути, потому что, если я на каждом пути посмотрю первое не остовное, то,
[48:30.420 --> 48:35.900]  поскольку я для всех разных не остовных ребер строю такие пути, то все пути различны. Ну,
[48:35.900 --> 48:42.500]  и, соответственно, строки, которые у них написаны, тоже различны. Вот. Значит, их не более
[48:42.500 --> 48:59.020]  n, потому что они все суффиксы, и это все различные суффиксы. Победа. Давайте. Значит, еще раз
[48:59.020 --> 49:04.620]  овервью количество ребер. Я делаю следующее. Сначала я фиксирую некое остовное дерево,
[49:05.020 --> 49:09.740]  например, дерево обхода ДФС, которое посещает все из старта. То есть, он начинается в старте,
[49:09.740 --> 49:15.140]  и с помощью его ребер можно дойти до всех решений автомата. Таких ребер вот столько максимум.
[49:15.140 --> 49:20.940]  Дальше. Давайте рассмотрим все остальные неостовные ребра. Я утверждаю, что вот таких вот ребер,
[49:20.940 --> 49:26.980]  которые не в остове лежат, их не больше, чем n. Почему? Давайте с каждым таким неостовным ребром
[49:26.980 --> 49:32.980]  ассоциируем путь, который ведет из корня до начала этого ребра по остовным ребрам. Такое есть,
[49:32.980 --> 49:39.140]  потому что из корня все достижено по остову. А из конца ребра я пойду до произвольной терминальной
[49:39.140 --> 49:43.780]  вершины и использую какие угодно ребра. Не обязательно остовные. Какие угодно ребра. Такое опять-таки
[49:43.780 --> 49:50.980]  есть, потому что это подстрока, и из подстроки можно всегда дойти до суффиксов. Вот. Получается,
[49:50.980 --> 49:57.180]  что каждому неостовному ребру я поставил соответственно некоторый суффикс. Потому что
[49:57.180 --> 50:03.620]  вот это вот все идет из корня в терминал, значит это суффикс. Да, конечно. Суффикс на автомате
[50:03.620 --> 50:09.380]  терминированный. Вот. Тогда соответственно разные пути отвечают разным суффиксам, потому что они
[50:09.380 --> 50:15.660]  отличаются как минимум вот в этом первом ребре неостовном. Ну и соответственно как бы равны они
[50:15.660 --> 50:23.340]  могли бы быть только если бы они шли вот ровно по одинаковому пути. Ну то есть вот эти вот суффиксы,
[50:23.420 --> 50:27.300]  с케ильницы, да. Суффиксы, отвечающие разным путям, могут быть равны. Что значит, что там два пути
[50:27.300 --> 50:31.940]  дают одинаковые суффиксы? Этоuras эти пути и сами одинаковые, потому что у них совпадает
[50:31.940 --> 50:34.540]  первый рябро, то есть первый символ, то есть первое рябро. Второй символ, то есть
[50:34.540 --> 50:38.220]  второй рябро. Третий символ, то есть третий рябро. Четвертый символ, то есть четвертый spare
[50:38.220 --> 50:42.340]  rebro. Да, потому что как раз tatsächlichiten, потому что как раз детерминированность.
[50:42.340 --> 50:44.700] west да, потому что как раз д disse Мар Mia ну все. Значит мы получили, что каждое такое
[50:44.700 --> 50:47.620]  ребро отвечает какому-то софиксу, такие ребра отвечают
[50:47.620 --> 50:49.420]  разным софиксам, значит их всего максимально.
[50:49.420 --> 50:52.540]  Ну там n плюс один, окей, для формальности n плюс один,
[50:52.540 --> 50:56.500]  потому что есть пустой сфикс еще у строки, да, профит.
[50:56.500 --> 51:03.700]  Да, все, значит, как я сказал, момент перекопирования
[51:03.700 --> 51:06.700]  ребер из Q в клон работает суммарно за линейное время,
[51:06.700 --> 51:08.700]  потому что на ребер у нас линия.
[51:08.700 --> 51:15.620]  Вот, сейчас осталось только этой доказать.
[51:15.620 --> 51:26.820]  Значит, осталось доказать, что, ну, как вы говорите,
[51:26.820 --> 51:33.260]  спуск по линкам суммарно работает за вот n.
[51:33.260 --> 51:45.060]  На самом деле очень просто, потому что верно следующее.
[51:45.060 --> 51:50.300]  Смотрите, вот, не совсем, потому что когда мы из paper
[51:50.300 --> 51:52.340]  направляем ребра, которые раньше выливку, мы на самом
[51:52.340 --> 51:54.060]  деле меняем ребра, мы их не проводим.
[51:54.060 --> 51:58.300]  Поэтому тут лучше другой аргумент использовать.
[51:58.300 --> 51:59.660]  Значит, смотрите, что мы делали.
[52:00.060 --> 52:04.980]  Вот мы спускались по су-всылкам, и с первого блока мы провели
[52:04.980 --> 52:10.900]  ребро в СС, потом из второго блока мы перенаправляли
[52:10.900 --> 52:18.060]  ребра ведущие в Q, так что мы теперь ввели в клона.
[52:18.060 --> 52:19.060]  Больше ничего не делаем.
[52:19.060 --> 52:23.740]  Смотрите тогда, в этом случае у меня очень сильно,
[52:23.740 --> 52:26.500]  если я провожу много таких ребер, то у меня очень сильно
[52:26.500 --> 52:33.340]  убывает длина пути по су-всылкам, ну, количество
[52:33.340 --> 52:36.020]  путей в этом многократном применении су-всылки, потому
[52:36.020 --> 52:38.260]  что раньше был вот такой длинный путь.
[52:38.260 --> 52:40.700]  Теперь, при переходе к новому автомату, у меня будет
[52:40.700 --> 52:43.660]  СС, который ссылается на клона, мы знаем, что клон
[52:44.660 --> 52:48.540]  Следующая, ну, точнее, клон является у ссылка СС.
[52:48.540 --> 52:51.740]  Так, а, тут надо аккуратнее сказать.
[52:51.740 --> 52:57.940]  Сейчас, момент, картинка надо побольше просто.
[52:57.940 --> 53:08.460]  Вот эти вот все ведут в СС, потом была та самая, давайте
[53:08.460 --> 53:10.700]  самый стрёмный случай, третий рассматриваю.
[53:10.700 --> 53:12.980]  Значит, раньше она веловку, теперь перенаправляется
[53:12.980 --> 53:18.020]  в клона вместе с несколькими вот этими вершинами, и дальше
[53:18.020 --> 53:21.260]  остаются какие-то вершины, которые я не трогаю, и ребра
[53:21.260 --> 53:22.260]  из них не меняются.
[53:22.260 --> 53:27.260]  Давайте вообще посмотрим, давайте точно также разобьём
[53:27.260 --> 53:30.620]  все вот эти вот вершины, более низкие, как из них
[53:30.620 --> 53:33.660]  устроено ребро по букве С, ну, понятно опять, да, вот
[53:33.660 --> 53:37.300]  они разбиваются на некоторые группы, так что внутри группы
[53:37.300 --> 53:39.420]  у меня ребро по букве С ведёт в одну и ту же вершину.
[53:39.420 --> 53:41.140]  То есть, по факту, у меня вот этот вот старый путь по
[53:41.380 --> 53:44.060]  ссылкам разбивается на несколько блоков, первый,
[53:44.060 --> 53:48.820]  второй, третий, четвёртый, так что внутри блока все
[53:48.820 --> 53:51.660]  переходы по С либо одновременно отсутствовали, либо одновременно
[53:51.660 --> 53:54.180]  вели в одну и ту же вершину.
[53:54.180 --> 53:58.420]  Вот, тогда давайте проследим, как этот путь трансформируется
[53:58.420 --> 53:59.420]  в новом автомате.
[53:59.420 --> 54:03.740]  Последней вершиной будет СС, она будет ссылаться
[54:03.740 --> 54:08.660]  на клон, клон будет ссылаться вот сюда, ну, потому что
[54:08.820 --> 54:09.820]  что это такое?
[54:09.820 --> 54:12.380]  Это вот мы отбрасываем самую левую букву, попали сюда,
[54:12.380 --> 54:14.460]  до писалицы попали сюда, но это вот как раз получается
[54:14.460 --> 54:16.740]  они отличаются отбрасыванием самой левой буквы.
[54:16.740 --> 54:20.300]  Это будет ссылаться сюда, ну, и там они, вот это потом
[54:20.300 --> 54:21.300]  идёт в корень.
[54:21.300 --> 54:28.300]  Тем самым, смотрите, чем больше я здесь вершин обработал,
[54:29.620 --> 54:31.100]  тем меньше у меня будет вершин вот на этом пути.
[54:31.100 --> 54:40.100]  Пока не дошло, давайте какие-нибудь буквы напишем.
[54:40.100 --> 54:47.100]  Ну, что-то пусть на старом пути по су-всылкам,
[55:01.620 --> 55:02.940]  было х вершин.
[55:02.940 --> 55:09.940]  Пусть мы создали или перенаправили
[55:20.620 --> 55:24.740]  к ребер, то есть суммарно вот этих вот ребер плюс
[55:24.740 --> 55:28.100]  вот этих вот, которые я либо направил в СС, либо в клона,
[55:28.100 --> 55:29.100]  пусть их суммарно к.
[55:29.100 --> 55:31.780]  Вот здесь вот суммарно к ребер.
[55:31.780 --> 55:38.780]  Тогда в новом пути по су-всылкам, ну, который начинается
[55:43.900 --> 55:49.980]  из СС, то есть из вот этого вот, не больше, чем х-к
[55:49.980 --> 55:50.980]  плюс одна вершина.
[55:50.980 --> 55:53.980]  Какое?
[55:54.980 --> 56:01.980]  Потому что вот здесь мы ребра не проводим, а перенаправляем.
[56:08.220 --> 56:09.220]  Не появляется.
[56:09.220 --> 56:14.220]  Оно было, мы его просто перенаправили.
[56:14.220 --> 56:16.620]  Оно раньше веловку, я просто поменял, что оно теперь показывает
[56:16.620 --> 56:17.620]  в клоны.
[56:17.620 --> 56:27.500]  Ну, тут по-другому, по-другому не получается, да.
[56:27.500 --> 56:29.900]  Потому что именно, что эти ребра не появляются, они
[56:29.900 --> 56:31.140]  просто перенаправляются.
[56:31.140 --> 56:32.140]  Вот.
[56:32.140 --> 56:34.620]  Ну, верно, вот это вот утверждение, потому что, смотрите, вот
[56:34.620 --> 56:38.340]  пусть вот здесь вот суммарно х-вершин, тогда это же, что,
[56:38.340 --> 56:42.580]  ну, во-первых, на этом пути вершин не больше, чем х,
[56:42.580 --> 56:44.380]  потому что как получается вот этот вот путь?
[56:44.380 --> 56:46.660]  Он получается группировкой вот этих х-вершин некоторыми
[56:46.660 --> 56:49.020]  блоками, что внутри блока они все по буквеце указывают
[56:49.020 --> 56:50.820]  в одну из вершин вот этого второго пути.
[56:50.820 --> 56:55.340]  Ну, картинка, да, просто мы показали.
[56:55.340 --> 57:02.340]  Более того, вот эти вот суммарно ребра и вот эти вот ребра,
[57:02.340 --> 57:06.260]  они не просто переходят в столько же вершин, сколько
[57:06.260 --> 57:09.260]  было здесь, они сильно уменьшают количество вершин, потому
[57:09.260 --> 57:12.460]  что вот если здесь там было, скажем, к1 ребер, то вот
[57:12.460 --> 57:15.540]  эти вот к1 вершины перешли в одну вершину, эти к2 вершины
[57:15.540 --> 57:18.060]  перешли в одну вершину, получается, суммарно у меня
[57:18.060 --> 57:20.980]  число этих вершин уменьшилось не просто на, ну, точнее,
[57:20.980 --> 57:23.380]  оно не просто осталось таким, как было, оно уменьшилось
[57:23.380 --> 57:27.580]  по крайней мере на к1 плюс к2, потому что вот эти вершины
[57:27.580 --> 57:36.900]  склеились в одну и вот эти склеились в одну.
[57:36.900 --> 57:41.540]  Вот здесь х, вот здесь суммарно к ребер направлено из этого
[57:41.540 --> 57:50.100]  блока сюда, плюс отсюда сюда, да, это, ну, смотрите,
[57:50.100 --> 57:52.940]  вот это вот, это с и все суфссылки, которые я брал
[57:52.940 --> 57:56.980]  от него, из них проводил ребро в СС, потом взял очередную
[57:56.980 --> 57:59.540]  суфссылку и перешел в П, несколько опять суфссылок
[57:59.540 --> 58:02.620]  перенаправил в клона, ну а дальше опять продолжение
[58:02.620 --> 58:05.780]  пути по суфссылкам, но он устроен так же, там некоторыми
[58:05.780 --> 58:09.940]  блоками они объединяются и ведут в одну новую вершину
[58:10.180 --> 58:12.180]  по вот этому уже новому пути по суфссылкам, то есть
[58:12.180 --> 58:14.880]  вот это старый путь по суфс ссылкам, с и все его суфиксы.
[58:14.900 --> 58:16.840]  Это новый, СС и все его суфиксы.
[58:18.400 --> 58:18.900]  Вот.
[58:19.000 --> 58:21.500]  Ну и, соответственно, чем больше я здесь вершины
[58:21.500 --> 58:24.400]  объединяю в один класс, чем больше вершин имеют ребро
[58:24.400 --> 58:27.560]  в СС, и чем больше вершин имеют ребро в клона, темane
[58:27.560 --> 58:30.460]  вершину этом пути, да, то есть, каждое такое ребро
[58:30.460 --> 58:32.280]  уменьшает здесь количество вершин на один.
[58:34.980 --> 58:35.860]  Ну вот.
[58:35.860 --> 58:43.060]  Ну как, ну потому что можно сказать, что x это потенциал.
[58:43.060 --> 58:49.000]  Ну типа интуиция такая, смотрите, вот пусть и давайте
[58:49.000 --> 58:50.740]  следить за значением перемены x.
[58:50.740 --> 58:52.900]  Вот раньше у меня было здесь x-вершин.
[58:52.900 --> 58:55.620]  Если я суммарно сделал, суммарно вайлы мои проработали
[58:55.620 --> 58:58.980]  к действии, то есть я k-рёбер создал, да, вот здесь вот
[58:58.980 --> 59:02.740]  и здесь вот, то у меня x уменьшилось на k.
[59:02.740 --> 59:04.620]  Ну и при этом потом выросло максимум на 1.
[59:04.620 --> 59:07.180]  Может на 2 из-за того, что вот еще s, c добавилось.
[59:07.180 --> 59:09.180]  Ну короче вот там 1 или 2 здесь констант.
[59:09.180 --> 59:15.380]  Вот, значит суммарно уменьшений не больше, чем суммарно увеличений,
[59:15.380 --> 59:16.380]  а их n.
[59:16.380 --> 59:18.540]  Значит и уменьшение максимум n.
[59:18.540 --> 59:20.580]  А уменьшение это ровно столько, сколько вайлы суммарно
[59:20.580 --> 59:21.580]  работали.
[59:21.580 --> 59:25.940]  Так, все умерли, да?
[59:25.940 --> 59:27.660]  Ну подумайте, здесь на самом деле правда несложное
[59:27.660 --> 59:30.100]  рассуждение, то есть просто сравните вот эти вот два
[59:30.100 --> 59:31.460]  пути по сувсылкам.
[59:31.460 --> 59:34.460]  Первый, который s и все его сувсылки, да, многократное
[59:34.460 --> 59:35.460]  применение.
[59:35.460 --> 59:37.220]  И s и все его многократное применение.
[59:37.220 --> 59:39.820]  Я утверждаю, что они разбиваются ровно так.
[59:39.820 --> 59:42.820]  Старый путь разбивается на блоке вершин, так что
[59:42.820 --> 59:46.740]  внутри блока они все ведут по букве c в одну из вершин
[59:46.740 --> 59:49.300]  второго пути, а вот так вот они все разбиваются.
[59:49.300 --> 59:51.540]  Тогда чем больше ребер здесь проведено, тем меньше
[59:51.540 --> 59:52.540]  вершин на этом пути.
[59:52.540 --> 01:00:09.500]  Х, можно просто сказать, что х это потенциал, да.
[01:00:09.500 --> 01:00:14.840]  Ну от текущего, да, скорее, да, от текущего самого
[01:00:14.840 --> 01:00:17.620]  длинного сувфикса количество ребер, количество вершин
[01:00:17.620 --> 01:00:18.620]  на пути по сувсылкам.
[01:00:19.620 --> 01:00:20.620]  Наверное.
[01:00:20.620 --> 01:00:21.620]  Так.
[01:00:21.620 --> 01:00:25.620]  Может какой-то вопрос конкретный есть, я на него тогда отвечу,
[01:00:25.620 --> 01:00:26.620]  если нет, то будем дальше.
[01:00:26.620 --> 01:00:27.620]  Ладно.
[01:00:27.620 --> 01:00:28.620]  Ладно.
[01:00:28.620 --> 01:00:29.620]  Ну как?
[01:00:29.620 --> 01:00:44.620]  Потому что вот, типа мы знаем, вот тут написано,
[01:00:44.620 --> 01:00:45.620]  сколько вершин вот на этом пути.
[01:00:45.620 --> 01:00:47.620]  Максимум там на плюс один.
[01:00:48.620 --> 01:00:51.620]  Потому что, опять, потому что, еще раз, потому что
[01:00:51.620 --> 01:00:53.620]  вот этот путь по сравнению с этим путем разбивается
[01:00:53.620 --> 01:00:54.620]  на блоке.
[01:00:54.620 --> 01:00:56.620]  Блок вершин ведет в одну.
[01:00:56.620 --> 01:00:58.620]  То есть как бы к1 вершин соответствует одной вершине
[01:00:58.620 --> 01:01:01.620]  здесь, к2 вершин соответствует одной вершине здесь, к3 здесь
[01:01:01.620 --> 01:01:02.620]  и так далее.
[01:01:02.620 --> 01:01:04.620]  Поэтому суммарно здесь вершин мы не больше, чем здесь.
[01:01:14.620 --> 01:01:16.620]  Ну тут, подожди, тут с корнем надо.
[01:01:16.620 --> 01:01:17.620]  Тут, сейчас, сейчас, сейчас.
[01:01:20.620 --> 01:01:22.620]  Давайте, окей, давайте какую-то картинку нарисую.
[01:01:34.620 --> 01:01:36.620]  Корень, который ведет куда-то еще.
[01:01:40.620 --> 01:01:41.620]  Вот, смотрите.
[01:01:41.620 --> 01:01:43.620]  Значит, как, как, вот пусть картинка такая.
[01:01:43.620 --> 01:01:44.620]  Причем это корень.
[01:01:44.620 --> 01:01:46.620]  То есть я, вот, вот этот левый, левый путь у меня,
[01:01:46.620 --> 01:01:48.620]  это путь по суфссылкам, начиная от s.
[01:01:48.620 --> 01:01:49.620]  Да, вот это все суфссылки.
[01:01:49.620 --> 01:01:51.620]  Он заканчивается в корне.
[01:01:52.620 --> 01:01:53.620]  Картинка такая.
[01:01:53.620 --> 01:01:56.620]  Тогда второй путь, это вот, это вот.
[01:01:58.620 --> 01:02:00.620]  И вот это последний суфсыслок как раз плюс один.
[01:02:02.620 --> 01:02:04.620]  То есть, смотрите, вот это вот разбивается на блоке.
[01:02:04.620 --> 01:02:06.620]  Первый блок, второй блок, третий блок.
[01:02:06.620 --> 01:02:08.620]  Соответственно, первый блок соответствует одной вершине.
[01:02:08.620 --> 01:02:10.620]  Второй блок, второй вершине, третий блок, третьей вершине.
[01:02:10.620 --> 01:02:13.620]  И плюс еще корень куда никого не ведет,
[01:02:13.620 --> 01:02:16.620]  куда никого не ведет, но который, тем не менее, на этом пути по ссылкам есть.
[01:02:16.620 --> 01:02:18.620]  Поэтому плюс один.
[01:02:23.620 --> 01:02:25.620]  Жесть, всех убил.
[01:02:25.620 --> 01:02:27.620]  Ну давайте дальше тогда.
[01:02:27.620 --> 01:02:29.620]  Что тут из сети?
[01:02:34.620 --> 01:02:36.620]  Поймете.
[01:02:36.620 --> 01:02:38.620]  Все, получается, что за линию работает.
[01:02:38.620 --> 01:02:40.620]  А это на экзаменах?
[01:02:40.620 --> 01:02:42.620]  Да, ну вот что тут изи же все.
[01:02:43.620 --> 01:02:44.620]  Вот.
[01:02:44.620 --> 01:02:46.620]  Значит давайте последнее.
[01:02:46.620 --> 01:02:48.620]  Это суффиксная массив за линией на время.
[01:03:00.620 --> 01:03:02.620]  По суффитомату.
[01:03:06.620 --> 01:03:08.620]  Значит смотрите.
[01:03:08.620 --> 01:03:10.620]  Мы умеем строить за Н.Лугенцев масс.
[01:03:11.620 --> 01:03:13.620]  И умеем за линию строить суффитомат.
[01:03:13.620 --> 01:03:15.620]  Давайте мы сначала построим суффитомат.
[01:03:15.620 --> 01:03:17.620]  Потом за линией на время построим по нему суффиксный массив.
[01:03:17.620 --> 01:03:19.620]  Ну чтобы было быстрее, чем то, что мы уже умеем.
[01:03:23.620 --> 01:03:25.620]  Чтобы проверить по строке на равенство, например.
[01:03:27.620 --> 01:03:29.620]  По индексам.
[01:03:29.620 --> 01:03:31.620]  Не, суффмасс что-то умеет.
[01:03:31.620 --> 01:03:33.620]  Я не знаю.
[01:03:33.620 --> 01:03:35.620]  Должно.
[01:03:35.620 --> 01:03:37.620]  Так.
[01:03:37.620 --> 01:03:39.620]  Значит смотрите.
[01:03:39.620 --> 01:03:41.620]  Что я сделаю?
[01:03:41.620 --> 01:03:43.620]  Первое, что я сделаю, это я сожму так называемые проходные вершины.
[01:03:45.620 --> 01:03:47.620]  Сожмем.
[01:03:47.620 --> 01:03:49.620]  Проходные вершины.
[01:03:53.620 --> 01:03:55.620]  Это вершины, у которых всего одно исходящее ребро.
[01:03:55.620 --> 01:03:57.620]  И которые при этом не являются терминальными.
[01:03:59.620 --> 01:04:01.620]  Проходные.
[01:04:01.620 --> 01:04:03.620]  Давайте напишу не терминальные вершины.
[01:04:03.620 --> 01:04:05.620]  То есть если была какая-то вершина,
[01:04:05.620 --> 01:04:07.620]  не являющаяся терминальной,
[01:04:07.620 --> 01:04:09.620]  из которой всего одно ребро исходит,
[01:04:09.620 --> 01:04:11.620]  то на самом деле картинка имеет какой-то такой вид.
[01:04:13.620 --> 01:04:15.620]  Ну там, возможно, несколько ребер в нее ведут.
[01:04:15.620 --> 01:04:17.620]  Потом по букве С есть из нее один всего переход.
[01:04:17.620 --> 01:04:19.620]  Тогда я эту картинку могу сжать следующим образом.
[01:04:19.620 --> 01:04:21.620]  То есть вот из этого я строю такую картинку.
[01:04:23.620 --> 01:04:25.620]  Ну понятно.
[01:04:25.620 --> 01:04:27.620]  Если здесь было А и Б,
[01:04:27.620 --> 01:04:29.620]  то здесь будет написано А и Б.
[01:04:29.620 --> 01:04:31.620]  Ну понятно.
[01:04:31.620 --> 01:04:33.620]  Если здесь было А и Б,
[01:04:33.620 --> 01:04:35.620]  то здесь будет написано АС, а здесь БС.
[01:04:41.620 --> 01:04:43.620]  Сжатие этой вершинки.
[01:04:43.620 --> 01:04:45.620]  То есть я вижу, что из нее
[01:04:45.620 --> 01:04:47.620]  продолжение единственным образом определено.
[01:04:47.620 --> 01:04:49.620]  Поэтому давайте я не буду...
[01:04:49.620 --> 01:04:51.620]  Я просто ее удалю, скажу, что нет такой сущности.
[01:04:51.620 --> 01:04:53.620]  У меня просто вот отсюда я могу сразу прыгнуть
[01:04:53.620 --> 01:04:55.620]  сюда за АС,
[01:04:55.620 --> 01:04:57.620]  отсюда сюда за БС.
[01:04:57.620 --> 01:04:59.620]  Еще раз?
[01:05:01.620 --> 01:05:03.620]  Правильное замечание.
[01:05:03.620 --> 01:05:05.620]  Не может. Ну окей, да.
[01:05:05.620 --> 01:05:07.620]  Действительно.
[01:05:09.620 --> 01:05:11.620]  Да.
[01:05:11.620 --> 01:05:13.620]  Это верно, но здесь
[01:05:13.620 --> 01:05:15.620]  не важно.
[01:05:15.620 --> 01:05:17.620]  Так.
[01:05:17.620 --> 01:05:19.620]  Ну вот представьте, что мы это сделали.
[01:05:19.620 --> 01:05:21.620]  Это делается очень просто.
[01:05:21.620 --> 01:05:23.620]  По автомату.
[01:05:23.620 --> 01:05:25.620]  Просто если снизу вверх пройти,
[01:05:25.620 --> 01:05:27.620]  давайте для каждой вершины указывать,
[01:05:27.620 --> 01:05:29.620]  где, грубо говоря,
[01:05:29.620 --> 01:05:31.620]  сожмем длинный путь по
[01:05:31.620 --> 01:05:33.620]  таким проходным вершинам.
[01:05:33.620 --> 01:05:35.620]  Это будет ссылаться вот сюда,
[01:05:35.620 --> 01:05:37.620]  это будет ссылаться вот сюда,
[01:05:37.620 --> 01:05:39.620]  это будет ссылаться вот сюда.
[01:05:39.620 --> 01:05:41.620]  Ну то есть как я сказал,
[01:05:41.620 --> 01:05:43.620]  это будет ссылаться вот сюда,
[01:05:43.620 --> 01:05:45.620]  мы просто для каждой вершины
[01:05:45.620 --> 01:05:47.620]  снизу вверх подсчитываем,
[01:05:47.620 --> 01:05:49.620]  где мы окажемся,
[01:05:49.620 --> 01:05:51.620]  если мы сразу пройдем вот этот длинный путь
[01:05:51.620 --> 01:05:53.620]  по сжатым вершинам.
[01:06:01.620 --> 01:06:03.620]  Вот.
[01:06:03.620 --> 01:06:05.620]  А дальше сделаем следующее.
[01:06:05.620 --> 01:06:07.620]  Мы получили опять
[01:06:07.620 --> 01:06:09.620]  некоторый граф
[01:06:09.620 --> 01:06:11.620]  на ребрах которого уже написаны
[01:06:11.620 --> 01:06:13.620]  строчки,
[01:06:13.620 --> 01:06:15.620]  не буквы как раньше, а строчки.
[01:06:15.620 --> 01:06:17.620]  И давайте сделаем следующее.
[01:06:17.620 --> 01:06:19.620]  Давайте просто запустим
[01:06:19.620 --> 01:06:21.620]  ДФС
[01:06:21.620 --> 01:06:23.620]  без пометок юст.
[01:06:27.620 --> 01:06:29.620]  ДФС без запоминания.
[01:06:29.620 --> 01:06:31.620]  То есть вот мы встали в корень,
[01:06:31.620 --> 01:06:33.620]  у нас есть несколько
[01:06:33.620 --> 01:06:35.620]  стрелок из нее.
[01:06:35.620 --> 01:06:37.620]  Стрелки в этом плане, что они уже сжаты.
[01:06:37.620 --> 01:06:39.620]  Я выбираю из них
[01:06:39.620 --> 01:06:41.620]  ту, которая начинает
[01:06:41.620 --> 01:06:43.620]  на самую маленькую букву,
[01:06:43.620 --> 01:06:45.620]  ну на А скажем,
[01:06:45.620 --> 01:06:47.620]  и иду сюда.
[01:06:47.620 --> 01:06:49.620]  Дальше здесь опять я стою здесь,
[01:06:49.620 --> 01:06:51.620]  иду в самую маленькую букву и так далее.
[01:06:51.620 --> 01:06:53.620]  В момент, когда я дошел до
[01:06:53.620 --> 01:06:55.620]  некоторой терминальной вершины,
[01:06:55.620 --> 01:06:57.620]  я знаю суммарную длину этого пути,
[01:06:57.620 --> 01:06:59.620]  то есть я знаю сколько суммарно букв
[01:06:59.620 --> 01:07:01.620]  было написано на этих ребрах,
[01:07:01.620 --> 01:07:03.620]  значит я знаю, что это был за суффикс.
[01:07:03.620 --> 01:07:05.620]  В момент
[01:07:05.620 --> 01:07:07.620]  посещения
[01:07:09.620 --> 01:07:11.620]  терминальной вершины
[01:07:13.620 --> 01:07:15.620]  выводим ее
[01:07:15.620 --> 01:07:17.620]  как очередной суффикс.
[01:07:19.620 --> 01:07:21.620]  Ну не ее, да, но как бы
[01:07:21.620 --> 01:07:23.620]  соответствующую длину
[01:07:25.620 --> 01:07:27.620]  как очередной суффикс.
[01:07:35.620 --> 01:07:37.620]  И мы при этом
[01:07:37.620 --> 01:07:39.620]  не запоминаем юзды,
[01:07:39.620 --> 01:07:41.620]  то есть мы позволяем себе многократно посещать
[01:07:41.620 --> 01:07:43.620]  одну и ту же вершину.
[01:07:43.620 --> 01:07:45.620]  Вот если, например, у меня как-то вот так вот автомат выглядит,
[01:07:45.620 --> 01:07:47.620]  то я сначала вот так вот пройду,
[01:07:47.620 --> 01:07:49.620]  я сначала пройду вот так вот,
[01:07:49.620 --> 01:07:51.620]  потом вот так вот.
[01:07:51.620 --> 01:07:53.620]  То есть я разрешаю себе вершину заходить
[01:07:53.620 --> 01:07:55.620]  несколько раз, ребра походить несколько раз.
[01:07:55.620 --> 01:07:57.620]  Я просто забываю про юзды,
[01:07:57.620 --> 01:07:59.620]  вообще их не обновляю.
[01:07:59.620 --> 01:08:01.620]  Хочу пройти вершину по ребру, прохожу.
[01:08:03.620 --> 01:08:05.620]  Давай сначала поймем, что это корректно.
[01:08:05.620 --> 01:08:07.620]  Потому что мы
[01:08:07.620 --> 01:08:09.620]  как бы по бору действуем жадно на самом деле.
[01:08:09.620 --> 01:08:11.620]  У нас есть автомат, я хочу найти самый маленький
[01:08:11.620 --> 01:08:13.620]  суффикс, для этого мне нужно взять
[01:08:13.620 --> 01:08:15.620]  самую маленькую букву, идти пока не встречу терминальную вершину.
[01:08:15.620 --> 01:08:17.620]  Это будет лекс-суффикс.
[01:08:17.620 --> 01:08:19.620]  Второй
[01:08:19.620 --> 01:08:21.620]  суффикс, который я выведу,
[01:08:21.620 --> 01:08:23.620]  это второй по лексографической минимальности.
[01:08:23.620 --> 01:08:25.620]  Потому что я всегда действую жадно,
[01:08:25.620 --> 01:08:27.620]  соответственно суффикс выведу в правильном порядке.
[01:08:27.620 --> 01:08:29.620]  То есть, по крайней мере, корректность
[01:08:29.620 --> 01:08:31.620]  тривиальна.
[01:08:31.620 --> 01:08:33.620]  Что со временем работы вопрос?
[01:08:35.620 --> 01:08:37.620]  Потому что к Азазовому делан
[01:08:37.620 --> 01:08:39.620]  какой-то кринж.
[01:08:39.620 --> 01:08:41.620]  Мы многократно посещаем вершины,
[01:08:41.620 --> 01:08:43.620]  мы даже не знаем,
[01:08:43.620 --> 01:08:45.620]  ДФС работает за сколько.
[01:08:45.620 --> 01:08:47.620]  В худшем случае он может работать за экспоненту.
[01:08:47.620 --> 01:08:49.620]  Если граф специального вида,
[01:08:49.620 --> 01:08:51.620]  то ДФС без юздов может работать за экспоненту.
[01:08:51.620 --> 01:08:53.620]  А если каждую вершину многократно можно посещать,
[01:08:53.620 --> 01:08:55.620]  то он может весь граф экспоненциально долго обходить.
[01:08:55.620 --> 01:08:57.620]  Но на этом графе он работает
[01:08:57.620 --> 01:08:59.620]  за линию.
[01:08:59.620 --> 01:09:01.620]  Почему?
[01:09:13.620 --> 01:09:15.620]  Что?
[01:09:17.620 --> 01:09:19.620]  Я скажу следующее.
[01:09:19.620 --> 01:09:21.620]  Время работы очевидно
[01:09:21.620 --> 01:09:23.620]  пропорционально количеству
[01:09:23.620 --> 01:09:25.620]  посещенных вершин.
[01:09:29.620 --> 01:09:31.620]  Количество посещенных вершин
[01:09:31.620 --> 01:09:33.620]  с учетом кратности.
[01:09:33.620 --> 01:09:35.620]  Если я вершину два раза наступил, то я их считаю дважды.
[01:09:35.620 --> 01:09:37.620]  Количество посещенных
[01:09:37.620 --> 01:09:39.620]  вершин
[01:09:39.620 --> 01:09:41.620]  с учетом количества посещений.
[01:09:41.620 --> 01:09:43.620]  Не буду писать, да.
[01:09:43.620 --> 01:09:45.620]  С учетом кратности.
[01:09:47.620 --> 01:09:49.620]  Понятно.
[01:09:49.620 --> 01:09:51.620]  Просто каждое действие – это попасть в вершину.
[01:09:51.620 --> 01:09:53.620]  Давайте тогда поймем вообще,
[01:09:53.620 --> 01:09:55.620]  сколько раз я могу попасть
[01:09:55.620 --> 01:09:57.620]  в какую-то вершину.
[01:09:59.620 --> 01:10:01.620]  Ну, не будем торопиться.
[01:10:01.620 --> 01:10:03.620]  Во-первых, если вершина терминальная,
[01:10:03.620 --> 01:10:05.620]  то попасть я могу в нее ровно столько раз,
[01:10:05.620 --> 01:10:07.620]  каков ее размер класса эквивалентности.
[01:10:07.620 --> 01:10:09.620]  Потому что я терминальные вершины не сжимаю.
[01:10:09.620 --> 01:10:11.620]  И попасть я в нее могу всеми возможными способами,
[01:10:11.620 --> 01:10:13.620]  как я могу прошедшить этот суффикс.
[01:10:13.620 --> 01:10:15.620]  А если я попасть в вершину,
[01:10:15.620 --> 01:10:17.620]  то я могу попасть в вершину,
[01:10:17.620 --> 01:10:19.620]  как я могу попасть в вершину,
[01:10:19.620 --> 01:10:21.620]  всеми возможными способами,
[01:10:21.620 --> 01:10:23.620]  как я могу прошедшить этот суффикс.
[01:10:23.620 --> 01:10:25.620]  Поэтому число раз, что я попаду в терминальную вершину,
[01:10:25.620 --> 01:10:27.620]  в точности равно, сколько в ней суффиксов.
[01:10:27.620 --> 01:10:29.620]  Ну, как бы, сколько суффиксов ей соответствует.
[01:10:29.620 --> 01:10:33.620]  Сколько ей соответствует суффиксов.
[01:10:37.620 --> 01:10:39.620]  Потому что любой путь в нашем автомате
[01:10:39.620 --> 01:10:41.620]  до этой вершины соответствует суффиксу.
[01:10:41.620 --> 01:10:43.620]  Ну, хочешь и не хочешь,
[01:10:43.620 --> 01:10:45.620]  по-другому, как вот
[01:10:45.620 --> 01:10:47.620]  стольким количеством способов сюда я не попаду.
[01:10:49.620 --> 01:10:51.620]  Теперь давайте рассмотрим остальные
[01:10:51.620 --> 01:10:53.620]  не терминальные, но при этом
[01:10:53.620 --> 01:10:55.620]  не сжатые вершины.
[01:10:55.620 --> 01:10:57.620]  Не терминальная,
[01:10:57.620 --> 01:10:59.620]  не сжатая вершина.
[01:11:03.620 --> 01:11:05.620]  Что значит, что они сжатые?
[01:11:05.620 --> 01:11:07.620]  Значит, из них, по крайней мере,
[01:11:07.620 --> 01:11:09.620]  два разных ребра исходят.
[01:11:09.620 --> 01:11:11.620]  Потому что если было бы одно, я бы ее сжал.
[01:11:11.620 --> 01:11:13.620]  Значит, отсюда есть, по крайней мере,
[01:11:13.620 --> 01:11:15.620]  два разных ребра А и Б.
[01:11:19.620 --> 01:11:21.620]  Теперь давайте рассмотрим
[01:11:21.620 --> 01:11:23.620]  все возможные способы попасть сюда
[01:11:23.620 --> 01:11:25.620]  в нашем сжатом суффиксном автомате.
[01:11:25.620 --> 01:11:27.620]  Что такое способ сюда попасть?
[01:11:27.620 --> 01:11:29.620]  Ну, по факту, это просто способ расширить какую-то строчку сюда ведущую.
[01:11:31.620 --> 01:11:33.620]  Давайте оценим число таких строк.
[01:11:37.620 --> 01:11:39.620]  Что мы точно знаем?
[01:11:39.620 --> 01:11:41.620]  Мы знаем, что а и б
[01:11:41.620 --> 01:11:43.620]  это подстроки С.
[01:11:49.620 --> 01:11:51.620]  Не наталкивает ли это вас
[01:11:51.620 --> 01:11:53.620]  на какие-то мысли?
[01:11:57.620 --> 01:11:59.620]  Альфа это
[01:11:59.620 --> 01:12:01.620]  где?
[01:12:03.620 --> 01:12:05.620]  Да.
[01:12:05.620 --> 01:12:07.620]  Смотрите, у нас был критерий
[01:12:07.620 --> 01:12:09.620]  longest, что строка является longest, если она
[01:12:09.620 --> 01:12:11.620]  префикс, или у нее два продолжения влево
[01:12:11.620 --> 01:12:13.620]  разных, а здесь вправо.
[01:12:13.620 --> 01:12:15.620]  Ну, чинится очень просто. Давайте
[01:12:15.620 --> 01:12:17.620]  реверсим строчку и получим продолжение влево.
[01:12:17.620 --> 01:12:19.620]  Значит, это значит,
[01:12:19.620 --> 01:12:21.620]  что а-реверснутая
[01:12:21.620 --> 01:12:23.620]  это longest
[01:12:23.620 --> 01:12:25.620]  для СР.
[01:12:27.620 --> 01:12:29.620]  Ну, критерий longest просто.
[01:12:29.620 --> 01:12:31.620]  Если я разворачиваю строчку,
[01:12:31.620 --> 01:12:33.620]  продолжение вправо, это, наоборот,
[01:12:33.620 --> 01:12:35.620]  предварение слева. Согласны?
[01:12:37.620 --> 01:12:39.620]  Все. Значит, количество
[01:12:39.620 --> 01:12:41.620]  посещений этой вершины
[01:12:41.620 --> 01:12:43.620]  ограничено числом таких альф,
[01:12:43.620 --> 01:12:45.620]  что я сюда попадаю, а таких альф
[01:12:45.620 --> 01:12:47.620]  суммарно столько
[01:12:47.620 --> 01:12:49.620]  longest для СР, а их линия,
[01:12:49.620 --> 01:12:51.620]  потому что вершин в автомате линия.
[01:12:51.620 --> 01:12:53.620]  Все.
[01:12:53.620 --> 01:12:55.620]  Давайте запишем.
[01:12:55.620 --> 01:12:57.620]  Значит, число посещений
[01:12:57.620 --> 01:12:59.620]  В
[01:13:01.620 --> 01:13:03.620]  ограничено
[01:13:05.620 --> 01:13:07.620]  количеством
[01:13:09.620 --> 01:13:11.620]  строк альфа,
[01:13:11.620 --> 01:13:13.620]  по которым можно
[01:13:13.620 --> 01:13:15.620]  из корня попасть в В.
[01:13:25.620 --> 01:13:27.620]  Ну, наверное, в точности равно,
[01:13:27.620 --> 01:13:29.620]  но...
[01:13:29.620 --> 01:13:31.620]  Наверное, в точности равно, да.
[01:13:31.620 --> 01:13:33.620]  Ну, я не хочу задумываться, потому что я, возможно,
[01:13:33.620 --> 01:13:35.620]  я какие-то вершины сжал, я, возможно,
[01:13:35.620 --> 01:13:37.620]  какие-то... Нет, я ничего не потерял.
[01:13:37.620 --> 01:13:39.620]  Ну, равно. Окей, равно.
[01:13:39.620 --> 01:13:41.620]  Ну, не больше, да, потому что каждая строка альфа
[01:13:41.620 --> 01:13:43.620]  соответствует какому-то пути до В.
[01:13:43.620 --> 01:13:45.620]  И попасть в В можно было только прочитав
[01:13:45.620 --> 01:13:47.620]  некий путь из корня до В, то есть какую-то альфу.
[01:13:47.620 --> 01:13:49.620]  Значит...
[01:13:51.620 --> 01:13:53.620]  Но такая альфа,
[01:13:53.620 --> 01:13:55.620]  значит, такие альфы
[01:13:55.620 --> 01:13:57.620]  обязательно
[01:13:57.620 --> 01:13:59.620]  удовлетворяют этому свойству,
[01:13:59.620 --> 01:14:01.620]  что если их развернуть и прощать справа-налево,
[01:14:01.620 --> 01:14:03.620]  то мы получим longest для реверсной строки.
[01:14:03.620 --> 01:14:05.620]  Значит, суммарно,
[01:14:05.620 --> 01:14:07.620]  всех таких альф, по всем В,
[01:14:07.620 --> 01:14:09.620]  у от n, потому что longest для СР
[01:14:09.620 --> 01:14:11.620]  у от n. Мы доказывали
[01:14:11.620 --> 01:14:13.620]  только что, что вершин в суавтомате
[01:14:13.620 --> 01:14:15.620]  не больше чем 2n.
[01:14:17.620 --> 01:14:19.620]  Чего?
[01:14:23.620 --> 01:14:25.620]  А почему
[01:14:25.620 --> 01:14:27.620]  не может быть
[01:14:27.620 --> 01:14:29.620]  одинаковый СР для ратора?
[01:14:29.620 --> 01:14:31.620]  Ой, одинаковый альфа для ратора.
[01:14:31.620 --> 01:14:33.620]  Да пусть даже есть.
[01:14:33.620 --> 01:14:35.620]  Когда цинклон
[01:14:35.620 --> 01:14:37.620]  не ломается.
[01:14:39.620 --> 01:14:41.620]  А, сейчас, одинаковые альфы для разных В, да?
[01:14:41.620 --> 01:14:43.620]  Я неправильно, значит, понял просто.
[01:14:43.620 --> 01:14:45.620]  Одинаковые альфы.
[01:14:45.620 --> 01:14:47.620]  Да, да, справедливо. Ну, понятно, что такого
[01:14:47.620 --> 01:14:49.620]  не бывает, да? Ну, автомат 10-мин, нельзя
[01:14:49.620 --> 01:14:51.620]  прочитать одну и ту же альфу, попасть в В. Да, спасибо, это
[01:14:51.620 --> 01:14:53.620]  важно. Да, это я явно не проговорил.
[01:14:53.620 --> 01:14:55.620]  Вот.
[01:14:55.620 --> 01:14:57.620]  Значит, давайте допишем, да? Да, спасибо,
[01:14:57.620 --> 01:14:59.620]  давайте это запишем, что разным В
[01:14:59.620 --> 01:15:01.620]  соответствуют разные альфы.
[01:15:01.620 --> 01:15:03.620]  Потому что автомат
[01:15:03.620 --> 01:15:05.620]  диссерминированный, и нельзя, прочитав
[01:15:05.620 --> 01:15:07.620]  одну и ту же альфу, попасть в одну и ту же В.
[01:15:07.620 --> 01:15:09.620]  Значит, суммарно таких альф,
[01:15:09.620 --> 01:15:11.620]  значит,
[01:15:11.620 --> 01:15:13.620]  суммарно
[01:15:13.620 --> 01:15:15.620]  посещений
[01:15:15.620 --> 01:15:17.620]  таких В
[01:15:19.620 --> 01:15:21.620]  не больше,
[01:15:21.620 --> 01:15:23.620]  чем таких альф,
[01:15:27.620 --> 01:15:29.620]  а их вот он.
[01:15:31.620 --> 01:15:33.620]  Ну, все.
[01:15:33.620 --> 01:15:35.620]  Построили автомат
[01:15:35.620 --> 01:15:37.620]  за линейное время.
[01:15:39.620 --> 01:15:41.620]  Да, конечно.
[01:15:43.620 --> 01:15:45.620]  Вопросы?
[01:15:45.620 --> 01:15:47.620]  Все, тогда спасибо, давайте
[01:15:47.620 --> 01:15:49.620]  нас сегодня закончим.
