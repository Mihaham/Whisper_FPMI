[00:00.000 --> 00:13.700]  И задачи общие. Есть специальная задача для группы 328 и 18.
[00:13.700 --> 00:16.700]  О построении схемы функциональных элементов.
[00:16.700 --> 00:25.700]  И специальная задача для 20-й группы.
[00:25.700 --> 00:37.700]  Давайте мы их на семинаре разбирать не будем, но я дополнительно приложу файлы как бы я их решал.
[00:55.700 --> 01:17.700]  Ну еще раз, мы в прошлый раз начали говорить про буду функции, что это такое, давайте еще раз вспомним.
[01:17.700 --> 01:32.700]  У нас есть функции. Как они работают? У нас есть FK.
[01:32.700 --> 01:41.700]  Мы добавляли дополнительные условия, что на Энарность.
[01:41.700 --> 01:52.700]  Потому что в общем случае говорить про буду функции не совсем корректно.
[01:52.700 --> 02:02.700]  Так что определяем что такое Энарная буду функция. Это 0,1.
[02:02.700 --> 02:11.700]  Функция из 0,1 степени 0,1. Соответственно произвольная буду функция это какая-то Энарная буду функция.
[02:11.700 --> 02:18.700]  Давайте определим классы Энарных буду функций.
[02:18.700 --> 02:26.700]  И потом просто буду функция на связи с объединением всех классов по N.
[02:26.700 --> 02:34.700]  Так же в прошлый раз мы говорили что есть буду функции.
[02:34.700 --> 02:44.700]  И мы можем каждую буду функцию сопоставить Dnf, Knf.
[02:44.700 --> 03:01.700]  Причем тот алгоритм, который мы делаем по таблице истинности, он дает нам не просто Dnf, Knf, а Sdnf, Sknf.
[03:01.700 --> 03:09.700]  Оказывается, помимо Dnf, Knf, буду функцию можно представлять другими способами.
[03:09.700 --> 03:27.700]  Сегодня мы будем больше говорить про то, как нам представлять буду функции не однообразным, а при помощи каких-то выбранных базовых элементарных операций.
[03:27.700 --> 03:39.700]  Буду функции Dnf, Knf, они были про конъюнцию, дезюнцию, инверсию.
[03:39.700 --> 03:53.700]  Второй способ это пареном Жигалкина.
[03:53.700 --> 04:01.700]  Как выглядит пареном Жигалкина? Это 1, 40, конъюнция.
[04:01.700 --> 04:06.700]  То есть мы теперь представляем другими операциями.
[04:06.700 --> 04:10.700]  Давайте определим что в принципе такое пареном Жигалкина.
[04:10.700 --> 04:16.700]  Дальше я буду здесь писать пыжи пареном Жигалкина.
[04:16.700 --> 04:30.700]  Пареном Жигалкина, по определению, это есть ссор от i равно 1 по n каких-то пареномов Жигалкина.
[04:30.700 --> 04:36.700]  Это не n, это i.
[04:36.700 --> 04:52.700]  Где пареном Жигалкина.
[04:52.700 --> 05:08.700]  Это либо конъюнция нескольких переменных.
[05:22.700 --> 05:34.700]  Либо 1.
[05:34.700 --> 05:44.700]  Как мы можем смотреть теперь на единицу? На единицу мы можем смотреть как на конъюнцию нуля переменных.
[05:44.700 --> 05:58.700]  То есть у нас, например, когда было логибреическое, что у нас было в алгебре?
[05:58.700 --> 06:06.700]  У нас были многочлены вида a, plus ab, plus что-нибудь там.
[06:06.700 --> 06:14.700]  Плюс какие-нибудь цифры, которые 3, 5, 6, 8 и так далее.
[06:14.700 --> 06:19.700]  Вот мы определяли количество вхождений переменных.
[06:19.700 --> 06:25.700]  Это степень одночлены, ну или другим словом, монома.
[06:25.700 --> 06:34.700]  И говорили, что степень вхождения переменных в моном вида какое-то число это ноль.
[06:34.700 --> 06:36.700]  То есть ничего не вошло.
[06:36.700 --> 06:41.700]  Ровно так и здесь. У нас в единицу просто не вошла никакая переменная.
[06:41.700 --> 06:50.700]  Давайте поговорим, почему в алгебрических пареномах мы могли там писать еще что-то вида.
[06:51.700 --> 06:58.700]  3mn, а здесь мы говорим, что это просто конъюнция нескольких переменных.
[06:58.700 --> 07:05.700]  Потому что на самом деле в алгебре мы работали с исчастными коэффициентами.
[07:05.700 --> 07:11.700]  В полиномаше Галкина мы берем коэффициент из какого множества, давайте подумаем.
[07:35.700 --> 07:38.700]  Что-то я ничего не слышу.
[07:40.700 --> 07:42.700]  0.1
[07:42.700 --> 07:44.700]  О, супер, хорошо.
[07:44.700 --> 07:47.700]  Берем коэффициент из 0.1.
[07:47.700 --> 07:55.700]  Если я возьму коэффициент из нуля, то что такое, у меня будет ноль конъюнции на что-либо.
[07:55.700 --> 07:58.700]  Это будет ноль.
[07:58.700 --> 08:02.700]  Поэтому писать ноль коэффициент перед чем-то не имеет смысла.
[08:02.700 --> 08:06.700]  А значит единственный коэффициент, который мы можем писать единица.
[08:06.700 --> 08:09.700]  Но при этом, если мы сделаем единицы конъюнции что-то.
[08:09.700 --> 08:13.700]  У нас есть свойство, что один конъюнции что-то, это есть само это что-то.
[08:13.700 --> 08:18.700]  Давайте запишем свойство, что ноль конъюнции а, это а.
[08:18.700 --> 08:21.700]  Для любого а.
[08:21.700 --> 08:29.700]  И для любого а также упомяну, что один конъюнции а, прошу прощения, это само а.
[08:29.700 --> 08:34.700]  Поэтому в реальности мы можем единственный раз, когда написать явно эти коэффициенты.
[08:34.700 --> 08:39.700]  Это когда не вошла ни одна переменная в оно.
[08:39.700 --> 08:43.700]  Причем ноль мы не пишем, потому что.
[08:43.700 --> 08:45.700]  Что?
[08:45.700 --> 08:48.700]  Потому что есть свойство, что для любого а.
[08:48.700 --> 08:53.700]  Ноль к сор а, это а.
[08:53.700 --> 08:55.700]  Поэтому ноль мы тоже не записываем.
[08:55.700 --> 08:58.700]  Единственное, что действительно у нас может поменять значение.
[08:58.700 --> 09:01.700]  Это один к сор а.
[09:01.700 --> 09:06.700]  Вспомним, один к сор а, это...
[09:10.700 --> 09:13.700]  Один к сор а, это что такое?
[09:13.700 --> 09:15.700]  Не а.
[09:15.700 --> 09:16.700]  Да.
[09:16.700 --> 09:18.700]  Это отрицание а.
[09:18.700 --> 09:23.700]  То есть один, он действительно меняет наше значение.
[09:23.700 --> 09:25.700]  Хорошо.
[09:25.700 --> 09:30.700]  Так, так, так, так, так.
[09:30.700 --> 09:32.700]  Это что такое маном Жигалкина.
[09:32.700 --> 09:37.700]  Дальше еще запишем интересное свойство про а.
[09:37.700 --> 09:46.700]  Что для любого а, а конъюнции самим собой, это а.
[09:46.700 --> 09:53.700]  Тогда, на самом деле, если мы будем увеличивать степень хождения переменной в маном.
[09:53.700 --> 09:55.700]  Мы ничего не изменяем.
[09:55.700 --> 09:58.700]  Там, например, в алгебре а и а квадрат.
[09:58.700 --> 10:00.700]  Это абсолютно разные вещи.
[10:00.700 --> 10:05.700]  В болевой алгебре у нас а равняется а квадрат.
[10:05.700 --> 10:09.700]  В каком смысле, что это а на а?
[10:09.700 --> 10:12.700]  Причем а на а.
[10:12.700 --> 10:15.700]  Мы договорились писать средних полиномах Жигалкина,
[10:15.700 --> 10:22.700]  подразумевая, что тут стоит знак конъюнции.
[10:35.700 --> 10:37.700]  Хорошо.
[10:38.700 --> 10:44.700]  Так, это, это, это, это есть.
[10:44.700 --> 10:46.700]  Дальше.
[10:46.700 --> 10:53.700]  Ну, давайте просто несколько свойств, почему полином Жигалкина это хорошо, красиво, круто.
[10:53.700 --> 10:57.700]  Первое свойство.
[10:57.700 --> 11:02.700]  Ну, наверное, это то, что называется коммутативностью.
[11:07.700 --> 11:17.700]  У вас уже было, у вас уже были что-то типа группы кольца поля где-нибудь на алгебре?
[11:17.700 --> 11:18.700]  Нет.
[11:18.700 --> 11:19.700]  Нет?
[11:19.700 --> 11:20.700]  Нет, не было.
[11:20.700 --> 11:21.700]  Главное, грустно.
[11:21.700 --> 11:25.700]  Тогда чуть позже вы поймете, что, в общем, вот эта система.
[11:25.700 --> 11:31.700]  Сор и конъюнция и единица.
[11:31.700 --> 11:33.700]  И единица.
[11:33.700 --> 11:39.700]  Запись в помощи манома Жигалкина это очень крутая тема.
[11:39.700 --> 11:44.700]  Запомните ее до, когда?
[11:44.700 --> 11:48.700]  До того момента, когда у вас появятся там кольца поля.
[11:48.700 --> 11:51.700]  Также аналогом это все будет на теории множеств.
[11:51.700 --> 11:52.700]  Это что?
[11:52.700 --> 11:56.700]  Теоксора это симметрическая разность для конъюнции пересечения.
[11:56.700 --> 11:58.700]  И один это все множество.
[11:58.700 --> 11:59.700]  Вот.
[11:59.700 --> 12:02.700]  Эта система очень крутая.
[12:02.700 --> 12:06.700]  Будете с ней работать.
[12:06.700 --> 12:08.700]  Даже, по-моему, не только на алгебре.
[12:08.700 --> 12:12.700]  Прямо с теорией множества будете потом работать на теорию меры.
[12:12.700 --> 12:14.700]  Вот с этой системой.
[12:14.700 --> 12:15.700]  Хорошо.
[12:15.700 --> 12:17.700]  У меня есть коммутативность.
[12:17.700 --> 12:19.700]  Сора и конъюнции.
[12:19.700 --> 12:22.700]  Почему это важно и нужно?
[12:22.700 --> 12:28.700]  Потому что теперь я могу произвольным образом записывать у себя конъюнции.
[12:28.700 --> 12:32.700]  Могу произвольным образом записывать переменные внутри манома.
[12:32.700 --> 12:35.700]  Ровно так же могу сталкаемые менять местами.
[12:35.700 --> 12:37.700]  И ничего от этого не меняется.
[12:37.700 --> 12:41.700]  Например, когда становится боль, беда, что этого нет.
[12:41.700 --> 12:43.700]  Например, матрицы.
[12:43.700 --> 12:45.700]  Если это матрицы, что делаете?
[12:45.700 --> 12:47.700]  Матрицы перемножаете.
[12:47.700 --> 12:49.700]  Перемножить матрицы мы не можем.
[12:49.700 --> 12:52.700]  Мы не можем менять порядок перемножения матрицы.
[12:52.700 --> 12:56.700]  И с этим на самом деле очень большой боль.
[12:56.700 --> 12:59.700]  Второе, что у меня есть хорошее.
[12:59.700 --> 13:02.700]  Ассоциативность.
[13:04.700 --> 13:08.700]  Ассоциативность сора и конъюнции.
[13:08.700 --> 13:13.700]  То есть я могу произвольным образом ставить скобки.
[13:13.700 --> 13:17.700]  В частности, это позволяет мне просто скобки убрать.
[13:17.700 --> 13:20.700]  Когда я пишу А, Б, С, какая разница?
[13:20.700 --> 13:24.700]  Я сначала возьму конъюнцию от переменных А и Б.
[13:24.700 --> 13:27.700]  И потом С к ним добавлю.
[13:27.700 --> 13:30.700]  Или наоборот, начну с Б, С, потом добавлю А.
[13:30.700 --> 13:36.700]  Но на личный XOR я могу произвольным образом поменять сагаи между собой.
[13:36.700 --> 13:38.700]  И вычислить их другим образом.
[13:38.700 --> 13:40.700]  При этом ответ я не поменяю.
[13:42.700 --> 13:44.700]  Извините, а можно на примере?
[13:44.700 --> 13:45.700]  На примере?
[13:45.700 --> 13:47.700]  Давай, смотри.
[13:47.700 --> 13:52.700]  А, Б, XOR, С, Д.
[13:57.700 --> 13:59.700]  И давай еще что-то.
[13:59.700 --> 14:04.700]  XOR, В, К, Н.
[14:07.700 --> 14:12.700]  Понятно, что, во-первых, я могу поменять местами А и Б.
[14:12.700 --> 14:14.700]  Вот внутри этого все добра.
[14:14.700 --> 14:18.700]  И значение, когда я вычислю теперь, у меня не поменялось.
[14:18.700 --> 14:22.700]  Это то, что называется коммутативность конъюнции.
[14:22.700 --> 14:24.700]  Я поменял местами два аргумента.
[14:27.700 --> 14:31.700]  Да, я про ассоциативность хотел понять.
[14:31.700 --> 14:33.700]  Ассоциативность, смотри.
[14:33.700 --> 14:38.700]  Ассоциативность говорит о том, что если я вот так расставлю скобки, то есть...
[14:38.700 --> 14:42.700]  Сначала вычислю первую, первый XOR, потом второй XOR.
[14:42.700 --> 14:45.700]  Или, наоборот, я поставлю скобки таким образом.
[14:45.700 --> 14:52.700]  А, Б, С, Д, XOR, В, К, Н.
[14:55.700 --> 14:57.700]  Значения будут одинаковые.
[15:00.700 --> 15:02.700]  Например, как это называется?
[15:04.700 --> 15:07.700]  Я не помню, как в школе это называется русскими словами.
[15:07.700 --> 15:08.700]  Простите.
[15:09.700 --> 15:10.700]  Это точно должно было быть.
[15:12.700 --> 15:15.700]  Возможно, это распределительный закон или сочетательный.
[15:19.700 --> 15:22.700]  Ну, это полезно, когда...
[15:23.700 --> 15:26.700]  Нет, дистрибутивность, она есть, и это другое.
[15:26.700 --> 15:28.700]  Дистрибутивность, она про две операции.
[15:29.700 --> 15:31.700]  Вот мы сейчас после этого прямо расскажем.
[15:35.700 --> 15:37.700]  Вот я могу сделать что?
[15:37.700 --> 15:39.700]  Я могу...
[15:39.700 --> 15:42.700]  Ну, например, пока не знаю, насколько тут хороший.
[15:45.700 --> 15:46.700]  Давайте...
[15:51.700 --> 15:52.700]  Сейчас.
[15:52.700 --> 15:53.700]  Дистрибутивность...
[15:53.700 --> 15:55.700]  Как коммутативность поможет при дистрибутивности?
[15:55.700 --> 15:56.700]  Это точно.
[15:56.700 --> 15:57.700]  Я могу сейчас показать.
[16:03.700 --> 16:05.700]  А, ну, смотрите.
[16:05.700 --> 16:07.700]  Например, у меня будет выражение какое?
[16:07.700 --> 16:19.700]  А, Б, XORCD, XORCM.
[16:20.700 --> 16:23.700]  Вот мы помним, что есть у нас дистрибутивность еще.
[16:23.700 --> 16:24.700]  Давайте сразу запишу.
[16:25.700 --> 16:30.700]  Дистрибутивность.
[16:30.700 --> 16:31.700]  Что относительно чего?
[16:31.700 --> 16:35.700]  Это вот опять то, как любят, то так и называют.
[16:36.700 --> 16:42.700]  Какого-то единого соглашения о том, что значит дистрибутивность одной операции на другой, нет.
[16:42.700 --> 16:46.700]  Поэтому я скажу, что это дистрибутивность конъюнции.
[16:47.700 --> 16:48.700]  Ой.
[16:48.700 --> 16:51.700]  Да, конъюнции надо...
[16:51.700 --> 16:52.700]  XOR.
[16:52.700 --> 16:55.700]  Если кто-то подозревает это другим образом,
[16:55.700 --> 16:56.700]  ну, ничего страшного.
[16:56.700 --> 16:57.700]  Главное в том, что...
[16:57.700 --> 16:59.700]  Какой именно смысл вы под этим вкладываете?
[16:59.700 --> 17:02.700]  А тут, ну, дело вкуса.
[17:02.700 --> 17:05.700]  Что значит дистрибутивность конъюнции над XOR?
[17:05.700 --> 17:09.700]  Это значит, что если у меня были A, XOR...
[17:09.700 --> 17:11.700]  Что было у меня?
[17:11.700 --> 17:17.700]  A, B, XOR...
[17:17.700 --> 17:19.700]  А, C?
[17:19.700 --> 17:22.700]  То есть, если у меня были 2 конъюнции,
[17:22.700 --> 17:25.700]  A, B, XOR, A, C,
[17:25.700 --> 17:29.700]  то это то же самое, что A, B, XOR, C.
[17:30.700 --> 17:32.700]  Это называется левая дистрибутивность.
[17:32.700 --> 17:35.700]  То есть, я взял с лева, вынес буковки в лево.
[17:37.700 --> 17:42.700]  В общем случае у нас дистрибутивность...
[17:42.700 --> 17:44.700]  Она...
[17:44.700 --> 17:46.700]  Не всегда бывает просто дистрибутивность.
[17:46.700 --> 17:48.700]  Иногда бывает только левая дистрибутивность.
[17:48.700 --> 17:50.700]  То есть, если аналогично сделаю все справа,
[17:50.700 --> 17:52.700]  буквы A вынесу,
[17:52.700 --> 17:54.700]  то это правая дистрибутивность.
[17:54.700 --> 17:56.700]  Если есть и то, и то,
[17:56.700 --> 17:58.700]  мы просто говорим, что есть дистрибутивность.
[17:58.700 --> 18:00.700]  Как правило, когда мы говорим просто дистрибутивность,
[18:00.700 --> 18:02.700]  мы понимаем, что у нас есть коммутативность
[18:02.700 --> 18:04.700]  операции вножения.
[18:04.700 --> 18:11.700]  То есть, мы можем взять и поменять местами переменные.
[18:11.700 --> 18:13.700]  Вот здесь, например,
[18:13.700 --> 18:16.700]  в классическом расставлении скобок
[18:16.700 --> 18:18.700]  у нас скобка стоит слева.
[18:18.700 --> 18:21.700]  И вот применить дистрибутивность,
[18:21.700 --> 18:23.700]  если у меня не было ассоциативности,
[18:23.700 --> 18:25.700]  здесь я не могу, вот тут.
[18:25.700 --> 18:28.700]  А я хочу применить дистрибутивность,
[18:28.700 --> 18:31.700]  и для этого я пользуюсь ассоциативностью.
[18:31.700 --> 18:34.700]  То есть, я теперь могу поменять порядок скобок.
[18:34.700 --> 18:37.700]  Давайте теперь у меня скобки будут стоять не так,
[18:37.700 --> 18:40.700]  а вот так, вот так.
[18:40.700 --> 18:42.700]  Все.
[18:42.700 --> 18:44.700]  Теперь у меня во второй скобке внутри есть
[18:44.700 --> 18:47.700]  то, что я могу просить по дистрибутивности.
[18:47.700 --> 18:49.700]  Я смогу вынести С.
[18:49.700 --> 18:51.700]  Давайте, даже не так сделаю.
[18:51.700 --> 18:54.700]  Я сделаю вот здесь, чтобы было написано МС.
[18:54.700 --> 18:57.700]  Теперь мне надо будет воспользоваться коммутативностью,
[18:57.700 --> 19:01.700]  чтобы поменять местами переменные М и С.
[19:01.700 --> 19:04.700]  Я их сделаю, жух, СМ.
[19:04.700 --> 19:12.700]  И после этого я все это добро превращу в С умножить на D плюс М.
[19:12.700 --> 19:17.700]  И я на самом деле простил нашу запись.
[19:17.700 --> 19:19.700]  Почему я простил?
[19:19.700 --> 19:21.700]  Потому что, ну, просто посчитайте,
[19:21.700 --> 19:23.700]  сколько переменных в первом случае использовалось
[19:23.700 --> 19:25.700]  и сколько переменных здесь.
[19:27.700 --> 19:30.700]  Это то, зачем нам нужны
[19:30.700 --> 19:34.700]  свойства коммутативности, ассоциативности, дистрибутивности.
[19:36.700 --> 19:39.700]  Есть такое, есть такое, есть такое.
[19:39.700 --> 19:43.700]  Слушай, нам бы важно понять...
[19:47.700 --> 19:49.700]  Хорошо.
[19:49.700 --> 19:51.700]  Мы можем...
[19:53.700 --> 19:55.700]  Четвертое.
[19:55.700 --> 20:00.700]  Четвертое это хорошее очень свойство.
[20:00.700 --> 20:03.700]  По сути, знаете, что оно говорит?
[20:03.700 --> 20:09.700]  Что раньше мы под XOR мы пишем плюсик, обводим в кружочек.
[20:09.700 --> 20:12.700]  Вот, если убрать кружочек,
[20:12.700 --> 20:15.700]  то, ну, в целом плюс идет в точности как плюс
[20:15.700 --> 20:18.700]  и умножение стандартное в алгебре.
[20:18.700 --> 20:21.700]  Но мы обводим его в кружочек не случайно.
[20:21.700 --> 20:24.700]  Что? Давайте его назову так.
[20:25.700 --> 20:29.700]  Сортеры это и сложение,
[20:31.700 --> 20:33.700]  и вычитание.
[20:39.700 --> 20:42.700]  В чем кроется свойство...
[20:44.700 --> 20:47.700]  Сейчас. Где кроется как раз это свойство?
[20:47.700 --> 20:53.700]  Если мы нарисуем таблицу истинности 0011 01 01.
[20:53.700 --> 20:55.700]  Вот AB.
[20:55.700 --> 20:57.700]  А тут XOR.
[20:57.700 --> 20:59.700]  То...
[20:59.700 --> 21:01.700]  Заметьте, что происходит.
[21:01.700 --> 21:04.700]  На нулях мы...
[21:05.700 --> 21:10.700]  что сложим нули, что вычтем нули, мы получаем действительно 0.
[21:10.700 --> 21:12.700]  0 и 1.
[21:12.700 --> 21:17.700]  Если мы сложим 0 и 1, то это получится 1.
[21:17.700 --> 21:21.700]  Если мы вычтем из единицы 0, это 1.
[21:21.700 --> 21:25.700]  Если из нуля вычтем 1, мы получим минус 1.
[21:25.700 --> 21:28.700]  Но так как минусов у нас нет, то...
[21:28.700 --> 21:31.700]  На самом деле, что такое минус?
[21:31.700 --> 21:33.700]  Минус это...
[21:35.700 --> 21:37.700]  Я скажу.
[21:42.700 --> 21:44.700]  Под минусом мы понимаем...
[21:44.700 --> 21:47.700]  В общем случае, что такое минус A.
[21:47.700 --> 21:49.700]  Минус A это...
[21:49.700 --> 21:51.700]  такой элемент...
[21:53.700 --> 21:59.700]  что A плюс минус A равняется 0.
[21:59.700 --> 22:01.700]  Вот что такое минус A.
[22:01.700 --> 22:05.700]  Это некое такое число, что мы добавим к A и получим 0.
[22:05.700 --> 22:06.700]  Вот.
[22:06.700 --> 22:10.700]  Что такое минус 1 в рамках булевой алтуры?
[22:11.700 --> 22:13.700]  Это 1.
[22:13.700 --> 22:15.700]  У нас в качестве сожжения теперь XOR.
[22:15.700 --> 22:17.700]  1 XOR.
[22:17.700 --> 22:19.700]  Что-то такое, что...
[22:19.700 --> 22:22.700]  минус 1, что будет равняться 0.
[22:22.700 --> 22:25.700]  А мы знаем, что 1 XOR 1 это есть 0.
[22:25.700 --> 22:27.700]  Просто из таблицей истинности.
[22:27.700 --> 22:29.700]  Значит, минус 1 вот это вот.
[22:29.700 --> 22:32.700]  Это есть не что иное, как само по себе 1.
[22:32.700 --> 22:37.700]  Поэтому 0 минус 1 это минус 1, который является 1.
[22:37.700 --> 22:41.700]  Ну, аналогично для второго случая просто поменяли местами.
[22:41.700 --> 22:42.700]  А...
[22:42.700 --> 22:44.700]  1 плюс 1 это 2.
[22:44.700 --> 22:45.700]  2 это перебрали.
[22:45.700 --> 22:47.700]  Ну...
[22:47.700 --> 22:51.700]  По-хорошему, еще один способ смотреть на это все как.
[22:51.700 --> 22:54.700]  Вот вам рассказывали уже про...
[22:54.700 --> 22:56.700]  модульную арифметику?
[22:58.700 --> 23:00.700]  Нет.
[23:00.700 --> 23:03.700]  Ну, мне кажется, что нет. Возможно, я ошибаюсь.
[23:03.700 --> 23:05.700]  Почти уверен, что нет.
[23:05.700 --> 23:08.700]  Ну, арифметика остатков по модулю.
[23:08.700 --> 23:09.700]  Вот.
[23:09.700 --> 23:15.700]  Ну, вы наверняка уже с этим как-то в школе должны быть сталкиваться, что...
[23:15.700 --> 23:19.700]  мы можем вычислять значение по модулю какого-то числа.
[23:19.700 --> 23:23.700]  Например, что значит вычислить по модулю 3?
[23:23.700 --> 23:24.700]  Вот.
[23:24.700 --> 23:29.700]  У меня есть. Я огрублю. У меня есть только цифры 0, 1 и 2.
[23:29.700 --> 23:33.700]  Если я сложу два числа...
[23:33.700 --> 23:35.700]  То есть, а...
[23:35.700 --> 23:40.700]  Сделаю остаток по модулю м плюс b.
[23:40.700 --> 23:42.700]  По модулю м.
[23:42.700 --> 23:45.700]  Это будет...
[23:45.700 --> 23:48.700]  На самом деле, я все возьму еще раз по модуле.
[23:48.700 --> 23:50.700]  Потому что внезапно я могу вынести.
[23:50.700 --> 23:52.700]  Выть из-за границы модуля.
[23:52.700 --> 23:55.700]  Это все то же самое, что возьму а плюс b.
[23:55.700 --> 23:57.700]  По модулю м.
[23:57.700 --> 23:59.700]  Ну, свойства остатков давайте.
[23:59.700 --> 24:01.700]  Просто сложили два числа.
[24:01.700 --> 24:05.700]  Мы взяли остаток деления на m.
[24:05.700 --> 24:09.700]  Дальше взяли остатки деления этих чисел, сложили.
[24:09.700 --> 24:11.700]  Потом еще раз взяли от этого всего остаток.
[24:11.700 --> 24:13.700]  Но это тоже самое будет.
[24:13.700 --> 24:15.700]  Просто арифметика проверить.
[24:15.700 --> 24:16.700]  Вот.
[24:16.700 --> 24:19.700]  На самом деле, 0, 1 это...
[24:19.700 --> 24:21.700]  Остатки какого числа могут быть?
[24:21.700 --> 24:23.700]  Это только остатки 2.
[24:23.700 --> 24:26.700]  Потому что у тройки уже может появиться остаток 2.
[24:26.700 --> 24:29.700]  То есть, мы живем в остатках по модулю 2.
[24:30.700 --> 24:35.700]  А тогда что такое 2 в рамках остатков по модулю 2?
[24:35.700 --> 24:38.700]  Ну, давайте просто 2 поделим с остатком на 2.
[24:41.700 --> 24:43.700]  Это в точности 0.
[24:43.700 --> 24:45.700]  Поэтому 1...
[24:45.700 --> 24:49.700]  Поэтому 2 в рамках пулевой алгебры это 0.
[24:49.700 --> 24:53.700]  То есть, что сложили, что вычли то же самое.
[24:53.700 --> 24:55.700]  Это важное свойство.
[24:55.700 --> 24:57.700]  Что XOR это изображение вычитания.
[24:57.700 --> 25:00.700]  Чтобы смотреть на полидом Жигалкина.
[25:00.700 --> 25:03.700]  И как-то понимать, как с ним работать.
[25:03.700 --> 25:07.700]  В плане, просто методом пристального взгляда.
[25:07.700 --> 25:12.700]  Да, мы говорили, что XOR это, по сути, в сравнении по модулю 2.
[25:12.700 --> 25:14.700]  А, супер топ.
[25:17.700 --> 25:19.700]  Хорошо.
[25:21.700 --> 25:23.700]  Так, теперь вот.
[25:23.700 --> 25:26.700]  Полидом Жигалкина, супер дупер.
[25:28.700 --> 25:30.700]  Да.
[25:32.700 --> 25:35.700]  Мы его даже в ядно КТЧ там были рассказывали.
[25:35.700 --> 25:37.700]  Теперь давайте смотреть.
[25:37.700 --> 25:40.700]  Методы нахождения полидома Жигалкина.
[25:40.700 --> 25:44.700]  В прошлый раз я рассказал про треугольник Паскаля.
[25:44.700 --> 25:45.700]  Было.
[25:45.700 --> 25:46.700]  Сейчас повторим.
[25:46.700 --> 25:48.700]  Но на самом деле его недостаточно.
[25:50.700 --> 25:55.700]  Они нам понадобятся не совсем для того, чтобы просто строить эти полидомы Жигалкина.
[25:55.700 --> 26:00.700]  Насколько, чтобы понимать, какие у них есть хорошие свойства.
[26:03.700 --> 26:09.700]  Построение полидома Жигалкина.
[26:09.700 --> 26:12.700]  Первый способ это...
[26:12.700 --> 26:14.700]  Как он там?
[26:14.700 --> 26:17.700]  Треугольник Паскаля.
[26:25.700 --> 26:27.700]  Хорошо.
[26:29.700 --> 26:32.700]  Как работает треугольник Паскаля?
[26:32.700 --> 26:35.700]  Давайте я расскажу на примере.
[26:35.700 --> 26:38.700]  Функции из трех.
[26:38.700 --> 26:39.700]  Агументов.
[26:39.700 --> 26:42.700]  Нужно строить будет на нее.
[26:42.700 --> 26:46.700]  Еще это ПЭКУЕР.
[26:46.700 --> 26:48.700]  Дальше строим таблицу истинности.
[26:48.700 --> 26:50.700]  Дальше строим таблицу истинности.
[26:50.700 --> 26:55.700]  4 0 4 единицы 2 0 2 единицы...
[26:55.700 --> 26:58.700]  2 единицы 0 1 0 1 0 1 0 1
[26:58.700 --> 27:03.700]  И сама наша функция.
[27:03.700 --> 27:05.700]  Давайте насыпием рандомных аргументов.
[27:05.700 --> 27:09.700]  0 1 2 3 4...
[27:09.700 --> 27:10.700]  Ой-ой-ой.
[27:10.700 --> 27:12.700]  Какая красивая полетела.
[27:12.700 --> 27:15.700]  0 0 1 1 1 0
[27:15.700 --> 27:25.840]  1 1 1 0 красиво красиво что мы делаем у нас появилась появился вектор значений
[27:25.840 --> 27:31.380]  функции прям видим вектор вот у нас 8 координат что мы делаем мы вектор
[27:31.380 --> 27:36.580]  превращаем строку для этого применяем операцию транспонирование взяли прям
[27:36.580 --> 27:44.940]  транспонируем 0 1 0 0 1 1 1 0 супер теперь начинаем строить
[27:44.940 --> 27:55.500]  треугольник для этого по серединке между цирчистами ниже записываем 40 0 41 это 1
[27:55.500 --> 28:13.420]  1 40 1 0 0 0 40 это 0 0 41 1 1 41 0 1 41 0 1 40 1 ну поехали дальше 1 1 0 1 0 1 0 1 1 1 1 0 1
[28:13.420 --> 28:32.180]  0 0 0 0 1 1 1 0 0 1 1 1 0 1 0 1 1 1 0 0 но опа получили прям треугольничек на самом
[28:32.180 --> 28:41.900]  деле этот треугольничек не не прям не поймет куда берется а здесь есть
[28:41.900 --> 28:48.460]  биерция между ним и треугольником паскаля который был для биноминальных
[28:48.460 --> 28:56.180]  коэффициентов и интуитивно откуда вообще взялись биноминальные коэффициенты но
[28:56.180 --> 29:06.740]  помните мы начинаем сумма сумма сумма сумма это свойство это то что называется
[29:06.860 --> 29:16.300]  паскаля для биноминальных коэффициентов когда значение вот этой штучки есть сумма
[29:16.300 --> 29:24.260]  значений сверху слева справа только теперь сумма это если в какой-то бумажке
[29:24.860 --> 29:36.540]  ваша задача просто я показать объект хорошо теперь на левый ряд
[29:42.700 --> 29:49.580]  и видим какие-то коэффициенты а это есть коэффициенты при соответствующих
[29:49.580 --> 29:55.780]  маномах в таблице истинности для этого нам надо каждому набору переменных сопоставить
[29:55.780 --> 30:01.220]  какой-то маном какой маном сопоставим мы сопоставим маном который состоит из всех
[30:01.220 --> 30:09.460]  переменных которых данном наборе перенесла значение 1 поехали для пейку для трех нулей у
[30:09.460 --> 30:16.260]  нас какая-то переменная в него войдет но нет все нули значит никакая переменная вошла это
[30:16.260 --> 30:24.420]  маном единица дальше вошла только переменная это маноме аналогично вон он ку здесь рожки
[30:24.420 --> 30:37.220]  куэр это маном куэр п пр п ку п куэр ну так как мы помним что коэффициент 0 этому просто не
[30:37.220 --> 30:46.420]  используем маном значит просто выбираем маном у которых которым соответствует единицы это будет
[30:46.420 --> 31:04.020]  ссор через один куэр ссор п ссор пр вот построили полином же галтыны для данной функции
[31:04.020 --> 31:21.300]  дальше у нас есть метод суммирования угольник паскаля он же не гарантирую что она самая короткая
[31:21.300 --> 31:41.180]  что значит самая короткая нет лишних маномов или это ну у нас вот первых у нас нету прям
[31:41.180 --> 31:49.380]  такого понятия как самая короткая ну по крайней мере мы мы этим не запаривались никогда но вроде
[31:49.380 --> 31:56.580]  если мы посмотреть первым такой канонический вид полинома жигалки нигде я сокращу например
[31:56.580 --> 32:04.260]  вот здесь вот я не сокращу там до r что как я могу сократить я могу сократить и р айдинг сор ку
[32:04.260 --> 32:16.780]  ссор п айдинг сор р вот если мы не будем пытаться сократить таким образом не запретим запретим
[32:16.780 --> 32:20.220]  скажем что это не полином же галкина на самом деле это не есть полином же галкин
[32:20.220 --> 32:29.980]  как этого модификации то мы получаем минимальную просто сам по себе полином же галкина мы можем
[32:29.980 --> 32:36.820]  явно расписать его вот не просто не такой формулой что это там уравняется а можем сказать что это
[32:36.820 --> 32:47.060]  ссор я скажу по всем подможествам
[32:47.060 --> 32:59.980]  ну дайте x1 тогда xn дальше соответственно теперь у нас какой-то подможество значит я беру
[32:59.980 --> 33:20.160]  коэффициент альфа амега на конъюнцию по 7 x1 x на конъюнцию по 7 x и там лежащим в
[33:20.160 --> 33:33.720]  амеге x итых и говорим что альфа амеговая лежит в 0 1 вот мы заняли более чуть конструктивную формулу
[33:33.720 --> 33:39.120]  что такое полином же галкин ну и как видишь здесь мы просто либо используем аном либо
[33:39.120 --> 33:45.240]  не используем оно поэтому самое короткое это когда мы убрали все неиспользуемые мономы здесь
[33:45.360 --> 33:58.880]  так что задачи минимизации кнф днф здесь нету если уже все очень хорошо то есть много
[33:58.880 --> 34:05.120]  член жигалкин когда мы записали это уже самое короткое это самый короткий полином жигалкин а
[34:05.320 --> 34:21.800]  ну за исключением тех моментов когда мы можем например вот здесь я сделаю здесь ку здесь
[34:21.800 --> 34:29.920]  делаю оставлю куяр то что я смогу сделать я смогу ку вынести один к соре а дальше меня это это я
[34:29.920 --> 34:41.160]  могу снова это упростить превратить в п к сорку вот один соря заметим что новая запись в
[34:41.160 --> 34:46.320]  разы компактнее но в том определении который мы дали это не является классическим полином
[34:46.320 --> 34:53.120]  жигалкина то есть мы действительно можем упрощать но уже это будет не полином жигалкина просто по
[34:53.120 --> 35:06.360]  определению метод суммирование скажите пожалуйста запись будет у нас записи грется будет
[35:06.360 --> 35:16.120]  я не понял как там получилось то что мы эти две скопки перемножили ща по эксорку это типа
[35:16.120 --> 35:29.040]  мэр вынесли да вот это вынес дальше вынес кушку а дальше вынесу уже нет и унес вот это вот это
[35:29.040 --> 35:35.160]  обязательно вообще выносить или можно и так оставить эксорку и и так далее то что я сейчас
[35:35.160 --> 35:40.880]  вынес это я просто показал что можно на самом деле запись упрощать но то что я упростил я
[35:40.880 --> 35:49.440]  получил не полином жигалкина будем внимательны вот ответом будет ровно вот такая вот запись
[35:49.440 --> 35:57.360]  ничего прощать не надо прям просто взяли получили какие маномы их записали через
[35:57.360 --> 36:07.280]  сорк всю задачу решили даже не пытаться ничего упрощать оптимизировать этого не надо всех
[36:07.280 --> 36:07.840]  устраивать
[36:25.840 --> 36:36.800]  жух и поехали значение функции пусть будут у меня 1 1 1 0 0 1 1 не хочу хочу
[36:36.800 --> 36:42.600]  красивый вот такой хорошо метод суммирования в чем заключается метод суммирования у нас
[36:42.600 --> 36:50.320]  опять опять же те же самые маномы соответствует каждой строке таблице есть нести один
[36:51.320 --> 37:08.000]  но вычисляем их уже несколько другим способом поехали как мы вычисляем на каждой строке мы
[37:08.000 --> 37:21.280]  вычисляем дефицент последующий последующие формуле давайте скажу что альфа на наборе
[37:21.280 --> 37:31.520]  икса 1 т.д. икса переменных причем уже здесь нули единицы это есть естественно сумма по модуле 2
[37:31.520 --> 37:48.200]  по всем наборам и и у 1 т.д. и век н что будут меньше икс айдин т.д. икс н в смысле
[37:48.200 --> 38:00.360]  декарта произведение f от y 1 т.д. икс н декарта произведение
[38:00.360 --> 38:11.240]  уже проходили произведение частичных порядочных морс подида что были
[38:11.240 --> 38:29.320]  да тогда порядок на 0 1 мы знаем на 0 1 у нас на 0 1 у нас порядок
[38:29.320 --> 38:36.960]  вот у меня частично порядочные множество какое что 0 не больше чем 1
[38:36.960 --> 38:50.080]  тогда декарта произведение декарта произведение у нас что было что мы берем декарта произвести
[38:50.080 --> 39:04.120]  перемножаем вот эти все 0 1 и так далее n раз и получаем какой порядок что каждое
[39:04.120 --> 39:15.800]  координата должна быть меньше вот такой у нас порядок давайте смотреть для строки из нулей это
[39:15.800 --> 39:28.880]  только она сама значит это значение функции просто на этом наборе вот даже давайте просто
[39:28.880 --> 39:44.160]  храню прошлую функцию показать что она одинаковая сейчас покажем что мы получили тот же все это
[39:44.160 --> 39:53.080]  значение как можно удобно писать что давайте просто дальше записывать это значение везде вниз где
[39:53.080 --> 39:58.280]  этот набор меньше ну где меньше набора всех нулей он всех наборов меньше поэтому
[39:58.280 --> 40:11.800]  можно взять везде единички 0 эти прописать 0 взялся это значение функции теперь значение функции на
[40:11.800 --> 40:29.320]  наборе 0 0 1 вот сюда записываем через ксори единичку где этот набор меньше там на самом
[40:29.320 --> 40:36.160]  деле он будет меньше там где присутствует переменная r у маномах ну значит он пройдет
[40:36.800 --> 40:47.360]  пройдет пройдет уже можно заметить интересную закономерность что каждый раз когда мы
[40:47.360 --> 40:53.240]  увеличиваем количество переменных соответствующим маноме то есть количество единиц наборе мы
[40:53.240 --> 41:01.280]  прыгаем на 2 в степени это количество единиц и через этот прыжок записываем везде значение
[41:01.280 --> 41:08.440]  функции там у нас было 0 мы поэтому прыгали на сколько 2 степень 0 1 шаг здесь у нас одна
[41:08.440 --> 41:17.080]  переменная это два степени 1 2 через два прыгаем наборы записывать значение и так далее это равняется
[41:17.080 --> 41:31.080]  единице дак у нас 0 прыгаем через 2 пум-пум-пум-пум-пум ладно я наврал не через два прыгаем
[41:31.080 --> 41:47.000]  все да я наврал такое бывает простите через два прыгать вот это все забили или сказал
[41:47.000 --> 42:05.440]  здесь у меня ку вот ку куяр где у меня у меня здесь куяр еще здесь куяр здесь не только п здесь не
[42:05.440 --> 42:18.000]  столько п здесь мне тоже п здесь у меня тоже п теперь пр у меня здесь единичка еще сюда единичку
[42:18.000 --> 42:32.920]  дальше пыку ничка спор ничка все отчетное число единичек это 0 поэтому получили какой маном поехали
[42:32.920 --> 42:45.520]  вот здесь единичка здесь здесь здесь и здесь р сор куэр сор да то есть получается и там смотрим
[42:45.520 --> 42:49.840]  на пакуэр видим просто там ноль везде ставим нули потом смотрим на пакуэр видим что там
[42:49.840 --> 42:59.440]  р равно единицы везде где р равна 1 и ставим типа сор значение в этой точке далее смотрим
[42:59.440 --> 43:05.720]  пакуэр где ку равна единицы смотрим все где ку тоже равна единицы то есть получается
[43:05.720 --> 43:17.040]  до куда мы дойдем таким образом да ну смотри мы так запол... сейчас вот мы максимальный набор
[43:17.040 --> 43:25.840]  у нас 1 1 1 вот до сюда мы доходим все ну тогда вот мы просто берем шагаем вверх пока не
[43:25.840 --> 43:33.920]  достигнем того то есть мы для каждого набора в общем мы берем все те которые больше равны чем
[43:33.920 --> 43:44.400]  он да и в них дописываем вот сорем это значение вот это ровно то что раз написано справа все мета
[43:44.400 --> 43:52.680]  суммирования очень хорош тем что мы поняли что первое что значение что коэффициент
[43:52.680 --> 44:03.720]  свободный член пареного Жигалкина я сделаю вот таким каким-нибудь нужно выделить прям свойство
[44:03.720 --> 44:28.320]  сразу первое свободный член свободный член свободный член пареного Жигалкина будет
[44:28.320 --> 44:33.600]  равняться чему дайте посмотрите метод суммирования что он сказал
[44:33.600 --> 44:51.480]  это в точности равняется f от всех нулей дальше второе
[44:51.480 --> 45:14.600]  маном коэффициент при маном x1 тогда xn он будет чему равняться
[45:21.480 --> 45:33.840]  ну смотрите он соответствует набору всех единиц какие наборы меньше набора всех единиц да все
[45:33.840 --> 45:41.960]  какие угодно значит значи значи коэффициент маном x1 тогда xn будет равняться просто к сору
[45:41.960 --> 45:51.680]  всех значений на всех наборах и считай и считай сам этот набор да и конечно да каждый каждый
[45:51.680 --> 45:59.720]  короче у нас порядок порядок рефлексивный поэтому каждый набор не больше самого себя то есть мы
[45:59.720 --> 46:06.440]  каждый набор к сориум со значениями которые в этом наборе ну да вот смотри я записываю
[46:07.040 --> 46:15.240]  вот они они всегда присутствует нас перцент приманоме и ксинта вернется и
[46:15.240 --> 46:26.760]  но доль ссор так далее ссор f от один тогда вяде все просто проксорили про всех важно отсюда
[46:26.760 --> 46:41.920]  сделаем какой выбор к ссор у нас было что сложение по модуль 2 что если f принимает единицу
[46:41.920 --> 47:07.960]  нечетное число раз то он есть то есть ходит в поляном жигалкина четная не входит зачем
[47:07.960 --> 47:21.160]  это нужно это нам дает хорошие хорошие достаточные условия того что поляном жигалкина функции
[47:21.160 --> 47:28.240]  будь нелинейным напомним что такое линейность линейность в обычной алгебре была когда у нас
[47:28.240 --> 47:33.720]  степень хождение каждой переменной равнялась единицам тогда у нас линейная на член
[47:33.720 --> 47:40.040]  я тебе скажу
[47:40.040 --> 47:53.120]  пареном же галкина линейн тире
[47:53.120 --> 48:13.480]  степень хождение сейчас дайте скажу его степень не превосходит единицей причем как мы
[48:13.480 --> 48:25.360]  определяем степень паренома дек паренома жигалкина равняется максимально 8 и и степеней
[48:25.360 --> 48:45.240]  манома жигалкина где маном жигалкина степень количество переменных ну на самом деле да мы
[48:45.240 --> 48:51.360]  вот там переменные как мы говорили в какой-то степени мы такие случаи сразу отбросили потому
[48:51.360 --> 49:00.720]  что бред какой-то и не имеется тогда поляном жигалкина линейн есть его степень меньше
[49:00.720 --> 49:13.760]  единиц и сразу записываем до достаточно условия линейности паренома жигалкина
[49:13.760 --> 49:21.440]  ду это достаточно условия уже наверное достаточно условия необходимые условия
[49:21.440 --> 49:30.280]  из мотонализа должны были как-то запомнить до линейности паренома жигалкина ф принимает
[49:30.280 --> 49:43.560]  единицу сколько раз он должен не войти пареном из xн так далее x1 так далее xn принимает
[49:43.560 --> 50:13.080]  единицу четное число раз причем f тире не менее чем бинарная функция то есть для
[50:13.080 --> 50:24.120]  унарные функции которые имеют аргумент только один ну от того что войдет маном x1 она линейность
[50:24.120 --> 50:30.440]  не потеряет мы в целом да для унарных функций говорить о нелинейности вообще как-то странно
[50:30.440 --> 50:47.520]  не все линиями хорошо это важно помните мы это будем использовать дальше так в целом на это
[50:47.520 --> 50:54.680]  блок пар полянома жигалкина все по нему есть вопросы если прос про достаточно условия я не
[50:54.680 --> 51:03.280]  понимаю почему я понимаю почему типа при четном числе единиц у нас последний не войдет
[51:03.280 --> 51:15.240]  недостаточные условия это необходимые условия да необходимо спасибо да потому что достаточно
[51:15.240 --> 51:21.200]  у нас говорит что достаточно говорить что если она выполнена то это точно так а необходимое
[51:21.200 --> 51:25.840]  слове говорит что если это не выполнено то это точно не так так что это у нас необходимо
[51:25.840 --> 51:35.680]  слово то есть если она принять нечетный раз то она точно не линейна все так что да мы определяем
[51:35.680 --> 51:43.160]  не линейность мы определяем не линейность в общем еще по полянома жигалкина есть какие-то
[51:43.160 --> 51:52.440]  вопросы может там замечание еще где-то наложил но видимо нету теперь мы переходим к
[51:52.440 --> 52:03.160]  а можете пожалуйста все-таки еще раз показать на примере вот тот том который мы посчитали вот
[52:03.160 --> 52:13.800]  как мы по условиям понимаем что он не линейный смотри метод суммирования заключается в чем что
[52:13.800 --> 52:20.800]  у нас есть формула коэффициента при соответствующем наборе из переменных и она говорит о том что это
[52:20.800 --> 52:29.760]  ссор значений функции на всех наборов которые меньше заданного причем меньше в смысле порядка
[52:29.760 --> 52:37.120]  заданного декартом произведением то есть каждая координата должна быть меньше тогда
[52:37.120 --> 52:51.560]  мы смотрим на набор на набор который соответствует моному x1 тогда xn это набор из всех единиц тогда
[52:51.560 --> 52:58.160]  если этот набор состоит из всех единиц какие наборы меньше его его все наборы меньше его
[52:58.160 --> 53:07.280]  потому что один это максимальное значение а значит коэффициент при нем это есть точности
[53:07.280 --> 53:14.120]  ссор всех значений функций а смысл коэффициентов заключается в чем что мы берем этот набор или
[53:14.120 --> 53:20.200]  не берем мы берем этот моном или не берем если единица то берем 0 не берем значит когда мы
[53:20.200 --> 53:29.000]  возьмем когда ссор всех значений функции равняется единице а ссор сам по себе это было
[53:29.000 --> 53:36.320]  свойство что ссор это сложение по модулю 2 когда сложение по модулю 2 из нулей единиц
[53:36.320 --> 53:47.080]  равняется единице когда количество единиц нечетно вот отсюда это взялось да а почему
[53:47.080 --> 54:00.480]  линейно получается если у нас кер не входит а смотри мы мы не говорим что она будет линейно
[54:00.480 --> 54:06.480]  необходимые условия как работает она говорит что если то условие не выполнено то функции точно
[54:06.480 --> 54:17.320]  не обладает этим свойством все да я поняла спасибо это недостаточные условия достаточно это
[54:17.320 --> 54:26.240]  тоже периодически полт необходимой достаточной ссоре это необходимо здесь начинаем говорить про
[54:26.240 --> 54:46.320]  про классы функций поехали начинаем с того что такое композиция функций
[54:46.320 --> 54:55.920]  f и g
[54:55.920 --> 55:10.840]  как мы обозначаем композицию это f кружочек или f композиция g от x1 тогда
[55:11.560 --> 55:25.720]  это есть скажем так давайте я вектор уже никого не пугают
[55:25.720 --> 55:47.080]  если пугать значит будем бороться со страхом же у нас будет функция из 0 1 0 1 м то есть что
[55:47.080 --> 55:54.360]  такое функция же она берет n аргументов и выплевывает м аргументов по-хорошему это
[55:54.360 --> 56:08.000]  записывается как тогда же это есть вот такой вот вектор g 1 так далее g m
[56:08.000 --> 56:18.920]  где все же и ты живу прошу не сейчас но основной зарядку
[56:38.000 --> 56:52.600]  же это живет у нас она принимает 0 1 и возвращает 0 1 то есть же само по себе это просто обычная
[56:52.600 --> 57:02.120]  и нарная же это обычная же и нарная более функции можно просто да тут написано из
[57:02.120 --> 57:11.000]  0 1 степени в 0 1 с какой степени я а откуда буква им взялась но это я вот определяю так
[57:11.000 --> 57:18.680]  сейчас функцию не говорю что вот пожалуйста рассмотрим что такое же же это функция которая
[57:18.680 --> 57:28.360]  из степени n степень им действует то есть она каждому набору
[57:28.360 --> 57:36.360]  короче каждой последовательности 0 единиц длины n сопоставляет какую-то последовательность 0 единиц
[57:36.360 --> 57:45.600]  длины n м да вот это то же самое что же это вот есть такой вектор с функцией g 1 так далее
[57:46.320 --> 57:58.840]  же на самом деле даже не так не оно так так как такие называются функции
[57:58.840 --> 58:12.000]  они называются сейчас по-хорошему такие функции называются матрицами
[58:12.000 --> 58:26.440]  извините там а там вот же это там не вместо нет смотри она примет что каждая функция себя примет
[58:26.440 --> 58:34.680]  она вернет 0 1 но их всего m штук и тогда что делает же же просто вернет ровно то что вернула
[58:35.680 --> 58:47.880]  то есть мы как бы подаем вот какой-то последовательности z 0 единиц дальше я прошу
[58:47.880 --> 58:56.640]  g 1 так далее же верни мне просто 0 единицу и она мне вернет нужную координату просто просто
[58:56.640 --> 59:06.720]  для уточнения получается f это м арная функция же это м арная же сама по себе ну она немножко
[59:06.720 --> 59:15.040]  не является буря функций в том смысле которым определяли она такая а же это что ли проектора
[59:15.040 --> 59:33.240]  нет нет же это просто и нарные буря функции окей а я вы действует из м в что 0 1 м это обычная
[59:33.240 --> 59:42.680]  м арная буря функция же к сожалению давайте на нее смотреть просто как на набор из м бинарных
[59:42.680 --> 59:55.700]  функций понял почему я говорил про матрица смотрите как работала и в м сейчас же как
[59:55.700 --> 01:00:05.680]  действовала она брало n выплевывала и я вперед м выплевывает 1 поэтому композиция работает следующим
[01:00:05.680 --> 01:00:15.560]  образом вот эти должны совпадать и тогда мы из n из последовательств длины n выплениваем
[01:00:15.560 --> 01:00:30.080]  последовательств длины 1 и тогда вот эта штучка на аргументах x 1 x и он означает что что мы взяли
[01:00:30.080 --> 01:00:45.480]  f от g x 1 тогда xn то есть по сути мы посчитали же потом это то что мот анализ называл сложной функцией
[01:00:45.480 --> 01:01:04.840]  вот как правило мы будем просто жить на чем нет мы все равно все равно мы будем просто мы будем
[01:01:04.840 --> 01:01:11.040]  использовать несколько функций подавать их на вход другой функции например мы можем сказать что такое
[01:01:11.040 --> 01:01:35.520]  функция x 1 или x 2 конъюнция x 1 играете x 42 вот такая вот штучка по сути это композиция функции
[01:01:35.520 --> 01:01:53.960]  конъюнции и дизъюнции xr вот это была f это f жух вот это же вот это же первое вот это же второе
[01:02:05.520 --> 01:02:19.760]  да немножко не совсем приятные ну и вообще когда мы говорили про матрицы почему матрицы
[01:02:19.760 --> 01:02:36.600]  почему откуда они взялись у нас была штучка g 1 тогда gm что такое мы подали значение x 1 тогда xn вот
[01:02:36.600 --> 01:02:42.120]  мы записываем к обысковых по сути это просто напоминает строку нам давайте осмотрим это как
[01:02:42.120 --> 01:02:59.880]  строку 1 тогда xr тогда когда мы применим мы что как работает умножение строки на столбец
[01:02:59.880 --> 01:03:16.720]  столбца на строку да мы просто берем и сейчас это 1 на n это
[01:03:16.720 --> 01:03:33.560]  ладно я не буду это рассказывать тоже гинейная алгебра которая пока мы не рассказывали я сейчас
[01:03:33.560 --> 01:03:43.560]  не подберу просто долго буду тратить время на этом ну умножаем матрицы грубо говоря что у нас вот
[01:03:43.560 --> 01:03:51.120]  есть раз матрица g 1 тогда gm у нас есть поддали ей аргумент x 1 мы перемножили матрицы получим
[01:03:51.120 --> 01:03:59.220]  матрицу которая будет m столбцов дальше эту матрицу z m столбцов поддали f и f умеет эту
[01:03:59.220 --> 01:04:10.800]  матрицу z m столбцов превращать в 1 столбец и всегда у нас все я понял как мы будем делать наверное
[01:04:10.800 --> 01:04:29.880]  все-таки g 1 тогда gm дальше у нас есть x 1 тогда xm мы перемножили здесь получилось высчитали
[01:04:29.880 --> 01:04:44.600]  значение это будет g 1 тогда g от x 1 тогда xm теперь вот этот вот вектор мы поддали f кире это превратилось
[01:04:44.600 --> 01:04:55.640]  в f от g 1 тогда gm на самом деле когда мы говорим про функцию мы сейчас про вот такие вот функции
[01:04:55.640 --> 01:05:05.000]  мы их можем как-то представить в виде виде матрицы с какими-то коэффициентами из того
[01:05:05.000 --> 01:05:11.520]  пространства в котором она живет у нас например пространство это пространство 0 единиц будет
[01:05:11.520 --> 01:05:19.800]  матрица из 0 единиц мы умножили на столбец из 0 единиц получили новый столбец из 0 единиц и
[01:05:19.800 --> 01:05:27.920]  потом их тоже такая матрица мы перевножили только матрица размера ст 1 получается строка
[01:05:27.920 --> 01:05:38.360]  строка из 0 единиц переножили их получили число это все работает так но можете этим не задуматься
[01:05:38.360 --> 01:05:47.600]  чуть позже поймете как это связано с просто сильнее на алгебре можно точить да можете много
[01:05:47.600 --> 01:06:03.520]  вверх пытать сейчас вот на том месте где x 1 или x 2 умножить на вот эту штуку равняется 1 вот
[01:06:03.520 --> 01:06:17.520]  это если честно не очень понял x 1 еще раз x 1 или x 2 и в скобках x 1 42 ну смотри это вот как
[01:06:17.520 --> 01:06:25.000]  раз пример того что есть композиции функции вот наверху меня функция f все да да все исполнил да
[01:06:25.000 --> 01:06:32.920]  можете так и вниз немного до это я понял вот с этим объяснением том где мы берем g 1
[01:06:32.920 --> 01:06:40.180]  до gм ты и умножаем на x 1 декса до x н ты мы ждать до x н ты должны умножать а вы им написали
[01:06:40.180 --> 01:06:52.740]  кажется молодец да получается типа мы и вниз тогда даже м ты да нет просто перепутал
[01:06:52.740 --> 01:06:57.380]  координаты все вот сейчас тогда я понимаю то есть мы для каждой же 1 берем все эти и
[01:06:57.380 --> 01:07:06.940]  потом берем все эти и для f уже берем вот эти все значения да ну окей понятно только
[01:07:06.940 --> 01:07:19.700]  стрелочку типа нарисовали ну да да на самом деле просто же такая каждая функция
[01:07:19.700 --> 01:07:26.660]  какая-то строка например как можно превратить функцию строку помните мы вы мы делали по
[01:07:26.660 --> 01:07:33.100]  линомы же галкина вот мы можем взять по линомы же галкина и просто сопоставить строке коэффициенты
[01:07:33.100 --> 01:07:43.460]  вот прям при этих наборах и превратить даже не так все мы просто вычислили значение функции
[01:07:43.460 --> 01:07:52.540]  наборах 0 1 2 3 и сопоставили строке ее значение вот у нас получилось своего рода кодирование
[01:07:52.540 --> 01:08:05.020]  строки а потом дальше когда вы вычисляете звучит как то что просто надо нет там чуть
[01:08:05.020 --> 01:08:10.220]  более сложно кодирование но глобально она вы того при смену стал что мы просто строке
[01:08:10.220 --> 01:08:18.100]  сопоставили функции сопоставили строку из 0 единиц такую что вот мы просто умножаем на это
[01:08:18.100 --> 01:08:30.220]  добро можем вычислить я даже умножение так у нас есть умножение умножение так они
[01:08:30.220 --> 01:08:38.660]  у нас сложение таксор не на смысл когда мы же один умножаем на вот эту на стол 5 из
[01:08:38.860 --> 01:08:51.980]  мы же умножаем не в прямом смысле ну да конечно ладно давайте пока забудем про это добро
[01:08:51.980 --> 01:09:00.980]  у меня одного изображения пропало нет у меня тоже пропало
[01:09:00.980 --> 01:09:10.340]  и с экран просто гаса гугл перестает
[01:09:10.340 --> 01:09:20.140]  все-таки хотел спросить но-то насчет формулы икс один из юнце икс два и икс один икс сор икс два
[01:09:20.140 --> 01:09:33.700]  вот это конъюнция это вот функции которые вы подадим что-то нам нужно подать два
[01:09:33.700 --> 01:09:40.420]  аргумента конъюнция значит же будет состоять из каких-то двух функций 1 2 1 пойдет на первый
[01:09:40.420 --> 01:09:47.420]  аргумент вторая пойдет на второй аргумент первая функция же первая это что же первая это у нас
[01:09:47.420 --> 01:09:57.380]  точности дизюнция же второе это ксор поняла в таком случае мы получим что-то вроде матрицы
[01:09:57.380 --> 01:10:05.660]  потом уже применяя к ней функцию f получим значение либо 0 либо 1 да вот это как раз то что
[01:10:05.660 --> 01:10:11.860]  хотел объяснить что каждая в общем каждую функцию если мы выберем базис мы можем эту функцию
[01:10:11.860 --> 01:10:17.860]  в базисе задать какой-то строкой соответственно икс 1 тогда икс н у нас будут в этом базисе
[01:10:17.860 --> 01:10:25.780]  0 или 1 поэтому это будет столбец строка это ой функции это строка строка умножить на столбец
[01:10:25.780 --> 01:10:32.900]  это число поэтому что мы можем мы здесь когда перемножаем столбец из функций мы получим
[01:10:32.900 --> 01:10:39.820]  сейчас мы переносим когда мы перемножим столбец из функций который на самом деле строки то есть
[01:10:39.820 --> 01:10:49.980]  какую-то матрицу размера n нет размера m на n умножим на столбец из m то есть матрицу размерности
[01:10:49.980 --> 01:10:59.860]  n умножить на 1 мы получим новый столбец но только он будет размерности n m на 1 тогда функция f это
[01:10:59.860 --> 01:11:09.180]  строка раз строка размера m то есть матрица размера 1 на m на выходе при перемножении строки на
[01:11:09.180 --> 01:11:19.380]  столбец получим просто число вот глобально это работает так вообще на этом будет построен вот
[01:11:19.380 --> 01:11:26.220]  дальше весь инал что каждую функцию мы превращаем строку аргументы функции становится столбцом и
[01:11:26.220 --> 01:11:38.700]  вычисления значения функции это просто перемножение строки на столбец да а функции которые выдают
[01:11:38.700 --> 01:11:46.020]  несколько значений это вот такой столбец из функции то есть матрица размерности m на n где
[01:11:46.020 --> 01:11:57.980]  n размерность каждой функции m количество всего таких функций вот в общем надеюсь композиции плюс
[01:11:57.980 --> 01:12:08.140]  минус понятно отчасти по ботовый инал поэтому давайте говорить про композицию n уровня
[01:12:08.140 --> 01:12:19.900]  давайте сначала сразу скажем класс более функции классом более функции будем называть
[01:12:19.900 --> 01:12:28.140]  какое-то множество тогда теперь композиция
[01:12:28.140 --> 01:12:34.860]  n уровня
[01:12:34.860 --> 01:12:47.740]  для класса пушевых функций назовем луку что это такое
[01:12:47.740 --> 01:12:58.780]  определяем мы как принято в матологе по индукциям когда мы определяем по индукции нам нужно указать
[01:12:58.780 --> 01:13:07.100]  какую-то базу базу какую это натуральное число самое маленькое натуральное число это 0 соответственно
[01:13:07.100 --> 01:13:16.940]  нулевой уровень это множество всех проекторов
[01:13:16.940 --> 01:13:33.980]  проектор через е или через и пишется кто помнит е вроде бы е
[01:13:33.980 --> 01:13:48.380]  в случае если это ошибка будет не моя твоя все мы тебя запомнили вот это множество всех
[01:13:48.380 --> 01:14:05.020]  проекторов тогда если мы знаем проекцию n-1 уровня то это уровень мы получим каким образом мы
[01:14:05.020 --> 01:14:16.300]  просто возьмем множество всех возможных композиций
[01:14:16.300 --> 01:14:33.020]  пункции из q и n-1 уровня
[01:14:33.020 --> 01:14:47.020]  ну например просто давайте поймем что такое первый уровень первый уровень это мы берем
[01:14:47.020 --> 01:14:55.140]  всевозможные композиции функции ску и проекторов проектор сам по себе это функция вида взяли x1
[01:14:55.140 --> 01:15:02.020]  тогда xn просто вернули координату тогда что мы можем положить в какую-то функции ску если
[01:15:02.020 --> 01:15:13.620]  на себе просто проекторов мы получим в точности все элементы ску плюс извините
[01:15:13.620 --> 01:15:19.740]  кажется в определении должно быть и всех уровней которые меньше и равны чем n-1
[01:15:19.740 --> 01:15:37.220]  ну да да спасибо из не больше чем с первого уровня вот так напишем ну хотя
[01:15:37.220 --> 01:15:53.300]  ну смотри я могу сказать почему достаточно писать n-1 уровня потому что давай возьмем
[01:15:53.300 --> 01:16:03.380]  проектор в него подадим на нужной координате функцию из n-2 уровня и получается эта функция
[01:16:03.380 --> 01:16:09.340]  просто войдет в уровень дальше если мы какую-то функцию положили каждый следующий класс она вот так
[01:16:09.340 --> 01:16:24.180]  вот войдет сейчас если честно не очень понял еще типа мы берем функции иску и ну давай посмотрим
[01:16:24.180 --> 01:16:31.540]  что такое просто первый уровень как мы будем писать проектор проектор можно писать там можно
[01:16:31.540 --> 01:16:42.540]  писать проектор и ты и x1 тогда xn давайте я буду писать не так я буду обозначать следующим
[01:16:42.540 --> 01:16:51.460]  образом я буду говорить что это x и t и буду ставить там давайте что нет можно подумать
[01:16:51.580 --> 01:17:01.860]  давайте буду ставить буду ставить крышку над эксцитом вот эта штучка это проектор по сути на самом
[01:17:01.860 --> 01:17:13.300]  деле это просто эксцитой мы просто мы взяли его из xn поэтому если мы взяли функцию скул там
[01:17:13.300 --> 01:17:22.860]  какая-то ку принадлежит ку пусть это ку это инарная функция тогда как мне получить функцию ку я просто
[01:17:22.860 --> 01:17:40.100]  возьму x1 проектор тогда или xn вот это есть она и совпадет с ним ну да да поэтому например в
[01:17:40.100 --> 01:17:47.420]  композицию первого уровня для класса более функции ку в него войдет все ку правда ли что-то будет
[01:17:47.420 --> 01:18:04.820]  равно этом классу то есть будет ли в обратную сторону вложения но я скажу сразу нет то есть
[01:18:04.820 --> 01:18:16.300]  ку вложена в первый уровень в обратную сторону не обязательно рассмотрим такой
[01:18:16.300 --> 01:18:24.780]  класс класс из импликации первый уровень это все возможные проекторы тогда второй
[01:18:24.780 --> 01:18:33.060]  ой тогда первый это нулевой уровень все возможные проекторы первый уровень это что это от x1 может
[01:18:33.060 --> 01:18:40.820]  она у нас быть от x2 а также я могу что сделать я могу подать наоборот x2 x1 поменять местами
[01:18:40.820 --> 01:18:46.860]  проекторами а если я меняю местами проекторам ты получаешь на самом деле уже другую функцию потому
[01:18:46.860 --> 01:18:55.980]  что у них разный вектор значений то есть например первый уровень у нее будет это что это будет
[01:18:55.980 --> 01:19:07.860]  импликация в одну сторону импликация в другую сторону ну и что еще туда обязательно войдет у меня
[01:19:07.860 --> 01:19:22.300]  был x1 он принимает там сколько аргументов два аргумента вот я возьму потом сюда x1 x2 это в
[01:19:22.300 --> 01:19:35.140]  точности будет x1 так что еще сюда у меня безусловно войдет x1 x2 и в принципе любой произвольный
[01:19:35.140 --> 01:19:45.780]  уровень будет вложен следующий потому что мы возьмем x1 дальше у него подсунем нужную функцию а дальше
[01:19:45.780 --> 01:19:53.340]  все просто захламим каким-то каким-то чудом ну пусть будет x2 тогда x1 просто захламили даже можно просто
[01:19:53.340 --> 01:20:02.780]  до проекторов натыкать потому что проектора там дальше есть все и эта штука даст вот эти скажу
[01:20:02.780 --> 01:20:12.180]  что таку это есть точностеку и мы таким образом просто пододвинули функцию с более нижнего уровня
[01:20:12.180 --> 01:20:22.580]  композиции в более верхней сохранить не очень понимаю как бы я не понимаю что здесь как бы
[01:20:22.580 --> 01:20:33.740]  происходит потому что ну я просто помню на примере допустим если у нас есть функции и или да или еще
[01:20:33.740 --> 01:20:39.700]  какое-то множество функций то на первом уровне мы просто берем допустим у нас есть функция двух
[01:20:39.700 --> 01:20:49.780]  аргументов давайте рассмотрим аргумент тип такие функции дизюнция конъюнция вот и отрицание вот и
[01:20:49.780 --> 01:20:56.380]  допустим у нас есть скольптам твой пример конъюнция дизюнция отрицание очень плохой
[01:20:56.380 --> 01:21:04.100]  почему потому что потому что короче тот пример который ты привел он может представить
[01:21:04.100 --> 01:21:13.820]  абсолютно любую функцию ну ладно давайте конъюнция дизюнция конъюнция дизюнция сейчас скажу конъюнция
[01:21:14.660 --> 01:21:23.140]  ну пересечение классов варям да да ну вот и на первом уровне тогда и допустим у нас есть три
[01:21:23.140 --> 01:21:30.340]  аргумента тогда на первом уровне это будет типа x1 конъюнция x2 ну и так далее и к 2 конъюнция x3
[01:21:30.340 --> 01:21:41.020]  x3 конъюнция x1 или x1 дизюнция x2 x2 дизюнция x3 или x1 дизюнция x3 всего 6 таких штук вот но на
[01:21:41.020 --> 01:21:47.020]  3 на самом деле нет еще помимо этого всего там обязательно будут проекторы потому что возьму
[01:21:47.020 --> 01:21:55.620]  в проектор подам другие проекторы я получу проектор каждый уровень будет содержать предыдущий
[01:21:55.620 --> 01:22:03.460]  поэтому проектор лежат в абсолютно любом уровне вложенности так что там уже не получится просто
[01:22:03.460 --> 01:22:12.220]  только конъюнция дизюнция просто помню нам это по-другому объясняли нам объясняли то что как бы
[01:22:12.220 --> 01:22:17.100]  это не подвигается на один уровень они все распределены по уровням то есть как нам на лекции
[01:22:17.100 --> 01:22:26.060]  объясняли что на первом уровне ну ладно окей хорошо то есть мы говорим что у нас проектор это
[01:22:26.060 --> 01:22:34.020]  такая в общем вспомогательная функция которая с прошлого берет какую-то функцию и двигает ее
[01:22:34.020 --> 01:22:43.700]  на следующий уровень то есть типа но в общем я понимаю но это да да все я кажется понимаю супер то
[01:22:43.700 --> 01:22:51.500]  есть глобально вот про это продвижение это продвижение части нам нужно чтобы смотреть как друг
[01:22:51.500 --> 01:22:57.820]  другом класс вот потом будем говорить про то что есть замкнутые классы как между собой
[01:22:57.820 --> 01:23:09.140]  замкнутые классы будут вложены поэтому например класс проекторов он очевидно вложен в произвольный
[01:23:09.140 --> 01:23:16.580]  другой класс замкнутый замкнутый мы сейчас попозже покажем что это не но это судя из того что вы
[01:23:16.580 --> 01:23:25.700]  говорите проектор они включены в любой класс функции нет все три класс функции это просто
[01:23:25.700 --> 01:23:31.500]  произвольное множество да если произвольная функции произвольное множество функций то я могу
[01:23:31.500 --> 01:23:38.420]  туда не положить прайпер да но тогда как мы будем передвигать на следующий уровень а мы сейчас
[01:23:38.420 --> 01:23:46.020]  говорим про композицию одного уровня то есть когда мы берем функции и пытаемся друг с другом
[01:23:46.020 --> 01:23:53.980]  их на комбинировать в плане в том чтобы смотри если у нас были функции какие-то вот изначально ну
[01:23:53.980 --> 01:23:59.780]  пусть тоже конюнция дизюнция еще что-то у нас еще на самом деле есть где-то проекторы лежат
[01:23:59.780 --> 01:24:08.540]  хорошие они правильность x1 xn на самом деле проекторов столько же сколько переменных
[01:24:08.540 --> 01:24:16.860]  переменных как мы поняли мы просили счетное число проекторов счетная и мы берем пытаемся это как-то
[01:24:16.860 --> 01:24:24.660]  накомбинировать то есть просто получить новую функцию просто подав функцию какие-то другие всем
[01:24:24.660 --> 01:24:33.460]  возможными способами в этом смысл перехода на новый уровень просто пытаемся но вот вы говорите
[01:24:33.460 --> 01:24:45.420]  проектор используется значит везде это везде где класс функции является супер позиции какого-то
[01:24:45.420 --> 01:24:54.260]  уровня а у нас не любой класс является супер позиции какого-то может это пример где у нас
[01:24:54.260 --> 01:25:01.260]  проекторы не будут использоваться ну вот я возьму просто множество из инкликации это является
[01:25:01.260 --> 01:25:06.660]  классом були функции потому что это какое-то множество но не является супер позиции почему ну
[01:25:06.660 --> 01:25:15.260]  потому что как минимум здесь нет проекторов как максимум даже если мы попросим первый уровень
[01:25:15.260 --> 01:25:20.380]  сказав что давайте проектор и мы оставим ну ревом уровень будем тянуть дальше там какой-нибудь там
[01:25:20.380 --> 01:25:29.180]  возьмем определение что давайте эти штуки будут лежать сейчас скажу это штуки будут лежать в
[01:25:29.180 --> 01:25:37.100]  минимальном уровне в котором они встретились только новые добавим уберем дубляж тогда не будем
[01:25:37.100 --> 01:25:45.780]  протаскивать вверх не будет хватать аппарат инкликации а в чем разница между композицией
[01:25:45.980 --> 01:25:53.260]  уровней супер позиции на уровне ничем просто это новичное название композиции супер позиции
[01:25:53.260 --> 01:26:04.860]  сложная функция это все просто разные названия одного и того же но смотри помнишь мы даже что
[01:26:04.860 --> 01:26:12.860]  сказали что это такое это просто мы и взяли а джи текс один тогда риэсэн это вот чисто как
[01:26:13.060 --> 01:26:16.140]  анализе была сложная функция ничего нового
[01:26:16.140 --> 01:26:24.860]  дайте смотреть и замыкание класса будет
[01:26:24.860 --> 01:26:35.300]  ну опять же смотри вот на глобально нам на композиции на уровне мы можем встретить
[01:26:35.300 --> 01:26:41.580]  как нам может всех возможных композиций функции на самом деле посмотрели что в таком
[01:26:41.580 --> 01:26:49.420]  определении нам не обязательным предыдущий уровень и потому что эти функции перейдут в
[01:26:49.420 --> 01:26:58.020]  более высокий уровень а можно сказать что давайте мы минимальный минимальный уровень в котором не
[01:26:58.020 --> 01:27:02.860]  встретились вот они там останутся дальше не будут перетекать вверх ну окей тогда просто
[01:27:02.860 --> 01:27:07.100]  потребуем что композицию с не больше чем анализ первого нет нормально ничего не изменилось
[01:27:07.100 --> 01:27:21.380]  на данной лекции нам и не так сказали ну тогда тогда есть претензии тому как
[01:27:21.380 --> 01:27:26.900]  формально определено то потому что если формально говорим что всех возможных суперпозиции то не
[01:27:26.900 --> 01:27:35.260]  прорезать если не всех возможных то вот тогда уже другое определение возможно кстати по
[01:27:35.260 --> 01:27:44.780]  душу в чате про это по этому поводу сделать это давайте поговорим за прозамыканием
[01:27:44.780 --> 01:27:56.380]  просто бурю функции обозначается на следующим образом
[01:27:56.380 --> 01:28:04.500]  с квадратных скобках к у вас бурю функцию к
[01:28:04.500 --> 01:28:23.420]  это объединили всех
[01:28:23.420 --> 01:28:33.700]  объединения композиции цельку всех уровней
[01:28:41.700 --> 01:28:48.020]  то есть туда положили нулевой 1 2 и так далее вот теперь замкнутые классы
[01:28:48.020 --> 01:29:00.260]  говорим что к замкнут
[01:29:00.260 --> 01:29:07.820]  если его замыкание совпадает с ним
[01:29:07.820 --> 01:29:17.820]  то есть в чем смысл за до классов бурю функции
[01:29:17.820 --> 01:29:24.100]  в том что мы попытались взяли какой то в чем смысл в принципе замыкание класса в том что мы
[01:29:24.100 --> 01:29:39.820]  взяли сейчас скажу взяли сейчас один момент взяли какой то стартовый набор более функции а дальше
[01:29:39.820 --> 01:29:44.820]  попытались при помощи этих более функции выразить все возможные другие функции вот все что мы можем
[01:29:44.820 --> 01:29:59.020]  только выразить это есть замыкание класса дальше может например какой-нибудь замкнутого класса множество
[01:29:59.020 --> 01:30:06.100]  всех проекторов как-то комбинатор не будешь комбинировать ты получишь все равно какой-то
[01:30:06.100 --> 01:30:16.980]  проектор поэтому вот или например еще проще какой класс замкнут например пустой класс когда
[01:30:16.980 --> 01:30:23.860]  ни одна функция не вошла очень глупые примеры когда на пустой множество да никаких функций нету
[01:30:23.860 --> 01:30:29.140]  поэтому ничего накомбинировать не можешь хотя сейчас композиции там все равно проекторы будут
[01:30:29.740 --> 01:30:39.420]  поэтому композиция нулевого уровня это множество всех проекторов
[01:30:39.420 --> 01:30:56.260]  поэтому помним что из этого следует что наш класс может быть зам необходимые условия зам
[01:30:56.260 --> 01:31:08.380]  необходимые условия замкнуть типа мы для пустого класса берем все равно проекторы от каких-то
[01:31:08.380 --> 01:31:26.620]  иксов да поэтому у нас не получается в него входит все проекторы если у него не вошли то нулевой
[01:31:26.620 --> 01:31:33.220]  уровень композиции будет уже содержать какой-то проекта которого нет соответственно замыкание
[01:31:33.220 --> 01:31:42.620]  не будет содержать этого дальше что хороший пример на завтра это множество всех функций если
[01:31:42.620 --> 01:31:46.500]  назначально появилась множество всех функций то как их не комбинирует и получишь какую-то
[01:31:46.500 --> 01:31:55.540]  функцию с этого всего множество потому что это уже множество всех функций это не множество всех
[01:31:55.540 --> 01:32:06.340]  множество поэтому такое можно давайте некоторые свойства замыкания
[01:32:06.340 --> 01:32:16.580]  можно какой-нибудь более сложный пример там где типа мы используем хотя бы одну
[01:32:16.580 --> 01:32:26.620]  нормальную функцию он является замкнутым сложный функции где мы используем хотя бы там не знаю и
[01:32:26.620 --> 01:32:33.540]  дизюнкты или конъюнкты или хотя бы что-нибудь такое просто непонятно может быть я просто не
[01:32:33.540 --> 01:32:42.260]  хочу понять как это применяется функции сохраняющие 0 то есть те функции которые на наборе из нулей дают
[01:32:42.260 --> 01:32:51.260]  ноль ну смотри есть у нас например но понятно что все проекторы будут подходить сюда потому что
[01:32:51.260 --> 01:32:56.540]  но проектор на всех нулях это значит какого-то переменной какой-то компоненты она будет
[01:32:56.540 --> 01:33:01.740]  обязательно ноль все проекторы сюда вошли так что уже необходимо свой выполнено дальше давай
[01:33:01.740 --> 01:33:10.660]  посмотрим что есть во всем композицию несколько функций если у нас изначально были же и ты они
[01:33:10.660 --> 01:33:18.820]  сохраняли что они сохранили они сохраняли но сохраняли 0 то тогда если мы подадим им
[01:33:18.820 --> 01:33:25.900]  7 0 то они вернут 0 а значит если еще f сохраняла 0 она получит на вход только нули то она тоже
[01:33:25.900 --> 01:33:33.460]  вернет 0 значит композиции тоже будет 0 для произвольных f и жеитых значит композиция
[01:33:33.460 --> 01:33:42.340]  тоже будет сохраняющий но дальше я хочу уточнить еще f и g это все жеитые это получается функции
[01:33:42.340 --> 01:33:51.580]  которые мы берем иску и все f это тоже которые мы берем иску да все возможные типа да так что
[01:33:51.580 --> 01:33:59.740]  там тоже все супер ну и так далее аналогично с сохранением нуля работает сохранение единицы
[01:33:59.860 --> 01:34:07.740]  вот вам примеры функции которые которые это уже не все функции но уже какие-то такие не
[01:34:07.740 --> 01:34:13.980]  тривиальный пример дальше будут у нас мы отдельно посмотрим еще замкнутость самодольственных
[01:34:13.980 --> 01:34:28.500]  линейных или афинных и монотонных это тоже вопрос еще да а вот у нас же получается что все функции
[01:34:28.500 --> 01:34:38.140]  иску одинаковое количество аргументов не обязательно я могу в куб засунуть там функции
[01:34:38.140 --> 01:34:45.820]  различного количества аргументов ну например конъюнция дезюнция и отрицание отрицание у нас
[01:34:45.820 --> 01:34:54.420]  унарная конъюнция дезюнция бинарная мы говорим что всех возможных композиций то есть вот постараемся
[01:34:54.420 --> 01:35:00.980]  засунуть столько аргументов сколько возможно а если невозможно то ну невозможно ну просто
[01:35:00.980 --> 01:35:15.940]  только возможные способы окей так дайте про свойства замыкания но первый очевидный
[01:35:16.300 --> 01:35:26.100]  свойства по которым прогрели что обязательно множество всех проекторов войдет множество всех
[01:35:26.100 --> 01:35:41.620]  проекторов хорошо дальше второе очевидное свойство что если что просто куба идет сюда
[01:35:41.620 --> 01:35:49.700]  третий это уже не очевидный свойство что если куба множество и это какие-то
[01:35:49.700 --> 01:36:00.140]  классы более функции то из замыкания будут сохранять вложенность
[01:36:00.140 --> 01:36:15.260]  извините можно вопрос сейчас куб это уже это же у нас множество функций типа там не
[01:36:15.260 --> 01:36:19.100]  подразумевается то что мы берем какие-то аргументы то есть это типа функции просто
[01:36:19.100 --> 01:36:23.780]  как функции типа если у нас есть функции к сор и дизюнкция то просто говорим 40 дизюнкция а
[01:36:23.780 --> 01:36:30.260]  когда мы говорим про супер позиция мы указываем какие переменные мы туда кладем типа x1 x2
[01:36:30.260 --> 01:36:41.500]  но мы говорим что них вот смотри здесь я явно еще нигде не писал специально вот никакие аргументы
[01:36:41.500 --> 01:36:49.780]  вот только здесь где проектор оказался такой проектор я кладу проектор этой координаты то есть
[01:36:49.780 --> 01:36:53.780]  это функция которая возьмет n аргументов и вернет не первый
[01:36:53.780 --> 01:37:08.500]  окей ну ладно хорошо то есть на самом деле да это функции я везде вот специально писал что я
[01:37:08.500 --> 01:37:14.740]  подаю функцию функцию я нигде не писал что это какие-то x1 pvxn у меня только проекторы я вот
[01:37:14.740 --> 01:37:19.620]  подал сказал что пожалуйста давайте мы если я хочу сохранить саму по себе функцию я в нее
[01:37:19.620 --> 01:37:33.900]  насыплю проекторов окей понятно тогда вот дальше у меня есть вложенность и четвертые свойства это
[01:37:33.900 --> 01:37:40.340]  то что называется идомпатентность что если мы один раз все накомбинировали то пытаясь комбинировать
[01:37:40.340 --> 01:37:46.580]  уже всевозможные комбинации между собой мы ничего нового не накомбинировали интуитивно
[01:37:46.580 --> 01:38:03.220]  понятные правила дальше по аналогии запустью мы скажем полный класс
[01:38:03.220 --> 01:38:16.100]  был функций это такое что его замыкание совпадает с множеством всех функций
[01:38:16.820 --> 01:38:25.380]  я пишу класс класса всех булю функций
[01:38:33.620 --> 01:38:40.260]  ну и тогда у нас есть такая штука как критерий
[01:38:40.260 --> 01:38:53.060]  полноты поста что он гласит
[01:38:53.060 --> 01:39:11.940]  куполный тогда я только тогда когда эти тогда и только тогда когда первая
[01:39:11.940 --> 01:39:35.380]  ку не вложен в 0 2 ку не вложен в 1 3 ку не вложен в совдол ку не вложен в афин и 5 ку не вложен
[01:39:35.380 --> 01:39:49.060]  все поехали теперь еще раз можем что еще раз а это линейные функции у вас вот я
[01:39:49.060 --> 01:39:58.580]  сейчас все скажу что такое по ноль пойдем так далее поехали по ноль сохраняющий 0
[01:39:58.580 --> 01:40:09.140]  полный класс б это имеется в виду типа полный класс для булевых функций то есть
[01:40:09.140 --> 01:40:19.500]  ку это уже булевые функции ну полный класс булевых функций это класс булевых функций
[01:40:19.500 --> 01:40:26.620]  которые дается полно то есть мы говорим по полноту булевых для булевых функций
[01:40:26.620 --> 01:40:38.980]  да да к этой полноты булевых он кутейли полноты поста для булевых функций сохраняет 0 значит на
[01:40:38.980 --> 01:40:56.020]  значение всех нулей это 0 п 1 сохраняет единицу это f от всех единиц равняется 1 дальше д по
[01:40:56.020 --> 01:41:12.860]  английский совдол само двойственные что значит самодвойственные что дайте скажу так f от x 1
[01:41:12.860 --> 01:41:23.700]  т.д. x н равняется не f от не x 1 т.д. не x как понять что функция сохраняющая 0 сохраняющий единицу
[01:41:23.700 --> 01:41:29.700]  очевидно просто смотрим в таблице истинности на первую и последнюю строку самодвойственные
[01:41:29.700 --> 01:41:44.660]  смотрим таблицу истинности от нас там делим ее пополам прям она всегда делится пополам потому
[01:41:44.660 --> 01:41:52.300]  что у нас количество строка то есть какая-то степень двойки и смотрим что что наборы
[01:41:52.300 --> 01:42:02.140]  симметрично относительно серединки должны принимать различные значения не совпадают
[01:42:02.140 --> 01:42:12.340]  почему это так потому что наборы симметрично относительно середины это есть наборы которые
[01:42:12.340 --> 01:42:22.020]  мы по компонентно инвертировали значение это в точности просто свойство в рамках таблицы
[01:42:22.020 --> 01:42:35.300]  истинности такой вот радугой дальше а а можно пример какой-нибудь пожалуйста извините наоборот
[01:42:35.300 --> 01:42:46.420]  если они не совпадают то получается что сейчас если они совпадают то она как раз
[01:42:46.420 --> 01:42:53.260]  ки получается не является самодвойственной да а мы говорим что не совпадает значит на самодвойственное
[01:42:53.260 --> 01:43:07.180]  давай я сделаю только можем пример да да вот побольше спасибо вот я возьму дайте что функцию
[01:43:07.180 --> 01:43:18.460]  там 0 1 1 0 1 1 1 1 жух беру делу телю пополам таблицейственности а теперь смотрю на вот
[01:43:18.460 --> 01:43:24.980]  такие вот наборы симметрично относительно серединки 0 1 у меня не совпали а вот один один
[01:43:24.980 --> 01:43:31.580]  совпали поэтому эта функция не самодвойственная например если я возьму испорчу это и скажу что
[01:43:31.580 --> 01:43:46.540]  пожалуйста будь нулём то функции станет вполне себе самодвойственной например один искусство
[01:43:46.540 --> 01:43:56.540]  самодвойственных функций что нам на самом деле не нужно сохранять весь ее массив значений нам
[01:43:56.540 --> 01:44:07.540]  нужно сохранить лишь первую половину его в этом так вот оптимизация то есть поле 1 и 1 0 это одно
[01:44:07.540 --> 01:44:16.140]  и тоже если совпадает то нечетная самодвойственная да если совпало то это не самое я имею
[01:44:16.140 --> 01:44:22.180]  в виду 0 1 и 1 0 это рабочая тема 0 1 1 0 да это самодвойственная они все не совпали
[01:44:22.180 --> 01:44:33.060]  симметричные поэтому всего а это класс афинных или не или линейных афинные ли не
[01:44:33.420 --> 01:44:41.060]  если бы там было 0 1 1 0 то они бы совпали значит это не самодвойственная не не самодвойственная
[01:44:41.060 --> 01:44:46.700]  это не самодвойственная линейные могут еще обозначать их как и
[01:44:46.700 --> 01:44:56.100]  аналогично самодвойственные д это долл но по-английски это все в дуле могут еще обозначать
[01:44:56.100 --> 01:45:07.100]  как я буду значать здесь д возможно иногда кстати мне будет переклинивать на с афинные это
[01:45:07.100 --> 01:45:16.500]  а также можно означать л от слова линейные ну откуда что то что сейчас на какие мысли
[01:45:16.500 --> 01:45:24.780]  налевать на понятие линейность это как раз линейность по дому жигалкина поэтому это все у кого
[01:45:24.780 --> 01:45:39.420]  по дому жигалкина линейный дальше стать я сейчас вспомнил про по дому жигалкина когда спрашивали
[01:45:39.420 --> 01:45:45.180]  про минимальность даже на экзамене будет один из билетов заключается в том что каждый функции
[01:45:45.180 --> 01:45:53.620]  соответствует единственной по дому жигалкина поэтому там без вариантов просто только один
[01:45:53.620 --> 01:46:03.780]  по дому жигалкин задает одну функцию и наоборот там минимизировать нечего и это монотонные
[01:46:03.780 --> 01:46:20.020]  что это значит что f от x1 т.д.xн должно не превосходить от f y1 т.д.yн если x1 т.д.xn
[01:46:20.020 --> 01:46:32.740]  y1 т.д.yн порядок мы помним порядок декартов монотонность прям в точности как обычная
[01:46:32.740 --> 01:46:37.300]  монотонность функции только тогда у нас были чисто мы говорили что чисто больше теперь у нас
[01:46:37.300 --> 01:46:57.660]  такие вектора из 0 единиц и если у нас появилась класс более функций на такой множество причем
[01:46:57.660 --> 01:47:05.060]  хорошие то мы можем сказать про базис класса
[01:47:05.060 --> 01:47:17.860]  базис класса класса более функций
[01:47:17.860 --> 01:47:41.260]  это класс как назовем базис давайте назовем базис буквы b такое что первое замыкание
[01:47:41.260 --> 01:47:48.620]  дает нам кум то есть мы можем при помощи функции с класса b выразить произвольную функцию с класса
[01:47:48.620 --> 01:48:01.540]  кум и второе что для любого b штрих под множество такого что не равно b выполнено что замыкание
[01:48:01.540 --> 01:48:14.820]  b штрих не равняется кум только такая что теперь если мы выкинем какую-то функцию из класса из
[01:48:14.820 --> 01:48:20.820]  выкинем какую-то функцию из базиса то мы потеряем выразимость некоторых функций с кум
[01:48:20.820 --> 01:48:30.900]  все табарны на этом теория вся давайте вопрос о теории это когда ты ее скребу
[01:48:50.820 --> 01:48:53.900]  один вопрос их нет поэтому будем прямо сейчас решать
[01:49:20.820 --> 01:49:29.540]  все хорошо итак у нас есть многочлен же галкина для функции от хотя бы двух
[01:49:29.540 --> 01:49:35.420]  переменных то есть почему мы смотрим на двух переменных хотя бы потому что у нас может
[01:49:35.420 --> 01:49:41.380]  появиться нелинейность для одной переменной все слишком скучно и выберите утверждение
[01:49:41.380 --> 01:49:50.580]  мы содержит слагаем один тогда и только тогда когда на всех нулях это один правда это или нет
[01:49:50.580 --> 01:50:06.180]  кто помнит мне кажется да да мы прям если посмотрим сейчас когда мы говорили про пареном
[01:50:06.180 --> 01:50:13.740]  же галкина бум бум бум бум бум это было давно же галкина первые вот свободный член это в
[01:50:13.740 --> 01:50:19.540]  точности значение на всех нулях то есть если значение на всех нулях один у нас будет свободно
[01:50:19.540 --> 01:50:30.380]  член один если на всех нулях будет но то получим 0 1 не получим все слагаем мы короче маном из
[01:50:30.380 --> 01:50:35.580]  всех переменных тогда и только тогда когда значение на всех единицах это один правда ли это
[01:50:35.580 --> 01:50:50.500]  нет нет нет правильно это неверно потому что давайте мы скажем что на всех единицах будет
[01:50:50.500 --> 01:51:03.820]  один а где-нибудь оставшееся нечетное число этих штук мы доберем нет нам ведь достаточно
[01:51:03.820 --> 01:51:09.980]  подождите нам достаточно условий чтобы существовал вот эта штука то чтобы у нас было просто нечетное
[01:51:09.980 --> 01:51:19.220]  число единиц в итоге чтобы существовало да это даже не просто для существования вот этого манома
[01:51:19.220 --> 01:51:33.260]  это необходимые достаточное оно для для для для линейности такая штука получается нам если мы
[01:51:33.260 --> 01:51:43.460]  говорим что если здесь единицы мы хотим попросить чтобы пожалуйста можно тогда я в п1 пн сейчас
[01:51:43.460 --> 01:51:49.780]  п1 пн не существовало но функции принимал на всех единицах один тогда мне нужно просто добить
[01:51:49.780 --> 01:51:57.740]  дочетного числа единиц и ее значениях и это могу спокойно раскидать по другим наборам все возьму
[01:51:57.740 --> 01:52:03.660]  какой-нибудь еще один набор туда поставлю единица все остальное 0 вот у меня будет функции на всех
[01:52:03.660 --> 01:52:12.500]  единицах один но при этом содержать такого слагаемого не будет в смысле тут уже очень
[01:52:12.500 --> 01:52:15.900]  просто рассуждение просто говорим у нас может быть такой пример то что нас нечетное количество
[01:52:15.900 --> 01:52:23.780]  единиц при этом f от всех единиц равно ну или так ну просто с разных сторон смотрим в кидах
[01:52:23.780 --> 01:52:31.020]  п содержит слагаемое один тогда только тогда когда f на всех нулях ну и ну очевидно это противоречит
[01:52:31.020 --> 01:52:37.900]  пункту а который мы сказали что верно поэтому скип п содержит слагаемое п1 тогда или пн тогда только
[01:52:37.900 --> 01:52:44.300]  тогда когда на всех единицах 0 но тут работает то что я сказал что давайте возьмем на всех единицах
[01:52:44.300 --> 01:52:53.060]  один какой-то еще набор на нем будет один а нет нет мы просто возьмем функцию которая только на
[01:52:53.060 --> 01:52:59.220]  единицах равняется единицей остальные 0 этой мерной конъюнции не будет содержаться вот это добро
[01:52:59.220 --> 01:53:07.180]  но при этом на единицах она не 0 поэтому неверно вот как раз прекрасный пример когда написано
[01:53:07.180 --> 01:53:16.780]  выберите верное утверждение оно одно поэтому внимательно а можете пожалуйста пояснить еще
[01:53:16.780 --> 01:53:26.180]  раз почему бы это неверное почему бы это неверно смотри я возьму функцию здесь сейчас мы говорили
[01:53:26.180 --> 01:53:34.020]  когда у нас существует такой маном критерии его и он существует тогда и только тогда когда
[01:53:34.020 --> 01:53:45.580]  функция f принимает нечетное число раз единицы вот я возьму здесь единицу на этом наборе я возьму
[01:53:45.580 --> 01:53:52.580]  функцию на наборе давайте как он на всех нулях тоже будет единица она всех остальных наборах у меня
[01:53:52.580 --> 01:54:00.820]  будет 0 тогда она всего содержит четное число единиц а значит слагаемые п1 тогда для пн не
[01:54:00.820 --> 01:54:11.340]  войдет в пыльном жигалке поняла то есть пыльном жигалки наслежит но вот п1 п2 пн только в
[01:54:11.340 --> 01:54:26.340]  том случае если количество один нечетно да поняла спасибо теперь номер 15
[01:54:30.820 --> 01:54:52.940]  какие свойства могут одновременно выполнить не сохраняет 0 но на то на нелинейно как это как с
[01:54:52.940 --> 01:55:04.060]  этим жить как правило смотрим на таблицу истинности и понимаем может ли быть такое не сохраняет 0 это
[01:55:04.060 --> 01:55:10.660]  как выглядит это вот нас из таблицы всех здесь набор всех нулей не сохраняет он значит здесь
[01:55:10.660 --> 01:55:20.180]  единицы монотонно наборы все короче все наборы из нулей единиц они будут не меньше чем набор
[01:55:20.180 --> 01:55:26.260]  из нулей и поэтому если на монотонно то значение должно быть не меньше чем единица значит будет
[01:55:26.260 --> 01:55:32.900]  единицей значит на самом деле наша функция вот такая вот всех единиц вопрос будет ли она
[01:55:32.900 --> 01:55:40.620]  линейной эта функция которую всегда принимает единица поэтому что функция единица а единица
[01:55:40.620 --> 01:55:44.300]  в одном же балке начали на единицах поэтому она всегда линейно соответственно такого быть не
[01:55:44.300 --> 01:55:54.100]  может смотрим на следующий номер из так у нас сохранение единиц сохранить сохранение нуля вот
[01:55:54.100 --> 01:55:59.940]  нас набор из нулей из единиц сохраняет один значит на 1 1 не сохраняет 0 значит нулях она единица
[01:55:59.940 --> 01:56:09.300]  самодвойственно дайте посмотрим вот у нас набор может быть такое не может быть она не
[01:56:09.300 --> 01:56:19.100]  самодвойственно пункт вы а если бы сохраняла 0 то тогда была бы самодвойственно да тогда у
[01:56:19.100 --> 01:56:24.020]  нас могут быть одновременно выполнено такое свойство там просто доберем оставшиеся набора
[01:56:24.020 --> 01:56:33.860]  как нибудь по самодвойственности красивенько вот сейчас как раз у нас будет этот пример 1 1 на
[01:56:33.860 --> 01:56:43.860]  нулях она сохраняет 0 на единицах сохраняет единицу она самодвойственно и линейно давайте я рассмотрю
[01:56:43.860 --> 01:56:57.100]  функцию от двух переменных 0 1 1 0 1 1 я смотрю что пока я вот смотрите пока я смотрел у меня
[01:56:57.100 --> 01:57:02.940]  ничего не нарушилось то есть самодвойственность мне пока есть линейность но я могу добрать до
[01:57:02.940 --> 01:57:09.220]  четного числа единиц и поэтому меня не спортится вот я вот к необходимым условиям поэтому я пытаюсь
[01:57:09.220 --> 01:57:14.540]  построить просто функцию которая хорошая как правило функции двух переменных достаточно
[01:57:14.540 --> 01:57:23.540]  чтобы если он есть пример то вы найдете очень надеюсь что не по не получится так что специально
[01:57:23.540 --> 01:57:28.980]  сейчас посмотрят это скажут что вот сказали про это давайте придумаем такой пример что он только
[01:57:28.980 --> 01:57:35.220]  работает на трех перемен дальше все на совести составитель задачи раньше всегда все от двумя
[01:57:35.220 --> 01:57:41.940]  функция для двух аргументов всегда работала в общем если в этом году не работает то это не
[01:57:41.940 --> 01:57:54.580]  я виноват тогда пробуйте из трех здесь 0 здесь 1 нам нужно дать самодвойственности линейность
[01:57:54.580 --> 01:58:01.340]  линейность значит мне нужно будет поставить что мне нужно сделать хотя бы четное число ну
[01:58:01.340 --> 01:58:06.340]  четное какими сделаю значит нужно расставить только одну единицу сюда ну давайте сделаю здесь
[01:58:06.340 --> 01:58:14.220]  один тогда по самодвойственности это должно быть нырём что это за функции это функции проекта
[01:58:14.220 --> 01:58:21.020]  первых координат и ее проектор его полиновом же галкин это в точности просто название этой
[01:58:21.020 --> 01:58:30.140]  переменной то есть поэтому длиннее все супер такое может быть как вы еще раз так быстро пределили
[01:58:30.140 --> 01:58:38.620]  поляном же галкину почему-то ну смотри 0 единицы это на что за функции она ведь совпадает просто
[01:58:38.620 --> 01:58:49.860]  со со значениями поэтому это проектор а проектор просто это название с этой переменной и у нее
[01:58:49.860 --> 01:58:57.020]  поляном же галкина вот как правило если надо там что-нибудь делать пробуйте выходить на какие-то
[01:58:57.020 --> 01:59:03.620]  простые функции их проводить пример вот например на поляном же ой на проектор и уходит все супер
[01:59:03.620 --> 01:59:15.020]  более того смотрите здесь не сказано что качество переменных должно быть больше одной поэтому
[01:59:15.020 --> 01:59:20.740]  можно было попробовать просто одной переменной здесь на нулях единицах поиграться что за функция
[01:59:20.740 --> 01:59:31.020]  здесь тоже выйдет проектор давайте смотреть линейная а тен больше одной переменной равна нулю на
[01:59:31.020 --> 01:59:39.340]  нечетном числе наборов но мы помним что критерии ой необходимые условия линейности это то что
[01:59:39.340 --> 01:59:49.180]  должна быть равна но сейчас равна единицы на четном числе наборы вопрос и как садить как
[01:59:49.180 --> 01:59:58.060]  соотносятся четность количестве единиц и количества нулей в векторе функции колокольки
[01:59:58.060 --> 02:00:11.980]  но они равны да потому что всего всего значение функции принимает два степени то есть четные
[02:00:11.980 --> 02:00:16.860]  поэтому если одно четное то и другое четное если одно нечетное то и другое нечетное поэтому
[02:00:16.860 --> 02:00:25.900]  если она равна нулю на четном наборе то и единицы на нечетном а дальше в максимальной степени
[02:00:26.620 --> 02:00:31.180]  да значит нелинейно все по инну она нелинейна
[02:00:31.180 --> 02:00:43.260]  вот здесь мы даже ничего не строили никакие из предыдущих но опять все мимо и опять у нас
[02:00:43.260 --> 02:00:52.620]  чудные задания в котором какие а правильный только один поэтому
[02:00:52.620 --> 02:01:01.140]  а можете пожалуйста еще раз объяснить как мы в первом пункте так быстро поняли что она линей
[02:01:01.140 --> 02:01:18.180]  навсегда глянем смотри не сохраняет 0 значит на наборе всех нулей она единица монотонно смотри
[02:01:18.180 --> 02:01:23.500]  один из таких свойств из аналогов того что можно говорить такой монотонность это если она на
[02:01:23.500 --> 02:01:29.020]  каком-то наборе единица то и на всех наборах его больше она тоже единица да то есть везде
[02:01:29.020 --> 02:01:34.020]  единица это понятно да а если функции везде принимает значение единица то это функция единица
[02:01:34.020 --> 02:01:46.620]  в равно один а это значит что линейно да понятно спасибо да нет извините а можете
[02:01:46.620 --> 02:01:53.940]  поесть еще раз необходимые условия просто почему она работает окей сейчас вернемся
[02:01:53.940 --> 02:02:10.980]  сейчас я сделаю красивенькое бом бом бом бом бом смотри у нас то что коэффициент при
[02:02:10.980 --> 02:02:18.740]  маноме x1 тогда xn принимал он есть если функция принимает один нечетный раз и отсутствует если
[02:02:18.740 --> 02:02:31.620]  четные это понятно да супер тогда если у нас степень f и f более чем бинарно не менее чем
[02:02:31.620 --> 02:02:42.740]  бинарно и она принимает один нечетный число раз то значит тогда в нее войдет полином ой в нее
[02:02:42.740 --> 02:02:50.060]  войдет маном x1 тогда xn причем n у нас будет хотя бы двойкой значит у нас будет маном степени
[02:02:50.060 --> 02:03:06.860]  больше чем не меньше чем два а значит она будет не линейна супер хорошо через замыкание какие из
[02:03:06.860 --> 02:03:12.780]  этих свойств гарантирует что пересечение что замыкание пересечения равно пересечение замыкания
[02:03:12.780 --> 02:03:24.380]  такие штук нам гарантируют
[02:03:24.380 --> 02:03:35.740]  ну давайте для произволь для любых множеств уже интуитивно должно быть понятно что это не
[02:03:35.740 --> 02:03:45.820]  должно работать просто перейдем пример ну например что я возьму например я возьму сюда что у меня
[02:03:45.820 --> 02:03:53.220]  вот например есть классе функций я могу сказать что он является замыканием конъюнции дезюнции
[02:03:53.220 --> 02:04:08.980]  инверсии потому что кнф днф и также он равняется замыканию ксор единица и что там конъюнция в этот
[02:04:08.980 --> 02:04:17.220]  раз я буду выучать и ниц и ниц и они вот как в прошлый раз потому что чтобы не путать ст все у меня
[02:04:17.220 --> 02:04:25.700]  вот такое получилось давайте просто просмотрим их их пересечение их замыкание это в точности
[02:04:25.700 --> 02:04:31.980]  т а их собственное пересечение это просто функция конъюнции понятно что одной конъюнции мы не выразим
[02:04:31.980 --> 02:04:43.940]  всевозможные функции почему ну например потому что функция ку сохраняет 0 а 0 это замкнутый
[02:04:43.940 --> 02:04:49.180]  класс значит как бы мы ку не комбинировали она всегда будет сохранять вот как бы конъюнции мы
[02:04:49.180 --> 02:04:56.300]  комбинировали она будет всегда сохранять 0 а функции не сохраняющие 0 она не выразить это кстати
[02:04:56.300 --> 02:05:03.740]  одна из идей которая потом будет все не работает ку вложена можно очень быстро при чем здесь сохранение
[02:05:03.740 --> 02:05:11.060]  нуля мы же поняли просто что их пересечение это просто дезюнции поэтому не работает но нам
[02:05:11.060 --> 02:05:17.060]  нужно сказать почему одной конъюнции мы не выразимся функции вот как ты докажешь хорошее
[02:05:17.060 --> 02:05:22.220]  доказательство этого то что мы скажем что вот там ку лежит в каком-то замкнутом классе а этот
[02:05:22.220 --> 02:05:27.380]  замкнутый класс не является всем множеством множеством всех функций вот я говорю что например
[02:05:27.380 --> 02:05:37.860]  например это что конъюнция сохраняет 0 а класс сохранения нуля он замкнутый поэтому чтобы мы
[02:05:37.860 --> 02:05:46.540]  не выражали при помощи конъюнции будет сохранять но а значит мы не выразим все функции а справа
[02:05:46.540 --> 02:05:59.260]  у нас будет как раз множество всех функций поэтому неверно сейчас если честно не очень понял на
[02:05:59.260 --> 02:06:09.980]  же и без всех без сохранения нули все работает в общем это просто просто формально доказали
[02:06:09.980 --> 02:06:17.820]  почему-то так не более чем на естественно на контроль на это все просто смотрится и
[02:06:17.820 --> 02:06:28.380]  такой вижу пишу не доказывать вот ку вложено в эр у нас какие-то свойства но если ку вложено
[02:06:28.380 --> 02:06:42.900]  в эр то пересечение куэр это что это ку супер соответственно слева мы имеем вот такую штуку
[02:06:42.900 --> 02:06:53.780]  справа что у нас вот меняется куэр я знаю что тогда если ку вложено в эр то замыкание ку вложено
[02:06:53.780 --> 02:07:02.340]  замыкание эр значит замыкание ку замыкание эр так как первое вложено во второе то это равняется в
[02:07:02.340 --> 02:07:14.580]  точности своему первому ну и понятно что я вижу равенство ой да это гарантирует дальше я предлагаю
[02:07:14.580 --> 02:07:27.020]  рассмотреть следующую штуку ты ну потом покажем почему так у нас есть прекрасные две штуки про
[02:07:27.020 --> 02:07:34.460]  которые мы говорили это стрелка пирса и штрих шефера и их плюс в том что при помощи их мы
[02:07:34.460 --> 02:07:43.060]  можем выразить абсолютно любую булил функцию и они являются базисом класса всех возможных функций
[02:07:43.060 --> 02:07:54.500]  очевидно что что он получим в пересечении этих это пустое множество замыкание пусто множество
[02:07:54.500 --> 02:08:03.260]  это множество всех проекторов а справа мы видим просто пересечение т и т но очевидно что это неверно
[02:08:03.260 --> 02:08:15.300]  и ну мы видим что правда куэр сами не пересекаются поэтому вот все и у нас снова чудесный номер в
[02:08:15.300 --> 02:08:21.980]  котором только спрашивают про какие а правильно ответ один погодите а как мы поняли что г это
[02:08:21.980 --> 02:08:35.380]  неверно стрелка пирса штрих шефера являются базисом класса всех функций а поняла спасибо
[02:08:35.380 --> 02:08:45.260]  большое сейчас и получается они не подходят потому что у нас их пересечение это пустое множество
[02:08:45.380 --> 02:08:52.380]  получается и слева пустое множество и справа тоже пустой множество смотри во первых
[02:08:52.380 --> 02:08:57.700]  замыкание пусто множество это может и вообще до справа все потому что каждое по отдельности
[02:08:57.700 --> 02:09:07.380]  замыкание да вот можется функции пон weaving все3004 под investigatorvar composition
[02:09:07.380 --> 02:09:09.380]  это все, а с левым получается пустое будет.
[02:09:09.380 --> 02:09:11.380]  Ну не пустое, а множество всех крейкеров.
[02:09:11.380 --> 02:09:13.380]  Да, множество всех крейкеров.
[02:09:13.380 --> 02:09:15.380]  А вот еще хотел точнить
[02:09:15.380 --> 02:09:17.380]  насчет там, где
[02:09:19.380 --> 02:09:21.380]  насчет пункта В.
[02:09:21.380 --> 02:09:23.380]  Пункта В.
[02:09:23.380 --> 02:09:25.380]  Тут работает вот тот же
[02:09:25.380 --> 02:09:27.380]  пример. Тот же пример, да?
[02:09:27.380 --> 02:09:29.380]  Да, мы просто не примеры,
[02:09:29.380 --> 02:09:31.380]  мы шили два одного мира. Понятно.
[02:09:31.380 --> 02:09:33.380]  Про вот это вот
[02:09:33.380 --> 02:09:35.380]  обязательно напомним. Короче, все
[02:09:35.380 --> 02:09:37.380]  держится просто на том, что
[02:09:37.380 --> 02:09:39.380]  мы помним, как
[02:09:39.380 --> 02:09:41.380]  выразить класс всех функций.
[02:09:41.380 --> 02:09:43.380]  Вот так вот можно,
[02:09:43.380 --> 02:09:45.380]  вот так вот можно, можно вот так вот
[02:09:45.380 --> 02:09:47.380]  дальше. На самом деле
[02:09:47.380 --> 02:09:49.380]  можно будет выразить вот
[02:09:49.380 --> 02:09:51.380]  так вот нам
[02:09:53.380 --> 02:09:55.380]  и можно выразить
[02:09:55.380 --> 02:09:57.380]  вот так вот.
[02:09:57.380 --> 02:09:59.380]  Вот. Это нам
[02:09:59.380 --> 02:10:01.380]  для кнф и днф,
[02:10:01.380 --> 02:10:03.380]  но на самом деле там одна из этих
[02:10:03.380 --> 02:10:05.380]  штук, она лишняя.
[02:10:05.380 --> 02:10:07.380]  Это не
[02:10:07.380 --> 02:10:09.380]  то есть она будет не базисом. Базисом
[02:10:09.380 --> 02:10:11.380]  будет вот. Базисом у нас
[02:10:11.380 --> 02:10:13.380]  раз, два, три, четыре, пять.
[02:10:13.380 --> 02:10:15.380]  Давайте сразу их выпишем.
[02:10:15.380 --> 02:10:17.380]  Базис и т.
[02:10:19.380 --> 02:10:21.380]  Первое это у нас
[02:10:21.380 --> 02:10:23.380]  конъюнция отрицания.
[02:10:23.380 --> 02:10:25.380]  Второе
[02:10:25.380 --> 02:10:27.380]  дизюнция отрицания.
[02:10:27.380 --> 02:10:29.380]  Третье
[02:10:29.380 --> 02:10:31.380]  конъюнция экссор
[02:10:31.380 --> 02:10:33.380]  единица.
[02:10:33.380 --> 02:10:35.380]  Четвертое
[02:10:35.380 --> 02:10:37.380]  стрелка пирса.
[02:10:37.380 --> 02:10:39.380]  Трешкой вы называете любую
[02:10:39.380 --> 02:10:41.380]  бф?
[02:10:41.380 --> 02:10:43.380]  Это множество всех возможных более функций.
[02:10:43.380 --> 02:10:45.380]  Понял.
[02:10:51.380 --> 02:10:53.380]  Хорошо.
[02:10:53.380 --> 02:10:55.380]  Есть такая штука, есть такая штука.
[02:10:55.380 --> 02:10:57.380]  Можете, пожалуйста, наполнить быстро,
[02:10:57.380 --> 02:10:59.380]  как с помощью
[02:10:59.380 --> 02:11:01.380]  этих мы выражаем
[02:11:01.380 --> 02:11:03.380]  те.
[02:11:05.380 --> 02:11:07.380]  Как при помощи этих выражаем?
[02:11:07.380 --> 02:11:09.380]  Ну, с помощью третьего,
[02:11:09.380 --> 02:11:11.380]  это просто мы вычислим отжигалки.
[02:11:11.380 --> 02:11:13.380]  А с помощью там
[02:11:13.380 --> 02:11:15.380]  первого, второго, четвертого. Я помню,
[02:11:15.380 --> 02:11:17.380]  с помощью первого мы
[02:11:17.380 --> 02:11:19.380]  хотим нам наполнить.
[02:11:19.380 --> 02:11:21.380]  И второго, и четвертого, и пятого.
[02:11:21.380 --> 02:11:23.380]  Третий полинов жигалки. Федос,
[02:11:23.380 --> 02:11:25.380]  подумай сначала.
[02:11:25.380 --> 02:11:27.380]  Ну, смотри, первый, второй
[02:11:27.380 --> 02:11:29.380]  очень легко делается.
[02:11:29.380 --> 02:11:31.380]  Для этого нам нужно просто при помощи
[02:11:31.380 --> 02:11:33.380]  конъюнции и отрицания выразить
[02:11:33.380 --> 02:11:35.380]  дизюнцию и наоборот.
[02:11:35.380 --> 02:11:37.380]  Ну, что такое?
[02:11:37.380 --> 02:11:39.380]  А или B?
[02:11:39.380 --> 02:11:41.380]  Ну, смотри, это то же самое, что не A
[02:11:41.380 --> 02:11:43.380]  или не B.
[02:11:43.380 --> 02:11:45.380]  А дальше мы применяем закон домоордана.
[02:11:45.380 --> 02:11:47.380]  Не, не A,
[02:11:47.380 --> 02:11:49.380]  и не B.
[02:11:49.380 --> 02:11:51.380]  Все.
[02:11:51.380 --> 02:11:53.380]  Вот так вот я могу выразить
[02:11:53.380 --> 02:11:55.380]  при помощи...
[02:11:55.380 --> 02:11:57.380]  четвертого и пятого.
[02:11:59.380 --> 02:12:01.380]  При помощи четвертого и пятого, смотри,
[02:12:01.380 --> 02:12:03.380]  я не помню в точности что и что.
[02:12:03.380 --> 02:12:05.380]  В общем,
[02:12:05.380 --> 02:12:07.380]  вот эта штука,
[02:12:07.380 --> 02:12:09.380]  это отрицание.
[02:12:11.380 --> 02:12:13.380]  Дальше.
[02:12:13.380 --> 02:12:15.380]  Ну, да.
[02:12:15.380 --> 02:12:17.380]  А, B.
[02:12:19.380 --> 02:12:21.380]  А, B.
[02:12:21.380 --> 02:12:23.380]  А, A.
[02:12:25.380 --> 02:12:27.380]  А, B.
[02:12:29.380 --> 02:12:31.380]  Б. Аналогично для
[02:12:31.380 --> 02:12:33.380]  стрелки...
[02:12:33.380 --> 02:12:35.380]  для штриха шейфера.
[02:12:35.380 --> 02:12:37.380]  Аналогично.
[02:12:39.380 --> 02:12:41.380]  Короче, одно из них является дизюнции,
[02:12:41.380 --> 02:12:43.380]  другое является конъюнции.
[02:12:43.380 --> 02:12:45.380]  И что и что, в каждом случае я точно не помню.
[02:12:45.380 --> 02:12:47.380]  Окей, все.
[02:12:49.380 --> 02:12:51.380]  Извините, а
[02:12:51.380 --> 02:12:53.380]  нет еще...
[02:12:53.380 --> 02:12:55.380]  что выражать, мы научились даже.
[02:12:55.380 --> 02:12:57.380]  Там привели в КНФ
[02:12:57.380 --> 02:12:59.380]  ДНФ и даже
[02:12:59.380 --> 02:13:01.380]  Тваринтич.
[02:13:05.380 --> 02:13:07.380]  Давайте смотреть.
[02:13:09.380 --> 02:13:11.380]  В паренном жигалке насчитаем в третий раз
[02:13:11.380 --> 02:13:13.380]  или уже достаточно?
[02:13:17.380 --> 02:13:19.380]  Ну, хуже не будет.
[02:13:19.380 --> 02:13:21.380]  Ну, давай.
[02:13:21.380 --> 02:13:23.380]  Не знаю, я бы уже пропустил.
[02:13:25.380 --> 02:13:27.380]  Ну, если просят, то давайте в третий раз
[02:13:27.380 --> 02:13:29.380]  посчитаем паренном жигалкина.
[02:13:31.380 --> 02:13:33.380]  Никогда еще столько раз паренном жигалкина
[02:13:33.380 --> 02:13:35.380]  не считали.
[02:13:37.380 --> 02:13:39.380]  Что?
[02:13:39.380 --> 02:13:41.380]  Писуем треугольник Паскалем.
[02:13:43.380 --> 02:13:45.380]  Только ответа недостаточно,
[02:13:45.380 --> 02:13:47.380]  нужно объяснить, как он получим.
[02:13:47.380 --> 02:13:49.380]  Применяем
[02:13:49.380 --> 02:13:51.380]  метод
[02:13:51.380 --> 02:13:53.380]  треугольника Паскаля.
[02:13:55.380 --> 02:13:57.380]  1 0 1
[02:13:57.380 --> 02:13:59.380]  0 0
[02:13:59.380 --> 02:14:01.380]  1 1 0
[02:14:01.380 --> 02:14:03.380]  Поехали.
[02:14:15.380 --> 02:14:17.380]  Соответственно, теперь выписываем,
[02:14:17.380 --> 02:14:19.380]  какие здесь у нас соответствуют
[02:14:19.380 --> 02:14:21.380]  мономы.
[02:14:33.380 --> 02:14:35.380]  Смотрим на левую штучку.
[02:14:37.380 --> 02:14:39.380]  Поехали. У меня есть раз, два, три, четыре.
[02:14:39.380 --> 02:14:41.380]  То есть это вот этот вот.
[02:14:47.380 --> 02:14:49.380]  И выписали его.
[02:14:57.380 --> 02:14:59.380]  Спидран по решению
[02:14:59.380 --> 02:15:01.380]  17 задачи готов.
[02:15:07.380 --> 02:15:09.380]  Так, 18 скипаем.
[02:15:11.380 --> 02:15:13.380]  В общем, дайте я проще скажу.
[02:15:17.380 --> 02:15:19.380]  Что-то в вашем году решили
[02:15:19.380 --> 02:15:21.380]  хардонуть.
[02:15:27.380 --> 02:15:29.380]  Извините, можно очень быстро
[02:15:29.380 --> 02:15:31.380]  учинить? Получается 16 ответ, только
[02:15:31.380 --> 02:15:33.380]  B.
[02:15:33.380 --> 02:15:35.380]  Да.
[02:15:37.380 --> 02:15:39.380]  Пугаться то, что спрашивают,
[02:15:39.380 --> 02:15:41.380]  какие у вас получилось один,
[02:15:41.380 --> 02:15:43.380]  и вы точно в этом верите, не надо.
[02:15:43.380 --> 02:15:45.380]  Просто люди не совсем
[02:15:45.380 --> 02:15:47.380]  умеют корректно составить число.
[02:15:51.380 --> 02:15:53.380]  Вот, короче.
[02:15:57.380 --> 02:15:59.380]  Номер про 19.
[02:15:59.380 --> 02:16:01.380]  Спрашивают какую-то функцию
[02:16:01.380 --> 02:16:03.380]  от какого-то количества аргументов.
[02:16:03.380 --> 02:16:05.380]  И просят
[02:16:05.380 --> 02:16:07.380]  сказать, при каких N
[02:16:07.380 --> 02:16:09.380]  она является какой.
[02:16:09.380 --> 02:16:11.380]  Как решается этот номер? Смотрите,
[02:16:11.380 --> 02:16:13.380]  как правило, там
[02:16:13.380 --> 02:16:15.380]  0, 1, 2, 3.
[02:16:15.380 --> 02:16:17.380]  Мы просто строим
[02:16:17.380 --> 02:16:19.380]  таблицу истины для этой
[02:16:19.380 --> 02:16:21.380]  булливой функции и прям явно выписываем.
[02:16:21.380 --> 02:16:23.380]  А при больших значениях,
[02:16:23.380 --> 02:16:25.380]  как правило, это просто какой-то там
[02:16:25.380 --> 02:16:27.380]  будет.
[02:16:27.380 --> 02:16:29.380]  А при больших значениях там всегда
[02:16:29.380 --> 02:16:31.380]  выполняется одно и то же, просто
[02:16:31.380 --> 02:16:33.380]  нужно заметить закономерность.
[02:16:33.380 --> 02:16:35.380]  Почему так?
[02:16:35.380 --> 02:16:37.380]  Потому что, ну, иначе
[02:16:37.380 --> 02:16:39.380]  как вы еще решите?
[02:16:39.380 --> 02:16:41.380]  Опять же, судя по тому, что
[02:16:41.380 --> 02:16:43.380]  ребята сейчас с тренировочными вариантами
[02:16:43.380 --> 02:16:45.380]  могут сделать так, что в этом году придется
[02:16:45.380 --> 02:16:47.380]  строить таблицу истины для четырех.
[02:16:47.380 --> 02:16:49.380]  И в целом, когда-то там был один номер,
[02:16:49.380 --> 02:16:51.380]  в котором пришлось строить таблицу истины для
[02:16:51.380 --> 02:16:53.380]  четырех аргументов, и смотреть, что там творится.
[02:16:53.380 --> 02:16:55.380]  А для всех больших там уже
[02:16:55.380 --> 02:16:57.380]  выполняется закономерность.
[02:16:57.380 --> 02:16:59.380]  Поэтому ничего гарантировать не могу.
[02:16:59.380 --> 02:17:01.380]  Поехали, смотрим.
[02:17:01.380 --> 02:17:03.380]  Начинаем прям.
[02:17:03.380 --> 02:17:05.380]  Почему только с трех начинаем?
[02:17:05.380 --> 02:17:07.380]  Почему для, типа, двух не строим,
[02:17:07.380 --> 02:17:09.380]  например?
[02:17:09.380 --> 02:17:11.380]  Прямо от нуля до трех всегда.
[02:17:13.380 --> 02:17:15.380]  Смотрим, вот n равняется 0.
[02:17:15.380 --> 02:17:17.380]  Что такое функция, когда n равняется 0?
[02:17:17.380 --> 02:17:19.380]  Если иди аргументов,
[02:17:19.380 --> 02:17:21.380]  ровно два нуля.
[02:17:21.380 --> 02:17:23.380]  Ну, понятно, что если у нас n равняется
[02:17:23.380 --> 02:17:25.380]  0.1, у нас, в принципе,
[02:17:25.380 --> 02:17:27.380]  не может быть два нуля, потому что
[02:17:27.380 --> 02:17:29.380]  не наберется по числу.
[02:17:29.380 --> 02:17:31.380]  Тогда эта функция – тождественный 0.
[02:17:31.380 --> 02:17:33.380]  Точности дайте так.
[02:17:33.380 --> 02:17:35.380]  Упор есть 0.
[02:17:35.380 --> 02:17:37.380]  Тогда, что мы знаем про 0?
[02:17:39.380 --> 02:17:41.380]  Дайте две нуля, начать им табличку.
[02:17:43.380 --> 02:17:45.380]  Даже не будем чутить.
[02:17:45.380 --> 02:17:47.380]  Две нуля.
[02:17:47.380 --> 02:17:49.380]  0 очевидно сохраняет единицу.
[02:17:51.380 --> 02:17:53.380]  Очевидно сохраняет 0,
[02:17:53.380 --> 02:17:55.380]  но очевидно не сохраняет единицу.
[02:17:57.380 --> 02:17:59.380]  Дальше.
[02:17:59.380 --> 02:18:01.380]  Дальше.
[02:18:01.380 --> 02:18:03.380]  0 монотонен,
[02:18:03.380 --> 02:18:05.380]  но он всегда константа,
[02:18:05.380 --> 02:18:07.380]  поэтому константа монотонна.
[02:18:07.380 --> 02:18:09.380]  Он линейен,
[02:18:09.380 --> 02:18:11.380]  да.
[02:18:13.380 --> 02:18:15.380]  Он самодвоственен,
[02:18:15.380 --> 02:18:17.380]  конечно же.
[02:18:17.380 --> 02:18:19.380]  А вот самодвоственен, сейчас скажу.
[02:18:25.380 --> 02:18:27.380]  Сейчас.
[02:18:29.380 --> 02:18:31.380]  Так.
[02:18:31.380 --> 02:18:33.380]  Когда один аргумент.
[02:18:33.380 --> 02:18:35.380]  Смотрите, когда 0 аргументов,
[02:18:35.380 --> 02:18:37.380]  у него
[02:18:37.380 --> 02:18:39.380]  он просто дает одно значение.
[02:18:39.380 --> 02:18:41.380]  Поэтому отрицания тех
[02:18:41.380 --> 02:18:43.380]  штук, их просто нет,
[02:18:43.380 --> 02:18:45.380]  поэтому он будет самодвоственен.
[02:18:47.380 --> 02:18:49.380]  При n равном единице
[02:18:49.380 --> 02:18:51.380]  у нас будет тоже 0.
[02:18:51.380 --> 02:18:53.380]  Он точно так же будет
[02:18:53.380 --> 02:18:55.380]  по 0, отсутствие по 1,
[02:18:55.380 --> 02:18:57.380]  монотонен, афинин.
[02:18:57.380 --> 02:18:59.380]  И он самодвоственен, конечно же, нет,
[02:18:59.380 --> 02:19:01.380]  потому что 0 и 1
[02:19:01.380 --> 02:19:03.380]  он всегда примет маль.
[02:19:07.380 --> 02:19:09.380]  Смотрим, n равняется 2.
[02:19:09.380 --> 02:19:11.380]  Чартим таблицу истинности.
[02:19:15.380 --> 02:19:17.380]  Когда 2, 0?
[02:19:17.380 --> 02:19:19.380]  2, 0.
[02:19:21.380 --> 02:19:23.380]  Для уже знающих эта штука
[02:19:23.380 --> 02:19:25.380]  называется стрелка пирса.
[02:19:27.380 --> 02:19:29.380]  Стрелка пирса
[02:19:29.380 --> 02:19:31.380]  она является
[02:19:31.380 --> 02:19:33.380]  булил функцией.
[02:19:33.380 --> 02:19:35.380]  Класс булил функции,
[02:19:35.380 --> 02:19:37.380]  состоящий из одной стрелки пирса,
[02:19:37.380 --> 02:19:39.380]  он у нас полный, а значит,
[02:19:39.380 --> 02:19:41.380]  она не лежит ни в одном.
[02:19:43.380 --> 02:19:45.380]  Извините, можно очень быстро учить?
[02:19:45.380 --> 02:19:47.380]  А для n равного 1,
[02:19:47.380 --> 02:19:49.380]  почему мы сказали, что там
[02:19:49.380 --> 02:19:51.380]  равно 2, 0?
[02:19:51.380 --> 02:19:53.380]  Это, типа, чтобы exec2n
[02:19:53.380 --> 02:19:55.380]  было верно?
[02:19:55.380 --> 02:19:57.380]  Смотри, n равна 1,
[02:19:57.380 --> 02:19:59.380]  когда среди аргументов ровно 2, 0.
[02:19:59.380 --> 02:20:01.380]  Когда n равняется 1, у нас, в принципе,
[02:20:01.380 --> 02:20:03.380]  не может быть 2, 0, значит, у нас всегда 0.
[02:20:03.380 --> 02:20:05.380]  Поэтому торжественный 0.
[02:20:05.380 --> 02:20:07.380]  Торжественный 0 он всегда
[02:20:07.380 --> 02:20:09.380]  не сохраняет 0, не сохраняет 1,
[02:20:09.380 --> 02:20:11.380]  монотонен, афинин, а самодвоственен
[02:20:11.380 --> 02:20:13.380]  он будет при 0 аргументов,
[02:20:13.380 --> 02:20:15.380]  а при всех остальных он не самодвоственен.
[02:20:21.380 --> 02:20:23.380]  Не понимаю определение,
[02:20:23.380 --> 02:20:25.380]  она верна, если среди аргументов
[02:20:25.380 --> 02:20:27.380]  ровно 2, 0, но
[02:20:27.380 --> 02:20:29.380]  почему мы строим, типа,
[02:20:29.380 --> 02:20:31.380]  именно для тех случаев, когда она верна?
[02:20:33.380 --> 02:20:35.380]  Не понял.
[02:20:35.380 --> 02:20:37.380]  Ну, я имею в виду,
[02:20:37.380 --> 02:20:39.380]  почему не может быть другая таблица истинности?
[02:20:41.380 --> 02:20:43.380]  Ну, потому что мы просто вычислили,
[02:20:43.380 --> 02:20:45.380]  ну, вот мы взяли количество аргументов 1,
[02:20:45.380 --> 02:20:47.380]  вычислили на каждом наборе аргументов
[02:20:47.380 --> 02:20:49.380]  значение этой функции, все.
[02:20:49.380 --> 02:20:51.380]  А, все, блин, понял.
[02:20:53.380 --> 02:20:55.380]  Ну, просто вычислили
[02:20:55.380 --> 02:20:57.380]  самую эту функцию.
[02:21:01.380 --> 02:21:03.380]  Если вы не помните свойства
[02:21:03.380 --> 02:21:05.380]  про...
[02:21:05.380 --> 02:21:07.380]  О, что-то мы лагаем вообще.
[02:21:07.380 --> 02:21:09.380]  Если вы не помните свойства про стрелку перса,
[02:21:09.380 --> 02:21:11.380]  то прям можно подобреться истинности.
[02:21:11.380 --> 02:21:13.380]  0 не сохранились, 1 не сохранились,
[02:21:13.380 --> 02:21:15.380]  монотонность очевидно не
[02:21:15.380 --> 02:21:17.380]  сохранилась, афининность
[02:21:17.380 --> 02:21:19.380]  почему? Потому что у нас всего нечетное число.
[02:21:19.380 --> 02:21:21.380]  Единиц в наборе,
[02:21:21.380 --> 02:21:23.380]  сама двойственность тоже не сохранилась.
[02:21:25.380 --> 02:21:27.380]  Все.
[02:21:27.380 --> 02:21:29.380]  Дальше живем.
[02:21:29.380 --> 02:21:31.380]  N равняется 3.
[02:21:35.380 --> 02:21:37.380]  N равняется 3, у нас...
[02:21:39.380 --> 02:21:41.380]  0, 0, 0, 1, 1, 1, 1,
[02:21:41.380 --> 02:21:43.380]  0, 0, 1, 1, 1, 0, 0, 1, 1, 1,
[02:21:43.380 --> 02:21:45.380]  0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
[02:21:45.380 --> 02:21:47.380]  0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1
[02:21:48.380 --> 02:21:50.380]  Этот номер самый неприятный,
[02:21:50.380 --> 02:21:52.380]  оставляйте его в конец, потому что
[02:21:52.380 --> 02:21:54.380]  у него больше всего делать, и прикол в том,
[02:21:54.380 --> 02:21:56.380]  что если вы не докажете
[02:21:56.380 --> 02:21:57.380]  хоть одну...
[02:21:57.380 --> 02:21:59.380]  Короче, если вы докажете про 0,
[02:21:59.380 --> 02:22:01.380]  про один, про монотонность,
[02:22:01.380 --> 02:22:02.380]  самодольность и провиневность нет,
[02:22:02.380 --> 02:22:04.380]  у вас 0 задачу.
[02:22:04.380 --> 02:22:06.380]  Очень неблагодарно, оставляем венец.
[02:22:07.380 --> 02:22:09.380]  Нам нужен 2 нуля.
[02:22:10.380 --> 02:22:12.380]  Вот, естественныйitations.
[02:22:15.380 --> 02:22:33.380]  она сохраняет ноль, не сохраняет единицу, она не монотонна, будет ли она аффинна,
[02:22:33.380 --> 02:22:38.380]  ну смотрите, всего у нас 3 таких штук, значит войдет MonomTot, поэтому она не аффинна,
[02:22:38.380 --> 02:22:40.380]  самодовольственная ли она?
[02:22:40.380 --> 02:22:42.380]  в порядке
[02:22:42.380 --> 02:22:46.380]  не самодовольственная, смотри, в момент больше равняется ли 4
[02:22:46.380 --> 02:22:56.380]  f на всех нулях будет равна чему? нулю, потому что количество нулей больше 2
[02:22:56.380 --> 02:23:00.380]  поэтому она по 0
[02:23:00.380 --> 02:23:06.380]  f на всех единицах равняется нулю, потому что здесь нулей равняется нулю
[02:23:06.380 --> 02:23:15.380]  хорошо, так как мы видим здесь и здесь ноль, то следовательно она не самодовольственная
[02:23:15.380 --> 02:23:20.380]  можно еще раз сказать, как мы довольно быстро понимаем, что функция не аффинна?
[02:23:20.380 --> 02:23:31.380]  считаем количество единиц, которое принимает функция, если не четно, то она будет содержать Monom
[02:23:31.380 --> 02:23:41.380]  из всех вот этих вот штук, из всех аргументов, он будет в степени больше, чем один, значит она не линейна
[02:23:42.380 --> 02:23:49.380]  ну это же недостаточное условие, то есть если бы у нас совпало, что она единичка, то нам пришлось бы
[02:23:49.380 --> 02:23:54.380]  для каждого проверять Monom, ну для каждого набора нуль единичек
[02:23:54.380 --> 02:23:56.380]  ну смотри
[02:23:56.380 --> 02:24:00.380]  ну в общем случае, да?
[02:24:00.380 --> 02:24:06.380]  ну как правило, в общем, по вариантам прошлых ряд, я очень надеюсь, что сохраняю традицию, что
[02:24:06.380 --> 02:24:08.380]  как правило, всегда не линейна
[02:24:08.380 --> 02:24:13.380]  и все это можно легко доказать, просто показав, что функция принимает нечетное число единиц
[02:24:18.380 --> 02:24:28.380]  а зачем мы отдельно 5 трех аргументов рассматривали, а потом для всего больше трех, мы не могли просто для всего больше еще 3?
[02:24:28.380 --> 02:24:30.380]  могли
[02:24:30.380 --> 02:24:35.380]  просто потому что начертили еще раз 3, еще раз поняли, что творится
[02:24:35.380 --> 02:24:41.380]  мы поняли, что больше трех, вот например нули у нас будет сверху снизу, поэтому у нас сразу по ноль не по 1 и не D
[02:24:41.380 --> 02:24:47.380]  а остальное, ну сейчас будем смотреть, ну понимаем, что вот где-то здесь мы заметили закономерность
[02:24:47.380 --> 02:24:57.380]  как нам получать набор, который сломает нам монотонность
[02:24:57.380 --> 02:25:02.380]  и аффинность нужно будет смотреть
[02:25:03.380 --> 02:25:09.380]  на счет аффинности в обратную сторону работает, если четное число единиц, то она обязательно аффинна?
[02:25:09.380 --> 02:25:10.380]  нет
[02:25:10.380 --> 02:25:11.380]  ну вот
[02:25:11.380 --> 02:25:13.380]  мы говорили, что это необходимо, но недостаточное
[02:25:13.380 --> 02:25:16.380]  ну да, хорошо, я это так просто в всякий случай
[02:25:16.380 --> 02:25:22.380]  поэтому если так получилось, что у вас не работает эта штука, как может сработать?
[02:25:22.380 --> 02:25:24.380]  может сработать метод суммирования
[02:25:24.380 --> 02:25:29.380]  метод суммирования говорит нам о чем, о том, что если вот здесь вот было в начале
[02:25:29.380 --> 02:25:37.380]  обычной такой строчки, если у нас здесь было нечетное число единиц, вот среди первых четырех
[02:25:37.380 --> 02:25:42.380]  то вот на этом мономе она будет принимать значение единицы
[02:25:42.380 --> 02:25:47.380]  будет это на моном войдет, вот например 0.1.1
[02:25:47.380 --> 02:25:50.380]  сейчас скажу
[02:25:50.380 --> 02:25:53.380]  в таком случае вот как раз работает, когда
[02:25:53.380 --> 02:25:56.380]  когда у нас 0, там 0, дальше 1
[02:25:56.380 --> 02:26:00.380]  0, дальше 1, 0, 1, 0
[02:26:00.380 --> 02:26:02.380]  здесь возможно где-то нулевое число нулей
[02:26:02.380 --> 02:26:05.380]  вот такой набор берем
[02:26:05.380 --> 02:26:12.380]  дальше смотрим какие функции примет значение на таких наборах
[02:26:19.380 --> 02:26:22.380]  и тогда для вот этой вот штуки
[02:26:22.380 --> 02:26:29.380]  коэффициент при соответствующем мономе будет просто к сору всех этих значений
[02:26:29.380 --> 02:26:32.380]  по методу суммирования
[02:26:36.380 --> 02:26:41.380]  то есть если здесь где-то встретилось только нечетное число единиц
[02:26:41.380 --> 02:26:44.380]  соответственно мы получили плохой моном
[02:26:44.380 --> 02:26:47.380]  она не линейная, это вот второй вариант как может использоваться
[02:26:52.380 --> 02:26:58.380]  а можете еще раз объяснить как мы вот по линейности поняли когда у нас просто больше четырех
[02:26:58.380 --> 02:27:01.380]  как мы выявили значение
[02:27:01.380 --> 02:27:04.380]  здесь мы очень быстро поняли
[02:27:04.380 --> 02:27:09.380]  просто сколько всего единиц в наборе значений f
[02:27:09.380 --> 02:27:12.380]  их три штуки
[02:27:12.380 --> 02:27:16.380]  да, но а вот когда мы говорим больше или равно четырем
[02:27:16.380 --> 02:27:19.380]  мы же пока еще ничего не сказали
[02:27:20.380 --> 02:27:23.380]  пока вообще ничего не сказали
[02:27:23.380 --> 02:27:26.380]  мы знаем пока про p0, p1 и про d
[02:27:26.380 --> 02:27:29.380]  вот теперь про монотонность мы поняли вот из этого набора
[02:27:29.380 --> 02:27:31.380]  извините, можно уточнить?
[02:27:31.380 --> 02:27:33.380]  да
[02:27:33.380 --> 02:27:39.380]  сейчас вот последнее что вы сказали как понять что функция является
[02:27:39.380 --> 02:27:44.380]  короче является она линейной или нет
[02:27:44.380 --> 02:27:49.380]  если у нас просто по четности количества единиц нельзя сказать
[02:27:49.380 --> 02:27:53.380]  то есть я вот этот шок не помню где мы сказали что
[02:27:53.380 --> 02:27:55.380]  ну вот то что вы красным нарисовали
[02:27:55.380 --> 02:27:57.380]  ну давай еще раз расскажу
[02:27:57.380 --> 02:28:01.380]  в общем если тогда не так
[02:28:01.380 --> 02:28:05.380]  то ну во-первых первое замечание
[02:28:05.380 --> 02:28:09.380]  я пока не видел в принципе вариантов которые
[02:28:09.380 --> 02:28:11.380]  в больших случаях она была линейной
[02:28:11.380 --> 02:28:15.380]  всегда была нелинейность потому что нелинейность мы можем доказать
[02:28:15.380 --> 02:28:20.380]  а доказать линейность это что-то очень сложное
[02:28:20.380 --> 02:28:22.380]  и вряд ли вас будут просить на контрольный
[02:28:22.380 --> 02:28:26.380]  нет, я понимаю, но я имею в виду доказать нелинейность
[02:28:26.380 --> 02:28:28.380]  если у нас мы его не можем доказать
[02:28:28.380 --> 02:28:31.380]  просто исходя из того что у нас нечетный единичек
[02:28:31.380 --> 02:28:34.380]  тогда мы пытаемся найти вот такую комбинашку
[02:28:34.380 --> 02:28:38.380]  выбираем две координаты когда они равняются единице
[02:28:38.380 --> 02:28:42.380]  дальше смотрим значение функ
[02:28:42.380 --> 02:28:46.380]  на ней на наборе в котором только одна единица есть вторая ноль
[02:28:46.380 --> 02:28:48.380]  на котором другая единица и другая ноль
[02:28:48.380 --> 02:28:50.380]  и на наборе всех нулей
[02:28:50.380 --> 02:28:56.380]  тогда коэффициент при соответствующем маноме
[02:28:56.380 --> 02:28:58.380]  то есть если это it это yt
[02:28:58.380 --> 02:29:00.380]  то есть x it и x yt
[02:29:00.380 --> 02:29:04.380]  коэффициент при ней есть сор четырех этих значений
[02:29:04.380 --> 02:29:06.380]  если у нас получилось так что
[02:29:06.380 --> 02:29:08.380]  среди этих значений ровно нечетный число единиц
[02:29:08.380 --> 02:29:10.380]  то значит у нас войдет такой маном
[02:29:10.380 --> 02:29:12.380]  значит у нас все испортилось
[02:29:14.380 --> 02:29:16.380]  а почему это должно работать?
[02:29:16.380 --> 02:29:20.380]  потому что по методу суммирования
[02:29:26.380 --> 02:29:28.380]  прям просто пишете по методу суммирования
[02:29:28.380 --> 02:29:30.380]  достаточно обоснований
[02:29:30.380 --> 02:29:32.380]  потому что в методе суммирования
[02:29:32.380 --> 02:29:34.380]  как мы работали?
[02:29:34.380 --> 02:29:38.380]  мы брали просто все меньшие наборы
[02:29:38.380 --> 02:29:40.380]  помните свойства
[02:29:46.380 --> 02:29:48.380]  теперь я понял в чем суть
[02:29:48.380 --> 02:29:50.380]  по методу суммирования
[02:29:50.380 --> 02:29:54.380]  то есть на самом деле нам метод суммирования нужен
[02:29:54.380 --> 02:29:56.380]  больше не для того чтобы находить пыльную обжигалки
[02:29:56.380 --> 02:30:00.380]  надо оказывать нелинейность функций
[02:30:00.380 --> 02:30:02.380]  в этом вопрос
[02:30:02.380 --> 02:30:04.380]  ему нужно делать поэтому достаточно внимания
[02:30:08.380 --> 02:30:10.380]  почему эта функция при n больше 4 не равняет 7?
[02:30:10.380 --> 02:30:12.380]  смотрите какая штука я заметил
[02:30:12.380 --> 02:30:14.380]  что если я по краям поставлю 0
[02:30:14.380 --> 02:30:16.380]  то у меня функция будет равнять единице
[02:30:16.380 --> 02:30:18.380]  а если я возьму потом
[02:30:18.380 --> 02:30:20.380]  самую последнюю сделаю единицей
[02:30:20.380 --> 02:30:22.380]  то у меня останется 0
[02:30:22.380 --> 02:30:24.380]  и это нарушит монотонность
[02:30:24.380 --> 02:30:26.380]  обобщил на большей размерности
[02:30:26.380 --> 02:30:28.380]  получил не монотонность
[02:30:28.380 --> 02:30:30.380]  просто беру по краям 0 все остальные единицы
[02:30:30.380 --> 02:30:32.380]  тогда у меня ровно два нуля
[02:30:32.380 --> 02:30:34.380]  поэтому функция принимает значение 1
[02:30:34.380 --> 02:30:36.380]  если я сделаю только первый 0
[02:30:36.380 --> 02:30:38.380]  этот набор больше его
[02:30:38.380 --> 02:30:40.380]  но функция принимает значение меньше
[02:30:40.380 --> 02:30:42.380]  следовательно не монотонно
[02:30:42.380 --> 02:30:44.380]  подождите
[02:30:44.380 --> 02:30:46.380]  а если мы возьмем просто первый и последний
[02:30:46.380 --> 02:30:48.380]  там же у нас оба нуля
[02:30:48.380 --> 02:30:50.380]  разве из этого не следует
[02:30:50.380 --> 02:30:52.380]  то что не монотонно?
[02:30:52.380 --> 02:30:54.380]  нет, не следует
[02:30:54.380 --> 02:30:56.380]  не понял
[02:30:56.380 --> 02:30:58.380]  монотонно это если у тебя есть
[02:30:58.380 --> 02:31:00.380]  два набора
[02:31:00.380 --> 02:31:02.380]  один больше другого
[02:31:02.380 --> 02:31:04.380]  но функция приняла значение меньше
[02:31:04.380 --> 02:31:06.380]  везде струйки
[02:31:06.380 --> 02:31:08.380]  я понял
[02:31:08.380 --> 02:31:10.380]  не строгая
[02:31:10.380 --> 02:31:12.380]  хорошо
[02:31:12.380 --> 02:31:14.380]  остался вопрос
[02:31:14.380 --> 02:31:16.380]  про линейность
[02:31:16.380 --> 02:31:18.380]  во-первых
[02:31:18.380 --> 02:31:20.380]  давайте заметим
[02:31:20.380 --> 02:31:22.380]  сколько у нас
[02:31:22.380 --> 02:31:24.380]  значений единиц
[02:31:24.380 --> 02:31:26.380]  количество единиц у нас ровно столько
[02:31:26.380 --> 02:31:28.380]  сколько
[02:31:28.380 --> 02:31:30.380]  из способов расставить два нуля
[02:31:30.380 --> 02:31:32.380]  по компоненте z
[02:31:36.380 --> 02:31:38.380]  поэтому
[02:31:38.380 --> 02:31:40.380]  давайте делать как
[02:31:50.380 --> 02:31:52.380]  сейчас
[02:31:52.380 --> 02:31:54.380]  подумаю
[02:31:54.380 --> 02:31:56.380]  сейчас подумаю
[02:31:56.380 --> 02:31:58.380]  один момент
[02:32:00.380 --> 02:32:02.380]  в общем первый вариант
[02:32:02.380 --> 02:32:04.380]  мы можем посчитать сколько таких
[02:32:04.380 --> 02:32:06.380]  наборов
[02:32:06.380 --> 02:32:08.380]  это будет c из
[02:32:08.380 --> 02:32:10.380]  n по
[02:32:10.380 --> 02:32:12.380]  сколько
[02:32:12.380 --> 02:32:14.380]  по два
[02:32:16.380 --> 02:32:18.380]  количество
[02:32:20.380 --> 02:32:22.380]  это
[02:32:26.380 --> 02:32:28.380]  это у нас что?
[02:32:28.380 --> 02:32:30.380]  это n факториал
[02:32:30.380 --> 02:32:32.380]  на 2 факториал
[02:32:32.380 --> 02:32:34.380]  на n минус 2 факториал
[02:32:36.380 --> 02:32:38.380]  равняется n
[02:32:38.380 --> 02:32:40.380]  на n минус 1 на 2
[02:32:44.380 --> 02:32:46.380]  ну в общем как мы понимаем что
[02:32:46.380 --> 02:32:48.380]  здесь например будет что?
[02:32:48.380 --> 02:32:50.380]  равняется 4
[02:32:50.380 --> 02:32:52.380]  если 1 кратно 4
[02:32:52.380 --> 02:32:54.380]  то у нас все плохо и может
[02:32:54.380 --> 02:32:56.380]  получиться четное число
[02:32:56.380 --> 02:32:58.380]  значений единиц
[02:32:58.380 --> 02:33:00.380]  поэтому не сработало
[02:33:00.380 --> 02:33:02.380]  давайте такой способ не работает
[02:33:02.380 --> 02:33:04.380]  значит мы действуем
[02:33:04.380 --> 02:33:06.380]  по этому методу
[02:33:06.380 --> 02:33:08.380]  подбираем такой набор
[02:33:08.380 --> 02:33:10.380]  чтобы было количество единиц
[02:33:10.380 --> 02:33:12.380]  нечетно на нем
[02:33:12.380 --> 02:33:14.380]  под набор
[02:33:14.380 --> 02:33:16.380]  я предлагаю поступить следующим образом
[02:33:16.380 --> 02:33:18.380]  давайте рассмотрим набор
[02:33:18.380 --> 02:33:20.380]  0011
[02:33:24.380 --> 02:33:26.380]  функция на нем
[02:33:26.380 --> 02:33:28.380]  принимает значение 1
[02:33:30.380 --> 02:33:32.380]  все наборы меньше него содержат
[02:33:32.380 --> 02:33:34.380]  нулей больше
[02:33:46.380 --> 02:33:48.380]  0
[02:33:50.380 --> 02:33:52.380]  значит функция
[02:33:52.380 --> 02:33:54.380]  равняется 0
[02:33:54.380 --> 02:33:56.380]  тогда здесь будут
[02:33:56.380 --> 02:33:58.380]  нули
[02:34:00.380 --> 02:34:02.380]  не здесь
[02:34:02.380 --> 02:34:04.380]  тогда все оставшиеся
[02:34:04.380 --> 02:34:06.380]  ксоры по методу суммирования
[02:34:06.380 --> 02:34:08.380]  это будут 0
[02:34:12.380 --> 02:34:14.380]  единиц здесь сколько?
[02:34:14.380 --> 02:34:16.380]  ровно 1
[02:34:16.380 --> 02:34:18.380]  следовательно
[02:34:18.380 --> 02:34:20.380]  монум какой?
[02:34:20.380 --> 02:34:22.380]  x3 и т.д.
[02:34:22.380 --> 02:34:24.380]  xn войдет
[02:34:24.380 --> 02:34:26.380]  смотрим
[02:34:26.380 --> 02:34:28.380]  сколько всего переменных
[02:34:28.380 --> 02:34:30.380]  среди x3 и xn
[02:34:30.380 --> 02:34:32.380]  так как n больше равно 4
[02:34:32.380 --> 02:34:34.380]  то
[02:34:34.380 --> 02:34:36.380]  степень больше либо равна 2
[02:34:36.380 --> 02:34:38.380]  следовательно
[02:34:38.380 --> 02:34:40.380]  не афиген
[02:34:40.380 --> 02:34:42.380]  вот именно поэтому рассматриваем
[02:34:42.380 --> 02:34:44.380]  с 3
[02:34:44.380 --> 02:34:46.380]  этот метод нам бы дал
[02:34:46.380 --> 02:34:48.380]  капель
[02:34:54.380 --> 02:34:56.380]  а можете еще раз повторить
[02:34:56.380 --> 02:34:58.380]  осуждение?
[02:34:58.380 --> 02:35:00.380]  первое что мы попробовали сделать
[02:35:00.380 --> 02:35:02.380]  давайте посчитаем сколько
[02:35:02.380 --> 02:35:04.380]  таких штук
[02:35:04.380 --> 02:35:06.380]  я понял
[02:35:06.380 --> 02:35:08.380]  что это просто способ
[02:35:08.380 --> 02:35:10.380]  расставить 2 нуля по n координатам
[02:35:10.380 --> 02:35:12.380]  это c с n по 2
[02:35:12.380 --> 02:35:14.380]  c с n по 2 это n факториал
[02:35:14.380 --> 02:35:16.380]  делить на 2 факториал делить на n-2 факториал
[02:35:16.380 --> 02:35:18.380]  то есть n-1 на 2
[02:35:18.380 --> 02:35:20.380]  вот если я возьму n кратную 4
[02:35:20.380 --> 02:35:22.380]  то очевидно у меня здесь получится четно
[02:35:22.380 --> 02:35:24.380]  значит
[02:35:24.380 --> 02:35:26.380]  идея с необходимым условием
[02:35:26.380 --> 02:35:28.380]  про количество
[02:35:28.380 --> 02:35:30.380]  про четность количества единиц
[02:35:30.380 --> 02:35:32.380]  принимаем у f не работает
[02:35:32.380 --> 02:35:34.380]  следовательно единственный способ показать нелинейность
[02:35:34.380 --> 02:35:36.380]  это искать такой набор
[02:35:40.380 --> 02:35:42.380]  первый случай
[02:35:42.380 --> 02:35:44.380]  когда мы искали набор
[02:35:44.380 --> 02:35:46.380]  там было 2 мы брали единицы
[02:35:46.380 --> 02:35:48.380]  чтобы было нечетно
[02:35:48.380 --> 02:35:50.380]  здесь нам придется взять больше
[02:35:50.380 --> 02:35:52.380]  я хочу взять
[02:35:52.380 --> 02:35:54.380]  первый такой набор
[02:35:54.380 --> 02:35:56.380]  на котором я получу 1
[02:35:56.380 --> 02:35:58.380]  чтобы меньше его все возможные наборы были 0
[02:35:58.380 --> 02:36:00.380]  тогда у меня всего единица 1
[02:36:00.380 --> 02:36:02.380]  значит
[02:36:02.380 --> 02:36:04.380]  я возьму такой
[02:36:04.380 --> 02:36:06.380]  моном
[02:36:06.380 --> 02:36:08.380]  состав пыльного жигалкина
[02:36:08.380 --> 02:36:10.380]  давайте я взял такой набор
[02:36:10.380 --> 02:36:12.380]  это 0,0 а все остальные единицы
[02:36:12.380 --> 02:36:14.380]  все наборы меньше
[02:36:14.380 --> 02:36:16.380]  его будут содержать
[02:36:16.380 --> 02:36:18.380]  хотя бы
[02:36:18.380 --> 02:36:20.380]  3 нуля
[02:36:20.380 --> 02:36:22.380]  потому что мне придется какой-то из единиц превратить в 0
[02:36:22.380 --> 02:36:24.380]  чтобы сделать меньше
[02:36:24.380 --> 02:36:26.380]  тогда у меня нулей будет хотя бы 3
[02:36:26.380 --> 02:36:28.380]  значит функция
[02:36:28.380 --> 02:36:30.380]  примет значение 0
[02:36:30.380 --> 02:36:32.380]  значит на всех наборах меньше него функция принимает значение 0
[02:36:32.380 --> 02:36:34.380]  тогда по методу суммирования
[02:36:34.380 --> 02:36:36.380]  коэффициент при
[02:36:36.380 --> 02:36:38.380]  мономе x3
[02:36:38.380 --> 02:36:40.380]  и так далее xn
[02:36:40.380 --> 02:36:42.380]  будет 1, 40
[02:36:42.380 --> 02:36:44.380]  и так далее 0 то есть 1
[02:36:44.380 --> 02:36:46.380]  значит
[02:36:46.380 --> 02:36:48.380]  этот моном
[02:36:48.380 --> 02:36:50.380]  войдет в пыльном жигалкина
[02:36:52.380 --> 02:36:54.380]  смотрим какая степень этого монова
[02:36:54.380 --> 02:36:56.380]  так как n больше 4
[02:36:56.380 --> 02:36:58.380]  то переменных там хотя бы 2
[02:36:58.380 --> 02:37:00.380]  значит степень больше равна 2
[02:37:00.380 --> 02:37:02.380]  тогда мы
[02:37:02.380 --> 02:37:04.380]  получили нелинейный моном
[02:37:04.380 --> 02:37:06.380]  в пыльном жигалкина
[02:37:06.380 --> 02:37:08.380]  откуда получили отсутствие афинности
[02:37:20.380 --> 02:37:22.380]  понятно не очень
[02:37:26.380 --> 02:37:28.380]  давайте пока другой скопируем
[02:37:34.380 --> 02:37:36.380]  давайте еще раз это рассуждение
[02:37:36.380 --> 02:37:38.380]  которое было для
[02:37:38.380 --> 02:37:40.380]  случая n больше 4
[02:37:40.380 --> 02:37:42.380]  окей
[02:37:46.380 --> 02:37:48.380]  следующая задача будет куда проще
[02:37:48.380 --> 02:37:50.380]  это кое-что самое интересное
[02:37:50.380 --> 02:37:52.380]  можно начнить
[02:37:52.380 --> 02:37:54.380]  мы получается
[02:37:54.380 --> 02:37:56.380]  а
[02:37:56.380 --> 02:37:58.380]  это
[02:37:58.380 --> 02:38:00.380]  это
[02:38:00.380 --> 02:38:02.380]  это
[02:38:02.380 --> 02:38:04.380]  а
[02:38:04.380 --> 02:38:06.380]  да да да все
[02:38:06.380 --> 02:38:08.380]  я просто сначала подумал что мы
[02:38:08.380 --> 02:38:10.380]  в общем да
[02:38:10.380 --> 02:38:12.380]  давайте еще раз идея
[02:38:16.380 --> 02:38:18.380]  она такая что берем
[02:38:18.380 --> 02:38:20.380]  и ищем набор
[02:38:20.380 --> 02:38:22.380]  первый набор на котором
[02:38:22.380 --> 02:38:24.380]  функция примет значение 1
[02:38:26.380 --> 02:38:28.380]  тогда мы точно знаем что если это
[02:38:28.380 --> 02:38:30.380]  первый набор то набора всех предыдущих
[02:38:30.380 --> 02:38:32.380]  значений 0
[02:38:32.380 --> 02:38:34.380]  значит
[02:38:34.380 --> 02:38:36.380]  тогда
[02:38:36.380 --> 02:38:38.380]  коэффициент
[02:38:38.380 --> 02:38:40.380]  при соответствующем мономе
[02:38:40.380 --> 02:38:42.380]  это все я понял да да но это все понятно
[02:38:42.380 --> 02:38:44.380]  все вот я отыскал его
[02:38:44.380 --> 02:38:46.380]  0 0 и 1 дальше все
[02:38:46.380 --> 02:38:48.380]  и супер я смотрю что
[02:38:48.380 --> 02:38:50.380]  действительно такой моном хорош
[02:38:50.380 --> 02:38:52.380]  потому что он содержит хотя бы две переменные
[02:38:56.380 --> 02:38:58.380]  поэтому мы потеряли линейность
[02:38:58.380 --> 02:39:00.380]  и у меня больше равных 4
[02:39:08.380 --> 02:39:10.380]  ну давайте пока вот вы над этим
[02:39:10.380 --> 02:39:12.380]  может подумать сейчас пока в голове переварится
[02:39:12.380 --> 02:39:14.380]  мы решим более простую задачу такую
[02:39:14.380 --> 02:39:16.380]  релакс для мозга максимально
[02:39:20.380 --> 02:39:22.380]  короче задача заключается в том
[02:39:22.380 --> 02:39:24.380]  чтобы построить две таблицы
[02:39:24.380 --> 02:39:26.380]  еще табличку критерия пост
[02:39:26.380 --> 02:39:28.380]  на этом достаточно
[02:39:30.380 --> 02:39:32.380]  строим для
[02:39:32.380 --> 02:39:34.380]  мажорити
[02:39:34.380 --> 02:39:36.380]  0 0 0
[02:39:36.380 --> 02:39:38.380]  1 1 1 1
[02:39:38.380 --> 02:39:40.380]  0 0 1 1
[02:39:40.380 --> 02:39:42.380]  0 0 1 1
[02:39:42.380 --> 02:39:44.380]  0 1
[02:39:44.380 --> 02:39:46.380]  0 1 0 1 0 1
[02:39:50.380 --> 02:39:52.380]  поехали у нас есть
[02:39:52.380 --> 02:39:54.380]  мажорити
[02:39:54.380 --> 02:39:56.380]  есть одада
[02:39:58.380 --> 02:40:00.380]  одада это же не четкость
[02:40:00.380 --> 02:40:02.380]  именно это четкость
[02:40:02.380 --> 02:40:04.380]  мажорити
[02:40:04.380 --> 02:40:06.380]  просто 0 0
[02:40:06.380 --> 02:40:08.380]  0 1 0 1
[02:40:08.380 --> 02:40:10.380]  1 1 1
[02:40:10.380 --> 02:40:12.380]  0 1 1
[02:40:12.380 --> 02:40:14.380]  0 1 0 0
[02:40:14.380 --> 02:40:16.380]  1
[02:40:16.380 --> 02:40:18.380]  0 1
[02:40:18.380 --> 02:40:20.380]  ну блин
[02:40:20.380 --> 02:40:22.380]  понятно как они
[02:40:22.380 --> 02:40:24.380]  себя ведут
[02:40:28.380 --> 02:40:30.380]  п 0
[02:40:30.380 --> 02:40:32.380]  п 1
[02:40:32.380 --> 02:40:34.380]  соудол
[02:40:34.380 --> 02:40:36.380]  монотенософем
[02:40:38.380 --> 02:40:40.380]  чертим вот такую табличку
[02:40:40.380 --> 02:40:42.380]  0 1
[02:40:42.380 --> 02:40:44.380]  мажорити
[02:40:44.380 --> 02:40:46.380]  одада
[02:40:46.380 --> 02:40:48.380]  поехали давайте заполнять про
[02:40:48.380 --> 02:40:50.380]  мажорити
[02:40:50.380 --> 02:40:52.380]  сохраняет 0
[02:40:52.380 --> 02:40:54.380]  сохраняет 1
[02:40:54.380 --> 02:40:56.380]  короче
[02:40:56.380 --> 02:40:58.380]  самодвоственная
[02:40:58.380 --> 02:41:00.380]  ряна
[02:41:00.380 --> 02:41:02.380]  все наборы симметричные
[02:41:02.380 --> 02:41:04.380]  имеют предположение
[02:41:04.380 --> 02:41:06.380]  монотонная
[02:41:06.380 --> 02:41:08.380]  ли она
[02:41:08.380 --> 02:41:10.380]  да
[02:41:10.380 --> 02:41:12.380]  афинная
[02:41:12.380 --> 02:41:14.380]  ряна
[02:41:14.380 --> 02:41:16.380]  нет почему не афинная
[02:41:16.380 --> 02:41:18.380]  вот такую штучку берем
[02:41:18.380 --> 02:41:20.380]  опять же идея с тем что берем
[02:41:20.380 --> 02:41:22.380]  первый набор
[02:41:22.380 --> 02:41:24.380]  на котором функция приняла один
[02:41:24.380 --> 02:41:26.380]  работает
[02:41:26.380 --> 02:41:28.380]  это набор с двумя переменными
[02:41:28.380 --> 02:41:30.380]  поэтому
[02:41:30.380 --> 02:41:32.380]  соответствующим оно войдет
[02:41:32.380 --> 02:41:34.380]  и она будет нелинейной
[02:41:34.380 --> 02:41:36.380]  потеряли афинность
[02:41:36.380 --> 02:41:38.380]  грусть тоска
[02:41:38.380 --> 02:41:40.380]  содом
[02:41:40.380 --> 02:41:42.380]  у нас
[02:41:42.380 --> 02:41:44.380]  п 0 есть, п 1 есть
[02:41:44.380 --> 02:41:46.380]  да есть
[02:41:50.380 --> 02:41:52.380]  монотонность
[02:41:52.380 --> 02:41:54.380]  очень быстро
[02:41:54.380 --> 02:41:56.380]  монотонность для
[02:41:56.380 --> 02:41:58.380]  мажорити как мы быстро проверили
[02:41:58.380 --> 02:42:00.380]  просто
[02:42:00.380 --> 02:42:02.380]  посмотрели на значение
[02:42:02.380 --> 02:42:04.380]  метода пристального взгляда
[02:42:04.380 --> 02:42:06.380]  понятно
[02:42:06.380 --> 02:42:08.380]  вот для
[02:42:08.380 --> 02:42:10.380]  для
[02:42:10.380 --> 02:42:12.380]  ода мы видим что не монотонно
[02:42:12.380 --> 02:42:14.380]  то есть набор 0.1.0
[02:42:14.380 --> 02:42:16.380]  стал 0.1.1 и поменялись на 0
[02:42:16.380 --> 02:42:18.380]  потерялись
[02:42:18.380 --> 02:42:20.380]  ну
[02:42:20.380 --> 02:42:22.380]  так как нас хотят
[02:42:22.380 --> 02:42:24.380]  чтобы это было базисом то
[02:42:26.380 --> 02:42:28.380]  я могу сразу сказать что можно
[02:42:28.380 --> 02:42:30.380]  скипать вот этот вот
[02:42:30.380 --> 02:42:32.380]  проверку на афинность она будет афинной
[02:42:32.380 --> 02:42:34.380]  но
[02:42:34.380 --> 02:42:36.380]  так как от вас просит развернуть
[02:42:36.380 --> 02:42:38.380]  ответ то придется построить
[02:42:38.380 --> 02:42:40.380]  пыльную обжигалку
[02:42:42.380 --> 02:42:44.380]  то есть
[02:42:44.380 --> 02:42:46.380]  здесь как мы ответили почему
[02:42:46.380 --> 02:42:48.380]  не афинно
[02:42:48.380 --> 02:42:50.380]  не афинно потому что вот
[02:42:50.380 --> 02:42:52.380]  рассмотрели первые три у нас
[02:42:52.380 --> 02:42:54.380]  вот такой моном
[02:42:54.380 --> 02:42:56.380]  либо можно
[02:42:56.380 --> 02:42:58.380]  явно построить пыльную обжигалку
[02:42:58.380 --> 02:43:00.380]  но показа еще нет не афинно
[02:43:00.380 --> 02:43:02.380]  поехали строим
[02:43:12.380 --> 02:43:14.380]  ну
[02:43:14.380 --> 02:43:16.380]  короче
[02:43:16.380 --> 02:43:18.380]  заметили что это
[02:43:18.380 --> 02:43:20.380]  это у нас
[02:43:28.380 --> 02:43:30.380]  теперь 0.1
[02:43:30.380 --> 02:43:32.380]  0 сохраняет 0
[02:43:32.380 --> 02:43:34.380]  1 не сохраняет
[02:43:34.380 --> 02:43:36.380]  можно очень быстро вот как мы монотонно
[02:43:36.380 --> 02:43:38.380]  проверили для
[02:43:38.380 --> 02:43:40.380]  от
[02:43:40.380 --> 02:43:42.380]  для от
[02:43:42.380 --> 02:43:44.380]  смотри вот наборчик
[02:43:48.380 --> 02:43:50.380]  все все
[02:43:50.380 --> 02:43:52.380]  то есть монотонно всегда проверяется
[02:43:52.380 --> 02:43:54.380]  методом пристального взгляда
[02:43:54.380 --> 02:43:56.380]  вот про монотонно сейчас
[02:43:56.380 --> 02:43:58.380]  скажу это метод пристального взгляда
[02:43:58.380 --> 02:44:00.380]  всегда
[02:44:02.380 --> 02:44:04.380]  если кто-то знает как
[02:44:04.380 --> 02:44:06.380]  можно делать не метод пристального взгляда
[02:44:06.380 --> 02:44:08.380]  будет круто
[02:44:08.380 --> 02:44:10.380]  х
[02:44:10.380 --> 02:44:12.380]  нет никто не знает если кто-то знает
[02:44:12.380 --> 02:44:14.380]  то вы решаете одну из вот этих проблем математики
[02:44:14.380 --> 02:44:16.380]  там короче
[02:44:16.380 --> 02:44:18.380]  есть
[02:44:18.380 --> 02:44:20.380]  есть функция
[02:44:20.380 --> 02:44:22.380]  не помню как называется
[02:44:22.380 --> 02:44:24.380]  конечно она
[02:44:24.380 --> 02:44:26.380]  равняется количеству монотонных
[02:44:26.380 --> 02:44:28.380]  функций от
[02:44:28.380 --> 02:44:30.380]  n аргументов
[02:44:30.380 --> 02:44:32.380]  булевых и там вот она
[02:44:32.380 --> 02:44:34.380]  очень быстро растет
[02:44:34.380 --> 02:44:36.380]  и ее можно решать только полным перебора
[02:44:36.380 --> 02:44:38.380]  да там что-то кажется
[02:44:38.380 --> 02:44:40.380]  до шести штуков определили
[02:44:40.380 --> 02:44:42.380]  до девяти по-моему
[02:44:42.380 --> 02:44:44.380]  до девяти
[02:44:44.380 --> 02:44:46.380]  уже по-моему до девяти
[02:44:46.380 --> 02:44:48.380]  быстро
[02:44:48.380 --> 02:44:50.380]  в общем 0 1 не самодвоственные
[02:44:50.380 --> 02:44:52.380]  монотонные
[02:44:52.380 --> 02:44:54.380]  да монотонные
[02:44:54.380 --> 02:44:56.380]  потому что константы афинные тоже
[02:44:56.380 --> 02:44:58.380]  потому что константы
[02:44:58.380 --> 02:45:00.380]  заполнили какую-то обличку
[02:45:00.380 --> 02:45:02.380]  теперь что делаем
[02:45:02.380 --> 02:45:04.380]  первое что проверяем то что это базис
[02:45:04.380 --> 02:45:06.380]  проверяется двумя
[02:45:06.380 --> 02:45:08.380]  почему они не самодвоственные
[02:45:08.380 --> 02:45:10.380]  самодвоственные это же получается двойное отрицание
[02:45:10.380 --> 02:45:12.380]  для 0 1
[02:45:12.380 --> 02:45:14.380]  но я возьму набор
[02:45:14.380 --> 02:45:16.380]  допустим
[02:45:16.380 --> 02:45:18.380]  она всегда примет 0
[02:45:18.380 --> 02:45:20.380]  поэтому как бы ты не инвертировал
[02:45:20.380 --> 02:45:22.380]  аргументы она
[02:45:22.380 --> 02:45:24.380]  значение свое не поменяет
[02:45:24.380 --> 02:45:26.380]  логично
[02:45:26.380 --> 02:45:28.380]  поэтому они не самодвоственные
[02:45:28.380 --> 02:45:30.380]  в смысле
[02:45:30.380 --> 02:45:32.380]  самодвоственные это
[02:45:32.380 --> 02:45:34.380]  если мы инвертируем
[02:45:34.380 --> 02:45:36.380]  все аргументы то
[02:45:36.380 --> 02:45:38.380]  значение функции инвертируется
[02:45:40.380 --> 02:45:42.380]  константы не могут
[02:45:42.380 --> 02:45:44.380]  инвертировать свое значение
[02:45:44.380 --> 02:45:46.380]  поэтому если мы инвертируем их
[02:45:46.380 --> 02:45:48.380]  аргументы они не поменяют
[02:45:48.380 --> 02:45:50.380]  соответственно они не самодвоственные
[02:45:50.380 --> 02:45:52.380]  ок понятно
[02:45:52.380 --> 02:45:54.380]  а 0 же не
[02:45:54.380 --> 02:45:56.380]  афинный там же четное
[02:45:56.380 --> 02:45:58.380]  число
[02:45:58.380 --> 02:46:00.380]  единиц
[02:46:00.380 --> 02:46:02.380]  0
[02:46:02.380 --> 02:46:04.380]  длином же галкина 0
[02:46:04.380 --> 02:46:06.380]  насколько я помню считается
[02:46:06.380 --> 02:46:08.380]  просто 0
[02:46:08.380 --> 02:46:10.380]  но там же не выполняется
[02:46:10.380 --> 02:46:12.380]  необходимые условия получается
[02:46:16.380 --> 02:46:18.380]  а не все я понял
[02:46:18.380 --> 02:46:20.380]  да там везде 0
[02:46:20.380 --> 02:46:22.380]  просто у тебя ни один не войдет поэтому
[02:46:22.380 --> 02:46:24.380]  считай просто 0
[02:46:24.380 --> 02:46:26.380]  у тебя коэффициент там либо 0 либо 1
[02:46:26.380 --> 02:46:28.380]  поэтому 0 как бы зашел
[02:46:32.380 --> 02:46:34.380]  супер
[02:46:34.380 --> 02:46:36.380]  да даже и мы можем
[02:46:36.380 --> 02:46:38.380]  как сказать что эти 0 это
[02:46:38.380 --> 02:46:40.380]  1-41 тут все
[02:46:40.380 --> 02:46:42.380]  линейны
[02:46:42.380 --> 02:46:44.380]  так что все супер
[02:46:48.380 --> 02:46:50.380]  в общем первое что мы проверяем
[02:46:50.380 --> 02:46:52.380]  полноту первая полнота
[02:46:54.380 --> 02:46:56.380]  для этого метода пристального
[02:46:56.380 --> 02:46:58.380]  взгляда смотрим что в каждой
[02:46:58.380 --> 02:47:00.380]  колонке у нас есть минус
[02:47:00.380 --> 02:47:02.380]  извините можно для монотонности
[02:47:02.380 --> 02:47:04.380]  спросить если мы возьмем какой-нибудь
[02:47:04.380 --> 02:47:06.380]  набор аргументов где типа
[02:47:06.380 --> 02:47:08.380]  первый набор аргументов будет больше
[02:47:08.380 --> 02:47:10.380]  чем второй и
[02:47:10.380 --> 02:47:12.380]  получится что при первом
[02:47:12.380 --> 02:47:14.380]  наборе аргументов функция будет
[02:47:14.380 --> 02:47:16.380]  все равно меньше или иначе
[02:47:16.380 --> 02:47:18.380]  при втором
[02:47:18.380 --> 02:47:20.380]  это ничего не даст
[02:47:20.380 --> 02:47:22.380]  ты скажешь
[02:47:22.380 --> 02:47:24.380]  просто на этих наборах у тебя функции
[02:47:24.380 --> 02:47:26.380]  монотонно
[02:47:26.380 --> 02:47:28.380]  монотонно ли она на всех
[02:47:28.380 --> 02:47:30.380]  не факт
[02:47:32.380 --> 02:47:34.380]  при линии монотонности
[02:47:34.380 --> 02:47:36.380]  оно же значит что если у нас набор
[02:47:36.380 --> 02:47:38.380]  аргументов меньше чем
[02:47:38.380 --> 02:47:40.380]  второй то при первом она должна быть
[02:47:40.380 --> 02:47:42.380]  меньше или иначе при втором
[02:47:46.380 --> 02:47:48.380]  для любых наборов
[02:47:48.380 --> 02:47:50.380]  ты говоришь что здесь мы можем
[02:47:50.380 --> 02:47:52.380]  взять что первый набор у нас больше
[02:47:52.380 --> 02:47:54.380]  чем второй
[02:47:54.380 --> 02:47:56.380]  значения в первом
[02:47:56.380 --> 02:47:58.380]  все равно меньше
[02:47:58.380 --> 02:47:59.980]  чем значение в втором
[02:48:00.380 --> 02:48:02.380]  это противоречит
[02:48:02.380 --> 02:48:04.380]  пределение допустим мы возьмем
[02:48:04.380 --> 02:48:06.380]  набор первого
[02:48:06.380 --> 02:48:08.380]  один нуль а второй набор
[02:48:08.380 --> 02:48:09.900]  ноль ноль
[02:48:09.900 --> 02:48:11.900]  при том при другом она 배умит
[02:48:11.900 --> 02:48:13.400]  одинаковое значение это
[02:48:13.400 --> 02:48:15.400]  это противоречит потому что первый doesn't have a lot
[02:48:15.400 --> 02:48:17.420]  монотонов ん
[02:48:17.420 --> 02:48:36.380]  видишь мы требуем не строгую монотонность то есть мы говорим то что типа эти условия
[02:48:36.380 --> 02:48:44.980]  равносильно да какие ну то что типа f от первого набора меньше чем f и второго это равносильно
[02:48:44.980 --> 02:48:54.980]  тому что первый набор меньше или равен второго нет мы говорим что если у нас набор один меньше
[02:48:54.980 --> 02:49:00.820]  другого то функция не должна уменьшить свое значение ну обычная монотонность как в школе
[02:49:00.820 --> 02:49:06.620]  окей просто теперь у нас более сложный порядок на аргументах
[02:49:06.620 --> 02:49:16.420]  в общем первая проверяем планту панта проверяется как смотрим что в каждой колонке у нас есть минус
[02:49:16.420 --> 02:49:27.660]  тоже есть все у нас каждой колонке есть минус соответственно у нас вот этот набор не вложен
[02:49:27.660 --> 02:49:39.100]  ни в один из классов следовательно по критерию поста полу все у нас есть полнота теперь нам
[02:49:39.100 --> 02:49:49.260]  нужно сказать что если мы хоть какую-то функцию выкинем то тогда мы потеряем полноту но смотрим
[02:49:49.260 --> 02:49:54.420]  дальше просто прям берете выписываете что если выкидываем 0 то у нас получится вложенность
[02:49:54.480 --> 02:50:03.760]  1 соответственно неполной выкидываем 1 получаем вложенность п10 соответственно
[02:50:03.760 --> 02:50:09.900]  неполной выкидываем мажорите получаем вложенности вов Ridge не полный выкидываем
[02:50:09.900 --> 02:50:16.580]  от получаем вложенности монотонный неполный все проверили полноту проверили что выкинув
[02:50:16.580 --> 02:50:23.140]  какой-то из функций мы потеряем полноту, значит показали, что это базис.
[02:50:46.580 --> 02:51:01.780]  У нас осталась последняя задача. В общем 22 выразите одно через другое.
[02:51:01.780 --> 02:51:14.620]  В общем как работаем мы с этим добром.
[02:51:14.620 --> 02:51:35.660]  Ну отрицание сейчас скажу. Отрицание у нас это мы помним 1 xor p. Поэтому наша задача выразить как
[02:51:36.660 --> 02:51:47.540]  как нам выразить единицу. Ну например по помощи инвекции я могу сказать, что p следует p это единица.
[02:51:47.540 --> 02:51:59.220]  Идея на что я хочу. Я хочу получить этот полином Жигалкина. Для полинома Жигалкина мне вот справа
[02:51:59.220 --> 02:52:04.220]  у меня есть xor, мне не хватает единицы, не хватает конъюнций. Почему я хочу получить полином Жигалкина?
[02:52:04.220 --> 02:52:09.660]  Потому что дальше я могу работать вот чисто с полиномами равенство и как-то упрощать все.
[02:52:09.660 --> 02:52:21.980]  Я выразил единицу, поэтому теперь я могу выразить отрицание. Не p это у нас p следует p xor p.
[02:52:21.980 --> 02:52:39.700]  Как не выразить импликацию? Давайте построим что? Построим полином Жигалкина для или. Это p xor q xor p q.
[02:52:39.700 --> 02:52:51.560]  Почему так? p xor q даст нам равенство на средних наборах, плюс нам нужны равенства на нижнем
[02:52:51.560 --> 02:52:58.240]  наборе. Это пq. То есть мне даже не чувствует. Импликация. Да импликацию уже придется построить.
[02:52:58.240 --> 02:53:08.640]  То есть естественности 1101. Это импликация. Извините, я сейчас. Как вы сразу без типа по
[02:53:08.640 --> 02:53:17.760]  строению поняли какой должен быть многочлен? Ну потому что xor даст нам равенство, даст нам
[02:53:17.760 --> 02:53:24.900]  единички на средних наборах. Нам что было или не хватает единички на нижнем наборе. Для этого это
[02:53:24.900 --> 02:53:40.180]  пq. Ну и плюс я просто помнил разложение этих функций. Все просто. Рисуем это чудо. Поехали.
[02:53:40.180 --> 02:54:01.100]  0 1 1 1 0 1. То есть это у меня 1 xor q xor p q. Теперь что я делаю? Теперь я решаю уравнение.
[02:54:01.100 --> 02:54:17.100]  Справа у меня p xor p q xor p q. Равняется что-то там. Давайте назову x. Например xor и инверсии.
[02:54:17.100 --> 02:54:27.900]  Это импликация. Что я могу? Так как это полиномы, я могу брать и вычеркивать
[02:54:27.900 --> 02:54:44.520]  одинаковые слагарины. Поехали. Теперь что у меня? p равняется x xor 1. Что тогда я делаю? Я хочу справа
[02:54:44.520 --> 02:54:51.660]  вычесть единицу. Что такое вычитание в полиномы Шигалкина? Это xor. То есть я беру сюда xor 1 xor 1.
[02:54:51.660 --> 02:55:06.580]  То есть x неизвестный. Это у меня 1 xor p. Что такое 1 xor p? 1 xor p это отрисание p. А мы уже знаем как это выразить.
[02:55:06.580 --> 02:55:17.460]  То есть 1 xor p мы знаем как выразить при помощи этого. Значит я знаю что такое x. Вот это у меня
[02:55:17.460 --> 02:55:33.300]  p следует q. Значит я могу выразить дизъюнцию. p или q равняется. Что такое x? Это p следует p xor p.
[02:55:33.300 --> 02:55:44.180]  Дальше на это все навешиваю xor и p следует q. Пожалуйста решили. Именно поэтому полином
[02:55:44.180 --> 02:55:51.300]  Шигалкина хорош. То есть мы справа получили полином Шигалкина. Слева получили полином Шигалкина.
[02:55:51.300 --> 02:55:58.620]  Дальше приравняли. Сказали что давайте мы добавим еще что-то. Чего не хватает до того. Назовем
[02:55:58.620 --> 02:56:05.400]  это x. И будем решать уравнение относительно x. Чему равняется x? Я могу вычитать справа с
[02:56:05.400 --> 02:56:13.360]  лево одинаковые. Дальше вот у меня остался 1. Я взял добавил еще 41 41 и получил в точности чему
[02:56:13.360 --> 02:56:22.360]  равняется x. Все решили уравнение но только уравнение теперь на немножко других полиномах. Извините можно
[02:56:22.360 --> 02:56:31.200]  уточнить если честно. Я для отрицания понял что мы сделали. Насчет дизъюнции не очень понял. Мы
[02:56:31.200 --> 02:56:39.560]  сначала составили многочисленные Шигалкина. И потом говорим что нам нужно еще чтобы была
[02:56:39.560 --> 02:56:48.840]  импликация. И сейчас чтобы была импликация. Что мы делаем получается. Ну смотри понятно что только
[02:56:48.840 --> 02:56:58.000]  через XOR я не смогу как-то получить. Нет тут же сказано через XOR импликацию по условию. То есть не
[02:56:58.000 --> 02:57:07.440]  может быть только XOR. На самом деле там если там подберут такие условия можно что одна через
[02:57:07.440 --> 02:57:13.960]  одну выразиться. Нет тут же мы выразили только через XOR. Но по условию нам нужно чтобы формуле
[02:57:13.960 --> 02:57:23.320]  было еще импликация. Нет по условия нам нужно чтобы эти были выразлены через это и то. Чтобы
[02:57:23.320 --> 02:57:31.960]  вот используя XOR используем импликацию и получаем эти штуки. Если ты можешь использовать только
[02:57:31.960 --> 02:57:36.960]  XOR получить какую-то из этих одних. Супер вполне себе подойдет. Проблема в том что это не сможешь.
[02:57:36.960 --> 02:57:45.040]  Я имею ввиду у нас по условию сказано что нужно выразить отрицание и импликацию через
[02:57:45.040 --> 02:57:55.680]  через XOR и импликацию. Это значит что мы должны отдельно сказать что такое отрицание P через
[02:57:55.680 --> 02:58:03.280]  чтобы записать такую формулу для отрицания P чтобы там было и XOR и импликация. Не обязательно.
[02:58:03.280 --> 02:58:08.840]  Нет ты просто должен использовать только эти два функции записать. Не обязательно чтобы
[02:58:08.840 --> 02:58:16.920]  участвовали обе. А ну так тогда зачем для ВМ еще что-то делаем если мы через XOR уже все записали.
[02:58:16.920 --> 02:58:33.480]  ПКУ. А я понял. Поэтому мне не хватает одного XOR и что я делаю. Я хочу записать импликацию
[02:58:33.480 --> 02:58:39.840]  через пыленом Жигалкина. Даша я скажу что к этому пыленому Жигалкина добавлю какой-то еще
[02:58:39.840 --> 02:58:47.160]  пыленом Жигалкина. То есть там будут содержаться либо вычитание лишних либо добавление не хватающих
[02:58:47.160 --> 02:58:54.240]  маномов Жигалкина. То есть глобально у нас с левой справа маномы Жигалкина так фиксированы. Теперь у меня
[02:58:54.240 --> 02:59:00.880]  справа функции с левой функции. Вот здесь вот у меня уже есть какие-то а здесь есть другие. Тогда вот я X
[02:59:00.880 --> 02:59:07.600]  я что хочу. Я хочу добавить недостающие. Я сейчас не очень понял. Переход. То есть вот мы говорим что нужно
[02:59:07.600 --> 02:59:16.560]  ПКУ. Короче мы говорим что у нас есть конъюнция которую мы не можем выразить. Вот как мы потом
[02:59:16.560 --> 02:59:24.360]  рассуждаем я не понял. Мы слева записали пыленом Жигалкина вот такой. А как мы записываем то что
[02:59:24.360 --> 02:59:33.560]  справа я не понял. Можно еще раз. Слева у меня пыленом Жигалкина для вот этой штуки.
[02:59:33.560 --> 02:59:48.120]  Да. Здесь вот это вот это пыленом Жигалкина для ампликации. Все. Пыленом Жигалкина это кабинет
[02:59:48.120 --> 02:59:55.240]  из каких-то маномов. Маномы все фиксированы. У меня есть такая штука как соль. Я вот что я скажу что
[02:59:55.240 --> 03:00:01.800]  пусть X это какой-то еще пыленом Жигалкина который я ссорю с пыленомом Жигалкина для ампликации
[03:00:01.800 --> 03:00:10.600]  чтобы получить пыленом Жигалкина для изюмцы. Почему-то. Сейчас извините вопрос. Разве P типа
[03:00:10.600 --> 03:00:19.360]  из P следует Q у нас должна быть такой пыленом Жигалкина? Да. Мы же записывали что это вы записали
[03:00:19.360 --> 03:00:33.920]  единичку и на ее месте должна P стоить. Ну ок. Спасибо. Да блин я не понял что это такое. Ну да это уже
[03:00:33.920 --> 03:00:49.320]  Мекса. Ладно давайте. Все. Теперь я понял. А там же Q должно стоять. КУК СОРПЕК СОРПЕКУК. Тут стоит. Тут единичка стоит.
[03:00:49.320 --> 03:01:04.680]  Сейчас подойди пожалуйста. В общем давай еще раз. Вот я записал пыленом Жигалкина для ампликации,
[03:01:04.680 --> 03:01:12.000]  записал для изюмции. Теперь я говорю что вот я возьму X это что? Это какой-то пыленом Жигалкина
[03:01:12.000 --> 03:01:17.880]  состоящий из манов Жигалкина который не достают справа до лево и который вычитает какие-то лишние
[03:01:17.880 --> 03:01:24.680]  пыленомы Жигалкин которые есть право. Все. Я решаю теперь уравнение относительно X. Что я делаю? Я
[03:01:24.680 --> 03:01:36.280]  могу вычесть Q. Дальше я могу вычесть P и P справа. Теперь я получаю следующее уравнение что Q равняется
[03:01:36.280 --> 03:01:44.680]  X 41. Тогда что мне нужно? Мне теперь нужно убрать единицу справа. Давайте я добавлю единицы там
[03:01:44.680 --> 03:01:53.080]  и там. Потому что единицы есть в учитании. Тогда X у меня будет равняться 1 к 40. 1 к 40 какая-то
[03:01:53.080 --> 03:02:05.440]  переменная я уже умею выражать. Поэтому я просто заменяю на эту запись. Это Q следует Q к 40. Все.
[03:02:05.440 --> 03:02:11.560]  Справа я знаю как эту запись переводить. Поэтому я вместо X подставляю новое, а дальше все умею.
[03:02:11.560 --> 03:02:25.000]  Q к 40, Q к 40, что это последует Q. И это равняется P или Q. Поэтому если у вас есть
[03:02:25.000 --> 03:02:34.280]  X, переводим все в пыленомы Жигалкин и решаем уравнение. А по условию типа 0 и 1 нельзя использовать
[03:02:34.280 --> 03:02:43.720]  формулю. Ну да, конечно. Так, ну вот это я понял как мы получили. Но сейчас вот эта верхняя запись,
[03:02:43.720 --> 03:02:50.960]  можно очень быстро уточнить просто чтобы понять правильно я понял или нет. Вот мы говорим что у нас
[03:02:50.960 --> 03:03:02.200]  слева пыленом Жигалкина для или, а справа получается говорим что какой-то короче пыленом Жигалкина
[03:03:02.200 --> 03:03:16.400]  для импликации и то что мы его умножим на другой пыленом, который у нас убьет вот
[03:03:16.400 --> 03:03:26.480]  эти самые. Но почему мы точно знаем что он убьет их? Это будет какой-то какой-то пыленом Жигалкина,
[03:03:26.480 --> 03:03:38.880]  который добавит недостающие и убьет лишние. X, то есть X добавит недостающие и убьет лишние.
[03:03:38.880 --> 03:03:46.760]  Ну вот смотри, например, что сделал этот X? X убил один, который был лишним и добавил Q,
[03:03:46.760 --> 03:03:55.840]  которое не доставало. Сейчас убил X и добавил Q, которого не доставало. Ну потому что вот 1 1,
[03:03:55.840 --> 03:04:10.680]  вот этот вот уберет, а Q он добавит. Сейчас работает как у нас XOR. Работает так, что если у нас чего-то
[03:04:10.680 --> 03:04:18.000]  не было, то он этого добавляет, а если что-то было мы это за XOR, он это уберет. Ну окей, хорошо мы
[03:04:18.000 --> 03:04:24.600]  говорим пусть у нас будет X, который недостающую короче добавит и уберет лишние, но как мы понимаем
[03:04:24.600 --> 03:04:32.360]  что у нас здесь? Мы говорим что Q это лишнее, да? Нет, я все, я сказал что вот и записал вот это урожение,
[03:04:32.360 --> 03:04:42.840]  все, после этого я начинаю решать уравнение, находить что такое X. А еще вопрос, вот почему мы
[03:04:42.840 --> 03:04:49.440]  сразу пришли к мысли, что типа мы должны X умножить именно там на импликацию? Мы X ничего не умножали,
[03:04:49.440 --> 03:05:03.240]  мы XORим. Почему мы именно XORим с импликацией? Потому что мы хотим вырослить. Потому что у нас из
[03:05:03.240 --> 03:05:11.360]  возможностей есть только импликация еще. Все, я понял, то есть мы говорим какой-то многочлен,
[03:05:11.360 --> 03:05:17.720]  XORим его с этим и говорим что он добавит недостающую, убьет лишнюю. Когда как мы понимаем,
[03:05:17.720 --> 03:05:23.000]  что у нас недостающая, что у нас лишняя? Я так понимаю, что у нас лишняя... Мы решаем уравнение.
[03:05:23.000 --> 03:05:31.480]  Мы решаем уравнение. У тебя записано слева, справа. Стандартное уравнение для многочленов,
[03:05:31.480 --> 03:05:38.440]  как в школе, только теперь другие значки. Теперь вместо сложения мы пишем сложение в кружочке. Все,
[03:05:38.440 --> 03:05:45.200]  дальше что умеем мы можем делать с многочленами? Если справа и слева есть одинаковые компоненты,
[03:05:45.200 --> 03:05:52.880]  мы их можем убрать. Вот я убираю одинаковые справа. Я убрал ПК с права-слева, П с права-слева.
[03:05:52.880 --> 03:06:00.400]  Игры чуть-чуть, я понял, да. Понятно. Мне осталось К уравняется в той штуке, поэтому теперь я хочу
[03:06:00.400 --> 03:06:06.320]  вычесть справа один, а вычесть этот XOR один, поэтому XOR один справа, XOR один слева. Получилось что такое X?
[03:06:06.320 --> 03:06:24.120]  Все. Если будет XOR с чем-то, решаем пыльном сжигалке. Решаем этим пыльном сжигалке. А если не будет?
[03:06:24.120 --> 03:06:31.880]  А если не будет грусти, мы пытаемся придумать какие-то, ну короче, методом рандома.
[03:06:31.880 --> 03:06:42.760]  Полюном сжигалки это круто, но есть подозрения, что вам его специально не дадут, потому что им
[03:06:42.760 --> 03:06:56.000]  очень приятно решать такие вот уравнения. Все. На этом вроде все задачи решили. Извините, а 20 можно
[03:06:56.000 --> 03:07:11.640]  разобрать? Давайте 20, вот 20 и 18 я отдельно напишу решение, я пишу файлы. А они какие-то сложные, да?
[03:07:11.640 --> 03:07:19.960]  Они просто там только пару групп, которые доступны, например 18. Короче 18, того что я помню,
[03:07:19.960 --> 03:07:28.320]  заключается в том, что вот это есть у нас по сути ESCNF. Соответственно, мы можем просто построить
[03:07:28.320 --> 03:07:33.720]  сразу по этому быстрый таблицу истинности. Делаем карту Karno по карте Karno, минимизируем.
[03:07:33.720 --> 03:07:40.480]  Дальше используем законы Деморгана. Еще как-то покрутили по дистрибутивности, по сокращали,
[03:07:40.480 --> 03:07:47.840]  получили красоту и записали это все при помощи схемы с функциональных элементов. Там будет что-то
[03:07:47.840 --> 03:07:57.680]  вида, как я помню. Там будет что-то вида, когда мы... Что там было? Там здесь вот дизюмсы,
[03:07:57.680 --> 03:08:05.080]  даже некого как-то там придут так, это как-то так, и там как-то так, и здесь вот как-то так.
[03:08:05.080 --> 03:08:12.160]  Нет, ну здесь вот такая, здесь такая. В общем, она как-то так будет выглядеть, я уже не помню точно.
[03:08:12.160 --> 03:08:20.800]  Я что-то такое решал, я напишу решение, которое я сделал. А по двадцатой какая основная идея?
[03:08:20.800 --> 03:08:36.080]  По двадцатой... Ну, по двадцатой, во-первых, во-первых, вам нужно для двадцатой есть 10
[03:08:36.080 --> 03:08:42.640]  ПТК-классы. Вам могут сюда найти произвольные классы, вам могут быть там классы лямбда, класс В,
[03:08:42.640 --> 03:08:51.160]  класс что... Ну, короче, кранитивные, дизюктивные вам могут дать классы... Пересечением вам могут
[03:08:51.160 --> 03:08:55.840]  быть дать каких-то классов. Короче, есть такая штука, как решетка поста.
[03:08:55.840 --> 03:09:16.640]  Вот такая красота. По идее, вам могут дать на контрольный, абсолютно произвольный класс
[03:09:16.640 --> 03:09:22.040]  отсюда. И там вот что-нибудь такое спросите. Вам нужно помнить всё.
[03:09:22.040 --> 03:09:32.600]  Ну, а как-то, нет, нам её показывали верхнюю часть, и вот Т ну там вот Т нулевое, ну как бы Т,
[03:09:32.600 --> 03:09:38.640]  который сохраняет нулевое, так далее, и это вот Т первое. Ну как бы, как этим пользоваться?
[03:09:38.640 --> 03:09:44.880]  Как этим? Я попытаюсь подумать, придумать какой-то общий способ, но я просто... Эта задача
[03:09:44.880 --> 03:09:49.640]  вообще впервые, таких никогда не было, что дадут на реальный, я даже представить себе не могу.
[03:09:49.640 --> 03:10:00.880]  Понятно. То есть вполне себе можно сделать что-то. Ну дай бог, и сохранят там классы ТК. А теперь,
[03:10:00.880 --> 03:10:08.920]  ну давайте дадим вам класс какой-нибудь там, вот этот вот МП, МТ, когда монотонные и ещё Т-шки.
[03:10:08.920 --> 03:10:18.840]  Вообще никто не помешает вам. Могу спокойно дать классы там, какие-нибудь дизинктивные, конъюнктивные.
[03:10:18.840 --> 03:10:32.560]  Ну, то есть это просто фиг пойми какая задача. Глобально, ну типа 18-й дадут что дадут, ну понятно,
[03:10:32.560 --> 03:10:38.120]  просто другую функцию там, как решать, какого-то общего алгоритма нету. Просто строим таблицу
[03:10:38.120 --> 03:10:43.000]  естественности, при помощи карт-карно пытаемся уже сразу как-то минимизировать. Дальшим методом
[03:10:43.000 --> 03:10:50.800]  приставного взгляда. Применяем законы деморгана, что мы делаем. Здесь, 20-й, ну, я не правда,
[03:10:50.800 --> 03:10:57.080]  я не знаю. Во-первых, я не знаю, что дадут. Правда ли дадут потом в конце просто Т0. Может
[03:10:57.080 --> 03:11:03.240]  быть сверху сделают, может быть верхний индекс будет фиксирован, нижний будет каперименный. Как именно
[03:11:03.240 --> 03:11:12.100]  эта штука будет выглядеть, непонятно. Понял. Типа, если был бы раньше, я бы мог еще как-то посмотреть.
[03:11:12.100 --> 03:11:21.280]  Задача вообще абсолютно новая. Раньше даже, ну типа, ТК не всегда на семинарах разбирали. Ну,
[03:11:21.280 --> 03:11:35.640]  324 это мат-группа, по-моему, а 326 и 328 это эти, про два. Ну, 312 это рэш. Я не знаю, зачем рэш дают.
[03:11:35.640 --> 03:11:47.320]  Ладно, я попытаюсь вывести какие идеи здесь, я почитаю, подумаю. Думаю, завтра сделаю.
[03:11:47.320 --> 03:12:00.600]  Спасибо, до свидания. Мне за что решение. Прошлые лет скоро будут. До свидания. Спасибо за
[03:12:00.600 --> 03:12:04.360]  ДОП-семинар. Всем добру, до свидания. Спасибо.
