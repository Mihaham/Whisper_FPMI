[00:00.000 --> 00:20.520]  У меня остался долг с Форд Белманом. Давайте мы все добьем. Что там было? Я сделал n-1 или n-этераций,
[00:20.520 --> 00:25.600]  ну n-этераций в случае, когда мы хотим работать с отрицательными циклами. Давайте еще раз
[00:25.600 --> 00:35.400]  напишу утверждение, что если c это отрицательный цикл, то есть цикл отрицательного веса, то на
[00:35.400 --> 00:42.400]  него обязательно существует по крайней мере одна вершина, для которой dp уменьшилось с n-1 до
[00:42.400 --> 00:56.080]  n-этераций. dp в n-е строго меньше, чем dp в n-1. Вот, доказательства. Ну пусть не так, пусть оно
[00:56.080 --> 01:01.680]  осталось как было. Понятно, что больше оно стать не могло, потому что dp в этой k плюс 1, в частности,
[01:01.680 --> 01:06.280]  расширится как минимум из dp в этой k и чего-то там, поэтому оно увеличиться точно не могло,
[01:06.280 --> 01:16.800]  поэтому тут везде равенства стоят. А то есть для любой v из c тут равенство. dp в этой n-е равно
[01:16.800 --> 01:29.080]  dp в этой n-1. Хорошо, что это значит? Давайте нарисуем наш цикл c. Вот такой цикл, большой цикл c.
[01:29.080 --> 01:43.600]  Он состоит из вершин v1, v2, v3 и так далее. Ну пусть будет k, не страшно. И тут есть веса-рёбер.
[01:43.600 --> 01:52.480]  Давайте я их обозначу c1, c2, c3 и так далее, ck. Что значит, что у меня dp не изменилось при
[01:52.480 --> 01:58.760]  переходе от n-ой сферы в слою к n-ому? Давайте распишем это для какой-нибудь вершины vi плюс 1.
[01:58.760 --> 02:08.080]  Значит, как у меня вообще считается dp vi плюс 1-ая n-ая? Там в частности рассматривается вот это вот
[02:08.080 --> 02:15.240]  ребро из цикла, веса ci ведущая из вершины vi. То есть я рассматриваю такое ребро и обновляю,
[02:15.720 --> 02:24.840]  пытаюсь обновить эту штуку через dp vi n-1 плюс ci. То есть я вот эту величину просто по формуле
[02:24.840 --> 02:35.880]  пересчета динамики, в частности пытаюсь обновить через dp vi n-1 плюс ci. Потому что я мог сначала
[02:35.880 --> 02:44.960]  дойти досюда, используя n-1 ребро, потом еще одно ребро, веса ci сюда добавить и получить путь из n-рёбер.
[02:44.960 --> 02:51.640]  Но поскольку здесь было равенство, значит это обновление не дало выигрыша. То есть вот эта
[02:51.640 --> 02:56.880]  штука, она больше равна, чем то, что и так лежало в этой дпшке. То есть я могу написать такое
[02:56.880 --> 03:14.160]  неравенство. dp vi n-1 плюс ci больше равно, чем вот это, чем dp vi плюс 1 n-1. Раз у меня дпшка
[03:14.160 --> 03:18.720]  не изменилась, значит все попытки обновить бесполезны. То есть они не лучше, чем то,
[03:18.720 --> 03:25.000]  что там и так лежало. А здесь лежало изначально как раз вот dp vi и плюс 1 и минус 1. То есть все
[03:25.000 --> 03:29.720]  возможные обновления с помощью входящих ребер, они бесполезны, они не улучшают ответ. Значит в
[03:29.720 --> 03:33.920]  частности вот эти все обновления по ребрам из цикла тоже не улучшают ответ, не улучшают дпшку.
[03:33.920 --> 03:49.600]  Вот. Ну все, теперь мы суммируем это все по всем i. Значит это превратится в сумму по всем
[03:49.600 --> 03:54.320]  вершинам цикла dp vi и минус 1. Это то же самое, только со сдвигом. Да, это одна и та же сумма,
[03:54.320 --> 04:01.120]  только со сдвигом на 1. Получается тогда они сократятся и останется сумма ci больше 0,
[04:01.120 --> 04:14.840]  противоречие. Нормально? Вот. То есть противоречие с тем, что цикл отрицательный. То есть если цикл
[04:14.840 --> 04:20.160]  отрицательный, то не может быть такого, что все эти dpшки остаются на месте при применении очередной
[04:20.160 --> 04:25.440]  итерации. По крайней мере одна должна упасть, иначе цикл должен был быть не отрицательным по весу.
[04:25.440 --> 04:34.040]  Вот. Все. Значит это первое. Первое, что нам нужно. Ну и второе тривиальное замечание. Замечание,
[04:34.040 --> 04:49.680]  если v такова, что dp в это n меньше, чем dp в это n минус 1, то существует отрицательный цикл,
[04:49.680 --> 04:55.760]  достижимый из s и из которого достижимо v. Опять нарисую картинку. Существует отрицательный
[04:55.760 --> 05:04.560]  ц, такой, что из s можно дойти до c, и из c можно дойти до v. Вот так давайте нарисую. Можно дойти до v.
[05:04.560 --> 05:14.720]  Ну вроде понятно, потому что если таких нет, то у меня очевидно dp не меняется при переходе
[05:14.720 --> 05:22.400]  с n минус 1 слоя на n, потому что, раз оно уменьшилось, значит есть какой-то путь длины n, точнее из n
[05:22.400 --> 05:27.120]  ребер, но не из-за минус одного ребра, который имеет меньше вес. Ну а если там n ребер, то там
[05:27.120 --> 05:30.640]  обязательно есть на пути отрицательный цикл. Иначе его можно было бы отбросить и вес стал бы
[05:30.640 --> 05:37.160]  только лучше. Тем самым вот эти два факта, утверждение и замечание, в совокупности означают
[05:37.160 --> 05:43.120]  следующее, что вершины, для которых уменьшилась dp с n минус 1 слоя до n, то есть вот такие или такие,
[05:43.120 --> 05:50.280]  это вершины отрицательных циклов или что-то, что из них достижимо. И при этом каждый отрицательный
[05:50.280 --> 05:54.960]  цикл даст себя хотя бы одну вершину. То есть каждого цикла отрицательным будет хотя бы одна вершина,
[05:54.960 --> 05:59.800]  а все вершины, для которых это верно, это либо вершины из циклов, либо что-то, что достижимо из цикла.
[05:59.800 --> 06:07.680]  Поэтому если я после этого запущу dfs из всех таких вершин, то я в точности посещу все вершины
[06:07.680 --> 06:13.360]  вот такого типа. То есть все вершины, которые достижимы из какого отрицательного цикла,
[06:13.360 --> 06:17.840]  которые в свою очередь достижимы из s. Поэтому то, что я в конце прошлой лекции говорил,
[06:17.840 --> 06:22.400]  что мы сначала вот эти вот все вершины сохраним, то есть я создам множество вершин, для которых
[06:22.400 --> 06:27.920]  уменьшилась dp, из них потом запущу dfs, и все, что dfs посетил, на самом деле для них dist равно
[06:27.920 --> 06:36.060]  минус бесконечности. А все, что не посетил для них dist, это то, что в dp лежит. Тем самым как раз мы
[06:36.060 --> 06:42.300]  показали, что все вершины с этим dist мы правильно обработали, мы их все нашли и с помощью dfs туда
[06:42.300 --> 06:47.620]  проставили эти dist. А все остальные, которые недостижимы, понятно, что для них dp-шка уже
[06:47.620 --> 07:06.880]  найдена еще на n-1-ом слое. Как-то так. Вопросы? Ну, хорошо. Тогда получается, что мы в этот
[07:06.880 --> 07:13.800]  момент научились полностью решать задачу поиска кратчайших расстояний от одной вершины до всех,
[07:13.800 --> 07:20.340]  от s до всех, во все возможных постановках, когда у меня граф невзвешенный, взвешенный с маленькими
[07:20.340 --> 07:25.620]  весами, это 0kbfs, взвешенный с неотрицательными ребрами и взвешенный с произвольными ребрами,
[07:25.620 --> 07:29.740]  и даже, возможно, в присутствии отрицательных циклов. Эту задачу мы полностью решили.
[07:29.740 --> 07:43.200]  Вот, есть еще другая задача. Давайте напишу сразу алгоритм Флойда. Он решает задачу поиска
[07:43.200 --> 07:49.540]  кратчайших путей от всех вершин до всех, то есть все попарные кратчайшие расстояния он
[07:49.540 --> 08:07.940]  находит. Поиск всех попарных кратчайших путей. То есть если раньше мы рассматривали кратчайшие
[08:07.940 --> 08:11.780]  пути от одной до всех, то здесь от всех до всех. У меня нет какого-то фиксированного
[08:11.780 --> 08:16.060]  истока, фиксированного начала, я могу от любой до любой идти. То есть по факту я нахожу все
[08:16.060 --> 08:27.140]  дисты и t и g для всех пар i и g. Вот, значит, ну здесь для удобства я скажу, что отрицательных циклов нет,
[08:27.140 --> 08:37.100]  но могут быть отрицательные ребра.
[08:37.100 --> 08:51.300]  Вот, на самом деле Флойд работает даже в присутствии отрицательных циклов. Там ничего менять не надо,
[08:51.300 --> 08:55.780]  надо просто там чуть-чуть-чуть аккуратнее все повторить. Это будет задачка на семинар,
[08:55.780 --> 09:00.280]  что делать в присутствии отрицательных циклов во Флойде. Мы рассмотрим на лекции только без
[09:00.280 --> 09:12.600]  отрицательных циклов. Значит, опять динамика, как ни странно. Ведем следующую dp. dp i t, j t, k t это
[09:12.600 --> 09:27.640]  следующая величина. Значит, это длина, минимальная длина пути от i до j такого, что, то есть я рассматриваю
[09:27.640 --> 09:32.680]  только такие пути, которые в качестве промежуточных вершин содержат вершины с номерами не больше
[09:32.680 --> 09:47.460]  k. Минимальная длина пути такого, что все промежуточные вершины, то есть вершины отличные от стартовой
[09:47.460 --> 09:58.140]  конечной. Все промежуточные вершины имеют номера не больше чем k. Такое странное условие. То есть я
[09:58.140 --> 10:03.860]  позволяю себе по дороге посещать только вершины с номерами небольшими, не больше чем k. То есть есть
[10:03.860 --> 10:11.380]  i и есть j. Без них мы уж не справимся, они обязательно есть в пути между ними. А по дороге все
[10:11.380 --> 10:19.780]  вот эти вот промежуточные вершины имеют номера не больше чем k. Такое условие. Как считать такую
[10:19.780 --> 10:28.380]  динамику? Ну, база очень простая. Когда k равно нулю, я считаю, что я живу сейчас в 1 индексации,
[10:28.380 --> 10:35.540]  и dp i t, j t, 0 это когда я вообще не могу использовать промежуточных вершин. Если у меня 1 индексация,
[10:35.540 --> 10:39.860]  то получается, что у меня требование, что все вершины здесь имеют номера не больше чем 0, а таких
[10:39.860 --> 10:45.700]  вершин вообще нет. Поэтому единственный путь из ив-жи, если и есть, это ребро из ив-жи просто.
[10:45.700 --> 10:51.460]  И поэтому его длина, это просто вес этого ребра. Я тогда могу здесь написать, что эта штука равна
[10:51.460 --> 11:00.300]  в точности кост и жи, где кост и жи это длина ребра из ив-жи, либо плюс бесконечность, если
[11:00.300 --> 11:09.540]  такого ребра нет. Давайте это отметим, что может быть плюс бесконечность. Ну, потому что понятно,
[11:09.540 --> 11:15.060]  что если ребра между вершинами нет, то от того, что я вставлю туда ребро веса плюс бесконечность,
[11:15.060 --> 11:20.100]  у меня ничего не изменится. Добавление ребра бесконечного веса не влияет на кратчайшие пути.
[11:20.100 --> 11:26.060]  Поэтому я могу смело сказать следующее, если между вершинами нет ребра, то я его туда вставляю,
[11:26.060 --> 11:29.420]  но говорю, что у меня бесконечно большой вес. Тогда эта штука просто в точности равна вот этой
[11:29.420 --> 11:33.700]  матрице костов. Возможно только в матрице кост есть бесконечный бесконечный числ.
[11:47.700 --> 11:55.860]  Так, дальше. Переходим к следующему слою динамики. Вот я хочу перейти от слоя номер к,
[11:55.860 --> 12:25.860]  к к к inform, к к к к, к к к к к к к, к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к кк к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к К к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к к
[12:25.860 --> 12:29.860]  используют вершины с номерами не большим k плюс 1.
[12:29.860 --> 12:31.860]  Но тут есть, как обычно, два варианта.
[12:31.860 --> 12:35.860]  Либо мы используем не просто меньше или равное k плюс 1,
[12:35.860 --> 12:37.860]  а меньше или равное k.
[12:37.860 --> 12:40.860]  То есть тогда, в частности, вот здесь я могу написать
[12:40.860 --> 12:44.860]  dp it kt.
[12:44.860 --> 12:47.860]  То есть у меня все промежуточные номера не только меньше
[12:47.860 --> 12:49.860]  или равно k плюс 1, но еще и меньше или равно k.
[12:49.860 --> 12:52.860]  Тогда это просто такая динамика, уже насчитанная нами.
[12:52.860 --> 12:54.860]  dp it kt.
[12:54.860 --> 12:58.860]  Иначе получается, что я использую номера больше, чем k,
[12:58.860 --> 13:01.860]  но меньше чем k плюс 1.
[13:01.860 --> 13:04.860]  Значит, я в частности использую в точности k плюс 1.
[13:04.860 --> 13:08.860]  То есть у меня на этом пути где-то по дороге есть вершины
[13:08.860 --> 13:10.860]  с номером k плюс 1.
[13:10.860 --> 13:12.860]  Но при этом все остальные имеют номер не больше,
[13:12.860 --> 13:14.860]  чем k плюс 1.
[13:14.860 --> 13:16.860]  Дальше.
[13:16.860 --> 13:18.860]  Очевидно, что нет смысла использовать k плюс 1
[13:18.860 --> 13:19.860]  больше, чем один раз.
[13:19.860 --> 13:21.860]  То есть не может быть такого, что у меня здесь k плюс 1
[13:21.860 --> 13:22.860]  и здесь k плюс 1.
[13:22.860 --> 13:25.860]  потому что иначе получается, что мы обходим какой-то цикл,
[13:25.860 --> 13:28.860]  то есть раз мы возвращаемся в ту же вершину, где мы уже побывали,
[13:28.860 --> 13:30.860]  а я предполагаю, что нет отрезательных циклов.
[13:30.860 --> 13:33.860]  Поэтому циклы нам бесполезны, их не нужно посещать.
[13:33.860 --> 13:38.860]  Чтобы попасть из И в Ж, используя минимальный вес, циклы мне посещать нельзя.
[13:38.860 --> 13:44.860]  Значит, вершина k плюс 1 на этом пути, если встречается, то максимум один раз.
[13:44.860 --> 13:50.860]  Ну а значит, все остальные вершины имеют номер максимум k, не больше чем k.
[13:50.860 --> 13:54.860]  Значит, мне нужно рассмотреть путь из И в k плюс 1,
[13:54.860 --> 13:56.860]  использующий вершину с номерами, не больше чем k,
[13:56.860 --> 14:00.860]  и потом путь из k плюс 1 в Ж, использующий вершину с номерами, не больше чем k.
[14:00.860 --> 14:04.860]  Поэтому вторая опция для нашего значения dp,
[14:04.860 --> 14:12.860]  это dp иt k плюс 1 kt, плюс dp k плюс 1 Ж kt.
[14:20.860 --> 14:22.860]  Вроде здесь простое рассуждение.
[14:22.860 --> 14:24.860]  Еще раз давайте проговорю.
[14:24.860 --> 14:27.860]  Если мне доступны только вершины с номерами, не больше чем k плюс 1,
[14:27.860 --> 14:30.860]  то либо там нет даже k плюс 1 и значит все не больше чем k,
[14:30.860 --> 14:33.860]  это первый случай, либо там есть вершина номера k плюс 1,
[14:33.860 --> 14:39.860]  тогда она точно ровно одна, и значит от начала до нее промежуточные не больше чем k имеют вес,
[14:39.860 --> 14:43.860]  и от нее до конца опять промежуточные имеют вес номера не больше чем k.
[14:43.860 --> 14:46.860]  Поэтому мне нужно взять сумму этих dp-шек,
[14:46.860 --> 14:51.860]  и они уже пощитны, потому что я считаю, что k иt пощитны, я перехожу k плюс 1.
[14:51.860 --> 14:54.860]  Вся dp-шка.
[14:54.860 --> 15:02.860]  Очевидно, что это работает за куб времени.
[15:02.860 --> 15:07.860]  Извините, я забыл сказать, что ответ это всегда dp иt Ж тн.
[15:07.860 --> 15:10.860]  Надо это проговорить, конечно, всегда.
[15:10.860 --> 15:14.860]  Ответ это dp иt Ж тн.
[15:14.860 --> 15:17.860]  Потому что такая динамика, это что такое?
[15:17.860 --> 15:20.860]  Это кратчайший путь из и в Ж, который в качестве промежуточных
[15:20.860 --> 15:22.860]  использует вершины с номерами не больше чем n.
[15:22.860 --> 15:24.860]  То есть просто какие угодно вершины.
[15:24.860 --> 15:26.860]  А вот это условие означает, что нет условия.
[15:26.860 --> 15:29.860]  То есть по факту все промежуточные вершины, какие угодно,
[15:29.860 --> 15:31.860]  это в точности то самый дист, который нам нужно.
[15:31.860 --> 15:34.860]  Дист из и в Ж.
[15:34.860 --> 15:37.860]  Поэтому такая динамика реально нам дает ответ за время кубическое.
[15:37.860 --> 15:40.860]  Потому что у меня трехслойная динамика,
[15:40.860 --> 15:44.860]  все три параметра, пробегая значения от 1 до n,
[15:44.860 --> 15:47.860]  от 0 до n, возможно, и пересчет у меня за единицу.
[15:47.860 --> 15:51.860]  Каждое значение dp иt Ж тк плюс 1 я вычисляю за единицу.
[15:51.860 --> 15:54.860]  Поэтому суммарной будет куб.
[15:54.860 --> 15:57.860]  Согласны?
[15:57.860 --> 16:00.860]  Чудно.
[16:00.860 --> 16:04.860]  Так, ну тут вопрос еще с памятью на самом деле.
[16:12.860 --> 16:15.860]  Некоторые есть.
[16:15.860 --> 16:18.860]  Потому что пока что память у меня кубическая.
[16:18.860 --> 16:21.860]  Динамика трехслойная, память тоже кубическая.
[16:21.860 --> 16:24.860]  Во-первых, как обычно, можем заметить, что у меня k
[16:24.860 --> 16:26.860]  плюс первый слой вычисляется через катый.
[16:26.860 --> 16:29.860]  Значит, мне достаточно хранить два слоя динамики.
[16:29.860 --> 16:32.860]  Поэтому память уже у нас получилась квадратичная.
[16:32.860 --> 16:35.860]  Если я храню только предыдущий слой и следующий,
[16:35.860 --> 16:38.860]  то мне достаточно от n квадрат ячеек памяти.
[16:38.860 --> 16:43.860]  На самом деле это можно реализовать еще более компактно.
[16:43.860 --> 16:46.860]  Следующим алгоритмом.
[16:46.860 --> 16:51.860]  Давайте я скажу, что пусть значения dp
[16:51.860 --> 16:56.860]  хранятся в массиве g.
[16:56.860 --> 17:00.860]  Хранятся в массиве g.
[17:00.860 --> 17:04.860]  Тогда алгоритм Флойда можно написать следующим образом.
[17:04.860 --> 17:08.860]  По всем k от 1 до n,
[17:08.860 --> 17:12.860]  по всем i от 1 до n,
[17:12.860 --> 17:16.860]  по всем g от 1 до n,
[17:16.860 --> 17:20.860]  g i, t i, g t
[17:20.860 --> 17:26.860]  равно минимум из того, что там уже лежит.
[17:26.860 --> 17:37.860]  И суммы g i, t i, k, t i, plus g k, t i, g t.
[17:37.860 --> 17:40.860]  Конец.
[17:40.860 --> 17:43.860]  После этого я утверждаю, после этих трех форов
[17:43.860 --> 17:48.860]  g i, t i, g t – это дист.
[17:48.860 --> 17:53.860]  Дист и g.
[17:53.860 --> 17:56.860]  То есть мне не просто можно избавиться от n слоев
[17:56.860 --> 17:58.860]  и хранить только два слоя,
[17:58.860 --> 18:00.860]  но на самом деле я могу оба слоя хранить
[18:00.860 --> 18:02.860]  на одной и той же памяти в каком-то смысле.
[18:02.860 --> 18:07.860]  Я завожу g i, t i, t i – это dp i, t i, t i, k, t i.
[18:07.860 --> 18:10.860]  То есть это значение на очередном слое динамики.
[18:10.860 --> 18:12.860]  Я его сам через себя пересчитываю.
[18:12.860 --> 18:15.860]  Я применяю вот эту формулу пересчета прямо на месте.
[18:15.860 --> 18:19.860]  Не использую два слоя динамики, а только один.
[18:19.860 --> 18:23.860]  Вот это само житое-ожитое само через себя пересчитывается.
[18:23.860 --> 18:27.860]  И оказывается, что это тоже будет корректно по счёт динамики.
[18:27.860 --> 18:30.860]  Почему?
[18:47.860 --> 18:51.860]  Я утверждаю, что после выполнения ката-итерации
[18:51.860 --> 18:54.860]  самого внешнего цикла,
[18:54.860 --> 18:59.860]  после ката-итерации внешнего цикла
[19:06.860 --> 19:11.860]  g i, t i, t i в точности равно dp i, t i, k, t i.
[19:15.860 --> 19:18.860]  То есть как раз у меня массив g хранит, собственно, массив dp.
[19:18.860 --> 19:21.860]  Ну, слой dp.
[19:25.860 --> 19:26.860]  Почему?
[19:26.860 --> 19:29.860]  Значит, смотрите, какая на самом деле тут проблема есть единственная?
[19:29.860 --> 19:31.860]  Проблема в том, что я два слоя склеил в один.
[19:31.860 --> 19:35.860]  То есть мне бы в идеале хранить два слоя динамики k и k плюс 1.
[19:35.860 --> 19:39.860]  И следующий k плюс первый считать через k.
[19:39.860 --> 19:43.860]  А здесь они как бы одно и то же.
[19:43.860 --> 19:46.860]  Я пересчитываю слой сам через себя.
[19:46.860 --> 19:50.860]  То есть я как бы не разделяю k и k плюс первый слой,
[19:50.860 --> 19:52.860]  а вот прям всё делаю на месте.
[19:52.860 --> 19:54.860]  И тут как бы непонятно, почему тогда работает.
[19:54.860 --> 19:56.860]  Что такое вот это g тогда вообще, если оно...
[19:56.860 --> 19:59.860]  Это какое dp, если я его само через себя пересчитываю?
[19:59.860 --> 20:01.860]  Непонятно.
[20:04.860 --> 20:06.860]  Ну, смотрите, я вот ожидаю тогда следующее.
[20:06.860 --> 20:11.860]  Заметим, что на...
[20:14.860 --> 20:17.860]  Сейчас, одну секунду.
[20:18.860 --> 20:21.860]  Ну да, что на ката-итерации
[20:23.860 --> 20:26.860]  g, it, kt...
[20:26.860 --> 20:28.860]  Давайте не так напишу.
[20:28.860 --> 20:37.860]  g, какое угодно kt и g, kt, какое угодно, не меняются.
[20:40.860 --> 20:44.860]  То есть если я нарисую табличку для нашего g,
[20:44.860 --> 20:49.860]  то у меня kt строка и kt столбец,
[20:50.860 --> 20:55.860]  они не меняются в течение выполнения ката-итерации.
[20:55.860 --> 20:58.860]  Ну, потому что, смотрите, если у меня вот здесь, скажем, i равно k,
[20:58.860 --> 21:00.860]  то представьте, что я сюда поставил k.
[21:00.860 --> 21:03.860]  А вот я уже говорю, что g, kt, gt никогда не поменяются.
[21:03.860 --> 21:05.860]  Что такое g, kt, gt?
[21:05.860 --> 21:11.860]  Это либо старое значение, либо g, kt, kt, то есть i равно k,
[21:11.860 --> 21:14.860]  плюс g, kt, gt.
[21:14.860 --> 21:16.860]  Ну, g, kt, kt это ноль,
[21:16.860 --> 21:20.860]  потому что путь из вершины в нее саму имеет вес ноль всегда.
[21:20.860 --> 21:23.860]  А здесь то же самое dp, kt, gt.
[21:23.860 --> 21:25.860]  То есть у меня dp, kt, gt не изменилось.
[21:25.860 --> 21:29.860]  Наоборот, если у меня здесь i, а здесь k,
[21:29.860 --> 21:31.860]  что такое g, it, kt, как я его обновляю?
[21:31.860 --> 21:36.860]  Либо то, что там уже и так лежит, либо g, it, kt, плюс g, kt, kt.
[21:36.860 --> 21:38.860]  Потому что k равно g.
[21:38.860 --> 21:40.860]  Опять то же самое, здесь нулевое слагаемое,
[21:40.860 --> 21:43.860]  поэтому у меня g, it, kt не изменилось вообще.
[21:43.860 --> 21:47.860]  Таким образом, у меня вот в этой моей матрице g,
[21:47.860 --> 21:51.860]  kt строка и kt столбец вообще не меняются в течение kт и итерации.
[21:51.860 --> 21:55.860]  Но смотрите, вот эти значения,
[21:55.860 --> 21:57.860]  это как раз вот эти самые строка и столбец,
[21:57.860 --> 22:00.860]  g, it, kt и g, kt, gt.
[22:00.860 --> 22:04.860]  Получается, что то, с помощью чего я обновляю все остальные g,
[22:04.860 --> 22:06.860]  у меня фиксировано не изменяется.
[22:06.860 --> 22:09.860]  И то есть если вот это были правильные значения как бы с прошлого слоя,
[22:09.860 --> 22:12.860]  то я обновляю следующий слой и использую значения с предыдущего слоя.
[22:12.860 --> 22:14.860]  И все хорошо.
[22:14.860 --> 22:16.860]  То есть вот эти вот значения у меня не меняются,
[22:16.860 --> 22:23.860]  и по факту они равны ну чему-то там dp, it, gt, k-1, видимо.
[22:23.860 --> 22:26.860]  То есть у меня вот эти значения сохранились, не меняются,
[22:26.860 --> 22:30.860]  и я обновляю dp, it, gt, kt на следующем слое через предыдущий.
[22:30.860 --> 22:32.860]  Ну и тогда получается все хорошо.
[22:32.860 --> 22:35.860]  У меня нет вот этого конфликта, что я только что посчитанные значения
[22:35.860 --> 22:37.860]  использую для насчета самих себя же.
[22:37.860 --> 22:39.860]  Потому что я обновляю g, it,
[22:39.860 --> 22:43.860]  gt только через то, что стабильно с прошлого слоя.
[22:44.860 --> 22:46.860]  Все, показали.
[22:50.860 --> 22:52.860]  Так, вопросики есть?
[22:54.860 --> 22:56.860]  Чудно.
[22:56.860 --> 22:58.860]  Вот.
[22:58.860 --> 23:00.860]  Ну и последнее тут замечание.
[23:10.860 --> 23:14.860]  Это про восстановление ответа.
[23:19.860 --> 23:22.860]  Ответа, то есть восстановление пути.
[23:24.860 --> 23:26.860]  Вот.
[23:26.860 --> 23:29.860]  Я научился находить длину, длину кратчайшего пути.
[23:29.860 --> 23:31.860]  А как сам путь восстановить?
[23:31.860 --> 23:34.860]  То есть я знаю, что в конце вот этого вот выполнения
[23:34.860 --> 23:36.860]  g, it, gt это кратчайшее расстояние.
[23:36.860 --> 23:38.860]  То есть длина кратчайшего пути.
[23:38.860 --> 23:40.860]  Вот вопрос, а как сам этот путь восстановить?
[23:40.860 --> 23:43.860]  Если я хочу вывести посредство вершин на пути от it, g.
[23:43.860 --> 23:45.860]  Как ее получить?
[23:46.860 --> 23:48.860]  Ну,
[23:48.860 --> 23:50.860]  смотрите, тут можно сделать следующее.
[23:50.860 --> 23:52.860]  Каждый раз, когда у меня вот эта g обновляется
[23:52.860 --> 23:55.860]  через что-то, то есть вот это g, it, gt обновляется через вот это.
[23:55.860 --> 23:57.860]  У меня получается что?
[23:57.860 --> 24:00.860]  У меня получается, что чтобы попасть из it в g,
[24:00.860 --> 24:03.860]  мне нужно сначала попасть из it в k, а потом из k в g.
[24:03.860 --> 24:05.860]  То есть у меня оптимальный путь выглядит как-то вот так.
[24:05.860 --> 24:07.860]  То есть если происходит обновление,
[24:07.860 --> 24:09.860]  то оптимальный путь выглядит как-то вот так.
[24:09.860 --> 24:11.860]  Сначала я попадаю в k,
[24:11.860 --> 24:13.860]  а потом дохожу до конца.
[24:13.860 --> 24:15.860]  Но давайте тогда в момент,
[24:15.860 --> 24:17.860]  когда у меня происходит это обновление,
[24:17.860 --> 24:19.860]  я укажу, что
[24:19.860 --> 24:21.860]  оптимальный путь из it в g, который я нашел,
[24:21.860 --> 24:23.860]  проходит в центре
[24:23.860 --> 24:25.860]  через вершин номер k.
[24:25.860 --> 24:27.860]  Давайте в момент обновления,
[24:27.860 --> 24:29.860]  в момент обновления
[24:33.860 --> 24:35.860]  g, it, gt,
[24:37.860 --> 24:39.860]  укажем
[24:43.860 --> 24:45.860]  p, it, gt равно k.
[24:45.860 --> 24:47.860]  То есть если вот здесь вот
[24:47.860 --> 24:49.860]  это значение меньше, чем старое значение,
[24:49.860 --> 24:51.860]  то я ж переприсваиваю
[24:51.860 --> 24:53.860]  и говорю, что p, it, gt равно k.
[24:53.860 --> 24:55.860]  По факту это означает,
[24:55.860 --> 24:57.860]  что чтобы попасть из it в g,
[24:57.860 --> 24:59.860]  мне нужно сначала дойти от it до k,
[24:59.860 --> 25:01.860]  и потом от k до g.
[25:01.860 --> 25:03.860]  И тогда в самом конце оптимальный путь,
[25:03.860 --> 25:05.860]  давайте напишем, что путь
[25:05.860 --> 25:07.860]  g,
[25:07.860 --> 25:09.860]  это что такое?
[25:09.860 --> 25:11.860]  Это мы сначала доходим
[25:11.860 --> 25:13.860]  от i до p, it, gt,
[25:13.860 --> 25:15.860]  то есть вот как раз до
[25:15.860 --> 25:17.860]  этой центральной вершины.
[25:17.860 --> 25:19.860]  Потом я печатаю само это p, it, gt,
[25:19.860 --> 25:21.860]  потом
[25:21.860 --> 25:23.860]  дохожу от него
[25:23.860 --> 25:25.860]  p, it, gt,
[25:25.860 --> 25:27.860]  до g,
[25:27.860 --> 25:29.860]  ну и в конце печатаю g.
[25:31.860 --> 25:33.860]  Нет, не буду печатать g.
[25:33.860 --> 25:35.860]  Сначала понятен, я сначала дошел сюда,
[25:35.860 --> 25:37.860]  как бы рекурсивно попросил
[25:37.860 --> 25:39.860]  найти вот этот путь оптимальный
[25:39.860 --> 25:41.860]  из i до k, потом напечатал k,
[25:41.860 --> 25:43.860]  и потом от k ищу оптимальный путь
[25:43.860 --> 25:45.860]  до g.
[25:49.860 --> 25:51.860]  Значит смысл у этого k на самом деле такой,
[25:51.860 --> 25:53.860]  что это вершина с максимальным номером
[25:53.860 --> 25:55.860]  на кратчайшем пути,
[25:55.860 --> 25:57.860]  потому что у меня вот эти обновления происходят
[25:57.860 --> 25:59.860]  до тех пор, пока, то есть у меня вот это gt,
[25:59.860 --> 26:01.860]  gt уменьшается, уменьшается,
[26:01.860 --> 26:03.860]  потому что он уменьшилось
[26:03.860 --> 26:05.860]  для вершины с максимальным номером
[26:05.860 --> 26:07.860]  среди всех на этом пути.
[26:07.860 --> 26:09.860]  То есть по факту p, it, gt это всегда
[26:09.860 --> 26:11.860]  максимальный номер вершины
[26:15.860 --> 26:17.860]  на кратчайшем пути от i до g.
[26:27.860 --> 26:29.860]  Ну и тогда соответственно мне нужно
[26:29.860 --> 26:31.860]  в середине напечатать где-то там по центру,
[26:31.860 --> 26:33.860]  и соответственно решить задачу
[26:33.860 --> 26:35.860]  на первой половинке, на второй половинке
[26:35.860 --> 26:37.860]  рекурсивно.
[26:39.860 --> 26:41.860]  Вот такое простое замечание нам
[26:41.860 --> 26:43.860]  позволяет восстановить ответ
[26:43.860 --> 26:45.860]  целиком.
[26:51.860 --> 26:53.860]  Еще раз?
[26:53.860 --> 26:55.860]  Ну зависит от реализации,
[26:55.860 --> 26:57.860]  то есть смотрите у меня сейчас получается
[26:57.860 --> 26:59.860]  что он рекурсивно
[26:59.860 --> 27:01.860]  выводит путь
[27:03.860 --> 27:05.860]  где i включительно,
[27:05.860 --> 27:07.860]  а g не включительно, вот так.
[27:07.860 --> 27:09.860]  Тогда это напечатало все
[27:09.860 --> 27:11.860]  от i до p и g, кроме
[27:11.860 --> 27:13.860]  p и g, потом p и g.
[27:13.860 --> 27:15.860]  Так, плохо, да?
[27:15.860 --> 27:17.860]  Тогда давайте вот это можно зачеркнуть.
[27:21.860 --> 27:23.860]  Ой, неприятно.
[27:23.860 --> 27:25.860]  В смысле не включая ни и ни и g?
[27:29.860 --> 27:31.860]  Так, это интереснее,
[27:31.860 --> 27:33.860]  давайте подумаем.
[27:33.860 --> 27:35.860]  Не включая ни и ни и g, тогда здесь
[27:35.860 --> 27:37.860]  да, и в конце еще напечатать и в начале
[27:37.860 --> 27:39.860]  и в конце. Да, вы правы, можно так?
[27:39.860 --> 27:41.860]  Да, действительно. Так, наверное, проще всего.
[27:41.860 --> 27:43.860]  Чтобы у нас вершины не дублировались как раз,
[27:43.860 --> 27:45.860]  включать границы не очень хочется.
[27:49.860 --> 27:51.860]  Ну потому что смотрите,
[27:51.860 --> 27:53.860]  когда у нас в последний раз присвоилось
[27:53.860 --> 27:55.860]  p и t житое,
[27:55.860 --> 27:57.860]  то есть у меня g и t житое, оно несколько раз обновлялось
[27:57.860 --> 27:59.860]  на разных итерациях k.
[27:59.860 --> 28:01.860]  И в последний раз оно
[28:01.860 --> 28:03.860]  обновится на какой-то конкретной итерации k,
[28:03.860 --> 28:05.860]  это означает,
[28:05.860 --> 28:07.860]  что чтобы попасть из i в g,
[28:07.860 --> 28:09.860]  мне нужно сначала из i попасть в k,
[28:09.860 --> 28:11.860]  потом из k в g. Но при этом
[28:11.860 --> 28:13.860]  вот это что такое? Это же dp,
[28:13.860 --> 28:15.860]  dp и t житое kt.
[28:15.860 --> 28:17.860]  А dp это как раз
[28:17.860 --> 28:19.860]  мне можно использовать только
[28:19.860 --> 28:21.860]  не больше чем k. И k есть, поэтому это максимально.
[28:35.860 --> 28:37.860]  Мы, получается, решили задачу про
[28:37.860 --> 28:39.860]  все попарные крайнейшие расстояния.
[28:39.860 --> 28:41.860]  Хорошо.
[28:49.860 --> 28:51.860]  И теперь переходим к последней
[28:51.860 --> 28:53.860]  популярной постановке.
[28:53.860 --> 28:55.860]  Это поиск корочайшей пути
[28:55.860 --> 28:57.860]  от s до t.
[28:57.860 --> 28:59.860]  Это будет у нас алгоритм a звездочка,
[28:59.860 --> 29:01.860]  а звездочка
[29:01.860 --> 29:03.860]  поиск
[29:03.860 --> 29:05.860]  dist st.
[29:07.860 --> 29:09.860]  То есть у меня фиксировано и начало,
[29:09.860 --> 29:11.860]  и конец. Другая крайность.
[29:11.860 --> 29:13.860]  Если до этого у меня начало-конец были любые,
[29:13.860 --> 29:15.860]  то есть мне нужно для каждой пары
[29:15.860 --> 29:17.860]  определить, то здесь нужно
[29:17.860 --> 29:19.860]  для конкретного начала и конкретного конца
[29:19.860 --> 29:21.860]  найти корочайшее расстояние.
[29:21.860 --> 29:23.860]  st фиксирован.
[29:31.860 --> 29:33.860]  Еще будем делать.
[29:33.860 --> 29:35.860]  Ну, тут на самом деле
[29:35.860 --> 29:37.860]  опять мне нужно, чтобы все ребра были не отрицательные.
[29:39.860 --> 29:41.860]  А весовая функция
[29:41.860 --> 29:43.860]  бьет в ноль плюс бесконечность.
[29:43.860 --> 29:45.860]  Своя функция не отрицательна у меня.
[29:47.860 --> 29:49.860]  И во многом алгоритм будет очень похож
[29:49.860 --> 29:51.860]  на dx.
[29:59.860 --> 30:01.860]  Интуиция здесь такая, смотрите.
[30:01.860 --> 30:03.860]  Вот раньше в dx мы делали
[30:03.860 --> 30:05.860]  примерно следующее. Мы находили
[30:05.860 --> 30:07.860]  из исходной вершины s
[30:07.860 --> 30:09.860]  оценки на корочайшей
[30:09.860 --> 30:11.860]  оцене до всех вершин.
[30:11.860 --> 30:13.860]  Там были всякие вершинки v.
[30:13.860 --> 30:15.860]  Мы вводили, давайте я это обозначу
[30:15.860 --> 30:17.860]  g от v, это оценка
[30:17.860 --> 30:19.860]  на корочайшее расстояние от s до v.
[30:19.860 --> 30:21.860]  Оценка сверху.
[30:21.860 --> 30:23.860]  Это длина одного из путей, и дальше
[30:23.860 --> 30:25.860]  мы находили вершину с минимальным g от v,
[30:25.860 --> 30:27.860]  которая еще не использована, объявляли, что это
[30:27.860 --> 30:29.860]  и есть настоящее расстояние,
[30:29.860 --> 30:31.860]  и потом что-то раскрывали.
[30:31.860 --> 30:33.860]  А звездочка делает чуть похитрее.
[30:33.860 --> 30:35.860]  Он не только использует
[30:35.860 --> 30:37.860]  длину вот этого пути
[30:37.860 --> 30:39.860]  от s до v,
[30:39.860 --> 30:41.860]  он еще и откуда-то пытается оценить
[30:41.860 --> 30:43.860]  длину пути от v до t.
[30:43.860 --> 30:45.860]  И если g от v это длина
[30:45.860 --> 30:47.860]  вот этого пути, ну оценка на
[30:47.860 --> 30:49.860]  этот путь, то h от v
[30:49.860 --> 30:51.860]  я буду обозначать оценку на длину
[30:51.860 --> 30:53.860]  вот этого пути.
[30:53.860 --> 30:55.860]  То есть я буду считывать не только,
[30:55.860 --> 30:57.860]  поскольку у меня есть некая
[30:57.860 --> 30:59.860]  цель, некий t, куда я хочу добраться,
[30:59.860 --> 31:01.860]  я могу еще оптимизировать
[31:01.860 --> 31:03.860]  наш алгоритм так, чтобы он использовал
[31:03.860 --> 31:05.860]  какую-то оценку
[31:05.860 --> 31:07.860]  на то, сколько осталось до конца.
[31:07.860 --> 31:09.860]  Вот, и если я обозначу f от v
[31:11.860 --> 31:13.860]  через, ну точнее,
[31:13.860 --> 31:15.860]  как g от v плюс h от v,
[31:17.860 --> 31:19.860]  то, грубо говоря, а звездочка
[31:19.860 --> 31:21.860]  это dx
[31:23.860 --> 31:25.860]  на функции f.
[31:27.860 --> 31:29.860]  То есть у меня, я буду в кучу
[31:29.860 --> 31:31.860]  складывать вершины,
[31:31.860 --> 31:33.860]  которые упорядочены по значению
[31:33.860 --> 31:35.860]  функции f. И в каком-то смысле
[31:35.860 --> 31:37.860]  я буду доставать вершины из кучи,
[31:37.860 --> 31:39.860]  то есть у меня там куча была в dx-ре,
[31:39.860 --> 31:41.860]  вот я буду доставать вершины из кучи
[31:41.860 --> 31:43.860]  в порядке возрастания f. То есть я буду их
[31:43.860 --> 31:45.860]  сравнивать не по вот этому вот пути,
[31:45.860 --> 31:47.860]  не по длине, пути, которые я уже нашел,
[31:47.860 --> 31:49.860]  а суммарный путь
[31:49.860 --> 31:51.860]  от s до v и от v до t, где путь
[31:51.860 --> 31:53.860]  от v до t это какая-то оценка, какая-то функция h
[31:53.860 --> 31:55.860]  волшебная.
[31:55.860 --> 31:57.860]  Вот. И вот если я
[31:57.860 --> 31:59.860]  все вершины буду сравнивать
[31:59.860 --> 32:01.860]  по значению этой функции f,
[32:01.860 --> 32:03.860]  тогда я, в принципе, могу добиться того, чтобы
[32:03.860 --> 32:05.860]  это работало еще, короче, чуть эффективнее,
[32:05.860 --> 32:07.860]  чем до икстра,
[32:07.860 --> 32:09.860]  в каких-то случаях оно работает чуть-чуть быстрее.
[32:09.860 --> 32:11.860]  Перерыв, потом продолжим про звездочку.
[32:11.860 --> 32:13.860]  Последний рывок.
[32:17.860 --> 32:19.860]  Давайте я расшифрую то, что я
[32:19.860 --> 32:21.860]  тут сказал на таком высоком уровне,
[32:21.860 --> 32:23.860]  как у нас работает та звездочка конкретно.
[32:27.860 --> 32:29.860]  Вот функция h, повторю, это какая-то
[32:29.860 --> 32:31.860]  оценка на расстояние
[32:31.860 --> 32:33.860]  от s до t. Я буду называть
[32:33.860 --> 32:35.860]  эвристика.
[32:35.860 --> 32:37.860]  h, эвристика.
[32:39.860 --> 32:41.860]  Значит, самый приятный
[32:41.860 --> 32:43.860]  пример, как можно про это думать,
[32:43.860 --> 32:45.860]  представьте себе, что наш весь граф
[32:45.860 --> 32:47.860]  он лежит на плоскости.
[32:47.860 --> 32:49.860]  То есть у меня вершины это точки на плоскости,
[32:49.860 --> 32:51.860]  а ребра, ну это какие-то вот,
[32:51.860 --> 32:53.860]  вот я там картинку рисовал,
[32:53.860 --> 32:55.860]  ребра это прямолинейные отрезки между ними,
[32:55.860 --> 32:57.860]  прямолинейные векторы между ними.
[32:57.860 --> 32:59.860]  Тогда смотрите, какой может быть,
[32:59.860 --> 33:01.860]  длина ребра это просто длина
[33:01.860 --> 33:03.860]  отрезка. Такая простая геометрическая
[33:03.860 --> 33:05.860]  интерпретация.
[33:05.860 --> 33:07.860]  Тогда в качестве h от v
[33:07.860 --> 33:09.860]  можно взять
[33:09.860 --> 33:11.860]  расстояние на плоскости
[33:11.860 --> 33:13.860]  между v и t.
[33:13.860 --> 33:15.860]  Потому что понятно, что любой путь от v до t
[33:15.860 --> 33:17.860]  имеет расстояние хотя бы вот эта вот
[33:17.860 --> 33:19.860]  евкелидовая длина вот этого отрезка.
[33:19.860 --> 33:21.860]  Потому что если какие-то ребра, то есть возможно
[33:21.860 --> 33:23.860]  вот так надо идти, понятно, что это
[33:23.860 --> 33:25.860]  больше либо равно, чем
[33:25.860 --> 33:27.860]  этот отрезок.
[33:27.860 --> 33:29.860]  h это в каком-то смысле приближение
[33:29.860 --> 33:31.860]  на ответ.
[33:31.860 --> 33:33.860]  Даже абсолютно не зная, как именно устроен граф,
[33:33.860 --> 33:35.860]  скорее зная,
[33:35.860 --> 33:37.860]  как устроена задача.
[33:37.860 --> 33:39.860]  Все точки на плоскости или там,
[33:39.860 --> 33:41.860]  все это, это какая-нибудь головоломка.
[33:41.860 --> 33:43.860]  Если вершина это состояние
[33:43.860 --> 33:45.860]  головоломки, то мы можем
[33:45.860 --> 33:47.860]  как-нибудь уметь оценивать
[33:47.860 --> 33:49.860]  расстояние между двумя состояниями головоломки.
[33:49.860 --> 33:51.860]  Например, если у нас есть какой-нибудь кубик Рубика,
[33:51.860 --> 33:53.860]  или вот в контесте будет задача про пятнашки,
[33:53.860 --> 33:55.860]  если есть два состояния таблички
[33:55.860 --> 33:57.860]  или два состояния кубика,
[33:57.860 --> 33:59.860]  то мы можем как-нибудь оценить расстояние между ними.
[33:59.860 --> 34:01.860]  Понимаем, что они сильно различаются.
[34:01.860 --> 34:03.860]  Чем больше они различаются,
[34:03.860 --> 34:05.860]  тем больше надо сделать действия, чтобы определить их одно в другое.
[34:07.860 --> 34:09.860]  И вот в каком-то смысле нужна функция,
[34:09.860 --> 34:11.860]  пытающаяся оценивать непохожесть вершин.
[34:11.860 --> 34:13.860]  На плоскости, например,
[34:13.860 --> 34:15.860]  эффективного расстояния, в головоломках
[34:15.860 --> 34:17.860]  это зависит от того, какая головоломка,
[34:17.860 --> 34:19.860]  насколько непохоже состояние.
[34:19.860 --> 34:21.860]  Вот это надо как-то измерять, уметь.
[34:21.860 --> 34:23.860]  Это эвристика, давайте напишу,
[34:23.860 --> 34:25.860]  насколько непохоже ВИТ.
[34:33.860 --> 34:35.860]  Если h правильно, то да.
[34:35.860 --> 34:37.860]  Я еще соролирую теорему.
[34:41.860 --> 34:43.860]  При достаточно простом условии на h
[34:43.860 --> 34:45.860]  он не хуже, чем dx.
[34:45.860 --> 34:47.860]  То есть он работает немедленно
[34:47.860 --> 34:49.860]  и всегда вызывает правильный ответ.
[34:49.860 --> 34:51.860]  Так что это не бесполезно.
[34:51.860 --> 34:53.860]  А g от v,
[34:53.860 --> 34:55.860]  это как обычно,
[34:55.860 --> 34:57.860]  g от v
[34:57.860 --> 34:59.860]  это
[34:59.860 --> 35:01.860]  текущая найденная
[35:03.860 --> 35:05.860]  текущая
[35:05.860 --> 35:07.860]  найденная длина пути вот s до v.
[35:13.860 --> 35:15.860]  Тогда как работает алгоритм?
[35:17.860 --> 35:19.860]  Я считаю, что вектор
[35:19.860 --> 35:21.860]  давайте double,
[35:21.860 --> 35:23.860]  на всякий случай, раз уж я
[35:23.860 --> 35:25.860]  заговорил про расстояние на плоскости.
[35:25.860 --> 35:27.860]  Пусть у меня вектор double g есть,
[35:27.860 --> 35:29.860]  он изначально заполнен плюс бесконечностями,
[35:29.860 --> 35:31.860]  а h такая-то функция.
[35:31.860 --> 35:33.860]  Напоминаю, что h
[35:33.860 --> 35:35.860]  она не зависит от того,
[35:35.860 --> 35:37.860]  что ваш алгоритм поделал.
[35:37.860 --> 35:39.860]  Она не зависит от того, какие вершины вы рассмотрели,
[35:39.860 --> 35:41.860]  что раскрыли и так далее.
[35:41.860 --> 35:43.860]  h это просто какая-то функция,
[35:43.860 --> 35:45.860]  которая по двум положениям v и t
[35:45.860 --> 35:47.860]  говорит, ну, возвращать какое-то число.
[35:47.860 --> 35:49.860]  Поэтому я ее не буду хранить в качестве массива,
[35:49.860 --> 35:51.860]  будет отдельная функция,
[35:51.860 --> 35:53.860]  которая там, когда надо, буду дергать.
[35:53.860 --> 35:55.860]  Значит, вектор g
[35:55.860 --> 35:57.860]  и вектор f
[36:05.860 --> 36:07.860]  Изначально, да, начало,
[36:07.860 --> 36:09.860]  это когда g от s равно 0,
[36:09.860 --> 36:11.860]  а f от s
[36:11.860 --> 36:13.860]  равно h от s.
[36:13.860 --> 36:15.860]  Потому что если я ищу пути
[36:15.860 --> 36:17.860]  из s, то, собственно, длина пути
[36:17.860 --> 36:19.860]  от s до s равно 0,
[36:19.860 --> 36:21.860]  а f от s как сумма g и h,
[36:21.860 --> 36:23.860]  напоминаю, вот у меня формула,
[36:23.860 --> 36:25.860]  f это сумма g плюс h.
[36:25.860 --> 36:27.860]  g нулевая, поэтому мне нужно просто h здесь написать,
[36:27.860 --> 36:29.860]  h от s.
[36:29.860 --> 36:31.860]  h это какая-то оценка на расстоянии от s до t.
[36:31.860 --> 36:33.860]  Вот.
[36:33.860 --> 36:35.860]  Ну и все, нужна какая-то куча,
[36:35.860 --> 36:37.860]  куда я добавлю вершину s
[36:39.860 --> 36:41.860]  вот с этим значением f.
[36:41.860 --> 36:43.860]  Давайте я словами напишу,
[36:43.860 --> 36:45.860]  нужна какая-то куча,
[36:45.860 --> 36:47.860]  куча q,
[36:47.860 --> 36:49.860]  где хранятся вершины,
[36:55.860 --> 36:57.860]  упорядоченные по f,
[36:57.860 --> 36:59.860]  по значению f.
[37:01.860 --> 37:03.860]  Ну, скорее не упорядоченные,
[37:03.860 --> 37:05.860]  а сравниваемые,
[37:05.860 --> 37:07.860]  сравниваемые по f,
[37:07.860 --> 37:09.860]  по значению f.
[37:09.860 --> 37:11.860]  То есть, если раньше у меня куча была на g,
[37:11.860 --> 37:13.860]  по факту у меня ключом
[37:13.860 --> 37:15.860]  выступало найденное расстояние
[37:15.860 --> 37:17.860]  до вершины,
[37:17.860 --> 37:19.860]  то теперь ключом будет f,
[37:19.860 --> 37:21.860]  то есть не только g,
[37:21.860 --> 37:23.860]  но g плюс h скорее.
[37:23.860 --> 37:25.860]  Вот.
[37:25.860 --> 37:27.860]  Значит, дальше, пока куча не пустая,
[37:27.860 --> 37:29.860]  куча не пустая,
[37:35.860 --> 37:37.860]  ну тут все просто,
[37:37.860 --> 37:39.860]  значит, давайте напишу q,
[37:39.860 --> 37:41.860]  точка экстракт мин.
[37:47.860 --> 37:49.860]  Дальше раскрытие вершины,
[37:49.860 --> 37:51.860]  как мы любим.
[37:51.860 --> 37:53.860]  То есть, я перебираю все ребра.
[37:57.860 --> 37:59.860]  Так, ну здесь у меня g уже занято,
[37:59.860 --> 38:01.860]  давайте я граф назову.
[38:01.860 --> 38:03.860]  Граф vt.
[38:03.860 --> 38:05.860]  Раскрытие.
[38:05.860 --> 38:07.860]  Ну раскрытие вершины влияет только на g.
[38:07.860 --> 38:09.860]  То есть, я по факту
[38:09.860 --> 38:11.860]  нахожу какое-то расстояние
[38:11.860 --> 38:13.860]  до вершины e.tu,
[38:13.860 --> 38:15.860]  и мне нужно, если что, обновить значение g,
[38:15.860 --> 38:17.860]  и, если надо, значение f,
[38:17.860 --> 38:19.860]  если g изменилось.
[38:19.860 --> 38:21.860]  Ну давайте я напишу x равно
[38:21.860 --> 38:23.860]  g вот v
[38:23.860 --> 38:25.860]  плюс e.cost,
[38:25.860 --> 38:27.860]  если x
[38:27.860 --> 38:29.860]  меньшим g вот e.tu,
[38:29.860 --> 38:31.860]  то есть, если до e.tu я нашел
[38:31.860 --> 38:33.860]  более короткий путь,
[38:33.860 --> 38:35.860]  то я его обновляю,
[38:39.860 --> 38:41.860]  наставлю на x,
[38:41.860 --> 38:43.860]  соответственно, обновляю f,
[38:43.860 --> 38:45.860]  как x плюс h
[38:45.860 --> 38:47.860]  вот e.tu.
[38:49.860 --> 38:51.860]  Ну и здесь нужно еще
[38:51.860 --> 38:53.860]  сказать, что у вершины e.tu
[38:53.860 --> 38:55.860]  есть значение f,
[38:55.860 --> 38:57.860]  то есть, у вершины e.tu
[38:57.860 --> 38:59.860]  сказать, что у вершины e.tu
[38:59.860 --> 39:01.860]  изменился ключ.
[39:01.860 --> 39:03.860]  То есть, если раньше у нее было какое-то свое значение f,
[39:03.860 --> 39:05.860]  то теперь у нее значение f уменьшилось
[39:05.860 --> 39:07.860]  и стало вот таким.
[39:07.860 --> 39:09.860]  И значит, мне в куче надо сделать decrease key.
[39:09.860 --> 39:11.860]  Ну, либо decrease key, если она там уже есть,
[39:11.860 --> 39:13.860]  либо, если нет, нужно сделать инферт.
[39:13.860 --> 39:15.860]  Соответственно, здесь нужно вставить
[39:17.860 --> 39:19.860]  e.tu в кучу
[39:19.860 --> 39:21.860]  q, или сделать
[39:21.860 --> 39:23.860]  decrease key.
[39:23.860 --> 39:25.860]  Или сделать decrease key.
[39:25.860 --> 39:27.860]  Decrease key.
[39:29.860 --> 39:31.860]  Потому что у меня могло быть такое,
[39:31.860 --> 39:33.860]  что ее в куче не было, я туда просто добавляю
[39:33.860 --> 39:35.860]  с таким вот ключом f,
[39:35.860 --> 39:37.860]  значение f.
[39:37.860 --> 39:39.860]  Либо же она там уже была,
[39:39.860 --> 39:41.860]  с другим значением f, со старым значением f.
[39:41.860 --> 39:43.860]  Вот я ее обновляю, я уменьшил у нее f,
[39:43.860 --> 39:45.860]  а значит, мне нужно сделать decrease key у нее.
[39:45.860 --> 39:47.860]  У нее изменился параметр,
[39:47.860 --> 39:49.860]  по которому они сравниваются.
[39:49.860 --> 39:51.860]  Ну и все, раскрытие, как обычно.
[39:51.860 --> 39:53.860]  Так, скобка, скобка, скобка.
[39:55.860 --> 39:57.860]  Все, конец.
[39:57.860 --> 39:59.860]  Только здесь я еще вставлю
[39:59.860 --> 40:01.860]  одну строчку.
[40:01.860 --> 40:03.860]  Если выравну t,
[40:03.860 --> 40:05.860]  break.
[40:07.860 --> 40:09.860]  Я не работаю дальше,
[40:09.860 --> 40:11.860]  если я нашел t в нашей
[40:11.860 --> 40:13.860]  куче.
[40:21.860 --> 40:23.860]  Вот такой странный алгоритм.
[40:23.860 --> 40:25.860]  То есть по факту это dx,
[40:25.860 --> 40:27.860]  которая еще, то есть она учитывает
[40:27.860 --> 40:29.860]  не только найденное расстояние, но еще и
[40:29.860 --> 40:31.860]  плюс оценка до конца.
[40:31.860 --> 40:33.860]  Плюс плюс h от v,
[40:33.860 --> 40:35.860]  где h такая-то оценка
[40:35.860 --> 40:37.860]  на расстояние от v до t.
[40:37.860 --> 40:39.860]  Значит, теперь, насколько это все
[40:39.860 --> 40:41.860]  адекватно?
[40:41.860 --> 40:43.860]  Когда это работает?
[40:43.860 --> 40:45.860]  Это определение.
[40:47.860 --> 40:49.860]  Эвристика h
[40:49.860 --> 40:51.860]  называется допустимой
[40:55.860 --> 40:57.860]  если
[40:59.860 --> 41:01.860]  если эта оценка снизу надист.
[41:09.860 --> 41:11.860]  Ну вот, когда я рисовал там
[41:11.860 --> 41:13.860]  картинку на плоскости, я говорю, что
[41:13.860 --> 41:15.860]  можно расстояние оценить, как
[41:15.860 --> 41:17.860]  расстояние на плоскости.
[41:17.860 --> 41:19.860]  Можно расстояние оценить, как
[41:19.860 --> 41:21.860]  настоящие вклиды в расстоянии между точками.
[41:21.860 --> 41:23.860]  Понятно, что меньше быть нельзя.
[41:23.860 --> 41:25.860]  То есть наша настоящая дист
[41:25.860 --> 41:27.860]  было больше либо равно, чем h от v.
[41:27.860 --> 41:29.860]  Больше либо равно, чем
[41:29.860 --> 41:31.860]  какая-то вот эта нижняя оценка, как
[41:31.860 --> 41:33.860]  самый короткий потенциально возможный путь.
[41:33.860 --> 41:35.860]  Значит, тогда такая эвристика допустимая.
[41:35.860 --> 41:37.860]  Дальше эвристика называется
[41:37.860 --> 41:39.860]  монотонной.
[41:41.860 --> 41:43.860]  Называется монотонной
[41:43.860 --> 41:45.860]  если
[41:49.860 --> 41:51.860]  во-первых, h от t равно 0,
[41:53.860 --> 41:55.860]  во-вторых, выполняется неравенство треугольника.
[41:57.860 --> 41:59.860]  Выполняется неравенство треугольника.
[42:01.860 --> 42:03.860]  Значит, что это за неравенство?
[42:05.860 --> 42:07.860]  Это такое неравенство.
[42:07.860 --> 42:09.860]  Если есть ребро из u в v,
[42:09.860 --> 42:11.860]  то h от u
[42:11.860 --> 42:13.860]  больше, чем h от v,
[42:13.860 --> 42:15.860]  плюс кост ребра у v.
[42:21.860 --> 42:23.860]  Почему неравенство треугольника?
[42:23.860 --> 42:25.860]  Потому что h от v это оценка длины пути
[42:25.860 --> 42:27.860]  от v до t,
[42:27.860 --> 42:29.860]  а h от u это оценка длины пути
[42:29.860 --> 42:31.860]  от u до t.
[42:31.860 --> 42:33.860]  И вот я говорю, что этот путь
[42:33.860 --> 42:35.860]  не больше, чем вот этот путь.
[42:35.860 --> 42:37.860]  Неравенство треугольника.
[42:37.860 --> 42:39.860]  Добраться от u до t точно
[42:39.860 --> 42:41.860]  будет не больше времени, чем от v до t
[42:41.860 --> 42:43.860]  плюс от u до v.
[42:43.860 --> 42:45.860]  Неравенство треугольника в чистом виде.
[42:45.860 --> 42:47.860]  Вот тогда, видите, называется монотонной.
[43:03.860 --> 43:05.860]  Ну, в частности, пример, когда я приводил
[43:05.860 --> 43:07.860]  Евклидову плоскость,
[43:07.860 --> 43:09.860]  равную расстоянию Евклидову от v до t,
[43:09.860 --> 43:11.860]  это даже монотонная еврестика.
[43:11.860 --> 43:13.860]  Не просто допустимая, но еще и монотонная.
[43:13.860 --> 43:15.860]  Ну, потому что понятно, что расстояние
[43:15.860 --> 43:17.860]  от t до t равно 0, и понятно, что
[43:17.860 --> 43:19.860]  Евклидовое расстояние подчиняется неравенству треугольника.
[43:21.860 --> 43:23.860]  Значит, замечание.
[43:23.860 --> 43:25.860]  Монотонная еврестика является допустимой.
[43:37.860 --> 43:39.860]  Монотонная еврестика является допустимой.
[43:43.860 --> 43:45.860]  То есть, если верно вот это,
[43:45.860 --> 43:47.860]  то верно вот это вот.
[43:49.860 --> 43:51.860]  Ну, это вроде просто.
[43:53.860 --> 43:55.860]  Давайте мы с конца пройдем.
[43:55.860 --> 43:57.860]  Значит, ht равно 0. То есть, я доказываю, что если верно вот это,
[43:57.860 --> 43:59.860]  то верно вот это. Значит, я знаю, что ht равно 0.
[44:01.860 --> 44:03.860]  Понятно, что тогда ht не больше
[44:03.860 --> 44:05.860]  чем d100t до t. Они все нули.
[44:05.860 --> 44:07.860]  Давайте рассмотрим все входящие сюда ребра.
[44:09.860 --> 44:11.860]  По неравенству треугольника я знаю,
[44:11.860 --> 44:13.860]  что h везде вот здесь
[44:13.860 --> 44:15.860]  не больше, чем длина этого ребра.
[44:15.860 --> 44:17.860]  Поэтому h везде
[44:17.860 --> 44:19.860]  вот здесь не больше, чем настоящий дист.
[44:21.860 --> 44:23.860]  Дальше провожу вот эти все ребра.
[44:23.860 --> 44:25.860]  Ну и аналогично, получается,
[44:25.860 --> 44:27.860]  что немедленно с помощью неравенства треугольника
[44:27.860 --> 44:29.860]  я получаю, что h вот отсюда
[44:29.860 --> 44:31.860]  точно не больше, чем дист.
[44:31.860 --> 44:33.860]  То есть, если есть какое-то настоящее расстояние
[44:33.860 --> 44:35.860]  по неравенству треугольника,
[44:35.860 --> 44:37.860]  то по неравенству треугольника
[44:37.860 --> 44:39.860]  h вот здесь точно не больше, чем
[44:39.860 --> 44:41.860]  это самое кратчаше расстояние.
[44:41.860 --> 44:43.860]  Если не поняли, то и фиг с ним.
[44:47.860 --> 44:49.860]  Теорема.
[44:51.860 --> 44:53.860]  Если еврестика монотонна,
[44:53.860 --> 44:55.860]  то вот то, что я говорил,
[44:55.860 --> 44:57.860]  алгоритм всегда корректен
[44:57.860 --> 44:59.860]  и всегда работает не хуже, чем dx.
[44:59.860 --> 45:01.860]  Если h монотонная,
[45:05.860 --> 45:07.860]  то
[45:09.860 --> 45:11.860]  а звездочка
[45:11.860 --> 45:13.860]  всегда находит правильный ответ.
[45:21.860 --> 45:23.860]  И более того, каждую вершину
[45:23.860 --> 45:25.860]  раскрывает не более одного раза.
[45:25.860 --> 45:27.860]  И раскрывает
[45:29.860 --> 45:31.860]  напомню, что раскрытие
[45:31.860 --> 45:33.860]  это вот этот цикл по всем исходящим ребрам.
[45:33.860 --> 45:35.860]  И раскрывает каждую вершину
[45:41.860 --> 45:43.860]  не больше одного раза.
[45:47.860 --> 45:49.860]  Ну, значит, это не хуже, чем dx.
[45:49.860 --> 45:51.860]  Ответ правильный,
[45:51.860 --> 45:53.860]  ну а симптотика тоже
[45:53.860 --> 45:55.860]  имлоген получается.
[45:55.860 --> 45:57.860]  Потому что каждая вершина раскроется максимум один раз,
[45:57.860 --> 45:59.860]  значит, каждый ребро рассмотрится максимум один раз.
[45:59.860 --> 46:01.860]  Ну и дальше куча, как обычно.
[46:01.860 --> 46:03.860]  Второе. Если еврестика только допустима,
[46:03.860 --> 46:05.860]  но не обязательно монотонна,
[46:05.860 --> 46:07.860]  то ответ-то тоже правильный будет.
[46:07.860 --> 46:09.860]  Но, возможно, симптотика сломается.
[46:11.860 --> 46:13.860]  Если h всего лишь допустимая,
[46:17.860 --> 46:19.860]  то а звездочка
[46:19.860 --> 46:21.860]  всегда находит правильный ответ.
[46:23.860 --> 46:25.860]  Но, возможно, за экспоненциально долгое время.
[46:29.860 --> 46:31.860]  Но, возможно,
[46:31.860 --> 46:33.860]  за экспоненциальное время.
[46:37.860 --> 46:39.860]  Вот. И третий пункт.
[46:39.860 --> 46:41.860]  Если h недопустимая,
[46:47.860 --> 46:49.860]  то а звездочка
[46:49.860 --> 46:51.860]  всегда находит правильный ответ.
[46:53.860 --> 46:55.860]  То все плохо.
[46:55.860 --> 46:57.860]  В том плане, что
[46:57.860 --> 46:59.860]  нет гарантии ни на то, ни на другое,
[46:59.860 --> 47:01.860]  нет гарантии ни на правильность ответа,
[47:01.860 --> 47:03.860]  ни на какое-то быстрое время работы.
[47:03.860 --> 47:05.860]  Но,
[47:05.860 --> 47:07.860]  тут как бы некая магия есть,
[47:07.860 --> 47:09.860]  в зависимости от задачи,
[47:09.860 --> 47:11.860]  может быть такое, что h обеспечивает
[47:11.860 --> 47:13.860]  довольно хорошее приближение на ответ
[47:13.860 --> 47:15.860]  и работает довольно быстро.
[47:15.860 --> 47:17.860]  Давайте я так и напишу,
[47:17.860 --> 47:19.860]  что это значит, не буду раскрывать.
[47:19.860 --> 47:21.860]  Значит, то
[47:21.860 --> 47:23.860]  а звездочка
[47:23.860 --> 47:25.860]  может найти
[47:27.860 --> 47:29.860]  довольно хорошее приближение
[47:29.860 --> 47:31.860]  к ответу.
[47:41.860 --> 47:43.860]  Ну, то есть, скажем, если настоящий дист
[47:43.860 --> 47:45.860]  это 100%,
[47:45.860 --> 47:47.860]  то, например, вот эта штука найдет
[47:47.860 --> 47:49.860]  путь длины не больше 110%.
[47:49.860 --> 47:51.860]  То есть, там небольшая погрешность будет.
[47:51.860 --> 47:53.860]  Не обязательно правильный ответ,
[47:53.860 --> 47:55.860]  но близко к оптимуму.
[47:55.860 --> 47:57.860]  С точностью до какой-нибудь погрешности.
[47:59.860 --> 48:01.860]  За довольно хорошее время.
[48:07.860 --> 48:09.860]  Ну, как бы близко к д-экстре.
[48:11.860 --> 48:13.860]  Да, конечно.
[48:13.860 --> 48:15.860]  Ну, это утверждение я пишу в качестве
[48:15.860 --> 48:17.860]  обзорного, понятно, что я его не могу
[48:17.860 --> 48:19.860]  сформулировать корректно, потому что
[48:23.860 --> 48:25.860]  можете его не писать на экзамене.
[48:25.860 --> 48:27.860]  Это просто для формирования
[48:27.860 --> 48:29.860]  какого-то понимания, что здесь происходит.
[48:29.860 --> 48:31.860]  То есть, на самом деле, еще раз,
[48:31.860 --> 48:33.860]  если h недопустимое, то
[48:33.860 --> 48:35.860]  а звездочка может вернуть неправильный ответ
[48:35.860 --> 48:37.860]  и работать при этом экспенсально долго.
[48:37.860 --> 48:39.860]  То есть, с теоретической точки зрения
[48:39.860 --> 48:41.860]  вот это содержательное,
[48:41.860 --> 48:43.860]  с практической точки зрения
[48:43.860 --> 48:45.860]  иногда бывают такие h,
[48:45.860 --> 48:47.860]  что на конкретных задачах
[48:47.860 --> 48:49.860]  находит достаточно хорошее приближение
[48:49.860 --> 48:51.860]  достаточно быстро.
[48:51.860 --> 48:53.860]  То есть, это уже вопрос чисто практический.
[48:53.860 --> 48:55.860]  Если вы пришли на работу,
[48:55.860 --> 48:57.860]  очень долго работаете с одним и тем же графом,
[48:57.860 --> 48:59.860]  и замечаете в нем какие-то закономерности,
[48:59.860 --> 49:01.860]  соответственно, соответственным образом
[49:01.860 --> 49:03.860]  как-то обновляете h.
[49:03.860 --> 49:05.860]  Что-то там делаете, как-то читаете эту ювелистику.
[49:05.860 --> 49:07.860]  Возможно, вы ее сможете так подхачивать,
[49:07.860 --> 49:09.860]  чтобы она делала вот это вот.
[49:09.860 --> 49:11.860]  Достаточно хорошо, достаточно быстро.
[49:11.860 --> 49:13.860]  Но это тут как бы только практика.
[49:15.860 --> 49:17.860]  То есть, у вас может получиться так,
[49:17.860 --> 49:19.860]  что она реально довольно хорошо работает,
[49:19.860 --> 49:21.860]  довольно быстро, но при этом как бы это
[49:21.860 --> 49:23.860]  свойство графа,
[49:23.860 --> 49:25.860]  а не задача в целом.
[49:33.860 --> 49:35.860]  Естественно, третий пункт
[49:35.860 --> 49:37.860]  я доказывать не буду.
[49:37.860 --> 49:39.860]  И второй тоже не буду,
[49:39.860 --> 49:41.860]  потому что там сложно и не очень интересно.
[49:41.860 --> 49:43.860]  У нас на самом деле основные ювелистики
[49:43.860 --> 49:45.860]  они монотонные всегда,
[49:45.860 --> 49:47.860]  потому что я сказал, что из монотонности следует допустимость,
[49:47.860 --> 49:49.860]  но на самом деле
[49:49.860 --> 49:51.860]  добиться того, что выполнялось
[49:51.860 --> 49:53.860]  не нравится треугольник, это не очень сложно.
[49:53.860 --> 49:55.860]  Поэтому на самом деле большинство ювелистик
[49:55.860 --> 49:57.860]  будет монотонные всегда.
[49:57.860 --> 49:59.860]  Сейчас будем доказывать первое.
[50:03.860 --> 50:05.860]  Утверждение.
[50:05.860 --> 50:07.860]  Пусть h монотонная.
[50:07.860 --> 50:09.860]  Тогда.
[50:17.860 --> 50:19.860]  Последователь значений f
[50:19.860 --> 50:21.860]  у извлекаемых из кучи вершин
[50:21.860 --> 50:23.860]  не убывает.
[50:37.860 --> 50:39.860]  Напоминаю.
[50:39.860 --> 50:41.860]  Как работает?
[50:41.860 --> 50:43.860]  Она имеет некую кучу,
[50:43.860 --> 50:45.860]  там вершины упорядочены по f,
[50:45.860 --> 50:47.860]  точнее сравниваются по f,
[50:47.860 --> 50:49.860]  ключами выступает значение f.
[50:49.860 --> 50:51.860]  Мы каждый раз извлекаем минимум.
[50:51.860 --> 50:53.860]  Взяли минимум, взяли минимум и так далее.
[50:53.860 --> 50:55.860]  Минимум по f каждый раз берем.
[50:55.860 --> 50:57.860]  И каждую вершину, когда я извлекаю из кучи,
[50:57.860 --> 50:59.860]  я ее раскрываю.
[50:59.860 --> 51:01.860]  То есть обновляю f к куче.
[51:01.860 --> 51:03.860]  И когда я извлекаю ее из кучи,
[51:03.860 --> 51:05.860]  я ее раскрываю.
[51:05.860 --> 51:07.860]  То есть обновляю f для всех вершин,
[51:07.860 --> 51:09.860]  которые из нее достижимы.
[51:09.860 --> 51:11.860]  Когда я извлекаю f,
[51:11.860 --> 51:13.860]  я ее раскрываю,
[51:13.860 --> 51:15.860]  обновляю g, обновляю f для всех этих вершин.
[51:15.860 --> 51:17.860]  И вот я утверждаю,
[51:17.860 --> 51:19.860]  что когда я поочередно
[51:19.860 --> 51:21.860]  всю кучу исчерпываю,
[51:21.860 --> 51:23.860]  забираю оттуда вершины одна за другой,
[51:23.860 --> 51:25.860]  у меня f только возрастает.
[51:25.860 --> 51:27.860]  Не может быть такого,
[51:27.860 --> 51:29.860]  что я извлек v с каким-то значением f,
[51:29.860 --> 51:31.860]  потом что-то поделал
[51:31.860 --> 51:33.860]  и извлек вершину с меньшим значением f.
[51:33.860 --> 51:35.860]  Это f не может.
[51:35.860 --> 51:39.860]  После последовательной извлечения из кучи,
[51:39.860 --> 51:41.860]  они могут только увеличивать f.
[51:41.860 --> 51:43.860]  Либо оставлять таким же, как было,
[51:43.860 --> 51:45.860]  либо только увеличивать.
[51:47.860 --> 51:49.860]  Доказательство простое.
[51:49.860 --> 51:51.860]  Давайте рассмотрим конкретное v.
[51:51.860 --> 51:53.860]  Пусть v извлекается из кучи.
[51:59.860 --> 52:01.860]  Что это значит?
[52:01.860 --> 52:03.860]  Это значит, что к моменту,
[52:03.860 --> 52:05.860]  когда она извлекается,
[52:05.860 --> 52:07.860]  ее f минимально возможный.
[52:07.860 --> 52:09.860]  То есть у всех остальных f только больше.
[52:09.860 --> 52:11.860]  f от x, f от u,
[52:11.860 --> 52:13.860]  больше равно f от v для всех u.
[52:15.860 --> 52:17.860]  Пока что нету f меньше,
[52:17.860 --> 52:19.860]  чем f от v.
[52:19.860 --> 52:21.860]  Теперь я ее раскрываю.
[52:21.860 --> 52:23.860]  Раскрываем v.
[52:23.860 --> 52:25.860]  Я давайте рассмотрю
[52:25.860 --> 52:27.860]  какое-то ребро из v в 2.
[52:27.860 --> 52:29.860]  Что я могу сказать?
[52:29.860 --> 52:31.860]  Я могу сказать, что вот здесь
[52:31.860 --> 52:33.860]  я нашел новый кратчайший путь.
[52:33.860 --> 52:35.860]  И если здесь был какой-то путь
[52:35.860 --> 52:37.860]  веса g от v,
[52:37.860 --> 52:39.860]  то есть путь из начала до v
[52:39.860 --> 52:41.860]  веса g от v,
[52:41.860 --> 52:43.860]  то теперь досюда появился
[52:43.860 --> 52:45.860]  путь веса g от v плюс
[52:45.860 --> 52:47.860]  вот этот кост.
[52:47.860 --> 52:49.860]  Давайте его назову c, плюс c.
[52:49.860 --> 52:51.860]  Плюс c.
[52:53.860 --> 52:55.860]  Тем самым я могу обновить f от 2
[52:55.860 --> 52:57.860]  через вот эту вот штуку,
[52:57.860 --> 52:59.860]  плюс еще h от 2.
[52:59.860 --> 53:01.860]  То есть
[53:01.860 --> 53:03.860]  f от 2
[53:03.860 --> 53:05.860]  может стать равным,
[53:05.860 --> 53:07.860]  может стать равным,
[53:09.860 --> 53:11.860]  может стать равным
[53:11.860 --> 53:13.860]  g от v
[53:13.860 --> 53:15.860]  плюс c,
[53:15.860 --> 53:17.860]  плюс h от 2.
[53:17.860 --> 53:19.860]  Потому что f
[53:19.860 --> 53:21.860]  это у меня всегда g плюс h,
[53:21.860 --> 53:23.860]  h я написал, а g это
[53:23.860 --> 53:25.860]  если я реально делаю обновление,
[53:25.860 --> 53:27.860]  релаксацию значения g,
[53:27.860 --> 53:29.860]  то g от 2 это g от v плюс c.
[53:31.860 --> 53:33.860]  Я хочу показать, что эта штука
[53:33.860 --> 53:35.860]  всегда больше равна,
[53:35.860 --> 53:37.860]  чем f от v.
[53:37.860 --> 53:39.860]  Вот если мы докажем,
[53:39.860 --> 53:41.860]  то мы на самом деле победили.
[53:41.860 --> 53:43.860]  Получается, что все раскрытия у меня
[53:43.860 --> 53:45.860]  сохраняют вот это неравенство,
[53:45.860 --> 53:47.860]  и у всех вершин f больше равно, чем у текущей.
[53:47.860 --> 53:49.860]  Значит, после каждого извлечения
[53:49.860 --> 53:51.860]  у меня как бы выполняется,
[53:51.860 --> 53:53.860]  что у всех остальных все равно f будет больше
[53:53.860 --> 53:55.860]  равно, чем текущая, и значит оно никогда не уменьшится.
[53:55.860 --> 53:57.860]  У извлекаемой вершины не может быть
[53:57.860 --> 53:59.860]  f меньше, чем у какой-либо из предыдущих.
[54:01.860 --> 54:03.860]  Ну почему это верно? Давайте это напишем.
[54:03.860 --> 54:05.860]  Что такое f от v?
[54:05.860 --> 54:07.860]  f от v, это g от v,
[54:07.860 --> 54:09.860]  плюс h от v.
[54:11.860 --> 54:13.860]  Это просто неравенство треугольника.
[54:13.860 --> 54:15.860]  То, что здесь осталось,
[54:15.860 --> 54:17.860]  это мне нужно показать,
[54:17.860 --> 54:19.860]  что h от v,
[54:19.860 --> 54:21.860]  ну то есть это под вопросом, я хочу это доказать,
[54:21.860 --> 54:23.860]  правда ли, что h от v
[54:23.860 --> 54:25.860]  не больше, чем h от t,
[54:25.860 --> 54:27.860]  плюс c.
[54:27.860 --> 54:29.860]  Это следует из определения,
[54:29.860 --> 54:31.860]  из неравенства треугольника.
[54:37.860 --> 54:39.860]  Вот.
[54:39.860 --> 54:41.860]  Чудесно.
[54:41.860 --> 54:43.860]  То есть получается, если h монотонно,
[54:43.860 --> 54:45.860]  то
[54:45.860 --> 54:47.860]  это реально похоже на dx.
[54:47.860 --> 54:49.860]  Я вот когда вершины исчерпываю из кучи,
[54:49.860 --> 54:51.860]  достаю из кучи одна с другой,
[54:51.860 --> 54:53.860]  у меня f возрастает, то есть расстояние до них все увеличивается и увеличивается,
[54:53.860 --> 54:55.860]  если под расстоянием понимать f.
[54:55.860 --> 54:57.860]  Но смотрите, это работает только
[54:57.860 --> 54:59.860]  в случае монотонности,
[54:59.860 --> 55:01.860]  и здесь как бы существенно требуется
[55:01.860 --> 55:03.860]  неравенство треугольника.
[55:03.860 --> 55:05.860]  Значит, если бы у меня выясник была не монотонная, а только допустимая,
[55:05.860 --> 55:07.860]  без неравенства треугольника,
[55:07.860 --> 55:09.860]  то это могло быть неверно.
[55:09.860 --> 55:11.860]  Потому что f-ки увеличиваются.
[55:11.860 --> 55:13.860]  Когда я исчерпываю кучу,
[55:13.860 --> 55:15.860]  извлекаю вершины одна с другой,
[55:15.860 --> 55:17.860]  f могли падать, могли уменьшаться,
[55:17.860 --> 55:19.860]  потому что если неравенство треугольника
[55:19.860 --> 55:21.860]  не выполняется на h только допустимо,
[55:21.860 --> 55:23.860]  но не монотонно, то f могли уменьшаться.
[55:23.860 --> 55:25.860]  Проблема этого в том, что мы тогда
[55:25.860 --> 55:27.860]  некоторые вершины могли несколько раз посещать.
[55:27.860 --> 55:29.860]  Потому что мы могли, скажем,
[55:29.860 --> 55:31.860]  добавить v в кучу каким-то образом,
[55:31.860 --> 55:33.860]  потом что-то здесь найти,
[55:33.860 --> 55:35.860]  найти еще некоторый путь
[55:35.860 --> 55:37.860]  и уменьшить f от v.
[55:37.860 --> 55:39.860]  То есть мы могли здесь найти
[55:39.860 --> 55:41.860]  новый более оптимальный путь,
[55:41.860 --> 55:43.860]  уменьшающий f от v по сравнению со старым его значением.
[55:43.860 --> 55:45.860]  Тогда v заново добавляется в кучу,
[55:45.860 --> 55:47.860]  и я ее заново обрабатываю.
[55:47.860 --> 55:49.860]  То есть у меня вершина раскрывается несколько раз одна и та же,
[55:49.860 --> 55:51.860]  но уже с разными значениями f.
[55:51.860 --> 55:53.860]  Отсюда как раз получается
[55:53.860 --> 55:55.860]  в худшем случае компонента.
[55:55.860 --> 55:57.860]  Вершина может несколько раз рассматриваться,
[55:57.860 --> 55:59.860]  несколько раз раскрываться,
[55:59.860 --> 56:01.860]  и поэтому, собственно,
[56:01.860 --> 56:03.860]  время летит к черту.
[56:07.860 --> 56:09.860]  Так, значит, теперь
[56:09.860 --> 56:11.860]  что делаем с этим утверждением?
[56:11.860 --> 56:13.860]  Как из утверждения следует
[56:13.860 --> 56:15.860]  пункт 1?
[56:15.860 --> 56:17.860]  Значит, доказательства теоремы.
[56:17.860 --> 56:19.860]  Доказательства теоремы
[56:19.860 --> 56:21.860]  пункт 1.
[56:23.860 --> 56:25.860]  Почему мы сляжем монотонную,
[56:25.860 --> 56:27.860]  то всегда найдем правильный ответ
[56:27.860 --> 56:29.860]  и раскроем каждую вещь не больше одного раза.
[56:29.860 --> 56:31.860]  Ну, начнем
[56:31.860 --> 56:33.860]  со второго вопроса.
[56:33.860 --> 56:35.860]  Каждая вершина очевидно раскроется не больше
[56:35.860 --> 56:37.860]  одного раза, потому что f не убывают.
[56:37.860 --> 56:39.860]  Смысл
[56:39.860 --> 56:41.860]  раскрывать вершину больше одного раза
[56:41.860 --> 56:43.860]  есть только в случае, когда мы нашли более
[56:43.860 --> 56:45.860]  оптимальный путь,
[56:45.860 --> 56:47.860]  то есть мы нашли меньше f, чем было раньше.
[56:49.860 --> 56:51.860]  Значит, за счет утверждения
[56:51.860 --> 56:53.860]  нет смысла
[56:55.860 --> 56:57.860]  раскрывать вершину
[56:57.860 --> 57:06.860]  раскрывать вершину больше одного раза.
[57:06.860 --> 57:13.860]  Потому что если вершина раскрывается больше одного раза,
[57:13.860 --> 57:18.860]  это может произойти только если мы нашли до нее более короткий путь, чем раньше нашли до этого.
[57:18.860 --> 57:22.860]  То есть мы извлекли кучу в какой-то момент, там было какое-то f,
[57:22.860 --> 57:25.860]  потом я ее еще раз добавил с меньшим f, и потом еще раз извлек.
[57:25.860 --> 57:28.860]  Только в случае уменьшения f я мог ее заново добавить в кучу.
[57:28.860 --> 57:31.860]  Ну а такого не бывает по утверждению.
[57:31.860 --> 57:36.860]  Второе утверждение, вот это вот.
[57:36.860 --> 57:43.860]  Мы пояснили, почему всегда правильный ответ находится.
[57:43.860 --> 58:00.860]  Ну а почему всегда найдется правильный ответ?
[58:00.860 --> 58:02.860]  Ну, давайте скажем следующее.
[58:02.860 --> 58:04.860]  Давайте я мой алгоритм немножко изменю.
[58:04.860 --> 58:08.860]  Смотрите, я вот там в самом конце, когда описывал звездочку, сказал следующее.
[58:08.860 --> 58:11.860]  Когда из кучи извлекается t, я сразу алгоритм завершаю.
[58:11.860 --> 58:16.860]  Как только у меня извлекается из кучи t, то есть я как бы говорю,
[58:16.860 --> 58:20.860]  что до нее уже найдено прошедшее состояние, я завершаюсь, больше ничего не рассматриваю.
[58:20.860 --> 58:28.860]  Так вот, давайте мы предположим, что это не так, пусть не так.
[58:28.860 --> 58:36.860]  И давайте мы тогда изменим наш алгоритм, разрешим ему продолжаться, пока куча не опустеет.
[58:36.860 --> 58:40.860]  То есть я отменяю строчку, вот эту вот, если выравнивать эту, break.
[58:40.860 --> 58:45.860]  Просто говорю, что пока куча не пустая, мы раскрываем экстракт-мин.
[58:45.860 --> 58:49.860]  Корень кучи раскрываем.
[58:49.860 --> 58:54.860]  И вот, если мы откроем эту строчку, то это будет как-то так.
[58:54.860 --> 59:00.860]  И вот, если мы откроем эту строчку, то это будет как-то так.
[59:00.860 --> 59:10.860]  А пока мы раскрываем экстракт-мин, корень кучи раскрываем.
[59:10.860 --> 59:19.860]  Что тогда? Я тогда утверждал, что такой алгоритм без вот этого break в случае находения t в первый раз точно найдет правильный ответ.
[59:19.860 --> 59:25.860]  Ну потому что, смотрите, есть же у нас какой-то настоящий кратчайший путь из s в t.
[59:25.860 --> 59:28.860]  Вот есть какой-то такой кратчайший путь.
[59:28.860 --> 59:33.860]  Понятно, в какой-то момент мы раскроем s, но в самом начале мы раскрыли s.
[59:33.860 --> 59:35.860]  Тогда я знаю кратчайшее состояние до сюда.
[59:35.860 --> 59:40.860]  В какой-то момент я раскрою эту вершину, найду кратчайшее состояние до суда.
[59:40.860 --> 59:45.860]  В какой-то момент раскрою ее, узнаю до сюда. Раскрою ее, узнаю до сюда.
[59:45.860 --> 59:49.860]  примерно так. Тут, на самом деле, надо немножко поаккуратнее искать, потому что они не обязательно в этом порядке раскрываются.
[59:49.860 --> 59:54.860]  На самом деле, возможно, есть другой путь, кратчайший, скажем, вот такой, но тоже кратчайший.
[59:54.860 --> 01:00:04.860]  Тогда, возможно, у меня вот эта вершина раскроется раньше этой, но все равно я утверждаю, что...
[01:00:04.860 --> 01:00:12.860]  То есть я утверждаю следующее, что вот эта вот вершина в какой-то момент раскроется, при этом до нее будет найден вот такой вот кратчайший путь.
[01:00:12.860 --> 01:00:14.860]  То есть до нее найдено корректное кратчайшее расстояние.
[01:00:14.860 --> 01:00:18.860]  Но это просто делается по индукции, значит, если...
[01:00:18.860 --> 01:00:22.860]  Ну, индукция по количеству ребер в этом кратчайшем пути.
[01:00:22.860 --> 01:00:31.860]  Вот если одно ребро, то, очевидно, до нее найдется правильный путь, потому что одно ребро обработается при раскрытии этой вершины.
[01:00:31.860 --> 01:00:38.860]  Если на кратчайшем пути там несколько ребер, скажем, K, то у меня эта вершина рано или поздно обработается, да, рано или поздно раскроется,
[01:00:38.860 --> 01:00:42.860]  а до нее уже ребер на кратчайшем пути меньше, K-1.
[01:00:42.860 --> 01:00:48.860]  Поэтому это раскроется, либо это раскроется до, и тогда я найду здесь правильный ответ, либо я найду еще какой-то другой,
[01:00:48.860 --> 01:00:55.860]  возможно, более короткий путь до нее, и значит, ну, опять-таки здесь ребер меньше, чем K, и это успеет раскрыться.
[01:00:55.860 --> 01:01:04.860]  То есть я утверждаю, что к моменту времени обработки каждой вершины, по крайней мере, один из кратчайших пути до нее уже будет рассмотрен.
[01:01:04.860 --> 01:01:09.860]  Ну, понятно, да, то есть хотя бы одна из этих вершин должна будет обработана быть.
[01:01:09.860 --> 01:01:18.860]  Значит, если я отменяю это условие про то, что if выровнуто break, тогда у меня кратчайший путь от s до t точно обработается,
[01:01:18.860 --> 01:01:24.860]  и у меня найдется правильное расстояние g от t.
[01:01:24.860 --> 01:01:36.860]  Но, смотрите, тогда получается, мне нужно моему алгоритму разрешить делать еще лишние итерации, чтобы он нашел правильный путь.
[01:01:36.860 --> 01:01:43.860]  То есть он найдет какое-то более правильное g от t, он нашел сначала какое-то расстояние, да, потом удалил t, что-то сделал,
[01:01:43.860 --> 01:01:50.860]  потом ему сказал, окей, работай дальше, он взял еще, нашел какой-то более короткий путь до t, такого быть не может, потому что у меня f увеличивается.
[01:01:50.860 --> 01:01:59.860]  А я что сказал? Я сказал, что я нашел какой-то путь до t, ее удалил, обработал, раскрыл, и потом нашел более короткий путь до нее же.
[01:01:59.860 --> 01:02:04.860]  И потом ее раскрыл, обработал. Но такого не бывает, потому что у меня f только не убывает.
[01:02:04.860 --> 01:02:11.860]  Значит, если я в какой-то момент обработал t и потом еще обработал t, извлек из кучи, то у меня f могло только вырастить для нее.
[01:02:11.860 --> 01:02:17.860]  Противоречие, да, то есть если у меня кратчайший путь нашелся когда-то потом, то он должен был найти в самом начале.
[01:02:17.860 --> 01:02:23.860]  В самый первый раз, когда я впервые извлекаю t из кучи, у меня должен был найти правильный путь.
[01:02:23.860 --> 01:02:30.860]  Вот, собственно, поэтому, когда я извлекаю t из кучи, для нее уже все насчитано.
[01:02:30.860 --> 01:02:51.860]  Давайте что-нибудь напишем. В конце, в конце, истинный кратчайший путь, истинный кратчайший путь из s в t гарантированно обработается.
[01:03:00.860 --> 01:03:14.860]  Следовательно, получим f от t равное dist t.
[01:03:14.860 --> 01:03:20.860]  Ну, для t, я, наверное, это уже замечал, для t у меня g и f это одно и то же, потому что h равно 0.
[01:03:20.860 --> 01:03:25.860]  В случае, по крайней мере, монотонной велистики h от t равно 0, поэтому g и f это одно и то же.
[01:03:25.860 --> 01:03:31.860]  Так вот, если я разрешаю алгоритму работать дальше, то у меня точно рано или поздно получится, что f это равно dist t.
[01:03:31.860 --> 01:03:37.860]  И если до этого f извлекалось, то там было еще меньшее значение f противоречия.
[01:03:37.860 --> 01:04:04.860]  Если t до этого уже извлекалось из кучи, то в ней было f от t меньше либо равно dist t.
[01:04:04.860 --> 01:04:09.860]  Потому что, опять-таки, по утверждению, последовательность f, какую-то извлекаемую, только возрастает.
[01:04:09.860 --> 01:04:19.860]  Поэтому если t извлекается дважды, то на предыдущем шаге там было только меньше либо равное значение f.
[01:04:19.860 --> 01:04:44.860]  Вот, вроде такая вот штука.
[01:04:44.860 --> 01:04:55.860]  Так, что еще хочу сказать? Примерчики давайте какие-нибудь посмотрим.
[01:04:55.860 --> 01:05:03.860]  Примеры. Пример первый. Когда h это тождественный 0.
[01:05:03.860 --> 01:05:17.860]  Если у меня эвристика очень глупая и всегда равна 0, то я утверждаю, что a звездочка вырождается в dx просто, что они просто делают одно и то же.
[01:05:17.860 --> 01:05:24.860]  Вырождается в dx.
[01:05:24.860 --> 01:05:29.860]  Ну, вроде понятно, если h всегда равно 0, то оно не влияет на g и f, это всегда одно и то же.
[01:05:29.860 --> 01:05:34.860]  Поэтому просто a звездочка в точность делает то же самое, что и dx.
[01:05:34.860 --> 01:05:38.860]  Поэтому в таком вот самом простом случае мы получили в точности dx.
[01:05:38.860 --> 01:05:43.860]  То есть, по крайней мере, не хуже, чем dx.
[01:05:43.860 --> 01:05:50.860]  Да, между конкретной s и конкретной t.
[01:05:50.860 --> 01:05:57.860]  Ну да, да, вы правы. То есть, по факту это такая дейстра ограниченная, что не от s до всех, а от s до t.
[01:05:57.860 --> 01:06:04.860]  Да, это важное замечание. Я имею в виду, что сейчас я рассматриваю только задачу поиска от s до t.
[01:06:04.860 --> 01:06:12.860]  Вторая крайность абсолютно сказочная. Пусть каким-то образом удалось вот такую эвристическую функцию придумать.
[01:06:12.860 --> 01:06:17.860]  Что h от v в точности равна d100.
[01:06:17.860 --> 01:06:26.860]  Тогда a звездочка неформально рассмотрит только кратчайший путь от s до t.
[01:06:27.860 --> 01:06:44.860]  Рассмотрит, давайте я напишу в кавычках, только кратчайший путь от s до t.
[01:06:44.860 --> 01:06:52.860]  На самом деле мы рассмотрим не только кратчайший путь, а все кратчайшие пути и все соседние вершины с ними.
[01:06:52.860 --> 01:06:57.860]  Примерно так. Пример, да, как это работает.
[01:06:57.860 --> 01:07:04.860]  Вот давайте я рассмотрю евклидовую мою... так, евклида неинтересна. Давайте рассмотрим Манхэттенскую метрику.
[01:07:04.860 --> 01:07:16.860]  Давайте я скажу, что расстояние между точками x1 и y1 и x2 и y2 равно сумме модулей разности.
[01:07:16.860 --> 01:07:23.860]  Пусть у меня не евклидовая плоскость, а такая Манхэттенская. То есть я могу двигаться только вдоль x или вдоль y параллельно одной из двух осей.
[01:07:23.860 --> 01:07:29.860]  Тогда расстояние определяется не как корень из суммы квадратов, а как сумма модулей разности.
[01:07:29.860 --> 01:07:36.860]  Так вот, давайте я начну какую-нибудь картинку. У меня есть такая плоскость, есть стартовая точка, есть конечная точка.
[01:07:36.860 --> 01:07:41.860]  Ну и там какие-то препятствия. Это по факту очень похоже на какой-нибудь игрушечный мир.
[01:07:41.860 --> 01:07:47.860]  Есть какие-то две точки, надо там человечкой перенаправить отсюда-досюда, и там есть какие-то препятствия.
[01:07:47.860 --> 01:07:51.860]  Деревья, какие-нибудь стены, ну что-нибудь такое. Какой-нибудь такой простой мир.
[01:07:51.860 --> 01:08:00.860]  И у вас там все... короче, вы умеете только на VASD нажимать, и у вас получается четыре направления движения.
[01:08:00.860 --> 01:08:07.860]  Вот так вот. Вот отличная задача для звездочки. Есть очень простой граф.
[01:08:08.860 --> 01:08:20.860]  Есть очень естественная эвристика, которая здесь подойдет.
[01:08:20.860 --> 01:08:30.860]  Ну и тогда что у вас делает... как у вас работает та звездочка?
[01:08:30.860 --> 01:08:37.860]  В самом деле, в случае, когда эта штука на самом деле равна DIST, вы найдете в каком-то смысле только вот этот вот кратчайший путь.
[01:08:37.860 --> 01:08:46.860]  Ну там один из них. Почему это верно? Смотрите. Давайте рассмотрим, как работает та звездочка.
[01:08:46.860 --> 01:08:53.860]  Мы сначала раскрываем... давайте рассмотрим еще любой кратчайший путь от SDT. Вот он.
[01:08:53.860 --> 01:08:58.860]  И если h равно DIST, то я утверждаю, что для них для всех f одинаковые.
[01:08:58.860 --> 01:09:06.860]  Для всех вершин на кратчайшем пути f одно и то же. То есть f от s равно f здесь, равно f здесь, равно и так далее, равно f от t.
[01:09:06.860 --> 01:09:12.860]  Ну потому что что такое f? Что такое f для вершинки? Это длина вот этой вот пути, это g.
[01:09:12.860 --> 01:09:18.860]  Плюс вот этот путь, это h. Ну понятно, что эта сумма, это всегда просто длина пути.
[01:09:18.860 --> 01:09:23.860]  Поэтому у них у всех одно и то же значение f. Это длина пути от s до v и от v до t.
[01:09:23.860 --> 01:09:32.860]  Вот в случае этом нереальном, когда h равно DIST. То есть у меня получается, что если это выполняется, то у меня все f-ки у них одинаковые.
[01:09:32.860 --> 01:09:41.860]  Ну а значит, просто как у меня работает DXTRA? Она сваливает в кучу все вершины и извлекает минимальное значение f.
[01:09:41.860 --> 01:09:49.860]  Ну покуда там есть значение f, вот то самое, что было для f от s, мы обрабатываем только вершины вот с этим вот f.
[01:09:49.860 --> 01:09:54.860]  У них у всех будет одно и то же значение f, и они все извлекутся в таком порядке.
[01:09:54.860 --> 01:09:57.860]  Получается, что мы сразу рассматриваем только кратчайший путь.
[01:09:57.860 --> 01:10:02.860]  Ну да, естественно мы рассматриваем все вот эти вот ребра, исходящие из этих вершин.
[01:10:02.860 --> 01:10:04.860]  Ну как бы, от этого никуда не денешься.
[01:10:04.860 --> 01:10:12.860]  Но по факту у нас как бы сразу есть вот эта вот цепочка, которая ведет нас из начала в конец по вершинам, для которых одно и то же значение f.
[01:10:16.860 --> 01:10:21.860]  Да, единственная тонкость, что возможно, если у нас путей таких несколько кратчайших, скажем вот такой и вот такой есть.
[01:10:21.860 --> 01:10:26.860]  Ну для них тоже, для второго кратчайшего пути, здесь тоже все f одинаковые.
[01:10:26.860 --> 01:10:33.860]  И у меня как бы, а звездочка, он не знает, какой из них выбирать, он ну скорее как-то вот так параллельно по ним идет, по обоим.
[01:10:33.860 --> 01:10:37.860]  И в какой-то момент один из них закончится, и тогда вот я сразу завершаю.
[01:10:37.860 --> 01:10:43.860]  Вот, то есть в этом случае у меня а звездочка рассматривает как бы только кратчайшие пути, и больше ничего не рассматривает.
[01:10:49.860 --> 01:10:52.860]  Это я погорячился, да, это конечно не верно, это конечно не верно.
[01:10:52.860 --> 01:10:59.860]  Но вот в случае, если здесь есть какой-то путь, ладно, давайте вот так сделаю.
[01:10:59.860 --> 01:11:02.860]  Если нет препятствий, тогда это верно.
[01:11:02.860 --> 01:11:04.860]  Вот, гениально, да?
[01:11:04.860 --> 01:11:11.860]  Ну, тяжело, тяжело просто придумать пример, когда у вас эвристика была бы еще равна дисту.
[01:11:11.860 --> 01:11:17.860]  Только вот какие-то графы без, без препятствий скорее.
[01:11:17.860 --> 01:11:28.860]  Так, ну сейчас давайте еще там две формулы напишу, значит какие бывают популярные эвристики на плоскости, значит на плоскости.
[01:11:28.860 --> 01:11:38.860]  Это, как я уже написал, Манхэттен, если можно ходить только в четыре стороны.
[01:11:38.860 --> 01:11:41.860]  Это Чебушовская метрика.
[01:11:47.860 --> 01:11:50.860]  Если можно ходить еще и по диагоналям.
[01:11:50.860 --> 01:11:54.860]  Вот, ну и это Евклидовская метрика, Евклидова метрика.
[01:11:58.860 --> 01:12:01.860]  Если можно ходить в любом направлении.
[01:12:06.860 --> 01:12:11.860]  Соответственно, в зависимости от того, как у вас определяется расстояние на плоскости,
[01:12:11.860 --> 01:12:14.860]  то есть как можно вашему человечку ходить на плоскости,
[01:12:14.860 --> 01:12:18.860]  соответствующая эвристика H подойдет лучше всего.
[01:12:18.860 --> 01:12:21.860]  Ну как бы для них все понятно, это монотонные эвристики.
[01:12:21.860 --> 01:12:24.860]  Понятно, что расстояние от T до T равно нулю.
[01:12:24.860 --> 01:12:27.860]  Выполняется на районе треугольника тривиально, потому что это метрики.
[01:12:27.860 --> 01:12:29.860]  Ну и все.
[01:12:29.860 --> 01:12:35.860]  Получается, что если вы вместо дэекстры вот в таких графах будете пускать азвездочку, то точно хуже вам от этого не будет.
[01:12:35.860 --> 01:12:40.860]  Но возможно будет сильно лучше, потому что вот, например, на графах без, без препятствий,
[01:12:40.860 --> 01:12:45.860]  вы будете посещать почти только коротчайший путь и, в общем-то, не будете уходить во все остальные вершины.
[01:12:45.860 --> 01:12:49.860]  Потому что, например, там DFS или дэекстра работали бы скорее вот так.
[01:12:49.860 --> 01:12:55.860]  Мы нашли все вершины на расстоянии ноль, потом все вершины на расстоянии один, два, три, четыре и так далее.
[01:12:55.860 --> 01:12:58.860]  То есть дэекстры и BFS они бы как-то во все стороны бы шли.
[01:12:58.860 --> 01:13:01.860]  А за счет H азвездочка понимает, что надо идти туда.
[01:13:01.860 --> 01:13:04.860]  Идет как бы только туда. Не обходится.
[01:13:05.860 --> 01:13:09.860]  Не обходит вообще во все стороны граф, а только как бы идет в правильное направление.
[01:13:09.860 --> 01:13:14.860]  Вот в этом как бы такое манемоническая выгода от азвездочки.
[01:13:14.860 --> 01:13:15.860]  Спасибо.
