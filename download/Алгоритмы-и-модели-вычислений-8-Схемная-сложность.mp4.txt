[00:00.000 --> 00:18.960]  Так, ну, значит, у нас про логографическую память осталась теорема, значит, теорема
[00:18.960 --> 00:38.720]  обычно называется иммерманно-слабчение. Вот, заключается в том, что NL равняется
[00:38.720 --> 00:50.320]  NL. Давайте я напомню, что такое NL. Значит, NL означает, что есть недоторминированная
[00:50.320 --> 00:56.840]  машина, которая распознает данный язык и использует логографическую память. То есть
[00:56.840 --> 01:02.840]  это что означает? Это означает, что если ответ «да», то тогда одна из ветвей приводит ответ «да»,
[01:02.840 --> 01:08.080]  и при этом каждая ветвь занимает логографическую память. Вот, если ответ «нет», то все ветви
[01:08.080 --> 01:13.600]  дают ответ «нет», но и тоже каждый ветвь занимает логографическую память. Значит,
[01:13.600 --> 01:24.560]  CoNL это то же самое, только наоборот. Значит, CoNL, ну, можно сказать наоборот, что, значит,
[01:24.560 --> 01:30.800]  если ответ «нет», то тогда какая-то ветка приходит к ответу «нет», а если ответ «да»,
[01:30.800 --> 01:39.560]  то все ветки приводят к ответу «да». Вот, то есть если в NL мы брали дизюнцию всех ветвей,
[01:39.560 --> 01:45.640]  это давало ответ, то в CoNL мы берем конъюнцию всех ветвей, это дает ответ. Ну, либо можно
[01:45.640 --> 01:52.040]  определять через дополнение, что, как всегда, Co класс — это класс дополнений к языкам из основного
[01:52.040 --> 02:00.760]  класса. Ну и, соответственно, первоначально была некоторая интуиция, что, на самом деле,
[02:00.760 --> 02:08.440]  это должно быть неравно и обосновывалось примерно так же, как для NP и CoNP. Ну, типа того, что вот,
[02:08.440 --> 02:18.440]  ну, вообще не очень понятно, как там от дизюнции к конъюнцию перейти. Ну, или еще есть другой
[02:18.440 --> 02:23.840]  подход, который мы будем использовать, который мы в конце прошлого раза изучали, это сертификатный
[02:23.840 --> 02:33.000]  подход, что есть сертификат, который читается один раз лево-направо. Вот, и, соответственно,
[02:33.000 --> 02:43.040]  должен существовать статистикат паридональной длины, который приводит к ответу «1», если на самом
[02:43.040 --> 02:50.320]  деле ответ «1», а если ответ «0», то любой сертификат приводит к ответу «0». Ну вот, и тут, казалось бы,
[02:50.320 --> 02:59.720]  та же самая интуиция работает, что и с NP. То есть, если мы можем предъявить короткий паридональный
[02:59.720 --> 03:04.880]  длинный сертификат, который проверяется на логографической памяти, читается лево-направо и
[03:04.880 --> 03:11.800]  удовтворяет ответ «да», то совершенно неясно, почему такой же сертификат будет для ответа «нет».
[03:11.800 --> 03:20.920]  Ну вот, Эмерман и Сэл Лэпченни в конце 80-х годов объяснили, почему это будет так. Таким образом,
[03:20.920 --> 03:31.840]  интуиция, которая берется от времени, здесь не работает. Ну, собственно, это у нас уже и раньше,
[03:31.840 --> 03:41.000]  да, мы говорили про PSPACE и NP-SPACE, что с полимональной памятью недотаминированной машины ничего
[03:41.000 --> 03:48.040]  дополнительно не дают. Но с логарифмической, они, может, и дают, но не дает вот этот переход
[03:48.040 --> 04:02.800]  к КО-классу. Так, хорошо. Значит, как же это доказывается? Ну, доказательство будет стать
[04:02.800 --> 04:21.800]  следующим. Значит, мы докажем, будем доказывать, что, значит, будем доказывать, что дополнение к
[04:21.800 --> 04:41.600]  языку ПФ лежит в НЛ. Значит, почему этого достаточно? Ну, потому что ПФ, значит, ПФ НЛ полный, значит, раз ПФ является НЛ полным,
[04:41.600 --> 05:02.440]  то, соответственно, ПФ с чертой, то есть дополнение к ПФ, является КО-НЛ полным. Ну, и тогда получается,
[05:02.440 --> 05:20.080]  что если ПФ с чертой лежит в НЛ, то из этого следует, что для любого А из КО-НЛ, значит,
[05:20.080 --> 05:38.480]  мы получаем, что А сводится к ПФ, к ПФ с чертой, значит, А из КО-НЛ, А сводится к ПФ с чертой, и тогда, значит, тогда получаем,
[05:38.480 --> 05:48.480]  что А лежит в НЛ. Ну, как обычно, что если какой-то язык логарифмически сводится к языку из НЛ, значит, он сам в НЛ.
[05:48.480 --> 06:02.480]  Вот. Ну, отсюда получается, отсюда получается, что КО-НЛ вложено в НЛ. Вот. Ну, и в другую сторону,
[06:02.480 --> 06:13.240]  на самом деле, аналогично. Да, значит, в... Можно привести аналогичное рассуждение, а можно просто сказать,
[06:13.240 --> 06:25.240]  что если А лежит в НЛ, то тогда А с чертой лежит в КО-НЛ, тогда, поскольку КО-НЛ вложено в НЛ,
[06:25.240 --> 06:51.240]  получаем, что А с чертой лежит в НЛ, и тогда А лежит в КО-НЛ. Соответственно, получается, что НЛ вложено в КО-НЛ.
[06:51.240 --> 07:05.240]  Вот. Ну, раз НЛ вложено туда и сюда, значит, они равны. Так, хорошо. Как же мы будем доказывать, что ПФ с чертой лежит в НЛ?
[07:05.240 --> 07:15.240]  Да, ну, вообще, ПФ... Что такое ПФ? Это множество троек из графа двух вершин, таких, что и с первыми вершинами во вторую идет ориентированный путь.
[07:15.240 --> 07:23.240]  Вот. Ну, дополнение, с одной стороны, формально можно сказать, что дополнение это любые объекты, не являющиеся такими тройками.
[07:23.240 --> 07:30.240]  Но поскольку по объекту можно понять, он вообще кодирует тройку из графа двух вершин или не кодирует.
[07:30.240 --> 07:41.240]  Для любой договоренности о кодировке это можно понять. Ну, для любой естественной договоренности можно понять, является ли данная запись кодом такой тройки или не является.
[07:41.240 --> 07:49.240]  Итак, можно считать, что ПФ с чертой – это множество троек, таких, что из вершины С и вершины Т нет пути.
[07:54.240 --> 08:02.240]  Вот. Дайте это я в новую уровню запишу.
[08:02.240 --> 08:27.240]  ПФ с чертой – это множество троек G, С, Т, таких, что в ориентированном графе G нет пути, нет пути из С в Т.
[08:27.240 --> 08:33.240]  Вот. Ну и нам нужно каким-то образом построить сертификат, который будет это доказывать.
[08:33.240 --> 09:01.240]  Нужно построить сертификат, который доказывает, что тройка G, С, Т лежит в ПФ с чертой.
[09:01.240 --> 09:16.240]  Вот. Ну и, соответственно, этот сертификат нужно построить, нужно делать так, чтобы он был полиномерной длины и чтобы он считался слева направо.
[09:16.240 --> 09:30.240]  Так. Ну, значит, если понятно, зачем нам нужно это делать, то тогда давайте начнем, собственно, этот сертификат строить.
[09:30.240 --> 09:49.240]  Значит, строить его будем постепенно. Значит, сначала такая идея. Ну, во-первых, если в вершину есть путь, то это мы уж можем доказать.
[09:49.240 --> 09:56.240]  И, в принципе, во все вершины, которые есть путь, мы можем доказать, что он есть.
[09:56.240 --> 10:05.240]  Ну, а теперь давайте представим, давайте представим, что у нас, откуда-то мы знаем, сколько всего вершин достижимые из С.
[10:05.240 --> 10:14.240]  Да, вот. Ну, мы потом получим эту информацию, вычислим, но пока что представим, что у нас эту информацию уже есть, мы ей можем доверять.
[10:14.240 --> 10:39.240]  Ну, значит, пусть известно, сколько всего вершин достижимо из С.
[10:39.240 --> 10:53.240]  Ну, это там какое-то число. Так, давайте я это напишу СН.
[10:53.240 --> 11:03.240]  Это число СН. Почему Н? Потому что дальше СИТ это будет число, достижимое путями длины не больше И.
[11:03.240 --> 11:10.240]  Ну, а если какой-то путь есть, то есть путь длины не больше Н. Ну, значит, вот поэтому СН.
[11:10.240 --> 11:26.240]  Вот, это число СН. Тогда нужно просто, чтобы доказать, чтобы доказать, что нет пути в Т,
[11:26.240 --> 11:44.240]  нет пути в Т, нужно предъявить, значит, нужно предъявить вот такое число вершин.
[11:44.240 --> 12:00.240]  Значит, СН вершин достижимых, значит, СН достижимых из С вершин, среди которых нет Т.
[12:14.240 --> 12:25.240]  Вот, а как мы это предъявим? Ну, если она достижима, если она достижима, то мы можем путь предъявлять.
[12:25.240 --> 12:31.240]  Ну, и то, что там они не совпадают с Т, мы тоже можем легко проверить. Мы же там обсуждали сравнение.
[12:31.240 --> 12:39.240]  А тут у нас даже сравнение маленьких чисел. Вот, но надо еще проверить, что это все разные вершины.
[12:39.240 --> 12:47.240]  Вот, а чтобы удостоверить, что это разные вершины, нужно их перечислять в порядке возрастания.
[12:47.240 --> 12:55.240]  Значит, чтобы, потому что мы не можем их все хранить и сравнивать новую со всеми старыми.
[12:55.240 --> 13:11.240]  Значит, чтобы проверить, что все вершины разные, чтобы проверить, что все вершины разные,
[13:11.240 --> 13:34.240]  нужно перечислить их в порядке возрастания. То есть у них там есть какие-то номера.
[13:34.240 --> 13:45.240]  Ну, тут можно считать, что просто номера от 1 до n. Вот, и тогда вот такой сертификат уже получается можно проверять.
[13:45.240 --> 13:53.240]  Получается, что он будет выглядеть примерно так.
[13:53.240 --> 14:03.240]  Вот такая длинная лента. Значит, как она выглядит. В1, потом тут есть путь из С в В1.
[14:03.240 --> 14:13.240]  Значит, потом В2. Ну, значит, потом путь из С в В2. Потом В3, ну и так далее.
[14:13.240 --> 14:25.240]  И потом В, так, давайте я двойной имекс не буду писать, ВСТ. Значит, ВСТ и, соответственно, путь из С в ВСТ.
[14:26.240 --> 14:36.240]  И вот такой сертификат можно действительно читать слева-направо, имея константу счетчиков.
[14:36.240 --> 14:44.240]  Ну, а какие у нас есть счетчики? Ну, во-первых, у нас изначально задан граф и две вершины, это вообще не в счет.
[14:44.240 --> 14:49.240]  Ну, дальше у нас должен быть счетчик для текущей вершины.
[14:49.240 --> 14:55.240]  Вот мы прочли текущую вершину В, ну и там, как нам договориться, как этот разделитель понимать, это, в общем, технические детали.
[14:55.240 --> 15:01.240]  А вот мы прочли вершину. Вот. После этого что означает путь?
[15:01.240 --> 15:12.240]  Ну, это тоже последовательность вершин, где первая вершина С, последняя вершина В1, а каждая следующая соединяется ребром с предыдущей.
[15:12.240 --> 15:17.240]  Вот. Соответственно, что мы тут делаем? Ну, смотрим на первую, проверяем, что она равна С.
[15:17.240 --> 15:21.240]  Значит, потом запоминаем первую, читаем вторую.
[15:21.240 --> 15:25.240]  Проверяем по графу, что есть ребро из первую и вторую.
[15:25.240 --> 15:31.240]  Потом первую забываем, на ее место записываем вторую и читаем третью, проверяем, что есть ребро из второй и третьей.
[15:31.240 --> 15:38.240]  И так далее, и так доходим до конца, и в конце смотрим, что то, что у нас было, это В1.
[15:38.240 --> 15:44.240]  Вот. Так мы проверили этот путь. После этого мы читаем В2, а В1 еще помним.
[15:44.240 --> 15:52.240]  И проверяем, что В2 больше, чем В1, строго больше, что это действительно в порядке возрастания.
[15:52.240 --> 15:59.240]  Вот. Если какая-то проверка на каком-то этапе не выполнена, тогда нужно сразу отвергать, говорить нет.
[15:59.240 --> 16:05.240]  Вот. Значит, проверяем, что В2 больше В1 и теперь записываем В2 на место В1.
[16:05.240 --> 16:16.240]  Дальше точно так же проверяем вот этот путь. Дальше В3 примерно, что больше В2 и так далее.
[16:16.240 --> 16:23.240]  И на самом деле нужно еще один счетчик. Нужен еще счетчик, сколько мы собственные решения проверили,
[16:23.240 --> 16:29.240]  чтобы в самом конце, если действительно... Да, еще каждый раз мы проверяем, что данная решения не Т.
[16:29.240 --> 16:33.240]  Что В1 не равно Т, В2 не равно Т и так далее.
[16:33.240 --> 16:39.240]  Соответственно, мы каждый раз проверяем, что новая вершина больше старой, новая вершина не равно Т,
[16:39.240 --> 16:46.240]  что путь, который идет дальше, правильный, и увеличиваем на единицу счетчик уже обработанных вершин.
[16:46.240 --> 16:53.240]  И в самом конце проверяем, что счетчик дошел до того значения С, которое должно быть, которое ценное.
[16:53.240 --> 17:02.240]  Ну и что все проверки, соответственно, ни разу не обманулись, что все условия ни разу не нарушились.
[17:02.240 --> 17:07.240]  Если это все так, то тогда прочитая этот сертификат, мы выдаем да.
[17:07.240 --> 17:14.240]  Вот, а действительно, если мы заранее уверены, что значение С правильное,
[17:14.240 --> 17:19.240]  то такая штука действительно докажет, что Т нету.
[17:19.240 --> 17:27.240]  Потому что если всего С вершин достижимо, то мы не можем предъявить столько же достижимых, среди которых нет С.
[17:27.240 --> 17:30.240]  Нет Т, если Т достижимо.
[17:30.240 --> 17:34.240]  А если Т недостижимо, то мы их возьмем предъявляем.
[17:38.240 --> 17:45.240]  Сn я сказал, n это число вершин в графе, а вообще потом CiT будет число вершин,
[17:45.240 --> 17:49.240]  вершин достижимых путем длины не больше i.
[17:49.240 --> 17:55.240]  А Cn, потому что если есть какой-то, то есть по длину не больше m.
[17:55.240 --> 18:00.240]  Ну там даже m-1 не сопаревываемо считать, но это, в общем, неважно.
[18:05.240 --> 18:12.240]  Хорошо, значит, если мы знаем общее число достижимых, то тогда вот все получается.
[18:12.240 --> 18:17.240]  Дальше возникает вопрос, откуда взять C?
[18:21.240 --> 18:26.240]  Откуда взять C, который есть Cn?
[18:28.240 --> 18:30.240]  Ну ответ по индукции.
[18:36.240 --> 18:38.240]  Значит, по индукции.
[18:38.240 --> 18:44.240]  Как именно? Ну мы определим, вот CiT.
[18:44.240 --> 18:52.240]  Значит, CiT это число, значит, число вершин
[18:55.240 --> 19:06.240]  достижимых, достижимых путем длины не больше i.
[19:08.240 --> 19:16.240]  Вот, значит, CiT это число вершин, достижимых путем длины не больше i.
[19:16.240 --> 19:21.240]  Тогда у нас есть база индукции, мы знаем, чему равно C0.
[19:21.240 --> 19:23.240]  Значит, C0 равно 1.
[19:23.240 --> 19:25.240]  Это мы знаем.
[19:25.240 --> 19:32.240]  Значит, база, что C0 равно 1.
[19:32.240 --> 19:37.240]  Путь длины 0, это одна вершина, и это как раз она и будет достижена.
[19:38.240 --> 19:42.240]  Вот. Ну а переход...
[19:49.240 --> 20:00.240]  Да, значит, переход, соответственно, каким-то образом нам нужно перейти вот CiT к Ci плюс 1.
[20:00.240 --> 20:02.240]  Да, то есть...
[20:02.240 --> 20:08.240]  Но иметь в виду, что вот это будет некоторым участком сертификата, так что к началу
[20:08.240 --> 20:16.240]  чтения этого участка мы уверены в значении CiT, а в конце мы будем уверены в значении Ci плюс 1.
[20:16.240 --> 20:26.240]  Вот. Но тогда, проведя n шагов, мы придем к Cn, и дальше добавив вот это, мы узнаем, что T недостижимо.
[20:26.240 --> 20:29.240]  Так, вот такой вот план.
[20:30.240 --> 20:34.240]  Так, ну что, есть какие-нибудь вопросы по общему плану?
[20:38.240 --> 20:40.240]  Длину давайте по ребрам считать.
[20:40.240 --> 20:44.240]  Да, тогда в принципе можно не Cn на Cn минус 1 взять, но, в общем-то, не важно.
[20:44.240 --> 20:47.240]  С Cn хуже не будет.
[20:49.240 --> 20:52.240]  Ну, длина пути, это число ребер, которые...
[20:52.240 --> 20:56.240]  То есть, на 1 с меньше, чем число вершин, которые в него входят.
[20:59.240 --> 21:01.240]  Так.
[21:03.240 --> 21:09.240]  Ну, значит, смотрите, вот в этом переходе, значит, переход будет выглядеть так.
[21:12.240 --> 21:21.240]  Во-первых, ну, очевидно, что если вершин достижимо путем длины не больше, чем и плюс 1,
[21:21.240 --> 21:24.240]  то для этого сертификат есть.
[21:24.240 --> 21:32.240]  Да, значит, есть сертификат достижимости.
[21:33.240 --> 21:48.240]  Значит, сертификат достижимости вершины путем длины не больше, чем и плюс 1.
[21:48.240 --> 21:50.240]  И это сам этот путь.
[21:51.240 --> 22:00.240]  Да, значит, это сам этот путь.
[22:02.240 --> 22:05.240]  Вот, а еще, может быть, сертификат недостижимости...
[22:05.240 --> 22:17.240]  Значит, сертификат недостижимости...
[22:17.240 --> 22:25.240]  Сертификат недостижимости...
[22:25.240 --> 22:31.240]  Ну, то же самое, вершины путем длины не больше, чем и плюс 1, при известном...
[22:33.240 --> 22:36.240]  При известном ЦИТ.
[22:36.240 --> 22:39.240]  Ну, в общем, он выглядит почти точно так же, как здесь.
[22:39.240 --> 22:43.240]  То есть, вообще, на самом деле, сам сертификат точно так же выглядит, но проверяется по-другому.
[22:43.240 --> 23:04.240]  Да, соответственно, сертификат выглядит так же, но только уже для C равного ЦИТ.
[23:05.240 --> 23:09.240]  Значит, для C равного ЦИТ.
[23:09.240 --> 23:13.240]  Но вместо...
[23:13.240 --> 23:23.240]  Значит, если мы анализируем вершину W, чтоб не путать с T, которая у нас конечная, во всей задаче.
[23:23.240 --> 23:42.240]  Вместо проверки того, что ВИТ не равно W, мы делаем проверку, что там нет ребра.
[23:43.240 --> 23:47.240]  Значит, ВИТ не W.
[23:47.240 --> 23:53.240]  Точнее, это даже не вместо, а вместе, наоборот.
[23:53.240 --> 24:00.240]  Значит, вместе с проверкой, что ВИТ не равно W.
[24:00.240 --> 24:06.240]  Потому что если ВИТ равно W, то она уже достижима путем длины и меньше, чем и плюс 1.
[24:06.240 --> 24:11.240]  А еще может быть, что какая-то решина ВИТ достижима путем длины и.
[24:11.240 --> 24:14.240]  И еще есть одно ребро в W.
[24:14.240 --> 24:21.240]  Тогда W была бы достижима путем длины и плюс 1.
[24:21.240 --> 24:23.240]  Ну вот.
[24:23.240 --> 24:30.240]  То есть нам предъявляют, да, мы знаем, что C-вершин достижимы путем небольшой E.
[24:30.240 --> 24:33.240]  Нам эти C-вершин предъявляют.
[24:33.240 --> 24:38.240]  И мы про каждую из них проверяем, что, во-первых, она сама не совпадает с W.
[24:38.240 --> 24:43.240]  И, во-вторых, из нее не идет путь W. Не путь, в смысле, а ребро.
[24:43.240 --> 24:48.240]  То есть нельзя этот путь длины и нарастить еще на одно ребро так, чтобы он пришел в W.
[24:51.240 --> 24:55.240]  Так. Ну ничего, понятно?
[24:55.240 --> 24:59.240]  В общем, у нас есть сертификат достижимости, есть сертификат недостижимости.
[24:59.240 --> 25:05.240]  Ну а дальше, как нам теперь посчитать C и плюс 1?
[25:05.240 --> 25:12.240]  Ну нам просто нужно для каждой вершины дать либо сертификат достижимости, либо сертификат недостижимости.
[25:12.240 --> 25:20.240]  То есть теперь сертификат...
[25:20.240 --> 25:23.240]  Так, дайте я вот так вот.
[25:23.240 --> 25:27.240]  Значит, сертификат как C и T в C и плюс 1.
[25:27.240 --> 25:31.240]  Значит, он тоже похожим образом...
[25:31.240 --> 25:35.240]  Выглядит...
[25:35.240 --> 25:37.240]  Ну тут уже все вершины по порядку идут.
[25:37.240 --> 25:40.240]  Там будет вершина 1.
[25:40.240 --> 25:44.240]  А тут, соответственно...
[25:44.240 --> 25:49.240]  Так, ну давайте я напишу для конкретного случая.
[25:49.240 --> 25:57.240]  Значит, если 1, то тут путь из S в 1 длины меньше на тему плюс 1.
[25:57.240 --> 26:00.240]  Да, а потом, например, 2.
[26:00.240 --> 26:09.240]  А тут будет сертификат недостижимости 2.
[26:09.240 --> 26:12.240]  Да, там 3, ну и так далее.
[26:12.240 --> 26:16.240]  Ну в общем, тут мы перебираем все вершины,
[26:16.240 --> 26:23.240]  и для каждой из них предъявляем либо сертификат достижимости, либо сертификат недостижимости, в зависимости от того, что именно верно.
[26:23.240 --> 26:51.240]  То есть тут для каждой вершины предъявляется сертификат достижимости или недостижимости.
[26:53.240 --> 27:06.240]  Ну и понятно, как проверяется.
[27:06.240 --> 27:11.240]  Ну можно сюда еще один бит записывать, каково видно сертификат.
[27:11.240 --> 27:14.240]  А можно пытаться это понять по самому сертификату.
[27:14.240 --> 27:17.240]  Проще, конечно, что записать, какой ответ.
[27:17.240 --> 27:24.240]  То есть вот у нас очередной номер, там 1.
[27:24.240 --> 27:28.240]  В принципе, можно даже имена ранее писать, их вычислять.
[27:28.240 --> 27:34.240]  Там будет просто очередной разделитель, бит ответа и сертификат.
[27:34.240 --> 27:39.240]  Но проще, когда будет номер, потом бит да или нет.
[27:39.240 --> 27:46.240]  Если да, то путь, если нет, то, соответственно, сертификат недостижимости.
[27:46.240 --> 27:49.240]  Ну и верификатор идет.
[27:49.240 --> 27:52.240]  Читает очередной номер вершины.
[27:52.240 --> 27:57.240]  Проверяет, что он на единицу больше того, что там было до этого.
[27:57.240 --> 28:00.240]  Дальше проверяет этот сертификат.
[28:00.240 --> 28:06.240]  После этого там читает новый номер, читает новый бит.
[28:06.240 --> 28:08.240]  Проверяет, что у нас на единицу больше.
[28:08.240 --> 28:10.240]  Перезаписывает там то, что было.
[28:10.240 --> 28:12.240]  Проверяется, соответственно, сертификат.
[28:12.240 --> 28:14.240]  Ну и так далее.
[28:20.240 --> 28:24.240]  Ну и после этого получается, что весь сертификат,
[28:27.240 --> 28:31.240]  значит, весь сертификат уже для П с чертой
[28:32.240 --> 28:34.240]  будет выглядеть так.
[28:40.240 --> 28:43.240]  На, тут как бы будет, там,
[28:43.240 --> 28:45.240]  c0 в c1,
[28:45.240 --> 28:47.240]  потом c1 в c2,
[28:47.240 --> 28:49.240]  там, и так далее.
[28:49.240 --> 28:52.240]  На, там, cn-1 в cn.
[28:52.240 --> 28:55.240]  Вот, и потом
[28:55.240 --> 29:00.240]  сертификат недостижимости
[29:02.240 --> 29:04.240]  при известном,
[29:07.240 --> 29:09.240]  при известном cn.
[29:11.240 --> 29:13.240]  Вот.
[29:17.240 --> 29:20.240]  Вот так это все должно выглядеть.
[29:20.240 --> 29:23.240]  Ну, действительно, длина будет полинамиальной.
[29:23.240 --> 29:25.240]  Знаете, почему?
[29:25.240 --> 29:30.240]  Ну, потому что, смотрите, у нас тут будет n,
[29:30.240 --> 29:34.240]  ну, n плюс 1, значит, n плюс 1 кусок, да, потому что вот,
[29:34.240 --> 29:38.240]  ну, это, собственно, выглядит точно так же, как вот это вот.
[29:38.240 --> 29:42.240]  Значит, ну, основная вот эта вот будет часть.
[29:42.240 --> 29:44.240]  Значит, будет n участков.
[29:44.240 --> 29:49.240]  Значит, каждый участок состоит еще вот из n тоже сертификатов.
[29:50.240 --> 29:55.240]  Вот. А эти сертификаты, значит, вот эти вот длины там не больше n,
[29:55.240 --> 30:00.240]  а вот эти, они, на самом деле, тоже выглядят так, да, они тоже из,
[30:00.240 --> 30:03.240]  ну, если не, может быть, меньше, чем из n, да,
[30:03.240 --> 30:06.240]  но тоже из какого-то линейного числа достижимых.
[30:07.240 --> 30:11.240]  И каждый, и каждый из этих путей тоже длинный.
[30:11.240 --> 30:13.240]  Ну, в общем, n с четвертой получается.
[30:13.240 --> 30:16.240]  Да, длина сертификата n с четвертой.
[30:16.240 --> 30:21.240]  Да, потому что n этапов, значит, каждый этап тоже из n частей.
[30:21.240 --> 30:26.240]  Вот. И эти части есть длинные, да, значит, которые тоже из,
[30:26.240 --> 30:30.240]  ну, может, не n, но n пополам там, или сколько-нибудь вершины,
[30:30.240 --> 30:32.240]  для каждой из них еще путь тоже.
[30:32.240 --> 30:37.240]  Ну, путь-то длины i, ну, i тоже может быть порядка n пополам,
[30:37.240 --> 30:39.240]  там где-то в середине.
[30:39.240 --> 30:42.240]  В общем, общая длина порядка n с четвертой.
[30:43.240 --> 30:46.240]  Ну, это нас устраивает, да, это полином.
[30:46.240 --> 30:48.240]  Значит, это полином.
[30:48.240 --> 30:51.240]  Соответственно, для проверки нужно там какое-то не очень большое
[30:51.240 --> 30:54.240]  константное число счетчиков.
[30:54.240 --> 30:58.240]  Ну, может, если не экономить там, ну, штук 15 точно хватит.
[30:59.240 --> 31:06.240]  Вот. Ну вот и действительно все корректно проверяется.
[31:10.240 --> 31:14.240]  Так, есть какие-нибудь вопросы по поводу этой конструкции?
[31:16.240 --> 31:19.240]  Нужно ли что-нибудь разъяснить подробнее?
[31:19.240 --> 31:21.240]  Повторите еще раз.
[31:29.240 --> 31:33.240]  Вот. Ну, действительно, она не очень тривиальная.
[31:34.240 --> 31:38.240]  Да, то есть это неудивительно, что это не сразу придумали.
[31:41.240 --> 31:46.240]  Вот. Ну, на самом деле, да, значит, вот этого получается достаточно
[31:46.240 --> 31:49.240]  для доказательств того, что nl равно qnl.
[31:50.240 --> 31:55.240]  Вот. Ну, это позволяет сразу много других задач классифицировать там в qnl,
[31:55.240 --> 31:57.240]  да, в qnl полное.
[31:59.240 --> 32:03.240]  Вот. Например, задачу выполнимость 2knf.
[32:04.240 --> 32:09.240]  Да, вот мы как-то обсуждали, значит, 2sat.
[32:10.240 --> 32:12.240]  2sat это выполнимость 2knf.
[32:15.240 --> 32:17.240]  Значит, ну что phi?
[32:17.240 --> 32:23.240]  Таких, что phi это выполнимое 2knf.
[32:23.240 --> 32:27.240]  Мы, кажется, обсуждали, почему она лежит в p,
[32:27.240 --> 32:31.240]  но на самом деле она лежит не только в p, но и в nl.
[32:36.240 --> 32:39.240]  Значит, она лежит не только в p, но и в nl,
[32:39.240 --> 32:41.240]  но и будет там nl полный.
[32:43.240 --> 32:46.240]  Так. Ну, я думаю, что я после перерыва это расскажу тогда,
[32:46.240 --> 32:48.240]  почему это будет так,
[32:48.240 --> 32:51.240]  что если вопросов по основной теории нет,
[32:51.240 --> 32:54.240]  тогда сейчас через полминут будет звонок.
[32:55.240 --> 32:57.240]  Через 6 минут продолжим.
[32:59.240 --> 33:01.240]  Продолжим.
[33:05.240 --> 33:09.240]  Да, давайте я напомню, что такое 2sat.
[33:10.240 --> 33:12.240]  Ну, у нас такие скобочки,
[33:13.240 --> 33:18.240]  в которых дизъюнкция какого-то вот такого вот вида.
[33:19.240 --> 33:21.240]  Да, дизъюнкция двух литералов.
[33:32.240 --> 33:35.240]  Вот, и они все должны быть выполнены.
[33:37.240 --> 33:41.240]  Значит, я напомню, что мы строили граф.
[33:41.240 --> 33:48.240]  Мы строили граф, где для каждой переменной заводили две вершины,
[33:54.240 --> 33:58.240]  соответствующие ей ее отрицания.
[34:00.240 --> 34:02.240]  Вот, и рисовали стрелочки.
[34:02.240 --> 34:05.240]  Значит, для каждой скобки рисовали две стрелочки,
[34:05.240 --> 34:08.240]  которые на самом деле получались импликациями,
[34:08.240 --> 34:11.240]  которые из этой скобки получались.
[34:11.240 --> 34:12.240]  То есть p или не q.
[34:12.240 --> 34:14.240]  Значит, из q следует p.
[34:14.240 --> 34:17.240]  Ну, или контрпозиция, что из не p следует не q.
[34:17.240 --> 34:19.240]  Так, p или r.
[34:19.240 --> 34:25.240]  Это, соответственно, из не p следует r.
[34:29.240 --> 34:33.240]  Значит, из не r следует p.
[34:34.240 --> 34:38.240]  Так, значит, не q или не r.
[34:40.240 --> 34:43.240]  Так, сейчас, что-то я какой-то не очень хороший пример делаю.
[34:43.240 --> 34:45.240]  Ну ладно, не важно.
[34:48.240 --> 34:50.240]  Значит, из q следует не r.
[34:50.240 --> 34:53.240]  Из r следует не q.
[34:53.240 --> 34:56.240]  В общем, они такими парами, получается, идут.
[34:57.240 --> 35:00.240]  Вот, ну и на самом деле, значит, в данном случае получилось,
[35:00.240 --> 35:04.240]  что вот эта вот скобочка, она на самом деле из этих двух просто следует.
[35:04.240 --> 35:06.240]  Потому что если мы...
[35:06.240 --> 35:08.240]  Вот это означает, что из q следует не r.
[35:08.240 --> 35:11.240]  А вот это означает, что из не r следует p.
[35:11.240 --> 35:13.240]  Поэтому из q следует p.
[35:13.240 --> 35:17.240]  То есть тут несколько избыточные, значит...
[35:21.240 --> 35:23.240]  Избыточные числа условий.
[35:24.240 --> 35:27.240]  Вот, ну вот, так или иначе, мы обсуждали следующее.
[35:27.240 --> 35:31.240]  Что формула выполнима...
[35:33.240 --> 35:40.240]  Формула выполнима тогда и только тогда,
[35:40.240 --> 35:44.240]  когда ни для одной переменной,
[35:47.240 --> 35:50.240]  ни для какой переменной
[35:51.240 --> 35:53.240]  нет одновременно
[35:58.240 --> 36:00.240]  пути...
[36:00.240 --> 36:02.240]  или там, путей.
[36:04.240 --> 36:08.240]  Значит, путей из p в не p
[36:08.240 --> 36:10.240]  и из не p в p.
[36:14.240 --> 36:16.240]  Вот.
[36:17.240 --> 36:19.240]  Ну, теперь мы знаем.
[36:19.240 --> 36:21.240]  Теперь мы знаем, что нет путей,
[36:21.240 --> 36:25.240]  можно проверять налогографической памяти.
[36:26.240 --> 36:29.240]  Но при этом и граф соответствующий
[36:29.240 --> 36:32.240]  тоже можно изготавливать в налогографической памяти.
[36:33.240 --> 36:35.240]  Вот, можно вообще граф не изготавливать,
[36:35.240 --> 36:38.240]  а на лету по формуле понимать, есть там ребро или нет.
[36:38.240 --> 36:41.240]  Да, просто перебирая все скобочки.
[36:42.240 --> 36:44.240]  Вот.
[36:44.240 --> 36:46.240]  И это пока что лезет в NL.
[36:47.240 --> 36:49.240]  Да, потому что нам нужно сделать цикл
[36:49.240 --> 36:51.240]  по всем переменам.
[36:51.240 --> 36:53.240]  И это нам даст еще один счетчик.
[36:55.240 --> 36:57.240]  Вот, и соответственно
[37:00.240 --> 37:02.240]  проверять для каждой перемены,
[37:02.240 --> 37:04.240]  что нет одновременно пути
[37:04.240 --> 37:07.240]  из p в не p и из не p в p.
[37:07.240 --> 37:09.240]  Вот.
[37:09.240 --> 37:11.240]  Да, давайте я тут допишу.
[37:11.240 --> 37:13.240]  Значит, вот это вот
[37:13.240 --> 37:15.240]  проверяется
[37:18.240 --> 37:20.240]  в NL.
[37:24.240 --> 37:25.240]  Так.
[37:25.240 --> 37:27.240]  Ну, ничего, понятно?
[37:27.240 --> 37:28.240]  Вот.
[37:28.240 --> 37:30.240]  Хорошо, ну теперь давайте еще
[37:30.240 --> 37:32.240]  я расскажу, почему
[37:32.240 --> 37:34.240]  2сад это NL полная задача.
[37:34.240 --> 37:36.240]  Значит, 2сад
[37:38.240 --> 37:40.240]  2сад это NL полная
[37:42.240 --> 37:44.240]  задача.
[37:46.240 --> 37:48.240]  Ну, для этого нужно просто
[37:48.240 --> 37:50.240]  к ней свести
[37:50.240 --> 37:52.240]  p в
[37:56.240 --> 37:58.240]  Так, ну точнее лучше, наверное,
[37:58.240 --> 38:00.240]  к ней свести
[38:00.240 --> 38:02.240]  p в
[38:02.240 --> 38:04.240]  Так, ну точнее лучше, наверное,
[38:04.240 --> 38:06.240]  p с чертой
[38:08.240 --> 38:10.240]  p с чертой
[38:10.240 --> 38:12.240]  логрифически сводится
[38:12.240 --> 38:14.240]  к 2сад.
[38:15.240 --> 38:17.240]  Так, ну идея сводимости такая,
[38:17.240 --> 38:19.240]  что вот у нас есть
[38:19.240 --> 38:21.240]  некоторый граф.
[38:21.240 --> 38:23.240]  Значит, есть некоторый граф.
[38:23.240 --> 38:25.240]  В нем есть s, есть t.
[38:28.240 --> 38:30.240]  И мы
[38:30.240 --> 38:32.240]  хотим делать следующее.
[38:32.240 --> 38:34.240]  Мы хотим для каждой вершины
[38:34.240 --> 38:36.240]  придумать
[38:36.240 --> 38:38.240]  какое-то логическое значение.
[38:38.240 --> 38:40.240]  Значит, так, чтобы
[38:40.240 --> 38:42.240]  в s
[38:42.240 --> 38:44.240]  значит, в s была бы
[38:44.240 --> 38:46.240]  единица, в t был бы
[38:46.240 --> 38:48.240]  ноль, ну
[38:48.240 --> 38:50.240]  и соответственно, значит,
[38:50.240 --> 38:52.240]  все, что достижимо
[38:54.240 --> 38:56.240]  значит, вот здесь была бы единица
[38:56.240 --> 38:58.240]  всюду, значит, во всех вершин,
[38:58.240 --> 39:00.240]  которые достижимы из s.
[39:00.240 --> 39:02.240]  И наоборот,
[39:02.240 --> 39:04.240]  значит, во всех вершинах, из которых
[39:06.240 --> 39:08.240]  достижимо t,
[39:08.240 --> 39:10.240]  чтобы был бы ноль.
[39:14.240 --> 39:16.240]  Ну, ясно, что такое можно делать, если пути нету.
[39:16.240 --> 39:18.240]  Если пути нету,
[39:18.240 --> 39:20.240]  то нет ни одной вершины, которая
[39:20.240 --> 39:22.240]  одновременно была бы достижимой из s
[39:22.240 --> 39:24.240]  и такой, что из нее
[39:24.240 --> 39:26.240]  достижимо t.
[39:26.240 --> 39:28.240]  Да, можно этим дать единицу, этим дать ноль.
[39:30.240 --> 39:32.240]  А, соответственно, если
[39:32.240 --> 39:34.240]  путь есть, то так нельзя сделать.
[39:34.240 --> 39:36.240]  Ну, вот получается, что отсутствие
[39:36.240 --> 39:38.240]  пути и равносение выполнимости этой формы.
[39:40.240 --> 39:42.240]  Ну, в общем, получается, что у нас
[39:44.240 --> 39:46.240]  переменная,
[39:46.240 --> 39:48.240]  одна переменная
[39:48.240 --> 39:50.240]  для каждой вершины
[39:56.240 --> 39:58.240]  Да, значит, есть одна переменная
[39:58.240 --> 40:00.240]  для каждой вершины.
[40:00.240 --> 40:02.240]  Вот, соответственно,
[40:02.240 --> 40:04.240]  ну, будешь считать, что она так
[40:04.240 --> 40:06.240]  же и обозначается, как сама вершина.
[40:06.240 --> 40:08.240]  Соответственно,
[40:08.240 --> 40:10.240]  одна у нас
[40:10.240 --> 40:12.240]  одного слоя будет просто s,
[40:12.240 --> 40:14.240]  значит,
[40:14.240 --> 40:16.240]  другой слою будет
[40:16.240 --> 40:18.240]  отрицание t.
[40:18.240 --> 40:20.240]  Ну, и для ребра
[40:20.240 --> 40:22.240]  значит,
[40:24.240 --> 40:26.240]  для ребра
[40:28.240 --> 40:30.240]  x и y
[40:30.240 --> 40:32.240]  мы вводим два условия.
[40:34.240 --> 40:36.240]  Нужно, чтобы у них было одинаковое значение.
[40:36.240 --> 40:38.240]  Одинаковое значение будет
[40:38.240 --> 40:40.240]  так, x или не y
[40:40.240 --> 40:42.240]  и y или не x.
[40:44.240 --> 40:46.240]  Ну, то есть они равносимны.
[40:50.240 --> 40:52.240]  Вот.
[40:52.240 --> 40:54.240]  Ну, вот, если мы все эти условия
[40:54.240 --> 40:56.240]  напишем
[40:56.240 --> 40:58.240]  и возьмем комьюнцию,
[40:58.240 --> 41:00.240]  значит,
[41:00.240 --> 41:02.240]  все условия одновременно
[41:04.240 --> 41:06.240]  все условия одновременно
[41:08.240 --> 41:10.240]  выполнены
[41:10.240 --> 41:12.240]  тогда и только тогда,
[41:12.240 --> 41:14.240]  когда пути
[41:16.240 --> 41:18.240]  из s в t нет.
[41:20.240 --> 41:22.240]  Ну, да.
[41:40.240 --> 41:42.240]  Ну, мы так хотим.
[41:42.240 --> 41:44.240]  Ну, что?
[41:44.240 --> 41:46.240]  Если из x идет ребро в y,
[41:46.240 --> 41:48.240]  то у них одинаковое значение.
[41:50.240 --> 41:52.240]  Нет.
[42:02.240 --> 42:04.240]  Нет.
[42:04.240 --> 42:06.240]  Значит, мы хотим, чтобы
[42:06.240 --> 42:08.240]  истинными были те вершины, которые достижимы из s,
[42:08.240 --> 42:10.240]  а лозными были те вершины, из которых
[42:10.240 --> 42:12.240]  достижимы t.
[42:20.240 --> 42:24.240]  А, ну, это вы, конечно, правильно говорите,
[42:24.240 --> 42:26.240]  но такие можно, наверное, просто исключить.
[42:36.240 --> 42:38.240]  А.
[42:42.240 --> 42:46.240]  А, то есть вы хотите сказать, что это не нужно,
[42:46.240 --> 42:48.240]  не нужна равносильность, да?
[42:50.240 --> 42:52.240]  Да.
[42:52.240 --> 42:54.240]  Да, пожалуй, вы правы.
[42:54.240 --> 42:56.240]  А это значит,
[42:56.240 --> 42:58.240]  это значит,
[42:58.240 --> 43:00.240]  только вот эту штуку надо оставить, да?
[43:08.240 --> 43:10.240]  Да.
[43:10.240 --> 43:12.240]  Да, пожалуй, вы правы.
[43:12.240 --> 43:14.240]  Так, надо сделать.
[43:20.240 --> 43:22.240]  finished, да?
[43:28.240 --> 43:30.240]  Да, тогда просто,
[43:30.240 --> 43:32.240]  да, тогда просто единица распространяется поребрям, да,
[43:32.240 --> 43:34.240]  но не распространяется обратно.
[43:34.240 --> 43:36.240]  А ноль наоборот, ноль распространяется обратно,
[43:36.240 --> 43:38.240]  но не распространяется поребрям.
[43:40.240 --> 43:42.240]  Да.
[43:42.240 --> 43:44.240]  Да, пожалуй, вы правы.
[43:46.240 --> 43:48.240]  Спасибо за исправление.
[43:48.240 --> 43:52.240]  Да, теперь правильно. Теперь правильно, да, значит, что
[43:52.240 --> 43:56.240]  действительно, s должно быть равно единице,
[43:56.240 --> 44:02.240]  если из s куда-то идёт, тогда то, куда идёт, тоже равно единице,
[44:02.240 --> 44:07.240]  да, значит, и по ребрам это всё распространится.
[44:07.240 --> 44:11.240]  Да, значит,
[44:11.240 --> 44:15.240]  действительно, да, значит, нам нужно, чтобы
[44:15.240 --> 44:19.240]  вот такое вот ребро допустимо,
[44:19.240 --> 44:23.240]  раньше такое ребро допустимо, и тут как раз вот нуля единицы может быть.
[44:29.240 --> 44:33.240]  Так, да, ну ладно,
[44:33.240 --> 44:37.240]  ладно, действительно, было неправильно вначале.
[44:39.240 --> 44:43.240]  Так, какие-то ещё вопросы?
[44:45.240 --> 44:49.240]  Так, ну в общем, про логическую память, это более-менее всё, что я хотел сказать.
[44:55.240 --> 44:59.240]  Значит, есть ещё одна тема, которая тоже связана с этим,
[44:59.240 --> 45:03.240]  но вообще с другой стороны стоит вообще немножко сомнительнее,
[45:03.240 --> 45:07.240]  то есть, в общем-то,
[45:07.240 --> 45:11.240]  в общем-то, есть ещё одна тема, которая тоже связана с этим,
[45:11.240 --> 45:15.240]  но вообще с другой стороны стоит вообще немножко с огняком,
[45:15.240 --> 45:19.240]  значит, эта тема, эта тема
[45:19.240 --> 45:23.240]  из логических элементов, да,
[45:23.240 --> 45:27.240]  или из функциональных элементов, или их называют контактные релейнами.
[45:33.240 --> 45:37.240]  Во, значит, это такое,
[45:37.240 --> 45:41.240]  в принципе, такая схема, это вообще альтернативная модель вычисления,
[45:41.240 --> 45:45.240]  которая, в принципе, по-другому устроена.
[45:45.240 --> 45:49.240]  Но она тоже имеет некоторые корни в реальности,
[45:49.240 --> 45:53.240]  значит, а именно
[45:53.240 --> 45:57.240]  реальные электронные микросхемы, они прямо так и устроены.
[46:01.240 --> 46:05.240]  Схема
[46:07.240 --> 46:11.240]  из функциональных элементов.
[46:13.240 --> 46:17.240]  Значит, функциональными элементами
[46:17.240 --> 46:21.240]  называются такие вот
[46:21.240 --> 46:25.240]  буквы, например,
[46:25.240 --> 46:29.240]  комьюнция, комьюнция
[46:29.240 --> 46:33.240]  и отрицание.
[46:33.240 --> 46:37.240]  На них смотреть, как действительно такие там релеи,
[46:37.240 --> 46:41.240]  действительно, элементы микросхемы,
[46:41.240 --> 46:45.240]  у них есть какие-то там проводки, которые поступают на вход,
[46:45.240 --> 46:49.240]  и, соответственно, проводок или нет проводков, которые выходят
[46:49.240 --> 46:53.240]  наружу. И, соответственно, там в каждом проводке
[46:53.240 --> 46:57.240]  может быть какой-то бит, то есть либо есть ток, либо нет тока.
[46:57.240 --> 47:01.240]  А этот элемент преобразует входные сигналы так, чтобы
[47:01.240 --> 47:05.240]  на выходе получился сигнал
[47:05.240 --> 47:09.240]  сообразно-логической функции, которая на элементе написана.
[47:09.240 --> 47:13.240]  Ну, вот, реально, там, процессоры примерно
[47:13.240 --> 47:17.240]  из таких мелких транзисторов и паяют.
[47:17.240 --> 47:21.240]  Ну, и сейчас, конечно, там не паяют, как по-другому делают, да, но, в общем,
[47:21.240 --> 47:25.240]  изготавливают действительно платы с очень-очень мелкими
[47:25.240 --> 47:29.240]  вот такими вот элементами. Нет, это не такие, да, но какие-то.
[47:31.240 --> 47:35.240]  Ну, вот.
[47:37.240 --> 47:41.240]  Ну, известно, да, что вот через
[47:41.240 --> 47:45.240]  действительно дезъюнцию, конъюнцию и отрицание можно
[47:45.240 --> 47:49.240]  определить любую функцию. Соответственно, если у вас есть
[47:49.240 --> 47:53.240]  неограниченный запас таких элементов, то из них можно спаять
[47:53.240 --> 47:57.240]  тему, которая вычисляет любую функцию, но
[47:57.240 --> 48:01.240]  с предписанным числом входов. Ну, например, может быть,
[48:01.240 --> 48:05.240]  такая схема, да, значит, на входе есть х, есть у.
[48:05.240 --> 48:09.240]  Значит, а дальше, например, я
[48:09.240 --> 48:13.240]  делаю отрицание.
[48:13.240 --> 48:17.240]  Теперь у меня есть не х, не у,
[48:17.240 --> 48:21.240]  в дополнение к эту у. Значит, дальше
[48:21.240 --> 48:25.240]  я беру, например,
[48:25.240 --> 48:31.240]  конъюнцию здесь
[48:31.240 --> 48:35.240]  и конъюнцию
[48:35.240 --> 48:39.240]  так, нет, а, ну, можно
[48:39.240 --> 48:43.240]  да, можно вот так вот.
[48:43.240 --> 48:47.240]  Конъюнцию здесь, конъюнцию здесь, да, значит, а здесь беру дезъюнцию.
[48:47.240 --> 48:51.240]  И вот это как бы отправил
[48:51.240 --> 48:55.240]  на выход. Вот, значит, тут смотрите,
[48:55.240 --> 48:59.240]  что происходит. Думаю, что мы сигнал еще можем
[48:59.240 --> 49:03.240]  как бы размножать. Да, то есть, можно
[49:03.240 --> 49:07.240]  считать, что это просто два разных проводка, на выходе получает один тот же ответ.
[49:07.240 --> 49:11.240]  Можно представить, что здесь еще там стоит элемент, там,
[49:11.240 --> 49:15.240]  удвоитель, который на вход получает какой-то сигнал
[49:15.240 --> 49:19.240]  и его по двум выходам отправляет.
[49:19.240 --> 49:23.240]  Вот. Ну вот, скорее всего, если на все это вместе
[49:23.240 --> 49:27.240]  посмотреть, да, можно все это вместе посмотреть, как на черный ящик,
[49:27.240 --> 49:31.240]  у которого вот есть два обхода и один выход.
[49:31.240 --> 49:35.240]  Тогда что это за элемент получается?
[49:35.240 --> 49:39.240]  Так, только я что-то не то вообще не представлял.
[49:39.240 --> 49:43.240]  Так, опять, извините, я написал, что у меня дублируется
[49:43.240 --> 49:47.240]  то же самое, а я хотел, нет, я хотел вот так их нарисовать.
[49:47.240 --> 49:51.240]  Да, вот теперь это,
[49:51.240 --> 49:55.240]  ну, теперь что-то осмысленное.
[49:57.240 --> 50:01.240]  Это раньше я дублировал, а теперь не дублирую.
[50:01.240 --> 50:05.240]  Да, это не XOR, а наоборот, эквивалент.
[50:05.240 --> 50:09.240]  Да, то есть вот это все вместе, это, значит,
[50:09.240 --> 50:13.240]  эквивалент.
[50:13.240 --> 50:17.240]  Вот.
[50:17.240 --> 50:21.240]  Вот.
[50:21.240 --> 50:25.240]  Вот.
[50:25.240 --> 50:29.240]  Вот.
[50:29.240 --> 50:33.240]  А, значит, эквивалент.
[50:33.240 --> 50:37.240]  А чтобы XOR нужно переключить, да, чтобы в XOR
[50:37.240 --> 50:41.240]  нужно, наоборот, вот это переключить сюда,
[50:41.240 --> 50:45.240]  а вот это переключить сюда.
[50:45.240 --> 50:49.240]  Вот. Ну, соответственно, вот
[50:49.240 --> 50:53.240]  такими штуками можно набирать
[50:53.240 --> 50:57.240]  какие-то сложные схемы, которые можно себе представлять,
[50:57.240 --> 51:01.240]  ну, вот так вот, да, что есть такой черный ящик,
[51:01.240 --> 51:05.240]  у которого много проводков на входе, один, ну, что если это
[51:05.240 --> 51:09.240]  булева функция, то один проводок на выходе, а может быть и больше проводков на выходе,
[51:09.240 --> 51:13.240]  если это какая-то вообще искрепная функция. Вот. Ну, а внутри
[51:13.240 --> 51:17.240]  черный ящик, который выглядит как каким-то вот таким образом.
[51:17.240 --> 51:21.240]  Вот.
[51:21.240 --> 51:25.240]  Ну, значит, особо глубоко
[51:25.240 --> 51:29.240]  в теорию я не хочу вдаваться, да, потому что тут
[51:29.240 --> 51:33.240]  ну, нужно какое-то формальное определение, что это такое, формально
[51:33.240 --> 51:37.240]  это будет, например, направленный граф с отметками,
[51:37.240 --> 51:41.240]  да, то есть
[51:41.240 --> 51:45.240]  ну, с отметками на вершинах, да, то есть отметка на вершине
[51:45.240 --> 51:49.240]  говорит какого типа этот элемент, да, или это вход,
[51:49.240 --> 51:53.240]  или это выход, или это какой-то преобразователь.
[51:53.240 --> 51:57.240]  Ну, и важно, чтобы этот граф был ориентированным без циклов,
[51:57.240 --> 52:01.240]  да, потому что если он будет циклами, то это
[52:01.240 --> 52:05.240]  ну, может, конечно, не такую спаять схему, но что там будет происходить, не очень понятно.
[52:05.240 --> 52:09.240]  Вот. Если он без циклов, тогда понятно, мы идем как бы
[52:09.240 --> 52:13.240]  сверху вниз, да, и вычисляем.
[52:13.240 --> 52:17.240]  Вот. Есть такая теорема от топологической сортировки, да, что если у вас есть граф
[52:17.240 --> 52:21.240]  ориентированным без циклов, то можно сортировать его вершина,
[52:21.240 --> 52:25.240]  да, сортировать его вершина так, чтобы ребра шли из вершины с меньшими номерами
[52:25.240 --> 52:29.240]  вершины с большими номерами. Ну, и тогда в соответствии
[52:29.240 --> 52:33.240]  с этими номерами можно вычислить те результаты.
[52:33.240 --> 52:37.240]  Да, идя просто вдоль этих номеров.
[52:37.240 --> 52:41.240]  Ну, чего, прямо понятно?
[52:41.240 --> 52:45.240]  Так, теперь только остаются сложности.
[52:45.240 --> 52:49.240]  Значит, тут есть два параметра.
[52:49.240 --> 52:53.240]  Два параметра у схемы,
[52:53.240 --> 52:57.240]  которые нас интересуют. Значит, это размер
[52:57.240 --> 53:01.240]  и глубина. Ну, размер это просто
[53:01.240 --> 53:05.240]  число вершин и число элементов.
[53:05.240 --> 53:09.240]  Ну, а глубина это
[53:09.240 --> 53:13.240]  максимальная длина цепочки от входной до выходной.
[53:13.240 --> 53:17.240]  Вершина.
[53:17.240 --> 53:21.240]  Ну, там опять же возможны вариации,
[53:21.240 --> 53:25.240]  типа считаем ли мы сами входную или выходную вершину,
[53:25.240 --> 53:29.240]  или не считаем. В общем, это будет там плюс-минус
[53:29.240 --> 53:33.240]  два. Это всё не очень важно.
[53:33.240 --> 53:37.240]  Вот.
[53:37.240 --> 53:41.240]  Значит, вот получается две характеристики.
[53:41.240 --> 53:45.240]  Две характеристики это
[53:45.240 --> 53:49.240]  размер
[53:49.240 --> 53:53.240]  и глубина.
[53:53.240 --> 53:57.240]  Вот. Ну, а при этом у нас
[53:57.240 --> 54:01.240]  число входов у схемы фиксировано.
[54:01.240 --> 54:05.240]  Значит,
[54:05.240 --> 54:09.240]  число входов
[54:09.240 --> 54:13.240]  фиксировано.
[54:13.240 --> 54:17.240]  Поэтому в контексте распознавания языков говорят не об одной схеме,
[54:17.240 --> 54:21.240]  а о семейской схеме. Значит,
[54:21.240 --> 54:25.240]  поэтому
[54:25.240 --> 54:29.240]  применительно
[54:29.240 --> 54:33.240]  к сложности задача
[54:33.240 --> 54:37.240]  говорить
[54:37.240 --> 54:41.240]  говорят
[54:41.240 --> 54:45.240]  не об одной схеме,
[54:45.240 --> 54:49.240]  а о семейской схеме.
[54:55.240 --> 54:59.240]  Осьмейской схеме.
[54:59.240 --> 55:03.240]  Да, кстати, схема здесь по-английски
[55:03.240 --> 55:07.240]  это не skim, как можно подумать, а circuit.
[55:07.240 --> 55:11.240]  То есть
[55:11.240 --> 55:15.240]  схема называется circuit.
[55:23.240 --> 55:27.240]  Вот. Boolean схемы это ещё называется.
[55:27.240 --> 55:31.240]  Boolean circuits обычно говорят по-английски.
[55:31.240 --> 55:35.240]  Вот. Ну, в общем, cn имеет ввиду, что для каждой длины входа
[55:35.240 --> 55:39.240]  есть своя схема. И нас интересуется этим точка.
[55:39.240 --> 55:43.240]  Значит, насколько растёт размер и глубина.
[55:43.240 --> 55:47.240]  Вот. На самом деле, значит,
[55:47.240 --> 55:51.240]  в принципе нас ещё может интересовать
[55:51.240 --> 55:55.240]  можно ли вычислить, зная n, можно ли вычислить cn и насколько эффективно.
[55:55.240 --> 55:59.240]  Вот. Если мы вообще никаких ограничений не делаем,
[55:59.240 --> 56:03.240]  то есть у нас и размер какой угодно, и глубина какая угодно,
[56:03.240 --> 56:07.240]  и вычислять не обязательно,
[56:07.240 --> 56:11.240]  тогда вообще любая функция,
[56:11.240 --> 56:15.240]  любой язык будет распознаваться в семейском схеме
[56:15.240 --> 56:19.240]  экспедиенциального размера.
[56:19.240 --> 56:23.240]  Значит, любой,
[56:23.240 --> 56:27.240]  совершенно любой язык,
[56:27.240 --> 56:31.240]  любой язык распознаётся
[56:31.240 --> 56:35.240]  в семейском схеме
[56:35.240 --> 56:39.240]  в семейском схеме
[56:39.240 --> 56:43.240]  экспедиенциального размера.
[56:43.240 --> 56:47.240]  Вот. Ну, это классическая теория.
[56:47.240 --> 56:51.240]  Да, значит, если мы в качестве экспедиенциального размера
[56:51.240 --> 56:55.240]  возьмём вот такой вот
[56:55.240 --> 56:59.240]  порядка n на 2 степени n,
[56:59.240 --> 57:03.240]  то это просто обычное там dnf или knf.
[57:03.240 --> 57:07.240]  Значит, dnf или knf
[57:07.240 --> 57:11.240]  стандартным образом строящиеся они вот такого размера будут.
[57:11.240 --> 57:15.240]  Так. Ну, этого, я думаю, вы изучали.
[57:15.240 --> 57:19.240]  Ну, значит, есть более хитрый способ, который позволяет
[57:19.240 --> 57:23.240]  за это какие-то похожие вещи находить
[57:23.240 --> 57:27.240]  и переиспользовать, значит, который получается порядка
[57:27.240 --> 57:31.240]  2 в степени андилитно, а n он не умножит.
[57:31.240 --> 57:35.240]  Значит, это уже хитрый способ. Называется керема Лупанова.
[57:39.240 --> 57:43.240]  Вот. Тоже классический результат из 1958 года.
[57:43.240 --> 57:47.240]  Вот. Но уже такой технически сложный.
[57:47.240 --> 57:51.240]  Вот. Существенно меньше сделать нельзя
[57:51.240 --> 57:55.240]  из соображений типа принципа Дерехле.
[57:55.240 --> 57:59.240]  Да, то есть, поскольку всех функций там от n переменных будет 2 в степени 2 в степени n,
[57:59.240 --> 58:03.240]  если аккуратно посчитать, сколько будет графов там меньшего размера,
[58:03.240 --> 58:07.240]  то их просто меньше будет. Вот. Поэтому это
[58:07.240 --> 58:11.240]  довольно точная граница. Ну, с точностью до того, какая здесь константа.
[58:11.240 --> 58:15.240]  В нижней оценке и в кереме Лупановой
[58:15.240 --> 58:19.240]  немножко разные константы, но порядок просто один и тот же.
[58:19.240 --> 58:23.240]  Вот. Но поэтому, раз экспедиционного размера
[58:23.240 --> 58:27.240]  значит, раз экспедиционного размера
[58:27.240 --> 58:31.240]  годится всегда,
[58:31.240 --> 58:35.240]  то возникает вопрос, а можно меньшего размера?
[58:35.240 --> 58:39.240]  Ну и об чем нас вообще это интересует? Ну, смотрите, если мы это
[58:39.240 --> 58:43.240]  паяем как микросхему,
[58:43.240 --> 58:47.240]  значит, если мы паяем как микросхему, то размер, это
[58:47.240 --> 58:51.240]  грубо говоря, стоимость этой микросхемы. То есть, сколько там релея
[58:51.240 --> 58:55.240]  нам нужно купить, чтобы паять с этой микросхемой.
[58:55.240 --> 58:59.240]  Вот. А вот глубина отвечает за быстродействие.
[58:59.240 --> 59:03.240]  Потому что если сигнал там по каждому проводку
[59:03.240 --> 59:07.240]  там проходит за один такт, то как раз какая-то глубина будет,
[59:07.240 --> 59:11.240]  за столько такта все это и будет вычисляться.
[59:13.240 --> 59:17.240]  Ой, ну, в общем-то, просто размерские слова там,
[59:17.240 --> 59:21.240]  size и depth используют.
[59:27.240 --> 59:31.240]  Ну вот.
[59:31.240 --> 59:35.240]  Да, я, кстати, что-то не написал, давайте я напису
[59:35.240 --> 59:39.240]  в доске, что размер, значит, размер
[59:39.240 --> 59:43.240]  число вершин, размер число вершин,
[59:43.240 --> 59:47.240]  значит, глубина
[59:47.240 --> 59:51.240]  это кратчайший путь,
[59:51.240 --> 59:55.240]  кратчайший путь от
[59:55.240 --> 59:59.240]  входа к выходу. Ой, не кратчайший,
[59:59.240 --> 01:00:03.240]  а наоборот длиннейший.
[01:00:03.240 --> 01:00:07.240]  Длиннейший путь
[01:00:07.240 --> 01:00:11.240]  кратчайший путь от входа к выходу.
[01:00:11.240 --> 01:00:15.240]  Вот. Ну и, соответственно,
[01:00:15.240 --> 01:00:19.240]  дальше начинаются
[01:00:19.240 --> 01:00:23.240]  сложностные классы. Значит, вот p, такое
[01:00:23.240 --> 01:00:27.240]  обозначение, p slash poly.
[01:00:27.240 --> 01:00:31.240]  p slash poly, значит, это языки
[01:00:31.240 --> 01:00:35.240]  распознаваемые
[01:00:35.240 --> 01:00:39.240]  имейством с тем
[01:00:39.240 --> 01:00:43.240]  размера
[01:00:43.240 --> 01:00:47.240]  полинома t.
[01:00:51.240 --> 01:00:55.240]  Вот.
[01:00:55.240 --> 01:00:59.240]  Ну и там, например,
[01:00:59.240 --> 01:01:03.240]  можно заметить,
[01:01:03.240 --> 01:01:07.240]  на самом деле, любой
[01:01:07.240 --> 01:01:11.240]  любой полиномиальный язык будет
[01:01:11.240 --> 01:01:15.240]  в t slash poly тоже.
[01:01:19.240 --> 01:01:23.240]  Да, значит.
[01:01:23.240 --> 01:01:27.240]  Да, значит.
[01:01:39.240 --> 01:01:43.240]  Значит, ну вот, можно сказать,
[01:01:43.240 --> 01:01:47.240]  теорема 100p трога вложена
[01:01:47.240 --> 01:01:51.240]  с p slash poly. Значит, тут еще может быть
[01:01:51.240 --> 01:01:55.240]  вопрос, что такое странное обозначение на какое-то p slash poly.
[01:01:55.240 --> 01:01:59.240]  Ну, на самом деле, это связано с другим определением
[01:01:59.240 --> 01:02:03.240]  того, что это за класса. Можно себе представлять, что
[01:02:03.240 --> 01:02:07.240]  есть как бы интерпретатор схемы,
[01:02:07.240 --> 01:02:11.240]  и он сам по себе, если у него схема уже есть, он ее может вычислять
[01:02:11.240 --> 01:02:15.240]  быстро за полином. И поэтому p.
[01:02:15.240 --> 01:02:19.240]  А вот это вот poly, это значит, что сама схема полинованного размера.
[01:02:19.240 --> 01:02:23.240]  Вот. Да, и вот видите, тут
[01:02:23.240 --> 01:02:27.240]  это значение означает, что вложено и не равно.
[01:02:27.240 --> 01:02:31.240]  То есть, с одной стороны вложено, но с другой стороны есть языки
[01:02:31.240 --> 01:02:35.240]  с p slash poly, которые не лежат.
[01:02:35.240 --> 01:02:39.240]  Ну а если по крайней мере идейно обсудим,
[01:02:39.240 --> 01:02:43.240]  доказательства.
[01:02:43.240 --> 01:02:47.240]  Ну, идейно, что вложено,
[01:02:47.240 --> 01:02:51.240]  это более-менее аналогично теремику Клевина.
[01:02:51.240 --> 01:02:55.240]  Аналогично
[01:02:59.240 --> 01:03:03.240]  теремику Клевина.
[01:03:03.240 --> 01:03:07.240]  Ну, что означает, что машина работает
[01:03:07.240 --> 01:03:11.240]  в полиномальное время, значит, у нее каждая конфигурация
[01:03:11.240 --> 01:03:15.240]  полиномального размера, их полиномальное количество.
[01:03:15.240 --> 01:03:19.240]  У нее есть некоторый протокол,
[01:03:19.240 --> 01:03:23.240]  протокол, который как-то вот так вот выглядит.
[01:03:27.240 --> 01:03:31.240]  Ну и тут, соответственно, тут, на самом деле, каждая клетка
[01:03:31.240 --> 01:03:35.240]  значит, каждая клетка является функцией
[01:03:35.240 --> 01:03:39.240]  от небольшого числа клеток на дни.
[01:03:39.240 --> 01:03:43.240]  И можно просто вот это вот как бы выразить
[01:03:43.240 --> 01:03:47.240]  какой-то функции, эту функцию
[01:03:47.240 --> 01:03:51.240]  как-то выразить соответственно схемой. Ну и просто после этого ее как бы
[01:03:51.240 --> 01:03:55.240]  все эти функции запаять в количестве t в квадрате раз.
[01:03:55.240 --> 01:03:59.240]  Ну t это полином, поэтому t в квадрате тоже полином, поэтому мы так все возьмем, вычислим
[01:03:59.240 --> 01:04:03.240]  и будет единица.
[01:04:03.240 --> 01:04:07.240]  А входа мне, ну а как вход, вот там в первой ячейке
[01:04:07.240 --> 01:04:11.240]  нужно записать бита х.
[01:04:11.240 --> 01:04:15.240]  Тут у нас уже нет никакого y в отличие от телемку Клевина.
[01:04:15.240 --> 01:04:19.240]  Да, есть только начальница стояния, соответственно, бита х,
[01:04:19.240 --> 01:04:23.240]  ну и дополнительные клетки.
[01:04:23.240 --> 01:04:27.240]  Ну а их как бы константы нужно инициализировать.
[01:04:27.240 --> 01:04:31.240]  Ну константу можно получить, либо можно считать, что она прям дана,
[01:04:31.240 --> 01:04:35.240]  либо можно вычислить, как там p или не p,
[01:04:35.240 --> 01:04:39.240]  как единица, и p или не p, как ноль.
[01:04:39.240 --> 01:04:43.240]  Да, то есть константа, так или иначе, можно
[01:04:43.240 --> 01:04:47.240]  как-то приготовить и, соответственно, сюда падает.
[01:04:47.240 --> 01:04:51.240]  Вот.
[01:04:51.240 --> 01:04:55.240]  Значит, это вот поэтому вложено.
[01:04:55.240 --> 01:04:59.240]  Ну а не равно,
[01:04:59.240 --> 01:05:03.240]  потому что может быть даже вообще невычислимая зависимость.
[01:05:03.240 --> 01:05:07.240]  То есть идея в том, что может быть вообще
[01:05:07.240 --> 01:05:11.240]  невычислимая,
[01:05:11.240 --> 01:05:15.240]  невычислимая зависимость
[01:05:15.240 --> 01:05:19.240]  на там схемы ценные от n.
[01:05:19.240 --> 01:05:23.240]  Ну, например, можно взять какую-то вообще неразрешимую задачу,
[01:05:23.240 --> 01:05:27.240]  например, к проблему там остановки.
[01:05:27.240 --> 01:05:31.240]  И, соответственно, рассмотреть
[01:05:31.240 --> 01:05:35.240]  вот такой язык, унарный,
[01:05:35.240 --> 01:05:39.240]  значит, один степень n имеет в виду, что это n единиц подряд.
[01:05:39.240 --> 01:05:43.240]  То есть слово из n единиц
[01:05:43.240 --> 01:05:47.240]  таких, что n лежит
[01:05:47.240 --> 01:05:51.240]  в языке halt.
[01:05:51.240 --> 01:05:55.240]  То есть n кодирует там машину тюринга и вход, на котором она останавливается.
[01:05:55.240 --> 01:05:59.240]  Ну, каким-то образом мы договорились, как кодировать
[01:05:59.240 --> 01:06:03.240]  пары из машины кода. Ну, может
[01:06:03.240 --> 01:06:07.240]  считать, что это проблема самопременимости, то есть n является номером машины,
[01:06:07.240 --> 01:06:11.240]  которая останавливается на собственном номере.
[01:06:11.240 --> 01:06:15.240]  В принципе, совершенно неважно, здесь можно любой язык
[01:06:15.240 --> 01:06:19.240]  неразрешимую взять, и конструкция будет одинаковой.
[01:06:19.240 --> 01:06:23.240]  Тогда получается, что смотрите, что у нас для фиксированного n, у нас получается, что
[01:06:23.240 --> 01:06:27.240]  либо слово из всех единиц входит, а остальные не входят.
[01:06:27.240 --> 01:06:31.240]  И тогда эта схема, это просто конъюнция всех кодов.
[01:06:31.240 --> 01:06:35.240]  Либо вообще ни одно слово не входит.
[01:06:35.240 --> 01:06:39.240]  То есть для фиксированной длины у нас либо нет ни одного слова, либо есть ровно одно из всех единиц.
[01:06:39.240 --> 01:06:43.240]  И, соответственно, если нет ни одного слова,
[01:06:43.240 --> 01:06:47.240]  это просто ажестно ложная функция, а если
[01:06:47.240 --> 01:06:51.240]  все единицы входят, тогда конъюнция всех кодов.
[01:06:51.240 --> 01:06:55.240]  Ну, конъюнция всех кодов, она, понятно, полиминального будет размера.
[01:06:55.240 --> 01:06:59.240]  И там, и там будет схема полиминального размера, и даже довольно простая, но мы не знаем,
[01:06:59.240 --> 01:07:03.240]  где какая.
[01:07:03.240 --> 01:07:07.240]  Вот, поэтому размер полиминальный,
[01:07:07.240 --> 01:07:11.240]  но вычислить при этом не можем, потому что нам, чтобы вычислить,
[01:07:11.240 --> 01:07:15.240]  нам нужно бесконечное число схем по одной или каждого размера.
[01:07:19.240 --> 01:07:23.240]  Вот, с другой стороны, если мы потребуем, чтобы вот эта зависимость была
[01:07:23.240 --> 01:07:27.240]  тоже полиминально вычислимой, тогда это будет просто то же самое.
[01:07:29.240 --> 01:07:33.240]  Ну да. То есть, если p слежь в поле, и при этом схема
[01:07:33.240 --> 01:07:37.240]  для размера n вычисляется за время полиминального от n, то это будет то же самое, что p.
[01:07:43.240 --> 01:07:47.240]  Ну да, ее сначала вычисляем, потом применяем.
[01:07:49.240 --> 01:07:53.240]  Так. Ну, все, понятно.
[01:07:53.240 --> 01:07:57.240]  Так, ну хорошо, значит, соответственно,
[01:07:57.240 --> 01:08:01.240]  так, минутка у нас остается, значит,
[01:08:01.240 --> 01:08:05.240]  небольшой анонс, что мы, по крайней мере, в начале следующего раза будем
[01:08:05.240 --> 01:08:09.240]  изучать, это
[01:08:09.240 --> 01:08:13.240]  говорим про глубину, значит, и вот если раньше мы изучали
[01:08:13.240 --> 01:08:17.240]  логеретмическую память, то теперь у нас будут схемы
[01:08:17.240 --> 01:08:21.240]  логеретмической глубины,
[01:08:21.240 --> 01:08:25.240]  и это как раз будет отвечать теперь за быстродействие.
[01:08:25.240 --> 01:08:29.240]  В случае со схемами, глубина это быстродействие, поэтому логеретмическая глубина
[01:08:29.240 --> 01:08:33.240]  отвечает за быстродействие, в частности
[01:08:33.240 --> 01:08:39.240]  для
[01:08:39.240 --> 01:08:43.240]  сложения. Да, давайте я все-таки
[01:08:43.240 --> 01:08:47.240]  доскажу, это важная идея.
[01:08:47.240 --> 01:08:51.240]  Смотрите, если мы складываем двоичные числа просто в столбик,
[01:08:51.240 --> 01:08:55.240]  как мы изучали на логеретмической памяти, то мы вообще проходим,
[01:08:55.240 --> 01:08:59.240]  чтобы вычислить предпоследний бит, нам нужно сначала
[01:08:59.240 --> 01:09:03.240]  сложить последний понятие, если стан перенос, чтобы вычислить второй,
[01:09:03.240 --> 01:09:07.240]  с конца нам нужно предпоследний вычислить и так далее, и тогда если все раскрутить,
[01:09:07.240 --> 01:09:11.240]  там будет глубина линейная от числа знаков.
[01:09:11.240 --> 01:09:15.240]  И если бы процессор делал так, значит, если процессор
[01:09:15.240 --> 01:09:19.240]  скуминировал просто в столбик, то он бы очень медленно работал,
[01:09:19.240 --> 01:09:23.240]  поэтому процессор использует быстрый сумматор, который
[01:09:23.240 --> 01:09:27.240]  позволяет не каким-то образом параллельно вычислять перенос,
[01:09:27.240 --> 01:09:31.240]  и потом сразу получить себе ответ. Но про этот быстрый сумматор
[01:09:31.240 --> 01:09:35.240]  я хочу рассказать в следующий раз, в начале,
[01:09:35.240 --> 01:09:39.240]  а дальше посмотрим.
[01:09:39.240 --> 01:09:43.240]  Куда дальше идти.
[01:09:43.240 --> 01:09:47.240]  Все, спасибо.
