[00:00.000 --> 00:08.000]  У нас, так или иначе, все это зацеплено на теорию множеств, и в теории множеств есть три понятия.
[00:19.000 --> 00:22.000]  Их три штуки. Это элемент
[00:25.000 --> 00:27.000]  множество
[00:30.000 --> 00:32.000]  и одна
[00:37.000 --> 00:46.000]  Тогда в теории формальных языков мы начинаем с того, что потеряем просто что такое язык. Мы говорим, что язык
[00:53.000 --> 00:55.000]  не язык. Начинаем с алфавита
[01:00.000 --> 01:05.000]  fit- произвольное множество
[01:13.000 --> 01:18.000]  Тогда мы называем элемент алфавита символами
[01:31.000 --> 01:33.000]  Хорошо
[01:35.000 --> 01:37.000]  Так, алфавит символы
[01:39.000 --> 01:42.000]  Дальше мы вводим операции
[01:44.000 --> 01:47.000]  Нам нужна операция конкатонации
[02:00.000 --> 02:02.000]  Слов
[02:05.000 --> 02:07.000]  Где слова
[02:11.000 --> 02:13.000]  Это последовательности
[02:19.000 --> 02:21.000]  И символов алфавита
[02:30.000 --> 02:34.000]  Хороший вопрос будет в том, что такое последовательности
[02:37.000 --> 02:39.000]  Последовательности это
[02:43.000 --> 02:47.000]  по сути отображение из N некоторое множество X
[02:48.000 --> 02:50.000]  Dix мы сами выбираем
[02:51.000 --> 02:56.000]  То есть слова, по сути, будут являться отображениями из N в какой-то алфавит
[02:56.000 --> 03:00.000]  Алфавит, как правило, обозначается за главную букву sigma
[03:09.000 --> 03:11.000]  Так вот, что такое конкатонация слов?
[03:21.000 --> 03:23.000]  У нас есть слово
[03:26.000 --> 03:32.000]  Слово A это sigma 1, так далее sigma N
[03:32.000 --> 03:38.000]  Есть слово B это tau 1, tau N
[03:38.000 --> 03:41.000]  Как правило, мы будем работать с конечными последовательностями
[03:41.000 --> 03:45.000]  Даже не как правило, всегда будем работать с конечными последовательностями
[03:45.000 --> 03:49.000]  Поэтому слова мы можем количествоить не просто последовательности, а конечными
[03:49.000 --> 03:54.000]  Тогда это не из N sigma, а из какого-то конечного
[03:54.000 --> 03:57.000]  Конечно, от множества N такого префикса
[03:57.000 --> 04:00.000]  Чуть позже поговорим про что такое префикс
[04:01.000 --> 04:08.000]  Тогда мы называем A конкатонация B следующую строку
[04:10.000 --> 04:16.000]  sigma 1 sigma N tau 1 tau N
[04:16.000 --> 04:18.000]  Хорошо
[04:32.000 --> 04:44.000]  После этого мы можем взять, вести понятие языка
[04:46.000 --> 04:48.000]  Зелененько уже написано
[04:50.000 --> 04:52.000]  Язык
[04:54.000 --> 04:56.000]  Множество слов
[04:58.000 --> 05:02.000]  Это первое определение, по сути, которое мы можем дать
[05:03.000 --> 05:06.000]  У нас есть какой-то алфавит, на нем есть слова
[05:06.000 --> 05:14.000]  Слова это какие-то конечные последовательности из префикса N в sigma
[05:14.000 --> 05:19.000]  И, соответственно, если мы их как-то насыпем, мы получим множество их языков
[05:19.000 --> 05:21.000]  Это первый вариант
[05:21.000 --> 05:27.000]  Второй вариант будет использовать под собой понятие конкатонации
[05:27.000 --> 05:29.000]  У нас есть конкатонация двух слов
[05:29.000 --> 05:36.000]  Дальше мы можем обобщить понятие конкатонации на языки
[05:36.000 --> 05:46.000]  Изыки обычно обозначаются заглавными латинскими, слова строчными латинскими, символы строчные греческие
[05:46.000 --> 05:52.000]  Афавит, как я сказал, заглавный греческий, как правило, это sigma, gamma, pi
[05:52.000 --> 05:56.000]  Потом, когда мы с этим встретимся, вторым семейством отловим
[05:56.000 --> 06:05.000]  Итого, у нас есть два языка, язык L и язык M, и мы хотим их конкатонировать
[06:05.000 --> 06:09.000]  Что значит конкатонация языков L и N?
[06:09.000 --> 06:24.000]  Это есть множество всех слов, давайте сделаем так, всех слов L на слова M, где L принадлежит L и M принадлежит N
[06:24.000 --> 06:29.000]  Как-то так
[06:29.000 --> 06:34.000]  Тогда мы можем что сделать?
[06:34.000 --> 06:40.000]  Мы можем начать конкатонировать, например, язык с самим собой
[06:40.000 --> 06:47.000]  L, так далее, мы конкатонируем с собой K раз
[06:47.000 --> 06:57.000]  Такую вещь мы будем называть KT степенью языка
[06:57.000 --> 07:02.000]  Хорошо
[07:02.000 --> 07:09.000]  Подобные языка мы можем конкатонировать N раз само собой
[07:09.000 --> 07:22.000]  Это уже слово обозначается точно так же, но только мы понимаем, что это строка из A
[07:22.000 --> 07:29.000]  Также у нас будет некоторая двойственность в том, что есть символ, а что есть слово
[07:29.000 --> 07:36.000]  Потому что сам по себе символ подпадает под определение слова, конечная последовательность
[07:36.000 --> 07:45.000]  Это последовательность, по сути, что отображение из нуля в сам этот символ
[07:45.000 --> 07:56.000]  Благодаря этому мы можем писать здесь даже символы, но при этом все будет работать
[07:56.000 --> 08:03.000]  Аналогично с конкатонацией языков мы можем таким образом конкатонировать, например, афавиты
[08:03.000 --> 08:06.000]  Потому что в чем проблема?
[08:06.000 --> 08:13.000]  Символы это тоже строки, слова, а множество слов это языки, получается правильно
[08:13.000 --> 08:16.000]  Двойственность
[08:16.000 --> 08:19.000]  Хорошо
[08:19.000 --> 08:33.000]  Теперь что мы вводим? Мы вводим звезда к линии и плюс к линии
[08:33.000 --> 08:36.000]  Звезда к линии
[08:36.000 --> 08:43.000]  Вводим мы ее вообще на языках
[08:43.000 --> 08:46.000]  Вот у нас язык R, звезда к линии
[08:46.000 --> 08:56.000]  Это есть объединение по всем степеням от iota равного нуля до плюс бесконечности
[08:56.000 --> 09:06.000]  К такому значку привыкли, уже понимаете, или нужно объяснить, что это?
[09:06.000 --> 09:07.000]  Можете объяснить еще?
[09:07.000 --> 09:09.000]  Ничего не слышу
[09:09.000 --> 09:14.000]  Отзовите кто-нибудь, пожалуйста
[09:14.000 --> 09:16.000]  Ничего не слышу
[09:20.000 --> 09:23.000]  Проясните, пожалуйста
[09:28.000 --> 09:31.000]  Значит, Дима, я не слышу
[09:34.000 --> 09:37.000]  Алло, можете сказать еще раз?
[09:44.000 --> 09:48.000]  А можете что-нибудь сказать, пожалуйста?
[09:48.000 --> 09:51.000]  Просит объяснить поподробнее
[09:51.000 --> 09:59.000]  Сейчас, давайте тогда я вернусь к компьютеру, потому что, видимо, технические шоколадки
[09:59.000 --> 10:01.000]  Да
[10:44.000 --> 10:50.000]  Да, спасибо
[10:50.000 --> 10:54.000]  Звезда к линии объяснить поподробнее или что?
[10:54.000 --> 10:56.000]  Да, можете, пожалуйста
[10:56.000 --> 10:58.000]  Все супер
[10:58.000 --> 11:00.000]  Так, пожалуйста
[11:01.000 --> 11:04.000]  Мы пофиксили такие
[11:04.000 --> 11:08.000]  В общем, у нас...
[11:08.000 --> 11:14.000]  В общем, с такими знаками Sumo в школе работали?
[11:14.000 --> 11:16.000]  Или еще нет?
[11:16.000 --> 11:18.000]  Было что-нибудь такое в школе?
[11:22.000 --> 11:24.000]  Да, было
[11:24.000 --> 11:25.000]  Супер
[11:25.000 --> 11:33.000]  В общем, у нас с такими знаками Sumo в школе работали?
[11:33.000 --> 11:35.000]  Или еще нет?
[11:35.000 --> 11:40.000]  К равно в нуля, по n, какой-нибудь x-кат
[11:40.000 --> 11:42.000]  Было что-нибудь такое в школе?
[11:46.000 --> 11:50.000]  Вот у нас есть здесь, что это, по сути, означает
[11:50.000 --> 11:55.000]  Что мы берем k равный нулю, подставляем здесь какое-то выражение, завищееся от k
[11:55.000 --> 12:01.000]  И суммируем все такие вот выражения, где k равняется нулю, так далее, k равняется n
[12:01.000 --> 12:03.000]  Здесь же, что мы делаем?
[12:03.000 --> 12:09.000]  Здесь у нас вместо Sumo выступает операция объединения на множествах
[12:09.000 --> 12:14.000]  Но только теперь у нас есть множество, завищещее от yod переменной
[12:14.000 --> 12:20.000]  Мы берем по всем yod, которые от нуля до бесконечности, то есть все натуральные числа
[12:22.000 --> 12:33.000]  Если расписать, то эта штучка будет равняться l в нулевой, plus l в первой, plus l во второй, plus и так далее
[12:33.000 --> 12:36.000]  Все возможные натуральные числа пробежали
[12:36.000 --> 12:45.000]  Да, очень важное напоминание, что натуральные числа, они с нуля и до бесконечности
[12:45.000 --> 12:51.000]  Не соединятся, почему-то так, узнаем во втором семестре
[12:51.000 --> 12:58.000]  Извините, а получается, что plus это как объединение работает в данном случае?
[12:59.000 --> 13:03.000]  Плюс? Да, спасибо, хорошее замечание
[13:05.000 --> 13:07.000]  Да, это объединение
[13:14.000 --> 13:18.000]  Хорошо, это называется зисторик линии
[13:18.000 --> 13:23.000]  У нас есть, по аналогии зисторика линии есть, плюс к линии
[13:23.000 --> 13:30.000]  Только теперь мы начинаем конконтонировать не от нулевой степени языка, а от первой
[13:30.000 --> 13:37.000]  Здесь уже будет l1, так далее, l2, так далее
[13:37.000 --> 13:50.000]  То есть, можно сказать, что l звезда, это есть l plus, plus l степени нулевой
[13:50.000 --> 13:54.000]  А теперь давайте посмотрим, что такое l степени нулевой
[13:54.000 --> 13:56.000]  У нас...
[14:00.000 --> 14:04.000]  Блин, вы ординалов еще не знаете, трудно
[14:10.000 --> 14:12.000]  Ну давайте думать вообще
[14:12.000 --> 14:23.000]  У нас на числах есть свойство, что число k в степени 0, это равняется единице
[14:25.000 --> 14:34.000]  Математика хороша тем, что то, что работает в одном, это, вероятно, какой-то частный случай абстракции, который работает везде
[14:34.000 --> 14:42.000]  Вот здесь у нас нулевая степень, и поэтому наша задача понять, что такое 0 во множествах, и что такое единица
[14:42.000 --> 14:45.000]  В данном случае у нас множество это языки
[14:45.000 --> 14:48.000]  Вот есть предположение, что будет нулем
[14:48.000 --> 14:51.000]  Пустое множество
[14:51.000 --> 14:57.000]  Да, вот 0 у нас во множествах, это пустое множество
[14:57.000 --> 14:59.000]  Что же такое единица?
[14:59.000 --> 15:04.000]  Понятно же, что пустое множество быть само собой единицей не может
[15:04.000 --> 15:09.000]  Это должно быть что-то, что содержит хотя бы какой-то элемент
[15:09.000 --> 15:15.000]  Какой же элемент мы можем дать настолько глупый, что это будет просто единица?
[15:15.000 --> 15:17.000]  А единица, да?
[15:17.000 --> 15:19.000]  Пустая строка, эпсилон
[15:19.000 --> 15:21.000]  Да
[15:21.000 --> 15:24.000]  Вот, и мы получили единицу
[15:24.000 --> 15:35.000]  И действительно, если мы посмотрим, то здесь будет выполнено свойство, что
[15:35.000 --> 15:42.000]  r в степени m умножить на r в степени n равняется r в степени n плюс n
[15:42.000 --> 15:44.000]  Существо для языков
[15:44.000 --> 15:50.000]  Нулевая степень не должна поменять ничего
[15:50.000 --> 15:56.000]  А единственный способ, конкатенируя строки между собой, не изменить
[15:56.000 --> 16:01.000]  Это конкатенироваться с пустой строкой, то есть с эпсилоном
[16:01.000 --> 16:10.000]  Тогда вот эта вот штучка запишется в r плюс объединить с языком единицей
[16:10.000 --> 16:15.000]  Второй же вариант, это мы определили звезду к линии через плюс к линии
[16:15.000 --> 16:21.000]  Второй вариант определить плюс к линии через звезду к линии
[16:21.000 --> 16:30.000]  Есть идея, как это сделать?
[16:30.000 --> 16:32.000]  Ну, для этого давайте посмотрим
[16:32.000 --> 16:34.000]  Домножить на l
[16:34.000 --> 16:36.000]  То есть здесь у нас что?
[16:36.000 --> 16:41.000]  Если мы домножим на l, то мы увеличим степень на единицу во всем вот этом вот
[16:41.000 --> 16:42.000]  разном объединении
[16:42.000 --> 16:46.000]  Тогда у нас начнется не с нуля объединяться, а с единицы
[16:46.000 --> 16:48.000]  Это равно то, что нам нужно
[16:48.000 --> 16:56.000]  Это l конкатенация на l звезда, то же самое, что l звезда на l
[16:56.000 --> 17:01.000]  Пока кажется, что, ну, это очень глупо записывается с двух сторон
[17:01.000 --> 17:06.000]  Но чуть позже на линейной алгебре вам покажут, что
[17:06.000 --> 17:13.000]  в зависимости от того, с какой стороны мы домножаем или складываем
[17:13.000 --> 17:17.000]  в определенных случаях у нас абсолютно все ломается
[17:17.000 --> 17:21.000]  Хорошо
[17:21.000 --> 17:27.000]  У нас звезда к линии плюс к линии есть
[17:27.000 --> 17:37.000]  А теперь мы приходим к второму определению того, что такое язык
[17:37.000 --> 17:44.000]  И именно это будут использовать потом на курсе формальных языков
[17:44.000 --> 17:47.000]  Я немножко формально запишу
[17:47.000 --> 17:53.000]  Это некоторое множество l, которое является под множеством
[17:53.000 --> 17:59.000]  Возможно совпадающим
[17:59.000 --> 18:06.000]  Над итерацией к линии алфавитом
[18:06.000 --> 18:12.000]  Даже часто уточнять язык над алфавитом
[18:12.000 --> 18:19.000]  Алфавитом сигма
[18:19.000 --> 18:23.000]  Ну, в целом, это у нас второе определение
[18:23.000 --> 18:29.000]  В целом, понять эквивалентность этих
[18:29.000 --> 18:32.000]  Ну, довольно непонятно
[18:32.000 --> 18:37.000]  Просто что такое звезда к линии над алфавитом
[18:37.000 --> 18:45.000]  Это мы берем всеми возможными способами контенируем между собой символы из алфавита
[18:45.000 --> 18:53.000]  Так мы получим всевозможные слова из символов выбранного алфавита
[18:53.000 --> 18:56.000]  Хорошо
[18:56.000 --> 19:03.000]  Это объяснил, это объяснил, это объяснил, это объяснил
[19:03.000 --> 19:08.000]  Давайте я гляну на, что у нас будет
[19:08.000 --> 19:12.000]  Контрольная, все ли я казала, еще нужно что-то
[19:12.000 --> 19:16.000]  Так, это осень первая
[19:20.000 --> 19:26.000]  И теперь мы после того, как ввели какой-то алфавит
[19:26.000 --> 19:30.000]  Мы начинаем рассматривать правильные исключенные последовательности
[19:30.000 --> 19:35.000]  По сути, это уже язык
[19:35.000 --> 19:39.000]  Но язык, на котором заданы определенные правила
[19:39.000 --> 19:43.000]  Потому что говорить в общих чертах и языках довольно бессмысленно
[19:43.000 --> 19:48.000]  Потому что это какая-то довольно-таки глупая структура
[19:48.000 --> 19:51.000]  Ну, просто мы набрали множество каких-то элементов
[19:51.000 --> 19:58.000]  Потому что глобально у нас язык может совпадать с алфавитом, алфавит — это произвольное множество
[19:58.000 --> 20:03.000]  То есть все, что угодно, мы можем назвать языком
[20:03.000 --> 20:12.000]  И чтобы хоть как-то было это применимо, мы должны задать ограничения
[20:12.000 --> 20:18.000]  Задать какие-то правила, как можно стола строить, как со столами оперировать
[20:18.000 --> 20:26.000]  И для этого мы рассмотрим язык правильных исключенных последовательств
[20:34.000 --> 20:37.000]  Так, язык ПСП
[20:37.000 --> 20:45.000]  Давайте сначала разберемся, что такое алфавит в правильных исключенных последовательствах
[20:47.000 --> 20:52.000]  Есть предположения?
[20:55.000 --> 20:57.000]  Открытый язык, видеоскопка
[20:57.000 --> 20:58.000]  Все
[20:59.000 --> 21:01.000]  Открытый язык, видеоскопка
[21:01.000 --> 21:05.000]  Все, все очень просто, да, две круглые скопки
[21:10.000 --> 21:12.000]  Так, у нас есть две скопки
[21:12.000 --> 21:18.000]  Соответственно, мы можем сказать, что это некоторое под множество уже
[21:18.000 --> 21:21.000]  Вот это вот симма звезды
[21:21.000 --> 21:27.000]  Первый вопрос, на который очень легко ответить
[21:27.000 --> 21:31.000]  Совпадает ли это с самой интерацией к линии?
[21:31.000 --> 21:37.000]  Конечно же нет, потому что здесь, например, получится вот такая строка, которая не будет правильной
[21:37.000 --> 21:41.000]  Соответственно, как нам определять правильность?
[21:41.000 --> 21:45.000]  Для этого мы вводим правила, как их строить
[21:45.000 --> 21:47.000]  У нас их есть целых три
[21:47.000 --> 21:54.000]  Первое правило, как мы можем задать правильность к обычной последовательности
[21:54.000 --> 21:59.000]  Эпсилон, правильность к обычной последовательности
[21:59.000 --> 22:05.000]  Дальше, Фи, Пси, ПСП
[22:05.000 --> 22:11.000]  Тогда, Фи конкретонация, Пси, ПСП
[22:11.000 --> 22:15.000]  Фи конкретонация, Пси, ПСП
[22:15.000 --> 22:18.000]  Фи, ПСП
[22:18.000 --> 22:23.000]  Тогда, скобочки над Фи тоже ПСП
[22:31.000 --> 22:33.000]  Все
[22:33.000 --> 22:36.000]  Данное определение
[22:36.000 --> 22:42.000]  Хорошо, с точки зрения того, что мы точно задали
[22:42.000 --> 22:46.000]  Хорошие скобочные последовательности, которые ничего не нарушат
[22:46.000 --> 22:50.000]  Но у них есть существенный недостаток
[22:56.000 --> 23:00.000]  Вот скобочная последовательность, вот такая вот
[23:00.000 --> 23:04.000]  Идейно нам нужен язык правильных скобочных последовательностей
[23:04.000 --> 23:09.000]  Чтобы позже всунуть в скобки какие-то операции математические
[23:09.000 --> 23:13.000]  Чтобы мы могли правильно выполнять их
[23:13.000 --> 23:18.000]  Вот представим, что внутри скобок лежат какие-то математические операции
[23:18.000 --> 23:21.000]  Здесь вот стоят их две
[23:21.000 --> 23:25.000]  Какую скобку нам выполнить первой?
[23:25.000 --> 23:33.000]  Данное определение, оно не дает никаких формализаций
[23:33.000 --> 23:37.000]  Никаких формализаций по данному вопросу
[23:37.000 --> 23:42.000]  Поэтому мы можем как сначала левую скобку выполнить, потом правую
[23:42.000 --> 23:45.000]  А можем выполнить сначала правую, а потом левую
[23:45.000 --> 23:57.000]  Но понятно же, что может случиться так, что нам нужно выполнять именно каким-то одним определенным образом
[23:57.000 --> 24:04.000]  Ну, например, здесь у нас будет, давайте что-нибудь параллельное, здесь будет что-то вида
[24:04.000 --> 24:10.000]  Ретерн 2, а здесь будет
[24:10.000 --> 24:16.000]  Ретерн 2 делить на нот
[24:16.000 --> 24:20.000]  Ну вот, если мы сначала упадем правую, мы упадем с ошибкой
[24:20.000 --> 24:23.000]  Выполним левую, все успешно выполнится
[24:23.000 --> 24:27.000]  И чтобы задать хоть как-то этот порядок
[24:27.000 --> 24:33.000]  Лучше использовать два других определения
[24:34.000 --> 24:39.000]  Есть, безусловно, база, это Эпсилон
[24:39.000 --> 24:42.000]  Является правильной скобочной последовательностью
[24:42.000 --> 24:46.000]  Дальше, ФИ
[24:46.000 --> 24:49.000]  ФИ и ПСИ, ПСП
[24:49.000 --> 24:55.000]  Тогда конконтонация ФИ
[24:55.000 --> 24:59.000]  Скобках на ПСИ-ПСП
[24:59.000 --> 25:01.000]  Это второе
[25:01.000 --> 25:05.000]  Третье это Епсилон ПСП
[25:05.000 --> 25:09.000]  ФИ и ПСИ ПСП
[25:09.000 --> 25:12.000]  Тогда ФИ
[25:12.000 --> 25:16.000]  В скобках ПСИ тоже ПСП
[25:16.000 --> 25:30.000]  Тогда два данных определения дадут нам гарантируемость того, что порядок будет исполняться именно четким фиксированным образом
[25:30.000 --> 25:36.000]  Второе даст нам то, что называется математики, левоассоциативностью
[25:36.000 --> 25:41.000]  То есть мы сначала будем слева выполнять операция, потом справа
[25:41.000 --> 25:46.000]  Ну это практически все стандартные математические операции, когда мы пишем
[25:46.000 --> 25:49.000]  А, плюс Б, плюс С
[25:49.000 --> 25:57.000]  Когда все такое написано в компьютере, мы начинаем сначала выполнять первое, потом второе, к результату третье и так далее и тому подобное
[25:57.000 --> 26:01.000]  А есть правоассоциативные, это тройка
[26:01.000 --> 26:03.000]  То, что сначала исполнится справа
[26:03.000 --> 26:11.000]  Вот, например, во втором случае мы успешно завершимся, в третьем случае мы упадем с ошибкой
[26:11.000 --> 26:16.000]  Примером правоассоциативной операции будет что?
[26:16.000 --> 26:20.000]  А равняется, Б равняется С
[26:20.000 --> 26:24.000]  То есть у нас есть какая-то переменная С, ее результат сначала присвоится Б
[26:24.000 --> 26:32.000]  Потом данная операция вернет то, что было присвоено Б, и это присвоится А
[26:46.000 --> 26:50.000]  Также, наверное, в школе была такая штука как математическая индукция
[26:50.000 --> 26:54.000]  Общий принцип математической индукции заключается в чем?
[26:54.000 --> 27:02.000]  Что у нас есть некоторая база, есть и есть правила перехода от n-1 к
[27:02.000 --> 27:10.000]  Математическая индукция хороша, но не всегда у нас правила перехода одно
[27:10.000 --> 27:16.000]  То есть мат-индукция
[27:20.000 --> 27:22.000]  У нас была база
[27:24.000 --> 27:28.000]  Что-то там, какое-то свойство для нуля
[27:31.000 --> 27:33.000]  И переход
[27:37.000 --> 27:43.000]  От n к n плюс один, ну или n-1 к n, оно не имеет смысла
[27:44.000 --> 27:54.000]  Здесь же в словах можно заметить, что у нас базы везде это епсилон
[27:54.000 --> 28:02.000]  А вот количество переходов во втором и третьем определении оно одно, а в первом два
[28:02.000 --> 28:05.000]  А иногда может быть еще больше количество переходов
[28:05.000 --> 28:11.000]  И в таких случаях использовать просто мат-индукцию нельзя
[28:12.000 --> 28:18.000]  Поэтому мы используем метод индукции, просто убирали слово математическое
[28:18.000 --> 28:26.000]  И заключательное в том, что теперь мы переход проверяем не для одного, а для каждого из вариантов перехода
[28:28.000 --> 28:30.000]  Выполнимость свойства
[28:30.000 --> 28:37.000]  Тогда если для каждого перехода свойство будет выполнено, то мы доказали что-то
[28:38.000 --> 28:41.000]  Ну, точнее, что свойство выполнено для всего множества
[28:42.000 --> 28:46.000]  Вот здесь будет переход, переход, переход, переход
[28:50.000 --> 28:54.000]  Подобные определения, заданные нами, называются еще индуктивными
[28:56.000 --> 29:04.000]  Можно еще сказать, что так или иначе это как-то связано с понятием грамматики, но это будет через год
[29:08.000 --> 29:10.000]  У нас есть PSP
[29:12.000 --> 29:19.000]  И в конце, после того как мы начали говорить, что появился язык, правильные скобочные последовательности, мы их как-то задали
[29:20.000 --> 29:26.000]  То теперь хочется их как-то проверять
[29:27.000 --> 29:31.000]  Но проверять, что построим то, что называется дерево разбора
[29:32.000 --> 29:34.000]  Говорим сейчас чуть позже про него
[29:34.000 --> 29:39.000]  Но помимо дерева разбора мы уже косвенно столкнулись с проблемой неотозначенности разбора
[29:40.000 --> 29:43.000]  Вот как я сказал, непонятно какой порядок выполнять
[29:44.000 --> 29:45.000]  А это порядок
[29:46.000 --> 29:58.000]  Но ведь может получиться так, что я задам правила перехода так, что
[29:59.000 --> 30:00.000]  Давайте пример
[30:01.000 --> 30:03.000]  Я возьму первое определение
[30:20.000 --> 30:22.000]  И я добавлю еще одно правило
[30:22.000 --> 30:24.000]  Давайте phi и psi
[30:28.000 --> 30:30.000]  И возьму строку какую-нибудь
[30:31.000 --> 30:33.000]  Ну пусть будет уже просто
[30:34.000 --> 30:35.000]  Вот такую
[30:38.000 --> 30:44.000]  Разбором, под разбором мы будем понимать последовательность переходов
[30:45.000 --> 30:47.000]  То есть правил, по которым мы построили
[30:47.000 --> 30:52.000]  Мы можем сказать, как из базовых приметилов мы получили конечный символ
[30:56.000 --> 31:01.000]  Данную строку у нас есть не один вариант того, как не прийти
[31:02.000 --> 31:06.000]  Первый это epsilon-epsilon
[31:07.000 --> 31:11.000]  А здесь второй вариант это epsilon-epsilon
[31:12.000 --> 31:13.000]  Вместе далее
[31:13.000 --> 31:14.000]  Далее
[31:15.000 --> 31:17.000]  Скопка epsilon-epsilon-epsilon
[31:18.000 --> 31:22.000]  И понять, по какому именно пути мы попали мы не можем
[31:23.000 --> 31:30.000]  Соответственно данный способ задания языка не гарантирует однозначности разбора
[31:31.000 --> 31:40.000]  И третий номер будет именно на то, что вам заданный язык, в котором правила его построения приводят к неоднозначности разбора
[31:44.000 --> 31:48.000]  Поговорим про дерево разбора
[31:59.000 --> 32:00.000]  Как устроено дерево разбора?
[32:01.000 --> 32:04.000]  Как любое дерево, у него есть какие-то листья
[32:05.000 --> 32:08.000]  Это элементы...
[32:08.000 --> 32:11.000]  Ладно, не получится вам так сказать
[32:12.000 --> 32:13.000]  Просто есть листья
[32:14.000 --> 32:20.000]  Это вершинки, от которых только идут ребра, к которым никакие ребра не пришли
[32:23.000 --> 32:28.000]  Соответственно листьями дерева разбора могут быть только базовые элементы
[32:29.000 --> 32:33.000]  В нашем случае это epsilon-epsilon, если мы говорим про PSP
[32:33.000 --> 32:40.000]  Дальше мы можем соединять все вершины по правилам перехода, которые заданы в индуктивного потеряния
[32:41.000 --> 32:46.000]  Мы можем взять и объединить две вершины по правилу конкатенации
[32:47.000 --> 32:48.000]  Получим epsilon
[32:49.000 --> 32:50.000]  Очень продуктивно, конечно
[32:50.000 --> 33:00.000]  Дальше с epsilon мы можем получить две скобки, их вместе собрав мы можем сделать скобки скобки скобки и так далее
[33:03.000 --> 33:06.000]  И вот это всё
[33:07.000 --> 33:08.000]  И вот это всё
[33:09.000 --> 33:10.000]  И вот это всё
[33:11.000 --> 33:12.000]  И вот это всё
[33:13.000 --> 33:14.000]  И вот это всё
[33:15.000 --> 33:16.000]  И вот это всё
[33:17.000 --> 33:24.000]  И вершины дерева получится исходная строка
[33:26.000 --> 33:30.000]  Простите, вы что-то пишите сейчас, а этого не видно на экране
[33:32.000 --> 33:33.000]  Или вы сейчас ничего не пишите?
[33:33.000 --> 33:34.000]  Я сейчас ничего не пишу
[33:34.000 --> 33:36.000]  А, простите, я не пишу
[33:39.000 --> 33:40.000]  Да, ничего страшного
[33:40.000 --> 33:48.760]  вот теперь давайте еще раз вот проверим кого-нибудь вопросы по теоретической части были
[33:48.760 --> 33:56.560]  остались что-то непонятное разберем мы и переходим сразу к решению номеров
[33:56.560 --> 34:06.560]  а пустая строка epsilon у нас содержится в алфавите пустая строка epsilon содержится ли в алфавите
[34:06.560 --> 34:24.680]  смотри по определению что такое пустая строка это отображение из пустого множества в множество
[34:24.680 --> 34:32.440]  символов алфавита и само по себе
[34:32.440 --> 34:44.080]  сейчас скажу само по себе оно не может быть в алфавите если мы просто рассматриваем алфавит
[34:44.080 --> 34:53.480]  но можно сделать как что у нас есть алфавит над этим алфавитом есть пустая строка и чисто
[34:53.480 --> 34:59.960]  формально мы можем сказать что ну алфавит же это что произвольное множество мы можем
[34:59.960 --> 35:10.880]  составить множество из вот таких вот пустых слов которые на самом деле они все будут различны
[35:10.880 --> 35:22.200]  потому что это как бы пустой множество отображается другое но при этом в чем проблема возникнет что
[35:22.200 --> 35:35.400]  на самом деле отображая пустое множество во что-то произвольное по смыслу у тебя ничего не
[35:35.400 --> 35:44.440]  изменится если мы изменим множество в которое идет отображение ну у нас не будет никаких пар то есть
[35:44.440 --> 35:51.160]  в пустом множестве нет никаких элементов соответственно мы ничему не сопоставим ничего ну какая
[35:51.160 --> 35:57.720]  разница вот это вот ничего сопоставлять множество из русского алфавита из латинского из греческого
[35:57.720 --> 36:09.360]  арабского ничего не изменится и поэтому пустую строку мы в алфавит никогда не заносим и считаем
[36:09.360 --> 36:18.880]  что во всех языках вот это вот пустая строка она плюс минус одинаково спасибо большое
[36:18.880 --> 36:28.960]  алфавит или язык может быть бесконечным да конечно мы смотри мы вводили понятие алфавита
[36:28.960 --> 36:33.520]  как произвольное множество у нас это множество может быть не просто бесконечное оно может
[36:33.520 --> 36:37.920]  сколько угодно и мощности оно может быть еще одном может быть континуальным может более чем
[36:37.920 --> 36:46.960]  континуально какое угодно аналогично и если алфавит бесконечен то ну над ним
[36:46.960 --> 37:02.840]  над ним язык будет может быть тоже бесконечным но при этом слова всегда конечны давайте считать
[37:02.840 --> 37:11.240]  так ну потому что если действительно проводить прикол математики что мы идем по уровню абстракции
[37:11.240 --> 37:18.680]  как можно вверх вот если мы на более практичном уровне мы говорим что слова конечны потому что
[37:18.680 --> 37:27.240]  на практике ну нигде вы с бесконечными словами по сути работать не будете но можно спокойно
[37:27.240 --> 37:37.320]  думать про слова как бесконечные это то что называется вот в программировании есть например
[37:37.320 --> 37:43.760]  такой термин есть понятие константы есть эффективно константные переменные то есть
[37:43.760 --> 37:50.800]  которые не помечено как константы но в коде они по сути выполняют роль констант точно также
[37:50.800 --> 38:00.760]  можно смотреть на что на слова они могут быть бесконечные но только мы сопоставили что-то
[38:00.760 --> 38:11.680]  только конечному префиксу последовательность из натуральных чисел дальше мы просто ничего не
[38:11.680 --> 38:17.320]  сопоставили это будет использоваться до определения что это не отображение а частично определенная
[38:17.320 --> 38:25.320]  функция но в целом можно построить язык из конечных слов но такое ну математические сыске
[38:25.320 --> 38:38.600]  которые на практике не особо имеют смысл с неоднозначно разбираемыми с кубичного последовательства
[38:38.600 --> 38:47.480]  можно сделать и так и конца полюсали что в третьем задании будет там что сделать с ними если у
[38:47.480 --> 38:55.080]  вас задан язык таким образом что у вас не дается однозначности разбора то значит нужно
[38:55.080 --> 39:01.200]  задавать язык другим образом это единственный способ это исправить а задачи у вас просто такой
[39:01.200 --> 39:07.320]  ну плохой так плохо задан язык что вам нужно найти два варианта разбора я сейчас посмотрю
[39:07.320 --> 39:14.320]  покажу как это делать все то есть там вас не будут просить а теперь сделайте как-нибудь чтобы
[39:14.320 --> 39:24.400]  язык однозначно разбирался меня потемнело сейчас
[39:24.400 --> 39:40.000]  но кстати на вопрос про того что слова конечны или бесконечны мы будем использовать
[39:40.000 --> 39:57.040]  определение формальных языках вот такое sigma звезда и sigma звезда она даст нам именно
[39:57.040 --> 40:03.640]  конечно всех этих строк и поэтому не появится просто могут быть ли слова бесконечно все здесь
[40:03.640 --> 40:13.360]  sigma звезда наконкатинирует нам лишь конечное число раз еще можно вот вопрос нашего значка когда
[40:13.360 --> 40:19.240]  мы обозначаем что одно множество является подножием другого а мы не можем когда он первое множество
[40:19.240 --> 40:25.440]  совпадают использовать обычный значок без дополнительной черточки снизу ну когда множество
[40:25.440 --> 40:35.640]  совпадают тогда мы хотим смотри по поводу этих значков в общем у нас есть значок у нас
[40:35.640 --> 40:42.760]  и значок равенства или равняется м что значит или равняется им по определению это значит что
[40:42.760 --> 40:54.960]  м под множество м и м под множество это что такое под множество что все элементы и есть м
[40:54.960 --> 41:06.960]  как писать значок под множество есть есть различные варианты то как кто как кто предпочитает там в
[41:06.960 --> 41:16.720]  школе скорее всего был значок просто такой это под множество дальше есть вариант писать вот такое
[41:16.720 --> 41:23.280]  под множество я как правило пишу такой значок потому что я его использую именно для того чтобы
[41:23.280 --> 41:28.720]  почеркнуть что эти множество могут совпадать то есть вот это вот равенство специально здесь
[41:28.720 --> 41:34.760]  написано чтобы почеркнуть что возможно что вариант совпадения этих множеств тоже допускается а
[41:35.400 --> 41:42.480]  когда вот специально мы хотим сказать что никогда не будет равенства вот есть перечеркнутая как я
[41:42.480 --> 41:51.600]  помню на лекции должны были быть вот эти вот два значка но лично я буду использовать вот эти два
[41:51.600 --> 41:59.000]  это уже знаете момент в кусовщины кто-то любит действительно почеркивать что равенство допускается и
[41:59.480 --> 42:00.600]  равенство не отпускается
[42:00.600 --> 42:11.560]  хорошо еще вопросы по теории
[42:11.560 --> 42:21.640]  тогда давайте начнем решать вот
[42:21.640 --> 42:34.680]  слова ассоциативность коммутативность уже режут слух еще режут слух и уже привыкли к ним
[42:34.680 --> 42:48.360]  привыкли вроде можно задать вопрос про звезду к линии плюс к линии да получается они задают
[42:48.360 --> 42:58.760]  ну вы бесконечный язык но язык бесконечный количество слов получается да понял понял ну да
[42:58.760 --> 43:07.160]  так смотри как минимум это следует из того что если ну вообще вообще на то что ты сказал есть
[43:07.160 --> 43:16.160]  контр пример вот всегда нужно помнить что существует язык ноль язык единицы вот что
[43:16.160 --> 43:32.200]  такое звезда к линии от нуля тоже самое нет а это пустой язык с пустым словом типа да это
[43:32.200 --> 43:44.960]  единица но при этом ноль плюс это ноль но из определения понятно почему да поэтому
[43:44.960 --> 43:51.520]  иногда будут конечно единица но единица понятно что единица звезда равняется единица плюс
[43:51.520 --> 44:05.960]  равняется вот про эти два языка очень важно помнить я сейчас скажу потому что это лучший
[44:05.960 --> 44:12.360]  источник контр примеров когда что-то казалось бы что должно в нормальном понимании выполняться
[44:12.360 --> 44:22.320]  будет наоборот не выполняться вот вы сравняли число и множество в этот момент можно прояснить не
[44:22.320 --> 44:33.080]  совсем понял номера но пустого множество вполне понятно это не это не сравнял да тут это да
[44:33.080 --> 44:39.520]  значок но должен быть немножко другой это я сказал что вот я буду вы значать нулём из язык пустой
[44:39.520 --> 44:48.440]  множества единицы язык из пустого слова да правда ли что я двойка будет ну бесконечную множество
[44:48.440 --> 44:56.640]  разных множеств такого рода вещь и ну или для единицы найдется куча множеств которые состоят из
[44:56.640 --> 45:07.360]  одного элемента бесконечных я не совсем понимаю с роль этой самой единички нуля и других натуральных
[45:07.360 --> 45:15.000]  чисел когда мы задаем это не это не натуральные числа это просто обозначение я вот сказал что я
[45:15.000 --> 45:20.680]  нулём назову такое множество единицы за такое множество все все понял извините это просто
[45:20.680 --> 45:27.680]  ну представь что переменная название переменной понял понял благодарю почему это 0 единица мы
[45:27.680 --> 45:33.200]  поговорим вот следующем семестре там станет понятно почему это именно 0 почему это единица
[45:33.200 --> 45:40.040]  что такое двойка тройка и вообще все натуральные числа хотя у вас же лектор лукашова он должен
[45:40.040 --> 45:47.920]  был вам вот это вот затереть по-моему на первой лекции он любит тратить модель 3 раз вроде
[45:47.920 --> 45:56.760]  рассказывал такое ну вообще я не знаю надо ли это фе кого-то там это называется теоретика
[45:56.760 --> 46:02.600]  множественная подходка преди этот ординальный подход к определению натуральных чисел их там
[46:02.600 --> 46:13.800]  несколько я с индукцией пиано и вот такой и кстати на лекциях по кутыче возможно тоже там показывали
[46:13.800 --> 46:20.240]  там было множество из пустого множество еще множество из множества из пустого множество
[46:20.240 --> 46:27.880]  и стоим множество так далее вот вот это вот это все натуральные числа да показывать был да
[46:27.880 --> 46:35.280]  поэтому вот именно поэтому я называю мы стоим множество 0 множество из пустой последовательности
[46:35.280 --> 46:54.480]  пустого слова это единица тогда не хорошо я хрен в общем первая задача она про что про то
[46:54.480 --> 47:00.640]  что конкуренция языков не является коммутативной операцией то есть если мы поменяем местами у нас
[47:00.640 --> 47:07.920]  все сломается примеру других некоммунативных ну наверное в школе если кому-то поездово вы
[47:07.920 --> 47:14.360]  матрицы перемножали и если вспомнить что матрицы вот цель того как вы их перемножите в общем
[47:14.360 --> 47:20.960]  случае вы можете получить различные ответы начисто все слишком хорошо там можно их нет
[47:20.960 --> 47:31.680]  в общем по первому номеру первое что нужно делать вспомнить язык 0 то есть пустое множество и
[47:31.680 --> 47:37.600]  просто проверить из тех где можно потому что как правило на пустом но сейчас потому что для
[47:37.600 --> 47:50.440]  пустого множества коммутативность выполнена для пустого множества очень хорошо пустой
[47:51.120 --> 47:55.560]  множество что она является под множеством любого множества соответственно везде
[47:55.560 --> 48:06.100]  где только вы видите значок под множество будет уже вариант что да возможно здесь плюс здесь
[48:06.100 --> 48:17.200]  плюс здесь плюс здесь плюс просто потому что значок под множеством а дальше все свойствует
[48:17.200 --> 48:24.440]  потому что мы пытаемся найти, а когда же нет. Если мы долго думали и не придумали, ну значит нет.
[48:24.440 --> 48:32.720]  Либо пользуемся какими-то свойствами. Давайте смотреть на L звезду. M равняется L звезда.
[48:32.720 --> 48:44.120]  Тогда вместо M прямо сразу запишем L звезду. Действительно ли это так? Ну да.
[48:44.120 --> 48:57.960]  И то и то является языком L+. Поэтому здесь точно да. Вот давайте если M это
[48:57.960 --> 49:17.840]  некоторое под множество L. Будут ли случаи, когда нет? Будут. Супер, напримерчик. Ну,
[49:17.840 --> 49:26.760]  например у нас L это множество из A и B, а M это из B. Тогда M на L всегда будет
[49:26.760 --> 49:40.240]  начинаться на B, а L может начинаться на A. Супер, прекрасно и оба. И мне понравилось то,
[49:40.240 --> 49:48.560]  что ты отметила. Если у нас язык состоит из одного символа, то если мы его сконкатенируем с чем-то,
[49:48.560 --> 49:55.840]  где он первый в конкатенации, то все слова будут начинаться именно с этого символа. Вот эти вот
[49:55.840 --> 50:01.920]  можно пользоваться для того, чтобы концентрировать контрпримеры. Этот прием поможет, он упростит.
[50:01.920 --> 50:14.400]  L под множество M звезда. Ну, абсолютно тот же пример. Если здесь мы сделаем что? Если L под множество
[50:14.400 --> 50:30.560]  M, то очевидно L под множество M звезда. Тогда разницы. Тогда если мы доказали, что B есть
[50:30.560 --> 50:40.480]  контрпример, то этот контрпример подойдет для случивая. Какие варианты по букве M?
[50:40.480 --> 50:58.000]  Ну, то же самое. А тут как раз, что у нас есть некоторые слова, double V. То есть L это все
[50:58.000 --> 51:18.400]  возможные степени этого слова. L это язык. А M, значит, это будет какие-то степени этого
[51:18.400 --> 51:29.440]  слова из какого-то под множество M. И поэтому пример, где что мы использовали, что здесь только один
[51:29.440 --> 51:36.880]  символ и с него все будет начинаться. А в другом языке появляется абсолютно новый символ, который
[51:36.880 --> 51:48.160]  появляется другой символ, которого нет в первом. А проблема языков M и L тут в том, что у них везде
[51:48.720 --> 51:59.120]  это просто степени одного и того же слова. У нас не появится ничего нового. И простое свойство
[51:59.120 --> 52:13.120]  W в степени K на W равняется W на W в степени K равняется W в степени K. Ну, если мы одно и
[52:13.120 --> 52:21.200]  то же слово припишем, ну какая разница? Мы в конец его припишем или в начало. Поэтому для данного
[52:21.200 --> 52:29.760]  примера, что мы L сначала приконкатинируем к L, что мы L приконкатинируем к L, разница не имеет.
[52:29.760 --> 52:36.320]  Мы просто либо в начало допишем какой-то дополнительный отрезочек из N-ного количества
[52:36.320 --> 52:52.160]  слов W, либо в начало. Мы слова не поменяем. Можно вопрос? Вот звездочка это же звезда к линии,
[52:52.160 --> 53:01.480]  да? То есть у нас алфавит состоит из пустой строки и различного рода слов остальных. Ну,
[53:01.560 --> 53:11.560]  то есть смысл в том, что есть пустая строка. Если у нас M состоит, допустим, из слова, в котором,
[53:11.560 --> 53:22.360]  ну, которое просто представляет собой одну букву, вот это вот W, то получается, что когда мы
[53:22.360 --> 53:32.480]  конкатинируем, у нас же пропадет этот самый пустое слово. Да, но оно пропадет в обоих случаях.
[53:32.480 --> 53:43.960]  Здесь мы сконкатинируем вот, дай посмотрим тебя, вот Epsilon, W и так далее. Вот мы в первом случае
[53:43.960 --> 53:52.880]  мы сконкатинируем так, то есть у нас будет что? У нас появится здесь слово W, здесь W, W и так
[53:52.880 --> 53:59.280]  далее. А второй раз мы будем конкатинировать в конец. Ну, теперь мы припишем к пустой строке
[53:59.280 --> 54:11.320]  в конец W, мы все равно получим W. А, все, я понял. То есть здесь идея на в чем, что у нас строки,
[54:11.320 --> 54:21.760]  они просто какие-то вот повторяющиеся кусочки и без разницы, куда их можно приписывать. С
[54:21.760 --> 54:31.920]  пунктом G всем понятно? Можно еще вот вопрос, а как объяснить, что вот когда мы L конкатинируем
[54:31.920 --> 54:40.480]  с пустым множеством, мы получаем пустую множество. Как объяснить? Ну, смотри, давай.
[54:40.480 --> 54:53.000]  По определению, это что такое? Это множество всех слов L, на все слова O, где L принадлежит
[54:53.000 --> 55:05.920]  языку L и O принадлежит пустому языку. Поехали. Сколько таких слов, которые принадлежат пустому
[55:05.920 --> 55:19.600]  языку? Их ноль. Супер. Какое множество у нас имеет мощность ноль? Это только пустое множество,
[55:19.600 --> 55:25.440]  оно потому и называется пустым, что в нем никаких элементов, поэтому здесь, поэтому это пустой множество.
[55:25.440 --> 55:42.640]  Понятно? Да. Супер. Тогда последний пункт D. Вот, M уже является под множеством плюс к линии
[55:42.640 --> 55:54.160]  слово W, а L это sigma звезда, где sigma входит хотя бы с двух букв. Совет, когда пишут хотя бы с двух
[55:54.160 --> 55:59.160]  букв, как правило, если есть контрпример, его можно найти на двух буквах, не надо плюсовать.
[55:59.160 --> 56:13.760]  Поэтому можно сделать хотя бы это. Также, когда вот написано из некоторого слова, из некоторых букв,
[56:13.760 --> 56:21.720]  если контрпример есть, ну без разницы, вы найдете каких-то других и потом переименуете его A, B,
[56:21.720 --> 56:31.080]  G, D, либо вы сразу будете искать LBW, поэтому здесь мы можем сразу говорить, что это алфавит из A и B и
[56:31.080 --> 56:39.000]  не пытаться там что-то придумать, потому что, так или иначе, придумав что-то более сложное, можно
[56:39.000 --> 56:54.320]  будет переименовать эти символы на ABW и все сработает. Так что здесь хотя бы из двух символов,
[56:54.320 --> 57:08.600]  ну тут уже спойлер был, так что может это контрпример? Мы можем взять слово AB? Да, все супер.
[57:08.600 --> 57:23.000]  Тогда у нас все слова, где у нас сначала перемножается M на L, будут начинаться с AB,
[57:23.000 --> 57:34.400]  а где L на M, они могут начинаться не с AB. Можно вопрос? То есть мы считаем,
[57:34.400 --> 57:44.160]  что пустое множество это под множество любого языка? Мы не считаем это теоретиком множественный
[57:44.160 --> 57:49.920]  факт, что пустое множество является под множеством любого множества. Почему так,
[57:49.920 --> 58:00.480]  что для любого M его является? У нас по определению, что значит, что множество M под множество
[58:01.000 --> 58:11.440]  L. По определению это значит, для любого M из множества M выполнено, что M принадлежит
[58:11.440 --> 58:23.160]  для любого элемента множества пустого множества. Тут важный факт про пустое множество. Для любого
[58:23.160 --> 58:37.480]  элемента пустого множества выполнено все что угодно, поэтому данные выполнены.
[58:37.480 --> 58:42.640]  Понятно, спасибо.
[58:42.640 --> 59:01.720]  Слово A тоже бы подошло? Да, тут даже любое слово подойдет.
[59:12.640 --> 59:25.360]  А можно еще раз, какой ответ в A? Точно да, потому что вот смотри,
[59:25.360 --> 59:31.440]  мы смотрели тогда, звезда к линии, что слева, что вправо, это будет…
[59:31.440 --> 59:43.280]  То есть первое, что в этом номере сделать, мы берем пустое множество и просто проверяем,
[59:43.280 --> 59:50.720]  и просто везде, где вот написано под множеством, везде сразу проставляем то, что возможно. А дальше,
[59:50.720 --> 59:55.520]  ну у вас уже, даже если ничего не получается, у вас вероятность того, что вы ответите повысилась
[59:55.520 --> 01:00:04.480]  с 33% до 50%. На угад, по натыков. Можно тыкать везде один вариант, тогда точно где-то попадете.
[01:00:04.480 --> 01:00:16.000]  Кстати, про систему оценивания вот таких вот задач вы знаете или вам рассказывали, не рассказывали?
[01:00:16.000 --> 01:00:22.880]  По-моему, не рассказывали. В общем, там файлики вроде есть.
[01:00:23.040 --> 01:00:31.360]  Ну, я сейчас кратко еще раз напомню, что если вы отмечаете на все пять пунктов верно,
[01:00:31.360 --> 01:00:40.240]  вы получаете полный балл за задачу. За тестовые задачи вы получаете 0,8 баллов. Если вы не ответили
[01:00:40.240 --> 01:00:46.640]  правильно на все, но ответили правильно на четыре пункта из пяти, вы получите половину баллов,
[01:00:46.640 --> 01:00:54.080]  то есть 0,4. Если не ответили ничего, то вы получаете 0 и у вас просто сгорела задача,
[01:00:54.080 --> 01:01:02.960]  больше вы эти баллы не вернете. По тестам так. Соответственно, если вы проболели, вам потом эти
[01:01:02.960 --> 01:01:13.040]  тестовые задания улетят в последнюю контрольную надписывание. Это по тестам задача. Будут задачи
[01:01:13.040 --> 01:01:19.680]  развернуты. За них можно получить максимум один балл. Причем он либо вам ставится, либо не ставится.
[01:01:19.680 --> 01:01:26.520]  Первый раз, получая задачу, вы получаете один балл. После этого задача считается закрыта и больше
[01:01:26.520 --> 01:01:35.280]  никогда вы с ней не встретитесь. Если вы в первый раз на нее не решили ее верно, то задача вам
[01:01:35.280 --> 01:01:43.960]  прилетит с другим, ну того же плана, но просто с другими условиями, прилетит на следующий контрольный
[01:01:43.960 --> 01:01:48.760]  вдобавок ко всему тому, что должно быть на этой контрольной. То есть у вас количество задач
[01:01:48.760 --> 01:01:56.280]  увеличится, времени нет. И количество баллов, которое вы можете получить во второй раз,
[01:01:56.280 --> 01:02:03.480]  решив эту задачу, ужасно ценится на 0,8. Если вы во второй раз не решили, эта задача с другим
[01:02:03.480 --> 01:02:10.320]  условием прилетит вам в домашнюю. И интересное наблюдение, что если у вас в первый раз
[01:02:10.320 --> 01:02:16.920]  получилась задача сложная, во второй раз вам дадут задачу более простого плана, она будет чуть
[01:02:16.920 --> 01:02:22.360]  более проще. А в домашнюю вам прилетит задача сложнее, чем та, которая была в первый раз. Поэтому
[01:02:22.360 --> 01:02:27.440]  как бы сложность сначала чуть упадет, а потом разы возрастет. На домашнюю прилетают задачи сложнее,
[01:02:27.440 --> 01:02:37.440]  чем в первый раз и встречаясь. Так что из советов, если у вас прилетели там задачки на следующую
[01:02:37.440 --> 01:02:44.840]  контрольную, вы сначала решите вот старые, вы получите 0,8 и они будут чуть более простые,
[01:02:44.840 --> 01:02:53.320]  нежели потом получите домашнюю. А потом уже решайте новое. Ну и плюс к тому, что если вы
[01:02:53.320 --> 01:02:59.280]  в домашнюю решите, вы получите не 0,8, а 0,5. То есть вы потеряете не 0,2 балла, а уже 0,5.
[01:02:59.280 --> 01:03:09.960]  Как-то так. Ну и получается особенность. Чем больше задачек вы решили, тем раньше вам прилетит
[01:03:09.960 --> 01:03:19.360]  задачки D. Это дополнительные задачи, они оцениваются в полтора баллов и с их помощью можно
[01:03:19.360 --> 01:03:30.040]  налутать баллов на десятку без дорежки. Это возможно. Да, это возможно, у меня такое было,
[01:03:30.040 --> 01:03:43.720]  но я делал дорежку чисто ради удовольствия. Я бы мог сказать про приблизительные пороги,
[01:03:43.720 --> 01:03:50.200]  какие были раньше, но я в прошлом году уже так сказал, в итоге там и контрольные форматы
[01:03:50.200 --> 01:03:56.600]  поменяли, и порога упала, все попереставали, поэтому в этот раз ничего такого не скажу.
[01:03:56.600 --> 01:04:16.520]  Там сама судьба все определит. Вот. Я, возможно, плохо слышу. Задача отлетает, если ты частично
[01:04:16.520 --> 01:04:24.120]  решил, и сгорает, если ты вообще не решил. Смотри, тестовая задача у тебя никогда не
[01:04:24.120 --> 01:04:28.920]  идёт в домашнюю, и не на следующую контрольную. Ты её либо решил сразу и получил баллы,
[01:04:28.920 --> 01:04:38.200]  либо ты не решил и всё, потерял балл. А задача с развернутым ответом контрольная. Вот у нас
[01:04:38.200 --> 01:04:44.680]  первые три задачи, как правило, нет, это первые контрольные, да. Здесь первые две задачи,
[01:04:44.680 --> 01:04:51.280]  это тестовые. Дальше идёт третья, это всё, это уже текстовая задача, тут будет развернута ответ.
[01:04:51.280 --> 01:04:56.520]  Соответственно, за неё будет максимум один балл. Те, кто сейчас её решат, получат один балл. Те,
[01:04:56.520 --> 01:05:01.840]  кто сейчас не решат, у них отлетит задача на следующую контрольную, вдобавка всем тем,
[01:05:01.840 --> 01:05:09.480]  которые будут тогда, если вы решите, получите 0,8 баллов. И есть уже второй раз, не решите,
[01:05:09.480 --> 01:05:19.680]  вам летит в домашнюю она, и будет за 0,5 баллов. Особенность какая? Что если вы не решаете,
[01:05:19.680 --> 01:05:30.800]  вот эти вот задачи с развернутым ответом, то вам не прилетят задачи D за полтора балла дополнительные.
[01:05:30.800 --> 01:05:39.640]  И если все задачи будут постепенно летать в домашнюю, то без задач D вы не сможете набрать
[01:05:39.640 --> 01:05:46.080]  утку. Ну или хор. Я думаю, сейчас всё же первый семестр все будут за хор стараться наливать хотя бы.
[01:05:46.080 --> 01:05:55.560]  Поэтому советую, как можно раньше эти задачи развернуты решать. На тест, если понимаете,
[01:05:55.560 --> 01:06:04.080]  что ну просто не можете догадаться, сначала решайте вторую часть, а потом уже ну на тест просто
[01:06:04.080 --> 01:06:12.960]  понатыкайте нога. Так хотя бы у вас не отлетит на следующую контрольную задачу. А здесь, ну если
[01:06:12.960 --> 01:06:27.960]  не знали, то знания ниоткуда не возьмутся. Так что как-то так. Извините, а вернуться в предыдущие можно,
[01:06:27.960 --> 01:06:36.560]  где мы... ну там была последняя буква, вот. Да-да, под буквой D. Можете, пожалуйста, повторить пример,
[01:06:36.560 --> 01:06:43.480]  когда выполняется. Пустое множество. Пустое множество? Смотри, видишь, вот метка того,
[01:06:43.480 --> 01:06:51.080]  что пустое множество здесь подходит. Значок под множество. Вот я сразу поставил везде выполнено,
[01:06:51.080 --> 01:06:57.800]  есть значок под множество. Потому что частный случай под множество это пустое множество.
[01:06:57.800 --> 01:07:05.200]  Я понял. Всё хорошо, спасибо. Всё, пожалуйста. Это вот такой хороший индикатор того,
[01:07:05.200 --> 01:07:11.680]  что здесь прям. Вот, например. Главное, чтобы потом на контрольной не дописали,
[01:07:11.680 --> 01:07:24.520]  что им это не пустое. Ну если... ну, честно, в мой год там не дописывали, в прошлый год, по-моему,
[01:07:24.520 --> 01:07:31.040]  не скидывали штуки, но в прошлом году там очень сильно сочинялись на контрольных. Я не знаю,
[01:07:31.040 --> 01:07:34.800]  что будет в этом году. В этом году, хотя для по-моему, информатика что-то сделает новое.
[01:07:34.800 --> 01:07:49.440]  Кому как повезёт. В общем, здесь мы вспоминаем, что мы обсуждали PSP. Там три правила,
[01:07:49.440 --> 01:08:18.000]  ещё их напомню. Epsilon phi, phi, phi, phi. И это первое правило, второе правило.
[01:08:18.000 --> 01:08:28.960]  Эти пользуются лево-социативным, право-социативным, оно просто поменяет первый сход,
[01:08:28.960 --> 01:08:40.880]  поэтому оно бесполезно. Нам два правила достаточно будет запасом. Вот. У нас заданы рекурсивные правила.
[01:08:40.880 --> 01:08:51.240]  У нас есть условия, что пустое слово является PSP, а дальше уже вот новые собираются показанным
[01:08:51.240 --> 01:08:58.000]  правилом. И нам нужно определить, что получится все PSP, но не все. Получится все PSP, только они.
[01:08:58.000 --> 01:09:04.760]  Все PSP, но не только они. Все PSP не получаются. Получается не только PSP. Ну, то есть, если
[01:09:04.760 --> 01:09:21.080]  посмотрим, у нас есть. Не посмотрим. Как делать такой номер? В общем, способ, который я предлагаю,
[01:09:21.080 --> 01:09:29.680]  он заключается в том, что у нас есть первое правило. У нас есть. Ещё раз я его выпишу.
[01:09:29.680 --> 01:09:47.080]  Вот. Эпсилон. Дальше правила контрдонации и навешивания скобок. Здесь у нас везде есть правила
[01:09:47.080 --> 01:09:56.680]  Эпсилон и вот ещё дополнительные правила. Дальше как мы можем сказать, что одно множество может
[01:09:56.680 --> 01:10:04.800]  быть получено при помощи другого множества. Давайте посмотрим как-нибудь. Ну, вот такое множество.
[01:10:04.800 --> 01:10:22.200]  Оно построено как Эпсилон, С1, С2. Это то, что я в своё время назвал там выводом одного правила
[01:10:22.200 --> 01:10:31.280]  из другого правила. То есть, можем ли мы получить и, пользуясь вот этим правилом, следующее правило?
[01:10:31.280 --> 01:10:41.360]  Ну да, конечно. Да. То есть, что... Ну да, как мы это сделаем? Мы здесь делаем сначала.
[01:10:41.360 --> 01:10:55.640]  Фи. Фи. Пси. Пси. Вместе наконконтонируем мы их как Фи. Пси. То есть, да, это было значимым как 1 и 2.
[01:10:55.640 --> 01:11:04.160]  Здесь это 1 и 1. Здесь 2. Ух ты. Нет, наоборот. Вот 2 здесь и 1. Что, по сути, сейчас мы сделали?
[01:11:04.160 --> 01:11:17.320]  Мы сказали, что имея слово... Вот, если мы имеем слово, построенное по данному правилу, то мы можем его также разобрать по правилам справа.
[01:11:17.320 --> 01:11:26.160]  А что это означает? Что любое слово отсюда принадлежит слово справа. У кого-то фонит.
[01:11:27.160 --> 01:11:49.160]  Итак, мы получим, по сути, вложение. Вот. Получается, если мы можем вывести из правила A правило B, то множество слов, сдаваем правилом B, будет вложено в множество слов, сдавая их правилом A.
[01:11:49.160 --> 01:12:01.160]  Как доказать эквалентность двух множеств? Доказать вложение в обе стороны. И как доказать, что они не вложены? Просто привести пример, когда принадлежит этому множеству, но не принадлежит другому.
[01:12:01.160 --> 01:12:13.160]  На этом метод решения этой задачи все. Здесь что мы знаем? Мы знаем, что В будет вложено в ПСП.
[01:12:13.160 --> 01:12:33.160]  Вопрос. А ПСП вложено ли в В? Нет. Ну правильно, да. Потому что здесь у нас всегда количество скобок, которые мы добавим, оно будет кратно четырем. А если мы возьмем ПСП из двух скобок, мы никогда не получим.
[01:12:33.160 --> 01:12:41.160]  Вот такой случай. Давайте осмотреться на пункт A.
[01:12:41.160 --> 01:12:54.160]  Можем ли... Ну тут, наверное, даже пытаться вводить правила не имеет смысла. Какие у нас отношения пункт А из ПСП?
[01:12:54.160 --> 01:13:10.160]  Ну если взять и сытые и пустыми, то понятно будет не ПСП. Да, то есть у нас появится не ПСП. Здесь есть. Не ПСП. А у нас могут ли получиться ПСП?
[01:13:10.160 --> 01:13:22.160]  Сейчас скажу. У нас получается не ПСП. А могут ли получиться ПСП? Не могут. Тоже не могут, да.
[01:13:22.160 --> 01:13:34.160]  Ну из первого правила могут. Могут, вот. Я могу получить ПСП. Прикол в том, что у нас получится ПСП могут.
[01:13:35.160 --> 01:13:44.160]  То есть это тот самый случай, когда я могу получить какие-то ПСП, но не все. Плюс я получу еще какой-то дополнительный мусор. Это четвертый пункт.
[01:13:48.160 --> 01:13:58.160]  Смотрите, как можно понять, что получится какие-то ПСП? Мы можем из какого-то правила получить другое правило.
[01:13:58.160 --> 01:14:06.160]  Вот у нас же есть. Тут наследуется правило второе. Если наследится правило второе, то значит какую-то часть ПСП мы получим.
[01:14:06.160 --> 01:14:19.160]  Почему нельзя получить все ПСП? Ну потому что по данному правилу ты не сможешь получить строку вот так вот.
[01:14:19.160 --> 01:14:29.160]  Мы бы могли, знаешь, что сделать? Получить все ПСП. Если бы мы могли вывести еще второе правило.
[01:14:29.160 --> 01:14:38.160]  Получить все ПСП, тогда нам нужно доказать вложение в другую сторону.
[01:14:38.160 --> 01:14:46.160]  Значит нам нужно из правил, предложенных в пункте А, вывести правило, предложенное в определение ПСП.
[01:14:46.160 --> 01:14:56.160]  Ну вообще получится такую строку получить. Если сначала первым правилом со всеми простыми строками, потом закрыть скобочками.
[01:14:56.160 --> 01:15:06.160]  Тогда давай я тебе приведу не пример, потому что пример сейчас. Я тебе докажу из...
[01:15:06.160 --> 01:15:18.160]  Сейчас, хотя может быть, может быть сейчас подумаем. Хороший вопрос.
[01:15:18.160 --> 01:15:28.160]  Давайте подумаем. Сначала я залезу в свои разборы прошлых лет.
[01:15:28.160 --> 01:15:39.160]  Елки-палки. Они еще поменяли тренировочный вариант. Сейчас скажу.
[01:15:39.160 --> 01:15:48.160]  Извините, пожалуйста, а разве если вот будет получаться такая скобочка по второму правилу, то С1 будет просто одной скобочкой, а значит она не будет ПСП?
[01:15:48.160 --> 01:15:53.160]  А по моему по условию С1, С2, С3 ПСП или нет?
[01:15:53.160 --> 01:16:13.160]  Смотри. Мы говорим, что здесь, давай смотреть, у нас задается какие-то слова, какое-то множество.
[01:16:13.160 --> 01:16:23.160]  Какой-то язык. Вот слова из языка. Вот С1, С2, С3 это слова из какого-то языка. Вот так вот мы используя эти правила мы соберем сам язык.
[01:16:23.160 --> 01:16:31.160]  А потом мы смотрим, этот язык будет ПСП или не будет ПСП.
[01:16:31.160 --> 01:16:40.160]  Поэтому мы смотрим эти слова сами по себе. Мы можем смотреть на них как на ПСП, а можем смотреть как на них на ПСП.
[01:16:40.160 --> 01:16:47.160]  Возвращаемся с того, что мы хотим сделать. Доказать, что неравны, неравны.
[01:16:47.160 --> 01:16:53.160]  Да, вероятно немножко мозгодорвительно.
[01:16:53.160 --> 01:16:59.160]  Сейчас давай про пункт А подумаем.
[01:16:59.160 --> 01:17:09.160]  Зачем они это сделали?
[01:17:09.160 --> 01:17:36.160]  А можно спросить, что значит все или не все получаются?
[01:17:36.160 --> 01:17:55.160]  Получится все или не все. У нас есть...
[01:17:55.160 --> 01:18:02.160]  Вот наш появился язык, который мы задали этими правилами. Есть язык ПСП.
[01:18:02.160 --> 01:18:13.160]  У нас есть два варианта того, что может быть. Вложенность в одну сторону, вложенность в другую сторону.
[01:18:13.160 --> 01:18:19.160]  Дальше на каждой из этих два варианта. У нас есть вариант выполнена или не выполнена.
[01:18:19.160 --> 01:18:32.160]  Тогда мы получили четыре варианта и здесь они названы словами.
[01:18:32.160 --> 01:18:36.160]  Вот что такое получается правильность к облачной последовательности, но не все.
[01:18:36.160 --> 01:18:39.160]  Значит получается правильность к облачной последовательности.
[01:18:39.160 --> 01:18:48.160]  Это означает, что А вложено в ПСП, но не все, но в обратную сторону исключения нет.
[01:18:48.160 --> 01:18:57.160]  Получается все ПСП не только они. Значит А вложено в ПСП, но А не вложено в ПСП. В А есть что-то кроме ПСП.
[01:18:57.160 --> 01:19:07.160]  Получается все ПСП, но не только они. Då есть, получается все ПСП и только они. Есть вложение в обе стороны.
[01:19:07.160 --> 01:19:12.160]  И последнее, не все ПСП получается, но получается не только ПСП. В обе стороны вложения отсутствуют.
[01:19:12.160 --> 01:19:29.320]  Вот что, по сути, это за ответы. Понятно или не очень? Нет. Правило, которое мы задали, оно...
[01:19:29.320 --> 01:19:39.520]  Что это такое? Оно на экране сейчас присутствует? Которое мы задали. Ну вот, например, сейчас
[01:19:39.520 --> 01:19:48.200]  рассматриваем правило A. А, это правило. Да, вот, их два правила. Их S1, вот, раз правило,
[01:19:48.200 --> 01:20:02.760]  которые... Скопки на вещь. И второе. Как могут получиться вообще PSP? Ну, ну вот, смотри, по A...
[01:20:02.760 --> 01:20:10.080]  По первому пункту мы можем получить PSP, если мы будем просто применять только первое правило.
[01:20:10.080 --> 01:20:15.240]  Мы получим скопки, которые будут правильными скопочными. А если мы начнем применять второе,
[01:20:15.240 --> 01:20:23.440]  ну как-то бездумным, мы можем получить не PSP. А как это правило вообще понимать,
[01:20:23.440 --> 01:20:32.440]  что это значит? S1, скопка закрывается, S2, скопка закрывается, S3. Есть Epsilon. Дальше у
[01:20:32.440 --> 01:20:44.720]  нас есть S1, тогда мы можем получить строку S1. S1, S2, S3. Это вот S1, S2, S3. Вот правило построения.
[01:20:44.720 --> 01:21:04.600]  Дима, можно получить твою строку. Вот так вот я получу. Дальше, что я сделаю? Я получу строку вот
[01:21:04.600 --> 01:21:10.600]  такую вот, просто понавешивав Epsilon. И дальше получу вот так вот, навешивав сверху,
[01:21:10.600 --> 01:21:18.760]  поэтому можно. Соответственно, что мы можем сказать? У нас в одну сторону, вот из пункта A,
[01:21:18.760 --> 01:21:30.760]  немножко так, пойдем к более хорошей терминологии. Из пункта A мы знаем, что в PSP у нас вложения нет,
[01:21:30.760 --> 01:21:38.880]  потому что нас, например, может получить строка вот такая. Теперь вопрос. Всякую ли PSP мы
[01:21:38.880 --> 01:21:48.160]  можем построить по правилу A? То есть для этого что нам нужно сделать? Посмотрим. То есть нам
[01:21:48.160 --> 01:21:59.760]  нужно из правил вот этих вот получить правила. Давайте я возьму второе определение. Сейчас я
[01:21:59.760 --> 01:22:09.720]  буду доказывать. Определение, что у нас есть FIPSY. Тогда я могу получить вот такую вот штучку.
[01:22:09.720 --> 01:22:21.920]  Моя задача получить как-нибудь вот это добро из вот этого всего. С конкретноцией будет чуть
[01:22:21.920 --> 01:22:31.800]  более неприятно. То есть, как я могу это сделать, по идее? Я могу, во-первых, убрать из два. Тогда
[01:22:31.800 --> 01:22:41.160]  у меня останется здесь из один, как вот ST. Пока номер не надо. Ну, пока вроде так я буду делать.
[01:22:41.160 --> 01:22:52.440]  Дальше я могу что сделать? Я далее могу навесить наверх скобки. По правилу первому.
[01:22:52.440 --> 01:23:15.880]  Я получу 1, S1, S3. Хорошо. По-хорошему, здесь S3. Сверху снять скобки. Есть два варианта.
[01:23:15.880 --> 01:23:21.640]  Либо они действительно были получены сверху наложением скобок. Тогда мы можем просто снять.
[01:23:21.640 --> 01:23:33.480]  Либо это была конкретноцией каких-то штучек. Я теперь вспоминаю про первое определение. Вот я
[01:23:33.480 --> 01:23:42.080]  смотрю сюда. Первое определение мне говорит, что вот что такое S3. S3 могло получиться как из
[01:23:42.080 --> 01:23:51.760]  некоторой строки S4. Тогда в чем проблема? Мне будет просто... Сейчас скажу. Эти скобки...
[01:23:51.760 --> 01:24:14.880]  Скажу. Вот у меня такое правило. Я хочу так. Я хочу объединить скобки и S3 в одну вместе
[01:24:14.880 --> 01:24:20.120]  переменную. Сказать, что это может соответствовать какой-то другой, которая была получена.
[01:24:20.120 --> 01:24:40.960]  Может быть, S4. Это возможно в двух случаях. Когда само S4 было получено так, либо само S4
[01:24:40.960 --> 01:24:47.920]  могло быть получено как? Фикон, конкретноция С. Тогда две эти крайние скобки могли получиться из...
[01:24:47.920 --> 01:25:06.040]  Какого-то, сейчас скажу. И вот так вот. И тогда мы спустимся на уровень индукции ниже и все будет
[01:25:06.040 --> 01:25:28.400]  работать. А теперь нужно подумать, как сказать все это докладно. Сейчас скажу. Можно вопрос?
[01:25:28.400 --> 01:25:38.360]  Разве из того, что мы из правила A доказали, что мы можем прийти к первому правилу задачи всех PSP,
[01:25:38.360 --> 01:25:54.120]  разве не следует то, что мы можем получить все PSP? Еще раз. Ну вот мы из цепочки превращений,
[01:25:54.120 --> 01:26:00.760]  что мы сначала оставили S1, скобочка закрывающая, скобочка открывающая, S3, и потом приписали слева,
[01:26:00.760 --> 01:26:09.480]  справа скобочки. Мы как бы пришли к первому правилу задачи всех PSP, когда мы записывали их.
[01:26:09.480 --> 01:26:25.680]  Когда мы только ввели PSP. Ну смотри, какой тут момент, что правила у нас... Давай рассмотрим
[01:26:25.680 --> 01:26:37.760]  пункт B. Пункт B, он хороший. Да, у нас есть S1, S2 и есть S1, S2. Вот у меня есть правило это,
[01:26:37.840 --> 01:26:41.960]  правило конкатинации я могу легко вывести, а теперь как бы не вывести это правило,
[01:26:41.960 --> 01:26:52.440]  просто возьму, дополню одну эпсеном, сделаю строку и все будет хорошо. Так вот здесь я получу в точности
[01:26:52.440 --> 01:27:04.280]  так правило, как оно здесь написано. Когда я дописал сюда скобки, что я сделал? Я на самом деле,
[01:27:04.280 --> 01:27:13.760]  я получил комбинацию этих правил, то есть я взял второе два раза и к нему применил единицу,
[01:27:13.760 --> 01:27:21.880]  и проблема в том, что теперь мне нужно здесь лишние скобки их снять, чтобы получить в точности то,
[01:27:21.880 --> 01:27:30.640]  что написано в правиле, сдающем PSP, иначе будет несколько не край. То есть нам обязательно нужно
[01:27:30.640 --> 01:27:45.000]  несколько операций применять. Если одна операция, то это не считается. Нет, не совсем. Давай, вот,
[01:27:45.000 --> 01:27:53.160]  смотри, я применил операцию, я получил такую строку, но в правилах у меня именно такой строки нет,
[01:27:53.160 --> 01:28:00.400]  у меня есть конкетинация двух произвольных. Сами же две эти произвольные, они не обязательно
[01:28:00.400 --> 01:28:13.560]  были получены как конкетинация именно двух полученных таким образом. Они сами могли
[01:28:13.560 --> 01:28:23.800]  быть получены как конкетинации некоторых других. Да, мы можем сказать, что в какой-то момент времени
[01:28:23.800 --> 01:28:28.680]  вот этой конкетинации мы не можем бесконечно что-то просто конкетинировать, потому что если
[01:28:28.680 --> 01:28:37.840]  был бы Epsilon, но конкетинируя Epsilon самим собой, мы ничего нового не получим. То есть если мы
[01:28:37.840 --> 01:28:42.960]  получили что-то отличное от Epsilon, в какой-то момент мы должны были на Epsilon навесить вот эти
[01:28:42.960 --> 01:28:52.840]  вот скобки круглые. А значит, в какой-то момент мы сведемся к тому, что у нас будет конкетинация
[01:28:52.840 --> 01:28:58.560]  вида что-то там, так далее, вот, что-то там. Сколько-то раз вот эти вот конкетинации были
[01:28:58.560 --> 01:29:07.440]  скобочек навешанных. Ну и а эти исходные скобочки, вот такие вот конкетинации, мы можем
[01:29:07.440 --> 01:29:14.560]  получить путем того, что вот в S1 скобку здесь делаем по этому правилу, так вот понадобляем двойные
[01:29:14.560 --> 01:29:23.480]  внутренние. Но это значит, что мы можем получить все по SP? Да. Но у нас же не получится по нашему
[01:29:23.480 --> 01:29:32.240]  правилу, чтобы у нас как бы было просто вот как бы phi1, phi2 без скобок. Да, это то, что мы сделали,
[01:29:32.240 --> 01:29:44.040]  мы явно правила не получили, но мы спустились на один уровень индукции вниз. То есть мы посмотрели,
[01:29:44.040 --> 01:29:55.320]  а откуда из происходит вот это вот правило, как сами слова phi и psi могут быть устроены. Явно мы
[01:29:55.320 --> 01:30:00.680]  получить действительно не можем, поэтому мы теперь пытаемся смотреть, а вот по ссылке как они могли
[01:30:00.680 --> 01:30:06.960]  быть получены. И вот мы, когда посмотрели, мы поняли, что в какой-то момент они должны
[01:30:06.960 --> 01:30:14.200]  быть получены по правилу 2. Конкетинация рано или поздно у нас ведется к тому, что мы должны
[01:30:14.200 --> 01:30:19.280]  были сконкетинировать правила 2. Иначе, если бы у нас не было конкетинации правил 2, мы бы
[01:30:19.280 --> 01:30:31.920]  конкетинировали epsilon, а значит ничего не изменяли. А правило 2 у нас уже разрешено, мы можем применять
[01:30:31.920 --> 01:30:42.520]  что-то правил 2. Правил 2 у нас разрешено. И теперь, когда мы так посмотрели в истории, как мы
[01:30:42.520 --> 01:30:49.640]  получили эту строку, мы думаем, а теперь как нам вот этот весь ужас наконкетинированных скобочек,
[01:30:49.640 --> 01:30:55.280]  как нам это сделать? То есть здесь у нас будут переменные, какие-то произвольные, там alpha,
[01:30:55.280 --> 01:31:03.160]  beta, gamma, delta. Вот они все хорошо, мы сможем их как-то использовать. Вопрос, как нам
[01:31:03.160 --> 01:31:09.800]  теперь вот навесить вот эти ужасные скобки? А мы узнаем теперь как это сделать. Вот здесь у
[01:31:09.800 --> 01:31:17.600]  boot мы s2 просто затрем epsilon, здесь мы проставим все переменные, а потом сверху навесим двойные
[01:31:17.600 --> 01:31:30.760]  скобки. Сейчас было понятно вроде или нет? Ну не очень понятно, как бы как сделать изначально
[01:31:30.760 --> 01:31:37.640]  строчку, если у нас нету скобок, как нам получить такую строчку? Давай тогда я заново начну писать.
[01:31:37.640 --> 01:31:55.640]  У меня есть правило навесить. А нам не проще начать рассуждение от того, что взять правильную скобочную
[01:31:55.640 --> 01:32:03.160]  последовательность и доказать, что мы ее можем получить по этим правилам? Круто говоря, мы это и
[01:32:03.160 --> 01:32:22.800]  делаем. Вот у меня есть два, вот есть здесь как-то правило задают и здесь как-то правило. Вот понятно,
[01:32:22.800 --> 01:32:28.680]  что слова получены по этому правилу, я легко могу получить используя это правило. Вот все,
[01:32:28.800 --> 01:32:38.040]  то есть здесь все хорошо. Теперь мне чтобы показать, что я могу все слова построить по данным правилам,
[01:32:38.040 --> 01:32:48.360]  я могу разобрать по этим правилам. Мне нужно показать, что правила FICON комбинации PSI можно
[01:32:48.360 --> 01:33:00.600]  получить используя вот этот ужас. Как это делать? Давайте смотреть на то, как были получены FIC.
[01:33:00.600 --> 01:33:09.600]  Смотрим на шаг раньше, как они были получены. FIC они могли получены по конкотинации. Ну,
[01:33:09.600 --> 01:33:17.240]  значит, теперь мы просто сконкотинировали еще несколько раз. Либо они были получены
[01:33:17.240 --> 01:33:26.240]  по правилам по правил 2. Вот, значит, они будут представлены в виде как-то скобок и внутри них
[01:33:26.240 --> 01:33:35.840]  переменная какая-то другая. Понятно, что все эти переменные в какой-то момент должны были быть
[01:33:35.840 --> 01:33:43.800]  получены по правил 2, либо это EPSION, но конкотинация с EPSION нам не даст никаких скобок. Ну, это просто
[01:33:43.800 --> 01:33:51.520]  не изменяет строку никак. Значит, в какой-то момент вот шагая назад и изучая то, как были
[01:33:51.520 --> 01:34:01.000]  получены FIC, мы придем к тому, что у нас получится строка вот alpha, beta, так далее там, пусть будет
[01:34:01.000 --> 01:34:11.120]  вот. Это следует к тому, что у нас есть какие-то PSP alpha, beta, mu, и на них сверху навешаны вот эти
[01:34:11.120 --> 01:34:22.640]  вот скобки. Это, по сути, вот это правило, которое мы здесь получили, но только за несколько шагов до. Вот
[01:34:22.640 --> 01:34:30.640]  как нам теперь его получить? Эту мы можем уже разобрать строку по правилам левым. Мы возьмем вот
[01:34:30.640 --> 01:34:36.240]  здесь вот это навесим, потом это навесим, потом это навесим, а потом в самом конце мы вот так вот
[01:34:36.240 --> 01:34:51.440]  наверх. И таким образом мы сможем вывести это правило. Сейчас было понятно? Да, спасибо. Супер. В общем,
[01:34:51.440 --> 01:34:57.960]  да, действительно, здесь будут какие-то моменты, когда нам придется шагать в историю назад и искать
[01:34:57.960 --> 01:35:06.920]  то, как были получены сами вот предпослуги PSP. Можно ли было воспользоваться правилам префиксных
[01:35:06.920 --> 01:35:23.000]  сумм для PSP? Смотри, правила префиксных сумм, префиксные суммы, они могут сказать о том,
[01:35:23.000 --> 01:35:31.400]  что строка PSP или нет. А здесь несколько другое то, что мы делали. Мы проверяли PSP это строка
[01:35:31.400 --> 01:35:37.320]  полученная по правилам A или нет. Вот в обратную сторону, да, можно было воспользоваться, когда мы
[01:35:37.320 --> 01:35:47.080]  проверяем, получается ли строки PSP. Здесь мы делаем обратно. Так что, да, здесь мы вот знаем,
[01:35:47.080 --> 01:35:57.880]  что так будет. Это какой у нас пункт? Здесь что мы сказали? Здесь PSP, но не все. Получается,
[01:35:57.880 --> 01:36:13.280]  получается все. Здесь один был у нас. Здесь мы получили PSP, но не только они. 3, хорошо. Смотрим
[01:36:13.280 --> 01:36:21.560]  на пункт B. Пункт B, да, я вот показал, как его легко вывести. Поэтому мы получили что из этого? Мы
[01:36:21.560 --> 01:36:36.280]  вывели из правил B правило PSP. Значит, теперь PSP вложено в B. Значит, теперь нам нужно в обратную
[01:36:36.280 --> 01:36:43.640]  сторону попытаться вывести. Из правил PSP правило B. Правило 2 у нас есть. Правило 1
[01:36:43.640 --> 01:36:54.920]  получается путем применения правила, путем сборка опять стилу правил. Мы сначала их сконкатенировали,
[01:36:54.920 --> 01:36:59.240]  получили PSP. Соответственно, для него мы теперь можем получить правило 2. И получим таким
[01:36:59.240 --> 01:37:13.400]  образом правило B. Так что они в обе стороны получили вложение, значит равенство. Сейчас
[01:37:13.400 --> 01:37:20.360]  прочитаю комментарий. Мы доходим до момента, когда сумма ноль, и выделяем им под строку в скобках.
[01:37:20.360 --> 01:37:31.320]  Не совсем понимаю, что ты написал в плане том, чтобы доказать именно, что любую PSP мы можем
[01:37:31.320 --> 01:37:39.600]  изобрать по правилу A. Вот если ты это как-то распишешь, то я попытаюсь понять, пока я не особо понимаю,
[01:37:39.600 --> 01:37:49.760]  просто идею. Там такое же разделение, как и с этими подпоследовательностями. Только мы просто идем
[01:37:49.760 --> 01:37:56.360]  по префиксам, доходим до момента, когда префикс ноль, сумма в префиксе ноль. И тогда мы говорим,
[01:37:56.360 --> 01:38:04.720]  что у нас есть вот этот префикс, и он является под строкой в скобках. То есть вот здесь отмечена
[01:38:04.720 --> 01:38:09.240]  альфа в скобках, потом так далее, потом мю в скобках. Мы делаем такое же разбиение,
[01:38:09.240 --> 01:38:32.160]  только через префиксную сумму. Мне надо подумать, я подумаю, сейчас не скажу так сходу. В общем,
[01:38:32.160 --> 01:38:42.680]  в случае оно не работает, но возможно тут оно сработает. Так сразу я подумаю. Пока про пункт G подумаем.
[01:38:42.680 --> 01:38:54.080]  Ну из сил того, что у нас просто одна скобка, понятно, что у нас появится какой-то мусор.
[01:38:54.080 --> 01:39:15.160]  Уже знаем, что здесь G не вложено в PSP. Будет ли вложено PSP в G? Какие варианты?
[01:39:15.160 --> 01:39:22.560]  Ну да, это вроде второе правило наше. Да, все. Здесь присутствуют все правила,
[01:39:22.560 --> 01:39:38.760]  соответственно мы получим это все. PSP в G или на G. Получается все PSP, но не только они. И пункт D.
[01:39:38.760 --> 01:39:55.560]  Это правило про создание PSP. Да. Поэтому будет PSP и все они. Да, супер. В одну сторону мы
[01:39:55.560 --> 01:40:03.800]  получим наше правило, которое второе просто взяв epsilon, а в обратную сторону мы получим из
[01:40:03.800 --> 01:40:09.720]  правила двойного, дважды сконкатенировав получив три строчки и потом прируниться.
[01:40:09.720 --> 01:40:16.600]  Не совсем так, ошибаюсь. В общем, правильно, формально делаем как? Мы делаем phi, делаем
[01:40:16.600 --> 01:40:28.800]  конкатонацию phi. Дальше у нас есть psi, вместе получили phi, psi. Дальше есть какой-нибудь rho,
[01:40:28.800 --> 01:40:40.680]  вместе получили rho, phi, psi. Так что здесь, да. Кстати, по номеру второму здесь реально будут
[01:40:40.680 --> 01:40:52.440]  вопросы. Или не будут? Видимо нет, супер. Формально доказывать нужно именно с двух сторон, то есть
[01:40:52.440 --> 01:41:02.200]  сначала то, что пункт принадлежит PSP и наоборот. Да, но это номер тестовый, от вас никто доказательств
[01:41:02.200 --> 01:41:09.640]  этого не будет. Если понимаете, что что-то типа как пункт A, что-то очень неприятное, на это время
[01:41:09.640 --> 01:41:15.560]  тратить не надо. Вот как интуиция подсказывает, так пишешь и потом, если время есть, сядешь,
[01:41:15.560 --> 01:41:25.160]  подробнее разберешь, но не нужно сидеть на тестовом. Не люблю этот номер.
[01:41:25.160 --> 01:41:37.400]  У тебя шоу с микрофоном. Можно писать в чат. Не, еще раз про пункт A. Ух, без проблем, еще раз скажу.
[01:41:37.400 --> 01:41:56.480]  В общем, нафига они его дали, как я не люблю. В общем, прикол с пунктом A. Вот пункт A. Синим
[01:41:56.480 --> 01:42:06.440]  написаны правила, по которым можно построить справа PSP, слева пункт A. Мы сразу можем сказать,
[01:42:06.440 --> 01:42:15.280]  что если я понатыкаю EPSY в третье правило, то я получу скобку, вот такую последовательность скобок.
[01:42:15.280 --> 01:42:26.640]  Она не является PSP, соответственно, у нас уже точно A не вложена в PSP. Теперь мы смотрим,
[01:42:26.640 --> 01:42:40.680]  а как же ведет себя PSP? Оно вложено в A или не вложено? Для этого в данном пункте мы не сможем
[01:42:40.680 --> 01:42:47.520]  явно вывести правила, как делали во всех других, просто подставив EPSY или пару раз накомбинировав
[01:42:47.520 --> 01:42:59.400]  правила. Здесь нам придется рассматривать, как были получены phi и psi. Здесь, смотри, вот второе
[01:42:59.400 --> 01:43:07.800]  правило, оно как звучит, что если phi и psi и PSP, то phi конкотинация psi, это PSP. Но с очередь же,
[01:43:07.800 --> 01:43:15.960]  если phi и psi были PSP, то они были получены по одному из правил, либо где навешаются скобки,
[01:43:15.960 --> 01:43:23.160]  либо где конкотинируются. Тогда рассмотрим два случая, они были получены либо как навесили скобки,
[01:43:23.160 --> 01:43:30.840]  либо как конкотинация. Если были навешаны скобки, то тогда мы сведемся вот к истории,
[01:43:30.840 --> 01:43:40.840]  что будет альфа и даже проконкотинировали какую-то переменную. Если была конкотинация,
[01:43:40.840 --> 01:43:52.720]  они были получены конкотинация двух строк, то давайте посмотрим еще один ход раньше,
[01:43:52.720 --> 01:44:02.560]  как они были получены. И если так разбираться, то конкотинация в какой-то момент должна была
[01:44:02.560 --> 01:44:10.280]  свистись к элементам, которые получаются либо по этому правилу, либо являются EPSY. То есть мы
[01:44:10.280 --> 01:44:18.760]  взяли и по возможности все эти верхние конкотинации, мы их раскрыли. Все, как только мы всех раскрыли,
[01:44:18.760 --> 01:44:27.280]  мы получим что? Мы получим либо EPSY, либо вот эти правила. Соответственно, все переменные,
[01:44:27.280 --> 01:44:35.480]  которые были не EPSY и сконкотинированы по первому правилу, они дадут вот такую вот строчку.
[01:44:35.480 --> 01:44:52.080]  И теперь наша задача как-нибудь распарсить эту строчку по правилам слева. Если мы сможем это
[01:44:52.080 --> 01:45:00.400]  сделать, то мы вывели по сути второе правило. Мы сделали что? Мы посмотрели, мы просто немножко
[01:45:00.400 --> 01:45:09.760]  развернули по истории, как была получена эта строчка. Ничего больше. Хорошо. Как мне получить такую,
[01:45:09.760 --> 01:45:19.440]  имея A, B, так далее, mu, например. Что я сделаю? Я сначала везде розы меню на EPSY, получу правила
[01:45:19.440 --> 01:45:29.520]  phi, две скобки psi. И дальше что я буду делать? Я сюда подам alpha, b, сейчас. Я сюда подам alpha,
[01:45:29.520 --> 01:45:41.520]  здесь получится alpha, psi. Вместо psi подам мне это правило. Там будет alpha, beta, что-то там новое,
[01:45:41.520 --> 01:45:59.360]  psi, так далее, до alpha, скобки beta, скобка, так далее, там, до mu. А теперь мне нужно навесить верхние
[01:45:59.360 --> 01:46:06.960]  скобки, чтобы укрить в точности то, что у нас есть. Это я могу сделать по первому правилу. Все. Я
[01:46:07.040 --> 01:46:12.960]  получил эту стропу, значит, я получил это правило. Значит, мы любое слово,
[01:46:12.960 --> 01:46:20.400]  которое является PSP, можем разобрать при помощи A. Потому что я вывел это правило,
[01:46:20.400 --> 01:46:33.800]  вывел это правило. Все. Понятно? Тебя не слышно.
[01:46:50.400 --> 01:46:57.760]  Напишу в чате, понятно, непонятно. Мы пойдем дальше, если непонятно.
[01:46:57.760 --> 01:47:13.200]  Ну, в общем, будем считать, что понятно. Давайте смотреть пункт номер третий, последний в контрольной.
[01:47:13.200 --> 01:47:25.840]  Он про то, как разбирать формулу, когда есть неоднозначность разбора. У нас есть два правила.
[01:47:25.840 --> 01:47:35.480]  Хоп и хоп. В какой-то момент у нас должны были вместо phi и psi попасть в формулы,
[01:47:35.480 --> 01:47:44.840]  переменные. Тогда давайте смотреть снизу. Вот. Найдем момент, в который могло
[01:47:44.840 --> 01:47:53.880]  получиться первый раз две переменные объединиться, и потом как-то из этого получать варианты.
[01:47:53.880 --> 01:48:04.920]  Что у нас есть? У нас есть уже либо одна палочка между переменными, либо две. У нас таких моментов
[01:48:04.920 --> 01:48:17.480]  ровно два. Это QR и RS. То, что их получилось два, ну, наверное, такая фраза подскажет то,
[01:48:17.480 --> 01:48:24.840]  что мы начнем разбирать QR, получим один способ RS, получим второй способ. Давайте разбирать QR.
[01:48:24.840 --> 01:48:47.280]  Для этого строим дерево разбора снизу. QR вместе дадут. Дальше. Это новая какая-то переменная. Мы
[01:48:47.280 --> 01:48:52.200]  могли что сделать? Мы можем попытаться с П соединить, но тогда мы захватим эту скобку,
[01:48:52.880 --> 01:49:01.640]  и уже С мы не сможем никуда применить, потому что каждая переменная должна быть окружена своей
[01:49:01.640 --> 01:49:13.240]  палочкой с двух сторон. Тогда, значит, нам придется брать С. Хорошо. С. Вместе дадут палка QR, палка С.
[01:49:13.240 --> 01:49:27.480]  Ну, теперь понятно, что нужно будет брать П. Берем П. Палка, П, палка, палка, палка, К,
[01:49:27.480 --> 01:49:36.040]  палка, палка, палка, палка, палка, палка, палка, палка, палка, палка, палка, палка. Ну и
[01:49:36.040 --> 01:49:52.520]  теперь, сделаем сюда вниз. Сидел. Вот сюда. Теперь у меня, ну, просто остался Т. Значит,
[01:49:52.520 --> 01:49:59.600]  сюда навешу t, здесь две палки, как раз с точностью второе правило. вместе это палка, палка-палка-п,
[01:49:59.600 --> 01:50:07.320]  палка-палка-п, палка-палка-ку, палка-палка-р, палка-палка-с, палка-палка-палка-п, палка-т-палка. Всё.
[01:50:07.320 --> 01:50:21.440]  Я получу формулу. Всё. Первый разбор получилось. Написав такой дерево-разбора, можно показать правил,
[01:50:21.440 --> 01:50:30.040]  какой здесь примерно здесь палка палка палка здесь палка палка здесь палка полка
[01:50:30.040 --> 01:50:51.920]  что я применял. Вот так вот. Показали правила, по которым получены деревья, построили деревье
[01:50:51.920 --> 01:50:58.840]  разбора, всё, показали как это деревье разбирается. Почему мы решили начать именно Square? Ну, смотри,
[01:50:58.840 --> 01:51:03.880]  я показал, что есть два варианта, как можно начать. Потому что в какой-то момент мы начали
[01:51:03.880 --> 01:51:10.320]  объединить переменные. Переменные можно объединить либо палкой между ними, либо две палки. Смотрим,
[01:51:10.320 --> 01:51:16.680]  где такие случаи есть. Их ровно два. Есть две палки между Square и две палки между RS. И я сказал
[01:51:16.680 --> 01:51:22.640]  тогда, что вот, похоже, это два кандидата на Doc можно разобрать. Вот я начал Square просто потому,
[01:51:22.640 --> 01:51:32.120]  что выбрал так. Теперь вот я разберусь с RS. Это будет второй разбор. Я сейчас сделаю RS. Палка,
[01:51:32.120 --> 01:51:51.360]  палка, палка, палка, палка. Шлёп, шлёп. Отмечаем. Теперь по аналогии с RS нам придется теперь взять
[01:51:51.360 --> 01:52:07.000]  Q. Палка, Q, палка, палка, R, палка, палка, к палкам, бух, бух, бух. Теперь что? Если я возьму T,
[01:52:07.000 --> 01:52:14.440]  то я вот захлопну здесь и не смогу навесить P. Значит мне придется взять P. Как я беру P? Я
[01:52:14.440 --> 01:52:21.920]  беру по правилам двух палок. Палка, палка, палка, палка, Q, палка, палка, палка, R, палка, палка,
[01:52:21.920 --> 01:52:34.040]  S, палка, палка, палка. Теперь у меня T просто навесить. Я получу палку, палку, P, палку, палка,
[01:52:34.440 --> 01:52:41.920]  earlier. Палку, палку, палку, палку, палка. Палка, палка, палка, палка, палка. Жук, жук. Всё.
[01:52:41.920 --> 01:52:51.560]  Пожалуйста, получено два разбора. Можете ли будет после этой задачи еще разknуться к пункту D,
[01:52:51.560 --> 01:53:00.200]  задача два? Да? Спокойно. Вопросы по этому номеру есть organizations? Это какой-то лёгкий номер
[01:53:00.200 --> 01:53:08.960]  номер по сравнению со вторым? Да, я очень не люблю второй номер, он очень неприятный,
[01:53:08.960 --> 01:53:16.040]  в тест высложный, и это радость, действительно. Следующий контрольный будет все номера легче.
[01:53:16.040 --> 01:53:37.280]  У вас показывают, как у меня чёрный экран стал? Чёрный.
[01:53:37.280 --> 01:53:48.600]  Не знаю, как это работает, но когда у меня экран гаснет, у меня прекращается там связь
[01:53:48.600 --> 01:53:57.040]  экрана. В общем, пункт 2D. Смотри, требуется ли снять построение деревьев? Достаточно просто
[01:53:57.040 --> 01:54:08.980]  построить. Их достаточно просто построить. Там даже будут решения прошлых лет у меня.
[01:54:08.980 --> 01:54:19.480]  Давайте, ну сейчас покажу чуть позже про них. Там прям так вот решение, которое вот отлекто.
[01:54:19.480 --> 01:54:31.360]  В общем, пункт D еще раз два. Смотрим, можем ли вывести из этого правила правила PSP? Давай я возьму
[01:54:31.360 --> 01:54:39.520]  S1 эпсилоном и я получу второе правило построения. Ну или что это? S3 эпсилоном. Вот я получил здесь
[01:54:39.520 --> 01:54:51.520]  это правило. Эпсилон там есть. Всё. Значит, я получил, что все PSP будут разбираться по правилам D.
[01:54:51.520 --> 01:55:03.880]  Всё. PSP вложено в D. А откуда взяты вот эти вот правила с синим цветом под номером 1 и 2?
[01:55:03.880 --> 01:55:16.120]  Так вводится PSP. Помнишь, когда я рассказывал про PSP? Это из теории, понятно. Да, вот их три правила.
[01:55:16.120 --> 01:55:26.280]  Вот всё. Это вот второе и третье. На самом деле, ну блин. Ну ладно, да, 2 и третье помните. Когда-то
[01:55:26.280 --> 01:55:33.680]  будет удобнее использовать 2, когда-то используется удобнее 3. И первое правило, которое с конкатенацией
[01:55:33.680 --> 01:55:41.000]  навешивания сколько? Ну и в пункт D как мне получить? В пункт D я получу из первого правила. Вот мне
[01:55:41.000 --> 01:55:48.680]  приятнее получать вот с этого. Что я сделаю? Я сделаю вот навешу, а потом дважды сконкатенирую,
[01:55:48.680 --> 01:56:02.000]  получу правило D. Поэтому D вложено в PSP. А это пункт 2. Не пункт 2, это ответ 2.
[01:56:02.000 --> 01:56:18.160]  В целом, с надлогом всё. Вот если есть вопросы, давайте сейчас их объясним. А можете пояснить по
[01:56:18.160 --> 01:56:27.600]  поводу оформления на контрольной работе? Оформление. В общем, в первом вы прям тут будете писать,
[01:56:27.600 --> 01:56:33.280]  что точно да, точно нет, возможно два варианта. Может быть у вас будет матрица ответов, там будут
[01:56:33.280 --> 01:56:40.560]  типа строчки A, B, V, и вы там пишете. Но обычно здесь просто вот, прям так и будет написано,
[01:56:40.560 --> 01:56:47.840]  вы просто будете писать рядом. Точно да, точно нет, возможно оба. В номере 2 просто рядом
[01:56:47.840 --> 01:56:53.360]  проставите циферки. В мой год так было. Может быть вам сделают там табличку, проставите циферки.
[01:56:53.360 --> 01:57:01.760]  И именно формально расписывать решение вам нужно только в третьем. Для этого достаточно построить
[01:57:01.760 --> 01:57:11.840]  дерево разбора. Вот давайте сейчас покажу. Можно вопрос? То есть получается, рассматривая PSP,
[01:57:11.840 --> 01:57:18.000]  можно взять любой из трёх правил, которые мы ввели, и уже сравнивать относительно него? Да. Более того,
[01:57:18.000 --> 01:57:22.080]  мы можем в одну сторону посмотреть по одному правилу, в другую сторону по другому. Это всё
[01:57:22.080 --> 01:57:36.880]  абсолютно возможно. Потом при этом это сейчас, давайте я сделаю вот так вот.
[01:57:36.880 --> 01:57:54.280]  Вот теперь я сделаю так. И получается вот у меня будет решение. Это решение моих прошлых годов.
[01:57:54.280 --> 01:58:05.520]  Чуть позже, здесь записи появятся чуть позже. Здесь можно так искать, можно просто млта,
[01:58:05.520 --> 01:58:14.200]  и тут будет всё, что нужно. Здесь будут всё про всем промотоньки, все материалы, я сюда выложу.
[01:58:14.200 --> 01:58:31.760]  Давайте как-нибудь так. Вот, например, решение прошлых лет. Здесь было некоторое пояснение
[01:58:32.240 --> 01:58:44.600]  про то, и вот, например, что. Вот прям да, решение от Вертера, пожалуйста. Всё. Так что,
[01:58:44.600 --> 01:58:58.840]  если просто на всю дерево разбора, всё будет супер. Ещё вопросы по мат-логике есть? Если нет,
[01:58:58.920 --> 01:59:27.760]  мы просто начнём. Ну хорошо, у нас вопросов нет. Показываем. В общем,
[01:59:27.760 --> 01:59:56.160]  что я хотел сказать. В общем, да,
[01:59:56.160 --> 02:00:08.560]  контрольная по КТЧ в тренировочном варианте очень простая для её решения. Ну, в общем,
[02:00:08.560 --> 02:00:14.800]  есть по сути три метода их всех решений. Первый метод – метод пристального взгляда, просто смотрим,
[02:00:14.800 --> 02:00:21.800]  замечаем, используем. Дальше для одного номера будет метод разбиений, который я вот придумал,
[02:00:21.800 --> 02:00:30.800]  и до оставшихся двух номеров в общем случае задачи решаются при помощи, гарантированно
[02:00:30.800 --> 02:00:36.140]  решаются при помощи метода характеристических функций. Вот про метод характеристических
[02:00:36.140 --> 02:00:42.600]  функций сейчас мы посмотрим. Метод разбиений будет очень простой. Для этого надо вспомнить
[02:00:42.600 --> 02:01:04.920]  более функция. Давайте, во-первых, вспомним теоретика множественной операции. Какие кто помнит.
[02:01:13.600 --> 02:01:28.920]  Ничего не помните? Ладно, их пересечение, объединение, разность и просто разность,
[02:01:28.920 --> 02:01:56.400]  но есть ещё дополнение. Всё. Соответственно, в булевой алгебре у нас есть такая штучка,
[02:01:56.400 --> 02:02:24.560]  как А-конъюнция В, А-дизъюнция В, А-ксор В. Все четыре кроме среднего в школе точно были.
[02:02:24.560 --> 02:02:35.280]  А-ксор уже был на мотогике на лекциях или ещё нет? Да, нам говорили. Супер-прекрасно. Полиномы
[02:02:35.280 --> 02:02:46.120]  Жигалкина были? Нет пока. Значит, это будет прямо на следующей неделе, потому что следующий
[02:02:46.120 --> 02:02:51.360]  контроль уже, по идее, должно быть там что-то про полиномы Жигалкина. В общем, поэтому сейчас
[02:02:52.160 --> 02:03:13.920]  про КНФ, ДНФ слышали все. У нас есть таблицы истинности. Да, и здесь вот что-то у нас будет
[02:03:13.920 --> 02:03:22.080]  там как-то написано. Соответственно, кnf и dnf мы можем просто построить и убирать там 0 единицы и
[02:03:22.080 --> 02:03:36.360]  брать конъюнции соответствующих отрицаний или просто самих переменных. Но проблема кnf и dnf в том,
[02:03:36.360 --> 02:03:43.480]  что в школе на алгебре мы работали с обычными полиновами, и мы могли спокойно их там складывать
[02:03:43.480 --> 02:03:53.000]  вычитать, то в кnf и dnf вычитать мы уже не можем, поэтому как-то приятно решать уравнение мы не сможем.
[02:03:53.000 --> 02:04:05.720]  Данную проблему решает вот этот вот потрясающий значок. Сор. Или исключающий или. Но я буду
[02:04:06.720 --> 02:04:18.560]  исключающий или слишком долго говорить. В общем, почему он такой прекрасный? Потому что исключающий
[02:04:18.560 --> 02:04:29.000]  или, иликсор, он одновременно является в буревой алгебре и суммой, и вычитанием. И когда мы называем
[02:04:29.000 --> 02:04:36.440]  что-то полиновами Жигалкина, мы называем их просто этаполиновами, потому что аналогия с обычными
[02:04:36.440 --> 02:04:41.240]  алгебраическими полиновами, которые были в школе, тогда они назывались многочленами теперь этаполиномами.
[02:04:41.240 --> 02:04:53.360]  С ними можно перерывать абсолютно так же. А умножение, то есть это своего рода сложение в
[02:04:53.360 --> 02:05:01.680]  школьных многочленах. Умножение в буревой алгебре будет конъюнцией. Так как писать каждый раз
[02:05:01.680 --> 02:05:07.320]  конъюнцию в символ, то мы будем писать прям как с умножением, пуская знак. То есть, например,
[02:05:07.320 --> 02:05:22.200]  запишем. Аксор БС это, по сути, запись аксор Б конъюнция С. Просто мы опускаем знаки конъюнции.
[02:05:22.200 --> 02:05:35.400]  Хорошо. Несколько правил про аксор, что вот, например, аксор А, аксор БС. Аксор А, он одновременно
[02:05:35.400 --> 02:05:41.520]  и сложение вычитания. Соответственно, мы можем как это складывать, так мы можем за вычитать А и
[02:05:41.520 --> 02:05:51.920]  убирать А. Это то, что еще называется правилом аннигиляции аксора, что для любого А аксор А равняется
[02:05:51.920 --> 02:06:03.880]  ноль. Ноль аксор А равняется А. Если мы ноль прибавим к чему-то, это все равно останется самим
[02:06:03.880 --> 02:06:08.640]  собой. Ноль, в которой бурева константа ноль. Плюс у нас есть бурева константа единица,
[02:06:08.640 --> 02:06:17.680]  провел связь с теоретико-множественной операцией, мы поговорим позже. Итак,
[02:06:17.680 --> 02:06:27.880]  у нас есть единица и теоретико-множественные операции. Когда мы говорим про множество,
[02:06:27.880 --> 02:06:38.920]  особенно в рамках операции дополнения, нам нужно понять, до чего мы дополняем. И в такие моменты
[02:06:38.920 --> 02:07:02.200]  мы вводим понятие U. Множество, в рамках которого мы живем. То есть, например, дополнение А
[02:07:02.200 --> 02:07:17.320]  — это дополнение А до множества универсума. Мы говорим, что такое универсум А? Это вот такая
[02:07:17.320 --> 02:07:25.640]  штучка. Но просто такой штучки в математике быть не может, поэтому для этого существует некоторое
[02:07:25.640 --> 02:07:42.720]  множество У, до которого А дополняется. Что тогда не А? Это У без А. В этой контрольной, как правило,
[02:07:42.720 --> 02:08:04.000]  самого У не будет. Почему не будет самого У? Потому что… не скажу. В общем, в данном
[02:08:04.000 --> 02:08:17.640]  моменте У не будет. Если У будет, я сейчас скажу, что надо делать. Попробуем. Множество У, универсум,
[02:08:17.640 --> 02:08:25.600]  по сути, это будет своего рода в булевой алгебре единица, константа единицы. А пустое множество
[02:08:25.600 --> 02:08:33.640]  будет нулем, стандартно, как в матлоге. Дальше мы хотим перейти от теоретико-множественных
[02:08:33.640 --> 02:08:40.720]  операций к операциям булевым, потому что на булевой алгебре мы умеем как-то красиво работать.
[02:08:40.720 --> 02:08:55.200]  Вот давайте рассмотрим. Просто на двух множествах. На больших все абсолютно
[02:08:55.200 --> 02:09:03.120]  аналогично. Давайте войдем в понятие характеристической функции. Вот у меня есть множество А. Для него я
[02:09:03.120 --> 02:09:13.480]  веду характеристическую функцию. Что она будет значить? А от х. Она будет равняться нулю, если х
[02:09:13.480 --> 02:09:20.640]  не принадлежит А, и единицы, если х принадлежит А. Данный метод будет особенно часто использоваться
[02:09:20.640 --> 02:09:26.840]  в теории меры, теории веры и так далее и тому подобное. Вот там вот прям это вообще любят. Даже
[02:09:26.840 --> 02:09:36.960]  во втором смене снимать она у вас будет. Вот у меня есть множество А, множество Д. Соответственно,
[02:09:36.960 --> 02:09:48.560]  давайте порасставим в единичке там, где закодируем все эти области словами из двух символов,
[02:09:48.560 --> 02:09:58.760]  или это 0 либо единицы, где единицей первая будет, если это содержится в А, а в втором случае единица
[02:09:58.760 --> 02:10:04.160]  будет, если это содержится в В. Поехали исполнять области. Здесь это принадлежит А, но не принадлежит В,
[02:10:04.160 --> 02:10:11.720]  это 1, 0. Принадлежит А принадлежит В, это 1, 1. Не принадлежит А, но принадлежит В, 0, 1. Не принадлежит
[02:10:11.720 --> 02:10:24.720]  ничего. Тогда, если я просто построю таблицу истинности 0, 0, 0, 1, 1, 0, 1, 1, это А, это В,
[02:10:24.720 --> 02:10:36.280]  то произвольная область на этой карте я могу как-то закодировать некоторые булевые функции,
[02:10:36.280 --> 02:10:46.120]  просто поставив, что 1 отмечен там вот 1, не отмечен 0. И получается, я дальше смогу довозить через
[02:10:46.120 --> 02:10:52.600]  переменные А и В. На самом деле, эти переменные А и В, это есть характеристические функции, которые единицы,
[02:10:52.600 --> 02:11:07.400]  когда принадлежит А, 0, когда не принадлежит В. Дальше, из некоторых соответствий, что мы знаем,
[02:11:07.400 --> 02:11:15.680]  у нас пересечение множество соответствует функции конъюнции, то будет, если мы пересечем,
[02:11:15.680 --> 02:11:21.080]  то мы отметим только область 1, 1, и мы получим следующую булевую функцию, и это действительно
[02:11:21.080 --> 02:11:30.080]  конъюнция. Аналогично, у нас объединение соответствует дизюнции, симметрическая разность к Сару,
[02:11:30.080 --> 02:11:39.680]  дополнение соответствует отрицанию, а теперь давайте посмотрим, что такое А без В. А без В,
[02:11:39.680 --> 02:11:56.640]  это только область 1, 0. Давайте вспомним, как выглядит из А следует В. Из А следует В,
[02:11:56.640 --> 02:12:07.320]  импликация имеет следующую таблицу истинности. Тогда А, дополнение В, по сути, является отрицанием
[02:12:07.320 --> 02:12:30.040]  импликации. Отрицание импликации это хорошо, но всегда лучше, когда есть ксор. Для этого мы
[02:12:30.040 --> 02:12:36.880]  запомним несколько интересных теоретиков множества фактов. Один из самых приятных,
[02:12:36.880 --> 02:12:53.760]  что симметрическая разность В, это А без В объединить с В без А. Дальше у нас есть факты вида А,
[02:12:53.760 --> 02:13:13.680]  это есть А без В. Вот, сейчас этот значок еще подниму и поговорю. Пересечь с В, что А объединение с В
[02:13:13.680 --> 02:13:25.760]  есть А без В. Когда мы делаем объединение вот таким вот квадратным точком, мы, по сути, пишем
[02:13:25.760 --> 02:13:32.520]  объединение, подчеркивая, что эти множества не пересекаются и называем это дизъюнтным объединением.
[02:13:32.520 --> 02:13:45.640]  Например, метод характеристических функций помогает очень удобно доказывать все эти равенства.
[02:13:45.640 --> 02:13:56.480]  Только давайте сначала поговорим про полиному Жигалкина. Полином Жигалкина мы можем по любой
[02:13:56.480 --> 02:14:05.360]  бульевой функции построить его по лином Жигалкена. Пусть у нас есть таблица истинности 0.0.1.1.
[02:14:05.360 --> 02:14:17.840]  У нас была таблица истинности 0.0.1.1. Это А, это В. Смотрите, как работают. Первая строчка будет
[02:14:17.840 --> 02:14:22.840]  соответствовать единице, потому что здесь нет ни одной переменной. Здесь есть переменная В,
[02:14:22.840 --> 02:14:27.880]  поэтому соответствует переменная В. Здесь есть переменная А, соответствует. Здесь единичка
[02:14:27.880 --> 02:14:34.040]  в переменной А, соответствует поэтому в переменной А. Здесь есть единицы В и В, поэтому это АВ.
[02:14:34.040 --> 02:14:52.120]  Выписываем вот так вот. 1.0.1.1.0.1. Дальше мы начинаем ксорить соседние числа. 0 ксор 0 это 0.
[02:14:52.120 --> 02:14:57.840]  Ксор это по-другому сложение по модуль 2. То есть, если они различные у нас единицы,
[02:14:57.840 --> 02:15:09.000]  одинаково 0. Поэтому здесь 1, здесь 1. Дальше здесь 1, здесь 0, здесь 1. Все. Теперь мы берем,
[02:15:09.000 --> 02:15:16.760]  создавляем полином Жигалкина. Как он делается? Очень просто. Смотрим на вот левую часть
[02:15:16.760 --> 02:15:24.520]  треугольника и проверяем, что если 0 мы не берем соответствующую ей переменную А с единицей,
[02:15:24.520 --> 02:15:37.840]  то берем. В данном случае мы получим А ксор АВ. Вот. Например, тогда в полином Жигалкина это АВ,
[02:15:37.840 --> 02:15:55.280]  АВ это А ксор, В это А ксор АВ. Что же такое объединение? Это А ксор В ксор АВ.
[02:15:55.280 --> 02:16:09.520]  А отрицание это будет 1 ксор А. И как раз функция единица, почему она единица? Потому что
[02:16:09.520 --> 02:16:19.840]  она будет здесь 1, 2, 3, 4 все содержать. И она будет говорить, что это весь универсум.
[02:16:19.840 --> 02:16:35.960]  Хорошо. А, ну и получается про то, что я говорил, что удобно ими пользоваться. Как показать,
[02:16:35.960 --> 02:16:45.400]  что это равно? Слева у нас в характеристических функциях записано А ксор В. Справа же что
[02:16:45.400 --> 02:16:57.560]  у нас написано? А ксор АВ ксор В ксор АВ. Как мы понимаем, ксор это на временное сложение учитания,
[02:16:57.560 --> 02:17:04.760]  поэтому одинаково просто убираем. Справа записано А ксор В. Все. В одну строчку доказали.
[02:17:04.760 --> 02:17:11.320]  Есть вариант расписывать там х принадлежит, рассмотреть сети сучий, но по мне это быстрее
[02:17:11.320 --> 02:17:23.760]  и приятнее. Все. Теперь, зная вот эту магию, мы можем что делать? Решать контрольную. Вот первый номер.
[02:17:23.760 --> 02:17:52.400]  Кто-то шумит. Поехали. А без В. Ну на самом деле мы вот рассмотрели уже А без В. А без В это А ксор АВ
[02:17:52.400 --> 02:17:57.360]  на характеристических функциях. А теперь мы просто берем заменяем все эти характеристические
[02:17:57.360 --> 02:18:05.240]  функции на соответствующие множество и знаки теоретика множества. Это А симметрическая разность,
[02:18:05.240 --> 02:18:18.520]  А пересечение с В. Все. Разность А пересечение с В. Что такое объединение? Объединение. Ну,
[02:18:18.520 --> 02:18:28.840]  как делать это все? Берем вот таблицу, составляем таблицу истинности по этому.
[02:18:28.840 --> 02:18:58.840]  Области 1.1.1.0.1.0.0.0.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.1.0.1.0.1.1.0.1.0.1.0.1.0.1.0.1.0.1.0.1.0.1.0.1.0.1.0.1.0.1.0.0.1.0.1.0.0.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0
[02:18:58.840 --> 02:19:00.840]  Оsheetavim.
[02:19:00.840 --> 02:19:04.840]  Тогда мы возьмем вот эти вот и
[02:19:04.840 --> 02:19:07.840]  переменные.
[02:19:07.840 --> 02:19:11.840]  Значит, мы получим, что мы получим?
[02:19:11.840 --> 02:19:14.840]  А, XOR, B, XOR, AB.
[02:19:14.840 --> 02:19:19.840]  А теперь просто записываем на языке
[02:19:19.840 --> 02:19:21.840]  теоретикам и арсферам.
[02:19:21.840 --> 02:19:25.840]  А, XOR, B, XOR, A, P, XOR, B.
[02:19:25.840 --> 02:19:32.180]  Сечение СП. Последнее. Вот. Теперь уже у нас будет
[02:19:32.180 --> 02:19:43.580]  три множества. Соответственно, теперь у нас области всё
[02:19:43.580 --> 02:20:11.780]  появится 16. Это 1.0.1. Сейчас. 1.0.0. 1.0.0. Это 0.1.0. 0.1.
[02:20:11.780 --> 02:20:21.980]  Здесь 1.0.1. Здесь 0.1.1. Здесь 1.1.0. Здесь 1.1.0. Здесь 0.0.0. Начинаем рисовать на
[02:20:21.980 --> 02:20:28.780]  диаграмме L-ровенно, как выглядит наше множество. Это объединение без C. Значит, вот оно.
[02:20:28.780 --> 02:20:38.180]  Всё. Быстро рисуем таблицу истинности. Раз, два, три, четыре. Раз, два, три, четыре. Раз, два, раз, два.
[02:20:38.180 --> 02:21:00.420]  Раз, два, раз, два. У меня единицы помечено множество 1.0.0, 1.1.0 и 0.1.0. Всё. Всё остальное
[02:21:00.420 --> 02:21:10.700]  у меня помечено 0.0. Всё. Теперь расписываю, какие будут соответственно здесь вот переменные.
[02:21:10.700 --> 02:21:19.540]  Здесь все 0.0.0. Это единица. Здесь только C. Здесь только B. Здесь B и C. Здесь только A. Здесь A-C.
[02:21:19.540 --> 02:21:31.540]  Здесь только AB. Здесь AB-C. Всё. Расписал. Начинаю строить вот этот треугольник. 1.0.1. 1.0.1.
[02:21:31.540 --> 02:21:48.820]  Что еще раз? Что такое полином Жигалкина? Полином Жигалкина – это запись из единицы,
[02:21:48.820 --> 02:21:55.540]  ксора и конъюнции. То есть мы любую булевую функцию можем представить, используя вот единицу,
[02:21:55.540 --> 02:22:08.540]  ксор, переменные и еще конъюнцию. Всё. Используя вот эти три символа и еще переменные,
[02:22:08.540 --> 02:22:14.060]  мы можем абсолютно произвольную булевую функцию представить в такой вот записи удобной. Она
[02:22:14.060 --> 02:22:22.940]  похожа в своем роде на полином. В школе, если помнишь, было A плюс BC. Только теперь мы в
[02:22:22.940 --> 02:22:27.580]  булевой алгебре живем, поэтому у нас плюсик у нас в кружочке, и при этом одновременно у нас
[02:22:27.580 --> 02:22:39.940]  плюсик и минусик. Такая немножко большая особенность булевая алгебра. Что мы делали?
[02:22:39.940 --> 02:22:47.220]  Мы здесь, когда нас попросили симметрическую разность и пересечение, нас, по сути,
[02:22:47.220 --> 02:22:57.980]  в точности попросили построить там полином Жигалкина. Как сделать полином Жигалкина?
[02:22:57.980 --> 02:23:07.740]  Вот можно было, знаешь, даже не строя таблицу естественности, считаю это, A без B. Мы знаем,
[02:23:07.740 --> 02:23:15.820]  что... ладно, не совсем, не получится. Нет, я хотел показать, но не совсем получится,
[02:23:15.820 --> 02:23:30.140]  в другом месте получится. В чем супер. Да, я вроде закончил. Сейчас понятно, в чем вообще смысл,
[02:23:30.140 --> 02:23:38.860]  что такое полином Жигалкина. Просто такая вот запись. Это такой способ ее расчета быстрой.
[02:23:38.860 --> 02:23:47.980]  Как нам быстро найти... Вот мы выписываем вот строчку всю таблицу естественности, вот видишь,
[02:23:47.980 --> 02:23:53.820]  вот строчка значений функции, мы туда записали, вот строчку теперь транспонировали. А дальше
[02:23:53.820 --> 02:24:00.420]  просто берем, если совпадают, мы посередине пишем ноль, не совпадают в единицах, делаем XOR.
[02:24:00.420 --> 02:24:10.700]  Здесь XOR. И так вот заполняем треугольник. И дальше смотрим на его левое ребро. Везде,
[02:24:10.700 --> 02:24:14.860]  где единицы, мы просто берем соответствующие переменные и получаем таким образом запись.
[02:24:14.860 --> 02:24:24.820]  Здесь мы получили AXOR, AXOR, AB. Вот здесь вот у нас немножко сложнее, у нас три переменных.
[02:24:24.820 --> 02:24:40.300]  Зачем это делать? Сейчас скажу. Ну, зачем это делать?
[02:24:40.300 --> 02:24:50.220]  Потому что вот как раз в номерах 1 и 3 у вас может быть использоваться это.
[02:24:50.220 --> 02:24:55.100]  Если вас как раз могут попросить использовать симметрическую разность пересечения,
[02:24:55.100 --> 02:25:02.780]  либо вас будут использовать вот эти вот вещи. Объединение, пересечение, дополнение. Если
[02:25:02.780 --> 02:25:07.980]  объединение, пересечение, дополнение, то при помощи метода характеристических функций мы
[02:25:07.980 --> 02:25:18.380]  можем использовать KNF, DNF строить. Но KNF, DNF умеют строить все со школы. Здесь это...
[02:25:18.380 --> 02:25:47.420]  В общем-то, здесь мы берем все, кроме первых двух. Здесь у нас BC, BVC6C, симметрическое дополнение.
[02:25:47.420 --> 02:25:59.020]  То есть пленом Жигалкина использовать можно только, когда нас через симметрическую разность
[02:25:59.020 --> 02:26:08.900]  и пересечение просят, что-то выразить? Да. В других случаях, в общем, раньше была задача на то,
[02:26:08.900 --> 02:26:18.460]  чтобы решать уравнение в, сейчас скажу, уравнение в теоретике множественной. То есть при каких х у вас
[02:26:18.460 --> 02:26:26.300]  там выполнено равенство. И тогда переход к пленому Жигалкину и решение через него, оно было в разы
[02:26:26.300 --> 02:26:33.460]  проще, чем пытаться расписывать все эти случаи. Пленом Жигалкина, по сути, да, он применим,
[02:26:33.460 --> 02:26:38.900]  если у вас пересечение симметрической разности. Если у вас объединение, объединение, пересечение
[02:26:38.900 --> 02:26:49.700]  дополнения, используйте KNF, DNF. Что удобнее на ваш выбор? Грубо говоря, все это сводится к тому,
[02:26:49.700 --> 02:26:55.460]  что вот теперь мы вместо теоретика множественных операций, мы хотим одни более функции выжать
[02:26:55.460 --> 02:27:06.580]  через другие. Задачи аналогичны. В этом заключается метод характеристических функций. И зачем он
[02:27:06.580 --> 02:27:13.140]  используется? Просто мы знаем про был функций немножко чуть больше, там закономерности чуть
[02:27:13.140 --> 02:27:18.340]  больше, и нам удобнее пойти работать с ними в какой-то момент, чтобы потом обратно вернуться к
[02:27:19.140 --> 02:27:29.860]  Могли вы повторить, что такое KNF и DNF? KNF и DNF это запись в помощи конъюнции и дезюнции. Сейчас
[02:27:29.860 --> 02:27:38.420]  я, наверное, покажу в том последнем номере. Давайте пока это добьем. Вот что у меня здесь. Меня
[02:27:38.420 --> 02:27:55.700]  просят все кроме 1 и C. То есть это будет B и C, и A и C, и A и B. Нет, C нельзя. И A, B, C. И
[02:27:56.260 --> 02:28:12.660]  я еще что-то забыл. И AB. Вот. И этот номер так решается вот, например, быстро. У вас вполне реально
[02:28:12.660 --> 02:28:17.820]  может быть по аналогии номер, где вас подпребуют выразить это как-то, например,
[02:28:17.820 --> 02:28:29.700]  используя пресечение, дополнение, там, пресечение, объединение, дополнение. Давайте смотреть. Вот нас,
[02:28:29.700 --> 02:28:34.820]  допустим, такое множество. Нас, таблица, истинность такая. Вы долго сидели, думали, вот,
[02:28:34.820 --> 02:28:41.900]  но не приходит вам в голову как явно выразить из методом пристального взгляда использовать операции.
[02:28:41.900 --> 02:28:46.340]  Это действительно нетреально. Здесь мы используем более общий случай, который нам гарантирует,
[02:28:46.340 --> 02:28:56.140]  что так можно. Как это сделать? Ну, если нас просят так, то давайте делать что? Давайте строить
[02:28:56.140 --> 02:29:05.780]  KNF-MNF. Вот у нас получилась такая таблица истинности. Так, как мы строим KNF? Эти просто KNF
[02:29:05.780 --> 02:29:16.340]  будем сейчас строить, я вспомню только. KNF – это конъюнцы и там дисюнцы. Хорошо. Вот давайте про
[02:29:16.340 --> 02:29:24.140]  KNF напомним, что конъюнцы – это конъюнцы вот таких вот скобочек, где внутри скобок стоят либо
[02:29:24.140 --> 02:29:34.860]  переменные, либо их отрицание, и между ними может соединяться дисюнция. Всё. Вот такая вот
[02:29:34.860 --> 02:29:42.580]  запись. Она строится по таблице истинности следующим образом. Да, конъюнцы будут нас фиксировать
[02:29:42.580 --> 02:29:54.420]  нули. Соответственно, мы убираем строчки, где нули. Так запомнить, как строить KNF. KNF – она то,
[02:29:54.420 --> 02:30:01.820]  что называется сохраняет ноль. То есть, если… или это не сохранение нуля. Нет, другое, да. В общем,
[02:30:01.820 --> 02:30:08.220]  KNF – она обладает свойством, что если одна из переменных ноль, то все выражение сразу ноль.
[02:30:08.220 --> 02:30:19.900]  Поэтому мы берем при помощи KNF, фиксируем значения, которые будут нули. Вот их пять
[02:30:19.900 --> 02:30:28.020]  штук. Можем фиксировать. Конечно, на данном случае лучше KNF, но без разницы. Выбираем,
[02:30:28.020 --> 02:30:39.260]  где нули. Тогда смотрим, здесь настоят нули. У нас теперь дисюнцы. Мы берем переменные,
[02:30:39.260 --> 02:30:52.460]  и там, где нули, мы берем сами переменные, а где единицы, мы берем отрицание этих переменных.
[02:30:52.460 --> 02:30:58.060]  То есть, если мы возьмем здесь дисюнцию a, b и c, то мы получим бурю функцию, которая будет
[02:30:58.060 --> 02:31:08.260]  верна везде, кроме этой строки. А это ровно то, что нам и нужно. Возьмем a или b или c. Дальше там
[02:31:08.260 --> 02:31:19.500]  конюнция будет, что a или b или c. Конюнция и так далее. Она вечно для всех странных строк.
[02:31:19.500 --> 02:31:24.900]  А дальше мы что сделаем, когда нас попросили записать, используя эти знаки. Мы конюнцию
[02:31:24.900 --> 02:31:34.780]  поменяем на пересечение, дисюнцию на объединение, отрицание на дополнение. На этом все.
[02:31:34.780 --> 02:31:49.860]  С номером третьим вот мы сейчас попробуем что-то такое сделать. ДНФ это просто другой
[02:31:49.860 --> 02:31:57.420]  вариант получается? В данном случае действительно будет проще искать ДНФ. Мы будем брать там,
[02:31:57.420 --> 02:32:06.180]  где единицы. То есть, наоборот, там, где единицы. И мы будем делать так, чтобы вот переменные,
[02:32:06.180 --> 02:32:11.820]  имея эти значения, давали единицу. То есть, конюнции. То есть, нам нужно будет сделать a,
[02:32:11.820 --> 02:32:25.620]  сделать b и 0 превратить в единицу. Это будет не c. Все. Идея такая, что конюнция, она, сейчас скажу,
[02:32:25.620 --> 02:32:34.740]  и что это сейчас. Конюнция, она фиксирует 0. А дисюнция, она фиксирует единицы. То есть,
[02:32:34.740 --> 02:32:42.620]  если у нас есть где-то единицы, то при объединении единица, она сохранится. Значит, для дисюнции
[02:32:42.620 --> 02:32:47.100]  мы будем убирать там единицы. Дальше нам нужно сделать так, чтобы вот теперь соответствующая
[02:32:47.100 --> 02:32:52.740]  конюнция обращалась к единице на данном наборе. Где-то мы подбираем соответствующим образом
[02:32:52.740 --> 02:33:10.380]  переменные. И все. Теперь, да, я покажу, зачем я выбрал КНФ в тот момент. Номер 6. Он решается
[02:33:10.380 --> 02:33:18.460]  как? Первый вариант методом пристимного взгляда. Как решать методом пристимного взгляда? Ну,
[02:33:18.460 --> 02:33:30.940]  смотрим. Да-да. Смотрим внимательно то, что нарисовано. Разбиваем на кусочки,
[02:33:30.940 --> 02:33:38.180]  которые мы можем понять, как мы получили. Например, есть вот такой вот кусочек. Я знаю,
[02:33:38.180 --> 02:33:48.980]  что это A без B или C. Ну, просто я так вижу. Этот кусочек это пересечение B и C. А этот
[02:33:48.980 --> 02:33:57.220]  кусочек C без A или D. Дальше я это все объединил и получил это множество. Аналогично здесь это
[02:33:57.220 --> 02:34:13.740]  пересечение без C, пересечение A и C. Вот это будет без B, а это C без объединения B. То,
[02:34:13.740 --> 02:34:36.500]  что я сейчас говорю, на самом деле это... Что это? Это своего рода КНФ. Давайте смотреть. Я возьму
[02:34:36.500 --> 02:34:46.740]  первый момент. Первый пример. У меня здесь 0.1.0.0.0. Даже не так. Я просто сделаю эти какие-то
[02:34:46.740 --> 02:35:16.740]  закрашеные. Не будет понятна
[02:35:16.740 --> 02:35:26.280]  единица, единица, единица, все остальные нули, что я предлагаю строить, я предлагаю
[02:35:26.280 --> 02:35:36.660]  строить кнf, хоть это невозможно будет где-то не оптимально, строить в данном случае
[02:35:36.660 --> 02:35:46.100]  просто все кнf, выбираем нули и выбираем так чтобы данный набор обнурялся, то есть
[02:35:46.100 --> 02:36:02.300]  у нас будет ab, a или b или c, дальше здесь a или не b или c, здесь не a или не a или b или не c,
[02:36:02.300 --> 02:36:22.820]  здесь не a или не b или не a или не b или c,
[02:36:22.820 --> 02:36:35.980]  дальше мы вспомним свойства, что a следует b, это не a плюс b,
[02:36:35.980 --> 02:37:01.020]  сейчас я скажу, а мы помним, что разность у нас была, а мы хотим разность,
[02:37:01.020 --> 02:37:08.700]  что разность это три цани импликации, жух, жух, жух, жух на весе этой цани, раскрываем под
[02:37:08.700 --> 02:37:30.180]  дымом, но это а и не b, поэтому надо будет строить dnf, да мы выбираем единички, это не а и не b и
[02:37:30.180 --> 02:37:57.340]  c, не а и b и c, а и не b и не c, а и b и c, супер, что теперь я буду делать, я теперь буду эти кусочки,
[02:37:57.340 --> 02:38:07.700]  зная, что у меня есть такая штучка, я их буду объединять, сворачивать вот в такие вот записи,
[02:38:07.700 --> 02:38:18.980]  давайте я вот это специально сделаю значок, для этого а не следует b, он специальный значок
[02:38:18.980 --> 02:38:28.380]  веду, чтобы не писать такую ужасную запись, вот это у меня станет не а и из b не следует c,
[02:38:28.380 --> 02:38:36.100]  но вот теперь я могу сделать просто такую штучку и сюда применить снова это правило,
[02:38:36.100 --> 02:38:52.780]  здесь c не следует b, вот, отметите, что здесь у нас а не следует b, а здесь а и не b, вот здесь не b,
[02:38:52.780 --> 02:39:01.460]  значит нужно будет их поменять местами, аналогично здесь, это будет превратиться в вот c не следует b,
[02:39:01.460 --> 02:39:15.700]  не следует а, все, по сути, что я сейчас сделал, я привел вот эту вот ужасную запись к запись,
[02:39:15.700 --> 02:39:19.900]  которую я могу легко перевести в теоретику множественную операцию, вот эта вот операция,
[02:39:19.900 --> 02:39:32.300]  это а не следует b, это множество а без b, теперь вот второе, второе что я сделаю,
[02:39:32.300 --> 02:39:54.460]  я сделаю просто, здесь я сделаю c и из b не следует а, хорошо, у меня осталась еще эта штучка,
[02:39:54.460 --> 02:40:16.180]  аналогично это b не следует а, объединение не c, это из c не следует b, вот, да, не это,
[02:40:16.180 --> 02:40:25.900]  и это превратится в из а не следует b, не следует c, а последнее просто так остается,
[02:40:25.900 --> 02:40:31.740]  а везде стоит disun c, тогда что я теперь делаю, я заменяю вот этот вот значок не следования на
[02:40:31.740 --> 02:40:44.540]  разность, я получаю в точности ответ, то есть не будет c без b без а, объединение с c пересечь с b
[02:40:44.540 --> 02:41:05.620]  без a, объединение с a без b без c, объединение с a пересечь b пересечь c, и действительно,
[02:41:05.620 --> 02:41:10.340]  если мы посмотрим, то это именно те кусочки, которые мы хотели, вот например c без b без a,
[02:41:10.340 --> 02:41:16.700]  это вот этот вот кусочек, мы вот так вот поняли как его задать, там вот пересечение кусочек,
[02:41:16.700 --> 02:41:28.740]  а без b без c вот кусочек, остался кусочек, что там у нас, c пересечь с b без a, ну действительно,
[02:41:28.740 --> 02:41:33.860]  это вот этот маленький кусочек, аналогично построив dnf и преобразовав данным способом,
[02:41:33.860 --> 02:41:40.700]  мы можем получить для второго случая, для третьего случая. Понятно,
[02:41:40.700 --> 02:41:44.860]  как будет делать третий номер, если прям совсем этот пристальный взгляд не работает.
[02:41:44.860 --> 02:41:55.300]  А насколько обычно сложностей на контрольной и выше пробного варианта?
[02:41:55.300 --> 02:42:06.940]  Ой, по УКТЧ, в общем, это абсолютно непонятно, то есть матлог, красота контрольных по матлогу,
[02:42:06.940 --> 02:42:16.900]  что тренировочный вариант, он действительно отражает суть задачи. По УКТЧ, там у вас могут,
[02:42:16.900 --> 02:42:24.020]  особенно дальше будут задачи, которые типа, это плюс-минус тестовые, типа считается, там будут
[02:42:24.020 --> 02:42:29.060]  задачи, которые разровнуты, там вообще никак подготовиться, какой-то понять план, решение нельзя.
[02:42:29.060 --> 02:42:36.300]  Поэтому вот здесь я просто вам рассказал про метод, который действительно дает,
[02:42:36.300 --> 02:42:43.260]  гарантированно дает ответ, просто нужно будет выбрать, к какому варианту нам нужно прийти там,
[02:42:43.260 --> 02:42:55.460]  КНФ ДНФ или, по-людному, Жигалкина. Ну и, конечно, есть вариант того, что, а, но на записи нету. Вот,
[02:42:55.460 --> 02:43:00.060]  да, в прошлом году-то была запись, поэтому можно было случайно посмотреть и понять,
[02:43:00.060 --> 02:43:03.540]  что если такое рассказывали, придумать специально контрольное то, что не рассказывали.
[02:43:13.260 --> 02:43:27.980]  Всё, и последний номер. Да неужели мы такими темпами закончим? В общем, задача, на первый
[02:43:27.980 --> 02:43:37.620]  взгляд, выглядит абсолютно устрашающе, непонятно как ее решать. Первое, что попробуйте сделать,
[02:43:37.620 --> 02:43:47.460]  вы, вероятно, это... В общем, давайте так будем решать. Я могу показать сначала метод, который,
[02:43:47.460 --> 02:43:56.220]  ну, мы просто попробуем решить по условным, то есть руководствуясь мыслям, а потом попробуем
[02:43:56.220 --> 02:44:01.180]  сразу использовать прикольный метод, понять насколько он в разы быстрее и что там все быстро решается,
[02:44:01.180 --> 02:44:13.900]  как что хотите, или сразу мы решаем быстрым способом. Лучше первое. Хорошо. В общем, быстрый
[02:44:13.900 --> 02:44:18.900]  способ там, я, ну, я предполагал, что он будет быстрым, но когда я пробовал его применить,
[02:44:18.900 --> 02:44:26.980]  там вообще слишком быстро, то есть если вы используете в 13, в 3, мы прям закончим. Ну,
[02:44:26.980 --> 02:44:32.380]  давайте думать. В общем, у нас в обоих частях стоят что? Стоят декарта произведения.
[02:44:32.380 --> 02:44:41.940]  Нет, это для моего метода. В общем, декарта произведения, когда вот декарта произведения
[02:44:41.940 --> 02:44:51.180]  будут равны, когда обе части с двух сторон будут совпадать, соответственно, мы сможем теперь разбить
[02:44:51.180 --> 02:44:59.460]  вот это равенство на одновременное выполнение равенства для двух сторон. Что я предлагаю делать? Вот.
[02:44:59.460 --> 02:45:07.380]  Здесь вот рисуем, здесь рисуем. Будем писать слева то, что по левую часть декарта произведения,
[02:45:07.380 --> 02:45:12.340]  справа то, что по правой части декарта произведения. Объединение, ну, понятно,
[02:45:12.340 --> 02:45:19.460]  что это просто система, когда совокупность называется. Поэтому первый случай у нас какой,
[02:45:19.460 --> 02:45:26.860]  когда A объединяется с B, а здесь C объединяется с D. Здесь у нас A объединилась с B, здесь C пересеклась с D.
[02:45:26.860 --> 02:45:46.180]  B, C, A, B, D без C, A без B, C и D. Поехали. Все. Теперь наша задача будет заключаться в чем?
[02:45:46.180 --> 02:45:52.500]  Что равенство у нас выполнено тогда и только тогда, когда обе стороны вложены друг в друга.
[02:45:52.500 --> 02:46:02.860]  Все. И у нас есть дополнительные условия. Начинаем с этих вот условий. Давайте посмотрим.
[02:46:02.860 --> 02:46:09.500]  Если A вложено в B, то мы посмотрим, как можно простить A объединить с B, а пересечь с B.
[02:46:09.500 --> 02:46:24.060]  Что такое A пересечь с B, если A вложено в B? В B просто. Пересечь? А, нет, пересечь, наоборот,
[02:46:24.060 --> 02:46:29.740]  А. Да, здесь будет B. Все. По сути, да, мы таким образом можем выкинуть вообще задаром одну
[02:46:29.740 --> 02:46:36.700]  переменную. Смотрим, A вложено в B. Это у нас упростится в A, это у нас упростится в B,
[02:46:36.700 --> 02:46:46.780]  это у нас упростится в A. А что такое, если A вложено в B, а без B? Пустое множество. Да. А пустое
[02:46:46.780 --> 02:46:52.060]  множество до карты на что-то, это пустое множество. Поэтому, по сути, в данном случае мы сбавляемся от
[02:46:52.060 --> 02:47:03.540]  третьего условия. Поехали, смотрим. Есть ли у нас вложение с права налево? Вот здесь вот A,
[02:47:03.540 --> 02:47:18.580]  а здесь C или D. Давайте посмотрим, что если мы лежим в C или D, то есть два варианта. Мы можем
[02:47:18.580 --> 02:47:30.460]  лежать в D без C, тогда мы войдем сюда. Но у нас есть свойство, что C или D, это D без C,
[02:47:30.460 --> 02:47:41.980]  объединить с C. Либо второй вариант у нас, тогда мы попадем в C, то есть у нас второй элемент будет
[02:47:41.980 --> 02:47:53.140]  лежать в C. Но если мы лежим в C, а A вложено в B, то эти пары содержатся здесь. Хорошо. То есть все пары
[02:47:53.140 --> 02:48:01.060]  отсюда, они будут лежать в правом множестве. Смотрим второй случай. A или B? Это B. Точнее,
[02:48:01.060 --> 02:48:07.940]  вот B и C и D. Но если эти пары из пересечения C и D, то они точно лежат в C, а значит они будут
[02:48:07.940 --> 02:48:15.380]  вложены у тебя. То есть множество слева, оно содержится в множестве справа. Смотрим в обратную
[02:48:15.380 --> 02:48:24.900]  сторону, что творится. В обратную сторону у нас творится следующее. Вот здесь вот A и D без C.
[02:48:24.900 --> 02:48:31.700]  Ну да, вот здесь мы тривиально вложились. Все. Теперь нам нужно вложить второе множество.
[02:48:31.700 --> 02:48:43.780]  А второе множество, если мы возьмем элемент B и C, такое, что если это будет B без A, это первое,
[02:48:43.780 --> 02:48:51.940]  а второе будет C без D, то что? B без A, значит, единственное, где оно может держаться,
[02:48:51.940 --> 02:48:59.180]  это вот только тут. Тут его точно не будет. Но здесь C пересечение с D, а мы взяли то,
[02:48:59.180 --> 02:49:05.780]  что не лежит в этом пересечение. Значит, у нас здесь не гарантируется выполнение. Есть какое-то
[02:49:05.780 --> 02:49:15.980]  множество, которое лежит справа, но не лежит слева. Все. Плохо. Смотрим второй случай. Да,
[02:49:15.980 --> 02:49:26.500]  еще сразу скажу, что могло показаться так, что у нас есть вот 4 условия, даже так 12 штук,
[02:49:26.500 --> 02:49:37.620]  и нужно будет проверять все 12. Ну, конечно же, нет. Нам нужно проверить первые 4. Как нам,
[02:49:37.620 --> 02:49:47.460]  зная первые 4, ответить на вот последние 4? Сейчас мы рассматриваем без каких-то дополнительных
[02:49:47.460 --> 02:49:53.900]  условий на второе множество. Мы рассматриваем в общем случае. Соответственно, если это будет
[02:49:53.900 --> 02:50:05.020]  выполнено для того, что слева, то справа здесь... Сейчас. В общем, если мы докажем для, например,
[02:50:05.020 --> 02:50:11.620]  C и D, то везде, где здесь C вложено в D, для всех этих случаев это тоже будет выполнено. С другой
[02:50:11.620 --> 02:50:16.980]  же стороны, когда или, мы объединяем. Поэтому, если мы нашли контр-пример в каком-то здесь,
[02:50:16.980 --> 02:50:22.700]  мы сразу нашли контр-пример там, где есть это условие справа. Вот, например, сейчас,
[02:50:22.700 --> 02:50:30.860]  здесь мы нашли контр-пример, и здесь нашли мы контр-пример. Все. А у меня повисла демонстрация
[02:50:30.860 --> 02:50:46.100]  экрана, что ли? Либо у меня на таком повис. Все. Да, мы нашли вот два контр-примера, уже все.
[02:50:46.100 --> 02:50:53.500]  Пошли дальше. B вложено в A. Если B вложено в A, мы просто поменяем буковку B на буковку A. Здесь
[02:50:53.500 --> 02:51:04.860]  буковка B вложена в A. A без B. Ну, A без B это какое-то лорусто может быть. Поехали смотреть,
[02:51:04.860 --> 02:51:13.980]  что творится. Здесь B, C или D. Первый случай это лежит C. Тогда мы здесь оказались. Второй случай
[02:51:13.980 --> 02:51:25.260]  это C или D. Это C, а второй случай это D без C. Мы оказались здесь. Все. Мы вложили первые пары.
[02:51:25.260 --> 02:51:40.460]  Вторые пары A или B. Это C и D. Так как вот у нас устроено A, внутри него B. У нас первый случай это,
[02:51:40.460 --> 02:51:47.400]  что A без B, тогда пара тут тривиально выполнена. Второй случай это будет лорусто B содержать,
[02:51:47.400 --> 02:51:56.220]  пары C, D. Но они будут вложены туда. Все. Получили вложение с левого направо. В обратную сторону
[02:51:56.220 --> 02:52:06.780]  смотрим. B, C войдет сюда. Здесь это сюда. A без B войдет сюда. Справа-налево вообще просто.
[02:52:06.780 --> 02:52:11.340]  Поэтому здесь плюс. А если здесь плюс, то у нас плюс здесь-здесь.
[02:52:11.340 --> 02:52:31.540]  Да, все хорошо пока. Дальше смотрим. C вложено в D. Для этого стираем все эти записи. C вложено в D.
[02:52:31.540 --> 02:52:38.580]  Тогда объединение это D, пересечение это C. D без C. Это что-то имеющее смысл? Это C.
[02:52:38.580 --> 02:52:48.660]  О, смотрите. Здесь B, а здесь A без B. И здесь C. То есть здесь A или B и C. Вот как раз точно все то,
[02:52:48.660 --> 02:52:55.820]  что нам нужно. Но здесь B, а здесь D без C. Поэтому надеюсь, что это вошло. Получили вложение
[02:52:55.820 --> 02:53:03.060]  вот справа-налево. Смотрим в обратную сторону. В обратную сторону у нас пересечение. У нас
[02:53:03.060 --> 02:53:17.660]  пересечение. Пересечение это может быть D. Объединение это D. Вот D есть C. Это может
[02:53:17.660 --> 02:53:26.300]  быть D без C. Тогда мы войдем вот сюда. А в другом случае это может быть само C. Но это же под множество
[02:53:26.300 --> 02:53:38.500]  B. Значит они войдут вот сюда. Все. Это первая часть будет вложена вправо. Второе условие A или B и C.
[02:53:38.500 --> 02:53:50.540]  Но опять же два варианта. Это либо A без B, либо B. Вот так вот разбилось у нас. Поэтому в другую
[02:53:50.540 --> 02:53:58.740]  сторону тоже есть вложение, значит есть равенство. C и D. Тогда там, где оба выполнены, их или тоже
[02:53:58.740 --> 02:54:10.540]  будет выполнено. B вложено A, C вложено в D. Супер. Хорошо. И последний случай, который нам осталось
[02:54:10.540 --> 02:54:21.380]  рассмотреть. Это D вложено в C. D вложено в C, значит здесь C, здесь D. D вложено в C. Я избавлюсь
[02:54:21.580 --> 02:54:33.860]  условия. Смотрим. Слева направо. A пересечь с B в C. Вот оно войдет сюда. Потому что это под множество
[02:54:33.860 --> 02:54:48.500]  B. A или B и D. Есть два варианта. Либо это A без B, оно войдет сюда. Либо это B. Но так как D это
[02:54:48.500 --> 02:54:56.340]  под множество C, то оно войдет вот сюда. Все. Левые пары есть в правом множестве. В обратную сторону
[02:54:56.340 --> 02:55:05.500]  смотрим. A без B, D вот сюда. Войдет легко, потому что под множество пересечения этого условия нет.
[02:55:05.500 --> 02:55:13.180]  Осталось условие B без C. Хорошо. У нас C более мощный, поэтому если возьмем C без D, то сюда
[02:55:13.180 --> 02:55:21.020]  пары эти не уйдут. Они могут войти только сюда. Но здесь B пересечь с A. Давайте снова возьмем вот
[02:55:21.020 --> 02:55:26.380]  это вот множество. И оказывается, что здесь вот оно присутствует, а здесь его нет. Поэтому нету и,
[02:55:26.380 --> 02:55:38.620]  соответственно, здесь это вот так. Все. Не могли бы еще раз пробоиться, объяснить почему оно не вножено?
[02:55:38.620 --> 02:55:50.580]  Давай рассмотрим вот под множество вот этих вот пар, а именно которые слева у нас это B без A,
[02:55:50.580 --> 02:56:02.500]  а справа C без D. Первое B без R, а значит они не могут войти вот сюда. Значит единственное,
[02:56:02.500 --> 02:56:09.180]  куда они могут войти, это сюда. Но с другой стороны у нас здесь D, а здесь мы специально исключили D,
[02:56:09.180 --> 02:56:14.860]  поэтому здесь содержаться не может. Значит место им слева нигде они нашлись, они не могли ниоткуда
[02:56:14.860 --> 02:56:25.860]  прийти. Поэтому они будут здесь, вот здесь. Все. Ну можно было заметить, что потратили мы на
[02:56:25.860 --> 02:56:37.100]  решение этого добра минут 15. Можно вопрос, почему в втором столбце в последней строчке у нас минус?
[02:56:37.100 --> 02:56:44.540]  Потому что соли.
[02:56:55.860 --> 02:57:06.060]  То есть или у нас когда оба условия выполняются, а и хотя бы одна. Да, потому что или оно расширяет
[02:57:06.060 --> 02:57:15.580]  класс этих множеств, и соответственно теперь нам нужно будет, сейчас скажу, или это по сути
[02:57:15.580 --> 02:57:22.100]  расширяет это объединение. Если у нас есть контр-пример в каком-то из частей, то контр-пример
[02:57:22.100 --> 02:57:30.620]  найдется везде. А и это значит что? Это мы возьмем какое-то под множество, но если во всем множестве
[02:57:30.620 --> 02:57:36.220]  выполнено, значит взяв его какое-то под множество, а и это пересечение, то есть под множество, то для него
[02:57:36.220 --> 02:57:44.860]  тоже будет выполнено. Поэтому надо достаточно проверить только левую. А теперь рассказываю метод,
[02:57:44.860 --> 02:57:53.140]  который решает это за две секунды. Отчасти мы его использовали, когда говорили, но только мы его
[02:57:53.140 --> 02:58:01.100]  использовали не особо рационально. У нас есть замечательные свойства. Сейчас скажу. Давайте даже
[02:58:01.100 --> 02:58:07.980]  так. Метод называется разбиение на, так скажем, атомарные кусочки неделимые. Вот мы не можем
[02:58:07.980 --> 02:58:16.020]  больше потерять. Какие у нас есть неделимые? Давайте рассмотрим это множество. У нас неделимых кусочков...
[02:58:16.020 --> 02:58:27.420]  Ладно, бог с ним. У нас есть из неделимых кусочков, у нас есть А без В, у нас есть А пересечение с В,
[02:58:27.420 --> 02:58:38.460]  есть В без А. Тогда если мы сделаем, воспользуемся еще одним свойством, что объединение В до картового
[02:58:38.460 --> 02:58:47.220]  С есть А до картового С, объединить В до картового С, то если мы возьмем, разобьем каждую из частей
[02:58:47.220 --> 02:58:53.340]  здесь, на вот эти вот атомарные кусочки, дальше воспользуемся вот этим вот свойством, называем
[02:58:53.340 --> 02:59:02.420]  дистрибутивностью, то мы расплодим количество систем, но при этом у нас появится много перекрытий,
[02:59:02.420 --> 02:59:08.260]  которые есть и там, и там, и мы их сразу отметем. И за счет этого у нас останется проверять куда
[02:59:08.260 --> 02:59:16.380]  меньше. Причем сейчас настолько меньше, что удивитесь. Поехали. Давайте разбивать лево.
[02:59:16.380 --> 02:59:27.540]  Нам нужно учиться разбивать объединение на атомарные. Вот, что такое объединение? Вот мы
[02:59:27.540 --> 02:59:46.340]  разбили объединение на атомарные кусочки. То есть левая часть нам подарит что? А пересечет
[02:59:46.340 --> 02:59:59.980]  с Б здесь С без Д, А пересечет с Б здесь С и Д, А пересечет с Б с Д без С. Дальше и аналогичный
[02:59:59.980 --> 03:00:18.060]  триггер А, Б. Бум. А без Б, А пересечет с Б, Б без А, здесь С, Д, С, Д, С, Д. Что бы было удобнее читать,
[03:00:18.060 --> 03:00:24.300]  везде, где разности, у нас порядок не важен, поэтому давайте писать там по алфавиту. Налично
[03:00:24.660 --> 03:00:38.060]  У нас Б и С. Уф. Б и С неприятные. У нас будет Б без С, Б, С. Я извиняюсь. Б без А,
[03:00:38.060 --> 03:00:58.180]  А, Б. Здесь будет С без Д, С, Д. Дальше Б без А, А без А пересечь, здесь С пересечь, здесь С убрать. Дальше, а остальные два
[03:00:58.180 --> 03:01:17.940]  условия они так уже атомарны. А и Б. Д без С. А симметрическая разность. Ой, просто разность. И С и Д.
[03:01:17.940 --> 03:01:26.980]  Все. Мы расписали теперь все в элементарных кусочках, все возможные пары. Теперь давайте
[03:01:26.980 --> 03:01:33.580]  зачеркивать все эти пары, которые есть и там, и там. Вот, например, у меня есть пересечение, вот двойное.
[03:01:33.580 --> 03:01:44.980]  Ой, у меня даже здесь два таких. Теперь у меня А пересечь Б есть и С пересечь, и С без Д. Зачеркну.
[03:01:44.980 --> 03:02:04.260]  А пересечь Б, Д без С. Вот у меня есть. А без Б, С пересечь Д. Жух-жух. Б без А объединение этого добра.
[03:02:04.260 --> 03:02:19.780]  Вот, смотрите, что мы заметили. Мы заметили так, что вообще лево вложено вправо. И единственное
[03:02:19.780 --> 03:02:28.420]  отличие этих множеств, вот вот это вот плохом кусочке элементарном, атомарном, давайте назвать
[03:02:28.420 --> 03:02:34.860]  элементарным, чтобы нам потом не было проблем. Вот этот кусочек. И теперь, когда он у нас будет
[03:02:34.860 --> 03:02:41.500]  тождественно наравны, когда этот кусочек обратится в ноль, а в какие моменты он обратится в ноль,
[03:02:41.500 --> 03:02:47.180]  когда одна из частей их будет пустым множеством, а чтобы она стала пустым множеством, она нужна
[03:02:47.180 --> 03:02:57.980]  либо чтобы было Б под множеством А, либо С под множеством Д. Всё. На этом моменте мы решили
[03:02:57.980 --> 03:03:03.220]  задачу. Дальше просто осталось выбрать условия, где хотя бы одно из этих условий присутствует.
[03:03:03.220 --> 03:03:25.300]  Слева выписан А без Б. Слева не может быть такого множества.
[03:03:25.300 --> 03:03:35.860]  Слева не может быть такого множества. И кстати, то множество, которое мы вот заметили,
[03:03:35.860 --> 03:03:42.500]  контрпример, неспроста вот мы его постоянно его встречали, когда проверяли. Вот оно сплю.
[03:03:42.500 --> 03:03:52.480]  Поэтому, во-первых, когда у вас такие ужасные квадратные, эти, декартовые произведения имеют
[03:03:52.480 --> 03:03:57.920]  смысл расписать вот эти элементарные кусочки. И дальше что мы делать? Дальше смотреть,
[03:03:57.920 --> 03:04:08.080]  вычеркнуть общие и смотреть, когда вот те или иные обращаются в ноль. Или когда они оба равны.
[03:04:08.080 --> 03:04:18.800]  Ой, когда они оба присутствуют. Так что, на этом… А можно ли ещё раз как неделимые части разбили?
[03:04:18.800 --> 03:04:29.800]  А, рассказывай. В общем, откуда вообще берутся неделимые вот эти тамарные части? Вспомним,
[03:04:29.800 --> 03:04:34.920]  что мы когда здесь делали. Мы вот эти вот частички, по сути, задавали так или иначе,
[03:04:34.920 --> 03:04:48.080]  стартаной болевой таблицы. Так вот, здесь корни все те же. То есть, мы берём, выделяем кусочки,
[03:04:48.080 --> 03:04:57.720]  вот с диаграммы L равенны, например. Мы можем выделить, сколько? Два в степени N, где N количество
[03:04:57.720 --> 03:05:04.680]  множество этих тамарных кусочков. Дальше у нас есть теоретика множественной операции. Объединение
[03:05:04.680 --> 03:05:14.120]  пересечения разности. Разность, она нам даст уже элементарный кусочек. Пересечение тоже. А вот
[03:05:14.120 --> 03:05:25.000]  объединение само по себе состоит из трёх таких кусочков. Вот. Равно как множество, например,
[03:05:25.000 --> 03:05:37.440]  A это A без B, объединить с A пересечь с B. Вот элементарные кусочки. Теперь мы берём вот это всё
[03:05:37.440 --> 03:05:45.360]  добро, записываем вместо самих множеств. А дальше мы используем просто правила дистрибутивности,
[03:05:45.360 --> 03:06:00.960]  которая гласит, что A объединить с B до карты A на C, есть A объединить с B до карты A на C. То есть,
[03:06:00.960 --> 03:06:09.680]  мы теперь вот это объединение взяли, раскрыли и получили просто дополнительных строчек в нашей
[03:06:09.680 --> 03:06:18.160]  системе. Здесь у меня было пересечение элементарных кусочек, справа будет 3 элементарных. Ну вот я
[03:06:18.160 --> 03:06:26.320]  записал их все 3. Пересечь с одной разностью, с другой разностью, с пересечением. Аналогично
[03:06:26.320 --> 03:06:36.120]  и с точностью до наоборот случись с C и D. Всё. Получил ли я вытаблицу? Справа у меня были B. B это
[03:06:36.120 --> 03:06:47.600]  объединение B без A и пересечение B и A. Вот оно. C это объединение пересечения C и D и C без D.
[03:06:47.600 --> 03:06:54.160]  Получается тут два варианта, тут два варианта. 2 на 2 равно 4. Соответственно, беру сервионную
[03:06:54.160 --> 03:07:03.520]  сложность и совпособно комбинирую. Получил вот 4 комбинации. И осталось ещё два условия, но эти
[03:07:03.520 --> 03:07:11.920]  кусочки уже сами по себе отомарны, поэтому их просто дописал. А дальше, ну, только вычёркивание
[03:07:11.920 --> 03:07:21.480]  одинаковых кусочков. Всё. Скажите, пожалуйста, как ещё раз называется тундром? А, это называется полином
[03:07:21.480 --> 03:07:40.040]  шигалкера. Это значит будет на следующей лекции по мат-логике. Это буквально общая тема,
[03:07:40.040 --> 03:07:46.880]  которая только-только. Можно последний раз по какому принципу вычёркивали эти отомарные кусочки?
[03:07:46.880 --> 03:07:51.760]  Я вычёркивал, которые есть и справа, и слева. Вот прям можем ещё раз повторить.
[03:07:51.760 --> 03:08:10.800]  Просто это нормально, что они с разными кусочками в парах стоят? Они же из декартового произведения
[03:08:10.800 --> 03:08:17.880]  образуются с разными кусками. Я что-то не понимаю. Ну, смотри, у нас отомарный кусочек будет тогда,
[03:08:17.880 --> 03:08:24.600]  когда обе части отомарны. Ну, вот мы понособирали отомарные кусочки друг на друга из двух ножей.
[03:08:24.600 --> 03:08:31.840]  Перекомбинировали. Где-то мы раскрывали только одну часть, где-то мы обе части раскрывали.
[03:08:31.840 --> 03:08:49.800]  Можно ещё раз показать в таблице снизу, где развернута A или B, точнее C и D. Слева у нас
[03:08:49.800 --> 03:08:57.520]  было уже отомарный A пересечь с B. Объединение это три кусочка, поэтому я беру их сюда
[03:08:57.520 --> 03:09:07.400]  просто раз-два-три. Три дубли. Супер. После того, как я вот всё разбил на элементарные кусочки,
[03:09:07.400 --> 03:09:12.400]  я беру и вычёркиваю те, которые есть слева и справа, потому что они всегда есть и там, и там,
[03:09:12.400 --> 03:09:22.360]  они всегда... На этих кусочках эти множества всегда совпадают тому, что есть тождественность,
[03:09:22.360 --> 03:09:30.840]  поэтому они на решение задачи не влияют. Вот у меня есть здесь пересечение обоих и здесь. Дальше
[03:09:30.840 --> 03:09:39.520]  у меня есть слева, например, A пересечь B, C без D. Вот это вот всё я убрал. Они есть там и там,
[03:09:39.520 --> 03:09:48.760]  они не влияют на хоть решение. У меня есть пересечение A и B и D без C. Убрал. Есть A без B,
[03:09:48.760 --> 03:09:57.880]  пересечение. Убрал. B без A и пересечение. Убрал. Всё. Слева я все кусочки убрал,
[03:09:57.880 --> 03:10:07.000]  значит, левое множество всегда свяжется с правым. Когда у нас правое множество будет совпадать
[03:10:07.000 --> 03:10:12.480]  с левым? Когда вот из вишек будет пустым? Соответственно, данное множество будет пустым,
[03:10:12.480 --> 03:10:20.520]  когда вот B под множеством A или C под множеством D. Хотя бы одно из этих совех есть. Всё. На этом
[03:10:20.520 --> 03:10:30.040]  задача решилась. В целом теперь просто у кого вопрос есть задавайте. Извините, а на матлоге
[03:10:30.040 --> 03:10:39.880]  будет три задачи? Да. А вот четвертая и пятая в листочке это что? Это домашка. Какая будет
[03:10:39.880 --> 03:10:51.000]  домашка? Она будет очень похожа на те, которые написаны здесь. А где можно найти? Это кидали
[03:10:51.000 --> 03:10:59.800]  в чате телеграмма. Там будет ссылочка. Вот последняя, которая там была. Тренировочные варианты
[03:10:59.800 --> 03:11:11.080]  контрольным по КТЧ. Просто первая открывайте, вот она есть. Ну, то есть, а домашку надо будет потом
[03:11:11.080 --> 03:11:17.880]  в письменном виде сдавать? Да, самому семинаристу. Но это лучше у него точно. Может быть,
[03:11:17.880 --> 03:11:32.560]  усну придётся, если особо не повезло. Всё, давайте тогда вопрос ещё есть.
[03:11:32.560 --> 03:11:49.280]  Ну, если нет, тогда всё. Домашка постиконтрольная получается? Создавать постиконтрольный или на
[03:11:49.280 --> 03:11:56.040]  следующем семинаре эту домашку сдать? Нет. Смотрите, вот это то, что домашку тут написали,
[03:11:56.040 --> 03:12:02.680]  это не та домашка, которая у вас будет. У вас будет немножко другая домашка. По постиконтрольной
[03:12:02.680 --> 03:12:09.760]  будет. Да, там вышли вздоровочные файлы с домашкой, скажут когда дедлайн, вот это вот всё. Всё,
[03:12:09.760 --> 03:12:22.600]  понял. Пока домашкинка нет. Это просто примерный вид домашки. Какой будет реальный? Он будет не
[03:12:22.600 --> 03:12:29.440]  перестекаться с отой вообще. Там, ну, либо рассказывать, как решать домашку. Какие-то
[03:12:29.440 --> 03:12:34.880]  здесь методы, но я не смогу сказать, какие здесь есть методы. Там, где есть, я постараюсь рассказать.
[03:12:34.880 --> 03:12:43.360]  Тут метод пристану взглядом. Скажите про пленок Жигалкина. Мы когда строим эту таблицу
[03:12:43.360 --> 03:12:53.440]  естественности, нам важно в каком порядке мы записываем 0 единицы для каждого элемента?
[03:12:53.440 --> 03:13:02.120]  Смотри, у нас вот мы получили таблицу естественности. Таблица естественности,
[03:13:02.120 --> 03:13:09.040]  понятно как получается, она единственным образом может построить. Да. Всё. А дальше,
[03:13:09.160 --> 03:13:16.640]  вот тебя есть столбец. Вот возьми этот столбец, транспонируй и получишь строку. Берёшь,
[03:13:16.640 --> 03:13:22.800]  прям пишешь 0, 0, 0, 0, вот прям по очереди писаешь. Вроде транспонирование вам уже
[03:13:22.800 --> 03:13:34.840]  должно было рассказать. Да. Супер. Просто я не очень понимаю, вот я пыталась построить для
[03:13:34.840 --> 03:13:43.760]  обычного объединения, и у меня не получается, если, ну, то есть... Давай построим сейчас. У нас
[03:13:43.760 --> 03:13:52.680]  объединение 0, 0, 0, 1, 1, 0 или 0, 1. Объединение будет иметь вот такую таблицу естественности. Тогда
[03:13:52.680 --> 03:13:59.880]  что мы делаем? Мы транспонируем строку значений функции, столбец получаем, строку, вот такую вот.
[03:13:59.880 --> 03:14:09.760]  Теперь мы дырём соседние к сорям и получаем новую строку. 0 к сору 1 это 1, здесь одинаково,
[03:14:09.760 --> 03:14:17.240]  поэтому 0, 0. Аналогично повторяем ещё раз, 1, 0, 0, получаем 1. Всё. Получили треугольниче.
[03:14:17.240 --> 03:14:27.400]  Дальше, теперь смотрим какие здесь у нас... А и Б. Какие здесь у нас будут одна члены. 1,
[03:14:27.400 --> 03:14:34.000]  это здесь единичка написана, поэтому это и Б, здесь единичка это А, здесь единичка, поэтому это и Б.
[03:14:34.000 --> 03:14:40.960]  То есть смысл, какие здесь будут многочлены? Везде, кроме строки 0, просто пишем все те буквы,
[03:14:40.960 --> 03:14:50.040]  до которых в данной строке есть единицы, там, где все нули, пишем единицу. Всё. Теперь просто
[03:14:50.040 --> 03:14:56.160]  берём, собираем к сорами. Да, но если мы, например, таблица естественности, сначала будем писать
[03:14:56.160 --> 03:15:04.160]  вот 1, 1, а, например, вот этот вариант, что у нас А и Б, 0, будет самым последним. А, я понял. Я вот в этом смысле.
[03:15:04.160 --> 03:15:11.200]  Всё. Нет, таблица естественности, она единственным образом пишется. Она пишется, что вот, по сути,
[03:15:11.200 --> 03:15:16.880]  у тебя начинается 0, 0, 0, а дальше ты начинаешь в двоичной системе прибавлять единицу, и только так.
[03:15:16.880 --> 03:15:24.480]  Понятно, спасибо. То есть это, ну, в информате, когда переводили, вот, из одной системы
[03:15:24.800 --> 03:15:32.640]  из десятичной в двоичную, четверичную, восьмиричную, шестнадцатиличную, вот, там ровно только так идут единицы.
[03:15:32.640 --> 03:15:43.280]  Если вам рассказывали про порядки, но вряд ли, у вас уже были порядки много, это еще нет?
[03:15:43.280 --> 03:15:51.120]  Нет. Тогда я не смогу рассказать, почему еще так.
[03:15:51.120 --> 03:15:58.560]  Просто считайте, что от нуля начнем прибавлять единицу бинарную.
[03:15:58.560 --> 03:16:15.160]  Еще удобный способ, как быстро писать таблицу истинности. В общем, у нас, там, скорее всего,
[03:16:15.160 --> 03:16:22.360]  у вас будет либо три, либо две переменные. Если у вас три переменные, четыре раза ноль, потом два раза ноль,
[03:16:22.360 --> 03:16:31.360]  потом две единицы, а потом просто один раз ноль, один раз единица. То есть каждый раз мы пишем два
[03:16:31.360 --> 03:16:37.800]  в степени n, где n количество от переменных сверху, от слева до края, и так вот их чередует.
[03:16:37.800 --> 03:16:40.120]  Так она заполняется быстро и легко.
[03:16:53.640 --> 03:16:59.440]  Можете пояснить, пожалуйста, почему в первой строке второго столбца минус, а не плюс.
[03:16:59.440 --> 03:17:14.400]  В второй строке... Сейчас, в первой строке второго столбца минус. Ну, смотри. Пример, когда...
[03:17:14.400 --> 03:17:35.800]  Пример, когда... Сейчас скажу. Смотри, или. Или подразумевает того, что эту
[03:17:35.800 --> 03:17:42.760]  условия может быть выполнена, может быть, не выполнена. Вот давай я сотру. Ну, или я хочу без или.
[03:17:42.760 --> 03:17:50.120]  Я возьму только такое множество. На нем мне не выполнено слева, поэтому здесь тоже будет не выполнено.
[03:17:50.120 --> 03:17:55.800]  То есть или говорит нам о том, что я могу добавить еще какие-то дополнительные пары,
[03:17:55.800 --> 03:18:01.560]  но старые-то останутся. Для старого у меня неверно, потому что есть вот такой вот...
[03:18:01.560 --> 03:18:16.040]  Контракт-пример. Вот почему неверно в втором столбце. Супер. Еще может быть какие-то вопросы.
[03:18:16.040 --> 03:18:35.320]  А что если попадет единица в XOR? А если попадет единица в XOR, то все будет плохо,
[03:18:35.320 --> 03:18:41.400]  потому что единица, как я говорил, это множество универсум. А нигде вам не дано использовать
[03:18:41.400 --> 03:18:51.720]  множество универсум. Поэтому ваши задачи будут записаны так. Ваши задачи будут таковы, что единица не
[03:18:51.720 --> 03:19:00.240]  попадется. Ну, то есть в худшем случае, если у вас попадается единица, значит у вас начинает
[03:19:00.240 --> 03:19:08.240]  быть закрашенным вот этот вот ужас. Вот такое попадание единицы. А если попался этот ужас,
[03:19:08.240 --> 03:19:14.000]  ну он как может быть получен? Он может быть получен только, если у вас есть отрицание,
[03:19:14.000 --> 03:19:24.960]  то есть дополнение операции без С. Операцию без С как делать на вот здесь? Это один XOR
[03:19:24.960 --> 03:19:31.080]  какой-то множестве. Это есть вот такая операция отрицания. Все. То есть если попала единица,
[03:19:31.080 --> 03:19:36.480]  то значит у вас есть дополнение, а значит, наверное, даже все еще проще будет, чем без него.
[03:19:36.480 --> 03:19:45.440]  Потому что без него, там, где мы делали, здесь мы, да, нам приходилось вот делать это отрицание
[03:19:45.440 --> 03:19:51.600]  импликации. Это как-то сворачивать не очень-то ядно, а там даже будет еще проще.
[03:19:51.600 --> 03:20:00.280]  А скажите тогда, пожалуйста, почему в полиноме Жиговского у нас ставится один,
[03:20:00.280 --> 03:20:04.120]  где OP переменная равна нулю? Зачем там единица? Почему не ноль?
[03:20:04.120 --> 03:20:13.520]  В полином Жигалкина. Почему там единица, а не ноль? Потому что ноль, XOR, что-либо,
[03:20:13.520 --> 03:20:21.120]  это есть что-либо. Это полином. Прям как мы начали, вот у тебя в числах, когда были вот
[03:20:21.120 --> 03:20:29.720]  многочлены какой-то степени, плюс ноль, ну ты просто получишь ноль. А здесь, поэтому,
[03:20:29.720 --> 03:20:38.560]  чтобы что-то добавить, ну только единицу можно. И это, если вот такой чистый рукомахательский
[03:20:38.560 --> 03:20:49.120]  способ. Почему так именно, точки зрения будевой логики, на это вас, на это лучше подождать лекции,
[03:20:49.120 --> 03:20:55.520]  там это все должно быть, либо это будет вообще вопрос Домашки. Не знаю, пока как в этом году будет.
[03:20:55.520 --> 03:21:07.080]  Возможно, это вам всем придется доказывать, почему там единица. Понятно, спасибо. По-моему,
[03:21:07.080 --> 03:21:18.920]  даже так и будет. Вопрос. Вот в последнем номере мы же вот нашли, что если у нас B это подможство A,
[03:21:18.920 --> 03:21:28.920]  то это пустое множество, ну B. И все хорошо, да. Да. Ну почему тогда, если вот в таблице нашей,
[03:21:28.920 --> 03:21:35.960]  там B принадлежит A или D, ну в смысле B это подможство A или D это подможство C,
[03:21:35.960 --> 03:21:42.680]  почему там минус? А давай рассмотрим тот случай, когда B не является подможством A,
[03:21:42.680 --> 03:21:48.480]  а D является подможством C. Тогда у нас это условие выполнено, но при этом у нас станет пусто.
[03:21:48.480 --> 03:22:00.440]  То есть прикол в том, что да, это то, что вы просто говорили. Да, как бы не казалось, что или должно
[03:22:00.440 --> 03:22:16.160]  наоборот все лучше, или наоборот все испортить, а и сохранить. Ну тогда давайте все, что ли.
[03:22:16.160 --> 03:22:31.160]  Да не за что. Записи я выложу туда, где решение прошлых лет. Всем спасибо, всем пока.
