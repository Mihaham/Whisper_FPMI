[00:00.000 --> 00:09.000]  Поэтому, как вы уже догадались, обсуждать сегодня будем метод четырёх русских. Да,
[00:09.000 --> 00:12.960]  но метод на самом деле решает несколько задач. Ну, то есть, конечно, классический пример,
[00:12.960 --> 00:17.440]  который у нас сегодня тоже будет, это, конечно, решение задачи стать икромку за линейный
[00:17.440 --> 00:22.320]  предподсчёт и единицу. Но сегодня выяснится, что метод, конечно, решает сильно больше.
[00:22.320 --> 00:32.240]  Ну, с чего бы нам начать? Давайте начнём с самой простой задачи. Заодно попробуем
[00:32.240 --> 00:41.880]  поиллюстрировать метод. Это, конечно, перемножение матриц. Давайте себе представим. Наверное,
[00:41.880 --> 00:50.160]  вам уже не надо объяснять, что такое перемножение матриц, правда? Или у вас этого не было? Ну,
[00:50.160 --> 00:57.040]  слава богу. А то мало ли. Так, давайте думать, за какую симпатику можно перемножить две матрицы.
[00:57.040 --> 01:18.560]  Ну, давайте для простоты квадратные. Ну, всякое бывает. Ну, стандарты, если есть перемножать
[01:18.560 --> 01:26.840]  матрицы прям в честную, то есть n куб. Да, ну, в общем случае, конечно, тут о чём можно думать. Ну,
[01:26.840 --> 01:31.460]  то хочется как-то побыстрее. Действительно, какие-то технологии есть. Вот, мы сейчас,
[01:31.460 --> 01:35.600]  конечно, будем обсуждать даже не самоэффективно, но действительно думаем, как бы это ускорить. Но мы
[01:35.600 --> 01:42.880]  обсудим, правда, такой подвид, как 0,1 матрица. Вот так скажем. Вот давайте себе представим,
[01:42.880 --> 01:52.560]  что матрицы состоят из 0,1. Вот. И попытаемся их перемножить. Ну, перемножать их будем честно,
[01:52.560 --> 01:57.560]  даже не булевым образом. Хотя, в принципе, в этом месте говорят, давайте перемножим булевые матрицы,
[01:57.560 --> 02:04.480]  но, кажется, показательнее будет, если мы перемножим эти матрицы всё-таки как числовые,
[02:04.480 --> 02:14.880]  хоть они из 0,1. Вот. Значит, за счёт чего мы попытаемся ускориться? Ускориться мы попытаемся за
[02:14.880 --> 02:21.640]  счёт следующего мистического заклинания, с которым мы будем начинать всё. Заклинание называется
[02:21.640 --> 02:33.520]  зафиксируем к, который выберем позже. Вот. Ну, то есть, что это означает? Ну, то есть, ничего страшного
[02:33.520 --> 02:37.800]  на самом деле это не означает. То есть, это означает, что у нас алгоритм будет зависеть не только от n,
[02:37.800 --> 02:42.880]  но и от какого-то параметра k. А потом мы посчитаем 8-точку в зависимости от k и подгоним
[02:42.880 --> 02:55.680]  k таким образом, чтобы синтоника была поменьше. Вот. Значит, в чём смысл этого k? А смысл вот в чём.
[02:55.680 --> 03:01.280]  Вот, на самом деле, смотрите, если бы мы перемножали, допустим, булевые матрицы,
[03:01.280 --> 03:06.240]  вот представьте, что мы перемножали булевые матрицы по булевому. То есть, что означает
[03:06.240 --> 03:13.480]  перемножать по булевому? То есть, это означает, что перемножение это типа конъюнкция, а сложение это
[03:13.480 --> 03:22.560]  типа дезюнкция. Вот. Тогда замечается маленькая интересная вещь. Мы могли бы условно перемножать на,
[03:22.560 --> 03:29.840]  то есть, как бы там, скажем так, ряд на столбец мы могли бы перемножать не за n, а за что-то типа n
[03:29.840 --> 03:37.560]  на 32, правда? Ну была бы у нас теоретически такая идея. Правда, мы бы это делали за счёт того,
[03:37.560 --> 03:43.360]  что у нас в компьютере есть мистические какие-то там булевые операции, которые на 32 бита работают
[03:43.360 --> 03:54.560]  там за единицу. Вот. Конечно, сейчас у нас такой операции нет. Вот. Но мы можем сделать следующим
[03:54.560 --> 04:05.600]  образом. Мы будем говорить так. А давайте попробуем научиться перемножать ряд длины k на столбец
[04:05.600 --> 04:17.000]  размера k за от единицы. Ну, то есть, нацеливаясь, конечно же, на то, что в итоге перемножать матрицы,
[04:17.000 --> 04:24.560]  но там перемножать матрицы мы будем за, за сколько мы там их будем перемножать, за, получается,
[04:24.560 --> 04:38.840]  n в кубе делить на k. Вот на такое мы будем нацеливаться. Как же мы это будем делать? Как научиться
[04:38.840 --> 04:51.480]  перемножать любые два, так сказать, вектора размера k скалярда? Неожиданно просто. Дело в том,
[04:51.480 --> 04:59.520]  что метод заключается в чём? Мы выберем такое k, что на самом деле векторов размера k будет не
[04:59.520 --> 05:11.240]  слишком много. А сколько у нас всего векторов размера k, кстати? Да, два степени k. А пар векторов,
[05:11.240 --> 05:19.880]  соответственно, два степени 2k. Ну да. Ну, мы будем записывать два степени 2k. Впрочем, можно и так,
[05:19.880 --> 05:27.680]  и так. И действительно, то есть у нас, причём будет у нас такая наглая идея. Давайте переберём все
[05:27.680 --> 05:40.200]  возможные пары векторов, прям вот предельно честно, за два в степени 2k. Каждую из них за k честно
[05:40.200 --> 05:55.760]  перемножим и сохраним в таблицу. Вот, и сохраним в таблицу. Вот. Тогда после этого мы делаем вот,
[05:55.760 --> 06:00.600]  то есть после того, как мы всё это перебрали и сохранили, остаётся только теперь действительно
[06:00.600 --> 06:11.800]  выполнить честное перемножение и, собственно, всё. То есть теперь уже мы просто берём, получается,
[06:11.800 --> 06:21.040]  каждую строчку делим на блоки по k. Вот, прям честно по k. То есть каждый столбец делим как-то
[06:21.040 --> 06:26.920]  вот пока. И, соответственно, теперь каждый блок размера k, ну там, конечно, мы и по каждому,
[06:26.920 --> 06:31.320]  предварительно по каждому блоку мы, конечно, должны пробежаться и там получить его порядковый
[06:31.320 --> 06:36.720]  номер. Ну, то есть эту битовую маску записать, по сути. Вот. И после этого оказывается, что вот
[06:36.720 --> 06:42.560]  любые два блока размера k мы теперь скалярно перемножаем за единицу, просто залезая в табличное
[06:42.560 --> 06:55.200]  значение. Так что вот такой алгоритм. А теперь остаётся такой, внимание, вопрос. Так какое же k нам
[06:55.200 --> 07:05.080]  выбрать? Чего? Вот. Ну да. Да. То есть стандартный метод такой. Да. То есть я мог бы просто сказать,
[07:05.080 --> 07:13.480]  давайте подсунем k равно, я не знаю, корень третьей степени из n, и вот вам алгоритм. Но я не скажу.
[07:13.480 --> 07:21.160]  Нет, ну я намеренно сказал заведомо неправильный ответ. Вот. Но давайте подумаем. Вместо этого
[07:21.160 --> 07:25.600]  давайте попробуем повыжимать. То есть подумать, какую максимальную асимптотику мы отсюда можем
[07:25.600 --> 07:31.040]  выжить. Но, опять, заметим, что у нас есть две составляющие, одна из которых возрастает,
[07:31.040 --> 07:38.520]  а другая убывает. Но мы знаем, что если у нас в асимптотике сумма, то это то же самое,
[07:38.520 --> 07:43.520]  что максимум. То есть такое упражнение на один балл могло бы быть. Докажите,
[07:43.520 --> 07:54.920]  что там f плюс g равно θ от максимума f и g. Звучит как заклинание, но если вдуматься,
[07:54.920 --> 08:01.520]  ничего страшного там нет. Вот. И тогда теперь получается нам надо, чтобы максимум этой штуки
[08:01.520 --> 08:08.640]  был как можно меньше. Так, ну тогда смотрите, как же искать этот максимум. Ну тогда и видим,
[08:08.640 --> 08:15.200]  что поначалу у нас одно убывающее слагаемое больше, потом они пересекаются, после этого вот это там
[08:15.200 --> 08:22.320]  уже, наоборот, возрастающее слагаемое начинает выигрывать. Это дает нам возможность найти
[08:22.320 --> 08:30.520]  оптимальное k бинпоиском. Ну примерно. То есть мы, например, ищем асимптотические. То есть, конечно,
[08:30.520 --> 08:36.840]  в идеале мы могли бы, конечно, написать два в степени 2k на k равно n куб делить на k, но с другой
[08:36.840 --> 08:43.960]  стороны, конечно, в радикалах это уравнение не уверен, что разрешимо. То есть там написать
[08:43.960 --> 08:49.080]  там что-то типа, что k равно, и написать прям адекватную формулу не получится. Ну может там
[08:49.080 --> 08:52.840]  ведется какая-нибудь там функция, какие-нибудь функции типа до ломбера или там что-нибудь еще в
[08:52.840 --> 08:58.520]  этом роде, но не будем этого делать, нам это в общем-то и не нужно. Но тем более, что даже из точки
[08:58.520 --> 09:03.440]  зрения практики на самом деле потом выяснится, что совсем такое точное k не надо, потому что тут же
[09:03.440 --> 09:08.840]  еще константы вообще есть по-хорошему, тогда тут какие-то там c1, c2 надо еще учесть, то есть там,
[09:08.840 --> 09:15.880]  но поэтому лучше сразу не заморачиваться. Ну вот, а теперь давайте думать, да, но теперь давайте,
[09:16.240 --> 09:22.840]  но к можно попытаться найти ното симпатически оптимально. Как же мы это будем делать? Ну давайте
[09:22.840 --> 09:27.840]  просто проверять, там что-то типа бинпоиска. Вот я, например, там что-то уже сказал про корень
[09:27.840 --> 09:36.400]  кубический из n? Ну давайте думать. Если я подставлю k равно корень кубический из n,
[09:36.400 --> 09:46.240]  что у меня получится? 2 в степени 2 корня кубических из n умножить на корень кубический из n плюс n в
[09:46.240 --> 09:56.920]  степени сколько там получается? 8 третьих. Так, что больше? Да, ну как-то, явно, наверное,
[09:56.920 --> 10:01.080]  левая слагаемость как-то многовато, потому что чтобы она претендовала на полиом, на полином,
[10:01.080 --> 10:06.040]  тут должно быть что-то логарифмическое, да, поэтому вот, то есть это значит, что это слагаемое,
[10:06.040 --> 10:15.760]  возрастающее слагаемое деминирует, поэтому пишем, что это много. Так, что можно было бы еще взять?
[10:15.760 --> 10:26.240]  Ну кто тоже себе-то предложил, давайте возьмем логарифм. Так, что же у нас будет в логарифме? Ну да,
[10:26.240 --> 10:37.040]  2 в степени 2 логарифма, как известно, это квадрат, то есть n квадрат лог n плюс n куб делить на лог n.
[10:37.040 --> 10:44.160]  И получается наоборот теперь, вот это слагаемое теперь деминирует,
[10:44.160 --> 11:01.160]  поэтому получается, что логарифм это мало. Да, но с другой стороны, оказывается, что принципиально
[11:01.160 --> 11:05.840]  лучше симпатически мы, тем не менее, не выжмем. Почему? Потому что если возьму 3 вторых лог n,
[11:05.840 --> 11:17.040]  то я получу n в кубе лог n. Ну ладно, там на 3 вторых и плюс там что-то типа 2 третьи n в кубе делить на лог n.
[11:17.040 --> 11:25.520]  То есть тут наоборот получается много. То есть получается оптимальная k, это где-то между логарифмом
[11:25.520 --> 11:33.080]  и полуторалогарифмами. То есть получается k надо брать просто θ от логарифма. Ну вот, если взять,
[11:33.080 --> 11:38.040]  скажем, логарифм, то у нас получается, ну то есть это означает, что это слагаемый уже всегда будет
[11:38.040 --> 11:44.880]  там n в кубе поделить на лог n. И причем там мы уже знаем, что ровно такую симпатику получить можно.
[11:44.880 --> 11:53.480]  Ну вывод очень простой, значит получается мы берем там k равно лог n и получаем симпатику
[11:53.480 --> 12:12.080]  θ от n в кубе поделить на лог n. Ну да. Нет, ну в принципе так оптимизировалось. Нет, ну понятно,
[12:12.080 --> 12:16.880]  не лучший вариант, то есть конечно не лучший вариант, через битмаски на самом деле было бы
[12:16.880 --> 12:25.560]  проще, там по n было бы дать. Понятно. Ну это, ну я вам так скажу, да. Я это рассказывал с целью того,
[12:25.560 --> 12:30.920]  что просто ввести в метод четырехрусских. Это не самое, конечно, яркое применение. Да, конкретно,
[12:30.920 --> 12:35.760]  что касается этой задачи, забирая вперед, да, что есть, конечно, существенно более быстрая симптотика
[12:35.760 --> 12:42.320]  и в общем случае. Потому что есть как минимум метод Штрассена, видимо, есть как минимум метод
[12:42.320 --> 12:52.160]  Штрассена, который работает за от n в степени там, сколько, лог 27. Ну там отдельная песня,
[12:52.160 --> 12:55.800]  я думаю, видимо, просто видимо на первом занятии следующего семестра, видимо,
[12:55.800 --> 13:25.800]  обсудим, ну собственно, откуда это берется. Аааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааааа
[13:25.800 --> 13:32.520]  ну нет ну как же задачи по математике да и сделайте за о малые да приват что там
[13:32.520 --> 13:37.480]  конца до константа жуткая да но это но это нормально да такое бывает шоу гритусы
[13:37.480 --> 13:42.440]  лукен быстрее алгоритма за энда бывает ну бывает вообще что алгоритмы да жили
[13:42.440 --> 13:48.240]  были алгоритмы с одной синтетикой но один но один заходит и другой нет ну да что
[13:48.240 --> 13:53.040]  делать за это даже что же здесь жить такая да как говорите если в жизнь была
[13:53.040 --> 13:58.920]  математика и называется был бы кайф конечно да вот но здоровься ладно хотя в конце концов
[13:58.920 --> 14:04.400]  можете хотя при спецпособках что взломать такую лойку потому что никто вас не обещал никто не
[14:04.400 --> 14:13.360]  требовал писать именно штраса на кстати вот этот подойдет это тоже умалая там в кубе если что
[14:13.360 --> 14:24.600]  так ну и да есть конечно проблем да только да это работает только нули единиц да но правда
[14:24.600 --> 14:29.200]  легко заметить в качестве упражнения что есть тут будут числа от нуля такой константы то в
[14:29.200 --> 14:38.280]  принципе тоже пойдет ну вот но в конце концов ладно чемпионские алгоритмы работают там по
[14:38.280 --> 14:51.080]  моему за оттен степени два точка если бы 20 нет там 2 3 там что-то да нет там нет но там это там
[14:51.080 --> 14:55.840]  что-то веселое на самом деле не помню точных цифр но там википедия в этом месте пишет веселые
[14:55.840 --> 15:01.360]  вещи она говорит что оптимальный алгоритм работает за энд степени там два точка три условно
[15:01.360 --> 15:07.600]  напишу 5 8 там примерно примерно суть такая это является улучшением метода капельсмита
[15:07.600 --> 15:17.480]  винограда который работает за энд степени два точка там 2 3 8 4 да вот но отдельная песня как
[15:17.480 --> 15:26.160]  то в общем не но я вообще не знаю там что там в этих методах то есть поэтому я никак не могу
[15:26.160 --> 15:30.920]  прокомментировать но вот на чемпионат идет вот такой так же в принципе можете поучаствовать
[15:30.920 --> 15:41.080]  то есть может у вас получится 2.229 тут сделать я не знаю да нет ну в конце концов знаете вон чем
[15:41.080 --> 15:49.800]  вот так надо не делить надо вон чтобы степень оптимизировался нет может вам
[15:49.800 --> 15:55.920]  удастся доказать что матрица нельзя перемножать быстрее чем за энд в степени 2.0001
[15:55.920 --> 16:04.200]  да если бы нет ну нет насколько мне известно насколько мне известно что
[16:04.200 --> 16:10.400]  вот пока так доказали понятно что перемножать матрицы можно только за мега тен квадрат все
[16:10.400 --> 16:24.960]  но как бы это это очевидно добрый день пока не пробовали вот так же в этом смысле так ладно
[16:24.960 --> 16:30.680]  но это перемножение матриц это отдельная песня но вот в конце концов там пулево перемножение
[16:30.680 --> 16:34.680]  более во перемножение матриц вообще там там вероятность еще алгоритмы есть на самом деле там
[16:34.680 --> 16:41.280]  как-то если она да если она если нам повезет то как бы у нас вообще в курсе возникнет просто
[16:41.280 --> 16:50.280]  такое пафосное словосочетание как свидетели пулева перемножение матриц вот будьте готовы вот да на
[16:50.280 --> 17:07.440]  полном серьезе так называется да вот на тип ну там но на самом деле да конечно метод
[17:07.440 --> 17:17.200]  давайте раскрывается немножко в других местах это но вот но это конечно великая задача про статик
[17:17.200 --> 17:28.640]  рэмку вот давайте вспомним вот у нас есть мистическая задача статик рэмку что это за задача то есть
[17:28.640 --> 17:36.800]  задача простая дан минимум по дан массив и спасает на произвольных чисел он не меняется сделайте
[17:36.800 --> 17:46.280]  какой-то предподсчет так чтобы потом на любом подотреске за достаточно быстро находить минимум
[17:46.280 --> 17:57.240]  вот понятная идея да понятная идея да спрашивается чего нас это приводит да
[17:57.840 --> 18:11.160]  сколько мы вообще-то умеем решать но у нас есть два способа в онлайне ну статик значит массив не
[18:11.160 --> 18:20.280]  меняется да массив не меняется только запросы те дают в онлайн то есть нет такого что я там
[18:20.640 --> 18:27.800]  данные заранее куча запросов может делать не все что хочешь да так конечно нет так конечно кстати
[18:27.800 --> 18:33.680]  вообще была бы мечта да то есть дан массив и да но куча запросов заранее можно ли как-то
[18:33.680 --> 18:54.800]  найти минимум побыстрее но да нет соте запросов по координате можно за линию потому что подсчет
[18:54.800 --> 19:15.160]  нет ну хорошо там там другое другое песня как бы еще тебе это даст скорее нет на самом деле так ладно
[19:15.160 --> 19:20.600]  если бы давайте так если бы у нас был снм на самом деле да то есть можно за обратную функцию керману
[19:20.600 --> 19:26.680]  потому что там можно там применять собственно стэк и в листику сжатия путей видимо это имеется
[19:26.680 --> 19:33.560]  в виду да но да то есть до по фада по факту до до практике наверно лучшего и желать нельзя но
[19:33.560 --> 19:39.360]  мы попробуем ладно но это конечно если значит такой снм мы пока не знаем да впервые может
[19:39.360 --> 19:42.800]  быть отчасти потому что может у нас есть мечта даже доказать что снм работать за какой-то
[19:42.800 --> 19:49.840]  асимптутику в чем какая-то там это не логарифум естественно хотя это тоже будет но вот но пока
[19:49.840 --> 19:56.480]  у нас значит если брать то что у нас было то у нас как бы есть n log n единица то есть там
[19:56.480 --> 20:05.160]  спарса спарсы построим за n log n после этого минимум ищете за единицы а есть дерево отрезков ну ну или
[20:05.160 --> 20:14.280]  там ну или там я не знаю это ваша любимая там овл вот ну или там что там не ваш короче что короче
[20:14.280 --> 20:22.280]  то что можно там насчитываете за от но зато минимум придется потом залогарифум искать вот
[20:22.280 --> 20:26.120]  но в принципе да то есть никто ни над кем не доминирует на самом деле то есть надо в зависимости
[20:26.120 --> 20:35.240]  от количества запросов выбирать вариант вот но мы попробуем конечно это победить то есть нам
[20:35.240 --> 20:44.200]  конечно хочется побыстрее ну в идеале да вот наша ставка то есть нам очень хочется убить лишний
[20:44.200 --> 20:53.800]  логарифм сделать чтобы это был n единица будьте здоровы вот но здесь конечно нам принот ну конечно
[20:53.800 --> 21:04.840]  классический метод требует от нас некоторые цепочки а именно то есть да то есть что что
[21:04.840 --> 21:10.680]  можно сделать но если кто-то до матрицы вектора были от нуля из нуля единиц то мы догадываемся
[21:10.680 --> 21:19.400]  что бы делали да ладно пока не догадываемся на неважно но мы пойдем другим путем мы просто
[21:19.560 --> 21:25.240]  так задачи римку там произвольные какие-то числа ой произвольные числа ой это очень сложно
[21:25.240 --> 21:37.240]  эти мы просто возьмем эту задачу не эту задачу возьмем и сведем ее к задаче л ца то есть раз
[21:37.240 --> 21:43.000]  скажем что мы сделаем мы сейчас то есть вместо того чтобы решать задачу римку мы тут потратим
[21:43.000 --> 21:53.700]  от времени и построим дерево и построим такое дерево в котором нот в котором нот в котором
[21:53.700 --> 22:01.480]  на самом деле если нам захочется искать минимум в массиве за там между лр то это свернуто то
[22:01.480 --> 22:08.640]  мы это сможем сделать просто найдя лца в этом дереве у правильно подобранных вершин ну пока
[22:08.640 --> 22:14.720]  говорю на уровне идеи хотя в прочем поднимите руки кто знает собственно каким образом это
[22:14.720 --> 22:25.400]  делается и редкий случай на самом деле что только две руки но хотя метод классический абсолютно вот
[22:25.400 --> 22:32.960]  и так так что теперь мы так что теперь значит у нас что получилось значит теперь получается нам
[22:32.960 --> 22:45.520]  просто нужно научиться решать задачу статик л ца за предподсчета вот единиц да но у нас уже
[22:45.520 --> 22:53.320]  есть эпическое сведение л ца к римку потому что мы можем запустить dfs там вот это выписать там
[22:53.320 --> 22:58.760]  все вот эти числа в общем выписывать когда мы идем вниз когда идем вверх да и потом там сводить вот
[22:58.760 --> 23:09.200]  вот да казалось бы зачем мы стали действительно зачем мы свели римку к римку ну вот да выглядит
[23:09.200 --> 23:17.640]  да как-то да как-то словосочетание да да появляется в голове словосочетание огромное количество
[23:17.640 --> 23:26.400]  словочетаний самым цензурным из которых является имитация бурной деятельности вот но если бы не
[23:26.400 --> 23:34.760]  одно но заметим что тут мы можем тут мы получим не любой массив а мы получим массив в котором
[23:34.760 --> 23:48.040]  любые два числа отличаются на единицу и может быть эту задачу мы сможем решить попроще но и
[23:48.040 --> 23:57.600]  действительно забирай вперед мы ее действительно сможем решить попроще ну как попроще да вот хотя
[23:57.600 --> 24:02.920]  ладно там ничего сложного не будет но как как мы уже с вами знаем у нас в курсе вообще сложных
[24:02.920 --> 24:16.480]  алгоритмов нету в принципе так что вот так что видимо да так что видимо да вопрос на отл называется
[24:16.480 --> 24:30.160]  докажите асимптотику и сыном снизу не просто нет просто вот докажите что ну скажете вот есть
[24:30.160 --> 24:36.320]  эсэнэм да можно доказать свеку что он работает там амортизировано за обратную функцию кермана так
[24:36.320 --> 24:41.800]  вот докажите что лучше оценить нельзя ну может там корень из обратной функции кермана мало ли
[24:41.800 --> 24:50.160]  а вот вот философский опрос там скажем так что-то там в истории были какие-то
[24:50.160 --> 24:53.400]  будет кто-то кто-то писал доказательства потом потом вроде там
[24:53.400 --> 25:23.360]  не но нет нет но это и цикла на практике там понятно что да это работает
[25:23.720 --> 25:30.320]  какой-то функция керма дако трепре адекватных данных не более чем 4 хотя ладно у нас будет
[25:30.320 --> 25:37.820]  а у нас будет еще более крутая функция которая про адекватных данных не более чем 2 вот нет
[25:37.820 --> 25:44.680]  просто 4 это если локзвездочка просто обратная функция керма на это еще более медленно растущая
[25:44.680 --> 25:50.600]  функция там вода 1 вот где-либо там просто разный просто там скажете я думаю крышак
[25:50.600 --> 25:56.120]  докажут докажут что-то про логзвездочка обычно если доказывают логзвездочка это типа сколько раз
[25:56.120 --> 26:04.960]  надо числа брать логарифом чтобы получилось меньше единиц вот по основанию двойки ну там
[26:04.960 --> 26:11.400]  но хотя это хотя это константа если двойку заменишь там на допустим я не знаю восьмерку то как бы
[26:11.400 --> 26:17.400]  этот лог звездочку увеличится в три раза так что не принципиально но вот то как бы если брать
[26:17.400 --> 26:21.920]  по двойке то действительно окажется что там не более чем четыре там будет доказательство не
[26:21.920 --> 26:27.200]  сложное но то есть обратно функция термана там и определение более сложное и собственно доказательство
[26:27.200 --> 26:33.240]  тоже вот но отдельная песня можно ли оценить это еще лучше но вот на практике конечно понятно что
[26:33.240 --> 26:38.240]  когда функция не превосходит каких-нибудь там четыре или два то уже не принципиально но но
[26:38.240 --> 26:45.840]  интересно же и а то когда-нибудь да совсем совсем совсем совсем когда-нибудь может быть
[26:45.840 --> 26:52.680]  там совсем да совсем в другой жизни даже это в другой цепочке другой цепочке
[26:52.680 --> 26:58.760]  да ну да да это уже много нужно оптимизировать
[26:58.760 --> 27:06.240]  почему корень 30
[27:06.240 --> 27:20.680]  она ну так ладно все понял что наврал-наврал-наврал хорошо но вот но правда по-моему по-моему
[27:20.680 --> 27:27.960]  принципиально суть от этого по мне поменяется да так вот ладно что мы сейчас делаем но давайте
[27:27.960 --> 27:35.920]  ладно быстренько давайте вот давайте вот эту дырочку быстренько закроем потому что задача на
[27:35.920 --> 27:43.240]  самом деле будет идентична по сути следующей то есть как по заданным приоритетам и ключам построить
[27:43.240 --> 27:48.880]  декартово дерево за линию да мы с вами ну декартово дерево мы так с вами так скользь помещались
[27:49.360 --> 27:55.640]  что как бы шутку декартово дерево все прекрасно знают вот но вот но этот момент тогда обсудим
[27:55.640 --> 28:00.400]  подробнее но давайте помните декартово дерево вообще да декартово дерево как мы это такое
[28:00.400 --> 28:05.120]  сбалансированное это такое двоичное дерево поиска у которого в каждой вершине есть не только ключик
[28:05.120 --> 28:10.960]  но и приоритет и по ключам этот двоичное дерево поиска а при приитетам куча в нашем случае на минимум
[28:10.960 --> 28:21.240]  вот но идея тогда будет такая и так допустим вот нам дан вот этот вот массив вот допустим
[28:21.240 --> 28:37.760]  дан массив то есть что у нас будет там 5 там я не знаю 5 7 9 6 там я не знаю 2 4 8 6 да у нас на
[28:37.760 --> 28:44.480]  минимум да но не важно можно и на но на самом деле можно нам больше да поэтому поэтому сейчас на
[28:44.480 --> 28:54.000]  минимум да это важно вот 5 там соответственно ничего не быть еще 8 11 значит идея такая мы
[28:54.000 --> 29:06.760]  объявим что это приоритеты это у нас приоритеты ключи будут а ключи будут прям честные 1 2 3 4 5 6 7 8 9 10 11
[29:06.760 --> 29:14.720]  и вот наша задача построить декартово дерево корректное то есть заметьте мы не гарантируем что
[29:14.720 --> 29:19.640]  оно естественно сбалансировано да то есть как бы если вам дают прессе приоритеты не сгенерировано
[29:19.640 --> 29:24.280]  рандомно вот дан какой-то массив то конечно вполне вероятно что декартово дерево кажется бомбу
[29:24.280 --> 29:32.600]  чап вот но тем не менее начинается алгоритм сейчас от этого зависит никак не будет значит он
[29:32.600 --> 29:37.360]  сделает следующее значит он будет идти слева направо и пытаться добавлять вершины в дерево
[29:37.360 --> 29:47.240]  даже не пытаться а успешно добавлять как он это будет делать делать будет так вот то есть ну давайте
[29:47.240 --> 29:55.360]  начнем с того что у нас есть сначала вот этот вот 1 5 ну просто создадим декартово дерево из
[29:55.360 --> 30:06.160]  одной вершины приходит следующая вершина 2 7 ну а первых заметим кстати что каждый если мы
[30:06.160 --> 30:09.840]  будем идти слева направо то каждый следующий вершинка должна быть в дереве самой правой
[30:09.840 --> 30:16.060]  очевидно правда потому что у нее максимальный ключ то есть значит да куда же подвести но заметим
[30:16.060 --> 30:22.160]  что вот у нас есть самая про старая самая правая вершина 1 и мы знаем что у нее и тут оказывается
[30:22.160 --> 30:29.080]  приоритет больше но тогда ничто нам не мешает просто взять и ее сюда подвести просто взять
[30:29.080 --> 30:40.880]  и вот ровно в таком виде подвести 2 и 7 так более того абсолютно также мы поступаем из девяточкой
[30:40.880 --> 30:56.080]  вот такая вот девять нот да потому что 9 у нас больше чем 7 а вот четверка такой
[30:56.080 --> 31:05.280]  механизм не работает потому что выясняется шестерочка таки меньше девяточки что в таком
[31:05.280 --> 31:12.320]  случае делать делать бы все еще мы будем поэтому правом пути идти снизу вверх вот идем идем и
[31:12.320 --> 31:20.080]  видим что девяточка больше шестерочки семерочка больше шестерочки а пятерочка меньше шестерочки
[31:20.080 --> 31:29.360]  что же делать тогда как оказывается корректно сделать вот что распиливаем этот переход смотрите
[31:29.360 --> 31:36.520]  значит значит добавляем нашу шестерочку справа теперь от пятерочки вот у нас тут будет
[31:36.520 --> 31:46.560]  шестерочка вот такая и а слева от этой вершиночки нот вешаем соответственно семерочку со всем
[31:46.560 --> 31:55.280]  деревом который тут висит теперь двоечка так теперь мы идем всегда по правом пути поэтому
[31:55.280 --> 32:01.440]  стартуем с той же шестерочки то есть по сути вы этот правый путь можете условно в стэке хранить
[32:01.440 --> 32:10.040]  вот это шестерочка шестерочка больше двоечки пятерочка больше двоечки поэтому от чуда мы у
[32:10.040 --> 32:28.040]  нас объявляется новый корень вот вот примерно так это и работает тут 4 тут 5 так что у нас дальше
[32:28.040 --> 32:36.280]  но дальше видим шестерки есть четверочка больше двоечки поэтому здесь мы поэтому здесь ну и забираю
[32:36.280 --> 32:45.560]  вперед в общем-то и вот так вот тоже вот будет и 48 что же будет дальше восьмерочка так восьмерочка
[32:45.560 --> 32:53.120]  по ключу и шестерочка по приоритету это у нас тут получается вот такая шестерочка вот так ну я
[32:53.120 --> 33:01.600]  думаю так смысл вы вроде поняли да наверное даже уже нет смысла дорисовывать вот то есть но
[33:01.600 --> 33:06.120]  в принципе очевидно что он говорит он работает за линию правда ну потому что по сути мы тут
[33:06.120 --> 33:10.280]  кто-то добавляем что-то один до каждой шаги добавляем один элемент стека перед этим сколько-то
[33:10.280 --> 33:21.720]  достаем но достаем не больше чем положили туда пользуемся но мы эти ключи в явном виде сгенерировали
[33:21.720 --> 33:32.520]  у нас от одного до n да редкий случай у нас приоритеты не рандомные да ибо мы вообще задачи
[33:32.520 --> 33:43.600]  стать крымку решаем да да на самом деле дайся включение были отсортированы то конечно это был
[33:43.600 --> 33:49.440]  бы кстати метод отсортировать ключи да то есть у вас ну то есть так есть у нас есть абстрактный
[33:49.440 --> 33:57.360]  метод вакууме построим декартово дерево да тогда по декарту тысячи моего бы умеем строить в
[33:57.360 --> 34:03.480]  общем случае за быстрее чем за н логан то увы и сортировали бы за н логан но конечно сейчас мы
[34:03.480 --> 34:08.560]  явно пользуемся тем что ключи отсортированы да но в данном случае возникает вопрос зачем нам
[34:08.560 --> 34:18.400]  это надо но идея оказывается очень простая если вы хотите найти минимум на подотреске lr в этом
[34:18.400 --> 34:28.560]  массиве вам просто нужно взять вершины с ключами lr и найти у них лца утверждение в этом лца будет
[34:28.560 --> 34:40.920]  написан минимум на отрезке вот доказательства очень простое но например потому что рассмотрим
[34:40.920 --> 34:47.200]  минимум вообще глобальный минимум массиве да заметим что отрезки бывают трех типов которые
[34:47.200 --> 34:53.160]  слева от минимума справа от минимума и которые через него проходит но если отрезок проходит
[34:53.160 --> 34:59.040]  через него то тогда у нас получается в качестве lr вершины возьмем вершину слева под дерево корня
[34:59.040 --> 35:05.400]  и правого под дерева корня лца будет корень ура то есть если на отрезке лежит минимум он будет
[35:05.400 --> 35:10.400]  найден но теперь переходим с левой справа но это означает что мы переходим в левое правое под
[35:10.400 --> 35:17.720]  деревой доказываем рекурсивно вот такое вот оказывается очень несложно алгоритм как свести
[35:17.720 --> 35:22.960]  то есть внимание это он еще не решает задачу стать и крыльку он сможет ее задача статик лца
[35:22.960 --> 35:30.880]  вот то есть пока это еще конечно это и сыкла так задача так сбежать из тюрьмы для этого нужно
[35:30.880 --> 35:34.640]  обмануть бдительность охранников осталось только придумать как обмануть бдительных
[35:35.360 --> 35:49.920]  задача упростилась вот так поднимите руки кто знает откуда это ой ой ой ой как это
[35:49.920 --> 35:57.520]  сказка гарри потери свела планету с ума сказка о пори гаторе вправит вам мозги да очень рекомендую
[35:57.520 --> 36:03.520]  да пори гаторе каменный философ там вот это все да не ребята вот я рекомендую не пожалеете
[36:03.520 --> 36:08.800]  правда там прям трилогия да пори гаторе каменный философ там пори гатор там личное дело делом
[36:08.800 --> 36:15.880]  эркеоны ну и соответственно 9 подлека сена если да так что прям то есть шикарно то есть это вообще
[36:15.880 --> 36:22.640]  дайся просто самых вообще смешных вообще вещей которые в жизни читал и замечательно и про
[36:22.640 --> 36:33.320]  технический прогресс там соответственно и тогда да ладно так ладно вернемся к методу четырех
[36:33.320 --> 36:41.000]  русских так где он у нас возникнет так ну хорошо илса к рмку плюс минус один повторять не будем
[36:41.000 --> 36:48.320]  мы уже научились это делать а теперь у нас задача опять же статья к рмку но гарантируется что
[36:48.400 --> 36:56.080]  но вот но теперь у нас такой получается статья к рмку плюс минус один это означает что мы
[36:56.080 --> 37:02.120]  пытаемся но что каждое следующее число на один отличается от предыдущего правда мы не всегда
[37:02.120 --> 37:11.880]  знаем в какую сторону ну то есть вот тут конечно же но вот то есть как бы радуся их может колебаться
[37:11.880 --> 37:33.120]  как угодно но она это делает непрерывно вот значит как же нам теперь искать минимум да ну как
[37:33.560 --> 37:40.720]  да как в чем у нас заключается метод четырех русских ну как всегда зафиксируем как которые
[37:40.720 --> 37:50.960]  выберем позже да то есть давайте начнем привыкать к этому заклинанию да что мы сделаем но у нас
[37:50.960 --> 38:02.040]  конечно голубая мечта на массивах размера к или меньше научиться искать ответ за от единицы вот
[38:02.040 --> 38:10.440]  да ну как мы это можем сделать а сколько у нас различных бывает различных массивов размера к
[38:10.440 --> 38:20.840]  да то есть о формально да формальный ответ на этот вопрос бесконечно много но заметим что с
[38:20.840 --> 38:25.720]  точностью до прибавления одной вычитание одного этого числа к массиву действительно всего два
[38:25.720 --> 38:32.680]  в степени к-1 но по большому счету нам чтобы найти позицию минимума нам с абсолютные значения
[38:32.680 --> 38:38.560]  не важны нам только важно как они изменяются в процессе то есть всего массива получается массивов
[38:38.560 --> 38:47.160]  размера к у нас два в степени к но асимпатически и за отка в каждом из них можно минимум найти
[38:47.160 --> 38:54.880]  ну на самом деле там более того на самом деле в эту осим точку можно упихнуть даже поиски
[38:54.880 --> 39:02.360]  минимума не только на массивах размера к но и на массивах размера меньше к это нам тоже
[39:02.360 --> 39:07.520]  пригодится ведь запрос может быть и меньше к правда но с другой стороны что это будет два
[39:07.520 --> 39:19.320]  степени к-1 на к-1 до степени к-2 на к-2 2 степени к-3 на к-3 и так далее но заметим что на самом
[39:19.320 --> 39:25.680]  деле это просуммировать то асимпатически все равно получится два степени к на к там оставим
[39:25.680 --> 39:35.400]  в качестве упражнения почему вот хорошо то есть предподсчет делаем за такой предподсчет делаем
[39:35.400 --> 39:41.480]  на два степени к на к теперь возникает вопрос а как же теперь мне хорошо вот да а если у меня
[39:41.480 --> 39:51.200]  теперь массив длины больше чем к например n и как же в нем теперь пытаться искать минимумы на
[39:51.200 --> 40:07.920]  больших отрезках ну вот ну идея это такая давайте поделим этот массив на блоки размера к вот но на
[40:07.920 --> 40:14.440]  самом деле я утверждаю следующее что если бы нам гарантировалось что все запросы имеют размер
[40:14.440 --> 40:19.720]  к или более то как и странно это было бы нам на руку и вот этого предподсчета делать вообще не
[40:19.720 --> 40:29.920]  надо почему а потому что идея такая если запросе есть хотя бы к элементов то на самом деле можно
[40:29.920 --> 40:37.280]  тогда рассматривать это так то за это любой запрос устроен так он включает себя суффикс
[40:37.280 --> 40:47.040]  какого-то блока префикс какого-то блока и несколько целиком взятых подряд идущих блоков пока
[40:47.040 --> 40:55.840]  логично но тогда идея такая давайте на каждом блоке найдем минимум более того давайте внутри
[40:55.840 --> 41:02.160]  каждого блока найдем минимумы на префиксах и минимумы на суффиксах это там суварна в линию
[41:02.160 --> 41:09.280]  обойдется правда то есть после этого тогда то есть теперь минимум на префиксе суффиксе минимум
[41:09.280 --> 41:15.120]  на префиксе мы найдем за единицу остается только найти как искать минимумы на вот этом вот под
[41:15.120 --> 41:23.240]  отрезке из блоков идея весьма неожиданно а давайте просто и был используем ну пользуясь тем что
[41:23.240 --> 41:31.680]  целых блоков у нас теперь не n а n делить на к то есть получается предподсчет здесь нам дает n
[41:31.680 --> 41:40.640]  плюс n делить на к лог n делить на к то есть обратить внимание да то есть вот эта часть нужна только
[41:40.640 --> 41:47.320]  для одного она на самом деле нам нужна для того чтобы искать минимум на запросы на запросах которые
[41:47.320 --> 41:53.520]  попадают целиком внутрь блока мелкий только ради этого да еще там конечно нужно там какие
[41:53.520 --> 41:57.640]  тенд потратить для того чтобы там научиться для любого такого под отрезочек искать его
[41:57.640 --> 42:04.760]  масочку конечно но но это думаю слишком просто для того чтобы прям отдельно на это это обсуждать
[42:04.760 --> 42:21.800]  да ну и сами минимумы конечно вот и теперь внимание вопрос какое же к нам подогнать
[42:21.800 --> 42:35.600]  так но давайте думать да давайте подумать сколько из этого можно выжить кара в нол гори фумен
[42:35.600 --> 42:43.800]  сколько получается так получается действительно n лог n плюс n плюс смотрите n делить на лог n
[42:43.800 --> 42:53.880]  лог n делить налога так ну здесь можно сказать шлёп шлёп дай согласен это не совсем прям поровну
[42:53.880 --> 42:59.520]  но взрослые заметим что логен он больше либо равен чем лог от n поделить нашу угодно правда
[42:59.520 --> 43:06.200]  но тем более что кстати асимпатически лог n делить налога н и лога н это одно и то же но
[43:06.200 --> 43:15.880]  потому что это что-то типа логен минус лог лог и налог лог и на то мало вот да согласен
[43:15.880 --> 43:23.120]  действительно так так скучно что можно заснуть действительно вот вот но видим что тут у нас
[43:23.120 --> 43:35.360]  получается n а тут n лога поэтому получается много но с другой стороны без потери без особых проблем
[43:35.360 --> 43:43.000]  на самом деле убил вот убить здесь n лог n очень просто надо просто взять ну классики говорят а
[43:43.000 --> 43:49.880]  давайте скажем что у нас кара в до логен пополам что тогда получится два в степени логен пополам
[43:49.880 --> 43:58.480]  это сколько корень из н совершенно верно то есть корень из н лога n а это меньше чем м да
[43:58.480 --> 44:05.520]  собственно вы уже продвинутые люди даже наверно умеете доказывать вот ну я не знаю там может это
[44:05.520 --> 44:12.040]  потом как-то помогут там все какие там правила лопиталя там какие-нибудь вот эти все ну там
[44:12.040 --> 44:18.880]  доказать ну там сериям а да доказать что там там логен поделить на корень из н стремится к нулю да
[44:18.880 --> 44:24.720]  при н стремящимся к бесконечности да там эти типа там плюс бесконечности плюс бесконечности давайте
[44:24.720 --> 44:32.040]  применим правила лопиталя там блаблаблаблаблаблаблабла в общем никаких проблем вот если к экзамену
[44:32.040 --> 44:39.600]  по матанальзу это не будет блаблаблаблаблабла то я боюсь вы вылететь если что вот это соответственно
[44:39.600 --> 44:45.920]  я но вот значит здесь получается так здесь плюс n здесь тут получается уже там 2n поделить на
[44:45.920 --> 44:55.160]  логен тут налог тоже там 2n поделить на логен но тут опять конечно же там шлюп шлюп и тогда
[44:55.160 --> 45:02.960]  получается что это равно от то есть тут получается это наоборот даже мало ну как сказать ну с точки
[45:02.960 --> 45:07.960]  зрения вот этой картинки чувства прекрасного требует что кара должно быть равно там 3 четверти
[45:07.960 --> 45:24.960]  там 7 восьмых логен да то есть нет вот это сам явно что к должно быть что-то в районе нет нет
[45:24.960 --> 45:29.080]  но тут вопрос как бы зачем да то есть принципе а симпатически в общем-то на этом можно успокоиться
[45:29.080 --> 45:34.400]  потому что лучше чем это мы по-любому уже не выжмем как минимум из-за этого да и вообще как-то
[45:34.400 --> 45:39.360]  глобально дайся нас массив размером то наверно уж считать его придется да поэтому в принципе
[45:39.360 --> 45:43.200]  можно уже не заморачиваться то есть константа то есть реальная константа очевидно из чего
[45:43.200 --> 45:47.520]  подгоняется да она подгоняется просто из практических душ то есть вам по практике нужно
[45:47.520 --> 45:54.560]  смотреть сколько константа живет здесь сколько здесь там и все вот то есть так-то на самом деле
[45:54.560 --> 46:00.760]  можно думать то есть здесь конечно парадоксальная ситуация что логарифм будет много а логарифм
[46:01.000 --> 46:12.160]  любую константу меньше единицы будет мало и вот то есть там на самом деле то есть там
[46:12.160 --> 46:18.560]  то есть можно креще там просто взять какой-то там супер крутой бин поиска штам пусть кара в но
[46:18.560 --> 46:31.200]  лог 2 н минус там я не знаю там лог лог и смотреть сколько получится там не насколько получится там
[46:31.200 --> 46:38.400]  вот как раз получится что-то типа n делит на лог n умножить на вот это вот шлёп шлёп и здесь
[46:38.400 --> 46:44.360]  пол а здесь и симпатически тоже получится н делит на лог н умножить на лог н да вот то есть
[46:44.360 --> 46:51.040]  заметим что это лучше чем логарифм умножить на любую константу меньше единиц с другой стороны
[46:51.040 --> 46:55.280]  как бы это с другой стороны да с другой стороны вы и честно вы скажете совсем уже абстрактная
[46:55.280 --> 47:03.520]  чепуха какая-то начинается и в общем-то будете прав такой абстрактное развлечение да вот потому
[47:03.520 --> 47:10.760]  что в принципе она уже алгоритма ничего не даст так что вот таким образом у нас получился такая
[47:10.760 --> 47:17.600]  вот длинная цепочка сведений то есть вот ровно в таком виде алгоритм называется алгоритм фарах
[47:17.600 --> 47:26.160]  колтона бендера вопрос на внимательность сколько здесь сколько произнес фамилии да правильно две
[47:26.160 --> 47:37.600]  да потому что до фамилии здесь фарах колтон это двойная фамилия господи сами погуглите почему
[47:37.600 --> 47:52.040]  вот вот и бендер да вот как это называется да как-то настоящий программист должен
[47:52.040 --> 48:06.120]  встретить своей жизни три бендера да из эльфы петрова из футурамы и да ну да нет ну да вы так
[48:06.120 --> 48:21.560]  ладно попроще вопрос кто читал 12 тульев через серьезно господи уже 12 стульев ладно хорошо кто
[48:21.560 --> 48:31.560]  смотрел ну хоть да ладно там еще отдельно в какой версии конечно да ну и господи нет ребят нет
[48:31.560 --> 48:38.440]  мне конечно приятно чувствовать себя начитанным человеком да но вот хотя конечно
[48:38.440 --> 48:53.760]  кошмар прям иногда уже хочется да уже до такой то лекции датчат она хочет рассказывать
[48:53.760 --> 48:59.960]  сложно алгоритм но с другой стороны в качестве лебеза читаем 12 стульев да так открываем в уездном
[48:59.960 --> 49:10.520]  городе м дата черт дальше не помню жалко хотя знаете ладно пока пока вот это стирать дайте
[49:10.520 --> 49:15.560]  нам нет кто-то там на самом деле там утверждается что в японии разговор может быть такой какой
[49:15.560 --> 49:21.960]  любимый стихотворение ну наверное в день я не гин прочти мне его это ну там же это несколько
[49:21.960 --> 49:27.080]  тысяч строчек так если поэт писал там так нас столько много букв значит ему нечего сказать
[49:27.080 --> 49:37.120]  о так ничего себе так хорошо так хорошо кто читал хотя бы один детектив про фонду рена давайте
[49:37.120 --> 49:50.480]  так а так уже лучше хорошо хорошо да да да да да да а про пелагею ну там есть такие там пелагея
[49:50.480 --> 49:55.880]  белый бульдог там например или там еще какие тоже акуни нет нет тоже рекомендую там отдельная
[49:55.880 --> 50:02.080]  песня в какой-то момент даже просто активно активный разговор на тему того как там из
[50:02.080 --> 50:07.360]  абсолютно обычного езды губернии сделать просто город сад просто с полным уничтожением преступности
[50:07.360 --> 50:29.080]  так так вот не в таком виде алгоритм называется алгоритм фарох колтенбендер но мы пойдем немножко
[50:29.080 --> 50:37.200]  другим путем на самом деле мало кто знает хотя на самом деле много кто знает но на самом
[50:37.520 --> 50:44.960]  деле метод четырех русских можно применить задачи стать и к рмку напрямую без сведения колта то есть
[50:44.960 --> 50:48.960]  конечно нам нужен был фарох колтенбендер как минимум ради того чтобы убедиться что а задача
[50:48.960 --> 50:54.840]  эквалент и б что задачу л ца можно идеально решать кстати да обратите внимание то есть
[50:54.840 --> 51:00.360]  принципе да мы научились решать задачи л цаза отн при статик л цаза отн предподсчета и единицу
[51:00.360 --> 51:06.920]  на запрос вот да вот ровно этим вот способом да то есть мы никак не пользуясь тем что у нас
[51:06.920 --> 51:16.840]  дерево двоичное вот но вот с рмку оказывается все серьезнее хотя ну начало конечно понятное то
[51:16.840 --> 51:21.800]  есть опять ну понятно да зафиксируем как который выберем позже тут никуда не денешься но мы уже
[51:21.800 --> 51:27.320]  поняли что оказывается у нас запросы бывают двух типов бывают большие то есть больше равно к и
[51:27.320 --> 51:33.200]  маленькие которые меньше к и выясняется что именно маленькие запросы для нас проблема потому что
[51:33.200 --> 51:39.640]  как вы только что убедились на большие запросы мы можем отвечать там за очень простые отн предподсчета
[51:39.640 --> 51:45.200]  правда ну включающие спорсы на н делить на к на сека у нас мы верим что если ка будет порядка
[51:45.200 --> 51:54.880]  там не более чем логариф но вот но оказывается маленькие запросы можно искать с помощью очень
[51:54.880 --> 52:01.720]  простой технологии которые там знают все продвинутые олимпиадники восьмого класса вот ну
[52:01.720 --> 52:05.080]  как у нас там действительно самый продвинутый алгоритм там который может встретиться на липяне
[52:05.080 --> 52:14.760]  восьмого класса да не ну не на последний раз когда видела пято восьмого класса там была
[52:14.760 --> 52:20.240]  помыла задача в которой желательно было бы понимать почему вектор хорошо амортизируется вот
[52:20.240 --> 52:26.040]  ну не важно но на самом деле такой классический алгоритм восьмого класса как минимум в очереди
[52:26.040 --> 52:35.120]  причем не тот который очень из очереди на двух стэках естественно значит отрите да давайте
[52:35.120 --> 52:40.800]  не но вот то есть смотрите есть такой неожиданный алгоритм то есть предположим что вот у нас есть
[52:40.800 --> 52:45.520]  задача да что нам нужно реализовать очередь то есть нужно добавлять элементы удалять
[52:45.520 --> 52:50.440]  элементы и сообщать а кто у нас сейчас в очереди минимум да очередь никакая не
[52:50.440 --> 52:56.680]  приоритетная прям вот предельно честная прям вот предельно честная что же в этом случае делать
[52:56.680 --> 53:04.720]  но то дело здесь оказывается пример следующего допустим у нас в очереди оказались вот какие-то
[53:04.720 --> 53:25.240]  числа там 5 4 8 там 1 6 4 9 там 11 5 7 вот давайте давайте на нее посмотрим да я буду предполагать
[53:25.240 --> 53:34.240]  что мы вставляем элементы справа достаем слева но мне так больше нравится тогда заметим маленькую
[53:34.240 --> 53:44.160]  приятную вещь вот у нас кто у нас сейчас минимум минимум у нас очевидно один и вот я могу заявить
[53:44.160 --> 53:52.600]  маленькую приятную вещь что нет нет ну не то чтобы не нужны как бы нам нужно знать что они есть и
[53:52.600 --> 53:58.320]  мы достаем потому что фронта может быть но факт остается фактом вот эти товарищи 5 4 8 они
[53:58.320 --> 54:06.200]  минимумы не будут никогда потому что за ними идет число вот единица которая заведомо меньше да
[54:06.200 --> 54:12.240]  может быть когда-нибудь сюда придет число меньше единицы понятно да но но тогда единицы
[54:12.240 --> 54:18.520]  перестанет быть минимум 5 4 8 никогда с другой стороны заметим вот еще а предположим что мы
[54:18.520 --> 54:27.960]  достанем 5 4 8 и 1 тогда минимум станет и ничего не добавим тогда минимум станет 4 отсюда
[54:27.960 --> 54:38.080]  можно сделать вывод что шестерочка минимумом являться не будет так более того аналогично
[54:38.080 --> 54:45.800]  можно вывести что вот 9 11 вот эти тоже минимумы никогда не будут потому что есть вот 5 7 вот то
[54:45.800 --> 54:51.840]  есть давайте просто будем пусть поменьше будем так помечать так сказать те элементы которые могут
[54:51.840 --> 54:58.560]  быть минимуме кого-то еще могут быть минимум или что тоже самое на самом деле можно это можно на
[54:58.560 --> 55:06.040]  это посмотреть немножко по-другому можно заметить что это все минимумы на суффиксах то есть если мы
[55:06.040 --> 55:12.520]  рассмотрим все суффиксы этой очереди то собственно мы сейчас отметили все что могло быть минимумом хоть
[55:12.520 --> 55:25.760]  какого-то суффикс понятна логика да пока вроде не сложно так вот но теперь просто идея такая то
[55:25.760 --> 55:32.000]  есть идея то есть идея на самом деле будет такая теперь то есть ну можно ну в исходном алгоритме
[55:32.000 --> 55:37.160]  поиска минимум в очереди можно говорить так то есть давайте скажем хранить вот эти помеченные
[55:37.160 --> 55:45.320]  элементы то есть можно даже эти помеченные элементы так сказать в отдельной в отдельном деке хранить то
[55:45.320 --> 55:51.320]  есть работать это будет так то есть когда вы там удаляете элемент то вы смотрите то есть если он
[55:51.320 --> 55:57.400]  был без галочки то дек не трогаем ничего не поменялось потому что а если например обнаружилось что у
[55:57.400 --> 56:04.800]  нас там появилась какая-нибудь то есть мы удаляем вот этот минимум с галочкой то ну значит соответственно
[56:04.800 --> 56:15.000]  этот элемент из начала дека и достаем единственное что а если мы добавляем новый элемент то здесь
[56:15.000 --> 56:22.680]  оказывается работает так вот давайте я добавлю вот мне хочется 4 с половиной тогда если рассмотреть
[56:22.680 --> 56:29.520]  по этим рассмотреть этот дек с конца то обнаружится следующее что у нас есть вот элементы 5 и 7 у которых
[56:29.520 --> 56:36.640]  мы галочки торжественно снимаем и сами эти элементы достаем а вот 4 с половиной конечно по
[56:36.640 --> 56:43.640]  любому кладем почему ну потому что 4 с половиной минимум на супер все из себя любимого вот то есть
[56:43.640 --> 56:50.040]  вот получается такое но такое вот то есть такой минимум на очереди вот таким вот образом может
[56:50.040 --> 56:58.800]  быть реализован то есть такой минимум на скользящем окне такой получается и он нам между прочим очень и
[56:58.800 --> 57:08.200]  он нам сейчас очень сильно поможет поможет он нам следующим образом смотрите дело в том что если
[57:08.200 --> 57:16.120]  мы возьмем ка не слишком большое то на самом деле помещенные элементы могут быть записан записаны
[57:16.120 --> 57:22.800]  просто в масочку правда но если я тут просто вот нолики единички запишу то получится прям масочка
[57:22.800 --> 57:35.520]  размера к и тогда у меня идея такая а давайте-ка я пробегусь по массиву за линию добивая и
[57:35.520 --> 57:41.760]  добавляя и удаляя из него элементы таким образом что каждый подотрезок размера к то есть не только
[57:41.760 --> 57:48.200]  вот этот блок но прям вот каждый подотрезок размера к там вот этот вот этот вот этот вот
[57:48.200 --> 57:54.400]  этот там вот этот и так далее то есть каждый подотрезок размера к в какой-то момент будет
[57:54.400 --> 58:00.440]  в очереди в чем не просто то есть все его элементы будут в очереди все вот и никаких других там не
[58:00.440 --> 58:09.920]  будет тогда у меня идея такая вот я проверю вот этот алгоритм и для каждого из этого состояния
[58:09.920 --> 58:17.280]  для каждого подотрезка размера к запишу его масочку вот сохраню себе в карман то есть пока
[58:17.280 --> 58:26.960]  видите я это все за линию делаю тогда идея такая то есть оказывается теперь что после этого что
[58:26.960 --> 58:33.680]  мне теперь нужно чтобы найти минимум на ком-то подотрезки да ну да то есть смотрите
[58:33.680 --> 58:38.320]  предположим что я тут взял какой-то подотрезок длины меньше чем к хочу найти на нем минимум
[58:38.320 --> 58:44.800]  тогда иди такая давайте возьмем подотрезок размера к который заканчивается там же где и
[58:44.800 --> 58:53.680]  этот мелкий вот ну если он там на префексе то там разобраться легко если что вот ну потому
[58:53.680 --> 58:57.240]  что там самые первые элементы когда добавляем там тоже вот эти масочки для префиксов тоже
[58:57.240 --> 59:04.760]  сохраняются так вот что мы здесь имеем то есть мы знаем что у нас было состояние и мы знаем что
[59:04.760 --> 59:13.200]  тут какие-то элементы помечены но тогда из вот обсужденного ранее очевидно что надо просто взять
[59:13.200 --> 59:18.080]  самую левую масочку которая попала вот в этот вот маленький отрезочек то есть самый левый
[59:18.080 --> 59:25.360]  уголочек то есть по сути будет идея такая то есть мы берем эту масочку оставляем из нее только
[59:25.360 --> 59:32.080]  несколько последних элементов и в этой маске после этого нам просто нужно найти старший единичный
[59:32.080 --> 59:41.680]  бит вот и все то есть получается единственное что нам нужно теперь научиться делать после этого это
[59:41.680 --> 59:49.680]  но вот это то есть по масочке размера то есть по масочке состоящий не более чем ка бит найти
[59:49.680 --> 59:56.560]  старший единичный бит в ней масочка задается к счастливке вот на самом деле тут сильно вообще
[59:56.560 --> 01:00:01.480]  есть сомнитель крайне сомнительным является вопрос а надо ли вообще предпочитывать что-либо для
[01:00:01.480 --> 01:00:06.680]  этого потому что кажется возможно в некоторых компиляторах едва ли не там какие-то специальные
[01:00:06.680 --> 01:00:14.960]  битовые функции есть вот но как бы там есть она совсем не повезло с компилятором или мы там
[01:00:14.960 --> 01:00:20.880]  называется там где что-то не догуглили то в конце концов предпочитать эту штуку за два
[01:00:20.880 --> 01:00:27.240]  степеника на к ну совсем на тупнячка хотя в принципе можно было из-за 2 степени к просто
[01:00:27.240 --> 01:00:33.520]  пересчитать на самом деле да то есть можно в общем-то там этот старший бит честно там
[01:00:33.520 --> 01:00:38.960]  сохраните там записать сохранить в таблицу возрадоваться но после этого как всегда n плюс
[01:00:38.960 --> 01:00:46.600]  n к логин делить на к ну второй раз решать не будем то есть получается там как всегда кара в но там
[01:00:46.600 --> 01:00:52.640]  логин пополам побеждает или можно это ка вообще убить и тогда ка просто пишем логарифом и будет
[01:00:52.640 --> 01:01:02.080]  хорошо ну потому что там ну для каждого числа потому что датам что там ну да там маски там
[01:01:02.080 --> 01:01:05.960]  больше типа для для каждого числа от одного до n ну или там на какой-то степени двойки насчитать
[01:01:05.960 --> 01:01:14.400]  там там этот бит но это там аккуратненько за линию делается вот собственно и все то есть алгоритм
[01:01:14.400 --> 01:01:27.120]  в общем-то оказался не сильно сложно вот здесь в алгоритме ну просто мы говорим мы то есть мы
[01:01:27.120 --> 01:01:33.240]  тратим вот и вот это время на то чтобы перебрать там все маски размерка то есть все числа
[01:01:33.240 --> 01:01:37.760]  получается от нуля до 2 степенька минус 1 и для каждого из этих чисел за улотка найти старший
[01:01:37.760 --> 01:02:07.720]  идеичный бит вот нет ну как сказать не совсем если
[01:02:07.720 --> 01:02:14.400]  мы идем вот так прибираемся по массиву добавляем элементы в очередь слева направо то как бы у нас
[01:02:14.400 --> 01:02:20.560]  тогда получается там мы можем искать минимумы на суффиксах очереди поэтому мы собственно тут
[01:02:20.560 --> 01:02:26.960]  брали такой отрезок длины к чтобы за простой отрезок оказался его суффиксом именно ага
[01:02:26.960 --> 01:02:40.040]  если билден если билден цлз это вот операция кто ищет старший
[01:02:40.040 --> 01:03:02.480]  единичный бит то да да да да да да именно именно нету для рентгистов из зрения практики
[01:03:02.480 --> 01:03:17.320]  не но все четыре то константа крыша такая себе ну такое да то есть то есть формально там как бы
[01:03:17.320 --> 01:03:30.080]  в этом алгоритме не выплыла вот это вот бит ности опять да нет можно предпочитать потому что если
[01:03:30.080 --> 01:03:46.080]  ты для маски z знаешь старший бит то для маски 2 z это старший бит тот же самый плюс один да правда
[01:03:46.080 --> 01:03:53.200]  это будет работать за единицу а за нет если гарантирует нет если гарантируется что билден
[01:03:53.360 --> 01:03:59.520]  заработает реально за единицу они они за какой-нибудь там количестве количество
[01:03:59.520 --> 01:04:29.080]  если ваш процессор умеет это делать реально за единицу то
[01:04:29.080 --> 01:04:43.560]  пожалуйста но это будет алгоритм получается не процессор и независимый получается сейчас
[01:04:43.560 --> 01:04:53.160]  ответ чего для легкого запрос так берем маленький запрос находим подотрезок длины к такой что
[01:04:53.160 --> 01:04:58.200]  маленький запрос является его суффиксом вот для этого подотрезка длины к у нас было какое-то
[01:04:58.200 --> 01:05:05.960]  состояние очереди с ее маской так вот обнуляем все биты в этой масочке кроме вот этой вот
[01:05:05.960 --> 01:05:13.840]  которые попадают запрос но там пишем там типа ма то есть масочка пишем там n равно там один
[01:05:13.840 --> 01:05:25.200]  хрец хрец длина запроса минус один понятно да да да маски записывает потом тут обнуляем
[01:05:25.200 --> 01:05:33.040]  мы находим старший единичный бит в этой маске все вот так что такая красота даже 4 там это и так
[01:05:33.040 --> 01:05:38.960]  далее так что получается но вот так что но то в принципе да то есть метод четырех русских
[01:05:38.960 --> 01:05:50.080]  здесь может работать с неожиданно вот таким вот способом старше бит для всех маски размера к
[01:05:50.080 --> 01:05:56.520]  нет для да нет а ну не важно можно сказать размера кап потому что как бы если меньше
[01:05:56.520 --> 01:06:04.000]  как тот как бы припишем нули слева и старший бит от этого не поменяется вот в общем это
[01:06:04.000 --> 01:06:09.880]  действительно детали да но это может быть самое классическое применение метод четырех русских
[01:06:09.880 --> 01:06:14.000]  но не торопитесь залезать телефоны есть еще
[01:06:20.080 --> 01:06:26.800]  нет это попытка это попытка сказать что как и что какие-то объекты достаточно малого размера
[01:06:26.800 --> 01:06:31.520]  мы умеем просто полностью перебрать и для них сложить это ответы табличным образом и потом
[01:06:31.520 --> 01:06:41.360]  после этого оптимизируетесь им точку во сколько-то раз да но просто да но просто старше будет
[01:06:41.360 --> 01:06:47.200]  просто в логарифм раз меньше поэтому получается хорошо более того но то есть эти так мы н лог
[01:06:47.200 --> 01:07:04.480]  n превратили в н да но нам надо не нет у каждой маски размера к можно старше бит поддерживать
[01:07:04.480 --> 01:07:08.240]  но нам же нужен старший бит не только маски размера к а у любого ее суффиксы
[01:07:08.240 --> 01:07:28.680]  нет это это конечно да но чем это нам поможет вот так что да ладно но если отыть так ладно так
[01:07:28.680 --> 01:07:39.240]  так дальше нет тут просто какое-то обсуждение это еще интересно ладно продолжаем поднимать
[01:07:39.240 --> 01:07:47.720]  планку как говорится что же у нас оно вот что же еще можно решить методом четырех русских ну
[01:07:47.720 --> 01:07:55.280]  конечно же это конечно всеми любимая задача лэвел анцестер квейли так а мы умеем решать
[01:07:55.280 --> 01:08:07.640]  эту задачу вообще хоть как-нибудь бенапами да да то есть конечно говоря про дабы научились решать
[01:08:07.640 --> 01:08:13.480]  задачи лца но да мы говорили что у нас есть конечно метод искать лца двоичными подъемами но
[01:08:13.480 --> 01:08:18.800]  это за логарифом поэтому придумали такие другие методы а задачи-то осталось ведь здесь же такая
[01:08:18.800 --> 01:08:27.360]  мечта вот в чем вообще заключается задача лэвел анцестер квейли вообще или как еще она известна как
[01:08:27.360 --> 01:08:35.560]  элаку но задача заключается в следующем да но дерево но в нашем случае статическая и запросы
[01:08:35.560 --> 01:08:46.720]  у него только одного типа элаку от вершины в и высоты аж запрос очень простой значит внимание
[01:08:46.720 --> 01:08:58.320]  найдите предка до дерева подвешенные предка вершины в находящимся на расстоянии аж от нее
[01:08:58.320 --> 01:09:11.520]  не путать не потомка предка предок один потомков много как всегда вот вот вот такая
[01:09:11.520 --> 01:09:20.440]  мистическая задача но давайте думать так вот но мы пока на самом деле у нас нет особо вариантов
[01:09:20.440 --> 01:09:29.440]  мы умеем решать пока эту задачу за м логан предподсчета и логан на запрос это просто двоичные подъемы
[01:09:29.440 --> 01:09:37.400]  да была бы конечно то есть как всегда доцеливаемся мы крыша на то что хочется
[01:09:37.400 --> 01:09:42.240]  делать линию предподсчета и единицу на запрос
[01:09:42.240 --> 01:09:58.120]  ну ничего значит смотрим значит это был но вот значит как же это сделать ну естественно
[01:09:58.120 --> 01:10:06.520]  с деревом нужно как-то поработать вот но обычно до у дерева конечно но заметим что дерево можно
[01:10:06.520 --> 01:10:13.240]  как-то декомпозировать на пути вот у нас уже но была такая замечательная штука как хевилл и
[01:10:13.240 --> 01:10:20.960]  декомпозиции вот который занимался тем что разбивал дерево на какие-то пути и чет с ними дел
[01:10:20.960 --> 01:10:35.320]  вот так вот слушайте другую декомпозицию значит смотреть сейчас поедем сейчас у нас будет
[01:10:35.320 --> 01:10:45.320]  сейчас сейчас нас поприветствует так какой маркер нас поприветствует пан пусть вот этот нас
[01:10:45.320 --> 01:11:00.920]  приветствует лонгест пэс декомпозицию значит он но во первых да он будет стараться от каждой
[01:11:00.920 --> 01:11:05.520]  вершины уж если путь в ней начался то хочется чтобы этот путь дошел до листа пойте в хевилл айте
[01:11:05.520 --> 01:11:12.120]  это не обязательно ну такие существует реализация хевилл айта как мы обсуждали да что то есть можно
[01:11:12.120 --> 01:11:16.720]  не заморачиваться кто тут тяжелые легкие просто для каждой вершины говорит что давайте объявим
[01:11:16.720 --> 01:11:25.240]  тяжелым просто ребро который ведет самое жирное под дерево вот но вот здесь мы тоже будем поступать
[01:11:25.240 --> 01:11:35.160]  примерно тем же способом но но вот но делать будем так давайте начнем с того что построим путь
[01:11:36.160 --> 01:11:43.160]  куда мы пойдем из корня но мы пойдем теперь да в лонгест пэс декомпозиции мы хотим сделать этот путь
[01:11:43.160 --> 01:11:50.440]  как можно длиннее поэтому мы пойдем да я специально тут так нарисовал поэтому потому что мы в каждой
[01:11:50.440 --> 01:11:59.840]  памяти будем идти сам в под дерево самой большой глубины вот прям вот так вот жадно идти идти идти
[01:11:59.840 --> 01:12:07.560]  ну тут вообще без вариантов идти идти идти идти ну а для остальных под деревья прям отсечка но
[01:12:07.560 --> 01:12:13.720]  здесь получается вот такой путь здесь получается вот такой путь значит у этой вершины так идем
[01:12:13.720 --> 01:12:27.280]  сюда и а дальше куда давайте посмотрим давайте раз два три четыре пять раз два три четыре пять
[01:12:27.280 --> 01:12:40.880]  безразлично эти пойдем так хорошо так кто за то чтобы пойти вправо сейчас погодить
[01:12:40.880 --> 01:13:06.520]  кто за то чтобы пойти влево не очевидно я посчитал руки 8 8 так короче так ладно
[01:13:06.680 --> 01:13:21.720]  число все все спасибо вправо так нет я загадал что-то нечет просто не в моем случае то это идет
[01:13:21.720 --> 01:13:30.520]  вправо так что не важно слушай 57 179 да это разная сторона да как бы 57 это слева от крылья 179
[01:13:30.520 --> 01:13:42.200]  справа но сути одна кремль ряда вот конечно да когда как говорится дошу находится между 57 179
[01:13:42.200 --> 01:13:48.040]  правильно кремль ладно в районе на самом деле неправильно нет кремль находится чуть по боку
[01:13:48.040 --> 01:13:52.160]  между ними находка там что там между ними находится там так что там госдума между ними
[01:13:52.160 --> 01:13:58.720]  находится сейчас что там еще на так ну дом пошла так ну дом пашкова там с библиотекой естественно
[01:13:58.720 --> 01:14:05.640]  находится там еще еще а ну все в принципе там будут там так но да правильно дом пашкова она
[01:14:05.640 --> 01:14:11.080]  же библиотека дальше библиотека так что там еще какие-то здания ну и в общем-то все госдума и
[01:14:11.080 --> 01:14:16.800]  179 все что там еще может быть а в ладах есть онка там еще есть но она чуть левее
[01:14:16.800 --> 01:14:30.120]  да это уже да так пум пум пум пум ладно для нас сейчас самое главное вот такое вот
[01:14:30.120 --> 01:14:37.680]  у нас получилась вот такая декомпозиция значит идея такая то есть давайте сделаем как всегда
[01:14:37.680 --> 01:14:44.080]  то есть давайте каждый путь честно выпишем сверху вниз прям честно все вершины естественно для
[01:14:44.080 --> 01:14:51.000]  каждой вершины выпишем что она находится на каком пути она находится и где находится тогда заметим
[01:14:51.000 --> 01:14:55.640]  что вдоль этого если мы находимся на каком-то таком пути то подняться на заданную высоту в
[01:14:55.640 --> 01:15:03.440]  рамках этого пути мы можем за единицу правда тогда получается тогда идея такая кстати да что
[01:15:03.440 --> 01:15:11.360]  самое приятное найти long space decomposition мы можем достаточно легко за линию правда там буквально
[01:15:11.360 --> 01:15:17.200]  двумя дфсами по сути один дфс почитает глубину по дереву а второй честно вот эти вот пути
[01:15:17.200 --> 01:15:24.960]  ну можно за один дфс и какой-нибудь там аккуратный бфс но это это звать кому как
[01:15:24.960 --> 01:15:32.040]  проще это не принципиально вот принципиально другое хорошо предподсчет у нас конечно работает
[01:15:32.040 --> 01:15:39.560]  за n но теперь вытекает вопрос а если у нас будет такой long space decomposition спрашивается за сколько
[01:15:39.560 --> 01:15:54.320]  мы будем подниматься почему закорен вот ну не обязательно на один но действительно как
[01:15:54.320 --> 01:16:00.200]  мы будем подниматься из каждой вершины так опять ну то есть из каждой вершины будем подниматься ну
[01:16:00.200 --> 01:16:05.280]  понятно если можем в рамках пути подняться то поднимаемся завершаем работу если пока аж еще
[01:16:05.280 --> 01:16:10.520]  большое то мы поднимаемся до начала пути проходим одно одно ребро выходим на другой
[01:16:10.520 --> 01:16:17.080]  путь поднимаемся по другому пути и так далее остается только вопрос сколько путей максимально
[01:16:17.080 --> 01:16:24.400]  мы пройдем да но оказывается но все давайте подумать то есть оказывается что каждый раз
[01:16:24.400 --> 01:16:29.200]  когда мы находимся на пути длины и к следующей путь будет длины как минимум x плюс 1
[01:16:29.200 --> 01:16:38.240]  больше к сожалению больше к сожалению нельзя есть конкретный тест
[01:16:38.240 --> 01:16:55.520]  рано никаких 2x не будет пока пока никаких 2x нету не будет не будет
[01:16:55.520 --> 01:17:07.240]  вот то есть на самом деле вот я тут я тут пока как раз рисую пример на котором вот видно
[01:17:07.240 --> 01:17:13.560]  что 2x не будет вот то есть принципе дерево может быть устроено примерно вот каким-то вот таким
[01:17:13.560 --> 01:17:24.320]  вот образом вот и тогда но вот ну и отсюда в общем-то очевидно да что то есть как бы если вы то
[01:17:24.320 --> 01:17:28.960]  есть тогда получается если вы сделали l шагов то тогда вы все что вы можете гарантировать то что
[01:17:28.960 --> 01:17:37.320]  в дереве есть хотя бы 1 плюс 2 плюс 3 плюс и так далее плюс l вершин и это не превосходит n но отсюда
[01:17:37.320 --> 01:17:46.040]  автоматически выводится уж не буду расписывать что l не превосходит корня из двух n да такая вот
[01:17:46.040 --> 01:17:53.400]  стандартная корневуха то есть мы неожиданно учились делать предподсчет за n и после этого
[01:17:53.480 --> 01:18:04.680]  подыматься за корень из-за вот ну в принципе да уже тоже интересно ну как-то до корень из-за
[01:18:04.680 --> 01:18:15.120]  как-то не очень мы за логарифом умели то ничего у нас есть но следующий уровень следующий уровень
[01:18:15.120 --> 01:18:26.320]  ладно нет ну нужно просто что-то контрастненькое ладно леда декомпозиции
[01:18:26.320 --> 01:18:41.040]  формально конечно декомпозиции то есть как по мне декомпозиции надо вставить скобочки потому
[01:18:41.040 --> 01:18:48.200]  что это конечно сейчас будет не декомпозиция но же декомпозиции это когда каждая вершина
[01:18:48.200 --> 01:18:53.600]  принадлежит ровно одному пути здесь будет интересно на самом деле чем отличается
[01:18:53.600 --> 01:19:00.080]  лонгис пэс декомпозицион от леда он отличается вот чем берем обычный лонгис пэс декомпозицион
[01:19:00.080 --> 01:19:09.880]  вот этот коричневый путь и каждый из этих путей продаляем вверх на его длину то есть прям в тупую
[01:19:09.880 --> 01:19:15.480]  суммарная длина коричневых путей n поэтому про это продление будет суммарно за n даже
[01:19:15.480 --> 01:19:27.200]  если в тупую делать вот такая красота что это нам дает это нам дает маленькую приятную вещь вот
[01:19:27.200 --> 01:19:33.960]  теперь вот для этой вот в этом случае уже работает это то что есть у нас сейчас путь длины x то тогда
[01:19:33.960 --> 01:19:42.560]  следующий путь будет длины 2x почему потому что если мы находимся на коричневом пути длины x то
[01:19:42.560 --> 01:19:49.840]  мы можем то мы подымаемся вот по ледах декомпозициону как минимум на x правда то есть
[01:19:49.840 --> 01:19:54.080]  мы подымаемся как минимум на x это означает что там мы пойдем на вершину с коричневым путем хотя
[01:19:54.080 --> 01:20:09.440]  бы 2x и это приводит нас к тому что у нас все работает за n и log n так ну что мы неплохо мы
[01:20:09.440 --> 01:20:24.040]  победили двоичный подъем уже неплохо пересекаются ну и что ну коричневый не пересекаются потому
[01:20:24.040 --> 01:20:30.200]  что коричневая из вон гиспеса да но там просто три дебы и дебы такая вот мы находимся сейчас
[01:20:30.200 --> 01:20:36.480]  какой-то вершине да сейчас но и сейчас при деле я сейчас расскажу значит мы тут значит если мы
[01:20:36.480 --> 01:20:42.280]  внутри леда декомпозициона можем подняться за единицу мы это делаем да в противном случае у
[01:20:42.280 --> 01:20:49.840]  нас тут есть какой-то путь мы поднимаемся до его начала и еще но вот и еще настолько же то есть
[01:20:49.840 --> 01:20:56.880]  если тут был путь длины x то и тут будет путь длины x ну там плюс-минус один не будем придираться то
[01:20:56.880 --> 01:21:02.560]  есть мы пойдем вот в эту вершину эта вершина тоже находится таком-то коричневом пути но этот
[01:21:02.560 --> 01:21:15.160]  коричневый путь хотя бы 2x почему потому что у этой вершины глубина как минимум 2x так что как
[01:21:15.160 --> 01:21:22.360]  мимо это еще только вниз может мы еще вверх куда-то ну собственно все но вот так что оказывается это
[01:21:22.360 --> 01:21:29.320]  уже круче и это мы обошлись без двоичных подъемов но как в этом месте говорить гори коспаров как
[01:21:29.320 --> 01:21:37.800]  говорится там мы с компьютера можно против компьютера бороться а можно им и воспользоваться вот
[01:21:37.800 --> 01:21:46.440]  поэтому потому что потому что но потому что на самом деле следующий день может быть что а
[01:21:46.440 --> 01:21:53.960]  вот двоичные подъемы все-таки можно использовать и ведь действительно можно каким образом давайте
[01:21:53.960 --> 01:22:01.440]  вот это давайте в наглую двоичные подъемы так и насчитаем вот честно зен логан казалось бы да
[01:22:01.440 --> 01:22:10.640]  тогда смотрите какая у меня неожиданная идея вот пусть я этого двоичные подъемы насчитал тогда
[01:22:10.640 --> 01:22:17.280]  если мне надо подняться тогда я с помощью двоичного подъема одного за от единицы могу подняться на
[01:22:17.280 --> 01:22:23.360]  высоту 2 в степень и такая что 2 степень меньше либо равно аж меньше чем два степень и л плюс
[01:22:23.360 --> 01:22:32.640]  один логично да то есть я могу с помощью двоичного подъема там скушать больше половины но теперь
[01:22:32.640 --> 01:22:40.640]  заметим давайте из после этого применим ледер декомпозицион но тогда оказывается что мы за один
[01:22:40.640 --> 01:22:47.160]  переход по ледер декомпозициону теперь достигнем финиша почему ну просто перейдя на 2 степень
[01:22:47.160 --> 01:22:53.120]  либо пойдем вершину у которой коричневый путь длины хотя бы два степени и правда следовательно мы
[01:22:53.120 --> 01:22:58.520]  наверх можем подняться на два степени и она надо подняться на длину очевидно меньше чем два
[01:22:58.520 --> 01:23:06.720]  степени и поэтому мы это теперь делаем за единицу то есть в результате то есть в результате у нас
[01:23:06.720 --> 01:23:15.240]  получается новая симптомика то есть ледер декомпозицион плюс двоичные подъемы binary jumps
[01:23:15.240 --> 01:23:22.080]  предподсчет получается n log n и на запрос мы отвечаем за единицу
[01:23:22.080 --> 01:23:36.480]  какие логарифмы а ну да но ну знаете это детали реализации да это детали реализации
[01:23:36.480 --> 01:23:44.120]  спорта тут ничего нет то есть таким образом видео у нас снова есть n и log n и n log n 1 хочется из них
[01:23:44.120 --> 01:23:53.160]  каким-то мистическим образом сделать n и 1 как же это сделать мы это узнаем после переговора как
[01:23:53.160 --> 01:24:05.520]  же нам как бы все-таки и n и dn log n не падать единицу сохранить нету первая идея ну да и тогда
[01:24:05.520 --> 01:24:13.680]  вот логарифм но на самом деле есть конечно на садите есть на самом деле неожиданный чит я
[01:24:13.680 --> 01:24:25.840]  утверждаю что на самом деле бинапы можно считать не для всех вершин ну заметить если есть у вас
[01:24:25.840 --> 01:24:31.720]  есть ледер декомпозицион кстати да заметим первое такое маленькое приятное замечание заметим
[01:24:31.720 --> 01:24:36.680]  что если у вас есть ледер декомпозицион то вы логарифм двоичных подъемов из одной вершины
[01:24:36.680 --> 01:24:41.800]  можете насчитать не считая при этом двоичные подъемы для предков как это делалось раньше
[01:24:41.800 --> 01:24:51.960]  почему ну потому что идея такая что если вы знаете куда из вершины скакнуть на 8 вверх то
[01:24:51.960 --> 01:24:58.360]  тогда с помощью ледер декомпозициона вы за единицу можете скакнуть еще на 8 правда вот вам
[01:24:58.360 --> 01:25:06.720]  и бинап на 16 вот из этой вершины скачет она там еще на 16 получается 32 но и так далее то есть
[01:25:06.720 --> 01:25:15.480]  получается вы можете выбирать для каких вершин вы считаете двоичные подъемы поэтому идея такая а
[01:25:15.480 --> 01:25:27.560]  давайте считать двоичные подъемы не для всех вершин а только для листов вот давайте насчитаем
[01:25:27.560 --> 01:25:33.360]  для листов двоичные подъемы тогда оказывается следующее что на самом деле если вы хотите
[01:25:33.360 --> 01:25:37.960]  подняться из какой-то вершины в то прежде чем подняться давайте просто опустимся из вершины
[01:25:37.960 --> 01:25:44.000]  в какой-нибудь лист в ее поддельно но можно же заранее там в дфс предподсчитать для каждой
[01:25:44.000 --> 01:25:51.440]  вершины какой-нибудь лист из ее поддельного а ну да тем более логи спресс декомпозицион и
[01:25:51.440 --> 01:25:58.600]  вы это в явном виде делаете да да можно даже лишний дфс не запускать окей ну вот то есть тогда
[01:25:58.600 --> 01:26:03.560]  получится что теперь надо подняться из этого листа но просто не на высоту ашта а на высоту аж плюс
[01:26:03.560 --> 01:26:11.840]  там сколько там на сколько спустились это приводит нас к тому то есть это приводит нас к новой
[01:26:11.840 --> 01:26:21.640]  мистической асимптотики так ладно кажется ну ладно а тот как-то вспоминаешь он аж на
[01:26:21.640 --> 01:26:28.240]  пользоваться тем что у нас тут две доски стоит зачем-то да ну ладно пока не надо значит смотрите
[01:26:28.240 --> 01:26:38.920]  значит идея будет такая то есть теперь у нас получается новый алгоритм то есть ld плюс так
[01:26:38.920 --> 01:26:51.240]  сказать bg на листах тогда предподсчет будет работать теперь за симптотику n плюс лага
[01:26:51.240 --> 01:27:02.520]  нот l лог n даже я вот правильно вот так нарисовать потому что вот ледер декомпозицион считается
[01:27:02.520 --> 01:27:12.120]  за линию l log n это вот двоичные подъемы для листов коих у нас l большое то есть
[01:27:12.120 --> 01:27:20.480]  принципе отсюда идея такая что если вам повезло и листов дерева у вас не слишком много например
[01:27:20.480 --> 01:27:29.080]  не более чем n поделить на log n то тогда в принципе больше ничего делать не надо вы уже победили вот
[01:27:29.080 --> 01:27:33.600]  вот я вчера не был на открытии вам вчера говорили что вы уже победите или
[01:27:33.600 --> 01:27:44.880]  а точно да нет маруся помню да хотя и эту запись маруся должны были в начало ставить
[01:27:44.880 --> 01:27:51.960]  конечно а то как-то да а то всем удачи дарю когда да а то всем удачи когда уже до контест
[01:27:51.960 --> 01:27:58.080]  закончен все уже мертвые главное да давайте теперь да покажите лучше нашу на что вы
[01:27:58.080 --> 01:28:04.960]  способны так так вот но теперь получается теперь неожиданная проблема что делать
[01:28:04.960 --> 01:28:17.880]  если листов у вас больше чем n поделить на log n вот что такое лист второго уровня
[01:28:17.880 --> 01:28:36.720]  для предком родителям да и что поможет
[01:28:36.720 --> 01:28:55.200]  для ка и где ка это что и видеть и видеть и видимо маленькая да нет то на самом деле
[01:28:55.200 --> 01:29:01.720]  смотрите нет тут идея оказывается немножко другой да то есть конечно да фиксировать
[01:29:01.720 --> 01:29:14.560]  ка который выберем позже мы будем так давайте будет у нас такое красивое давайте ой нет давайте
[01:29:14.560 --> 01:29:21.600]  вот такое у нас красивая ка будет они что нет там вот еще вообще нет у нас был метод а у нас
[01:29:21.600 --> 01:29:29.400]  метр четырех русских уже был серий не ближе пусть и будет вот там ка так вот значит интуитивная
[01:29:29.400 --> 01:29:38.120]  идея то есть идея хочется сделать так вот у вас есть какое-то дерево то есть какие деревья
[01:29:38.120 --> 01:29:53.080]  вот такая вот красота красота красота красота вот так вот идея такая давайте
[01:29:53.080 --> 01:30:06.000]  попытаемся по отпиливать от этого дерева таким вот снизу маленькие под деревья размера приблизительно
[01:30:06.000 --> 01:30:30.400]  ка вот ну как-то так вот приблизительно но ну типа но но например жадным образом если выяснять
[01:30:30.400 --> 01:30:35.320]  что то есть можно вершину объявлять корень под дерево если у нее размер под дерево не
[01:30:35.320 --> 01:30:47.040]  превосходит ка а вот размер ее родителя ка превосходит ну например ну по сути да да придется
[01:30:47.040 --> 01:30:55.160]  тут конечно вот так делать вот но конечно у нас была бы мечта чтобы таких листьев не было а тут
[01:30:55.160 --> 01:31:01.040]  еще кстати вот все а на самом деле мы бы по отпиливали действительно именно под деревья
[01:31:01.040 --> 01:31:08.920]  размера ка потому что смотрите если эти деревья как бы то есть идея такая что надо их отпилить
[01:31:08.920 --> 01:31:23.840]  вместо них объявить такую мета вершину вот такое слово тоже есть да вот почему нам так хочется а
[01:31:23.920 --> 01:31:29.400]  потому что хочется что наверное если мы тут пожимали под деревья размера ка то наверное листов у нас
[01:31:29.400 --> 01:31:39.480]  оказалось не более чем инделить на кадр и дальше останется только маленькая идея останется
[01:31:39.480 --> 01:31:49.920]  только научиться подниматься в деревьях размера не более чем ка вот да согласен да это конечно не
[01:31:49.920 --> 01:32:01.120]  очень очевидно да да это не просто не очевидно это еще и неверно ну типа да ну типа да но на
[01:32:01.120 --> 01:32:08.960]  самом деле но на самом деле да то есть более точная идея будет такая смотрите я буду жадным образом
[01:32:08.960 --> 01:32:14.640]  отпиливать под деревья размера ка жадном в каком плане что я отпиливаю под дерево вершину который
[01:32:14.640 --> 01:32:22.000]  не более чем ка но у родителя который размер больше чем ка то есть вот ее я то есть теперь
[01:32:22.000 --> 01:32:30.080]  я гарантирую что ладно приблизительность не рассчитываю но что меньше либо равно ка гарантирую так
[01:32:30.080 --> 01:32:36.400]  вот идея на самом деле такая значит да у нас тут здесь мета вершин куча некоторые из них из одной
[01:32:36.400 --> 01:32:42.160]  вершины состоят но давайте посмотрим не на нее а посмотрим на родителя
[01:32:42.160 --> 01:32:55.640]  вот родителей мета вершин посмотрим так что-то у нас а ну здесь кстати мета вершина будет не
[01:32:55.640 --> 01:33:04.480]  такая она самом деле вот такая конечно вот ну вот ну и здесь будет там видим вот какая-то
[01:33:04.820 --> 01:33:15.120]  вершина тут будет вот такая ну и так далее вот так вот на самом деле идея такая то есть
[01:33:15.120 --> 01:33:24.760]  есть у нас мета вершины есть родители мета вершины так вот идея такая давайте отпилим вот отпилим все
[01:33:24.760 --> 01:33:30.180]  мета вершины на этот целиком и в общем просто отпилим ничего вместо них делать брать не будем
[01:33:30.180 --> 01:33:41.180]  Рыжая, то есть красные как раз оставляем, то есть мы будем говорить, что красная у нас останется вершина, от которой что-то отпилили.
[01:33:41.180 --> 01:33:53.180]  Так вот, мистическое утверждение. Я утверждаю, что после этого безобразия листами могли остаться только красные вершины.
[01:33:53.180 --> 01:34:06.180]  Обратное неверное, то есть не все оставшиеся выжившие красные вершины листы, но все выжившие листы это очевидно красные вершины.
[01:34:07.180 --> 01:34:19.180]  Но отсюда следует маленькая приятная вещь. Каждому из этих листов в старом дереве соответствовало ее под дерево размера больше к.
[01:34:19.180 --> 01:34:25.180]  То есть от нее отпилили хотя бы к вершин.
[01:34:25.180 --> 01:34:40.180]  Следовательно, в этом дереве, то есть красных вершин, то есть красных листов не более чем n делить на k.
[01:34:40.180 --> 01:35:03.180]  То есть идея получается такая. То есть тогда мы легко сделаем за линию теперь предподсчет, то есть если мы поднимаемся изнеотпиленной части, то там уже с помощью линейного предподсчета за единицу мы легко поднимемся.
[01:35:03.180 --> 01:35:23.180]  Более того, как сейчас у нас было в фарах в Колтонбендере, если мы поднимаемся из отпиленной части, но высота потребует дойти до красной вершины и пойти дальше, то мы тоже это легко можем сделать за единицу.
[01:35:23.180 --> 01:35:33.180]  Потому что заранее в ДФС мы в отпиленной части можем просто сказать, на каком расстоянии от нее находится корень и его родитель.
[01:35:33.180 --> 01:35:45.180]  В одном ДФС не получится, потому что в первом ДФС придется ССЗ для всего этого посчитать.
[01:35:45.180 --> 01:36:02.180]  В первом ДФС на ССЗшке, а потом уже во втором ДФС можно и лонгест ПС смотреть, и вот эти вершины мысленно отпиливать и так далее.
[01:36:02.180 --> 01:36:07.180]  Но там придется много чего еще делать, потому что в чем еще фишка?
[01:36:07.180 --> 01:36:18.180]  Мы научились решать задачу в предположении, что ответ всегда будет в этой неотпиленной части.
[01:36:18.180 --> 01:36:31.180]  Остается только как ирагия, то есть самым мерзким случаем оказывается, а что делать, если вершина В находится в отпиленной части и ответ на нее находится где-то в отпиленной части?
[01:36:31.180 --> 01:36:33.180]  Что делать?
[01:36:33.180 --> 01:36:37.180]  Для всех деревьев, для всех вершин, для всех вопросов.
[01:36:37.180 --> 01:36:39.180]  Ну да, ну да, собственно чего.
[01:36:39.180 --> 01:36:44.180]  Давайте подумаем, а сколько у нас вообще подвешенных деревьев размера К?
[01:36:44.180 --> 01:36:47.180]  В принципе-то вообще.
[01:36:47.180 --> 01:36:50.180]  Особенно еще.
[01:36:50.180 --> 01:36:57.180]  К в степени К-2, да?
[01:36:57.180 --> 01:37:03.180]  Не, сейчас.
[01:37:03.180 --> 01:37:11.180]  Ну да, если там еще источник перенумерации, там еще есть перенумерация вершин, дают другое дерево и так далее.
[01:37:11.180 --> 01:37:14.180]  Нет, да, формула К или такая есть.
[01:37:14.180 --> 01:37:25.180]  Но заметим, что нам, в общем-то, если мы под деревья поменяем местами, дерево принципиально не поменяется.
[01:37:25.180 --> 01:37:33.180]  Поэтому, я отражаю так, если с точностью до изоморфизма...
[01:37:33.180 --> 01:37:39.180]  Вот, кстати, вот отдельная задача. Даны два дерева, изоморфны ли они?
[01:37:39.180 --> 01:37:43.180]  Да, нет.
[01:37:43.180 --> 01:37:46.180]  Не сейчас мы этим будем заниматься, нет.
[01:37:47.180 --> 01:37:50.180]  Это я просто прикидываю.
[01:37:50.180 --> 01:37:58.180]  Заранее начну морально готовить к тому, что скорее всего у нас, собственно, остались в этом семестре занятия только вот это и через неделю.
[01:37:58.180 --> 01:38:07.180]  Ну, то есть, формально говоря, там, конечно, занятие еще будет одинство, но я боюсь, я в этом время рискую оказаться в Питере.
[01:38:07.180 --> 01:38:11.180]  Равно как и некоторые из вас.
[01:38:11.180 --> 01:38:14.180]  Вот, собственно, отдельные счастливчики.
[01:38:14.180 --> 01:38:17.180]  Кто вчера больше семи задач решил.
[01:38:17.180 --> 01:38:20.180]  Ну или очень хорошо решил семь.
[01:38:20.180 --> 01:38:24.180]  Ну, это так, просто в всякий случай.
[01:38:24.180 --> 01:38:28.180]  Вот, поэтому это более нот.
[01:38:28.180 --> 01:38:33.180]  Поэтому я тебе запоминаю, что надо закончить, чтобы в следующем семестре не возвращаться.
[01:38:33.180 --> 01:38:46.180]  Так, значит, что делать, если вот мы хотим посчитать количество деревьев с точностью доизоморфизма.
[01:38:46.180 --> 01:38:49.180]  Так вот, мистическое утверждение.
[01:38:49.180 --> 01:38:57.180]  Деревьев, подвешенных с точностью доизоморфизма размера К, размера ровно К, не более чем.
[01:39:03.180 --> 01:39:11.180]  Ну ладно, если брать по оригинальной статье, то не более чем два в степени 2К.
[01:39:11.180 --> 01:39:12.180]  Ну да.
[01:39:12.180 --> 01:39:18.180]  Ну, через скобчатые последовательности, конечно, не более чем КТ и число каталана.
[01:39:18.180 --> 01:39:19.180]  Почему?
[01:39:19.180 --> 01:39:22.180]  Ну, потому что мы помним, что дерево мы можем закодировать правильной скобчатой.
[01:39:22.180 --> 01:39:24.180]  Ну, не совсем так.
[01:39:24.180 --> 01:39:25.180]  Двоичное дерево.
[01:39:25.180 --> 01:39:30.180]  Да, мы помним, что двоичное дерево мы могли бы закодировать правильные скобчатые последствия, причем взаимнооднозначно.
[01:39:30.180 --> 01:39:32.180]  Здесь у нас дерево не взаимнооднозначно.
[01:39:32.180 --> 01:39:34.180]  Не двоичное, да?
[01:39:34.180 --> 01:39:36.180]  Но закодировать...
[01:39:36.180 --> 01:39:37.180]  Ну, там...
[01:39:37.180 --> 01:39:38.180]  Ладно, там...
[01:39:38.180 --> 01:39:42.180]  Ну, кат, конечно, там будет не К, там, наверное, будет...
[01:39:42.180 --> 01:39:46.180]  Там минус один, наверное, все-таки.
[01:39:46.180 --> 01:39:48.180]  Ну, потому что как кодировать дерево?
[01:39:48.180 --> 01:39:53.180]  Да, проходим по революции вниз, записываем открывающую скобку, проходим вверх закрывающую.
[01:39:53.180 --> 01:39:56.180]  То есть явно там не все правильные скобчатые последствия получаются.
[01:39:56.180 --> 01:40:01.180]  Ну, вот там правильные скобчатые последствия размера К минус один получаются.
[01:40:01.180 --> 01:40:06.180]  Но там, по-моему, в оригинальной статье, если такая была вообще...
[01:40:06.180 --> 01:40:09.180]  А, ну да, такая была, конечно.
[01:40:09.180 --> 01:40:10.180]  Вот.
[01:40:10.180 --> 01:40:11.180]  Ну, вот.
[01:40:11.180 --> 01:40:21.180]  Тогда вот там просто сказали, что нам для наших целей можем не заморачиваться и просто сказать, что у нас правильных скобчатых последствий не более, чем два в степени 2К.
[01:40:21.180 --> 01:40:22.180]  Вот.
[01:40:22.180 --> 01:40:24.180]  Просто.
[01:40:24.180 --> 01:40:25.180]  Вот.
[01:40:25.180 --> 01:40:28.180]  То есть, смотрите, идея такая.
[01:40:28.180 --> 01:40:30.180]  Перебираем все деревья.
[01:40:30.180 --> 01:40:32.180]  Значит, что мы делаем?
[01:40:32.180 --> 01:40:33.180]  Перебираем все деревья.
[01:40:33.180 --> 01:40:36.180]  То есть, по сути, может быть, там все правильные скобчатые последствия.
[01:40:36.180 --> 01:40:38.180]  По каждой из них пытаемся восстановить дерево.
[01:40:38.180 --> 01:40:46.180]  И для каждого такого дерева мы честно, для Ка, прям перебираем в тупую все вершины.
[01:40:46.180 --> 01:40:52.180]  И для каждой вершины в тупую перебираем все подъемы, прям в тупую их записываем.
[01:40:53.180 --> 01:40:54.180]  Да.
[01:40:54.180 --> 01:40:56.180]  Это прям вот очень в тупую работает.
[01:40:56.180 --> 01:41:01.180]  За два в степени 2К на К в квадрате.
[01:41:01.180 --> 01:41:03.180]  Ну, там не сильно будет принципиально.
[01:41:03.180 --> 01:41:05.180]  Там хоть К в клубе можно писать.
[01:41:05.180 --> 01:41:06.180]  И в четвертый.
[01:41:06.180 --> 01:41:09.180]  Вот.
[01:41:09.180 --> 01:41:12.180]  Правда, смотрите, тут надо, правда, аккуратнее.
[01:41:12.180 --> 01:41:14.180]  Потому что после этого вам придется сделать еще следующее.
[01:41:14.180 --> 01:41:18.180]  Вам придется пробежаться по всем отрезанным метавершинам.
[01:41:18.180 --> 01:41:22.180]  И для каждой метавершины еще и запустить ДФС.
[01:41:22.180 --> 01:41:28.180]  И желательно прописать, во-первых, какого типа это дерево.
[01:41:28.180 --> 01:41:29.180]  Понятно, да?
[01:41:29.180 --> 01:41:32.180]  Какого типа это дерево.
[01:41:32.180 --> 01:41:39.180]  И самое главное, что каждой вершине поставить в соответствие, то есть какая вершина в табличном дереве его соответствия.
[01:41:39.180 --> 01:41:45.180]  Потому что тут будут там вершины 57, 179, там 2007, 2009, там два.
[01:41:45.180 --> 01:41:46.180]  Ну вот.
[01:41:46.180 --> 01:41:51.180]  А в реальном дереве тут будет там 0, 1, 2, 3, 4, очевидно.
[01:41:51.180 --> 01:41:52.180]  Вот.
[01:41:52.180 --> 01:41:54.180]  Поэтому там надо такое соответствие.
[01:41:54.180 --> 01:41:57.180]  Но это за линию уже делается легко.
[01:41:57.180 --> 01:41:59.180]  Вот.
[01:41:59.180 --> 01:42:02.180]  То есть получается тупо, что каждое дерево придется перебирать.
[01:42:02.180 --> 01:42:10.180]  Но как бы смысл этого параметра K заключается в том, чтобы было выгоднее, чтобы различных типов деревьев было меньше, чем метавершин.
[01:42:10.180 --> 01:42:13.180]  Вот здесь.
[01:42:13.180 --> 01:42:18.180]  В этом, собственно, и смысл методов четырех русских.
[01:42:18.180 --> 01:42:24.180]  Получается мы умеем делать 2 в степени 2K на K квадрат.
[01:42:24.180 --> 01:42:28.180]  И после этого то, что выше, мы предподсчитываем.
[01:42:28.180 --> 01:42:31.180]  Получается за сколько?
[01:42:31.180 --> 01:42:33.180]  За N.
[01:42:33.180 --> 01:42:36.180]  Ну, как мы уже выяснили.
[01:42:36.180 --> 01:42:43.180]  Значит, за не более чем N делить на K, на log N.
[01:42:43.180 --> 01:42:44.180]  Так.
[01:42:44.180 --> 01:42:47.180]  Ну и, конечно, сам по себе ladder decomposition.
[01:42:47.180 --> 01:42:52.180]  Плюс, соответственно, N.
[01:42:52.180 --> 01:42:54.180]  Вот так это я уберу.
[01:42:54.180 --> 01:42:57.180]  Вот такая красота у нас теперь получается.
[01:42:57.180 --> 01:42:58.180]  Да.
[01:42:58.180 --> 01:43:03.180]  С помощью этой красоты очевидно мы теперь за единицу можем искать все подъемы.
[01:43:03.180 --> 01:43:05.180]  Правда?
[01:43:05.180 --> 01:43:07.180]  Ну, первая чека это вопрос.
[01:43:07.180 --> 01:43:08.180]  Какой нот?
[01:43:08.180 --> 01:43:09.180]  Ну, тут уже даже проще.
[01:43:09.180 --> 01:43:11.180]  Не будем сейчас подгонять идеально.
[01:43:11.180 --> 01:43:18.180]  Просто какое бы нам K подогнать, чтобы это получилась линия?
[01:43:18.180 --> 01:43:27.180]  Ну да, самое тупое, что можно подогнать, это K просто там logarithm на 4.
[01:43:27.180 --> 01:43:28.180]  Да.
[01:43:28.180 --> 01:43:29.180]  То есть на какой-нибудь это его там реальный.
[01:43:29.180 --> 01:43:34.180]  То есть если там N равно миллион, то K получится равно 5.
[01:43:35.180 --> 01:43:39.180]  То есть перебираем все подделения размера 5.
[01:43:39.180 --> 01:43:46.180]  На практике вам, конечно, явно окажется легче, видимо, эти 5 шагов делать честно.
[01:43:46.180 --> 01:43:49.180]  Но это уже вопрос константа, конечно.
[01:43:49.180 --> 01:43:52.180]  Ну тогда подставляем K равно log 4.
[01:43:52.180 --> 01:43:53.180]  Ну и что тогда?
[01:43:53.180 --> 01:43:54.180]  То есть log делить на 4.
[01:43:54.180 --> 01:43:59.180]  Тогда получается корень из N на log квадрат N делить на даже 16.
[01:43:59.180 --> 01:44:02.180]  Плюс там получается 4N.
[01:44:02.180 --> 01:44:04.180]  Ну 4N плюс N.
[01:44:04.180 --> 01:44:05.180]  Короче, ОАТ.
[01:44:05.180 --> 01:44:06.180]  Все.
[01:44:06.180 --> 01:44:08.180]  Да, тут log N пошлеп-шлепался.
[01:44:08.180 --> 01:44:09.180]  Чего?
[01:44:09.180 --> 01:44:10.180]  Ну да.
[01:44:10.180 --> 01:44:11.180]  Да, шлеп-шлеп.
[01:44:11.180 --> 01:44:12.180]  Да.
[01:44:12.180 --> 01:44:13.180]  Ой.
[01:44:13.180 --> 01:44:20.180]  Кстати, а так, шлеп-шлеп вчера забрал свой диплом, кстати?
[01:44:20.180 --> 01:44:21.180]  Окей.
[01:44:21.180 --> 01:44:24.180]  Нет, кто-то вот не забрал, кстати.
[01:44:24.180 --> 01:44:28.180]  Нет, я даже ожидал, Серге, кому-то из вас.
[01:44:28.180 --> 01:44:31.180]  Но вот тут у меня сейчас...
[01:44:31.180 --> 01:44:36.180]  А, вот была у меня команда Бэри Нор Адреналин.
[01:44:36.180 --> 01:44:42.180]  В составе Ивана Белецкого, Алина Мансурова и Юрия Воженин.
[01:44:42.180 --> 01:44:47.180]  Да, но окажется, впервые в жизни никого из них нет.
[01:44:47.180 --> 01:44:48.180]  Чего?
[01:44:48.180 --> 01:44:53.180]  Прям совсем расстроились после вчерашнего, что ли, или что?
[01:44:53.180 --> 01:44:56.180]  Так что господина, не фартаанула называется.
[01:44:56.180 --> 01:44:57.180]  Ну ладно.
[01:44:57.180 --> 01:44:58.180]  Ничего.
[01:44:58.180 --> 01:44:59.180]  Ну вот.
[01:44:59.180 --> 01:45:00.180]  Так.
[01:45:00.180 --> 01:45:01.180]  Ну вот.
[01:45:01.180 --> 01:45:07.180]  Таким образом получается, что мы научились оказываться
[01:45:07.180 --> 01:45:10.180]  и эту задачу, то есть и подниматься на нужную нам высоту
[01:45:10.180 --> 01:45:11.180]  за единицу.
[01:45:11.180 --> 01:45:14.180]  То есть у нас на самом деле не совсем из-за марксизма,
[01:45:14.180 --> 01:45:17.180]  у нас из-за марксизма точно следует того, что мы еще
[01:45:17.180 --> 01:45:20.180]  не меняем детей местами.
[01:45:20.180 --> 01:45:22.180]  Ну, типа того, да.
[01:45:22.180 --> 01:45:25.180]  Ну, то есть, ну вот.
[01:45:25.180 --> 01:45:27.180]  То есть если как-то нормально описать все эти марксные
[01:45:27.180 --> 01:45:30.180]  дети, их там окажется сильно меньше, что у нас еще
[01:45:30.180 --> 01:45:32.180]  какой-то выигрыш в константе будет.
[01:45:32.180 --> 01:45:34.180]  Ну да, но правда там да.
[01:45:34.180 --> 01:45:36.180]  Ну может и будет.
[01:45:36.180 --> 01:45:39.180]  Но там как-то отдельный вопрос о сколько существует
[01:45:39.180 --> 01:45:44.180]  попарно незаморзных подвешенных деревьев.
[01:45:44.180 --> 01:45:46.180]  Хотя бы симпатически.
[01:45:46.180 --> 01:45:49.180]  Пока все, что я знаю, что там на Котфольсе была такая
[01:45:49.180 --> 01:45:50.180]  задача, по-моему.
[01:45:50.180 --> 01:45:53.180]  Там была задача, сколько существует попарно незаморзных
[01:45:53.180 --> 01:45:56.180]  деревьев, диаметры которых не превосходит чего-то,
[01:45:56.180 --> 01:45:57.180]  по-моему.
[01:45:57.180 --> 01:46:00.180]  Десяти, что ли, или что-то в этом роде.
[01:46:00.180 --> 01:46:02.180]  Нет.
[01:46:02.180 --> 01:46:03.180]  Нет.
[01:46:03.180 --> 01:46:04.180]  Если бы на подъеме.
[01:46:04.180 --> 01:46:07.180]  Даже не на подмасках, там на деревьях каких-то.
[01:46:07.180 --> 01:46:08.180]  Нет.
[01:46:08.180 --> 01:46:10.180]  Ну может нет.
[01:46:10.180 --> 01:46:11.180]  Ну может не десять.
[01:46:11.180 --> 01:46:12.180]  Может там просто Н и К.
[01:46:12.180 --> 01:46:13.180]  Просто до тысячи оба.
[01:46:13.180 --> 01:46:15.180]  Или что-то в этом роде.
[01:46:15.180 --> 01:46:16.180]  Но тогда нормально.
[01:46:16.180 --> 01:46:18.180]  Да, но правда нам еще надо пообсуждать деревья.
[01:46:18.180 --> 01:46:21.180]  Еще хорошо, чтобы понять, за счет чего такие задачи
[01:46:21.180 --> 01:46:22.180]  вообще можно решать.
[01:46:22.180 --> 01:46:23.180]  Вот.
[01:46:23.180 --> 01:46:24.180]  Так.
[01:46:24.180 --> 01:46:27.180]  Но пока у нас вот такая красота.
[01:46:27.180 --> 01:46:28.180]  Так.
[01:46:28.180 --> 01:46:39.180]  Ну потому что там в каждой дереве там К вершин.
[01:46:39.180 --> 01:46:42.180]  Ну не более, чем К на самом деле.
[01:46:42.180 --> 01:46:43.180]  Вот.
[01:46:43.180 --> 01:46:46.180]  Для каждой вершины мы можем подняться на высоту 1.
[01:46:46.180 --> 01:46:47.180]  Захотеть подняться на высоту 1.
[01:46:47.180 --> 01:46:48.180]  На высоту 2.
[01:46:48.180 --> 01:46:49.180]  На высоту 3.
[01:46:49.180 --> 01:46:50.180]  И так далее.
[01:46:50.180 --> 01:46:51.180]  До К.
[01:46:51.180 --> 01:46:52.180]  Поэтому и как вот.
[01:46:52.180 --> 01:46:53.180]  Но это совсем в тупую.
[01:46:53.180 --> 01:46:54.180]  Если мы просто войдем и поднимемся.
[01:46:54.180 --> 01:46:55.180]  Передается следующая реализация данного алгоритма.
[01:46:55.180 --> 01:46:56.180]  Давайте пересчитаем вершинки, которые являются предками
[01:46:56.180 --> 01:46:57.180]  на высоте 5 листьев.
[01:46:57.180 --> 01:46:58.180]  И когда у нас приходит запрос, мы спускаемся до
[01:46:58.180 --> 01:47:17.180]  листа, идем 5 шагов вверх и прыгаем.
[01:47:17.180 --> 01:47:22.180]  Ну скажем так.
[01:47:22.180 --> 01:47:23.180]  На нашей практике, да.
[01:47:23.180 --> 01:47:24.180]  Логично.
[01:47:24.180 --> 01:47:27.180]  То есть на реальной практике, конечно, такое реализовывать
[01:47:27.180 --> 01:47:28.180]  сложно.
[01:47:28.180 --> 01:47:29.180]  Да.
[01:47:29.180 --> 01:47:31.180]  То есть алгоритм, конечно, скорее теоретически это
[01:47:31.180 --> 01:47:32.180]  да.
[01:47:32.180 --> 01:47:33.180]  Вот.
[01:47:33.180 --> 01:47:35.180]  Потому что на реальной практике, скорее всего, там лишние
[01:47:35.180 --> 01:47:39.180]  5 шагов можно и сделать.
[01:47:39.180 --> 01:47:40.180]  Чем, конечно.
[01:47:40.180 --> 01:47:41.180]  Хотя...
[01:47:41.180 --> 01:47:44.180]  Хотя философский вопрос.
[01:47:44.180 --> 01:47:47.180]  Там делать 5 шагов или там вы просто для каждой вершины
[01:47:47.180 --> 01:47:49.180]  четко знаете в какую таблицу куда лезть.
[01:47:49.180 --> 01:47:50.180]  Один раз.
[01:47:50.180 --> 01:47:54.180]  Потому что вы же заранее предпочитали.
[01:47:54.180 --> 01:47:55.180]  Так что может и...
[01:47:55.180 --> 01:47:56.180]  Ну то есть, ладно.
[01:47:56.180 --> 01:47:59.180]  Н, конечно, миллион вряд ли, но если там вам сгенерят
[01:47:59.180 --> 01:48:03.180]  как-то рандомно дерево там, скажем, на 10 миллионов,
[01:48:03.180 --> 01:48:04.180]  то...
[01:48:04.180 --> 01:48:11.180]  То может на самом деле единица начнет работать.
[01:48:11.180 --> 01:48:15.180]  Но это, конечно, тема для отдельного исследования.
[01:48:15.180 --> 01:48:16.180]  Так.
[01:48:16.180 --> 01:48:17.180]  Так.
[01:48:17.180 --> 01:48:22.180]  Чего бы вам еще такое рассказать?
[01:48:22.180 --> 01:48:27.180]  Я хочу просто сведеть к предыдущему пункту.
[01:48:27.180 --> 01:48:28.180]  Ну да.
[01:48:28.180 --> 01:48:29.180]  Ну да.
[01:48:29.180 --> 01:48:30.180]  Ну точнее так.
[01:48:30.180 --> 01:48:33.180]  После отпиливания метовершин листов оказывается не более,
[01:48:33.180 --> 01:48:34.180]  чем отделить на к.
[01:48:34.180 --> 01:48:35.180]  Да.
[01:48:35.180 --> 01:48:39.180]  А мы такую задачу уже умеем решать.
[01:48:39.180 --> 01:48:41.180]  Ну, значит так, с оговоркой.
[01:48:41.180 --> 01:48:44.180]  Мы ее умели решать в предположении, что к порядка логарифма.
[01:48:44.180 --> 01:48:47.180]  Но у нас так и есть.
[01:48:47.180 --> 01:48:49.180]  Получился не логарифм, а логарифм делить на 4.
[01:48:49.180 --> 01:48:50.180]  Но как бы...
[01:48:50.180 --> 01:48:54.180]  А если запрос вот попадает по дереву?
[01:48:54.180 --> 01:48:56.180]  Ничего, мука размера.
[01:48:56.180 --> 01:48:58.180]  Мы же ради этого и предподсчитывали.
[01:48:58.180 --> 01:49:01.180]  То есть мы как бы знаем про дерево какого оно типа
[01:49:01.180 --> 01:49:04.180]  и просто лезем в табличку.
[01:49:04.180 --> 01:49:07.180]  То есть соответствующее, что там есть вот это дерево,
[01:49:07.180 --> 01:49:10.180]  у него из этой вершины надо подняться на какую-то высоту,
[01:49:10.180 --> 01:49:12.180]  и там просто в табличке тупо...
[01:49:12.180 --> 01:49:15.180]  То есть из этого предподсчета там будет тупо написано,
[01:49:15.180 --> 01:49:16.180]  куда мы поднялись.
[01:49:16.180 --> 01:49:18.180]  Ну это не сложный случай.
[01:49:18.180 --> 01:49:20.180]  Нет, ну это самый сложный случай.
[01:49:20.180 --> 01:49:22.180]  Мы ради этого делали предподсчет.
[01:49:22.180 --> 01:49:24.180]  То есть когда сделали предподсчет,
[01:49:24.180 --> 01:49:25.180]  это оказался просто там...
[01:49:25.180 --> 01:49:28.180]  Ну я не знаю уже какой из этих случаев проще после этого.
[01:49:30.180 --> 01:49:34.180]  Но просто суть в том, что именно вот для этого мы делали предподсчет,
[01:49:34.180 --> 01:49:38.180]  чтобы отвечать на запросы, которые не будут вылезать за пределы лежи вершины.
[01:49:43.180 --> 01:49:45.180]  Так, ну что, еще какие-то вопросы?
[01:49:48.180 --> 01:49:49.180]  Нету?
[01:49:51.180 --> 01:49:53.180]  Господи, что ж такое рассказывать-то?
[01:50:00.180 --> 01:50:03.180]  Сомневаюсь, вам дерево хранить надо.
[01:50:03.180 --> 01:50:05.180]  Ну, в плане на предподсчет.
[01:50:06.180 --> 01:50:08.180]  В плане предподсчетки, он ведь...
[01:50:08.180 --> 01:50:10.180]  Суть его прикол в том, что нам ведь могут дать другой дерево
[01:50:10.180 --> 01:50:12.180]  с новым ножным запросом.
[01:50:12.180 --> 01:50:14.180]  Есть предподсчет сохраняется?
[01:50:14.180 --> 01:50:16.180]  Можно где-то предподсчет тебе взял?
[01:50:16.180 --> 01:50:19.180]  Суп линомиального, да?
[01:50:21.180 --> 01:50:22.180]  Ну не знаю.
[01:50:22.180 --> 01:50:25.180]  Ну чтоб было прям суп линомиальный, я...
[01:50:28.180 --> 01:50:30.180]  Ну не знаю, там что-то много вещей завязано на то,
[01:50:30.180 --> 01:50:31.180]  что у нас линейная память,
[01:50:31.180 --> 01:50:33.180]  то есть надо помечать там какие там...
[01:50:33.180 --> 01:50:35.180]  Ну там красные вершины надо помечать, скажем их,
[01:50:35.180 --> 01:50:37.180]  может быть порядка N.
[01:50:38.180 --> 01:50:39.180]  Там, по-моему, да.
[01:50:39.180 --> 01:50:41.180]  Ну, то есть можно, конечно, листы не отмечать,
[01:50:41.180 --> 01:50:42.180]  но там вот эти...
[01:50:42.180 --> 01:50:44.180]  СССшки, понятно.
[01:50:44.180 --> 01:50:46.180]  Ну, смотри, ты даже рекурсивный ДФС,
[01:50:46.180 --> 01:50:48.180]  на самом деле, он потребует тебя,
[01:50:48.180 --> 01:50:50.180]  может потребовать тебя для бамбука линейной памяти дополнительной,
[01:50:50.180 --> 01:50:52.180]  так что вряд ли.
[01:50:53.180 --> 01:50:55.180]  Очень сильно вряд ли.
[01:50:56.180 --> 01:50:58.180]  Так, ну что?
[01:50:58.180 --> 01:51:00.180]  Нет, даже интересно.
[01:51:00.180 --> 01:51:02.180]  Так, прям уже интересно, да.
[01:51:03.180 --> 01:51:05.180]  Не, слушайте, прям действительно интересно открыть Уикипедию.
[01:51:05.180 --> 01:51:06.180]  Интересно.
[01:51:06.180 --> 01:51:07.180]  Просто напомните, я что-то уже запамятал.
[01:51:07.180 --> 01:51:10.180]  А какие еще задачи решает этот четырех русских?
[01:51:10.180 --> 01:51:11.180]  Все.
[01:51:11.180 --> 01:51:13.180]  Все?
[01:51:13.180 --> 01:51:15.180]  Яха Карасик тоже?
[01:51:15.180 --> 01:51:17.180]  Там у нас строго NOP камеры.
[01:51:17.180 --> 01:51:19.180]  А, так, ну NOP, а еще?
[01:51:20.180 --> 01:51:22.180]  Ну тоже дедовично только.
[01:51:22.180 --> 01:51:23.180]  Не только.
[01:51:23.180 --> 01:51:24.180]  Нет.
[01:51:24.180 --> 01:51:27.180]  Нет, NOP-то да, это мы сейчас, видимо, и обсудим.
[01:51:27.180 --> 01:51:29.180]  Транзитивного замыкания графа.
[01:51:30.180 --> 01:51:31.180]  О, как.
[01:51:31.180 --> 01:51:32.180]  Так.
[01:51:34.180 --> 01:51:35.180]  Так.
[01:51:35.180 --> 01:51:36.180]  Ладно, давайте.
[01:51:36.180 --> 01:51:38.180]  Нет, прежде чем переходить к NOP,
[01:51:38.180 --> 01:51:40.180]  это прям отдельная песня.
[01:51:40.180 --> 01:51:41.180]  Красивая.
[01:51:41.180 --> 01:51:43.180]  Значит, ладно, давай, значит,
[01:51:43.180 --> 01:51:45.180]  тогда еще как бы утверждать,
[01:51:45.180 --> 01:51:48.180]  что у нас есть задача транзитивного замыкания графа.
[01:51:50.180 --> 01:51:51.180]  Ну, то есть о чем задача?
[01:51:51.180 --> 01:51:52.180]  То есть данный циклический,
[01:51:52.180 --> 01:51:53.180]  ну, то есть в чем задача?
[01:51:53.180 --> 01:51:55.180]  Данный циклический граф,
[01:51:55.180 --> 01:51:58.180]  данный ациклический ориентированный граф,
[01:51:58.180 --> 01:52:00.180]  и надо привести ребра
[01:52:00.180 --> 01:52:01.180]  между всеми парами вершин,
[01:52:01.180 --> 01:52:03.180]  между которыми есть путь.
[01:52:04.180 --> 01:52:06.180]  Так, это понятно, что я сказал, да?
[01:52:06.180 --> 01:52:08.180]  Это называется транзитивное замыкание.
[01:52:09.180 --> 01:52:11.180]  Да, спрашивается,
[01:52:11.180 --> 01:52:13.180]  за какое симпточку это вообще можно,
[01:52:13.180 --> 01:52:15.180]  если в тупую, сделать?
[01:52:16.180 --> 01:52:17.180]  Ну, в принципе, да.
[01:52:17.180 --> 01:52:19.180]  То есть напрашиваешь все решения за куб.
[01:52:19.180 --> 01:52:22.180]  Ну, либо DFS, либо там BFS.
[01:52:22.180 --> 01:52:30.180]  Ну, с другой стороны, да,
[01:52:30.180 --> 01:52:32.180]  заметим, что правилами BFS и масочками,
[01:52:32.180 --> 01:52:33.180]  или бицетами можно это сделать
[01:52:33.180 --> 01:52:35.180]  за n куб делить на 32.
[01:52:37.180 --> 01:52:38.180]  Почему?
[01:52:38.180 --> 01:52:39.180]  Ну, очень просто,
[01:52:39.180 --> 01:52:40.180]  потому что как понять,
[01:52:40.180 --> 01:52:42.180]  куда мы из этой вершины можем дойти?
[01:52:42.180 --> 01:52:44.180]  Для этого нужно посмотреть,
[01:52:44.180 --> 01:52:46.180]  куда мы из нее можем перейти
[01:52:46.180 --> 01:52:47.180]  за один переход,
[01:52:47.180 --> 01:52:50.180]  взять множество переходов,
[01:52:50.180 --> 01:52:51.180]  куда мы тут можем перейти,
[01:52:51.180 --> 01:52:52.180]  куда мы тут можем перейти,
[01:52:52.180 --> 01:52:53.180]  куда мы тут можем перейти
[01:52:53.180 --> 01:52:54.180]  и их тупо объединить.
[01:52:55.180 --> 01:52:56.180]  Если мы это храним
[01:52:56.180 --> 01:52:57.180]  в каких-нибудь бицетах,
[01:52:57.180 --> 01:52:58.180]  то получается,
[01:52:58.180 --> 01:52:59.180]  то мы это делаем
[01:52:59.180 --> 01:53:01.180]  за то любые два бицета,
[01:53:01.180 --> 01:53:03.180]  мы объединяем за n поделить на 32.
[01:53:04.180 --> 01:53:05.180]  Логично, да?
[01:53:06.180 --> 01:53:07.180]  Логично, да.
[01:53:08.180 --> 01:53:09.180]  Ну, вот.
[01:53:09.180 --> 01:53:10.180]  Ну, теперь возьмите какой-нибудь вопрос.
[01:53:10.180 --> 01:53:11.180]  А теперь давайте подумаем.
[01:53:12.180 --> 01:53:13.180]  Хорошо.
[01:53:13.180 --> 01:53:15.180]  А если у нас нет опции бицетов?
[01:53:15.180 --> 01:53:16.180]  А если у нас нет опции бицетов?
[01:53:18.180 --> 01:53:20.180]  Ну, разбиваем на блоки пока.
[01:53:20.180 --> 01:53:21.180]  Ну, это нет.
[01:53:21.180 --> 01:53:22.180]  Это будет, ну, да.
[01:53:22.180 --> 01:53:23.180]  Но есть риск, что это да.
[01:53:23.180 --> 01:53:25.180]  Все их пары в два степени кассы храним ответ.
[01:53:25.180 --> 01:53:26.180]  Ну, и нет.
[01:53:26.180 --> 01:53:27.180]  Ну, как бы.
[01:53:28.180 --> 01:53:29.180]  Как раз какие, по-моему,
[01:53:29.180 --> 01:53:30.180]  это оптимальность.
[01:53:30.180 --> 01:53:31.180]  И битности нет.
[01:53:32.180 --> 01:53:33.180]  Ну, да.
[01:53:33.180 --> 01:53:34.180]  Нет, скажи так.
[01:53:34.180 --> 01:53:35.180]  А если у нас нет
[01:53:35.180 --> 01:53:36.180]  волшебных битовых операций?
[01:53:36.180 --> 01:53:37.180]  Давай так.
[01:53:37.180 --> 01:53:38.180]  Как это без битовых операций?
[01:53:39.180 --> 01:53:40.180]  Еще бицеты завязаны
[01:53:40.180 --> 01:53:41.180]  на битовых...
[01:53:41.180 --> 01:53:42.180]  Бицет, изветь, бицет
[01:53:42.180 --> 01:53:43.180]  завязан на том,
[01:53:43.180 --> 01:53:44.180]  что мы там две битмаски
[01:53:44.180 --> 01:53:45.180]  размера тридцать два умеем
[01:53:45.180 --> 01:53:48.180]  там Энди теорить за единицу.
[01:53:48.180 --> 01:53:49.180]  У нас есть табличка,
[01:53:49.180 --> 01:53:50.180]  для всех массов.
[01:53:51.180 --> 01:53:52.180]  Число до два степеника.
[01:53:53.180 --> 01:53:54.180]  У нас есть табличка,
[01:53:54.180 --> 01:53:55.180]  где для каждой пары чисел
[01:53:55.180 --> 01:53:56.180]  до два степеника.
[01:53:57.180 --> 01:53:58.180]  Их о, в смысле.
[01:53:58.180 --> 01:53:59.180]  Или о.
[01:53:59.180 --> 01:54:00.180]  Энди.
[01:54:01.180 --> 01:54:03.180]  И нам эти битвы играться не нужны.
[01:54:04.180 --> 01:54:05.180]  Это тоже предпочитывается
[01:54:05.180 --> 01:54:06.180]  за два степени пока.
[01:54:06.180 --> 01:54:08.180]  А, то есть такой наглеж, да?
[01:54:09.180 --> 01:54:10.180]  Ну, в принципе, да.
[01:54:11.180 --> 01:54:12.180]  Да, в принципе, да.
[01:54:12.180 --> 01:54:13.180]  Действительно.
[01:54:13.180 --> 01:54:14.180]  Это метод четырехрусских, да.
[01:54:15.180 --> 01:54:17.180]  Зафиксируем к, который выберем позже.
[01:54:18.180 --> 01:54:20.180]  И объявим, что у нас к
[01:54:20.180 --> 01:54:22.180]  это типа та часть бицета,
[01:54:22.180 --> 01:54:23.180]  которую умеем Энди теорить
[01:54:23.180 --> 01:54:24.180]  за вот единиц.
[01:54:25.180 --> 01:54:26.180]  Если у нас нет битовых операций,
[01:54:26.180 --> 01:54:28.180]  то, значит, просто переберем
[01:54:28.180 --> 01:54:30.180]  переберем два в степени два к пар
[01:54:30.180 --> 01:54:31.180]  массовщик.
[01:54:31.180 --> 01:54:32.180]  И для каждой из них
[01:54:32.180 --> 01:54:33.180]  прям честно за к посчитаем
[01:54:33.180 --> 01:54:34.180]  энд или ор.
[01:54:37.180 --> 01:54:38.180]  Вот.
[01:54:38.180 --> 01:54:39.180]  Так.
[01:54:39.180 --> 01:54:40.180]  И это, в принципе,
[01:54:40.180 --> 01:54:41.180]  позволит нам
[01:54:41.180 --> 01:54:42.180]  работать за энд в кубе
[01:54:42.180 --> 01:54:43.180]  поделить на к,
[01:54:43.180 --> 01:54:44.180]  но остается только подогнать
[01:54:44.180 --> 01:54:45.180]  к так, чтобы было хорошо.
[01:54:46.180 --> 01:54:47.180]  Ну, как вы уже убеждались,
[01:54:47.180 --> 01:54:48.180]  к порядка там,
[01:54:48.180 --> 01:54:49.180]  сколько там?
[01:54:49.180 --> 01:54:50.180]  Ну ладно, просто к алгорифам
[01:54:50.180 --> 01:54:51.180]  уже подойдет.
[01:54:51.180 --> 01:54:52.180]  Так, окей.
[01:54:52.180 --> 01:54:53.180]  Да.
[01:54:57.180 --> 01:54:59.180]  Потому что ребер вот этих,
[01:54:59.180 --> 01:55:00.180]  которые мы, то есть бицетов,
[01:55:00.180 --> 01:55:01.180]  которые мы обетеряем,
[01:55:01.180 --> 01:55:02.180]  их порядка квадрата.
[01:55:05.180 --> 01:55:06.180]  Так что, соответственно.
[01:55:07.180 --> 01:55:08.180]  То есть по факту это будет, да,
[01:55:08.180 --> 01:55:10.180]  это работать за там,
[01:55:10.180 --> 01:55:11.180]  по факту
[01:55:12.180 --> 01:55:14.180]  то есть сейчас за сколько
[01:55:14.180 --> 01:55:15.180]  это будет работать за
[01:55:15.180 --> 01:55:16.180]  энд поделить на к
[01:55:16.180 --> 01:55:17.180]  умножить на количество ребер,
[01:55:17.180 --> 01:55:18.180]  по факту.
[01:55:18.180 --> 01:55:19.180]  Вот так.
[01:55:20.180 --> 01:55:21.180]  Вот.
[01:55:21.180 --> 01:55:23.180]  Так что там в зависимости от этого,
[01:55:23.180 --> 01:55:24.180]  то есть от этого параметра,
[01:55:24.180 --> 01:55:26.180]  если у вас тут не энд куб,
[01:55:26.180 --> 01:55:27.180]  а допустим, действительно,
[01:55:27.180 --> 01:55:28.180]  энд эм,
[01:55:28.180 --> 01:55:30.180]  то в соответствии с этим можно и к
[01:55:30.180 --> 01:55:31.180]  подгонять.
[01:55:31.180 --> 01:55:32.180]  Это же не совсем так,
[01:55:32.180 --> 01:55:33.180]  потому что у нас количество ребер
[01:55:33.180 --> 01:55:34.180]  увеличивается
[01:55:34.180 --> 01:55:35.180]  по ситуации.
[01:55:35.180 --> 01:55:36.180]  Поэтому изначально это может быть энд,
[01:55:36.180 --> 01:55:37.180]  а в конце энд квадрат.
[01:55:37.180 --> 01:55:38.180]  Нет, увеличивается,
[01:55:38.180 --> 01:55:39.180]  но количество бицетов,
[01:55:39.180 --> 01:55:40.180]  которые мы объединяем,
[01:55:40.180 --> 01:55:41.180]  объединяем же не меняется.
[01:55:41.180 --> 01:55:42.180]  Потому что какая разница,
[01:55:42.180 --> 01:55:43.180]  у тебя есть вершины,
[01:55:43.180 --> 01:55:44.180]  тебе нужно просто взять бицеты
[01:55:44.180 --> 01:55:45.180]  для вот этих трех вершин
[01:55:45.180 --> 01:55:46.180]  и их объединить.
[01:55:46.180 --> 01:55:47.180]  Все.
[01:55:47.180 --> 01:55:48.180]  То есть как бы оно,
[01:55:48.180 --> 01:55:49.180]  то есть и там.
[01:55:49.180 --> 01:55:51.180]  Ну хорошо, то есть в конце там
[01:55:51.180 --> 01:55:52.180]  ты потрачишь энд квадрат времени,
[01:55:52.180 --> 01:55:53.180]  разве что на вывод ответа.
[01:55:53.180 --> 01:55:54.180]  Не более того.
[01:55:54.180 --> 01:55:55.180]  Вот так.
[01:55:55.180 --> 01:55:56.180]  Ну теперь, кстати, вот да.
[01:55:56.180 --> 01:55:57.180]  Вот с этой точки зрения,
[01:55:57.180 --> 01:55:58.180]  когда энд куб превращается в энд эм,
[01:55:58.180 --> 01:55:59.180]  тут как бы вопрос,
[01:55:59.180 --> 01:56:00.180]  какой ка предлагать?
[01:56:01.180 --> 01:56:06.180]  А лучше на четыре.
[01:56:06.180 --> 01:56:07.180]  Да.
[01:56:07.180 --> 01:56:08.180]  Да.
[01:56:08.180 --> 01:56:10.180]  То есть действительно ка
[01:56:10.180 --> 01:56:11.180]  давайте скажем,
[01:56:11.180 --> 01:56:18.180]  что это лог энд эм двойчный,
[01:56:18.180 --> 01:56:21.180]  определить на четыре,
[01:56:21.180 --> 01:56:24.180]  и что получается?
[01:56:24.180 --> 01:56:27.180]  Что там получается?
[01:56:27.180 --> 01:56:29.180]  Корень из энд эм,
[01:56:29.180 --> 01:56:45.260]  корень из nm на log nm делить на 4 плюс 4nm делить на log, то есть получается даже, нет стоп,
[01:56:45.260 --> 01:56:52.500]  а нет нормально да, то есть получается асимптотика nm делить на log nm.
[01:56:52.500 --> 01:57:21.700]  но мы так а мы их не добавляем,
[01:57:21.700 --> 01:57:26.540]  у нас у нас нет цели добавить, у нас цель для каждой вершины получить бит сет.
[01:57:26.540 --> 01:57:33.020]  вот так. нет, ну в принципе да, log nm на самом деле, заметим, что nm, можно в принципе сказать,
[01:57:33.020 --> 01:57:37.900]  что nm, то есть m не происходит n квадрат, поэтому log nm не происходит там log n в кубе,
[01:57:37.900 --> 01:57:43.780]  поэтому асимптотические по барабану. но когда фишка здесь, даже оптимизация здесь,
[01:57:43.780 --> 01:57:48.660]  что если m порядка n, то это даже не n куб поделить на log n, а на n квадрат поделить на log n,
[01:57:48.660 --> 01:57:53.660]  то есть еще меньше. ну против с бит сетами у вас тоже бит сеты у вас тоже по факту работают не
[01:57:53.660 --> 01:58:03.900]  за n куб на 32, а nm делить на 32 с теми же спецэффектами. так что вот такие вот, да, из истории русского
[01:58:03.900 --> 01:58:12.020]  пехона, да. вот, ладно, так, хорошо, так, а что-то там еще кроме nop есть?
[01:58:18.020 --> 01:58:29.860]  давайте. что там еще есть? ну есть расстояние редактирования, но есть подозрение, что это
[01:58:29.860 --> 01:58:42.180]  примерно то же самое, что и nop. все? ну окей, ладно, значит мы сегодня изучим полностью метод
[01:58:42.180 --> 01:58:53.140]  четырех русских. да, и так, да, теперь мы неожиданно переходим к задаче о наименьшем общей
[01:58:53.140 --> 01:58:58.260]  подпоследовательности. и так решаем задачу о наибольшей общей подпоследовательности. так,
[01:58:58.300 --> 01:59:03.420]  в чем заключается задача? даны две последовательности, выберите из них, каждый из них подпоследовательности,
[01:59:03.420 --> 01:59:10.900]  которые совпадут. не путать подпоследовательности с подстроками. помним, да? так, но задачу все
[01:59:10.900 --> 01:59:17.820]  знают. так, поднимите руки, кто умеет решать эту задачу за n квадрат, ну пусть там обе последствия
[01:59:17.820 --> 01:59:31.660]  одинаковой длины. так, кто-то не умеет, да? да ладно, в данном случае называется хорошо
[01:59:31.660 --> 01:59:42.300]  прикалываться. ну хотя ладно, если есть, придется рассказать. значит, как решается
[01:59:42.300 --> 01:59:47.580]  задача? ну даны какие-то последовательности a, а последовательность b, обе длины n. они из чего-то
[01:59:47.580 --> 02:00:00.620]  там состоят. тогда идея такая, dp и tgt. пусть это будет просто длина nоп для префикса длины i у
[02:00:00.620 --> 02:00:08.060]  последствия a и префикса длины g по следовательности b. это такое определение. определение функции. да,
[02:00:08.060 --> 02:00:13.820]  я ее почему-то называю dp, а ну люблю эти две буквы почему-то, вот, не важно. вот, ну и тогда
[02:00:13.820 --> 02:00:21.500]  очевидно, что dp и tgt очень легко пересчитывать, потому что, ну идея такая, вот вы ищете nоп двух
[02:00:21.500 --> 02:00:27.140]  последствий. очевидно, что если два последних элемента совпадают, то очевидно, что этот
[02:00:27.140 --> 02:00:37.260]  элемент просто подпоследствия надо взять, правда? то есть получается, что это 1 плюс dp от i-1 и g-1,
[02:00:37.260 --> 02:00:50.140]  если a и t равно b и t, ну а если они не равны, значит, как минимум кого-то придется взять не. но если
[02:00:50.140 --> 02:00:59.220]  вы не берете, скажем, вот последний элемент b, то тогда эта задача сводится к задаче подпоследствия
[02:00:59.220 --> 02:01:09.540]  dp и g-1, или если мы и это элемент не берем, то вот dp и g-1. да, то есть в принципе может
[02:01:09.540 --> 02:01:13.260]  случиться, что мы не возьмем ни тот, ни тот, но этот случай будет и тут, и тут учтен.
[02:01:13.260 --> 02:01:35.820]  ну-то погодите, погодите, тут как бы аккуратно. нет, чего оптимизировать, не понял. нет,
[02:01:35.820 --> 02:01:39.380]  наоборот, оптимизация будет заключена в том, чтобы это не учитывать и рассмотреть только эти два
[02:01:39.380 --> 02:01:46.100]  варианта. потому что мы же не количество вариантов перебираем, а только там выбираем максимальные
[02:01:46.100 --> 02:02:01.820]  из имеющихся, поэтому не глобально. вот, это работает с n квадрат. для числовых там может и можно,
[02:02:01.820 --> 02:02:08.580]  но действительно есть маленькая подлянка. потому что как это ни странно, метод четырех русских тут
[02:02:08.580 --> 02:02:16.340]  вообще не поможет, что быстрее чем z квадрат эту задачу решить нельзя, если загнать очень жесткие
[02:02:16.340 --> 02:02:24.700]  предположения. самое жесткое предположение, которое можно загнать, это такое, что у вас элементы
[02:02:24.700 --> 02:02:31.580]  последовательства это камешки. да, почти те самые камешки из сортировки, но только теперь,
[02:02:31.580 --> 02:02:36.100]  если бы камешки из сортировки умели хотя бы сравнивать, то есть кто меньше, кто больше,
[02:02:36.100 --> 02:02:45.300]  то давайте скажем, что камешки мы теперь можем только говорить, равны они или нет.
[02:02:45.300 --> 02:02:56.420]  тогда я утверждаю, что быстрее чем z квадрат вы эту задачу не решите просто в принципе. более того,
[02:02:56.420 --> 02:03:06.060]  я даже просто утверждаю, я утверждаю, что какой бы у вас не был детерминированный алгоритм,
[02:03:06.100 --> 02:03:13.860]  найдется случай, когда вы сделаете реально даже не омега от н квадрат, а просто н квадрат сравнений.
[02:03:13.860 --> 02:03:25.180]  или даже еще тупее. в алгоритму придется сравнить каждый элемент массива a с каждым элементом массива b.
[02:03:25.180 --> 02:03:38.380]  могло бы быть. если бы я вам просто сказал, докажите, что быстрее нельзя,
[02:03:38.380 --> 02:03:42.460]  да, это может быть даже сложная задача, но сейчас я вам уже подсказывал так, что в принципе уже
[02:03:42.460 --> 02:03:47.820]  практически все пробивается, хотя техника может быть не совсем стандартной, потому что техника тут
[02:03:47.820 --> 02:03:55.540]  такая. пусть у вас есть детерминированный алгоритм. там черный ящик такой. но все,
[02:03:55.540 --> 02:03:59.700]  что он делает, он иногда вас спрашивает, просит сравнить какие-то элементы, вы ему
[02:03:59.700 --> 02:04:12.540]  отвечаете yes и no, и он из этого думает. так вот, идея такая. давайте подсунем ему тест,
[02:04:12.540 --> 02:04:26.500]  на котором все двойные элементы по парде различны. я утверждаю, что для того,
[02:04:26.500 --> 02:04:37.660]  чтобы ему вывести ответ 0, ему придется все пары камешков он вам сравнит. почему нет?
[02:04:37.660 --> 02:04:47.380]  да, потому что тут идея такая. предположим, что какой-нибудь там 57 элемент массива а,
[02:04:47.380 --> 02:04:56.100]  он не сравнился с 179 элементом массива b. тогда скорбим ему другой тест. скорбим ему тест,
[02:04:56.100 --> 02:05:02.700]  в котором все элементы по паре различны, кроме вот этого и вот этого, которые равны. алгоритм
[02:05:02.700 --> 02:05:09.220]  детерминированный. это означает, что если вы ему будете сообщать одни и те же ответы,
[02:05:09.220 --> 02:05:14.180]  он будет задавать одни и те же вопросы. следовательно, он про эти ничего не спросит,
[02:05:14.180 --> 02:05:19.260]  про все остальное выдаст 0 и выдаст вам ответ, следовательно, тоже 0. либо на предыдущем
[02:05:19.260 --> 02:05:29.500]  тесте он вам тоже выдал не 0, а это wrong answer. ура, ящик взломан. чтобы убедиться, что 0,
[02:05:29.500 --> 02:05:39.460]  ему придется сравнить все. вот такая вот неожиданная красота. получается,
[02:05:39.460 --> 02:05:50.060]  что быстрее, чем за квадрат, вы эту задачу особо не решите. вот, спрашивайте, при чем тут
[02:05:51.060 --> 02:05:59.500]  нет, но там, на самом деле, думать можно. так, сколько у нас времени, кстати, так,
[02:05:59.500 --> 02:06:19.740]  значит, давайте смотреть, где тут можно оптимизировать. но оптимизация, естественно,
[02:06:19.740 --> 02:06:30.140]  начинается тогда, когда мы при эти камешки все-таки что-то знаем. ну, в нашем случае,
[02:06:30.140 --> 02:06:36.420]  конечно, давайте предположим, что, как в реальной жизни, у нас алфалит константный. ну,
[02:06:36.420 --> 02:06:40.420]  давайте для простоты предположим, что у нас, на самом деле, вообще эти камешки это 0 и 1.
[02:06:40.420 --> 02:06:55.140]  вот, ну, бывает такое, nop на бинарных строчках. нет, я не знаю, Капелевич мог вам дать это
[02:06:55.140 --> 02:07:05.860]  развлечение, как бы даны бинарные строчки, найдите nop за n2 на 32. а кто знает, кто такой Капелевич?
[02:07:05.860 --> 02:07:23.100]  а, ЛКШ не катается, да, ну окей. а куда катается? а, окей. нет, ну, Sirius это бывает. ну,
[02:07:23.100 --> 02:07:33.180]  понятно, да, ой, ну, нет, ну, понятно. давайте, смотрите, какая у нас тут возникает идея. как
[02:07:33.180 --> 02:07:41.660]  говорит, это dp, ну, предположим, у нас строчки бинарные. нам нужно насчитать вот примерно такую
[02:07:41.660 --> 02:07:49.260]  квадратную табличку, да, ну, типа, по i и по j, да, то есть, типа, тут мы насчитываем, тут типа a, тут b и
[02:07:49.260 --> 02:07:55.020]  тут dp, да, по идее, у нас же каждую клеточку, то есть, каждую клеточку надо честно посчитать,
[02:07:55.020 --> 02:08:03.780]  да, вот, ну, теперь заметим следующий. давайте, тут, допустим, вот, так, вот, давайте,
[02:08:03.780 --> 02:08:11.300]  тут просто для понятности тут нарисую, да, то есть, тут я прям честно 1, 1, 0, 1, 1, 0, 0, 0,
[02:08:11.300 --> 02:08:25.060]  1, ну, я примерно, да, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, вот, ну, и, по идее, вот, да, то есть,
[02:08:25.060 --> 02:08:30.060]  у нас, то есть, по сути, у нас там табличка выглядит примерно вот так, то есть, даже это не клеточки,
[02:08:30.060 --> 02:08:34.340]  а скорее, давайте, вот, почему-то очень удобно мыслить в терминах, что у вас тут на самом деле в
[02:08:34.340 --> 02:08:40.500]  узелках находятся, то есть, в узелках этой клеточки, в каждой клеточке находятся ДПшка,
[02:08:40.500 --> 02:08:50.100]  вот, понятно, что имеется в виду, да, вот, ну, и, по идее, стандартный алгоритм говорит о том,
[02:08:50.100 --> 02:08:53.900]  что надо прям честно, на самом деле, в каждом узелке числуку посчитать,
[02:08:53.900 --> 02:09:09.260]  вот, но тут приходят четыре русских и говорят, зафиксируем, как-то выберем позже, хотя ладно,
[02:09:09.260 --> 02:09:13.780]  я не уверен, конечно, что это их формулировка, нет, фразу я услышал, собственно, от Андрея Сергеевича
[02:09:13.780 --> 02:09:18.300]  Санкевича, который рассказывал этот метод, вот, то есть, там, в оригинальных статьях, я,
[02:09:18.300 --> 02:09:23.180]  честно говоря, ничего подобного не слышал, там, может, просто там, действительно, то есть,
[02:09:23.180 --> 02:09:28.900]  там везде говорят, давайте просто там это, введем карта и сразу логин поделить на 4 и поехали,
[02:09:28.900 --> 02:09:37.660]  и погнали, вот, и там неожиданно все сходится, но суть тут будет такая, дело в том, что мы с вами,
[02:09:37.660 --> 02:09:46.180]  значит, возьмем тут кое-что, значит, сделаем такие метаклетки, метаклетки размера канака,
[02:09:46.180 --> 02:09:56.140]  вот так вот, попилим. Просто в чем идея? Идея заключается в том, что для каждой метаклетки
[02:09:56.140 --> 02:10:04.220]  верно следующее, если вы знаете значение вот в этих вот узелках, вот в этих узелках и вот эти
[02:10:04.220 --> 02:10:12.140]  вот строчки, то, в принципе, этого вам достаточно для того, чтобы посчитать значение вот в этих
[02:10:12.140 --> 02:10:16.860]  узелках, и вот эти промежуточные значения вам даже не нужны. Ну, хранить, по крайней мере,
[02:10:16.860 --> 02:10:22.460]  не надо, да? Ну, тут, в принципе, заметим, что, на самом деле, вот, кстати, кто-то тут говорил про
[02:10:22.460 --> 02:10:30.060]  доп память, да, то есть, заметим, что насчитать ДП можно за ОАТН доп памяти, то есть, вот это НОП.
[02:10:30.060 --> 02:10:34.780]  Отдельная песня, это, видимо, будем в следующий раз обсуждать, а может, а может, сегодня,
[02:10:34.780 --> 02:10:40.420]  собственно, отдельная песня, как потом восстановить это наибольший вообще последствия линии памяти.
[02:10:40.420 --> 02:10:49.540]  Ну, идея такая, значит, разбиваем тут каждую подстроку на блоке размера К, а ДП, а табличку ДПшек
[02:10:49.540 --> 02:10:56.020]  нам вот эти метаклеточки. У меня просто идея, я очень хочу насчитывать не все узелки, а только
[02:10:56.020 --> 02:11:03.980]  вот узелки на вот этих вот границах метаклеточек. Для чего я это, чтобы это сделать, я замечаю,
[02:11:04.100 --> 02:11:10.540]  я замечаю следующее, я замечаю, чтобы насчитать правые и нижние узелки каждой клеточки,
[02:11:10.540 --> 02:11:16.620]  мне нужно знать, что он мне ждет. Вот только верхние узелки, левые узелки и, собственно, строчки.
[02:11:16.620 --> 02:11:24.740]  А теперь давайте посмотрим, а сколько у нас этих вот четверок есть, то есть,
[02:11:24.740 --> 02:11:29.500]  типа, а сколько у нас существует наборов, типа, вот эти ДПшки, вот эти ДПшки, там вот эта строчка,
[02:11:29.500 --> 02:11:37.420]  вот этот строчек. Ну да, формуля бесконечно много, но, как всегда,
[02:11:37.420 --> 02:11:41.940]  каждый следующий узелок, это как предыдущий, только либо такой же, либо плюс один, правда.
[02:11:41.940 --> 02:11:48.220]  Поэтому получается, что у нас тут всего два в степени 2К, это вот на узелки уходит,
[02:11:48.220 --> 02:11:58.460]  и еще два в степени 2К у нас уйдет на сами строчки. То есть различных клеточек у нас всего вот столько.
[02:11:58.460 --> 02:12:06.180]  Давайте все их честно переберем, для каждой из них честно за К квадрат насчитаем вот эти узелки,
[02:12:06.180 --> 02:12:15.740]  тоже в виде масочек, и положим их в таблицу. То есть после этого тогда окажется, что вы,
[02:12:15.740 --> 02:12:21.060]  собственно, динамику теперь считаете, ну потому что вам теперь не надо считать все промежуточные
[02:12:21.060 --> 02:12:26.540]  узелки, вы считаете только вот, собственно, узелки прямо вот на месте. И получается,
[02:12:26.620 --> 02:12:32.140]  в результате делаете вы это теперь за Н квадрат делить на, соответственно, К квадрат.
[02:12:32.140 --> 02:12:50.580]  Спрашивается, вот, спрашивается, теперь что, спрашивается, какое каму теперь подгоним?
[02:12:50.580 --> 02:13:10.420]  Делить на 8, потому что первая 2 в степени 2К на узелки. Каждое следующее как бы два варианта
[02:13:10.420 --> 02:13:18.660]  от предыдущего, ну там стоит вот, так что поэтому тут 2 в степени К, тут 2 в степени К. А вторые 2
[02:13:18.660 --> 02:13:22.260]  в степени К, потому что у нас строки, то есть у нас еще вот эта строчка размера К, а вот
[02:13:22.260 --> 02:13:29.060]  эта строчка размера К, и они бинарные. Поэтому возникают вторые 2 в степени 2К,
[02:13:29.060 --> 02:13:35.300]  потому что вот эти DPS зависит не только от этих узелков, но и от строчечек самих.
[02:13:35.300 --> 02:13:46.140]  То есть мы подставляем лог N делить на 8, получаем тут, как всегда, корень из N на лог квадрат N на
[02:13:46.140 --> 02:13:56.060]  64, плюс там 64 N квадрат делить на лог квадрат N. В общем, короче, это от N квадрат делить на лог квадрат N.
[02:13:56.060 --> 02:14:02.020]  Правда, с константой 64.
[02:14:02.020 --> 02:14:16.340]  Вот, по крайней мере, на уровне теории этот результат можно усилить. Предположим,
[02:14:16.340 --> 02:14:23.780]  что у вас размер алфавит константного размера, но этот размер не два, а допустим альфа.
[02:14:23.780 --> 02:14:36.220]  Что поменяется? Да ничего, да. То есть на самом деле просто вот эту двойку вторую,
[02:14:36.220 --> 02:14:42.300]  где мы строчечки считали, мы заменяем на альфа. Так, а какое нам K теперь надо взять?
[02:14:42.300 --> 02:15:02.220]  Чего лог делить? Нет, зачем? Я бы сказал так, лог два альфа, там, соответственно, N делить на
[02:15:02.220 --> 02:15:12.500]  лог 4, чтобы тут опять корень был. То есть тут опять, ну, по сути, опять получится лог квадрат N,
[02:15:12.500 --> 02:15:18.660]  но правда там прото лог будет уже по основанию альфа. То есть чем больше альфа, тем меньше этот
[02:15:18.660 --> 02:15:24.020]  логарифм, соответственно, понимаете. Поэтому тем ближе это будет к реальному N квадрату.
[02:15:24.020 --> 02:15:36.540]  Ну, типа, если у нас как бы последователи стоят из символов какого-то константа алфавита,
[02:15:36.540 --> 02:15:41.460]  ну, там, допустим, это, то есть обычно это как бы Nоп для двух строчек каких-нибудь,
[02:15:41.460 --> 02:15:47.340]  допустим, 26 буквок, тогда можно решать, вот тогда тут можно поделить на лог квадрат,
[02:15:47.340 --> 02:16:02.940]  чем логарифм берется по основанию 52. Вот такая красота. Вот, но мы замахнемся еще на кое-что.
[02:16:02.940 --> 02:16:09.940]  Да, ну, мы в принципе любим замахиваться. Вот, соответственно, сколько у нас там времени?
[02:16:09.940 --> 02:16:21.140]  А, нормально. Давайте замахнемся еще. А что делать, если алфавит у вас не
[02:16:21.140 --> 02:16:28.380]  константного размера? Ну, сейчас я возьму максимально типичную ситуацию. Альфавит
[02:16:28.380 --> 02:16:34.420]  не гарантируется, что константного размера, но при этом гарантируется, что элементы этого
[02:16:34.500 --> 02:16:43.220]  алфавита можно сортировать. Ну, например, числовая последствия. Ну, или там любое линейное
[02:16:43.220 --> 02:16:54.060]  паралитичное множество подойдет. Так, ну, начнем с того, чтобы за NLogN можете сделать сжатие координат
[02:16:54.060 --> 02:17:05.740]  и свести задачу к NLogN. И какой задачи свести такую задачу? И тогда свести задачу, что у нас
[02:17:05.740 --> 02:17:15.140]  действительно этот алфавит альфа состоит из чисел от 1 до N. Ну ладно, формально для двух N,
[02:17:15.140 --> 02:17:20.140]  но на самом деле заметим, что все элементы B, которые, если прижатие выяснилось, что в B есть
[02:17:20.140 --> 02:17:27.580]  какие-то элементы, нележащие в А, то их можно и выкинуть. Поэтому можно тут даже не два N считать,
[02:17:27.580 --> 02:17:33.900]  а просто 2. Будем такая типичная ситуация. Будем считать, что A и B состоит из чисел от 1 до N.
[02:17:33.900 --> 02:17:41.100]  Так, теперь вот давайте думать, что мы можем выжать из этого?
[02:17:41.100 --> 02:18:03.460]  Чему NLogN по основанию N? Ага, ну как Константина? Единица. Да, не помогает. Хорошо. А что дот?
[02:18:03.460 --> 02:18:07.140]  Ну действительно, что еще можно сделать? Так, нет, погодите, ну давайте, нет, у нас же есть вот метод.
[02:18:07.500 --> 02:18:17.220]  Так, давайте выберем K. И давайте теперь, так, ну давайте теперь просто почешемся. Так, ну давайте,
[02:18:17.220 --> 02:18:26.340]  так, давайте теперь почешемся. Что за нот? То есть каким образом можно делать сжатие? Ну конечно,
[02:18:26.340 --> 02:18:31.220]  если мы тут будем писать клеточки там что-то N в степени 2K, это будет, конечно, много.
[02:18:31.220 --> 02:18:41.300]  Ну что можно сделать? Можно заметить маленькую прятную вещь. В каждой клеточке можно сжать
[02:18:41.300 --> 02:18:51.220]  координаты дополнительные. Это можно сделать за, причем, кстати, да, вот, причем более того,
[02:18:51.220 --> 02:18:57.460]  суммарно можно сделать сжатие координат за вот какую-то адекватную симптомику.
[02:18:58.460 --> 02:19:08.740]  Что? Да нет, нет, нет, ну если в каждой прям совсем независимо делать. Ну давайте так,
[02:19:08.740 --> 02:19:15.660]  хорошо, ладно. Так, ладно, давайте, ну давайте так. Заметим, в каждой клеточке размера K на K сжатие
[02:19:15.660 --> 02:19:22.220]  координат за кало K сделать можно, правда? Тогда идея такая, то есть, тогда смотрите,
[02:19:22.220 --> 02:19:30.260]  сколько у нас клеточек? Ну вот, нет, не с этой точки зрения, а в смысле различных клеточек,
[02:19:30.260 --> 02:19:36.140]  вот этих вот с точностью до этих эквивалентностей. Да, ну сжатых, когда у нас, предположим,
[02:19:36.140 --> 02:19:44.780]  в каждой клеточке числа еще и до K. Так, получается K в степени 2K на 2 в степени 2K.
[02:19:44.780 --> 02:19:54.340]  Да, ну пока так пишем, так-то 2K в степени 2K и в каждый из них мы тратим, получается,
[02:19:54.340 --> 02:20:03.660]  как квадрат времени на то, чтобы насчитать динамику. После этого мы теперь перебираем все
[02:20:03.660 --> 02:20:08.500]  клеточки, но в каждой клеточке мы работаем, получается, за кало K, потому что у нас
[02:20:08.500 --> 02:20:18.820]  сжатие координат за столько работает. Так, в общем, в переводе говоря, 2K в степени 2K на K
[02:20:18.820 --> 02:20:31.500]  квадрат, значит, плюс N квадрат, значит, умножить на лог K делить на K. Так, спрашивается, какое бы
[02:20:31.500 --> 02:20:51.300]  к нам подсунуть, чтобы было хорошо. Лог-лог N. Лог-лог N. Единственный... Так, какой, говорите,
[02:20:52.260 --> 02:21:10.580]  так, ну поехали. Итак, 2 лог-лог N в степени 2 лог-лог N на лог-лог N в квадрате плюс N квадрат
[02:21:10.580 --> 02:21:22.500]  умножить на лог-лог-лог N делить на лог-лог N. А теперь, уважаемые издатаки, что из этого больше?
[02:21:22.500 --> 02:21:39.860]  Очевидно. Сейчас будет очевидно, но неверно. А так я не знаю. Я сказал очевидно. Ну, как вам
[02:21:39.860 --> 02:21:48.420]  сказать? Я думаю, знаете, чем вы выгодно отличаетесь от снежного человека? Вам не
[02:21:48.420 --> 02:21:58.060]  нужно читать лекцию про такие понятия, как ирония, сарказм, юмор и так далее. Так, ну ладно,
[02:21:58.060 --> 02:22:02.980]  страшно спрашивать, конечно, но спрашиваю. А сказку о тройке кто-нибудь читал? Так, хорошо,
[02:22:02.980 --> 02:22:09.020]  попроще. Понедельник начинается в субботу. А, ну правильно, да, действительно, как-то книжку
[02:22:09.020 --> 02:22:22.140]  по программисту нужно читать. Ну, программист в институте волшебства, ну, логично. Действительно,
[02:22:22.140 --> 02:22:36.820]  да. Так, и чё? И будет L в степени L, замечательно. И чем это поможет? Так, ну давайте попробуем. Да,
[02:22:36.860 --> 02:22:45.940]  давайте скажем, что N равно 2 в степени 2 в степени L. Так, хорошо, получается 2L в степени 2L на...
[02:22:45.940 --> 02:22:51.500]  что там получается? Так, на L квадрат плюс...
[02:22:51.500 --> 02:23:10.300]  Ну, так, плюс 2 в степени 2 в степени L плюс 1 на... так, L делить на лог L. Ну, я не смеюсь,
[02:23:10.300 --> 02:23:14.540]  это-то 2 в степени 2 в степени, а N квадрат это 2 в степени 2 в степени L умножить на 2,
[02:23:14.540 --> 02:23:30.500]  то есть 2 в степени L плюс 1. Так, и чё? Да, логично, да. Да, вот эта штука действительно равна,
[02:23:30.500 --> 02:23:43.020]  действительно, у нас на самом деле 2 в степени 2L лог 2 в степени 2L. Ну да, здесь вроде и тут
[02:23:43.020 --> 02:23:50.460]  уже действительно становится очевидно, что это что-то прям очень сильно меньше. Да,
[02:23:50.460 --> 02:23:56.340]  что-то... как это? Что-то да, лог-лог это прям сильно мало. Так, ну давайте попробуем,
[02:23:56.340 --> 02:24:15.980]  что ещё можно сделать? Так. Так. Где-то, наверное, возникает. Так, ладно, давайте сделаем попроще.
[02:24:15.980 --> 02:24:30.380]  Так, слушайте, а если я сделаю K равно просто лог N? Чё мы тут логаем-то? Слушайте,
[02:24:30.380 --> 02:24:35.820]  давайте сразу эту идею вообще себе зафиксируем ещё, потому что мне она понравилась. То есть давайте
[02:24:35.820 --> 02:24:41.460]  так, когда непонятно, что такое K в степени K, давайте честно запишем, что на самом деле вот
[02:24:41.460 --> 02:24:52.380]  эта штука, это на самом деле равна, то есть 2 в степени 2K лог 2K на K квадрат плюс N квадрат
[02:24:52.380 --> 02:25:10.260]  на лог K делить на K. Вот, и после этого давайте будем часаться. Это откуда?
[02:25:22.380 --> 02:25:33.220]  Где тут будет лог N квадрат, извиняюсь. Тут просто лог N будет. Будет 2 лог N. Ну,
[02:25:33.220 --> 02:25:53.740]  то есть будет 2 лог N. Давайте. Так, ну давайте попробуем хорошо. K равно лог N делить на
[02:25:53.740 --> 02:26:10.420]  лог N. Так, ну давайте подставлять это. Получается 2 в степени, ой, давайте на 4. Тут уже двойки есть.
[02:26:10.420 --> 02:26:26.860]  Поэтому да. Итак, поехали. 2 в степени лог N делить на 2 лог N. Замечательно. На логарифом этого же
[02:26:26.860 --> 02:26:38.820]  безобразие. Лог N. Так, это ещё домножить на лог N делить на лог N и всё это в квадрате. Так,
[02:26:38.860 --> 02:26:54.860]  что у нас теперь? Плюс N квадрат на... Так, ну поехали. Лог этого безобразия делить на лог N. Делить
[02:26:54.860 --> 02:27:08.580]  на лог N. Делить на лог N. Четёрка, ой-ой-ой. Ну хорошо, давайте тут четёрка. Что тут ещё? Тут
[02:27:08.580 --> 02:27:17.260]  четёрка. И тут четёрка. Ну это мелочи. В общем-то, тихо-тихо это мелочи. Так, ну давайте разбираться.
[02:27:17.260 --> 02:27:26.780]  Ну заметим, что... А что мы заметим-то вообще? Ну ладно. Ну на самом деле с точки зрения
[02:27:26.780 --> 02:27:37.780]  оценки сверху у нас имеет место шлёп-шлёп. Как всегда. Поэтому 2 в степени, тут лог N пополам
[02:27:37.780 --> 02:27:44.180]  остаётся только и получается, что это да. То есть получается что-то типа корень из N сверху на
[02:27:44.180 --> 02:27:51.020]  лог квадрат N. На самом деле надо ещё что-то поделить, но это уже по барабану. И здесь получается...
[02:27:51.020 --> 02:27:58.140]  Так, а тут получается N квадрат. Ну заметим так, а симпатически, кстати, лог от лог N делить на
[02:27:58.140 --> 02:28:03.220]  лог лог N, а симпатически это то же самое, что лог лог N. Ну потому что это равно лог лог N
[02:28:03.220 --> 02:28:11.620]  минус лог лог лог N. А лог лог лог N это очевидно умалое от лог лог N. Вот. Поэтому тут оставляем лог N.
[02:28:11.620 --> 02:28:24.500]  Тут оставляем тоже лог N. И получается тут вообще мистическая штука. Лог N на лог лог N ещё и в квадрете.
[02:28:24.500 --> 02:28:51.220]  Ну конкретно тут... Да, безусловно, безусловно. Поэтому да, у нас проблемы. Ну как проблемы? Мы
[02:28:51.220 --> 02:29:01.740]  получили решение быстрее, чем за N квадрат. Да, это быстрее, чем за N квадрат. Ну теперь вот
[02:29:01.740 --> 02:29:08.580]  остаётся... Ну вот. Так, ну давайте подумаем. А можно ли тут ещё что-нибудь всё-таки пооптимизировать?
[02:29:08.580 --> 02:29:18.180]  Да, как говорили тому же Капелёвичу, а если подумать... Ну это рассказывал, да, как пойти, да.
[02:29:18.180 --> 02:29:27.860]  Как Капелёвичу учили искать Гамильтонов путь. Ну это классическая история. Приходит такой
[02:29:27.860 --> 02:29:32.340]  учитель в красном плаще и говорит, так сегодня мы снова будем учиться программировать. Вот тебе
[02:29:32.340 --> 02:29:38.260]  задача найти Гамильтонов путь в графе. Ну Капелёвич, ну тут перебрать, тут перебрать, тут перебрать. За N
[02:29:38.260 --> 02:29:49.820]  квадрат могу. Так, учитель, а если подумать? Ну тут отсечь, тут отсечь. А да, учитель, вы правы, за N квадрат
[02:29:49.820 --> 02:29:59.060]  можно. Не так неплохо. А теперь подумай, нельзя ли оценить твоё решение лучше? Ну как, учитель?
[02:29:59.060 --> 02:30:12.180]  Используй силу, силу амортизационного анализа. Ой, за N квадрат можно. Именно, вот теперь садись и
[02:30:12.180 --> 02:30:22.380]  пиши, а я пойду отдохну. И, кстати, на тесток Сюги вообще линейно работать будет. Как говорится,
[02:30:22.380 --> 02:30:30.820]  звёздные войны в ЛКШ бывают вот такими. Причём самое, причём действительно очень страшно,
[02:30:30.820 --> 02:30:38.100]  да. Пошли сидеть, да, он сидит, что-то кодит. Господи, как же это за кодить? Ну, там доходящая
[02:30:38.100 --> 02:30:50.060]  сзади фигура в чёрном пафе. Используй силу, силу СТЛ. Да. Так, ну догадывайтесь, на каком языке
[02:30:50.060 --> 02:31:01.780]  светлые силы кодили там, да? И как они назывались, да? Они назывались Джавайи, да. Как назывались,
[02:31:01.780 --> 02:31:08.780]  тёмные силы, рассказывать не надо, да? Вот, да, мистическим образом в ритоте капида, почему-то
[02:31:08.780 --> 02:31:15.660]  в процессе капеллёвки превратился в лопатину, но это другой вопрос, да. Ладно, так вот, ладно,
[02:31:15.660 --> 02:31:21.860]  начнём с первого шара. А если подумать, можно ли тут как-то вот, хотя бы на это, ну, то есть понятно,
[02:31:21.860 --> 02:31:27.340]  тут мы, конечно, уже действительно больше не выжмём, поэтому, а отсюда мы больше можем выжать?
[02:31:27.340 --> 02:31:57.300]  Ну, может, нет. Нет, я говорю, тут не надо переписывать,
[02:31:57.300 --> 02:32:05.740]  я говорю, из алгебры мы больше ничего не сделаем. Тут как бы искать вопрос, а нельзя алгоритм чуть
[02:32:05.740 --> 02:32:16.220]  получше реализовать? Вот давайте, начну с простой подсказки. Такой с простой. А точно прям сжатие
[02:32:17.220 --> 02:32:39.740]  надо делать. Нет, мы уже знаем, что изначально у нас числа от 1 до n.
[02:32:39.740 --> 02:33:04.260]  Ну, по сути так. Заметим, что это каждое сжатие можно проводить за отка просто с помощью хэшмапы.
[02:33:04.260 --> 02:33:12.860]  А теперь заметим, что хэшмапу, если у вас заранее есть заготовленный массив от 1 до n,
[02:33:12.860 --> 02:33:18.580]  то в общем-то хэшмапу можно реализовать без хэшей. То есть как бы, потому что элемент равный и вы
[02:33:18.580 --> 02:33:23.060]  просто записываете в эту ячейку. Главное потом не забыть пробежаться и за те же отка всё там
[02:33:23.060 --> 02:33:29.900]  стереть обратно. Так что на самом деле никаких там лишних логарифмов тут нету и на самом деле
[02:33:29.900 --> 02:33:38.220]  тут н квадрат делить на к. Вот теперь думаем, вот давайте вот этот вот мы убили логарифом.
[02:33:38.220 --> 02:33:52.580]  Спрашивается, что теперь, а что у нас теперь? Так, но на самом деле, да, что поменяется? Да,
[02:33:52.580 --> 02:33:58.340]  но есть подозрение, конечно, что для того, чтобы штука была меньше там меньше н, но где-то
[02:33:58.340 --> 02:34:04.220]  близко к нему, да, то есть чтобы вот эта штука была там какая-то там что-то логарифом n поделить
[02:34:04.220 --> 02:34:10.580]  на что-нибудь там где-нибудь, то тогда оказывается, что оптимальная k примерно такой же. В результате
[02:34:10.580 --> 02:34:17.100]  опять это опять всё не превосходит там корень из n на там лог квадрат n, но разница только в том,
[02:34:17.100 --> 02:34:23.020]  что здесь никакого лога нет, поэтому здесь получается n квадрат на получается ну там 4 на
[02:34:23.020 --> 02:34:38.860]  лог лог н делить на лог н. И квадрата как-то и квадрат алгорифма нету, ещё и лог лог н вылез.
[02:34:38.860 --> 02:34:44.660]  Спрашивается, можно ли сделать что-то ещё?
[02:34:44.660 --> 02:34:59.060]  Да, если по-другому, да, то есть в чём у нас проблема? Да, мы видим, да, у нас есть, конечно,
[02:34:59.060 --> 02:35:06.260]  да, мерзкая проблема в том, что нам как бы, чтобы n квадрат вынужденный после деления на k квадрат
[02:35:06.260 --> 02:35:13.700]  ещё и давно нажать на k, потому что к сожалению сжатие координат у нас, конечно, такое не очень.
[02:35:13.700 --> 02:35:34.740]  Что? Да, только строчки нам дают элементы от 1 до n, поэтому вот так. Нет, ну не совсем,
[02:35:34.740 --> 02:35:49.540]  получится, но в этом направлении направление правильное. Так, так ребят, тихо, тихо, тихо,
[02:35:49.540 --> 02:36:19.540]  тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, т
[02:36:19.540 --> 02:36:49.540]  тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, тихо, т
[02:36:49.540 --> 02:36:55.540]  это не получится второй раз применить мета-четырех вопрос в них уже для такой-то задачи
[02:36:55.540 --> 02:37:01.540]  не знаю, ну пока-пока я не понял что имеется в виду, так что зачем мне здесь нужна вторая константа
[02:37:01.540 --> 02:37:10.540]  вторая не нужна, да, но имеется в виду, что мы можем как-то отдельно жимать карназы, чтобы было быстрее
[02:37:10.540 --> 02:37:17.540]  так, ну да, нет, хотелось бы, нет, ну в принципе да, но на самом деле да, то есть идея тут
[02:37:17.540 --> 02:37:23.540]  действительно в эти стороны бродим туда, мы могли бы пытаться сжимать координаты как-то быстрее
[02:37:23.540 --> 02:37:28.540]  если бы у нас элементы были хотя бы от одного дока или хотя бы от чего-то подобного
[02:37:28.540 --> 02:37:37.540]  поэтому то есть да, то есть на самом деле да, идея здесь конечно в этом месте заключается такая
[02:37:37.540 --> 02:37:42.540]  да, у нас и так есть вот рыжие метаклетки, сейчас мы из них будем делать метаметаклетки
[02:37:42.540 --> 02:37:52.540]  да, ну давайте я это сотру, просто общую картину поняли, да, то есть где-то у нас там то есть черная
[02:37:52.540 --> 02:38:00.540]  клеточка, то есть черная сеточка становится совсем маленькой, маленькой и получается примерно следующее
[02:38:00.540 --> 02:38:07.540]  значит у нас черная, это у нас рыжая, это у нас красная, ну вот, значит у нас, напоминаю, есть рыжие
[02:38:07.540 --> 02:38:23.540]  клеточки размера к, там вот как-то так это выглядит, рыжий маркер посыпался, да ничего, так вот
[02:38:23.540 --> 02:38:32.540]  и так вот теперь, значит, идея такая, что мы на этих клеточках, ну давайте не будем вводить вторую константу
[02:38:32.540 --> 02:38:42.540]  то есть эту сетку из метаклетчик тоже поделим на, то есть метаклет, то есть получается каждый размер вот этой красной клетки
[02:38:42.540 --> 02:38:47.540]  это получается даже не к на к, а даже как квадрат, так как квадрат, то есть к на к метаклетчик
[02:38:47.540 --> 02:39:04.540]  да, мясо, да, ну что делать, вот, что же нам это даст, ну идея такая, мы можем, смотрите, мы можем попытаться
[02:39:04.540 --> 02:39:13.540]  потратить значит на сжатие, ну во-первых, идея такая, то есть давайте сделаем сжатие координат, то есть будем делать сжатие координат
[02:39:13.540 --> 02:39:21.540]  координат сначала по красным клеткам, сколько нам времени это займет, это получается нам займет что-то типа
[02:39:21.540 --> 02:39:34.540]  n квадрат делить на k в четвертый, вот это вот, это как квадрат, вот, каждое будем делать сжатие за k квадрат
[02:39:34.540 --> 02:39:45.540]  так, вот уже и получился n квадрат делить на k квадрат, о котором мы мечтаем, да, вот, значит получается так, хорошо, сжали
[02:39:45.540 --> 02:39:53.540]  так, то есть получается каждую клеточку мы умеем сжимать адекватно, но что это нам дало, это нам теперь дает такое, что в каждой метаклеточке
[02:39:53.540 --> 02:40:09.540]  у нас теперь чиселки от n квадрата, от одного до k квадрат, и получается, ну вот, да как квадрат, для нас как квадрат, но что это нам дает
[02:40:09.540 --> 02:40:19.540]  то теперь просто идея такая, то есть теперь нам надо научиться, для того, чтобы делать сжатие координат в рыжей клеточке, нам теперь нужно научиться получается делать
[02:40:19.540 --> 02:40:34.540]  сжатие координат на, ну вот, сжатие координат, то есть для строчек размера k, но при этом имею в виду, что символы там теперь не от одного до n, а от одного до k квадрат
[02:40:34.540 --> 02:40:55.540]  так, делаем на них тотальный предподсчет, будет у нас он работать за, сколько там получается, получается, что там получается, там что-то типа, ну ладно, давайте сразу скажу
[02:40:55.540 --> 02:41:12.540]  2k квадрат в степени 2k, вы видите, приятно, тут квадрат есть, а тут нет, то есть вот всего столько клеточек, и каждую такую клеточку мы, естественно, обсчитываем за k в квадрате
[02:41:12.540 --> 02:41:27.540]  что это нам дает? то есть это нам на самом деле дает очень много шум, потому что я утверждаю, что мы теперь каждую клеточку теперь проходим за единицу
[02:41:27.540 --> 02:41:47.540]  то есть, ну на самом деле так, как пройти нот, ну точнее так, вот, потому что нот, ну по сути да, то есть с помощью вот этих вот сжатий, то есть у нас получился, так сказать, класс эквалентности для каждой клеточки, точнее ее тип
[02:41:47.540 --> 02:42:02.540]  ну тогда если мы для каждой клеточки вот этой рыжей знаем ее тип, то мы ее проходим за у от единицы, и в результате, то есть потом рыжие, то есть вот этих вот рыжих проходов у нас в конце окажется n квадрат делить на k квадрат
[02:42:02.540 --> 02:42:12.540]  то есть мы добились того, просто что сжатия координат на самом деле тоже стали n квадрат делить на k квадрат, понятно, да?
[02:42:12.540 --> 02:42:22.540]  вот, так, ну вот теперь внимание, вопрос, какое же k теперь мы хотим?
[02:42:22.540 --> 02:42:36.540]  да, да, господи, да, тут прям все одно, да, тут прям, да, прям это, да, скучно, нет, ну почему?
[02:42:36.540 --> 02:42:45.540]  нет, ну почему? ну почему наоборот, иногда даже позитивно, если у вас это, если вам не случайно дали в руки молоток, вы идете при этом, выясняется, что он везде работает
[02:42:45.540 --> 02:43:06.540]  ну как бы у кого-то молоток, у Бахметева, например, это обычная пластиковая бутылка там, ну и так далее, вот, так, и так, поехали, там, соответственно, господи, так, ладно, еще понизим планочку, кто знает, кто такой Андрей Бахметев?
[02:43:06.540 --> 02:43:33.540]  о, кошмар, слушайте, в каких разных мирах мы живем вообще, господи, а кто знает вообще, хорошо, какого-нибудь словосочетания пока все дома что-нибудь говорит, а словосочетания о чумелые ручки, понятно, да, нет, ну хотя ладно, вы уже то поколение, которое телевизор не смотрит, логично, да, да, кошмар, были времена, да
[02:43:36.540 --> 02:44:04.540]  спасибо, я смотрел, если что, да, то-то я туплю, да, действительно, так, значит, поехали, n квадрат плюс 2 в степени 2k лог 2k квадрат на k квадрат, так, мы пытаемся ка подставить вот это вот.
[02:44:06.540 --> 02:44:10.540]  Ну, по большому счету, да, сейчас чего вынести?
[02:44:10.540 --> 02:44:12.540]  4k лог
[02:44:12.540 --> 02:44:13.540]  На 8 надо
[02:44:13.540 --> 02:44:15.540]  Уже на 8?
[02:44:15.540 --> 02:44:19.540]  Да, потому что там k квадрат, лог 2k квадрат, лог еще вынесется
[02:44:19.540 --> 02:44:33.540]  Ой-ой-ой, ну ладно, ну хорошо, 8 так 8, да, хорошо, ладно, это меньше либо равно, чем, давайте так, я пока, пока я не буду, значит, n квадрат k плюс 2 в степени, сколько там получается?
[02:44:33.540 --> 02:44:53.540]  4k лог 2k, еще на k квадрат, ой, ну n квадрат, ну я их в один запихал, неинтересно, неинтересно, так, что еще у нас есть?
[02:44:53.540 --> 02:45:17.540]  Так, хорошо, значит, теперь подставляем, там при подстановке выяснять, что это меньше либо равно, чем, значит, сколько там, 64 n квадрата на лог лог n в квадрате делить на лог n в квадрате, плюс, что там у нас получается?
[02:45:17.540 --> 02:45:46.540]  Так, так, да, ну да, тут как бы и да, подставляем, лог лог n, тут на лог лог n там поубивается, поэтому, да, как всегда, корень из n, там лог квадрат n, так, ой, ну правда странно, видите, тут n, ну да, тут, тут вот возникает вопрос,
[02:45:46.540 --> 02:45:56.540]  а нельзя ли еще поупихивать? Пока это получается тета от n квадрат на лог лог n делить на лог n все это в квадрате.
[02:45:56.540 --> 02:46:02.540]  А что, поможет?
[02:46:02.540 --> 02:46:11.540]  Нет, это да, но конкретно...
[02:46:11.540 --> 02:46:39.540]  Нет, ну вы подозреваете, что вот это слога, да.
[02:46:39.540 --> 02:46:41.540]  Вот это слога, да.
[02:46:41.540 --> 02:46:43.540]  Нет, тут...
[02:46:43.540 --> 02:46:58.540]  Ну да, ну нет, тут это да.
[02:46:58.540 --> 02:47:10.540]  Ну, смотря как менять, если мы увеличиваем k, то мы как бы увеличиваем k, то мы уменьшаем вот эту штуку и увеличиваем вот эту.
[02:47:10.540 --> 02:47:19.540]  То, с другой стороны, заметим, что слишком сильно увеличить эту штуку нельзя, потому что мы k можем увеличить на во сколько там, как там можем увеличить.
[02:47:19.540 --> 02:47:29.540]  То есть, если мы подставим хотя бы 4, то как бы есть риск, что тут уже, как говорится, от n-ты и вылезет.
[02:47:29.540 --> 02:47:36.540]  Вот, поэтому, соответственно, поэтому, кажется, принципиально другому мы тут уже ничего не сделаем.
[02:47:36.540 --> 02:47:51.540]  Ну, значит, придется на этом восстановиться.
[02:47:51.540 --> 02:47:53.540]  Нет, ну хорошо, давай подставим.
[02:47:53.540 --> 02:47:55.540]  Тогда, смотри, тогда что тут будет?
[02:47:55.540 --> 02:48:05.540]  Тогда здесь будет, тогда 4 до 4 тут сократится, будет log n, делить на log log n, умножить на там, на что-то, что там, близко к log log n.
[02:48:05.540 --> 02:48:07.540]  Ну, а симпатически, по крайней мере.
[02:48:07.540 --> 02:48:08.540]  Ну да.
[02:48:08.540 --> 02:48:13.540]  Ну, хотя нет, не совсем, то есть там, хотя нет, там, хотя не, хотя не...
[02:48:13.540 --> 02:48:22.540]  Хотя нет, а знаете что, давайте-ка, может, мы не совсем аккуратно, знаете, все-таки давайте-ка потратим время и подставим.
[02:48:22.540 --> 02:48:28.540]  Вот давайте, подставим, кандидит на 4, но сделаем это предельно, попробуем сделать это предельно аккуратно.
[02:48:28.540 --> 02:48:34.540]  Так, значит, давайте, пишем честно.
[02:48:34.540 --> 02:48:39.540]  Так, ну ладно, тут 64 превращается в 8, тут прям честно, да.
[02:48:39.540 --> 02:48:49.540]  А что тут получается? Откуда? 16. Ну, 16. Ну хорошо, 16, так 16, пожалуйста.
[02:48:49.540 --> 02:49:04.540]  Так, ну давайте разбираться, подставляем 2 в степени, 4, так, ну там пошлеп-шлепали, поэтому log n делить на log log n,
[02:49:04.540 --> 02:49:16.540]  на логарифом log log n делить на 4 log log n, да.
[02:49:16.540 --> 02:49:24.540]  И все это на log n делить на 4 log log n в квадрате, да.
[02:49:24.540 --> 02:49:32.540]  Нет, я по-другому напишу, я... Нет, я не все сотру, я просто скажу, что это как в квадрате.
[02:49:32.540 --> 02:49:37.540]  Понятно, да?
[02:49:37.540 --> 02:49:42.540]  Ну да. Так.
[02:49:42.540 --> 02:49:46.540]  Так, ну хорошо, нет, просто...
[02:49:46.540 --> 02:49:53.540]  Так, нет, просто вопрос, что это даст, просто конкретно тут просто... Нет, у меня просто идея возникла, что это равно...
[02:49:53.540 --> 02:49:59.540]  Что это, допустим, равно пока n квадрат делить на k квадрат, давайте лучше честно напишем, да.
[02:49:59.540 --> 02:50:02.540]  Плюс, смотрите, что это такое.
[02:50:02.540 --> 02:50:13.540]  Дело в том, что на самом деле это равно 2 в степени, log n делить на log log n, и здесь домножить на в скобочках.
[02:50:13.540 --> 02:50:27.540]  Так, тут log log n, в скобочках пишем log log n минус логарифом 4 log log n, на k квадрат.
[02:50:27.540 --> 02:50:32.540]  Вот, что же тут у нас получается.
[02:50:32.540 --> 02:50:37.540]  Это на самом деле равно n квадрат делить на k квадрат, плюс...
[02:50:37.540 --> 02:50:53.540]  Ну на самом деле, в первом, получится, я утверждаю, что 2 в степени на логарифом n делить на 2 в степени логарифом 4...
[02:50:53.540 --> 02:50:55.540]  Нет, не 4.
[02:50:55.540 --> 02:50:58.540]  Там там мясо, да.
[02:50:58.540 --> 02:51:10.540]  Там 2 в степени сейчас log n делить на log log n, а тут логарифом 4 log log n.
[02:51:10.540 --> 02:51:17.540]  Нет, тут, как сказать, если тут скобочек раскрыть, то в одной log log сократится, а в другой тут еще мясо.
[02:51:17.540 --> 02:51:22.540]  А, тут еще и 2 лога, кстати, log log от 4 log log n.
[02:51:22.540 --> 02:51:24.540]  Четверку вынести...
[02:51:30.540 --> 02:51:32.540]  Ну, можно, да, будет.
[02:51:32.540 --> 02:51:33.540]  Так, ну хорошо.
[02:51:33.540 --> 02:51:34.540]  То есть, нет, это получается...
[02:51:34.540 --> 02:51:38.540]  Нет, это, в общем-то, не сильно принципиально.
[02:51:38.540 --> 02:51:40.540]  Там получится просто так.
[02:51:40.540 --> 02:51:47.540]  Получится просто n, а тут придется, если уж в точности его, на что-то поделить.
[02:51:47.540 --> 02:51:49.540]  Причем это, что-то оно...
[02:51:52.540 --> 02:51:54.540]  Это, что-то, да.
[02:51:56.540 --> 02:52:03.540]  Главное, ничем не помогло, потому что симпатику здесь все равно никак не меняет, а тут как бы...
[02:52:03.540 --> 02:52:09.540]  Ну, скажем так, то, что это, как бы, не о малой от n, это нам ставит немножко под угрозу.
[02:52:09.540 --> 02:52:14.540]  Ну, скажем так, это, по-моему, не дает нам сильного ресурса для того, чтобы там была победа.
[02:52:14.540 --> 02:52:16.540]  Я что-то не вижу пока.
[02:52:16.540 --> 02:52:21.540]  Ну, можно просто сказать, что, окей, log-log n это что-то маленькое.
[02:52:21.540 --> 02:52:23.540]  Давайте забьем на него, оценим сверху как.
[02:52:23.540 --> 02:52:25.540]  Но вместо log-log n, напишем...
[02:52:25.540 --> 02:52:28.540]  Вот, лог 4 log-log n, напишем ноль.
[02:52:28.540 --> 02:52:30.540]  И как оно получится?
[02:52:30.540 --> 02:52:33.540]  Вот, то самое n квадрат длинный как квадрат, плюс n как квадрат.
[02:52:33.540 --> 02:52:35.540]  И еще?
[02:52:35.540 --> 02:52:39.540]  Ну, это все еще, это от n квадрат длинный как квадрат.
[02:52:39.540 --> 02:52:47.540]  А чем нам это помогло-то?
[02:52:47.540 --> 02:52:51.540]  Ну, разве что.
[02:52:51.540 --> 02:52:52.540]  Ну, разве что.
[02:52:52.540 --> 02:52:55.540]  Ну, понимаете, пока мы тут не сделаем что-то принципиального, я не знаю.
[02:52:55.540 --> 02:53:00.540]  То есть, не заявим, что k равно log-log n делить на корень из log-log n, например.
[02:53:00.540 --> 02:53:08.540]  Ну, да.
[02:53:08.540 --> 02:53:10.540]  А, ну, какая разница?
[02:53:10.540 --> 02:53:17.540]  Нет, тут как бы была бы мечта только возникает вопрос, а можно ли тут хотя бы одну двоечку log-loga тут убить?
[02:53:17.540 --> 02:53:19.540]  Нет, понимаете, ситуация такая.
[02:53:19.540 --> 02:53:23.540]  Просто мы как бы к чему мы вообще пришли, да?
[02:53:23.540 --> 02:53:32.540]  То есть, мы умеем, получается, решать задачу об n-op в ограничениях, когда у нас элементы сравниваем между собой.
[02:53:32.540 --> 02:53:43.540]  Засим точку n квадрат умножить на log-log n делить на log n и все это в квадрате.
[02:53:43.540 --> 02:53:50.540]  То есть, вот не та мечта, чтобы n квадрат делить на log квадрат, она как бы получилась до log-ru квадрата.
[02:53:50.540 --> 02:53:57.540]  Вопрос было бы круто, конечно, если бы хотя бы двойку из числителя удалось бы убить.
[02:53:57.540 --> 02:54:11.540]  Но, впрочем, если честно, как говорится, я не уверен, что человечество знает, как это сделать.
[02:54:11.540 --> 02:54:13.540]  Ну, в принципе, да.
[02:54:13.540 --> 02:54:22.540]  Я не знаю, есть какие-то подобные идеи из архивной статьи брались, на самом деле.
[02:54:22.540 --> 02:54:30.540]  Но как бы в оптимале log-log в квадрате, то есть у меня иногда было ощущение, что log-log без квадрата.
[02:54:30.540 --> 02:54:33.540]  Но совсем от него избавиться не удается.
[02:54:33.540 --> 02:54:37.540]  Но тем не менее, вот такое выжить удается.
[02:54:37.540 --> 02:54:39.540]  То есть, не то чтобы...
[02:54:39.540 --> 02:54:42.540]  То есть, формально, видимо, чемпионская симптотика.
[02:54:42.540 --> 02:54:46.540]  То есть, вполне верно, что это лучшее, что знает человечество.
[02:54:46.540 --> 02:54:48.540]  Но соответственно.
[02:54:50.540 --> 02:54:54.540]  Так, ну что, есть ли тут какие-то вопросы?
[02:54:58.540 --> 02:55:01.540]  Так, ну если нет, тогда перегрев.
[02:55:01.540 --> 02:55:06.540]  То есть, видимо, суперядерного сегодня уже не будет, потому что тупую уже не успеем.
[02:55:06.540 --> 02:55:10.540]  Вот в следующий раз, видимо, будет тот OLCS по такому раскладу.
[02:55:14.540 --> 02:55:15.540]  В общем, да.
[02:55:15.540 --> 02:55:18.540]  В общем, очень мощная задача на НОП.
[02:55:18.540 --> 02:55:21.540]  Но это будет отдельный взрыв мозга, сразу предупреждаю.
[02:55:21.540 --> 02:55:26.540]  Просто обычно по опыту часа три называется на нее надо.
[02:55:28.540 --> 02:55:31.540]  Нет, ну не знаю, может с вами будет быстрее, я не знаю.
[02:55:32.540 --> 02:55:35.540]  За столько лет он обычно как-то...
[02:55:35.540 --> 02:55:37.540]  Рассказывается, конечно, за полчаса.
[02:55:40.540 --> 02:55:43.540]  Нет, пишется за 10 минут, там код просто минималистичный.
[02:55:45.540 --> 02:55:50.540]  Но проблема в том, что у нас на парке цель, чтобы я не просто рассказал какие-то заклинания,
[02:55:50.540 --> 02:55:52.540]  а чтобы вы еще поняли, о чем это вообще.
[02:55:52.540 --> 02:55:58.540]  А обычно, чтобы с этого разобраться нуля, там все-таки называется три часа обычно надо.
[02:56:02.540 --> 02:56:03.540]  Что?
[02:56:03.540 --> 02:56:05.540]  Нет, ну это был просто ОНОП.
[02:56:05.540 --> 02:56:07.540]  Нет, я имею в виду, что Ляймна ксиста.
[02:56:07.540 --> 02:56:11.540]  Нет, ну погодите, так-то нам придется, как-то надо будет и Хишберга еще обсудить как минимум.
[02:56:12.540 --> 02:56:14.540]  Нет, понятно, что там нечего особо обсуждаю.
[02:56:20.540 --> 02:56:21.540]  Ладно.
[02:56:21.540 --> 02:56:24.540]  Сегодня мы, пожалуй, давайте...
[02:56:24.540 --> 02:56:26.540]  Хочется сегодня закончить просто с деревьями.
[02:56:26.540 --> 02:56:30.540]  Но просто есть такие пара простых, таких вещей, которые достаточно простые,
[02:56:30.540 --> 02:56:32.540]  но как бы просто важно их понимать надо.
[02:56:32.540 --> 02:56:38.540]  Поэтому хочется сегодня обсудить там вместе с антроидной декомпозицией и, собственно, на этом и закончить.
[02:56:42.540 --> 02:56:47.540]  Потому что давайте себе представим данные, конечно же, задачи про изоморфизм деревьев.
[02:56:47.540 --> 02:56:52.540]  Потому что можно сказать, что самые интересные задачи сегодня сейчас будут задачи об изоморфизме деревьев.
[02:56:52.540 --> 02:56:55.540]  То есть даны два дерева, скажите, пожалуйста, изоморфны ли они?
[02:56:55.540 --> 02:56:56.540]  Да или нет?
[02:56:58.540 --> 02:57:01.540]  Ну, в идеале, конечно, еще и желательно, если да, то как?
[02:57:05.540 --> 02:57:06.540]  Да.
[02:57:07.540 --> 02:57:10.540]  Ну, типа, ну, как бы, чтоб чекеру было удобно проверять.
[02:57:12.540 --> 02:57:13.540]  Вот.
[02:57:13.540 --> 02:57:14.540]  А то как бы вот.
[02:57:14.540 --> 02:57:17.540]  Нет, хотя нет, я снова ему, конечно, так и так будет удобно проверять.
[02:57:22.540 --> 02:57:23.540]  Ну да.
[02:57:23.540 --> 02:57:25.540]  Ну да, поэтому я снова проще.
[02:57:25.540 --> 02:57:26.540]  Так-то да.
[02:57:27.540 --> 02:57:35.540]  Но так, по крайней мере, знаете, получается, если есть ЗЕС, то есть если юзер вывел ЗЕС, то его проверить, то как бы его можно заведомо проверить.
[02:57:37.540 --> 02:57:40.540]  Вот, тогда чекеру придется проверить.
[02:57:40.540 --> 02:57:42.540]  Авторский ответ тоже ноут.
[02:57:49.540 --> 02:57:50.540]  Да-да.
[02:57:50.540 --> 02:57:51.540]  Нет, ну если, ну да.
[02:57:53.540 --> 02:57:55.540]  Если нужно знать, существует ли биекция.
[02:57:58.540 --> 02:58:01.540]  Ну окей, ладно, тут уже так, окей, так.
[02:58:01.540 --> 02:58:02.540]  Так.
[02:58:17.540 --> 02:58:18.540]  Ну да, да, да.
[02:58:18.540 --> 02:58:23.540]  Даны два теря, вы видите биекцию между ними, гарантируется, что биекция всегда существует.
[02:58:24.540 --> 02:58:25.540]  Интересная задача.
[02:58:26.540 --> 02:58:27.540]  Можно без автора.
[02:58:28.540 --> 02:58:29.540]  Ну погодите.
[02:58:29.540 --> 02:58:33.540]  Но для начала, для этого придется исследовать вообще, что такое дерево, как оно условно.
[02:58:33.540 --> 02:58:36.540]  Ну понятно, что такое дерево, связанное с гравбис-циклов, это понятно.
[02:58:36.540 --> 02:58:43.540]  Да, что такое подвешенное дерево, дерево, у которого одна вершина почему-то обзывается корнем.
[02:58:43.540 --> 02:58:44.540]  Ну окей.
[02:58:44.540 --> 02:58:47.540]  Ну а первое, конечно, что обсудим, это...
[02:58:47.540 --> 02:58:52.540]  Ну давайте подумаем, что такое вообще эзоморфизм.
[02:58:52.540 --> 02:58:56.540]  Ну на самом деле тут, конечно, можно относиться немножко к топологии.
[02:58:56.540 --> 02:58:58.540]  Чем занимается вообще топология?
[02:58:59.540 --> 02:59:00.540]  Да.
[02:59:07.540 --> 02:59:08.540]  Нет, ну на самом деле нет.
[02:59:08.540 --> 02:59:10.540]  Вот, да, это называется аудез была.
[02:59:10.540 --> 02:59:18.540]  И там, в принципе, топология на самом деле изучает какие-то общие для каких-то вот пространств, поверхностей и так далее инварианты.
[02:59:18.540 --> 02:59:23.540]  Ну то есть по сути, мы там, я не знаю, берем тесто, начинаем его растягивать.
[02:59:23.540 --> 02:59:26.540]  Или там как-то вот там мять или что-нибудь еще с ним в этом смысле делать.
[02:59:26.540 --> 02:59:30.540]  То есть внимание вопросов, какие варианты при этом будут сохраняться.
[02:59:31.540 --> 02:59:32.540]  Вот.
[02:59:32.540 --> 02:59:33.540]  Ну там вот что-то в этом роде.
[02:59:33.540 --> 02:59:34.540]  Ладно.
[02:59:34.540 --> 02:59:35.540]  Не знаю.
[02:59:35.540 --> 02:59:36.540]  Вот.
[02:59:36.540 --> 02:59:37.540]  Так вот, здесь у нас тоже давайте подумать.
[02:59:37.540 --> 02:59:43.540]  Если мы возьмем дерево и начнем у него там вершину перенумерировать, что у него будет сохраняться?
[02:59:46.540 --> 02:59:48.540]  Да, количество вершин, безусловно, будет.
[02:59:48.540 --> 02:59:49.540]  Степень вершин.
[02:59:49.540 --> 02:59:54.540]  Да, набор степеней вершин, конечно, тоже будет сохраняться.
[02:59:56.540 --> 02:59:57.540]  Так.
[02:59:57.540 --> 02:59:59.540]  Ну вот, конечно, такая нетривиальная вещь.
[02:59:59.540 --> 03:00:01.540]  Это, конечно, диаметр.
[03:00:04.540 --> 03:00:05.540]  Не, ну как?
[03:00:05.540 --> 03:00:06.540]  Ну и количество.
[03:00:06.540 --> 03:00:08.540]  В первую очередь, конечно, диаметр.
[03:00:08.540 --> 03:00:11.540]  Но тут, кстати, это уже на самом деле интересная песня.
[03:00:11.540 --> 03:00:13.540]  Потому что вот действительно есть диаметр.
[03:00:13.540 --> 03:00:14.540]  Что такое диаметр?
[03:00:14.540 --> 03:00:16.540]  Это самый длинный простой путь в дереве.
[03:00:16.540 --> 03:00:17.540]  Да?
[03:00:17.540 --> 03:00:19.540]  И теперь очень хочется понять.
[03:00:19.540 --> 03:00:20.540]  Хочется вопрос.
[03:00:20.540 --> 03:00:21.540]  Как его найти?
[03:00:24.540 --> 03:00:25.540]  Да, ну как бы да.
[03:00:25.540 --> 03:00:26.540]  Есть два способа.
[03:00:27.540 --> 03:00:31.540]  Первый называется, давайте запустим две динамики на под деревьях.
[03:00:34.540 --> 03:00:35.540]  А, ну можно даже одну.
[03:00:35.540 --> 03:00:36.540]  Хорошо, можно даже одну.
[03:00:36.540 --> 03:00:37.540]  Ну там по-разному можно делать.
[03:00:38.540 --> 03:00:40.540]  Да, то есть идея в том, что подвесим за какую-нибудь вершину.
[03:00:40.540 --> 03:00:46.540]  И давайте там скажем, для каждой вершины найдем длину пути, у которой лца именно эта вершина.
[03:00:46.540 --> 03:00:48.540]  То есть для этого вам нужно, для каждой вершины,
[03:00:48.540 --> 03:00:50.540]  во-первых, просто научиться насчитывать вот это вот.
[03:00:50.540 --> 03:00:52.540]  Ну что-то типа Logis Post Decomposition.
[03:00:53.540 --> 03:00:56.540]  Ну, короче, самый длинный путь из нее в ребенка.
[03:00:56.540 --> 03:00:59.540]  А потом для каждой вершины, если вы знаете эту штуку для детей,
[03:00:59.540 --> 03:01:02.540]  то надо просто из них выбрать два максимума и через нее поконнектить.
[03:01:03.540 --> 03:01:04.540]  Вот.
[03:01:04.540 --> 03:01:08.540]  То есть этот метод так относительно сложно пишет.
[03:01:08.540 --> 03:01:09.540]  Оно относительно, конечно.
[03:01:10.540 --> 03:01:12.540]  Но зато он самодоказывающийся.
[03:01:14.540 --> 03:01:15.540]  Да.
[03:01:15.540 --> 03:01:18.540]  Но есть, конечно, более известное решение такое популярное.
[03:01:18.540 --> 03:01:20.540]  Просто, конечно, оказывается так.
[03:01:20.540 --> 03:01:23.540]  Берем первую попавшуюся вершину, находим из нее самую удаленную.
[03:01:23.540 --> 03:01:27.540]  Берем эту вершину и из нее находим самую удаленную.
[03:01:27.540 --> 03:01:28.540]  Утверждение.
[03:01:28.540 --> 03:01:29.540]  Вот это диаметр.
[03:01:31.540 --> 03:01:32.540]  Да, это максимально просто.
[03:01:33.540 --> 03:01:35.540]  Может быть, максимально просто пишется для всех.
[03:01:36.540 --> 03:01:37.540]  Только возле нот.
[03:01:37.540 --> 03:01:41.540]  Пока вас не спросят, а почему это найденное вообще имеет отношение к диаметру.
[03:01:41.540 --> 03:01:44.540]  Метрику можно вложить в конечное мирное пространство.
[03:01:47.540 --> 03:01:50.540]  В это пространство это удовлетворение очевидное.
[03:01:53.540 --> 03:01:55.540]  На самом деле, адекватный пруд.
[03:01:55.540 --> 03:01:56.540]  Ты можешь просто по диаметру посмотреть.
[03:01:57.540 --> 03:01:58.540]  Да, да, да.
[03:01:59.540 --> 03:02:02.540]  Если диаметр зафиксировать, то у тебя от каждой вершины
[03:02:02.540 --> 03:02:04.540]  самый дальний путь в нее будет в один из концов диаметра.
[03:02:05.540 --> 03:02:06.540]  Вот так.
[03:02:07.540 --> 03:02:08.540]  Не, смотрите.
[03:02:08.540 --> 03:02:09.540]  Так, погодите, погодите.
[03:02:09.540 --> 03:02:11.540]  Давайте не будем сейчас просто откатать все с места.
[03:02:11.540 --> 03:02:13.540]  Давайте просто все это нарисуем и изучим подробнее.
[03:02:14.540 --> 03:02:16.540]  Тут попутно на самом деле еще будет интересно.
[03:02:17.540 --> 03:02:18.540]  Да, потому что так-то да.
[03:02:18.540 --> 03:02:20.540]  Можно, конечно, вводить там какие-то метрики на конечном
[03:02:20.540 --> 03:02:22.540]  мирном пространствах, но как бы да, знаете.
[03:02:23.540 --> 03:02:26.540]  Но как бы это, да, семиклассником это особо не объяснишь.
[03:02:27.540 --> 03:02:28.540]  Значит, оказывать будем так.
[03:02:29.540 --> 03:02:32.540]  Ну, во-первых, на самом деле интересно посмотреть вот то, что.
[03:02:32.540 --> 03:02:35.540]  Значит, мы посмотрим на два разных случая.
[03:02:35.540 --> 03:02:36.540]  Значит, первый случай.
[03:02:37.540 --> 03:02:39.540]  Наш диаметр делится на два.
[03:02:46.540 --> 03:02:47.540]  Вот так.
[03:02:47.540 --> 03:02:50.540]  Пять, шесть, семь, восемь, девять, десять.
[03:02:53.540 --> 03:02:56.540]  Вот, допустим, я рассмотрю какой-нибудь диаметр.
[03:02:58.540 --> 03:03:03.540]  Вот эту вершину посередине я назову диаметром.
[03:03:03.540 --> 03:03:05.540]  Я назову центр.
[03:03:07.540 --> 03:03:08.540]  То есть я назову центром.
[03:03:08.540 --> 03:03:11.540]  Я назову вершину, которая лежит на сей день какого-то диаметра.
[03:03:13.540 --> 03:03:16.540]  А теперь, значит, смотрите.
[03:03:17.540 --> 03:03:18.540]  Значит, теперь рассмотрим.
[03:03:18.540 --> 03:03:20.540]  Ну, просто вот у какого-то диаметра есть центр.
[03:03:20.540 --> 03:03:22.540]  И от него отходят два пути длины.
[03:03:23.540 --> 03:03:25.540]  Ну, получается вот это вот Д пополам.
[03:03:27.540 --> 03:03:29.540]  Ну, на самом деле много тут отчего отходит.
[03:03:30.540 --> 03:03:31.540]  Тут еще под деревья какие-то есть.
[03:03:31.540 --> 03:03:34.540]  Но можно заметить, что если объявить этот центр корнем,
[03:03:34.540 --> 03:03:40.540]  то отходить мы от него в любую сторону будем на глубину не более чем Д пополам.
[03:03:41.540 --> 03:03:44.540]  Потому что если хоть куда-нибудь мы отойдем на глубину там больше,
[03:03:44.540 --> 03:03:47.540]  то тогда у нас и получится путь больше, чем Д.
[03:03:50.540 --> 03:03:55.540]  Но тогда получается, смотрите, как устроены вообще диаметры в принципе.
[03:03:57.540 --> 03:03:58.540]  Тогда получается диаметры устроены так.
[03:03:59.540 --> 03:04:04.540]  То есть либо они не проходят через вот эту вершину,
[03:04:04.540 --> 03:04:06.540]  но тогда они тут лежат где-то в поддереве,
[03:04:06.540 --> 03:04:11.540]  и они как бы, получается, идут в сторону этого центра,
[03:04:12.540 --> 03:04:15.540]  значит, на расстояние меньше, чем Д пополам,
[03:04:15.540 --> 03:04:17.540]  а потом спускаются на расстояние более, чем Д пополам,
[03:04:17.540 --> 03:04:18.540]  то есть диаметры не получается.
[03:04:20.540 --> 03:04:22.540]  А если они проходят через центр,
[03:04:22.540 --> 03:04:25.540]  то они, значит, из какого-то поддерева подымаются
[03:04:25.540 --> 03:04:27.540]  на длину не более, чем Д пополам
[03:04:27.540 --> 03:04:31.540]  и идут в другое поддерево на длину не более, чем Д пополам.
[03:04:32.540 --> 03:04:34.540]  И более того, диаметром это получится,
[03:04:34.540 --> 03:04:39.540]  только если у вас тут получится ровно Д пополам здесь и ровно Д пополам там.
[03:04:41.540 --> 03:04:45.540]  То есть получается, этот центр будет являться центром не только вот этого первого диаметра,
[03:04:45.540 --> 03:04:48.540]  но и вообще любого диаметра.
[03:04:49.540 --> 03:04:54.540]  То есть мистический факт оказывается в том, что центр в дереве один.
[03:04:55.540 --> 03:04:59.540]  Да, но правда давайте я сразу говорю,
[03:05:00.540 --> 03:05:03.540]  то есть что если диаметр нечетный,
[03:05:04.540 --> 03:05:09.540]  то центром я назову на самом деле не центральную вершину,
[03:05:09.540 --> 03:05:11.540]  а центральное ребро с двумя вершинами.
[03:05:14.540 --> 03:05:17.540]  5, 6, 7, 8, ну допустим 9.
[03:05:17.540 --> 03:05:20.540]  То есть тогда здесь я центром назову вот это ребро
[03:05:21.540 --> 03:05:24.540]  и тогда здесь можно аналогично,
[03:05:24.540 --> 03:05:27.540]  даже еще более простым образом доказать, что центр один.
[03:05:28.540 --> 03:05:30.540]  То есть смотрите, какой интересный факт, видите?
[03:05:30.540 --> 03:05:34.540]  То есть оказывается действительно диаметров у дерева может быть огромное количество,
[03:05:34.540 --> 03:05:36.540]  а центр один.
[03:05:37.540 --> 03:05:39.540]  Неплохо тогда.
[03:05:40.540 --> 03:05:42.540]  Да, кстати, не путать понятия, кстати, внимание,
[03:05:42.540 --> 03:05:45.540]  не путать, пожалуйста, понятие центр с понятием центроид.
[03:05:46.540 --> 03:05:48.540]  Да, потому что многие действительно там путаются,
[03:05:48.540 --> 03:05:52.540]  что-то пугаются, то на самом деле это то есть как бы оба понятия простые,
[03:05:52.540 --> 03:05:54.540]  но просто разные.
[03:05:59.540 --> 03:06:01.540]  Ну, скажем так, вот допустим рассмотрим четный случай.
[03:06:02.540 --> 03:06:04.540]  Рассмотрим любой диаметр.
[03:06:05.540 --> 03:06:06.540]  Как он устроен?
[03:06:07.540 --> 03:06:10.540]  Он, утверждение, этот диаметр через вот этот вот центр,
[03:06:10.540 --> 03:06:12.540]  ну давай назовем эту вершину там В,
[03:06:12.540 --> 03:06:14.540]  через вот эту вершину В точно проходит.
[03:06:14.540 --> 03:06:16.540]  Да, потому что в любом подъеме будет строго меньше.
[03:06:17.540 --> 03:06:20.540]  Но, значит, диаметр проходит через вершину В,
[03:06:20.540 --> 03:06:24.540]  и тогда этот диаметр делится этой вершиной В на два кусочка,
[03:06:24.540 --> 03:06:28.540]  но каждый из этих кусочков длины не более чем D пополам.
[03:06:29.540 --> 03:06:31.540]  Ну, так как там левая часть не более чем D пополам,
[03:06:31.540 --> 03:06:33.540]  правая не более чем D пополам,
[03:06:33.540 --> 03:06:35.540]  но сумма должна быть D.
[03:06:35.540 --> 03:06:38.540]  Следовательно, там D пополам, D пополам, В центр, ура.
[03:06:39.540 --> 03:06:43.540]  Ну, здесь будет то же самое, но там оставим в качестве упражнения.
[03:06:43.540 --> 03:06:45.540]  То есть центр это свойство диаметра?
[03:06:45.540 --> 03:06:47.540]  Нет, это свойство дерева.
[03:06:51.540 --> 03:06:53.540]  То есть как бы у каждой вершины,
[03:06:53.540 --> 03:06:55.540]  то есть у дерева есть такое вот понятие,
[03:06:55.540 --> 03:06:57.540]  как центральный, то есть такой вот просто центр,
[03:06:57.540 --> 03:06:59.540]  и это одна вершина, ну или одно ребро,
[03:06:59.540 --> 03:07:01.540]  которое жестко определяется.
[03:07:05.540 --> 03:07:08.540]  Да, ну просто оказывается, что она от диаметра не зависит.
[03:07:08.540 --> 03:07:11.540]  То есть дальше там начинаются веселые задачи вида,
[03:07:11.540 --> 03:07:13.540]  там найдите количество диаметра в дереве,
[03:07:16.540 --> 03:07:19.540]  ну понятно, по сути, с какими способами можно выбрать лист
[03:07:19.540 --> 03:07:21.540]  на расстоянии D пополам от центра,
[03:07:21.540 --> 03:07:23.540]  из разных поддеревьев.
[03:07:25.540 --> 03:07:27.540]  Для ничего ты еще тупее.
[03:07:27.540 --> 03:07:30.540]  Вот тебе надо просто количество листов из этого поддерева
[03:07:30.540 --> 03:07:32.540]  умножить на количество листов из этого всего.
[03:07:34.540 --> 03:07:36.540]  Да, потому что тут всего два поддерева,
[03:07:36.540 --> 03:07:38.540]  с той стороны и с этой стороны.
[03:07:38.540 --> 03:07:40.540]  Так что вот этот случай даже более сложный,
[03:07:40.540 --> 03:07:43.540]  потому что тут как бы бывает несколько поддеревьев,
[03:07:43.540 --> 03:07:45.540]  они там все могут быть глубины D пополам.
[03:07:45.540 --> 03:07:47.540]  Ну совсем отсылка, вот просто звездочка.
[03:07:52.540 --> 03:07:54.540]  Так, ну теперь, значит,
[03:07:54.540 --> 03:07:56.540]  на самом деле глядя на это понятие,
[03:07:56.540 --> 03:07:58.540]  можно уже подоказывать пару интересных фактов.
[03:07:59.540 --> 03:08:01.540]  Например, докажем наш алгоритм
[03:08:01.540 --> 03:08:03.540]  про поиск диаметра.
[03:08:05.540 --> 03:08:07.540]  Значит, утверждение.
[03:08:07.540 --> 03:08:09.540]  Когда вы запустите первый DFS,
[03:08:09.540 --> 03:08:11.540]  вы попадете обязательно в лист,
[03:08:11.540 --> 03:08:13.540]  который будет находиться
[03:08:13.540 --> 03:08:15.540]  на расстоянии D пополам от центра.
[03:08:17.540 --> 03:08:19.540]  Почему?
[03:08:19.540 --> 03:08:21.540]  Ну как минимум,
[03:08:21.540 --> 03:08:23.540]  допустим, вы находитесь на расстоянии
[03:08:23.540 --> 03:08:25.540]  L от центра.
[03:08:27.540 --> 03:08:29.540]  Ну тогда утверждение такое.
[03:08:29.540 --> 03:08:31.540]  Во-первых, вы не уйдете
[03:08:31.540 --> 03:08:33.540]  на расстояние от этой вершины
[03:08:33.540 --> 03:08:35.540]  на расстояние больше, чем
[03:08:35.540 --> 03:08:37.540]  L плюс D пополам.
[03:08:37.540 --> 03:08:39.540]  Ну потому что вы некоторое время
[03:08:39.540 --> 03:08:41.540]  будете приближаться к центру,
[03:08:41.540 --> 03:08:43.540]  а потом уйдете от этого центра куда-то,
[03:08:43.540 --> 03:08:45.540]  но дальше, чем на D пополам, не уйдете.
[03:08:45.540 --> 03:08:47.540]  Утверждение номер два.
[03:08:47.540 --> 03:08:49.540]  На такое расстояние вы пройдете.
[03:08:49.540 --> 03:08:51.540]  Для этого вам нужно просто пройти
[03:08:51.540 --> 03:08:53.540]  вот эти L, а потом уйти в другое под дерево.
[03:08:55.540 --> 03:08:57.540]  Но очевидно, что для этого вам придется
[03:08:57.540 --> 03:08:59.540]  именно что уйти в лист на расстоянии D пополам.
[03:09:01.540 --> 03:09:03.540]  То есть вывод.
[03:09:03.540 --> 03:09:05.540]  После первого DFS вы попали в лист на расстоянии D пополам от центра.
[03:09:05.540 --> 03:09:07.540]  Но при этом
[03:09:07.540 --> 03:09:09.540]  мы заметим тогда, что любой такой лист является концом
[03:09:09.540 --> 03:09:11.540]  какого-то диаметра.
[03:09:11.540 --> 03:09:13.540]  Потому что вы просто идете в центр
[03:09:13.540 --> 03:09:15.540]  и знаете, что тут
[03:09:15.540 --> 03:09:17.540]  существует еще хотя бы одно под дерево
[03:09:17.540 --> 03:09:19.540]  с расстоянием D.
[03:09:19.540 --> 03:09:21.540]  Но потому что вы знали, что у вас их в принципе два.
[03:09:21.540 --> 03:09:23.540]  Хотя бы два. Может три, четыре, пять.
[03:09:25.540 --> 03:09:27.540]  Попута, кстати.
[03:09:27.540 --> 03:09:29.540]  Ну попута, естественно, вы еще...
[03:09:29.540 --> 03:09:31.540]  Таким образом мы нашли диаметр,
[03:09:31.540 --> 03:09:33.540]  ну и соответственно центр, кстати, тоже.
[03:09:37.540 --> 03:09:39.540]  Потому что
[03:09:39.540 --> 03:09:41.540]  мы можем пройти
[03:09:41.540 --> 03:09:43.540]  за расстояние L до центра.
[03:09:43.540 --> 03:09:45.540]  И теперь мы знаем, что существует другое
[03:09:45.540 --> 03:09:47.540]  под дерево, в котором глубина
[03:09:47.540 --> 03:09:49.540]  ровно D пополам.
[03:09:49.540 --> 03:09:51.540]  Но мы знаем,
[03:09:51.540 --> 03:09:53.540]  что существует хотя бы два, поэтому если мы из одного
[03:09:53.540 --> 03:09:55.540]  из них пришли, значит пойдем в другое.
[03:09:57.540 --> 03:09:59.540]  А в том же
[03:09:59.540 --> 03:10:01.540]  под дереве... Нет,
[03:10:01.540 --> 03:10:03.540]  тогда бы мы до центра не дашли, если бы не вылезали
[03:10:03.540 --> 03:10:05.540]  из того же под дерева.
[03:10:05.540 --> 03:10:07.540]  Просто утверждение, существует хотя бы два
[03:10:07.540 --> 03:10:09.540]  под дерева, глубина D пополам.
[03:10:09.540 --> 03:10:11.540]  Ну потому что какой-то диаметр
[03:10:11.540 --> 03:10:13.540]  существует. Тогда если
[03:10:13.540 --> 03:10:15.540]  ты пришел из одного под дерева, просто
[03:10:15.540 --> 03:10:17.540]  пойдем в другое.
[03:10:17.540 --> 03:10:19.540]  То есть у нас вопрос, что оно существует.
[03:10:19.540 --> 03:10:21.540]  И мы можем так сделать.
[03:10:27.540 --> 03:10:29.540]  Таким образом получается, что
[03:10:29.540 --> 03:10:31.540]  диаметр находится, центр
[03:10:31.540 --> 03:10:33.540]  находится.
[03:10:33.540 --> 03:10:35.540]  Но тут
[03:10:35.540 --> 03:10:37.540]  на самом деле неожиданно выясняется, что мы можем
[03:10:37.540 --> 03:10:39.540]  решить и задачу про изоморфизм
[03:10:39.540 --> 03:10:41.540]  деревьев.
[03:10:43.540 --> 03:10:45.540]  Потому что отсюда уже возникает наша
[03:10:45.540 --> 03:10:47.540]  первая неожиданная оптимизация.
[03:10:49.540 --> 03:10:51.540]  Мы знаем вершины, которые точно
[03:10:51.540 --> 03:10:53.540]  должны переходить друг в друга.
[03:10:55.540 --> 03:10:57.540]  Первое, что мы должны проверить,
[03:10:57.540 --> 03:10:59.540]  а вообще одинаковые ли у них
[03:10:59.540 --> 03:11:01.540]  диаметры? Если у деревьев
[03:11:01.540 --> 03:11:03.540]  разные диаметры, то, в принципе, до свидания
[03:11:03.540 --> 03:11:05.540]  сразу. Ну можно еще там пару
[03:11:05.540 --> 03:11:07.540]  метров проверить. Ну можете, пожалуйста,
[03:11:07.540 --> 03:11:09.540]  там проверить себе стее, там набор
[03:11:09.540 --> 03:11:11.540]  степеней вершин, там, пожалуйста, и так далее.
[03:11:13.540 --> 03:11:15.540]  Там все что угодно. Но так, в принципе,
[03:11:15.540 --> 03:11:17.540]  вы находите диаметры. Но если
[03:11:17.540 --> 03:11:19.540]  диаметры совпали, то значит
[03:11:19.540 --> 03:11:21.540]  центры должны переходить друг в друга.
[03:11:23.540 --> 03:11:25.540]  В этом случае вам повезло, если диаметр чётной длины,
[03:11:25.540 --> 03:11:27.540]  потому что центр прямо переходит чётко
[03:11:27.540 --> 03:11:29.540]  в центр.
[03:11:29.540 --> 03:11:31.540]  Здесь все хитрее, здесь у вас, в принципе,
[03:11:31.540 --> 03:11:33.540]  два варианта есть.
[03:11:33.540 --> 03:11:35.540]  Ну там есть вот это вот центральное
[03:11:35.540 --> 03:11:37.540]  ребро. Оно как бы может совпадать вот так, может
[03:11:37.540 --> 03:11:39.540]  вот так.
[03:11:39.540 --> 03:11:41.540]  Но это все
[03:11:41.540 --> 03:11:43.540]  с точностью до
[03:11:43.540 --> 03:11:45.540]  домножения на константу сводит
[03:11:45.540 --> 03:11:47.540]  задачу
[03:11:47.540 --> 03:11:49.540]  к проверке изоморфизма
[03:11:49.540 --> 03:11:51.540]  подвешенных деревьев.
[03:11:51.540 --> 03:11:53.540]  То есть корни у нас не было,
[03:11:53.540 --> 03:11:55.540]  но оказывается для нас это за ОАТН
[03:11:55.540 --> 03:11:57.540]  не проблема.
[03:11:57.540 --> 03:11:59.540]  Итак, задача.
[03:11:59.540 --> 03:12:01.540]  Даны два подвешенных дерева.
[03:12:01.540 --> 03:12:03.540]  Разрешается
[03:12:03.540 --> 03:12:05.540]  изоморфизм, рассматриваемый изоморфизм,
[03:12:05.540 --> 03:12:07.540]  только переводящий корень в корень.
[03:12:07.540 --> 03:12:09.540]  Спрашивается, изоморфны
[03:12:09.540 --> 03:12:11.540]  ли деревья?
[03:12:13.540 --> 03:12:15.540]  Вот такая
[03:12:15.540 --> 03:12:17.540]  задача.
[03:12:19.540 --> 03:12:21.540]  Да, мы нашли за что подвесить.
[03:12:21.540 --> 03:12:23.540]  Да.
[03:12:27.540 --> 03:12:29.540]  Да.
[03:12:41.540 --> 03:12:43.540]  Да.
[03:12:43.540 --> 03:12:45.540]  Напрашивающаяся идея, давайте
[03:12:45.540 --> 03:12:47.540]  хэшировать подвешенные
[03:12:47.540 --> 03:12:49.540]  под деревья.
[03:12:53.540 --> 03:12:55.540]  Ну, на самом деле можно, но сейчас
[03:12:55.540 --> 03:12:57.540]  дойдем. Да, как это ни странно,
[03:12:57.540 --> 03:12:59.540]  в данном случае нам поможет
[03:12:59.540 --> 03:13:01.540]  хэширование, просто мы научимся
[03:13:01.540 --> 03:13:03.540]  делать это без хэшей.
[03:13:05.540 --> 03:13:07.540]  Ну, потому что идея такая.
[03:13:07.540 --> 03:13:09.540]  Потому что, ну, на самом деле основное,
[03:13:09.540 --> 03:13:11.540]  что нам хочется, потому что идея как бы такая,
[03:13:11.540 --> 03:13:13.540]  то есть как хэшировать под дерево.
[03:13:13.540 --> 03:13:15.540]  Надо пойти в его детей,
[03:13:15.540 --> 03:13:17.540]  из каждого
[03:13:17.540 --> 03:13:19.540]  дерева,
[03:13:19.540 --> 03:13:21.540]  значит,
[03:13:21.540 --> 03:13:23.540]  из каждого дерева, под дерева
[03:13:23.540 --> 03:13:25.540]  рекурсивно достать хэш.
[03:13:25.540 --> 03:13:27.540]  Ну, дальше, так как у нас с точностью
[03:13:27.540 --> 03:13:29.540]  дозиморфизма отсортировать
[03:13:29.540 --> 03:13:31.540]  эти хэши.
[03:13:31.540 --> 03:13:33.540]  Прямо посортировать в явном виде.
[03:13:33.540 --> 03:13:35.540]  И у вас получается такой
[03:13:35.540 --> 03:13:37.540]  четверной, то есть там
[03:13:37.540 --> 03:13:39.540]  массив, в данном случае на 4 хэша,
[03:13:39.540 --> 03:13:41.540]  в данном случае на сколько там детей.
[03:13:41.540 --> 03:13:43.540]  И, собственно, остается вам только захэшировать
[03:13:43.540 --> 03:13:45.540]  вектор.
[03:13:45.540 --> 03:13:47.540]  Вот, понимаете, да?
[03:13:49.540 --> 03:13:51.540]  То есть, ну, там хэш какой-нибудь,
[03:13:51.540 --> 03:13:53.540]  наверное, можно придумать.
[03:13:57.540 --> 03:13:59.540]  Ну, да.
[03:13:59.540 --> 03:14:01.540]  Ну, по сути,
[03:14:01.540 --> 03:14:03.540]  N log N, ладно, формально там, конечно,
[03:14:03.540 --> 03:14:05.540]  формально в таком виде,
[03:14:05.540 --> 03:14:07.540]  ну, если вы адекватно хэш какой-нибудь полинамиальный делаете,
[03:14:07.540 --> 03:14:09.540]  допустим,
[03:14:09.540 --> 03:14:11.540]  то там получается
[03:14:11.540 --> 03:14:13.540]  N
[03:14:13.540 --> 03:14:15.540]  log, там максимальная степень,
[03:14:15.540 --> 03:14:17.540]  на самом деле, если внимательно думать.
[03:14:21.540 --> 03:14:23.540]  А, ну,
[03:14:23.540 --> 03:14:25.540]  в принципе, смотрите,
[03:14:25.540 --> 03:14:27.540]  ну, есть чит такой,
[03:14:27.540 --> 03:14:29.540]  нет, есть еще чит такой,
[03:14:29.540 --> 03:14:31.540]  но, на самом деле, каждому дереву можно сопоставлять
[03:14:31.540 --> 03:14:33.540]  правильные скобочные последствия, правда?
[03:14:33.540 --> 03:14:35.540]  Так вот, идея такая, а можно сопоставлять их
[03:14:35.540 --> 03:14:37.540]  аккуратным образом.
[03:14:37.540 --> 03:14:39.540]  А именно, когда вам достаетесь деревья в правильные
[03:14:39.540 --> 03:14:41.540]  скобочные последовательсти, вы сортируете.
[03:14:43.540 --> 03:14:45.540]  И только после этого там вот начинается
[03:14:45.540 --> 03:14:47.540]  ставить, то есть вот как бы заводите 4 скобочки
[03:14:47.540 --> 03:14:49.540]  и вставляете в них вот эти вот скобочные
[03:14:49.540 --> 03:14:51.540]  последствия, снято 4, но только вы их
[03:14:51.540 --> 03:14:53.540]  лексикографически сортируете.
[03:15:09.540 --> 03:15:11.540]  Не, ну, можно не добавлять,
[03:15:11.540 --> 03:15:13.540]  если у тебя одна, ну, скажем так,
[03:15:13.540 --> 03:15:15.540]  сейчас.
[03:15:17.540 --> 03:15:19.540]  Ну, там, да, можно сказать, что, да,
[03:15:19.540 --> 03:15:21.540]  если у тебя одна вершина, то, допустим,
[03:15:21.540 --> 03:15:23.540]  там просто пустая последовательность,
[03:15:23.540 --> 03:15:25.540]  например.
[03:15:25.540 --> 03:15:27.540]  А если у тебя кайдите, то вот рисуем
[03:15:27.540 --> 03:15:29.540]  вот это, вот и все.
[03:15:29.540 --> 03:15:31.540]  Вот, например, так.
[03:15:31.540 --> 03:15:33.540]  Вот, то есть, выглядит вот такое.
[03:15:33.540 --> 03:15:35.540]  Но теперь возникает вопрос, а можно ли обойтись
[03:15:35.540 --> 03:15:37.540]  без хэшей?
[03:15:37.540 --> 03:15:39.540]  Оказывается,
[03:15:39.540 --> 03:15:41.540]  вполне можно.
[03:15:41.540 --> 03:15:43.540]  То есть, идея
[03:15:43.540 --> 03:15:45.540]  на самом деле такая.
[03:15:55.540 --> 03:15:57.540]  Ну, да, но
[03:15:57.540 --> 03:15:59.540]  правда тут, конечно, там.
[03:16:05.540 --> 03:16:07.540]  Поради,
[03:16:07.540 --> 03:16:09.540]  какой суффиксный массив, если
[03:16:09.540 --> 03:16:11.540]  так, да, но несколько строчек отсортирую их,
[03:16:11.540 --> 03:16:13.540]  а какой?
[03:16:15.540 --> 03:16:17.540]  Так, нет, ну, хорошо,
[03:16:17.540 --> 03:16:19.540]  да, ну, тут, хорошо, да,
[03:16:19.540 --> 03:16:21.540]  то там проблема в том, да, какая
[03:16:21.540 --> 03:16:23.540]  суммарная длина будет.
[03:16:23.540 --> 03:16:25.540]  То есть, сколько суммарно?
[03:16:25.540 --> 03:16:27.540]  То есть, в каждой вершине ты будешь работать за от
[03:16:27.540 --> 03:16:29.540]  количества вершин в подделье.
[03:16:35.540 --> 03:16:37.540]  А приравных?
[03:16:39.540 --> 03:16:41.540]  Можно переливать.
[03:16:47.540 --> 03:16:49.540]  Нет, в явном виде переливать.
[03:16:49.540 --> 03:16:51.540]  Нет, вообще,
[03:16:51.540 --> 03:16:53.540]  вообще, идея хорошая.
[03:16:53.540 --> 03:16:55.540]  Нет, смотрите, да, можно на эту тему подумать.
[03:16:55.540 --> 03:16:57.540]  Смотрите, давайте подумаем, действительно,
[03:16:57.540 --> 03:16:59.540]  что давайте сортировать последствия
[03:16:59.540 --> 03:17:01.540]  в первую очередь по количеству вершин в подделье.
[03:17:01.540 --> 03:17:03.540]  Ну, СССР мы можем посчитать.
[03:17:03.540 --> 03:17:05.540]  Да, замечательно.
[03:17:05.540 --> 03:17:07.540]  Остается только вопрос, то есть, теперь идея такая.
[03:17:07.540 --> 03:17:09.540]  Давайте только, если у нас есть равные
[03:17:09.540 --> 03:17:11.540]  по размеру под дерево последствия,
[03:17:11.540 --> 03:17:13.540]  тогда мы их тут,
[03:17:13.540 --> 03:17:15.540]  тогда мы с ними будем что-то делать.
[03:17:15.540 --> 03:17:17.540]  Да.
[03:17:17.540 --> 03:17:19.540]  Чего?
[03:17:21.540 --> 03:17:23.540]  Нет, при равных размерах, ну,
[03:17:23.540 --> 03:17:25.540]  нет, ну, их надо отсортировать и сеграфически, чтобы было однозначно.
[03:17:31.540 --> 03:17:33.540]  Ну, я и говорю, сначала по размеру,
[03:17:33.540 --> 03:17:35.540]  потом минимально и сеграфически, это да.
[03:17:35.540 --> 03:17:37.540]  Нам нужна однозначность, да.
[03:17:37.540 --> 03:17:39.540]  Но давайте только, если у нас нашлись равные СССР,
[03:17:39.540 --> 03:17:41.540]  тогда мы для них
[03:17:41.540 --> 03:17:43.540]  уже эти скобочные последовательности
[03:17:43.540 --> 03:17:45.540]  там как-то, там, видимо, в явном виде
[03:17:45.540 --> 03:17:47.540]  генерируем.
[03:17:47.540 --> 03:17:49.540]  Там генерируем, сравниваем и выбираем, кто первый,
[03:17:49.540 --> 03:17:51.540]  кто второй, кто третий.
[03:17:53.540 --> 03:17:55.540]  Ну, номер он тоже длинный, так что не поможет.
[03:17:57.540 --> 03:17:59.540]  Вот, так вот.
[03:17:59.540 --> 03:18:01.540]  Хорошо, скобочные последствия.
[03:18:01.540 --> 03:18:03.540]  Почему-то какие-то переливашенные моменты
[03:18:03.540 --> 03:18:05.540]  намекают, что это тоже может работать за n лог n или
[03:18:05.540 --> 03:18:07.540]  хотя бы n лог квадрат.
[03:18:07.540 --> 03:18:09.540]  Нет, но давайте думать.
[03:18:11.540 --> 03:18:13.540]  Нет, давайте думать.
[03:18:13.540 --> 03:18:15.540]  Ну, действительно, давайте подумаем,
[03:18:15.540 --> 03:18:17.540]  как это действительно может быть.
[03:18:19.540 --> 03:18:21.540]  Ну, на самом деле, то есть, заметим следующее,
[03:18:21.540 --> 03:18:23.540]  что можно сказать, что когда мы сортируем
[03:18:23.540 --> 03:18:25.540]  скобочные последствия, мы просто
[03:18:25.540 --> 03:18:27.540]  говорим, что у нас, что у нас тут,
[03:18:27.540 --> 03:18:29.540]  то есть, вот, допустим, если у нас оказалось,
[03:18:29.540 --> 03:18:31.540]  что вот эти поддеревья равны,
[03:18:31.540 --> 03:18:33.540]  то тогда мы можем в некотором смысле сказать,
[03:18:33.540 --> 03:18:35.540]  что каждая вершина этого поддерева
[03:18:35.540 --> 03:18:37.540]  участвует вот в этом вот сравнении.
[03:18:39.540 --> 03:18:41.540]  И мы делаем это сравнение за o от количества
[03:18:41.540 --> 03:18:43.540]  вершин в этих деревьях.
[03:18:51.540 --> 03:18:53.540]  Ну, честно, выписали стройские сравнения
[03:18:53.540 --> 03:18:55.540]  с помощью бора, например.
[03:18:55.540 --> 03:18:57.540]  От количества вершин
[03:18:57.540 --> 03:18:59.540]  с равными размерами?
[03:18:59.540 --> 03:19:01.540]  Нет, от количества вершин
[03:19:01.540 --> 03:19:03.540]  в равных по СС
[03:19:03.540 --> 03:19:05.540]  под деревьях.
[03:19:05.540 --> 03:19:07.540]  Вот.
[03:19:07.540 --> 03:19:09.540]  И тогда вычекает вопрос. То есть, получается,
[03:19:09.540 --> 03:19:11.540]  можем будем говорить, что в таких сравнениях
[03:19:11.540 --> 03:19:13.540]  все вершины под деревья участвуют.
[03:19:13.540 --> 03:19:15.540]  Просто это удобно мыслить. Удобно мыслить
[03:19:15.540 --> 03:19:17.540]  в следующих терминах. А сколько раз
[03:19:17.540 --> 03:19:19.540]  каждая конкретная вершина
[03:19:19.540 --> 03:19:21.540]  на самом деле может участвовать
[03:19:21.540 --> 03:19:23.540]  в такого рода сравнениях?
[03:19:25.540 --> 03:19:27.540]  Ну, заметим.
[03:19:27.540 --> 03:19:29.540]  Я утверждаю, что логарифм.
[03:19:29.540 --> 03:19:31.540]  Потому что если размер
[03:19:31.540 --> 03:19:33.540]  вот этого поддерева x и вот вершина
[03:19:33.540 --> 03:19:35.540]  в нем участвует, то если на более
[03:19:35.540 --> 03:19:37.540]  высоком уровне эта вершина опять будет
[03:19:37.540 --> 03:19:39.540]  участвовать там в более высоких вершинах,
[03:19:39.540 --> 03:19:41.540]  то ССС там будет уже как минимум 2х.
[03:19:43.540 --> 03:19:45.540]  Ну вот. Так что в результате
[03:19:45.540 --> 03:19:47.540]  так что получился.
[03:19:47.540 --> 03:19:49.540]  Единственное только, алгоритм
[03:19:49.540 --> 03:19:51.540]  будет такой технически сложный
[03:19:51.540 --> 03:19:53.540]  немножко в том плане, что вам придется, конечно,
[03:19:53.540 --> 03:19:55.540]  эту правильную скобочку в последствии в явном
[03:19:55.540 --> 03:19:57.540]  виде выписывать.
[03:19:57.540 --> 03:19:59.540]  Бор это не проблема
[03:19:59.540 --> 03:20:01.540]  сделать на две скобочки.
[03:20:05.540 --> 03:20:07.540]  Единственная проблема, что эти строчки
[03:20:07.540 --> 03:20:09.540]  надо геней, то там это как бы понятно.
[03:20:09.540 --> 03:20:11.540]  Потому что вам в каждой вершине нужно расписывать
[03:20:11.540 --> 03:20:13.540]  в каком порядке перебирать ребра.
[03:20:13.540 --> 03:20:15.540]  Если вы этот порядок знаете,
[03:20:15.540 --> 03:20:17.540]  то ДФСом выписать в последствии не проблема.
[03:20:23.540 --> 03:20:27.540]  Нет, а лог квадрат никто не претендует.
[03:20:27.540 --> 03:20:29.540]  Это и так лог.
[03:20:35.540 --> 03:20:37.540]  Нет, погоди, погоди.
[03:20:37.540 --> 03:20:39.540]  Мы сначала сортируем
[03:20:39.540 --> 03:20:41.540]  по СССшкам,
[03:20:41.540 --> 03:20:43.540]  я имел в виду, а потом
[03:20:43.540 --> 03:20:45.540]  только для равных СССшек
[03:20:45.540 --> 03:20:47.540]  мы забабахиваем борт для каждой своего.
[03:20:49.540 --> 03:20:51.540]  Так что
[03:20:51.540 --> 03:20:53.540]  получается такой лог.
[03:20:53.540 --> 03:20:55.540]  Но я все-таки расскажу
[03:20:55.540 --> 03:20:57.540]  другой алгоритм за лог.
[03:20:57.540 --> 03:20:59.540]  Просто на мой вкус сильно проще.
[03:20:59.540 --> 03:21:01.540]  Ну пишется прям на муа.
[03:21:01.540 --> 03:21:03.540]  Значит, смотрите.
[03:21:03.540 --> 03:21:05.540]  То есть на самом деле он будет базироваться
[03:21:05.540 --> 03:21:07.540]  на тех же самых хэшах.
[03:21:11.540 --> 03:21:13.540]  Значит, смотрите.
[03:21:13.540 --> 03:21:15.540]  Идея будет в том, что мы будем
[03:21:15.540 --> 03:21:17.540]  запускать вершину.
[03:21:17.540 --> 03:21:19.540]  То есть когда мы запускаем ДФС,
[03:21:19.540 --> 03:21:21.540]  наша цель,
[03:21:21.540 --> 03:21:23.540]  то есть прийти в вершину и выйти из нее,
[03:21:23.540 --> 03:21:25.540]  сказав, что
[03:21:25.540 --> 03:21:27.540]  эта вершина имеет
[03:21:27.540 --> 03:21:29.540]  поддерева типа
[03:21:29.540 --> 03:21:31.540]  L.
[03:21:31.540 --> 03:21:33.540]  Где L это какое-то число
[03:21:33.540 --> 03:21:35.540]  в нашем случае от 0
[03:21:35.540 --> 03:21:37.540]  до 2n-1.
[03:21:37.540 --> 03:21:39.540]  В общем, 2n-1.
[03:21:41.540 --> 03:21:43.540]  То есть что мы хотим?
[03:21:43.540 --> 03:21:45.540]  У каждой вершины есть свое поддерево.
[03:21:45.540 --> 03:21:47.540]  Я хочу, чтобы
[03:21:47.540 --> 03:21:49.540]  придать им такие номера, чтобы
[03:21:49.540 --> 03:21:51.540]  понятно, изомовные
[03:21:51.540 --> 03:21:53.540]  поддеревья получили одинаковые
[03:21:53.540 --> 03:21:55.540]  номера, а не изомовные разные.
[03:21:55.540 --> 03:21:57.540]  Понятно, да?
[03:21:59.540 --> 03:22:01.540]  Ну вот так вот.
[03:22:01.540 --> 03:22:03.540]  Тогда у меня возникает
[03:22:03.540 --> 03:22:05.540]  такая неожиданная идея.
[03:22:05.540 --> 03:22:07.540]  Как же мне это сделать?
[03:22:07.540 --> 03:22:09.540]  Делать я это буду
[03:22:09.540 --> 03:22:11.540]  весьма неожиданным образом.
[03:22:11.540 --> 03:22:13.540]  Я заведу
[03:22:13.540 --> 03:22:15.540]  маптик
[03:22:15.540 --> 03:22:17.540]  из вектора
[03:22:21.540 --> 03:22:23.540]  и назову ее
[03:22:23.540 --> 03:22:25.540]  не тратя здесь силы
[03:22:25.540 --> 03:22:27.540]  на фантазию.
[03:22:29.540 --> 03:22:31.540]  Так вот, идея у меня будет очень простая.
[03:22:31.540 --> 03:22:33.540]  Значит, как я буду давать
[03:22:33.540 --> 03:22:35.540]  номер в вершине? Очень просто.
[03:22:35.540 --> 03:22:37.540]  Я возьму вершину,
[03:22:37.540 --> 03:22:39.540]  посмотрю, у нее детей.
[03:22:39.540 --> 03:22:41.540]  DFS мне вернет
[03:22:41.540 --> 03:22:43.540]  номера L1, L2, L3
[03:22:43.540 --> 03:22:45.540]  и так далее.
[03:22:45.540 --> 03:22:47.540]  Я эти номера
[03:22:47.540 --> 03:22:49.540]  отсортирую.
[03:22:51.540 --> 03:22:53.540]  Это уже номера. Если они равны, значит
[03:22:53.540 --> 03:22:55.540]  у них поддеревья изомовные.
[03:22:55.540 --> 03:22:57.540]  И проверю.
[03:22:57.540 --> 03:22:59.540]  Запихну эти элементы в вектор
[03:22:59.540 --> 03:23:01.540]  и проверю, есть ли у меня
[03:23:01.540 --> 03:23:03.540]  такой вектор в маптике.
[03:23:07.540 --> 03:23:09.540]  Если есть, то тогда в этом маптике будет
[03:23:09.540 --> 03:23:11.540]  записан просто номер.
[03:23:11.540 --> 03:23:13.540]  Что нужно, чтобы
[03:23:13.540 --> 03:23:15.540]  задать дерево?
[03:23:15.540 --> 03:23:17.540]  Чтобы задать тип дерева,
[03:23:17.540 --> 03:23:19.540]  на самом деле он вполне
[03:23:19.540 --> 03:23:21.540]  однозначно восстанавливается по типам
[03:23:21.540 --> 03:23:23.540]  поддеревьев своих детей.
[03:23:25.540 --> 03:23:27.540]  Например,
[03:23:27.540 --> 03:23:29.540]  сразу можно заметить, что
[03:23:29.540 --> 03:23:31.540]  дерево из одной вершины
[03:23:31.540 --> 03:23:33.540]  задается просто пустым вектором.
[03:23:35.540 --> 03:23:37.540]  У меня ноль детей.
[03:23:37.540 --> 03:23:39.540]  Вот такая
[03:23:39.540 --> 03:23:41.540]  штука. Я просто
[03:23:41.540 --> 03:23:43.540]  проверяю, есть ли этот
[03:23:43.540 --> 03:23:45.540]  вектор здесь. Если да, то записываю
[03:23:45.540 --> 03:23:47.540]  вершину V то, что тут написано. Если
[03:23:47.540 --> 03:23:49.540]  нет, то значит я тогда записываю
[03:23:49.540 --> 03:23:51.540]  там вершину V, что такого поддерева
[03:23:51.540 --> 03:23:53.540]  не было и оно у нас теперь появилось.
[03:23:57.540 --> 03:23:59.540]  Вот и все решение.
[03:23:59.540 --> 03:24:01.540]  Я запускаю это сначала для одного дерева,
[03:24:01.540 --> 03:24:03.540]  потом не затирая мапа для
[03:24:03.540 --> 03:24:05.540]  другого. Если у
[03:24:05.540 --> 03:24:07.540]  меня у корней
[03:24:07.540 --> 03:24:09.540]  получился один тип, мы победили,
[03:24:09.540 --> 03:24:11.540]  то значит они заморфны. Если нет,
[03:24:11.540 --> 03:24:13.540]  нет.
[03:24:23.540 --> 03:24:25.540]  Да, да, смотрите, вот да, действительно
[03:24:25.540 --> 03:24:27.540]  такой тонкий момент. Кажется, что
[03:24:27.540 --> 03:24:29.540]  вектора сравниваются за линию.
[03:24:29.540 --> 03:24:31.540]  Это правда, но за какую?
[03:24:31.540 --> 03:24:33.540]  Если вы ищете в мапе вектор размера
[03:24:33.540 --> 03:24:35.540]  там Z, то все сравнения
[03:24:35.540 --> 03:24:37.540]  этого вектора с соседями будут
[03:24:37.540 --> 03:24:39.540]  выполняться за O от Z.
[03:24:43.540 --> 03:24:45.540]  Но сумма
[03:24:45.540 --> 03:24:47.540]  Z по всем вершинам
[03:24:47.540 --> 03:24:49.540]  это практически
[03:24:49.540 --> 03:24:51.540]  суммарное количество детей
[03:24:51.540 --> 03:24:53.540]  у всех вершин, то есть N-1.
[03:24:53.540 --> 03:24:55.540]  То есть суммарно получается
[03:24:55.540 --> 03:24:57.540]  эти поиски в мапочках у вас появятся
[03:24:57.540 --> 03:24:59.540]  за N логом.
[03:25:03.540 --> 03:25:05.540]  А зачем?
[03:25:05.540 --> 03:25:07.540]  Ну без мапы мы делали абсолютно те же самые
[03:25:07.540 --> 03:25:09.540]  хэши, просто
[03:25:09.540 --> 03:25:11.540]  там более
[03:25:11.540 --> 03:25:13.540]  с каких? Да ладно!
[03:25:13.540 --> 03:25:15.540]  Давай, слушай,
[03:25:15.540 --> 03:25:17.540]  давай
[03:25:17.540 --> 03:25:19.540]  давай, слушай, нормально
[03:25:19.540 --> 03:25:21.540]  давай, ты живешь в мире, где есть 11 и 14
[03:25:21.540 --> 03:25:23.540]  стандарты, это как бы дохалялось.
[03:25:25.540 --> 03:25:27.540]  Ну нормально, ну и что? Ну и кайф.
[03:25:29.540 --> 03:25:31.540]  Господи, чем тут мап векторов-то вообще?
[03:25:33.540 --> 03:25:35.540]  Да я не знаю, нет,
[03:25:35.540 --> 03:25:37.540]  я извиняюсь.
[03:25:39.540 --> 03:25:41.540]  Нет, нет, просто
[03:25:41.540 --> 03:25:43.540]  что тут может быть
[03:25:43.540 --> 03:25:45.540]  неприятного? Смотри.
[03:25:47.540 --> 03:25:49.540]  Ну а в чем
[03:25:49.540 --> 03:25:51.540]  неприятность?
[03:25:51.540 --> 03:25:53.540]  В чем неприятность? Тут просто 10-10
[03:25:53.540 --> 03:25:55.540]  кайфюжных строчек.
[03:25:55.540 --> 03:25:57.540]  Большой ключ в мапе
[03:25:57.540 --> 03:25:59.540]  интуитивно.
[03:25:59.540 --> 03:26:01.540]  Но надо просто,
[03:26:01.540 --> 03:26:03.540]  но как бы это надо иногда смотреть,
[03:26:03.540 --> 03:26:05.540]  как всегда, если есть какая-то проблема,
[03:26:05.540 --> 03:26:07.540]  два варианта, либо ее всеми правдами
[03:26:07.540 --> 03:26:09.540]  правдами обвести, либо посмотреть на нее внимательно,
[03:26:09.540 --> 03:26:11.540]  и возможно понять, что она не такая большая, как кажется.
[03:26:13.540 --> 03:26:15.540]  Мы с этим столкнемся,
[03:26:15.540 --> 03:26:17.540]  когда будем пытаться искать,
[03:26:17.540 --> 03:26:19.540]  скажем, проверять, лежит ли
[03:26:19.540 --> 03:26:21.540]  точка в ногу уголики.
[03:26:21.540 --> 03:26:23.540]  Ну то есть стандартный метод
[03:26:23.540 --> 03:26:25.540]  известен, пустим луч, там найдем,
[03:26:25.540 --> 03:26:27.540]  сколько там, сколько пересеклось,
[03:26:27.540 --> 03:26:29.540]  поделим на 2, да?
[03:26:29.540 --> 03:26:31.540]  Да, не выпукло, конечно.
[03:26:31.540 --> 03:26:33.540]  И тогда мы теряем вопрос. У вас проблема.
[03:26:33.540 --> 03:26:35.540]  Луч может проходить через вершину.
[03:26:37.540 --> 03:26:39.540]  Есть куча решений.
[03:26:39.540 --> 03:26:41.540]  Запустим случайные
[03:26:41.540 --> 03:26:43.540]  лучи, запустим
[03:26:43.540 --> 03:26:45.540]  правильно
[03:26:45.540 --> 03:26:47.540]  подогнанную бисектрису.
[03:26:47.540 --> 03:26:49.540]  Ну там, правда,
[03:26:49.540 --> 03:26:51.540]  есть горизонтальный луч, есть
[03:26:51.540 --> 03:26:53.540]  самый низкий луч из всех,
[03:26:53.540 --> 03:26:55.540]  запустим там между ними
[03:26:55.540 --> 03:26:57.540]  что угодно между ними, вот этот вектор плюс
[03:26:57.540 --> 03:26:59.540]  этот вектор, например, запустим.
[03:26:59.540 --> 03:27:01.540]  Если эти точки целые,
[03:27:01.540 --> 03:27:03.540]  давайте запустим луч в направлении
[03:27:03.540 --> 03:27:05.540]  миллиард запятая один.
[03:27:05.540 --> 03:27:07.540]  Уже этого хватит, на самом деле.
[03:27:07.540 --> 03:27:09.540]  Все что угодно можно делать.
[03:27:09.540 --> 03:27:11.540]  А есть неожиданный читерский метод
[03:27:11.540 --> 03:27:13.540]  в качестве анонса.
[03:27:13.540 --> 03:27:15.540]  А давайте тут запустим луч влево.
[03:27:17.540 --> 03:27:19.540]  Да, может проходить через вершины,
[03:27:19.540 --> 03:27:21.540]  но давайте внимательно рассмотрим случай,
[03:27:21.540 --> 03:27:23.540]  и выяснится, что на самом деле там все не так сложно,
[03:27:23.540 --> 03:27:25.540]  и на самом деле там получается все очень просто.
[03:27:25.540 --> 03:27:27.540]  Там говорится так,
[03:27:27.540 --> 03:27:29.540]  если у вас какое-то ребро пересекает этот луч
[03:27:29.540 --> 03:27:31.540]  или имеет с ним хотя бы одну общую точку,
[03:27:31.540 --> 03:27:33.540]  то тогда вы
[03:27:33.540 --> 03:27:35.540]  прибавляете один,
[03:27:35.540 --> 03:27:37.540]  если одна точка, одна вершина
[03:27:37.540 --> 03:27:39.540]  строго выше, а другая
[03:27:39.540 --> 03:27:41.540]  не строго ниже.
[03:27:41.540 --> 03:27:43.540]  Остается только на бумажке
[03:27:43.540 --> 03:27:45.540]  просто аккуратно проверить все случаи
[03:27:45.540 --> 03:27:47.540]  и убедиться, что это работает.
[03:27:55.540 --> 03:27:57.540]  Да, там...
[03:28:01.540 --> 03:28:03.540]  Ну, не важно.
[03:28:03.540 --> 03:28:05.540]  Ладно.
[03:28:05.540 --> 03:28:07.540]  Нет, спокойно.
[03:28:07.540 --> 03:28:09.540]  Сумма углов
[03:28:09.540 --> 03:28:11.540]  это мерзкие даблы.
[03:28:11.540 --> 03:28:13.540]  Даб.
[03:28:17.540 --> 03:28:19.540]  Да,
[03:28:19.540 --> 03:28:21.540]  но по константе...
[03:28:21.540 --> 03:28:23.540]  Нет, смотри.
[03:28:23.540 --> 03:28:25.540]  Нет, просто
[03:28:25.540 --> 03:28:27.540]  это будет очень жирно,
[03:28:27.540 --> 03:28:29.540]  потому что сам по себе угол, даже Сатан 2,
[03:28:29.540 --> 03:28:31.540]  это больно.
[03:28:31.540 --> 03:28:33.540]  То есть да, по точности проблем
[03:28:33.540 --> 03:28:35.540]  нет, конечно, действительно, скорее всего,
[03:28:35.540 --> 03:28:37.540]  но...
[03:28:41.540 --> 03:28:43.540]  Граничка угла комплексной
[03:28:43.540 --> 03:28:45.540]  число по модулю.
[03:28:45.540 --> 03:28:47.540]  Это проблем вообще никаких нет.
[03:28:47.540 --> 03:28:49.540]  Летает.
[03:28:49.540 --> 03:28:51.540]  Летает и точность идеальна.
[03:28:51.540 --> 03:28:53.540]  Летает и точность идеальна.
[03:28:55.540 --> 03:28:57.540]  Издевательство.
[03:28:57.540 --> 03:28:59.540]  Да.
[03:28:59.540 --> 03:29:01.540]  Да, главное, чтоб там при умножении эти целые числа
[03:29:01.540 --> 03:29:03.540]  не ушли в бесконечность куда-нибудь.
[03:29:03.540 --> 03:29:05.540]  Ладно.
[03:29:05.540 --> 03:29:07.540]  Сколько у нас там времени?
[03:29:07.540 --> 03:29:09.540]  Так.
[03:29:11.540 --> 03:29:13.540]  Сейчас
[03:29:13.540 --> 03:29:15.540]  чуть-чуть.
[03:29:15.540 --> 03:29:17.540]  Так.
[03:29:17.540 --> 03:29:19.540]  Да.
[03:29:19.540 --> 03:29:21.540]  Ну, значит,
[03:29:21.540 --> 03:29:23.540]  что еще, конечно?
[03:29:23.540 --> 03:29:25.540]  Ну, ладно, давайте за оставшиеся
[03:29:25.540 --> 03:29:27.540]  20 такое.
[03:29:27.540 --> 03:29:29.540]  Можно вопросить?
[03:29:29.540 --> 03:29:31.540]  Вот у нас почему
[03:29:31.540 --> 03:29:33.540]  мы можем от 0
[03:29:33.540 --> 03:29:35.540]  до 0-1?
[03:29:35.540 --> 03:29:37.540]  Нет, у нас вершина.
[03:29:37.540 --> 03:29:39.540]  Состояние тоже.
[03:29:39.540 --> 03:29:41.540]  У нас два дерева, у нас еще втранили.
[03:29:41.540 --> 03:29:43.540]  А мы же как раз хотим,
[03:29:43.540 --> 03:29:45.540]  чтобы у нас состояние потом сзали.
[03:29:45.540 --> 03:29:47.540]  Не, в целом, да,
[03:29:47.540 --> 03:29:49.540]  можно сделать навиады просто
[03:29:49.540 --> 03:29:51.540]  если у нас по переустановлению состояние
[03:29:51.540 --> 03:29:53.540]  говорит, чтобы мы уже
[03:29:53.540 --> 03:29:55.540]  просто потом как в итоге сравниваем?
[03:29:55.540 --> 03:29:57.540]  Мы в корнях сравним состояние?
[03:29:57.540 --> 03:29:59.540]  Да.
[03:29:59.540 --> 03:30:01.540]  Да.
[03:30:01.540 --> 03:30:03.540]  Вот.
[03:30:03.540 --> 03:30:05.540]  Но да, в принципе, даже после этого
[03:30:05.540 --> 03:30:07.540]  в качестве бонуса вообще уже теперь начинаем
[03:30:07.540 --> 03:30:09.540]  писать на запросы в духе даны две вершины
[03:30:09.540 --> 03:30:11.540]  и заморфнули под деревья в них.
[03:30:11.540 --> 03:30:13.540]  Ну вот.
[03:30:13.540 --> 03:30:15.540]  Да, даже такие
[03:30:15.540 --> 03:30:17.540]  развлечения уже начинаются.
[03:30:17.540 --> 03:30:19.540]  Вот.
[03:30:19.540 --> 03:30:21.540]  На самом.
[03:30:21.540 --> 03:30:23.540]  Так вот.
[03:30:23.540 --> 03:30:25.540]  А можно ли отвечать
[03:30:25.540 --> 03:30:27.540]  на
[03:30:27.540 --> 03:30:29.540]  можно ли делать предподсчет
[03:30:29.540 --> 03:30:31.540]  за N?
[03:30:31.540 --> 03:30:33.540]  Предподсчет за N?
[03:30:33.540 --> 03:30:35.540]  Нет, там сортировать по-любому придется,
[03:30:35.540 --> 03:30:37.540]  поэтому
[03:30:37.540 --> 03:30:39.540]  честно говоря, да.
[03:30:39.540 --> 03:30:41.540]  Да.
[03:30:41.540 --> 03:30:43.540]  Чисто.
[03:30:43.540 --> 03:30:45.540]  Да.
[03:30:45.540 --> 03:30:47.540]  Да.
[03:30:47.540 --> 03:30:49.540]  Да.
[03:30:49.540 --> 03:30:51.540]  Да.
[03:30:51.540 --> 03:30:53.540]  Да.
[03:30:53.540 --> 03:30:55.540]  Да.
[03:30:55.540 --> 03:30:57.540]  Да.
[03:30:57.540 --> 03:30:59.540]  Да.
[03:30:59.540 --> 03:31:01.540]  Так.
[03:31:01.540 --> 03:31:03.540]  Идем дальше.
[03:31:03.540 --> 03:31:05.540]  Следующий вопрос.
[03:31:05.540 --> 03:31:07.540]  Так. Значит.
[03:31:07.540 --> 03:31:09.540]  Для этого, конечно, у нас
[03:31:09.540 --> 03:31:11.540]  помимо центра, конечно, у нас
[03:31:11.540 --> 03:31:13.540]  бывают, конечно, еще и немножко другие объекты.
[03:31:15.540 --> 03:31:17.540]  Вот. Ну, например.
[03:31:17.540 --> 03:31:19.540]  Нет.
[03:31:19.540 --> 03:31:21.540]  Нет. Ну, например, какая нот.
[03:31:21.540 --> 03:31:23.540]  Ну, то есть тут у нас всякое бывает.
[03:31:23.540 --> 03:31:25.540]  Потому что, например, есть такая классическая
[03:31:25.540 --> 03:31:27.540]  задача.
[03:31:27.540 --> 03:31:29.540]  То есть есть там какая-нибудь классическая
[03:31:29.540 --> 03:31:31.540]  задача. Ну, например,
[03:31:31.540 --> 03:31:33.540]  в простом виде, конечно, скажем.
[03:31:33.540 --> 03:31:35.540]  Да, но дерево на вершинах. Скажите, пожалуйста.
[03:31:35.540 --> 03:31:37.540]  Да, но дерево.
[03:31:37.540 --> 03:31:39.540]  Причем даже взвешенное дерево.
[03:31:39.540 --> 03:31:41.540]  То есть у каждого ребра есть
[03:31:41.540 --> 03:31:43.540]  там какие-то длины. Допустим,
[03:31:43.540 --> 03:31:45.540]  положительные, хотя это может быть даже
[03:31:45.540 --> 03:31:47.540]  отрицательные.
[03:31:47.540 --> 03:31:49.540]  Скажите, пожалуйста.
[03:31:49.540 --> 03:31:51.540]  А есть ли
[03:31:51.540 --> 03:31:53.540]  две вершины?
[03:31:53.540 --> 03:31:55.540]  Сумма весов
[03:31:55.540 --> 03:31:57.540]  ребер на пути между ними.
[03:31:57.540 --> 03:31:59.540]  Такие-таки равно
[03:31:59.540 --> 03:32:01.540]  к, где k это
[03:32:01.540 --> 03:32:03.540]  заданное число.
[03:32:03.540 --> 03:32:05.540]  Чего?
[03:32:05.540 --> 03:32:07.540]  Так.
[03:32:07.540 --> 03:32:09.540]  По высотам.
[03:32:09.540 --> 03:32:11.540]  Ну, вот.
[03:32:11.540 --> 03:32:13.540]  Ну, вот.
[03:32:13.540 --> 03:32:15.540]  Ну, вот.
[03:32:15.540 --> 03:32:17.540]  Ну, давайте так.
[03:32:17.540 --> 03:32:19.540]  Это задача может быть относительно простой.
[03:32:19.540 --> 03:32:21.540]  В том плане,
[03:32:21.540 --> 03:32:23.540]  что, конечно, так. То есть в принципе
[03:32:23.540 --> 03:32:25.540]  есть такое. Тут есть два стандарта.
[03:32:25.540 --> 03:32:27.540]  Как ее решать?
[03:32:29.540 --> 03:32:31.540]  Нет.
[03:32:31.540 --> 03:32:33.540]  В первой пока переливайка.
[03:32:37.540 --> 03:32:39.540]  Ну, то есть,
[03:32:39.540 --> 03:32:41.540]  может быть,
[03:32:41.540 --> 03:32:43.540]  по-хорошему надо было бы
[03:32:43.540 --> 03:32:45.540]  разключить компьютер и немножко покудить.
[03:32:45.540 --> 03:32:47.540]  Ну, давайте поговорим о чем речь.
[03:32:47.540 --> 03:32:49.540]  Ну, потому что идея
[03:32:49.540 --> 03:32:51.540]  на самом деле такая,
[03:32:51.540 --> 03:32:53.540]  что хочется запустить
[03:32:53.540 --> 03:32:55.540]  ДФС.
[03:32:55.540 --> 03:32:57.540]  И очень хочется, чтобы
[03:32:57.540 --> 03:32:59.540]  в каждой вершине,
[03:32:59.540 --> 03:33:01.540]  когда мы выходим из нее,
[03:33:01.540 --> 03:33:03.540]  у нас был сет расстояний,
[03:33:03.540 --> 03:33:05.540]  который мы можем получить идея из этой вершины
[03:33:05.540 --> 03:33:07.540]  в под деревья.
[03:33:07.540 --> 03:33:09.540]  Ну, идея в том, что
[03:33:09.540 --> 03:33:11.540]  когда у нас у вершины,
[03:33:11.540 --> 03:33:13.540]  скажем, три ребенка,
[03:33:13.540 --> 03:33:15.540]  то мы должны взять эти три сета и их объединить.
[03:33:15.540 --> 03:33:17.540]  Правда, с оговоркой,
[03:33:17.540 --> 03:33:19.540]  что эти сеты перед тем, как объедить,
[03:33:19.540 --> 03:33:21.540]  мы к сетам должны прибавить
[03:33:21.540 --> 03:33:23.540]  чиселку.
[03:33:23.540 --> 03:33:25.540]  Тут просто, видимо, надо достать покудить,
[03:33:25.540 --> 03:33:27.540]  потому что по умолчанию можно сказать,
[03:33:27.540 --> 03:33:29.540]  что этот сет мы напишем самостоятельно,
[03:33:29.540 --> 03:33:31.540]  поэтому прибавление на под деревья для нас не проблема.
[03:33:31.540 --> 03:33:33.540]  Но я надеюсь, в этом месте
[03:33:33.540 --> 03:33:35.540]  никто так не пишет.
[03:33:35.540 --> 03:33:37.540]  Ну, смотрите,
[03:33:37.540 --> 03:33:39.540]  прежде чем объединять, вам придется
[03:33:39.540 --> 03:33:41.540]  ко всем вот этим вот элементам
[03:33:41.540 --> 03:33:43.540]  прибавить чиселку.
[03:33:43.540 --> 03:33:45.540]  Теперь внимание, вопрос.
[03:33:45.540 --> 03:33:47.540]  Как это делать
[03:33:47.540 --> 03:33:49.540]  без отложенных операций
[03:33:49.540 --> 03:33:51.540]  в декортичках?
[03:33:51.540 --> 03:33:53.540]  Ну, да.
[03:33:53.540 --> 03:33:55.540]  Ну, честно говоря,
[03:33:55.540 --> 03:33:57.540]  я в этом месте люблю хранить даже не пару,
[03:33:57.540 --> 03:33:59.540]  а просто структуру.
[03:33:59.540 --> 03:34:01.540]  Но оказывается очень
[03:34:01.540 --> 03:34:03.540]  удобно.
[03:34:03.540 --> 03:34:05.540]  Я сейчас просто на уровне
[03:34:05.540 --> 03:34:07.540]  концепции показываю, я часто пишу.
[03:34:07.540 --> 03:34:09.540]  То есть я это называю
[03:34:09.540 --> 03:34:11.540]  set with add.
[03:34:11.540 --> 03:34:13.540]  Я
[03:34:13.540 --> 03:34:15.540]  люблю
[03:34:15.540 --> 03:34:17.540]  предельно часто в ней храним, понятно,
[03:34:17.540 --> 03:34:19.540]  set int
[03:34:19.540 --> 03:34:21.540]  там s
[03:34:21.540 --> 03:34:23.540]  и там int вот этот add.
[03:34:23.540 --> 03:34:25.540]  То есть
[03:34:25.540 --> 03:34:27.540]  чтобы понять, какие у меня элементы в сетте,
[03:34:27.540 --> 03:34:29.540]  я должен взять элементы этого сеттайка, всем
[03:34:29.540 --> 03:34:31.540]  им прибавить вот это число.
[03:34:31.540 --> 03:34:33.540]  Ну, то есть такая
[03:34:33.540 --> 03:34:35.540]  отложенная операция, но фишка,
[03:34:35.540 --> 03:34:37.540]  но мы здесь гарантируем, что у нас отложенная операция есть только
[03:34:37.540 --> 03:34:39.540]  на всем дереве, а не на под деревьях.
[03:34:39.540 --> 03:34:41.540]  Вот.
[03:34:41.540 --> 03:34:43.540]  Я тут прям честно, дальше
[03:34:43.540 --> 03:34:45.540]  я просто честно начинаю прописывать методы.
[03:34:45.540 --> 03:34:47.540]  То есть там
[03:34:47.540 --> 03:34:49.540]  честный метод там, допустим,
[03:34:49.540 --> 03:34:51.540]  insert,
[03:34:51.540 --> 03:34:53.540]  там какой-нибудь insert от x.
[03:34:53.540 --> 03:34:55.540]  Так, значит,
[03:34:55.540 --> 03:34:57.540]  я не знаю, там bool там,
[03:34:57.540 --> 03:34:59.540]  я не знаю, count от x.
[03:35:01.540 --> 03:35:03.540]  Там какой-нибудь, ну, можно bool,
[03:35:03.540 --> 03:35:05.540]  можно int. А, ну, кстати, size
[03:35:05.540 --> 03:35:07.540]  не помешает.
[03:35:07.540 --> 03:35:09.540]  Что там еще надо?
[03:35:09.540 --> 03:35:11.540]  А, еще я очень люблю, конечно,
[03:35:11.540 --> 03:35:13.540]  написать метод
[03:35:13.540 --> 03:35:15.540]  clear
[03:35:15.540 --> 03:35:17.540]  и люблю еще
[03:35:17.540 --> 03:35:19.540]  написать метод вида, а выдай
[03:35:19.540 --> 03:35:21.540]  мне все элементы, которые у тебя есть
[03:35:21.540 --> 03:35:23.540]  в виде вектора.
[03:35:25.540 --> 03:35:27.540]  Вот прям вот, знаете, вот очень полезно
[03:35:27.540 --> 03:35:29.540]  написать. То есть я не буду прописывать,
[03:35:29.540 --> 03:35:31.540]  конечно, этот метод очень просто пишется,
[03:35:31.540 --> 03:35:33.540]  но просто
[03:35:33.540 --> 03:35:35.540]  это технически, опять же, хорошо, потому что
[03:35:35.540 --> 03:35:37.540]  с помощью таких,
[03:35:37.540 --> 03:35:39.540]  то есть пользовать эти сеты и сливать их, потом легко
[03:35:39.540 --> 03:35:41.540]  приятно. То есть как
[03:35:41.540 --> 03:35:43.540]  слить, то есть как теперь объединить такие
[03:35:43.540 --> 03:35:45.540]  два сета? Ну, очень просто. Надо добавить
[03:35:45.540 --> 03:35:47.540]  элементы меньшего в большее, а меньшие зачистить.
[03:35:47.540 --> 03:35:49.540]  Надо еще push сделать.
[03:35:49.540 --> 03:35:51.540]  Ах, да, да, да, да, да, да, да, да.
[03:35:51.540 --> 03:35:53.540]  Да, да, да, да, void,
[03:35:53.540 --> 03:35:55.540]  add to all
[03:35:55.540 --> 03:35:57.540]  от x.
[03:35:57.540 --> 03:35:59.540]  Да.
[03:35:59.540 --> 03:36:01.540]  Просто от x.
[03:36:01.540 --> 03:36:03.540]  Нет, ну, а зачем?
[03:36:03.540 --> 03:36:05.540]  Нет, ну, Гитаря просто...
[03:36:05.540 --> 03:36:07.540]  А, все, да, да.
[03:36:07.540 --> 03:36:09.540]  Нужно add to all, и нам еще нужно функции, которые
[03:36:09.540 --> 03:36:11.540]  будут для удобства пропушивать, когда мы не сливать
[03:36:11.540 --> 03:36:13.540]  два сета. Зачем нам функции?
[03:36:13.540 --> 03:36:15.540]  Нет, фун...
[03:36:15.540 --> 03:36:17.540]  Да, нам это...
[03:36:17.540 --> 03:36:19.540]  Ну, нет, просто нет.
[03:36:19.540 --> 03:36:21.540]  Get all это делает, да.
[03:36:21.540 --> 03:36:23.540]  Нет, get all...
[03:36:23.540 --> 03:36:25.540]  Нет, в этом и фишка.
[03:36:25.540 --> 03:36:27.540]  Особенно правильное мышление какое-то должно быть.
[03:36:27.540 --> 03:36:29.540]  Я реализую черный ящик,
[03:36:29.540 --> 03:36:31.540]  который умеет реализовать вот эти методы.
[03:36:31.540 --> 03:36:33.540]  Как он там внутри себя устроен,
[03:36:33.540 --> 03:36:35.540]  на самом деле, с точки зрения интерфейса, мне абсолютно
[03:36:35.540 --> 03:36:37.540]  торчать. Вот эти сеты, это я вообще
[03:36:37.540 --> 03:36:39.540]  должен в приват запихнуть.
[03:36:39.540 --> 03:36:41.540]  То есть это вот так
[03:36:41.540 --> 03:36:43.540]  должно быть. То есть в идеале это
[03:36:43.540 --> 03:36:45.540]  такой класс, и вот это
[03:36:45.540 --> 03:36:47.540]  методы должны быть в паблике.
[03:36:47.540 --> 03:36:49.540]  Все остальное, вот это в привате.
[03:36:49.540 --> 03:36:51.540]  И важный принцип объекта
[03:36:51.540 --> 03:36:53.540]  амбицировать, когда вы пишите просто
[03:36:53.540 --> 03:36:55.540]  сложные, то есть сложенные с кусочком задачи,
[03:36:55.540 --> 03:36:57.540]  то есть вы пишете, должны писать
[03:36:57.540 --> 03:36:59.540]  систему черных ящиков. То есть когда вы пишете
[03:36:59.540 --> 03:37:01.540]  сам черный ящик, вам...
[03:37:01.540 --> 03:37:03.540]  То есть вы изначально
[03:37:03.540 --> 03:37:05.540]  продумали, какие методы там должны быть,
[03:37:05.540 --> 03:37:07.540]  но потом, когда вы уже определились с интерфейсом,
[03:37:07.540 --> 03:37:09.540]  когда вы пишете черный ящик, вам абсолютно
[03:37:09.540 --> 03:37:11.540]  начхать, в каком порядке
[03:37:11.540 --> 03:37:13.540]  его используют.
[03:37:13.540 --> 03:37:15.540]  А когда вы используете черный ящик,
[03:37:15.540 --> 03:37:17.540]  то есть прописываете то, как
[03:37:17.540 --> 03:37:19.540]  он используется, вам должно быть абсолютно
[03:37:19.540 --> 03:37:21.540]  начхать, что он конкретно внутри
[03:37:21.540 --> 03:37:23.540]  делает, что он к кому прибавляет и
[03:37:23.540 --> 03:37:25.540]  так далее.
[03:37:25.540 --> 03:37:27.540]  Понятно, да?
[03:37:27.540 --> 03:37:29.540]  То есть это на самом деле просто...
[03:37:29.540 --> 03:37:31.540]  То есть как бы это и вероятность
[03:37:31.540 --> 03:37:33.540]  ошибки уменьшает и
[03:37:33.540 --> 03:37:35.540]  увеличивает считабельность вашего кода.
[03:37:35.540 --> 03:37:37.540]  Потому что вы знаете, что когда вы читаете этот код,
[03:37:37.540 --> 03:37:39.540]  вы думаете только об этой вот задаче, а когда
[03:37:39.540 --> 03:37:41.540]  вы читаете другую часть, вы
[03:37:41.540 --> 03:37:43.540]  о внутренностях не думаете.
[03:37:43.540 --> 03:37:45.540]  То есть вы думаете о том, что, возможно,
[03:37:45.540 --> 03:37:47.540]  вы это неправильно использовали.
[03:37:53.540 --> 03:37:55.540]  Ну, можно и так. Нет, у нас была задача
[03:37:55.540 --> 03:37:57.540]  просто... Я сформулировал,
[03:37:57.540 --> 03:37:59.540]  есть ли да или нет, да, можно было бы
[03:37:59.540 --> 03:38:01.540]  сформулировать в виде сколько, да,
[03:38:01.540 --> 03:38:03.540]  но это по барабадам, можно
[03:38:03.540 --> 03:38:05.540]  мапочки, да, то есть можно сливаемые
[03:38:05.540 --> 03:38:07.540]  мапочки сделать, да, пожалуйста.
[03:38:07.540 --> 03:38:09.540]  Да, теперь давайте подумаем, как
[03:38:09.540 --> 03:38:11.540]  теперь объединить... То есть теперь у нас
[03:38:11.540 --> 03:38:13.540]  возникнет задача, как объединить два сета.
[03:38:13.540 --> 03:38:15.540]  Ну два сета, то есть
[03:38:15.540 --> 03:38:17.540]  выглядеть это будет на уровне
[03:38:17.540 --> 03:38:19.540]  кода так. То есть, ну я обычно
[03:38:19.540 --> 03:38:21.540]  пишу через указатели,
[03:38:21.540 --> 03:38:23.540]  там,
[03:38:23.540 --> 03:38:25.540]  то есть merge set
[03:38:25.540 --> 03:38:27.540]  от, значит,
[03:38:27.540 --> 03:38:29.540]  set там,
[03:38:29.540 --> 03:38:31.540]  ну давайте я кратко буду писать.
[03:38:31.540 --> 03:38:33.540]  SVA, звездочка
[03:38:33.540 --> 03:38:35.540]  S1,
[03:38:35.540 --> 03:38:37.540]  SVA, ну set VZ,
[03:38:37.540 --> 03:38:39.540]  S2.
[03:38:41.540 --> 03:38:43.540]  Значит, первое, что вы делаете,
[03:38:43.540 --> 03:38:45.540]  если оказалось S1 size
[03:38:47.540 --> 03:38:49.540]  больше, чем
[03:38:49.540 --> 03:38:51.540]  S2 size,
[03:38:53.540 --> 03:38:55.540]  то, соответственно, не забываем
[03:38:55.540 --> 03:38:57.540]  swap.
[03:38:57.540 --> 03:38:59.540]  То есть это я для чего делаю?
[03:38:59.540 --> 03:39:01.540]  Для того, чтобы я точно знал, что я хочу
[03:39:01.540 --> 03:39:03.540]  элементы из S1 перекинуть в S2.
[03:39:05.540 --> 03:39:07.540]  Ну и после этого вы понимаете.
[03:39:07.540 --> 03:39:09.540]  После этого я пишу vector id.
[03:39:11.540 --> 03:39:13.540]  Там, допустим, a равно
[03:39:13.540 --> 03:39:15.540]  S1, стрелочка
[03:39:15.540 --> 03:39:17.540]  getall.
[03:39:23.540 --> 03:39:25.540]  Вот.
[03:39:25.540 --> 03:39:27.540]  А, ну и в общем-то все.
[03:39:27.540 --> 03:39:29.540]  Потому что пишем, что
[03:39:29.540 --> 03:39:31.540]  S1, допустим, clear.
[03:39:31.540 --> 03:39:33.540]  Но я обычно не удаляю,
[03:39:33.540 --> 03:39:35.540]  потому что я не делаю там new
[03:39:35.540 --> 03:39:37.540]  сетов, я там все эти сеты в статическом
[03:39:37.540 --> 03:39:39.540]  массиве на самом деле храню.
[03:39:39.540 --> 03:39:41.540]  Вот.
[03:39:41.540 --> 03:39:43.540]  Значит, и дальше пишем for
[03:39:43.540 --> 03:39:45.540]  int x
[03:39:45.540 --> 03:39:47.540]  2.a
[03:39:47.540 --> 03:39:49.540]  S2
[03:39:49.540 --> 03:39:51.540]  insert at x.
[03:39:51.540 --> 03:39:53.540]  Ну и все.
[03:39:53.540 --> 03:39:55.540]  Return S2.
[03:39:55.540 --> 03:39:57.540]  Вот.
[03:39:57.540 --> 03:39:59.540]  Так видите, то есть, знаешь, оказался
[03:39:59.540 --> 03:40:01.540]  теперь пишет, а просто легко, приятно.
[03:40:01.540 --> 03:40:03.540]  То есть единственное, что
[03:40:03.540 --> 03:40:05.540]  самое умное, что я тут сделал,
[03:40:05.540 --> 03:40:07.540]  теперь это вот этот иф написал.
[03:40:07.540 --> 03:40:09.540]  Вот.
[03:40:09.540 --> 03:40:11.540]  То есть очень
[03:40:11.540 --> 03:40:13.540]  удобно.
[03:40:13.540 --> 03:40:15.540]  Но
[03:40:15.540 --> 03:40:17.540]  мы хотим для каждой вершины хранить
[03:40:17.540 --> 03:40:19.540]  какие расстояния бывают
[03:40:19.540 --> 03:40:21.540]  между этой вершиной и ее
[03:40:21.540 --> 03:40:23.540]  потопками. Прям в явном виде
[03:40:23.540 --> 03:40:25.540]  все выписываем.
[03:40:25.540 --> 03:40:27.540]  Да, ноль, кстати, не забываю. Но я не буду сейчас полный код
[03:40:27.540 --> 03:40:29.540]  писать, да. То есть не буду писать там
[03:40:29.540 --> 03:40:31.540]  в каком месте мы там используем функцию
[03:40:31.540 --> 03:40:33.540]  вот это вот add to all, да, вот это.
[03:40:33.540 --> 03:40:35.540]  Там полный тот DFS
[03:40:35.540 --> 03:40:37.540]  не буду. Но как бы
[03:40:37.540 --> 03:40:39.540]  уже догадываете еще, наверное, вот с таким
[03:40:39.540 --> 03:40:41.540]  интерфейсом это там тоже легко, приятно
[03:40:41.540 --> 03:40:43.540]  будет.
[03:40:43.540 --> 03:40:45.540]  Но еще, кстати, остается только один вопрос.
[03:40:45.540 --> 03:40:47.540]  Но на самом деле, конечно, в
[03:40:47.540 --> 03:40:49.540]  merge sets на самом деле придется еще кое-что
[03:40:49.540 --> 03:40:51.540]  вписать. Потому что
[03:40:51.540 --> 03:40:53.540]  на самом деле высекает вопрос, а в какой момент мы
[03:40:53.540 --> 03:40:55.540]  собственно решаем задачу?
[03:40:55.540 --> 03:40:57.540]  То есть пока это мы просто сделали
[03:40:57.540 --> 03:40:59.540]  какое-то сферическое объединение элементов в вакууме.
[03:41:01.540 --> 03:41:03.540]  Как же решать задачу? Очень просто.
[03:41:03.540 --> 03:41:05.540]  Дело в том, что прежде чем объединять два
[03:41:05.540 --> 03:41:07.540]  сета, надо выяснить, а нельзя ли выбрать
[03:41:07.540 --> 03:41:09.540]  одну вершину в одну, а другую в другом, так
[03:41:09.540 --> 03:41:11.540]  чтобы расстояние было к?
[03:41:11.540 --> 03:41:13.540]  С точки зрения
[03:41:13.540 --> 03:41:15.540]  сета это означает, что надо просто
[03:41:15.540 --> 03:41:17.540]  можно ли из двух сетов выбрать по одному
[03:41:17.540 --> 03:41:19.540]  числу так, чтобы сумма была ровно к?
[03:41:19.540 --> 03:41:21.540]  Но на самом деле
[03:41:21.540 --> 03:41:23.540]  вот в этом, это можно сделать
[03:41:23.540 --> 03:41:25.540]  просто вот в этом месте. То есть прежде
[03:41:25.540 --> 03:41:27.540]  чем вы добавляете элементы из вектора a,
[03:41:27.540 --> 03:41:29.540]  надо просто для каждого x'а проверить,
[03:41:29.540 --> 03:41:31.540]  а нет ли случайно в s2 элемента
[03:41:31.540 --> 03:41:33.540]  k-x, и если да, то просто
[03:41:33.540 --> 03:41:35.540]  выбрасываете с криком да.
[03:41:37.540 --> 03:41:39.540]  Почему минус два?
[03:41:41.540 --> 03:41:43.540]  Не-не-не, когда мы их объединяем,
[03:41:43.540 --> 03:41:45.540]  мы уже вот это вот лишнее ребро прибавили.
[03:41:45.540 --> 03:41:47.540]  И кстати, там не два, там
[03:41:47.540 --> 03:41:49.540]  веса у этих ребра есть.
[03:41:49.540 --> 03:41:51.540]  Вот. Но это не важно,
[03:41:51.540 --> 03:41:53.540]  потому что, как я уже сказал, то есть где-то в
[03:41:53.540 --> 03:41:55.540]  ДФС, да, вы запустите ДФС от ребенка
[03:41:55.540 --> 03:41:57.540]  и к этому сету прибавите
[03:41:57.540 --> 03:41:59.540]  вот это ребро.
[03:41:59.540 --> 03:42:01.540]  Вот.
[03:42:01.540 --> 03:42:03.540]  Так что в этом смысле,
[03:42:03.540 --> 03:42:05.540]  так что как сказал бы тут классик,
[03:42:05.540 --> 03:42:07.540]  в этом смысле, да, как бы нет необходимости,
[03:42:07.540 --> 03:42:09.540]  как бы свой процент я уже взял.
[03:42:09.540 --> 03:42:11.540]  Вот.
[03:42:11.540 --> 03:42:13.540]  Так, но этот фильм вы точно не знаете, конечно.
[03:42:13.540 --> 03:42:15.540]  Вот. Или знаете.
[03:42:15.540 --> 03:42:17.540]  Вот фильм классик, не сталкивались?
[03:42:17.540 --> 03:42:19.540]  Ну, про бильярд такой.
[03:42:19.540 --> 03:42:21.540]  Там 97-го, ну не, ну да, это конечно
[03:42:21.540 --> 03:42:23.540]  не особо известный фильм.
[03:42:23.540 --> 03:42:25.540]  Вот. Ладно, не суть.
[03:42:25.540 --> 03:42:27.540]  Вот.
[03:42:27.540 --> 03:42:29.540]  Ну, теперь давайте подумаем, за какое
[03:42:29.540 --> 03:42:31.540]  симптомико это работает.
[03:42:33.540 --> 03:42:35.540]  К сожалению,
[03:42:35.540 --> 03:42:37.540]  лог квадрат. Почему
[03:42:37.540 --> 03:42:39.540]  лог квадрат? Да, потому что, да, очевидно,
[03:42:39.540 --> 03:42:41.540]  что каждый элемент меняет сет
[03:42:41.540 --> 03:42:43.540]  не более чем логарифм раз, потому что он перемещается
[03:42:43.540 --> 03:42:45.540]  в сеты два раза больше.
[03:42:45.540 --> 03:42:47.540]  Вот. Но, к сожалению,
[03:42:47.540 --> 03:42:49.540]  поэтому перемещение получается суммарно
[03:42:49.540 --> 03:42:51.540]  Н лог Н, но каждое перемещение
[03:42:51.540 --> 03:42:53.540]  делается за логарифм, потому что
[03:42:53.540 --> 03:42:55.540]  инсерт и инсерт в сете
[03:42:55.540 --> 03:42:57.540]  работает за логарифм.
[03:42:57.540 --> 03:42:59.540]  Поэтому лог квадрат. Но, в принципе, если бы сет был
[03:42:59.540 --> 03:43:01.540]  онордерат сетом, то был бы Н лог Н.
[03:43:03.540 --> 03:43:05.540]  Это один стандартный метод.
[03:43:05.540 --> 03:43:07.540]  Слючите
[03:43:07.540 --> 03:43:09.540]  другой стандартный метод.
[03:43:09.540 --> 03:43:11.540]  Все.
[03:43:11.540 --> 03:43:13.540]  Не нужен сет в классе.
[03:43:13.540 --> 03:43:15.540]  Нам нужно
[03:43:15.540 --> 03:43:17.540]  только нод вотмапа количества.
[03:43:17.540 --> 03:43:19.540]  Зачем? До количества даже не обязательно.
[03:43:19.540 --> 03:43:21.540]  У нас задача
[03:43:21.540 --> 03:43:23.540]  просто, есть ли две вершины с расстоянием k,
[03:43:23.540 --> 03:43:25.540]  да или нет.
[03:43:29.540 --> 03:43:31.540]  Нет, почему сет хранит просто, какие расстояния
[03:43:31.540 --> 03:43:33.540]  встретились.
[03:43:35.540 --> 03:43:37.540]  Не-не-не-не. Нет, сеты
[03:43:37.540 --> 03:43:39.540]  нужны, потому что ты ж вот в этом вот форе,
[03:43:39.540 --> 03:43:41.540]  который я не дописал. Для каждого х должен проверить,
[03:43:41.540 --> 03:43:43.540]  есть ли в соседнем сете число k-х.
[03:43:45.540 --> 03:43:47.540]  Да.
[03:43:47.540 --> 03:43:49.540]  Поэтому не вектор.
[03:43:49.540 --> 03:43:51.540]  Да, пожалуйста.
[03:43:51.540 --> 03:43:53.540]  Нет,
[03:43:53.540 --> 03:43:55.540]  онордерат сет, пожалуйста.
[03:43:55.540 --> 03:43:57.540]  Вот.
[03:43:57.540 --> 03:43:59.540]  Но слушайте другой метод.
[03:44:01.540 --> 03:44:03.540]  Значит,
[03:44:03.540 --> 03:44:05.540]  когда, если вас
[03:44:05.540 --> 03:44:07.540]  пугает вот это перекидывание
[03:44:07.540 --> 03:44:09.540]  с сетами,
[03:44:11.540 --> 03:44:13.540]  хотя, на самом деле, то, что я сейчас скажу, может выглядеть
[03:44:13.540 --> 03:44:15.540]  нод, то, ну как бы идея тогда
[03:44:15.540 --> 03:44:17.540]  могла быть такая.
[03:44:17.540 --> 03:44:19.540]  Вот просто, как бы мы решали такую задачу в массиве?
[03:44:19.540 --> 03:44:21.540]  Вот, допустим, да.
[03:44:21.540 --> 03:44:23.540]  Ну, допустим, нам там дан массив,
[03:44:23.540 --> 03:44:25.540]  скажите, пожалуйста,
[03:44:25.540 --> 03:44:27.540]  есть ли в нем подотрезок, на котором там
[03:44:27.540 --> 03:44:29.540]  сумма элементов равна k.
[03:44:29.540 --> 03:44:31.540]  Да, вместо суммы
[03:44:31.540 --> 03:44:33.540]  мы еще введем какую-нибудь такую мистическую
[03:44:33.540 --> 03:44:35.540]  операцию, чтобы префикс, чтобы префиксными
[03:44:35.540 --> 03:44:37.540]  суммами это не делалось.
[03:44:39.540 --> 03:44:41.540]  Тогда у нас есть два варианта.
[03:44:41.540 --> 03:44:43.540]  Тогда у нас, тогда идея
[03:44:43.540 --> 03:44:45.540]  на массиве может быть
[03:44:45.540 --> 03:44:47.540]  следующим образом.
[03:44:47.540 --> 03:44:49.540]  Рассмотрим вот этот центр.
[03:44:49.540 --> 03:44:51.540]  Подотрезки бывают трех типов.
[03:44:51.540 --> 03:44:53.540]  Лежащие слева, лежащие справа и проходящие
[03:44:53.540 --> 03:44:55.540]  через центр, правда?
[03:44:55.540 --> 03:44:57.540]  Тогда идея такая.
[03:44:57.540 --> 03:44:59.540]  Давайте за линию найдем тут ответы
[03:44:59.540 --> 03:45:01.540]  на всех префиксах,
[03:45:01.540 --> 03:45:03.540]  на всех суфиксах и дальше
[03:45:03.540 --> 03:45:05.540]  можем пытаться для
[03:45:05.540 --> 03:45:07.540]  каждого суфикса, попытаться
[03:45:07.540 --> 03:45:09.540]  подходящий префикс прицепить.
[03:45:09.540 --> 03:45:11.540]  Ладно, правда, если у вас нет
[03:45:11.540 --> 03:45:13.540]  префиксных сумм, то, возможно, вам это не удаст.
[03:45:15.540 --> 03:45:17.540]  Да, но тем не менее, таким методом
[03:45:17.540 --> 03:45:19.540]  тоже можно, но пока я
[03:45:19.540 --> 03:45:21.540]  просто для примера привожу.
[03:45:21.540 --> 03:45:23.540]  То есть вот такой разделяем властвуй,
[03:45:23.540 --> 03:45:25.540]  получается суммарная н лога n,
[03:45:25.540 --> 03:45:27.540]  потому что тут n, потом дальше тут будет
[03:45:27.540 --> 03:45:29.540]  n пополам, n пополам,
[03:45:29.540 --> 03:45:31.540]  и так далее.
[03:45:33.540 --> 03:45:35.540]  И желательно не обратимая еще.
[03:45:35.540 --> 03:45:37.540]  Но была бы она обратимая,
[03:45:37.540 --> 03:45:39.540]  то префиксные суммы начали
[03:45:39.540 --> 03:45:41.540]  бы работать.
[03:45:45.540 --> 03:45:47.540]  Значит, что еще надо?
[03:45:47.540 --> 03:45:49.540]  А надо вот что.
[03:45:49.540 --> 03:45:51.540]  Так вот, просто идея. Дело в том, что эта идея,
[03:45:51.540 --> 03:45:53.540]  в отличие от префиксных сумм, может неплохо
[03:45:53.540 --> 03:45:55.540]  масштабироваться на дерево.
[03:45:57.540 --> 03:45:59.540]  Потому что возьмем у дерева корень.
[03:45:59.540 --> 03:46:01.540]  Вот этот вот.
[03:46:01.540 --> 03:46:03.540]  Просто у дерева какой-нибудь корень.
[03:46:05.540 --> 03:46:07.540]  Тогда идея такая. У нас два варианта.
[03:46:07.540 --> 03:46:09.540]  У нас два варианта. Либо путь проходит через корень,
[03:46:09.540 --> 03:46:11.540]  либо лежит в каком-то под дереве.
[03:46:11.540 --> 03:46:13.540]  На каждом из под деревьев запустимся рекурсивно.
[03:46:15.540 --> 03:46:17.540]  А для корня, ну что делаем?
[03:46:17.540 --> 03:46:19.540]  А то же самое, что и здесь,
[03:46:19.540 --> 03:46:21.540]  только без рекурсивного перекидывания
[03:46:21.540 --> 03:46:23.540]  сетами. То есть мы
[03:46:23.540 --> 03:46:25.540]  запускаем def. То есть для каждого
[03:46:25.540 --> 03:46:27.540]  под дереве, от дерева честно
[03:46:27.540 --> 03:46:29.540]  генерируем, какие тут расстояния бывают.
[03:46:29.540 --> 03:46:31.540]  То есть генерируем в данном случае четыре сета.
[03:46:31.540 --> 03:46:33.540]  А потом нам надо просто проверить,
[03:46:33.540 --> 03:46:35.540]  существует ли два числа из
[03:46:35.540 --> 03:46:37.540]  разных сетов, чтобы их сумма была равна к.
[03:46:37.540 --> 03:46:39.540]  Ну как это сделать?
[03:46:39.540 --> 03:46:41.540]  Ну сначала проверяем, есть ли такие числа в этих
[03:46:41.540 --> 03:46:43.540]  двух сетах. Если нет, то там
[03:46:43.540 --> 03:46:45.540]  объединяем эти два сета, причем уже по барабану как.
[03:46:45.540 --> 03:46:47.540]  Потом пытаемся
[03:46:47.540 --> 03:46:49.540]  проверить, можно ли выбрать одно число в этих
[03:46:49.540 --> 03:46:51.540]  двух сетах, а дальше в третьем объединяем,
[03:46:51.540 --> 03:46:53.540]  ну и так далее.
[03:46:53.540 --> 03:46:55.540]  Ну,
[03:46:55.540 --> 03:46:57.540]  с этим корнем
[03:46:57.540 --> 03:46:59.540]  разобрались n log n,
[03:46:59.540 --> 03:47:01.540]  дальше потом,
[03:47:01.540 --> 03:47:03.540]  потом тут берем корни какие-то,
[03:47:03.540 --> 03:47:05.540]  и тут суммарно тоже
[03:47:05.540 --> 03:47:07.540]  n log n получается, ну и так далее.
[03:47:07.540 --> 03:47:09.540]  Получается n log n
[03:47:09.540 --> 03:47:11.540]  на количество уровней
[03:47:11.540 --> 03:47:13.540]  рекурсии.
[03:47:17.540 --> 03:47:19.540]  Теперь возникает вопрос, от чему может быть равен?
[03:47:19.540 --> 03:47:21.540]  А сколько тут
[03:47:21.540 --> 03:47:23.540]  глубина рекурсии может быть?
[03:47:23.540 --> 03:47:25.540]  Если в тупую корню брать как корни под деревьев,
[03:47:25.540 --> 03:47:27.540]  то, возможно, вам фантастически
[03:47:27.540 --> 03:47:29.540]  не повезет, и глубина будет n.
[03:47:29.540 --> 03:47:31.540]  Это многовато.
[03:47:33.540 --> 03:47:35.540]  Но фишка, конечно,
[03:47:35.540 --> 03:47:37.540]  в том, что, заметим, что в каждом дереве
[03:47:37.540 --> 03:47:39.540]  корень мы можем выбирать заново.
[03:47:39.540 --> 03:47:41.540]  То есть мы
[03:47:41.540 --> 03:47:43.540]  решаем, какой будет корень. То есть мы здесь
[03:47:43.540 --> 03:47:45.540]  в этом под деревом можем брать не вот эту
[03:47:45.540 --> 03:47:47.540]  вершину, а просто какую угодно.
[03:47:47.540 --> 03:47:49.540]  То есть более того, я как-то в какой-то задачи
[03:47:49.540 --> 03:47:51.540]  реализовал даже, что я это делаю, просто заново
[03:47:51.540 --> 03:47:53.540]  копировал, перенабирал вершины и просто
[03:47:53.540 --> 03:47:55.540]  кидал рекурсивно.
[03:47:55.540 --> 03:47:57.540]  Не, ну помогло.
[03:47:57.540 --> 03:47:59.540]  Правда, судя по разборам
[03:47:59.540 --> 03:48:01.540]  и обсуждениям, видимо, авторы задачи не ожидали,
[03:48:01.540 --> 03:48:03.540]  что там можно это пихнуть.
[03:48:03.540 --> 03:48:05.540]  Ну, точнее, как-то
[03:48:05.540 --> 03:48:07.540]  решение оказалось полной неожиданностью
[03:48:07.540 --> 03:48:09.540]  для нас, мы не заготовили тестов.
[03:48:11.540 --> 03:48:13.540]  Но, впрочем, я не уверен, что у меня
[03:48:13.540 --> 03:48:15.540]  решение прям так плохо работает, прям сильно
[03:48:15.540 --> 03:48:17.540]  заваливалось, скажем так.
[03:48:17.540 --> 03:48:19.540]  Вот.
[03:48:19.540 --> 03:48:21.540]  А как же? Ну, просто
[03:48:21.540 --> 03:48:23.540]  что нужно сделать? Но идея очень простая.
[03:48:23.540 --> 03:48:25.540]  Дело в том, что если размер N,
[03:48:25.540 --> 03:48:27.540]  то, оказывается,
[03:48:27.540 --> 03:48:29.540]  можно просто выбрать
[03:48:29.540 --> 03:48:31.540]  такую вершину в качестве корня, чтобы у нее
[03:48:31.540 --> 03:48:33.540]  все размеры под деревьев были
[03:48:33.540 --> 03:48:35.540]  не более чем
[03:48:35.540 --> 03:48:37.540]  N пополам.
[03:48:37.540 --> 03:48:39.540]  Вот хочется такую сделать.
[03:48:41.540 --> 03:48:43.540]  И такая вершина называется
[03:48:43.540 --> 03:48:45.540]  центроинит.
[03:48:47.540 --> 03:48:49.540]  Вот, не путать с центром.
[03:48:49.540 --> 03:48:51.540]  Центр – это середина диаметра. Центроинит – это вот такая
[03:48:51.540 --> 03:48:53.540]  вершина, что у нее все, что
[03:48:53.540 --> 03:48:55.540]  если ее выкинуть, то дерево распадется
[03:48:55.540 --> 03:48:57.540]  на компоненты связности
[03:48:57.540 --> 03:48:59.540]  размера не более чем N пополам.
[03:49:03.540 --> 03:49:05.540]  Такую вершину очень легко
[03:49:05.540 --> 03:49:07.540]  найти за линейное время, попутно доказав,
[03:49:07.540 --> 03:49:09.540]  что она существует.
[03:49:09.540 --> 03:49:11.540]  Как это сделать?
[03:49:11.540 --> 03:49:13.540]  Ну, сделать это очень просто.
[03:49:13.540 --> 03:49:15.540]  Возьмем
[03:49:15.540 --> 03:49:17.540]  первую попавшуюся вершину в качестве корня,
[03:49:17.540 --> 03:49:19.540]  запустим из нее DFS, посчитаем СЗ.
[03:49:21.540 --> 03:49:23.540]  После этого смотрим, если у детей корня
[03:49:23.540 --> 03:49:25.540]  все СЗ оказались N пополам
[03:49:25.540 --> 03:49:27.540]  или менее, значит, поздравляем,
[03:49:27.540 --> 03:49:29.540]  мы центроинит нашли.
[03:49:29.540 --> 03:49:31.540]  Если нашлась какое-то под дерево
[03:49:31.540 --> 03:49:33.540]  с СЗ больше, чем N пополам,
[03:49:33.540 --> 03:49:35.540]  ну окей, смотрим на детей
[03:49:35.540 --> 03:49:37.540]  этого ребенка.
[03:49:37.540 --> 03:49:39.540]  Если тут кто-то больше, чем
[03:49:39.540 --> 03:49:41.540]  N пополам, очевидно, не больше,
[03:49:41.540 --> 03:49:43.540]  чем одна такая вершина, то идем сюда.
[03:49:43.540 --> 03:49:45.540]  Идем, идем, идем,
[03:49:45.540 --> 03:49:47.540]  и вот в какой-то момент натыкаемся на вершину,
[03:49:47.540 --> 03:49:49.540]  у которой все под деревья меньше
[03:49:49.540 --> 03:49:51.540]  N пополам.
[03:49:51.540 --> 03:49:53.540]  Утверждение
[03:49:53.540 --> 03:49:55.540]  это центроид.
[03:49:55.540 --> 03:49:57.540]  Почему?
[03:49:57.540 --> 03:49:59.540]  Потому что, если его выкинуть,
[03:49:59.540 --> 03:50:01.540]  то у детей меньше N пополам,
[03:50:01.540 --> 03:50:03.540]  а то, что сверху меньше N пополам,
[03:50:03.540 --> 03:50:05.540]  потому что у самого
[03:50:05.540 --> 03:50:07.540]  эта вершина больше, чем N пополам.
[03:50:09.540 --> 03:50:11.540]  Все.
[03:50:13.540 --> 03:50:15.540]  Так что вот нот.
[03:50:15.540 --> 03:50:17.540]  Сам центроид найти легко, и если вы будете в качестве корня
[03:50:17.540 --> 03:50:19.540]  здесь запускать именно это,
[03:50:19.540 --> 03:50:21.540]  то уровни у вас будет, очевидно, логарифом.
[03:50:21.540 --> 03:50:23.540]  И суммарно,
[03:50:23.540 --> 03:50:25.540]  это будет работать за O от N лог
[03:50:25.540 --> 03:50:27.540]  квадрат N, то есть еще одна
[03:50:27.540 --> 03:50:29.540]  такая версия.
[03:50:29.540 --> 03:50:31.540]  То есть как бы либо центроиды, либо с этой в рекурсии.
[03:50:31.540 --> 03:50:33.540]  Ну, например,
[03:50:33.540 --> 03:50:35.540]  оба метода, конечно, полезны, то есть
[03:50:35.540 --> 03:50:37.540]  в каких-то задачах помогает одно, в каких-то другое.
[03:50:39.540 --> 03:50:41.540]  Вот. Но, конечно,
[03:50:41.540 --> 03:50:43.540]  нот.
[03:50:43.540 --> 03:50:45.540]  Но, на самом деле,
[03:50:45.540 --> 03:50:47.540]  центроиды, конечно,
[03:50:47.540 --> 03:50:49.540]  и структура этих центроидов
[03:50:49.540 --> 03:50:51.540]  помогает решать, конечно, иногда и
[03:50:51.540 --> 03:50:53.540]  более мощные задачи.
[03:50:53.540 --> 03:50:55.540]  Ну, вот задачу,
[03:50:55.540 --> 03:50:57.540]  которую мы тут много задач, конечно, не разберем,
[03:50:57.540 --> 03:50:59.540]  но мы разберем такую классическую задачу.
[03:50:59.540 --> 03:51:01.540]  Ну, точно так. То есть пока уже
[03:51:01.540 --> 03:51:03.540]  поняли, что, в принципе, центроиды
[03:51:03.540 --> 03:51:05.540]  позволяют решать какие-то задачи на деревья методом
[03:51:05.540 --> 03:51:07.540]  разделяя и властвовать.
[03:51:07.540 --> 03:51:09.540]  То есть всегда, если вы умеете
[03:51:09.540 --> 03:51:11.540]  за какую-то асимптотику там
[03:51:11.540 --> 03:51:13.540]  f от n, допустим,
[03:51:13.540 --> 03:51:15.540]  решать задачу в
[03:51:15.540 --> 03:51:17.540]  предположении, что
[03:51:17.540 --> 03:51:19.540]  там все, что вам надо, проходит
[03:51:19.540 --> 03:51:21.540]  через заданную вершину,
[03:51:21.540 --> 03:51:23.540]  то тогда за f от n умножить
[03:51:23.540 --> 03:51:25.540]  на log n вы, в принципе, умеете
[03:51:25.540 --> 03:51:27.540]  решать задачу.
[03:51:27.540 --> 03:51:29.540]  Вот. Но, оказывается, можно
[03:51:29.540 --> 03:51:31.540]  решать еще мощнее.
[03:51:31.540 --> 03:51:33.540]  Сейчас мы с вами будем делать
[03:51:33.540 --> 03:51:35.540]  присваивание в радиусе.
[03:51:40.540 --> 03:51:42.540]  Потому что, смотри, у тебя сейчас
[03:51:42.540 --> 03:51:44.540]  под деревья размер n пополам,
[03:51:44.540 --> 03:51:46.540]  то есть когда ты тут в каждом из них выберешь
[03:51:46.540 --> 03:51:48.540]  центроиды, там дальше будет n делить на 4
[03:51:48.540 --> 03:51:50.540]  и так далее.
[03:51:50.540 --> 03:51:52.540]  И теперь
[03:51:52.540 --> 03:51:54.540]  значит еще одна веселая,
[03:51:54.540 --> 03:51:56.540]  но тем не менее прям очень классическая
[03:51:56.540 --> 03:51:58.540]  задача.
[03:51:58.540 --> 03:52:00.540]  Задача такая.
[03:52:00.540 --> 03:52:02.540]  Да оно дерево.
[03:52:02.540 --> 03:52:04.540]  Дерево взвешенное,
[03:52:04.540 --> 03:52:06.540]  все веса положительные.
[03:52:06.540 --> 03:52:08.540]  Нужно уметь
[03:52:08.540 --> 03:52:10.540]  делать
[03:52:10.540 --> 03:52:12.540]  два запроса. Каждая вершина покрашена
[03:52:12.540 --> 03:52:14.540]  в какой-то цвет.
[03:52:14.540 --> 03:52:16.540]  Нужно делать два запроса.
[03:52:16.540 --> 03:52:18.540]  Первый тип запроса.
[03:52:18.540 --> 03:52:20.540]  Скажи, пожалуйста,
[03:52:22.540 --> 03:52:24.540]  в какой цвет покрашена вершина v?
[03:52:26.540 --> 03:52:28.540]  Тип второй.
[03:52:30.540 --> 03:52:32.540]  Покрась, пожалуйста,
[03:52:32.540 --> 03:52:34.540]  все
[03:52:34.540 --> 03:52:36.540]  вершины,
[03:52:36.540 --> 03:52:38.540]  находящиеся на расстоянии
[03:52:38.540 --> 03:52:40.540]  не более, чем r,
[03:52:40.540 --> 03:52:42.540]  от вершины v,
[03:52:42.540 --> 03:52:44.540]  в цвет c.
[03:52:48.540 --> 03:52:50.540]  Вот такая классика.
[03:52:52.540 --> 03:52:54.540]  Да, c произвольная, r произвольная,
[03:52:54.540 --> 03:52:56.540]  веса до 10, там все веса тоже произвольные.
[03:52:56.540 --> 03:52:58.540]  Ну там гарантируется, конечно,
[03:52:58.540 --> 03:53:00.540]  что в каждом из деревней сумма весов не более,
[03:53:00.540 --> 03:53:02.540]  чем там 10-18 и что-нибудь,
[03:53:02.540 --> 03:53:04.540]  вот это все.
[03:53:04.540 --> 03:53:06.540]  Можете считать, что все это веса до 10 в 9.
[03:53:08.540 --> 03:53:10.540]  Расстояние
[03:53:10.540 --> 03:53:12.540]  это сумма весов.
[03:53:12.540 --> 03:53:14.540]  То есть, как бы, каждая
[03:53:14.540 --> 03:53:16.540]  ребро имеет длину.
[03:53:16.540 --> 03:53:18.540]  Как такое решать?
[03:53:22.540 --> 03:53:24.540]  Ну вот,
[03:53:24.540 --> 03:53:26.540]  центроиды нам, конечно, помогают,
[03:53:26.540 --> 03:53:28.540]  но помогает, конечно, что-то более сильное.
[03:53:28.540 --> 03:53:30.540]  Помогает то, что называется
[03:53:30.540 --> 03:53:32.540]  центроидная
[03:53:32.540 --> 03:53:34.540]  позиция.
[03:53:34.540 --> 03:53:36.540]  Выглядит это примерно
[03:53:36.540 --> 03:53:38.540]  следующим образом.
[03:53:38.540 --> 03:53:40.540]  Вот жилов у нас
[03:53:40.540 --> 03:53:42.540]  какое-то дерево.
[03:53:42.540 --> 03:53:44.540]  Тут можно уже и побольше нарисовать.
[03:53:44.540 --> 03:53:46.540]  Вот.
[03:54:00.540 --> 03:54:02.540]  Здесь, смотрите,
[03:54:02.540 --> 03:54:04.540]  идея тут
[03:54:04.540 --> 03:54:06.540]  оказывается такая.
[03:54:06.540 --> 03:54:08.540]  Ну, первое, давайте начнем с простого.
[03:54:08.540 --> 03:54:10.540]  Давайте
[03:54:10.540 --> 03:54:12.540]  предположим, что у нас
[03:54:12.540 --> 03:54:14.540]  в пэнсе вот эта вершина В всегда одна и та же.
[03:54:16.540 --> 03:54:18.540]  Как тогда решать за декю?
[03:54:26.540 --> 03:54:28.540]  Ну вот.
[03:54:28.540 --> 03:54:30.540]  Ну вот.
[03:54:30.540 --> 03:54:32.540]  Ну, по сути, да. То есть там идея оказывается в том,
[03:54:32.540 --> 03:54:34.540]  что для каждой вершины
[03:54:34.540 --> 03:54:36.540]  мы можем хранить что-то типа стека,
[03:54:36.540 --> 03:54:38.540]  в том плане, что мы знаем, что там, скажем,
[03:54:38.540 --> 03:54:40.540]  все вершины от нее до расстояния
[03:54:40.540 --> 03:54:42.540]  не более чем L1 покрашены в цвет
[03:54:42.540 --> 03:54:44.540]  C1.
[03:54:44.540 --> 03:54:46.540]  До расстояния не более чем L2,
[03:54:46.540 --> 03:54:48.540]  но больше чем L1 покрашены в цвет
[03:54:48.540 --> 03:54:50.540]  C2. Вот так вот, да.
[03:54:50.540 --> 03:54:52.540]  То есть вот что-то такое там.
[03:54:52.540 --> 03:54:54.540]  Потом дальше L3, C3 и так далее.
[03:54:54.540 --> 03:54:56.540]  То есть когда мы решили что-то новое покрасить,
[03:54:56.540 --> 03:54:58.540]  то есть мы тут проходимся по стеку, все меньше
[03:54:58.540 --> 03:55:00.540]  длинные удаляем.
[03:55:00.540 --> 03:55:02.540]  Ну вот.
[03:55:02.540 --> 03:55:04.540]  А взамен там вставляем одно и красим
[03:55:04.540 --> 03:55:06.540]  в новое C.
[03:55:06.540 --> 03:55:08.540]  Так.
[03:55:08.540 --> 03:55:10.540]  Понятно, о чем я говорю?
[03:55:10.540 --> 03:55:12.540]  То есть достаточно хранить только эту информацию,
[03:55:12.540 --> 03:55:14.540]  да, все, что вам останется, если когда
[03:55:14.540 --> 03:55:16.540]  вам встанут там где-то от кого-нибудь,
[03:55:16.540 --> 03:55:18.540]  то вы проверяете расстояние до вот этого
[03:55:18.540 --> 03:55:20.540]  корнера, где вы все красите.
[03:55:20.540 --> 03:55:22.540]  То есть находите расстояние, а вам останется только
[03:55:22.540 --> 03:55:24.540]  бинпольском найти в какой-то цвет, что покрашит.
[03:55:24.540 --> 03:55:26.540]  Удобно, да?
[03:55:28.540 --> 03:55:30.540]  Вот.
[03:55:30.540 --> 03:55:32.540]  Но что делать, если такие вершины,
[03:55:32.540 --> 03:55:34.540]  если
[03:55:34.540 --> 03:55:36.540]  пейнтимся мы в радиусе разного?
[03:55:36.540 --> 03:55:38.540]  Корнячку и то же самое получится.
[03:55:38.540 --> 03:55:40.540]  Корнячку?
[03:55:40.540 --> 03:55:42.540]  Корнячку по запросам.
[03:55:46.540 --> 03:55:48.540]  Ну да, если вы еще расстояние между двумя вершинами
[03:55:48.540 --> 03:55:50.540]  за вот единицу умеете искать,
[03:55:50.540 --> 03:55:52.540]  а ну вы уже умеете, естественно,
[03:55:52.540 --> 03:55:54.540]  да.
[03:55:54.540 --> 03:55:56.540]  Ну вот.
[03:55:56.540 --> 03:55:58.540]  Хорошо.
[03:55:58.540 --> 03:56:00.540]  Ну тут, как всегда, вы напишите корнячку,
[03:56:00.540 --> 03:56:02.540]  она получит T, а автор скажет, извините,
[03:56:02.540 --> 03:56:04.540]  у нас лог квадрат, который работает 10 раз быстрее
[03:56:04.540 --> 03:56:06.540]  вашего.
[03:56:06.540 --> 03:56:08.540]  Как-то он
[03:56:08.540 --> 03:56:10.540]  нам очень жаль.
[03:56:10.540 --> 03:56:12.540]  Вот.
[03:56:12.540 --> 03:56:14.540]  Хотя, да, корнячка по запросам
[03:56:14.540 --> 03:56:16.540]  тут, конечно, красиво было.
[03:56:16.540 --> 03:56:18.540]  Вот. Ну ладно.
[03:56:18.540 --> 03:56:20.540]  Значит, идея тогда тут такая.
[03:56:20.540 --> 03:56:22.540]  Найдем в дереве
[03:56:22.540 --> 03:56:24.540]  центроид.
[03:56:24.540 --> 03:56:26.540]  Вот он.
[03:56:26.540 --> 03:56:28.540]  Ну я надеюсь.
[03:56:28.540 --> 03:56:30.540]  Тогда, смотрите, какая нот.
[03:56:30.540 --> 03:56:32.540]  Вот жила была у нас вот такое глобальное
[03:56:32.540 --> 03:56:34.540]  дерево, и был у него
[03:56:34.540 --> 03:56:36.540]  центроид.
[03:56:36.540 --> 03:56:38.540]  Вот.
[03:56:38.540 --> 03:56:40.540]  В мире существует
[03:56:40.540 --> 03:56:42.540]  этот центроид и все под деревья.
[03:56:42.540 --> 03:56:44.540]  И заметим, что каждый запрос
[03:56:44.540 --> 03:56:46.540]  paint может
[03:56:46.540 --> 03:56:48.540]  касаться этого центроида
[03:56:48.540 --> 03:56:50.540]  или не касаться. То есть этот центроид может быть перекрашен,
[03:56:50.540 --> 03:56:52.540]  а может быть не перекрашен.
[03:56:52.540 --> 03:56:54.540]  Ну теперь идея такая.
[03:56:54.540 --> 03:56:56.540]  Предположим, что мы отправились
[03:56:56.540 --> 03:56:58.540]  в какую-то вершину его под дерево,
[03:56:58.540 --> 03:57:00.540]  какую-то вершину его под дерево,
[03:57:00.540 --> 03:57:02.540]  на расстоянии, ну, допустим,
[03:57:02.540 --> 03:57:04.540]  тут 57.
[03:57:04.540 --> 03:57:06.540]  И сказали, в радиусе 179
[03:57:06.540 --> 03:57:08.540]  перекрасить, пожалуйста,
[03:57:08.540 --> 03:57:10.540]  там все вершины от него.
[03:57:12.540 --> 03:57:14.540]  Тогда, оказывается, заметим следующее,
[03:57:14.540 --> 03:57:16.540]  что надо перекрасить вообще все вершины
[03:57:16.540 --> 03:57:18.540]  у центроида на расстоянии
[03:57:18.540 --> 03:57:20.540]  122.
[03:57:22.540 --> 03:57:24.540]  Но это еще не все.
[03:57:24.540 --> 03:57:26.540]  Да, это не все, что мы перекрасили.
[03:57:26.540 --> 03:57:28.540]  Но заметим, что все, что мы не перекрасили,
[03:57:28.540 --> 03:57:30.540]  уже точно лежит вот в этом под дерево.
[03:57:32.540 --> 03:57:34.540]  То есть, по сути, это у нас такая столица,
[03:57:34.540 --> 03:57:36.540]  Москва такая.
[03:57:36.540 --> 03:57:38.540]  Значит, в радиусе Москвы
[03:57:38.540 --> 03:57:40.540]  мы все перекрасили.
[03:57:40.540 --> 03:57:42.540]  Теперь давайте поперекрашиваем,
[03:57:42.540 --> 03:57:44.540]  идем в эту вершину. А что у нас в этом под дерево?
[03:57:44.540 --> 03:57:46.540]  Так, ну, какая у нас дальше?
[03:57:46.540 --> 03:57:48.540]  Дальше у нас идут,
[03:57:48.540 --> 03:57:50.540]  помимо Москвы, у нас есть, конечно,
[03:57:50.540 --> 03:57:52.540]  федеральная круга.
[03:57:52.540 --> 03:57:54.540]  Вот они.
[03:57:54.540 --> 03:57:56.540]  То есть вот у нас это,
[03:57:56.540 --> 03:57:58.540]  вот у нас это, что-то там у нас еще есть.
[03:58:00.540 --> 03:58:02.540]  Вот этот у нас дерево есть.
[03:58:04.540 --> 03:58:06.540]  Вот это вот такая
[03:58:06.540 --> 03:58:08.540]  автономная область.
[03:58:08.540 --> 03:58:10.540]  Такая-то мелкая.
[03:58:10.540 --> 03:58:12.540]  Так вот,
[03:58:12.540 --> 03:58:14.540]  вот так вот.
[03:58:16.540 --> 03:58:18.540]  Что это такое?
[03:58:20.540 --> 03:58:22.540]  А, ладно, где-то внизу.
[03:58:22.540 --> 03:58:24.540]  Не, это, я не знаю,
[03:58:24.540 --> 03:58:26.540]  это уже там Дагестан какой-то.
[03:58:26.540 --> 03:58:28.540]  А вот это, да,
[03:58:28.540 --> 03:58:30.540]  это Калининград.
[03:58:30.540 --> 03:58:32.540]  Ну, а что европейцы жалуются?
[03:58:34.540 --> 03:58:36.540]  Ну, нормально, ладно.
[03:58:38.540 --> 03:58:40.540]  Ой, ну, знаете,
[03:58:40.540 --> 03:58:42.540]  если землю реально в плоскости развернуть,
[03:58:42.540 --> 03:58:44.540]  еще вопрос, кто там большой, будет кто-то маленький.
[03:58:44.540 --> 03:58:46.540]  Вот это Сибирь вообще.
[03:58:48.540 --> 03:58:50.540]  Это Якутия. Прикольная такая.
[03:58:50.540 --> 03:58:52.540]  Так вот.
[03:58:52.540 --> 03:58:54.540]  В каждом этом федеральном округе
[03:58:54.540 --> 03:58:56.540]  мы тоже можем
[03:58:56.540 --> 03:58:58.540]  забабахать центроид.
[03:58:58.540 --> 03:59:00.540]  Вот.
[03:59:00.540 --> 03:59:02.540]  Так, где у нас тут центроид?
[03:59:04.540 --> 03:59:06.540]  Да, вот тут.
[03:59:06.540 --> 03:59:08.540]  Это будет центроид второго уровня.
[03:59:10.540 --> 03:59:12.540]  Это будет центроид второго уровня.
[03:59:12.540 --> 03:59:14.540]  Так.
[03:59:14.540 --> 03:59:16.540]  Что-то у нас тут еще будет.
[03:59:16.540 --> 03:59:18.540]  Тут, видимо, где-то будет.
[03:59:18.540 --> 03:59:20.540]  Вот.
[03:59:20.540 --> 03:59:22.540]  То есть, идея такая, давайте в каждом из этих деревьев
[03:59:22.540 --> 03:59:24.540]  тоже будем
[03:59:24.540 --> 03:59:26.540]  иметь в виду перекаж.
[03:59:26.540 --> 03:59:28.540]  То есть, если вершина находится вот в этом дереве,
[03:59:28.540 --> 03:59:30.540]  дереве второго, в федеральном округе,
[03:59:30.540 --> 03:59:32.540]  то мы попытаемся проделать ту же операцию
[03:59:32.540 --> 03:59:34.540]  через вот этот центроид второго уровня.
[03:59:36.540 --> 03:59:38.540]  Ну, а потом, как вы уже догадываетесь,
[03:59:38.540 --> 03:59:40.540]  через третий, через четвертый и так далее.
[03:59:40.540 --> 03:59:42.540]  То есть, сама вся эта центроидная декомпозиция получается такой
[03:59:42.540 --> 03:59:44.540]  логарифом уровней.
[03:59:44.540 --> 03:59:46.540]  То есть, получается, каждая вершина является центроидом какого-то уровня.
[03:59:46.540 --> 03:59:48.540]  То есть, более того,
[03:59:48.540 --> 03:59:50.540]  можно построить дерево центроидов,
[03:59:50.540 --> 03:59:52.540]  в котором
[03:59:52.540 --> 03:59:54.540]  каждая вершина будет глубина
[03:59:54.540 --> 03:59:56.540]  не более чем логарифом.
[03:59:56.540 --> 03:59:58.540]  То есть, идея нот.
[03:59:58.540 --> 04:00:00.540]  То есть, будем делать вот как вот с этим сказали.
[04:00:00.540 --> 04:00:02.540]  То есть, у нас получается,
[04:00:02.540 --> 04:00:04.540]  у каждого центроида есть сигналы,
[04:00:04.540 --> 04:00:06.540]  что, пожалуйста, в радиусе этого центроида
[04:00:06.540 --> 04:00:08.540]  перекрась там,
[04:00:08.540 --> 04:00:10.540]  в каком-то радиусе перекрась вершины в цвет,
[04:00:10.540 --> 04:00:12.540]  но при этом, очень важно еще отметить,
[04:00:12.540 --> 04:00:14.540]  что это касается только
[04:00:14.540 --> 04:00:16.540]  его зоны ответственности.
[04:00:18.540 --> 04:00:20.540]  То есть, когда мы требуем перекрасить с центром
[04:00:20.540 --> 04:00:22.540]  вот в этом центроиде, мы в столицу не лезем.
[04:00:22.540 --> 04:00:24.540]  И в другие поддеревья не лезем.
[04:00:24.540 --> 04:00:26.540]  Даже если там расстояние меньше.
[04:00:30.540 --> 04:00:32.540]  То есть, получается такая перекраска, но правда получается,
[04:00:32.540 --> 04:00:34.540]  каждая вершина может быть перекрашенная несколько раз.
[04:00:36.540 --> 04:00:38.540]  Но будьте внимательны, конечно, это операция неотложенная.
[04:00:38.540 --> 04:00:40.540]  Поэтому гет у вас будет, конечно, не совсем тривиальный.
[04:00:44.540 --> 04:00:46.540]  Но гет сделается получается так.
[04:00:46.540 --> 04:00:48.540]  То есть, чтобы получить гет,
[04:00:48.540 --> 04:00:50.540]  вам нужно взять вершину В
[04:00:50.540 --> 04:00:52.540]  и подумать,
[04:00:52.540 --> 04:00:54.540]  а какие центроиды могли ее вообще перекрасить?
[04:00:54.540 --> 04:00:56.540]  Их до логарифма.
[04:00:56.540 --> 04:00:58.540]  Вы перебираете все эти центроиды
[04:00:58.540 --> 04:01:00.540]  и получаете логарифм
[04:01:00.540 --> 04:01:02.540]  вариантов ответа.
[04:01:02.540 --> 04:01:04.540]  Осталось только, если никакой из них правильный,
[04:01:04.540 --> 04:01:06.540]  да, правильно, последний.
[04:01:06.540 --> 04:01:08.540]  То есть, это означает, что когда вы перекрашиваете
[04:01:08.540 --> 04:01:10.540]  для каждой перекраски, тут еще храните,
[04:01:10.540 --> 04:01:12.540]  а когда это произошло.
[04:01:12.540 --> 04:01:14.540]  И тогда получается,
[04:01:14.540 --> 04:01:16.540]  что вы все сделали за
[04:01:18.540 --> 04:01:20.540]  лог квадрат.
[04:01:24.540 --> 04:01:26.540]  Потому что в каждом из логарифмов стека
[04:01:26.540 --> 04:01:28.540]  делаете бинпорт.
[04:01:28.540 --> 04:01:30.540]  В каждом из логарифмов стека
[04:01:30.540 --> 04:01:32.540]  делаете бинпорт.
[04:01:32.540 --> 04:01:34.540]  В каждом из логарифмов стека делаете бинпоиск.
[04:01:38.540 --> 04:01:40.540]  Лог квадрат на гет
[04:01:40.540 --> 04:01:42.540]  и лог пейнтов.
[04:01:48.540 --> 04:01:50.540]  И памяти энлог.
[04:01:50.540 --> 04:01:52.540]  Памяти энлог,
[04:01:52.540 --> 04:01:54.540]  потому что
[04:01:54.540 --> 04:01:56.540]  каждый элемент добавляется
[04:01:56.540 --> 04:01:58.540]  в логарифм.
[04:02:04.540 --> 04:02:06.540]  Памяти энлог,
[04:02:06.540 --> 04:02:08.540]  потому что каждый цвет, который ты
[04:02:08.540 --> 04:02:10.540]  красишь, он как бы добавляется в
[04:02:10.540 --> 04:02:12.540]  логарифм массивов.
[04:02:12.540 --> 04:02:14.540]  Нет,
[04:02:14.540 --> 04:02:16.540]  теоретически
[04:02:16.540 --> 04:02:18.540]  нет,
[04:02:18.540 --> 04:02:20.540]  если тебе
[04:02:20.540 --> 04:02:22.540]  нужно построить
[04:02:22.540 --> 04:02:24.540]  только дерево центроидов,
[04:02:24.540 --> 04:02:26.540]  то в общем-то тебе достаточно.
[04:02:36.540 --> 04:02:38.540]  Тебе еще Сашке придется искать,
[04:02:38.540 --> 04:02:40.540]  чтобы расстояние
[04:02:40.540 --> 04:02:42.540]  дали две вершины,
[04:02:42.540 --> 04:02:44.540]  найди расстояние.
[04:03:04.540 --> 04:03:06.540]  Нет, на самом деле нет
[04:03:06.540 --> 04:03:08.540]  необходимости,
[04:03:08.540 --> 04:03:10.540]  если вы согласны за энлог
[04:03:10.540 --> 04:03:12.540]  и памяти, то в принципе
[04:03:12.540 --> 04:03:14.540]  можно для каждого центроида
[04:03:14.540 --> 04:03:16.540]  посчитать расстояние до всех
[04:03:16.540 --> 04:03:18.540]  подмандатох вершин.
[04:03:24.540 --> 04:03:26.540]  Тебе по сути нужно
[04:03:26.540 --> 04:03:28.540]  расстояние только до своего центроида.
[04:03:32.540 --> 04:03:34.540]  Для этой вершины я буду хранить расстояние
[04:03:34.540 --> 04:03:36.540]  до всех, а для этой я буду хранить
[04:03:36.540 --> 04:03:38.540]  до своего дерева.
[04:03:44.540 --> 04:03:46.540]  Потому что у центроида второго
[04:03:46.540 --> 04:03:48.540]  уровня суммарно n будет.
[04:03:52.540 --> 04:03:54.540]  Деревеж какого-то уровня
[04:03:54.540 --> 04:03:56.540]  не пересекаются между собой.
[04:04:06.540 --> 04:04:08.540]  Я бы сказал,
[04:04:08.540 --> 04:04:10.540]  что каждая вершина
[04:04:10.540 --> 04:04:12.540]  является центроидом своего уровня.
[04:04:14.540 --> 04:04:16.540]  Давайте я возьму все вершины
[04:04:16.540 --> 04:04:18.540]  соответствующего дерева
[04:04:18.540 --> 04:04:20.540]  и в этом дереве
[04:04:20.540 --> 04:04:22.540]  выпишу все расстояния
[04:04:22.540 --> 04:04:24.540]  до своего центроида.
[04:04:24.540 --> 04:04:26.540]  Таким образом у каждой вершины
[04:04:26.540 --> 04:04:28.540]  получится расстояние
[04:04:28.540 --> 04:04:30.540]  до всех своих родительских центроидов.
[04:04:30.540 --> 04:04:32.540]  То есть до центра уезда,
[04:04:32.540 --> 04:04:34.540]  до центра области,
[04:04:34.540 --> 04:04:36.540]  до центра округа,
[04:04:36.540 --> 04:04:38.540]  ну и собственно до Москвы.
[04:04:40.540 --> 04:04:42.540]  Остается только надеяться,
[04:04:42.540 --> 04:04:44.540]  что у нас как-то дорог не дерево.
[04:04:46.540 --> 04:04:48.540]  Хотя иногда
[04:04:48.540 --> 04:04:50.540]  как выясняется,
[04:04:50.540 --> 04:04:52.540]  что там иногда
[04:04:52.540 --> 04:04:54.540]  долететь из Владивостока
[04:04:54.540 --> 04:04:56.540]  в Южный Сахалинск можно только через Москву.
[04:04:56.540 --> 04:04:58.540]  Ну ладно, вру, через Новосибирск
[04:04:58.540 --> 04:05:00.540]  все-таки можно, наверное.
[04:05:00.540 --> 04:05:02.540]  Хотя и так
[04:05:02.540 --> 04:05:04.540]  и так немножко экзотично получается.
[04:05:06.540 --> 04:05:08.540]  Хотя нет, Владивосток может быть большим хабом
[04:05:08.540 --> 04:05:10.540]  в этом плане.
[04:05:10.540 --> 04:05:12.540]  Потому что Владивосток в Китай там летают
[04:05:12.540 --> 04:05:14.540]  много на самом деле.
[04:05:14.540 --> 04:05:16.540]  Хотите в Китай?
[04:05:16.540 --> 04:05:18.540]  Летите в Благовещенск.
[04:05:18.540 --> 04:05:20.540]  Да, там через речку.
[04:05:22.540 --> 04:05:24.540]  Да,
[04:05:24.540 --> 04:05:26.540]  добрая китайская деревня.
[04:05:26.540 --> 04:05:28.540]  Да, у них жители
[04:05:28.540 --> 04:05:30.540]  в Благовещенск уезжают, что у них
[04:05:30.540 --> 04:05:32.540]  действительно есть опция пойти пообедать в Китай.
[04:05:40.540 --> 04:05:42.540]  А там на проходе
[04:05:42.540 --> 04:05:44.540]  отличают жителей Благовещенска от остальных
[04:05:44.540 --> 04:05:46.540]  россиян?
[04:05:46.540 --> 04:05:48.540]  Понятно.
[04:05:48.540 --> 04:05:50.540]  Ну да, то есть можно, то есть кто-то
[04:05:50.540 --> 04:05:52.540]  получает визу в Китай, а кто-то идет через
[04:05:52.540 --> 04:05:54.540]  Благовещенск.
[04:06:00.540 --> 04:06:02.540]  Ну да,
[04:06:02.540 --> 04:06:04.540]  через общий центроид.
[04:06:04.540 --> 04:06:06.540]  Нет.
[04:06:06.540 --> 04:06:08.540]  Нет, ну как бы
[04:06:08.540 --> 04:06:10.540]  да, у тебя просто...
[04:06:10.540 --> 04:06:12.540]  Когда ты строишь центроиды для декомпозиции,
[04:06:12.540 --> 04:06:14.540]  у тебя некоторое время две вершины отправляются в одно и то же под дерево.
[04:06:14.540 --> 04:06:16.540]  А потом в какой-то момент
[04:06:16.540 --> 04:06:18.540]  очередной центроид оказался на пути
[04:06:18.540 --> 04:06:20.540]  между ними. Рано или поздно это произойдет.
[04:06:22.540 --> 04:06:24.540]  Потому что, смотри,
[04:06:24.540 --> 04:06:26.540]  тебе нужно перебрать логарифм центроидов.
[04:06:26.540 --> 04:06:28.540]  И в каждом центроиде
[04:06:28.540 --> 04:06:30.540]  надо полезть в этот стэк
[04:06:30.540 --> 04:06:32.540]  и там бин поиском найти расстояние.
[04:06:32.540 --> 04:06:34.540]  Да, поэтому...
[04:06:36.540 --> 04:06:38.540]  То есть я не знаю, возможно там как-то
[04:06:38.540 --> 04:06:40.540]  если тебе запросы даны в офлайн,
[04:06:40.540 --> 04:06:42.540]  может быть там как-то амортизировано
[04:06:42.540 --> 04:06:44.540]  это до логарифма допиливается.
[04:06:44.540 --> 04:06:46.540]  Вот я помню, когда...
[04:06:46.540 --> 04:06:48.540]  У меня вообще-то слезное ощущение, что когда-то когда-то пытался,
[04:06:48.540 --> 04:06:50.540]  и что-то получалось. Не уверен,
[04:06:50.540 --> 04:06:52.540]  что это прям имеет глубокий смысл
[04:06:52.540 --> 04:06:54.540]  с точки зрения практики.
[04:06:54.540 --> 04:06:56.540]  Но так.
[04:06:56.540 --> 04:06:58.540]  Но вот так.
[04:06:58.540 --> 04:07:00.540]  Так, есть ли тут
[04:07:00.540 --> 04:07:02.540]  вопросы?
[04:07:18.540 --> 04:07:20.540]  Нет, мы не считаем для центроидов.
[04:07:20.540 --> 04:07:22.540]  Нет, я сказал так, что
[04:07:22.540 --> 04:07:24.540]  для каждого... То есть вот у нас есть
[04:07:24.540 --> 04:07:26.540]  дерево. Мы нашли билет центроид
[04:07:26.540 --> 04:07:28.540]  и нашли расстояние от центроида до всех вершин этого дерева.
[04:07:34.540 --> 04:07:36.540]  Но для нашей задачи... Нет, это в итоге
[04:07:36.540 --> 04:07:38.540]  приводит к тому, что мы для каждой вершины
[04:07:38.540 --> 04:07:40.540]  нашли расстояние до всех ее центроидов.
[04:07:44.540 --> 04:07:46.540]  А мы ровно это и сделали.
[04:07:54.540 --> 04:07:56.540]  Почему?
[04:07:56.540 --> 04:07:58.540]  Из Москвы мы ДФС по всей стране
[04:07:58.540 --> 04:08:00.540]  пускали.
[04:08:06.540 --> 04:08:08.540]  Нет, нам интересны расстояния
[04:08:08.540 --> 04:08:10.540]  и до сюда, и до сюда, и до сюда.
[04:08:12.540 --> 04:08:14.540]  Нет, сохранили тоже.
[04:08:14.540 --> 04:08:16.540]  Потому что
[04:08:16.540 --> 04:08:18.540]  нас могли покрасить
[04:08:18.540 --> 04:08:20.540]  как из Судиславля,
[04:08:20.540 --> 04:08:22.540]  но так и из Костромы.
[04:08:22.540 --> 04:08:24.540]  Ну,
[04:08:28.540 --> 04:08:30.540]  допустим, мы там находимся в Бердеевых полянах.
[04:08:30.540 --> 04:08:32.540]  Как устроен
[04:08:32.540 --> 04:08:34.540]  пейнт?
[04:08:38.540 --> 04:08:40.540]  То есть пейнт устроен так,
[04:08:40.540 --> 04:08:42.540]  что мы идем в Судиславль и красим там
[04:08:42.540 --> 04:08:44.540]  Судиславский район.
[04:08:44.540 --> 04:08:46.540]  Потом идем в Кострому
[04:08:48.540 --> 04:08:50.540]  и понимаешь, что сколько-то там эпизода кресла из Костромы красим.
[04:08:50.540 --> 04:08:52.540]  Потом мы идем в Москву и красим еще
[04:08:52.540 --> 04:08:54.540]  окрестность ее.
[04:08:54.540 --> 04:08:56.540]  К чему это приводит?
[04:08:56.540 --> 04:08:58.540]  Это приводит,
[04:08:58.540 --> 04:09:00.540]  что если ты находишься
[04:09:00.540 --> 04:09:02.540]  где-то там,
[04:09:02.540 --> 04:09:04.540]  то есть
[04:09:04.540 --> 04:09:06.540]  если ты находишься в Балашихе,
[04:09:06.540 --> 04:09:08.540]  то как бы если
[04:09:08.540 --> 04:09:10.540]  ты находишься там,
[04:09:10.540 --> 04:09:12.540]  нет, ладно, даже не в Балашихе, а там.
[04:09:12.540 --> 04:09:14.540]  Так, какой-нибудь пример.
[04:09:16.540 --> 04:09:18.540]  Нет, значит,
[04:09:20.540 --> 04:09:22.540]  если ты живешь там,
[04:09:22.540 --> 04:09:24.540]  с формулировом так,
[04:09:24.540 --> 04:09:26.540]  ладно, если живешь, допустим,
[04:09:26.540 --> 04:09:28.540]  в какой-нибудь деревне под Яхомой,
[04:09:28.540 --> 04:09:30.540]  то тебя, значит,
[04:09:30.540 --> 04:09:32.540]  могли покрасить из Яхомы,
[04:09:32.540 --> 04:09:34.540]  тебя могли покрасить из Дмитрова,
[04:09:34.540 --> 04:09:36.540]  а могли и из Москвы покрасить.
[04:09:36.540 --> 04:09:38.540]  Причем более тем
[04:09:38.540 --> 04:09:40.540]  самым запросом, который пришел у Судиславля.
[04:09:40.540 --> 04:09:42.540]  То есть получается я должен
[04:09:42.540 --> 04:09:44.540]  перебрать,
[04:09:44.540 --> 04:09:46.540]  хранить не только, то есть расстояние,
[04:09:46.540 --> 04:09:48.540]  то есть расстояние, получается, мне придется хранить
[04:09:48.540 --> 04:09:50.540]  все-таки до всех своих центроидов,
[04:09:50.540 --> 04:09:52.540]  а не только до одной
[04:09:52.540 --> 04:09:54.540]  ближайшей Яхомы.
[04:10:00.540 --> 04:10:02.540]  Да, если что,
[04:10:02.540 --> 04:10:04.540]  если что, расстояние от Яхомы до Москвы
[04:10:04.540 --> 04:10:06.540]  не равно расстояние от Яхомы до Дмитрова
[04:10:06.540 --> 04:10:08.540]  плюс расстояние от Дмитрова до Москвы.
[04:10:14.540 --> 04:10:16.540]  Почему?
[04:10:16.540 --> 04:10:18.540]  Расстояние от Яхомы до Дмитрова меньше,
[04:10:18.540 --> 04:10:20.540]  чем расстояние от Яхомы до Москвы.
[04:10:20.540 --> 04:10:22.540]  Так, короче, вот так вот,
[04:10:22.540 --> 04:10:24.540]  есть железная дорога, вот эта темирская, да?
[04:10:24.540 --> 04:10:26.540]  Так вот, значит, если ты едешь
[04:10:26.540 --> 04:10:28.540]  вот тупо на север,
[04:10:28.540 --> 04:10:30.540]  ты рано или поздно приедешь в Дмитров.
[04:10:30.540 --> 04:10:32.540]  Так вот, за станцию до него есть Яхрома.
[04:10:36.540 --> 04:10:38.540]  Так что вот так себе это надо уважать.
[04:10:38.540 --> 04:10:40.540]  Так вот, поверь, Яхрома ближе, Дмитров ближе
[04:10:40.540 --> 04:10:42.540]  к Яхроме, чем к Москве.
[04:10:42.540 --> 04:10:44.540]  Если бы мы красили
[04:10:44.540 --> 04:10:46.540]  ровно, радиус уже не работал бы.
[04:10:46.540 --> 04:10:48.540]  Нет, то есть прям
[04:10:48.540 --> 04:10:50.540]  на ровно, ну, конечно.
[04:10:50.540 --> 04:10:52.540]  Хотя, нет,
[04:10:52.540 --> 04:10:54.540]  нет, крепче.
[04:10:54.540 --> 04:10:56.540]  Ну, хотя, да, не работает, согласен.
[04:11:00.540 --> 04:11:02.540]  Нет, это правда, это не ровно.
[04:11:06.540 --> 04:11:08.540]  Да, мы явно пользуемся тем, чтобы красить
[04:11:08.540 --> 04:11:10.540]  не только на расстоянии, а на расстоянии не более,
[04:11:10.540 --> 04:11:12.540]  чем Р.
[04:11:14.540 --> 04:11:16.540]  В какой момент
[04:11:16.540 --> 04:11:18.540]  мне нужно оставить расстояние?
[04:11:20.540 --> 04:11:22.540]  Ну, как минимум...
[04:11:24.540 --> 04:11:26.540]  Ну, потому что когда мы идем из Судяславля
[04:11:26.540 --> 04:11:28.540]  в Москву,
[04:11:28.540 --> 04:11:30.540]  нам нужно просто дать, какой конкретная
[04:11:30.540 --> 04:11:32.540]  псилонокрестность Москвы красить.
[04:11:44.540 --> 04:11:46.540]  Вот.
[04:11:46.540 --> 04:11:48.540]  Так, ну, что, еще какие-то вопросы есть?
[04:11:50.540 --> 04:11:52.540]  За лог квадрат.
[04:11:52.540 --> 04:11:54.540]  Ну, потому что
[04:11:54.540 --> 04:11:56.540]  в каждом центроиде там стек находится,
[04:11:56.540 --> 04:11:58.540]  в котором надо бинпоиском искать.
[04:12:00.540 --> 04:12:02.540]  Лог квадрат.
[04:12:02.540 --> 04:12:04.540]  Логарифм стеков в каждом логарифме,
[04:12:04.540 --> 04:12:06.540]  поэтому лог квадрат.
[04:12:08.540 --> 04:12:10.540]  Потому что логарифм центроидов.
[04:12:14.540 --> 04:12:16.540]  Как, чего, кого?
[04:12:16.540 --> 04:12:18.540]  Мы должны перебрать
[04:12:18.540 --> 04:12:20.540]  просто все мои родительские центроиды.
[04:12:20.540 --> 04:12:22.540]  То есть, типа, если я берендирую поляну,
[04:12:22.540 --> 04:12:24.540]  я должен перебрать Судяславль, я должен перебрать
[04:12:24.540 --> 04:12:26.540]  к страну, я должен перебрать там,
[04:12:26.540 --> 04:12:28.540]  я не знаю, там северо-осточный федеральный округ
[04:12:28.540 --> 04:12:30.540]  или в каком-то округе находится к стране,
[04:12:30.540 --> 04:12:32.540]  я не знаю. И концертов надо
[04:12:32.540 --> 04:12:34.540]  перебрать всю страну.
[04:12:34.540 --> 04:12:36.540]  Да.
[04:12:36.540 --> 04:12:38.540]  Ну, нет, ну, как бы декомпозиция
[04:12:38.540 --> 04:12:40.540]  подразумевает, что ты заранее там за НЛОГАН
[04:12:40.540 --> 04:12:42.540]  как бы это все предподсчитал.
[04:12:42.540 --> 04:12:44.540]  Для каждой вершины в явном виде знаешь, кто у нее
[04:12:44.540 --> 04:12:46.540]  родительские центроиды?
[04:12:50.540 --> 04:12:52.540]  По факту мы для каждой вершины храним стек.
[04:12:52.540 --> 04:12:54.540]  Потому что каждая вершина
[04:12:54.540 --> 04:12:56.540]  является центроидом своего уровня.
[04:12:58.540 --> 04:13:00.540]  Почему отложены? Отложенных операций нет.
[04:13:00.540 --> 04:13:02.540]  Ну, в самом стеке
[04:13:02.540 --> 04:13:04.540]  конечно нет, отложенных операций нет.
[04:13:04.540 --> 04:13:06.540]  В смысле?
[04:13:06.540 --> 04:13:08.540]  Ну, чтобы
[04:13:08.540 --> 04:13:10.540]  у нас
[04:13:10.540 --> 04:13:12.540]  такие вопросы я не умею отвечать,
[04:13:12.540 --> 04:13:14.540]  только у нас он так устроен,
[04:13:14.540 --> 04:13:16.540]  что значит зачем?
[04:13:20.540 --> 04:13:22.540]  Каждый
[04:13:22.540 --> 04:13:24.540]  стек находится, каждая вершина
[04:13:24.540 --> 04:13:26.540]  является центроидом.
[04:13:28.540 --> 04:13:30.540]  То есть вопрос только, как бы она
[04:13:30.540 --> 04:13:32.540]  всей страны центроид, или только там
[04:13:32.540 --> 04:13:34.540]  своей области?
[04:13:36.540 --> 04:13:38.540]  Когда мы берем
[04:13:38.540 --> 04:13:40.540]  гет от В, мы должны для каждой вершины В понять,
[04:13:40.540 --> 04:13:42.540]  то есть
[04:13:42.540 --> 04:13:44.540]  найти центроиды всех деревьев,
[04:13:44.540 --> 04:13:46.540]  внутри которых она лежит. Она лежит
[04:13:46.540 --> 04:13:48.540]  внутри логарифма деревьев там,
[04:13:48.540 --> 04:13:50.540]  потому что логарифм уровень.
[04:13:52.540 --> 04:13:54.540]  Нет, В не надо искать.
[04:13:56.540 --> 04:13:58.540]  Ну, как и с центроидом какого-то уровня.
[04:13:58.540 --> 04:14:00.540]  Но это не важно.
[04:14:00.540 --> 04:14:02.540]  Если она является центроидом
[04:14:02.540 --> 04:14:04.540]  11-го уровня,
[04:14:04.540 --> 04:14:06.540]  значит она лежит еще в 10
[04:14:06.540 --> 04:14:08.540]  деревьях более больших.
[04:14:08.540 --> 04:14:10.540]  И у каждого из них есть центроиды,
[04:14:10.540 --> 04:14:12.540]  и их надо уметь находить.
[04:14:18.540 --> 04:14:20.540]  Так что вот,
[04:14:20.540 --> 04:14:22.540]  вот таким образом
[04:14:22.540 --> 04:14:24.540]  восьмые задачи на все расщелкаются,
[04:14:24.540 --> 04:14:26.540]  как орешки.
[04:14:30.540 --> 04:14:32.540]  Ну, бывает.
[04:14:32.540 --> 04:14:34.540]  Уже вторые, да?
[04:14:42.540 --> 04:14:44.540]  Ну, это пожалуйста.
[04:14:44.540 --> 04:14:46.540]  Ну, кому как проще.
[04:14:46.540 --> 04:14:48.540]  Но тем не менее, вот метод мощный данный.
[04:14:54.540 --> 04:14:56.540]  Да.
[04:14:56.540 --> 04:14:58.540]  Это что такое нормальные люди?
[04:14:58.540 --> 04:15:00.540]  Так, ладно, в финсе на сегодня все.
[04:15:00.540 --> 04:15:02.540]  Да.
