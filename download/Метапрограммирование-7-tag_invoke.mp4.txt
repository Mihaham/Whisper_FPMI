[00:00.000 --> 00:19.600]  Ну окей, давайте, ладно, тег-инвок так тег-бук, так, нам нужен экран, и попробуем начать с конца,
[00:19.600 --> 00:33.060]  так сказать, с мотивировки. Попробуем толкаться от совершенно практичной задачи. Вот в языке
[00:33.060 --> 00:42.320]  Rust есть такой смешной, ну концепт не концепт, ну понятие, итератор. Тут этот рейтн называется,
[00:42.320 --> 00:50.440]  но нам это не важно. И главное, что делает какой-либо тип итератором, это вот такая забавная функция next,
[00:50.440 --> 01:00.960]  которая принимает по ссылке тип, вот этот вот итератор, меняет его как-то, ну передвигает
[01:00.960 --> 01:15.920]  вперед, очевидно, и возвращает либо значение, лежавшее под ним сейчас, либо ничего, да, то есть
[01:15.920 --> 01:22.080]  вот этот option, это тот же самый std option, и вот это ничего, понятное дело, приходит, когда мы
[01:22.080 --> 01:35.400]  дошли до конца. Ну и идея в том, что мы будем писать циклы вроде while value равно next от итератора,
[01:35.400 --> 01:46.720]  делать что-то. Вот представим, что нам в плюсах захотелось такую же штуку сделать, да, объявить
[01:46.720 --> 01:55.280]  некоторый концепт итератора, у которого есть функция next, и с которой мы можем работать.
[01:55.280 --> 02:05.200]  А как это можно моделировать? Ну, самый наивный подход это opa использовать, да,
[02:05.200 --> 02:28.120]  просто попросим, чтобы у t был next, который нам вернет optional от, ну чего-то на самом деле. Вот я
[02:28.120 --> 02:33.600]  сейчас не хочу фокусироваться на том, что каждый итератор еще и должен знать, что он возвращает,
[02:33.600 --> 02:41.400]  поэтому скажем, что он какой-нибудь std any возвращает, вот чисто чтобы не париться,
[02:41.400 --> 02:46.160]  да, с таким же успехом int можно написать или еще что-нибудь.
[02:46.160 --> 03:15.400]  В чем проблема такого подхода? Если мы
[03:15.400 --> 03:23.880]  используем какую-то стороннюю библиотеку или даже библиотеку std, то этот концепт нам не
[03:23.880 --> 03:31.000]  подходит. Мы не можем внутри стд итератора какого-то взять и определить новую функцию next.
[03:31.000 --> 03:42.000]  Печаль беда, но хотелось бы иметь такую возможность сделать какой-то концепт в
[03:42.000 --> 03:55.160]  терминах удобных нам функций и потом адаптировать как бы к этому концепту сторонние классы какие-то,
[03:55.160 --> 04:02.720]  которые в принципе поддерживают такой же функционал, но при этом работают несколько иначе другой
[04:02.720 --> 04:16.440]  интерфейс. Ну раз методы не подходят, наверное стоит использовать функцию как это не freestanding,
[04:16.440 --> 04:39.480]  в общем просто функцию. Ну и как правило, итераторы в плюсах следуют все-таки известному
[04:39.480 --> 04:51.720]  соглашению. Да, у них есть оператор плюс-плюс, у них есть оператор разыминования и мы в принципе
[04:51.720 --> 05:02.560]  можем сделать дефолтную имплементацию для таких итераторов. Правда в отличие от раз-то в плюсах
[05:02.560 --> 05:08.440]  мы не можем понять дошел ли итератор до конца или нет. Вот это такое небольшое отличие,
[05:08.440 --> 05:17.040]  небольшая проблемка, но ничего, мы на него сейчас немножко забьем. Мы скажем, что если нам пришел
[05:17.040 --> 05:26.440]  произвольный класс T, то мы как бы по дефолту будем делать плюс-плюс, вернее что будем делать
[05:26.440 --> 05:38.720]  return T++. Сначала разыминовывает и возвращает результат, а потом увеличивает. И вот это в принципе
[05:38.720 --> 05:45.840]  будет работать и все хорошо. Но если нам дали какую-то библиотеку, у которой совсем другой
[05:45.840 --> 06:01.400]  интерфейс. Предположим, что в какой-то сторонней библиотеке нужно делать it.advance и it.get. То есть
[06:01.400 --> 06:06.840]  суть та же, но интерфейс другой и нужно как-то адаптировать. Мы конечно можем написать обертку,
[06:06.840 --> 06:15.040]  но это не очень приятно повсюду искать эти обертки, тем более что сама библиотека их не ожидает.
[06:15.040 --> 06:27.480]  Окей, это все намекает на то, что вот эту функцию next нам хочется кастомизировать в зависимости от
[06:27.480 --> 06:34.560]  того, какой шаблонный аргумент пришел. То есть вот это дефолтная имплементация, а мы хотим делать
[06:34.560 --> 06:43.160]  какие-то перегрузки, не перегрузки, в общем какой-то языковой инструмент применить, чтобы получить
[06:43.160 --> 06:50.600]  кастомизацию. Ну и да, перегрузки я уже сказал. Самое очевидное, что приходит голову. А что если мы
[06:50.600 --> 06:59.480]  перегрузим? Но вот чтобы продемонстрировать, почему это не работает, давайте здесь объявим функцию
[06:59.480 --> 07:15.160]  next twice. А да, мы наверное хотим все-таки, чтобы вот так отработал. Мы же все-таки его увеличиваем. Вот,
[07:15.160 --> 07:24.400]  соответственно next twice, что оно будет делать? Оно будет принимать данные класса iterator,
[07:24.400 --> 07:43.960]  и будет делать next at t. Давайте даже скажем, что это не в нашей библиотеке, а вот где-то в пользовательском
[07:43.960 --> 07:55.400]  коде встретилась такая функция. Ну и конечно пользователь вот так делает. У нас же в Молибе объявлен next.
[07:55.400 --> 08:08.800]  Окей, здорово. После этого так получилось, что у нас перегрузка появилась. Как мы эту перегрузку
[08:08.800 --> 08:16.520]  сделаем? Мы конечно же внутри namespace и мы должны ее создавать. Перегрузки только в одной области
[08:16.520 --> 08:23.520]  видимости считаются для функций, как мы видели на примере второй домашки. Соответственно, окей,
[08:23.520 --> 08:38.880]  делаем перегрузку, которая будет работать с чем. Ну нам тип какой-то, конечно же, да.
[08:38.880 --> 08:48.160]  К сожалению, придется немножко пописать.
[08:48.160 --> 09:05.760]  Скажем, что ничего не делают.
[09:05.760 --> 09:26.440]  И возвращает, не знаю, ноль. Все это не важно. Вот, и здесь мы кастомизируем для adder.idr,
[09:26.440 --> 09:30.880]  посылки его принимаем и делаем то, что хотели.
[09:30.880 --> 09:55.400]  И ко всему прочему мы сделаем вот так вот.
[09:55.400 --> 10:11.280]  К чему все это клонится?
[10:25.400 --> 10:40.440]  К тому, что если мы next.twice сейчас вызовем adder.idr, вроде как все хорошо, да?
[10:40.440 --> 10:56.800]  Опа, а как же так вышло? То есть, да, оно даже не попробовало найти вот эту нашу перегрузку,
[10:56.800 --> 11:03.040]  которая бы сработала, а почему-то пошло вот сюда, в дефолтную. Ну и тут мы это еще
[11:03.040 --> 11:11.760]  увидели, да, потому что плюс-плюса нет. Ну а что если в этой библиотеке все-таки оператор
[11:11.760 --> 11:19.640]  плюс-плюс есть, но который делает вообще что-то другое. То есть, конечно, для операторов это
[11:19.640 --> 11:30.080]  немножко с натяжкой такого ожидать. Например, делает std award. Но если мы теоретически смотрим,
[11:30.080 --> 11:38.800]  что это произвольная кастомизация произвольного чего-то, то вот такая штука произойти могла и
[11:38.800 --> 11:49.520]  привело бы это к чему? К тому, что мы запускаем, да, кажется постфиксный оператор вот так
[11:49.520 --> 12:02.680]  объявляется у нас. Вот, вызвался дефолт. Ну и вызвался, конечно же, плюс-плюс вот этого
[12:02.680 --> 12:11.880]  ad-reader, и все заобортировалось. Это немного неожиданно, это даже очень неожиданно. То есть,
[12:11.880 --> 12:17.160]  мы как бы перегрузку сделали, она как бы есть, но почему-то компилятор даже не пытается ее
[12:17.160 --> 12:25.840]  использовать или найти. А причина этому очень простая. Если мы вспомним про dependent имена и
[12:25.840 --> 12:46.080]  откроем вот эту статью, то здесь написано, что не ADL lookup для dependent имен идет только по тому,
[12:46.080 --> 12:56.720]  что видим из точки определения шаблона. Вот это ключевое. То есть, когда мы внутри шаблона next
[12:56.720 --> 13:07.320]  twice пытаемся понять, о какой перегрузке mylibnext идет речь, мы имеем право искать только определения,
[13:07.320 --> 13:14.640]  которые видны из точки определения нашего шаблона. То есть, вот отсюда. А к этому моменту у нас ровно
[13:14.640 --> 13:25.720]  одна mylibnext видна, а вот эта еще не была определена. Вот так странно работают плюсы,
[13:25.720 --> 13:33.320]  и поделать с этим мы ничего не можем. То есть, бессмысленно вообще даже пытаться предоставлять
[13:33.320 --> 13:38.080]  с точки зрения библиотеки пользователям возможность кастомизировать какие-то вызовы
[13:38.080 --> 13:46.480]  с помощью перегрузок функций. Потому что тут немножко искусственно, а мы можем представить,
[13:46.480 --> 14:06.640]  что вот это вот includeUser, один из include, вот это library.include, а вот здесь другой include
[14:06.640 --> 14:14.600]  пользователя. То бишь, в зависимости от того, в каком порядке вот этот include и вот этот include
[14:14.600 --> 14:21.680]  идут в файле пользователя, у нас либо будет виден вот этот next, либо не будет. То есть,
[14:21.680 --> 14:28.040]  все зависит от того, что раньше определили. Вот этот шаблон или вот эту перегрузку функции next.
[14:28.040 --> 14:38.480]  Ну это абсолютно недовлетворительно. Но, к счастью, есть второй пунктик. Среди правил
[14:38.480 --> 14:45.800]  лукапа. Да, понятно же всем, почему имя dependent, вот это вот next. У нас dependent expression,
[14:45.800 --> 14:57.640]  потому что его тип, ну это есть по определению dependent. А next, оно как бы рассматривается не
[14:57.640 --> 15:02.720]  в изоляции, а вместе с аргументами. Вот, соответственно, отсюда прилетают зависимости,
[15:02.720 --> 15:10.720]  и next тоже считается зависимым в рамках этого шаблона. Вот, а есть второй пункт вот в этом
[15:10.720 --> 15:21.960]  объяснении. Когда идет argument-dependent-lookup, у нас рассматриваются все функции, которые видны и
[15:21.960 --> 15:35.680]  из места определения шаблона, и из места инстанциации шаблона. Но ADL, мы про него,
[15:35.680 --> 15:43.560]  кажется, уже не раз говорили, это lookup, namespace, в котором лежит функция, в зависимости от namespace
[15:43.560 --> 15:50.880]  аргумент. Соответственно, чтобы он вообще работал, нам нужно вызывать функцию без namespace,
[15:50.880 --> 16:01.680]  то есть он квалифает. И если в namespace, где лежит t, определенная вот такая вот функция,
[16:03.680 --> 16:11.440]  то она найдется. Ну, давайте адаптируем вот это вот все. Это будет namespace user, в котором будет
[16:11.440 --> 16:24.560]  определен ad-reader. И, соответственно, next, который уже не считается перегрузкой, они лежат в разных
[16:24.560 --> 16:31.480]  namespace, соответственно, не перегружают друг друга. Но ADL сможет найти теперь этот next,
[16:31.480 --> 16:44.240]  потому что t, какой у нас будет вот в этом вызове, да, user ad-reader. Соответственно,
[16:44.240 --> 16:53.680]  вот такой типу t вот в этом вызове. И в namespace-и ассоциированным user мы будем
[16:53.680 --> 17:00.880]  пытаться найти функцию next и, ура-ура, найдем ее. И вот это сейчас заработает.
[17:00.880 --> 17:10.680]  Да, действительно, кастомайз запустилась. Но теперь мы делаем...
[17:10.680 --> 17:31.240]  Да, заключим вектор. Делаем вектор и пытаемся делать next-advice от... Да, tail-value у нас
[17:31.240 --> 17:41.360]  ничего не выйдет. Теперь tail-value и... И что же произойдет?
[17:46.400 --> 17:58.000]  А произойдет... Да, у нас требуется итератор, конечно. Нет, да, все правильно, все правильно.
[17:59.000 --> 18:07.800]  Вернись к консолям. Смотрим, почему концепт не удовлетворился.
[18:10.960 --> 18:21.440]  Да, да, да, да, да, да, мы забыли или не забыли, где оно, или next-adt. А, да, вот, мы потребовали,
[18:21.560 --> 18:30.080]  чтобы next-adt работало в концепте. Нет, что-то не так.
[18:30.080 --> 18:51.080]  Ладно, я хотел продемонстрировать не это, поэтому давайте уберем концепт.
[18:51.080 --> 19:00.200]  Держим, вот.
[19:00.200 --> 19:20.920]  Ничего не произошло.
[19:31.200 --> 19:32.920]  Это интересно.
[19:32.920 --> 19:48.360]  Окей, уберем вот это, хоть какую-то из функций next-advice он же вызвал.
[19:48.360 --> 19:58.240]  Так, это сюрприз.
[19:58.240 --> 20:18.480]  А, конфликты имен меня обманули. Да, у нас вызвалась функция std next внезапно,
[20:18.480 --> 20:27.120]  потому что в namespace std тоже есть функция next и ничто ей не помешало вызваться.
[20:27.120 --> 20:46.400]  Да, да, на всякий случай, std next, вот она есть, она делает похожую штуку, но не совсем. Вот,
[20:46.400 --> 20:54.160]  нам как-то не хочется, чтобы она вызывалась, поэтому давайте вместо std-шного итератора все-таки
[20:54.160 --> 20:56.560]  очередную структурку закастеляем.
[21:24.160 --> 21:31.480]  Просто что-то, чтобы оно было. Так, окей, вот теперь сюрпризов быть не должно,
[21:31.480 --> 21:39.440]  и у нас будет итер, и мы хотели бы, чтобы у нас дефолтная имплементация вызвалась,
[21:39.440 --> 21:47.880]  но она, конечно, не вызовется, потому что дефолтная имплементация у нас лежит вот в этом вот namespace
[21:47.880 --> 22:05.320]  и mylib, а мы как бы итер определили вне namespace и mylib. Очень жаль. Ну, конечно, написать mylib
[22:05.320 --> 22:11.920]  2.next мы не можем, потому что это вернуло нас бы к старому варианту, и вот отсюда берется вот эта
[22:11.920 --> 22:21.080]  вот техника, про которую в прошлый раз говорил, делать using на какую-то конкретную функцию. Там
[22:21.080 --> 22:29.960]  было using std swap, теперь нам нужно написать вот такой using, и это привнесет вот это вот next в
[22:29.960 --> 22:40.120]  список перегрузок, которые мы будем рассматривать, и это нам все еще не сломает на самом деле вот эту
[22:40.120 --> 22:51.000]  перегрузку, которую нам ADL находит. Запускаем, и оно работает ровно так, как мы ожидали. Для
[22:51.000 --> 23:00.000]  кастомного типа, где с помощью ADL находится специализированная версия, мы находим ее. Для
[23:00.000 --> 23:14.320]  общих типов находится дефолтная версия. Вот. Собственно отсюда берется нужда везде в шаблонном
[23:14.320 --> 23:25.440]  коде, где вы используете std swap, std begin, std end делать вот такую хитрую технику, но это конечно
[23:25.440 --> 23:33.160]  же неудобно. И вот ровно отсюда берются неблоиды, которые, собственно, единственное, что делают,
[23:33.160 --> 23:49.000]  это оборачивают вот эту вот, вот эти две строчки в удобную готовую функцию. Ну, как мы помним,
[23:49.000 --> 24:00.200]  неблоиды в прошлый раз они были какими-то объектами странными. Нужно понять, почему. Если мы
[24:00.200 --> 24:10.080]  просто скажем, что айда определю в глобальном namespace функцию next.
[24:30.200 --> 24:49.240]  И туда вот эти вот штуки оберну и сделаю next.t. Ну, конечно, у нас будет ambiguous. Вот этот next,
[24:49.240 --> 24:56.840]  который мы привнесли сюда из mylib, он точно так же выглядит, как другой next. И из-за этого
[24:56.840 --> 25:03.920]  получается конфликт. Компилятор не может понять, пытаемся ли мы рекурсирно запустить самого себя,
[25:03.920 --> 25:15.800]  здесь return, конечно, или мы пытаемся из mylib взять next. Так что такое не пройдет. Мы можем поменять
[25:15.800 --> 25:29.840]  название вот этого next, на какое-нибудь подчеркивание, и сказать всем, айда использует только вот это. И это
[25:29.840 --> 25:42.080]  тоже сработает. Но это не очень удобно, когда нужно хранить в памяти, что вызывая, нужно там одно
[25:42.080 --> 25:51.560]  название функции делать. А кастомизируя, нужно использовать другое название функции, просто next.
[25:51.560 --> 25:58.680]  Ну, эти названия примерно. На деле бы мы, наверное, все-таки функцию для кастомизации назвали как-то
[25:58.680 --> 26:13.440]  более кривые и неприятно, а общую функцию как-то более красивую. Ну и это нас не лишает еще одной
[26:13.440 --> 26:19.880]  проблемы. Если кто-то забылся и кастомизировал вот это next подчеркивание, то это нам все планы ломает.
[26:19.880 --> 26:41.720]  Вот если здесь сделать вот так. Ну да, конечно, идея в том, чтобы этот next тоже поместить в
[26:41.720 --> 26:48.080]  какой-нибудь namespace, потому что, ну не хорошо глобальный namespace засорять всякими своими
[26:48.080 --> 27:01.640]  функциями. Хорошо бы все класть в namespace. Вот, и кто-то забыл и сделал вот так вот. У нас
[27:01.640 --> 27:08.440]  вновь ничего не работает. Оба раза дефолтная должна вызваться, что у нас все еще в оборот кидает.
[27:08.440 --> 27:19.080]  Беда, неприятно, очень легко отстрелить себе ногу, хочется лучше. И вот ровно из-за этого
[27:19.080 --> 27:26.920]  не bloid это не просто вот такие функции обертки с юзингами, а те самые хитрые структурки с
[27:56.920 --> 28:05.280]  принимающий temp% и говорили, что вот он уже делает неквалифицированный вызов next.
[28:05.280 --> 28:23.120]  Что не так? Да, и вот здесь мы ловим этот самый redefinition,
[28:23.120 --> 28:39.840]  которого нас спасет хитрый трюк с этим самым inline namespace. Вот этот вот inline namespace это
[28:39.840 --> 28:45.880]  достаточно непонятная штука, но в сухом остатке он просто подмешивает содержимое того,
[28:45.880 --> 28:54.520]  что было снаружи во внешний namespace и спасает нас от вот этого вот конфликта. И теперь,
[28:54.520 --> 29:22.240]  когда мы делаем myLeaveNext, да, происходит что-то не то, а кажется нужно что-то вот такое сделать
[29:22.240 --> 29:31.680]  возможно. Сейчас давайте лучше. Я посмотрю, потому что я опять забыл. Слишком много тонкостей.
[29:31.680 --> 29:40.080]  Секунду.
[30:01.680 --> 30:24.080]  Да, странно, странно. Да, почему-то это работает чуть иначе, но так как это лютая магия, я не думаю,
[30:24.080 --> 30:29.800]  что нам стоит задумываться об этом. Нам нужно сделать вот так.
[30:29.800 --> 30:54.240]  А почему?
[31:00.800 --> 31:09.760]  Так, давайте на секундочку прерву демонстрацию и поточним по своему коду. Тяжело без двух мидоров,
[31:09.760 --> 31:35.840]  конечно. Да, почему-то действительно вот ровно так не получится у нас.
[31:35.840 --> 31:46.120]  Нам таки придется сделать вот так, то есть разделить объявление этой структурки,
[31:46.120 --> 32:12.040]  и объявление этой переменной. Вот, теперь у нас next лежит в namespace myLeave из-за того,
[32:12.040 --> 32:26.920]  что мы внутри InlineNamespace объявили. Секундочку.
[32:56.920 --> 33:04.080]  Дефолт лежит внутри Detail, но при этом при вызове отсюда мы видим, так как лежим в том же namespace,
[33:04.080 --> 33:12.600]  вот этот вот дефолт. Более того, если вдруг где-то в родительских namespace объявлена другая
[33:12.600 --> 33:21.640]  функция next, например, кто-то случайно объявил в глобальном namespace next, а вот этот next его спрячет.
[33:21.640 --> 33:40.680]  Ну и, может быть, сделать вот так, и убедиться, что все будет ток.
[33:40.680 --> 33:55.320]  Вот, соответственно, вот этот вот using, который у нас там раньше был myLeave, он не нужен, мы и так
[33:55.320 --> 34:09.720]  видим этот next, за счет того, что мы используем переменную теперь next вместо... что не так?
[34:09.720 --> 34:17.920]  А, да, конечно, я опять забыл эту штуку. Да, за счет того, что мы используем переменную вместо обычной
[34:17.920 --> 34:28.120]  функции. Мы выключили ADL, вот, а, видимо, зашедовать вот эту штуку так просто не получится.
[34:28.120 --> 34:51.960]  Там предлагают вот так сделать, но это не помогает. Ладно, неважно. Вот, и, собственно, это profit,
[34:51.960 --> 35:00.840]  и это то, как работают точки кастомизации в библиотеке ranges. Вновь на нее посмотрим.
[35:00.840 --> 35:16.800]  Size. Точно такой же inline namespace, правда, именованный, но это ничего не дает. Точно такие inline constexpr
[35:16.800 --> 35:28.840]  переменные, тип которых указан вот здесь, но вместо такого дефолта одного, как мы сделали,
[35:28.840 --> 35:42.400]  в ranges есть несколько дефолтов для различных стандартных контейнеров, и они с помощью
[35:43.000 --> 35:58.120]  constexpr разбирают все кейсы. Да, только это, я не туда смотрю, кажется. А, это проверка noexcept.leon.
[35:58.120 --> 36:06.040]  Нам нужно смотреть сюда на оператор, круглые скобки, который делает то же самое. Если это
[36:06.040 --> 36:12.360]  сишный массив, то просто использовать какие-то лютые шаблоны, которые по сишному массиву получают
[36:12.360 --> 36:29.640]  размеры. Так, если есть метод size, то используем его. Если с помощью ADL, то есть вот этот вот
[36:29.640 --> 36:35.360]  ключевой момент, что у нас здесь с помощью ADL находится функция, он здесь даже более аккуратно
[36:35.360 --> 36:45.960]  обработан с помощью проверочки. Если с помощью ADL что-то находится, то мы используем это. Ну,
[36:45.960 --> 36:54.880]  еще какой-то дефолтный случай, который просто с помощью begin& и минуса вычисляет размеры.
[36:54.880 --> 37:01.360]  Соответственно, вот это можно считать основным дефолтом. По дефолту мы просто вычитаем
[37:01.360 --> 37:14.560]  begin&, но также имеем возможность кастомизировать в своем namespace вот эту функцию size и даже еще
[37:14.560 --> 37:24.040]  какие-то дефолты, сделанные хитрые. Ну, даже как метод можно сделать. В общем-то, комитет пришел к
[37:24.040 --> 37:32.160]  выводу, что именно так правильно делать точки кастомизации в библиотеках и никак иначе.
[37:32.160 --> 37:48.480]  Так, что дальше? А дальше нужно задуматься о следующем. Когда мы вот этот вот next используем
[37:48.480 --> 37:56.960]  здесь, мы как бы предполагаем, что у нас нет глобальной функции next. На самом-то деле, если кто-то
[37:56.960 --> 38:02.320]  в другой библиотеке, в другом inclusive какую-то другую next объявит, это может очень сильно нам
[38:02.320 --> 38:08.680]  попортить все планы. Она может случайно подойти в какой-то момент, непонятно почему, непонятно
[38:08.680 --> 38:19.520]  зачем. И это неприятно. Особенно неприятно для стандартной библиотеки, в которой чем больше таких
[38:19.520 --> 38:27.760]  точек кастомизации, как мы видели, их тут уже прилично, на самом деле их еще больше, тем больше
[38:27.760 --> 38:37.560]  мы вот таких глобальных имен, которые используем в ADL, прямо резервируем. Имя begin зарезервировано
[38:37.560 --> 38:43.400]  в глобальном namespace, и ничего begin нельзя объявлять. И особенно это шокирует людей, которые
[38:43.400 --> 38:50.640]  начинают на плюсах писать. Они решили у себя просто какую-то простую олимпиадную задачку,
[38:50.640 --> 38:58.200]  решая написать функцию там begin. Но что могло пойти не так? А что-то пошло не так. Она нашлась с
[38:58.200 --> 39:06.880]  помощью ADL в каком-то вызове стандартной библиотеки, произошел взрыв. И это плохо. Это плохой
[39:06.880 --> 39:12.600]  дизайн языка. Мы как бы резервируем все больше и больше с каждым новым фичей ключевых слов,
[39:12.600 --> 39:18.720]  которые вроде как... А почему они зарезервированы? Это же даже не ключевые слова языка, а просто
[39:18.720 --> 39:25.880]  какие-то функции стандартной библиотеки, которые просто так работают, хитро, что любой шаг вправо,
[39:25.880 --> 39:37.400]  шаг влево, и мы их ломаем. Вот. И соответственно за этим и нужен Tag&Walk. Tag&Walk это супер
[39:37.400 --> 39:45.680]  простая идея. Мы резервируем не много имен, мы резервируем одно. И это имя будет называться
[39:45.680 --> 40:00.480]  ровно так. Tag&Walk. То бишь теперь отдельная точка кастомизации будет, да, так форматировать
[40:00.480 --> 40:23.280]  правильно. Которая будет называться Tag&Walk. И нам нужно вот эту штуку. Вот. Тут мы с помощью ADL
[40:23.280 --> 40:30.640]  одно единственное зарезервированное имя Tag&Walk будем использовать, но так как мы через одно это
[40:30.640 --> 40:41.240]  единственное имя хотим пробросить как бы любой вызов к чему угодно вообще, где угодно, нам нужно
[40:41.240 --> 40:48.480]  как-то на основе аргументов выбирать из сотен разных перегрузок, потому что мы собрались как бы
[40:48.480 --> 40:56.760]  вот все функции, которые там были, begin, end, size и прочее, все их пробрасывать через этот Tag&Walk.
[40:56.760 --> 41:02.840]  А это значит, что у этого Tag&Walk будет столько перегрузок, сколько суммарно перегрузок у каждой
[41:02.840 --> 41:09.600]  из этих функций. И это может быть очень много, это может быть очень больно. Но сначала вопрос,
[41:09.600 --> 41:17.000]  а как вообще отличить какую перегрузку мы хотим? Ну, для начала на уровне, какую из функций мы
[41:17.000 --> 41:25.400]  собрались вызывать? Метод, который мы уже видели, использовать теги. С помощью тегов мы будем
[41:25.400 --> 41:37.760]  использовать произвольный тип tag, который нам должны передать, а также аргументы, которые мы
[41:37.760 --> 41:44.200]  дальше принимаем, ну их может быть сколько угодно. Раз уж мы любую точку кастомизации пропускаем,
[41:44.200 --> 41:55.400]  лучше бы мы умели сколько угодно много аргументов пропускать. И, соответственно, да, давайте скажем,
[41:55.400 --> 42:00.600]  что все по ссылке передается, чтобы лишних копирований не было, хотя они скорее всего
[42:00.600 --> 42:09.600]  оптимизируются. И мы здесь хотим заформить. Возвращаем мы уже теперь, конечно, что угодно.
[42:09.600 --> 42:18.640]  Все вот эти вот функции различные begin and size. Возвращаемые типы у них разные, количество
[42:18.640 --> 42:25.240]  аргументов разное, поэтому здесь мы это отразим. Раз уж мы через один и тот же вызов пропускаем
[42:25.240 --> 42:32.640]  произвольное число аргументов, произвольный возвращаемый тип. Но вот в прошлый раз
[42:32.640 --> 42:39.880]  особо неподробно это проговорил. Вот так нам написать не подойдет. Нам нужно именно
[42:39.880 --> 43:03.520]  явно написать decal type от вот этого выражения. Вот. Зачем? Это сложный вопрос. Я вновь забыл на него
[43:03.520 --> 43:10.840]  ответ. Ну, помним, что это как бы вот так вот у нас работает SFINAE. Если бы написали decal type
[43:10.840 --> 43:20.200]  от auto, то SFINAE бы не было. Но случай, когда у нас с помощью ADL не находится тег-н-воука,
[43:20.200 --> 43:27.960]  и мы хотим какую-то другую перегрузку оператора круглой скобки, кажется нету.
[43:27.960 --> 43:38.400]  Боюсь наврать, но вот я почти уверен, что такого кейса нету, поэтому мы все-таки вот так сделаем.
[43:38.400 --> 43:50.880]  Авторы статьи рекомендуют что? Вот они рекомендуют все-таки, а нет, это fcpo, это ok.
[43:57.960 --> 44:15.880]  Да, а как они рекомендуют сам тег-н-воук? Определить? Никак не рекомендуют.
[44:15.880 --> 44:39.360]  Окей, здорово. Нет, нигде нет. Что ж такое? Беда. Ну, мы можем подойти альтернативно,
[44:39.360 --> 44:45.280]  посмотреть как единственной имплементации рабочей определяется тег-н-воук. Ну вот,
[44:45.280 --> 44:54.480]  они здесь тоже делают такой decal type. Ну вот непонятно, зачем они это делали? Такой оператор круглой
[44:54.480 --> 45:01.440]  скобки есть всего один у этой структурки, другая перегрузка из SFINAE выбраться не может. Очень
[45:01.440 --> 45:13.080]  странное поведение. Видимо надо на него забить ехать дальше. Код. Все пропускаем через тег-н-воук.
[45:13.080 --> 45:28.660]  Да, пока так и задумано, только назвать его нужно вот так. И теперь вот в этих вот
[45:28.660 --> 45:41.160]  неблоидах вроде next, которые мы все еще оставляем вот такими хитрыми с объектом,
[45:41.160 --> 45:46.120]  который на самом деле вызывается, чтобы отключить ADL, который может нам случайно попортить все,
[45:46.120 --> 46:07.720]  мы вызываем тег-н-воук. Ну а дефолт мы можем, по примеру, ренджей, например, стелем. Что если
[46:07.720 --> 46:26.960]  тег-н-воук сработает, это можно проверить, например, вот так. То используем его. Если не сработает,
[46:26.960 --> 46:43.360]  то используем, например, вот это. И скажем, что это дефолт. Объект полностью еще остается,
[46:43.360 --> 46:50.160]  чтобы отключить ADL. И вот этот вот итератор мы все-таки в конце передвинем вниз, чтобы он
[46:50.160 --> 47:06.200]  использовал именно вот этот объект. Окей. Да, я думаю, даже вот это требование теперь лишнее,
[47:06.200 --> 47:14.080]  что вернулось что-то с AMS. Мы просто хотим, чтобы вот этот вызов через точку кастомизации работал.
[47:14.080 --> 47:23.740]  Вот. Как теперь кастомизировать? Теперь у нас ADL идет не через главальное имя Next, а главальное
[47:23.740 --> 47:34.920]  имя тег-н-воук. И вот это уже позволит более, так сказать, тоненько кастомизировать с помощью ADL,
[47:34.920 --> 47:47.760]  цпо, потому что раньше нам приходилось в namespace определять такую функцию next. И, ну,
[47:47.760 --> 48:00.200]  по-хорошему мы хотим, чтобы в любом пользовательском коде весь доступ к этому next шел через вот этот
[48:00.200 --> 48:09.040]  объект. А если мы вот так вот определяем этот next, то, ну, кто-то случайно через него может
[48:09.040 --> 48:18.800]  пойти. Это раз. А два, таких next может очень много в namespace накопиться, и хотелось бы как-то
[48:18.800 --> 48:25.360]  экономить место, если этот next относится только к вот этому other Iter и больше ни к чему другому.
[48:25.360 --> 48:37.760]  И вот тут как раз выезжает секретная техника с френдами. И, соответственно, мы теперь не next,
[48:37.760 --> 48:43.760]  а тег-н-воук кастомизируем. Но вот здесь нужно написать тип тега, про это сейчас скажу. Вот.
[48:43.760 --> 48:51.120]  А что делает такое странное объявление френда шаблонного еще и с определением? Оно вставляет
[48:51.120 --> 48:59.160]  просто такую функцию в окружающий namespace, то есть namespace-user. Но чем это лучше, чем то,
[48:59.160 --> 49:05.280]  что было раньше? А тем, чтобы как определенные френды их нельзя вызвать напрямую никогда,
[49:05.280 --> 49:13.960]  только через ADL. Соответственно, это ровно то, что нам нужно. Мы собираемся их вызывать только
[49:13.960 --> 49:20.800]  через ADL, посредством тег-н-воука, а в глобальном namespace нам их иметь совершенно не обязательно.
[49:20.800 --> 49:30.720]  И когда точек кастомизации становится вот примерно столько, неприятно класть их в глобальный
[49:30.720 --> 49:36.640]  namespace. Более того, кладя их в глобальный namespace, они начинают участвовать в
[49:36.640 --> 49:46.440]  overload-сетах различных. Конечно, они чаще всего будут не подходить и выкидываться,
[49:46.440 --> 49:55.560]  но это нам неприятно, потому что это замедляет время компиляции. Такие штуки будут использоваться
[49:55.560 --> 50:03.360]  только когда они найдены ADL, соответственно, меньше overload-сет, меньше нагрузка на компилятор,
[50:03.360 --> 50:15.280]  всем лучше. Теперь про какой здесь тип поставить, как получить тип вот этой структурки. Мы можем,
[50:15.280 --> 50:21.880]  конечно, к нему явно обратиться, но это не очень здорово. Нам бы хотелось через next его выразить,
[50:21.880 --> 50:27.840]  и вот если мы его выразим через next, что получится? декл-тайп от mylib-next,
[50:27.840 --> 50:36.440]  но не все, потому что этот декл-тайп нам скорее всего вернет конст-ссылку. Соответственно,
[50:36.440 --> 50:52.040]  нужно написать remove-svref от вот этого, но очень много букв, поэтому предлагается определить helper,
[50:52.040 --> 51:13.440]  который за нас будет делать вот эти две вещи, так это называется, пропозали remove-svref и декл-тайп от cbo.
[51:13.440 --> 51:23.880]  Соответственно, теперь мы можем написать
[51:23.880 --> 51:37.640]  next, и это должно работать, и это не работает.
[51:37.640 --> 51:58.560]  Кстати, я вот так хотел. Оно не смогло замачить наш overload.
[51:58.560 --> 52:08.400]  В этом overload ожидает создатель персант.
[52:15.400 --> 52:16.440]  Она пришло что?
[52:28.560 --> 52:52.680]  А, вот где я доложал, да, беда.
[52:58.560 --> 53:17.200]  Нет. Давайте уберем на всякий случай mylib, и все-таки используем forward.
[53:17.200 --> 53:46.800]  Оно не нашло для итера, вот этого итера, который мы хотели чтобы в default шел.
[53:46.800 --> 53:56.600]  А, то есть не сработало вот это вот фишечко.
[53:56.600 --> 54:23.680]  Давайте подсмотрим, да, там есть небольшая жуть, чтобы ее избежать,
[54:23.680 --> 54:49.840]  мы сделаем так, нет, даже не так, мы объявим helper, который проверяет получится ли сделать
[54:49.840 --> 54:59.040]  тег-инвок с конкретными аргументами, конкретными типами аргументов. И этот helper, конечно же,
[54:59.040 --> 55:05.120]  нужно делать в том же месте, где и сам тег-инвок, чтобы ADL у нас происходил точно так же.
[55:05.120 --> 55:32.280]  Соответственно, по аналогии с тем, что там было. Так, так, так, так. Да.
[55:35.120 --> 55:47.000]  Мы можем даже лучше. Да, я путаю два разных reflinks, на которые ссылаюсь. Мы можем сразу
[55:47.000 --> 56:07.760]  за-abuse-it, и просто использовать вот такую штуку. То есть в SVSTD есть шаблон, который точно правильно
[56:07.760 --> 56:16.160]  написан и никаких проблем нет, который проверяет получится ли запустить какой-то функтор или
[56:16.160 --> 56:22.400]  функциональный тип с какими-то аргументами. В нашем случае это вот этот тег-инвок, его операторы
[56:22.400 --> 56:30.720]  круглые скобки. Аргументы это tag и test. И соответственно, здесь мы будем проверку ровно с помощью этого
[56:30.720 --> 56:54.960]  helper производить. CPU у нас будет так. This. Да, так, конечно, не выйдет. Просто впишем. И так. Так, так.
[56:55.160 --> 56:57.360]  Теперь вы не туда.
[57:07.600 --> 57:08.480]  Что ж такое?
[57:08.480 --> 57:33.160]  Mancon still value. Carvalue. Почему же это value? Потому что надо все формулировать. Да.
[57:33.160 --> 57:40.240]  Still value. Очень странно.
[57:40.240 --> 58:09.840]  Кажется, проблема
[58:09.840 --> 58:25.920]  в том, что мы вот здесь показали те, кто на самом деле даем персант, и умирало оно ровно от этого.
[58:25.920 --> 58:37.720]  Да, оно умирало от этого, но почему-то оно все равно не хочет.
[59:07.720 --> 59:24.080]  А вот мы и узнали, для чего там декл-тайп так был написан. Да, важная деталь оказывается. Вот
[59:24.080 --> 59:32.040]  эта функция, которую у нас std-invocable использует, она ведь написана с помощью концептов точно так же,
[59:32.040 --> 59:40.160]  как мы раньше это писали. Вот я сразу написал requires, ла-ла-ла, и это не сработало. Я начал
[59:40.160 --> 59:55.640]  паниковать и накручивать всякие модные фишки, но не надо было. Вернем как было и поймем,
[59:55.640 --> 01:00:07.000]  что тег-ин-вок-оператор круглой скобки, ну концепт что проверяет? Что такое выражение валидно. Он
[01:00:07.000 --> 01:00:13.680]  не проверяет, скомпилируется ли вся функция. Он проверяет, только скомпилируется ли ее declaration.
[01:00:13.680 --> 01:00:22.120]  И его не волнует то, что вот здесь уже внутри, когда мы пойдем вычислять, вернее инстанцировать
[01:00:22.120 --> 01:00:30.200]  сам шаблон. Мы не найдем вот это вот тег-ин-вок, его волнует только declaration. А он, ну да,
[01:00:30.200 --> 01:00:40.040]  он нормальный, с ним все хорошо. Поэтому мы делаем вот так вот и засовываем туда ровно то же
[01:00:40.040 --> 01:00:49.840]  самое. Теперь вот это выражение часть declaration. И чтобы проверить, что вызов вот этого оператора
[01:00:49.840 --> 01:00:57.240]  круглой скобки вообще корректен, нам нужно сходить и проверить, а корректен ли вызов тег-ин-вок
[01:00:57.240 --> 01:01:10.160]  из глобального namespace, вызов с помощью ADL. Вот, и теперь если мы это запустим, уже будет все хорошо.
[01:01:10.160 --> 01:01:21.080]  Вот мы все выяснили. И, кажется, я изложил все, что нужно по тег-ин-воку в достаточных деталях.
[01:01:21.080 --> 01:01:34.120]  Есть только еще, ну да, есть еще детали. Ладно, детали здесь бесконечны. Вот такой метод кастомизации
[01:01:34.120 --> 01:01:41.160]  с фронтами, как мы использовали где, вот здесь. Он, конечно, классный, когда вы свой код пишете.
[01:01:41.160 --> 01:01:52.080]  Но когда вы хотите для чужой библиотеки сделать запускаемым, ну, кастомизировать точку для типа
[01:01:52.080 --> 01:02:06.480]  из другой библиотеки, например, все того же. Вот такого типа, да.
[01:02:06.480 --> 01:02:33.080]  Бит 2. Взять, пойти в std, вектор, итератор и объявить там фронта. Мы не можем. Соответственно, нужна какая-то
[01:02:33.080 --> 01:02:43.920]  возможность, так, нужна какая-то возможность сделать шаблонные такие кастомизации для целого
[01:02:43.920 --> 01:02:53.480]  набора типов. И такая возможность таки есть. Ну, конечно, в нашем случае, да, для std-вектора у нас
[01:02:53.480 --> 01:03:03.880]  работает наш дефолт, который мы объявили. Ну, бывает, что не работает. И, да, ладно, ну, плохо,
[01:03:03.880 --> 01:03:09.960]  плохо через std-вектор. Давайте просто представим, что вот этот атер итер лежит непонятно где,
[01:03:09.960 --> 01:03:18.280]  и использовать вот это вот, мы, правда, не имеем. Как можно, куда можно еще положить функции теган
[01:03:18.280 --> 01:03:37.720]  волк, чтобы они были видны. Вот в этот момент. Если мы положим их в... Вернее, не так. Плохо, конечно,
[01:03:37.720 --> 01:03:48.360]  класть так, что они видны были бы вот здесь вообще для любого теган волка. Нам, наверное,
[01:03:48.360 --> 01:03:54.640]  хочется более мелкогранулированного и мелкогранулированной кастомизации и
[01:03:54.640 --> 01:04:06.640]  делать так, чтобы они видны были вот в этом контексте. Соответственно, да, здесь, наверное,
[01:04:06.640 --> 01:04:14.800]  можно уточнить, что мы mylib теган волк используем, чтобы здесь это или не происходило. Это ведь
[01:04:14.800 --> 01:04:29.160]  нам ничего не словно. Правда? Да, все нормально. Нет, не нормально. Что произошло? Наверное,
[01:04:29.160 --> 01:04:55.640]  это вот эта штука. Да, в реквайерсе, конечно, нужно вот так делать. И так это работает. И что
[01:04:55.640 --> 01:05:03.520]  произошло? Почему резко все сломалось? Теган волк.
[01:05:25.640 --> 01:05:47.200]  Так, это супер странно. То есть здесь происходил ADL, и мы попадали в нужный теган волк через него.
[01:05:47.200 --> 01:05:56.800]  А теперь мы идем в mylib теган волк, то есть используем эту переменную. Приходим сюда и делаем
[01:05:56.800 --> 01:06:05.080]  модель здесь. И он не срабатывает. Вернее, не так. У нас получается проверить, что оно теган волк.
[01:06:17.200 --> 01:06:45.040]  То есть для рыдра она теперь перестала находить
[01:06:45.040 --> 01:07:11.520]  так. Как обычно, с такими сложными вещами происходит какой-то треш. Я был уверен,
[01:07:11.520 --> 01:07:30.480]  что я разобрался со всем трешем, что может произойти, но он все равно происходит. Да,
[01:07:30.480 --> 01:07:41.080]  никто не следит за тем, что происходит. Правильно, все уже отвалились. Я же закомментировал то,
[01:07:41.160 --> 01:07:55.520]  что должно было находиться. Конечно, оно перестало находиться, если его убрал. Да, все нормально.
[01:07:55.520 --> 01:08:08.640]  Паника отменяется. Да, customized запустился. Все хорошо. Так запускается default. Все отлично.
[01:08:08.640 --> 01:08:16.960]  Так вот, речь шла о том, как сделать не во френде и внутри класса, а где-то снаружи. Потому что,
[01:08:16.960 --> 01:08:30.560]  если мы на самом деле вот это все возьмем и просто где-нибудь объявим, не пойми где. Подмешивать
[01:08:30.560 --> 01:08:36.840]  что-то в namespace от чужих библиотек мы считаем, что нехорошо. Поэтому, вероятно, мы объявили это в
[01:08:36.840 --> 01:08:58.000]  своем namespace. Да, и теперь это не френд. И вот оно, конечно, теперь не найдется. Да, default. И вот
[01:08:58.000 --> 01:09:06.800]  вопросик. Давайте придумаем способ, как подхачить, чтобы в этом месте тег инлок мог находить какие-то
[01:09:07.320 --> 01:09:18.880]  штуки, объявленные не френдами. Где их объявить? Или даже более тонко, то о чем он начал говорить.
[01:09:18.880 --> 01:09:35.200]  Как сделать, чтобы тег инлок, используемый в next.cpo находил что-то кастомное и как бы не френда,
[01:09:35.200 --> 01:09:41.400]  а просто что-то в каком-то namespace определенное. У кого-нибудь есть идеи?
[01:09:41.400 --> 01:09:54.280]  Я чувствую бесполезность спрашивать. Подайте голос, что еще здесь и как-то отзовитесь. Есть
[01:09:54.280 --> 01:10:13.720]  понимание, что происходит. Мы еще живы, но очень много деталей. Ну да, поэтому я подумал дать
[01:10:13.720 --> 01:10:23.800]  задачу, потому что не прочувствовав это самому на своей шкуре, плохо понятно. Ну окей, давайте я
[01:10:23.800 --> 01:10:30.720]  тогда договорю и мы с этим постараемся закончить. И все-таки лучше разберем вторую домашку. А вот
[01:10:30.720 --> 01:10:37.720]  этот TypeRager, который я в прошлый раз обещал, мне кажется уже нет смысла рассказывать. Очень
[01:10:37.720 --> 01:10:54.680]  тяжело, очень сложно. Лучше его как-то в домашку дать. Так вот, как сделать кастомизации какие-то
[01:10:54.680 --> 01:11:07.560]  глобальные, не связанные с каким-то конкретным типом или классом. Адаптеры, так сказать. Мы можем взять и
[01:11:07.560 --> 01:11:23.920]  объявить какой-нибудь namespace customizations в MyLib, а там объявить структуру magic. Next.cpo мы
[01:11:23.920 --> 01:11:41.240]  наследуемся структурке magic. И теперь нашей кастомизации мы будем лепить вот именно в этот
[01:11:41.240 --> 01:11:55.640]  namespace. Где кастомизация? Вот кастомизация. То есть это как бы отдельно отведенный namespace,
[01:11:55.640 --> 01:12:02.000]  который окей засоряет и класть туда больше функций, если конечно не жалко времени компиляции,
[01:12:02.000 --> 01:12:13.400]  которая конечно замедлится. Вот. Теперь надо посмотреть, будет ли это работать. И это работает.
[01:12:13.400 --> 01:12:30.800]  И вот вопрос. Как так выходит? Почему ADL вот в этом месте находит вот эту кастомизацию на
[01:12:30.800 --> 01:12:39.240]  namespace и MyLib customizations? Все дело, конечно, в классе magic. Если его убрать, то работать оно не будет.
[01:12:39.240 --> 01:12:56.880]  И лучше это, конечно, со ссылками цепи preference смотреть. Так. Вот здесь оно было. И нам нужен
[01:12:56.880 --> 01:13:07.280]  VDL. И вот тут в VDL описана куча-куча разных вариаций того, где что, когда считается так
[01:13:07.280 --> 01:13:17.960]  называемым ассоциированным множеством namespace и классов. Да, так оно немножко закрыто. Вот.
[01:13:17.960 --> 01:13:28.640]  Ассоциированное множество namespace и классов для конкретного вызова. То есть для вызова,
[01:13:28.640 --> 01:13:38.360]  ну, например, лежащего внутри вот этого tagging-book. Это целый списочек. Что нам интересно,
[01:13:38.360 --> 01:13:50.480]  это классы аргументов и их базовые классы, а также namespaces, в которых они лежат. То бишь,
[01:13:50.480 --> 01:13:58.680]  когда мы, вот у нас внутри этого tagging-book, внутри std-invoke происходит вот ровно тот же
[01:13:58.680 --> 01:14:14.600]  requires tagging-book this10. И вот этот tagging-book по типу this, он видит тип next-cpo. У next-cpo есть
[01:14:14.600 --> 01:14:21.480]  parent, а parent лежит на namespace-customizations. Поэтому namespace-customizations попадает в набор
[01:14:21.480 --> 01:14:28.840]  ассоциированных namespaces и классов. И все перегрузки, которые там определены, они будут
[01:14:28.840 --> 01:14:40.280]  участвовать в ADL. И поэтому вот эта кастомизация у нас найдется. Вот. Соответственно, два способа,
[01:14:40.280 --> 01:14:50.800]  как делать кастомизации, это friend внутри класса, который вы определили, либо шаблон в ассоциированном
[01:14:50.800 --> 01:15:05.720]  namespace с этим customization-point. Вот, соответственно, шаблон, он может быть здесь сколько угодно
[01:15:05.720 --> 01:15:16.440]  сложным. Мы, например, можем произвести следующую магию. Да, скопируем вот это все, но теперь скажем,
[01:15:16.440 --> 01:15:37.720]  что мы принимаем какой-то конкретный тег. Вообще любой тег. И на вход мы берем unicptr.att. Возвращать
[01:15:37.720 --> 01:16:03.200]  мы будем тегом invoke от тега, который мы просто зафорвардим в memory. И звездочка
[01:16:03.200 --> 01:16:13.720]  тега. То бишь, мы форвардим любые вызовы next, вернее даже не так, любые вызовы любого тега
[01:16:13.720 --> 01:16:25.200]  над unicptr мы форвардим к вызовам того же тега над содержимым unicptr. И даже можно сделать
[01:16:25.200 --> 01:16:35.080]  авто. И вот здесь уже точно нужно particle type, чтобы у нас лишняя перегрузка не взялась.
[01:16:35.080 --> 01:16:50.800]  Да, этот шаблончик мы еще не завели, но я думаю завести стоит. Лучше его скопировать,
[01:16:50.800 --> 01:17:02.520]  чтобы не тратить время. Шаблончик для определения типа. Да, он будет выглядеть точно так же,
[01:17:02.520 --> 01:17:26.240]  как теган лукабл. Надо будет using. И вот эта штука. И теперь вот в том месте мы можем
[01:17:26.240 --> 01:17:41.600]  использовать теган лук резал т, тега и т, но предположим по ссылке. И уже без декл тай.
[01:17:41.600 --> 01:18:01.120]  Соответственно, если мы теперь сделаем unicptr, давайте даже.
[01:18:11.600 --> 01:18:17.840]  То с этим юма тоже сможем запустить точку кастомизации.
[01:18:17.840 --> 01:18:35.280]  Если мы конечно соберем синтаксис плюсов. А не соберем мы его где?
[01:19:11.600 --> 01:19:30.520]  А, вот здесь. Да, наверное не стоит. Да, и таки работает.
[01:19:30.520 --> 01:19:44.080]  Физов next для unicptr зафорвардился к вот этому теган луку, который в свою очередь зафорвардил
[01:19:44.080 --> 01:19:55.120]  к содержимому. Ну и при желании мы даже можем здесь потребовать что-нибудь вроде
[01:19:55.120 --> 01:20:24.320]  не same as тег от next. То есть что это делает? Это запрещает тегу быть вот этим вот.
[01:20:24.320 --> 01:20:37.480]  тегом для next. И тогда, и тогда да, у нас не получится зафорвардить этот конкретно этот тег
[01:20:37.480 --> 01:20:47.920]  next, зато все остальные теги будут спокойно форвардиться и работать. И в целом вся эта штука,
[01:20:47.920 --> 01:20:57.200]  она дает огромное пространство для кастомизации и как бы инкрементальной такой кастомизации
[01:20:57.200 --> 01:21:04.680]  только тех частей, которые вам нужны. То есть обернув какую-нибудь штуку, вы можете там большую
[01:21:04.680 --> 01:21:14.680]  часть вызовов зафорвардить к обертке и только некоторые кастомизировать. И это по сути то,
[01:21:14.680 --> 01:21:25.560]  как паттерн адаптер или даже прокси возможно, нужно делать с compile-time полиморфизмом в плюсах
[01:21:25.560 --> 01:21:37.600]  по науке. Теперь нужно, когда все это включит стандарт. До этого никакого такого общего механизма
[01:21:37.600 --> 01:21:46.920]  не было, но это было практически невозможно. Вот на этом давайте прервемся на 10 минут,
[01:21:46.920 --> 01:21:58.720]  соответственно 50 продолжим. И давайте просто разберем домашку и разойдемся. И тогда за две
[01:21:58.720 --> 01:22:06.280]  недели напложу еще домашек, чтобы все это не просто так было рассказано, а село в голове.
[01:22:06.280 --> 01:22:10.960]  И тогда уже будут новые темы. Все, перерыв.
