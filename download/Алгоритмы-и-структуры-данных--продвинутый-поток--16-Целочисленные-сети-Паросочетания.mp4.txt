[00:00.000 --> 00:16.000]  Как уже говорилось, в 99% случаев почему-то во всех сетях, которые вам требуются, пропустые способности целочисленной.
[00:16.000 --> 00:18.000]  Верно или нет?
[00:18.000 --> 00:20.000]  Да не только.
[00:20.000 --> 00:32.000]  Ну нет, может иногда бывает, что там по дороге может проехать не более чем корень из трех пополам машин в минуту.
[00:32.000 --> 00:40.000]  Понятно, конечно, полтора землекопа в античной культуре не новость, но все.
[00:40.000 --> 00:48.000]  Хотя было бы круто, если бы он получил скорень из трех пополам землекопы, конечно.
[00:52.000 --> 00:57.000]  Итак, давайте себе представить, что тогда можно сказать.
[00:58.000 --> 01:12.000]  Ну, в принципе, уже зачастую можно заметить иногда, что если пропустые способности не только целые, но еще и не сильно большие, то иногда даже банальный метод Форда-Полкерсона даже каким-нибудь банальным ДФСом работает не сильно долго.
[01:12.000 --> 01:21.000]  Ну, мы думали, что, например, мы, вот еще одна оценка на метод Форда-Полкерсона в таком случае, вот здесь у нас есть оценка С.
[01:21.000 --> 01:33.000]  Ну, такие даже не оценка С. Теперь мы можем вообще оценить, что у нас метод Форда-Полкерсона на самом деле будет работать не более чем за О от Е умножить на, а сколько там потока вам реально надо искать.
[01:33.000 --> 01:41.000]  Логично, да? То есть вот если целые числа, то так. Это можно еще оценить так.
[01:41.000 --> 01:47.000]  Ну, еще, конечно, иногда размер потока мы, конечно, можем оценить не всегда, хотя иногда нам это пригождается.
[01:47.000 --> 01:58.000]  Но, например, если у нас есть классическая оценка С, то есть нам известно, что все пропускные способности, вот я напишу, в математическом виде, не превосходят какой-нибудь ценой большого,
[01:58.000 --> 02:12.000]  то мы можем тогда оценить, на самом деле, поток как Е умножить на вот так С на, ну, допустим, день от С.
[02:12.000 --> 02:20.000]  Ну, заметим, что поток уж точно больше не будет, правда? Наверное, просто из истока больше не выйдет.
[02:20.000 --> 02:28.000]  Так что можно вот так, или если уж совсем от степени избавиться, в принципе, можно написать ЕС на В и желание будет.
[02:28.000 --> 02:32.000]  Да, согласен, только что в предположении еще нет кратности.
[02:32.000 --> 02:34.000]  А где это, что это?
[02:34.000 --> 02:37.000]  Степень. В данном случае исходящее.
[02:37.000 --> 02:42.000]  То есть уже можно оценивать вот какими-нибудь таким образом.
[02:42.000 --> 02:45.000]  В чем заметьте, это просто метод Фордовских сонов банально.
[02:45.000 --> 02:49.000]  Ну, а если брать еще ситуации, когда нам не всегда нужен максимальный поток.
[02:49.000 --> 02:52.000]  Вот, например, есть такая классическая задача, например.
[02:52.000 --> 03:00.000]  Это, скажем там, Вася и Петя живут в одном доме, ходят в одну и тоже школу, в какой-то момент поссорились.
[03:01.000 --> 03:11.000]  И они хотят теперь придумать дорогу от дома до школы, не обязательно качайшую, но так, чтобы по одной и той же дороге они не ходили.
[03:11.000 --> 03:14.000]  Вот, например.
[03:14.000 --> 03:16.000]  Вот спрашивает, как тогда такое решать?
[03:16.000 --> 03:19.000]  Ну, допустим, для простоты, что дороги ориентированы.
[03:19.000 --> 03:20.000]  Ну, да.
[03:26.000 --> 03:27.000]  Ну, да.
[03:27.000 --> 03:28.000]  Совершенно верно.
[03:28.000 --> 03:33.000]  В этом случае просто, мы берем ориентированный граф, действительно объявляем,
[03:33.000 --> 03:37.000]  что это сеть пропустной способности всех игр Одды, мы запускаем поток величины 2.
[03:37.000 --> 03:45.000]  Вот этих нема не надо искать максимальный поток, нам просто нужно искать максимальный поток величины 2.
[03:45.000 --> 03:50.000]  не надо искать максимальный поток, нам просто нужно искать максимальный поток в величине 2
[03:50.000 --> 03:54.000]  это делается буквально двумя ДФС
[03:56.000 --> 04:02.000]  но правда, раз уж об этом зашла речь, стоит упомянуть об еще одном лайфхаке, который помогает
[04:02.000 --> 04:10.000]  а что делать, если они так поссорились, что они хотят не только в одной дороге не ходить вместе, но даже на площадях не встречаться?
[04:10.000 --> 04:12.000]  можно раздавить еще
[04:12.000 --> 04:14.000]  просто вот упомянем
[04:18.000 --> 04:23.000]  а то потом по результатам ДЗК кто-то там говорил, что может только подобные вещи нельзя придумать
[04:23.000 --> 04:28.000]  и как-то тот фальшу 42 человека как-то будет найти залог, как-то не помогает
[04:28.000 --> 04:30.000]  понимаешь?
[04:35.000 --> 04:37.000]  вот ситуация
[04:37.000 --> 04:43.000]  короче, если абсурдироваться от Васи и Пети, данный ориентированный граф, надо найти 2 пути от С до Т
[04:43.000 --> 04:47.000]  так, чтобы они не пересекались ни по вершинам, ни по ребрам
[04:47.000 --> 04:50.000]  по вершинам, кстати, по ребрам автоматически
[04:50.000 --> 04:52.000]  что делать?
[04:52.000 --> 04:55.000]  ну, хочется тоже решать задачу потоком
[04:55.000 --> 05:05.000]  но при этом сделать так, чтобы единица потока не могла проходить через одну и ту же вершину более чем один раз
[05:05.000 --> 05:07.000]  как это делается?
[05:07.000 --> 05:09.000]  тогда делается так
[05:09.000 --> 05:12.000]  если у вас есть вот такая вершина, допустим У
[05:17.000 --> 05:19.000]  то мы просто ее разваливаем
[05:19.000 --> 05:21.000]  говорим следующее
[05:21.000 --> 05:29.000]  что теперь у нас вместо вершины У есть вершина У входящая и У исходящая
[05:29.000 --> 05:34.000]  значит все ребра, которые входили раньше, входят в выходящую часть
[05:34.000 --> 05:37.000]  в аут входят исходящие
[05:37.000 --> 05:41.000]  и здесь есть пропускная способность А
[05:41.000 --> 05:46.000]  ну или там, если вам требует то, чтобы проходило не более чем сколько, то тут тоже можете написать
[05:46.000 --> 05:49.000]  да, вот такой вот хак есть
[05:49.000 --> 05:52.000]  как вы решаете, чтобы через одну вершину...
[05:52.000 --> 05:55.000]  да, чтобы через вершину тоже никто не приходил
[05:55.000 --> 05:58.000]  фактически мы давали пропускные способности вершинам
[05:58.000 --> 06:01.000]  ну да, на самом деле оказывается тоже можно
[06:04.000 --> 06:09.000]  конечно, на самом деле ориентированность тут особой роли не играет
[06:09.000 --> 06:11.000]  на самом деле
[06:11.000 --> 06:15.000]  поток же ориентированность это всегда то же самое, что была ребра в одни стадии
[06:15.000 --> 06:17.000]  ну, по сути, да
[06:17.000 --> 06:19.000]  ориентированность
[06:19.000 --> 06:23.000]  там конечно есть одна маленькая оговорка
[06:23.000 --> 06:25.000]  на самом деле
[06:27.000 --> 06:30.000]  там просто может так получиться
[06:30.000 --> 06:35.000]  смотрите, мы предположим сеть вот такая
[06:39.000 --> 06:41.000]  это не ориентированная
[06:41.000 --> 06:43.000]  да, не ориентированная сеть
[06:43.000 --> 06:47.000]  не, проблема не будет в том, что он тут не найдет какую-то потоку, он его, естественно, найдет
[06:47.000 --> 06:50.000]  просто если не очень аккуратно сделать, то просто что у нас тут получится?
[06:50.000 --> 06:52.000]  вот такое раздваивание не получится, да?
[06:52.000 --> 06:53.000]  а теперь какие ребра?
[06:53.000 --> 06:56.000]  вот те, допустим, мы не раздваиваем, потому что начхай
[06:56.000 --> 06:57.000]  вот
[06:57.000 --> 07:00.000]  а тут получается вот такая какая-то ситуация
[07:03.000 --> 07:05.000]  вот, а, и вот так
[07:06.000 --> 07:08.000]  ну и еще два ребра забыли
[07:08.000 --> 07:10.000]  да, еще какие? внутренние
[07:10.000 --> 07:12.000]  а, вот эти вот, да
[07:13.000 --> 07:14.000]  так
[07:15.000 --> 07:17.000]  что-то не то
[07:17.000 --> 07:18.000]  сейчас
[07:18.000 --> 07:21.000]  первый выход вершины должны входить в начало
[07:21.000 --> 07:23.000]  да, да, да, я ошибся
[07:23.000 --> 07:25.000]  видимо, проблема
[07:25.000 --> 07:30.000]  так, проблема будет в том, что мы как бы по одному ребру два раза пройдем
[07:30.000 --> 07:31.000]  а как мы пройдем?
[07:31.000 --> 07:34.000]  в чем проблема? вот, раз, а
[07:37.000 --> 07:38.000]  да, все же нормально
[07:38.000 --> 07:41.000]  да, как-то в данном случае проблем не будет
[07:41.000 --> 07:43.000]  хотя, нет, хотя
[07:43.000 --> 07:45.000]  хотя полностью не что
[07:45.000 --> 07:49.000]  ну хотя, да, как-то в эту вершину мы же иначе как отсюда не попадем
[07:49.000 --> 07:52.000]  да, да, да, думаю, все нормально будет
[07:53.000 --> 07:54.000]  да
[07:54.000 --> 07:55.000]  да
[07:55.000 --> 07:58.000]  ну да, тем более, видимо вообще нет проблем
[07:59.000 --> 08:00.000]  вот
[08:00.000 --> 08:04.000]  ну даже если бы они были, можно было отменять поток и не париться
[08:04.000 --> 08:05.000]  в случае чего
[08:05.000 --> 08:09.000]  правда, потом отдельно восстанавливать, в общем, на самом деле это не нужно
[08:09.000 --> 08:11.000]  вот, ну это вот, да, упомянули
[08:11.000 --> 08:12.000]  да, это вот важно
[08:12.000 --> 08:17.000]  но это как бы ситуация, когда нам просто требуется не максимальный поток, а поток величины два
[08:17.000 --> 08:19.000]  все, тогда два DFS-а, радость
[08:20.000 --> 08:23.000]  вот, но если поток все-таки большой
[08:24.000 --> 08:28.000]  тогда возникает такая, ну первая тут естественная мысль возникает
[08:28.000 --> 08:32.000]  вот, хорошо, вот у нас метод Форда Фолкерсона, он ищет хоть какой-нибудь
[08:32.000 --> 08:34.000]  да, чтобы пустить хоть сколько-нибудь
[08:36.000 --> 08:38.000]  а ведь можно задуматься
[08:40.000 --> 08:43.000]  а сколько пути он может вообще
[08:45.000 --> 08:51.000]  а может быть попробовать поискать путь, по которому можно припихнуть не один, а много
[08:52.000 --> 08:53.000]  и так
[08:53.000 --> 09:00.000]  начнется возникает такая, собственно, хитрая идея, которая ведуется масштабированию
[09:00.000 --> 09:01.000]  масштабирование
[09:07.000 --> 09:10.000]  вот такое вот слово, или по адресу это называется скейт
[09:12.000 --> 09:16.000]  кажется, скейт гораздо круче звучит, все масштабирование, в контексте этого
[09:17.000 --> 09:18.000]  философский вопрос
[09:19.000 --> 09:24.000]  в зависимости от того, насколько гармоничной вам кажется речь без излишних амбицизм
[09:25.000 --> 09:29.000]  мне кажется, очень гармоничное слово масштабирование вообще ни к чему я при чем
[09:29.000 --> 09:31.000]  ну, шкейт и масштабирование
[09:32.000 --> 09:33.000]  или как увеличение
[09:34.000 --> 09:40.000]  ну, скейт, шкала, шкалирование
[09:41.000 --> 09:43.000]  шкалирование потоку
[09:44.000 --> 09:45.000]  следующая лекция
[09:48.000 --> 09:49.000]  а в чем суть?
[09:50.000 --> 09:51.000]  ну, суть очень проста
[09:53.000 --> 09:54.000]  можно ее сформулировать так
[09:55.000 --> 09:59.000]  давайте будем, значит, запустим метод Фордо Фолкерсона
[10:00.000 --> 10:05.000]  но запустим его только по ребрам пропускной способности больше либорадной ц
[10:10.000 --> 10:11.000]  ну, значит, позапускали
[10:12.000 --> 10:15.000]  по каждой там, по всем путям сразу пропустили не меньше, чем ц
[10:16.000 --> 10:19.000]  можно сразу больше либорадной ц плюс один, чтобы точно ноль пропустить
[10:20.000 --> 10:21.000]  потом
[10:21.000 --> 10:23.000]  после этого уменьшим, говорим, так, может быть, еще поменьше
[10:24.000 --> 10:26.000]  давайте будем пускать ц пополам
[10:29.000 --> 10:31.000]  потом ц пополам 4
[10:32.000 --> 10:34.000]  чтобы это не один путь пускать, то есть пускаем, пока можем
[10:35.000 --> 10:36.000]  вот, и так
[10:37.000 --> 10:39.000]  ц поделить на 8, ну и так далее
[10:40.000 --> 10:41.000]  и тогда 1
[10:42.000 --> 10:46.000]  ну, понятно, что тут имеют место какие-то там округления в тулиную сторону, естественно
[10:46.000 --> 10:51.000]  думаю, суть понятна, не будут тут писать 2 в степени, там, лом 20-то, округленное куда-нибудь
[10:52.000 --> 10:53.000]  это не надо
[10:55.000 --> 10:56.000]  вот такая вот идея
[10:57.000 --> 10:59.000]  внимание, вопрос
[11:00.000 --> 11:04.000]  а за какую же ассимптотику это будет работать?
[11:05.000 --> 11:08.000]  логарифм ц шагов, на каждом шаге сейчас оттянем быстренько
[11:09.000 --> 11:10.000]  ну да, логарифм ц шагов
[11:13.000 --> 11:14.000]  ну вот
[11:14.000 --> 11:15.000]  ну вот
[11:16.000 --> 11:17.000]  ну вот
[11:18.000 --> 11:20.000]  и на каждом шаге сколько-то DFS
[11:21.000 --> 11:22.000]  и DFS работают за сколько?
[11:23.000 --> 11:24.000]  за E
[11:25.000 --> 11:26.000]  внимание, вопрос
[11:27.000 --> 11:29.000]  а сколько на каждом шаге будет DFS?
[11:31.000 --> 11:32.000]  не больше, чем
[11:33.000 --> 11:34.000]  что-то типа D
[11:37.000 --> 11:38.000]  для того чтобы это понять
[11:39.000 --> 11:40.000]  мы с вами сделаем следующее
[11:41.000 --> 11:42.000]  а давайте поймем
[11:42.000 --> 11:45.000]  вот вы сделали только что
[11:46.000 --> 11:49.000]  итерацию на C поделить 2 в степени
[11:51.000 --> 11:52.000]  а внимание, вопрос
[11:53.000 --> 11:55.000]  а сколько вообще потока осталось пихать?
[11:56.000 --> 12:00.000]  каков максимальный поток в остаточной сети?
[12:01.000 --> 12:04.000]  DFS, например, на следующую
[12:05.000 --> 12:07.000]  ну не больше, чем DFS на 2 вкаток
[12:08.000 --> 12:09.000]  это неправда
[12:10.000 --> 12:11.000]  есть одна маленькая подлятка
[12:12.000 --> 12:13.000]  мы сделали эту операцию
[12:14.000 --> 12:15.000]  верно только одно
[12:16.000 --> 12:17.000]  что нет пути из S в T
[12:18.000 --> 12:21.000]  в котором каждое ребро, профессиональное способство имеет вот такое
[12:22.000 --> 12:25.000]  но сами по себе большие ребра вполне могли остаться
[12:29.000 --> 12:30.000]  поэтому
[12:31.000 --> 12:32.000]  уже имеющимся на образах
[12:33.000 --> 12:36.000]  идею о том, что давайте посмотрим ребра из S
[12:37.000 --> 12:38.000]  надо модифицировать
[12:39.000 --> 12:40.000]  у нас есть разрез
[12:40.000 --> 12:41.000]  у нас есть разрез
[12:42.000 --> 12:46.000]  раз мы знаем, что мы не можем по ребрам с такими способностями дойти из S в T
[12:47.000 --> 12:51.000]  а давайте посмотрим, как всегда, а куда можем
[12:53.000 --> 12:56.000]  вот, до куда шли-шли-шли и вот разрез
[12:58.000 --> 13:01.000]  и давайте оценим пропускную способность этого разреза
[13:03.000 --> 13:05.000]  то есть тут торчат какие-то ребра
[13:07.000 --> 13:08.000]  к сожалению их максимальный
[13:09.000 --> 13:10.000]  да
[13:11.000 --> 13:15.000]  значит, на каждом из них написано что-то меньшее, чем C делить на 2 в степени K
[13:16.000 --> 13:17.000]  ну по определению
[13:18.000 --> 13:22.000]  а мы сейчас не идем по ребрам меньше в какую-то величину
[13:23.000 --> 13:24.000]  меньше
[13:25.000 --> 13:30.000]  мы только что пытались идти по ребрам не меньше, чем C делить на 2 в степени K
[13:31.000 --> 13:34.000]  и вот в какой-то момент обнаружили, что из S до T дойти нельзя
[13:35.000 --> 13:37.000]  вот S где-то здесь, T вот там где-то там
[13:38.000 --> 13:40.000]  вот, и мы изучаем пропускную способность разреза
[13:41.000 --> 13:45.000]  ну она, как бы, что такое, напомните, пропускная способность разреза
[13:46.000 --> 13:47.000]  да
[13:48.000 --> 13:49.000]  да
[13:50.000 --> 13:54.000]  но ребра, которые у нас пересекают этот разрез, не более чем E
[13:55.000 --> 14:00.000]  и пропускная способность каждого из них меньше, чем C делить на 2 в степени K
[14:01.000 --> 14:05.000]  следовательно, у нас тут ERC делить на 2 в степени K
[14:08.000 --> 14:14.000]  это размер, это верхняя оценка на максимальный поток в этой остаточной сети
[14:15.000 --> 14:16.000]  ну теперь интересный факт
[14:17.000 --> 14:24.000]  теперь мы думаем, а вот когда, вот у нас на следующей итерации, мы будем искать потоки, то есть каждый DFS найдет путь
[14:28.000 --> 14:31.000]  то есть по которому можно протолкнуть хотя бы C делить на 2 в степени K, а минус этим
[14:32.000 --> 14:33.000]  внимание, вопрос
[14:34.000 --> 14:36.000]  сколько раз это может произойти?
[14:36.000 --> 14:37.000]  2E, максимально
[14:38.000 --> 14:39.000]  да, совершенно верно
[14:40.000 --> 14:45.000]  то есть если у нас поток всего не более, чем вот 100, а на каждом шаге пропихиваем как минимум 100, то получается 2E
[14:46.000 --> 14:48.000]  то есть мы доказали следующую терему
[14:49.000 --> 14:55.000]  что на каждой итерации успешных DFS будет не более, чем 2E
[14:56.000 --> 14:57.000]  ну, в смысле, от E
[14:58.000 --> 15:00.000]  ну, смотри, она получается с точкой E квадратно ловится
[15:01.000 --> 15:02.000]  да, совершенно верно
[15:07.000 --> 15:08.000]  совершенно верно
[15:09.000 --> 15:10.000]  действительно возникает
[15:11.000 --> 15:15.000]  E квадрат лог C
[15:20.000 --> 15:22.000]  а можно еще раз объяснить, откуда это?
[15:23.000 --> 15:28.000]  у нас каждый DFS заод Е, на каждой итерации от Е DFS, а итерации лог C
[15:29.000 --> 15:30.000]  перемножим
[15:31.000 --> 15:32.000]  вот так и выглядит от
[15:33.000 --> 15:34.000]  почему на каждой итерации от Е?
[15:34.000 --> 15:35.000]  значит, смотрите еще раз
[15:36.000 --> 15:39.000]  потому что после того, как мы сделали итерацию номер K
[15:40.000 --> 15:42.000]  осталось нам пропихнуть вообще потока
[15:43.000 --> 15:44.000]  не более, чем вот 100
[15:45.000 --> 15:48.000]  причем, но когда мы будем делать эту K плюс первую итерацию
[15:55.000 --> 15:57.000]  когда мы будем делать следующую операцию
[15:58.000 --> 16:02.000]  то есть получается каждый успешный DFS будет пропихивать поток от хотя бы 100
[16:04.000 --> 16:06.000]  но так как нам осталось не более, чем вот 100
[16:07.000 --> 16:10.000]  то получается, что больше, чем 2E раз мы, собственно, ничего не сделаем
[16:11.000 --> 16:13.000]  следовательно, каждая итерация DFS в 2E
[16:14.000 --> 16:15.000]  или меньше
[16:16.000 --> 16:17.000]  это же строгая
[16:18.000 --> 16:21.000]  наверное, даже точно меньше, потому что тут только такая строгая
[16:26.000 --> 16:28.000]  так что вот такая вот разминка
[16:29.000 --> 16:30.000]  а
[16:31.000 --> 16:32.000]  то есть чем это отличается?
[16:33.000 --> 16:34.000]  то есть мы идем по большим ребрам DFS?
[16:35.000 --> 16:36.000]  да
[16:37.000 --> 16:38.000]  а потом по ребрам в 2 раза меньше
[16:39.000 --> 16:40.000]  а потом по ребрам в 4 раза меньше
[16:41.000 --> 16:42.000]  ну не меньше
[16:43.000 --> 16:44.000]  если мы вот тут встретим большие ребра, то мы по ним тоже идем
[16:45.000 --> 16:46.000]  ну да, в смысле
[16:47.000 --> 16:48.000]  по маленьким находим
[16:49.000 --> 16:50.000]  оригинальный сколько работал? 1,25?
[16:51.000 --> 16:52.000]  да
[16:53.000 --> 16:54.000]  Edmunds Card?
[16:55.000 --> 16:56.000]  да
[16:56.000 --> 16:57.000]  ну просто DFS
[16:58.000 --> 17:00.000]  нам не важно, что DFS или PFS
[17:01.000 --> 17:04.000]  если E примерно В, то это работает быстрее всех предыдущих, которые мы начали
[17:05.000 --> 17:06.000]  да
[17:07.000 --> 17:12.000]  ну можно еще просто поверить, что крайне редко, наверное, C будет больше, чем 2 в степени У
[17:13.000 --> 17:15.000]  так что есть подозрение, что это чем получше
[17:16.000 --> 17:18.000]  можно еще раз быстренько проведаться по оси
[17:19.000 --> 17:22.000]  значит, количество итераций лог-C
[17:23.000 --> 17:25.000]  каждый DFS работает за E
[17:26.000 --> 17:29.000]  и на каждой итерации DFS-ов 2E
[17:30.000 --> 17:31.000]  максимум
[17:32.000 --> 17:33.000]  почему?
[17:34.000 --> 17:36.000]  потому что мы хотим сейчас сделать K плюс первую итерацию
[17:37.000 --> 17:39.000]  значит, мы перед этим сделали K
[17:40.000 --> 17:47.000]  и привело это нас к тому, что на любом пути от S до T найдется ребро плюсовой способности меньше, чем цифли на 2 степени K
[17:48.000 --> 17:49.000]  да
[17:50.000 --> 17:51.000]  вот
[17:51.000 --> 17:59.000]  я утверждаю, что в этом случае максимальный поток, который мы можем сейчас еще нам осталось пустить в остаточной сети
[18:00.000 --> 18:02.000]  он меньше, чем EC поделить на 2 степени K
[18:03.000 --> 18:08.000]  но если мы сейчас в это поверим, то тогда из этого будет следует, что на следующей итерации больше чем 2E DFS-ов не будет
[18:08.000 --> 18:09.000]  не будет
[18:15.000 --> 18:16.000]  сейчас
[18:17.000 --> 18:18.000]  привариваем
[18:19.000 --> 18:21.000]  а мы сначала по большим ребрам идем?
[18:22.000 --> 18:23.000]  сначала по большим
[18:24.000 --> 18:25.000]  это важно
[18:33.000 --> 18:34.000]  раньше наш DFS что искал?
[18:35.000 --> 18:37.000]  он искал любой путь из S в T
[18:38.000 --> 18:39.000]  не нулевой
[18:40.000 --> 18:45.000]  сейчас наш первый DFS будет искать только пути, у которых минимум на пути хотя бы C
[18:47.000 --> 18:50.000]  нашли все такие пути, все их заполнили сразу по C потока
[18:51.000 --> 18:52.000]  но не аккуратно все пути
[18:54.000 --> 18:55.000]  согласен, не аккуратно
[18:58.000 --> 18:59.000]  какого? размер большого?
[19:00.000 --> 19:01.000]  мы переходим к следующему
[19:02.000 --> 19:05.000]  увеличаем нижнюю границу в 2 раза и делаем 2
[19:06.000 --> 19:08.000]  мы продолжаем DFS или просто с самого начала?
[19:09.000 --> 19:10.000]  не, не продолжаем заново
[19:12.000 --> 19:15.000]  лод абсолютно отдельно друг от друга итерации фонической
[19:18.000 --> 19:20.000]  получается вот поэтому DFS лод
[19:21.000 --> 19:27.000]  если мы поверим, что там остался поток и стока, то с такой нижней границы DFS-ов будет не более чем 2E
[19:28.000 --> 19:29.000]  а, ну да
[19:32.000 --> 19:33.000]  ну и все
[19:34.000 --> 19:35.000]  откуда взялась эта граница на поток?
[19:36.000 --> 19:40.000]  ну потому что, как всегда, предположим, что мы от S до T по вот таким ребрам дойти не можем
[19:41.000 --> 19:45.000]  ну как всегда, рассмотрим разрез, в котором в доле S будет написано, а докуда он может
[19:46.000 --> 19:48.000]  и рассмотрим пропсуя способность этого разреза
[19:50.000 --> 19:56.000]  ну через этот разрез проходит не более чем G ребр, в каждом из которых пропсуя способность меньше, чем C поддеть на 2 степени
[19:57.000 --> 20:01.000]  так что нашелся разрез, ну такой значит максимальный поток не больше
[20:02.000 --> 20:05.000]  у нас, кстати, был максимальный поток, минимальный разрез, вот такое
[20:06.000 --> 20:08.000]  мы это называем теремой форда полкерсона
[20:09.000 --> 20:10.000]  да
[20:11.000 --> 20:14.000]  терема форда полкерсона, это терема степотворительности 3 по 34
[20:15.000 --> 20:16.000]  я вроде не могу
[20:17.000 --> 20:19.000]  ладно, не разрез, это следует
[20:20.000 --> 20:22.000]  тем более, чтобы доказать, что оно участвует так или иначе
[20:22.000 --> 20:24.000]  так что это для нас важно
[20:25.000 --> 20:26.000]  вот
[20:27.000 --> 20:29.000]  но это если даже просто DF запускать
[20:30.000 --> 20:32.000]  а что делать, если
[20:33.000 --> 20:36.000]  если, ну вот, а что делать, если запускать
[20:37.000 --> 20:39.000]  вот, например, алгоритм Динница
[20:41.000 --> 20:43.000]  а можно в E-Log ценовить, смотри
[20:44.000 --> 20:46.000]  это для нас не дарит
[20:47.000 --> 20:49.000]  а, да, это для нас не дарит
[20:49.000 --> 20:51.000]  это для нас не дарит
[20:52.000 --> 20:54.000]  а, это у нас все равно в E-Log, да?
[20:55.000 --> 20:57.000]  да, у нас лучше, ну в каком-то смысле
[20:58.000 --> 21:00.000]  хотя, если все равно идти, а в E-Log ценовить откуда?
[21:01.000 --> 21:03.000]  я вроде помню
[21:04.000 --> 21:07.000]  ну да, вот у меня тоже безобразие, честно говоря
[21:08.000 --> 21:12.000]  что-то Динец влаштадируем сам по себе откуда-то в E-Log ценовить
[21:13.000 --> 21:14.000]  вот
[21:15.000 --> 21:17.000]  но, попробуем вот что
[21:17.000 --> 21:19.000]  на самом деле вот
[21:20.000 --> 21:22.000]  начнем, потому что, конечно, у целочисленных сетей
[21:23.000 --> 21:25.000]  есть такое принятное, такое подмножество сетей как
[21:26.000 --> 21:28.000]  единичные сети
[21:33.000 --> 21:35.000]  наши любимые единичные сети
[21:36.000 --> 21:38.000]  кстати, мы вот здесь уже рассматриваем
[21:39.000 --> 21:41.000]  то, что у нас, ну, трудностные особенности в назначаемом графике
[21:42.000 --> 21:44.000]  пока мы еще не меняем
[21:45.000 --> 21:47.000]  ну, да
[21:48.000 --> 21:53.000]  конечно, забавно, что в некоторых случаях прописные способности могут становиться и 20 при желании
[21:54.000 --> 21:56.000]  ну, если они не ориентированы
[21:57.000 --> 21:58.000]  честно
[21:59.000 --> 22:01.000]  но это равно лакомит
[22:02.000 --> 22:03.000]  вот
[22:04.000 --> 22:05.000]  а, ну, кстати, да
[22:06.000 --> 22:08.000]  Ладно, вот еще Тихон спрашивал на прошлый паре, вот можем попробовать
[22:09.000 --> 22:11.000]  это вот мы говорим, если у нас сети целые, да?
[22:12.000 --> 22:14.000]  а что делать, если у нас прописные способности не целые?
[22:17.000 --> 22:19.000]  нет, насовировать до последнего бита
[22:20.000 --> 22:22.000]  нет, ну, может быть
[22:23.000 --> 22:25.000]  ну, она же всегда просто вытескает по ГС
[22:26.000 --> 22:28.000]  ну, где-то может быть погрешить, но с другой стороны, даже если предположить, что у нас все идеально точно
[22:29.000 --> 22:31.000]  потому что мы, например, работаем в рациональных числах
[22:32.000 --> 22:34.000]  по-моему, синтетика будет начинать от этого зависеть
[22:35.000 --> 22:36.000]  ну
[22:37.000 --> 22:39.000]  а если мы же поверим, что там
[22:39.000 --> 22:40.000]  еще и заузеницы работают, да?
[22:41.000 --> 22:42.000]  поверили
[22:43.000 --> 22:44.000]  так я вам и поверил
[22:45.000 --> 22:46.000]  нет, ну, если мы, да
[22:47.000 --> 22:49.000]  нет, это, конечно, можно об этом думать, но если мы это, как всегда, поверим
[22:50.000 --> 22:52.000]  часто в это верим, то можно действительно заметить следующее
[22:53.000 --> 22:55.000]  что после того, как вы сделали
[22:56.000 --> 22:57.000]  то есть вы сделали
[22:58.000 --> 23:00.000]  значит, после того, как вы сделали
[23:01.000 --> 23:03.000]  итерацию цепы длиной 20 степеника
[23:04.000 --> 23:06.000]  то, что вы нашли, то есть вот размер потока
[23:06.000 --> 23:08.000]  он больше либо равен, чем
[23:09.000 --> 23:11.000]  размер, чем
[23:12.000 --> 23:14.000]  размер оптимального потока
[23:15.000 --> 23:16.000]  минус
[23:17.000 --> 23:19.000]  ес поделить на 2 степени к, как вы только что увидели
[23:20.000 --> 23:22.000]  поэтому, в принципе, вам все, что вам нужно
[23:23.000 --> 23:25.000]  это, на самом деле, добиться того, чтобы
[23:26.000 --> 23:28.000]  вот эта вот штука была достаточно малой долей
[23:29.000 --> 23:30.000]  вот этого
[23:31.000 --> 23:33.000]  и в результате у вас там получится какая-то
[23:34.000 --> 23:35.000]  даже какая-то ассердочка
[23:37.000 --> 23:39.000]  ну, там, правда, она будет зависеть от оптимального потока
[23:40.000 --> 23:41.000]  ну, соответственно
[23:42.000 --> 23:43.000]  ну вот
[23:44.000 --> 23:46.000]  так что, соответственно, можно ее даже посчитать
[23:47.000 --> 23:48.000]  что-то мне хочется
[23:49.000 --> 23:50.000]  вот
[23:51.000 --> 23:52.000]  давайте поговорим об единичных
[23:53.000 --> 23:55.000]  теперь давайте представим, что у нас все
[23:56.000 --> 23:57.000]  способности единичны
[23:58.000 --> 23:59.000]  чем это приятно?
[24:00.000 --> 24:01.000]  особенно если граф ориентирован
[24:03.000 --> 24:05.000]  если граф ориентирован, то это приятно тем, что у нас
[24:06.000 --> 24:10.000]  то у нас тогда достаточно степень тоже всегда будет единичный
[24:11.000 --> 24:13.000]  ну, потому что, когда мы пропускаем поток по единичному ребру
[24:14.000 --> 24:17.000]  оно убивается, появляется обратное ребро в способности 1
[24:18.000 --> 24:19.000]  но это так ориентированно
[24:20.000 --> 24:23.000]  если ориентированно, рассматривать как ориентированно
[24:24.000 --> 24:25.000]  это не страшно
[24:26.000 --> 24:27.000]  ну, да
[24:28.000 --> 24:32.000]  так как мы не живем в матрице с межностью, то нам не принципиально
[24:32.000 --> 24:34.000]  а теперь давайте представим себе
[24:35.000 --> 24:36.000]  что мы в этой
[24:37.000 --> 24:38.000]  ну, понятно, что
[24:39.000 --> 24:40.000]  ну, вот
[24:41.000 --> 24:43.000]  ну, то есть понятно, что кажется не теперь
[24:44.000 --> 24:45.000]  вот в такой ситуации
[24:46.000 --> 24:47.000]  время рабочее
[24:48.000 --> 24:49.000]  время поиска поток
[24:50.000 --> 24:51.000]  ну, и вот
[24:52.000 --> 24:53.000]  вот
[24:54.000 --> 24:55.000]  вот
[24:56.000 --> 24:57.000]  вот
[24:58.000 --> 24:59.000]  вот
[25:00.000 --> 25:01.000]  вот
[25:02.000 --> 25:04.000]  ну, а если мы ставим, конечно, методом форда Фолкерсона
[25:05.000 --> 25:07.000]  то теперь его можно оценить как модуль f на
[25:08.000 --> 25:09.000]  степени стока
[25:10.000 --> 25:12.000]  ну, или степени стока
[25:15.000 --> 25:16.000]  почему?
[25:17.000 --> 25:18.000]  да
[25:19.000 --> 25:20.000]  вот так
[25:21.000 --> 25:22.000]  да, да
[25:23.000 --> 25:25.000]  а почему у нас е появляется?
[25:26.000 --> 25:27.000]  dfs
[25:28.000 --> 25:29.000]  пока?
[25:30.000 --> 25:31.000]  да
[25:32.000 --> 25:33.000]  а теперь давайте представим
[25:37.000 --> 25:41.000]  что мы запускаем алгоритм Деница
[25:44.000 --> 25:45.000]  корень вывели?
[25:46.000 --> 25:47.000]  ну, не сказка
[25:48.000 --> 25:51.000]  сначала давайте вспомним, откуда он вообще взял
[25:52.000 --> 25:53.000]  вообще какая там ассимптотика
[25:54.000 --> 25:55.000]  там была ассимптотика
[25:56.000 --> 25:57.000]  смотрите
[25:58.000 --> 26:00.000]  v на ve
[26:02.000 --> 26:05.000]  dv это количество фаз, то есть это вот
[26:08.000 --> 26:12.000]  а ve это, так сказать, обработка одной фазы
[26:13.000 --> 26:14.000]  поиск потери еще
[26:17.000 --> 26:18.000]  но это в общем случае
[26:19.000 --> 26:24.000]  а теперь давайте посмотрим, что поменяется в анализе Деница, если
[26:25.000 --> 26:27.000]  соответственно все ребра единицы
[26:27.000 --> 26:28.000]  соответственно все ребра единицы
[26:30.000 --> 26:34.000]  вот давайте, что поменяется в анализе поиска плотирующего поток?
[26:35.000 --> 26:36.000]  он вычтет, где не работает
[26:37.000 --> 26:38.000]  а почему?
[26:39.000 --> 26:40.000]  когда путь находит, он целиком удаляется
[26:41.000 --> 26:43.000]  да, совершенно верно, то есть обратите внимание, что
[26:44.000 --> 26:50.000]  когда у нас есть единичный краф, то когда мы найдем какой-то путь, удалится не одно какое-то ребро, а просто сразу все
[26:51.000 --> 26:55.000]  поэтому получается, что пропуск этого пути можно упихать в е удаленное
[26:56.000 --> 27:01.000]  и тогда получается, что одна фаза в единичной сети будет работать за у от е
[27:07.000 --> 27:11.000]  ну а если бы там были пропускные способности какие-то с, то за ец
[27:15.000 --> 27:18.000]  вот теперь начинается самое интересное
[27:21.000 --> 27:24.000]  а можно ли как-то улучшить оценку на количество фаз?
[27:25.000 --> 27:26.000]  да, разрешаю
[27:27.000 --> 27:28.000]  ответил особый вопрос
[27:29.000 --> 27:32.000]  ну вдруг там очень-очень-очень много кратных единичных ребят
[27:34.000 --> 27:35.000]  вот
[27:38.000 --> 27:39.000]  но
[27:40.000 --> 27:42.000]  значит есть вместитель Оно
[27:43.000 --> 27:46.000]  но я утверждаю следующее, что в единичной сети
[27:47.000 --> 27:52.000]  количество фаз будет тут не больше чем в, а здесь будет не больше чем
[27:53.000 --> 27:54.000]  или нет?
[27:55.000 --> 27:56.000]  два
[27:57.000 --> 27:58.000]  уничтожение просто
[27:59.000 --> 28:00.000]  а после из в?
[28:01.000 --> 28:02.000]  или е?
[28:03.000 --> 28:04.000]  в общем случае пока из е
[28:05.000 --> 28:09.000]  из в будет когда выяснится, что там нельзя через вершину протопнуть больше, чем один
[28:11.000 --> 28:12.000]  это важно
[28:13.000 --> 28:15.000]  а в общем случае кое-не из е
[28:16.000 --> 28:18.000]  значит как-то все работает
[28:21.000 --> 28:24.000]  ну тут я конечно немножко спалил, но работает это давайте подумаем
[28:25.000 --> 28:28.000]  давайте сейчас сразу попробуем в общем случае применить анализ, который мы говорили
[28:29.000 --> 28:30.000]  итак
[28:31.000 --> 28:32.000]  введем
[28:33.000 --> 28:34.000]  мистический бубен
[28:35.000 --> 28:36.000]  который мы берем позже
[28:37.000 --> 28:38.000]  а пригодится нам все это
[28:39.000 --> 28:41.000]  давайте лучше сразу вводить бубен
[28:42.000 --> 28:43.000]  и говорим
[28:43.000 --> 28:48.000]  давайте сделаем бубен от итерации блокирующего потока
[28:49.000 --> 28:54.000]  в чем нам сейчас даже плевать Диницет, Алсотра, может быть Хишвари или там любой другой атерит
[28:56.000 --> 28:58.000]  вот сделаем бубен итерации
[28:59.000 --> 29:01.000]  внимание, вопрос
[29:02.000 --> 29:07.000]  каков у нас останется максимальный поток в остаточной сети после бубен итерации?
[29:13.000 --> 29:17.000]  ну каждый путь после этого хотя бы к, бла-бла-бла
[29:18.000 --> 29:25.000]  то есть давайте посмотрим, что у нас представляет собой остаточная сеть после бубен итерации
[29:28.000 --> 29:32.000]  ну вот это, произвольная единичная сеть, только с мелким ограничением
[29:33.000 --> 29:35.000]  расстояние от СДТ больше, чем бубен
[29:36.000 --> 29:40.000]  давайте представим себе этот максимальный поток по остаточной сети
[29:41.000 --> 29:43.000]  и декомпозируем его на пути
[29:44.000 --> 29:47.000]  ну естественно мы имеем в виду, что он будет состоять только из единичной
[29:48.000 --> 29:50.000]  и давайте себе представим
[29:51.000 --> 29:55.000]  тогда когда мы его декомпозируем, мы заметим, что путь может проходить
[29:56.000 --> 30:00.000]  только по каждому ребру проходит не более чем один путь
[30:01.000 --> 30:02.000]  потому что у нас единичная сеть
[30:02.000 --> 30:06.000]  ну правда заметим, что тут всякое может быть
[30:07.000 --> 30:11.000]  нормальные герои могут как угодно идти в обход
[30:25.000 --> 30:29.000]  но размер потока это количество этих путей
[30:29.000 --> 30:33.000]  значит каждый из этих путей
[30:34.000 --> 30:39.000]  на каждом из этих путей больше, чем бубен ребер
[30:40.000 --> 30:42.000]  а всего ребер е
[30:43.000 --> 30:45.000]  то не более, чем е
[30:46.000 --> 30:54.000]  тогда это означает, что размер этого оставшегося потока не превосходит
[30:54.000 --> 30:56.000]  ну сколько получается?
[30:57.000 --> 30:59.000]  е поделить на бубен
[31:06.000 --> 31:08.000]  понимаете, да?
[31:09.000 --> 31:11.000]  да, нет, наверное
[31:14.000 --> 31:17.000]  но тогда из этого следует, что так как оставшийся поток будет таким
[31:18.000 --> 31:21.000]  то мы вынуждены заключить, что количество фаз ось комплокирующего потока
[31:21.000 --> 31:23.000]  будет тоже не более, чем столько
[31:24.000 --> 31:26.000]  потому что каждая фаза, кроме последней, неудачной
[31:27.000 --> 31:29.000]  она нам хотя бы одну единицу из этого найдет
[31:30.000 --> 31:36.000]  то есть таким образом мы можем оценить, что время количества фаз у нас не превосходит
[31:37.000 --> 31:41.000]  бубен плюс е поделить на бубен
[31:46.000 --> 31:49.000]  уже сразу было понятно, какой конкретно бубен мы возьмем
[31:49.000 --> 31:51.000]  откуда, собственно, два корня е?
[31:54.000 --> 31:58.000]  а почему f будет меньше, чем е делить на бубен?
[31:59.000 --> 32:02.000]  ну потому что мы рассмотрели остаточную сеть
[32:03.000 --> 32:05.000]  рассмотрели максимальный поток в ней
[32:08.000 --> 32:10.000]  ну какой-то он там какой-то будет
[32:11.000 --> 32:13.000]  и декомпозировали его на единичные пути
[32:14.000 --> 32:16.000]  по каждому реберу проходит не более, чем один путь
[32:16.000 --> 32:18.000]  но на каждом пути больше, чем бубен
[32:21.000 --> 32:23.000]  потому что мы это делаем после бубен итерации
[32:24.000 --> 32:26.000]  это значит, что расстояние от СДТ больше, чем бубен
[32:27.000 --> 32:29.000]  почему мы точно будем декомпозировать?
[32:30.000 --> 32:34.000]  у нас же может быть один путь, который в одну сторону проходит, а в другую обратно
[32:35.000 --> 32:38.000]  почему у нас декомпозиция не может получить короткого пути?
[32:40.000 --> 32:42.000]  потому что у нас не может получить короткого пути
[32:43.000 --> 32:45.000]  это что, интригенды?
[32:46.000 --> 32:48.000]  а полегаем вот это туда-сюда?
[32:49.000 --> 32:51.000]  ну во-первых, эту циркуляцию можно отменить
[32:52.000 --> 32:54.000]  да, есть теория, что любой поток можно декомпозировать до пути
[32:55.000 --> 32:56.000]  и циклы
[32:57.000 --> 32:59.000]  нет, любой поток декомпозировать до пути просто неверно
[33:00.000 --> 33:02.000]  любой поток из СДТ или как это называется?
[33:03.000 --> 33:04.000]  просто любой поток
[33:05.000 --> 33:07.000]  да, любой корректный поток
[33:08.000 --> 33:10.000]  просто входящий, выходящий
[33:10.000 --> 33:12.000]  можно декомпозировать по всей аксиоматике
[33:13.000 --> 33:15.000]  можно декомпозировать именно на пути циклы
[33:16.000 --> 33:18.000]  любой цикл можно отменить
[33:19.000 --> 33:21.000]  в любом случае, если случайно граф неориентированный
[33:22.000 --> 33:24.000]  и у вас случайно что-то не то получилось
[33:25.000 --> 33:27.000]  хотя непонятно как
[33:28.000 --> 33:30.000]  ориентированным это проблема не будет сразу
[33:31.000 --> 33:33.000]  если в эту сторону ребро изначально
[33:34.000 --> 33:36.000]  и в эту сторону, то это будут два незамеченных ребра
[33:37.000 --> 33:39.000]  и пусть поток течет и туда, и туда
[33:40.000 --> 33:42.000]  и пусть потоки все равно можно отменить
[33:43.000 --> 33:44.000]  не суть важна
[33:45.000 --> 33:47.000]  мне все еще не очевидно, почему у нас
[33:48.000 --> 33:50.000]  какой-то путь нечаянно не может оказаться короче, чем будет
[33:51.000 --> 33:56.000]  у нас была тарема о том, что в новой сети с...
[33:57.000 --> 33:58.000]  как это называется?
[33:59.000 --> 34:00.000]  в каждой новой слоистой сети
[34:01.000 --> 34:03.000]  да, в каждой новой слоистой сети нет короткого пути
[34:04.000 --> 34:05.000]  у нас была тарема остаточная сеть
[34:06.000 --> 34:07.000]  остаточная
[34:07.000 --> 34:11.000]  да, мы этот поток еще именно в остаточной сети
[34:12.000 --> 34:16.000]  но расстояние от СДТ у нас после каждой фазы строго увеличивается
[34:17.000 --> 34:19.000]  но мы же больше
[34:20.000 --> 34:21.000]  больше что?
[34:22.000 --> 34:25.000]  нет, нет, я алгоритм спрашиваю
[34:26.000 --> 34:29.000]  я бы хотел понять, почему мы смогли так оценить остаточный поток
[34:30.000 --> 34:35.000]  потому что у нас потоки декомпатируются на пути циклы
[34:35.000 --> 34:38.000]  пути не пересекаются по рюмкам
[34:39.000 --> 34:40.000]  это важно
[34:41.000 --> 34:46.000]  и на каждом из этих путей и каждый путь захватывает бубенгами
[34:47.000 --> 34:48.000]  если они не пересекаются по рюмкам
[34:49.000 --> 34:50.000]  не пересекаются, а у нас единичная сеть
[34:51.000 --> 34:52.000]  нет смысле
[34:53.000 --> 34:59.000]  наверное ускоряешься, просто у нас вот ребра, которые через уровень они не могут никогда перестать доступным
[35:00.000 --> 35:01.000]  если они часто не доступны
[35:02.000 --> 35:09.000]  верно ли, что слоистой сети есть максимальный поток
[35:10.000 --> 35:11.000]  совпадающий с максимальным потоком всего этого
[35:12.000 --> 35:13.000]  не обязательно
[35:14.000 --> 35:16.000]  но я не оцениваю максимальный поток слоистой сети
[35:17.000 --> 35:19.000]  я оцениваю просто
[35:20.000 --> 35:21.000]  я сделал бубен и это раз единица он пустил какой-то поток
[35:22.000 --> 35:23.000]  или единица неважно
[35:24.000 --> 35:25.000]  у меня какая-то остаточная сеть
[35:26.000 --> 35:29.000]  я в этой сети рассматриваю реально максимально поток
[35:29.000 --> 35:31.900]  Просто абстрактно рассматриваем. Не ищем, просто рассматриваем.
[35:31.900 --> 35:35.000]  Просто рассматриваем, да. Рассмотрим какой-нибудь максимальный поток.
[35:35.000 --> 35:38.000]  Утверждение. Ну вот.
[35:38.000 --> 35:41.000]  Утверждение. Его можно декомпозировать на пути.
[35:41.000 --> 35:45.000]  И все эти пути будут вины больше, чем boobin.
[35:45.000 --> 35:50.000]  А, они будут больше, чем boobin? Потому что если бы был хотя бы один меньше, чем boobin, то он бы был в...
[35:50.000 --> 35:52.000]  То есть сейчас состояние застепа было бы...
[35:52.000 --> 35:53.000]  Что было бы что?
[35:53.000 --> 35:56.000]  Минимальный... Минимальный путь застеп был бы в своей стейсите тоже.
[35:56.000 --> 35:57.000]  В нашей текущей.
[35:57.000 --> 35:59.000]  Да. А в нашей стейсите...
[35:59.000 --> 36:00.000]  Почему?
[36:00.000 --> 36:02.000]  Он минимальной длины.
[36:02.000 --> 36:03.000]  И?
[36:03.000 --> 36:06.000]  Значит, он такой будет в BFS.
[36:06.000 --> 36:10.000]  Сейчас. Может какой-то из ребров его сейчас, но сейчас насыщенно. В смысле...
[36:10.000 --> 36:11.000]  Нет. Мы сейчас...
[36:11.000 --> 36:12.000]  Ну, ничего.
[36:12.000 --> 36:13.000]  Не понял.
[36:13.000 --> 36:15.000]  Почему насыщенные ребры?
[36:15.000 --> 36:18.000]  Мы в ресторане всегда ищем поненасыщенные ребры.
[36:21.000 --> 36:25.000]  И слоистые сети всегда строили только на ненасыщенных ребрах.
[36:27.000 --> 36:35.000]  Утверждение про то, что в итоговой декомпозиции не будет путей boobin, не очевидно.
[36:35.000 --> 36:36.000]  Нет.
[36:36.000 --> 36:37.000]  В смысле...
[36:37.000 --> 36:42.000]  Тогда у меня возникает вопрос, почему в алгоритме динеца мы вообще поверили, что на каждой...
[36:42.000 --> 36:45.000]  Что в следующей слоистой сети не будет пути, короче.
[36:45.000 --> 36:46.000]  А какая разница?
[36:46.000 --> 36:48.000]  Слоистая сеть строится на основе BFS.
[36:48.000 --> 36:51.000]  Расстояние СДТ там такое же, как было на момент построения этой сети.
[36:52.000 --> 36:57.000]  Когда мы говорим, что ищем поток высоса сети, мы говорим, что мы вообще забываем про ребра, которые сейчас насыщены?
[36:57.000 --> 36:59.000]  Или, конечно, там как бы...
[36:59.000 --> 37:00.000]  Нет.
[37:00.000 --> 37:03.000]  Ну, когда мы строим BFS, мы забываем о них.
[37:03.000 --> 37:11.000]  Ну, просто почему высоса сети может быть, ну, такая, как бы, на пути, что у нас затрагивается ребро, которое сейчас насыщено.
[37:11.000 --> 37:13.000]  Потому что там другую, во правду, сторону тоже проходит.
[37:13.000 --> 37:17.000]  Но оно тогда может быть вот тем, который сокращает путь.
[37:17.000 --> 37:19.000]  Проблема какая-то такая.
[37:19.000 --> 37:20.000]  Нет, пожалуйста.
[37:20.000 --> 37:23.000]  Нет, тогда эта проблема просто у вас отсылка к вопросу по предыдущей лекции.
[37:25.000 --> 37:27.000]  Потому что сейчас как бы ответ на этот вопрос такой.
[37:27.000 --> 37:37.000]  У нас была теорема о том, что перед, на каждой очередной итерации поиска блокирующего потока, расстояние от СДТ строго увеличивается.
[37:37.000 --> 37:38.000]  Это понятно.
[37:38.000 --> 37:40.000]  Все, если вам это понятно, то здесь тогда вопросов быть не должно.
[37:40.000 --> 37:41.000]  Они есть.
[37:41.000 --> 37:42.000]  Они есть.
[37:42.000 --> 37:43.000]  А что, потому что они...
[37:43.000 --> 37:48.000]  У нас путь из декомпозиции, он не будет пучом какого-то конкретного, какой-то конкретный, это раз.
[37:48.000 --> 37:51.000]  Ребра из разных итераций.
[37:51.000 --> 37:52.000]  И что?
[37:52.000 --> 37:53.000]  Мы доказали.
[37:53.000 --> 37:57.000]  Значит, перед первой итерацией расстояние от СДТ было как минимум 1.
[37:57.000 --> 37:58.000]  Да.
[37:58.000 --> 37:59.000]  Перед второй как минимум 2.
[37:59.000 --> 38:00.000]  Да.
[38:00.000 --> 38:01.000]  Перед третьей как минимум 3.
[38:01.000 --> 38:04.000]  Расстояние от СДТ вы всегда называете расстояние в остаточной сети.
[38:04.000 --> 38:05.000]  Ну да.
[38:05.000 --> 38:08.000]  Именно в остаточной сети и именно по ненасыщенной бревне.
[38:08.000 --> 38:09.000]  Хорошо, да.
[38:09.000 --> 38:10.000]  Вот, и тогда.
[38:10.000 --> 38:15.000]  После, после бубен итерации расстояние от СДТ будет как минимум b плюс 1.
[38:15.000 --> 38:16.000]  Да.
[38:16.000 --> 38:22.000]  Следовательно, когда я в этой остаточной сети, в которой расстояние от СДТ больше чем b плюс 1,
[38:22.000 --> 38:27.000]  а каждая, ну вот, рассмотрю декомпозицию на пути, то каждая из этих путей будет длинной...
[38:27.000 --> 38:31.000]  Сейчас, мы остаточную сеть рассматриваем просто как независимый граф.
[38:31.000 --> 38:32.000]  Ну да.
[38:32.000 --> 38:33.000]  Остаточная сеть...
[38:33.000 --> 38:35.000]  Декомпозиция на пути не...
[38:35.000 --> 38:41.000]  Сейчас, если возьмем какой-то граф, забудем про существование общей остаточной сети, возьмем какой-то граф,
[38:41.000 --> 38:47.000]  то в нем существует множество путей.
[38:47.000 --> 38:54.000]  Именно в нем, не в его сети с учетом обратных ревер, просто в каком-то ориентированном графе
[38:54.000 --> 38:59.000]  существует разбиение на пути равное максимальном потоку.
[38:59.000 --> 39:02.000]  Ну, в смысле, не разбиение на пути, а просто декомпозиция на пути.
[39:02.000 --> 39:07.000]  Ну хорошо.
[39:07.000 --> 39:11.000]  И теперь мы разворачиваем остаточную сеть как независимый граф.
[39:11.000 --> 39:13.000]  Ну, вроде да. Вроде нормально.
[39:13.000 --> 39:16.000]  Ну, это важно. Давайте еще раз поговорим, что да.
[39:16.000 --> 39:20.000]  Мы сейчас рассматриваем именно остаточную сеть после бубен итерации.
[39:20.000 --> 39:25.000]  И максимальный поток, вот этот поток, это вот максимальный поток именно в этой остаточной сети.
[39:25.000 --> 39:29.000]  Ну, потому что как бы максимальный поток в исходной сети, да,
[39:29.000 --> 39:32.000]  это будет тот поток, который мы уже за бубен итерации пропихнули,
[39:32.000 --> 39:36.000]  плюс максимальный поток, который там в остаточной сети остался.
[39:36.000 --> 39:38.000]  Да. Ну, это вот.
[39:38.000 --> 39:42.000]  Такая да. Выглядит как умная мысль, на самом деле нет.
[39:42.000 --> 39:43.000]  Вот. Вот и все.
[39:43.000 --> 39:47.000]  Ну вот. И поэтому мы рассматриваем, какой у нас максимальный поток именно в остаточной сети,
[39:47.000 --> 39:53.000]  и у нас получается вот такая оценка за счет того, что расстояние от s2t в ней больше, чем в пути.
[39:53.000 --> 39:55.000]  То есть каждый пути композиции больше, чем в пути.
[39:55.000 --> 40:00.000]  Нет, хотел бы сейчас надо уложить, потому что сейчас дальше эта идея будет применяться в усиленной версии.
[40:02.000 --> 40:03.000]  Вот.
[40:04.000 --> 40:05.000]  Итак.
[40:05.000 --> 40:09.000]  Ну, значит, соответственно, то есть как мы уже сейчас поняли,
[40:09.000 --> 40:14.000]  значит, тогда у нас сразу получается, что фаз будет не более, чем два корня из E,
[40:14.000 --> 40:20.000]  и каждый ряд ищется за E, то получается, что в единичной сети на самом деле
[40:21.000 --> 40:22.000]  Динец.
[40:22.000 --> 40:25.000]  Вот конкретно алгоритм Динеца сработает за E корня из E.
[40:25.000 --> 40:30.000]  Вот конкретно алгоритм Динеца в том плане, что конкретно алгоритм Динеца вам блокирующий поток завод не дойдет.
[40:33.000 --> 40:34.000]  Понятно?
[40:34.000 --> 40:35.000]  Да.
[40:35.000 --> 40:36.000]  Вот. Класс.
[40:36.000 --> 40:37.000]  Вот.
[40:39.000 --> 40:40.000]  Что?
[40:42.000 --> 40:45.000]  А что такое губин плюс E деликат на губин?
[40:46.000 --> 40:47.000]  Не.
[40:47.000 --> 40:50.000]  Мы сказали, что вот сделаем губин итерацией и рассмотрим сколько осталось.
[40:50.000 --> 40:54.000]  Осталось итерации, как мы выяснились, E поделить на губин.
[40:54.000 --> 40:57.000]  Потому что у нас GB осталось не более, чем E поделить на губин.
[40:57.000 --> 41:04.000]  Следовательно, количество итераций — то есть для любого губин, верно, что количество итераций не более, чем губин плюс E поделить на губин.
[41:04.000 --> 41:09.000]  Остается только выбрать оптимальный губин, который в данном случае будет более низ E,
[41:09.000 --> 41:13.500]  и получить, что вот можно вычить отсетку 2 корня из E.
[41:13.500 --> 41:17.500]  А boobin... А, в смысле, это на...
[41:18.500 --> 41:21.500]  Можем в любой момент выбрать чему район boobin. Это просто теоретические изменения.
[41:21.500 --> 41:25.500]  Почему boobin? Почему ездили на boobin? Это понятно. А boobin?
[41:25.500 --> 41:28.500]  Boobin это количество фаз, которые мы сделали перед этим.
[41:28.500 --> 41:32.500]  Ведь за счет чего у нас расстояние от s до t больше, чем boobin?
[41:32.500 --> 41:36.500]  Это количество запусков DFS, которые мы делали?
[41:36.500 --> 41:40.500]  Нет, количество итераций блокирующего потока.
[41:41.500 --> 41:44.500]  Внутри блокирующего потока DFS могло быть много.
[41:44.500 --> 41:47.500]  Но они суммарно за блоке работают, но и другой вопрос.
[41:47.500 --> 41:49.500]  Почему там просто boobin?
[41:49.500 --> 41:55.500]  Потому что мы сейчас оцениваем не асимпторику, мы оцениваем количество фаз блокирующего потока.
[41:55.500 --> 41:57.500]  Именно фаз.
[41:57.500 --> 42:03.500]  А потом будем оценивать, чтобы асимпторика это количество фаз блокирующего потока
[42:03.500 --> 42:07.500]  на сколько времени мы в каждую фазу делаем.
[42:08.500 --> 42:13.500]  В классическом алгоритме Диница мы делаем фаз не более чем v,
[42:13.500 --> 42:16.500]  потому что расстояние бывает только от 1 до v.
[42:16.500 --> 42:18.500]  И каждую фазу делали за ve.
[42:18.500 --> 42:23.500]  Сейчас же мы ухитрились доказать, что фаз в единичной сети 2 корень из e.
[42:23.500 --> 42:25.500]  Ну если boobin поставить...
[42:25.500 --> 42:27.500]  Правил boobin корень из e.
[42:27.500 --> 42:30.500]  А одна фаза e это...
[42:30.500 --> 42:34.500]  Ну там за счет того, что конкретно в алгоритме Диница выясняется,
[42:34.500 --> 42:37.500]  когда у вас за сколько работает.
[42:37.500 --> 42:43.500]  У вас работает на самом деле за ve, за e на 10 плюс e время удаления ребер,
[42:43.500 --> 42:46.500]  а удаляем мы ребра за o от e суммарно.
[42:46.500 --> 42:51.500]  А здесь теперь заметим следующее, что на самом деле теперь у нас просто эта часть исчезла,
[42:51.500 --> 42:56.500]  потому что когда вы нашли путь от s до t, вы убиваете не одно ребро, а все сразу.
[42:56.500 --> 42:58.500]  То есть по сути вы можете, когда продолкнули поток,
[42:58.500 --> 43:03.500]  вы убили просто сразу все ребра и получается тоже упихнуть в те же самые неудаленные.
[43:17.500 --> 43:22.500]  То есть нам даже не надо модифицировать алгоритм, чтобы у нас только количество этих раций.
[43:22.500 --> 43:24.500]  Да, в том-то и фишка, да.
[43:24.500 --> 43:26.500]  То есть он сам так делает.
[43:28.500 --> 43:30.500]  Так, давайте это поймем.
[43:34.500 --> 43:36.500]  Ну просто смотрите, откуда там бралось ve?
[43:37.500 --> 43:38.500]  В e там бралось...
[43:38.500 --> 43:42.500]  То есть e на 10 у нас всегда не больше, чем v.
[43:43.500 --> 43:44.500]  Нет, это не то.
[43:44.500 --> 43:47.500]  Ну то там o от e, потому что e на 10 плюс e.
[43:47.500 --> 43:48.500]  Да, правильно.
[43:49.500 --> 43:52.500]  Но теперь этот e на 10, теперь этого слагаемого нет.
[43:52.500 --> 43:53.500]  Откуда бралось e на 10?
[43:53.500 --> 43:54.500]  Откуда бралось e на 10?
[43:54.500 --> 43:58.500]  Потому что вы за o от d, значит, пробихивали поток по пути.
[43:59.500 --> 44:05.500]  И мы знали, что хотя бы одно ребро убьется, поэтому суммарно таких пропусканий будет не более чем e.
[44:07.500 --> 44:09.500]  А теперь оценка меняется.
[44:09.500 --> 44:15.500]  Потому что теперь мы говорим, что убьется не одно ребро, а убьется все сразу.
[44:16.500 --> 44:18.500]  Поэтому по сути можно сказать, что этого слагаемого нет,
[44:18.500 --> 44:21.500]  а на самом деле у вас есть только время удаления всех ребр.
[44:23.500 --> 44:24.500]  Все.
[44:24.500 --> 44:25.500]  Все, понятно.
[44:25.500 --> 44:27.500]  То есть даже менять реализацию даже не надо,
[44:27.500 --> 44:30.500]  потому что по сути это будет проходить просто, что вы пришли в вершину,
[44:30.500 --> 44:32.500]  вы говорите, так, у меня активное ребро вот это,
[44:32.500 --> 44:34.500]  ой, оно убилось, ладно, пошли дальше.
[44:35.500 --> 44:37.500]  Но в сути это не поменяем.
[44:38.500 --> 44:40.500]  А, это когда мы оптимизировали DFS?
[44:41.500 --> 44:42.500]  Да даже не оптимизированный любой.
[44:42.500 --> 44:43.500]  Какая разница?
[44:45.500 --> 44:46.500]  А, да.
[44:47.500 --> 44:50.500]  В исходном-то тоже, на самом деле, могли даже так.
[44:50.500 --> 44:52.500]  Но самое главное, когда нашли этот путь,
[44:52.500 --> 44:54.500]  нашли какую-то минимальную пропускную способность,
[44:54.500 --> 44:55.500]  можете пропустить и пропускаете.
[44:55.500 --> 44:58.500]  Не обязательно там какое-то убитое ребро прямо сейчас убивать.
[44:59.500 --> 45:02.500]  То есть потом, когда следующий DFS придет в эту вершину,
[45:02.500 --> 45:03.500]  он это ребро просто убьет сразу.
[45:03.500 --> 45:05.500]  Просто первое, что делает, это убьет это ребро.
[45:06.500 --> 45:09.500]  Но поэтому прямо сейчас можно не заморачиваться.
[45:10.500 --> 45:12.500]  Вот такая вот красота.
[45:14.500 --> 45:15.500]  Вот.
[45:15.500 --> 45:17.500]  Так, еще вопросы по этой части?
[45:20.500 --> 45:23.500]  А, это окончательная симпточка?
[45:23.500 --> 45:24.500]  Да.
[45:26.500 --> 45:30.500]  В общем, в данном случае можно достаточно легко даже попроводить всякие примеры.
[45:31.500 --> 45:33.500]  Там, не знаю, это когда, там, попроводить примеры,
[45:33.500 --> 45:38.500]  когда, когда, когда симпточка конкретно алгоритма 1 реально будет такой.
[45:40.500 --> 45:45.500]  Ну просто е распределить так, чтобы у вас там были пути не длины 1, и длины 2, и длины 3 и так далее.
[45:45.500 --> 45:47.500]  Тогда как ассоц курии будет.
[45:48.500 --> 45:50.500]  Так что эта симпточка точная.
[45:52.500 --> 45:54.500]  Но теперь уже, если говорить о,
[45:54.500 --> 45:56.500]  вернуться к задаче по рассочетанию,
[45:57.500 --> 45:59.500]  одно из классических применений единичных сетей.
[46:04.500 --> 46:05.500]  Вот.
[46:05.500 --> 46:09.500]  То возникает, конечно, мистический, знаете, умный алгоритм Хобкрофта-Карпа.
[46:11.500 --> 46:12.500]  Вот наш два автора.
[46:13.500 --> 46:14.500]  Вот.
[46:14.500 --> 46:17.500]  Да, и ровно столько же слов на описание этого алгоритма.
[46:17.500 --> 46:18.500]  Запускаем.
[46:18.500 --> 46:19.500]  Да.
[46:25.500 --> 46:26.500]  Самый смешной, что да.
[46:26.500 --> 46:29.500]  Ну, на самом деле, я вас, конечно, подразумеваю, что алгоритм заключает в том,
[46:29.500 --> 46:31.500]  что давайте построим сеть.
[46:32.500 --> 46:33.500]  Ну, как мы в прошлый раз делали.
[46:33.500 --> 46:34.500]  Ну, в общем, получается.
[46:35.500 --> 46:39.500]  Когда в дудольном графе построить сеть, в общем-то, семер вариантов тут особо не возникает.
[46:39.500 --> 46:40.500]  Давайте это сделаем.
[46:41.500 --> 46:44.500]  Ну, то есть напомним, да, что есть у вас вот какая-то вот такая вот.
[46:45.500 --> 46:47.500]  Такой вот граф какой-нибудь вот этот вот, да.
[46:47.500 --> 46:48.500]  То, что мы делаем.
[46:49.500 --> 46:54.500]  То, мы тут строим, как всегда, строим с, строим т.
[46:57.500 --> 46:58.500]  Вот.
[47:00.500 --> 47:03.500]  Соединяем так, все ребра ориентируем вправо.
[47:03.500 --> 47:05.500]  И все пишем, что это один.
[47:07.500 --> 47:11.500]  Ну, чтобы и по ребру, чтобы как бы ребро каждое, там по ребру поток приходил только один.
[47:11.500 --> 47:13.500]  Ну, вы помните, еще в прошлый раз обсуждали.
[47:14.500 --> 47:15.500]  Да и просто, да и просто.
[47:20.500 --> 47:21.500]  Ну, вот.
[47:22.500 --> 47:23.500]  Вот.
[47:24.500 --> 47:25.500]  Вот.
[47:26.500 --> 47:27.500]  Вот.
[47:28.500 --> 47:29.500]  Вот.
[47:30.500 --> 47:31.500]  Вот.
[47:32.500 --> 47:33.500]  Вот.
[47:34.500 --> 47:35.500]  Вот.
[47:40.500 --> 47:41.500]  И что же у нас получается?
[47:46.500 --> 47:47.500]  А получается примерно следующее.
[47:48.500 --> 47:49.500]  Да, везде.
[47:50.500 --> 47:51.500]  И теперь давайте запустим тут динеца.
[47:52.500 --> 47:57.500]  Там алгоритм Хопкорфта как-то построим, вот такую сеть и запустим, где алгоритм динеца.
[47:58.500 --> 48:01.500]  Но есть еще маленькая новинка, да.
[48:02.500 --> 48:07.500]  Мы уже доказали, что тогда мы это просочетание найдем за Екарния из В.
[48:08.500 --> 48:09.500]  Екарния из В.
[48:10.500 --> 48:12.500]  Ну, это мы уже только что доказали.
[48:13.500 --> 48:14.500]  Да.
[48:15.500 --> 48:23.500]  Но на самом деле я утверждаю, что конкретно в данном случае можно уточнить оценочку и сказать, что Екарния из В.
[48:24.500 --> 48:25.500]  Круто.
[48:25.500 --> 48:26.500]  Круто.
[48:27.500 --> 48:28.500]  Да.
[48:29.500 --> 48:31.500]  Откуда же тут Екарния из В берется?
[48:32.500 --> 48:34.500]  За каждой вершинкой небольшой один поток.
[48:35.500 --> 48:36.500]  Да, в общем-то оттуда же.
[48:37.500 --> 48:38.500]  Ведь смотрите какая интересная идея.
[48:39.500 --> 48:40.500]  Ну, то есть логика та же.
[48:41.500 --> 48:43.500]  Ну, начало логики та же.
[48:44.500 --> 48:45.500]  То есть сделаем корень из В итерации.
[48:46.500 --> 48:47.500]  То есть бубер равен корень из В, так?
[48:48.500 --> 48:49.500]  И у нас получается какие-то декомпозиции.
[48:50.500 --> 48:52.500]  Но теперь очень интересный факт, смотрите.
[48:52.500 --> 49:07.500]  Ведь если внимательно посмотреть на исходную сеть, то можно заметить, что в каждой вершину либо входит ровно одно ребро, либо исходит ровно одно ребро.
[49:08.500 --> 49:09.500]  Видите, да?
[49:10.500 --> 49:16.500]  Заметим, что на каждом восстаточной сети, скажем, в эту вершину, все будет так же.
[49:17.500 --> 49:21.500]  То есть в нее в каждый момент времени будет входить ровно одно ненасыщенное ребро.
[49:22.500 --> 49:28.500]  Ну, просто действительно, если вы протолкнете через нее какой-то поток, то тогда что получится?
[49:29.500 --> 49:33.500]  То есть тут получится какая-то единичка, допустим, единичка-единичка, да?
[49:34.500 --> 49:42.500]  То есть тогда эти ребра убьются, но появятся обратные.
[49:43.500 --> 49:44.500]  Теперь вот.
[49:45.500 --> 49:46.500]  Появятся обратные.
[49:47.500 --> 49:51.500]  И тогда получается все равно, как входило ровно одно ребро, так и будет входить ровно одно ребро.
[49:53.500 --> 49:54.500]  Вот, понимаете, да?
[49:55.500 --> 49:56.500]  Вот.
[49:58.500 --> 50:01.500]  Но тогда из этого следует, что когда мы будем рассматривать...
[50:02.500 --> 50:12.500]  Но тогда из этого следует, что если вы рассмотрите в подобного рода сети максимальный поток и декомпозируете его на пути, то на этот раз вот в такой ситуации пути будут не пересекаться не только по ребрам, но еще и по вершинам.
[50:16.500 --> 50:17.500]  Вот.
[50:17.500 --> 50:19.500]  Но вершин-то у нас, то есть получается...
[50:20.500 --> 50:27.500]  Но получается каждый путь у нас длинный и больше, чем корень ESW, значит вот этих вот промежуточных вершин будет больше либо равно, чем корень ESW.
[50:28.500 --> 50:33.500]  Откуда мы и заключаем, что останется фаз не более, чем корень ESW.
[50:33.500 --> 50:35.500]  Так что отсюда получается, что вот у нас...
[50:36.500 --> 50:40.500]  Оказывается, мы теперь умеем искать про сочетание, а жно зовут такую оседотику.
[50:48.500 --> 50:50.500]  В принципе, вот красиво.
[50:51.500 --> 50:52.500]  Можно еще раз?
[50:54.500 --> 50:55.500]  Еще раз?
[50:56.500 --> 50:57.500]  Да.
[50:57.500 --> 50:58.500]  Ну, утверждение.
[50:58.500 --> 51:00.500]  Делаем корень ESW итерации, да?
[51:01.500 --> 51:02.500]  Да.
[51:02.500 --> 51:04.500]  После этого у нас останется какая-то остаточная сеть.
[51:05.500 --> 51:08.500]  Найдем в ней максимальный поток опять же, той же самой остаточной сети.
[51:09.500 --> 51:11.500]  Декомпозируем поток на пути.
[51:13.500 --> 51:18.500]  Эти планотки пути не будут пересекаться не только по ребрам, но и по вершинам.
[51:18.500 --> 51:22.500]  Тогда и на каждом пути будет как минимум корень ESW своих вершин.
[51:29.500 --> 51:31.500]  Ну, всего-то вершин В.
[51:33.500 --> 51:35.500]  На каждом пути не более корень ESW.
[51:36.500 --> 51:37.500]  Как не менее.
[51:38.500 --> 51:43.500]  То есть, корень ESW, корень ESW, корень ESW, корень ESW, корень ESW.
[51:44.500 --> 51:47.500]  На каждом пути не более корень ESW.
[51:48.500 --> 51:49.500]  Как не менее.
[51:50.500 --> 51:51.500]  Корень ESW вершин.
[51:52.500 --> 51:54.500]  Причем, так сказать, своих для каждого пути.
[51:58.500 --> 52:06.500]  Мы уже сделали первые корень ESW стадии, теперь у нас все пути, хотя, ну, больше равные, чем корень ESW.
[52:07.500 --> 52:08.500]  Ну вот.
[52:09.500 --> 52:15.500]  Так же, как в предыдущей, только теперь пути не вертоклеры, а вершины не пересекаются.
[52:17.500 --> 52:19.500]  Вершины не пересекаются.
[52:20.500 --> 52:22.500]  Так что, да, вот такая красота.
[52:24.500 --> 52:26.500]  У тебя теперь корни ESW.
[52:28.500 --> 52:32.500]  Это, как это, это умный алгоритм Ховкрофта.
[52:33.500 --> 52:36.500]  Не знаю, была ли посвящена этому алгоритму прям отдельная статья.
[52:39.500 --> 52:41.500]  Хотя, ну, хотя на две странички, в принципе, помогало.
[52:44.500 --> 52:45.500]  Уровень заметка.
[52:48.500 --> 52:49.500]  Ну ладно.
[52:50.500 --> 52:51.500]  А теперь дальше.
[52:52.500 --> 52:56.500]  У нас там было E делить на B, а тут у нас получается B делить на корень ESW.
[52:56.500 --> 52:58.500]  А здесь? Ну там просто будет просто B.
[52:59.500 --> 53:01.500]  То есть, теперь мы В поделить на B.
[53:04.500 --> 53:06.500]  Ну потому что раньше мы покрывали ребра.
[53:07.500 --> 53:09.500]  То есть, каждое ребро покрыто своим путем.
[53:10.500 --> 53:15.500]  Ну вот, поэтому там и каждый путь покрывал там B, E, поэтому E поделить на B.
[53:16.500 --> 53:17.500]  А теперь мы покрываем вершины.
[53:20.500 --> 53:23.500]  Поэтому там будет B плюс V поделить на B.
[53:24.500 --> 53:26.500]  Так что вот такой вот будет.
[53:27.500 --> 53:28.500]  Ну вот.
[53:29.500 --> 53:31.500]  Но здесь, оказывается, и это еще не все.
[53:32.500 --> 53:34.500]  Не, не в смысле ассимптотики, лучше не будет.
[53:36.500 --> 53:37.500]  Ну вот.
[53:38.500 --> 53:44.500]  Но товарищ умник тем не менее усеклется и тут называется предложить веселую интересность.
[53:45.500 --> 53:47.500]  Представьте, задачка.
[53:47.500 --> 53:49.500]  Миллион вершин, два миллиона вершин.
[53:51.500 --> 53:53.500]  Найдите, пожалуйста, максимальное просочетание.
[53:56.500 --> 53:57.500]  Найдите и предъявите его.
[53:58.500 --> 53:59.500]  Да.
[54:00.500 --> 54:01.500]  Ну как максимальное?
[54:02.500 --> 54:09.500]  Ответ будет признан правильным, если размер предложенного вами просочетания будет не менее чем 95.
[54:10.500 --> 54:18.500]  Ответ будет признан правильным, если размер предложенного вами просочетания будет не менее чем 95 процентов от правильного.
[54:24.500 --> 54:26.500]  А, ну то есть не точно.
[54:27.500 --> 54:28.500]  Да.
[54:29.500 --> 54:32.500]  Ну, можно сказать, что мы вначале будем очень быстро набирать нас.
[54:33.500 --> 54:34.500]  Вот, да.
[54:35.500 --> 54:36.500]  А насколько быстро?
[54:37.500 --> 54:38.500]  В идее правильно.
[54:39.500 --> 54:40.500]  А теперь давайте...
[54:41.500 --> 54:42.500]  Какая еще раз идея?
[54:43.500 --> 54:44.500]  Ну, пока идея такая вот.
[54:45.500 --> 54:49.500]  Возникает что-то жуткое ощущение, что, скорее всего, на первых фазах, наверное, большая часть просочетания будет набрана.
[54:50.500 --> 54:53.500]  Осталось только точно оценить, насколько быстро выбирается.
[54:57.500 --> 54:59.500]  А теперь вот давайте внимательно на это посмотрим.
[55:00.500 --> 55:05.500]  Вот давайте опять представим, что мы сделали Бубен и Тарас.
[55:06.500 --> 55:07.500]  Вот опять Бубен.
[55:08.500 --> 55:10.500]  А набираем, в смысле, просто жадно?
[55:11.500 --> 55:12.500]  Рандомно берем пары?
[55:13.500 --> 55:15.500]  Нет, ну, как это алгоритм делится, да?
[55:16.500 --> 55:18.500]  Он строит слоистую сеть и как-то там ищет пути.
[55:19.500 --> 55:24.500]  Как конкретно он их ищет, он зависит, наверное, от порядка игры.
[55:25.500 --> 55:27.500]  Не, у нас же просто дан общий граф, да?
[55:28.500 --> 55:30.500]  Ну, сейчас дан конкретный, да.
[55:31.500 --> 55:36.500]  Не, у нас задача дан граф общего вида или обязательно двудольный?
[55:37.500 --> 55:38.500]  Нет, двудольный.
[55:39.500 --> 55:40.500]  Нет, двудольный.
[55:41.500 --> 55:42.500]  Нет, двудольный.
[55:43.500 --> 55:45.500]  Не, не, не, не настолько.
[55:46.500 --> 55:47.500]  Вот, значит, Бубен.
[55:48.500 --> 55:49.500]  Как тут Бубен?
[55:50.500 --> 55:52.500]  Это мы сделали первые Бубен и Тарасы.
[55:53.500 --> 55:54.500]  Да, вот представь себе.
[55:55.500 --> 56:01.500]  Да, построили у двудольного графа вот такую сеть, запустили Диница, сделали у Диница Бубен и Тарас.
[56:01.500 --> 56:02.500]  Итарация.
[56:04.500 --> 56:06.500]  Значит, что же такое?
[56:07.500 --> 56:11.500]  Значит, теперь давайте посмотрим на это все внимательнее.
[56:14.500 --> 56:19.500]  Значит, как у нас устроены после Бубен итерации, ну, как устроен этот поток?
[56:20.500 --> 56:24.500]  Ну, поток у нас это опять что-то, то есть какие-то вот эти вот пути, да?
[56:26.500 --> 56:29.500]  Ну, поток оставшийся декабодируется на пути, да?
[56:32.500 --> 56:33.500]  А теперь смотрите вот что.
[56:34.500 --> 56:35.500]  Как устроен этот путь?
[56:36.500 --> 56:45.500]  Ведь смотрите, в каждый момент времени, если проигнорировать, то есть в каждый момент времени, на самом деле, каждый поток символизирует какое-то парасочетание, правда?
[56:46.500 --> 56:55.500]  И у нас, у каждой ребро, либо ребро включено сейчас в парасочетании, и тогда у нас в остаточной сети живет обратное, либо не включено, и тогда у нас в сети живет вот это ребро, да?
[56:56.500 --> 56:57.500]  Так.
[56:58.500 --> 56:59.500]  Теперь смотрите.
[57:00.500 --> 57:03.500]  А теперь давайте подумаем, как устроен любой путь из С в Т?
[57:06.500 --> 57:07.500]  Ну, он устроен очень просто.
[57:08.500 --> 57:22.500]  Значит, заметим, что, ну, устроить он тут не сильно много вариантов, так как мы в С не входим, а в Т уже не выходим, ага, в двудольные, то на самом деле заметим, что любой путь будет устроен вот таким вот нехитрым образом.
[57:25.500 --> 57:35.500]  Ну, да, в терминах алгоритма Куна это удвиняющая цикл, да?
[57:36.500 --> 57:37.500]  Вот.
[57:38.500 --> 57:39.500]  Вот такая рация.
[57:40.500 --> 57:42.500]  Ну, теперь заметим вот что.
[57:43.500 --> 57:56.500]  На самом деле, заметим, что в каждый момент времени, ну, то есть мы можем вот этот оставшийся после Губбина итерации путь, то есть оставшийся поток декомпозировать на пути, которые вот по ребрам и по вершинам не пересекутся.
[57:57.500 --> 57:58.500]  Внимательно.
[57:59.500 --> 58:01.500]  Ну, теперь рассмотрим каждый такой путь.
[58:02.500 --> 58:06.500]  Вот у нас один, вот каждый по каждому такому пути мы можем протолкнуть только единицу потока, да?
[58:07.500 --> 58:09.500]  Ну, теперь заметим следующее.
[58:09.500 --> 58:19.500]  Заметим, что вот эти ребра в просочетании не участвуют, а вот эти, точнее их напарники участвуют. Видите, да?
[58:20.500 --> 58:22.500]  Ну, которые вот идут справа-налево.
[58:23.500 --> 58:26.500]  То есть вот правильно их, конечно, выше не нарисовать.
[58:27.500 --> 58:29.500]  А что значит участвуют или не участвуют?
[58:30.500 --> 58:31.500]  Ну, вот как я выше сказал.
[58:31.500 --> 58:43.500]  Какой бы я тут поток в этой сети не запустил, да, то есть если у нас по этому ребру поток течет, то это как бы символизирует, что оно участвует в просочетании.
[58:44.500 --> 58:47.500]  А в остаточной сети его представляет вот режим напарника.
[58:48.500 --> 58:55.500]  А если по ребру поток не течет, то тогда это просто вот ребро слева-направо, оно представляет в остаточной сети слово сияется.
[58:56.500 --> 58:59.500]  Ну, тогда получается, смотрите, какая ситуация.
[59:00.500 --> 59:08.500]  То есть у нас получается, каждая единица потока в этой его, в оставшейся сети, в оставшейся остаточной сети, так сказать,
[59:09.500 --> 59:15.500]  у нас каждая единица потока вот соответствует какой-то набор рыжих ребер.
[59:16.500 --> 59:27.500]  И этих рыжих ребер у вас больше либо равно, чем будем.
[59:29.500 --> 59:35.500]  Ну, давай.
[59:36.500 --> 59:43.500]  Ну, тут, да, все тут пути еще нечетные, да, на самом деле тут не 1, 2, 3, 4, 5, а на самом деле 3, 5, 7, 9 и так далее.
[59:44.500 --> 59:52.500]  Это поток в сети после губер-интерации.
[59:52.500 --> 01:00:01.500]  После губер-интерации рассматриваем максимальный поток, и каждая единица потока соответствует вот такой вот губер.
[01:00:02.500 --> 01:00:14.500]  То есть получается, если у нас было, соответственно, f губер, то есть это сколько мы нашли за губер-интерацией, да?
[01:00:14.500 --> 01:00:29.500]  Ну, смотрите, тут, видите, в этом граф специфический, там он так устроен, что изначально кричащий путь не меньше, чем 3, потом не меньше, чем 5, потом не меньше, чем 7 и так далее.
[01:00:29.500 --> 01:00:32.500]  Поэтому, да.
[01:00:33.500 --> 01:00:41.500]  Или можно говорить, что вот таких ребер, или в переводе говорят, то есть одно такое, одно такое, и тут вот таких ребер не меньше, чем 0, не меньше, чем одно и так далее.
[01:00:42.500 --> 01:00:44.500]  Ну, после губер-интерации не меньше, чем будем.
[01:00:45.500 --> 01:00:53.500]  То есть получается, у нас есть поток f губер, то есть это просочетание, которое мы нашли до этого.
[01:00:53.500 --> 01:00:58.500]  И потом у нас и есть еще f оставший.
[01:01:02.500 --> 01:01:09.500]  Но заметьте, что количество рыжих ребер сейчас, да, после губер-интерации, это в точности f от губер, правда?
[01:01:09.500 --> 01:01:27.500]  И тогда получается интересный факт, что f оставшиеся получается меньше либо равно f губер поделить, да?
[01:01:27.500 --> 01:01:49.500]  То есть у нас, оказывается, то, что мы нашли раньше, то есть то, что мы нашли раньше за губер-интерацией, это хотя бы в губер-интерации раз больше, чем то, что нам осталось.
[01:01:49.500 --> 01:01:59.500]  Ну, теперь все, что нам остается, это прибавить к этому неравенству с двух сторон f губер.
[01:02:01.500 --> 01:02:03.500]  Вот здесь и здесь.
[01:02:06.500 --> 01:02:13.500]  Тогда во что это превратится? f губер плюс f оста, это просто максимальное просочетание, оно же размер максимального потока, да?
[01:02:14.500 --> 01:02:16.500]  То есть f просто.
[01:02:17.500 --> 01:02:21.500]  И это будет меньше либо равно f губер.
[01:02:22.500 --> 01:02:30.500]  f губер умножить на, соответственно, губер плюс один поделить на губер.
[01:02:30.500 --> 01:02:56.500]  Ну, или что то же самое, f губер, то есть после губер-интерации мы сделаем больше либо равно, чем губер поделить на губер плюс один f.
[01:02:57.500 --> 01:02:59.500]  Вот такой интересный факт.
[01:03:01.500 --> 01:03:04.500]  Который я, собственно, и называю Теремонидомирюка.
[01:03:08.500 --> 01:03:10.500]  19 итераций.
[01:03:11.500 --> 01:03:21.500]  Да, то есть вот авторское решение так и предполагает, давайте просто сделаем 1, но сделаем там 19 итераций ДМС.
[01:03:22.500 --> 01:03:26.500]  То есть не сколько там реально надо, а 19. Ну, или там меньше.
[01:03:30.500 --> 01:03:32.500]  Вот так.
[01:03:36.500 --> 01:03:43.500]  И тогда действительно оказывается, за 19 итераций мы найдем не менее чем 19,20 от максимального размера протокина.
[01:03:45.500 --> 01:03:49.500]  Так что вот это называется Теремонидомирюка.
[01:03:52.500 --> 01:03:55.500]  А можно еще раз повторить, что это за зигзак?
[01:03:56.500 --> 01:04:04.500]  Мы сказали, что любой путь, представим, где ты входишь из стока в левую долю, входишь вот между ними и выходишь обратно.
[01:04:05.500 --> 01:04:06.500]  Ну, у нас все ребра.
[01:04:07.500 --> 01:04:08.500]  Это понятно.
[01:04:09.500 --> 01:04:13.500]  Вот, и тогда получается любой путь из СТ, достаточно из сети, он выглядит вот таким зигзаком.
[01:04:14.500 --> 01:04:16.500]  Теперь почему я тут рисую именно вот такие же ребра?
[01:04:17.500 --> 01:04:21.500]  Потому что замечаем, что изначально все ребра смотрели слева направо.
[01:04:22.500 --> 01:04:29.500]  И у нас тогда, а потом в процессе у нас либо по ребру не пошел поток, и тогда это ребро так и смотрит слева направо,
[01:04:30.500 --> 01:04:35.500]  либо по ребру пошел поток, тогда этого ребра нет, но у него есть рыжий напашник, который смотрит справа налево.
[01:04:36.500 --> 01:04:39.500]  И это единственный способ, как справа налево ребра могли получиться.
[01:04:40.500 --> 01:04:42.500]  Поэтому я этот зигзак рисую вот именно вот таким образом.
[01:04:43.500 --> 01:04:46.500]  То есть рыжие ребра – это те, по которым раньше шел поток?
[01:04:46.500 --> 01:04:49.500]  Рыжие ребра – это обратные к тем, по которым реально идет поток.
[01:04:51.500 --> 01:04:55.500]  Так, если вы случайно знаете, что такое алгоритм Куна...
[01:04:58.500 --> 01:05:00.500]  А, вы-то пока не знаете, что это алгоритм Куна?
[01:05:01.500 --> 01:05:04.500]  То есть я один не знаю, Куну до сих пор так и не помню.
[01:05:05.500 --> 01:05:06.500]  А-а-а.
[01:05:07.500 --> 01:05:09.500]  Затонные фазы уже прошли, уже неплохо.
[01:05:10.500 --> 01:05:11.500]  Удлиняющая цепь.
[01:05:11.500 --> 01:05:13.500]  Так, ну ладно, раз уж об этом зашла речь.
[01:05:14.500 --> 01:05:15.500]  Ладно, давайте так можно...
[01:05:16.500 --> 01:05:17.500]  Так, а вот там про Вубина.
[01:05:19.500 --> 01:05:20.500]  В смысле?
[01:05:20.500 --> 01:05:21.500]  Ну потому что...
[01:05:22.500 --> 01:05:23.500]  Ну еще раз.
[01:05:24.500 --> 01:05:30.500]  Ну потому что мы замечаем, что в каждой удлиняющей цепи, после Вубин-итерации Диница,
[01:05:31.500 --> 01:05:34.500]  в каждой удлиняющей цепи будет хотя бы Вубин-рёбер из пор сочетания.
[01:05:34.500 --> 01:05:38.500]  Следовательно, оставшиеся то, что нам осталось, не превосходит...
[01:05:39.500 --> 01:05:41.500]  То есть основной факт на самом деле такой.
[01:05:45.500 --> 01:05:46.500]  Вот это вот основной факт.
[01:05:47.500 --> 01:05:52.500]  То есть то, что нам осталось, не превосходит то, что мы уже нашли, то есть количество рыжих ребер поделить нам будет.
[01:05:54.500 --> 01:05:55.500]  Ну и что же мы делаем?
[01:05:56.500 --> 01:05:57.500]  Вот это вот основной факт.
[01:05:58.500 --> 01:06:03.500]  То есть то, что нам осталось, не превосходит то, что мы уже нашли, то есть количество рыжих ребер поделить нам будет.
[01:06:08.500 --> 01:06:09.500]  Что такое фост?
[01:06:10.500 --> 01:06:11.500]  То, что она...
[01:06:12.500 --> 01:06:15.500]  Вот этот большевальный поток, который в остаточной сети после Вубин-итерации.
[01:06:16.500 --> 01:06:17.500]  А почему как Вубин?
[01:06:18.500 --> 01:06:22.500]  Нарисовали вы просто какой-то путь рандомный, который мы нашли.
[01:06:23.500 --> 01:06:25.500]  Я его написал, конечно, не просто так, скорее из декомпозиции.
[01:06:26.500 --> 01:06:27.500]  Вообще любой рандомный путь выглядит так.
[01:06:28.500 --> 01:06:31.500]  А теперь пообразим себе декомпозицию потока этого оставшегося потока.
[01:06:32.500 --> 01:06:33.500]  А и Вубин это количество или...
[01:06:34.500 --> 01:06:37.500]  Нет, f-Vubin это размер потока после Вубин-итерации.
[01:06:39.500 --> 01:06:41.500]  Он же количество рыжих ребер на текущий момент.
[01:06:42.500 --> 01:06:43.500]  По случайному...
[01:06:44.500 --> 01:06:45.500]  Рыжих ребер по всей декомпозиции.
[01:06:46.500 --> 01:06:47.500]  Да, но не совсем.
[01:06:48.500 --> 01:06:49.500]  Нет, не по декомпозиции, а вообще в графе.
[01:06:49.500 --> 01:06:51.500]  Ну, не считая, конечно, рыжих ребер вот этих вот.
[01:06:52.500 --> 01:06:53.500]  Вот эти мы не считаем, конечно.
[01:06:54.500 --> 01:06:56.500]  Мы считаем только вот эту основную часть.
[01:07:01.500 --> 01:07:02.500]  Можно вопрос?
[01:07:03.500 --> 01:07:04.500]  Можно, не совсем понятно, почему...
[01:07:05.500 --> 01:07:07.500]  Как связано f-Vubin с f-остаточным?
[01:07:08.500 --> 01:07:09.500]  Ну, смотрите.
[01:07:10.500 --> 01:07:13.500]  f-Vubin это количество рыжих ребер вот в этой части сети.
[01:07:14.500 --> 01:07:15.500]  Да.
[01:07:16.500 --> 01:07:17.500]  Логично, да?
[01:07:17.500 --> 01:07:18.500]  То есть количество рыжих ребер.
[01:07:19.500 --> 01:07:21.500]  А, f-Vubin это количество ребер уже на взятый поток.
[01:07:22.500 --> 01:07:24.500]  То есть количество ребер взятых в расписание.
[01:07:25.500 --> 01:07:26.500]  То есть количество рыжих ребер.
[01:07:27.500 --> 01:07:28.500]  То есть количество обратных ребер.
[01:07:29.500 --> 01:07:30.500]  Ага, все, теперь понял, да.
[01:07:31.500 --> 01:07:32.500]  Ну, так получается, да.
[01:07:33.500 --> 01:07:37.500]  И в каждой сети, в декомпозиции, в каждом пути будет вот Вубин своих рыжих ребер.
[01:07:38.500 --> 01:07:39.500]  Так что вот такая разница.
[01:07:40.500 --> 01:07:45.500]  А почему f-Vubin плюс f-оставшийся это f максимальное в изначальном графе?
[01:07:45.500 --> 01:07:47.500]  Ну, потому что f-Vubin это тоже...
[01:07:48.500 --> 01:07:50.500]  Вы делали Вубин-интерацией потока.
[01:07:51.500 --> 01:07:55.500]  Какой-то поток вы нашли за эти Вубин-интерации, какой-то вам предстоит еще найти.
[01:07:56.500 --> 01:07:58.500]  Вот мы сделали первый Вубин-интерацией.
[01:07:59.500 --> 01:08:00.500]  И нашли f-Vubin поток.
[01:08:01.500 --> 01:08:02.500]  Да, и у нас есть остаточная сеть текущая.
[01:08:03.500 --> 01:08:05.500]  В которой максимальный поток f-остаточный.
[01:08:06.500 --> 01:08:13.500]  Да, но почему максимальный поток в остаточной сети это максимальный поток в текущем графе сети?
[01:08:13.500 --> 01:08:15.500]  Текущем графе сети.
[01:08:20.500 --> 01:08:22.500]  Так, ну если вы даже не знаете...
[01:08:23.500 --> 01:08:24.500]  Как это?
[01:08:25.500 --> 01:08:27.500]  Знаете, я не умею объяснить почему травы зеленые немножко.
[01:08:28.500 --> 01:08:34.500]  А, у нас есть факт, что максимальный поток в остаточной сети это максимальный поток графе?
[01:08:35.500 --> 01:08:41.500]  Ну это не просто факт, это просто метод форта флукевсона как устроен.
[01:08:41.500 --> 01:08:44.500]  Ну или просто пихаете-пихаете потоки, да?
[01:08:45.500 --> 01:08:55.500]  Там соответственно, в каждый раз, когда вы пихаете единичный поток, в остаточной сети поток уменьшается.
[01:08:56.500 --> 01:08:57.500]  Вот.
[01:09:03.500 --> 01:09:04.500]  Вот.
[01:09:10.500 --> 01:09:11.500]  Значит, вот соответственно.
[01:09:12.500 --> 01:09:14.500]  Так что вот это была тяга будденей рука.
[01:09:16.500 --> 01:09:17.500]  Так.
[01:09:19.500 --> 01:09:21.500]  Денг, сколько у нас там времени-то?
[01:09:22.500 --> 01:09:23.500]  Ну окей.
[01:09:24.500 --> 01:09:31.500]  Ну раз уж об этом зашла речь, действительно, можно кратенько действительно обнаружить, откуда у нас при поиске просочетаний вообще берется алгоритм куна.
[01:09:32.500 --> 01:09:34.500]  Ну точнее, что это вообще такое?
[01:09:35.500 --> 01:09:37.500]  Ну на самом деле, действительно, заметим, что...
[01:09:38.500 --> 01:09:47.500]  То есть давайте подумаем, давайте просто, ладно, хорошо, вот, его можно искатиться, но давайте себе представим, что мы ищем просочетания методом форта флукевсона.
[01:09:48.500 --> 01:09:50.500]  Представим себе такое, да?
[01:09:51.500 --> 01:09:52.500]  Можем такое представить, можем.
[01:09:53.500 --> 01:10:01.500]  Тогда заметим, что каждый DFS, он, по сути, будет искать путь, ну вот, собственно, ровно такого вида.
[01:10:02.500 --> 01:10:03.500]  Видите, да?
[01:10:05.500 --> 01:10:11.500]  Но это если вот строить нот, это если прям в явном виде строить остаточную сеть.
[01:10:12.500 --> 01:10:14.500]  В принципе, этот алгоритм будет работать за от VEP.
[01:10:15.500 --> 01:10:16.500]  Почему за от VEP?
[01:10:17.500 --> 01:10:23.500]  Потому что у каждой просочетания не более, чем у от VEP, и каждый DFS будет работать за от VEP и находить и увеличивать просочетания хотя бы на 1.
[01:10:24.500 --> 01:10:25.500]  Правда?
[01:10:26.500 --> 01:10:27.500]  Понимаете?
[01:10:28.500 --> 01:10:29.500]  Вот.
[01:10:30.500 --> 01:10:32.500]  То есть, заметим, то есть сейчас как бы для нас...
[01:10:33.500 --> 01:10:35.500]  Значит, теперь поехали.
[01:10:36.500 --> 01:10:40.500]  Значит, да, наша цель найти такую вот удлиняющую цель.
[01:10:41.500 --> 01:10:52.500]  Ну, у нас есть терема Форда Балкерсона, который говорит, что найденное нами просочетание максимально тогда и только тогда, когда не существует вот такого вот, какого-то пути.
[01:10:53.500 --> 01:10:54.500]  Да?
[01:10:55.500 --> 01:11:04.500]  Но заметим, что, то есть если попытаться это переформулировать без, значит, истока истока, то тогда что у нас остается?
[01:11:05.500 --> 01:11:10.500]  У нас остается путь, который начинается в вершине левой доли непокрытой просочетания.
[01:11:11.500 --> 01:11:17.500]  Да, заметим же одно – что если вершина уже покрыта просочетания, то она покрыта навсегда.
[01:11:18.500 --> 01:11:22.500]  То есть, там, конкретно каким ребром покрыта может меняться, но то, что она покрыта, уже сомнений не изв Release.
[01:11:23.500 --> 01:11:26.500]  То есть, начинается в вершине левой доли, которая не покрыта просочетанием.
[01:11:27.500 --> 01:11:28.500]  Бегает, бегает, бегает, бегает.
[01:11:28.500 --> 01:11:31.500]  Причем, влево бегает по ребрам не покрытым.
[01:11:31.500 --> 01:11:37.820]  в правой берет ток по ребрам из поросочетания и в итоге приходит вершина правой доли непокрытая
[01:11:37.820 --> 01:11:55.780]  поросочетанием. Это вот называется удлиняющая цель. Надеюсь я никакую букву не пропустил.
[01:11:55.780 --> 01:12:21.540]  Ну просто. Я сейчас не приведу то, что правила русского языка. Ну удлиняющая, ну просто
[01:12:21.540 --> 01:12:30.940]  потому что слово удлинить тоже пишут с одно «m». Ну как бы удлинить, удлинить или нет, это все с одно «m» пишут.
[01:12:30.940 --> 01:12:57.460]  Давайте правила русского языка потом погубим. Или по Яндекс. Яндекс может уже лучше.
[01:12:57.460 --> 01:13:21.460]  А вот оригинальная алгоритма Фолкэксона немного другую вещь делает. Нет, на самом деле так. На самом деле немножко другой, потому что я отвечаю так, что он действительно делает форзо Фолкэксона, только делает это более красиво.
[01:13:21.460 --> 01:13:49.460]  Медленно работает. Медленнее. Если запустить вместо кума Фолкэксона, будет видеть гораздо быстрее. Не уверен. Пост НКФ это истина первой станции. Да, но как-то сомнительно. Потому что если прям строить вот эту сеть и запускать Фолкэксона. Нет, нет, я не об этом. Я о том, что если взять и сделать такую же логику запусков как в Фолкэксоне, а не как в…
[01:13:49.460 --> 01:13:59.460]  Нет, это странно, потому что казалось бы он будет делать ровно то же самое, только прибегаться по лишним бельшинам, по лишним лёмам.
[01:13:59.460 --> 01:14:01.460]  Сейчас, не совсем оригинальный.
[01:14:01.460 --> 01:14:03.460]  Просто видимо он разный представитель.
[01:14:03.460 --> 01:14:10.460]  А, короче, если в тупую искать блокирующий поток Фолкэксона.
[01:14:10.460 --> 01:14:15.460]  А что такое в тупую искать блокирующий поток Фолкэксона?
[01:14:16.460 --> 01:14:21.460]  Нет, если его совсем в тупую искать, ну извиняйте, это значит кто-то плохо единицы написал.
[01:14:21.460 --> 01:14:23.460]  Не-не-не, в смысле…
[01:14:23.460 --> 01:14:25.460]  Ладно.
[01:14:25.460 --> 01:14:27.460]  Нет, ну сейчас посмотрим.
[01:14:27.460 --> 01:14:30.460]  Тут как бы еще зависит от размера просчитания на самом деле.
[01:14:30.460 --> 01:14:33.460]  Потому что заметим, что этот ВЕ на самом деле…
[01:14:33.460 --> 01:14:39.460]  Ну, точнее, в идеале на самом деле, когда мы говорим, что работает за ВЕ, на самом деле мы не совсем правы.
[01:14:39.460 --> 01:14:41.460]  Ну, видите, который у нас сейчас есть.
[01:14:41.460 --> 01:14:47.460]  На самом деле он работает за ZE, так сказать, F максимального потока.
[01:14:47.460 --> 01:14:50.460]  То есть размер максимального просчитания.
[01:14:50.460 --> 01:14:54.460]  Если там размер максимального просчитания 5, то он его найдет за 5 DFS.
[01:14:54.460 --> 01:14:56.460]  Ну ладно, за 6.
[01:14:56.460 --> 01:14:58.460]  Это метод форда Фолкэксона.
[01:14:58.460 --> 01:15:00.460]  Да, прям тупой, да?
[01:15:00.460 --> 01:15:01.460]  Теперь давайте…
[01:15:01.460 --> 01:15:03.460]  Целочисленно.
[01:15:03.460 --> 01:15:06.460]  Ну, мы просчитания ищем.
[01:15:06.460 --> 01:15:08.460]  У нас не просто целочисленные.
[01:15:08.460 --> 01:15:10.460]  Да, мы все еще ищем просочетания.
[01:15:10.460 --> 01:15:14.460]  То есть алгоритм Кунна, он как бы дан был долгий граф, ищет просочетания.
[01:15:14.460 --> 01:15:16.460]  Но мы пока…
[01:15:16.460 --> 01:15:18.460]  Ну вот, значит, берем форда Фолкэксона.
[01:15:18.460 --> 01:15:20.460]  Значит, теперь убираем S&T.
[01:15:20.460 --> 01:15:22.460]  Что поменяется?
[01:15:22.460 --> 01:15:24.460]  Что такое S&T?
[01:15:24.460 --> 01:15:26.460]  Ну, и сток, и сток.
[01:15:26.460 --> 01:15:27.460]  Ну, вот этот сток.
[01:15:27.460 --> 01:15:28.460]  Добавили, да?
[01:15:28.460 --> 01:15:29.460]  Все.
[01:15:29.460 --> 01:15:32.460]  А теперь говорим, что давайте S&T, вот на S&T лишнее время не тратить.
[01:15:33.460 --> 01:15:39.460]  А вместо этого давайте помечать, для каждой вершины лежит ли она в просочетании.
[01:15:39.460 --> 01:15:42.460]  Можем даже в явном виде напарника сродить.
[01:15:42.460 --> 01:15:49.460]  И на каждом шаге просто запускать DFS из всех вершин левой доли непокрытой просочетания.
[01:15:49.460 --> 01:15:51.460]  То есть запускаем DFS.
[01:15:51.460 --> 01:15:57.460]  Если из какой-то вершины мы вот неожиданно достигли вершины правой доли непокрытой просочетанием,
[01:15:57.460 --> 01:16:02.460]  то вот удлиняющая цепь на лицо, и мы вдоль этой удлиняющей цепи улучшаем просочетание.
[01:16:02.460 --> 01:16:04.460]  Ну, то есть что такое пропихнуть поток?
[01:16:04.460 --> 01:16:08.460]  Это сказать, что вот эти ребра теперь лежат в просочетании, а вот эти теперь нет.
[01:16:08.460 --> 01:16:11.460]  Но зато вот эти на месте.
[01:16:11.460 --> 01:16:15.460]  Понимаете, да?
[01:16:15.460 --> 01:16:17.460]  Мы сейчас попередом куна разбираем, что ли?
[01:16:17.460 --> 01:16:18.460]  Да.
[01:16:18.460 --> 01:16:22.460]  Вообще, приходим к алгоритму куна, это еще не он.
[01:16:22.460 --> 01:16:26.460]  Так, еще раз, мы убираем S&T.
[01:16:26.460 --> 01:16:30.460]  Убираем обратные и...
[01:16:30.460 --> 01:16:33.460]  Нет, мы убираем S&T, а не обратные.
[01:16:33.460 --> 01:16:37.460]  То есть пока мы просто говорим, что теперь вместо того, чтобы искать путь от S&T,
[01:16:37.460 --> 01:16:44.460]  мы ищем путь от вершины левой доли непокрытой просочетанием в вершину правой доли непокрытой просочетанием.
[01:16:44.460 --> 01:16:47.460]  Теперь следующая идея.
[01:16:47.460 --> 01:16:53.460]  Давайте вместо того, чтобы хранить эти все прямые и обратные ребра,
[01:16:53.460 --> 01:16:56.460]  будем хранить только две вещи.
[01:16:56.460 --> 01:16:58.460]  Значит, смотрите, вместо этого мы будем делать так.
[01:16:58.460 --> 01:16:59.460]  Смотрите.
[01:16:59.460 --> 01:17:04.460]  Ведь на самом деле из каждой вершины правой доли может исходить только одно обратное ребро.
[01:17:04.460 --> 01:17:06.460]  Это ребро просочетания, правда?
[01:17:06.460 --> 01:17:12.460]  А вот давайте его в явном виде хранить.
[01:17:12.460 --> 01:17:14.460]  Вот. Давайте его в явном виде хранить.
[01:17:14.460 --> 01:17:17.460]  Тогда заметим, что вот из правой доли DFS...
[01:17:17.460 --> 01:17:21.460]  То есть DFS, когда придет в вершину правой доли, у него все очень просто.
[01:17:21.460 --> 01:17:26.460]  Либо из этой вершины нету рыжего ребра.
[01:17:26.460 --> 01:17:27.460]  Ребра просочетания.
[01:17:27.460 --> 01:17:31.460]  Тогда мы говорим, что ура, мы пришли куда надо.
[01:17:31.460 --> 01:17:35.460]  Либо у нас из нее одно ребро так считает, и у нас только один вариант куда пойти.
[01:17:35.460 --> 01:17:42.460]  То есть идем просто сразу в вершину соответствующую вершину левой доли.
[01:17:42.460 --> 01:17:44.460]  То есть смотрите, у нас такая революция.
[01:17:44.460 --> 01:17:48.460]  Мы вообще отказываемся от достаточной сети.
[01:17:48.460 --> 01:17:55.460]  Единственное, что нам требуется, это то, что очень захочется, чтобы когда мы пришли в эту вершину, мы из нее вот сюда не ходили.
[01:17:55.460 --> 01:17:59.460]  Вот по этому ребру не ходили, потому что его как бы нет.
[01:17:59.460 --> 01:18:02.460]  Понимаете, да?
[01:18:02.460 --> 01:18:07.460]  Но с другой стороны, если мы в эту вершину пойдем, она все равно нас сюда вернет.
[01:18:07.460 --> 01:18:12.460]  Поэтому идея такая, что конкретно вот это ребро можно в общем-то и не угонять.
[01:18:12.460 --> 01:18:19.460]  То есть самое главное, чтобы в нужные моменты времени у нас исчезало рыжее ребро.
[01:18:19.460 --> 01:18:21.460]  Но на самом деле это не проблема.
[01:18:21.460 --> 01:18:28.460]  Потому что, как я уже сказал, мы просто для каждой вершины правой доли будем хранить, есть ли в ней просочетание, и если да, то кто на партии.
[01:18:28.460 --> 01:18:31.460]  И это и будет тем самым рыжим ребром.
[01:18:31.460 --> 01:18:41.460]  То есть если вот после проталкивания потока по вот этой длиняющей цепи рыжее ребро будет перенаправлено сюда, то здесь просто одна переменная поменяется.
[01:18:42.460 --> 01:18:45.460]  Понятно?
[01:18:45.460 --> 01:18:47.460]  Вот.
[01:18:47.460 --> 01:18:59.460]  То есть в результате, вместо того, чтобы вот эту вот писать всю сеть, мы уже приходим к весьма минималистичной реализации.
[01:18:59.460 --> 01:19:04.460]  По крайней мере DFS из нее будет выглядеть, то есть граф у нас вообще будет выглядеть.
[01:19:04.460 --> 01:19:06.460]  То есть что у нас будет вообще?
[01:19:06.460 --> 01:19:08.460]  Вектор, вектор интгра.
[01:19:15.460 --> 01:19:19.460]  И размер у него будет как размер левой доли.
[01:19:19.460 --> 01:19:22.460]  То есть я буду создавать в доле граф очень просто.
[01:19:22.460 --> 01:19:25.460]  У меня есть доля левая доля и правая доля.
[01:19:25.460 --> 01:19:32.460]  И я буду просто для каждой вершины левой доли говорить, куда ведут из каждой вершины, в какие вершины правой доли.
[01:19:32.460 --> 01:19:35.460]  Вот, понимаете, да?
[01:19:35.460 --> 01:19:39.460]  Значит, в результате что нам еще потребуется?
[01:19:39.460 --> 01:19:42.460]  Вектор инт.
[01:19:42.460 --> 01:19:46.460]  Ну, а первых, юзет для левой доли.
[01:19:46.460 --> 01:19:56.460]  И нам потребуется вектор инт.
[01:19:56.460 --> 01:19:59.460]  Ну, я его назваю Порю.
[01:19:59.460 --> 01:20:01.460]  Или как там, напарник.
[01:20:01.460 --> 01:20:05.460]  Ну, можно тут написать слово ХОБРАВ, конечно, но...
[01:20:07.460 --> 01:20:10.460]  Изначально тут минус один.
[01:20:10.460 --> 01:20:14.460]  Ну, минус один будет в каждой вершине правой доли, а в минус один будет в правой доле.
[01:20:14.460 --> 01:20:18.460]  Минус один будет в каждой вершине правой доли, а в минус один, значит, напарника нет.
[01:20:18.460 --> 01:20:22.460]  А если напарник есть, там будет написан номер этого напарника.
[01:20:22.460 --> 01:20:25.460]  Вот, понимаете, да?
[01:20:25.460 --> 01:20:30.460]  И что же нас теперь ждет?
[01:20:30.460 --> 01:20:33.460]  Нас теперь ждет маленькая приятная вещь.
[01:20:33.460 --> 01:20:35.460]  То есть теперь DFS будет звучать так.
[01:20:35.460 --> 01:20:37.460]  Он будет у нас в У.
[01:20:37.460 --> 01:20:42.460]  И этот DFS будет говорить, верно ли, что удалось найти удлинающую цель, да или нет?
[01:20:42.460 --> 01:20:46.460]  Удалось ли, вот, запустившись из вершины В левой доли,
[01:20:46.460 --> 01:20:48.460]  В лежит у нас в левой доле,
[01:20:48.460 --> 01:20:51.460]  дойти, да, вот, вершины правой доли?
[01:20:53.460 --> 01:20:56.460]  Если да, то вот да, если нет, нет.
[01:20:56.460 --> 01:20:59.460]  Ну, то есть DFS будет устроен очень просто.
[01:20:59.460 --> 01:21:01.460]  Ну, во-первых, начнем с...
[01:21:01.460 --> 01:21:05.460]  В данном случае оказывается целесообразно именно в этом месте проверять.
[01:21:05.460 --> 01:21:07.460]  То есть, там юзит, давай.
[01:21:07.460 --> 01:21:11.460]  То есть если юзит от В, то ну...
[01:21:13.460 --> 01:21:15.460]  Соответственно...
[01:21:16.460 --> 01:21:18.460]  Ретерпост.
[01:21:19.460 --> 01:21:21.460]  Ну, а дальше тут, соответственно, форм.
[01:21:21.460 --> 01:21:23.460]  Ну, тут вообще все просто.
[01:21:23.460 --> 01:21:27.460]  Значит, пинт у гр от В.
[01:21:28.460 --> 01:21:31.460]  Значит, пишем мы, если...
[01:21:32.460 --> 01:21:35.460]  И вот здесь можно вообще красоту написать.
[01:21:35.460 --> 01:21:37.460]  Если, смотрите,
[01:21:37.460 --> 01:21:42.460]  pr от U равно минус 1,
[01:21:42.460 --> 01:21:44.460]  то есть если напарника нет,
[01:21:44.460 --> 01:21:48.460]  или напарник есть,
[01:21:48.460 --> 01:21:53.460]  но DFS из него оказался неожиданно трушным,
[01:21:55.460 --> 01:21:57.460]  то return true.
[01:21:57.460 --> 01:21:59.460]  Нет, не так.
[01:21:59.460 --> 01:22:01.460]  Вот так. Return true.
[01:22:06.460 --> 01:22:08.460]  А.
[01:22:08.460 --> 01:22:10.460]  Спокойно.
[01:22:10.460 --> 01:22:11.460]  Что значит юзит?
[01:22:11.460 --> 01:22:13.460]  Юзит это значит мы посетили в основном цикле.
[01:22:13.460 --> 01:22:15.460]  Нет, юзит это означает,
[01:22:15.460 --> 01:22:19.460]  что мы его посетили или не посетили в DFS.
[01:22:19.460 --> 01:22:22.460]  А почему тогда мы его посетили в DFS?
[01:22:22.460 --> 01:22:24.460]  Это означает, что мы в этой вершине уже были,
[01:22:24.460 --> 01:22:27.460]  то есть типа туда не входим.
[01:22:28.460 --> 01:22:31.460]  А, тогда как мы будем находить
[01:22:31.460 --> 01:22:33.460]  увеличившийся поток,
[01:22:33.460 --> 01:22:35.460]  если мы вот пойдем в вершину,
[01:22:35.460 --> 01:22:38.460]  и если у нее уже есть ребро,
[01:22:38.460 --> 01:22:40.460]  значит мы ее посещали.
[01:22:40.460 --> 01:22:42.460]  В смысле?
[01:22:42.460 --> 01:22:44.460]  Ну нет, если мы ее только что...
[01:22:44.460 --> 01:22:46.460]  Нет, погодите, не понял.
[01:22:46.460 --> 01:22:48.460]  Ну как бы это означает,
[01:22:48.460 --> 01:22:50.460]  что если мы вот пришли в эту вершину по этому ребру,
[01:22:50.460 --> 01:22:52.460]  то да, если сейчас пойдет DFS по этому ребру,
[01:22:52.460 --> 01:22:54.460]  то он нам тут вернет false.
[01:22:54.460 --> 01:22:56.460]  Один раз, но не второй.
[01:22:56.460 --> 01:22:58.460]  А, то есть у нас перед каждым запуском
[01:22:58.460 --> 01:23:00.460]  у нас очищается?
[01:23:00.460 --> 01:23:02.460]  Да, ну не так.
[01:23:02.460 --> 01:23:04.460]  У нас, мне кажется, немножко неправильно написано.
[01:23:04.460 --> 01:23:06.460]  Правильно написано.
[01:23:06.460 --> 01:23:08.460]  У нас же DFS в РСКВ
[01:23:08.460 --> 01:23:10.460]  только из левой доли обязательно.
[01:23:10.460 --> 01:23:12.460]  Да.
[01:23:12.460 --> 01:23:14.460]  А почему это DFS от УМА,
[01:23:14.460 --> 01:23:16.460]  а DFS от ПРАТУ?
[01:23:16.460 --> 01:23:18.460]  А, в этом плане, да.
[01:23:18.460 --> 01:23:20.460]  А еще мы нигде не присваиваем
[01:23:20.460 --> 01:23:22.460]  новое значение ПРАТУ.
[01:23:22.460 --> 01:23:24.460]  Ну да, пока у нас была цель DFS просто
[01:23:24.460 --> 01:23:27.460]  найти существующую любвеющую цель, да или нет.
[01:23:27.460 --> 01:23:29.460]  Ну да, да, да.
[01:23:29.460 --> 01:23:31.460]  Ой-ой-ой-ой.
[01:23:31.460 --> 01:23:33.460]  Как сложно.
[01:23:33.460 --> 01:23:35.460]  Да.
[01:23:35.460 --> 01:23:37.460]  UZIT от V равно true, да, совершенно верно.
[01:23:39.460 --> 01:23:41.460]  Как давно я пыльчика-то
[01:23:41.460 --> 01:23:43.460]  не писал, оказывается.
[01:23:43.460 --> 01:23:45.460]  Так.
[01:23:45.460 --> 01:23:47.460]  Просто такой написано, что у Гаррина сидишь
[01:23:47.460 --> 01:23:49.460]  и не понимаешь, что там чего не хватает.
[01:23:49.460 --> 01:23:51.460]  А там какая-нибудь UZIT не хватает.
[01:23:51.460 --> 01:23:53.460]  Это, это, это.
[01:23:53.460 --> 01:23:55.460]  И вообще, у Гаррито не хватает.
[01:23:55.460 --> 01:23:57.460]  Ну и нет, еще не хватает, как минимум,
[01:23:57.460 --> 01:23:59.460]  что в конце надо Гарриторию полнуть.
[01:23:59.460 --> 01:24:01.460]  А что сделать, если мы берем
[01:24:01.460 --> 01:24:03.460]  доставку экзамена алгоритма,
[01:24:03.460 --> 01:24:05.460]  который ни разу из них не писали?
[01:24:05.460 --> 01:24:07.460]  Как будто такого в семестре не было.
[01:24:07.460 --> 01:24:09.460]  В каком семестре?
[01:24:09.460 --> 01:24:11.460]  Нет, в третьем семестре экзамена
[01:24:11.460 --> 01:24:13.460]  чечебалась.
[01:24:13.460 --> 01:24:15.460]  Вот у нас основной цикл
[01:24:15.460 --> 01:24:17.460]  по всем вершинам.
[01:24:17.460 --> 01:24:19.460]  В каждой террасе
[01:24:19.460 --> 01:24:21.460]  этого цикла мы очищаем
[01:24:21.460 --> 01:24:23.460]  UZIT.
[01:24:23.460 --> 01:24:25.460]  Где мы очищаем UZIT?
[01:24:25.460 --> 01:24:27.460]  Ну как, но там
[01:24:27.460 --> 01:24:29.460]  аккуратненько, сейчас вот увидите.
[01:24:29.460 --> 01:24:31.460]  Еще раз, DFS нам
[01:24:31.460 --> 01:24:33.460]  говорит, что?
[01:24:33.460 --> 01:24:35.460]  Удалось ли нам найти удлинающую цепь?
[01:24:35.460 --> 01:24:37.460]  Или дойти до правой вершины,
[01:24:37.460 --> 01:24:39.460]  у которой нет на парке?
[01:24:39.460 --> 01:24:41.460]  А мы давали еще раз
[01:24:41.460 --> 01:24:43.460]  формальное определение этих
[01:24:43.460 --> 01:24:45.460]  удлинающих цепей или нет?
[01:24:45.460 --> 01:24:47.460]  Просто
[01:24:47.460 --> 01:24:49.460]  пути достаточно сцепить.
[01:24:49.460 --> 01:24:51.460]  Только сцепить у нас виртуальная такая.
[01:24:51.460 --> 01:24:53.460]  Ну формально
[01:24:53.460 --> 01:24:55.460]  остаточная,
[01:24:55.460 --> 01:24:57.460]  это путь.
[01:24:57.460 --> 01:24:59.460]  То есть это путь от вершины левой доли
[01:24:59.460 --> 01:25:01.460]  в вершину правой доли,
[01:25:01.460 --> 01:25:03.460]  где мы слева направо идем по ребрам не из пресочетания,
[01:25:03.460 --> 01:25:05.460]  а справа налево идем по ребрам
[01:25:05.460 --> 01:25:07.460]  из пресочетания.
[01:25:07.460 --> 01:25:09.460]  Так что если совсем формально,
[01:25:09.460 --> 01:25:11.460]  то вот это так.
[01:25:11.460 --> 01:25:13.460]  Это удлинающая цепь?
[01:25:13.460 --> 01:25:15.460]  Да.
[01:25:15.460 --> 01:25:17.460]  Когда мы запустим внутреннюю цепь,
[01:25:17.460 --> 01:25:19.460]  она сразу выйдет, потому что
[01:25:19.460 --> 01:25:21.460]  это сочетание.
[01:25:21.460 --> 01:25:23.460]  Из-за юзера?
[01:25:23.460 --> 01:25:25.460]  Нет, вопрос как юзер.
[01:25:25.460 --> 01:25:27.460]  Я бы сказал так, что как только мы нашли удлинающую цепь,
[01:25:27.460 --> 01:25:29.460]  тогда юзер очищаем
[01:25:29.460 --> 01:25:31.460]  и запускаем ДФС сзади.
[01:25:35.460 --> 01:25:37.460]  На уровне идей.
[01:25:37.460 --> 01:25:39.460]  То есть как бы
[01:25:39.460 --> 01:25:41.460]  будет кун
[01:25:41.460 --> 01:25:43.460]  будет работать примерно так.
[01:25:43.460 --> 01:25:45.460]  Вот давайте я тут пример напишу.
[01:25:45.460 --> 01:25:47.460]  Он будет работать так.
[01:25:49.460 --> 01:25:51.460]  Ну допустим там
[01:25:51.460 --> 01:25:53.460]  пишем
[01:25:53.460 --> 01:25:55.460]  пора точка
[01:25:55.460 --> 01:25:57.460]  assign
[01:25:57.460 --> 01:25:59.460]  соответственно
[01:25:59.460 --> 01:26:01.460]  модуль r
[01:26:01.460 --> 01:26:03.460]  минус один изначально.
[01:26:07.460 --> 01:26:09.460]  Значит bo
[01:26:09.460 --> 01:26:11.460]  допустим
[01:26:11.460 --> 01:26:13.460]  из ok
[01:26:13.460 --> 01:26:15.460]  равно true.
[01:26:15.460 --> 01:26:17.460]  И дальше
[01:26:17.460 --> 01:26:19.460]  говорим что
[01:26:19.460 --> 01:26:21.460]  while из ok
[01:26:21.460 --> 01:26:23.460]  говорим так
[01:26:23.460 --> 01:26:25.460]  из ok равно false.
[01:26:25.460 --> 01:26:27.460]  То есть из ok будет символизировать то
[01:26:27.460 --> 01:26:29.460]  верно ли что в эту итерацию удлинающая цепь
[01:26:29.460 --> 01:26:31.460]  нашлась.
[01:26:31.460 --> 01:26:33.460]  Дальше говорим
[01:26:33.460 --> 01:26:35.460]  use it
[01:26:35.460 --> 01:26:37.460]  точка assign
[01:26:39.460 --> 01:26:41.460]  как всегда на
[01:26:41.460 --> 01:26:43.460]  модуль l
[01:26:43.460 --> 01:26:45.460]  соответственно 0.
[01:26:49.460 --> 01:26:51.460]  Дальше мы говорим
[01:26:51.460 --> 01:26:53.460]  значит перебираем
[01:26:53.460 --> 01:26:55.460]  все вершины в левой доле.
[01:26:57.460 --> 01:26:59.460]  Я вот так немножко
[01:26:59.460 --> 01:27:01.460]  и формально напишу.
[01:27:01.460 --> 01:27:03.460]  Перебираем все вершины в левой доле.
[01:27:03.460 --> 01:27:05.460]  Это можно без модуля
[01:27:05.460 --> 01:27:07.460]  или как можете воспринимать.
[01:27:07.460 --> 01:27:09.460]  Да да?
[01:27:09.460 --> 01:27:11.460]  И говорим
[01:27:11.460 --> 01:27:13.460]  если
[01:27:15.460 --> 01:27:17.460]  вот сейчас будет черная
[01:27:17.460 --> 01:27:19.460]  баня, которую мы пока
[01:27:19.460 --> 01:27:21.460]  не будем понимать как делать.
[01:27:21.460 --> 01:27:23.460]  If that
[01:27:23.460 --> 01:27:25.460]  is not
[01:27:25.460 --> 01:27:27.460]  covered
[01:27:29.460 --> 01:27:31.460]  by matching
[01:27:31.460 --> 01:27:33.460]  то мы говорим
[01:27:33.460 --> 01:27:35.460]  и теперь говорим неожиданно.
[01:27:35.460 --> 01:27:37.460]  Если dfs
[01:27:37.460 --> 01:27:39.460]  от v
[01:27:41.460 --> 01:27:43.460]  то соответственно
[01:27:43.460 --> 01:27:45.460]  из ok равно true
[01:27:45.460 --> 01:27:47.460]  и бряк.
[01:27:51.460 --> 01:27:53.460]  То есть
[01:27:53.460 --> 01:27:55.460]  из ok равно true
[01:27:55.460 --> 01:27:57.460]  и бряк.
[01:27:57.460 --> 01:27:59.460]  И бряк.
[01:28:05.460 --> 01:28:07.460]  Все.
[01:28:21.460 --> 01:28:23.460]  Первое что тут может возникнуть
[01:28:23.460 --> 01:28:25.460]  это если
[01:28:25.460 --> 01:28:27.460]  да кто скажет
[01:28:27.460 --> 01:28:29.460]  а если тут это
[01:28:29.460 --> 01:28:31.460]  не надо ли тут проверить что вершину v
[01:28:31.460 --> 01:28:33.460]  не покрыта?
[01:28:33.460 --> 01:28:35.460]  Нет.
[01:28:35.460 --> 01:28:37.460]  Но тут две причины.
[01:28:37.460 --> 01:28:39.460]  Мало того что если что то dfs выбросится сразу
[01:28:39.460 --> 01:28:41.460]  а во вторых заметим что
[01:28:41.460 --> 01:28:43.460]  если вершина покрыта
[01:28:43.460 --> 01:28:45.460]  а во вторых заметим что если
[01:28:45.460 --> 01:28:47.460]  вершина не покрыта про сочетание
[01:28:47.460 --> 01:28:49.460]  то мы в нее как отсюда
[01:28:49.460 --> 01:28:51.460]  попасть не можем в принципе.
[01:28:51.460 --> 01:28:53.460]  Поэтому достаточно
[01:28:53.460 --> 01:28:55.460]  проверить что v не покрыт
[01:28:55.460 --> 01:28:57.460]  про сочетание.
[01:28:57.460 --> 01:28:59.460]  То есть это мы пока
[01:28:59.460 --> 01:29:01.460]  подразумеваем что это
[01:29:01.460 --> 01:29:03.460]  черная мания. Мысленно мы думаем
[01:29:03.460 --> 01:29:05.460]  что можно поддерживать
[01:29:05.460 --> 01:29:07.460]  не только p-r
[01:29:07.460 --> 01:29:09.460]  можно p-r наоборот
[01:29:09.460 --> 01:29:11.460]  поддерживать в явном виде.
[01:29:11.460 --> 01:29:13.460]  Но правда
[01:29:13.460 --> 01:29:15.460]  есть маленькая проблема.
[01:29:15.460 --> 01:29:17.460]  Выглядит это так, но теперь мы
[01:29:17.460 --> 01:29:19.460]  скажем вопрос а кто будет
[01:29:19.460 --> 01:29:21.460]  улучшить цепь и улучшать про сочетание?
[01:29:21.460 --> 01:29:23.460]  Нет.
[01:29:23.460 --> 01:29:25.460]  Но оказывается ничего умного тут делать
[01:29:25.460 --> 01:29:27.460]  не надо, потому что все что вам в этом месте нужно
[01:29:27.460 --> 01:29:29.460]  это сказать что
[01:29:29.460 --> 01:29:31.460]  p-r от u равно
[01:29:31.460 --> 01:29:33.460]  v. Все.
[01:29:37.460 --> 01:29:39.460]  Вот прям в этом месте.
[01:29:39.460 --> 01:29:41.460]  То есть обратите внимание. То есть как только вы
[01:29:41.460 --> 01:29:43.460]  делаете вот эту вот удлиняющую цепь
[01:29:43.460 --> 01:29:45.460]  то она у вас прям
[01:29:45.460 --> 01:29:47.460]  обрадуется и прям так и начнет.
[01:29:47.460 --> 01:29:49.460]  То есть скажет что
[01:29:49.460 --> 01:29:51.460]  у этой вершины теперь вот такой напахник
[01:29:51.460 --> 01:29:53.460]  у этой вот такой, у этой вот такой, у этой вот такой
[01:29:53.460 --> 01:29:55.460]  такой ура.
[01:29:55.460 --> 01:29:57.460]  То есть окажется что
[01:29:57.460 --> 01:29:59.460]  у вас удлиняющая цепь просто встает
[01:29:59.460 --> 01:30:01.460]  и вы тут
[01:30:01.460 --> 01:30:03.460]  и вы вот так вот поскачете.
[01:30:03.460 --> 01:30:05.460]  Все.
[01:30:05.460 --> 01:30:07.460]  А сколько раз может
[01:30:07.460 --> 01:30:09.460]  цикл вайл проработать?
[01:30:09.460 --> 01:30:11.460]  А сколько он может проработать?
[01:30:11.460 --> 01:30:13.460]  Заметим что каждая цикл вайл это по сути
[01:30:13.460 --> 01:30:15.460]  4,5.
[01:30:15.460 --> 01:30:17.460]  А сколько же?
[01:30:17.460 --> 01:30:19.460]  Нет, на самом деле обратите внимание.
[01:30:19.460 --> 01:30:21.460]  Больше чем один поток.
[01:30:21.460 --> 01:30:23.460]  Больше чем один.
[01:30:23.460 --> 01:30:25.460]  Ровно один.
[01:30:25.460 --> 01:30:27.460]  Как только нашли хоть один, брякнулись.
[01:30:27.460 --> 01:30:29.460]  Вы брякнулись, прям бряк-брякнулись?
[01:30:29.460 --> 01:30:31.460]  Прямо брякнуть.
[01:30:31.460 --> 01:30:33.460]  Ну смотри.
[01:30:33.460 --> 01:30:35.460]  А, ну да. Зачем?
[01:30:37.460 --> 01:30:39.460]  Уберите брейк, будет быстрее работать.
[01:30:41.460 --> 01:30:43.460]  Ну хорошо.
[01:30:43.460 --> 01:30:45.460]  Ну можно и так.
[01:30:45.460 --> 01:30:47.460]  Пока мы оставим бряк,
[01:30:47.460 --> 01:30:49.460]  то я убеждаю, что то, что мы тут написали,
[01:30:49.460 --> 01:30:51.460]  это просто такая
[01:30:51.460 --> 01:30:53.460]  сильно модифицированная
[01:30:53.460 --> 01:30:55.460]  и просто перевернутая
[01:30:55.460 --> 01:30:57.460]  реализация форта.
[01:30:57.460 --> 01:30:59.460]  Прямо идентично.
[01:30:59.460 --> 01:31:01.460]  То есть форт тут единственное берется из-за того,
[01:31:01.460 --> 01:31:03.460]  что был бы и сток, и сток,
[01:31:03.460 --> 01:31:05.460]  это был бы просто идентично запуску ДФС
[01:31:05.460 --> 01:31:07.460]  из-за стока.
[01:31:07.460 --> 01:31:09.460]  Понимаете, да?
[01:31:09.460 --> 01:31:11.460]  Вот.
[01:31:11.460 --> 01:31:13.460]  Да, оно работает то же самое.
[01:31:13.460 --> 01:31:15.460]  Да, может быть, локальная оптимизация, конечно,
[01:31:15.460 --> 01:31:17.460]  бряк действительно не обязательно.
[01:31:17.460 --> 01:31:19.460]  Можно и без него обойтись.
[01:31:19.460 --> 01:31:21.460]  Хотя...
[01:31:21.460 --> 01:31:23.460]  Честно, быстрее будет.
[01:31:23.460 --> 01:31:25.460]  Может быть, быстрее.
[01:31:25.460 --> 01:31:27.460]  Хотя, ну да.
[01:31:27.460 --> 01:31:29.460]  Может, даже юзер имеет смысл защитить, конечно.
[01:31:29.460 --> 01:31:31.460]  Нет, вот здесь не имеет.
[01:31:31.460 --> 01:31:33.460]  Ну да, может.
[01:31:33.460 --> 01:31:35.460]  Но не важно.
[01:31:35.460 --> 01:31:37.460]  Ну не совсем так.
[01:31:37.460 --> 01:31:39.460]  Но на самом деле это еще не классический форт.
[01:31:39.460 --> 01:31:41.460]  На самом деле, то есть это еще такой,
[01:31:41.460 --> 01:31:43.460]  это псевдокун.
[01:31:43.460 --> 01:31:45.460]  На самом деле,
[01:31:45.460 --> 01:31:47.460]  совсем кун это делает
[01:31:47.460 --> 01:31:49.460]  другие образы.
[01:31:51.460 --> 01:31:53.460]  На самом деле,
[01:31:53.460 --> 01:31:55.460]  совсем кун это делает образы.
[01:32:09.460 --> 01:32:11.460]  Он тупо перебирает все вершины.
[01:32:15.460 --> 01:32:17.460]  И из каждой из них запускает ДФС.
[01:32:19.460 --> 01:32:21.460]  То есть, примерно так.
[01:32:21.460 --> 01:32:23.460]  Можно и...
[01:32:23.460 --> 01:32:25.460]  То есть, такой классический кун можно замылить вот так.
[01:32:39.460 --> 01:32:41.460]  Бугага.
[01:32:47.460 --> 01:32:49.460]  Правда, то, что он работает, в отличие от всего предыдущего,
[01:32:49.460 --> 01:32:51.460]  реально надо доказывать.
[01:32:51.460 --> 01:32:53.460]  Ну, в каком смысле реально надо доказывать?
[01:32:53.460 --> 01:32:55.460]  Потому что все предыдущее,
[01:32:55.460 --> 01:32:57.460]  валидность всего остального,
[01:32:57.460 --> 01:32:59.460]  это просто следовало из валидности форта Фолкерсона.
[01:32:59.460 --> 01:33:01.460]  Правда?
[01:33:01.460 --> 01:33:03.460]  То есть, обратите внимание, мы, по сути, ничего не доказывали.
[01:33:03.460 --> 01:33:05.460]  То есть, мы сказали, что у нас уже есть форт Фолкерсона,
[01:33:05.460 --> 01:33:07.460]  и из него, собственно, все это автоматически следует.
[01:33:07.460 --> 01:33:09.460]  А вот здесь непонятно.
[01:33:11.460 --> 01:33:13.460]  По крайней мере, на первый взгляд.
[01:33:13.460 --> 01:33:15.460]  Потому что здесь утверждается следующее.
[01:33:15.460 --> 01:33:17.460]  Почему-то утверждается,
[01:33:17.460 --> 01:33:19.460]  что из каждой вершины
[01:33:19.460 --> 01:33:21.460]  имеет смысл запускать ДФС только один раз.
[01:33:23.460 --> 01:33:25.460]  Казалось бы, почему?
[01:33:25.460 --> 01:33:27.460]  Но на самом деле,
[01:33:27.460 --> 01:33:29.460]  это следует опять же
[01:33:29.460 --> 01:33:31.460]  из более общей теории.
[01:33:31.460 --> 01:33:33.460]  Которая будет гласить следующее.
[01:33:33.460 --> 01:33:35.460]  Если...
[01:33:35.460 --> 01:33:37.460]  Вот, предположим, что мы запускаем
[01:33:37.460 --> 01:33:39.460]  метод Фольда Фолкерсона.
[01:33:39.460 --> 01:33:41.460]  Вот сейчас будет мистическая теорема.
[01:33:41.460 --> 01:33:43.460]  Даже не просочетательная.
[01:33:45.460 --> 01:33:47.460]  Предположим, что у нас есть
[01:33:47.460 --> 01:33:49.460]  то есть теорема.
[01:33:49.460 --> 01:33:51.460]  Пусть мы
[01:33:51.460 --> 01:33:53.460]  ищем
[01:33:55.460 --> 01:33:57.460]  в сети
[01:33:57.460 --> 01:33:59.460]  G
[01:33:59.460 --> 01:34:01.460]  поток методом
[01:34:01.460 --> 01:34:03.460]  Фольда Фолкерсона.
[01:34:05.460 --> 01:34:07.460]  Ну тут даже наплевать.
[01:34:07.460 --> 01:34:09.460]  ДФС мы-то ищем путь или нет.
[01:34:09.460 --> 01:34:11.460]  ДФС мы-то неважно.
[01:34:11.460 --> 01:34:13.460]  Просто методом Фольда Фолкерсона.
[01:34:15.460 --> 01:34:17.460]  Пусть
[01:34:17.460 --> 01:34:19.460]  в какой-то момент
[01:34:21.460 --> 01:34:23.460]  времени
[01:34:27.460 --> 01:34:29.460]  времени
[01:34:29.460 --> 01:34:31.460]  из
[01:34:31.460 --> 01:34:33.460]  некоторой
[01:34:35.460 --> 01:34:37.460]  вершины
[01:34:37.460 --> 01:34:39.460]  В
[01:34:41.460 --> 01:34:43.460]  нельзя
[01:34:47.460 --> 01:34:49.460]  дойти
[01:34:51.460 --> 01:34:53.460]  до стока
[01:34:53.460 --> 01:34:55.460]  Т
[01:34:55.460 --> 01:34:57.460]  по ненасыщенным ребрам.
[01:34:57.460 --> 01:34:59.460]  Ненасыщенным ребрам в остаточной сети разувереться.
[01:35:13.460 --> 01:35:15.460]  Тогда, утверждаю я
[01:35:17.460 --> 01:35:19.460]  никогда позже
[01:35:19.460 --> 01:35:21.460]  с соответствующего пути
[01:35:21.460 --> 01:35:23.460]  и не появится.
[01:35:49.460 --> 01:35:51.460]  Вот.
[01:35:51.460 --> 01:35:53.460]  Мистическая терема верна
[01:35:53.460 --> 01:35:55.460]  не только для просочетаний,
[01:35:55.460 --> 01:35:57.460]  а вообще для любых
[01:35:57.460 --> 01:35:59.460]  остаточных сетей.
[01:35:59.460 --> 01:36:01.460]  То есть казалось бы,
[01:36:01.460 --> 01:36:03.460]  вроде как реображь там появляется,
[01:36:03.460 --> 01:36:05.460]  исчезает в процессе, мало ли там
[01:36:05.460 --> 01:36:07.460]  какие-то пути исчезают, какие-то появляются.
[01:36:07.460 --> 01:36:09.460]  Но оказывается, что если пути
[01:36:09.460 --> 01:36:11.460]  от В до Т в какой-то момент не было,
[01:36:11.460 --> 01:36:13.460]  то есть если сейчас от В до Т
[01:36:13.460 --> 01:36:15.460]  пути нет, то в будущем
[01:36:15.460 --> 01:36:17.460]  его и не появится никогда.
[01:36:19.460 --> 01:36:21.460]  Вот такая идея.
[01:36:23.460 --> 01:36:25.460]  Такой приятный, интересный факт.
[01:36:27.460 --> 01:36:29.460]  Откуда же этот факт берется?
[01:36:29.460 --> 01:36:31.460]  А вот откуда.
[01:36:31.460 --> 01:36:33.460]  Вот предположим,
[01:36:33.460 --> 01:36:35.460]  что чудо произошло,
[01:36:35.460 --> 01:36:37.460]  что вот пути не было,
[01:36:37.460 --> 01:36:39.460]  не было, не было, не было,
[01:36:39.460 --> 01:36:41.460]  а потом в какой-то момент бабазый появился.
[01:36:45.460 --> 01:36:47.460]  Ну и действительно, у нас же не просто так,
[01:36:47.460 --> 01:36:49.460]  то есть не из воздуха берутся.
[01:36:49.460 --> 01:36:51.460]  То есть у нас, что такой метод Форда Пулкерсона?
[01:36:51.460 --> 01:36:53.460]  Мы находим пути
[01:36:53.460 --> 01:36:55.460]  в Т, пропускаем по нему потом.
[01:36:55.460 --> 01:36:57.460]  Какие-то ребра появляются,
[01:36:57.460 --> 01:36:59.460]  какие-то исчезают.
[01:37:01.460 --> 01:37:03.460]  И вот давайте себе представим, что после
[01:37:03.460 --> 01:37:05.460]  пропуска только что пути не было
[01:37:05.460 --> 01:37:07.460]  из ВТ,
[01:37:07.460 --> 01:37:09.460]  а потом вы пропихнули поток
[01:37:09.460 --> 01:37:11.460]  где-то там в сети, и путь появился.
[01:37:13.460 --> 01:37:15.460]  Как такое может быть?
[01:37:15.460 --> 01:37:17.460]  Повелся обратная любовь.
[01:37:17.460 --> 01:37:19.460]  И не только.
[01:37:19.460 --> 01:37:21.460]  Давайте рассмотрим этот путь.
[01:37:23.460 --> 01:37:25.460]  Или прямое восстановление?
[01:37:25.460 --> 01:37:27.460]  Да, но это даже не важно.
[01:37:29.460 --> 01:37:31.460]  То есть рассмотрим вот этот свежепоявившийся путь
[01:37:31.460 --> 01:37:33.460]  от В до Т.
[01:37:37.460 --> 01:37:39.460]  Как мы вынуждены заключить,
[01:37:39.460 --> 01:37:41.460]  какие-то из этих ребер
[01:37:41.460 --> 01:37:43.460]  появились только что?
[01:37:45.460 --> 01:37:47.460]  Есть такой, да?
[01:37:49.460 --> 01:37:51.460]  Какие-то были
[01:37:51.460 --> 01:37:53.460]  и перед этим пропуском,
[01:37:53.460 --> 01:37:55.460]  а какие-то появились только что.
[01:37:55.460 --> 01:37:57.460]  Ну, давайте рассмотрим.
[01:37:57.460 --> 01:37:59.460]  Вот этот путь, вот это ребро,
[01:37:59.460 --> 01:38:01.460]  там допустим вот это.
[01:38:03.460 --> 01:38:05.460]  Ну, я не знаю.
[01:38:07.460 --> 01:38:09.460]  Ну и вот это.
[01:38:09.460 --> 01:38:11.460]  Ну и не хочу совсем
[01:38:11.460 --> 01:38:13.460]  прям быть последней.
[01:38:15.460 --> 01:38:17.460]  Понимаешь, что это значит?
[01:38:17.460 --> 01:38:19.460]  Это значит,
[01:38:19.460 --> 01:38:21.460]  что у нас были
[01:38:21.460 --> 01:38:23.460]  как выглядел вот этот вот
[01:38:23.460 --> 01:38:25.460]  мистический путь от С до Т.
[01:38:27.460 --> 01:38:29.460]  Ну, он как-то, как-то выглядел.
[01:38:29.460 --> 01:38:31.460]  Значит, он тут ходил, ходил,
[01:38:31.460 --> 01:38:33.460]  ходил, ходил.
[01:38:33.460 --> 01:38:35.460]  Но в какой-то момент прошел через вот это ребро.
[01:38:35.460 --> 01:38:37.460]  Логично, да?
[01:38:37.460 --> 01:38:39.460]  Потом еще тут что-то ходил,
[01:38:39.460 --> 01:38:41.460]  ходил, ходил, ходил, ходил
[01:38:41.460 --> 01:38:43.460]  и прошел там, скажем,
[01:38:43.460 --> 01:38:45.460]  через вот это, через вот это ребро.
[01:38:45.460 --> 01:38:47.460]  Да, в каком порядке он их посетил,
[01:38:47.460 --> 01:38:49.460]  мы не знаем.
[01:38:49.460 --> 01:38:51.460]  Потом еще тут.
[01:38:53.460 --> 01:38:55.460]  Потом прошел вот как-то так
[01:38:55.460 --> 01:38:57.460]  и...
[01:38:57.460 --> 01:38:59.460]  и пришел в Т.
[01:39:01.460 --> 01:39:03.460]  Вот там еще он мог там по вершинам ходить
[01:39:03.460 --> 01:39:05.460]  и так далее, да?
[01:39:05.460 --> 01:39:07.460]  Ну, тогда смотрите, вот какая ситуация.
[01:39:07.460 --> 01:39:09.460]  Рассмотрим последний,
[01:39:09.460 --> 01:39:11.460]  вот на этом пути с ВТ,
[01:39:11.460 --> 01:39:13.460]  рассмотрим вот последнее такое голубое ребро.
[01:39:13.460 --> 01:39:15.460]  Последнее с точки зрения пути
[01:39:15.460 --> 01:39:17.460]  от В до Т, конечно.
[01:39:17.460 --> 01:39:19.460]  Ну, потому что это опять одно из тех доказательств,
[01:39:19.460 --> 01:39:21.460]  где, как бы, давайте будем высказывать мысль
[01:39:21.460 --> 01:39:23.460]  о бы как и в результате будет там
[01:39:23.460 --> 01:39:25.460]  можно будет нарываться на всякие там предные
[01:39:25.460 --> 01:39:27.460]  формальные вопросы.
[01:39:27.460 --> 01:39:29.460]  Итак, вот, то есть рассмотрим вот все эти ребра,
[01:39:29.460 --> 01:39:31.460]  которые появились, только что рассмотрим последнее.
[01:39:31.460 --> 01:39:33.460]  Последнее на пути из ВТ?
[01:39:33.460 --> 01:39:35.460]  Да.
[01:39:35.460 --> 01:39:37.460]  Тогда я утверждаю...
[01:39:39.460 --> 01:39:41.460]  А, хотя нет, даже не последнее,
[01:39:41.460 --> 01:39:43.460]  наоборот, первое.
[01:39:43.460 --> 01:39:45.460]  Потому что нам что надо доказать?
[01:39:45.460 --> 01:39:47.460]  Нам надо доказать, что и перед пропуском
[01:39:47.460 --> 01:39:49.460]  потока по этому пути
[01:39:49.460 --> 01:39:51.460]  путь от В до Т будет.
[01:39:51.460 --> 01:39:53.460]  Как это доказать? Это очень просто.
[01:39:53.460 --> 01:39:55.460]  Идем по пути вот этому от В до Т
[01:39:55.460 --> 01:39:57.460]  до первого голубого ребра.
[01:39:57.460 --> 01:39:59.460]  До первого голубого ребра.
[01:40:01.460 --> 01:40:03.460]  А от этого голубого ребра вообще,
[01:40:03.460 --> 01:40:05.460]  от его конца, идем по вот этому
[01:40:05.460 --> 01:40:07.460]  голубому пути, который только что был,
[01:40:07.460 --> 01:40:09.460]  потому что мы по нему что-то пустили.
[01:40:09.460 --> 01:40:11.460]  Вот, пошли вот так вот.
[01:40:11.460 --> 01:40:13.460]  Следовательно, путь от В до Т и был.
[01:40:13.460 --> 01:40:15.460]  И перед пропуском по этому голубому пути.
[01:40:15.460 --> 01:40:17.460]  Доказательства окончены.
[01:40:21.460 --> 01:40:23.460]  То есть получается вот такой глобальный факт,
[01:40:23.460 --> 01:40:25.460]  что если от В до Т пути нет, то он и не появится.
[01:40:27.460 --> 01:40:29.460]  Идем до первого ряда и до его конца.
[01:40:31.460 --> 01:40:33.460]  А дальше по голубому.
[01:40:33.460 --> 01:40:35.460]  Вот. Ну аналогичным способом можно доказать,
[01:40:35.460 --> 01:40:37.460]  что если от С до В
[01:40:37.460 --> 01:40:39.460]  в какой-то момент пути нет, то он и не появится.
[01:40:39.460 --> 01:40:41.460]  Можно эти вершины сразу икногиривать.
[01:40:43.460 --> 01:40:45.460]  Ну почему-то это даже еще более очевидно.
[01:40:47.460 --> 01:40:49.460]  Так что вот есть такой вот, тоже из общей теории потоков,
[01:40:49.460 --> 01:40:51.460]  такой маленький приятный факт.
[01:40:51.460 --> 01:40:53.460]  Еще раз, секундочку.
[01:40:53.460 --> 01:40:55.460]  Значит, мы из С идем
[01:40:55.460 --> 01:40:57.460]  по пути, после которого у нас появились все ребра.
[01:40:59.460 --> 01:41:01.460]  Ну точнее так, рассмотрим путь от В до Т,
[01:41:01.460 --> 01:41:03.460]  который у нас неожиданно появился.
[01:41:03.460 --> 01:41:05.460]  Он появился после пропускания
[01:41:05.460 --> 01:41:07.460]  потока по пути из С в Т.
[01:41:07.460 --> 01:41:09.460]  Рассмотрим этот голубой путь.
[01:41:11.460 --> 01:41:13.460]  То есть так как
[01:41:13.460 --> 01:41:15.460]  перед пропусканием потока по этому голубому пути
[01:41:15.460 --> 01:41:17.460]  вот этого пути от В до Т
[01:41:17.460 --> 01:41:19.460]  не было,
[01:41:19.460 --> 01:41:21.460]  то значит тогда у нас на этом СТ
[01:41:21.460 --> 01:41:23.460]  есть некие голубые ребра, которые являются
[01:41:23.460 --> 01:41:25.460]  обратными к ребрам
[01:41:25.460 --> 01:41:27.460]  на пути от В до Т.
[01:41:29.460 --> 01:41:31.460]  Теперь я утверждаю, что
[01:41:31.460 --> 01:41:33.460]  перед пропусканием потока от С до Т
[01:41:35.460 --> 01:41:37.460]  по этому голубому пути
[01:41:37.460 --> 01:41:39.460]  путь от В до Т по ненасыщенным ребрам
[01:41:39.460 --> 01:41:41.460]  какой-то добыл.
[01:41:41.460 --> 01:41:43.460]  Что это за путь? Очень просто.
[01:41:43.460 --> 01:41:45.460]  Давайте идти по ребрам
[01:41:45.460 --> 01:41:47.460]  до первого ребра с голубым напарником.
[01:41:49.460 --> 01:41:51.460]  Точнее до его конца.
[01:41:51.460 --> 01:41:53.460]  Эти ребра были
[01:41:53.460 --> 01:41:55.460]  так как у них нет напарников,
[01:41:55.460 --> 01:41:57.460]  то эти ребра были и перед
[01:41:59.460 --> 01:42:01.460]  и перед запуском потока
[01:42:01.460 --> 01:42:03.460]  по голубому пути.
[01:42:07.460 --> 01:42:09.460]  И вот тогда
[01:42:09.460 --> 01:42:11.460]  давайте до сюда мы дошли,
[01:42:11.460 --> 01:42:13.460]  а из этой вершины до Т
[01:42:13.460 --> 01:42:15.460]  мы уже можем найти по остатку голубого пути.
[01:42:15.460 --> 01:42:17.460]  То есть следовать
[01:42:17.460 --> 01:42:19.460]  на от В до Т можно было
[01:42:19.460 --> 01:42:21.460]  по ненасыщенным ребрамам.
[01:42:27.460 --> 01:42:29.460]  Что касается просочетания,
[01:42:29.460 --> 01:42:31.460]  тогда эта интересная
[01:42:31.460 --> 01:42:33.460]  теория дает нам возможность
[01:42:33.460 --> 01:42:35.460]  в Куне не заворачиваться
[01:42:35.460 --> 01:42:37.460]  и просто запустить один раз
[01:42:37.460 --> 01:42:39.460]  ДФС из каждой вершины.
[01:42:41.460 --> 01:42:43.460]  Правда, в такой реализации Куна
[01:42:43.460 --> 01:42:45.460]  нет никаких проблем.
[01:42:49.460 --> 01:42:51.460]  Ну как хуже?
[01:42:51.460 --> 01:42:53.460]  В Э-то остается,
[01:42:53.460 --> 01:42:55.460]  но оценить это теперь
[01:42:55.460 --> 01:42:57.460]  как Е на максимальное просочетание
[01:42:57.460 --> 01:42:59.460]  вы уже не можете,
[01:42:59.460 --> 01:43:01.460]  потому что мы реально запускаем ДФС.
[01:43:07.460 --> 01:43:09.460]  Я утверждаю, что на самом деле
[01:43:09.460 --> 01:43:11.460]  можно достаточно легко
[01:43:11.460 --> 01:43:13.460]  запустить ДФС
[01:43:13.460 --> 01:43:15.460]  так, чтобы ассистентика
[01:43:15.460 --> 01:43:17.460]  с максимальным просочетанием
[01:43:17.460 --> 01:43:19.460]  состоять.
[01:43:23.460 --> 01:43:25.460]  Если не нашли,
[01:43:25.460 --> 01:43:27.460]  можно оставлять.
[01:43:27.460 --> 01:43:29.460]  Да, совершенно верно.
[01:43:29.460 --> 01:43:31.460]  Тут вот так напишем.
[01:43:37.460 --> 01:43:39.460]  Зачистим в начале
[01:43:41.460 --> 01:43:43.460]  вот там
[01:43:45.460 --> 01:43:47.460]  и дальше перебираем вершины
[01:43:51.460 --> 01:43:53.460]  и говорим, что если
[01:43:53.460 --> 01:43:55.460]  ДФС удался,
[01:43:57.460 --> 01:43:59.460]  то защищаем обратно.
[01:44:03.460 --> 01:44:05.460]  То есть действительно заметим,
[01:44:05.460 --> 01:44:07.460]  что если
[01:44:07.460 --> 01:44:09.460]  в случае неудачного ДФС
[01:44:09.460 --> 01:44:11.460]  граф не поменялся вообще.
[01:44:11.460 --> 01:44:13.460]  А раз граф не поменялся,
[01:44:13.460 --> 01:44:15.460]  то зачем старые пометки снимать?
[01:44:15.460 --> 01:44:17.460]  То есть если вершина помечена,
[01:44:17.460 --> 01:44:19.460]  значит вы из нее до вершины
[01:44:19.460 --> 01:44:21.460]  правой доли низ просочетания
[01:44:21.460 --> 01:44:23.460]  тупо не дойдете. Вы это уже знаете.
[01:44:23.460 --> 01:44:25.460]  Так зачем же их снимать? Давайте туда второй раз не ходить.
[01:44:25.460 --> 01:44:27.460]  И тогда серия подряд
[01:44:27.460 --> 01:44:29.460]  идущих ДФСов
[01:44:33.460 --> 01:44:35.460]  в таком случае
[01:44:35.460 --> 01:44:37.460]  будет работать за ОАД.
[01:44:39.460 --> 01:44:41.460]  То есть как только вы нашли,
[01:44:41.460 --> 01:44:43.460]  граф поменялся,
[01:44:43.460 --> 01:44:45.460]  придется делать защиту.
[01:44:47.460 --> 01:44:49.460]  Так что в результате
[01:44:49.460 --> 01:44:51.460]  все-таки
[01:44:55.460 --> 01:44:57.460]  размер максимального просочетания
[01:44:57.460 --> 01:44:59.460]  победить удалось.
[01:44:59.460 --> 01:45:01.460]  То есть алгоритм
[01:45:01.460 --> 01:45:03.460]  он хуже
[01:45:03.460 --> 01:45:05.460]  работает,
[01:45:05.460 --> 01:45:07.460]  чем
[01:45:07.460 --> 01:45:09.460]  Д9.
[01:45:09.460 --> 01:45:11.460]  Конечно.
[01:45:11.460 --> 01:45:13.460]  Конечно.
[01:45:13.460 --> 01:45:15.460]  Ну,
[01:45:15.460 --> 01:45:17.460]  в реальности там
[01:45:17.460 --> 01:45:19.460]  понятно,
[01:45:19.460 --> 01:45:21.460]  что он приятен тем,
[01:45:21.460 --> 01:45:23.460]  что он имеет, во-первых, очень крутую константу.
[01:45:25.460 --> 01:45:27.460]  Не говоря уже о той мелочи,
[01:45:27.460 --> 01:45:29.460]  тем более, что там очень хорошо работают
[01:45:29.460 --> 01:45:31.460]  всякие подхачки в духе.
[01:45:31.460 --> 01:45:33.460]  А давайте вместо
[01:45:33.460 --> 01:45:35.460]  вот перед этим фором
[01:45:35.460 --> 01:45:37.460]  попытаемся вставить фор, который будет
[01:45:37.460 --> 01:45:39.460]  проверять только вот этот.
[01:45:39.460 --> 01:45:41.460]  Ну, то есть сразу из вершины проверить.
[01:45:41.460 --> 01:45:43.460]  А нельзя ли прямо сейчас выиграть?
[01:45:47.460 --> 01:45:49.460]  Ну, или там бывает еще как-то
[01:45:49.460 --> 01:45:51.460]  оптимизировать в среднем раза в два.
[01:45:51.460 --> 01:45:53.460]  Найти просочетание
[01:45:53.460 --> 01:45:55.460]  какое-нибудь жадно.
[01:45:57.460 --> 01:45:59.460]  Вот представьте себе,
[01:45:59.460 --> 01:46:01.460]  что вы набираете просочетание два раза.
[01:46:01.460 --> 01:46:03.460]  Вот, просочетание жадно.
[01:46:03.460 --> 01:46:05.460]  То есть просто, по сути, берете ребро
[01:46:05.460 --> 01:46:07.460]  и говорите, так.
[01:46:07.460 --> 01:46:09.460]  Так, это ребро можно добавить в просочетание?
[01:46:09.460 --> 01:46:11.460]  Можно? О, берем. Это можно?
[01:46:11.460 --> 01:46:13.460]  Можно? О, берем. А это можно?
[01:46:13.460 --> 01:46:15.460]  Ой, оно со старым ребром просочетается. Не берем.
[01:46:15.460 --> 01:46:17.460]  Ну и так далее.
[01:46:17.460 --> 01:46:19.460]  А, это то есть с начальника брать?
[01:46:19.460 --> 01:46:21.460]  Да.
[01:46:21.460 --> 01:46:23.460]  Вот утверждение.
[01:46:23.460 --> 01:46:25.460]  Да, утверждение.
[01:46:25.460 --> 01:46:27.460]  И мы эту крылью от оптимального ответа
[01:46:27.460 --> 01:46:29.460]  мы таким образом наберем.
[01:46:29.460 --> 01:46:31.460]  Потому что у нас есть все требры
[01:46:31.460 --> 01:46:33.460]  оригинального самого же просочетания,
[01:46:33.460 --> 01:46:35.460]  каждая порция будет в двух.
[01:46:35.460 --> 01:46:37.460]  Да, именно.
[01:46:37.460 --> 01:46:39.460]  То есть давайте еще раз скажу
[01:46:39.460 --> 01:46:41.460]  то же самое. То есть берем такой жадно,
[01:46:41.460 --> 01:46:43.460]  да, то есть рассмотрим максимальное
[01:46:43.460 --> 01:46:45.460]  реальное просочетание. Вот, допустим.
[01:46:45.460 --> 01:46:47.460]  Вот пусть это реальное максимальное просочетание.
[01:46:47.460 --> 01:46:49.460]  Вот.
[01:46:49.460 --> 01:46:51.460]  Тогда
[01:46:51.460 --> 01:46:53.460]  заметим следующее.
[01:46:53.460 --> 01:46:55.460]  То есть это просочетание, если оно там
[01:46:55.460 --> 01:46:57.460]  размера вот f max,
[01:46:57.460 --> 01:46:59.460]  то заметим, что количество
[01:46:59.460 --> 01:47:01.460]  вершин в нем 2
[01:47:01.460 --> 01:47:03.460]  f max.
[01:47:05.460 --> 01:47:07.460]  Ну тогда если мы
[01:47:07.460 --> 01:47:09.460]  предположим, что мы
[01:47:09.460 --> 01:47:11.460]  просочетание набирали жадно
[01:47:11.460 --> 01:47:13.460]  и набрали
[01:47:13.460 --> 01:47:15.460]  какое-то вот просочетание
[01:47:15.460 --> 01:47:17.460]  вот какое-то, вот набирали, набирали
[01:47:17.460 --> 01:47:19.460]  там, я не знаю, набирали
[01:47:19.460 --> 01:47:21.460]  и набрали меньше, чем
[01:47:21.460 --> 01:47:23.460]  f max пополам.
[01:47:25.460 --> 01:47:27.460]  Тогда я утверждаю, что этими
[01:47:27.460 --> 01:47:29.460]  голубыми ребрами
[01:47:29.460 --> 01:47:31.460]  не покрыта ни одна из двух вершин
[01:47:31.460 --> 01:47:33.460]  хотя бы одного из ребра.
[01:47:35.460 --> 01:47:37.460]  Ну вот. Ну почему так?
[01:47:37.460 --> 01:47:39.460]  Ну просто потому, что если мы набрали меньше, чем
[01:47:39.460 --> 01:47:41.460]  стора,
[01:47:41.460 --> 01:47:43.460]  ну вот.
[01:47:43.460 --> 01:47:45.460]  Всего вершин меньше, чем f max.
[01:47:45.460 --> 01:47:47.460]  Ну да.
[01:47:47.460 --> 01:47:49.460]  Ну да, то всего тогда
[01:47:49.460 --> 01:47:51.460]  всего покрытые вершины не более, чем
[01:47:51.460 --> 01:47:53.460]  то есть строго меньше, чем
[01:47:55.460 --> 01:47:57.460]  f max.
[01:47:59.460 --> 01:48:01.460]  Ну вот, да. То есть оно, ну да.
[01:48:01.460 --> 01:48:03.460]  А всего их 2 f max. То есть там просто
[01:48:03.460 --> 01:48:05.460]  принцип телепия встает.
[01:48:05.460 --> 01:48:07.460]  Ну или просто ребр всего f max.
[01:48:07.460 --> 01:48:09.460]  Ну да, вот да, вот легче уже мыслить
[01:48:09.460 --> 01:48:11.460]  действительно в тех, что каждое голубое
[01:48:11.460 --> 01:48:13.460]  там, каждое голубое ребро
[01:48:13.460 --> 01:48:15.460]  портит не более, чем
[01:48:15.460 --> 01:48:17.460]  два ребра просочетания.
[01:48:17.460 --> 01:48:19.460]  Портит в смысле блокировать.
[01:48:19.460 --> 01:48:21.460]  Вот. И тогда получается,
[01:48:21.460 --> 01:48:23.460]  если будет меньше, чем...
[01:48:23.460 --> 01:48:25.460]  То есть получается, чтобы заблокировать их все.
[01:48:25.460 --> 01:48:27.460]  Но если кто-то не заблокирован, то будет
[01:48:27.460 --> 01:48:29.460]  возникать вопрос, когда мы его перебирали,
[01:48:29.460 --> 01:48:31.460]  что мы его не взяли.
[01:48:31.460 --> 01:48:33.460]  Так что вот оказывается, что
[01:48:33.460 --> 01:48:35.460]  если вы просто жадно набираете про все,
[01:48:35.460 --> 01:48:37.460]  вы уже полработы сделаете.
[01:48:37.460 --> 01:48:39.460]  Оптимизация, которая сначала проходит
[01:48:39.460 --> 01:48:41.460]  с циклом минус 1, потом с циклом f max,
[01:48:41.460 --> 01:48:43.460]  делает пробку та же самая.
[01:48:43.460 --> 01:48:45.460]  Или что более...
[01:48:45.460 --> 01:48:47.460]  Не-не-не, ну не совсем,
[01:48:47.460 --> 01:48:49.460]  она ж как бы...
[01:48:49.460 --> 01:48:51.460]  Не совсем, она ж там из каждой вершины
[01:48:51.460 --> 01:48:53.460]  начали висеть, напарника тупо не нашла.
[01:48:53.460 --> 01:48:55.460]  Она ж у каждой конкретной вершины напарника
[01:48:55.460 --> 01:48:57.460]  может не найти, тогда ж она реальный DFS
[01:48:57.460 --> 01:48:59.460]  начала выпускать.
[01:49:01.460 --> 01:49:03.460]  Это вообще сложнее показать, но она
[01:49:03.460 --> 01:49:05.460]  делает меня хуже, чем столько
[01:49:05.460 --> 01:49:07.460]  за первые Е действия.
[01:49:07.460 --> 01:49:09.460]  А что такое первые Е действия?
[01:49:09.460 --> 01:49:11.460]  Ну вот, за сколько мы это сделали все?
[01:49:11.460 --> 01:49:13.460]  Ну да, но это мы отдельно работали,
[01:49:13.460 --> 01:49:15.460]  DFS мы не запускали.
[01:49:15.460 --> 01:49:17.460]  Во, да.
[01:49:17.460 --> 01:49:19.460]  Но...
[01:49:21.460 --> 01:49:23.460]  Нет, можно конечно заметить,
[01:49:23.460 --> 01:49:25.460]  что потеряли Данилюка,
[01:49:25.460 --> 01:49:27.460]  и действительно первая фаза Диница тоже найдет
[01:49:27.460 --> 01:49:29.460]  хотя бы половину.
[01:49:29.460 --> 01:49:31.460]  О, потому что
[01:49:31.460 --> 01:49:33.460]  Губин разновал один.
[01:49:35.460 --> 01:49:37.460]  Вот так.
[01:49:37.460 --> 01:49:39.460]  Так что, в принципе, Динец
[01:49:39.460 --> 01:49:41.460]  за куда-то не знаю,
[01:49:41.460 --> 01:49:43.460]  но Динец это делает.
[01:49:43.460 --> 01:49:45.460]  А,
[01:49:45.460 --> 01:49:47.460]  а если учесть, что Динец
[01:49:47.460 --> 01:49:49.460]  на первой фазе ровно этот шаг
[01:49:49.460 --> 01:49:51.460]  и делает, что самое смешное.
[01:49:51.460 --> 01:49:53.460]  А, кстати,
[01:49:53.460 --> 01:49:55.460]  Путигины 3, да?
[01:49:55.460 --> 01:49:57.460]  То да.
[01:49:57.460 --> 01:49:59.460]  Это сильно ускоряет?
[01:49:59.460 --> 01:50:01.460]  Два раза.
[01:50:01.460 --> 01:50:03.460]  Ну где-то я, честно говоря,
[01:50:03.460 --> 01:50:05.460]  я так не проводил эксперименты, но
[01:50:05.460 --> 01:50:07.460]  знаете,
[01:50:07.460 --> 01:50:09.460]  ходят случаи, что-то.
[01:50:09.460 --> 01:50:11.460]  Знаете, как бывает?
[01:50:11.460 --> 01:50:13.460]  Автор подобных задач,
[01:50:13.460 --> 01:50:15.460]  кто пишет задачу там?
[01:50:15.460 --> 01:50:17.460]  А, плевать, что там ограничения какие-то большие,
[01:50:17.460 --> 01:50:19.460]  хорошо написанные.
[01:50:19.460 --> 01:50:21.460]  Хорошо написанные.
[01:50:21.460 --> 01:50:23.460]  Ну да, у этого автора, конечно,
[01:50:23.460 --> 01:50:25.460]  хорошо написанные это может быть отдельная письма.
[01:50:27.460 --> 01:50:29.460]  Ну вот так.
[01:50:29.460 --> 01:50:31.460]  Значит, теперь представим себе,
[01:50:31.460 --> 01:50:33.460]  что у нас есть жадь.
[01:50:33.460 --> 01:50:35.460]  Что такое жадь?
[01:50:35.460 --> 01:50:37.460]  Это абсолютно какой-то
[01:50:37.460 --> 01:50:39.460]  произвольный, неориентированный граф.
[01:50:39.460 --> 01:50:41.460]  Ну я сейчас определение
[01:50:41.460 --> 01:50:43.460]  беру для абсолютно произвольного,
[01:50:43.460 --> 01:50:45.460]  неориентированного графа.
[01:50:45.460 --> 01:50:47.460]  Да, не обязательно планарного,
[01:50:47.460 --> 01:50:49.460]  если что.
[01:50:49.460 --> 01:50:51.460]  Ну там, с планарным графом-то отдельная письма.
[01:50:53.460 --> 01:50:55.460]  Вот.
[01:50:55.460 --> 01:50:57.460]  И смотрите.
[01:50:59.460 --> 01:51:01.460]  Вот.
[01:51:01.460 --> 01:51:03.460]  Значит, и тогда
[01:51:03.460 --> 01:51:05.460]  с ним связаны
[01:51:05.460 --> 01:51:07.460]  три приятные вещи.
[01:51:09.460 --> 01:51:11.460]  Ну, давайте, красненько нарисуем.
[01:51:11.460 --> 01:51:13.460]  Какие у меня там марки, видите?
[01:51:15.460 --> 01:51:17.460]  Ну давайте вот такие.
[01:51:17.460 --> 01:51:19.460]  Значит, смотрите.
[01:51:21.460 --> 01:51:23.460]  Буковки такие.
[01:51:23.460 --> 01:51:25.460]  Альфа джэ.
[01:51:25.460 --> 01:51:27.460]  Это размер
[01:51:27.460 --> 01:51:29.460]  максимального
[01:51:29.460 --> 01:51:31.460]  парасочетания.
[01:51:41.460 --> 01:51:43.460]  О.
[01:51:43.460 --> 01:51:45.460]  Альфа джэ размер максимального парасочетания.
[01:51:49.460 --> 01:51:51.460]  Вот. Ну это мы уже знаем.
[01:51:51.460 --> 01:51:53.460]  А вот теперь два определения, которых мы не знаем.
[01:51:53.460 --> 01:51:55.460]  Тау от джэ.
[01:51:55.460 --> 01:51:57.460]  Мы знаем, что такое парасочетание случайно говорят.
[01:51:57.460 --> 01:51:59.460]  Но определение понятно.
[01:51:59.460 --> 01:52:01.460]  Что такое парасочетание?
[01:52:01.460 --> 01:52:03.460]  Парасочетание это набор не пересекающихся
[01:52:03.460 --> 01:52:05.460]  по вершинам.
[01:52:05.460 --> 01:52:07.460]  Теперь.
[01:52:07.460 --> 01:52:09.460]  Тау от джэ.
[01:52:09.460 --> 01:52:11.460]  Размер
[01:52:11.460 --> 01:52:13.460]  минимального
[01:52:13.460 --> 01:52:15.460]  вершинного покрытия.
[01:52:23.460 --> 01:52:25.460]  У нас нет долей.
[01:52:25.460 --> 01:52:27.460]  Сейчас у нас абсолютно произвольный граф.
[01:52:31.460 --> 01:52:33.460]  Ну то есть мы
[01:52:33.460 --> 01:52:35.460]  как бы уже, когда мы находим...
[01:52:35.460 --> 01:52:37.460]  Мы его не умеем искать, если что.
[01:52:37.460 --> 01:52:39.460]  Нет, нет. Просто само определение.
[01:52:39.460 --> 01:52:41.460]  Я не совсем понимаю. Вот мы потом разбили
[01:52:41.460 --> 01:52:43.460]  на две доли.
[01:52:43.460 --> 01:52:45.460]  Разбили на три доли.
[01:52:45.460 --> 01:52:47.460]  Не три доли.
[01:52:47.460 --> 01:52:49.460]  А что мы делаем? Ничего.
[01:52:49.460 --> 01:52:51.460]  Обыделение.
[01:52:51.460 --> 01:52:53.460]  Пока мы просто говорим, что у нас есть, в этом графе есть
[01:52:53.460 --> 01:52:55.460]  بعάν.
[01:52:55.460 --> 01:52:57.460]  Некоторые имеют большой ребер,
[01:52:57.460 --> 01:52:59.460]  некоторые меньшее.
[01:52:59.460 --> 01:53:01.460]  И максимальным парасочетанием мы называем парасочетание
[01:53:01.460 --> 01:53:03.460]  с максимальным числом ребер.
[01:53:03.460 --> 01:53:05.460]  Парасочетание это набор
[01:53:05.460 --> 01:53:07.460]  ребер не зависимых по вершинам.
[01:53:07.460 --> 01:53:09.460]  Никакие два из которых не имеют
[01:53:09.460 --> 01:53:11.460]  общего вершины.
[01:53:11.460 --> 01:53:13.460]  А вершины могут быть связаны между собой?
[01:53:13.460 --> 01:53:15.460]  Конечно.
[01:53:15.460 --> 01:53:17.460]  А они в двудольном графе могут быть
[01:53:17.460 --> 01:53:19.460]  связаны между собой.
[01:53:19.460 --> 01:53:21.460]  Потому что в двудольном графе тоже могла бы быть ситуация
[01:53:21.460 --> 01:53:26.460]  Вот такие вот, вот что-нибудь вот такое, и на самом деле там есть еще вот такие бёбра.
[01:53:26.460 --> 01:53:28.460]  То есть это ж допустимо в плане?
[01:53:28.460 --> 01:53:31.460]  А в одной доле они могли...
[01:53:31.460 --> 01:53:33.460]  А, а это в плане?
[01:53:33.460 --> 01:53:35.460]  Нет, ну просто нет, это определение двудольное.
[01:53:35.460 --> 01:53:42.460]  Когда мы говорим, что граф называется двудольным, если его вершины можно разбить на две доли так, чтобы внутри долей...
[01:53:42.460 --> 01:53:45.460]  Да, здесь мы сейчас не рассматриваем двудольный.
[01:53:45.460 --> 01:53:49.460]  То есть мы делаем абсолютно произвольный, не ориентированный граф.
[01:53:49.460 --> 01:53:51.460]  Хорошо.
[01:53:54.460 --> 01:53:58.460]  Мы ненадолго, но мы забываем о двудольности.
[01:54:08.460 --> 01:54:13.460]  Это размер минимального вершинного покрытия.
[01:54:14.460 --> 01:54:18.460]  Да, то есть это прошутское вершинное покрытие.
[01:54:18.460 --> 01:54:29.460]  Значит, вершинное покрытие это такой набор вершин, вот такой вот набор вершин,
[01:54:29.460 --> 01:54:40.460]  такой что каждое ребро инцидентно хотя бы одной вершине из этого ножа.
[01:54:44.460 --> 01:54:48.460]  Ну, то есть вот там все ходит, хотя бы...
[01:54:48.460 --> 01:54:55.460]  Ну да, то есть давайте так, смотрите, у подмножества в это вершинное покрытие,
[01:54:55.460 --> 01:55:00.460]  покрытие, если...
[01:55:00.460 --> 01:55:05.460]  Ну, то есть я не формально сказал, а формально это...
[01:55:05.460 --> 01:55:08.460]  Ну, если формально писать, сейчас тут будет тупий звук, конечно.
[01:55:08.460 --> 01:55:11.460]  То есть если для любого ребра E,
[01:55:14.460 --> 01:55:17.460]  которое мы обозначим как УВ,
[01:55:19.460 --> 01:55:22.460]  значит, оказывается, что У лежит в этом множестве У.
[01:55:22.460 --> 01:55:25.460]  Ой, плохие буквы набрались, конечно.
[01:55:25.460 --> 01:55:27.460]  Давайте...
[01:55:27.460 --> 01:55:29.460]  Х.
[01:55:30.460 --> 01:55:32.460]  Ну, что Х.
[01:55:33.460 --> 01:55:35.460]  О.
[01:55:36.460 --> 01:55:38.460]  В.
[01:55:41.460 --> 01:55:42.460]  Вот так.
[01:55:42.460 --> 01:55:48.460]  То есть для любого ребра E хотя бы одна из его вершин в этом множестве лежит.
[01:55:48.460 --> 01:55:55.460]  То есть вершина мысленно взятая, потому что она покрывает все ребра торчачьи из неба.
[01:55:55.460 --> 01:56:00.460]  Ну, естественно, каждое ребро может быть покрыто в таком множестве либо одной вершины, либо даже двумя.
[01:56:00.460 --> 01:56:05.460]  Но, как бы, можно назвать вершину покрытием, если нет ребра, которые не покрыты ничем.
[01:56:06.460 --> 01:56:11.460]  И, разумеется, ну, понятно, что такое ребро в вершинах покрытия всегда существует.
[01:56:11.460 --> 01:56:15.460]  Ну, потому что можно просто в него взять все вершины.
[01:56:16.460 --> 01:56:20.460]  Или все вершины без одной, кстати, всегда можно взять, это тоже нам хватит.
[01:56:21.460 --> 01:56:24.460]  Но, на самом деле, конечно...
[01:56:24.460 --> 01:56:30.460]  И нам, конечно, очень интересно, насколько мало можно взять вершин, чтобы все покрыть.
[01:56:33.460 --> 01:56:38.460]  И, конечно же, и у него есть, конечно, такой замечательный нападник.
[01:56:39.460 --> 01:56:40.460]  Ой.
[01:56:41.460 --> 01:56:43.460]  Ой, а я в буквах нагнал.
[01:56:44.460 --> 01:56:47.460]  Нет, это не альфа, это пи.
[01:56:50.460 --> 01:56:52.460]  Альфа вот она.
[01:56:52.460 --> 01:56:54.460]  Альфа, подожди.
[01:56:55.460 --> 01:56:57.460]  Это размер...
[01:57:00.460 --> 01:57:04.460]  Минимального, флаксимального ненависти.
[01:57:10.460 --> 01:57:12.460]  Независимого множества.
[01:57:22.460 --> 01:57:24.460]  Да, шутка и независимая множество.
[01:57:26.460 --> 01:57:30.460]  Это множество вершин, которые не связаны ни одним ребром.
[01:57:30.460 --> 01:57:34.460]  Да, совершенно. Никакие две из которых не соединены ребром.
[01:57:37.460 --> 01:57:42.460]  И таких, конечно, вершин, ну, поэтому в идеале можно, наоборот, взять пустое множество.
[01:57:43.460 --> 01:57:45.460]  Но, конечно, это не вершина.
[01:57:46.460 --> 01:57:51.460]  И таких, конечно, вершин, ну, поэтому в идеале можно, наоборот, взять пустое множество.
[01:57:52.460 --> 01:57:55.460]  Или одну вершину. Но хочется, наверное, взять как можно больше.
[01:57:59.460 --> 01:58:03.460]  Но, знаете, тут оказывается интересным даже написать формальное определение.
[01:58:04.460 --> 01:58:07.460]  Вот так и написать. Смотрите, игрок.
[01:58:09.460 --> 01:58:11.460]  В это независимое множество.
[01:58:15.460 --> 01:58:17.460]  Если, угадайте, что.
[01:58:20.460 --> 01:58:23.460]  Если для любого Е.
[01:58:28.460 --> 01:58:31.460]  Ну, так скажем. Если для любого Е.
[01:58:32.460 --> 01:58:38.460]  То есть никакое ребро не соединяет две вершины из этого множества.
[01:58:39.460 --> 01:58:45.460]  То есть, вот так, неверно, что У лежит в множестве Х,
[01:58:45.460 --> 01:58:51.460]  и В лежит в В.
[01:58:51.460 --> 01:58:53.460]  Вот, если совсем формально написать.
[01:58:53.460 --> 01:58:55.460]  И вот так.
[01:59:07.460 --> 01:59:09.460]  И вот так.
[01:59:10.460 --> 01:59:12.460]  Или, что то же самое.
[01:59:13.460 --> 01:59:15.460]  Не У, а Х.
[01:59:15.460 --> 01:59:21.460]  Не, точнее, так, У не лежит, либо У не лежит, или, или, или, или, или, либо.
[01:59:23.460 --> 01:59:25.460]  Не еще одну вершину.
[01:59:26.460 --> 01:59:27.460]  Да.
[01:59:28.460 --> 01:59:30.460]  Вот, что-то похожее, правда?
[01:59:31.460 --> 01:59:35.460]  Вот, если формально написать, то есть есть что-то как будто прямо от одной вершины.
[01:59:37.460 --> 01:59:38.460]  Что?
[01:59:39.460 --> 01:59:41.460]  Не, ну не совсем. Видите, разница есть.
[01:59:42.460 --> 01:59:45.460]  Тут как бы лежит, а тут не лежит.
[01:59:47.460 --> 01:59:49.460]  Так мы объявили ИГЛИК.
[01:59:50.460 --> 01:59:51.460]  Да, тут.
[01:59:52.460 --> 01:59:53.460]  Да, да, да.
[01:59:58.460 --> 01:59:59.460]  Это да.
[02:00:00.460 --> 02:00:01.460]  Да, конечно.
[02:00:01.460 --> 02:00:02.460]  Да, конечно.
[02:00:03.460 --> 02:00:05.460]  Не, ну а то просто чисто, как бы уже просто,
[02:00:05.460 --> 02:00:07.460]  обычно эта логика, которую вы продолжаете изучать,
[02:00:07.460 --> 02:00:09.460]  уже должна спрашивать, а Х это что?
[02:00:12.460 --> 02:00:15.460]  А тут вот какое-то это, как это называется?
[02:00:15.460 --> 02:00:18.460]  Что называется? Незамкнутый предикат?
[02:00:18.460 --> 02:00:21.460]  Или какое-то мудное сочетание, которое называется?
[02:00:23.460 --> 02:00:25.460]  Нет, просто не помню.
[02:00:25.460 --> 02:00:28.460]  На самом деле, по логике, как раз, нет, не было этого зачетка, это ни в чем не было.
[02:00:28.460 --> 02:00:29.460]  Да.
[02:00:29.460 --> 02:00:31.460]  Ну и еще будет.
[02:00:32.460 --> 02:00:34.460]  Ой, почему-то кого-то он сильно пугает даже.
[02:00:35.460 --> 02:00:37.460]  В наши времена почему-то все болялись такого страшного просто, как,
[02:00:37.460 --> 02:00:39.460]  клянутое исчисление.
[02:00:42.460 --> 02:00:44.460]  Только клянутое исчисление.
[02:00:45.460 --> 02:00:47.460]  И то не в том предвече.
[02:00:49.460 --> 02:00:51.460]  Ну почти плюс плюс у вас тоже экзамен.
[02:00:52.460 --> 02:00:54.460]  Будут быть. Самый страшный, говорят.
[02:00:54.460 --> 02:00:55.460]  Да?
[02:00:55.460 --> 02:00:56.460]  Да.
[02:00:57.460 --> 02:00:59.460]  Ну это да.
[02:01:00.460 --> 02:01:02.460]  Ну да, да, да.
[02:01:02.460 --> 02:01:04.460]  А то да, да, да, хоть и да.
[02:01:04.460 --> 02:01:06.460]  Как говорится, с лекцией нет.
[02:01:08.460 --> 02:01:10.460]  Ну знаете, иногда бывает, что это.
[02:01:10.460 --> 02:01:12.460]  Лекции нет, экзамен сдавайте.
[02:01:12.460 --> 02:01:14.460]  Нет, ну просто знаете, как логика,
[02:01:14.460 --> 02:01:16.460]  потому что как-то хорошо вытверждается,
[02:01:16.460 --> 02:01:18.460]  как-то, что где-то из гузер, там,
[02:01:18.460 --> 02:01:20.460]  ну, в основном не наших, но там,
[02:01:20.460 --> 02:01:22.460]  иногда практикуется такое, что,
[02:01:22.460 --> 02:01:24.460]  на самом деле, вот какой смысл,
[02:01:24.460 --> 02:01:26.460]  можно сидеть и читать лекцию, если все
[02:01:26.460 --> 02:01:28.460]  материалы можно найти в учебнике.
[02:01:28.460 --> 02:01:30.460]  Ну, потому что вот, ну, так там,
[02:01:30.460 --> 02:01:32.460]  во всяких приметах, типа ватан или нав,
[02:01:32.460 --> 02:01:34.460]  чаще всего это реально века.
[02:01:34.460 --> 02:01:36.460]  Вот. Поэтому возникает такая практика.
[02:01:36.460 --> 02:01:38.460]  То есть, на самом деле, лекция
[02:01:38.460 --> 02:01:40.460]  существует только для того, чтобы лектору задать вопрос.
[02:01:40.460 --> 02:01:42.460]  То есть, условно говоря, вы там
[02:01:42.460 --> 02:01:44.460]  ботаете там, заданный объем материала,
[02:01:44.460 --> 02:01:46.460]  потом, если что-то не поняли,
[02:01:46.460 --> 02:01:48.460]  то, собственно, приходите и начинаете
[02:01:48.460 --> 02:01:50.460]  задавать вопрос.
[02:01:50.460 --> 02:01:52.460]  Вот.
[02:01:52.460 --> 02:01:54.460]  Ну, вот. У нас почему-то это не происходит.
[02:01:54.460 --> 02:01:56.460]  Видимо, потому что
[02:01:56.460 --> 02:01:58.460]  с какой-то момента перестанут задавать вопрос.
[02:02:00.460 --> 02:02:02.460]  Вот.
[02:02:02.460 --> 02:02:04.460]  А потом выяснится, что что-то,
[02:02:04.460 --> 02:02:06.460]  что-то знают. Так вот.
[02:02:06.460 --> 02:02:08.460]  Значит, посмотрим внимательно.
[02:02:08.460 --> 02:02:10.460]  Тао-аджи и альфа-аджи.
[02:02:12.460 --> 02:02:14.460]  Что это такое? Ну, вот.
[02:02:14.460 --> 02:02:16.460]  Ну, на самом деле, если очень внимательно
[02:02:16.460 --> 02:02:18.460]  на вот это вот посмотреть,
[02:02:18.460 --> 02:02:20.460]  то
[02:02:20.460 --> 02:02:22.460]  сразу возникает мистическое
[02:02:22.460 --> 02:02:24.460]  утверждение.
[02:02:30.460 --> 02:02:32.460]  То есть, на самом деле, какое?
[02:02:32.460 --> 02:02:34.460]  А утверждение такое,
[02:02:34.460 --> 02:02:36.460]  что x, вот, произвольное
[02:02:36.460 --> 02:02:38.460]  под множеством v, это
[02:02:38.460 --> 02:02:40.460]  значит, вершинное покрытие,
[02:02:40.460 --> 02:02:42.460]  не обязательно минимальное.
[02:02:42.460 --> 02:02:44.460]  Вершинное покрытие.
[02:02:46.460 --> 02:02:48.460]  Если и только
[02:02:48.460 --> 02:02:50.460]  если
[02:02:50.460 --> 02:02:52.460]  если
[02:02:56.460 --> 02:02:58.460]  v без x
[02:02:58.460 --> 02:03:00.460]  независимое множество.
[02:03:12.460 --> 02:03:14.460]  На камере не видно?
[02:03:14.460 --> 02:03:16.460]  Или там видно только тогда
[02:03:16.460 --> 02:03:18.460]  этого?
[02:03:18.460 --> 02:03:20.460]  Видно, все видно.
[02:03:20.460 --> 02:03:22.460]  Все шикарно видно.
[02:03:28.460 --> 02:03:30.460]  То есть, то действительно, если внимательно
[02:03:30.460 --> 02:03:32.460]  посмотреть на формальное определение,
[02:03:32.460 --> 02:03:34.460]  то в общем-то утверждение становится очевидно.
[02:03:36.460 --> 02:03:38.460]  Ну, и даже можно и напрямую доказывать,
[02:03:38.460 --> 02:03:40.460]  что, как бы, пусть это
[02:03:40.460 --> 02:03:42.460]  x-вершинное покрытие. Если тут
[02:03:42.460 --> 02:03:44.460]  зависит от множества, значит, есть ребро,
[02:03:44.460 --> 02:03:46.460]  соединяющие две вершины
[02:03:46.460 --> 02:03:48.460]  из дополнения x.
[02:03:48.460 --> 02:03:50.460]  То есть, получается, этот x
[02:03:50.460 --> 02:03:52.460]  какой-то ребро не покрыл.
[02:03:52.460 --> 02:03:54.460]  Ну, и наоборот то же самое.
[02:03:56.460 --> 02:03:58.460]  Я не тут минимальное не писал,
[02:03:58.460 --> 02:04:00.460]  не тут подсимальное не писал.
[02:04:00.460 --> 02:04:02.460]  То есть, не обязательно максимальное?
[02:04:02.460 --> 02:04:04.460]  Да.
[02:04:04.460 --> 02:04:06.460]  Они просто обыстомали, ходим паре.
[02:04:06.460 --> 02:04:08.460]  То есть, там можно всяким
[02:04:08.460 --> 02:04:10.460]  формулировать там всякие утверждения,
[02:04:10.460 --> 02:04:12.460]  типа, что вершинных покрытий ровно столько,
[02:04:12.460 --> 02:04:14.460]  сколько независимо от множества, например.
[02:04:14.460 --> 02:04:16.460]  И это, видите, тоже отдельная тема.
[02:04:16.460 --> 02:04:18.460]  Что-то там да.
[02:04:18.460 --> 02:04:20.460]  Ой, да. Замечательно, да.
[02:04:20.460 --> 02:04:22.460]  Так сказать, нельзя сказать, что
[02:04:22.460 --> 02:04:24.460]  это же результат публиковать
[02:04:24.460 --> 02:04:26.460]  в каком-то журнале.
[02:04:26.460 --> 02:04:28.460]  Вот.
[02:04:30.460 --> 02:04:32.460]  Так это да.
[02:04:32.460 --> 02:04:34.460]  Вот.
[02:04:34.460 --> 02:04:36.460]  Нет, ну, в каком-то математике так бывает.
[02:04:36.460 --> 02:04:38.460]  Доказываешься, доказываешься, теряем у фирма.
[02:04:38.460 --> 02:04:40.460]  Там находишь несколько доказательств.
[02:04:40.460 --> 02:04:42.460]  Каждый из них валят.
[02:04:42.460 --> 02:04:44.460]  Ну, там по разным причинам. Потом говорят, что есть у вас
[02:04:44.460 --> 02:04:46.460]  одна маленькая незначительная ошибка,
[02:04:46.460 --> 02:04:48.460]  то есть, если не исправить, то уже доказательство не получается.
[02:04:48.460 --> 02:04:50.460]  И там придумываете второе доказательство,
[02:04:50.460 --> 02:04:52.460]  и доказательство абсолютно правильное, только доказали,
[02:04:52.460 --> 02:04:54.460]  вы не теряем у фирма. А там что-то другое
[02:04:54.460 --> 02:04:56.460]  доказали, впрочем, давно известно.
[02:04:56.460 --> 02:04:58.460]  Ну, вот потом вы там
[02:04:58.460 --> 02:05:00.460]  просто играете числами,
[02:05:00.460 --> 02:05:02.460]  находите интересный план.
[02:05:02.460 --> 02:05:04.460]  Не ставите энциклопедию,
[02:05:04.460 --> 02:05:06.460]  там просто, там, в которой есть все
[02:05:06.460 --> 02:05:08.460]  в математике, и ваша теорема не находится.
[02:05:08.460 --> 02:05:10.460]  Думаете, что это ваша теорема.
[02:05:10.460 --> 02:05:12.460]  А потом через много лет просто находите
[02:05:12.460 --> 02:05:14.460]  эту теорему, как олимпиаду,
[02:05:14.460 --> 02:05:16.460]  олимпиаду Дескак-Шиклая.
[02:05:20.460 --> 02:05:22.460]  Ну, вот.
[02:05:22.460 --> 02:05:24.460]  Так вот.
[02:05:24.460 --> 02:05:26.460]  На самом деле нас из этого всего будет интересовать
[02:05:26.460 --> 02:05:28.460]  следствие. То есть, я могу сформулировать так.
[02:05:28.460 --> 02:05:30.460]  Ну, следствие, на самом деле, очень прозрачное.
[02:05:32.460 --> 02:05:34.460]  Что на самом деле
[02:05:36.460 --> 02:05:38.460]  я даже вот так симметрично сформулирую.
[02:05:54.460 --> 02:05:56.460]  Ну, понятно, да?
[02:05:56.460 --> 02:05:58.460]  Чем меньше вершинное покрытие, тем больше
[02:05:58.460 --> 02:06:00.460]  у него дополнение. То есть, мысль теорема в том,
[02:06:00.460 --> 02:06:02.460]  что, это даже можно более точно сказать, что
[02:06:02.460 --> 02:06:04.460]  дополнением к минимальному
[02:06:04.460 --> 02:06:06.460]  вершинному покрытию является максимально
[02:06:06.460 --> 02:06:08.460]  независимое дно штуны, ну и наоборот.
[02:06:10.460 --> 02:06:12.460]  То есть, поэтому по факту,
[02:06:12.460 --> 02:06:14.460]  во всех смыслах, нам на самом деле
[02:06:14.460 --> 02:06:16.460]  отдельно альфа аджей
[02:06:16.460 --> 02:06:18.460]  искать необходимости нет.
[02:06:18.460 --> 02:06:20.460]  То есть, если мы найдем минимальное вершинное покрытие,
[02:06:20.460 --> 02:06:22.460]  мы автоматически максимально независимое
[02:06:22.460 --> 02:06:24.460]  дно штуны найдем.
[02:06:26.460 --> 02:06:28.460]  В чем-то, заметьте, что самое приятное, я вот
[02:06:28.460 --> 02:06:30.460]  случайно тут рисовал произвольный граф.
[02:06:30.460 --> 02:06:32.460]  То есть, это вот эти утверждения
[02:06:32.460 --> 02:06:34.460]  для произвольного графа.
[02:06:34.460 --> 02:06:36.460]  То есть, мы здесь двудольностью не пользовались
[02:06:36.460 --> 02:06:38.460]  никак.
[02:06:40.460 --> 02:06:42.460]  Поэтому давайте
[02:06:42.460 --> 02:06:44.460]  временно про независимое
[02:06:44.460 --> 02:06:46.460]  дно штуна забудем.
[02:06:46.460 --> 02:06:48.460]  Ну, не временно, на самом деле.
[02:06:48.460 --> 02:06:50.460]  Безвременно, да.
[02:06:50.460 --> 02:06:52.460]  Так что, значит, давайте
[02:06:52.460 --> 02:06:54.460]  это все мы убираем.
[02:06:54.460 --> 02:06:56.460]  То есть, мы поняли, что
[02:06:56.460 --> 02:06:58.460]  с точки зрения глобальных идей
[02:06:58.460 --> 02:07:00.460]  нам, в общем-то, независимое дно штуна
[02:07:00.460 --> 02:07:02.460]  бесполезно практически.
[02:07:02.460 --> 02:07:04.460]  Ну, не бесполезно, но в смысле
[02:07:04.460 --> 02:07:06.460]  что
[02:07:06.460 --> 02:07:08.460]  тратить много времени
[02:07:08.460 --> 02:07:10.460]  отдельно от вершинного покрытия нам не надо.
[02:07:10.460 --> 02:07:12.460]  А теперь давайте думать,
[02:07:12.460 --> 02:07:14.460]  как связаны между собой таоджи
[02:07:14.460 --> 02:07:16.460]  и пьеджи?
[02:07:20.460 --> 02:07:22.460]  Ну да, заметим, что мы, конечно,
[02:07:22.460 --> 02:07:24.460]  гордо
[02:07:24.460 --> 02:07:26.460]  можем заявить, что
[02:07:26.460 --> 02:07:28.460]  пьеджи больше либо равно,
[02:07:28.460 --> 02:07:30.460]  чем таоджи.
[02:07:32.460 --> 02:07:34.460]  Или наоборот.
[02:07:40.460 --> 02:07:42.460]  Вот кто кого.
[02:07:42.460 --> 02:07:44.460]  Пока я тут пишу слово
[02:07:44.460 --> 02:07:46.460]  уплевнение.
[02:07:46.460 --> 02:07:48.460]  Таоджи больше либо равно.
[02:07:48.460 --> 02:07:50.460]  Пьеджи переписается,
[02:07:50.460 --> 02:07:52.460]  на записи будет ничего.
[02:07:52.460 --> 02:07:54.460]  Ну, пи какой-то не пи.
[02:07:54.460 --> 02:07:56.460]  Вот это пи как пи,
[02:07:56.460 --> 02:07:58.460]  а вот нижнее пи.
[02:07:58.460 --> 02:08:00.460]  А вот это?
[02:08:00.460 --> 02:08:02.460]  Оно как что-то х чертой.
[02:08:02.460 --> 02:08:04.460]  Реполнение к х все нормально.
[02:08:04.460 --> 02:08:06.460]  Ну как? Все красный свет
[02:08:06.460 --> 02:08:08.460]  негликаешь хоть?
[02:08:08.460 --> 02:08:10.460]  Что?
[02:08:10.460 --> 02:08:12.460]  Красно-торанжевая на записи, думаю, не отличается.
[02:08:12.460 --> 02:08:14.460]  Да?
[02:08:14.460 --> 02:08:16.460]  Ну, у меня тут в голодах не очень
[02:08:16.460 --> 02:08:18.460]  отличается.
[02:08:18.460 --> 02:08:20.460]  Я думаю, просто свет
[02:08:20.460 --> 02:08:22.460]  включить надо.
[02:08:22.460 --> 02:08:24.460]  Ну, свет сейчас
[02:08:24.460 --> 02:08:26.460]  ну, я не знаю, поскорей,
[02:08:26.460 --> 02:08:28.460]  свет включить это называется, вон это
[02:08:28.460 --> 02:08:30.460]  всуху открыть.
[02:08:30.460 --> 02:08:32.460]  Вообще ничего не видно.
[02:08:32.460 --> 02:08:34.460]  Без свет будет отсвечиваться.
[02:08:34.460 --> 02:08:36.460]  Пьеджи меньше либо равно таоджи, думаю, в случае.
[02:08:36.460 --> 02:08:38.460]  Почему так? Потому что таоджи
[02:08:38.460 --> 02:08:40.460]  должен покрыть хотя бы
[02:08:40.460 --> 02:08:42.460]  каждое ребро по рассочетанию,
[02:08:42.460 --> 02:08:44.460]  а у каждого ребра по рассочетанию
[02:08:44.460 --> 02:08:46.460]  свои две вершины.
[02:08:46.460 --> 02:08:48.460]  А теперь есть какая-то вопрос.
[02:08:48.460 --> 02:08:50.460]  Хорошо.
[02:08:50.460 --> 02:08:52.460]  А может ли быть так, что пьеджи строго
[02:08:52.460 --> 02:08:54.460]  меньше, чем таоджи?
[02:08:54.460 --> 02:08:56.460]  Да.
[02:08:56.460 --> 02:08:58.460]  Самый тупой пример, конечно, три ульбы.
[02:09:00.460 --> 02:09:02.460]  Ну, тут понятно, да.
[02:09:02.460 --> 02:09:04.460]  Просочетанием является
[02:09:04.460 --> 02:09:06.460]  максимально обдымное ребро.
[02:09:06.460 --> 02:09:08.460]  Но, к сожалению,
[02:09:08.460 --> 02:09:10.460]  чтобы покрыть все три ребра, вам все-таки тут
[02:09:10.460 --> 02:09:12.460]  две вершинки взять придется.
[02:09:12.460 --> 02:09:14.460]  Вот так.
[02:09:14.460 --> 02:09:16.460]  Вот так.
[02:09:16.460 --> 02:09:18.460]  Вот так.
[02:09:18.460 --> 02:09:20.460]  Вот так.
[02:09:20.460 --> 02:09:22.460]  Но, оказывается,
[02:09:22.460 --> 02:09:24.460]  если мы берем все в удольный граф,
[02:09:24.460 --> 02:09:26.460]  то
[02:09:26.460 --> 02:09:28.460]  оказывается,
[02:09:28.460 --> 02:09:30.460]  здесь равенство.
[02:09:30.460 --> 02:09:32.460]  То есть уже
[02:09:32.460 --> 02:09:34.460]  это уже не утверждение.
[02:09:34.460 --> 02:09:36.460]  То есть это пока простое утверждение, тут все несложно.
[02:09:36.460 --> 02:09:38.460]  Но вот.
[02:09:38.460 --> 02:09:40.460]  Но если мы возьмем в удольный граф,
[02:09:40.460 --> 02:09:42.460]  то выясняется,
[02:09:42.460 --> 02:09:44.460]  видимо, теория материнга.
[02:09:44.460 --> 02:09:46.460]  Вот.
[02:09:46.460 --> 02:09:48.460]  Прямо что-то узнаю.
[02:09:48.460 --> 02:09:50.460]  Если
[02:09:50.460 --> 02:09:52.460]  граф в удольный,
[02:09:58.460 --> 02:10:00.460]  то
[02:10:00.460 --> 02:10:02.460]  оказывается, что
[02:10:02.460 --> 02:10:04.460]  пьеджи
[02:10:06.460 --> 02:10:08.460]  равно таоджи.
[02:10:10.460 --> 02:10:12.460]  Вот.
[02:10:18.460 --> 02:10:20.460]  Это называется теория материнга.
[02:10:24.460 --> 02:10:26.460]  Вот.
[02:10:28.460 --> 02:10:30.460]  Вот спрашивается, как же
[02:10:30.460 --> 02:10:32.460]  ее доказать?
[02:10:32.460 --> 02:10:34.460]  Ну, собственно, мы ее не просто докажем,
[02:10:34.460 --> 02:10:36.460]  а еще и укажем, каким образом,
[02:10:36.460 --> 02:10:38.460]  если у вас есть максимальное просочетание,
[02:10:38.460 --> 02:10:40.460]  то у вас есть максимальное вершинное покрытие выкопы.
[02:10:42.460 --> 02:10:44.460]  Значит, смотрите внимательно.
[02:10:44.460 --> 02:10:46.460]  Итак, вот у нас есть
[02:10:46.460 --> 02:10:48.460]  в удольный граф.
[02:10:50.460 --> 02:10:52.460]  В лице двух долей.
[02:10:54.460 --> 02:10:56.460]  Ну, вот у нас есть доля L,
[02:10:56.460 --> 02:10:58.460]  есть доля R.
[02:11:00.460 --> 02:11:02.460]  Вперед. Смотрите внимательно.
[02:11:02.460 --> 02:11:04.460]  И у нас есть трех.
[02:11:04.460 --> 02:11:06.460]  Некоторые ребра лежат
[02:11:06.460 --> 02:11:08.460]  в просочетании.
[02:11:08.460 --> 02:11:10.460]  Мы их, естественно, ориентируем
[02:11:10.460 --> 02:11:12.460]  справа-направо.
[02:11:20.460 --> 02:11:22.460]  Еще у нас есть ребра, не вошедшие
[02:11:22.460 --> 02:11:24.460]  в просочетание. Мы их ориентируем
[02:11:24.460 --> 02:11:26.460]  слева-направо.
[02:11:26.460 --> 02:11:28.460]  Так мы не будем.
[02:11:30.460 --> 02:11:32.460]  Вот так вот будет.
[02:11:34.460 --> 02:11:36.460]  Вот так вот.
[02:11:38.460 --> 02:11:40.460]  Вот, ну, приблизительно.
[02:11:44.460 --> 02:11:46.460]  А, еще, конечно же, вот так вот.
[02:11:48.460 --> 02:11:50.460]  А, ну да, вот так вот, конечно.
[02:11:50.460 --> 02:11:52.460]  Ваше просочетание не максимальное.
[02:11:54.460 --> 02:11:56.460]  Господи, как ни рисую, я все равно
[02:11:56.460 --> 02:11:58.460]  удоняющая целью, где-нибудь проскочу.
[02:11:58.460 --> 02:12:00.460]  Так.
[02:12:02.460 --> 02:12:04.460]  Сейчас.
[02:12:04.460 --> 02:12:06.460]  Нет, надо как-то...
[02:12:06.460 --> 02:12:08.460]  Сейчас.
[02:12:08.460 --> 02:12:10.460]  Вот так надо сделать.
[02:12:10.460 --> 02:12:12.460]  Ну, чтобы совсем красиво было,
[02:12:12.460 --> 02:12:14.460]  надо вот так.
[02:12:16.460 --> 02:12:18.460]  Окей.
[02:12:18.460 --> 02:12:20.460]  Пойдет.
[02:12:20.460 --> 02:12:22.460]  Вот сейчас пойдет, да.
[02:12:22.460 --> 02:12:24.460]  Так вот.
[02:12:24.460 --> 02:12:26.460]  Интересно теперь в следующем.
[02:12:26.460 --> 02:12:28.460]  Мы сейчас проделаем
[02:12:28.460 --> 02:12:30.460]  мистическую штуку.
[02:12:30.460 --> 02:12:32.460]  Мы возьмем...
[02:12:32.460 --> 02:12:34.460]  Зачем мы все еще ориентируем?
[02:12:34.460 --> 02:12:36.460]  Мы возьмем
[02:12:38.460 --> 02:12:40.460]  все вершины
[02:12:44.460 --> 02:12:46.460]  левой доли
[02:12:46.460 --> 02:12:48.460]  не покрытые в просочетании.
[02:12:48.460 --> 02:12:50.460]  И запустим из них
[02:12:50.460 --> 02:12:52.460]  DFS.
[02:12:54.460 --> 02:12:56.460]  Вот эти.
[02:12:56.460 --> 02:12:58.460]  Так и запустим.
[02:12:58.460 --> 02:13:00.460]  Вот эти вершины я обведу в знак того,
[02:13:00.460 --> 02:13:02.460]  чтобы из них DFS запускали,
[02:13:02.460 --> 02:13:04.460]  а эти просто закажем в знак того,
[02:13:04.460 --> 02:13:06.460]  чтобы из них не запускали,
[02:13:06.460 --> 02:13:08.460]  но DFS до них дошел.
[02:13:08.460 --> 02:13:10.460]  Вот, примерно, вот так вот это.
[02:13:12.460 --> 02:13:14.460]  Вот.
[02:13:14.460 --> 02:13:16.460]  Вот, примерно, вот так вот это
[02:13:16.460 --> 02:13:18.460]  произойдет.
[02:13:18.460 --> 02:13:20.460]  Видите, да?
[02:13:20.460 --> 02:13:22.460]  Значит, смотрите, тогда
[02:13:22.460 --> 02:13:24.460]  в левой доле есть
[02:13:24.460 --> 02:13:26.460]  вершины, которые
[02:13:26.460 --> 02:13:28.460]  DFS обошел, мы их назовем
[02:13:28.460 --> 02:13:30.460]  L+.
[02:13:30.460 --> 02:13:32.460]  А есть вершины,
[02:13:32.460 --> 02:13:34.460]  в нашем случае одна, но их может быть
[02:13:34.460 --> 02:13:36.460]  и больше, когда DFS не отошел.
[02:13:36.460 --> 02:13:38.460]  L+. Видите, да?
[02:13:38.460 --> 02:13:40.460]  Абсолютно
[02:13:40.460 --> 02:13:42.460]  аналогичным образом мы скажем,
[02:13:42.460 --> 02:13:44.460]  что до кого DFS дошел
[02:13:44.460 --> 02:13:46.460]  в правой доле мы будем называть
[02:13:46.460 --> 02:13:48.460]  L+.
[02:13:50.460 --> 02:13:52.460]  С Мирко, что ли?
[02:13:52.460 --> 02:13:54.460]  Да.
[02:13:54.460 --> 02:13:56.460]  С Вики, с чего он?
[02:13:56.460 --> 02:13:58.460]  Ну, когда
[02:13:58.460 --> 02:14:00.460]  когда у вас есть
[02:14:00.460 --> 02:14:02.460]  алгоритм, который работает
[02:14:02.460 --> 02:14:04.460]  за ОАД,
[02:14:04.460 --> 02:14:06.460]  если у вас уже есть максимальное
[02:14:06.460 --> 02:14:08.460]  просочетание, то зачем
[02:14:08.460 --> 02:14:10.460]  придумывать еще?
[02:14:10.460 --> 02:14:12.460]  Да. И это будет называться
[02:14:12.460 --> 02:14:14.460]  L+. Ну да, литературы может быть
[02:14:14.460 --> 02:14:16.460]  действительной. Там все максимальные конспекты,
[02:14:16.460 --> 02:14:18.460]  что угодно.
[02:14:18.460 --> 02:14:20.460]  Вот.
[02:14:20.460 --> 02:14:22.460]  Так вот.
[02:14:24.460 --> 02:14:26.460]  Так вот.
[02:14:26.460 --> 02:14:28.460]  Мистическое утверждение.
[02:14:30.460 --> 02:14:32.460]  Минимальное вершинное покрытие
[02:14:40.460 --> 02:14:42.460]  нот,
[02:14:42.460 --> 02:14:44.460]  то есть
[02:14:44.460 --> 02:14:46.460]  покрытие
[02:14:48.460 --> 02:14:50.460]  ну, не совсем то есть,
[02:14:50.460 --> 02:14:52.460]  понятно.
[02:14:52.460 --> 02:14:54.460]  То есть,
[02:14:54.460 --> 02:14:56.460]  покрытие
[02:14:56.460 --> 02:14:58.460]  размера
[02:15:02.460 --> 02:15:04.460]  собственно P от G
[02:15:04.460 --> 02:15:06.460]  меньше быть не может,
[02:15:06.460 --> 02:15:08.460]  а вот покрытие размера P от G
[02:15:10.460 --> 02:15:12.460]  это
[02:15:18.460 --> 02:15:20.460]  я утверждаю, что это L-
[02:15:20.460 --> 02:15:22.460]  объединенное
[02:15:22.460 --> 02:15:24.460]  R+.
[02:15:26.460 --> 02:15:28.460]  Все.
[02:15:28.460 --> 02:15:30.460]  То есть, как бы, если мы поверим
[02:15:30.460 --> 02:15:32.460]  в этот мистический факт,
[02:15:34.460 --> 02:15:36.460]  то вот тогда, то есть, получается, что
[02:15:36.460 --> 02:15:38.460]  если у вас есть максимальное просочетание,
[02:15:38.460 --> 02:15:40.460]  то минимальное вершинное покрытие вы найдете
[02:15:40.460 --> 02:15:42.460]  практически за O от E одним DFS.
[02:15:44.460 --> 02:15:46.460]  Ну, то есть, серии DFS, которые суммарно
[02:15:46.460 --> 02:15:48.460]  работают за O от E.
[02:15:48.460 --> 02:15:50.460]  Ну, а максимальное независимое
[02:15:50.460 --> 02:15:52.460]  вы найдете, естественно, как L+,
[02:15:52.460 --> 02:15:54.460]  объединенная серия.
[02:15:54.460 --> 02:15:56.460]  А мы
[02:15:56.460 --> 02:15:58.460]  закрасили вершинки, которые насыщены
[02:15:58.460 --> 02:16:00.460]  просочетанием?
[02:16:00.460 --> 02:16:02.460]  Нет. Мы закрасили вершинки,
[02:16:02.460 --> 02:16:04.460]  на которых вы дотянулись DFS.
[02:16:04.460 --> 02:16:06.460]  ДФС,
[02:16:06.460 --> 02:16:08.460]  которые мы запустили
[02:16:08.460 --> 02:16:10.460]  из всех вершин левой доли,
[02:16:10.460 --> 02:16:12.460]  не покрытой просочетанием.
[02:16:20.460 --> 02:16:22.460]  Потому что она покрыта
[02:16:22.460 --> 02:16:24.460]  просочетанием, и мы так ее
[02:16:24.460 --> 02:16:26.460]  не дотянулись.
[02:16:26.460 --> 02:16:28.460]  Вот такой вот красота.
[02:16:46.460 --> 02:16:48.460]  Проказательство, конечно,
[02:16:48.460 --> 02:16:50.460]  сложнее.
[02:16:50.460 --> 02:16:52.460]  Но тут, конечно, полезно его иногда
[02:16:52.460 --> 02:16:54.460]  иметь в виду,
[02:16:54.460 --> 02:16:56.460]  потому что я зачастую
[02:16:56.460 --> 02:16:58.460]  не помню, кого там
[02:16:58.460 --> 02:17:00.460]  надо брать, но я помню, из каких
[02:17:00.460 --> 02:17:02.460]  соображений это берется, и результате,
[02:17:02.460 --> 02:17:04.460]  исходя из этого, достаточно быстро вспоминаю,
[02:17:04.460 --> 02:17:06.460]  что тут надо писать.
[02:17:06.460 --> 02:17:08.460]  Доказательство тут, в общем-то, логичное.
[02:17:08.460 --> 02:17:10.460]  Что надо доказать?
[02:17:10.460 --> 02:17:12.460]  Во-первых, неплохо
[02:17:12.460 --> 02:17:14.460]  было бы доказать, что это
[02:17:14.460 --> 02:17:16.460]  реально вершинное
[02:17:16.460 --> 02:17:18.460]  покрытие.
[02:17:18.460 --> 02:17:20.460]  Но это самое
[02:17:20.460 --> 02:17:22.460]  простое.
[02:17:22.460 --> 02:17:24.460]  Потому что предположим, что
[02:17:24.460 --> 02:17:26.460]  это не вершинное покрытие.
[02:17:26.460 --> 02:17:28.460]  Тогда у нас получается,
[02:17:28.460 --> 02:17:30.460]  есть две вершины.
[02:17:30.460 --> 02:17:32.460]  Одна,
[02:17:32.460 --> 02:17:34.460]  есть две вершины.
[02:17:34.460 --> 02:17:36.460]  Одна из L+,
[02:17:38.460 --> 02:17:40.460]  а другая
[02:17:40.460 --> 02:17:42.460]  из R-.
[02:17:42.460 --> 02:17:44.460]  И они соединены ребром.
[02:17:44.460 --> 02:17:46.460]  Внимание и вопрос.
[02:17:46.460 --> 02:17:48.460]  Каким ребром?
[02:17:48.460 --> 02:17:50.460]  Ну, у нас два варианта.
[02:17:50.460 --> 02:17:52.460]  Либо они соединены
[02:17:52.460 --> 02:17:54.460]  вот таким ребром.
[02:17:54.460 --> 02:17:56.460]  То есть, вот отсюда-сюда.
[02:17:56.460 --> 02:17:58.460]  Либо вот таким.
[02:18:06.460 --> 02:18:08.460]  Вот этим ребром
[02:18:08.460 --> 02:18:10.460]  это идиотизм.
[02:18:10.460 --> 02:18:12.460]  Потому что
[02:18:12.460 --> 02:18:14.460]  из вершины,
[02:18:14.460 --> 02:18:16.460]  помеченной DFS-ом,
[02:18:16.460 --> 02:18:18.460]  ведет ребро вершину,
[02:18:18.460 --> 02:18:20.460]  не помеченную DFS-ом,
[02:18:20.460 --> 02:18:22.460]  что забреет.
[02:18:24.460 --> 02:18:26.460]  Значит, такого не бывает.
[02:18:28.460 --> 02:18:30.460]  Так, ребро
[02:18:30.460 --> 02:18:32.460]  из вершины,
[02:18:32.460 --> 02:18:34.460]  не помеченной DFS-ом,
[02:18:34.460 --> 02:18:36.460]  ведет ребро
[02:18:36.460 --> 02:18:38.460]  вершину, помеченную DFS-ом.
[02:18:38.460 --> 02:18:40.460]  Может ли
[02:18:40.460 --> 02:18:42.460]  такое быть?
[02:18:44.460 --> 02:18:46.460]  В общем случае, может.
[02:18:48.460 --> 02:18:50.460]  Ну, потому что малый как DFS-ом устроен,
[02:18:50.460 --> 02:18:52.460]  помните, да?
[02:18:52.460 --> 02:18:54.460]  Потому что мы из не самых удачных вершин запустили.
[02:18:54.460 --> 02:18:56.460]  Само по себе это может быть.
[02:18:56.460 --> 02:18:58.460]  Но здесь есть маленькая оговорочка.
[02:18:58.460 --> 02:19:00.460]  Мы в эту вершину...
[02:19:00.460 --> 02:19:02.460]  А как мы в эту вершину вообще попали?
[02:19:06.460 --> 02:19:08.460]  Вот заметим, что мы в вершину могли попасть только два раза,
[02:19:08.460 --> 02:19:10.460]  двумя способами. Либо мы из нее запустили DFS,
[02:19:10.460 --> 02:19:12.460]  либо пришли по какому-то ребру, правда?
[02:19:14.460 --> 02:19:16.460]  Но так как она покрыта по рассочетаниям,
[02:19:16.460 --> 02:19:18.460]  и мы DFS из нее не запускали,
[02:19:18.460 --> 02:19:20.460]  значит мы должны были в нее прийти.
[02:19:20.460 --> 02:19:22.460]  А прийти мы в нее могли только
[02:19:22.460 --> 02:19:24.460]  через это ребро.
[02:19:28.460 --> 02:19:30.460]  Но так как в эту вершину мы не ходили,
[02:19:30.460 --> 02:19:32.460]  через это ребро мы не приходили,
[02:19:32.460 --> 02:19:34.460]  противоречие.
[02:19:34.460 --> 02:19:36.460]  Значит, ура!
[02:19:36.460 --> 02:19:38.460]  Мы доказали...
[02:19:38.460 --> 02:19:40.460]  Давайте внимательно, что мы доказали?
[02:19:46.460 --> 02:19:48.460]  Что нет ребер
[02:19:48.460 --> 02:19:50.460]  между L+, и R-.
[02:19:50.460 --> 02:19:52.460]  Да.
[02:19:52.460 --> 02:19:54.460]  Или что то же самое, мы доказали,
[02:19:54.460 --> 02:19:56.460]  что L- и R+, в объединении,
[02:19:56.460 --> 02:19:58.460]  дают покрывающее множество.
[02:20:00.460 --> 02:20:02.460]  Но минимальное ли оно?
[02:20:02.460 --> 02:20:04.460]  Вообще, вегна ли, что
[02:20:04.460 --> 02:20:06.460]  оно реально имеет размер PNG?
[02:20:12.460 --> 02:20:14.460]  Как это доказать?
[02:20:14.460 --> 02:20:16.460]  Это очень просто.
[02:20:16.460 --> 02:20:18.460]  Мы докажем, что в этих множествах
[02:20:18.460 --> 02:20:20.460]  каждая вершина
[02:20:20.460 --> 02:20:22.460]  лежит в просочетании.
[02:20:22.460 --> 02:20:24.460]  И более того,
[02:20:24.460 --> 02:20:26.460]  на каждому ребру просочетания
[02:20:26.460 --> 02:20:28.460]  принадлежит ровно одна из этих вершин.
[02:20:28.460 --> 02:20:30.460]  Я утверждаю, что ровно это нам достаточно доказать.
[02:20:34.460 --> 02:20:36.460]  Понятно, что я сказал?
[02:20:40.460 --> 02:20:42.460]  Ну, смотрите.
[02:20:42.460 --> 02:20:44.460]  Это покрывающее множество.
[02:20:44.460 --> 02:20:46.460]  Я хочу просто показать,
[02:20:46.460 --> 02:20:48.460]  что все эти вершины
[02:20:48.460 --> 02:20:50.460]  лежат в просочетании,
[02:20:50.460 --> 02:20:52.460]  и более того, на каждом ребре просочетания
[02:20:52.460 --> 02:20:54.460]  лежит ровно одна такая вершина.
[02:20:54.460 --> 02:20:56.460]  То есть это и будет означать,
[02:20:56.460 --> 02:20:58.460]  что в этом множестве ровно PNG-вершины.
[02:20:58.460 --> 02:21:00.460]  Логично, да?
[02:21:00.460 --> 02:21:02.460]  Логично, да.
[02:21:04.460 --> 02:21:06.460]  Ну, давайте думать.
[02:21:08.460 --> 02:21:10.460]  Ну, во-первых, конечно же...
[02:21:10.460 --> 02:21:12.460]  Ну, давайте так.
[02:21:12.460 --> 02:21:14.460]  Ну, хотя все тут надо...
[02:21:14.460 --> 02:21:16.460]  Ну, во-первых, давайте подумаем.
[02:21:16.460 --> 02:21:18.460]  Могут ли эти вершины не лежать в просочетании?
[02:21:18.460 --> 02:21:20.460]  Ну, A-минус, очевидно, не может.
[02:21:22.460 --> 02:21:24.460]  Потому что
[02:21:24.460 --> 02:21:26.460]  из всех вершин левой доли
[02:21:26.460 --> 02:21:28.460]  не лежащая, мы DFS тупо запускали.
[02:21:28.460 --> 02:21:30.460]  Помните, да?
[02:21:30.460 --> 02:21:32.460]  Хорошо, а F+.
[02:21:32.460 --> 02:21:34.460]  А почему?
[02:21:36.460 --> 02:21:38.460]  Допустим, вершина
[02:21:38.460 --> 02:21:40.460]  не лежит,
[02:21:42.460 --> 02:21:44.460]  но мы как-то
[02:21:44.460 --> 02:21:46.460]  дошли ребром
[02:21:46.460 --> 02:21:48.460]  до R+, ну, до этой вершины
[02:21:48.460 --> 02:21:50.460]  и не вышли.
[02:21:52.460 --> 02:21:54.460]  Ну, само по себе DFS...
[02:21:54.460 --> 02:21:56.460]  Нет, тут не с DFS
[02:21:56.460 --> 02:21:58.460]  противоречие.
[02:21:58.460 --> 02:22:00.460]  То есть DFS-а-то...
[02:22:00.460 --> 02:22:02.460]  Тут противоречие в другом.
[02:22:02.460 --> 02:22:04.460]  Смотрите.
[02:22:04.460 --> 02:22:06.460]  Предположим, вершина лежит в R+.
[02:22:06.460 --> 02:22:08.460]  И предположим, что она
[02:22:08.460 --> 02:22:10.460]  в просочетании не лежит.
[02:22:10.460 --> 02:22:12.460]  Тогда получается, что мы
[02:22:12.460 --> 02:22:14.460]  до нее дошли
[02:22:14.460 --> 02:22:16.460]  из какой-то вершины левой доли
[02:22:16.460 --> 02:22:18.460]  не покрытой просочетанием.
[02:22:18.460 --> 02:22:20.460]  Как называется
[02:22:20.460 --> 02:22:22.460]  путь, по которому мы это сделали?
[02:22:22.460 --> 02:22:24.460]  Совершенно верно.
[02:22:24.460 --> 02:22:26.460]  Это называется удлиняющая цепь,
[02:22:26.460 --> 02:22:28.460]  и это тогда давало бы нам информацию
[02:22:28.460 --> 02:22:30.460]  о том, что просочетание не максимально,
[02:22:30.460 --> 02:22:32.460]  вот мы, кстати, впервые этим воспользовались.
[02:22:32.460 --> 02:22:34.460]  Обратите внимание.
[02:22:34.460 --> 02:22:36.460]  Так что, получили противоречие.
[02:22:36.460 --> 02:22:38.460]  Следовательно, R+, либо просочетание
[02:22:38.460 --> 02:22:40.460]  не максимально, либо
[02:22:40.460 --> 02:22:42.460]  из каждой вершины R+,
[02:22:42.460 --> 02:22:44.460]  просочетание ребра торки.
[02:22:44.460 --> 02:22:46.460]  Ну, все, что нам остается, это
[02:22:46.460 --> 02:22:48.460]  показать, что не существует
[02:22:48.460 --> 02:22:50.460]  вот ребра из просочетания,
[02:22:50.460 --> 02:22:52.460]  которая соединяет
[02:22:52.460 --> 02:22:54.460]  вершину из R+,
[02:22:58.460 --> 02:23:00.460]  с вершиной
[02:23:04.460 --> 02:23:06.460]  из L-.
[02:23:10.460 --> 02:23:12.460]  Ну, опять ребра, ведущая из
[02:23:12.460 --> 02:23:14.460]  вершины, посещенной ДФС, вершины,
[02:23:14.460 --> 02:23:16.460]  не посещенной ДФС, опять предъятина.
[02:23:18.460 --> 02:23:20.460]  Таким образом, мы показали,
[02:23:20.460 --> 02:23:22.460]  что все эти
[02:23:22.460 --> 02:23:24.460]  вершины лежат на ноте,
[02:23:24.460 --> 02:23:26.460]  что, действительно, это
[02:23:26.460 --> 02:23:28.460]  покрывающее множество,
[02:23:28.460 --> 02:23:30.460]  все эти вершины лежат в просочетании,
[02:23:30.460 --> 02:23:32.460]  и на каждом ребре просочетания,
[02:23:32.460 --> 02:23:34.460]  ну, максимально имеется в виду,
[02:23:34.460 --> 02:23:36.460]  лежит из этих вершин
[02:23:36.460 --> 02:23:38.460]  ровно одна.
[02:23:38.460 --> 02:23:40.460]  Что означает,
[02:23:40.460 --> 02:23:42.460]  что это действительно...
[02:23:42.460 --> 02:23:44.460]  А еще мы доказали, что это вершинное покрытие.
[02:23:44.460 --> 02:23:46.460]  Значит, это и означает, что мы нашли
[02:23:46.460 --> 02:23:48.460]  вершинное покрытие минимально
[02:23:48.460 --> 02:23:50.460]  возможного размера.
[02:23:50.460 --> 02:23:52.460]  Ну, в смысле, меньше деньги.
[02:23:56.460 --> 02:23:58.460]  Ну, и автоматически там максимально
[02:23:58.460 --> 02:24:00.460]  исходить. Так что вот, собственно,
[02:24:00.460 --> 02:24:02.460]  приятно
[02:24:02.460 --> 02:24:04.460]  прямо за ОАДЕЙ нашли.
[02:24:08.460 --> 02:24:10.460]  Коротко можно еще раз прибежать сюда?
[02:24:12.460 --> 02:24:14.460]  Вот там, где мы
[02:24:14.460 --> 02:24:16.460]  говорили,
[02:24:18.460 --> 02:24:20.460]  вот такая скороткая получка.
[02:24:20.460 --> 02:24:22.460]  А ведь просочетание,
[02:24:22.460 --> 02:24:24.460]  сколько угодно.
[02:24:24.460 --> 02:24:26.460]  А это не важно. Я сказал, когда я говорю ОАДЕЙ,
[02:24:26.460 --> 02:24:28.460]  я не веду следующее. Если вам дал вот дольные гафы
[02:24:28.460 --> 02:24:30.460]  просочетания в нем, то вот это вот
[02:24:30.460 --> 02:24:32.460]  вы находите за ОАДЕЙ.
[02:24:32.460 --> 02:24:34.460]  То есть, по сравнению с подпросочетанием,
[02:24:34.460 --> 02:24:36.460]  вы делаете ОАДЕЙ дополнительно.
[02:24:36.460 --> 02:24:38.460]  Это все, что я управляю.
[02:24:38.460 --> 02:24:40.460]  Так, ну, значит,
[02:24:40.460 --> 02:24:42.460]  давайте, значит,
[02:24:42.460 --> 02:24:44.460]  алгоритм. Значит, берем максимальное
[02:24:44.460 --> 02:24:46.460]  просочетание, ориентируем его вправо,
[02:24:46.460 --> 02:24:48.460]  все остальные... Вон, обратно.
[02:24:48.460 --> 02:24:50.460]  Просочетание ориентируем влево, остальное
[02:24:50.460 --> 02:24:52.460]  все ориентируем слева-направо.
[02:24:52.460 --> 02:24:54.460]  Вот.
[02:24:54.460 --> 02:24:56.460]  Берем все вершины, не покрытые просочетанием,
[02:24:56.460 --> 02:24:58.460]  влево и доль, и
[02:24:58.460 --> 02:25:00.460]  запускаем из них DFS.
[02:25:00.460 --> 02:25:02.460]  Обоснащаем вершины в левой и правой
[02:25:02.460 --> 02:25:04.460]  долях, покрытые,
[02:25:04.460 --> 02:25:06.460]  то есть, до которых DFS дошел,
[02:25:06.460 --> 02:25:08.460]  за L+, L+.
[02:25:08.460 --> 02:25:10.460]  Остальные вершины L- и L+.
[02:25:12.460 --> 02:25:14.460]  И теперь я утверждаю, что
[02:25:14.460 --> 02:25:16.460]  если мы возьмем множество L-
[02:25:16.460 --> 02:25:18.460]  объединенных с R+,
[02:25:18.460 --> 02:25:20.460]  то это будет в точности
[02:25:20.460 --> 02:25:22.460]  вершинное покрытие размера 5.
[02:25:22.460 --> 02:25:24.460]  Доказательства.
[02:25:24.460 --> 02:25:26.460]  Во-первых, это
[02:25:26.460 --> 02:25:28.460]  вершинное покрытие.
[02:25:28.460 --> 02:25:30.460]  Почему?
[02:25:30.460 --> 02:25:32.460]  Пусть это не так, тогда
[02:25:32.460 --> 02:25:34.460]  найдется ребро, которое соединяет
[02:25:34.460 --> 02:25:36.460]  L+, R- или наоборот.
[02:25:36.460 --> 02:25:38.460]  Но L+, R-
[02:25:38.460 --> 02:25:40.460]  оно соединять не может, потому что
[02:25:40.460 --> 02:25:42.460]  не может из вершины
[02:25:42.460 --> 02:25:44.460]  обойденной DFS
[02:25:44.460 --> 02:25:46.460]  торчать в вершину не обойденной DFS.
[02:25:46.460 --> 02:25:48.460]  А в другую сторону
[02:25:48.460 --> 02:25:50.460]  быть не может, потому что
[02:25:50.460 --> 02:25:52.460]  мы в эту вершину могли попасть
[02:25:52.460 --> 02:25:54.460]  только по этому ребру.
[02:25:54.460 --> 02:25:56.460]  DFS на прямую не запускался
[02:25:56.460 --> 02:25:58.460]  по определению, но попасть в эту
[02:25:58.460 --> 02:26:00.460]  вершину мы можем прийти
[02:26:00.460 --> 02:26:02.460]  только по этому ребру, других ребров
[02:26:02.460 --> 02:26:04.460]  у нас сюда не входит.
[02:26:04.460 --> 02:26:06.460]  Поэтому это
[02:26:06.460 --> 02:26:08.460]  минимальное покрытие.
[02:26:08.460 --> 02:26:10.460]  Почему оно минимальное?
[02:26:10.460 --> 02:26:12.460]  Потому что
[02:26:12.460 --> 02:26:14.460]  я утверждаю, что
[02:26:14.460 --> 02:26:16.460]  все эти вершины принадлежат
[02:26:16.460 --> 02:26:18.460]  просочетанию
[02:26:18.460 --> 02:26:20.460]  максимальному нашему.
[02:26:20.460 --> 02:26:22.460]  Причем более того
[02:26:24.460 --> 02:26:26.460]  в каждом ребре
[02:26:26.460 --> 02:26:28.460]  ровно одна из вершин
[02:26:28.460 --> 02:26:30.460]  лежит в этом ножестве.
[02:26:32.460 --> 02:26:34.460]  Из этого и следует.
[02:26:34.460 --> 02:26:36.460]  Если мы это докажем,
[02:26:36.460 --> 02:26:38.460]  то на этом доказательство закончится,
[02:26:38.460 --> 02:26:40.460]  потому что из этого и будет следует,
[02:26:40.460 --> 02:26:42.460]  что их ровно пердежа.
[02:26:42.460 --> 02:26:44.460]  Этот момент понятен?
[02:26:44.460 --> 02:26:46.460]  Да.
[02:26:46.460 --> 02:26:48.460]  У нас их две.
[02:26:52.460 --> 02:26:54.460]  Теперь надо оказать,
[02:26:54.460 --> 02:26:56.460]  что каждый из них имеет отношение
[02:26:56.460 --> 02:26:58.460]  к просочетанию.
[02:26:58.460 --> 02:27:00.460]  Почему имеет отношение к просочетанию?
[02:27:00.460 --> 02:27:02.460]  Вершины L- имеют
[02:27:02.460 --> 02:27:04.460]  отношение к просочетанию
[02:27:04.460 --> 02:27:06.460]  просто потому что все вершины
[02:27:06.460 --> 02:27:08.460]  левой доли, которые не имеют отношения
[02:27:08.460 --> 02:27:10.460]  к просочетанию, из них DFS запускался.
[02:27:12.460 --> 02:27:14.460]  Поэтому это точно.
[02:27:14.460 --> 02:27:16.460]  Здесь все хитрее.
[02:27:18.460 --> 02:27:20.460]  Здесь уже все увязывается в то,
[02:27:20.460 --> 02:27:22.460]  что если у вас нашлась в правой доле
[02:27:22.460 --> 02:27:24.460]  вершина не покрытая просочетанием,
[02:27:24.460 --> 02:27:26.460]  до которой дотянулся DFS,
[02:27:26.460 --> 02:27:28.460]  то это значит, что в процессе
[02:27:28.460 --> 02:27:30.460]  этого DFS
[02:27:30.460 --> 02:27:32.460]  вы запустили DFS из какой-то
[02:27:32.460 --> 02:27:34.460]  вершины левой доли
[02:27:34.460 --> 02:27:36.460]  и дошли до вершины
[02:27:36.460 --> 02:27:38.460]  не покрытой просочетанием
[02:27:38.460 --> 02:27:40.460]  и дошли до какой-то вершины правой доли
[02:27:40.460 --> 02:27:42.460]  не покрытой просочетанием.
[02:27:42.460 --> 02:27:44.460]  Притиморичит факту,
[02:27:44.460 --> 02:27:46.460]  что просочетание максимально.
[02:27:46.460 --> 02:27:48.460]  Потому что это просто
[02:27:48.460 --> 02:27:50.460]  удлиняющая цепь явно.
[02:27:50.460 --> 02:27:52.460]  Следовательно, да, эти вершины
[02:27:52.460 --> 02:27:54.460]  имеют отношение к просочетанию.
[02:27:54.460 --> 02:27:56.460]  Остается только показать,
[02:27:56.460 --> 02:27:58.460]  что ни на одном ребре
[02:27:58.460 --> 02:28:00.460]  просочетания нет
[02:28:00.460 --> 02:28:02.460]  двух вершин из этого проста.
[02:28:02.460 --> 02:28:04.460]  Но это как раз просто.
[02:28:04.460 --> 02:28:06.460]  Тогда у нас справа есть
[02:28:06.460 --> 02:28:08.460]  вершина, которую DFS прошел,
[02:28:08.460 --> 02:28:10.460]  и из нее справа налево ведет ребро
[02:28:10.460 --> 02:28:12.460]  вершину, которую DFS не прошел.
[02:28:12.460 --> 02:28:14.460]  Притиморичить уже со смыслами DFS.
[02:28:14.460 --> 02:28:16.460]  Все.
