[00:00.000 --> 00:14.000]  Смотрите, мы обсудили все, что связано с полимональным временем для разных вычислительных моделей,
[00:14.000 --> 00:19.000]  детерминированных машин, недетерминированных и альтернирующих.
[00:19.000 --> 00:29.000]  Но с альтернирующими у нас было ограничение, как получалась полимональная аархия,
[00:29.000 --> 00:37.000]  что число перемен метки на состоянии не больше, чем некоторая константа к, независящая от длины х.
[00:37.000 --> 00:45.000]  Что будет, если мы снимем это ограничение, и перемен может быть сколько угодно.
[00:45.000 --> 00:54.000]  Этот класс будет называться ap, альтернирующая машина, полимональное время.
[00:54.000 --> 01:03.000]  И на самом деле это будет то же самое, что ap-space означает полимональная память.
[01:03.000 --> 01:09.000]  Соответственно, мы плавно перетекаем от измерения времени к измерению памяти.
[01:09.000 --> 01:19.000]  Это утверждение на самом деле теорема. В какой-то момент можно обсудить, почему это так.
[01:19.000 --> 01:27.000]  Но начну я с того, что мы обсудим, как вообще измерять использованную память.
[01:27.000 --> 01:37.000]  Пока нет, не определяли. Чтобы определить ap-space, нужно сначала сказать, как вообще измеряется память.
[01:37.000 --> 01:42.000]  Смотрите, у машины теоринга есть элементарная ячейка памяти.
[01:42.000 --> 01:51.000]  Это ячейка на ленте. Ячейка на ленте.
[01:51.000 --> 02:00.000]  Ячейка на ленте это единица используемой памяти.
[02:00.000 --> 02:06.000]  Вообще в начале чуть-чуть обсудить, почему нас вообще интересует используемая память.
[02:06.000 --> 02:16.000]  Может быть несколько причин. Во-первых, за память надо платить.
[02:16.000 --> 02:27.000]  Особенно это было верно 50 лет назад. 50 лет назад память просто по цене составляла подавляющую часть компьютера.
[02:27.000 --> 02:33.000]  То есть если вам нужен был компьютер с в два раза больше памяти, то почти в два раза больше и нужно было за него заплатить.
[02:33.000 --> 02:41.000]  Поэтому чтобы потратить меньше, а вычислить больше, надо придумывать алгоритмы, которые используют мало памяти.
[02:41.000 --> 02:46.000]  Даже если будет некоторый прогресс по времени.
[02:46.000 --> 02:54.000]  Эта причина сейчас гораздо менее важна, но все равно остается вторая причина.
[02:54.000 --> 02:59.000]  Как устроена память в реальном компьютере? Есть несколько уровней.
[02:59.000 --> 03:08.000]  Есть регистры процессора, несколько уровней кэша, есть оперативная память, есть жесткий диск, есть какое-нибудь облако.
[03:08.000 --> 03:17.000]  И каждый раз на каждом следующем уровне будет больше памяти, но дольше обращение к этой памяти.
[03:17.000 --> 03:24.000]  Получается, что если вся программа уменьшается в более маленькую память, то получается более быстрое обращение к этой памяти.
[03:24.000 --> 03:32.000]  И поэтому программа работает быстрее. Даже если шагов будет там немножко больше, но за счет того, что каждый элементарный шаг будет более быстрым,
[03:32.000 --> 03:36.000]  за счет более близкой памяти, в общее время будет меньше.
[03:36.000 --> 03:44.000]  Так что так или иначе память связана со временем и со стоимостью.
[03:44.000 --> 03:54.000]  Дальше у нас есть второй вопрос. А что нужно измерять? Какие ячейки?
[03:54.000 --> 04:01.000]  Простой ответ, что все куда указывает, то и измеряем.
[04:01.000 --> 04:12.000]  Но представьте, что у вас программа это поиск какого-то слова в текстовых файлах.
[04:12.000 --> 04:19.000]  И пусть у вас весь диск забит этими текстовыми файлами, и вам нужно какое-то слово там найти.
[04:19.000 --> 04:26.000]  Во-первых, в процессе поиска этого слова нельзя эти файлы менять.
[04:26.000 --> 04:33.000]  Если вход это все эти файлы, то в процессе поиска нужного слова нельзя там ничего редактировать.
[04:33.000 --> 04:37.000]  Это будет неправильная программа, если она так будет делать.
[04:38.000 --> 04:43.000]  Во-вторых, если у вас уже почти весь диск забит этими файлами,
[04:43.000 --> 04:51.000]  то используемая память должна быть сильно меньше, чем сам массив, которым вы ищете.
[04:51.000 --> 04:58.000]  Вот отсюда получается концепция, во-первых, неизменяемого входа.
[04:58.000 --> 05:16.000]  Ключевые аспекты определения это, во-первых, неизменяемый вход.
[05:16.000 --> 05:25.000]  Во-вторых, считаются дополнительные ячейки памяти по сравнению со входом.
[05:26.000 --> 05:36.000]  Считаются дополнительные ячейки памяти.
[05:44.000 --> 05:51.000]  Те ячейки, в которых записан вход, не редактируются.
[05:51.000 --> 05:57.000]  Проще всего это моделировать через две ленты.
[05:57.000 --> 06:10.000]  Есть одна лента, которая только для чтения, read-only.
[06:10.000 --> 06:16.000]  И вторая лента для чтения и записи.
[06:17.000 --> 06:22.000]  Рабочая лента.
[06:22.000 --> 06:28.000]  Давайте я условно напишу work.
[06:28.000 --> 06:34.000]  И, как всегда, управляющая машина имеет два указателя.
[06:34.000 --> 06:39.000]  На ячейку здесь и на ячейку здесь.
[06:39.000 --> 06:47.000]  По первой ленте будем бегать туда-сюда.
[06:47.000 --> 06:52.000]  Но это же влияет только на время работы.
[06:52.000 --> 06:58.000]  А на память это совсем не влияет, тем более, если эта лента входная и неизменяемая.
[06:58.000 --> 07:04.000]  На самом деле, если это PSPACE, то это неважно.
[07:05.000 --> 07:13.000]  Но бывают модели со сверхмалой памятью.
[07:13.000 --> 07:19.000]  Когда здесь логарифмическая память, типичная ситуация.
[07:19.000 --> 07:25.000]  Здесь длина A, а здесь длина логарифмы.
[07:25.000 --> 07:33.000]  Тогда очень важно, что вход неизменяемый, что считаем только дополнительную память.
[07:33.000 --> 07:42.000]  Это позволяет обредить класс SPACE от S от N.
[07:42.000 --> 07:58.000]  Это получается класс языков распознаваемых на памяти.
[07:58.000 --> 08:08.000]  Я явно напишу на дополнительной памяти O от S от N.
[08:08.000 --> 08:15.000]  Распознаваемых означает, что всегда будет правильный ответ.
[08:15.000 --> 08:23.000]  Если х лежит в языке, то будет ответ «да», если х не лежит, то будет ответ «нет».
[08:23.000 --> 08:28.000]  Тогда число дополнительных ячеек вот такое.
[08:28.000 --> 08:33.000]  Какая-то константа на S от длины х.
[08:33.000 --> 08:37.000]  Ну хорошо.
[08:37.000 --> 08:42.000]  Тут лучше буквку D добавить.
[08:42.000 --> 08:48.000]  Можно и так, D, чтобы подчеркнуть, что машины детерминированы.
[08:48.000 --> 08:57.000]  Бывает N SPACE от S от N.
[08:57.000 --> 09:04.000]  Но это тоже самое аналогично, но на недетерминированной машине.
[09:04.000 --> 09:08.000]  Сейчас немножко обсудим, что это значит.
[09:08.000 --> 09:17.000]  На недетерминированной машине.
[09:17.000 --> 09:21.000]  Что это означает?
[09:21.000 --> 09:25.000]  Это означает, что функция перехода неоднозначна.
[09:25.000 --> 09:32.000]  Но все равно на всех ветвях будет дополнительной памяти не больше, чем у большой от S от N.
[09:32.000 --> 09:37.000]  Ну и определение, как обычно. Если есть ветка, приводящая к единицу, то общий ответ – единица.
[09:37.000 --> 09:42.000]  Если все ветви приводят к ноль, то общий ответ – ноль.
[09:42.000 --> 09:46.000]  Так, хорошо.
[09:46.000 --> 09:55.000]  Дальше можно разные конкретные функции подставлять, и некоторые классы будут получаться.
[09:55.000 --> 10:06.000]  Будет класс L. L – это D SPACE от logarithm N.
[10:06.000 --> 10:11.000]  Дополнительная память – логарифмическая.
[10:11.000 --> 10:22.000]  Дальше есть N L. Это N SPACE от logarithm N.
[10:22.000 --> 10:29.000]  Кстати, фишка вот этих обозначений в том, что не нужно описать, по какому основанию логарифм.
[10:29.000 --> 10:35.000]  Если будет другое основание, то будет другая константа. В большом логарифме останется.
[10:35.000 --> 10:50.000]  Дальше есть класс poly L. Это D SPACE от полинома от логарифма.
[10:55.000 --> 11:01.000]  Можно, в принципе, посмотреть N poly L, но это вообще никто не пишет.
[11:01.000 --> 11:07.000]  Дальше есть P SPACE.
[11:07.000 --> 11:19.000]  P SPACE – это D SPACE от полинома от N.
[11:19.000 --> 11:27.000]  Это обычно записывается, это объединение по всем степеням D SPACE от N в такой степени.
[11:27.000 --> 11:32.000]  N P SPACE.
[11:32.000 --> 11:40.000]  Это N SPACE от полинома.
[11:40.000 --> 11:45.000]  Еще бывает EXP SPACE.
[11:45.000 --> 11:56.000]  Это, соответственно, D SPACE от экспонента.
[11:56.000 --> 12:00.000]  Дайте я напишу 2 в степени полинома от N.
[12:00.000 --> 12:05.000]  Наверное, может быть и E SPACE, где 2 в степеньом большой от N.
[12:05.000 --> 12:20.000]  На самом деле, если для времени был важнейший вопрос, равны ли P и N P, то здесь вопроса про P SPACE и N P SPACE нет.
[12:20.000 --> 12:24.000]  Они будут равны. Мы это сейчас скоро докажем.
[12:24.000 --> 12:34.000]  И также и для экспоненты, и для линейной экспоненты, и даже для полилогарифма, и только для L ENL.
[12:34.000 --> 12:36.000]  Это вопрос открыт.
[12:36.000 --> 12:44.000]  Аналогом вопроса про P и N P для пространственной сложности будет вопрос про L ENL.
[12:44.000 --> 12:50.000]  Сейчас мы с этим разберемся.
[12:50.000 --> 12:55.000]  Давайте сначала посмотрим на простые вложения.
[12:55.000 --> 13:00.000]  Есть магистральная линия вложений.
[13:04.000 --> 13:09.000]  Давайте начнем с совсем простых вещей.
[13:09.000 --> 13:24.000]  Утверждение 1, что L вложено в P, и аналогично P SPACE вложено в эксп.
[13:24.000 --> 13:32.000]  Ну а там эксп SPACE будет в E эксп, но это уж ладно. Все аналогично делается.
[13:32.000 --> 13:37.000]  Смотрите, это фактически по принципу Дерехлей делается.
[13:37.000 --> 13:42.000]  Потому что надо посчитать общее число конфигураций.
[13:42.000 --> 13:57.000]  Общее число конфигураций машины Тьюринга. Какое?
[13:57.000 --> 14:12.000]  Давайте для простоты считать, что на этой входной ленте еще и нельзя за пределы входа выходить.
[14:12.000 --> 14:17.000]  Если можно, все равно будет верно, но там уже какие-то полигические случаи рассматривать.
[14:17.000 --> 14:22.000]  Если мы будем считать, что нельзя за пределы входной ленты выходить,
[14:22.000 --> 14:30.000]  то, наверное, нужно переделать программу, которая выходит, в какую-то программу, которая не выходит.
[14:30.000 --> 14:36.000]  Потому что если она ушла слишком далеко, то там ничего...
[14:36.000 --> 14:40.000]  Ну вообще интуитивно, ясно, что не зачем дотуда выходить, там все равно ничего записать нельзя.
[14:40.000 --> 14:43.000]  И мы знаем, что там будет.
[14:43.000 --> 14:51.000]  Наверное, нужно будет сказать, что если мы уходим, то вместо этого мы забудем счетчик, который показывает, насколько мы ушли.
[14:51.000 --> 14:57.000]  Если бы назад возвращались, счетчик скручиваем обратно, там что-нибудь такое надо придумать.
[14:57.000 --> 15:00.000]  Вот.
[15:04.000 --> 15:09.000]  Считаем те, которые посетили на рабочей ленте.
[15:09.000 --> 15:19.000]  Либо можно сказать, что если мы на лишнюю ячейку на входной пришли, то мы ее тоже считаем в память.
[15:19.000 --> 15:24.000]  Это все какие-то усложнения технические.
[15:24.000 --> 15:29.000]  Скажем по-простому, что мы просто не выходим за пределы входа на входной ленте.
[15:29.000 --> 15:31.000]  УБР.
[15:31.000 --> 15:33.000]  Чего?
[15:33.000 --> 15:35.000]  УБР.
[15:35.000 --> 15:37.000]  В смысле?
[15:37.000 --> 15:39.000]  Нехорректная программа.
[15:39.000 --> 15:41.000]  Ну ладно.
[15:41.000 --> 15:43.000]  Ладно.
[15:43.000 --> 15:47.000]  Какое будет число конфигураций?
[15:47.000 --> 15:49.000]  Значит, у нас будет...
[15:49.000 --> 15:58.000]  И дай считать, что вот эсатен это прямо в точности, сколько мы используем ячеек.
[15:58.000 --> 16:03.000]  Во-первых, у нас есть содержимые рабочей ленты.
[16:03.000 --> 16:08.000]  И сигма или сейчас гамма, наверное.
[16:08.000 --> 16:13.000]  Обычно сигма это алфавит входа, а гамма это алфавит на ленте.
[16:13.000 --> 16:18.000]  Соответственно, может быть, размер гамма разных символов в каждой ячейке.
[16:18.000 --> 16:22.000]  Соответственно, эта гамма нужно возвести в степени эсатен.
[16:22.000 --> 16:28.000]  Вот это число вариантов заполнения рабочей ленты.
[16:28.000 --> 16:37.000]  Значит, умножить на число состояний, умножить на число положения указателя на первой ленте
[16:37.000 --> 16:42.000]  и умножить на число положения указателя на второй ленте.
[16:46.000 --> 16:48.000]  Понятно, да?
[16:48.000 --> 16:50.000]  У нас рабочая лента ровно одна.
[16:50.000 --> 16:56.000]  Да, дай считать, что ровно одна рабочая лента, и ровно эсатен ячеек мы там используем, чтобы не усложнять.
[16:59.000 --> 17:02.000]  N это число положений указателей на первой ленте.
[17:02.000 --> 17:06.000]  Первой ленту мы не изменяем, но мы можем по ней двигаться туда-сюда.
[17:06.000 --> 17:08.000]  N это значит, что это размер хода.
[17:08.000 --> 17:10.000]  N размер хода, да.
[17:10.000 --> 17:15.000]  N размер хода, а эсатен это размер памяти выделенной, дополнительной.
[17:15.000 --> 17:20.000]  Два указателя состояния и слова на рабочей ленте.
[17:23.000 --> 17:28.000]  Соответственно, число шагов будет не больше, чем это число конфигураций.
[17:31.000 --> 17:38.000]  Значит, число шагов не больше, чем число конфигураций.
[17:39.000 --> 17:46.000]  Ну а дальше нужно увидеть, что если эсатен от логарифм, тогда это штука полином.
[17:46.000 --> 17:49.000]  Если эсатен от полином, тогда это штука от экспонента.
[17:49.000 --> 17:56.000]  А это по принципу Дерехлия, что если конфигурация повторилась, то все, машина зациклилась и никогда не остановится.
[17:58.000 --> 18:00.000]  Ну вот все и получается.
[18:00.000 --> 18:20.000]  Если эсатен это большой от логарифма, то тогда получается вот это вот число конфигураций полином от N.
[18:20.000 --> 18:22.000]  И время соответственно тоже.
[18:22.000 --> 18:24.000]  А гамма это рабочий алфавит?
[18:24.000 --> 18:27.000]  Да, гамма это ленточный алфавит машины Тьюринга.
[18:27.000 --> 18:36.000]  Если эсатен полином, то тогда здесь будет экспонента.
[18:36.000 --> 18:39.000]  Ну и отсюда это и получается.
[18:43.000 --> 18:46.000]  Так, хорошо.
[18:48.000 --> 18:52.000]  Значит, утверждение 2. NL тоже вложено в P.
[18:57.000 --> 19:09.000]  Тут уже так просто не получится. Нужно некоторые рассуждения.
[19:09.000 --> 19:16.000]  Смотрите, мы рассмотрим конфигурационный граф.
[19:16.000 --> 19:23.000]  Именно вершины будут всей конфигурации, а ребрами корректные переходы.
[19:24.000 --> 19:42.000]  В случае детерминированной машины это будет такое обратное дерево, что раздвоиться не может, а сойтись могут.
[19:42.000 --> 19:48.000]  Из каждой вершины одна стрелка и точно нет циклов.
[19:48.000 --> 19:51.000]  Входящее дерево это называется.
[19:51.000 --> 19:58.000]  Ну точнее лес, если все раз рассмотреть, то они не обязательно все в одну сойдутся.
[19:58.000 --> 20:02.000]  В общем, входящее лес такое получается.
[20:02.000 --> 20:07.000]  Если это произвольная нетерминированная машина, то они могут раздвоиваться.
[20:07.000 --> 20:15.000]  Но все-таки давайте считать, что она не зацикливается никогда.
[20:15.000 --> 20:19.000]  Все-таки на каждой ветве есть ответ.
[20:19.000 --> 20:22.000]  Зациклов могут быть, главное, чтобы был дыхатель.
[20:22.000 --> 20:24.000]  Да, считать, что не будет.
[20:24.000 --> 20:27.000]  Но это правильно, что можно рассматривать циклы тоже.
[20:27.000 --> 20:30.000]  Давайте для простыды считать, что вообще не будет циклов.
[20:30.000 --> 20:33.000]  Там могут вылезти какие-то сюрпризы.
[20:33.000 --> 20:35.000]  А если есть цикл, то существует бесконечный столб?
[20:35.000 --> 20:38.000]  Если есть цикл, то есть бесконечная ветка, и не понятно, что с ней делать.
[20:38.000 --> 20:42.000]  А если есть бесконечный столб, то это уже происходящее?
[20:42.000 --> 20:47.000]  Ну нет, это время будет бесконечное, а память будет конечная за счет зацикл.
[20:47.000 --> 20:50.000]  А, нет, тогда она не смогла быть ответной.
[20:50.000 --> 20:56.000]  Мы уже договорились, что в конце каждой ветки лежит либо один, либо ноль.
[20:56.000 --> 21:02.000]  Если там не лежит ответ, то мы, видимо, не можем посчитать определенные изменения.
[21:02.000 --> 21:06.000]  На самом деле, это зациклевание можно отслеживать.
[21:06.000 --> 21:09.000]  Можно вести счетчик, сколько мы шагов сделали.
[21:09.000 --> 21:13.000]  И этот счетчик нам удвоит память.
[21:13.000 --> 21:17.000]  Но если он превысит нужный порог, то мы поймем, что мы зацикливались
[21:17.000 --> 21:21.000]  и директивно прекратим учление с ответом ноль.
[21:30.000 --> 21:33.000]  Будем считать, что ничего не зацикливается.
[21:39.000 --> 21:44.000]  Да, давайте считать, что на каждой ветке есть ответ.
[21:44.000 --> 21:50.000]  Если на одной ветке нет ответа, то у всей машины нет ответа.
[21:56.000 --> 21:59.000]  Но дальше можно любую машину преобразовать новую,
[21:59.000 --> 22:03.000]  где ответ будет на каждой ветке, и все единицы сохранятся.
[22:04.000 --> 22:08.000]  Мы рассматриваем конфигурационный граф.
[22:15.000 --> 22:18.000]  Вершины – это конфигурация.
[22:21.000 --> 22:27.000]  Ребра – это корректные переходы.
[22:27.000 --> 22:31.000]  И добавим в него еще одну виртуальную вершину,
[22:31.000 --> 22:34.000]  универсальную принимающую вершину.
[22:34.000 --> 22:40.000]  Если машина закончила работу в принимающем состоянии,
[22:40.000 --> 22:44.000]  то еще одно ребро вот в эту универсальную принимающую вершину.
[22:46.000 --> 22:52.000]  Плюс универсальная принимающая вершина.
[22:57.000 --> 23:02.000]  И тогда что получается?
[23:02.000 --> 23:07.000]  Вопрос о том, будет ли ответ принимающим,
[23:07.000 --> 23:11.000]  то есть m от x равно единице,
[23:11.000 --> 23:18.000]  если есть ориентированный путь
[23:18.000 --> 23:23.000]  из стартовой конфигурации.
[23:23.000 --> 23:27.000]  Вот в эту универсальную принимающую.
[23:33.000 --> 23:37.000]  А дальше смотрите, если память логарифмическая,
[23:37.000 --> 23:41.000]  то в графе поляном вершин.
[23:41.000 --> 23:45.000]  Ну а для поляного графа эту задачу вы умеете решать наверняка.
[23:45.000 --> 23:48.000]  Это задача о поиске пути в орграфе.
[23:48.000 --> 23:52.000]  Получаем, что если s от n, то большая от логарифма...
[23:52.000 --> 23:56.000]  Нет, сейчас нет.
[23:56.000 --> 24:00.000]  Нет, если мы решили логариф памяти,
[24:00.000 --> 24:04.000]  то мы можем доказать, что n или равно l.
[24:04.000 --> 24:07.000]  Но это никто не умеет.
[24:07.000 --> 24:11.000]  Мы доказываем, что можно решить по логарифму памяти.
[24:11.000 --> 24:15.000]  Но если мы решим по логарифму памяти,
[24:15.000 --> 24:19.000]  то на самом деле это очень интересная вещь.
[24:19.000 --> 24:23.000]  Потому что достижение уже XXI века,
[24:23.000 --> 24:27.000]  что если у вас неориентированный граф,
[24:27.000 --> 24:31.000]  то там задачу о достижимости можно решать с логарифмической памяти.
[24:31.000 --> 24:35.000]  Но если мы решим по логарифму памяти,
[24:35.000 --> 24:39.000]  то мы не сможем решить по логарифму памяти.
[24:39.000 --> 24:43.000]  Но если мы решим по логарифму памяти,
[24:43.000 --> 24:47.000]  то на месте можно решать с логарифмической памятью.
[24:47.000 --> 24:51.000]  Если бы для ориентированного можно было, тогда бы l равнялся nl.
[24:51.000 --> 24:55.000]  Но это пока никто не умеет.
[24:55.000 --> 24:59.000]  Нет, ну подождите. Если логарифмическая память,
[24:59.000 --> 25:03.000]  то поляном времени автоматически.
[25:07.000 --> 25:11.000]  Так, давайте я запишу.
[25:11.000 --> 25:15.000]  Мы решим граф поляномиального размера,
[25:15.000 --> 25:19.000]  и путь можно найти
[25:27.000 --> 25:31.000]  за поляномальное время.
[25:41.000 --> 25:45.000]  Ну вот, значит nl получается тоже
[25:45.000 --> 25:49.000]  вложено в P.
[25:49.000 --> 25:53.000]  Аналогично, конечно, может сказать, что там NPSP,
[25:53.000 --> 25:57.000]  вложено в EXP и так далее.
[25:57.000 --> 26:01.000]  Так, хорошо.
[26:01.000 --> 26:05.000]  Значит, если также склеить
[26:05.000 --> 26:09.000]  с тем, что мы уже раньше знаем,
[26:09.000 --> 26:13.000]  то получается такая
[26:13.000 --> 26:17.000]  магистральная цепочка вложений.
[26:25.000 --> 26:29.000]  Глобальное утверждение 3 получается,
[26:29.000 --> 26:33.000]  что l вложено в nl,
[26:33.000 --> 26:37.000]  это вложено в P,
[26:37.000 --> 26:41.000]  это вложено в np,
[26:41.000 --> 26:45.000]  это вложено в ph,
[26:45.000 --> 26:49.000]  а сейчас это мы, наверное, не знаем еще, сейчас обсудим.
[26:49.000 --> 26:53.000]  Это вложено в pspace, дальше это вложено в npspace,
[26:53.000 --> 26:57.000]  значит, это дальше вложено в exp,
[26:57.000 --> 27:01.000]  это в nxp,
[27:01.000 --> 27:05.000]  значит, это в expspace
[27:05.000 --> 27:09.000]  и так далее. Тут еще, в принципе, экспедициональная иерархия
[27:09.000 --> 27:13.000]  тоже есть, но эту мы сейчас не будем обсуждать.
[27:13.000 --> 27:17.000]  Так, значит,
[27:17.000 --> 27:21.000]  первое, чего мы не знаем, это вот это вот.
[27:21.000 --> 27:25.000]  Значит, почему ph вложено в pspace?
[27:25.000 --> 27:29.000]  Так, дайте что-нибудь попроще.
[27:29.000 --> 27:33.000]  Почему np вложено в pspace?
[27:35.000 --> 27:39.000]  Значит, почему np вложено в pspace?
[27:39.000 --> 27:43.000]  Не просто за экспедиционное время
[27:43.000 --> 27:47.000]  можно все перебрать, а на понимание памяти.
[27:47.000 --> 27:51.000]  Но потому что в чем вообще фишка памяти, что ее можно освободить и переиспользовать.
[27:51.000 --> 27:55.000]  В этом ее отличие от времени. Время нельзя переиспользовать, оно ушло, и все.
[27:55.000 --> 27:59.000]  А память можно очистить и использовать заново.
[27:59.000 --> 28:03.000]  Ну и тогда тут получается
[28:03.000 --> 28:07.000]  что нужно вычислить память под перебор y
[28:07.000 --> 28:11.000]  и дальше выделить память
[28:11.000 --> 28:15.000]  под вычисление v от x и y.
[28:15.000 --> 28:19.000]  Вот. И дальше как организована работа?
[28:19.000 --> 28:23.000]  Что вот у нас есть какой-то первый y, так сказать, из всех нулей.
[28:23.000 --> 28:27.000]  Для этого y мы вычисляем v от x и y.
[28:27.000 --> 28:31.000]  Вот. И дальше как организована работа?
[28:31.000 --> 28:35.000]  Для этого y мы вычисляем v от x и y.
[28:35.000 --> 28:39.000]  Если подошло, то останавливаемся ответом 1.
[28:39.000 --> 28:43.000]  Если не подошло, то вот эту память освобождаем
[28:43.000 --> 28:47.000]  и здесь приходим к следующему. Все нули, а последние единицы.
[28:47.000 --> 28:51.000]  И дальше на той же самой памяти вычисляем v от x и y.
[28:51.000 --> 28:55.000]  Ну и так далее. Каждый раз на одной и той же памяти
[28:55.000 --> 28:59.000]  вот это вычисление происходит, а здесь итерируется y.
[28:59.000 --> 29:03.000]  Ну и так получается, что если в какой-то момент
[29:03.000 --> 29:07.000]  тут получилась единица, то мы останавливаемся ответом 1.
[29:07.000 --> 29:11.000]  А если дошли до последнего y и все нули, то останавливаемся ответом 0.
[29:11.000 --> 29:15.000]  Ну и память вот такая вот и получается.
[29:15.000 --> 29:19.000]  Так.
[29:19.000 --> 29:23.000]  Ну чего, понятно?
[29:23.000 --> 29:27.000]  Но с pH более-менее так же, только вложенный такой перебор будет.
[29:27.000 --> 29:31.000]  Значит, как получается, что pH...
[29:31.000 --> 29:35.000]  Почему pH вложено в p-space?
[29:35.000 --> 29:39.000]  Ну тут примерно так же, только тут перебор
[29:39.000 --> 29:43.000]  y1, дальше перебор
[29:43.000 --> 29:47.000]  y2.
[29:57.000 --> 30:01.000]  Сейчас.
[30:01.000 --> 30:05.000]  Сейчас обсудим. Значит, перебор y.
[30:05.000 --> 30:09.000]  И дальше соответственно вычисление
[30:09.000 --> 30:13.000]  v от x, y1 и так далее.
[30:17.000 --> 30:21.000]  Значит, смотрите, на самом деле
[30:21.000 --> 30:25.000]  можно считать, что длина вот этих вот y
[30:25.000 --> 30:29.000]  она... Некоторые фиксированы полиновой длиной x,
[30:29.000 --> 30:33.000]  и определяются вот этим вот алгоритмом v.
[30:33.000 --> 30:37.000]  Но потому что уж как... Уж по крайней мере эта длина
[30:37.000 --> 30:41.000]  будет не больше, чем время работы этого v.
[30:41.000 --> 30:45.000]  Вот, количество y... Значит, смотрите, в pH
[30:45.000 --> 30:49.000]  количество фиксировано.
[30:49.000 --> 30:53.000]  То есть полимиальная иерархия означает, что у нас k фиксировано.
[30:53.000 --> 30:57.000]  Может быть, сколько год нам большое, но фиксировано не зависит от x.
[30:57.000 --> 31:01.000]  Но на самом деле, если мы сделаем,
[31:01.000 --> 31:05.000]  что число этих k растущее
[31:05.000 --> 31:09.000]  и полимиально растущее, то это как раз ровно
[31:09.000 --> 31:13.000]  в p-space получится.
[31:13.000 --> 31:17.000]  А если фиксированы, то pH, которое вложено в p-space.
[31:17.000 --> 31:21.000]  Ну вот, организована работа
[31:21.000 --> 31:25.000]  примерно так же, как бы рекурсивно.
[31:25.000 --> 31:29.000]  Мы здесь перебираем для фиксированного y1, запускаем рекурсивно
[31:29.000 --> 31:33.000]  вот эту штуку, и значит, 2 кванторов на единицу меньше.
[31:33.000 --> 31:37.000]  Y2 и так далее. И дальше там,
[31:37.000 --> 31:41.000]  если был квантор всеобщности, то нужно
[31:41.000 --> 31:45.000]  дождаться до конца, проверить, что все единицы.
[31:45.000 --> 31:49.000]  А если хотя бы одна ноль, то остановить с ответом ноль.
[31:49.000 --> 31:53.000]  Вместо вызова.
[31:53.000 --> 31:57.000]  Вместо вызова, откуда вызвали это под программу.
[31:57.000 --> 32:01.000]  А если в кратном существовании, как в NP, то тогда наоборот.
[32:01.000 --> 32:05.000]  Если дошли до конца все нули, тогда ноль, а если где-то единицы,
[32:05.000 --> 32:09.000]  то отправляем единицу наверх.
[32:09.000 --> 32:13.000]  Главное, что каждый раз
[32:13.000 --> 32:17.000]  y-каты для, скажем, всех предыдущих
[32:17.000 --> 32:21.000]  фиксированных на одной той же памяти итерируется.
[32:21.000 --> 32:25.000]  Когда будет следующий y-1, то y-каты начинают снова со всех нулей.
[32:25.000 --> 32:29.000]  Нам еще нужно хранить результаты предыдущих участвений.
[32:29.000 --> 32:33.000]  Ну, конечно, да, там еще небольшая служебная память
[32:33.000 --> 32:37.000]  нужна, чтобы все это организовать.
[32:37.000 --> 32:41.000]  Хорошо, значит, ph положено в p-space, это
[32:41.000 --> 32:45.000]  положено в np-space.
[32:45.000 --> 32:49.000]  Остальное все из предыдущего получается.
[32:49.000 --> 32:53.000]  Ну, скажем, l положено в nl, просто потому что
[32:53.000 --> 32:57.000]  детерминированный, в частном случае, не детерминированный.
[32:57.000 --> 33:01.000]  Значит, p-space, np-space тоже.
[33:01.000 --> 33:05.000]  Прирыв надо делать? Или не обязательно?
[33:05.000 --> 33:09.000]  Не обязательно.
[33:09.000 --> 33:13.000]  Сейчас будет следующая теорема, что вот здесь
[33:13.000 --> 33:17.000]  на самом деле равенства.
[33:17.000 --> 33:21.000]  Я уже анонсировал ее, что p-space равняется np-space.
[33:21.000 --> 33:25.000]  Это называется теорема Сейвича.
[33:25.000 --> 33:29.000]  Теорема совершенно классическая еще с 70-х годов.
[33:29.000 --> 33:33.000]  Ей теорема довольно простая.
[33:37.000 --> 33:41.000]  И она еще более общая, более общая, чем
[33:41.000 --> 33:45.000]  просто то, что p-space равно np-space.
[33:45.000 --> 33:49.000]  Она вообще про связь детерминированной и нетерминированной модели
[33:49.000 --> 33:53.000]  в случае измерения памяти.
[33:53.000 --> 33:57.000]  А именно, что переход от недетерминированной модели
[33:57.000 --> 34:01.000]  к детерминированной памяти возводит в квадрат.
[34:01.000 --> 34:05.000]  Ну и как следствие получается, что квадрат полином
[34:05.000 --> 34:09.000]  и это полином.
[34:09.000 --> 34:13.000]  Полилогарифм и это полилогарифм.
[34:13.000 --> 34:17.000]  Поэтому n-полиэль это то же самое, что полиэль.
[34:17.000 --> 34:21.000]  А квадрат логарифма и квадрат логарифма.
[34:21.000 --> 34:25.000]  Поэтому про l и n-эль тут не получается.
[34:25.000 --> 34:29.000]  Вот теорема Сейвича,
[34:29.000 --> 34:33.000]  Уолтера Сейвича
[34:33.000 --> 34:37.000]  заключает в следующем, что если s от n, хотя бы логарифм,
[34:37.000 --> 34:41.000]  ну совсем сверхмалые
[34:41.000 --> 34:45.000]  ограничения на памяти повторного логарифма
[34:45.000 --> 34:49.000]  они дают просто автомат на языке.
[34:49.000 --> 34:53.000]  Да, тоже конечный автомат распознается.
[34:53.000 --> 34:57.000]  Но это если повторный логарифм, а если там какой-нибудь корень
[34:57.000 --> 35:01.000]  из логарифма, то там не понятно, что получится.
[35:01.000 --> 35:05.000]  В общем, если s от n больше того, что логарифм n,
[35:05.000 --> 35:09.000]  то получается, что n-space
[35:09.000 --> 35:13.000]  от s от n будет вложена
[35:13.000 --> 35:17.000]  в d-space
[35:17.000 --> 35:21.000]  от s от n в квадрате.
[35:25.000 --> 35:29.000]  Соответственно получаем следствие,
[35:29.000 --> 35:33.000]  что n-эль вложена в полиэль,
[35:33.000 --> 35:37.000]  да, квадрат логарифма
[35:37.000 --> 35:41.000]  это полином от логарифма.
[35:41.000 --> 35:45.000]  Ну а n-p-space равно p-space.
[35:45.000 --> 35:49.000]  Ну и во всех прочих тоже нет
[35:49.000 --> 35:53.000]  никакого смысла.
[35:53.000 --> 35:57.000]  Н-эксп-спейс это тоже эксп-спейс и так далее.
[35:57.000 --> 36:01.000]  Так, хорошо. Значит, как этот теремм доказывается?
[36:01.000 --> 36:05.000]  Это через конфигурационный граф.
[36:05.000 --> 36:09.000]  Все ту же самую задачу достижимости нам нужно решать,
[36:09.000 --> 36:13.000]  но мы ее будем решать,
[36:13.000 --> 36:17.000]  использовав немножко побольше памяти, именно квадрат.
[36:17.000 --> 36:21.000]  Доказательство теоремы
[36:25.000 --> 36:29.000]  заключается в том,
[36:29.000 --> 36:33.000]  что на вот этой памяти
[36:37.000 --> 36:41.000]  значит, на памяти
[36:41.000 --> 36:45.000]  от s от n в квадрате
[36:45.000 --> 36:49.000]  можно...
[36:49.000 --> 36:53.000]  что сделать?
[36:53.000 --> 36:57.000]  Можно решить задачу достижимости.
[36:57.000 --> 37:01.000]  То есть можно проверить наличие пути.
[37:05.000 --> 37:09.000]  Значит, наличие пути из s в t.
[37:13.000 --> 37:17.000]  Значит, смотрите, прям в целиком граф
[37:17.000 --> 37:21.000]  мы построить не можем,
[37:21.000 --> 37:25.000]  потому что у него будет как раз экспонент от s от n размера.
[37:25.000 --> 37:29.000]  То есть нам его нужно как-то строить так на лету.
[37:29.000 --> 37:33.000]  Мы не можем его прям весь сразу выписать,
[37:33.000 --> 37:37.000]  но можем какие-то отдельные фрагменты все время подсматривать, потом забывать про них.
[37:37.000 --> 37:41.000]  Если нужно, то заново вычислять.
[37:41.000 --> 37:45.000]  Все-таки обычные
[37:45.000 --> 37:49.000]  поиски ширину в глубину, они подразумевают какие-то метки
[37:49.000 --> 37:53.000]  на вершинах.
[37:55.000 --> 37:59.000]  Вот здесь в некотором смысле
[37:59.000 --> 38:03.000]  будет такой двоичный поиск.
[38:03.000 --> 38:07.000]  Потому что, смотрите, даже если бы мы разрешили циклы,
[38:07.000 --> 38:11.000]  то все равно, если был бы путь, то был бы простой путь.
[38:11.000 --> 38:15.000]  И в простом пути вершин не больше, чем вершин в графе.
[38:15.000 --> 38:19.000]  Да, совершенно верно.
[38:19.000 --> 38:23.000]  Перебирать среднюю и рекурсивно искать два пути от начальной до средней,
[38:23.000 --> 38:27.000]  от средней до конечной.
[38:27.000 --> 38:31.000]  Значит, тут получается
[38:31.000 --> 38:35.000]  пусть n в графе,
[38:35.000 --> 38:39.000]  n в графе,
[38:39.000 --> 38:43.000]  и здесь н в графе,
[38:43.000 --> 38:47.000]  н в графе,
[38:47.000 --> 38:51.000]  тогда получается есть путь
[38:55.000 --> 38:59.000]  длины
[38:59.000 --> 39:03.000]  не больше, чем n.
[39:07.000 --> 39:11.000]  Дальше получается, что есть путь
[39:11.000 --> 39:15.000]  из s в t.
[39:15.000 --> 39:19.000]  N большое
[39:19.000 --> 39:23.000]  это та формула,
[39:23.000 --> 39:27.000]  это вот это вот.
[39:27.000 --> 39:31.000]  N большое это число конфигурации.
[39:31.000 --> 39:35.000]  То есть, грубо говоря, это экспонент s от n.
[39:35.000 --> 39:39.000]  И даже тут видно, зачем оно, чтобы s от n было больше логарифма.
[39:39.000 --> 39:43.000]  Потому что если бы s от n было меньше логарифма, то главным множителем стал бы вот этот вот.
[39:43.000 --> 39:47.000]  Так что в принципе можно обобщить теорему,
[39:47.000 --> 39:51.000]  подставив вот сюда вместо s от n, подставив максимум из s от n и логарифма.
[39:51.000 --> 39:55.000]  Тогда это уже будет всегда верно.
[39:59.000 --> 40:03.000]  Конечно, это техническое требование.
[40:03.000 --> 40:07.000]  Вот.
[40:11.000 --> 40:15.000]  В общем, смотрите, что получается.
[40:15.000 --> 40:19.000]  Давайте я это обозначу как предикат.
[40:19.000 --> 40:23.000]  Reach, s, t, n. То есть есть достижимость.
[40:23.000 --> 40:27.000]  Есть путь из s в t длины не больше n.
[40:27.000 --> 40:31.000]  Это равносильно тому, что существует
[40:31.000 --> 40:35.000]  какая-то промежуточная вершина x.
[40:35.000 --> 40:41.000]  Да, значит, где будет reach от s, x и n пополам.
[40:41.000 --> 40:49.000]  И reach от x, t и n пополам.
[40:49.000 --> 40:53.000]  Вот такое как бы рекурсивное правило.
[40:53.000 --> 40:57.000]  Вот. А если n равно 1,
[40:57.000 --> 41:01.000]  ну не 1, а третий параметр.
[41:01.000 --> 41:05.000]  Reach от u, v, 1.
[41:05.000 --> 41:09.000]  Это означает, что либо у равно v, то есть путь длины 0,
[41:09.000 --> 41:13.000]  либо есть одно ребро.
[41:13.000 --> 41:17.000]  То есть это равносильно тому, что u равно v,
[41:17.000 --> 41:21.000]  или есть корректный переход
[41:21.000 --> 41:27.000]  из u в v.
[41:27.000 --> 41:33.000]  Это можем проверить просто по программе для машины тюринга.
[41:33.000 --> 41:37.000]  Но там еще какое-то котирование нужно.
[41:37.000 --> 41:41.000]  Что это конфигурация, что там, где записано.
[41:41.000 --> 41:45.000]  В общем, переход за один шаг означает, что почти ничего не изменилось.
[41:45.000 --> 41:49.000]  И только в районе указателя все произошло согласно программе машины тюринга.
[41:49.000 --> 41:53.000]  Так.
[41:53.000 --> 41:57.000]  Хорошо.
[41:57.000 --> 42:01.000]  Теперь надо из этой формулы организовать программу,
[42:01.000 --> 42:05.000]  которая все вычислит, используя такую память.
[42:05.000 --> 42:09.000]  Вот.
[42:09.000 --> 42:13.000]  Вот получается рекурсия.
[42:13.000 --> 42:17.000]  Что нам нужна память на перебор XA,
[42:17.000 --> 42:21.000]  и потом память на рекурсивный запуск.
[42:33.000 --> 42:37.000]  То есть тут получается...
[42:37.000 --> 42:41.000]  Перебор XA.
[42:41.000 --> 42:47.000]  А здесь получается рекурсивный запуск.
[42:47.000 --> 42:53.000]  Рич от двух аргументов n пополам.
[42:53.000 --> 42:57.000]  Вот.
[42:57.000 --> 43:03.000]  Получается, что перебор XA нам нужен порядка s от n этих самых ячеек.
[43:03.000 --> 43:09.000]  Что большое, это s от n ячеек.
[43:09.000 --> 43:15.000]  И, соответственно, нам нужна память на перебор XA.
[43:15.000 --> 43:19.000]  Вот.
[43:19.000 --> 43:23.000]  Вот.
[43:23.000 --> 43:29.000]  И, соответственно, каждое уменьшение n в два раза
[43:29.000 --> 43:33.000]  нам будет добавлять еще столько же ячеек.
[43:33.000 --> 43:37.000]  Вот. Ну а сколько раз нужно уменьшать n в два раза, чтобы получить константу?
[43:37.000 --> 43:41.000]  Ну как раз тоже s от n.
[43:41.000 --> 43:45.000]  То есть глубина рекурсия
[43:45.000 --> 43:51.000]  тоже большое, это s от n.
[43:51.000 --> 43:57.000]  Значит, базу рекурсии мы как-нибудь вычислим за небольшую память.
[43:57.000 --> 44:01.000]  Ну да.
[44:01.000 --> 44:05.000]  Что за один шаг можно перейти.
[44:05.000 --> 44:11.000]  В детали нужно лезть, но явно это много не потребует дополнительной памяти.
[44:11.000 --> 44:17.000]  Но, до сих пор, нужно умножить глубину на дополнительную память на каждом уровне
[44:17.000 --> 44:21.000]  и получим как раз s от n в квадрате.
[44:21.000 --> 44:25.000]  Ну да, но это совсем мелочь.
[44:25.000 --> 44:31.000]  Нам как бы один бит нужно хранить еще.
[44:31.000 --> 44:39.000]  Вот. Соответственно, получаем, что произведение
[44:39.000 --> 44:45.000]  большое вот s от n в квадрате.
[44:45.000 --> 44:51.000]  Вот так. Ну все, доказали Теремсовича.
[44:51.000 --> 44:57.000]  Киньте вопросы.
[44:57.000 --> 45:03.000]  Так.
[45:03.000 --> 45:07.000]  Так.
[45:07.000 --> 45:11.000]  Да, значит, здесь будет равно.
[45:11.000 --> 45:15.000]  Вот, теперь, значит,
[45:15.000 --> 45:21.000]  что здесь известно в плане строгости вложений?
[45:21.000 --> 45:27.000]  Значит, идея тут такая, что если у нас один и тот же ресурс,
[45:27.000 --> 45:31.000]  то чем больше ресурса, тем шире класс.
[45:31.000 --> 45:35.000]  Это называется терема об иерархии.
[45:35.000 --> 45:39.000]  Мы ее, наверное, не будем доказывать, или на семинаре вы доказывали.
[45:39.000 --> 45:43.000]  Звучит очевидно.
[45:43.000 --> 45:47.000]  Ну, то есть там p не равно exp, или l не равно pspace.
[45:47.000 --> 45:53.000]  Это все из теремы об иерархии. Или там np не равно nexp.
[45:53.000 --> 45:57.000]  И это все разные теремы об иерархии.
[45:57.000 --> 46:01.000]  Для детерминированных вычислений, для вычислений с ограничениями на память,
[46:01.000 --> 46:07.000]  для нетерминированных, для нетерминированных на память.
[46:07.000 --> 46:11.000]  Ну, это не интересно, потому что они там почти сразу схлопываются.
[46:11.000 --> 46:15.000]  Но, скажем, nl тоже строго вложено в pspace,
[46:15.000 --> 46:19.000]  потому что nl вложено в полиэль, а полилогриф меньше, чем полином,
[46:19.000 --> 46:23.000]  поэтому полиэль уже строго вложено в pspace.
[46:23.000 --> 46:27.000]  Если касается ресурсов разной природы,
[46:27.000 --> 46:31.000]  то тут не известно, в общем-то, ничего.
[46:31.000 --> 46:35.000]  И в частности, открытый вопрос,
[46:35.000 --> 46:39.000]  это равны ли p и pspace?
[46:39.000 --> 46:43.000]  Не только равны ли p и np, мы не знаем, хотя верим, что не равны,
[46:43.000 --> 46:47.000]  но даже мы не знаем, равны ли p и pspace.
[46:47.000 --> 46:51.000]  Хотя кажется, что это очень странно,
[46:51.000 --> 46:55.000]  что явно pspace гораздо больше,
[46:55.000 --> 46:59.000]  мы не только отдельный перебор можем сделать, но и какой-то вложный перебор,
[46:59.000 --> 47:03.000]  и еще и глубина вложенности может быть даже полиномом.
[47:03.000 --> 47:09.000]  И, тем не менее, это открытый вопрос.
[47:09.000 --> 47:13.000]  Так, ну ладно.
[47:13.000 --> 47:19.000]  Сейчас обсудим, какие вообще задачи
[47:19.000 --> 47:23.000]  лежат в pspace.
[47:23.000 --> 47:27.000]  Как на это можно смотреть?
[47:27.000 --> 47:31.000]  Кроме ph, что там еще лежит?
[47:31.000 --> 47:35.000]  На самом деле, то, что я стираю,
[47:35.000 --> 47:39.000]  это характеризация с произвольным члом кванторов,
[47:39.000 --> 47:43.000]  и это очень похоже на альтернирующие машины,
[47:43.000 --> 47:47.000]  и это, собственно, равно pspace.
[47:47.000 --> 47:51.000]  Где еще возникают вот такие
[47:51.000 --> 47:55.000]  меняющиеся кванторы?
[47:55.000 --> 47:59.000]  Конечно, да.
[47:59.000 --> 48:03.000]  Что такое выигрышная стратегия?
[48:03.000 --> 48:07.000]  В игре, где двое ходят по очереди,
[48:07.000 --> 48:11.000]  это такой хороший ход, что как бы соперник не ответил,
[48:11.000 --> 48:15.000]  будет все равно хороший ход, что как бы он не ответил,
[48:15.000 --> 48:19.000]  что в итоге мы победим.
[48:19.000 --> 48:23.000]  Но, соответственно, многие pspace задачи
[48:23.000 --> 48:27.000]  формулируются через игры.
[48:27.000 --> 48:31.000]  Например, крестики-нолики.
[48:31.000 --> 48:35.000]  Крестики-нолики можно так формулировать.
[48:35.000 --> 48:39.000]  Пусть у нас есть какая-то конечная доска,
[48:39.000 --> 48:43.000]  и там уже какие-то крестики-нолики стоят.
[48:43.000 --> 48:47.000]  И тогда вопрос, кто выиграет при правильной игре.
[48:47.000 --> 48:51.000]  Но это игра, где пять вряд.
[48:51.000 --> 48:55.000]  Уже какие-то крестики-нолики есть, ходят крестики,
[48:55.000 --> 48:59.000]  и вопрос, у какой стороны есть выигрышная стратегия
[48:59.000 --> 49:03.000]  из такого начала.
[49:03.000 --> 49:07.000]  Начальная ситуация нужна, чтобы много было возможных
[49:07.000 --> 49:11.000]  начальных ситуаций.
[49:11.000 --> 49:15.000]  И вопрос, кто просто выигрывает на пустой доске m на n.
[49:35.000 --> 49:39.000]  Но даже если вы скажете какие-нибудь более сложные правила,
[49:39.000 --> 49:43.000]  то все равно главное, что если у вас только два числа,
[49:43.000 --> 49:49.000]  то запись входа это будет просто логарифм от n.
[49:49.000 --> 49:53.000]  А решаться это будет напоминать памяти от n.
[49:53.000 --> 49:57.000]  Ну, можно в мунарной записи, да,
[49:57.000 --> 50:01.000]  но это можно, конечно, так делать.
[50:01.000 --> 50:05.000]  Ну вот, соответственно, если уже начальная позиция есть,
[50:05.000 --> 50:09.000]  то получается,
[50:09.000 --> 50:13.000]  как минимум, там экспоненционально, что разные входы длины n,
[50:13.000 --> 50:17.000]  а не полиномиальная.
[50:17.000 --> 50:21.000]  Так, хорошо.
[50:21.000 --> 50:25.000]  Повторим.
[50:25.000 --> 50:29.000]  Повторим.
[50:29.000 --> 50:33.000]  А почему это на полиномиальной памяти решается?
[50:33.000 --> 50:37.000]  Да потому что будет такая же рекурсия,
[50:37.000 --> 50:41.000]  только тут будет полиномиальная вложенность,
[50:41.000 --> 50:45.000]  и на каждом уровне будет полиномиальный перебор,
[50:45.000 --> 50:49.000]  то есть перебор следующего хода.
[50:49.000 --> 50:53.000]  Перебор следующего хода будет полиномиальный,
[50:53.000 --> 50:57.000]  это число оставшихся пустых мест на доске,
[50:57.000 --> 51:01.000]  а глубина вложенности – это число пустых мест с самого начала.
[51:01.000 --> 51:05.000]  Ну и дальше это точно так же можно все вычислить.
[51:05.000 --> 51:09.000]  Даже почти как здесь, только тут будет место одной конъюнкции,
[51:09.000 --> 51:13.000]  да, либо большая конъюнкция, либо большая дезюнкция.
[51:13.000 --> 51:17.000]  Так, ну что, понятно, да?
[51:17.000 --> 51:21.000]  Ну, конечно, возникает вопрос про разные другие игры,
[51:21.000 --> 51:25.000]  например, шахматы.
[51:25.000 --> 51:29.000]  Но чтобы говорить про шахматы, нужно очень аккуратно,
[51:29.000 --> 51:33.000]  нужно, во-первых, распространить на доску произвольного размера,
[51:33.000 --> 51:37.000]  что уже нетривиальное дело.
[51:37.000 --> 51:41.000]  Сколько там должно быть фигур, где они должны стоять?
[51:41.000 --> 51:45.000]  Ну хорошо, где они стоят?
[51:45.000 --> 51:49.000]  Допустим, тоже вход.
[51:49.000 --> 51:53.000]  В принципе, можно даже сказать так, что сколько угодно разных фигур.
[51:53.000 --> 51:57.000]  Только про короля надо сказать, он один или их много.
[52:09.000 --> 52:13.000]  Ну, можно новый тип фигур сводить.
[52:13.000 --> 52:17.000]  Но главное,
[52:17.000 --> 52:21.000]  что нужно расширить всякие специальные правила,
[52:21.000 --> 52:25.000]  типа повторения позиции.
[52:25.000 --> 52:29.000]  Потому что, смотрите,
[52:29.000 --> 52:33.000]  просто повторение позиции нас вообще не спасет,
[52:33.000 --> 52:37.000]  потому что позиций может быть специально много.
[52:37.000 --> 52:41.000]  И даже если мы говорим, что каждая позиция повторяется не больше трех раз,
[52:41.000 --> 52:45.000]  то все равно может быть экспедиционно долгая игра.
[52:45.000 --> 52:49.000]  Вот, соответственно,
[52:49.000 --> 52:53.000]  возникает вопрос, есть ли у нас правил 50 ходов,
[52:53.000 --> 52:57.000]  и если есть, то во что превращается число 50,
[52:57.000 --> 53:01.000]  когда у нас доска N на N.
[53:01.000 --> 53:05.000]  Значит, если это будет
[53:05.000 --> 53:09.000]  тоже там константа 50
[53:09.000 --> 53:13.000]  или какой-то полином,
[53:13.000 --> 53:17.000]  то тогда сразу игра пойдет в PSPACE,
[53:17.000 --> 53:21.000]  потому что тогда игра будет длиться не больше полинома ходов,
[53:21.000 --> 53:25.000]  и работает такой же перебор.
[53:25.000 --> 53:29.000]  Если это 50 заменить на что-нибудь больше полинома,
[53:29.000 --> 53:33.000]  то уже непонятно, будет это в PSPACE или не будет,
[53:33.000 --> 53:37.000]  по крайней мере прямой перебор всех вариантов займет слишком много.
[53:39.000 --> 53:43.000]  Это я, к сожалению, не знаю правил.
[53:43.000 --> 53:49.000]  Но в целом знание некоторых принципов
[53:49.000 --> 53:53.000]  заменяет знание некоторых фактов.
[53:53.000 --> 53:57.000]  Если у вас любая ветка длится не больше полинома,
[53:57.000 --> 54:01.000]  то сразу это будет PSPACE.
[54:01.000 --> 54:05.000]  Если могут быть сверхполиномиальные ветви, то тогда начинаются вопросы.
[54:05.000 --> 54:09.000]  Либо есть какой-то тонкий анализ, либо это будет больше, чем полином.
[54:17.000 --> 54:21.000]  Зачем нам нужны были NP-полные задачи?
[54:21.000 --> 54:25.000]  Затем, что если мы умеем решать NP-полную задачу,
[54:25.000 --> 54:29.000]  то мы умеем решать все NP.
[54:29.000 --> 54:33.000]  То есть это самые сложные задачи в NP
[54:33.000 --> 54:37.000]  с водимости из P.
[54:37.000 --> 54:41.000]  PSPACE-полная задача тоже самая.
[54:41.000 --> 54:45.000]  PSPACE-полные тоже самые сложные в PSPACE,
[54:45.000 --> 54:49.000]  но с точки зрения сводимости в P.
[54:49.000 --> 54:53.000]  Определение, что B
[54:53.000 --> 54:57.000]  это PSPACE-полная задача,
[54:57.000 --> 55:01.000]  или PSPACE-полный язык,
[55:01.000 --> 55:05.000]  значит, если верно следующее.
[55:05.000 --> 55:09.000]  Если B лежит в PSPACE,
[55:09.000 --> 55:13.000]  и для любого A из PSPACE
[55:13.000 --> 55:17.000]  у нас выполнено, что A
[55:17.000 --> 55:21.000]  сходится к B
[55:21.000 --> 55:25.000]  в смысле с водимости по карпу,
[55:25.000 --> 55:29.000]  понимали, по времени.
[55:29.000 --> 55:33.000]  У нас интересует разделение P и PSPACE,
[55:33.000 --> 55:37.000]  поэтому берем сводимость из нижнего класса.
[55:37.000 --> 55:41.000]  Ну и дальше какая-то вопрос,
[55:41.000 --> 55:45.000]  какие задачи будут PSPACE-полными, какие нет.
[55:45.000 --> 55:49.000]  Здесь есть некоторый аналог
[55:49.000 --> 55:53.000]  всех задач и выполнимости.
[55:53.000 --> 55:57.000]  Аналог всяких сад,
[55:57.000 --> 56:01.000]  тавтологий,
[56:01.000 --> 56:05.000]  сигмакасад, и пикасад.
[56:05.000 --> 56:09.000]  Это задача TQBF.
[56:09.000 --> 56:13.000]  TQBF,
[56:13.000 --> 56:17.000]  true quantified Boolean formula,
[56:17.000 --> 56:21.000]  то есть истинные boolean formulas с кванторами.
[56:21.000 --> 56:25.000]  Иногда на русском BFK
[56:25.000 --> 56:29.000]  используют аббревиатуру boolean formulas с кванторами.
[56:29.000 --> 56:33.000]  Тут, соответственно,
[56:33.000 --> 56:37.000]  дана формула phi,
[56:37.000 --> 56:41.000]  это распространение этого сигмакасад.
[56:41.000 --> 56:45.000]  Но теперь нам не нужно экономить число альтернирований,
[56:45.000 --> 56:49.000]  и мы можем просто сказать,
[56:49.000 --> 56:53.000]  что у нас по каждой переменной свой квантор и они чередуются.
[56:53.000 --> 56:57.000]  Потому что phi таких, что
[56:57.000 --> 57:01.000]  существует x1 для любого x2, существует x3,
[57:01.000 --> 57:05.000]  и так далее.
[57:05.000 --> 57:09.000]  Можно даже считать, что у ка отчетная для любого xk,
[57:09.000 --> 57:13.000]  phi от x1, x2,
[57:13.000 --> 57:17.000]  и так далее xk.
[57:17.000 --> 57:21.000]  Это отдельные переменные, можно считать, что это блоки переменных,
[57:21.000 --> 57:25.000]  и это все совершенно неважно будет.
[57:25.000 --> 57:29.000]  Это будет TQBF.
[57:29.000 --> 57:33.000]  Важно только, что тут полиномиальничало кванторов,
[57:33.000 --> 57:37.000]  но их полиномиальны, потому что они все просто записаны как переменные в формуле phi.
[57:37.000 --> 57:41.000]  Мы считаем, что phi записаны явно,
[57:41.000 --> 57:45.000]  прям текстом все переменные явно прописаны без каких-то сокращений.
[57:45.000 --> 57:49.000]  Вот.
[57:49.000 --> 57:53.000]  Значит, это лежит в PSPACE, но по той же причине рекурсия.
[57:53.000 --> 57:57.000]  То есть это
[57:57.000 --> 58:01.000]  лежит в PSPACE
[58:01.000 --> 58:05.000]  так как рекурсивный алгоритм.
[58:05.000 --> 58:09.000]  Вот.
[58:09.000 --> 58:13.000]  Почему же она PSPACE полная?
[58:13.000 --> 58:17.000]  На самом деле тут будет
[58:17.000 --> 58:21.000]  похожая штука, но чуть-чуть другая.
[58:21.000 --> 58:25.000]  Значит, если вы хорошо помните тему выразимости
[58:25.000 --> 58:29.000]  из логики с прошлого года, там тоже были похожие формулы,
[58:29.000 --> 58:33.000]  и там мы заменяли двойное упоминание
[58:33.000 --> 58:37.000]  вот этого предиката на одинартное.
[58:37.000 --> 58:41.000]  Это ровно то, что нужно, чтобы получить вот такую штуку.
[58:41.000 --> 58:45.000]  Ну, типа того, да.
[58:45.000 --> 58:49.000]  Значит,
[58:49.000 --> 58:53.000]  как мы а сводим в TQBF?
[58:53.000 --> 58:57.000]  Да, вообще, в принципе, можно
[58:57.000 --> 59:01.000]  рассмотреть промежуточную задачу, которая будет как раз про
[59:01.000 --> 59:05.000]  про достижимость в графе.
[59:05.000 --> 59:09.000]  Только граф нужно сдавать неявно.
[59:09.000 --> 59:13.000]  Задание графа неявно означает, что мы по каждой паре вершин
[59:13.000 --> 59:17.000]  можем понять, есть там ребро или нет там ребра,
[59:17.000 --> 59:21.000]  и как-то довольно быстро.
[59:21.000 --> 59:25.000]  Это ровно то, что вот здесь происходит,
[59:25.000 --> 59:29.000]  что мы можем
[59:29.000 --> 59:33.000]  если нам дано описание одной конфигурации, описание другой конфигурации,
[59:33.000 --> 59:37.000]  мы можем быстро понять, есть между ними ребро или нет.
[59:37.000 --> 59:41.000]  Ну ладно, значит,
[59:41.000 --> 59:45.000]  я, наверное, не буду подробно на то издаче останавливать,
[59:45.000 --> 59:49.000]  сразу для этой напишу, что у нас получается,
[59:49.000 --> 59:53.000]  что по X
[59:59.000 --> 01:00:03.000]  не fill же с PSPS, а TQBF же с PSPS.
[01:00:03.000 --> 01:00:07.000]  Множество всех. Смотрите, PSPS это класс, то есть это второго уровня.
[01:00:07.000 --> 01:00:11.000]  Вот нет.
[01:00:11.000 --> 01:00:15.000]  Смотрите, в чем отличие?
[01:00:15.000 --> 01:00:19.000]  В чем отличие от сигмак осад? В том, что в сигмак осад
[01:00:19.000 --> 01:00:23.000]  K фиксированный не зависит вообще от входа.
[01:00:23.000 --> 01:00:27.000]  А здесь K определяется входом, то есть K это число переменных формуля.
[01:00:27.000 --> 01:00:31.000]  То есть чем формула длиннее, тем больше может быть K.
[01:00:31.000 --> 01:00:35.000]  А в сигмак осад у нас K фиксированный для всех входов.
[01:00:35.000 --> 01:00:39.000]  Вот в этом отличие.
[01:00:39.000 --> 01:00:43.000]  Так, ну да, это важно, давайте я это подчеркну,
[01:00:43.000 --> 01:00:47.000]  что K растет
[01:00:47.000 --> 01:00:51.000]  с ростом phi.
[01:00:51.000 --> 01:00:55.000]  То есть вместо константы мы получаем растущую функцию.
[01:00:55.000 --> 01:00:59.000]  Не, ну можно считать, что там прям символ,
[01:00:59.000 --> 01:01:03.000]  это X с индексами.
[01:01:03.000 --> 01:01:07.000]  Не, сейчас, переменные булевские остаются.
[01:01:07.000 --> 01:01:11.000]  Переменные булевые, но формуле они прямо записываются.
[01:01:11.000 --> 01:01:15.000]  Нет, тут точно так же было. Сейчас, смотрите,
[01:01:15.000 --> 01:01:19.000]  у нас есть кое-какая формула.
[01:01:19.000 --> 01:01:23.000]  Вот, вот, вот.
[01:01:23.000 --> 01:01:27.000]  Нет, тут точно так же было. Сейчас, смотрите, в сигмак осад
[01:01:27.000 --> 01:01:31.000]  у нас вот эти X и T могли быть не одной переменной, а блоком переменных.
[01:01:31.000 --> 01:01:35.000]  А здесь, как хотите, можно считать, что тоже блок, а можно считать, что прямо по одной переменной.
[01:01:35.000 --> 01:01:39.000]  Вот, хорошо.
[01:01:39.000 --> 01:01:43.000]  Значит, по X мы строим граф.
[01:01:43.000 --> 01:01:47.000]  Да, значит, мы считаем,
[01:01:47.000 --> 01:01:51.000]  что пусть A лежит в P-спейс,
[01:01:51.000 --> 01:01:55.000]  значит, A лежит в P-спейс,
[01:01:55.000 --> 01:01:59.000]  то есть распознается
[01:01:59.000 --> 01:02:03.000]  алгоритмом V
[01:02:03.000 --> 01:02:07.000]  на памяти
[01:02:07.000 --> 01:02:11.000]  полинома A.
[01:02:11.000 --> 01:02:15.000]  Вот, соответственно,
[01:02:15.000 --> 01:02:19.000]  по X мы строим граф.
[01:02:19.000 --> 01:02:23.000]  Мы строим граф конфигурации.
[01:02:23.000 --> 01:02:27.000]  Значит, граф конфигурации
[01:02:27.000 --> 01:02:31.000]  вот этой самой V от X.
[01:02:33.000 --> 01:02:37.000]  Вот, и, соответственно, нас интересует задача достижимости.
[01:02:39.000 --> 01:02:43.000]  Значит, вопрос
[01:02:43.000 --> 01:02:47.000]  достижима ли
[01:02:47.000 --> 01:02:51.000]  принимающая вершина
[01:02:51.000 --> 01:02:55.000]  из стартовой.
[01:02:59.000 --> 01:03:03.000]  Значит, получается,
[01:03:03.000 --> 01:03:07.000]  что в общем то же самое, что здесь работает,
[01:03:07.000 --> 01:03:11.000]  что если достижима,
[01:03:11.000 --> 01:03:15.000]  то получается, что есть путь длины
[01:03:15.000 --> 01:03:19.000]  и не больше n,
[01:03:19.000 --> 01:03:23.000]  а n в данном случае будет экспонентой,
[01:03:23.000 --> 01:03:27.000]  потому что у нас s это полином,
[01:03:27.000 --> 01:03:31.000]  так что число конфигурации будет экспонента.
[01:03:31.000 --> 01:03:35.000]  Вот, и вот это вот переход тоже остается,
[01:03:35.000 --> 01:03:39.000]  но проблема в том, что если мы теперь на это смотрим не как на инструкцию по вычислению,
[01:03:39.000 --> 01:03:43.000]  а как на формулу, то получается, что здесь параметр уменьшился вдвое,
[01:03:43.000 --> 01:03:47.000]  но и длина увеличилась вдвое.
[01:03:47.000 --> 01:03:51.000]  Ну, как мы делали, чтобы длина увеличилась не вдвое, а на константу?
[01:03:51.000 --> 01:03:55.000]  Ну, давайте распишем.
[01:03:55.000 --> 01:03:59.000]  Reach от s, t, n
[01:03:59.000 --> 01:04:03.000]  это равносильно тому, что существует x,
[01:04:03.000 --> 01:04:07.000]  такой, что reach
[01:04:07.000 --> 01:04:11.000]  от s, x, n пополам
[01:04:11.000 --> 01:04:15.000]  и reach от x, t
[01:04:15.000 --> 01:04:19.000]  и n пополам.
[01:04:19.000 --> 01:04:23.000]  Значит, а это равносильно тому, что
[01:04:23.000 --> 01:04:27.000]  существует x потом для любого u, для любого v.
[01:04:27.000 --> 01:04:31.000]  Значит, если
[01:04:31.000 --> 01:04:35.000]  u равно s
[01:04:35.000 --> 01:04:39.000]  и v равно x,
[01:04:39.000 --> 01:04:43.000]  или u равно x
[01:04:43.000 --> 01:04:47.000]  и v равно t,
[01:04:47.000 --> 01:04:51.000]  то тогда reach
[01:04:51.000 --> 01:04:55.000]  от u, v и n пополам.
[01:04:59.000 --> 01:05:03.000]  И вот получилось, что если мы написали формулу для этого,
[01:05:03.000 --> 01:05:07.000]  для n пополам,
[01:05:07.000 --> 01:05:11.000]  то получается увеличением длины вот настолько.
[01:05:15.000 --> 01:05:19.000]  Соответственно получается, что общая длина будет порядка логарифма n большого,
[01:05:19.000 --> 01:05:23.000]  то есть порядка полинома.
[01:05:27.000 --> 01:05:31.000]  Общая длина формулы
[01:05:31.000 --> 01:05:35.000]  это логарифма n большое,
[01:05:35.000 --> 01:05:39.000]  то есть это будет полином от n маленького.
[01:05:41.000 --> 01:05:45.000]  Ещё база нужна.
[01:05:45.000 --> 01:05:49.000]  База у нас та же самая, что и там.
[01:05:49.000 --> 01:05:53.000]  Либо u равно v, либо достижим за один шаг.
[01:05:53.000 --> 01:05:57.000]  Соответственно тут тоже есть алгоритм,
[01:05:57.000 --> 01:06:01.000]  машина тюринга.
[01:06:01.000 --> 01:06:05.000]  Переход за один шаг, можем проверить.
[01:06:09.000 --> 01:06:13.000]  Это тоже нужно ещё преобразовать формулу,
[01:06:13.000 --> 01:06:17.000]  но это тоже технический вопрос.
[01:06:17.000 --> 01:06:21.000]  Мы фактически уже делали
[01:06:21.000 --> 01:06:25.000]  в теории Кукулевина и в теории полноции Сигмакасад.
[01:06:25.000 --> 01:06:29.000]  Там, правда, нужно переделать,
[01:06:29.000 --> 01:06:33.000]  потому что в Сигме лента не одна и будет более сложная зависимость.
[01:06:33.000 --> 01:06:37.000]  Но всё равно как-нибудь сделаем.
[01:06:51.000 --> 01:06:55.000]  Что? Вот это выражение верно.
[01:06:55.000 --> 01:06:59.000]  Нет.
[01:06:59.000 --> 01:07:03.000]  Да, по всем примерам расставили квантеры.
[01:07:03.000 --> 01:07:07.000]  Всё свободное записывается
[01:07:07.000 --> 01:07:11.000]  прямо внутрь формулы Фи.
[01:07:11.000 --> 01:07:15.000]  Все свободные переменные это будет часть формулы Фи.
[01:07:15.000 --> 01:07:19.000]  Ну, если там откуда-то она взялась,
[01:07:19.000 --> 01:07:23.000]  то мы, во-первых, фиксируем её значение,
[01:07:23.000 --> 01:07:27.000]  во-вторых, считаем частью формулы Фи.
[01:07:45.000 --> 01:07:49.000]  Ну, грубо говоря, да.
[01:07:49.000 --> 01:07:53.000]  И тогда можно спрашивать,
[01:07:53.000 --> 01:07:57.000]  будет ли лежать это в ТКБФ или не будет.
[01:07:57.000 --> 01:08:01.000]  Так, ну вот.
[01:08:01.000 --> 01:08:05.000]  Так, вроде получилось, да? Или какие-то вопросы ещё остались?
[01:08:05.000 --> 01:08:09.000]  Когда мы записываем Фи,
[01:08:09.000 --> 01:08:13.000]  мы не должны ещё записывать...
[01:08:13.000 --> 01:08:17.000]  Сейчас, да, подождите, да, не совсем получилось.
[01:08:17.000 --> 01:08:21.000]  Во-первых, когда рекурсивно это строим,
[01:08:21.000 --> 01:08:25.000]  то у нас квантеры вот тут будут.
[01:08:25.000 --> 01:08:29.000]  И их нужно вытащить вперёд,
[01:08:29.000 --> 01:08:33.000]  как когда мы приводили к предыдурем нормальной форме.
[01:08:33.000 --> 01:08:37.000]  Это мы умеем, да, это просто механически надо взять.
[01:08:37.000 --> 01:08:41.000]  Ну, конечно, просто берём и переносим.
[01:08:41.000 --> 01:08:45.000]  Там, конечно, нужно позаботиться о том,
[01:08:45.000 --> 01:08:49.000]  чтобы все перемены были разными,
[01:08:49.000 --> 01:08:53.000]  чтобы имена всех переменных были разными.
[01:08:53.000 --> 01:08:57.000]  Ну и тогда из заключения импликации можно просто переносить в начало,
[01:08:57.000 --> 01:09:01.000]  ничего не меняя, вообще не меняя квантеры и не меняя переменных.
[01:09:01.000 --> 01:09:05.000]  Ну а дальше, да, тут, конечно, будут блоки,
[01:09:05.000 --> 01:09:09.000]  блоки переменных.
[01:09:09.000 --> 01:09:13.000]  Захотеть, чтобы прям перемены чередовались,
[01:09:13.000 --> 01:09:17.000]  но нож просто бы эффективные переменные,
[01:09:17.000 --> 01:09:21.000]  от которых на самом деле ФИ не будет зависеть,
[01:09:21.000 --> 01:09:25.000]  ну или они могут даже текстуально встречаться, но так что от них ничего не зависит.
[01:09:25.000 --> 01:09:29.000]  Берём ещё там конъюнкция, ещё А или не А, да.
[01:09:29.000 --> 01:09:33.000]  Вот.
[01:09:39.000 --> 01:09:43.000]  Так.
[01:09:45.000 --> 01:09:49.000]  Ну хорошо.
[01:09:51.000 --> 01:09:55.000]  Знаешь что, можно ещё сказать про PSPACE.
[01:09:55.000 --> 01:09:59.000]  А, наверное, можно вернуться к тому, с чем мы начали.
[01:09:59.000 --> 01:10:03.000]  Да, вообще, есть ещё всякие другие PSPACE полные задачи,
[01:10:03.000 --> 01:10:07.000]  но я бы хотел сказать, что у нас есть ещё какие-то
[01:10:07.000 --> 01:10:11.000]  другие PSPACE полные задачи.
[01:10:11.000 --> 01:10:15.000]  Их не так много, как NP полных,
[01:10:15.000 --> 01:10:19.000]  но всё равно достаточно много, и многие игры являются PSPACE полными.
[01:10:19.000 --> 01:10:23.000]  То есть многие игры настолько же сложны,
[01:10:23.000 --> 01:10:27.000]  насколько любая задача с PSPACE.
[01:10:29.000 --> 01:10:33.000]  Вот. Так.
[01:10:33.000 --> 01:10:37.000]  А, можно ещё обсудить, что можно считать...
[01:10:37.000 --> 01:10:41.000]  Да, сейчас давайте за оставшееся время обсудим вот что.
[01:10:41.000 --> 01:10:45.000]  Во-первых, можно считать, что это ФИ это 3 KNF.
[01:10:45.000 --> 01:10:49.000]  Почему? Потому что если вспомнить, как мы в NP сводили
[01:10:49.000 --> 01:10:53.000]  SAT к 3 SAT,
[01:10:53.000 --> 01:10:57.000]  то мы просто добавляли кванторы существования ещё.
[01:10:57.000 --> 01:11:01.000]  Да, ну мы добавим сюда кванторы существования в конец.
[01:11:01.000 --> 01:11:05.000]  Мы добавляем немножко больше кванторов, но всё ещё поленальное число.
[01:11:05.000 --> 01:11:09.000]  А ФИ преобразует в 3 KNF.
[01:11:09.000 --> 01:11:13.000]  Так.
[01:11:13.000 --> 01:11:17.000]  Можно считать,
[01:11:17.000 --> 01:11:21.000]  что ФИ это 3 KNF.
[01:11:21.000 --> 01:11:25.000]  Ну и так же отсюда получается,
[01:11:25.000 --> 01:11:29.000]  что AP равно PSPACE.
[01:11:31.000 --> 01:11:35.000]  Значит, почему?
[01:11:35.000 --> 01:11:39.000]  В одну сторону. Почему AP вложено в PSPACE?
[01:11:39.000 --> 01:11:43.000]  Так, что такое AP? Это значит, что у нас альтернирующая машина,
[01:11:43.000 --> 01:11:47.000]  поленальное время, но не фиксирует число альтернирований.
[01:11:47.000 --> 01:11:51.000]  Но то, что это в PSPACE,
[01:11:51.000 --> 01:11:55.000]  это точно так же, как все наши рекурсивные вычисления.
[01:11:55.000 --> 01:11:59.000]  Если мы умеем по дереву вычисления рекурсивной альтернирующей машины,
[01:11:59.000 --> 01:12:03.000]  понимать, какой ответ,
[01:12:03.000 --> 01:12:07.000]  мы рекурсивно перебираем все ветки, на каждой из них определяем ответ,
[01:12:07.000 --> 01:12:11.000]  и берём конъюнцию или дезюнцию.
[01:12:11.000 --> 01:12:15.000]  Ну, практически, да.
[01:12:15.000 --> 01:12:19.000]  Ну и как следствие, PSPACE тоже вложено в AP,
[01:12:19.000 --> 01:12:23.000]  потому что PQBF, PSPACE полная, и аналгерит в AP тоже здесь буквально.
[01:12:23.000 --> 01:12:27.000]  Мы альтернированием выбираем все вот эти иксы,
[01:12:27.000 --> 01:12:31.000]  потом в детерминированном вычислении вычисляем вот это вот.
[01:12:31.000 --> 01:12:37.000]  То есть любая задача из PSPACE
[01:12:37.000 --> 01:12:41.000]  сначала сводится к TQBF,
[01:12:41.000 --> 01:12:45.000]  и потом решается альтернирующей машиной, которая вот это вот делает.
[01:12:45.000 --> 01:12:49.000]  То есть альтернирующей машине надо только смотреть, какую именно формулу ФИ взять
[01:12:49.000 --> 01:12:53.000]  из той задачи, которую мы сводили.
[01:12:53.000 --> 01:12:57.000]  Ну вот такой ещё взгляд
[01:12:57.000 --> 01:13:01.000]  на PSPACE.
[01:13:01.000 --> 01:13:05.000]  Так.
[01:13:05.000 --> 01:13:09.000]  Сейчас дайте я что ли анонсирую. Есть одна красивая игра,
[01:13:09.000 --> 01:13:13.000]  про которую не очень сложно доказать, что она PSPACE полная.
[01:13:13.000 --> 01:13:17.000]  Значит, это
[01:13:17.000 --> 01:13:21.000]  называется GG,
[01:13:21.000 --> 01:13:25.000]  это аббревиатура Generalize Geography,
[01:13:25.000 --> 01:13:29.000]  то есть обобщенная игра в города.
[01:13:29.000 --> 01:13:33.000]  Игру в города вы, наверное, знаете.
[01:13:33.000 --> 01:13:37.000]  Один игрок, там Алиса, называет город, Боб называет город,
[01:13:37.000 --> 01:13:41.000]  начинающий на последнюю букву города Алиса, потом снова Алиса,
[01:13:41.000 --> 01:13:45.000]  называет на последнюю букву города Боба и так далее.
[01:13:45.000 --> 01:13:49.000]  И важно, что нельзя повторяться. Нельзя повторяться, и кто не может придумать новый город, тот проиграл.
[01:13:49.000 --> 01:13:53.000]  На практике это такая игра на эрундицию,
[01:13:53.000 --> 01:13:57.000]  чтобы выиграть, нужно больше городов знать.
[01:13:57.000 --> 01:14:01.000]  Но в теории, и на практике среди сильных игроков,
[01:14:01.000 --> 01:14:05.000]  надо
[01:14:05.000 --> 01:14:09.000]  на практике среди сильных игроков
[01:14:09.000 --> 01:14:13.000]  смотреть какую-нибудь букву, на которую кончается сильно больше городов, чем начинается,
[01:14:13.000 --> 01:14:17.000]  и пытаются именно на неё называть, чтобы на эту букву у соперника быстрее кончились города.
[01:14:17.000 --> 01:14:21.000]  Да, соответственно, если это игра в теории,
[01:14:21.000 --> 01:14:25.000]  или двух игроков с одинаковым словарем,
[01:14:25.000 --> 01:14:29.000]  то да, начинаешь нужно смотреть четность,
[01:14:29.000 --> 01:14:35.000]  а дальше, какие города нужно называть, чтобы не получить там нет учетности,
[01:14:35.000 --> 01:14:41.000]  или вынудить назвать что-нибудь вот так.
[01:14:41.000 --> 01:14:45.000]  Тем не менее, в обычной игре в города есть очень важная особенность.
[01:14:45.000 --> 01:14:51.000]  Если после этого города можно назвать вот этот,
[01:14:51.000 --> 01:14:55.000]  а еще можно назвать вот этот,
[01:14:55.000 --> 01:14:59.000]  а после этого города можно назвать вот этот,
[01:14:59.000 --> 01:15:05.000]  то автоматически вот такое ребро тоже есть.
[01:15:05.000 --> 01:15:13.680]  то автоматически вот такое вот ребро тоже есть. То есть ребро означает, что после данного города
[01:15:13.680 --> 01:15:20.160]  можно назвать вот тот. Так вот, значит, генеральность географии, это то же самое,
[01:15:20.160 --> 01:15:28.880]  только без этого правила. То есть есть просто какой-то граф ориентированный, и тут еще,
[01:15:28.880 --> 01:15:38.600]  давайте считать, что есть начальная вершина. Граф есть начальная вершина, и дальше просто
[01:15:38.600 --> 01:15:46.280]  Алиса и Боб по очереди двигают фишку с начальной вершины по ребрам. И нельзя повторяться,
[01:15:46.280 --> 01:15:52.440]  значит, нельзя перемещать фишку на ту вершину, где она уже была. Кто не может делать ход, тот проиграл.
[01:15:58.880 --> 01:16:19.240]  Нет, это да. Сейчас, но эта игра в города только без вот этого условия. Сейчас, нет, чего? Обычной
[01:16:19.240 --> 01:16:36.720]  игре тоже не можно повторять вершины. А, в смысле, я понял, что можно повторять вершины,
[01:16:36.720 --> 01:16:57.640]  но нужно загнать в тупик. В общем, это PSP-исполненная игра. Ну, я думаю, что сейчас нужно заканчивать.
[01:16:57.640 --> 01:17:04.360]  В следующий раз я расскажу, почему она PSP-исполненная, и обсудим про логографическую память,
[01:17:04.360 --> 01:17:13.640]  значит, про L и, наверное, NL немножко обсудим. Вот, тогда на сегодня все. Спасибо за внимание.
