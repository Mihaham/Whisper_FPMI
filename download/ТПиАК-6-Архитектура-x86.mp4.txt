[00:00.000 --> 00:09.680]  В прошлый раз мы смотрели на Assembler архитектура ARM,
[00:09.680 --> 00:15.120]  которая у вас, в частности в телефонах, пришла пора посмотреть и на то, что у вас
[00:15.120 --> 00:28.720]  также весьма распространено в ваших стопах, ноутах. Тоже весьма распространенная архитектура,
[00:28.720 --> 00:57.480]  а именно x86, и в частности x86-64. Вот у нас процесса этой архитектуры AMD,
[00:57.480 --> 01:04.600]  попробуем что-нибудь написать и скомпилировать это в Assembler на код.
[01:04.600 --> 01:31.920]  Естественно нам интересно выяснить какое же здесь соглашение вызови, по аналогии с ARM.
[01:31.920 --> 01:58.760]  Поэтому напишем простейшую функцию сложения чисел и посмотрим во что она превратится.
[02:28.760 --> 02:38.760]  Видим, что здесь чего-то очень много страшного, поэтому может быть нам пригодятся оптимизации.
[02:38.760 --> 03:05.880]  Вот наша функция, в которой мы наловили сложение и какие-то операции.
[03:05.880 --> 03:24.120]  Что это у нас такое с процентиками может быть? Это у нас как раз регистры,
[03:24.120 --> 03:46.280]  маленькие кусочки памяти, которые хранят наши данные. Интересный вопрос, что же за операция,
[03:46.280 --> 03:57.560]  если она начинается со слова add? А в какую сторону идет присваивание? К тому, кто указан слева или
[03:57.560 --> 04:08.920]  который указан справа? То есть вы считаете, что указан слева? То есть EDI добавляется к ECE,
[04:08.920 --> 04:23.120]  затем к ECEX, а у нас вроде бы сложение всех несколько чисел в одну сумму. Проверили
[04:23.120 --> 04:32.360]  кипотезу? Что-то у нас подозрительное. Другая кипотеза? Ну да, вариантов не особо много.
[04:32.360 --> 04:52.040]  Добавить ECE, EDE и положить EDE. Добавить EDEX к EDE. То есть присваивание в местном синтаксисе
[04:52.040 --> 05:22.000]  идет слева направо. А теперь вот так. Где оказался EDE? Теперь присваивание
[05:22.000 --> 05:37.840]  идет справа налево. Так, в случае x86 у нас есть как минимум два варианта синтаксиса. Все действия
[05:37.840 --> 05:43.800]  и соответствующие им машинные кд остаются ровно теми же самыми, но есть два варианта записи их
[05:43.800 --> 05:57.280]  в форме удобной для чтения человека. То что было первое это аттензивный синтаксис. Он с
[05:57.280 --> 06:04.120]  процентиками и с присваиванием слева направо. И интеловский синтаксис без процентиков и с
[06:04.120 --> 06:11.680]  записью справа налево. Какой синтаксис вам нравится больше? Кто за интеловский? Кому он
[06:11.680 --> 06:25.440]  больше понравился? Раз, два, три, четыре. Кто за аттенкишник? Раз. А дистанционные слушатели
[06:25.440 --> 06:39.160]  у нас есть еще? А только в записи. Ну значит 4.1 в пользу интеловского. Оба синтаксиса имеют
[06:39.160 --> 06:46.080]  правное существование, но поскольку разные направления присваивания, если вы будете
[06:46.080 --> 06:59.520]  их использовать вместе, то вы просто запутаетесь. Хорошо фиксируем, что синтаксис используем интеловский
[06:59.520 --> 07:18.800]  и присваивания справа налево. Исходя из этого можно ли сказать, где у нас возвращается код
[07:18.800 --> 07:39.240]  возврата? В каком регистре? Перед тем, как выйти из функции, в какой присваивается последний? В ЯХ.
[07:39.240 --> 07:59.880]  То есть происходит какая-то магия. Сейчас мы до нее доберемся. С регистром ЯХ. А где у нас аргументы?
[07:59.880 --> 08:23.120]  В регистрах ЕДИ, ЕСИ, ЕДХ, ЕЦХ, Р8Д и какой-то Р9. Обращаю внимание, что в отличие от Арман,
[08:23.120 --> 08:33.040]  где было все относительно просто и понятно, регистры имели вроде бы естественные названия.
[08:33.040 --> 08:52.920]  Начиная с нулевого, просто по номерам, здесь название какие-то буквы. Но большая часть регистров
[08:52.920 --> 09:16.800]  имеет название, начинающуюся на букву Е. По крайней мере пока мы работаем с интами. А если мы возьмем и поменяем все на
[09:46.800 --> 10:10.080]  И регистры вроде бы те же самые, только буквка впереди Р. Отсюда делаем вывод, что Р у нас 4 бита, Е 32 бита.
[10:16.800 --> 10:31.560]  А если у нас будет другой тип?
[10:46.800 --> 11:15.200]  Схранили, скомпилировали. Судя по всему, просто используются младшие части регистров.
[11:15.200 --> 11:40.200]  Как же они на самом деле устроены? Основной принцип, который ставили разработчики этой
[11:40.200 --> 11:48.080]  архитектуры совместимы с предыдущими моделями. И здесь очень много наслоений предыдущего.
[11:48.080 --> 11:56.760]  Вспомните, как мы писали свой маленький простой процессор-видеоэмулятор. У нас были регистры А,
[11:56.760 --> 12:16.440]  А, Б, Ц, и Д с какими-то номерами. Примерно так было и было и в интернете. Допустим, был у нас регистр А. Затем появился
[12:16.440 --> 12:25.720]  более хороший техпроцесс, можно делать транзисторы по-мельче, значит транзисторы
[12:25.720 --> 12:43.400]  побольше, значит можно сделать сам регистр побольше. 16 бит. Вот у нас
[12:43.400 --> 13:03.640]  16 битный АХ, но изображение совместимости работы 8 бит осталось и доступ к 8 битным остался. Значит,
[13:03.640 --> 13:20.920]  у нас есть его старшая часть АХ 8 битная и АЛ 8 битная младшая. Всего это 16 битный регистр. Затем
[13:20.920 --> 13:30.520]  закон УГУРО продолжал работать и делали наконец 30 битные.
[13:50.920 --> 14:10.600]  Появился 30 битный регистр АХ, к его младшим битам есть доступ как к регистру АХ, к его младшим битам 8 как к регистру АЛ и старшим битам регистр АХ под названием АХ.
[14:10.600 --> 14:25.720]  Те же самые 8, тем тоже самое сделали 16 битные архитектуры и появились вот такие регистры.
[14:40.600 --> 14:54.680]  А вот этот один и не делали, но совместим уже со старым. Вот теперь у нас АХ.
[14:54.680 --> 15:22.360]  Исходя из этого подумайте, насколько велик в битых регистр АХ БЛ? 8 бит.
[15:22.360 --> 15:44.440]  Регистр СХ. Регистр ДХ. Регистр ЕСИ.
[15:44.440 --> 15:55.160]  Начинается наездка. Сколько битный? Регистр РДИ.
[15:55.160 --> 16:20.760]  Ну интересно, посмотрите как же здесь выполняются какие-нибудь арифметики и другие арифметические операции.
[16:20.760 --> 16:43.800]  Вот он у нас был плюс. Заменяем. Компилируем.
[16:43.800 --> 17:03.160]  Компилятор многие операции заменил на сложение, но для оптимизации логично.
[17:03.160 --> 17:26.520]  Уножение.
[17:33.160 --> 17:54.760]  Так оптимизирующий компилятор зачем-то закинул регистр Р9Д в АХ и только затем с ним начал делать операцию вложения.
[17:54.760 --> 18:07.400]  Похоже на то, что этот процессор имеет разные регистры, не только по наименованию, но и по назначению.
[18:07.400 --> 18:14.840]  То есть не все регистры равноправны. Может быть многие равны, но некоторые равнее других.
[18:15.560 --> 18:19.560]  Как писал Хоро.
[18:19.560 --> 18:43.000]  Дело в том, что как раз многие операции привязаны к конкретным регистрам, то есть они могут быть выполнены только с конкретными регистрами.
[18:43.000 --> 18:51.960]  В данном случае как раз с регистром ЯХ, название которого происходит от аккумулятора регистр.
[18:51.960 --> 18:55.640]  То есть куда и складывается весь результат.
[18:56.280 --> 18:59.080]  Чем имут.
[18:59.080 --> 19:03.080]  В чём имут?
[19:22.080 --> 19:26.080]  А если у нас будет беззнаковый имут?
[19:29.080 --> 19:33.080]  Тоже имут.
[19:41.080 --> 19:45.080]  А если беззнаковый лонг-лонг?
[19:59.080 --> 20:03.080]  Тоже имут.
[20:10.080 --> 20:14.080]  А что будет с делением?
[20:29.080 --> 20:33.080]  Тут произошло что-то более интересное.
[20:59.080 --> 21:03.080]  Старое значение rdx было запихнуто куда-то, а именно в r10.
[21:29.080 --> 21:39.080]  Rdx это похоже на один из аргументов.
[21:39.080 --> 21:43.080]  В rax у нас лежит rdi.
[21:43.080 --> 21:49.080]  И зачем-то делаем побитую операцию xor.
[21:49.080 --> 21:55.080]  Что будет если xor-ить регистр сам с собой?
[21:56.080 --> 22:00.080]  Обнуляем регистр таким странным образом.
[22:05.080 --> 22:11.080]  Почему-то не занесение им константы, а побитую операцию.
[22:11.080 --> 22:15.080]  Возможно это чем-то лучше.
[22:15.080 --> 22:19.080]  А чем-то может быть в принципе лучше.
[22:19.080 --> 22:27.080]  Ага, значит все команды были равны, но здесь некоторые равнее других.
[22:27.080 --> 22:35.080]  То есть команды может быть дольше выполняются.
[22:35.080 --> 22:39.080]  Может быть больше занимают в памяти.
[22:39.080 --> 22:47.080]  То есть похоже это может быть и не риск архитектуры, а циск.
[22:47.080 --> 22:55.080]  С инструкциями разной длины и разным времени в работу.
[22:55.080 --> 23:23.080]  Rste у нас оказался еще одним аргументом нашего деления.
[23:23.080 --> 23:45.080]  Поделили и в результате.
[23:45.080 --> 24:05.080]  Затем мы опять что-то делим на r10, но в яx ничего не заносим.
[24:05.080 --> 24:11.080]  Значит куда у нас попало частное?
[24:11.080 --> 24:17.080]  В rx.
[24:17.080 --> 24:27.080]  Возможно в результате деления у нас использовался еще какой-то регистр.
[24:27.080 --> 24:41.080]  Раз мы вынуждены опять перед каждым делением обнулять edx.
[24:41.080 --> 25:05.080]  Вот наше деление в столбик.
[25:05.080 --> 25:25.080]  И остаток у нас.
[25:25.080 --> 25:35.080]  Вот такое деление, при котором в отличие от арма, где мы не обнаружили прямого вычисления остатка.
[25:35.080 --> 25:49.080]  В процессе вычисления частного заодно вычисляется и остаток.
[25:49.080 --> 26:07.080]  Мы делим изначально как было устроено умножение.
[26:07.080 --> 26:27.080]  Если мы перемножаем два числа размерности n, то какое число получаем?
[26:27.080 --> 26:37.080]  У нас есть древние-древние процессоры, еще 8-битные.
[26:37.080 --> 26:43.080]  И мы хотим реализовать умножение.
[26:43.080 --> 26:55.080]  Умножили 8-битные на 8-битные, скорее всего у нас не влезло, значит старшую часть нужно куда-то запихать.
[26:55.080 --> 27:05.080]  8-битные регистр не лезет, значит куда надо? В два.
[27:05.080 --> 27:21.080]  Поэтому перемножили AL на BL, например.
[27:21.080 --> 27:29.080]  И получилась пара регистров.
[27:29.080 --> 27:35.080]  Старшая часть BL, младшая часть BL.
[27:35.080 --> 27:43.080]  Дальше мы в этом процессе наконец-то делаем команду деления.
[27:43.080 --> 28:11.080]  А если мы поделили некоторое число и хотим получить частные длины n и делитель был длиной n, то какое максимальное длины было бы делимое?
[28:11.080 --> 28:35.080]  Делитель длины n, частная длина n, а число длины 2n мы храним в паре регистров.
[28:35.080 --> 29:03.080]  Если мы делим, например, пару регистров dx и ax, делим на какой-то регистр, например bx.
[29:03.080 --> 29:13.080]  Получаем в ax частное, а остаток куда деть?
[29:13.080 --> 29:23.080]  Регистров у нас внезапно мало, их всегда не хватает, но все равно мы запортили младшую часть большого числа.
[29:23.080 --> 29:31.080]  Если мы запортили младшую часть большого числа, значит dx уже смысла не имеет.
[29:31.080 --> 29:47.080]  Значит остаток запихнем dx.
[29:47.080 --> 30:13.080]  В этом нам важно, чтобы эта старшая часть была какой, чтобы нам удалось поделить, что у нас может пойти не так в определении.
[30:13.080 --> 30:29.080]  Делить на ноль у вас вроде как учили целый год в курсе матана, но все-таки в целых числах делать это не желательно.
[30:29.080 --> 30:43.080]  Допустим, это все-таки не ноль. Допустим, у нас будет один.
[30:43.080 --> 30:59.080]  Каким будет размер частного, если делитель 1, а делимые длины n?
[30:59.080 --> 31:15.080]  Поэтому, чтобы она влезла в один регистр, старшую часть нужно обнулить.
[31:15.080 --> 31:23.080]  Поэтому у нас происходит вот такая подготовка к делению.
[31:23.080 --> 31:48.080]  Да, конечно, это костыль, но исторически сохранившийся костыль приравнен теперь к несущей конструкции.
[31:48.080 --> 32:05.080]  Это все еще пока у нас числа были беззнаковые.
[32:05.080 --> 32:28.080]  Можем для простоты оставить деление всего лишь двух.
[32:28.080 --> 32:46.080]  Итак, вычление у нас происходит опять-таки в rx.
[32:46.080 --> 33:08.080]  Делим у нас было в rdi, делитель в rci первые два аргумента, а здесь происходит еще какая-то странная операция.
[33:08.080 --> 33:15.080]  Перед делением.
[33:15.080 --> 33:21.080]  Обращаем внимание, что числа знаковые.
[33:21.080 --> 33:29.080]  Если мы заполним старшую часть нулями, что будет с числом?
[33:29.080 --> 33:39.080]  А если мы делили отрицательное, оно вдруг стало положительным?
[33:39.080 --> 33:48.080]  А чем тогда заполнить старшую часть, чтобы число осталось ровно таким же, но отрицательно, только более длинным?
[33:48.080 --> 33:56.080]  Просто нулями не подходит. Давайте заполним не нулями.
[33:56.080 --> 34:02.080]  Значение числа при этом изменится.
[34:02.080 --> 34:07.080]  Нам нужно добавить ровно такое же число, чтобы оно стало нуливым.
[34:07.080 --> 34:16.080]  Помним, что число у нас в дополнительном коде.
[34:16.080 --> 34:21.080]  Было у нас такое число.
[34:21.080 --> 34:27.080]  Можно дописать слева лидирующие нули, можно дописать слева лидирующие единички.
[34:27.080 --> 34:37.080]  Если значение числа при этом не изменится, просто изменится его размер.
[34:37.080 --> 34:46.080]  Допустим, если у нас было число минус один, добавили единичку, получили ноль.
[34:46.080 --> 34:53.080]  То есть это минус один. Если оно стало длиннее, значение его не изменилось.
[34:53.080 --> 34:57.080]  От того, что мы слева дописали единички.
[34:57.080 --> 35:01.080]  Аналогично с другими отрицательными числами.
[35:01.080 --> 35:23.080]  Поэтому вот у нас rdx.
[35:23.080 --> 35:43.080]  Берем знаковый бит этого самого rx.
[35:43.080 --> 35:55.080]  Берем этот бит и размазываем.
[35:55.080 --> 35:57.080]  По всему rdx.
[35:57.080 --> 36:00.080]  То есть ставим его всего либо нули, либо единичками.
[36:00.080 --> 36:08.080]  В зависимости от этого старшего бита.
[36:08.080 --> 36:26.080]  Такое странное деление, но так реализовали.
[36:26.080 --> 36:48.080]  Как же здесь происходит ветвление?
[36:48.080 --> 37:14.080]  Посоливаем за торнарником.
[37:14.080 --> 37:20.080]  Посоляем.
[37:20.080 --> 37:24.080]  Здесь мы сравниваем.
[37:24.080 --> 37:38.080]  И куда попадает результат сравнения?
[37:38.080 --> 37:59.080]  Пока не воедем. Раз мы его выложим, модифицируемся.
[37:59.080 --> 38:27.080]  Вышли регистры. Результат выкинули.
[38:27.080 --> 38:37.080]  При каком условии rdi больше, чем rsi?
[38:37.080 --> 38:48.080]  Именно больше.
[38:48.080 --> 38:56.080]  Нет, мы вот именно так сравнивали.
[38:56.080 --> 39:06.080]  Rdi-rsi.
[39:06.080 --> 39:35.080]  То есть у нас сброшен зиру флаг.
[39:35.080 --> 39:42.080]  И еще какой флаг?
[39:42.080 --> 39:45.080]  Тоже сброшен.
[39:45.080 --> 39:59.080]  Если он не встал, значит у нас не получилось отрицательное число в результате этого вычитания.
[39:59.080 --> 40:03.080]  И зиру флаг тоже не встал, нуль тоже не получился.
[40:03.080 --> 40:07.080]  Не отрицательное и не ноль. Это что?
[40:07.080 --> 40:09.080]  Положительное.
[40:09.080 --> 40:13.080]  Как раз значит rdi строго больше, чем rsi.
[40:13.080 --> 40:21.080]  Это вот парадекат greater.
[40:21.080 --> 40:31.080]  И в зависимости от этого парадеката
[40:31.080 --> 40:59.080]  Мы поставили al в единичку либо в нолик.
[40:59.080 --> 41:27.080]  А старшую часть вы уже обнулили.
[41:27.080 --> 41:55.080]  Сделаем чуть-чуть по-другому.
[41:55.080 --> 41:59.080]  Мы сравнили.
[41:59.080 --> 42:15.080]  В один регистр занесли одно, в другое другое.
[42:15.080 --> 42:44.080]  И условно занесли в наш регистр edX при каком-то условии.
[42:44.080 --> 42:54.080]  Что значит меньше или равно?
[42:54.080 --> 43:17.080]  Если флаг знака или зиру флаг у нас стоят.
[43:17.080 --> 43:41.080]  То есть если у нас случай равно или случай меньше, тогда...
[43:41.080 --> 43:51.080]  Мы видим команду conditional move. Условно выполнен некоторую команду при некотором состоянии флага.
[43:51.080 --> 44:01.080]  Этот move у нас безусловный, а этот условный.
[44:01.080 --> 44:21.080]  Кроме того, этот move не поменял нам состояние флага.
[44:21.080 --> 44:43.080]  А может ли процессор делать эти команды не совсем по порядку, а слегка распараллельно?
[44:43.080 --> 44:55.080]  Сравнение и два присваивания у нас независимы. Их можно сделать параллельно.
[44:55.080 --> 45:00.080]  А conditional move зависит от состояния флага, который будет поставлен в результате сравнения.
[45:00.080 --> 45:08.080]  И вот как раз edX и ex.
[45:08.080 --> 45:20.080]  Но это уже на откоп самому процессору. Во время исполнения может быть он смотрит чуть вперед и что-то исполняет раньше.
[45:38.080 --> 45:52.080]  Но если он смотрит вперед и что-то исполняет раньше, то это не значит, что он смотрит вперед.
[45:52.080 --> 46:06.080]  Но если он смотрит вперед и что-то исполняет раньше, то это не значит, что он смотрит вперед.
[46:06.080 --> 46:20.080]  Но если он смотрит вперед и что-то исполняет раньше, то это не значит, что он смотрит вперед.
[46:20.080 --> 46:34.080]  Но если он смотрит вперед и что-то исполняет раньше, то это не значит, что он смотрит вперед.
[46:34.080 --> 47:02.080]  Конечно move мы видим, а тут у нас где-то должно быть еще одно сравнение.
[47:02.080 --> 47:16.080]  Мы сравнили два регистра и возможно куда-то перешли.
[47:16.080 --> 47:30.080]  В армии это называлось branch, а здесь у нас переход jump. Мы перепрыгнули на L7.
[47:30.080 --> 47:49.080]  После чего позвали функцию push. После чего вернулись на метку L2.
[47:49.080 --> 48:11.080]  Куда-то сходили и вернулись.
[48:11.080 --> 48:39.080]  Загрузили регистр, взяли регистр, закинули туда аргумент.
[48:39.080 --> 49:07.080]  И нам понравилась функция Lea. Пока еще временна магия.
[49:07.080 --> 49:35.080]  Теперь пройдемся по массиву.
[50:05.080 --> 50:33.080]  И просумируем все числа массива.
[51:03.080 --> 51:31.080]  Все-таки в интонском синтексе.
[51:31.080 --> 51:59.080]  Все-таки в интонском.
[51:59.080 --> 52:27.080]  Возможно вариант без оптимизации будет более простым.
[52:27.080 --> 52:55.080]  У нас есть обращение к памяти.
[52:55.080 --> 53:23.080]  Начало массива плюс смещение.
[53:23.080 --> 53:43.080]  Номер элемента, домноженный на что? На размер интон.
[53:43.080 --> 53:59.080]  Вот для таких вычислений. Причем как правило размеры, типы данных, какое число?
[53:59.080 --> 54:15.080]  Заранее известные и при этом степени двойки.
[54:15.080 --> 54:25.080]  Значит можем ли мы такую операцию сделать быстрее, чем простое умножение? Сложиться с двигом.
[54:25.080 --> 54:35.080]  Поэтому была предусмотрена отдельная команда сложиться с двигом.
[54:35.080 --> 55:03.080]  В данном случае мы наносим адрес.
[55:03.080 --> 55:09.080]  Адрес ЛЦ0 относительно РИП. РИП инструкцион поинтер. Сколько битный?
[55:09.080 --> 55:17.080]  6-4 битный.
[55:17.080 --> 55:27.080]  Относить на текущего положение смещение на метку ЛЦ0.
[55:27.080 --> 55:35.080]  Как раз адрес нашей строчки в нашем исполняемом коде.
[55:35.080 --> 55:45.080]  Заносится в РДИ и как раз становится аргументом функции ПУЦ.
[55:45.080 --> 55:49.080]  Теперь посмотрим как же это выглядит все в машинном коде.
[55:49.080 --> 56:05.080]  Поэтому мы не будем на этот раз останавливать компиляцию на этапе остального кода и посмотрим на машины.
[56:05.080 --> 56:29.080]  Дезасаблировали.
[56:29.080 --> 56:35.080]  И получили в каком сетоксисе с процентиками?
[56:35.080 --> 56:39.080]  В оттенке?
[57:05.080 --> 57:29.080]  Либо дезасаблировали.
[57:29.080 --> 57:33.080]  Дезасаблировали.
[57:33.080 --> 57:41.080]  Собственно минус Минтел.
[57:41.080 --> 58:01.080]  И получили уже ставший нам привычным Интел с кодеситоксисом.
[58:01.080 --> 58:17.080]  Видим здесь смещение относительно начала, коды команд и их расшифровку для чтения человека.
[58:17.080 --> 58:21.080]  Команда у нас какого размера?
[58:21.080 --> 58:29.080]  От 1 байта до как минимум 5.
[58:29.080 --> 58:33.080]  И даже 7 байта.
[58:33.080 --> 58:37.080]  Это характерный атрибут цискоархитектуры.
[58:37.080 --> 58:39.080]  У нас разные команды.
[58:39.080 --> 58:47.080]  Разного размера.
[58:47.080 --> 58:55.080]  Ну хотя в принципе можно видеть, что все равно каждая команда в отдельности принимает конца количества аргументов.
[58:55.080 --> 59:15.080]  Даже если мы их даем лучше.
[59:15.080 --> 59:17.080]  Соответствует.
[59:17.080 --> 59:23.080]  Мы в EIX заносим число.
[59:23.080 --> 59:25.080]  То есть то, что нужно.
[59:25.080 --> 59:27.080]  И в EIX заносим число.
[59:27.080 --> 59:29.080]  Раз Ешки.
[59:29.080 --> 59:31.080]  Они у нас сколько битные?
[59:31.080 --> 59:35.080]  32 бита, то бишь 4 байта.
[59:35.080 --> 59:37.080]  Ага, В занести.
[59:37.080 --> 59:39.080]  В какой именно регистр?
[59:39.080 --> 59:43.080]  Регистр номер 8 или регистр номер А.
[59:43.080 --> 59:47.080]  Вот.
[59:47.080 --> 59:49.080]  Куда занести.
[59:49.080 --> 59:51.080]  А теперь само число.
[59:51.080 --> 59:55.080]  Причем в каком порядке байтов?
[59:55.080 --> 01:00:01.080]  Да, в лидл-энди.
[01:00:01.080 --> 01:00:03.080]  То же самое.
[01:00:03.080 --> 01:00:05.080]  Непосредственное число.
[01:00:13.080 --> 01:00:41.080]  Ну сами команды имеют разный размер, поэтому вычислять где следующая команда сложнее.
[01:00:41.080 --> 01:00:47.080]  Чтобы вычислить где следующая, нужно декодировать предыдущую.
[01:00:47.080 --> 01:00:55.080]  А просто сказать сдвинься на 7 команд влево у нас не получится.
[01:00:55.080 --> 01:00:59.080]  Даль на 7 команд вперед не получится.
[01:01:11.080 --> 01:01:25.080]  Напишем кто-нибудь, что уже целиково и может запуститься.
[01:01:41.080 --> 01:01:59.080]  И можем запустить это под отладчиком.
[01:01:59.080 --> 01:02:05.080]  Например, отладчик ГДБ.
[01:02:05.080 --> 01:02:19.080]  Было больше информации, добавим опцию минус G.
[01:02:19.080 --> 01:02:25.080]  Ставим breakpoint на функцию main.
[01:02:25.080 --> 01:02:27.080]  И R. Inforegisters.
[01:02:27.080 --> 01:02:31.080]  Да, та самая команда, которую вы реализовали в своем процессоре.
[01:02:31.080 --> 01:02:35.080]  Но программа еще не запущена, у нее еще нет регистра.
[01:02:35.080 --> 01:02:37.080]  Запускаем.
[01:02:37.080 --> 01:02:39.080]  Run.
[01:02:39.080 --> 01:02:47.080]  Поскольку мы добавили опцию минус G, у нас появилась в исполнении в фаре отладочная информация.
[01:02:47.080 --> 01:02:51.080]  В частности информация, какой код на C этим командам соответствует.
[01:02:51.080 --> 01:02:55.080]  Мы не выполняем непосредственно код на C.
[01:02:55.080 --> 01:03:07.080]  Но поставить метки, что вот у нас была такая команда носивка, она скомпилировала света, мы можем.
[01:03:07.080 --> 01:03:11.080]  Inforegisters.
[01:03:11.080 --> 01:03:19.080]  Ой, сколько у нас всяких регистров. Интересно, как получилось.
[01:03:19.080 --> 01:03:25.080]  РАХ, РБХ, РЦХ, РДХ.
[01:03:25.080 --> 01:03:31.080]  Вот четыре основных архиметических регистра.
[01:03:31.080 --> 01:03:37.080]  АХ, аккумулятор, регистр.
[01:03:37.080 --> 01:03:41.080]  ДХ, датарегистр.
[01:03:41.080 --> 01:03:44.080]  К ним гвоздями прибыто деление.
[01:03:44.080 --> 01:03:48.080]  И умножение.
[01:03:48.080 --> 01:03:50.080]  То есть регистр у нас не общего назначения.
[01:03:50.080 --> 01:03:56.080]  Это еще один признак цискархистектуры.
[01:03:56.080 --> 01:03:59.080]  РСИ, РДИ.
[01:03:59.080 --> 01:04:04.080]  Изначально Source Index, Destination Index.
[01:04:04.080 --> 01:04:11.080]  Оно сейчас используется для передачи аргументов функций.
[01:04:11.080 --> 01:04:13.080]  РБП, РСП.
[01:04:13.080 --> 01:04:17.080]  Base pointer, stack pointer.
[01:04:17.080 --> 01:04:31.080]  Base pointer используется как регистр, в котором хранится адрес, относительно которого мы как-то базируемся, что-то отчитываем.
[01:04:31.080 --> 01:04:35.080]  Stack pointer, указатель на вершину стека.
[01:04:35.080 --> 01:04:40.080]  А вот тут Intel надоело выдумывать название.
[01:04:40.080 --> 01:04:43.080]  И они решили сделать по-простому.
[01:04:43.080 --> 01:04:53.080]  Восьмой, девят, десятый и так далее до пятнадцатого.
[01:04:53.080 --> 01:05:05.080]  Если продолжить назад, РАХ будет нулевой.
[01:05:05.080 --> 01:05:11.080]  Также есть крайне важный регистр.
[01:05:11.080 --> 01:05:13.080]  Instruction point.
[01:05:13.080 --> 01:05:27.080]  В данном случае в 64-битной своей спостасе, который хранит, какую команду выполнит следующий.
[01:05:27.080 --> 01:05:31.080]  То есть переход это фактически записи в Instruction point.
[01:05:31.080 --> 01:05:33.080]  Ну а также регистр флагов.
[01:05:33.080 --> 01:05:35.080]  В данном случае E-flags.
[01:05:35.080 --> 01:05:43.080]  В случае 64-битности там ничего особо не добавили.
[01:05:43.080 --> 01:05:48.080]  И какие флаги у нас сейчас установлены.
[01:05:48.080 --> 01:05:51.080]  Parity flag.
[01:05:51.080 --> 01:05:53.080]  Ну и interrupt.
[01:05:53.080 --> 01:06:02.080]  То есть мы сейчас все постоянно прерываем.
[01:06:02.080 --> 01:06:07.080]  Parity flag.
[01:06:07.080 --> 01:06:12.080]  Также у нас есть сегментный регистр.
[01:06:12.080 --> 01:06:17.080]  В частности код и сегмент, stack и сегмент.
[01:06:17.080 --> 01:06:24.080]  В каком сегменте, поймите, что у нас лежит.
[01:06:24.080 --> 01:06:32.080]  Сделаем шаг.
[01:06:32.080 --> 01:06:35.080]  У нас что-то, возможно, поменялось.
[01:06:35.080 --> 01:06:55.080]  Что-то в регистре было записано.
[01:06:55.080 --> 01:06:57.080]  А х, например, показалось единичка.
[01:06:57.080 --> 01:07:08.080]  Оттуда вернулся код вас рата из нашей функции.
[01:07:08.080 --> 01:07:37.080]  Ну вот мы из функции вышли.
[01:07:37.080 --> 01:07:40.080]  Ну поскольку архитектура достаточно древняя,
[01:07:40.080 --> 01:07:47.080]  оброшая всяким софтом, существует и множество диалектов ассамблера.
[01:07:47.080 --> 01:07:55.080]  То есть помимо разного синтактиса, еще и разные диалекты.
[01:07:55.080 --> 01:08:07.080]  В частности, диалект у нас.
[01:08:55.080 --> 01:09:01.080]  Мы написали нашу программу.
[01:09:01.080 --> 01:09:07.080]  Как вы думаете, что она сделает?
[01:09:07.080 --> 01:09:14.080]  У нее торчит наружу контакт, к которому можно подпаяться.
[01:09:14.080 --> 01:09:20.080]  Контакт называется main.
[01:09:20.080 --> 01:09:24.080]  Вот она, метка main.
[01:09:24.080 --> 01:09:32.080]  Мы обнуляем регистр rx вот таким способом.
[01:09:32.080 --> 01:09:40.080]  Потому что это короче, чем заносить туда константу.
[01:09:40.080 --> 01:09:43.080]  И чуть-чуть быстрее работает.
[01:09:43.080 --> 01:09:48.080]  Тут у нас инструкция работает разное время, занимает разное место в памяти.
[01:09:48.080 --> 01:10:12.080]  В отличие от риск архитектуры.
[01:10:12.080 --> 01:10:18.080]  Получили уже объектный файл в виде executable, unlinkable формат.
[01:10:18.080 --> 01:10:38.080]  Мы его можем разобрать с помощью дампа.
[01:10:38.080 --> 01:10:45.080]  Функция main состоящая из целой одной команды.
[01:10:45.080 --> 01:11:00.080]  Длиной 3 байта.
[01:11:00.080 --> 01:11:04.080]  Дальше мы можем отравить гнусный компилятор.
[01:11:04.080 --> 01:11:09.080]  В составе которого много всего хорошего, в частности линковщика.
[01:11:09.080 --> 01:11:14.080]  Он берет все наши объектные файлы.
[01:11:14.080 --> 01:11:18.080]  Как радиодетали рассыпухой и спаивает их.
[01:11:18.080 --> 01:11:22.080]  Тут был выход под названием main, тут есть вход под названием main.
[01:11:22.080 --> 01:11:24.080]  Спаиваем и так далее.
[01:11:24.080 --> 01:11:36.080]  Это линковка, а наша связывание.
[01:11:36.080 --> 01:11:51.080]  Вот наша программа запустилась.
[01:11:51.080 --> 01:12:06.080]  Это целиковая программа, написанная на нашем ассамбле Renas.
[01:12:06.080 --> 01:12:10.080]  А как бы автоматизировать эту сборку?
[01:12:10.080 --> 01:12:27.080]  С помощью каких инструментов?
[01:12:27.080 --> 01:12:32.080]  Например, с помощью make.
[01:12:32.080 --> 01:12:38.080]  Тест A это у нас цель.
[01:12:38.080 --> 01:12:45.080]  Тест S исходный текст.
[01:12:45.080 --> 01:13:03.080]  Скомпилировать ассамблем NASMA в формат executable and likable формат.
[01:13:03.080 --> 01:13:05.080]  Всполняемый файл.
[01:13:05.080 --> 01:13:09.080]  Попозже назовем его exec.
[01:13:09.080 --> 01:13:19.080]  Чтобы его собрать нам нужен объектный файл.
[01:13:19.080 --> 01:13:25.080]  Например, натравливаем линковщик.
[01:13:25.080 --> 01:13:29.080]  Тест O у нас уже существует.
[01:13:29.080 --> 01:13:44.080]  И первая цель в make файле, которая у нас получается по умолчанию.
[01:13:44.080 --> 01:14:00.080]  Дата модификации объектного файла позже, чем исходного.
[01:14:00.080 --> 01:14:06.080]  Если у нас исходный файл модифицируем позже, чем исполняемый.
[01:14:06.080 --> 01:14:21.080]  Может ли исполняемый быть скомпилирован из этого исходника?
[01:14:21.080 --> 01:14:26.080]  Если у нас время идет нормально, то не мог.
[01:14:26.080 --> 01:14:28.080]  Значит его нужно перекомпилировать.
[01:14:28.080 --> 01:14:30.080]  В противном случае зачем?
[01:14:30.080 --> 01:14:41.080]  Тут как раз то, что в самом начале название нашего предмета, технология программирования.
[01:14:41.080 --> 01:14:45.080]  Вот это вам пригодится, даже если вы забудете весь ассамблер.
[01:14:45.080 --> 01:14:51.080]  А именно make файл.
[01:14:51.080 --> 01:14:55.080]  Или возможно какие-то надстройки, которые позволяют их автоматически генерить.
[01:14:55.080 --> 01:15:02.080]  Например, CMake или CMake.
[01:15:02.080 --> 01:15:24.080]  Собрать исполняемый файл.
[01:15:24.080 --> 01:15:29.080]  И поменяли дату риме, просто обновили.
[01:15:29.080 --> 01:15:35.080]  И вот у нас уже полностью пересобирается наш объектный файл.
[01:15:35.080 --> 01:15:49.080]  И из объектного файла линкуется исполняемый.
[01:15:49.080 --> 01:16:00.080]  Если уж мы хотим так, то исполняемый файл должен получаться тот, который мы назовем.
[01:16:00.080 --> 01:16:03.080]  Минус о, аутут.
[01:16:03.080 --> 01:16:14.080]  То есть какой должен получиться результат работы.
[01:16:14.080 --> 01:16:17.080]  Выбил только та часть моего файла, которая требуется.
[01:16:17.080 --> 01:16:22.080]  Если у вас будет большой проект, на гигабайт так исходного кода.
[01:16:22.080 --> 01:16:26.080]  И вы изменили там очень мало.
[01:16:26.080 --> 01:16:32.080]  То обновление мейком вам поможет сильно сэкономить врига.
[01:16:32.080 --> 01:16:38.080]  При этом у нас разные части собраны разными компиляторами.
[01:17:17.080 --> 01:17:21.080]  И возможно нам потребуется не только исполняемый код, но и данный.
[01:17:47.080 --> 01:18:02.080]  Мы хотим позвать принт.
[01:18:02.080 --> 01:18:05.080]  Ей нужно передать аргументы.
[01:18:05.080 --> 01:18:28.080]  Как мы их передадим?
[01:18:28.080 --> 01:18:31.080]  Увы, линф неизвестен.
[01:18:31.080 --> 01:18:39.080]  Что же мы делали? Обычно ради этого.
[01:18:39.080 --> 01:18:46.080]  Говорили, что мы где-то друг в другом месте объявим.
[01:18:46.080 --> 01:18:57.080]  Так и напишем.
[01:18:57.080 --> 01:19:02.080]  Но почему-то не выявилось.
[01:19:02.080 --> 01:19:17.080]  Объектный файл собрался.
[01:19:17.080 --> 01:19:20.080]  Но не получилось. Почему?
[01:19:20.080 --> 01:19:47.080]  Потому что по умолчанию мы пытаемся сделать динамический линкуемый файл.
[01:19:47.080 --> 01:19:51.080]  А нас нам родил статический линкуемый.
[01:19:51.080 --> 01:20:04.080]  Попробуем так.
[01:20:04.080 --> 01:20:17.080]  Опять таки не вывел, а попробуем в еды.
[01:20:17.080 --> 01:20:42.080]  Тоже вывел.
[01:20:42.080 --> 01:20:52.080]  Пока не выводит.
[01:20:52.080 --> 01:20:58.080]  Но поскольку уже звонок был, и сейчас приедет следующий лектор.
[01:20:58.080 --> 01:21:02.080]  То чего же у нас там не хватает?
[01:21:02.080 --> 01:21:04.080]  И как это исправить?
[01:21:04.080 --> 01:21:10.080]  Это уже на следующий лектор.
