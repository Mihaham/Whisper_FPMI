[00:00.000 --> 00:18.880]  значит что мы в прошлый раз изучили значит мы изучили что любую функцию значит можно представить
[00:18.880 --> 00:28.680]  значит как кнф значит можно представить как dnf значит и так же можно представить как
[00:28.680 --> 00:42.000]  многочлен жигалкин вот а какие связки нам нужны чтобы эти формы записывать но вот чтобы
[00:42.000 --> 00:50.800]  представлять кнф dnf до ночи нам нужно отрицание конъюнции дизюнция ну и тут тоже отрицание
[00:51.800 --> 01:01.080]  значит чтобы записывать многочлены нам нужна конъюнция то есть умножение или наоборот
[01:01.080 --> 01:10.280]  умножение то есть конъюнция и сложение то есть ксор вот но на самом деле это мы определяли только
[01:10.280 --> 01:18.640]  через сложение и умножение чтобы это записать нужно еще один символ единица потому что когда
[01:18.760 --> 01:25.960]  определяли мы говорили что единица но это вот такое пустое произведение произведение нуля
[01:25.960 --> 01:33.920]  переменных это как бы единица но с помощью переменной можно записать произведение одной
[01:33.920 --> 01:40.120]  переменной с помощью нескольких переменных и конъюнции может сказать при zdję interject
[01:40.120 --> 01:47.200]  нуля переменных нужно еще специальные силы единица вот с другой стороны чтобы записать
[01:47.200 --> 01:54.200]  сумму нуля переменных. Специально символа не нужно, можно просто писать x-xor-x.
[01:54.200 --> 02:05.560]  x-xor-x это 0, значит и поэтому, чтобы 0 записать другого,
[02:05.560 --> 02:12.720]  других символов не нужно. Вот, на самом деле, в случае с KNF и с DNF можно
[02:12.720 --> 02:21.120]  заметить закон Д. Моргана, и что P конъюнция Q это будет, так, сейчас дайте,
[02:21.120 --> 02:26.760]  я не равно напишу, а эквивалентно, хотя можно и равно в данном случае. Да, дайте я,
[02:26.760 --> 02:36.680]  наоборот, равно напишу, значит это равно отрицанию, дезюнции отрицаний.
[02:37.160 --> 02:45.040]  Соответственно, можно все конъюнции заменить на вот такие штуки и останутся
[02:45.040 --> 02:52.880]  только отрицание и дезюнция. Ну или наоборот, значит, можно писать, что P или Q
[02:52.880 --> 03:01.000]  это будет отрицание, отрицание P и отрицание Q. Да, и можно, наоборот, все
[03:01.320 --> 03:05.800]  дезюнции заменить на такие штуки, останутся только отрицание и конъюнция.
[03:05.800 --> 03:22.360]  Вот, получается вывод, значит вывод, что можно, можно все формулы, значит, можно все
[03:22.360 --> 03:34.040]  формулы записать, только используя все, сейчас не формулы, наверное, а функции.
[03:34.040 --> 03:40.960]  Ну а форма как бы преобразована как эквивалентно, значит, функции записать,
[03:40.960 --> 03:54.040]  так дайте я чуть подробнее напишу, значит, записать формулами, использующими только,
[03:54.040 --> 04:15.200]  значит, использующими только. Ну вот, первый, значит, первый вариант только отрицание и конъюнция,
[04:15.200 --> 04:22.320]  второй вариант только отрицание и дезюнция, значит, третий вариант только вот эти вот,
[04:22.920 --> 04:30.560]  конъюнцию, ксор и единицу, ну и так далее, да, значит, можно еще много других вариантов,
[04:30.560 --> 04:43.080]  ну давайте какой-нибудь еще не тривиальный вариант я напишу, значит, например, можно рассмотреть
[04:43.080 --> 04:58.360]  импликацию и тождественную ноль, тождественную ложь, тоже, значит, это будет другой язык,
[04:58.360 --> 05:05.040]  значит, импликация, тождественная ложь, но можно в этом языке тоже все что угодно записать,
[05:05.040 --> 05:16.440]  значит, а именно отрицание будет записываться, ну как то, что из П следует ноль, значит,
[05:16.440 --> 05:23.440]  это вообще полезный, полезная точка зрения на отрицание, да, что П неверно, если из П следует
[05:23.440 --> 05:30.000]  ложь, да, то есть, как бы, если из П следует ложь, то П само ложно, и это тут и написано,
[05:30.000 --> 05:43.360]  ну а дальше можно написать, например, да, значит, мы знаем, что, значит, П влечет Ку,
[05:43.360 --> 05:53.400]  это то же самое, что не П или Ку, и тогда можно это опять же переначить и написать,
[05:53.400 --> 06:04.160]  что П или Ку, это будет, что отрицание П влечет Ку, вот, а после этого происходит следующее,
[06:04.160 --> 06:12.640]  что мы уже выразили отрицание, значит, и уже выразили дизюнцию, а через отрицание дизюнции
[06:12.640 --> 06:19.440]  можно выразить все что угодно, через КНФ, ДНФ, тогда получается, что и через импликацию и ноль,
[06:19.440 --> 06:30.760]  мы тоже можем выразить все что угодно, хорошо, значит, это примеры такие положительные, да,
[06:30.760 --> 06:38.040]  значит, когда мы можем все выразить, дайте еще один пример, значит, пример, когда можно даже из
[06:38.040 --> 06:47.720]  одной связки все выразить, значит, пусть есть штрих шефера, значит, штрих шефера это отрицание
[06:47.720 --> 07:12.680]  конъюнции, штрих шефера это у нас отрицание конъюнции, значит, тогда нам только его одного хватит,
[07:12.680 --> 07:28.240]  значит, почему, ну потому что теперь отрицание П это будет П штрих П, да, значит, почему,
[07:28.240 --> 07:40.400]  ну потому что если П это ноль, да, то ноль конъюнции ноль это ноль, а потом еще отрицание это один, да,
[07:40.400 --> 07:46.720]  поэтому ноль штрих ноль это один, ну а с единицей наоборот, единица конъюнции единицы это единица,
[07:46.720 --> 07:53.400]  отрицание это ноль, то есть один штрих один это ноль, ну а дальше может, например, конъюнцию выразить,
[07:53.400 --> 08:04.720]  значит, П конъюнция Q это будет отрицание штриха шефера, да, если штрих шефера это отрицание
[08:04.720 --> 08:12.320]  конъюнции, то наоборот конъюнция это отрицание штриха шефера, ну а отрицание у нас уже есть,
[08:12.320 --> 08:24.400]  то есть получается штрих шефера П и Q штрих сам с собой, вот, ну а дальше как раньше, если у нас есть
[08:24.400 --> 08:30.400]  отрицание конъюнции, то тогда можно все что угодно выразить, вот, это вот такой пример, да,
[08:30.400 --> 08:38.360]  значит, пример ровно одной операции, через которую все можно выразить, значит, у этого факта есть такое,
[08:38.360 --> 08:47.120]  так сказать, электротехническое применение, да, что можно прям какие-то микросхемы поять логические,
[08:47.120 --> 08:55.320]  которые будут вычислять логические функции, ну так что у каждого элемента, да, какой-нибудь реле там или
[08:55.320 --> 09:00.960]  транзистор или что-нибудь еще, значит, у этого элемента есть какие-то проводки, которые в него входят,
[09:00.960 --> 09:06.720]  вот, дальше в этом элементе что-то происходит и, соответственно, из него проводок выходит наружу,
[09:06.720 --> 09:12.440]  но и этот элемент вычисляет логическую функцию, если в зависимости от того, есть ли ток на входящих
[09:12.440 --> 09:18.600]  проводках, будет или не будет ток на исходящем проводе, но дальше еще может какие-нибудь разветвить
[09:18.600 --> 09:30.040]  или ставить, да, как дублировать сигнал, вот, ну можно и не ставить, вот, тогда получается, что можно считать,
[09:30.040 --> 09:37.760]  что у вас вот есть ассортимент таких базовых элементов, да, есть элемент отрицания и элемент
[09:37.760 --> 09:44.280]  дизъюнция, и тогда из таких двух элементов вы можете спаять все что угодно, да, что у вас будет
[09:44.280 --> 09:50.120]  вычислять любую функцию, вот, но есть какая-то вопрос, а можете только из одного элемента, значит, любую
[09:50.120 --> 09:55.720]  схему спаять, да, потому что удобнее выпускать только один элемент, да, на производственной линии, но вот,
[09:55.720 --> 10:02.440]  как раз штрих шефера является примером такого элемента, ну, а второй, например, стрелка пирса,
[10:02.440 --> 10:11.680]  примерно, также делается, вот, поэтому там всякие люди, которые на низком уровне изучают всякие
[10:11.680 --> 10:22.240]  процессоры и микросхемы, да, значит, они это очень любят, называют nand, потому что not end, а стрелку пирса
[10:22.240 --> 10:32.960]  называют nor, да, потому что not or, ну и, соответственно, вот, в принципе, можно схему для любой функции
[10:32.960 --> 10:46.520]  спаять вот только из таких элементов, да, хорошо, ну ладно, теперь с другой стороны, давайте посмотрим, пусть у нас
[10:46.520 --> 10:57.800]  теперь, например, нет отрицания, да, пусть есть только, значит, пусть есть только
[10:57.800 --> 11:08.360]  conjunction, disunction, implication, да, вот, пусть мы из наших четырех базовых связок убрали отрицание,
[11:08.360 --> 11:20.680]  оставили только вот такие бинарные связки, значит, можно ли тогда все выразить? Ну, смотрите, значит,
[11:20.680 --> 11:29.240]  knf-dnf уже не получится, да, потому что отрицание нужно, да, значит, начнешь галкин тоже не получится,
[11:29.240 --> 11:36.240]  единицу-то можно получить, да, как p влечет p, а вот xor не понятно, как получить,
[11:36.240 --> 11:47.120]  вот, на самом деле тут уже не все можно получить по следующей причине, смотрите, пусть мы написали
[11:47.120 --> 11:52.400]  формулу только из conjunction, disunction, implication, без отрицаний, без xor, да, без чего-либо еще,
[11:52.400 --> 12:03.160]  и подставили мы в нее все единицы, тогда что мы получаем, да, получаем, что единица
[12:03.200 --> 12:09.440]  конъюнкция единицы это единица, значит, единица-дизюнкция единицы это единица,
[12:09.440 --> 12:19.040]  и единица-импликация единицы это единица, ну и дальше можно индукции ей по обвстроению
[12:19.040 --> 12:26.800]  формулы доказать, что тогда любая такая формула, будучи вычисленной на одних единицах, дает единицу,
[12:26.800 --> 12:37.240]  да, то есть вот из этих трех вещей следует, что если мы в функцию подставим все единицы, значит,
[12:37.240 --> 12:51.000]  то получится единица, вот, ну и так, скажем, если это саму экваленцию еще добавить,
[12:51.000 --> 13:00.520]  например, то там тоже будет то же самое, вот, в общем, тут этого нам не хватит, да,
[13:00.520 --> 13:06.400]  значит, нам нужно что-то, что единица превращает в ноль, не обязательно прям отрицание, да,
[13:06.400 --> 13:14.600]  значит, может быть из штрих-шефера, да, или даже xor, да, вот если сюда добавить xor, то уже все
[13:14.600 --> 13:21.280]  можно выразить, да, потому что единица через импликацию выражается, да, конъюнкции xor и единицы дают
[13:21.280 --> 13:30.920]  через навещание нажигалкина все на свете, вот, но как раз xor на единицах две единицы превращает в ноль,
[13:30.920 --> 13:42.080]  хорошо, то есть только такое препятствие, да, значит, такое препятствие, что если базовые связки,
[13:42.080 --> 14:02.160]  значит, препятствие, что если базовые связки все сохраняют единицу, то есть при подстановке единиц дают
[14:02.160 --> 14:15.800]  результат 1, то и все, что можно выразить, тоже сохраняет единицу, значит, то и все выразимое
[14:22.080 --> 14:23.760]  тоже сохраняет единицу.
[14:32.160 --> 14:50.800]  Вот, не, ну хорошо, допустим, допустим, мы от этого избавились, да, хорошо, давайте, ну вот если взять
[14:50.800 --> 15:02.040]  импликацию xor, соответственно, конъюнкции дизъюнкции, да, то это нам даст все что угодно, даже на самом
[15:02.040 --> 15:08.440]  деле просто импликация xor уже даст все что угодно, потому что через xor можно получить ноль, да, из
[15:08.440 --> 15:15.600]  импликации нуля можно получить все что угодно, вот, хорошо, а теперь попробуем заменить импликацию на
[15:15.600 --> 15:25.440]  xor вот в этом наборе, да, значит, и получим, например, значит, получим конъюнкции дизъюнкции xor, тогда вот того
[15:25.440 --> 15:34.720]  препятствия не будет, да, потому что 1 xor 1 это ноль, но будет симметричное препятствие, что если мы нули
[15:34.720 --> 15:45.000]  подставим, то, соответственно, будут оставаться одни нули, да, значит, тут получается препятствие,
[15:45.000 --> 15:59.160]  что 0 конъюнкции 0 это 0, 0 дизъюнкции 0 это 0 и 0 xor 0 это 0, да, и получается симметричное, значит,
[15:59.160 --> 16:08.280]  симметричное препятствие, что отсюда, соответственно, f от всех нулей должно равняться нулю,
[16:08.280 --> 16:21.720]  так, ну, хорошо, значит, моя задача на сегодня это рассказать некоторую общую теорию, значит,
[16:21.720 --> 16:27.080]  как по набору исходных функций понять все можно выразить или не все можно выразить,
[16:27.080 --> 16:33.200]  значит, если это функция двух аргументов, то там, в принципе, не так уж и много вариантов,
[16:33.200 --> 16:38.160]  ну, что-таки не так уж и мало, но не так уж и много, в принципе, можно как-то разобраться на
[16:38.160 --> 16:43.280]  пальцах, но если исходные функции от произвольного числа аргументов тоже нужна некоторая теория,
[16:43.280 --> 16:52.920]  вот, и вот эту теорию развил американский логик Эмиль Пост в середине 20 века, и он вообще ввел
[16:52.920 --> 16:59.600]  полную классификацию, значит, полная классификация это уже немножко специальная тема для спецкурса,
[16:59.600 --> 17:09.560]  скорее, чем для регулярных лекций, но самую важную часть мы изучим, значит, если вас заинтересует
[17:09.560 --> 17:20.680]  более подробно, то ключевые слова, значит, это решетка Поста, значит, решетка, да, почему,
[17:20.680 --> 17:34.080]  потому что вообще слово решетка это многозначное в математике, и разный объект называется решетками,
[17:34.080 --> 17:39.080]  бывают решетки как упорядоченное множество, бывают решетки как экологические структуры,
[17:39.080 --> 17:53.080]  бывают решетки как дискретные подножства пространства, вот, но, наверное, все, где-то три основных
[17:53.080 --> 18:08.360]  значения, вот так, ну вот, значит, это, соответственно, значит, набор, ну, не набор, как бы, систематизация,
[18:08.360 --> 18:24.200]  систематизация замкнутых классов вулевых функций, так, а что такое замкнутый класс, ну, сейчас поговорим,
[18:24.200 --> 18:45.400]  значит, сначала нужно что-то вроде обобщенной формулы написать, но, смотрите, у нас в наших
[18:45.600 --> 18:54.600]  в наших проектах построения формулы была унарная операция, это отрицание, которое просто приписывалось слева к формуле,
[18:54.600 --> 19:02.000]  и были разные бинарные операции, которых можно было других добавить, да, не конъюнкции, дезинкции, импликации,
[19:02.000 --> 19:10.200]  а любые другие можно взять, которые писались в так называемой инфиксной записи, да, когда символ операции
[19:10.200 --> 19:17.800]  между двумя оперантами пишется, но если у вас функция от трех аргументов, то там понятие инфиксной записи уже будет
[19:17.800 --> 19:31.000]  бессмысленно, хотя вообще иногда бывает, да, значит, есть вот такая вот функция, это называется тернарный оператор,
[19:31.000 --> 19:39.400]  если вдруг кто не знает, это значит следующее, если p истинно, то оно берет q, а если p ложно, то берет r, да, то есть это
[19:39.400 --> 19:50.600]  как бы такое if-then-else оператор, вот, но это, пожалуй, единственный пример, когда функция больше, чем от двух аргументов
[19:50.600 --> 19:57.800]  записывается в инфиксной форме, вот, а обычно функции записывают все-таки вот так вот, да, например, функция большинства,
[19:57.800 --> 20:07.800]  значит, majority от pqf, да, то есть есть какое-то специальное имя его функции, и дальше в скобках через запятую перечисляются аргументы.
[20:08.200 --> 20:18.600]  Вот, ну и, значит, удобно, соответственно, в общем виде так записывать формулы, так, ну и давайте я прям параллельно,
[20:18.600 --> 20:30.200]  параллельно можно говорить, значит, про суперпозицию функций, ну или по-простому композицию, да, но иногда говорят, что композиция
[20:30.600 --> 20:41.400]  то, что мы в УХТЧ изучали, да, что композиция бывает у функции одного аргумента, а если функция многих аргументов, то это уже надо называть не композиция, а суперпозиция.
[20:41.600 --> 21:02.600]  Так, значит, вот есть понятие суперпозиции функций, суперпозиция функций, значит, и можно также писать от формулы
[21:02.800 --> 21:13.800]  с произвольным набором базовых связок.
[21:20.800 --> 21:31.800]  Так, значит, с точки зрения, значит, это более-менее каждой формуле как записи соответствует функции как суперпозиция.
[21:32.800 --> 21:55.800]  Значит, база рекурсивного определения, значит, это когда как бы глубина 0, значит, если глубина 0, значит, тогда суперпозиция глубины 0,
[21:56.000 --> 22:11.000]  и это просто уже называется проектор, значит, проектор на ИТ-у координату, значит, от А1 и так далее АН, значит, это будет АИТ.
[22:15.000 --> 22:22.000]  Значит, это проектор, вот, или еще есть такое красочное название из теории общественного выбора, это диктаторская функция.
[22:26.000 --> 22:41.000]  Почему диктаторская? Ну, потому что вот как ИТ решил, так и будет, значит, тут ИТ и диктатор.
[22:42.000 --> 22:50.000]  То есть вообще теория общественного выбора изучает такие правила агрегирования, что, например, к какому-то вопросу у каждого члена общества есть мнение
[22:50.200 --> 23:00.200]  за или против, чтобы это была булева функция, нужно взять только два варианта, нельзя издержаться или скорее, ничего такого нет, просто либо 0, либо 1.
[23:01.200 --> 23:08.200]  Ну, а вот эта функция агрегирования получает все эти мнения и какой-то результат возвращает.
[23:09.200 --> 23:13.200]  Ну, вот диктаторская функция, когда есть один диктатор, и как диктатор решил, так и будет.
[23:13.400 --> 23:27.400]  Хорошо, значит, в случае с формулой то глубина 0 это просто переменная, значит, здесь глубина 0 это просто ПИТ.
[23:27.600 --> 23:34.600]  Значит, сама по себе переменная это формула глубины 0.
[23:35.600 --> 23:53.600]  Так, ну а дальше, значит, глубина N, так, давайте, так, нет, N это у нас число переменных, но давайте глубина это D, значит D, D плюс 1, значит глубина D плюс 1.
[23:53.800 --> 24:13.800]  Значит, это вот, что, это получается, что, ну какая-то запись вот такого вида F от phi 1 и так далее, phi kt, значит, где вот эти все phi t,
[24:14.000 --> 24:21.000]  значит, phi t это формулы глубины меньше либо равно D.
[24:22.000 --> 24:32.000]  Ну и вообще-то, если вы хотите, чтобы глубина была определена однозначно, то надо сказать, что они все меньше либо равно D и какая-то одна ровно D, тогда тут будет глубина D плюс 1.
[24:33.000 --> 24:37.000]  Вот, если вам это не нужно, можно не обращать внимания и говорить, что они все глубины не больше D.
[24:37.200 --> 24:55.200]  Вот, ну а F, это вот базовая связка, значит, F это базовая связка, значит, как говорят, валентности k или r-ности или местности.
[24:55.400 --> 25:11.400]  Да, в общем, все эти слова означают, что k это сколько, ну в случае, смотрите, в случае функции k это сколько аргументов в функции, ну а в случае вот такой записи это просто сколько как бы мест для подстановки.
[25:13.400 --> 25:23.400]  Вот, ну и чтобы было единообразно, можно всюду так записывать, да, со скобками, да, в инфиксной записи, в смысле не в инфиксной, а наоборот в префиксной записи,
[25:23.600 --> 25:31.600]  когда сначала идет значок, а потом там в скобках через запятые перечисляются все аргументы.
[25:33.600 --> 25:43.600]  Вот, значит, это с точки зрения формулы, ну а с точки зрения суперпозиции, ну аналогично, да, значит, что у вас,
[25:43.800 --> 26:01.800]  да, что у вас есть какие-то функции, значит, g1 и так далее, gk, значит, это вот суперпозиция, суперпозиция глубины меньше либо равно d.
[26:02.000 --> 26:14.000]  Соответственно, f это функция от k аргументов, ну и, соответственно, вот как бы суперпозиция, так, давайте я там напишу,
[26:15.000 --> 26:27.000]  значит, суперпозиция будет, ну вот, примерно так и выглядеть, да, то есть будет, что h от a1 и так далее,
[26:27.200 --> 26:35.200]  а n, значит, это будет f от g1, от a1 и так далее, а n, значит, и так далее, значит, gk от a1 и так далее, а n.
[26:39.200 --> 26:47.200]  Вот, ну и видно, что, в общем, то, что я написал вот здесь, вот это, ну более-менее то же самое, да, что я написал,
[26:47.400 --> 26:53.400]  вот здесь, вот только здесь, как бы раскручивается до основания, да, и получается какие-то длинные формулы,
[26:55.400 --> 27:03.400]  а здесь получается, что мы как бы вычислили, что они за значение вернули, и эти значения подставили в функцию f.
[27:03.600 --> 27:15.600]  Так, в общем, кратко, это все было к чему? Это все было к тому, что можно определить формулы не только от отрицания конечно-дизьюнца импликации,
[27:16.600 --> 27:24.600]  но от любого набора базисных функций с каким угодным количеством аргументов, но и от любого набора базисных функций с каким угодным количеством аргументов,
[27:24.600 --> 27:30.800]  и, соответственно, значения таких сложных формул будут подсчитываться, ну вот, по этому правилу фактически.
[27:33.800 --> 27:39.800]  Мы же так раньше и говорили, что чтобы посчитать значение формулы, скажем, коньюнции, нужно посчитать значение одной части,
[27:39.800 --> 27:43.800]  потом посчитать значение другой части, и как это будет работать?
[27:44.000 --> 27:52.000]  Мы же так раньше и говорили, что чтобы посчитать значение формулы, скажем, коньюнции, нужно посчитать значение одной части,
[27:52.000 --> 28:02.000]  потом посчитать значение другой части, и к этим значениям применить функцию i, то есть умножение, можно сказать, умножить эти значения.
[28:04.000 --> 28:08.000]  Вот это можно обобщить на произвольный набор базовых связок.
[28:08.200 --> 28:20.200]  Так, ну я надеюсь, это не очень сложно и более-менее понятно.
[28:27.200 --> 28:31.200]  Да, h будет с производительской глубины t плюс 1.
[28:31.400 --> 28:43.400]  Да, смотрите, мы считаем так, что у нас изначально задан какой-то набор переменных, от которых у нас все действует.
[28:43.400 --> 28:47.400]  Но дальше, смотрите, вот зачем нужны проекторы, зачем нужен нулевой уровень?
[28:47.400 --> 28:53.400]  Что как бы проектор, он от любого, сколько он длинного вектора, оставляет только одну координату.
[28:54.400 --> 28:58.400]  И потом эти координаты уже можно подставлять во что-нибудь другое.
[28:58.600 --> 29:03.600]  То есть, например, скажем, на первом уровне, если у нас есть базовая связка коньюнция,
[29:03.600 --> 29:15.600]  то если у вас там есть 100 аргументов, то будут коньюнции, что мы можем взять там коньюнцию 31-й переменной и 28-й,
[29:15.600 --> 29:18.600]  и как угодно так и комбинировать.
[29:19.600 --> 29:27.600]  То есть, фактически, проекторы как функции позволяют подставлять любые переменные с точки зрения формулы.
[29:28.600 --> 29:33.600]  Сейчас, что еще раз?
[29:33.600 --> 29:39.600]  Число k задается тем, сколько аргументов функции f.
[29:39.600 --> 29:43.600]  То есть, если f это коньюнция, то k равно 2.
[29:43.600 --> 29:50.600]  Если f это majority, смотря сколько там аргументов, в данном случае 3 аргумента.
[29:50.600 --> 29:52.600]  Ну и так далее.
[29:52.800 --> 29:58.800]  То есть, вон там написано, что f функция тк-аргументов.
[30:01.800 --> 30:04.800]  Ну ладно, давайте дальше.
[30:05.800 --> 30:10.800]  Дальше есть понятие замыкания.
[30:11.000 --> 30:31.000]  Если есть просто какой-то, не знаю, q, это какое-то любое множество, какое-то множество бульевых функций,
[30:31.200 --> 30:44.200]  то тогда q в квадратных скобках, это множество всех суперпозиций.
[30:48.200 --> 30:52.200]  Всех суперпозиций, всех глубин или еще всех порядков, говорят.
[30:52.400 --> 30:55.400]  Вот, а класс называется замкнутым.
[30:59.400 --> 31:03.400]  Значит, класс замкнутый.
[31:07.400 --> 31:10.400]  Так, ну давайте как-нибудь его назовем.
[31:12.400 --> 31:15.400]  Ну вот, я не знаю, класс R замкнутый.
[31:15.600 --> 31:18.600]  Если его замыкание равно ему самому.
[31:24.600 --> 31:28.600]  Вот, дальше тут есть всякие простые свойства.
[31:29.600 --> 31:32.600]  Значит, они будут в основном на семинарах.
[31:32.800 --> 31:33.800]  Да.
[31:51.800 --> 31:56.800]  В качестве g мы берем суперпозиции меньшей глубины, а в качестве f берем элементы sql.
[31:57.800 --> 31:59.800]  В качестве g это как раз spice воhaitа.
[31:59.800 --> 32:08.800]  элемент Sq. Суперпозиции глубины на 1 меньше. Суперпозиции, они уже могут быть сложными.
[32:08.800 --> 32:19.800]  Смотрите, суперпозиции глубины 0 – это проекторы, а суперпозиции глубины 1 – это
[32:19.800 --> 32:23.800]  фактически исходные функции, но в которые внутрь поставлены какие угодно переменные
[32:23.800 --> 32:30.800]  из нашего набора. Обычно считается так, что функция изначальная, у нее как бы
[32:30.800 --> 32:36.800]  вот k аргументов фиксирована, а суперпозиции глубины 1 означает, что мы из нашего
[32:36.800 --> 32:40.800]  большого множества n элементов выбрали какие-то k, может даже с повторами,
[32:40.800 --> 32:46.800]  в каком-то порядке, их подставили вначально, и получили вот такую функцию от n аргументов.
[32:47.800 --> 32:51.800]  Ну а дальше можно вот это накручивать по вот этой формуле.
[32:56.800 --> 32:59.800]  Почему мы не используем их, используем их в качестве f?
[33:03.800 --> 33:09.800]  Просто сами функции j, они могли получиться не Sq напрямую, а уже как суперпозиции
[33:09.800 --> 33:21.800]  какого-то меньшего порядка. Вот такие несложные свойства, это называется и демпотентность.
[33:21.800 --> 33:26.800]  Если мы взяли замыкание-замыкание, то это то же самое, что и разъять замыкание.
[33:28.800 --> 33:38.800]  Почему это верно? Потому что мы-то в качестве функции f,
[33:38.800 --> 33:47.800]  мы берем уже какие-то композиции, и мы их можем раскрутить и получить не композицию композиций,
[33:47.800 --> 33:53.800]  а композицию исходных функций. А получается уже вот эта правая часть.
[33:55.800 --> 33:59.800]  Соответственно получается, что замыкание любого множества – это замкнутый класс.
[33:59.800 --> 34:12.800]  Получается, что замыкание q – это замкнутый класс.
[34:12.800 --> 34:20.800]  Так, и теперь можно определить, что такое полная система.
[34:20.800 --> 34:30.800]  Значит, какая-то там множество S. Сейчас, нет, S у меня сейчас будет.
[34:30.800 --> 34:37.800]  Скажем множество P. Значит, множество P – это полная система.
[34:37.800 --> 34:45.800]  Если ее замыкание – это все функции.
[34:54.800 --> 35:00.800]  Ну, вообще все функции. Ну, значит, смотрите, все были его функции, конечно.
[35:00.800 --> 35:06.800]  То, с чем мы начинали, например, множество из отрицаний конъюнса – это полная система.
[35:06.800 --> 35:12.800]  Потому что суперпозиции можно выразить через KNF.
[35:12.800 --> 35:20.800]  Все, что на первых экранах было – это были примеры полных систем.
[35:20.800 --> 35:25.800]  Ну, здесь уместно сделать перерыв.
[35:25.800 --> 35:31.800]  После перерыва глобальная цель – доказать критерий.
[35:31.800 --> 35:37.800]  То система полная тогда и только тогда, когда там что-то верно.
[35:37.800 --> 35:43.800]  Так, ну что, давайте попробуем продолжить.
[35:43.800 --> 35:49.800]  Значит, смотрите, что сделал пост. Что это за решетка поста?
[35:49.800 --> 35:55.800]  Значит, пост привел исчерпывающий список всех замкнутых классов.
[35:55.800 --> 36:01.800]  Значит, почему эта решетка?
[36:01.800 --> 36:05.800]  Есть еще такое вот свойство.
[36:05.800 --> 36:09.800]  Значит, если мы возьмем...
[36:09.800 --> 36:13.800]  Вот как бы еще есть такое утверждение,
[36:13.800 --> 36:19.800]  то если Q и R – это замкнутые классы,
[36:19.800 --> 36:25.800]  то тогда их пересечение – это тоже замкнутый класс.
[36:35.800 --> 36:39.800]  Вот почему это так.
[36:39.800 --> 36:43.800]  Ну, значит, смотрите, что означает, что Q – это замкнутый класс.
[36:43.800 --> 36:47.800]  Ну, это значит, что если мы берем любые суперпозиции функции SQ,
[36:47.800 --> 36:51.800]  тоже будут лежать в Q.
[36:51.800 --> 36:57.800]  То есть, вот раз Q замкнутые, то любые суперпозиции функций SQ
[36:57.800 --> 37:01.800]  лежат в Q.
[37:01.800 --> 37:05.800]  Что значит, что R замкнутые?
[37:05.800 --> 37:09.800]  Ну, то же самое, но только для R.
[37:09.800 --> 37:15.800]  Значит, вот получается, что любые суперпозиции функций SQ
[37:15.800 --> 37:19.800]  лежат в Q.
[37:19.800 --> 37:23.800]  Ну, то же самое, но только для R.
[37:23.800 --> 37:33.800]  Суперпозиции функций SQ лежат в R.
[37:33.800 --> 37:37.800]  Ну, а смотрите, если мы берем суперпозиции функций,
[37:37.800 --> 37:41.800]  которые лежат в пересечении.
[37:41.800 --> 37:45.800]  Изначально их функции лежат в пересечении, значит, они лежат в Q,
[37:45.800 --> 37:49.800]  и поэтому их замыкание лежит в Q.
[37:49.800 --> 37:53.800]  Они лежат в R, поэтому их замыкание тоже лежит в R.
[37:53.800 --> 37:57.800]  Значит, их замыкание лежит и в Q, и в R.
[37:57.800 --> 38:05.800]  Соответственно, эти функции и в Q, и в R.
[38:05.800 --> 38:13.800]  Ну, и потому их суперпозиция тоже.
[38:19.800 --> 38:25.800]  Так, ну ладно, я надеюсь, это довольно-таки понятно.
[38:25.800 --> 38:31.800]  Но вообще не ясно, как это такое много определений и мало примеров.
[38:31.800 --> 38:35.800]  Сейчас давайте к примерам перейдем.
[38:35.800 --> 38:39.800]  Свяжем то, что мы в самом начале лекции изучали,
[38:39.800 --> 38:43.800]  про те наборы, с тем, что вот здесь происходит.
[38:43.800 --> 38:47.800]  Какие есть примеры замкнутых классов?
[38:47.800 --> 38:51.800]  И почему они замкнуты?
[38:51.800 --> 38:59.800]  Значит, примеры замкнутых классов.
[39:01.800 --> 39:05.800]  Так, первый пример. То, с чем мы начинали.
[39:05.800 --> 39:09.800]  Если мы возьмем только конъюнцию, дизюнцию, импликацию,
[39:09.800 --> 39:13.800]  еще может эквиваленцию, значит, все эти функции сохраняют единицу.
[39:13.800 --> 39:17.800]  Но вот это можно определить как класс.
[39:17.800 --> 39:21.800]  Он называется T1, или надо P1.
[39:21.800 --> 39:37.800]  Значит, T1 это класс функций, сохраняющих единицу.
[39:37.800 --> 39:45.800]  То есть, если мы подставим P1, то получим единицу.
[39:45.800 --> 39:49.800]  Так, а почему он замкнутый?
[39:49.800 --> 39:53.800]  Ну, надо по индукции доказывать.
[39:53.800 --> 39:57.800]  Значит, база индукции тривиальная, это проектор.
[39:57.800 --> 40:01.800]  То есть, формально докажем.
[40:01.800 --> 40:05.800]  Теорема T1 замкнутый класс.
[40:05.800 --> 40:13.800]  Теорема T1 замкнутый класс.
[40:13.800 --> 40:17.800]  Значит, формально как нужно доказывать?
[40:17.800 --> 40:21.800]  Надо доказывать по индукции, а индукцию надо начинать с базы.
[40:21.800 --> 40:25.800]  А база – это проектор.
[40:25.800 --> 40:35.800]  Так, дайте доказательства по индукции.
[40:35.800 --> 40:41.800]  Соответственно, база – то проектор на любую координату.
[40:41.800 --> 40:47.800]  Если у него подставить все единицы, то он, конечно же, выдаст единицу.
[40:47.800 --> 40:51.800]  Ну, а дальше переход.
[40:51.800 --> 41:03.800]  Значит, переход заключается в том, что если и функция F сохраняет единицу,
[41:03.800 --> 41:09.800]  значит, тогда я тебя сюда отлесну, у нас форма выглядит вот так вот.
[41:09.800 --> 41:11.800]  Соответственно, что нужно доказать?
[41:11.800 --> 41:13.800]  Соответственно, что нужно доказать?
[41:13.800 --> 41:19.800]  Что если и функция F сохраняет единицу, и по предложении индукции все вот эти вот GIT сохраняют единицу,
[41:19.800 --> 41:25.800]  то тогда и такая суперпозиция тоже сохраняет единицу.
[41:25.800 --> 41:29.800]  Так, возвращаемся сюда.
[41:29.800 --> 41:37.800]  Значит, если F лежит в T1, и GIT лежат в T1,
[41:37.800 --> 41:43.800]  то, соответственно, H лежит в T1, где H заданного той вот формулой.
[41:43.800 --> 41:47.800]  Так, ну давайте аккуратно это проверим.
[41:47.800 --> 41:49.800]  Значит, давайте перепишем.
[41:49.800 --> 41:55.800]  Значит, F от G1.
[41:55.800 --> 42:01.800]  Так, ну давайте я сюда уже единицы подставлю.
[42:01.800 --> 42:09.800]  Значит, и так далее. Тут будет GKT от всех единиц.
[42:09.800 --> 42:15.800]  Ну, смотрите, по предложении индукции все GIT сохраняют единицу,
[42:15.800 --> 42:21.800]  поэтому можно написать, что вот это вот будет единица.
[42:21.800 --> 42:24.800]  И G2 от всех единиц будет единица, и так далее.
[42:24.800 --> 42:28.800]  И GKT от всех единиц будет единица.
[42:28.800 --> 42:35.800]  То есть получается, что это равняется F от всех единиц.
[42:35.800 --> 42:40.800]  И теперь нужно воспользоваться тем, что сама F сохраняет единицу,
[42:40.800 --> 42:48.800]  поэтому, соответственно, это будет единица.
[42:48.800 --> 42:58.800]  Ну вот, то есть получается, что H от всех единиц тоже единица.
[42:58.800 --> 43:01.800]  Нет, а что происходит в других, это вообще неважно.
[43:01.800 --> 43:07.800]  Значит, чтобы функция попала в этот класс, достаточно, чтобы при постановке единиц были единицы.
[43:07.800 --> 43:14.800]  А чтобы при постановке нулей или единиц и нулей, это нам неважно.
[43:14.800 --> 43:23.800]  То есть нужно проверить только вот это.
[43:23.800 --> 43:30.800]  Сейчас, что еще раз?
[43:30.800 --> 43:32.800]  Что-то не важно, как раз важно.
[43:32.800 --> 43:34.800]  Нам что нужно доказать?
[43:34.800 --> 43:39.800]  Нам нужно доказать, что выполнено вот это вот свойство для функции H.
[43:39.800 --> 43:40.800]  Что мы сделали?
[43:40.800 --> 43:43.800]  Значит, мы формулу для H, которая вот здесь.
[43:43.800 --> 43:48.800]  Вот вместо всех этих аиток подставили одни единицы.
[43:48.800 --> 43:51.800]  Значит, получили вот такое вот выражение.
[43:51.800 --> 43:56.800]  Теперь, по предположению дуксу и все, что здесь внутри, раз жеит и сохраняет единицу,
[43:56.800 --> 44:00.800]  то все значения внутри будут единицами.
[44:00.800 --> 44:09.800]  Поэтому это равняется вот этому, и это тоже равно единице, потому что F сохраняет.
[44:09.800 --> 44:13.800]  Не на каком-то одном, а именно на наборе всех единиц.
[44:13.800 --> 44:21.800]  Не на каком-то, но вполне конкретно в одном наборе нам нужно конкретные значения.
[44:21.800 --> 44:26.800]  То есть тут есть только один набор из всех единиц.
[44:26.800 --> 44:35.800]  И мы именно его подставляем.
[44:35.800 --> 44:42.800]  Так, ну чего, разобрались?
[44:42.800 --> 44:44.800]  Потому что у нас определение такое.
[44:44.800 --> 44:55.800]  У нас в определении только один набор, и именно для этого набора мы проверяем.
[44:55.800 --> 45:06.800]  Так, хорошо, значит, дальше есть полностью симметричный класс.
[45:06.800 --> 45:11.800]  Значит, полностью симметричный класс – это класс всех функций, сохраняющих ноль.
[45:11.800 --> 45:14.800]  Значит, он обозначается T0.
[45:14.800 --> 45:23.800]  Значит, это класс функций, сохраняющих ноль.
[45:23.800 --> 45:33.800]  То есть должно быть, что F от всех нулей равняется нулю.
[45:33.800 --> 45:38.800]  Дальше все точно так же делается, только все единицы мы заменяем на все нули.
[45:38.800 --> 45:43.800]  И соответственно получаем, что T0 – это замкнутый класс.
[45:43.800 --> 45:49.800]  Значит, T0 – это замкнутый класс.
[45:49.800 --> 45:57.800]  Значит, аналогично предыдущему.
[45:57.800 --> 46:01.800]  Вот, и это вот то было препятствие, да, после мы изучали, что если взять
[46:01.800 --> 46:06.800]  конъюнцию, дизъюнцию и эксор, можно тогда все выразить или нельзя?
[46:06.800 --> 46:10.800]  Нет, нельзя, потому что они все сохраняют ноль.
[46:10.800 --> 46:18.800]  И поэтому все, что мы через них выразим, тоже сохраняет ноль.
[46:18.800 --> 46:24.800]  Так, ну чего, понятно?
[46:24.800 --> 46:25.800]  Так, хорошо.
[46:25.800 --> 46:27.800]  Так, теперь что дальше бывает?
[46:27.800 --> 46:31.800]  Дальше хитрее.
[46:31.800 --> 46:38.800]  Так, ну давайте, наверное, самодвойственные функции.
[46:38.800 --> 46:43.800]  Значит, это класс D.
[46:43.800 --> 46:48.800]  Значит, класс D – это самодвойственная функция.
[46:48.800 --> 46:58.800]  Или их еще могут называть нечетными.
[46:58.800 --> 47:02.800]  Вообще, наверное, многие из вас знают, что такая нечетная функция,
[47:02.800 --> 47:06.800]  просто как бы мат-анализ, да, это означает, что если у нее
[47:06.800 --> 47:11.800]  аргумензование на противоположные, то она сама заменится на противоположные.
[47:11.800 --> 47:16.800]  Или еще косо-симметричные, это еще называется.
[47:16.800 --> 47:20.800]  Вот, значит, здесь то же самое, только, во-первых, аргументов много,
[47:20.800 --> 47:24.800]  но и противоположные понимаются как отрицания.
[47:24.800 --> 47:28.800]  Да, то есть вообще у любой функции есть двойственная.
[47:28.800 --> 47:35.800]  Давайте пока прежде чем про самодвойственные говорить, поговорим просто про двойственные.
[47:35.800 --> 47:43.800]  Значит, если есть какая-то функция F, да, значит, вот A1, и так далее, AN,
[47:43.800 --> 47:46.800]  то по ней можно определить F со звездочкой.
[47:46.800 --> 47:58.800]  Двойственная функция, значит, это будет отрицание F от отрицания A1, и так далее, отрицание AN.
[47:58.800 --> 48:06.800]  Ну, например, что такое двойственная конъюнция?
[48:06.800 --> 48:12.800]  Ну, давайте я вот так запишу в инфиксной записи, значит, двойственная конъюнция.
[48:12.800 --> 48:18.800]  Значит, это что такое? Это мы берем отрицание P, конъюнцию, отрицание Q,
[48:18.800 --> 48:21.800]  и ко всему этому вместе еще добавляем конъюнцию.
[48:21.800 --> 48:28.800]  Это что за функция? Это дезюнция получается.
[48:28.800 --> 48:33.800]  Вот, и наоборот, значит, двойственная дезюнция это конъюнция,
[48:33.800 --> 48:38.800]  и вообще, на самом деле, они именно двойственные, они так на пары разбиваются.
[48:38.800 --> 48:41.800]  Значит, F со звездочкой, со звездочкой это F.
[48:41.800 --> 48:47.800]  Упражнение проверить, что если мы два раза берем двойственную, то получаем саму функцию.
[48:47.800 --> 48:55.800]  Давайте еще один пример, XOR. Значит, что такое XOR со звездочкой от P?
[48:55.800 --> 48:58.800]  Так, смотрите, что нам нужно сделать.
[48:58.800 --> 49:04.800]  Нам нужно взять отрицание P по XOR с отрицанием Q
[49:04.800 --> 49:07.800]  и у этого всего взять отрицание.
[49:07.800 --> 49:11.800]  А это что за функция? Да, это экваленция,
[49:11.800 --> 49:16.800]  потому что каждое отрицание даст плюс один, и будет три раза плюс один.
[49:16.800 --> 49:20.800]  Ну, соответственно, два сократятся, один останется.
[49:20.800 --> 49:24.800]  Ну, и получается, что это отрицание XOR, то есть это экваленция.
[49:30.800 --> 49:35.800]  Ну, а соответственно, функция называется самодвойственная, если она двойственна сама себе.
[49:40.800 --> 49:43.800]  Так, значит, самодвойственная.
[49:46.800 --> 49:51.800]  Это означает, что F со звездочкой совпадает с F.
[49:51.800 --> 49:56.800]  То есть на каждом аргументе мы такое проделали и ничего не поменялось.
[50:04.800 --> 50:07.800]  Да, это другая звезда.
[50:07.800 --> 50:10.800]  Это не звезда к линии, это другая звезда.
[50:10.800 --> 50:13.800]  Звезда, так сказать, сопряжения.
[50:13.800 --> 50:20.800]  Ну, это на какое-то комплексное сопряжение похоже, да, или что-то такое.
[50:30.800 --> 50:35.800]  Да, мы ставим аргумент под отрицание, и все эти результаты тоже ставим под отрицание.
[50:35.800 --> 50:39.800]  Какие функции будут самодвойственные?
[50:39.800 --> 50:44.800]  Ну, вот, например, отрицание само по себе.
[50:44.800 --> 50:49.800]  Смотрите, что такое отрицание со звездочкой от P.
[50:49.800 --> 50:55.800]  Значит, по определению это получается, что мы ставим аргумент под отрицание,
[50:55.800 --> 51:00.800]  потом как бы отрицание, которое сама функция F,
[51:00.800 --> 51:04.800]  и потом еще одно отрицание, это вот внешнее отрицание, вот это вот.
[51:04.800 --> 51:10.800]  Если смотреть сюда, то если есть само отрицание, то у нас получается 1, 2 и 3 отрицания.
[51:10.800 --> 51:15.800]  Ну, а тройное отрицание – то же самое, что одинарное отрицание.
[51:15.800 --> 51:18.800]  Двойное отрицание сокращается.
[51:18.800 --> 51:22.800]  И это, кстати, даже интуиционисты признают.
[51:22.800 --> 51:26.800]  Значит, они не признают, что можно всегда 2 отрицания стереть,
[51:26.800 --> 51:30.800]  но что 2 отрицания из 3 можно стереть, они признают.
[51:30.800 --> 51:37.800]  Вот это пример, что звездочка самодольственная.
[51:37.800 --> 51:44.800]  Еще один пример самодольственной функции, это функция большинства.
[51:44.800 --> 51:53.800]  Смотрите, большинство со звездочкой от PQR.
[51:54.800 --> 52:04.800]  Это что такое? Это отрицание большинства от не P, не Q и не R.
[52:04.800 --> 52:11.800]  Но смотрите, что здесь получается? Получается, что есть голосование с тремя избирателями.
[52:11.800 --> 52:14.800]  Есть два варианта, за и против.
[52:14.800 --> 52:19.800]  И теперь мы смотрите, что делаем. Мы меняем мнение каждого избирателя на противоположное.
[52:19.800 --> 52:25.800]  Берем большинство, а потом у результата тоже берем противоположное.
[52:25.800 --> 52:30.800]  Ясно, что это то же самое, что просто большинство.
[52:30.800 --> 52:38.800]  Смотрите, большинство это единицы, если две или три единицы среди аргументов.
[52:38.800 --> 52:43.800]  Когда мы поменяли вот здесь внутри, то есть двух или трех единиц стало два или три нуля,
[52:43.800 --> 52:48.800]  то есть большинство получилось ноль, а потом взяли отрицание и снова один получился.
[52:48.800 --> 52:53.800]  Поэтому большинство это самодольственная функция.
[52:53.800 --> 53:08.800]  Вообще можно переписать по другому условию, как бы перекинуть одно отрицание отсюда вот сюда.
[53:08.800 --> 53:12.800]  Почему оно нечетное?
[53:12.800 --> 53:16.800]  Почему нечетное?
[53:16.800 --> 53:22.800]  Потому что отрицание действует как минус. Можно другую часть перенести.
[53:22.800 --> 53:28.800]  И тогда получится, что f от отрицания p1 и так далее отрицание pn.
[53:28.800 --> 53:36.800]  Это отрицание f от p1 и так далее pn.
[53:36.800 --> 53:46.800]  Это уже очень похоже на определение нечетной функции, где вместо минуса отрицание.
[53:46.800 --> 53:49.800]  Так, хорошо.
[53:49.800 --> 53:56.800]  Ну наконец, утверждение, что это замкнутый класс.
[53:56.800 --> 54:01.800]  И это удобно именно для такого определения проверять.
[54:01.800 --> 54:07.800]  Что мы как бы отрицание перекинули отсюда сюда, и теперь это стало удобно проверять.
[54:07.800 --> 54:13.800]  Так, ну давайте вот аналогично вот этому запишем, только теперь с отрицаниями.
[54:13.800 --> 54:23.800]  Так, у нас получается f от g1 от отрицания a1 и так далее отрицания аn.
[54:23.800 --> 54:27.800]  Да, но база еще есть, база тривиальная.
[54:27.800 --> 54:35.800]  Что мы как бы отрицание перекинули отсюда сюда, и теперь это стало удобно проверять.
[54:35.800 --> 54:41.800]  Ну давайте вот аналогично вот этому запишем, только теперь с отрицаниями.
[54:41.800 --> 54:48.800]  А еще есть база тривиальная, что если мы все аргументы поменяли на противоположные,
[54:48.800 --> 54:57.800]  то и ты тоже поменялся на противоположные, поэтому проектор поменялся на противоположные.
[54:57.800 --> 55:00.800]  Нет, это одно и то же.
[55:00.800 --> 55:04.800]  Потому что отличие только в том, что мы отрицание перекинули с одной части в другую.
[55:04.800 --> 55:08.800]  Ну так можно делать это эквивалентно.
[55:08.800 --> 55:22.800]  А отличие в том, что мы отрицание принесли в другую часть.
[55:22.800 --> 55:28.800]  Ну это, так сказать, дано же на минус единицу обе части.
[55:28.800 --> 55:33.800]  Ну потому что если две вещи равны, то их отрицания тоже равны.
[55:33.800 --> 55:37.800]  А поскольку одно отрицание сокращается, то как раз добавление отрицания к обеим частям,
[55:37.800 --> 55:44.800]  это и означает перенос отрицаний с одной части в другую.
[55:44.800 --> 55:47.800]  Так вот, почему замкнутый?
[55:47.800 --> 55:58.800]  Мы составляем такое выражение, суперпозицию.
[55:58.800 --> 56:05.800]  И дальше смотрите, мы применяем условия самодвойственности для внутренних функций.
[56:05.800 --> 56:12.800]  То есть G1 у нас самодвойственная, поэтому можно все эти отрицания вынести наружу.
[56:12.800 --> 56:21.800]  Значит, тут получаем, что получаем не G1, вот А1, и так далее, АН.
[56:21.800 --> 56:31.800]  И так далее, и тут получаем не GKT, вот А1, и так далее, АН.
[56:31.800 --> 56:38.800]  А теперь мы не забываем, что эти все штуки остаются как аргумент AF.
[56:45.800 --> 56:48.800]  Вот, эти штуки остаются как аргумент AF.
[56:48.800 --> 56:52.800]  И теперь мы используем самодвойственность GF.
[56:52.800 --> 56:58.800]  Теперь все вот эти отрицания можно вынести наружу.
[56:58.800 --> 57:01.800]  Так, и тут, извините, мелко получается.
[57:01.800 --> 57:08.800]  Значит, отрицание F, вот уже G1 от А1, и так далее, АН.
[57:08.800 --> 57:15.800]  И так далее, GKT от А1, и так далее, АН.
[57:15.800 --> 57:26.800]  Как бы вот такая ступенчатая процедура, вынесли все отрицания наружу.
[57:26.800 --> 57:29.800]  Нет, сама все звездочки это предъявление двойственности.
[57:29.800 --> 57:37.800]  А самодвойственность, те, у которых двойственность, это они сами.
[57:37.800 --> 57:43.800]  Да, самодвойственность означает, что двойственных функций это она сама.
[57:43.800 --> 57:48.800]  Да, а нечетность получается от того, что мы перенесли одно отрицание в другую часть.
[57:49.800 --> 58:03.800]  Ну, это эквивалентность, эквивалентное свойство.
[58:03.800 --> 58:07.800]  То есть самодвойственный и нечетный, это одно и то же.
[58:07.800 --> 58:15.800]  Значит, вообще, опять же, вот эта самодвойственность, это полезное свойство в теории общественного выбора.
[58:15.800 --> 58:22.800]  Если все члены общества передумали наоборот, то все общество тоже должно передумать.
[58:22.800 --> 58:28.800]  Можно вот так интерпретировать в терминах общественного выбора.
[58:28.800 --> 58:35.800]  Так, хорошо, значит, еще два класса нам осталось из основных.
[58:35.800 --> 58:39.800]  Значит, есть класс монотонных.
[58:40.800 --> 58:43.800]  М – монотонная.
[58:48.800 --> 58:51.800]  Ну, вообще, слово «монотонная» вы, наверное, хорошо знаете.
[58:51.800 --> 58:55.800]  Если х меньше у, то f от х меньше f от у.
[58:55.800 --> 59:00.800]  Или там меньше либо равно, там, в общем, всякое бывает, строго, нестрого.
[59:00.800 --> 59:03.800]  Но здесь у нас много аргументов.
[59:03.800 --> 59:08.800]  И вопрос возникает, а что, если у нас один аргумент вырос, а другой уменьшился?
[59:08.800 --> 59:11.800]  Ну, ответ такой, что в этом случае мы не требуем ничего.
[59:11.800 --> 59:18.800]  Да, монотонность означает следующее, что если все аргументы либо не изменились, либо выросли,
[59:18.800 --> 59:22.800]  то тогда и значение должно либо не измениться, либо вырасти.
[59:22.800 --> 59:26.800]  Да, то есть получается, давайте я это запишу.
[59:26.800 --> 59:36.800]  Значит, если a1 меньше либо равно, чем b1, значит, a2 меньше либо равно, чем b2 и так далее,
[59:36.800 --> 59:45.800]  а n меньше либо равно, чем bn, то тогда получается, что и f от a1 и так далее,
[59:45.800 --> 59:53.800]  а n должно быть меньше либо равно, чем f от b1 и так далее, bn.
[59:56.800 --> 01:00:02.800]  Вот, например, конъюнция и дезюнция – это монотонная функция.
[01:00:02.800 --> 01:00:06.800]  Конъюнция и дезюнция – это монотонная функция.
[01:00:06.800 --> 01:00:10.800]  А вот, например, импликации уже нет.
[01:00:10.800 --> 01:00:15.800]  Значит, импликации нет. Почему?
[01:00:15.800 --> 01:00:25.800]  Ну, потому что, например, 0 влечет 0 – это 1, а 1 влечет 0 – это 0.
[01:00:25.800 --> 01:00:29.800]  Да, и получается, что мы аргумент увеличили.
[01:00:29.800 --> 01:00:33.800]  Один аргумент увеличился с нуля на единицу, второй не изменили,
[01:00:33.800 --> 01:00:39.800]  а значение функции, наоборот, изменилось с 1 на 0, то есть уменьшилось.
[01:00:39.800 --> 01:00:45.800]  Вот, или, например, XOR. Значит, XOR тоже нет.
[01:00:45.800 --> 01:00:50.800]  Значит, XOR нет. Почему?
[01:00:50.800 --> 01:01:04.800]  Ну, потому что, например, единица XOR 0 – это единица, а единица XOR 1 – это 0.
[01:01:04.800 --> 01:01:09.800]  То есть тоже получается, что один аргумент не изменился.
[01:01:09.800 --> 01:01:15.800]  Второй аргумент вырос, а значение уменьшилось.
[01:01:15.800 --> 01:01:22.800]  Вообще получается, что можно сказать следующее, что у нас же только 0 и единица – аргументы,
[01:01:22.800 --> 01:01:28.800]  и меньше либо равно – это значит либо равно, либо a – это 0, а b – это 1.
[01:01:28.800 --> 01:01:35.800]  Можно еще сказать так, что если значения всех аргументов либо не изменились,
[01:01:35.800 --> 01:01:41.800]  либо изменились с нуля на единицу, то значение тоже либо не изменилось,
[01:01:41.800 --> 01:01:51.800]  либо изменилось с нуля на единицу, то есть не могло измениться с единицы на 0.
[01:01:51.800 --> 01:01:57.800]  Так. Ну хорошо, теперь почему это самодвостенное?
[01:01:57.800 --> 01:02:02.800]  Да, кстати, есть еще такое понятие, я здесь запишу.
[01:02:02.800 --> 01:02:10.800]  Значит, монотонные KNF и DNF.
[01:02:10.800 --> 01:02:15.800]  Значит, это означает, что без отрицаний.
[01:02:15.800 --> 01:02:25.800]  Значит, без отрицаний переменных.
[01:02:25.800 --> 01:02:35.800]  Ну, если литералы берем только переменные, то это называется монотонные KNF и DNF.
[01:02:35.800 --> 01:02:40.800]  Отрицание, конечно, тоже не монотонное.
[01:02:40.800 --> 01:02:44.800]  Потому что отрицание нуля – это единица, отрицание единицы – это 0.
[01:02:44.800 --> 01:02:49.800]  Как раз получается, что аргументы изменились с нуля на единицу, а значение изменилось с единицы на 0.
[01:02:49.800 --> 01:02:54.800]  Так вот, утверждается, что m – это замкнутый класс.
[01:02:54.800 --> 01:03:02.800]  Четвертое утверждение все того же вида, значит, что m – это замкнутый класс.
[01:03:02.800 --> 01:03:12.800]  Почему?
[01:03:12.800 --> 01:03:21.800]  Ну, давайте это тоже аккуратно напишем.
[01:03:21.800 --> 01:03:24.800]  Так, давайте так я напишу.
[01:03:24.800 --> 01:03:29.800]  Значит, тут будет f от g1 от a1 и так далее, aN.
[01:03:29.800 --> 01:03:49.800]  Значит, а здесь внизу f от g1 от b1 и так далее, bN и так далее, gkt от b1 и так далее, bN.
[01:03:49.800 --> 01:03:53.800]  Так, теперь смотрите, что у нас получается.
[01:03:53.800 --> 01:03:57.800]  У нас получается, что все эти аиты выросли.
[01:03:57.800 --> 01:04:02.800]  То есть аиты меньше, чем b.
[01:04:02.800 --> 01:04:04.800]  Значит, опять же, с проектором все тривиально.
[01:04:04.800 --> 01:04:10.800]  Проектор просто берет одну из аит и ровно такой неравенственный получается.
[01:04:10.800 --> 01:04:14.800]  Поэтому можно сразу к переходу двигаться.
[01:04:14.800 --> 01:04:15.800]  Что мы получаем?
[01:04:15.800 --> 01:04:27.800]  Получаем, что вот эта вот штука g1 от аитых будет меньше либо равна, чем g1 от b-итых.
[01:04:27.800 --> 01:04:31.800]  Значит, это по предложению индукции.
[01:04:31.800 --> 01:04:35.800]  По предложению индукции все эти аиты не уменьшились.
[01:04:35.800 --> 01:04:42.800]  Поэтому раз g1 монотонная, то, соответственно, оно тоже не уменьшилось.
[01:04:42.800 --> 01:04:48.800]  Ну и так далее со всеми аргументами.
[01:04:48.800 --> 01:04:56.800]  То есть gkt от аитых тоже будет меньше, чем gkt от b-итых.
[01:04:56.800 --> 01:05:01.800]  Тоже потому, что мы предполагаем, что все предыдущие уже монотонные.
[01:05:01.800 --> 01:05:04.800]  Значит, gkt монотонные.
[01:05:04.800 --> 01:05:11.800]  Ну а после этого мы получается применяем уже свойство монотонности к этому всему.
[01:05:11.800 --> 01:05:17.800]  Теперь, поскольку уже f монотонная, то теперь уже аргументы f не уменьшились.
[01:05:17.800 --> 01:05:25.800]  Ну и значит, соответственно, получилось, что значение тоже не уменьшилось.
[01:05:25.800 --> 01:05:30.800]  Поэтому композиция монотонных монотонна.
[01:05:35.800 --> 01:05:39.800]  Так, ну что, понятно?
[01:05:42.800 --> 01:05:49.800]  Так, ну и теперь у нас еще один класс остался из важных.
[01:05:49.800 --> 01:05:55.800]  Значит, еще один класс это l, или иногда его еще a называют.
[01:05:55.800 --> 01:06:00.800]  Значит, l это линейная функция.
[01:06:00.800 --> 01:06:13.800]  Ну, значит, иногда их называют афинные.
[01:06:13.800 --> 01:06:18.800]  Вообще, афинные это более правильное название, чем линейное.
[01:06:18.800 --> 01:06:22.800]  Но, как бы, вот у Верщикина Шиня линейное написано.
[01:06:22.800 --> 01:06:26.800]  Вот, значит, что это такое? Что такое вообще линейная функция?
[01:06:26.800 --> 01:06:34.800]  Ну, это какая-то сумма с коэффициентами переменных.
[01:06:34.800 --> 01:06:37.800]  Но у нас перемен от 0 или 1.
[01:06:37.800 --> 01:06:41.800]  Ну, то есть, тут получается, что это многочлены Жигалкина.
[01:06:46.800 --> 01:06:59.800]  То есть, выражаемые линейными многочленами Жигалкина.
[01:07:07.800 --> 01:07:09.800]  Ну, а что это значит?
[01:07:09.800 --> 01:07:16.800]  Это означает, что там просто сумма каких-то переменных и еще, может быть, плюс один.
[01:07:16.800 --> 01:07:21.800]  То есть, вот это мы понимаем. Вот это плюс один как раз и есть камень преткновения.
[01:07:21.800 --> 01:07:23.800]  Линейная, а не афинная.
[01:07:23.800 --> 01:07:27.800]  Значит, вот как бы функция kx плюс b это линейная функция, или афинная.
[01:07:27.800 --> 01:07:29.800]  Если линейная, тогда может быть плюс один.
[01:07:29.800 --> 01:07:33.800]  Если говорить, что линейная только kx, а kx плюс b это афинная,
[01:07:33.800 --> 01:07:35.800]  тогда нужно эти называть афинными.
[01:07:38.800 --> 01:07:41.800]  Ну ладно, в общем, я думаю, что мы как-то разберемся.
[01:07:41.800 --> 01:07:43.800]  Я буду говорить линейная.
[01:07:43.800 --> 01:08:00.800]  То есть, получается, что f это сумма в смысле ксора каких-то поитых, ну или аитых,
[01:08:00.800 --> 01:08:02.800]  да и может быть единица.
[01:08:07.800 --> 01:08:10.800]  Ну, например, отрицание линейной функции.
[01:08:11.800 --> 01:08:16.800]  Значит, отрицание p, это вот p плюс один, это линейная функция.
[01:08:17.800 --> 01:08:19.800]  Или эквивалентность.
[01:08:21.800 --> 01:08:26.800]  Значит, эквивалентность это px 41.
[01:08:30.800 --> 01:08:35.800]  Или, может быть, функция четности там от большого числа аргументов, это parity называется.
[01:08:37.800 --> 01:08:44.800]  Значит, функция parity, да, это вот там p1, ксор и так далее, ксор pn.
[01:08:50.800 --> 01:08:52.800]  Вот это примеры линейных функций.
[01:09:00.800 --> 01:09:03.800]  Ну, у отдельной перемены у нас всегда степень больше единицы,
[01:09:03.800 --> 01:09:05.800]  вот важно, что мы разные перемены не умножаем друг на друга.
[01:09:07.800 --> 01:09:10.800]  То есть, например, нелинейная, например, дизюнция.
[01:09:13.800 --> 01:09:18.800]  Нелинейная, например, дизюнция, да, значит, это p ксор q.
[01:09:19.800 --> 01:09:21.800]  Ксор q, да, значит, вот здесь произведение 2.
[01:09:22.800 --> 01:09:24.800]  Значит, или импликация.
[01:09:25.800 --> 01:09:30.800]  Значит, импликация, это мы считали в прошлый раз, да, значит, 1 плюс p плюс q.
[01:09:35.800 --> 01:09:38.800]  Не, ну, имеет, конечно, ну, скорее, не просто.
[01:09:39.800 --> 01:09:45.800]  Ну, а вот есть поле из двух элементов, да, и вот эта ножта всех слов из 0 единиц можно воспринимать как булиф куб,
[01:09:46.800 --> 01:09:49.800]  да, то есть как как раз инмерный пространство над этим полем из двух элементов.
[01:09:50.800 --> 01:09:52.800]  И тогда это будет в точности афинной функции.
[01:09:55.800 --> 01:10:03.800]  Вот, но мы, как бы, это вообще можно применять разные математические приемы,
[01:10:04.800 --> 01:10:09.800]  типа там коэффициент Фурье, да, или там чего-нибудь такого для изучения буливых функций.
[01:10:10.800 --> 01:10:13.800]  Это очень интересная область, но все-таки выходит за рамки нашего основного курса.
[01:10:14.800 --> 01:10:23.800]  Так, хорошо, значит, что мы успеем, наверное, понять, что L это замкнутый класс.
[01:10:27.800 --> 01:10:29.800]  Значит, утверждение, что L это замкнутый класс.
[01:10:30.800 --> 01:10:33.800]  Ну, смотрите, как это надо понимать.
[01:10:35.800 --> 01:10:38.800]  Значит, мне кажется, что проще всего нарисовать, как бы, вот такую вот картинку, да,
[01:10:39.800 --> 01:10:46.800]  что вот здесь вот какая-то сумма, значит, сумма, дальше мы ее ксорим еще с какой-то суммой.
[01:10:48.800 --> 01:10:52.800]  То есть мы можем использовать, как бы, вот такую картинку, да,
[01:10:52.800 --> 01:10:58.100]  сумма, значит, сумма, дальше мы ее ксорим еще с какой-то
[01:10:58.100 --> 01:11:08.100]  суммой, значит, и так далее. И можно быть еще ксорим
[01:11:08.100 --> 01:11:13.300]  с единицей, а может и не ксорим. Но смотрите, все
[01:11:13.300 --> 01:11:18.380]  эти суммы – это суммы переменных. Ну тогда ясно, что тут повторы
[01:11:18.680 --> 01:11:22.220]  сократятся, в том числе единицы, если там есть повтора
[01:11:22.220 --> 01:11:25.540]  единицы. Ну и останется тоже сумма переменных и
[01:11:25.540 --> 01:11:29.420]  может быть единица. Да, то есть понятно, а что что
[01:11:29.420 --> 01:11:32.220]  здесь происходит? Я беру может быть такое выражение,
[01:11:32.220 --> 01:11:34.980]  что сумма переменных и может быть единица,
[01:11:34.980 --> 01:11:36.980]  и вместо каждой переменной тоже ну соответственно
[01:11:36.980 --> 01:11:39.860]  подставляю сумму переменных и может быть единица,
[01:11:39.860 --> 01:11:43.060]  ну и тоже получается такую длинную сумму и там могут
[01:11:43.060 --> 01:11:44.500]  быть повторы, но если повторы сократятся и останется
[01:11:44.500 --> 01:11:55.620]  снова суммы переменных каких-то и, может быть, единицы. Вот так. Ну чего, понятно? Или не очень?
[01:11:55.620 --> 01:12:01.520]  Значит, это будет много на семинарах обсуждаться. Значит, я думаю, что в сильных группах будут какие-то
[01:12:01.520 --> 01:12:07.620]  продвинутые вещи. Кроме этих пяти, там еще есть всякие интересные классы. Значит, по крайней
[01:12:07.620 --> 01:12:12.820]  мере, в те группы, которые выскажут интерес, это будет разбираться. Так, а в следующий раз мы
[01:12:12.820 --> 01:12:20.500]  докажем теорему. Если я сформулирую за оставшиеся две минуты, значит, теорема критерий ПОСТа.
[01:12:20.500 --> 01:12:32.100]  А в следующий раз мы его докажем. Значит, критерий ПОСТа. Значит, это вот какая штука критерий ПОСТа.
[01:12:32.100 --> 01:12:38.340]  Что утверждается, что вот эти вот пять классов — это, конечно, препятствие к полной системе.
[01:12:38.340 --> 01:12:47.980]  Да, то есть если у нас все функции, точнее так, значит, если у нас класс, ну или там множество
[01:12:47.980 --> 01:12:57.100]  целиком под множество одного из этих пяти классов, то он не будет полным. Но других препятствий не
[01:12:57.100 --> 01:13:05.860]  может быть. Да, то есть, соответственно, ну, можно сформулировать так, что Q — это полная система.
[01:13:05.860 --> 01:13:17.820]  Значит, Q — это полная система тогда и только тогда, когда Q содержит функцию, не сохраняющую
[01:13:17.820 --> 01:13:32.220]  единицу. Значит, не сохраняющую единицу. Функцию, не сохраняющую ноль. Значит, немонотонную функцию,
[01:13:32.220 --> 01:13:50.980]  немонотонную функцию, несамодвойственную функцию и нелинейную функцию. Вот, при этом одна и та же функция
[01:13:50.980 --> 01:13:57.500]  может как бы несколько раз встречаться. Например, штрих-шефер, он сразу не один из них, и поэтому один
[01:13:57.620 --> 01:14:08.180]  штрих-шефер — это полная система. Полная система означает, что мы через функции SQ можем выразить
[01:14:08.180 --> 01:14:16.180]  любую функцию на суперпозиции. Вот так. Ну ладно, все, спасибо за внимание.
