[00:00.000 --> 00:10.480]  мы с вами поговорили про все я думаю вы поняли что вас ожидает поверьте бояться этого не нужно чем
[00:10.480 --> 00:15.840]  больше будете бояться тем хуже будет на самом этом итоговом контесте или контроль вы просто должны
[00:15.840 --> 00:25.440]  прийти и показать что-что знаете я надеюсь что-то да вы знаете вот итоговый контест всегда на
[00:25.440 --> 00:35.440]  зачетной неделе зачетная неделя начинается 15 декабря во время лекции обычно но там в
[00:35.440 --> 00:42.720]  зависимости от того как у нас получится с аудиториями нам нужна аудитория на 3 часа вам все сообщат вы
[00:42.720 --> 00:49.760]  увидите я подозреваю что даже уже написано это у вас в расписание сессии есть у меня такое
[00:50.400 --> 01:00.320]  ладно давайте успокоились и теперь начинаем говорить про наибольший общий подпоследователь
[01:00.320 --> 01:05.240]  и наибольший возрастающий подпоследователь что это такое поставим задачу поймем с этим жить
[01:05.240 --> 01:12.640]  первое с чем мы будем работать это наибольшая общая подпоследовательность но прежде чем к
[01:12.640 --> 01:17.680]  нему перейти я напомню что у нас есть динамическое программирование есть критерии применимости
[01:17.680 --> 01:23.280]  динамического программирования критерии следующие оптимальная подструктура перекрывающий под задачу
[01:23.280 --> 01:36.080]  помните такое было или не помните все читают такие так вроде было но не помнят на всякий
[01:36.080 --> 01:41.360]  случай оптимальность на тему того что у вас действительности решение является оптимальным
[01:41.360 --> 01:46.880]  и правильным перекрывающий под задачу вы используете результат который получили еще на предыдущих
[01:46.880 --> 01:55.800]  шагах вот это про критерии применимость задача наибольшей общей подпоследовательности выглядит
[01:55.800 --> 02:02.040]  достаточно просто у нас есть две последовательности с 1 и с 2 это могут чисто строки все что угодно
[02:02.040 --> 02:08.820]  спецсимвол и требуется найти самую длинную общую подпоследовательность что такое
[02:08.820 --> 02:12.840]  подпоследовательность но подпоследовательность это тоже самое что вы взяли какую-то строчку
[02:12.840 --> 02:17.840]  выкинули из неё часть символов. Вот это будет подпоследовательностью. И оставили их ровно в том же порядке.
[02:17.840 --> 02:20.840]  Там не знаю, а...
[02:22.840 --> 02:26.840]  Кто не знает, почему я такие буквки выбрал?
[02:26.840 --> 02:33.840]  Нет среди вас биологов. А? Да. Ладно, хорошо, есть среди вас биологов.
[02:33.840 --> 02:41.840]  Ну а... от СТГ, да. Должно же быть познавательной ещё.
[02:41.840 --> 02:49.840]  Когда у нас есть некоторая последовательность, мы можем сказать, что АТТ это подпоследовательность.
[02:49.840 --> 02:54.840]  Я могу сказать, что АТГ это подпоследовательность и так далее.
[02:54.840 --> 02:58.840]  Ну как бы просто убираю некоторые букв и получаю наш подпоследователь.
[02:58.840 --> 03:05.840]  Ничего страшного здесь нет. Но нужно понять, как решать такую вообще штуку.
[03:05.840 --> 03:10.840]  Представим, что у меня есть строка первая какая-нибудь, не знаю.
[03:18.840 --> 03:21.840]  Вот. У меня есть такая строка и есть...
[03:28.840 --> 03:31.840]  Вот такая строка. Какая наибольшая подпоследовательность?
[03:31.840 --> 03:44.840]  Ну, можно сказать, что это ААА. Вот это, вот это и вот это, а здесь вот эти буквы.
[03:44.840 --> 03:54.840]  Согласны? То есть наибольшая общая подпоследовательность, это когда я возьму подпоследовательность отсюда и отсюда, и она будет и там и там.
[03:54.840 --> 03:59.840]  Понятно? То есть мы должны выбрать такие вот символы.
[03:59.840 --> 04:06.840]  Вот теорема. Теорема об оптимальной структуре, наибольшей общей подпоследовательности.
[04:06.840 --> 04:13.840]  Она звучит следующим образом. Пусть у нас есть две последовательности, х и у.
[04:13.840 --> 04:19.840]  Ну вот х там состоит из х1 и до хм, у состоит из у1 до ум.
[04:20.840 --> 04:24.840]  Заметьте, х и у не обязательно одинаковой длины.
[04:26.840 --> 04:31.840]  Вот. А z это наибольшая общая их подпоследовательность.
[04:34.840 --> 04:41.840]  И нужно сказать, как выглядит z. И здесь в действительности от z мы можем сказать следующее.
[04:42.840 --> 04:51.840]  Что если у нас последние х и у равны, то в этом случае они равны последнему символу z.
[04:55.840 --> 05:06.840]  И тогда, если я уберу этот символ и там из х, из у, из z, то у меня zk-1 это как раз все символы без катова.
[05:07.840 --> 05:21.840]  То есть у меня вот z есть, он там z1 и так далее, zk-1, а вот zk-1 это z1 и так далее zk-1.
[05:22.840 --> 05:39.840]  Вот. Тогда мы говорим, что zk-1 это наибольшая общая подпоследовательность от х, а что у меня там, м-1, и у, н-1.
[05:39.840 --> 05:49.840]  Вот. То есть мы должны сказать, что это вот выглядит в таком виде. Что это нам позволяет?
[05:50.840 --> 05:56.840]  Как вы думаете? Видите, что мы свели задачу к предыдущему вопросу.
[05:56.840 --> 06:08.840]  Когда у меня было z до k, я свел к тому, что у меня k-1 уже символ. И здесь эти последовательности уменьшил.
[06:09.840 --> 06:13.840]  То есть я взял и уменьшил, а это означает вот ту самую динамику, которую я набрал.
[06:20.840 --> 06:24.840]  Это происходит только в том случае, когда xm равно yn.
[06:27.840 --> 06:34.840]  Когда два последних символов, x и y, они вот такие, они равны. И они равны z.
[06:35.840 --> 06:46.840]  Вот. Это первое утверждение этой теоремы. Второе утверждение этой теоремы, что если не равны между собой, тогда z это то же самое,
[06:46.840 --> 06:55.840]  ну если x и y не равны последние символы, тогда это то же самое, что я бы выкинул либо из x, либо из y последний символ.
[06:56.840 --> 07:00.840]  Но это, я думаю, тоже понятно. Мы придем заказать.
[07:01.840 --> 07:07.840]  У этого на всякий случай. Окей? Могу дальше идти?
[07:09.840 --> 07:11.840]  Чё-то как-то большинство сгрустнуло.
[07:16.840 --> 07:18.840]  Где минус?
[07:22.840 --> 07:28.840]  Да. LCS это на всякий случай npo. Отрицательным оно быть не могло.
[07:33.840 --> 07:36.840]  Окей. Поехали. Давайте доказывать с вами все, что у нас есть.
[07:37.840 --> 07:40.840]  Первый случай, когда у нас равны символы xm, yn.
[07:41.840 --> 07:48.840]  Первое. Заметьте, у нас тогда в этом случае мы говорим, что zkt равно ym и xm.
[07:49.840 --> 07:55.840]  И zk-1 это наибольший общий подпоследователь. Мы будем разбирать эти два факта в отдельности.
[07:56.840 --> 08:00.840]  Первый факт о том, что у нас zkt равно xm равно ym.
[08:01.840 --> 08:06.840]  Смотрите. Мы идем от противного. Если бы у нас выполнялось, что они были неравны,
[08:07.840 --> 08:13.840]  то есть вот этот последний z, который у нас есть, он бы был не равен а xm,
[08:14.840 --> 08:19.840]  тогда я бы к z мог бы добавить тот самый последний символ.
[08:21.840 --> 08:25.840]  Ну, давайте это на примерах показывать. Я думаю, вам так будет легче.
[08:26.840 --> 08:29.840]  Доказать теорему.
[08:38.840 --> 08:41.840]  А, вот это дальше будет вопрос.
[08:42.840 --> 08:47.840]  Эта теорема позволяет нам сделать следующее. Давайте еще раз вернемся на нее.
[08:48.840 --> 08:51.840]  Видишь, что мы уменьшаем x и y?
[08:51.840 --> 08:54.840]  И z заодно.
[08:55.840 --> 08:58.840]  В то же время мы можем уменьшать x и y по отдельности.
[08:59.840 --> 09:06.840]  Согласен, что когда я уменьшаю x и y, я уменьшаю саму задачу, размерную задачу.
[09:09.840 --> 09:10.840]  Да.
[09:11.840 --> 09:17.840]  Мне нужно понять, из чего состоит z и как я могу взять и использовать это в динамике.
[09:17.840 --> 09:21.840]  В динамике мне что нужно? Оптимальность и перекрывающийся подзадачи.
[09:22.840 --> 09:26.840]  Перекрывающийся подзадачи здесь есть за счет того, что у нас z является nop,
[09:27.840 --> 09:32.840]  ну zk-1 или z, она является nop от последовательств поменьше.
[09:33.840 --> 09:34.840]  Правильно?
[09:35.840 --> 09:39.840]  Оптимальность – это то, что мы используем их в результате, получим то, что нам нужно.
[09:44.840 --> 09:45.840]  Да.
[09:48.840 --> 09:52.840]  Еще раз, об оптимальности под структуры z.
[09:53.840 --> 09:56.840]  Я говорю, что z, ну как бы хорошо.
[09:57.840 --> 10:02.840]  Я говорю, что z – это наибольшая общая под последовательность x и y.
[10:05.840 --> 10:06.840]  Да.
[10:07.840 --> 10:11.840]  Я говорю, вот у меня есть случай xm равно yn.
[10:12.840 --> 10:14.840]  Что я могу сказать о других вещах?
[10:15.840 --> 10:18.840]  Могу я сказать о состоянии z в этот момент что-то?
[10:19.840 --> 10:20.840]  Что?
[10:21.840 --> 10:22.840]  Почему?
[10:26.840 --> 10:28.840]  Вот смотри, нам нужно это по-хорошему доказать.
[10:29.840 --> 10:30.840]  О том, как выглядит z.
[10:31.840 --> 10:39.840]  Почему это нужно? Представь следующее – a, c, t, t, не знаю, и g, c, t, t.
[10:40.840 --> 10:43.840]  Вот я нахожусь вот тут, вот буду на последнем символе.
[10:45.840 --> 10:46.840]  Вот тут смотри.
[10:47.840 --> 10:50.840]  Друзья, давайте это, хлопнемся.
[10:52.840 --> 10:53.840]  Пожалуйста.
[10:54.840 --> 10:56.840]  Очень плохо так говорить.
[10:57.840 --> 10:59.840]  Ладно, а вот я нахожусь вот здесь вот.
[11:01.840 --> 11:04.840]  Вот у меня первая строчка, вот вторая.
[11:05.840 --> 11:09.840]  Вот это должно быть в моей наибольшей общей под последовательности.
[11:10.840 --> 11:11.840]  Да?
[11:12.840 --> 11:13.840]  С одной стороны.
[11:14.840 --> 11:15.840]  С другой стороны.
[11:16.840 --> 11:17.840]  Почему я так уверен?
[11:19.840 --> 11:22.840]  Но просто если я скажу, что вот эти символы у меня есть, то согласен,
[11:23.840 --> 11:25.840]  что я могу найти наибольшую общую под последовательность от вот этого кусочка
[11:26.840 --> 11:28.840]  и добавить к ним букву t в конце.
[11:32.840 --> 11:34.840]  Чтобы использовать ее для того, чтобы динамически это делать.
[11:35.840 --> 11:37.840]  Потому что вот у меня меньшая под задачу уже.
[11:38.840 --> 11:39.840]  А вот.
[11:40.840 --> 11:41.840]  Еще есть вопросы?
[11:42.840 --> 11:43.840]  Нет.
[11:44.840 --> 11:45.840]  Значит, давайте здесь еще раз.
[11:46.840 --> 11:47.840]  Мы идем от обратного.
[11:48.840 --> 11:52.840]  Говорим, что пусть у меня последний символ z-каты не равен xm.
[11:53.840 --> 11:56.840]  Если он не равен xm, то он не равен и ym.
[11:57.840 --> 12:02.840]  Окей, тогда давайте я просто в свою z, которая у меня уже есть,
[12:03.840 --> 12:05.840]  добавлю в конец еще один вот этот символ.
[12:06.840 --> 12:08.840]  Он же в конце последовательности идет?
[12:09.840 --> 12:10.840]  В конце.
[12:11.840 --> 12:13.840]  Если я добавлю этот символ, у меня будет общая под последовательность?
[12:15.840 --> 12:16.840]  Будет.
[12:17.840 --> 12:19.840]  Только она стала на 1 больше.
[12:20.840 --> 12:22.840]  То есть в k у меня было k элементов,
[12:23.840 --> 12:25.840]  а здесь я добавил еще последний элемент, вот этот xm и yn,
[12:26.840 --> 12:28.840]  и получил k плюс 1 элемент.
[12:29.840 --> 12:31.840]  А значит, у меня есть противоречие с чем?
[12:32.840 --> 12:35.840]  С тем, что z это наибольшая общая под последовательность.
[12:36.840 --> 12:37.840]  Она не наибольшая.
[12:38.840 --> 12:39.840]  Вот есть из k плюс 1 элемент.
[12:40.840 --> 12:41.840]  Понятно логика?
[12:42.840 --> 12:44.840]  Вот, благодаря этому мы говорим, что да,
[12:45.840 --> 12:48.840]  в действительности, если последние символы равны между собой,
[12:49.840 --> 12:52.840]  то мы обязаны добавлять в свое z.
[12:53.840 --> 12:54.840]  Это раз.
[12:55.840 --> 12:56.840]  Второе.
[12:57.840 --> 13:01.840]  Мы покажем, что zk минус 1 ро равно наибольшей общей под последовательностью.
[13:02.840 --> 13:06.840]  То есть я утверждаю следующее, что если я уберу последний символ z-каты,
[13:07.840 --> 13:10.840]  то это то же самое, что у меня будет вот здесь вот zk минус 1,
[13:11.840 --> 13:15.840]  то это не больше общей под последовательности, вот этого вот чуда.
[13:16.840 --> 13:17.840]  Как это сделать?
[13:18.840 --> 13:19.840]  Все достаточно просто, опять же, от противного.
[13:20.840 --> 13:24.840]  Пусть это не так, тогда существует какая-то другая большая общая под последовательность,
[13:25.840 --> 13:28.840]  большая, у которой длина больше, чем k минус 1 элементик.
[13:29.840 --> 13:31.840]  Потому что zk минус 1, а k минус 1 элементик.
[13:33.840 --> 13:38.840]  А добавим к этому w вот ту самую последнюю z-кату.
[13:38.840 --> 13:41.840]  Мы же знаем, что она у нас в конце стоит.
[13:42.840 --> 13:43.840]  Знаем.
[13:44.840 --> 13:45.840]  Добавляем ее.
[13:46.840 --> 13:50.840]  Тогда мы получаем, что в нашей общей под последовательности будет больше, чем k элементов.
[13:51.840 --> 13:56.840]  А если там больше, чем k элементов, то z никогда не была наибольшей общей под последовательностью.
[13:57.840 --> 14:00.840]  То есть мы просто играем тут словами от противного.
[14:01.840 --> 14:02.840]  Понятно?
[14:03.840 --> 14:04.840]  Важно получить вот это противоречие.
[14:05.840 --> 14:09.840]  Таким образом мы понимаем, как у нас выглядит внутри z.
[14:10.840 --> 14:11.840]  Пока что понимаем.
[14:12.840 --> 14:16.840]  Но нам нужно понять, а что делать, если символы в конце не одинаковые?
[14:17.840 --> 14:23.840]  Грубо говоря, если у нас одинаковые символы, то я могу перейти из этой строчки и сделать плюс один к количеству символов.
[14:24.840 --> 14:25.840]  Согласны?
[14:26.840 --> 14:27.840]  Ну вот из этого кусочка.
[14:28.840 --> 14:29.840]  Правильно?
[14:29.840 --> 14:31.840]  Потому что вот это будет как раз там.
[14:32.840 --> 14:33.840]  xn-1.
[14:34.840 --> 14:36.840]  А это ym-1.
[14:37.840 --> 14:38.840]  Это yn-1.
[14:40.840 --> 14:43.840]  А вот это вот здесь вот число будет как раз zk-1.
[14:44.840 --> 14:46.840]  Мы это сделали благодаря вот этому вот переходу.
[14:48.840 --> 14:51.840]  Осталось понять, а если символы разные, что делать?
[14:52.840 --> 14:56.840]  Тогда в этом случае нам приходят вот те 2 и 3 свойства, которые были написаны в теореме.
[14:57.840 --> 15:13.840]  О том, что если у нас xm не равно yn, то из того, что zk, то есть последний элемент, не равен xm, следует, что z, а наибольшая общая подпоследность xm-1y.
[15:14.840 --> 15:16.840]  То есть я могу просто взять и выкинуть вот отсюда этот символ.
[15:17.840 --> 15:19.840]  Вот представим, что тут у меня была бы буква а, не знаю.
[15:20.840 --> 15:22.840]  То есть вот этого перехода бы уже не было.
[15:23.840 --> 15:30.840]  То есть я говорю о том, что я могу взять и сказать, ну да, у меня есть вот этот символ, но я не буду рассматривать вот этот символ.
[15:31.840 --> 15:33.840]  То есть я могу вот таким вот образом обрубить это все.
[15:35.840 --> 15:37.840]  И вот здесь уже находить значение.
[15:38.840 --> 15:42.840]  И вот из этого значения прийти сюда, и оно будет ровно таким же.
[15:43.840 --> 15:45.840]  Почему я могу таким образом сделать?
[15:46.840 --> 15:48.840]  Я могу это сделать только по одной причине, на самом деле.
[15:48.840 --> 15:55.840]  Потому что, опять же, мы будем исходить из некоторых предположений от обратного.
[15:56.840 --> 15:58.840]  То есть пусть у меня zk не равно xm.
[15:59.840 --> 16:01.840]  Ну, это мы знаем по условию.
[16:02.840 --> 16:07.840]  И z, то z, наибольшая общая подпоследовательность.
[16:08.840 --> 16:15.840]  Пусть существует их общая подпоследовательность w, длина которой превышает z.
[16:15.840 --> 16:17.840]  То есть опять же мы исходим от обратного.
[16:18.840 --> 16:20.840]  Пусть существует что-то большее.
[16:21.840 --> 16:26.840]  Тогда в этом случае она является наибольшей общей подпоследовательностью x и y.
[16:27.840 --> 16:28.840]  Почему?
[16:33.840 --> 16:43.840]  Почему если w, смотрите, w это наибольшая общая подпоследовательность от xm-1y?
[16:44.840 --> 16:52.840]  Почему я говорю, что в этом случае w точно является общей подпоследовательностью x и y?
[16:58.840 --> 17:01.840]  Да, потому что у x я просто забрал последний символ.
[17:02.840 --> 17:07.840]  Ну, как бы, если я заберу там один последний символ, то тут я его добавлю, это точно будет общей подпоследовательностью.
[17:08.840 --> 17:11.840]  А я говорю, что размерность вот этого, оно больше, чем у z.
[17:11.840 --> 17:14.840]  Значит и здесь будет больше, чем у z.
[17:15.840 --> 17:16.840]  А это противоречит чему?
[17:17.840 --> 17:21.840]  Противоречит тому, что мы говорили, что z это наибольшая общая подпоследовательность.
[17:22.840 --> 17:23.840]  Понятно?
[17:29.840 --> 17:31.840]  Так, задайте вопросы.
[17:38.840 --> 17:40.840]  Так мы уже и отошли от этого.
[17:41.840 --> 17:42.840]  Это же второй пункт.
[17:43.840 --> 17:48.840]  Вот сверху два точка и там написано как раз то, что мы писали в теореме.
[17:49.840 --> 17:51.840]  Вот, теорема вот так выглядит.
[17:54.840 --> 17:58.840]  В первом мы говорим, что одинаковые элементы, а во втором и третьем у нас они различные.
[18:06.840 --> 18:07.840]  Да.
[18:11.840 --> 18:12.840]  Да.
[18:23.840 --> 18:28.840]  Потому что наибольшая имеется в виду с точки зрения количества символов.
[18:30.840 --> 18:34.840]  Мне нужно противоречие получить с наибольшей общей подпоследовательностью.
[18:35.840 --> 18:37.840]  z является наибольшей общей.
[18:38.840 --> 18:45.840]  Если я покажу, что она является не наибольшей, а просто общей, то это будет противоречие с тем, что я говорил до этого.
[18:56.840 --> 18:57.840]  Это ровно то же самое.
[18:58.840 --> 18:59.840]  Оно подходит и по той, и по другой.
[19:02.840 --> 19:04.840]  А как ты думаешь, что в этом случае лучше?
[19:07.840 --> 19:09.840]  Лучше то, что откуда больше придет.
[19:13.840 --> 19:22.840]  Ну то есть в действительности такого момента, на самом деле, вот когда xm не равно yn и xm, ну типа у нас же тут рассматривается, когда они не равны, правильно?
[19:24.840 --> 19:27.840]  А ни один из этих символов, значит, не будет введен в задкат, просто так.
[19:29.840 --> 19:30.840]  Вот.
[19:31.840 --> 19:35.840]  В этом случае мы говорим, что нам лучше прийти оттуда, где было больше.
[19:36.840 --> 19:43.840]  Потому что в этом случае z является ее на p, и с одной стороны xm-1y, а с другой стороны это xyn-1.
[19:45.840 --> 19:47.840]  Я мог и так прийти, и так прийти.
[19:48.840 --> 19:49.840]  То есть z является наибольшей общей подпоследовательностью.
[19:50.840 --> 19:51.840]  И для того, и для того.
[19:52.840 --> 19:54.840]  Мне нужно идти здесь немного в другую сторону, мне z будет неизвестно.
[19:55.840 --> 20:01.840]  А если мне z будет неизвестно, мне нужно как-то из этих кусочков понять, типа, а что я, где я нахожусь сейчас.
[20:02.840 --> 20:03.840]  Понятно?
[20:05.840 --> 20:06.840]  Вот.
[20:08.840 --> 20:10.840]  Как, вот как использовать эту теорему?
[20:11.840 --> 20:16.840]  Как раз таки был вопрос, вот здесь вот, а мы этого и будем делать.
[20:17.840 --> 20:18.840]  Значит, смотрите.
[20:19.840 --> 20:20.840]  А что мы будем делать?
[20:21.840 --> 20:22.840]  Мы заведем с вами двумерный массив.
[20:23.840 --> 20:34.840]  Двумерный массив dpt ж, где будем хранить в dpt ж длину наибольшей общей подпоследовательности xyt y ж.
[20:35.840 --> 20:37.840]  И заполнять z будет очень просто.
[20:38.840 --> 20:39.840]  Давайте я сейчас что-нибудь сотру.
[20:49.840 --> 20:53.840]  Смотри, продиктуйте мне какие-нибудь, не знаю.
[20:55.840 --> 20:58.840]  А, сейчас я пойму, как тут лучше.
[20:58.840 --> 20:59.840]  Вот так.
[21:00.840 --> 21:01.840]  И вот так.
[21:02.840 --> 21:05.840]  Продиктуйте мне какие-нибудь чиселки.
[21:08.840 --> 21:10.840]  Ладно, давайте буквки.
[21:11.840 --> 21:12.840]  Давайте буквками.
[21:15.840 --> 21:16.840]  А?
[21:18.840 --> 21:19.840]  А?
[21:21.840 --> 21:24.840]  Давайте английское.
[21:25.840 --> 21:26.840]  Хорошо?
[21:26.840 --> 21:27.840]  Английское.
[21:28.840 --> 21:29.840]  А?
[21:34.840 --> 21:35.840]  Чего еще раз?
[21:39.840 --> 21:40.840]  Давайте еще что.
[21:45.840 --> 21:47.840]  Хорошо, ладно, если вам так надо.
[21:50.840 --> 21:51.840]  Все?
[21:52.840 --> 21:53.840]  Стало жить лучше?
[21:56.840 --> 21:57.840]  Откуда?
[21:58.840 --> 21:59.840]  Почему?
[22:02.840 --> 22:04.840]  Ладно, друзья, так и быть.
[22:05.840 --> 22:06.840]  Мы здесь закончим.
[22:07.840 --> 22:08.840]  Вам здесь тоже нужно что-то.
[22:09.840 --> 22:10.840]  Теперь русские буквы давайте.
[22:11.840 --> 22:12.840]  Еще.
[22:15.840 --> 22:16.840]  Вы хотите, чтобы вообще последовательности не сходились?
[22:17.840 --> 22:18.840]  Я правильно понимаю?
[22:23.840 --> 22:24.840]  Еще раз?
[22:26.840 --> 22:27.840]  У просто поместилось.
[22:29.840 --> 22:30.840]  Значит, смотрите.
[22:31.840 --> 22:32.840]  Как заполнять эту таблицу?
[22:33.840 --> 22:35.840]  Таблица заполняется, на самом деле, очень просто.
[22:36.840 --> 22:39.840]  В начале здесь вот у меня не просто так сделаны пропуски.
[22:40.840 --> 22:42.840]  Это сделано именно для того, чтобы у нас она легче заполнилась.
[22:43.840 --> 22:47.840]  Мы говорим, что пока у нас символов нет, ну вот, пустая строка.
[22:48.840 --> 22:49.840]  То есть это обозначение пустой той самой строки.
[22:50.840 --> 22:51.840]  Какая длина наибольшей, вообще?
[22:51.840 --> 22:52.840]  Ноль.
[22:53.840 --> 22:54.840]  Ну, пустая строка.
[22:55.840 --> 22:56.840]  Какая с ней может быть наибольшая последовательность?
[22:57.840 --> 22:58.840]  Поэтому она заполняется вот так вот нулями.
[22:59.840 --> 23:00.840]  А дальше, что происходит?
[23:01.840 --> 23:06.840]  Если мы находим одинаковые символы, то это означает, что мы могли прийти только в одном случае.
[23:07.840 --> 23:08.840]  Каком?
[23:09.840 --> 23:15.840]  А вот по той самой теореме мы говорили о том, что мы могли прийти только из наибольшей строки.
[23:15.840 --> 23:22.840]  По той самой теореме мы говорили о том, что мы могли прийти только из наибольшей общей подпоследовательности.
[23:23.840 --> 23:25.840]  Хм-1, ун-1.
[23:26.840 --> 23:27.840]  Правда?
[23:28.840 --> 23:34.840]  А значит, это то же самое, что мы здесь делаем dpi-1, g-1 и сделаем плюс один, потому что символ одинаковый.
[23:35.840 --> 23:36.840]  Окей?
[23:38.840 --> 23:39.840]  Это понятно?
[23:40.840 --> 23:41.840]  Да.
[23:42.840 --> 23:49.840]  Аналогично для второго случая мы говорили, что если у нас символы не равны, то мы могли прийти, грубо говоря, либо сверху, либо слева.
[23:50.840 --> 23:52.840]  То есть убрать символ либо от одной строки, либо от другой строки.
[23:53.840 --> 23:55.840]  В этом случае нам нужно выбрать максимальный.
[23:56.840 --> 23:59.840]  Мы же пытаемся найти наибольшую общую подпоследовательность, а структуру ее не знаем.
[24:00.840 --> 24:01.840]  То есть мы отталкиваемся здесь от этого.
[24:02.840 --> 24:03.840]  Таким образом у нас вот такое вот построение будет.
[24:04.840 --> 24:10.840]  И если мы говорим о данном примере восхитительном, то что у нас будет происходить?
[24:11.840 --> 24:13.840]  И а оно как бы не сходит.
[24:14.840 --> 24:17.840]  Первый раз на самом деле с русскими буквами эту задачу решаем.
[24:18.840 --> 24:21.840]  Вот, поэтому здесь максимум отсюда и отсюда это ноль.
[24:22.840 --> 24:24.840]  И ис тоже самое.
[24:25.840 --> 24:26.840]  Сложно, становится.
[24:27.840 --> 24:34.840]  Здесь аналогично, а иф тоже, ища тоже, и твердый знак тоже.
[24:35.840 --> 24:37.840]  То есть у нас как бы мы не могли ниоткуда прийти здесь.
[24:38.840 --> 24:39.840]  У нас, к сожалению, нет такой буковки.
[24:39.840 --> 24:49.840]  Когда сходится, да, сейчас мы дойдем до сходства.
[24:50.840 --> 24:52.840]  Когда не сходится, мы смотрим вверх и влево.
[24:53.840 --> 24:55.840]  А максимальный?
[24:56.840 --> 25:00.840]  Потому что он нам показывает, что мы же оттуда могли прийти.
[25:01.840 --> 25:04.840]  Вот, или отсюда могли прийти. Другого варианта у нас нет.
[25:05.840 --> 25:07.840]  Мы специально теориям для этого доказали.
[25:10.840 --> 25:14.840]  Ну, то есть я вот пришел, к примеру, вот из этой строчки, либо отсюда, либо отсюда.
[25:15.840 --> 25:17.840]  Я максимум из них убираю, но там и там ноль.
[25:24.840 --> 25:28.840]  По диагонали мы можем прийти только в одном случае, когда символы одинаковые.
[25:29.840 --> 25:30.840]  Вот.
[25:31.840 --> 25:32.840]  Смотрим на ща.
[25:33.840 --> 25:36.840]  Ну, давайте я тут облегчу нам задачу.
[25:36.840 --> 25:37.840]  Вот так.
[25:38.840 --> 25:52.840]  Но когда щ и щ здесь будут одинаковые, это означает, что мы должны убрать символ один отсюда и один отсюда, сделать плюс один к тому, что было по диагональке.
[25:53.840 --> 25:57.840]  То есть вот из этого кусочка, который я сейчас выделяю, мы должны выбрать как раз наши символы.
[25:58.840 --> 26:03.840]  То есть вот здесь я делаю через плюс один, получая здесь один.
[26:04.840 --> 26:05.840]  Понятно?
[26:06.840 --> 26:09.840]  Это благодаря той самой теории, которую мы с вами доказали.
[26:10.840 --> 26:11.840]  Ну, дальше здесь отсюда и отсюда.
[26:12.840 --> 26:13.840]  Вот здесь вот единичка вот здесь получается.
[26:14.840 --> 26:15.840]  Согласны?
[26:16.840 --> 26:17.840]  Смотрим дальше.
[26:18.840 --> 26:20.840]  А и А. А и А сходятся удивительные рядом.
[26:21.840 --> 26:24.840]  Поэтому здесь аналогично, через плюс один по диагональке.
[26:25.840 --> 26:26.840]  Здесь будет один.
[26:27.840 --> 26:28.840]  И здесь опять А и А сходятся.
[26:29.840 --> 26:31.840]  Мы идем опять же по диагонали и делаем плюс один.
[26:32.840 --> 26:35.840]  После этого мы смотрим на максимумы, вот получаем такое.
[26:39.840 --> 26:40.840]  А?
[26:41.840 --> 26:42.840]  Интересно получается.
[26:43.840 --> 26:45.840]  Здесь аналогично А и А.
[26:46.840 --> 26:49.840]  Мы смотрим, приходим по диагонали, получаем здесь один.
[26:50.840 --> 26:54.840]  А здесь не сходится один, а вот здесь А и А опять сходятся.
[26:55.840 --> 26:58.840]  Поэтому мы приходим вот отсюда, через плюс один у нас получается два.
[26:58.840 --> 26:59.840]  Дальше будет два, два, два.
[27:00.840 --> 27:01.840]  Ну и У.
[27:02.840 --> 27:06.840]  У, извините, у него ничего нет, поэтому это просто максимум из соседних ячеек.
[27:07.840 --> 27:09.840]  Ответ лежит вот здесь.
[27:10.840 --> 27:11.840]  В ДП.
[27:12.840 --> 27:13.840]  Н там.
[27:14.840 --> 27:15.840]  М там.
[27:18.840 --> 27:20.840]  Здесь находится ответ.
[27:21.840 --> 27:24.840]  Давайте сразу проговорим, как можно восстановить диагональ.
[27:25.840 --> 27:27.840]  Мы смотрим, откуда мы пришли.
[27:28.840 --> 27:30.840]  Либо сверху, либо слева.
[27:31.840 --> 27:33.840]  Здесь числа одинаковые, нам без разницы откуда мы пришли.
[27:34.840 --> 27:36.840]  Поэтому мы можем сказать, что сверху.
[27:37.840 --> 27:38.840]  Но так как мы знаем, что если мы пришли либо сверху,
[27:39.840 --> 27:40.840]  ну мы смотрим на символы.
[27:41.840 --> 27:45.840]  Если символы различные, то мы идем либо наверх, либо налево где-либо вот здесь.
[27:46.840 --> 27:47.840]  И вот здесь вот.
[27:48.840 --> 27:49.840]  Ну вот.
[27:50.840 --> 27:51.840]  И вот здесь вот.
[27:51.840 --> 27:57.660]  то мы идем либо наверх, либо налево, где лежит это максимальное число. Но если мы встретим
[27:57.660 --> 28:02.960]  одинаковые символы, то эти символы мы записываем себе в подпоследовательность. Давайте здесь
[28:02.960 --> 28:09.800]  делать. Ну вот я иду в два, в два я мог попасть только отсюда, потому что сверху единичка,
[28:09.800 --> 28:15.880]  слева двойка. Я слева пришел. Дальше здесь у меня символы опять различны, я иду вот сюда,
[28:15.880 --> 28:23.320]  а потом я иду вот сюда. А вот здесь я уже встречаю одинаковый символ А и А. Я записываю это А,
[28:23.320 --> 28:33.680]  давайте напишу это с черточкой, чтобы вы поняли, что мы получим подследовательный наоборот. Вот я
[28:33.680 --> 28:42.640]  получаю А и А и иду вот сюда, в эту диагональку. Смотрю здесь, здесь опять А, С. Символы различны,
[28:42.640 --> 28:48.600]  я пришел либо сверху, либо слева, а здесь только слева, то есть вот сюда иду. Смотрю здесь А и А,
[28:48.600 --> 28:56.440]  значит я пришел по диагонали, а значит в этом случае я говорю, что я пишу вот это А и иду по
[28:56.440 --> 29:03.960]  диагональке. Но дальше тут ноль, все грустно и получается, что у меня вот такая последовательность.
[29:03.960 --> 29:16.160]  Заметьте, она наоборот сделана. Вот, поэтому ее нужно в конце всегда перевернуть. Понятно? Все
[29:16.160 --> 29:23.200]  достаточно просто. Реализация его вот, здесь чуть больше ифов написано с точки зрения не максимума,
[29:23.200 --> 29:28.440]  откуда мы пришли, почему? Потому что здесь реализована то самая преф, это та самая пара,
[29:28.440 --> 29:34.160]  которая нам нужна будет с точки зрения встановления ответа. Это не обязательно,
[29:34.160 --> 29:40.840]  вы можете делать это не таким образом. Вот здесь написано пара, вы пары использовать не можете,
[29:40.840 --> 29:49.280]  я так напоминаю. С ДПР еще не существует. Можете структуру написать, все верно.
[29:49.280 --> 30:07.320]  Инициализация, так, и чего?
[30:19.280 --> 30:32.640]  Нельзя. Вот, я здесь написал вам псевдокод. Я напомню, что я начал писать псевдокод,
[30:32.640 --> 30:37.520]  потому что ВЛ с плейдеревом и закончили, это было самое сложное. Здесь очень простое.
[30:37.520 --> 30:45.440]  Вот. Но здесь что происходит? Ну как бы заполнение в начале, я думаю, вы понимаете. Дальше у меня
[30:45.440 --> 30:51.760]  просто идет цикл между собой, я сравню, если одинаковая, то я иду как раз по диагонали и
[30:51.760 --> 31:00.120]  делаю плюс один, иначе я смотрю, откуда пришел, сверху или слева. Все, нет никаких проблем.
[31:00.120 --> 31:11.760]  Вопросы есть? Все ли понимают, что этот алгоритм работает за NM? Есть ли вопросы к этому? Или проблемы?
[31:11.760 --> 31:24.160]  К сожалению, наибольшую общую подпоследовательность быстрее нельзя. Но мы переходим с вами к НВП потом,
[31:24.160 --> 31:29.400]  попозже. Восстановление ответа мы с вами проговорили. Здесь просто пройтись по этим параметрам.
[31:29.400 --> 31:41.400]  Наибольшая возрастающая подпоследовательность, что здесь? Это N-V-P. Дальше задача очень простая.
[31:41.400 --> 31:48.800]  Здесь уже дается не несколько последователей, а одна. И нужно N-state из чисел, ну либо из чего-то,
[31:48.800 --> 31:57.640]  что вы можете сравнивать, но чаще всего это чиселки. Для примера это будут именно целые числа. И вам
[31:57.640 --> 32:04.480]  нужно найти такую подпоследовательность, которая будет возрастать. То есть наибольшая
[32:04.480 --> 32:11.840]  общая возрастающая подпоследовательность. Все достаточно просто. Понятно, что хочется в
[32:11.840 --> 32:24.320]  задачу? Всем? Хорошо. Тогда первое решение очень простое. Вот вы можете его прочитать и сказать,
[32:24.320 --> 32:28.440]  понятно оно вам или нет. Давай пока сотру. Дальше мы его разберем.
[32:44.000 --> 32:45.360]  Кто понял, что написано?
[32:45.360 --> 33:04.320]  Понятно? Это за N квадрат работает, да. Смотрите, давайте это сделаем на примере. Продиктуйте
[33:04.320 --> 33:22.840]  мне чиселки. 1, 4. Будем возрастать на время. Давайте я введу 3 для прикола. 8,
[33:22.840 --> 33:39.280]  минус 9, минус 1 и 7. Ну все ладно, давайте успокоимся. Смотрите, что подразумевается в этом алгоритме.
[33:39.280 --> 33:46.880]  В этом алгоритме происходит следующее. Предположим, мы с вами знаем вот здесь вот какие-то числа. Ну там,
[33:46.880 --> 33:57.920]  давайте их назову x1, x2, x3, x4. Вот к этому моменту. Смотрите, как можно здесь разбивать их между
[33:57.920 --> 34:06.880]  собой? Я смотрю на нынешнее число и смотрю на все числа перед ним. Если я нахожу числа меньше его,
[34:06.880 --> 34:14.120]  то я буду рассуждать в одном случае. Если я их не нахожу, тогда, извините, если там не было
[34:14.120 --> 34:19.080]  перед ним никаких чисел меньше, значит он не может участвовать ни в какой возрастающий подпоследок,
[34:19.080 --> 34:28.320]  кроме как сам собой. Согласны? Поэтому здесь будет на самом деле единичка, к примеру. Теперь
[34:28.320 --> 34:35.440]  предположим, что у нас здесь еще какой-нибудь есть x5. Вот я смотрю сюда, на эту семерку. Я опять же
[34:35.440 --> 34:43.200]  пройдусь по всем предыдущим и выберу из чисел там, где у меня есть числа меньше. Это 1,
[34:43.200 --> 34:52.480]  4, 3, минус 9, минус 1. Только 8 обделено. Я выбрал числа меньше. А теперь смотрите,
[34:52.480 --> 35:00.200]  какой здесь интересный поворот. Согласны, что если я добавлю 7 к любой из подпоследов,
[35:00.200 --> 35:04.440]  которая заканчивается на эти числа, то у меня увеличится возрастающая подпоследовательность.
[35:04.440 --> 35:12.320]  Согласны? А давайте выберем наибольшую из всех возможных. То есть я вот сюда поставлю
[35:12.320 --> 35:18.000]  максимум из всех чисел, которые у меня здесь есть, и сделаю плюс один, потому что я добавлю
[35:18.000 --> 35:24.160]  семерку. Кроме 8, 8 больше число, поэтому я его не трогаю. Понятно, что я имею в виду?
[35:24.160 --> 35:38.320]  У кого есть непонимание решения? Сейчас примерно разберем нормально с чиселками. А перед ним нет
[35:38.320 --> 35:44.760]  ни одного числа меньше него. Согласен? Он не может участвовать ни в одной возрастающей
[35:44.760 --> 35:50.280]  подпоследовательности. Да, это длина. Здесь мы храним длину. Вот это и есть тот самый массив dp.
[35:50.280 --> 36:13.080]  А слева от иксы. Икс и – это символ, число. У меня весь этот массив – это икс. Но обратиться
[36:13.080 --> 36:25.680]  к итому элементу – это x и t. Это одно число. Вот это, например. Ну, смотрите, x нулевое равно
[36:25.680 --> 36:42.400]  единичке. Я утверждаю. Это массив. А x и t – это предыдущие. Это до этого момента. То есть x
[36:42.400 --> 36:56.080]  большое и t – это все числа, которые есть там x1 и так далее x и t. x нулевое. Понятно? Все
[36:56.080 --> 37:06.160]  числа меньше. Ну вот, меньше-то вот, что здесь есть. Давайте разбирать здесь. Смотрите, начальные
[37:06.160 --> 37:11.200]  условия на самом деле простые. Первое число всегда одно. Это максимальная возрастающая
[37:11.200 --> 37:18.920]  подпоследовательность из одного числа. Согласны? Теперь я смотрю дальше. Четыре. Смотрю на все
[37:18.920 --> 37:25.840]  предыдущие. Вижу только единичку, правда? Но все равно вижу. А она меньше, чем четыре. Какой у
[37:25.840 --> 37:30.880]  меня здесь есть вариант? Первый вариант есть, что само четыре, как возрастающий подпоследователь.
[37:31.400 --> 37:41.560]  Что мы добавим эту четверку к какому-то другому числу, которая будет меньше четырех, а значит мы
[37:41.560 --> 37:46.760]  увеличим это возрастающую подпоследовательность. Поэтому здесь уже будет ответ два. То есть количество
[37:46.760 --> 37:55.520]  символов – два, один, четыре. Понятно? Дальше я смотрю на три. Три меньше четырех, но больше
[37:55.520 --> 38:04.320]  единицы. Меньше четырех мы пропускаем. Больше единицы смотрим. Если оно больше единицы, тогда в этом
[38:04.320 --> 38:09.360]  случае я могу тройку добавить к единичке и опять получить возрастающую подпоследовательность.
[38:09.360 --> 38:15.720]  Один, три. Согласны? Поэтому здесь на один больше количество возрастающей подпоследовательности,
[38:15.720 --> 38:23.280]  чем в единичке. Поэтому здесь опять же два. Восемь. Мы смотрим восемь. Восемь больше трех, правильно?
[38:23.280 --> 38:30.720]  А я могу восьмерку добавить к этой тройке в конце и получить новую возрастающую подпоследовательность.
[38:30.720 --> 38:37.360]  Значит я делаю, что здесь, к примеру, у меня три. Четыре опять меньше восьми, но я не получаю
[38:37.360 --> 38:45.660]  большее число, чем три. Согласны? А значит смысл мне это вообще трогать. Поэтому здесь три. Для
[38:45.660 --> 38:50.720]  единички аналогично. Тут получу вообще два. Ничего не изменится. То есть я прошелся по всем
[38:50.720 --> 38:57.800]  предыдущим. Минус девять. Я смотрю оно меньше этого, меньше этого, меньше этого, меньше этого. Грустная
[38:57.800 --> 39:05.320]  история. Значит оно может быть только лишь самим собой. Поэтому это единичка. Оно само может быть
[39:05.320 --> 39:11.000]  только возрастающей подпоследовательностью. Для минус одного я смотрю все предыдущие только минус
[39:11.000 --> 39:17.240]  девять меньше. Если минус девять меньше, то я могу к нему добавить минус единицу и я получаю
[39:17.240 --> 39:22.440]  возрастающую подпоследовательность. Поэтому получаю здесь два. Ну плюс один от минус девяти.
[39:22.440 --> 39:29.640]  Для семерки мы опять же смотрим на все предыдущие, а выбираем все числа меньше. Все числа меньше,
[39:29.640 --> 39:34.360]  вот у меня галочка здесь и проставлены. И на самом деле вот я первое число, которое встречу,
[39:34.360 --> 39:40.480]  минус один, здесь будет два. И вот я как бы добавлю сюда три. Какая возрастающая подпоследовательность,
[39:40.480 --> 39:51.600]  как вы думаете, здесь будет? Все зависит от того, как вы найдете максимум на самом деле. Для того,
[39:51.600 --> 39:57.320]  чтобы восстановить всю эту подпоследовательность, вам достаточно будет хранить массив предыдущих. То
[39:57.320 --> 40:04.960]  есть кто является предыдущим тем самым элементом? Предыдущий индекс от этой возрастающей подпоследовательности.
[40:04.960 --> 40:10.080]  Кто перед ним стоит? Ну для единички это будет минус один, для четверки это будет нулевой индекс,
[40:10.080 --> 40:18.480]  для тройки это нулевой индекс, для восьмерки это будет второй индекс. Дайте я пронумеру 0, 1, 2, 3,
[40:18.480 --> 40:29.240]  4, 5, 6. Для минус девяти это будет какой индекс? Минус первый, перед ним никого нет, да минус одного что?
[40:29.240 --> 40:42.520]  Четвертый, то есть минус девять, которое было. А для семерки? Пятый. Ну и как бы вы просто возвращаете
[40:42.520 --> 40:46.560]  эту последовательность. Каким образом? Пока предыдущий не равен минус единице, вы добавляете
[40:46.560 --> 40:52.160]  этот массивчик, получаете число. Если вам надо найти размер этой наибольшей общей подпоследовательности,
[40:52.160 --> 41:01.920]  то он лежит вот здесь. Согласны? Вот. Найдете максимум здесь, получите возрастающую подпоследовательность.
[41:01.920 --> 41:15.360]  За сколько это работает? Почему? Ну мы сравниваем, получается у нас там будет n на n минус один
[41:15.360 --> 41:28.960]  пополам. Количество сравнений. Правильно? Понятно почему? А почему это плохо? А что бывает быстрее?
[41:28.960 --> 41:39.920]  Бывает логоарифм. Правильно, бывает логоарифм. Это я согласен. Вот. Но что касается реализации
[41:39.920 --> 41:46.160]  вот этого решения? Реализация достаточно тоже понятна. Вы берете сначала, создаете все массивы,
[41:46.160 --> 41:53.400]  потом дальше проходите по каждому из элементов и говорите, что он идет от нуля до n минус один.
[41:53.400 --> 41:59.520]  Ставите единичку, потому что он может быть самостоятельным. Предыдущий минус единички,
[41:59.520 --> 42:05.480]  ок, ничего страшного. А дальше вы говорите, что если вы нашли из предыдущих элементов какой-то
[42:05.480 --> 42:11.080]  меньше и размеры этой наибольшей подпоследовательности больше, чем тот, который стоит у меня сейчас,
[42:11.080 --> 42:18.040]  тогда я беру этот элемент. Все. Ну ровно то, что мы сейчас сделали на примере. К этому ли есть вопросы?
[42:18.040 --> 42:31.080]  Вроде достаточно простой алгоритм. Главное понять суть. А это очень похоже на префиксу,
[42:31.480 --> 42:38.680]  с префиксами, когда вы работали или если хоть раз встречались, давайте так. Это очень похоже.
[42:38.680 --> 42:47.700]  Вы просто смотрите на все предыдущие и что-нибудь решаете от этого. Но можно ли быстрее? Это главный
[42:47.700 --> 43:00.320]  будет наш вопрос. На самом деле можно. Здесь пока я стираю опять же. Вы почитайте и мы с вами
[43:00.320 --> 43:10.840]  сейчас поймем, что же там происходит такого. Вот обычно на этом моменте многие из вас ломают.
[43:10.840 --> 43:17.000]  Поэтому, пожалуйста, задавайте вопросы. Для предыдущей вроде понятно.
[43:31.320 --> 43:41.840]  Очень забавно, что люди сверху, они еще и в наушниках сидят. Вот я ж говорю. А зачем ты приходишь?
[43:41.840 --> 43:48.960]  Если ты в наушниках сидишь, ну вот настолько.
[43:56.960 --> 44:03.520]  Ладно. Давайте разбираться с тем, что происходит здесь в наибольшей возрастающей подпоследовании.
[44:03.520 --> 44:12.040]  Смотрите. Мы говорили, что у нас здесь в ДП хранилась максимальная длина наибольшей
[44:12.040 --> 44:22.720]  возрастающей подпоследователь, оканчиваясь на этот символ. Правильно? А теперь мы в ДП и там храним
[44:22.720 --> 44:42.000]  минимальное число, на которое может, я специально пишу и говорю типа по словам, может оканчиваться
[44:42.000 --> 45:03.480]  наибольшая возрастающая подпоследовательность длины и все. Какое у нас максимальное значение
[45:03.480 --> 45:11.320]  наибольшей возрастающей подпоследовательности? Все элементы. Поэтому в действительности вот это ДП,
[45:11.320 --> 45:24.800]  оно будет принимать значение от нуля, потому что их и ноль как бы бывает, до Н включительно. Одно?
[45:24.800 --> 45:34.760]  Может мы выбираем специально меньшее число из них. Меньшее число, на которое заканчивается
[45:34.760 --> 46:01.840]  последовательность длины и минимальное, наименьшее. Одно? Да? Это размерность массива. Не более.
[46:05.520 --> 46:21.360]  Что еще раз? Наибольшая возрастающая подпоследовательность длины и… Да?
[46:21.360 --> 46:30.800]  Наибольшая возрастающая… Хорошо, возможно я здесь не совсем корректно написал. Предположим,
[46:30.800 --> 46:37.480]  что у нас есть х, это наибольшая возрастающая подпоследовательность от х длины и. Просто
[46:37.480 --> 46:44.280]  возрастающая подпоследовательность длины и. Давайте типа вот так. Возрастающая подпоследовательность
[46:44.280 --> 47:02.400]  длины и. Так лучше? Из нашего массива х. Мы храним минимальный элемент, на который может
[47:02.400 --> 47:10.760]  заканчиваться наибольшая возрастающая подпоследовательность длины и. У нас длина
[47:10.760 --> 47:21.400]  здесь, понимаешь, она не максимальный. Нет. Давайте с вами разбираться с тем, что здесь происходит.
[47:21.400 --> 47:44.760]  На минимальный? Если ты так рассуждаешь, то хорошо. Давайте с вами смотреть. Это все на самом деле
[47:44.920 --> 47:57.960]  работает на примерах. Вот это вам придется самим написать. Кодом я, конечно, покажу, но поверьте,
[47:57.960 --> 48:09.000]  здесь не то чтобы очень много поможет. Возьмем такую же последовательность. Хорошо. Один, четыре,
[48:09.000 --> 48:18.760]  три, восемь. Сейчас момент. Нет, я не хочу такую. Я чуть-чуть изменю. Я добавлю один символ в конце.
[48:18.760 --> 48:35.760]  Минус девять, минус один и. Давайте я сделаю здесь минус десять. Двукзначные числа? Кошмар! Ужас
[48:35.760 --> 48:42.680]  просто. Смотрите, я буду пошагово заполнять массив dp и вы будете смотреть, что с ним происходит.
[48:42.680 --> 48:49.560]  Первоначально массив dp в самом начале, на нулевой итерации, он равен минус бесконечный. Давайте я
[48:49.560 --> 48:56.400]  вот прям под этим буду писать. Единственное, что лучше бы их чуть-чуть сдвинул. Ну ладно.
[48:56.400 --> 49:05.840]  Сделаю табличку. Здесь будет номер итерации. Это все будет про массив dp. Номер итерации,
[49:05.840 --> 49:20.720]  а здесь количество символов. Ноль, один, два, три, четыре. Сейчас, сколько у нас тут? Четыре, пять,
[49:20.720 --> 49:33.720]  шесть, семь, восемь, восемь. Четыре, пять, шесть, семь, ну и тут восемь. Вот это массив dp. Я буду
[49:34.140 --> 49:45.900]  смотреть на каждую из итераций. Ну на нулевой итерации что этот массив занят. Минус бесконечностью.
[49:45.900 --> 49:55.020]  еще раз бесконечный. Да. А существует специальная библиотека с лимитами, можешь взять лимит.
[49:55.020 --> 50:03.260]  Ну да, с лимитами-то можно. Но у тебя обычно в условии сказано, что не больше каких чисел.
[50:03.260 --> 50:12.420]  Этого будет достаточно. Вот в начале такое у меня ДП. И тут бесконечный. Я смотрю последовательно
[50:12.420 --> 50:21.220]  каждый из этих символов. На первые трассы я смотрю лишь на первое число. Какой максимальной длины
[50:21.220 --> 50:25.380]  здесь возрастающей подпоследность может быть? Вот из одного элементика.
[50:25.380 --> 50:32.580]  Один. Вот здесь становится единичка, здесь остается минус бесконечность, бесконечность,
[50:32.580 --> 50:42.380]  бесконечность, бесконечность и так далее. Ага. Я дальше уже буду прочерк ставить.
[50:42.380 --> 50:54.660]  Почему единичка встала в единичку? Я смотрю пока на первое число. Только лишь на первое. Я
[50:54.660 --> 51:03.980]  иду последовательно. Я говорю, что у меня в ДПИ там хранится, еще раз, минимальное число,
[51:03.980 --> 51:10.140]  на которое последовательность может заканчиваться длиной И. Вот если у меня в начале было минус
[51:10.140 --> 51:17.780]  бесконечность и бесконечность, и я смотрю только на одно число, вот эту единицу, то при этой единице,
[51:17.780 --> 51:25.980]  вот оно одно. Какая возрастающая подпоследность максимальная? Из единички. И длины единицы.
[51:25.980 --> 51:32.180]  Так уж и сошлось в этом примере. Вы меня сами продиктовали, я только по нему иду.
[51:32.180 --> 51:37.700]  Вот. Теперь я смотрю на второй итерации. Что у меня происходит на второй итерации здесь,
[51:38.380 --> 51:50.420]  я добавляю новое число 4. Смотрите, я заполняю. Минус бесконечность. Здесь я могу сказать,
[51:50.420 --> 51:58.020]  что на 4 будет заканчиваться. Оно не минимальное. Минимальное это единичка, поэтому я оставляю
[51:58.020 --> 52:04.420]  единичку здесь, а четверку я вставляю сюда, потому что у меня есть 1 в 4. Причем заметьте,
[52:04.420 --> 52:13.020]  я меняю только один символ. Число, к которому я перехожу. Вот 2 означает, что к второму пришел.
[52:13.020 --> 52:29.100]  Вроде мы решили вопрос с единичкой. Нельзя. Почему? Потому что, давайте еще раз,
[52:29.100 --> 52:38.740]  ДПИТ это массив, в котором вы сохраняете наименьшее число, на которое заканчивается
[52:38.740 --> 52:45.180]  возрастающая подпоследовательность длины И. Если у меня есть две возрастающие подпоследовательности,
[52:45.180 --> 52:54.740]  длины 1. 1 и 4. На какое число минимальное оно оканчивается? Вот у меня есть две. Какой из них меньше?
[52:59.420 --> 53:11.180]  У меня есть последовательность длины 1 из единицы и четверки. Я ее и оставляю. А дальше я смотрю на 2.
[53:11.180 --> 53:18.420]  Длины 2. Могу я что-то сделать или нет? Могу. Четверку если добавлю. У меня два символа всего пока так.
[53:18.420 --> 53:31.100]  Оно одномерно. Я ставлю здесь номер итерации. Это номер итерации. Как меняется массив ДПП,
[53:31.100 --> 53:41.700]  когда мы проходимся по всему своему массиву. Понятно? Все вопросы? Я говорю, вот это вот все.
[53:41.700 --> 53:56.500]  Это финал. Смотрим на третий возможный вариант. У меня есть 1, 4 и 3. Длины 1. Все еще из единицы.
[53:56.500 --> 54:05.940]  Согласны? Лучше всего. А вот длины 2. Что лучше? Троечку поставить. У меня будет 1 и 3 уже в этом
[54:05.940 --> 54:18.820]  случае. Тут бесконечности. Те, где я не заполняю. Что еще раз? А я могу здесь сделать 3 элемента из 4?
[54:18.820 --> 54:34.100]  Вот у меня 1, 4 и 3. Что возрастающее? Не могу. Что еще раз? Что меньше, что лучше.
[54:34.740 --> 54:41.420]  Сейчас объясню, как мы будем искать, куда вставлять. Это нормально. Я хочу сейчас кое-что показать на этом
[54:41.420 --> 54:56.580]  примере. Я показываю смысловую нагрузку. Это хороший вопрос, которому я скоро перейду.
[54:56.580 --> 55:09.180]  Хорошо? Да. Итерация, что это такое? Я смотрю на новый символ. Я же иду последовательно по символам.
[55:09.180 --> 55:14.980]  Я смотрю на новый символ и пытаюсь его куда-то впихнуть. И смотрю, типа, сделает он какие-то
[55:14.980 --> 55:23.180]  обновления или нет. И где он сделает? Понятно? Вот это здесь итерация. Вот, я смотрю на 8. Смотрите,
[55:23.180 --> 55:32.740]  8 в один символ может встать? Нет, но единица меньше. Тройка тоже меньше, и там смысла встать нет.
[55:32.740 --> 55:41.380]  А вот из трех символов восьмерка уже встанет. Логично? Логично. Здесь опять будет бесконечности.
[55:41.380 --> 55:57.060]  Дальше пятая итерация. Кто-нибудь хочет мне ее продиктовать? Шестая. Давайте сразу седьмая.
[55:57.060 --> 56:20.100]  Что еще раз? Потому что у меня нету большей длины в последовательности.
[56:20.100 --> 56:33.300]  Конечно. Вторая и третья итерация это вот досюда и вот досюда. Вот это первая итерация,
[56:33.300 --> 56:45.700]  вот это вторая итерация, вот это третья. На шестой что? Потому что какая последовательность длины
[56:46.180 --> 57:01.580]  меньше оканчивается на меньшее число? На минус 9 или на единицу? Минус 9, 3, 8. Вот здесь очень важно
[57:01.580 --> 57:07.940]  вам показать следующее, что это не является той самой возрастающей под последовательностью,
[57:07.940 --> 57:17.940]  которой у меня есть. В dpi хранится просто одно число, на которое заканчивается последовательность
[57:17.940 --> 57:28.380]  длины и и это число на и меньшее из всех возможных. Смотрите, давайте вот на примере пятой итерации
[57:28.380 --> 57:39.420]  поймем. У нас длины 1. Какие есть последовательности? Вот если до минус 9. У меня есть 1, 4, 3, 8, минус 9.
[57:39.420 --> 57:56.260]  Согласны? Минимальный последний элемент. Извините. Вот у меня есть вот эти числа. Какое из них
[57:56.260 --> 58:04.180]  минимальное? Вот оно и стоит. Теперь давайте смотреть длины последовательности 2. У меня может
[58:04.180 --> 58:25.220]  быть 1, 4, 1, 3, 1, 8, 4, 8, 3, 8. Все. Какое из этих последних чисел меньше? Вот это 3 здесь и стоит.
[58:25.220 --> 58:40.180]  Теперь давайте длины 3. Длины 3 у меня есть 1, 4, 8, 1, 3, 8. Все. Какое меньше? Ну 8. У нас другого
[58:40.180 --> 58:51.660]  варианта нет. Понятно, что имеется в виду здесь dpi там? Вот. Шестой вариант. Тогда
[58:51.660 --> 59:05.340]  мне продиктуйте, пожалуйста. Минус 9, минус 1, 8. Так. Правда. Дальше? Я еще вот здесь. У меня семерки
[59:05.340 --> 59:19.380]  еще нет. Следующее. Когда у нас 7 появляется? Минус 9, минус 1, 7 и бесконечности. Ну и когда
[59:19.380 --> 59:32.300]  минус 10 появляется? Минус 10, минус 1, 7 и бесконечности. Смотрите. Давайте с вами кое-что заметим,
[59:32.300 --> 59:39.380]  очень важное здесь. Во-первых, согласны ли вы с тем, что из смысла dpi вы понимаете,
[59:39.380 --> 59:50.100]  что это всегда будет возрастающий массив? Правильно? А? Не. Ну по числам, которые в нем хранятся.
[59:50.100 --> 59:58.740]  Ну у вас в dpi там хранится число, на которое заканчивается it последовательно. Значит,
[59:58.740 --> 01:00:07.180]  i-1 заканчивается на число меньше. Значит dpi-1 всегда меньше, чем dpi. Это первый нюанс.
[01:00:07.180 --> 01:00:14.100]  Второй нюанс. У нас любое число, которое мы здесь с вами находили, меняло эту последовательность один раз.
[01:00:14.100 --> 01:00:24.980]  Всего один. Оно вставало в какое-то место и делало это один раз. И как оно это делало? На самом
[01:00:24.980 --> 01:00:34.260]  деле все очень просто оно это делало. Оно находило место там, где первое число большее него. То есть
[01:00:34.260 --> 01:00:39.940]  один стало на место бесконечности, четыре стало на место бесконечности, три на место
[01:00:39.940 --> 01:00:48.900]  четыре, потому что четыре больше него. Восемь стало на место бесконечности, а дальше у нас было
[01:00:48.900 --> 01:00:58.740]  минус девять. Минус девять стало на единичку и так далее. Видите этот момент здесь? И оно в
[01:00:58.740 --> 01:01:02.900]  действительности всегда будет обновлять только одно число. Это тоже очень легко выводится из того,
[01:01:03.140 --> 01:01:08.500]  как выглядит dpi-t, потому что если оно встало в два места, то это странно, потому что такого быть не
[01:01:08.500 --> 01:01:17.140]  может. Потому что оно заканчивалось, ну там и-то и житое место, к примеру. И g больше и. Значит g-то
[01:01:17.140 --> 01:01:22.660]  заканчивается на число и it заканчивается на это же число. А что между ними? Что возрастающий
[01:01:22.660 --> 01:01:28.820]  под последовательностью является? Понятно? То есть между одинаковыми числами у вас что-то есть,
[01:01:28.820 --> 01:01:35.300]  а такого быть не может. Оно обновляется один раз, оно всегда возрастающее. Значит,
[01:01:35.300 --> 01:01:44.180]  как нам найти место первого числа, которое является большим? Bin поиском. Бежать долго.
[01:01:44.180 --> 01:01:56.540]  Bin поиск вам в помощь. Bin поиск найдет это место за сколько? За логарифм. Это и будет здесь ключом к
[01:01:56.540 --> 01:02:04.820]  тому, что это работает за n-логин. То есть я каждое число буду вставлять в это dpi-t с помощью bin поиска.
[01:02:04.820 --> 01:02:13.500]  Я вам показал, почему bin поиск можно, потому что это a возрастающая всегда,
[01:02:13.500 --> 01:02:23.540]  а возрастающий массив b это потому что я меняю всего одно число и возрастание остается. Именно
[01:02:23.540 --> 01:02:48.500]  поэтому минус бесконечность здесь есть. Она для bin поиска нужна. Давай еще раз.
[01:02:48.500 --> 01:03:10.740]  Да. dpi-t равно минимальный dpi житый. Такой, что у меня x житый больше,
[01:03:10.740 --> 01:03:20.540]  чем x итый. Здесь не совсем x. Ошибка, я согласен. Короче, переход здесь на самом деле просто найти
[01:03:20.540 --> 01:03:30.340]  это место в dpi житый. Вот. Да, это у меня тоже галочка. А вот здесь еще и аито. Я что-то вообще
[01:03:30.340 --> 01:03:36.500]  все напутал. Ладно. Важный момент. Для того, чтобы восстановить ответы, что нужно будет хранить?
[01:03:36.500 --> 01:03:42.900]  Хранить нужно будет позицию ита, которая будет показывать просто индекс элемента,
[01:03:42.900 --> 01:03:52.180]  на который здесь находится. Твоя массив x. Ну то есть я вот в поз ита буду сохранять эти индексы.
[01:03:52.180 --> 01:03:59.300]  Почему? Потому что у меня вот это вот минус 10, минус 1, 7 не является возрастающей. Мне нужно
[01:03:59.300 --> 01:04:07.740]  восстановить. А как мне это сделать? А очень просто. Я узнаю, какой индекс у семерки, а у семерки
[01:04:07.740 --> 01:04:14.580]  узнаю, какие у нее были предыдущие элементы. И все. Как я узнаю эти предыдущие элементы? Но вот
[01:04:14.580 --> 01:04:20.300]  когда я вставляю некоторое число, я знаю, что перед ним стоит элемент, который стоял точно раньше.
[01:04:20.300 --> 01:04:26.380]  Согласны? Это будет тот самый преф. Вопрос.
[01:04:40.380 --> 01:04:48.100]  В бесконечность. Он заменяет первый элемент больше. Это же бесконечность. Все в бесконечности.
[01:04:50.300 --> 01:04:51.980]  Что вопроса?
[01:04:51.980 --> 01:05:05.820]  Понял вопрос. Для этого нам нужно чуть-чуть еще написать тогда поз и ф. Давайте я напишу.
[01:05:05.820 --> 01:05:09.820]  Вот при заполнении как мы их должны были получить?
[01:05:09.820 --> 01:05:20.820]  Смотрите. Делается массив поз.
[01:05:20.820 --> 01:05:34.500]  Сколько у меня там от 0 до 8? 8. Вот так должно быть.
[01:05:34.500 --> 01:05:44.020]  И делается массив предыдущих элементов.
[01:05:44.020 --> 01:06:07.780]  Раз, два, три, четыре, пять, шесть, семь, восемь. Тоже от 0 до 8. Смотрите. Я иду все так же по элементу,
[01:06:07.780 --> 01:06:12.260]  с самого начала. То есть вот тут вот атеративно я здесь буду просто чиселки ставить.
[01:06:12.260 --> 01:06:15.260]  Привыначально тут минус единички, тут минус единички.
[01:06:15.260 --> 01:06:21.260]  Что означает поз и т?
[01:06:21.260 --> 01:06:31.260]  Поз и т, оно связано с dp. Вот представьте, что у меня есть тут и т элемент. Я должен понять, где он находится в моем массивчике.
[01:06:31.260 --> 01:06:41.260]  Если я говорю про последний элемент, то поз и т вот к этому, когда я получил финальный dp,
[01:06:41.260 --> 01:06:51.260]  он будет следующий. Минус один, но минус бесконечности, нет его места. Минус 10, где у нас стоит? На восьмом месте.
[01:06:51.260 --> 01:07:06.260]  Минус один стоит на шестом месте, а семь стоит на седьмом месте.
[01:07:07.260 --> 01:07:14.260]  А дальше будет минус один, минус один, минус один, минус один, минус один.
[01:07:14.260 --> 01:07:26.260]  То есть позиция это просто соответствие вот этого dp, этого числа, которое здесь, с тем, что было в иксе.
[01:07:26.260 --> 01:07:31.260]  Теперь предыдущие. Предыдущие это как раз когда я вставлял, что там происходило.
[01:07:31.260 --> 01:07:41.260]  Вот когда я единичку вставляю на первое место, а вот здесь, какой у него предыдущий элемент? Минус бесконечности, согласен?
[01:07:41.260 --> 01:07:50.260]  А у минус бесконечности какая позиция? Минус один, правильно? Поэтому я ставлю здесь минус один.
[01:07:50.260 --> 01:07:59.260]  Первый элемент вставляю четверку, четверку я вставляю на место сюда. Я смотрю на предыдущий элемент. Предыдущий элемент какую позицию имеет?
[01:07:59.260 --> 01:08:10.260]  У единичка какая имеет позицию? Ноль? Согласны? Сейчас подожди, вот этот пост, он соотносится только лишь с последним.
[01:08:13.260 --> 01:08:19.260]  Я понял, ты сломался. У нас есть еще, у нас очень мало времени.
[01:08:20.260 --> 01:08:26.260]  Давайте я сейчас проговорю про пост, если будет еще вопрос, мы еще одну таблицу нарисуем, хорошо?
[01:08:26.260 --> 01:08:30.260]  Ну я отпущу всех, кто понимает, или кто...
[01:08:35.260 --> 01:08:37.260]  Здесь? Здесь, да.
[01:08:37.260 --> 01:08:39.260]  Ну здесь, да.
[01:08:42.260 --> 01:08:45.260]  Три, четыре, пять, шесть, семь, действительно.
[01:08:47.260 --> 01:08:49.260]  Ну да, извините.
[01:08:51.260 --> 01:08:55.260]  Семь, шесть, пять.
[01:08:56.260 --> 01:08:59.260]  Лучше? Лучше. Хорошо.
[01:09:00.260 --> 01:09:07.260]  Что касается здесь, первое, ну вот, пири, когда я вставлял, я вставлял его вот сюда.
[01:09:08.260 --> 01:09:15.260]  Для него предыдущим являлась единичка. У единички какая позиция? Нулевая, правильно? Поэтому здесь будет ноль.
[01:09:16.260 --> 01:09:24.260]  Дальше я вставлял три, у тройку я вставлял сюда, и предыдущий стоит что? Единичка. У единички какая позиция? Нулевая.
[01:09:24.260 --> 01:09:26.260]  Нулевая.
[01:09:27.260 --> 01:09:39.260]  А дальше я смотрю на следующую итерацию. Что у нас тут происходит? У меня есть третий элемент, восемь. Восемь я вставляю сюда, предыдущий какой у нас? Третий. У тройки позиция какая? Два.
[01:09:41.260 --> 01:09:42.260]  Да, два.
[01:09:42.260 --> 01:09:49.260]  Дальше я смотрю еще ниже. Я смотрю на минус девять. Минус девять встал сюда, у него предыдущий какой?
[01:09:51.260 --> 01:09:56.260]  Минус бесконечность, это минус единица. Да, у нас вот так.
[01:09:58.260 --> 01:10:04.260]  Поехали дальше. У нас есть минус один. Минус один я вставляю сюда, предыдущий у него какой?
[01:10:06.260 --> 01:10:10.260]  Минус девять. Минус девять какой индекс имеет?
[01:10:12.260 --> 01:10:14.260]  Да, четыре.
[01:10:19.260 --> 01:10:32.260]  Какое-то число вы не вставляли. А, например, может ли быть такое, что мы какое-то число не вставили?
[01:10:43.260 --> 01:10:52.260]  Вот. Поехали дальше. Единственное, что точно не вставит, когда у нас будет одинаковый число.
[01:10:53.260 --> 01:11:00.260]  Семь, когда я вставляю у семерки, какой предыдущий элемент? Минус один. У минус один какая позиция?
[01:11:01.260 --> 01:11:10.260]  Пятая. Ну и последний я оставляю минус десять. Минус десять я вставляю в самое начало предыдущий элемент, минус бесконечность, у него позиция минус один.
[01:11:10.260 --> 01:11:17.260]  Вот я смотрю на эти позиции. Теперь смотрите, как мне понять длину максимальной подпоследовательности возрастающей?
[01:11:20.260 --> 01:11:25.260]  Максимальный небесконечный индекс будет показывать нам именно это. Вот здесь вот троечка, согласны?
[01:11:27.260 --> 01:11:37.260]  Здесь у меня стоит что? Семерка. У семерки я знаю что. Вот этот поз, видите? Вот он шестерка.
[01:11:38.260 --> 01:11:44.260]  Я говорю, что я вывожу Си, и у шестого элемента какой предыдущий?
[01:11:45.260 --> 01:11:53.260]  Четвертый, ну предыдущий пять, индекс пять. А индекс пять означает какой элемент?
[01:11:54.260 --> 01:12:03.260]  Минус один. Я перехожу по этому индексу, вижу здесь четыре. Четыре. Какой элемент?
[01:12:04.260 --> 01:12:11.260]  Минус девять. Индекс у какого элемента четыре? Минус девять.
[01:12:12.260 --> 01:12:20.260]  Перехожу в четвертый элемент, смотрю какой у него предыдущий. Минус первый, ничего, значит нет никакого предыдущего элемента.
[01:12:21.260 --> 01:12:26.260]  Вот это возрастающий подпоследствия, но наоборот. Поэтому я переворачиваю, получаю минус девять, минус один, семь.
[01:12:34.260 --> 01:12:43.260]  Исходя из поз и преф. Поз показывает нам элемент, индекс этого элемента, шесть.
[01:12:44.260 --> 01:12:47.260]  Шесть является последним индексом, согласен?
[01:12:49.260 --> 01:12:57.260]  Дальше я иду сюда. У шестерки какой предыдущий? Шестой элемент, во-первых, это семь. У шестерки какой предыдущий индекс? Пять.
[01:12:57.260 --> 01:13:05.260]  Пять имеет, ну, х пятая, это минус один. Давайте я выпишу вот так, это х.
[01:13:06.260 --> 01:13:18.260]  Шестое, это х. Пятое, это х. Четвертое, и все. Соответствие идет вот согласно этому. Да.
[01:13:27.260 --> 01:13:37.260]  А потом, что так или так или иначе, у меня уже один квадрат действий. Где у меня здесь один квадрат действий?
[01:13:38.260 --> 01:13:44.260]  Это n. Ну а, а, это итерация, ну ладно. Это итерация. Это n.
[01:13:45.260 --> 01:13:51.260]  Ну, по-моему, сюда будет очень много странных. Почему? У от н? У от н?
[01:13:51.260 --> 01:13:53.260]  Это от н?
[01:13:57.260 --> 01:13:59.260]  Это от н?
[01:14:03.260 --> 01:14:06.260]  Нет, вы строите его параллельно, сейчас покажу.
[01:14:07.260 --> 01:14:12.260]  Смотрите, что вы делаете? Да, я сейчас всех вас отпущу, все хорошо.
[01:14:14.260 --> 01:14:16.260]  Понимаю, все нормально.
[01:14:16.260 --> 01:14:20.260]  А у нас есть массив dp, у нас есть массив pos, у нас есть массив pref.
[01:14:21.260 --> 01:14:27.260]  Смотрите, вы идете по всем числам, которые у вас есть, и бинарным поиском ищете место иксытово.
[01:14:28.260 --> 01:14:33.260]  Когда вы находите это место иксытово, вы его вставляете и говорите.
[01:14:34.260 --> 01:14:41.260]  Здесь я перепутал буковку и написал p. dp житое равно аитому, это раз, то есть место, куда я вставил.
[01:14:42.260 --> 01:14:49.260]  Дальше вы говорите, что позиция житого, то есть позиция элемента, который я вставил в моем стандартном массиве, равна i.
[01:14:50.260 --> 01:14:53.260]  Я в этом элементе нахожусь, его индексы, согласны?
[01:14:54.260 --> 01:15:00.260]  А предыдущий его элемент, это тот, который стоял раньше, его индекс.
[01:15:03.260 --> 01:15:07.260]  Порисуйте, потыкайтесь чуть побольше, поймете, что происходит.
[01:15:07.260 --> 01:15:12.260]  Восстановление очень простое, когда у меня есть pos, все становится очень просто.
[01:15:13.260 --> 01:15:15.260]  Есть ли у вас вопросы?
[01:15:24.260 --> 01:15:27.260]  Хорошего всем вечера, продуктивного!
