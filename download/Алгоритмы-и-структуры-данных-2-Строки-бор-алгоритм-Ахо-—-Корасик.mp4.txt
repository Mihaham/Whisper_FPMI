[00:00.000 --> 00:21.000]  Так, мы продолжаем говорить про строки, сегодня всякие
[00:21.000 --> 00:23.720]  вариации Бора рассмотрим, Бора алгоритма Хкараси.
[00:23.720 --> 00:42.320]  Ну, определение, Бор это корневое подвешенное дерево, на ребрах которого написаны буквы из алфавита.
[00:53.720 --> 01:19.600]  Причем есть еще одно важное ограничение, что если из вершины исходят несколько ребер,
[01:19.600 --> 01:36.280]  то на них на всех должны быть попарно различные символы, то есть для любой вершины В из нее не
[01:36.280 --> 01:39.760]  исходить двух ребер, на которых написаны они те же символы.
[02:06.280 --> 02:22.960]  Так, например, давайте тут нарисую, ну вот есть какой-то корень дерева, давайте вот так обзову
[02:22.960 --> 02:29.600]  рут, из него могут быть какие-то стрелочки, какие-то ребра, на них на всех написаны попарно
[02:29.600 --> 02:37.600]  различные буквы, там не знаю, а, б, д, у, опять вот есть вершины, из них могут исходить какие-то
[02:37.600 --> 02:43.320]  ребра, но главное, что исходящие из одной вершины ребра все должны быть с попарно различными символами,
[02:43.320 --> 02:55.280]  а, т, х, здесь там тоже, например, не знаю, а, с, ну и так далее. Главное требование, что из вершины не
[02:55.280 --> 03:05.360]  может быть такого, не может быть вот такого, что есть вершина, из нее есть два ребра с одной и той же
[03:05.360 --> 03:10.040]  пометочкой, скажем, с, ни с какой фиксированной пометкой не может быть два одинаковых исходящих
[03:10.040 --> 03:21.360]  ребра. В остальном это просто дерево, на ребрах которого написаны буквы. Вот, значит, в таком
[03:21.360 --> 03:39.200]  определении давайте скажем, что такое построить бор по множеству слов. Значит, ну нам нужно построить
[03:39.200 --> 03:45.360]  такое корневое дерево, чтобы, ну давайте я множество слов пронумерую, s1, s2 и так далее,
[03:45.800 --> 03:53.760]  я хочу построить такой бор, чтобы из корня этого бора можно было все вот эти вот n слов прочитать,
[03:53.760 --> 03:58.400]  то есть мы идем сверху вниз, читаем просто по буковке, буква, буква, буква, буква, так доходим
[03:58.400 --> 04:03.920]  до какой-то вершинки и вот эта вот последовательность букв, которые мы считали, должна совпадать с одной из,
[04:03.920 --> 04:09.640]  с одним словарных слов и больше никакие другие слова не должны читаться. Ну давайте какой-нибудь
[04:09.640 --> 04:14.560]  пример нарисуем, я не буду формально здесь расписывать, например, у меня есть строчка там
[04:14.560 --> 04:31.840]  aba, есть строчка ab, есть строчка там ac, есть строчка, скажем, ct. Тогда бор для нее будет такой,
[04:31.840 --> 04:37.440]  есть некий общий корень, а затем можно его строить очень просто, значит, давайте сначала построим путь,
[04:37.440 --> 04:47.360]  по которому читается слово aba. Вот читаем aba и давайте последнюю вершину на этом пути пометим
[04:47.360 --> 04:54.960]  терминальный. Это знак того, что в этой вершине заканчивается какой-то из вот этих вот словарных
[04:54.960 --> 04:59.720]  слов, из тех слов, по которым мы строили бор, вот здесь одно из них заканчивается. Давайте такие
[04:59.720 --> 05:08.720]  вершины помечать жирным кружочком, я буду называть их терминальными. Терминальная вершина, так где
[05:08.720 --> 05:15.560]  что-то заканчивается. Ну дальше ab, понятно, вот этот путь у нас уже есть ab, мне нужно просто вот
[05:15.560 --> 05:19.920]  этой вершины пометить терминальный, сказать, что здесь опять заканчивается какое-то слово, да, вот
[05:19.920 --> 05:27.080]  это вот s2, оно в точности здесь заканчивается. Дальше скажем ac, ну понятно, здесь я буквку a могу
[05:27.080 --> 05:31.000]  прочитать, а дальше не могу, поэтому мне придется витвиться и создать новое ребро с пометкой c. И
[05:31.000 --> 05:38.320]  уже вот эту вершину пометить терминальный. Просто каждая вершина соответствующая концу какого-то
[05:38.320 --> 05:42.600]  слова, мы помечаем ее сразу жирным кружочком, говорим, что она терминальная. Ну и наконец,
[05:42.600 --> 05:51.560]  если мы хотим прочитать снова ct из корня, то нам придется оба эти ребра добавлять и по c и
[05:51.560 --> 05:57.360]  по t, не нужно добавить новый ребро и сказать, что это вершина терминальная. Вот, то есть по сути
[05:57.360 --> 06:03.520]  алгоритм построения бора по данному мнению слов очень простой. Мы идем и пытаемся как можно больше
[06:03.520 --> 06:09.200]  первых символов сопоставить с тем, что уже находится в боре, да, вот как здесь мы ab, мы шли по тем
[06:09.200 --> 06:13.200]  ребрам, которые, ну собственно есть, да, сначала есть ребро a, потом есть ребро b, мы вот здесь
[06:13.200 --> 06:17.560]  заканчиваемся. Когда мы строили ac, мы сначала прошлись по ребру a, которая уже была в боре,
[06:17.560 --> 06:22.040]  потом рибрации не было, его пришлось построить. Ну также в общем случае мы идем как можно дольше
[06:22.040 --> 06:28.040]  сопоставляя ребра с теми, которые уже есть, а оставшийся кусочек строим, да, с какого-то момента
[06:28.040 --> 06:33.800]  мне придется ветвиться в другую сторону и здесь будет такая длинная длинный путь, отвечающий
[06:33.800 --> 06:39.160]  суффиксу слова, который мы еще не прочитали. Вот, и все концы вот этих путей помечаем терминальные
[06:39.160 --> 06:46.840]  вершины. Так, это вроде понятно. Ну здесь как раз соблюдается свойство, что из вершины нет разных
[06:46.840 --> 06:51.640]  букв, да, исходящих, вот такого, вот такого нету, потому что если бы было, да, если нам в какой-то
[06:51.640 --> 06:58.760]  момент нужно здесь написать c, то мы просто прошлись здесь вниз и ну это, это ребро нет смысла заводить,
[06:58.760 --> 07:04.960]  потому что можно просто прочитать эту букву здесь, да, нет, нет смысла заводить новое ребро. Так, хорошо.
[07:04.960 --> 07:11.640]  Значит, ну давайте тогда поговорим еще о методах, как можно хранить этот самый борт.
[07:11.640 --> 07:27.840]  Способ хранения бора. Ну здесь понятно, что как бы естественно для каждой вершинкой завести некую
[07:27.840 --> 07:35.040]  структуру данных, да, каждый вот этот узел, это некая там структурка, но при этом есть несколько
[07:35.040 --> 07:40.160]  возможных вариантов, как именно мы храним множество исходящих ребер, да, там, как мы
[07:40.160 --> 07:45.960]  сопоставляем для каждой, для каждого символа алфавита ребро, куда, куда ведется, точнее конец
[07:45.960 --> 07:51.360]  ребра, куда ведет этот символ. Ну здесь есть три классических способа. Первый это, значит,
[07:51.360 --> 08:06.120]  имеется в виду, как храним переходы, как храним переходы по буквам. Значит, первый способ это
[08:06.120 --> 08:15.640]  просто массив размера Сигмы. Просто для каждого символа алфавита мы храним либо там какой-нибудь
[08:15.640 --> 08:20.960]  минус-одинечку, как знак того, что нет такого ребра, либо номер вершины или там указатель,
[08:20.960 --> 08:28.240]  куда ссылается, куда мы попадем, если прочитаем эту букву. Например, в массиве размера Сигма по
[08:28.240 --> 08:35.840]  номеру буковки С будет находиться ссылка на вот эту вершину. Отсюда будет вести ссылка сюда. Да,
[08:35.840 --> 08:43.920]  конечно, сигма алфавит всегда у нас. Да, да, да, в каждой вершине, но я это не прописал, но сказал,
[08:43.920 --> 08:50.000]  у нас есть своя структура для каждой вершины, структ нод какой-нибудь, да, и так вот в каждой,
[08:50.000 --> 08:54.720]  в каждой точке, в каждом узле у нас своя нода, своя структурка. И внутри каждой структуры мы
[08:55.000 --> 09:00.720]  хотим понять, как именно мы храним множество переходов. И вот это вот то, что я обсуждаю,
[09:00.720 --> 09:09.520]  это то, что находится внутри этой ноды для каждого узла нашего бора. Да, в каждой вершине. Так,
[09:09.520 --> 09:23.400]  сигма это алфавит. Второе, это, ну, какое-нибудь дерево поиска. Ну, для наших целей будет хватать
[09:23.400 --> 09:33.480]  стд мап. Просто мап, скажем, из чар в нод-звездочка или в инт, если у нас будут вершины
[09:34.040 --> 09:40.680]  каждому символу сопоставляет то, куда мы попадем, если прочитаем этот символ, либо если этого символа
[09:40.680 --> 09:45.800]  нет, да, если нет, скажем, вот здесь вот нет ребра, исходящего по букве А, значит просто, ну,
[09:45.800 --> 09:51.120]  там нет такого элемента, да, в этой мапе нет такого ключа. И третье, это какая-нибудь хэштаблица.
[09:51.120 --> 10:00.600]  Про хэштаблицы мы с вами немножко говорили в прошлом семестре, когда нам нужно поддерживать, да,
[10:00.600 --> 10:06.360]  какое-нибудь, какое-то множество, добавлять туда ключи и удалять, то в принципе хэштаблица тоже
[10:06.360 --> 10:14.400]  с этой задачей справляется. Особенно, ну, когда у нас вот так не очень много данных. Вот, значит,
[10:14.400 --> 10:23.840]  в чем преимущество всех методов. Так, так, так, ну, давайте, давайте нарезать такую тупую табличку.
[10:23.840 --> 10:39.040]  Значит, массив, мап и хэштаблица. Нам важны две операции. Первая, это, ну, грубо говоря, перейти по
[10:39.040 --> 10:56.280]  ребру. Вторая, это создать переход, ну, то есть создать ребро, да, завести новый переход. Ну,
[10:56.280 --> 11:11.520]  и последняя, это создать вершину. Сейчас поясню, что имеется в виду. Смотрите, перейти по ребру,
[11:11.520 --> 11:18.040]  это когда я стою в вершине в какой-то В, и у меня есть некое множество ребер, а мне говорят,
[11:18.040 --> 11:23.280]  что мне нужно сейчас прочитать там букву С. И, соответственно, перейти по ребру, это значит понять,
[11:23.280 --> 11:27.160]  есть ли переход по букве С, и если есть, сделать переход, да, то есть найти среди вот этих вот
[11:27.160 --> 11:34.360]  исходящих ребер то, которое помечено буква в кольце, и понять, куда оно ведет. Вот, что такое перейти по
[11:34.360 --> 11:41.280]  ребру. Ну, в массиве это, понятно, занимает от единиц времени. В мапе от лог К, где К это количество
[11:41.280 --> 11:55.600]  исходящих ребер. Вот, ну хэш таблицы, это будет занимать от единицы в среднем, ну, точнее,
[11:55.600 --> 12:02.120]  амортизированного в среднем. Да, потому что у нас там, во-первых, есть случайность хэш таблицы,
[12:02.120 --> 12:07.520]  поэтому у нас оценки все только в среднем. Во-вторых, там есть амортизация, потому что пост,
[12:07.520 --> 12:11.240]  когда насыщается хэш таблица, мне нужно сделать перехэширование, завести таблицу размером
[12:11.240 --> 12:15.160]  в два раза больше, поэтому там еще появляется амортизационная оценка. То есть, каждое конкретно
[12:15.160 --> 12:20.600]  может работать долго, но суммарно в среднем можно считать, что каждый работает за единичку. Дальше,
[12:20.600 --> 12:25.440]  ну, создать ребро это в случае, если перейти по ребру не удалось, а надо, да, мне нужно было
[12:25.440 --> 12:30.280]  прочитать какую-то букву в куце, такого перехода не было, значит, нужно его создать. Ну, в массиве
[12:30.280 --> 12:36.200]  это опять-таки работает от единицы, мне нужно просто в массиве длины сигма там, да, взять элемент
[12:36.200 --> 12:42.440]  с номером c и провести ребро в нужную только что образовавшуюся вершинку. В мапе это вставка
[12:42.440 --> 12:49.760]  ключа, да, по значению, за логарифом работает, в хэш таблице опять единица в среднем, амортизированная
[12:49.760 --> 12:57.600]  единица в среднем, потому что это просто, ну, инсерс хэш таблицы. Вот, а создать вершину это
[12:57.600 --> 13:02.720]  подразумевается, что вот, когда, когда у нас нужно было прочитать букву в куце, а здесь ее не было,
[13:02.720 --> 13:08.400]  тогда нам нужно завести новое ребро, пометить его буковкой c и завести вот здесь вершину,
[13:08.400 --> 13:14.160]  соответственно, создать новую структуру здесь, создать новый нод здесь. Вопрос, сколько нам
[13:14.160 --> 13:20.360]  нужно времени, чтобы создать новый нод. В случае с массивом от сигма, ну, от мощности сигма,
[13:20.360 --> 13:25.760]  потому что мне нужно завести массив, да, на каждый символ алфавита, это занимает вот столько
[13:25.760 --> 13:31.760]  времени и столько же памяти. Ну, а с мапой хэш таблицы все проще, здесь просто чисто единицы,
[13:31.760 --> 13:40.360]  потому что пустой мап, пустая хэш таблица создаются за от единицы. Так, вопросы есть? Вот здесь.
[13:40.360 --> 13:49.720]  Ну и вывод какой? Вывод зависит, собственно, от того, какие у вас есть ресурсы. Если у вас есть,
[13:49.720 --> 13:58.680]  так, да, я бы сказал так, если у вас есть много памяти, то предпочтительный вариант это массив,
[13:58.680 --> 14:05.520]  потому что все операции с проходом по ребру выполняются за единицу, ну, а это просто создание,
[14:05.520 --> 14:10.560]  выделение куска памяти работает довольно быстро. Поэтому, если у вас есть память на то, чтобы,
[14:10.560 --> 14:16.200]  если у вас достаточно много оперативки, чтобы для каждой вершины хранить вот прям столько значений
[14:16.200 --> 14:21.920]  и создавать их каждый раз, когда создаете вершину, то предпочтительный вариант это массив, если
[14:21.920 --> 14:35.920]  доступно много памяти. Если же с памятью проблемы, то лучше использовать мап, время ухудшится не очень
[14:35.920 --> 14:42.360]  сильно, потому что, ну, здесь была единица, остался всего лишь логарифм, где k не больше, чем стигма. Да,
[14:42.360 --> 14:46.400]  мы понимаем, что число исходящих ребер не больше, чем размер алфавита, поэтому эти логарифмы будут,
[14:46.400 --> 14:50.760]  ну, от довольно небольшого числа, в принципе, тоже поправка будет не очень большой. Значит, это хорошо,
[14:50.760 --> 15:03.920]  если, ну, мало памяти, мало памяти. Вот, хэштаблица, в принципе, хороша всегда, но нужно помнить вот про вот
[15:03.920 --> 15:08.760]  эти вот. Во-первых, оно не очень просто пишется, если что-то самописное делаете. Во-вторых,
[15:08.760 --> 15:14.440]  здесь все оценки, они в среднем и амортизированные, на это надо тоже закладываться. Да, понимаю,
[15:14.440 --> 15:19.880]  что с какой-то вероятностью у вас алгоритм может работать долго. Давайте так я напишу. Хорошо,
[15:19.880 --> 15:29.640]  если не требуется гарантировать, что оно всегда работает быстро. Если не требуется эффективность
[15:29.640 --> 15:42.360]  в 100% случаев. Ну, это вот стандартные наши приколы с вероятностными алгоритмами. Они
[15:42.360 --> 15:48.600]  работают почти всегда хорошо, быстро, но иногда там, не знаю, раз в год может быть такое, что вы
[15:48.600 --> 15:52.160]  плохо подобрали хэши, у вас все вырождается там. Ну, здесь не вырождется, но, короче,
[15:52.160 --> 15:57.240]  здесь будет ООК везде. В худшем случае вам нужно пройти всю хэштаблицу, чтобы понять,
[15:57.240 --> 16:03.000]  есть ключ или нет. И здесь тоже ООК. Из-за того, что вы там как-то плохо выбрали хэш, у вас может
[16:03.000 --> 16:08.800]  быть вообще время работы здесь, короче, вырождаться. Не очень сильно, но все-таки
[16:08.800 --> 16:13.760]  иногда такое бывает. Если вы хотите написать систему, которая всегда работает безупречно,
[16:13.760 --> 16:19.320]  никогда не зависает, то, наверное, это не для вас. А если там, не знаю, раз в годик можно и полагать
[16:19.320 --> 16:25.160]  немножко, то, пожалуйста, хэштаблица в остальные 355 дней в году, она будет работать быстрее,
[16:25.160 --> 16:32.200]  чем все остальное. Ну, конечно, хэштаблица, она же как работает? Она заводит массив размера
[16:32.200 --> 16:38.760]  примерно в два раза больше, чем число ключей, там максимум 2К. И чтобы проверить, есть ли там
[16:38.760 --> 16:47.400]  переход, она по сути просто с какого-то момента идет и пытается его здесь найти до первой пустой
[16:47.400 --> 16:58.480]  клетки. В худшем случае она пройдет всю таблицу, то есть максимум отка. Да, конечно, ну, собственно,
[16:58.480 --> 17:03.800]  вот вы правы, да-да-да, конечно. Здесь я имел в виду, как бы, если есть много памяти, и можно в
[17:03.800 --> 17:08.800]  каком-то смысле эффективно ее выделять. Да, если алфавит большой, там, не знаю, тысячи,
[17:08.800 --> 17:12.800]  десятки тысяч символов, то, наверное, не очень получится ее просто выделять, ну и вам просто
[17:12.800 --> 17:32.880]  памяти даже не хватит, не говоря про время. Сейчас, секунду. Так, вот оно как, а, это количество
[17:32.880 --> 17:39.440]  исходящих ребер из вершины. Ну, и с той, в которой мы стоим, вот если мы находимся в вершине В,
[17:39.440 --> 17:46.520]  и нас спрашивают, есть ли переход по букве С, при этом из нее исходит К ребер, то тогда ответ
[17:46.520 --> 17:52.080]  на этот запрос работает за единицу в случае массива, ло К в случае мапа и в среднем за
[17:52.080 --> 17:55.840]  амортизированную единицу в случае х-таблицы. Ну, это вот как мы стоим в вершине, нам поступает
[17:55.840 --> 18:10.840]  запрос какая-то параметра вершины. Да. Ну, не совсем, мы скорее для каждой буквы говорим,
[18:10.840 --> 18:15.360]  что нет перехода, да, то есть для каждой из сигма букв мы говорим, нет перехода по А,
[18:15.360 --> 18:20.160]  нет перехода по B, нет перехода по C и так далее. То есть мы, я сейчас буду писать код для массива,
[18:20.160 --> 18:24.880]  там будет типа мы создаем массив, заполненный минусы единицами, как знак того, что нет перехода.
[18:24.880 --> 18:29.160]  Ну, то есть мы не можем создать пустой массив и потом вставить там по букве С, это уже мап,
[18:29.160 --> 18:35.840]  по сути. Мы скорее для каждой буквы говорим, что нет перехода. Вот, ну и давайте, значит,
[18:35.840 --> 18:53.680]  алгоритм построения Бора, ну, на массиве, на массивах. Сейчас напишу простой код,
[18:53.680 --> 19:01.560]  и пойдем дальше. Значит, что мне нужно от вершины? Мне нужен список переходов,
[19:01.560 --> 19:10.640]  давайте я назову этот массив 2, он будет у меня размера сигма, да, где сигма это, ну,
[19:10.640 --> 19:19.760]  размер алфавита. И мне нужен флаг терминальности, bull term, я вот так назову. Терминальная или
[19:19.760 --> 19:25.600]  не терминальная вершина, да, заканчивается в ней кто-то или нет. Значит, ну, конструктор
[19:25.600 --> 19:32.520]  по умолчанию будет такой, мы создаем вершину без остатейших ребер и по умолчанию не терминальную.
[19:32.520 --> 19:38.720]  Для этого мне нужно вот здесь вот все значения в массиве 2 заполнить каким-то фиктивным числом,
[19:38.720 --> 19:51.960]  я привык это делать минус 1, и это можно писать так, memset tu-1 sizeof tu. Еще раз?
[19:51.960 --> 20:05.240]  Long звездочка? А, нам достаточно интов, у нас будут все вершины пронумерованы сквозной
[20:05.240 --> 20:08.240]  нумерацией, нам даже не нужны вот эти ноут звездочки, у нас ничего удаляться не будет,
[20:08.240 --> 20:15.840]  поэтому указатели не нужны. Ну, то есть, да, да, иногда, конечно, бывают задачи, где нужно удалять
[20:15.840 --> 20:19.880]  вершины, но это редкость скорее, поэтому всегда достаточно интов, ну, зачастую достаточно интов.
[20:19.880 --> 20:22.120]  И по умолчанию вершина не терминальная.
[20:35.240 --> 20:48.720]  Так, дальше, я завожу вектор вершин, который назову, ну, скажем, T. По-английски BOR это,
[20:48.720 --> 21:01.160]  кстати, try, поэтому T. Ну и процедура добавления некого слова в наш BOR.
[21:01.160 --> 21:14.520]  Add какой-нибудь строчку S, const string S. Значит, приняли строчку, хотим ее добавить в BOR.
[21:14.520 --> 21:28.880]  Стартуем в корне, считаем, что в дереве всегда есть, ну, в этом BOR всегда есть корень, да, то есть,
[21:28.880 --> 21:35.840]  где-то мы еще там. Ну, давайте, давайте проверочку здесь сделаем. Момент. Значит,
[21:35.840 --> 21:47.000]  если BOR пусто, его нужно создать, нужно просто в него корень положить, это просто T pushback нод.
[21:47.000 --> 21:59.320]  Если, если у нас никого не было, вот это список вершин, да, просто перечтение вершин,
[21:59.320 --> 22:04.400]  наливая первые, вторые и так далее, описание всех вершинок. Если это пустой BOR, то мне нужно
[22:04.400 --> 22:11.040]  сначала создать корень, я его просто добавляю pushback вершины, ну, вот, как бы, без начинки, да,
[22:11.040 --> 22:19.680]  вот, по умолчанию запомнил. Дальше я встаю в корень, говорю, что V это корень, потом мне
[22:19.680 --> 22:23.680]  нужно идти по строке S и прочитать как можно больше первых его символов, которые, ну,
[22:23.680 --> 22:33.760]  по которым есть переход в V. То есть, я иду по строке S, так, и меньше S точка size.
[22:33.760 --> 22:50.160]  Значит, дальше, если есть переход из V по S item, то я его делаю. Если нет,
[22:50.160 --> 22:58.440]  тогда нужно его будет создавать. Давайте, напишу так, если нет перехода, то есть,
[22:58.440 --> 23:07.240]  T в это, точка tu от, давайте, я буду считать, что у меня алфавит, это маленькие латинские буквы,
[23:07.240 --> 23:22.680]  тогда, соответственно, номер буквы в массиве, это просто вычитание из чара символа A. Поэтому
[23:22.680 --> 23:29.560]  здесь я пишу S и T минус A, минус символ A. Так вот, если нет перехода по такому символу,
[23:29.560 --> 23:35.000]  то есть, если здесь минус единица, то значение, которое по умолчанию там стояло, тогда нужно
[23:35.000 --> 23:53.080]  этот переход создать. Ну, это можно сделать так. T точка size и T pushback вершины без значинки.
[23:53.080 --> 24:07.000]  То есть, перехода не было, я его создал, говорю, что переход ведет в вершину вот с таким номером,
[24:07.000 --> 24:14.200]  а дальше сразу создаю вершину с таким номером с помощью pushback вершины без значинки. Скажем,
[24:14.200 --> 24:19.880]  если в боре было всего 5 вершин с номерами от 0 до 4, тогда, соответственно, я создаю вершину,
[24:19.880 --> 24:25.400]  говорю, что в нее ссылаются под номером 5, и добавляю пятую вершину в 0 индексация, пятую
[24:25.400 --> 24:33.680]  вершину без значинки. Просто завожу ребро по нужному мне символу S и T. Вот, это в случае,
[24:33.680 --> 24:37.640]  если перехода не было, я его создал. А дальше я просто спускаюсь по этому переходу.
[24:37.640 --> 24:54.160]  Если перехода не было, я его создал. Если был, он и так остается. И в любом случае я должен
[24:54.160 --> 24:59.320]  сделать переход, чтобы пройти вот этот путь, мне нужно эту букву прочитать из текущей вершины.
[24:59.320 --> 25:06.640]  То есть, вместо V написать TV to вот это вот S и T. Все, и в конце, после этого фора мы прочитали всю
[25:06.640 --> 25:10.800]  строчку S. Там, где надо было, разветвились и создали новый путь. В конце нужно не
[25:10.800 --> 25:34.480]  забыть пометить эту вершину терминальной. Все. Вопросы?
[25:36.640 --> 25:48.120]  Тогда я в асимптотику. Асимптотика добавления строки S, это у нас длина S на мощность алфавита.
[25:48.120 --> 25:52.560]  В худшем случае, потому что в худшем случае мне придется создать вот столько вершин,
[25:52.560 --> 25:58.120]  в каждой из которых вот столько элементов массива. То есть, вот столько времени,
[25:58.120 --> 26:02.880]  столько памяти в худшем случае тратится на создание пути, отвечающего некоторому слову.
[26:06.640 --> 26:10.120]  Задача.
[26:23.120 --> 26:30.320]  Нужно научиться поддерживать множество целых чисел S с двумя типами запросов. Первый тип
[26:30.320 --> 26:44.760]  запроса это вставить X в множество, то есть добавить X в S. Второе, ну это давайте просто find X,
[26:44.760 --> 27:06.160]  проверить, есть ли X в S. Как решать с помощью Бора? Что? Да, например так, можно просто вот это X
[27:06.160 --> 27:14.400]  воспринимать как строку над алфавитом 0, 1 и так далее, 9. При инсерте, соответственно,
[27:14.400 --> 27:19.320]  создать Бор над алфавитом из десяти символов, при инсерте нужно просто добавлять эту строчку в
[27:19.320 --> 27:26.120]  Бор, чтобы проверить, есть ли это число в Боре в множестве или нет. Нужно пройти опять вот этот
[27:26.120 --> 27:31.040]  путь, который отвечает слову X. Если мы в конце оказались в терминальной вершинке, значит это слово
[27:31.040 --> 27:54.920]  есть в нашем множестве. Да. А мы их храним. Еще раз.
[27:54.920 --> 28:06.680]  В каком-то смысле да, сейчас я про удаление тоже скажу. Давайте запишу. Бор над алфавитом от 0 до 9,
[28:06.680 --> 28:28.520]  инсерт это добавить X как строку в Бор, find это пройти путь отвечающий X,
[28:28.520 --> 28:44.800]  ну и проверить стоит там терминальность или нет. Проверить терминальность. Да,
[28:44.800 --> 28:50.480]  значит прозвучало справедливое замечание, что в этом случае можно и рейс тоже делать,
[28:50.480 --> 28:56.800]  то есть удалять число из множества тоже можно. Для этого нужно просто опять прочитать X в нашем
[28:56.800 --> 29:03.040]  Боре и заменить терминальность на нетерминальность. То есть если X было в множестве, а нужно его
[29:03.040 --> 29:08.480]  удалить, то нужно его опять найти, прочитать вот этот путь от корня до вершины соответствующей
[29:08.480 --> 29:14.800]  концу X и снять терминальность. То есть если там был терм равен true, то нужно его заменить на false.
[29:14.800 --> 29:24.680]  Это удаление. То есть в принципе рейс тоже здесь можно сделать. Единственный как бы недостаток в том,
[29:24.680 --> 29:30.840]  что у вас, ну если например там вы сначала добавили 10 чисел, а потом удалили 10 чисел,
[29:30.840 --> 29:37.680]  то у вас как бы будет какой-то Бор с десятью путями, но здесь все вершины будут равны,
[29:37.680 --> 29:41.480]  ну как бы все вершины нетерминальные. В каком-то смысле вы храните просто мусор,
[29:41.480 --> 29:48.280]  который ничему не соответствует. И у вас тогда как бы размер вашей структуры не пропорционален,
[29:48.280 --> 30:03.160]  а как бы даже больше, чем количество элементов в S. Ну да, да, да. Тут можно по-всякому это делать,
[30:03.160 --> 30:09.520]  действительно. Например, если мы, да, в общем вы правильно сказали, можно просто в каждой вершине
[30:09.520 --> 30:13.760]  хранить сколько есть терминальных в поддереве, вот здесь вот для этой вершины мы скажем храним
[30:13.760 --> 30:18.200]  сколько здесь терминальных. Если мы в какой-то момент удаляем обе эти терминальные, то мы
[30:18.200 --> 30:22.280]  понимаем, что тогда у этой вершины в поддереве ноль терминальных, и мы как бы ее можем просто
[30:22.280 --> 30:42.680]  удалить. Все вот эти пути автоматически удаляются. Ну это одно и то же по сути,
[30:43.640 --> 30:48.320]  как мы это реализуем? Мы все равно сначала доходим до конца, удаляем здесь терминальность,
[30:48.320 --> 30:59.360]  если у нас нет детей, то мы удаляем эту вершину и идем вверх, пока не дойдем до вершины. Да,
[30:59.360 --> 31:10.640]  есть сын, да. Поэтому удаление тоже как-то можно сделать, но обычно это даже не требуется. Так,
[31:10.640 --> 31:17.880]  что-то еще есть вопросы какие-то? Хорошо, ну тогда вроде сбором разобрались.
[31:27.480 --> 31:31.520]  Дальше переходим к алгоритму Ахкарасик.
[31:40.640 --> 31:51.560]  Задача, которую мы будем стремиться решать такая, дано множество стоварных слов, дано множество
[31:51.560 --> 32:09.880]  слов С1 и так далее, СН, дано текст Т. Ну и скажем в одной вариации нам нужно сложить,
[32:09.880 --> 32:18.600]  узнать сколько суммарно есть вхождений всех вот этих слов в строчку Т. Найти суммарное
[32:18.600 --> 32:32.160]  количество вхождений всех строк с первой по н-ую текст Т. То есть, грубо говоря,
[32:32.160 --> 32:36.640]  для каждой узнать и все сложить и вывести это как одно число. Это одна постановка,
[32:36.640 --> 32:43.800]  вторая постановка будет такая, задача штриха я назову. Все то же самое, только нужно вывести
[32:43.800 --> 33:00.680]  все вхождения, вывести все вхождения вот этих наших строчек Т. Будьте здоровы.
[33:00.680 --> 33:10.000]  Обычно вот эти слова, которые мы будем искать в тексте, мы будем называть словарные слова,
[33:10.000 --> 33:16.720]  в том смысле, что есть некий словарик вот из этих слов, да, есть какое-то множество слов,
[33:16.720 --> 33:25.160]  которые мы будем называть словарем, и мы ищем их вхождение в некий длинный текст Т. Не знаю,
[33:25.160 --> 33:30.800]  зачем, но, например, там мы составляем контрольную по русскому языку, у нас есть список слов,
[33:30.800 --> 33:34.720]  ну реально словарных, да, которые там надо знать, как пишутся, и мы проверяем, как часто они
[33:34.720 --> 33:39.280]  встречаются в некотором литературном тексте. Нам нужно вывести все примеры их использования,
[33:39.280 --> 33:44.360]  увидеть, где они в тексте появляются. Вот, например, так, да, есть множество слов, есть текст,
[33:44.360 --> 33:50.320]  нужно найти все вхождения в этот текст. Значит, ну, какой-нибудь здесь там, понятно, есть совсем
[33:50.320 --> 33:54.480]  тривиальное решение, можно для каждой строки решать эту задачу независимо с помощью, например,
[33:54.480 --> 33:58.240]  алгоритма Кнута Морриса Прата, который мы на прошлой лекции разбирали. Например,
[33:58.240 --> 34:02.680]  можем построить вот такую строчку, посчитать у него префикс-функцию и тем самым найти все
[34:02.680 --> 34:11.120]  вхождения с, и, т, в, т. А дальше там префикс или z-функция, кому что приятнее, префикс или z-функция,
[34:11.120 --> 34:21.320]  и на прошлом деле мы уже учились находить все вхождения вот этого сюда, но это работает за
[34:21.320 --> 34:30.680]  вот столько для каждого и, и если у нас этих строк много, то у нас, значит, когда я просуммирую
[34:30.680 --> 34:38.040]  все вот эти симптотики по всем и, у меня получится, ну, понятное дело, сумма длин всех строк s,
[34:38.040 --> 34:45.720]  но зато перед t еще будет множитель n, плюс n на t, то есть я как бы независимо ищу вхождения
[34:45.720 --> 34:49.320]  всех с, и, т, в, т, и поэтому здесь возникает вот такой множитель. В случае, если n большой,
[34:49.320 --> 34:54.440]  это как бы убийственная симптотика, и, собственно, вот от этого множителя мы хотели бы избавиться,
[34:54.440 --> 34:59.560]  что у нас все-таки не независимо каждая строка пытается попасть в t, а все вместе, и мы их все
[34:59.560 --> 35:02.160]  вместе пытаемся туда уместить, и понять, где они там лежат.
[35:19.880 --> 35:24.120]  Так, ну, первое, что мы сделаем для решения обеих задач, это, конечно, построим бор,
[35:24.240 --> 35:37.400]  помножить условия с 1, так далее, с n. Построим бор по вот этим нашим словам на словам.
[35:37.400 --> 35:55.800]  Так, давайте я такое даже не столько определение, сколько обозначение скажу. Я буду говорить,
[35:55.800 --> 36:01.680]  что строка есть в боре, если ее можно прочитать из корня, то есть вот вы встаете в корень,
[36:01.680 --> 36:06.640]  по буковке эту строку читаете и заканчиваетесь в вершине, не обязательно в терминале,
[36:06.640 --> 36:10.520]  но в какой-то вершине. То есть ни в какой момент вы не пытаетесь прочитать букву,
[36:10.520 --> 36:26.480]  которой нет, которого ребра нет. Будем говорить, что слово, какое-то s, есть в боре,
[36:26.480 --> 36:48.200]  если его можно прочитать из корня. Если его можно прочитать из корня. То есть мы встаем в корень,
[36:48.200 --> 36:54.640]  переходим по ребрам, отвечающим буквам строки s, и каждый раз этот переход можно сделать. То есть
[36:54.640 --> 36:58.720]  всегда есть такой переход. В конце мы заканчиваемся в какой-то вершине. Она не обязательно,
[36:58.720 --> 37:04.680]  повторюсь, не обязательно терминальная, просто какая-то вершина. Например, если есть вот такой
[37:04.680 --> 37:21.920]  какой-нибудь бор, и вот эти вот вершины помечены терминальными, то какие слова есть в боре? Есть
[37:21.920 --> 37:29.320]  в боре. Ну, во-первых, конечно пустое слово, эпсион, всегда есть в боре, потому что это просто
[37:29.320 --> 37:34.240]  стояние в корне, ничего читать не надо, мы уже этот эпсион прочитали. Ну, дальше что? Есть a,
[37:34.240 --> 37:50.680]  есть ab, есть ad, есть abc, abe, f и fg. Это множество слов, которые есть в боре. Окей? Скажите,
[37:51.000 --> 37:55.160]  характеристическое свойство слов, которые есть в боре относительно вот этого набора строк,
[37:55.160 --> 38:04.560]  s1 и так далее. Конечно, да, просто множество префиксов словарных слов. Множество тех префиксов
[38:04.560 --> 38:19.960]  всех словарных слов. Вот, мне просто будет короче говорить словосочетание есть в боре,
[38:20.040 --> 38:44.480]  чем префикс какого-то словарного слова. Дальше. Дальше, дальше, дальше. Дальше мне нужно
[38:44.480 --> 38:51.400]  отождествить вершины и слова. Значит, чтобы немножко формальнее это сделать, смотрите,
[38:51.400 --> 38:55.840]  у меня вообще говорят, да, все вот эти вот узлы это какие-то ноды, множество вершин,
[38:55.840 --> 39:03.000]  ну, вершины и множество вершин. Я хочу отождествить вершины с путями, которые до них ведут. То есть,
[39:03.000 --> 39:08.600]  когда я пишу вершина v, я одновременно имею в виду и точку, да, то есть какой-то структ нод в
[39:08.600 --> 39:16.840]  нашем боре. И в то же время путь, который ведет от корня до этой самой вершины v. Существует
[39:16.840 --> 39:33.880]  однозначное сопоставление вершин бора и множество слов, которые есть в боре.
[39:38.600 --> 39:44.360]  То есть, то, что можно прочитать из корня, то, что можно прочитать из корня,
[39:44.360 --> 39:50.840]  заканчивается в какой-то вершине. И всюду дальше, когда я пишу v, я могу подразумевать,
[39:50.840 --> 39:55.880]  как вершину, да, там скажем номер вершины в боре, так и в то же время всю вот эту строчку целиком,
[39:55.880 --> 40:00.640]  потому что между ними есть тривиальная объекция, да, каждое слово ведет в некую вершину и, наоборот,
[40:00.640 --> 40:05.360]  по вершине восстановляется слово, которое в нее ведет. Поэтому я сейчас буду перемешивать номер
[40:05.360 --> 40:15.160]  вершины и строку, отвечающую этой вершине. Так, вот, и, значит, ведя все эти предварительные
[40:15.160 --> 40:21.360]  обозначения и условности, я могу вести определение. Значит, определение линк от v,
[40:21.360 --> 40:38.280]  так называемая суффиксная ссылка для вершины v, это самый длинный собственный суффикс v,
[40:38.280 --> 41:03.520]  который есть в боре. Самый длинный собственный суффикс v, который есть в боре. Вот, и здесь,
[41:03.520 --> 41:09.600]  пожалуйста, я уже смешиваю строки и вершины, потому что, что такое суффикс v? Ну, конечно,
[41:09.600 --> 41:14.280]  суффикс не вершины, а строки, отвечающие вершине, да, и в то же время здесь написано,
[41:14.280 --> 41:20.320]  то есть как бы вот v, она же одновременно отвечает некоторой строке. Я рассматриваю все ее собственные
[41:20.320 --> 41:25.360]  суффиксы, то есть суффиксы, отличные от всей строки, в порядке убывания длины. Сначала этот,
[41:25.360 --> 41:30.120]  потом этот, потом этот, да, все такие суффиксы рассматриваю. Мне нужен из них самый длинный,
[41:30.120 --> 41:34.240]  который можно прочитать из корня, который есть в боре. Скажем, вот эти два было нельзя,
[41:34.240 --> 41:38.880]  а этот можно. Значит, линк от v будет вести в строку, точнее вершину, отвечающую вот этой
[41:38.880 --> 41:44.240]  строке. Среди всех суффиксов мы оставляем самый длинный, который можно прочитать в боре.
[41:44.240 --> 42:01.440]  Ну не столько путь, сколько последовательность букв написана
[42:01.440 --> 42:05.600]  этом пути. Как слово мы и мы его воспринимаем. Давайте пример какой-нибудь нарисую.
[42:05.600 --> 42:23.640]  Ну вот так, например. Вот пусть v это эта вершина. Договорившись вот об этом, v это не только вершина,
[42:23.640 --> 42:29.760]  но и строка a, b, c, a. Да, есть биекция между словами, которые есть в боре, и вершинами,
[42:29.760 --> 42:36.160]  поэтому v это в частности вот это вот слово. Давайте перебрать все собственные суффиксы этой
[42:36.160 --> 42:41.400]  строки и найдем какой из них самый длинный есть в боре. Ну a, b, c, a это не собственный суффикс,
[42:41.400 --> 42:46.400]  это вся строка, ее брать нельзя. b, c, a прочитать из корня нельзя, нет даже первого перехода по
[42:46.400 --> 42:53.360]  букве b, а вот c, a уже можно. Вот он, переход c, a. Поэтому суффиксная ссылка от v будет вести вот
[42:53.360 --> 43:10.600]  сюда. Линк от v будет равно этой вершинке. Окей? Ну и тогда второе определение. go vc это,
[43:10.600 --> 43:25.840]  но никак не называется, это самый длинный, самый длинный суффикс, строки v плюс c,
[43:25.840 --> 43:42.880]  которые есть в боре. Да. Нет, между всеми вершинами, между всеми вершинами и всеми словами,
[43:42.880 --> 43:53.880]  которые есть в боре. Ну как вот здесь, например, вот это это epsilon, вот это это a, вот ab, это abc и
[43:53.880 --> 44:16.840]  так далее. Symbol, v это вершина, вершины, t элемент sigma, т.е. t это один символ. Вот. Что здесь написано?
[44:16.840 --> 44:22.960]  Есть некий путь до вершины v, соответственно, отвечающий этому пути некая строка, потом я хочу
[44:22.960 --> 44:27.640]  как бы в конце этой строки, да, вот она строка v, я ее написал сверху вниз, хочу как бы дописать
[44:27.640 --> 44:33.960]  c и найти самый длинный суффикс такой строки, которую можно просчитать в боре. В идеале,
[44:33.960 --> 44:41.360]  прям в лучшем случае, вся эта строка и будет читаема из корня. В случае, если из v есть переход
[44:41.360 --> 44:47.720]  по букве c, вот если здесь есть переход по букве c, тогда go то же самое, что и tu. Переход просто
[44:47.720 --> 44:54.240]  из вершины v по букве c. Если он есть, тогда самый длинный суффикс такой вот строки, находящейся в
[44:54.240 --> 45:00.160]  боре, это сама строка v плюс c. Если для такого перехода нет, если, к сожалению, в боре нет
[45:00.160 --> 45:04.840]  такого ребра, то это что-то более интересно. Нужно сколько-то первых символов отбросить и взять
[45:04.840 --> 45:09.920]  самый длинный из оставшихся суффиксов, который можно было бы просчитать из корня. Собственно,
[45:09.920 --> 45:13.680]  определение здесь написано. Самый длинный вот суффикс такой строки, который есть в боре,
[45:13.680 --> 45:14.960]  который можно просчитать из корня.
[45:43.680 --> 46:01.880]  Ну и, соответственно, после этого алгоритм AH-карасик, во-первых, насчитывает вот эти вот величины,
[46:01.880 --> 46:06.800]  все линки, все go для всех вершин, а затем с их помощью решает вот эти две задачи,
[46:06.800 --> 46:16.240]  наша задача, задачу штрих. Алгоритм AH-карасик. Это, как всегда, два автора. Это мужчина, это женщина,
[46:16.240 --> 46:21.000]  поэтому здесь не карасик, а имя карасик, женская фамилия. В родительном падеже так и остается.
[46:21.000 --> 46:33.200]  Он, во-первых, насчитывает все вот эти линки и все тушки, и все go, простите, насчитывает линк и go,
[46:33.200 --> 46:38.480]  для любой вершины, для любого символа. Стреликом заполняется режим вот этих
[46:38.480 --> 46:44.680]  массивов линк и go. Значит, ну давайте мы прям его сразу и напишем, по ходу будем
[46:44.680 --> 46:49.880]  разбираться, как эти линк и go заполнять. Ну, во-первых, надо разбираться сначала с корнем.
[46:49.880 --> 47:02.040]  Скажите, пожалуйста, чему должен быть равен линк от корня? Вот поэтому определение, если вы это
[47:02.040 --> 47:08.440]  корень, то куда должна вести суффиксная ссылка? Никуда, да, ее не может быть по определению,
[47:08.440 --> 47:13.200]  потому что поскольку v отвечает Эпсилону в пустой строке, то у Эпсилона просто нет
[47:13.200 --> 47:18.000]  собственных суффиксов, поэтому мы как бы берем максимум по пустому множеству, так делать нельзя.
[47:18.000 --> 47:23.080]  Поэтому формально линк от корня не определен, но я давайте для удобства напишу, что линк от нуля,
[47:23.080 --> 47:33.440]  скажем, равно нулю. Это неважно, да, но формально он не определен. Формально не определен.
[47:33.440 --> 47:45.080]  Линк от корня не определен. Значит, дальше, что делает go от корня? Ну, я уже сказал важное
[47:45.080 --> 47:52.400]  замечание, что если из вершины v есть переход по букве c, то есть если есть в массиве tu переход
[47:52.400 --> 48:06.120]  по c, значит go просто совпадает с tu. Важное замечание, что если из v есть переход по c,
[48:06.120 --> 48:21.560]  то go vc равно, ну то, что у нас было tu c для этой вершинки v. То есть у нас для каждого символа
[48:21.560 --> 48:28.840]  хранится то, куда мы попадем, если просчитаем этот символ. В этом же смысле go просто равен tu,
[48:28.840 --> 48:34.120]  потому что мы просто считаем этот символ, тем самым v плюс c, оно вот здесь и находится, его можно
[48:34.120 --> 48:42.360]  просчитать. Это понятно, вот этот случай? Вот. Поэтому для корня мы сделаем следующее. Мы пройдемся по
[48:42.360 --> 48:47.840]  всем символам, ну давайте я там считаю, что у меня сейчас алфавит это какие-нибудь там числа от нуля до
[48:47.840 --> 49:05.000]  сигма минус один. Вот. И если t0.tu c не равно минус один, то есть если есть переход по этой
[49:05.000 --> 49:22.880]  букве по этому числу, тогда go равно просто этому сталому переходу. Go 0t равно t0 tu c. Вот. А что делать,
[49:22.880 --> 49:32.520]  если нет перехода по букве c из корня? Вот был корень. Я хочу, то есть это строка epsilon,
[49:32.520 --> 49:37.240]  хочу дописать некий символ c, то есть получить строчку c, взять у нее максимальный суев,
[49:37.240 --> 49:55.680]  который есть в боре. Чему тогда равно go? Нулю да. Ну просто по определению у нас был корень epsilon,
[49:55.680 --> 50:01.000]  приписал букву c, получилась строка c. При этом, да, я предположил, что это условие пройдено,
[50:01.000 --> 50:06.640]  ну то есть это условие не выполнилось, значит по c не было перехода, то есть c нельзя прочитать из
[50:06.640 --> 50:12.480]  корня. Значит единственный суффикс этой строки, которую можно просчитать, это epsilon. Поэтому go
[50:12.480 --> 50:22.680]  равен нулю как строка, вершина соответствующей пустой строке. Поэтому иначе я пишу go 0t равно нулю.
[50:22.680 --> 50:31.240]  То есть если переход был, то go это то же самое, что тот переход. Если перехода не было,
[50:31.240 --> 50:35.160]  то go это 0. Я попытался прочитать символ c, но не смог и вернулся в корень.
[50:35.160 --> 50:57.560]  Так, хорошо, с корнем разобрались. А дальше алгоритм можно реализовать, например, так. Мы
[50:57.560 --> 51:04.760]  будем в каком-то смысле в порядке bfs его обходить, наш бор, и в очередь будем складывать вершины,
[51:04.760 --> 51:10.040]  для которых мы уже все посчитали. И link и go все насчитали. Тогда, когда мы из бора достаем очередную
[51:10.040 --> 51:15.920]  вершинку, видим из нее несколько переходов, мы посчитаем link и go для всех вот этих вот вершин
[51:15.920 --> 51:21.240]  и сложим их опять в очередь. То есть мы как бы, ну вот, как обычно обходит bfs, давайте что-нибудь
[51:21.240 --> 51:28.840]  нарисую побольше. Какое-нибудь вот такое дерево. Мы сначала обошли корень, потом посчитали ответ
[51:28.840 --> 51:34.000]  для всех его детей, добавили их в очередь, потом извлекли из очереди эту вершину, посчитали ответ
[51:34.360 --> 51:38.840]  вЭтовершин, удалили ее, для этой вершины посчитали ответ для них, добавили их, удалили ее,
[51:38.840 --> 51:44.160]  для этой вершины посчитали ответ для нее, добавили ее в очередь, удалили ее. В итоге�мя сейчас,
[51:44.160 --> 51:49.560]  в очереди вершины все со второго уровня, потом я опять их обхожу слева направо, добавляют
[51:49.560 --> 51:54.640]  совершенно трет�ум уровна, и так далее. То есть я вот как бы так, сверху вниз, слева направо
[51:54.640 --> 52:02.800]  прохожу, вот мы реализуем это в виде прям очереди, очередь номеров вершин, которые мы обработали.
[52:02.800 --> 52:13.080]  это обработанные вершины, обработанные вершины, ну и изначально мы в эту очередь добавляем корень,
[52:13.080 --> 52:20.280]  купуш ноль. Дальше пока очередь не пустая,
[52:27.280 --> 52:36.360]  мы хотим достать вершину и, зная, что у нее уже посчитаны линк и гоу, найти линк и гоу для всех
[52:36.360 --> 52:50.000]  ее детей. Достали первую вершину из очереди, сразу ее удалили оттуда и сейчас наша цель найти линк и
[52:50.000 --> 53:08.240]  гоу для детей v. Ну давайте этих детей перебирать. Перебираем все переходы от 0 до сигма. Говорим,
[53:08.240 --> 53:19.040]  что u это наш сын. Получается при переходе по букве c, то есть t, v, tu, c. Если это минус 1,
[53:19.040 --> 53:34.320]  то continue. Если это не настоящая вершина, то делать ничего не надо, это не сын, его нет, мы его пропускаем.
[53:49.040 --> 53:56.120]  Вот, а дальше интересно, смотрите, есть вершина v, для которой мы все знаем, и линк и гоу все знаем.
[53:56.120 --> 54:01.680]  Есть из нее переход по букве c и вершины u. Для вершины u мы еще ничего не знаем. Вот давайте
[54:01.680 --> 54:14.680]  попытаемся что-то для нее найти. Во-первых, как найти линк u? Чему он равен? Ну давайте я нарисую так,
[54:14.680 --> 54:20.880]  вот у нас была строка отвечающей вершинке v, мы дописали к ней t, и это все теперь вместе будет u.
[54:20.880 --> 54:38.440]  Мы дописали один символ, стало u. Еще раз. Да, гоут линк v по букве c почти всегда. Значит,
[54:38.440 --> 54:42.880]  давайте подробно здесь обсудим. Почти правильно, только здесь есть небольшая тонкость. Смотрите,
[54:42.880 --> 54:48.760]  что такое линк? Это максимальный собственный суффикс, который есть в боре. То есть мне нужно
[54:48.760 --> 54:53.240]  отрезать несколько символов в начале, при этом хотя бы один надо отрезать, нельзя ничего не
[54:53.240 --> 55:01.720]  отрезать. Нужно отрезать хотя бы один, так чтобы вот эта строка была в боре. Давайте мы сделаем
[55:01.720 --> 55:08.760]  по-другому. Давайте мы сначала возьмем самый длинный собственный суффикс v, который есть в
[55:08.760 --> 55:19.360]  боре. Возьмем линк от v. И понятное дело, что если вот это есть в боре, то это тоже есть в боре.
[55:19.360 --> 55:25.240]  Поэтому когда мы берем линк от v, мы не теряем вот этого вот суффикса v, который остается,
[55:25.240 --> 55:33.520]  когда мы взяли линк от u. Еще раз. Линк от u, вот эта вот строка, она точно не более длинная,
[55:33.520 --> 55:40.800]  чем линк от v. Вот здесь вот. Это все не длиннее, чем вот это, потому что это самый длинный собственный
[55:40.800 --> 55:47.000]  суффикс v, а это самый длинный собственный суффикс v, который еще продлевается на ц. Поэтому это,
[55:47.000 --> 55:52.200]  конечно, более длинное, чем это, но по крайней мере не короче. И дальше мне нужно как бы среди
[55:52.200 --> 55:59.960]  всех вот таких вот суффиксов найти тот, который можно продлить буквой c. Значит в общем случае
[55:59.960 --> 56:10.920]  линк от u будет равно go линк от v по букве c.
[56:20.920 --> 56:27.260]  Значит давайте еще раз объясню почему. Смотрите, вот это максимальный собственный суффикс строки
[56:27.260 --> 56:36.020]  v плюс c, потому что u это v плюс c. А максимальный собственный суффикс строки v плюс c. Другими
[56:36.020 --> 56:42.620]  словами это такой максимальный собственный суффикс строки v, который продлевается еще строкой c. То
[56:42.620 --> 56:48.140]  есть это некий вот здесь вот суффикс, который можно обращать в боре, от которого вниз еще есть
[56:48.140 --> 56:55.340]  переход p atraburny по буконе с. Нас самый длинный собственный суффикс v, который еще продлевается
[56:55.340 --> 57:00.100]  вниз буковкой С. Но это то же самое, что если сначала взять просто самый длинный
[57:00.100 --> 57:05.140]  собственности суффикс В, а потом среди них всех подписать, ну как бы подписать
[57:05.140 --> 57:08.540]  к этой строке С и взять максимальный собственности суффикс, просто максимальный
[57:08.540 --> 57:11.660]  суффикс, который в этой строке есть.
[57:21.220 --> 57:25.100]  Так, сейчас попробую еще как-нибудь по-другому объяснить.
[57:25.340 --> 57:49.780]  Ну да, то есть смотрите, вообще что нам нужно вот здесь? Что такое линк от У? Это
[57:49.780 --> 57:57.060]  точно некий суффикс В, некий собственный суффикс В, после которого написано С. Ну а
[57:57.060 --> 58:02.140]  здесь мы находим сначала самый длинный, в принципе, собственный суффикс В, а затем к
[58:02.140 --> 58:06.220]  нему приписываем, то есть вот взяли линк от В, к нему приписали С, и либо это
[58:06.220 --> 58:10.540]  сразу был переход вниз по ребру С, то есть был переход здесь вниз, тогда гоу
[58:10.540 --> 58:15.140]  совпадает с ту и просто ведет вниз. Либо мы понимаем, что сразу за вот этим нет
[58:15.140 --> 58:19.260]  перехода по С. Тогда нам нужно взять как можно более длинный оставшийся суффикс
[58:19.260 --> 58:24.180]  вот этой строки, который можно продлить буквой С, а это в точности гоу. То есть была строка,
[58:24.180 --> 58:28.740]  мы к ней приписали С, и нам нужно оставить отсюда как можно больше суффикс, чтобы
[58:28.740 --> 58:31.500]  можно было написать С. Это в точности по определению просто гоу.
[58:31.500 --> 58:39.900]  Вот, ну если не понятно, еще порефлексируйте на досуге. По сути мы просто сначала насильно
[58:39.900 --> 58:43.940]  отрезали хотя бы один символ, да, линк это всегда собственный суффикс, это вот здесь
[58:43.940 --> 58:47.580]  обеспечивается, что мы насильно отрезали хотя бы один, потому что линк всегда собственный.
[58:47.580 --> 58:53.060]  А дальше мне нужно просто сохранить как можно больший суффикс с переходом по С в конце,
[58:53.060 --> 58:59.340]  вот это делается в помощи гоу. Вот, значит, это почти всегда верно, вот эта формула почти
[58:59.340 --> 59:05.260]  всегда верна, кроме какого случая. Да, кроме случая В это корень, потому что для В у нас формально
[59:05.260 --> 59:09.620]  линк неопределенный, мы туда написали какой-то мусор, линк отвернул на нулю, что на самом деле как бы
[59:09.620 --> 59:20.340]  не осмысленно. Вот, значит, это верно, если В не корень, если В не корень. Если же В корень,
[59:20.340 --> 59:31.940]  то чему равно линк от У? Вот если В это корень, мы прочитали один символ, соответственно,
[59:31.940 --> 59:38.180]  У отвечает строке из одного символа, чему равно линк от этой вершинки? Да, пустой строке, то есть корню.
[59:38.180 --> 59:50.620]  Потому что у нас есть строка из одного символа, так как У равно С, вершина отвечает строке из
[59:50.620 --> 59:55.940]  одного символа С, максимальный собственный суффикс, это строка пустая, Эпсилон, и она
[59:55.940 --> 01:00:01.300]  соответствует корню, которая читается в боре, поэтому линк от ребенка корня это всегда корень.
[01:00:01.300 --> 01:00:11.860]  Тем самым мы получили полное описание того, как насчитывать линк от У, либо по такой формуле,
[01:00:11.860 --> 01:00:19.660]  когда В не корень, либо по такой, когда В корень. Так, ну давайте вставим это в код, давайте вот так
[01:00:19.660 --> 01:00:30.060]  выделю, линк от У равно, я это обычно так пишу, тернарным оператором В равно 0, если да, то 0,
[01:00:30.060 --> 01:00:51.340]  иначе вот то самое наше ГО, линк от В по букве С. Вот такая врезка. С линк более-менее
[01:00:51.340 --> 01:00:57.780]  разобрались. Значит дальше мне нужно для вершины У насчитать все ГО, для каждого символа, для каждого
[01:00:57.780 --> 01:01:03.700]  символ нашего алфавита, мне нужно считать ГО по этому символу. Значит мне нужно как минимум все эти
[01:01:03.700 --> 01:01:15.540]  символы перебрать. Давайте я скажу, что это будет переменная D от 0 до Сигма. Я сейчас буду пытаться
[01:01:15.540 --> 01:01:29.220]  найти ГО у Д. Начну первый случай опять простой. Если есть переход, да, если из У есть переход по Д,
[01:01:29.220 --> 01:01:42.540]  тогда ГО просто с ним совпадает. Если ТУ.ТУ от Д не равно минус 1, тогда ГО равно этому
[01:01:42.540 --> 01:01:58.340]  самому переходу. Так, я поленюсь, напишу в одну строчку. ГО у Д равно ТУ ТУ Д. Если из У есть ребро
[01:01:58.340 --> 01:02:04.540]  вниз по букве Д, тогда, как мы неоднократно замечали, ГО по этой букве просто равно тому
[01:02:04.540 --> 01:02:17.500]  самому переходу. Просто переход вниз по букве Д. Вот сюда мы попадаем через ГО. Иначе, что нам
[01:02:17.500 --> 01:02:25.740]  нужно сделать? Иначе, какая произошла ситуация? У нас была строка У, мы попытались к ней приписать
[01:02:25.740 --> 01:02:33.660]  символ Д, поняли, что вот такой строки в Боре уже нет. У плюс Д уже в Боре точно нет. Потому что
[01:02:33.660 --> 01:02:38.740]  если бы была, мы бы могли просто прочитать буковку Д, начавшись с вершинки У. То есть,
[01:02:38.740 --> 01:02:44.300]  тогда здесь был бы переход. Итак, строки У плюс Д в Боре нет, но мы по-прежнему хотим найти самый
[01:02:44.300 --> 01:02:51.180]  длинный суффикс этой строки, которая читается в Боре, которая есть в Боре. Значит, это не просто
[01:02:51.180 --> 01:03:00.380]  максимальный суффикс строки У плюс Д, но максимальный собственный суффикс. Поскольку самой У плюс Д в
[01:03:00.380 --> 01:03:08.500]  Боре точно нет, то тогда давайте напишу так. Максимальный хороший суффикс У плюс Д, хороший,
[01:03:08.500 --> 01:03:17.420]  то есть тот, который есть в Боре. Хороший суффикс У плюс Д. Это то же самое, что максимальный хороший
[01:03:17.420 --> 01:03:39.860]  суффикс. Хороший, сори, собственный суффикс. Да. Нет. Внутри, да, внутри цикла по С. Значит,
[01:03:39.860 --> 01:03:42.940]  что я тут написал? Я сказал, что максимальный хороший суффикс У плюс Д, это то же самое,
[01:03:42.940 --> 01:03:47.900]  что максимальный хороший собственный суффикс У плюс Д. Просто потому, что само У плюс Д это не
[01:03:47.900 --> 01:03:52.300]  хорошее слово, да, его нет в Боре, его нельзя просчитать в Боре. Значит, как минимум один символ
[01:03:52.300 --> 01:03:57.260]  надо откусить, поэтому мы рассматриваем только собственный суффикс. То есть, смотрите, мне нужно
[01:03:57.260 --> 01:04:03.580]  для строки У плюс Д найти максимальный собственный суффикс, который есть в Боре. Но это мы уже вот
[01:04:03.580 --> 01:04:09.780]  только что делали. Да, у нас была строка, мы к ней приписывали символ и искали максимальный собственный
[01:04:09.780 --> 01:04:17.060]  суффикс вот такой вот новой строки В плюс С, который есть в Боре. Это вот оно. Ну, значит, там работает
[01:04:17.060 --> 01:04:23.580]  то же самое. Просто потому, что это та же самая задача. Для строки строка плюс символ найти максимальный
[01:04:23.580 --> 01:04:28.420]  собственный суффикс, который есть в Боре, это вот это. Поэтому просто формула здесь копируется и
[01:04:28.420 --> 01:04:52.020]  будет ГОУ, ну не копируется, а будет аналогичное. ГОУ С, ГОУ Д это ГОУ линк У Д. И это уже будет всегда
[01:04:52.020 --> 01:04:57.780]  корректно, потому что линк от У всегда определено. У это уже не корень, поэтому линк от У можно
[01:04:57.780 --> 01:05:06.860]  корректно брать и, соответственно, можно просто взять ГОУ точно так же, как и там. Вот мораль такая,
[01:05:06.860 --> 01:05:12.580]  смотрите, если мы поняли, почему работает эта формула, тогда, на самом деле, здесь она также
[01:05:12.580 --> 01:05:17.100]  автоматически работает просто потому, что мы решаем одну и ту же задачу. У нас была строка,
[01:05:17.100 --> 01:05:21.660]  вот здесь была строка В, мы к ней приписали символ и ищем максимальный собственный суффикс,
[01:05:21.660 --> 01:05:27.540]  который есть в Боре. Здесь то же самое. Есть строка У, мы приписали символ Д и ищем максимальный
[01:05:27.540 --> 01:05:31.140]  собственный суффикс, который есть в Боре. Но раз это одна и та же задача, то и формула для
[01:05:31.140 --> 01:05:42.660]  почета одна и та же. Просто нужно ВЦ поменять на УД. Вот она. Так, ну и в конце, после вот этого,
[01:05:42.660 --> 01:05:55.740]  сейчас, момент, давайте куда-нибудь вставлю последнюю строчку. Так, ну ладно.
[01:05:55.740 --> 01:06:17.700]  Мы закончили на счет ГОУ УД для всех символов Д. Дальше мы считаем, что мы для вершины У все
[01:06:17.700 --> 01:06:23.220]  посчитали и добавляем ее в очередь. Мы ее обработали, нашли все вот эти величины для нее,
[01:06:23.220 --> 01:06:28.660]  добавили в очередь. Ну и все, на этом надо завершиться. Значит, цикл по С закрывается,
[01:06:28.660 --> 01:06:33.020]  и ВАИЛ наш тоже закрывается. Ну и соответственно, да, все, больше ничего не было.
[01:06:33.020 --> 01:06:54.540]  Да. Потому что мы линк от У считаем, а не линк от В. У нас В это вершина, для которой все
[01:06:54.540 --> 01:07:00.380]  насчитано. Изначально В это корень. Потом мы рассматриваем его ребенка У. И для У уже,
[01:07:00.540 --> 01:07:04.220]  У это уже не корень, а ребенок корня. Пытаемся найти линк.
[01:07:04.220 --> 01:07:32.180]  Сейчас. Не, не сработает. У вас будет линк от уровна У. Потому что, смотрите, вот у вас был
[01:07:32.180 --> 01:07:39.620]  корень В равно нулю. У вас был переход С в вершину У. И линк от В равно нулю. Тогда вы
[01:07:39.620 --> 01:07:47.420]  смотрите на GO корень по букве С. Ну извините, но это У. Да, потому что вот он есть переход.
[01:07:47.420 --> 01:08:02.020]  Так, алгоритм я написал. Единственное здесь, смотрите, здесь два тонких места. Первое,
[01:08:02.020 --> 01:08:06.060]  это понимание вот этой формулы. Я как мог объяснил, но, пожалуйста, еще порефлексируйте
[01:08:06.060 --> 01:08:11.540]  над ней, поймите, почему здесь все нормально. И во-вторых, почему, когда мы вот это вот все делаем,
[01:08:11.540 --> 01:08:20.980]  мы имеем право полагать, что линк от В насчитано, и GO для вот этой штуки уже все насчитаны. А также
[01:08:20.980 --> 01:08:24.980]  здесь, ну линк от У понятно, мы только что насчитали. Но также почему мы имеем право полагать,
[01:08:24.980 --> 01:08:32.980]  что GO для этой вершины и буква D уже насчитана? Да, именно так. Потому что мы идем по нашему
[01:08:32.980 --> 01:08:39.020]  бороду сверху вниз, порядке BFS, то есть порядке увеличения глубины. Значит, все вершины с глубиной
[01:08:39.020 --> 01:08:46.220]  меньше, чем У, уже имеют полностью насчитанные линки и GO. Да, поскольку эта вершина точно имеет
[01:08:46.220 --> 01:08:49.740]  глубину меньше, чем У, потому что это линк, собственный суффикс, значит, имеет меньшую глубину,
[01:08:49.740 --> 01:08:55.060]  тогда для нее точно уже GO насчитано. Ну то же самое здесь. Линк от В имеет глубину меньше,
[01:08:55.060 --> 01:09:01.140]  чем В. Что имеет глубину еще меньше, чем У, значит, для нее все GO уже насчитаны. И именно за
[01:09:01.140 --> 01:09:06.020]  счет того, что мы идем вот так BFS сверху вниз по бору, мы имеем право брать GO для всех вот
[01:09:06.020 --> 01:09:11.300]  это и для линк от В, и для линк от У. Они уже находятся на меньшей глубине, для них уже все посчитано.
[01:09:11.300 --> 01:09:39.740]  Давайте зафиксирую обращение GO линк от В и GO линк от У. Корректно? Поскольку, значит, обе эти
[01:09:39.740 --> 01:09:48.620]  вершины, что линк от В, что линк от У, линк от В и линк от У, имеют меньшую глубину, чем У.
[01:09:48.620 --> 01:10:05.180]  Имеют меньшую глубину, чем У. А потому они уже были обработаны в нашем BFS, значит, для них уже все
[01:10:05.180 --> 01:10:19.260]  насчитано. Были обработаны в BFS раньше, ну просто потому, что BFS идет в порядке увеличения глубины,
[01:10:19.260 --> 01:10:25.700]  в порядке увеличения расстояния от корня. Значит, все такие обращения корректны, и если мы на каждом
[01:10:25.700 --> 01:10:30.100]  шаге делали корректные вычисления, GO и линк, тогда на каждом следующем, поскольку оно следует
[01:10:30.100 --> 01:10:48.660]  из корректных, то каждое конкретно тоже будет корректным. Так, ну а симптотика здесь, конечно,
[01:10:48.660 --> 01:11:00.620]  будет просто В на сигма, где В это, ну что, вершин, ну а сигма, как обычный алфавит. Потому что для каждой
[01:11:00.620 --> 01:11:07.540]  вершины Бора мы заводим массив вот такой вот длины, а все остальное, на самом деле, линейное. Потому
[01:11:07.540 --> 01:11:11.660]  что мы для каждой вершины просто, ну смотрите, линк для вершины у нас определяется за вот
[01:11:11.660 --> 01:11:16.180]  единицы. Потому что линк от В уже насчитано, GO вот эти штуки уже насчитаны, просто обращение
[01:11:16.180 --> 01:11:21.820]  к массиву за вот единицы. Чтобы насчитать GO для вершины по букве, мне тоже никаких вычислений
[01:11:21.820 --> 01:11:26.020]  делать не надо, это просто вычисление за вот единицы. Поэтому каждое конкретное значение
[01:11:26.020 --> 01:11:32.180]  находится за вот единицы, ну а всего значений нужно найти ровно вот столько. Для каждой вершины
[01:11:32.180 --> 01:11:39.660]  и каждого символа нужно найти GO по вершине и символу. Вот столько значений нужно найти,
[01:11:39.660 --> 01:11:46.740]  поэтому вот столько времени нужно потратить. Ну давайте я отмечу, что столько времени и столько
[01:11:46.740 --> 01:11:57.940]  памяти. Ну тут в каком-то смысле лучше и нельзя, потому что мне все равно, мне нужно посчитать вот
[01:11:57.940 --> 01:12:02.340]  столько значений. Мне нужно для каждой вершины и для каждой буквы найти, куда мы попадем,
[01:12:02.340 --> 01:12:06.540]  если к вершине припишем букву. Поэтому лучше чем столько нельзя, вот за такой симптом мы и решили.
[01:12:06.540 --> 01:12:29.060]  Так, ну хорошо, теперь давайте решать задачу и задачу штрих. Давайте вспомним задачу. Обычно
[01:12:29.060 --> 01:12:52.980]  это просто суммарное число вхождений словарных слов в текст. Здесь алгоритм будет следующий.
[01:12:52.980 --> 01:13:02.220]  Мы будем читать наш текст T по одному символу слева направо и в каждый момент времени,
[01:13:02.220 --> 01:13:07.220]  то есть вот где-то там еще продолжение нашего текста, вот мы дочитали до сюда, в каждый момент
[01:13:07.220 --> 01:13:15.060]  времени мы будем от текущего состояния строки T хранить максимальный суффикс, который есть в
[01:13:15.060 --> 01:13:23.420]  боре. Мы идем по T читаем слева направо, вот мы находимся где-то здесь, там дальше еще будут
[01:13:23.420 --> 01:13:28.140]  символы, но вот пока мы дочитали до сюда. И вот в этот момент времени мы храним самый длинный
[01:13:28.140 --> 01:13:39.980]  суффикс текущего положения T, который можно прочитать в боре. Давайте так, для каждого и в момент
[01:13:39.980 --> 01:14:03.020]  времени и храним максимальный суффикс строки T0 и т.д. Т.е. все символы вплоть до Итого. Максимальный
[01:14:03.020 --> 01:14:17.100]  суффикс этой строки, который есть в боре. В чем смысл? Зачем хранить максимальный суффикс,
[01:14:17.100 --> 01:14:24.820]  который есть в боре? Смотрите, мы помним, что что такое слова, которые есть в боре? В боре есть
[01:14:24.820 --> 01:14:31.180]  только те слова, те и только те слова, которые являются префиксами словарных слов. Т.е. если вот
[01:14:31.540 --> 01:14:37.420]  это слово, которое есть в боре, значит его потенциально, если T дальше правильно будет устроено,
[01:14:37.420 --> 01:14:42.720]  его можно потенциально добить до некоторого слова из словаря. То есть это префикс некоторого
[01:14:42.720 --> 01:14:48.340]  словарного слова. И если T дальше будет правильным, мы можем вот здесь получить вхождение какого-то
[01:14:48.340 --> 01:14:55.580]  словарного слова. Из всех таких вот окончаний меня, конечно, интересует только префикс словарных
[01:14:55.580 --> 01:14:59.380]  слов, потому что если вот этот кусок не является
[01:14:59.380 --> 01:15:02.040]  префиксом никакого словарного слова, то его никак нельзя
[01:15:02.040 --> 01:15:03.040]  продолжить.
[01:15:03.040 --> 01:15:06.120]  Если мы взяли какой-то кусок, и это причем не префикс
[01:15:06.120 --> 01:15:08.320]  ни одного словарного слова, то есть его нет в боре, то
[01:15:08.320 --> 01:15:11.840]  что не пиши дальше, эта штука уже не будет началом вхождения
[01:15:11.840 --> 01:15:13.840]  никакого.
[01:15:13.840 --> 01:15:16.440]  Поэтому среди этих окончаний, которые можно продлить
[01:15:16.440 --> 01:15:19.920]  направо, меня интересуют только те, которые есть
[01:15:19.920 --> 01:15:22.640]  в боре, потому что их можно продлить направо некими
[01:15:22.640 --> 01:15:27.740]  окончаниями, чтобы получить словарное слово.
[01:15:27.740 --> 01:15:31.040]  Когда мы обрезали, меня интересуют только такие суффиксы
[01:15:31.040 --> 01:15:35.660]  текущей строки T, которые являются префиксами словарных
[01:15:35.660 --> 01:15:36.660]  слов.
[01:15:36.660 --> 01:15:38.460]  Среди всех таких давайте возьмем максимальный, то
[01:15:38.460 --> 01:15:41.380]  есть их там может быть несколько, вот этот, поменьше, поменьше,
[01:15:41.380 --> 01:15:44.300]  вот все они есть в боре, их потенциально можно как-то
[01:15:44.300 --> 01:15:45.300]  продолжить.
[01:15:45.300 --> 01:15:47.180]  Давайте возьмем среди них самый длинный, тогда мы
[01:15:47.180 --> 01:15:48.360]  точно никакую информацию не потеряем.
[01:15:48.360 --> 01:16:08.560]  Так, а вот этот массив очень легко насчитывается, как
[01:16:08.560 --> 01:16:12.080]  для каждого и взять максимальный суффикс такой строки, которая
[01:16:12.080 --> 01:16:13.080]  есть в боре.
[01:16:13.080 --> 01:16:17.780]  Это очень просто, v0, ну не так, давайте я в 1 индексации
[01:16:17.780 --> 01:16:22.740]  перейду, пусть у меня будет t в 1 индексация от 1 до i.
[01:16:22.740 --> 01:16:27.420]  Значит, тогда v0 это просто корень 0, а дальше vit это
[01:16:27.420 --> 01:16:39.240]  go vi-1 по символу tit, просто потому что вот у меня было
[01:16:39.240 --> 01:16:44.120]  положение строки в момент времени i-1 и было vi-1 это максимальный
[01:16:44.120 --> 01:16:48.120]  вот этот суффикс, давайте я назову, храним vit, вот
[01:16:48.120 --> 01:16:50.240]  у меня был максимальный суффикс в момент времени
[01:16:50.240 --> 01:16:54.760]  i-1, потом добавляется новый символ tit, я хочу пересчитать
[01:16:54.760 --> 01:16:55.760]  максимальный суффикс.
[01:16:55.760 --> 01:16:59.320]  Ну понятно, что это просто go, потому что у меня была
[01:16:59.320 --> 01:17:03.360]  некая строка vi-1, я к ней приписываю новый символ
[01:17:03.360 --> 01:17:05.800]  и теперь у этой штуки хочу взять максимальный суффикс,
[01:17:05.800 --> 01:17:12.000]  ну просто по определению это go, еще раз, у меня было
[01:17:12.000 --> 01:17:15.200]  положение строки в момент времени i-1, вот оно, пусть
[01:17:15.200 --> 01:17:18.160]  vi-1 это максимальный суффикс, который есть в боре, у вот
[01:17:18.160 --> 01:17:21.960]  этой строки до черты, дальше появляется новый символ
[01:17:21.960 --> 01:17:25.080]  ti, я хочу уже найти максимальный суффикс вот этой новой
[01:17:25.080 --> 01:17:29.240]  строки вместе с символом ti, который есть в боре, максимальный
[01:17:29.240 --> 01:17:30.960]  суффикс, который есть в боре, ну как-то вот так будет
[01:17:30.960 --> 01:17:31.960]  выглядеть.
[01:17:32.560 --> 01:17:36.760]  Ну это просто по определению go vi-1 ti, потому что мне нужно
[01:17:36.760 --> 01:17:41.160]  взять вот эту строчку, приписать к ней новый символ и взять
[01:17:41.160 --> 01:17:43.880]  среди всех возможных суффиксов максимальный, ровно это
[01:17:43.880 --> 01:17:49.840]  и делает go, а поэтому вот это vi-1 будет просто переходом
[01:17:49.840 --> 01:17:57.480]  по go в боре, ну и после этого, если я для каждого момента
[01:17:57.480 --> 01:18:02.160]  времени, после каждого символа ti, знаю текущую
[01:18:02.160 --> 01:18:10.840]  вершину в боре, то что мне нужно сделать, сейчас напишу,
[01:18:10.840 --> 01:18:18.200]  каждая i вносит несколько вхождений словарных слов,
[01:18:18.200 --> 01:18:23.080]  несколько вхождений словарных слов.
[01:18:23.080 --> 01:18:50.280]  Значит каких, смотрите, вот пусть vit, это максимальный
[01:18:50.280 --> 01:18:53.320]  суффикс t, который есть в боре, я уже рисовал вот
[01:18:53.320 --> 01:19:00.360]  эту картинку, давайте продублирую, вот он vi, какие слова, вот
[01:19:00.360 --> 01:19:03.240]  мы добавили новый символ, вот этот последний ti, какие
[01:19:03.240 --> 01:19:06.040]  словарные слова только что получили вхождение, то
[01:19:06.040 --> 01:19:08.400]  есть которые раньше не встречались, теперь получили
[01:19:08.400 --> 01:19:10.600]  вхождение, ну это явно какие-то суффиксы, вот какие-то
[01:19:10.600 --> 01:19:14.520]  такие строки, раньше не было, теперь вот появилось
[01:19:14.520 --> 01:19:19.440]  новое вхождение, ну тогда это просто напросто все суффиксы
[01:19:19.440 --> 01:19:21.920]  вот этой строки, которые являются терминальными
[01:19:21.920 --> 01:19:25.960]  вершинами, значит мне, чтобы обновить ответ при добавлении
[01:19:25.960 --> 01:19:30.360]  этого символа, нужно найти количество терминальных
[01:19:30.360 --> 01:19:34.760]  вершин среди суффиксов вот этого, то есть мне нужно
[01:19:34.760 --> 01:19:39.920]  как бы перебрать все суффиксы строки vit и среди них найти
[01:19:39.920 --> 01:19:42.360]  количество терминальных, и это и будет то, насколько
[01:19:42.360 --> 01:19:45.760]  увеличится ответ при добавлении вот этого символа ti, но эта
[01:19:45.760 --> 01:19:47.920]  штука на самом деле может быть переформулирована
[01:19:47.920 --> 01:20:00.760]  так, значит, сколько суффиксов vi являются терминальными
[01:20:00.760 --> 01:20:01.760]  вершинами.
[01:20:01.760 --> 01:20:11.480]  Ну это является, например, так, смотрите, если vi сама
[01:20:11.480 --> 01:20:14.320]  по себе терминальная, то нужно прибавить единичку,
[01:20:14.320 --> 01:20:17.040]  а дальше давайте брать линк от v, линк от текущей
[01:20:17.040 --> 01:20:20.280]  вершины, пока мы не дойдем до корня, потому что линк
[01:20:20.280 --> 01:20:23.080]  это по сути отбрасывание первых нескольких символов,
[01:20:23.080 --> 01:20:25.240]  чтобы вернуться в Бор, сколько символов надо отбросить
[01:20:25.240 --> 01:20:28.320]  минимально, чтобы получилась строка из Бор, то есть вот
[01:20:28.320 --> 01:20:33.000]  у нас, так, давайте не так, вот оно было vi, vi, если она
[01:20:33.000 --> 01:20:35.640]  терминальная, то она уже, как бы собственный суффикс,
[01:20:35.640 --> 01:20:38.600]  нужно добавить единичку, потом нужен следующий по
[01:20:38.600 --> 01:20:42.960]  величине суффикс, который терминальный, значит мне
[01:20:42.960 --> 01:20:45.680]  нужно несколько первых символов отбросить, окей, получил
[01:20:45.680 --> 01:20:47.880]  некий суффикс, который есть в Боре, но при этом не
[01:20:47.880 --> 01:20:51.600]  терминальный, это была просто линк, мы ее игнорируем, потом
[01:20:51.600 --> 01:20:54.440]  опять нужно несколько символов отбросить, чтобы получить
[01:20:54.440 --> 01:20:58.520]  суффикс, который есть в Боре, окей, он, например, был терминальный,
[01:20:58.520 --> 01:21:01.400]  но главное, что это тоже линк, да, то есть мне по сути
[01:21:01.400 --> 01:21:05.280]  нужно, чтобы вообще перебрать все вот эти суффиксы, мне
[01:21:05.280 --> 01:21:09.520]  достаточно прыгать по суффсылкам, по линкам от vd vi, тем самым
[01:21:09.520 --> 01:21:13.400]  я буду перебирать все возможные суффиксы текущей строки,
[01:21:13.400 --> 01:21:16.600]  которые есть в Боре, тогда вот здесь алгоритм очень простой,
[01:21:16.600 --> 01:21:21.000]  давайте мы просто будем прыгать по линк, пока не дойдем
[01:21:21.000 --> 01:21:24.200]  до корня и считать, сколько средних терминальных, тем
[01:21:24.200 --> 01:21:28.520]  самым мы как бы переберем все суффиксы вот этой строки
[01:21:28.520 --> 01:21:35.240]  и найдем, сколько из них являлись словарными словами,
[01:21:35.240 --> 01:21:38.160]  да, это можно предпочитать, конечно, давайте я это напишу,
[01:21:38.160 --> 01:21:42.880]  пока не алгоритмом, да, скорее, идея, да, значит, мы берем
[01:21:42.880 --> 01:21:48.840]  линк от vi, то есть мы берем vi, берем линк от vi, берем
[01:21:48.840 --> 01:21:57.560]  линк от линк от vi и так далее, вплоть до корня, и смотрим,
[01:21:57.560 --> 01:22:07.920]  сколько средних терминальных, сколько среди них терминальных,
[01:22:07.920 --> 01:22:16.840]  сколько средних терминальных есть, ровно столько и появилось
[01:22:16.840 --> 01:22:24.000]  вхождение словарных слов в наш текст, вот, ну, чтобы
[01:22:24.000 --> 01:22:27.160]  победить нам осталось, ну, научиться вот эту штуку
[01:22:27.160 --> 01:22:29.080]  насчитывать быстро, да, сколько среди вот этих
[01:22:29.080 --> 01:22:31.440]  вершин есть терминальных, это, конечно, можно сделать
[01:22:31.440 --> 01:22:48.000]  предпочетом просто, значит, скажем, давайте, пусть будет
[01:22:48.000 --> 01:23:06.400]  knt от v, это количество терминальных на пути по су-всылкам, ну,
[01:23:06.400 --> 01:23:08.880]  собственно, вот по тому пути, да, v, линк от v, линк от
[01:23:08.880 --> 01:23:12.680]  линк от v и так далее, вплоть до корня, считается также
[01:23:12.680 --> 01:23:23.360]  в bfs и в алгоритмах карасик, считается внутри bfs, ну,
[01:23:23.360 --> 01:23:30.320]  считается очень просто, значит, knt от v, это, значит, нужно
[01:23:30.320 --> 01:23:34.640]  проверить, является она терминальной или нет, так,
[01:23:34.640 --> 01:23:39.440]  t от v точка терм, если терминальная, то нужно добавить единицу,
[01:23:40.320 --> 01:23:53.760]  плюс knt от линк от v, а поскольку у меня вот этот вот путь по су-всылкам, он содержит сначала v,
[01:23:53.760 --> 01:23:58.960]  потом линк от v, потом продолжение суфиксного пути для вершины линк от v, да, я просто много
[01:23:58.960 --> 01:24:04.760]  раз навешаю линк на вот эту штуку уже, то мне достаточно знать вот это вот knt и просто к нему
[01:24:04.760 --> 01:24:08.320]  прибавить 1 или 0, в зависимости от того, является ли терминальная вот эта вершинка v или нет.
[01:24:08.320 --> 01:24:13.200]  Если является, то прибавляю единицу, если не, если не является, то прибавляю 0,
[01:24:13.200 --> 01:24:20.960]  и просто остается knt от линк от v. Вот, ну и тем самым, смотрите, мы, во-первых, поняли,
[01:24:20.960 --> 01:24:25.760]  что все возможные, как бы, все возможные интересующие нас суфиксы, это всегда путь по
[01:24:25.760 --> 01:24:30.720]  су-всылкам, да, много раз нужно брать линк, чтобы рассмотреть вообще все возможные суфиксы,
[01:24:30.720 --> 01:24:36.160]  которые читаются в боре, и при этом количество мы также насчитали внутри алгоритмах карасик,
[01:24:36.160 --> 01:24:42.200]  внутри нашего вайла, да, knt от v, то есть количество терминальных на этом пути мы можем насчитать
[01:24:42.200 --> 01:24:47.320]  параллельно с тем, как мы насчитываем все го и все линки, тем самым каждый раз просто в нашем алгоритме,
[01:24:47.320 --> 01:24:57.720]  когда мы спускаем, когда мы как бы переходим в новую вершинку из v и минус 1 в v и v и. Мы просто
[01:24:57.720 --> 01:25:04.840]  добавляем knt для вот этой вершины, это то, сколько новых вхождений появилось в нашем тексте. Так,
[01:25:04.840 --> 01:25:07.800]  давайте закончим, в следующий раз добьем задачу штрих. Спасибо.
