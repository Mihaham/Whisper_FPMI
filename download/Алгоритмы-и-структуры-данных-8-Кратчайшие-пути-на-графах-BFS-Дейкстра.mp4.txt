[00:00.000 --> 00:13.880]  Здравствуйте, так мы переходим к небольшому разделу про кратчайшие пути в графах,
[00:13.880 --> 00:20.680]  значит все что было связано с DFS, ну что я хотел разобрать мы разобрали. Сегодня в
[00:20.680 --> 00:34.880]  следующий раз у нас будут про кратчайшие пути. Сюжет. Это алгоритмы BFS, Dijkstra,
[00:34.880 --> 00:40.800]  Floyd, Fort Belman, я звездочка. Такой у нас план на ближайшие две лекции.
[00:40.800 --> 00:54.600]  Значит начнем с определений. Пусть G, ну это граф, там ориентированный или не ориентированный,
[00:54.600 --> 01:02.040]  тогда собственно кратчайшим путем или просто расстоянием, да, минимальным расстоянием
[01:02.040 --> 01:06.560]  между двумя вершинами называется минимально возможное число ребер на пути от U до V.
[01:06.560 --> 01:26.040]  Тогда кратчайший путь от U до V это путь из U в V с минимальным числом ребер.
[01:26.040 --> 01:37.440]  Ну естественно кратчайших путей может быть несколько, если у вас есть несколько способов
[01:37.440 --> 01:45.640]  одинаковой длины попасть из УВ, они все тогда будут кратчайшими. Ну и расстояние, собственно
[01:45.640 --> 02:00.680]  distance от U до V это просто число ребер в этом пути. Dist УВ это число ребер в этом кратчайшем пути.
[02:00.680 --> 02:11.120]  Так это расстояние. Значит ну сразу понятно, что из определения вот эта вот штука может
[02:11.120 --> 02:16.360]  быть плюс бесконечность, если у нас нет никакого пути из УВ, если нет ни одного пути, то максимум берется
[02:16.360 --> 02:20.360]  по посту множеству, ссори, минимум берется по посту множеству, считаем, что минимум по посту
[02:20.360 --> 02:25.880]  множеству это плюс бесконечность. То есть эта штука может быть бесконечной. Так это было определение
[02:25.880 --> 02:30.600]  для невзвешенного графа, когда как бы все ребра имеют одинаковый вес единичка, когда каждое
[02:30.600 --> 02:45.640]  ребро дает сумму единицы. Дальше, что такое взвешенный граф? Значит это опять множество вершин, множество
[02:45.640 --> 02:56.240]  ребер, а также некая весовая функция ВВ, которая каждому ребрусу поставляет какое-то число. Значит ВЕ это
[02:56.240 --> 03:05.840]  граф, ну тоже любой ориентированный или не ориентированный. А ВВ, как функция из Е в Р, это весовая
[03:05.840 --> 03:11.880]  функция. Ну мы ее будем называть и своей функцией. По смыслу это просто отображение множества ребер
[03:11.880 --> 03:18.200]  в множество вещественных чисел. Значит тогда, ну дальше все определения наследуются. Крочайший путь
[03:18.200 --> 03:24.960]  это путь из УВ, на котором сумма весов всех ребер минимально возможна, соответственно расстояние это
[03:24.960 --> 03:34.280]  та самая минимально возможная сумма. Давайте я напишу так, что весом пути во взвешенном графе
[03:34.280 --> 03:48.160]  называется сумма весов его ребер. Напишу так, сумма ВВ от Е по всем Е из этого пути П. Если П это наш
[03:48.160 --> 03:54.160]  путь, мы проходим по всем ребрам на этом пути и складываем вот ВВ от них, то есть тот вес, который
[03:54.160 --> 04:01.280]  написан на этом ребре. Ну и дальше все то же самое, я давайте не буду это прописывать. Крочайший путь
[04:01.280 --> 04:06.880]  от УВ это такой путь от УВ, на котором вот это вот, вес которого минимально возможен, соответственно
[04:06.880 --> 04:11.440]  расстояние это тот самый минимально возможный вес на пути от УВ. И опять он может быть плюс
[04:11.440 --> 04:16.360]  бесконечность, если нет пути от УВ. То есть такое простое обобщение, представьте, что мы там на
[04:16.360 --> 04:20.840]  всех ребрах написали какие-то веса и соответственно теперь считаем не число ребер на пути, а сумму тех
[04:20.840 --> 04:25.320]  чисел, которые написаны. То есть за прохождение дороги у нас есть там какой-то штраф, какая-то
[04:25.320 --> 04:30.520]  стоимость, вот и мы хотим минимизировать суммарную стоимость, которую мы проходим по пути от УВ.
[04:30.520 --> 04:40.440]  Так, ну и собственно первый наш алгоритм, это алгоритм поиска крочайших путей в неориентированном
[04:40.440 --> 05:02.880]  графе. Поиска крочайших путей от одной вершины до всех в неориентированном графе. Это будет БФС.
[05:02.880 --> 05:22.760]  Расшифровывается это вот так, а значит поиск в ширину. Ну собственно вот эта вот ширина,
[05:22.760 --> 05:29.640]  как бы в первую очередь мы делаем поиск в ширину. Сейчас я объясню, что это значит.
[05:29.640 --> 05:35.880]  Идейно он работает следующим образом. Вот есть какая-то стартовершенка С, и мы хотим найти крочайшее
[05:35.880 --> 05:39.880]  расстояние от нее до всех остальных в нашем графе. Тогда давайте сделаем следующее. Ну понятно,
[05:39.880 --> 05:44.360]  что крочайшее расстояние от С до С это ноль, да, минимальная, ну минимальная, возможно, длина пути
[05:44.360 --> 05:50.640]  от С до само себя это ноль. Дальше, вот есть какие-то из С исходящие ребра. Понятно, что до них,
[05:50.640 --> 05:55.600]  до всех крочайшее расстояние это единица. Ну потому что расстояние ноль быть не может,
[05:55.600 --> 06:00.560]  потому что ни одна из них с С не совпадает, и есть путь длины 1. До них расстояние единичка.
[06:00.560 --> 06:06.560]  Дальше, давайте посмотрим все исходящие ребра из них, которые ведут в новую вершинке, то есть не
[06:06.560 --> 06:11.160]  ведут в С, не ведут в этот же самый слой. Да, это будет там опять какое-то еще другое множество
[06:11.160 --> 06:17.440]  вершинок. Понятно, что до них расстояние это двойка, потому что есть путь длины 2, нет пути длины 1,
[06:17.440 --> 06:22.360]  нет пути длины 0. Ну и так далее. Вот в этом будет такой очень простой. Мы просто так по
[06:22.360 --> 06:27.240]  слоям будем рассматривать все исходящие ребра. Если соответственно мы попадаем в какую-то новую
[06:27.240 --> 06:33.000]  вершинку, то мы однозначно определяем, что ее вес, расстояние до нее на единичку больше, чем расстояние
[06:33.000 --> 06:38.520]  вот до предыдущей. И поскольку эта вершина как бы новая, она раньше не была найдена, значит до нее
[06:38.520 --> 06:43.640]  найдено корректное расстояние. Что есть путь такой длины, и нет пути меньше длины, потому что все
[06:43.640 --> 06:50.760]  вершины на меньшем расстоянии мы уже нашли. Вот собственно так работает этот алгоритм BFS. Ну и в
[06:50.760 --> 06:55.040]  ширину значит, что как бы мы встали в вершинку, все ребра, которые из нее исходили, записали,
[06:55.040 --> 07:00.800]  потом значит для них, для всех тоже прошли все ребра, записали как бы во втором множестве и так
[07:00.800 --> 07:06.040]  далее. А DFS он наоборот, он как бы шел сначала вот по этой вот веточке, потом поднимался, шел по этой
[07:06.040 --> 07:10.760]  и так далее. То есть он как бы старался сначала в глубину, а этот сначала в ширину, он максимально
[07:10.760 --> 07:26.640]  раскрывает текущую вершину. Давайте. Так, я имею ввиду невзвешенным. Да, спасибо, это хорошее
[07:26.640 --> 07:34.680]  замечание. Тут глупость, конечно, написана. Спасибо. Невзвешенным. То есть когда все ребра имеют вес 1.
[07:34.680 --> 07:54.120]  Так, напишем код. Как всегда у нас граф будет храниться вектор и векторов. Для каждой вершины
[07:54.120 --> 08:01.080]  храним список ее соседей, то есть куда можно попасть за один шаг. Дальше будем хранить вектор
[08:01.080 --> 08:08.360]  расстояний. Для каждой вершины будем хранить насчитанное до нее кратчайшее расстояние. Давайте
[08:08.360 --> 08:14.920]  я его изначально заполню вот так вот. Что там будет n чисел, все равны плюс бесконечности. Давайте
[08:16.920 --> 08:21.400]  так и напишу, плюс бесконечность. То есть изначально считаем, что все кратчайшие пути не существуют,
[08:21.400 --> 08:31.000]  равны плюс бесконечности по весу. Дальше говорим, что dist от s это 0. Говорим, что встаем в стартовую
[08:31.000 --> 08:38.760]  вершинку, до нее кратчайшее расстояние точно 0. Значит кладем сюда нолик, заводим очередь вершин,
[08:38.760 --> 08:48.800]  которую хотим рассмотреть, и кидаем в нее s. И наш элдрейтам будет доставать просто по очереди
[08:48.800 --> 08:54.960]  вершинки из этого q. Достал вершинку, рассмотрел все исходящие ребра, и если они еще были не
[08:54.960 --> 09:00.800]  рассмотрены, то до них distance это плюс бесконечность. Тогда мы до них нашли кратчайшее расстояние,
[09:00.800 --> 09:07.680]  выставляем для них dist и кладем вот эти новые вершинки в очередь. Собственно код будет такой.
[09:07.680 --> 09:25.200]  Пока q не пусто, достаем оттуда первую вершинку, удаляем, рассматриваем все исходящие ребра,
[09:25.200 --> 09:40.440]  пытаемся обновить расстояние. Я напишу так. По всем tu пробегающим массив g от v. Значит,
[09:40.440 --> 09:44.920]  если distance от tu это плюс бесконечность, и это новая вершинка, до которой еще не найдено расстояние,
[09:44.920 --> 09:52.120]  тогда нужно туда положить правильный distance и положить tu в очередь. Наверное, я все-таки здесь
[09:52.120 --> 10:18.560]  не вмещусь, перейду на вторую доску. Если distance от tu это плюс бесконечность, тогда мы выставляем туда
[10:18.560 --> 10:27.280]  правильное значение, равное distance от v плюс 1. Потому что у нас есть путь до v вот такой длины,
[10:27.280 --> 10:31.160]  мы еще добавляем одно новое ребро, из-за этого длина увеличится ровно на единичку.
[10:31.160 --> 10:43.720]  Distance становится distance плюс 1. И добавляем q в очередь, q push tu. Так, раз-два. Кажется, все.
[10:43.720 --> 10:52.720]  Вот, ну и на этой картинке давайте посмотрим, что будет происходить. Мы изначально добавили s,
[10:52.720 --> 10:57.800]  первая вершина, которая обработается из очереди, будет вот эта самая s. Окей, ее достали,
[10:57.800 --> 11:03.280]  обработали. Рассмотрели все исходящие ребра. Для них, для всех вот этих вот вершинок изначально
[11:03.280 --> 11:07.800]  distance был плюс бесконечность, поэтому я теперь сюда ставлю единички и добавляю их в очередь.
[11:07.800 --> 11:13.040]  То есть, соответственно, s я из очереди удалил, а вот эти вершинки в очередь добавил. Дальше
[11:13.040 --> 11:17.160]  обрабатываем вот эту вот вершинку как первую в очереди. Рассматриваем все исходящие из нее
[11:17.160 --> 11:22.280]  ребра, для них выставляем distance равные двойке и кладем их тоже в очередь. Поэтому сейчас в очереди
[11:22.280 --> 11:26.800]  будет вот этот вот кусочек вершин и вот эти вот вершинки. Дальше это рассмотрится, добавится
[11:26.800 --> 11:30.840]  это, это рассмотрится, добавится вот эти, это рассмотрится, добавится вот эти. Мы перейдем по
[11:30.840 --> 11:35.840]  сути вот на этот второй уровень, потом от него перейдем на третий и так далее и так далее. Вот
[11:35.840 --> 11:43.400]  такая реализация, собственно, BFS. Значит, ну здесь все хорошо, а симптотика линейная будет опять.
[11:43.400 --> 11:50.080]  N это число вершины, N, M это число ребер. Потому что
[11:50.080 --> 11:54.640]  каждая вершина добавится в очередь, максимум один раз. Значит, каждое ребро рассмотрится
[11:54.640 --> 12:00.320]  опять-таки, максимум один раз. Потому что, ну, для каждого начала, вот если есть ребро,
[12:00.320 --> 12:04.980]  мы знаем, что начальный, начальный вершин этого ребра рассмотрится один раз. Значит, это ребро
[12:04.980 --> 12:12.980]  тоже рассмотрится максимум в один раз, ну и поэтому, да. Т.е. суммально. Вот этот вот фор по всем вершинкам
[12:12.980 --> 12:16.780]  он отработает за O от m, да, просто за число ребер. Каждый ребер рассмотрится один раз.
[12:16.780 --> 12:21.300]  Поэтому символитотика, конечно, линейная, как и, собственно, у всего, что у нас было до этого времени.
[12:21.300 --> 12:38.780]  Так, давайте попробуем доказать корректность. Возможно, она здесь как бы кажется очевидной,
[12:38.780 --> 12:56.220]  но давайте мы попробуем это плюс-минус формализовать. Сначала следующее. Пусть в какой-то момент времени
[12:56.220 --> 13:17.140]  dist от q.top равно какому-то числу k. Пусть в какой-то момент времени найдено расстояние до первой
[13:17.140 --> 13:23.860]  вишенки в очереди, это в точной стеке. Тогда мы покажем следующее, что на самом деле очередь
[13:23.860 --> 13:32.020]  выглядит следующим образом. Так, давайте я пронумеру. Значит, во-первых, во-первых,
[13:32.020 --> 13:37.580]  очередь выглядит следующим образом. Сначала идет несколько вершинок с distance равным k,
[13:37.580 --> 13:47.060]  потом идет несколько вершинок с distance равным k плюс 1. То есть в очереди всегда,
[13:47.060 --> 13:52.300]  как бы, состояние очереди всегда такое. Несколько вершинок с distance равным k,
[13:52.300 --> 14:02.020]  и потом несколько вершинок, возможно 0, на расстоянии ровно k плюс 1. Во-вторых,
[14:02.020 --> 14:13.660]  вот в этот момент времени, если distance для первой вишенки это k, то тогда все вершины
[14:13.660 --> 14:28.860]  на расстоянии меньше либо равно k уже обработаны, ну точнее, до них найдено правильное расстояние.
[14:28.860 --> 14:40.860]  Давайте я пишу так. Для всех вершин на расстоянии больше чем k найдено правильное расстояние дист.
[14:40.860 --> 14:52.900]  То есть если я вижу вершинку в начале очереди с distance равным k, то это значит,
[14:52.900 --> 14:57.620]  что все вершинки с distance не больше чем k уже как бы обработаны, и в них хранится
[14:57.620 --> 15:09.420]  в правильном значении дист. Так, ну и третье, если алгоритм когда-то выставляет какой-то дист,
[15:09.420 --> 15:15.380]  то он его сразу вставляет правильным. То есть если мы для какой-то вершинки v, вот в этой, скажем,
[15:15.380 --> 15:20.620]  для какой-то вершинки 2 кладем distance от v от 2 равно чему-то, то это присваивание правильное,
[15:20.620 --> 15:27.180]  и это вот distance, который мы находим, в точности равно расстоянию от v от s до 2. То есть если
[15:27.180 --> 15:39.180]  алгоритм присваивает distance от 2, то это верное значение, то он присваивает верное значение.
[15:39.180 --> 15:51.340]  Наш алгоритм никогда ничего не придумывает. Единственное, что вот отсюда следует,
[15:51.340 --> 15:59.900]  это что он для каких-то вершин может не найти правильный дист. То есть если он distance чему-то
[15:59.900 --> 16:04.540]  выставил, то это точно правильное значение. Единственное, что он может для каких-то вершин
[16:04.540 --> 16:08.700]  не найти правильный distance и оставить их плюс бесконечность. Но давайте посмотрим,
[16:08.700 --> 16:23.140]  что такого тоже быть не может. Так, давайте сначала вот это утверждение докажем собственной
[16:23.140 --> 16:27.340]  индукцией по нашему алгоритму. Вот давайте делать шаг алгоритма за шагом, шаг за шагом делаем,
[16:27.340 --> 16:31.220]  проверяем, что всегда выполняются вот эти три утверждения. Что если это было верно вначале,
[16:31.220 --> 16:36.580]  то это будет верно после каждого шага. Ну сначала нам нужна база, что это утверждение вообще верно.
[16:36.580 --> 16:43.780]  База, когда, собственно, очередь состоит только из вершинки s. Ну тогда все ясно,
[16:43.780 --> 16:52.420]  тогда k это 0, k это 0, да, distance от первого элемента очереди это 0. Дальше, как выглядит
[16:52.420 --> 16:58.220]  очередь? Ну там есть только одно число, одна вершина с distance равным 0. Это в частности очередь
[16:58.220 --> 17:02.780]  вот того вида, что сначала несколько нулей, потом несколько, возможно, 0 единиц. Это правильный
[17:02.780 --> 17:10.060]  вид очереди. Это у нас есть. Дальше. Все вершины на расстоянии меньше чем 0 обработаны, для них
[17:10.060 --> 17:15.220]  найден правильный distance. Но все вершины на расстоянии не больше чем 0 это только s, и для нее
[17:15.220 --> 17:22.900]  правильный distance мы знаем. Мы его в самом начале до вайла проставляем. Поэтому все вершины на
[17:22.900 --> 17:31.740]  расстоянии меньше равно 0 обработаны. Это тоже верно, потому что она только одна s, и мы ее изначально
[17:31.740 --> 17:41.460]  для нее выставляем правильный distance. Ну и третье. Я имею в виду, что вот к тому моменту,
[17:41.460 --> 17:47.980]  если в очереди distance от q.tоп равно k, тогда все, что мы делали до этого момента, мы все присваивания
[17:47.980 --> 17:54.420]  делали правильными. Мы сейчас сделали только одно присвоение, что distance от s равно 0. Собственно,
[17:54.420 --> 18:01.020]  это понятное дело верное присвоение, что все выполненные присваивания пока что корректны.
[18:01.020 --> 18:07.500]  Корректно.
[18:07.500 --> 18:12.620]  Ну теперь переход.
[18:12.620 --> 18:29.380]  Вот пусть в какой-то момент времени очередь имеет такой вид.
[18:29.380 --> 18:40.820]  Мы хотим показать, что когда мы обработаем эту вершинку первую, у нас будут по-прежнему
[18:40.820 --> 18:47.460]  сохраняться все три свойства. Так, ну давайте обработаем и поймем. Значит, первое свойство. Как
[18:47.460 --> 18:52.060]  поменяется наша очередь после обработки первой вершинки, после того как мы ее достанем из очереди,
[18:52.060 --> 18:57.300]  рассмотрим все исходящие ребра, и какие-то distance обновим, добавим их в очередь. Ну,
[18:57.300 --> 19:02.460]  понятное дело, что произойдет. Вот это удалится, и возможно в конец еще добавится несколько k плюс
[19:02.460 --> 19:08.180]  1, потому что у меня добавятся новые вершинки на расстоянии ровно k плюс 1, и я их добавлю в конец
[19:08.180 --> 19:14.980]  очереди. Значит, вид нашей очереди останется таким же, либо там будет несколько k, и потом
[19:14.980 --> 19:21.660]  несколько k плюс 1, либо сразу будут просто k плюс 1. Если, скажем, вот это была последняя k, то есть
[19:21.660 --> 19:27.820]  если, собственно, здесь была ровно одна вершина на таком расстоянии в очереди, мы ее обработали,
[19:27.820 --> 19:32.100]  удалили, осталось много вершин на одинаковом расстоянии. Поэтому структура в очереди осталась
[19:32.100 --> 19:37.220]  такой же, как, собственно, в соответствии со утверждением индукции, что сначала несколько одинаковых
[19:37.220 --> 19:44.060]  чисел, потом несколько чисел больше на один, чем вот это самое число. Первое условие верно. Второе.
[19:44.060 --> 19:52.540]  Второе. Значит, что все вершины на расстоянии больше чем k, для них корректно найдено расстояние.
[19:52.540 --> 20:03.820]  Так, ну смотрите, если у меня изначально в очереди было хотя бы две k-шки, тогда утверждение у меня
[20:03.820 --> 20:10.260]  ну, собственно, ничего нового не появляется. Если я знаю, что к этому моменту у всех вершин
[20:10.260 --> 20:14.420]  на расстоянии больше чем k все найдено, то после удаления мне нужно, чтобы выполнялось то же самое,
[20:14.420 --> 20:19.900]  но понять, что это будет верно. Ничего не поменялось, условие не сломалось. Единственный интересный
[20:19.900 --> 20:26.260]  случай, это когда у меня была кашка единственная, а потом шло несколько сразу k плюс одинов. Я хочу
[20:26.260 --> 20:31.900]  показать следующее, что к этому моменту, когда я удалю k, когда я целиком работаю, и, соответственно,
[20:31.900 --> 20:36.220]  в начале очереди будет вот эта вот вершина на расстоянии k плюс один, у меня будут корректно
[20:36.220 --> 20:41.860]  найдены все дисты до вершины на расстоянии не больше чем k плюс один. А то здесь у меня были только
[20:41.860 --> 20:45.780]  корректные на расстоянии не больше чем k, а здесь я утверждаю, что на расстоянии не больше чем k плюс один.
[20:45.780 --> 20:58.700]  Но это не сложно. Смотрите, что значит, что у меня были empirительно найдены все вершины на расстоянии
[20:58.700 --> 21:04.900]  больше к значит вот у меня когда-то в очереди были все вершины на расстоянии
[21:04.900 --> 21:16.180]  ровно к все вершины на расстоянии не больше к а сори ровно к а поскольку я
[21:16.180 --> 21:19.180]  для них нашел правильное расстояние по предложении индукции значит они
[21:19.180 --> 21:22.980]  когда-то были в очереди вот так подряд я их обработал к моменту куда обрабатываю
[21:22.980 --> 21:26.940]  последнюю кашку у меня все они побывали в очереди я их как бы все
[21:26.940 --> 21:31.740]  раскрыл то есть рассмотрел всех их соседей обновил дисты и я тогда утверждаю
[21:31.740 --> 21:34.980]  что у меня теперь в очереди лежат все вершины на расстояниях ровно к
[21:34.980 --> 21:38.880]  плюс 1 что после того как я рассмотрел все верхиниlands они ровно к у меня в
[21:38.880 --> 21:44.580]  очереди держат ровно все вершины расстояние капли с один все вершины на
[21:44.580 --> 21:54.540]  расстоянии ровно кап tous один так ну значит это почти очевидно
[21:54.540 --> 21:58.660]  Вот почему. Значит рассмотрим отсюда какую-то вершинку на расстоянии k плюс 1.
[21:58.660 --> 22:02.940]  Если она находится на расстоянии k плюс 1, то значит есть какой-то путь из s в
[22:02.940 --> 22:07.600]  с k плюс 1 ребром. Тогда, если я рассмотрю на нём предпоследнюю вершинку,
[22:07.600 --> 22:12.100]  какую-то u, тогда эта вершина находится на расстоянии ровно k. Да, понятно, что вот есть
[22:12.100 --> 22:15.620]  путь длины k и нет пути меньше длины, потому что иначе до v был бы путь
[22:15.620 --> 22:19.060]  меньше длины. Можно было бы приклеить последнее ребро и, соответственно, уменьшить
[22:19.060 --> 22:23.860]  значит у была где-то здесь значит у раскрыто поэтому такое
[22:23.860 --> 22:29.980]  ребро ув рассмотрено и для вершинки вы я нашел правильное расстояние вот мы
[22:29.980 --> 22:34.300]  сейчас доказали что любая вершина расстояние ровно ка плюс 1 лежит сейчас
[22:34.300 --> 22:38.100]  в очереди ну и наоборот любая здесь лежащая конечно же имеет дистанс равный
[22:38.100 --> 22:43.300]  ка плюс 1 потому что когда я ну как собственно как когда я какой-то
[22:43.300 --> 22:47.260]  дист выставляю это собственно можно вот отсюда вот взять что если я какой-то
[22:47.260 --> 22:51.540]  дист выставляет он правильно насчитывается значит действительно все вот эти вот
[22:51.540 --> 22:54.740]  вершинки это правильные вершины все множество шин расстояние ровно ка плюс
[22:54.740 --> 23:05.060]  1 так это это был второй шаг ну и последнее
[23:05.060 --> 23:20.900]  что все дисты которые я вставляю правильные да давайте это тоже поясним когда я
[23:20.900 --> 23:27.180]  обрабатываю первую вершинку из очереди вот эту вершинку с расстоянием ка я по
[23:27.180 --> 23:31.340]  сути перебираю все ребра из нее исходящие которые ведут в еще не
[23:31.340 --> 23:35.980]  посещенные вершины то есть вершины до которых я еще не знаю дистанции тогда я
[23:35.980 --> 23:39.340]  значит ставлю что у них у всех дистанции така плюс один вопрос почему это верно
[23:39.340 --> 23:45.900]  ну смотрите здесь не может быть дистанции меньше ровно ка потому что растут ка то
[23:45.900 --> 23:49.020]  все вершины на расстоянии меньше ну ка я уже обработал и в них лежит корректный
[23:49.020 --> 23:54.100]  дистанц по вот этому вот второму тому что я стер на что не может быть у них
[23:54.100 --> 24:00.220]  меньше ровно ка настоящие расстояния потому что по второму пункту я все такие
[24:00.220 --> 24:04.180]  уже обработал у них уже найдено корректное расстояние дистанции поэтому здесь хотя
[24:04.180 --> 24:07.540]  бы ка плюс один но с другой стороны здесь не больше чем ка плюс один потому что есть
[24:07.540 --> 24:11.260]  путь длины ка вот здесь вот который можно одним ребром дополнить до пути длины ка
[24:11.260 --> 24:17.820]  плюс один значит после обработки вершины ну во время обработки вот этой вершины первой
[24:17.820 --> 24:21.740]  в очереди действительно все дисты которые я проставляю они проставятся правильными
[24:21.740 --> 24:31.300]  значениями ка плюс один то что надо я туда и поставлю вроде все вот мы доказали что эти
[24:31.300 --> 24:37.740]  три свойства выполняются ну и отсюда собственно вследствие что все дисты мы правильно найдем
[24:37.740 --> 24:47.340]  все дисты найдутся верно наверное это можно там наверное можно сказать что это очевидно и
[24:47.340 --> 24:54.100]  можно было не доказывать но мы заодно поняли вообще как выглядит очередь в каждую минуту времени
[24:54.100 --> 25:01.420]  пока доказывали вопросы
[25:01.420 --> 25:09.620]  хорошо
[25:09.620 --> 25:22.020]  думаю нет ну типа непонятно как потому что вот представьте у вас такая картинка какая-то
[25:22.020 --> 25:29.620]  вы беремность выходить на расстоянии вот дайте вершинки кратчайшие
[25:29.620 --> 25:40.980]  короче на самом деле если вы так будет сделать то вы у вас экспоненциальное время работы будет
[25:40.980 --> 25:46.780]  вы по сути перебираете все пути на самом деле в дефессе ну если вы то есть вы дошли вот так вот
[25:46.780 --> 25:50.820]  нашли какое-то расстояние потом нашли другое и вам нужно от этой вышины опять перезапуститься да что
[25:50.820 --> 25:57.060]  там сначала было двойка потом единица вам нужно заново обойти все ее по дереву вот и это может
[25:57.060 --> 26:12.460]  выразиться в экспоненту так тогда значит следующий алгоритм это 0 ка бфс это случай когда все
[26:12.460 --> 26:20.940]  ребра в графе имеют вес целый от нуля до к давайте напишу так что весовая функция ребра отображает
[26:20.940 --> 26:33.060]  множество 0 1 и так далее к значит тогда работает следующая идея смотрите мы опять будем использовать
[26:33.060 --> 26:40.740]  очереди только в этот раз не одну а ну типа n к значит первое замечание такое что если все веса
[26:41.120 --> 26:45.940] uri все ребра имеют вес максимум ка тогда максимальный вес который нам который может
[26:45.940 --> 26:56.340]  получиться он не больше мы n-1 множество к все дисты не больше чем н-1 мозг на кeed
[26:56.340 --> 27:01.080]  потому что если есть какой-то путь от удове то можно считать что в нем максимум и минус одно
[27:01.080 --> 27:08.220]  ребро ну давайте это поясни в да что вот если есть какой-то путь можно считать что в нем
[27:08.220 --> 27:14.780]  максимум n-1 ребро. Ну, действительно, мы знаем, что если есть путь, то есть простой путь по вершинам.
[27:14.780 --> 27:21.100]  Значит, все вот эти вершины попарно различны. То есть каждое ребро, когда мы проходим по
[27:21.100 --> 27:27.940]  ребру, дает нам новую вершинку, значит, суммарно ребер я прошел не больше, чем n-1. Потому что изначально
[27:27.940 --> 27:33.420]  была u, каждое ребро увеличивает число пройденных вершин на 1, значит их суммарно максимум n-1. Значит,
[27:33.420 --> 27:40.380]  есть путь длины максимум n-1, значит его вес максимум n-1 умножить на k. Если вот здесь все веса
[27:40.380 --> 27:47.180]  максимум k, то значит его вес максимум вот такой. Поэтому мы точно знаем, что ответ всегда не больше,
[27:47.180 --> 27:55.220]  чем вот столько. Соответственно, в обычном BFS все дисты максимум n-1. Тогда давайте сделаем
[27:55.220 --> 28:04.340]  следующее. Мы заведем вот столько очередей. Давайте я для удобства напишу здесь nk, меньше nk. Давайте
[28:04.340 --> 28:18.940]  для удобства заведем nk очередей. Пронумеруем их там, значит это будет q0, q1, q с индексом nk-1. И будем
[28:18.940 --> 28:24.140]  делать следующее. Изначально в нулевую очередь положим s, стартовую вершину, из которой мы хотим
[28:24.140 --> 28:29.900]  найти все дисты. А дальше будем обрабатывать ну собственно так же, как раньше. Вот есть некая вершинка
[28:29.900 --> 28:35.620]  s, есть из нее исходящие ребра. Они могут быть разных весов. Ну скажем, вот здесь есть какое-нибудь
[28:35.620 --> 28:42.020]  ребро веса 3. Ну тогда понятно, что если у меня было до s какое-то расстояние x, то до этой вершинки
[28:42.020 --> 28:46.900]  у меня есть расстояние x-3. Да, возможно, давайте я здесь напишу, вот тут было какое-то x, тогда
[28:46.900 --> 28:51.980]  здесь x плюс 3. Возможно это не кратчайшее, но нам нужно по крайней мере такие пути учесть, что если,
[28:51.980 --> 28:58.540]  скажем, кратчайший путь до вот этой вершинки проходит через s, то это расстояние равно x плюс 3.
[28:58.540 --> 29:06.980]  Значит давайте просто тогда в очередь с номером x плюс 3 добавим эту вершинку u. Что если мы нашли
[29:06.980 --> 29:13.140]  какое-то расстояние, более короткое, чем раньше было известно до этой вершинки, то я просто добавляю
[29:13.140 --> 29:18.220]  в очередь с этим, ну с номером равным этому самому расстоянию. И потом я до нее опять дойду,
[29:18.220 --> 29:23.980]  ее обработаю, рассмотрю все ребра, исходящие из нее, положу опять их в соответствующую очередь и так далее.
[29:23.980 --> 29:29.660]  То есть теперь у меня как бы именно что по слоям все будет. Сначала рассмотрим все вершины на расстоянии 0,
[29:29.660 --> 29:34.140]  потом на расстоянии 1, 2 и так далее, и они все, когда я рассматриваю очередную вершинку, они
[29:34.140 --> 29:42.300]  добавляют какие-то новые вершины в более низкие очереди с большими номерами. Так, давайте тоже
[29:42.300 --> 29:55.060]  какой-нибудь код напишем. Есть у меня столько очередей. Далее q0 push s dist s равно 0. Ну а все остальные
[29:55.060 --> 30:06.060]  опять плюс бесконечности. Все остальные равны плюс бесконечности. Дальше запускаем, скажем, цикл x по
[30:06.060 --> 30:19.820]  номеру очереди. Так, меньше чем nk. Пока x-я очередь не пустая. Неверно, что qx.empty.
[30:19.820 --> 30:34.980]  Начнем делаем похожую штуку. Достаем первую вершину. qx front и qx.pop делаем сразу.
[30:34.980 --> 30:45.820]  Рассматриваем все ребра. Вот, ну теперь ребра уже характеризуется не только как бы конечной
[30:45.820 --> 30:50.580]  вершины ребра, но еще и весом. Поэтому давайте я буду считать, что у меня ребро задается какой-то
[30:50.580 --> 30:56.020]  структуркой, которая хранит все параметры, там откуда, куда и какой вес. И я вот сейчас в цикле
[30:56.020 --> 31:05.460]  пройдусь просто все, ну пройдусь по всем ребрам. g от v вот так сделаю. Я считаю, что есть какая-то
[31:05.460 --> 31:11.300]  структурка edge, да, и собственно мы там итератором пробегаемся по вектору всех ребер, исходящих из v.
[31:26.020 --> 31:44.340]  Да, да, да, вот как раз это я сейчас хотел сделать. Так, давайте, значит, заведем изначально какой-то
[31:44.340 --> 31:58.420]  вектор used and false. Значит, он для каждой вершины говорит, правда ли, что мы ее раскрыли, то есть правда ли,
[31:58.420 --> 32:04.260]  что мы ее когда-то достали из очереди и прошлись по всем ребрам. Так, давайте я вот это вот сотру.
[32:04.260 --> 32:21.980]  Напишу здесь, если used от v, тогда continue, а иначе used от v равно true, вот так. Значит, смысл такой,
[32:21.980 --> 32:26.980]  смотрите, у нас в принципе на самом деле каждая вершина может быть во многих очередях, да,
[32:26.980 --> 32:31.220]  потому что, смотрите, вот, например, мы до нее нашли сначала расстояние x плюс 3, а потом там через
[32:31.220 --> 32:36.060]  какую-то другую вершину нашли более короткое расстояние, и она тогда будет жать в двух очередях,
[32:36.060 --> 32:41.620]  например, в x плюс 3 и в какой-то с еще более маленьким номером. И понятно, что нам нужно рассматривать
[32:41.620 --> 32:47.260]  только когда мы ее впервые нашли, когда до нее, собственно, расстояние найдено кратчайше. Вот,
[32:47.260 --> 32:52.060]  поэтому, собственно, если мы ее достали из какой-то очереди с большим номером, то я тогда, ну,
[32:52.060 --> 32:57.660]  это проверяю, да, если мы ее уже видели, то пропускаем, вот, и иначе помещаем использованное,
[32:57.660 --> 33:03.580]  что вот мы ее сейчас впервые достали. Так, и дальше вот этот вот проход по всем исходящим ребрам.
[33:15.580 --> 33:24.900]  Ну, да, значит, если distance от e.tu, то есть куда ведет это ребро, больше, чем distance от v,
[33:24.900 --> 33:33.580]  плюс стоимость этого ребра, e.kost я напишу, тогда нужно обновить и положить в новую очередь.
[33:33.580 --> 33:50.220]  Distance от e.tu равно distance от v плюс e.kost. И надо добавить вершину e.tu в очередь вот с этим номером,
[33:50.220 --> 33:54.540]  потому что мы как бы до нее нашли более короткое расстояние, поэтому мы сейчас хотим ее
[33:54.540 --> 34:01.580]  добавить в эту самую очередь вот, ну, с номером равным этому расстоянию. То есть q с индексом
[34:01.580 --> 34:10.060]  Distance от e.tu, push e.tu. Вот, кажется, все.
[34:10.060 --> 34:34.180]  Так, значит, я утверждаю, что, я утверждаю следующее, что когда мы начинаем рассматривать
[34:34.180 --> 34:41.460]  х-ую очередь, да, то есть когда х становится равным к какому-то значению, у меня в х-ой очереди лежит
[34:41.460 --> 34:48.060]  следующее. Все вершины на расстоянии ровно х, кроме, возможно, тех, которые достижены из них по
[34:48.060 --> 34:55.540]  ребрам нулевого веса. Значит, еще раз, когда х, когда я вхожу вот в этом цикле, когда х
[34:55.540 --> 35:03.300]  приобретает какое-то новое значение, очередь qx имеет следующий вид. Здесь находятся все вершины
[35:03.300 --> 35:10.900]  на расстоянии ровно х, кроме, возможно, нескольких тех, которые достижены из них по ребрам нулевого веса.
[35:10.900 --> 35:15.460]  У нас же есть, да, возможно, ребра веса ноль. То есть, возможно, вот здесь вот есть какие-то
[35:15.460 --> 35:19.420]  ребра веса ноль, которые тоже, по сути, надо сюда добавить. Ну, ничего страшного, мы их, когда вот
[35:19.420 --> 35:23.540]  эти вершинки будем рассматривать, мы все равно все вот эти вот ребра, исходящие веса ноль, будем
[35:23.540 --> 35:28.740]  видеть и добавлять их в эту же самую очередь. То есть, вот здесь, если если e.coast это ноль,
[35:28.740 --> 35:33.420]  тогда мы добавим e.coast в ту же самую очередь, в которой находится v. То есть, в текущую очередь
[35:33.420 --> 35:39.620]  добавим. Значит, здесь все, кроме тех, которые достижены по ребрам веса ноль, и мы их тоже добавим,
[35:39.620 --> 35:46.140]  когда будем вот таким образом рассматривать, раскрывать все наши вершинки. Так, ну а дальше,
[35:46.140 --> 35:52.900]  соответственно, почему это всегда верно? Ну, там понятно, что это верно вначале, что есть изначально
[35:52.900 --> 35:59.260]  есть вершинка s в нулевой очереди, и понятно, что все вершины на расстоянии ноль это либо s, либо
[35:59.260 --> 36:03.100]  достижимые из s по ребрам нулевого веса. И мы их тогда все найдем, когда будем раскрывать вершинку s
[36:03.100 --> 36:11.060]  и там исходящие из нее. Как-то так. Ну и, соответственно, дальше, если я, скажем, правильно нашел все
[36:11.060 --> 36:16.580]  выше, то есть все вершинки на расстоянии меньше ну x я правильно обработал, тогда в частности, ну понятно,
[36:16.580 --> 36:23.420]  что вот есть там какая-то следующая очередь x плюс один. Ну, вообще, для всех более низких вершин
[36:23.420 --> 36:28.580]  distance строго больше, чем x, потому что все меньше равные x я уже обработал. Ну и, соответственно,
[36:28.580 --> 36:34.260]  что значит, что у вершинки расстояние там x плюс один? Значит, из какой-то из этих вершин есть
[36:34.260 --> 36:39.420]  ребро такое, что, ну в общем, сумма вот этой расстоянии плюс вес этого ребра это ровно x плюс один.
[36:39.420 --> 36:44.380]  Ну, значит, собственно, я ее в эту очередь добавил. Все, ну тут давайте там особо без доказательства,
[36:44.380 --> 36:48.940]  можно считать, что это без доказательства. Ну, какое-то такое интуитивное понимание вроде есть,
[36:48.940 --> 36:53.660]  что вот когда мы обработали первые x очередей, у нас правильно найдены все вершины на расстоянии
[36:53.660 --> 36:58.460]  больше, чем x. Вот они тут лежат, они обработаны. Значит, все остальные, ну что такое вершина
[36:58.460 --> 37:02.620]  расстояния там x плюс сколько-то? Это значит, нужно откусить последнее ребро, посмотрите,
[37:02.620 --> 37:08.620]  его вес, попасть в вершину расстояния меньше, чем x, ее обработали, значит, это ребро раскрыто,
[37:08.620 --> 37:11.540]  значит, в эту очередь добавлено на правильную вершину. Вот и все.
[37:11.540 --> 37:38.220]  Вопросы? Так, ну давайте тогда напишем симптотику. Здесь симптотика такая, м плюс nk. Значит,
[37:38.220 --> 37:46.100]  nk, потому что у меня, ну как минимум, я изначально завожу nk очередей, ну или там по-другому, можно
[37:46.100 --> 37:51.060]  сказать, что каждая вершина в худшем случае добавится в k очередей, потому что вот если есть
[37:51.060 --> 37:56.420]  какая-то вершинка v, и я, ну допустим, представьте, что я изначально нашел до нее там какое-то расстояние
[37:56.420 --> 38:04.460]  x плюс k по там ребру веса k, потом я нашел до нее расстояние x плюс k минус 1 по какому-то другому
[38:04.460 --> 38:11.060]  ребру, ну видимо там величный k минус 1 и так далее. То есть в худшем случае вот эту вершинку я для нее
[38:11.060 --> 38:17.380]  могу обновлять расстояние k раз, когда я рассматриваю ребра все меньше и меньше веса, я получаю все меньше
[38:17.380 --> 38:22.180]  и меньше расстояние до v, поэтому она может побывать в нескольких очередях, но максимум в k, точнее видимо
[38:22.180 --> 38:28.900]  в k плюс 1. Отсюда возникает вот это вот слагаемое nk. Ну а m опять из-за того, что каждая вершина на
[38:28.900 --> 38:35.020]  самом деле раскроется, то есть вот за счет вот этих меток, за счет вот этих меток, у меня каждая вершина
[38:35.020 --> 38:41.420]  будет для каждой вершины вот этой цикла обработана с максимумом один раз. То есть ходящие
[38:41.420 --> 38:45.380]  ребра обработаны только один раз, когда она впервые отмечена, впервые обработана в какой-то
[38:45.380 --> 38:52.780]  очереди. Поэтому каждое ребро рассмотрится один раз, значит по ребрам у меня вот ну просто плюс m слагаемое.
[38:52.780 --> 39:01.860]  То есть этот алгоритм в принципе хорош, если у вас k там небольшое, ну там. Часто вообще k равно
[39:01.860 --> 39:07.580]  единице и так называемый 0.1 bfs, когда у вас в графе ребра только вес 0 или 1. Вот, ну для произвольного k
[39:07.580 --> 39:17.540]  тоже работает, если n на k не очень велико. Окей. Так, да, симпотика, корректность, ну корректность
[39:17.540 --> 39:28.580]  без доказательств на уровне идеи. Вроде все. Значит дальше двусторонний bfs. Двусторонний bfs.
[39:28.580 --> 39:36.340]  Ну здесь название говорит само за себя. Только здесь немножко другую задачу мы решаем. Мы находим
[39:36.340 --> 39:45.260]  расстояние не от s до всех, а от s до t. Раньше мы по сути находили кратчайшее состояние от s до всех
[39:45.260 --> 39:50.740]  остальных. Теперь хотим от s такое-то фиксированное t найти. Ну тогда давайте просто с двух сторон наш
[39:50.740 --> 39:57.220]  bfs пускать. Да, вот давайте сначала рассмотрим все вершины на расстоянии 1 от s, потом, ну давайте я
[39:57.220 --> 40:03.180]  ребра буду рисовать. Стрелочки, то есть. Затем найдем все вершины, из которых есть подлинный 1 в t.
[40:03.180 --> 40:12.940]  Потом отсюда рассмотрим все вершины на расстоянии 2. Здесь наоборот все ребра ведущие в это множество
[40:13.180 --> 40:18.180]  получится. Множество вершин на расстоянии 2 от t и так далее, пока они не пересекутся. И вот когда-то
[40:18.180 --> 40:25.180]  впервые найдется вершина, до которой мы нашли путь из s и из которой нашли путь в t. То есть мы
[40:25.180 --> 40:32.700]  будем пускать наш bfs как бы вот так с двух сторон, пока какая-то вершина не обработается из обеих
[40:32.700 --> 40:40.460]  половинок. И с левой, и справа. Тогда я утверждаю, что минимальный ответ это, ну собственно минимум по
[40:40.460 --> 40:49.740]  всем обработанным вершинкам, distance от s плюс distance до t. Ну давайте это опишем. Запускаем.
[40:49.740 --> 41:03.420]  Я напишу параллельно. На самом деле имеется ввиду по итерациям последовательно, что сначала
[41:03.420 --> 41:08.380]  нашли все вершины на расстоянии 1 здесь, потом на расстоянии 1 здесь, на расстоянии 2 здесь, на расстоянии 2
[41:08.380 --> 41:12.540]  здесь и так далее. Ну не то что параллельно мы запускаем там два потока, если у вас были какие-то
[41:12.540 --> 41:17.740]  параллелки. Нет, просто ну значит, грубо говоря, один шаг алгоритма здесь, один шаг алгоритма здесь,
[41:17.740 --> 41:35.420]  один здесь, один здесь. Пока не найдется вершина, обработанная с обеих концов, с обеих сторон,
[41:35.420 --> 41:47.060]  с обеих сторон. Тогда ответ, истинное расстояние от s до t, это следующая величина, минимум по всем
[41:47.060 --> 42:06.660]  вершинам v. Давайте напишу так, dist s до v плюс dist t от v, вот так. Что это такое? Это два массива, которые
[42:06.660 --> 42:12.900]  я, соответственно, dist s это те расстояния, которые я нахожу идя от s, dist t это те расстояния, которые
[42:12.900 --> 42:21.660]  я нахожу идя от t по обратным ребрам. То есть два bfs, один работает с массивом dist s расстояния,
[42:21.660 --> 42:27.940]  другой работает с массивом dist t расстояния. И тогда, чтобы найти правильное расстояние, нужно
[42:27.940 --> 42:32.140]  просто перебирать все вершины, которые вы здесь видели, и взять минимально возможную сумму. То есть
[42:32.140 --> 42:36.700]  что вы взяли любую вершинку v, вы знаете вот это расстояние, знаете вот это расстояние, складываете
[42:36.700 --> 42:50.020]  их и по всем возможным вершинам перебираете, это будет ваш минимум. Нет, нет-нет-нет, невзвешенный,
[42:50.020 --> 43:04.540]  невзвешенный. То есть это можно обобщить на там 0k bfs, но давайте считать, что он невзвешенный.
[43:04.540 --> 43:18.660]  Так, ну почему это, почему это верно? Почему то, что мы найдем, это действительно расстояние от s
[43:18.660 --> 43:24.300]  до t. Ну смотрите, давайте считать, что мы сделали как бы по d шагов слева и справа. То есть мы
[43:24.300 --> 43:31.780]  сделали дейтерации bfs из s и дейтерации вот по этому обратному графу из t. Это значит, что вот
[43:31.780 --> 43:37.540]  если наш bfs обрубить после дейтерации, это значит, что мы правильно нашли все вершины на расстоянии
[43:37.540 --> 43:48.140]  не больше чем d из s и правильно нашли все вершины на расстоянии не больше чем d от t. Согласны? Мы
[43:48.140 --> 43:52.580]  правильно нашли все вершины на расстоянии не больше чем d из s и из t. Значит дальше мы рассматриваем
[43:52.580 --> 43:56.980]  все вершины, складываем вот эти две суммы, то есть по сути те вершины, которые попали сюда и сюда,
[43:56.980 --> 44:02.020]  мы вот здесь рассматриваем, потому что для остальных там будет плюс бесконечность какой-то из
[44:02.020 --> 44:08.580]  чисел. Складываем два числа, берем из них минимум. Так, почему найдется правильный ответ?
[44:08.580 --> 44:22.940]  Ну давайте скажем следующее, пусть с обеих сторон выполнено по дейтерации bfs. Пусть с обеих сторон
[44:22.940 --> 44:42.700]  выполнено по дейтерации bfs. То есть найдены все вершины на расстоянии не больше чем d из s и
[44:42.700 --> 44:55.580]  найдены все вершины на расстоянии не больше чем d до t. Все вершины с dist sv меньше равно d и все
[44:55.580 --> 45:04.140]  вершины или dist vt меньше равно d. Все такие вершины найдены, у них насчитано правильное расстояние
[45:04.140 --> 45:10.380]  в этом случае от s до v, в том случае от v до t. Почему мы тогда нашли правильный путь, когда взяли
[45:10.380 --> 45:21.180]  такой минимум? Так, ну во-первых, понятно следующее, что когда мы берем вот такой минимум,
[45:21.180 --> 45:28.780]  этот минимум будет точно не больше чем 2d. Потому что раз у меня вот эти вот, ну по сути,
[45:28.780 --> 45:33.980]  я вот так расширял наши облачка слева и справа, они когда-то пересеклись. Они пересеклись на какой-то
[45:33.980 --> 45:40.160]  вершинке, на расстоянии не больше чем d отсюда, не больше чем d отсюда. Значит ответ точно не
[45:40.160 --> 45:45.020]  больше чем d плюс d. Есть вот этот путь, есть вот этот путь. Каждый из них не больше чем d, значит
[45:45.020 --> 45:51.820]  ответ точно не больше чем 2d. Тогда давайте покажем, что любой путь длины меньше чем 2d мы точно
[45:51.820 --> 46:12.700]  увидим. Докажем, что любой путь длины меньше чем 2d мы точно увидим. Ну увидим, значит, что на
[46:12.700 --> 46:18.420]  нем есть какая-то вершинка v, для которой вот эта штука равна вот этой самой длине пути. Почему это
[46:18.420 --> 46:28.660]  так? Вот есть путь какой-то из s в t, длины меньше чем 2d. Почему тогда я его обнаружу? Очень просто.
[46:28.660 --> 46:35.380]  Давайте просто возьмем d эту на нем вершину, то есть вершину такую, что вот здесь d ребер. Соответственно,
[46:35.380 --> 46:39.980]  эта вершина на расстоянии d находится от s. Ну извините, если она находится на расстоянии d от s,
[46:39.980 --> 46:46.020]  тогда она обработана и до нее насчитана правильный дист, вот этот вот дист s правильно до нее насчитан.
[46:46.020 --> 46:51.980]  Вот эта вершинка v на расстоянии d. Для нее правильно насчитан дист s с одной стороны. С другой стороны,
[46:51.980 --> 46:57.700]  раз длина пути меньше чем 2d, значит вот здесь вот длина пути меньше чем d. Раз суммы этих двух чисел
[46:57.700 --> 47:03.860]  меньше чем 2d, поэтому тогда здесь меньше чем d. Ну значит опять, она обработана, если мы рассматриваем
[47:03.860 --> 47:12.380]  вот этот обратный bfs из t. Поэтому до нее правильно насчитан дист t. Профит. То есть еще раз, если мы
[47:12.380 --> 47:16.420]  предполагаем, что есть какой-то более короткий путь, чем вот тот, он точно имеет вот такую маленькую длину,
[47:16.420 --> 47:21.180]  но с другой стороны, если мы рассмотрим d эту на нем вершину, то до нее правильно насчитана и вот это
[47:21.180 --> 47:25.980]  расстояние, и вот это. Значит в частности в том минимуме этот путь участвует. Поэтому все пути,
[47:25.980 --> 47:31.300]  как бы кандидаты на ответ, у меня будут учтены. Значит минимум я точно найду, расстояние точно найду.
[47:31.300 --> 47:39.540]  Согласны? Тут надо еще там, если совсем строго хотим, то нам надо рассмотреть случай, когда на
[47:39.540 --> 47:48.020]  этом пути нету d этой вершины, то есть длина этого пути меньше чем d, но тогда расстояние от s до t
[47:48.020 --> 47:52.140]  вообще меньше чем d, и на самом деле наш алгоритм должен был закончиться на предыдущей итерации,
[47:52.140 --> 47:59.620]  потому что, то есть я, получается, за d-1 итерацию дохожу от s до t, значит тогда вершинка t будет
[47:59.620 --> 48:05.300]  обработана на d-1 итерации, но с другой стороны обработана на нулевой привод, когда мы шли
[48:05.300 --> 48:13.300]  здесь, поэтому алгоритм должен был бы раньше завершиться. Вот вроде так. Теперь вопрос зачем,
[48:13.300 --> 48:27.940]  если у нас есть обычный BFS. Например, затем, если у нас граф, грубо говоря, экспоненциально растет,
[48:27.940 --> 48:33.740]  или другими словами, каждая вершина, вот если вы стоите в какой-то вершинке, то из нее есть,
[48:34.100 --> 48:42.260]  скажем, константа, какое-то одинаковое число новых рёбер, новых вершин она порождает по а штук.
[48:42.260 --> 48:47.300]  Каждая вершина, когда вы идёте BFS с лево направо, каждая вершина вам раскрывается в а новых вершин,
[48:47.300 --> 48:54.780]  то есть, скажем, у s степень какая-то а, затем каждый из них дает еще а исходящих рёбер, ну и так далее.
[48:54.780 --> 49:03.180]  Вот, ну пусть такой граф у вас есть. Тогда, если бы вы запустили обычный BFS и пытались бы найти
[49:03.340 --> 49:11.580]  путь из s в t, и между ними пусть какое-то расстояние d, тогда вам пришлось бы рассмотреть примерно вот
[49:11.580 --> 49:17.820]  столько вершин, а в степени d. Ну, там, видимо, даже еще больше. В общем, тут будет какая-то сумма
[49:17.820 --> 49:23.860]  геометрической прогрессии, да, 1, а, а в квадрате и так далее, до а в степени d. Ну, короче, вот главное
[49:23.860 --> 49:29.580]  слагами а в степени d. Это обычный BFS, если мы просто идем вот так с лево направо. Вот, а двусторонний BFS,
[49:29.580 --> 49:38.300]  как он будет работать на таком графе? Ну, смотрите, то есть мы считаем, что вот есть s, такие
[49:38.300 --> 49:44.180]  три ребра из нее, вот так вот, ну не три, а там а-рёбер. И то же самое с t. В t входят три ребра, в
[49:44.180 --> 49:47.940]  каждой из них входят по три ребра и так далее. То есть тут как бы он и с лево направо экспоненциально
[49:47.940 --> 49:53.420]  растет, и справа налево экспоненциально растет. Тогда до того момента, чтобы они пересеклись,
[49:53.420 --> 50:00.540]  нам достаточно пройти d пополам шагов примерно. Ну, там d плюс 1 пополам, возможно. И поэтому тогда
[50:00.540 --> 50:08.740]  здесь человечем, который я рассмотрю, будет всего лишь 2 на а в степени d пополам. Ну, это сильно лучше,
[50:08.740 --> 50:14.100]  да, то есть если там у вас а и d какие-то достаточно большие, то это, ну, по сути, улучшение в корень.
[50:14.100 --> 50:21.740]  По сравнению вот с этим, это это корень. Корень из вот этого как раз а в степени d пополам. Вот,
[50:21.740 --> 50:29.300]  поэтому двухсторонний BFS, он вот так хорошо работает, если вы быстро экспоненциально растете при
[50:29.300 --> 50:33.500]  проходе из любой вершинки или, наоборот, в любую вершинку вот по этим обратным рёбам.
[50:33.500 --> 50:41.340]  Так, да, ну и при этом тут надо еще сказать, что там в идеале, чтобы действительно было вот такое
[50:41.340 --> 50:46.660]  значительное различие, нам нужно весь граф хранить в какой-то хедж таблице, потому что, то есть если
[50:46.660 --> 50:51.260]  скажем, у нас граф экспоненциальный, и мы все равно храним там дист s и дист t как какие-то массивы,
[50:51.260 --> 50:55.900]  то мы, конечно, никакого выигрыша не получим, нам все равно нужно там вот столько памяти хранить. Но
[50:55.900 --> 51:00.620]  чтобы этого не делать, и чтобы как бы обрабатывать только те вершины, до которых мы дошли, нам нужна
[51:00.620 --> 51:06.020]  какая-то хедж таблица вот здесь. Чтобы, соответственно, не хранить дисты до всех, а только до тех, которые
[51:06.020 --> 51:17.860]  мы видим. Нам нужна хедж таблица. Ну, то есть как один из возможных вариантов. Вот, и, значит,
[51:17.860 --> 51:23.580]  такое в принципе бывает, вот в контесте будет задачка на это, это, грубо говоря, когда у вас есть,
[51:23.580 --> 51:30.180]  ну там, не знаю, грубо говоря, какая-то игра, и вы можете из каждой позиции делать, ну какой там,
[51:30.180 --> 51:34.500]  не знаю, из каждой позиции у вас есть ровно четыре хода. То есть, соответственно, у вас тогда каждая
[51:34.500 --> 51:38.980]  вершинка, это какая-то позиция в игре, вы можете из нее сделать четыре хода. Ну, соответственно,
[51:38.980 --> 51:43.780]  наоборот, если у вас есть какая-то позиция, то она достигается из каких-то других четырех возможных
[51:43.780 --> 51:49.700]  вершин. Поэтому как раз у вас вот такой экспоненциальный рост есть, ну там, слева направо и справа налево,
[51:49.700 --> 52:03.620]  поэтому, ну, в каком-то смысле лучше было бы использовать двусторонний BFS. Ну, а в худшем случае,
[52:03.620 --> 52:14.100]  конечно, это тоже просто n плюс m, линейная по размеру графа алгоритм. Ну, потому что, там, в худшем
[52:14.100 --> 52:17.340]  случае, если граф какой-то обычный, то вы просто пройдете половину вершин слева, половину вершин
[52:17.340 --> 52:22.500]  справа. Понятно, что у вас ничего от этого в терминах азимтотики не изменится, но только если
[52:22.500 --> 52:33.060]  у вас какая-то такой специфичка структура, это может быть полезно. Так, хорошо, значит,
[52:33.060 --> 52:48.180]  тогда мы переходим к алгоритму Dijkstra. Это случай взвешенного графа с произвольными не отрицательными
[52:48.180 --> 52:58.660]  весами ребер. Значит, функция W, она из ребер в, ну, давайте я так напишу, ноль плюс бесконечность. То есть,
[52:58.660 --> 53:06.540]  все веса ребер не отрицательные какие-то числа. Давайте это прям пропишу. Веса ребер не отрицательные
[53:06.540 --> 53:15.860]  числа. С отрицателями Dijkstra работать не умеют. Они все должны быть строго не отрицательные,
[53:15.860 --> 53:27.700]  больше нуля. Так, алгоритм довольно простой. Значит, смотрите, в каждом инфремене все вершины будут
[53:27.700 --> 53:36.100]  разбиты на два кластера, использованные и неиспользованные. Для использованных вершин я
[53:36.100 --> 53:44.740]  считаю, что я знаю корректный дистанц. То есть, задачу опять я решаю от s до всех. От s до всех
[53:44.740 --> 53:51.820]  находим кратчащее расстояние. Найти dist. Значит, вот есть какое-то множество использованных, я до них
[53:51.820 --> 53:57.500]  знаю корректное кратчащее расстояние. А здесь я знаю только какую-то оценку на кратчащее расстояние.
[53:57.500 --> 54:02.220]  Тогда алгоритм работает так. Из всех вот этих вот неиспользованных найти вершину с минимальным
[54:02.220 --> 54:10.140]  дистанцем, который я нашел, какой-то v, до которой дистанц насчитанный минимально возможный. Дальше я
[54:10.140 --> 54:14.900]  считаю ее использованной. Считаю, что до нее насчитанное расстояние правильно. То есть,
[54:14.900 --> 54:20.460]  по сути расширяю мое множество использованных нововершенкой v. А дальше рассматриваю все
[54:20.740 --> 54:28.260]  исходящие ребра из v и обновляю dist для всех этих концов. Очень похоже на то, что было у нас в 0kbfs,
[54:28.260 --> 54:33.260]  что я нахожу вершину первую, как бы не обработанную, с минимально возможным дистанцем до нее
[54:33.260 --> 54:39.740]  насчитанным. Раскрываю ее, то есть рассматриваю все исходящие ребра и обновляю dist для концов этих
[54:39.740 --> 54:45.780]  ребер. Ну и, соответственно, перехожу в цикле. Потом дальше у меня будет из вот этих вот, из вот
[54:45.780 --> 54:50.780]  этих вершин находиться вершина с минимальным дистом. Она будет объявляться как использованная,
[54:50.780 --> 54:54.980]  то есть до нее правильная насчитанная расстояние. Ее раскрываем, то есть рассматриваем все исходящие
[54:54.980 --> 55:15.540]  ребра, ну и так далее. Итак, алгоритм. Значит, изначально все дисты
[55:15.540 --> 55:32.220]  это плюс бесконечности, дистатес это 0, все вершины неиспользованные. Все вершины неиспользованные.
[55:32.220 --> 55:46.620]  Дальше. Пока есть хотя бы одна неиспользованная, пока есть неиспользованные вершины, мы говорим,
[55:46.620 --> 55:54.540]  что пусть v это неиспользованная вершина с минимальным значением dist, неиспользованная
[55:54.540 --> 56:13.700]  вершина с минимальным значением dist от v. Помечаем ее использованной. Помечаем v использованной. Ну а
[56:13.700 --> 56:21.540]  дальше вот то, что называю раскрытие вершины в цикле по всем ребрам исходящим из v, обновляем
[56:21.540 --> 56:42.940]  dist для конца этого ребра. Обновить dist от e.tu. Точно так же, как у нас было в 0kbfs. Я
[56:42.940 --> 56:50.060]  прохожу по всем ребрам исходящим из v. Если distance от v плюс вес ребра меньше, чем distance от
[56:50.060 --> 56:56.460]  e.tu, тогда я этот самый distance e.tu обновляю. Уменьшаю собственно с учетом вот этого последнего
[56:56.460 --> 57:13.180]  ребра из v в tu. Вот это будет называться раскрытие вершины для краткости. Раскрытие v. Ну все. Я взял
[57:13.180 --> 57:16.780]  вершину с минимальным dist. Говорю, что это теперь правильное расстояние. Она помеченная,
[57:16.780 --> 57:22.780]  использованная. И рассматриваю все исходящие ребра, обновляю dist. И дальше возвращаюсь в цикл,
[57:22.780 --> 57:25.420]  нахожу первую неиспользованную с минимальным dist. И так далее, и так далее.
[57:25.420 --> 57:47.340]  Так, значит, со сколько это можно реализовать? Асимптотика. Тут есть две принципальные
[57:47.340 --> 57:57.820]  реализации. Первая это просто за n квадрат. Очень просто. Давайте мы для каждой вершины явно хранить
[57:57.820 --> 58:03.100]  вот эту пометку использования использованная. Там какой-то просто булливский флаг used. Чтобы
[58:03.100 --> 58:08.940]  найти вершину v с минимальным значением distance, которая не использована, я просто прохожусь по
[58:08.940 --> 58:13.660]  всем вершинам неиспользованным. То есть по всем прохожу. Если она неиспользованная, то тогда пытаюсь
[58:13.660 --> 58:18.060]  обновить вот эту, то есть нахожу минимальную вот эту вот dist от v за линейное время. То есть эта штука
[58:18.060 --> 58:25.180]  будет работать за линию, просто проход по всем вершинам. Вот. Ну а дальше, суммарно время работы
[58:25.180 --> 58:33.100]  раскрытия всех вершин, это от m. Суммарно от m. Потому что каждой вершины будет помечено использованной
[58:33.100 --> 58:38.220]  максимум один раз. Значит, каждое ребро рассмотрено максимум один раз. Поэтому суммарно все раскрытия
[58:38.220 --> 58:45.220]  работают за линейное по числу ребер время. Ну и последнее, это что итерации в цикле while у меня
[58:45.220 --> 58:52.620]  максимум n. Не больше, чем n. Ну точнее там ровно n, видимо, будет. Ну не важно. Не больше, чем n
[58:52.620 --> 58:58.340]  итерации. Потому что на каждой итерации я помечаю какую-то неиспользованную использованную. И while
[58:58.340 --> 59:03.660]  работает ровно столько, пока есть неиспользованные вершины. Значит, суммарно итерации максимум n.
[59:03.660 --> 59:12.540]  Поэтому есть слагаемое от m. Все раскрытия работают за от m. Плюс слагаемое n квадрат, потому что я n раз
[59:12.540 --> 59:17.500]  нахожу минимум. Из этих двух понятно дело, что n квадрат максимальная, потому что мы считаем,
[59:17.500 --> 59:22.300]  что в графе нет красных ребер. Значит, m всегда меньше, чем n квадрат. Ребер не может быть больше, чем
[59:22.300 --> 59:35.660]  квадрат от числа вершин, если нет красных ребер. Это первое, да, просто линейный поиск минимума на
[59:35.660 --> 59:50.740]  каждой итерации. На каждой итерации. Другой подход работает за m лог n. И здесь нам нужно более
[59:50.740 --> 59:58.920]  хитро искать минимум. А именно искать мы его будем с помощью кучи. Тех куч, которые мы рассматриваем в
[59:58.920 --> 01:00:05.020]  первом семестре. Смотрите, что у нас есть. Давайте у меня в какой-то куче, в бинарной куче, лежат все
[01:00:05.020 --> 01:00:11.740]  неиспользованные вершины, которые сортируются в порядке убывания дистатвы. То есть в корне лежит
[01:00:11.740 --> 01:00:17.940]  неиспользованный вершина с минимальным дистанцием. Дальше, что мне нужно? Мне нужно находить минимум в
[01:00:17.940 --> 01:00:24.300]  куче. Это корень. В случае бинарной кучи это корень getMin. Дальше, мне нужно делать extractMin,
[01:00:24.300 --> 01:00:28.580]  потому что вершину нужно пометить использованный, соответственно удалить из кучи. Удалить
[01:00:28.580 --> 01:00:33.780]  минимальное значение из кучи. А еще мне нужно делать decrease key, потому что вот здесь вот, когда я
[01:00:33.780 --> 01:00:40.100]  обновляю distance, когда я раскрываю вершину, обновляю дисты, я могу их только уменьшать. Дисты, они
[01:00:40.100 --> 01:00:44.540]  могут только уменьшаться, то есть если у меня был какой-то путь до e.to и я нашел более короткий,
[01:00:44.540 --> 01:00:52.300]  тогда я его уменьшаю. Значит мне в куче нужно, точнее в моей структуре, мне нужны три операции getMin,
[01:00:52.300 --> 01:01:09.220]  extractMin и decrease key. Там еще в каком-то начале надо было сделать build, создать кучу на n элементах
[01:01:09.220 --> 01:01:15.780]  вот по тем значениям дистов. Но это куча, это куча. Там бинарная, биномиальная, какая хотите.
[01:01:15.780 --> 01:01:21.860]  Вот, соответственно, ну там давайте build я буду игнорирует, build работает за линейное время у нас.
[01:01:21.860 --> 01:01:29.980]  Вот, getMin работает за единицу в бинарной куче по крайней мере, extractMin за логарифом от размера
[01:01:29.980 --> 01:01:33.740]  кучи, а в куче у нас максимум n элементов всегда, потому что каждая вершина один раз.
[01:01:33.740 --> 01:01:42.260]  Decrease key работает за логарифом. Причем сколько раз нам нужно будет делать эти операции? Вот эти по n раз,
[01:01:42.260 --> 01:01:47.580]  getMin и extractMin нужно делать n раз столько, сколько итерации Вайля, а это суммарно m раз.
[01:01:47.580 --> 01:01:53.980]  Decrease key работает, ну как бы, decrease key связан с обработкой ребра, поэтому суммарно декризов будет
[01:01:53.980 --> 01:02:01.780]  максимум m. Ну поэтому видим, что у нас здесь будет n раз log n плюс m log n. Понятно, что обычно m
[01:02:01.780 --> 01:02:09.460]  больше чем n, поэтому здесь обычно остается только вот это вот главное слагаемое. Здесь пишется m log n.
[01:02:09.460 --> 01:02:15.780]  Ну можно для там, для честности написать что-то типа m плюс n log n, что если у вас граф очень маленький,
[01:02:15.780 --> 01:02:21.420]  в смысле, в смысле ребер в нем мало, тогда у вас там вот это слагаемое может быть больше, n log n
[01:02:21.420 --> 01:02:25.740]  может быть больше чем m log n. Ну можно тогда писать вот такое, но давайте я все-таки вот это буду писать
[01:02:25.740 --> 01:02:32.540]  как основное, потому что я считаю, что m оно у нас больше чем n. Потому что, значит, у нас вообще
[01:02:32.540 --> 01:02:36.540]  граф не связан и можно тогда взять какую-то его отдельную компоненту связанности и в ней отдельно
[01:02:36.540 --> 01:02:44.500]  работать. Так, понятно откуда такая симптотика получилась? Вот, ну и последнее, что на самом деле
[01:02:44.500 --> 01:02:48.660]  здесь можно использовать не бинарную кучу, то есть мы использовали бинарную кучу, можно использовать
[01:02:48.660 --> 01:02:54.260]  какую-нибудь другую, типа куча фибоначи. Мы ее не рассматривали, ну давайте напишем, как у меня будет
[01:02:54.260 --> 01:03:09.860]  симптотика. Значит, еще раз, да, главные операции такие, экстракт бинарный нужно сделать m раз,
[01:03:09.860 --> 01:03:22.900]  декриз ки, так декриз ки, нужно сделать m раз. Так вот, в фибоначевой куче экстракт работает
[01:03:22.900 --> 01:03:34.420]  амортизировано за алгорифм, а декриз амортизировано за единицу от фибоначевой кучи. Значит,
[01:03:34.420 --> 01:03:49.860]  тогда суммарное время работы будет m плюс n лог n. Вот, ну у фибоначевой кучи хорошо тем,
[01:03:49.860 --> 01:03:54.300]  что у него как раз декриз ки амортизировано за единицу, и в том случае, когда m сильно больше
[01:03:54.300 --> 01:03:58.900]  чем n, то есть декризов больше, чем экстрактов, тогда у меня, соответственно, декриз работает
[01:03:58.900 --> 01:04:04.100]  суммарно за m, а экстракты за n лог n. И по сравнению с m лог n, это, ну, довольно значимое улучшение,
[01:04:04.100 --> 01:04:09.940]  потому что если я скажу m сильно больше, чем n, то я тогда теперь не больше множителя умножать на
[01:04:09.940 --> 01:04:24.700]  лог n, а меньше, да, только n умножая на лог n, а m на лог n я не умножаю. Вот. Она большая, да,
[01:04:24.700 --> 01:04:30.780]  но амортизация во-первых, во-вторых, о, большое, поэтому. Но в любом случае мы это писать не будем,
[01:04:30.780 --> 01:04:36.820]  но с точки зрения теории, если мы рассматриваем поведение на реально больших нм, там миллионы,
[01:04:36.820 --> 01:04:41.580]  миллиарды вершин, тогда, да, вот эта симптомика будет лучше, чем бинарная куча, но как бы у нас,
[01:04:41.580 --> 01:04:49.060]  в наших таких учебных задачках, конечно, нам такое не нужно, нам будет всегда хватать бинарной кучи,
[01:04:49.060 --> 01:04:58.900]  или биномиальной, какая вам больше нравится, за m лог n. Так, корректность. Почему этот алгоритм
[01:04:58.900 --> 01:05:28.260]  всегда находит правильные ответы для всех вершин? Корректность. Сейчас скажу.
[01:05:28.900 --> 01:05:43.500]  Я хочу доказать следующее утверждение, что вот, ну, у меня, понятное дело, в каждом инфремене,
[01:05:43.500 --> 01:05:47.860]  после каждой трассы моего алгоритма, у меня есть использованные вершины, которые, как бы говорю,
[01:05:47.860 --> 01:05:51.860]  что я до них уже нашел правильное расстояние. Есть неиспользованные, до которых есть только какая-то
[01:05:51.860 --> 01:05:57.340]  оценка на расстоянии, да, для них dist от v это не точный ответ, а какая-то пока что оценка на
[01:05:57.340 --> 01:06:00.980]  ответ, оценка сверху на ответ, что я нашел до них какой-то путь, возможно, есть более короткие,
[01:06:00.980 --> 01:06:08.020]  которые я пока не учел. Так вот, я утверждаю следующее, что пусть в какой-то момент времени,
[01:06:08.020 --> 01:06:24.740]  давайте не v, а u, в какой-то момент времени, u это неиспользованные вершины. Такая что?
[01:06:24.740 --> 01:06:36.500]  Один из кратчайших путей от s до u не содержит других неиспользованных вершин. Один, ну, в смысле,
[01:06:36.500 --> 01:06:47.420]  какой-то, один из кратчайших путей от s до u не содержит других неиспользованных.
[01:06:47.420 --> 01:07:07.980]  Тогда distance от u правильно посчитан. Тогда distance от u, который мы насчитываем нашим алгоритме,
[01:07:07.980 --> 01:07:15.660]  равно правильному значению dist s u. То есть, напоминаю, dist s u это определение просто расстояния
[01:07:15.660 --> 01:07:20.700]  от s до u, а distance от u в квадратных скобках, то, что мы в алгоритме находим, это то, что наш алгоритм
[01:07:20.700 --> 01:07:32.700]  пытается выдать в качестве ответа для вершинки u. Так, вот, я это формулировал. Ну, это плюс-минус
[01:07:32.700 --> 01:07:37.260]  очевидно, потому что смотрите, что значит, что есть кратчайший путь от s до u, который не содержит других
[01:07:37.260 --> 01:07:42.060]  неиспользованных. Значит, он сначала как-то петляет по множеству использованных, потом берет и за одно
[01:07:42.060 --> 01:07:49.100]  ребро сразу попадает в u, да, и больше никаких других не посещает. Согласны? Дальше, если я по индукции
[01:07:49.100 --> 01:07:54.820]  буду доказывать, что в множестве использованных лежат всегда правильные ответы, что для них,
[01:07:54.820 --> 01:08:00.860]  для всех distance, которые я нашел, всегда правильный, тогда, ну, понятное дело, я как бы знаю, получается,
[01:08:00.860 --> 01:08:10.060]  вот это кратчайшее расстояние. Я знаю кратчайшее расстояние от s до u, например. Знаю кратчайшее
[01:08:10.060 --> 01:08:16.180]  расстояние distance от s до y. Ну и тогда понятно, что нужно просто одно ребро приклеить, но оно как бы
[01:08:16.180 --> 01:08:23.540]  обработается, когда я буду раскрывать y. Значит, в момент, когда я раскрываю y, у меня в u положится
[01:08:23.540 --> 01:08:37.780]  правильный ответ. Вот, значит, я использую такое утверждение, что если v использованное, то, ну опять, да,
[01:08:37.780 --> 01:08:45.540]  distance от v равно distance от s до v. То есть это, собственно, мы хотим показать, что все вершины, когда они
[01:08:45.540 --> 01:08:49.940]  переносится в разряд использованных, до них правильно щепочет на distance. Так вот, если это верно какой-то
[01:08:49.940 --> 01:08:55.020]  итерации, вот сейчас для них для всех начнется правильное расстояние. Тогда все вот такие вершины
[01:08:55.020 --> 01:08:59.980]  справа лежащие, неиспользованные, до которых кратчайший путь не содержит других неиспользованных,
[01:08:59.980 --> 01:09:06.620]  тогда для них вот это тоже верно. Потому что я знаю кратчайший путь от s до y, до предпоследней
[01:09:06.620 --> 01:09:11.820]  вершины этого пути. y когда-то был раскрыт, когда он помечался использованным, значит это ребро
[01:09:11.820 --> 01:09:18.540]  рассмотрелось и, соответственно, до u я нашел кратчайшее расстояние. То есть этот путь учтен. Вот.
[01:09:18.540 --> 01:09:27.300]  Значит, теперь осталось показать, что когда я достаю v из неиспользованных с минимальным
[01:09:27.300 --> 01:09:37.580]  distance, я до нее нашел правильный ответ. Ну пусть это не так. Пусть в какой-то момент
[01:09:41.820 --> 01:09:59.740]  алгоритм помечает использованной вершину v, для которой distance насчитан неправильно. То есть
[01:09:59.740 --> 01:10:07.340]  distance найденный в алгоритме строго больше, чем distance sv. Ну понятно, он не может быть меньше,
[01:10:07.340 --> 01:10:11.020]  потому что все, что мы делаем в алгоритме, это, понятно, делать только оценка сверху на правильное
[01:10:11.020 --> 01:10:16.660]  расстояние. Я никогда, я не придумаю несуществующих путей, я только рассматриваю какие-то пути,
[01:10:16.660 --> 01:10:20.660]  пытаюсь их продлить существующими ребрами. Потому что поэтому в другую сторону неравенства быть
[01:10:20.660 --> 01:10:25.940]  точно не может. Так вот пусть я использованный помечаю какую-то такую вершину distance v больше,
[01:10:25.940 --> 01:10:43.860]  чем distance v. Окей, рассмотрим настоящий кратчайший путь от s до v. Поскольку вот это вот верно,
[01:10:43.860 --> 01:10:51.540]  то в этом пути обязательно есть какая-то другая неиспользованная, потому что если бы в ней не
[01:10:51.540 --> 01:11:01.100]  было неиспользованных, то у меня было бы точно вот это вот равенство. Здесь квантор всеобщности,
[01:11:01.100 --> 01:11:07.820]  что если у вот такова, что есть какой-то путь такой, тогда вот это верно. То есть любой вершины у,
[01:11:07.820 --> 01:11:11.580]  для которой существует путь неиспользующий других неиспользованных, тогда для нее distance
[01:11:11.580 --> 01:11:20.540]  правильно посчитан. Так вот, значит вернемся. Вот пусть мы v выбираем в соответствии с тем,
[01:11:20.540 --> 01:11:24.820]  как наш алгоритм, ее выбирает минимальный distance по неиспользованному, и пусть у нее
[01:11:24.820 --> 01:11:29.660]  неверно посчитан distance. Тогда рассматриваем кратчайший путь настоящий. Он обязательно содержит
[01:11:29.660 --> 01:11:33.820]  какую-то другую неиспользованную, потому что если бы не содержал, то вот по этому
[01:11:33.820 --> 01:11:40.980]  утверждению у нас был бы distance равный. Значит он выглядит как-то так. Вот есть s, вот есть v,
[01:11:40.980 --> 01:11:45.820]  и этот кратчайший путь ходит как-то так. Сначала он как-то здесь что-то делает, потом перемещается
[01:11:45.820 --> 01:11:49.620]  в неиспользованные, там как-то ходит здесь, возможно возвращается, как-то так петляет,
[01:11:49.620 --> 01:11:55.620]  и доходит до v. Причем есть какая-то другая вот здесь вершина. Давайте рассмотрим первую
[01:11:55.620 --> 01:12:12.100]  неиспользованную на этом пути. Пусть у первая неиспользованная на этом пути. Тогда, поскольку
[01:12:12.100 --> 01:12:18.580]  вот этот начальный отрезок моего пути является кратчайшим путем от s до u, если бы он не являлся,
[01:12:18.580 --> 01:12:22.820]  можно было бы этот путь опять сократить, и тогда был бы еще более кроткий путь от s до v. Так вот,
[01:12:22.820 --> 01:12:26.980]  это получается кратчайший путь до u, который не использует других неиспользованных вершин,
[01:12:26.980 --> 01:12:39.700]  кроме u. Значит, я для u нашел правильное расстояние. Путь от s до u не содержит других неиспользованных,
[01:12:39.700 --> 01:12:50.140]  других неиспользованных. Значит, мой алгоритм нашел правильное расстояние dist at u. Dist at u
[01:12:50.140 --> 01:12:56.700]  равно dist s u. Согласны? То есть, был какой-то путь, я взял первую неиспользованную,
[01:12:56.700 --> 01:13:02.140]  тогда для нее правильный пощитный ответ. Ну а дальше уже все просто. Мы понимаем,
[01:13:02.140 --> 01:13:09.140]  что вот это не больше, чем dist s v, потому что кратчайший путь от s до v отличается от кратчайших
[01:13:09.140 --> 01:13:14.100]  путей от s до u, дописыванием каких-то ребер вот здесь. Ну и поскольку они все не отрицательные,
[01:13:14.100 --> 01:13:18.020]  distance мог только вырасти. Такого неравенства следует из-за того, что все ребра не отрицательны.
[01:13:18.020 --> 01:13:30.780]  Так, ну и вот это меньше, по предположению, чем dist s v. Получается противоречие. Мы показали,
[01:13:30.780 --> 01:13:35.620]  что distance от u меньше, чем distance от v, а v была такая, что она не использована с минимальным
[01:13:35.620 --> 01:13:49.420]  dist. А мы показали, что из другая не использована с меньшим dist, противоречие. Сейчас мы доказали
[01:13:49.420 --> 01:13:57.180]  корректность dx. Смотрите, два шага здесь. Первое замечание такое, что вот просто рассмотрим
[01:13:57.180 --> 01:14:02.100]  какой-то момент в выполнении нашего алгоритма. Вот есть использованные, есть неиспользованные.
[01:14:02.740 --> 01:14:07.780]  Если u это какая-то неиспользованная, вот просто пусть ус가지вольно неиспользованная такая,
[01:14:07.780 --> 01:14:12.020]  что до нее есть крайней Idi.♪ потт неиспользующей других неиспользованных. Тогда я утверждаю,
[01:14:12.020 --> 01:14:17.540]  что это GWG найдено к радости. Это мы, вроде, как доказали, потому, что, если здесь у меня все
[01:14:17.540 --> 01:14:21.300]  найдено по индукции, по предположению индукции, здесь все найдено, правильную расстояния найдены,
[01:14:21.300 --> 01:14:25.860]  тогда от S до Y известно крершу расстояния, Y раскрывается, соответственно это ребро
[01:14:25.860 --> 01:14:29.860]  это ребро учитывается, я до У нахожу кратчайшее расстояние.
[01:14:29.860 --> 01:14:32.860]  Почему не может быть что-то более короткое,
[01:14:32.860 --> 01:14:36.860]  используя еще раз, не используя кратчайшие?
[01:14:36.860 --> 01:14:41.860]  Потому что я... сейчас.
[01:14:41.860 --> 01:14:45.860]  Вот еще раз, да, до У есть несколько кратчайших путей.
[01:14:45.860 --> 01:14:48.860]  Я говорю, что пусть один из них, один из кратчайших,
[01:14:48.860 --> 01:14:50.860]  не использует других неиспользованных.
[01:14:50.860 --> 01:14:55.860]  Нет путей меньшего веса.
[01:14:55.860 --> 01:14:58.860]  Есть этот кусок, который мы просто заметили.
[01:14:58.860 --> 01:15:00.860]  Дальше предполагаем, что наш алгоритм некорректен,
[01:15:00.860 --> 01:15:02.860]  до их стране корректная.
[01:15:02.860 --> 01:15:04.860]  Это значит, что в какой-то момент мы достаем вершину В
[01:15:04.860 --> 01:15:06.860]  неиспользованную, такую, что вот эта выполняется.
[01:15:06.860 --> 01:15:08.860]  Для нее найдено расстояние неверное,
[01:15:08.860 --> 01:15:10.860]  не совпадает с истинным.
[01:15:10.860 --> 01:15:13.860]  Тогда рассматриваем настоящий кратчайший путь от С до В,
[01:15:13.860 --> 01:15:16.860]  вот этот вот, вот он, такой петляющий.
[01:15:16.860 --> 01:15:18.860]  Дальше, поскольку выполняется такое неравенство,
[01:15:18.860 --> 01:15:20.860]  то на нем обязательно есть какая-то другая неиспользованная,
[01:15:20.860 --> 01:15:23.860]  потому что если бы не было, то было бы равенство.
[01:15:23.860 --> 01:15:26.860]  Окей, рассмотрим на этом пути первую неиспользованную У.
[01:15:26.860 --> 01:15:28.860]  Пусть У это первая неиспользованная.
[01:15:28.860 --> 01:15:30.860]  Ну а дальше, значит, мы понимаем, что до нее distance правильно посчитано,
[01:15:30.860 --> 01:15:33.860]  что distance У равно distance У по тому замечанию.
[01:15:33.860 --> 01:15:35.860]  Это не больше, чем distance В, потому что отличается
[01:15:35.860 --> 01:15:37.860]  дописанием каких-то ребер в конце,
[01:15:37.860 --> 01:15:39.860]  и это по предположению меньше, чем distance В.
[01:15:39.860 --> 01:15:41.860]  Значит, distance У имеет меньше, меньше distance В.
[01:15:41.860 --> 01:15:44.860]  Противоречие с тем, что В это минимальная вершина,
[01:15:44.860 --> 01:15:47.860]  минимальная неиспользованная по дисту.
[01:15:51.860 --> 01:15:53.860]  Хорошо.
[01:16:03.860 --> 01:16:05.860]  И, наконец, последний алгоритм на сегодня,
[01:16:05.860 --> 01:16:07.860]  это двусторонний алгоритм Dijkstra.
[01:16:10.860 --> 01:16:12.860]  Двусторонний алгоритм Dijkstra.
[01:16:15.860 --> 01:16:17.860]  Работает очень похоже на то,
[01:16:17.860 --> 01:16:19.860]  как мы, собственно, делали двусторонний BFS.
[01:16:19.860 --> 01:16:21.860]  Задача опять.
[01:16:21.860 --> 01:16:23.860]  Есть две вершины, S и T.
[01:16:23.860 --> 01:16:25.860]  Нужно найти кратчайший путь из S в T.
[01:16:25.860 --> 01:16:28.860]  Не из S до всех, как мы делали в обычном алгоритме Dijkstra.
[01:16:28.860 --> 01:16:31.860]  А именно от S до T есть начальная вершина, есть конечная,
[01:16:31.860 --> 01:16:33.860]  а между ними нужно найти кратчайшее состояние.
[01:16:33.860 --> 01:16:36.860]  Работает очень похоже на обычный BFS.
[01:16:36.860 --> 01:16:39.860]  Ну, по сути, мы просто параллельно, в кавычках,
[01:16:39.860 --> 01:16:43.860]  запускаем Dijkstra по обычным ребрам из S
[01:16:43.860 --> 01:16:45.860]  и по обратным ребрам из T.
[01:16:45.860 --> 01:16:47.860]  То есть те ребра, которые ведут в T.
[01:16:47.860 --> 01:16:49.860]  Вот так вот, справа-налево как бы.
[01:16:51.860 --> 01:16:53.860]  Что значит параллельно?
[01:16:53.860 --> 01:16:55.860]  Значит, у нас есть, по сути, две кучи.
[01:16:55.860 --> 01:16:59.860]  Куча для вот этих вершин, которые из S обрабатываются,
[01:16:59.860 --> 01:17:01.860]  и куча вершин, которые обрабатываются из T.
[01:17:01.860 --> 01:17:03.860]  Есть у меня две кучи,
[01:17:03.860 --> 01:17:06.860]  две бинарные кучи, например.
[01:17:06.860 --> 01:17:08.860]  Я смотрю на их корни,
[01:17:08.860 --> 01:17:10.860]  то есть на минимальные из дистов.
[01:17:10.860 --> 01:17:13.860]  То есть это минимально неиспользованный из S,
[01:17:13.860 --> 01:17:15.860]  это минимально неиспользованный из T.
[01:17:15.860 --> 01:17:17.860]  Выбираю из них минимум и раскрываю.
[01:17:17.860 --> 01:17:19.860]  То есть если скажем вот это меньше,
[01:17:19.860 --> 01:17:21.860]  чем вот это,
[01:17:21.860 --> 01:17:23.860]  то я рассматриваю эту вершинку,
[01:17:23.860 --> 01:17:25.860]  достаю ее, экстрактиваю из кучи,
[01:17:25.860 --> 01:17:26.860]  раскрываю ее.
[01:17:26.860 --> 01:17:28.860]  Иначе, если мне нравится в другую сторону,
[01:17:28.860 --> 01:17:30.860]  я, наоборот, экстрактиваю вот это,
[01:17:30.860 --> 01:17:32.860]  удаляю вершинку из правой доли
[01:17:32.860 --> 01:17:34.860]  и раскрываю ее по обратным ребрам.
[01:17:36.860 --> 01:17:38.860]  И так делаю до тех пор,
[01:17:38.860 --> 01:17:40.860]  пока какая-то вершина не будет обработана
[01:17:40.860 --> 01:17:42.860]  и исключена из обеих куч.
[01:17:45.860 --> 01:17:52.860]  Значит, параллельный запуск с двух сторон.
[01:17:57.860 --> 01:18:06.860]  Обрабатываем вершину с минимальным дистанцием.
[01:18:06.860 --> 01:18:08.860]  То есть из этих двух выбираем минимальную
[01:18:08.860 --> 01:18:10.860]  и ее раскрываем.
[01:18:10.860 --> 01:18:12.860]  То есть либо раскрываем по прямым ребрам,
[01:18:12.860 --> 01:18:14.860]  либо раскрываем, наоборот, по обратным ребрам.
[01:18:14.860 --> 01:18:17.860]  То есть я изначально завожу список всех ребер,
[01:18:17.860 --> 01:18:19.860]  ведущих в каждую вершину,
[01:18:19.860 --> 01:18:21.860]  и теперь ее в обратную сторону раскрываю.
[01:18:21.860 --> 01:18:23.860]  И завершаемся,
[01:18:25.860 --> 01:18:27.860]  когда какая-то вершина будет удалена,
[01:18:27.860 --> 01:18:29.860]  обработана из обеих куч.
[01:18:32.860 --> 01:18:34.860]  Когда какая-то вершина
[01:18:37.860 --> 01:18:39.860]  удалится
[01:18:39.860 --> 01:18:41.860]  из обеих куч.
[01:18:41.860 --> 01:18:43.860] impotent.com
[01:19:05.860 --> 01:19:07.860]  Ну и соответственно ответ
[01:19:07.860 --> 01:19:22.860]  Это опять то же самое, минимум по всем вершинам, dist s до v плюс dist t от v.
[01:19:22.860 --> 01:19:33.860]  То есть я иду слева направо, храню dist s по ребрам слева направо от s, иду справа налево от t, храню все dist t, расстояние от текущей до t.
[01:19:33.860 --> 01:19:41.860]  И соответственно ответ это минимум вот таких сумм, что я сначала от s добираюсь до v, а потом от v до t.
[01:19:41.860 --> 01:19:43.860]  Так, ну опять нужна корректность.
[01:19:43.860 --> 01:19:50.860]  То есть со симптотикой здесь то же самое, что если ваш граф вот такой, что он как бы экспенциально растет,
[01:19:50.860 --> 01:19:55.860]  из каждой вершины есть там, грубо говоря, константа, ребер влево и константа, ребер, наоборот, вправо.
[01:19:55.860 --> 01:20:00.860]  Тогда, ну то же самое, что если мы так параллельно запускаем, то как бы мы встречимся где-то на серединке,
[01:20:00.860 --> 01:20:03.860]  соответственно рассмотрим там корневое число вершин.
[01:20:03.860 --> 01:20:07.860]  И тоже опять нам нужны какие-то х-таблицы, чтобы получить выигрыш по времени.
[01:20:07.860 --> 01:20:11.860]  Но в худшем случае, конечно, вы просто рассмотрите n пополам вершин слева, n пополам вершин справа,
[01:20:11.860 --> 01:20:14.860]  и никакого выигрыша не получится. Это в общем случае.
[01:20:14.860 --> 01:20:22.860]  Но в каких-то там частных, если граф в специфичке устроен, то вот у вас может быть сильно лучше от такого алгоритма.
[01:20:22.860 --> 01:20:25.860]  Корректность.
[01:20:25.860 --> 01:20:44.860]  Значит, пусть алгоритм завершается после обработки какой-то вершины мид.
[01:20:44.860 --> 01:20:50.860]  То есть вершина мид – это вот тот момент, когда у вас вот эти две кучи пересеклись,
[01:20:50.860 --> 01:20:56.860]  вершина мид обработался и из левой кучи, и из правой.
[01:20:56.860 --> 01:21:03.860]  Вершина мид удалена из обеих куч.
[01:21:03.860 --> 01:21:05.860]  Ну и дальше похожий аргумент.
[01:21:05.860 --> 01:21:08.860]  Значит, мы знаем, что ответ точно…
[01:21:08.860 --> 01:21:11.860]  Значит, если мы нашли расстояние от s до мид какой-то там d1,
[01:21:11.860 --> 01:21:16.860]  вес этого пути d1, и от мид до t вес какой-то d2,
[01:21:16.860 --> 01:21:23.860]  то мы точно знаем, что ответ не больше d1 плюс d2.
[01:21:23.860 --> 01:21:25.860]  Потому что есть вот такой хорошейший путь.
[01:21:25.860 --> 01:21:28.860]  Дальше опять так же, как мы делали в двустороннем BFS,
[01:21:28.860 --> 01:21:31.860]  покажем, что любой путь меньше длины мы увидим.
[01:21:31.860 --> 01:21:34.860]  То есть если путь имеет длину меньше, чем d1 плюс d2,
[01:21:34.860 --> 01:21:40.860]  то на нём обязательно найдётся вершина такая, что для неё сумма вот этих штук равна длине пути.
[01:21:46.860 --> 01:21:51.860]  Ну действительно, пусть есть какой-то путь меньше длины.
[01:21:51.860 --> 01:21:58.860]  Пусть есть путь из s в t длины меньше, чем d1 плюс d2.
[01:21:58.860 --> 01:22:02.860]  Вот какой-то путь.
[01:22:02.860 --> 01:22:07.860]  Тогда опять давайте рассмотрим вершину, первую вершину в этом пути,
[01:22:07.860 --> 01:22:12.860]  на расстоянии хотя бы d1 от s.
[01:22:12.860 --> 01:22:16.860]  На расстоянии хотя бы d1 от s.
[01:22:16.860 --> 01:22:19.860]  Первую вершину на этом пути на расстоянии хотя бы d1 от s.
[01:22:19.860 --> 01:22:23.860]  То есть вот здесь везде сумма весов ребер меньше, чем d1,
[01:22:23.860 --> 01:22:27.860]  и вот это вот, когда ребро добавляется, сумма хотя бы d1.
[01:22:27.860 --> 01:22:30.860]  Вот это первая вершина расстояния хотя бы d1.
[01:22:30.860 --> 01:22:34.860]  Тогда до неё я утверждаю, обязательно правильно найден dist s.
[01:22:34.860 --> 01:22:37.860]  Давайте я её назову как-нибудь x.
[01:22:37.860 --> 01:22:40.860]  Dist s от x правильно найден.
[01:22:40.860 --> 01:22:43.860]  Потому что все вот эти вот вершины обработаны.
[01:22:43.860 --> 01:22:48.860]  То есть до них до всех dist от s меньше, чем d1.
[01:22:48.860 --> 01:22:54.860]  Значит, поскольку у меня mid удалена из кучи,
[01:22:54.860 --> 01:22:57.860]  значит все вершины с меньшим расстоянием уже удалены из неё.
[01:22:57.860 --> 01:23:00.860]  Потому что Dexter рассматривает вершины в порядке увеличения этого самого dist.
[01:23:00.860 --> 01:23:04.860]  Значит все вот эти вершины удалены раньше из кучи и обработаны.
[01:23:04.860 --> 01:23:07.860]  Значит до x в частности найдено правильное расстояние.
[01:23:07.860 --> 01:23:10.860]  То есть у меня найдено до них до всех кратчащие расстояния.
[01:23:10.860 --> 01:23:14.860]  И когда вот это обрабатывалось, я это ребро рассмотрю, то есть до x найду правильное кратчащее расстояние.
[01:23:14.860 --> 01:23:16.860]  Это есть.
[01:23:16.860 --> 01:23:19.860]  Ну и дальше уже очевидно, что эта штука меньше, чем d2.
[01:23:19.860 --> 01:23:23.860]  Потому что если это хотя бы d1, а в сумме меньше, чем d1, то это меньше, чем d2.
[01:23:23.860 --> 01:23:26.860]  Значит dist t от x тоже правильно найден.
[01:23:26.860 --> 01:23:31.860]  Потому что эта штука меньше, чем d2, а у меня mid удалена, и до неё было d2.
[01:23:31.860 --> 01:23:34.860]  Поэтому все меньше тоже найдены.
[01:23:35.860 --> 01:23:39.860]  Значит dist t тоже правильно найдено.
[01:23:39.860 --> 01:23:44.860]  Ну все, сумма этих вершин равна длине этого пути, значит я его учту в ответе.
[01:23:48.860 --> 01:23:56.860]  Еще раз, я рассматриваю первую вершину x, первую вершину в этом пути, слева направо, до которой расстояние хотя бы d1.
[01:23:56.860 --> 01:24:00.860]  То есть вот здесь хотя бы d1, а на всех префиксах меньше, чем d1.
[01:24:01.860 --> 01:24:09.860]  Ну значит мы d учтем, она участвует в этом минимуме, поэтому все пути меньше длины мы учтем, значит минимали из них тоже учтем.
[01:24:09.860 --> 01:24:12.860]  Кажется все, спасибо за внимание.
