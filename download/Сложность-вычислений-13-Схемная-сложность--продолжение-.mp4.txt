[00:00.000 --> 00:15.000]  Мы обсуждали быстрые сумматоры и увидели, что если делать всё тривиальным образом,
[00:15.000 --> 00:19.000]  то будет длинная цепочка, которая будет долго работать.
[00:19.000 --> 00:24.000]  Но есть вариант подсчитывать быстро.
[00:24.000 --> 00:28.000]  Дальше начали изучать общую теорию схем.
[00:32.000 --> 00:38.000]  На схему можно смотреть по-разному. Мы изучили несколько разных взглядов.
[00:38.000 --> 00:44.000]  Это, может быть, размещенно-ориентированный граф, который похож на реальную микросхему
[00:44.000 --> 00:48.000]  и вычисляет какую-то буревую функцию.
[00:48.000 --> 00:52.000]  Это могут быть машины теории, которые получают нефрю подсказку.
[00:52.000 --> 01:00.000]  Могут быть прямолинейные программы без всяких условных переходов на циклах и так далее.
[01:00.000 --> 01:04.000]  Мы обсудили, что это всё будет одно и то же.
[01:04.000 --> 01:19.000]  Дальше обсудили, какие возникают классы. Важный класс возник П-слеш-поле.
[01:19.000 --> 01:26.000]  П-слеш-поле – это класс языков, которые распространены в сетчатке.
[01:26.000 --> 01:36.000]  Тут U, Unary, SelfApply. Это множество номеров машин, которые самоприменимы.
[01:36.000 --> 01:42.000]  Это лежит в фонарьной записи.
[01:42.000 --> 01:48.000]  Важный класс возник П-слеш-поле.
[01:48.000 --> 01:53.000]  Это множество номеров машин, которые самоприменимы в фонарьной записи.
[01:53.000 --> 02:04.000]  Это лежит в П-слеш-поле, но не в П, поэтому у нас есть строгое выложение в П-слеш-поле.
[02:04.000 --> 02:13.000]  Дальше мы изучали разные вопросы про то, как П-слеш-поле связано с другими классами.
[02:13.000 --> 02:19.000]  Мы успели доказать терему Карпеллиптона, что если NP вложено в П-слеш-поле,
[02:19.000 --> 02:23.000]  то тогда полиномиальная иерархия слопается на втором уровне.
[02:23.000 --> 02:28.000]  То есть pH равняется sigma2 полиномиальному.
[02:28.000 --> 02:34.000]  Дальше мы анонсировали более сильную терему Меера.
[02:34.000 --> 02:40.000]  Опубликована она была в той же статье, что терема Карпеллиптона.
[02:40.000 --> 02:45.000]  Но они там ссылаются, что это Меер доказала, а они только рассказывают.
[02:45.000 --> 02:54.000]  Соответственно, по сравнению с теремой Карпеллиптона, здесь более сильные условия.
[02:54.000 --> 03:01.000]  То есть если даже exp вложено в П-слеш-поле, то тем более NP вложено в П-слеш-поле.
[03:01.000 --> 03:04.000]  Но и более сильные заключения.
[03:04.000 --> 03:10.000]  Так же ясно, что поскольку pH вложено в exp, то если exp равно sigma2,
[03:10.000 --> 03:15.000]  то pH тоже равно sigma2, потому что sigma2 всегда вложено в pH,
[03:15.000 --> 03:20.000]  а pH вложено в exp, если эти штуки равны, то и pH тоже между ними.
[03:20.000 --> 03:39.000]  Теперь можно начинать доказывать терему Меера.
[03:39.000 --> 03:43.000]  Ясно, что достаточно доказывать одно вложение.
[03:43.000 --> 03:55.000]  Ну и техника будет следующей.
[03:55.000 --> 04:15.000]  Техника будет следующей.
[04:15.000 --> 04:20.000]  Ясно, что нужно доказать только в одну сторону.
[04:20.000 --> 04:32.000]  Так, значит, доказательства.
[04:32.000 --> 04:38.000]  Доказательства заключаются в том, что достаточно доказать,
[04:38.000 --> 04:52.000]  доказать, что exp вложено в sigma2-пальномиальное.
[04:52.000 --> 04:58.000]  Потому что в другую сторону вложения уже автоматически есть.
[04:58.000 --> 05:16.000]  Это делается так. Пусть у нас есть какой-то язык из exp.
[05:16.000 --> 05:25.000]  Когда для него есть какая-то машина.
[05:25.000 --> 05:41.000]  Найдется машина М, такая, что, во-первых, у нас х лежит в А тогда и только тогда,
[05:41.000 --> 05:47.000]  когда М от х равно единице.
[05:47.000 --> 06:02.000]  И на входах длины N машина М работает не больше, чем какая-то конкретная экспонента.
[06:02.000 --> 06:14.000]  Не больше, чем 2 в степени C на N степени D шагов.
[06:14.000 --> 06:20.000]  Какая-то экспоненциальная функция.
[06:20.000 --> 06:23.000]  Что это значит?
[06:23.000 --> 06:29.000]  Это значит, что если мы рассмотрим протокол работы машины чуринга,
[06:29.000 --> 06:48.000]  то это будет таблица вот такого вот размера.
[06:48.000 --> 07:04.000]  Ну, давайте обозначим E от N.
[07:04.000 --> 07:29.000]  Это получается таблица размера E от N на E от N.
[07:29.000 --> 07:57.000]  В этой таблице перечислены последовательно все конфигурации в ходе вычисления.
[07:57.000 --> 08:14.000]  Так, тогда за экспоненциальное время можно заполнить всю эту таблицу.
[08:14.000 --> 08:29.000]  И получается в частности выяснить содержимое любой конкретной ячейки.
[08:29.000 --> 08:33.000]  То есть есть какая-то другая экспоненциальная машина.
[08:33.000 --> 08:48.000]  То есть существует экспоненциальная машина, какая-то M штрих,
[08:48.000 --> 09:08.000]  которая по паре IG устанавливает содержимое ячейки с номером IG.
[09:08.000 --> 09:28.000]  С координатами можно написать IG.
[09:28.000 --> 09:50.000]  При этом, соответственно, IG лежат в диапароне от 1 до E от N.
[09:50.000 --> 10:01.000]  То есть записываются по линомерным числам битов.
[10:01.000 --> 10:19.000]  Поскольку само число имеет бит экспоненту, то число битов – это логарифм, то есть порядка C на N в степени D.
[10:19.000 --> 10:39.000]  Так, теперь поскольку эксп вложено в P слэш-поле,
[10:39.000 --> 11:07.000]  то найдется схема полиномерного размера, вычисляющая результат M штрих.
[11:07.000 --> 11:28.000]  При этом, поскольку аргументы M штрих имеют полиномерную длину,
[11:28.000 --> 11:38.000]  то и размер схемы.
[11:38.000 --> 11:43.000]  Давайте как-нибудь обозначим эту схему.
[11:43.000 --> 12:00.000]  Но надо только явно написать, что она зависит от N, что результат M штрих на входах не длинные.
[12:00.000 --> 12:13.000]  Поскольку мы считаем, что вот эти IG имеют какую-то фиксированную длину, то есть мы с ведущими нулями их записываем, то есть число битов в них заранее фиксировано.
[12:13.000 --> 12:18.000]  То есть мы фиксируем длину входа, но сам вход может быть каким угодно такой длинный.
[12:18.000 --> 12:25.000]  Ну так и IG это у нас индексы, то есть мы все ячейки в таблице вычисляем.
[12:25.000 --> 12:28.000]  И IG это соответственно координаты ячейки.
[12:28.000 --> 12:31.000]  Нет, но в плане таблицы же будут разные для разных ходов.
[12:31.000 --> 12:35.000]  И вот мы считаем, что любой вход такой длинный, и M штрих умеет их считать.
[12:35.000 --> 12:37.000]  А, ну вообще да.
[12:37.000 --> 12:42.000]  Вот сейчас знаете, как лучше мы сделаем.
[12:42.000 --> 12:46.000]  И E от N как летный полинов обозначим, а вот тут, наверное, пшу меньше либо ровно.
[12:46.000 --> 12:56.000]  То есть это будет значить, что такой таблице точно хватит для того, чтобы все записать.
[12:56.000 --> 13:01.000]  Вот, поскольку документы M штрих имеют полиномиальный от N длину,
[13:01.000 --> 13:16.000]  то схема имеет полиномиальный размер не только от своих входов, но и от N.
[13:16.000 --> 13:26.000]  Потому что полином от полинома это полином.
[13:26.000 --> 13:42.000]  Ну а дальше происходит что-то вроде теоремку Клевина.
[13:42.000 --> 13:58.000]  Теперь нужно записать формулу.
[13:58.000 --> 14:26.000]  Да, как в теореме Клевина, которая будет означать, что Cn вычисляет полиномиальный от N.
[14:26.000 --> 14:40.000]  Вот, то есть что нужно писать.
[14:40.000 --> 15:08.000]  Да, можно написать что.
[15:08.000 --> 15:17.000]  Мы хотим написать, что во-первых, там все начинается как-то.
[15:17.000 --> 15:27.000]  Cn от 0.0, это значение стояния Q0.
[15:27.000 --> 15:43.000]  Да, значит, и там Cn от 0.1, это первый бит икса и так далее.
[15:43.000 --> 15:56.000]  И Cn от 0.0, N равно Xn.
[15:56.000 --> 16:06.000]  И там Cn от 0.0 и N плюс 1 равняется…
[16:06.000 --> 16:08.000]  А, это лучше написать так.
[16:08.000 --> 16:25.000]  И для любого K больше N, Cn от 0.0 и K, это равняется пробелу.
[16:25.000 --> 16:29.000]  Мне кажется, на этой стадии мы зафиксировали и вход тоже.
[16:29.000 --> 16:35.000]  То есть схема же для конкретного входа может справиться.
[16:35.000 --> 16:47.000]  Пока показывали, но мы хотим сводимость строить.
[16:47.000 --> 16:54.000]  Конечно, конкретная формула в sigma2 будет зависеть от входа.
[16:54.000 --> 17:00.000]  Так и должно быть.
[17:00.000 --> 17:04.000]  Но можно здесь приписать, что там корректный протокол на данном входе.
[17:04.000 --> 17:20.000]  Эта строчка означает, что начальная позиция правильная.
[17:20.000 --> 17:35.000]  Дальше существует какой-то индекс K.
[17:35.000 --> 17:45.000]  Такой, что Cn от 0.0 и K равняется QAccept.
[17:45.000 --> 17:58.000]  Это конечное состояние принимающее.
[17:58.000 --> 18:21.000]  Ну и, наконец, для любого I, для любого J, Cn от IJ равняется какой-то конкретной функции F.
[18:21.000 --> 18:40.000]  Там вот Cn, и минус 1, и Cn, и минус 1, и минус 1.
[18:40.000 --> 19:05.000]  Тут и минус 1J, значит, Cn от i-1J плюс 1, да, и еще Cn от i-1J плюс 2.
[19:05.000 --> 19:15.000]  Это означает, что каждый шаг корректен.
[19:15.000 --> 19:22.000]  Ну и тогда получается, что...
[19:22.000 --> 19:26.000]  Тут правильно вы спрашиваете. Важен порядок кванторов.
[19:26.000 --> 19:31.000]  Точнее важно сказать, что и так, и так может быть.
[19:31.000 --> 19:35.000]  В итоге хочу сказать, что X лежит в нашем языке.
[19:35.000 --> 19:49.000]  Значит, тогда и только тогда, когда существует схема Cn,
[19:49.000 --> 19:57.000]  значит, такая, что... Тут, в общем, конъюнция трех предыдущих формул.
[19:57.000 --> 20:17.000]  Конъюнция трех предыдущих формул.
[20:17.000 --> 20:24.000]  Ну и тогда, если вывести кванторы в правильном порядке...
[20:24.000 --> 20:29.000]  То есть тут есть вот квантор существования, вот квантор всеобщенности, вот квантор всеобщенности.
[20:29.000 --> 20:45.000]  Значит, при вынесении кванторов в правильном порядке получим как раз sigma2 формулу.
[20:54.000 --> 21:00.000]  Вот. Тут как раз за счет стерлинга Клевина мы прям явным образом писали конъюнцию.
[21:00.000 --> 21:05.000]  И поэтому там нам годились только полинемиальные вычисления.
[21:05.000 --> 21:09.000]  А здесь мы не пишем явную конъюнцию, а пишем квантор.
[21:09.000 --> 21:13.000]  И поэтому тут уже переменные под квантором, может быть, полинемиальные длины,
[21:13.000 --> 21:22.000]  поэтому уже годятся экспоненциальные вычисления.
[21:22.000 --> 21:30.000]  Вот. Ну вот, а это и значит, поскольку мы получили sigma2 формулу,
[21:30.000 --> 21:43.000]  соответственно, с параметрами х, то как раз и получим, что как раз параметры...
[21:52.000 --> 22:15.000]  что как раз вот эти вот биты, которые параметры образуют х из нужного множества,
[22:15.000 --> 22:19.000]  тогда и только тогда, когда верна такая sigma2 форму.
[22:19.000 --> 22:37.000]  Вот. Это и означает, что А у нас лежит в sigma2 полинемиальный.
[22:37.000 --> 22:54.000]  Вот. Получается вот такая вот конструкция.
[22:54.000 --> 23:06.000]  Так, ну что, нужно ли еще что-нибудь пояснить?
[23:06.000 --> 23:12.000]  Видим, все понятно. Есть у меня тут одно важное замечание.
[23:12.000 --> 23:18.000]  Значит, важное соображение.
[23:18.000 --> 23:43.000]  Важное соображение, что если действительно эксп равно sigma2 полинемиальному,
[23:43.000 --> 23:52.000]  то тогда P не равно NP.
[23:52.000 --> 24:07.000]  Потому что при P равно NP верно, и P равно sigma2 полинемиальная.
[24:07.000 --> 24:27.000]  Вот. Но тогда P равно эксп, что противоречит теореме об иерархии.
[24:27.000 --> 24:45.000]  Вот. Таким образом, верхнюю оценку в одной модели значит то,
[24:45.000 --> 24:54.000]  что у нас эксп вложено в P slash поле.
[24:54.000 --> 25:04.000]  Можно использовать для нижней оценки в другой модели.
[25:04.000 --> 25:16.000]  То есть P не равно NP.
[25:16.000 --> 25:20.000]  Ну, это вот такой вот поучительный пример.
[25:20.000 --> 25:23.000]  Верхняя оценка на сложности.
[25:23.000 --> 25:29.000]  То есть верхняя оценка означает, что в модели схем, экспедиционное вычисление
[25:29.000 --> 25:34.000]  можно делать с использованием полинемиального размера схем.
[25:34.000 --> 25:37.000]  Это верхняя оценка на размер схемы.
[25:37.000 --> 25:41.000]  А P не равно NP – это нижняя оценка на время работы для NP полных задач.
[25:41.000 --> 25:45.000]  Ну и вообще получение нижних оценок, каких бы то ни было,
[25:45.000 --> 25:52.000]  это самая сложная часть в теории сложности вычислений.
[25:52.000 --> 26:01.000]  Ну, в том числе и P не равно NP тоже никто не умеет показать.
[26:01.000 --> 26:06.000]  Так.
[26:06.000 --> 26:09.000]  Хорошо.
[26:09.000 --> 26:21.000]  Ну и теперь я хотел бы немножко вернуться к быстрым сумматорам.
[26:21.000 --> 26:23.000]  Давайте вернемся к быстрым сумматорам.
[26:23.000 --> 26:28.000]  Нет никаких нет вопросов.
[26:28.000 --> 26:50.000]  А именно поговорим, что помимо размера схемы важный показатель – это ее глубина.
[26:50.000 --> 27:11.000]  Если схема моделирует какие-то реальные микросхемы, то именно глубина отвечает за быстродействие.
[27:11.000 --> 27:25.000]  Так же схемы используют для моделирования параллельных вычислений.
[27:25.000 --> 27:35.000]  Предполагается, что в разных частях схемы у нас будут стоять разные процессоры,
[27:35.000 --> 27:47.000]  которые будут параллельно какие-то вычисления проводить.
[27:47.000 --> 28:11.000]  Соответственно, там глубина тоже соответствует времени работы отдельного процессора.
[28:11.000 --> 28:15.000]  Ну вот, поэтому это нас интересует.
[28:15.000 --> 28:44.000]  Ну и в частности интересуют схемы с логарифмической глубиной или полилогарифмической.
[28:44.000 --> 29:13.000]  Значит, тут становится важно, какая входящая степень, какой элементов конъюнса и дезюнса.
[29:13.000 --> 29:23.000]  Два или произвольная.
[29:23.000 --> 29:45.000]  Ну, потому что элемент совходящий степень юка можно смоделировать двоичным деревом глубины.
[29:45.000 --> 29:53.000]  Ну дайте я напишу верхнюю целую часть.
[29:53.000 --> 30:03.000]  Логарифмука.
[30:03.000 --> 30:12.000]  Ну это соответственно может, если так на всех уровнях сделать, глубина изменится в соответствующий число раз.
[30:12.000 --> 30:22.000]  Так,
[30:22.000 --> 30:29.000]  хорошо, значит, таким образом у нас будут два,
[30:29.000 --> 30:48.000]  два семидесятоклассов.
[30:48.000 --> 30:58.000]  У нас будет nc, ncdt.
[30:58.000 --> 31:08.000]  Значит, это nc или nc, это на самом деле собственное.
[31:08.000 --> 31:18.000]  Этот класс назвали в честь конкретного человека Николаса Питтинджера, поэтому это называется nx-класс.
[31:18.000 --> 31:38.000]  Значит, ncdt это класс языков, которые распознаются семействами схем полиномиального размера.
[31:38.000 --> 31:58.000]  Полиномиального размера и глубины.
[31:58.000 --> 32:08.000]  Большой логарифм n в тепени D.
[32:08.000 --> 32:25.000]  И дальше могут накладываться условия равномерности.
[32:25.000 --> 32:45.000]  То есть, может быть, схема cn может быть вычислена, может быть найдена логаритмически за время полинома от n.
[32:45.000 --> 32:54.000]  Значит, это называется полиномиальная равномерность.
[32:54.000 --> 33:05.000]  И также может быть то же самое, только на логарифмической памяти.
[33:05.000 --> 33:24.000]  Так, значит, тут на памяти, на памяти большое логарифм n.
[33:24.000 --> 33:37.000]  Это, соответственно, логарифмическая равномерность.
[33:37.000 --> 33:52.000]  Но может ничего не накладываться, тогда будет неравномерное семейство.
[33:52.000 --> 34:01.000]  Ну и, соответственно, есть также ac dt.
[34:01.000 --> 34:06.000]  А тут удивительно образом, это a уже никого конкретно не означает.
[34:06.000 --> 34:11.000]  Это anyfanin-класс.
[34:11.000 --> 34:17.000]  То есть с любой входящей степени.
[34:17.000 --> 34:22.000]  Так.
[34:22.000 --> 34:25.000]  Да-да-да-да, это надо дописать вот здесь.
[34:25.000 --> 34:45.000]  Значит, где элементы конъюнция и дизъюнция имеют входящую степень была.
[34:45.000 --> 35:09.000]  Вот, соответственно, тут то же самое, только элементы уже имеют произвольную степень.
[35:09.000 --> 35:28.000]  Значит, где элементы имеют произвольную входящую степень.
[35:28.000 --> 35:35.000]  Ну и также могут накладывать условия равномерности.
[35:35.000 --> 35:41.000]  Вот, значит, тогда это образует иерархию.
[35:41.000 --> 35:50.000]  Значит, образуется иерархия.
[35:50.000 --> 36:00.000]  Это значит nc dt вложено в ac dt.
[36:00.000 --> 36:06.000]  Это вложено в nc d плюс первое.
[36:06.000 --> 36:09.000]  Так, ну первое очевидно.
[36:09.000 --> 36:13.000]  Ну и дальше это может так раскручиваться.
[36:13.000 --> 36:22.000]  Значит, первое вложение очевидно, потому что 2 – это частный случай произвольной степени.
[36:22.000 --> 36:39.000]  А второе следует из того, что в схеме полиномиального размера
[36:39.000 --> 37:01.000]  элемент конъюнция или дизъюнция не может иметь больше полинома входящих рёбов.
[37:01.000 --> 37:30.000]  Ну и получается, что поскольку нужное дерево имеет глубину порядка логарифма,
[37:30.000 --> 37:41.000]  логарифма входящей степени,
[37:41.000 --> 37:56.000]  значит, она будет равна большой от логарифма от полинома от n.
[37:56.000 --> 38:11.000]  А это будет то же самое, что большая от простого логарифма n.
[38:11.000 --> 38:15.000]  Ну, что и даст множитель.
[38:15.000 --> 38:24.000]  Что и даст увеличение степени логарифма на 1.
[38:24.000 --> 38:31.000]  То есть мы логарифм в DET, умножаем ещё на логарифм, получаем логарифм DET плюс 1, что здесь написано.
[38:31.000 --> 38:39.000]  Возникает вопрос, а в этой иерархии что со слопыванием?
[38:39.000 --> 38:52.000]  Будут ли вложения строгими?
[38:52.000 --> 38:58.000]  Ну и на этот счёт есть некоторый ответ.
[38:58.000 --> 39:10.000]  Что точно будет, что nc0 не равно ac0.
[39:10.000 --> 39:17.000]  Дело в том, что 0 означает константную глубину.
[39:17.000 --> 39:23.000]  Тут будет константная глубина.
[39:23.000 --> 39:51.000]  А если и входящая степень константна, то функция может зависеть только от константы аргументов.
[39:53.000 --> 40:05.000]  Можно доказать, что если у нас глубина D и каждый рассветление в два раза, то максимальная зависимость будет 2 в степени D.
[40:05.000 --> 40:16.000]  Но если D констант, то это будет какая-то констанция, если отец больше, то уже от каких-то бит в зависимости не будет.
[40:16.000 --> 40:35.000]  При этом сама конъюнция всех аргументов лежит в ac0.
[40:35.000 --> 40:40.000]  Потому что у нас есть произвольная конъюнция.
[40:40.000 --> 40:47.000]  И зависит от всех аргументов.
[40:47.000 --> 40:58.000]  Изменение любого аргумента может повлиять на значение конъюнция.
[40:58.000 --> 41:03.000]  Вот это известно.
[41:03.000 --> 41:20.000]  Ну и также известно, что ac0 не равно nc1.
[41:20.000 --> 41:25.000]  Это уже посложнее теорема.
[41:25.000 --> 41:33.000]  Но по крайней мере я расскажу, какая тут функция будет лежать в большем, но не в меньшем.
[41:33.000 --> 41:56.000]  Это будет просто parity, функция четности.
[41:56.000 --> 42:06.000]  Функция четности.
[42:06.000 --> 42:22.000]  То есть просто x1, боксоренное со всеми, боксоренное с xn, лежит в nc1.
[42:22.000 --> 42:35.000]  Потому что можно построить двоичное дерево из ксоров.
[42:35.000 --> 42:47.000]  А отдельный xor можно выразить формулой, схемой константной глубины.
[42:47.000 --> 42:57.000]  Но не лежит в ac0.
[42:57.000 --> 43:15.000]  Я бы назвал это как именноторно-гематологическое доказательство.
[43:15.000 --> 43:21.000]  Это сложная целая лекция, даже в одном из проектов есть.
[43:21.000 --> 43:25.000]  Это тема одного из проектов.
[43:25.000 --> 43:33.000]  Правда, это не самый сложный проект.
[43:33.000 --> 43:45.000]  Там есть некоторое рассуждение с приближением разного количества членов.
[43:45.000 --> 43:51.000]  Это я не буду подробно рассказывать.
[43:51.000 --> 44:07.000]  Ну ладно, есть ли какие-нибудь вопросы?
[44:07.000 --> 44:17.000]  Там еще есть некоторая связь с классами l и nl.
[44:17.000 --> 44:26.000]  Это я вкратце тоже напишу.
[44:26.000 --> 44:39.000]  Если рассматривать логарифмически равномерные схемы,
[44:39.000 --> 44:46.000]  то получается, что тут будет nc1.
[44:46.000 --> 45:14.000]  Надо еще сказать, что про все дальнейшие вложения в nc-ерархию ничего не известно.
[45:14.000 --> 45:20.000]  Даже вроде не умеет доказывать, что np там не лежит.
[45:20.000 --> 45:26.000]  Оказывается, даже про nc1 не умеет доказывать, что там np не лежит.
[45:26.000 --> 45:30.000]  Надо уточнить.
[45:30.000 --> 45:38.000]  Открытый вопрос, равно ли nc1 и np.
[45:38.000 --> 45:44.000]  Если рассматривать логарифмически равномерные схемы, то для них будет nc1 вложено в l,
[45:44.000 --> 45:52.000]  это вложено в nl, это вложено в ac1.
[45:52.000 --> 46:02.000]  В частности, вопрос о равенстве l и nl тоже связан со строкостью вложения на следующем уровне.
[46:02.000 --> 46:06.000]  Но тут я давайте совсем вкратце отпишу.
[46:06.000 --> 46:10.000]  Может быть, у нас семинар в каких-то группах будет подробнее.
[46:10.000 --> 46:16.000]  То, что nc1 вложено в l, нужно аккуратно указывать,
[46:16.000 --> 46:20.000]  что из-за того, что у нас глубина логарифмическая,
[46:20.000 --> 46:27.000]  мы можем настроить рекурсию логарифмической глубины и вычислять ответ.
[46:27.000 --> 46:33.000]  Что именно там вычислять, поскольку у нас схема логарифмически равномерная,
[46:33.000 --> 46:41.000]  то мы сможем на ходу понимать, какие функции использовать.
[46:41.000 --> 46:45.000]  Прям такая идея.
[46:45.000 --> 46:52.000]  А nl вложенного ac1 следует из того, что задача о достижимости в графе будет nl полной,
[46:52.000 --> 46:57.000]  и она будет решаться в ac1.
[46:57.000 --> 47:04.000]  Вот у нас была схема для быстрого сумматора.
[47:04.000 --> 47:10.000]  Дальше можно приделать схему для умножения матриц.
[47:10.000 --> 47:14.000]  А поиск пути – это более-менее есть умножение матриц,
[47:14.000 --> 47:20.000]  но только там такое специфическое, так называемое дезюмпное умножение.
[47:20.000 --> 47:26.000]  В общем, может быть, на некоторых семинарах это будет подробно изучено.
[47:26.000 --> 47:36.000]  А сейчас, если вопросов не появилось,
[47:36.000 --> 47:41.000]  то я бы полчаса поговорил про вероятностный алгоритм.
[47:50.000 --> 48:01.000]  Вот круг некоторых конкретных алгоритмов.
[48:01.000 --> 48:11.000]  Так, ну что, вопросов нет.
[48:11.000 --> 48:27.000]  Хорошо, поговорим про вероятностные отчисления.
[48:27.000 --> 48:30.000]  Основная часть будет в следующий раз.
[48:30.000 --> 48:33.000]  В следующий раз поговорим про вероятностные классы.
[48:33.000 --> 48:39.000]  И сегодня поговорим про некоторые конкретные задачи, которые решаются миресным образом.
[48:39.000 --> 48:44.000]  Ну и там еще есть вопрос, какая у нас модель вычислительная.
[48:44.000 --> 49:06.000]  Будем считать, что результат работы алгоритма может зависеть от исходов некоторого случайного процесса.
[49:06.000 --> 49:15.000]  Например, бросание монетки.
[49:15.000 --> 49:34.000]  В зависимости от исходов, результат, ну как бы ответ, может быть различным.
[49:34.000 --> 49:39.000]  В зависимости от исходов ответ может быть различным.
[49:39.000 --> 49:58.000]  И поэтому то есть ответ является случайной величиной.
[49:58.000 --> 50:20.000]  Ну и соответственно, если ответ бинарный, то могут быть два типа ошибок.
[50:20.000 --> 50:29.000]  Первого рода и второго рода.
[50:29.000 --> 50:36.000]  В зависимости от того, что там происходит.
[50:36.000 --> 50:49.000]  То есть какой настоящий ответ и какой ответ дает машина.
[50:49.000 --> 51:11.000]  Значит, ошибки первого рода это положительные срабатывания.
[51:11.000 --> 51:36.000]  Альфа ошибки ниже положительные срабатывания.
[51:36.000 --> 51:55.000]  Значит, это настоящий ответ нет, а алгоритм отвечает да.
[51:55.000 --> 52:00.000]  Это ошибки второго рода.
[52:00.000 --> 52:09.000]  А ниже бета ошибки.
[52:09.000 --> 52:17.000]  Или ложно-отрицательные срабатывания.
[52:17.000 --> 52:32.000]  Наоборот, настоящий ответ да, алгоритм отвечает нет.
[52:32.000 --> 53:01.000]  Значит, если ответ не да или нет, ответ сложный, то получается, что важна вероятность получить правильный ответ.
[53:01.000 --> 53:13.000]  Ну либо, наоборот, можно очень много разных вариантов рассматривать.
[53:13.000 --> 53:27.000]  Тут целые матрицы разных ошибок получаются.
[53:27.000 --> 53:38.000]  Но при этом нужно отличать вероятность.
[53:38.000 --> 54:06.000]  Вероятность, что ответ машины такой при условии, что настоящий ответ и наоборот.
[54:06.000 --> 54:29.000]  Вероятность того, что настоящий ответ такой при условии, что ответ машины такой.
[54:29.000 --> 54:43.000]  Потому что если у вас очень сильно отличаются абсолютно вероятности разных ответов, то тогда и вот эти условные вероятности будут тоже совершенно различные.
[54:43.000 --> 55:08.000]  Значит, они могут сильно отличаться, если вероятности различных настоящих ответов существенно отличаются.
[55:08.000 --> 55:23.000]  Ну и в целом различают несколько видов алгоритмов.
[55:23.000 --> 55:33.000]  Несколько видов вероятностных алгоритмов.
[55:33.000 --> 55:42.000]  Есть так называемые алгоритмы Монте-Карла.
[55:42.000 --> 55:47.000]  А алгоритм Монте-Карла это ситуация, когда ответ всегда правильный.
[55:47.000 --> 56:03.000]  Нет, наоборот, значит ответ всегда выдается быстро, но может быть ошибочным.
[56:03.000 --> 56:11.000]  Наоборот алгоритмы Лас-Вегаса.
[56:11.000 --> 56:27.000]  Ответ всегда правильный, но может считаться очень долго, хотя в среднем быстро.
[56:27.000 --> 56:36.000]  Еще бывает алгоритмы Атлантик-Сити.
[56:36.000 --> 56:57.000]  То есть на ответ обычно правильный и в среднем считается быстро, но нет гарантий ни того ни другого.
[56:57.000 --> 57:12.000]  Конечно, алгоритм Атлантик-Сити похуже, но бывает так, что ничего другого нет.
[57:12.000 --> 57:22.000]  Важная задача, на которой долгие годы развивалась теория и разработка алгоритмов, это проверка простоты.
[57:22.000 --> 57:41.000]  Задолго до АКС алгоритма были придуманы вероятностные тесты простоты.
[57:41.000 --> 57:52.000]  Поскольку тогда же в конце 70-х были открыты криптографические протоколы на базе простых чисел,
[57:52.000 --> 58:01.000]  то оказалось, что поиск простых чисел – это важная область.
[58:01.000 --> 58:15.000]  Поэтому как раз были разработаны много разных методов.
[58:15.000 --> 58:24.000]  Простейший тест – это тест фирма.
[58:24.000 --> 58:31.000]  У нас есть малый теориям фирма.
[58:31.000 --> 58:43.000]  Малый теориям фирма, что А в степени P-1 сравним с единицей по модулю P.
[58:43.000 --> 59:08.000]  Тест фирма – выбрать случайный остаток А.
[59:08.000 --> 59:28.000]  Дальше можно проверить, что наибольший общий делитель А и П равен единице.
[59:28.000 --> 59:43.000]  Если вдруг не равен, то это точно не простое число, поскольку делитель обнаружился.
[59:43.000 --> 59:55.000]  Вторая вещь – что А в степени P-1 сравним с единицей.
[59:55.000 --> 01:00:00.000]  И тут есть проблема.
[01:00:00.000 --> 01:00:14.000]  Проблема с таким методом заключается в том, что есть числа кармаекла.
[01:00:14.000 --> 01:00:30.000]  Для чисел кармаекла это равенство тоже всегда верно.
[01:00:30.000 --> 01:00:37.000]  Если число не является ни простым, ни числом кармаекла,
[01:00:37.000 --> 01:00:43.000]  то тогда максимум для половины остатков будет верно.
[01:00:43.000 --> 01:01:03.000]  То есть вместо простоты тест распознает простоту или кармаекловость.
[01:01:03.000 --> 01:01:21.000]  Что-то он делает, но не совсем то, что мы хотим.
[01:01:21.000 --> 01:01:36.000]  Дальше я расскажу про некоторую надстройку над этим тестом, который уже работает.
[01:01:36.000 --> 01:01:58.000]  Если А в степени P-1 сравним с единицей, то А в степени P-1 пополам
[01:01:58.000 --> 01:02:12.000]  сравнима с плюс-минус единицей.
[01:02:12.000 --> 01:02:34.000]  При этом, если А в степени P-1 пополам сравнима с единицей,
[01:02:34.000 --> 01:02:53.000]  то А в степени P-1 на 4 сравнима с плюс-минус единицей.
[01:02:53.000 --> 01:03:11.000]  Теорема, которую Миллер и Рабин доказали.
[01:03:11.000 --> 01:03:40.000]  Если А простое, то тогда в ряду А в степени P-1 на 2 в степени K
[01:04:10.000 --> 01:04:25.000]  или так и дойдет до конца этого ряда.
[01:04:25.000 --> 01:04:40.000]  Если же P составное, то это будет верно максимум для 1 четверти.
[01:04:40.000 --> 01:04:49.000]  Вот всех А взаимно простых с P.
[01:04:49.000 --> 01:04:59.000]  Ну и тогда получается тест на базе теоремы.
[01:04:59.000 --> 01:05:14.000]  Тест на базе теоремы выглядит так, что выберем случайное А и проверим это условие.
[01:05:14.000 --> 01:05:20.000]  Проверим указанные условия.
[01:05:20.000 --> 01:05:24.000]  Сначала идут единицы.
[01:05:24.000 --> 01:05:30.000]  А в степени P-1 должно быть равно 1, а не минус 1.
[01:05:30.000 --> 01:05:34.000]  Конечно, начинать нужно с единицей.
[01:06:00.000 --> 01:06:10.000]  В этом заключается теорема.
[01:06:10.000 --> 01:06:33.000]  Если нужно повысить точность, можно брать не одно случайное А, а несколько независимых друг от друга.
[01:06:33.000 --> 01:06:57.000]  Проверяем, что для всех А это условие выполнено.
[01:06:57.000 --> 01:07:09.000]  А получается, что если у нас 1 четверть, то чтобы все тесты пройти, нужно чтобы каждый из 10 попал в 1 четверть.
[01:07:09.000 --> 01:07:14.000]  А это будет 1,4 в десятые, то есть 1 миллионная вероятность.
[01:07:14.000 --> 01:07:18.000]  Что уже достаточно немного.
[01:07:18.000 --> 01:07:23.000]  Хорошо, что тест Миллера Рабина.
[01:07:23.000 --> 01:07:32.000]  Есть также много других разных тестов.
[01:07:32.000 --> 01:07:46.000]  Последнее, что я сегодня расскажу, это задача по проверке многочленов на равенство.
[01:07:46.000 --> 01:07:49.000]  На первый взгляд, в чем задача?
[01:07:49.000 --> 01:07:52.000]  Проверить, что два наночления одинаковые.
[01:07:52.000 --> 01:07:55.000]  Надо просто посмотреть, что коэффициенты одни и те же.
[01:07:55.000 --> 01:07:57.000]  Значит, одинаковые.
[01:07:57.000 --> 01:08:02.000]  Но это так легко сделать, если наночения заданы явно.
[01:08:02.000 --> 01:08:11.000]  Даже если у них перепутаны коэффициенты, то можно отсортировать и тоже сравнить.
[01:08:11.000 --> 01:08:15.000]  Может быть так, что во-первых, там может быть много переменных,
[01:08:15.000 --> 01:08:21.000]  и во-вторых, они могут быть заданы не прямым способом,
[01:08:21.000 --> 01:08:25.000]  то есть не списком своих коэффициентов,
[01:08:25.000 --> 01:08:29.000]  а может быть какое-то сложное выражение со скобками и так далее.
[01:08:29.000 --> 01:08:34.000]  А в общем случае, это даже какая-то архиметическая схема.
[01:08:34.000 --> 01:08:39.000]  Пусть есть два постановка.
[01:08:39.000 --> 01:08:52.000]  Пусть имеются два многочлена, заданных арифметическими схемами.
[01:08:52.000 --> 01:09:10.000]  Это аналоги булевых схем, в которых вместо логических операций
[01:09:10.000 --> 01:09:20.000]  стоят сложение и умножение.
[01:09:20.000 --> 01:09:37.000]  Ну и тогда получается, что входящие вершины помещены переменными.
[01:09:37.000 --> 01:09:46.000]  Ну и соответственно, в результате выполнения всех операций
[01:09:46.000 --> 01:10:01.000]  получится многочлен вот этих переменных.
[01:10:01.000 --> 01:10:18.000]  Ну и соответственно, теперь получается, что просто так раскрыть все скобки
[01:10:18.000 --> 01:10:26.000]  за полиномиальное время не получится.
[01:10:26.000 --> 01:10:32.000]  Ну потому что даже если у меня там произведение n скобок,
[01:10:32.000 --> 01:10:55.000]  там какой-то x1 плюс y1, умножить на и так далее, умножить на xn и плюс yn,
[01:10:55.000 --> 01:11:10.000]  значит это уже получается выражение с два в степенем слагаемыми.
[01:11:10.000 --> 01:11:14.000]  Ну и соответственно, вот эта x и это y, это могут быть не отдельные переменные,
[01:11:14.000 --> 01:11:17.000]  а тоже какие-то там одночлены или что-нибудь.
[01:11:17.000 --> 01:11:22.000]  Уже такая штука будет выражением с два в степенем слагаемыми.
[01:11:22.000 --> 01:11:27.000]  Уже просто так не получится раскрыть.
[01:11:27.000 --> 01:11:56.000]  Вот, ну а кроме того, значит кроме того, за счет...
[01:11:56.000 --> 01:12:13.000]  значит за счет этого итерированного умножения и степень многочлена
[01:12:13.000 --> 01:12:24.000]  может стать экспоненциально большой.
[01:12:24.000 --> 01:12:28.000]  Ну потому что у нас может быть там какое-то выражение.
[01:12:28.000 --> 01:12:30.000]  Вот так будет получаться.
[01:12:30.000 --> 01:12:46.000]  Степень мы взвели в квадрат, а потом еще в квадрат,
[01:12:46.000 --> 01:12:51.000]  значит и так далее.
[01:12:51.000 --> 01:13:00.000]  Значит вот это в квадрате.
[01:13:00.000 --> 01:13:10.000]  Как раз вот такое итерированное воздействие в квадрат можно за счет этой схемы,
[01:13:10.000 --> 01:13:15.000]  вот в этом умножении одно и то же засовывать.
[01:13:15.000 --> 01:13:30.000]  Получается, что это будет равно P в степени 2 в степени n, если это n раз так сделать.
[01:13:30.000 --> 01:13:34.000]  Ну и поэтому даже если у нас там одна переменная,
[01:13:34.000 --> 01:13:39.000]  то просто может очень слишком длинное выражение получиться.
[01:13:39.000 --> 01:13:46.000]  Вот, значит соответственно вот так вот просто раскрыть все скобки нельзя.
[01:13:46.000 --> 01:13:59.000]  Ну и никакого, никакого детерминированного алгоритма.
[01:13:59.000 --> 01:14:16.000]  Алгоритма проверки двух многочленов на равенство неизвестна.
[01:14:16.000 --> 01:14:35.000]  Вот, но есть вероятность алгоритма.
[01:14:35.000 --> 01:14:55.000]  Значит вероятность алгоритма выберем, выберем случайную точку.
[01:14:55.000 --> 01:15:08.000]  Выберем случайную точку и посчитаем в ней значение многочленов.
[01:15:08.000 --> 01:15:20.000]  Если значения не совпали, то многочлены точно разные.
[01:15:20.000 --> 01:15:30.000]  Если совпали, то скорее всего одинаковые.
[01:15:30.000 --> 01:15:33.000]  Вот, но вопрос, где эту точку выбирать?
[01:15:33.000 --> 01:15:40.000]  Смотрите, действительно числами работать не умеем на компьютере.
[01:15:40.000 --> 01:15:46.000]  Случайно натуральное число тоже нельзя взять равномерно.
[01:15:46.000 --> 01:15:51.000]  Если брать случайно в каком-то диапазоне, то за счет этих подстановок у нас очень большое число получится.
[01:15:51.000 --> 01:15:54.000]  Так что мы просто тоже не сможем посчитать.
[01:15:54.000 --> 01:16:10.000]  Поэтому, чтобы процедура была полинамиальной,
[01:16:10.000 --> 01:16:27.000]  нужно брать точку и проводить вычисления в большом конечном поле.
[01:16:27.000 --> 01:16:32.000]  А для этого предыдущая задача.
[01:16:32.000 --> 01:16:36.000]  Тест на простоту.
[01:16:36.000 --> 01:17:04.000]  Размер поля должен быть достаточно большим, чтобы вероятность совпадения была мала.
[01:17:04.000 --> 01:17:18.000]  Но и достаточно маленьким, чтобы можно было проводить в нем вычисления.
[01:17:18.000 --> 01:17:37.000]  Но оказывается, что можно такое взять.
[01:17:37.000 --> 01:18:06.000]  Как раз более экспоненциального размера, существенно большего, чем степень многочленов, подойдет.
[01:18:06.000 --> 01:18:35.000]  Но чтобы тут все сработало, нужна так называемая лемма Шварца-Зиппеля.
[01:18:35.000 --> 01:18:47.000]  Если у нас поле размера P, многочленов 10 переменных, степени D.
[01:18:47.000 --> 01:18:51.000]  Я ее сформулирую и закончу.
[01:18:51.000 --> 01:18:54.000]  Я думаю, доказательство тоже на семинара оставим.
[01:18:54.000 --> 01:18:59.000]  Лемма Шварца-Зиппеля.
[01:18:59.000 --> 01:19:08.000]  Взять в следующем.
[01:19:08.000 --> 01:19:37.000]  Просто многочлен от N переменных, не нулевой многочлен, от N переменных, степени D имеет не больше, чем 1-D делить на P.
[01:19:37.000 --> 01:19:55.000]  1-D делить на P в N корней в поле размера P.
[01:19:55.000 --> 01:20:10.000]  Если N равно 1, то это просто утверждение о том, что степень D не больше, чем доля корней.
[01:20:10.000 --> 01:20:16.000]  Я не то написал. Больше либо равно, а наоборот как бы не корнить.
[01:20:16.000 --> 01:20:20.000]  Это доля.
[01:20:20.000 --> 01:20:41.000]  Имеет долю больше, чем столько точек, в которых он не равен нулю в поле размера P.
[01:20:41.000 --> 01:20:46.000]  Теперь вот правильно.
[01:20:46.000 --> 01:20:53.000]  Ну, корней будет меньше, чем 1 минус вот такая штука.
[01:20:53.000 --> 01:20:59.000]  Если доказать, то это обосновывает, почему такое работает.
[01:20:59.000 --> 01:21:07.000]  Потому что если P достаточно большое по сравнению с D, то есть P должно быть сильно больше, чем D, может, на N, например.
[01:21:07.000 --> 01:21:11.000]  Тогда вот эта штука будет все еще близко к единице.
[01:21:11.000 --> 01:21:17.000]  И, соответственно, вероятность попасть в корень будет маленькой.
[01:21:17.000 --> 01:21:21.000]  Ну, все. На сегодня все.
[01:21:21.000 --> 01:21:31.000]  И у нас останется еще два занятия, на которых мы про вероятность поговорим.
[01:21:31.000 --> 01:21:37.000]  Ну и, может быть, еще там про чуть-чуть связанные вещи.
[01:21:37.000 --> 01:21:54.000]  Так, ну хорошо, есть ли вопросы.
[01:21:54.000 --> 01:22:00.000]  Ладно, на сегодня все. Спасибо за внимание.
[01:22:00.000 --> 01:22:02.000]  До встречи.
