[00:00.000 --> 00:14.880]  Еще три пунктика, и первый пункт из тех, что нам надо
[00:14.880 --> 00:20.840]  обсудить, это перегрузка операторов new и delete.
[00:20.840 --> 00:23.320]  Значит, у нас продолжается пока что тема локаторов
[00:23.320 --> 00:24.320]  и выделения памяти.
[00:24.320 --> 00:36.240]  Я буду в основном код писать, я думаю доска мне не очень
[00:36.240 --> 00:37.640]  понадобится в этом деле.
[00:37.640 --> 00:47.160]  Напомню, что у нас есть теперь уже несколько слоев
[00:47.160 --> 00:51.400]  абстракции, когда у нас есть контейнер какой-то,
[00:51.400 --> 00:58.800]  он обращается не напрямую к new, а к локатор trades, которые
[00:58.800 --> 01:03.160]  в свою очередь обращаются к локатору, который обращается
[01:03.160 --> 01:04.480]  к оператору new.
[01:04.480 --> 01:10.120]  В прошлый раз мы разобрали вот этот участок цепочки,
[01:10.120 --> 01:13.120]  пищевой цепочки.
[01:13.120 --> 01:15.320]  Мы понимаем, что никакой контейнер стандартной
[01:15.320 --> 01:17.240]  библиотеки на самом деле оператор new напрямую не
[01:17.240 --> 01:18.240]  вызывает.
[01:19.200 --> 01:25.280]  Но оператор new как и локатор тоже можно переопределять.
[01:25.280 --> 01:28.680]  Можно подменить локатор, а можно подменить оператор
[01:28.680 --> 01:29.760]  new.
[01:29.760 --> 01:35.540]  Переопределение оператора new это гораздо более фундаментальная
[01:35.540 --> 01:38.560]  вещь, чем переопределение локатора, в том смысле
[01:38.560 --> 01:39.860]  еще более глобальное.
[01:39.860 --> 01:43.320]  Вы можете локально подменить локатор в какой-нибудь
[01:43.320 --> 01:44.320]  контейнер.
[01:44.320 --> 01:46.240]  Вот этот контейнер работает пожалуйста с другим локатором.
[01:46.240 --> 01:55.140]  Но C++, как известно, не черпаемо богато, он позволяет вам сам оператор new изменить,
[01:55.140 --> 02:00.400]  поменять его действие. Соответственно, все локаторы, вызывающие оператор new,
[02:00.400 --> 02:03.520]  будут натыкаться на ваш по-новому определенный оператор new.
[02:03.520 --> 02:13.240]  Вот сейчас я скажу очень странную и шокирующую вещь. Тем не менее, это самая главная вещь,
[02:13.240 --> 02:23.360]  которую надо запомнить про оператор new. Вещь такая, оператор new и функция с названием оператор new,
[02:23.360 --> 02:33.240]  это не одно и то же. Есть оператор new, это то, что мы раньше называли оператор new, а сегодня мы
[02:33.240 --> 02:39.360]  изучим штуку, которая называется функцией оператор new. Я не знаю, как это на английском вообще люди
[02:39.360 --> 02:48.040]  понимают, потому что у них еще и называется это одинаково. Ну короче, то, что мы будем
[02:48.040 --> 02:53.760]  переопределять, это не совсем оператор new, это функция с названием оператор new, и это не совсем
[02:53.760 --> 02:59.820]  то же самое. Дело в том, что действие оператора new состоит из двух частей. Сначала он выделяет
[02:59.820 --> 03:04.800]  память, потом вызывает конструкторы. Ну вот что происходит, когда вы, например, давайте я какую-нибудь
[03:04.800 --> 03:27.000]  структуру заведу, логгер, у нее будет конструктор. Я даже установил себе плагинчик, чтобы было какое-никакое
[03:27.000 --> 03:34.120]  автодополнение, а то мы так много времени будем терять. Вот, ну давайте у меня будет такая структурка,
[03:34.120 --> 03:47.600]  которая значит делает лог, что с ней произошло. Создано, уничтожено. New Delete Overloading 9.4, да. Вот,
[03:47.600 --> 04:04.440]  и что происходит, когда я пишу логгер звездочка ptr равно new логгер. На самом деле происходят две
[04:04.440 --> 04:09.240]  вещи последовательно. Вот, когда мы впервые изучали оператора new, мы еще не знали про конструкторы,
[04:09.240 --> 04:15.040]  но теперь мы понимаем, что работа оператора new заключается не только в выделении памяти. Сначала
[04:15.040 --> 04:27.440]  выделяется память, а потом на этом адресе вызывается конструктор. Вот. Вот это вот называется new
[04:27.440 --> 04:37.320]  expression. Ну, выражение new. Да, new что-то там, new te. И вот действие выражения new как раз оно стоит
[04:37.320 --> 04:44.200]  из двух частей. Сначала вызывается функция с названием оператора new, которая выделяет память,
[04:44.200 --> 04:51.760]  а потом на выделенной памяти вызывается конструктор данного типа. И когда говорят
[04:51.760 --> 04:56.600]  о переопределении оператора new, имеют в виду именно переопределение первой части. То есть вы
[04:56.600 --> 05:02.760]  можете переопределить функцию оператора new, но вы не можете переопределить поведение,
[05:02.760 --> 05:10.440]  заключающееся вызове конструктора. Вот. Как переопределить оператор new? Вы должны написать
[05:10.440 --> 05:20.600]  функцию со следующей сигнатурой. Вот звездочка, оператор new от size te, ну скажем n. И вот тут вы
[05:20.600 --> 05:31.760]  должны что-то сделать. Вот эти действия должны сводиться к выделению памяти. Ну, как можно
[05:31.760 --> 05:39.360]  переопределить оператор new? Я сейчас переопределю его неправильно. Я переопределю его очень тупо и
[05:39.360 --> 05:47.120]  неправильно. Ну, что можно было бы сделать? Вот мы сейчас должны написать свое выделение памяти.
[05:47.120 --> 05:52.080]  Вот стандартный оператор new что-то там делает, а мы сейчас по-своему это напишем. Как это написать
[05:52.080 --> 06:01.320]  по-своему? Ну, да, malloc. У нас оператор new мы решились, нам лишились, нам нужна функция malloc. Понятно,
[06:01.320 --> 06:08.160]  что оператор new вызывает сишный malloc. Ну, оператор new это фактически обертка над сишным malloc, умная
[06:08.160 --> 06:15.240]  в некотором смысле. Вот в чем ее ум заключается, мы сейчас разберем. Я вам сейчас, я даже специально
[06:15.240 --> 06:20.720]  заготовил код. Мы сейчас посмотрим просто, как стандартная реализация оператора new выглядит,
[06:20.720 --> 06:25.360]  что она делает. Прям она не очень длинная, можно ее просто прочитать и понять, что она делает,
[06:25.360 --> 06:39.360]  чем она от malloc отличается. Вот, но давайте будем считать, что мы просто делаем вот так. Значит malloc
[06:39.360 --> 06:46.200]  от n. Нормальная, простая реализация оператора new. Давайте я еще вот здесь вот добавлю какой-нибудь
[06:46.200 --> 07:02.760]  тоже лог, чтобы вы понимали, что мы реально сюда попали. Вот, я сейчас очень примитивно
[07:02.760 --> 07:13.840]  переопределил оператор new. Я просто вызвал malloc на n byte из c s t d либо и вернул void звездочку. Вы
[07:13.840 --> 07:19.360]  можете спросить, почему я возвращаю void звездочку, а не t звездочку, и что такое n? Ну n это количество
[07:19.360 --> 07:25.920]  byte, а void звездочку я должен возвращать malloc возвращает void звездочку. Вот, но прикол в том,
[07:25.920 --> 07:30.440]  что оператор new, вот этот вот new expression, он возвращает не void звездочку, а логер звездочку.
[07:30.440 --> 07:37.160]  Но когда мы переопределяем оператор new, это все нам стандартом так гарантировано, что вот если мы
[07:37.160 --> 07:44.120]  хотим переопределить оператор new, нам не нужно думать ничего о типах. Мы получаем, ну то есть
[07:44.120 --> 07:50.720]  компилятор, он так все обустраивает, что реально вызывается наша функция, в которую уже передается
[07:50.720 --> 08:04.440]  правильное число в байтах. И правильно делает, ну нельзя, ну либо глобально, либо в классе можно
[08:04.440 --> 08:11.120]  переопределять оператор new. Вот. Сейчас а n это количество byte? Byte именно, да, это количество byte,
[08:11.120 --> 08:17.360]  которое выделить надо. Оно само вычисляется как-то без вашего участия на лету, то есть когда вас
[08:17.360 --> 08:22.640]  переопределил оператор new, вы количество byte откуда-то получаете от компилятора. Вот компилятор
[08:22.640 --> 08:33.800]  передаст вам правильное. SizeOfLogger умножить на n. Ну в данном случае будет SizeOfLogger. Да, про это мы
[08:33.800 --> 08:38.400]  сейчас поговорим. Вот то, что я сейчас сделал, это глобальное переопределение оператора new. Теперь
[08:38.400 --> 08:43.600]  вообще все вызовы оператора new будут проходить через вот это. В частности, например, если я сейчас
[08:43.600 --> 08:48.520]  заведу вектор, ну давайте, во-первых, я продемонстрирую, что оно так работает.
[09:00.520 --> 09:08.960]  Значит, оно само, вот вся магия промежуточных стадий делается без вас. Все, что вы вольны
[09:08.960 --> 09:14.120]  переопределить, это стадию выделения памяти непосредственно. Вот. Вычистение размеров в
[09:14.120 --> 09:19.720]  байтах, а также каст отводить звездочки к чему надо, производится без вас. И вызов конструктора
[09:19.720 --> 09:25.320]  производится без вас. Вот на том указателе, который вы вернете, будет вызван конструктор данного типа,
[09:25.320 --> 09:31.440]  который просили создать. И это все делается без вашей воли, без вашего участия. Вот. Что сейчас
[09:31.440 --> 09:38.680]  произошло? Я переопределил оператор new для выделения памяти, и мне его вызвали с одним байтом,
[09:38.680 --> 09:46.000]  потому что размер этой структуры один байт, конечно. И вот потом был вызван конструктор.
[09:46.000 --> 09:57.520]  Деструктор вызван не был, кстати, ну логично. Как именно? А кто сказал, что это плохо? Я
[09:57.520 --> 10:07.160]  пока не говорю. А, в смысле, что это совсем неправильное переопределение? А, в этом смысле. Ну,
[10:07.160 --> 10:24.840]  хорошо, давайте поговорим о том, что с проектором случилось. А что с проектором случилось? Ага. Ну,
[10:24.840 --> 10:38.480]  это даже лучше. Хорошо. Почему это неправильное переопределение оператора new? Потому что оно
[10:38.480 --> 10:44.760]  совершенно не удовлетворяет требованиям стандарта, что должен делать оператор new. Давайте вспомним,
[10:44.760 --> 10:50.680]  что мы уже знаем про оператора new. Что он должен делать умного? Ну, например, если не получилось
[10:50.680 --> 10:57.840]  выделить память, он должен кидать std bad alog, а мы вернем null ptr. Вот. Это не то поведение,
[10:57.840 --> 11:07.800]  которое ожидается от оператора new. Нет, нет, неправильно. Здесь с выравниванием нет никаких
[11:07.800 --> 11:14.520]  проблем, но об этом мы позже поговорим. Еще одна проблема, о которой мы, впрочем, не говорили.
[11:14.520 --> 11:24.000]  Оператор new на самом деле, сейчас будет еще одно откровение. Я вас обманывал все это время. На
[11:24.000 --> 11:28.360]  самом деле оператор new не сразу кидает bad alog, если у него не получилось выделить память. Сначала
[11:28.360 --> 11:41.000]  он вызывает так называемую функцию new handler. Значит, стандарт говорит следующее. Если оператор
[11:41.000 --> 11:55.440]  new не получилось выделить память, то он должен вызвать функцию get new handler. Так, сейчас подождите.
[11:55.440 --> 12:07.720]  Опять не туда. Нет, вот сюда, да. Так, сейчас. Давайте я вам открою на себе периферен соответствующую
[12:07.720 --> 12:16.680]  страницу. Пожалуйста, выдерни капель и воткни обратно. Что, что ужасно? Это Мексика. Мексика?
[12:16.680 --> 12:46.200]  Голливудская Мексика, все желтая. Сейчас. Вот, по стандарту есть такая функция get new handler.
[12:46.200 --> 13:03.840]  Ну хорошо, давайте. Ого, это что там, контакт плохой что ли? Да, я заметил, да. Может это дело
[13:03.840 --> 13:11.680]  в контакте? О, да, похоже. Я его чуть-чуть шевелю и он меняет цвет. А вот сейчас я его не шевелю,
[13:11.680 --> 13:17.520]  а цвет он все равно меняет. Слушайте, ну я не знаю, ну придется так жить, ну что я могу поделать.
[13:17.520 --> 13:34.160]  Так, давайте не задерживаться. Так вот, есть такая функция std get new handler. Что она делает? Она
[13:34.160 --> 13:41.680]  возвращает currently installed new handler, which may be a null pointer. Значит, handler это обработчик.
[13:41.680 --> 13:51.240]  Ситуация, когда не получилось выделить память. Вот, вы можете кастомизировать функцию, которая
[13:51.240 --> 13:55.280]  будет вызываться оператором new стандартным, в случае, если у него не получилось выделить
[13:55.280 --> 14:00.080]  память, перед тем, как он отчается и кинет badlog. На самом деле, есть еще одна промежуточная стадия,
[14:00.080 --> 14:05.960]  когда у нее не получилось выделить память, он сначала вызывает функцию new handler. А как он
[14:05.960 --> 14:14.040]  понимает, что это за функция? А он просто вызывает вот эту функцию std get new handler. И если она
[14:14.040 --> 14:21.760]  возвращает null ptr, это значит, что, ну все, нечего вызывать, нет никакой функции, кидаем badlog. А если
[14:21.760 --> 14:29.280]  она возвращает какой-то function pointer, то он вызывает функцию по этому адресу. Вот, и заново пытается
[14:29.280 --> 14:36.600]  вызвать malloc после этого. Ну давайте я вам просто, что уж говорить, давайте я вам просто покажу код. Да,
[14:36.600 --> 14:42.920]  там и есть цикл. Давайте я вам просто покажу код, в конце концов. Мы с вами так много говорим,
[14:42.920 --> 14:51.200]  я вам просто код сейчас покажу. Вот это код стандартной библиотеки Selang. Вот, значит,
[14:51.200 --> 15:01.600]  так выглядит код стандартного оператора new. По умолчанию, который работает. Вот. Так, давайте
[15:01.600 --> 15:05.680]  мы не будем придираться к коду стандартной библиотеки. Больше, пожалуйста, вот вопросы,
[15:05.680 --> 15:11.400]  почему такой странный код style в стандартной библиотеке не принимается. Я не готов обсуждать это.
[15:11.400 --> 15:24.920]  Вот такая сигнатура. Здесь происходит следующее. Ну вот эти строчки я пока оставлю без комментариев.
[15:24.920 --> 15:39.520]  Так, господа, я не шучу. Код style мы не обсуждаем, иначе мы никогда не закончим дискуссию. Стандартная
[15:39.520 --> 15:47.320]  библиотека это отдельная история. Их код style это что-то непостижимое. Мы не обсуждаем его. Вот.
[15:47.320 --> 15:55.400]  Смотрите, что происходит. Вот берется этот поинтер, и пока malloc возвращает null ptr,
[15:55.400 --> 16:05.400]  мы пытаемся вызвать new handler. Если он не нулевой, мы его вызываем, иначе кидаем badlock.
[16:05.400 --> 16:21.160]  Вот. Да. И возвращаемся в вайле в начало. Мы вызываем в цикле new handler. Как теоретически
[16:21.160 --> 16:27.840]  мог бы new handler что-то исправить? Теоретически new handler это функция, которая может что-то
[16:27.840 --> 16:38.000]  попробовать освободить, допустим. Ну да, то есть вы можете у вас может быть какой-нибудь очень
[16:38.000 --> 16:43.400]  долгоживущий сервер какой-нибудь, на котором если new понимает, что ему памяти не хватает,
[16:43.400 --> 16:49.880]  то new handler вы определяете такой, чтобы он что-нибудь старое, древнее решил освободить. Ну что-нибудь
[16:49.880 --> 16:55.560]  типа garbage collector, да. Вот. В конце концов он возвращает вот это p. Вот. Ну тут, видите,
[16:55.560 --> 17:02.680]  еще есть значит ifdef если no exceptions, то есть если мы force'им в параметрах компиляции,
[17:02.680 --> 17:08.400]  что мы без исключений работаем, то мы просто не кидаем ничего. Вот. Тут есть интересное вот это
[17:08.400 --> 17:15.240]  вот интересный макрослип cpp weak. И тут есть комментарий, что это означает implement all new
[17:15.240 --> 17:22.320]  and delete operators as weak definitions, so that they can be overridden. Вот. Вообще в нормальной ситуации,
[17:22.320 --> 17:27.520]  если вы переопределяете функцию с такой же сигнатурой, то вы получаете ce со словами
[17:27.520 --> 17:33.040]  «такая функция уже определена». Но здесь вот этот вот макрослип cpp weak — это такой костыль,
[17:33.040 --> 17:36.800]  который говорит компилятору. Вот конкретно для этой функции, если вдруг ты встретишь другое
[17:36.800 --> 17:41.600]  определение, то забудь про это и используй то. Так это и работает. То есть на самом деле,
[17:41.600 --> 17:46.320]  когда вы глобально переопределяете оператор new, по стандарту компилятор обязан забыть стандартное
[17:46.320 --> 17:55.280]  определение и начать использовать ваше. Ну разумеется, разумеется. Это внутренняя кухня. Да,
[17:55.280 --> 17:59.800]  это конечно не нужно так делать. Вот. Но это просто костыль, потому что стандарт от компилятора
[17:59.800 --> 18:07.760]  требует вот такого поведения. Вот. Так. Вопрос, почему, ну то есть как стандартный new должен
[18:07.760 --> 18:15.600]  себя вести исчерпан. В принципе, если вы захотите его переопределить, то теперь вы знаете как.
[18:15.600 --> 18:23.240]  А как, собственно, new handler-то поменять? Я вам сказал, что есть функция get new handler,
[18:23.240 --> 18:37.200]  но есть логичная функция set new handler. Собственно, эта функция, которая позволяет вам установить
[18:37.200 --> 18:42.920]  новый new handler, вы определили какую-нибудь функцию и function pointer на эту функцию передали в set new
[18:42.920 --> 18:49.920]  handler. У нас уже была аналогичная ситуация. Помните с чем? Похожая пара функций get set,
[18:49.920 --> 18:58.040]  вот с какими-то function pointers-ами уже была. Кто помнит? Я помню, что была. Ха-ха-ха-ха. Ну ладно.
[18:58.040 --> 19:07.160]  Значит летом вы все вспомните. Ну была пара get terminate, get terminate и set terminate. Да,
[19:07.640 --> 19:13.000]  мы этим занимались, когда исключения обсуждали. У нас была функция std terminate,
[19:13.000 --> 19:19.120]  которую можно было подменить с помощью set terminate и узнать чему равна текущая функция
[19:19.120 --> 19:26.920]  с помощью get terminate. То же самое с new handler. Вот, да, а вот это что такое? Я так и не сказал.
[19:26.920 --> 19:39.320]  Что вы по этому поводу думаете? Ну что мы не можем выделять 0 байт, поэтому давайте выделим 1.
[19:39.320 --> 19:45.440]  То есть если у нас объект, в котором нет полей, то мы под него выделяем 1 байт. Нет, объект,
[19:45.440 --> 19:53.760]  в котором нет полей, он занимает 1 байт. Скорее, если нам просят выделить массив из нуля элементов,
[19:53.760 --> 20:00.800]  то мы должны корректно это обработать все равно и на самом деле выделить массив из одного элемента.
[20:00.800 --> 20:10.200]  Вот оператор new корректно это обработает. К сожалению, я не помню пример, когда это может быть
[20:10.200 --> 20:28.920]  нужно, но в общем стандарт требует, так скажем. Так решил комитет. В целом примерно так же выглядит
[20:28.920 --> 20:38.640]  это стд либо силенга. В целом можно посмотреть и в стд либо g++ написано примерно то же самое.
[20:38.640 --> 20:53.920]  Вот, хорошо. Давайте теперь откроем, собственно, вот эту страничку. Я вам показал, как переопределять
[20:53.920 --> 21:03.040]  оператор new вот с такой сигнатурой. Но на самом деле существует 22 разновидности оператора new,
[21:03.040 --> 21:15.040]  которые перечислены вот на этой странице. Вот, давайте разберем их по очереди. Во-первых,
[21:15.160 --> 21:25.920]  отдельно функцией является оператор new с квадратными скобочками. Вот, оператор new с квадратными
[21:25.920 --> 21:34.400]  скобочками это другая функция. Вот если я сейчас напишу new логер квадратной скобочки, не знаю,
[21:34.400 --> 21:48.760]  опять, то в эту функцию я не попаду. Ой, нет, я все равно в нее попал. А, правильно, да, совершенно,
[21:48.760 --> 21:54.200]  да, да, да, ты прав. Оператор new с квадратными скобочками, ну в принципе это тоже можно прочитать
[21:54.200 --> 21:59.400]  здесь же. Собственно, что тут далеко ходить? Оператор new с квадратными скобочками просто вызывает
[21:59.400 --> 22:15.240]  оператор new. Вот, ну, формально это разные функции, хотя по факту они делают одно и то же. Ну,
[22:15.240 --> 22:19.840]  можно переопределить оператор new с квадратными скобочками отдельно. Да, ну, тем не менее,
[22:19.840 --> 22:30.800]  оператор new с квадратными скобочками он, ну, давайте я его отдельно переопределю и вы поймете,
[22:30.800 --> 22:34.960]  что он все-таки является отдельной функцией. Вот, оператор new с квадратными скобочками,
[22:34.960 --> 22:47.680]  size to n, и вот здесь я напишу вот так, а потом верну оператор new от n. Да, что вы хотели сказать?
[22:47.680 --> 22:56.760]  Как это? Нет, нет, у нас пять раз конструктор вызвался, а new вызвался один раз.
[22:56.760 --> 23:16.360]  Кстати, отличный вопрос, а вот это что такое? Почему 13?
[23:16.360 --> 23:28.920]  Потому что захотел. Кто помнит первый семестр, мы обсуждали это. Да, на самом деле,
[23:28.920 --> 23:32.520]  когда вы вызываете оператор new с квадратными скобочками, вы запрашиваете памяти больше,
[23:32.520 --> 23:44.600]  чем size of умножить на n. Напоминаю, да, напоминаю, у нас размер одного логера один, и мы выделяем
[23:44.600 --> 23:49.680]  пять штук, но запрашивается 13, потому что запрашивается 5 плюс 8, потому что на самом деле
[23:49.680 --> 24:00.680]  запрашивается n умножить на size of t плюс size of size t. Зачем? Да потому что перед этим массивом
[24:00.680 --> 24:07.280]  компилятор собирается положить число, в котором написано, сколько штук было этих элементов
[24:07.280 --> 24:17.720]  в массиве, и он делает это тоже без вашего участия сам, да. Нет, это implementation defined,
[24:17.720 --> 24:31.120]  но по факту компиляторы, все нормальные компиляторы так делают, вот, но вы не можете
[24:31.120 --> 24:37.000]  на это полагаться. И вот сейчас, если я приду, сейчас, если я вот это вот вызову, я вот сейчас
[24:37.000 --> 24:43.960]  так сделаю. Ну, вы видите, у меня вызвался вот этот оператор тоже числом 13, то есть на самом
[24:43.960 --> 24:52.640]  деле мне уже в оператор new с квадратной скобочке пришло число 13, а потому что компилятор за меня
[24:52.640 --> 24:58.480]  рассчитал, что надо выделить size of, меня попросили new логер 5, но на самом деле компилятор рассчитал,
[24:58.480 --> 25:05.120]  что надо size of логер умножить на 5 плюс вот это вот число, куда я сам положу, и это все само
[25:05.120 --> 25:09.800]  происходит без вашего участия, то есть когда оператор new с квадратной скобочке возвращает
[25:09.800 --> 25:14.840]  указатель, дальше без вашего участия происходит сохранение числа по нужному адресу и вызов
[25:14.840 --> 25:22.440]  конструкторов. Ну, на самом деле то, что я здесь делаю, это уб, вот в этом коде уб, знаете почему,
[25:22.440 --> 25:28.320]  потому что я оператор new написал свой, а delete свой не написал. Если я приобрел оператор new,
[25:28.320 --> 25:39.160]  то и delete мне надо переопределить. Давайте приобрелю оператор delete. Ну, вызывается
[25:39.160 --> 25:47.360]  стандартный delete, но кажется, что пара new custom и delete стандартный, это формально уб, хотя
[25:47.360 --> 25:56.640]  по факту ничего плохого не происходит. Да, что? По-моему нельзя, по-моему вы обязаны,
[25:56.640 --> 26:03.200]  ну я не помню формальностей, формально по-моему это все уб, но вот по факту конечно ничего плохого
[26:03.200 --> 26:09.200]  не происходит, потому что понятно, что происходит здесь, но стандарту кажется, говорит, что если вы
[26:09.200 --> 26:16.440]  определяли свой new, то и свой delete тоже нужно. Вот, ну что принимает оператор delete? Он принимает
[26:16.440 --> 26:43.800]  void звездочка P и кажется больше ничего. Да, и он еще no accept начинается и плюс 11. Вот, возможно,
[26:43.800 --> 26:51.040]  если я этого не напишу, он даже не переопределится нормально. Вот, что этот оператор delete должен
[26:51.040 --> 26:59.520]  делать? Он просто должен сделать free от P. Вот, вопрос, а нафига тогда число-то мы все-таки
[26:59.520 --> 27:08.080]  сохраняли? Точнее вот, вот смотрите, у нас оператор delete с квадратными скобочками, он точно такой же,
[27:08.080 --> 27:17.080]  то есть вот я могу написать и вот сюда вот вставить вот эту сигнатуру и здесь тоже сделать free от PTR.
[27:17.080 --> 27:33.440]  Вот, а нафига же мы сохраняли число? Хорошо, я и здесь и здесь веду себя одинаково, когда я выделял
[27:33.440 --> 27:40.720]  массив, а когда я выделял немассив, я во free отдаю один лишь указатель. Нафига же я в одном случае
[27:40.720 --> 27:59.760]  сохранял число, в другом нет. Кого этих вот? Этих вот кого? Да, а для чего он его использует?
[27:59.760 --> 28:09.080]  Что значит освободить? Вопрос в том, зачем оператор new квадратной скобочки на самом деле сохраняет
[28:09.080 --> 28:16.680]  число слева от массива, если в оператор delete это число уже не передается, а передается только P.
[28:16.680 --> 28:23.720]  В какой момент ему оказывается нужно это число реально?
[28:23.720 --> 28:39.600]  Нет, это предположение не рабочее, потому что мы одинаково вызываем free, хоть мы массив удаляем,
[28:39.600 --> 28:44.720]  хоть мы немассив удаляем. Cish на функция free просто принимает указатель и она уже точно не
[28:44.720 --> 28:55.240]  может полагаться на то, что там какое-то число слева лежит. Потому что мы выделяем память
[28:55.240 --> 29:04.040]  единым куском, мы один запрос делаем на память. Вот господин Барыкин правильно сказал, мы на
[29:04.040 --> 29:11.040]  самом деле вызываем деструкторы, вот что мы забыли. Вот это число, которое сохраняет компилятор
[29:11.040 --> 29:18.920]  слева от массива, оно нужно на уровне абстракции C++, дальше на уровень язык оси оно не передается.
[29:18.920 --> 29:25.920]  Оно нужно на этой промежуточной стадии до того, как вы вызвали функцию с названием оператор delete,
[29:25.920 --> 29:37.800]  чтобы вызвать деструктор нужное количество раз. Это число говорит компилятору, сколько штук
[29:37.800 --> 29:46.040]  деструкторов вызвать. То есть free только вызывает деструкторы и все? Free? Никаких деструкторов,
[29:46.040 --> 29:49.840]  это Cish-ная функция, в C вообще нет такого понятия деструктор. А как free понимает,
[29:49.840 --> 29:56.760]  сколько памяти освободить? А это внутренняя логика malloc и free. Когда вы вызываете malloc,
[29:56.760 --> 30:04.960]  он очень сложно устроен внутри, он запоминает хитрую сам таблицу храни, по какому указателю,
[30:04.960 --> 30:12.520]  что сколько там было выделено. А вот мы запоминаем число не для того, чтобы malloc им там пользовался или
[30:12.520 --> 30:18.720]  free. Они сами запоминают, что им надо. malloc и free запоминают какие-то числа для себя сами,
[30:18.720 --> 30:25.440]  если им надо. А мы на уровень выше, еще число наверх, нас запоминаем, чтобы перед оператором
[30:25.440 --> 30:33.400]  delete вызвалось нужное количество деструкторов. Чтобы, когда ваш код компилировал, вот этот код,
[30:33.400 --> 30:40.520]  когда мы напишем сейчас delete квадратной скобочки, ptr, во что это превращается? Это
[30:40.520 --> 30:46.680]  превращается на самом деле в цикл, то есть что делает компилятор при таком коде? Он делает цикл
[30:46.680 --> 30:55.960]  for от 0 до того числа, которое левее ptr лежит на 8, ну там, возможно, с какой-то поправкой. Сделать
[30:55.960 --> 31:03.320]  tilde logger, он же знает тип, вызвать деструктор соответствующего типа вот столько раз,
[31:03.320 --> 31:09.840]  сколько написано слева, а потом вызвать функцию с названием оператор delete квадратной скобочки
[31:09.840 --> 31:16.400]  от пойнтера уже сдвинутого на 8 влево. Вот что на самом деле происходит, когда вызываете оператор
[31:16.400 --> 31:25.640]  delete. И переопределить вызов деструкторов нельзя, и переопределить вызов конструкторов нельзя,
[31:25.640 --> 31:33.920]  можно переопределить только выделение памяти. А вот можно вопрос, у нас же delete, он каким-то
[31:33.920 --> 31:42.320]  образом по сути отмечает, что у нас куча там теперь в этот память свободно. Кто? Что? Delete?
[31:42.320 --> 32:05.440]  Мы не можем полагаться на то, что внутри себя делает free, потому что free это следующий
[32:05.440 --> 32:10.240]  уровень абстракции, мы работаем с ним как с черным ящиком. На самом деле malloc и free устроены
[32:10.240 --> 32:18.420]  очень сложно, и мы не можем полагаться на то, что они внутри там знают, но нам нужно на своем
[32:18.420 --> 32:22.640]  уровне запомнить число, чтобы количество деструкторов правильно вызвать. А когда мы
[32:22.640 --> 32:27.280]  вызываем malloc и free, мы просто полагаемся, что они как-то работают и возможно взаимодействовать с
[32:27.280 --> 32:32.480]  операционкой, но это не точно. Ну вот они сложно на самом деле очень устроены. Реализация malloc
[32:32.480 --> 32:59.720]  современная, она там занимает, не знаю, строк тысячу может быть. Да. Сейчас.
[33:02.480 --> 33:24.040]  Ну не знаю, у меня все компилируется. Кого поставить? Ну хорошо.
[33:24.040 --> 33:42.520]  Ну у меня ничего подобного. Вот, ну есть разные версии. Есть версия оператора delete с числом.
[33:42.520 --> 33:57.680]  Честно говоря, я не знаю, зачем она нужна и кто ее вызывает. А, ну да, смотрите, вот если вы, вот,
[33:57.680 --> 34:06.120]  оператор delete, есть у нее версия с числом еще. Она вызывается вместо первой версии, если,
[34:06.120 --> 34:19.200]  ну, в общем, если дана, если таковая определена. Вот. Тогда вызывается, тогда предпочтение будет
[34:19.200 --> 34:24.960]  отдано ей. Но можно обойтись и без нее, кажется, и вот этим всем обойтись. Ну, то есть, если вы
[34:24.960 --> 34:30.840]  хотите каким-то, почему-то, вы хотите следить в операторе delete, сколько вы байт освобождаете
[34:30.840 --> 34:34.760]  сейчас, то вы можете приобрететь эту и тогда всегда будет выбираться она вместо той. Видимо,
[34:34.760 --> 34:44.960]  что-то такое. Вот. Давайте бегло просмотрим. Нет, вы можете просто хотеть, чтобы вы в delete
[34:44.960 --> 34:49.680]  знали, сколько байт вы сейчас освобождаете. Это возможно, потому что вам будет просто,
[34:49.680 --> 34:55.120]  точно так же, как в new, вам будет отдаваться size of, ну компилятор же знает, он, либо вам будет
[34:55.120 --> 35:02.680]  отдавать size of t, либо size of t, может, на n, плюс там вот этот 8. То есть, вызывается он абсолютно так же,
[35:02.680 --> 35:09.680]  просто поставляется вместо. Ну да, да, да. То есть, если хотите, можно, видимо, им пользоваться вместо
[35:09.680 --> 35:13.680]  этим. Вот. Давайте бегло просмотрим остальные версии оператора new, их все можно переопределить.
[35:13.680 --> 35:25.680]  Вот особый интерес вызывает вот эти вот версии. Смотрите, вот есть такая, а, да, ну, для начала,
[35:25.680 --> 35:31.640]  вообще, как пользоваться нестандартными версиями new. Вот, например, вот есть такая версия, оператор
[35:31.640 --> 35:50.760]  new size account std no throw tag. Это что такое? Кто помнит, что это за оператор new? Да. Гений. Да. Мы вкратце упоминали
[35:50.760 --> 35:56.760]  такой оператор new, когда говорили об исключениях. Тоже я вам про него рассказывал. Это, этот оператор
[35:56.880 --> 36:05.720]  new вызывает stag. Вы пишите new, ну, я могу вот так просто сделать, вот здесь вот, new в скобочках
[36:05.720 --> 36:19.920]  std no throw от logger. Вот. И это будет не бросающая версия оператора new. На lptr возвращает. То есть,
[36:19.920 --> 36:31.800]  у оператора new есть no throw версия. Это отличный вопрос, мы его обсудим чуть позже. Пока, пока
[36:31.800 --> 36:40.200]  игнорируем этот, это тонкий момент. Вот. Ее тоже можно переопределить. Какая сигнатура для
[36:40.200 --> 36:49.200]  переопределения этой штуки? Ну, надо просто переопределить вот это вот еще с... Ну, понятно.
[36:49.200 --> 37:05.280]  С не no accept, а no throw. Причем const std no throw t. Вот это будет не бросающая версия. No throw new
[37:05.280 --> 37:16.360]  cold. Да. No throw t это такой тег. Что такое тег? Это просто пустая структура, которая нужна только
[37:16.360 --> 37:26.360]  для диспетчеризации, чтобы выбирать между версиями функций. Какой бул? Потому что там есть
[37:26.360 --> 37:34.720]  много разных тегов. Вот, например, есть тег... Ну ладно, тут больше тегов нет, но есть кое-что
[37:34.720 --> 37:48.000]  другое. Вот, например, есть placement new. Узнаете? Это placement new. Что эта функция делает? Вот вопрос
[37:48.000 --> 38:01.560]  на понимание, как выглядит стандартная реализация вот этой функции. Значит, вопрос еще раз. Вопрос
[38:01.560 --> 38:13.360]  на понимание, как выглядит стандартная реализация вот этой вот функции. Просто return ptr и все. Потому
[38:13.360 --> 38:21.800]  что placement new это штука, которая вызывается, когда память уже выделена, надо лишь конструктор
[38:21.800 --> 38:25.720]  вызвать, но часть выделения памяти уже сделана. Нам ничего не надо делать, поэтому мы просто
[38:25.720 --> 38:40.880]  возвращаем ptr. Перегружать это, кажется, нельзя. Я, кстати, в предыдущие годы ошибочно на лекции
[38:40.880 --> 38:45.560]  говорил, что это можно перегружать, а потом понял, что, кажется, это нельзя перегружать. Ну вот именно
[38:45.560 --> 38:51.320]  placement new стандарт почему-то запрещает перегружать. Ну ладно, я не буду тут читать подробности. Вот,
[38:51.320 --> 38:57.920]  давайте посмотрим на еще что-нибудь. Ну про eline я пока не буду говорить. Давайте посмотрим вот
[38:57.920 --> 39:04.560]  еще на это. User defined placement allocation functions. Смотрите, вы можете создать функцию оператор new с
[39:04.560 --> 39:11.320]  кастомными параметрами. То есть вы можете переопределить оператор new с каким угодно набором
[39:11.320 --> 39:29.200]  параметров. Вы можете сказать new 123 logger от 5. И здесь вы можете написать, допустим, ну первым
[39:29.200 --> 39:35.640]  параметром всегда идет size t, а вот здесь вы можете сколько угодно параметров написать int int int.
[39:35.640 --> 39:41.080]  И здесь вы скажете custom new colt.
[39:41.080 --> 40:09.880]  Да. А, здесь, здесь это не работает. Сейчас, подождите, да, это не работает, потому что квадратных
[40:09.880 --> 40:27.560]  скобочек я не реализовал, а вот теперь нормально должно быть. Ну это какой-то, ну типа скорее на
[40:27.560 --> 40:40.640]  оборот. No throw реализован через обычный. No throw реализован через обычный, просто он все ловит,
[40:40.640 --> 40:50.080]  если что-то вылетело и кидает. Да, вообще довольно странно, что не наоборот, кстати, это интересный
[40:50.080 --> 40:53.840]  вопрос, почему так сделано, потому что кажется, что это накладные расходы на исключения, которых
[40:53.840 --> 41:04.640]  можно было бы избежать. Да, непонятно. Ну, по сравнению с вызовом самого new это все равно не очень
[41:04.640 --> 41:12.080]  много кажется, но, кстати, это вопрос действительно очень хороший, почему так сделано. Ну вот в стандартной
[41:12.080 --> 41:18.880]  библиотеке no throw new реализован через обычный new, хотя казалось бы логичнее наоборот, чтобы не,
[41:19.040 --> 41:25.200]  чтобы не иметь дело с исключениями, если мы не хотим, а тут написано no throw new просто делает
[41:25.200 --> 41:34.720]  подтраем обычный new и все ловит и проглатывает. Вот это как-то странно, ну я вот ничего не придумывал.
[41:34.720 --> 41:44.520]  Ну я не знаю, может у них есть какая-то мотивация, может это просто недоработка в стандартной
[41:44.520 --> 41:52.680]  библиотеке, можно сделать, можно попытаться сделать commit и исправить, я не знаю. New, который,
[41:52.680 --> 42:07.320]  если не удалось выделить память, возвращает на lptr, а ничего не кидает. Так, дальше, вот, можно
[42:07.320 --> 42:15.120]  определить new с кастомными параметрами. Правда, ну с какими угодно параметрами вы можете определить
[42:15.120 --> 42:20.840]  свое new. Правда, если вы такое new определили, то вам и delete нужно парное к нему определить
[42:20.840 --> 42:27.160]  с кастомными параметрами, иначе это кажется будет все опять-таки уб. Вот, мне теперь надо написать void
[42:27.160 --> 42:42.560]  оператор delete от void звездочка P и трех интов, и тут сделать там тоже free от P, чтобы избежать уб,
[42:42.560 --> 42:50.760]  ну потому что если я вызываю, если я делаю delete не той версией, которой делаю new, это формально уб.
[42:50.760 --> 42:58.160]  Вот, правда есть проблема. У оператора delete нет синтаксиса вызова с кастомными параметрами,
[42:58.160 --> 43:06.680]  нельзя написать delete от 123ptr. Поэтому, если мне хочется использовать кастомный оператор delete,
[43:06.680 --> 43:11.840]  то мне придется вручную писать вызов деструктора и вызов функции оператор delete. Мне придется писать
[43:11.840 --> 43:30.160]  ptr tilde logger, а потом 2.2.operaтор delete от ptr 1.2.3. То есть, если мы сделали такой кастомный new,
[43:30.160 --> 43:34.240]  тогда нам нет другого выбора, как писать void оператор. Да, если вы сделали new с кастомными
[43:34.240 --> 43:38.600]  параметрами, то вам придется и delete вызывать с кастомными параметрами, но до этого самим вызывать
[43:38.600 --> 43:44.960]  деструктор. Ну нету синтаксиса у delete вызова с кастомными параметрами, вот почему-то не сделали,
[43:44.960 --> 43:56.720]  не знаю. Вот, впрочем, есть один забавный кейс. Вот давайте вернем, значит, а не, не буду ничего
[43:56.720 --> 44:07.600]  возвращать. Смотрите, вот что будет, кто-то этот вопрос уже задавал. Что будет, если я в конструкторе
[44:07.600 --> 44:18.360]  брошу исключения в момент, когда делается вызов new? Ваши версии.
[44:18.360 --> 44:48.320]  Куда? Кто память освободит? Ведь смотрите, как работает, еще раз, как работает оператор,
[44:48.320 --> 44:57.840]  выделяется память, вызывается конструктор, и вам возвращается указатель на этот t. Память уже
[44:57.840 --> 45:02.680]  выделилась, и тут вызывается конструктор, и конструктор бросает исключение. Кто освободит
[45:02.680 --> 45:14.640]  память? А кто ее попросит? Нет, а если не завершится, если мы это все поймаем вот здесь вот,
[45:14.640 --> 45:22.680]  то есть получается, что если в конструкторе во время выделения динамической памяти вылетел
[45:22.680 --> 45:29.760]  исключение, то это гарантированный memo relic. Ничего с этим сделать нельзя. А кто вызовет-то его в
[45:29.760 --> 45:38.360]  какой момент? Нет, то есть функция оператора new, она только память выделяет. Эта часть работала
[45:38.360 --> 45:48.560]  корректно, исключение не вылетело. Кинуло исключение конструктор. Ну, в целом, да,
[45:48.560 --> 45:53.920]  значит, это обязанность компилятора. Значит, стандарт говорит, если в момент выделения памяти
[45:53.920 --> 45:59.760]  оператора new, точнее не в момент выделения памяти, а в момент вызова конструктора после выделения
[45:59.760 --> 46:06.080]  памяти оператора new вылетело исключение, то компилятор сам обязан вызвать соответствующий
[46:06.080 --> 46:14.280]  оператор delete и только потом вам отдать, что делать с этим исключением. Поэтому, на самом деле,
[46:14.280 --> 46:19.600]  сейчас будет вызван кастомный оператор delete. Вот это тонкий момент, когда у вас вылетело
[46:19.600 --> 46:25.520]  исключение. После того, как вы сделали кастомный new, компилятор сам найдет delete с такими же
[46:25.520 --> 46:30.560]  точно параметрами и вызовет его в случае, если вылетело исключение в конструкторе. Так что
[46:30.560 --> 46:40.200]  сейчас будет кастом delete called. Ну, оно не произошло, потому что это УБ, потому что,
[46:40.200 --> 46:46.360]  когда вы меня не поймали на исключение, delete имеет право не вызываться, но вот так оно должно
[46:46.360 --> 47:06.800]  произойти. Вот, custom delete called, потому что комитет по стандартизации так решил. Так, хорошо.
[47:16.360 --> 47:24.360]  Указатель, который создан просто new, почему мы так не можем сделать? Чего-чего? Мы создали new без
[47:24.360 --> 47:31.320]  квадратных скобочек какой-то объект. Да. И потом вызвали от него дали квадратные скобочки. Нет,
[47:31.320 --> 47:37.920]  не квадратные. Вот этот мы вызвали. А если мы вызовем квадратные? УБ будет что. Почему это не
[47:37.920 --> 47:43.680]  будет работать? Но если даже в стандарте реализация, то тоже самое, просто free вызвать.
[47:43.680 --> 47:53.520]  Delete квадратной скобочки вызывает n деструкторов. Смотрит на число слева от массива, вызывает
[47:53.520 --> 48:03.360]  количество деструкторов. Только потом функцию оператора delete. Так, дальше. Можно переопределить
[48:03.360 --> 48:10.480]  оператор new для своих типов отдельно. Не глобально, а для своих типов. Вот это class
[48:10.480 --> 48:24.080]  specific allocation functions. Вы можете сделать в своем классе метод оператор new. Вот, например, здесь. Я
[48:24.080 --> 48:42.560]  могу сделать вот такой метод. И здесь напишу class specific new cold. Теперь, когда я буду вызывать new...
[48:54.080 --> 49:01.680]  Когда я буду вызывать new стандартный для своего класса, у меня будет вызываться специфичный new.
[49:01.680 --> 49:15.280]  Class specific new cold. Вот. Как это работает? Но также по правилу частное предпочтительнее общего.
[49:15.280 --> 49:21.920]  Если у вас есть специфичный для вашего класса оператор new, то выбирается он. Если его нет,
[49:21.920 --> 49:26.960]  то ищется, не переопределили вы глобальный оператор new. И только иначе вызывается стандартный.
[49:26.960 --> 49:31.120]  То есть теперь вот для объектов logger будет вызываться специфичный оператор new,
[49:31.120 --> 49:38.480]  который в классе определен. Вот. Я здесь не написал слово static. Но это, тем не менее,
[49:38.480 --> 49:47.880]  работало. Почему? Ну, это же не метод объекта, это же метод, относящийся к всему классу. Потому
[49:47.880 --> 49:52.360]  что так решил комитет по стандартизации. Значит, случаи оператора new, они статические,
[49:52.360 --> 50:00.120]  даже если не написан static. Можно не писать static, оператор new, оператор delete все равно
[50:00.120 --> 50:10.680]  будут считаться статическими функциями. Вот. Да.
[50:17.880 --> 50:28.360]  Ну и то же, да, ну delete вызывается стандартный, но это уб. А может даже никакой не вызывает. Короче,
[50:28.360 --> 50:32.920]  я не знаю, это уб. Но мне, если я сделал кастомный для класса оператора new, то надо и оператор delete
[50:32.920 --> 50:41.640]  сделать кастомный. Вот. Два еще маленьких момента обсудим и пойдем к следующему пункту.
[50:41.640 --> 50:58.000]  Еще я только проверю, что я ничего не забыл, как всегда. Вот. Ну, с исключениями понятно. Если мы
[50:58.000 --> 51:02.320]  вылетел исключение в конструкторе, значит этот случай мы разобрали.
[51:11.640 --> 51:26.520]  Смотрите, какая история.
[51:26.520 --> 51:53.800]  Значит, я уже жду, что у людей начинаются некоторые. Да, да, ну сейчас должна возникать уже боль,
[51:53.800 --> 52:00.880]  когда начинаю такое писать в определенных местах. Значит так, вот смотрите, я вот так сделал,
[52:00.880 --> 52:23.320]  а теперь я говорю. Не-не, все гораздо проще. Не-не-не, нет, вот так. Вопрос. Как это работает?
[52:23.320 --> 52:38.240]  Откуда оператор delete в таком сценарии будет знать, сколько байт ему принять в качестве вот этого вот?
[52:38.240 --> 52:50.040]  Точнее, нет, не сколько байт ему принять, сколько байт ему принять. Ему вот, да, вот это работает
[52:50.040 --> 53:00.800]  нормально, потому что оператору delete на самом деле не нужно знать количество байт. Вот, но хорошо, хорошо, хорошо.
[53:00.800 --> 53:24.680]  Да, да, да, да, да, да, смотрите, смотрите, смотрите, да, да, да, вот смотрите, я говорю так, а потом я как раз,
[53:24.680 --> 53:33.960]  видите, думаю, вот сын, вот сын, наследник мамы и папы. Ну, неважно какие тут поля, тут не знаю,
[53:33.960 --> 53:46.600]  с. Вот, и теперь я говорю sun, нет, не так я говорю, father звездочка f равно new sun. И говорю delete f. Вот,
[53:46.600 --> 53:52.920]  вот этот вопрос меня больше интересует. Откуда оператор delete знает, какой pointer?
[53:52.920 --> 54:06.040]  Знает, что ему чистить вообще. Да. Ну, dead, да. Ну, в оператор delete. Откуда delete знает, что на самом деле мы
[54:06.040 --> 54:13.560]  сам и у нас нужно почистить четыре? Откуда оператор delete узнает, что ему вот сюда нужно
[54:13.560 --> 54:22.400]  принять не тот pointer, от которого мы формально вызвельнулись, а сдвинутый? А откуда он ее возьмет,
[54:22.400 --> 54:37.280]  ее нет же. У нас нет ничего виртуального. Так, поднимите руки, кто понимает проблему. А кто
[54:37.280 --> 54:50.280]  понимает, как она решается? Комитет по статартизации, конечно, понимаю. Я тоже понимаю. Я не до конца
[54:50.280 --> 54:55.200]  понимаю, на самом деле. Ну, ответ простой, надо просто виртуальный деструктор объявить. Надо,
[54:55.200 --> 55:02.160]  короче, чтоб тип был полиморфным, иначе это тоже не будет работать. Это действительно да, уб. Это
[55:02.160 --> 55:08.360]  действительно уб. Потому что delete в таком сценарии никак не поймет, по какому указателю ему чистить.
[55:08.360 --> 55:18.280]  Если тип полиморфный, то оператор delete сможет увидеть вот этот топов, он поймет сдвиг относительно
[55:18.280 --> 55:23.560]  начала объекта и функцию оператора delete отдаст нужный pointer. Именно так и действует оператор
[55:23.560 --> 55:29.640]  delete по стандарту. Он обязан, если тип полиморфный, сперва заглянуть, а что там написано, какой там
[55:29.640 --> 55:37.840]  сдвиг и вот вызвать нужную. Вот, ну, можно скинуть там, там есть достаточно глубокий ответ на stack
[55:37.840 --> 55:43.800]  overflow, что там происходит. Ну, в общем, там вызывается, ему нужно вызвать еще деструкторы
[55:43.800 --> 55:48.000]  соответствующих под объектов, я не напоминаю, потому что это у меня тривиальные деструкторы у под
[55:48.000 --> 55:57.120]  объектов. Вообще-то у сына мог быть свой деструктор, у папы, у мамы, у бабушки. Оператору delete нужно,
[55:57.120 --> 56:04.200]  прежде чем освобождать память, вызвать деструкторы всех под объектов в правильном порядке. И вот он из
[56:04.200 --> 56:10.960]  таблицы виртуальных функций должен подчеркнуть информацию о том, в каком порядке вызвать деструкторы
[56:10.960 --> 56:17.360]  и по каким адресам каждый из деструкторов вызвать. И вот это все должно быть тоже записано в таблице
[56:17.360 --> 56:26.920]  виртуальных функций, там в определенном формате. Ну, там висит адрес, скажем так, там висит адрес,
[56:26.920 --> 56:33.640]  по которому вызывать деструктор в случае чего. И этот уже деструктор, в свою очередь, по этому адресу
[56:33.640 --> 56:38.800]  написан код, который в правильном порядке все уничтожает, в том числе поля, деструкторы под
[56:38.800 --> 56:43.920]  объектов и так далее. Но если нет виртуального деструктора, то это просто УБ, и так не будет работать.
[56:43.920 --> 57:09.480]  Вот. Да. Ну. Зачем тебе вызывать деструктор строки, если строка сейчас со стека снимется,
[57:09.480 --> 57:16.440]  ты хотел это спросить? Ну как тебе сказать? Деструктор строки сам содержит в отделе освобождения
[57:16.440 --> 57:39.400]  некоторой динамической памяти. Да. Кажется, Илья просто говорил, что нужно писать всегда виртуальные деструкторы.
[57:39.400 --> 57:56.360]  Кажется, мы раньше не делали такого со сдвигом указателя. Кажется, что вот конкретно такое пример
[57:56.360 --> 58:03.240]  у нас раньше не разбирался, потому что мы никогда не делали new, а потом delete по сдвинутому указателю.
[58:03.240 --> 58:10.920]  Это выглядит как какая-то ситуация, которая ужасно распространена, и это какое-то очень неочевидное
[58:10.920 --> 58:15.960]  угло. То есть это не какая-то там высосанная из пальцев ситуация, это, кажется, ситуация, в которой вы можете
[58:15.960 --> 58:23.240]  написать вообще, кто угор, надо выяснить. Ну окей, да. Значит, возможно, я забыл сказать или что-то, не знаю.
[58:23.240 --> 58:41.720]  Просто если вы делаете delete по pointer не того типа, по которому делали new, то делайте деструктор виртуальным.
[58:41.720 --> 58:44.360]  Тогда все будет хорошо.
[58:44.360 --> 59:07.640]  Ну если вы собираетесь когда-либо в своем коде допускать, что будет делаться delete по pointer не того типа,
[59:07.800 --> 59:12.280]  что был при выделении, то делайте деструктор виртуальным. Вот что из этого следует.
[59:12.280 --> 59:23.640]  Ну если вы не делаете new delete с этими pointer, то кажется...
[59:23.640 --> 59:35.800]  Да нет, написать new в нормальном коде так не делают.
[59:36.440 --> 59:37.960]  Ну как редко делают.
[59:37.960 --> 59:43.000]  New это не очень часто используемая штука, это довольно низкоуровневая штука.
[59:43.000 --> 59:46.520]  Ну давайте потише вы там, вы что-то очень громко.
[59:46.520 --> 59:55.800]  Ну если он виртуальный у бабушки, то все остальные у него унаследуют и станут полиморфными.
[59:55.800 --> 01:00:04.720]  Да. Так, все. Это предпоследняя штука, которую я хочу сказать про оператор new,
[01:00:04.720 --> 01:00:16.320]  теперь последняя штука. Если мы переоперим для бабушки, но не для мамы и для папы.
[01:00:16.320 --> 01:00:26.160]  Нет, я думаю что он не вызовется, будет стандартный вызываться, потому что мы выделяем new не для того типа.
[01:00:26.800 --> 01:00:33.600]  Так, ну мы же другой тип выделяем, нам другой размер надо выделить, например.
[01:00:33.600 --> 01:00:50.320]  Так, последний вопрос. Задача. Задача на отл. Однажды мне такой вопрос задали...
[01:00:50.320 --> 01:01:04.720]  В общем, мне лично такой вопрос на собеседовании не задавали, но я знаю, что однажды такой вопрос был на собеседовании, не помню куда.
[01:01:04.720 --> 01:01:14.960]  Может быть, кстати, в Касперск, не помню. Как запретить создавать некоторый объект на куче?
[01:01:15.600 --> 01:01:23.920]  Сначала вопрос простой. У вас есть некоторые типы. Вы хотите, чтобы объект этого типа нельзя было создавать на стеке?
[01:01:23.920 --> 01:01:35.200]  Как это сделать? Как запретить? Попытка создать этот объект на стеке должна приводить к CE. Как сделать такое?
[01:01:35.440 --> 01:01:51.440]  Кажется, можно сделать delete у оператора new публичный и приватный конструктор.
[01:01:51.440 --> 01:01:58.640]  Можно проще сделать приватный конструктор. Ну или приватные конструкторы.
[01:01:59.080 --> 01:02:03.080]  Можно сделать приватный деструктор. Конструкторов может быть много, а они публичные.
[01:02:03.080 --> 01:02:07.080]  Можно сделать приватный деструктор. Это автоматически запретит создавать объект на стеке.
[01:02:07.080 --> 01:02:11.080]  Прикол в том, что при создании на стеке прописывается явный его вызов?
[01:02:11.080 --> 01:02:21.080]  Да, и при создании на стеке просто не дадут создать, если деструктор приватный.
[01:02:21.520 --> 01:02:24.520]  В то же время на куче вы можете этот объект научиться создавать.
[01:02:24.520 --> 01:02:32.520]  Если там new и delete. Допустим, вам деструктор можно будет вызывать только из определенных мест.
[01:02:32.520 --> 01:02:34.520]  И конструкторы только из определенных мест.
[01:02:34.520 --> 01:02:40.520]  И тогда вы сможете определенным манипуляциям с приватностью добиться того,
[01:02:40.520 --> 01:02:42.520]  что на куче этот объект у вас создать получится.
[01:02:42.520 --> 01:02:44.520]  Через оператор new.
[01:02:44.520 --> 01:02:46.520]  В динамической памяти?
[01:02:46.520 --> 01:02:48.520]  Да, в динамической памяти.
[01:02:48.960 --> 01:02:50.960]  А какие это должны быть?
[01:02:50.960 --> 01:02:58.960]  Ну, сделать там какую-то функцию random и из нее вызывать деструктор.
[01:02:58.960 --> 01:03:07.960]  То есть деструктор вам придется вызывать явно из какой-нибудь функции, которая ваш друг.
[01:03:07.960 --> 01:03:11.960]  Я же не могу сделать себя другом изнутри.
[01:03:11.960 --> 01:03:13.960]  Ой, осторожно.
[01:03:13.960 --> 01:03:15.960]  Классно.
[01:03:18.960 --> 01:03:20.960]  А ...
[01:03:28.960 --> 01:03:31.960]  А, сейчас.
[01:03:40.960 --> 01:03:43.960]  А, может я тебя как раз перепутал?
[01:03:43.960 --> 01:03:45.960]  И вопрос-то в другом.
[01:03:45.960 --> 01:03:50.880]  что на куче запретить легко, а на стеке… короче, два
[01:03:50.880 --> 01:03:51.880]  вопроса.
[01:03:51.880 --> 01:03:53.760]  Как запретить создать объект на куче и только на стеке
[01:03:53.760 --> 01:03:54.760]  разрешить?
[01:03:54.760 --> 01:03:56.120]  И как запретить создать объект на стеке и только
[01:03:56.120 --> 01:03:57.120]  на куче разрешать?
[01:03:57.120 --> 01:03:58.120]  Вот.
[01:03:58.120 --> 01:04:03.420]  А, ну да, чтобы запретить создавать на куче можно
[01:04:03.420 --> 01:04:08.760]  просто сделать, например, оператор new… да, я вас обманул.
[01:04:08.760 --> 01:04:10.560]  На самом деле запретить на куче создать как раз
[01:04:10.560 --> 01:04:12.360]  просто, а на стеке не так просто.
[01:04:12.360 --> 01:04:14.560]  Вот, чтобы запретить создавать объект на куче мы просто
[01:04:14.560 --> 01:04:17.000]  оператор new для данного типа переопределяем так,
[01:04:17.000 --> 01:04:20.800]  чтобы он, ну не знаю, равно delete, например, да, делаем
[01:04:20.800 --> 01:04:22.440]  или бросал исключение.
[01:04:22.440 --> 01:04:25.800]  Ну, короче, попытка сделать new от этого типа приводила
[01:04:25.800 --> 01:04:26.800]  бы к ошибке.
[01:04:26.800 --> 01:04:27.800]  Вот.
[01:04:27.800 --> 01:04:29.840]  Запретить создавать на куче понятно как.
[01:04:29.840 --> 01:04:32.040]  Как запретить создавать на стеке?
[01:04:32.040 --> 01:04:37.400]  Нам надо, чтобы вызов деструктора делался в какой-то функции,
[01:04:37.400 --> 01:04:40.200]  когда мы удаляем объект, которое бы… единственное
[01:04:40.200 --> 01:04:42.160]  было можно делать вызов деструктора, а всем остальным
[01:04:42.160 --> 01:04:43.160]  нельзя.
[01:04:43.160 --> 01:04:47.560]  Вот, до C++20 не существовала способа, но начиная с C++20
[01:04:47.560 --> 01:04:50.880]  появился так называемый destroying оператор delete.
[01:04:54.880 --> 01:04:57.040]  Что такое destroying оператор delete?
[01:04:57.040 --> 01:05:02.360]  Это такой специфический оператор delete, который,
[01:05:02.360 --> 01:05:06.080]  если определен, то компилятор при вызове delete expression не
[01:05:06.080 --> 01:05:08.960]  вызывает деструктор сам, не пытается, а дает это
[01:05:08.960 --> 01:05:10.640]  на откуп вот этому оператору.
[01:05:10.640 --> 01:05:11.640]  Вот, смотрите, тут написано.
[01:05:12.120 --> 01:05:16.240]  If defined delete expression does not execute a destructor before placing
[01:05:16.240 --> 01:05:18.280]  the called operator delete.
[01:05:18.280 --> 01:05:22.520]  Если вы определили такую функцию, то тогда вызов выражения
[01:05:22.520 --> 01:05:25.560]  delete от вашего поинтера не будет автоматически
[01:05:25.560 --> 01:05:28.360]  приводить к вызову деструктора, и вы сами в этой функции
[01:05:28.360 --> 01:05:30.040]  должны вызывать деструктор.
[01:05:30.040 --> 01:05:32.200]  Это только начиная с C++20.
[01:05:32.200 --> 01:05:35.880]  Вот, эта функция, определение этой функции позволяет
[01:05:35.880 --> 01:05:37.960]  вам запретить создавать объекты на стеке и разрешить
[01:05:37.960 --> 01:05:38.960]  только на куче.
[01:05:39.960 --> 01:05:42.960]  Сейчас, это СЕ будет?
[01:05:42.960 --> 01:05:43.960]  Чего?
[01:05:43.960 --> 01:05:44.960]  Это СЕ будет?
[01:05:44.960 --> 01:05:46.960]  Что такое СЕ?
[01:05:46.960 --> 01:05:47.960]  Software engineer?
[01:05:47.960 --> 01:05:49.960]  Не представляешь, это CЕ.
[01:05:49.960 --> 01:05:51.960]  Это CЕ скорее.
[01:05:51.960 --> 01:05:54.960]  Ну да, это будет CЕ, конечно.
[01:05:54.960 --> 01:05:57.960]  Как именно мы запрещаем?
[01:05:57.960 --> 01:06:02.960]  Вы делаете приватный деструктор, а эта функция является членом
[01:06:02.960 --> 01:06:05.960]  вашего класса, и из нее деструктор вызывать можно.
[01:06:05.960 --> 01:06:07.960]  Это приведет к тому, что на стеке объекты вашего класса
[01:06:07.960 --> 01:06:08.960]  создавать нельзя.
[01:06:08.960 --> 01:06:09.960]  Это будет CЕ.
[01:06:09.960 --> 01:06:13.960]  Но при этом с помощью пары операторов NewDelete можно.
[01:06:13.960 --> 01:06:16.960]  И вот из этой функции оператор Delete вы сможете вызывать
[01:06:16.960 --> 01:06:17.960]  деструктор.
[01:06:17.960 --> 01:06:19.960]  Понятно?
[01:06:19.960 --> 01:06:22.960]  Вот такая вот, такой лайфхак.
[01:06:22.960 --> 01:06:25.960]  Подожди, а предыдущий лайфхак не работал?
[01:06:25.960 --> 01:06:26.960]  Да, предыдущий лайфхак...
[01:06:26.960 --> 01:06:28.960]  Ну, я перепутал просто.
[01:06:28.960 --> 01:06:33.960]  Что-то одно из этого можно было и раньше делать просто.
[01:06:33.960 --> 01:06:35.960]  Ну вот запретить создавать объекты на куче можно было
[01:06:35.960 --> 01:06:38.960]  просто, просто оператор New для данного t написать равно
[01:06:38.960 --> 01:06:39.960]  Delete, например.
[01:06:39.960 --> 01:06:40.960]  Вот.
[01:06:40.960 --> 01:06:42.960]  А это легко как раз.
[01:06:42.960 --> 01:06:44.960]  А вот запретить создать объекты на стеке, да, это
[01:06:44.960 --> 01:06:45.960]  не так легко как раз.
[01:06:45.960 --> 01:06:46.960]  Это я перепутал.
[01:06:46.960 --> 01:06:49.960]  И вот это стало можно все плюс плюс 20.
[01:06:49.960 --> 01:06:52.960]  То есть вот это мы в паплике определяем с деструком
[01:06:52.960 --> 01:06:55.960]  Delete, а без деструка Delete вправить, да?
[01:06:55.960 --> 01:06:57.960]  Чего без деструка Delete вправить?
[01:06:57.960 --> 01:07:01.960]  Мы оператор Delete делаем членом класса, в котором вызываем
[01:07:01.960 --> 01:07:03.960]  деструктор, а сам деструктор, приватный.
[01:07:03.960 --> 01:07:05.960]  Мы можем деструктор удалить?
[01:07:05.960 --> 01:07:06.960]  А, нет.
[01:07:06.960 --> 01:07:09.960]  Ну можем, но тогда мы вообще никак не сможем объект
[01:07:09.960 --> 01:07:10.960]  создавать.
[01:07:10.960 --> 01:07:12.960]  Не, ну сможем через оператор New, но корректно мы его
[01:07:12.960 --> 01:07:13.960]  создавать не сможем.
[01:07:13.960 --> 01:07:15.960]  Удалить деструктор, а потом он написать...
[01:07:15.960 --> 01:07:17.960]  Что значит удалить?
[01:07:17.960 --> 01:07:18.960]  Написать равно Delete?
[01:07:18.960 --> 01:07:19.960]  Да.
[01:07:19.960 --> 01:07:21.960]  Тогда мы корректно с этим объектом вообще не сможем
[01:07:21.960 --> 01:07:22.960]  работать.
[01:07:22.960 --> 01:07:24.960]  А мы потом вот этот, который деструем Delete.
[01:07:24.960 --> 01:07:27.960]  Так он удален, деструктор, нельзя вызывать деструктор
[01:07:27.960 --> 01:07:29.960]  ниоткуда, если он равно Delete.
[01:07:29.960 --> 01:07:31.960]  Нет, Илья.
[01:07:31.960 --> 01:07:37.960]  Равно Delete и оператор Delete это разное значение слова
[01:07:37.960 --> 01:07:39.960]  Delete, никак не связанное друг с другом.
[01:07:39.960 --> 01:07:43.960]  Илья, а если деструктор сделать приватным?
[01:07:43.960 --> 01:07:44.960]  Да.
[01:07:44.960 --> 01:07:46.960]  Почему это слово не работает?
[01:07:46.960 --> 01:07:49.960]  Ну, ты сделал деструктор приватным, но как на куче
[01:07:49.960 --> 01:07:50.960]  теперь тебе объект создавать?
[01:07:50.960 --> 01:07:53.960]  Ты сделал New, а Delete как делать?
[01:07:53.960 --> 01:07:56.960]  Просто при попытке сделать Delete по TR, просто стандартным
[01:07:56.960 --> 01:07:59.960]  способом, компилятор автоматически попытается вызвать деструктор
[01:07:59.960 --> 01:08:01.960]  и не сможет, потому что он приватный.
[01:08:01.960 --> 01:08:06.960]  Нет, а если я какую-то оберточную функцию напишу,
[01:08:06.960 --> 01:08:09.960]  которая, какой-нибудь оберточный метод, который, у которого
[01:08:09.960 --> 01:08:11.960]  есть уже доступ к этому Delete?
[01:08:11.960 --> 01:08:12.960]  Что такое оберточный метод?
[01:08:12.960 --> 01:08:14.960]  Ну, то есть тебе освобождать...
[01:08:14.960 --> 01:08:16.960]  У оператора Delete сделать его random.
[01:08:16.960 --> 01:08:19.960]  Ну, то есть тебе надо будет всякое удаление этого
[01:08:19.960 --> 01:08:21.960]  объекта делать через какой-то оберточный метод, который
[01:08:21.960 --> 01:08:23.960]  сделать random исходного класса.
[01:08:23.960 --> 01:08:25.960]  Ну да, так по идее сработает.
[01:08:25.960 --> 01:08:27.960]  Ну да, да.
[01:08:27.960 --> 01:08:34.960]  Но это кривой метод, кривой способ, потому что нормальным
[01:08:34.960 --> 01:08:38.960]  образом, ну как, ты сможешь его создавать на куче, но
[01:08:38.960 --> 01:08:40.960]  тебе придется это делать как-то нестандартно через
[01:08:40.960 --> 01:08:43.960]  какие-то непонятные заклинания, а вот с этим способом
[01:08:43.960 --> 01:08:44.960]  ты можешь это делать стандартно.
[01:08:44.960 --> 01:08:47.960]  New, Delete, пара New, Delete, как будто для пользователей
[01:08:47.960 --> 01:08:51.960]  это выглядит, он пишет обычный код New, Delete, а внутри это
[01:08:51.960 --> 01:08:53.960]  работает вот так, что просто он попадает в эту функцию
[01:08:53.960 --> 01:08:55.960]  и она вызывает деструктор.
[01:08:55.960 --> 01:08:57.960]  А, еще раз, извините.
[01:08:57.960 --> 01:09:00.960]  А в Delete, ну в этом Delete, что мы делаем?
[01:09:00.960 --> 01:09:02.960]  Как мы в итоге дойдем до деструктора?
[01:09:02.960 --> 01:09:05.960]  Ptr, стрелочка, тильда, t, вызов деструктора.
[01:09:05.960 --> 01:09:06.960]  Уже в Delete.
[01:09:06.960 --> 01:09:09.960]  В функции DestroyingDelete, вот в этой.
[01:09:09.960 --> 01:09:14.960]  Типа, а еще что делает DestroyingDelete, t?
[01:09:14.960 --> 01:09:18.960]  DestroyingDelete, t это тег, говорящий о том, что это версия оператора
[01:09:18.960 --> 01:09:21.960]  Delete с такими параметрами.
[01:09:21.960 --> 01:09:26.960]  Почему мы в куче можем, а в стеке не можем?
[01:09:26.960 --> 01:09:29.960]  Очевидно почему.
[01:09:29.960 --> 01:09:31.960]  Может Delete мы в стеке не вызываем, да?
[01:09:31.960 --> 01:09:36.960]  Потому что деструктор приватный, попытка создать объект
[01:09:36.960 --> 01:09:39.960]  с приватным деструктором в стеке будет давать ce.
[01:09:39.960 --> 01:09:41.960]  У нас Delete не статический?
[01:09:41.960 --> 01:09:42.960]  Статический.
[01:09:42.960 --> 01:09:45.960]  Оператор Delete всегда статический, даже если статик не написано.
[01:09:45.960 --> 01:09:50.960]  Откуда он берет объект, который не может быть статичным?
[01:09:50.960 --> 01:09:52.960]  Передается параметром ptr.
[01:09:52.960 --> 01:09:56.960]  У нас же изначально должен вызваться деструктор, а потом уже оператор Delete.
[01:09:56.960 --> 01:09:58.960]  Да.
[01:09:58.960 --> 01:10:02.960]  Но в случае DestroyingDelete это работает не так, и для этого
[01:10:02.960 --> 01:10:05.960]  специально прописано исключение из правил, начиная с C++20.
[01:10:05.960 --> 01:10:09.960]  DestroyingDelete берет на себя ответственность из-за вызов деструктора
[01:10:09.960 --> 01:10:12.960]  в том числе, как раз для того, чтобы решить вот эту описанную проблему.
[01:10:20.960 --> 01:10:22.960]  Сейчас мы пишем оператора NewDelete.
[01:10:22.960 --> 01:10:25.960]  Он ни разу не вызовет стандарты NewDelete?
[01:10:25.960 --> 01:10:29.960]  Слушайте, давайте, пожалуйста, мы дальше пойдем.
[01:10:29.960 --> 01:10:33.960]  Сейчас, когда у нас будет перерыв между парами, вы мне все вопросы зададите.
[01:10:33.960 --> 01:10:35.960]  Просто нам надо еще два пункта обсудить.
[01:10:35.960 --> 01:10:40.960]  Я надеюсь, что мы сейчас минут за 40 их обсудим.
[01:10:40.960 --> 01:10:42.960]  Давайте пойдем дальше.
[01:10:42.960 --> 01:10:46.960]  Я закончил про перегрузку операторов NewDelete.
[01:10:51.960 --> 01:10:53.960]  Да.
[01:10:53.960 --> 01:10:58.960]  Следующий пункт называется Alignment.
[01:10:58.960 --> 01:11:00.960]  Выравнивание.
[01:11:06.960 --> 01:11:08.960]  9.5.
[01:11:08.960 --> 01:11:13.960]  Ну, если точнее, Alignments and bit fields.
[01:11:13.960 --> 01:11:15.960]  Это короткий пункт.
[01:11:15.960 --> 01:11:20.960]  Мы про него, я думаю, за 15 минут справимся поговорить.
[01:11:23.960 --> 01:11:24.960]  Что такое выравнивание?
[01:11:24.960 --> 01:11:27.960]  В принципе, мы уже знаем из первого семестра.
[01:11:31.960 --> 01:11:34.960]  Да, значит, у нас объекты должны лежать по адресам кратным...
[01:11:34.960 --> 01:11:40.960]  Ну, не обязательно размеру, кратным размеру наибольшего примитивного типа,
[01:11:40.960 --> 01:11:42.960]  как поле, входящего в них.
[01:11:42.960 --> 01:11:46.960]  Ну, короче, у нас есть варианты, что инты должны лежать по адресу кратному
[01:11:46.960 --> 01:11:49.960]  size of int, double по адресу кратному size of double.
[01:11:49.960 --> 01:11:52.960]  А если объект состоит из многих других подобъектов,
[01:11:52.960 --> 01:11:59.960]  то они разбиваются на составляющие, и все приводится к тому,
[01:11:59.960 --> 01:12:04.960]  что они должны лежать тоже по адресам кратным своим размерам.
[01:12:06.960 --> 01:12:11.960]  Все сводится к тому, что числа на примитивном уровне,
[01:12:11.960 --> 01:12:16.960]  числа инты и даблы должны лежать по адресам всегда кратным своему размеру.
[01:12:16.960 --> 01:12:17.960]  И поинтеры.
[01:12:17.960 --> 01:12:18.960]  Почему так?
[01:12:18.960 --> 01:12:19.960]  Напоминаю.
[01:12:19.960 --> 01:12:22.960]  Потому что так устроен процессор.
[01:12:23.960 --> 01:12:27.960]  Потому что процессор читает не по одному байту.
[01:12:27.960 --> 01:12:30.960]  Потому что процессор, когда читает число, 4-байтное,
[01:12:30.960 --> 01:12:33.960]  он его читает одной инструкцией.
[01:12:33.960 --> 01:12:35.960]  Машинное слово, допустим, он читает.
[01:12:35.960 --> 01:12:37.960]  Или два машинных слова.
[01:12:37.960 --> 01:12:43.960]  И если у вас будет в памяти лежать число не по адресу кратному 4,
[01:12:43.960 --> 01:12:46.960]  то процессору, чтобы прочитать это число, потребуется
[01:12:46.960 --> 01:12:51.960]  либо две инструкции потом как-то хитрое это число из битов составлять,
[01:12:51.960 --> 01:12:55.960]  либо это будет вообще runtime error.
[01:12:57.960 --> 01:13:01.960]  На самом деле, насколько мне известно,
[01:13:01.960 --> 01:13:05.960]  интеловский процессор нормально справляется с невыровненными числами.
[01:13:05.960 --> 01:13:08.960]  Это просто дольше работает.
[01:13:08.960 --> 01:13:13.960]  Если число лежит невыровненное по адресу кратному нужному,
[01:13:13.960 --> 01:13:16.960]  то интеловский процессор, он его прочитает,
[01:13:16.960 --> 01:13:19.960]  но для этого ему придется больше шагов сделать.
[01:13:19.960 --> 01:13:22.960]  Ему придется прочитать этот кусок, этот кусок,
[01:13:22.960 --> 01:13:25.960]  склеить число из двух кусков и начать с ним работать.
[01:13:25.960 --> 01:13:30.960]  А вот AMD процессоры, кажется, могут и упасть вообще.
[01:13:31.960 --> 01:13:37.960]  Если попросить AMD процессор считать целое число с адреса не кратного 4,
[01:13:37.960 --> 01:13:40.960]  то он просто упадет с R&E.
[01:13:40.960 --> 01:13:44.960]  Ну там сгенерирует ошибку на низком уровне и все повалится.
[01:13:44.960 --> 01:13:49.960]  Кажется, что даже где-то у нас на работе
[01:13:49.960 --> 01:13:52.960]  однажды такой случай был из-за неправильного выравнивания.
[01:13:52.960 --> 01:13:57.960]  Так вот, короче, неправильное выравнивание чисел – это УБ.
[01:13:57.960 --> 01:14:01.960]  Потому что как минимум некоторые процессоры могут просто сломаться
[01:14:01.960 --> 01:14:04.960]  и не суметь прочитать число по некратному адресу.
[01:14:04.960 --> 01:14:09.960]  Вопрос, а как же мы тогда вообще существовали до этого?
[01:14:09.960 --> 01:14:13.960]  У нас УБ все это время было, мы же писали вектор,
[01:14:13.960 --> 01:14:19.960]  и в векторе мы тут делали вот это вот allocate,
[01:14:19.960 --> 01:14:23.960]  которое в свою очередь делало new char.
[01:14:23.960 --> 01:14:27.960]  Но чары не обладают никаким выравниванием.
[01:14:27.960 --> 01:14:31.960]  Чары они на любой байт могут класситься.
[01:14:31.960 --> 01:14:37.960]  Когда мы в векторе делали выделение памяти под несколько штук Т,
[01:14:37.960 --> 01:14:43.960]  мы на самом деле выделяли чары,
[01:14:43.960 --> 01:14:46.960]  а потом кастовали их в интерпрет кастом к Т звездочке.
[01:14:46.960 --> 01:14:49.960]  То есть это что получается, если бы мы вектор W
[01:14:49.960 --> 01:14:51.960]  таким образом создавали или вектор N.
[01:14:51.960 --> 01:14:57.960]  У нас УБ, если вдруг мы new char не по адресу кратному 4 положили.
[01:14:57.960 --> 01:15:03.960]  На самом деле нет. На самом деле все здесь хорошо.
[01:15:03.960 --> 01:15:07.960]  УБ здесь нету, потому что оператор new умный.
[01:15:07.960 --> 01:15:10.960]  Он застрахован от дураков, которые ничего не знают про выравнивание.
[01:15:10.960 --> 01:15:14.960]  Оператор new, чтобы вы не выделяли,
[01:15:14.960 --> 01:15:18.960]  он вернет вам адрес кратный 16 вообще.
[01:15:18.960 --> 01:15:20.960]  Можете проверить.
[01:15:20.960 --> 01:15:27.960]  На самом деле не кратный 16, а кратный так называемой штуке max align.
[01:15:45.960 --> 01:15:50.960]  Max align T это такой тип в стандартной библиотеке,
[01:15:50.960 --> 01:15:54.960]  который обладает наибольшим требованием к выравниванию из всех стандартных типов.
[01:15:54.960 --> 01:15:58.960]  И он определен компилятором за вас.
[01:15:58.960 --> 01:16:02.960]  И когда вы вызываете оператор new от чего-то,
[01:16:02.960 --> 01:16:09.960]  он по умолчанию выравнивает возвращаемый вам указатель так, как если бы вы выделяли max align T.
[01:16:09.960 --> 01:16:14.960]  Понятно, что такое max align T?
[01:16:14.960 --> 01:16:27.960]  Ну, на уровне языка статусов нет.
[01:16:27.960 --> 01:16:30.960]  Вы в оператор new получаете один байт.
[01:16:30.960 --> 01:16:33.960]  Вот здесь, где мы тут писали, вот здесь.
[01:16:33.960 --> 01:16:36.960]  Вы получаете один байт.
[01:16:36.960 --> 01:16:41.960]  Но этот один байт, когда вы запрашиваете...
[01:16:41.960 --> 01:16:43.960]  Давайте разберем по частям.
[01:16:43.960 --> 01:16:46.960]  Вот я в оператор new прихожу, мне говорят, допустим, выдели один байт.
[01:16:46.960 --> 01:16:49.960]  Я обращаюсь к функции malloc.
[01:16:49.960 --> 01:16:51.960]  А как функция malloc себя ведет?
[01:16:51.960 --> 01:16:55.960]  А также функция malloc тоже все выравнивает по max align T.
[01:16:55.960 --> 01:16:59.960]  То есть всякий раз, когда вы имеете дело с динамической памятью,
[01:16:59.960 --> 01:17:05.960]  когда вы делаете new, malloc, то, что они возвращают, выровненного по max align T.
[01:17:05.960 --> 01:17:07.960]  Когда вы просите malloc выделить один байт,
[01:17:07.960 --> 01:17:09.960]  на самом деле она, конечно, выделяет...
[01:17:09.960 --> 01:17:12.960]  Я не знаю, там очень сложно все это устроено.
[01:17:12.960 --> 01:17:15.960]  Она какую-то свою внутреннюю логику поддерживает.
[01:17:15.960 --> 01:17:18.960]  Она, по факту, может выделить больше, чем один байт.
[01:17:18.960 --> 01:17:20.960]  Но вы будете уверены, что вам дан один байт,
[01:17:20.960 --> 01:17:24.960]  и дан он вам по адресу, кратному size of max align T.
[01:17:24.960 --> 01:17:27.960]  Ну, один байт по max align T, это, конечно, сильно.
[01:17:27.960 --> 01:17:28.960]  Расточительно, да.
[01:17:28.960 --> 01:17:30.960]  Но, тем не менее, вот такое требование...
[01:17:30.960 --> 01:17:32.960]  Не, это мало того, что это глупо,
[01:17:32.960 --> 01:17:36.960]  потому что у нас в один байт не может поместиться тип,
[01:17:36.960 --> 01:17:39.960]  который требует кратности больше, чем один байт.
[01:17:39.960 --> 01:17:44.960]  Ну, я не знаю, глупо, неглупо, тем не менее, формально требования такие.
[01:17:44.960 --> 01:17:47.960]  Как устроен malloc я сейчас не готов обсуждать.
[01:17:47.960 --> 01:17:50.960]  Это вам, скорее всего, расскажут на втором курсе уже.
[01:17:50.960 --> 01:17:54.960]  Malloc устроен очень сложно, там реализация занимает сотни строк.
[01:17:54.960 --> 01:17:55.960]  Как называется параграф еще?
[01:17:55.960 --> 01:17:58.960]  Параграф называется alignment and bit fields.
[01:17:58.960 --> 01:17:59.960]  Параграф 9.5.
[01:18:00.960 --> 01:18:02.960]  Выравнивание и битовые поля.
[01:18:03.960 --> 01:18:04.960]  Вот.
[01:18:05.960 --> 01:18:08.960]  Почему вдруг мы начали об этом говорить именно сейчас?
[01:18:08.960 --> 01:18:11.960]  Да потому что как раз, когда вы будете писать свою задачу про stack allocator,
[01:18:11.960 --> 01:18:13.960]  у вас возникнет эта проблема.
[01:18:13.960 --> 01:18:17.960]  Покуда вы в allocator'е вызываете функцию locate,
[01:18:17.960 --> 01:18:19.960]  оператор new, все хорошо.
[01:18:19.960 --> 01:18:22.960]  Но если вы заведете stack allocator,
[01:18:23.960 --> 01:18:27.960]  то есть массив на стеке, вот вы заведете массив чаров на стеке
[01:18:27.960 --> 01:18:30.960]  и сделаете stack allocator на этом массиве.
[01:18:30.960 --> 01:18:34.960]  Когда вы заводите массив чаров на стеке, там уже никакого выравнивания не гарантируется.
[01:18:36.960 --> 01:18:40.960]  И если вы начнете на этом stack allocator'е выделять разные типы,
[01:18:40.960 --> 01:18:43.960]  например, выдели два чара, а потом int решили выделить.
[01:18:43.960 --> 01:18:46.960]  Если вы будете подряд так выделять этим stack allocator на стеке,
[01:18:46.960 --> 01:18:50.960]  у вас возникнет беда, у вас int ляжет на адрес не кратный 4.
[01:18:51.960 --> 01:18:55.960]  Если вы тупо будете писать stack allocator, не думая о выравнивании,
[01:18:55.960 --> 01:18:57.960]  то вы схватите UB.
[01:18:57.960 --> 01:19:03.960]  Поэтому, когда вы делаете allocator на стеке не с помощью оператора new,
[01:19:03.960 --> 01:19:05.960]  а вручную распоряжаясь памятью,
[01:19:05.960 --> 01:19:07.960]  сырым куском памяти чаров,
[01:19:07.960 --> 01:19:10.960]  вам нужно думать о выравнивании.
[01:19:10.960 --> 01:19:15.960]  Да и когда вы на куче делаете allocator, в принципе, у вас тоже могла быть проблема,
[01:19:15.960 --> 01:19:19.960]  если вы на одном allocator'е выделили сначала 3 int, а потом решили double выделить.
[01:19:19.960 --> 01:19:23.960]  Если вы так подряд будете выделять, то у вас double ляжет на адрес не кратный 8.
[01:19:23.960 --> 01:19:27.960]  Покуда вы каждый раз к new заново обращаетесь, эта проблема от вас скрыта,
[01:19:27.960 --> 01:19:29.960]  оно само там решается.
[01:19:29.960 --> 01:19:31.960]  Но теперь вам нужно думать о выравнивании.
[01:19:31.960 --> 01:19:35.960]  И для этого вам пригодятся ключевые слова align of и align as.
[01:19:35.960 --> 01:19:38.960]  Давайте про них поговорим, значит.
[01:19:40.960 --> 01:19:43.960]  Align of, для начала.
[01:19:46.960 --> 01:19:48.960]  Есть такой оператор align of.
[01:19:50.960 --> 01:19:53.960]  Это как size of, только align of.
[01:19:53.960 --> 01:19:58.960]  Вы можете у произвольного объекта или у типа спросить,
[01:19:58.960 --> 01:20:01.960]  какое у него требование к выравниванию.
[01:20:01.960 --> 01:20:06.960]  Ну вот, например, вы можете спросить align of char, и вам скажут 1.
[01:20:06.960 --> 01:20:09.960]  Можете спросить align of int звездочка, вам скажут 8.
[01:20:09.960 --> 01:20:14.960]  Можете спросить align of любого типа, и вам скажут, какое у него требование к выравниванию.
[01:20:15.960 --> 01:20:16.960]  Ну вот.
[01:20:18.960 --> 01:20:22.960]  Ну вы можете, но это будет слишком расточительно как раз таки.
[01:20:22.960 --> 01:20:28.960]  Если у вас, ну, если вам нужно выделять чары, а потом int,
[01:20:28.960 --> 01:20:33.960]  то не стоит на max align t выравнивать, это слишком много.
[01:20:35.960 --> 01:20:36.960]  Вот.
[01:20:40.960 --> 01:20:42.960]  Это align as уже.
[01:20:42.960 --> 01:20:44.960]  Я пока говорю только про align of.
[01:20:44.960 --> 01:20:47.960]  Значит, align of это оператор, встроенный в язык, ключевое слово,
[01:20:47.960 --> 01:20:53.960]  которое возвращает выравнивание данного типа в байтах.
[01:20:54.960 --> 01:20:56.960]  Это ключевое слово.
[01:20:56.960 --> 01:20:59.960]  Кстати, появилось только начинается плюс 11.
[01:20:59.960 --> 01:21:01.960]  Как жили до этого, я не знаю.
[01:21:01.960 --> 01:21:03.960]  Ну, сишные функции использовали какие-то.
[01:21:03.960 --> 01:21:06.960]  И кроме этого еще ключевое слово align as.
[01:21:06.960 --> 01:21:12.960]  align as это такая вот конструкция, такой спецификатор,
[01:21:12.960 --> 01:21:16.960]  который можно писать после слова struct перед именем структуры,
[01:21:16.960 --> 01:21:18.960]  чтобы сказать, как она должна быть выровнена.
[01:21:23.960 --> 01:21:27.960]  Нет, вы можете, например, хотеть, чтобы структура была выровнена сильнее, чем,
[01:21:27.960 --> 01:21:29.960]  по идее, она должна быть выровнена.
[01:21:29.960 --> 01:21:31.960]  Например, у вас структура состоит из одного чара.
[01:21:31.960 --> 01:21:34.960]  Тогда она будет выровнена по одному байт, то есть никак не выровнена.
[01:21:34.960 --> 01:21:39.960]  А вы можете сказать struct align as 4, и она будет выровнена как будто ind.
[01:21:39.960 --> 01:21:41.960]  А меньше она не может, чем ее?
[01:21:41.960 --> 01:21:45.960]  Меньше, наверное, ob.
[01:21:45.960 --> 01:21:48.960]  Ну, вы можете, например, сказать struct align as 64.
[01:21:51.960 --> 01:21:54.960]  И это значит, она будет выровнена вообще по 64 байта.
[01:21:54.960 --> 01:21:55.960]  А в чем мотивация?
[01:21:55.960 --> 01:21:58.960]  Ну, мы хотим показатель позапихивать данные.
[01:21:58.960 --> 01:21:59.960]  Вот. Вопрос.
[01:21:59.960 --> 01:22:00.960]  Вопрос.
[01:22:00.960 --> 01:22:05.960]  А зачем, может быть, нужно выравнивать какие-то типы сильнее, чем по 16,
[01:22:05.960 --> 01:22:08.960]  по 32 или по 64, или даже по 128?
[01:22:16.960 --> 01:22:22.960]  Нет, казалось бы, если у вас есть align as 16, если у вас максимальный тип для выра...
[01:22:22.960 --> 01:22:26.960]  У вас все поля внутри структуры и так будут выровнены относительно друг друга.
[01:22:26.960 --> 01:22:32.960]  Если вы кладете int, потом char, потом int, то после чара перед следующим int будет 3 байта пэддинг.
[01:22:33.960 --> 01:22:38.960]  Зачем, казалось бы, нужно выравнивание больше, чем на 16 в такой ситуации?
[01:22:38.960 --> 01:22:42.960]  Зачем, может быть, нужно выравнивать структуры больше, чем по max align?
[01:22:43.960 --> 01:22:45.960]  Что же лучше разложилось?
[01:22:45.960 --> 01:22:50.960]  Оно и так, если у вас поля подряд лежат, там и так пэддинг будет между полями, чтобы все выравнивания соблюдались.
[01:22:50.960 --> 01:22:52.960]  Но вдруг еще один байтик и все, типа...
[01:22:53.960 --> 01:22:55.960]  Нет, не понимаю.
[01:22:55.960 --> 01:22:56.960]  Можно предположить?
[01:22:56.960 --> 01:22:57.960]  Давай.
[01:22:57.960 --> 01:23:03.960]  Ну пусть у нас есть структура, которую мы храним чаще всего какими-то большими блоками, то есть массивами.
[01:23:03.960 --> 01:23:07.960]  И мы хотим в нее булов понапихать, не выделяя дополнительной памяти.
[01:23:07.960 --> 01:23:11.960]  Ну вот мы в последние биты указателя просто эти булы засовываем,
[01:23:11.960 --> 01:23:15.960]  зная, что все эти структуры лежат по адресу кратном 64.
[01:23:15.960 --> 01:23:19.960]  Потому что у тебя тогда, когда ты эту структуру массивом размещаешь,
[01:23:19.960 --> 01:23:27.960]  например, у нее размер 16, она будет занимать 17 байки, если там еще бул отдельно хранить.
[01:23:27.960 --> 01:23:30.960]  И когда ты хранишь ее массивом, это плохо.
[01:23:30.960 --> 01:23:33.960]  Особенно с счетом кратности, как оно будет ложиться.
[01:23:33.960 --> 01:23:36.960]  Возможно, у тебя вообще байк 15 теряется.
[01:23:36.960 --> 01:23:39.960]  То есть если у нас int и честное количество байков,
[01:23:39.960 --> 01:23:43.960]  и мы можем платить в подряд по пять байков, а не четыре.
[01:23:43.960 --> 01:23:46.960]  То есть если у нас int и честное количество байков,
[01:23:46.960 --> 01:23:52.960]  и мы можем платить в подряд по пять байков, а не четыре.
[01:24:08.960 --> 01:24:10.960]  Значит, ответ вот какой.
[01:24:10.960 --> 01:24:15.960]  Иногда вам бывает нужно, но это уже выходит за рамки нашего курса,
[01:24:15.960 --> 01:24:18.960]  и это вам скорее всего опять-таки расскажут на втором курсе.
[01:24:18.960 --> 01:24:23.960]  Мы тут находимся на пороге низкоуровневого программирования.
[01:24:23.960 --> 01:24:30.960]  Иногда бывает нужно, ну так скажем, конвейерно обрабатывать данные.
[01:24:30.960 --> 01:24:35.960]  Бывают так называемые SSE инструкции у процессоров.
[01:24:35.960 --> 01:24:41.960]  Когда вы берете и читаете сразу большую длинную цепочку байт,
[01:24:41.960 --> 01:24:46.960]  например 32 байта за раз, и перемножаете сразу 32 битные числа.
[01:24:46.960 --> 01:24:50.960]  Вот некоторые процессоры умеют, ну большинство на самом деле,
[01:24:50.960 --> 01:24:57.960]  у интеловских, скажем, процессоров вы можете нагуглить векторные инструкции.
[01:24:57.960 --> 01:24:59.960]  Vector instructions.
[01:24:59.960 --> 01:25:01.960]  Это инструкции, которые позволяют вам сразу сказать,
[01:25:02.960 --> 01:25:06.960]  ну это ассемблерные уже инструкции, у них есть тишные обертки,
[01:25:06.960 --> 01:25:08.960]  но это выходит за рамки нашего курса.
[01:25:08.960 --> 01:25:12.960]  Вот, например, вам можно быстрее перемножать числа или матрицы длинные так.
[01:25:12.960 --> 01:25:16.960]  Вы берете и говорите, вот, кстати, господин Клич, в первом семестре именно так.
[01:25:16.960 --> 01:25:20.960]  Именно это делал в своей реализации матриц, в том числе в своих реализациях биг интеджеров,
[01:25:20.960 --> 01:25:22.960]  в том числе, там были векторные инструкции.
[01:25:22.960 --> 01:25:29.960]  Вы просто считываете сразу много и перемножаете как бы 32 битные числа.
[01:25:29.960 --> 01:25:30.960]  Вот.
[01:25:30.960 --> 01:25:32.960]  Некоторые процессоры умеют это делать эффективно.
[01:25:32.960 --> 01:25:33.960]  Вот.
[01:25:33.960 --> 01:25:36.960]  И тогда вам нужно, чтобы эти числа лежали выровненные по 32.
[01:25:36.960 --> 01:25:37.960]  Некоторые.
[01:25:37.960 --> 01:25:39.960]  Это сейчас поменяю на все.
[01:25:39.960 --> 01:25:40.960]  Ну, да.
[01:25:40.960 --> 01:25:42.960]  Ну, формально не могу утверждать какие.
[01:25:42.960 --> 01:25:43.960]  Ну, в общем.
[01:25:43.960 --> 01:25:47.960]  Это выходит за рамки курса по C++.
[01:25:47.960 --> 01:25:50.960]  И это даже выходит за рамки стандартной библиотеки.
[01:25:50.960 --> 01:25:55.960]  То есть это расширение специальное, которые специфические для конкретных процессоров.
[01:25:55.960 --> 01:26:02.960]  Можно на сайте интелла под ваш конкретный процессор найти, что там надо написать, чтобы оно так сработало.
[01:26:02.960 --> 01:26:06.960]  Это вам даст ускорение во много раз, может быть, если будете перемножать длинные числа.
[01:26:06.960 --> 01:26:10.960]  Но это скорее второй курс уже у вас будет.
[01:26:10.960 --> 01:26:17.960]  Есть ли какие-нибудь стандартные библиотеки плюсов?
[01:26:17.960 --> 01:26:22.960]  Ну, что-то типа.
[01:26:22.960 --> 01:26:25.960]  Короче, чтобы можно было в compile time.
[01:26:25.960 --> 01:26:28.960]  Если такое на процессоре доступно, то скомпилируйте.
[01:26:28.960 --> 01:26:35.960]  Что можно поставить аргументы в constexpr, чтобы скомпилировать в зависимости от того, доступные эти.
[01:26:35.960 --> 01:26:36.960]  Ну, вы можете вызвать.
[01:26:36.960 --> 01:26:37.960]  Нет.
[01:26:37.960 --> 01:26:38.960]  В стандартной библиотеке плюсов такого нет.
[01:26:38.960 --> 01:26:41.960]  Вы можете вызвать функцию, там, какую-нибудь вида.
[01:26:41.960 --> 01:26:48.960]  Если процессор сейчас у меня такой-то, ну, там, какая-нибудь низкоуровневая функция операционной системы,
[01:26:48.960 --> 01:26:52.960]  которая говорит вам, у вас там поддерживаются эти операции или нет.
[01:26:52.960 --> 01:26:54.960]  И если да, то начинать их вызывать.
[01:26:54.960 --> 01:26:55.960]  Что-то такое.
[01:26:55.960 --> 01:27:01.960]  И правильно делает, нефиг.
[01:27:01.960 --> 01:27:08.960]  Ты что-то странное придумал.
[01:27:08.960 --> 01:27:09.960]  Так.
[01:27:09.960 --> 01:27:15.960]  Так вот.
[01:27:15.960 --> 01:27:21.960]  Когда вы будете делать свой локатор, вам...
[01:27:21.960 --> 01:27:28.960]  Так, это что-то не то.
[01:27:28.960 --> 01:27:35.960]  Когда вы будете делать свой локатор, вам, вероятно, пригодится вот такая функция std align,
[01:27:35.960 --> 01:27:39.960]  которая берет поинтер и выравнивает его по
[01:27:39.960 --> 01:27:43.960]  нужному, ну, согласно нужному выравниванию.
[01:27:43.960 --> 01:27:48.960]  Вот даже здесь в качестве примера есть, когда это может пригодиться.
[01:27:48.960 --> 01:27:53.960]  Вот как раз, когда вы пишете свой локатор стековой памяти.
[01:27:53.960 --> 01:27:56.960]  Вот.
[01:27:56.960 --> 01:28:03.960]  В библиотеке Boost есть специальный локатор, aligned-локатор, по-моему,
[01:28:03.960 --> 01:28:07.960]  который как стд-локатор только с фиксированным выравниванием.
[01:28:07.960 --> 01:28:12.960]  Ну, вы можете сказать aligned-локатор от int 16, скажем.
[01:28:12.960 --> 01:28:15.960]  И он будет выделять int вам с выравниванием по 16, ну, например.
[01:28:15.960 --> 01:28:16.960]  Вот.
[01:28:16.960 --> 01:28:20.960]  Это легкое упражнение написать свой локатор, который ведет себя как стандартный, но
[01:28:20.960 --> 01:28:23.960]  кастомное выравнивание использует.
[01:28:23.960 --> 01:28:25.960]  Что еще раз делает align?
[01:28:25.960 --> 01:28:32.960]  align выравнивает, ну, берет поинтер, вот этот вот.
[01:28:32.960 --> 01:28:38.960]  И возвращает поинтер выровненный по, ну, округляет, короче, до
[01:28:38.960 --> 01:28:41.960]  ближайшего адреса кратного, чему надо.
[01:28:41.960 --> 01:28:52.960]  Округляет вверх и decreases space argument by the number of bytes used for alignment.
[01:28:52.960 --> 01:29:02.960]  Ну как, вас просят выделить int, а вы уже до этого, возможно, выделяли
[01:29:02.960 --> 01:29:03.960]  сколько-то чаров.
[01:29:03.960 --> 01:29:07.960]  Вы не можете так просто сказать следующий byte, возьми и верни, как будто я int выделил.
[01:29:07.960 --> 01:29:14.960]  Конечно, у вас есть свой блок, и вам нужно сделать, да, сделать align и вернуть
[01:29:14.960 --> 01:29:15.960]  только после этого.
[01:29:15.960 --> 01:29:16.960]  Вот.
[01:29:16.960 --> 01:29:20.960]  И есть еще одна функция полезная, тоже которую я вам покажу сейчас, называется
[01:29:20.960 --> 01:29:25.960]  align unlock, начиная с C++17.
[01:29:25.960 --> 01:29:32.960]  Эта штука, которая как mall lock, только с кастомным выравниванием.
[01:29:32.960 --> 01:29:36.960]  Вы можете, это вообще C-шная функция, вот.
[01:29:36.960 --> 01:29:41.960]  Если вы хотите уточнить, с каким выравниванием вы хотите вернуть вам указатель,
[01:29:41.960 --> 01:29:47.960]  то вы можете использовать не mall lock, а align unlock, чтобы определенное
[01:29:47.960 --> 01:29:56.960]  выравнивание было при этом указателе.
[01:29:56.960 --> 01:30:03.960]  Не уверен, правда, что она может делать меньшее выравнивание, чем max align t.
[01:30:03.960 --> 01:30:05.960]  Вот.
[01:30:05.960 --> 01:30:12.960]  Но больше, чем max align t, может быть, вам понадобится когда-нибудь в жизни.
[01:30:12.960 --> 01:30:15.960]  Ну и последняя штука – это битовые поля.
[01:30:15.960 --> 01:30:17.960]  Это вообще кринш.
[01:30:17.960 --> 01:30:23.960]  Значит, в C++ есть способ сказать, чтобы поле весило не байт, а несколько бит.
[01:30:27.960 --> 01:30:29.960]  Там как-то очень больно это пишется.
[01:30:29.960 --> 01:30:35.960]  Да, если вы такие, значит, экономные, что вам принципиально, чтобы ваше поле весило…
[01:30:35.960 --> 01:30:40.960]  Причем оно реально работает, только когда вы массив этого выделяете.
[01:30:40.960 --> 01:30:41.960]  Нет, почему?
[01:30:41.960 --> 01:30:42.960]  Вот так вот это работает.
[01:30:42.960 --> 01:30:47.960]  Ну, в смысле, потому что память под одну переменную все равно выделится кратно.
[01:30:47.960 --> 01:30:50.960]  Значит, смотрите, смотрите, вот то, что я сейчас написал.
[01:30:50.960 --> 01:30:51.960]  Я сейчас написал…
[01:30:51.960 --> 01:30:54.960]  Почему это не рассказывают на программе в школе?
[01:30:54.960 --> 01:30:56.960]  Не знаю.
[01:30:56.960 --> 01:30:58.960]  Школа такая, видимо, не ваще.
[01:30:58.960 --> 01:31:07.960]  Если я задам один тип, вот такой, и там скажу ему, выдели мне 5 бит, то он выделит мне 5, а 8.
[01:31:07.960 --> 01:31:11.960]  Правильно, потому что размер одной штуки должен быть кратен.
[01:31:11.960 --> 01:31:13.960]  Сайзов должен быть все равно целым числом байт.
[01:31:13.960 --> 01:31:21.960]  А вот нет, там точно можно было какие-то упоротые размеры типа 27 брайт, но они реально работают, только если мы массив.
[01:31:21.960 --> 01:31:23.960]  Вот этого я не знаю.
[01:31:23.960 --> 01:31:28.960]  Я просто точно знаю, что так можно делать, и это иногда помогает запихивать задачи.
[01:31:28.960 --> 01:31:30.960]  Вот этого я не знаю.
[01:31:30.960 --> 01:31:37.960]  Но я знаю, что можно в рамках одной структуры можно указать полям, весить меньше, чем байт.
[01:31:37.960 --> 01:31:41.960]  Это 4-х битовые поля сейчас.
[01:31:41.960 --> 01:31:45.960]  Сайзов этой штуки будет 1.
[01:31:45.960 --> 01:31:48.960]  Вот.
[01:31:48.960 --> 01:31:53.960]  По стандарту здесь может быть либо int, либо unsigned int.
[01:31:53.960 --> 01:31:55.960]  Да и все по-моему.
[01:31:55.960 --> 01:31:58.960]  Ну то есть здесь либо char, либо unsigned char.
[01:31:58.960 --> 01:32:00.960]  Ну короче, здесь ограниченное количество слов.
[01:32:00.960 --> 01:32:03.960]  Здесь должен быть название какого-то целочисленного типа.
[01:32:03.960 --> 01:32:13.960]  Вот сейчас у меня x и y это числа, которые могут принимать значение в диапазоне от минус 8 до 7.
[01:32:13.960 --> 01:32:16.960]  Потому что у них 4-х битный размер.
[01:32:16.960 --> 01:32:19.960]  Это значит, что 16 возможных значений.
[01:32:19.960 --> 01:32:22.960]  То есть каждый из таких полей может принимать значение от минус 8 до 7.
[01:32:22.960 --> 01:32:25.960]  А можно писать 2.1 или 2.0?
[01:32:25.960 --> 01:32:28.960]  2.0, наверное, не знаю.
[01:32:28.960 --> 01:32:31.960]  Ну либо CE, либо UB, 2.1 можно.
[01:32:31.960 --> 01:32:33.960]  Это будет 1-битное поле, да.
[01:32:33.960 --> 01:32:39.960]  Стоп, а что такое 1-битное 1.0?
[01:32:39.960 --> 01:32:42.960]  Это 0 и минус 1, что ли?
[01:32:42.960 --> 01:32:47.960]  А если int x 2.1, ну наверное да.
[01:32:47.960 --> 01:32:55.960]  Но если написать unsigned int x 2.4, то это будет от 0 до 15.
[01:32:55.960 --> 01:32:59.960]  А можно сделать не степень двойки?
[01:32:59.960 --> 01:33:01.960]  Что? Не степень двойки? Да, можно.
[01:33:01.960 --> 01:33:04.960]  Можно, например, сделать вот это 3, а вот это 5.
[01:33:04.960 --> 01:33:07.960]  А число просто 2 тысячи уже сделано?
[01:33:07.960 --> 01:33:08.960]  Да.
[01:33:08.960 --> 01:33:11.960]  А они обязаны в сумме быть?
[01:33:11.960 --> 01:33:14.960]  Нет, ну я могу сделать вот так.
[01:33:14.960 --> 01:33:18.960]  Тогда это будет объект и структуру будет 2 байта весить.
[01:33:18.960 --> 01:33:21.960]  Это число должно быть констатой?
[01:33:21.960 --> 01:33:23.960]  Да.
[01:33:23.960 --> 01:33:25.960]  Можно комплектировать?
[01:33:25.960 --> 01:33:27.960]  Нет, нельзя.
[01:33:27.960 --> 01:33:29.960]  Даже дробное нельзя.
[01:33:29.960 --> 01:33:31.960]  2.1 это не то же самое, что bool?
[01:33:31.960 --> 01:33:36.960]  Нет, конечно, bool это 1 байт, а int x 2.1 это 1 бит.
[01:33:36.960 --> 01:33:40.960]  Если мы объедем всего 8 штук, а 2.1 это будет 8 байт.
[01:33:40.960 --> 01:33:41.960]  Да-да-да.
[01:33:41.960 --> 01:33:44.960]  Вот, эта штука очень полезна.
[01:33:44.960 --> 01:33:48.960]  Лично я это видел в коде в промышленном.
[01:33:48.960 --> 01:33:52.960]  Когда реализуются какие-нибудь сетевые протоколы, например.
[01:33:52.960 --> 01:33:55.960]  Вот когда реализуется какой-нибудь протокол обмена сообщениями,
[01:33:55.960 --> 01:33:57.960]  какой-нибудь TCP, например.
[01:33:57.960 --> 01:34:01.960]  Там есть хедер, и в нем много разных флагов.
[01:34:01.960 --> 01:34:04.960]  Там флаг сетового, флаг сего, флаг этого, того.
[01:34:04.960 --> 01:34:08.960]  И вот это все в этой структуре, они битовые поля.
[01:34:08.960 --> 01:34:18.960]  Нет, это флаги, которые говорят в пакете данных какую-то 1-битовую информацию несут.
[01:34:18.960 --> 01:34:20.960]  Они могут 2-х битовые, 4-х битовые.
[01:34:20.960 --> 01:34:22.960]  Но вот битвы поля очень полезны для этого.
[01:34:32.960 --> 01:34:34.960]  Выравнивается до целого числа байт.
[01:34:34.960 --> 01:34:36.960]  Я думаю, выравнивается.
[01:34:36.960 --> 01:34:38.960]  Но было бы странно.
[01:34:38.960 --> 01:34:40.960]  Должно выравниваться.
[01:34:40.960 --> 01:34:42.960]  Не знаю.
[01:34:42.960 --> 01:34:44.960]  Не пробовал.
[01:34:46.960 --> 01:34:48.960]  Можно.
[01:34:48.960 --> 01:34:50.960]  Но это...
[01:34:50.960 --> 01:34:52.960]  Я не хочу это обсуждать.
[01:34:52.960 --> 01:34:56.960]  Короче, откройте страницу TCP-референс, пробитые поля,
[01:34:56.960 --> 01:34:58.960]  и прочитайте все, что с ними можно делать.
[01:35:00.960 --> 01:35:02.960]  Два байта.
[01:35:02.960 --> 01:35:04.960]  Два будет.
[01:35:04.960 --> 01:35:06.960]  Я тебе и так скажу.
[01:35:10.960 --> 01:35:13.960]  А, может он округляет до размера int вообще тогда?
[01:35:13.960 --> 01:35:15.960]  Я не знаю.
[01:35:15.960 --> 01:35:17.960]  Ну можно писать char, тогда 2 должно быть.
[01:35:27.960 --> 01:35:31.960]  Возможно, он округляет до сайзов вот этого типа, который здесь указан.
[01:35:31.960 --> 01:35:33.960]  Сайзов int.
[01:35:33.960 --> 01:35:35.960]  Но если написать char, то должно не округляться.
[01:35:35.960 --> 01:35:37.960]  Должно быть 2.
[01:35:37.960 --> 01:35:39.960]  Да, наверное, вот чем дело.
[01:35:39.960 --> 01:35:42.960]  Если вы пишете int, то он все равно выравнивает его.
[01:35:42.960 --> 01:35:44.960]  То есть у него сайзов...
[01:35:44.960 --> 01:35:46.960]  Короче, align of у него остается 4.
[01:35:46.960 --> 01:35:49.960]  И поэтому он считает, что и сайзов тоже 4.
[01:35:52.960 --> 01:35:55.960]  Да, вот видимо сейчас будет 4.
[01:35:55.960 --> 01:35:57.960]  Но если написать char, то будет 2.
[01:36:01.960 --> 01:36:03.960]  Вот так должно быть размер 2.
[01:36:05.960 --> 01:36:11.960]  То есть тут у нас получается, что y он будет лежать как-то частично в одном байте, частично в другом.
[01:36:11.960 --> 01:36:13.960]  Да.
[01:36:13.960 --> 01:36:18.960]  То есть это получается как-то очень медленно, достаточно медленно работает.
[01:36:18.960 --> 01:36:20.960]  Ну да нет.
[01:36:20.960 --> 01:36:25.960]  Процессор все равно читает не по байтово, а сразу пачка из нескольких байт.
[01:36:26.960 --> 01:36:30.960]  Наработать с этим гарсентом нормально не получится, да?
[01:36:30.960 --> 01:36:32.960]  Получится.
[01:36:32.960 --> 01:36:34.960]  Присваивать ему целые числа можно.
[01:36:34.960 --> 01:36:37.960]  Но если ты переполнишь, то будет ub опять.
[01:36:37.960 --> 01:36:40.960]  А, то есть если на первый момент будет ub?
[01:36:40.960 --> 01:36:43.960]  Ну если вы переполните, то, наверное, будет ub, если это знаковое число.
[01:36:43.960 --> 01:36:46.960]  И обрубится по модулю, если это будет беззнаковое число, как обычно.
[01:36:46.960 --> 01:36:49.960]  Если я добавлю 2, 3...
[01:36:49.960 --> 01:36:51.960]  То будет 5.
[01:36:51.960 --> 01:36:53.960]  Если у меня обратно не подбавится.
[01:36:53.960 --> 01:36:58.960]  Если это будет знаковое число, то это будет ub скорее всего.
[01:36:58.960 --> 01:37:01.960]  А если это не беззнаковое число, то будет обрубление по...
[01:37:01.960 --> 01:37:03.960]  Ну как unsigned int?
[01:37:03.960 --> 01:37:06.960]  По модулю степени двойки возьмется.
[01:37:06.960 --> 01:37:08.960]  Ну в плане по модулю 2 степени 3, да?
[01:37:08.960 --> 01:37:10.960]  Ну да.
[01:37:10.960 --> 01:37:12.960]  Так.
[01:37:12.960 --> 01:37:14.960]  Господа.
[01:37:14.960 --> 01:37:18.960]  Последний пункт нам надо обсудить, связанный с локаторами.
[01:37:18.960 --> 01:37:21.960]  Давайте мы все-таки прочитаем.
[01:37:22.960 --> 01:37:24.960]  Давайте мы все-таки сделаем рывок.
[01:37:24.960 --> 01:37:26.960]  Его обсудим, и потом пойдем на перерыв.
[01:37:26.960 --> 01:37:28.960]  А потом уже будет мух семантика.
[01:37:31.960 --> 01:37:34.960]  Пункт довольно...
[01:37:34.960 --> 01:37:37.960]  Криповый, значит.
[01:37:39.960 --> 01:37:42.960]  Следующий, последний пункт, который нам надо обсудить в этой теме,
[01:37:42.960 --> 01:37:45.960]  это так называемый scoped allocator.
[01:37:45.960 --> 01:37:46.960]  Это шестой?
[01:37:46.960 --> 01:37:48.960]  Да, 96.
[01:37:51.960 --> 01:37:58.960]  Ну давайте всякого на inclusive тут, чтобы было полегче.
[01:37:58.960 --> 01:38:01.960]  Чем нам scope, если мы с нас scope можем?
[01:38:01.960 --> 01:38:03.960]  Чего?
[01:38:07.960 --> 01:38:09.960]  Scoped allocators.
[01:38:09.960 --> 01:38:12.960]  Смотрите, какая история.
[01:38:15.960 --> 01:38:19.960]  Ну вот представьте, что у меня есть мой какой-нибудь allocator.
[01:38:21.960 --> 01:38:23.960]  Ну я не знаю там.
[01:38:23.960 --> 01:38:28.960]  Ну давайте я скажу, using my alloc равно...
[01:38:28.960 --> 01:38:29.960]  Не, не так.
[01:38:29.960 --> 01:38:37.960]  Вот я здесь скажу, template type name t.
[01:38:37.960 --> 01:38:40.960]  Что-то плохо работает подсказка, даже не помогает мне.
[01:38:40.960 --> 01:38:47.960]  My alloc равно std allocator at.
[01:38:47.960 --> 01:38:50.960]  Ну просто допустим, у меня есть какой-то кастомный allocator.
[01:38:50.960 --> 01:38:51.960]  Я...
[01:38:54.960 --> 01:38:59.960]  Это потому что у меня скорее всего был до этого файл, в котором это было написано, я не знаю, кто это понимает.
[01:39:03.960 --> 01:39:06.960]  Возможно он делает search по всей папке.
[01:39:06.960 --> 01:39:07.960]  Вот.
[01:39:07.960 --> 01:39:09.960]  Допустим, это какой-то кастомный allocator.
[01:39:09.960 --> 01:39:12.960]  Я говорю, my alloc...
[01:39:12.960 --> 01:39:14.960]  alloc.
[01:39:14.960 --> 01:39:17.960]  Какой-то экземпляр моего allocator.
[01:39:17.960 --> 01:39:21.960]  А теперь я завожу вектор...
[01:39:21.960 --> 01:39:24.960]  из строк...
[01:39:24.960 --> 01:39:26.960]  с my alloc...
[01:39:26.960 --> 01:39:27.960]  в.
[01:39:27.960 --> 01:39:30.960]  И начинаю pushback-ать туда строки.
[01:39:32.960 --> 01:39:34.960]  abc...
[01:39:37.960 --> 01:39:40.960]  Да, my alloc от std string.
[01:39:43.960 --> 01:39:45.960]  Жесть.
[01:39:48.960 --> 01:39:50.960]  Вот.
[01:39:51.960 --> 01:39:52.960]  Чего?
[01:39:54.960 --> 01:39:56.960]  Да господи.
[01:39:56.960 --> 01:39:58.960]  My alloc от std string.
[01:40:00.960 --> 01:40:02.960]  Вот.
[01:40:03.960 --> 01:40:05.960]  Что...
[01:40:06.960 --> 01:40:09.960]  вас здесь... ну вас кое-что должно смущать в этом коде.
[01:40:09.960 --> 01:40:12.960]  Вот что тут... что тут не так?
[01:40:17.960 --> 01:40:19.960]  Да, точно.
[01:40:19.960 --> 01:40:21.960]  Это правда.
[01:40:21.960 --> 01:40:23.960]  Я создал вектор от конкретного allocator.
[01:40:44.960 --> 01:40:46.960]  По-моему это что?
[01:40:47.960 --> 01:40:49.960]  Вопрос на отл-10?
[01:40:49.960 --> 01:40:52.960]  Да нет, это вопрос на...
[01:40:53.960 --> 01:40:55.960]  хор 7, я думаю.
[01:41:00.960 --> 01:41:02.960]  Ну, есть проблема.
[01:41:02.960 --> 01:41:05.960]  Представим, что my alloc это, скажем, стековый allocator.
[01:41:05.960 --> 01:41:08.960]  Я хочу, чтобы ничего в динамической памяти не выделялось.
[01:41:09.960 --> 01:41:14.960]  Но если я так напишу, не особо-то я добьюсь того, чего хочу.
[01:41:14.960 --> 01:41:16.960]  Потому что...
[01:41:16.960 --> 01:41:21.960]  string она же тоже делает new в своем конструкторе.
[01:41:25.960 --> 01:41:31.960]  То есть я завел вектор из строк над каким-то там особым allocator.
[01:41:31.960 --> 01:41:35.960]  Но сами строки в своих конструкторах тоже вызывают оператор new.
[01:41:35.960 --> 01:41:38.960]  И они-то уже этот allocator не спрашивают.
[01:41:38.960 --> 01:41:40.960]  Они используют стандартный allocator.
[01:41:40.960 --> 01:41:45.960]  На самом деле, строки std-шные, они, конечно, тоже используют allocator в себе.
[01:41:45.960 --> 01:41:48.960]  Но только они уже ничего не знают об этом allocator.
[01:41:48.960 --> 01:41:50.960]  Они будут выделяться на стандартном allocator.
[01:41:50.960 --> 01:41:55.960]  Вот давайте посмотрим на std-basic-string.
[01:42:02.960 --> 01:42:08.960]  Вот. На самом деле, для тех, кто не знал, я сообщу, а для тех, кто знал, напомню.
[01:42:08.960 --> 01:42:10.960]  Ну вот вообще это знать надо.
[01:42:10.960 --> 01:42:14.960]  Значит, что std-string это на самом деле некоторый using.
[01:42:14.960 --> 01:42:18.960]  А по-настоящему тип называется std-basic-string от char.
[01:42:18.960 --> 01:42:24.960]  Вот. Но у basic-string есть и другие шаблонные параметры.
[01:42:24.960 --> 01:42:31.960]  Но есть chart-rates, которые мы не будем, наверное, обсуждать.
[01:42:31.960 --> 01:42:33.960]  А есть allocator.
[01:42:33.960 --> 01:42:38.960]  Ну, короче, у basic-string есть параметр allocator, в общем-то.
[01:42:38.960 --> 01:42:40.960]  Как и у любого контейнера.
[01:42:40.960 --> 01:42:43.960]  Ну, string тоже вроде контейнер.
[01:42:43.960 --> 01:42:46.960]  Формально, кажется, нет, но...
[01:42:46.960 --> 01:42:51.960]  А, стд-basic-string удовлетворяет требования у локатора wire-container.
[01:42:51.960 --> 01:42:53.960]  То есть string это тоже формальный контейнер.
[01:42:53.960 --> 01:42:58.960]  А чем string в таком понимании, идейно, отличается от объекта?
[01:42:58.960 --> 01:43:04.960]  Ну, она проще устроена. Там нету всяких...
[01:43:07.960 --> 01:43:10.960]  Там нету этих заморочек, да, что тип может быть нестандартный.
[01:43:10.960 --> 01:43:13.960]  Она подразумевает, что она работает с char, с символами.
[01:43:13.960 --> 01:43:15.960]  И там есть операторы вывода, например.
[01:43:15.960 --> 01:43:20.960]  Ну, там за счет того, что символы, а не произвольные типы, все проще устроено.
[01:43:20.960 --> 01:43:23.960]  Вот. Есть cstr, например, data, ну и так далее.
[01:43:23.960 --> 01:43:24.960]  Что?
[01:43:24.960 --> 01:43:26.960]  А если std-basic-string отдавал?
[01:43:26.960 --> 01:43:29.960]  Я думаю, так нельзя.
[01:43:31.960 --> 01:43:34.960]  Так вот, у basic-string тоже есть allocator.
[01:43:34.960 --> 01:43:36.960]  У basic-string тоже есть allocator.
[01:43:36.960 --> 01:43:44.960]  Но при таком конструировании мы не используем этот allocator.
[01:43:44.960 --> 01:43:48.960]  То есть string использует стандартный allocator.
[01:43:48.960 --> 01:43:52.960]  А как нам сделать, чтобы строки, которые мы добавляем в свой вектор,
[01:43:52.960 --> 01:43:56.960]  создавались на том же allocator, на котором создавался и сам вектор?
[01:43:56.960 --> 01:44:01.960]  Нам нужно какой-то способ пробросить allocator во внутренние объекты.
[01:44:02.960 --> 01:44:11.960]  Мы хотим, чтобы для объектов вектора использовался тот же allocator,
[01:44:11.960 --> 01:44:13.960]  что и для самого вектора.
[01:44:13.960 --> 01:44:15.960]  Ну, тот же тип allocator.
[01:44:17.960 --> 01:44:18.960]  Вот.
[01:44:18.960 --> 01:44:22.960]  Конечно, мы могли бы сделать так.
[01:44:22.960 --> 01:44:23.960]  Вот так.
[01:44:27.960 --> 01:44:39.960]  Значит, myalloc от char там, myalloc от std-string от myalloc от char.
[01:44:41.960 --> 01:44:44.960]  И сюда нам придется, и тогда это не будет компилироваться.
[01:44:44.960 --> 01:44:45.960]  Почему?
[01:44:45.960 --> 01:44:51.960]  Потому что это не std-string от, ну, потому что это std-string от обычного allocator,
[01:44:51.960 --> 01:44:55.960]  а myalloc, ну, давайте попробуем компилировать.
[01:45:02.960 --> 01:45:03.960]  std-string is not a template.
[01:45:03.960 --> 01:45:09.960]  А, потому что здесь надо написать не std-string, а std-basic-string
[01:45:09.960 --> 01:45:13.960]  с шаблонными параметрами char, std-char-trades.
[01:45:15.960 --> 01:45:19.960]  А char язык C++ не исчерпаем богат.
[01:45:21.960 --> 01:45:38.960]  myalloc от char, myalloc от std-basic-string от char, std-char-trades от char, myalloc от char.
[01:45:51.960 --> 01:46:04.960]  Ну, а еще у нас myalloc для allocator от std-string должен быть std-string от char.
[01:46:04.960 --> 01:46:08.960]  Короче, я даже не буду, в общем, я просто все это отменю.
[01:46:08.960 --> 01:46:10.960]  Ну, так и надо на самом деле.
[01:46:10.960 --> 01:46:14.960]  Я не буду, в общем, доделывать это до того вида, в котором это будет работать.
[01:46:14.960 --> 01:46:17.960]  Представляю вам решение.
[01:46:17.960 --> 01:46:22.960]  Комитет по стандартизации думал-думал, как же победить эту проблему, и придумал.
[01:46:22.960 --> 01:46:27.960]  Представляю вам std-scoped-allocator-adapter.
[01:46:34.960 --> 01:46:39.960]  Итак, scoped-allocator-adapter.
[01:46:39.960 --> 01:46:50.960]  От создателей C++-1 от set.
[01:46:50.960 --> 01:46:56.960]  Defined только в заголовочном файле scoped-allocator.
[01:47:02.960 --> 01:47:04.960]  Scoped-allocator.
[01:47:05.960 --> 01:47:09.960]  Что эта штука позволяет делать?
[01:47:09.960 --> 01:47:18.960]  Она позволяет вам не париться насчет пробрасывания allocator во внутренние объекты, а сама делает это за вас.
[01:47:18.960 --> 01:47:20.960]  Как вы это используете?
[01:47:20.960 --> 01:47:31.960]  Вы говорите, вместо вот этого вы передаете std-scoped-allocator-adapter от вашего allocator.
[01:47:34.960 --> 01:47:38.960]  А мы должны?
[01:47:38.960 --> 01:47:39.960]  Да.
[01:47:39.960 --> 01:47:41.960]  Да, мы, конечно, должны.
[01:47:41.960 --> 01:47:44.960]  Потому что мы на конкретном локаторе создаемся.
[01:47:44.960 --> 01:47:45.960]  Вот.
[01:47:45.960 --> 01:47:51.960]  Что будет делать этот scoped-allocator-adapter?
[01:47:51.960 --> 01:47:58.960]  Как вообще это работать должно?
[01:47:58.960 --> 01:48:00.960]  Вот ваши идеи.
[01:48:00.960 --> 01:48:06.960]  Как должен быть реализован класс scoped-allocator-adapter, чтобы этот код работал корректно?
[01:48:06.960 --> 01:48:08.960]  Давайте еще проверим, что он работает корректно.
[01:48:11.960 --> 01:48:13.960]  Ну да, я здесь забыл std-string.
[01:48:19.960 --> 01:48:21.960]  Ну, я просто отменил лишнее.
[01:48:21.960 --> 01:48:22.960]  Вот.
[01:48:22.960 --> 01:48:24.960]  Вот этот код работает корректно.
[01:48:24.960 --> 01:48:30.960]  Утверждается, что теперь все строки создаются на том же самом локаторе, который я передал.
[01:48:30.960 --> 01:48:36.960]  Ну, то есть, если бы это был stack-овый локатор, то никакой динамической памяти бы не выделялось.
[01:48:36.960 --> 01:48:40.960]  Вопрос на... вот теперь уже вопрос на отл.
[01:48:40.960 --> 01:48:46.960]  А что должно быть написано в классе std-scoped-allocator-adapter?
[01:48:46.960 --> 01:48:50.960]  Как в нем должны быть реализованы методы, чтобы это корректно работало?
[01:48:50.960 --> 01:48:52.960]  Взвешиваться можно?
[01:48:54.960 --> 01:48:57.960]  Не могу пропагандировать суицид, к сожалению.
[01:49:11.960 --> 01:49:13.960]  Может, он переобретеляет аккрата new?
[01:49:14.960 --> 01:49:17.960]  Кто, а локатор? Нет, вы что, оператор new ни в коем случае.
[01:49:17.960 --> 01:49:21.960]  Мы не пользуемся оператором new в контейнере.
[01:49:28.960 --> 01:49:30.960]  Чего? Нет.
[01:49:30.960 --> 01:49:37.960]  У вектора... Вектор от строк, но аллокатор в нем имеет тип scoped-allocator-adapter.
[01:49:47.960 --> 01:49:54.960]  Это значит, что если у нас используется scoped-allocator-adapter, то это значит, что на самом деле мы храним где стринг,
[01:49:54.960 --> 01:49:59.960]  a basic-string, char-trade и рома нашего нового кавринина.
[01:49:59.960 --> 01:50:03.960]  И еще... Ты иногда отвечаешь, что у нас как бы другой тип уже векторе хранится как-то вначале.
[01:50:03.960 --> 01:50:14.960]  Так, а почему мы в качестве параметра для вектора передаем аллокат уже другого типа, а не того же, как у нас указано в шоплоне?
[01:50:14.960 --> 01:50:21.960]  Это может быть, если там, допустим, есть scoped-allocator, там может быть конструктор подходящий.
[01:50:23.960 --> 01:50:28.960]  Вектор... Вот, вектор... Давайте вспомним, что делает вектор.
[01:50:28.960 --> 01:50:32.960]  А может у scoped-allocator есть frame на все базовые классы?
[01:50:32.960 --> 01:50:35.960]  И он может там менять тем более локатор?
[01:50:35.960 --> 01:50:41.960]  Давайте вспомним, что делает вектор. Вектор в своем конструкторе создает...
[01:50:45.960 --> 01:50:50.960]  Во-первых, он как вектор использует аллокатор. Давайте вспомним.
[01:50:50.960 --> 01:50:57.960]  Во-первых, вектор выделяет на аллокаторе count-штук нашего типа.
[01:50:59.960 --> 01:51:04.960]  Тут уже есть проблема, потому что нам нужно не string хранить, а string с нужным аллокатором.
[01:51:04.960 --> 01:51:09.960]  Ну, забьем пока на нее. А потом он делает констракт.
[01:51:09.960 --> 01:51:14.960]  Он делает констракт по указателю нужного значения.
[01:51:14.960 --> 01:51:26.960]  То есть, когда мы делаем pushback-вектор, этот вектор берет аллокатор trades от нашего аллокатора, то есть от scoped-allocator, констракт по указателю от вот этих параметров.
[01:51:26.960 --> 01:51:32.960]  Может внутри аллокатор trades есть функция, которая нам...
[01:51:32.960 --> 01:51:37.960]  Нет-нет, аллокатор trades, напоминаю, аллокатор trades-констракт устроена просто.
[01:51:37.960 --> 01:51:42.960]  Если в аллокаторе определен констракт, она вызывает его, а иначе просто вызывает placement-new.
[01:51:42.960 --> 01:51:46.960]  Так мы не можем внутри аллокатор trades...
[01:51:46.960 --> 01:51:55.960]  Аллокатор trades ничего не знает про scoped-allocator, это просто обертка, общая обертка над аллокатором, которая, если функция определяет, вызывает ее, иначе делает placement-new.
[01:51:55.960 --> 01:52:00.960]  А аллокатор trades-то более высокий уровень абстракции, чем нам сейчас нужен.
[01:52:00.960 --> 01:52:04.960]  А оператор new-то более низкий уровень абстракции, который нам сейчас нужен.
[01:52:04.960 --> 01:52:08.960]  Проблема решается на уровне самого класса scoped-allocator-адаптер.
[01:52:08.960 --> 01:52:17.960]  В нем так хитро определены методы, что когда вектор вызывает вот то, что он вызывает, scoped-allocator-adapter все подменяет так, что правильно все конструируется.
[01:52:17.960 --> 01:52:22.960]  На самом деле в scoped-allocator-адаптере как раз переопределен метод констракт необычным образом.
[01:52:23.960 --> 01:52:31.960]  Scoped-allocator-adapter это как раз пример аллокатора, у которого конструкт это далеко не просто placement-new, а что-то очень хитрое.
[01:52:33.960 --> 01:52:37.960]  Что такое конструкт у scoped-allocator-adapter?
[01:52:40.960 --> 01:52:45.960]  Давайте я, наверное, вам код открою готовый.
[01:52:47.960 --> 01:52:49.960]  Прошлогодний просто.
[01:52:52.960 --> 01:52:56.960]  А что из себя представляет scoped-allocator-adapter?
[01:52:58.960 --> 01:53:02.960]  Он хранит в себе вот тот самый аллокатор, от которого он построен.
[01:53:03.960 --> 01:53:11.960]  И когда, ну, allocate-diallocate работают стандартным образом, но когда у него вызывают конструкт, он ведет себя очень необычно.
[01:53:11.960 --> 01:53:14.960]  Он не просто вызывает placement-new.
[01:53:14.960 --> 01:53:38.960]  Он создает аллокатор нужного типа из того аллокатора, что он хранит, и уже на своем аллокаторе, который он хранит, вызывает конструкт от тех аргументов, которые ему дали, с дополнительным аргументом тот аллокатор, который он создал.
[01:53:44.960 --> 01:53:50.960]  Это означает, что мы предполагаем, что все наши объекты так строены, что они себе конструкт предпринимают аллокатор?
[01:53:50.960 --> 01:53:52.960]  Да, да.
[01:53:52.960 --> 01:53:56.960]  Или последним. Смотрите, как это работает в конкретном случае вектора и строк.
[01:53:57.960 --> 01:54:06.960]  Вектор говорит, сконструируй, пожалуйста, строку на данном указателе от аргументов...
[01:54:07.960 --> 01:54:10.960]  Сейчас, мне кажется, что стринг все-таки...
[01:54:13.960 --> 01:54:20.960]  Все-таки стринг придется другой тип указать. То, как я написал, все-таки не будет правильно работать, я вас обманул.
[01:54:20.960 --> 01:54:25.960]  Потому что проблему с тем, что стринг по умолчанию другой аллокатор использует, мы не решим.
[01:54:25.960 --> 01:54:28.960]  Вектор должен понимать, какие строки он хранит.
[01:54:29.960 --> 01:54:34.960]  То есть стринг все-таки должно быть с указанным аллокатором.
[01:54:37.960 --> 01:54:42.960]  У нас же по идее два вектора с разными аллокаторами, это тоже два разных типа.
[01:54:43.960 --> 01:54:45.960]  С разными типами аллокаторов?
[01:54:45.960 --> 01:54:46.960]  Ну да.
[01:54:47.960 --> 01:54:58.960]  Значит, вот здесь вот я все-таки должен написать, using my string равно std basic string...
[01:54:59.960 --> 01:55:01.960]  От нашего аллокатора, да?
[01:55:02.960 --> 01:55:13.960]  от char std char trades от char и my...
[01:55:14.960 --> 01:55:25.960]  Ну, скомпилировалось, он просто увидел, что у стринга нет этого нужного аллокатора и просто делал стринг по-прежнему через new.
[01:55:25.960 --> 01:55:30.960]  Вот при такой реализации оно скомпилировалось, но все равно выделяло стринг через new.
[01:55:30.960 --> 01:55:32.960]  А вот сейчас он будет выделять стринг правильно.
[01:55:32.960 --> 01:55:35.960]  Значит, my lock от char.
[01:55:36.960 --> 01:55:38.960]  Вот. Мне надо...
[01:55:42.960 --> 01:55:44.960]  Не, my lock от char.
[01:55:47.960 --> 01:55:48.960]  Чего?
[01:55:54.960 --> 01:55:55.960]  Да это неважно.
[01:55:55.960 --> 01:55:57.960]  А, ну можно сказать my lock от...
[01:55:58.960 --> 01:56:01.960]  Ну можно сказать my lock от my string, наверное, да, хорошо.
[01:56:01.960 --> 01:56:06.960]  Но это в принципе неважно, потому что он все равно же создать себе аллокатор нужного типа.
[01:56:08.960 --> 01:56:10.960]  Вот, и здесь я пишу my string.
[01:56:14.960 --> 01:56:17.960]  Потому что объект был бы... объект аллокатора был бы другим.
[01:56:17.960 --> 01:56:22.960]  Он бы начал создавать на аллокаторе того же типа, но на другом объекте аллокатор.
[01:56:23.960 --> 01:56:26.960]  Если у меня stack аллокатор, то у него могут быть разные буферы.
[01:56:27.960 --> 01:56:30.960]  Он бы создал новый объект аллокатора из ничего.
[01:56:30.960 --> 01:56:38.960]  И это бы означало, что строки он бы создавал на другом каком-то буфере, не на том, на котором создавался сам вектор.
[01:56:38.960 --> 01:56:43.960]  Или он бы вообще не смог создать буфер, потому что он бы не знал, из чего создать новый объект аллокатора.
[01:56:43.960 --> 01:56:50.960]  Суть в том, чтобы он создавал строки на том же самом аллокаторе, в смысле на равном данном аллокаторе.
[01:56:50.960 --> 01:56:55.960]  У этого аллокатора будет другой тип, но как аллокаторы они будут равны, как объекты.
[01:56:55.960 --> 01:56:57.960]  Потому что они будут указаны на один и тот же пул.
[01:56:57.960 --> 01:57:01.960]  Нам надо, чтобы эти аллокаторы на одном и том же пуле создавали объекты.
[01:57:02.960 --> 01:57:12.960]  И вот скоп аллокатор-адаптер позволяет заставить внутренние объекты создавать на том же самом, в смысле равенство аллокаторов, аллокаторе, на котором создавались внешние объекты.
[01:57:13.960 --> 01:57:21.960]  Так вот здесь мы еще раз разбираем, как работает констракт.
[01:57:21.960 --> 01:57:23.960]  Это пример аллокатора с нестандартным констрактом.
[01:57:23.960 --> 01:57:30.960]  Мы получаем указатель на майстринг и аргументы, из которых надо создать майстринг.
[01:57:35.960 --> 01:57:38.960]  А вот этот иф мы пока пропустим, будем считать, что это верно.
[01:57:38.960 --> 01:57:45.960]  Дальше мы говорим, пусть innerLog это t2.2.allocatorType.
[01:57:45.960 --> 01:57:47.960]  Не забываем tapeName, конечно.
[01:57:47.960 --> 01:57:52.960]  Мы предполагаем, что внутри типа t определен usingAllocatorType.
[01:57:52.960 --> 01:57:56.960]  И вот это ключевое предположение, на которое мы опираемся.
[01:57:56.960 --> 01:58:00.960]  Но внутри стринг, как и внутри любого контейнера, определен внутренний тип AllocatorType.
[01:58:00.960 --> 01:58:03.960]  Это требование к контейнеру, там обязан быть определен AllocatorType.
[01:58:04.960 --> 01:58:08.960]  Таким образом мы понимаем, каков тип Allocator, на котором делать строку.
[01:58:08.960 --> 01:58:17.960]  Дальше мы создаем объект такого типа, называем его innerLog, из того Allocator, который есть у нас.
[01:58:17.960 --> 01:58:24.960]  То есть мы создаем копию того Allocator, который есть у нас, но это уже получается Allocator на char, а не Allocator на string.
[01:58:24.960 --> 01:58:30.960]  А дальше мы вызываем констракт от нашего Allocator.
[01:58:34.960 --> 01:58:38.960]  InnerLog теперь это Allocator на char.
[01:58:38.960 --> 01:58:42.960]  Мы из строки, вот это t это string, t это myString.
[01:58:42.960 --> 01:58:44.960]  В myString определен AllocatorType.
[01:58:44.960 --> 01:58:48.960]  И там написано usingAllocatorType равно вот тот Allocator, на котором string делается.
[01:58:48.960 --> 01:58:51.960]  Это myAllocator от char.
[01:58:51.960 --> 01:58:57.960]  Так что вот этой строчкой мы узнали, какой тип должен быть у Allocator, на котором делать строку.
[01:58:57.960 --> 01:59:03.960]  Теперь мы вот такого типа создаем innerLog и делаем его копией нашего Allocator.
[01:59:03.960 --> 01:59:06.960]  ourLog это myAllocator от string.
[01:59:06.960 --> 01:59:09.960]  innerLog теперь это myAllocator от char.
[01:59:09.960 --> 01:59:16.960]  Мы делаем копию Allocator от string, и типа этой копии будет Allocator от char.
[01:59:16.960 --> 01:59:23.960]  А дальше мы у нашего Allocator, который от string, вызываем констракт через AllocatorTrades.
[01:59:23.960 --> 01:59:30.960]  По указателю на string от тех аргументов, которые нам передали, и с последним дополнительным аргументом innerLog.
[01:59:30.960 --> 01:59:37.960]  То есть мы на самом деле вызываем вот такой конструктор от строки, вот здесь вот.
[01:59:37.960 --> 01:59:46.960]  Мы по сути вызываем вот этот конструктор, вот этот конструктор, с последним аргументом Allocator.
[01:59:46.960 --> 01:59:52.960]  Вот. То есть мы попадем в этот конструктор.
[01:59:52.960 --> 02:00:05.960]  Вот здесь вот мы на нашем Allocator, Allocator.construct от pointer, а дальше передаем аргументы строки, и последним аргументом даем ей ее Allocator, который ей нужно.
[02:00:05.960 --> 02:00:11.960]  Который является копией нашего Allocator, что приведет к тому, что они создаются на одном и том же пуле.
[02:00:11.960 --> 02:00:20.960]  В качестве упражнения предлагаем самостоятельно реализовать Destroy для скопт AllocatorAdapter.
[02:00:20.960 --> 02:00:25.960]  Остался вопрос, что такое ifconstects.std.usersAllocatorV.
[02:00:25.960 --> 02:00:38.960]  А это как раз вот этот ifчик, который проверяет, правда ли внутри нашего типа T есть AllocatorType, который конвертируем в наш AllocatorType.
[02:00:38.960 --> 02:00:54.960]  UsersAllocatorV это такая метафункция, которая проверяет, правда ли в нашем типе T есть usingAllocatorType, равный такому типу, что его можно создать из нашего Alloc.
[02:00:54.960 --> 02:00:59.960]  Это просто метафункция, которая определена в стандартной библиотеке.
[02:00:59.960 --> 02:01:05.960]  UsersAllocatorV это шаблонная переменная.
[02:01:05.960 --> 02:01:10.960]  На самом деле это структура usersAllocator, в которой есть статик const bool value равно.
[02:01:10.960 --> 02:01:16.960]  И там написано шаблонное маги, которое проверяет, что правда в типе T есть AllocatorType, конвертируемый в наш Allocator.
[02:01:16.960 --> 02:01:20.960]  То есть мы должны в каждом контейнере подписывать...
[02:01:20.960 --> 02:01:23.960]  Да, это требование к контейнеру.
[02:01:23.960 --> 02:01:26.960]  Это входит в число требований namedRequirementsContainer.
[02:01:26.960 --> 02:01:29.960]  Там должен быть указано AllocatorAwareContainer.
[02:01:29.960 --> 02:01:34.960]  Если это AllocatorAwareContainer, то в нем обязательно должен быть AllocatorType и написано вот это.
[02:01:34.960 --> 02:01:40.960]  А если это неверно, то есть если там окажется, что нет AllocatorType, вот именно поэтому это под constexpr.
[02:01:40.960 --> 02:01:45.960]  Если окажется, что та строка, которую нас просят конструировать, она не поддерживает такой Allocator.
[02:01:45.960 --> 02:01:49.960]  Это как в первом примере, который я разбирал, когда я не забыл указать Allocator в строке.
[02:01:49.960 --> 02:01:57.960]  Я попаду сюда, а тут мы просто игнорируем Allocator и тут мы просто сделаем констракт без какого-либо Allocator.
[02:01:57.960 --> 02:02:05.960]  То есть мы просто сделаем вот это, но уже без InnerLog.
[02:02:05.960 --> 02:02:12.960]  Просто сделаем констракт на нашем Allocator от argument, но без InnerLog.
[02:02:12.960 --> 02:02:16.960]  Это то, что происходило в первом примере и CE не было.
[02:02:16.960 --> 02:02:26.960]  Это упрощенная реализация констракта, там на самом деле все еще хитрее, но это мы пока опустим.
[02:02:26.960 --> 02:02:29.960]  В качестве упражнений можно реализовать Destroy.
[02:02:29.960 --> 02:02:32.960]  Ну, в общем, кто еще раз Main.
[02:02:32.960 --> 02:02:34.960]  Вот.
[02:02:44.960 --> 02:02:45.960]  Чего-чего?
[02:02:45.960 --> 02:02:48.960]  Мы не решили проблемы с ним, потому что это не STD String.
[02:02:48.960 --> 02:02:50.960]  Это все равно Basic String.
[02:02:50.960 --> 02:02:53.960]  Ну, я, кстати, думаю, что можно...
[02:02:53.960 --> 02:02:58.960]  Вот так, может быть, оно даже скомпилируется, но я не уверен, может и не скомпилируется.
[02:02:58.960 --> 02:02:59.960]  Сейчас.
[02:03:01.960 --> 02:03:03.960]  Так, нет, не туда.
[02:03:10.960 --> 02:03:12.960]  Минус STD C++17.
[02:03:12.960 --> 02:03:16.960]  Компилируется.
[02:03:18.960 --> 02:03:26.960]  Да, потому что у MyString есть конструктор, принимающий только один аргумент, а второй аргумент по умолчанию.
[02:03:28.960 --> 02:03:29.960]  Нам не нужно...
[02:03:29.960 --> 02:03:35.960]  Ну, если у нас есть вот этот вот конструктор, вот этот.
[02:03:38.960 --> 02:03:40.960]  Вот этот, ну вот этот, да.
[02:03:40.960 --> 02:03:46.960]  У него второй аргумент по умолчанию, и это не explicit конструктор, поэтому мы все равно в него попадаем, даже не указывая явно Allocator.
[02:03:46.960 --> 02:03:51.960]  Поэтому даже вот такой код компилируется, несмотря на то, что типа MyString, а не STD String.
[02:03:52.960 --> 02:03:58.960]  Потому что вот этот конструктор не explicit, а второй аргумент у него по умолчанию.
[02:03:58.960 --> 02:04:04.960]  Он понимает, что я хочу сконструировать Mat String от одного аргумента, который является char звездочкой.
[02:04:04.960 --> 02:04:09.960]  И второй аргумент у меня не указан, но у меня есть подходящий конструктор.
[02:04:09.960 --> 02:04:13.960]  Как сконструить MyString, а второй аргумент просто по умолчанию подставить.
[02:04:16.960 --> 02:04:27.960]  Ну, кто хочет, будет хотеть на экзамене отел, тот это заботает, пересмотрит, а остальные забейте.
[02:04:28.960 --> 02:04:33.960]  Все, мы закончили тему Allocators, перерыв, и сейчас будет Move Semantica.
[02:04:34.960 --> 02:04:37.960]  И соберемся.
[02:04:39.960 --> 02:04:47.960]  Move Semantica и R-Value ссылки. Это то, чего все, я думаю, долго ждали. Пришла пора.
[02:04:52.960 --> 02:04:59.960]  Вот. Ну, я всегда перед этой темой делаю дисклеймер, что с первого раза вы, скорее всего, не поймете.
[02:04:59.960 --> 02:05:02.960]  Поэтому, чем раньше вы начнете пытаться понять, тем лучше.
[02:05:02.960 --> 02:05:10.960]  Вот. У тех, кто начнет в феврале, гораздо больше шансов разобраться к концу семестра, чем у тех, кто начнет в конце семестра.
[02:05:10.960 --> 02:05:11.960]  Оптимистичная тема.
[02:05:11.960 --> 02:05:19.960]  Вот. Да. Я лично понял раза с четвертого, когда мне четыре раза прослушал в разных источниках и понял.
[02:05:21.960 --> 02:05:25.960]  Вы можете, конечно, меня перебивать, задавать вопросы, пытаться понять, чтобы.
[02:05:25.960 --> 02:05:31.960]  Но если вы не поймете все равно, не страшно. Вы можете еще несколько раз пересмотреть, и потом поймете.
[02:05:31.960 --> 02:05:34.960]  А если поймем, то значит, может, это неверно.
[02:05:34.960 --> 02:05:44.960]  Да. Если вы поймете с первого раза, ну, может быть, вы действительно такой умный, а может быть, вы что-то неправильно уложили у себя в голове, и надо еще раз пересмыслить.
[02:05:46.960 --> 02:05:48.960]  Ну, параграф 10.1.
[02:05:52.960 --> 02:05:53.960]  Идея.
[02:05:56.960 --> 02:06:00.960]  Мув семантики 10.1.
[02:06:03.960 --> 02:06:07.960]  И волшебная функция steady move.
[02:06:07.960 --> 02:06:26.960]  Вот. Давайте вспомним, какие у нас были проблемы, связанные с лишними копированиями.
[02:06:26.960 --> 02:06:34.960]  Первая такая проблема у нас была, когда мы реализовали функцию swap.
[02:06:34.960 --> 02:06:43.960]  Вот функция swap, если попытаться реализовать для двух произвольных типов, она у нас была написана так.
[02:06:43.960 --> 02:06:50.960]  Мы объявляем новый объект tmp, который равен x, потом x равен y, потом y равен t.
[02:06:54.960 --> 02:06:58.960]  Когда вы это делали для интов, все было нормально.
[02:06:58.960 --> 02:07:01.960]  Когда мы только ссылки изучали в первый раз.
[02:07:01.960 --> 02:07:08.960]  Но когда у нас возникли нетривиальные объекты, наша реализация функции swap стала непригодной.
[02:07:08.960 --> 02:07:14.960]  В таком виде, вот как сейчас написано. Понимаете, почему эта реализация swap не годная совершенно?
[02:07:14.960 --> 02:07:22.960]  Потому что, например, если это строки, то это будет линейное время, не просто линейное, а тройное просто копирование.
[02:07:22.960 --> 02:07:28.960]  Каждая строчка этого кода это копирование строки целиком.
[02:07:28.960 --> 02:07:35.960]  Хотя, казалось бы, можно просто слопнуть указатели, но как это сделать в общем случае для всех типов непонятно.
[02:07:35.960 --> 02:07:40.960]  Ну ладно. Следующая проблема.
[02:07:40.960 --> 02:07:46.960]  Вот у нас есть вектор. Допустим, опять вектор и строк.
[02:07:49.960 --> 02:07:57.960]  И мы в этот вектор решаем положить, вот прям буквально то, что мы недавно делали, какую-нибудь строку abc.
[02:07:58.960 --> 02:08:05.960]  Понимаете ли вы, почему это плохо? Работает, вот если писать это так, как мы писали раньше.
[02:08:05.960 --> 02:08:09.960]  Здесь опять лишние действия очень неприятные.
[02:08:11.960 --> 02:08:18.960]  Потому что мы два раза вызовем конструктор строки на самом деле, и два раза обратимся к нью, хотя могли бы один.
[02:08:18.960 --> 02:08:25.960]  Почему? Ну потому что давайте вспомним внимательно, что происходит при pushback.
[02:08:25.960 --> 02:08:37.960]  У нас изначально в векторе, ну вектор у нас пустой, там допустим у нас, ну скажем, ладно, мы сделали v.reserve на 1.
[02:08:37.960 --> 02:08:43.960]  То есть мы даже эту часть опустим. То есть что там вектор сам резервирует, это ладно.
[02:08:43.960 --> 02:08:48.960]  У нас память выделена под объекты в векторе. И вот мы говорим v pushback abc.
[02:08:48.960 --> 02:08:59.960]  Pushback принимает const t ampersand, t это std string. То есть создается std string из вот этого abc, чтобы передаться в параметр pushback.
[02:08:59.960 --> 02:09:07.960]  Да, вот в этом месте явно создается std string, который принимается по константной ссылке в метод pushback.
[02:09:07.960 --> 02:09:18.960]  После чего pushback там что-то делает, и дальше там написано new от ptr, t от того, что нам дали.
[02:09:18.960 --> 02:09:32.960]  Да, placement new. Что такое t? t это std string. То есть в методе pushback в какой-то момент написано new от ptr, std string от вот этот вот x, который положили в вектор.
[02:09:32.960 --> 02:09:37.960]  Это что такое? Это опять создание std string из того std string, который только что нам дали.
[02:09:37.960 --> 02:09:44.960]  То есть мы один раз создали string, когда передавали ее в качестве параметров pushback.
[02:09:44.960 --> 02:09:50.960]  Второй раз создали string из первого string, когда уже клали ее непосредственно в вектор.
[02:09:50.960 --> 02:09:56.960]  Понимаете проблему? Мы два раза создали string на самом деле, когда так написали.
[02:09:56.960 --> 02:10:04.960]  А уж совсем неприятно это выглядит, когда мы делаем резерв.
[02:10:04.960 --> 02:10:12.960]  Ведь помните, когда мы реализовали вектор, у нас в какой-то момент нужно было реалацировать память.
[02:10:12.960 --> 02:10:20.960]  Вот мы берем старый массив и перекладываем его в новый массив. Что такое перекладываем?
[02:10:21.960 --> 02:10:31.960]  Мы берем все эти объекты и говорим new от вот этого вот pointer t от aritova.
[02:10:31.960 --> 02:10:37.960]  То есть мы берем placement new, вызываем n раз на каждый вот этот объект.
[02:10:37.960 --> 02:10:43.960]  В случае строк это означает, что мы создаем n новых строк каждой из соответствующей старой строки.
[02:10:43.960 --> 02:10:47.960]  Но что такое создание новой строки и старой строки? Это опять new.
[02:10:47.960 --> 02:10:53.960]  То есть каждый раз, когда мы перекладываем, вот если использовать нашу старую реализацию вектора,
[02:10:53.960 --> 02:11:01.960]  ту которую мы написали, каждый раз, когда мы делаем реаллокацию, мы n раз вызываем new,
[02:11:01.960 --> 02:11:09.960]  когда нам нужно переложить, нет бы просто взять и вот сюда присвоить тест pointer,
[02:11:09.960 --> 02:11:15.960]  которые в этих строках хранились, потому что строки же сами хранят pointer на какие-то массивы чаров.
[02:11:15.960 --> 02:11:23.960]  Нет бы нам взять и как-то умудриться вот сюда просто записать поля этих строк, чтобы pointer просто остались теми же.
[02:11:23.960 --> 02:11:29.960]  Но нет, мы так не умеем делать. Мы конструируем полностью строки заново.
[02:11:29.960 --> 02:11:35.960]  И не только строки, но любые объекты, которые мы бы перекладывали в векторе, мы бы их конструировали заново.
[02:11:35.960 --> 02:11:37.960]  То есть мы n раз копируем.
[02:11:37.960 --> 02:11:38.960]  То есть нам больно.
[02:11:38.960 --> 02:11:40.960]  Да, это очень неэффективно.
[02:11:45.960 --> 02:11:48.960]  Вообще это не только в pushback такая ситуация.
[02:11:48.960 --> 02:11:55.960]  Вот, например, представьте, что у вас есть какая-нибудь функция, которая...
[02:12:01.960 --> 02:12:07.960]  Ну, действительно, даже, к примеру, не pushback, а любая вообще функция,
[02:12:07.960 --> 02:12:12.960]  которая принимает объект по константной ссылке и потом этот объект где-то сохраняет, скажем.
[02:12:12.960 --> 02:12:13.960]  Вот.
[02:12:13.960 --> 02:12:21.960]  Она могла бы этот объект сохранить прямо вот в его первозданном виде, не создавая копию.
[02:12:21.960 --> 02:12:25.960]  То есть вот вы создали какой-то временный объект и отдали его в какую-то функцию, которая должна его сохранить.
[02:12:25.960 --> 02:12:32.960]  И в нормальной ситуации вы бы могли вот этот вот временный объект, только что созданный, как-то положить сразу на нужное место, и все.
[02:12:32.960 --> 02:12:33.960]  Но нет.
[02:12:33.960 --> 02:12:36.960]  Если вы приняли по константной ссылке, вы вынуждены копировать.
[02:12:36.960 --> 02:12:42.960]  И вот в таком сценарии у вас будет двойное создание объекта одного и того же.
[02:12:42.960 --> 02:12:46.960]  И еще один сценарий – это когда вы бросаете исключения.
[02:12:46.960 --> 02:12:51.960]  Вот, когда вы пишете throw что-нибудь, например, ту же строку несчастную.
[02:12:51.960 --> 02:12:55.960]  Вот я говорю throw s, где s – это некоторая строка.
[02:12:55.960 --> 02:13:03.960]  Эта строка копируется, как вы помните, в специальное место памяти, где будет лежать это исключение, пока оно летит.
[02:13:03.960 --> 02:13:05.960]  Казалось бы, зачем?
[02:13:05.960 --> 02:13:10.960]  Ведь ну зачем это, получается, надо создать новую строку из старой строки?
[02:13:10.960 --> 02:13:13.960]  Но ведь та строка сразу же сейчас будет уничтожена.
[02:13:13.960 --> 02:13:15.960]  Зачем копировать-то?
[02:13:15.960 --> 02:13:18.960]  Можно как-то вот просто поля переложить, что ли?
[02:13:22.960 --> 02:13:23.960]  Чего-чего во время копирования?
[02:13:26.960 --> 02:13:30.960]  Ну если во время копирования вылетает исключение, то да, то полетит в итоге оно.
[02:13:30.960 --> 02:13:35.960]  Но этот вопрос мы уж не обсуждаем сейчас.
[02:13:42.960 --> 02:13:45.960]  Вот, кстати, про реаллокацию вектора.
[02:13:45.960 --> 02:13:49.960]  Почему нельзя просто побитого скопировать память?
[02:13:49.960 --> 02:13:55.960]  И скользь я про это говорил в прошлом семестре, а может и в этом, но, возможно, все забыли.
[02:13:55.960 --> 02:13:58.960]  Почему бы не решить проблемы с реаллокацией вектора так?
[02:13:58.960 --> 02:14:00.960]  Просто побитого скопировать память отсюда-сюда.
[02:14:00.960 --> 02:14:03.960]  Это может быть какой-то указатель на какое-то свое поле.
[02:14:03.960 --> 02:14:07.960]  Да-да, если там какие-то кросспойнтеры, ну если в каком-то, если эти объекты...
[02:14:07.960 --> 02:14:09.960]  Если там что-то сложнее, чем просто поле...
[02:14:09.960 --> 02:14:16.960]  Если там объекты, которые в полях ссылаются на другие свои же поля, то все сломается.
[02:14:16.960 --> 02:14:17.960]  Вот.
[02:14:17.960 --> 02:14:18.960]  И, кстати...
[02:14:18.960 --> 02:14:19.960]  Чего?
[02:14:19.960 --> 02:14:20.960]  Что?
[02:14:20.960 --> 02:14:22.960]  А, вот все.
[02:14:22.960 --> 02:14:23.960]  Да.
[02:14:23.960 --> 02:14:26.960]  Вопрос в том, почему нельзя скопировать объект без вызова конструктора.
[02:14:26.960 --> 02:14:33.960]  Почему нельзя сделать просто memcpi побитого вот этой памяти в эту, когда мы делаем реаллокацию вектора?
[02:14:33.960 --> 02:14:44.960]  Потому что, если объекты были нетривиальными такими, что, например, у них были поля, ссылающиеся на другие поля, то все сломается.
[02:14:44.960 --> 02:14:46.960]  И фат структура тоже не хватает.
[02:14:46.960 --> 02:14:47.960]  Вот.
[02:14:47.960 --> 02:14:48.960]  Вот.
[02:14:48.960 --> 02:14:57.960]  Можно бы было написать if constexpr данный тип является int или чем-то там примитивным, и тогда скопировать побитого, а иначе...
[02:14:57.960 --> 02:14:59.960]  Но с этими случаями и так проблем нет.
[02:14:59.960 --> 02:15:02.960]  С этими случаями и так проблем нет.
[02:15:02.960 --> 02:15:05.960]  Вот если структура нетривиальная, как ее перекладывать, непонятно.
[02:15:05.960 --> 02:15:07.960]  Кстати, спойлер.
[02:15:07.960 --> 02:15:09.960]  std string как раз так и устроено.
[02:15:09.960 --> 02:15:12.960]  Там одни поля ссылаются на другие.
[02:15:12.960 --> 02:15:14.960]  Вообще говоря.
[02:15:14.960 --> 02:15:20.960]  Но это очень хитрое знание, которое мы потом разберем.
[02:15:20.960 --> 02:15:25.960]  Ну, короче, вот уже для std string бы это работало неправильно в общем случае.
[02:15:25.960 --> 02:15:34.960]  Потому что на самом деле в std string так устроена хитра оптимизация, что там как раз одно поле является ссылкой на другое, вообще говоря.
[02:15:34.960 --> 02:15:38.960]  И как раз для std string уже бы это сломалось.
[02:15:38.960 --> 02:15:41.960]  Но если вы пока не понимаете, то забейте.
[02:15:41.960 --> 02:15:46.960]  Потом мы разберем подробно, как std string устроен внутри, и вы поймете.
[02:15:46.960 --> 02:15:48.960]  Ну да ладно.
[02:15:57.960 --> 02:15:59.960]  Mc5 побитого копирует.
[02:15:59.960 --> 02:16:04.960]  Когда мы копируем строки, мы перевыделяем память под строку заново.
[02:16:04.960 --> 02:16:08.960]  Медленно, конечно, мы нью должны вызывать на каждое копирование строки.
[02:16:12.960 --> 02:16:13.960]  Еще раз.
[02:16:13.960 --> 02:16:16.960]  У тебя есть 10 строк.
[02:16:16.960 --> 02:16:21.960]  Каждая строка это указатель на огромный массив.
[02:16:24.960 --> 02:16:25.960]  И так далее.
[02:16:25.960 --> 02:16:28.960]  Нет бы взять и переставить указатели, чтобы они здесь лежали.
[02:16:28.960 --> 02:16:29.960]  Нет.
[02:16:29.960 --> 02:16:35.960]  Мы берем и говорим, возьмем эту строку и перевыделим вот эту память заново.
[02:16:35.960 --> 02:16:37.960]  И выделим этот массив и перекопируем этот массив.
[02:16:37.960 --> 02:16:39.960]  А этот забудем.
[02:16:39.960 --> 02:16:41.960]  И так происходит у нас сейчас реаллокация вектора.
[02:16:41.960 --> 02:16:42.960]  Итак, n раз.
[02:16:42.960 --> 02:16:44.960]  На каждую строку вот это происходит.
[02:16:44.960 --> 02:16:46.960]  Чего бы нам не переложить указатели.
[02:16:46.960 --> 02:16:48.960]  А вот не получается.
[02:16:52.960 --> 02:16:54.960]  Решение.
[02:16:54.960 --> 02:17:00.960]  Давайте добавим волшебную функцию, которая называется std move.
[02:17:00.960 --> 02:17:07.960]  Которая делает какую-то магию, после которой все быстро перекладывается.
[02:17:07.960 --> 02:17:08.960]  Значит, смотрите.
[02:17:08.960 --> 02:17:10.960]  Чего?
[02:17:10.960 --> 02:17:16.960]  Решение современное выглядит следующим образом.
[02:17:16.960 --> 02:17:24.960]  Я говорю, tmp вот здесь равно не x, а std move от x.
[02:17:26.960 --> 02:17:30.960]  x равно не y, а std move от y.
[02:17:34.960 --> 02:17:38.960]  Ну и y равно не t, а std move от t.
[02:17:42.960 --> 02:17:43.960]  Создаем.
[02:17:43.960 --> 02:17:47.960]  Но мы не копируем объект полностью.
[02:17:47.960 --> 02:17:52.960]  Вот утверждается, что если написать так, то каким-то магическим образом.
[02:17:52.960 --> 02:17:59.960]  При условии, что тип поддерживает move семантику, что бы это не значило.
[02:17:59.960 --> 02:18:02.960]  Но все стандартные типы таковы.
[02:18:02.960 --> 02:18:07.960]  В общем, если написать так, то каким-то магическим образом.
[02:18:07.960 --> 02:18:10.960]  Для всех стандартных типов вместо того, чтобы копироваться.
[02:18:10.960 --> 02:18:13.960]  Будет происходить перемещение.
[02:18:13.960 --> 02:18:14.960]  Что такое перемещение?
[02:18:14.960 --> 02:18:17.960]  А это как раз вот то, что мы и хотим в случае строк.
[02:18:17.960 --> 02:18:20.960]  Что мы не пересоздаем вот этот вот огромный массив.
[02:18:20.960 --> 02:18:23.960]  А по байтикам просто перекладываем поля и все.
[02:18:23.960 --> 02:18:27.960]  Вот каким-то магическим образом, непонятно каким.
[02:18:27.960 --> 02:18:31.960]  И не будет понятно еще в ближайший час, наверное.
[02:18:31.960 --> 02:18:34.960]  То есть в ближайшую неделю получается.
[02:18:34.960 --> 02:18:39.960]  Сегодня я не успею объяснить, что на самом деле делает move.
[02:18:39.960 --> 02:18:50.960]  Я понимаю, что это звучит довольно настораживающе.
[02:18:50.960 --> 02:18:59.960]  Но, к сожалению, я пока не могу никак лучше объяснить, что там происходит.
[02:18:59.960 --> 02:19:03.960]  Я пока лишь говорю, что у нас есть следующие проблемы.
[02:19:03.960 --> 02:19:05.960]  Я их вам перечислил.
[02:19:05.960 --> 02:19:07.960]  У нас есть общая проблема.
[02:19:07.960 --> 02:19:13.960]  Заключается в том, что иногда, когда объект хотелось бы просто переложить поля в другое место.
[02:19:13.960 --> 02:19:17.960]  Нам приходится копировать целиком, вызывая конструктор копирования.
[02:19:17.960 --> 02:19:23.960]  И для таких случаев стандарт придумал, комитет придумал следующее заклинание.
[02:19:23.960 --> 02:19:26.960]  Вот пока иначе как заклинание я его воспринимать вам не предлагаю.
[02:19:26.960 --> 02:19:30.960]  Мы обязательно разберемся досконально, что происходит на самом глубоком уровне.
[02:19:30.960 --> 02:19:35.960]  Но пока, если я начну сразу говорить все формально, что происходит, вообще будет ничего не понятно.
[02:19:35.960 --> 02:19:41.960]  Поэтому пока мы просто думаем, что это некоторое заклинание, которое чудом вместо того, чтобы копировать, перекладывает поля.
[02:19:46.960 --> 02:19:48.960]  Ну вот здесь он не бесполезен.
[02:19:48.960 --> 02:19:54.960]  Вот в этих ситуациях он действительно будет бесполезен, но это тоже мы пока не понимаем почему.
[02:19:55.960 --> 02:20:05.960]  Но я пока утверждаю, что если написать вот здесь вот move и если написать вот там, где мы перекладываем тоже move,
[02:20:05.960 --> 02:20:11.960]  а не копирование, то чудесным образом вместо копирования будет перекладывание полей просто.
[02:20:11.960 --> 02:20:13.960]  В смысле STD move от ABC?
[02:20:13.960 --> 02:20:20.960]  То есть когда мы вот там в placement new, да, ну STD move от ABC звучит довольно странно.
[02:20:20.960 --> 02:20:26.960]  И ну так все-таки не надо писать, потому что оно и...
[02:20:26.960 --> 02:20:31.960]  Ну там на самом деле vector и так реализован по-умному, что и без STD move оно нормально будет работать.
[02:20:31.960 --> 02:20:34.960]  Просто мы пока по-туковому реализовали.
[02:20:34.960 --> 02:20:39.960]  Да, но если написать STD move, то все равно должно работать.
[02:20:39.960 --> 02:20:44.960]  На самом деле и без него будет работать хорошо, просто потому что vector очень умно реализован.
[02:20:44.960 --> 02:20:46.960]  Но это мы потом поймем как он реализован.
[02:20:46.960 --> 02:20:50.960]  Но STD move действительно здесь можно не писать, это и так будет быстро работать.
[02:20:50.960 --> 02:20:57.960]  STD vector реализован по-умному таким образом, что вот это не приводит ко второму копированию.
[02:20:57.960 --> 02:21:05.960]  Правда, что у нас вот равно, которое слева от STD move, это его часть?
[02:21:05.960 --> 02:21:08.960]  Нет, ну нет, STD move это какая-то волшебная функция.
[02:21:08.960 --> 02:21:16.960]  Она что-то делает странное с объектом, после чего его присваивание работает не как копирование, а как перекладывание полей.
[02:21:16.960 --> 02:21:17.960]  А не слишком долго работает?
[02:21:17.960 --> 02:21:18.960]  Нет.
[02:21:18.960 --> 02:21:24.960]  Это правда, что vector внутри вот этого умного копирования используется STD move?
[02:21:24.960 --> 02:21:27.960]  Ну да, он работает, он использует.
[02:21:27.960 --> 02:21:33.960]  Вот давайте теперь с учетом новых знаний напишем как выглядит реаллокация будет.
[02:21:33.960 --> 02:21:36.960]  У нас раньше было написано примерно следующее.
[02:21:36.960 --> 02:21:59.960]  У нас был написано следующее.
[02:21:59.960 --> 02:22:03.960]  Примерно такое у нас было написано, правда?
[02:22:03.960 --> 02:22:06.960]  Когда мы на новое место кладем объекты старого массива.
[02:22:06.960 --> 02:22:07.960]  Это копирование.
[02:22:07.960 --> 02:22:08.960]  Вот.
[02:22:08.960 --> 02:22:13.960]  Как теперь это написать, чтобы это работало быстро и волшебно?
[02:22:13.960 --> 02:22:22.960]  Не R и T, а STD move от R и T.
[02:22:22.960 --> 02:22:24.960]  Ну, которые поля перекладывают, да, значит.
[02:22:24.960 --> 02:22:29.960]  Вместо того, чтобы создавать T от R и T, теперь мы создаем T.
[02:22:29.960 --> 02:22:31.960]  От STD move от R и T.
[02:22:31.960 --> 02:22:32.960]  Точно так же, как здесь.
[02:22:32.960 --> 02:22:37.960]  Вместо того, чтобы присваивать TMP просто X, мы присваиваем TMP STD move от X.
[02:22:37.960 --> 02:22:50.960]  И каким-то волшебством это работает за от ениса, а не за от N.
[02:22:50.960 --> 02:22:58.960]  Значит, я пока не буду отвечать на этот вопрос.
[02:22:58.960 --> 02:23:11.960]  Да, правда, но я пытаюсь рассказывать это в таком порядке, чтобы правда открывалась вам постепенно.
[02:23:11.960 --> 02:23:21.960]  Если мы попробуем применить STD move к условно нашему написанному в первом семестре стрингу, оно будет нормально работать, просто по-прежнему медленно копироваться.
[02:23:21.960 --> 02:23:32.960]  Да, в вашем первом семестре написанный стринг, к сожалению, не поддерживает действие move правильно, поэтому копироваться оно все равно будет по-прежнему.
[02:23:32.960 --> 02:23:34.960]  Но стандартный контейнер, да.
[02:23:34.960 --> 02:23:38.960]  Получается, он сделает одно конструирование и одно перемещение.
[02:23:38.960 --> 02:23:40.960]  Да.
[02:23:40.960 --> 02:23:45.960]  Так вообще переместили N объекта за от N.
[02:23:45.960 --> 02:23:49.960]  Нет, нет, от N будет замять перемещение одного объекта.
[02:23:49.960 --> 02:23:51.960]  N объекта такая, что от N.
[02:23:51.960 --> 02:23:55.960]  То есть, со своим объектом move не обязательно будет работать быстро?
[02:23:55.960 --> 02:23:59.960]  Я пока утверждаю только про стандартные объекты, про наши классы.
[02:23:59.960 --> 02:24:03.960]  Сейчас мы поговорим, как сделать, чтобы move работал корректно с ними.
[02:24:03.960 --> 02:24:08.960]  Итак, конец первой серии, типа занавеса.
[02:24:08.960 --> 02:24:12.960]  Первое знакомство с move выглядит так.
[02:24:12.960 --> 02:24:20.960]  У нас были такие проблемы, и тут пришла волшебная функция move, которую мы начали писать всегда, когда мы не хотим копирования, а хотим эффективное перемещение.
[02:24:20.960 --> 02:24:31.960]  Каким-то чудом что-то внутри происходит совершенно непонятное, и, значит, для всех стандартных типов оно работает корректно.
[02:24:31.960 --> 02:24:32.960]  Класс.
[02:24:32.960 --> 02:24:35.960]  Мы ничего пока не понимаем, как это работает, но работает.
[02:24:35.960 --> 02:24:37.960]  Конец первой части.
[02:24:37.960 --> 02:24:45.960]  Вот на этом понимание move заканчивается у, не знаю, мне кажется, у...
[02:24:45.960 --> 02:24:46.960]  У нас.
[02:24:46.960 --> 02:24:48.960]  Ну, я не знаю, у вас, да.
[02:24:48.960 --> 02:25:01.960]  Ну, я не буду утверждать насчет прям половины, но мне кажется, ну, где-нибудь треть всех людей, которые пишут на C++, примерно этим пониманием и ограничиваются.
[02:25:01.960 --> 02:25:04.960]  В принципе, его достаточно, чтобы что-то писать.
[02:25:04.960 --> 02:25:08.960]  То есть к функции move можно относиться как к черному ящику.
[02:25:08.960 --> 02:25:14.960]  Она просто каким-то чудом заставляет объект эффективно перекладывать поля вместо того, чтобы копировать.
[02:25:14.960 --> 02:25:15.960]  Вот.
[02:25:15.960 --> 02:25:16.960]  Вы можете...
[02:25:16.960 --> 02:25:20.960]  Нет, только к стандартной.
[02:25:20.960 --> 02:25:22.960]  Ваши нет.
[02:25:22.960 --> 02:25:23.960]  Вот.
[02:25:23.960 --> 02:25:28.960]  Вот.
[02:25:28.960 --> 02:25:30.960]  Вот.
[02:25:30.960 --> 02:25:32.960]  Часть вторая.
[02:25:32.960 --> 02:25:37.960]  Значит, серия номер два.
[02:25:37.960 --> 02:25:44.960]  Поддержка move для своих объектов.
[02:25:44.960 --> 02:25:47.960]  Да, да, уже, уже.
[02:25:47.960 --> 02:25:48.960]  Да, да.
[02:25:48.960 --> 02:25:49.960]  Прямо сейчас.
[02:25:49.960 --> 02:25:56.960]  Ну, можно выключить свет, похлопать и включить свет снова.
[02:25:56.960 --> 02:25:58.960]  Спасибо, спасибо.
[02:25:58.960 --> 02:26:00.960]  Отлично, отлично.
[02:26:00.960 --> 02:26:02.960]  Замечательно, замечательно.
[02:26:02.960 --> 02:26:04.960]  Если что, я шутил, это было не обязательно.
[02:26:04.960 --> 02:26:05.960]  Ну ладно.
[02:26:05.960 --> 02:26:10.960]  Так, значит, теперь поддержка move для своих объектов.
[02:26:10.960 --> 02:26:19.960]  Окей, мы поняли, что функция с demove это какая-то волшебная функция, которая для всех стандартных объектов заставляет их эффективно копироваться,
[02:26:19.960 --> 02:26:25.960]  эффективно перемещаться вместо копирования, но для наших объектов пока это не работает.
[02:26:25.960 --> 02:26:29.960]  А как сделать, чтобы для наших объектов это тоже работало?
[02:26:29.960 --> 02:26:41.960]  А нам нужно для этого у своих объектов явно определить специальные методы, которые будут говорить, что им делать, если от них вызывается вот это вот.
[02:26:41.960 --> 02:27:05.960]  То есть, когда мы говорим, да, название параграфа, значит, поддержка move в семантике, support for custom types.
[02:27:05.960 --> 02:27:16.960]  Значит, как научить ваши классы тоже правильно работать в таких ситуациях с move?
[02:27:16.960 --> 02:27:24.960]  На самом деле нам надо определить две новых операции для своего типа, чтобы для него это работало.
[02:27:24.960 --> 02:27:26.960]  А какие это операции?
[02:27:26.960 --> 02:27:31.960]  Это так называемые move-конструкторы, move-оператор присваивания.
[02:27:31.960 --> 02:27:41.960]  Мы их обе использовали. Что происходит, когда я говорю t, b равно std move от a?
[02:27:41.960 --> 02:27:53.960]  Ну, у меня есть... я создаю b не из a, а из чего-то, что получилось после std move от a.
[02:27:53.960 --> 02:28:04.960]  И мне надо вот эту операцию для своего типа отдельно определить. Пока она отдельно для моего типа не определена, она будет работать как обычное копирование.
[02:28:04.960 --> 02:28:11.960]  Если я для своего типа эту операцию определю специальным образом, то вот она так и будет работать, как я напишу.
[02:28:11.960 --> 02:28:14.960]  Ну, понятно, что для всех стандартных типов они определены правильно.
[02:28:14.960 --> 02:28:20.960]  Вот это move-конструктор. Вот если я написал t, b равно a, это был бы копий-конструктор.
[02:28:20.960 --> 02:28:25.960]  А вот если я написал t, b равно std move от a, это я обратился к move-конструктору.
[02:28:25.960 --> 02:28:30.960]  И мне надо его определить. А дальше я могу написать, допустим, a равно std move от b.
[02:28:30.960 --> 02:28:38.960]  Ну, это какая-то бессмысленная деятельность, но вот теперь я вызвал move-оператор присваивания.
[02:28:38.960 --> 02:28:42.960]  То есть раньше у меня был обычный оператор присваивания, когда я говорил a равно b.
[02:28:42.960 --> 02:28:45.960]  Это копирующий оператор присваивания.
[02:28:45.960 --> 02:28:55.960]  А если я присваиваю не просто b, а std move от b, то будет пытаться вызваться move-овающий оператор присваивания, что является отдельной операцией.
[02:28:55.960 --> 02:28:59.960]  Move случайно не портит объект, от которого мы его выбрали?
[02:28:59.960 --> 02:29:07.960]  Это пока, значит, ты забегаешь вперед, ответ нет, но подробности будут позже.
[02:29:07.960 --> 02:29:09.960]  Что?
[02:29:09.960 --> 02:29:18.960]  Так вот, нам нужно определить две новых операции для своего класса, чтобы он поддерживал move-семантику.
[02:29:18.960 --> 02:29:22.960]  Вот умение поддерживать такие операции и называется поддержкой move-семантики.
[02:29:22.960 --> 02:29:31.960]  Так, подожди.
[02:29:31.960 --> 02:29:33.960]  Давай без забегания вперед, пожалуйста.
[02:29:33.960 --> 02:29:39.960]  Тут и так совершенно очень трудно не сбиться и не запутать всех.
[02:29:39.960 --> 02:29:44.960]  Я из всех сил стараюсь не говорить ничего лишнего пока.
[02:29:44.960 --> 02:29:50.960]  Пока мы только понимаем, что вот есть такие две непонятные операции, нам их надо определить для своих типов.
[02:29:50.960 --> 02:29:54.960]  И есть непонятная функция move вообще, когда вы совершенно не поняли, что делать.
[02:29:54.960 --> 02:30:04.960]  Хорошо, давайте на примере string я напишу, как это должно выглядеть.
[02:30:04.960 --> 02:30:11.960]  Смотрите, вы же помните, как конструктор копирования и оператор присваивания у string выглядит, да?
[02:30:11.960 --> 02:30:18.960]  Давайте я вам для примера напишу, как должен выглядеть конструктор перемещения от string.
[02:30:18.960 --> 02:30:25.960]  То есть как должен выглядеть этот метод у string, чтобы при перемещении все корректно работало.
[02:30:25.960 --> 02:30:33.960]  Давайте вспомним, что у меня там есть char звездочка r или str.
[02:30:33.960 --> 02:30:35.960]  У меня поля string какие.
[02:30:35.960 --> 02:30:40.960]  Там еще есть allocator, но давайте пока без него, и так тошно.
[02:30:40.960 --> 02:30:44.960]  Но вам, конечно, это все нужно будет с allocator поддерживать.
[02:30:44.960 --> 02:30:48.960]  Size tss и size tcap, как обычно.
[02:30:48.960 --> 02:30:51.960]  Три поля.
[02:30:51.960 --> 02:30:59.960]  Как будет выглядеть конструктор перемещения для string?
[02:30:59.960 --> 02:31:03.960]  Как и любой конструктор, он начинает с слова string.
[02:31:03.960 --> 02:31:08.960]  А вот дальше еще одно чудо-юдо, которое совершенно непонятно, что означает.
[02:31:08.960 --> 02:31:11.960]  Но надо это просто принять и смириться пока.
[02:31:11.960 --> 02:31:14.960]  Значит, тип принимаемого аргумента будет таким.
[02:31:14.960 --> 02:31:22.960]  String с двумя амперсандами.
[02:31:22.960 --> 02:31:28.960]  Значит, это такой тип, новый.
[02:31:28.960 --> 02:31:34.960]  Ссылок на ссылку не бывает, но это не ссылка на ссылку.
[02:31:34.960 --> 02:31:40.960]  Это в общем, это нечто, с чем надо пока просто смириться.
[02:31:40.960 --> 02:31:44.960]  Мы уже смирились с тем, что есть волшебная функция с дому, в которой непонятно, что делает.
[02:31:44.960 --> 02:31:48.960]  Теперь нужно смириться еще кое с чем.
[02:31:48.960 --> 02:31:58.960]  Можно так писать много, когда, но пока мы...
[02:31:58.960 --> 02:32:05.960]  Воспринимайте это просто как часть синтаксиса объявления конструктора и считайте, что пока больше нигде так писать нельзя.
[02:32:05.960 --> 02:32:13.960]  В общем, я ухожу от ответа на эти вопросы.
[02:32:13.960 --> 02:32:20.960]  Я просто говорю, что чтобы определить для своего класса мувающий конструктор, нужно написать вот такую очень странную вещь.
[02:32:20.960 --> 02:32:24.960]  Ничего не понятно.
[02:32:24.960 --> 02:32:27.960]  Значит, вот непонятно, что это за тип.
[02:32:27.960 --> 02:32:30.960]  Это особый вид ссылки, давайте так скажем.
[02:32:30.960 --> 02:32:36.960]  Это особый вид ссылки на стринг, который непонятно, чем отличается от обычной ссылки на стринг.
[02:32:36.960 --> 02:32:44.960]  Непонятно, где еще это можно использовать, но я вам гарантирую, что, по крайней мере, вот эту задачу мы решим таким способом.
[02:32:44.960 --> 02:32:48.960]  Да, да.
[02:32:48.960 --> 02:32:50.960]  Ну хорошо, так уж и быть скажу.
[02:32:50.960 --> 02:32:53.960]  Это называется R-value ссылка на стринг.
[02:32:53.960 --> 02:32:57.960]  R-value defines это единый термин.
[02:32:57.960 --> 02:33:05.960]  R-value defines reference, ну в смысле это единый термин, его нельзя понимать, как R-value отдельно, reference отдельно.
[02:33:05.960 --> 02:33:08.960]  Так вот.
[02:33:08.960 --> 02:33:11.960]  Давайте поймем, как должен выглядеть такой конструктор.
[02:33:11.960 --> 02:33:16.960]  Ну как и любой конструктор, список инициализации, что он должен сделать?
[02:33:16.960 --> 02:33:22.960]  Вот сейчас вопрос на понимание, что надо написать в таком конструкторе.
[02:33:22.960 --> 02:33:28.960]  Надо сказать, что str это просто s.str.
[02:33:28.960 --> 02:33:30.960]  Дальше.
[02:33:30.960 --> 02:33:34.960]  Cz это s.cz.
[02:33:34.960 --> 02:33:39.960]  Cap это s.cap.
[02:33:39.960 --> 02:33:45.960]  Тело конструктора, что-нибудь надо писать в нем или нет?
[02:33:45.960 --> 02:33:48.960]  Ну вообще кажется стоит.
[02:33:48.960 --> 02:33:50.960]  Что?
[02:33:50.960 --> 02:33:53.960]  Типа как-нибудь...
[02:33:53.960 --> 02:33:58.960]  Короче, у нас по идее сейчас появилась очень большая проблема, что у нас две разные строки.
[02:33:58.960 --> 02:34:00.960]  Конечно.
[02:34:00.960 --> 02:34:04.960]  Нам обязательно надо сделать s.str равно nullptr, как минимум.
[02:34:10.960 --> 02:34:14.960]  Как ты в конструктор передашь ссылку на себя?
[02:34:14.960 --> 02:34:16.960]  Ладно, другой вопрос.
[02:34:16.960 --> 02:34:21.960]  А вот зря, ты не знаешь, вообще-то это можно сделать.
[02:34:21.960 --> 02:34:27.960]  Нет, на самом деле можно написать ta равно stdmove от a.
[02:34:27.960 --> 02:34:30.960]  Этот случай считается кринж, и мы его не разбираем.
[02:34:30.960 --> 02:34:33.960]  Ну просто не принято так делать.
[02:34:33.960 --> 02:34:35.960]  А если случайно так получилось?
[02:34:35.960 --> 02:34:37.960]  Нет, мы с вами говорили.
[02:34:37.960 --> 02:34:41.960]  ta равно a вызывает конструктор копирования от себя на неиннициализированной памяти.
[02:34:41.960 --> 02:34:46.960]  Это просто убе.
[02:34:46.960 --> 02:34:49.960]  Короче, в конструкторе такого не бывает.
[02:34:49.960 --> 02:34:54.960]  В операторе присваивания мы разберем этот случай.
[02:34:55.960 --> 02:35:00.960]  Понятно ли, почему вот это обязательно нужно написать?
[02:35:00.960 --> 02:35:02.960]  Иначе будет беда большая.
[02:35:02.960 --> 02:35:07.960]  s.str обязательно надо сделать nullptr, иначе все будет неправильно работать.
[02:35:07.960 --> 02:35:11.960]  Кому, кто понимает, почему так надо написать?
[02:35:11.960 --> 02:35:15.960]  Мы испортили англичан.
[02:35:15.960 --> 02:35:17.960]  Правильно, да.
[02:35:17.960 --> 02:35:19.960]  Когда мы присвоили строку...
[02:35:19.960 --> 02:35:23.960]  Естественно, мы когда сделали вот такое,
[02:35:23.960 --> 02:35:27.960]  после этого a испортилась, там стало nullptr.
[02:35:29.960 --> 02:35:32.960]  Нет, я говорил, что функция stdmove не портит объект.
[02:35:32.960 --> 02:35:35.960]  Но я не говорил, что присваивание не портит объект.
[02:35:35.960 --> 02:35:37.960]  Это разные вещи.
[02:35:41.960 --> 02:35:42.960]  Это не все.
[02:35:42.960 --> 02:35:45.960]  Надо занулить поля еще у s.
[02:35:48.960 --> 02:35:52.960]  Разве реклама не честна, что будет лежать после?
[02:35:52.960 --> 02:35:55.960]  Нам нужно оставить объект s в корректном состоянии.
[02:35:55.960 --> 02:35:57.960]  То есть соблюсти все инварианты.
[02:35:57.960 --> 02:35:59.960]  Мы ему сделали pointer nullptr.
[02:35:59.960 --> 02:36:03.960]  То есть после того, как мы так сделали, объекта как бы становится пустым.
[02:36:03.960 --> 02:36:08.960]  Мы сделали ему nullptr указатель и занулили поля.
[02:36:10.960 --> 02:36:16.960]  Мы должны после этой операции оставить объект s в корректном состоянии, но пустым.
[02:36:16.960 --> 02:36:18.960]  Вот что должен делать move-конструктор.
[02:36:23.960 --> 02:36:28.960]  Если мы замуваем вектор, то тот вектор, из которого move-нули, будет пустым.
[02:36:28.960 --> 02:36:30.960]  Мы заберем просто указательный динамический массив,
[02:36:30.960 --> 02:36:33.960]  а ему оставим nulli в полях и nullptr.
[02:36:33.960 --> 02:36:38.960]  Да, после move-а объект должен остаться в корректном состоянии, но пустым.
[02:36:38.960 --> 02:36:43.960]  После не самого move-а, а после вот такого конструктора от него.
[02:36:47.960 --> 02:36:48.960]  Чего?
[02:36:48.960 --> 02:36:51.960]  Мы прямо сейчас поменяли rvalue.
[02:36:51.960 --> 02:36:53.960]  Да?
[02:36:53.960 --> 02:36:57.960]  Давай ты... вопрос некорректен.
[02:36:57.960 --> 02:37:02.960]  rvalue... я напоминаю, что value это термин относящийся к expression.
[02:37:02.960 --> 02:37:04.960]  Я не знаю, что такое поменять expression.
[02:37:04.960 --> 02:37:06.960]  Value бывают expression, а не объекты.
[02:37:06.960 --> 02:37:10.960]  Давай ты уточнишь свой вопрос, когда у нас пара закончится.
[02:37:10.960 --> 02:37:14.960]  Я сейчас покажу, как написать оператор присваивания, и на этом мы закончим на сегодня.
[02:37:14.960 --> 02:37:17.960]  Давайте напишем напоследок оператор присваивания.
[02:37:17.960 --> 02:37:19.960]  move еще оператор присваивания.
[02:37:19.960 --> 02:37:20.960]  Что он должен делать?
[02:37:20.960 --> 02:37:22.960]  Ну, я думаю, вот здесь мне места хватит.
[02:37:22.960 --> 02:37:31.960]  Значит, оператор присваивания должен возвращать ссылку на string, обычную на сей раз.
[02:37:31.960 --> 02:37:34.960]  Вот, оператор равно...
[02:37:37.960 --> 02:37:40.960]  И принимает он опять такую же странную вещь.
[02:37:40.960 --> 02:37:42.960]  String двойной амперсант.
[02:37:42.960 --> 02:37:44.960]  S.
[02:37:44.960 --> 02:37:47.960]  Вот, что будет делать move еще оператор присваивания?
[02:37:50.960 --> 02:37:52.960]  Вот. Ну...
[02:37:52.960 --> 02:37:56.960]  Ну, в принципе, можно сделать copy and swap, только в данном случае это будет move and swap.
[02:37:59.960 --> 02:38:00.960]  Ну, можно сказать t...
[02:38:00.960 --> 02:38:01.960]  Ну, помните, у нас было copy and swap?
[02:38:01.960 --> 02:38:07.960]  Можно сказать t-копия равно std move от s.
[02:38:12.960 --> 02:38:13.960]  Вот.
[02:38:23.960 --> 02:38:32.960]  Потом мы делаем swap полей себя с копии, и все на этом заканчивается.
[02:38:36.960 --> 02:38:39.960]  А почему мы не можем сразу с копии?
[02:38:39.960 --> 02:38:40.960]  Или у нас есть...
[02:38:40.960 --> 02:38:46.960]  Типа, у нас же тогда, ну, останется s в каком-то корректном состоянии.
[02:38:46.960 --> 02:38:48.960]  Сейчас, сейчас, сейчас. Что вы предлагаете сделать?
[02:38:48.960 --> 02:38:50.960]  Сразу просто свопаться с полями s.
[02:38:50.960 --> 02:38:51.960]  Своп с s?
[02:38:51.960 --> 02:38:52.960]  Да.
[02:38:52.960 --> 02:38:53.960]  Так s не уничтожится.
[02:38:53.960 --> 02:38:57.960]  Мне нужно, чтобы это был локальный объект, у которого бы вызвался деструктор по окончании.
[02:38:57.960 --> 02:39:02.960]  Надо, чтобы мои поля уничтожились, в том числе вызвался delete квадратный скопчик для моего массива.
[02:39:02.960 --> 02:39:06.960]  То есть мы не можем эти поля оставить в другом объекте, типа...
[02:39:06.960 --> 02:39:10.960]  Мне надо, чтобы s пустым объектом стал после того, как я сделал move от них.
[02:39:10.960 --> 02:39:14.960]  Он не просто в валидном состоянии должен быть, он должен быть именно как был пустым.
[02:39:14.960 --> 02:39:18.960]  Ну, формально вы можете оставить его в непустом состоянии, но это очень странное поведение.
[02:39:18.960 --> 02:39:21.960]  Кажется, я не знаю, вас проклянут.
[02:39:21.960 --> 02:39:25.960]  Кажется, стандарт вам не запрещает так делать, но...
[02:39:25.960 --> 02:39:29.960]  Просто здравый смысл запрещает вам оставлять объект в непустом состоянии.
[02:39:29.960 --> 02:39:32.960]  Если я сейчас ничего не понял, что делать?
[02:39:33.960 --> 02:39:35.960]  Я же говорил, что это нормально.
[02:39:35.960 --> 02:39:38.960]  Нет, давай ты можешь что-нибудь спросить.
[02:39:38.960 --> 02:39:40.960]  Сейчас, подожди, чего?
[02:39:40.960 --> 02:39:42.960]  Ой, string, конечно.
[02:39:46.960 --> 02:39:50.960]  Так, давайте я еще раз на это посмотрю, чтобы, на всякий случай...
[02:39:50.960 --> 02:39:58.960]  Так, значит, ну если бы это был копирующий оператор писания, то мы бы просто написали string copy равно s, swap copy и все.
[02:39:58.960 --> 02:40:00.960]  Правильно?
[02:40:00.960 --> 02:40:04.960]  Swap это метод, который мы уже давно реализовывали еще в первом семестве.
[02:40:04.960 --> 02:40:06.960]  Просто swap-ает наши поля с полями вот этого.
[02:40:06.960 --> 02:40:08.960]  В том числе указатель swap-ает.
[02:40:13.960 --> 02:40:18.960]  Значит, а теперь мы просто move-нули, то есть мы вызвали на самом деле вот этот конструктор,
[02:40:18.960 --> 02:40:21.960]  занулили вот этому челику поля,
[02:40:21.960 --> 02:40:25.960]  этот челик теперь стал как этот челик, и мы swap-нулись с ним.
[02:40:25.960 --> 02:40:27.960]  Теперь мы стали как этот челик,
[02:40:27.960 --> 02:40:33.960]  а наши поля теперь в копии, но копия локальная, поэтому у нее вызывается деструктор в конце тела,
[02:40:33.960 --> 02:40:35.960]  и она уничтожается.
[02:40:35.960 --> 02:40:37.960]  Корректно.
[02:40:43.960 --> 02:40:49.960]  Сейчас, что получается, что мы приравнялись к какой-то другой строке
[02:40:49.960 --> 02:40:51.960]  и сломали этим самым эту строку или как?
[02:40:51.960 --> 02:40:53.960]  Нет.
[02:40:53.960 --> 02:40:55.960]  Эту строку мы занулили.
[02:40:55.960 --> 02:41:01.960]  Не, вот как извне для нас выглядит, что у нас там была строка, а мы сказали string b равно...
[02:41:01.960 --> 02:41:03.960]  Я сказал b равно std move от a.
[02:41:03.960 --> 02:41:06.960]  Конечно, мы занулили строку a.
[02:41:06.960 --> 02:41:10.960]  После такой операции строка a становится пустой.
[02:41:10.960 --> 02:41:12.960]  Не, а почему b равно std move?
[02:41:12.960 --> 02:41:16.960]  Ну, это присваивание, мы вот именно это сейчас реализовали, как работает присваивание.
[02:41:16.960 --> 02:41:18.960]  Ага.
[02:41:18.960 --> 02:41:20.960]  Еще раз, зачем собственно?
[02:41:20.960 --> 02:41:21.960]  Так понятно.
[02:41:21.960 --> 02:41:23.960]  Ну, это идиома copy-and-swap.
[02:41:26.960 --> 02:41:29.960]  То есть это оператор равно именно через move?
[02:41:29.960 --> 02:41:31.960]  Это move-ующий оператор присваивания.
[02:41:31.960 --> 02:41:34.960]  Он отличается от копирующего просто тем, что здесь move написано.
[02:41:34.960 --> 02:41:37.960]  Копирующий был бы просто string copy равно s swap copy.
[02:41:42.960 --> 02:41:43.960]  Что такое std swap?
[02:41:43.960 --> 02:41:44.960]  Ну, ты мог бы.
[02:41:44.960 --> 02:41:46.960]  Просто std swap.
[02:41:46.960 --> 02:41:49.960]  Он сам себе содержит move, и это получалось бы в бесконечной рекурсии,
[02:41:49.960 --> 02:41:54.960]  потому что он бы снова вызывал соответствующий конструктор или оператор присваивания.
[02:41:54.960 --> 02:41:57.960]  Стд swap здесь ты не можешь вызвать, это из копии,
[02:41:57.960 --> 02:42:02.960]  потому что std swap в себе содержит t, tnp равно std move от x,
[02:42:02.960 --> 02:42:04.960]  а это значит, ты бы пришел в этот конструктор,
[02:42:04.960 --> 02:42:07.960]  а потом ты бы опять пришел в этот оператор присваивания.
[02:42:07.960 --> 02:42:09.960]  А в своем swap'е ты просто swap'ешь поля.
[02:42:09.960 --> 02:42:10.960]  Да.
[02:42:10.960 --> 02:42:12.960]  Ну, Лоберто, наверное, надо написать еще return this.
[02:42:12.960 --> 02:42:14.960]  Да, да, да, да, да, да, да, конечно.
[02:42:14.960 --> 02:42:16.960]  Нам точно-то надо написать std move?
[02:42:16.960 --> 02:42:18.960]  Вот здесь?
[02:42:18.960 --> 02:42:20.960]  Ну, у нас же и так рвались, сука, передается.
[02:42:20.960 --> 02:42:21.960]  Так.
[02:42:21.960 --> 02:42:24.960]  Нам надо вызвать move конструктор.
[02:42:24.960 --> 02:42:28.960]  Чтобы вызвать move конструктор, надо написать вот такое заклинание.
[02:42:30.960 --> 02:42:33.960]  Вот это заклинание, и вот это заклинание никак не связано.
[02:42:33.960 --> 02:42:35.960]  Слово rvalue, не смотрите на него.
[02:42:38.960 --> 02:42:43.960]  Вы начинаете делать то, что ни в коем случае нельзя делать,
[02:42:43.960 --> 02:42:50.960]  пытаться из каких-то обрывков сказанного вывести то, что я не говорил.
[02:42:50.960 --> 02:42:53.960]  Это ошибка, нельзя так делать, короче.
[02:42:53.960 --> 02:42:57.960]  Пока лишь мы знаем, что есть вот такое заклинание для вызвания move конструктора,
[02:42:57.960 --> 02:43:01.960]  вот такое заклинание для написания move конструктора, и больше ничего.
[02:43:01.960 --> 02:43:04.960]  То есть из того, что мы ему сразу передаем rvalue suit,
[02:43:04.960 --> 02:43:06.960]  не следует, что он вызовет?
[02:43:06.960 --> 02:43:08.960]  Нет, не следует.
[02:43:08.960 --> 02:43:11.960]  Если написать s, не будет move конструктора.
[02:43:11.960 --> 02:43:13.960]  Вы забегаете вперед.
[02:43:13.960 --> 02:43:15.960]  Пока мы знаем только вот эти два заклинания.
[02:43:15.960 --> 02:43:18.960]  s это не rvalue, если вам так хочется знать.
[02:43:18.960 --> 02:43:21.960]  То, что это rvalue suit, не означает, что это rvalue.
[02:43:21.960 --> 02:43:26.960]  Не пытайтесь удивить смысл, которого там нет.
[02:43:26.960 --> 02:43:28.960]  Не думайте пока об этом.
[02:43:28.960 --> 02:43:30.960]  Мы пока знаем только два заклинания, больше ничего.
[02:43:30.960 --> 02:43:36.960]  Мы вызываем move оператор присваивания.
[02:43:36.960 --> 02:43:40.960]  За счет того, что мы пишем std move, мы попадаем в эту версию.
[02:43:40.960 --> 02:43:42.960]  И в ней мы опять вызываем std move.
[02:43:42.960 --> 02:43:46.960]  И в ней мы опять вызываем std move, чтобы вот здесь вызвать move конструктор.
[02:43:46.960 --> 02:43:49.960]  Если мы напишем std move, мы вызываем не move конструктор,
[02:43:49.960 --> 02:43:51.960]  мы вызываем copy конструктор.
[02:43:51.960 --> 02:43:54.960]  Чтобы вызвать move конструктор, нужно вот такое заклинание.
[02:43:54.960 --> 02:43:58.960]  Мы зайдем вот сюда.
[02:43:58.960 --> 02:44:03.960]  Это оператор присваивания, а здесь мы зайдем в move конструктор.
[02:44:03.960 --> 02:44:07.960]  Это оператор присваивания, а там move конструктор?
[02:44:07.960 --> 02:44:09.960]  Да.
[02:44:09.960 --> 02:44:11.960]  std move это не функция.
[02:44:11.960 --> 02:44:13.960]  std move это функция.
[02:44:14.960 --> 02:44:19.960]  Нет, это какая-то волшебная функция, которая что-то необычное делает с объектом.
[02:44:19.960 --> 02:44:21.960]  Мы не понимаем, что.
[02:44:21.960 --> 02:44:25.960]  Но в результате после ее вызова мы попадаем вот сюда.
[02:44:25.960 --> 02:44:27.960]  Ну давай.
[02:44:27.960 --> 02:44:29.960]  Я просто думаю, что надо людей отпустить.
[02:44:29.960 --> 02:44:31.960]  Давайте я скажу, что на сегодня все.
[02:44:31.960 --> 02:44:33.960]  И...
[02:44:33.960 --> 02:44:35.960]  Чего?
[02:44:35.960 --> 02:44:37.960]  Вторая серия не совсем закончилась, потому что
[02:44:37.960 --> 02:44:39.960]  мне нужно еще сформулировать правила пяти.
[02:44:39.960 --> 02:44:41.960]  Но я сформулирую в следующий раз.
[02:44:41.960 --> 02:44:43.960]  Вторая еще не закончена пока серия.
[02:44:43.960 --> 02:44:45.960]  Можно самим реализовать?
[02:44:45.960 --> 02:44:47.960]  Да, мы это сделаем обязательно в следующий раз.
[02:44:47.960 --> 02:44:49.960]  Функция move реализуется в две строчки.
[02:44:49.960 --> 02:44:53.960]  Но как она реализуется мы узнаем в следующей серии.
