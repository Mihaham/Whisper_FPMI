[00:00.000 --> 00:12.480]  Я две строчки буквально пропишу про домашки, да, немножко информации про домашки. Во-первых,
[00:12.480 --> 00:21.520]  многие из вас... Пальцы оледенели, писать не могу. Вместо вот такого, которое я показывал на парах,
[00:21.520 --> 00:27.600]  и вот здесь всякие вспомогательные хелперы, некоторые из вас вот так вот делали. Ну,
[00:27.600 --> 00:34.160]  почему некоторые? Каждый второй. Так вот, вот это и вот это принципиально разные конструкции,
[00:34.160 --> 00:39.600]  которые не имеют ничего общего. Вот вам так кажется, что это какое-то лишнее, зачем здесь имя,
[00:39.600 --> 00:47.360]  нам оно не нужно, напишем просто namespace. Вот это очень похожие по тексту конструкции,
[00:47.360 --> 00:53.080]  которые значат тем не менее абсолютно разные вещи. Вот это, это просто обычный namespace. Зачем мы
[00:53.080 --> 00:59.960]  его пишем? По сравнению с... Какая-то вот метафункция у нас есть, да, но мы ее реализовать
[00:59.960 --> 01:06.280]  просто так в одну строчку не можем, поэтому делаем какой-то метафунк-хелпер. Ну, там в
[01:06.280 --> 01:12.320]  тайп-листах такое было, даже в слайсе, везде. Ну, повсюду нужны какие-то хелперы. Ну, как-то в
[01:12.320 --> 01:17.320]  нешаблонном программировании такие хелперы из хедеров убирают, в cpp-шник запрятывают или в
[01:17.320 --> 01:22.600]  приват какой-нибудь, в оп, всякие детали инклементации. Когда у нас метапрога, мы вот лучше этого
[01:22.600 --> 01:27.400]  ничего придумать не можем. Зачем вообще что-то придумывать и не оставить просто вот так вот хелпера?
[01:27.400 --> 01:32.440]  А тем, что я теперь... Ну, вот, предположим, это хедер какой-то был, его кто-то заинклюдил из
[01:32.440 --> 01:40.880]  ваших пользователей, начал писать метафунк и нет сеггестшенов, потому что ну а зачем? Черт,
[01:40.880 --> 01:45.280]  давайте я сейчас быстро все это скопипасчу в какую-нибудь...
[01:45.280 --> 01:55.000]  Секундочку.
[01:55.000 --> 02:03.680]  Вот здесь будем писать.
[02:03.680 --> 02:08.880]  Все закроем.
[02:08.880 --> 02:24.600]  Вот, вот я так пишу WDEшки свои, и мне первым высвечивают метафунк. Я нажимаю Enter и я доволен.
[02:24.600 --> 02:35.280]  А если я сделаю вот так, то мне высвечивают и то и другое, и более того, в зависимости от ситуации
[02:35.280 --> 02:40.520]  имен, может так получиться, что первым хелпер покажут. Вы нажмете Enter и будете недовольны.
[02:40.520 --> 02:51.960]  Конфликт имен тоже можно, между разными. Вот там L, H, I.
[02:51.960 --> 02:58.720]  Нет. Ну, в смысле, это большая проблема, потому что это замедляет написание кода. Вот так я там
[02:58.720 --> 03:04.880]  какую-то букву P написал и просто так отсортировалось по алфавиту, что первым хелпер идет. Ну и это
[03:04.880 --> 03:10.800]  неудобно просто. Если эта библиотека используется типа во всей кодовой базе, все типа разработчики
[03:10.800 --> 03:16.560]  там 100 человек используют, то каждый из них потратит там каждый день по несколько секунд на
[03:16.560 --> 03:22.320]  то, чтобы, ой, не то написал, стереть, обратно написать. Если все это перемножите, то приличное
[03:22.320 --> 03:28.400]  время не потрачено впустую. Кто вам мешал написать здесь детейл и не тратить это время за зря. Вот,
[03:28.400 --> 03:34.560]  а теперь к тому, что, в принципе, вот такая конструкция делает. Она делает очень смешную вещь.
[03:34.560 --> 03:44.320]  Ну, для классов ничего, а вот для функций она помещает их статиком, автоматом. То есть,
[03:44.320 --> 03:53.200]  ну, вот такая конструкция, это то же самое, что и вот такая конструкция. Вот эти foo и bar,
[03:53.200 --> 04:01.480]  они обе static. То есть, ну, вот такая конструкция с минимальным namespace, это просто способ пометить
[04:01.480 --> 04:10.760]  кучу функций разом как static. Вот это единственное, зачем языке эта конструкция нужна. Ну, если вы
[04:10.760 --> 04:18.000]  там на Sharpe на джаве писали, то вы видели там постоянные вот эти вот public static int foo, public
[04:18.000 --> 04:24.320]  static int bar, public. Ну, каждый раз public static писать. Вот мы типа оптимизируем, да? Нас public
[04:24.320 --> 04:31.080]  dot один раз написал, все довольны, очень удобно. Это немножко сарказм, если что. Так же и здесь
[04:31.080 --> 04:36.640]  сделали, что типа ой, static много раз писать так лень, давайте просто массово пометим.
[04:36.640 --> 04:56.280]  Ну, кажется, оно еще и спасает от конфликта имен, действительно. То есть, если вы хотели
[04:56.280 --> 05:02.840]  чисто конфликта имена сбежать, вот тут такой код, он не конфликтует, кажется, что. Вроде бы да.
[05:02.840 --> 05:10.360]  Потому что там есть как бы реальное имя на namespace, какое-то фактически, оно просто генерируется.
[05:10.360 --> 05:15.560]  Ну вот, да-да-да, генерируется-то, генерируется. То есть, когда вы так пишете это как анонимная
[05:15.560 --> 05:20.720]  функция, она же лямбда, у вас как бы генерируется какое-то имя. Но когда вы позвать такую функцию,
[05:20.720 --> 05:26.080]  захотите, где есть конфликт, у вас все равно будет амбигиус, как мы видим. И то, и другое
[05:26.080 --> 05:31.080]  подходит. То есть, как бы это разные функции, но именно они у них одинаковые, и мы не можем вызвать
[05:31.080 --> 05:38.360]  ни одну из них. Ну вот непонятно, зачем, в общем, так делать. А в header это еще и вредно. Кто нам
[05:38.360 --> 05:46.640]  напомнит, почему в header не стоит статические функции писать? Потому что они размножатся. Да, static
[05:46.640 --> 05:54.640]  значит, в каждом cpp-шнике своя функция отдельна. Вот это вот, фу, она будет новая, своя, разная,
[05:54.640 --> 05:59.360]  скопипасченный ассемблерный код в каждый cpp-шник, в который вы заинклюидите этот header.
[05:59.360 --> 06:06.280]  Ну и если вы через namespace анонимный пометили все как static, то у вас все функции в вашем header,
[06:06.280 --> 06:12.160]  вот эти вспомогательные, они будут копипаститься в каждый translation unit, раздувая размер вашего
[06:12.160 --> 06:19.320]  бинаря. Зачем? Ну то есть, вот эта вот конструкция в header никогда не нужна. Это вот железно,
[06:19.320 --> 06:25.400]  абсолютно никогда. А в cpp-шнике я предчитаю ее тоже не использовать. Лучше явно напишите,
[06:25.400 --> 06:33.680]  что статик. Сейчас, Ром, мне кажется, то, что написал с фу внутри bar, это ambiguous call
[06:33.680 --> 06:41.920]  внутри данного namespace, но это же не совсем ODR. Нет, ODR здесь нету. Ну вот мы можем от ODR как
[06:41.920 --> 06:51.600]  раз спастись, если фу это, не знаю. Да, да. Кто-нибудь понимает, кроме Аркадия, о чем речь? Что такое ODR?
[06:51.600 --> 06:58.400]  В чем проблема? One-definition rule. Помним, да? Вот в плюсах всегда есть какие-то хитрые способы нарушить
[06:58.400 --> 07:05.680]  это one-definition rule. Сделать несколько definition в одной и той же функции и сделать уб. То есть,
[07:05.680 --> 07:12.720]  ну вы зовете функцию и не знаете, какая из них позовется. Ну, вот это вот, анонимные namespace,
[07:12.720 --> 07:18.360]  они от нарушения ODR спасают, потому что вот это фу и вот это фу, это автоматом разные имена,
[07:18.360 --> 07:24.360]  разные функции. Ну, namespace вот этого анонимного, какое-то имя сгенерируется, типа вот что-нибудь такое,
[07:24.360 --> 07:32.640]  и как бы ODR нет. Но я не знаю, в какой ситуации вам захочется именно так спасаться от каких-то
[07:32.640 --> 07:39.000]  нарушений ODR, а не просто написать нормальный код. Я что-то помню, что Ниблер тоже недавно говорил,
[07:39.000 --> 07:44.520]  что у них опять execution tests сломались из-за ODR, они оборачивали все анонимные namespaces. Ну вот,
[07:44.520 --> 07:49.560]  если ты конкретный кейс нам скинешь почитать, будет здорово, но мне пока оно ни разу не пригодилось.
[07:49.560 --> 07:57.480]  Вот, поэтому я не могу сказать про это больше, чем, ну то есть то, что это эквивалент нам везде пометить
[07:57.480 --> 08:03.280]  как статик, кажется верно, помимо вот этих вот проблем с ODR, ну давайте просто забьем на все это.
[08:03.280 --> 08:09.960]  Не пишите в хедрах анонимные namespaces, вот мораль. В домашке все, пожалуйста, это уберите. Это первое,
[08:09.960 --> 08:21.360]  что хотел сказать про домашку, а что второе? А, про итератор в... Да, вот есть итератор у вас
[08:21.360 --> 08:30.800]  в слайсе, прекрасный итератор, у него есть там указатель и страйд, вы пишете.
[08:30.800 --> 08:50.320]  Оператор равенства, ну, например, вот такой. PTR равно ODR, PTR. Нормально? Нормально, потому что
[08:50.320 --> 09:00.240]  какая разница, какой страйд? Вот такая легатура. Где это у себя сделать? Ну,
[09:00.240 --> 09:08.520]  во-первых, надо поставить шрифт Fira код. А, ну в JavaScript. Там тройное равно и двойное
[09:08.520 --> 09:16.160]  отличаются. А ну вот, ну бывает, в плюсах, конечно, не нужно. Так, и сделали вот такую штуку,
[09:16.160 --> 09:22.480]  и тут мы такие пометили авто. Давайте пытаться найти здесь какую-то проблему или доказать,
[09:22.480 --> 09:32.480]  что ее нет. Где может очевидно быть проблема? Консты, конечно, да. А в другом месте проблема,
[09:32.480 --> 09:38.200]  связанная все-таки с нашим курсом. Чего? Вот да, я некоторым из вас написал уже там в комментариях,
[09:38.200 --> 09:44.800]  equality preservation. Ну, на самом деле проблема в том, как вы пишете код. Вот вы поставили авто,
[09:44.800 --> 09:50.000]  не задумываясь, скорее всего. Вот из тех десяти или пяти человек, которые поставили авто,
[09:50.080 --> 09:55.320]  я очень сомневаюсь, что кто-то сел и так внимательно задумался. Так, это у нас указатели, значит,
[09:55.320 --> 10:03.640]  тут выведется. Так, семантические требования выполнены, все корректно. Это не строн-кордеринг,
[10:03.640 --> 10:11.520]  это строн-кордеринг. Ну, во-первых, давайте поставим явно строн-кордеринг, чтобы было очевидно,
[10:11.520 --> 10:25.600]  что происходит. А во-вторых, почему ты так считаешь? Вот давайте для этого...
[10:25.600 --> 10:39.160]  Сейчас. Кто-нибудь помнит, как концепт называется или где эти семантические требования были написаны?
[10:39.160 --> 10:50.360]  Что-то я забыл. Наверное, в нем, да. Наверное, в нем. И тут нам интересно...
[11:00.360 --> 11:06.720]  Ну, короче, сейчас я не найду, видимо, да. Так вот, о чем я подумал в первый раз,
[11:06.720 --> 11:12.080]  когда наткнулся на это авто, сразу подозрения. Ну, подозрения правильные, но вот вывод я сделал
[11:12.080 --> 11:19.000]  неправильный. Что, мол, можно сделать слайсы с разным страйдом на один и тот же контейнер и
[11:19.000 --> 11:33.600]  потом сравнить их итераторы. То есть а-ля... Вот это будет с одним страйдом, там типа, неважно.
[11:33.600 --> 11:42.960]  Страйд будет один, это будет структура для наглядности. Это будет итератор два, но у него будет
[11:42.960 --> 11:59.000]  другой страйд. И вот мы такие, о, правда, работает. А теперь такие. Потому что мы только ПТР сравниваем.
[11:59.000 --> 12:10.280]  Ну, мы скажем, что это динамик страйд был, то есть это динамический слайс. Вот про это речь.
[12:10.280 --> 12:17.560]  Плюс-плюс определен. Неопределена вот эта операция. То есть, ну, вообще, я только что продемонстрировал
[12:17.560 --> 12:22.440]  нарушение quality preservation. Согласны? Вот мы одинаковые операции проделали и опа,
[12:22.440 --> 12:42.600]  equality нарушился. Не знаю. По идее, для этого и сделано. Ну, то есть, по идее, ровно для таких
[12:42.600 --> 12:47.920]  оптимизаций оно и сделано. Делаются ли они на практике сейчас, надо Assembler копать, я не смотрел.
[12:47.920 --> 12:54.760]  Но здесь нету никаких нарушений, потому что вы сами написали UBS с точки зрения своего кода.
[12:54.760 --> 13:01.800]  Для стандартного спана, если у вас два разных спана было, и вы из них получили два итератора,
[13:01.800 --> 13:07.400]  сравнивать их некорректно. Можно сравнивать итераторы только на один и тот же span,
[13:07.400 --> 13:14.640]  порожденный из одного и того же инстанса. А вот такие два разных итератора с разным страйдом могли
[13:14.640 --> 13:20.600]  получиться только из разных слайсов. Это к вопросу, как написать этот код, так чтобы он был правильный.
[13:20.600 --> 13:30.480]  Давайте вот так напишем, чтобы было совсем наглядно, что вот было два разных слайса,
[13:30.480 --> 13:40.080]  которых здесь, конечно, нет. Скип возвращает другой тип. Да, скип возвращает не другой тип,
[13:40.080 --> 13:46.440]  а новый инстанс. Вот в этом главное. Это один инстанс, это другой инстанс. Вот в стандарте решили,
[13:46.440 --> 13:51.880]  чтобы в такие игры дурацкие не играть, мы просто скажем, что сравнивать итераторы на разные
[13:51.880 --> 14:06.520]  инстансы спана это undefinedBehaviour. Нет, почему ты такое решил? Если мы говорим, что в нашем коде
[14:06.520 --> 14:12.800]  валидно сравнивать итераторы на разные слайсы, то здесь действительно должен быть weakorder.
[14:12.800 --> 14:26.840]  Я забыл, как он называется. weakordering. Если мы говорим, что мы считаем вот эту строчку
[14:26.840 --> 14:34.800]  корректной, то есть можно сравнивать из разных слайсов, то надо поставить weakordering,
[14:34.800 --> 14:40.360]  действительно. Но weakordering, с ним неприятно работать, это меньше возможности оптимизации
[14:40.360 --> 14:51.720]  компилятору. Поэтому хочется все-таки strictordering. Но этого тоже можно добиться. И вот в стандарте нам
[14:51.720 --> 14:57.000]  говорят, как этого добиться. Просто сказать, что такая строчка сравнивания итераторов на разные
[14:57.000 --> 15:05.840]  слайсы, это автоматому B. Ну, можно написать какие-нибудь иператоры сравнения шаблонные.
[15:05.840 --> 15:10.840]  Некоторые из вас так делали. Так вот, я предлагаю нам тоже сказать просто, что на разные слайсы
[15:10.840 --> 15:18.800]  итераторы запрещено сравнивать. Ассерт тут уже не нужен, мне кажется, потому что это ну такой,
[15:18.800 --> 15:29.120]  ну можно бахнуть. Можно бахнуть, ассерт, что other stride равно равно stride. Но это все равно вам не
[15:29.120 --> 15:38.040]  поможет спастись от того, что это были разные. Вот такое иногда делают, кстати, в некоторых итераторах,
[15:38.040 --> 15:51.000]  некоторые так пишут код, ну нет, давайте, ну ассерт можно. Отлично. Нет, короче, вариантов много,
[15:51.000 --> 15:58.240]  мораль какая. Вот ровно на такие вопросы вы как там дизайнер кода должны отвечать. Вот в вашей
[15:58.240 --> 16:04.240]  системе определено поведение вот такой строчки? Если определено, то вы должны продумать вот такой
[16:04.240 --> 16:12.880]  момент. Если не определено, то как бы все нормально и так. Ну вот это вот тонкие моменты. Ну можно
[16:12.880 --> 16:20.840]  писать авто и не думать, но просто авто пишешь и ты не задумываешься. Я предлагаю вам авто не писать,
[16:20.840 --> 16:27.280]  а писать все-таки явно, и тогда сразу задумайтесь. Так, у меня строн-кордер. Здравствуйте. Извините,
[16:27.600 --> 16:40.440]  извиняю, нет, садись. Отвлек меня. Что я говорил, не пишите авто, пишите явно. Как только вы явно
[16:40.440 --> 16:45.960]  написали строн-кордеринг, вы сразу задумайтесь, подождите, quality preservation, а я тут два поля имею,
[16:45.960 --> 16:52.760]  а сравниваю только по одному. А не нарушу ли я как-нибудь quality preservation? Вот об этом надо как бы
[16:52.760 --> 16:58.680]  задуматься и сделать, чтобы у вас все нормально было. Окей, на этом все по комментариям, по слайсу.
[16:58.680 --> 17:19.200]  Это по всех контейнерах стандарта? По-моему так. Ну да.
[17:22.760 --> 17:35.480]  Нет, смотри. Только узнать от кого-нибудь или прочитать где-нибудь в твиттере, например. Ну такие
[17:35.480 --> 17:42.840]  вещи. Понимаешь? C++ это язык, который лучше всего учить, читая твиттер членов комитета стандартизации,
[17:42.840 --> 17:53.480]  на удивление. По набросам в твиттере? Ну да, по набросам в твиттере, это прекрасно работает,
[17:53.480 --> 18:04.720]  они там статьи кидают. Да, это тоже. Вот, ну вот тут есть ссылка, что cp17 forward iterator domain of
[18:04.720 --> 18:29.880]  lalala same underlined sequence. Ну если мы там std concept откроем. Ну тут, конечно, надо смотреть.
[18:29.880 --> 18:52.000]  Ну то есть вот прям, явно вам написано, нельзя сравнивать итераторы на разные контейнеры.
[18:52.000 --> 18:58.280]  Предлагаю вам придерживаться такого же правила. Тогда у вас все ордеры будут strong и проблем не
[18:58.280 --> 19:08.840]  будет. Это опять моменты, как в Библии, их нужно правильно интерпретировать. Я боюсь, что будет,
[19:08.840 --> 19:12.800]  если это интерпретировать не так, как я сейчас интерпретировал. Мне кажется, все-таки задумано
[19:12.800 --> 19:33.920]  так. Ну вот да, как бы раскол церкви c++ сейчас происходит. Да, наверное, ты все-таки не хочешь
[19:33.920 --> 19:42.480]  сравнивать итераторы из разных этих, тем более, что, вспомним, что на меньше-больше можно сравнивать
[19:42.480 --> 19:48.800]  только указатели, которые в одном, в один блок локации указывают. Помните, я вам такое говорил,
[19:48.800 --> 19:54.480]  хоть кто-нибудь? Ну вот, соответственно, если у вас есть один вектор и другой, вы сравните итераторы
[19:54.480 --> 20:02.400]  из этих векторов, то это указатели в разные локации, и у вас в Б, во всяком случае. Поэтому лучше
[20:02.400 --> 20:09.200]  соблюдать это. Ну вот ты сказал, что иногда потенциально, может быть, хочется нарушить это, и вот вопрос как-то
[20:09.200 --> 20:15.680]  сделать так, чтобы пользоваться, чтобы было понятно, что я это нарушаю. Давай сначала ты придумаешь
[20:15.680 --> 20:21.400]  кейс, которым ты хочешь нарушить, прям адекватный, ненадуманный, адекватный, и тогда мы поговорим,
[20:21.400 --> 20:28.640]  а сейчас будем говорить еще немного про полиморфизм. Вот тут две таких маленьких подтемы,
[20:28.640 --> 20:35.000]  здесь мы их быстро пролетим и после этого продолжим обсуждать домашки, потому что они меня
[20:35.000 --> 20:43.880]  гораздо сильнее сейчас волнуют, чем новые темы. Вот, значит, ну про... не будешь работать, да?
[20:43.880 --> 20:51.200]  Про мультиметоды надо сначала поговорить, перед тем, как вот к страшному слову Tag and Walk переходить.
[20:51.200 --> 21:01.600]  Это каждый раз происходит, я же заранее воткнул, чтобы оно потупило само. Оно не потупило.
[21:05.000 --> 21:18.560]  Как это понимать? О, работает. Вот такая смешная картинка, вот тут изображены какие-то разные
[21:18.560 --> 21:27.000]  типы пересечений, кружочка и квадратика, условно говоря. На это можно сделать свитч, правда? Ну,
[21:27.000 --> 21:31.480]  вот вы поняли, какой у вас из видов пересечений, и дальше вам там площадь надо посчитать,
[21:31.480 --> 21:37.240]  какой-нибудь многоугольник построить, который имеет форму пересечения, неважно. Ну, вот свитчи
[21:37.240 --> 21:47.640]  хорошо бы заменять на полиморфизм. Мы же все обожаем заменять свитчи на полиморфизм. И полиморфизм,
[21:47.640 --> 21:55.480]  ну статический, мы умеем делать в таком случае, но сейчас увидим как. Но вот кружочек и квадратика
[21:55.480 --> 22:00.880]  окей, а если у нас там целая иерархия, там кружочки, квадратики, какие-то полигончики,
[22:00.880 --> 22:08.880]  вот куча разных вариантов, каждый с каждым надо пересекать, еще там по-разному возможно. В общем,
[22:08.880 --> 22:14.800]  напрашивается какая-то такая конструкция, что у вас много перегрузок, кружок с кружком,
[22:14.800 --> 22:20.200]  кружок с квадратом, квадрат с кружком и так далее. Ну и в них написан разный код пересечения разных
[22:20.200 --> 22:25.640]  фигур. Ну, аналогично для разных случаев пересечения можно сделать. На самом деле просто картинка
[22:25.640 --> 22:33.400]  первая не очень удачная, но она уже тут три года, поэтому с уважением к ней относитесь. Ну, понятная
[22:33.400 --> 22:40.480]  идея. Это multiple dispatch полиморфизм. Вот в обычных виртуальных методах у нас только один аргумент
[22:40.480 --> 22:47.280]  влияет на то, какой метод будет вызван, определяет вот этот полиморфизм. Тот, на котором мы точку
[22:47.280 --> 22:53.800]  делаем, объект точка метод, то, что перед точкой определяет, у кого вызовется метод. Тут же мы
[22:53.800 --> 22:59.080]  определяем по нескольким аргументам, у кого вызовется метод. Ну вот а что, если мы хотим
[22:59.080 --> 23:08.640]  динамический полиморфизм в таком месте, казалось бы, что может быть проще. Вот есть перегрузки,
[23:08.640 --> 23:15.480]  хочется динамически диспетчеризироваться. Ну, нативных инструментах в плюсах, как вы можете
[23:15.480 --> 23:24.520]  припомнить, для этого нету. Свечи это не полиморфизм. Все полиморфизм. Свечи ифе полиморфизм.
[23:24.520 --> 23:32.400]  Ну, свечи окей, свечи сработают, только здесь вместо свеча иф написан, потому что, ну,
[23:32.400 --> 23:38.840]  почему мы будем делать свечи? Нам по интерфейсу shape приходит какая-то фигура, надо пересекать.
[23:38.840 --> 23:50.320]  Это еще одна тема по домашкам, которую хочу поднять на самом деле. Кто-то так каждый год делает.
[23:50.320 --> 23:56.440]  Вспомните, как вы решали домашку про маппер. Есть ли у вас там тройкетч?
[23:56.440 --> 24:05.760]  Признавайтесь, есть ли у кого тройкетч? У кого найду, того заставлю переделывать.
[24:05.760 --> 24:13.960]  Ну, потом, в общем, про домашку. Ну, нормальная тема. Ну, вы же понимаете, что руками отписать влом?
[24:13.960 --> 24:31.640]  Да нет, ну ты что, нет. Надо сделать список типов, надо написать шаблон, генерирующий вот такой вот
[24:31.640 --> 24:39.800]  каскады FOV и там список функций тоже в компайлтайме. Можно не только типы в списках таких компайлтаймовых
[24:39.800 --> 24:45.480]  можем хранить. Указательно, функции тоже можем. Ну и как-то так вот это все делается. То есть
[24:45.480 --> 24:50.440]  приправляем метапрога и получается. С вашего позволения я не буду сейчас тратить время на
[24:50.440 --> 24:56.920]  то, чтобы это проделать, потому что более-менее понятно, как это делается, правда? Что? Зачем?
[24:56.920 --> 25:02.640]  Потому что вот сюда много дописывать буков сложно и неудобно. Хочется написать вот еще
[25:02.640 --> 25:09.240]  одну функцию вот такую, вписать ее куда-нибудь в список, что мы поддержали новый класс и чтобы
[25:09.240 --> 25:14.680]  все работало. Ну, предлагается просто сделать список типов, в котором все вот эти вот circle,
[25:14.680 --> 25:25.200]  rectangle, там полигон, вот список типов, где все это есть. Например, в принципе и через маппер можно.
[25:25.200 --> 25:33.480]  Во-первых, да, во-вторых, чтобы руками вот эти ифы не писать. Говорю, нам приходит по интерфейсу два
[25:33.480 --> 25:39.720]  непонятных экземпляра. Надо динамик касты проделать и понять какие-то экземпляры и в зависимости
[25:39.720 --> 25:45.800]  от этого вызвать разную функцию. Ну или разную перегрузку одной и той же функции. Ну маппер у
[25:45.800 --> 25:53.520]  вас был single dispatch, там один объект был. Ну да, конечно же так писать не надо, надо написать маппер,
[25:53.520 --> 25:59.960]  который типа в рядик и там сразу все делает. Если хотите, можете сами проделать. Идея, я надеюсь,
[25:59.960 --> 26:07.000]  понятна. На практике такое вряд ли кто-то будет писать, вот, потому что тут есть проблема с
[26:07.000 --> 26:15.560]  симптотикой небольшая. Вот если так задуматься, то вообще-то, вообще-то ифы это тоже такой цикл. Да,
[26:15.560 --> 26:22.800]  он в compile-time, но как бы асимптотика все равно есть. Можно сказать, что вот единица, потому что
[26:22.800 --> 26:29.680]  мы в compile-time фиксируем количество сущностей. Но на деле, ну вот комбинаторику вы помните,
[26:29.680 --> 26:35.520]  да? Понимаете, что тут n в степени m? Я уже не помню просто, я доверяю себе прошлогодним или
[26:35.520 --> 26:43.200]  пазопрошлым. Вот сколько аргументов у метода? Количество аргументов, арность, да. Количество
[26:43.200 --> 26:47.360]  аргументов, по которому мы хотим диспетчеризироваться. Ну и n это количество вот этих
[26:47.520 --> 26:55.940]  разных наследников интерфейса, по которым хотим. Ну вот еще там списки типов надо сортировать,
[26:55.940 --> 27:03.360]  как бы это сделать можно, там ambiguous call можно обработать. Что я имею ввиду под ambiguous call?
[27:03.360 --> 27:10.480]  Ну вообще говоря, эта иерархия, она может быть неплоской. Тут вот от полигона square может
[27:10.480 --> 27:18.160]  наследоваться. И вероятно, вы хотите уметь делать какие-то методы, мультиметоды, которые берут
[27:18.160 --> 27:25.800]  ректанглы полигон, а еще отдельный берет там square, еще что-то, какого-нибудь наследника
[27:25.800 --> 27:35.400]  ректангла. Ну вот как бы да, вот это вот надо написать, чтобы вот проблем тут не было. Ну,
[27:35.400 --> 27:42.760]  надеюсь, кто-то понял, это несущественно. Вот, ну и еще отсутствующая перегрузка бывает. Бывает
[27:42.760 --> 27:47.040]  такой кейс, что у вас для какой-то пары не определена ваша операция. Ну это тоже можно
[27:47.040 --> 27:52.800]  поддержать. Единственное, что вот долго, мы по сути за линию такую в кавычках проходимся,
[27:52.800 --> 28:01.320]  но линия это на самом деле n в степени n. Жесть, надо лучше. Ну сейчас будет очень знакомая тема,
[28:01.320 --> 28:12.640]  тем, кто любит ОП. Да много чего можно. Тут, наверное, можно. Я уже не в том возрасте,
[28:12.640 --> 28:17.880]  чтобы когда вот вижу задачу и мне говорят, можно за такую симпатику, у меня мгновенно в голове
[28:17.880 --> 28:31.960]  был решение. Ну хорошо, если топологическую сортировку сделать, то тогда можно. Да, вот как
[28:31.960 --> 28:36.480]  бы топологически отсортировать, потом идти по первому и там все делается за более-менее нормально,
[28:36.480 --> 28:44.760]  но можно лучше, можно проще без вот этих всех генераций каких-то ифов. Ну вот это не самый
[28:44.760 --> 28:52.760]  лучший вариант. Ну да, это легендарный метод «нормально делай, нормально будет». Если тебе
[28:52.760 --> 28:58.160]  нужно найти перегрузку, возьми ее и найди, что тут сложного. Окей, еще один способ, как ее найти
[28:58.160 --> 29:03.800]  все-таки. Виртуальные вызовы есть, они диспетчеризируются по this, по одному аргументу.
[29:03.800 --> 29:09.360]  Ну давайте сначала по первому аргументу диспетчеризуемся, потом по второму. То есть,
[29:09.360 --> 29:14.520]  ну вот тут какой-то код, сейчас надо его понять. Нам прислали other в intersection area,
[29:14.520 --> 29:28.520]  а мы у other и вызываем intersection area this. Ничего не напоминает? Что? Визитора, вот. Вот это
[29:28.520 --> 29:38.720]  правильный ответ. Ну как бы мы двойную диспетчеризацию делаем, нас вызывают непонятно чего. Что? Да,
[29:38.800 --> 29:50.160]  вас прям используют, но это вот хорошо. Ну да, кто-то снаружи зовет у какого-то шейпа метод
[29:50.160 --> 29:56.080]  intersection area. Мы попадаем в конкретный шейп уже, по первому аргументу, в circle, сюда попадаем,
[29:56.080 --> 30:02.480]  а теперь мы наоборот делаем. Вот нам прислали неизвестного шейпа, а мы у него зовем intersection
[30:02.480 --> 30:09.720]  area. Но вот себя мы уже знаем. Кто мы? Мы circle. Вот this у него будет тип как раз circle. И вызовется
[30:09.720 --> 30:17.120]  вот эта перегрузка. Ну или точнее. Давайте лучше вот через это. Пусть мы позвали на двух шейпах
[30:17.120 --> 30:29.480]  intersection area. Первый был rectangle, второй circle. Первый вызов. Можно. Будьте осторожны. Ну вот если
[30:29.480 --> 30:33.800]  мы на rectangle и circle зовем, мы сначала придем сюда, потому что первый аргумент был на самом деле
[30:33.800 --> 30:39.200]  rectangle, а вот это вот придет на самом деле вот сюда. Потому что тут первый аргумент на самом деле circle
[30:39.200 --> 30:45.680]  и из двух этих или трех этих перегрузок мы вызовем самую конкретизированную. А вот здесь у this уже тип
[30:45.680 --> 30:53.400]  известен статически. Поэтому этот rectangle будет эта перегрузка вызвана. Простая тупая идея. Работает,
[30:53.400 --> 31:02.960]  можно делать. Можно совсем хорошо. Может начать казаться, что это плохо на самом деле, но эту идею
[31:02.960 --> 31:11.560]  можно добить до нормального чего-то. Внимание, костыль из книжки двадцатилетней давности. Давайте
[31:11.560 --> 31:22.640]  добавим интерфейс с вот таким вызовом get class index и в каждого наследника будем вписывать вот
[31:22.640 --> 31:30.760]  этот macros, чтобы автоматом подпихнуть туда, во-первых, статическую переменную, а во-вторых,
[31:30.760 --> 31:39.880]  по виртуальному вызову уметь получать эту ссылку на эту статическую переменную. Поняли,
[31:39.880 --> 31:47.720]  что произошло? Нет, нет, именно просто ссылку. Вот он изначально минус один, мы просто ссылку
[31:47.720 --> 31:56.920]  возвращаем. Заполнять этот индекс будет кто-то извне. Нет, нет, нет, через friend injection можно
[31:56.920 --> 32:04.160]  сделать много чего, здесь его не будет. Пока что мы просто завели по одной переменной в каждом
[32:04.160 --> 32:11.640]  классе иерархии. Мы готовимся к номерации, но пока просто вот. Кстати, почему так, а не статическое
[32:11.640 --> 32:23.240]  поле? Кто может сказать? Зачем писать метод статический, внутри которого? Да ничего не сложно в
[32:23.240 --> 32:29.240]  современных плюсах. Ну ладно, ты, наверное, прав, да. Тут, скорее всего, такая причина была. У меня
[32:29.240 --> 32:39.640]  другое предположение есть. Вот эта штука tradsafe-ная, по-моему, автомат. Что-то там
[32:39.640 --> 32:46.160]  инициализация, первый вызов к этой штуке, он tradsafe-ный, потому что вот эта вот инициализация,
[32:46.160 --> 32:55.800]  она там под mutex-ом делается. В общем, статические переменные внутри методов, они инициализируются
[32:55.800 --> 33:01.960]  под mutex-ом, только инициализируются. Не доступ к ним потом, доступ к ним потом, он просто,
[33:01.960 --> 33:08.440]  ну переменная и переменная. Собственно, вот singleton-maersa, слышали про него? Да. Ну вот это ровно по той же
[33:08.440 --> 33:13.760]  причине там пишется. Вот именно так. Потому что там инициализация, она под локом происходит.
[33:13.760 --> 33:34.880]  Чего вызывается? А когда это вообще имеет влияние какое-то? Не знаю. Я предпочитаю просто вот
[33:34.880 --> 33:40.360]  такую штуку не использовать. Вот статические переменные внутри этого и там такие вещи,
[33:40.360 --> 33:50.360]  это все бор темный для меня пока что. Но всегда есть способ лучше это написать. Ну вот Александровску
[33:50.360 --> 33:56.440]  в своей книге предлагает нам так сделать. Давайте так сделаем, неважно. Полетим дальше. Ну вот какой-то
[33:56.440 --> 34:05.480]  derived от base, в базе есть этот интерфейс. Мы за уберрайдели вот этим макросом забавным. Ура!
[34:05.480 --> 34:15.280]  Александровску в своей книге сказал, что надо через макросы. Сейчас мы можем гораздо лучше,
[34:15.280 --> 34:25.520]  гораздо проще на самом деле. Ну вот весь мультиметод. Мы будем делать вектор указателей на функции.
[34:25.520 --> 34:44.640]  Ну пока это не мультиметод, это просто метод. Так написано в книжке, это просто изложение
[34:44.640 --> 34:49.520]  материала книжки. Я говорю, вы если будете на практике что-то подобное делать, вы 100% сделаете
[34:49.520 --> 34:58.160]  сильно лучше. Но это ну такая основная идея, тупая. Вектор указателей на функции, нам прилетает
[34:58.160 --> 35:06.120]  новый указатель на функцию и класс, для которого вызывать эту функцию. Пока не мультиметод. Ну
[35:06.120 --> 35:14.560]  берем idшник ему, если его нет, выдаем новый, просто по размеру этого массива и запихиваем в туда,
[35:14.560 --> 35:24.240]  где idшник, функцию, которую нам дали. Понятная идея. Тупая идея. Ну понятно, что нам обобщается
[35:24.240 --> 35:30.680]  насколько угодно много таких классов. Сделайте вектор векторов и все работает. Вот и вообще такая
[35:30.680 --> 35:37.720]  штука называется открытые методы. Несколько напоминать должны extension-методы, которые уже
[35:37.720 --> 35:43.320]  многократно упоминались. Вот я и не знаю, extension-методы бывают виртуальными в котляных с-шарпах,
[35:43.320 --> 35:51.080]  а прочем. Все виртуальное. Ну значит, бывают. Ну в общем, это вот такая некоторая попытка сделать
[35:51.080 --> 35:59.880]  extension-методы в плюсах с виртуальностью и прочим-прочим. Ну runtime-полиморфизм, вот там еще есть
[35:59.880 --> 36:05.280]  какой-то expression-problem, который был когда-то и всех волновал где-то в начале нулевых, в конце
[36:05.280 --> 36:10.840]  девяностых. Но нам это не интересно, нам интересна вот эта вот табличка, что мы в ОП этом группировали
[36:10.840 --> 36:17.280]  сяк-визитер и сяк, а теперь в открытых методах можем сгруппировать сяк. Потому что просто, блин,
[36:17.280 --> 36:21.880]  какой-то порядок слайдов странный, ну ладно. Потому что просто берем и вектор векторов делаем,
[36:21.880 --> 36:28.840]  ну по каждому индексу класса мы понимаем куда лезть. Естественно, тут вообще никакой группировки
[36:28.840 --> 36:37.440]  нету и дописывать можно в каком угодно месте, что угодно. Да, ну конечно же это все немножко
[36:37.440 --> 36:43.200]  фига тень, тут вот ID-шники типов какие-то вычислять, ну с много поточностью тоже проблемы,
[36:43.200 --> 36:48.600]  конечно же, будут. Нам ни тепло, ни холодно от того, что там минус единичка потока безопасно,
[36:48.600 --> 36:54.560]  это инициализировалось, нам интересно именно вот выдачу индекса. Хотелось бы вообще,
[36:54.560 --> 37:01.560]  чтобы эти индексы выдавались автоматом. Можно добавить в то, что ранится до мейна. В плане.
[37:01.560 --> 37:17.840]  Ну вот что-нибудь такое можно сделать. Можно через это и хэш таблички. Ну сейчас увидим,
[37:17.840 --> 37:23.280]  короче. В общем, ID типов не делайте. Раньше это было модно, потому что ничего лучше не придумали,
[37:23.280 --> 37:28.320]  теперь не делайте. А векторы могут очень сильно вырасти. Если вы вектор-векторочков делаете,
[37:28.320 --> 37:34.640]  или трехмерный вектор, вектор-вектор-вектор, то будет очень много пустой памяти. Нужно
[37:34.640 --> 37:42.600]  Sparse что-то писать, какую-нибудь Sparse матрицу, и тогда будет нормально. Вот помните момент был
[37:42.600 --> 37:48.840]  с ректенглом, который наследовал полигон. Вот тут такое не особо работать будет. Ну если задуматься,
[37:48.840 --> 37:55.360]  там просто вот непонятно, что должно происходить, и оно вот просто так не заработает, нужно что-то
[37:55.360 --> 38:03.760]  еще дополнительно предпринимать. Ну и тут как бы все это фиксится, что вот телекаты принимают
[38:03.760 --> 38:13.920]  бейс. Даже не помню, что я хотел сказать, и неважно. Через TTI можно пофиксить легко и через... Короче,
[38:13.920 --> 38:20.760]  вот так надо писать. Вот это решает все проблемы. Никаких векторов, unordered мапа, хэш мапа, круто.
[38:20.760 --> 38:26.480]  В идеале не STDшную используете, потому что вы же знаете, что STDшная unordered мапа очень медленная.
[38:26.480 --> 38:37.160]  Вот, хорошо. TypeID. TypeID нам никто использовать не запретит, даже если RTTI выключен, потому
[38:37.160 --> 38:45.320]  что мы вроде научились его устанавливать обратно. Через адрес метода что-то вот такое мы делали,
[38:45.320 --> 38:53.640]  помните? Адрес статической функции в классе. Не помните ничего. Ладно. Короче, TypeIDшники можно
[38:53.640 --> 39:00.200]  даже без RTTI себе восстановить при помощи несложных манипуляций. Ну и, конечно, указатели на функции
[39:00.200 --> 39:06.720]  это не очень удобно, лучше хранить прям нормальные функции со стейтом. Вот, ну и в каком-то таком виде
[39:06.720 --> 39:11.640]  совсем легко просто понятно получается. Но если вам нужно несколько типов здесь, возьмите да
[39:11.640 --> 39:18.120]  поксорите хэши TypeID. Или, ну, ксорить лучше не надо, лучше как-то их комбинировать адекватно, да.
[39:18.120 --> 39:28.440]  Чего? Ну, что-нибудь такое. Ну вот, можно бахнуть тензор, да, как-то у меня не в том порядке немножко,
[39:28.440 --> 39:35.720]  что вот вектор векторов и вот он прекрасный мультиметод рабочий. Зачем? Только не очень понятно,
[39:35.720 --> 39:43.120]  но такое есть. Ещё можно смешной трюк вывернуть. Можно взять и сделать симметричную диспетчеризацию.
[39:43.120 --> 39:49.560]  То есть, тут у вас два аргумента и вы можете сказать, что для пары AB и BA всегда будет одинаковый
[39:49.560 --> 40:00.480]  метод вызван. Ну то есть, если вы пересекаете фигуры, это симметричная операция, правда? Ну и наш
[40:00.480 --> 40:05.880]  полиморфизм замечательно это должен учитывать и выдавать одинаковые результаты. И, ну, там,
[40:05.880 --> 40:18.280]  как-то это делается. Я думаю, вы и сами догадаетесь, что там AB пару заменять на BA. Несложно. Давайте
[40:18.280 --> 40:24.360]  вот про финального босса нашего курса попробуем поговорить. Я понятия не имею, получится ли. Каждый
[40:24.360 --> 40:52.760]  год я предпринимаю попытку. Да. Ну STD Visit уже автоматом тебе делает мультиметод на
[40:52.760 --> 40:58.720]  вариантах. В STD Visit можно запихнуть не один вариант, а несколько. До 11 штук. И
[40:58.720 --> 41:08.680]  Аркадий знает. Ну больше 11 не нужно. 11 нормальное число. Вот. И, то есть, соответственно, передаешь
[41:08.680 --> 41:15.280]  функцию, которая принимает там три аргумента, причем все комбинации этих трех аргументов,
[41:15.280 --> 41:19.320]  и передаешь три варианта. И оно тебе дикартовое произведение всех вариантов перебирает.
[41:19.320 --> 41:43.800]  Нет? Ну, давайте это напишем. Быстро, просто и понятно. Include ли вариант? Вариант из
[41:44.360 --> 42:03.720]  Bula. Это V1, он будет от false. Chara и langa. Зовем STD Visit. Сюда мы прокидываем функцию не простую,
[42:03.720 --> 42:22.560]  а золотую. First after second. И пихаем туда V1 и V2. Что? Visit не просто умный, Visit невероятно
[42:22.560 --> 42:33.280]  умный. Но мне надоело сюда вписывать код. Давайте в Godbolt впишем, там быстрее запускать. Да нет.
[42:33.280 --> 42:58.480]  Так, ну чего он меня не запускает? Output компилятора, Output это. Где Output программа?
[42:58.480 --> 43:15.880]  Executor, вот. Вот, не поверите. Buzbulam и Charm позвал перегрузку. Понятно ли, что произошло? Вот этот
[43:15.880 --> 43:21.680]  объект lambda, он содержит шаблонный оператор круглой скобки, который можно вызвать с любыми
[43:21.680 --> 43:30.360]  двумя аргументами, которые ему прикинут. Мы запустили Visit от этой lambda и V1 в V2. Что сделает
[43:30.360 --> 43:39.280]  Visit? Он в этом объекте вызовет ту перегрузку оператора круглой скобки, в которой аргументы
[43:39.280 --> 43:43.840]  соответствуют тому, что лежит на самом деле в этих вариантах. А у нас в этих вариантах на
[43:43.840 --> 43:51.440]  самом деле лежит Bool и Char. Вот здесь же я написал Bool и Char. Соответственно вызовется перегрузка с
[43:51.440 --> 44:00.080]  Bool и Char, ну шаблон к любому подойдет. И вот первая авто это Bool, вторая авто это Char. Тоже вполне
[44:00.080 --> 44:11.600]  себе мультиметоды статические на вариантах. Да, это можно объюзить всякими интересными образами.
[44:11.600 --> 44:31.280]  Ну не получилось. Я хотел, чтобы у меня просто какой-то код скомпилировался,
[44:31.280 --> 44:48.160]  я кликнул на Visit и мы посмотрели. Что тут у нас? S-Variant, S-Variant, тыры-пыры. Да, все понятно. Да
[44:48.160 --> 45:00.080]  не, мне тоже ничего не понятно, это нормально. Я хочу найти комментарий про 11 штук. А, ну вот.
[45:00.080 --> 45:13.120]  Вот если N больше типа 11, то ну все. Не, ну это глупо реально, зачем больше 11 аргументов писать?
[45:13.120 --> 45:31.800]  Не уверен. Возможно, возможно. Я неправильно этот код интерпретировал, когда... Ну да, вероятно,
[45:31.800 --> 45:36.000]  я неправильно интерпретировал, что оно не работает после 11. Возможно, оно тут просто менее
[45:36.000 --> 45:44.120]  эффективную имплементацию использует. Вот. Ну видимо, ну черт ногу сломит в этом коде,
[45:44.120 --> 45:51.560]  я не хочу код либо cdc++ читать и вам не советую. Поэтому давайте про теганвук поговорим.
[45:51.560 --> 46:02.160]  Не очень хорошим, потому что там 100% оно пишется не красиво, не элегантно, а с тупыми хаками.
[46:02.160 --> 46:12.960]  Да, то есть это, ну, боль и страдание. Ну как бы никто у вас, вам не запрещается самостоятельно
[46:12.960 --> 46:17.520]  поупражняться во всяком вот таком прикольном, если вам это нравится. В «Аркаде» я не объект
[46:17.520 --> 46:23.360]  написал. Кому-то это прикольно, я уже расчаровался в жизни, мне не прикольно писать и не объекты.
[46:23.360 --> 46:30.160]  Сейчас мы узнаем как раз, что такое не объект. Потому что тема наша последняя, это теганвук.
[46:30.160 --> 46:38.600]  В прошлых сериях мы узнали что-то про неблоида и цпо, да? И у них там были какие-то проблемы,
[46:38.600 --> 46:47.200]  вот мы что-то их порешали, но не все. Давайте вспомним, что такое неблоид. Кто-нибудь? Нет?
[46:47.200 --> 46:58.240]  Вот давай один. Ну в целом да. Такая шняга, которую мы вместо функции используем. Вместо
[46:58.240 --> 47:03.840]  функции делаем объект. У объекта круглые скобки оператора, дальше уже что угодно. Зачем? Чтобы
[47:03.840 --> 47:13.120]  подавить случайный ADL. А цпо это что такое? Это вот не то же самое, что неблоид, а накрутка поверх
[47:13.120 --> 47:24.480]  него. Что мы там накручим? Ну да. Да, то есть мы так и берем неблоид, это объект, он ADL подавил,
[47:24.480 --> 47:31.280]  а дальше мы внутри все равно используем ADL, чтобы сделать кастомизация. Чтобы можно было для
[47:31.280 --> 47:36.560]  конкретных ваших классов переопределить, что эта глобальная функция будет делать.
[47:36.560 --> 47:46.360]  Вот, то есть такая прикольная техника, но там была вот проблема такая, да? Что как только мы
[47:46.360 --> 47:56.360]  сделали цпошку std ranges swap, имя swap у нас глобально зарезервировано. Вы не можете больше ни в какой
[47:56.360 --> 48:02.360]  своей библиотеке сделать цпошку swap, потому что тогда ADL будет находить не ту функцию swap,
[48:02.360 --> 48:10.600]  о которой вы думаете. Поняли о чем я, да? Вспомнили, что там такая проблема есть и надо ее решить.
[48:10.600 --> 48:18.920]  Давайте ее решим. Для этого нам нужно опять вспомнить про вот такую смешную штуку. Вот есть optional,
[48:18.920 --> 48:24.920]  и у него есть такой конструктор, а есть такой конструктор. Вот этот конструктор понятное дело
[48:24.920 --> 48:30.560]  пустой делает optional, а вот этот вот конструирует прямо внутри optional уже какой-то лежащий объект.
[48:30.560 --> 48:36.680]  Вот вопрос, что если у нас объект без аргументов, и мы хотим сделать optional,
[48:36.680 --> 48:44.480]  к которому же есть этот объект, но без аргументов, как вызвать вот эту штуку без аргументов вместо вот этой?
[48:44.480 --> 48:56.720]  Можно такое сделать? Нет, треугольные скобки для конструкторов явно указывать нельзя,
[48:56.720 --> 49:04.760]  потому что это будет конфликтовать с синтаксисом указания вот этого. Вот, поэтому мы пишем тут
[49:04.760 --> 49:10.680]  вместо каких-то треугольных скобочек, которые вот с этим конфликтуют, такой подхак,
[49:10.680 --> 49:19.400]  steady in place t, и тогда если мы зовем вот так, то у нас вызовется вторая штука. Если без, то первая.
[49:19.400 --> 49:28.960]  Видели уже такой хак, правда? Даже делали. И вот это вот, на самом деле, вот эта фундаментальная причина,
[49:28.960 --> 49:33.680]  почему его вообще в стандарт несли, потому что бывает, что мы хотим и то, и другое иметь вызывать,
[49:33.680 --> 49:43.080]  и не иметь каких-то конфликтов. Воспользуемся этой идеей. Очень плохо воспользуемся. Вот у нас
[49:43.080 --> 49:54.160]  какой-то customization point object swap. Здесь мы раньше вызывали неквалифицированно swap, чтобы ADL нам
[49:54.160 --> 50:01.080]  пошел и нашел то, что нужно, какую-то кастомизацию. Теперь мы не будем вызывать здесь просто swap,
[50:01.080 --> 50:06.240]  вот это вот неквалифицированное имя. Теперь неквалифицированное имя, которое мы вызываем,
[50:06.240 --> 50:13.440]  будет имя tag invoke. Вот это имя теперь зарезервировано глобально и никто его не может использовать в своих
[50:13.440 --> 50:22.480]  целях никаких. Зато мы всегда его используем, чтобы сделать ADL, при этом дифференцируем разные
[50:22.480 --> 50:30.040]  цепошки. Вот для какой из цепошек мы сейчас делаем ADL? Посредством тега, где в качестве тега
[50:30.040 --> 50:43.360]  служит сам объект цпошки. Запутались? Очевидно. Интуитивное решение. Интуитивное и понятное. Вот
[50:43.360 --> 50:49.200]  это это тег, вот точно такой же, как был на прошлом слайде. Ну вот это тег, тут специальный какой-то
[50:49.200 --> 50:55.200]  класс завели. Ну и здесь мы хотим для каждой цепошки свой тег завести. Ну есть swap, begin, end,
[50:55.200 --> 51:01.640]  это все разные цепошки, но мы хотим не резервировать глобальные имена, когда вот здесь дергаем через
[51:01.640 --> 51:08.080]  DL что-то. Поэтому мы зарезервируем одно имя, а для разных цепошек будем использовать разные теги.
[51:08.080 --> 51:15.380]  Ну и почему бы в качестве тега не использовать сам этот объект и сам его тип? Это же какая-то
[51:15.380 --> 51:24.120]  анонимная структура, вот у нее уникальный тип, вот ее используем в качестве тега. Все. Вот это
[51:24.120 --> 51:31.320]  тег на бок. Всем понятно? Аркадий, тебе понятно, что понятно? Ты уже все это сам написал. Поговорите со мной
[51:31.320 --> 51:38.760]  остальные. Вы понимаете, как это решает проблему namespace? У нас у каждой этот тег в своем namespace
[51:38.760 --> 51:43.520]  лежит, поэтому теперь мы по тегу однозначно понимаем, что мы собрались вызывать, и больше
[51:43.520 --> 51:49.680]  нет вот этой резервации имен глобальной. Теперь имя одно зарезервировано. Какие вы видите
[51:49.680 --> 51:56.160]  сразу недостатки в этой замечательной бильберде? Заклинание это один раз написали.
[51:56.160 --> 52:13.960]  Ну да, если вы напишете некорректный тег-н-волк какой-нибудь у себя, то вы можете дров наломать
[52:13.960 --> 52:20.640]  очень сильно. Это, конечно, печально. Как? Ну тег-н-волк, который принимает в ряде к пак чего угодно.
[52:20.640 --> 52:30.520]  В смысле? Ты же никогда не пишешь тег-н-волк ничего? Ты пишешь френ-декларацию? Ну да, ладно, нет. Ну ты не
[52:30.520 --> 52:37.000]  всегда пишешь френ-декларацию. Ты по идее должен всегда писать тег-декларацию. Ну френ-декларацию.
[52:37.000 --> 52:48.600]  На практике иногда получается так. Ладно, другая проблема. Помнишь, когда мы из свопа делали точку
[52:48.600 --> 52:57.760]  кастомизации, мы делали френ-да внутри какого-то класса. Тут на самом деле опущен еще дефолт. И вот этот
[52:57.760 --> 53:04.040]  тег-н-волк ничего не находит, использует просто std-swap. А вот если он находит, то его заигрываем. И как мы
[53:04.040 --> 53:11.440]  раньше делали? Мы звали своп неквалифицированно от двух аргументов. И ADL нам находил френ-декларацию в
[53:11.440 --> 53:18.120]  том же namespace, что и аргументы. Вот тут тешки какие-то. Вот в их namespace будет найдена какая-нибудь
[53:18.120 --> 53:26.360]  реализация свопа, которая кастомизирует поведение. Сейчас мы сядем это писать. Но тут есть даже без
[53:26.360 --> 53:31.280]  написания. Ну ладно, я вижу, что тебе непонятно. Сейчас мы вернемся к этому. Здесь есть очень
[53:31.280 --> 53:39.440]  очевидная проблема. Вот самой фундаментальной идеей, что раньше у нас было много зарезервированных имен,
[53:39.440 --> 53:46.800]  и для каждого из них свое множество перегрузок. Теперь у нас одно зарезервированное имя и одно
[53:46.800 --> 53:59.400]  большое множество перегрузок. Это все равно большая проблема, потому что там практика показала,
[53:59.400 --> 54:06.120]  что библиотека или библиотеки, которые вот на это полагаются, они заметно дольше компилируются,
[54:06.120 --> 54:15.720]  чем если бы там просто стоял вызов какого-нибудь метода. Поняли, о чем я? Нормально. Эрик Нибблер писал,
[54:15.720 --> 54:22.920]  все нормально. Вот был overload set для begin, overload set для swap, overload set для end. Нам нужно было
[54:22.920 --> 54:28.920]  только там искать, локально. Это было быстро. Теперь оно все в кучу слито в один overload set
[54:28.920 --> 54:34.160]  для имени tag and walk. Теперь всю ее нужно обыскивать в поисках того, что подойдет под вот этот тег.
[54:34.160 --> 54:42.600]  Это медленней. Вот такая техника может замедлить скорость компиляции вполне себе заметно. Вот,
[54:42.600 --> 54:48.120]  есть ли у меня еще слайды? А так у меня есть же слайды. Так вот, как мы этот тег и вог будем
[54:48.120 --> 54:55.200]  реализовывать. Вот какая-то фу, и мы захотели кастомизировать swap для фу. Написать кастомный
[54:55.200 --> 55:05.680]  механизм свопа с другим фу. Мы напишем friendly definition прямо внутри фу, который принимает тип
[55:05.680 --> 55:12.200]  свопа. Ну, вот это заклинание какое-то, да? Если внимательно наверх посмотреть, станет понятно.
[55:12.200 --> 55:18.440]  Вот этот своп, это вот это вот, это объект. Вот этот объект, он пустой внутри. Это структура
[55:18.440 --> 55:26.280]  без всего. Констекспоры, все дела. Вот эту структуру, своп, прям ее экземпляр, глобальный объект,
[55:26.280 --> 55:34.800]  мы запихиваем вот в этот шаблон, берем ее тип и убираем констант и амперсант. Ну и получаем
[55:34.800 --> 55:39.120]  просто, по сути, тип вот этой структуры анонимной. То есть структура-то анонимная,
[55:39.120 --> 55:48.080]  но тип у нее есть. Вот это заклинание получает по цепошке ее тип. И вот ровно этот тип мы сюда
[55:48.080 --> 55:55.920]  на вход принимаем. Поэтому тип вот этого звездочка здесь, он подойдет сюда. Вот эта вот перегрузка,
[55:55.920 --> 56:02.160]  она нам теги совпадают. Ну и дальше просто принимаем наши аргументы свопа и делаем своп.
[56:02.160 --> 56:08.920]  То есть вот ответ на твой вопрос, как мы это реализуем, а вот так. Вот код кастомизации,
[56:08.920 --> 56:17.080]  вот код вызова. А Дэйль увидит, что у тебя здесь фу написано в сснд и найдет через вот
[56:17.080 --> 56:28.440]  эту вот friend-definition в сопряженном наимспейсе. Некрасиво. Сюда иногда набрасываются делать
[56:28.440 --> 56:35.840]  макросы, чтобы вот эту первую строчку friend-void-tag-and-voke-tag-test-swap автоматом генерирует. Но не знаю.
[56:39.840 --> 56:47.480]  Да. Некоторые набрасываются и говорят, что это все вообще полная дичь. Надо это выкинуть к чертовой
[56:47.480 --> 56:56.040]  бабушке и заменить на инструмент уровня языка. Добавить в плюсы новое ключевое слово, как,
[56:56.040 --> 57:03.800]  например, static-virtual. А вот так вот. В глобальном наимспейсе пишете static-virtual и у вас вот это
[57:03.800 --> 57:12.200]  компилятор генерирует за вас. А вот здесь пишете static-overwrite и у вас с автоматом теги,
[57:12.200 --> 57:21.080]  теганвук, вся эта фигня генерируется. Опять же, здесь не нужен макрос, здесь можно сделать базу,
[57:21.080 --> 57:27.960]  которая в шаблонном аргументе принимает тип и объект тега, и она будет подмешивать в ремна.
[57:27.960 --> 57:36.920]  Можно. Много, можно по-разному извращаться. Но я считаю, что это все тлен, это полный тлен.
[57:36.920 --> 57:43.360]  Ну, давайте так, вы помните еще, зачем все вот это мы придумываем, зачем эти точки кастомизации,
[57:43.360 --> 57:55.240]  какие-то там звуки. Ну, как бы кажется, что да, а на самом деле нет, потому что есть execution,
[57:55.240 --> 58:00.340]  замечательный пропузл, про то, что давайте в C++ наконец-то добавим, вот как на курсе у Липовского
[58:00.340 --> 58:06.680]  рассказано, вот так и добавим. Но там столкнулись с проблемой. Мы хотим перфа, не хотим виртуальных
[58:06.680 --> 58:11.400]  вызовов, не хотим никаких локаций на куче, поэтому мы не можем делать как Липовский,
[58:11.880 --> 58:17.040]  потому что плюсы вообще-то еще на микроконтроллерах должны работать. А Рому интересуют исключительно
[58:17.040 --> 58:23.960]  распределенные системы. Ну, на микроконтроллерах нету кучи, если вы не знали. Просто локаций на куче нету.
[58:23.960 --> 58:32.360]  Кто? Виртуальный диспатчинг? Его можно сделать, но сами разработчики, которые пишут под микроконтроллеры,
[58:32.360 --> 58:39.720]  боятся его как огня, потому что он непредсказуемый перформанс дает. Там типа кашмисы, вот это все,
[58:39.720 --> 58:44.840]  оно сразу очень убивает. В общем, микроконтроллер – это то, что называется задача реального времени.
[58:44.840 --> 58:52.400]  Вот у вас должна быть строгая гарантия, что ваша программа либо в ближайшие пять микросекунд даст
[58:52.400 --> 58:59.560]  ответ, либо она скрашется и сигнализирует, что произошел сбой. Ну, где это используется,
[58:59.560 --> 59:06.600]  угадайте. Что? Ну, в Huawei 5G действительно, но там не такая большая проблема. Вот роутер это,
[59:06.600 --> 59:14.360]  роутер они не особо. Вот самолет, когда у вас летит, и там микроконтроллер, и вот он должен
[59:14.360 --> 59:21.200]  либо прямо сейчас отработать, пять миллисекунд бюджет, больше нельзя, либо сообщить, что я сломался,
[59:21.200 --> 59:30.760]  давайте на фолбэк на запасную систему или пусть пилот сам. Вот такого происходить как раз не
[59:30.760 --> 59:36.200]  должно. Понимаете, о чем я? Не просто гарантия корректности, а гарантия времени отклика.
[59:36.200 --> 59:44.280]  Нельзя зависнуть, нельзя долго слишком рассчитывать. Если вы марсоход какой-то
[59:44.280 --> 59:51.360]  спускаете на Марс, то, что вы лишние несколько миллисекунд подумаете, может привести к тому,
[59:51.360 --> 59:58.520]  что вы промахнетесь просто в тайминге, не в тот момент включили ускоритель, не туда полетели.
[59:58.520 --> 01:00:04.000]  Все расчеты к чертовой бабушке. То есть они не могут себе позволить лейтензий так называемый,
[01:00:04.000 --> 01:00:12.600]  задержку между приходом входа в микроконтроллер и откликом. В играх то же самое, кстати, не так
[01:00:12.600 --> 01:00:17.960]  критично, но все равно, если у вас фризит игра периодически, то есть вы играете у вас как бы 60
[01:00:17.960 --> 01:00:24.560]  фпс, но каждую секунду такой фриз типа. Сборщик мусора Джавы решил пособирать мусор, поэтому у вас
[01:00:24.560 --> 01:00:36.520]  майнкрафт как бы 60 фпс, но фризит. Это неприемлемо. Вы сразу закройте такую игру и... Нет,
[01:00:36.520 --> 01:00:48.680]  она обычно не раз в час происходит, а раз в секунду или несколько. Это уже типа не позволить... Ну вот,
[01:00:48.680 --> 01:00:53.400]  вот прекрасная, прекрасная вещь. Вот такого как бы в играх недопустимо, а в микроконтроллерах,
[01:00:53.400 --> 01:00:58.600]  на самолетах, марсоходах и прочем, вообще никаким образом, вот совершенно. Поэтому
[01:00:58.600 --> 01:01:03.680]  не используются некоторые вещи, которые имеют непредсказуемую временную характеристику. Например,
[01:01:03.680 --> 01:01:10.000]  куча. Вот на кучу вы что-то решили запустить, алоцировать, и вы не знаете, сколько времени это
[01:01:10.000 --> 01:01:16.120]  займет. Возможно, у вас в вашем трейдлокальном кэше уже есть блок памяти подходящий, вы возьмете
[01:01:16.120 --> 01:01:23.080]  это быстро. Возможно, вам придется идти в кэш на весь процесс того, что уже замаплено,
[01:01:23.080 --> 01:01:29.320]  и доставать оттуда кусочек, то есть в локатор идти. Возможно, в локаторе тоже не хватает места,
[01:01:29.320 --> 01:01:36.240]  и вам придется идти в операционную систему, мапить новый регион. Это непредсказуемое время работы,
[01:01:36.240 --> 01:01:41.880]  поэтому никакой кучи на микроконтроллерах быть не может. Более того, у нас в играх тоже куча
[01:01:41.880 --> 01:01:48.800]  отпиливается постоянно. Типа за кадр, а локации происходить вообще не должно за кадр игры,
[01:01:48.800 --> 01:01:56.280]  в идеале. На практике, конечно, так не получается, но стараемся. Избегается от разными способами,
[01:01:56.280 --> 01:02:01.560]  всякие кастомные локаторы аккуратненько сделаны и прочее-прочее, предлокация. На микроконтроллерах
[01:02:01.560 --> 01:02:07.880]  заранее выбирают размеры буферов. То есть такая предлокация, но не на запуске, а в компайл-тайме.
[01:02:07.880 --> 01:02:14.080]  Мы выбрали, что вот у нас килобайт памяти есть на микроконтроллере, вот от сих до сих будут лежать
[01:02:14.080 --> 01:02:20.440]  вершины связанного списка, которые нам нужны для бизнес-задачи. Если их больше, крашимся и
[01:02:20.440 --> 01:02:25.640]  репортим ошибку. Все, никакая куча не нужна, никаких локаторов хитрых, вы просто разметили
[01:02:25.640 --> 01:02:31.320]  память и знаете, что где лежит. Вот, я, надеюсь, достаточно замотивировал, что такая штука,
[01:02:31.320 --> 01:02:37.160]  как low latency, это вообще-то важно, и нам это нужно поддерживать. Поэтому наши прекрасные
[01:02:37.160 --> 01:02:43.640]  библиотеки, вроде STD ranges и STD execution, они должны работать без виртуальных вызовов и без локаций
[01:02:43.640 --> 01:02:48.200]  на куче. Виртуальные вызовы по той же причине могут быть там непредсказуемые по времени,
[01:02:48.200 --> 01:02:53.720]  потому что непонятно, куда идет instruction pointer. Там может быть непрогрета кэш инструкция и тоже
[01:02:53.720 --> 01:03:01.040]  там задержка, все плохо. Вот, поэтому весь ranges, если вы приглядитесь, он вообще-то работает без
[01:03:01.040 --> 01:03:08.800]  динамических локаций. И то же самое в STD execution. И чтобы этого добиться, нам нужен очень мощный
[01:03:08.800 --> 01:03:16.840]  статический полиморфизм. И вот для этого придумано все это, чтобы поддерживать статический полиморфизм,
[01:03:16.840 --> 01:03:24.680]  независимо от того, что нам пригнали, в каком виде пригнали и так далее. Вот begin and swap в ranges есть,
[01:03:24.680 --> 01:03:34.040]  но это как-то по-детски. А вот в execution там куча этих customization point object. Там есть сэнды всякие,
[01:03:34.040 --> 01:03:50.560]  есть set value, set error, schedule. Так нет, еще connect. Нет, ну предполагается же, что некоторые люди все-таки
[01:03:50.560 --> 01:03:56.800]  будут писать код, который инфраструктурный. И там куча, в общем, этих customization point,
[01:03:56.800 --> 01:04:03.760]  которые нужны, чтобы очень аккуратно выбрать, как для вашего класса существующего сделать
[01:04:03.760 --> 01:04:10.360]  какую-то синхронную операцию. Вот такая вещь. То есть они на самом деле хотели трейты, как в расте,
[01:04:10.360 --> 01:04:16.240]  по сути. Только статические трейты из раста. Но у них их не было, поэтому они изобрели вот это.
[01:04:16.240 --> 01:04:22.440]  Она работает примерно так же, если приглядеться. Ну и вообще Tag and Walk можно, не обязательно в
[01:04:22.440 --> 01:04:28.560]  самом классе, вы его можете определить где угодно. То есть если у вас уже есть legacy class foo,
[01:04:28.560 --> 01:04:34.360]  который трогать нельзя ни в коем случае, вы можете для него через Tag and Walk кастомизировать
[01:04:34.360 --> 01:04:40.920]  поведение спокойно. Вот эта всякая расширяемость, что можно и сюда вписать, можно отдельно написать,
[01:04:40.920 --> 01:04:46.240]  можно и так, и сяко, по пятому, по десятому. Вот за счет нее к такому механизму и привязались,
[01:04:46.240 --> 01:04:56.480]  что можно как годно делать, и будет работать, и все довольны. Если правильно писать, то все будет
[01:04:56.480 --> 01:05:06.440]  правильно находить. Да, ну вот проблема, чтобы это объяснить, нам понадобился примерно курс. Ну
[01:05:06.440 --> 01:05:11.480]  тут конечно не вся информация курса посвящена этому. Тут много тонких деталей, которые нужно
[01:05:11.480 --> 01:05:17.920]  понимать, и вот беды в общем. Давайте немножко приколов, которые можно через Tag and Walk сделать,
[01:05:17.920 --> 01:05:25.520]  дополнительных. Ну смотрите какая штука. Вот это враппер какой-то поверх чего-то, что T, и у этого T
[01:05:25.520 --> 01:05:33.160]  тоже как бы есть size. И вы хотите автоматически, чтобы ваш враппер начинал соблюдать контракт,
[01:05:33.160 --> 01:05:39.320]  который соблюдает T. Ну и вы пишите Tag and Walk и пробрасываете size от враппера к size от T.
[01:05:39.320 --> 01:05:46.920]  Прикольно, удобно. Это можно даже автоматизировать каким-нибудь macros или CRTP или еще чем-то таким.
[01:05:46.920 --> 01:05:56.560]  Можно дальше пойти. Сейчас нужно сосредоточиться, вот это вот финальное усилие перед перерывом. Вот
[01:05:56.560 --> 01:06:04.640]  тут мы просто size, cpo-шка size, пробросили ее к тому, что мы внутри хранили. Внутри была value,
[01:06:04.640 --> 01:06:14.840]  мы к нему пробросили cpo-шку size. ОК? ОК. А тут шаблонный Tag and Walk, который принимает
[01:06:14.840 --> 01:06:31.960]  любую cpo-шку и любую cpo-шку пробрасывает к value. Не инстанцируется. Нет, подожди, ADL это именно идет.
[01:06:31.960 --> 01:06:41.360]  Вот ADL в том месте, вот в этом месте, где мы ADL-ем вызываем Tag and Walk, для вот этого класса враппер
[01:06:41.360 --> 01:06:48.440]  вот эта штука найдется, вот этот шаблон функции. И он инстанцируется для той cpo-шки, с которой мы
[01:06:48.440 --> 01:06:57.440]  вызвали все это дело. И любая cpo-шка, которую вы вызовете с враппером, она будет проброшена к
[01:06:57.440 --> 01:07:05.720]  тому, что внутри лежит. Забавно, не правда ли? Но это как будто бы вы отнаследовали какой-то класс и
[01:07:05.720 --> 01:07:17.400]  автоматом зауверрайдили все его методы, но при этом как бы скрыли его. Ладно, в ОП, наверное,
[01:07:17.400 --> 01:07:23.040]  такого эффекта космически очень легко добиться. А здесь, ну, по-моему, это смешно. Мы просто
[01:07:23.040 --> 01:07:32.840]  форвардим все cpo-шки, все вызовы к нам, к тому, кто внутри нас лежит. Ну, вообще, надо вот так
[01:07:32.840 --> 01:07:40.280]  написать, да. Все еще неправильно, конечно. Тут не хватает очень много чего. Тут нужно написать еще
[01:07:40.280 --> 01:07:47.040]  дополнительные аргументы, форварды написать, декл-тайп от авто. Вот, ну, вот это тут появилось
[01:07:47.040 --> 01:07:52.720]  по сравнению с прошлым слайдом, тег инвокабл. Вот это сделано здесь чисто для того, чтобы у нас...
[01:07:52.720 --> 01:08:09.520]  Ну, не только. Короче, вы же помните, что у нас набирается множество перегрузок, если сигнатуры...
[01:08:09.520 --> 01:08:15.760]  Да, множество перегрузок набирается, в нем есть функции, есть шаблоны функций. Шаблоны функций
[01:08:15.760 --> 01:08:24.560]  инстанцируются. Если инстанциация declaration функции произошла успешно, то все, эта функция
[01:08:24.560 --> 01:08:29.400]  подходит, и мы ее дальше несем, и начинаем их перебирать, кто подойдет. Так вот, если вот этого
[01:08:29.400 --> 01:08:35.000]  не написать, может так выйти, что вот эта функция нам, в принципе, подходит. Потому что здесь, что, никаких
[01:08:35.000 --> 01:08:40.080]  проблем скомпилировать вот эту вот строчку первую, то есть декларацию, ее скомпилировать для любого
[01:08:40.080 --> 01:08:48.760]  типа, проблемы нет. Вот. Ну и выбор перегрузки может выбрать вот эту вот функцию и сказать,
[01:08:48.760 --> 01:08:55.280]  она мне подходит. Но на самом деле вот эта строчка не скомпилируется. И вот чтобы, так как бы на шаг
[01:08:55.280 --> 01:09:00.240]  раньше еще на выборе перегрузки запретить вызывать вот эту функцию, если у нас на самом деле не
[01:09:00.240 --> 01:09:08.040]  компилируется вызов этого тега для нашего value, вот такую штуку хорошо бы написать. Во-первых,
[01:09:08.040 --> 01:09:13.000]  во-вторых, раньше ошибку получаешь, в некоторых случаях это кажется может повлиять на семантику,
[01:09:13.000 --> 01:09:17.960]  не обязательно. Не обязательно повлиять на семантику, потому что у тебя будет, ну, допустим, у нас у
[01:09:17.960 --> 01:09:28.840]  T, T не tag-invocable, тогда у нас wrapper от T будет tag-invocable, если мы пишем код буквально if constexpr
[01:09:28.840 --> 01:09:36.520]  tag-invocable, тогда tag-invocable. Вот, да. Тогда мы будем получать CE вместо корректного выведения. Вот, да,
[01:09:36.520 --> 01:09:43.280]  замечательный пример. Понял ли ты его? Ну, tag-invocable проверяет, что вот такая строчка компилируется.
[01:09:43.280 --> 01:09:49.600]  Теперь представь, ты где-то в стороне в коде написал вот такую штуку, у тебя есть, и ты в коде
[01:09:49.600 --> 01:09:57.520]  где-то написал в шаблонной функции if constexpr tag-invocable wrapper от T какого-то, тогда делай одно,
[01:09:57.520 --> 01:10:03.200]  иначе делай другое. Так получилось, что тебе такой код понадобилось написать. Этот код всегда
[01:10:03.200 --> 01:10:08.680]  true тебе даст. Вот тут tag-invocable всегда будет true для вот этого wrapper, независимо от того,
[01:10:08.680 --> 01:10:15.760]  какую CPO укажешь. Это странно. Ну, потому что здесь ничто не запретит вот эту декларацию вызвать,
[01:10:15.760 --> 01:10:21.360]  а вот то, что в теле где-то что-то не скомпилируется, как бы requires это не умеют проверять.
[01:10:21.360 --> 01:10:27.840]  Я подобные проблемы встречал в примере, когда мы пишем какой-то шаблонный код, в котором мы
[01:10:27.840 --> 01:10:35.920]  хотим сравнивать объекты. Ну, хотим, если они допускают сравнение, и мы пишем что-то в духе if
[01:10:35.920 --> 01:10:43.880]  constexpr equality comparable, мы их сравним, если нет, мы делаем какой-то fallback. Вот, и если ты в такой
[01:10:43.880 --> 01:10:49.840]  шаблонный код передашь std vector, то у тебя он будет всегда пытаться сравнить, потому что в std vector
[01:10:49.840 --> 01:10:55.320]  написано requires. Если ты передашь туда std vector от чего-то, что ты не умеешь сравнивать, ты
[01:10:55.320 --> 01:11:06.000]  будешь получать шип вместо fallback. Хороший пример. Стало понятнее или стоит написать это? Да или
[01:11:06.000 --> 01:11:12.880]  нет? Понятно. Окей, то есть вот это вот запрещает нам на этапе выбора перегрузки вызывать вот эту
[01:11:12.880 --> 01:11:20.400]  штуку, если на самом деле тело не скомпилируется. Почему это надо? Чтобы if constexpr tag-and-vowel для
[01:11:20.400 --> 01:11:26.480]  всего врапера работал корректно и не врал. Мы такое уже, кажется, видели несколько раз, просто надо
[01:11:26.480 --> 01:11:31.400]  в голове это связать. У вектора вот оператор копирования, например, он тоже такой, у него не хватает
[01:11:31.400 --> 01:11:39.480]  requires. То есть если ты сделаешь if constexpr std copyable vector, это всегда true, даже если это вектор
[01:11:39.480 --> 01:11:48.600]  unique pointers. Немножко странно, что is copyable для вектора unique pointers возвращает true. Как этот
[01:11:48.600 --> 01:11:53.880]  вектор unique pointers будешь копировать. А в том-то и дело, что никак. Is copyable тебе вернет true,
[01:11:53.880 --> 01:11:59.480]  но при этом, при попытке скопировать вектор, у тебя вылетит ошибка компиляции. Чтобы вот этой
[01:11:59.480 --> 01:12:07.040]  лажа не происходило, нужно requires писать аккуратно. Вот. Раньше нужно было писать этот свиная,
[01:12:07.040 --> 01:12:18.240]  теперь забыли про него. Кстати, кто в домашней пишет свиная? Вы здесь? Что-то люди... Да,
[01:12:18.240 --> 01:12:21.920]  потому что я и тут распинаюсь, объясняю, как теперь легко и приятно писать код.
[01:12:21.920 --> 01:12:31.320]  Сколько они как болтовая свиная пишут? Они enable if пишут или они тестеры пишут? Одна перекрузка проверяет...
[01:12:31.320 --> 01:12:38.440]  Нет, ну дами аргумент равно enable if, классический этот свиная.
[01:12:38.440 --> 01:12:54.760]  Черт. Вот еще почему-то оператор spaceship не все использовали, я не знаю. Вот это вот как бы кололись,
[01:12:54.760 --> 01:13:06.120]  мыши плакали, кровью стекали, но как-то сжать не переставали. Шесть операторов сравнения. Ну зачем?
[01:13:06.120 --> 01:13:17.720]  Не надо так. Вот все так. Это кажется все у нас. Ребят, не шептаться. Важные вещи говорю. Перерыв.
[01:13:17.720 --> 01:13:28.440]  Чуть-чуть поговорю еще про вот эту муть невнятную, да, и дальше мы перейдем к вопросу домашек. Так вот
[01:13:28.440 --> 01:13:37.720]  про муть невнятную. Тыгнвук можно сделать так в коде, чтобы он у вас был как некая библиотека. Во-первых,
[01:13:37.720 --> 01:13:45.360]  во-первых, вот разные цпо делать и внутри них дергать одно и то же имя. Так как бы можно делать,
[01:13:45.360 --> 01:13:54.120]  но на самом деле нужно ли? Вот авторы пропузла, которые вот это все втаскивает, предлагают делать не
[01:13:54.120 --> 01:14:02.040]  так. Они предлагают сделать ровно одну цпошку, которая сама называется тегнвук, одну единственную,
[01:14:02.040 --> 01:14:08.960]  и через нее дальше все пропускать. То есть вот этот код вам приблизительно уже должен быть знаком,
[01:14:08.960 --> 01:14:18.400]  что вот тип, вот функциональный объект цпо, внутри этого типа в операторе круглые скобки мы принимаем
[01:14:18.400 --> 01:14:28.320]  другую цпо и аргументы и тупо через одл вызываем вот это вот. Ну то есть можно было по-другому
[01:14:28.320 --> 01:14:37.440]  сделать. Они решили так. Про inline namespace. Вот такая малюсенькая деталь, ничто наважная,
[01:14:37.440 --> 01:14:43.920]  но вот Аркадий нам подсказывает, что просто вот так написать в нашем каком-то namespace MPC,
[01:14:43.920 --> 01:14:49.320]  ну представьте, что это STD. Просто так в нем написать такой объект плохо, потому что,
[01:14:49.320 --> 01:14:56.120]  коль скоро в этом namespace будет класс с friend, с таким же названием, нам скажут 3D definition.
[01:14:56.120 --> 01:15:07.560]  Почему это так работает? Ну бог его знает. Ну как бы да, а вот если написать так,
[01:15:07.560 --> 01:15:11.960]  то оно внезапно все работает и понимает, что вот эта цпошка ее надо звать, а вот эта вот
[01:15:11.960 --> 01:15:21.520]  кастомизация. Ну вот, то есть по сути вся механика Tag & Walk, она вот эти строчки. Вот просто вот это,
[01:15:21.520 --> 01:15:26.200]  ну еще вот тут всякие дополнительные вспомогательные, tag-tag, который я вам показывал,
[01:15:26.200 --> 01:15:32.280]  сейчас увидим как он используется. Tag & Walk был концепт, но он тоже простой, что можно позвать
[01:15:32.280 --> 01:15:40.160]  Tag & Walk от аргументов. Ну и в принципе все, какие-то резалты, еще что-то, не важно. Давайте посмотрим
[01:15:40.160 --> 01:15:51.560]  на адекватное более-менее применение всего этого. Делается структура with the, ну вернее еще одна цпошка.
[01:15:51.560 --> 01:16:03.640]  Внутри этой цпошки делается, как обычно, оператор круглой скобки и зовется уже Tag & Walk из namespace.
[01:16:03.640 --> 01:16:10.560]  Вот зачем, непонятно. Можно было прямо сюда вписать ADL, но решили для безопасности сделать,
[01:16:10.560 --> 01:16:15.280]  чтобы этот ADL, видимо для безопасности, всегда из одного и того же контекста происходил,
[01:16:15.280 --> 01:16:22.360]  где еще к тому же вписали вот эту штуку. Возможно лучше. Черт ногу сломит. Вот это вот,
[01:16:22.360 --> 01:16:30.280]  насколько я понимаю, это архаизма, его здесь уже не должно быть, мы вот говорили. Мы про это же
[01:16:30.280 --> 01:16:36.640]  говорили и вроде как пришли к выводу, что не нужно уже. В общем, неважно. То есть дизайн такой. В
[01:16:36.640 --> 01:16:43.640]  коде, который был у меня на слайдах, было вот так. Суть это не меняет. Можно вот так. И значит
[01:16:43.640 --> 01:16:52.240]  заведена какая-то цпошка для ширины фигуры, для высоты фигуры. Она принимает только одну фигуру,
[01:16:52.240 --> 01:16:59.800]  и та и другая, и возвращает float, но еще площадь заведена. Причем тут забавно, в каждой вот этой
[01:16:59.800 --> 01:17:11.840]  вот цепошке еще некоторый type rest signature написан. Догадайтесь, в чем суть? Абсолютно не очевидно.
[01:17:11.840 --> 01:17:19.480]  Вот если сравнить сигнатуру вот этого оператора круглые скобки и вот этой штуки, в чем связь?
[01:17:19.480 --> 01:17:33.160]  Да, Юрка, не знаешь. Кто-нибудь еще скажите что-нибудь. Ну типа того. Ну как бы эта цепошка,
[01:17:33.160 --> 01:17:37.600]  она создана, предназначена для того, чтобы взываться на одном объекте. Вот эта вот ширина,
[01:17:37.600 --> 01:17:45.200]  она принимает ровно один объект. Этот объект, он в каком-то смысле this. И вот эта сигнатура,
[01:17:45.200 --> 01:17:50.240]  она повторяет сигнатуру оператора круглой скобки, но заменив вот этот вот текущий объект на
[01:17:50.240 --> 01:17:57.880]  некоторый тип this, который, ну, пустая структурка, ничего не делающая. Зачем это нужно? Увидим чуть
[01:17:57.880 --> 01:18:05.240]  ниже. Ну вот как-то так получается, что у нас есть width, height, area, ну, прекрасно есть. А еще
[01:18:05.240 --> 01:18:17.000]  scale by некоторый. Вот здесь, здесь не написано. Ну ладно. Давайте квадрат посмотрим. В квадрате
[01:18:17.000 --> 01:18:24.480]  прекрасно сделаны friend definition и tag invoke, который будет height, в ответ на оба этих запроса возвращает
[01:18:24.480 --> 01:18:32.760]  просто size. Ну и area там считает и scale by некоторый. Scale by к нему сейчас попозже вернемся.
[01:18:32.760 --> 01:18:41.720]  Интересно, здесь вот что. Здесь есть концепт shape, который комбинирует в себе несколько
[01:18:41.720 --> 01:18:52.440]  CPO. Это вам должно какой-то концепт напомнить? Cenery нет. Ну, range. В концепте range было написано
[01:18:52.440 --> 01:18:58.760]  примерно то же самое. Copyable и там begin end определенно, где begin end это тоже CPO. Ну и здесь
[01:18:58.760 --> 01:19:10.080]  также. Окей. И это, и это все неважно. Дальше есть некоторый волшебный any shape. И вот это вот
[01:19:10.080 --> 01:19:17.560]  один из таких сочных моментов того, что позволяет делать технология теганвоков и CPO. Ну нет и нет,
[01:19:17.560 --> 01:19:37.240]  чего бухтеть. Теперь есть. Мы писали с вами type erasure контейнеры. И тогда я немножко так
[01:19:37.240 --> 01:19:43.720]  анонсировал, что можно обобщенный type erasure контейнер написать. Собственно, это он. Вы указываете
[01:19:43.720 --> 01:19:53.720]  этому type erasure контейнеру список CPO, и он все их стирает в Vtable. Вот это ближайший аналог,
[01:19:53.720 --> 01:20:01.040]  который мы можем в плюсах получить к трейтам из растов этих ваших. Потому что концепт shape,
[01:20:01.040 --> 01:20:12.080]  который где он, это статический трейд. Вот если вы функцию принимаете по концепту что-то,
[01:20:12.080 --> 01:20:18.440]  то функция автоматом шаблон, происходит мономерфизация, статический трейд. А вот
[01:20:18.440 --> 01:20:26.360]  этот вот any object или any shape из него получающийся, это как раз динамический трейд. Потому что если
[01:20:26.360 --> 01:20:33.800]  вы принимаете по any object функцию, то у вас там type erasure происходит, Vtable и динамическая
[01:20:33.800 --> 01:20:40.080]  диспетчеризация. Единственная интересная деталь, которую здесь еще можно осветить,
[01:20:40.080 --> 01:20:47.840]  это вот этот прекрасный метод scale by. Не знаю, наверное это будет забава для тех из вас,
[01:20:47.840 --> 01:20:56.820]  кто еще не отлетел. Метод scale by должен вернуть такой же тип, как и текущий тип. Вот как бы
[01:20:56.820 --> 01:21:05.520]  реализация scale by для square, и он принимает на вход square и некоторое ratio. И на выход
[01:21:05.520 --> 01:21:12.640]  должен дать square. Так вот вопрос смешной. А как вот этому прекрасному any object понять,
[01:21:12.640 --> 01:21:18.960]  какую сигнатуру делать? Потому что до сих пор мы как бы делали type erasure, когда сигнатура была
[01:21:18.960 --> 01:21:25.240]  какая-то простая более-менее. А тут она как бы зависимая. У вас даже возвращаемый тип зависит
[01:21:25.240 --> 01:21:30.520]  от того, на чем вы вызываете. Ну и вот здесь начинаются как раз вот эти приколы с this,
[01:21:30.520 --> 01:21:38.800]  что надо как-то исхищлиться. Ну вообще у any object в итоге у самого должен быть метод any
[01:21:38.800 --> 01:21:49.040]  shape, scale by. В этом смысл. Вот эти CPO-шки стерли, и у object у самого появилась возможность вызывать
[01:21:49.040 --> 01:21:58.120]  CPO-шки. Но при этом, если вы вызовете у any object scale by, что вам должны вернуть? Ну вот scale
[01:21:58.120 --> 01:22:03.880]  by у квадрата возвращает квадрат, у круга возвращает круг. Ну и вот единственный выбор — это действительно,
[01:22:03.880 --> 01:22:10.400]  что должны вернуть any shape. И тут происходят некоторые трюки, что мы говорим, что у scale by
[01:22:10.400 --> 01:22:17.240]  там два параметра. Именно первый из них, а не второй. Мы стираем у него type, и это будет произвольный
[01:22:17.240 --> 01:22:25.440]  как бы аргумент this, а второй ну просто float. А возвращаемое значение внезапно оно будет any
[01:22:25.440 --> 01:22:33.360]  object. То есть мы как бы стираем одну CPO-шку, но с другой сигнатурой, сделав каст по дороге. И вот так
[01:22:33.360 --> 01:22:41.360]  тоже можно. Я искренне надеюсь, что хоть один человек, ну Аркадий точно понял, да? Ну еще хотя
[01:22:41.360 --> 01:22:47.200]  бы один человек это понял. Если кому-то интересно в это углубиться, в то как написать трейты из
[01:22:47.200 --> 01:22:56.240]  раста в плюсах без как бы зеркал и дыма, по-честному, можете углубиться самостоятельно в это,
[01:22:56.240 --> 01:23:07.720]  соответственно для этого у нас есть any object. Вот это вот статья, которую я вам уже показывал. Здесь
[01:23:07.720 --> 01:23:13.680]  подробно объясняют все проблемы реализацию, вот эти вот все трюки со scale by. Ровно отсюда код
[01:23:13.680 --> 01:23:20.920]  взят, но с нуля написан. И да, если вы захотите пройти такой же путь, как Аркадий, можете
[01:23:20.920 --> 01:23:27.760]  самостоятельно, а на этом я пожалуй завершу вот эту вот бодягу. Я искренне надеюсь, что этот стандарт
[01:23:27.760 --> 01:23:32.960]  не добавят, а вместо этого сделают языковую поддержку, чтобы было без вот этой черной магии
[01:23:32.960 --> 01:23:43.400]  и там ADL и прочего, и это можно было объяснить первокурснику хоть как-то. Вот и да, на этой
[01:23:43.400 --> 01:23:47.760]  замечательной ноте я предлагаю закончить запись и перейти к вопросу домашних.
[01:23:47.760 --> 01:24:06.480]  Реализация есть. Можно прям полностью посмотреть на итог.
[01:24:06.480 --> 01:24:25.480]  Ну, короче, вот у них есть тот самый any object, вот ему передается коллекция цепошек и дальше
[01:24:25.480 --> 01:24:34.360]  пошли там какие-то типа 300 строк. Вроде как не очень сложно, но там еще много инклюдов и да.
[01:24:34.360 --> 01:24:41.240]  У меня тоже где-то в 300 строк.
[01:25:04.360 --> 01:25:13.040]  Звучит крайне увлекательно, никому не рекомендую.
[01:25:13.040 --> 01:25:23.880]  Не знаю, потому что в прошлом году, вот год назад мы сидели и вот оставшийся там час вот это все
[01:25:23.880 --> 01:25:30.760]  аккуратно трепетно писали, вот ну в итоге отлетели опять все кроме одного или двух человек. Я считаю,
[01:25:30.760 --> 01:25:36.200]  что на этот раз мы не будем на это тратить время, потому что выхлоп нулевой, если кому-то интересно,
[01:25:36.200 --> 01:25:40.920]  вы можете самостоятельно почитать. Большинству из вас, скорее всего, это вот точно не понадобится
[01:25:40.920 --> 01:25:54.160]  никогда. Стандарт пусть завезут, вот такой уже готовый инструмент и все. В репозитории, по-моему,
[01:25:54.160 --> 01:26:00.560]  тоже есть. Я не уверен, работает ли она, по-моему, все-таки мы добили, оно работало в прошлом году.
[01:26:00.560 --> 01:26:11.760]  Вот все, давайте. Такие вопросы, Аркадий, не задавай. Ну сломалось, ну бывает. Вот все,
[01:26:11.760 --> 01:26:14.440]  для онлайн зрителей пока, а мы с вами продолжаем.
