[00:00.000 --> 00:10.000]  Так, ну ладно, надо начинать, наверное.
[00:10.000 --> 00:16.640]  Ну, у нас сегодня последняя лекция, и в ней сойдутся
[00:16.640 --> 00:19.360]  коды корректирующие, о которых я говорил в прошлый
[00:19.360 --> 00:21.960]  раз, и теории оконечных полей, о которых я рассказывал
[00:21.960 --> 00:22.960]  полсеместра.
[00:22.960 --> 00:29.440]  Я напомню, какой класс кодов я в прошлый раз свел,
[00:29.440 --> 00:31.760]  называется циклические коды, и мы будем сегодня
[00:31.760 --> 00:33.760]  обсуждать только их.
[00:33.760 --> 00:38.680]  Я вот на этой доске выпишу то, что было в прошлый раз.
[00:38.680 --> 00:40.400]  Значит, что такое циклический код?
[00:40.400 --> 00:47.320]  Мы берем кольцо вычетов многочленов с коэффициентами
[00:47.320 --> 00:52.440]  по модулю 2, значит, вычеты по модулю идеала хвн-то
[00:52.440 --> 00:53.440]  и минус один.
[00:53.440 --> 00:57.840]  Ну, можно было бы написать плюс один, это неважно,
[00:57.840 --> 01:01.760]  потому что у нас минус единица равняется плюс единице
[01:01.760 --> 01:03.280]  в поле из двух элементов.
[01:03.280 --> 01:16.800]  И код называется циклическим, если он идеал в этом кольце.
[01:16.800 --> 01:24.920]  И в прошлый раз я несколько свойств этих циклических
[01:24.920 --> 01:26.600]  кодов обсуждал.
[01:26.600 --> 01:32.600]  Во-первых, в этом кольце все идеалы главные, то есть
[01:32.600 --> 01:35.800]  каждый циклический код поражен некоторым многочленом.
[01:35.800 --> 01:39.480]  Более того, можно считать, что этот многочлен является
[01:39.480 --> 01:42.680]  делителем многочлена хвн-то и минус один.
[01:42.680 --> 01:47.200]  Необязательно, можно породить и другим, но любой многочлен
[01:47.200 --> 01:50.000]  отличается от делителя хвн-то и минус один на какой-то
[01:50.000 --> 01:53.360]  взаимно простой с хвн-то и минус один множитель,
[01:53.360 --> 01:55.320]  то есть на обратимый элемент.
[01:55.320 --> 02:09.640]  И размерность кода мы отсюда легко нашли, она равна n-степень
[02:09.640 --> 02:11.480]  вот этого порождающего многочлена.
[02:11.480 --> 02:20.320]  Ну и кроме того, мы еще обсудили, что циклические
[02:20.320 --> 02:27.240]  коды это подпространство, инвариантное относительно
[02:27.240 --> 02:28.400]  циклического сдвига.
[02:28.400 --> 02:36.680]  Ну, чтобы говорить о циклическом сдвиге, мне хорошо бы здесь
[02:36.680 --> 02:37.680]  базис вести.
[02:37.680 --> 02:39.360]  Базис самый обычный.
[02:39.360 --> 02:45.600]  Мне же ведь нужны двоичные векторы, и для этого мне
[02:45.600 --> 02:48.960]  нужен какой-то базис, чтобы координаты в этом базисе
[02:48.960 --> 02:50.480]  образовывали двоичный вектор.
[02:50.480 --> 02:54.120]  Вот в качестве базиса я беру степени х от нулевой
[02:54.120 --> 02:55.120]  до n-1.
[02:55.120 --> 03:00.120]  Это базис в любом кольце вычитов, если мы берем
[03:00.120 --> 03:02.880]  вычеты по модулю идеала степени, порожденного в
[03:02.880 --> 03:06.480]  многочленном степени n, так что тут все как обычно.
[03:06.480 --> 03:13.640]  А вот эта вот характеризация позволяет нам задавать
[03:13.640 --> 03:16.320]  циклический код очень коротко, нам достаточно задать
[03:16.320 --> 03:29.680]  один вектор и сказать, что циклический код получается
[03:29.680 --> 03:30.680]  так.
[03:30.680 --> 03:33.880]  Мы берем все циклические сдвиги этого вектора
[03:33.880 --> 03:36.920]  и их суммы, суммируем по модулю 2.
[03:36.920 --> 04:00.200]  Вот я написал вектор двоичной длины 15.
[04:00.200 --> 04:04.440]  Если брать его циклические сдвиги, у нас будут получаться
[04:05.040 --> 04:09.280]  скажем в начале три нуля, потом две единицы, два нуля
[04:09.280 --> 04:12.360]  и единица, ну и оставшиеся тоже нули, то есть все такие
[04:12.360 --> 04:13.360]  циклические сдвиги.
[04:13.360 --> 04:18.080]  Берем и берем все возможные их суммы по модулю 2.
[04:18.080 --> 04:20.800]  Вообще говоря, даже не очень понятно, сколько получится
[04:20.800 --> 04:25.640]  векторов, то есть какова размерность, но это определить
[04:25.640 --> 04:27.240]  сравнительно легко.
[04:27.240 --> 04:30.840]  Более интересный вопрос, какое кодовое расстояние
[04:30.840 --> 04:40.840]  у такого кода?
[04:40.840 --> 04:43.480]  И вот это сложный вопрос, циклических кодов довольно
[04:43.480 --> 04:49.560]  много и общего способа определить кодовое расстояние
[04:49.560 --> 04:57.160]  удобно, вот как у нас допустим есть для размерности.
[04:57.160 --> 04:58.960]  Размерность мы можем определить так, нам задан какой-то
[04:59.000 --> 05:01.160]  многочлен, он конечно не обязательно делитель
[05:01.160 --> 05:04.920]  x-vent и минус один, но давайте возьмем наибольший общий
[05:04.920 --> 05:07.920]  делитель x-vent и минус один и порождающего многочлена,
[05:07.920 --> 05:10.560]  это уже будет делитель x-vent и минус один, он будет порождать
[05:10.560 --> 05:16.880]  тот же самый идеал, поэтому получится, что размерность
[05:16.880 --> 05:19.680]  вот будет находиться по этой формуле, только здесь
[05:19.680 --> 05:21.880]  надо уже будет использовать вот этот наибольший общий
[05:21.880 --> 05:22.880]  делитель.
[05:22.880 --> 05:27.120]  А с кодовым расстоянием все хуже, сложнее найти
[05:27.120 --> 05:34.160]  и его в общем случае довольно трудно, но есть много интересных
[05:34.160 --> 05:39.160]  примеров таких кодов, циклических, этот класс содержит много
[05:39.160 --> 05:45.000]  интересных примеров, в том числе он содержит все
[05:45.000 --> 05:47.600]  совершенные коды, я напомню, что совершенные коды, это
[05:47.600 --> 05:51.880]  такие замечательные коды, которые задают разбиение
[05:51.880 --> 05:56.080]  булева куба на хэминговые шары радиуса r, то есть они
[05:56.080 --> 05:59.360]  не просто не пересекаются, а еще и каждая точка принадлежит
[05:59.360 --> 06:00.680]  ровно одному шару.
[06:00.680 --> 06:05.760]  Вот оказывается, что все совершенные коды циклические.
[06:05.760 --> 06:12.040]  Начну я с кода хэминга, который был в прошлый раз, и мы посмотрим,
[06:12.040 --> 06:14.480]  почему он циклический, так как я его определял в
[06:14.480 --> 06:16.120]  прошлый раз, это совершенно непонятно.
[06:16.120 --> 06:29.920]  Ну там мы знаем параметры, я сейчас начну с того, что
[06:29.920 --> 06:32.880]  построю циклический код с такими же параметрами,
[06:32.880 --> 06:36.200]  а потом объясню, почему он по сути дела совпадает
[06:36.200 --> 06:40.880]  с кодом хэминга, с точностью до перестановки, я даже
[06:40.880 --> 06:44.480]  порождающую матрицу, которая у меня была, все подгоню.
[06:44.560 --> 06:46.840]  Ну вообще, когда говорят, что совпадает, имеется
[06:46.840 --> 06:50.600]  в виду, что мы можем переставить строки из столбцы, потому
[06:50.600 --> 06:54.640]  что это ни на что не влияет, в смысле кодового расстояния,
[06:54.640 --> 06:55.640]  размерности.
[06:55.640 --> 06:59.800]  Значит, как строится такой код?
[06:59.800 --> 07:06.080]  Нам потребуется поле из 2 в степени s элемента.
[07:06.080 --> 07:10.240]  Нам потребуется порождающие мультипликативные группы.
[07:10.240 --> 07:13.560]  Тут вот надо вспоминать теорию конечных полей,
[07:14.240 --> 07:17.600]  одна из самых первых теориям про конечные поля, что мультипликативная
[07:17.600 --> 07:18.600]  группа циклическая.
[07:18.600 --> 07:31.560]  Вот я беру порождающий и беру минимальный многочлен
[07:31.560 --> 07:40.040]  для альфа, то есть это многочлен с коэффициентами в поле
[07:40.040 --> 07:41.880]  из двух элементов.
[07:41.880 --> 07:45.240]  По нашему определению, минимальный вам многочлен.
[07:45.240 --> 07:50.120]  И вот нужный нам код, давайте его сейчас пока обозначу
[07:50.120 --> 07:55.200]  как-то отлично, от кода Хемминга, чтобы было понятно, он как
[07:55.200 --> 08:04.080]  раз порожден, аж, прошу прощения, аж, он как раз порожден этим
[08:04.080 --> 08:05.080]  многочленом.
[08:05.080 --> 08:13.480]  Ну, чтобы найти размерность, давайте вспомним, что многочлен
[08:13.480 --> 08:24.920]  х в степени 2 в степени s минус 1 делится на, я напишу
[08:24.920 --> 08:28.680]  сразу на аж, но что мы знаем про этот многочлен?
[08:28.680 --> 08:31.920]  Ну, если мы еще домножим на х, мы получим наш стандартный
[08:31.920 --> 08:35.160]  многочлен х в степени 2 в степени s минус x, и он делится
[08:35.160 --> 08:38.960]  на все неприводимые многочлены, степень которых является
[08:38.960 --> 08:39.960]  делителем s.
[08:39.960 --> 08:43.440]  Ну, если мы на х сократили, то все кроме многочлена
[08:43.440 --> 08:44.440]  х.
[08:44.440 --> 08:48.480]  А минимальный многочлен неприводим, какая его степень?
[08:48.480 --> 08:57.400]  Ну, поскольку мы знаем, что поле порожденное альфа,
[08:57.400 --> 09:00.400]  а в данном случае, поскольку это порождающая мультипликативная
[09:00.400 --> 09:04.040]  группа, это все наше поле из 2 степеней с элементов,
[09:04.040 --> 09:07.720]  у нас есть замечательная лемма, о которой нужно помнить,
[09:07.720 --> 09:10.800]  что оно изоморфно кольцу вычитов по модулю минимального
[09:10.800 --> 09:11.800]  многочлена.
[09:11.800 --> 09:16.400]  Ну, идеала порожденного минимального, значит степень,
[09:16.400 --> 09:20.680]  мы знаем сколько элементов в кольце вычитов, их 2 в степени
[09:20.680 --> 09:23.120]  степени многочлена, значит степень многочена обязательно
[09:23.120 --> 09:30.120]  с.
[09:30.120 --> 09:34.160]  Поэтому это делитель вот такого многочлена.
[09:34.160 --> 09:37.840]  Ну и теперь размерность уже мы находим обычным
[09:37.840 --> 09:43.960]  образом, вот по нашей общей лемме, она такая, как нужно.
[09:43.960 --> 09:49.680]  Теперь нужно понять, кодовое расстояние, как я уже говорил,
[09:49.680 --> 09:52.040]  это сложнее, но в данном случае это довольно легко.
[09:52.040 --> 09:53.040]  Почему?
[09:53.960 --> 09:58.080]  Посмотрите, пусть у нас есть какой-то элемент нашего
[09:58.080 --> 10:03.960]  кода, это рассуждение мне понадобится и дальше, это
[10:03.960 --> 10:08.960]  значит, что он кратная, ну с каким-то коэффициентом
[10:08.960 --> 10:12.720]  h tilde, кратная нашего многочлена h.
[10:12.720 --> 10:16.240]  Что это означает в кольце многочленов?
[10:16.240 --> 10:20.080]  В кольце многочленов, это же равенство класса вычитов,
[10:20.080 --> 10:22.720]  это значит, что разность этих двух многоченов отличается
[10:22.720 --> 10:27.360]  на делитель x в степени n, поэтому в кольце многочленов
[10:27.360 --> 10:38.000]  мы получаем такое равенство, ну плюс какой-то g от x на
[10:38.000 --> 10:41.640]  x в степени n минус 1.
[10:41.640 --> 10:46.680]  Что для меня существенно, существенно то, что если
[10:46.680 --> 10:52.720]  я подставлю альфа в x, получится что?
[10:52.720 --> 10:58.320]  Получится что h от альфы это 0, поскольку это минимальный
[10:58.320 --> 11:02.760]  многочлен, но и альфа в степени n минус 1 это 0, потому что
[11:02.760 --> 11:08.760]  альфа в степени n это единица, n это как раз 2 в степени
[11:08.760 --> 11:21.600]  с минус 1, и вот из этого соображения, что раз у нас
[11:21.600 --> 11:26.080]  порождающий идиала имеет корнем альфа, то и любое
[11:26.080 --> 11:28.400]  кратное тоже будет иметь корнем альфа, для этого
[11:28.400 --> 11:34.120]  нужно только чтобы альфа само по себе было корнем
[11:34.120 --> 11:42.520]  вот этого вот многочлена, по которому мы берем вычеты.
[11:42.520 --> 11:47.520]  Ну давайте смотреть, предположим у нас есть элемент веса 1,
[11:47.520 --> 11:52.200]  это означает, что у нас есть какой-то вычет, содержащий
[11:52.200 --> 11:58.320]  просто степень x, но из рассуждения, которое я написал выше,
[11:58.320 --> 12:01.520]  следует, что тогда альфа в степень a равно 0, это вообще
[12:01.520 --> 12:07.920]  невозможно, в поле нет делителей нуля, поэтому
[12:07.920 --> 12:11.040]  никакая степень ненулевого элемента не может равняться
[12:11.040 --> 12:12.040]  нулю.
[12:12.040 --> 12:25.520]  Ну надо еще посмотреть на вес 2, то есть многочлен,
[12:25.520 --> 12:32.760]  у которого две единицы среди коэффициентов, ну из вот
[12:32.760 --> 12:35.520]  это и несложного утверждения, которое я написал, следует,
[12:35.520 --> 12:39.000]  что альфа в степени i, плюс альфа в степени j должно
[12:39.000 --> 12:47.800]  равняться нулю, ну давайте вынесем что-нибудь за скобку,
[12:47.800 --> 12:50.800]  плюс и минус 1 в данном случае одно и то же, я напоминаю,
[12:50.800 --> 12:53.200]  у нас характеристика 2, поэтому плюс 1 и минус 1 я
[12:53.200 --> 12:56.400]  пишу скорее из соображений зрительного удобства.
[12:56.400 --> 13:02.600]  И мы видим, что поскольку делителей нуля нет, это
[13:02.600 --> 13:05.760]  не 0, значит вот это 0, то есть мы получаем, что альфа
[13:05.760 --> 13:09.680]  в степени j минус i должно равняться единице, но это
[13:09.680 --> 13:19.320]  означает, что j минус i должно быть кратно n, по-другому
[13:19.320 --> 13:22.000]  не получится, потому что я напоминаю, это порождающая
[13:22.000 --> 13:24.920]  мультипликативная группа, его порядок краю на n, для
[13:24.920 --> 13:32.280]  этого мне и нужно было взять порождающий, ну а ij, нас же
[13:32.280 --> 13:38.440]  интересуют только какие ij, которые не отрицательны
[13:38.440 --> 13:45.640]  и строго меньше n, потому что у нас вот этот вот базис,
[13:45.640 --> 13:51.560]  здесь мы берем i как раз от нуля до n, до степени
[13:51.560 --> 13:54.360]  многощины, степени многощины уже не включаем, строго меньше
[13:54.360 --> 13:59.040]  чем n, ну значит разность никак не может, если разность
[13:59.040 --> 14:04.200]  кратна n, то отсюда следует, что i равняется j, именно
[14:04.200 --> 14:08.880]  j должно равняться нулю, но тогда это просто 0, это
[14:08.880 --> 14:11.320]  не то, что мы хотели, мы хотели все-таки, чтобы i не равнял
[14:12.320 --> 14:14.960]  Таким образом, мы видим, что параметры
[14:14.960 --> 14:19.400]  этого кода в точности такие же, как у кода Хемминга,
[14:19.400 --> 14:22.040]  теперь я хочу объяснить, почему это на самом деле
[14:22.040 --> 14:26.580]  код Хемминга и есть, ну это можно доказать более сложными
[14:26.580 --> 14:28.840]  рассуждениями, что коды с такими параметрами все
[14:28.840 --> 14:32.280]  вот эквивалентны относительно перестановок строк столцов,
[14:32.280 --> 14:36.240]  но я этим не буду заниматься, а прямо для конкретного
[14:36.240 --> 14:44.080]  такого представления объясню, что у нас получается в точности
[14:44.080 --> 14:49.520]  та же порождающая матрица, что была, значит у нас как
[14:49.520 --> 14:58.040]  устроен наш код, вот он, порождается он чем, h это делитель х степени
[14:59.040 --> 15:10.440]  значит g порождается вот такими элементами, берем какую-нибудь
[15:10.440 --> 15:17.800]  степень х и умножаем на h, и тут тогда g должно меняться
[15:17.800 --> 15:29.280]  от нуля до ну до n минус степень h, а это я напомню как раз
[15:29.280 --> 15:41.240]  два степени s минус один минус s, степень h равна s, ну давайте
[15:41.240 --> 15:45.600]  посмотрим на этот многочлен, будем считать, что у h, ну тут
[15:45.680 --> 15:48.080]  поскольку поле из двух элементов старше коэффициент райна
[15:48.080 --> 15:53.800]  единица, давайте запишем вот это вот как я это назову
[15:53.800 --> 16:06.640]  аж и запишу это так, х в степени s плюс g плюс ну какой-то
[16:06.640 --> 16:15.680]  остаток, как-нибудь его обозначу, ну ладно пусть будет
[16:15.680 --> 16:32.320]  ж ж, но смотрите нас же интересуют элементы в кольце класса
[16:32.800 --> 16:36.280]  вычетов, поэтому ничего не изменится, если я возьму
[16:36.280 --> 16:43.760]  здесь, ну даже не элементы в кольце класса вычета,
[16:43.760 --> 16:51.720]  нас интересует кратный h, и вот если я запишу, разделю
[16:51.720 --> 16:59.080]  вот этот многочлен с остатком на h, ну давайте какой-нибудь
[16:59.280 --> 17:16.600]  с тильдой на h плюс rgt, то смотрите, если я потом возьму класс вычетов,
[17:16.600 --> 17:21.240]  ну этот класс вычетов я хочу оставить отдельно, значит давайте
[17:21.240 --> 17:26.520]  я теперь воспользуюсь магическими свойствами доски и запишу вторую
[17:26.520 --> 17:40.040]  формулу на месте первой, плюс вот этот вот класс вычета, но
[17:56.520 --> 18:14.120]  что-то мне не нравится, что у меня получается, секундочку
[18:26.520 --> 18:34.600]  я хочу представить вот такой вот многочлен
[18:48.440 --> 18:56.120]  хочу представить такой многочлен, как туму какой-то большой степени и многочлена степени
[18:56.120 --> 19:02.840]  меньше s, ну для этого да, я должен конечно взять вот так, но что у меня получится,
[19:02.840 --> 19:10.240]  у меня получится не совсем то, что я хотел, сейчас разберемся, вот это то, что я хотел и
[19:10.240 --> 19:30.840]  еще у меня есть вот эта вот добавочка, ну да, ну да, значит тут надо как обычно базис поменять,
[19:30.840 --> 19:38.480]  значит смотрите рассуждение такое, вот это будет точно базис в нашем коде, но я теперь хочу взять
[19:38.640 --> 19:43.440]  другой базис, вот я взял соответствующий многочлен, представил его в таком виде,
[19:43.440 --> 19:53.960]  а заметьте, что вот тут вот степень уже меньше, самую старшую степень я выделил, значит здесь
[19:53.960 --> 20:00.360]  степень меньше, чем j и вот это вот будет представляться, то есть я хочу сказать,
[20:00.360 --> 20:14.280]  что у меня базисом будет и вот такой набор векторов, когда я вот для многочленов этого
[20:14.280 --> 20:20.920]  базиса заменяю, оставляю старшую степень, а все остальное беру по модулю h, почему, потому что
[20:20.920 --> 20:27.120]  смотрите, вот эта вот добавка, она поскольку у нее степень меньше, она будет выражаться через
[20:27.120 --> 20:34.360]  базисные векторы с меньшими значениями j, то есть матрица перехода от одного базиса к другому,
[20:34.360 --> 20:41.040]  она будет просто треугольная, то есть начинаю я просто с обычного многочлена h, у него все правильно,
[20:41.040 --> 20:48.840]  степень s старше, остальное меньше, чем s-1 и дальше, когда я беру следующую степень, у меня получается так,
[20:48.840 --> 20:54.160]  что вот появляется новый базисный вектор плюс какая-то линейная комбинация предыдущих,
[20:54.160 --> 21:03.200]  поэтому это тоже базис, степени вот тут существенно, степени вот этих вот многочленов,
[21:03.200 --> 21:14.000]  они не превосходят s, ну и теперь давайте я этот базис, это базис, поэтому чтобы написать
[21:14.000 --> 21:22.120]  порождающую матрицу, мне нужно записать коэффициенты многочлена, давайте я сейчас буду их писать вот в
[21:22.120 --> 21:31.280]  этом направлении, право, нулевая степень и так вот будет увеличиваться, вот здесь будет
[21:31.280 --> 21:42.040]  s-1 степень, вот тут будет st, ну и так далее. Посмотрите, какой я базис нашел, я нашел базис,
[21:42.040 --> 21:48.720]  у которого вот эти вот старшие степени, начиная с st, они как раз образуют вот такую вот единичную
[21:48.720 --> 21:58.720]  матрицу, а что написано здесь, а здесь написаны коэффициенты многочлена r житого от x,
[21:58.720 --> 22:10.280]  если вот здесь вот s-1, многочлен имеет степень меньше, чем s, потому что я делю с остатком на
[22:10.280 --> 22:16.200]  многочлен степени s, значит коэффициенты от 0 до s-1 нумируются, и что мы можем сказать,
[22:16.480 --> 22:23.880]  во-первых, мы можем точно сказать, что они разные, вот представьте, что здесь и здесь написано было
[22:23.880 --> 22:34.000]  бы одно и то же, тогда сложив эти два элемента кода, я бы получил кодовый вектор, в котором
[22:34.000 --> 22:40.960]  всего две единицы, все что вот в этой правой части, все бы сократилось, если я беру два одинаковых
[22:40.960 --> 22:46.520]  вектора, складываю их по модулю 2 и получаю 0, остаются только две единицы, но кодовое расстояние
[22:46.520 --> 22:58.280]  я уже нашел, оно 3, поэтому такое невозможно, значит тут все разное, и более того, в каждой
[22:58.280 --> 23:06.880]  такой строчке не меньше двух единиц, почему, ну потому что иначе бы опять у меня просто появилось
[23:06.920 --> 23:14.160]  строчка где две единицы или меньше, что невозможно, как мы проверили, и мы получаем в точности порождающую
[23:14.160 --> 23:24.960]  матрицу кода Хэминга, то есть я сейчас доказал, по сути дела, что мой код совпадает с кодом Хэминга,
[23:24.960 --> 23:41.320]  вот такой вот анализ, вот это вот часть необязательна, можно было бы, код-то все равно получается
[23:41.320 --> 23:46.720]  совершенный, это отдельная теорема, что все совершенные коды с кодовым расстоянием 3 одинаковые,
[23:46.720 --> 23:57.520]  ну в смысле с одинаковой длиной, одинаковым кодовым расстоянием 3, и они имеют именно такое значение
[23:57.520 --> 24:04.760]  параметра, но тем не менее тут можно вот просто и явно показать, видно, что на самом деле на эту
[24:04.760 --> 24:10.040]  матрицу можно смотреть вот таким вот способом, это один из возможных базисов в нашем коде,
[24:10.040 --> 24:16.760]  не тот, который у меня был с самого начала, немножко другой, давайте какой-нибудь пример возьмем,
[24:16.760 --> 24:32.480]  давайте я, наверное, центральную доску сотру, ну вот у меня там вектор длиной 15, поэтому я хочу написать,
[24:32.480 --> 24:44.760]  что n это 15, то есть 2 в четвертый минус 1, теперь мне нужно найти порождающие мультипликативные
[24:44.760 --> 24:54.000]  группы поля из 16 элементов, я не помню делал я это или нет, но многочлен х четвертый плюс х плюс
[24:54.000 --> 25:04.400]  один, это минимальный многочлен, можно взять порождающий с таким минимальным многочленом,
[25:04.400 --> 25:10.640]  действительно смотрите, раз он минимальный многочлен, значит альфа в четвертой плюс альфа плюс
[25:10.640 --> 25:20.000]  один равняется нулю, альфа в кубе, я хочу проверить, что порядок альфа 15 мультипликативной группе
[25:20.000 --> 25:24.880]  этого поля, для этого мне достаточно проверить, что альфа в кубе не равно 1, альфа в пятой не
[25:24.880 --> 25:29.600]  равно 1, помните вот этот трюк, который я уже несколько раз использовал, когда мы про группы
[25:29.600 --> 25:35.960]  говорили, я хочу убедиться, что порядок некоторого элемента n, для этого я должен взять простые
[25:35.960 --> 25:41.880]  делители n, на каждый простой делитель поделить и убедиться, что соответствующая степень не 1, альфа
[25:41.880 --> 25:54.560]  в кубе не равно 1, просто потому что мы знаем, что все линейные комбинации степеней меньше 4,
[25:54.560 --> 25:59.560]  все различные, теперь с альфа в пятой, тут конечно сложнее, потому что степень уже больше четырех,
[25:59.560 --> 26:04.080]  но на самом деле тоже не очень сложно, потому что это альфа умножить на альфа в четвертой,
[26:04.080 --> 26:08.760]  то есть это альфа в квадрате плюс альфа, потому что альфа в четвертой это альфа плюс один,
[26:08.760 --> 26:13.880]  я напомню, что плюс и минус один у меня сейчас одинаковые, и это тоже не равно единице,
[26:13.880 --> 26:26.600]  значит действительно порождающая мультипликативная группа, ну смотрим, что нам еще нужно, все, значит код
[26:26.600 --> 26:35.160]  порожденный вот таким вот многочленом даст нам код Хэминга длины 15, давай теперь посмотрим на
[26:35.160 --> 26:44.360]  вот этот магический вектор, который я написал, я внизу припишу степени 0, 1, 2, 3, 4, ну и так далее,
[26:44.360 --> 26:52.960]  мы видим, что это в точности вектор коэффициентов этого многочлена, поэтому мы знаем, во-первых,
[26:52.960 --> 27:09.840]  что всего у нас получится 2 в 15 минус 4, то есть 2 в 11 разных сумм циклических сдвигов этого вектора,
[27:09.840 --> 27:28.720]  и в каждом ни нулевом ни нулевой, хотя бы три единицы, глядя на такой вектор, это не очень легко понять
[27:28.720 --> 27:35.760]  сходу, ну то есть понятно, что можно взять циклические суммы, найти размерность линейной оболочки,
[27:35.760 --> 27:44.320]  но дальше надо как-то перебирать, чтобы убедиться, что все единицы такие, но вот поскольку мы взяли этот
[27:44.320 --> 27:51.040]  вектор совершенно не случайно, вытащили его из конечных полей, то и свойств всей этой конструкции
[27:51.040 --> 27:56.640]  все сразу следует, ничего проверять не нужно, уже все готово, таким образом мы видим, что код Хэминга
[27:56.640 --> 28:03.560]  циклический, и более того, вот эта вот конструкция, я напомню, что код Хэминга он исправляет, поскольку
[28:03.560 --> 28:08.280]  у него кода в расстоянии 3, он исправляет одну ошибку, но хочется исправлять больше ошибок,
[28:08.280 --> 28:15.680]  при вот таком вот задании кода Хэминга, совершенно непонятно, как это обобщить, чтобы получить код,
[28:15.680 --> 28:24.080]  который исправляет больше ошибок, а вот эта вот конструкция позволяет построить коды, которые
[28:24.080 --> 28:29.600]  исправляют R ошибок, и тоже достаточно хороши, вот это следующий шаг, который я хочу сделать,
[28:29.600 --> 28:36.840]  я буду, поскольку конструкция во многом повторяется, я буду так постепенно стирать,
[28:36.840 --> 28:53.520]  это называется коды БЧХ, БЧХ по именам Боуз, Чаат Хури и Хокенгима,
[28:53.520 --> 29:08.160]  обычно ссылаются именно на этих людей, значит, в литературе они первыми записали, мы хотим
[29:08.160 --> 29:26.280]  исправлять R ошибок, то есть кодовое расстояние мы хотим, чтобы было не меньше, чем 2R плюс 1,
[29:26.280 --> 29:30.760]  это мы в прошлый раз обсуждали, для исправления R ошибок нам нужно кодовое расстояние не меньше,
[29:31.720 --> 29:51.720]  какая размерность я пока писать не буду, а длина будет той же, дальше мы делаем вот что,
[29:51.720 --> 30:03.480]  я по-прежнему беру порождающие мультипликативные группы, но ищу теперь многочлен,
[30:03.480 --> 30:13.760]  среди корней которого есть не только альфа, но и альфа квадрат, и альфа куб, и так до
[30:13.760 --> 30:29.720]  все первые 2R степеней, и вот нужный нам код циклический порождается таким значением,
[30:29.720 --> 30:45.040]  в случае кода хэминга у нас была всего одна, всего одно условие нас интересовал,
[30:45.040 --> 30:52.800]  ну минимальным на чем нас интересовал, на самом деле вы можете заметить, что в моем доказательстве
[30:52.800 --> 30:57.240]  минимальность этого многочлена была не так существенна, там в некоторых местах она была нужна,
[30:57.240 --> 31:03.360]  но ее можно обойти, но чем меньше степень многочлена, тем больше размерность, поэтому
[31:03.360 --> 31:06.880]  минимальный многочлен мы хотим взять для того, чтобы размерность была как можно больше,
[31:06.880 --> 31:13.560]  тогда у нас получается совершенный код, но в случае произвольного количества ошибок R
[31:13.560 --> 31:19.080]  совершенный код уже не получится, мы сейчас посмотрим насколько он хорош, но давайте для
[31:19.080 --> 31:24.760]  начала поймем, что такое построить можно, это на самом деле не очень сложно, смотрите что я делаю,
[31:24.760 --> 31:30.920]  я этот многочлен определяю так, я беру минимальный многочлен для альфа, минимальный многочлен для
[31:30.920 --> 31:44.160]  альфа в кубе и так далее, минимальный многочлен для альфа в степени 2R-1, просто по построению мы видим,
[31:44.160 --> 31:56.200]  что альфа в нечетной степени вплоть до 2R-1 является корнем этого многочлена, а что делать с альфа в
[31:56.200 --> 32:06.520]  четной степени, а тут надо вспомнить про ауто-морфизм фробениуса, если у нас альфа в степени 2 и является
[32:06.520 --> 32:15.680]  корнем этого многочлена, альфа в степени и тоже является корнем, поэтому если я беру какую-то
[32:15.680 --> 32:21.920]  четную степень, деля показатель степени пополам, я рано или поздно приду к какому-то нечетному числу,
[32:21.920 --> 32:32.600]  а все нечетные числа уже корни, поэтому это тоже будет корень, то есть вот такая вот конструкция,
[32:32.600 --> 32:38.280]  она неоднозначно, потому что выбирать эти многочлены можно по-разному, более того,
[32:38.280 --> 32:48.920]  мы можем немножко улучшать, ведь у нас может так случиться, что в одну орбиту фробениусы попадают
[32:48.920 --> 32:58.280]  и какие-то нечетные числа, ну это при каких-то РН возможно, ну в общем, такое возможно, то есть
[32:58.280 --> 33:03.840]  конструкция неоднозначно, но тем не менее, я вот буду это называть кодом БЧХ, их много разных,
[33:03.840 --> 33:11.720]  но что для меня существенно, что я могу теперь оценить размерность этого кода довольно легко,
[33:11.720 --> 33:23.080]  почему, потому что степень каждого такого многочлена не превосходит S,
[33:23.080 --> 33:33.960]  всего я взял R множители, значит, степень F не превосходит R множить на S, ну тогда размерность
[33:33.960 --> 33:41.080]  по общей лемме, раз степень не превосходит, то размерность не меньше, чем N минус R множить
[33:41.080 --> 34:01.680]  на S, вот мы получили размерность, ну и теперь самая интересная часть, нужно как-то объяснить,
[34:01.680 --> 34:06.800]  почему кодовое расстояние достаточно большое.
[34:31.680 --> 34:55.960]  Вот это утверждение о том, что кодовое расстояние БЧХ кода не меньше, чем 2R плюс 1,
[34:55.960 --> 35:10.840]  я буду доказывать отпротивно. Я предположу, что у меня есть вектор небольшого веса L,
[35:10.840 --> 35:20.040]  то есть сумма L мономов, у меня векторы же имеют очень простые координаты 0, 1, это у нас все над
[35:20.040 --> 35:40.760]  полем из двух элементов, и L не превосходит 2R. Я предполагаю, что такое есть, сейчас я приду к
[35:40.760 --> 35:53.840]  противоречию. Смотрите, давайте я как-нибудь вот этот многочлен через G обозначу, и вот здесь
[35:53.840 --> 36:11.880]  напишу выкладку, у которой у меня уже была, я ее стер. Значит, мы знаем, что это вычеты,
[36:11.880 --> 36:19.640]  содержащие многочлен G, принадлежат нашему коду, наш код это идеал, порожденный многочленом F,
[36:19.640 --> 36:34.240]  поэтому с точностью до кратного многочлена х в степени n минус 1, мы имеем такое равенство в
[36:34.240 --> 36:44.360]  кольце многочленов. Вычет кратный вычет у F, а это означает, что разность равна 0 в нашем кольце,
[36:44.360 --> 36:52.440]  разность равна 0, означает, что кратно значено х в степени n минус 1. Ну и тогда мы видим,
[36:52.440 --> 37:07.080]  что раз F от альфа в степени равно 0 при i под единицей до 2R, мы видим, что G от альфа в степени
[37:07.080 --> 37:14.760]  также равно 0 при тех же значениях i. Потому что смотрите, если я подставляю в значенных
[37:14.760 --> 37:22.760]  степени n минус 1, любая степень альфа, она еще возведется в степень n, это будет на единице,
[37:22.760 --> 37:29.920]  просто потому что n порядок мультипликативной группы. Здесь точно будет 0, а здесь 0 вот по нашему
[37:29.920 --> 37:50.880]  строю. Значит, мы получаем такой набор равенств. Это я подставил в многочлен просто в степени
[37:50.880 --> 38:11.360]  альфа. Дальше я могу подставить квадрат. Дальше я могу подставить какую-то степень G. Ну ладно,
[38:11.360 --> 38:27.320]  пусть будет i, у меня уже i появилось, пусть будет i. Ну тут много каких-то строчек. Ну и это все
[38:27.320 --> 38:39.320]  продолжается вплоть до альфа в степени l. Тут у меня равенство выполняется до 2R, но я сейчас
[38:39.320 --> 38:57.600]  предполагаю, что l не превосходит чем 2R и выпишу только l равенства. Вот это мы из построения кода
[38:57.600 --> 39:08.000]  получили такие равенства. Ну давайте теперь их изучать. Давайте представим себе такую матрицу,
[39:08.000 --> 39:32.840]  где-нибудь здесь я ее напишу. Составленную ровно из этих элементов. Здесь у меня будет альфа
[39:32.840 --> 39:42.800]  в степени i, а в степени aj. Вот такая матрица. Давайте я не знаю, а обозначу, это не очень важно,
[39:42.800 --> 39:52.800]  как я ее обозначу. Что мне дают вот эти l равенства? Эти l равенства говорят мне, что стумма столбцов
[39:52.800 --> 40:12.720]  а равна нулю. О, а у меня подошло время перерыва. Ну хорошо, значит, это тоже удачное место, потому что в
[40:12.720 --> 40:18.760]  этот момент вам все равно надо напрячься, вспомнить линейный алгебр. Если сумма столбцов равна нулю,
[40:18.760 --> 40:24.160]  то мы что-то можем сказать и про сумму строк, правда? Давайте сейчас сделаем перерыв, после перерыва это
[40:24.160 --> 40:31.680]  обсудим. Ну давайте, наверное, продолжим. Кто-то, по-моему, еще не вернулся с перерыва, но я начну...
[40:31.680 --> 40:44.840]  Ну, не то чтобы, а вот я их слышу. Давайте я просто повторю, на чем я остановился. Это очень важный
[40:44.840 --> 40:51.720]  момент. Вот эти равенства мы получили, фактически, из определения кода БЧХ. Теперь, если смотреть на эту
[40:51.720 --> 40:59.640]  матрицу, что эти равенства означают? Ну, действительно, если я возьму столбцы этой матрицы и сложу, то первая
[40:59.640 --> 41:05.840]  сумма – это сумма первых элементов столбца, вторая сумма – сумма вторых элементов столбца. Мы видим, что это все до 0.
[41:05.840 --> 41:14.720]  Это означает, что матрица вырожденная. У нас есть линейная комбинация столбцов, которая равна нулю.
[41:14.720 --> 41:23.040]  Нетривиальная линейная комбинация, не все коэффициенты равны нулю. Но вы знаете из линейной алгебры и
[41:23.040 --> 41:29.600]  доказательства переносятся на векторное пространство над любым полем буквально, теорему о том, что строчный
[41:29.600 --> 41:37.680]  ранг равен столбцовому. Если у вас есть нетривиальная линейная комбинация столбцов равная нулю, у вас
[41:37.680 --> 41:43.280]  обязана быть нетривиальная линейная комбинация строк тоже равная нулю. То есть, теперь я уже буду
[41:43.280 --> 41:50.120]  складывать вот так, выбирая какие-то множители. Ну, давайте мне их сейчас будет удобнее обозначить
[41:50.120 --> 41:59.720]  лямбда 0, лямбда L-1. Это множители, конечно, из поля из 2 степени S элементов. Эти же равенства в этом
[41:59.720 --> 42:14.160]  поле написаны. И что будет выполняться? Ну, давайте смотреть. Значит, у меня получится 0. Значит,
[42:14.280 --> 42:26.200]  если здесь у меня, как я индексировал, ну, это пусть будет G. Да, вот G у меня так и индексировано,
[42:26.200 --> 42:39.520]  все правильно. То есть, я должен буду сложить, и вот я нумирую от 0 до L-1, мне так удобнее. Я должен
[42:39.520 --> 42:52.360]  буду сложить, чтобы, если у меня житый столбец, то у меня альфа в степени i плюс 1. Смотрите,
[42:52.360 --> 42:58.240]  тут же, ведь я начинаю нумерацию с нуля, но у меня степени-то идут от единицы, поэтому тут надо
[42:58.240 --> 43:05.200]  не забыть вот этот сдвиг на единицу в степени а житое, но с вот этими коэффициентами лямбда иt.
[43:05.200 --> 43:27.520]  И вот это должно равняться нулю. Пои сумма для любого ж, которая от единицы до L. Но я эту сумму
[43:27.520 --> 43:33.420]  могу немножко переписать. Смотрите, во-первых, у меня появляется в каждом слагаемом общий
[43:33.420 --> 43:42.300]  множитель альфа в степени а житое. Я его вынесу за скобку. А в сумме я переставлю. Смотрите,
[43:42.300 --> 43:47.700]  тут у меня написано, что альфа в степени i, потом еще возводится в степень а житое. Но это то
[43:47.700 --> 43:52.940]  же самое, что альфа возвести степень i умножить на а житое, что в свою очередь то же самое,
[43:52.940 --> 44:11.060]  что в начале альфа возвести степень а житое, а потом степень i. То есть получается,
[44:11.060 --> 44:19.340]  что у нас вот такое выражение равно нулю. А что это вообще за выражение? А это вот что такое. Это
[44:19.340 --> 44:24.620]  значит, что у нас многочлен. У меня уже для многочленов использованы все буквы,
[44:24.620 --> 44:44.540]  какие только можно. Ну пусть будет p. p от x, вот такой многочлен, степень его не превосходит l.
[44:44.540 --> 45:00.180]  l-1, строго меньше l. И вот это равенство означает, что этот многочлен обращается в ноль в каждой
[45:00.180 --> 45:13.660]  степени а под первой дуэльтой. Вот что означает это равенство. Но смотрите, что у нас получилось.
[45:13.660 --> 45:17.980]  Мы построили многочлен, исходя из общей теоремы линейной алгебры о том,
[45:17.980 --> 45:25.180]  что строчность равенства в целом, мы построили многочлен, у которого степень строго меньше l,
[45:25.180 --> 45:32.820]  но l корней. Так не бывает. Мы знаем, что количество корней у ненулевого многочлена не превосходит
[45:32.820 --> 45:37.060]  многочлен. Должен быть ненулевой, потому что эти коэффициенты, должна быть нетривиальная
[45:37.060 --> 45:44.500]  линейная комбинация, обращающаяся в ноль. Ненулевой многочлен имеет корней не больше, чем его степень.
[45:44.500 --> 45:50.980]  Значит, мы пришли к противоречию. Я напомню, что доказательство противного, то есть я предположил,
[45:50.980 --> 46:00.060]  что вот такой многочлен входит в наш код. И пришел к противоречию, выяснилось, что это
[46:00.060 --> 46:09.100]  неминуемое влечество для некоторого многочлена степени не выше, чем l-1, есть l корней, что противоречит
[46:09.100 --> 46:16.460]  друг другу эти два условия. Вот таким образом доказана вот эта теория. Как видите, здесь анализ
[46:16.460 --> 46:22.140]  существенно сложнее, чем в случае кода Хемлинга. Нам уже нужна какая-то нетривиальная линейная алгебра,
[46:22.140 --> 46:30.820]  что-то такое нужно делать. Можно было бы, кстати, по-другому рассуждать. В нашем учебнике так написано
[46:30.820 --> 46:37.260]  тоже. Посмотреть на эту матрицу, увидеть, что это матрица Вандермонда, записать ее определитель и
[46:37.260 --> 46:43.420]  свести, по сути дела, вопрос к тому же, что было в случае кода Хемлинга. Там, если вы помните,
[46:43.420 --> 46:53.380]  как при директоре Вандермонда записываются там разности соответствующих элементов, и у нас
[46:53.380 --> 47:07.660]  получится, что так же, как в случае кода Хемлинга, какие-то две разности, которые меньше, чем n равны,
[47:07.660 --> 47:14.380]  это противоречит тому, что альфа порождающий. Вот такое рассуждение. Давайте опять-таки,
[47:14.380 --> 47:31.740]  вот тут у меня был выписан пример для код Хемлинга. Давайте теперь возьмем r равное 2, n возьмем
[47:31.740 --> 47:40.020]  то же самое, чтобы почисления были попроще. И попробуем построить код БЧХ. Теперь мне нужно
[47:40.020 --> 47:52.620]  больше. Мне нужно, я напомню, многочлен, который обращается в ноль в альфа в квадрат, в альфа в
[47:52.620 --> 48:03.180]  кубе, в альфа в четвертый. Ну, давайте начнем вот с того, что у нас уже есть, и увидим, что три корня
[48:03.180 --> 48:10.140]  вот этот вот многочлен покрывает. Потому что корнями этого многочлена будут альфа, потом в силу
[48:10.140 --> 48:15.580]  афтаморфизма, фрабениуса и альфа в квадрат, и альфа в четвертый. Но для альфа в кубе нужен
[48:15.580 --> 48:23.220]  другой многочлен. Я уже разбирался с тем, какой там должен быть многочлен, сейчас коротко напомню.
[48:23.220 --> 48:28.580]  Альфа в кубе, возведенный в пятую степень, равен единице, потому что порядок мультипликотинная
[48:28.580 --> 48:38.620]  группа 15. Поэтому я могу записать это так, как альфа в кубе минус один. Альфа в кубе минус
[48:38.620 --> 48:49.820]  один не равно нулю, а дальше написать сумму. То есть нам нужен еще вот этот у нас многочлен,
[48:49.820 --> 48:56.820]  и еще один многочлен, который состоит из, ну, все коэффициенты, который у нас в степени четыре, у
[48:56.820 --> 49:04.620]  которого все коэффициенты на единиц. Вот теперь мне надо перемножить эти два многочлена. Перемножать
[49:04.620 --> 49:18.460]  многочлены как-то всегда удобнее, записывая их в другом порядке. Я хочу это умножить на единицу
[49:18.460 --> 49:27.500]  плюс х плюс х четверть. Ну давайте. Для этого, значит, вот это я умножил на единицу. Если умножу
[49:27.500 --> 49:37.300]  на х, у меня получится вот такой многочлен. Если умножу на х четвертый, у меня получится такой
[49:37.300 --> 49:47.060]  многочлен х четвертый плюс х пятый плюс х шестой плюс х седьмой плюс х восьмой. И теперь только
[49:47.060 --> 49:51.620]  осталось сложить по модулю два эти коэффициенты. Значит, что у меня получится? У меня получится
[49:51.620 --> 49:59.620]  единица, х плюс х ноль, х квадрат плюс х квадрат ноль, х куб плюс х куб ноль, 3х четвертый даст нам х четвертый,
[49:59.620 --> 50:10.420]  это нечет. Количество х пятый опять-таки даст ноль, а х шестой, х седьмой, х восьмой останутся. Вот,
[50:10.420 --> 50:16.980]  то есть нужный нам код порождается классом вычетов, содержащих вот такой многочлен. То есть,
[50:16.980 --> 50:27.620]  если записывать опять-таки порождающую строчку, она будет выглядеть так. Она будет выглядеть один,
[50:27.620 --> 50:37.860]  дальше три нуля, первая, вторая, третья степень, дальше четвертая степень единица, пятая степень ноль,
[50:37.860 --> 50:45.780]  шестая, седьмая и восьмая степень единицы, ну и дальше девятая, десятая, одиннадцатая,
[50:45.780 --> 50:51.140]  двенадцатая, тринадцатая, четырнадцатая, пятьнадцатая. Вот если я возьму такую строчку,
[50:51.140 --> 50:59.780]  ну в ней уже, как вы видите, пять единиц. Если я возьму суммы циклических сдвигов этой строчки,
[50:59.780 --> 51:07.020]  то у меня получится сколько? Два в пятнадцатой минус степень многочлена в восемь, то есть два в
[51:07.020 --> 51:13.060]  седьмой, то двадцать восемь разных векторов. То есть, вот, заметьте, здесь гораздо больше,
[51:13.060 --> 51:19.100]  здесь уже существенно меньше. Но зато каждый из этих ста двадцати семи векторов, кроме нулевого,
[51:19.100 --> 51:28.140]  имеет не меньше пяти единиц. Ну, вот выдумать такую строчку из головы достаточно сложно. Я не знаю,
[51:28.140 --> 51:38.540]  достигал ли кто-то такого по степени просветления. Иногда на занятиях у меня студенты находят
[51:38.540 --> 51:42.140]  неожиданные решения алгебрических значений, то есть, действительно догадываются до каких-то очень
[51:42.140 --> 51:46.820]  нетривиальных равенств. Но вот это я даже никогда не пробовал. Ну, понятно, что это в рамках
[51:46.820 --> 51:52.940]  семинара и невозможно, но так, чтобы человек просто посидел, подумал и придумал, какими циклическими
[51:52.940 --> 52:01.340]  сдвигами получить код с кодовым расстоянием 5, я не знаю. Вы тоже теперь испорчены, потому что я вам
[52:01.340 --> 52:06.260]  рассказал науку, как получается такая строка. То есть, это надо взять человека девственного,
[52:06.260 --> 52:10.620]  который вот, ну, что-то про линейный алгебр, хотя бы знать, чтобы было понятно, что такое сумма по
[52:10.620 --> 52:16.940]  модулю два этих векторов, что такое циклические сдвиги, но который вот не изучал конечные поля.
[52:16.940 --> 52:26.940]  Это не так легко таких людей найти. Но, в общем, я не знаю и думаю, что это действительно очень
[52:26.940 --> 52:33.020]  трудно, потому что догадаться, ну, как, ну, посмотрите, какая-то совершенно идиотская, никакой особой
[52:33.020 --> 52:38.540]  симметрии в этом нет. Наверное, у кода БЧХ есть более симметричные порождающие. Я сейчас чуть-чуть
[52:38.540 --> 52:47.940]  это прокомментирую про другой код, но не очень понятно, как их искать. Но, тем не менее, вот такой
[52:47.940 --> 52:55.700]  вот пример есть. То есть, мы получаем один из кодов БЧХ. Теперь следующий вопрос, который я
[52:55.700 --> 53:03.060]  хотел бы обсудить, это насколько вообще коды БЧХ хорошие? Что я имею в виду? Ну, мы знаем две
[53:03.060 --> 53:09.060]  оценки. Верхняя оценка Хэминга, вот код Хэминга вообще замечательный, он просто сажается на верхнюю
[53:09.060 --> 53:21.380]  оценку, он совершенный. А что с кодами БЧХ? Давайте я для простоты записи на доске пропускал индексы,
[53:21.380 --> 53:28.980]  давайте я теперь напишу у меня два параметра, которые задают этот код. Ну, длина, это 2 в степени
[53:28.980 --> 53:37.860]  s-1 и r количество ошибок. Вот я написал s и r. Мы знаем, что в коде не меньше векторов, чем 2 в степени
[53:37.860 --> 53:50.900]  размерности. И мы знаем, что не больше, чем 2 в степени n поделить на объем хэмингового шара
[53:50.900 --> 53:57.580]  равномерного радиуса r. Это граница Хэминга, больше не бывает. Вот давайте сравним, то есть по
[53:57.580 --> 54:06.860]  спасуте дела, насколько код БЧХ хорош. Это определяется отношением двух величин. Почему? Вот тут
[54:06.860 --> 54:15.780]  давайте вспомним, нас интересует передача информации. Если у нас 2 в степени k кодовых слов,
[54:15.780 --> 54:22.860]  мы можем передавать k битов. Поэтому резонно считать все-таки не размер кода, а логарифм
[54:22.860 --> 54:28.940]  размера кода. Как бы будет количество битов, сколько мы теряем в передаче информации. Поэтому
[54:28.940 --> 54:35.460]  нужно взять просто отношение этих двух оценок, ну и взять его логарифм. Отношение этих оценок
[54:35.460 --> 54:44.060]  какое? Смотрите, 2 в степени n, 2 в степени n сократится. Останется, если я поделю вот это вот на это,
[54:44.060 --> 55:01.340]  получится 2 в степени rс поделить вот на объем шара. 2 в степени s это n плюс 1 в степени r. А объем
[55:01.340 --> 55:09.460]  шара, вот давайте посмотрим вот в такой симпатической постановке. Длина кода стремится к бесконечности,
[55:09.540 --> 55:16.460]  а количество ошибок просто фиксировано, какая-то константа. Тогда как у нас будет
[55:16.460 --> 55:38.820]  определяться объем мерного шара? Ну на самом деле с точностью до, ну он асимпатически должен
[55:38.820 --> 55:46.180]  быть вот таким. Почему? Потому что сумма биномиальных коэффициентов, это самый большой биномиальный
[55:46.180 --> 55:51.820]  коэффициент. Самая большая степень n, которая может быть в биномиальном коэффициенте. У нас биномиальные
[55:51.820 --> 55:59.340]  коэффициенты берутся из n по i, где i до r. То есть в биномиальном коэффициенте из n по r у нас будет
[55:59.340 --> 56:07.740]  степень n степени r, ну делить на, ну там не n, прям буквально степени r, поэтому я тут пишу не строгое
[56:07.740 --> 56:16.020]  равенство некоторую асимптотику, но асимптотически это вот примерно столько же. Значит тут получится n
[56:16.020 --> 56:25.620]  степени r, а тут еще получится r factorial. И что мы видим? Что это, если r константа, это очень
[56:25.620 --> 56:37.660]  хорошая вещь. Это o от единицы. То есть мы теряем, по сравнению с идеальной ситуацией, мы теряем
[56:37.660 --> 56:46.700]  константу битов. Нам же нужно взять потом логарифм этой величины, это и будет количество лишних битов,
[56:46.700 --> 56:57.740]  по сравнению с оценкой Хэминга, которую мы используем в коде BCH. Ну и если r константа, то вообще все
[56:57.740 --> 57:03.740]  замечательно. Мы теряем некоторую константу битов. Такие коды называются квазисовершенными,
[57:03.740 --> 57:10.260]  насколько я знаю их классификация как раз полностью неизвестна. Ну и тут определение уже более
[57:10.260 --> 57:18.100]  сложное. Мы должны брать серии кодов, когда для нас стремится к бесконечности. В общем, это такое менее
[57:18.100 --> 57:26.260]  формализуемое понятие, но слово такое используется. И это объясняет, почему коды BCH, их изобрели
[57:26.260 --> 57:31.700]  практически сразу, как возникли задачи теории кодирования, вот исправление ошибок. Их изобрели
[57:31.700 --> 57:38.100]  очень быстро, потому что инженеры нашли правильных математиков, которые вот все это знали и сделали
[57:38.100 --> 57:50.220]  соответствующие выводы. Для тогдашней математики, кстати, нельзя сказать, что это была очень модная
[57:50.220 --> 57:57.780]  тематика, конечные поля и все такое. То есть сама теория уже была, но она скорее была в стороне. Она
[57:57.780 --> 58:05.220]  стала очень популярной с развитием теоретической информатики. А до этого, ну да, вот были, да не
[58:05.220 --> 58:10.460]  только с развитием теоретической информатики, с тем, что в конце 50-х годов был такой великий
[58:10.460 --> 58:16.300]  математик Гротендик, он поставил перед математиками еще амбициозную цель – объединить анализ и
[58:16.300 --> 58:22.100]  арифметику. То есть развить все теоремы, которые есть в теории чисел, все теоремы в анализе,
[58:22.100 --> 58:27.780]  чтобы это были частные случаи некоторых общих теорем. Поэтому математики стали очень интересоваться
[58:27.780 --> 58:34.500]  конечной характеристикой. Она, естественно, связана с теорией чисел. Ну, мы уже видели много связей.
[58:34.500 --> 58:41.460]  И вот с этого момента конечная характеристика стала очень важна. А коды появились раньше. Ну, я точно
[58:41.460 --> 58:45.020]  историю математики не знаю, может быть, уже к этому времени многие понимали, что конечная
[58:45.020 --> 58:51.540]  характеристика важна. Так статей было не очень много, по крайней мере. Ну, и это, конечно,
[58:51.540 --> 58:58.180]  инженеров очень устраивало, потому что я про это говорить уже точно не буду, но для кодов БЧХ есть
[58:58.180 --> 59:03.700]  и хорошие алгоритмы декодирования. Кодировать циклический код вообще инженерам было довольно
[59:03.700 --> 59:07.860]  легко, потому что в сущности вот эти вот циклические сдвиги — это довольно простая
[59:07.860 --> 59:16.860]  электрическая схема, которая их осуществляет. И сложение по модулю 2 достаточно легко
[59:16.860 --> 59:22.660]  реализуется. Поэтому инженеры были страшно счастливы, что есть такие хорошие коды.
[59:22.660 --> 59:30.980]  Составляются таблицы оптимальных кодов при конкретных значениях длин кодовых расстояний
[59:30.980 --> 59:36.300]  и размерности. И коды БЧХ в некоторых случаях просто оптимальные. Лучше не бывает. Но таких
[59:36.300 --> 59:47.500]  случаев мало. И где коды БЧХ совсем плохи — это в том случае, когда мы хотим исправлять очень много
[59:47.500 --> 59:53.740]  ошибок. Более естественная ситуация — это же мы блочное кодирование рассматриваем — состоит
[59:53.740 --> 59:59.860]  в том, что оно вообще очень большое. Это прям все наше сообщение. И у нас есть какая-то фиксированная
[59:59.860 --> 01:00:04.340]  доля ошибок. То есть канал, он ошибается в одном проценте случаев или в одном тысячный
[01:00:04.340 --> 01:00:10.660]  проценте случаев с какой-то частотой. И тогда нам нужно исправлять уже ошибок не константное
[01:00:10.660 --> 01:00:17.140]  количество, а пропорциональное длине передаваемого сообщения. И вот тут мы видим, что коды БЧХ
[01:00:17.140 --> 01:00:25.540]  становятся бесконечно плохими, потому что эрофакториал вот этот, он все портит. Тем не менее,
[01:00:25.540 --> 01:00:31.460]  такие, как говорят, асимпатически хорошие коды существуют. Они строятся на основе совсем другой
[01:00:31.460 --> 01:00:39.660]  алгебры. В основном там нужна скорее нетривиальная линейная алгебра и связанные с ней вещи. Но в
[01:00:39.660 --> 01:00:46.420]  некоторых ситуациях бывают нужны действительно и поля. Хотя там конечные поля используются
[01:00:46.420 --> 01:00:52.380]  скорее уже в более экзотических конструкциях. Не напрямую в конструкциях асимпатически
[01:00:52.380 --> 01:00:58.860]  оптимальных кодов, а в более сложных ситуациях. Про которые я говорить не буду. Но ситуации
[01:00:58.860 --> 01:01:04.100]  типовые, о которых я говорил, что мы из вероятностных соображений знаем, что какой-то комбинаторный
[01:01:04.100 --> 01:01:08.740]  объект есть, мы хотим его построить. До сих пор есть такие объекты, про которые мы знаем,
[01:01:08.740 --> 01:01:15.340]  что они существуют, но удобных явных конструкций у нас нет. Но вот близкие к этим конструкциям
[01:01:15.340 --> 01:01:22.380]  рекордные результаты, они тоже получаются с помощью полей. Причем там, вот чего мы здесь не
[01:01:22.380 --> 01:01:27.900]  использовали, это структуры подполей в конечных полях. На самом деле в теоретической информатике
[01:01:27.900 --> 01:01:35.620]  есть и такие задачи, где и это бывает важно. Вот в частности для этих более сложного обобщения
[01:01:35.620 --> 01:01:44.020]  корректирующих кодов, которые называются экстракторы. Это такая неформально очень интересная задача.
[01:01:44.020 --> 01:01:48.520]  У вас есть источник случайных битов, но плохой. Он дает неравномерную случайность, а какую-то
[01:01:48.520 --> 01:01:54.780]  искаженную. А вы хотите сделать следующее. Хотите подлить к нему немного настоящую случайность.
[01:01:54.780 --> 01:02:00.200]  Но совсем мало. У вас где-то есть очень надежный источник действительно равномерных независимых
[01:02:00.200 --> 01:02:05.800]  случайных битов. И вы хотите как можно меньше당 источника использовать. Он дорогой. А вот этот
[01:02:05.800 --> 01:02:12.060]  грязный источник он дешевый. Вот вы хотите смешать немножко чистой случайности с нечистой, с тем,
[01:02:12.060 --> 01:02:14.780]  чтобы результат был очень близок к чистой случайности.
[01:02:14.780 --> 01:02:17.060]  Это называется экстрактор.
[01:02:17.060 --> 01:02:21.660]  И вот для экстракторов там есть разные конструкции.
[01:02:21.660 --> 01:02:27.220]  Те, которые получаются, они конечные поля не используют,
[01:02:27.220 --> 01:02:30.420]  но в некоторых ситуациях там действительно тоже
[01:02:30.420 --> 01:02:31.940]  бывают нужны конечные поля.
[01:02:31.940 --> 01:02:35.540]  В общем, это заведомо я не успею оставшееся время
[01:02:35.540 --> 01:02:36.540]  рассказать.
[01:02:36.540 --> 01:02:39.580]  Ну, так просто, чтобы вы имели в виду.
[01:02:39.740 --> 01:02:42.220]  Что я хотел сказать по поводу конечных полей, что они действительно
[01:02:42.220 --> 01:02:44.580]  используются самыми разными целями.
[01:02:44.580 --> 01:02:48.260]  Много примеров мне привести не удаётся.
[01:02:48.260 --> 01:02:50.300]  Давайте я приведу один пример, который, по-моему,
[01:02:50.300 --> 01:02:55.620]  даже есть в сборнике задач, которые вам выдан.
[01:02:55.620 --> 01:03:00.340]  Я не уверен, но, по-моему, есть.
[01:03:00.340 --> 01:03:02.380]  Он короткий, я его сейчас быстро приведу.
[01:03:09.580 --> 01:03:24.620]  Допустим, мы хотим найти в группе перестановок
[01:03:24.620 --> 01:03:27.260]  9 элементов по группе 72 элементов.
[01:03:27.260 --> 01:03:29.540]  Ну, вот захотелось бы.
[01:03:29.540 --> 01:03:31.980]  Вам, может быть, и не захотелось, но от вас этого требует
[01:03:31.980 --> 01:03:32.980]  задавальник.
[01:03:32.980 --> 01:03:34.980]  Откуда её взять?
[01:03:35.180 --> 01:03:39.620]  Ну, мы помним, там возникают проблемы, одних арифметических
[01:03:39.620 --> 01:03:40.820]  условий недостаточно.
[01:03:40.820 --> 01:03:44.540]  Конечно, 72 это 8 на 9, и это делитель 9 факториалов.
[01:03:44.540 --> 01:03:45.940]  То есть, противоречия стеоремы Л.
[01:03:45.940 --> 01:03:46.940]  Э.
[01:03:46.940 --> 01:03:47.940]  Гранжа нет.
[01:03:47.940 --> 01:03:50.340]  Но мы знаем, что не для любого порядка есть соответствующая
[01:03:50.340 --> 01:03:51.340]  подгруппа.
[01:03:51.340 --> 01:03:53.020]  Откуда взять эту подгруппу?
[01:03:53.020 --> 01:03:54.020]  Заранее непонятно.
[01:03:54.020 --> 01:03:56.900]  Ну, вот смотрите, что я делаю.
[01:03:56.900 --> 01:04:00.180]  Я вижу, что 9 – это степень простого.
[01:04:00.180 --> 01:04:04.580]  То есть, это 3 в квадрате умножить на 3 в квадрате
[01:04:04.580 --> 01:04:05.580]  минус 1.
[01:04:05.580 --> 01:04:06.580]  Ага, говорю я.
[01:04:06.580 --> 01:04:11.580]  Так, может быть, это что-то, связанное с конечным полем
[01:04:11.580 --> 01:04:12.580]  из 9 элементов.
[01:04:12.580 --> 01:04:15.580]  Ну, хорошо.
[01:04:15.580 --> 01:04:17.700]  А что же может быть связано, какая группа может быть
[01:04:17.700 --> 01:04:23.140]  связана с перестановки этого поля из 9 элементов?
[01:04:23.140 --> 01:04:26.020]  Ну, и такое перестановки.
[01:04:26.020 --> 01:04:28.460]  Ну, давайте что-нибудь самое простое сделаем.
[01:04:28.460 --> 01:04:31.900]  Ну, у нас есть самые простые биоктивные преобразования
[01:04:31.900 --> 01:04:32.900]  поля.
[01:04:32.900 --> 01:04:33.900]  Линейные функции.
[01:04:33.900 --> 01:04:49.900]  То есть, я беру не нулевое а, и беру вот такую линейную
[01:04:49.900 --> 01:04:50.900]  функцию.
[01:04:50.900 --> 01:04:53.740]  Она обратима, потому что раз а не равно нулю, мы можем
[01:04:53.740 --> 01:04:55.980]  написать обратную функцию.
[01:04:55.980 --> 01:04:57.340]  Там коэффициент будет единиц на а.
[01:04:57.340 --> 01:05:03.700]  Значит, это и, что существенно, композиции линейных функций,
[01:05:03.700 --> 01:05:04.700]  они тоже линейные.
[01:05:04.700 --> 01:05:09.380]  Если я сюда подставлю линейную функцию, то у меня получится
[01:05:09.380 --> 01:05:10.380]  линейная функция.
[01:05:10.380 --> 01:05:13.460]  Значит, это действительно получается перестановки.
[01:05:13.460 --> 01:05:14.460]  А сколько их будет?
[01:05:14.460 --> 01:05:19.980]  Ну, вот коэффициентов 8, свободных членов 9.
[01:05:20.980 --> 01:05:33.500]  Ну, а можно еще, ну, давайте я не буду, там скажем, группы
[01:05:33.500 --> 01:05:36.200]  перестановок из 10 элементов, можно уж совсем большую под
[01:05:36.200 --> 01:05:40.940]  группу найти, нетривиальную, которую так сразу не построишь.
[01:05:40.940 --> 01:05:43.620]  Но давайте я отвлекаться не буду, потому что я хотел
[01:05:43.620 --> 01:05:46.660]  бы полностью мне это рассказать, все равно я не успеваю, я
[01:05:46.660 --> 01:05:47.660]  уже прикинул.
[01:05:47.820 --> 01:05:51.220]  Но я упоминал, что есть еще один совершенный код, кроме
[01:05:51.220 --> 01:05:54.340]  кодов Хемминга, и он тоже циклический.
[01:05:54.340 --> 01:05:59.860]  То есть не случайно я так переоточился на циклических
[01:05:59.860 --> 01:06:02.420]  кодах, это так называемый код Галлея.
[01:06:02.420 --> 01:06:10.300]  У него параметры такие, длина 23, размерность 12 и кодовое
[01:06:10.300 --> 01:06:11.300]  расстояние 7.
[01:06:11.300 --> 01:06:12.580]  То есть он исправляет три ошибки.
[01:06:12.580 --> 01:06:14.660]  И он совершенный.
[01:06:14.660 --> 01:06:19.180]  То, что он совершенный, это, по сути дела, означает,
[01:06:19.180 --> 01:06:29.420]  вот что, что размерность 12, это значит, что 2 в 12 равно,
[01:06:29.420 --> 01:06:33.420]  ну вот объем у Хемминга, 2 в 11, извините, на границе
[01:06:33.420 --> 01:06:41.940]  Хемминга вот так вот записывается, то есть если я поделю, у меня
[01:06:42.300 --> 01:06:49.700]  2 в 11 равно вот этому вот самому объему шара, то есть единица
[01:06:49.700 --> 01:07:00.340]  плюс биномиальная коэффициента 23 на 1, 23 на 2, плюс 23 на 3.
[01:07:00.340 --> 01:07:04.540]  Ну, это равенство, как вы понимаете, по каким-то
[01:07:04.540 --> 01:07:06.940]  довольно мистическим причинам возникает.
[01:07:06.940 --> 01:07:11.420]  Ну, что это такое?
[01:07:11.420 --> 01:07:15.020]  На самом деле, если чуть-чуть упростить, это получится
[01:07:15.020 --> 01:07:19.380]  1 плюс 23 умножить на 89, и это действительно чудесным
[01:07:19.380 --> 01:07:26.860]  образом ровняется 2048, но никаких внятных причин,
[01:07:26.860 --> 01:07:28.700]  почему такое равенство берется, у нас нет.
[01:07:28.700 --> 01:07:31.620]  Вот просто случайно появилось такое рифметическое равенство.
[01:07:31.620 --> 01:07:35.340]  И на самом деле, то, что совершенных кодов мало,
[01:07:35.340 --> 01:07:38.660]  это как раз из-за того, что для совершенного кода
[01:07:38.740 --> 01:07:41.700]  нам нужно вот такого типа соотношения между параметрами,
[01:07:41.700 --> 01:07:44.140]  чтобы сумма начальных биномиальных коэффициентов
[01:07:44.140 --> 01:07:46.340]  ровнялась к какой-то степени двойки.
[01:07:46.340 --> 01:07:48.580]  Это довольно редкое явление.
[01:07:48.580 --> 01:07:51.380]  То есть у нас есть коды Хэминга, но там понятно, почему,
[01:07:51.380 --> 01:07:55.420]  потому что у нас радиус единицы, вот здесь вот совсем
[01:07:55.420 --> 01:07:56.980]  простое число написано.
[01:07:56.980 --> 01:08:01.980]  Если мы берем уже две ошибки, у нас будет здесь
[01:08:01.980 --> 01:08:03.940]  какой-то нетривиальный биномиальный коэффициент,
[01:08:03.940 --> 01:08:06.580]  и уже подобрать довольно сложно.
[01:08:06.580 --> 01:08:07.900]  Ну, и оказывается, что невозможно.
[01:08:07.900 --> 01:08:10.860]  В общем, это целое дело, я вдаваться в это не буду.
[01:08:10.860 --> 01:08:14.460]  Тем не менее, код Галлея существует.
[01:08:14.460 --> 01:08:16.940]  Как его определить?
[01:08:16.940 --> 01:08:19.460]  Ну, это я точно успею сделать.
[01:08:19.460 --> 01:08:22.260]  Он циклический, поэтому, чтобы его задать, мне нужны
[01:08:22.260 --> 01:08:24.940]  коэффициенты многочлены, я пока напишу показатель
[01:08:24.940 --> 01:08:25.940]  степеней.
[01:08:25.940 --> 01:08:38.620]  Значит, у нас n равно 23, значит, мне нужны вычеты по модулю
[01:08:38.620 --> 01:08:45.860]  х23-1, значит, мне нужны коэффициенты до 22.
[01:08:45.860 --> 01:08:51.940]  Ну, давайте, сейчас я попробую выписать эти коэффициенты.
[01:08:52.940 --> 01:09:11.940]  Ноль, один, один, один, один, один, один, один, кто-нибудь
[01:09:11.940 --> 01:09:18.060]  догадался, в каких местах я ставлю единицы?
[01:09:18.060 --> 01:09:19.060]  Квадраты, да.
[01:09:19.180 --> 01:09:23.060]  Я, на самом деле, отмечаю единицами квадратичные
[01:09:23.060 --> 01:09:24.860]  вычеты по модулю 23.
[01:09:24.860 --> 01:09:27.660]  Ну, теперь, после того, как я признался, и мы видим,
[01:09:27.660 --> 01:09:31.860]  что двойка квадратичный вычет, и она же автоморфизма
[01:09:31.860 --> 01:09:35.460]  Фрабениуса, поэтому дело можно быстрее провести.
[01:09:35.460 --> 01:09:37.860]  Можно просто умножать на двойку, это квадратичный
[01:09:37.860 --> 01:09:38.860]  вычет.
[01:09:38.860 --> 01:09:45.700]  Значит, 1, 4, 8, что мне не хватает?
[01:09:45.700 --> 01:09:47.220]  Тройку надо как-то получить.
[01:09:47.380 --> 01:09:56.580]  А, ну это 13 на 2, это 26, значит, теперь шестерка отсюда
[01:09:56.580 --> 01:10:10.620]  сразу возьмется, 12 отсюда возьмется, 4, 8, 6, 12, 16 на 2,
[01:10:10.620 --> 01:10:16.260]  32, то есть, 9 уже есть, 18 на 2, 36, 13 есть, а сколько
[01:10:16.300 --> 01:10:17.300]  у меня?
[01:10:17.300 --> 01:10:22.180]  4, 7, а, так уже все, смотрите, 4, 7, 10, 11.
[01:10:22.180 --> 01:10:25.380]  Мы знаем, что вычитав и не вычитав поровну, я уже
[01:10:25.380 --> 01:10:27.060]  11 нашел, все, хватит.
[01:10:30.660 --> 01:10:34.620]  То есть, вот появляется такая волшебная строчка, длины
[01:10:34.620 --> 01:10:39.260]  23, и я утверждаю, что если брать циклические сдвиги
[01:10:39.260 --> 01:10:44.180]  этой строчки и их суммы по модулю 2, то у меня получится
[01:10:44.180 --> 01:10:51.140]  4096 различных сумм, и в каждой такой ненулевой сумме будет
[01:10:51.140 --> 01:10:52.140]  хотя бы 7 единиц.
[01:10:52.140 --> 01:11:00.100]  Ну вот, как это понять, непонятно, причем, заметьте, тут уже
[01:11:00.100 --> 01:11:02.940]  ясно, что я в качестве порождающего, давайте этот многочлен
[01:11:02.940 --> 01:11:08.620]  с такими коэффициентами обозначу Q от X, ну, более
[01:11:08.620 --> 01:11:13.580]  обычным способом его можно представить вот так, Q23,
[01:11:13.580 --> 01:11:22.900]  это квадротичные вычеты по модулю 23, ну, M23, давайте
[01:11:22.900 --> 01:11:36.580]  я сразу определю, это квадротичные не вычеты, но вот такой
[01:11:36.580 --> 01:11:40.740]  простой способ, немонический, который позволяет запомнить,
[01:11:40.740 --> 01:11:44.300]  как вообще строить код Галлея, потому что сообразить
[01:11:44.300 --> 01:11:47.100]  про квадротичные вычеты легко, значит, код Галлея
[01:11:47.100 --> 01:11:52.300]  это точности циклический код, порожденный классом
[01:11:52.300 --> 01:12:00.140]  вычетов, содержащих вот этот многочлен Q, но сразу
[01:12:00.140 --> 01:12:03.340]  вычислить размерность трудно, потому что, вот смотрите,
[01:12:03.340 --> 01:12:08.980]  тут нужно быть аккуратным, потому что размерность,
[01:12:09.220 --> 01:12:12.220]  вот эта формула требует, чтобы порождающий многочлен
[01:12:12.220 --> 01:12:17.340]  был делителем X в НТ без единиц, а это, конечно, не так
[01:12:17.340 --> 01:12:20.500]  для этого многочленов, ну, может быть, это не столь
[01:12:20.500 --> 01:12:35.060]  очевидно, но давайте вообще поймем, какие у нас неприводимые
[01:12:35.060 --> 01:12:41.860]  делители у многочлена X23-1, ну, я обсуждал, как с помощью
[01:12:41.860 --> 01:12:44.700]  автоморфизма Фробениуса находить неприводимые делители
[01:12:44.700 --> 01:12:48.060]  у такого многочлена, надо просто построить орбиты
[01:12:48.060 --> 01:12:52.500]  Фробениуса, они будут отвечать корням неприводимых многочленов,
[01:12:52.500 --> 01:12:55.340]  и у нас получается одна орбита отвечает показателю
[01:12:55.340 --> 01:13:05.780]  0, это вот это, а дальше есть орбита длины 11, которая
[01:13:05.780 --> 01:13:09.260]  отвечает квадратичным вычетам, двое как квадратичный
[01:13:09.260 --> 01:13:12.900]  вычет, если я умножаю на два, то я снова получаю квадратичный
[01:13:12.900 --> 01:13:21.540]  вычет, и 2 в 11 равно, раз это квадратичный вычет, то
[01:13:22.420 --> 01:13:29.980]  равно 1 по модулю 23, но 11 простое число, поэтому в меньших
[01:13:29.980 --> 01:13:32.580]  степенях мы будем получать не единицу, значит, у нас
[01:13:32.580 --> 01:13:36.780]  здесь будет орбита длины 11, ну, а не вычетая это все
[01:13:36.780 --> 01:13:43.420]  остальное, ну, скажем, вот с X5 что ли, начиная, я бы
[01:13:43.420 --> 01:13:54.260]  даже начал с X22, которая X-1. Заметьте, что X-1 в нашем
[01:13:54.260 --> 01:13:57.700]  кольце это то же самое, что X22, а минус единица это
[01:13:57.700 --> 01:14:00.300]  квадратичный вычет, потому что минус единица в 11 степени
[01:14:00.300 --> 01:14:05.380]  это минус единица, значит, у нас получается вот такое
[01:14:05.380 --> 01:14:11.940]  разложение на неприводимые множества, и мы знаем, что
[01:14:11.940 --> 01:14:14.980]  наш многочлен, раз он задает какой-то нетривиальный код,
[01:14:14.980 --> 01:14:18.300]  он должен иметь нетривиальный наибольший общий делитель
[01:14:18.300 --> 01:14:28.020]  с этим, ну, с каким? Так заранее не ясно. Тут нужно некоторое
[01:14:28.020 --> 01:14:32.380]  вычисление. Давайте найдем в каком-нибудь поле характеристики
[01:14:32.380 --> 01:14:39.420]  2 корень 23 степени из единиц, то есть такой элемент поля,
[01:14:39.420 --> 01:14:44.500]  который порождает циклическую группу порядка 23. И подставим
[01:14:44.500 --> 01:14:51.620]  в наш многочлен. И даже не просто подставим в наш многочлен,
[01:14:51.620 --> 01:15:20.100]  сразу заведем в квадрат. Смотрите, что я делаю. Я
[01:15:20.100 --> 01:15:22.460]  развожу квадрат, но у меня в полях характеристики
[01:15:22.460 --> 01:15:26.740]  два возведения в квадрат. Это применение автоморфизма
[01:15:26.740 --> 01:15:30.260]  фробениуса, то есть это сумма слагаемых возведенных
[01:15:30.260 --> 01:15:35.020]  квадрат. Но два – квадратичный вычет, поэтому если я и умножаю
[01:15:35.020 --> 01:15:39.860]  на 2, я получаю снова квадратичный вычет. Мы просто такой сдвиг
[01:15:39.860 --> 01:15:42.100]  в подгруппе квадратичных вычетов делаем. Значит,
[01:15:42.100 --> 01:15:46.660]  мы получаем равенство. Q от ω в квадрате равняется
[01:15:46.660 --> 01:15:52.900]  Q от ω. Но отсюда следует, что Q от ω – это элемент
[01:15:52.900 --> 01:15:58.980]  поля из двух элементов. Вспомним, что если какое-то
[01:15:58.980 --> 01:16:03.740]  число x в степени p равняется x, то это означает, что оно
[01:16:03.740 --> 01:16:06.460]  в каком-то конечном поле, это означает характеристики
[01:16:06.460 --> 01:16:08.420]  p. Это означает, что оно просто принадлежит простому
[01:16:08.420 --> 01:16:13.660]  подполю. Значит, Q от ω – это 0 или 1. Теперь я могу проделать
[01:16:13.660 --> 01:16:27.580]  то же самое с ω в минус 1. Тут будет минус 2 и поскольку
[01:16:27.580 --> 01:16:33.460]  у нас минус, то это мы получаем сдвиги вдоль квадратичных
[01:16:33.460 --> 01:16:37.180]  вычетов. В общем, будет вот такое вот разница. А с другой
[01:16:37.180 --> 01:16:53.700]  стороны, вот это равно 0, ω – 1 – 0 не равно, значит,
[01:16:53.700 --> 01:16:56.580]  мы получаем, что сумма вот такой геометрической
[01:16:56.580 --> 01:17:00.260]  прогрессии должна равняться 0. Но из чего она состоит?
[01:17:00.260 --> 01:17:06.540]  Она состоит из единицы плюс значения в ω, плюс значения
[01:17:06.540 --> 01:17:10.300]  в ω минус 1. То есть я беру сумму по квадратичным вычетам
[01:17:10.300 --> 01:17:14.820]  в степени ω и сумму по квадратичным невычетам
[01:17:14.820 --> 01:17:18.500]  в степени ω. То есть мы видим, что не просто что эти два
[01:17:18.500 --> 01:17:21.180]  числа принадлежат полю из двух элементов, а они должны
[01:17:21.180 --> 01:17:23.980]  быть разными. Потому что если мы к ним, к их сумме
[01:17:23.980 --> 01:17:26.940]  еще добавим единицу, мы должны получить 0. Значит,
[01:17:26.940 --> 01:17:29.900]  к их сумме они должны давать единицу. И у нас есть два
[01:17:29.900 --> 01:17:33.820]  выбора – считать, что вот это равно 0, а то равно единице,
[01:17:33.820 --> 01:17:35.420]  или наоборот считать, что это равно единице, а то
[01:17:35.420 --> 01:17:40.020]  равно 0. И, как я уже говорил, тут полная асимметрия. Если
[01:17:40.020 --> 01:17:43.460]  ω заменю на ω минус 1, то у меня все равно будет порождать
[01:17:43.460 --> 01:17:47.660]  ту же самую циклическую группу. Поэтому ничего не изменится.
[01:17:47.660 --> 01:17:49.620]  Поэтому без ограничения общности можно считать,
[01:17:49.620 --> 01:18:06.020]  что q от ω равно 0. Ну и тогда смотрите, q от ω равно 0, и у нас
[01:18:06.020 --> 01:18:11.580]  вот есть два этих множителя. Один из них будет равен
[01:18:11.580 --> 01:18:13.060]  0, другой не будет равен 0.
[01:18:19.620 --> 01:18:25.500]  Потому что q, конечно, не является вот такой суммой гиметрической
[01:18:25.500 --> 01:18:33.300]  праведности. Мы получаем, что тот же самый код Галлея
[01:18:33.300 --> 01:18:40.140]  порождается вот этим вот в многочленом степени 11.
[01:18:40.140 --> 01:18:42.740]  Раз он порождается в многочленом степени 11, его размерность
[01:18:42.740 --> 01:18:50.860]  23 минус 11, как раз 12. Ну и начинается самое интересное.
[01:18:50.860 --> 01:18:56.220]  Но наступает утро, шахеризация прекращает дозволенные
[01:18:56.220 --> 01:18:59.500]  речи. То есть кодовое расстояние. Я не объяснил, почему кодовое
[01:18:59.500 --> 01:19:03.100]  расстояние 7. Это, конечно, самое интересное. Ну вы можете
[01:19:03.100 --> 01:19:07.940]  посмотреть в нашей книжке, лучше в файле, который выложен
[01:19:07.940 --> 01:19:12.060]  на странице кафедры и на странице курса, то, что
[01:19:12.060 --> 01:19:15.340]  называется расширенная версия учебника. Там приводится
[01:19:15.340 --> 01:19:17.820]  достаточно элементарный анализ, который дает вот
[01:19:17.820 --> 01:19:20.700]  это кодовое расстояние 7. Поскольку у меня осталось
[01:19:20.700 --> 01:19:23.620]  буквально минуты, я скажу, что на самом деле правильный
[01:19:23.620 --> 01:19:29.340]  анализ другой. Нужно из этого кода сделать код длины
[01:19:29.340 --> 01:19:36.020]  24 той же самой размерности, но с кодовым расстоянием
[01:19:36.020 --> 01:19:40.620]  8. Это делается очень просто. Нужно добавить к каждой
[01:19:40.620 --> 01:19:43.380]  кодовой нашей строчки еще проверку на четность.
[01:19:43.380 --> 01:19:46.820]  Вот тут у нас 11 единиц, значит, мы должны в дополнительной
[01:19:46.820 --> 01:19:50.980]  позиции, которая бесконечности обычно обозначается, поставить
[01:19:50.980 --> 01:19:53.340]  единицу. А если будет четное число единиц, поставить
[01:19:53.340 --> 01:20:00.260]  0. И получим код, у которого кодовое расстояние в 8. Более
[01:20:00.260 --> 01:20:05.860]  того, там веса всех кодовых слов, они кратны 8, 8, 16 или
[01:20:06.860 --> 01:20:12.260]  0. И это можно доказать гораздо более интересным способом,
[01:20:12.260 --> 01:20:15.940]  чем тот, который я написал, элементарный. Но у нас совершенно
[01:20:15.940 --> 01:20:18.940]  нет времени, там надо и дробно-линейное преобразование
[01:20:18.940 --> 01:20:23.060]  вначале изучить, вообще понять. То есть там действительно
[01:20:23.060 --> 01:20:26.860]  существенно, что у нас есть не просто поле из 23 элементов,
[01:20:26.860 --> 01:20:31.900]  а есть вот поле из 23 элементов плюс бесконечность. И вот
[01:20:31.900 --> 01:20:34.500]  на нем действует дробно-линейное преобразование. Вот этот
[01:20:34.500 --> 01:20:36.340]  код, который я приводил, тут линейное преобразование.
[01:20:36.340 --> 01:20:40.180]  Если написать разность двух линейных функций, то
[01:20:40.180 --> 01:20:43.380]  она, знаменатель может обращаться в ноль, поэтому она может
[01:20:43.380 --> 01:20:45.940]  что-то отправлять в бесконечность, бесконечность куда-то
[01:20:45.940 --> 01:20:48.420]  будет отправлять, то есть она будет переставлять
[01:20:48.420 --> 01:20:51.980]  расширенное поле, где есть еще точка бесконечности.
[01:20:51.980 --> 01:20:56.740]  И вот оказывается, что вот этот вот код, он симметричен
[01:20:56.740 --> 01:20:59.740]  относительно таких преобразований координат. Не только относительно
[01:20:59.740 --> 01:21:02.260]  циклических сдвигов, но относительно всех дробно-линейных
[01:21:02.340 --> 01:21:05.300]  преобразований координат. А оттуда уже можно вывести,
[01:21:05.300 --> 01:21:09.260]  ну тоже немгновенно вывести кодовое расстояние.
[01:21:09.260 --> 01:21:14.340]  В общем, я свое время исчерпал, на этом курс закончен.
[01:21:14.340 --> 01:21:17.100]  Я надеюсь, что какое-то представление о том, как
[01:21:17.100 --> 01:21:20.620]  конечные поля возникают в приложениях у вас возникло.
[01:21:20.620 --> 01:21:23.820]  Ну и надеюсь, что про сами конечные поля вы что-то
[01:21:23.820 --> 01:21:27.300]  запомнили, потому что, конечно, вам они понадобятся.
[01:21:27.300 --> 01:21:30.900]  Ну, сейчас вы будете экзамен сдавать или там получать
[01:21:31.100 --> 01:21:34.140]  оценку на итоговом занятии. Потом, конечно, какое-то
[01:21:34.140 --> 01:21:36.980]  время они вам могут и не встречаться. Но есть надежда,
[01:21:36.980 --> 01:21:39.020]  что даже если через год или два вам понадобятся,
[01:21:39.020 --> 01:21:41.980]  вы все-таки не беспользуясь, вспомните, что я вам тут
[01:21:41.980 --> 01:21:45.820]  рассказывал. Ну, кто знает.
[01:21:45.820 --> 01:21:47.540]  Благодарю за внимание. На этом все.
