[00:00.000 --> 00:08.120]  Лекция 11 и наша тема динамические структуры данных.
[00:20.120 --> 00:26.560]  Итак, мы с вами изучили довольно много структур данных, стандартных для DKS++.
[00:26.560 --> 00:31.160]  У нас были совсем простые типы данных, такие как int, char.
[00:31.160 --> 00:36.600]  Потом мы из них конструировали что-то сложное, например, строки мы могли конструировать из
[00:36.600 --> 00:44.320]  char, мы могли конструировать из каких-то там int или double, например, массивы.
[00:44.320 --> 00:50.080]  Потом гетерогенные типы данных, когда разные типы данных мы использовали для того,
[00:50.160 --> 00:57.640]  чтобы конструировать структуру и потом можно же делать, например, массив структур, идти дальше.
[00:57.640 --> 01:06.040]  И это то, чем то, что мы сейчас умеем уже. Но для решения некоторых задач массивы,
[01:06.040 --> 01:11.080]  например, не всегда хороши. Какая главная проблема вообще у массива?
[01:11.080 --> 01:17.480]  В чем особенность хранения массива в памяти? Они идут подряд, совершенно верно.
[01:17.480 --> 01:24.800]  То, что мы здесь с вами размещаем все элементы массива подряд, с одной стороны,
[01:24.800 --> 01:28.040]  дает нам громадное преимущество. Какое это преимущество?
[01:28.040 --> 01:38.600]  Можно легко адресовать. Мы знаем начало, мы даем сдвиг и мы попадаем в нужную ячейку.
[01:39.160 --> 01:47.800]  Это на самом деле преимущество. Мы за от 1 получаем с вами доступ к любому элементу.
[01:47.800 --> 01:52.960]  Не во всех структурах данных доступ у вас будет за от 1, а в массиве,
[01:52.960 --> 01:59.240]  потому что это просто формула, это от 1, следовательно, у вас доступ к любому элементу.
[01:59.240 --> 02:04.520]  За это приходится платить всегда, когда что-то просто другое сложно.
[02:04.520 --> 02:12.200]  То здесь в массиве делать сложно, как вы думаете. Вот если у меня есть хороший,
[02:12.200 --> 02:20.040]  милый такой массив из интов, два, три, два, три оценки за сессию студента какого-то.
[02:20.040 --> 02:32.240]  И вот в этом массиве мне захотелось ставить что-то в середину, например, этого массива.
[02:33.080 --> 02:37.480]  Я хочу добавить, я пропустил, когда записывал, у него еще одна пятерка была, оказывается.
[02:37.480 --> 02:42.840]  И хочу вставить в хронологическом порядке, не в конец именно, чтобы как он сдавал,
[02:42.840 --> 02:47.160]  вот неправильно заполнил. Я хочу в хронологическом порядке его сессию вставить,
[02:47.160 --> 02:52.360]  чтобы правильно записать. Мне надо вставить элемент массива. Что значит вставить?
[02:52.360 --> 02:59.600]  Я не могу сейчас разрывать. У меня самое главное свойство массива, что все элементы хранятся подряд.
[02:59.600 --> 03:05.640]  Из этого следует, что мне придется 2, 3 сохранить, потом написать вот эту пятерку,
[03:05.640 --> 03:14.320]  а все вот этот весь хвост просто сдвинуть. Записать там его 2, 3, 4, 2. Но мы предполагаем,
[03:14.320 --> 03:18.480]  что здесь были какие-то свободные ячейки, например, записанные нулями. Тогда это корректно делать.
[03:18.480 --> 03:25.920]  И за сколько работает такая операция вставки у нас в массив? За от n, потому что мне приходится
[03:25.920 --> 03:31.920]  двигать весь массив. Также удаление. Если потом я понял, что я вставил ошибся,
[03:31.920 --> 03:36.640]  это было не его пятерка, и мне надо удалить назад. Но все, что я должен делать, это опять же брать
[03:36.640 --> 03:40.680]  этот хвост и сдвигать, чтобы у меня не было пропусков. Потому что в этой структуре данных
[03:40.680 --> 03:49.000]  не может быть пропуски. Они подряд располагаются, следовательно, не может быть никаких у вас
[03:49.000 --> 03:53.680]  несуществующих ячейк. Иначе, если вы даже на какую-то сделаете хитрую структуру,
[03:53.680 --> 03:58.800]  пометьте эту ячейку как свободную, как вы будете перемещаться правильно,
[03:58.800 --> 04:03.160]  вот так адресовать, как в начале. И операция вставки удаления из массива, соответственно,
[04:03.160 --> 04:09.160]  сработает за от n. И это и есть проблема наша в массиве. Есть другая структура данных,
[04:09.160 --> 04:15.960]  которую мы начнем с вами изучать. Список. Мы будем ее рассмотреть как динамическую,
[04:15.960 --> 04:21.520]  потому что она в начале не существует. Потом вы создаете один элемент, потом два, потом три и так
[04:21.520 --> 04:27.160]  далее, сколько вам надо. То есть она изменяет свои параметры, то есть количество элементов,
[04:27.160 --> 04:35.280]  другие параметры изменяет в процессе работы программы. Поэтому данная структура данных
[04:35.280 --> 04:40.760]  у нас будет называться динамической структурой данных. Что же такое список? Давайте вот посмотрим.
[04:40.760 --> 04:51.560]  Вот у нас есть какой-то элемент этого списка. Если там у нас элемент списка, элемент массива,
[04:51.560 --> 04:59.000]  хранил только значение 2, 3, 2, то здесь придется чуть сложнее. Мы тоже будем эту двойку хранить
[04:59.000 --> 05:04.160]  в этом списке, мы тоже можем хранить значения какие-то. Но поскольку они у нас будут в памяти
[05:04.160 --> 05:15.560]  располагаться не подряд, нам нельзя с вами хранить только значение. Нам придется с вами хранить
[05:15.560 --> 05:21.000]  некий указатель на следующий элемент этого списка, потому что мы их в памяти располагаем не подряд.
[05:21.000 --> 05:32.680]  Ну таким образом вот это 2, там что у нас было? 2, 3, 2, 3, 2, 3, 2, но это точно не студент физтеха,
[05:32.760 --> 05:40.160]  поэтому это просто гипотетический пример. В студенте хиждестибальная система,
[05:40.160 --> 05:44.800]  двойку получить здесь невозможно практически. По теории вероятности, да? Должно же быть
[05:44.800 --> 05:54.680]  нормальное распределение, поэтому R5, 6, где-то все время вы получаете 2. Итак, и вот этот список,
[05:54.680 --> 06:04.400]  и вот этот список, когда последний у нас элемент, мы здесь ставим нулевой указатель, то есть ноль
[06:04.400 --> 06:09.400]  можем просто записать, что с последнего элемента, вот так храним в памяти. Таким образом, это структура,
[06:09.400 --> 06:16.080]  в которой у нас будет одно поле, какие-то данные, другое поле указатель, указатель на какой тип,
[06:16.080 --> 06:20.400]  на вот эту же структуру. Сейчас мы это напишем, но пока концептуально поймем. И
[06:20.400 --> 06:31.240]  бывают списки у нас односвязные, бывают списки двухсвязные. Это значит, что у нас хранится
[06:31.240 --> 06:36.320]  указатель не только на следующий, но и на предыдущий. То есть вот у нас вот так будет
[06:36.320 --> 06:41.720]  идти указатель, и у первого будет ноль, потому что предыдущего в него нет. В односвязанных
[06:41.720 --> 06:46.480]  списках мы с вами перемещаемся только в одном направлении, в двухсвязанном можем в двух
[06:46.480 --> 06:54.600]  направлениях, поэтому называется двухсвязный. Как правило, для того, чтобы нам с вами с этим
[06:54.600 --> 07:00.840]  списком правильно работать, нам как минимум нужно иметь один указатель на него, потому что он
[07:00.840 --> 07:07.040]  хранится где-то в динамической памяти, и если ничто из ни стека, ни статической памяти не указывает
[07:07.040 --> 07:18.040]  на этот, вы не согласны с чем-то? Все, хорошо. Ничто не указывает на этот список, то непонятно,
[07:18.040 --> 07:22.480]  как к нему начать с ним работать, поэтому у нас всегда будет указатель на первый элемент. Но,
[07:22.480 --> 07:26.320]  как правило, если это двухсвязанный список, чтобы воспользоваться его преимуществами,
[07:26.320 --> 07:30.800]  то можно ходить и в другую сторону, мы будем делать с вами и указатель на последний элемент.
[07:30.800 --> 07:39.200]  Теперь давайте, пока мы с вами не начали писать код, который я сегодня как раз буду писать с
[07:39.200 --> 07:45.600]  помощью указателей, чтобы получше с этой темой потренироваться, подумаем, а что в этой структуре
[07:45.600 --> 07:53.960]  со сложностью? То, что мы обсуждали на массивах с вами. За сколько происходит поиск элемента? То
[07:53.960 --> 07:59.720]  есть здесь я просто, если хотел до какого-то элемента дойти, я прибавлял, здесь мне нельзя
[07:59.720 --> 08:05.560]  прибавить. Вот список, вот так у меня красивый нарисован в памяти, это может быть вот так. Вот
[08:05.560 --> 08:10.600]  здесь у вас первый, здесь второй, здесь третий, здесь четвертый, здесь пятый, здесь там шестой и
[08:10.600 --> 08:20.560]  так далее. Поэтому вы не можете прибавлять, вам придется идти по этой цепочке. Если вы идете по
[08:20.560 --> 08:25.600]  этой цепочке, то какая сложность у нас будет поиск элемента в списке? ОАТН совершенно верно,
[08:26.080 --> 08:38.560]  после контрольной все помнили. А дальше у нас с вами удаление и ставка, сравним. Если там мне
[08:38.560 --> 08:44.440]  надо было что-то сдвигать, то надо ли мне здесь весь этот список сдвигать влево или вправо? Нет,
[08:44.440 --> 08:51.840]  потому что я просто, если хочу добавить эту пятерку, что я буду делать? Я вот эту ноду сделаю
[08:51.840 --> 08:57.160]  где-то там, а потом просто поменяю указатели. Этот сюда, этот сюда и так далее. То есть,
[08:57.160 --> 09:04.280]  я грамотно поменяв указатели, некоторые изменю, и у меня эта нода хорошо вставится,
[09:04.280 --> 09:08.880]  потому что если вот мы хотим вот здесь разорвать, вот между этими вставить, мы просто эту связь с
[09:08.880 --> 09:15.120]  вами разорвем, какой-то сделаем элемент, и вот у нас получится новый элемент, который вставился в
[09:15.120 --> 09:23.680]  память, и совершенно неважно, потому что где они лежат и что было. Кроме того, иногда это полезно
[09:23.680 --> 09:31.520]  в некоторых, например, алгоритмах, когда требуется что-то сделать, и прежде чем я скажу что сделать,
[09:31.520 --> 09:38.560]  я хотел вас как раз спросить ту же тому штуку про сортировки, про квадратичные сортировки. Какие
[09:38.560 --> 09:47.960]  квадратичные сортировки вы знаете? Пузырек, ставками, выбора. За сколько работает каждая из них?
[09:47.960 --> 09:55.200]  Н квадрат. Замечательно. А теперь, какая сортировка особенная? Что она умеет делать,
[09:55.200 --> 10:05.400]  то что никакая другая не умеет? Вот этих трех, что вы назвали? У вас есть ставками, есть пузырек,
[10:05.400 --> 10:19.920]  есть выбором. Какой у вас ответ? Почему ставками? Не совсем. Давайте так, уточню вопрос,
[10:19.920 --> 10:25.760]  чтобы было понятно в каком направлении думать. Мы говорим о сложности алгоритмов, и вот с точки
[10:25.760 --> 10:33.480]  зрения сложности чего-то одна из этих сортировок намного лучше, чем все остальные. Мало того,
[10:33.560 --> 10:40.720]  она еще и лучше, чем даже быстрая сортировка или другие сортировки, которые вы будете,
[10:40.720 --> 10:51.360]  ни другая ни одна сортировка это делать не умеет. Да, нет же, не пузырек. Пузырек у Бог во всем,
[10:51.360 --> 10:57.440]  и в этом тоже. Поэтому, поскольку мы перечисли уже медного исключения, мы назвали ставками,
[10:57.440 --> 11:02.840]  назвали пузырек, остался выбором. Давайте теперь просто кто-то из вас додумается,
[11:02.840 --> 11:12.280]  скажет в чем выбора такая особенная, в чем ее такая крутизна. Не совсем, да.
[11:12.280 --> 11:20.480]  Ну это для всех тоже, пузырек тоже, если он частично у вас или полностью сортирован,
[11:20.480 --> 11:28.000]  одна итерация и все закончилось. Да, уникально, она дает минимум максимум и.
[11:32.840 --> 11:43.600]  Хорошо, да. Ну ладно, на десятку вы бы не сдали экзамен, но я расскажу. Смотрите,
[11:43.600 --> 11:55.440]  представьте себе, вот вы, вас как зовут? Леонид. Ну вот представьте себе, в другой
[11:55.440 --> 12:02.020]  жизни где-то там Леонид не на фистехе учится, а работает на пристани крановщиком, разгружает
[12:02.020 --> 12:06.980]  контейнеры с китайскими товарами, которые привозит в Долгопрудный по Москве реке на речном
[12:06.980 --> 12:14.620]  вокзале. Итак, представьте себе, что это пристань, это кран, сейчас у меня будет художественное
[12:14.620 --> 12:22.620]  тут просто рисование, вот кран, вот у него что-то свисает, вот это Леоня, вот сидит вот там наверху
[12:22.620 --> 12:30.540]  высоко, глядит, все видит и здесь вот такие контейнеры. Вот контейнеры, такая жизненная задача,
[12:30.620 --> 12:36.180]  их нагрузили ему на пристань вот в таком порядке, привозили и как-то сгружали, а завтра утром у него
[12:36.180 --> 12:42.340]  приезжают грузовики, вот здесь такие грузовики, они будут подъезжать и забирать вот эти контейнеры.
[12:42.340 --> 12:47.700]  Ему надо за ночь отсортировать контейнеры, чтобы грузовик, который в девять приезжает,
[12:47.700 --> 12:51.900]  забрал первый контейнер, а потому что второй он не проедет к нему, не заберет. Ему нужно вот
[12:51.900 --> 12:58.300]  этим краном пересортировать эти контейнеры между собой. Если Леоня будет делать пузырьком,
[12:58.300 --> 13:01.780]  у него будет очень хорошее развлечение, он будет их постоянно менять между собой,
[13:01.780 --> 13:07.300]  ведь операция смены контейнеров это поднять, куда-то в промежуточную переменную опустить,
[13:07.300 --> 13:13.860]  потом поднять другой, он за ночь не успеет, потому что у сортировки пузырьком количество обменов
[13:13.860 --> 13:20.420]  квадратично, как и у сортировки вставками. Сортировка выбором единственная сортировка,
[13:20.420 --> 13:23.980]  которая линейная относительно количества обменов. Почему? Потому что умный Леоня,
[13:23.980 --> 13:30.860]  который фистек закончил, он что сделает? Он спустится по этой лестнице и сначала пройдет и
[13:30.860 --> 13:35.940]  выберет этот максимум или минимум, то есть тот, кто должен стоять на этом месте и один раз его
[13:35.940 --> 13:42.820]  поставить на свое место. То есть сортировка выбором у вас единственная, которая не делает лишние
[13:42.820 --> 13:47.860]  обмены, потому что когда обмена ничего не значит, когда вы инты меняете, это неважно,
[13:47.860 --> 13:53.100]  но когда обмена это два контейнера или вы там сортируете, не знаю, какие-то огромные массивы
[13:53.100 --> 14:01.180]  информации, то у вас выходит не только на первый взгляд необходимость считать количество
[14:01.180 --> 14:07.260]  итераций именно сравнение, но вам надо посчитать количество обменов. И здесь количество обменов
[14:07.260 --> 14:13.100]  линейно, потому что вы выбираете вот, например, контейнер максимальный и ставите вот сюда,
[14:13.100 --> 14:19.180]  меняете их и вот этот, который у нас максимальный, больше никогда не будет тронут. Все, теперь из
[14:19.180 --> 14:25.260]  остальных он выбирает максимум, допустим этот меняет их, и вот у вас там таким образом
[14:25.260 --> 14:30.220]  происходит расстановка, у вас будет количество обменов, это n-1, потому что последний встанет на
[14:30.220 --> 14:39.740]  свое место. И это максимально, и это как бы прелесть этой сортировки, вот как раз когда у нас указатели,
[14:39.740 --> 14:46.100]  нам даже менять не надо, мы просто вот эти указатели подвесили в списке, это тоже, например,
[14:46.100 --> 14:51.380]  когда список удобен, потому что вам не надо перезаписывать, вы можете просто менять указатель,
[14:51.380 --> 14:59.700]  еще один для чего могут применяться списки. Теперь давайте перейдем к написанию того самого
[14:59.700 --> 15:07.300]  страшного кода, который я вам анонсировал, для того чтобы мы посмотрели с вами как выглядит
[15:07.300 --> 15:14.900]  реализация списков, и на ней как раз на этой реализации мы с вами потренируемся в работе
[15:14.900 --> 15:28.300]  с указателями. Сама нода, как ее называют, или элемент списка, это некая структура, узел,
[15:28.300 --> 15:36.900]  по-русски, которая состоит из следующих полей. Здесь какое-то поле данных, назовем вот это слово
[15:36.900 --> 15:42.340]  date, которое будет иметь тип int, например, потому что это наш пример, у нас здесь вот эти оценки
[15:42.740 --> 15:50.180]  но вы можете хранить все что угодно, другую структуру, другие типы данных, и у нас есть два указателя,
[15:50.180 --> 15:57.740]  указатель на следующий, на предыдущий элемент. Когда мы с вами изучали структуру, мы говорили,
[15:57.740 --> 16:01.620]  что структура может содержать указатель на этот тип структуры, который мы объявляем,
[16:01.620 --> 16:07.100]  это было у нас на лекции про структуры, и это как раз сделано для того, чтобы вы могли объявлять
[16:07.100 --> 16:11.740]  списки, иначе вы не сможете их сделать, потому что вы сейчас объявляете эту ноду и надо указывать
[16:11.740 --> 16:20.500]  в самой ноде на эту ноду. Такая вот у нас замечательная рекурсивная штука. Итак, указатель
[16:20.500 --> 16:26.860]  на следующий элемент назовем next, это указатель на ноду, которую мы объявляем, и указатель на
[16:26.860 --> 16:46.020]  предыдущий элемент мы с вами назовем prev. Вот наше объявление, которое мы начнем с него работать.
[16:46.020 --> 16:58.180]  Теперь давайте писать функцию main, где мы объявим следующие вещи. Нам потребуется указатель на
[16:58.180 --> 17:07.740]  начало, его мы с вами назовем указатель начала, pointer, begin, указатель на начало. Тип у него будет
[17:07.740 --> 17:14.100]  тоже. Это указатель на что? Он указывает на вот эту ноду, вот это тип, это есть нода. Значит,
[17:14.100 --> 17:31.860]  нод, звездочка, побег. Побег это указатель на ноду. И теперь мы сделаем некую функцию,
[17:31.860 --> 17:40.020]  которая нам инициализирует первый элемент этой ноды. Я вот здесь сейчас отрую, начну дописать эти
[17:40.020 --> 17:44.580]  функции, потому что там у меня main, вам надо отступить еще, наверное, строчек 6 у нас будет в
[17:44.580 --> 17:54.140]  main, а ниже будем писать функции, которые будет этот main вызывать. Итак, давайте напишем функцию first,
[17:54.140 --> 18:01.340]  которая нам заводит первый элемент. Итак, функция first, она возвращает, как мы видим вот из этого
[18:01.340 --> 18:11.260]  присваивания, указатель на ноду. Ну так ее и объявим. First это у нас указатель на нашу ноду.
[18:11.260 --> 18:21.660]  Принимает она данные, которые надо положить в данный узел, списка, и это наш ind. Ну что и
[18:21.660 --> 18:27.740]  сделать? Она объявит какой-то в нашей функции, мы объявим какой-то временный указатель,
[18:27.740 --> 18:35.180]  который сейчас у нас будет храниться в стейке в этой функции, удалится, когда мы закончим с ней
[18:35.180 --> 18:52.740]  работать. Итак, у нас есть некий pv, это указатель на ноду, которая сейчас у нас в динамической
[18:52.740 --> 19:00.780]  памяти заведена, это stack, это динамическая память, и пока в ней ничего нет, пока мы просто завели,
[19:01.740 --> 19:09.900]  теперь давайте заполнять ее смыслом. Как обращение у нас будет идти через указатель? pv это указатель,
[19:09.900 --> 19:16.900]  нам надо разаменовать указатель и обратиться к элементу структуры. Разаменование указателя
[19:16.900 --> 19:27.540]  это звездочка, обратиться к элементу структуры это точка. Эта операция c++, которая была очень
[19:27.540 --> 19:32.060]  часто заменили, ну не заменили, а сделали альтернативную, которая более простая стрелочка,
[19:32.060 --> 19:41.100]  поэтому мы будем писать сразу стрелочку. pv стрелочка d равно d, то есть вот это первое поле,
[19:41.100 --> 19:46.580]  которое мне называется d, я кладу сюда то, что мне передали функцию. Чем меня инициализируют,
[19:46.580 --> 19:54.180]  например здесь единицей, давайте чтобы было похоже на нас, двойкой инициализируемся. Мы
[19:54.180 --> 20:02.060]  инициализируемся двойкой и вот сюда эту двоечку кладем. Еще нам надо что-то записать в следующий и
[20:02.060 --> 20:06.700]  предыдущий, но поскольку она самая первая, у нее нет ни следующего, ни предыдущего,
[20:06.700 --> 20:22.300]  поэтому это просто нули. Давайте тоже это сделаем. pv next равно нулю, pv prev равно нулю. Вот мы с вами
[20:22.300 --> 20:30.140]  закончили функцию, которая в конце должна вернуть то, что она создала вот этот элемент
[20:30.140 --> 20:36.740]  списка в динамической памяти. Мы возвращаем указатель на него, вот звездочка, которую мы
[20:36.740 --> 20:44.100]  возвращаем, и этот указатель у нас присвоится указателю на начало списка. Таким образом,
[20:44.100 --> 20:48.900]  в текущий момент у нас только вот это создано. Есть начало списка, есть один элемент списка,
[20:48.900 --> 20:57.900]  который у нас в памяти. Вот этот кусок правее, ничего сейчас нет. Давайте теперь создадим еще
[20:57.900 --> 21:09.780]  в мейне одну переменную, которая будет держать конец списка. p end. Конец списка. Пока я затру
[21:09.780 --> 21:15.460]  все, чтобы ничего нас не отвлекало, и здесь у нас рисовалось именно то, что у нас в данный
[21:15.460 --> 21:22.740]  момент в памяти. Вам так будет проще понимать. Вот у нас сейчас 2, 0, 0. Это то, что у нас сейчас
[21:22.740 --> 21:30.340]  записано. И конец списка, наверное, логично, если у меня список из одного элемента, то его конец
[21:30.340 --> 21:37.540]  совпадает с началом. Поэтому я просто присваиваю сюда указатель на начало, а не равный. Это
[21:37.540 --> 21:48.100]  начальная инициализация конца списка. Теперь давайте докидывать
[21:48.100 --> 22:01.100]  элементы и давайте вставим в конец нашего списка несколько элементов. Сюда сейчас я буду писать,
[22:01.100 --> 22:13.620]  Леню придется нам стереть. Он уволился оттуда. Значит, функция, которую мы сейчас напишем,
[22:13.620 --> 22:23.020]  это продолжение мейна, будет называться add. И мы будем добавлять с вами конец списка. Для
[22:23.020 --> 22:32.340]  чего мы будем сейчас передавать адрес конца? Это операция. Взятия адреса конца списка и то,
[22:32.340 --> 22:38.460]  что хотим добавить. Какая у нас была оценка после двойки? Пункт тройка. А потом была после тройки
[22:38.460 --> 22:48.580]  снова двойка. Это нормальная ситуация. Два, он напрягся, получил тройку, расслабился,
[22:48.580 --> 22:58.180]  получил двойку и так далее. Все логично объяснимо. Да, сейчас поймем. Это не ошибка,
[22:58.180 --> 23:04.980]  это так задумано. Ну и несколько можем дальше добавлять. Самая суть, давайте напишем эту
[23:04.980 --> 23:14.660]  функцию add. Я сотру first, чтобы нам было где писать. Все успели вот эту часть переписать? First все
[23:14.660 --> 23:34.740]  переписали. На ее месте сейчас будем писать add. Итак, когда мы с вами добавляем в конец списка,
[23:34.740 --> 23:43.860]  у нас что-то меняется. А именно, если мы добавляем конец, понятно, что у нас вот эта переменная
[23:43.860 --> 23:52.260]  paint. Но тоже, если мы сейчас сюда второй элемент добавим, тоже у нас должна сдвинуться. Где-то нам
[23:52.260 --> 23:58.580]  надо менять указатель. Как менять указатель? Ну, передав его можно, например, по указателю,
[23:58.580 --> 24:06.340]  по адресу. Чтобы передать указатель по адресу, нам понадобится указатель, который на него указывает.
[24:06.340 --> 24:14.700]  Правильно? То есть, у нас будет указатель, который по адресу передал получил этот, и мы
[24:14.700 --> 24:21.700]  тем самым получаем с вами двойной указатель. Именно это у нас и будет сейчас функцией нашей add. Итак,
[24:21.700 --> 24:25.820]  вот у нас функция add. Она ничего не возвращает, она просто добавляет элемент в конец списка,
[24:25.820 --> 24:46.580]  но она принимает двойной указатель, который, допустим, назвали мы P. И кроме этого,
[24:46.580 --> 24:56.500]  она принимает, кто я добавлю. Так что такое P у меня? Вот у меня P. P – это переменная,
[24:56.500 --> 25:05.540]  которая живет на стеке. Впрочем, PN тоже живет на стеке. Но P – это переменная локальная для
[25:05.540 --> 25:14.020]  функции add. PN у меня живет в main, и за функцией add я не могу менять переменную, которая живет
[25:14.020 --> 25:19.140]  в main. Поэтому, чтобы получить возможность изменения, я использую возможность передач
[25:19.140 --> 25:28.740]  по адресу. Я передаю адрес PN. Этот адрес копируется в указатель. Какой это тип? Если это тип
[25:28.740 --> 25:39.460]  нот-звездочка, это нот. То есть, вот это нот. Это нот-звездочка, она указывает на нот. А этот
[25:39.460 --> 25:43.140]  указывает на того, кто указывает на нот. Значит, он нот-звездочка-звездочку, он указатель на
[25:43.140 --> 25:51.460]  указатель на нот. Но звездочка-звездочка – это вот наша P. Вот у нее вот здесь как раз такой тип,
[25:51.460 --> 25:58.980]  видите, нот-звездочка-звездочка. Я знал, что вам понравится. Я знал, что это нельзя делать до
[25:58.980 --> 26:12.460]  контрольной. И начинаем реализовывать эту функцию. Нот. Новую ноту создаем. Мы добавляем в
[26:12.460 --> 26:17.020]  конец. Соответственно, нам нужна новая, которая сейчас добавится в конец. То же самое. Нот,
[26:17.020 --> 26:32.620]  назовем ее PV, равно newNOT. Нот PV, newNOT. То есть, сейчас мы с вами создали некий указатель на ноту
[26:32.620 --> 26:40.100]  PV. Через него создали новую ноту в памяти. Вот что у нас сейчас в памяти делается. Все вот это чудо
[26:40.100 --> 26:46.780]  в стеке. К разным функциям, правда, относится это к функции add, это к функции main. Вот эти две
[26:46.780 --> 26:55.260]  штуки висят у нас в динамической памяти. Заполняем ее смыслом, как обычно. То же самое. Через операцию
[26:55.260 --> 27:04.660]  стрелочка. Значит, я что делаю PV? D. Равно D. Вот этот D, который мне передали, я кладу сюда. Вот у
[27:04.660 --> 27:15.700]  меня был вызов с тройкой. Эта тройка вот сюда у нас записалась. Теперь давайте PV next. Вот у меня
[27:15.700 --> 27:21.700]  следующий элемент. У него нет следующего, поэтому, наверное, мы сюда сейчас запишем с вами
[27:21.700 --> 27:37.060]  0 PV next. Это 0 будет у нас. А вот PV prev чуть сложнее, потому что вот у меня предыдущий элемент,
[27:37.060 --> 27:44.660]  и мне, по идее, надо связать. У него есть предыдущий. Как мне до него достучаться? Как узнаешь,
[27:44.660 --> 27:49.100]  как кто у меня предыдущий? Вот меня создали, у меня, оказывается, есть предыдущий. Что я еще знаю? Я
[27:49.100 --> 27:56.060]  знаю, вот это P, который указывает на P end, а P end указывает на предыдущий. Давайте через P и
[27:56.060 --> 28:03.140]  вытащим этот предыдущий. Как? Разыменуем P. Если мы разыменовали P, то мы получили P end,
[28:03.140 --> 28:09.500]  который указывает на предыдущий. Таким образом, PV стрелочка prev равно звездочка P.
[28:09.500 --> 28:25.780]  Ну, это все или нет? Нет, потому что у этого теперь появился у первого следующий. Значит,
[28:25.780 --> 28:34.260]  надо это 0 заменить на вот тот элемент, который мы только что создали. Давайте достучимся до этого
[28:34.260 --> 28:42.020]  поля next. То есть, это у нас поле D. Напоминаю, это поле next. Это поле prev. Давайте достучимся до
[28:42.020 --> 28:49.580]  поля next первой структуры, которая у нас была создана в памяти. Вот у меня P есть. P держит
[28:49.580 --> 28:57.740]  у меня указатель на P end. P end знает, где находится эта нода, и внутри ноды надо выделить еще и одно
[28:57.740 --> 29:11.300]  поле next. Как будет выглядеть эта структура? Значит, мне, чтобы добраться до P end, надо разыменовать
[29:11.300 --> 29:17.220]  P, потому что P это указатель, а мне надо то, что содержимый указатель. Ведь P end указывает сюда,
[29:17.220 --> 29:22.380]  адрес находится здесь. Это содержимое. Мне не интересно, где адрес P end. Мне интересно его
[29:22.380 --> 29:28.020]  мясо содержимое. Это значит, что мне надо разыменовать вот этот P, чтобы получить содержимое этой
[29:28.020 --> 29:36.260]  ячейки. Я разыменовываю P. Теперь, когда я его разыменовал, я должен поставить стрелочку,
[29:36.260 --> 29:43.620]  потому что, чтобы добраться, собственно, до вот этой структуры, мне надо разыменовать
[29:43.620 --> 29:49.380]  теперь сам P end и поставить точку. Это то же самое, что стрелочка. И теперь, после стрелочки,
[29:49.380 --> 29:56.220]  к какому полю я обращаюсь? К next. А теперь я пойму, понимаете ли вы хотя бы что-то,
[29:56.220 --> 30:02.220]  и спрошу рандомного человека, что надо написать дальше. Сделаем очень просто. Вот я вижу,
[30:02.220 --> 30:08.940]  что молодого человека на последней парте точно он все знает. Да, вот вы. Что надо здесь написать?
[30:08.940 --> 30:26.220]  Ладно, попытка номер два. Раз, два, три, четыре, пять, шесть, семь, восемь. Да, вот вы. Нет,
[30:26.220 --> 30:33.260]  вот вы. Восьмая парта, самый крайний. Молодой человек в серой футболке. В нее смотреть назад,
[30:33.260 --> 30:50.580]  это вы, да. Ну, хорошо. Давайте, кто знает тогда? Один, два, так много. Так, а почему все отличники
[30:50.580 --> 30:59.140]  сидят в начале, а почему... Вот на последней парте поднял руку, молодец. ПВ, молодец. Видите,
[30:59.140 --> 31:06.060]  и наша галерка тоже все знает. ПВ. Потому что мы хотели присвоить адрес вот этой второй ноды,
[31:06.060 --> 31:15.540]  но у нас есть как раз указатель ПВ, который ее держит. Вот. Теперь смотрите, мы с вами завели
[31:15.540 --> 31:21.220]  второй элемент списка, мы заполнили сюда данные, мы заполнили следующий элемент, мы заполнили
[31:21.220 --> 31:28.140]  предыдущий элемент, и все ли я сделал, можно ли заканчивать функцию, или осталось сделать еще
[31:28.140 --> 31:33.900]  что-то. ПН, да. Теперь вот нам надо указатель наконец нашего списка подвинуть, то есть его надо
[31:33.900 --> 31:40.940]  изменить. С первого на второй. И как раз я его изменю за счет этого П. П поменяет нам содержимое
[31:40.940 --> 31:53.900]  того, на что оно указывает. Итак, содержимое П это звездочка П. И это тоже ПВ, потому что
[31:53.900 --> 31:58.340]  второй элемент это как раз ПВ. И вот мы закрываем функцию. Это прекрасная функция,
[31:58.340 --> 32:05.940]  которая у нас получилась, которая добавляет, накидывает нам элементы в конец список, добавляет их.
[32:05.940 --> 32:20.340]  Давайте теперь научимся с вами удалять, или сначала давайте попроще вставлять. Итак,
[32:20.340 --> 32:26.420]  когда у меня будет накидано много элементов в список, вот у меня список, иногда мне захочется,
[32:26.420 --> 32:30.940]  как я вам демонстрировал, что-то вставить в середину списка, добавить новый элемент,
[32:30.940 --> 32:44.940]  которого не было. Это будет у нас функция insert. Вызовем ее из нашей программы в main. Ее тоже
[32:44.940 --> 32:54.900]  будет уметь добавлять после какого-то элемента. Такая insert у нас будет уметь добавлять после
[32:54.900 --> 32:59.460]  элемента. То есть вставлять она может после какого-то элемента. Если вставлять после,
[32:59.460 --> 33:05.180]  она никогда начало не изменит. Но если она вставляет после последнего, она может
[33:05.180 --> 33:13.460]  изменить конец. Поэтому начало мы передадим наш пб обычно по значению, а пн нам придется
[33:13.460 --> 33:22.460]  также передать, чтобы его возможность была менять. Поэтому возьмем адрес пн. Теперь дальше,
[33:22.460 --> 33:28.140]  после элемента 2 мы вставляем 5, так как мы хотели. После первой двойки, оказывается,
[33:28.140 --> 33:34.340]  была пятерка. Мы ее не заметили. Человек так собрался и хотим добавить в список после двойки
[33:34.340 --> 33:47.700]  пятерку. Давайте нашу процедуру insert напишем. Буду писать тогда уже здесь. Вам здесь видно?
[33:47.700 --> 34:06.540]  Наверное. Итак, мы с вами вернем то, что вставили. Можно там игнорироваться,
[34:06.540 --> 34:14.740]  возвращаем значение. Это неважно. Мы можем использовать это. Итак, вставляем новый элемент.
[34:14.740 --> 34:24.220]  Значит, мы хотим с вами передать значение. Указатель на начало. Чтобы никто нам его не
[34:24.220 --> 34:31.860]  попортил, мы передадим его как константный указатель. Пб будет у меня константный указатель
[34:31.860 --> 34:40.180]  на ноду. Это локальный фибек. К тому побегу не имеет отношения. Об этом помним, потому что это
[34:40.180 --> 34:47.220]  объявляется внутри функции. Читаем справа налево. Константный указатель на ноду. То есть,
[34:47.220 --> 34:51.540]  мы не сможем поменять этот указатель, чтобы, если функция insert работает некорректно,
[34:51.540 --> 35:05.140]  начало нашего списка хотя бы останется правильным. Кроме того, мы с вами должны дальше продолжать.
[35:05.140 --> 35:15.220]  Второй у нас элемент нашего списка будет передаваться по чему? Уже по адресу,
[35:15.220 --> 35:27.220]  потому что у нас с вами в списке требуется иногда изменить конец, если у нас последний
[35:27.220 --> 35:31.540]  элемент, после него мы вставляем след на конец нашего списка, будет меняться. Поэтому это будет
[35:31.540 --> 35:37.740]  указатель на ноду, как только что было. Здесь его p-end, чтобы было понятно, о чем речь,
[35:37.740 --> 35:41.620]  но и другой p-end. Это не тот, который тот. Это локальная переменная в данной функции,
[35:41.620 --> 35:47.260]  которая будет указателем на p-end, который функции main. То есть, у нас вот что вышло.
[35:47.260 --> 35:58.220]  У нас вышло вами следующее. У нас сейчас есть две ноды. Давайте не две. Там много нод. Мы
[35:58.220 --> 36:09.460]  добавили с вами еще троечку, двоечку. Вот что мы сделали с вами. В них есть указатель на
[36:09.460 --> 36:20.980]  следующий. Здесь у нас указатель на предыдущий. Это текущая картинка. И вот у нас есть еще p-end,
[36:20.980 --> 36:30.460]  который указывает на наш последний элемент нашего списка. Теперь смотрите, я хочу вставить
[36:30.460 --> 36:36.180]  пятерку после двойки. То есть, фактически вот за этой двойкой сейчас появится нода с пятеркой,
[36:36.180 --> 36:42.100]  которую я буду вставлять. И для того, чтобы правильно работать, я здесь завел две переменные.
[36:42.100 --> 36:54.340]  Вот этот p-beg, который только что у меня объявился в функции insert, это не указатель на p-beg,
[36:54.340 --> 36:59.460]  а это переменная, которая была передана по значению. Следовательно, просто вот этот p-beg
[36:59.460 --> 37:09.300]  скопировался в этот p-beg. Этот p-beg держит начало списка. Мы не можем менять. А p-end у меня чуть
[37:09.300 --> 37:16.380]  сложнее. У меня есть другой p-end, который указывает как указатель на указатель. Вот такая картинка.
[37:16.380 --> 37:30.900]  Теперь передадим ключ. Это то, что мы ищем. Обычно программируют и называют это ключом. И
[37:30.900 --> 37:37.060]  значение, которое мы вставим после ноды, которое является ключом, если оно найдется. Ну и самое
[37:37.060 --> 37:44.140]  главное, тезис, что если найдется, может мы вставляем зачем чего нет. Поэтому давайте поищем,
[37:44.140 --> 37:51.140]  будет ли она вообще найдена. Для этого нам потребуется if, где мы в лучших наших традициях
[37:51.140 --> 37:55.940]  все сделаем и объявим, и присвоим, и получим результаты, в зависимости от этого будем
[37:55.940 --> 38:06.180]  работать или не работать. Итак, объявим внутри if-a новую переменную нод, указатель на нод,
[38:06.180 --> 38:12.780]  которая будет называться у нас pk. Ей же тут же сразу присвоим значение функции, которую мы сейчас
[38:12.780 --> 38:28.220]  еще не написали. Именно функция find, которая будет искать в нашем списке нужное нам значение вот
[38:28.220 --> 38:36.820]  этого ключа. Мы даем откуда искать pbek. Вот это переменная нас pbek. И что искать? Ключ.
[38:36.820 --> 38:49.820]  Значит, нам нужна еще скобочка. И теперь самое время написать функцию find, где бы нам найти место.
[38:49.820 --> 39:12.980]  А там вы не видите, да? Тогда функцию add, да. Потому что у нас будет хитрый
[39:12.980 --> 39:18.660]  работать функция find. Если она ничего не нашла, она вернет 0, if не сработает. Если она хоть
[39:18.660 --> 39:23.420]  что-то нашла, она вернет адрес. Любой адрес, это не 0. И значит это true, значит мы работаем.
[39:23.420 --> 39:43.820]  В этом у нас с вами и суть. Так, давайте напишем вот эту функцию find.
[39:43.820 --> 40:02.540]  Смысл в том, что у вас вы никогда не знаете вообще сколько вы напишете, потому что может
[40:02.540 --> 40:08.020]  пойти вдохновение и вы можете писать очень много кода. А утром вы просыпаетесь и понимаете все,
[40:08.020 --> 40:13.060]  что вы писали ночью, можно написать двумя строчками. Особенно это часто встречается
[40:13.060 --> 40:17.140]  на Олимпиадах. Если вы на ИСМ ходите на студенческие Олимпиады программированию,
[40:17.140 --> 40:24.140]  там очень часто такая ситуация, что командник пишет, пишет, пишет, написал 20 экранов. Недавно,
[40:24.140 --> 40:29.780]  может быть, слышали финал был у нас как раз в России, проводился в манеже перед Кремлем. И
[40:29.780 --> 40:37.340]  пистек там хорошо выступил, минутка рекламы. Вот, получил золотую медаль. Значит, так вот,
[40:37.340 --> 40:45.100]  и задача не зашла. Что они делают, как правило? Ну, отлаживают, отлаживают, потом поняли,
[40:45.100 --> 40:52.100]  что отлаживать это вообще такое, скажем, неблагодарное дело, особенно в чужом коде
[40:52.100 --> 40:56.620]  разбираться. Иногда проще переписать заново. Садится другой человек переписывать заново,
[40:56.620 --> 41:01.180]  было там 10 экранов, стал один экран, зашла с первого раза. Потому что не всегда количество кода,
[41:01.180 --> 41:06.100]  оно соответствует качеству, поэтому никогда нельзя предугадать, чтобы решить задачу.
[41:06.100 --> 41:15.380]  Итак, not find. Значит, find у нас с вами будет делать следующее. Мы объявим вот этот самый
[41:15.380 --> 41:29.780]  константный указатель тоже на побег. Начало нашего списка. И, собственно, что мы с вами ищем?
[41:29.780 --> 41:47.180]  int d. Давайте какую-то, объявим временную переменную указатель на нашу временную указатель. У нас
[41:47.180 --> 41:55.180]  все начинается с p, потому что p это pointer. В информатике вот эта одна нода еще называется
[41:55.180 --> 42:01.020]  вершины графа вертекс, поэтому мы будем это как бы, как в графах будем с вами писать. И дальше мы
[42:01.020 --> 42:11.900]  начинаем этот указатель двигать. Вначале мы его с вами присвоим началу. Списка вот этому.
[42:11.900 --> 42:24.460]  Пбек. То есть наш pv это пбек. Сейчас он, наша временная какая-то переменная, она указывает
[42:24.460 --> 42:32.220]  на первый элемент нашей ноды. Теперь дальше я должен смотреть. Вот у меня вот здесь хранится то,
[42:32.220 --> 42:42.620]  что я ищу или нет. Если да, то ок, я возвращаю, я смог найти. Если нет, я продолжаю идти. И pv должен
[42:42.620 --> 42:47.660]  двигать next, next, next, next, пока не дошел до нуля. Потому что последний в next будет 0 у нас, правда? И
[42:47.660 --> 42:59.420]  этот 0 мы с вами закончим наш цикл. И тогда очень просто. Прямо сделаем while pv. Смотрите,
[42:59.540 --> 43:11.500]  когда он станет нулем цикл закончится, пока не 0 мы будем продолжать искать. И теперь если то,
[43:11.500 --> 43:17.660]  что у нас хранится в нашей временной переменной данной у нас как раз те, которые мы ищем,
[43:17.660 --> 43:29.020]  извините, равно вот этому d, вот это d, вот это d. Все, мы нашли. По идее мы можем с вами цикл
[43:29.020 --> 43:38.260]  заканчивать, поэтому мы досрочно из нее выходим, делаем break. И дальше, если нет, мы просто сдвинемся
[43:38.260 --> 43:45.420]  на следующий элемент. pv равно pv next. Мы сдвигаемся на следующий элемент списка. И когда мы будем на
[43:45.420 --> 43:50.820]  последнем, то pv next будет равен нулю, у нас присвоится 0, while по нулю у нас выйдет,
[43:50.820 --> 44:08.460]  тем самым мы в любом случае цикл будет конечным. И давайте вернем то, что мы нашли. И вот если мы
[44:08.460 --> 44:19.420]  нашли 0, если у нас указатель этот нулевой, это значит мы прошли до конца списка, ничего не
[44:19.420 --> 44:29.820]  обнаружили. Значит find вернет 0, 0 присвоится в pk. Результатом у нас тоже будет присваивание,
[44:29.820 --> 44:34.860]  всегда то, что присвоилось как результат присваивания, это будет ложь и все. Мы никуда не
[44:34.860 --> 44:40.500]  провалимся, поскольку некуда вставлять не нашли зачем. Если же мы с вами найдем такой элемент,
[44:40.500 --> 44:46.260]  то это будет не 0 и ивс работает. Поэтому мы здесь объявили переменную и выполнили поиск и присваивание,
[44:46.260 --> 44:51.380]  еще и результат. Это вот тот момент, когда в тот случай, когда присваивание в ифе разумно.
[44:51.380 --> 44:56.700]  Можно было делать по-другому, но здесь оно хотя бы имеет смысл. Это вот не баг, это фитча, как это
[44:56.700 --> 45:06.460]  говорят программисты. Теперь я создаю новую ноду, какую-то временную, которую буду сейчас
[45:06.460 --> 45:18.780]  вставлять между нашими двумя элементами списка после того, кого мы нашли. Заполним ее сначала
[45:18.780 --> 45:35.460]  значением. Вот что у меня сейчас получилось. У меня есть некое время, мы вот сейчас после
[45:35.460 --> 45:44.260]  двойки будем вставлять новую ноду. Я создал ее в памяти, на нее у нас указатель pv. Что вы так,
[45:44.260 --> 45:54.340]  как сепенди, так разговариваете? Сейчас еще три минутки. У нас указатель есть, и нам надо с
[45:54.340 --> 46:03.980]  вами, нам надо с вами очень сюда заполнить вот эту пятерку, поменять все указатели. То есть вот этот
[46:03.980 --> 46:09.740]  вот сюда, от этого на следующую и так далее, этот на предыдущую. То есть мы должны вот эту связь
[46:09.740 --> 46:14.140]  разорвать между вторым и третьим, первым и вторым, и сделать ее между первым, вторым, вторым и третьим.
[46:14.140 --> 46:20.100]  Ну давайте, поскольку времени мало, я просто это напишу, а вы дома посмотрите, почему это так.
[46:20.100 --> 46:34.300]  pvnext это было, это pknext, то есть то, что мы нашли, его следующий, то есть если мы говорим pvnext,
[46:34.300 --> 46:40.820]  вот он, на что он должен укаживать? Вот мы нашли ноду, вот его следующий, вот мы как раз на его
[46:40.820 --> 47:02.020]  следующий пишем ему указатель. pvprev это pk. Теперь мне надо поменять, собственно, те остальные,
[47:02.020 --> 47:09.940]  которые мы только что с вами нашли, вот за которым мы вставляем, у него тоже следующий поменялся,
[47:09.940 --> 47:20.580]  следующий это вот этот новый, поэтому давайте его менять, на него указывает pk. pknext это pv,
[47:20.580 --> 47:33.020]  этот новый, за которым мы сейчас вставили. Ну последний у нас небольшой такой if будет с
[47:33.020 --> 47:45.180]  вами, если мы с вами не за последним вставляем, то есть если у наш pk, который мы нашли, не указывает
[47:45.180 --> 47:49.660]  на последнюю ноду, мы разыменовываем этот pn, который двойной указатель, получаем адрес последней
[47:49.660 --> 47:56.300]  нашей ноды, если наш pk не последняя нода, то есть потому что если за последним, то у нас частный
[47:56.300 --> 48:11.980]  случай, поэтому если не равно, то обычный случай мы с вами сделаем это pvnext.prev равно pv,
[48:11.980 --> 48:24.260]  то есть что я делаю, вот у меня pv, следующий сейчас указывает на вот этот второй, у него
[48:24.260 --> 48:28.900]  предыдущий должен стать не первый, а мне надо замкнуть его на собственно pv, вот эта строчка она
[48:28.900 --> 48:36.980]  это и делает, и а иначе, мне надо просто, раз у меня вставилось после последней, теперь то, что вставилось,
[48:36.980 --> 48:44.500]  это есть последний, поэтому разыменовываю pn, чтобы его поменять, равно pv, возвращаем то, что мы с
[48:44.500 --> 48:51.660]  вами новый элемент, который вставили, а иначе, если мы в них не вошли, возвращаем ноль, что не
[48:51.660 --> 48:57.300]  смогли вставить, отлично, мы даже успели, а на этом на сегодня все, до свидания.
