[00:00.000 --> 00:14.000]  Итак, всем доброго дня! Мы сегодня снимаем нашу лекцию, я бы так сказал, в походных условиях.
[00:14.000 --> 00:21.000]  Поэтому, если кто будет смотреть ее записи, особенно кто будет смотреть лекторию, извините.
[00:21.000 --> 00:27.000]  Приходите в отчет.
[00:27.000 --> 00:37.000]  У нас сегодня последняя лекция связана именно с основным стаком компиляторов, а дальше мы будем их уже расширять.
[00:37.000 --> 00:45.000]  Итак, у нас сегодня тема анализ потока данных, и мы с вами сейчас находимся на вот такой стадии.
[00:45.000 --> 00:54.000]  На самом деле мы с вами уже ушли очень-очень далеко по сравнению с темой семинарских занятий.
[00:54.000 --> 01:01.000]  И сейчас уже, так или иначе, нам нужно уже заниматься аллокацией регистров.
[01:01.000 --> 01:09.000]  Что означает аллокация регистров? Давайте вспомним, что у нас уже есть к этому моменту времени.
[01:09.000 --> 01:17.000]  Что делает Instruction Solution стадия?
[01:17.000 --> 01:21.000]  Да, гениальная.
[01:21.000 --> 01:29.000]  Напомню, что у нас было дерево промежуточного представления, и мы дерево промежуточного представления разложили уже в команды ассендеров.
[01:29.000 --> 01:34.000]  В прошлый раз мы даже очень детально сидели и пытались посмотреть, какие струкции ассендеров бывают.
[01:34.000 --> 01:43.000]  То есть мы с вами рассмотрели циск-архитектуру, мы с вами рассмотрели риск-архитектуру и поняли, что наборы инструкций разные в зависимости от железа.
[01:43.000 --> 01:54.000]  Более того, мы с вами увидели, что в опциях компиляции минус 1 и минус 3 есть даже векторные инструкции, которые при желании можно использовать для работы с СССЕ.
[01:54.000 --> 02:08.000]  Но есть одна важная особенность. Чему равняется количество регистров на выходе стадии Instruction Selection?
[02:08.000 --> 02:11.000]  Регистров сколько угодно.
[02:11.000 --> 02:23.000]  Мы еще не привели наш под к использованию регистров на уровне центрального процессора.
[02:23.000 --> 02:34.000]  Цель на сегодня. Посмотрим, как пойдет. Я обычно делаю полторы-две лекции на это. Возможно, если быстрее пойдем, то ладно, успеем.
[02:34.000 --> 02:41.000]  Разобраться, во-первых, почему у нас возникает проблема выбора регистров.
[02:41.000 --> 02:51.000]  Дальше построить грамм конфликтующих виртуальных регистров. Мы построим с вами грамм по управлению и попытаемся разобраться с виртуальными регистрами.
[02:51.000 --> 03:01.000]  Дальше разобрать первую версию локации регистров. У нас экран периодически моргает, поэтому приходится жить вот так.
[03:02.000 --> 03:08.000]  Дальше тут будет спойлеры. В чем проблема?
[03:14.000 --> 03:19.000]  Проблема состоит в том, что у нас обычно малое количество регистров.
[03:19.000 --> 03:25.000]  Говорится, мы делили апельсин много на СООН-1. Из советского мультика «Абстракция».
[03:25.000 --> 03:32.000]  Виртуальных регистров у нас много, а физических регистров у нас мало. Поэтому с этим нужно каким-то образом справляться.
[03:32.000 --> 03:43.000]  И как раз в стадии регистра локации, в следующем раз я буду говорить про конвейерность.
[03:43.000 --> 03:49.000]  Пока что конвейерность мы с вами учитывать не будем. Это как бы дополнительная стадия, которую мы можем учитывать.
[03:49.000 --> 03:55.000]  Давайте вспомним, что у нас есть. У нас с вами есть набор операций на ассендерной астракции.
[03:55.000 --> 04:02.000]  И у нас есть много виртуальных регистров. У нас есть темп фрайпов, которые мы можем с вами использовать.
[04:02.000 --> 04:09.000]  Наша цель – попробовать занести это все в реальные регистры.
[04:09.000 --> 04:16.000]  Итак, давайте познакомимся с следующей абстракцией. Абстракция называется граф потока управления.
[04:16.000 --> 04:26.000]  Здесь у нас уже код написан по факту. На какой? На каком цикле, как вы понимаете?
[04:26.000 --> 04:34.000]  Здесь максимально. Вот у нас, например, так вот есть, что а0...
[04:34.000 --> 04:41.000]  Ну это уже похоже на ассендер. Да, это уже даже похоже на ассендер.
[04:41.000 --> 04:47.000]  И давайте построим граф потока управления. У нас здесь нет никаких инструкций VitaJump в определенную метку.
[04:47.000 --> 04:53.000]  У нас уже с вами идет бортрейс, по которому мы идем.
[04:53.000 --> 05:02.000]  Что мы говорим? У нас есть a0, дальше у нас b равно a плюс 1, c равно c плюс b, a равно b умножить на 2 и a меньше n.
[05:02.000 --> 05:07.000]  Дальше мы проверяем условия if a меньше n и делаем jump. То есть это даже ассендерная инструкция.
[05:07.000 --> 05:13.000]  Потому что если бы мы работали с вами с LVMUSK.R, то у нас был conditional jump в две ветки.
[05:13.000 --> 05:17.000]  Здесь jump в одну ветку. То есть это ассендерная инструкция.
[05:17.000 --> 05:23.000]  И наша цель будет построить граф потока управления и понять, какие переменные не могут находиться в одном регистре.
[05:23.000 --> 05:29.000]  APC это виртуальные регистры. Нам нужно выделить реальные регистры.
[05:29.000 --> 05:37.000]  Давайте прикинем. Есть ли мысли сходу, как определить, какие регистры не могут быть?
[05:44.000 --> 05:48.000]  Ну да, можно ли меньшее количество регистров?
[06:00.000 --> 06:02.000]  Угу.
[06:07.000 --> 06:09.000]  Да, так.
[06:09.000 --> 06:11.000]  Угу.
[06:21.000 --> 06:23.000]  Угу.
[06:27.000 --> 06:29.000]  Ну да.
[06:31.000 --> 06:35.000]  Можно сказать, что a это ради.
[06:40.000 --> 06:45.000]  Так, а и ц между собой не пересекаются, нет?
[06:45.000 --> 06:47.000]  Вроде нет.
[06:47.000 --> 06:49.000]  Скорее всего даже вот так.
[06:51.000 --> 06:55.000]  То есть в принципе мы можем вместить это все в два регистра и будет нам счастье.
[06:55.000 --> 06:58.000]  Но вопрос, как это автоматизировать?
[07:02.000 --> 07:04.000]  Угу.
[07:10.000 --> 07:12.000]  Угу.
[07:27.000 --> 07:32.000]  Да, смотрите, на самом деле для каждой перемены нам нужно вычислить время жизни.
[07:32.000 --> 07:38.000]  Вот, и если у нас, смотрите, получается так, что если у нас две переменные, два виртуальных регистров,
[07:38.000 --> 07:43.000]  смотрите, важный момент, пересекаются именно не по вершине, а по регу их линии жизни,
[07:43.000 --> 07:46.000]  то значит они комплектуют нужно собой.
[07:46.000 --> 07:49.000]  Не по вершине, именно по регу.
[07:49.000 --> 07:54.000]  Вот, и как раз нам нужно теперь построить алгоритм, который это будет делать.
[07:54.000 --> 07:57.000]  Хорошо, значит так.
[07:57.000 --> 08:02.000]  Вот, и давайте вот здесь введем некоторые переменные.
[08:02.000 --> 08:07.000]  Значит, переменная х у нас будет, ну виртуальный регистр х будет называться живым,
[08:07.000 --> 08:10.000]  если значение этого регистра будет использоваться в будущем.
[08:10.000 --> 08:14.000]  Собственно, для нашей цели нужно будет построить град.
[08:14.000 --> 08:17.000]  Значит, как это нам строится?
[08:17.000 --> 08:20.000]  Мы проводим ребро из вершины с в вершину т,
[08:20.000 --> 08:26.000]  если ребро st лежит на некотором пути от вершины, которые присвоили переменную,
[08:26.000 --> 08:29.000]  к вершине, которая использована в эту переменную.
[08:29.000 --> 08:32.000]  То есть мы запоминаем все операции storm в нашу переменную
[08:32.000 --> 08:36.000]  и смотрим до каких операций лод мы можем с вами дойти.
[08:36.000 --> 08:40.000]  Вот, понятно, что не хочется, смотрите, здесь очень важный момент,
[08:40.000 --> 08:45.000]  заключается в том, что мы не хотим запускать DFS для каждой вершины по отдельности.
[08:45.000 --> 08:47.000]  Да, или каким-то образом это хранить.
[08:47.000 --> 08:50.000]  То есть хотелось бы как-то получать фронтаймер и ходить из-за того,
[08:50.000 --> 08:55.000]  что у нас два ребра между собой пересекаются, две вершины между собой пересекаются.
[08:55.000 --> 08:59.000]  И как раз нам сейчас нужно будет вводить уравнение потока.
[08:59.000 --> 09:01.000]  Давайте как раз посмотрим.
[09:01.000 --> 09:04.000]  Для каждой вершины мы можем найти такой подграф.
[09:04.000 --> 09:06.000]  Пока что мы не обсуждаем, как он построился,
[09:06.000 --> 09:09.000]  но мы в целом видим, вот как этот граф выглядит.
[09:09.000 --> 09:12.000]  То есть что мы здесь явно видим?
[09:12.000 --> 09:15.000]  Я не знаю, жирно-цветом здесь все прекрасно видно?
[09:15.000 --> 09:18.000]  Или немного размазывается?
[09:18.000 --> 09:19.000]  Да, вроде видно.
[09:19.000 --> 09:21.000]  Значит, смотрите, что у нас получается.
[09:21.000 --> 09:24.000]  У нас переменные P и C, что с собой комплектуют.
[09:24.000 --> 09:27.000]  Да, по вот этому пути.
[09:27.000 --> 09:32.000]  Переменные A и C тоже комплектуют между собой по определенному пути.
[09:32.000 --> 09:36.000]  А вот переменные A и B мы с вами видим, что они не комплектуют.
[09:36.000 --> 09:40.000]  Это означает, что переменные A и B можно алоцировать один в тот же регистр.
[09:40.000 --> 09:42.000]  То есть у нас...
[09:42.000 --> 09:44.000]  А, получается, я...
[09:44.000 --> 09:46.000]  Бак у нас.
[09:46.000 --> 09:51.000]  Здесь у нас регистр RAMID, а здесь регистр APA.
[09:51.000 --> 09:55.000]  То есть вот такой у нас граф потока управления получается.
[09:58.000 --> 10:00.000]  Теперь как строить это все дело?
[10:00.000 --> 10:02.000]  Давайте посмотрим.
[10:02.000 --> 10:05.000]  Здесь нужно будет ввести некоторое обозначение.
[10:05.000 --> 10:09.000]  Сейчас будет некоторое динамическое программирование.
[10:09.000 --> 10:11.000]  Значит, первое.
[10:11.000 --> 10:14.000]  Давайте обозначим successor от V.
[10:14.000 --> 10:17.000]  Это список выходящих вершин из вершины V.
[10:17.000 --> 10:21.000]  Пред V – это список всех вершин, которые входят в вершину V.
[10:21.000 --> 10:28.000]  Дальше у нас будет def V – список переменных, которые определяют значения в определенной вершине.
[10:28.000 --> 10:33.000]  То есть там, где у нас есть ассаймы какие-то, либо присваивания.
[10:33.000 --> 10:38.000]  Use – список переменных, которые используются в этой вершине.
[10:38.000 --> 10:44.000]  In – это список переменных, которые живы на каком-то входном репре V.
[10:44.000 --> 10:46.000]  То есть видите список живых переменных.
[10:46.000 --> 10:51.000]  Out of left – это список переменных, которые живы на каком-то выходном репре ASV.
[10:51.000 --> 10:55.000]  Да, мы ввели понятие «живая» и «переменная».
[10:55.000 --> 10:58.000]  Переменная жива, если она…
[10:58.000 --> 11:01.000]  Собственно, про репрому сказали.
[11:01.000 --> 11:10.000]  Переменная жива на репре, если эта репро содержится на пути от присваивания значения до операции чтения.
[11:15.000 --> 11:21.000]  И давайте теперь выведем вот этот факт, утверждение, которое вы не поверите.
[11:21.000 --> 11:24.000]  Наверное, мы даже с вами докажем сейчас.
[11:29.000 --> 11:31.000]  Не-не-не.
[11:35.000 --> 11:38.000]  Да, это live analysis.
[11:45.000 --> 11:49.000]  А live analysis, да?
[11:59.000 --> 12:07.000]  Давайте я просто попытаюсь привести вот это все дело над доской, чтобы мы это…
[12:14.000 --> 12:16.000]  Так.
[12:18.000 --> 12:20.000]  Утверждение.
[12:27.000 --> 12:29.000]  Use at end.
[12:29.000 --> 12:31.000]  Ne-ne-ne-ne-ne.
[12:37.000 --> 12:39.000]  And use at end.
[12:39.000 --> 12:41.000]  И at end.
[12:45.000 --> 12:47.000]  Это обменение.
[12:50.000 --> 12:52.000]  Yes.
[12:55.000 --> 12:57.000]  Следовательно, at end.
[12:59.000 --> 13:06.000]  Вот такое у нас сравнение должно быть, давайте подумаем, почему это так.
[13:06.000 --> 13:15.000]  Утверждение, что переменные, которые живут на контакте в одном ребре из v,
[13:16.000 --> 13:23.000]  Значит, у нас есть переменная v, вот у нас ребро n.
[13:29.000 --> 13:35.000]  Что нам нужно доказать? Представим себе, что у нас вершина, вот это вот ребро, у нас живо.
[13:35.000 --> 13:47.000]  Главное, ребро у нас живо. Давайте я тут отключу шаринг, чтобы вот так сделать.
[13:47.000 --> 13:54.000]  Ай, черт, как это полному сделать? Наверное, мне надо кром включить.
[13:54.000 --> 13:59.000]  И на ten это список перемен, которые живы на каком-то входном ребре из v.
[13:59.000 --> 14:07.000]  Дальше нам нужно доказать, когда она жива, какие у нас варианты есть.
[14:07.000 --> 14:14.000]  У нас есть два варианта на самом деле. Ути, вот у нас путь.
[14:14.000 --> 14:21.000]  То есть у нас здесь есть операция store и где-то дальше есть операция load.
[14:21.000 --> 14:27.000]  Где у нас операция load может присутствовать? Ну, использование этой переменной.
[14:27.000 --> 14:37.000]  Значит, варианта на самом деле два. Вариант номер один. Мы останавливаемся в этой перемене.
[14:37.000 --> 14:42.000]  Да, то есть мы используем эту переменную здесь. Соответственно, путь начинается здесь, заканчивается в этой перемене.
[14:42.000 --> 14:47.000]  Тогда это к чему относится, к какому из пунктов?
[14:47.000 --> 14:53.000]  Use of ten или вот к правому пункту?
[14:53.000 --> 14:58.000]  Да, то есть мы эту переменную используем прямо здесь.
[14:58.000 --> 15:08.000]  Хорошо, если у нас есть какой-то путь, в второй случай, то что тогда у нас происходит?
[15:08.000 --> 15:20.000]  Соответственно, по вот этому пути, по которому мы идем, давайте рассмотрим первое ребро, которое здесь находится.
[15:20.000 --> 15:30.000]  Смотрите, тогда у нас получается явно, что in будет вот эта переменная n.
[15:30.000 --> 15:38.000]  Она лежит в autodown нашей переменной x.
[15:38.000 --> 15:46.000]  Но при этом, смотри, почему у нас в данном случае x не принадлежит defat?
[15:46.000 --> 15:55.000]  То есть мы доказали, что нет, вот эта штука лежит в use of ten или в autodown, но пока про те потом говорит.
[15:55.000 --> 16:02.000]  Почему переменная x не может лежать в defat?
[16:02.000 --> 16:10.000]  На этой перемене мы не определяли эти перемены.
[16:10.000 --> 16:19.000]  Не, не, надо показать почему.
[16:19.000 --> 16:31.000]  Ну смотрите, что произойдет, если окажется, что мы переменную x определили здесь?
[16:31.000 --> 16:37.000]  Не, не, на самом деле, если мы переменную определили здесь, что такое определить переменную?
[16:37.000 --> 16:41.000]  Это по факту начать новую путь записи переменной.
[16:41.000 --> 16:46.000]  То есть по факту, получается, мы определили переменную в вершине 1.
[16:46.000 --> 16:52.000]  Вот здесь написали x равно чему-то там, и здесь x равно чему-то там.
[16:52.000 --> 16:58.000]  Но вопрос, тогда будет ли переменная x в этой ипостасе жива здесь?
[16:58.000 --> 17:02.000]  Нет, не будет, потому что мы ее переопределили по новостям.
[17:02.000 --> 17:11.000]  Перевалочный пункт говорит следующее, что эту вершину мы не можем определить.
[17:11.000 --> 17:17.000]  Вот, поэтому получается, в одну сторону мы с вами доказали, что x лежит в inotent.
[17:17.000 --> 17:22.000]  Если x лежит в inotent, то она либо использована, либо не идет.
[17:22.000 --> 17:27.000]  Давайте в обратную сторону рассудим. Пусть у нас x лежит в inotent.
[17:27.000 --> 17:30.000]  В одну сторону понятно.
[17:34.000 --> 17:37.000]  Вопросов у нас таки много, поэтому...
[17:52.000 --> 17:54.000]  Что означает что?
[17:54.000 --> 17:59.000]  Что означает, что вершина жива на этой перемене.
[17:59.000 --> 18:02.000]  Что означает, что вершина жива на этой перемене?
[18:02.000 --> 18:06.000]  Вот у нас есть операция, когда мы эту переменную поставили.
[18:06.000 --> 18:12.000]  А здесь мы использовали эту переменную.
[18:12.000 --> 18:15.000]  Именно после этого прислали.
[18:15.000 --> 18:19.000]  Соответственно, у нас прошелся какой-то путь,
[18:19.000 --> 18:28.000]  и на каждом из этих шагов нам так или иначе значение переменной A нужно хранить.
[18:28.000 --> 18:35.000]  Любое лицо, которое есть, оно должно хранить эту переменную A.
[18:35.000 --> 18:37.000]  На этом пути.
[18:37.000 --> 18:41.000]  Это означает, что переменная A жива на этой перемене.
[18:42.000 --> 18:47.000]  Все пути, которые у нас есть, в которых мы определили какую-то переменную A,
[18:47.000 --> 18:51.000]  до того момента, как мы эту переменную A...
[18:51.000 --> 18:53.000]  У нас будет она жива на пути...
[18:53.000 --> 18:58.000]  Ой, она жива на пути, если есть вершина,
[18:58.000 --> 19:05.000]  которая ведет в библиотеку до какого-то упражнения,
[19:05.000 --> 19:08.000]  где она используется.
[19:08.000 --> 19:09.000]  Да, да, да.
[19:09.000 --> 19:11.000]  Ну, не будет уже спрашивать, да.
[19:16.000 --> 19:18.000]  Ну да, по факту...
[19:18.000 --> 19:20.000]  По факту да, у нас будет набор...
[19:27.000 --> 19:35.000]  Соответственно, если у нас какая-то переменная...
[19:35.000 --> 19:41.000]  Две каких-то переменах находятся живыми на одном и том же регистре,
[19:41.000 --> 19:43.000]  то мы их не можем поместить в один и тот же регистр.
[19:43.000 --> 19:47.000]  Потому что если мы одну из переменных запишем в один регистр,
[19:47.000 --> 19:50.000]  то вторую переменную мы перезатрем.
[19:54.000 --> 19:56.000]  И как раз мы говорим теперь следующее,
[19:56.000 --> 20:00.000]  что для этих переменных мы пытаемся определить факты,
[20:00.000 --> 20:05.000]  как пересчитывать список переменных, которые живы на куполке 1.5.
[20:08.000 --> 20:10.000]  То есть по входам и по выходам.
[20:13.000 --> 20:15.000]  Так.
[20:15.000 --> 20:17.000]  А, понятно.
[20:17.000 --> 20:18.000]  Ага.
[20:18.000 --> 20:20.000]  Теперь вот это упражнение.
[20:22.000 --> 20:24.000]  Да, оно понятно.
[20:24.000 --> 20:26.000]  Значит, в обратную сторону.
[20:26.000 --> 20:28.000]  Что у нас получается?
[20:28.000 --> 20:33.000]  У нас есть вершина, которая лежит в списке использованных от n.
[20:33.000 --> 20:35.000]  Нам нужно доказать, что она...
[20:43.000 --> 20:47.000]  Нам нужно доказать, что эта переменная жива теперь на...
[20:49.000 --> 20:51.000]  Где она жива?
[20:53.000 --> 20:55.000]  А, она жива на коптере в ребре.
[20:55.000 --> 20:57.000]  Ну, давайте калуна.
[20:57.000 --> 21:01.000]  Здесь, кстати, нам понадобится знание из front-end.
[21:01.000 --> 21:07.000]  Вот, смотрите, представьте, что у нас x используется в этом моменте.
[21:07.000 --> 21:13.000]  Хорошо, представим себе, что у нас переменная нигде не жива.
[21:13.000 --> 21:16.000]  То есть ни на каком входном пути, и зато вершина.
[21:18.000 --> 21:21.000]  Тогда что мы можем сказать про эту переменную x?
[21:23.000 --> 21:27.000]  Не то что не бесполезно, эта переменная просто не определена нигде.
[21:29.000 --> 21:33.000]  Да, то есть мы пытаемся определить, что у нас есть вершина,
[21:34.000 --> 21:37.000]  да, то есть мы пытаемся использовать переменную,
[21:37.000 --> 21:39.000]  которую вот это не определили.
[21:39.000 --> 21:41.000]  Это, извините, ошибка для апелляции.
[21:41.000 --> 21:43.000]  Мы с этим на front-end собрались.
[21:43.000 --> 21:47.000]  Ну, мы предполагаем, что все стати оптимизации, все стати...
[21:47.000 --> 21:49.000]  Ну, мы сейчас...
[21:49.000 --> 21:51.000]  Не, а у нас есть...
[21:51.000 --> 21:53.000]  Она определена, она может быть...
[21:55.000 --> 21:58.000]  Вот компонент, что у нее дипломное значение, если поставить это.
[21:58.000 --> 22:00.000]  Вот вся индекс.
[22:01.000 --> 22:06.000]  А, ну, это мы должны были сделать на уровне, кажется, предыдущей стати.
[22:09.000 --> 22:11.000]  Поставить значение.
[22:15.000 --> 22:18.000]  Или мы говорим, что у нас может быть undefined behavior.
[22:19.000 --> 22:23.000]  Ну, перемена в плане установить дипломное значение.
[22:23.000 --> 22:25.000]  Ну да, да, да.
[22:25.000 --> 22:27.000]  О-о-о!
[22:29.000 --> 22:32.000]  Не будет прекрасно еще акклетика на undef.
[22:32.000 --> 22:34.000]  А, ничего, да.
[22:34.000 --> 22:36.000]  И еще акклетика на undef.
[22:37.000 --> 22:39.000]  А undef и suandef это что?
[22:40.000 --> 22:42.000]  Не знаю.
[22:42.000 --> 22:47.000]  Скорее всего, похоже, сильно похоже, что будет, если у вас сложится строковый трип в шамп-скрипте.
[22:47.000 --> 22:50.000]  Нет, тут в таком плане попросту два...
[22:50.000 --> 22:53.000]  Undefа пришедши как одной переменной или два разных undefа?
[22:53.000 --> 22:55.000]  Если одна переменная, то это будет.
[22:55.000 --> 22:58.000]  А если она, например, разная, то это будет.
[22:58.000 --> 22:59.000]  Ну да.
[22:59.000 --> 23:03.000]  Ну, в общем, давайте не учитывая эти случаи и говорить, что у нас просто иппиляция брона.
[23:04.000 --> 23:05.000]  Второй случай.
[23:05.000 --> 23:07.000]  Значит, переменная у нас...
[23:10.000 --> 23:15.000]  Получается вышла из какой-то вершины, но при этом она не была определена.
[23:15.000 --> 23:19.000]  То есть у нас получается x is out от m.
[23:19.000 --> 23:22.000]  То есть у нас существуют три броны, в которых эта переменная жила.
[23:22.000 --> 23:25.000]  Но при этом она не определена в этой перемене.
[23:25.000 --> 23:29.000]  Значит, эту перемену мы на пути определили где-то раньше.
[23:29.000 --> 23:35.000]  Смотрим первое ревро, в которое пошел этот путь.
[23:35.000 --> 23:40.000]  И это как раз сэкономизирует, что вершина у нас лежит в списке ходячих вершин.
[23:44.000 --> 23:47.000]  У кого-то есть мысли, зачем мы это все доказываем?
[23:47.000 --> 23:49.000]  Вот этот факт доказываем.
[23:50.000 --> 23:51.000]  Вот.
[23:53.000 --> 23:54.000]  Да.
[23:54.000 --> 23:56.000]  Нет, зачем мы эти формулы доказываем?
[23:59.000 --> 24:06.000]  А смотрите, потом, когда мы будем иметь в наличии книги аутов, мы сможем достаточно быстро прочитать
[24:06.000 --> 24:10.000]  на каждом вершине, какие ребра у меня входят, какие ребра у меня не входят.
[24:10.000 --> 24:16.000]  Соответственно, сразу причем алгоритмы будут напоминать алгоритмы насыщения.
[24:16.000 --> 24:17.000]  То есть что такое алгоритмы насыщения?
[24:17.000 --> 24:18.000]  Это алгоритмы насыщения.
[24:18.000 --> 24:23.000]  Когда у вас есть стратегический алгоритм, для каждой переменной вы что-то объявляете,
[24:23.000 --> 24:26.000]  какие-то наборы значений изначально.
[24:26.000 --> 24:29.000]  А дальше вы делаете, делаете, делаете и повторяете этот алгоритм до сих пор,
[24:29.000 --> 24:32.000]  пока у вас все значения не стабилизируются.
[24:32.000 --> 24:36.000]  Как говорится, пока у нас что-то меняется, мы делаем насыщение.
[24:36.000 --> 24:38.000]  Классическая идея.
[24:40.000 --> 24:44.000]  Тот же самый алгоритм Merle, если вы его помните, работает точно так же.
[24:47.000 --> 24:50.000]  Хорошо, значит, второй способ.
[24:50.000 --> 24:52.000]  Да, вторая формула.
[24:58.000 --> 25:05.000]  Вторая формула Out of N равно количеству отгинем всех саксессоров от вершины N.
[25:05.000 --> 25:08.000]  Так, то есть что такое у нас саксессор?
[25:08.000 --> 25:11.000]  Список вершин выходящих из B.
[25:14.000 --> 25:16.000]  То есть у нас есть...
[25:18.000 --> 25:19.000]  А?
[25:21.000 --> 25:23.000]  Ну по факту да.
[25:23.000 --> 25:26.000]  То есть у нас, значит, получается...
[25:29.000 --> 25:31.000]  Вершина является...
[25:35.000 --> 25:38.000]  Точнее, переменная является живой для вершины,
[25:40.000 --> 25:42.000]  причем конечной вершины.
[25:42.000 --> 25:47.000]  То есть если она является живой для вершины, которая была начальная...
[25:47.000 --> 25:52.000]  Ну да, это по факту мы переписали обредление.
[25:54.000 --> 25:57.000]  Так, хорошо, значит, мы эти формы доказали.
[25:57.000 --> 25:59.000]  Так, здесь мы...
[25:59.000 --> 26:02.000]  Да, сразу поясню, что у нас сегодня...
[26:03.000 --> 26:05.000]  Как называется обычно?
[26:06.000 --> 26:08.000]  FOMART съемка или как?
[26:08.000 --> 26:10.000]  Да.
[26:10.000 --> 26:12.000]  В общем, мы доказали вот этот переход,
[26:12.000 --> 26:15.000]  и теперь мы можем использовать это для своих целей.
[26:16.000 --> 26:17.000]  Собственно, идея такая.
[26:17.000 --> 26:19.000]  Давайте мы пока...
[26:21.000 --> 26:24.000]  Пока множество IN и OUT меняется, мы делаем следующее.
[26:24.000 --> 26:29.000]  То есть мы присваиваем значение и пересчитываем те значения, которые есть.
[26:29.000 --> 26:34.000]  Изначально, кстати, нам нужно поставить точку инициализации нашего алкорита.
[26:34.000 --> 26:36.000]  Какую точку поставим?
[26:36.000 --> 26:38.000]  Давайте подумаем.
[26:41.000 --> 26:43.000]  У нас поменение, значит...
[26:45.000 --> 26:47.000]  Не, ну кажется, тогда у нас ничего не...
[26:48.000 --> 26:50.000]  А, у нас же есть use, так?
[26:51.000 --> 26:53.000]  У нас есть use, поэтому с этим проблем не будет.
[26:53.000 --> 26:57.000]  То есть у нас изначально для каждой переменной мы можем поставить пустое множество,
[26:57.000 --> 26:59.000]  а дальше мы делаем use.
[26:59.000 --> 27:00.000]  Переменно.
[27:00.000 --> 27:02.000]  Некральная прооперация.
[27:02.000 --> 27:03.000]  Да.
[27:03.000 --> 27:06.000]  Вот, значит, и вот он пример вычислений для этого графа.
