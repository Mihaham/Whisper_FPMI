[00:00.000 --> 00:15.000]  Смотрите, что мы изучили в прошлый раз. Мы изучили, что бывают задачи, которые перечислимые, но неразрешимые.
[00:15.000 --> 00:25.000]  То есть, в целом, можно рисовать такую диаграмму Эйлера.
[00:25.000 --> 00:54.000]  Есть множество перечислимое, есть множество коперечислимое, и есть пересечение и пересечение в точность разрешимой множества.
[00:54.000 --> 01:06.000]  Это нам критика Теремы Поста. Терема Поста говорит, что множество разрешимо только тогда, когда и оно само перечислимо, и его дополнение тоже перечислимо, то есть оно коперечислимо.
[01:06.000 --> 01:29.000]  Дальше мы изучали разные задачи. Например, проблема самоприменимости была вот здесь, проблема остановки или остановка была вот здесь.
[01:29.000 --> 01:49.000]  Коперечислимое мы в явном виде не приводили, но, например, нигде неопределенная программа, то есть множество программ, которые ни на одном входе не останавливаются, будут коперечислимым.
[01:49.000 --> 02:03.000]  Почему это так? А давайте прямо докажем аккуратненько.
[02:03.000 --> 02:28.000]  Теорема множества таких П, что для любого Х у от Пх не определено. Вот это множество коперечислимо, но неразрешимо.
[02:28.000 --> 02:43.000]  Почему оно коперечислимо? Ну, его дополнение, доказательство. Почему коперечислимо?
[02:43.000 --> 03:02.000]  Ну, потому что его дополнение это множество таких П, что существует Х такое, что у от Пх определено.
[03:02.000 --> 03:21.000]  А можно еще по-другому написать. Можно написать, что это равно множество таких П, что существует Х и существует Т, такие, что у от Пх останавливается за Т шагов.
[03:21.000 --> 03:31.000]  Вот. Но вот эта вот часть, после кванторов, это свойство разрешимое.
[03:31.000 --> 03:50.000]  Получается, что вот это разрешимое свойство тройки Пхта.
[03:50.000 --> 03:55.000]  Ну и тогда получаем, что дополнение перечислимо как проект разрешимого.
[03:55.000 --> 04:06.000]  Так, потому что здесь хоть и две переменных, но по ним один тот же квантор, так что можно вместо этого написать, что существует пара из Х и Т.
[04:06.000 --> 04:27.000]  То есть получаем, что дополнение перечислимо. Ну а, соответственно, само множество коперечислимо.
[04:27.000 --> 04:43.000]  Так, почему оно неразрешимое? Ну, неразрешимое, потому что, опять же, это на самом деле верно. В самом конце обсуждали про главную нумерацию.
[04:43.000 --> 04:52.000]  Это вот что неразрешимо. Ну вот, для проблем основки это всегда верно.
[04:52.000 --> 04:59.000]  А вот для нигде неопределенной это не всегда верно, что оно неразрешимо. Верно только для главной нумерации.
[04:59.000 --> 05:17.000]  Ну, интуиция такая, что можно посмотреть... Так, давайте на следующую страницу.
[05:17.000 --> 05:41.000]  Почему оно неразрешимое? Ну, потому что можно рассмотреть... Рассмотрим Q такую, что для любого Y у от Qy равняется у от px.
[05:41.000 --> 06:09.000]  И тогда получается, что Q нигде не определена. Тогда и только тогда, когда у от px останавливается.
[06:09.000 --> 06:26.000]  Ну и что же получается? Мы не можем определить, верно ли, что у от px останавливается, значит не можем определить, что Q нигде не определена.
[06:26.000 --> 06:35.000]  Если бы мы про Q могли определить верно ли, что она нигде не определена, то мы смогли бы про пару px определить верно ли вот это.
[06:35.000 --> 06:51.000]  То есть мы получаем, что вот это вот неразрешимо. Из этого следует, что вот это вот тоже неразрешимо.
[06:51.000 --> 07:08.000]  Так, ну ничего, понятно? Но здесь используется на самом деле определение главности или опорно какой-нибудь конкретный язык программирования, что можно...
[07:08.000 --> 07:27.000]  Что как бы превращение пары px вот в такое Q, это вычислимая задача. Иначе нельзя сделать такую штуку, потому что мы не сможем по px найти такое Q.
[07:27.000 --> 07:40.000]  Так, ну и еще у нас, давайте я вернусь сюда. Еще у нас был пример задач, которая вообще снаружи не перечислима, не коперечислима.
[07:40.000 --> 07:50.000]  Эта задача, наоборот, всюду определена. Верно ли, что программа всюду определена?
[07:50.000 --> 08:00.000]  Значит, вот эта вот задача, она не перечислима и не коперечислима. Но, опять же, только вот для главных нумераций.
[08:00.000 --> 08:10.000]  Так, ну у нас сейчас самое время вспомнить, что такое главная нумерация или главная универсально училимая функция.
[08:10.000 --> 08:20.000]  Но я говорю о нумерации иногда, потому что можно считать, что программа или код программы или номер программы это номер функции, которую она вычисляет.
[08:20.000 --> 08:32.000]  Вот, и можно считать, что, соответственно, универсально училимая функция или тампилятор, можно сказать, задает нумерацию всех вычилимых функций.
[08:32.000 --> 08:37.000]  То есть номер вычилимой функции это фактически программа, которая ее вычисляет.
[08:37.000 --> 08:47.000]  Так, ну вот, значит, соответственно, главная универсальная вычислимая функция.
[08:47.000 --> 08:55.000]  Значит, это у, который берет два аргумента.
[08:55.000 --> 09:05.000]  Но тут смотрите, я уже много раз говорил, что есть два стандартных подхода, что вычилимые функции определены на натуральных числах.
[09:05.000 --> 09:11.000]  Это исторически первый подход, или что функции определены на словах из нулей единицы.
[09:11.000 --> 09:19.000]  Это такой более современный подход, потому что сейчас мы привыкли, что все кодируется битами, поэтому все определяется на словах.
[09:19.000 --> 09:28.000]  А в 30-х годах прошлого века компьютеров еще не было, так что люди не привыкли к универсальному кодированию,
[09:28.000 --> 09:36.000]  зато уже много знали про математику, поэтому они, соответственно, любили все натуральными числами кодировать.
[09:36.000 --> 09:46.000]  Вообще, на самом деле, кодирование оно же не только из компьютерной техники взялось,
[09:46.000 --> 09:54.000]  но, например, еще из генетического кода, который тоже был открыт в 50-х годах, в 30-х о нем еще не знали.
[09:54.000 --> 10:02.000]  Поэтому сейчас для нас как-то привычнее говорить про строки, слова и так далее.
[10:02.000 --> 10:08.000]  Но, с другой стороны, можно и про числа говорить. Это, по крайней мере, короче.
[10:08.000 --> 10:12.000]  Стандартный символ для натуральных чисел.
[10:17.000 --> 10:21.000]  Стандартного значения это один символ, а не несколько.
[10:21.000 --> 10:25.000]  Код. Главная универсальная вычислимая функция U.
[10:25.000 --> 10:29.000]  Это функция, которая заплывает следующими свойствами.
[10:29.000 --> 10:40.000]  Во-первых, она сама вычислима. У вычислима как функция от двух аргументов.
[10:41.000 --> 10:51.000]  Во-вторых, она универсальная, что означает, что для любой вычислимой F,
[10:51.000 --> 10:57.000]  которая отображает нейтральные числа и нейтральные числа,
[10:57.000 --> 11:09.000]  существует такой номер P или такая программа P, что для любого x U от Px равняется F от x.
[11:09.000 --> 11:16.000]  Вот это еще то, что называется полнотап от юринга для языкопрограммирования.
[11:16.000 --> 11:20.000]  То есть, что можно любую задачу на этом языке решить.
[11:22.000 --> 11:33.000]  И, наконец, третье свойство, которое и говорит, что это главная универсальная функция,
[11:33.000 --> 11:38.000]  что фактически можно писать транслятор на нее с любого другого языкопрограммирования.
[11:38.000 --> 11:45.000]  Тут для любой вычислимой функции двух аргументов
[11:45.000 --> 11:53.000]  существует S.
[11:53.000 --> 12:05.000]  Значит, S это всюду определенная, всюду определенная вычислимая функция.
[12:05.000 --> 12:21.000]  Такая, что для любого P и для любого x V от P и x равняется U от S от P и x.
[12:21.000 --> 12:31.000]  Вот, то есть, что делает S?
[12:31.000 --> 12:37.000]  S фактически переводит с языка U на язык V.
[12:37.000 --> 12:44.000]  То есть, S берет программу P, которая дает какую-то функцию.
[12:44.000 --> 12:47.000]  То есть, вот это V от P и x равняется какому-то F от x.
[12:47.000 --> 12:52.000]  И можно сказать, что P это программа для той функции на языке V.
[12:52.000 --> 12:56.000]  И вот эта вот функция S из программы P делает программу S от P,
[12:56.000 --> 13:01.000]  которая будет программой для той же самой функции на языке U.
[13:01.000 --> 13:04.000]  Ну, вот такой транслятор получается.
[13:04.000 --> 13:09.000]  Значит, в принципе, такой транслятор всегда есть, но для главной он не просто есть,
[13:09.000 --> 13:11.000]  а он всегда определен и вычислен.
[13:11.000 --> 13:15.000]  Ну, в смысле, он всегда всегда определен, но он еще и вычислим.
[13:15.000 --> 13:19.000]  То есть, такая программа всегда есть, но не всегда его можно найти.
[13:19.000 --> 13:25.000]  А вот для главной всегда можно найти.
[13:25.000 --> 13:28.000]  Вот.
[13:28.000 --> 13:32.000]  Хорошо, теперь что я хочу про эти функции сказать?
[13:32.000 --> 13:37.000]  Так, ну, смотрите, вот если вернемся на эту диаграмму,
[13:37.000 --> 13:41.000]  то здесь, ну, вот самоприменимость,
[13:41.000 --> 13:45.000]  самоприменимость это не свойство функции на самом деле.
[13:45.000 --> 13:52.000]  Потому что для одной и той же задачи можно написать самоприменимую программу,
[13:52.000 --> 13:55.000]  а можно не самоприменимую.
[13:55.000 --> 14:01.000]  Ну, например, давайте, почему так происходит, пример.
[14:01.000 --> 14:06.000]  Например, пусть у меня функция ищет в программе какой-нибудь символ.
[14:06.000 --> 14:08.000]  Ну, вообще в тексте.
[14:08.000 --> 14:12.000]  Функция ищет в тексте символ и ищет там твердый знак.
[14:12.000 --> 14:17.000]  Вот есть файл какой-нибудь кодировки стандартной, кириллической.
[14:17.000 --> 14:20.000]  И она в этом файле ищет твердый знак.
[14:20.000 --> 14:23.000]  И если она его нашла, то она останавливается.
[14:23.000 --> 14:27.000]  А если не нашла, то, соответственно, не останавливается, зацикливается.
[14:27.000 --> 14:29.000]  Ну, можно сказать, что она ищет, пока не найдет.
[14:29.000 --> 14:33.000]  Если его там нет, то она всегда будет искать.
[14:33.000 --> 14:36.000]  Вот такая функция.
[14:36.000 --> 14:39.000]  Но теперь как ее можно реализовать?
[14:39.000 --> 14:43.000]  Можно реализовать, что вот символ твердый знак и ищи его в тексте.
[14:43.000 --> 14:47.000]  То есть все символы сравнивай с этим символом.
[14:47.000 --> 14:50.000]  Тогда в этом тексте программа есть твердый знак,
[14:50.000 --> 14:54.000]  и она на своем собственном тексте остановится.
[14:54.000 --> 14:58.000]  А можно взять другую программу, которая говорит,
[14:58.000 --> 15:03.000]  возьмите символ ща и возьмите следующую букву алфавита.
[15:03.000 --> 15:07.000]  И потом эту следующую букву ищите.
[15:07.000 --> 15:11.000]  Тогда вот в этой программе в тексте такой программы нет символа твердый знак,
[15:11.000 --> 15:14.000]  хотя она делает то же самое.
[15:14.000 --> 15:20.000]  Советственно, получается, что одна программа останавливается на собственном тексте,
[15:20.000 --> 15:24.000]  другая делает то же самое, но на собственном тексте не останавливается.
[15:24.000 --> 15:28.000]  Поэтому самоприменимость — это свойство конкретной реализации.
[15:28.000 --> 15:34.000]  Но все остальное — остановка, нигде неопределенность, всю доопределенность и еще куча всего остального —
[15:34.000 --> 15:40.000]  это свойство не реализации, а свойство функций, которые программа вычисляет.
[15:40.000 --> 15:46.000]  Какие-то свойства реализации могут быть даже разрешимыми.
[15:46.000 --> 15:51.000]  Например, что длина программы не больше 1000 символов.
[15:51.000 --> 15:55.000]  Да, вот это, конечно, разрешимое свойство.
[15:55.000 --> 16:01.000]  Но с другой стороны, все, наверное, понимают, что если какую-то программу можно написать,
[16:01.000 --> 16:04.000]  то можно ее сколько-либо раздуть.
[16:04.000 --> 16:08.000]  То есть если есть программа, реализующая функцию короче 1000 символов,
[16:08.000 --> 16:12.000]  то можно написать и другую, которая будет длиннее 1000 символов.
[16:12.000 --> 16:17.000]  Ну уж как минимум за счет написания комментариев.
[16:17.000 --> 16:21.000]  Даже если комментариев в языке нет, то все равно можно что-то делать.
[16:21.000 --> 16:25.000]  Бессмысленное, да, но зато оно занимает текст программы.
[16:30.000 --> 16:34.000]  Ну вот, поэтому какие-то такие свойства могут быть даже разрешимыми.
[16:34.000 --> 16:38.000]  Но вот все, что связано с функциями, пока у нас было, оно не разрешимо.
[16:38.000 --> 16:43.000]  Может быть перечислимо как проблема остановки, может быть...
[16:43.000 --> 16:49.000]  Может быть перечислимо как нигде неопределенность, может быть даже ни то ни другое, как сюда, определенность.
[16:49.000 --> 16:56.000]  Вот, но вот сейчас я хочу про это доказать теорему, что вот здесь вот может быть только в тривиальном случае,
[16:56.000 --> 17:01.000]  то есть если свойство всегда верно или никогда не верно, то оно, конечно, разрешимо.
[17:01.000 --> 17:07.000]  Но если свойство либо может быть как верно, так и неверно, и при этом это свойство функции,
[17:07.000 --> 17:12.000]  то мы не можем понять, обладает ли данная программа этим свойством или нет.
[17:12.000 --> 17:19.000]  Так, хорошо, теперь давайте я запишу это.
[17:19.000 --> 17:27.000]  Так, пусть какое-нибудь А красивое.
[17:28.000 --> 17:41.000]  Значит, А красивое это множество вычислимых функций одного аргумента.
[17:45.000 --> 17:55.000]  Значит, такое, что, соответственно, А не пусто и А с чертой тоже не пусто.
[17:57.000 --> 18:13.000]  Вот тогда теорема Успенского райса
[18:13.000 --> 18:35.000]  заключается в следующем, что множество таких программ, что программа задает,
[18:35.000 --> 18:43.000]  А, сейчас, подождите, так, нет, давайте я его аккуратнее сформулирую.
[18:43.000 --> 18:57.000]  Пусть У это главная универсальная вычислимая функция.
[18:57.000 --> 19:05.000]  А вот такое вот.
[19:05.000 --> 19:24.000]  Значит, тогда множество таких П, что у, так, вот тут есть такое обозначение с точечкой.
[19:24.000 --> 19:30.000]  Значит, обозначение с точечкой означает, что то, что написано, воспринимается как функция только вот от этой точечки.
[19:30.000 --> 19:37.000]  То есть, П фиксировано, а Х это аргумент.
[19:37.000 --> 19:47.000]  В общем, множество таких П, что соответствующее сечение лежит в А красивом,
[19:47.000 --> 20:03.000]  значит, это неразрешимое множество.
[20:03.000 --> 20:13.000]  То есть, получается, что если есть программы, то есть если есть функция, обладающая хорошим свойством, есть функция, им не обладающая,
[20:13.000 --> 20:23.000]  то невозможно по тексту программы сказать, вычислямая ей функция обладает эти свойства или не обладает.
[20:23.000 --> 20:29.000]  Но это если это главная универсальная вычислимая функция.
[20:29.000 --> 20:34.000]  Так, понятно ли утверждение теоремы?
[20:34.000 --> 20:39.000]  То есть вот, опять же, если вернуться на нашу диаграмму в начало,
[20:39.000 --> 20:45.000]  то теорема говорит, что вот эти свойства именно функций могут быть вот здесь, вот здесь, вот здесь, вот здесь,
[20:45.000 --> 21:00.000]  но никогда не могут быть вот здесь, вот, да, только если это тривиальное свойство.
[21:00.000 --> 21:08.000]  Так, ну ладно, давайте будем доказывать.
[21:08.000 --> 21:16.000]  И в доказательстве нам как раз поможет нигде неопределенная функция.
[21:16.000 --> 21:33.000]  Так, значит, пусть вот здесь такая буква, зета, греческая буква, ее полезно уметь писать, встречается в математике.
[21:33.000 --> 21:50.000]  Значит, zeta от x это нигде неопределенная функция, нигде неопределенная функция.
[21:50.000 --> 22:04.000]  И вот, значит, без ограничений общности, без ограничений общности эта функция zeta лежит в а красивом.
[22:04.000 --> 22:10.000]  Что если вдруг не лежит, мы перейдем к дополнению, да, она же где-то лежит, либо в а, либо в дополнение к а.
[22:10.000 --> 22:16.000]  Если в дополнение, то мы переименуем дополнение а в а, будем доказывать неразрешимость дополнения,
[22:16.000 --> 22:24.000]  но а разрешимость, поскольку сохраняется при дополнении, то, значит, для исходного она тоже верно.
[22:24.000 --> 22:46.000]  А, значит, без ограничений общности zeta лежит в а, и пусть тогда кси, значит, пусть кси лежит...
[22:46.000 --> 22:55.000]  А, хотя сейчас, может быть, наоборот удобнее. Понятно, что это неважно, но в каком-то варианте удобнее излагать.
[23:03.000 --> 23:07.000]  Да, вообще, наверное, не очень важно.
[23:07.000 --> 23:21.000]  Да, вроде неважно, так тоже сработает. Пусть z лежит в а, а какая другая функция кси лежит в а с чертой.
[23:21.000 --> 23:27.000]  Поскольку свойство нетривиально, то найдется функция, которая в а с чертой лежит.
[23:27.000 --> 23:49.000]  Так, теперь, что мы делаем? Теперь пусть k, пусть k это перечислимое, перечислимое, неразрешимое множество.
[23:49.000 --> 24:04.000]  И тогда рассмотрим вот такую функцию.
[24:04.000 --> 24:19.000]  А, значит, v от nx. Это v не случайно, это мы будем подставлять как раз в определение главной функции.
[24:19.000 --> 24:39.000]  Значит, v от nx равняется следующему, оно равно кси от x, если n принадлежит k, и z от x, если n не принадлежит k.
[24:39.000 --> 24:58.000]  Ну, то есть, если вспомнить определение, то вот этот z от x, значит, это не определено, не определено, если n не принадлежит k.
[24:58.000 --> 25:07.000]  Так, значит, вот эта функция v вычислима, v от nx вычислима.
[25:07.000 --> 25:23.000]  Потому что на самом деле, можно сказать, что v от nx это будет кси от x умножить на полухарактеристическую функцию k от n.
[25:23.000 --> 25:30.000]  Да, как раз если n лежит в k, тогда мы единицу умножаем на кси от x, получаем кси от x.
[25:30.000 --> 25:42.000]  А если n не принадлежит k, тогда мы умножаем на неопределенность. На неопределенность не важно, что мы умножаем, получаем неопределенность.
[25:42.000 --> 25:46.000]  Что нам и нужно.
[25:46.000 --> 25:54.000]  Вот, значит, v от nx вычислима. Что тогда нам говорит свойство?
[25:54.000 --> 26:13.000]  Значит, из свойства главной универсальной вычислимой функции мы получаем, что существует всю доопределенную вычислимая s.
[26:13.000 --> 26:33.000]  Такая, что для любых nx, v от nx равняется u от s от n и x.
[26:33.000 --> 27:02.000]  Что же мы получаем? Мы получаем, что если n лежит в k, то тогда для любого x u от s от nx равняется кси от x.
[27:02.000 --> 27:17.000]  Значит, и тогда получается, что s от n лежит в a с чертой.
[27:17.000 --> 27:30.000]  Если n не принадлежит k, то тогда получается, что для любого x u от s от nx равно z от x.
[27:30.000 --> 27:37.000]  И тогда получается, что s от n лежит в a.
[27:37.000 --> 27:47.000]  Почему это так? Потому что кси у нас лежит в a с чертой, а s от n получается программой, которая ее вычисляет.
[27:47.000 --> 28:00.000]  Сейчас, наверное, не совсем хорошо вот так вот писать, потому что a красивое, это именно множество функций.
[28:00.000 --> 28:24.000]  Сейчас это где-то надо вести обозначение.
[28:24.000 --> 28:46.000]  Давайте напишу так. Здесь a прямое с чертой, здесь тоже a прямое, а где-нибудь здесь я напишу, что a прямое это множество таких p, что...
[28:46.000 --> 28:56.000]  А, вот эта штука и есть. Я могу просто вот сюда написать a прямое, которое равняется вот этой штуке.
[28:56.000 --> 29:03.000]  Значит, оно неразрешимо. То есть a красивое множество функций, а a прямое множество программ, которые эти функции вычисляют.
[29:03.000 --> 29:07.000]  Это немножко разные объекты, поэтому я их по-разному обозначаю.
[29:08.000 --> 29:15.000]  Вот, соответственно, получается вот это. Что же получается?
[29:15.000 --> 29:23.000]  Ну, мы получили... Сейчас, что еще раз объяснить?
[29:23.000 --> 29:26.000]  А, две строки. Вот, да.
[29:26.000 --> 29:32.000]  Значит, еще раз, смотрите, кси у нас лежит в a с чертой красивым.
[29:32.000 --> 29:40.000]  Но вот это вот равенство получается, что s от n сдает программу, которая вычисляет кси, то есть вычисляет функцию из a красивого с чертой.
[29:40.000 --> 29:43.000]  Значит, самой s от n лежит в a прямом с чертой.
[29:43.000 --> 29:49.000]  Ну и симметрично вот здесь. Значит, z у нас лежит в a, s от n вычисляет программу, которая лежит в a.
[29:49.000 --> 29:53.000]  Поэтому, соответственно, s от n лежит в a прямом.
[29:53.000 --> 29:55.000]  Что же мы получили?
[29:55.000 --> 29:57.000]  Ну, мы получили, на самом деле, мосводимость.
[29:57.000 --> 30:02.000]  Потому что если тут перейти к дополнению, будет в другую сторону.
[30:02.000 --> 30:04.000]  Ну, не к дополнению, а к отрицанию.
[30:04.000 --> 30:10.000]  Значит, к отрицанию получается то же самое, что сверху, но в другую сторону.
[30:10.000 --> 30:29.000]  То есть в итоге мы получили, что n лежит в k тогда и только тогда, когда s от n лежит в a с чертой.
[30:29.000 --> 30:43.000]  Но тогда получается, что если s от чертой разрешима, то есть k у нас сводится к s чертой.
[30:43.000 --> 31:00.000]  Но поскольку k неразрешима, то я с чертой неразрешима.
[31:13.000 --> 31:23.000]  Ну вот, собственно, все доказали. Нам это и нужно было.
[31:23.000 --> 31:27.000]  Ну, то есть, да, все-таки надо было там исправить.
[31:27.000 --> 31:38.000]  Наоборот, тогда бы здесь а получился неразрешимо, но, по сути, это неважно.
[31:38.000 --> 31:44.000]  Так, ну что, какие-нибудь вопросы?
[31:49.000 --> 31:54.000]  Ну вот, как исходная диаграмма показывала, могут быть три варианта.
[31:54.000 --> 31:58.000]  На самом деле, это еще и больше, как мы в следующей лекции узнаем.
[31:58.000 --> 32:04.000]  В общем, может быть перечислим, может быть ко перечислимо, а может быть ни то, ни другое.
[32:04.000 --> 32:10.000]  Ну вот, в этом ни том, ни другом, на самом деле, есть больше разных вариантов.
[32:10.000 --> 32:16.000]  Вот. Так, ну а сейчас вроде и звонок должен быть.
[32:16.000 --> 32:20.000]  Если вопросов нету, то можно сейчас сделать перерыв.
[32:20.000 --> 32:25.000]  А потом будет другая великая теорема неподвижной точки.
[32:25.000 --> 32:29.000]  Так, ну что ж, давайте продолжим.
[32:37.000 --> 32:40.000]  Может быть, какие-нибудь вопросы появились?
[32:45.000 --> 32:47.000]  Так, ну ладно.
[32:47.000 --> 32:56.000]  Значит, тогда я хочу показать пример, как можно построить неглавную универсальную вычислимую функцию.
[32:56.000 --> 33:00.000]  Как мы будем использовать эту теорему?
[33:00.000 --> 33:04.000]  Что мы построим такую функцию, для которой эта теорема неверна.
[33:04.000 --> 33:07.000]  Но при этом эта функция будет универсально вычислимой.
[33:07.000 --> 33:10.000]  И, значит, она будет неглавной.
[33:11.000 --> 33:26.000]  Значит, пример построения неглавной универсально вычислимой функции.
[33:26.000 --> 33:30.000]  Значит, план такой.
[33:30.000 --> 33:49.000]  Значит, построим функцию, которая будет универсально вычислимой.
[33:49.000 --> 34:10.000]  Но для некоторой, но некоторое нетривиальное свойство, а будет разрешимым.
[34:10.000 --> 34:16.000]  Ну а для главного оно должно было быть неразрешимым, значит, это неглавное.
[34:17.000 --> 34:19.000]  Так.
[34:24.000 --> 34:34.000]  Значит, рассмотрим множество какой-нибудь...
[34:38.000 --> 34:45.000]  Ну, неважно, как эти идеи его назовем.
[34:45.000 --> 34:50.000]  Значит, d, как раз мы с ним уже встречались вначале, это множество где-то определенных функций.
[34:50.000 --> 35:04.000]  То есть это множество таких p, таких, что существует x, что u от px определено.
[35:04.000 --> 35:17.000]  То есть это множество где-то останавливающихся программ.
[35:17.000 --> 35:32.000]  Значит, при этом вот эта u, которая здесь, это обычная универсальная машина тюринга, то есть она-то главная.
[35:32.000 --> 35:36.000]  Но мы на базе ее сделаем другую неглавную.
[35:36.000 --> 35:39.000]  Так.
[35:39.000 --> 35:43.000]  Значит, смотрите, вот это может перечислимо.
[35:43.000 --> 35:51.000]  Значит, это перечислимое множество.
[35:51.000 --> 35:57.000]  Но раз оно перечислимо, то вот пусть какая-то функция его перечисляет.
[35:57.000 --> 36:07.000]  То есть вот это d, значит, d это там d0, d1, d2 и так далее.
[36:08.000 --> 36:14.000]  Вот как-то мы его перечислили.
[36:14.000 --> 36:21.000]  Теперь рассмотрим такую функцию.
[36:21.000 --> 36:31.000]  Рассмотрим вот такую функцию v, v от nx,
[36:31.000 --> 36:36.000]  которая будет не определено.
[36:36.000 --> 36:43.000]  Не определено, если n равно 0.
[36:43.000 --> 36:53.000]  Вот. E равняется u от d с индексом n-1 и x, если n больше 0.
[36:59.000 --> 37:03.000]  Вот. Тогда что же получается?
[37:04.000 --> 37:10.000]  D вот здесь. Множество где-то останавливающихся программ.
[37:10.000 --> 37:16.000]  Множество x, что существует x, что у от x определено.
[37:26.000 --> 37:28.000]  Так. Ну вот, рассмотрим вот такое вот v.
[37:28.000 --> 37:34.000]  Ну, утверждаем, что v искомое.
[37:34.000 --> 37:37.000]  Значит, v искомое.
[37:37.000 --> 37:39.000]  Почему?
[37:39.000 --> 37:43.000]  Ну, во-первых, v вычислимо.
[37:43.000 --> 37:47.000]  v вычислимо как...
[37:47.000 --> 37:52.000]  Да, ну и нужно...
[37:52.000 --> 37:56.000]  То есть тут нужно считать, что все эти di-то это конкретные числа.
[37:56.000 --> 37:59.000]  То есть это не пропусков неопределенных.
[37:59.000 --> 38:03.000]  А прямо это мы перечислим множество в каком-то порядке.
[38:03.000 --> 38:11.000]  Вот. Поэтому v вычислимо как композиция вычислимых функций.
[38:11.000 --> 38:17.000]  То есть нам нужно сначала сравнить с нулем, что, понятное дело, мы умеем.
[38:17.000 --> 38:23.000]  Потом вычислить, если больше нет, вычислить dn-1,
[38:23.000 --> 38:28.000]  что какое-то перечисление можно сделать, и поставить v, которое тоже вычислимо.
[38:28.000 --> 38:34.000]  Вот. Поэтому v вычислимо как композиция вычислимых функций.
[38:34.000 --> 38:42.000]  Дальше. v универсальная.
[38:42.000 --> 38:50.000]  Почему? Ну, потому что нигде неопределенное имеет номер 0.
[38:50.000 --> 39:00.000]  Значит, z от x имеет номер 0.
[39:00.000 --> 39:09.000]  Вот. А соответственно, все остальные тоже имеют какой-то номер.
[39:09.000 --> 39:24.000]  Значит, все остальные имеют какой-то номер dit.
[39:24.000 --> 39:35.000]  Значит, какой-то номер dit. Ну и потом встречаются под номером dit в u.
[39:35.000 --> 39:43.000]  И потому встречаются под номером i плюс 1, получается.
[39:43.000 --> 39:52.000]  Значит, под номером i плюс 1 в v.
[39:52.000 --> 40:01.000]  Ну, вот это d. Значит, d это множество всех где-то определенных программ.
[40:01.000 --> 40:06.000]  Потому что номеров всех функций, кроме нигде неопределенных.
[40:06.000 --> 40:15.000]  И, соответственно, наша функция где-то определенная, имеет какой-то номер внутри d.
[40:15.000 --> 40:28.000]  И тогда, если мы возьмем n как i плюс 1, то как раз та же самая функция появится на i плюс 1 строчке в таблице для v.
[40:28.000 --> 40:33.000]  Так. Ну чего? Понятно?
[40:33.000 --> 40:37.000]  Тогда что же получается? Значит, да, универсальность тоже есть.
[40:37.000 --> 40:52.000]  Но при этом можно по номеру... То есть получается, что n больше 0 тогда и только тогда,
[40:52.000 --> 41:02.000]  когда существует такой x, что v от nx определено.
[41:02.000 --> 41:06.000]  Да, и то, что n больше 0, конечно, можно выяснить.
[41:06.000 --> 41:10.000]  Получается, что нигде неопределенная функция имеет вообще ровно один номер.
[41:10.000 --> 41:14.000]  И это, конечно, разрешимое множество.
[41:14.000 --> 41:23.000]  Кстати, получается в следствии с теорией Успенского райса, что для любой функции есть бесконечно много программ.
[41:23.000 --> 41:27.000]  Иначе это будет конечное множество.
[41:27.000 --> 41:31.000]  Ну, для обычных языков мы это и так знаем.
[41:31.000 --> 41:41.000]  Но, опять же, получается, что это следует просто из главности, не из каких-то особенностей синтаксиса.
[41:41.000 --> 41:46.000]  Ну вот, значит, поэтому...
[41:46.000 --> 42:00.000]  Ну вот, в общем, свойства где-то определенности разрешима.
[42:00.000 --> 42:05.000]  Но, следовательно, v не главное.
[42:11.000 --> 42:21.000]  Ну вот.
[42:21.000 --> 42:25.000]  Понятны конструкция? Есть какие-нибудь вопросы?
[42:34.000 --> 42:38.000]  Да, давайте поймём, почему определение тут не будет выполнено.
[42:38.000 --> 42:40.000]  Это хороший вопрос.
[42:40.000 --> 42:47.000]  Смотрите, что такое главное по определению, что если у нас есть какая-то ещё нумерация w,
[42:47.000 --> 42:52.000]  то мы из этой нумерации w можем перекодировать нумерации вот здесь.
[42:52.000 --> 42:55.000]  И почему мы так не можем сделать?
[42:55.000 --> 43:00.000]  Потому что, смотрите, если у нас программа для w нигде не определена,
[43:00.000 --> 43:03.000]  то для неё нужно...
[43:03.000 --> 43:07.000]  Её нужно перекодировать в номер 0.
[43:09.000 --> 43:11.000]  Вот, и никак иначе.
[43:11.000 --> 43:14.000]  Но тогда получается, что там для той w надо было бы определять,
[43:14.000 --> 43:19.000]  надо было бы понимать, определена exchange programme где-то или не определена.
[43:19.000 --> 43:22.000]  То есть получается, чтобы корректно перекодировать вот в эту нумерацию,
[43:22.000 --> 43:27.000]  нужно для той нумерации определять, является ли программа где-то определённой или не является.
[43:27.000 --> 43:33.000]  Но мы только что увидели, что это невозможно для главной нумерации.
[43:37.000 --> 43:40.000]  Понятно, да, какова природа.
[43:40.000 --> 43:45.000]  Там действительно и для где-то определенной можно найти программу,
[43:45.000 --> 43:50.000]  и для нигде неопределенной можно, но для нигде неопределенной здесь есть ровно один вариант.
[43:50.000 --> 43:54.000]  И чтобы именно его сопоставить, нужно для то и откуда перекодируем
[43:54.000 --> 43:58.000]  решать вот эту проблему непустой области определения.
[44:08.000 --> 44:12.000]  Так, ничего, понятно.
[44:12.000 --> 44:24.000]  Так, тут я хотел бы упомянуть еще одну теорему,
[44:24.000 --> 44:31.000]  но, конечно, уже без доказательств, это сложная теорема.
[44:31.000 --> 44:45.000]  Теорема Фридберга, существует универсальная вычлимая функция,
[44:45.000 --> 45:05.000]  в которой у каждой функции одного аргумента есть ровно одна программа.
[45:15.000 --> 45:24.000]  При таковенском программировании удобно проверять олимпиаду по программированию.
[45:24.000 --> 45:29.000]  Нужно просто сравнивать то, что предъявили, с той единственной программой, которая подходит.
[45:29.000 --> 45:40.000]  Но, конечно, это совершенно не практический язык, и довольно сложно доказывается.
[45:41.000 --> 45:44.000]  Но теорема есть.
[45:53.000 --> 46:01.000]  Так, ну теперь еще одна тема, которую я сегодня хочу обсудить, и еще одна теорема.
[46:01.000 --> 46:08.000]  Так, знаете ли вы, что такое Куайм?
[46:08.000 --> 46:13.000]  Да, совершенно верно. Ну, вообще, это фамилия тоже, математика.
[46:13.000 --> 46:16.000]  Но эта фамилия стала нарисательным понятием.
[46:16.000 --> 46:25.000]  Это программа, которая печатает свой текст.
[46:33.000 --> 46:40.000]  Такую программу можно написать на, опять же, любом нормальном языке программирования,
[46:40.000 --> 46:46.000]  а именно на любом, который задает главную универсальному члену мою функцию.
[46:46.000 --> 46:55.000]  Ну и, действительно, бывает, что люди развлекаются, берут какой-нибудь язык программирования и на нем пишут.
[46:55.000 --> 47:05.000]  Есть читерские языки, в которых в язык встроена программа, типа лист, напечатать текст текущей программы.
[47:05.000 --> 47:14.000]  Еще может быть такой читерский подход с файловой системой, что программа на файловой системе
[47:14.000 --> 47:17.000]  находит свой собственный текст и его читает и выводит.
[47:17.000 --> 47:26.000]  Но бывают, конечно, и настоящие Куаймы, которые никакими особенностями среды не пользуются,
[47:26.000 --> 47:31.000]  а просто сами печатают, и действительно его можно создать.
[47:31.000 --> 47:35.000]  На естественном языке можно писать такую инструкцию.
[47:35.000 --> 47:49.000]  Напечатать дважды,
[47:49.000 --> 48:07.000]  взяв второй экземпляр в кавычке.
[48:07.000 --> 48:12.000]  Ну и дальше, соответственно, еще раз то же самое.
[48:12.000 --> 48:37.000]  Напечатать дважды, взяв второй экземпляр в кавычке.
[48:37.000 --> 48:46.000]  Но действительно, если эту инструкцию выполнить, то она сама и получится.
[48:46.000 --> 48:52.000]  Ну и более-менее стандартные Куаймы, они более-менее то же самое делают,
[48:52.000 --> 48:56.000]  используя средства того языка, на котором они написаны.
[48:56.000 --> 49:00.000]  Но, конечно, можно что-то другое делать.
[49:00.000 --> 49:04.000]  Теорема стоит в том, что на самом деле на любом языке,
[49:04.000 --> 49:11.000]  который задает главную универсальному члену функцию, такое можно написать.
[49:11.000 --> 49:23.000]  Теорема, что на любом языке программирование,
[49:23.000 --> 49:31.000]  программирование, значит, задающим главную универсальному члену функцию,
[49:31.000 --> 49:42.000]  существует Куайм.
[49:42.000 --> 49:56.000]  Вот, значит, и это на самом деле следует из более общей теоремы,
[49:56.000 --> 50:00.000]  значит, а именно из теоремы к линии о неподвижной точке.
[50:00.000 --> 50:08.000]  Так, ну а вообще можете при желании поупражняться на своих любимых языках программирования.
[50:08.000 --> 50:13.000]  Значит, пока в чем заключается теорема?
[50:13.000 --> 50:29.000]  Ну, смотрите, ничего не печатать и печатать ничего, это немножко разные вещи.
[50:29.000 --> 50:35.000]  Да, то есть я сказал, что пустая программа, не, но вообще в обычный компилятор,
[50:35.000 --> 50:39.000]  если вы пустой файл отправите, наверное, он ошибку выдаст.
[50:39.000 --> 50:45.000]  Это, конечно, зависит там от языка и от компилятора, но скорее он все-таки выдаст ошибку.
[50:45.000 --> 50:51.000]  Вот, но опять же, она должна, скорее всего, даже если он не выдаст ошибку,
[50:51.000 --> 50:56.000]  скорее всего, она вообще ничего не будет делать, а она должна напечатать пустое слово.
[50:56.000 --> 51:00.000]  Это не одно и то же.
[51:00.000 --> 51:08.000]  Конечно, можно придумать язык, который, получив пустой файл и печатает пустую строку,
[51:08.000 --> 51:14.000]  но там легкая задача получается.
[51:14.000 --> 51:18.000]  Теоремы к линии о неподвижной точке.
[51:18.000 --> 51:34.000]  Так, значит, пусть у, это главная универсаливоченемая функция.
[51:34.000 --> 51:40.000]  Значит, а h это функция одного аргумента.
[51:40.000 --> 51:54.000]  Значит, h функция одного аргумента это всюду определенная вычислимая функция.
[51:54.000 --> 52:18.000]  Тогда существует p такое, что для любого x u от p и x равняется u от h от p и x.
[52:18.000 --> 52:20.000]  Вот, то есть что здесь происходит?
[52:20.000 --> 52:26.000]  Значит, здесь h делает какое-то преобразование программ.
[52:26.000 --> 52:31.000]  Да, h берет программу p, что-то не делает, получает программу h от p.
[52:31.000 --> 52:36.000]  Но теорема заключается в том, что, чтобы это преобразование не делало,
[52:36.000 --> 52:45.000]  все равно найдется программа, которая не изменит свои работы после этого преобразования.
[52:45.000 --> 52:55.000]  То есть тут смысл получается такой, что h это преобразование программ,
[52:55.000 --> 53:04.000]  но оно, по крайней мере, вычислимое и всюду определенное, то есть во что-то преобразует.
[53:04.000 --> 53:11.000]  И, соответственно, теорема, что существует программа,
[53:11.000 --> 53:37.000]  которая после преобразования делает то же, что и до преобразования.
[53:37.000 --> 53:41.000]  Вот, теперь как это связано с QAIN?
[53:41.000 --> 53:57.000]  Ну, QAIN в тернах универсальных, значит, QAIN в тернах универсальных вычислимых функций,
[53:57.000 --> 54:07.000]  ну, наверное, нужно вот так вот потребовать, что для любого x у от px равно p.
[54:07.000 --> 54:12.000]  А вот это, наверное, нужно назвать QAIN.
[54:12.000 --> 54:21.000]  Ну, тут вопрос, что нужно в QAIN подставлять, там пустой вход или какой угодно,
[54:21.000 --> 54:25.000]  но вот здесь решили, что какое угодно.
[54:25.000 --> 54:38.000]  Вот, ну и тогда, грубо говоря, нужно написать h от p, это программа print p,
[54:38.000 --> 54:48.000]  значит, напечатать p.
[54:48.000 --> 54:56.000]  Ну и опять же, такая программа, она для большинства языков просто напрямую есть такая функция,
[54:56.000 --> 54:59.000]  напечатать что-нибудь.
[54:59.000 --> 55:06.000]  Но можно ее там доказать для главной универсальной функции непосредственно, что такая есть.
[55:06.000 --> 55:15.000]  Ну, тогда получается, что у от px равняется у от h от px.
[55:15.000 --> 55:25.000]  Если p такова, ну, p такова, которая из теоремы, то получается, что у от px равно у от h от px и равно p.
[55:25.000 --> 55:39.000]  Потому что программа print p выдает p.
[55:39.000 --> 55:44.000]  Вот, поэтому QAIN существует.
[55:44.000 --> 55:49.000]  Так, ну чего, понятно.
[55:49.000 --> 55:55.000]  Так, ну что ж, давайте попробуем доказать эту теорему.
[55:55.000 --> 56:01.000]  Значит, тут доказательство, на самом деле, не очень длинное, но оно какое-то такое немножко странное.
[56:01.000 --> 56:10.000]  Там, в общем, немножко как кролика из шляпы достают, не очень понятно, почему вообще так происходят.
[56:10.000 --> 56:16.000]  Ну вот, в книжке вещей Айкина Шиня там немножко побольше написано, почему такое происходит,
[56:16.000 --> 56:22.000]  там это как-то погружено в какие-то общие свойства вычтемых функций.
[56:22.000 --> 56:28.000]  Так, ну вот я попробую, надеюсь, что у меня получится не испортить фокус,
[56:28.000 --> 56:32.000]  и, соответственно, я достану кролика из шляпы.
[56:32.000 --> 56:41.000]  Значит, как часто бывает каким-то образом использовать диагональный метод.
[56:41.000 --> 56:47.000]  Вот, а именно возникает такая странная идея.
[56:47.000 --> 56:52.000]  Так, значит, вот доказательство, значит, доказательство теоремы.
[56:52.000 --> 56:59.000]  Так, значит, идея очень странная, да, вообще непонятно откуда взявшаяся.
[56:59.000 --> 57:09.000]  Но, в общем, применим программу саму к себе, и то, что получилось, воспримем как тоже некоторую программу.
[57:09.000 --> 57:25.000]  Значит, применим программу саму к себе, и воспримем результат,
[57:25.000 --> 57:33.000]  воспримем результат как тоже некоторую программу.
[57:33.000 --> 57:38.000]  Ну, так вообще непонятно зачем, но вроде не запрещено так делать,
[57:38.000 --> 57:46.000]  и иногда даже осмыслено. Вполне может быть так, что программа делает какое-то изменение в тексте программы, например,
[57:46.000 --> 57:52.000]  сохраняя ее синтетическую корректность, и тогда она в своем тексте тоже может изменить что-то,
[57:52.000 --> 57:56.000]  и получится тоже какая-то осмысленная программа.
[57:56.000 --> 58:00.000]  Вот, значит, что это в серонах универсальных функций происходит?
[58:00.000 --> 58:12.000]  Значит, я определю, значит, v от x, y.
[58:12.000 --> 58:19.000]  Ну или, так, сейчас давайте, давайте лучше v от n, x.
[58:19.000 --> 58:29.000]  v от n, x я определю как u, а u это как раз вот та самая, которая из условия, главное, универсальная.
[58:29.000 --> 58:40.000]  Значит, u от u от n, n и x.
[58:40.000 --> 58:45.000]  Ну вот, значит, вот как-то я так и сделал.
[58:45.000 --> 58:52.000]  Теперь, что нам говорит свойство главности?
[58:52.000 --> 59:02.000]  Так, значит, и свойство главности,
[59:02.000 --> 59:08.000]  и свойство главности существует какое-то преобразование.
[59:08.000 --> 59:18.000]  Значит, существует преобразование s такое, что для любого n, для любого x
[59:18.000 --> 59:31.000]  v от n, x равняется u от s от n, x.
[59:31.000 --> 59:42.000]  Так, ну хорошо, значит, вот есть, значит, есть вот такая вот функция.
[59:42.000 --> 59:48.000]  Так, пока опять же, да, все корректно, непонятно зачем.
[59:48.000 --> 59:55.000]  Ну ладно, дальше следующий странный шаг.
[59:55.000 --> 01:00:09.000]  Значит, теперь рассмотрим,
[01:00:09.000 --> 01:00:14.000]  значит, рассмотрим функцию
[01:00:14.000 --> 01:00:27.000]  t от x, который есть h, ой, нет, h от s от x.
[01:00:27.000 --> 01:00:32.000]  Вот, а h это как раз та функция, в которой мы неподвижную точку ищем.
[01:00:32.000 --> 01:00:38.000]  Сейчас ее пока не было еще. Так, давайте я тут это напомню.
[01:00:38.000 --> 01:00:55.000]  Значит, это у которой ищем неподвижную точку.
[01:00:55.000 --> 01:01:01.000]  Так, значит, и вот это вот h от s от x, это будет сюда определенное.
[01:01:01.000 --> 01:01:08.000]  Ой, так.
[01:01:08.000 --> 01:01:22.000]  Значит, это всюду определенная, всюду определенная вычислимая функция.
[01:01:22.000 --> 01:01:30.000]  Так, теперь свойства главности мы уже использовали, теперь свойства универсальности.
[01:01:30.000 --> 01:01:38.000]  Значит, по свойству универсальности,
[01:01:38.000 --> 01:01:44.000]  по свойству универсальности существует такое q,
[01:01:44.000 --> 01:02:04.000]  что для любого x t от x равняется u от qx.
[01:02:04.000 --> 01:02:12.000]  Вот, ну и теперь утверждение.
[01:02:12.000 --> 01:02:33.000]  Утверждение s, s от q, это неподвижная точка.
[01:02:33.000 --> 01:02:41.000]  Почему же так происходит? Ну, сейчас будет некоторая выкладка.
[01:02:41.000 --> 01:02:48.000]  Сейчас вот все, что на этой доске есть, сейчас сыграет на следующей, и я буду туда-сюда перебегать.
[01:02:48.000 --> 01:02:53.000]  Так, значит, s от q неподвижная точка.
[01:02:53.000 --> 01:03:01.000]  Так, ну давайте посмотрим. Значит, u от s от q и x.
[01:03:01.000 --> 01:03:07.000]  Так, что это такое? Ну, смотрим вот сюда вот.
[01:03:07.000 --> 01:03:14.000]  Да, тут вместо nq. Значит, u от s от qx это v от qx.
[01:03:14.000 --> 01:03:22.000]  Так, ну давайте запишем. У от s от qx это v от qx.
[01:03:22.000 --> 01:03:28.000]  Так, очень хорошо. А что как было v от qx?
[01:03:28.000 --> 01:03:34.000]  А это у нас вот здесь вот. Да, здесь вот эта вот диагональная функция.
[01:03:34.000 --> 01:03:45.000]  То есть это получается, равняется u от u от qq и x.
[01:03:45.000 --> 01:03:52.000]  Ну ладно. Так, значит, это тоже получилось.
[01:03:52.000 --> 01:03:56.000]  Так, теперь что такое u от q и q? А смотрим вот сюда вот.
[01:03:57.000 --> 01:04:04.000]  Ну, u от qx это t от x, а u от q и q это t от q.
[01:04:04.000 --> 01:04:15.000]  То есть это будет u от t от q и x.
[01:04:15.000 --> 01:04:20.000]  Вот, ну и наконец, что такое t от q?
[01:04:20.000 --> 01:04:26.000]  Смотрим вот сюда вот. t от q это h, t от x это h от s от x,
[01:04:26.000 --> 01:04:29.000]  а t от q это h от s от q.
[01:04:29.000 --> 01:04:40.000]  Получаем, что это будет u от h от s от q и x.
[01:04:40.000 --> 01:04:47.000]  Но вот x был произвольным, так что получается, что действительно все верно.
[01:04:51.000 --> 01:05:00.000]  Так, значит, поскольку x произвольный, то теория получается доказана.
[01:05:06.000 --> 01:05:13.000]  Действительно, это самое s от q делает с x то же самое, что h от s от q
[01:05:13.000 --> 01:05:18.000]  тоже с тем же самым произвольным x.
[01:05:18.000 --> 01:05:24.000]  Ну вот, вроде фокус получился, и вроде формально все верно,
[01:05:24.000 --> 01:05:28.000]  но почему нужно делать именно так, не очень понятно.
[01:05:28.000 --> 01:05:34.000]  Ну вот, опять же, величайкие нишени, это погружено в некоторый более широкий контекст.
[01:05:34.000 --> 01:05:40.000]  Написано там про функции, имеющие там продолжение или не имеющее,
[01:05:40.000 --> 01:05:45.000]  и что если у них там нету всю дополнительную члену продолжения,
[01:05:45.000 --> 01:05:50.000]  то у них должна быть неподвижная точка, диагонально его как раз нету.
[01:05:50.000 --> 01:06:03.000]  В общем, рекомендую прочесть, но сейчас более широким контекстом это не будем обсуждать.
[01:06:03.000 --> 01:06:08.000]  Есть какие-нибудь вопросы. Я хотел бы еще про небольшое приложение сказать,
[01:06:08.000 --> 01:06:13.000]  помимо куайнов, но если есть вопросы, то могу ответить.
[01:06:13.000 --> 01:06:26.000]  Ладно, ну хорошо, давайте тогда оставишься пять минут.
[01:06:26.000 --> 01:06:32.000]  Еще одно приложение.
[01:06:32.000 --> 01:06:42.000]  Приложение это рекурсивное программирование.
[01:06:42.000 --> 01:06:47.000]  Почему вообще рекурсия возможна, и что вообще такое рекурсия?
[01:06:47.000 --> 01:06:53.000]  Ну рекурсия означает, что какая-то программа вызывает саму себя с каким-нибудь другим аргументом,
[01:06:53.000 --> 01:06:59.000]  а потом, в свою очередь, еще раз вызывает саму себя с еще другим аргументом,
[01:06:59.000 --> 01:07:03.000]  и так это все спускается до какого-то базового случая.
[01:07:03.000 --> 01:07:09.000]  Бывает что бесконечная рекурсия, типа там, рекурсия, смотри, рекурсия,
[01:07:09.000 --> 01:07:15.000]  там нет условий остановки, она ни к чему не может привести.
[01:07:15.000 --> 01:07:22.000]  На чем основана вообще возможность такой штуки?
[01:07:22.000 --> 01:07:28.000]  Ну обычно в языке программирования есть специальные конструкции для такого,
[01:07:28.000 --> 01:07:34.000]  то есть какая-то подпрограмма, которую можно вызвать и можно вызвать саму себя.
[01:07:34.000 --> 01:07:39.000]  Есть там какой-то процессор, который это все обрабатывает.
[01:07:39.000 --> 01:07:45.000]  Ну а все же, мы так написали программу, почему она там скомпилируется, вообще что-то сделает.
[01:07:45.000 --> 01:07:48.000]  И, например, в машине Тюринга там же нет таких конструкций.
[01:07:48.000 --> 01:07:52.000]  Почему на машине Тюринга такое можно писать?
[01:07:52.000 --> 01:07:58.000]  Ну оказывается, что теория МакЛини говорит, что рекурсивное программирование,
[01:07:58.000 --> 01:08:08.000]  возможно, на любом языке, который соответствует главной универсальному члену и функции.
[01:08:08.000 --> 01:08:13.000]  Ну в каком смысле возможно, я думаю сейчас будет понятно.
[01:08:13.000 --> 01:08:21.000]  Ну, например, есть определение функции факториал рекурсивное.
[01:08:21.000 --> 01:08:27.000]  Что такое функция факториал? Это единица, если n равно нулю,
[01:08:27.000 --> 01:08:36.000]  и n умножить на факториал от n-1, если n больше нуля.
[01:08:36.000 --> 01:08:43.000]  Почему есть функция, которая этому удовлетворяет?
[01:08:43.000 --> 01:08:50.000]  Что мы вообще хотим? Что означает, что программа вычисляет факториал именно по рекурсивному определению?
[01:08:50.000 --> 01:08:55.000]  Ну, давайте напишем.
[01:08:55.000 --> 01:09:05.000]  Значит, программа P рекурсивно вычисляет n-факториал.
[01:09:05.000 --> 01:09:08.000]  Дальше, что она должна делать?
[01:09:08.000 --> 01:09:16.000]  Это означает, что u от P и n будет равняться единице, если n равно нулю,
[01:09:16.000 --> 01:09:25.000]  и cесто n умножить на u от P и n-1, значит, если n больше нуля.
[01:09:25.000 --> 01:09:33.000]  Значит, почему такое P есть? Ну, ровно по терминику линия.
[01:09:33.000 --> 01:09:44.000]  Значит, такое P есть по терминику линии.
[01:09:44.000 --> 01:09:50.000]  Как именно? Ну, смотрите, можно написать так.
[01:09:50.000 --> 01:09:56.000]  Значит, v от P и n будет равно тому же самому.
[01:09:57.000 --> 01:10:05.000]  И n умножить, а здесь u, n умножить на u от P и n-1, если n больше нуля.
[01:10:05.000 --> 01:10:08.000]  Да, уж такое v точно можно написать.
[01:10:08.000 --> 01:10:11.000]  Значит, тут никакой рекурсии нет.
[01:10:11.000 --> 01:10:17.000]  Дальше по теореме, не по теореме, а по свойству главности,
[01:10:17.000 --> 01:10:26.000]  значит, по свойству главности мы получаем, что существует S такое,
[01:10:26.000 --> 01:10:36.000]  что для любого P, для любого n, u от S от P и n равно v от P и n.
[01:10:39.000 --> 01:10:42.000]  А дальше по теореме к линии.
[01:10:42.000 --> 01:11:02.000]  По теореме к линии существует такое P, что для любого n, u от P и n равно u от S от P и n.
[01:11:02.000 --> 01:11:05.000]  Тут очень красивая штука.
[01:11:05.000 --> 01:11:11.000]  Мы берем S из определения главной универсальной функции
[01:11:11.000 --> 01:11:19.000]  и поставим это S в теорему к линии как функцию сюда определенного преобразования.
[01:11:19.000 --> 01:11:24.000]  И к этой S в качестве h применяем теорему к линии.
[01:11:25.000 --> 01:11:28.000]  Ну, в общем, если это все раскрутить,
[01:11:37.000 --> 01:11:41.000]  значит, если все это раскрутить, если взять вот это вот равенство,
[01:11:41.000 --> 01:11:44.000]  потом вот это вот равенство и потом вот это вот равенство,
[01:11:44.000 --> 01:11:47.000]  то получится ровно исходная равенство, которая нам и была нужна.
[01:11:47.000 --> 01:11:57.000]  То есть вывод такой, что рекурсию писать можно, и, соответственно, она точно реализуется.
[01:11:57.000 --> 01:12:01.000]  Спасибо за внимание.
