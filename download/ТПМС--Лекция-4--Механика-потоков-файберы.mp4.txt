[00:00.000 --> 00:20.000]  Приветствую еще раз. Теперь должно быть меня видно и слышно. И экран должен быть. И мы, кажется, готовы начать. Давайте договоримся сразу. У нас сегодня встреча в зуме. Я этому очень не рад. Нужно договориться о правилах.
[00:20.000 --> 00:37.000]  Если у вас есть вопрос, то просто включайте микрофон и задавайте его. Лучше не писать в чат, потому что читать чат мне неудобно во время реакции. Просто включайте и сразу задавайте вопрос. Единственное, что не забывайте потом микрофон выключать, чтобы остальным это не мешало.
[00:37.000 --> 00:46.000]  А правда, что записи нет? Записи вроде сейчас нет. Вопрос оператору. Записи сейчас правда нет.
[00:47.000 --> 00:50.000]  Когда тема пойдет, я включу.
[00:50.000 --> 00:53.000]  Когда она пойдет, ты уже не успеешь, потому что она начнется.
[00:53.000 --> 00:55.000]  Ладно, обрежем.
[00:55.000 --> 01:02.000]  Что лучше. Да, спасибо. Так безопаснее.
[01:03.000 --> 01:08.000]  Ну что, давайте начнем уже. Время наше пошло.
[01:08.000 --> 01:12.000]  Итак, мы с вами продолжаем говорить про синхронизацию.
[01:12.000 --> 01:24.000]  И вот две последние лекции мы занимаемся синхронизацией с разных сторон. Мы синхронизируем потоки с помощью мютексов. В прошлый раз мы поговорили про кундвары.
[01:24.000 --> 01:28.000]  Сегодня мы поговорим, наконец, про потоки.
[01:28.000 --> 01:36.000]  Ну как про потоки? В прошлый раз мы уже говорили про потоки. Мы их научились запускать. Вернее, договорились, что мы их запускаем только в виде пула потоков.
[01:36.000 --> 01:39.000]  То есть они в нашей программе присутствуют только в таком виде.
[01:39.000 --> 01:46.000]  Но я думаю, предполагаю, что все же наше понимание потоков все еще несколько магическое.
[01:46.000 --> 01:54.000]  Ну то есть, да, мы на первом семинаре обсудили с вами, ну или с некоторыми из вас, как мы представляем себе исполнение.
[01:54.000 --> 02:04.000]  То есть есть процессор, есть там ядро. Это ядро считывает инструкции из памяти, использует call stack для того, чтобы по этому коду перемещаться, заходить в функции, выходить из них.
[02:04.000 --> 02:11.000]  Мы, наверное, представляем себе, что вот есть, скажем, системный вызов shit yield, который передает управление планировщику.
[02:11.000 --> 02:15.000]  Планировщик убирает очередной поток, намазывает его на процессор.
[02:15.000 --> 02:23.000]  Но все же такое понимание, оно несколько, не знаю, магическое какое-то.
[02:23.000 --> 02:27.000]  Потоки пока не очень несезаемые. Вот что именно это такое? Как его себе представить?
[02:27.000 --> 02:38.000]  Ну, представить это бы не наш путь. В этом курсе мы, если хотим что-то по-настоящему написать, мы должны, по-настоящему понять, мы должны это написать своими руками.
[02:38.000 --> 02:44.000]  Это такой основополагающий принцип наш. Вот все, о чем мы в курсе говорим, мы стараемся запрограммировать в одной из домаш.
[02:44.000 --> 02:50.000]  Так что сегодня мы поступим с потоками ровно так. Мы научимся их писать.
[02:50.000 --> 02:56.000]  Но я немного обманываю вас, потому что прямо потоки мы писать не научимся сегодня.
[02:56.000 --> 03:04.000]  Вместо этого мы научимся писать файберы, которые для нас будут служить вот некоторым воплощением упрощенным потоком.
[03:04.000 --> 03:16.000]  Файберы. С файберами мы уже столкнулись в домашних работах для того, чтобы симулировать различные конкурентные баги, а именно дедлоки и лайфлоки.
[03:16.000 --> 03:27.000]  Вы с ними могли столкнуться в домашних работах, потому что тесты запускаются не только под потоками недетерминированными и параллельными, а под кооперативными файберами тоже с fault injection.
[03:27.000 --> 03:35.000]  Но вот сегодня мы хотим использовать файберы как наглядную простую учебную реализацию потоков.
[03:35.000 --> 03:49.000]  Но помимо такого использования файберов, у нас конечно же к ним есть самостоятельный интерес, потому что файберы в конце концов в нашем курсе будут служить средством выразительности,
[03:49.000 --> 03:57.000]  которое позволяет нам в нашей программе конкурентно обслуживать пользователей.
[03:57.000 --> 04:15.000]  Вот я вам показывал этот код уже на первой лекции. Это эхо-сервер, написанный как будто бы на потоках в таком же стиле, но при этом весь код исполняется всего лишь в одном потоке операционной системы, очень компактно упаковывая всю работу.
[04:15.000 --> 04:28.000]  Вот на самом деле, конечно же, в курсе мы хотим сделать файберы именно такими полезными, которые умеют сетевой вывод, умеют приметиво синхронизации, умеют в будущем параллельность.
[04:28.000 --> 04:35.000]  Но сегодня нам подойдут самые простые файберы, и на примере их мы сможем изучить механику потоков.
[04:35.000 --> 04:48.000]  Ну и давайте еще раз проговорим, вы это, конечно, в домашних уже встречали, но лучше проговорить, что именно мы под файберами понимаем.
[04:48.000 --> 04:56.000]  Почему вообще мы считаем, что файберы для нас могут служить хорошим примером реализации потоков?
[04:57.000 --> 05:08.000]  Ну я бы сказал бы так, что мы готовы изучить потоки на примере файберов, потому что файберы ведут себя как потоки. Что это значит?
[05:08.000 --> 05:15.000]  Ну вот у файберов, у наших учебных файберов есть три базовых метода. Стойте, давайте я оговорюсь.
[05:15.000 --> 05:23.000]  Мы сегодня говорим про конкретную библиотеку, про тайные файберы, которые мы используем в курсе, и если у вас есть возможность, то просто откроете ее у себя на ноутбуке,
[05:23.000 --> 05:29.000]  и если вы будете по ней ходить, задавать вопросы, мне кажется, что вам будет удобнее так.
[05:29.000 --> 05:36.000]  Лучше перед глазами иметь у себя на компьютере весь код библиотеки.
[05:36.000 --> 05:43.000]  Ну вот, библиотека вам предоставляет в первую очередь три функции. Во-первых, это функция RunShedular.
[05:43.000 --> 05:51.000]  Есть разные способы это произносить, либо Scheduler, либо Sheduler, в зависимости от версии, либо это...
[05:51.000 --> 05:59.000]  Sheduler это американский английский, Scheduler это британский английский, ну вот я говорю Sheduler, или планировщик, всегда так говорить безопасно, корректно.
[05:59.000 --> 06:08.000]  Мы запускаем эту функцию и передаем туда некоторую лямду. И вот в вызове этой функции разворачивается планировщик,
[06:08.000 --> 06:14.000]  ну потому что мы пишем файбер, и файбером нужен планировщик, и мы его воспроизводим в пространстве пользователя.
[06:14.000 --> 06:25.000]  Вот в этой функции он разворачивается и начинает исполнение первого файбера, нулевого файбера, стартового, который исполняет переданную в эту функцию лямду.
[06:25.000 --> 06:34.000]  Что это первый файбер, нулевой файбер делает? Он первым же делом запускает другой файбер.
[06:34.000 --> 06:46.000]  Ну вот вызов Spawn прямо к запуску, точнее к исполнению нового файбера не приводит, потому что все наши файберы исполняются всего лишь в одном потоке операционной системы.
[06:46.000 --> 06:58.000]  Они не параллельны. И вызов Spawn конструирует файбер, чтобы это пока не значило, и добавляет его в очередь исполнения в планировщики.
[06:59.000 --> 07:09.000]  Очередь исполнения мы называем RunQueue. То есть сейчас исполняется нулевой, стартовый файбер, файбер номер один,
[07:09.000 --> 07:15.000]  сконструированный, томится в очереди ожидания в планировщики, ждет пока ему передадут возможность исполняться.
[07:15.000 --> 07:25.000]  Стартовый файбер доходит до шага один и вызывает функцию Self Yield. Что делает Yield?
[07:25.000 --> 07:34.000]  Yield останавливает исполнение текущего файбера, передает управление в планировщик, и планировщик в свою очередь,
[07:34.000 --> 07:41.000]  во-первых, помещает текущий файбер, который вернул ему управление, в хвост RunQueue.
[07:41.000 --> 07:47.000]  А во-вторых, выбирает очередной файбер и запускает его.
[07:47.000 --> 07:53.000]  Но вот опять, не совсем понятно пока, что это значит. Вот наше сегодняшнее целе разобраться, что именно происходит.
[07:53.000 --> 08:01.000]  Вот посмотрите на код всего этого. Итого, мы заходим в этот метод Yield, вот сюда.
[08:02.000 --> 08:11.000]  Управление возвращается в планировщик, в эту функцию, и после этого планировщик, видимо, запускает первый файбер из RunQueue.
[08:11.000 --> 08:15.000]  А в этот момент в RunQueue находился только файбер с номером один.
[08:15.000 --> 08:20.000]  Так что мы заходим сюда и продолжаем исполняться отсюда.
[08:20.000 --> 08:25.000]  Выполняем шаг два и снова видим Yield. Что он означает?
[08:25.000 --> 08:31.000]  Что нужно вернуться в планировщик и планировщик переключится на первый поток в RunQueue.
[08:31.000 --> 08:34.000]  В данный момент RunQueue выглядит как?
[08:36.000 --> 08:39.000]  Там находится файбер ноль.
[08:42.000 --> 08:45.000]  Вот мы заходим в этот вызов теперь.
[08:47.000 --> 08:54.000]  И выходим и продолжаем исполнение нулевого стартового файбера.
[08:55.000 --> 09:00.000]  А оно остановилось вот в этой точке, когда мы зашли в Yield и начали исполнять первый файбер.
[09:00.000 --> 09:10.000]  Ну отлично, мы из этого Yield прыгнули обратно сюда, сделали третий шаг и запустили второй, если отсчитывать от нуля, файбер.
[09:11.000 --> 09:17.000]  Он снова пока не начал исполняться, он попал в хвост RunQueue, и RunQueue сейчас выглядит так.
[09:17.000 --> 09:24.000]  Там находится файбер f1 и f2. f1 сейчас остановился здесь.
[09:25.000 --> 09:33.000]  f2 сейчас, ну он пока еще не исполнялся, вот он, когда он начнет, он стартует просто с начала вот этой ляммы.
[09:34.000 --> 09:38.000]  И теперь мы отдаем управление планировщику в нулевом файбере.
[09:39.000 --> 09:48.000]  А что конкретно вот возвращает нам Spawn? Понятно, что Join Handle, а что у нас умеет Join Handle? Что это за объект?
[09:48.000 --> 09:59.000]  Может быть я чуть позже поговорю об этом. Join Handle это, ну я не знаю как бы назвать по-русски Handle, давайте так я и буду говорить от беспомощности.
[10:00.000 --> 10:05.000]  С помощью этого Handle можно дождаться завершения исполнения запущенного файбера.
[10:06.000 --> 10:13.000]  Ну то есть это некоторая такая ручка для его, точнее для, не то чтобы для управления, вот файбер стартовал, он будет работать.
[10:13.000 --> 10:21.000]  Когда планировщика появится возможность. Ну вот с помощью Join Handle, давайте я уже до конца пример дойду и скажу, немного осталось.
[10:22.000 --> 10:31.000]  Мы говорим здесь Yield, передаем управление планировщику, планировщик выбирает первый файбер из RunQ, помещает в RunQ в конец файбер 0.
[10:32.000 --> 10:39.000]  В итоге мы прыгаем отсюда, вот сюда, выходим из этого Yield, в котором мы когда-то остановились, делаем четвертый шаг.
[10:39.000 --> 10:49.000]  Первый файбер завершает свое исполнение, планировщик получает управление обратно, выбирает из RunQ очередной файбер, там сейчас первый файбер в очереди F2.
[10:50.000 --> 11:04.000]  Стартует его, печатает 5, файбер снова завершается и наконец исполнение доходит до стартового файбера, который возвращается, печатает 6 и блокируется.
[11:04.000 --> 11:15.000]  Блокируется, он по сути не блокируется, но семантика Join Handle Join, семантика такая, заблокироваться до тех пор, пока файбер не завершит свое исполнение.
[11:16.000 --> 11:26.000]  Вот Join Handle ассоциирован с некоторым файбером и заблокировавшись на H1 Join, мы дожидаемся пока файбер вот этот вот не завершит свое исполнение.
[11:26.000 --> 11:38.000]  Про это есть отдельный пример, это него. Вот он, тут можно даже эту строчку стереть, она кажется никакой роли не играет.
[11:56.000 --> 12:20.000]  Ну вот давайте этот пример проговорим, он простой, но тем не менее полезный сейчас сделать. Мы стартуем, мы разворачиваем планировщик, файбер начинает исполняться и печатает Hello from parent, потом запускает еще один файбер, файбер этот попадает в конец RunQ планировщика, пока не исполняется.
[12:20.000 --> 12:41.000]  А дальше этот файбер продолжает работать и говорит Child Join и вот он блокируется, то есть он дальше не может исполняться, пока не завершится этот файбер, этот файбер пока даже не стартовал, поэтому мы уходим с исполнения, отдаем управление планировщику, останавливаемся и планировщик запускает этот файбер.
[12:42.000 --> 12:55.000]  Когда этот файбер завершится, то файбер начальный, нулевой, сможет выйти из Join и продолжить работать. Ну вот поэтому строчки печатаются вот в таком порядке. Раз, два, три.
[12:55.000 --> 13:24.000]  Мы пока не говорим про реализацию, мы пока говорим просто про наблюдаемое поведение. Да и давайте запустим этот пример, потому что мы тут проговаривали в каком порядке все печатается, вот полезно это своими глазами увидеть. Я надеюсь, что вы даже пробовали это запускать дома и что-то читать, это будет сегодня полезно. Простите, я не аккуратно нажимаю на кнопки.
[13:25.000 --> 13:49.000]  Все шаги выполнились в каком-то предсказуемом порядке. Ну вот, если мы это все понимаем, если пока вопросов больше нет, то еще раз я повторю свое утверждение, что файберы похожи на потоки, поэтому если мы сегодня изучим, как они работают, как они написаны, то мы тем самым поймем, как устроены настоящие потоки.
[13:49.000 --> 14:15.000]  Ну что ж, давайте пару замечаний все же еще сделаем, прежде чем переходить к реализации. Ну вот, во-первых, вы можете заметить, что вот эти файберы ничего полезного делать не умеют. Ну да, они умеют запускаться и переключаться друг на друга с помощью вызовов yield, но все же никакой полезной программы с такими файберами не напишешь.
[14:15.000 --> 14:41.000]  Это нас сейчас не беспокоит, потому что в конце концов мы хотим научить эти файберы какой-то полезной работе, мы хотим научить их вводу-выводу, и в этом курсе мы вряд ли сделаем что-то сильно сложнее, а вот скажем, в спецкурсе про распределенную систему осенью мы будем на файберах писать в общем полноценный сложный промышленный код, где файберы будут общаться через RPC.
[14:41.000 --> 14:55.000]  Там много всего будет, так что пока можно такие претензии к файберам отложить. Ну и вы сами в очередной домашней, которая будет правда через неделю, только научите эти файберы общаться с внешним миром.
[14:55.000 --> 15:06.000]  Для нас пока это модель потоков, и что нам важно, что файберы умеют друг на друга переключаться и планироваться. Что уж они делают, насколько это полезно, это второстепенная сегодня задача.
[15:06.000 --> 15:27.000]  Но вы можете возразить мне более содержательно, а именно, вот я говорю, что мы изучим потоки на примере файберов, но ведь потоки они похожи на, простите, файберы они похожи на потоки, но они все-таки потоками в том смысле, в котором мы их наблюдали в течение первых лекций домашних, они конечно не являются. Почему?
[15:27.000 --> 15:39.000]  Ну во-первых, потому что потоки исполняются параллельно, а файберы упакованы в один поток. Вот если исполняется один файбер, то другой не может исполняться, они не могут исполняться одновременно на разных ядрах.
[15:39.000 --> 16:02.000]  Во-вторых, файберы не дотягивают до потоков, потому что в потоках есть механизм вытеснения. Если, скажем, поток на ядре запустился, работает долго, слишком долго, то при очередном прерывании по таймеру в обработчике этого прерывания в ядре операционной системы запустится планировщик.
[16:02.000 --> 16:15.000]  Планировщик увидит, что поток на ядре израсходовал свой квант времени, выберет другую задачу и намажет ее на процессор. Вот такого механизма у файберов нет.
[16:15.000 --> 16:33.000]  Ну и давайте обсудим, насколько эти отличия принципиальны для нас. По поводу параллелизма. Параллелизма действительно нет и не будет сегодня, но он будет уже через неделю. Вот через неделю мы научимся строить файберы параллельными.
[16:33.000 --> 16:47.000]  Вернее как, я расскажу вам идею, мне кажется, очень изящную, очень ловкую, с помощью которой можно задачу декомпозировать и потом легко поддержать параллельность в файберах.
[16:47.000 --> 16:55.000]  Ну а вы это напишите даже сами. Так что подождем неделю и задача будет решена. Файберы параллельными у нас, безусловно, станут.
[16:55.000 --> 17:06.000]  Вторая претензия состояла в том, что в них нет механизма вытеснения. Ну вот здесь потребуется, наверное, чуть более подробный комментарий.
[17:06.000 --> 17:17.000]  Наши файберы называются кооперативными. Вот они отдают управление планировщику другому файберу только добровольно, в каких-то понятных точках.
[17:17.000 --> 17:29.000]  Вот мы здесь говорим yield и перестаем исполняться и переключаемся на другой файбер. Если мы yield не скажем, мы исполняться продолжим дальше, никто нам не помешает.
[17:29.000 --> 17:46.000]  Возможно, этого недостаточно. Ну вот скажем, для языка go, где у вас грутины, которые мы считаем почти что синонимами файберов, в go есть механизм вытеснения.
[17:46.000 --> 17:54.000]  Но я утверждаю, что вот он в go нужен, а нам не нужен. Потому что мы пишем все-таки не язык программирования, мы пишем библиотеку.
[17:54.000 --> 18:06.000]  Библиотеку, которая решает более-менее конкретные задачи. Библиотеку или в общем случае какой-то фреймворк, в котором предполагается решать какие-то определенные задачи.
[18:06.000 --> 18:16.000]  Скажем, мы пишем сетевой код, где у нас много обработчиков запросов, много конкурентных активностей, и они друг с другом как-то взаимодействуют.
[18:16.000 --> 18:28.000]  Взаимодействуют с помощью приметилов синхронизации, взаимодействуют с помощью сетевых вызовов. Их может быть очень много, но они собираются все-таки упаковаться в небольшое число ядер,
[18:28.000 --> 18:36.000]  потому что они большую часть времени не то чтобы работают на процессоре, они большую часть времени спят. Спят в ожидании чего-то.
[18:36.000 --> 18:49.000]  Спят, ожидая завершения сетевого вызова к другому удаленному сервису. Или спят в ожидании освобождения блокировки локальной.
[18:49.000 --> 19:02.000]  И вот эти точки, где они блокируются, чего-то ожидают, они и будут точками, где в коде файберы передают друг другу управление.
[19:02.000 --> 19:08.000]  Конечно, настоящие полезные файберы не будут делать, но кажется, что никогда не будут даже делать.
[19:08.000 --> 19:14.000]  Так вот, им будет достаточно вот тех блокирующих операций, которые они будут выполнять.
[19:14.000 --> 19:27.000]  Если мы будем переключать файберы в точках этих блокирующих операций, то нам вытеснение не потребуется, потому что задача наша таковы, что никаких тяжелых вычислений в файберах мы делать не планируем.
[19:27.000 --> 19:36.000]  Если же, конечно, пользователь файберов решит что-то долго вычислять в них, то, да, он пострадает от отсутствия вытеснения.
[19:36.000 --> 19:41.000]  Но он вроде как и не должен этого делать, иначе зачем он выбрал файберы? Почему он не выбрал просто потоки?
[19:42.000 --> 19:51.000]  То есть это в его случае будет осознанным выбором, поэтому он понимает ограничения или специфику инструмента, который он собирается использовать.
[19:51.000 --> 19:58.000]  В ГО ситуация сложнее, потому что там пользователь не выбирает между потоками и гарутинами, там есть только гарутины.
[19:58.000 --> 20:09.000]  Поэтому там, значит, разработчики языка уважают принцип наименьшего удивления и ожидают, что пользователь может любую программу на ГО написать,
[20:09.000 --> 20:14.000]  а значит, когда-нибудь придется все же гарутины вытеснить.
[20:14.000 --> 20:22.000]  Но в любом случае мы будем делать параллелизм уже через неделю, наши файберы будут исполняться одновременно на разных ядрах,
[20:22.000 --> 20:29.000]  и мы не будем делать вытеснения. Но при этом я скажу, что вытеснения сделать можно.
[20:29.000 --> 20:37.000]  То есть если вы захотите, то к файберам можно приделать и вот такое, и механизм приемщину самый настоящий.
[20:37.000 --> 20:42.000]  Но просто нас не интересует, мне кажется, что это не самая полезная функциональность.
[20:44.000 --> 20:52.000]  Хорошо, есть ли вопросы к тому, что мы хотим сделать? Нужно ли что-то пояснить?
[20:55.000 --> 20:59.000]  Верим ли мы, что мы научимся делать потоки после этого?
[20:59.000 --> 21:11.000]  Ну, не знаю, нам это на этом курсе нужно или опять же нужно? Мы должны на осеннем заниматься.
[21:11.000 --> 21:18.000]  Мы собираемся изучить потоки, устройства потоков на примере файберов.
[21:18.000 --> 21:24.000]  Вот я сейчас спрашиваю, в какой степени нам это нужно? Я утверждаю, что нам это нужно, понимать, что такое потоки,
[21:24.000 --> 21:29.000]  потому что если мы не понимаем, что такое потоки, то очень странно, как мы вообще с ними дальше работать собираемся.
[21:29.000 --> 21:34.000]  Полезно понимать то, что мы трогаем своими руками. Мы же в конце концов инженеры.
[21:34.000 --> 21:38.000]  Мы понимаем тогда, когда умеем это запрограммировать.
[21:38.000 --> 21:44.000]  И я сейчас спрашиваю не о том, как мы собираемся пользоваться файберами,
[21:44.000 --> 21:48.000]  а я сейчас говорю, что мы на примере файберов хотим понять потоки.
[21:48.000 --> 21:52.000]  И вот верим ли мы, что на примере файберов мы действительно поймем потоки?
[21:53.000 --> 21:58.000]  Может быть, я что-то не учел. Я вроде поговорил про функциональность,
[21:58.000 --> 22:01.000]  про то, что файбер научится делать, эти выводы, синхронизацию.
[22:01.000 --> 22:05.000]  Но, впрочем, они уже умеют про параллелизм, про утеснение.
[22:05.000 --> 22:09.000]  Но вот чем-то в нашем уме файберы от потоков еще отличаются?
[22:12.000 --> 22:19.000]  Наверное, да. Возможно, у меня, конечно, в голове все перепуталось, но, по-моему,
[22:19.000 --> 22:24.000]  вот тот вот пример с тем, когда внезапно оказывается,
[22:24.000 --> 22:28.000]  что в двух прочитанных переменных внезапно одновременно оказывается ноль,
[22:28.000 --> 22:32.000]  может быть, вот этим они могут отличаться от потоков.
[22:32.000 --> 22:34.000]  А это не имеет отношения к файберам или потокам.
[22:34.000 --> 22:37.000]  Это происходит на уровне процессора и обращения к памяти.
[22:39.000 --> 22:41.000]  То есть это на уровне железа происходит.
[22:41.000 --> 22:45.000]  А потоки, файберы, это же такие сущности виртуальные.
[22:45.000 --> 22:48.000]  Они появляются на уровне операционной системы, библиотека.
[22:48.000 --> 22:50.000]  Это просто более высокий уровень.
[22:50.000 --> 22:53.000]  Если мы сделаем файберы параллельными, а мы сделаем их,
[22:53.000 --> 22:55.000]  то они будут исполняться на разных ядрах,
[22:55.000 --> 22:59.000]  и тогда они будут наблюдать те же самые странные эффекты.
[23:00.000 --> 23:02.000]  То есть тут ничего не поменяется.
[23:04.000 --> 23:06.000]  Ну тогда вроде бы да.
[23:06.000 --> 23:09.000]  Отлично. Значит, я вас убедил, что мы делаем потоки.
[23:09.000 --> 23:11.000]  Мы сделаем потоки.
[23:11.000 --> 23:14.000]  Ну тогда давайте переходить к реализации.
[23:15.000 --> 23:18.000]  И начну я вот с такого вопроса.
[23:18.000 --> 23:20.000]  Ну вот, написан код.
[23:20.000 --> 23:22.000]  Вот он как-то себя ведет.
[23:22.000 --> 23:24.000]  И вам дают задачу.
[23:24.000 --> 23:26.000]  Вот, напишите реализацию этих функций.
[23:26.000 --> 23:29.000]  Что тут выглядит самым необычным?
[23:32.000 --> 23:37.000]  Вот почему нетривиально такое поведение реализовать?
[23:37.000 --> 23:41.000]  Действительно, у нас есть функция yield, и она очень необычная.
[23:41.000 --> 23:43.000]  Вроде бы мы вызываем обычную функцию.
[23:44.000 --> 23:47.000]  Но при этом, как ведет себя обычная функция,
[23:47.000 --> 23:49.000]  мы заходим в нее, она начинает выполняться,
[23:49.000 --> 23:51.000]  может вызывать какие-то другие функции,
[23:51.000 --> 23:54.000]  но в конце концов вызов функции завершается,
[23:54.000 --> 23:56.000]  она возвращает нам управление.
[23:56.000 --> 23:59.000]  Мы один раз в нее заходим, один раз из нее выходим.
[23:59.000 --> 24:03.000]  Функция yield ведет себя иначе.
[24:03.000 --> 24:08.000]  Мы заходим в нее, ну вот скажем здесь,
[24:08.000 --> 24:10.000]  мы заходим в этот вызов yield,
[24:10.000 --> 24:13.000]  а выходим почему-то из этого вызова yield.
[24:13.000 --> 24:15.000]  Это довольно странно.
[24:15.000 --> 24:19.000]  Кроме того, мы заходим в этот вызов yield один раз,
[24:19.000 --> 24:22.000]  а выходим получается два раза.
[24:22.000 --> 24:25.000]  С одной стороны, первый раз мы выходим отсюда,
[24:25.000 --> 24:27.000]  ну не совсем из этого вызова, но все-таки выходим,
[24:27.000 --> 24:29.000]  продолжаем исполнять какой-то другой код.
[24:29.000 --> 24:32.000]  А второй раз мы выходим из этого yield,
[24:32.000 --> 24:38.000]  тогда, когда нулевому стартовому файберу возвращают управление.
[24:38.000 --> 24:42.000]  Когда видимо завершается второй запущенный файбер.
[24:43.000 --> 24:46.000]  То есть у нас здесь какая-то очень нелокальная,
[24:46.000 --> 24:48.000]  странная передача управления,
[24:48.000 --> 24:51.000]  и мы заходим один раз, а выходим дважды.
[24:51.000 --> 24:55.000]  Вот это самое нетривиальное, кажется, место в этом примере.
[24:55.000 --> 24:59.000]  Потому что вот что такое сконструировать файбер тоже пока непонятно,
[24:59.000 --> 25:02.000]  но в целом вот мы конструируем какой-то объект,
[25:02.000 --> 25:06.000]  кладем его в какую-то очередь, это еще вот мы можем себе вообразить.
[25:06.000 --> 25:09.000]  А как написать yield?
[25:09.000 --> 25:11.000]  Под вопросом пока.
[25:11.000 --> 25:14.000]  Тем более, почему под вопросом?
[25:14.000 --> 25:20.000]  Потому что вроде бы мы, смотрите, мы пишем какой-то код,
[25:20.000 --> 25:23.000]  и ему же придется исполняться на процессоре.
[25:23.000 --> 25:29.000]  И в данном случае процессор нам помогать сильно не будет.
[25:29.000 --> 25:33.000]  Вот мы умеем передвигаться по коду с помощью инструкции,
[25:33.000 --> 25:36.000]  там не знаю, jump условных, безусловных.
[25:36.000 --> 25:39.000]  У нас есть в процессоре инструкции call и read,
[25:39.000 --> 25:43.000]  с помощью которых процессор двигается,
[25:43.000 --> 25:49.000]  который компилятор расставляет в точках вызова функции завершения.
[25:49.000 --> 25:55.000]  И мы привыкли, что для функций выполняется такое простое свойство,
[25:55.000 --> 25:59.000]  что любые два вызова, они либо не пересекаются между собой,
[25:59.000 --> 26:01.000]  либо один вложен в другой.
[26:01.000 --> 26:04.000]  Давайте мы какой-то простой пример откроем.
[26:04.000 --> 26:08.000]  Вот я взял Godbolt, написал какую-то программу с вызовами функций,
[26:08.000 --> 26:11.000]  и вот у нас есть функция foo, которая вызывает функцию bar,
[26:11.000 --> 26:15.000]  которая вызывает функцию baz, а потом baz вызывается прямо из foo.
[26:16.000 --> 26:21.000]  И вы, наверное, понимаете, что чтобы двигаться по вот такому коду,
[26:21.000 --> 26:24.000]  процессору нужно поддерживать call stack.
[26:24.000 --> 26:31.000]  Потому что когда мы, скажем, вызываем функцию foo из main,
[26:31.000 --> 26:37.000]  то мы, компилятор, знаем, куда мы хотим прыгнуть.
[26:38.000 --> 26:41.000]  Адрес понятен нам.
[26:41.000 --> 26:43.000]  Но с другой стороны, когда мы выходим из какой-то функции,
[26:43.000 --> 26:47.000]  например, из функции baz, то компилятору уже, конечно, неизвестно,
[26:47.000 --> 26:50.000]  куда мы вернемся, то ли мы вернемся в функцию bar,
[26:50.000 --> 26:54.000]  то ли мы вернемся в функцию foo.
[26:54.000 --> 26:56.000]  И для того, чтобы двигаться по этому коду,
[26:56.000 --> 27:00.000]  процессору, ядру процессора, нужен call stack,
[27:00.000 --> 27:04.000]  на котором процессор будет сохранять до 10 возвратов.
[27:04.000 --> 27:09.000]  Когда мы вызываем функцию baz, то мы кладем на вершину stack,
[27:09.000 --> 27:12.000]  после мантики инструкции call мы кладем на вершину stack
[27:12.000 --> 27:18.000]  адрес очередной за вызовом baz инструкции.
[27:18.000 --> 27:23.000]  Когда вызов baz завершается в инструкции red,
[27:23.000 --> 27:26.000]  мы снимаем адрес возврата с вершины stack
[27:26.000 --> 27:30.000]  и кладем его в регистр процессора, instruction pointer.
[27:30.000 --> 27:33.000]  И это, кстати, нам сегодня понадобится единственный способ
[27:33.000 --> 27:38.000]  instruction pointer манипулировать.
[27:38.000 --> 27:42.000]  Это важно, потому что я сейчас утверждаю,
[27:42.000 --> 27:47.000]  что никакого другого механизма движения по коду вашей программы,
[27:47.000 --> 27:49.000]  по ее функциям в процессоре нет.
[27:49.000 --> 27:53.000]  Есть stack вызовов, есть инструкции call, red,
[27:53.000 --> 27:57.000]  положить на stack адрес возврата, снять со stack возврата и прыгнуть в него.
[27:57.000 --> 28:02.000]  Вот это все инструменты, которые в нашем распоряжении имеются.
[28:02.000 --> 28:06.000]  То есть, когда мы будем писать переключения
[28:06.000 --> 28:10.000]  между разными частями файбера,
[28:10.000 --> 28:16.000]  мы будем какие-то хитрые вещи с call stack делать, да?
[28:16.000 --> 28:20.000]  Это не совсем то, что я прямо сейчас хотел сказать.
[28:20.000 --> 28:23.000]  Я скорее хотел обратить внимание, что никакой специальной магии
[28:23.000 --> 28:27.000]  в процессоре для реализации вот такого нетривиального поведения,
[28:27.000 --> 28:30.000]  нелокальной передачи управления нет.
[28:30.000 --> 28:34.000]  Мы собираемся сделать файберы из того, что вы уже знаете.
[28:34.000 --> 28:37.000]  Если вы знаете про call stack и инструкции call, red,
[28:37.000 --> 28:39.000]  а это, кажется, тема первого семинара,
[28:39.000 --> 28:44.000]  то таких знаний достаточно, чтобы, простите,
[28:44.000 --> 28:49.000]  написать собственные файберы с такой передачей управления.
[28:49.000 --> 28:52.000]  И да, раз у нас ничего другого нет,
[28:52.000 --> 28:55.000]  то нам придется к какой-то хитрости прибегать.
[28:55.000 --> 28:57.000]  Но дело отличается, скажем, от Atomic,
[28:57.000 --> 29:00.000]  потому что в Atomic вы знаете, там есть какие-то специальные инструкции
[29:00.000 --> 29:02.000]  в процессоре для того, чтобы делать атомарные операции.
[29:02.000 --> 29:05.000]  Здесь у нас обычный call, red, call stack,
[29:05.000 --> 29:09.000]  и мы должны каким-то образом выразить вот такое странное поведение,
[29:09.000 --> 29:14.000]  где вызовы разных файберов, разных функций, разных лямб пересекаются.
[29:14.000 --> 29:17.000]  Они не вложены, не пересекаются,
[29:17.000 --> 29:24.000]  фрагменты функций чередуются друг с другом на процессоре.
[29:24.000 --> 29:28.000]  Ну и давайте себе примерно представим, как это могло бы выглядеть,
[29:28.000 --> 29:31.000]  как это могло бы работать.
[29:31.000 --> 29:35.000]  Ну, мы хотим сохранить состояние,
[29:35.000 --> 29:39.000]  из которого вызвали yield, то есть, видимо, stack,
[29:39.000 --> 29:42.000]  вершину stack вот этого вот файбера,
[29:42.000 --> 29:45.000]  и регистры какие-то, которые, ну, незатираемые,
[29:45.000 --> 29:47.000]  которые ему хочется запомнить,
[29:47.000 --> 29:51.000]  и просто записать их, чтобы дальше можно было это восстановить
[29:51.000 --> 29:55.000]  перед тем, как возвращать управление этому файберу.
[29:55.000 --> 29:58.000]  Ну да, мы сейчас занимаем, мы сейчас рассуждаем,
[29:58.000 --> 30:01.000]  как написать yield. Так, воображаем пока.
[30:01.000 --> 30:04.000]  И тут есть как бы две стороны вопроса.
[30:04.000 --> 30:07.000]  Во-первых, это работа с очередью планировщика.
[30:07.000 --> 30:09.000]  Нам нужно поставить себя в очередь,
[30:09.000 --> 30:11.000]  выбрать какой-то следующий файбер из очереди,
[30:11.000 --> 30:13.000]  в общем, этот рангью участвует.
[30:13.000 --> 30:16.000]  А есть такой чисто технический момент,
[30:16.000 --> 30:19.000]  как переключить исполнение,
[30:19.000 --> 30:22.000]  как переключить процессор с исполнения вот этой функции
[30:22.000 --> 30:25.000]  на исполнение этой функции.
[30:25.000 --> 30:28.000]  И вот это не вызов функции,
[30:28.000 --> 30:30.000]  потому что мы выходим из середины почему-то
[30:30.000 --> 30:32.000]  и прыгаем в другое место.
[30:32.000 --> 30:36.000]  Так что нужно вспомнить, что такое вообще исполнение.
[30:36.000 --> 30:39.000]  Исполнение с точки зрения процессора – это
[30:39.000 --> 30:42.000]  что нужно к ядру процессора, чтобы исполнять код.
[30:42.000 --> 30:45.000]  Ему нужен instruction pointer, чтобы, собственно,
[30:45.000 --> 30:49.000]  понимать, какую инструкцию дальше считывать, декодировать, исполнять.
[30:49.000 --> 30:53.000]  И ему нужен call stack, чтобы по коду двигаться.
[30:53.000 --> 30:56.000]  Ну, там, pointer еще на корень таблицы страниц, в общем,
[30:56.000 --> 30:58.000]  какие-то еще дополнительные вещи.
[30:58.000 --> 31:02.000]  И, разумеется, регистр процессора, в которых
[31:02.000 --> 31:06.000]  исполнение раскладывает какие-то свои
[31:06.000 --> 31:09.000]  результаты, аргументы, возвращаемые значения,
[31:09.000 --> 31:13.000]  все, что этому исполняемому коду требуется.
[31:13.000 --> 31:17.000]  Когда мы говорим про переключение, переключение контекста,
[31:20.000 --> 31:23.000]  то, видимо, мы должны вот это состояние
[31:23.000 --> 31:27.000]  процессора сохранить
[31:27.000 --> 31:31.000]  и сохранить с ядра куда-то
[31:31.000 --> 31:35.000]  и активировать на ядре состояние
[31:35.000 --> 31:38.000]  контекста исполнения вот этого,
[31:38.000 --> 31:40.000]  ну, еще не запущенного fiber.
[31:40.000 --> 31:43.000]  Когда мы говорим здесь yield, то мы активируем
[31:43.000 --> 31:47.000]  контекст, сохраненный вот в этой точке.
[31:47.000 --> 31:51.000]  Контекст — это набор регистров, который,
[31:51.000 --> 31:54.000]  относительно которого,
[31:54.000 --> 31:57.000]  исполнение процессора вообще что-то исполняет.
[31:57.000 --> 32:00.000]  То есть, это такой согласованный набор регистров,
[32:00.000 --> 32:04.000]  RIP, instruction pointer, RIP, stack pointer, RSP,
[32:04.000 --> 32:07.000]  ну, и так далее.
[32:07.000 --> 32:10.000]  Вот здесь мы хотим эти регистры сохранить
[32:10.000 --> 32:13.000]  с процессора в память, и потом намазать
[32:13.000 --> 32:17.000]  вот здесь, сохранить и намазать вот эти регистры,
[32:17.000 --> 32:20.000]  которые были сохранены шагом ранее.
[32:20.000 --> 32:23.000]  Пока мы не будем разбираться, как именно это все работает,
[32:23.000 --> 32:26.000]  как мы сохраняем регистры, какие регистры, почему
[32:26.000 --> 32:30.000]  такие, мы скажем, что у нас для этого просто есть
[32:30.000 --> 32:33.000]  вспомогательный такой компонент, инструмент, который
[32:33.000 --> 32:36.000]  называется executionContext.
[32:39.000 --> 32:42.000]  Вот такая структура, у которой есть, ну,
[32:42.000 --> 32:45.000]  по сути,
[32:46.000 --> 32:50.000]  единственный метод — switchTo.
[32:54.000 --> 32:57.000]  И что мы сможем с помощью него сделать? Мы можем
[32:57.000 --> 33:00.000]  написать такую строчку.
[33:01.000 --> 33:04.000]  Пока пользуемся им, как некоторым
[33:04.000 --> 33:07.000]  черным ящиком, нам не важно, как устроено,
[33:07.000 --> 33:10.000]  примерно, как устроено switchTo, мы с этим разберемся
[33:10.000 --> 33:13.000]  чуть позже. Пока нам важна семантика.
[33:13.000 --> 33:16.000]  Итак, представим себе, что мы,
[33:16.000 --> 33:19.000]  процессор, мы исполняем код, и в этом коде написано
[33:19.000 --> 33:22.000]  контекст switchTo, контекст штрих.
[33:22.000 --> 33:25.000]  Семантика вызова такова. Сохранить
[33:25.000 --> 33:28.000]  текущий контекст исполнения, то есть набор регистров,
[33:28.000 --> 33:31.000]  в эту переменную.
[33:31.000 --> 33:34.000]  И активировать набор регистров,
[33:34.000 --> 33:37.000]  который сохранен в штрихованном контексте справа от switchTo.
[33:44.000 --> 33:47.000]  То есть мы вот здесь переключаем
[33:47.000 --> 33:50.000]  процессор на исполнение какого-то другого кода,
[33:50.000 --> 33:53.000]  видимо, собственным стэком, потому что исполнение
[33:53.000 --> 33:56.000]  всегда относительно какого-то стэка происходит.
[33:56.000 --> 33:59.000]  С другими значениями содержимым регистров.
[34:02.000 --> 34:05.000]  Но возникает вопрос, откуда взялся контекст штрих?
[34:05.000 --> 34:08.000]  Откуда там взялись сохраненные регистры? Но, видимо, возможно.
[34:08.000 --> 34:11.000]  Контекст штрих до этого когда-то сам
[34:11.000 --> 34:14.000]  стоял слева от вызова switchTo.
[34:16.000 --> 34:19.000]  И вот мы когда-то ранее сохранили в него состояние
[34:19.000 --> 34:22.000]  процессора, а сейчас мы его активируем,
[34:22.000 --> 34:25.000]  и в него возвращаемся.
[34:26.000 --> 34:29.000]  Что значит, если мы прыгаем обратно по стэку?
[34:29.000 --> 34:32.000]  Если мы прыгаем вперед, то есть заходя на уровень бы уже...
[34:32.000 --> 34:35.000]  Что значит прыгаем по стэку? Мы не прыгаем по стэку.
[34:38.000 --> 34:41.000]  Мы переключаем разные исполнения.
[34:41.000 --> 34:44.000]  Любое исполнение в процессоре происходит относительно
[34:44.000 --> 34:47.000]  стэка, потому что стэк
[34:47.000 --> 34:50.000]  это некоторый путь сейчас
[34:50.000 --> 34:53.000]  в дереве вызова функций.
[34:53.000 --> 34:56.000]  Да, но вот насколько я понимаю, сейчас мы
[34:56.000 --> 34:59.000]  конкретно сейчас мы
[34:59.000 --> 35:02.000]  switchTo рассматриваем, если у нас контекст
[35:02.000 --> 35:05.000]  штрих уже когда-то был. Это значит, мы возвращаемся
[35:05.000 --> 35:08.000]  на уровень выше по стэку.
[35:08.000 --> 35:11.000]  Уровень выше по стэку, я не понимаю, что это значит.
[35:11.000 --> 35:14.000]  Это вообще звучит некорректно, если честно.
[35:14.000 --> 35:17.000]  Ну, предыдущий элемент в стэке. В каком стэке?
[35:17.000 --> 35:20.000]  Тут нет никакого стэка.
[35:20.000 --> 35:23.000]  Ты понимаешь, значит, предыдущий в стэке? Я говорю, что
[35:23.000 --> 35:26.000]  у нас есть процессор, он исполняет код.
[35:26.000 --> 35:29.000]  И этот код вызывает метод switchTo.
[35:29.000 --> 35:32.000]  И я регистры процессора сохраняю сюда,
[35:32.000 --> 35:35.000]  я активирую регистры отсюда.
[35:35.000 --> 35:38.000]  Намазываю их на процессор.
[35:38.000 --> 35:41.000]  Да, это понятно, что делает switchTo.
[35:41.000 --> 35:44.000]  Но что делать, если контекст штрих
[35:44.000 --> 35:47.000]  у нас никогда еще не был?
[35:47.000 --> 35:50.000]  Это странно, что ты прыгаешь в контекст,
[35:50.000 --> 35:53.000]  который еще не существовал. Значит, ты написал
[35:53.000 --> 35:56.000]  неправильную программу.
[35:56.000 --> 35:59.000]  Получается, мы можем вызывать функции
[35:59.000 --> 36:02.000]  только те, которые у нас были.
[36:02.000 --> 36:05.000]  То, что это множество не пустое, мы пока не доказали.
[36:05.000 --> 36:08.000]  Если ты про то, что нам...
[36:08.000 --> 36:11.000]  Я понимаю, про что ты говоришь.
[36:11.000 --> 36:14.000]  Ты не совсем все же корректные слова выбираешь.
[36:14.000 --> 36:17.000]  Если ты выбираешь выше по стэку,
[36:17.000 --> 36:20.000]  тут нет, к сожалению, общего стэка,
[36:20.000 --> 36:23.000]  относительно которого мы все это делаем.
[36:23.000 --> 36:26.000]  Я действительно говорю, что если мы
[36:26.000 --> 36:29.000]  сохраняем текущий контекст с процессора
[36:29.000 --> 36:32.000]  вот сюда и активируем этот контекст, то этот контекст
[36:32.000 --> 36:35.000]  должен быть валиден. В нем должны быть
[36:35.000 --> 36:38.000]  какие-то разумные содержимые регистров записано.
[36:38.000 --> 36:41.000]  И откуда оно могло взяться?
[36:41.000 --> 36:44.000]  Вот этот контекст штрих до этого в исполнении
[36:44.000 --> 36:47.000]  когда-то находился слева от свечту.
[36:47.000 --> 36:50.000]  И мы в него сохранили состояние исполнения на процессоре.
[36:50.000 --> 36:53.000]  Но возникает тогда вопрос,
[36:53.000 --> 36:56.000]  откуда взялся контекст два штриха.
[36:56.000 --> 36:59.000]  И вот так можно откатываться, откатываться, откатываться,
[36:59.000 --> 37:02.000]  добавляя и добавляя штрихи. Где-то должна быть база.
[37:02.000 --> 37:05.000]  Это правда, но мы пока этот вопрос откладываем.
[37:05.000 --> 37:08.000]  Мы пока про базу не говорим. Мы говорим про отдельную
[37:08.000 --> 37:11.000]  и считаем, что вот контекст штрих откуда-то уже взялся.
[37:11.000 --> 37:14.000]  Если мы вернемся вот
[37:14.000 --> 37:17.000]  к этому коду,
[37:17.000 --> 37:20.000]  то я иллюстрирую такой пример, что мы заходим
[37:20.000 --> 37:23.000]  в этот Yield и выходим отсюда.
[37:23.000 --> 37:26.000]  И здесь мы активируем контекст
[37:26.000 --> 37:29.000]  вот в этом вызове Yield, мы активируем контекст,
[37:29.000 --> 37:32.000]  который был сохранен вот здесь вот.
[37:33.000 --> 37:36.000]  Но есть отдельная ситуация,
[37:36.000 --> 37:39.000]  когда мы вызываем вот этот Yield,
[37:39.000 --> 37:42.000]  и мы активируем контекст вот запущенного файбера.
[37:42.000 --> 37:45.000]  А откуда он взялся, непонятно.
[37:45.000 --> 37:48.000]  Ну, забегая вперед, я скажу,
[37:48.000 --> 37:51.000]  что мы его сами руками сконструировали,
[37:51.000 --> 37:54.000]  прям вот буквально руками.
[37:54.000 --> 37:57.000]  Но это такой базовый случай,
[37:57.000 --> 38:00.000]  а дальше все остальные переключения контекста
[38:00.000 --> 38:03.000]  внутри файберов, они выполняются
[38:03.000 --> 38:06.000]  с помощью вот такого вызова.
[38:09.000 --> 38:12.000]  И вот происходящая здесь операция, она называется
[38:12.000 --> 38:15.000]  симметричной передачей управления.
[38:17.000 --> 38:20.000]  Небольшое замечание. Класс, про который
[38:20.000 --> 38:23.000]  я сейчас говорю, называется ExecutionContext,
[38:23.000 --> 38:26.000]  и он вообще-то находится в отдельной библиотеке.
[38:27.000 --> 38:30.000]  И он не связан ни с потоками,
[38:30.000 --> 38:33.000]  ни с файберами. Он оперирует
[38:33.000 --> 38:36.000]  понятием исполнения.
[38:36.000 --> 38:39.000]  Если вы вспомните первый семинар,
[38:39.000 --> 38:42.000]  то какая там одна из важных мыслей,
[38:42.000 --> 38:45.000]  которая должна была с вами остаться после него,
[38:45.000 --> 38:48.000]  что на уровне процессора
[38:48.000 --> 38:51.000]  у вас есть instruction pointer,
[38:51.000 --> 38:54.000]  у вас есть stack pointer, у вас есть call stack.
[38:54.000 --> 38:57.000]  Вот это и процессор
[38:57.000 --> 39:00.000]  с помощью вот этих
[39:00.000 --> 39:03.000]  с помощью вот этих структур данных,
[39:03.000 --> 39:06.000]  stack, там таблица, страница, еще чего-то, исполняет ваш код.
[39:06.000 --> 39:09.000]  Что это за код? Это код файбера, это код потока
[39:09.000 --> 39:12.000]  из питредов.
[39:12.000 --> 39:15.000]  Процессору неважно, на его уровне всего этого нет.
[39:16.000 --> 39:19.000]  Мы сейчас говорим именно про исполнение
[39:19.000 --> 39:22.000]  на процессоре и как процессор переключить
[39:22.000 --> 39:25.000]  вызовы исполнения на другое.
[39:25.000 --> 39:28.000]  Вот этот execution-контекст, он более универсален,
[39:28.000 --> 39:31.000]  чем файбера. Файбера это всего лишь одно из
[39:31.000 --> 39:34.000]  применений процедуры переключения контекста.
[39:37.000 --> 39:40.000]  И мы собираемся ее использовать вот где-то
[39:40.000 --> 39:43.000]  внутри этого вызова yield.
[39:43.000 --> 39:46.000]  Давайте я сейчас сразу забегу немного вперед,
[39:46.000 --> 39:49.000]  пока не важно, что это все значит.
[39:49.000 --> 39:52.000]  И потом вызывать там какой-то switch-to в конце концов.
[39:57.000 --> 40:00.000]  Хорошо. Если мы понимаем,
[40:00.000 --> 40:03.000]  в чем сложность вот в этом переключении контекста,
[40:03.000 --> 40:06.000]  в нелокальной передаче управления, и мы понимаем
[40:06.000 --> 40:09.000]  семантику switch-to и само назначение
[40:09.000 --> 40:12.000]  класс execution-контекст, то можно теперь
[40:12.000 --> 40:15.000]  перейти уже к конкретному применению всего этого,
[40:15.000 --> 40:18.000]  к нашим файберам, и разобрать два основных
[40:18.000 --> 40:21.000]  элемента библиотеки, а именно сам файбер,
[40:21.000 --> 40:24.000]  сам объект файбер и планировщик
[40:24.000 --> 40:27.000]  файбера. Давайте начнем с файбера.
[40:27.000 --> 40:30.000]  Вот он представлен в виде
[40:30.000 --> 40:33.000]  соответствующего класса.
[40:36.000 --> 40:39.000]  И нас интересует сейчас,
[40:39.000 --> 40:42.000]  чем образован этот файбер.
[40:42.000 --> 40:45.000]  Во-первых, файбер исполняет некоторую лямбду.
[40:45.000 --> 40:48.000]  И эта лямбда в нем хранится в виде контейнера,
[40:48.000 --> 40:51.000]  в виде уник-фанкшн. Это альтернативная
[40:51.000 --> 40:54.000]  реализация std-фанкшн, которая
[40:54.000 --> 40:57.000]  позволяет нам хранить move-only лямбду.
[40:57.000 --> 41:00.000]  Есть код, который файбер
[41:00.000 --> 41:03.000]  собирается исполнять.
[41:03.000 --> 41:06.000]  У файбера, помимо этого кода, есть еще и стэк,
[41:06.000 --> 41:09.000]  потому что проще
[41:09.000 --> 41:12.000]  показать. Давайте посмотрим на другой пример.
[41:13.000 --> 41:16.000]  Вот на такой.
[41:16.000 --> 41:19.000]  Запускаем планировщик. В нем запускаем...
[41:19.000 --> 41:22.000]  В нем файбер запускает
[41:22.000 --> 41:25.000]  другой файбер и вызывает функцию foo.
[41:25.000 --> 41:28.000]  В этой функции foo он вызывает функцию bar. В этой функции
[41:28.000 --> 41:31.000]  bar он говорит yield.
[41:31.000 --> 41:34.000]  И управление передается вот этому
[41:34.000 --> 41:37.000]  файберу. Этот файбер вызывает функцию bus.
[41:37.000 --> 41:40.000]  В функции bus тоже сразу говорит yield.
[41:40.000 --> 41:43.000]  После чего возвращает управление сюда
[41:43.000 --> 41:46.000]  и первый файбер завершает
[41:46.000 --> 41:49.000]  свою работу. Ну вот давайте мы этот пример
[41:49.000 --> 41:52.000]  запустим и продемонстрируем.
[41:52.000 --> 41:55.000]  Ну, я надеюсь, понятное...
[41:58.000 --> 42:01.000]  Понятное свойство файберов, но все же.
[42:05.000 --> 42:08.000]  Видеть своими глазами тоже полезно.
[42:10.000 --> 42:13.000]  Простите, что так неспешно. Тут просто
[42:13.000 --> 42:16.000]  и EDE, и скринкаст пишется, и зум.
[42:16.000 --> 42:19.000]  Все это не добавляет нам скорости.
[42:19.000 --> 42:22.000]  Вот так вот.
[42:22.000 --> 42:25.000]  Ну, я надеюсь, вам понравилось это видео.
[42:25.000 --> 42:28.000]  Если вам понравилось, не забывайте
[42:28.000 --> 42:31.000]  поставить лайк.
[42:31.000 --> 42:34.000]  А если вам понравилось, не забывайте
[42:34.000 --> 42:37.000]  подписаться на канал.
[42:37.000 --> 42:40.000]  Все это не добавляет нам скорости.
[42:40.000 --> 42:43.000]  Вот мы вызвали функцию foo и остановились
[42:43.000 --> 42:46.000]  на breakpoint.
[42:46.000 --> 42:49.000]  Смотрим на текущий стэк.
[42:49.000 --> 42:52.000]  Ну, там что-то странное внизу происходит, но в конце концов
[42:52.000 --> 42:55.000]  на верхушке вызов bar,
[42:55.000 --> 42:58.000]  под ним вызов foo.
[42:58.000 --> 43:01.000]  Вот мы сейчас в стартовом файбере
[43:01.000 --> 43:04.000]  зашли foo, в нем зашли в bar и остановились
[43:04.000 --> 43:07.000]  на breakpoint.
[43:07.000 --> 43:10.000]  Вот как выглядит наш стэк.
[43:10.000 --> 43:13.000]  После этого мы возобновляем
[43:13.000 --> 43:16.000]  исполнение и, видимо, попадаем в yield
[43:16.000 --> 43:19.000]  и перемещаемся в этот файбер
[43:19.000 --> 43:22.000]  и останавливаемся на его
[43:22.000 --> 43:25.000]  breakpoint. Вот мы теперь стоим на стэке, где
[43:25.000 --> 43:28.000]  находится только вызов bass.
[43:28.000 --> 43:31.000]  А дальше мы снова
[43:31.000 --> 43:34.000]  из вызова bass, из этого yield,
[43:34.000 --> 43:37.000]  прыгаем сюда. Возвращаемся
[43:37.000 --> 43:40.000]  из этого вызова yield функцией bar,
[43:40.000 --> 43:43.000]  останавливаемся на втором breakpoint.
[43:43.000 --> 43:46.000]  И вот мы снова на стэке bar foo bar.
[43:46.000 --> 43:49.000]  О чем это нам говорит? Что у каждого
[43:49.000 --> 43:52.000]  файбера есть свой собственный стэк вызовов.
[43:52.000 --> 43:55.000]  Они находятся в разных точках
[43:55.000 --> 43:58.000]  в этой иерархии, в этом дереве вызовов
[43:58.000 --> 44:01.000]  функций в программе.
[44:01.000 --> 44:04.000]  Еще раз повторю, любое
[44:04.000 --> 44:07.000]  исполнение на процессоре осуществляется
[44:07.000 --> 44:10.000]  относительно некоторого стэка вызовов.
[44:10.000 --> 44:13.000]  И у каждого файбера он свой.
[44:13.000 --> 44:16.000]  Так что мы это можем наблюдать
[44:16.000 --> 44:19.000]  в этой структуре.
[44:19.000 --> 44:22.000]  Что такое стэк здесь?
[44:22.000 --> 44:25.000]  Если смотреть в реализацию, то это
[44:26.000 --> 44:29.000]  просто-напросто диапазон памяти.
[44:29.000 --> 44:32.000]  Чарльзвездочка size t.
[44:32.000 --> 44:35.000]  Откуда он взялся,
[44:37.000 --> 44:40.000]  можно зайти в этот вызов
[44:40.000 --> 44:43.000]  и посмотреть.
[44:43.000 --> 44:46.000]  Мы этот стэк лоцировали.
[44:46.000 --> 44:49.000]  Терпеливо ждем.
[44:49.000 --> 44:52.000]  А локация это не что иное,
[44:52.000 --> 44:55.000]  как сегодня все медленно.
[45:01.000 --> 45:04.000]  Как вызов ММЭП?
[45:04.000 --> 45:07.000]  Как вызов ММЭП?
[45:07.000 --> 45:10.000]  Как вызов ММЭП?
[45:10.000 --> 45:13.000]  Как вызов ММЭП?
[45:14.000 --> 45:17.000]  Как вызов ММЭП?
[45:23.000 --> 45:26.000]  То есть, когда мы
[45:26.000 --> 45:29.000]  конструируем файбер, то мы лоцируем для него стэк
[45:29.000 --> 45:32.000]  с помощью вызова ММЭП,
[45:32.000 --> 45:35.000]  то есть просто заводим диапазон страниц в памяти,
[45:35.000 --> 45:38.000]  которые будут использованы
[45:38.000 --> 45:41.000]  для хранения, для поддержания
[45:41.000 --> 45:44.000]  стэка.
[45:44.000 --> 45:47.000]  Процессору совершенно не важно, в какую память он пишет,
[45:47.000 --> 45:50.000]  когда он работает с коллстэком.
[45:50.000 --> 45:53.000]  Вот то место, куда указывает регистр РСП в нем,
[45:53.000 --> 45:56.000]  это и есть для него стэк.
[45:56.000 --> 45:59.000]  Вот мы его выделяем так.
[45:59.000 --> 46:02.000]  Тут еще есть много каких-то тонкостей в пути.
[46:02.000 --> 46:05.000]  Мы пока их откладываем.
[46:05.000 --> 46:08.000]  Да, можно сразу задать вопрос, почему ММЭП,
[46:08.000 --> 46:11.000]  что с колл делать?
[46:11.000 --> 46:14.000]  Во-первых, мы с колл делать будем не всегда.
[46:14.000 --> 46:17.000]  Во-вторых, у этого есть некоторая необходимость.
[46:17.000 --> 46:20.000]  Мы хотим именно память, выровненную по страницам.
[46:20.000 --> 46:23.000]  Но это мы, если не успеем сегодня, то обсудим на семинаре.
[46:26.000 --> 46:29.000]  Хорошо, возвращаемся в файбер.
[46:32.000 --> 46:35.000]  У него есть стэк.
[46:35.000 --> 46:38.000]  У него есть чар-звездочка из IST, то есть вью над памятью.
[46:41.000 --> 46:44.000]  И есть, наконец, экзекьюшн-контекст.
[46:47.000 --> 46:50.000]  Вот это поле заполнено, конечно же, не всегда.
[46:50.000 --> 46:53.000]  Если файбер прямо сейчас исполняется,
[46:53.000 --> 46:56.000]  то здесь ничего содержательного не написано внутри этого объекта.
[46:56.000 --> 46:59.000]  Но если файбер сказал yield
[46:59.000 --> 47:02.000]  и остановился,
[47:02.000 --> 47:05.000]  то в этот момент вызывается свечту,
[47:05.000 --> 47:08.000]  который и записывает в поле экзекьюшн-контекста
[47:08.000 --> 47:11.000]  этого файбера текущие содержимые регистров процессора.
[47:11.000 --> 47:14.000]  То есть это поле заполнено,
[47:14.000 --> 47:17.000]  только если файбер сейчас остановлен
[47:17.000 --> 47:20.000]  и находится, например, в ранг U.
[47:20.000 --> 47:23.000]  И есть какие-то вспомогательные поля.
[47:23.000 --> 47:26.000]  У каждого файбера есть идентификатор.
[47:26.000 --> 47:29.000]  И у файбера есть состояние...
[47:29.000 --> 47:32.000]  Ну вот, это состояние означает,
[47:32.000 --> 47:35.000]  что файбер исполняется прямо сейчас.
[47:35.000 --> 47:38.000]  Это что он находится в ранг U.
[47:38.000 --> 47:41.000]  Это что он завершен.
[47:41.000 --> 47:44.000]  Зачем эти состояния нам нужны, мы чуть позже увидим.
[47:44.000 --> 47:47.000]  И можно теперь посмотреть
[47:47.000 --> 47:50.000]  еще раз на код создания файбера.
[47:53.000 --> 47:56.000]  Мы алоцируем стэк,
[47:56.000 --> 47:59.000]  генерируем уникальный идентификатор для файбера
[47:59.000 --> 48:02.000]  и, собственно, заводим структуру файбера,
[48:02.000 --> 48:05.000]  мувая туда функцию,
[48:05.000 --> 48:08.000]  которую он должен выполнять,
[48:08.000 --> 48:11.000]  и передавая владение алоцированным стэкам.
[48:14.000 --> 48:17.000]  Обратите внимание, что структура файбера
[48:17.000 --> 48:20.000]  нигде наружу в API-библиотеке публично не торчит.
[48:20.000 --> 48:23.000]  Пользователь к этому объекту доступа не имеет.
[48:26.000 --> 48:29.000]  У него есть API-spawn,
[48:29.000 --> 48:32.000]  API-yield, но есть slip-forward, get-id,
[48:32.000 --> 48:35.000]  но прямого доступа к этому объекту нет,
[48:35.000 --> 48:38.000]  и join-handle это, конечно же, не
[48:38.000 --> 48:41.000]  ссылка прямо на объект файбера.
[48:41.000 --> 48:44.000]  Это всего лишь ручка, с помощью которой можно заблокироваться
[48:44.000 --> 48:47.000]  на ожидании завершения файбера, но все же это не файбер.
[48:47.000 --> 48:50.000]  И вот, кстати,
[48:50.000 --> 48:53.000]  когда мы говорим про STD thread,
[48:53.000 --> 48:56.000]  то ведь экземпляр класса STD thread
[48:56.000 --> 48:59.000]  это не то же, вот прям объект поток.
[48:59.000 --> 49:02.000]  Это, на самом деле, такая же ручка, с помощью которой можно
[49:02.000 --> 49:05.000]  сделать det через join.
[49:05.000 --> 49:08.000]  То есть STD thread C++ в библиотеке
[49:08.000 --> 49:11.000]  работать с потоками, это вот в точности то же самое,
[49:11.000 --> 49:14.000]  что join-handle у нас.
[49:14.000 --> 49:17.000]  То есть это не сам поток, это не сам файбер.
[49:17.000 --> 49:20.000]  Мы пользователю доступа до этого объекта не даем.
[49:23.000 --> 49:26.000]  Есть такие потоки,
[49:26.000 --> 49:29.000]  есть файберы,
[49:29.000 --> 49:32.000]  и есть class execution context,
[49:32.000 --> 49:35.000]  который мы пока не понимаем, как устроен, но в принципе
[49:35.000 --> 49:38.000]  можно было бы уже, имея вот такие файберы, потоки
[49:38.000 --> 49:41.000]  и стэки, написать саму библиотеку.
[49:41.000 --> 49:44.000]  Мы запускаем файбер, он начинает исполняться,
[49:44.000 --> 49:47.000]  работает-работает, доходит до yield, в yield
[49:47.000 --> 49:50.000]  мы говорим switch to, в yield
[49:50.000 --> 49:53.000]  мы выбираем следующий файбер из очереди,
[49:53.000 --> 49:56.000]  некоторый, который где-то хранится,
[49:56.000 --> 49:59.000]  и переключаемся
[49:59.000 --> 50:02.000]  на новый файбер. То есть мы
[50:02.000 --> 50:05.000]  сохраняем регистр процессора в контекст текущего
[50:05.000 --> 50:08.000]  файбера и активируем контекст выбранного из очереди файбер.
[50:08.000 --> 50:11.000]  Но, тем не менее,
[50:11.000 --> 50:14.000]  код написан не совсем так. То есть наш код,
[50:14.000 --> 50:17.000]  когда мы говорим yield,
[50:17.000 --> 50:20.000]  не переключает на самом деле файбер
[50:20.000 --> 50:23.000]  сразу на файбер.
[50:23.000 --> 50:26.000]  Вот мы отсюда прыгаем все-таки не напрямую
[50:26.000 --> 50:29.000]  в этот код, в эту точку. У нас есть некоторые
[50:29.000 --> 50:32.000]  промежуточный вспомогательный хоп.
[50:32.000 --> 50:35.000]  И давайте, чтобы это почувствовать,
[50:35.000 --> 50:38.000]  я задам такой вопрос. Вот есть пример, тут есть
[50:38.000 --> 50:41.000]  три файбера. Стартовый и вот
[50:41.000 --> 50:44.000]  два запущенных из него.
[50:44.000 --> 50:47.000]  Сколько стэков в этом примере?
[50:51.000 --> 50:54.000]  Три. То есть три файбера, три стэка.
[50:54.000 --> 50:57.000]  Маловато. Да.
[50:57.000 --> 51:00.000]  Нет, ну еще есть стэк изначально, на котором main вызывался.
[51:00.000 --> 51:03.000]  Ну вот да, мы создаем файбер, и мы вроде бы
[51:03.000 --> 51:06.000]  уже убедились, что у каждого файбера при создании
[51:06.000 --> 51:09.000]  аллоцируется собственный стэк. У каждого файбера есть
[51:09.000 --> 51:12.000]  совершенно отдельная память,
[51:12.000 --> 51:15.000]  которую процессор использует для навигации по коду.
[51:15.000 --> 51:18.000]  Но ведь есть еще и сама функция main,
[51:18.000 --> 51:21.000]  и она запустилась в некотором потоке, у которого тоже
[51:21.000 --> 51:24.000]  был собственный стэк, который аллоцировали уже не мы,
[51:24.000 --> 51:27.000]  разумеется, а операционная система.
[51:27.000 --> 51:30.000]  Но в конце концов, это тоже стэк.
[51:30.000 --> 51:33.000]  И вот именно на этом стэке вызывается
[51:33.000 --> 51:36.000]  функция runShaddler.
[51:36.000 --> 51:39.000]  И что же она делает?
[51:39.000 --> 51:42.000]  Она разворачивает планировщик, она запускает планировщик.
[51:42.000 --> 51:45.000]  И вот на самом деле у нас на процессоре в этой
[51:45.000 --> 51:48.000]  библиотеке исполняется не только файбер, а сам планировщик.
[51:48.000 --> 51:51.000]  То есть он активный участник исполнения.
[51:51.000 --> 51:54.000]  Он тоже выполняет некоторый код.
[51:54.000 --> 51:57.000]  Что он делает?
[51:57.000 --> 52:00.000]  С чего начинается вообще исполнение
[52:00.000 --> 52:03.000]  функции runShaddler?
[52:03.000 --> 52:06.000]  Мы запускаем файбер.
[52:06.000 --> 52:09.000]  Что это значит?
[52:09.000 --> 52:12.000]  Логически запускаем.
[52:12.000 --> 52:15.000]  Пока конструируем файбер,
[52:15.000 --> 52:18.000]  и помещаем его в очередь ожидания.
[52:18.000 --> 52:21.000]  Вот как было заявлено, в планировщике есть очередь ожидания,
[52:21.000 --> 52:24.000]  и вот она.
[52:24.000 --> 52:27.000]  Это не совсем обычный список, это интрузивный список.
[52:27.000 --> 52:30.000]  К интрузивности мы еще вернемся, причем много раз.
[52:30.000 --> 52:33.000]  Это тоже, пожалуй, тема для семинара.
[52:36.000 --> 52:39.000]  Вот мы сконструировали новый файбер, мы запланировали
[52:39.000 --> 52:42.000]  новый файбер, то есть добавили его в очередь.
[52:42.000 --> 52:45.000]  После чего мы перешли в runLoop.
[52:45.000 --> 52:48.000]  И вот runLoop это функция, которая
[52:48.000 --> 52:51.000]  работает на стеке
[52:51.000 --> 52:54.000]  того потока, который
[52:54.000 --> 52:57.000]  вообще вызвал runShaddler.
[52:57.000 --> 53:00.000]  Вот эта функция,
[53:00.000 --> 53:03.000]  мы же ее вызываем на стеке мейна,
[53:03.000 --> 53:06.000]  и она исполняется, не завершается
[53:06.000 --> 53:09.000]  до тех пор, пока внутри планировщика остаются
[53:09.000 --> 53:12.000]  готовые исполняться файберы.
[53:12.000 --> 53:15.000]  И вот эта функция
[53:15.000 --> 53:18.000]  не завершается именно в вызове runLoop.
[53:18.000 --> 53:21.000]  Вот мы здесь, в этом цикле, крутимся,
[53:21.000 --> 53:24.000]  и на каждой итерации, пока очередь не пуста,
[53:24.000 --> 53:27.000]  выбираем из этой очереди очередной файбер,
[53:27.000 --> 53:30.000]  и переключаемся на него.
[53:30.000 --> 53:33.000]  Что значит переключаемся?
[53:33.000 --> 53:36.000]  Ну это означает, что мы
[53:36.000 --> 53:39.000]  запоминаем, что сейчас исполняется
[53:39.000 --> 53:42.000]  вот такой вот файбер.
[53:42.000 --> 53:45.000]  Для этого есть поле current, а вы простите running.
[53:48.000 --> 53:51.000]  Мы меняем состояние
[53:51.000 --> 53:54.000]  выбранного файбера на running с runnable
[53:54.000 --> 53:57.000]  и вызываем метод switchToFiber.
[53:57.000 --> 54:00.000]  Который что делает?
[54:00.000 --> 54:03.000]  Видим. Сохраняет состояние
[54:03.000 --> 54:06.000]  процессора, который сейчас
[54:06.000 --> 54:09.000]  выполняет функцию runLoop
[54:09.000 --> 54:12.000]  в поле loop.context
[54:12.000 --> 54:15.000]  планировщика.
[54:15.000 --> 54:18.000]  То есть у него тоже есть контекст исполнения,
[54:18.000 --> 54:21.000]  потому что он тоже исполняется, и с него тоже переключаются.
[54:21.000 --> 54:24.000]  И активирует
[54:24.000 --> 54:27.000]  на процессоре контекст исполнения,
[54:27.000 --> 54:30.000]  то есть регистры, которые
[54:30.000 --> 54:33.000]  задают исполнение файбера.
[54:33.000 --> 54:36.000]  Итого, у нас в примере
[54:36.000 --> 54:39.000]  в этом четыре активных сущности.
[54:39.000 --> 54:42.000]  Это три файбера и один планировщик.
[54:42.000 --> 54:45.000]  И у каждого из них есть свой собственный контекст исполнения.
[54:45.000 --> 54:48.000]  И вот прыжки между этими объектами
[54:48.000 --> 54:51.000]  происходят, смотрите, в каком стиле.
[54:51.000 --> 54:54.000]  Все начинается, конечно, с планировщика,
[54:54.000 --> 54:57.000]  вот мы его стартуем, он выбирает первый файбер,
[54:57.000 --> 55:00.000]  переключается на него, файбер работает, работает, работает,
[55:00.000 --> 55:03.000]  переключается обратно в планировщик,
[55:03.000 --> 55:06.000]  ну и вот исполнение бежит так по цепочке.
[55:06.000 --> 55:09.000]  Это лучше показать, вот я сейчас попробую
[55:09.000 --> 55:12.000]  это сделать следующим образом.
[55:13.000 --> 55:16.000]  Вот у нас есть программа,
[55:16.000 --> 55:19.000]  вот мы в ней
[55:19.000 --> 55:22.000]  вызываем, например, здесь
[55:22.000 --> 55:25.000]  Yield
[55:25.000 --> 55:28.000]  и
[55:28.000 --> 55:31.000]  ну то есть что происходит при запуске
[55:31.000 --> 55:34.000]  планировщика я показал, а вот теперь
[55:34.000 --> 55:37.000]  я хочу показать то же самое со стороны
[55:37.000 --> 55:40.000]  файбера. Вот файбер работает,
[55:40.000 --> 55:43.000]  вызывает Yield, и это же обращение
[55:43.000 --> 55:46.000]  к планировщику, это некоторый системный вызов, да?
[55:46.000 --> 55:49.000]  Ну а чтобы сделать системный вызов,
[55:49.000 --> 55:52.000]  нужно как-то адресовать текущий планировщик, как вообще его найти.
[55:52.000 --> 55:55.000]  Но для этого
[55:55.000 --> 55:58.000]  у нас есть функция GetCurrentShadower
[55:58.000 --> 56:01.000]  и она реализована очень просто. У нас есть просто глобальная
[56:01.000 --> 56:04.000]  переменная Shadower звездочка, которая указывает
[56:04.000 --> 56:07.000]  на текущий планировщик,
[56:07.000 --> 56:10.000]  в котором мы исполняемся, это такой способ его
[56:10.000 --> 56:13.000]  найти в программе.
[56:13.000 --> 56:16.000]  И вот мы уже на этом планировщике
[56:16.000 --> 56:19.000]  вызываем метод Yield.
[56:19.000 --> 56:22.000]  Вот планировщик, у него есть
[56:22.000 --> 56:25.000]  системные вызовы, которые можно исполнять из
[56:25.000 --> 56:28.000]  файберов. Пока мы говорим только про
[56:28.000 --> 56:31.000]  Spawn и про Yield, но есть еще
[56:31.000 --> 56:34.000]  SlipForer, это отдельная история, есть SuspendResume
[56:34.000 --> 56:37.000]  для реализации приметива синхронизации
[56:37.000 --> 56:40.000]  и есть Terminate, до которого речь еще дойдет сегодня.
[56:40.000 --> 56:43.000]  Вот мы вызываем Yield.
[56:43.000 --> 56:46.000]  И что происходит? Смотрите.
[56:49.000 --> 56:52.000]  На планировщике вызвали метод Yield,
[56:52.000 --> 56:55.000]  вызвали из файбера. Что делает планировщик?
[56:55.000 --> 56:58.000]  Он находит файбер, который к нему обратился.
[56:58.000 --> 57:01.000]  Как? Ну просто смотрит на поле
[57:01.000 --> 57:04.000]  и в ранг.
[57:04.000 --> 57:07.000]  Давайте мы сделаем
[57:09.000 --> 57:12.000]  вот что.
[57:12.000 --> 57:15.000]  Так, это будет немного сложнее,
[57:15.000 --> 57:18.000]  чем я думал.
[57:20.000 --> 57:23.000]  Итак, вот у нас, смотрите,
[57:23.000 --> 57:26.000]  у нас есть сейчас такая раздвойная картинка.
[57:26.000 --> 57:29.000]  А здесь у нас есть
[57:29.000 --> 57:32.000]  вот такая картинка,
[57:32.000 --> 57:35.000]  вот эта картинка,
[57:35.000 --> 57:38.000]  вот эта картинка,
[57:38.000 --> 57:41.000]  вот эта картинка,
[57:41.000 --> 57:44.000]  слева,
[57:45.000 --> 57:48.000]  слева,
[57:52.000 --> 57:55.000]  нам потребуется некоторый сетап.
[57:58.000 --> 58:01.000]  Картинка разделена на две части,
[58:01.000 --> 58:04.000]  слева будет файбер,
[58:04.000 --> 58:07.000]  справа будет планировщик.
[58:07.000 --> 58:10.000]  Ну в смысле, что значит файбер-планировщик?
[58:10.000 --> 58:13.000]  И планировщик это отдельные исполнения,
[58:13.000 --> 58:16.000]  у которых есть свои собственные стеки.
[58:16.000 --> 58:19.000]  И вот то, что происходит на стеке файбера,
[58:19.000 --> 58:22.000]  я буду показывать слева. То, что происходит на стеке
[58:22.000 --> 58:25.000]  планировщика, я буду показывать справа.
[58:25.000 --> 58:28.000]  И вот мы говорили, с чего начинает работа планировщика.
[58:31.000 --> 58:34.000]  Так, простите.
[58:34.000 --> 58:37.000]  Он исполняет процедуру run loop.
[58:37.000 --> 58:40.000]  Он выбрал очередной файбер
[58:40.000 --> 58:43.000]  и запускает его.
[58:43.000 --> 58:46.000]  То есть запоминает, вот кто сейчас running.
[58:46.000 --> 58:49.000]  И когда этот файбер
[58:49.000 --> 58:52.000]  запущенный вызывает yield,
[58:55.000 --> 58:58.000]  то в планировщике
[58:58.000 --> 59:01.000]  этот yield с помощью функции
[59:01.000 --> 59:04.000]  getCurrentFiber через установленное
[59:04.000 --> 59:07.000]  вот здесь поле running находит этот текущий файбер,
[59:07.000 --> 59:10.000]  меняет его состояние обратно на runnable,
[59:10.000 --> 59:13.000]  после чего
[59:13.000 --> 59:16.000]  выполняет переключение контекста
[59:16.000 --> 59:19.000]  в обратную сторону.
[59:19.000 --> 59:22.000]  То есть мы
[59:22.000 --> 59:25.000]  сохраняем регистры
[59:25.000 --> 59:28.000]  процессора в контекст
[59:28.000 --> 59:31.000]  исполнения файбера и активируем
[59:31.000 --> 59:34.000]  loop.context.
[59:34.000 --> 59:37.000]  Почему он инициализирован?
[59:37.000 --> 59:40.000]  Потому что ранее вот здесь вот,
[59:40.000 --> 59:43.000]  когда мы запускали файбер,
[59:43.000 --> 59:46.000]  мы в этот loop.context
[59:46.000 --> 59:49.000]  сохранили регистры процессора
[59:49.000 --> 59:52.000]  для основного стека, для основного потока программы.
[59:52.000 --> 59:55.000]  Вот мы его здесь сохранили,
[59:55.000 --> 59:58.000]  а теперь мы в него готовы вернуться.
[01:00:02.000 --> 01:00:05.000]  И вот именно этот switch2 это и есть
[01:00:05.000 --> 01:00:08.000]  магия, потому что мы вот здесь
[01:00:08.000 --> 01:00:11.000]  вызываем switch2,
[01:00:11.000 --> 01:00:14.000]  лучше даже здесь, вызываем этот switch2,
[01:00:14.000 --> 01:00:17.000]  а выходим из этого switch2, в который мы зашли ранее.
[01:00:19.000 --> 01:00:22.000]  И вот именно эта функция,
[01:00:22.000 --> 01:00:25.000]  switch2 это вот та самая функция,
[01:00:25.000 --> 01:00:28.000]  в которую мы заходим один раз и выходим дважды в конце концов.
[01:00:29.000 --> 01:00:32.000]  Скажите, это понятно?
[01:00:32.000 --> 01:00:35.000]  Да.
[01:00:35.000 --> 01:00:38.000]  Ну, если все понятно, то здорово.
[01:00:38.000 --> 01:00:41.000]  Тогда что нам осталось
[01:00:41.000 --> 01:00:44.000]  обсудить?
[01:00:44.000 --> 01:00:47.000]  Ну, наверное, нам нужно договорить, что происходит,
[01:00:47.000 --> 01:00:50.000]  когда мы возвращаемся в планировщик.
[01:00:50.000 --> 01:00:53.000]  Вот мы вызвали switch2.shadower,
[01:00:53.000 --> 01:00:56.000]  активировали контекст планировщика, вернулись в него,
[01:00:56.000 --> 01:00:59.000]  вернулись из этой функции switch2Fiber,
[01:00:59.000 --> 01:01:02.000]  сбросили runningFiber,
[01:01:02.000 --> 01:01:05.000]  функция вызовStep завершился.
[01:01:05.000 --> 01:01:08.000]  Ну, то есть, мы запустили Fiber,
[01:01:08.000 --> 01:01:11.000]  он поисполнялся, а потом почему-то решил остановиться.
[01:01:11.000 --> 01:01:14.000]  Почему он решил остановиться?
[01:01:14.000 --> 01:01:17.000]  Ну, возможно, он вызвал yield.
[01:01:17.000 --> 01:01:20.000]  Вот для того, чтобы разобраться, почему Fiber остановился,
[01:01:20.000 --> 01:01:23.000]  у нас есть функция dispatch.
[01:01:23.000 --> 01:01:26.000]  Потому что он сделал какой-то системный вызов в конце концов,
[01:01:26.000 --> 01:01:29.000]  аналогия. И вот этот системный вызов
[01:01:29.000 --> 01:01:32.000]  вырабатывается в методе dispatch.
[01:01:32.000 --> 01:01:35.000]  Это может быть не совсем не то, что неаккуратно
[01:01:35.000 --> 01:01:38.000]  написанный код. Возможно, его нужно написать иначе.
[01:01:38.000 --> 01:01:41.000]  Я знаю, написать гораздо лучше,
[01:01:41.000 --> 01:01:44.000]  но я вам пока не рассказываю, вы должны
[01:01:44.000 --> 01:01:47.000]  это сами придумать в какой-то довольно поздней
[01:01:47.000 --> 01:01:50.000]  домашней работе. Но в этом коде
[01:01:50.000 --> 01:01:53.000]  начализация Fiber'а происходит по его состоянию.
[01:01:53.000 --> 01:01:56.000]  Вот если Fiber вернулся в состояние runnable,
[01:01:56.000 --> 01:01:59.000]  а так был устроен yield,
[01:01:59.000 --> 01:02:02.000]  он менял состояние Fiber'а на runnable.
[01:02:02.000 --> 01:02:05.000]  Вот здесь вот.
[01:02:05.000 --> 01:02:08.000]  То планировщик понимает, что Fiber
[01:02:08.000 --> 01:02:11.000]  сделал yield и просто его перепланирует.
[01:02:11.000 --> 01:02:14.000]  То есть, снова добавляет в конец очереди.
[01:02:14.000 --> 01:02:17.000]  И вот, смотрите, вот семантика метода yield.
[01:02:17.000 --> 01:02:20.000]  Мы сейчас ее в коде увидели просто, как она реализуется.
[01:02:20.000 --> 01:02:23.000]  Мы находим планировщик.
[01:02:23.000 --> 01:02:26.000]  Сейчас мы
[01:02:26.000 --> 01:02:29.000]  находим планировщик, вызываем на нем yield.
[01:02:29.000 --> 01:02:32.000]  Прыгаем в него.
[01:02:32.000 --> 01:02:35.000]  Возвращаемся
[01:02:35.000 --> 01:02:38.000]  из метода switchTo в методе switchToFiber,
[01:02:38.000 --> 01:02:41.000]  который был вызван из степа.
[01:02:41.000 --> 01:02:44.000]  И помещаем
[01:02:44.000 --> 01:02:47.000]  себя в конец rankU.
[01:02:47.000 --> 01:02:50.000]  После чего планировщик
[01:02:50.000 --> 01:02:53.000]  переходит на очередную итерацию циклопланирования,
[01:02:53.000 --> 01:02:56.000]  выбирает себе очередной Fiber и запускает его.
[01:02:59.000 --> 01:03:02.000]  Ну вот, почти все понятно.
[01:03:02.000 --> 01:03:05.000]  Осталось только разобрать, как, собственно, работает
[01:03:05.000 --> 01:03:08.000]  самый непонятный компонент, а именно вызов switchTo.
[01:03:08.000 --> 01:03:11.000]  Скажите, а во сколько мы заканчиваем?
[01:03:11.000 --> 01:03:14.000]  Сколько у нас времени осталось?
[01:03:14.000 --> 01:03:17.000]  15 минут.
[01:03:17.000 --> 01:03:20.000]  Ну, вроде по плану все.
[01:03:20.000 --> 01:03:23.000]  Итак, если мы понимаем
[01:03:23.000 --> 01:03:26.000]  все остальное, кроме execution-контекста,
[01:03:26.000 --> 01:03:29.000]  как он устроен, то давайте подумаем,
[01:03:29.000 --> 01:03:32.000]  как этот execution-контекст написать.
[01:03:32.000 --> 01:03:35.000]  Это, может, такое, наверное, глупое предположение,
[01:03:35.000 --> 01:03:38.000]  но это разве не решается просто
[01:03:38.000 --> 01:03:41.000]  несколькими вызовами атомарного экщенжа.
[01:03:41.000 --> 01:03:44.000]  Ну, причем здесь вообще атомарные инструкции?
[01:03:44.000 --> 01:03:47.000]  Атомарная сна вообще не нужна,
[01:03:47.000 --> 01:03:50.000]  она просто сделает слаб всех регистров, которые нужны.
[01:03:50.000 --> 01:03:53.000]  Ну, так процессоры
[01:03:53.000 --> 01:03:56.000]  все же не работают.
[01:03:56.000 --> 01:03:59.000]  Давай я расскажу лучше.
[01:03:59.000 --> 01:04:02.000]  Звучит действительно просто сохранить регистр, активировать регистр,
[01:04:02.000 --> 01:04:05.000]  но тут есть нюансы, и из-за нюансов появляется что-то.
[01:04:05.000 --> 01:04:08.000]  Ну, это сложно,
[01:04:08.000 --> 01:04:11.000]  но тут аккуратность требуется в рассказе.
[01:04:11.000 --> 01:04:14.000]  Итак, если мы понимаем,
[01:04:14.000 --> 01:04:17.000]  как файберы и планировщик
[01:04:17.000 --> 01:04:20.000]  взаимодействуют между собой,
[01:04:20.000 --> 01:04:23.000]  как организовано взаимодействие в этих ролях,
[01:04:23.000 --> 01:04:26.000]  как они используют класс execution-контекст,
[01:04:26.000 --> 01:04:29.000]  то, кажется, с файбером это мы закончили.
[01:04:29.000 --> 01:04:32.000]  И теперь нужно вернуться на уровень исполнения
[01:04:32.000 --> 01:04:35.000]  теста, как устроен Switch2.
[01:04:41.000 --> 01:04:44.000]  Давайте заметим, что
[01:04:44.000 --> 01:04:47.000]  вот здесь, при реализации этого самого Switch2,
[01:04:47.000 --> 01:04:50.000]  мы воспользуемся тем фактом, что у нас все-таки файберы
[01:04:50.000 --> 01:04:53.000]  это не потоки, в том смысле, что файберы у нас
[01:04:53.000 --> 01:04:56.000]  кооперативные, что в них нет механизма
[01:04:56.000 --> 01:04:59.000]  вытеснения.
[01:04:59.000 --> 01:05:02.000]  Если вы запускаете несколько потоков на ядрах
[01:05:02.000 --> 01:05:05.000]  процессора, то вы можете ожидать, что между
[01:05:05.000 --> 01:05:08.000]  любыми двумя инструкциями в ассембле
[01:05:08.000 --> 01:05:11.000]  у вас произойдет вытеснение,
[01:05:11.000 --> 01:05:14.000]  то есть, прилетит прерывание по таймеру, допустим,
[01:05:14.000 --> 01:05:17.000]  и процессор переключится на исполнение кода
[01:05:17.000 --> 01:05:20.000]  ядра операционной системы. Там запустит планировщик,
[01:05:20.000 --> 01:05:23.000]  ну и вот что-то там случится.
[01:05:23.000 --> 01:05:26.000]  Ну, в общем, вы этого можете ожидать абсолютно в любом месте,
[01:05:26.000 --> 01:05:29.000]  с любыми двумя инструкциями.
[01:05:29.000 --> 01:05:32.000]  И, конечно же, процессор должен учитывать,
[01:05:32.000 --> 01:05:35.000]  что он прервал исполнение вашего кода
[01:05:35.000 --> 01:05:38.000]  в совершенно произвольном месте.
[01:05:38.000 --> 01:05:41.000]  И он должен помочь этому коду потом обратно
[01:05:41.000 --> 01:05:44.000]  на процессоре восстановиться.
[01:05:44.000 --> 01:05:47.000]  Поэтому, когда в процессоре происходит прерывание,
[01:05:47.000 --> 01:05:50.000]  то он, конечно же, сохраняет буквально
[01:05:50.000 --> 01:05:53.000]  все регистры, которые там есть,
[01:05:53.000 --> 01:05:56.000]  которые программа могла пользоваться.
[01:05:56.000 --> 01:05:59.000]  Потому что программа не могла к этому подготовиться,
[01:05:59.000 --> 01:06:02.000]  она этого вообще всего не наблюдает.
[01:06:02.000 --> 01:06:05.000]  Компилиатор же не думает, что вот произойдет
[01:06:05.000 --> 01:06:08.000]  переключение контекста сейчас.
[01:06:08.000 --> 01:06:11.000]  В нашей ситуации, в случае файберов,
[01:06:11.000 --> 01:06:14.000]  все будет гораздо проще, потому что наши файберы кооперативные,
[01:06:14.000 --> 01:06:17.000]  они не могут вытесняться, они переключаются
[01:06:17.000 --> 01:06:20.000]  только в строго определенных местах,
[01:06:20.000 --> 01:06:23.000]  а не явно, вызывая свечту.
[01:06:23.000 --> 01:06:26.000]  Вот это единственная точка переключения.
[01:06:26.000 --> 01:06:29.000]  Она всегда явная и добровольная.
[01:06:29.000 --> 01:06:32.000]  И мы собираемся этим фактом воспользоваться.
[01:06:32.000 --> 01:06:35.000]  Мы не собираемся сохранять в свечту
[01:06:35.000 --> 01:06:38.000]  вообще все регистры.
[01:06:38.000 --> 01:06:41.000]  И тут можно вернуться к примеру, который был в годболте.
[01:06:41.000 --> 01:06:44.000]  Вот у вас есть функция foo,
[01:06:44.000 --> 01:06:47.000]  которая вызывает функцию bar.
[01:06:47.000 --> 01:06:50.000]  Она по себе может быть сложно устроена,
[01:06:50.000 --> 01:06:53.000]  она там может алоцировать что-то на стэке, какие-то вычисления,
[01:06:53.000 --> 01:06:56.000]  производить... Компилиатор разложит эти вычисления
[01:06:56.000 --> 01:06:59.000]  при регистрам, а потом мы вызываем функцию bar.
[01:06:59.000 --> 01:07:02.000]  А функция bar вообще может быть частью библиотеки
[01:07:02.000 --> 01:07:05.000]  и скомпилирована быть отдельно.
[01:07:05.000 --> 01:07:08.000]  И компилируя foo, компилиратор ничего не знает
[01:07:08.000 --> 01:07:11.000]  про устройство bar, и компилиратор компилируя bar
[01:07:11.000 --> 01:07:14.000]  ничего не знает про то, что эту функцию будет
[01:07:14.000 --> 01:07:17.000]  и функция bar, если так наивно рассуждать очень,
[01:07:17.000 --> 01:07:20.000]  могла бы взять и перезаписать,
[01:07:20.000 --> 01:07:23.000]  переиспользовать все регистры, на которые полагалось foo,
[01:07:23.000 --> 01:07:26.000]  и когда мы вернемся в вызов foo, то
[01:07:26.000 --> 01:07:29.000]  состояние нашей функции
[01:07:29.000 --> 01:07:32.000]  будет разрушено.
[01:07:32.000 --> 01:07:35.000]  Вот, конечно же, такого не происходит.
[01:07:35.000 --> 01:07:38.000]  Если мы вызываем одну функцию
[01:07:38.000 --> 01:07:41.000]  из другой и мы компилируем их независимо,
[01:07:41.000 --> 01:07:44.000]  то мы должны, мы хотим ожидать, что
[01:07:44.000 --> 01:07:47.000]  после завершения функции bar все-таки регистры
[01:07:47.000 --> 01:07:50.000]  процессора окажутся в каком-то предсказуемом
[01:07:50.000 --> 01:07:53.000]  состоянии. И вот
[01:07:53.000 --> 01:07:56.000]  эти ожидания зафиксированы в документе,
[01:07:56.000 --> 01:07:59.000]  который называется Scrolling Conventions, соглашение о вызове.
[01:07:59.000 --> 01:08:02.000]  И что нам из них сейчас интересно?
[01:08:02.000 --> 01:08:05.000]  Интересно то, что, разумеется, функция
[01:08:05.000 --> 01:08:08.000]  foo вызвана, функция bar вызвана из
[01:08:08.000 --> 01:08:11.000]  функции foo может использовать какие-то регистры,
[01:08:11.000 --> 01:08:14.000]  может их переиспользовать, перезаписать.
[01:08:14.000 --> 01:08:17.000]  Но соглашение
[01:08:17.000 --> 01:08:20.000]  о вызовах регламентирует, что
[01:08:20.000 --> 01:08:23.000]  часть регистров, функция bar
[01:08:23.000 --> 01:08:26.000]  после своего завершения обязана
[01:08:26.000 --> 01:08:29.000]  вернуть в исходное состояние,
[01:08:29.000 --> 01:08:32.000]  которое эти регистры имели до вызова.
[01:08:32.000 --> 01:08:35.000]  То есть либо не трогать их вообще, либо
[01:08:35.000 --> 01:08:38.000]  хранить на стэк, а потом обратно намазать
[01:08:38.000 --> 01:08:41.000]  на процессор. Эти регистры называются
[01:08:41.000 --> 01:08:44.000]  call-saved-регистры.
[01:08:44.000 --> 01:08:47.000]  Разумеется, соглашение о вызовах
[01:08:47.000 --> 01:08:50.000]  и call-saved-регистры,
[01:08:50.000 --> 01:08:53.000]  конкретное соглашение о вызовах,
[01:08:53.000 --> 01:08:56.000]  все это фиксировано для
[01:08:56.000 --> 01:08:59.000]  конкретной операционной системы, для конкретного
[01:08:59.000 --> 01:09:02.000]  процессора. Но вот мы все-таки говорим
[01:09:02.000 --> 01:09:05.000]  не про библиотеку, которая будет работать
[01:09:05.000 --> 01:09:08.000]  на любой операционной системе, на любом процессоре, мы говорим
[01:09:08.000 --> 01:09:11.000]  про нашу конкретную библиотеку, которая должна работать на
[01:09:11.000 --> 01:09:14.000]  линуксе и на процессоре с
[01:09:14.000 --> 01:09:17.000]  архитектурой x86a4, поэтому мы
[01:09:17.000 --> 01:09:20.000]  используем конкретно вот эти соглашения
[01:09:20.000 --> 01:09:23.000]  о вызовах. Они говорят, что после вызова
[01:09:23.000 --> 01:09:26.000]  функция bar обязана сохранить регистры r12, r15,
[01:09:26.000 --> 01:09:29.000]  rsp, rbp, rbx.
[01:09:29.000 --> 01:09:32.000]  Это касается
[01:09:32.000 --> 01:09:35.000]  просто вызова функций.
[01:09:35.000 --> 01:09:38.000]  Вот, ну и компилятор же, он когда компилирует
[01:09:38.000 --> 01:09:41.000]  этот вызов функций, он мало что, то есть он не знает,
[01:09:41.000 --> 01:09:44.000]  что эта функция сделает что-то магическое.
[01:09:44.000 --> 01:09:47.000]  Но он ожидает, что после
[01:09:47.000 --> 01:09:50.000]  вызова функции switch2-fiber,
[01:09:50.000 --> 01:09:53.000]  там switch2,
[01:09:53.000 --> 01:09:56.000]  вот эти регистры,
[01:09:56.000 --> 01:09:59.000]  вот эти регистры перечисленные
[01:09:59.000 --> 01:10:02.000]  должны находиться в неизменном,
[01:10:02.000 --> 01:10:05.000]  в исходном состоянии, которое они имели до вызова.
[01:10:05.000 --> 01:10:08.000]  Вот на этот вариант
[01:10:08.000 --> 01:10:11.000]  будет полагаться компилятор, когда он будет компилировать
[01:10:11.000 --> 01:10:14.000]  вот метод step, метод switch2-fiber.
[01:10:14.000 --> 01:10:17.000]  Понимаете меня, да?
[01:10:17.000 --> 01:10:20.000]  Так что мы должны сохранить
[01:10:20.000 --> 01:10:23.000]  только перечисленный набор регистров.
[01:10:24.000 --> 01:10:27.000]  Вот мы их сохраняем, после чего
[01:10:27.000 --> 01:10:30.000]  мы трогаем rip, instruction pointer
[01:10:30.000 --> 01:10:33.000]  и перемещаемся в другую точку программы.
[01:10:35.000 --> 01:10:38.000]  Но,
[01:10:38.000 --> 01:10:41.000]  смотрите, очевидное замечание,
[01:10:41.000 --> 01:10:44.000]  написать такой код на C++ невозможно, потому что мы
[01:10:44.000 --> 01:10:47.000]  манипулируем регистрами процессора, в C++ мы не умеем
[01:10:47.000 --> 01:10:50.000]  манипулировать регистрами процессора.
[01:10:50.000 --> 01:10:53.000]  То есть реализация switch2 будет ассемблерная.
[01:10:53.000 --> 01:10:56.000]  Кроме того, вторая сложность.
[01:10:56.000 --> 01:10:59.000]  Вот действительно мы можем
[01:10:59.000 --> 01:11:02.000]  сохранить регистры с процессоров памяти,
[01:11:02.000 --> 01:11:05.000]  просто скопировать их, а потом намазать другие регистры.
[01:11:05.000 --> 01:11:08.000]  Но так мы можем сделать
[01:11:08.000 --> 01:11:11.000]  почти со всеми, кроме rip.
[01:11:11.000 --> 01:11:14.000]  Вот с rip мы трогать напрямую не можем.
[01:11:14.000 --> 01:11:17.000]  Но когда я показывал вам
[01:11:17.000 --> 01:11:20.000]  вот здесь вот код,
[01:11:20.000 --> 01:11:23.000]  то я говорил, кто трогает rip.
[01:11:23.000 --> 01:11:26.000]  Вот инструкция red, она трогает rip.
[01:11:26.000 --> 01:11:29.000]  Она снимает
[01:11:29.000 --> 01:11:32.000]  с вершины стека адрес, записывает
[01:11:32.000 --> 01:11:35.000]  его в регистр rip и
[01:11:35.000 --> 01:11:38.000]  вот процессор прыгает
[01:11:38.000 --> 01:11:41.000]  по этому адресу. Вот это тот способ, которым
[01:11:41.000 --> 01:11:44.000]  мы можем регистром rip instruction pointer манипулировать.
[01:11:44.000 --> 01:11:47.000]  Итого, значит, мы
[01:11:47.000 --> 01:11:50.000]  пользуемся тем фактом, что у нас
[01:11:50.000 --> 01:11:53.000]  файберы кооперативные, что они переключаются только добровольно.
[01:11:53.000 --> 01:11:56.000]  Поэтому мы здесь должны позаботиться только
[01:11:56.000 --> 01:11:59.000]  о части регистров, о call и save регистрах,
[01:11:59.000 --> 01:12:02.000]  которые зафиксированы в соглашении о вызовах.
[01:12:02.000 --> 01:12:05.000]  И вот второе наблюдение, что мы должны как-то
[01:12:05.000 --> 01:12:08.000]  аккуратнее быть с rip.
[01:12:08.000 --> 01:12:11.000]  Не то, что аккуратно, некорректно говорю, что мы должны как-то
[01:12:11.000 --> 01:12:14.000]  по-особенному его поменять.
[01:12:14.000 --> 01:12:17.000]  Ну и давайте посмотрим, наконец, как это
[01:12:17.000 --> 01:12:20.000]  реализовано. Вот я показывал вам класс execution
[01:12:20.000 --> 01:12:23.000]  context. Он на самом деле не так-то прост, потому что
[01:12:23.000 --> 01:12:26.000]  execution context это не только регистр процессора, это еще
[01:12:26.000 --> 01:12:29.000]  состояние санитайзера, это еще состояние механизма
[01:12:29.000 --> 01:12:32.000]  исключений, но под капотом
[01:12:32.000 --> 01:12:35.000]  контекст процессора, он в библиотеке
[01:12:35.000 --> 01:12:38.000]  называется машинный контекст, у него есть такой же
[01:12:38.000 --> 01:12:41.000]  свечту, и вот на этот свечту мы сейчас
[01:12:41.000 --> 01:12:44.000]  и посмотрим.
[01:12:44.000 --> 01:12:47.000]  Это assembler-ная функция.
[01:12:50.000 --> 01:12:53.000]  И давайте даже я не ее буду показывать,
[01:12:53.000 --> 01:12:56.000]  а сначала покажу картинку,
[01:12:56.000 --> 01:12:59.000]  о том, как она работает, а потом мы переместимся
[01:12:59.000 --> 01:13:02.000]  в assembler-ный код.
[01:13:03.000 --> 01:13:06.000]  Итак, мы хотим написать функцию
[01:13:06.000 --> 01:13:09.000]  переключения контекстов, и у нас есть два аргумента,
[01:13:09.000 --> 01:13:12.000]  контекст, в который мы должны сохранить состояние процессора
[01:13:12.000 --> 01:13:15.000]  и контекст, который мы хотим активировать.
[01:13:17.000 --> 01:13:20.000]  Вопрос, куда мы сохраним
[01:13:20.000 --> 01:13:23.000]  регистр процессора?
[01:13:23.000 --> 01:13:26.000]  В какую память? Но можно подумать, что прямо
[01:13:26.000 --> 01:13:29.000]  в объект контекста. На самом деле нет.
[01:13:29.000 --> 01:13:32.000]  Регистр процессора, который нам нужно сохранить, вот эти call и save
[01:13:32.000 --> 01:13:35.000]  регистры, мы сохраним в память,
[01:13:35.000 --> 01:13:38.000]  который точно можно безопасно пользоваться,
[01:13:38.000 --> 01:13:41.000]  с которой никто не будет работать.
[01:13:41.000 --> 01:13:44.000]  Нет, stack.
[01:13:44.000 --> 01:13:47.000]  Вот мы уходим со стека.
[01:13:47.000 --> 01:13:50.000]  Мы планировщик, переключаемся в файбер.
[01:13:50.000 --> 01:13:53.000]  Мы планировщик, исполнялись на стеке операционной системы.
[01:13:53.000 --> 01:13:56.000]  Мы переключаемся на исполнение кода
[01:13:56.000 --> 01:13:59.000]  файбера на его стеке.
[01:13:59.000 --> 01:14:02.000]  Так что стек планировщика,
[01:14:02.000 --> 01:14:05.000]  стек, простите, стек планировщика, стек потока,
[01:14:05.000 --> 01:14:08.000]  на котором была вызвана функция runsheduler,
[01:14:08.000 --> 01:14:11.000]  использоваться не будет, пока мы в планировщик не вернемся.
[01:14:11.000 --> 01:14:14.000]  Поэтому мы сохраняем все вот эти
[01:14:14.000 --> 01:14:17.000]  call и save регистры прямо на стек потока,
[01:14:17.000 --> 01:14:20.000]  с которого мы уходим.
[01:14:20.000 --> 01:14:23.000]  Но вообще, чтобы попасть
[01:14:23.000 --> 01:14:26.000]  в эту процедуру switch-машин-контекст,
[01:14:26.000 --> 01:14:29.000]  мы же должны ее вызвать.
[01:14:29.000 --> 01:14:32.000]  Так что ее исполнение начинается с инструкции call.
[01:14:32.000 --> 01:14:35.000]  А инструкция call по своей семантике сама сохраняет
[01:14:35.000 --> 01:14:38.000]  следующую за инструкции call адрес,
[01:14:38.000 --> 01:14:41.000]  следующий за инструкции call инструкции, простите,
[01:14:41.000 --> 01:14:44.000]  на вершину стека.
[01:14:44.000 --> 01:14:47.000]  То есть когда мы вызываем эту процедуру первым шагом,
[01:14:47.000 --> 01:14:50.000]  при ее вызове, собственно, при исполнении инструкции call,
[01:14:50.000 --> 01:14:53.000]  и очередная инструкция после call сохраняется на стек.
[01:14:58.000 --> 01:15:01.000]  То есть это произошло неявно при вызове этой функции.
[01:15:01.000 --> 01:15:04.000]  После этого у нас есть стадия,
[01:15:04.000 --> 01:15:07.000]  когда мы сохраняем,
[01:15:07.000 --> 01:15:10.000]  аккуратно скажу,
[01:15:10.000 --> 01:15:13.000]  в процедуре переключения контекста два больших шага,
[01:15:13.000 --> 01:15:16.000]  мы сохраняем состояние текущего исполнения,
[01:15:16.000 --> 01:15:19.000]  это стадия save, и мы активируем
[01:15:19.000 --> 01:15:22.000]  следующего очередного исполнения, шаг activate.
[01:15:22.000 --> 01:15:25.000]  Вот save, первый шаг,
[01:15:25.000 --> 01:15:28.000]  половина save, это сам вызов функции.
[01:15:28.000 --> 01:15:31.000]  Вот на этом шаге мы уже кое-что сохранили на стек.
[01:15:31.000 --> 01:15:34.000]  Адрес возврата.
[01:15:34.000 --> 01:15:37.000]  После этого мы пушим на стек те регистры,
[01:15:37.000 --> 01:15:40.000]  которые мы хотели сохранить,
[01:15:40.000 --> 01:15:43.000]  call и save три регистры, r12, r15, rbp, rbx, rsp.
[01:15:43.000 --> 01:15:46.000]  Ну rsp мы не пушим.
[01:15:46.000 --> 01:15:49.000]  С rsp у нас отдельная история.
[01:15:49.000 --> 01:15:52.000]  Вот мы запушили вот эти все регистры,
[01:15:52.000 --> 01:15:55.000]  кроме rsp, а дальше
[01:15:55.000 --> 01:15:58.000]  мы хотим переключить исполнение.
[01:15:58.000 --> 01:16:01.000]  И вот ключевой момент для переключения
[01:16:01.000 --> 01:16:04.000]  стеков.
[01:16:04.000 --> 01:16:07.000]  Мы делаем два мува. Мы сохраняем текущий rsp
[01:16:07.000 --> 01:16:10.000]  в поле контекст.
[01:16:10.000 --> 01:16:13.000]  Вот машинный контекст, сама структура,
[01:16:13.000 --> 01:16:16.000]  в ней только одно поле, это rsp.
[01:16:16.000 --> 01:16:19.000]  Вот достаточно его запомнить, чтобы
[01:16:19.000 --> 01:16:22.000]  восстановить все остальные регистры, потому что
[01:16:22.000 --> 01:16:25.000]  по этому поентру находятся совершенно стековызвы,
[01:16:25.000 --> 01:16:28.000]  в котором сейчас свалены все остальные регистры,
[01:16:28.000 --> 01:16:31.000]  которые нам нужно было сохранить.
[01:16:31.000 --> 01:16:34.000]  Итого, первый шаг, это call сохранения rip,
[01:16:34.000 --> 01:16:37.000]  потом шаги пуши сохранения call и save три регистров,
[01:16:37.000 --> 01:16:40.000]  кроме rsp, а потом мы просто
[01:16:40.000 --> 01:16:43.000]  сохраняем rsp в поле контекст,
[01:16:43.000 --> 01:16:46.000]  ну то есть, по сути, мы сохраняем его
[01:16:46.000 --> 01:16:49.000]  в поле файбера.
[01:16:53.000 --> 01:16:56.000]  Вот сюда.
[01:16:56.000 --> 01:16:59.000]  Ой, простите, вот сюда.
[01:17:03.000 --> 01:17:06.000]  За это отвечает
[01:17:06.000 --> 01:17:09.000]  вот эта строчка.
[01:17:10.000 --> 01:17:13.000]  Мы двигаем текущее значение rsp
[01:17:13.000 --> 01:17:16.000]  по поентру, на который указывает
[01:17:16.000 --> 01:17:19.000]  первый аргумент функции.
[01:17:19.000 --> 01:17:22.000]  А дальше мы выполняем симметричную работу.
[01:17:22.000 --> 01:17:25.000]  Смотрите, тут все очень логично.
[01:17:25.000 --> 01:17:28.000]  Дальше мы, наоборот, из памяти контекст
[01:17:28.000 --> 01:17:31.000]  strig двигаем stack pointer в
[01:17:31.000 --> 01:17:34.000]  процессор, после чего наш мир становится
[01:17:34.000 --> 01:17:37.000]  красным. Вот тут синяя половина и красная половина
[01:17:37.000 --> 01:17:40.000]  это мир синего stack и мир красного stack.
[01:17:40.000 --> 01:17:43.000]  И вот после того, как мы сделали
[01:17:43.000 --> 01:17:46.000]  вот этот move, мы знаем, что
[01:17:46.000 --> 01:17:49.000]  на stack, который сейчас установлен,
[01:17:49.000 --> 01:17:52.000]  видимо, лежат сохраненные регистры
[01:17:52.000 --> 01:17:55.000]  rbp, rbx, r12, r15, причем именно в таком порядке.
[01:17:55.000 --> 01:17:58.000]  Мы их
[01:17:58.000 --> 01:18:01.000]  попаем со stack в обратном порядке,
[01:18:01.000 --> 01:18:04.000]  разумеется, и говорим
[01:18:04.000 --> 01:18:07.000]  red. И вот последний red
[01:18:07.000 --> 01:18:10.000]  третьим шагом снимает адрес
[01:18:10.000 --> 01:18:13.000]  возврата со stack и намазывает
[01:18:13.000 --> 01:18:16.000]  его на процессор. И вот мы прыгаем в другое место кода.
[01:18:19.000 --> 01:18:22.000]  Вот stack здесь, это такое
[01:18:22.000 --> 01:18:25.000]  хранилище состояния, хранилище контекста. Нам нужно
[01:18:25.000 --> 01:18:28.000]  всего лишь помнить один pointer для файбера
[01:18:28.000 --> 01:18:31.000]  вершину его call stack.
[01:18:32.000 --> 01:18:35.000]  Когда я говорю, что мы переключаемся в...
[01:18:50.000 --> 01:18:52.000]  Простите, я немного завис.
[01:18:52.000 --> 01:18:55.000]  Когда я говорю, что мы переключаемся в контекст
[01:18:55.000 --> 01:18:58.000]  штрих, который ранее стоял слева и был заполнен,
[01:18:58.000 --> 01:19:01.000]  вот о чем я говорю? Я ожидаю, что
[01:19:01.000 --> 01:19:04.000]  если я вызвал такую процедуру в коде,
[01:19:04.000 --> 01:19:07.000]  то, видимо, в контексте
[01:19:07.000 --> 01:19:10.000]  штрихованном находится stack pointer,
[01:19:12.000 --> 01:19:15.000]  который указывает на stack,
[01:19:15.000 --> 01:19:18.000]  в котором уже ранее
[01:19:18.000 --> 01:19:21.000]  кто-то сохранил все вот эти коди сейфт-регистры и
[01:19:21.000 --> 01:19:24.000]  установил разумный адрес возврата.
[01:19:24.000 --> 01:19:27.000]  И вот я здесь сохраняю текущее
[01:19:27.000 --> 01:19:30.000]  состояние текущего исполнения на этот stack
[01:19:30.000 --> 01:19:33.000]  и запоминаю rsp. И после того,
[01:19:33.000 --> 01:19:36.000]  как я свои stack переставлю, попаду в красный мир,
[01:19:36.000 --> 01:19:39.000]  то я со stack в обратном порядке все снимаю
[01:19:39.000 --> 01:19:42.000]  и намазываю на процессор.
[01:19:43.000 --> 01:19:46.000]  Можно вопрос?
[01:19:48.000 --> 01:19:51.000]  Все же, если у нас stack всего 8 мегабайт,
[01:19:51.000 --> 01:19:54.000]  учитывая, что
[01:19:54.000 --> 01:19:57.000]  и пользователи внутри программы могут переменные
[01:19:57.000 --> 01:20:00.000]  писать, и в целом глубина у нас может быть достаточно
[01:20:00.000 --> 01:20:03.000]  большая, и контекстов много. Мы не боимся, что
[01:20:03.000 --> 01:20:06.000]  эти 8 мегабайт закончатся?
[01:20:06.000 --> 01:20:09.000]  Вопрос, кажется, к файберу у них не относится.
[01:20:09.000 --> 01:20:12.000]  Во-первых, файбер либо остановлен, либо работает.
[01:20:12.000 --> 01:20:15.000]  Сколько мы потратили какие-то
[01:20:15.000 --> 01:20:18.000]  совсем крохи на этом stack?
[01:20:18.000 --> 01:20:21.000]  Ну, файберов у нас теоретически может быть много.
[01:20:22.000 --> 01:20:25.000]  Во-первых, никто не мешает тебе заводить stack для файберов
[01:20:25.000 --> 01:20:28.000]  любого размера. Почему 8 мегабайт? Можно заводить,
[01:20:28.000 --> 01:20:31.000]  ну, не знаю, можно гигабайтные stack и малацировать.
[01:20:31.000 --> 01:20:34.000]  А, или это другой stack? Это не тот же stack, который...
[01:20:34.000 --> 01:20:37.000]  Нет, это stack вызова файбера. Вот этот stack, вот он.
[01:20:40.000 --> 01:20:43.000]  Вот он.
[01:20:45.000 --> 01:20:48.000]  И не понимаю, при чем здесь
[01:20:48.000 --> 01:20:51.000]  файбер. Ну, то есть потоки, файбер тут разницы особой нет.
[01:20:51.000 --> 01:20:54.000]  Поток может переполнить stack, файбер тоже может переполнить stack.
[01:20:54.000 --> 01:20:57.000]  Я в терминало не запутался просто, я
[01:20:57.000 --> 01:21:00.000]  думал, почему stack они куча, а это вообще наш stack, а не
[01:21:00.000 --> 01:21:03.000]  программный. Ну, я говорю аккуратно, я говорю close stack везде.
[01:21:03.000 --> 01:21:06.000]  Это close stacks.
[01:21:12.000 --> 01:21:15.000]  Можно тоже спросить? У нас уже контекст
[01:21:15.000 --> 01:21:18.000]  должен быть уже потенциализированный, понятно, что мы,
[01:21:18.000 --> 01:21:21.000]  когда нам приходит новая функция, мы там как-то распихиваем,
[01:21:21.000 --> 01:21:24.000]  допустим, вот эти регистры R153.0
[01:21:24.000 --> 01:21:27.000]  исполняем, вот. А про RIP
[01:21:27.000 --> 01:21:30.000]  немного непонятно, потому что функция новая,
[01:21:30.000 --> 01:21:33.000]  ну, нам придали лямбу новую, которую мы еще не разу не запускали.
[01:21:33.000 --> 01:21:36.000]  Нам нужно в RIP ее фактически адрес дать.
[01:21:36.000 --> 01:21:39.000]  И достаточно... Ты правильно все говоришь,
[01:21:39.000 --> 01:21:42.000]  я понял, о чем ты спрашиваешь. Ты спрашиваешь про базу. Вот я говорю,
[01:21:42.000 --> 01:21:45.000]  когда мы переключаемся в контекст,
[01:21:45.000 --> 01:21:48.000]  вот здесь вот, то мы ожидаем, что он
[01:21:48.000 --> 01:21:51.000]  заполнен чем-то разумным. Почему он заполнен? Потому что
[01:21:51.000 --> 01:21:54.000]  ранее он стоял слева от switch2. Ну, вот, например,
[01:21:54.000 --> 01:21:57.000]  когда мы говорим про планировщик, когда мы прыгаем в планировщик,
[01:21:57.000 --> 01:22:00.000]  то мы ожидаем, что луп контекста заполнен, потому что ранее
[01:22:00.000 --> 01:22:03.000]  этот луп контекста,
[01:22:03.000 --> 01:22:06.000]  в него был
[01:22:06.000 --> 01:22:09.000]  сохранен контекст потока, который исполнял
[01:22:09.000 --> 01:22:12.000]  франшедулер вот здесь, в этой строчке.
[01:22:12.000 --> 01:22:15.000]  Но когда мы первый раз переключаемся на файбер, то, кажется, у нас проблема,
[01:22:15.000 --> 01:22:18.000]  потому что первый файбер еще ни разу не запускался,
[01:22:18.000 --> 01:22:21.000]  у него ничего разумного нет. Но в этом случае,
[01:22:21.000 --> 01:22:24.000]  при первом запуске файбера, это разговор просто на семинар.
[01:22:24.000 --> 01:22:27.000]  Мы должны заранее для него подготовить стэк вызовов,
[01:22:27.000 --> 01:22:30.000]  то есть привести его к такому виду.
[01:22:30.000 --> 01:22:33.000]  Просто руками построить.
[01:22:33.000 --> 01:22:36.000]  Для того, чтобы в первый раз он смог заработать.
[01:22:36.000 --> 01:22:39.000]  Я последние слова скажу буквально, это важно,
[01:22:39.000 --> 01:22:42.000]  мы не проговорили их, мне кажется, стоит
[01:22:42.000 --> 01:22:45.000]  полезно понимать тоже. Вот смотрите,
[01:22:45.000 --> 01:22:48.000]  вы запускаете файбер
[01:22:51.000 --> 01:22:54.000]  вот здесь вот.
[01:22:55.000 --> 01:22:58.000]  Он работает-работает и завершается.
[01:23:00.000 --> 01:23:03.000]  Ну это же функция, да?
[01:23:03.000 --> 01:23:06.000]  Просто функция. Компилятор ее скомпилирует
[01:23:06.000 --> 01:23:09.000]  и в конце напишет инструкцию RET.
[01:23:12.000 --> 01:23:15.000]  Что эта функция RET сделает?
[01:23:15.000 --> 01:23:18.000]  Что эта инструкция RET сделает?
[01:23:22.000 --> 01:23:25.000]  Вот. При виде инструкции RET
[01:23:25.000 --> 01:23:28.000]  процессор снимает возврата со стэка и прыгает
[01:23:28.000 --> 01:23:31.000]  по нему. Но с другой стороны, видимо, в корне
[01:23:31.000 --> 01:23:34.000]  нашего стэка находилась лямбда, который файбер исполнял.
[01:23:34.000 --> 01:23:37.000]  И если мы не постараемся, то при завершении
[01:23:37.000 --> 01:23:40.000]  файбера просто процессор пробьет дно нашего стэка
[01:23:40.000 --> 01:23:43.000]  и программа разломается.
[01:23:43.000 --> 01:23:46.000]  Поэтому у нас два частных случая.
[01:23:46.000 --> 01:23:49.000]  Во-первых, это старт файбера, когда мы должны
[01:23:49.000 --> 01:23:52.000]  руками подготовить контекст исполнения на стэке.
[01:23:52.000 --> 01:23:55.000]  А второй частный случай это завершение
[01:23:55.000 --> 01:23:58.000]  файбера.
[01:23:58.000 --> 01:24:01.000]  С завершением связана такая процедура,
[01:24:01.000 --> 01:24:04.000]  которая называется трамплином.
[01:24:04.000 --> 01:24:07.000]  Сейчас давайте этот сплит уберу.
[01:24:07.000 --> 01:24:10.000]  Он, кажется, уже исчерпал себя.
[01:24:10.000 --> 01:24:13.000]  Смотрите, когда файбер стартует,
[01:24:13.000 --> 01:24:16.000]  он на самом деле стартует не с исполнения лямбды.
[01:24:16.000 --> 01:24:19.000]  Он стартует с специальной функцией, которая называется
[01:24:19.000 --> 01:24:22.000]  трамплином.
[01:24:22.000 --> 01:24:25.000]  То есть, когда я готовлю файбер к запуску,
[01:24:25.000 --> 01:24:28.000]  я заполняю его стэк так, чтобы при прыжке
[01:24:28.000 --> 01:24:31.000]  при переключении в этот файбер
[01:24:31.000 --> 01:24:34.000]  начала исполняться вот эта функция с некоторым
[01:24:34.000 --> 01:24:37.000]  аргументом arg, в которой я передам каким-то образом
[01:24:37.000 --> 01:24:40.000]  адрес текущего файбера, то есть this.
[01:24:40.000 --> 01:24:43.000]  Это статическое, у него нет никакого this.
[01:24:43.000 --> 01:24:46.000]  При старте файбера в эту функцию
[01:24:46.000 --> 01:24:49.000]  передастся pointer на файбер, который хочет запуститься.
[01:24:49.000 --> 01:24:52.000]  И вот эта функция, она
[01:24:52.000 --> 01:24:55.000]  запустит уже
[01:24:57.000 --> 01:25:00.000]  код пользователя.
[01:25:03.000 --> 01:25:06.000]  Эта функция завершится, то есть, эта инструкция
[01:25:06.000 --> 01:25:09.000]  red в вашей лямбде, она выполнится,
[01:25:09.000 --> 01:25:12.000]  файбер выйдет из этого вызова.
[01:25:12.000 --> 01:25:15.000]  А после этого он вызовет специальную функцию,
[01:25:15.000 --> 01:25:18.000]  специальный метод планировщика syscall terminate.
[01:25:18.000 --> 01:25:21.000]  И смысл его такой. Уйти
[01:25:21.000 --> 01:25:24.000]  из трамплина, но больше в него не возвращаться.
[01:25:24.000 --> 01:25:27.000]  Вот функция yield, это такая функция,
[01:25:27.000 --> 01:25:30.000]  куда мы заходим один раз, выходим дважды.
[01:25:30.000 --> 01:25:33.000]  А вот terminate мы заходим туда один раз, а выходим
[01:25:33.000 --> 01:25:36.000]  никогда. Каким образом это достигается?
[01:25:36.000 --> 01:25:39.000]  Ну, буквально, совершенно древиально.
[01:25:39.000 --> 01:25:42.000]  Мы меняем state текущего файбера
[01:25:42.000 --> 01:25:45.000]  на terminate и прыгаем в планировщик.
[01:25:45.000 --> 01:25:48.000]  В планировщике мы выходим
[01:25:49.000 --> 01:25:52.000]  из этого вызова,
[01:25:52.000 --> 01:25:55.000]  возвращаемся в цикл, переходим в метод
[01:25:55.000 --> 01:25:58.000]  диспетчеризации и видим, что если файбер
[01:25:58.000 --> 01:26:01.000]  в состоянии terminate, то, видимо, он завершился
[01:26:01.000 --> 01:26:04.000]  и нужно просто его разрушить.
[01:26:04.000 --> 01:26:07.000]  Нужно освободить стэк, ударить файбер.
[01:26:10.000 --> 01:26:13.000]  Ну, то есть, трамплин — это функция,
[01:26:13.000 --> 01:26:16.000]  которая находится на дне
[01:26:16.000 --> 01:26:19.000]  стека вызовов. Вот если мы посмотрим, например,
[01:26:19.000 --> 01:26:22.000]  на пример со стэками,
[01:26:22.000 --> 01:26:25.000]  запустим его,
[01:26:25.000 --> 01:26:28.000]  то мы увидим, что
[01:26:28.000 --> 01:26:31.000]  в корне стека, на дне стека лежит вовсе не
[01:26:31.000 --> 01:26:34.000]  код пользователя, а лежит этот самый...
[01:26:34.000 --> 01:26:37.000]  Ждем, ждем, ждем.
[01:26:37.000 --> 01:26:40.000]  Лежит этот самый трамплин.
[01:26:40.000 --> 01:26:43.000]  И когда этот трамплин
[01:26:43.000 --> 01:26:46.000]  завершит вызов функции пользователя,
[01:26:46.000 --> 01:26:49.000]  он вызовет terminate,
[01:26:49.000 --> 01:26:52.000]  и исполнение навсегда покинет этот стэк.
[01:26:52.000 --> 01:26:55.000]  Так что мы его не разломаем при выходе.
[01:26:57.000 --> 01:27:00.000]  Ну что, я исчерпал время больше, чем должен был.
[01:27:00.000 --> 01:27:03.000]  Вроде бы мы
[01:27:03.000 --> 01:27:06.000]  разобрали то, что планировали,
[01:27:06.000 --> 01:27:09.000]  разобрали переключение контекста, даже успели
[01:27:09.000 --> 01:27:12.000]  поговорить про трамплины. Тут много деталей
[01:27:12.000 --> 01:27:15.000]  осталось еще не разобранным, всякие интрузивности,
[01:27:15.000 --> 01:27:18.000]  там локация стэков, синхронизация.
[01:27:18.000 --> 01:27:21.000]  Ну вот это вы можете почитать сами, посмотреть,
[01:27:21.000 --> 01:27:24.000]  прийти на следующий семинар, где вам об этом расскажут еще.
[01:27:24.000 --> 01:27:27.000]  А в следующий раз мы поговорим уже
[01:27:27.000 --> 01:27:30.000]  про то, поговорим про две важные вещи. Это будет
[01:27:30.000 --> 01:27:33.000]  очень важная, мне кажется, рекция, новая в курсе,
[01:27:33.000 --> 01:27:36.000]  которая не хватала. Мы поговорим, во-первых,
[01:27:36.000 --> 01:27:39.000]  про те вещи, которые параллельными,
[01:27:39.000 --> 01:27:42.000]  а во-вторых, мы поговорим, как их
[01:27:42.000 --> 01:27:45.000]  научить делать что-то полезное, а именно
[01:27:45.000 --> 01:27:48.000]  общаться с внешним миром.
[01:27:48.000 --> 01:27:51.000]  Что спасибо за то, что пришли сегодня
[01:27:51.000 --> 01:27:54.000]  в Zoom. Если остаются вопросы, то
[01:27:54.000 --> 01:27:57.000]  мы, конечно, можем еще некоторое время продолжить.
[01:27:57.000 --> 01:28:00.000]  Я отвечу на них с удовольствием.
[01:28:00.000 --> 01:28:03.000]  На этой неделе тоже
[01:28:03.000 --> 01:28:06.000]  домашнее задание, да? На этой неделе не будет.
[01:28:06.000 --> 01:28:09.000]  Мы должны послушать еще одну лекцию,
[01:28:09.000 --> 01:28:12.000]  где мы научимся делать файберы параллельными
[01:28:12.000 --> 01:28:15.000]  и делать их, научимся выполнять
[01:28:15.000 --> 01:28:18.000]  ввод-вывод в них, и после этого через неделю у вас будет
[01:28:18.000 --> 01:28:21.000]  очередная домашняя работа, но уже большая и сложная,
[01:28:21.000 --> 01:28:24.000]  и такая долгоиграющая.
[01:28:24.000 --> 01:28:27.000]  А пока мы дорешиваем простые задачи про Кондвор и про Мютекс.
[01:28:27.000 --> 01:28:30.000]  Хорошо, спасибо.
[01:28:31.000 --> 01:28:34.000]  Еще про переключение контекста на армию.
[01:28:34.000 --> 01:28:37.000]  Да.
[01:28:37.000 --> 01:28:40.000]  Там сейчас оно режется, и я не знаю, почему.
[01:28:40.000 --> 01:28:43.000]  Оно даже не депажится.
[01:28:43.000 --> 01:28:46.000]  Но мне кажется, что это вопрос не для лекций все же.
[01:28:46.000 --> 01:28:49.000]  Ну да ладно.
[01:28:51.000 --> 01:28:54.000]  Ну тогда спасибо, до свидания.
[01:28:54.000 --> 01:28:57.000]  Счастливо. Спасибо, до свидания.
