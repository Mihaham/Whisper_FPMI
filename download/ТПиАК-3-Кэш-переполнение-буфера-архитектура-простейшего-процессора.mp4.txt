[00:00.000 --> 00:11.400]  Так, судя по тому, что начались всякие генерёжки и прочие
[00:11.400 --> 00:13.880]  мероприятия, скоро наступает посвят.
[00:13.880 --> 00:22.240]  Но, возможно, он в этот раз пройдёт более активно
[00:22.240 --> 00:25.720]  по той простой причине, что вроде никаких ограничений
[00:25.720 --> 00:26.720]  нет.
[00:26.720 --> 00:38.040]  В общем, жили-были студенты в семёрке и решили не отмечать
[00:38.040 --> 00:39.040]  посвят.
[00:39.040 --> 00:51.520]  В процессе отмечания им не хватило сока, но значит
[00:51.520 --> 00:52.840]  они кого-то пошлют за соком.
[00:52.840 --> 01:00.760]  Время уже позднее, поэтому первокуров послать нельзя.
[01:00.760 --> 01:04.640]  Они не совершеннолетние, для них движет комендантский
[01:04.640 --> 01:05.640]  час.
[01:05.640 --> 01:14.960]  Но старокуры совершеннолетние, они уже спокойно ходят.
[01:14.960 --> 01:20.340]  Старокуров как-то лень, поэтому отправляют самых
[01:20.340 --> 01:26.720]  младших, самых духов по армейской терминологии.
[01:26.720 --> 01:30.440]  Ну, в частности, второкуров.
[01:30.440 --> 01:38.880]  Прибегают, в общем, из всей компании послали самого
[01:38.880 --> 01:42.120]  младшего, то бишь второкурсника, прибегают он в палатки
[01:42.120 --> 01:43.120]  и видит.
[01:43.120 --> 01:46.640]  Там есть куча сока.
[01:46.640 --> 02:16.560]  Вот его послали за литром апельсинового сока.
[02:16.560 --> 02:28.600]  Он побежал, принес и его бусинка из всей компании
[02:28.600 --> 02:31.000]  выпала и послала еще за литром апельсинового
[02:31.000 --> 02:46.440]  сока.
[02:46.440 --> 02:48.880]  Тем компания захотела бананового сока.
[02:48.880 --> 02:57.840]  Он побежал, принес, но у него начали возникать некоторые
[02:57.840 --> 02:58.840]  подозрения.
[02:58.840 --> 03:04.240]  И, возможно, этот хитрый второкур, естественно,
[03:04.240 --> 03:10.920]  из всех школ, программ, информатики, умеет считать,
[03:10.920 --> 03:11.920]  начал о чем-то догадываться.
[03:11.920 --> 03:33.920]  Ну да, возможно, кэш у него не очень много, поэтому
[03:33.920 --> 03:38.200]  нужно выбирать, какой закупить еще.
[03:38.200 --> 04:03.520]  Нет, его отправили злобные старшекуры, которые устраивают
[04:03.520 --> 04:10.400]  слобную защиту и требуют ровно конкретного.
[04:10.400 --> 04:17.760]  Ну, известно, что как только он сбегал за апельсином,
[04:17.760 --> 04:19.240]  его снова послали за тем же.
[04:19.240 --> 04:25.840]  Только что его первый раз послали за банановым.
[04:25.840 --> 04:28.840]  Какие будут предложения?
[04:29.840 --> 04:33.480]  Так, как предложила Оля.
[04:33.480 --> 04:37.240]  А, тем более, она в том, что она может сама исправить,
[04:37.240 --> 04:38.240]  что сколько он взял.
[04:38.240 --> 04:51.840]  Он сразу взял 2 литра бананового сока, притащил один виду,
[04:51.840 --> 05:01.360]  затем его послали снова за банановым, и он очень
[05:01.360 --> 05:02.840]  быстро смог его выдать.
[05:02.840 --> 05:07.200]  Почему он смог его быстро выдать?
[05:07.200 --> 05:11.360]  А свадьба была уже в рюкзачке, конечно, небольшом рюкзачке,
[05:11.360 --> 05:12.360]  но сколько-то у него помещается.
[05:12.880 --> 05:25.440]  Злобные старшекуры снова послали его на этот раз за
[05:25.440 --> 05:33.400]  виноградным за 1 литр.
[05:33.440 --> 05:47.080]  Нет, поправили его, попросили бы за виноградным.
[05:47.080 --> 05:55.520]  Если он каждый раз будет брать по 2 литра вместо 1,
[05:55.520 --> 05:58.320]  то насколько реже он будет бегать в палатку?
[05:59.240 --> 06:08.240]  Нет, мы не знаем, в каком порядке он будет бегать в палатку.
[06:09.160 --> 06:18.160]  Короче, он будет бегать в палатку по 1 литру.
[06:18.160 --> 06:23.160]  Он будет бегать в палатку по 1 литру.
[06:23.160 --> 06:26.160]  Он будет бегать в палатку по 1 литру.
[06:27.080 --> 06:44.080]  Есть одна большая проблема.
[06:44.080 --> 06:48.080]  Это бедный второкурор, у которого нет денег 7 пачек
[06:48.080 --> 06:49.080]  40 сразу.
[06:49.080 --> 06:52.400]  Ну, ему каждый раз давали.
[06:56.400 --> 07:03.400]  Можно нанять другого второкурора?
[07:03.400 --> 07:08.400]  Ограничение по финансам.
[07:08.400 --> 07:13.400]  А какой интерес так его бегать?
[07:13.400 --> 07:21.400]  Это какой-то дополнительный ресурс.
[07:21.640 --> 07:27.640]  То есть, просто предположив временную локальность,
[07:27.640 --> 07:32.640]  если мы пыли какой-то сок, то значит скорее всего
[07:32.640 --> 07:45.640]  мы захотим еще получаем снижение частоты похода
[07:45.640 --> 07:48.640]  в палатку в 2 раза.
[07:48.880 --> 07:55.880]  Ну, допустим, нашего второкура объема рюкзачка, ну и, соответственно,
[07:55.880 --> 08:02.880]  кэша в кошельке хватает на 4 пачки сока.
[08:06.880 --> 08:11.880]  Его пока первый раз послали за одним виноградным,
[08:11.880 --> 08:15.880]  и он помнит некоторую историю действия до этого.
[08:18.880 --> 08:20.880]  Что он может предположить?
[08:20.880 --> 08:23.880]  Какой брать еще?
[08:27.880 --> 08:30.880]  Ну, давай, пиши.
[08:35.880 --> 08:38.880]  Так, наш второкур.
[08:48.880 --> 08:51.880]  Ну, хорошо.
[08:51.880 --> 08:54.880]  Не с этим любят инициатора.
[08:54.880 --> 08:57.880]  Ну, может быть, Оля сделает.
[09:18.880 --> 09:25.880]  Ну, то есть, можно сделать примерно так.
[09:41.880 --> 09:47.880]  Он предположил, что скорее всего они решили пить стоки по алфавиту,
[09:48.120 --> 09:55.120]  и взял 4 литра сока, 2 виноградного и 2 грушего.
[09:57.120 --> 10:03.120]  То есть, он предположил такие вещи, а именно временную локальность,
[10:03.120 --> 10:08.120]  то есть, если какие-то данные нам понадобились, то скорее
[10:08.120 --> 10:12.120]  всего, им понадобится снова, и пространственную локальность.
[10:12.120 --> 10:15.120]  Возможно, нам понадобятся соседние данные.
[10:18.120 --> 10:31.120]  И, имея рюкзачок и количество коша в кошельке на 4 пакета сока,
[10:31.120 --> 10:37.120]  насколько реже он стал бегать в палатку?
[10:37.120 --> 10:40.120]  Ну, плохое такое ускорение.
[10:40.360 --> 10:43.360]  Да.
[10:47.360 --> 10:54.360]  Дальше он стал решать домашнюю работу по какому-то предмету,
[10:54.360 --> 10:57.360]  связанному с программированием.
[10:57.360 --> 11:00.600]  Осталось писать что-то такое.
[11:27.600 --> 11:30.600]  Что-то такое.
[11:30.840 --> 11:35.840]  Думайте, какие-то законодательные законодательные законодательные
[11:35.840 --> 11:38.840]  законодательные законодательные законодательные законодательные
[11:38.840 --> 11:41.840]  законодательные законодательные законодательные законодательные
[11:41.840 --> 11:44.840]  законодательные законодательные законодательные законодательные
[11:44.840 --> 11:47.840]  законодательные законодательные законодательные законодательные
[11:47.840 --> 11:50.840]  законодательные законодательные законодательные законодательные
[11:50.840 --> 11:53.840]  законодательные законодательные законодательные законодательные
[11:53.840 --> 11:56.840]  законодательные законодательные законодательные законодательные
[11:56.840 --> 12:00.240]  законодательные законодательные законодательные
[12:00.240 --> 12:03.240]  законодательные законодательные законодательные законодательные
[12:03.240 --> 12:06.240]  законодательные законодательные законодательные законодательные
[12:06.240 --> 12:09.240]  законодательные законодательные законодательные законодательные
[12:09.240 --> 12:12.240]  законодательные законодательные законодательные законодательные
[12:12.240 --> 12:16.320]  законодательные законодательныеori
[12:16.320 --> 12:23.320]  законодательные законодательные законодательные законодательные
[12:23.320 --> 12:45.400]  Если мы ее только что исполнили, очень великая вероятность,
[12:45.400 --> 12:46.640]  что мы ее будем исполнивать снова.
[12:46.640 --> 12:57.040]  А еще и массив мы проходим последовательно. Что это нам дает?
[13:16.640 --> 13:29.520]  Значит, нам нужно, если мы умеем из какого хранилища данных относительно медленного,
[13:29.520 --> 13:36.080]  которое нам приходится ждать, пока мы вытащим данные, вытащить сразу несколько данных,
[13:36.080 --> 13:42.880]  следующий элемент нам тоже нужно вытащить. А если мы какой-то элемент только что используем,
[13:42.880 --> 13:52.800]  стоит его сохранить в чем-то более быстром и снова использовать. Вот так работает кэш.
[13:52.800 --> 13:59.120]  Если вы лезете в оперативную память относительно медленного устройства,
[13:59.120 --> 14:07.360]  вы сохраняете данные в кэше процессора, вытащить даже не вы, а это делается прозрачно для вас,
[14:07.360 --> 14:12.800]  вы просто набраете часикл с памяти и внезапно некоторые обращения с попаданием в кэш
[14:12.800 --> 14:23.000]  приводит к тому, что вы обращаетесь к данным быстро. Если вы тащите данные с диска,
[14:23.000 --> 14:33.080]  то вам нужно дождаться, пока магнитный диск довернется нужным секторам к считывающей головке,
[14:33.080 --> 14:44.840]  а сам блок головок дойдет до нужной дорожки на диске. Это ждать долго, но зато как только вы
[14:44.840 --> 14:49.600]  это считались, можно считать сразу несколько сектов и они сохраняются в оперативной памяти,
[14:49.600 --> 14:59.040]  в более быстром устройстве. А теперь вы решили посмотреть, ну, допустим, лекции на ютубе.
[14:59.040 --> 15:11.520]  Всем потоком. Внезапно оказывается, что канал Fistech во внешний мир тоже не бесконечный.
[15:11.520 --> 15:26.680]  Что же в таких случаях делает Google, чтобы такой хаббор-эффект не положил ютуб?
[15:26.680 --> 15:40.760]  Они ставят кэширующий сервер. То есть некоторое время до того, как Google стал убегать из России,
[15:40.760 --> 15:46.800]  он стоял в 210 ППМ, все равно им хватает телекома. И на самом деле все, что смотрелись в ютубе,
[15:46.800 --> 15:56.400]  смотрелись с этого сервера. И это все сохранялось в кэше этого сервера. А он в единственном
[15:56.400 --> 16:02.600]  экземпляре забирал данные от Google. Смотрит у нас целый поток лекции перед экзаменом. В единственном
[16:02.600 --> 16:13.040]  экземпляре забираем данные с реальных серверов Google и сотни потоков отдаем здесь. Вот так работает.
[16:13.040 --> 16:22.960]  А теперь как же нам с учетом этого написать программу, которая будет дружесленна к использованию кэша?
[16:22.960 --> 16:35.760]  Допустим, у вас есть две матрицы, и вам нужно их перемножить.
[16:52.960 --> 17:05.840]  Вот где такие матрицы. Как нам заставить наш комп считать, перемножать их быстрее?
[17:05.840 --> 17:20.480]  Вот такой нехороший. В прошлый раз подвергалось обменю коммутативность и ассоциативные сложения.
[17:20.480 --> 17:30.240]  Теперь я вам расскажу вам неправильные вещи про аналит. Вот у нас есть какая-то матрица.
[17:30.240 --> 17:49.360]  Как нормальный человек. И вторая матрица.
[18:00.240 --> 18:21.040]  Как ее перемножает нормальный человек? Идет по строке и по столбцу.
[18:21.040 --> 18:34.400]  Что у нас не так с матрицами? Исправляем до правильного размера.
[18:51.040 --> 19:16.000]  Здесь идем по строке или по столбцу? Как решетками отмечено.
[19:16.000 --> 19:23.600]  А во второй? Сколько строк должно быть во второй?
[19:23.600 --> 19:45.120]  Написываем.
[19:45.120 --> 19:55.760]  При этом, допустим, мы в кэш утаскиваем, прочитав некий элемент, утаскиваем соседний.
[19:55.760 --> 20:16.720]  Мы попали сюда. Промах мимо кэша. А здесь взяли данные из кэша. Промазали из кэша, промазали из кэша.
[20:16.720 --> 20:28.880]  Идем здесь. Промазали. Попали в кэш. Промазали. Данные в кэш. Попали. Промазали. Данные в кэш.
[20:47.360 --> 21:02.640]  Когда мы шли по строке, то сколько у нас получилось промахов мимо кэша, то есть реальных обращений к памяти?
[21:02.640 --> 21:13.040]  Всего три. А когда мы шли по столбцу?
[21:13.040 --> 21:31.920]  А какова у нас вообще сложность перемножения матрицы, алгоритмическая, если у нас две матрицы N умножить на N?
[21:31.920 --> 21:50.160]  Аналит, вроде, никак не давали, сдавали.
[21:50.400 --> 22:02.080]  Какая у нас сложность транспонирования матрицы?
[22:02.160 --> 22:10.160]  То есть потратив время порядка N в квадрате, мы можем эту матрицу транспонировать.
[22:10.160 --> 22:24.640]  И после этого мы в некоторую константу раз быстрее будем делать операцию, которая делается N в кубе раз.
[22:24.640 --> 22:41.200]  Если кэш у нас побольше, например, целых четыре элемента сохраняют, тогда у нас и попаданий в кэш будет больше.
[22:41.760 --> 23:00.880]  Первый раз мы промазали, затем взяли из кэша, из кэша, из кэша. Промазали из кэша, то есть где-то раз так четыре, ускорим.
[23:00.880 --> 23:06.960]  То есть нам нужно хранить данные в своей структуре так, чтобы они же по возможности лежали последовательно.
[23:07.040 --> 23:08.960]  И обращаться к ним по возможности последовательно.
[23:11.840 --> 23:19.600]  Наш бедный процессор предполагает, что мы будем забирать данные именно последовательно.
[23:22.800 --> 23:27.920]  А также использовать те, которые мы только что использовали повторно.
[23:27.920 --> 23:49.680]  Теперь вот у нас есть некоторый кусочек данных, который занимает 7 байтов.
[23:57.920 --> 24:16.720]  Есть, допустим, у нас кэш-линейка, которая на конкретной модели процессора допустим 8 байтов.
[24:16.720 --> 24:29.840]  То есть в реальности, чтобы вычитать эти данные, мы читаем по какому-то адресу и в кэш попадает 8 байтов.
[24:29.840 --> 24:47.840]  Прочитали один раз, затем мы хотим прочитать второй кусочек данных.
[24:47.840 --> 24:57.200]  Сколько у нас, что у нас прочитается второй раз.
[24:57.200 --> 25:26.880]  А также возможно, что наши данные окажутся
[25:26.880 --> 25:39.000]  например вот здесь. И чтобы прочитать вот этот кусочек данных из 7 байтов,
[25:39.000 --> 25:47.360]  физически будут два обращения к памяти. Первая прочитает аммидиатмично маленькими буквами,
[25:47.360 --> 26:02.080]  вторая где большими. Еще одна контроинтуитивная вещь. Мы хотим прочитать 7 байтов,
[26:02.080 --> 26:08.600]  а вместо этого из памяти прочитали два раза по 8 байтов.
[26:08.600 --> 26:21.600]  Ну и два раза лазили в оперативную память. Память у нас медленная, ну по крайней мере относительно
[26:21.600 --> 26:26.200]  регистр процесса. Ну или диск у нас медленный относительно оперативной памяти. Принцип
[26:26.200 --> 26:36.040]  остается тоже. Как же нам сделать так, чтобы нам не приходилось лишний раз лазить в оперативную
[26:36.040 --> 26:55.040]  память, если мы читаем кусочками по 8 байтов. Да, давайте заплатим памятью за время.
[27:06.040 --> 27:30.840]  Обычно размер кэш линейки это некоторая степень двойки и вообще все считается некими
[27:30.840 --> 27:37.680]  кусочками по 2 в степени Н байта. Допустим несколько байтов размер кэш линейки в процессоре,
[27:37.680 --> 27:51.920]  или с жесткого диска мы считаем какими кусочками минимум 512 байтов, с магнитом оптического минимум
[27:51.920 --> 28:03.760]  по 2 килобайта, с 2 мешек тоже возможно большими кусочками. Исходя из этого, как мы можем
[28:03.760 --> 28:13.840]  ускорить работу нашего перемножателя матрицы? Что мы можем сделать с размерами этой матрицы?
[28:13.840 --> 28:40.080]  Какое же, если не тысяча на тысячу? Ну можно тысячу такое некруглое число.
[28:44.680 --> 29:03.120]  Округлито тысяча двадцать четырех. Ну попробуйте написать перемножение матриц и попробуйте
[29:03.120 --> 29:10.400]  и померить время. Насколько быстро будут они перемножаться после этого?
[29:10.400 --> 29:33.720]  Ну алгоритм это хорошо, но не будем отбирать хлеб у кафедры мол.
[29:40.400 --> 29:58.400]  Если мы хотим померить, то сколько раз ускоряет нам кэш, то как мы должны поставить эксперимент,
[29:58.400 --> 30:08.880]  так чтобы на это минимально влияло наше все остальное и сделать минимальную погрешность.
[30:08.880 --> 30:13.920]  Да, внезапно вам пригодится та культура эксперимента,
[30:13.920 --> 30:29.200]  которую вы освоили на ПИЗЛАБах, ну или не освоили. На что потратится время,
[30:29.200 --> 30:36.880]  если вы будете писать это в какой-нибудь среде заработки и вводить матрицу такого размера вручную.
[30:36.880 --> 30:59.480]  А как же нам их ввести тогда, если не вручную?
[31:06.880 --> 31:17.760]  Ну можно, например, сделать так с перенаправлением потока ввода-вывода.
[31:17.760 --> 31:26.960]  Ну и здесь, несмотря на то, что мы отключим от процесса всяких медленных положенных мешков,
[31:26.960 --> 31:39.480]  ввод-вывод займет существенное время, потому что в любом случае ввод-вывод медленнее,
[31:39.480 --> 31:45.040]  чем оперативная память. Нам нужно что-то, что работает быстрее, быстрее, чем оперативка.
[31:45.040 --> 31:58.840]  Значит, матрицы должны у нас для чистоты эксперимента генерироваться на ходу,
[31:58.840 --> 32:10.640]  то есть по какому-то правилу генерироваться, причем меньше, чем за n куб, существенно меньше.
[32:10.640 --> 32:20.240]  То есть за сложный порядок от n квадрат, в крайнем случае n квадрат много,
[32:20.240 --> 32:28.440]  генерироваться прямо перед вычислением в нашей программе, прямо в оперативной памяти,
[32:28.440 --> 32:41.600]  а затем уже перемножаться. Попробуйте, что будет, если перемножать строку,
[32:41.600 --> 32:52.720]  можно их даже генерировать сразу трансформированными. Строку на столбец, строку на строку, столбец на
[32:52.720 --> 33:18.280]  столбец. Ну и сколько это займет времени? А просто померить. Время вы можете с помощью
[33:18.280 --> 33:30.640]  утилиты тайм. То есть запускайте под утилиты тайм вашу программу, и она мерит сколько времени
[33:30.640 --> 33:40.640]  на работу. Ну вот и будет интересно посмотреть, сколько у вас получится. Какое ускорение у вас
[33:40.640 --> 34:04.760]  получится от использования кыша. Следующий эксперимент. Можем ли мы залезть в данные
[34:04.760 --> 34:13.640]  другой программы. Ну или не другой программы, а хотя бы другой кусок данных нашей программы.
[34:13.640 --> 34:31.680]  Пишем некую структуру.
[34:43.640 --> 35:13.600]  Интересно, по каким адресам у нас будет лежать этот самый
[35:13.600 --> 35:14.280]  массив Х?
[35:43.600 --> 35:47.720]  Ну давайте проверим.
[36:13.600 --> 36:42.400]  Справим ошибку.
[36:42.400 --> 37:04.040]  А вот библиотеку Lipsy мы как раз пролинкуем, причем динамически. Вот мы запускаем,
[37:04.040 --> 37:15.640]  делаем несколько запусков. А теперь вспоминаем Fizzlabs. Что мы можем вынести из нескольких
[37:15.640 --> 37:41.440]  последовательных экспериментов. Адреса у нас. Но сами адреса у нас меняются.
[37:41.440 --> 37:57.080]  Используется адрес Space-Layout-Ranomization, ISLR. Это для того, чтобы всякие злобные хакеры,
[37:57.080 --> 38:12.320]  типа Николая и Владислава, нам ничего не поломали. По крайней мере, чтобы это сделать было труднее.
[38:27.080 --> 38:40.160]  Можем ли мы, обращаясь только к нашему массиву, изменить значение Х? Как?
[38:57.080 --> 39:18.320]  К указателю прибавить 17? Что с этим сделать? У нас 23 интересно.
[39:27.080 --> 39:54.640]  Что это вы подсовываете мне какое-то левое значение, говорит компилятор?
[39:54.640 --> 40:09.920]  Может так сделать?
[40:24.640 --> 40:28.920]  Интересный результат. Почему такое?
[40:54.640 --> 41:00.600]  Интересное число. 1643. Что бы оно значило?
[41:24.640 --> 41:44.680]  То есть в самом младшем байте 123, в следующем 45. Ну вот и интерпретировалось.
[41:44.680 --> 41:51.760]  С учетом того, что у нас Литл Эндиен. А как бы нам напрямую записать?
[41:51.760 --> 42:06.280]  Прямо в Х. Прямо в этот байт, где лежит Х.
[42:06.280 --> 42:18.520]  Нет, ну это не интересно. Плюс 17 мы в соседний байт записали.
[42:18.520 --> 42:39.960]  Только ли Интел?
[42:39.960 --> 42:55.920]  АМД тоже.
[42:55.920 --> 43:10.360]  Взяли и записали.
[43:25.920 --> 43:38.600]  Ну у нас 16 байт. С 0 по 15. Если сдвинуть на 16, мы вылезем за пределы.
[43:38.600 --> 44:06.200]  На 17 это уже шаг дальше. А как можно изменить эти данные на 0, если у нас будет некая строка,
[44:06.200 --> 44:08.480]  которую мы сюда копируем. В этот самый массив.
[44:36.240 --> 45:05.720]  Здесь у нас некие данные. Некая строка. Состоящая из 16 байтов.
[45:05.720 --> 45:20.120]  Если мы хотим, чтобы это была строка, какой должен быть последний байт?
[45:20.120 --> 45:35.040]  Причем не код символа 0, а именно численно 0. А что будет, если мы с помощью СТРЦМП
[45:35.040 --> 45:46.880]  копируем в этот массив строчку, в которой будет 16 значащих символов. Ну и естественно символ
[45:46.880 --> 45:59.120]  терминатор 0. С 0 по 15 будут значащие, а на 16 месте будет символ терминатор за значением 0. Что тогда произойдет?
[45:59.120 --> 46:26.360]  Чего не хватает? Вот тут у нас лежат 4 байта этого самого X, в предложении 4-байтовый.
[46:26.360 --> 46:41.000]  В общем, самый младший что-то значащий. Допустим, как раз 3 0, потому что число у нас небольшое,
[46:41.000 --> 46:56.760]  не превышает 256. Если у нас в строчке появится еще один символ, то символ терминатора как раз
[46:56.760 --> 47:09.560]  затрет от значения. То есть мы передаем просто строчку, состоящую из каких-то символов в количестве
[47:09.560 --> 47:18.360]  16 штук и затем символ с нулевым кодом. В предположении, что кто-то положится функцией СТРЦКОПИ,
[47:18.360 --> 47:37.400]  например. И честно копируют до символа с нулевым кодом. В результате происходит переполнение этого
[47:37.400 --> 47:44.440]  массива и данные попадают в соседний. А если у нас был, допустим, логин и айдишник пользователя,
[47:44.440 --> 47:56.920]  и айдишник пользователя внезапно стал нулевым. Что у нас стало с пользователем? Вот такие бывают
[47:56.920 --> 48:00.840]  последствия переполнения. А что же делать, чтобы переполнения не было?
[48:00.840 --> 48:16.560]  Моно вам об этом что-нибудь подсказывает?
[48:16.560 --> 48:30.240]  СТРЦКОПИ
[48:46.560 --> 49:08.280]  Монологично не в копе, но именно ограниченный.
[49:08.280 --> 49:28.760]  Теперь вдруг выяснилось, что некоторые западные, ну и восточные типа TSMC компании не хотят с
[49:28.760 --> 49:38.200]  нами работать. И в частности, поставлять процессором. Что же делать придется? Значит,
[49:38.200 --> 49:51.480]  придется делать свой процессор 160 СТРДЦКОПИ. Ну давайте сделаем небольшую модельку такого
[49:51.480 --> 49:55.440]  процессора. И некий эмулятор, его работа на СИ.
[50:21.480 --> 50:51.400]  Допустим, наш процессор будет
[50:51.400 --> 51:08.880]  поддерживать. Будет иметь несколько регистров. Назовем их А, Б, Ц, И, Д. И пусть они в неком
[51:09.640 --> 51:23.000]  будут иметь номера с 5 по 8. Пусть он у нас будет делать некоторые команды. Например, ОСТОНОВ,
[51:23.000 --> 51:34.360]  СЛОЖЕНИЕ, УЧИТАНИЕ, ПРИСВАЕВАНИЕ. Ну и команда инфорегистров, которая задамит нам все
[51:34.360 --> 51:58.640]  содержимые регистров. На вход у нас приходит некоторая команда. Дальше мы должны разобрать,
[51:58.680 --> 52:10.280]  что это за команда и что-то с ней сделать. Сами регистры нам выгодно хранить в виде
[52:10.280 --> 52:38.520]  чего? В виде некоторого массива. Считали нашу команду, если она не ОСТОНОВ, не 0. Проверяем,
[52:38.520 --> 52:47.640]  если это команда СЛОЖЕНИЯ. Читаем номера регистров, с которыми нам нужно что-то сделать.
[52:58.280 --> 53:07.480]  Может быть они окажутся недопустимыми. Мы это обрабатываем. А если все хорошо,
[53:07.480 --> 53:20.840]  к одному регистру из нашего регистрового файла, т.е. массивы регистров, предлагаем значение
[53:20.840 --> 53:31.840]  другого. Вот у нас уже процессор, который что-то умеет делать. Логично с вычитанием.
[53:31.840 --> 53:45.720]  По команде MOV что-то присвоить мы берем и записываем данные в наш регистр. А по
[53:45.720 --> 53:52.520]  команде info-registers мы берем и все нам выводим.
[54:15.720 --> 54:33.240]  А как нам в принципе организовать витвление в нашем процессоре? В одном случае сделать
[54:33.240 --> 55:02.360]  одно в другом другое. При этом мы должны сохранить такую важную вещь, как обратная
[55:02.360 --> 55:12.200]  совместимость. Бинарные программы, написанные под наш процессор. Предыдущие вещи должны
[55:12.200 --> 55:23.440]  работать на более новый. Вот каждый номер регистра или номер команды мы использовали целый байт.
[55:32.360 --> 55:59.600]  Можно. Возможно вариант. Мы введем еще один битик, в котором будет граница информации да или
[55:59.600 --> 56:20.960]  нет. Т.е. есть или нет эти поведки zen или поведки else в нашем витвлении. Не стоит
[56:20.960 --> 56:26.720]  использовать их любитые как флаги. Все-таки могут быть любые значения.
[56:50.960 --> 57:00.040]  Как мы можем проверить условия, что один регистр больше другого? Используя существующие команды.
[57:00.040 --> 57:22.120]  Например один регистр равен другому. Точно равен. А давайте мы из одного регистра другой вычтем.
[57:22.120 --> 57:41.800]  И возможно получим одно очень интересное красивое число, если они равны. И поставим
[57:41.800 --> 57:51.640]  большого брата следить за нами. Если в результате какой-нибудь операции получается
[57:51.640 --> 58:04.680]  нолик, ровно нолик, все биты нолики. Пусть он поднимает такой яркий флаг, название zero flag.
[58:21.640 --> 58:51.280]  А какие еще флаги у нас могут быть?
[58:51.280 --> 59:02.920]  Какими-нибудь интересными числами, которые получаются в результате вычлений.
[59:21.280 --> 59:34.440]  Положительные числа детектировать сложно. А отрицательные проще.
[59:51.280 --> 01:00:06.280]  Как мы без знака вытащим отсюда?
[01:00:06.280 --> 01:00:17.680]  Допустим, если процессор у нас 8-битный, с какой маской?
[01:00:36.280 --> 01:00:56.160]  Если в результате это побитые операции у нас получился нолик, верно ли, что число у нас отрицательное?
[01:00:56.160 --> 01:01:07.080]  Имеет отрицательный знак. Значит оно не отрицательное. Не отрицательно додектирует проще, чем положительно.
[01:01:27.000 --> 01:01:33.840]  А можем мы с помощью комбинации этих двух флагов сказать, что у нас число положительное?
[01:01:33.840 --> 01:01:50.080]  Если сигн флаг у нас нолик, при этом zero flag тоже нолик, значит число положительное.
[01:01:50.080 --> 01:01:55.920]  Какие еще эффекты стоит отлавливать?
[01:01:55.920 --> 01:02:04.240]  Например, сможем ли мы отлавливать факт? Число у нас четное.
[01:02:04.240 --> 01:02:17.600]  Можем ли мы обращать внимание на тот факт, что мы сложили допустим в 8-битном регистре?
[01:02:17.600 --> 01:02:39.080]  127 плюс 127. Сколько у нас получилось? Интересно. В процессе сложения у нас изменился старший бит.
[01:02:39.080 --> 01:02:54.440]  На что это намекает? Что у нас случилось? Ага, то есть флаг про переполнение. Еще про что?
[01:02:54.440 --> 01:03:10.520]  А если у нас без знаковые числа? Мы сложили 128 и на сколько получилось? На ноль.
[01:03:10.520 --> 01:03:15.480]  Пожалуй, об этом факту тоже стоит поднять какой-нибудь интересный флаг.
[01:03:15.480 --> 01:03:28.440]  Что у нас произошел? Перенос в старший разряд. А если мы такой флаг сохраним и при этом захотим сделать динку?
[01:03:28.440 --> 01:03:35.160]  Мы захотим складывать 16-битные числа, а у нас процессор поддерживает 8-битные.
[01:03:35.160 --> 01:03:58.520]  Был ли перенос? Да, соответственно. Затем в старших байтах складывать старший одного флага и старший другого, плюс флаг переноса.
[01:03:59.400 --> 01:04:04.120]  Вот, пожалуйста, у нас получилась длинная рифметика на базе этого флага.
[01:04:04.120 --> 01:04:26.280]  А как бы нам сделать условное исполнение? Причем так, чтобы наш процессор быстро работал.
[01:04:26.280 --> 01:04:35.800]  Вот сидят тут студенты. Слушают про архитектуру.
[01:04:35.800 --> 01:04:48.440]  Параллельно решают задание по Матану, чтобы написать контрольную, которая будет на следующей веопаре.
[01:04:48.440 --> 01:04:55.160]  Пока у нас делается одна операция, мы готовимся к следующей.
[01:04:55.160 --> 01:05:09.080]  Пока мы записываем результат одной команды, мы вычисляем следующую и вытаскиваем из оперативной памяти данные для после следующей.
[01:05:09.080 --> 01:05:22.840]  Что же это за организация труда такая? На заводах еще используется конвейер.
[01:05:22.840 --> 01:05:36.040]  Вдруг мы говорим так, а теперь в срочном порядке переходи по тому адресу исполнять другую команду.
[01:05:36.040 --> 01:05:44.360]  Поможет то, что мы уже частично сделали следующую команду на конвейере.
[01:05:44.360 --> 01:06:02.920]  Например, вы готовились к 15 минут контрольной лекции по Матану, которая будет на следующей паре.
[01:06:02.920 --> 01:06:11.240]  Вдруг вам говорят, извините, у вас будет вместо этого лекция по физике, но тоже с 15 минут.
[01:06:12.120 --> 01:06:14.120]  И вообще в лабораторном.
[01:06:14.120 --> 01:06:24.040]  А могут заложены заботливо разложенные шпаргалки под партами 239?
[01:06:24.040 --> 01:06:30.520]  Почти.
[01:06:30.520 --> 01:06:36.840]  То есть нам нужно по возможности не допустить срывов конвейера.
[01:06:41.240 --> 01:06:48.040]  Теперь мы сделаем иначе.
[01:06:48.040 --> 01:06:59.160]  Приходит на следующую лекцию преподаватель Матана и говорит, если у вас окажется меньше чем 7 человек на лекции, то она не будет контрольная.
[01:06:59.160 --> 01:07:17.080]  Ну а затем будет, допустим, лекция по физике, и если вы просто готовитесь к лекции по физике на тех же условиях, то конвейер не потерялся.
[01:07:17.080 --> 01:07:28.840]  То есть нам выгоднее вместо того, чтобы прыгать куда-то в другое место, исполнять другую команду, просто некоторые команды исполнить условно.
[01:07:28.840 --> 01:07:38.040]  Как раз у нас в номерах команд старше бита не используется.
[01:07:38.040 --> 01:07:45.080]  Допустим добавим такое условие.
[01:07:45.640 --> 01:07:49.640]  Если в старшей бите команды
[01:07:49.640 --> 01:08:19.400]  Стоит эта единичка и, допустим,
[01:08:20.360 --> 01:08:26.440]  то выполняется эта команда тогда и только тогда, когда зервь флаг установлен.
[01:08:26.440 --> 01:08:53.320]  И старший бит не установлен, значит мы эту команду исполним безусловно и всегда.
[01:08:56.440 --> 01:09:04.840]  То есть там стоит нолик, скобочки.
[01:09:18.840 --> 01:09:20.120]  Убираем старший битик.
[01:09:27.080 --> 01:09:33.560]  С помощью вот такой маски все остальное осталось тем же самым.
[01:09:33.560 --> 01:09:39.160]  Сомневаешься? Оставь скобки.
[01:09:39.160 --> 01:09:45.560]  Если тебе не очевидно, значит хотя бы лечитаемость эта нужна.
[01:09:45.560 --> 01:09:53.640]  И все остальное осталось тем же самым.
[01:09:54.360 --> 01:09:59.400]  И мы запросто приделали условное исполнение, сохранив обратно совместимость.
[01:09:59.400 --> 01:10:07.240]  Вот так мы взяли и сделали свой процессор.
[01:10:07.240 --> 01:10:10.440]  Вот примерно об этом и будет следующий контест.
[01:10:10.440 --> 01:10:23.240]  Атаковать с помощью переполнения буфера, быстро перемножить матрицы и написать свой процессор.
[01:10:23.240 --> 01:10:29.080]  И мы уже вплотную подошли к ассамблеру.
