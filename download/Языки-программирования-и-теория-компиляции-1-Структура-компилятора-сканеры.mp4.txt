[00:00.000 --> 00:12.360]  Так, всем доброго дня. Нам надо перестраиваться. У нас в этот раз лекции в 12.20, а не в 11.30,
[00:12.360 --> 00:18.840]  поэтому доброе утро уже не скажешь. Давайте еще раз познакомимся, особенно для тех,
[00:18.840 --> 00:24.920]  кто будет смотреть меня в YouTube внезапно. Меня зовут Ахтямов Павел. И, как ни странно,
[00:24.920 --> 00:33.480]  мы продолжаем с вами изучать всякие разные технические вещи. Формально этот курс называется
[00:33.480 --> 00:40.440]  «Языки программирования и теории компиляции». Еще одно формальное название этого курса – «Теории
[00:40.440 --> 00:47.760]  языков программирования и компиляции». Тут могут быть люди, которые записаны на два курса,
[00:47.760 --> 00:57.040]  разных совсем. По факту это курс по компиляторам. Что мы будем с вами делать? Мы будем на лекциях
[00:57.040 --> 01:03.320]  изучать то, как пишутся компиляторы. На практике мы будем смотреть практически кейсы того,
[01:03.320 --> 01:15.880]  как эти компиляторы писать, основные аспекты. Лекции у нас здесь. Семинары 15.30 будут где-то
[01:15.880 --> 01:30.200]  там наверху. Сегодня? Да, сегодня. То есть у нас все занятия будут в один день. В 15.30 что у
[01:30.200 --> 01:51.560]  нас в расписании? Да ладно. Да, через пару. Там тоже типа должно быть. А, и вот так, но там
[01:51.560 --> 02:11.400]  стоит? Понятно. Ладно, будем что-нибудь думать с этим. Там блоки по выбору скорее всего, если дальше
[02:11.400 --> 02:16.720]  промотать в этих блоках по выбору, там скорее всего будут тоже языки программирования и компиляции.
[02:16.720 --> 02:30.600]  Этот курс является курсом по выбору одним весом? Нет, странно. Ну ладно. Понятно. Ладно,
[02:30.600 --> 02:37.600]  короче будем разбираться. Значит, курс будет о теории компиляторов и про практику написания
[02:37.600 --> 02:42.840]  компиляторов. Сразу скажу, что этот курс совместный. Я предполагаю, что все так или
[02:42.840 --> 02:56.840]  иначе проходили курс формальных языков. Все проходили? Да, хорошо. Я пишу скринкаст. Да,
[02:56.840 --> 03:05.360]  нормально, да. Вот, собственно нам это понадобится, но понадобится на самом деле не в большом количестве
[03:05.360 --> 03:13.760]  случаев. Давайте тогда я спрошу следующие вещи. Там на самом деле будет некоторая сведения из курсов,
[03:13.760 --> 03:21.520]  которые нужны. Этот курс на самом деле является такой квинтэссенцией нескольких курсов. Наверное,
[03:21.520 --> 03:26.600]  люди с третьего курса знают, что есть такое понятие как функкан, функциональный анализ,
[03:26.600 --> 03:35.160]  который требует сведения из разных курсов. Здесь как раз такая же история. Нам нужно будут
[03:35.160 --> 03:39.720]  формальные языки и трансляции для того, чтобы понимать, как работают регулярные выражения,
[03:39.720 --> 03:45.560]  конечные автоматы и кс-громантики. И как ни странно, нам нужно будет понимание того,
[03:45.560 --> 03:54.960]  как работает алгоритм парсинга. Хорошо работает. Не, а как именно конфликты разрешаете и так далее.
[03:54.960 --> 04:03.160]  Этот кейс мы с вами продвинемся и научимся как раз пробовать разрешать эти конфликты на уровне
[04:03.160 --> 04:09.760]  не того, что типа есть конфликт этот или нету этого конфликта, а на уровне того, собственно,
[04:09.760 --> 04:15.800]  каким образом грамматики перестраивать, чтобы не было этих конфликт. Тема с однозначными
[04:15.800 --> 04:22.320]  грамматиками, если кто ее не забыл, она будет крайне полезной. Заодно мы рассмотрим с вами
[04:22.320 --> 04:31.280]  еще один алгоритм парсинга, который сильно проще, чем LR0, это алгоритм LL. Мы тоже его
[04:31.280 --> 04:37.760]  рассмотрим и, наверное, с этого года будут возможны разные реализации языков программирования,
[04:37.760 --> 04:49.720]  поэтому попробуем такой эксперимент. В принципе, можно. Кстати, про пеги можно
[04:49.720 --> 04:54.800]  тоже поговорить. Это, на самом деле, базовая вещь, на которой мы будем заострять первые два
[04:54.800 --> 04:59.920]  занятия. Дальше нам внезапно понадобится курс по технологиям программирования или, на самом
[04:59.920 --> 05:06.760]  деле, того, как грамотно организовывать код, потому что кода будет много, сразу предупреждаю.
[05:06.760 --> 05:19.320]  С учетом того, сколько ты мне уже сдал практиками по интерпретаторам, может быть и нет.
[05:19.320 --> 05:32.160]  Наверное, не побьет, но если только ты компилятор до конца не доведешь.
[05:32.160 --> 05:40.240]  Вот, значит, вводные сведения о компиляции проектов нам тоже понадобятся, потому что нам
[05:40.240 --> 05:44.960]  нужно будет понимать, как работают системы сборки. Дальше, как ни странно, как мы все
[05:44.960 --> 05:51.200]  преобразуем, нам понадобятся алгоритмы. Все знают алгоритмы? Наверное, не один экзамен уже сдали по алгоритмам.
[05:51.200 --> 06:10.480]  А, понятно. Ладно. Хорошо. Алгоритмы, преимущественно, нам понадобится алгоритмограф, как ни странно.
[06:11.320 --> 06:18.120]  Причем, кажется, что компиляторы, какие тут алгоритмы на графах. На самом деле, они есть.
[06:18.120 --> 06:31.280]  Мы будем говорить про статистические методы оптимизации, но машинку мы прикручивать туда не будем.
[06:31.280 --> 06:49.120]  И последняя вещь. Наверное, у кого-то этот курс уже прошел. Это курс по операционным
[06:49.120 --> 06:56.160]  системам. У кого-то он еще идет. Наверное, я не знаю, сейчас на АКОСе до сих пор на ассемблере пишут?
[06:56.160 --> 07:06.160]  Это, как ни странно, окажется полезным. Мы понятно, что на уровне ассемблера спускаться не будем.
[07:06.160 --> 07:19.680]  Коллинг-конвеншнс было бы неплохо знать. На самом деле, мы его писать не будем, скорее всего, в базовом варианте.
[07:19.680 --> 07:30.640]  Здесь есть такая слайд, для тех, кто раньше формальные языки были не у всех. Что делать, если я внезапно все забыл?
[07:31.600 --> 07:38.320]  На самом деле, раньше был ответ страдать. Но, как ни странно, основные сведения мы будем разбирать на лекциях в семинарах.
[07:38.320 --> 07:48.320]  И будет список литературы, с которым можно будет подчеркнуть эту всю информацию. Сразу скажу, курс в лекциях чуть более теоретический.
[07:48.320 --> 07:54.560]  На практике он будет, конечно же, практический. Большая часть будет явно практической.
[07:55.520 --> 08:04.160]  Поэтому можно будет подчеркнуть необходимую информацию. Так, этот слайд я пропущу, чтобы я его на ютубе не полил.
[08:04.160 --> 08:11.120]  Давайте поговорим про литературу. На курсе по формальным языкам мы это опустили, но на самом деле здесь это будет крайне полезным.
[08:11.120 --> 08:17.840]  Есть, так или иначе, три-четыре фундаментальных книги, которые можно что-то исследовать.
[08:18.720 --> 08:29.920]  Первая книга называется Engineering Compiler. Это, как мне кажется, одна из самых современно прикладных книг по компиляторам.
[08:29.920 --> 08:34.880]  Причем в ней есть еще и теоретические основы. Причем хорошо достаточно описаны.
[08:34.880 --> 08:41.120]  Я не знаю, сейчас можно ее достать или нет. Честно, потому что раньше я ее доставал в библиотеке Урэйле.
[08:41.360 --> 08:49.200]  Наверное, слышали такой. Слышали издателя Урэйле? Они раньше еще любили на заставке всяких животных закидывать.
[08:49.200 --> 08:54.480]  Собственно, книга достаточно популярная. Теория с практическими примерами.
[08:54.480 --> 09:00.320]  Вторая книга, которая здесь бывает, это вот такая вот.
[09:00.320 --> 09:12.880]  Это вот, собственно, если кто-то пытался каким-то образом когда-то проходить курс по компиляторам, то обычно по ней читается большее количество книжек, большее количество компиляторов.
[09:12.880 --> 09:22.800]  По крайней мере, раньше на кафедре Абби, которая я сейчас не знаю, как называется, у нее есть сейчас же какое-то название у кафедры Абби, или они?
[09:22.800 --> 09:24.800]  Идиоты.
[09:25.280 --> 09:35.200]  Вот. Собственно, там раньше был курс по компиляторам, он был годовой, и как раз в нем все разбиралось по этой книге.
[09:35.200 --> 09:43.360]  Просто такая вот. Мостановская книга, 400 страниц. Причем эта книга, образно говоря, 2002 года. Садитесь, делайте, так сказать.
[09:43.920 --> 09:47.360]  Мы, понятно, что не все время будем опираться на нее.
[09:47.360 --> 10:03.120]  Так, собственно, эту книгу я, наверное, покажу. Скажу, что она существует. Она называется Dragon Book, потому что на заголовке написан нарисован дракон.
[10:03.120 --> 10:13.120]  Да, но на самом деле книга хорошая, и книга именно хорошая, теоретическая книга. Но для практики, к сожалению, она сейчас уже особо не подходит.
[10:13.120 --> 10:19.120]  Вот. Я не знаю. Кто-нибудь пытался читать ее, может быть?
[10:19.120 --> 10:23.120]  Нет, я не буду знать, кто пытался читать.
[10:23.120 --> 10:33.120]  Да, причем хочу сказать, что у Аха Уйма бывают две книги. То есть первая про формальные языки и про парсер, а эта чисто для про написание компиляторов.
[10:33.120 --> 10:41.120]  Ну, она вот такая вот. То есть она толще, чем мой ноутбук, в три раза где-то. Вот такая постодонская история.
[10:41.120 --> 10:48.120]  Четвертая книга, которая здесь есть. Значит, здесь я буду, опять же, альтернативно предлагать две книги.
[10:48.120 --> 10:54.120]  Значит, первая это Flexibizon. Это для тех любителей, кто хочет вот прямо пострадать, так сказать.
[10:54.120 --> 10:55.120]  А?
[10:55.120 --> 10:56.120]  Флексить.
[10:56.120 --> 11:02.120]  Да. И вторая книга, которая будет, это будет книга Panteler.
[11:02.120 --> 11:17.120]  Да. Главное, хочу сказать следующее, что несмотря на то, что язык, который написан, называется Anteler, собственно, там реализовывается LR-алгоритм.
[11:17.120 --> 11:22.120]  А расшифровывается это, как и Nazar Language Cognition Tool.
[11:23.120 --> 11:24.120]  Вот.
[11:27.120 --> 11:33.120]  Да. Значит, смотрите. Теперь давайте расскажу, что мы будем стараться делать.
[11:33.120 --> 11:37.120]  Значит, у нас цель на выходе будет реализовать компилятор упрощенного языка программирования.
[11:37.120 --> 11:48.120]  Значит, будет два пути. Первый будет более продвинутый, и, значит, нам нужно будет пройти все стадии сложного пути, как минимум, один раз.
[11:48.120 --> 11:53.120]  И путь проще, это сделать строивание языка в язык промежуточного представления.
[11:53.120 --> 11:59.120]  Промежуточного представления, ну, любого промежуточного представления я беру в качестве примера, это LLVM.
[11:59.120 --> 12:05.120]  Теперь по формату выполнения заданий. Значит, задания будут идти итеративно.
[12:05.120 --> 12:17.120]  То есть мы будем, первая наша цель будет все время это довести образно говоря какой-то базовый интерпретатор до трансляции в LLVM, а потом его обрастать мясом.
[12:17.120 --> 12:27.120]  То есть сначала нам нужно просто пройти всю эту цепочку для того, чтобы быстро продвинуться в наши задачи, потом мы будем уже собственно внедрять системы типов и так далее.
[12:27.120 --> 12:37.120]  Вот, сразу скажу, что проект можно будет выполнять в командах. Я еще подумаю по командам, по сколько человек это будет.
[12:37.120 --> 12:42.120]  Потому что иногда одного этого сделать практически нереально.
[12:42.120 --> 12:48.120]  Да, ну, у команды два-три человека, но сразу скажу, что для двух человек еще можно будет делать строивание в LLVM.
[12:48.120 --> 12:55.120]  Если вы подписываетесь на три человека в команде, то придется пройти полный путь.
[12:55.120 --> 13:00.120]  Ну, это да.
[13:00.120 --> 13:10.120]  Вот. Наверное, чтобы вы понимали, как вам идея такая, что я на ахчеке сразу выложу формулировки заданий, тем более они с прошлого года остались.
[13:10.120 --> 13:17.120]  Сразу выложу формулировки, чтобы вы поняли, куда мы в итоге движемся.
[13:17.120 --> 13:22.120]  Хорошо. Так, давайте, наверное, организационные вопросы.
[13:22.120 --> 13:29.120]  Так, давайте про пары этого не будем говорить. Давайте в тройках нельзя будет свернуть в LLVM.
[13:29.120 --> 13:37.120]  С двойками посмотрим. То есть, готовьтесь к тому, что если вы делаете в одного из двух пар, то вы будете в тройках.
[13:37.120 --> 13:42.120]  Если вы делаете в одного из двух пар, то вы будете в тройках.
[13:43.120 --> 13:50.120]  Если вы делаете в одного, то у вас будут какие-то простые вещи.
[13:50.120 --> 13:57.120]  Если вы работаете вдвоем, то у вас будут некоторые усложнения к заданиям.
[13:57.120 --> 14:03.120]  Если вы работаете втроем, то мы движемся по полному пути.
[14:03.120 --> 14:07.120]  Давайте примеры усложнений, которые будут в парных проектах.
[14:07.120 --> 14:14.120]  Допустим, первое задание, которое у нас будет, это будет прикрутить сканеры и парсеры.
[14:14.120 --> 14:17.120]  Прикрутить парсеры. Так вот, в чем отличия будут?
[14:17.120 --> 14:23.120]  Отличие будет в том, что для первых и одиночных проектов будет достаточно прикрутить парсер.
[14:23.120 --> 14:28.120]  А для парных проектов нужно будет прикрутить в ошибках компиляции, в каком месте она происходит.
[14:28.120 --> 14:31.120]  То есть, такой механизм под названием locations.
[14:31.120 --> 14:34.120]  То есть, нужно будет отслеживать, где именно происходит ошибка компиляции.
[14:34.120 --> 14:39.120]  Это достаточно популярная практика. Вы видели языки программирования.
[14:39.120 --> 14:44.120]  Особенно, кстати, современные языки, они подсвечивают даже участок кода.
[14:44.120 --> 14:47.120]  Выдирают от участка кода и его подсвечивают.
[14:57.120 --> 15:00.120]  Поэтому можно будет делать проект вдвоем.
[15:00.120 --> 15:04.120]  По-моему, это все, что касается организации организационных вопросов.
[15:04.120 --> 15:08.120]  Поэтому давайте, наверное, остановимся здесь.
[15:08.120 --> 15:11.120]  Есть вопрос по организации?
[15:11.120 --> 15:13.120]  Семинары.
[15:13.120 --> 15:17.120]  Семинары, что с ними? Да, надо будет решить этот вопрос.
[15:17.120 --> 15:21.120]  Чуть раньше закончим сегодня и порешаем этот вопрос.
[15:21.120 --> 15:24.120]  Возможно, найдем слот.
[15:24.120 --> 15:27.120]  Так, давайте тогда двигаться дальше.
[15:28.120 --> 15:33.120]  Какой-нибудь тулу, конечно, мы помним.
[15:33.120 --> 15:37.120]  Типа антеллера или типа пигена?
[15:57.120 --> 16:03.120]  Я сейчас как раз про цепочку буду эту говорить.
[16:03.120 --> 16:09.120]  Так, давайте еще организационные вопросы.
[16:09.120 --> 16:13.120]  Есть вариант оутпут в виде ассемлера?
[16:13.120 --> 16:17.120]  Ну, для отладки можно.
[16:17.120 --> 16:20.120]  Нет, аутпут в виде ассемлера?
[16:20.120 --> 16:24.120]  Ну, аутпут в виде ассемлера это как раз сложный путь.
[16:24.120 --> 16:28.120]  В сложном пути как раз наша цель дойти будет до ассемлерного...
[16:28.120 --> 16:30.120]  Еще тебе прикол в искусстве детинского.
[16:30.120 --> 16:35.120]  Написать контент минус первый, который, наоборот, из-за Яры тебе язык гнели.
[16:35.120 --> 16:38.120]  Ну да, то, что...
[16:38.120 --> 16:42.120]  Ой, можно, это как декомпилятор называется.
[16:42.120 --> 16:46.120]  Так, организационные вопросы.
[16:46.120 --> 16:49.120]  Потом ты берешь все интерлоты.
[16:49.120 --> 16:52.120]  Так, ладно.
[16:52.120 --> 16:55.120]  Так, давайте продолжим все-таки.
[16:55.120 --> 17:00.120]  Так, мы пришли на курс по компиляторам.
[17:00.120 --> 17:04.120]  И, наверное, хотелось бы понять, а что же такое компилятор?
[17:04.120 --> 17:08.120]  Я не знаю, я пишу не в кофе.
[17:08.120 --> 17:11.120]  Это хороший ответ.
[17:11.120 --> 17:13.120]  Это функция.
[17:13.120 --> 17:17.120]  Да, это функция.
[17:17.120 --> 17:21.120]  Это смартфон, который переводит в программную язык, а программирование другой.
[17:21.120 --> 17:23.120]  Да, это...
[17:23.120 --> 17:26.120]  Скажешь, что X86 это тоже язык программирования?
[17:26.120 --> 17:31.120]  Нет, это ассемлерный диалект X86, это язык программирования.
[17:31.120 --> 17:35.120]  А ассемлерный диалект, который подчеркнет ассемлеру байк-код, это не компилятор что ли?
[17:35.120 --> 17:38.120]  Ну, тоже компилятор.
[17:38.120 --> 17:42.120]  А список языков программирования языков X86?
[17:42.120 --> 17:44.120]  Ну да.
[17:44.120 --> 17:47.120]  Так, давайте все-таки, чтобы это...
[17:47.120 --> 17:51.120]  Я понимаю, что у нас уже этот лекция практически в диалог превращается.
[17:51.120 --> 17:53.120]  Но давайте попробуем это.
[17:53.120 --> 17:55.120]  Компилятор это компьютерная программа.
[17:55.120 --> 17:57.120]  Определение, кстати, я взял с Википедии,
[17:57.120 --> 18:02.120]  которое транслирует код, написан на одном языке программирования, в код на другом языке программирования.
[18:02.120 --> 18:04.120]  Ну, не обязательно на языке программирования.
[18:04.120 --> 18:07.120]  Можно сказать, что и в машинный код, при желании.
[18:07.120 --> 18:10.120]  Так, давайте примеры, ГЦЦ.
[18:11.120 --> 18:13.120]  Откуда-куда?
[18:13.120 --> 18:16.120]  А там ахзимонога-куда, а монога-куда?
[18:16.120 --> 18:18.120]  Нет.
[18:18.120 --> 18:21.120]  Именно, да, именно.
[18:21.120 --> 18:23.120]  Плюс это...
[18:23.120 --> 18:24.120]  ГЦЦ у тебя в ГЦЦ.
[18:24.120 --> 18:26.120]  ГЦЦ у тебя в ГЦЦ.
[18:26.120 --> 18:28.120]  Си, плюс, плюс.
[18:28.120 --> 18:30.120]  Ну да.
[18:30.120 --> 18:35.120]  Ну, в общем, да, из Java даже умеет.
[18:35.120 --> 18:38.120]  А в 13 версии из Rasta даже научился.
[18:38.120 --> 18:48.120]  Ну, давайте остановимся на ассемблере.
[18:48.120 --> 18:52.120]  Ну да, пока не будем.
[18:52.120 --> 18:55.120]  GDK.
[18:55.120 --> 18:59.120]  Да, откуда-куда?
[18:59.120 --> 19:04.120]  Да, из Java в Java Bytecode.
[19:04.120 --> 19:09.120]  Нет, jar это архив.
[19:09.120 --> 19:15.120]  Jar это, на самом деле, аналог DLL-ки в Windows.
[19:15.120 --> 19:20.120]  Вот, если вы реально в ВИМе откроете jar-файл, то вы увидите, что там набор классов.
[19:20.120 --> 19:22.120]  Есть.
[19:22.120 --> 19:23.120]  Так, ладно.
[19:23.120 --> 19:26.120]  CoffeeScript, блин, я забываю каждый раз подправить презентацию,
[19:26.120 --> 19:30.120]  поэтому давайте будем считать, что здесь не CoffeeScript, а TypeScript.
[19:30.120 --> 19:35.120]  Кто знаком, что такое TypeScript?
[19:35.120 --> 19:39.120]  TypeScript со строгой интерфейсации.
[19:39.120 --> 19:44.120]  Да, из TypeScript в JavaScript.
[19:44.120 --> 19:51.120]  Есть еще всякие ВИМ-компиляторы, которые компилируют Rasta в WebAssembly.
[19:51.120 --> 19:56.120]  Открыли черную дуру.
[19:56.120 --> 20:01.120]  Так.
[20:01.120 --> 20:04.120]  Ну, по-хорошему да.
[20:04.120 --> 20:10.120]  Python умеет на стадии препроцессинга делать трансляцию в Python Bytecode,
[20:10.120 --> 20:15.120]  который он потом интерпретирует.
[20:15.120 --> 20:18.120]  Да, в PyC.
[20:18.120 --> 20:22.120]  Но давайте я скажу проще, чтобы все воспринимали,
[20:22.120 --> 20:27.120]  что по умолчанию Python все-таки считается интерпретатором.
[20:27.120 --> 20:32.120]  Хотя, по-моему, уже...
[20:32.120 --> 20:39.120]  Ну да, если мы в Python говорим Python, там сначала Python Bytecode,
[20:39.120 --> 20:42.120]  потом он уже интерпретируется.
[20:42.120 --> 20:44.120]  Вот, поэтому вот так.
[20:44.120 --> 20:46.120]  Что такое интерпретатор?
[20:46.120 --> 20:48.120]  Тоже заговорим, что это компьютерная программа,
[20:48.120 --> 20:51.120]  которая выполняет инструкции без компиляции в машины язык.
[20:51.120 --> 20:53.120]  Вот, ну давайте будем считать так.
[20:53.120 --> 20:57.120]  Так, а теперь, наконец-таки, начнем с того, собственно,
[20:57.120 --> 20:59.120]  каким образом выглядят все компиляторы.
[20:59.120 --> 21:02.120]  Значит, у нас есть обычно входная программа,
[21:02.120 --> 21:06.120]  которую мы подаем код в frontend.
[21:06.120 --> 21:10.120]  Значит, это часть кода, часть компилятора,
[21:10.120 --> 21:13.120]  которая должна код на нашем языке программирования
[21:13.120 --> 21:16.120]  превратить в некоторое промежуточное представление,
[21:16.120 --> 21:18.120]  которое будет одинаковое для всех языков программирования.
[21:18.120 --> 21:22.120]  Независимо от того, какой код это вставил.
[21:22.120 --> 21:25.120]  Дальше, значит, у нас с вами есть оптимизатор,
[21:25.120 --> 21:30.120]  который берет код на языке промежуточного представления
[21:30.120 --> 21:32.120]  и оптимизирует его.
[21:32.120 --> 21:36.120]  То есть обычно оптимизация происходит не на стадии того,
[21:36.120 --> 21:41.120]  что вы читаете код, и у вас написано там int x равно a умножить на 2.
[21:41.120 --> 21:44.120]  В этом моменте очень сложно преобразовать.
[21:44.120 --> 21:49.120]  А проще, когда мы уже переходим в набор каких-то более простых инструкций.
[21:49.120 --> 21:54.120]  После этого у нас получается на выходе результат промежуточного представления
[21:54.120 --> 21:55.120]  с оптимизированным кодом.
[21:55.120 --> 21:58.120]  И дальше у нас начинает срабатывать стадия back-end,
[21:58.120 --> 22:04.120]  которая берет и транслирует этот код уже под, так сказать,
[22:04.120 --> 22:06.120]  определенную архитектуру процессора.
[22:06.120 --> 22:10.120]  То есть именно мы превращаем все это в диалект ассемблера.
[22:10.120 --> 22:14.120]  Еще раз front-end. Мы транслируем промежуточное представление.
[22:14.120 --> 22:18.120]  Оптимизер мы оптимизируем промежуточное представление.
[22:18.120 --> 22:23.120]  И back-end это транслируется промежуточного представления в исполняемый код.
[22:23.120 --> 22:28.120]  Сразу такой вопрос, который я хочу задать.
[22:28.120 --> 22:32.120]  Кто здесь вставил пакеты из PIP?
[22:32.120 --> 22:36.120]  Это Python Package Manager.
[22:36.120 --> 22:41.120]  Хорошо. Есть ли там особенность как раз от того,
[22:41.120 --> 22:44.120]  откуда у вас качается пакет?
[22:44.120 --> 22:49.120]  Там есть дополнительный чемодан под своей указательностью.
[22:49.120 --> 22:52.120]  Смотрите.
[22:52.120 --> 22:58.120]  Кстати, у меня вообще PIP-пакеты унесены в обычной репетитории.
[22:58.120 --> 23:01.120]  Да, смотрите. Вот у вас есть пакет.
[23:01.120 --> 23:03.120]  И давайте какой-нибудь пакет откроем.
[23:03.120 --> 23:06.120]  Json это системный пакет.
[23:06.120 --> 23:08.120]  Давайте NumPy.
[23:08.120 --> 23:11.120]  Кстати, NumPy мне кажется будет прямо визуально.
[23:11.120 --> 23:15.120]  О, господи. Там же второй NumPy скоро выйдет.
[23:15.120 --> 23:20.120]  Обратной совместимости не будет.
[23:20.120 --> 23:24.120]  Так. И смотрите. Здесь есть вот такая вещь.
[23:24.120 --> 23:27.120]  Download.
[23:27.120 --> 23:30.120]  И смотрите, что здесь есть.
[23:30.120 --> 23:33.120]  Здесь есть вилпакеты.
[23:33.120 --> 23:36.120]  И здесь есть так называемая тройка.
[23:36.120 --> 23:39.120]  Собственно, это операционная система,
[23:39.120 --> 23:41.120]  в которой вы это все запускаете.
[23:41.120 --> 23:43.120]  Архитектура процессора.
[23:43.120 --> 23:50.120]  И в Python еще используется такое понятие, как этот.
[23:50.120 --> 23:55.120]  Как правильно сказать? Backend, под который написан этот питон.
[23:55.120 --> 23:59.120]  То есть, видите, здесь CP312.
[23:59.120 --> 24:03.120]  Это значит, что этот код, вот этот установочник
[24:03.120 --> 24:06.120]  работает в CPython 312.
[24:06.120 --> 24:09.120]  Опять же, есть Pypy.
[24:09.120 --> 24:11.120]  Вот это вот питоновские, которые.
[24:11.120 --> 24:13.120]  То есть, видите, в зависимости от того,
[24:13.120 --> 24:17.120]  есть ли у вас Python 312,
[24:17.120 --> 24:21.120]  есть ли у вас под капотом код на сях,
[24:21.120 --> 24:25.120]  у вас будут устанавливаться разные версии пакет.
[24:25.120 --> 24:27.120]  И, собственно, в чем цель pipa?
[24:27.120 --> 24:30.120]  Цель pipa, когда вы пишете pip install,
[24:30.120 --> 24:33.120]  это обратиться в этот пакетный менеджер,
[24:33.120 --> 24:36.120]  узнать, какая версия у вас операционной системы,
[24:36.120 --> 24:38.120]  какая версия питона,
[24:38.120 --> 24:42.120]  какая версия под капотом CPython либо Pypy
[24:42.120 --> 24:46.120]  и выбрать правильный дистрибутив.
[24:46.120 --> 24:49.120]  То есть, видите, в зависимости от бэкэнда
[24:49.120 --> 24:51.120]  все может сильно отличаться.
[24:51.120 --> 24:56.120]  Значит, да.
[24:56.120 --> 25:00.120]  Ну, собственно, если это написано в проекте.
[25:00.120 --> 25:03.120]  Обычно все-таки стараются готовить
[25:03.120 --> 25:05.120]  правильный установочник, который не надо компилизовать
[25:05.120 --> 25:07.120]  в процессе установки.
[25:07.120 --> 25:11.120]  Потому что сидеть, значит, мы пишем pip install,
[25:11.120 --> 25:13.120]  при этом указываем какие-нибудь переменные
[25:13.120 --> 25:15.120]  окружения сборки под CMake перед этим.
[25:15.120 --> 25:17.120]  Я, кстати, с этим столкнулся недавно,
[25:17.120 --> 25:19.120]  когда я запускал большую языковую модель
[25:19.120 --> 25:21.120]  на своем компьютере.
[25:21.120 --> 25:23.120]  Да, что такое большая языковая?
[25:23.120 --> 25:28.120]  Оно самое.
[25:28.120 --> 25:30.120]  Что такое большая языковая модель?
[25:30.120 --> 25:36.120]  Это то, что используются аналоги модели чат ГПТ.
[25:36.120 --> 25:38.120]  Пришлось.
[25:38.120 --> 25:40.120]  Собственно, там вот этот миндинг,
[25:40.120 --> 25:43.120]  который был LAM и CPTPython, нам пришлось
[25:43.120 --> 25:47.120]  export use force CMake единичка,
[25:47.120 --> 25:52.120]  export CMake args равно токенная строка.
[25:52.120 --> 25:54.120]  Потом только pip install.
[25:54.120 --> 25:56.120]  То есть через переменные окружения все,
[25:56.120 --> 25:58.120]  пришлось прокидывать.
[26:06.120 --> 26:09.120]  Ну ладно, мы уже немножко отклоняемся от темы.
[26:09.120 --> 26:11.120]  Чем удобна такая структура?
[26:11.120 --> 26:14.120]  Кто помнит технологию программирования?
[26:14.120 --> 26:20.120]  Паттерн-медиатор или паттерн-мост?
[26:20.120 --> 26:22.120]  Что такое медиатор?
[26:22.120 --> 26:24.120]  Это посредник, который перекидывает
[26:24.120 --> 26:27.120]  информацию с одной части на вторую часть.
[26:27.120 --> 26:29.120]  Что такое паттерн-мост?
[26:29.120 --> 26:33.120]  Кто помнит?
[26:33.120 --> 26:37.120]  Да, технологии программирования пошли мимо.
[26:37.120 --> 26:39.120]  Да, ну у вас-то понятно.
[26:39.120 --> 26:43.120]  Это паттерн, в котором у нас есть управляющая часть
[26:43.120 --> 26:45.120]  и управляемая часть.
[26:45.120 --> 26:47.120]  У управляющей части одна иерархия,
[26:47.120 --> 26:50.120]  у управляемой части другая иерархия классов.
[26:50.120 --> 26:54.120]  То есть связываются они через API-интерфейс.
[26:54.120 --> 26:57.120]  Кстати, тут сразу скажу, что здесь не совсем
[26:57.120 --> 26:59.120]  правильная презентация.
[26:59.120 --> 27:01.120]  У нас есть frontend.
[27:01.120 --> 27:03.120]  Аналог GCC взят.
[27:03.120 --> 27:06.120]  У нас есть cfront, у нас есть c++front,
[27:06.120 --> 27:08.120]  у нас есть fortranfront.
[27:08.120 --> 27:10.120]  Дальше мы это закидываем в промежуточное представление.
[27:10.120 --> 27:12.120]  У нас происходит оптимизатор.
[27:12.120 --> 27:15.120]  И дальше мы компилируем под определенную архитектуру.
[27:15.120 --> 27:18.120]  Собственно, это либо армовская архитектура,
[27:18.120 --> 27:20.120]  либо какой-нибудь мингвэшный компилятор.
[27:20.120 --> 27:23.120]  Я думаю, что все слышали про мингвэ
[27:23.120 --> 27:26.120]  свое собственное время, когда писали на плюсах,
[27:26.120 --> 27:28.120]  там, не знаю, свое время.
[27:28.120 --> 27:30.120]  Было такое?
[27:30.120 --> 27:32.120]  Вот. И линуксбэк, который называется
[27:32.120 --> 27:35.120]  обычный x8664-компилятор,
[27:35.120 --> 27:37.120]  который обычно ставится,
[27:37.120 --> 27:39.120]  когда вы делаете pip install g++.
[27:39.120 --> 27:42.120]  Вот. То есть чем удобна такая структура?
[27:42.120 --> 27:45.120]  Она удобна тем, что нам на самом деле достаточно
[27:45.120 --> 27:47.120]  написать какой-нибудь frontend дополнительно
[27:47.120 --> 27:49.120]  и правильно встроить в структуру Яра.
[27:49.120 --> 27:52.120]  Затем мы будем с вами и заниматься.
[27:52.120 --> 27:55.120]  А дальше оптимизаторы, если правильно
[27:55.120 --> 27:57.120]  организованная структура кода,
[27:57.120 --> 28:02.120]  то мы можем сами прикрутить определенную стадию оптимизации.
[28:02.120 --> 28:05.120]  Собственно, здравствуйте, еще один паттерн.
[28:05.120 --> 28:07.120]  Значит, это либо паттерн-билдер,
[28:07.120 --> 28:10.120]  который проходит по всем стадиям и выполняет его,
[28:10.120 --> 28:12.120]  создает нам проект,
[28:12.120 --> 28:16.120]  либо паттерн под названием шаблонный метод.
[28:16.120 --> 28:19.120]  Собственно, где у нас что-то выполняется по шаблону.
[28:19.120 --> 28:21.120]  Так.
[28:21.120 --> 28:23.120]  А мы сами будем выбирать?
[28:23.120 --> 28:27.120]  Мы работаем, если мы выбираем...
[28:27.120 --> 28:29.120]  Да.
[28:29.120 --> 28:32.120]  Да, тут можно счетерить и выбрать,
[28:32.120 --> 28:34.120]  написать все под ARM.
[28:34.120 --> 28:36.120]  Может под ARM писать все проще.
[28:42.120 --> 28:46.120]  Так, вот так не надо на мной издеваться.
[28:51.120 --> 28:54.120]  У меня тоже есть где тестить ARM.
[29:00.120 --> 29:03.120]  Да, у меня ARM процессор.
[29:05.120 --> 29:07.120]  Да, да, согласен.
[29:07.120 --> 29:09.120]  Кему решают все вопросы.
[29:13.120 --> 29:15.120]  Ну да.
[29:18.120 --> 29:21.120]  Да, в общем, давайте все-таки рассмотрим,
[29:21.120 --> 29:24.120]  из чего же обычно состоят все эти части.
[29:24.120 --> 29:27.120]  Значит, собственно, цель наших занятий
[29:27.120 --> 29:30.120]  будет это постепенно проходиться по каждой из этих частей
[29:30.120 --> 29:33.120]  и разбирать, каким образом они работают.
[29:33.120 --> 29:38.120]  Начнем с тех частей, с которыми мы с вами работали.
[29:38.120 --> 29:40.120]  Как вы думаете, какие из частей мы с вами разбирали
[29:40.120 --> 29:42.120]  на курс формальных языков?
[29:42.120 --> 29:44.120]  Первые две.
[29:44.120 --> 29:46.120]  Первые две.
[29:46.120 --> 29:48.120]  На остальные...
[29:48.120 --> 29:50.120]  На остальные...
[29:50.120 --> 29:52.120]  Ну да, да, да.
[29:52.120 --> 29:54.120]  Да.
[29:54.120 --> 29:59.120]  Так, давайте как раз мы начнем с первой части, это сканер.
[29:59.120 --> 30:02.120]  Вот представьте себе, что у нас есть такой псевдокод.
[30:02.120 --> 30:04.120]  Это псевдокод.
[30:04.120 --> 30:07.120]  То есть у нас есть переменная int a, int b, int c, int d,
[30:07.120 --> 30:09.120]  потом читаем a, b, c, d,
[30:09.120 --> 30:14.120]  делаем такой температур присваивания и пишем print a.
[30:14.120 --> 30:18.120]  Мы понимаем с вами, что код работает не таким образом.
[30:18.120 --> 30:21.120]  То, что вот он существует, отлично.
[30:21.120 --> 30:25.120]  Что мы можем с вами сделать?
[30:25.120 --> 30:29.120]  Курс формальных языков вспоминаем.
[30:29.120 --> 30:31.120]  Не-не-не, рано.
[30:31.120 --> 30:35.120]  Нам нужно выделить все ключевые слова, которые здесь есть.
[30:35.120 --> 30:37.120]  То есть все токен...
[30:37.120 --> 30:40.120]  Да, нам нужно это все токенизировать.
[30:40.120 --> 30:44.120]  Собственно, первая стадия front-end называется сканером.
[30:44.120 --> 30:46.120]  В чем она заключается?
[30:46.120 --> 30:53.120]  Каждую из составных частей разбить на так называемые токены.
[30:53.120 --> 30:55.120]  Собственно, что такое токен?
[30:55.120 --> 30:57.120]  Токен это как раз такая структура,
[30:57.120 --> 31:03.120]  внутри которой есть какая-то встроенная часть в виде текста.
[31:03.120 --> 31:05.120]  То есть токен это по факту тип.
[31:05.120 --> 31:08.120]  Вот, типа int, var, semicolon и так далее.
[31:08.120 --> 31:12.120]  Алексема это то, что как раз парсится этим токеном.
[31:12.120 --> 31:14.120]  То есть давайте мы сделаем в следующем.
[31:14.120 --> 31:16.120]  Мы понимаем, что int это скорее всего тип int,
[31:16.120 --> 31:19.120]  abcd это на самом деле var,
[31:19.120 --> 31:21.120]  точку запятой это semicolon,
[31:21.120 --> 31:23.120]  read это read, print-print,
[31:23.120 --> 31:25.120]  скобки заменяем, assign,
[31:25.120 --> 31:30.120]  двойку мы заменяем на нам и звездочку заменяем на mu.
[31:30.120 --> 31:32.120]  И смотрим, что получается.
[31:32.120 --> 31:35.120]  На самом деле у нас получается вот такая вот вещь.
[31:35.120 --> 31:38.120]  Да, причем еще и без перевода строки.
[31:38.120 --> 31:43.120]  То есть перевод строки просто для визуальной трансляции того, как это работает.
[31:43.120 --> 31:46.120]  То есть вот что мы хотим получить на выходе сканера.
[31:46.120 --> 31:51.120]  Причем я замечу, что некоторые токены, которые здесь есть, они именованные.
[31:51.120 --> 31:54.120]  То есть внутри них есть название имени.
[31:54.120 --> 32:00.120]  Вот, допустим, двойка это нам, var это b.
[32:00.120 --> 32:02.120]  Следующая часть.
[32:02.120 --> 32:05.120]  Вот у нас есть набор токенов.
[32:05.120 --> 32:07.120]  Следующая часть это парсер.
[32:07.120 --> 32:12.120]  Парсер в качестве входного алфавита, вот это важно,
[32:12.120 --> 32:16.120]  принимает токены.
[32:16.120 --> 32:21.120]  Да, то есть она принимает токены, она не принимает слова из этого алфавита.
[32:21.120 --> 32:25.120]  Ну, из входного алфавита, то есть это выход сканера.
[32:25.120 --> 32:31.120]  Вот, ну и здесь мы что должны построить, чтобы построить парсер?
[32:31.120 --> 32:33.120]  Грамматику, да.
[32:33.120 --> 32:35.120]  Причем контекст свободный.
[32:35.120 --> 32:37.120]  Что делает парсер?
[32:37.120 --> 32:41.120]  Парсер разбирает полученную грамматику, программу при помощи грамматики
[32:41.120 --> 32:43.120]  чтобы выстраивать дерево разбора.
[32:43.120 --> 32:48.120]  И здесь нужно будет специфицировать два разных видов дерева разбора.
[32:48.120 --> 32:51.120]  То дерево разбора, которое мы с вами разбирали на курсе формальных языков,
[32:51.120 --> 32:54.120]  оно никаким образом не обозначалось.
[32:54.120 --> 33:00.120]  А здесь мы для каждого правила разбора будем специфицировать его конкретный тип.
[33:00.120 --> 33:05.120]  И вот это будет называться абстрактным синтоксическим деревом разбора, ast.
[33:05.120 --> 33:10.120]  Вот пример грамматики, который парсит эти выражения.
[33:10.120 --> 33:14.120]  Программа это statement семиколон либо list statement.
[33:14.120 --> 33:19.120]  Понятно, что эта грамматика может быть неоднозначной сейчас, хотя она по идее должна быть быть однозначной.
[33:19.120 --> 33:24.120]  А list statement, дальше statement это read, assign, print и так далее.
[33:24.120 --> 33:30.120]  И здесь мы явно сразу видим структуру, что обычно программа у нас разбивается сначала на наборы стейтментов,
[33:30.120 --> 33:33.120]  а внутри стейтментов есть какие-то экспрессии.
[33:33.120 --> 33:39.120]  И в принципе это будет сохраняться еще до долгих стадий компиляции.
[33:39.120 --> 33:43.120]  То есть там в VR такая же абстракция есть.
[33:43.120 --> 33:49.120]  Lparen и rparen у нас есть.
[33:49.120 --> 33:56.120]  Понятно, что когда мы будем упрощать это все дело, у нас это будут не скобки уже, а какие-то...
[33:56.120 --> 33:59.120]  Там можно обратный маппинг сделать.
[33:59.120 --> 34:02.120]  То есть сказать, что lparen это скобки.
[34:02.120 --> 34:05.120]  Это делается в том же самом бизоне.
[34:05.120 --> 34:10.120]  Ну и вот, у нас получается дерево разбора.
[34:10.120 --> 34:15.120]  Давайте... я в какой-то момент времени рисовал, вы полюбуйтесь как...
[34:22.120 --> 34:24.120]  Вот, получаем дерево разбора грамматики.
[34:24.120 --> 34:29.120]  А дальше, когда у нас есть дерево абстракции тактического дерева разбора,
[34:29.120 --> 34:32.120]  на самом деле для того, чтобы довести его до промежуточного представления,
[34:32.120 --> 34:34.120]  нам нужно на самом деле пройти большое количество стадий.
[34:34.120 --> 34:36.120]  Нам нужно создать таблицу символов.
[34:36.120 --> 34:41.120]  То есть это такая структура данных, которая позволит по переменной понять, какой у нее тип.
[34:41.120 --> 34:47.120]  И что это такое? Класс, переменная, число и так далее.
[34:47.120 --> 34:50.120]  Дальше нам нужно будет построить систему выводов типов.
[34:50.120 --> 34:54.120]  То есть у нас ошибки компиляции могут быть на уровне сканера обнаружены,
[34:54.120 --> 34:57.120]  чтобы какой-то токен не проанализируем.
[34:57.120 --> 35:00.120]  Больше количество ошибок это синтоксических ошибок.
[35:00.120 --> 35:04.120]  Но более того, у нас есть семантические ошибки, когда у нас типы не совпали.
[35:04.120 --> 35:07.120]  И, кстати, такой вопрос.
[35:07.120 --> 35:11.120]  Переменную объявили дважды. Это какой тип ошибки?
[35:14.120 --> 35:17.120]  Это уже семантическая ошибка.
[35:18.120 --> 35:21.120]  Да, то есть нам нужно почитать...
[35:21.120 --> 35:36.120]  И дальше нам нужно будет проверить преобразование над деревом для получения промежутинного представления.
[35:36.120 --> 35:41.120]  И здесь нам как раз уже понадобится набор так называемых виртуальных регистров.
[35:41.120 --> 35:44.120]  Это более простой пример.
[35:44.120 --> 35:50.120]  На самом деле я просто взял аналог того кода, скомпилировал в VR и заменил...
[35:50.120 --> 35:57.120]  Да, только это на самом деле не чистый ЯР, а вот такой вот промежуточный.
[35:57.120 --> 36:02.120]  То есть я из него просто выкинул несколько лишних слов, чтобы было проще.
[36:02.120 --> 36:08.120]  То есть смотрите, когда мы создаем переменную, на самом деле мы ее алоцируем на стеке.
[36:13.120 --> 36:15.120]  Да, да, да.
[36:15.120 --> 36:24.120]  Смотрите, это не переменная, это виртуальный регистр называется.
[36:28.120 --> 36:38.120]  И здесь видно, что каждый раз, когда мы объявляем новый регистр, мы не можем ничего присвоить другому.
[36:38.120 --> 36:41.120]  То есть мы создаем виртуальный регистр и все.
[36:41.120 --> 36:49.120]  Да, если нам нужно записать ячейку в какой-нибудь другой виртуальный регистр, здесь есть операция Store, которая это делает.
[36:49.120 --> 36:54.120]  Я вижу, что это старая версия VR, потому что поинтер непрозрачный.
[36:54.120 --> 36:57.120]  Ну да.
[37:03.120 --> 37:12.120]  Тут тоже по усмотрению. Обычно берется мини-версия Джавы, либо какой-нибудь C.
[37:12.120 --> 37:15.120]  Да, C++ с простыми классами.
[37:15.120 --> 37:17.120]  C++?
[37:17.120 --> 37:22.120]  Да. Я бы так сказал, да, C++.
[37:22.120 --> 37:27.120]  Видите, кстати, вопрос такой, который я хочу задать.
[37:27.120 --> 37:30.120]  Чем более удобно это представление?
[37:30.120 --> 37:32.120]  Это не дерево.
[37:32.120 --> 37:36.120]  Это не дерево, это линейная структура кода, которую можно выполнить.
[37:36.120 --> 37:39.120]  Более того, у нее есть заранее определенный набор правил.
[37:39.120 --> 37:51.120]  То есть в принципе, насколько я понимаю, если мы забиваем на вот эти вот команды, которые у нас есть, то в принципе это даже что-то похожее на автоматность.
[37:51.120 --> 37:54.120]  То есть их легко распознать именно последовательно.
[37:54.120 --> 37:59.120]  То есть по факту мы получаем с вами на халяву правилинейную грамотику.
[37:59.120 --> 38:01.120]  Ну да.
[38:01.120 --> 38:04.120]  Да.
[38:04.120 --> 38:05.120]  Вот.
[38:05.120 --> 38:10.120]  Значит, дальше, после того, как мы это пройдем, мы будем проходить про оптимизацию.
[38:10.120 --> 38:12.120]  Ну здесь, конечно, простая оптимизация.
[38:12.120 --> 38:16.120]  И здесь видно, что это оптимизация уже на уровне ассамблярных команд.
[38:16.120 --> 38:21.120]  То есть видите, мы вычисляем A на 2 на B на C на D в большом количестве циклов.
[38:21.120 --> 38:27.120]  То в принципе мы можем попробовать вынести эту переменную до и попробовать вычислять.
[38:27.120 --> 38:30.120]  Там прямо можно будет посмотреть, собственно.
[38:30.120 --> 38:35.120]  Видите, A на 2 на B на C на D на самом деле раскладывается вот в такую портянку.
[38:41.120 --> 38:45.120]  Ну, это не те методы оптимизации.
[38:45.120 --> 38:47.120]  Да.
[38:47.120 --> 38:51.120]  И последние части компиляторов, которые есть, это выбор инструкций,
[38:51.120 --> 38:54.120]  аллокация регистров и составление расписания инструкций.
[38:54.120 --> 38:56.120]  Давайте тоже поговорим про эти части.
[38:56.120 --> 38:59.120]  Мы, опять же, каждый случай будем разбирать отдельно.
[38:59.120 --> 39:03.120]  В выбор инструкций задача данного этапа будет взять набор инструкций,
[39:03.120 --> 39:07.120]  которые у нас имеется на входе, и перестроить ее под определенную архитектуру.
[39:07.120 --> 39:12.120]  Потому что в разных архитектурах процессора бывают разные наборы ассамблярных команд.
[39:12.120 --> 39:16.120]  То есть здесь мы, опять же, при выборе инструкций говорим,
[39:16.120 --> 39:20.120]  что число регистров может быть бесконечным.
[39:20.120 --> 39:23.120]  Ну и тут возможна базовая трансформация,
[39:23.120 --> 39:27.120]  к которой, конечно, уже заточено, смотрите, под определенную версию компилятора,
[39:27.120 --> 39:31.120]  потому что где-то операция умножения на два работает быстро,
[39:31.120 --> 39:35.120]  где-то это надо трансформировать в операцию плюс,
[39:35.120 --> 39:38.120]  а где-то это нужно трансформировать во что?
[39:38.120 --> 39:40.120]  В битовый сдвиг.
[39:40.120 --> 39:45.120]  То есть, опять же, тут уже возникает задача, кстати, как ни странно, оптимизации.
[39:45.120 --> 39:47.120]  Причем дискретной оптимизации.
[39:47.120 --> 39:54.120]  То есть нужно будет покрыть дерево таким образом, чтобы оно было меньше...
[39:54.120 --> 39:57.120]  Кажем, мало на физики инструкций.
[39:57.120 --> 39:59.120]  Да.
[39:59.120 --> 40:06.120]  Следующая стадия как раз понадобит ценам здесь алгоритма.
[40:06.120 --> 40:08.120]  Это локация регистров.
[40:08.120 --> 40:10.120]  Что делает этот этап?
[40:10.120 --> 40:16.120]  Задача этого этапа заключается в том, чтобы виртуальные регистры перевести в реальные.
[40:16.120 --> 40:21.120]  Вопрос к вам, как людям, которые прошли курс по аквозу,
[40:21.120 --> 40:23.120]  по крайней мере, первый семестр.
[40:23.120 --> 40:27.120]  Сколько регистров есть в разных архитектурах, которые можно использовать?
[40:27.120 --> 40:29.120]  Конечное количество.
[40:29.120 --> 40:31.120]  16, 20 до 2.
[40:31.120 --> 40:35.120]  Ну, это в армии.
[40:35.120 --> 40:38.120]  На 86, а потом на 6.
[40:38.120 --> 40:41.120]  Ну, а сколько из них реально можно использовать нормально?
[40:41.120 --> 40:43.120]  Ну, 6-6.
[40:43.120 --> 40:45.120]  Ну, там же Колинка меньше сильно режет.
[40:45.120 --> 40:47.120]  Да-да-да.
[40:47.120 --> 40:49.120]  6.
[40:49.120 --> 40:57.120]  Ну, в лучшем случае очень странные операции.
[40:57.120 --> 40:59.120]  Вот.
[40:59.120 --> 41:01.120]  А теперь знатоки.
[41:01.120 --> 41:08.120]  Знаете такое понятие, как хроматическое число графа?
[41:08.120 --> 41:12.120]  Это количество цветов, которые нужно покрасить граф,
[41:12.120 --> 41:17.120]  для того, чтобы никакие два ребра не были покрашены в один цвет.
[41:17.120 --> 41:23.120]  Ну вот, как раз наша задача будет оценить, можем ли мы покрасить граф разные цвета.
[41:23.120 --> 41:30.120]  Собственно, вершины будут это регистры виртуальные, ребра, это могут ли они одновременно существовать.
[41:30.120 --> 41:35.120]  И нужно будет как раз разбирать, можем ли мы этот граф покрасить.
[41:35.120 --> 41:40.120]  Сразу скажу, что Uber-мега-жёстких алгоритмов не будет, там будет тупой жадный алгоритм.
[41:40.120 --> 41:46.120]  Но в целом нужно будет понять, каким образом это решать.
[41:46.120 --> 41:57.120]  Если у нас алгоритм не справляется успешно, мы тратим наши ресурсы на то, чтобы скинуть эту переменную виртуальную регистр в память.
[41:57.120 --> 42:04.120]  Но это уменьшает скорость нашей программы.
[42:04.120 --> 42:06.120]  Увеличивает задержку.
[42:06.120 --> 42:08.120]  А?
[42:08.120 --> 42:14.120]  Не, алгоритма достаточно.
[42:14.120 --> 42:20.120]  Вот, кстати, пример превращения этого кода.
[42:20.120 --> 42:29.120]  То есть вот тут был один код, и здесь видите, всего вместо шести регистров, которые были отведены под каждую перемену ABCD,
[42:29.120 --> 42:38.120]  ARP это, по-моему, что-то типа фреймпоинтера, то есть это указатель на начало стека.
[42:38.120 --> 42:42.120]  Их, оказывается, можно превратить в всего три регистра.
[42:42.120 --> 42:47.120]  Если посмотреть код. Ну, собственно, презентацию можно сделать.
[42:47.120 --> 42:52.120]  Ну и, собственно, последняя вещь, это про конвейерность.
[42:52.120 --> 43:00.120]  Обычно про нее не говорят, но желательно правильно выстроить инструкцию таким образом, чтобы они правильно встали в конвейер процессора.
[43:00.120 --> 43:06.120]  То есть какие-то для чтения, какие-то для запись, какие-то для вычислений.
[43:06.120 --> 43:10.120]  Но мы как раз про это детально говорить не будем.
[43:10.120 --> 43:16.120]  Так, это что касается стадии компиляции. Есть ли вопросы?
[43:20.120 --> 43:27.120]  Хорошо, тогда давайте мы сегодня начнем с... Закончим нашу лекцию первой темой, такой фундаментальной.
[43:27.120 --> 43:37.120]  И вам тут сейчас настанут некоторые флешбеки, из предыдущего семестра, во что мы будем говорить про сканеры.
[43:37.120 --> 43:41.120]  Но на самом деле мы немножко их адаптируем к нашим вещам.
[43:41.120 --> 43:44.120]  Да, это, кстати, основные пункты поведения.
[43:44.120 --> 43:48.120]  Слушайте, еще раз мы с вами...
[43:54.120 --> 43:58.120]  Сейчас параллельно курс идет по хайлоду.
[43:58.120 --> 44:01.120]  Так, там более правильное определение фронтэнта.
[44:01.120 --> 44:06.120]  Там фронтэнту даже относится NGINX в веб-сервер.
[44:06.120 --> 44:11.120]  То есть все, что на уровне до веб-серверов, это прямо фронтэнтом считается.
[44:17.120 --> 44:21.120]  NGINX написано не на JavaScript, явно уж точно.
[44:24.120 --> 44:27.120]  Более того, на фронтэнде можно сделать авторизацию.
[44:27.120 --> 44:29.120]  Внешние проверки.
[44:29.120 --> 44:33.120]  Так, давайте перейдем тогда к сканерам.
[44:33.120 --> 44:35.120]  И поймем...
[44:35.120 --> 44:39.120]  Да, у нас будет каждый раз рисоваться такая картинка.
[44:39.120 --> 44:41.120]  Стоит в компилер.
[44:43.120 --> 44:46.120]  Да, то есть мы находимся сейчас здесь.
[44:46.120 --> 44:49.120]  И давайте еще раз я проговорю те определения, которые я уже говорил.
[44:49.120 --> 44:50.120]  Что такое Алексема?
[44:50.120 --> 44:54.120]  Это некоторая последняя символов, шаблон которой ультавряет некоторому требованию.
[44:55.120 --> 45:00.120]  А токен – это строка, имеющая некоторый сакральный смысл, некоторые Алексемы.
[45:00.120 --> 45:03.120]  То есть токен – это типизированная Алексема.
[45:03.120 --> 45:09.120]  Сканер – это по факту транслятор, который приводит входной текст в некоторую последовательность токенов.
[45:09.120 --> 45:14.120]  Значит, примеры возможных Алексем токенов.
[45:14.120 --> 45:15.120]  Int – это type.
[45:15.120 --> 45:18.120]  Причем Int – это Алексема, а type – это будет токен.
[45:18.120 --> 45:20.120]  42 – это...
[45:20.120 --> 45:22.120]  Ну, кто-то считает, что это число.
[45:22.120 --> 45:24.120]  Можно написать, что это магическое число.
[45:24.120 --> 45:26.120]  Можно написать, что это void-звездочка.
[45:26.120 --> 45:29.120]  Ну, понятно, что это плашутка.
[45:31.120 --> 45:35.120]  Сканер переводит в из Алексема токена.
[45:35.120 --> 45:36.120]  Ну да.
[45:36.120 --> 45:38.120]  То есть он знает, что это type, что это int.
[45:38.120 --> 45:39.120]  Да, да, да.
[45:39.120 --> 45:42.120]  Но токен обычно внутри себя содержит Алексему.
[45:44.120 --> 45:46.120]  Подчеркивание Hello – это переменная.
[45:46.120 --> 45:48.120]  Hello word – это строка.
[45:48.120 --> 45:53.120]  И плюс-минус – это может быть либо бинарная операция с Алексемой заложенной в эту бинарную операцию,
[45:53.120 --> 45:57.120]  либо это может быть отдельный токен, вида плюс и минус.
[46:05.120 --> 46:07.120]  При желании, да.
[46:19.120 --> 46:22.120]  Да, правила грамматики какие-то там должны быть громоздкие.
[46:22.120 --> 46:23.120]  Да.
[46:23.120 --> 46:24.120]  Ну...
[46:24.120 --> 46:27.120]  Типа я пробил его, да я вам правила грамматики.
[46:27.120 --> 46:30.120]  Ну, бывают разные подходы.
[46:30.120 --> 46:32.120]  Такой неправильно мне парить.
[46:32.120 --> 46:33.120]  Да.
[46:33.120 --> 46:34.120]  Так.
[46:34.120 --> 46:35.120]  Ладно.
[46:35.120 --> 46:38.120]  Что означает, что Алексема заложен в токен?
[46:38.120 --> 46:43.120]  А это означает, что, допустим, если у нас есть Алексе, образно говоря,
[46:43.120 --> 46:46.120]  у нас под токеном type,
[46:46.120 --> 46:48.120]  может скрываться как int, так и float.
[46:49.120 --> 46:51.120]  В принципе, произвольный тип.
[46:51.120 --> 46:52.120]  Вот.
[46:52.120 --> 46:54.120]  И мы будем это обозначать следующим образом.
[46:54.120 --> 46:56.120]  Что у нас есть тип.
[46:58.120 --> 47:00.120]  Вот, тут доску поменяли, что ли.
[47:08.120 --> 47:11.120]  А внутри нее будет заложена Алексема, которая ее раскрывает.
[47:11.120 --> 47:14.120]  То есть, как бы у нас в коде это float,
[47:14.120 --> 47:15.120]  по факту это тип.
[47:18.120 --> 47:19.120]  Вот.
[47:19.120 --> 47:20.120]  Хорошо.
[47:20.120 --> 47:22.120]  Задание токенов.
[47:22.120 --> 47:25.120]  И здесь начинается курс формальных языков,
[47:25.120 --> 47:29.120]  потому что для нас обычно токены проще задавать регулярными выражениями.
[47:29.120 --> 47:31.120]  То есть, шаблонами, которые это все парсят.
[47:32.120 --> 47:35.120]  Напоминаем, собственно, определение регулярных выражений.
[47:35.120 --> 47:37.120]  Они задаются рекурсивным образом.
[47:37.120 --> 47:39.120]  0 это пустой язык,
[47:39.120 --> 47:41.120]  1 это пустое слово,
[47:41.120 --> 47:44.120]  однобуквенные символы этой языка за этой буквы,
[47:44.120 --> 47:46.120]  есть конкатинация языков.
[47:46.120 --> 47:50.120]  В нашем случае регулярные выражения есть объединение языков
[47:50.120 --> 47:52.120]  и есть итерация к линии.
[47:52.120 --> 47:54.120]  Мы это все прекрасно помним.
[47:54.120 --> 47:56.120]  И это формальное определение.
[47:57.120 --> 48:00.120]  А теперь давайте посмотрим, как это дело пишет о практике.
[48:00.120 --> 48:02.120]  Практике это пишет вот таким вот образом.
[48:02.120 --> 48:05.120]  То есть, у нас появляются дополнительные символы,
[48:05.120 --> 48:07.120]  которые раскрываются в базовую.
[48:07.120 --> 48:09.120]  Первый токен, который есть,
[48:09.120 --> 48:12.120]  это то, что начинается с определенного слова
[48:12.120 --> 48:14.120]  и заканчивается им.
[48:14.120 --> 48:17.120]  То есть, это оператор или на уровне одного токена.
[48:17.120 --> 48:21.120]  То есть, допустим, каким образом задаются все большие буквы,
[48:21.120 --> 48:23.120]  они задаются вот таким образом.
[48:29.120 --> 48:31.120]  Как задаются все буквы?
[48:32.120 --> 48:34.120]  Как задаются все буквы?
[48:38.120 --> 48:40.120]  Вот так они задаются.
[48:53.120 --> 48:55.120]  Да, да, да.
[48:55.120 --> 48:58.120]  Тут опять же плюс имеет...
[49:02.120 --> 49:05.120]  В регулярных он был вверх и полеуза, а теперь под стеной.
[49:05.120 --> 49:07.120]  Да, это серединный плюс.
[49:08.120 --> 49:11.120]  То есть, здесь есть еще вот такая вещь.
[49:15.120 --> 49:17.120]  Вот так вот.
[49:17.120 --> 49:22.120]  То есть, когда вы пишете о плюс, это на самом деле а с символом плюс.
[49:24.120 --> 49:29.120]  И важный еще момент, что круглые скобки здесь тоже имеют смысл.
[49:30.120 --> 49:34.120]  Это называется группирование в регулярных выражениях.
[49:40.120 --> 49:43.120]  Ну, это уже совсем продвинутые вещи.
[49:43.120 --> 49:45.120]  Значит, и при этом есть некоторые сокращения.
[49:45.120 --> 49:49.120]  Здесь важное следующее, что мы с вами решаем все-таки...
[49:49.120 --> 49:51.120]  Смотрите, важный момент.
[49:51.120 --> 49:55.120]  Мы здесь решаем задачи не распознавания, а задачи трансляции.
[49:56.120 --> 49:59.120]  Поэтому у нас будет поток символов,
[49:59.120 --> 50:01.120]  которые нам нужно будет транслировать набор токенов.
[50:01.120 --> 50:04.120]  Поэтому здесь еще появляются дополнительные токены
[50:04.120 --> 50:06.120]  в виде начала строки и конца строки.
[50:08.120 --> 50:10.120]  Которые бывают полезны.
[50:10.120 --> 50:12.120]  Backslash-S плюс.
[50:12.120 --> 50:15.120]  Backslash-S это пробельные символы,
[50:15.120 --> 50:17.120]  а Backslash-V это непробельные символы.
[50:19.120 --> 50:23.120]  Так, как говорится, сложно.
[50:23.120 --> 50:25.120]  Если вы не пользовались.
[50:25.120 --> 50:27.120]  И здесь есть реклама, к сожалению.
[50:27.120 --> 50:31.120]  Твоя банковская система, которая ушла из нашей страны.
[50:34.120 --> 50:37.120]  Это, наверное, мем нашего поколения.
[50:39.120 --> 50:41.120]  Если что, видео покажу в конце.
[50:45.120 --> 50:49.120]  Но для построения регулярок есть сайт regig101.com
[50:50.120 --> 50:52.120]  Я не знаю.
[50:52.120 --> 50:55.120]  Коллеги с третьего курса точно знают.
[50:55.120 --> 50:59.120]  Потому что были параллельные распределенные вычисления.
[50:59.120 --> 51:03.120]  В общем, сайт выглядит вот таким вот образом.
[51:03.120 --> 51:05.120]  И давайте что-нибудь напишу.
[51:19.120 --> 51:21.120]  Видите?
[51:24.120 --> 51:26.120]  Сколько сегодня?
[51:29.120 --> 51:31.120]  Вот, видите, что он сделал?
[51:31.120 --> 51:34.120]  Он выделил, собственно, все вхождения вот этого шаблона.
[51:34.120 --> 51:36.120]  0,9 плюс.
[51:36.120 --> 51:38.120]  То есть первое вхождение 20,24.
[51:38.120 --> 51:40.120]  Второе вхождение 0,2.
[51:40.120 --> 51:42.120]  То есть при помощи него можно взять,
[51:42.120 --> 51:44.120]  загнать регулярные выражения
[51:44.120 --> 51:50.120]  и увидеть, что он конкретно разбивает в данном случае на токенах.
[51:50.120 --> 51:52.120]  Крайне удобно.
[51:52.120 --> 51:55.120]  Просто заходим, вбиваем, смотрим, тестируем.
[51:55.120 --> 51:58.120]  В принципе, здесь даже есть кодеген.
[51:58.120 --> 52:01.120]  Для парсинга этих регулярных выражений.
[52:02.120 --> 52:04.120]  Да.
[52:04.120 --> 52:06.120]  Да.
[52:06.120 --> 52:08.120]  Того шаблона, который...
[52:08.120 --> 52:10.120]  Здесь есть такая кнопочка.
[52:11.120 --> 52:13.120]  Вот.
[52:13.120 --> 52:16.120]  Собственно, здесь даже можно эти,
[52:16.120 --> 52:18.120]  юнит-тест писать.
[52:18.120 --> 52:20.120]  А? При желании.
[52:20.120 --> 52:22.120]  А?
[52:24.120 --> 52:26.120]  Последний символов.
[52:26.120 --> 52:28.120]  Да.
[52:28.120 --> 52:30.120]  Да.
[52:37.120 --> 52:39.120]  В ASCII, да.
[52:46.120 --> 52:48.120]  Ну, да.
[52:48.120 --> 52:50.120]  Да, тут есть, кстати, разные форматы.
[52:50.120 --> 52:52.120]  Match.
[52:52.120 --> 52:54.120]  Вот.
[52:54.120 --> 52:56.120]  Ну, здесь видно от 0 до A.
[52:56.120 --> 53:00.120]  Собственно, от 48 до 65 символа.
[53:00.120 --> 53:02.120]  В ASCII кодировки.
[53:04.120 --> 53:07.120]  Так, это что касается регулярных выражений?
[53:16.120 --> 53:20.120]  Так, что было по формальным языкам?
[53:20.120 --> 53:23.120]  А, я имею в виду, вот такая регулярная та,
[53:23.120 --> 53:25.120]  которая в формалку была.
[53:25.120 --> 53:27.120]  Ну, а это те же самые регулярки, если что.
[53:27.120 --> 53:29.120]  Нет, там есть...
[53:29.120 --> 53:31.120]  Куча, куча...
[53:31.120 --> 53:33.120]  А.
[53:33.120 --> 53:36.120]  Ну, да, это продвинутые вещи.
[53:36.120 --> 53:38.120]  В первую очередь.
[53:38.120 --> 53:40.120]  Ну, мне кажется, это будет сложно,
[53:40.120 --> 53:43.120]  потому что, собственно,
[53:43.120 --> 53:48.120]  язык AFP это и не контексту свободный язык.
[53:48.120 --> 53:50.120]  Поэтому с этим будут проблемы.
[53:54.120 --> 53:57.120]  Ну, блин, давайте уже не закапываться.
[53:57.120 --> 53:59.120]  Так, давайте как раз попробуем построить регулянки
[53:59.120 --> 54:01.120]  на некоторых примерах.
[54:01.120 --> 54:03.120]  Не отрицательные целые числа.
[54:09.120 --> 54:11.120]  Ну, желательно, чтобы еще...
[54:13.120 --> 54:15.120]  Ну, с двумя цифрами все-таки мы пропускали.
[54:15.120 --> 54:17.120]  Да, тут есть еще операторы или,
[54:17.120 --> 54:19.120]  вот, которые я указал, это палка.
[54:32.120 --> 54:34.120]  Ну, да, то есть это...
[54:37.120 --> 54:39.120]  Ну, да, да, да.
[54:39.120 --> 54:41.120]  Ну, мы все-таки не восьмеричную запись.
[54:41.120 --> 54:43.120]  То есть у нас число либо неоднозначное.
[54:43.120 --> 54:45.120]  Начинается оно с 1 или 9.
[54:45.120 --> 54:47.120]  Вот, дальше 0,9 плюс.
[54:47.120 --> 54:49.120]  Либо 0,9. Имена переменных?
[54:54.120 --> 54:57.120]  Ну, вот, понятно, что это некоторые подношения.
[54:57.120 --> 54:59.120]  Я в качестве примера показываю.
[55:06.120 --> 55:08.120]  Ну, это да.
[55:10.120 --> 55:12.120]  Ну, да, да, да.
[55:12.120 --> 55:14.120]  Ну, тут можно по-разному уже задавать.
[55:14.120 --> 55:16.120]  Это просто для того, чтобы мы обознаковались.
[55:16.120 --> 55:18.120]  Строки, кстати.
[55:23.120 --> 55:26.120]  Да, тут я, к сожалению, все кроме кавычки опустил.
[55:26.120 --> 55:28.120]  Но по-хорошему, кавычка, все кроме кавычки.
[55:28.120 --> 55:34.120]  Кстати, как в этой штуке сделать отрицание?
[55:34.120 --> 55:36.120]  В этой штуке сделать отрицание,
[55:36.120 --> 55:38.120]  тут нужно крышечку добавить.
[55:38.120 --> 55:40.120]  Это будет отрицание.
[55:41.120 --> 55:43.120]  Мы с вами понимаем, что регулярные языки
[55:43.120 --> 55:45.120]  в замке относятся к отрицанию,
[55:45.120 --> 55:47.120]  поэтому здесь у нас никаких проблем не было.
[55:47.120 --> 55:49.120]  Все кроме, смотри, кавычки и бэкс-лэш-кавычки.
[55:49.120 --> 55:51.120]  Ну...
[55:51.120 --> 55:53.120]  А как распознавать экранирование?
[55:53.120 --> 55:57.120]  Или экранирование, которое, скажем,
[55:57.120 --> 55:59.120]  форматирована строка?
[55:59.120 --> 56:03.120]  Все кроме кавычки, но бэкс-лэш-кавычка...
[56:03.120 --> 56:07.120]  Типа я, когда писал по интерпретатору,
[56:07.120 --> 56:12.120]  там тоже часть языка это экранирование и форматирование.
[56:12.120 --> 56:17.120]  Экранирование, это вообще первый прогон?
[56:17.120 --> 56:21.120]  Да, кстати, несколько прогонов тоже разрешается.
[56:21.120 --> 56:23.120]  То есть мы можем взять наш прогон
[56:23.120 --> 56:27.120]  и его трансформировать в первый раз.
[56:27.120 --> 56:29.120]  То есть, когда ты считываешь буквы,
[56:29.120 --> 56:31.120]  перед тем, как кидать экранизаторы,
[56:31.120 --> 56:33.120]  ты перекорректируешь?
[56:33.120 --> 56:35.120]  Да, но поскольку люди очень решили
[56:35.120 --> 56:37.120]  сильно забить на это все,
[56:37.120 --> 56:39.120]  для этих людей как раз и придумал
[56:39.120 --> 56:41.120]  был формат B6C4,
[56:41.120 --> 56:43.120]  который берет и переводит это
[56:43.120 --> 56:45.120]  в набор символов и слашей.
[56:45.120 --> 56:47.120]  Собственно, даже если вы посмотрите
[56:47.120 --> 56:49.120]  SSH-ключ свой,
[56:49.120 --> 56:52.120]  там строка написана в формате B6C4.
[56:52.120 --> 56:53.120]  Специально чтобы можно было
[56:53.120 --> 56:55.120]  подобрать эту строку?
[56:55.120 --> 56:57.120]  Да.
[56:57.120 --> 56:59.120]  Так, вопрос.
[56:59.120 --> 57:01.120]  Мы с вами разобрали, каким образом
[57:01.120 --> 57:03.120]  мы можем стряпать эти шаблоны.
[57:03.120 --> 57:05.120]  Каким образом их распознавать?
[57:05.120 --> 57:07.120]  Готовыми парсерами или регулярными?
[57:07.120 --> 57:09.120]  Так, ладно, давайте мы
[57:09.120 --> 57:11.120]  в теорию перейдем.
[57:11.120 --> 57:13.120]  Что мы сопоставляли регулярным выражением?
[57:13.120 --> 57:15.120]  Конечные автоматы, конечно же.
[57:15.120 --> 57:17.120]  Для того, чтобы распознать шаблоны,
[57:17.120 --> 57:19.120]  нам нужны конечные автоматы.
[57:19.120 --> 57:21.120]  Сразу скажу, что у нас
[57:21.120 --> 57:23.120]  курс уже более ламповый,
[57:23.120 --> 57:25.120]  поэтому здесь не будет
[57:25.120 --> 57:27.120]  строгих определений.
[57:27.120 --> 57:29.120]  Но если мы говорим про строгие определения,
[57:29.120 --> 57:31.120]  то, конечно, автоматы это
[57:31.120 --> 57:33.120]  пятидесять.
[57:33.120 --> 57:35.120]  Можно только так в экзамене сказать?
[57:37.120 --> 57:39.120]  Теперь можно.
[57:39.120 --> 57:41.120]  Ты в экзамене дал, как ты тебе что правил?
[57:41.120 --> 57:43.120]  Да.
[57:43.120 --> 57:45.120]  Множество состояний,
[57:45.120 --> 57:47.120]  афавит, стартовые состояний,
[57:47.120 --> 57:49.120]  множество переходов, откуда-куда,
[57:49.120 --> 57:51.120]  и здесь можно сказать, что по какой букве
[57:51.120 --> 57:53.120]  или по какому слову,
[57:53.120 --> 57:55.120]  и множество завершающих состояний.
[57:55.120 --> 57:57.120]  Слово распознается тогда,
[57:57.120 --> 57:59.120]  когда существует путь от старта до финишена,
[57:59.120 --> 58:01.120]  и это очень важно.
[58:01.120 --> 58:03.120]  Когда существует путь от старта до финишена,
[58:03.120 --> 58:05.120]  на ребрах которого написано слово.
[58:05.120 --> 58:07.120]  Понятно, что здесь мы про штопоры
[58:07.120 --> 58:09.120]  говорить не будем.
[58:09.120 --> 58:11.120]  Потому что наша цель, на самом деле,
[58:11.120 --> 58:13.120]  другая.
[58:13.120 --> 58:15.120]  Вот пример автомат для распознавания этих чисел.
[58:15.120 --> 58:17.120]  Тут он немножко
[58:17.120 --> 58:19.120]  преобразовал.
[58:19.120 --> 58:21.120]  У нас есть числа от 0 до 9,
[58:21.120 --> 58:23.120]  есть числа от 0 до 9 и 0.
[58:25.120 --> 58:27.120]  Есть недетерминированность.
[58:27.120 --> 58:29.120]  Мы с вами понимаем, что мы можем с вами
[58:29.120 --> 58:31.120]  построить детерминированный автомат.
[58:31.120 --> 58:33.120]  Собственно, для этого нужно выполнить три стадия.
[58:33.120 --> 58:35.120]  Первое, это сделать все переходы
[58:35.120 --> 58:37.120]  не более чем однобуквенными.
[58:37.120 --> 58:39.120]  Дальше убрать пустые переходы и построить
[58:39.120 --> 58:41.120]  детерминированный автомат.
[58:45.120 --> 58:47.120]  Мы по факту это инклудим.
[58:47.120 --> 58:49.120]  Я просто напоминаю,
[58:49.120 --> 58:51.120]  как это инклудится.
[58:53.120 --> 58:55.120]  Ну как, хедр, почти.
[58:55.120 --> 58:57.120]  Мы показываем абстрактный класс,
[58:57.120 --> 58:59.120]  можно сказать.
[58:59.120 --> 59:01.120]  Без реализации.
[59:01.120 --> 59:03.120]  Вот оно реализация.
[59:03.120 --> 59:05.120]  Наверное,
[59:05.120 --> 59:07.120]  все это помнят.
[59:07.120 --> 59:09.120]  Все помнят?
[59:09.120 --> 59:11.120]  Хорошо.
[59:11.120 --> 59:13.120]  Детерминированный автомат.
[59:13.120 --> 59:15.120]  Когда мы детерминируем автомат, мы собираем по множеству.
[59:15.120 --> 59:17.120]  Тоже алгоритм Тобсона у нас был.
[59:17.120 --> 59:19.120]  Дальше нам нужно будет построить
[59:19.120 --> 59:21.120]  минимальный ДК.
[59:21.120 --> 59:23.120]  Тоже делается различение по буквы.
[59:23.120 --> 59:25.120]  Синий мы в одну часть отправляем.
[59:25.120 --> 59:27.120]  В одном классе другие и в другой класс.
[59:27.120 --> 59:29.120]  И делаем это до тех пор,
[59:29.120 --> 59:31.120]  пока это повторяется.
[59:31.120 --> 59:33.120]  Все понимают, что симпточка этого алгоритма
[59:33.120 --> 59:35.120]  экспоненциальная.
[59:35.120 --> 59:37.120]  Но почему мы его можем делать?
[59:45.120 --> 59:47.120]  Да.
[59:47.120 --> 59:49.120]  Мы делаем на один раз.
[59:49.120 --> 59:53.120]  Но он даже компилироваться не долго будет, на самом деле.
[59:53.120 --> 59:55.120]  Ну да.
[59:55.120 --> 59:57.120]  Так.
[59:57.120 --> 59:59.120]  И вот, смотрите,
[59:59.120 --> 01:00:01.120]  один важный момент,
[01:00:01.120 --> 01:00:03.120]  который я хочу обратить внимание,
[01:00:03.120 --> 01:00:05.120]  что в определении
[01:00:05.120 --> 01:00:07.120]  нужно допустить
[01:00:07.120 --> 01:00:09.120]  одно важное изменение.
[01:00:11.120 --> 01:00:13.120]  Я хочу подчеркнуть, где.
[01:00:13.120 --> 01:00:15.120]  Здесь.
[01:00:15.120 --> 01:00:17.120]  Множество завершает
[01:00:17.120 --> 01:00:19.120]  состояние.
[01:00:19.120 --> 01:00:21.120]  Для распознавания.
[01:00:21.120 --> 01:00:23.120]  Мы все-таки делаем
[01:00:23.120 --> 01:00:25.120]  не распознавание,
[01:00:25.120 --> 01:00:27.120]  мы делаем транслятор.
[01:00:27.120 --> 01:00:29.120]  И цель наша такая, что по входному слову
[01:00:29.120 --> 01:00:31.120]  мы должны транслировать его в один из типов.
[01:00:33.120 --> 01:00:35.120]  В один из типов токена.
[01:00:35.120 --> 01:00:37.120]  Вопрос.
[01:00:37.120 --> 01:00:39.120]  Каким образом мы можем трансформировать это определение,
[01:00:39.120 --> 01:00:41.120]  чтобы у нас все получилось?
[01:00:41.120 --> 01:00:43.120]  Да.
[01:00:43.120 --> 01:00:45.120]  Мы можем сказать, что завершающее состояние
[01:00:45.120 --> 01:00:47.120]  у каждого завершающего состояния
[01:00:47.120 --> 01:00:49.120]  у нас есть определенный цвет.
[01:00:55.120 --> 01:00:57.120]  Ну, можно так.
[01:00:57.120 --> 01:00:59.120]  То есть, смотрите,
[01:00:59.120 --> 01:01:01.120]  мы красим наше завершающее состояние
[01:01:01.120 --> 01:01:03.120]  в несколько типов.
[01:01:03.120 --> 01:01:05.120]  Важно, главное,
[01:01:05.120 --> 01:01:07.120]  чтобы у вас
[01:01:07.120 --> 01:01:09.120]  два завершающие состояния
[01:01:09.120 --> 01:01:11.120]  не покрасилось в один и тот же цвет.
[01:01:11.120 --> 01:01:13.120]  Но обычно это решают таким образом,
[01:01:13.120 --> 01:01:15.120]  что первое правило,
[01:01:15.120 --> 01:01:17.120]  которое соответствует
[01:01:17.120 --> 01:01:19.120]  вот этому шаблону,
[01:01:19.120 --> 01:01:21.120]  в тот цвет оно и красится.
[01:01:21.120 --> 01:01:23.120]  То есть, если у вас есть правило
[01:01:23.120 --> 01:01:25.120]  на пятой строке,
[01:01:25.120 --> 01:01:27.120]  есть правило на восьмой строке
[01:01:27.120 --> 01:01:29.120]  с разными типами токенов,
[01:01:29.120 --> 01:01:31.120]  то красятся в цвет пятой строки.
[01:01:33.120 --> 01:01:35.120]  Потому что чтобы было
[01:01:35.120 --> 01:01:37.120]  по методу исключения все работало.
[01:01:37.120 --> 01:01:39.120]  Потому что обычно,
[01:01:39.120 --> 01:01:41.120]  как ни странно, последний токен,
[01:01:41.120 --> 01:01:43.120]  который задают в сканере,
[01:01:43.120 --> 01:01:45.120]  это вот такой. Это точка-звездочка.
[01:01:45.120 --> 01:01:47.120]  Это означает
[01:01:47.120 --> 01:01:49.120]  произвольная строка.
[01:01:49.120 --> 01:01:51.120]  Мы на ней говорим,
[01:01:51.120 --> 01:01:53.120]  что у нас ошибка сканера.
[01:01:55.120 --> 01:01:57.120]  Чего там шумит?
[01:01:57.120 --> 01:01:59.120]  Ноль шумит, что ли?
[01:02:01.120 --> 01:02:03.120]  Ну все, проектор это.
[01:02:05.120 --> 01:02:07.120]  Так, и давайте как раз мы сейчас
[01:02:07.120 --> 01:02:09.120]  поговорим про алгоритм построения сканера.
[01:02:09.120 --> 01:02:11.120]  Может быть, успеем один разобрать.
[01:02:11.120 --> 01:02:13.120]  Потому что сканер – это транслятор.
[01:02:13.120 --> 01:02:15.120]  Он принимает на вход всю строку
[01:02:15.120 --> 01:02:17.120]  и должен получать
[01:02:17.120 --> 01:02:19.120]  какой-то выход.
[01:02:19.120 --> 01:02:21.120]  Здесь есть другой подход.
[01:02:21.120 --> 01:02:23.120]  Второй подход – это прямой поиск.
[01:02:23.120 --> 01:02:25.120]  Это по факту то, что делал
[01:02:25.120 --> 01:02:27.120]  Гера у нас.
[01:02:27.120 --> 01:02:29.120]  То есть, он берет
[01:02:29.120 --> 01:02:31.120]  и пишет сам код, который берет
[01:02:31.120 --> 01:02:33.120]  и делает сканер.
[01:02:33.120 --> 01:02:35.120]  Вот.
[01:02:35.120 --> 01:02:37.120]  Я делал все, чтобы издвигать
[01:02:37.120 --> 01:02:39.120]  и избирать от состояния кода.
[01:02:39.120 --> 01:02:41.120]  Проделал дарить гераматику.
[01:02:45.120 --> 01:02:47.120]  И есть еще такой код.
[01:02:47.120 --> 01:02:49.120]  Подход называется ручной подход.
[01:02:49.120 --> 01:02:51.120]  То есть, это всякие евристические правила,
[01:02:51.120 --> 01:02:53.120]  которые мы можем докинуть
[01:02:53.120 --> 01:02:55.120]  для того, чтобы построить сканер.
[01:02:55.120 --> 01:02:57.120]  То есть, у нас есть классический сканер,
[01:02:57.120 --> 01:02:59.120]  но, допонятно, мы делаем еще какие-то действия.
[01:02:59.120 --> 01:03:01.120]  Итак, табличный подход. Давайте расскажу,
[01:03:01.120 --> 01:03:03.120]  в чем он состоит.
[01:03:03.120 --> 01:03:05.120]  Цель будет состоять в том, чтобы
[01:03:05.120 --> 01:03:07.120]  на выходе получить токен.
[01:03:07.120 --> 01:03:09.120]  Набор токенов.
[01:03:09.120 --> 01:03:11.120]  Но здесь есть некоторый подвох.
[01:03:11.120 --> 01:03:13.120]  Мы можем сказать,
[01:03:13.120 --> 01:03:15.120]  ну, какой простой пример наивный алгоритм.
[01:03:15.120 --> 01:03:17.120]  Мы берем, значит,
[01:03:17.120 --> 01:03:19.120]  идем по нашему слову до тех пор,
[01:03:19.120 --> 01:03:21.120]  пока мы не зашли в завершающее состояние.
[01:03:21.120 --> 01:03:23.120]  Как только мы заходим в завершающее состояние,
[01:03:23.120 --> 01:03:25.120]  мы выдаем токен.
[01:03:27.120 --> 01:03:29.120]  Найдите ошибку.
[01:03:29.120 --> 01:03:31.120]  Нет, нет, нет.
[01:03:31.120 --> 01:03:33.120]  Это не вот этот алгоритм.
[01:03:33.120 --> 01:03:35.120]  Смотрите, здесь есть такой подвох,
[01:03:35.120 --> 01:03:37.120]  что давайте рассмотрим два слова.
[01:03:37.120 --> 01:03:39.120]  Первое слово это new,
[01:03:43.120 --> 01:03:45.120]  а второе слово это new-element.
[01:03:53.120 --> 01:03:55.120]  Это ключевое слово.
[01:03:55.120 --> 01:03:57.120]  Это название нашей переменной.
[01:03:57.120 --> 01:03:59.120]  Если мы будем парсить
[01:03:59.120 --> 01:04:01.120]  последовательно
[01:04:01.120 --> 01:04:03.120]  и будем работать new,
[01:04:03.120 --> 01:04:05.120]  здесь мы выдаем наш токен
[01:04:05.120 --> 01:04:07.120]  и обрываем наш контекст.
[01:04:07.120 --> 01:04:09.120]  А дальше у нас получается какая-то ерунда.
[01:04:15.120 --> 01:04:17.120]  Как-то некрасиво.
[01:04:17.120 --> 01:04:19.120]  Мы хотим парсить все-таки
[01:04:19.120 --> 01:04:21.120]  наибольшее по включению слова.
[01:04:21.120 --> 01:04:23.120]  Обычно при сканики
[01:04:23.120 --> 01:04:25.120]  говорится, что
[01:04:25.120 --> 01:04:27.120]  пытаемся максимально
[01:04:27.120 --> 01:04:29.120]  по включению префикс делать.
[01:04:37.120 --> 01:04:39.120]  Это тоже есть.
[01:04:39.120 --> 01:04:41.120]  Поэтому наша цель
[01:04:41.120 --> 01:04:43.120]  будет стать следующим,
[01:04:43.120 --> 01:04:45.120]  что когда мы парсим наше слово,
[01:04:45.120 --> 01:04:47.120]  мы доходим до состояния
[01:04:47.120 --> 01:04:49.120]  состояния error.
[01:04:49.120 --> 01:04:51.120]  Подумайте, в каком алгоритме
[01:04:51.120 --> 01:04:53.120]  у нас возникало состояние error.
[01:04:53.120 --> 01:04:55.120]  Кто может сказать?
[01:04:55.120 --> 01:04:57.120]  Мы с вами его рассматривали
[01:04:57.120 --> 01:04:59.120]  алгоритм на курс формальных языков.
[01:05:07.120 --> 01:05:09.120]  Не конфликт.
[01:05:09.120 --> 01:05:11.120]  Давайте я назову его
[01:05:11.120 --> 01:05:13.120]  другое название, stock.
[01:05:17.120 --> 01:05:19.120]  Когда мы строили с вами
[01:05:19.120 --> 01:05:21.120]  PDKA,
[01:05:21.120 --> 01:05:23.120]  у нас было стоковое состояние,
[01:05:23.120 --> 01:05:25.120]  в которое приходят все слова,
[01:05:25.120 --> 01:05:27.120]  в которые у меня было перехода.
[01:05:27.120 --> 01:05:29.120]  Здесь это состояние мы назовем
[01:05:29.120 --> 01:05:31.120]  состояние ошибкой.
[01:05:31.120 --> 01:05:33.120]  Мы пошли не по корректному пути,
[01:05:33.120 --> 01:05:35.120]  а пошли в какое-то другое место.
[01:05:35.120 --> 01:05:37.120]  Это ошибка error.
[01:05:37.120 --> 01:05:39.120]  Если в задаче распознавания
[01:05:39.120 --> 01:05:41.120]  это состояние было для нас совсем неважно,
[01:05:41.120 --> 01:05:43.120]  то здесь оно играет ключевую роль.
[01:05:43.120 --> 01:05:45.120]  Мы относительно него начинаем
[01:05:45.120 --> 01:05:47.120]  отматывать наш сканер назад.
[01:05:47.120 --> 01:05:49.120]  То есть мы построили с вами
[01:05:49.120 --> 01:05:51.120]  несколько завершающих состояний.
[01:05:55.120 --> 01:05:57.120]  И потом пошли в состояние ошибку.
[01:05:59.120 --> 01:06:01.120]  Дальше наша цель
[01:06:01.120 --> 01:06:03.120]  будет сделать обратный проход
[01:06:03.120 --> 01:06:05.120]  по этому моменту до тех пор,
[01:06:05.120 --> 01:06:07.120]  пока мы не вернемся в завершающее состояние.
[01:06:07.120 --> 01:06:09.120]  Именно в нем отсечь наше слово.
[01:06:11.120 --> 01:06:13.120]  Здесь у нас получается new элемент.
[01:06:13.120 --> 01:06:15.120]  После наступления
[01:06:15.120 --> 01:06:17.120]  с пробела мы идем в ошибку.
[01:06:17.120 --> 01:06:19.120]  Скорее всего,
[01:06:19.120 --> 01:06:21.120]  если там
[01:06:21.120 --> 01:06:23.120]  не какая-то другая грамотика.
[01:06:23.120 --> 01:06:25.120]  И дальше мы отматываемся назад
[01:06:25.120 --> 01:06:27.120]  и попадаем в наш сканер.
[01:06:27.120 --> 01:06:29.120]  С высокой степенью вероятности
[01:06:29.120 --> 01:06:31.120]  мы сделаем один шаг назад.
[01:06:31.120 --> 01:06:33.120]  Но это не гарантируется.
[01:06:37.120 --> 01:06:39.120]  Дальше мы очищаем стэк.
[01:06:39.120 --> 01:06:41.120]  Тут именно стэк нужен для того,
[01:06:41.120 --> 01:06:43.120]  чтобы все это делать.
[01:06:43.120 --> 01:06:45.120]  Если мы внезапно дошли
[01:06:45.120 --> 01:06:47.120]  до корня стэка,
[01:06:47.120 --> 01:06:49.120]  а такое вполне возможно.
[01:06:49.120 --> 01:06:51.120]  То есть мы шли-шли-шли,
[01:06:51.120 --> 01:06:53.120]  и на нашем пути не было ни одного принимающего состояния.
[01:06:53.120 --> 01:06:55.120]  Хотя это навряд ли.
[01:06:55.120 --> 01:06:57.120]  То мы говорим, что у нас
[01:06:57.120 --> 01:06:59.120]  синтоксическая ошибка.
[01:06:59.120 --> 01:07:01.120]  Ой, не синтоксическая, а лексическая ошибка.
[01:07:01.120 --> 01:07:03.120]  В нашем примере.
[01:07:09.120 --> 01:07:11.120]  Хороший кейс.
[01:07:11.120 --> 01:07:13.120]  У нас
[01:07:13.120 --> 01:07:15.120]  нам нужно сделать следующую вещь.
[01:07:17.120 --> 01:07:19.120]  Если мы бесконечно будем
[01:07:19.120 --> 01:07:21.120]  ходить до конца программы.
[01:07:29.120 --> 01:07:31.120]  Ну, end of file
[01:07:31.120 --> 01:07:33.120]  мы можем всегда ввести перемен
[01:07:33.120 --> 01:07:35.120]  строку.
[01:07:35.120 --> 01:07:37.120]  И именно туда тоже закидываем
[01:07:37.120 --> 01:07:39.120]  переход в ошибку.
[01:07:43.120 --> 01:07:45.120]  Да, мы построили для всех
[01:07:45.120 --> 01:07:47.120]  токенов, которые мы хотим располонить
[01:07:47.120 --> 01:07:49.120]  по ДК.
[01:07:53.120 --> 01:07:55.120]  Да, как только мы дошли в ошибку.
[01:07:59.120 --> 01:08:01.120]  Дальше мы делаем следующее.
[01:08:01.120 --> 01:08:03.120]  Мы делаем откат по нашему пути
[01:08:03.120 --> 01:08:05.120]  до тех пор, пока мы не зашли в завершающее
[01:08:05.120 --> 01:08:07.120]  состояние.
[01:08:07.120 --> 01:08:09.120]  И дальше то слово, которое у нас было
[01:08:09.120 --> 01:08:11.120]  до завершающего состояния, мы отсекаем
[01:08:11.120 --> 01:08:13.120]  и повторяем все по новой.
[01:08:15.120 --> 01:08:17.120]  Да, да, снова в стартовую вершину.
[01:08:19.120 --> 01:08:21.120]  Здесь нужно отдельно рассмотреть случай
[01:08:21.120 --> 01:08:23.120]  конца файла.
[01:08:25.120 --> 01:08:27.120]  Собственно, этот пример мы уже
[01:08:27.120 --> 01:08:29.120]  с вами разобрали.
[01:08:29.120 --> 01:08:31.120]  И, кстати, проблема этого алгоритма, что он работает
[01:08:31.120 --> 01:08:33.120]  в квадратичное время для произвольных
[01:08:33.120 --> 01:08:35.120]  сканеров.
[01:08:35.120 --> 01:08:37.120]  Здесь есть пример, зачастую
[01:08:37.120 --> 01:08:39.120]  он будет работать за линию.
[01:08:39.120 --> 01:08:41.120]  У нас есть строка
[01:08:41.120 --> 01:08:43.120]  ab, ab, ab, ab...
[01:08:43.120 --> 01:08:45.120]  Здесь видно, что
[01:08:45.120 --> 01:08:47.120]  можно подумать, что если мы принимаем
[01:08:47.120 --> 01:08:49.120]  слово только ab, то у нас будет
[01:08:49.120 --> 01:08:51.120]  квадратичная сложность на отматывание.
[01:08:51.120 --> 01:08:53.120]  То есть мы промотали все слово, смотрите.
[01:08:53.120 --> 01:08:55.120]  ab, ab, ab,
[01:08:55.120 --> 01:08:57.120]  дошли до конца файла бесконечный цикл,
[01:08:57.120 --> 01:08:59.120]  и все-таки нам нужно отмотаться до ab.
[01:08:59.120 --> 01:09:01.120]  То есть мы по факту сделали цикл
[01:09:01.120 --> 01:09:03.120]  по всему слову,
[01:09:03.120 --> 01:09:05.120]  проход по всему слову, а приняли только ab.
[01:09:05.120 --> 01:09:07.120]  Поэтому здесь
[01:09:07.120 --> 01:09:09.120]  это можно лечить. Мы можем сказать,
[01:09:09.120 --> 01:09:11.120]  что давайте заведем
[01:09:11.120 --> 01:09:13.120]  массив пар,
[01:09:13.120 --> 01:09:15.120]  позицию состояния в сканере
[01:09:15.120 --> 01:09:17.120]  и будем при помощи него
[01:09:17.120 --> 01:09:19.120]  отслеживать.
[01:09:19.120 --> 01:09:21.120]  Допустим, если мы один раз зашли в какую-то
[01:09:21.120 --> 01:09:23.120]  ложную ситуацию, в ложный путь,
[01:09:23.120 --> 01:09:25.120]  то мы можем сделать маркировку
[01:09:25.120 --> 01:09:27.120]  того, что мы уже пошли по ложному пути.
[01:09:27.120 --> 01:09:29.120]  Ну, в принципе, да.
[01:09:29.120 --> 01:09:31.120]  Почему здесь стек?
[01:09:31.120 --> 01:09:33.120]  Потому что мы считаем,
[01:09:33.120 --> 01:09:35.120]  что мы работаем с водным потоком,
[01:09:35.120 --> 01:09:37.120]  поэтому все-таки, как только мы
[01:09:37.120 --> 01:09:39.120]  прошли что-то из входного потока,
[01:09:39.120 --> 01:09:41.120]  нам желательно сохранять это все дело.
[01:09:41.120 --> 01:09:43.120]  Ровно по этой причине.
[01:09:43.120 --> 01:09:45.120]  Вот и все.
[01:09:45.120 --> 01:09:47.120]  Вот и все.
[01:09:47.120 --> 01:09:49.120]  Вот и все.
[01:09:49.120 --> 01:09:51.120]  Вот и все.
[01:09:51.120 --> 01:09:53.120]  Вот и все.
[01:09:53.120 --> 01:09:55.120]  Вот и все.
[01:09:55.120 --> 01:09:57.120]  Ровно по этой причине.
[01:09:57.120 --> 01:09:59.120]  Собственно, давайте попробуем
[01:09:59.120 --> 01:10:01.120]  подумать, какие недостатки у этого подхода есть.
[01:10:09.120 --> 01:10:11.120]  Тут проблем
[01:10:11.120 --> 01:10:13.120]  будет в памяти.
[01:10:13.120 --> 01:10:15.120]  Потому что, чтобы хранить DKA,
[01:10:15.120 --> 01:10:17.120]  нам нужно большое количество
[01:10:17.120 --> 01:10:19.120]  состояний.
[01:10:19.120 --> 01:10:21.120]  Сейчас это не проблема,
[01:10:21.120 --> 01:10:23.120]  потому что у нас компьютеры все мощные.
[01:10:23.120 --> 01:10:25.120]  В 80-90-х годах это была проблема.
[01:10:25.120 --> 01:10:27.120]  И, во-вторых, у нас есть долгий поиск по таблиц.
[01:10:27.120 --> 01:10:29.120]  То есть нам нужно
[01:10:29.120 --> 01:10:31.120]  отмотать какое-то состояние DKA,
[01:10:31.120 --> 01:10:33.120]  проверить в нем переходы, найти его,
[01:10:33.120 --> 01:10:35.120]  и так далее. С этим есть проблема.
[01:10:35.120 --> 01:10:37.120]  Вот.
[01:10:37.120 --> 01:10:39.120]  Собственно,
[01:10:39.120 --> 01:10:41.120]  есть идея,
[01:10:41.120 --> 01:10:43.120]  каким образом еще попытаться
[01:10:43.120 --> 01:10:45.120]  обойти
[01:10:45.120 --> 01:10:47.120]  вот этот подход.
[01:10:47.120 --> 01:10:49.120]  С тем, что мы можем очень долго
[01:10:49.120 --> 01:10:51.120]  плутать.
[01:10:53.120 --> 01:10:55.120]  Он, кстати,
[01:10:55.120 --> 01:10:57.120]  завязан как на особенностях
[01:10:57.120 --> 01:10:59.120]  операционной системы,
[01:10:59.120 --> 01:11:01.120]  так и на особенностях самого языка.
[01:11:03.120 --> 01:11:05.120]  Вот, допустим, мы с вами,
[01:11:05.120 --> 01:11:07.120]  если у нас распознается строка
[01:11:07.120 --> 01:11:09.120]  какая-нибудь, то мы понимаем сразу,
[01:11:09.120 --> 01:11:11.120]  что у нас первый символ
[01:11:11.120 --> 01:11:13.120]  это кавычка, и явно нам нужно ждать следующую
[01:11:13.120 --> 01:11:15.120]  кавычку.
[01:11:15.120 --> 01:11:17.120]  Да?
[01:11:17.120 --> 01:11:19.120]  Вопрос к вам.
[01:11:19.120 --> 01:11:21.120]  Вы когда-нибудь пытались объявлять очень длинные
[01:11:21.120 --> 01:11:23.120]  кавычки в программах?
[01:11:27.120 --> 01:11:29.120]  Практически во всех языках
[01:11:29.120 --> 01:11:31.120]  программирования есть ограничение
[01:11:31.120 --> 01:11:33.120]  на длину переменной.
[01:11:41.120 --> 01:11:43.120]  То есть тем самым мы можем
[01:11:43.120 --> 01:11:45.120]  на этапе сканера сказать, что если
[01:11:45.120 --> 01:11:47.120]  мы находимся в определенном
[01:11:47.120 --> 01:11:49.120]  наборе ситуаций,
[01:11:49.120 --> 01:11:51.120]  проевристический подход,
[01:11:51.120 --> 01:11:53.120]  и, собственно, мы прошли какое-то количество
[01:11:53.120 --> 01:11:55.120]  символов, очень большое,
[01:11:55.120 --> 01:11:57.120]  и мы не дошли до ошибки,
[01:11:57.120 --> 01:11:59.120]  или мы не приходили
[01:11:59.120 --> 01:12:01.120]  ни через какое завершающее состояние,
[01:12:01.120 --> 01:12:03.120]  то, значит, мы
[01:12:03.120 --> 01:12:05.120]  останавливаем наш алгоритм.
[01:12:05.120 --> 01:12:07.120]  Говорим, что у нас лексическая ошибка.
[01:12:07.120 --> 01:12:09.120]  Понятно, да? То есть...
[01:12:09.120 --> 01:12:11.120]  А?
[01:12:15.120 --> 01:12:17.120]  Ну, это
[01:12:17.120 --> 01:12:19.120]  совсем плохая ошибка компилятора.
[01:12:19.120 --> 01:12:21.120]  Так. Да.
[01:12:21.120 --> 01:12:23.120]  Тут, кстати, есть еще прямой подход.
[01:12:23.120 --> 01:12:25.120]  То есть мы по факту, как только
[01:12:25.120 --> 01:12:27.120]  заходим в определенное
[01:12:27.120 --> 01:12:29.120]  состояние в ДК,
[01:12:29.120 --> 01:12:31.120]  просто выводим код,
[01:12:31.120 --> 01:12:33.120]  который у нас
[01:12:33.120 --> 01:12:35.120]  имеется. То есть в первый раз, как только
[01:12:35.120 --> 01:12:37.120]  мы зашли в определенное состояние ДК,
[01:12:37.120 --> 01:12:39.120]  мы генерируем код.
[01:12:39.120 --> 01:12:41.120]  То есть вы представляете себе ситуацию,
[01:12:41.120 --> 01:12:43.120]  у вас есть код, у вас есть какой-то пример,
[01:12:43.120 --> 01:12:45.120]  и вы понимаете, в принципе,
[01:12:45.120 --> 01:12:47.120]  какой у вас маленький НК есть,
[01:12:47.120 --> 01:12:49.120]  и вы понимаете, что, скорее всего,
[01:12:49.120 --> 01:12:51.120]  на стадии прохода нашей программы
[01:12:51.120 --> 01:12:53.120]  вам не нужен этот весь код.
[01:12:53.120 --> 01:12:55.120]  Вам не нужна эта вся таблица.
[01:12:55.120 --> 01:12:57.120]  Тогда идея какая?
[01:12:57.120 --> 01:12:59.120]  Мы идем, и
[01:12:59.120 --> 01:13:01.120]  как только попадаем в определенное состояние
[01:13:01.120 --> 01:13:03.120]  в НК, то есть запускаем алгоритм Томсона
[01:13:03.120 --> 01:13:05.120]  на этапе прохода самого языка.
[01:13:07.120 --> 01:13:09.120]  На этапе прохода компилятора.
[01:13:09.120 --> 01:13:11.120]  В итоге у вас код автоматически генерироваться
[01:13:11.120 --> 01:13:13.120]  будет
[01:13:13.120 --> 01:13:15.120]  для парсинга,
[01:13:15.120 --> 01:13:17.120]  для распознавания Алексея.
[01:13:17.120 --> 01:13:19.120]  Получается вот такая вот страшная вещь.
[01:13:21.120 --> 01:13:23.120]  Да, это фотография из книжки.
[01:13:27.120 --> 01:13:29.120]  Собственно, вот так
[01:13:29.120 --> 01:13:31.120]  она будет выглядеть.
[01:13:31.120 --> 01:13:33.120]  Так, хорошо.
[01:13:33.120 --> 01:13:35.120]  Тут есть еще евристические подходы.
[01:13:35.120 --> 01:13:37.120]  Собственно, про ограниченность
[01:13:37.120 --> 01:13:39.120]  названий переменных мы с вами поговорили.
[01:13:39.120 --> 01:13:41.120]  Тут есть решение.
[01:13:41.120 --> 01:13:43.120]  И есть еще одна чтенька евристика
[01:13:43.120 --> 01:13:45.120]  используется, это обработка чисел.
[01:13:45.120 --> 01:13:47.120]  Кстати, мы ее тоже посмотрим.
[01:13:47.120 --> 01:13:49.120]  То есть мы понимаем с вами,
[01:13:49.120 --> 01:13:51.120]  что конвертировать строки в числа
[01:13:51.120 --> 01:13:53.120]  это зачастую оверхед,
[01:13:53.120 --> 01:13:55.120]  потому что вы и так уже прочли
[01:13:55.120 --> 01:13:57.120]  строку,
[01:13:57.120 --> 01:13:59.120]  и вам еще раз эту строку конвертировать число
[01:13:59.120 --> 01:14:01.120]  это бред.
[01:14:01.120 --> 01:14:03.120]  Поэтому вспоминаем олимпиадное
[01:14:03.120 --> 01:14:05.120]  программирование, каким образом
[01:14:05.120 --> 01:14:07.120]  там строки в числа конвертируются.
[01:14:09.120 --> 01:14:11.120]  Омтикота, мы идем,
[01:14:11.120 --> 01:14:13.120]  считываем символ,
[01:14:13.120 --> 01:14:15.120]  его автоматически считаем
[01:14:15.120 --> 01:14:17.120]  текущее число,
[01:14:17.120 --> 01:14:19.120]  которое у нас имеется.
[01:14:19.120 --> 01:14:21.120]  То есть вот такие подходы к трансформации
[01:14:21.120 --> 01:14:23.120]  в число, чтобы как только вы зашли
[01:14:23.120 --> 01:14:25.120]  в завершающее состояние, связанное
[01:14:25.120 --> 01:14:27.120]  с числом, вы сразу выдавали число,
[01:14:27.120 --> 01:14:29.120]  а не делали дополнительную
[01:14:29.120 --> 01:14:31.120]  конвертацию на это дело.
[01:14:31.120 --> 01:14:33.120]  И такие мелкие обработки
[01:14:33.120 --> 01:14:35.120]  еще есть.
[01:14:35.120 --> 01:14:37.120]  Еще один последний кейс
[01:14:37.120 --> 01:14:39.120]  это обработка ключевых слов.
[01:14:41.120 --> 01:14:43.120]  У вас количество
[01:14:43.120 --> 01:14:45.120]  ключевых слов в языке
[01:14:45.120 --> 01:14:47.120]  ограничено, поэтому можно сделать
[01:14:47.120 --> 01:14:49.120]  следующее. А давайте мы с вами
[01:14:49.120 --> 01:14:51.120]  создадим универсальную
[01:14:51.120 --> 01:14:53.120]  хэш-функцию для этих ключевых слов
[01:14:55.120 --> 01:14:57.120]  и будем просто каждый раз, когда у нас
[01:14:57.120 --> 01:14:59.120]  накапливается определенное слово, автоматически
[01:14:59.120 --> 01:15:01.120]  проверять,
[01:15:01.120 --> 01:15:03.120]  является ли оно
[01:15:03.120 --> 01:15:05.120]  ключевым типом.
[01:15:05.120 --> 01:15:07.120]  Для того, чтобы если оно является ключевым типом, мы сразу сказали,
[01:15:07.120 --> 01:15:09.120]  что это токен ключевого типа.
[01:15:09.120 --> 01:15:11.120]  И не выполняли лишний проход
[01:15:11.120 --> 01:15:13.120]  по автоматам.
[01:15:17.120 --> 01:15:19.120]  Нет, нет, конечно, это вот такие
[01:15:19.120 --> 01:15:21.120]  теоретические вещи, которые я хотел рассказать.
[01:15:21.120 --> 01:15:23.120]  Вот, собственно,
[01:15:23.120 --> 01:15:25.120]  это еще раз суммирование
[01:15:25.120 --> 01:15:27.120]  того, что мы прошли за сегодня.
[01:15:27.120 --> 01:15:29.120]  Мы посмотрели,
[01:15:29.120 --> 01:15:31.120]  из чего состоит компилятор,
[01:15:31.120 --> 01:15:33.120]  и начали работать как раз
[01:15:33.120 --> 01:15:35.120]  с разными типами сканеров.
[01:15:35.120 --> 01:15:37.120]  Возможно, какие-то части мы добьем
[01:15:37.120 --> 01:15:39.120]  на следующей лекции.
[01:15:39.120 --> 01:15:41.120]  А сейчас мы будем решать
[01:15:41.120 --> 01:15:43.120]  вопрос с семинаром.
[01:15:43.120 --> 01:15:45.120]  Тем, кто смотрел на YouTube,
[01:15:45.120 --> 01:15:47.120]  всем спасибо.
[01:15:47.120 --> 01:15:49.120]  Всем до следующего раза.
