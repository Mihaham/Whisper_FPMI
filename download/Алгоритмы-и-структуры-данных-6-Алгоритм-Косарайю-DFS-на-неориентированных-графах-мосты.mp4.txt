[00:00.000 --> 00:08.920]  Мы продолжаем прошлую лекцию. У нас остался долг доказать
[00:08.920 --> 00:11.160]  корректность алгоритма Косараю. Давайте я его напомню
[00:11.160 --> 00:21.720]  быстренько. Напоминаю, что мы делали. У нас был ориентированный
[00:21.720 --> 00:24.760]  граф. Мы хотели выделить в нем все компоненты сильной
[00:24.760 --> 00:27.600]  связности. Давайте я договорюсь, что компоненты сильной
[00:27.600 --> 00:30.200]  связи я буду называть КСС сегодня, чтобы долго не
[00:30.200 --> 00:34.080]  говорить. Нужно выделить КСС в ориентированном графе.
[00:34.080 --> 00:40.480]  Мы делали следующее. Во-первых, мы с помощью обычного ДФСа
[00:40.480 --> 00:45.160]  сортировали все вершины в порядке убывания ТАУД.
[00:45.160 --> 00:56.240]  Сортировка вершин в порядке убывания ТАУД. На втором
[00:56.240 --> 01:00.120]  шаге мы по этой перестановке вершин в этом порядке шли
[01:00.120 --> 01:02.480]  и для всех непосещенных запускали ДФС по обратным
[01:02.480 --> 01:06.240]  ребрам. Все, что мы посещаем, непосещенное раньше, это
[01:06.240 --> 01:17.600]  очередная компонента связности. ДФС по обратным ребрам
[01:17.600 --> 01:24.480]  из вершин в этом порядке. Все, что на очередном шаге
[01:24.480 --> 01:26.800]  достигается, это очередная компонента сильной связности.
[01:26.800 --> 01:32.480]  Есть у меня какая-то перестановка. Я сначала запускаюсь ДФСом
[01:32.480 --> 01:38.560]  по обратным ребрамам, которые я обзываю ДФСР, ДФС реверс.
[01:38.560 --> 01:41.320]  Запускаю ДФС из первой вершины в этом порядке. Она что-то
[01:41.320 --> 01:45.480]  посещает. Все, что она посетила, я помещаю юздами, какими-то
[01:45.480 --> 01:48.040]  метками, что эти все вершины посещены. Я говорю, что это
[01:48.040 --> 01:50.600]  очередная компонента сильной связности. Потом продолжаю
[01:50.600 --> 01:53.280]  идти по вот этому списку, по этой перестановке. Нахожу
[01:53.280 --> 01:55.600]  первую непосещенную, та, которая еще не помещена,
[01:55.600 --> 01:58.280]  как юзд, запускаю от нее ДФСом по обратным ребрам.
[01:58.280 --> 02:01.280]  И опять то, что она посетит, это очередная компонента.
[02:01.280 --> 02:05.600]  Вот такой алгоритм. Нам нужно догадать корректность.
[02:05.600 --> 02:10.640]  Для этого нужно следующее утверждение. Утверждение
[02:10.640 --> 02:26.960]  значит, пусть из У есть путь В, но из В нет пути В, тогда
[02:26.960 --> 02:39.000]  tout от У больше tout от В. У нас было похожее утверждение,
[02:40.000 --> 02:42.000]  когда мы говорили про дак, когда мы строили дипологическую
[02:42.000 --> 02:45.000]  сортировку, у нас было, что если есть ребро из УВ,
[02:45.000 --> 02:48.000]  в комментарии, если, значит, когда мы говорили про дак
[02:48.000 --> 02:51.000]  и строили топ-сорт, мы говорили, что если есть ребро из УВ,
[02:51.000 --> 02:53.000]  и соответственно нет обратного ребра, поскольку у нас
[02:53.000 --> 02:55.000]  ациклический граф, нет обратного ребра, тогда tout
[02:55.000 --> 02:58.000]  отсюда обязательно больше, чем tout отсюда. И значит,
[02:58.000 --> 03:02.000]  когда мы сортим все в порядке убывания tout, эти вершины
[03:02.000 --> 03:04.000]  гарантированно будут идти раньше, а значит, ребра будут
[03:04.000 --> 03:07.000]  только слева направо. Это у нас было в прошлый раз.
[03:07.000 --> 03:09.000]  Такое изменение такое, доказательство.
[03:13.000 --> 03:15.000]  Ну вот рассмотрим путь из УВ.
[03:19.000 --> 03:21.000]  Давайте на этом пути рассмотрим вершину с минимальным
[03:21.000 --> 03:22.000]  t in.
[03:25.000 --> 03:30.000]  Дубль В, это вершина на пути из УВ
[03:33.000 --> 03:35.000]  с минимальным t in.
[03:37.000 --> 03:47.000]  Здесь, видимо, есть два варианта. Первый вариант,
[03:47.000 --> 03:52.000]  если W совпадает с У, тогда все очевидно, потому что,
[03:52.000 --> 03:56.000]  значит, если W совпадает с У, значит, среди всех вот
[03:56.000 --> 03:59.000]  этих вот вершин первая, в которую мой DFS зашел, это
[03:59.000 --> 04:03.000]  У. Значит, к моменту времени входа сюда все вот эти
[04:03.000 --> 04:05.000]  вершинки еще не посещены, значит, они еще белые.
[04:05.000 --> 04:07.000]  Ну, значит, в частности, по леммиям белых путях,
[04:07.000 --> 04:10.000]  к моменту времени выхода из У мы обязаны будем все
[04:10.000 --> 04:12.000]  вот это обойти, потому что все это белый путь. Значит,
[04:12.000 --> 04:15.000]  в частности, вершинку В мы тоже посетим, из нее все
[04:15.000 --> 04:17.000]  обойдем, пометим ее черной, и только после этого мы
[04:17.000 --> 04:26.000]  посетим У. Значит, первый случай. Если W равна У, тогда
[04:26.000 --> 04:46.000]  по леммиям белых путях W посетится до выхода из У. Ну,
[04:46.000 --> 04:49.000]  значит, есть вот такой неравенственный т-аут, что мы сначала выйдем
[04:49.000 --> 04:58.000]  из В, только после этого когда-то выйдем из У. Понятно?
[04:58.000 --> 05:08.000]  Ну, второе, если W не равно У, то как у нас все это выглядит?
[05:08.000 --> 05:16.000]  Если W, тогда работает следующее. Сейчас, момент.
[05:16.000 --> 05:36.000]  Неприятно, неприятно. Так, виноват, надо минутку подумать.
[05:36.000 --> 05:49.000]  Не, ну, смотрите, проблема, вот такая может быть проблема,
[05:49.000 --> 06:00.000]  на самом деле. Ну, это не очень страшно, главное, что
[06:00.000 --> 06:18.000]  нет из В в У цикла. Так, сейчас, момент.
[06:18.000 --> 06:36.000]  Да, окей, получается, что не верно, надо что-то будет
[06:36.000 --> 06:39.000]  менять, потому что, смотрите, например, вот на такой картинке,
[06:39.000 --> 06:43.000]  пусть вот есть такая картина, путь из У в В и обратное
[06:43.000 --> 06:47.000]  ребро из W в У. Тогда, если вот эта вершина первая, из которой
[06:47.000 --> 06:50.000]  мы запускаемся, и, например, ДФС идет так, он сначала
[06:50.000 --> 06:53.000]  идет в У, потом пощадь все вот это, потом говорит,
[06:53.000 --> 06:55.000]  ага, я дошел до вершины, где я уже был, все, дальше
[06:55.000 --> 06:57.000]  не иду. Получается, разворачивается обратно, выходит из
[06:57.000 --> 07:01.000]  них из всех, доходит до У, до W, то есть мы, получается,
[07:01.000 --> 07:04.000]  сначала обошли целиком У, потом вернулись сюда,
[07:04.000 --> 07:06.000]  и только потом в конце дойдем до В. Тогда, получается,
[07:06.000 --> 07:08.000]  вот это утверждение неверное, что т-аут больше, чем
[07:08.000 --> 07:11.000]  т-аут от В. То есть мы сначала выйдем отсюда, потом
[07:11.000 --> 07:15.000]  выйдем отсюда. Значит, это неверно, извините, там
[07:15.000 --> 07:19.000]  можно все увидеть. Так, ну тогда надо сделать как-то
[07:19.000 --> 07:24.000]  по-другому, да, что, ну здесь проблема в том, что они
[07:24.000 --> 07:26.000]  как бы в разных компонентах, в разных компонентах
[07:26.000 --> 07:30.000]  сильно связанности, что вот, ну точнее У и В в одной,
[07:30.000 --> 07:33.000]  У и В в одной компоненте сильно связанности.
[07:33.000 --> 07:37.000]  Давай тогда попробуем наоборот утверждение сформулировать,
[07:37.000 --> 07:40.000]  что если есть две вершины в разных компонентах
[07:40.000 --> 07:44.000]  сильно связанности, причем из одной есть путь в другую.
[07:44.000 --> 07:46.000]  Давайте как-нибудь вот так вот сделаем, сначала
[07:46.000 --> 07:51.000]  на картинке. Вот кружочки этой компоненты
[07:51.000 --> 07:55.000]  сильно связанности. И пусть есть из одной компоненты
[07:55.000 --> 07:58.000]  сильно связанности путь в другую, по ребрам вот
[07:58.000 --> 08:00.000]  между компонентами. Тогда я хочу сказать, что
[08:00.000 --> 08:02.000]  т-аут, максимальный из т-аутов,
[08:02.000 --> 08:05.000]  который есть здесь, больше максимального из т-аутов,
[08:05.000 --> 08:07.000]  который есть здесь. То есть, на самом деле мне
[08:07.000 --> 08:11.160]  мне нужно путь не как бы между двумя вершинами, а путь между компонентами и
[08:11.160 --> 08:16.440]  брать не просто t-out от вершины, а t-out максимальный из всей компоненты.
[08:16.440 --> 08:31.600]  Сейчас мы это формально напишем. Пусть c1 и c2 различные компоненты
[08:31.600 --> 08:50.480]  сильно связанности, различные ксс, причем есть путь из c1 в c2, но сейчас значит,
[08:50.480 --> 08:54.920]  нет пути обратно, потому что если есть путь отсюда сюда и отсюда сюда, то
[08:54.920 --> 08:57.320]  получается, что они на самом деле все должны быть в одной компоненте сильно
[08:57.320 --> 09:01.000]  связанности, если есть путь отсюда сюда и обратно, значит, эти две компоненты
[09:01.000 --> 09:07.280]  должны склеиться, потому что есть путь в обе стороны. Тогда туждение будет
[09:07.280 --> 09:21.400]  следующее. Максимум t-out от u по всем u и c1 больше, чем максимум t-out по всем v
[09:21.880 --> 09:22.680]  для v и c2.
[09:22.680 --> 09:28.720]  Так, то, что тут было, забыли.
[09:28.720 --> 09:50.280]  Так, давайте доказывать.
[09:50.280 --> 10:09.040]  Ну хорошо, давайте посмотрим просто на вот этот путь из первой компоненты в
[10:09.040 --> 10:19.320]  последнюю, то есть из c1 в c2. Давайте посмотрим на вот эту вершину, из которой, собственно,
[10:19.320 --> 10:25.800]  когда мы запускаем dfs, мы потом по какому-то пути, то есть возьмем начало ребра в другую
[10:25.800 --> 10:37.440]  компоненту, который ведет в ту нашу компоненту c2. Ну тогда понятно, что здесь вот как раз не
[10:37.440 --> 10:46.840]  будет той проблемы, которую мы наблюдали раньше. Значит, смотрите, давайте рассмотрим вот этот
[10:46.840 --> 11:09.720]  вот путь. Пусть, как бы его назовем, давайте x, первая вершина на пути c1, c2. То есть опять,
[11:09.720 --> 11:14.160]  я могу нарисовать такую картинку, только здесь же будет верно такое, что у меня не будет как бы
[11:14.160 --> 11:18.440]  ребер в x. То есть раньше у меня была такая проблема, что если я рассматриваю на вот этом вот пути,
[11:18.440 --> 11:23.320]  ну вершину с минимальным t1, где-нибудь вот здесь она могла быть, тогда у меня могло быть ребро
[11:23.320 --> 11:29.080]  в начало. Вот, а сейчас такого же точно не будет, потому что я беру такую вершинку x, да, это первая
[11:29.080 --> 11:35.360]  вершина на пути отсюда-сюда. Ну то есть такая, что x еще в c1, а следующий уже не в c1. Вот это вот
[11:35.360 --> 11:42.440]  в c1, в первой компоненте это уже не в c1. Не в c1. Тогда опять то же самое, рассмотрим вершину с
[11:42.440 --> 12:00.920]  минимальным t1 на этом пути. Так, с минимальным значением t1 от w на этом пути. Вот, первый случай такой
[12:00.920 --> 12:08.480]  же, что если w совпадает с началом, то все хорошо, потому что если x это вершина первая, в которую мы
[12:08.480 --> 12:13.400]  попали на всем этом пути, то значит, когда мы в нее зашли, это все белое, раз у нее минимальный t1,
[12:13.400 --> 12:18.480]  значит, к моменту времени выхода из x мы посетим весь этот путь, в частности эту вершину, то есть мы
[12:18.480 --> 12:26.880]  выйдем отсюда раньше, чем выйдем отсюда. Первый шаг остается. Полей на белых путях.
[12:26.880 --> 12:47.160]  Полей на белых путях. tout от w меньше, чем tout от x. Причем здесь можно в качестве w взять,
[12:47.160 --> 12:57.360]  на самом деле, любую вершину из c2. Где w любая из c2. Потому что если вот это произвольная вершина из
[12:57.360 --> 13:02.560]  c2, то я ее могу продлить, то есть я вот дошел до какой-то вершинки из c2. Дальше я могу продлить
[13:02.560 --> 13:06.800]  до произвольной вершинки v, потому что я знаю, что здесь есть пути во все стороны, значит,
[13:06.800 --> 13:13.160]  я этот путь могу там довести до v, до произвольной вершинки. И опять у меня есть какой-то один сплошной
[13:13.160 --> 13:26.040]  путь, значит, выйду отсюда я раньше, чем выйду из начала. Нужен второй случай, когда w это не x.
[13:43.160 --> 13:58.520]  Так, ну тогда можем заметить следующее. Если это первая вершина, которую мы встретили на этом пути,
[13:58.520 --> 14:05.600]  то к моменту времени выхода из нее, когда этот DFS закончится, я x точно посетить не смогу.
[14:05.600 --> 14:14.240]  Потому что пока эта вершина обрабатывается, то есть с момента времени t in от w до t out от w,
[14:14.240 --> 14:20.120]  у меня по сути происходит обработка вершины w, то есть достигнется все, что достижено из нее. Но
[14:20.120 --> 14:27.600]  x тогда за это время точно не посетится, потому что нет вот такого пути. Ну нет такого пути точно.
[14:27.600 --> 14:34.160]  Мы предположили, что x это единственная вершина из компоненты сильно связанной с ц1, значит все
[14:34.160 --> 14:39.080]  остальные точно в ц1 не лежат, в частности из них нет пути в x. Поэтому в x мы никогда не попадем.
[14:39.080 --> 14:44.560]  Значит, к моменту времени выхода отсюда x еще не будет посещена, но зато будет посещено все,
[14:44.560 --> 14:49.440]  что находится правее, потому что это белый путь. Вот, и тогда все хорошо. Мы сначала выйдем оттуда,
[14:49.440 --> 15:16.640]  потом зайдем сюда и выйдем отсюда. Поскольку w не принадлежит ц1, к моменту времени t out от w,
[15:16.640 --> 15:34.360]  вершина x все еще будет белая. Это с одной стороны. Ну а с другой стороны все вот это посетится,
[15:34.360 --> 15:39.800]  опять-таки поля на белых путях. Значит, вот то, что мы здесь в конце были в ц2, ц2 вся посетится,
[15:39.880 --> 15:54.120]  мы не успеем выйти до того, когда же вошли в x. Но ц2 целиком посетится. Значит, можно написать
[15:54.120 --> 16:04.360]  следующее, что максимальное время выхода во всем v из ц2 будет меньше, чем время выхода из x.
[16:04.360 --> 16:10.600]  Но этого достаточно для доказательства утверждения. Там у нас было вот здесь,
[16:10.600 --> 16:16.200]  что нужно взять максимум по всем t out, то есть по всем t out из ц1. Но здесь мы взяли
[16:16.200 --> 16:20.320]  какое-то конкретное, поэтому это можно оценить еще сверху как максимум по всем вот этим t out.
[16:20.320 --> 16:27.520]  Значит, этого достаточно. Так, есть ли вопросы? Да, получился сомбурный, извините, но вот вроде
[16:27.520 --> 16:33.840]  сейчас мы все доказали. По крайней мере, наше утверждение. Так, хорошо, теперь давайте
[16:33.840 --> 16:52.680]  поймем, зачем это нам нужно. Ну, я утверждаю следующее, что в каждом момент времени вот этого
[16:52.680 --> 16:57.000]  нашего алгоритма двухчасно, ну, точнее, вот на втором шаге, когда мы запускаем DFS по обратным
[16:57.000 --> 17:03.480]  ребрам, после каждого запуска DFS мы откусываем целиком какой-то компонент усиленно-связанности.
[17:03.480 --> 17:07.400]  Это, собственно, то, что нам нужно доказать, что когда мы запускаем DFS по обратным ребрам от
[17:07.400 --> 17:12.120]  какой-то вершины, мы посещаем целиком какую-то компоненту связанности и больше ничего. То есть
[17:12.120 --> 17:17.440]  каждый вот этот вот, каждый запуск DFSR по обратным ребрам выделяет нам ровно одну компоненту
[17:17.440 --> 17:22.240]  цельно-связанности. Если мы докажем, то будет все верно. Ну, смотрите, значит, как эта штука
[17:22.240 --> 17:29.120]  работает. Пусть, ну, давайте индукции по вот этому вот списку вершин в порядке убывания т-аутов.
[17:29.120 --> 17:35.880]  Пусть мы несколько компонентов цельно-связанности выделили, их все посетили и пометили все вершины
[17:35.880 --> 17:42.720]  в них посещенными. Значит, индукция по количеству сделанных шагов. Дальше, вот это вот DFSR
[17:42.720 --> 17:48.160]  запускается от вершины с максимальным т-аутом, который не лежит ни в одной из обработанных
[17:48.160 --> 18:14.880]  ксс. Давайте это запишем. Каждый раз DFSR запускается от вершины ранее не посещенной
[18:14.880 --> 18:31.680]  этим самым DFSR. Ранее не посещенный вот этим самым DFSR по обратным ребрам с максимальным т-аутом,
[18:31.680 --> 18:43.440]  с максимальным значением т-аут. Ну, то есть есть какая-то вершина В, которая не лежит в этих
[18:43.440 --> 18:47.400]  компонентах, которые мы уже рассмотрели, и ее т-аут максимально среди всех нерассмотренных. Ну,
[18:47.400 --> 18:51.640]  тогда мысль первая. Она в какой-то компоненте цельно-связанности точно лежит, причем эта
[18:51.640 --> 18:56.640]  компонента отлична от вот этих вот уже рассмотренных. Значит, если я запущу DFSR по обратным ребрам из нее,
[18:56.640 --> 19:02.360]  то как минимум ее компоненту цельно-связанности я точно посещу. Я точно в них вовсе зайду,
[19:02.360 --> 19:08.720]  потому что это какой-то множество вершин, в частности из которых есть пути В, потому что
[19:09.400 --> 19:14.400]  есть пути в обе стороны. Если я буду ходить по обратным ребрам из В, то я обязательно посещу
[19:14.400 --> 19:22.240]  целиком всю компоненту цельно-связанности. Давайте я ее назову как-нибудь В. Запускаемся от вершины
[19:22.240 --> 19:33.480]  В с максимальным значением т-аута от В. DFSR от В точно посетит всю компоненту цельно-связанности
[19:33.480 --> 19:44.400]  от В к SSV. Потому что мы предполагаем, что у нас посещенными отмечены только несколько компонент.
[19:44.400 --> 19:51.320]  В соответственно не посещена, значит вся ее компонента не посещена. Поэтому по обратным
[19:51.320 --> 19:56.560]  ребрам мы точно достигнем все вот этого. Теперь последнее, что осталось сделать, это показать,
[19:56.560 --> 20:00.240]  что мы не посетим никакие другие вершины, что мы не посетим вершины из других компонентов.
[20:00.240 --> 20:04.800]  Ну пусть посетим, пусть есть какая-то ещё другая компонента, с сильной связанности,
[20:04.800 --> 20:10.400]  отличная от тех посещенных и отличная от настоящих компонентов с сильной связанности вершины V.
[20:10.400 --> 20:18.880]  Если мы ее посетим, это значит, что есть некий путь по обратным ребрам из V в это компонент
[20:18.880 --> 20:24.200]  цельно-связанности. Путь по обратным ребрам, не проходящий по посещенным вершинам,
[20:24.200 --> 20:28.540]  нам ведущий в другую компоненту сильно связанности. Давайте
[20:28.540 --> 20:53.200]  это тоже запишем. DFSR от V работает некорректно
[20:53.200 --> 21:09.960]  только если из V есть путь по обратным ребрам
[21:09.960 --> 21:15.520]  в другую КСС. Ну и все вершины не посещены на этом пути,
[21:15.520 --> 21:18.560]  потому что в посещенные мы не ходим. Ну тогда это
[21:18.560 --> 21:21.720]  противоречит с утверждением, потому что если вот эта
[21:21.720 --> 21:26.000]  вот компонента сильно связанности какая-то другая, причем она
[21:26.000 --> 21:29.000]  целиком не посещена в этот момент, ну мы считаем, что
[21:29.000 --> 21:33.800]  до запуска DFSR у меня целиком посещены несколько компонент
[21:33.800 --> 21:36.400]  сильно связанности целиком. Вот эти вот три. Значит целиком
[21:36.400 --> 21:41.000]  тогда не посещена. Ну тогда извините, если у меня есть
[21:41.000 --> 21:44.120]  путь из одной компоненты сильно связанности в другую,
[21:44.120 --> 21:46.000]  значит по нашему утверждению максимальный т-аут вот
[21:46.000 --> 21:48.720]  здесь вот больше, чем максимальный т-аут вот здесь. Значит
[21:48.720 --> 21:55.200]  V это не вершина с максимальным т-аутом, как мы предположили.
[21:55.200 --> 22:01.960]  Ну тогда мы получаем, что есть путь между двумя компонентами
[22:01.960 --> 22:07.640]  сильно связанности С1 и С2. Значит вершина с максимальным
[22:07.640 --> 22:14.320]  т-аутом это не V, а какая-то вершина С1. Ну не обязательно
[22:14.320 --> 22:16.280]  С1, возможно откуда-то из другого места, но главное,
[22:16.280 --> 22:21.640]  что точно не V. Значит вершина с максимальным значением
[22:21.640 --> 22:40.760]  т-аут это не V. Ну вот как-то так. Вопросы? Давайте еще
[22:40.760 --> 22:46.320]  раз тогда овервью, чтобы не было дырок. Значит смотрите,
[22:46.320 --> 22:48.400]  мы доказываем по сути такое утверждение, что если есть
[22:48.400 --> 22:53.000]  путь между двумя компонентами сильно связанности С1 и С2,
[22:53.000 --> 22:55.320]  то максимальный т-аут здесь больше, чем максимальный
[22:55.320 --> 22:57.680]  т-аут здесь. Максимальный т-аут в первой, больше
[22:57.680 --> 23:00.680]  максимальный т-аут во второй. Это вот мы как-то доказали.
[23:00.680 --> 23:03.200]  Дальше почему корректен наш алгоритм Касараю. Ну мы
[23:03.200 --> 23:06.800]  доказываем индукции по числу запусков DFSR, что он делает
[23:06.800 --> 23:11.120]  следующее. После каждого запуска он находит несколько
[23:11.120 --> 23:14.640]  компонентов сильно связанности, выводит их и посещенными
[23:14.640 --> 23:18.000]  считает только целиком несколько компонентов. То
[23:18.000 --> 23:19.880]  есть каждый компонент либо целиком посещена, либо
[23:19.880 --> 23:23.440]  целиком не посещена. Тогда если я выбираю вершину с
[23:23.440 --> 23:27.080]  максимальным т-аутом, который еще не посещена, и предполагаю,
[23:27.080 --> 23:29.880]  что мой алгоритм работает некорректно, и посещает
[23:29.880 --> 23:32.560]  кроме правильных компонентов еще какой-то мусор, еще
[23:32.560 --> 23:39.380]  это часть другой компоненты, то это значит, что эта компонента целиком не посещена, а значит из утверждения
[23:41.380 --> 23:43.380]  из утверждения
[23:43.660 --> 23:48.720]  t-out здесь должен быть больше, чем t-out здесь, ну по крайней мере максимальный t-out здесь больше, чем максимальный t-out здесь, а
[23:48.880 --> 23:52.560]  значит v у нас была была была выбрана неправильно, нам нужно было v взять отсюда
[23:53.480 --> 23:55.480]  окей?
[23:58.160 --> 24:00.160]  Ну окей
[24:02.560 --> 24:04.560]  окей
[24:12.440 --> 24:14.440]  хорошо тогда простое замечание
[24:19.560 --> 24:21.560]  о том, что такое конденсация графа
[24:26.680 --> 24:28.680]  конденсация
[24:32.680 --> 24:39.680]  значит, ну собственно это вот тот граф, когда мы кss объединяем в большие кружочки такие, то есть мы в качестве новых вершин рассматриваем
[24:39.680 --> 24:43.920]  кss в исходном графе, а ребра оставляем только между кss
[24:44.880 --> 24:48.200]  конденсация это опять-таки граф, вершины которого это кss
[24:49.320 --> 24:51.320]  вершины это кss
[24:51.640 --> 24:53.640]  ну а ребра это ребра между кss
[24:54.680 --> 24:56.680]  в исходном графе
[24:56.680 --> 25:03.320]  еще давайте скажем, что кратные ребра удаляем
[25:06.840 --> 25:08.840]  кратные удаляем
[25:12.840 --> 25:14.840]  ну какой-нибудь пример давайте сразу
[25:14.840 --> 25:16.840]  вот
[25:24.600 --> 25:27.040]  вот есть у меня такие три компонента из сильной связности
[25:28.000 --> 25:32.480]  первая, вторая, третья и между ними могут быть кинуть ребра например вот такое
[25:33.240 --> 25:35.240]  вот такое и вот такое
[25:36.120 --> 25:39.080]  когда после конденсации у меня будет граф из трех вершинок и
[25:41.240 --> 25:44.080]  двух ребер вот так и вот так
[25:45.000 --> 25:52.280]  то есть вот эти вот два сжались, потому что в этом графе они были бы, ну по сути кратные ребра, отсюда сюда два ребра
[25:52.280 --> 25:54.280]  мы не рисуем, мы рисуем только одно
[25:54.280 --> 25:56.280]  ну и дальше вот это вот
[25:56.600 --> 25:58.600]  превращается в такое ребро
[26:00.320 --> 26:05.960]  простое наблюдение, что получившийся граф, получившаяся конденсация это всегда дак, всегда цикличкий граф
[26:14.840 --> 26:16.840]  всегда так, то есть это циклический граф
[26:39.800 --> 26:43.040]  ну это несложно, значит если бы у меня был какой-то цикл, то
[26:43.040 --> 26:46.940]  Если fucker у меня был какой-то цикл, то что значит, что у меня есть цикл между
[26:46.940 --> 26:51.440]  какими-то компонентами? Что-нибудь вот такое я нарисую то значит, что есть путь отсюда
[26:51.440 --> 26:55.840]  сюда дальше, здесь можно как-то добраться до вот этого начала ребра. Потом перейти
[26:55.840 --> 26:59.180]  по ребру, опять добраться до вот этого начала ребра. Короче говоря, у меня есть цикл
[26:59.180 --> 27:02.020]  между какими-то вершинами разных компонент стильно связанности.
[27:02.020 --> 27:05.160]  Ну значит в частности, они должны все лежать в одной компанией стильно связанности,
[27:05.160 --> 27:10.420]  потому что есть путь отсюда сюда и отсюда сюда, через вот Journey Part 2
[27:10.420 --> 27:13.560]  Поэтому, как минимум, вот эти две вершины должны были быть стянуты.
[27:13.560 --> 27:17.360]  Ну, противоречие, да, мы предположим, что они в разных ксс.
[27:17.360 --> 27:24.000]  Значит, давайте это распишем, что пусть у меня есть в этом графе, ну, от противного,
[27:24.000 --> 27:30.000]  пусть в этом графе есть какой-то цикл на вот этих вот компонентах сильно связанности.
[27:30.000 --> 27:36.200]  Он тогда порождается используя какие-то ребра в исходном графе из у1 в v1,
[27:36.200 --> 27:44.320]  из у2 в v2, из у3 в v3 и так далее. То есть в термах исходного графа вот эти вот ребра между компонентами,
[27:44.320 --> 27:48.780]  которые я здесь рисую, на самом деле были ребрами между вершинами у и ты, в и ты.
[27:48.780 --> 27:56.820]  Тогда давайте рассмотрим такой путь. Ну, начнем с ребра у1 в и1. Дальше, поскольку у меня v1 и u2
[27:56.820 --> 28:01.380]  лежат в одной компоненте сильно связанности, то у меня, конечно, есть путь между ними из v1 в u2.
[28:01.380 --> 28:09.660]  Потом используем ребро у2 v2. Дальше, поскольку v2 и u3 у меня в одной компоненте сильно связанности,
[28:09.660 --> 28:13.660]  то я могу между ними перейти, как хочу, потому что это одна ксс, ну и так далее.
[28:13.660 --> 28:20.100]  Собственно, в конце я дохожу до вот этой вот там vn, до последней вершинки. И поскольку они в одной
[28:20.100 --> 28:26.540]  ксс, то я могу дойти из одной в другую спокойно. Все, значит, есть цикл, поэтому все они должны
[28:26.540 --> 28:31.420]  лежать в одной компоненте сильно связанности. Раз есть цикл, то можно из одной попасть в другую
[28:31.420 --> 28:37.380]  и наоборот. Если есть какой-то цикл ориентированный, то можно на нем из любой вершины попасть в любую
[28:37.380 --> 28:43.580]  другую. Это очевидно. Ну, значит, они все должны лежать в одной ксс. Противоречие. Мы предположили,
[28:43.580 --> 28:57.780]  что как минимум у 1 v1 в разных. Противоречие. Вопросы? Хорошо. Ну вот, ну а с дагами мы умеем
[28:57.780 --> 29:04.340]  работать. То есть, если бы у меня была какая-нибудь задача про, скажем, подсчет числа путей в графе,
[29:04.340 --> 29:08.140]  то вот после конденсации, возможно, что-нибудь там бы получилось делать. То есть, возможно,
[29:08.140 --> 29:12.660]  нужно было бы просто на конденсации посчитать число путей, а мы это умеем делать с помощью топ-сорта,
[29:12.660 --> 29:27.740]  и динамики какой-нибудь. Хорошо. Значит, пример, зачем это может быть нужно, это решение задачи
[29:27.740 --> 29:35.980]  2-сад. Зачем нужно выделять компоненты сильно связанности? Задача 2-сад ставится следующим
[29:35.980 --> 29:48.620]  образом. У вас есть формула в 2-кНФ. Значит, 2-кНФ это конъюнкция нескольких скобок. В каждой
[29:48.620 --> 30:04.540]  скобке стоит дизюнкция ровно двух литералов. Конъюнкция нескольких скобок. Каждая скобка
[30:04.540 --> 30:29.340]  это дизюнкция ровно двух литералов. Ну а литерал это переменная или отрицание переменной.
[30:29.340 --> 30:40.740]  Литерал это переменная или отрицание переменной. И наша задача это сказать,
[30:40.740 --> 30:44.740]  является ли данная формула выполнимой, ну или найти у нее выполняющий набор. То есть,
[30:44.740 --> 30:48.500]  найти такой набор ограничений переменных, чтобы формула на этом наборе была истинна.
[30:48.500 --> 31:05.660]  Найти выполняющий набор, то есть, ну я так напишу, набор Х1 и так далее ХН, что ФИ на этом
[31:05.660 --> 31:15.100]  наборе истинна. Ну найти какой-нибудь или сказать, что его не существует, сказать,
[31:15.100 --> 31:30.500]  что формула не выполнима. Эта задача решается так. Давайте мы для каждой буквы,
[31:30.500 --> 31:36.580]  для каждой переменной точнее заведем по две вершины. Каждую переменную мы превратим в
[31:36.580 --> 31:42.900]  две вершины, пометим их соответственно П и не П. Вот, если у меня есть там еще какая-то переменная
[31:42.900 --> 31:48.140]  Q, то я ее опять раздвою, будет у меня вершина, отличающая Q и вершина, отличающая не Q и так далее.
[31:48.140 --> 31:58.220]  Для каждой вершины, для каждой переменной две вершины. Дальше каждое ребро, ну например,
[31:58.220 --> 32:06.660]  точнее каждую скобку, например Х или Y, я превращу в два ребра. А именно, я просто напишу каким
[32:06.660 --> 32:11.820]  импликациям вот эта дизинкция эквивалентна и проведу ровно такие ребра, как написано в
[32:11.820 --> 32:20.780]  импликации. Мы знаем, что это то же самое, что не X стрелка Y, это то же самое, что не Y стрелка X.
[32:20.780 --> 32:31.260]  Интуитивный смысл такой, что чтобы дизинкция была истинна, вам нужно, чтобы если бы не X,
[32:31.260 --> 32:37.100]  то есть если X 0, то Y обязательно единица. Если не это, то вот это. Или что то же самое,
[32:37.100 --> 32:44.900]  если не Y, то X. Вам нужно, чтобы хотя бы один из них был единичкой. Значит, если у вас не Y или не X,
[32:44.900 --> 32:52.900]  то соответственно X или Y. Ну поэтому, давайте на этом примере нарисуем. Есть у меня X, есть у меня Y.
[32:52.900 --> 33:00.140]  Они тоже превратились в какие-то вершинки. Ну и я рисую просто вот эти вот два ребра,
[33:00.140 --> 33:04.540]  вот эти две импликации, которые эквивалентны исходной дизинкции. Рисую вот такое ребро и вот
[33:04.540 --> 33:12.140]  такое ребро. Если у меня, скажем, было что-нибудь, ну давайте еще для примера нарисую. Если у меня
[33:12.140 --> 33:18.220]  есть что-нибудь типа не P или Q, что у меня здесь стоит не переменная, а отрица не переменная,
[33:18.220 --> 33:25.300]  например. Ну то же самое, я пишу каким импликациям это эквивалентно. Например, не Q стрелка не P,
[33:25.300 --> 33:37.940]  или P стрелка Q. Ну и рисую вот эти вот стрелки из не Q в не P и из P в Q. То есть вот какие
[33:37.940 --> 33:44.060]  импликации эквивалентны данной дизинкции, я такие стрелки рисую просто. Вот и дальше идет такое
[33:44.060 --> 33:52.980]  утверждение, что выполняющий набор существует, если и только если ни для какой переменной она
[33:52.980 --> 33:59.060]  и ее отрицание не лежат в одной компанией сильно связанности. Значит, phi выполнимо,
[33:59.060 --> 34:07.180]  ну выполнимо, то есть у нее вот есть набор, на котором она единица. Если и только если не
[34:07.180 --> 34:22.180]  существует такой переменной P, что P и не P лежат в одной ксс. Соответственно, алгоритм проверки
[34:22.180 --> 34:27.300]  выполнимости такой. Мы смотрим на формулу, устроим паниграф вот по тому правилу, как я
[34:27.300 --> 34:32.340]  описал, и дальше просто разбиваем все на ксс, на компанией сильно связанности, и для каждой
[34:32.340 --> 34:37.140]  переменной проверяем, а правда ли, что P и не P в одной ксс, да или нет. Если есть хотя бы одна
[34:37.140 --> 34:42.140]  переменная, что вот эти вот две вершины в одной ксс, то все плохо, формула невыполнима. Иначе
[34:42.140 --> 34:52.940]  покажем, что выполнима. Ну, мы на самом деле для каждой вершины будем просто хранить номер ксс,
[34:52.940 --> 34:59.380]  в которой она лежит. И вот когда косараю работает, мы просто вот храним номер итерации, который мы
[34:59.380 --> 35:04.820]  запускаем DFS по обратным ребрам, и все что посещаем, им говорим, что у них номер ксс,
[35:04.820 --> 35:09.340]  там ноль, потом это увеличиваем, у них у всех будет один и так далее. Просто для каждой вершины
[35:09.340 --> 35:25.060]  храним номер ксс. Так, давайте доказывать. Сверху вниз получается, что если выполнима,
[35:25.060 --> 35:38.140]  то не может быть вот такого. Начну это просто. Предположим противное. Пусть есть какие-то две
[35:38.140 --> 35:45.140]  вершины, есть какая-то переменная, такая, что она и ее отрисование лежат в одной ксс. Одна ксс.
[35:45.140 --> 35:54.540]  Раз-то одна ксс, то получается есть путь в обе стороны. Есть путь из П вне П, и есть путь из не П в П.
[35:54.540 --> 36:02.420]  Теперь давайте вспоминать, какой мы смысл вкладывали вот эту импликацию в эти стрелочки. Смысл был
[36:02.420 --> 36:09.500]  такой, что если верно начало стрелочки, то должно быть верно конец стрелочки. Если П,
[36:09.500 --> 36:22.260]  если П, то вот это, если это, то вот это, если это, то вот это и так далее. То есть если верно
[36:22.260 --> 36:27.180]  какая-то вершина, то есть если она соответствует истинному литераллу, тогда все что из нее достижено,
[36:27.180 --> 36:33.100]  тоже должно быть истинно. Ну вот просто по тому правилу, что вот здесь, давайте смотреть. Если
[36:33.100 --> 36:37.980]  не х, то есть если вот это вот верно, то должно быть верно вот это. Если не у, то должно быть верно
[36:37.980 --> 36:44.860]  вот это. Ну а в тернах нашего графа, если какая-то вершина соответствует истинному литераллу,
[36:44.860 --> 36:49.620]  то все достижимое из нее должно быть истинно. Ну понятно, что такого быть не может, потому что
[36:49.620 --> 36:54.540]  понятно, что хотя бы одна из них соответствует единичке, то есть хотя бы один из этих литераллов
[36:54.540 --> 37:00.780]  истинной, например П. Пусть П равно единице в выполняющем нашем наборе. Тогда единица должна
[37:00.780 --> 37:05.960]  быть здесь, здесь, здесь, здесь и здесь. Соответственно не П, тоже единица. Противоречие. Если П равно
[37:05.960 --> 37:10.260]  нелюys, то тогда соответственно, наоборот это единица и тогда здесь должна быть единица,
[37:10.260 --> 37:14.220]  здесь единица, здесь единица, здесь единица, здесь единица и здесь единица, опять противоречие.
[37:14.900 --> 37:19.540]  Мы никак не можем выбрать значение П, чтобы у меня все было не было противоречием
[37:19.540 --> 37:26.900]  вот этих вот двух путях. Давайте я основную идею здесь запишу, что если какая-то вершина
[37:26.900 --> 37:43.260]  соответствует истинному литералу, то все, что из нее достижимо, тоже должно быть истинной литералы.
[37:43.260 --> 38:11.340]  Согласны? Ну тогда обратно, снизу вверх, что если вот такой картинки нету, не для какой
[38:11.340 --> 38:18.700]  переменной, то есть нет явных противоречий, тогда получится найти набор. Давайте его построим.
[38:18.700 --> 38:25.460]  Давайте скажем следующее, что пусть, ну во-первых, чтобы это сделать, чтобы проверить,
[38:25.460 --> 38:29.900]  что все вершины, точнее, что для каждой переменной у меня п и не п в разных ксс,
[38:29.900 --> 38:33.900]  мы запускаем алгоритм Касараю, и он разбивает нам все на компоненты сильной связанности.
[38:33.900 --> 38:45.180]  Так вот, пусть алгоритм Касараю для каждой вершины сохраняет номер ее ксс.
[38:45.180 --> 39:03.380]  Для каждой вершины сохраняет номер ее ксс. Я буду обозначать как С от В. То есть для каждой
[39:03.380 --> 39:10.620]  вершинки В у меня хранится число С от В, равное номеру ее компоненты. Значит, на первом шаге,
[39:10.620 --> 39:16.500]  когда я запускаю первый раз ДФС по обратным ребрам, я все достижимые по обратным ребрам вершины
[39:16.500 --> 39:21.820]  говорю, что они в нулевой компоненте, и для них говорю, что С это ноль. Дальше все, что мог посетил,
[39:21.820 --> 39:26.940]  на следующем шаге беру там вершину с максимальным тавом, непосещенную, посещаю из нее все,
[39:26.940 --> 39:32.020]  что достижено по обратным ребрам, говорю, что у них С единичка, ну и так далее. То есть храню какой-то
[39:32.020 --> 39:41.580]  там счетчик и увеличиваю, когда перехожу к новой ксс. Ну тогда мы в частности понимаем,
[39:41.580 --> 39:51.100]  что для любой вершины П С от П и С от не П это разные числа, не одинаковые. Для любой переменной
[39:51.100 --> 39:58.820]  С от П не равно С от не П. Ну потому что если было равенство, то они были бы в одной ксс,
[39:58.820 --> 40:10.700]  а мы предполагаем, что они в разных. Тогда давайте скажем следующее, что П равно единице,
[40:10.700 --> 40:23.500]  если и только если С от П больше, чем С от не П. Ну то есть чтобы определить значение какой-то
[40:23.500 --> 40:29.900]  переменной, я смотрю на номер компонента сильной связанности для вершинки П и для вершинки не П.
[40:29.900 --> 40:34.540]  Если вот выполняется такое неравенство, говорю, что значение П равно единице. Ну и соответственно
[40:34.540 --> 40:40.460]  наоборот, П я ставлю равно нулю, если выполняется неравенство С от П меньше, чем С от не П.
[40:40.460 --> 40:52.380]  Вот я так задал значение всех переменных, я утверждаю, что это выполняющий набор. Покажем,
[40:52.380 --> 41:13.580]  что это выполняющий набор. Ну пусть не так. Что значит, что это неверно? Значит,
[41:13.580 --> 41:20.140]  что формула не выполнилась, когда конъюнкция может не выполниться. Только если одна из скобок не
[41:20.140 --> 41:24.180]  выполнилась. Конъюнкция нулевая, если только если хотя бы одна из скобок нулевая, хотя бы
[41:24.180 --> 41:30.020]  один из конъюнктов нулевой. Ну окей, значит есть какая-то скобка, скажем, х или у, которая на этом
[41:30.020 --> 41:35.580]  наборе оказалась сложная. Есть хотя бы одна такая скобка, вот пусть это какая-то скобка х или у,
[41:35.580 --> 41:46.060]  где х и у такие литералы. Хорошо, значит когда такое могло произойти? Только если они оба были нулями,
[41:46.060 --> 41:55.460]  что дизюнкция нулевая, если оба дизюнкты нулевые. Х равно нулю и у равно нулю. С одной стороны. Это
[41:55.460 --> 42:00.140]  значит, что раз они нулевые, то выполняются вот такие вот неравенства на номера их компонент
[42:00.140 --> 42:06.180]  сильно связанности. Давайте тоже напишем, что мы знаем, что c от x меньше, чем c от не x,
[42:06.180 --> 42:12.820]  потому что я x поставил нулем. То же самое с у, c от y меньше, чем c от не y, потому что я y поставил
[42:12.820 --> 42:19.980]  нулем. Но при этом, поскольку у меня вот эта вот скобка присутствует в исходной формуле,
[42:19.980 --> 42:28.060]  то у меня на самом деле в моем графе точно есть ребра вот эти вот, из не x в y и из не y в x. Потому
[42:28.060 --> 42:34.060]  что если была такая скобка, то точно таки есть два ребра. Давайте я их здесь нарисую. Есть вот
[42:34.060 --> 42:42.740]  такое ребро и вот такое ребро. Из не x в y и из не y в x. Согласны?
[42:42.740 --> 43:05.500]  Так, побольше хочу картинку нарисовать, x не x, y не y. Знаю, что есть вот такие ребра перекрестные.
[43:05.500 --> 43:10.540]  И при этом номер компонента вот здесь меньше, чем здесь, а здесь меньше, чем здесь.
[43:10.540 --> 43:17.540]  Хорошо. Давайте заметим следующее.
[43:17.540 --> 43:33.860]  Заметим следующее, что c от не x гарантированно не больше, чем c от y.
[43:33.860 --> 43:43.060]  Ну вообще, я хочу сказать следующее, что если есть две вершины, соединенные ребром, из одной
[43:43.060 --> 43:47.420]  есть ребро в другую, то номер и компоненты сильно связанности, которые находит алгоритм Косарая,
[43:47.420 --> 43:56.060]  у этой вершинки гарантированно не больше, чем у этой. Ну почему это так? Во-первых, если они в одной
[43:56.060 --> 44:00.740]  ксс, то здесь равенство и все хорошо. Если они в одной ксс, то здесь равенство и все нормально.
[44:00.740 --> 44:09.300]  Иначе пусть они в разных ксс. Значит, вот y в какой-то ксс и не x в какой-то другой ксс. Ну тогда
[44:09.300 --> 44:14.300]  работает наше утверждение про корректность Косараю, что если есть путь из одной ксс в другую,
[44:14.300 --> 44:20.100]  то это обработается раньше. Если есть путь из одной в другую, то обработается раньше та из которой
[44:20.100 --> 44:24.900]  есть путь. Поэтому, значит, наш алгоритм вот эту ксс найдет раньше, чем вот эту. Поэтому здесь будет
[44:24.900 --> 44:31.900]  строго неравенство. Ну и аналогично вот с этими двумя вершинками. С вот не y будет не больше,
[44:31.900 --> 44:35.780]  чем с вот x. Опять, потому что есть ребра отсюда-сюда, значит, они либо в одной ксс,
[44:35.780 --> 44:43.220]  либо Косараю найдет сначала вот эту ксс, потом вот эту. Ну все, а здесь уже, я утверждаю,
[44:43.220 --> 44:47.260]  что написано какое-то противоречие. Осталось вот эти вот четыре неравенства совместить и получить,
[44:47.260 --> 44:58.780]  что там z меньше, чем z. Давайте начну с c от x. Я знаю, что это меньше, чем c от не x. Это знаю,
[44:58.780 --> 45:05.940]  что меньше равно, чем c от y. Это знаю, что меньше, чем c от не y. И это знаю, что не больше, чем c от x.
[45:05.940 --> 45:24.660]  Ну все противоречие от c от x меньше, чем c от x. Конец. То есть алгоритм решения 2sat следующий,
[45:24.660 --> 45:31.060]  мы строим граф, запускаем на нем алгоритм Косараю. Затем для каждой вершины, ну то есть алгоритм,
[45:31.060 --> 45:34.580]  в частности, для каждой вершины запоминает номер компонента сильной связности, где лежит эта
[45:34.580 --> 45:38.860]  вершина. Дальше мы проверяем, во-первых, что для каждой переменной вот эти вот два значения
[45:38.860 --> 45:44.980]  различны, то есть что p и не p всегда в разных ксс. Ну а дальше, в зависимости от номеров этих ксс,
[45:44.980 --> 45:48.980]  мы либо говорим, что переменная единичка, либо ноль. И просто выводим это в качестве ответа.
[45:48.980 --> 45:53.580]  Даже ничего не нужно перепроверять, это гарантируемо будет выполняющим набором. Я, конечно,
[45:53.580 --> 46:01.180]  не утверждаю, что это единственный выполняющий набор, но это один из подходящих. Вообще выполняющих
[46:01.180 --> 46:06.020]  наборов может быть много, но какой-то один мы нашли. И в принципе их может быть даже экспоненциально
[46:06.020 --> 46:17.220]  много, поэтому выводить их все это, ну короче, неосмысленно задача, скажем так. Вопросы? Да,
[46:17.220 --> 46:27.860]  хороший вопрос. Давайте вы на него ответите. Ну конечно, пока что у нас все алгоритмы были
[46:27.860 --> 46:35.020]  линейные, потому что по сути у нас все сводилось к dfs, а dfs мы знаем, что линейные. Давайте зафиксируем.
[46:35.020 --> 46:53.500]  Значит, алгоритм Косараю и алгоритм решения Двасат работают за линейное время.
[46:57.860 --> 47:09.460]  Ну почему Косараю за линию? Там два шага. Первый это запускать обычный dfs и вывести все в порядке
[47:09.460 --> 47:15.100]  убывания т-аутов, но это легко сделать с помощью просто одного dfs и выводить вершину, собственно,
[47:15.100 --> 47:23.180]  когда вершина, когда мы выходим из вершины, добавляем ее в вектор посещенных, потом его разворачиваем,
[47:23.180 --> 47:28.220]  чтобы получить в порядке убывания. А затем я просто прохожусь по вершинам и запускаюсь
[47:28.220 --> 47:32.740]  dfs по обратным ребраммам. Все, что там достижено, это очередная ксс. Здесь все линейно, никакая вершина
[47:32.740 --> 47:39.260]  дважды не посетится, поэтому время работы линейная. Двасат тоже получился линейным, потому что если
[47:39.260 --> 47:51.180]  у меня было, скажем, n переменных и m скобок, то граф, который я строю, имеет два n вершин и два m скобок.
[47:51.180 --> 48:07.340]  Ну а дальше просто косараю с линейной временной работы от 2n плюс 2m. Окей? Хорошо. Так, ладно.
[48:07.340 --> 48:15.500]  Значит, тогда с ориентированными графами мы вроде разобрались, базовое все сделали. Теперь давайте
[48:15.500 --> 48:25.940]  перейдем к неориентированным графам. DFS в Нюор графах.
[48:45.500 --> 48:51.500]  Главное замечание, главное отличие DFS в неориентированных графах от DFS в ориентированных графах следующее.
[48:51.500 --> 49:02.500]  Значит, смотрите, в ориентированных графах могла быть такая картинка. Как-нибудь вот так я ее нарисую.
[49:02.500 --> 49:09.500]  Что это значит? Что я сначала пошел как бы по вот этой вот ветке, все здесь посетил, потом помечаю их черными,
[49:09.500 --> 49:16.500]  откатываюсь назад и затем запускаюсь по этой ветке. И в частности, нахожу ребро в уже посещенную вершину,
[49:16.500 --> 49:22.500]  которая уже черная, помеченной черной. То есть я сначала до нее дошел, здесь посетил все, что можно, вышел из нее,
[49:22.500 --> 49:29.500]  пометил черный, вернулся сюда, а дальше нашел опять ребро в эту же вершину, но она уже черная. То есть в какие-то моменты времени бывали
[49:29.500 --> 49:37.500]  ребра в черной вершины. То есть в какой-то момент эта серая, эта серая, а эти черные. И есть ребро в черную.
[49:37.500 --> 49:45.500]  Но понятно, что если бы граф был неориентированный, то такого быть не могло. Потому что если, скажем, вот на этом ребре нет ориентации,
[49:45.500 --> 49:52.500]  то перед тем как отсюда выйти, я должен был бы ее посетить. Что если я дошел до сюда, здесь все прошел и хочу выйти,
[49:52.500 --> 49:56.500]  то мне нужно сначала еще вот сюда пройти и эту вершинку тоже пометьте использовать.
[49:56.500 --> 50:06.500]  Поэтому на самом деле в неориентированных графах не бывает ребер в черной вершины. Не бывает ребер в черной вершины.
[50:11.500 --> 50:18.500]  Ну это очень просто доказывается, что если мы в какой-то момент находим ребро в черную, вот есть В, а есть какое-то ребро из нее в какую-то вершины,
[50:18.500 --> 50:26.500]  которое уже покрашено в черный цвет. Ну значит извините, в момент времени, когда мы ее обходили, перед тем как покрасить ее в черный,
[50:26.500 --> 50:35.500]  нам нужно было начать обрабатывать ее. Значит до того как выйти отсюда, я должен был ее посетить.
[50:35.500 --> 50:43.500]  А я говорю, что наоборот, я захожу в нее после того как эту посетил. Этого быть не может. Поэтому никогда не бывает ребра в черные вершины.
[50:44.500 --> 50:55.500]  Это значит в частности, что нам на самом деле не нужны вот эти три цвета, белый, серый, черный, потому что черный у нас никогда не будет ребер в черной вершины.
[50:55.500 --> 51:07.500]  Поэтому нам будет достаточно двух цветов по сути, поскольку вот здесь черный, его мы никогда не увидим, то есть мы никогда не будем пытаться идти в черную вершину.
[51:07.500 --> 51:16.500]  Таких ребер мы никогда не увидим. Поэтому нам будет достаточно хранить как бы два значения, которые мы будем просто в виде буллевского флага запоминать.
[51:16.500 --> 51:28.500]  У нас будет вектор буллевских значений UST. И просто UST от V это были мы в данной вершине или нет. Запускали ли мы от нее DFS.
[51:29.500 --> 51:46.500]  То есть теперь вместо цвета храним метку посещаемости. Были ли мы в этой вершине. Вместо цвета храним метку посещенности UST.
[51:46.500 --> 52:02.500]  Ну и давайте я быстренько код перепишу. То есть вот тот код, который был в прошлый раз, он скорее для ориентированных графов, там где мы храним три цвета, белый, серый, черный.
[52:02.500 --> 52:10.500]  А здесь нам будет достаточно меток UST без цветов. Ну как всегда у нас граф хранится в векторе векторов.
[52:15.500 --> 52:23.500]  И вот здесь появляется вектор булл UST, который изначально заполнен фолсами, что все вершины изначально не посещены.
[52:23.500 --> 52:37.500]  Ну а дальше внутри все очень похоже на то, что было. Что мы хотим в какой-то вершине начаться с предыдущей вершины P.
[52:38.500 --> 52:48.500]  Ну здесь там начало такое же. Можем сохранить родителя parent of V равно P. Можем написать, что ты на V равно timer++, если мы хотим запоминать время входа.
[52:53.500 --> 53:04.500]  И здесь еще UST от V равно true будет у нас. Вместо того, что было раньше, color от V равно gray. То есть мы отказались от цвета, просто ее пометили посещенной.
[53:05.500 --> 53:19.500]  Ну а дальше проход по всем вершинам. Вот здесь еще появляется отдельный случай, что у нас вот это вот ребро, которое мы сейчас рассматриваем, это возможно ребро в родителя.
[53:19.500 --> 53:31.500]  Вот смотрите, я из P пришел в V, теперь находясь в V, я опять это ребро когда-то увижу. Поскольку у меня граф не ориентированный, то наличие такого ребра означает наличие обратного.
[53:32.500 --> 53:37.500]  И я как бы хочу его игнорировать, потому что я по нему уже прошел, нет смысла по нему вверх возвращаться.
[53:37.500 --> 53:52.500]  А, так, сейчас. Ну это на самом деле и так у нас обработается, да. Ну ладно, давай тогда просто напишем, что если UST от TUTO continue, да, это здесь пока можно делать.
[53:52.500 --> 54:00.500]  Если UST от TUTO continue, а иначе просто DFS to V, конец.
[54:05.500 --> 54:15.500]  Да, то есть если я пытаюсь пойти в вершину, где я уже был, причем вот это в частности включает случай, когда я пытаюсь пойти в родителя по тому ребру, которое только что в меня привело.
[54:15.500 --> 54:29.500]  Либо ну в какую-то другую вершину я пытаюсь попасть. Тогда я делаю просто continue, а иначе я понимаю, что эта вершина еще не посещена, она свежая, белая в старых терминах, значит я просто от нее запускаюсь и говорю, что в нее я попал из вершинки V.
[54:29.500 --> 54:49.500]  Вот, ну и здесь тоже работают замечания, например, про то, что на стеке у нас всегда лежат серые вершины, лежащие в одном пути, значит стек рекурсий всегда такой.
[54:49.500 --> 55:06.500]  Это какая-то вершина старта, от которой мы начали, и затем несколько вот таких вот ребер, все из которых сейчас обрабатываются в каком-то смысле.
[55:06.500 --> 55:13.500]  То есть вот это вот, скажем, начало, корень старта вершины, затем я запустился от вот этой вершины, вот этой, вот этой, вот этой, и сейчас обрабатывается вот эта.
[55:13.500 --> 55:18.500]  Потом, когда я ее целиком обработаю, я ее со стека удалю и продолжу обрабатывать вот эту вот.
[55:18.500 --> 55:31.500]  Ну да, поскольку сейчас у меня уже нет понятия, что эти вершины серые, я просто говорю, что вот на стеке всегда лежит какой-то путь с началом в вершине, из которой мы начали исходный DFS.
[55:31.500 --> 55:40.500]  Ну и они как бы сейчас в работе. Когда я закончу обрабатывать последнюю, я вернусь к предпоследней на этом пути.
[55:40.500 --> 55:47.500]  Так, хорошо.
[55:47.500 --> 56:05.500]  Вот, можно еще вести такие определения, что ли. Можно сказать, что те ребра, которые наш DFS проходит, что это древесные ребра, вот эти вот ребра из V2, по которым я спускаюсь вниз, рекурсивно запускаюсь DFS, это древесные ребра.
[56:06.500 --> 56:22.500]  Ребра V2, когда запускается DFS2V, это древесные ребра.
[56:22.500 --> 56:44.500]  То есть вот когда я вижу, что я стою в V, хочу пойти в ту и ту не посещенное, ну unused, used еще равен там false, used от true равно false, значит я в нее спускаюсь и рекурсивно начинаю обход.
[56:44.500 --> 56:54.500]  Ну поэтому такое ребро называют древесным. Вот, а все остальные ребра будут обратные. Все остальные ребра обратные.
[56:54.500 --> 57:01.500]  И обратные они как раз в том смысле, что они ведут в какую-то одну из более ранних вершин на стеке рекурсии.
[57:01.500 --> 57:08.500]  Что все ребра, которые не являются древесными, они на самом деле обратные, то есть ведут куда-то выше именно на стеке рекурсии.
[57:08.500 --> 57:17.500]  Не в какую-то там другую вершину, не лежащую на стеке, а именно куда-то раньше на стеке. То есть то, что у нас раньше было в ориентированном графе, ребро в серую вершину,
[57:17.500 --> 57:26.500]  серые у меня лежали на стеке, и все вот как раз ребра, не являющиеся древесными, по которым не пускается DFS, это обязательно такое, которое раньше было как бы ребром в серую вершину.
[57:26.500 --> 57:34.500]  Что это цикл, ну получаем цикл из вершин на стеке.
[57:34.500 --> 57:42.500]  Ну вот почему, давайте я картинку нарисую, откуда все вот эти, почему это древесные ребра, а остальные обратные.
[57:42.500 --> 57:45.500]  Что-нибудь такое нарисуем.
[57:45.500 --> 58:03.500]  Ну вот как-то так может выглядеть наш граф.
[58:03.500 --> 58:11.500]  Значит, наш граф исходно неориентированный, есть все ребра, которые я нарисовал, и ребра со стрелочками, и вот эти пунктированные ребра снизу вверх тоже такие есть.
[58:11.500 --> 58:19.500]  Тогда как работает наш DFS? Он запускается отсюда, помечает использованный, находит это ребро, говорит, что оно древесное, запускается отсюда.
[58:19.500 --> 58:21.500]  Находит это ребро, говорит, что оно древесное, запускается отсюда.
[58:21.500 --> 58:25.500]  Ну то же самое здесь, потом сюда, потом сюда.
[58:25.500 --> 58:32.500]  Вот тут в этот момент находится, что есть ребро, ведущее в уже посещенную вершину.
[58:32.500 --> 58:38.500]  Тогда он это ребро называет обратным.
[58:38.500 --> 58:40.500]  Обратное ребро.
[58:40.500 --> 58:51.500]  Ну и за счет того, что мы как раз вот сказали, что если мы находим ребро в посещенную, мы заметили, что нет ребров в черной вершины, значит, на самом деле это обязательно ребро в серой вершины, которая как бы лежит на стеке.
[58:51.500 --> 59:02.500]  Поэтому все обратные ребра нам немедленно образуют некоторый цикл, что вот встав в этой вершинке, пройдя по этому обратному ребру, и затем обратно спустившись под древесный, мы получим цикл.
[59:02.500 --> 59:05.500]  Каждое обратное сдает нам некоторый цикл.
[59:05.500 --> 59:10.500]  Ну и здесь то же самое. Мы вот здесь все обошли, вернулись в корень, потом эти два назначили древесными.
[59:10.500 --> 59:18.500]  Затем это обнаруживаем в качестве обратного, продолжаем, продолжаем, продолжаем, находим еще одно обратное. Вот вам еще один цикл.
[59:18.500 --> 59:27.500]  Каждое обратное на самом деле просто стягивает некоторый цикл на нашем дереве, то есть какое-то дерево с корнем там, где мы начали и, ну вот это дерево сверху вниз,
[59:27.500 --> 59:30.380]  дерево сверху вниз. И есть некие обратные ребра, которые вот так вот стягивают
[59:30.380 --> 59:37.060]  какие-то пути на этом дереве. И главная мысль, что не бывает ребер между
[59:37.060 --> 59:44.500]  разными под деревьями. Вот таких вот ребер не бывает. Ну потому что как раз
[59:44.500 --> 59:48.900]  такое ребро означало бы, что я должен был... Что значит, что есть такое ребро, например?
[59:48.900 --> 59:53.140]  Это значит, что я сначала обошел все вот здесь, потом поднялся сюда и дошел
[59:53.140 --> 59:56.940]  до сюда. Но извините, тогда я вот это ребро пропустил, когда это обрабатывал. Я
[59:56.940 --> 59:59.340]  должен был бы тогда вот эту вершинку переподвесить сюда,
[59:59.340 --> 01:00:04.020]  значит дерево выглядело по-другому. Ну то есть как раз вот это ребро, оно было бы,
[01:00:04.020 --> 01:00:08.180]  скажем, ребром в чёрную вершину, когда я вот эту вершину обрабатывал. А мы поняли,
[01:00:08.180 --> 01:00:17.020]  что ребер в чёрной вершины нет. Так, шикарно.
[01:00:17.020 --> 01:00:27.740]  Вот. Ну давайте я еще словами проговорю, что как, скажем, проверять граф на связанность,
[01:00:27.740 --> 01:00:32.180]  как разбивать его на компоненты связанности и как проверять наличие цикла. Значит,
[01:00:32.180 --> 01:00:35.980]  как проверить, что он связанный? Просто встаём в любую вершинку, запускаем DFS,
[01:00:35.980 --> 01:00:41.700]  после DFS проверяем, что все вершинки у нас used, что все вершины посещены. Это, ну опять,
[01:00:41.700 --> 01:00:48.460]  в терминах ориентированных графов, это лем о белых путях. Что если мы встали в вершину,
[01:00:48.460 --> 01:00:53.260]  запустили DFS, то есть посетили все, что можно, тогда, поскольку раньше все было
[01:00:53.260 --> 01:00:56.700]  достижено по белым путям, то к моменту времени выхода мы посетим все, что было возможно.
[01:00:56.700 --> 01:01:02.460]  Значит, это связанность. Как разбить на компоненты связанности? Ну встаём в любую вершину,
[01:01:02.460 --> 01:01:08.500]  помечаем используемые все, что достижено из неё. То есть запускаем просто DFS,
[01:01:08.980 --> 01:01:12.980]  все, что возможно, и говорим, что это очередная компонента связанности. Встаем, ну как бы,
[01:01:12.980 --> 01:01:18.120]  то есть находим следующую непосещенную, запускаем от нее DFS, все, что из нее достижено,
[01:01:18.120 --> 01:01:22.420]  все, что достижено этим DFS-ом, это очередная компонента связанности. Вот. Ну и так далее.
[01:01:22.420 --> 01:01:27.620]  Это по сути опять лем о белых путях. Что я встал в вершину, достиг из неё всего,
[01:01:27.620 --> 01:01:31.360]  чего возможно. То есть ее компоненту связанности, по идее, выделил. Ну и так
[01:01:31.360 --> 01:01:37.020]  делаю для каждой вершины. И, наконец, третий вопрос про циклы, как проверить,
[01:01:37.020 --> 01:01:41.740]  если в этом графе циклы. Нужно просто узнать, если хотя бы одно обратное ребро, то есть есть ли
[01:01:41.740 --> 01:01:49.380]  ребро в более высокую вершину, есть ли ребро в уже посещенную вершину. Давайте я здесь аккуратнее
[01:01:49.380 --> 01:02:04.180]  это напишу. Проверка на ацикличность. Ну вот, в строчках, когда мы перебираем все исходящие
[01:02:04.180 --> 01:02:20.220]  ребра, надо добавить еще одну. Если ту равно п, тогда continue. То есть если я стою вершине и пытаюсь
[01:02:20.220 --> 01:02:24.820]  пойти по ну в общем ребру, по которому я только что пришел, то есть я спустился вниз, теперь обратно
[01:02:24.820 --> 01:02:28.660]  пытаюсь по нему перепрыгнуть, тогда нужно этот случай проигнорировать. У меня это ребро уже
[01:02:28.660 --> 01:02:34.660]  древесно, я его не должен рассматривать при попытке подняться вверх. А иначе, если я пытаюсь
[01:02:34.660 --> 01:02:46.340]  пойти в посещенную вершину, то есть если you start to, тогда мы нашли цикл. Ну а иначе просто
[01:02:46.340 --> 01:02:59.860]  dfs. Давайте я напишу так, не знаю, cycle, что мы нашли цикл, содержащий ребро из v в tu. И значит,
[01:02:59.860 --> 01:03:06.380]  чтобы его, скажем, целиком вывести, вот есть v, вот есть tu, тогда нужно встать в v, подниматься
[01:03:06.380 --> 01:03:15.180]  по parent до тех пор, пока мы не дойдем в tu, и в конце напишет последнее ребро из tu в v. Если мы ни одного
[01:03:15.180 --> 01:03:20.180]  такого цикла не обнаружили, значит в той комбинации связанности, от которой мы запустились, нет ни
[01:03:20.180 --> 01:03:40.700]  одному циклу. Так, хорошо. Вроде все просто. Так, тогда давайте посмотрим на критические
[01:03:40.700 --> 01:03:56.460]  ребра и вершины в неориентированном графе. Определение. Пусть g связан граф. Так, ну кажется,
[01:03:56.460 --> 01:04:00.620]  понятие связан я еще формально не определял, но связан это тот, у которого всего одна компонента
[01:04:00.620 --> 01:04:06.620]  связанности. То есть такая, что между любыми вершинами есть путь. Всего одна компонента связанности.
[01:04:06.620 --> 01:04:22.540]  Итак, пусть g связан граф, тогда ребро g называется мостом, если после его удаления граф становится
[01:04:22.540 --> 01:04:33.460]  несвязанным. Я напишу так g-e несвязанной. То есть я удалил одно ребро и граф сразу стал
[01:04:33.460 --> 01:04:46.700]  несвязанным. Но альтернативное определение можно не требовать, чтобы g был связанным изначально,
[01:04:46.700 --> 01:04:54.180]  и тогда надо будет говорить, что в этом графе g-e, в графе после выбрасывания ребра, если исходный
[01:04:54.180 --> 01:04:57.540]  граф был несвязан, то и новый тоже будет, конечно, несвязан. Нужно потребовать,
[01:04:57.540 --> 01:05:09.420]  что увеличится число компонент связанности. Альтернативно e это мост, если число компонент
[01:05:09.420 --> 01:05:23.100]  связанности в g-e больше, чем число компонент связанности в g.
[01:05:34.060 --> 01:05:38.140]  То есть тут уже на любителей. Либо вы говорите, что вы мосты определяете только в связанном графе,
[01:05:38.220 --> 01:05:42.300]  и тогда это любое ребро, которое делает граф несвязанным, то есть по сути расшипляет
[01:05:42.300 --> 01:05:46.380]  его хотя бы на две компоненты связанности. Либо вы говорите, что мосты определены в
[01:05:46.380 --> 01:05:49.940]  любом графе, не обязательно связанном, тогда нужно говорить, что число компонент связанности
[01:05:49.940 --> 01:06:01.300]  увеличится после удаления. Обычно я бы все-таки сказал, что вот это берется. Говорить про мосты
[01:06:01.300 --> 01:06:05.380]  адекватно, только если исходный граф связан. То есть вот у вас есть связанный граф, и вы хотите
[01:06:05.380 --> 01:06:10.700]  понять, какие ребра критичны в том смысле, что их удаление делает граф несвязанным. А здесь,
[01:06:10.700 --> 01:06:15.380]  ну не очень понятно. То есть у вас есть какой-то граф странный, не обязательно связанный, и тогда
[01:06:15.380 --> 01:06:19.300]  удаление ребра, ну как бы его оставляет несвязанным. Да, увеличивает число компонент, но непонятно,
[01:06:19.300 --> 01:06:23.380]  почему нам интересно вообще число компонент. А здесь хотя бы какая-то явная характеристика
[01:06:23.380 --> 01:06:36.020]  про связанность, чуть более естественная. Начну нашу цель от найти все мосты.
[01:06:43.540 --> 01:06:49.340]  Поясню еще раз, зачем это может быть нужно. Вот представьте, у вас есть какой-то связанный граф,
[01:06:49.340 --> 01:06:55.340]  ну не знаю, там какая-то сеть, и вам хочется понять, какие каналы взаимодействия, какие связи
[01:06:55.340 --> 01:07:01.020]  между вершинами, какие ребра по сути. Ну критично важно поддерживать. То есть если, скажем, какой-то
[01:07:01.020 --> 01:07:05.980]  канал сломается, если какое-то ребро удалится, то граф станет несвязанным, и скажем, они не смогут
[01:07:05.980 --> 01:07:10.220]  передать друг другу информацию. Если у вас есть там какие-то башенки, которые общаются по радио,
[01:07:10.220 --> 01:07:14.900]  то вот если у вас какая-то связь между башенками нарушится, то вы не сможете передать информацию
[01:07:14.900 --> 01:07:21.380]  из любой вершины в любую, вот будут какие-то уже отдельные куски несвязанные. Так, цель
[01:07:21.380 --> 01:07:35.100]  найти все мосты. Хорошо. Ну давайте сделаем следующее. Ведем такую функцию.
[01:07:35.100 --> 01:07:56.140]  Рет от v, от слова return. Это следующее. То есть минимум из tn от v и минимума tn от u,
[01:07:56.260 --> 01:08:07.180]  где u может выглядеть как-то так. Вот у вас есть вершинка v. Вы можете сначала взять несколько
[01:08:07.180 --> 01:08:14.620]  древесных ребер вниз и попасть в какую хотите вершину w, а дальше взять одно обратное ребро из w в u.
[01:08:14.620 --> 01:08:22.780]  И вот по всем таким возможным путям вам нужно найти минимальный tn от u. То есть вы, смотрите,
[01:08:22.780 --> 01:08:27.860]  вот у вас есть v, соответственно есть под дерево v. Это те вершины, которые достижены используя древесные
[01:08:27.860 --> 01:08:36.540]  ребра вниз. Вот как вы по dfs ушли, вот все, что вы обходите после входа в v и до выхода из v. Короче,
[01:08:36.540 --> 01:08:42.260]  что вы обходите во время обработки v, это под дерево v. Но вот вы можете спуститься в любую вершину
[01:08:42.260 --> 01:08:46.900]  под дерево и затем, используя только одно обратное ребро, прыгнуть куда-то наверх. И среди всех
[01:08:46.900 --> 01:08:56.740]  таких вершин взять минимальное tn. Формально это будет минимум по ребрам w, у. Таким, что это
[01:08:56.740 --> 01:09:04.020]  обратно, давайте я так напишу, минимум по всем обратным ребрам w, у. Таким, что w в под дереве v.
[01:09:04.020 --> 01:09:06.580]  w в под дереве v.
[01:09:23.580 --> 01:09:29.900]  Интуиция здесь тоже очень простая. Вот это вот red означает следующее, что если мы рассмотрим
[01:09:29.900 --> 01:09:34.300]  вот этот вот кусок, да, все по дереву w, рассмотрим, как что-то что-то неделимое,
[01:09:34.300 --> 01:09:40.300]  как компоненту связанности, грубо говоря, то вопрос, насколько высоко мы можем из нее прыгнуть
[01:09:40.300 --> 01:09:45.740]  используя одно ребро. То есть мы можем находиться здесь где угодно и при этом можем взять одно
[01:09:45.740 --> 01:09:50.780]  ребро куда-то вот наверх. То есть какое-то одно обратное ребро. И тогда, когда я беру минимум по
[01:09:50.780 --> 01:09:55.420]  всем вот этим вот tn, я по сути беру самую высокую из тех решений, куда я могу прыгнуть за один шаг.
[01:09:55.420 --> 01:10:10.660]  Тогда я утверждаю следующее. Древесное ребро e является мостом. Давайте я напишу так. Древесное
[01:10:10.660 --> 01:10:28.540]  ребро e равное паре uv. uvtu является мостом. Если только если в термиях вот этой вот функции,
[01:10:28.540 --> 01:10:45.820]  ну, например, rttu равно tntu. Можно так написать. Доказательства. Первое замечание, что
[01:10:45.820 --> 01:11:04.300]  не-древесные ребра мостами быть не могут. Не-древесные ребра мостами быть не могут. Ну потому что
[01:11:04.300 --> 01:11:08.860]  что такое древесные ребра? Это такие ребра, используя которые, идя сверху вниз, начиная
[01:11:08.860 --> 01:11:13.860]  из какого-то корня, я посещаю всю компоненту связанности. То есть вот я где-то встал, ну там,
[01:11:13.860 --> 01:11:18.940]  в какую-то корневую вершину. Дальше использую древесные ребра, посещаю все что возможно. Ребра
[01:11:18.940 --> 01:11:23.060]  такие сверху вниз, как я рисую на картинке. Ну понятно, что все остальные ребра, вот эти обратные
[01:11:23.060 --> 01:11:27.940]  ребра, они нам, если их удалить, то связанности от этого не нарушатся. Я могу удалить все обратные
[01:11:27.940 --> 01:11:33.460]  ребра, от этого древесные ребра останутся все, поэтому будет связанность. Значит, не-древесные
[01:11:33.460 --> 01:11:38.140]  точно на связанность не влияют. Они не могут быть мостами, потому что их удаление оставляет,
[01:11:38.140 --> 01:11:44.100]  ну собственно, вот этот каркас, по которому я могу дойти от корня до всех вершин. Окей, значит,
[01:11:44.100 --> 01:11:52.060]  остается рассматривать только древесные ребра, только они могут быть мостами. Ну что здесь надо
[01:11:52.060 --> 01:12:02.140]  сказать? Ну вот пусть есть какое-то ребро, да, древесное, из VF2. У меня был DFS, он сначала зашел сюда,
[01:12:02.140 --> 01:12:08.740]  затем увидел вот такое ребро в непосченую вершинку Ту, запустился там рекурсивно вот в этом вот
[01:12:08.740 --> 01:12:16.420]  поддереве и посчитал там как-то, что рита Ту равна 3 на Ту. Что это значит? Это значит, что вот отсюда
[01:12:16.420 --> 01:12:23.380]  из всего этого поддерева я не смогу никуда прыгнуть выше, чем в Ту. То есть нет вот таких ребер,
[01:12:23.380 --> 01:12:29.060]  ни такого, ни такого, никуда выше, чем в Ту я прыгнуть не смогу, потому что вот это вот равенство
[01:12:29.060 --> 01:12:35.540]  означает, что, ну вообще, какие значения может принимать рита Ту? Вот куда я могу прыгнуть,
[01:12:35.540 --> 01:12:41.740]  если я рассматриваю риту от какой-то вершинки? Я могу либо остаться вот в самом начале этого
[01:12:41.740 --> 01:12:47.740]  поддерева, либо куда-то, вот если я рассматриваю путь до корня, то я могу прыгнуть куда-то вот на
[01:12:47.740 --> 01:12:53.740]  этот путь от корня до V, да, и соответственно, чем меньше Тин, тем выше я нахожусь к корню,
[01:12:53.740 --> 01:12:59.820]  тем ближе к корню. А если здесь у меня рита Ту равна 3 на Ту, значит, я из всего этого поддерева не
[01:12:59.820 --> 01:13:04.940]  могу прыгнуть никуда, ни сюда, ни выше, ни выше, ну в общем, никуда в корень не смогу. Поэтому единственное,
[01:13:04.940 --> 01:13:11.420]  где я могу быть, это только в этом поддереве. Ну значит, если я просто это ребро удалю, то используя
[01:13:11.420 --> 01:13:17.140]  любые ребра здесь, что древесные, что обратные, я из этой компонента связанности не смогу добраться
[01:13:17.140 --> 01:13:24.460]  в В или выше. Давайте справа налево, да, это мы получается сделали, справа налево. Что если это
[01:13:24.460 --> 01:13:44.220]  верно, если рита Ту равно 3 на Ту, то после удаления ребра ВТУ, после удаления ребра ВТУ,
[01:13:44.220 --> 01:14:03.180]  не будет пути между В и Ту. Ну потому что еще раз, как может выглядеть путь между, давайте так,
[01:14:03.180 --> 01:14:08.980]  путь из Ту в В, при условии, что это ребро удалено. Ну окей, этим пользоваться нельзя. Значит,
[01:14:08.980 --> 01:14:13.460]  все, что я могу сделать, это куда-то там, скажем, спуститься вниз и использовать обратные ребра. Но
[01:14:13.460 --> 01:14:18.980]  все, что у меня здесь есть, из вот этого предположения, обратные ребра меня по-прежнему
[01:14:18.980 --> 01:14:22.580]  оставляют в этом поддереве. Значит, я отсюда никогда не выберусь. Здесь нет никаких других
[01:14:22.580 --> 01:14:28.580]  ребер, я отсюда никак не выберусь, в В точно не попаду. Поэтому, значит, при таком условии у меня
[01:14:28.580 --> 01:14:57.260]  это точно мост. Теперь обратно. Ну пусть не так, пусть перед Ту меньше, чем 3 на Ту. Ну,
[01:14:57.260 --> 01:15:01.260]  понятно, что оно больше быть не может, потому что в определении у меня участвует, в частности,
[01:15:01.260 --> 01:15:07.820]  само значение ТИНа, поэтому мне раньше в другую сторону быть не может. Ну пусть оно меньше. Вот
[01:15:07.820 --> 01:15:15.380]  есть В, вот есть Ту. И я предполагаю, что откуда-то из этого поддерева я могу прыгнуть выше, чем в Ту.
[01:15:15.380 --> 01:15:21.380]  То есть, скажем, в В, например, или еще куда-то выше. Тогда понятно, что после удаления этого
[01:15:21.460 --> 01:15:36.420]  ребра у меня будет путь из Ту в В, например. Тогда, после удаления ребра в ВТУ, по-прежнему будет путь из Ту в В.
[01:15:36.420 --> 01:15:53.960]  Мне нужно сначала спуститься в ту вершину, которая дает вот то самое оптимальное обратное
[01:15:53.960 --> 01:15:59.060]  ребро, затем по нему прыгнуть. Либо я сразу в В попал, либо попал еще куда-то выше,
[01:15:59.060 --> 01:16:05.020]  но тогда нужно просто спуститься по обычным вот этим древесным ребрам до В. Значит, у меня есть путь
[01:16:05.020 --> 01:16:09.820]  из Ту в В даже после удаления этого ребра. Но если есть путь между ними, то я, получается,
[01:16:09.820 --> 01:16:14.620]  смотрите, я удалил ребро из В в Ту, но при этом путь между ними сохранился. Значит,
[01:16:14.620 --> 01:16:18.220]  никакая связанность не нарушилась. Все, что раньше использовало это ребро,
[01:16:18.220 --> 01:16:22.460]  теперь может альтернативно использовать вот этот путь из Ту в В, поэтому связанность никакая не
[01:16:22.460 --> 01:16:51.740]  нарушилась. Значит, граф по-прежнему связан, значит, е не мост. Согласны? Хорошо. Вот,
[01:16:51.740 --> 01:16:56.980]  но мы, получается, построили критерий проверки того, что что-то это мост, осталось его реализовать
[01:16:56.980 --> 01:17:18.980]  в коде. Сейчас-то быстро сделаем. Так, давайте я напишу void-dfs. Ну, начало у нас, как обычно,
[01:17:18.980 --> 01:17:30.220]  мы назначаем parent, parent от В равно P, назначаем ty на V равно timer++. И изначально скажем,
[01:17:30.220 --> 01:17:35.900]  что ret от В это то же самое, что ty на V. Потому что мы знаем, что первое значение, ну, в общем,
[01:17:35.900 --> 01:17:40.020]  чтобы посчитать ret от В, мне нужно взять вот это вот и еще потом его прорелаксировать через
[01:17:40.020 --> 01:17:46.660]  минимум какими-то другими ty-нами. Так, не забываем пометить ее посещенный, just от В равно true.
[01:17:46.660 --> 01:18:03.940]  Ну, теперь обход ребер. Во-первых, если это ребро в родителя, то мы его скипаем. Если true
[01:18:03.940 --> 01:18:14.620]  равно parent, тогда continue. Дальше, что еще бывает? Либо ребро в родителя, либо нормальное обратное
[01:18:14.620 --> 01:18:23.100]  ребро, либо нормально древесное ребро. Значит, обратное ребро это когда just от true. Да, вершина
[01:18:23.100 --> 01:18:28.540]  уже посещенная, значит, ребро обратное. Поэтому, смотрите, мне нужно в частности обновить ret. Мне
[01:18:28.540 --> 01:18:35.100]  нужно сказать, что ret от V, в частности, нужно прорелаксировать ty-нам от true. Картинка такая
[01:18:35.100 --> 01:18:40.660]  здесь. Вот есть V, есть обратное ребро в true. Значит, в частности, из вот этого поддерева я
[01:18:40.660 --> 01:18:44.460]  могу попасть как минимум сюда. Возможно, еще выше, то есть, возможно, я могу спуститься и куда-то еще
[01:18:44.460 --> 01:18:49.300]  прыгнуть. Но в частности, вот это ребро точно есть. Поэтому в этом случае нужно написать следующее.
[01:18:49.300 --> 01:19:03.060]  ret от V равно минимум из того, что там уже и так лежало, и ty на true. Согласны? Ну, просто вот
[01:19:03.060 --> 01:19:09.700]  это ребро используем и обновляем через ty на true. Ну и последнее, когда это все неверно, да, иначе
[01:19:09.700 --> 01:19:25.220]  мы, во-первых, запускаем dfs, tu-V, обычный dfs. Ну, еще при этом нужно ret обновить. ret от V равно
[01:19:25.220 --> 01:19:36.260]  минимум из ret от V и ret от tu. Это картинка такая. Когда мы нашли древесное ребро, вот такое,
[01:19:36.260 --> 01:19:43.180]  вот есть V, вот есть tu, тогда как высоко можно прыгнуть из этого поддерева? Ну, либо используем старую
[01:19:43.180 --> 01:19:48.220]  информацию ret от V, либо можем сначала спуститься в tu, а потом, ну, если здесь ret от tu насчитано
[01:19:48.220 --> 01:19:53.340]  корректно, то я могу, соответственно, куда-то вот сюда прыгнуть. Поэтому это нужно тоже информацию
[01:19:53.340 --> 01:20:02.740]  передать. Знаешь что, я обновляю ret от V через ret от tu. Так, ну и вот здесь мы проверяем, да, вот как
[01:20:02.740 --> 01:20:07.180]  раз применяем то утверждение, что когда мы рассматриваем древесное ребро из V в tu, то на мост,
[01:20:07.180 --> 01:20:17.860]  если только есть, выполняется какое-то равенство. Если ret от tu равно ty на tu,
[01:20:17.860 --> 01:20:29.740]  тогда нужно каким-то образом пометить вот это ребро мостом. Тогда V tu это мост. Ну, тут уже зависит
[01:20:29.740 --> 01:20:35.660]  от постановки задачи. Возможно, вам нужно просто напечатать список всех мостов, либо нужно как-то
[01:20:35.660 --> 01:20:42.060]  там пометить его мостиком, да, то есть, скажем, завести какой-нибудь struct edge, который храни там
[01:20:42.060 --> 01:20:46.900]  откуда-куда это ребро, номер ребра, и булевский флаг является ли это ребро мостом. Тогда нужно
[01:20:46.900 --> 01:20:52.540]  просто у этого ребра поставить метку, что оно мост, ну и потом делать с этим то, что хочет ваш алгоритм.
[01:20:52.540 --> 01:21:05.820]  Все, пометили мостом, завершились. Вот и все. Так, ну тут, наверное, для приличия надо доказать
[01:21:05.820 --> 01:21:26.500]  корректность. Наверное, словами обойдусь. Ну, я хочу доказать следующее, что к моменту времени,
[01:21:26.500 --> 01:21:32.460]  когда V обработано, то есть, к моменту времени, когда у меня, когда я выхожу DFS из вышинки V,
[01:21:32.460 --> 01:21:42.180]  у меня, в частности, корректно подчислены ред от V. К моменту выхода из вершины V
[01:21:42.180 --> 01:22:01.780]  корректно насчитано значение ред от V. Вот, ну если это так, тогда, смотрите, когда я вот здесь
[01:22:01.780 --> 01:22:08.460]  опускаю DFS от 2 с родителем V, тогда я могу предполагать, ну там, по индукции, что когда вот тот
[01:22:08.460 --> 01:22:14.460]  DFS закончился, у меня, в частности, корректно посчитано ред от 2. Значит, зная вот это, я хочу
[01:22:14.460 --> 01:22:18.860]  проверить, что у меня корректно насчитывается ред от V. Ну давайте посмотрим. Вот есть V, вот есть его
[01:22:18.860 --> 01:22:26.620]  под дерево, есть его дети. Все, в общем, древесные ребра из V. Значит, я знаю, что рекурсивно запущусь
[01:22:26.620 --> 01:22:33.420]  от этого сына, от этого сына и от этого сына. Я там правильно насчитал реты по индукции, правильно
[01:22:33.420 --> 01:22:37.900]  насчитал в них реты. То есть, что это значит? Я насчитал ред вот здесь, ред вот здесь и ред вот здесь.
[01:22:37.900 --> 01:22:44.540]  Тогда как выглядит ред от V? Это значит, мне нужно либо сразу взять обратное ребро из V, либо спуститься
[01:22:44.540 --> 01:22:49.140]  хотя бы в одного из сыновей и там взять ред. Ну то есть, спуститься куда-то в под дерево и из него
[01:22:49.140 --> 01:22:53.660]  прыгнуть. Ну это то же самое, что просто в одного из детей спуститься и взять в нем минимально
[01:22:53.660 --> 01:22:59.340]  возможный ред. Все, а как раз ровно так я и обновляю. По всем детям я беру минимум из того,
[01:22:59.340 --> 01:23:06.100]  что там лежало и ред от ребенка. А также я не забываю, что все вот эти вот ребра обратные,
[01:23:06.100 --> 01:23:10.620]  вот это сразу из V обратные ребра, я их тоже учитываю. Что ребра, сразу прыгающие из V куда-то
[01:23:10.620 --> 01:23:17.100]  наверх, я тоже их учитываю. Поэтому вот это утверждение доказывается просто индукцией по нашему
[01:23:17.100 --> 01:23:21.340]  дереву, вот так снизу вверх. То есть, если для этих вышин все правильно посчитано, то для V тоже по
[01:23:21.340 --> 01:23:31.100]  индукции правильно считано. Окей? Ну тогда, наверное, все. За пару минут мы не успеем
[01:23:31.100 --> 01:23:35.220]  следующую мысль сказать. Да, на этом заканчиваем. Спасибо, всем успехов.
