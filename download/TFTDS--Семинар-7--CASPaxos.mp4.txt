[00:00.000 --> 00:10.000]  Я с вами хотел сегодня договорить последний раз про сингл и грипп аксус.
[00:10.000 --> 00:18.000]  И кое-что, скажем так, неожиданное про него рассказать, если это еще возможно.
[00:18.000 --> 00:20.000]  Но мне кажется, что возможно.
[00:20.000 --> 00:26.000]  А для начала, чтобы перейти к основному содержанию, нам нужно вспомнить про домашку
[00:26.000 --> 00:30.000]  и подумать, со всеми мы из нее справились.
[00:30.000 --> 00:36.000]  Нет ли у нас вопросов, как стоило ее написать?
[00:36.000 --> 00:40.000]  Нет, если ты еще не написал, то нужно выйти.
[00:40.000 --> 00:46.000]  Но вообще дедлайн уже прошел.
[00:46.000 --> 00:50.000]  Тех, кто написал, есть ли вопросы?
[00:50.000 --> 00:54.000]  У меня есть вопрос по поводу отзрания ролей Алисы.
[00:54.000 --> 00:58.000]  Попробуй мне рассказать.
[00:58.000 --> 01:02.000]  Да, очень легко. Представь, что ты мультипаксис.
[01:02.000 --> 01:06.000]  То есть ты реплика в мультипаксисе.
[01:06.000 --> 01:12.000]  Тебе приходят препэры и аксепты, ты на них реагируешь, отвечаешь и ничего не понимаешь.
[01:12.000 --> 01:18.000]  Но твоя задача – понимать, что какая-то команда закомитилась.
[01:18.000 --> 01:22.000]  Сам по себе ты ничего не понимаешь, ты просто голоса отдаешь, особенно если ты не лидер.
[01:22.000 --> 01:26.000]  Лидер тебе может что-то сообщать, но это нужно делать аккуратно.
[01:26.000 --> 01:30.000]  Во-первых, во-вторых, он может перезагрузиться и все потерять.
[01:30.000 --> 01:34.000]  В общем, это роли для того, чтобы ты, помимо того, чтобы голосовал и предлагал команды,
[01:34.000 --> 01:38.000]  еще узнавал о том, что некоторые команды выбраны, для того, чтобы их применять к себе.
[01:38.000 --> 01:54.000]  Для одного паксиса это оптимизация, которая позволяет тебе быстрее узнавать о выбранном значении, если оно уже было выбрано.
[01:54.000 --> 02:00.000]  Ну или узнавать вообще о том, что оно выбрано, для того, чтобы ты применял к себе реплицированный лог.
[02:00.000 --> 02:07.000]  Что мне важно в этой задачи, в том, чтобы вы разобрались, как работать правильно с ретраями.
[02:11.000 --> 02:15.000]  Ну скажем, если вы использовали комбинатор Quorum, который был раньше, то вы написали точно плохой код.
[02:15.000 --> 02:20.000]  То есть можно не сомневаться, но вроде бы это в условии намекания на то, что так не стоит делать.
[02:20.000 --> 02:27.000]  Вы, наверное, написали свой комбинатор, но свой комбинатор можно немного по-разному писать.
[02:27.000 --> 02:35.000]  Вот чем acceptor в паксисе отличается от реплики в прошлой Домашке?
[02:35.000 --> 02:41.000]  Тем, что в прошлой Домашке реплика отвечала всегда, да, я сделал запись, даже если она пригнанировала ее.
[02:41.000 --> 02:44.000]  То есть она всегда выполняла команду успешно.
[02:44.000 --> 02:49.000]  Но либо она вообще не отвечала, если не рвалась, потому что машина перезагрузилась или умерла.
[02:49.000 --> 02:55.000]  Вот здесь добавляется третий ответ, и третий ответ должен как-то явно быть представлен.
[02:55.000 --> 03:03.000]  То есть она либо согласна с вами, либо отвечает ack, либо отвечает not ack, либо отвечает дисконнектом, скажем.
[03:03.000 --> 03:07.000]  Ну либо не отвечает очень долго, потому что partition, но рано или поздно вы дождетесь чего-нибудь,
[03:07.000 --> 03:10.000]  или дисконнекта, или какого-то ответа.
[03:10.000 --> 03:13.000]  Понятно ли, почему эти три ответа должны быть равны?
[03:13.000 --> 03:19.000]  В смысле, почему мы разделяем ответ ack и ответ nak?
[03:19.000 --> 03:23.000]  Ну, совсем понятно, почему мы разделяем их на стороне проповзора,
[03:23.000 --> 03:25.000]  но почему мы разделяем их на стороне кворума?
[03:25.000 --> 03:28.000]  Какая из этого может быть польза?
[03:33.000 --> 03:37.000]  Но какую информацию вместе с наком мы посылаем по-хорошему?
[03:37.000 --> 03:42.000]  Мы посылаем некоторую нижнюю границу, ниже которой проповзул number предлагать уже не стоит.
[03:42.000 --> 03:46.000]  И, видимо, кворум, который вы пишете, он мог бы быть, ну, это какой-то специальный кворум,
[03:46.000 --> 03:54.000]  который написан специально для паксиса и который понимает, что можно собрать результаты в смысле положительные ответы,
[03:54.000 --> 03:57.000]  а если вдруг они не собрались, потому что слишком много нак,
[03:57.000 --> 04:01.000]  то вы вернете advice, от которого нужно дальше выбирать себе новый n.
[04:04.000 --> 04:07.000]  Следующее, ну, техническое с этим замечание по коду.
[04:07.000 --> 04:13.000]  Не нужно дублировать RPC-колы, то есть не нужно делать отдельную функцию для первой фазы, отдельную для второй фазы.
[04:13.000 --> 04:19.000]  Если у вас два раза собирается кворум, два раза написан коминатор кворум, два раза написаны RPC вызовы, то зачем?
[04:24.000 --> 04:25.000]  Да?
[04:28.000 --> 04:31.000]  Да вы понимаете, что зачем вы это сделали?
[04:32.000 --> 04:37.000]  Ну, короче, у меня-то в коде один написан, одна функция шаблонный написан, она просто принимает параметры фазы,
[04:37.000 --> 04:41.000]  у фазы есть request-response, у ответов какая-то общая структура,
[04:41.000 --> 04:47.000]  там всегда есть флажок да-нет, если нет, то advice, если да, то есть vote,
[04:47.000 --> 04:50.000]  не важно, vote я даже не могу использовать.
[04:52.000 --> 04:58.000]  Этой общей структуры достаточно для того, чтобы написать общий комбинатор или написать общий код, который кворум собирает.
[04:59.000 --> 05:00.000]  Код дублировать не нужно.
[05:01.000 --> 05:07.000]  Ну и содержательное замечание про retry.
[05:08.000 --> 05:10.000]  Как мы поступаем с retry здесь?
[05:11.000 --> 05:17.000]  Ну вот делать бесконечный retry, возможно, не стоит.
[05:18.000 --> 05:24.000]  Ну или по-другому, вот у вас есть три реплики, вы получили от одной да, другой нет, а третьи пока ничего не получили.
[05:25.000 --> 05:29.000]  Если вы используете at least once тимантику, то есть дожидаетесь, что каждый реплик вам ответит,
[05:29.000 --> 05:36.000]  то получается, что вы не вправе дожидаться более чем n пополам плюс одного ответа.
[05:36.000 --> 05:45.000]  Потому что если вы прям будете настойчиво ждать дольше, то получается, что вы можете зависеть, когда у вас откажет одна реплика из трех,
[05:45.000 --> 05:48.000]  это вроде бы OK, но вы в этот момент заблокируетесь.
[05:49.000 --> 05:54.000]  Поэтому вы действуете очень уныло, вы дожидаетесь n пополам плюс одного и принимаете решение.
[05:55.000 --> 06:00.000]  Но с другой стороны, это решение может быть слишком пессимистично, потому что для того, чтобы собрать кворум из ack'ов
[06:00.000 --> 06:07.000]  и при этом не ждать больше majority ответа, то получается, что один n и все, и вы отказываетесь от выбора.
[06:08.000 --> 06:10.000]  В смысле вы ретраитесь с новым n.
[06:11.000 --> 06:19.000]  Возможно, можно делать эффективнее, и даже если вы получили один n, то пока их не слишком много, все-таки можно ждать дальше.
[06:20.000 --> 06:24.000]  Но важно, что вы не нужно просто ждать бесконечно.
[06:25.000 --> 06:27.000]  И так вы приходите к тому, что нужно ограничивать число ретраев.
[06:27.000 --> 06:33.000]  И к этому можно прийти с другой стороны, потому что у вас ретраи на отдельном RPC вызове есть по дефолту.
[06:34.000 --> 06:37.000]  Ну, точнее не по дефолту, не помню, что по дефолту.
[06:38.000 --> 06:41.000]  По дефолту есть, да? Нужно дефолт изменить.
[06:42.000 --> 06:47.000]  Вот у вас по дефолту есть ретраи в отдельном RPC вызове, и у вас есть ретраи на уровне алгоритма.
[06:48.000 --> 06:52.000]  Вот в этот момент нужно задуматься, что класть ретраи в ретраи это, возможно, не самая разумная идея.
[06:52.000 --> 06:58.000]  И что нужно как-то эти ретраи понять, на каком уровне их лучше разумно делать.
[06:59.000 --> 07:04.000]  И так вы приходите к тому, что вам не нужно использовать at least once для отдельных RPC вызовов.
[07:05.000 --> 07:08.000]  Вы можете сделать какое-то ограниченное число ретраев, или вы можете сделать...
[07:09.000 --> 07:12.000]  Ну, там есть флажок at most once, то есть вы делаете просто одну попытку.
[07:13.000 --> 07:17.000]  То есть канал с ретраями, который вы написали, он вообще не используется, вы проходите сквозь него.
[07:17.000 --> 07:20.000]  Вот, ну вот так получается вроде бы какой-то разумный небольшой код.
[07:23.000 --> 07:27.000]  Это, в общем-то, единственные сложности, у которых эти задачи были, нужно было на них не напороться.
[07:28.000 --> 07:34.000]  Ну вот at least once – это то, что нам потребуется дальше и в мультипаксосе,
[07:35.000 --> 07:39.000]  но потому что этот код у нас следуется почти без изменений, и, конечно, в рафте, потому что там...
[07:40.000 --> 07:43.000]  Ну, про него еще рано. Там тоже есть такой код.
[07:43.000 --> 07:45.000]  Ну вот, мы решаем задачу консенсуса.
[07:46.000 --> 07:49.000]  И кажется, что сама по себе задача консенсуса бесполезна.
[07:51.000 --> 07:53.000]  Ну, по крайней мере, в таком вот изолированном состоянии.
[07:54.000 --> 07:56.000]  Вот я сегодня покажу, мне кажется, забавную штуку.
[07:57.000 --> 07:59.000]  Вроде бы в продакшене не используют, хотя могли бы.
[08:00.000 --> 08:02.000]  Но эта вещь у нас совершенно удивительная для понимания,
[08:03.000 --> 08:08.000]  потому что, в общем-то, в рафте, в рафте, в рафте, в рафте, в рафте, в рафте, в рафте.
[08:08.000 --> 08:10.000]  В продакшене не используют, хотя могли бы.
[08:11.000 --> 08:13.000]  Но эта вещь у нас совершенно удивительная для понимания.
[08:14.000 --> 08:16.000]  То есть алгоритм паксос, он не так прост, как выглядит.
[08:17.000 --> 08:23.000]  Ну, он не то, что выглядит простым, но он еще хитрее, чем нам кажется сейчас.
[08:24.000 --> 08:26.000]  Для этого нужно некоторое вступление.
[08:27.000 --> 08:28.000]  И вступление – это будет...
[08:29.000 --> 08:31.000]  А мне видно на доске сейчас или нет?
[08:34.000 --> 08:36.000]  Видно, но, возможно, не очень ярко.
[08:39.000 --> 08:40.000]  Вот, так лучше.
[08:44.000 --> 08:46.000]  Совсем недавно, в 2021 году вышла статья,
[08:47.000 --> 08:48.000]  которая называется «Виртуальный консенсус Делос».
[08:49.000 --> 08:52.000]  Ее написали снова в Facebook, но мы сегодня смотрели на файловую систему.
[08:53.000 --> 08:57.000]  Это статья про то, как они строили свою систему Делос,
[08:58.000 --> 09:02.000]  а это сервис-координация, то есть это их альтернатива ЧАБи.
[09:03.000 --> 09:07.000]  Но они написали не в 2021 году, конечно, написали несколько годами раньше,
[09:08.000 --> 09:10.000]  статью фабриковали сейчас.
[09:11.000 --> 09:15.000]  Вот про сам Делос есть, ну, запись у них в техническом блоге.
[09:17.000 --> 09:18.000]  И о чем они пишут?
[09:19.000 --> 09:21.000]  Ну, вот Делос – это там, не знаю, какая-то таблица,
[09:22.000 --> 09:23.000]  с помощью которой можно делать координацию.
[09:24.000 --> 09:27.000]  В общем, для того же самого, для чего нужен ЧАБи, для чего нужен Зукипер,
[09:28.000 --> 09:30.000]  а про Зукипер мы в другом курсе еще поговорим в любом случае.
[09:31.000 --> 09:35.000]  Но статья не про сам Делос, а про то, как они реплицируют данные там.
[09:35.000 --> 09:40.000]  Они делают РСМ, но вводят там дополнительную абстракцию.
[09:41.000 --> 09:43.000]  То есть мало абстракции, они, известно, любую проблему
[09:44.000 --> 09:45.000]  можно решить еще одним слоем.
[09:46.000 --> 09:47.000]  Вот они добавляют его, делают виртуальный консенсус.
[09:48.000 --> 09:49.000]  Они делают виртуальный лог.
[09:50.000 --> 09:51.000]  Не то, чтобы они пишут поверх рафта или поверх мультипакса
[09:52.000 --> 09:55.000]  со своей репликацией, они пишут поверх вот некоторого абстрактного лога.
[09:57.000 --> 10:00.000]  И вот этот дополнительный уровень косвенности,
[10:00.000 --> 10:04.000]  дополнительная абстракция, она удивительным образом помогает им
[10:05.000 --> 10:07.000]  получить решение еще проще, но и лучше почувствовать,
[10:08.000 --> 10:10.000]  где консенсус нужен, а где консенсус не нужен.
[10:11.000 --> 10:15.000]  Вот у них есть база данных, это какие-то реплики с РСМ.
[10:16.000 --> 10:17.000]  Реплики РСМ.
[10:18.000 --> 10:24.000]  И они работают поверх виртуального лога, в котором откуда-то берутся
[10:24.000 --> 10:25.000]  закромиченные записи.
[10:26.000 --> 10:27.000]  Сейчас мы найдем интерфейс.
[10:29.000 --> 10:30.000]  Вот виртуальный лог.
[10:31.000 --> 10:33.000]  В него можно добавлять, из него можно читать
[10:34.000 --> 10:38.000]  и можно отрезать префикс, когда он уже не нужен.
[10:39.000 --> 10:41.000]  Тут есть еще какие-то операции.
[10:42.000 --> 10:43.000]  Почему-то тут два интерфейса, не один.
[10:44.000 --> 10:45.000]  Вот этому как раз статья и посвящена.
[10:50.000 --> 10:51.000]  Ну вот есть же рафт с другой стороны.
[10:51.000 --> 10:52.000]  Вот авторы говорят, что рафт...
[10:53.000 --> 10:54.000]  Где они говорят про рафт?
[10:59.000 --> 11:05.000]  Что рафт смешивает два уровня, два измерения.
[11:06.000 --> 11:11.000]  В распределенных системах часто уделяют вот такие плоскости
[11:12.000 --> 11:13.000]  control plane и data plane.
[11:14.000 --> 11:18.000]  То есть у вас есть некоторая система, ну и там как бы много всего в ней происходит.
[11:18.000 --> 11:23.000]  Там, не знаю, какие-то переконфигурации, вы меняете состав машины, вы пишете данные, читаете данные.
[11:24.000 --> 11:27.000]  Так вот, вот есть пользователь и есть его write pass и read pass.
[11:28.000 --> 11:31.000]  То есть путь, который он проходит в системе для того, чтобы сделать запись или сделать чтение.
[11:32.000 --> 11:36.000]  И вот компонента, которую он задевает, называется data plane.
[11:37.000 --> 11:38.000]  А есть control plane.
[11:39.000 --> 11:41.000]  Это слой, который нужен для того, чтобы система функционировала.
[11:42.000 --> 11:45.000]  Это слой, который, не знаю, управляет всеми остальными узлами в ней.
[11:45.000 --> 11:49.000]  Но при этом через него проходить на быстром пути не нужно.
[11:50.000 --> 11:58.000]  И вот они говорят, авторы статьи, что в algorithm.raft все вместе, и переконфигурации, и репликация, все в один протокол замешано.
[11:59.000 --> 12:03.000]  Вот мы сейчас выделим две абстракции, которые помогают эти слои разделить.
[12:04.000 --> 12:05.000]  Control plane и data plane.
[12:06.000 --> 12:08.000]  И реализовать их по-разному.
[12:11.000 --> 12:12.000]  Вот они выделяют две абстракции.
[12:12.000 --> 12:13.000]  Вот они выделяют две абстракции.
[12:14.000 --> 12:18.000]  Собственно, виртуальный лог, с которым работают реплики RSM, и выделяют loglet.
[12:19.000 --> 12:21.000]  Это компонентный кусочек лога.
[12:23.000 --> 12:27.000]  Вот чем такая декомпозиция оказывается полезной?
[12:28.000 --> 12:38.000]  Помните, что когда я говорил вам про multipaxos, в конце лекции я вам говорил, что на самом деле algorithm.paxos не про то, чтобы выбирать очередную команду в логе.
[12:38.000 --> 12:42.000]  Он про то, чтобы решать проблему конкуренции лидеров.
[12:43.000 --> 12:48.000]  Когда у вас лидер один, то он просто назначает команды, пишет их в лог, но как бы нему никто не мешает, ordering делает он.
[12:49.000 --> 12:52.000]  Вот для того, чтобы команды упорядочивать, консенсус не нужен.
[12:53.000 --> 12:57.000]  Консенсус нужен тогда, когда у вас появляется новый лидер, а старого нужно заблокировать.
[12:58.000 --> 13:00.000]  Вот только вот в период смены эпохи.
[13:02.000 --> 13:06.000]  А Facebook идут в эту сторону и разделяют обязанности.
[13:06.000 --> 13:12.000]  Вот у них есть логлит, который занимается только тем, что упорядочивает команды.
[13:13.000 --> 13:18.000]  В него можно сделать append, из него можно читать, ну и его можно запечатать.
[13:20.000 --> 13:27.000]  Вот операция запечатывания, это такое, мы один раз запечатываем и все, и в этом месте логлит заканчивается.
[13:28.000 --> 13:37.000]  А виртуальный лог выстраивается из логлитов, то есть он умеет их склеивать в одну бесконечную цепочку.
[13:38.000 --> 13:39.000]  Зачем это нужно?
[13:40.000 --> 13:44.000]  Вот оказывается, что в такой декомпозиции, немного искусственной по началу,
[13:45.000 --> 13:51.000]  можно сделать так, чтобы логлит, вот этот кусочек лога, был реализован вообще без консенсуса.
[13:51.000 --> 13:58.000]  Тут можно сделать репликацию, где у вас есть один лидер, два фоллвера, и он получает все команды, пишет на них.
[13:59.000 --> 14:05.000]  И если вдруг лидер умирает, то все. Думать про перевыборы не нужно, думать про консенсус не нужно.
[14:06.000 --> 14:12.000]  Вот можно строить такие очень простые компоненты, причем, ну это уже такая инженерная задача, на нас меньше степь не касается.
[14:13.000 --> 14:17.000]  Можно реализацию этих логлитов менять. Можно сделать одну реализацию, потом другую.
[14:18.000 --> 14:22.000]  Ну и скажем, вот представьте, что вы пишете мультипаксис, и у вас там есть какие-то метапараметры,
[14:23.000 --> 14:26.000]  типа альфа для переконфигурации, то есть в каком окне действует переконфигурация.
[14:27.000 --> 14:30.000]  Вот некоторые такие большие параметры в алгоритме сложно на ходу менять.
[14:31.000 --> 14:36.000]  Вот вы можете разделить их на такие логлиты и в каждом наборе использовать свои параметры.
[14:37.000 --> 14:38.000]  Ну или вообще разную реализацию.
[14:39.000 --> 14:42.000]  И скажем, если вы логлит закрыли, то есть кусочек лога зафиксировали,
[14:42.000 --> 14:46.000]  то вы можете вообще избавиться от лога и поместить его на какое-то другое хранилище,
[14:47.000 --> 14:53.000]  на какой-то холодный storage, который очень эффективно жмет данные и не умеет их особенно быстро читать.
[14:54.000 --> 14:57.000]  Так вот, вы можете построить логлит, в котором консенсуса вообще не будет,
[14:58.000 --> 15:02.000]  а будет просто primary backup, то есть лидер, который принимает команды, реплицирует на всех.
[15:03.000 --> 15:08.000]  И все, что нужно уметь, нужно сказать лидеру, что перестань, просто как бы остановись.
[15:08.000 --> 15:13.000]  Вот это не совсем тривиальная задача, то есть это примерно страница текста посвящена как это сделать,
[15:14.000 --> 15:18.000]  но все же задача решаемая, и консенсус еще раз не нужен.
[15:19.000 --> 15:21.000]  А вот на верхнем уровне нужен консенсус, вот здесь вот,
[15:22.000 --> 15:26.000]  потому что здесь нужно переконфигурировать систему, переключаться с одной реализацией на другую.
[15:27.000 --> 15:30.000]  Так вот, к чему я все это рассказываю?
[15:31.000 --> 15:35.000]  К тому, что здесь консенсуса вообще нет для репликации лога,
[15:35.000 --> 15:41.000]  а вот этот уровень, который строит из кусочков одну непрерывную цепочку команд,
[15:42.000 --> 15:44.000]  он называется у них Metastore.
[15:45.000 --> 15:47.000]  Но это не совсем тот Metastore.
[15:48.000 --> 15:50.000]  Там используется Multipaxs.
[15:51.000 --> 15:53.000]  Сейчас я найду.
[15:54.000 --> 15:57.000]  Metastore использует протокол уже консенсуса Multipaxs.
[15:58.000 --> 16:00.000]  Так вот, этот Metastore – это control plane.
[16:00.000 --> 16:02.000]  Там редко что-то происходит.
[16:03.000 --> 16:06.000]  Там работы происходят тогда, когда система переходит из одного логлята в другой.
[16:09.000 --> 16:11.000]  Сейчас я найду, где они это пишут именно.
[16:12.000 --> 16:14.000]  Смотрите, что они пишут.
[16:19.000 --> 16:21.000]  Я не знаю, стало ли лучше видно или хуже.
[16:22.000 --> 16:26.000]  Ну вот, чтобы сделать этот верхний слой Metastore, мы взяли
[16:26.000 --> 16:31.000]  и сделали реплицированный автомат с помощью оригинальной статьи про Paxos.
[16:34.000 --> 16:37.000]  Я сейчас не помню, они ссылаются на греков.
[16:38.000 --> 16:40.000]  Наверное, ссылаются на большую статью.
[16:45.000 --> 16:46.000]  Так, мы откатываемся.
[16:47.000 --> 16:49.000]  Но они пишут, что они взяли и реализовали самый тупой протокол.
[16:50.000 --> 16:55.000]  То есть, у них каждый слот – это тупой single-slot Paxos без оптимизации
[16:56.000 --> 17:00.000]  без каких-то лидеров, с конкуренцией пропозеров.
[17:01.000 --> 17:04.000]  То есть, самый базовый вариант, который мы построили примерно через 15 минут после начала.
[17:05.000 --> 17:07.000]  И это единственный консенсус в их системе.
[17:08.000 --> 17:13.000]  То есть, они как бы строят RSM, но они не используют никаких оптимизаций вот на этом уровне,
[17:14.000 --> 17:15.000]  на уровне протокола консенсуса.
[17:16.000 --> 17:24.000]  Просто немного выделив дополнительный слой абстракции, они умеют упростить
[17:24.000 --> 17:29.000]  сделать две задачи вместо одной, и каждую задачу решать проще, чем одну большую.
[17:32.000 --> 17:34.000]  Так вот, и зачем им нужен Multipaxos?
[17:36.000 --> 17:42.000]  Им Multipaxos нужен для того, чтобы сделать вот такую штуку, по сути.
[17:43.000 --> 17:51.000]  Metastore – у них это версионируемый регистр, у которого есть операция условной записи.
[17:51.000 --> 17:54.000]  То есть, мы пишем в него, если он равен чему-то.
[17:55.000 --> 17:57.000]  Короче говоря, нам нужна ячейка памяти с операцией CAS.
[17:58.000 --> 18:02.000]  И вот мы с ней работают редко, потому что эта ячейка хранит текущий логрит.
[18:04.000 --> 18:09.000]  Она не должна быть устроена супер-эффективно, и вот только для нее нужен консенсус во всей этой системе.
[18:10.000 --> 18:16.000]  Так вот, я сейчас покажу, что имея не то чтобы лог из single degree Paxos,
[18:16.000 --> 18:21.000]  что само по себе уже довольно просто, а имея просто один single degree Paxos, можно сделать такую ячейку.
[18:25.000 --> 18:29.000]  То есть, одного single degree Paxos достаточно для того, чтобы построить распределенную систему.
[18:30.000 --> 18:34.000]  Ну и давайте мы сейчас это сделаем довольно быстро.
[18:36.000 --> 18:40.000]  Но это, мне кажется, совершенно удивительно, что так можно.
[18:41.000 --> 18:44.000]  Итак, мы с вами все знаем, как устроен Paxos, конечно.
[18:44.000 --> 18:49.000]  Мы знаем, что там пропозеры выбирают себе bellot number, проходят через первую фазу, через вторую фазу.
[18:50.000 --> 18:54.000]  Мне сейчас это все не очень важно. Мне важно, как...
[18:57.000 --> 18:59.000]  Где-то красный маркинг был.
[19:02.000 --> 19:05.000]  Как работает фаза prepare, как она взаимодействует с accept.
[19:07.000 --> 19:12.000]  Давайте я сейчас буду странные вещи какие-то делать, но потом я объясню, что это все значит.
[19:12.000 --> 19:14.000]  Я объясню, что это все значит, но точнее мы сами поймем.
[19:15.000 --> 19:20.000]  Вот берем Paxos, там, я знаю, три пропозера, три accept, они запускаются, что-то там выбирают.
[19:21.000 --> 19:26.000]  Вот в этом исполнении появляются какие-то proposal numbers, вот n, которые мы выбираем.
[19:27.000 --> 19:29.000]  Давайте из них сделаем граф.
[19:34.000 --> 19:38.000]  Ориентированный граф, в котором n будут соединяться друг с другом.
[19:39.000 --> 19:42.000]  Вот каким образом, естественно, можно связать разные n?
[19:43.000 --> 19:45.000]  Как я буду строить этот граф?
[19:46.000 --> 19:48.000]  Тут не то чтобы много способов это выдумать.
[19:49.000 --> 19:53.000]  Я понимаю, что пока смыслов происходящего нет, но интрига какая-то должна быть.
[19:54.000 --> 19:58.000]  Вот как бы вы построили из n направленный граф?
[19:59.000 --> 20:01.000]  Какие бы вы n соединили?
[20:05.000 --> 20:07.000]  Что значит один поменялся на другой?
[20:08.000 --> 20:12.000]  Было n1 и значение было n1, а теперь стало n1, значит...
[20:13.000 --> 20:15.000]  Где стало?
[20:17.000 --> 20:21.000]  Сейчас я хочу сделать вершинами графа n, у тебя здесь много accept'ров.
[20:22.000 --> 20:26.000]  У тебя будут такие параллельные графы, альтернативные, или что?
[20:29.000 --> 20:35.000]  n было number, он глобальный, он рождается в алгоритме, он есть один, ну и есть другие.
[20:35.000 --> 20:39.000]  Вот я хочу как-то их связать. Как они алгоритмологически связываются, эти n?
[20:43.000 --> 20:45.000]  Давайте я пример нарисую.
[20:46.000 --> 20:50.000]  Помните, у нас был на лекции про паксис контур пример, что нельзя считать значение выбранным, когда оно лежит на большинстве.
[20:51.000 --> 20:58.000]  И мы там брали три accept'ра и рисовали такую картинку.
[20:59.000 --> 21:04.000]  У нас был сначала первый пропозер, у него был n1, пропозер n1.
[21:05.000 --> 21:07.000]  Он говорил prepar на первых двух репликах.
[21:08.000 --> 21:10.000]  Потом говорил здесь a1x.
[21:11.000 --> 21:16.000]  Потом его перебивали, говорили здесь p2p2.
[21:17.000 --> 21:19.000]  Говорили здесь a2y.
[21:20.000 --> 21:23.000]  Этот 1x сломался, и здесь, и здесь.
[21:24.000 --> 21:26.000]  Потом появлялся кто-то третий.
[21:29.000 --> 21:31.000]  p3, p3.
[21:31.000 --> 21:36.000]  Здесь мы выбирали x, здесь мы выбирали ничего.
[21:37.000 --> 21:41.000]  И говорили accept 3x.
[21:43.000 --> 21:45.000]  Ну вот какое-то исполнение.
[21:46.000 --> 21:50.000]  Вот у меня здесь три разных n, 1, 2 и 3.
[21:52.000 --> 21:55.000]  Ну есть некоторое нулевое n у каждого accept'ра с самого начала.
[21:56.000 --> 21:59.000]  Вот я хочу на них какую-то картинку, какой-то граф нарисовать.
[21:59.000 --> 22:01.000]  Как мне это сделать?
[22:06.000 --> 22:07.000]  Что?
[22:09.000 --> 22:12.000]  Мне кажется, паксос не нужен для того, чтобы такую картинку нарисовать.
[22:19.000 --> 22:22.000]  Вы написали паксос, но так и не поняли, да, его?
[22:26.000 --> 22:27.000]  Что?
[22:30.000 --> 22:33.000]  Ну вот, у нас была фаза prepare на зеленом пропозере.
[22:34.000 --> 22:36.000]  Мы собрали quorum.
[22:37.000 --> 22:40.000]  Нам каждый accept'р ответил каким-то своим локальным голосом и промессом.
[22:41.000 --> 22:46.000]  И вот этот сказал accept'р, что у него есть голос за 1x, у этого есть голос за...
[22:47.000 --> 22:49.000]  Ну ни за кого пока.
[22:50.000 --> 22:52.000]  С нулевым n, пустой голос.
[22:53.000 --> 22:56.000]  И мы посмотрели на эти голоса, и раз кто-то за что-то уже проголосовал,
[22:56.000 --> 23:04.000]  мы выбрали под своим ballot number 3 значение с максимальным nx, которое мы получали в ответ.
[23:05.000 --> 23:07.000]  Значение с единицей.
[23:08.000 --> 23:09.000]  Да?
[23:11.000 --> 23:12.000]  Ну, собственно, так...
[23:13.000 --> 23:15.000]  А, ты же не замеришь. Прости.
[23:16.000 --> 23:19.000]  То есть мы из этого голоса взяли себе значение.
[23:20.000 --> 23:23.000]  Но почему мы взяли это значение? Потому что здесь был максимальный nx.
[23:24.000 --> 23:28.000]  Ну вот давайте я скажу, что у меня вот здесь 3 связалось с единицей.
[23:29.000 --> 23:33.000]  Из пропозула 1, пропозул 3 получает свое значение.
[23:34.000 --> 23:35.000]  Да?
[23:36.000 --> 23:43.000]  Вот, в итоге у меня был 0, был 1, и он получал свое значение сам, то есть он был связан с 0.
[23:44.000 --> 23:45.000]  Цеплялся к 0.
[23:46.000 --> 23:48.000]  У меня был 2, который тоже цеплялся к 0.
[23:53.000 --> 23:59.000]  И у меня была тройка, которая цеплялась к чему, к единице, да?
[24:06.000 --> 24:07.000]  Понятная конструкция?
[24:08.000 --> 24:11.000]  Вот, ну дальше эта картинка может дополняться, потому что что?
[24:12.000 --> 24:16.000]  Потому что появляется четвертый пропозор, и он приходит куда?
[24:18.000 --> 24:20.000]  Ну, тут разные варианты есть.
[24:20.000 --> 24:22.000]  Он может прийти
[24:25.000 --> 24:28.000]  P4, P4, и тогда что получится?
[24:29.000 --> 24:30.000]  Тогда он прицепится к этой двойке, да?
[24:31.000 --> 24:33.000]  Потому что она максимальная.
[24:34.000 --> 24:38.000]  Тогда я нарисую здесь вот, ну так, виртуально эту четверку.
[24:41.000 --> 24:45.000]  А может быть я приду сюда и сюда четвертым пропозором?
[24:46.000 --> 24:48.000]  И тогда я прицеплюсь, видимо, к тройке.
[24:48.000 --> 24:49.000]  Прицеплюсь, видимо, к тройке.
[24:50.000 --> 24:51.000]  И тогда я нарисовал бы ее здесь.
[24:55.000 --> 24:58.000]  Ну вот, живет в себе такой граф.
[25:00.000 --> 25:05.000]  Давайте выделим в нем некоторые вершины, некоторые n.
[25:06.000 --> 25:07.000]  Там же есть какие-то особенные n?
[25:11.000 --> 25:14.000]  Ну, пока нет особенных, пока они все просто разноцветные и одинаковые.
[25:14.000 --> 25:19.000]  Ну, скажем, если четверка придет вот сюда и...
[25:24.000 --> 25:26.000]  А нет, пусть сюда приходит.
[25:27.000 --> 25:28.000]  Сюда и сюда.
[25:29.000 --> 25:34.000]  То она выберет себе в качестве значения y, потому что двойка была больше, чем единица.
[25:35.000 --> 25:37.000]  И мы закомитим эту двойку на первого-второго аксептора.
[25:38.000 --> 25:40.000]  В смысле y закомитим.
[25:41.000 --> 25:43.000]  Хотя он лежал не на большинстве.
[25:43.000 --> 25:44.000]  Это не очень важно для нас.
[25:45.000 --> 25:47.000]  Важно, что у нас вот детерминируется выбор.
[25:48.000 --> 25:49.000]  Мы четверку приклеим вот сюда.
[25:55.000 --> 25:59.000]  Вот, давайте я четверку в кружочек обведу, потому что чем она отличается от остальных?
[26:01.000 --> 26:04.000]  Вот, этот пропозал был успешным.
[26:05.000 --> 26:07.000]  Ну, вот вообще во всем алгоритме каждый пропозал,
[26:07.000 --> 26:11.000]  каждый конкретный пропозал для конкретного n может быть успешным либо неуспешным.
[26:13.000 --> 26:18.000]  Ну вот представьте себе исполнение, и в нем есть успешные пропозалы и неуспешные пропозалы.
[26:19.000 --> 26:22.000]  И вот мы нарисовали для всего этого исполнения некоторый граф.
[26:25.000 --> 26:27.000]  Ну, давайте дорисуем еще чего-нибудь.
[26:35.000 --> 26:37.000]  Что получается? 4, да?
[26:42.000 --> 26:44.000]  А потом появляется...
[26:48.000 --> 26:50.000]  О, ерунду пишу.
[26:50.000 --> 26:52.000]  P5, P5.
[26:55.000 --> 26:57.000]  Потом приходит
[27:01.000 --> 27:03.000]  P6, P6.
[27:03.000 --> 27:05.000]  A6, Y.
[27:05.000 --> 27:08.000]  Ну, Y уже не может поменяться, он закоммичен, все, навертвое.
[27:08.000 --> 27:10.000]  По свойствам Паксиса.
[27:10.000 --> 27:12.000]  А вот пятый пропозал проиграет.
[27:20.000 --> 27:22.000]  Что получится?
[27:23.000 --> 27:24.000]  Что?
[27:26.000 --> 27:27.000]  И П вместо А, да?
[27:27.000 --> 27:29.000]  Ну, в смысле...
[27:30.000 --> 27:33.000]  А, да, да, да, да, конечно.
[27:34.000 --> 27:36.000]  Простите.
[27:41.000 --> 27:43.000]  Что получается?
[27:45.000 --> 27:47.000]  Ну, Y закоммитился, это же...
[27:48.000 --> 27:50.000]  Как огорчаешь меня.
[27:52.000 --> 27:54.000]  Получается вот такая картинка, да?
[27:59.000 --> 28:01.000]  Почему?
[28:03.000 --> 28:05.000]  Почему квадратная, да?
[28:05.000 --> 28:07.000]  Странно.
[28:11.000 --> 28:13.000]  Я правильно рисую?
[28:15.000 --> 28:17.000]  Ну, пора бы уже смысл в этом найти.
[28:17.000 --> 28:21.000]  Ну, точнее, не то, что смысл, а какую-то структуру.
[28:24.000 --> 28:27.000]  Я просто могу дальше продолжать, ну, точнее, не могу, у меня доска закончится.
[28:27.000 --> 28:29.000]  Я же к чему-то это все веду.
[28:32.000 --> 28:34.000]  Круглые прицепляются круглым, да?
[28:41.000 --> 28:43.000]  В этом графике могло бы быть иначе?
[28:44.000 --> 28:46.000]  Мне кажется, что могло.
[28:46.000 --> 28:48.000]  Вот представь, что было бы...
[28:48.000 --> 28:50.000]  Представь, что было бы вот так.
[28:57.000 --> 29:01.000]  Твоя гипотеза провалилась.
[29:01.000 --> 29:05.000]  Круглая прицепилась к некруглому.
[29:09.000 --> 29:11.000]  Ну, что же надо посмотреть.
[29:11.000 --> 29:13.000]  Вот посмотреть, так я сказал, у тебя...
[29:13.000 --> 29:15.000]  Я в крошу у меня был, я не мог бы в крошу...
[29:15.000 --> 29:17.000]  Круглая прицепилась к некруглому.
[29:17.000 --> 29:19.000]  Я не могу в крошу.
[29:19.000 --> 29:21.000]  Я не могу в крошу.
[29:21.000 --> 29:23.000]  Вот, вот это было бы не так.
[29:23.000 --> 29:25.000]  Многое было бы не так.
[29:25.000 --> 29:30.600]  так я сказал, я в кружок обвожу те пропузлы, которые были приняты на фазе accept.
[29:30.600 --> 29:49.500]  Не понял, пришел пятый, он выбрал себе Y, потому что он получил 4Y, но 5 прицепился к четырем.
[29:50.500 --> 29:58.500]  Пришел шестой, он отправил UPR на второго и на третьего, и с третьего получил голос 5Y,
[29:58.500 --> 30:05.100]  прицепился по нашему представлению к пятому, но при этом не дал пятому закомититься,
[30:05.100 --> 30:09.500]  потому что теперь у него у пятого проваливается проверка на UPR.
[30:13.500 --> 30:17.100]  Сейчас еще раз, я предлагаю конкретную конструкцию, не надо фантазировать,
[30:17.100 --> 30:28.100]  я говорю, что я соединяю такие N, если у тебя после фазы prepare для N берется значение
[30:28.100 --> 30:32.100]  из голоса N' V' какого-то более старого.
[30:33.100 --> 30:37.100]  Вот я такие пары соединяю, вот я взял здесь этот Y отсюда.
[30:38.100 --> 30:42.100]  А как так окажется, пятерка пришла?
[30:42.100 --> 30:43.100]  Что?
[30:43.100 --> 30:49.100]  Пятерка должна быть accepted, чтобы она появилась в голосе.
[30:50.100 --> 30:52.100]  Так вот, она успела сюда прийти.
[30:52.100 --> 30:58.100]  Но ее уже должно быть большинство принять, чтобы ее затеснять как последний голос.
[30:58.100 --> 31:05.100]  В смысле, вот, я зеленый accept, я пришел с ballot number 5, мне пришли...
[31:05.100 --> 31:12.100]  Я получил отсюда четверку, 4Y, собрал quorum из двух prepare'ов, пошел писать на...
[31:12.100 --> 31:17.100]  пошел писать на вторую фазу, на третьем accept успел записать, а потом меня перебили.
[31:20.100 --> 31:22.100]  Но вроде валидное исполнение.
[31:25.100 --> 31:30.100]  Но это граф распространения значения, это правда, но...
[31:30.100 --> 31:35.100]  Когда мы проходим через две фазы?
[31:42.100 --> 31:45.100]  Я посмотри, как граф строится, понятно?
[31:45.100 --> 31:48.100]  Вот можно в нем какое-то свойство обнаружить?
[31:49.100 --> 31:53.100]  Вот, все круглые вершинки находятся на одной цепи, почему так?
[31:54.100 --> 31:57.100]  Ну, это более-менее рассуждение про корректность.
[31:57.100 --> 32:06.100]  Вот у нас есть некоторая N, и... сейчас вот возьмем N и N'.
[32:06.100 --> 32:14.100]  Такие, что они оба были закомичаны, то есть прошли оба через две фазы.
[32:14.100 --> 32:21.100]  Вот мы хотим показать, что N является... ну, и N меньше, чем N', мы хотим показать, что N является предком.
[32:21.100 --> 32:25.100]  Ну, вот посмотрим на N', что с ним было.
[32:25.100 --> 32:29.100]  Да, в этом графе, разумеется, только те N', которые прошли через первую фазу, потому что иначе они не могут...
[32:29.100 --> 32:31.100]  Ну, непонятно вообще, к чему они цепляются.
[32:32.100 --> 32:37.100]  Ну вот, посмотрим на N'3', который прошел через вторую фазу.
[32:37.100 --> 32:42.100]  Видимо, он записал что-то через accept на quorum.
[32:42.100 --> 32:56.100]  Вот, но этот N, он... сейчас...
[32:56.100 --> 33:01.100]  Нет, я хочу сказать, что N' прошел через prepare.
[33:05.100 --> 33:09.100]  Перезапутался.
[33:10.100 --> 33:17.100]  А N прошел через accept, наверное так.
[33:17.100 --> 33:29.100]  Вот, ну и в пересечении есть узел, и мы через этот prepare для N' связались с каким-то меньшим нас N, правда?
[33:29.100 --> 33:39.100]  Вот мы получили... мы хотим понять, к чему цепляется этот N' в графе.
[33:39.100 --> 33:45.100]  Он цепляется к максимальному N', который N' получил от фазы prepare.
[33:45.100 --> 33:48.100]  Это максимальная N', оно какое может быть?
[33:48.100 --> 33:54.100]  Но оно не меньше N, потому что вот на этой реплике лежит N' по крайней мере N.
[33:54.100 --> 34:00.100]  Потому что и N и N' были chosen.
[34:00.100 --> 34:06.100]  Так что у N' есть предок, и он не меньше N.
[34:06.100 --> 34:10.100]  Ну он бы меньше N' уж точно, и он не меньше N.
[34:10.100 --> 34:15.100]  Ну вот, повторим рассуждение для вот этого предка.
[34:15.100 --> 34:21.100]  Вот кажется, что мы всегда будем спускаться вниз по N, но при этом никогда не выйдем,
[34:21.100 --> 34:27.100]  то есть никогда не станем меньше, чем... мы будем спускаться по proposal number, но никогда не станем меньше, чем N.
[34:27.100 --> 34:34.100]  Но явно это делать бесконечно нельзя, поэтому рано или поздно мы в N должны прийти.
[34:34.100 --> 34:42.100]  Так что вот эти вершинки лежат на одной цепи, но что из этого можно дальше извлечь?
[34:42.100 --> 34:48.100]  Ну или по-другому. Вот есть одна ветка, и вот есть другая ветка.
[34:48.100 --> 34:53.100]  И вот эта ветка, как будто кружочков уже нет, кружочки все здесь.
[34:53.100 --> 34:58.100]  Что значит кружочки, мы понимаем, это успешные пропозалы.
[34:58.100 --> 35:02.100]  А что значит стрелочка? Ну вот в смысле алгоритма.
[35:02.100 --> 35:07.100]  Как в вашем коде реализована стрелочка?
[35:07.100 --> 35:24.100]  Мы взяли голос максимальным N, A, взяли оттуда V, A и выбрали его в качестве V со звездочкой здесь.
[35:24.100 --> 35:30.100]  То есть на входе было значение, на выходе было значение.
[35:30.100 --> 35:39.100]  Ну одно и то же. Вот тут была написана тождественная функция, получается, на этой стрелочке.
[35:39.100 --> 35:45.100]  Понятно ли, к чему я клоню? Ну ладно, вспомогательный вопрос.
[35:45.100 --> 35:55.100]  Понятно ли, что от этой тождественной функции, то есть от значений сам граф вообще никак не зависел?
[35:55.100 --> 36:01.100]  То есть это вообще было неважно все. Как я новые V со звездочкой выбираю, что там вообще за V,
[36:01.100 --> 36:06.100]  этот граф строится в зависимости от фаз и выбора N.
[36:06.100 --> 36:14.100]  Так что, что бы я здесь не писал на стрелках, все равно получится такой же граф.
[36:14.100 --> 36:20.100]  Ну вот и отлично. Теперь я могу это использовать для чего-то разумного.
[36:20.100 --> 36:28.100]  Что я могу здесь сделать? Что я положу на этих стрелках?
[36:28.100 --> 36:42.100]  Я положу свои операции клиентские, которые будут менять значение.
[36:42.100 --> 36:48.100]  Как устроена моя операция? Я прихожу, выбираю себе N, прохожу через фазу prepare.
[36:48.100 --> 36:52.100]  Если не прохожу, значит я ухожу обратно, моя операция проводилась.
[36:52.100 --> 36:55.100]  Ну как бы ничего плохого не сделано, кажется, ее притрайть можно.
[36:55.100 --> 36:58.100]  В смысле, выбрать новое N, это уже будет такой новый трай, новая операция.
[36:58.100 --> 37:04.100]  Ну вот, если я со своей операцией прихожу и прохожу через первую фазу,
[37:04.100 --> 37:08.100]  то вот я получил какое-то значение старое.
[37:08.100 --> 37:17.100]  Из этого VA и с максимальным NA. То есть вот я здесь получил какое-то старое значение.
[37:17.100 --> 37:21.100]  Вот я пятая операция, я получил значение Y.
[37:21.100 --> 37:27.100]  И я на него действую своим преобразованием. Я же хочу это значение как-то изменить.
[37:27.100 --> 37:34.100]  Вот действую преобразованием и пытаюсь это новое значение записать.
[37:34.100 --> 37:36.100]  Если я прохожу через вторую фазу, я записал значение.
[37:36.100 --> 37:43.100]  Если я не прохожу через вторую фазу, то что?
[37:43.100 --> 37:50.100]  Да нет, не так.
[37:50.100 --> 37:54.100]  Ну вот смотри, у нас была история такая в начале.
[37:54.100 --> 38:05.100]  Было вот синий, красный, зеленый. И граф был вот такой.
[38:05.100 --> 38:08.100]  И была четвертая операция.
[38:08.100 --> 38:14.100]  Вот смотри, тут прямо сейчас реализовалось две альтернативные ветки жизни ячейки памяти.
[38:14.100 --> 38:20.100]  Вот есть одна ветка и другая ветка. И чем именно история продолжится, непонятно.
[38:20.100 --> 38:29.100]  Если мой препарат приземлиться на первую и вторую, то получается, что я продолжу ветку вот эту вот.
[38:29.100 --> 38:33.100]  Если приземлиться на первую и третью, то я продолжу ветку вот эту вот.
[38:33.100 --> 38:37.100]  Ну и как судьба сложится, та ветка и станет в конце концов закомиченной.
[38:37.100 --> 38:44.100]  То есть если я комичу какое-то значение, то значит я финализирую всю ветку перед ней.
[38:44.100 --> 38:55.100]  Вот эти три операции, операция один началась и провалилась, операция два началась и провалилась.
[38:55.100 --> 39:03.100]  В некотором смысле неуспешна. Но она неуспешна не в том смысле, что она вот зафейлилась и можно ее повторить.
[39:03.100 --> 39:09.100]  Наоборот, она завершилась непредсказуемым исходом. В зависимости от того, что будет дальше,
[39:09.100 --> 39:17.100]  эта операция, например, три, она либо может стать частью истории, либо выпадет из нее.
[39:17.100 --> 39:21.100]  В зависимости от того, что будет дальше происходить.
[39:21.100 --> 39:28.100]  Так вот, мы упорядочили операцию довольно странным образом.
[39:28.100 --> 39:34.100]  Но тем не менее, мы получили цепочку, такую историю.
[39:34.100 --> 39:45.100]  И что предлагается делать дальше? Предлагается в качестве сделать в нашем алгоритме три операции.
[39:45.100 --> 39:51.100]  Вот кажется так видно. У нас есть операция чтения, это тождественная функция.
[39:51.100 --> 39:56.100]  То есть мы читаем с Quorum и пишем на Quorum то же самое. У нас есть операция CAS.
[39:56.100 --> 40:02.100]  То есть мы в качестве значения храним пару версия и содержимые.
[40:02.100 --> 40:11.100]  И каждая операция выглядит так. Если версия равна чему-то, то записать новое значение с версии плюс один.
[40:11.100 --> 40:15.100]  То есть у нас есть операция чтения, у нас есть операция CAS.
[40:15.100 --> 40:22.100]  И мы научились их выполнять с помощью одного единственного паксуса.
[40:22.100 --> 40:28.100]  Смотрите, вы выполняете операцию CAS, она проходит через первую фазу, а на второй фазе фейлится.
[40:28.100 --> 40:34.100]  Это означает, что она либо успешно закоммитилась, либо закоммитилась, мы пока этого не поняли.
[40:34.100 --> 40:38.100]  Точнее не так. Она осталась в подвешенном состоянии в этом графе.
[40:38.100 --> 40:43.100]  И она либо закоммитится чем-то другой операцией в будущем или нет.
[40:43.100 --> 40:47.100]  Но мы этого не понимаем, поэтому мы просто делаем чтение.
[40:47.100 --> 40:54.100]  Чтение безопасно ретравить. И вот если чтение закоммитилось, то он зафиксировал некоторую историю.
[40:54.100 --> 40:57.100]  И после этого мы финализировали предшествующую операцию.
[40:57.100 --> 41:04.100]  То есть она либо откатилась, либо накатилась, либо зафиксировалась надежно уже.
[41:04.100 --> 41:08.100]  Это очень странно. Но мне кажется, что это очень странно.
[41:08.100 --> 41:12.100]  Но тем не менее, так можно делать. Правда, тут есть один нюанс.
[41:12.100 --> 41:19.100]  То есть вы применили CAS, он завершился значением maybe. То есть он непонятно, применился или нет.
[41:19.100 --> 41:22.100]  Как вам понять, применился он или нет?
[41:22.100 --> 41:25.100]  То есть вы делали CAS из первой версии во вторую.
[41:25.100 --> 41:33.100]  Вторая фаза паксуса провалилась, поэтому вы делаете чтение, а чтение вам говорит, версия уже пятая.
[41:33.100 --> 41:38.100]  Вот вы не можете понять, вы закоммитили свой старый CAS или не закоммитили.
[41:38.100 --> 41:43.100]  Применился или не применился, потому что тут уже несколько CAS прошло.
[41:43.100 --> 41:48.100]  Но если вы в одной чехии памяти храните всю историю изменений,
[41:48.100 --> 41:54.100]  то получается, что по этой истории можно понять, закоммитился ваш CAS или нет.
[41:54.100 --> 42:03.100]  И вы можете повторить его, либо считать, что он готов, потому что его накрыло сверху вот этим закоммичным чтением.
[42:08.100 --> 42:12.100]  То есть вы применили все предыдущие состояния нашей чехии памяти?
[42:12.100 --> 42:15.100]  Получается, что да. Если мы так делаем, то мы вообще все понимаем.
[42:15.100 --> 42:18.100]  Даже несмотря на то, что у нас операция заканчивалась от значения maybe.
[42:18.100 --> 42:21.100]  То есть потому, что вы проверили, мы просто входим по всем имени?
[42:21.100 --> 42:25.100]  Нет, мы читаем до тех пор, пока чтение будет успешно.
[42:25.100 --> 42:29.100]  И после чтения можно считать, что наша операция либо отменилась, либо применилась.
[42:29.100 --> 42:35.100]  Мы прочитали успешно и смотрим, применилась или откатилась.
[42:36.100 --> 42:42.100]  Мы прошли для некоторого n через две фазы паксуса.
[42:42.100 --> 42:47.100]  То есть у тебя каждый кружочек, он же финализирует альтернативу некоторую.
[42:47.100 --> 42:49.100]  То есть применилась, значит, в кружочек?
[42:49.100 --> 42:53.100]  Твоя чтение применилась, значит, она ввелась в кружочек.
[42:53.100 --> 42:59.100]  А это значит, что оно зафиксировало перед собой все операции, которые тоже могли бы закоммититься.
[42:59.100 --> 43:04.100]  А какие-то ветки, наоборот, закатились.
[43:04.100 --> 43:08.100]  То есть у нас здесь, в отличие от мультипаксуса, нет истории одной изменений.
[43:08.100 --> 43:10.100]  Есть такие веточки, которые отмирают.
[43:10.100 --> 43:14.100]  Но, тем не менее, есть одна ветка, на которой попадает все закоммиченное.
[43:14.100 --> 43:17.100]  Чем-то на блокчейн похоже.
[43:21.100 --> 43:28.100]  Ну так вот, а Фейсбук говорит, что для их сервиса координации достаточно одного регистра, который умеет делать условную перезапись.
[43:28.100 --> 43:35.100]  То есть они могли бы войтись одним синглдикрипаксусом, в принципе, для того, чтобы свою систему построить.
[43:35.100 --> 43:37.100]  Что довольно странно.
[43:37.100 --> 43:41.100]  Он поверх этого сервиса координации, можно строить уже колоссус, и в итоге...
[43:41.100 --> 43:46.100]  То есть если довести до абсурда, то, в принципе, можно в один синглдикрипаксус все упаковать, всю сложность.
[43:51.100 --> 43:55.100]  Да, ну тут она неудобна тем, что она завершается иногда непонятным значением,
[43:55.100 --> 44:00.100]  и поэтому нужно как бы историю изменения помнить в самом значении ячейки памяти.
[44:02.100 --> 44:07.100]  Но если вдруг ты сумеешь даже как-то без этого обойтись, то тогда тебе даже историю помнить не нужно.
[44:08.100 --> 44:10.100]  Но тогда операция CAS, она хорошая.
[44:10.100 --> 44:13.100]  Но вот ZooKeeper, он тебе ровно такой API дает.
[44:13.100 --> 44:20.100]  То есть ты можешь записать в узел дерева новое значение, если текущая версия узла равна этому чему-то.
[44:21.100 --> 44:25.100]  И вот с помощью ZooKeeper ты дальше можешь строить другие системы.
[44:25.100 --> 44:28.100]  Ну там, не знаю, кавка у вас будет, можно кавку построить.
[44:30.100 --> 44:32.100]  Такие дела.
[44:39.100 --> 44:42.100]  Не знаю, это на самом деле все, что я хотел сегодня рассказать.
[44:43.100 --> 44:45.100]  Поэтому если у вас вопросы есть, то...
[44:45.100 --> 44:47.100]  Кто-нибудь делал такое?
[44:47.100 --> 44:48.100]  Что?
[44:49.100 --> 44:53.100]  В продакшене я не видел, а системы, которые более-менее академические.
[44:53.100 --> 44:56.100]  Эту идею по-разному придумали, но придумывали.
[44:58.100 --> 45:01.100]  Вообще этот алгоритм придумал человек, который работал в Яндексе, он просто ушел,
[45:01.100 --> 45:05.100]  как бы из Яндекса переехал в Штаты, где-то в Facebook работает, в свободное время написал статью.
[45:06.100 --> 45:11.100]  Она многих удивила, потому что какой-то неожиданный исход.
[45:13.100 --> 45:17.100]  А потом оказалось, что вот эту идею как-то в разной степени разные люди придумывали, но так не очень явно.
[45:17.100 --> 45:19.100]  Не старались особо ее описать.
[45:23.100 --> 45:26.100]  То ли общее место какое-то, но неважно, кто ее придумал.
[45:26.100 --> 45:34.100]  Важно, что даже в простом алгоритме есть такая цепочка операции, которая может упорядочить все действия.
[45:35.100 --> 45:37.100]  Это совершенно неожиданно.
