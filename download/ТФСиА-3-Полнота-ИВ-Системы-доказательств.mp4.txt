[00:00.000 --> 00:12.360]  Я доказывал это на первой лекции без япотез, то есть с пустым ножетом япотез, но доказательство
[00:12.360 --> 00:17.280]  практически не меняется, потому что, смотрите, если я использую аксиомы, она вообще всюду истинна,
[00:17.280 --> 00:21.440]  если я использую япотезу, она истинна на этом выполняющем наборе. То есть в сущности нам
[00:21.440 --> 00:27.240]  нужно доказать тоже, что если есть выполняющий набор для этого ножета формы, то тогда и а на
[00:27.240 --> 00:32.960]  этом наборе равна единице. Но проверять нужно то же самое. Аксиомы истины, япотезы истины,
[00:32.960 --> 00:40.920]  и по моду спонанс мы, если и а и за следует b истины на каком-то наборе значений переменных,
[00:40.920 --> 00:45.840]  то b тоже истина на каком-то наборе значений переменных. То есть это то же самое и очень просто.
[00:45.840 --> 01:00.080]  В обратную сторону это как раз полнотам. Ну если ножет япотез пустая, это в точности утверждение,
[01:00.080 --> 01:07.200]  что тавтологии выводимы в исчислениях высказанных. Ну а если не пусто, это означает что-то дополнительное,
[01:07.200 --> 01:13.680]  что вот мы можем вывести все следствия, которые содержательно есть из этого ножета формул,
[01:13.680 --> 01:20.080]  мы можем получить нашими синтоксическими следствиями. Это и есть основной смысл этой
[01:20.080 --> 01:26.080]  теоремы. То есть наша формальная система адекватно формализует значения формул,
[01:26.080 --> 01:36.960]  извините, свойства функций задаваемых формул. Как я это буду доказывать? Есть на самом деле
[01:36.960 --> 01:40.720]  несколько доказательств, есть очень простое конструктивное доказательство, вы можете посмотреть
[01:40.960 --> 01:47.280]  у нас в учебнике. Но я расскажу более сложное, но зато необычайно полезное доказательство,
[01:47.280 --> 01:57.120]  которое в принципе переносится на более сложные логические теории, и в котором используется очень
[01:57.120 --> 02:02.640]  важные для логики идеи. Собственно цель даже представить эти идеи, а не только рассказать доказательства.
[02:02.640 --> 02:10.080]  Первая важная идея состоит в том, что мы будем доказывать не напрямую. Не очень понятно,
[02:10.080 --> 02:14.640]  как из того, что у нас есть какое-то такое симматическое свойство, скажем формула
[02:14.640 --> 02:22.960]  Тавтология, как отсюда получить, что для нее есть вывод. Не очень понятно. Мы будем доказывать
[02:22.960 --> 02:34.200]  равносильность другой пары свойств. Я их сейчас напишу. Мы называем множество гамма противоречивым,
[02:34.200 --> 02:48.280]  если из него можно вывести какую-то формулу и можно вывести ее отрицательно. То есть из множества
[02:48.280 --> 02:57.640]  этих формул получается противоречие. И мы называем множество гамма совместно,
[02:57.640 --> 03:15.120]  если существует выполняющий набор для этого множества. На этом множестве мы тогда смотрим,
[03:15.120 --> 03:20.480]  как на систему уравнений. Вот есть формулы. Мы пишем для каждой формулы из этого множества
[03:20.480 --> 03:25.400]  уравнений. Фи от х равняется единицей. Совместность означает, что система уравнений может
[03:25.400 --> 03:34.400]  бесконечно совместно иметь решение. То есть вполне естественное название. Так вот, на самом деле,
[03:34.400 --> 03:41.400]  главный факт, это не вполне очевидно, но правильно доказывать именно вот такое утверждение, что не
[03:41.480 --> 04:02.680]  противоречивость равносильна совместности. Это другая ипостась той же самой теоремы. Просто это
[04:02.680 --> 04:16.600]  не так легко увидеть. В одну сторону, впрочем, не сложно. В какую? Ну, представьте, что система
[04:16.600 --> 04:23.360]  совместна. Тогда, ясное дело, что она не противоречива, потому что, посмотрите на определение
[04:23.360 --> 04:31.400]  противоречия, если система совместна, множество формул совместна, то тогда все, что мы можем вывести
[04:31.400 --> 04:39.280]  из этого множества, также обращается в единицу на выполняющем наборе. Но если бы мы вывели
[04:39.280 --> 04:45.600]  противоречие, мы бы получили такой странный факт, что формула истины на каком-то наборе значений
[04:46.200 --> 04:51.880]  и отрицание формулы. Истина на том же наборе значений. Это невозможно, потому что отрицание
[04:51.880 --> 04:58.800]  формулы и формула принимают в точности разные значения. В эту сторону это, по сути дела, теорема
[04:58.800 --> 05:07.000]  корректности. Все очень просто. Теперь в другую сторону. В другую сторону сложно. Это основная трудность.
[05:07.000 --> 05:15.560]  Мы пока переформулировали, но не вполне ясно, чем это нам поможет. Давайте, прежде чем рассказывать
[05:15.560 --> 05:21.280]  доказательства в другую сторону, то есть основная часть моего доказательства будет вот в эту сторону.
[05:21.280 --> 05:31.000]  Я буду доказывать, что непротиворечивое множество формул совместно. Это очень важный для логики момент,
[05:31.000 --> 05:39.680]  что если мы написали какое-то множество условий и мы каким-то образом знаем или доказали, что
[05:39.680 --> 05:45.840]  противоречия мы из этого множества вывести не можем, для него есть выполняющий набор, то есть эти
[05:45.840 --> 05:53.000]  условия реализуются. Какими бы они ни были странными. Это, я не буду отвлекаться за недостатком времени
[05:53.000 --> 06:00.120]  на историю математики, но это очень важный шаг в разных рассуждениях, связанных с основаниями
[06:00.120 --> 06:08.640]  математики. Тем не менее, прежде чем начинать доказательства, я хочу вывести вот этот факт из вот этого.
[06:08.640 --> 06:13.440]  Предположим, мы уже умеем доказывать, что непротиворечивость равносильна совместно. Как
[06:13.440 --> 06:34.320]  вывести тогда полноту? Ну, смотрите, у нас есть условие, что из гамма синтоксически следует...
[06:34.320 --> 06:40.120]  А, симонтически, извините. Тогда вот такое множество формул обязательно не совместно.
[06:40.120 --> 06:49.520]  Посмотрите на определение. Если мы вдруг нашли набор значений и переменных, на которых все формулы
[06:49.520 --> 06:54.880]  из гамма обратились единицу, то тогда и формула обратилась единицу, а отрицание формулы обратилось
[06:54.880 --> 07:00.480]  в ноль. То есть у нас либо на любом наборе значений и переменных, либо какая-то формула отсюда
[07:00.480 --> 07:07.400]  обращается в ноль, либо отрицание А обращается в ноль. Теперь смотрим на вот это утверждение. Раз это множество
[07:07.400 --> 07:18.200]  не совместно, оно противоречиво. То есть мы по определению знаем, что из него можно вывести какое-то противоречие.
[07:18.200 --> 07:33.240]  Очень хорошо. Но мы знаем также и теорему дедукции. Это утверждение означает, что из самого множества мы можем вывести
[07:33.240 --> 07:43.560]  такие формулы. Из-за А следует В, и можем вывести также формулы, из-за А следует В. Ну, а зная эти факты, построить вывод
[07:43.560 --> 07:53.240]  формулы А, нам же конечно в шуте нужно вывести формула. Уже очень легко. Как мы это делаем? Мы вначале выводим эти две формулы.
[07:53.240 --> 08:01.240]  Просто выводы, которые там перечислены, записываем. Теперь пишем третью схему акцион.
[08:12.240 --> 08:21.240]  И два раза применяем моду спонс. У нас уже есть такая формула, которая посылка в этой третьей схеме акциона. Значит, мы можем по моду спонс написать
[08:22.240 --> 08:30.240]  заключение нашего вывода. Ну и такая формула у нас есть. Мы еще раз применяем моду спонс и получаем формулу А.
[08:30.240 --> 08:52.240]  Так что видно, что в эту сторону совсем легко. В обратную тоже не сложно. Давайте я не буду на это тратить время. Но если у нас есть утверждение о том, что
[08:52.240 --> 09:00.240]  несовместное множество обязательно противоречиво, мы уже все быстро можем после этого закончить доказательство теоремы полноты.
[09:01.240 --> 09:12.240]  Значит, по крайней мере один шахмус делали, теперь мы можем сосредоточиться вот на этом утверждении. Из него будет следовать полнота, основная наша теорема, все будет следовать.
[09:12.240 --> 09:29.240]  Как же доказать этот факт? К прежнему не очень ясно, но вот есть непротиворечивое множество форм. Нам хочется найти какой-то выполняющий набор значений перемен.
[09:29.240 --> 09:55.240]  На самом деле есть очень хорошая идея, как это делать. Вот смотрите. Я давайте буду определять набор значений переменных так. Если из гамма выводится переменная х и п, я полагаю значение х и п единицы.
[09:55.240 --> 10:15.240]  А если выводится отрицание х, я полагаю значение переменной ноль. Вот определил так набор значений переменных.
[10:15.240 --> 10:35.240]  А теперь я утверждаю, что этот набор выполняющий. Почему? Давайте возьмем формулу из нашего мнения. В нее входят какие-то переменные х1, х2.
[10:35.240 --> 10:50.240]  У нас есть Лемма Кальмахра, которая говорит, что из алфаверсий литералов, отвечающих этому набору значений переменных, они в точности так и определяются.
[10:50.240 --> 11:03.240]  То есть здесь это будет отрицание, здесь это будет сама переменная. Выводится алфаверсия формулы. Альфаверсия, я напомню, это или сама формула, или ее отрицание.
[11:03.240 --> 11:12.240]  Но формула уже сама принадлежит нашего множества хипотез. Конечно ее можно вывести из этого множества. Какие сомнения, просто вывод из одной строчки.
[11:12.240 --> 11:32.240]  Если бы мы еще могли вывести отрицание формулы, мы бы получили противоречие. А множество не противоречило. Значит отсюда следует, что формула на этом наборе значений переменных должна равняться единице.
[11:32.240 --> 11:45.240]  Если бы она равнялась нулю, ее бы алфаверсия была бы отрицательна по определению. То есть очень просто, если из наших формул вытекает, что мы вывели переменную эксы,
[11:45.240 --> 11:53.240]  мы же знаем теорию корректности, нам надо эксы положить равным единицам. Если вытекает, что не эксы, значит мы должны положить равным единицам.
[11:53.240 --> 12:04.240]  Но у нас точно не получится выполняющего набор. Все очень просто. Но есть одно большое но. Это хорошая идея, она работает.
[12:04.240 --> 12:13.240]  И тут видно как используется Лемма Кальмара. Техническая трудность скрыта вот здесь. Я ее в прошлый раз преодолел.
[12:13.240 --> 12:24.240]  Вот здесь нам нужно конкретные знания про конкретную формальную систему. А так эти общие рассуждения, они конкретному виду формальной системы даже не очень привязаны.
[12:24.240 --> 12:34.240]  Но есть проблема. Проблема состоит в том, что, замечательно, если так, то так, если это, то это, а если не выводится ни то, ни другое.
[12:34.240 --> 12:41.240]  Ну вот представьте, что множество гипотез пусто. Мы же хотим в частности доказать теорию о полноте. То есть если тавтология, то она выводимая.
[12:41.240 --> 12:48.240]  Тогда мы должны взять пустое множество гипотез. И что делать? С пустое множество гипотез мы не можем вывести ни переменную, ни ее отрицания.
[12:48.240 --> 12:54.240]  Потому что выводимый только тавтология. Ни переменная, ни ее отрицания, тавтология не выводится.
[12:54.240 --> 13:00.240]  И это вроде бы создает какое-то немыслимое препятствие.
[13:05.240 --> 13:12.240]  Тем не менее, это препятствие преодолимым.
[13:12.240 --> 13:19.240]  Идея его преодоления, она как раз очень важна. Она в логике постоянно используется для доказательств самых разных фактов.
[13:19.240 --> 13:27.240]  И для доказательств полноты самых разных логических систем, если они достаточно сложны, что-то такое обязательно приходится делать.
[13:27.240 --> 13:35.240]  Идея состоит в том, что мы множество должны поповодиться. То есть сохраняя непротиворечимость, добавлять в него формулу.
[13:35.240 --> 13:39.240]  Для чего? Чем больше формул, тем больше формул выводится.
[13:39.240 --> 13:48.240]  Мы хотим добиться того, чтобы для каждой переменной выводился какой-нибудь из литералов, или позитивный, или негативный, или сама переменная, или ее отрицания.
[13:48.240 --> 14:07.240]  Если мы этого добьемся, представьте, что множество гамма такое, что для любой переменной у нас выводится или переменная, или отрицание.
[14:07.240 --> 14:17.240]  Тогда вот этот план прекраснейшим образом работает, потому что мы получим действительно выполняющий набор для, при своем значении, всем перемен.
[14:17.240 --> 14:39.240]  Заметьте также, что из того же соображения про лему кальмара, из такого свойства будет следовать, что вообще для любой формул, из гамма выводится формула, или выводится отрицание формул.
[14:40.240 --> 14:49.240]  Ну потому что раз мы вывели все переменные, дальше применяя лему кальмара, мы получим альфа-версию любой формулы. Альфа-версия это или формула, или ее отрицание.
[14:49.240 --> 14:58.240]  Вот такие множества формул имеют специальное название. Они называются поумы. Просто по определению.
[14:58.240 --> 15:26.240]  Таким образом наша цель, что нам осталось сделать, это доказать, что любое множество непротиворечиво содержится в непротиворечивом полном.
[15:28.240 --> 15:40.240]  Ведь смотрите, а что тут существенно? Когда мы расширяем множество формул, совместность только сложнее становится доказывать. У нас появляются дополнительные формулы, они тоже должны обращаться в единство.
[15:40.240 --> 15:47.240]  Уже если большее множество имеет выполняющий набор, то тот же выполняющий набор будет для любого его подножия.
[15:47.240 --> 15:55.240]  А для полного непротиворечивого множества работает вот эта прекраснейшая идея с использованием лему оценки.
[15:55.240 --> 16:02.240]  То есть мы смотрим какие из литералов выводятся, присваиваем им переменным соответствующие значения.
[16:02.240 --> 16:18.240]  И все, дальше применяем лему оценки и получаем, что этот набор значений переменных является выполняющим для данного множества.
[16:18.240 --> 16:28.240]  То есть все, что осталось, это каким-то образом убедиться, что любое множество можно расширить для полного непротиворечивого.
[16:28.240 --> 16:35.240]  Ну, тут это действительно можно сделать, и это я и собираюсь доказывать.
[16:35.240 --> 16:40.240]  Но доказывать я это буду в несколько шагов. Вначале я докажу лему о пополнении.
[16:40.240 --> 17:00.240]  Предположим, что для какой-то формулы нельзя вывести из множества γ, гамма мы предполагаем непротиворечивым.
[17:00.240 --> 17:07.240]  Ну, если нельзя вывести, на самом деле из противоречивого множества, как мы помним, выводится любая формула.
[17:07.240 --> 17:15.240]  Поэтому это можно было бы и не писать, только тут я неправильно формулу писал. То есть нельзя вывести ни формулу, ни ее отрицания.
[17:15.240 --> 17:27.240]  Тогда, если я добавлю к моему множеству еще и отрицание формулы, оно тоже непротиворечитно.
[17:34.240 --> 17:41.240]  Это очень важный шаг. Он как раз показывает, что наша формальная система хорошо устроена.
[17:41.240 --> 17:47.240]  Если мы уж не можем что-то доказать и опровергнуть не можем, тогда нам безопасно сделать.
[17:47.240 --> 17:54.240]  На самом деле любой выбор можно было бы и добавить. Я для простоты доказываю, только для меня будет короче доказательство.
[17:54.240 --> 17:59.240]  А в принципе, конечно, если добавить, то тоже будет непротиворечитно.
[17:59.240 --> 18:09.240]  Если мы то, что не можем доказать, примем или примем отрицание, мы никаких противоречий все равно не получим.
[18:09.240 --> 18:15.240]  Это очень важный момент, и доказательство такое синтоксическое.
[18:20.240 --> 18:32.240]  На самом деле оно уже фактически было доказано, когда я выводил свою основную теорему из вот этой вот теоремы о том, что из непротиворечимости следует совместно, что это равносильно.
[18:32.240 --> 18:37.240]  Но смотрите, я буду доказывать контрапозицию. Предположим, что это множество противоречий.
[18:41.240 --> 18:45.240]  По определению это означает, что можно построить противоречие.
[18:45.240 --> 18:53.240]  Я сейчас просто повторяю то, что я уже делал. Дальше потеря дедукции это равносильно тому, что выводится вот так.
[18:53.240 --> 18:56.240]  Ну а теперь уже все совсем понятно.
[18:56.240 --> 19:01.240]  Имея такие формулы, мы опять-таки пишем их выводы.
[19:05.240 --> 19:11.240]  Тут где-то я забил отрицание. Не А, в любом случае, это отрицание.
[19:12.240 --> 19:15.240]  Дальше пишем третью схему ОСЕО.
[19:15.240 --> 19:17.240]  Ну и два раза модусполненсов применяем.
[19:18.240 --> 19:22.240]  То есть это в точности тоже рассуждение, которое уже было.
[19:27.240 --> 19:29.240]  Вот так вот.
[19:29.240 --> 19:31.240]  Вот так вот.
[19:31.240 --> 19:33.240]  Вот так вот.
[19:33.240 --> 19:35.240]  Вот так вот.
[19:35.240 --> 19:37.240]  Вот так вот.
[19:37.240 --> 19:39.240]  Вот так вот.
[19:39.240 --> 19:41.240]  Вот так вот.
[19:41.240 --> 19:43.240]  Вот так вот.
[19:46.240 --> 19:52.240]  То есть смотрите, мы получили вывод из множества гамма формулы А.
[19:54.240 --> 20:01.240]  Пришли к противоречию с условием леммы, потому что мы предполагаем, что А невыводимо и отрицание А невыводимо.
[20:02.240 --> 20:15.240]  Таким образом, мы можем пополнять наше непротиворечивое множество, сохраняя непротиворечивость.
[20:15.240 --> 20:26.240]  А чем больше у нас формул, тем легче доказывать, тем легче выводить, тем больше у нас формулы выводятся.
[20:27.240 --> 20:33.240]  Ну если мы получим противоречивое множество, начнут выводиться все, но так далеко мы заходить не будем.
[20:33.240 --> 20:39.240]  Мы внимательно следим за тем, чтобы не добавлять лишнего, чтобы непротиворечивость сохранилась.
[20:39.240 --> 20:42.240]  Ну и как теперь будем рассуждать?
[20:42.240 --> 20:45.240]  Теперь рассуждение уже такое.
[20:45.240 --> 20:51.240]  Давайте построим возрастающую последовательность множеств формы.
[20:57.240 --> 20:59.240]  Бесконечно.
[20:59.240 --> 21:04.240]  Я напомню, что в переменах у нас счетное количество, то есть все переменные как-то перенумерованы.
[21:04.240 --> 21:10.240]  Все переменные, которые мы используем, они имеют номер.
[21:10.240 --> 21:13.240]  Целая ручка в каждом положительном число, не важно какое.
[21:13.240 --> 21:24.240]  И вот теперь я так и буду строить индуктивно свои множества.
[21:24.240 --> 21:32.240]  Во-первых, в некоторых случаях множество просто не меняется.
[21:32.240 --> 21:34.240]  У меня не струй порядок.
[21:34.240 --> 21:36.240]  Не меняется, ну вот в каких случаях.
[21:36.240 --> 21:47.240]  Если из предыдущего множества выводится или катая переменная, или выводится отрицание.
[21:47.240 --> 21:50.240]  Тогда мы множество не меняем.
[21:50.240 --> 21:59.240]  А в противном случае мы добавляем все переменные.
[22:00.240 --> 22:06.240]  Мы добавляем отрицание этой переменной.
[22:10.240 --> 22:14.240]  То есть вот такое определение последовательности множеств формы.
[22:14.240 --> 22:17.240]  То есть мы начинаем с нашего множества, какое бы оно ни было.
[22:17.240 --> 22:22.240]  Если оно еще не является полным, то мы выполняем эти шаги.
[22:22.240 --> 22:27.240]  Но если оно полное уже, то просто все множества в этой последовательности будут равными.
[22:27.240 --> 22:30.240]  Потому что первая строчка всегда выполняется.
[22:30.240 --> 22:34.240]  А если оно не полное и для каких-то переменных ничего не определено,
[22:34.240 --> 22:37.240]  мы просто добавляем множество отрицания.
[22:39.240 --> 22:43.240]  Ну давайте посмотрим на лему и на это построение.
[22:43.240 --> 22:58.240]  Ясно, что индукции пока можно доказать, что все эти множества непротиворечивы.
[22:58.240 --> 23:03.240]  Просто мы по очереди добавляем формулы, применяем много раз эту лему,
[23:03.240 --> 23:06.240]  и непротиворечивость сохраняется.
[23:06.240 --> 23:11.240]  Но теперь мне же нужно вот полное непротиворечивое множество.
[23:11.240 --> 23:14.240]  Что это будет? Это будет объединение всех этих множеств.
[23:14.240 --> 23:16.240]  То есть такой предел.
[23:17.240 --> 23:20.240]  И с пределом возникает сложность.
[23:20.240 --> 23:22.240]  Какая сложность возникает с пределом?
[23:22.240 --> 23:25.240]  Вы уже, я думаю, много математики изучали,
[23:25.240 --> 23:29.240]  и знаете, что при предельных переходах свойства могут нарушаться.
[23:42.240 --> 23:45.240]  Берете расширяющиеся последовательно замкнутых множества,
[23:45.240 --> 23:48.240]  вложенные друг у друга,
[23:48.240 --> 23:50.240]  а их объединение уже не замкнутое.
[23:50.240 --> 23:53.240]  Ну я думаю, с легкостью такой пример построить.
[23:53.240 --> 23:59.240]  Ну просто вы возьмите отрезки, которые от минус а до а,
[23:59.240 --> 24:02.240]  где а там меняется нуля до единицы.
[24:02.240 --> 24:05.240]  Это такая бесконечная система отрезков,
[24:05.240 --> 24:07.240]  каждый из них замкнутое множество,
[24:07.240 --> 24:10.240]  а если возьмете объединение, у вас получится интервал.
[24:10.240 --> 24:12.240]  Ну единицу они включают.
[24:12.240 --> 24:14.240]  У вас получится интервал, который уже не замкнутый.
[24:14.240 --> 24:19.240]  Здесь может в принципе быть та же самая проблема, но нам везет.
[24:19.240 --> 24:23.240]  На самом деле это множество тоже не противоречиво.
[24:27.240 --> 24:29.240]  А следующие очень важные причины.
[24:29.240 --> 24:31.240]  Но настоящая причина состоит в том,
[24:31.240 --> 24:35.240]  что топология, которая стоит за этими конструкциями,
[24:35.240 --> 24:38.240]  она другая, не такая как с числами.
[24:38.240 --> 24:43.240]  И там той проблемы, которую я обозначил, не была.
[24:44.240 --> 24:47.240]  Все открыты, но что ниже из-за.
[24:47.240 --> 24:52.240]  Ну не все, но не буду на это тратить время,
[24:52.240 --> 24:55.240]  потому что там аккуратное слово требует время.
[24:55.240 --> 24:57.240]  Но доказать это очень легко.
[24:57.240 --> 24:59.240]  Потому что, смотрите, предположим,
[24:59.240 --> 25:02.240]  что объединение всех этих множеств оказалось противоречиво.
[25:02.240 --> 25:05.240]  По определению это означает, что мы можем вывести противоречие.
[25:05.240 --> 25:07.240]  Но противоречие это два вывода.
[25:07.240 --> 25:10.240]  Вывод в какую-то формулу A, вывод в какую-то формулу N.
[25:10.240 --> 25:13.240]  Вывод по определению это конечная последовательность формулы.
[25:13.240 --> 25:17.240]  В этой конечной последовательности мы из всего этого множества,
[25:19.240 --> 25:23.240]  можем использовать только конечное множество формул.
[25:23.240 --> 25:26.240]  Потому что у нас всего конечное множество формул.
[25:26.240 --> 25:29.240]  Но раз мы используем только конечное множество формул,
[25:29.240 --> 25:32.240]  они все входят в какие-то гамма-каты.
[25:32.240 --> 25:35.240]  Т.е. мы можем указать конкретно какая-то гамма-Mв,
[25:35.240 --> 25:40.240]  гамма n большое, куда входят все формулы, которые нам понадобятся для вывода противоречия.
[25:40.240 --> 25:46.240]  И тогда эта гамма n большое тоже противоречила, потому что ничего дальше мы не используем.
[25:46.240 --> 25:52.240]  Таким образом, оно не противоречиво, и оно полно.
[25:52.240 --> 25:55.240]  Но полно по тому трюку, который я с самого начала обозначил.
[25:55.240 --> 26:01.240]  Ведь смотрите, после того, как я взял все эти формулы, я уже точно знаю,
[26:01.240 --> 26:05.240]  что для каждой переменной выводится или переменная, или ее отрицание.
[26:05.240 --> 26:09.240]  Потому что если какая-то переменная из предыдущего множества формул не выводится,
[26:09.240 --> 26:13.240]  и не выводится ее отрицание, на следующем шаге мы прям добавляем отрицание этой переменной.
[26:13.240 --> 26:21.240]  То есть мы так принудительно добиваемся того, чтобы для каждой переменной один из литераллов выводился.
[26:21.240 --> 26:23.240]  И следим за сохранением непротиворечимости.
[26:23.240 --> 26:28.240]  Тут основная сложность состоит, конечно, в том, что непротиворечимость нам надо сохранить.
[26:28.240 --> 26:34.240]  Потому что если мы слишком легкомысленно отнесемся к этому делу, у нас возникнут проблемы.
[26:34.240 --> 26:41.240]  Ну хорошо, значит, это вот доказательство теоремы о полноте.
[26:41.240 --> 26:44.240]  Теперь я еще раз пройдусь в обратную сторону.
[26:44.240 --> 26:46.240]  Значит, что мы сделали?
[26:46.240 --> 26:48.240]  Мы доказали лему о пополнении.
[26:48.240 --> 26:54.240]  Мы доказали, что используя ее в качестве шага индукции мы можем построить
[26:54.240 --> 27:00.240]  полное непротиворечивое множество формул, содержащее данное множество.
[27:00.240 --> 27:05.240]  А для полного непротиворечивого множества мы знаем уже, что оно совместно.
[27:05.240 --> 27:11.240]  Мы явно указали процедуру нахождения выполняющего набора.
[27:11.240 --> 27:15.240]  Раз оно совместно, мы доказали, что было непротиворечивое множество, то оно совместно.
[27:15.240 --> 27:20.240]  И, как я уже говорил, отсюда будет следовать то, что я хотел.
[27:20.240 --> 27:26.240]  Что если формула является следствием семантическим из данного множества формул,
[27:26.240 --> 27:29.240]  то ее можно вывести синтоксически.
[27:29.240 --> 27:40.240]  Это следует из нашего вот этой вот главного свойства исчисления высказаний.
[27:40.240 --> 27:42.240]  Вот на этом мы закончили.
[27:42.240 --> 27:45.240]  То есть я начал с того, что определил это исчисление высказаний.
[27:45.240 --> 27:50.240]  Вот у меня почти две лекции ушло на то, чтобы доказать его адекватность этой формализации.
[27:50.240 --> 27:52.240]  То есть что выполняется и корректность, и полнота.
[27:52.240 --> 27:58.240]  Ну, корректность легко, как это обычно бывает, а с полнотой пришлось повозиться.
[27:58.240 --> 28:01.240]  Это так почти всегда.
[28:01.240 --> 28:07.240]  Ну, давайте теперь... На этом мы не закончили еще с булевыми формулами.
[28:07.240 --> 28:10.240]  Есть два сюжета. Один короткий, другой длинный.
[28:10.240 --> 28:14.240]  Я начну с короткого, а длинный может быть придется еще в следующий раз продолжить.
[28:14.240 --> 28:17.240]  Еще точно придется.
[28:17.240 --> 28:19.240]  Короткий сюжет такой.
[28:19.240 --> 28:22.240]  Ну, у меня была странная аксиоматика.
[28:22.240 --> 28:26.240]  Три схемы аксиом, которые выглядели очень странно.
[28:26.240 --> 28:29.240]  И оправдывались, конечно, тем, что их очень удобно используют доказательства.
[28:29.240 --> 28:32.240]  Как вы видели, на теоремы дедукции первые две схемы нужны.
[28:32.240 --> 28:36.240]  А дальше почти во всех рассуждениях мы использовали третью схему аксиом.
[28:36.240 --> 28:39.240]  Без нее как-то ничего не получалось.
[28:40.240 --> 28:46.240]  А что будет, если я попытаюсь другую аксиоматику написать?
[28:46.240 --> 28:49.240]  Действительно, можно написать другую аксиоматику для других связок.
[28:49.240 --> 28:52.240]  Но та аксиоматика, которую я написал, она минимальна.
[28:52.240 --> 28:55.240]  Я про это упоминал. Сейчас я хочу сказать немножко подробнее
[28:55.240 --> 28:58.240]  и объяснить идею доказательств.
[28:58.240 --> 29:01.240]  Вот представьте, что мы из трех схем всем оставили две.
[29:01.240 --> 29:04.240]  Ну, скажем, первую и вторую.
[29:04.240 --> 29:09.240]  Изменили числение высказывания.
[29:09.240 --> 29:12.240]  Это тоже какая-то формальная система.
[29:12.240 --> 29:17.240]  Все определения, выводимости и так далее, они все сохраняются.
[29:17.240 --> 29:20.240]  Правила вывода я сохраняю.
[29:20.240 --> 29:23.240]  Что про такую формальную систему можно сказать?
[29:23.240 --> 29:26.240]  На ней какие-то формулы выводятся.
[29:26.240 --> 29:29.240]  Например, из-за следует а.
[29:29.240 --> 29:32.240]  Я прям явно вывод писал.
[29:32.240 --> 29:35.240]  А какие формулы выводятся?
[29:35.240 --> 29:38.240]  Ответ на этот вопрос не очень простой.
[29:38.240 --> 29:41.240]  Я его давать в полном объеме не буду.
[29:41.240 --> 29:44.240]  Но точно не все тавтологии.
[29:48.240 --> 29:51.240]  Конечно, выводятся только тавтологии.
[29:51.240 --> 29:54.240]  Корректность сохраняется.
[29:54.240 --> 29:57.240]  Если я вывел, не использую третьей схемы аксиомата,
[29:57.240 --> 30:00.240]  понятно, что теремму корректности все равно применить можно.
[30:00.240 --> 30:03.240]  И для доказательства этого факта
[30:03.240 --> 30:07.240]  используется такой популярный математический метод
[30:07.240 --> 30:10.240]  контрмоды.
[30:10.240 --> 30:13.240]  У нас есть формулы.
[30:13.240 --> 30:16.240]  Я для простоты говорю о формулах,
[30:16.240 --> 30:19.240]  которые используют только две связки.
[30:19.240 --> 30:22.240]  Импликация и накрицание.
[30:22.240 --> 30:25.240]  Одна связка от двух аргументов,
[30:25.240 --> 30:28.240]  другая от одного.
[30:28.240 --> 30:31.240]  И я их трактовал как болевые функции.
[30:31.240 --> 30:34.240]  Функции, которые определены на множестве 0 и 1,
[30:34.240 --> 30:37.240]  принимают значение 0.
[30:37.240 --> 30:40.240]  Но совершенно не обязательно делать так.
[30:40.240 --> 30:43.240]  Если я возьму какую-нибудь другую функцию.
[30:43.240 --> 30:46.240]  Скажем, действительных чисел.
[30:46.240 --> 30:49.240]  Буду считать, что импликация это функция х плюс эффект,
[30:49.240 --> 30:52.240]  а накрицание это функция х переходит в х квадрат.
[30:52.240 --> 30:55.240]  У меня каждой формуле моей будет соответствовать
[30:55.240 --> 30:58.240]  Ну, если я возьму любое множество, любую пару функций,
[30:58.240 --> 31:01.240]  то формулы будут задавать какие-то функции.
[31:01.240 --> 31:04.240]  Так вот, смотрите, какая идея.
[31:04.240 --> 31:07.240]  Нам нужно,
[31:07.240 --> 31:10.240]  чтобы построить, как говорят, контрмодель,
[31:10.240 --> 31:13.240]  нам нужно придумать
[31:13.240 --> 31:16.240]  такой набор функций,
[31:16.240 --> 31:19.240]  который обладал бы следующим свойством.
[31:19.240 --> 31:22.240]  Все аксиомы,
[31:22.240 --> 31:25.240]  соответствуют какие-то функции.
[31:25.240 --> 31:28.240]  То есть, я определил функцию импликации и функцию отрицания.
[31:28.240 --> 31:31.240]  Что соответствует импликация и отрицание.
[31:31.240 --> 31:34.240]  Тогда первым был схема Максима,
[31:34.240 --> 31:37.240]  будут отвечать какие-то функции.
[31:37.240 --> 31:40.240]  И вот надо, чтобы эти функции были каким-нибудь хорошим свойством.
[31:40.240 --> 31:43.240]  Вот как Тавтология. Тавтология, это, естественно, равный единице.
[31:43.240 --> 31:46.240]  Функция константа, роман, какому-то константу мы скачиваем.
[31:46.240 --> 31:49.240]  А та формула, про которую мы хотим доказать, что вывести нельзя,
[31:49.240 --> 31:52.240]  нам нужно, чтобы модус понус это сохранил.
[31:52.240 --> 31:55.240]  Что если у нас применяется модус понус,
[31:55.240 --> 31:58.240]  то получается константная функция.
[31:58.240 --> 32:01.240]  Это такие свойства, которые задают ограничения
[32:01.240 --> 32:04.240]  на эти пары функций.
[32:04.240 --> 32:07.240]  И если нам такое сделать удалось,
[32:07.240 --> 32:10.240]  и мы нашли формулу, которая не задает константную функцию,
[32:10.240 --> 32:13.240]  в этой модели, другой, не булилой,
[32:13.240 --> 32:16.240]  то мы знаем, что ее вывести нельзя.
[32:16.240 --> 32:19.240]  Если вот то, что я сказал, выполняется,
[32:19.240 --> 32:22.240]  то теорема корректности тоже выполняется.
[32:22.240 --> 32:25.240]  Ну и вот конкретно для этой формальной системы
[32:25.240 --> 32:28.240]  функции определить очень легко.
[32:28.240 --> 32:31.240]  Они заданы такие, действительно,
[32:31.240 --> 32:34.240]  на множестве ноль.
[32:34.240 --> 32:37.240]  И импликация задана, как и раньше было.
[32:37.240 --> 32:40.240]  А вот отрицание,
[32:40.240 --> 32:43.240]  это простоождественная функция.
[32:43.240 --> 32:46.240]  Ну, имею право.
[32:46.240 --> 32:49.240]  Тогда смотрите,
[32:49.240 --> 32:52.240]  про модус понус там входит только импликация,
[32:52.240 --> 32:55.240]  поэтому все наши рассуждения сохраняются.
[32:55.240 --> 32:58.240]  Если функция тождественно равна единице,
[32:58.240 --> 33:01.240]  формула задает функцию тождественно равной единице,
[33:01.240 --> 33:04.240]  и формула из A следует B задает формулу,
[33:04.240 --> 33:07.240]  функцию тождественно равной единице,
[33:07.240 --> 33:10.240]  потому что импликация точно так же.
[33:10.240 --> 33:20.240]  И первые две схемы аксема там вообще нет отрицания, поэтому они не меняются, они в этой функции тождественной равной единице.
[33:20.240 --> 33:31.240]  А вот третья схема аксема уже с ней будут проблемы. Давайте я ее напишу.
[33:31.240 --> 33:49.240]  Посмотрите, теперь отрицание это тождественная функция, поэтому функция, которая задается такой формулой, и функция, которая задается вот такой формулой, они просто-напросто совпадают как функции.
[33:49.240 --> 33:56.240]  Функция была разная, а функция та же самая.
[33:56.240 --> 34:03.240]  Но вот эта формула не является фактологией. Очень легко придумать значение переменных, при которых эта формула ложна.
[34:03.240 --> 34:11.240]  Нам нужно, чтобы вот эта формула ложна, значит вот это ноль, это единица.
[34:11.240 --> 34:21.240]  Ну главное, давайте возьмем х равную 0 или х равную 0, тогда это единица, это единица, из единицы ноль это ноль, и из единицы ноль это ноль.
[34:21.240 --> 34:28.240]  Таким образом это не фактология. Копить очень просто.
[34:28.240 --> 34:38.240]  Ну то же самое верно, если оставить, скажем, вторую и третью схему аксема. Тут пример немножко выраженный, потому что отрицание вообще в этих схемах первых двух не используется.
[34:38.240 --> 34:53.240]  Но если оставить вторую и третью схему аксема, опять-таки найдется контрмодель, можно придумать такие функции, которые будут задавать, такие функции для импликации отрицания, которые будут задавать.
[34:53.240 --> 34:59.240]  Вторую и третью схему аксем будут отвечать константным функциям, а первая схема аксем не будет отвечать константным функциям.
[34:59.240 --> 35:03.240]  И то же самое, если оставить первую и третью схему аксема.
[35:03.240 --> 35:17.240]  Но два других примера, они более сложные, значит там, во-первых, уже двузначной логики не хватает, нужно использовать трехзначную логику, то есть множество из трех значений, и функции, ну мягко говоря, непрозрачные.
[35:17.240 --> 35:27.240]  То есть их как-то люди подобрали в свое время. Сейчас, конечно, это можно было бы сделать компьютерным поиском, потому что понятно, функций все-таки не так много, множество из трех элементов.
[35:27.240 --> 35:40.240]  Но сделано это было давным-давно, и люди просто на бумажке подобрали. У нас в учебнике эти примеры примодятся и даже разобраны, но они как-то выглядят не очень убедительно.
[35:40.240 --> 35:55.240]  Просто не очень понятно, какая математика за этим стоит. Вот за этой формальной системой стоит очень интересная математика, то, что называется интуиционистское числение высказываний, но я не буду про него ничего говорить.
[35:55.240 --> 36:04.240]  Кому интересно, можете почитать книжки, у нас в учебнике есть голова, в курс, к сожалению, это не помещается, это было бы очень интересно, но не помещается.
[36:04.240 --> 36:16.240]  Так, давайте сделаем перерыв. Я извиняюсь, я делаю перерыв, чуть-чуть затяну, потому что сейчас перерыв на пять минут давайте сделаем, и после перерыва уже займемся прыгом.
[36:16.240 --> 36:31.240]  Ну, давайте потихоньку начнем, так по моим часам еще минута где-то от перерыва осталось. Я постепенно начну, потому что мы закончили разбор вот этого важного примера, исчисления высказываний.
[36:31.240 --> 36:53.240]  Но что осталось не разобранным? Если вы помните, я начинал с задачи проверки тавтологичности формулы. У нас был совсем простой способ, просто по таблице выписать таблицу значений, их два в степени, строчек, применить и получить ответ.
[36:53.240 --> 37:09.240]  Вычислить значения, если все единицы, то тавтология, если какая-то не единица, то нет тавтологии. Очень простой способ. Чем хороша система, которая назвала исчисления высказываний?
[37:09.240 --> 37:22.240]  Она имитирует обычные математические рассуждения. То есть, по сути дела, мы строим доказательство того, что формула тавтологии. Такое доказательство в очень мелких шагах. Мы пишем какие-то очень простые факты, которые являются тавтологиями.
[37:22.240 --> 37:34.240]  Просто наши схемы аксем, могли бы и более сложные тавтологии писать, про которые легко проверить, что они тавтологи. А потом применяем моду спонс. Это обычный способ математического рассуждения.
[37:34.240 --> 37:44.240]  Если я доказал А и доказал, что из А следует В, значит я могу вывести В. То есть, эта наша система моделирует обычные математические доказательства.
[37:44.240 --> 37:52.240]  Этим она сильна. Она на самом деле является частью более сложных логических систем, про которые я чуть-чуть скажу позже.
[37:52.240 --> 38:00.240]  Но с точки зрения проверки тавтологичности, давайте подумаем, выиграли мы что-нибудь или нет.
[38:00.240 --> 38:14.240]  У вас есть какая-то сложная формула. Как строить вывод, допустим, мы хотим доказать, что она тавтология. Нам надо построить вывод в исчислении высказываний. С чего начинать? Совершенно непонятно.
[38:14.240 --> 38:22.240]  Исчисление высказываний настолько хорошо мимикрирует под настоящее математическое рассуждение, что возникают те же самые сложности.
[38:22.240 --> 38:28.240]  Если у вас есть какая-то реальная содержательная математическая задача, тоже часто бывает, смотришь на нее и непонятно с чего начать.
[38:28.240 --> 38:33.240]  То есть, это такая обычная проблема для математики. И тут она в полной мере присутствует.
[38:33.240 --> 38:41.240]  А допустим, мы хотим писать компьютерную программу, которая проверяет тавтологичность. Чем нам наше исчисление в высказывании поможет?
[38:41.240 --> 38:49.240]  А непонятно чем, потому что с чего начинать? Программа должна с чего-то начинать. С чего ей начинать? Неясно совершенно.
[38:49.240 --> 39:00.240]  С другой стороны, почему математики вот так вот рассуждали, используя modus ponens и какие-то простые формулы?
[39:00.240 --> 39:05.240]  Да потому что по почталеной Печкиной не было велосипеда, а у них не было компьютеров.
[39:05.240 --> 39:14.240]  По-другому было очень сложно на бумажке делать. Если вы что-то сложное преобразование с формулой делаете, пойди его проверь, что вы нигде не запутались.
[39:14.240 --> 39:17.240]  Поэтому математики старались все разбивать на максимально простые ходы.
[39:17.240 --> 39:24.240]  Что изменилось в наш компьютерный век? Изменилось то, что даже если мы делаем какое-то довольно сложное преобразование формул,
[39:24.240 --> 39:31.240]  но которое можно эффективно реализовать программой, мы можем проверить корректность программы раз и навсегда, то у нас нет проблем.
[39:31.240 --> 39:41.240]  Сделаем это преобразование и будем работать с тем, что получилось. То есть с компьютерной точки зрения нам не обязательно привязываться к такому жесткому формату.
[39:41.240 --> 39:46.240]  Мы можем какие-то совершенно другие действия выполнять.
[39:46.240 --> 39:54.240]  И отсюда возникает очень важное понятие. Оно скорее относится не к классической логике, а уже к тому, что раздел теоретической информатики,
[39:54.240 --> 40:01.240]  который называется сложность доказательств, но мне бы хотелось про него немножко сказать, чтобы стало понятно, о чем я буду говорить дальше.
[40:01.240 --> 40:08.240]  Я буду в основном говорить все равно про классические вещи, но тем не менее. Возникает понятие системы доказательств.
[40:11.240 --> 40:28.240]  Я в скобках напишу тавтологии, потому что мы будем доказывать тавтологичность формул, но вообще говоря, это и более общее можно определить.
[40:28.240 --> 40:45.240]  Что такое система доказательств? Это алгоритм, у которого на вход подаются два аргумента.
[40:45.240 --> 40:52.240]  Формула и второй аргумент мы называем доказательством, но он может иметь любой природу.
[40:52.240 --> 41:00.240]  Вообще говоря, алгоритму на вход мы можем подавать какие-то двоичные строки. У нас есть двоичная строка F и двоичная строка P.
[41:00.240 --> 41:10.240]  F как-то кодирует булевую формулу. Мы это подробно не обсуждали, но я думаю, вам понятно, как закодировать булевую формулу.
[41:10.240 --> 41:21.240]  У нас есть алфавит, он, конечно, бесконечный, но вот как закодировать? Бесконечная часть у нас есть конечное число символов, которые, понятно, можно закодировать каким-нибудь способом.
[41:21.240 --> 41:35.240]  И X и T. Как закодировать X и T? Давайте писать X, а дальше двоичная запись И. У нас в нашем алфавите нет ни символа X, ни нуля и единицы.
[41:35.240 --> 41:43.240]  Мы получаем такой конечный алфавит, ну а конечный алфавит уже записать двоичными строками, это, я думаю, вы понимаете, что не очень сложно.
[41:43.240 --> 41:54.240]  Таким образом мы можем кодировать формулы. Ну и в качестве доказательства мы предъявляем какую-то двоичную строку.
[41:54.240 --> 42:07.240]  Какие требования к этому алгоритму, чтобы это была система доказательств? Требования такие. Во-первых, алгоритм должен работать достаточно быстро.
[42:07.240 --> 42:21.240]  Он работает за время, которое полинамиально зависит от длины входа. То есть длина входа у нас это сумма длин, строки, задающие формулу и строки, задающие доказательства.
[42:21.240 --> 42:34.240]  И вот алгоритм должен, то есть мы хотим все-таки, чтобы доказательство можно было легко проверить, потому что если доказательство еще и трудно проверить, то это уже вообще не очень понятно, что это за доказательство.
[42:34.240 --> 43:01.240]  Доказательство должно подвергаться автоматически, просто, быстро. И, скажем, доказательство в нашей системе исчисления высказываний такому свойству удовлетворяет, потому что в качестве второго аргумента мы подаем просто последовательность формул, которая является выводом.
[43:01.240 --> 43:16.240]  И все, что нам нужно проверять, это, во-первых, что первое слово задает формулу, второе слово задает вывод, который заканчивается нашей формулой, но это сравнительно легко проверить, чтобы одно двоичное слово содержит другое в каком-то формате.
[43:16.240 --> 43:32.240]  И что все, что происходит внутри, подчиняется нашим правилам, то есть либо стоит аксиома, либо получается по моду спонс. А как проверить, что какая формула аксиома или полученная из двух других по моду спонс?
[43:32.240 --> 43:55.240]  А для этого все, что нам нужно, это разбор формул. Вот если мы можем формулу приставить в виде дерева, как я рисовал, то есть разобрать, указать какая связка там первая, применяется потомков тоже какая первая и так далее, то дальше проверка, что формула удовлетворяет схеме аксиом или проверка, что формула получается по моду спонсу, тоже сводится к тому, что мы проверяем просто равенство конкретных двоичных слов.
[43:55.240 --> 44:18.240]  С проверкой равенства двоичных слов проблем нет, а чтобы разобрать формулу, ну, проблемы есть, но не очень сложные. Фактически, за счет того, что я специально определял формулы так, чтобы там были правильные скобочные выражения, по сути дела вам нужно проверять, разбирать скобочные выражения, то есть находить вот эту скобочную структуру, и тогда вы можете сказать, какая операция применяется последней.
[44:18.240 --> 44:34.240]  Про правильные скобочные выражения вам, может быть, уже на тряпе и объяснили. Это частный пример контекстно-свободного грамматика. Было уже или еще не было? Дошли вы до контекстно-свободного грамматика? А, еще нет. Ну, значит, будет.
[44:34.240 --> 44:48.240]  Но, в общем, это несложно. На самом деле, конкретно со скобочными выражениями я подозреваю, что многие знают, как их разбирать. Ну, я очень коротко скажу, нужно скобочный итог считать. Скобочный итог – это разность между количеством открывающих и закрывающих скобок.
[44:48.240 --> 45:05.240]  Ну и вот правильное скобочное выражение обладает таким замечательным свойством, что скобочный итог в конце ноль, а в каждой промежуточной позиции не отрицательный. Ну и тогда, если вы знаете это правило, очень легко понять, где там в формуле стоит последняя связка.
[45:05.240 --> 45:19.240]  В общем, я пропускаю детали. Ну, а подсчет скобочного итога – это тоже очень эффективное действие. То есть исчислению высказываний отвечает такой алгоритм.
[45:19.240 --> 45:43.240]  Но каким еще свойством должен обладать этот алгоритм? Если формула тавтология, ну, точнее, строка, кодирующая тавтологию, то существует доказательство для этой тавтологии. То есть алгоритм на такой паре F и P дает единицу.
[45:43.240 --> 46:04.240]  Это то, что я называл полнотой. Для любой тавтологии есть вывод. Ну а третья – это корректность. Если F не тавтология, то для любого второго аргумента алгоритм дает ноль.
[46:04.240 --> 46:19.240]  То есть алгоритм – это такой судья или, если угодно, преподаватель. Значит, студенту дается вопрос, является ли формула тавтологии.
[46:19.240 --> 46:31.240]  Студент пишет решение. Это вот второй аргумент. Если это формула тавтологии, нужно, чтобы было правильное решение. Если нет тавтологии, то преподаватель отвергнет любое решение.
[46:31.240 --> 46:43.240]  Вот этого на самом деле нам и хочется, по сути дела. То есть то, что мы так вот modus ponens используем, это следы от классической логики.
[46:43.240 --> 46:50.240]  А в современном мире, если у нас есть вот такая система, доказательство, то есть такой алгоритм, то это ничуть не хуже, чем классическая логика.
[46:50.240 --> 46:58.240]  Будем мы использовать компьютеры для того, чтобы для длинных формул запускать этот алгоритм. Руками может быть этот алгоритм запустить сложно.
[46:58.240 --> 47:07.240]  Будем использовать компьютеры. Ну и что, мы их и так используем. Нужно, конечно, проверять корректность программ, которые выполняют этот алгоритм.
[47:07.240 --> 47:20.240]  Ну это все-таки одна и единственная программа. Один и единственный раз можно потратить силы, написать, в конце концов, на коке, где, так сказать, вы пишете программу, которая одновременно с доказательством ее корректности.
[47:20.240 --> 47:32.240]  В общем, есть способы добиться твердой уверенности, что программа работает правильно. Надо постараться просто. Это отдельная проблема, относящаяся скорее к программированию.
[47:32.240 --> 47:51.240]  А в остальном ничем не хуже. И вот можно сказать, что такой алгоритм тоже задает некоторую формальную систему. Там даже непонятно, что у нас есть доказательства, оно не обязательно разбивается на какие-то шаги.
[47:51.240 --> 47:58.240]  Так часто бывает, что оно разбивается на какие-то шаги. Но может быть и никаких шагов. Там может быть совершенно другая структура.
[47:58.240 --> 48:11.240]  Вообще, для тавтологии таких систем доказательств известно много. Исчисление высказываний одно из самых сильных. В том смысле, что доказательства самые короткие.
[48:11.240 --> 48:26.240]  Ну то есть, если уж есть доказательства, нас еще может интересовать доказательства покороче. Само доказательство может быть намного длиннее, чем формула. Это не противоречит нашему определению.
[48:26.240 --> 48:36.240]  Мы считаем работу алгоритма по общей длине входа. Но тем не менее, в разных системах доказательств длины, доказательств разные.
[48:36.240 --> 48:46.240]  Скажем, очень легко из табличного метода тоже получить систему доказательств. Ну вот просто вы записываете формулу, а дальше пишете вычисления всех этих строчек таблицы.
[48:46.240 --> 49:00.240]  Это тоже система доказательств. Потому что проверить эти вычисления, ясное дело, легко, если вы уже все написали. Но она для любой формулы будет иметь длину не меньше, чем 2 в степени n, где n количество переменных формул.
[49:00.240 --> 49:09.240]  И это много. А есть более экономные системы доказательств. Вот исчисление высказываний, как я говорил, одна из самых экономных.
[49:09.240 --> 49:17.240]  Сейчас уже даже нельзя сказать, что самые экономные, потому что ее там научились сращивать с другими довольно мощными системами.
[49:17.240 --> 49:29.240]  Идеи в этих системах доказательств очень разные. И я хочу рассказать, сегодня и в следующий раз, я хочу рассказать об одной из таких систем, доказательств.
[49:29.240 --> 49:40.240]  Почему о ней? Вот если исчисление высказываний было выбрано, потому что, во-первых, все доказательства получаются достаточно короткими, и оно имеет ясные связи с классической логикой,
[49:40.240 --> 49:52.240]  то вторую систему доказательств, которую я хочу рассказать, это тоже будет формальная система, я даже ее назову исчисления тоже. Она важна с точки зрения практики.
[49:52.240 --> 50:02.240]  На самом деле, вот эта система, которую я буду рассказывать, она сидит, значит, проверки тавтологии, она практически важная.
[50:02.240 --> 50:11.240]  И есть куча программ, которые это делают. И вот практически все эффективные программы, они содержат вот эту часть, и эта часть, на самом деле, основной мотор.
[50:11.240 --> 50:17.240]  То есть хорошие программы содержат еще много чего, но я в следующий раз прокомментирую это, может быть, более подробно.
[50:17.240 --> 50:29.240]  Но это оказалась некоторая очень важная вещь. И, собственно, люди придумали эту систему уже в конце 50-х годов прошлого века, когда появились компьютеры.
[50:29.240 --> 50:32.240]  Система основана на так называемом правиле резолюции.
[50:47.240 --> 50:57.240]  Ну ладно, я пишу какие-то, может быть, не самые удачные буквы, это все неважно.
[50:57.240 --> 51:07.240]  Значит, смотрите, если у нас есть формулы A или не B, и формула C или B, то мы можем вывести формулу A или C.
[51:07.240 --> 51:10.240]  Это называется резолюция.
[51:10.240 --> 51:16.240]  Ну, прежде всего, конечно, важно понять, что это корректно.
[51:16.240 --> 51:22.240]  Корректность я проверю так. Я докажу, что семантически, если вот это истина, то это тоже истина.
[51:22.240 --> 51:30.240]  Что нам нужно для доказательства корректности? В точности вот такое утверждение, что семантически следует.
[51:30.240 --> 51:36.240]  Ну а как доказать, что семантически следует? Да очень просто.
[51:36.240 --> 51:41.240]  Смотрите, ну я уже стер, к сожалению. Что такое семантическое исследование?
[51:41.240 --> 51:47.240]  Если вот есть выполняющий набор для этих формул, то тогда на нем эта формула равна 1.
[51:47.240 --> 51:53.240]  Другими словами, если эта формула равна 0, контрпозиция, то тогда хотя бы одна из этих двух формул равна 0.
[51:53.240 --> 52:01.240]  Ну давайте представим, что X или Z равна 0. Что это означает? Мы знаем, что это означает, что X равен 0 и Z равен 0.
[52:01.240 --> 52:08.240]  Но если X равен 0, то отсюда мы получаем сразу такие вещи.
[52:08.240 --> 52:19.240]  X или Y равен не Y, а Z или Y равен Y, потому что X и Z равны 0.
[52:19.240 --> 52:25.240]  Ну и смотрите, у нас получается, что одна формула совпадает со значением Y, а другая с отрицанием Y.
[52:25.240 --> 52:29.240]  Они обе единицы равняться никак не могут. Какая-то должна равняться 0.
[52:29.240 --> 52:39.240]  Значит, если на каком-то наборе значений переменных X или Z обращается в 0, тогда и вот одна из пар в резолюции тоже обращается в 0.
[52:39.240 --> 52:45.240]  Но это, другими словами, если здесь обе эти формулы равны единице, эта формула тоже равна единице.
[52:45.240 --> 52:49.240]  Тут, как видите, ничего сложного. Вопрос в том, как применять это правило.
[52:49.240 --> 52:55.240]  Оно уже, заметьте, не выглядит как часть логического рассуждения в классической математике.
[52:55.240 --> 53:05.240]  Мы, конечно, можем так рассуждать. Такие рассуждения в жизни бывают, что мы доказали так и сяк, а потом вывели то, что хотели.
[53:05.240 --> 53:13.240]  Этому можно придать самый разный смысл, в том числе и более-менее понятный с логической точки зрения.
[53:13.240 --> 53:24.240]  Но тем не менее, чтобы применять такое правило, мы уже видим, что оно очень хорошо применяется к формулам, которые состоят из дизьюнции чего-то там достаточно простого.
[53:24.240 --> 53:39.240]  И на самом деле мы будем применять резолюцию к тому, что называется KNF.
[53:39.240 --> 54:03.240]  Конъюнкция дизьюнции литерала. Я надеюсь, что вас в прошлом году уже учили этим словам.
[54:03.240 --> 54:12.240]  Тем не менее, я напомню, что вот это вот называется дизьюнктом. То есть формула, которая является дизьюнцией литерала, называется дизьюнктом.
[54:12.240 --> 54:29.240]  Литерал – это переменная или отрицание.
[54:29.240 --> 54:38.240]  Тут я написал конъюнцию, но можно считать, что у нас просто задано множество. Я в следующий раз это подробнее обсужу.
[54:38.240 --> 55:00.240]  Давайте рассмотрим какой-нибудь простой пример. Допустим, мы хотим доказать, что такое множество дизьюнктов не совместно.
[55:01.240 --> 55:10.240]  Тут еще один важный момент. Резолюциями мы будем не доказывать, не писать доказательства какой-то формулы, а строить опровержение.
[55:10.240 --> 55:15.240]  Мы будем доказывать, что какие-то формулы невыполнимы, то есть всегда равны нулю.
[55:15.240 --> 55:24.240]  Но невыполнимость формулы равносильно к автологичности ее отрицания.
[55:24.240 --> 55:31.240]  Если формула невыполнимая, значит она на каждом наборе переменных равна нулю, значит ее отрицание на каждом наборе переменных равно единице.
[55:31.240 --> 55:39.240]  То есть это логически равносильные условия, поэтому проверка невыполнимости, проверка тавтологичности – это задачи тесно связанные.
[55:39.240 --> 55:44.240]  В следующем семестре вам объяснят тонкую разницу между ними, я сейчас на это не буду тратить время.
[55:44.240 --> 55:54.240]  Ну и фактически опровержение состоит в том, что мы доказываем, что какой-то набор формул несовместный.
[55:54.240 --> 56:00.240]  Вы уже видели из доказательства полноты, что мы скорее всего сводим к проверке несовместности.
[56:00.240 --> 56:03.240]  Ну и как это сделать с помощью резолюции? Очень просто.
[56:03.240 --> 56:15.240]  Смотрите, я беру вот эту пару формул и вывожу из нее формулу А. Ну А или А формально, если смотреть на правила резолюции.
[56:15.240 --> 56:26.240]  Но мы в методе резолюции знаем, что А равносильно А или А. То есть мы лишних не пишем литералов в дизюнкте.
[56:26.240 --> 56:39.240]  Хорошо, берем не А или Б, не А или не Б. Выводим по правилу резолюции точно также не А.
[56:39.240 --> 56:52.240]  А теперь смотрите, у меня есть А и не А. К этой паре тоже можно применить резолюции.
[56:52.240 --> 56:57.240]  Ну у нас формально там вроде бы как должно быть две члена, а тут всего по одному.
[56:57.240 --> 57:04.240]  Но мы мысленно допишем дизюнцию с ложью. Вот такой вот значенка перпендикулярной логики так обозначают ложь.
[57:04.240 --> 57:09.240]  Ясно, что А и А или ложь – это равносильные утверждения.
[57:09.240 --> 57:14.240]  Это я написал, чтобы соответствовало нашему формату правила резолюции.
[57:15.240 --> 57:22.240]  И мы выводим ложь. То есть получается так, что мы знаем корректность, я уже проверил корректность.
[57:22.240 --> 57:29.240]  Все, что мы выводим резолюциями, если вот эти вот формулы истины, то на таком наборе значений переменных истина и все, что мы выводим.
[57:29.240 --> 57:35.240]  А ложь ложна всегда. То есть если мы вывели ложь, это означает, что выполняющего набора просто нет.
[57:36.240 --> 57:40.240]  Вот основная идея метода резолюции.
[57:40.240 --> 57:47.240]  Возникает много трудностей. Не трудностей, а мы только начали, это основная идея.
[57:47.240 --> 57:50.240]  Надо разбираться, что делать дальше.
[57:50.240 --> 57:56.240]  И сегодня я попробую покрыть одну из этих проблем.
[57:56.240 --> 58:10.240]  Во-первых, неясно, в каких случаях мы можем получить ложь, в каких не можем. Это все в следующий раз будем обсуждать.
[58:10.240 --> 58:14.240]  Но есть другая принципиальная трудность, которую, может быть, вы уже заметили.
[58:14.240 --> 58:20.240]  Я хочу систему доказательств для произвольных формул. То есть проверка тавтологии любой формы.
[58:20.240 --> 58:24.240]  А здесь у меня есть КНФ, и я проверяю ее невыполнимость.
[58:24.240 --> 58:29.240]  Другими словами, я проверяю, если я возьму отрицание КНФ, то это получится что?
[58:29.240 --> 58:33.240]  По законам Деморгана, конъюнция перейдет в дизюнцию, конъюнция.
[58:33.240 --> 58:37.240]  То есть получится ДНФ, дизюнктивная нормальная форма.
[58:37.240 --> 58:47.240]  То есть я фактически буду строить систему, которая будет проверять тавтологичность ДНФ.
[58:47.240 --> 58:52.240]  Но ДНФ – это не все формулы. Надо что-то про остальные формулы сказать, что-то с ними сделать.
[58:52.240 --> 58:54.240]  Вот это, я надеюсь, сегодня объяснить.
[58:54.240 --> 58:57.240]  И в следующий раз уже к этому возвращаться не буду.
[58:57.240 --> 59:02.240]  То есть я даже не буду переходить к ДНФ, я буду именно на языке КНФ.
[59:02.240 --> 59:05.240]  То есть мне хочется проверять невыполнимость формул.
[59:05.240 --> 59:14.240]  Ясно, что если мне нужно проверять тавтологичность, я просто напишу отрицание формулы и сведу вопрос к проверке невыполнимости.
[59:14.240 --> 59:20.240]  Давайте вспоминать, чему вас учили в прошлом году.
[59:20.240 --> 59:24.240]  Учили ли вас, что любая булева функция представляется КНФ?
[59:24.240 --> 59:30.240]  Про ДНФ я надеюсь точно учили, но про КНФ там двойственно.
[59:30.240 --> 59:32.240]  Я сейчас напишу формулу.
[59:32.240 --> 59:53.240]  Если у меня есть булева функция, то ее можно представить так, как конъюнцию по всем наборам, на которых эта функция равна нулю, дизюнции вот таких вот литералов.
[59:53.240 --> 01:00:04.240]  Обычное обозначение, х в первой степени х, х в нулевой степени отрицания х.
[01:00:04.240 --> 01:00:14.240]  Вот такой дизюнкт равен нулю только когда каждый из его членов равен нулю, и это бывает только на наборе альфа.
[01:00:14.240 --> 01:00:18.240]  Тут все переменные входят от единицы до Н.
[01:00:19.240 --> 01:00:28.240]  Ну и дальше уже легко проверить, что поскольку я беру конъюнцию по всем нулям функции, то получаю в точности эту функцию.
[01:00:28.240 --> 01:00:38.240]  Таким образом, казалось бы, вопроса нет. У нас есть формула, есть соответствует какая-то булева функция, давайте эту булевую функцию представим в виде КНФ.
[01:00:38.240 --> 01:00:44.240]  Но проблема есть. Посмотрите в каком контексте мы все это делаем. Мы хотим какую-то разумную систему доказательств.
[01:00:44.240 --> 01:00:49.240]  А если мы будем делать так, то как правило нулею функ
[01:00:49.240 --> 01:00:53.240]  функций очень много, экспоненциально много. И вот эта КНФ будет очень длинной.
[01:00:53.240 --> 01:01:01.240]  Система доказательств получится. У нас и табличная система доказательств есть, но она получится такой, что более-менее для любой формулы ничего хорошего мы не получим.
[01:01:01.240 --> 01:01:04.240]  Мы получим только очень длинные доказательства.
[01:01:04.240 --> 01:01:13.240]  А нас, конечно, это неформально, это в определении системы доказательств не фиксируется, это такой показатель того, насколько система доказательств хороша.
[01:01:13.240 --> 01:01:15.240]  Нас, конечно, интересует длина выводов.
[01:01:15.240 --> 01:01:24.240]  Например, важный открытый вопрос, одна из центральных проблем теоретической информатики, есть ли система доказательств в том смысле, в котором я написал,
[01:01:24.240 --> 01:01:31.240]  в которой для каждой тавтологии есть вывод полиномиального размера, полиномиального длины формулы.
[01:01:31.240 --> 01:01:34.240]  Ответ неизвестен.
[01:01:34.240 --> 01:01:39.240]  Люди предполагают, что нет, но никто этого не знает.
[01:01:39.240 --> 01:01:48.240]  Никто не знает даже про наше исчисление высказываний, верно ли, что существуют формулы, для которых длина вывода больше, чем полиномы.
[01:01:48.240 --> 01:01:52.240]  Я вам в качестве бонусной задачи предложил намного более простую.
[01:01:52.240 --> 01:01:56.240]  Существуют формулы, для которых длина вывода не константа.
[01:01:56.240 --> 01:02:00.240]  Это люди умеют делать, но не сильно больше.
[01:02:00.240 --> 01:02:10.240]  То есть, если на самом деле вы чуть-чуть, любое решение этой задачи, если оно дает сверхконстантную оценку, там какая-то функция, растущая длины формулы,
[01:02:10.240 --> 01:02:15.240]  она очень медленно будет расти, на самом деле сильно лучше люди делать не умеют.
[01:02:15.240 --> 01:02:21.240]  Наверное, получше можно, но это настолько плохие оценки, что никто ими не заморачивается.
[01:02:21.240 --> 01:02:23.240]  Вопрос открыт.
[01:02:23.240 --> 01:02:25.240]  Но для нас это проблема.
[01:02:25.240 --> 01:02:32.240]  Значит, мы не можем так просто взять и перейти к вот этой, как говорят, совершенной КНФ.
[01:02:32.240 --> 01:02:35.240]  Она слишком длинная.
[01:02:35.240 --> 01:02:43.240]  Мы хотим сделать такой переход, чтобы по формуле мы написали КНФ, длина которой не очень сильно отличается от длины формулы.
[01:02:43.240 --> 01:02:45.240]  И вот тут проблема.
[01:02:45.240 --> 01:02:49.240]  Равносильную такую КНФ можно задать далеко не всегда.
[01:02:49.240 --> 01:02:53.240]  Это легко построить примеры, я не буду опять-таки на этом останавливаться.
[01:02:53.240 --> 01:02:58.240]  Есть примеры, когда ничего лучше, чем совершенная КНФ, нет.
[01:03:03.240 --> 01:03:04.240]  Так что же делать?
[01:03:04.240 --> 01:03:06.240]  А делать нужно вот что.
[01:03:06.240 --> 01:03:10.240]  Давайте вспомним, что нас интересуют вопросы выполнимости или невыполнимости формы.
[01:03:10.240 --> 01:03:13.240]  Нам не нужно КНФ, которая равносильна нашей форме.
[01:03:13.240 --> 01:03:15.240]  Это очень важная идея.
[01:03:15.240 --> 01:03:17.240]  В той части курса я ее тоже буду использовать.
[01:03:17.240 --> 01:03:19.240]  Ее вот очень важно прям сейчас осознать.
[01:03:19.240 --> 01:03:32.240]  Нам достаточно, если у меня есть формула А, достаточно построить КНФ по этой формуле.
[01:03:32.240 --> 01:03:42.240]  Такую, что выполнимость формулы равносильно выполнимость этой КНФ.
[01:03:45.240 --> 01:04:00.240]  То есть, мы не обязаны, вот эта формула не обязана быть равносильной, задавать ту же самую булливую функцию.
[01:04:00.240 --> 01:04:03.240]  Как мы увидим, в ней даже будет другое количество переменных.
[01:04:03.240 --> 01:04:05.240]  И это тоже не возражает.
[01:04:05.240 --> 01:04:09.240]  Единственное, что нам нужно, чтобы была эффективная процедура, как мы строим эту КНФ,
[01:04:09.240 --> 01:04:13.240]  потому что у нас все должно быть эффективно в системе доказательств.
[01:04:13.240 --> 01:04:21.240]  Ну и, в частности, длина этой КНФ должна быть не очень большим.
[01:04:21.240 --> 01:04:24.240]  Вот это я как раз сегодня, у меня еще 10 минут.
[01:04:24.240 --> 01:04:28.240]  И вот это я как раз хотел бы успеть рассказать.
[01:04:28.240 --> 01:04:32.240]  То есть, я надеюсь, что понятно, какую проблему я решаю.
[01:04:32.240 --> 01:04:36.240]  Я хочу по произвольной булливой формуле построить КНФ.
[01:04:36.240 --> 01:04:41.240]  Такую, что выполнимость формулы равносильно выполнимость этой КНФ.
[01:04:41.240 --> 01:04:44.240]  Процедура должна быть достаточно эффективной.
[01:04:44.240 --> 01:04:51.240]  Ну и, в частности, длина КНФ не должна быть сильно больше длины формулы.
[01:04:51.240 --> 01:04:53.240]  Сейчас я это проделаю.
[01:04:54.240 --> 01:04:58.240]  И для этого мне потребуется разбор формулы.
[01:04:59.240 --> 01:05:02.240]  Чтобы было понятно доказательство, я прямо сразу
[01:05:02.240 --> 01:05:09.240]  напишу дерево разбора.
[01:05:09.240 --> 01:05:12.240]  В конце у нас какие-то переменные тут сидят.
[01:05:12.240 --> 01:05:16.240]  А тут, в этом дереве, сидят наши связки.
[01:05:16.240 --> 01:05:19.240]  Можно доказывать и для формул с другими связками.
[01:05:19.240 --> 01:05:21.240]  Рассуждение совершенно аналогичное.
[01:05:21.240 --> 01:05:24.240]  То есть, то, что я сейчас говорю, верно для формулы,
[01:05:24.240 --> 01:05:27.240]  которая использует любое конечное количество связок.
[01:05:27.240 --> 01:05:34.240]  То есть, для простоты, чтобы меньше писать случаев,
[01:05:34.240 --> 01:05:36.240]  я буду писать только отрицание и импликацию.
[01:05:36.240 --> 01:05:38.240]  Если добавить дизюнцию и конюнцию, там вы сейчас увидите,
[01:05:38.240 --> 01:05:40.240]  в каком месте нужно добавить.
[01:05:40.240 --> 01:05:42.240]  Абсолютно ничего в рассуждении не меняется.
[01:05:44.240 --> 01:05:45.240]  Ну раз у нас есть дерево.
[01:05:45.240 --> 01:05:48.240]  Смотрите, вот листям приписаны переменные.
[01:05:48.240 --> 01:05:53.240]  А внутренним вершинам пока еще никаких переменных не приписано.
[01:05:53.240 --> 01:05:56.240]  Но каждая внутренняя вершина задает некоторую подформулу,
[01:05:56.240 --> 01:05:58.240]  которую я буду обозначать B.
[01:05:58.240 --> 01:06:00.240]  То есть, вот это вот все, это формула A.
[01:06:02.240 --> 01:06:06.240]  И вот каждой внутренней вершине я сопоставлю новую переменную.
[01:06:06.240 --> 01:06:08.240]  Вот я ее обозначаю ZA, ZB.
[01:06:08.240 --> 01:06:11.240]  То есть, каждой внутренней вершине дерева разбора формулы
[01:06:11.240 --> 01:06:13.240]  я сопоставляю новую переменную.
[01:06:16.240 --> 01:06:18.240]  А ясно, что этих переменных не очень много,
[01:06:18.240 --> 01:06:27.240]  потому что количество вершин в дереве разбора,
[01:06:27.240 --> 01:06:30.240]  но оно линейно ограничено длиной формулы.
[01:06:30.240 --> 01:06:32.240]  Тут совершенно понятно.
[01:06:32.240 --> 01:06:34.240]  Что я делаю дальше?
[01:06:34.240 --> 01:06:36.240]  Дальше я делаю вот что.
[01:06:36.240 --> 01:06:40.240]  Я строю вот эту КНФ так.
[01:06:40.240 --> 01:06:42.240]  Так, я пишу
[01:06:58.240 --> 01:06:59.240]  конъюнцию.
[01:06:59.240 --> 01:07:01.240]  Значит, там будет...
[01:07:01.240 --> 01:07:03.240]  Один дизюнк будет состоять только из переменной,
[01:07:03.240 --> 01:07:05.240]  вспоминания, отвечающей всей формуле.
[01:07:05.240 --> 01:07:07.240]  Переменная за циндексом A.
[01:07:07.240 --> 01:07:09.240]  А дальше будет конъюнция.
[01:07:09.240 --> 01:07:11.240]  Ну, давайте я как-нибудь напишу
[01:07:15.240 --> 01:07:18.240]  D, B, какое-нибудь обозначение.
[01:07:18.240 --> 01:07:23.240]  То есть, у меня будет каждой внутренней вершине дерева разбора
[01:07:23.240 --> 01:07:28.240]  будет отвечать своя КНФ.
[01:07:28.240 --> 01:07:30.240]  Вот это вот КНФ.
[01:07:30.240 --> 01:07:32.240]  Тут все-таки лучше я напишу какую-то другую букву.
[01:07:32.240 --> 01:07:34.240]  Ну, пусть будет K.
[01:07:34.240 --> 01:07:36.240]  D как-то на дизюнк слишком похоже.
[01:07:36.240 --> 01:07:38.240]  Там КНФ будет.
[01:07:38.240 --> 01:07:40.240]  Не один дизюнк.
[01:07:42.240 --> 01:07:44.240]  Как это выглядит?
[01:07:44.240 --> 01:07:46.240]  Правило очень простое.
[01:07:46.240 --> 01:07:48.240]  Вот представьте, что я хочу
[01:07:48.240 --> 01:07:52.240]  для вершины B, которая является импликацией.
[01:07:52.240 --> 01:07:54.240]  Чего-то там.
[01:07:54.240 --> 01:07:57.240]  Тут у меня вершина C.
[01:07:57.240 --> 01:07:59.240]  Тут у меня вот C уже было.
[01:07:59.240 --> 01:08:01.240]  Пусть будет...
[01:08:01.240 --> 01:08:03.240]  Ну, пусть будет X и Y.
[01:08:03.240 --> 01:08:05.240]  Неважно как я это назову.
[01:08:05.240 --> 01:08:07.240]  Неважно какие здесь связки.
[01:08:07.240 --> 01:08:10.240]  Вот переменная ZX, ZY.
[01:08:12.240 --> 01:08:15.240]  Как будет устроена вот эта вот КБ?
[01:08:17.240 --> 01:08:23.240]  Это КНФ, которая равносильна такой формуле.
[01:08:23.240 --> 01:08:25.240]  Функции, задаваемые такой формулой.
[01:08:25.240 --> 01:08:28.240]  Z beta
[01:08:28.240 --> 01:08:31.240]  равносильно
[01:08:31.240 --> 01:08:36.240]  импликации ZX, ZY.
[01:08:36.240 --> 01:08:39.240]  Написано довольно сложно, но понятно, что это такое.
[01:08:39.240 --> 01:08:42.240]  Что означает это логическое условие?
[01:08:42.240 --> 01:08:47.240]  Оно означает, что значения в этих трех узлах дерева
[01:08:47.240 --> 01:08:50.240]  связаны очень просто.
[01:08:50.240 --> 01:08:53.240]  Значение в верхнем узле является импликацией значения нижнего.
[01:08:53.240 --> 01:08:55.240]  Потому что эквивалентность это равенство.
[01:08:55.240 --> 01:08:57.240]  То есть вот это логическое условие говорит,
[01:08:57.240 --> 01:09:01.240]  что ZB это импликация нижних значений.
[01:09:01.240 --> 01:09:04.240]  Тут могут быть не обязательно вспомогательные переменные.
[01:09:04.240 --> 01:09:06.240]  Могут быть и основные переменные X,
[01:09:06.240 --> 01:09:08.240]  и тогда надо написать просто основную перемену.
[01:09:08.240 --> 01:09:12.240]  Ну и с отрицанием очень похоже, еще проще.
[01:09:12.240 --> 01:09:15.240]  Потому что у нас один потомок.
[01:09:15.240 --> 01:09:18.240]  Мы должны просто написать формулу,
[01:09:18.240 --> 01:09:25.240]  которая равносильна ZB, равносильна отрицанию ZX.
[01:09:25.240 --> 01:09:26.240]  Что мы выиграли?
[01:09:26.240 --> 01:09:28.240]  Смотрите, вот эти вот формулы имеют конечный размер.
[01:09:28.240 --> 01:09:31.240]  Тут две переменные, тут три переменные.
[01:09:31.240 --> 01:09:34.240]  Если я для них напишу совершенную KNF,
[01:09:34.240 --> 01:09:37.240]  там будет заведывание больше 8 дизъюнктов.
[01:09:37.240 --> 01:09:40.240]  На самом деле верхней формуле будет 4 дизъюнкта.
[01:09:40.240 --> 01:09:43.240]  Это легко проверить, сколько там нулей.
[01:09:43.240 --> 01:09:45.240]  Нижнее того меньше.
[01:09:45.240 --> 01:09:49.240]  То есть у нас вот эти вот KNF имеют константный размер.
[01:09:49.240 --> 01:09:53.240]  То есть вот здесь у нас появляются какие-то дизъюнкты,
[01:09:53.240 --> 01:09:55.240]  но в небольшом количестве.
[01:09:55.240 --> 01:09:59.240]  Их количество не более чем 8 раз больше,
[01:09:59.240 --> 01:10:02.240]  чем количество внутренних узлов дерева.
[01:10:02.240 --> 01:10:04.240]  Поэтому вся формула очень компактная.
[01:10:04.240 --> 01:10:08.240]  И, я думаю, понятно, что такое построение
[01:10:08.240 --> 01:10:10.240]  резуется эффективным алгоритмом.
[01:10:10.240 --> 01:10:12.240]  Если вы уж построили дерево разбора,
[01:10:12.240 --> 01:10:14.240]  то дальше вот все остальное делается автоматически.
[01:10:14.240 --> 01:10:17.240]  Ну, выписать для конкретной функции из трех переменов,
[01:10:17.240 --> 01:10:21.240]  вы можете просто сразу выписать эту совершенную KNF.
[01:10:21.240 --> 01:10:23.240]  Это прямо в код ее вогнать.
[01:10:23.240 --> 01:10:25.240]  Не надо, чтобы это делал алгоритм.
[01:10:25.240 --> 01:10:27.240]  Тут никакой сложности нет.
[01:10:27.240 --> 01:10:30.240]  Все, что осталось, это доказать вот это утверждение.
[01:10:32.240 --> 01:10:34.240]  Но оно практически очевидно.
[01:10:34.240 --> 01:10:36.240]  Потому что вспомните, как мы определяли значение формулы.
[01:10:36.240 --> 01:10:39.240]  Мы вычисляли его по этому дереву разбора.
[01:10:39.240 --> 01:10:43.240]  И все, что нам теперь нужно доказать индукцией
[01:10:43.240 --> 01:10:46.240]  по разбору формулы, это такое утверждение,
[01:10:46.240 --> 01:10:48.240]  что предположим, что формула выполнима.
[01:10:48.240 --> 01:10:52.240]  То есть на каком-то наборе значений переменных
[01:10:52.240 --> 01:10:54.240]  она равна единице.
[01:10:54.240 --> 01:10:59.240]  Давайте тогда припишем с помогательным переменным
[01:11:01.240 --> 01:11:05.240]  значения, которые задаются на вот этом вот наборе.
[01:11:08.240 --> 01:11:13.240]  И KNF на таком наборе будет истина.
[01:11:17.240 --> 01:11:19.240]  Почему?
[01:11:19.240 --> 01:11:21.240]  Ну, потому что, смотрите,
[01:11:22.240 --> 01:11:26.240]  вот это и есть правило вычисления,
[01:11:26.240 --> 01:11:30.240]  индуктивного вычисления значения формулы по дереву.
[01:11:30.240 --> 01:11:32.240]  Переменным присвоили какие-то значения.
[01:11:32.240 --> 01:11:34.240]  Вот из этого набора альфа.
[01:11:34.240 --> 01:11:36.240]  Дальше, если у меня есть какой-то внутренний узел,
[01:11:36.240 --> 01:11:38.240]  я вычисляю по связке.
[01:11:38.240 --> 01:11:40.240]  И это в точности значение.
[01:11:40.240 --> 01:11:44.240]  Мы видим, что это значение в точности соответствует.
[01:11:44.240 --> 01:11:47.240]  Ну, и для каждого узла у нас своя формула.
[01:11:47.240 --> 01:11:50.240]  Все вместе, это нужно, конечно, аккуратно написать индукцию
[01:11:50.240 --> 01:11:53.240]  по разбору формулы, но это совершенно несложно сделать.
[01:11:53.240 --> 01:11:55.240]  У нас получится то, что нужно.
[01:11:55.240 --> 01:11:57.240]  Теперь в обратную сторону.
[01:11:57.240 --> 01:11:59.240]  Предположим, что вот это выполнимо.
[01:11:59.240 --> 01:12:03.240]  То есть, у нас есть какой-то набор значений переменных,
[01:12:06.240 --> 01:12:09.240]  альфа основных переменных и бета вспомогательных переменных,
[01:12:09.240 --> 01:12:11.240]  на которых KNF равна единице.
[01:12:11.240 --> 01:12:13.240]  Что это означает?
[01:12:13.240 --> 01:12:15.240]  Мы должны теперь доказать другую сторону.
[01:12:15.240 --> 01:12:17.240]  Это означает следующее, что
[01:12:17.240 --> 01:12:23.240]  я хочу доказать, что формула А только на альфа будет истинной.
[01:12:23.240 --> 01:12:25.240]  И доказательство очень простое.
[01:12:25.240 --> 01:12:28.240]  Мне нужно по индукции проверить такое же равенство,
[01:12:30.240 --> 01:12:39.240]  что z бета от бета – это в точности значение под формулы альфа.
[01:12:39.240 --> 01:12:43.240]  Ну, и по построению моей KNF это достаточно очевидно.
[01:12:43.240 --> 01:12:46.240]  Вот эта вспомогательная KNF, которая отвечает внутреннему узлу,
[01:12:46.240 --> 01:12:48.240]  она вообще равна единице,
[01:12:48.240 --> 01:12:52.240]  если у нас правильно определено значение в верхний узел,
[01:12:52.240 --> 01:12:54.240]  переменную, отвечающую верхнему узлу,
[01:12:54.240 --> 01:12:58.240]  мы помещаем результат применения связки к значениям, которые получены ниже.
[01:12:58.240 --> 01:13:01.240]  Ну, значит, по индукции будет вот это равенство сохраняться,
[01:13:01.240 --> 01:13:03.240]  и так оно поднимется до самого верха.
[01:13:03.240 --> 01:13:05.240]  Вот и все.
[01:13:05.240 --> 01:13:08.240]  На этом доказательство, по сути дела, закончено.
[01:13:08.240 --> 01:13:11.240]  Я пропускаю вот эти вот технические детали аккуратные,
[01:13:11.240 --> 01:13:16.240]  запись рассуждения по индукции, но она достаточно очевидна.
[01:13:16.240 --> 01:13:20.240]  То есть основная идея – понятно, что мы следим за выполнением…
[01:13:20.240 --> 01:13:22.240]  То есть как мы вычисляем значение формулы?
[01:13:22.240 --> 01:13:24.240]  Мы вычисляем индуктивно.
[01:13:24.240 --> 01:13:28.240]  Если за одно из значений переменных мы берем внутренний узел,
[01:13:28.240 --> 01:13:30.240]  который зависит только от переменных,
[01:13:30.240 --> 01:13:33.240]  вычисляем в нем значение в соответствии с этой связкой и продолжаем.
[01:13:33.240 --> 01:13:37.240]  Но раз мы вычисляем значение в соответствии с этой связкой,
[01:13:37.240 --> 01:13:39.240]  это фиксируется вот таким вот условием,
[01:13:39.240 --> 01:13:42.240]  что значение вспомогательной переменной в верхнем узле
[01:13:42.240 --> 01:13:45.240]  равно значению связки от значений в нижних узлах.
[01:13:45.240 --> 01:13:48.240]  Если мы добились выполнения всех этих условий,
[01:13:48.240 --> 01:13:50.240]  конечно, мы все посчитали правильно.
[01:13:54.240 --> 01:13:56.240]  Таким образом, я хочу зафиксировать,
[01:13:56.240 --> 01:13:59.240]  чтобы в следующий раз особо на это время не тратить.
[01:14:01.240 --> 01:14:03.240]  Мы убедились, что у нас…
[01:14:03.240 --> 01:14:05.240]  Я напомню, что наша система доказательств
[01:14:05.240 --> 01:14:08.240]  может содержать какие-то алгоритмические действия произвольного характера.
[01:14:08.240 --> 01:14:10.240]  Наша система доказательств
[01:14:10.240 --> 01:14:13.240]  к автологичности какой-то формулы будет устроена так.
[01:14:13.240 --> 01:14:16.240]  Мы, прежде всего, приписываем к формуле отрицания.
[01:14:16.240 --> 01:14:18.240]  Это очень эффективная процедура.
[01:14:18.240 --> 01:14:20.240]  То есть, если у вас есть формула,
[01:14:20.240 --> 01:14:23.240]  ну что там, просто три значка написать вокруг нее.
[01:14:23.240 --> 01:14:26.240]  Дальше для этой формулы мы делаем разбор,
[01:14:26.240 --> 01:14:28.240]  строим вот эту вот КНФ,
[01:14:28.240 --> 01:14:32.240]  а на полученную КНФ мы уже запускаем некоторую другую формальную систему,
[01:14:32.240 --> 01:14:34.240]  которая называется исчисление резолюций,
[01:14:34.240 --> 01:14:36.240]  которую я в следующий раз опишу.
[01:14:36.240 --> 01:14:38.240]  То есть, там уже доказательством
[01:14:38.240 --> 01:14:41.240]  будет вывод в исчисление резолюций для полученной КНФ.
[01:14:41.240 --> 01:14:43.240]  То есть, в нашей системе доказательств
[01:14:43.240 --> 01:14:46.240]  будет важный вот такой шаг при процессинге,
[01:14:46.240 --> 01:14:49.240]  когда мы произвольную формулу превращаем в КНФ.
[01:14:49.240 --> 01:14:52.240]  И дальше доказываем невыполнимость.
[01:14:52.240 --> 01:14:54.240]  То есть, опровергаем эту КНФ,
[01:14:54.240 --> 01:14:56.240]  доказываем ее невыполнимость,
[01:14:56.240 --> 01:14:59.240]  выводим из дезюмта в этой КНФ тождественную ложь.
[01:14:59.240 --> 01:15:01.240]  Вот что мы делаем.
[01:15:01.240 --> 01:15:03.240]  Как мы это делаем?
[01:15:03.240 --> 01:15:05.240]  Это отдельная история.
[01:15:05.240 --> 01:15:06.240]  Все в следующий раз.
[01:15:06.240 --> 01:15:10.240]  И нужно, конечно, формально определить все эти манипуляции из КНФ.
[01:15:10.240 --> 01:15:14.240]  Но тут за полпары точно это все не успеешь.
[01:15:14.240 --> 01:15:17.240]  В следующий раз, я думаю, мы с этим всем разберемся.
[01:15:17.240 --> 01:15:19.240]  Это все не так сложно.
[01:15:19.240 --> 01:15:23.240]  А вот переход от общих формул КНФ, я надеюсь, стал понятен.
[01:15:23.240 --> 01:15:25.240]  Ну, на сегодня тогда все.
