[00:00.000 --> 00:11.340]  Здравствуйте, начинаем.
[00:11.340 --> 00:14.080]  Сначала нам нужно доделать то, что мы не сделали в
[00:14.080 --> 00:15.960]  прошлый раз про бинарную кучу.
[00:15.960 --> 00:19.040]  Во-первых, нам нужно добить hip-сорт, да, у нас там был
[00:19.040 --> 00:21.760]  кусочек, который я назвал hipify, алгоритм построения
[00:21.760 --> 00:24.640]  кучи за линейное время, там мы не все сделали.
[00:24.640 --> 00:27.200]  И плюс еще несколько штучек, которые куча умеет в дополнение
[00:27.200 --> 00:29.840]  ко всему, что мы уже про нее знаем.
[00:29.840 --> 00:34.800]  Во-первых, мы давайте вспомним, как мы реализовали процедуру
[00:34.800 --> 00:37.800]  hip-сорт.
[00:37.800 --> 00:42.640]  Процедура построения, не так, процедура сортировки
[00:42.640 --> 00:45.640]  данного массива с помощью кучи, есть у нас какой-то
[00:45.640 --> 00:50.560]  массив A1 и так далее, An, алгоритм состоит из двух шагов.
[00:50.560 --> 00:56.600]  Во-первых, мы делаем hipify, то есть строим кучу на данном
[00:56.600 --> 01:05.200]  массиве, но при этом куча с максимумом в корне.
[01:05.200 --> 01:07.400]  Строим кучу с максимумом корни.
[01:07.400 --> 01:14.400]  То есть если обычная куча, это у нас, когда добавляется
[01:14.400 --> 01:17.080]  требование кучи, что в корне лежит минимум, и соответственно
[01:17.080 --> 01:19.120]  в каждой вершинке лежит число меньше либо равное
[01:19.120 --> 01:21.800]  чем во всем по дереве, то здесь наоборот мы строим
[01:21.800 --> 01:24.840]  такую кучу, где наоборот максимум находится ближе
[01:24.840 --> 01:25.840]  к корню.
[01:25.840 --> 01:28.520]  То есть это самое большое число, там в детях какие-то
[01:28.520 --> 01:30.160]  близкие к самому большому и так далее.
[01:30.160 --> 01:36.760]  И второе, N раз просто вызываем экстракт Мин, извините,
[01:36.760 --> 01:46.000]  экстракт Макс, да, N раз вызвать экстракт Макс, и сам этот
[01:46.000 --> 01:48.880]  результат, то число из корня, которое мы удаляем, мы
[01:48.880 --> 01:52.200]  его никуда не выводим, просто запускаем ту реализацию
[01:52.200 --> 01:54.880]  экстракт Макс, которая меняет корневое значение
[01:54.880 --> 01:58.160]  с самым правым листом и уменьшая размер кучи
[01:58.160 --> 01:59.160]  на единичку.
[01:59.160 --> 02:02.080]  Тем самым мы как раз на каждом шаге сначала самое
[02:02.080 --> 02:04.680]  большое число положим в конец, второе потом по
[02:04.680 --> 02:07.120]  величине положим вторым с конца и так далее.
[02:07.120 --> 02:10.280]  Ну и вот в итоге мы на том же месте, где исходный был
[02:10.280 --> 02:13.600]  массив, посортировали его с привлечением от единицы
[02:13.600 --> 02:14.960]  допонятных человек памяти.
[02:14.960 --> 02:24.240]  Это in-place сортировка, то есть используем
[02:24.240 --> 02:31.120]  от единицы дополнительных ячеек памяти.
[02:31.120 --> 02:42.560]  Ну и нам осталось добить вот этот Hippie-Fi, что было
[02:42.560 --> 02:50.720]  в прошлый раз.
[02:50.720 --> 02:52.440]  Давайте мы будем считать, что мы все равно строим
[02:52.440 --> 02:54.440]  кучу на минимум в корне.
[02:54.440 --> 03:00.800]  То есть обычную кучу, когда в корне должно быть минимальное
[03:00.800 --> 03:01.800]  значение.
[03:01.800 --> 03:05.320]  Остаюсь, чтобы, например, минимум превратить в максимум,
[03:05.320 --> 03:08.760]  можно изначально все числа умножить на минус 1, и потом
[03:08.760 --> 03:11.320]  вот написать Hippie-Fi с минимумом в корне, и тогда у вас как
[03:11.320 --> 03:13.840]  раз в корне будет лежать минимальное число после
[03:13.840 --> 03:15.640]  умножения всего на единицу, значит до умножения это
[03:15.640 --> 03:17.440]  как раз максимальное число.
[03:17.440 --> 03:19.800]  Ну и потом, когда вы извлекаете, вы как раз извлекаете в
[03:19.800 --> 03:20.800]  нужном порядке.
[03:20.800 --> 03:25.000]  Или же нужно просто поменять значок сравнения, если раньше
[03:25.000 --> 03:27.400]  у вас два числа были, одно меньше другого, то теперь
[03:27.400 --> 03:31.080]  вам нужно наоборот сравнивать, что второе меньше первого.
[03:31.080 --> 03:42.320]  Напоминаю процедуру, мы просто N раз, от N до единички делаем
[03:42.320 --> 03:43.320]  севдаун.
[03:43.320 --> 03:48.160]  Севдаун, а ты?
[03:48.160 --> 03:53.080]  В прошлый раз мы доказали, что такая штука работает
[03:53.080 --> 03:56.520]  за от N, там какой-то ряд, давайте напомним, что время
[03:56.520 --> 04:00.280]  работы оценивается сверху рядом вот таким вот, M от
[04:00.280 --> 04:05.680]  единицы до бесконечности, M на 2M, ну и все это умножить
[04:05.680 --> 04:26.560]  на, на T, T, N, на T, T, N, то есть основной здесь, да, да, сорри,
[04:26.560 --> 04:32.560]  извините, больше бы равно, конечно, от N до единички.
[04:33.160 --> 04:36.000]  Вот, а симпатика сверху, это T, T, T, основной множитель,
[04:36.000 --> 04:38.720]  и здесь какой-то ряд, который мы оценили сверху какой-то
[04:38.720 --> 04:40.720]  константой, что все это не больше, чем какая-то
[04:40.720 --> 04:43.240]  константа C, независимо какой у вас верхний предел
[04:43.240 --> 04:46.920]  суммирования, хоть до бесконечности, хоть до любой константы,
[04:46.920 --> 04:50.920]  можно оценить сверху одной, одним числом C.
[04:50.920 --> 04:53.400]  Остается доказать только корректность, почему после
[04:53.400 --> 04:57.880]  вот этого вот цикла у вас обязательно будет храниться
[04:57.880 --> 05:00.760]  правильная куча, то есть почему она будет удовлетворять
[05:00.760 --> 05:03.640]  требования у кучи.
[05:03.640 --> 05:07.800]  Ну здесь, это просто доказать, значит, докажем индукции
[05:07.800 --> 05:15.720]  PN в порядке, по E в порядке убывания, индукции E по E в порядке
[05:15.720 --> 05:24.520]  убывания, что после севдаун от E в поддереве этой вершинки
[05:24.520 --> 05:33.400]  будет корректная куча, что после выполнения севдаун
[05:33.400 --> 05:40.320]  от E в поддереве этой вершинки будет лежать корректная
[05:40.320 --> 06:03.560]  куча.
[06:03.560 --> 06:06.320]  То есть скажем вот, когда E равно N, мы что делаем?
[06:06.320 --> 06:09.720]  Мы запускаем севдаун от N, но понятно, что N это обязательно
[06:09.720 --> 06:12.560]  лист, и поэтому его ниже опускать некуда, а севдаун
[06:12.560 --> 06:14.720]  у меня берет какое-то число и пытается его просеять
[06:14.720 --> 06:15.720]  ниже.
[06:15.720 --> 06:17.360]  Если это число слишком большое, то он пытается его опустить
[06:17.360 --> 06:18.360]  ниже к листю.
[06:18.360 --> 06:20.400]  Так вот, севдаун от N, понятно, ничего не делает, потому
[06:20.400 --> 06:21.400]  что опускать ниже некуда.
[06:21.400 --> 06:24.060]  Севдаун от N минус 1 тоже, скорее всего, ну то есть для
[06:24.060 --> 06:26.080]  листьев ничего не поменяется, севдаун для листа ничего
[06:26.080 --> 06:27.080]  не сделает.
[06:27.080 --> 06:30.320]  Поэтому здесь потенциально можно было бы вызывать,
[06:30.320 --> 06:36.080]  можно было бы перебирать E не от N, а скажем от N пополам,
[06:36.080 --> 06:40.440]  потому что для всех E от N до N пополам, это все равно
[06:40.440 --> 06:42.200]  вершинка будет листом, и тогда севдаун ничего
[06:42.200 --> 06:43.200]  не сделает.
[06:43.200 --> 06:45.320]  Ну это не асимпатическая оптимизация, она всего лишь
[06:45.320 --> 06:48.080]  уменьшит число запусков вдвое, а у нас в принципе
[06:48.080 --> 06:51.080]  и так линейное время работы, поэтому не особо важно,
[06:51.080 --> 06:53.280]  какая здесь константа, поэтому можно от N начинать.
[06:53.280 --> 06:56.440]  Ну значит там база индукции какая-нибудь проста, если
[06:56.440 --> 06:59.560]  E соответствует листу, то обязательно после севдауна
[06:59.560 --> 07:01.720]  ничего не произойдет, ну собственно это корректная
[07:01.720 --> 07:03.360]  куча в корне с E лежит.
[07:03.360 --> 07:10.880]  Ну теперь переход, смотрим на какую-нибудь вершинку
[07:10.880 --> 07:16.880]  E и на двух ее детей, соответственно 2E и 2E плюс 1.
[07:16.880 --> 07:19.600]  Мы понимаем, что эти вершинки уже были когда-то рассмотрены
[07:19.600 --> 07:22.560]  раньше, поскольку мы перебираем E в порядке убывания, значит
[07:22.560 --> 07:25.640]  когда-то у меня вызвался вот такой севдаун от 2E
[07:25.640 --> 07:29.400]  и вызвался севдаун от 2E плюс 1, и по предположению
[07:29.400 --> 07:31.960]  индукции здесь лежат две корректные кучи, значит
[07:31.960 --> 07:35.440]  здесь корректная куча и здесь корректная куча.
[07:35.440 --> 07:41.840]  Ну тогда, собственно единственное, что может сломаться, это
[07:41.840 --> 07:44.720]  нарушится может какой-то из вот этих двух неравенств,
[07:44.720 --> 07:47.760]  что либо вот это число больше чем 2E, либо вот это число
[07:47.760 --> 07:50.000]  больше чем 2E плюс 1, да, то есть может нарушиться
[07:50.000 --> 07:51.800]  только вот одно из этих двух неравенств.
[07:51.800 --> 07:54.320]  И мы хотим показать, что если мы вызовем один только
[07:54.320 --> 08:00.360]  севдаун от E, севдаун от E, то обязательно все вместе
[08:00.960 --> 08:01.960]  вот эта вся большая куча станет корректной.
[08:01.960 --> 08:05.360]  Ну что-то похожее мы уже делали, давайте скажем,
[08:05.360 --> 08:08.480]  что, вот у нас были 2 корректных кучи, давайте мы сначала
[08:08.480 --> 08:13.460]  их склеим в одну путем дописывания вот здесь числа минус бесконечности,
[08:13.460 --> 08:15.260]  тогда это понятно дело будет корректная куча, потому
[08:15.260 --> 08:18.240]  что вот здесь неравенства не нарушаются, здесь не
[08:18.240 --> 08:21.560]  нарушается, ну и здесь понятное дело, тоже ничего не нарушается,
[08:21.560 --> 08:23.940]  потому что минус бесконечность, это самое маленькое число,
[08:23.940 --> 08:26.700]  оно явно меньше, чем то что написано в детях, а потом
[08:26.700 --> 08:33.060]  мы возьмем эту минус бесконечность, увеличим до правильного значения аитова. Вместо минус
[08:33.060 --> 08:39.100]  бесконечности напишем аито. Получается, что мы число увеличили, минус бесконечность увеличили
[08:39.100 --> 08:45.360]  до аитова. Здесь могли нарушиться какие-то неравенства, но мы знаем, что stiff down как раз
[08:45.360 --> 08:49.580]  все нам починит. Мы знаем, что если была корректная куча и одно из чисел увеличили, а после этого
[08:49.580 --> 08:54.940]  вызвали stiff down, то обязательно в результате будет корректная куча. Это вот одна из лемм с прошлого
[08:54.940 --> 08:59.500]  раза, который мы делали, что если была корректная куча, число увеличили и запустили stiff down, то в
[08:59.500 --> 09:13.620]  конце будет корректная куча. Было такое? Было, было. Ну все, в конце. Давайте напишем после. Мы, конечно,
[09:13.620 --> 09:18.260]  явным образом здесь минус бесконечность мы не пишем. Это я просто написал, чтобы показать почему-то
[09:18.260 --> 09:22.980]  все корректно, что если бы здесь была изначальная минус бесконечность, то была бы корректная куча,
[09:22.980 --> 09:28.860]  и потом я число бы увеличил. Но наш алгоритм не ставит минус бесконечность, он сразу говорит,
[09:28.860 --> 09:32.980]  что давайте я туда поставлю аито и сделаю stiff down. Ну тогда это будет просто корректно,
[09:32.980 --> 09:44.380]  потому что если бы мы заменяли минус бесконечность на аито. После замены минус бесконечности на аито
[09:44.380 --> 10:04.060]  и вызова stiff down от и получим корректную кучу. Значит, после каждой и-то итерации у меня будет
[10:04.060 --> 10:08.820]  корректная куча с корнем в и, а значит, после последней итерации, после итерации, где и равно
[10:08.820 --> 10:12.620]  единичке, у меня будет корректная куча с корнем в единице, то есть просто корректная куча.
[10:12.620 --> 10:20.260]  Что я требовал доказать? Мы хотели по данному массиву построить корректную кучу, собственно
[10:20.260 --> 10:31.380]  ровно это вот следует для нашего утверждения. Понятно? Хорошо, значит вот Hippie-5 мы построили
[10:31.380 --> 10:42.220]  за линейное время, он строит кучу на данном на данном наборе элементов. Хорошо. Отсюда можно
[10:42.220 --> 10:54.780]  сделать такое следствие из вот этого алгоритма hip sort. Не существует такой реализации кучи,
[11:02.380 --> 11:16.340]  которая могла бы отвечать на экстракт мин за от единицы. Я напишу, которая могла бы делать экстракт
[11:16.340 --> 11:32.300]  мин за от единицы. Иначе, если такая куча есть и она умеет делать экстракт мин за единицу. Так,
[11:32.300 --> 11:39.940]  сейчас, секунду, секунду, секунду. Давайте мы ослабим немножко, потому что это зависит
[11:39.940 --> 11:53.900]  все-таки от структуры кучи, и при этом могла бы делать тоже insert за единицу, insert за от единицы.
[11:53.900 --> 12:01.940]  Потому что, если бы такая куча была, которая бы и insert, и экстракт мин делала бы за единицу,
[12:01.940 --> 12:08.140]  то у меня был бы алгоритм сортировки за от n. Я сначала n раз делаю insert, потом n раз делаю
[12:08.140 --> 12:13.580]  экстракт мин. И каждое издалеченное число я просто печатаю, тем самым сортирую мой массив за
[12:13.580 --> 12:25.660]  линейное время. Это мы сегодня еще узнаем, что такое амортизированное, но то же самое. Что такое
[12:25.660 --> 12:29.380]  амортизированное? Это значит, что если вы сделаете k-итерации, то суммарно все работает максимум за от k.
[12:29.380 --> 12:35.060]  То же самое. Вы делаете там n insert, n extract, даже если здесь амортизированная вот единица, то
[12:35.060 --> 12:39.460]  суммарно это значит, что все работает за от n, что противоречит нашей теории парового сортировку за
[12:39.460 --> 12:54.420]  n log n. Иначе был бы алгоритм сортировки за от n. А мы с вами доказали, что алгоритм, основанный на
[12:54.420 --> 12:59.900]  сравнениях, обязательно требует n log n, ω от n log n, действий для того, чтобы правильно завершиться.
[12:59.900 --> 13:07.180]  Но здесь я явно не сказал, давайте я подчеркну где-нибудь, что куча обязательно должна быть
[13:07.180 --> 13:20.540]  основана на сравнениях. В том же смысле, в каком мы говорили про сортировки, основанные на сравнениях,
[13:20.540 --> 13:25.220]  что у нас объекты это какие-то камушки разноцветные, которые мы можем сравнивать только
[13:25.220 --> 13:30.260]  явным образом, положив два камушка на весы. То есть мы не можем просто по виду двух камней сказать,
[13:30.260 --> 13:35.260]  какой из них больше, какой меньше. Мы должны их прямо положить руками и сравнить, как у нас было
[13:35.260 --> 13:40.060]  сортировки сравнений. То есть если бы у нас, например, было не так и мы бы знали, например, что числа,
[13:40.060 --> 13:45.260]  которые мы кладем в кучу, это маленькие целые числа, не знаю там от n log n до 10, то тогда понятно,
[13:45.260 --> 13:50.420]  что легко делать n extract за единицу, n insert за единицу, просто давайте для каждого числа от n log n до 10
[13:50.420 --> 13:55.180]  и хранить, сколько раз оно встречается. Тогда insert это просто увеличить какой-то счетчик,
[13:55.180 --> 14:01.940]  а extract min это пройтись от 1 до 10 и найти первый не нулевой счетчик. Но это как раз тогда получится
[14:01.940 --> 14:05.740]  куча не основана на сравнениях, потому что она использует доп информацию о наших объектах,
[14:05.740 --> 14:10.220]  что это не просто камушки, которые можно сравнивать, а вот маленькие целые числа, которые можно как-то
[14:10.220 --> 14:16.220]  развить по корзинкам. Ну а в общем случае, если можно только сравнивать наши элементы и больше
[14:16.220 --> 14:22.820]  ничего мы про них не знаем, то вот ничего лучше, чем ну не так, то нельзя одновременно extract
[14:22.820 --> 14:29.500]  insert делать за единичку. Ну еще можно заметить, что наша бинарная куча, она как раз основана на
[14:29.500 --> 14:34.180]  сравнениях, потому что в ней там основная операция это shift up и shift down, которые всегда просто берут
[14:34.180 --> 14:40.420]  и сравнивают число с детьми или там с родителем. То есть наша куча, она как раз основана на
[14:40.420 --> 14:44.060]  сравнении. Вот это сделали, хорошо.
[15:02.180 --> 15:06.900]  Так, давайте теперь еще тогда поговорим про то, что умеет куча делать. Это про декоризки,
[15:06.900 --> 15:13.500]  ну про вообще про особенности декоризки. Значит как у нас работала декоризки в простой
[15:13.500 --> 15:20.020]  реализации на бинарной куче? Мы брали в качестве одного из аргументов позицию, не помню я там ве
[15:20.020 --> 15:26.020]  называл ее или давайте пусть будет ве. Позицию ве вершины такую, что на соответствует числу,
[15:26.020 --> 15:32.300]  которому нужно уменьшить, да, и мы сначала там делали, а в этой минус равно дельта. Мы вот то самое
[15:32.300 --> 15:38.940]  число, на которое показывает указатель, уменьшаем на дельту. Это такая скорее абстрактная ситуация,
[15:38.940 --> 15:43.100]  когда внешний сторонний пользователь прям вам тыкает на элемент в куче, то есть он знает,
[15:43.100 --> 15:47.780]  где он лежит и говорит вам уменьшить его, пожалуйста, на дельту. Скорее всего внешний пользователь не то,
[15:47.780 --> 15:52.100]  что не может вам показательный элемент, он скорее даже не знает, что у вас вообще какая-то куча
[15:52.100 --> 15:56.820]  реализована в программе. Это скорее ваша задача понимать, чего хочет пользователь, какой именно
[15:56.820 --> 16:03.940]  нужно объект уменьшить. Вот, и здесь возникает два возможных способа, как это может быть реализовано.
[16:03.940 --> 16:16.220]  Способ первый это декрески по... Сейчас, сейчас, извините, нет, я перепутал, тут один есть вариант,
[16:16.220 --> 16:25.940]  просто декрески. Нам просто как-то указывают идентификаторы элемента, которые нужно уменьшить.
[16:25.940 --> 16:38.940]  По идентификатору я так скажу. То есть, ну проблема остается, что нам не могут сообщить просто число,
[16:38.940 --> 16:44.460]  скажем, нам не могут сказать уменьшите, пожалуйста, х на дельту, напишите вместо ха х-дельта, потому что
[16:44.460 --> 16:50.260]  из этих х-ов нашей кучи может быть много, во-первых, и непонятно, какой из х-ов менять. Во-вторых,
[16:50.260 --> 16:56.340]  даже если их один или нам не важно, какой именно менять, к сожалению, куча не умеет быстро находить
[16:56.340 --> 17:01.140]  данный элемент. Вот есть у меня бинарная куча, там много-много чисел, я вас прошу, найдите в ней
[17:01.140 --> 17:06.380]  число 10 и уменьшите его. Но чтобы найти эту десятку, у нас нет никакого алгоритма, чтобы это
[17:06.380 --> 17:10.060]  эффективно делать. То есть, лучшее, что мы можем придумать, это как-то спускаться просто по куче
[17:10.060 --> 17:14.820]  снизу вверх, обрубаясь на числах сажем, которые больше, чем 10, потому что спускаться вниз не имеет
[17:14.820 --> 17:21.140]  смысла. Вот, но как-то эффективно найти 10, скажем, за гарантированное от алгоритма, к сожалению, нет
[17:21.140 --> 17:26.180]  способа или, по крайней мере, не придумано. То есть, найти число в куче проблематично, ну потому что мы
[17:26.180 --> 17:31.900]  не поддерживаем никакую структуру, и это число может быть где угодно в куче. Поэтому лучше, на что
[17:31.900 --> 17:37.820]  можем надеяться, это на то, что пользователь как-то дает какую-то все равно информацию о том числе,
[17:37.820 --> 17:43.740]  которую нужно уменьшить. И вот самый простой случай, это когда идентификатор, это, скажем, номер
[17:43.740 --> 17:56.060]  запроса, на котором соответствующее число было добавлено. Номер запроса, на котором соответствующее
[17:56.060 --> 18:09.060]  число было добавлено. То есть, дикрийский будет работать теперь так. Есть у меня там insert,
[18:09.060 --> 18:13.960]  extract min и так далее, вот все эти обычные операции, а дикрийский работает следующим образом. Уменьшите,
[18:13.960 --> 18:20.540]  пожалуйста, вот тот запрос, который к вам пришел 13-м, на столько-то. То есть, вам не тыкают места в
[18:20.540 --> 18:25.980]  куче, а говорят, вот тот элемент, который я когда-то 13-м положил вам, вот его уменьшите. Ну и это уже
[18:25.980 --> 18:29.780]  чуть более реалистично. В той модели, когда мы там какая-нибудь фабрика, которая обрабатывает
[18:29.780 --> 18:37.140]  заказы, нам приходит клиент и говорит, я вам тут дал заказ номером там 1, 4, 2, 3, вот, пожалуйста,
[18:37.140 --> 18:41.220]  его нужно поскорее закончить. То есть, какой-то идентификатор, который однозначно позволяет
[18:41.220 --> 18:49.820]  вам понять, про какой элемент идет речь. Вот. Здесь тогда нам нужно как-то по идентификатору
[18:49.820 --> 18:55.340]  найти, где находится это число в куче. Но это можно сделать довольно просто. Смотрите, давайте
[18:55.340 --> 19:02.620]  мы для каждого элемента кучи будем хранить соответствующему как бы коробочку, которая вот с ним
[19:02.620 --> 19:09.780]  находится во взаимно-однозначном соответствии. То есть, говорим, что вот это идентификатор и он,
[19:09.780 --> 19:15.700]  а это какая-то вершина кучи, да, это вершина кучи, и что вот они друг на друга ссылаются. То есть,
[19:15.700 --> 19:19.820]  этот идентификатор хранит информацию, что соответствующий заказ лежит там-то в куче,
[19:19.820 --> 19:25.700]  и наоборот, эта вершина кучи, зная, какой тут элемент, говорит, что ему соответствует
[19:25.700 --> 19:29.980]  такой-то идентификатор. То есть, вот такое вот взаимно-однозначное соответствие. И потом,
[19:29.980 --> 19:34.420]  если ко мне приходит запрос по какому-то данному идентификатору изменить какой-то элемент,
[19:34.420 --> 19:37.820]  я просто нахожу соответствующую коробочку, смотрю, куда она ссылается, и этот элемент
[19:37.820 --> 19:44.620]  уменьшаю. Делаю дикрестки уже от этой позиции в кучу. Получается, что вот это такое соответствие
[19:44.860 --> 19:51.100]  позволит не отвечать на запрос. Но тогда их нужно еще научиться поддерживать и сохранять вот эти
[19:51.100 --> 19:55.860]  вот стрелочки, когда мы делаем всякие сифтапы и сифтдаун. Вот давайте мы на это посмотрим.
[20:14.620 --> 20:27.380]  Итак, давайте скажем, что num, нет, сейчас, сейчас, pointer, наоборот, pointer от t, это указатель
[20:27.380 --> 20:37.980]  на вершину в куче, которое соответствует этому добавленному элементу. Указатель на вершину в куче.
[20:44.620 --> 20:56.620]  Которое соответствует, соответствует этому добавленному элементу. То есть это вот как раз,
[20:56.620 --> 21:01.900]  если мы знаем идентификатор, то по нему мы хотим понять, на какой элемент куча это указывает. Вот
[21:01.900 --> 21:06.460]  такой pointer будем хранить. Ну указатель – это громкое слово, поскольку у меня все равно вся куча
[21:06.460 --> 21:10.260]  хранится в массиве, то на самом деле это будет просто номер вершинки. Вместо указателя скорее
[21:10.260 --> 21:19.220]  номер вершины. Ну и обратное соответствие нам тоже нужно. Давайте я его назову num. Num,
[21:19.220 --> 21:25.500]  наоборот, от v, это обратное соответствие, то есть идентификатор в соответствующей вершине v.
[21:25.500 --> 21:42.380]  Идентификатор в соответствующей вершине v. И нам нужно эти pointer и num корректно пересчитывать,
[21:42.380 --> 21:46.900]  когда мы делаем в нашей куче всякие там свопы, когда мы поднимаем, что-то опускаем. Вот это все
[21:46.900 --> 21:53.220]  нужно аккуратно переделывать. Например, когда мы реализуем coin-sift-up, мне может понадобиться
[21:53.220 --> 22:00.580]  поменять местами значения, которые написаны вот в вершинке v и вершинке v пополам. Но тогда не
[22:00.580 --> 22:04.620]  просто я поменяю значения, которые там лежат, но также мне нужно аккуратно вот эти вот стрелочки
[22:04.620 --> 22:09.500]  все переназначить. Потому что если у меня был идентификатор соответствующий v и идентификатор
[22:09.500 --> 22:14.300]  соответствующий v пополам, то теперь, поскольку эти числа поменяются местами, то эти стрелки
[22:14.300 --> 22:19.580]  тоже нужно будет перерисовать. Давайте я нарисую красным старую конфигурацию.
[22:19.580 --> 22:36.260]  Вот красное было то, что раньше, а синее то, что теперь должно быть. Потому что я их поменял
[22:36.260 --> 22:40.860]  местами, и теперь v находится вот здесь. Значит, коробочка, которая соответствует,
[22:40.860 --> 22:45.300]  но она находится там же, но нужно этот указатель как бы перенаправить в эту вершинку. То есть числа
[22:45.300 --> 22:49.620]  поменяли, значит и вот эти стрелки тоже должны как бы перенаправиться. Давайте напишем тогда
[22:49.620 --> 22:59.140]  простую процедурку. Я ее назову exchange, которая принимает номера вот этих двух вершин, для
[22:59.140 --> 23:05.540]  которых нужно сделать вот этот вот swap, ну и меняет все вот эти стрелочки аккуратно. Ну тут int u, int v.
[23:05.540 --> 23:26.740]  Так, я хочу ввести переменные, скажем k, это pointer от u и какой-нибудь m, это pointer от v.
[23:26.740 --> 23:34.900]  Если это u, а это v, тогда у меня получается вот это вот, это идентификатор соответствующий v,
[23:34.900 --> 23:46.100]  sorry, вот это вот m соответствует v, а k соответствует v половину или там u. Так, во-первых,
[23:46.100 --> 23:51.500]  мне нужно поменять эти pointer, во-вторых, у них нужно num поменять, потому что вот эти стрелки
[23:51.500 --> 23:55.980]  тоже меняются, то есть была стрелка сюда, станет стрелка сюда. Еще нужно не забыть поменять out
[23:55.980 --> 24:06.420]  и out, это все я аккуратно сейчас сделаю. Во-первых, нужно поменять эти pointer, pointer out и pointer v.
[24:15.540 --> 24:16.700]  Во-вторых, нужно поменять,
[24:16.700 --> 24:31.180]  так. Плохо, да? Здесь я имею в виду num. Да, извините, num давайте напишем здесь.
[24:31.180 --> 24:45.820]  Виноват. Тут везде num, а не pointer, потому что для вершинки мне нужен номер идентификатора,
[24:45.820 --> 24:50.700]  а вот здесь наоборот. У меня есть два идентификатора, и мне нужно поменять указатели на элементы в куче,
[24:50.700 --> 25:00.300]  куда они показывают. То есть мне нужно здесь поменять pointer kt и pointer mt, вот так. Неважно,
[25:00.300 --> 25:04.620]  как я их назову, можно было бы поменять pointer num, потому что это все равно взаимно противоположные
[25:04.620 --> 25:09.700]  вот такие вот соответствия, слева направо, справа налево. Так, ну и в конце не забываем сделать swap
[25:09.700 --> 25:19.460]  аута и авета. Поменять местами значение утово и в этого элемента. Все. Вот такой exchange,
[25:19.460 --> 25:25.140]  то есть это по сути обычный swap, только еще мы аккуратно с этими стрелочками работаем. Давайте
[25:39.700 --> 25:49.220]  вот. Понятно? Хорошо. Ну и тогда если у нее есть такой exchange, то все операции shift-tap и shift-down
[25:49.220 --> 25:56.460]  сейчас автоматически мы перепишем с его помощью, и у нас будет куча, которая поддерживает уже вот
[25:56.460 --> 26:02.820]  эти вот соответствия между элементами кучи и идентификаторами. Давайте shift-tap только перепишем.
[26:02.820 --> 26:10.620]  Shift-tap. Напоминаем, как он работает, принимает номер вершинки. Пока у нее есть родитель,
[26:10.620 --> 26:21.300]  мы пытаемся с ним поменять. Пока v не равно единице, если авета меньше чем a родительская,
[26:21.300 --> 26:28.260]  av пополам т. Тогда в обычной реализации я пишу здесь swap, а здесь напишу exchange, потому что кроме
[26:28.260 --> 26:35.100]  значений мне нужно также поменять все эти ссылочки. Поэтому я просто напишу exchange, v и v пополам.
[26:35.100 --> 26:42.700]  Потом v поделю, вместо v напишу родителя, ну а иначе break.
[26:51.020 --> 26:56.500]  То есть shift-down остается точно таким же, только вместо swap-a, exchange. Все. А дальше, ну то есть
[26:56.500 --> 27:01.380]  дальше у меня shift-down точно также переписывается. Всюду, где у меня там был swap, я делаю exchange,
[27:01.380 --> 27:06.380]  соответственно. Ну а все операции, поскольку они выражаются через shift-tap и shift-down, то там insert,
[27:06.380 --> 27:11.780]  getmin и так далее, они все останутся таким же, просто используя shift-tap и shift-down. А дальше,
[27:11.780 --> 27:21.940]  когда мне приходит запрос decrease key, какой-нибудь идентификатор t и дельта, мне нужно вспомнить,
[27:21.940 --> 27:29.660]  чему соответствует этот идентификатор. То есть посмотреть на pointer от t, просто pointer от t,
[27:29.660 --> 27:36.740]  и этот pointer от t как раз ведет меня в ту вершинку в куче, которую нужно уменьшить. Я считаю,
[27:36.740 --> 27:42.540]  что там t-шки, это номер запроса в общем порядке. Пришел первый, второй, третий и так далее запрос.
[27:42.540 --> 27:47.180]  То есть вот эти t-шки как бы сплошняком номируются, тогда я могу хранить просто массив этих
[27:47.180 --> 27:51.900]  pointer и для каждого идентификатора я знаю, куда он ссылается в кучу. И тогда, соответственно,
[27:51.900 --> 27:56.660]  я просто считаю сам этот свой pointer, поддерживаю его всегда в процессе работы программы, посчитал
[27:56.660 --> 28:07.820]  pointer, знаю, куда он ссылается и уменьшаю вот этого число на дельту. А от pointer от t уменьшу на
[28:07.820 --> 28:19.780]  дельту. Ну и вызову с фитапом. Вот и все, вся реализация дикриски, если мне не показывать кучу,
[28:19.780 --> 28:36.740]  а говорят просто там номер элемента в порядке добавления. Вот, вопросы. Хорошо. Так, вот,
[28:36.740 --> 28:41.660]  ну дикриски как по-другому. Когда пользователь не знает, какой именно элемент где хранится,
[28:41.660 --> 28:47.780]  мы сами должны как-то про это узнавать. Ну вот никак по-другому, кроме как давать какой-то
[28:47.780 --> 28:51.700]  идентификатор элемента, ну непонятно, как это по-другому можно реализовать. То есть все равно
[28:51.700 --> 28:56.540]  пользователь как-то должен знать, какой именно элемент ему нужно уменьшить, поэтому вот это t
[28:56.540 --> 29:06.500]  он сам откуда-то берет, ну а мы его обрабатываем. Мы его сами уже обрабатываем. Так, с дикризом
[29:06.500 --> 29:15.140]  разобрались. Вот, и оказывается, что с помощью этого дикриза и с помощью вот этих указателей можно
[29:15.140 --> 29:25.300]  делать еще и рейс из кучи. Прям вот удалять элементы с кучи. И здесь есть вот, вот здесь как
[29:25.300 --> 29:36.060]  ростки из два подхода. Первое это удаление по указателю, удаление по указателю, ну или по
[29:36.060 --> 29:54.500]  идентификатору. И второе это удаление по значению, удаление по значению. Вот, первое удаление по
[29:54.500 --> 30:01.380]  указателю. В дополнение к нашим четырем запросам insert, getmin, extractmin и дикриски появляются еще
[30:01.380 --> 30:07.100]  запросы вида erase t. Это значит, что тот элемент, который был добавлен на t этом шаге, нужно теперь
[30:07.100 --> 30:11.900]  удалить из кучи. Там, не знаю, приходит клиент, говорит, что вот у меня, мой заказ, который я вам
[30:11.900 --> 30:17.340]  тетин дал, вы его так долго исполняете, что мне его даже не надо уже все оставить, не выполнять его,
[30:17.340 --> 30:22.700]  удалить его из кучи своей. Вот такой поступает запрос удаления заказа. Но мы его просто должны
[30:22.700 --> 30:29.180]  удалить из кучи. И в случае, если нам вот дается этот идентификатор t или нам прям показывают,
[30:29.180 --> 30:33.260]  какой элемент нужно удалить, здесь реализация очень простая. Как удалить можно из кучи? Ваше
[30:33.260 --> 30:55.420]  предложение. Что сделать? Да-да-да, хорошая идея. Действительно, можно так. Сейчас поступило
[30:55.420 --> 31:00.060]  такое предложение. Вот если мне известен идентификатор или сразу указатель, мы понимаем,
[31:00.060 --> 31:04.220]  что по идентификатору можно построить указатель. Вот у меня есть вершинка v,
[31:04.220 --> 31:11.140]  которую нужно удалить. Тогда давайте мы возьмем последний элемент кучи, аэнный. Поменяем местами
[31:11.140 --> 31:23.260]  аэнное и авэте, уменьшим размер кучи на единичку и сделаем сифтап от сифтдаун от v. А нам это,
[31:23.260 --> 31:32.260]  кажется, не нужно. А, возможно, сифтап придется запустить. Да-да, это может быть. Действительно,
[31:32.260 --> 31:36.820]  вот есть элемент, который нужно удалить. Берем аэнное, ставим его на его место и, соответственно,
[31:36.820 --> 31:41.740]  уменьшаем кучу на единичку. Тогда у меня что? У меня есть корректная куча на n-1 элементе,
[31:41.740 --> 31:46.820]  в котором вот этот элемент изменился, было авэто и стало аэнным. Ну и, соответственно,
[31:46.820 --> 31:50.420]  в зависимости от того, увеличилось это число или уменьшилось, нужно сделать сифтап или сифтдаун.
[31:50.420 --> 31:55.980]  Тогда вроде все работает. Я просто забываю, что это когда-то было, переношу его в область
[31:55.980 --> 32:02.180]  недопустимых значений и делаю тут сифтап или сифтдаун. Да, так вроде работает. Можно немножко по
[32:02.180 --> 32:08.140]  другому. Можно сказать, что давайте мы сюда поместим число минус бесконечность, ну или такое число,
[32:08.140 --> 32:13.460]  которое меньше, чем все элементы в куче просто. Запустим сифтап, поднимем его в корень и потом
[32:13.460 --> 32:20.060]  просто удалим. Еще раз, авэто равно минус бесконечность, кладем туда что-то очень
[32:20.060 --> 32:25.700]  маленькое, потом запускаем сифтап от v, после чего это как раз минус бесконечность всплывает
[32:25.700 --> 32:32.780]  в корень, ну и потом делаем экстракт мин. Экстракт мин. На этом шаге как раз вот эта
[32:32.780 --> 32:37.740]  минус бесконечность уйдет в конец, отрежется, ну и куча корректной перестроится опять. Да,
[32:37.740 --> 32:47.380]  можно так и так, как удобно. Вот, это первый случай, да, простой, когда у меня прям,
[32:47.380 --> 32:51.020]  нам показывают явно, то есть либо сразу показывают, какую вершинку нужно удалить,
[32:51.020 --> 33:00.340]  либо мы сами это понимаем по идентификатору. Сейчас, сейчас, секунду.
[33:17.380 --> 33:29.700]  Да. Отрезаем эту ветку и потом запускаем сифтап отсюда. Ну, мы сначала понимаем,
[33:29.700 --> 33:34.740]  как число изменилось, уменьшилось или увеличилось. И мы знаем, что в зависимости, ну то есть у нас была
[33:34.740 --> 33:38.700]  лемма, что если была корректная куча и число увеличилось, то нужно запускать сифтап и все
[33:38.700 --> 33:42.140]  будет корректно. А если число уменьшилось, нужно вызвать сифтап и все будет тоже корректно.
[33:42.140 --> 33:55.580]  Что? Ну, по сути, это одно и то же. Декрестки. Вы про это или вот это?
[34:02.380 --> 34:07.420]  Ну, по сути, это все равно одно и то же, потому что мы меняем значение в элементе и потом,
[34:07.420 --> 34:15.500]  там чего, сифтап. Ну, то же самое. Просто я как бы это расшифровал без использования декрестки.
[34:15.500 --> 34:26.080]  Так, это простой случай. Теперь второй случай – удаление по значению. Это когда мне не говорят,
[34:26.080 --> 34:30.100]  какое именно нужно удалить, а сообщают просто о значении. Нужно из кучи удалить элемент со
[34:30.100 --> 34:35.940]  значением x. И вот здесь опять та же проблема, которая была в декрестки, что нельзя уменьшать
[34:35.940 --> 34:45.060]  по значению, потому что я не могу в куче быстро найти этот элемент. Вот мне говорят raise x. И мне в
[34:45.060 --> 34:49.140]  идеале хотелось бы найти, где это x влит в куче, но, к сожалению, у меня нет такого способа. У меня
[34:49.140 --> 34:59.900]  нету процедуры, которая бы находила, где x влит в куче. Найти, где x лежит в куче. У меня такого нету.
[34:59.900 --> 35:04.860]  Мы не умеем это эффективно делать, потому что куча не поддерживает никаких свойств, которые
[35:04.860 --> 35:14.060]  позволял бы быстро находить данное число. Поэтому придется здесь что-то придумать другое. А именно,
[35:14.060 --> 35:20.700]  давайте мы поддерживать на риту с нашей исходной обычной кучей кучу удаленных элементов. У меня
[35:20.700 --> 35:26.700]  теперь в решении будет не одна куча, как было всегда до этого, а две. Обычная куча, а также куча
[35:26.700 --> 35:35.620]  удаленных. Удаленные элементы. И тогда вместо raise x, вместо удаления ее из исходной кучи,
[35:35.620 --> 35:42.260]  я просто добавлю x в множество удаленных. Ничего удалять не буду, буду только вставлять,
[35:42.260 --> 35:47.140]  наоборот, в множество удаленных. А дальше у меня, ну, на самом деле мало что изменится,
[35:47.140 --> 35:52.180]  потому что когда приходит обычный insert, скажем insert y, тогда нужно просто y сюда
[35:52.180 --> 35:57.860]  поместить. Там decrease key тоже, если мне как-то ссылаются, да, то есть если мне дают как-то
[35:57.860 --> 36:02.580]  идентификатор элемента и говорят это уменьшить, ну, я тоже его спокойно уменьшу. Проблема только в
[36:02.580 --> 36:07.940]  get mini и в extract mini. То есть мне нужно как-то найти минимальный элемент вот в этой куче с учетом
[36:07.940 --> 36:18.100]  того, что какие-то из нее еще извлечены, какие-то из нее уже удалены. Я утверждаю,
[36:18.100 --> 36:23.380]  что это сделать довольно просто. Давайте я назову эту кучу a, эту кучу d. Как будет тогда
[36:23.380 --> 36:30.820]  работать get min? Он работает так. Пока минимальные элементы в наших двух кучах a и d совпадают,
[36:30.820 --> 36:43.420]  мы их оба удаляем. Пока, но я так вольно напишу a.get min. Равно d.get min. В том смысле,
[36:43.420 --> 36:48.740]  что если я запущу на каждой отдельной куче get min, то вернется одно и то же число, то я
[36:48.740 --> 37:06.140]  этот минимум из обеих куч извлекаю. a.extract min и d.extract min. А в конце у меня что? У меня это
[37:06.140 --> 37:10.620]  условие будет уже не выполняться. Когда я из вайла выйду, у меня это условие уже не выполняется. То
[37:10.620 --> 37:16.900]  есть здесь в корне лежит какое-то число, которого здесь нет. По крайней мере так хочется, что здесь в
[37:16.900 --> 37:20.340]  корне будет число, которого нет здесь. И тогда соответственно в качестве ответа нужно просто
[37:20.340 --> 37:34.860]  его вернуть. return a.get min. Вот как поменяется запрос get min на случай, когда у меня две кучи,
[37:35.540 --> 38:03.220]  так понятно ли то, что тут произошло? Ну вообще да, это верно. Сейчас, сейчас, одну секунду. Да,
[38:03.220 --> 38:08.900]  это хорошее замечание, тут нарушается в каком-то смысле следующее требование. Но это такое, мы не
[38:08.900 --> 38:17.860]  будем об этом задумываться. Да, да, да, я понимаю, но здесь можно по-разному на это претензию ответить,
[38:17.860 --> 38:23.820]  что, во-первых, представим, что у нас всего будет n операций вот к этой куче, к этой структуре,
[38:23.820 --> 38:29.300]  всего n операций. Там, не знаю, сначала куча инсертов, потом куча рейзов, опять куча инсертов,
[38:29.300 --> 38:34.020]  куча рейзов и так далее. И никогда, скажем, get min я не удаляю и корень тогда не удаляю. Но тогда
[38:34.020 --> 38:40.140]  все равно каждый запрос за логарифм обработается, за log n, где n это общий число запросов, потому что
[38:40.140 --> 38:44.740]  суммарно здесь будет максимум n элементов, ну и поэтому как бы глубина тоже максимум всегда логарифм.
[38:44.740 --> 38:49.660]  Поэтому все равно как бы будет логарифмическая оценка. С другой стороны, у нас логарифм не от числа
[38:49.660 --> 38:57.500]  элементов в куче активных, а как бы числа всего запросов. Ну такой метод, да, это конечно его изъян,
[38:57.500 --> 39:03.820]  что логарифм не от числа активных элементов, а от общего числа запросов. Ну что есть? Что есть?
[39:03.820 --> 39:10.220]  Так, нам надо доказать корректность вот этого, но здесь все довольно просто. Сейчас, извините.
[39:20.220 --> 39:26.220]  Почему это все верно? Можно просто заметить, что если у меня все запросы корректные, то есть у меня
[39:26.220 --> 39:31.380]  не поступает запрос, а, скажем, удаление несуществующего элемента, тогда у меня всегда
[39:31.380 --> 39:36.620]  будет выполнено, что d вложено в a. Множество удаленных всегда является под множество,
[39:36.620 --> 39:42.220]  множество добавленных. И давайте я тогда нарисую следующую картинку. Вот пусть a это какая-то такая,
[39:42.220 --> 39:47.140]  ну расположим эти числа на вещественной прямой, ну или там наши элементы упорядочим как-то в
[39:47.140 --> 39:55.220]  порядке возрастания, и у меня какие-то элементы как бы убиты, да, они какие-то были удалены из кучи.
[39:55.240 --> 39:59.620]  То есть в черточке это те, которые есть в a, а в крестике те, которые есть aggression, которые
[39:59.620 --> 40:03.960]  нужно удалить. Тогда как найти минимальное добавленное, но еще не удаленное? Давайте
[40:03.960 --> 40:07.180]  просто идти слева направо и находить первую черточку, которая не зачеркнуто крестиком,
[40:07.180 --> 40:12.820]  да, найти самое левое добавленное число, которое еще не было удаленным. Ну и собственно ровно
[40:12.820 --> 40:18.380]  это мы и делаем, мы идем слева направо по палочкам слева направо по крестикам, пока они совпадают,
[40:18.380 --> 40:22.400]  это значит, что элемент был добавлен и удален. Значит я должен удалить его из обеих кучек и
[40:22.400 --> 40:24.400]  И вообще считаю, что здесь ничего нет.
[40:24.400 --> 40:28.900]  Опять то же самое. И впервые, когда я вижу, что здесь элемент есть,
[40:28.900 --> 40:34.400]  ну то есть минимум здесь левее, чем вот здесь, то есть я нахожу первое минимум вот здесь и первое минимум вот здесь,
[40:34.400 --> 40:38.400]  они различны. Значит, я какой-то этот элемент добавил, но еще не удалил.
[40:38.400 --> 40:40.400]  Собственно, его и нужно вернуть.
[40:40.400 --> 40:42.400]  Вот и все, такое простое объяснение.
[40:42.400 --> 40:46.400]  Ну и экстракт-мин точно так же. Если я нашел минимум,
[40:46.400 --> 40:50.900]  то в экстракт-мине нужно его не найти, а удалить.
[40:50.900 --> 40:52.900]  То есть экстракт-мин пишется точно так же.
[40:52.900 --> 40:58.900]  Главное, что нам нужно поудалять вот эти вот первые элементы, пока не найдем первый неудаленный.
[41:08.900 --> 41:13.900]  Ну, проблемы не будет, если, скажем, нам говорят там insertX два раза,
[41:13.900 --> 41:15.900]  ну давайте не X, а давайте Y.
[41:15.900 --> 41:18.900]  И потом говорят eraseY один раз.
[41:18.900 --> 41:22.900]  И будет иметься в виду, что Y нужно как раз один раз удалить.
[41:22.900 --> 41:25.900]  То есть сколько удаляем, столько его и нужно вычеркнуть.
[41:25.900 --> 41:29.900]  Ну тогда все будет хорошо, потому что я сначала, ну и допустим там все остальные числа больше.
[41:29.900 --> 41:33.900]  Тогда как раз я сначала найду минимальное число Y, его удалю из обеих пуч,
[41:33.900 --> 41:36.900]  а дальше здесь будет Y, а здесь не будет.
[41:36.900 --> 41:38.900]  Ну как раз все как надо.
[41:38.900 --> 41:43.900]  На вот этой картинке у меня в одном месте там, не знаю, три палочки и два крестика.
[41:43.900 --> 41:47.900]  Тогда я удалю две палочки и два крестика, и одна палочка останется как раз то, что мне нужно.
[41:54.900 --> 41:56.900]  Здесь мы тоже все показали.
[41:56.900 --> 42:01.900]  Еще одно, я допишу, что это все работает в случае корректности запросов.
[42:01.900 --> 42:06.900]  Это все работает при корректности запросов.
[42:14.900 --> 42:17.900]  То есть что несуществующие элементы не должны удаляться.
[42:24.900 --> 42:28.900]  Несуществующие элементы не должны удаляться.
[42:34.900 --> 42:40.900]  Ну иначе все может сломаться, потому что, например, если у меня вот здесь стоит палочка,
[42:40.900 --> 42:44.900]  и где-то левее стоит крестика, которая не соответствует никому добавленному числу.
[42:44.900 --> 42:47.900]  Скажем, не знаю, мы добавили двойку, а удалили единицу.
[42:47.900 --> 42:52.900]  Ну тогда мы эту единицу будем всегда находить, и до этой двойки даже не доберемся.
[42:52.900 --> 42:58.900]  То есть в том случае мы поймем, что первые минимальные элементы различные, поэтому это равен минимум.
[42:58.900 --> 43:02.900]  Но возможно и не так, потому что двойка тоже удалена, а, скажем, тройка остается.
[43:02.900 --> 43:06.900]  И это все из-за вот этой фиктивной единицы, которая удаляет несуществующие элементы.
[43:06.900 --> 43:08.900]  Тогда все эти рассуждения не работают.
[43:08.900 --> 43:15.900]  Ну а если же работают, и тогда действительно множество удаленных является под множеством множества добавленных,
[43:15.900 --> 43:16.900]  тогда все корректно.
[43:16.900 --> 43:19.900]  Но мы считаем тогда, что запросы корректные, и такого не возникает.
[43:24.900 --> 43:25.900]  Хорошо.
[43:28.900 --> 43:29.900]  Тогда идем дальше.
[43:36.900 --> 43:37.900]  Да.
[43:44.900 --> 43:45.900]  Да.
[43:51.900 --> 43:52.900]  Да.
[43:55.900 --> 43:56.900]  Да.
[43:59.900 --> 44:04.900]  Ну опять, если у нас есть какая-то верхняя оценка, начало запроса, можно завести массив такого размера.
[44:04.900 --> 44:10.900]  Если нет, то у нас сегодня же будет структура данных вектор, которая как раз умеет это делать.
[44:10.900 --> 44:12.900]  Она умеет добавлять элементы в конец.
[44:17.900 --> 44:23.900]  Так, давайте я здесь еще расскажу про вообще другие реализации куч.
[44:23.900 --> 44:26.900]  То есть мы вот рассмотрели сейчас конкретно только бинарную кучу, двоичную кучу,
[44:26.900 --> 44:31.900]  которая по сути на все отвечает за логарифом, кроме того, что гитмин может зовут единиц.
[44:31.900 --> 44:40.900]  Есть куча других еще реализаций куч, которые, возможно, в некоторых местах достигают лучшей асимптотики.
[44:40.900 --> 44:44.900]  Но все там точно не будет от единицы и в инсерте, и в экстракт-мини,
[44:44.900 --> 44:49.900]  потому что мы доказали, что не может быть и того, и того одновременно, если это нормальная куча на сравнении.
[44:50.900 --> 44:52.900]  Есть, например, куча фибоначи,
[44:57.900 --> 45:03.900]  которая позволяет делать декрески за от единицы амортизировано.
[45:09.900 --> 45:12.900]  Мы вот сегодня посмотрим, что значит амортизировано.
[45:12.900 --> 45:21.900]  Но, грубо говоря, можно считать, что каждый декрески выполняется как бы в среднем за от единицы.
[45:21.900 --> 45:28.900]  То есть, возможно, каждый конкретный декрески работает и долго, может потребовать большого количества операций.
[45:28.900 --> 45:31.900]  Но если вы их делаете много, скажем, если вы суммарно сделаете n операций,
[45:31.900 --> 45:34.900]  то суммарно все эти декрески будут работать за от n.
[45:34.900 --> 45:39.900]  Это вот как раз такая учетная стоимость, что каждая конкретная, возможно, работает долго,
[45:39.900 --> 45:41.900]  но суммарно они все работают за от n.
[45:41.900 --> 45:47.900]  Вы там сделали n раз декрески, и тогда суммарно они работают за от n, хоть каждая конкретная может работать долго.
[45:47.900 --> 45:57.900]  Ну а все остальное, все остальные, за от логен амортизировано.
[46:02.900 --> 46:06.900]  И тогда с помощью такой кучи фибоначи мы ее, наверное, рассматривать не будем,
[46:06.900 --> 46:12.900]  но с ее помощью можно некоторые алгоритмы, по крайней мере, в теории улучшить на них эту точку.
[46:12.900 --> 46:17.900]  Вот, например, я в прошлый раз говорил, что будет у нас когда-то алгоритм Dijkstra.
[46:17.900 --> 46:23.900]  Алгоритм Dijkstra. Нам не нужно понимать пока что, что это такое.
[46:23.900 --> 46:26.900]  Можно просто сказать, что это какой-то алгоритм на графе.
[46:26.900 --> 46:29.900]  У нас дан граф с n вершинами и n ребрами.
[46:29.900 --> 46:32.900]  С n вершинами и m ребрами.
[46:36.900 --> 46:49.900]  И в процессе нашего алгоритма, в процессе алгоритма Dijkstra, мне нужно сделать m раз декрески, куча, m раз декрески и n раз экстракт-мин.
[46:52.900 --> 46:59.900]  Еще раз повторюсь, нам пока что не обязательно понимать, как работает алгоритм Dijkstra, но если вы это знаете, то сейчас будет хорошо.
[47:00.900 --> 47:05.900]  Там нам важно, что нам нужна какая-то структура данных, которая умеет делать все, что умеет куча.
[47:05.900 --> 47:08.900]  Вот этот декреский, экстракт-мин, get-мин, insert и так далее.
[47:08.900 --> 47:13.900]  И в ней нужно m раз делать декрес и n раз делать экстракт-мин.
[47:13.900 --> 47:19.900]  И тогда, смотрите, обычная бинарная куча справится со всем этим за логарифом.
[47:19.900 --> 47:24.900]  Потому что что декреский там работал за логарифом, что экстракт-мин работал за логарифом.
[47:24.900 --> 47:30.900]  Поэтому асимптотика, если мы будем использовать бинарную кучу алгоритма Dijkstra, у меня будет асимптотика n плюс m на лог n.
[47:34.900 --> 47:41.900]  А если мы используем кучу Fibonacci, то у меня будет асимптотика m плюс n лог n.
[47:55.900 --> 48:01.900]  Потому что, еще раз, у меня декреский как раз за от единицы работает амортизировано.
[48:01.900 --> 48:05.900]  В том смысле, что если мы сделаем много операций, то можно считать, что каждый работает за от единицы.
[48:05.900 --> 48:08.900]  То есть, суммарно, вот эти вот все декрески работают за от m.
[48:08.900 --> 48:15.900]  Плюс еще log раз, извините, n раз нужно за логарифмическое время сделать экстракт-мин, тоже амортизировано.
[48:15.900 --> 48:18.900]  В сумме это даст добавку n лог n.
[48:18.900 --> 48:26.900]  И в случае, когда у нас, например, m сильно больше, чем n, у меня куча Fibonacci позволяет сделать алгоритм Dijkstra быстрее.
[48:26.900 --> 48:32.900]  То есть, здесь у меня m умножалось на логарифм, а здесь m идет просто линейно и без умножения на логарифм.
[48:32.900 --> 48:40.900]  То есть, получается, в зависимости от того, как именно вы эту кучу реализуете, у вас разные другие алгоритмы будут, возможно, работать быстрее.
[48:40.900 --> 48:42.900]  Ну, по крайней мере, с точки зрения теоретической оценки.
[48:43.900 --> 48:48.900]  Проблема кучи Fibonacci как минимум в том, что там очень большая скрытая константа, там нужно очень много всего хранить.
[48:48.900 --> 48:52.900]  Она гораздо гораздо объемнее, чем наша бинарная куча, которая на массиве, по сути, хранится.
[48:52.900 --> 48:54.900]  Там нужно гораздо больше всего хранить.
[48:54.900 --> 48:57.900]  Поэтому здесь константа в большом, к сожалению, сильно большая.
[48:57.900 --> 49:02.900]  И не всегда на практике это будет лучше, чем вот это.
[49:03.900 --> 49:12.900]  Но, тем не менее, с точки зрения теории или для очень больших NM, когда компьютеры ускорятся в тысячи, десятки тысяч раз, вот это будет лучше, чем вот это гарантированно.
[49:24.900 --> 49:28.900]  А сейчас давайте рассмотрим еще одну кучу, биномиальную.
[49:29.900 --> 49:31.900]  Биномиальная куча.
[49:34.900 --> 49:38.900]  Вот, и раз это куча, то она, конечно, умеет делать все, что умеет делать бинарная куча.
[49:38.900 --> 49:41.900]  Давайте мы восстановим все эти действия.
[49:41.900 --> 49:50.900]  Insert, get mean, extract mean, decrease key.
[49:50.900 --> 50:00.900]  Если постараться, то можно также сюда добавить erase, потому что мы можем хранить дополнительную кучу удаленных элементов.
[50:00.900 --> 50:04.900]  Но здесь еще появляется новое действие, здесь появляется действие merge.
[50:04.900 --> 50:07.900]  Слить две кучи, объединить две кучи в одну.
[50:07.900 --> 50:12.900]  То есть представьте, что у вас было какие-то две кучи, и вам пришел запрос, что нужно их объединить в одну.
[50:12.900 --> 50:19.900]  То есть построить какую-то новую кучу, которая хранит информацию обо всех этих элементах по одному разу и только их.
[50:19.900 --> 50:23.900]  Каждый элемент отсюда, который вы переместите туда в один большой список.
[50:23.900 --> 50:29.900]  Продолжая нашу странную метафору с заводом, у вас два завода объединились,
[50:29.900 --> 50:33.900]  а им нужно все еще сделать те же самые запросы, обработать те же самые заказы,
[50:33.900 --> 50:38.900]  но вот они их сваливают в одну кучу и опять обрабатывают теперь уже всем новым большим заводом вместе.
[50:40.900 --> 50:44.900]  Вот, то есть новость только то, что появляется merge.
[50:45.900 --> 50:52.900]  Это во-первых, это куча более мощная, поскольку позволяет делать merge за эффективно, то есть мы это будем довольно быстро делать.
[50:52.900 --> 50:58.900]  И во-вторых, у меня будет такое, что она на самом деле нужна, чтобы по ней построить кучу фибоначи.
[50:58.900 --> 51:01.900]  Она дает способ построить кучу фибоначи.
[51:04.900 --> 51:09.900]  То есть фибоначи очень сильно базируются на том, что мы сейчас будем делать, но мы туда не пойдем.
[51:14.900 --> 51:15.900]  Окей.
[51:15.900 --> 51:20.900]  Чтобы определить, что такое биномиальная куча, мы сначала определим биномиальное дерево.
[51:22.900 --> 51:23.900]  Биномиальное дерево.
[51:26.900 --> 51:27.900]  Порядка К.
[51:29.900 --> 51:30.900]  Порядка К.
[51:32.900 --> 51:36.900]  Биномиальное дерево порядка ноль, это вот такое дерево, просто одна вершина.
[51:37.900 --> 51:40.900]  Биномиальное дерево порядка один, это вершина с одним сыном.
[51:42.900 --> 51:45.900]  Биномиальное дерево порядка два, это вершина с одним сыном,
[51:47.900 --> 51:50.900]  в которой еще присоединено то же самое дерево, вершина с одним сыном.
[51:51.900 --> 51:53.900]  Ну и давайте Т3 еще нарисую.
[51:53.900 --> 51:54.900]  Вот, кажется так.
[51:57.900 --> 52:02.900]  В общем случае формула такая, если у вас есть дерево ткта
[52:04.900 --> 52:08.900]  с каким-то корнем, то вы можете внести его в кучу фибоначи.
[52:10.900 --> 52:16.900]  В общем случае, если у вас есть дерево ткта, то вы можете внести его в кучу фибоначи.
[52:16.900 --> 52:18.900]  Вот формула такая, если у вас есть дерево ткта
[52:21.900 --> 52:26.900]  с каким-то корнем, то вы можете к этому же корню подвести еще одного сына и здесь подвести еще одну ткта.
[52:27.900 --> 52:28.900]  Вот здесь ткта и здесь ткта.
[52:29.900 --> 52:30.900]  И все это вместе будет тк плюс первое.
[52:34.900 --> 52:37.900]  То есть если у вас есть дерево катового порядка, вот такое,
[52:38.900 --> 52:40.900]  вы просто его дублируете и подвешиваете один из корней к другому.
[52:41.900 --> 52:42.900]  И это будет дерево следующего ка плюс первого порядка.
[52:43.900 --> 52:44.900]  Ну и все вот эти получается ровно так.
[52:45.900 --> 52:48.900]  Ну например, у вас есть дерево нулевого порядка, вот это,
[52:49.900 --> 52:53.900]  и вот дерево нулевого порядка, вот это, вы одно подвесите к другому и получаете дерево первого порядка.
[52:55.900 --> 52:58.900]  То-что самое здесь. Вот есть дерево первого порядка, вот есть дерево первого порядка,
[52:59.900 --> 53:01.900]  вы одно подвесите к другому и получаете Т2.
[53:02.900 --> 53:07.900]  Ну и тут, раз, два, и одно подвесите к другому.
[53:11.900 --> 53:12.900]  Почему они биномиальные?
[53:12.900 --> 53:21.900]  потому что, например, на m уровне
[53:21.900 --> 53:24.900]  дерева tk
[53:30.660 --> 53:36.460]  находится t из m пока вершин.
[53:38.300 --> 53:40.460]  Так, я надеюсь, что вот это обозначение всем знакомо.
[53:40.460 --> 53:47.380]  Если нет, то на семинарах. Вот эта задача про количество вершин на каком-то уровне в
[53:47.380 --> 53:53.900]  катом дереве, что это какой-то биномиальный коэффициент, она будет на семинарах.
[53:53.900 --> 53:58.380]  Попросите у семинаристов объяснить, что это такое, если не знаете. Вот, но эти цешки
[53:58.380 --> 54:02.620]  как раз и называются биномиальными коэффициентами. Они возникают, если вы там
[54:02.620 --> 54:10.220]  возводите в степень какую-нибудь сумму. А плюс б в степени n, вот известный бином
[54:10.220 --> 54:17.140]  ньютона, если вдруг не знакомо, что а в степени k, b в степени n-k на c из n по k.
[54:17.140 --> 54:20.580]  И вот эти вот биномиальные коэффициенты, с помощью которых мы можем раскрыть бином
[54:20.580 --> 54:23.860]  ньютона, они как раз вот здесь и будут. И это называется биномиальные коэффициенты,
[54:23.860 --> 54:31.260]  поэтому дерево тоже биномиальное. Так, ну хорошо, вот мы определили, что такое дерево.
[54:31.260 --> 54:37.580]  Ну и мы в вершинах этого дерева будем хранить наши элементы. В вершинах деревьев, в вершинах
[54:37.580 --> 54:48.980]  дерева храним элементы. Элементы нашего мульти-множества, которые мы добавляем.
[54:48.980 --> 54:54.540]  Мульти-множество. Которым мы работаем, там удаляем, добавляем и так далее. Уменьшаем.
[54:54.540 --> 55:00.260]  Вот. Опять, если у меня есть дерево, то у меня возникает требование кучи,
[55:00.260 --> 55:04.860]  это что каждое число, записанное в вершине, должно быть меньше либо равно, чем все,
[55:04.860 --> 55:11.740]  что написано в поддереве. То же самое, что было в бинарной куче. Требование кучи.
[55:11.860 --> 55:33.820]  Число, записанное в вершине, в вершине В, не превосходит чисел, записанных в поддереве В.
[55:33.820 --> 55:45.460]  Вот. И картинка будет такая же, как раньше, что число, написанное в родителе, должно быть меньше
[55:45.460 --> 55:50.660]  либо равно, чем все числа в детях. Только теперь детей может быть больше, чем два. Вот уже на этой
[55:50.660 --> 55:55.060]  картинке у вершинки есть три ребенка, в Т4 будет четыре ребенка и так далее. Поэтому у меня
[55:55.060 --> 55:59.740]  возникает больше неравенств. Но смысл такой же. Число, написанное вот здесь, должно быть меньше
[55:59.740 --> 56:13.380]  либо равно, чем все числа в детях. Вот так. Требование кучи. Ну и, наконец, биномиальная куча.
[56:20.900 --> 56:26.540]  Это набор биномиальных деревьев, причем все они попарно различных порядков.
[56:30.740 --> 56:32.340]  Набор биномиальных деревьев
[56:40.740 --> 56:42.300]  попарно различных порядков.
[56:50.020 --> 56:55.740]  Ну, например, у вас может быть Т2 и Т3. Это корректная биномиальная куча. То есть у вас есть
[56:55.740 --> 57:06.900]  отдельно дерево Т2 лежит, отдельно Т2, отдельно Т3. Они вместе образуют корректную биномиальную
[57:06.900 --> 57:16.420]  кучу. А если, например, у вас есть две одинаковые, там не знаю, Т1, Т3 и Т3, это уже не корректная
[57:16.420 --> 57:20.580]  биномиальная куча, потому что есть две кучи одинакового порядка, с одинаковым индексом. Извините,
[57:20.580 --> 57:30.860]  два дерева с одинаковым индексом мы такое запрещаем себе. Какой в этом смысл? На самом
[57:30.860 --> 57:36.860]  деле, вот это вот разложение по деревьям, разложение биномиальной кучи по биномиальным
[57:36.860 --> 57:42.460]  деревьям, оно соответствует разложению в двоичную систему исчисления числа n элементов в куче.
[57:42.460 --> 57:47.820]  Потому что, смотрите, легко заметить, что вот, скажем, катом деревя у меня всего два степенька
[57:47.820 --> 58:00.700]  вершин. В дереве ТК содержится два вкаты вершин. Ну, это совсем легко понять, потому что, если у
[58:00.700 --> 58:05.660]  вас здесь два степенька, то чтобы получить ТФ степенька при степеньке, вы сливаете два дерева
[58:05.660 --> 58:09.780]  одинакого размера, получаете дерево в два раза больше, как раз два в ка плюс первый. Это совсем
[58:09.780 --> 58:15.340]  простое утверждение. Но тогда как раз у вас вот здесь два во второй элементов, тут два в третьей
[58:15.340 --> 58:20.700]  и так далее. И если все эти порядки попарно различны, то это как раз разложение в двоичную систему,
[58:20.700 --> 58:25.660]  то есть по степеням двойки, общего числа элементов. Да, если, например, у вас, то есть вот здесь сколько?
[58:25.660 --> 58:30.180]  Четыре плюс восемь. Если у вас всего в куче двенадцать элементов, то они раскладываются следующим
[58:30.180 --> 58:35.020]  образом. У вас есть дерево на четырех элементах, дерево на восьми элементах. И так для любого n.
[58:35.020 --> 58:45.780]  Да, ну то есть какая-то часть, просто какие-то четыре будут здесь, какие-то восемь будут здесь.
[58:45.780 --> 58:51.620]  Они произвольны, нам не важно, как они распределяются по деревьям, нам лишь важно,
[58:51.620 --> 58:55.420]  что они все где-то здесь присутствуют. Ну тогда, например, чтобы найти минимум,
[58:55.420 --> 58:59.500]  нужно просто посмотреть на минимальное значение в каждой из деревьев, в каждом.
[58:59.500 --> 59:07.540]  Ну их не может быть очень много, потому что у них размер экспенциально растется номером.
[59:07.540 --> 59:10.300]  Чем больше k, тем сильно больше.
[59:10.300 --> 59:30.300]  Ну если у числа в двоечной записи n единиц, то оно хотя бы само по себе уже два в степени n.
[59:30.300 --> 59:37.460]  И в нем будет n деревьев. Мы сейчас все докажем, это все нормально будет работать. Мы все докажем
[59:37.460 --> 59:44.420]  обязательно. И так, вот у меня есть несколько деревьев, и суммарно их размеры равны в точности n,
[59:44.420 --> 59:50.660]  то есть по сути это разложение n по степеням двойки. И мы будем их хранить вот в таком
[59:50.660 --> 59:55.740]  возрастающем порядке, в порядке возрастания этих индексов, в порядке возрастания номеров,
[59:55.740 --> 01:00:02.100]  точнее порядков всех деревьев. Тогда давайте понимать, как обрабатывать, скажем, самый простой
[01:00:02.180 --> 01:00:09.980]  вопрос GetMin. Как обрабатывать GetMin? Ну мы сказали уже, что каждый элемент лежит ровно в одном из
[01:00:09.980 --> 01:00:14.660]  этих деревьев, и если мне нужно найти самый маленький элемент среди всех, то мне достаточно
[01:00:14.660 --> 01:00:19.860]  посмотреть на самый маленький в каждом из деревьев и среди них выбрать минимум. Вот если у меня есть
[01:00:19.860 --> 01:00:24.780]  всего две кучи, то мне нужно посмотреть минимум вот здесь, минимум вот здесь, и взять из них
[01:00:24.780 --> 01:00:29.500]  самое маленькое. Ну потому что если у меня весь список разбит на непредсекающие корзинки,
[01:00:29.500 --> 01:00:35.540]  то минимум во всем массиве это минимум среди минимумов во всех корзинках. Поэтому тут можно
[01:00:35.540 --> 01:00:40.060]  сделать следующее. Ну давайте я не буду писать код, я скажу, что просто словами, да, найти
[01:00:43.900 --> 01:00:44.700]  минимальный,
[01:00:48.100 --> 01:00:48.820]  минимальный
[01:00:52.380 --> 01:00:55.620]  корень среди всех деревьев.
[01:00:59.940 --> 01:01:10.380]  среди всех деревьев. И это опять будет работать, потому что, так сейчас, а это опять будет работать,
[01:01:10.380 --> 01:01:14.820]  потому что в каждом дереве минимум обязательно в корнях из-за требования кучи, да, требования
[01:01:14.820 --> 01:01:18.580]  кучи, в частности, мне говоришь, что минимальное число в дереве всегда находится в его корне,
[01:01:18.580 --> 01:01:23.140]  и тогда если у меня корень каждого дерева это минимальное число, то я просто прохожу по всем
[01:01:23.140 --> 01:01:30.340]  корням и беру самое маленькое. Да? Вот, а сколько это работает? Ну, смотрите, если всего в куче
[01:01:30.340 --> 01:01:48.580]  n элементов, если всего в куче n элементов, то какие порядки деревьев допустимы? Да? Да, да, да. Ну,
[01:01:48.580 --> 01:01:51.860]  каждый элемент ровно один раз присутствует, поэтому суммарный размер всех деревьев, он, конечно,
[01:01:51.860 --> 01:01:58.180]  равен в точности n. Так вот, если всего в куче n элементов, то я утверждаю, что порядки вот этих
[01:01:58.180 --> 01:02:14.100]  вот деревьев, они максимум логарифом, то все деревья в куче имеют порядок не больше, чем, ну,
[01:02:14.100 --> 01:02:20.100]  я напишу так, двоиченалберифмен, округленный вверх, ну, короче, не больше логарифа, потому что мы
[01:02:20.100 --> 01:02:26.260]  знаем, что в катом дереве два вката вершин, даже, даже вниз, даже вниз можно сказать, но неважно,
[01:02:26.260 --> 01:02:33.500]  короче, даже можно вниз, потому что мы знаем, что в дереве порядка k у меня два в степеника вершин,
[01:02:33.500 --> 01:02:38.140]  и это два степеника должно быть меньше броной, чем n, да, потому что, ну, там какие-то элементы же
[01:02:38.140 --> 01:02:42.940]  лежат неповторяющиеся, значит, обязательно это должно быть не больше, чем общее число элементов n,
[01:02:42.940 --> 01:02:47.940]  раз мы еще и по разным деревьям разбросываем, поэтому у них у всех порядок максимум логарифом,
[01:02:47.940 --> 01:02:52.700]  а значит, поскольку у меня все порядки различные, то у меня ноль может встречаться максимум один раз,
[01:02:52.700 --> 01:02:56.660]  единицы максимум один раз, и так далее, вплоть до логарифма, значит, всего деревьев максимум логарифм,
[01:02:56.660 --> 01:03:08.220]  всего деревьев куча, куча, не больше, чем логарифм, не больше, чем двоиченалберифмен, ну, а значит,
[01:03:08.220 --> 01:03:12.900]  вот этот проход по корням, он работает за логарифм, я просто перебираю все, все деревья,
[01:03:12.900 --> 01:03:21.780]  нахожу у них, ну, смотрю на корень, и выбираю средних минимум, это работает за логарифм. Согласны?
[01:03:21.780 --> 01:03:41.660]  Кажется, что да. Хорошо, get mean мы обработали. Дальше decrease key, давайте возьмем decrease key,
[01:03:41.660 --> 01:03:47.100]  ну, здесь опять вот эта вот дилемма насчет того, как именно указатель нам задается,
[01:03:47.100 --> 01:03:52.340]  давайте в простом случае, когда нам прям тыкают на вершинку, которую нужно уменьшить. Вот нам
[01:03:52.340 --> 01:03:58.340]  тыкнули на вершинку, которая находится в позиции ptr, и нужно уменьшить ее значение на дельту. Ну,
[01:03:58.340 --> 01:04:02.700]  тогда все абсолютно точно так же, как было в бинарной куче. Вот есть у вас число какое-то,
[01:04:02.700 --> 01:04:09.580]  вам нужно его уменьшить, было какое-то x, нужно превратить его в x-delta. Тогда, чтобы сохранилось
[01:04:09.580 --> 01:04:13.460]  требование кучи, мне нужно просто это число поднимать до тех пор, пока все не подчинится.
[01:04:13.460 --> 01:04:17.020]  То есть, по сути, мне нужно просто запустить тот же самый сифтап,
[01:04:17.020 --> 01:04:23.220]  тот же самый сифтап, который поднимает вершинку, то есть сравнивает вершинку с родительской и
[01:04:23.220 --> 01:04:29.460]  меняет значение, пока у меня не начнется выполняться эта неравенство, пока все я не подчиню.
[01:04:29.460 --> 01:04:38.700]  Ну, чего? Нужно еще там аккуратно доказать корректность, но мы аналогично делали в
[01:04:38.700 --> 01:04:42.500]  бинарной куче. Если у меня была корректная куча, одно число уменьшилось, я вызывал сифтап,
[01:04:42.500 --> 01:04:46.860]  то в конце будет корректная куча. Тут то же самое, только у меня дерево как бы не бинарное,
[01:04:46.860 --> 01:04:51.980]  а сколько угодно ветвящееся. У вершинки может быть много сыновей, но это неважно,
[01:04:51.980 --> 01:04:57.940]  это не влияет на корректность нашего доказательства. Сифтап все равно даст нам в конце корректную кучу.
[01:04:57.940 --> 01:05:07.460]  За сколько это работает? Ну, это работает за глубину дерева. Работает за глубину дерева,
[01:05:07.460 --> 01:05:12.380]  но легко тоже видеть, что вот эти деревья, как мы строим ткт, у катого дерева глубина ровно к,
[01:05:12.380 --> 01:05:17.540]  потому что мы там взяли катое дерево. Чтобы получить к плюс первым, мы взяли ткт,
[01:05:17.540 --> 01:05:28.180]  мы взяли ткт, подвесили к его корню еще одно ткт. Получается, что если здесь глубина была к,
[01:05:28.180 --> 01:05:35.020]  то здесь глубина как раз на один побольше. Здесь как раз глубина на один побольше.
[01:05:35.020 --> 01:05:41.140]  То есть глубина ровно такая же, как порядок. А значит, если мы возвращаемся сюда, у меня все
[01:05:41.140 --> 01:05:45.820]  порядки максимум логарифм, поэтому глубина тоже вся максимум логарифм. В итоге дикризки тоже
[01:05:45.820 --> 01:05:53.980]  работают за отлогом. Понятно? Ну, просто за глубину, а глубина максимум логарифм.
[01:05:53.980 --> 01:06:04.780]  Так, get mean. Сделали, все сделали. Теперь давайте мерч обсудим. Давайте мерч обсудим.
[01:06:04.780 --> 01:06:15.580]  Как я предполагаю, что реализуется мерч? У меня есть какие-то две кучи, h1, h2, две кучи,
[01:06:15.580 --> 01:06:22.180]  каждый из которых это набор биноминальных деревьев. И мне нужно их слить в один набор
[01:06:22.180 --> 01:06:27.900]  вот этих самых деревьев. Идеальный случай — это когда деревья вот здесь и вот здесь имеют попарно
[01:06:27.900 --> 01:06:35.700]  различные порядки. Ну скажем, не знаю, здесь порядки 1 и 3, здесь порядки, тут 1 и 4, тут 2 и 3. Тогда они
[01:06:35.700 --> 01:06:40.660]  просто, ну, то есть их нужно в правильном порядке расположить, и будет вам корректная куча. Да,
[01:06:40.660 --> 01:06:46.660]  ничего не нужно там, ничего не ломается. У меня все еще все порядки различны. Это хорошо. Но иногда,
[01:06:46.660 --> 01:06:50.900]  конечно, может быть такое, что здесь бывают кучи одинаково, деревья одинакового порядка, скажем,
[01:06:51.180 --> 01:06:57.940]  две двойки лежат. У меня будут бывать деревья одинакового порядка. Но с ними не очень сложно
[01:06:57.940 --> 01:07:04.860]  побороться. Если у меня есть два дерева одного порядка, давайте мы посмотрим, у кого из них число
[01:07:04.860 --> 01:07:10.020]  в корне меньше. Ну скажем, у вот этого. Давайте здесь a, здесь b, и считаем, что a меньше, чем b.
[01:07:10.020 --> 01:07:18.860]  Ну меньше, примерно, чем b. Тогда я могу просто подвесить второе дерево к первому, то есть вот этот
[01:07:18.860 --> 01:07:31.540]  корень подвесить сюда, тем самым получив дерево t3. Я слил два дерева одного порядка, подвесив один из
[01:07:31.540 --> 01:07:36.260]  корней к другому, тем самым получает дерево следующего порядка t3. Это просто по построению,
[01:07:36.260 --> 01:07:42.060]  у меня так строятся деревья. И получаю опять корректную кучу, потому что единственное новое
[01:07:42.060 --> 01:07:47.380]  требование кучи, которое добавляется, это вот это соотношение, что корень должен быть меньше
[01:07:47.380 --> 01:07:51.900]  либравен, чем его вот этот правый сын. Но это выполнено по предположению, я к меньшему как раз числу
[01:07:51.900 --> 01:07:58.100]  и довешиваю второй корень. Поэтому это будет корректное биномиальное дерево, то есть, ну,
[01:07:58.100 --> 01:08:02.060]  во-первых, у него структура правильная, потому что я деревья одинаково порядка слил. Во-вторых,
[01:08:02.060 --> 01:08:07.660]  там будет не нарушаться требование кучи, оно будет выполнено. Итак, мы сделаем со всеми
[01:08:07.660 --> 01:08:12.940]  совпадающими парами. Вот было у меня две двойки, я их слил, получил следующую. Там было две тройки,
[01:08:12.940 --> 01:08:19.180]  я их тоже слил, получил следующую. И так сделаю как бы со всеми конфликтами, в итоге у меня будет
[01:08:19.180 --> 01:08:25.780]  дерево как бы без проблем, все одинаковые, все совпадающие деревья я склею, получу такой
[01:08:25.780 --> 01:08:34.140]  непересекающийся набор деревьев, у них у всех разные будут порядки. Вот, и по сути это то же
[01:08:34.140 --> 01:08:39.140]  самое, как если бы мы складывали вот эти два числа просто в столбик вдовечной записи. Мы понимаем,
[01:08:39.140 --> 01:08:44.780]  что вот это что значит. Это значит, что в этой куче 2 в первый плюс 2 в четвертый вершин, ну и там
[01:08:44.780 --> 01:08:51.540]  элемент. Здесь 2 в квадрате плюс 2 в третий элемент. И если бы мы представили это там
[01:08:51.540 --> 01:08:57.780]  числом вдовечной записи, и вот второе число тоже также представили, и потом сложили, то у меня
[01:08:57.780 --> 01:09:04.020]  возможно где-то будут две единички. Это как раз значит, что у меня вот эта степень двойки входит
[01:09:04.020 --> 01:09:10.540]  и сюда и сюда в разложение n1 и n2 размеров куч. Ну и как раз при сложении у меня вот эти вот две
[01:09:10.540 --> 01:09:16.380]  кучи как бы объединятся, тут станет нолик, а здесь станет единичка. Сюда перенесется единица,
[01:09:16.380 --> 01:09:22.220]  как это, перенос, будет перенос из предыдущего разряд. Здесь то же самое, если скажем, у меня
[01:09:22.220 --> 01:09:28.300]  здесь было 0,1, тогда у меня вот эта единица склеится вот с этой единицей, тут будет нолик,
[01:09:28.300 --> 01:09:33.700]  и еще единица перенесется в следующий разряд. И это вот как раз моделирует ровно то, что мы
[01:09:33.700 --> 01:09:38.380]  будем делать. Мы берем деревья совпадающих порядков, то есть две единички в одном разряде,
[01:09:38.380 --> 01:09:42.580]  сливаем их в дерево следующего порядка, переносим его в следующее, а тут пишем нолик,
[01:09:42.580 --> 01:09:52.740]  то есть два дерева мы как бы убили и получили одно новое. Вот такой алгоритм. Давайте попробуем
[01:09:52.740 --> 01:10:06.460]  его написать. Ну так, не очень подробно, но все же. Будем считать, что у меня есть в h1 какой-то
[01:10:06.460 --> 01:10:20.340]  список деревьев. Не знаю там, первая с индексами от 0 до логи. И во втором дереве тоже есть список
[01:10:20.340 --> 01:10:32.780]  деревьев от 0 до алгоритма. И соответственно, там каждое дерево это либо ну какой-нибудь там
[01:10:32.780 --> 01:10:38.940]  нулевой указатель или фиктивное значение, минус 1 скажем, либо это вот номер вершины корня,
[01:10:38.940 --> 01:10:46.180]  что-нибудь такое. Тогда как будет у меня происходить слияние? Я прохожусь, нет,
[01:10:46.180 --> 01:10:51.940]  давайте я сначала заведу переменную переноса к эри, у меня там будет минус 1.
[01:10:51.940 --> 01:11:02.940]  Ну да, минус 1, то есть как бы нет переноса, и у меня в переносе не хранится никакое дерево.
[01:11:02.940 --> 01:11:12.100]  Вот давайте так сделаем. Потом я иду по и от 0 до чего, ну может быть до алгоритма плюс 1,
[01:11:12.100 --> 01:11:18.020]  нам возможно придется увеличить количество ячеек, потому что если здесь они скажем все
[01:11:18.020 --> 01:11:22.340]  заполнены, здесь все заполнены и мы их сливаем, то мне придется следующий разряд тоже использовать.
[01:11:22.340 --> 01:11:26.820]  Когда я складываю два числа одной длины, мне возможно придется увеличить длину на единицу.
[01:11:26.820 --> 01:11:36.500]  Вот и теперь смотрите, у меня есть три объекта, у меня есть T1 и T, у меня есть T2 и T и у меня есть
[01:11:36.500 --> 01:11:41.660]  кэри, у меня есть перенос из предыдущего разряда. Какие-то из них это настоящие деревья,
[01:11:41.660 --> 01:11:48.380]  а остальные это минусы дницы как знак того, что нет такого дерева, то есть скажем либо перенос
[01:11:48.380 --> 01:11:56.300]  пришел пустой, либо в одной из куч не было такого дерева. И моя цель следующая, вот из этих трех
[01:11:56.300 --> 01:11:59.900]  деревьев, то есть какие-то из них фиктивные пустые деревья, которые не нужно рассматривать,
[01:11:59.900 --> 01:12:05.780]  и из оставшихся мне нужно, если их два, их нужно склеить, склеить, перенести в следующий разряд.
[01:12:05.780 --> 01:12:19.220]  Да, не просто упорядоченные, мы считаем, что нам, ну то есть для каждого вот это вот порядка,
[01:12:19.220 --> 01:12:25.100]  там для каждого K, у меня хранится указатель на кучу порядка K, либо сообщение о том, что нет
[01:12:25.100 --> 01:12:29.180]  кучи порядка K, то есть не просто упорядоченные, но и вот для каждого порядка хранится,
[01:12:29.180 --> 01:12:34.100]  то есть для каждого номера хранится куча с таким номером, или указатель, что ее нет.
[01:12:34.100 --> 01:12:43.180]  Ну вот это минусы дницы. Ну это зависит от реализации того, что мы понимаем под деревом.
[01:12:43.180 --> 01:12:54.460]  Здесь можно говорить, что у меня там T2 от K, это номер вершины дерева TK, номер вершины корня вот
[01:12:54.700 --> 01:13:03.380]  вот. Это будет там TKT. И в случае, если это настоящее дерево, которое присутствует в разложении N по
[01:13:03.380 --> 01:13:08.980]  степням двойки, то это будет просто номер вот этой вершинки. А если этого дерева нету, то есть нету
[01:13:08.980 --> 01:13:13.180]  два вкаты в разложении N по степням двойки, ну там будет минус один. То есть либо нормальное дерево,
[01:13:13.180 --> 01:13:17.020]  ну там, скажем, указатель на корень, либо минус один как знак того, что это дерево не
[01:13:17.020 --> 01:13:21.700]  участвует, его там нет. Ну, соответственно, вот здесь это либо нормальное дерево
[01:13:21.700 --> 01:13:25.980]  текущего там и этого порядка, либо это минус 1 как знак того, что ничего не
[01:13:25.980 --> 01:13:30.300]  пришло. Ну, то есть вот нолик, да, вот здесь. Если здесь был нолик, то у меня там
[01:13:30.300 --> 01:13:36.500]  будет минус 1, а если 1, то указательное дерево. Вот так. Вот, в итоге у меня есть
[01:13:36.500 --> 01:13:40.780]  три дерева, какие-то из них, возможно, не существующие, и мне нужно, если среди них
[01:13:40.780 --> 01:13:44.780]  есть хотя бы две не минус 1, то есть если два настоящих дерева есть, мне нужно их
[01:13:44.780 --> 01:13:52.220]  склеить и перенести в следующий разряд. Ну, и давайте скажем, что t0 и так далее, t
[01:13:52.220 --> 01:14:05.500]  log n плюс 1 это результат. Результат. Так, так, так, так, так.
[01:14:06.900 --> 01:14:13.060]  Ну, тут нужно аккуратно все разобрать. Давайте скажем, что если те три дерева
[01:14:13.060 --> 01:14:22.420]  настоящие, те три дерева есть. То есть это значит, вот здесь была единица здесь,
[01:14:22.420 --> 01:14:25.420]  единица здесь, и еще единица с того разряда пришла. То есть у меня есть сейчас три
[01:14:25.420 --> 01:14:32.740]  дерева одного порядка t0. Есть три вот таких дерева. Тогда я делаю следующее. Я два
[01:14:32.740 --> 01:14:37.060]  из них склеиваю, превращаю в дерево и плюс первого порядка, а одну из них
[01:14:37.060 --> 01:14:46.460]  оставляю как раз t0. Можно написать так, значит t и t это, например, там query пусть будет. То есть
[01:14:46.460 --> 01:14:51.700]  я то, что мне пришло с предыдущего разряда, сохранил здесь, а дальше в query то, что я переношу
[01:14:51.700 --> 01:15:04.100]  в следующий, я напишу объединение t1 и t2 и t. Там merge. Ну, давайте не merge плохо, потому что
[01:15:04.700 --> 01:15:26.980]  так функция называется. Unite давайте. Unite t1 и t, t2 и t. То есть я то, что пришло с предыдущего
[01:15:26.980 --> 01:15:32.020]  разряда, сохранил в этой позиции, а те, которые сейчас у меня вот эти две единички стоят, я их
[01:15:32.020 --> 01:15:43.660]  сложил и переношу в следующий, перезаписываю в query. Дальше, если у меня всего два дерева,
[01:15:43.660 --> 01:15:55.100]  есть два дерева из трех, тогда что это значит? У меня пришло два дерева, то есть среди вот этих
[01:15:55.100 --> 01:16:00.340]  вот трех потенциальных единиц, раз два и три, которые перенос, у меня есть всего два, тогда их
[01:16:00.340 --> 01:16:06.880]  сумма будет ноль, то здесь ничего стоять не будет, у меня точно будет t и t равно нулю, равно минус
[01:16:06.880 --> 01:16:11.380]  единицы, то есть в этом разряде ничего не будет. А дальше вот те два нужно склеить и перенести
[01:16:11.380 --> 01:16:19.460]  в и плюс первый. И просто сказать, что query равно unite, ну вот те самые два дерева, которые настоящие,
[01:16:19.460 --> 01:16:29.100]  два дерева. То есть я понимаю, какие именно деревья настоящие, то есть какие деревья существуют,
[01:16:29.100 --> 01:16:32.780]  их объединяю в одно дерево следующего порядка и приношу это с помощью переноса в следующий
[01:16:32.780 --> 01:16:38.860]  разряд. А в этом разряде ничего не пишу, потому что две единички превращаются в нолик в этом
[01:16:38.860 --> 01:16:49.340]  разряде. Ну и наконец, ну два остается, если есть одно дерево из трех, то я его записываю в
[01:16:49.340 --> 01:17:01.300]  teite, да, что teite это то самое дерево, а query я за минус единичиваю. То есть если из трех
[01:17:01.300 --> 01:17:05.340]  деревьев мне пришло только одно, то я его записываю в этом разряде, а переноса не делаю,
[01:17:05.340 --> 01:17:09.780]  потому что у меня не возникает переноса в больший разряд. Ну и в конце, если ноль деревьев,
[01:17:09.780 --> 01:17:17.940]  если ноль деревьев, то я должен и teite сделать пустым, и query сделать пустым.
[01:17:17.940 --> 01:17:33.300]  teite минус единица, query минус единица, вот и на этом все. Чего-чего? Да-да-да, ну действительно,
[01:17:33.300 --> 01:17:37.260]  можно этого не писать, потому что если все действительно все пустые, то query так пустой,
[01:17:37.260 --> 01:17:46.620]  можно тогда, согласен. Это можно как бы не дописывать. Вот, еще раз повторюсь, если что-то из этого
[01:17:46.620 --> 01:17:50.900]  непонятно, мы по сути просто моделируем сложение двух чисел в столбик справа налево. Берем,
[01:17:50.900 --> 01:17:55.540]  у нас есть максимум три бита, которые нам нужно учитывать, бит из первого числа, бит из второго
[01:17:55.540 --> 01:18:03.380]  числа и бит переноса с предыдущего разряда. Мы их все складываем, записываем сюда то, что нужно,
[01:18:03.380 --> 01:18:08.100]  либо одно из этих деревьев, либо слияние каких-нибудь двух деревьев, и переносим,
[01:18:08.100 --> 01:18:17.660]  если нужно, разряд следующий. Вот такой алгоритм merge. Работает это за log n, потому что, собственно,
[01:18:17.660 --> 01:18:25.100]  здесь просто у меня есть цикл от нуля до логарифма, где логарифм – это как раз ограничение начало
[01:18:25.100 --> 01:18:31.460]  порядка в куче, а дальше у меня все вот эти штуки обрабатываются за вот и днице, потому что какие-то
[01:18:31.460 --> 01:18:37.700]  случаи просто… Ну и самое сложное – это unite, как объединить два дерева. Но мы это уже обсуждали,
[01:18:37.700 --> 01:18:42.860]  что нужно просто добавить одно вот такое ребро, просто сказать, что у этой вершинки появляется
[01:18:42.860 --> 01:18:50.940]  один новый сын. Вот это можно сделать за вот и днице. В итоге merge тоже работает за… Ну я напишу так,
[01:18:50.940 --> 01:19:08.460]  о от логарифма n1 plus n2, где n1 – это размер первой кучи, n2 – размер второй кучи. Вот так,
[01:19:08.460 --> 01:19:19.500]  за логарифмом как бы от общего итогового размера обеих куч. Так, и теперь, когда мы сделали самое
[01:19:19.500 --> 01:19:24.820]  сложное, когда мы сделали merge, нам сделать insert и extract-min уже труда не составит.
[01:19:24.820 --> 01:19:35.060]  Insert теперь сделать очень просто – как добавить x в нашу кучу. То есть была какая-то корректная
[01:19:35.060 --> 01:19:42.500]  куча h, к ней добавляется новый элемент x. Самое простое, что можно сделать – это следующее – оставить
[01:19:42.500 --> 01:19:47.740]  в покое кучу h, которая там была несколько деревьев каких-то, завести новую кучу h1,
[01:19:47.740 --> 01:19:56.140]  в которой будет всего одно дерево порядка 0, и в нем будет тот самый x. Заводим новую кучу,
[01:19:56.140 --> 01:20:01.260]  в которой всего одно дерево нулевого порядка, и в вершине этой написано число x. То есть я
[01:20:01.260 --> 01:20:08.220]  просто создавел кучу на одном элементе. А дальше делаю их merge. У меня же есть способ объединить
[01:20:08.220 --> 01:20:15.140]  в совокупность две кучи. Ну вот ровно это мне и нужно сделать. Мне нужно слить вот это вот множество
[01:20:15.140 --> 01:20:20.460]  элементов, с вот этим множеством элементов и построить одну новую большую кучу. Работает за
[01:20:20.460 --> 01:20:25.760]  логарифм от n. Если n, у меня было элементов здесь, и тут появился 1, то мы работаем как бы за
[01:20:25.760 --> 01:20:45.840]  лог от n-то с 1. Это то же самое, что логарем. Понятно? Экстракт мин теперь. Ну мы знаем,
[01:20:45.840 --> 01:20:54.760]  как находить минимум. Нужно пройтись по всем вот этим вот деревьям куча и среди корней выбрать
[01:20:54.760 --> 01:20:58.360]  самое маленькое. Например, вот это вот значение соответствует самому маленькому значению среди
[01:20:58.360 --> 01:21:04.420]  корней. И нам нужно в идеале вот эту вершинку как бы удалить, а всех ее детей, которых тут в
[01:21:04.420 --> 01:21:09.240]  принципе может быть много, потому что дерево уже не обязательно бинарное, нам нужно все вот эти вот
[01:21:09.240 --> 01:21:17.120]  поддеревья как бы добавить в общий набор. Их вот все как бы сюда перенести и сделать такой
[01:21:17.120 --> 01:21:23.220]  набор деревьев. Вот это, вот это, а также все поддеревья вот этой удаленной вершинки. Вот этого
[01:21:23.220 --> 01:21:30.420]  минимума. Вот. Ну и на самом деле мы ровно так и сделаем. Да, мы скажем, что все, то есть эта
[01:21:30.420 --> 01:21:35.140]  вершинка там печатаем, знаем, что это минимум, ее удаляем, освобождаем память, которую она
[01:21:35.140 --> 01:21:41.140]  занимала, а дальше всех ее детей просто добавляем в этот общий список. Ну или альтернативно,
[01:21:41.140 --> 01:21:47.700]  мы в куче h, вот этой вот исходной, удалим дерево, которое соответствует, у которой минимум был вот
[01:21:47.700 --> 01:21:51.940]  этот вот, у которого корень был минимальным значением. Я эту кучу как бы, это дерево целиком
[01:21:51.940 --> 01:21:58.940]  удаляю, а все ее поддеревья заношу в новую отдельную кучу. Вот этих вот все я заношу в
[01:21:58.940 --> 01:22:05.300]  отдельную кучу. И потом вызываем мерч от того, что осталось, то есть исходной кучи без вот этого
[01:22:05.300 --> 01:22:11.100]  дерева, с новой кучей, которая получается из-под деревьев вот этого вот корня, которую мы удалили.
[01:22:11.100 --> 01:22:17.340]  Здесь тоже делаю мерч, и в результате у меня будет как раз объединение всех нужных элементов,
[01:22:17.340 --> 01:22:31.060]  то есть все исходные элементы, кроме минимально удаленного. Это хороший вопрос, да, но на самом
[01:22:31.060 --> 01:22:37.780]  деле будет все ровно так как нужно. Значит, чтобы понять, что это корректно, нам нужно показать,
[01:22:37.780 --> 01:22:51.580]  что вот это будет корректная биномиальная куча, потому что мерч работает только на двух
[01:22:51.580 --> 01:22:56.680]  корректных определенных биномиальных кучах. То есть, во-первых, что здесь все порядки поварно
[01:22:56.680 --> 01:23:00.580]  различны, во-вторых, что здесь выполняется требование кучи, но вообще, что это биномиальные
[01:23:00.580 --> 01:23:06.020]  деревья. Для этого мы докажем следующий простой факт, который следует из построения деревьев
[01:23:06.020 --> 01:23:27.180]  наших. Факт такой, сыновьями корня дерева тк выступают под деревья, соответственно,
[01:23:27.180 --> 01:23:35.020]  всех меньших порядков, порядков t0, 1, 2 и так далее, вплоть до k-1. То есть,
[01:23:35.020 --> 01:23:44.860]  когда я отрезаю у тк-того дерева корень, у меня все распадается на t0, t1, t2 и т.д. от tk-1. И как раз
[01:23:44.860 --> 01:23:49.540]  тогда это будет корректная биномиальная куча, потому что это набор биномиальных деревьев по
[01:23:49.540 --> 01:23:57.180]  пара различных порядков, и тогда их можно склеить с исходной кучей h. Ну, почему это верно,
[01:23:57.180 --> 01:24:01.500]  можно показать по индукции или порисовав в картинке. Значит, вот есть у меня, пусть это,
[01:24:01.500 --> 01:24:12.500]  к сожалению, верно для какого-нибудь k. Тогда как работает тк-1? Тк-1 получается дорисовыванием
[01:24:12.500 --> 01:24:19.660]  корня, корню вот этого тк-того дерева, еще одного тк-того. Но вот в этом исходном дереве у меня
[01:24:19.660 --> 01:24:28.700]  были сыновья t0, t1 и т.д. тк-1 по предположению индукции. А еще я довесил как раз одно новое
[01:24:28.700 --> 01:24:34.100]  тк-т. Поэтому обязательно, если у меня есть дерево tk-1, то у него есть все нужные сыновья в
[01:24:34.100 --> 01:24:42.580]  порядке от 0 до k. Получается корректная куча и все доказано. Получается тоже работа с алгорифом
[01:24:42.580 --> 01:24:47.980]  extract-min, потому что это слияние двух куч. Ну и на этом мы все операции сделаем с алгорифом. Все,
[01:24:47.980 --> 01:24:49.020]  спасибо, до свидания.
