[00:00.000 --> 00:21.520]  И вот сегодня я начну с того, что определю формулы
[00:21.520 --> 00:25.920]  первого порядка, которые описывают этот формализм.
[00:25.920 --> 00:33.240]  Ну, более торжественно сказать формулы логики первого порядка.
[00:33.240 --> 00:44.760]  Значит, определение, похоже на определение булевых формул,
[00:44.760 --> 00:49.120]  нам формулы будут словами, некоторыми специальными словами в алфавите.
[00:49.120 --> 00:54.000]  Ну, какой алфавит? Давайте, я его как-нибудь вот так обозначу,
[00:54.120 --> 00:57.760]  это от слов первого порядка. Пусть будет а, ладно.
[00:57.760 --> 01:05.800]  Значит, алфавит устроен сложно. Я даже не буду писать обычное обозначение множества,
[01:05.800 --> 01:10.800]  а просто буду перечислять, что есть. Есть, во-первых, символы переменных.
[01:10.800 --> 01:26.760]  Я вот тут прямо напишу символы, чтобы их не повторять. Есть предикатные символы.
[01:26.760 --> 01:39.800]  K называется арностью предикатного символа. Есть функциональные символы.
[01:39.800 --> 01:54.360]  Это все символы, одиночные символы алфавита. То же самое. Есть, наконец,
[01:54.360 --> 02:16.200]  константы. И есть специальные знаки. Какие? Ну, во-первых, нам нужны знаки булевых связок.
[02:16.200 --> 02:25.120]  Давайте я перечислю те, которые, по-моему, были для булевых форм. Не очень принципиально.
[02:25.120 --> 02:35.880]  Ну, пусть будет стандартный набор. Символы кланторов, открывающие закрывающие скобки и
[02:35.880 --> 02:42.960]  запятая. Вот из-за того, что запятая, записывать все это дело обычным образом, когда мы перечисляем
[02:42.960 --> 02:47.360]  элементы множества, не очень удобно. То есть, видите, алфавит довольно сложно. Есть некоторое
[02:47.360 --> 03:01.040]  конечное количество специальных знаков и есть, ну так, сколько нужно. Счетное количество символов.
[03:01.040 --> 03:07.720]  Причем про символы мы приписали, какого они сорта. Константа, функциональный символ, предикатный,
[03:07.720 --> 03:14.800]  переменная и про функциональные и предикатные символы еще сказано, какого они арности. И символов
[03:14.800 --> 03:18.840]  каждой арности и функциональных и предикатных сколько угодно. Ну, счетное количество, чтобы
[03:18.840 --> 03:29.160]  не испытывать каких-то проблем. Вот это алфавит. Теперь, исходя из этого алфавита, нужно определить
[03:29.160 --> 03:36.600]  формулы. Но определение, опять-таки, более сложное, чем в случае булевых формул, потому что вначале
[03:36.600 --> 03:44.160]  нужно определить то, что называется термой. Значит, определение рекурсивное. Все определения будут
[03:44.160 --> 03:48.240]  похожи на определение булевых формул. Я вот так подробно про булевые формулы рассказывал,
[03:48.240 --> 03:54.960]  потому что они попроще. А определения все устроены точно так же. Значит, термом является переменная
[03:54.960 --> 04:08.440]  или константа. Это терм длины 1. А также термом является выражение вот такого вида,
[04:08.440 --> 04:34.920]  где f это функциональный символ, а t и t термы. Многоточие здесь, как обычно, я ставлю, чтобы
[04:34.920 --> 04:40.520]  показать, что там просто через запятую перечисляются термы. Тут их должно быть к штук. То есть,
[04:40.520 --> 04:46.840]  типичный терм выглядит так. Вначале имя функционального символа, затем открывающая скобка и
[04:46.840 --> 04:54.120]  внутри пары открывающей и закрывающей скобка просто перечислены через запятую еще какие-то
[04:54.120 --> 05:00.200]  термы. Могут быть перечислены переменные, а могут быть и более сложные термы. И для чего это нужно?
[05:00.200 --> 05:05.720]  Ну, я напомню, в прошлый раз про это заходила речь. В математике постоянно используются какие-нибудь
[05:05.720 --> 05:10.360]  вот такие выражения. Не просто переменные, а какие-то выражения, составленные из функции
[05:10.360 --> 05:17.240]  переменных. Вот чтобы это задать, мы заводим термы. Если функциональных символов, скажем,
[05:17.240 --> 05:21.800]  убрать функциональные символы, то термы останутся только переменные и константы. Но мы их обычно не
[05:21.800 --> 05:32.520]  убираем. Теперь, когда определены термы, можно определить атомарную формулу. Это уже формулы. И
[05:32.520 --> 05:40.000]  термы и формулы — это слова. Но они устроены по-разному. Атомарная формула имеет вид,
[05:40.000 --> 05:49.280]  предикатный символ. И дальше в скобках перечисляются через запятую К термов.
[05:49.280 --> 06:04.800]  Давайте здесь, чтобы не было путаницы с переменными, ножи заменю.
[06:04.800 --> 06:19.200]  Элементарные формулы. Из элементарных. Ну, атомарные или элементарные. Я буду
[06:19.200 --> 06:27.360]  постоянно оговариваться, потому что это синонимы. Атомарными они называются, потому что это атомы,
[06:27.360 --> 06:34.600]  формулы из которых собираются более сложные. Внутри атомарной формулы формул уже нет.
[06:34.600 --> 06:39.680]  Сейчас мы это обсудим чуть подробнее. Давайте я закончу определение. Ну и, наконец, формула.
[06:39.680 --> 06:46.040]  Определение рекурсивное, как и в случае термы, это устроено так. Атомарная формула.
[06:46.040 --> 06:58.120]  Или связка, примененная, ну, одна из связок, примененная к формулам.
[06:58.120 --> 07:15.520]  У нас там связки еще есть. Ну, отрицание есть. Есть эквивалентность, пусть будет. Да, правильно.
[07:15.520 --> 07:20.600]  То есть мы можем булевые связки применять к формулам так же, как к булевым формулам. То есть
[07:20.600 --> 07:25.040]  вот тут должны стоять формулы, но теперь уже не булевые, а вот формулы первого порядка,
[07:25.120 --> 07:35.800]  в частности, атомарные могут стоять. И, наконец, есть формулы, которые, как говорят,
[07:35.800 --> 07:43.600]  получаются навешиванием квантора. То есть слова, которые устроены так, что...
[07:43.600 --> 08:00.360]  Давайте я возьму скобки. По-моему, это совсем не обязательно, но не хочется возиться с лишними
[08:00.360 --> 08:05.560]  техническими доказательствами. Скобки, я напомню, они задают порядок действия. Сейчас мы это обсудим.
[08:05.560 --> 08:10.360]  Подробнее. Ну, вот это вот уже определение. То есть когда мы смотрим на слово в алфавите
[08:10.360 --> 08:18.480]  символов первого порядка, мы должны понять, формула оно или нет, применяя это определение
[08:18.480 --> 08:28.840]  рекурсивно. То есть у нас одно из этих условий должно выполняться. Мы проверяем возможность
[08:28.840 --> 08:34.680]  каждого из них. Чтобы проверить, мы должны проверить части, которые у нас получились
[08:34.680 --> 08:39.400]  под формулы, что они корректные под формулы и так далее, пока не доходим до атомарной формулы,
[08:39.400 --> 08:45.040]  где нам уже нужно проверить, что перечислены именно термы. Для этого мы используем определение терм.
[08:45.040 --> 08:55.640]  Ну и опять-таки, как и в случае булевых формул, с формулой можно сопоставить дерево. Плоское дерево,
[08:55.640 --> 09:09.800]  размеченное, но оно имеет уже более сложную структуру. Это предикатный символ. Не предыдущий,
[09:09.800 --> 09:18.800]  а предикатный. Я прошу прощения, что сокращение написал. Хотелось не занимать все доски. Дерево
[09:18.800 --> 09:32.040]  разбора. Как оно устроено? В вершине дерева написано что-то. Смотрите, что у нас может быть
[09:32.040 --> 09:47.240]  в вершине дерева. Либо связка, либо квантор, либо предикатный символ. И тогда тут будут уже термы.
[09:47.240 --> 09:58.000]  Тут уже дерево может этвиться больше, чем на два. И вот термы, они заканчиваются переменными или
[09:58.000 --> 10:06.360]  константами. Получается так, у нас дерево разбора. Построить это дерево разбора по формуле можно точно
[10:06.360 --> 10:12.880]  тем же алгоритмом, который мы использовали в булевом случае. Смотрим на скобки и восстанавливаем
[10:12.880 --> 10:17.720]  по скобкам структуру дерева. А какие ставить, приписывать символы вершинам дерева? Ну вот те,
[10:17.720 --> 10:23.600]  которые у нас возникают при разборе формулы. То есть в сущности все то же самое, только более
[10:23.600 --> 10:30.880]  сложные правила. И у нас возникает большее ветвление, но тут никакой сложности нет, потому что
[10:30.880 --> 10:40.000]  запятая достаточно однозначно синтоксически выделяет вот те блоки, которые должны быть термами,
[10:40.000 --> 10:47.080]  которым мы должны применить уже построение дерева терма, начинающиеся с какого-то имени,
[10:47.080 --> 10:53.760]  ну и заканчиваешься переменными. В результате у дерева разбора получается сложная структура.
[10:53.760 --> 11:05.240]  Вот смотрите, есть часть в дереве разбора, в которой являются формулы, а есть часть вершины,
[11:05.240 --> 11:15.360]  которые являются термами. Это не обязательно равномерные части. Вот тут у меня сразу очень
[11:15.360 --> 11:21.280]  простая формула. Давайте я, чтобы можно было продемонстрировать какое-то разнообразие,
[11:21.280 --> 11:27.920]  я наоборот напишу там импликацию. А здесь что-то такое, вот еще где-то глубже у нас стоит формула,
[11:27.920 --> 11:35.160]  и вот потом только где-то вот здесь уже встречаются атомарные формулы. То есть если посмотреть только
[11:35.160 --> 11:41.440]  на ту часть, которая отвечает формулам, это тоже будет дерево с тем же самым корнем, но листьями у
[11:41.440 --> 11:46.520]  него будут атомарные формулы, то есть предикатные символы. Когда мы смотрим на это дерево, мы видим,
[11:46.520 --> 11:53.240]  на это под деревом мы видим в листьях предикатные символы, а дальше под предикатными символами мы
[11:53.240 --> 12:09.920]  должны поставить термы, какие нужны. Ну допустим t1 имеет r2. Да, значит я скорее имел в виду,
[12:10.000 --> 12:15.400]  что здесь какое-то дерево, но два ребра может выходить, а может выходить три, если арность
[12:15.400 --> 12:22.080]  этого терма 3, если у вас функциональный символ. Да, здесь можно даже написать не термы, я прошу
[12:22.080 --> 12:28.560]  прощения, это я хотел говорить о термах. Тут конечно функциональные символы стоят, посмотрите
[12:28.560 --> 12:32.600]  на определение терма. Что будет стоять вверху? Ну какой-то функциональный символ,
[12:32.600 --> 12:44.480]  а в листьях будут стоять переменные или константы, это отвечает определению терм. Вот это
[12:44.480 --> 12:56.680]  разбиение существенно при определении, давайте прямо здесь напишу значение, ведь формулы нам
[12:56.680 --> 13:03.840]  нужны не просто так, написать формулу можно и их много можно написать, но наша цель зафиксировать
[13:03.840 --> 13:10.240]  с помощью формулы какой-то предикат в какой-то модели, и поэтому нам нужны правила оценки
[13:10.240 --> 13:16.880]  формулы. Как формулу, также как с булевой формулой, мы оцениваем булевую формулу каким-то
[13:16.880 --> 13:24.160]  способом, получаем истину или ложь. Здесь оценкой формулы тоже будет истина или ложь, но не оценкой
[13:24.160 --> 13:29.800]  термы. Термы будут оцениваться иначе, а формулы будут оцениваться истиной и ложь, но это будет
[13:29.800 --> 13:38.520]  зависеть от многих вещей. Вот давайте сейчас я здесь напишу на этой доске, надеюсь помещусь,
[13:38.520 --> 13:51.600]  значит для того чтобы оценивать формулу мы должны задать модель, иначе вообще невозможно
[13:51.600 --> 14:16.360]  говорить об оценке формулы. Ну и в этой модели что должно быть? Какая у нее должна быть сигнатура?
[14:16.360 --> 14:21.000]  Мы должны, если у нас есть формула, в ней встречаются какие-то предикатные функциональные
[14:21.000 --> 14:27.400]  символы, константы. Модель должна быть такой, чтобы она содержала соответствующие предикаты,
[14:27.400 --> 14:32.840]  функции и константы. То есть мы должны каждому вот этому синтоксическому элементу, символу,
[14:32.840 --> 14:40.080]  который у нас есть, сопоставить. Ну предикат, я напомню, это отношение и правильная арность.
[14:40.080 --> 14:45.680]  Если я хочу первый, допустим, у меня R1, он имеет арность 3, ну значит мне тут нужен тернарный
[14:45.680 --> 14:50.520]  предикат, R2 имеет арность 2, ну значит нужен бинарный предикат. То же самое с функциональными
[14:50.520 --> 14:58.280]  символами. Ну и константы это какие-то выделенные имена в модели. Модель, я напомню, сразу не пустой,
[14:58.280 --> 15:05.640]  считается множество, это там для того, чтобы не возникали всякие паразитные проблемы. Но этого
[15:05.640 --> 15:10.920]  еще недостаточно, чтобы сказать истинно формула или ложно. Почему? Потому что у нас есть переменные.
[15:10.920 --> 15:16.800]  От значений переменных значение формулы тоже может зависеть. Поэтому нам еще нужна оценка
[15:16.880 --> 15:36.800]  переменных. Ну это просто-напросто функция из переменных в модель. То есть функция из множества
[15:36.800 --> 15:49.280]  переменных. Обычно мы как записываем функцию P и в круглых скобочках аргумент? Здесь это не
[15:49.280 --> 15:54.440]  очень удобно, потому что круглые скобочки у нас носят синтоксический характер. Поэтому я то же
[15:54.440 --> 16:01.280]  самое, это на самом деле то же самое, буду писать вот как. Х, допустим, значение переменной х в
[16:01.280 --> 16:08.560]  квадратных скобочках, а имя оценки я буду писать как индекс. Вот здесь вот я тоже использую
[16:08.560 --> 16:14.320]  квадратные скобочки, это у меня будет общее соглашение. У нас есть проблема, мы сейчас рассуждаем о
[16:14.320 --> 16:21.120]  синтаксисе, в котором уже есть запятые круглые скобки и очень легко запутаться, если использовать
[16:21.120 --> 16:26.960]  привычные математические приемы. Поэтому я буду использовать квадратные скобки, которых у меня
[16:26.960 --> 16:34.360]  нет во фавите первого порядка, чтобы подчеркивать, что это значение какого-то синтаксического элемента
[16:34.360 --> 16:40.240]  в модели. Значение переменной, ну вот оно задается какой-то оценкой, оно может быть разное. В модели
[16:40.240 --> 16:45.520]  значение предикатных функциональных символовых констант фиксировано, поэтому там никакой оценки
[16:45.520 --> 16:59.160]  не приписано, оно просто моделью задается. Давайте попробуем, что бы мне стереть. Наверное,
[16:59.160 --> 17:06.920]  алфавит проще всего стереть, вряд ли вы запутаетесь хоть их и много, но вряд ли вы запутаетесь с алфавитом.
[17:15.520 --> 17:36.280]  Ну вот я написал некоторую формулу, значит вот значок меньше это символ бинарного отношения,
[17:36.280 --> 17:44.480]  а интерпретировать я ее буду так на действительных числах. Меньше это просто отношение строгого
[17:44.480 --> 17:51.480]  сравнения. Ну здесь у меня нет констант и нет функциональных символов, ну давайте тогда,
[17:51.480 --> 18:03.720]  чтобы константы будут похожим образом, давайте пусть будет функциональный символ. И есть еще
[18:03.720 --> 18:09.480]  бинарный функциональный символ сложения. Вот такая формула. Она формула, естественно, потому
[18:09.480 --> 18:14.680]  что смотрите, в корне стоит квантор всеобщенности, дальше предикатный символ, вот как я рисовал,
[18:14.680 --> 18:23.200]  он бинарный и это уже атомарная формула, поэтому здесь есть терм переменная, а здесь терм более
[18:23.200 --> 18:33.160]  сложный применение функций двум переменным. И вот мы хотим оценить, значит что нам нужно,
[18:33.160 --> 18:42.280]  я уже написал оценку этих символов, она обычная, и мне теперь нужно написать, как я оцениваю значение
[18:42.280 --> 18:58.720]  переменных. Ну вот скажем один и два. Вот если это зафиксировано, у этой формулы возникнет
[18:58.720 --> 19:13.120]  логическое значение. Но я еще не описал, как оно возникнет. Что? Значит еще раз, тут некоторая
[19:13.120 --> 19:20.200]  проблема состоит в том, что можно эти формальные определения давать по-разному и ни один из
[19:20.200 --> 19:25.360]  вариантов не будет полностью удобен, то есть у нас будут возникать проблемы. Стандартно считается,
[19:25.360 --> 19:30.880]  что мы определяем, смотрите, у меня на самом деле формальная оценка переменных, это оценка вообще
[19:30.880 --> 19:36.200]  всех переменных в алфавите. Конечно для формулы это не нужно, потому что если в формулу входят,
[19:36.200 --> 19:40.480]  мы сейчас увидим из правил оценки, входят какие-то переменные, то от остальных уж точно ничего не
[19:40.480 --> 19:45.440]  зависит. Но формально мы вообще должны всем переменным приписать значение. Я этого не стал
[19:45.440 --> 19:53.280]  делать, потому что это как-то уж совсем доска маленькая, переменных бесконечно много. Но правила
[19:53.280 --> 19:57.880]  оценки они формулируются именно так. Я хочу сейчас просто продемонстрировать, как работают
[19:57.880 --> 20:04.400]  правила оценки, раз уж попросили пример. Значит с чего начинается оценка? Оценка начинается с
[20:04.400 --> 20:13.440]  оценки терма. Значит смотрите, оценки константа уже заданы, оценки переменных вот они тоже заданы,
[20:13.440 --> 20:21.880]  поэтому если терм имеет длину один, ну уже знаем его оценку. Давайте теперь оценим терм,
[20:21.880 --> 20:34.200]  который имеет вид функция от каких-то термов. Как вы думаете, как мы его оценим? Ну можно
[20:34.200 --> 20:39.000]  догадаться, мы должны взять ту функцию, которая отвечает этому функциональному символу и применить,
[20:39.000 --> 20:51.120]  рекурсивно вычислить значение от термов и применить эту функцию к этим значениям. Получим
[20:51.120 --> 20:58.840]  значение функции. Ну в общем, самым естественным образом. Например, здесь. Как будет оцениваться терм
[20:58.840 --> 21:11.120]  вот этот? Плюс, у, х, пи. Какая будет оценка? Ну мы видим один и два, значит функция у нас
[21:11.120 --> 21:18.760]  сложения. Значит этот терм будет оцениваться в три. Теперь как оценивать атомарные формулы?
[21:18.760 --> 21:33.480]  Следующий шаг. Оценка переменных она определяна на переменных, а на термы она продолжается. То есть
[21:33.480 --> 21:40.120]  смотрите, у меня написано правило оценки. Вот я здесь написал, здесь термы. Формула состоит из
[21:40.120 --> 21:48.600]  разных частей вершины. Формулы бывают термами, бывают формулами. Так вот, термы оцениваются как
[21:48.600 --> 22:00.560]  элементы модели, а формулы оцениваются как обычно, как истина и ложь. И ну 0, 1. Я буду писать для
[22:00.560 --> 22:08.800]  краткости 1, 0. Давайте смотреть, как я буду оценивать атомарную формулу на заданной оценке
[22:08.800 --> 22:17.880]  переменных. Ну тоже легко догадаться. У меня есть предикат, отвечающий этому предикатному
[22:17.880 --> 22:31.320]  символу. Я должен вычислить значение термов, которые входят в атомарную формулу. Ну и применить
[22:31.320 --> 22:40.680]  предикат. Давайте на примере, как попросили. Пример, к сожалению, в другом месте, но я не
[22:40.680 --> 22:47.440]  предусмотрел. Ну и вы видите, что трудно все поместить. Пределение довольно громоздкое. Как
[22:47.440 --> 22:54.440]  будет оцениваться вот на такой оценке переменных вот такой предикат? Извиняюсь.
[22:54.440 --> 23:13.080]  Ну надо оценить термы. Этот терм оценивается в двойку, а этот терм оценивается в тройку. Истина
[23:13.080 --> 23:24.200]  значения 2 меньше 3. Истина. Вот мы оценили атомарную формулу. Ну теперь надо оценить дальше.
[23:24.200 --> 23:35.960]  Значит оценки формул, которые являются булевыми связками, по обычным правилам. Я даже их не буду
[23:35.960 --> 23:40.880]  расписывать, потому что это точно так же, как в случае булевых формул. То есть если у меня есть
[23:40.880 --> 23:47.360]  импликация, я хочу ее оценить, я должен оценить посылку, должен оценить заключение, ну и применить
[23:47.360 --> 23:54.320]  к полученным логическим значениям импликацию и так далее. А вот с кванторами получается хитрее.
[23:54.320 --> 24:04.560]  Как оценить формулу с квантором? Она равна единице тогда и только тогда.
[24:17.360 --> 24:27.040]  Сейчас я напишу, потому что трудно говорить. То есть смотрите, оценка получается очень хитрой.
[24:27.040 --> 24:33.520]  Формула с навешенным квантором всеобщности равна единице тогда и только тогда, когда формула A,
[24:33.520 --> 24:42.960]  ее называют область действия квантора, истина, но не просто на оценке pi, а на всех оценках,
[24:42.960 --> 24:50.960]  которые совпадают с pi за исключением переменной х. А вот переменная х может в новой оценке,
[24:50.960 --> 24:56.640]  пишу штрих, может принимать произвольное значение. Содержательно это очень понятно,
[24:56.640 --> 25:01.040]  когда мы говорим, для любого х что-то выполняется. Это значит, что какой бы мы х не подставили,
[25:01.040 --> 25:08.120]  х переменно оценим как-то, должно получиться истинным. Вот это формальное определение. Ну и
[25:08.240 --> 25:18.520]  аналогичное определение для квантора существования. Тут только разница в том,
[25:18.520 --> 25:30.720]  что достаточно одной такой оценки. Для всех пиш-штрих, а тут существует пиш-штрих.
[25:30.720 --> 25:40.560]  И давайте вернемся к примеру. Теперь я хочу оценить всю формулу. Она как раз имеет вид квантора
[25:40.560 --> 25:48.280]  всеобщности. Значит, я теперь должен сделать вот что. Я должен оценивать вот эту вот формулу не
[25:48.280 --> 25:53.720]  только при тех значениях х и у, которые у меня написаны. Х у меня по-прежнему всегда будет 1,
[25:53.720 --> 25:58.520]  а вот у я должен приписать мысленно все возможные значения и посмотреть,
[25:58.520 --> 26:10.280]  всегда ли получается истина. Ну как вы думаете, при всех ли у выполняется неравенство х строго
[26:10.280 --> 26:16.080]  меньше у плюс х. Если переписать нашу формулу в привычных обозначениях, она будет выглядеть
[26:16.080 --> 26:26.280]  вот так. И теперь х у меня единица, а у я должен присваивать все возможные значения. Всегда ли
[26:26.280 --> 26:34.680]  единица строго меньше, чем у плюс единица? Не всегда, потому что это зависит на самом деле от
[26:34.680 --> 26:39.440]  носителя модели. Вот эта множество называется носителем модели. У нас действительные числа,
[26:39.440 --> 26:45.120]  среди них есть отрицательные. Давайте возьмем там у минус 1. Ну вообще любое отрицательное число,
[26:45.120 --> 26:51.440]  это нарушится. Если бы это были, скажем, целые положительные числа, это было бы правда. А даже
[26:51.440 --> 26:56.400]  если целые не отрицательные, тоже неправда, потому что было бы ноль и строгого неравенства бы не
[26:56.400 --> 27:02.120]  было. То есть вообще говоря, это свойство может быть чувствительным к модели, но в любом случае
[27:02.120 --> 27:11.880]  так или иначе мы можем это определить. Можем в таком пиквикском смысле. То есть у нас есть определение.
[27:11.880 --> 27:26.120]  Ну вот, то есть вот так устроены правила оценки, вот так устроены формулы, и вот с этим придется
[27:26.120 --> 27:32.760]  дальше работать. Прощее определение я вам предложить не могу. Есть разные варианты, повторяю,
[27:32.760 --> 27:39.360]  но во всех возникают какие-то неприятные синтакфические ограничения, что-то нужно говорить. В общем,
[27:39.360 --> 27:51.720]  ну цель довольно мощная. Мы хотим вообще всю математику вложить в наш формализм, поэтому
[27:51.720 --> 27:57.560]  приходится мириться с тем, что формализм получается не очень простым и содержит какие-то
[27:57.560 --> 28:02.880]  такие неприятные вещи. Может быть кто-то когда-нибудь придумает лучший формализм. Пока вот
[28:02.880 --> 28:13.320]  все, что известно, оно не сильно лучше вот этого стандартного. Что-что? Про кванторы? Значит,
[28:13.320 --> 28:19.880]  смотрите, как оценивается квантор всеобщенности? Мы должны взять все оценки переменных, которые
[28:19.880 --> 28:26.640]  совпадают с нашей, за исключением переменной X, и на каждой такой оценке вычислить значение формулы,
[28:26.640 --> 28:31.880]  которая стоит под квантором, области действия квантора. Если всегда получается единица,
[28:31.880 --> 28:38.160]  формула с навешанным квантором единица. Если хотя бы при одном значении ноль, формула ноль. Вот
[28:38.160 --> 28:44.480]  как в примере. А с квантором существования похожая ситуация. Мы тоже берем те же самые оценки,
[28:44.480 --> 28:50.080]  которые только в X отличаются, но теперь нас устроит, если хотя бы на одной такой оценке область
[28:50.080 --> 28:57.480]  действия квантора оценивается в единицу. Содержательно это понятно. Тут ничего по сравнению
[28:57.800 --> 29:01.320]  нового, по сравнению с тем, что я рассказывал в прошлый раз, нет. Но теперь мы зафиксировали
[29:01.320 --> 29:07.000]  формализм и нужно зафиксировать определение, как мы вычисляем значение вот по этой формуле,
[29:07.000 --> 29:13.320]  которая является словом или деревом, неважно. То есть вот так вот вычисляем. Ну и давайте сразу
[29:13.320 --> 29:19.640]  первое наблюдение из правил оценки. Во-первых, из правил оценки ясно, что значение формулы уж
[29:19.640 --> 29:25.560]  точно не зависит от переменных, которые в нее не входят. Я думаю, это просто вот понятно из
[29:25.560 --> 29:34.800]  самих правил. Но оказывается больше. Переменная может входить в формулу, но от нее ничего не зависит.
[29:34.800 --> 29:40.760]  Это тот вопрос, который вот мне задавали. Бывают такие переменные, от которых тоже ничего не
[29:40.760 --> 29:49.480]  зависит. Давайте посмотрим. Тут надо ввести терминологию. Еще раз это я перепишу. Если у
[29:49.480 --> 29:57.480]  нас формула имеет такой вид, вот это называется область действия. Квантер. Я пишу, в общем,
[29:57.480 --> 30:07.240]  для квантера существование то же самое. Теперь пусть у нас есть какая-то формула. Я ее специально
[30:07.240 --> 30:16.120]  напишу вот так. Это слово какое-то из символов. И пусть у нас есть вхождение переменной. Вот это
[30:16.120 --> 30:25.840]  вхождение связанное. Называется связанное. Если существует квантер по х такой, что вот это
[30:25.840 --> 30:33.480]  вхождение входит в область действия квантера. Вот как в примере у меня было. У у меня входил
[30:33.480 --> 30:50.440]  связанно. А х свободно. Иначе свободно. Я еще раз напишу уже просто произвольными буквами. Вот
[30:50.440 --> 30:57.680]  формула. Вот смотрите, у входит связанно. Он входит один раз, и он входит связанно. А х входит
[30:57.680 --> 31:08.800]  свободно. Оба вхождения. Если формула какая-нибудь более сложная. Это тоже формула. Я скобку забыл
[31:08.800 --> 31:15.560]  поставить. То смотрите, х входит три раза. Вот эти вхождения свободные. То есть свободные или
[31:15.560 --> 31:20.600]  связанные вхождения переменной. Не имя переменной, а вхождение переменной. Вот эти вот вхождения
[31:20.600 --> 31:25.360]  свободные. А вот это связанное, потому что он входит в область действия квантера. Такое возможно,
[31:25.360 --> 31:32.440]  что одна и та же переменная входит и свободно, и связанно. Что мне сейчас важно, это что такое
[31:32.440 --> 31:45.800]  параметр формулы. Переменная, это переменная, у которой есть свободное вхождение.
[31:55.360 --> 32:06.480]  То есть в этом примере, скажем, у х есть свободное вхождение. Хотя бы одно. Вот нашли
[32:06.480 --> 32:14.680]  свободное вхождение, всё, достаточно. А у у конец свободных вхождений. Вхождение под квантером,
[32:14.680 --> 32:23.160]  оно тоже считается связанным для определённости. То есть свободное это то, которое не попадает в
[32:23.160 --> 32:29.720]  область действия квантера. На самом деле это легко показать на вот этой схеме с деревом. Вот что
[32:29.720 --> 32:36.960]  значит, что переменная входит свободно. Смотрите, у нас есть корень. Давайте я там не связку напишу,
[32:36.960 --> 32:44.600]  а корень обозначу формулу. И как всегда в дереве, я думаю вы это знаете, от листа к корню существует
[32:44.600 --> 32:52.800]  единственный путь. И что значит, что переменная входит, вот это вот вхождение, в разных листьях
[32:52.800 --> 32:58.720]  может быть написано одно и то же имя переменной. Каждый лист это вхождение переменной. И вот что
[32:58.720 --> 33:03.800]  значит, что это вхождение свободное. Значит, что когда я двигаюсь к корню, мне квантер по иксу не
[33:03.800 --> 33:12.720]  встретится. А если он встретился именно по иксу, то это вхождение уже связано. То есть очень просто.
[33:12.720 --> 33:18.920]  То есть вы просто смотрите на путь от листа к корню, там появился квантер по той же переменной,
[33:18.920 --> 33:24.920]  ну значит она связана. Если не появился, значит это вхождение свободно. И вот первая лемма,
[33:24.920 --> 33:34.080]  которую не сложная, но которую полезно доказать, чтобы убедиться, что мы нигде не наврались с
[33:34.080 --> 33:53.920]  определениями формализма. Она такая, значение формулы зависит только от оценок параметров.
[33:53.920 --> 34:11.200]  Ну вспомните пример, который мы разбирали. Там у был, не было параметров, у него только связанное
[34:11.200 --> 34:16.160]  вхождение. И было видно, что хотя мы у какое-то значение вначале присвоили, но оно ни на что не
[34:16.160 --> 34:20.560]  повлияло, потому что когда мы начали оценивать квантер, мы вместо у должны были подставлять все
[34:20.560 --> 34:27.120]  возможные значения. Поэтому по этой лемме вы правы, чтобы сказать, какое значение формулы,
[34:27.120 --> 34:31.560]  нам достаточно указать значение икса. Просто посмотрели на формулу, там есть параметры, вот
[34:31.560 --> 34:37.560]  надо указать оценки параметров, этого будет достаточно. Но при таких определениях это становится
[34:37.560 --> 34:44.760]  утверждением. Тут мы уже зафиксировали, как оценивается формула, теперь это надо доказать.
[34:44.760 --> 34:52.920]  Ну доказательство очень простое, доказательство разбором по длине формулы. Базой будет случай
[34:52.920 --> 35:04.240]  атомарных формул. Атомарные формулы, в них все вхождения свободны, поэтому ясно, что лемма
[35:04.240 --> 35:12.720]  выполняется. Если мы применяем булевые связки, то что получается? Вот допустим импликацию я для
[35:12.720 --> 35:16.820]  определенности буду говорить. Здесь есть какие-то параметры, здесь есть какие-то параметры,
[35:16.820 --> 35:22.060]  какие параметры у формулы, которая является импликацией A в B. Ну объединение параметров
[35:22.060 --> 35:27.920]  по двум подформулам. И если мы знаем значение всех этих параметров, у нас есть оценка всех этих
[35:27.920 --> 35:33.000]  параметров, то по индуктивному предположению, мы можем оценить A, можем оценить B, ну и значит
[35:33.000 --> 35:38.920]  можем оценить импликацию. Но и осталось понять что происходит, когда мы делаем шах индукции
[35:38.920 --> 35:42.920]  на формуле с навешанным квантором. Здесь тоже очень просто, потому что, смотрите,
[35:42.920 --> 35:50.200]  вот если у меня есть формула вида для любого xA, в этой формуле x точно не параметр, потому что
[35:50.200 --> 35:58.680]  самого верху висит квантор, значит, все вхождения xA в эту формулу будут связаны. Значит, нам нужно
[35:58.680 --> 36:06.440]  доказать, что оценка зависит только от параметров A за исключением возможной x. x может быть параметром
[36:06.440 --> 36:14.120]  формуля. Ну так это понятно из определения, потому что мы x придаем все возможные значения и смотрим,
[36:14.120 --> 36:18.040]  получится у нас всегда единица или нет, если квантор в всеобщенности, или получится хотя бы
[36:18.040 --> 36:24.280]  один раз единица, если квантор существует. И ясно, что этот результат не зависит от того,
[36:24.280 --> 36:30.600]  как я оцениваю переменную x. Ну, как в примере, я приписал формально какое-то значение, но оно
[36:30.600 --> 36:37.640]  никакой роли в оценке уже формулы с квантором не сыграло. Поэтому эта лемма выполняется. И
[36:37.640 --> 36:50.120]  фактически получается... О! Базы атомарные формулы, вот такого вида. Утверждение у нас такое,
[36:50.120 --> 36:55.200]  что значение формулы зависит только от значения параметров. Какие параметры у атомарной формулы?
[36:55.200 --> 37:00.640]  Все вхождения переменных, потому что квантора вообще нет, поэтому все вхождения свободны.
[37:00.640 --> 37:04.640]  Связанное вхождение может возникнуть только, если есть квантор, а в атомарной формуле его нет.
[37:04.640 --> 37:16.920]  Ну и в сущности теперь понятно, что формула задает нам, когда зафиксирована модель. Если
[37:16.920 --> 37:20.800]  модель не зафиксирована, формула вообще непонятно, что задает, это мы обсудим. Формула,
[37:20.800 --> 37:26.200]  которая для всех моделей что-то говорят, это отдельная история. Но обычно значение формулы
[37:26.200 --> 37:33.280]  зависит от модели. Вот мы берем, и в примере я это показал, это тоже возможно. Мы берем модель,
[37:33.280 --> 37:40.240]  и что задает формула? Чтобы получить истину или ложь, мы должны задать оценку переменных. Теперь
[37:40.240 --> 37:44.680]  мы уже знаем, что достаточно задать оценку параметров. То есть фактически формула задает
[37:44.680 --> 37:52.400]  предикат. R-ности равны количеству параметров. В частности, если формула, как говорят,
[37:52.400 --> 37:58.920]  замкнутая, в ней нет параметров. Такие формулы тоже бывают. Я сейчас напишу какую-нибудь. Для
[37:58.920 --> 38:05.040]  любого x, а от x. Эта формула называется замкнутая, потому что ни одного параметра нет. По этой
[38:05.040 --> 38:12.040]  лемме ее значение не зависит ни от одной переменной. То есть она истинная или ложь данной модели. Такой
[38:12.040 --> 38:20.080]  нулярный предикат. То есть замкнутые формулы задают фактически в каком-то смысле аналог
[38:20.080 --> 38:28.800]  булевых формул в том смысле, что если задана модель, а модель заменяет нам присваивание
[38:28.800 --> 38:34.240]  переменных. Вот тогда у таких формул есть значение. А у остальных это получается некоторый
[38:34.240 --> 38:38.440]  предикат. Ну и последнее, что я хочу сказать перед перерывом, до него осталась минута,
[38:38.440 --> 38:44.720]  что в отличие от булевых формул, там всегда есть надежда иногда иллюзорная, что если мы
[38:44.720 --> 38:53.560]  посмотрим на все мыслимые значения, там на самом деле всегда значение вычисляется. Я неправильно
[38:53.560 --> 38:58.760]  сказал, не надо посмотрим. Если у нас есть формула и значение переменных, то чего бы не вычислить.
[38:58.760 --> 39:09.240]  А с формулами первого порядка это не так. Если задана модель, давайте я напишу какую-нибудь
[39:09.240 --> 39:34.040]  формулу сложную. Для любого х существует у такой что... Я позволю себе тут немножко
[39:34.040 --> 39:40.040]  математические жаргоны в обычном виде написать, чтобы было понятнее. Ну, значит, эта формула я
[39:40.040 --> 39:44.760]  хочу ее интерпретировать на натуральных числах. Ну давайте даже на положительных натуральных
[39:44.760 --> 39:51.640]  числах. Прайм это предикат унарной простоты. Ранее единицы, если число простое. Сложение это
[39:51.640 --> 39:57.280]  сложение, это прибавление просто. Двойка это константа. Ну а это сравнение чисел. И что здесь
[39:57.280 --> 40:03.320]  написано вот в такой формуле? Она замкнутая, как нетрудно видеть. У нас есть два квантора по х и по
[40:03.320 --> 40:10.200]  у и другие переменные не входят. Что эта формула утверждает? Она утверждает, что есть сколько угодно
[40:10.200 --> 40:16.640]  большое простое у такое что у плюс два тоже простое. То есть, чтобы оценить эту формулу,
[40:16.640 --> 40:22.280]  нужно решить знаменитую проблему простых чисел близнецов. Она истина, если простых чисел
[40:22.280 --> 40:29.200]  близнецов бесконечное количество и ложна в противном случае. И тут ясно, что уже никакое
[40:29.200 --> 40:34.280]  построение табличек нам не поможет. Это вот математика. Ну либо истина, либо ложна. Никто не
[40:34.280 --> 40:39.560]  знает. Уже много веков люди пытаются на этот вопрос ответить и ничего не получается. Несмотря
[40:39.560 --> 40:46.600]  на то, что теория чисел развита там до безумной степени, но не выходит. То есть оценки формул
[40:46.600 --> 40:52.240]  первого порядка это уже очень непростое дело. И ой, я извиняюсь, сейчас нужно делать перерыв.
[40:52.240 --> 40:58.200]  После перерыва я начну объяснять почему так. Ну, собственно, короткое объяснение уже было,
[40:58.200 --> 41:02.320]  что мы всю математику можем выразить не только простые числа близнецов, а вообще все что есть.
[41:02.320 --> 41:10.160]  Значит, такое небольшое введение в синтаксис у нас появилось, но и появилась некоторая
[41:10.160 --> 41:14.600]  семантика. И теперь я хочу про семантику поговорить, потому что синтаксис сам по себе,
[41:14.600 --> 41:23.760]  он не очень интересен. Ну, зачем он нужен? Тут опять-таки придется ввести какие-то слова. Сейчас
[41:23.760 --> 41:30.720]  я их сделаю ввиду. Значит, логики используют такую терминологию. Теория
[41:30.720 --> 41:59.480]  т-аккурсивная. Это множество замкнутых формул. Ну, почему это называется теорией? Это на совести
[41:59.480 --> 42:05.320]  логиков. Обычные математики это называют аксиомами. Вот простой пример. Допустим,
[42:05.320 --> 42:10.280]  мы изучаем группы и написали множество замкнутых формул. Я их выписывать не буду для скорости,
[42:10.280 --> 42:14.120]  но, я думаю, в голове легко представить, что это формулы первого порядка. Значит, какие у нас
[42:14.120 --> 42:18.800]  свойства у группы? Ассоциативность. То есть, для любого х, для любого их, для любого z,
[42:18.800 --> 42:23.560]  должно выполняться равенство ассоциативности. Ну, в сигнатуре группы это записывается.
[42:23.560 --> 42:33.960]  Существует такой элемент группы E, что, ну или если E у нас константа, то тогда это будет
[42:33.960 --> 42:40.920]  выглядеть так, что для любого х, E умножить на х равно х умножить на E равно х. Тоже формула первого
[42:40.920 --> 42:47.960]  порядка. Равенство у нас есть в этой сигнатуре. Ну и обратный тоже можем написать. Это с точки
[42:47.960 --> 42:53.160]  зрения специалиста по теории группы, аксиомы группы. Но логики, когда мы напишем соответствующие
[42:53.160 --> 42:58.840]  формулы, скажут, что нет, это вы написали теорию. Ну вот такая терминология. Мы ей будем
[42:58.840 --> 43:08.040]  пользоваться, потому что так в логике говорят. Значит, и поскольку формулы замкнутые, то для
[43:08.040 --> 43:17.920]  каждой модели теории, модели теории это понятное дело, что такое. Ну не очень понятно, сейчас скажу,
[43:17.920 --> 43:41.400]  модель теории. Во-первых, в сигнатуру входят, входят интерпретации всех символов из Т. То есть
[43:41.400 --> 43:47.880]  для каждой формулы мы должны уметь по правилам оценки вычислять значение. И все формулы,
[43:48.040 --> 44:03.840]  из Т истины. Ну вот модель, давайте как-нибудь ее М обозначу. М, ну и здесь что-то там сигнатура. То
[44:03.840 --> 44:09.680]  есть моделью теории я называю такую модель, в которой все формулы из нашего множества,
[44:09.680 --> 44:14.920]  они замкнутые, поэтому они истинные или ложные в каждой модели. Вот они должны быть все истинные.
[44:14.920 --> 44:22.120]  Ну, например, моделью для аксиом группы будет любая группа. Модель у данной теории,
[44:22.120 --> 44:30.440]  их может быть много, они могут быть устроены по-разному, да. Модель теории, это такая модель,
[44:30.440 --> 44:37.560]  в которую входят интерпретации всех символов формул теории. Ну у нас формулы теории содержат
[44:37.560 --> 44:41.760]  какие-то переменные, не переменные, предикаты, функциональные символы. Все они должны быть в
[44:41.760 --> 44:50.120]  этой модели определены. Ну вот как здесь в правилах оценки. И причем должно еще также выполняться такое
[44:50.120 --> 45:00.080]  свойство, что все формулы теории должны быть истинны в этой модели. Значит, конечно, не у любой
[45:00.080 --> 45:11.600]  теории есть модель. Я сейчас легко напишу теорию, у которой нет модели. А вот можно здесь простой
[45:11.600 --> 45:26.720]  пример. Вот, значит, вот одна формула и вот вторая формула. Они обе замкнуты, но я думаю всем понятно,
[45:26.720 --> 45:34.120]  что модели у такой теории быть не может. Как бы я не проинтерпретировал символ А, у меня фактически
[45:34.120 --> 45:41.120]  написано формула и ее отрицание. Но по правилам оценки, либо формула ложная будет в ложь оцениваться,
[45:41.120 --> 45:46.800]  либо отрицание будет в ложь оцениваться. Значит, у такой теории просто нет модели. Значит,
[45:46.800 --> 46:01.600]  Т говорят совместно, если есть хотя бы одна модель. Ну и не совместно в противном случае. Вот
[46:01.600 --> 46:10.040]  эта модель не совместна. Ну то есть несовместная модель, это мы погорячились, мы наложили такие
[46:10.040 --> 46:15.520]  условия, которые выполнить в принципе нельзя. А если совместно, значит, о чем-то идет речь,
[46:15.520 --> 46:23.800]  не всегда о чем-то однозначно определенном. Вот как в случае аксиом группы. Группы у нас очень
[46:23.800 --> 46:32.200]  много свойств, они очень сильно различаются. И так, ну, какие-то теоремы вернут для всех групп,
[46:32.200 --> 46:41.080]  но таких теорем мало, но какие-то вернут. Теперь я напомню, что у меня возникало понятие
[46:41.080 --> 46:52.080]  семантического следствия, оно определено и здесь. Синтактическое у нас появится позже.
[46:52.080 --> 47:06.520]  Значит, формула А является семантическим следствием из теории Т, если А истина в любой модели Т.
[47:06.520 --> 47:15.240]  В сущности, я повторяю то же самое определение, что было для более формул только в более
[47:15.240 --> 47:20.920]  общей абстрактной ситуации. Значит, модель – это такая интерпретация всех символов,
[47:20.920 --> 47:25.720]  которые входят в наши формулы, при которых они все становятся истинными. И вот если такая
[47:25.720 --> 47:33.440]  интерпретация сделана, может так получиться, что формула А тоже истина. Ну, в качестве примера,
[47:33.440 --> 47:41.840]  если у нас есть теория группы, то вот та формула, которую я уже выписывал, что для любого x,
[47:41.840 --> 47:57.800]  для любого y, x, y в минус 1 равняется y в минус 1 на x в минус 1. Это формула, и она
[47:57.800 --> 48:05.560]  является семантическим следствием теории групп, то есть тех вот аксем трех, которые у
[48:05.560 --> 48:27.600]  нас задают свойства группы. Формула. Это теория, это формула. Любая. Ну, вот как пример,
[48:27.600 --> 48:37.200]  вот я написал пример формулы А. Только тогда здесь нехорошо писать равенство внутри формулы,
[48:37.200 --> 48:47.280]  как-то вот так что ли напишу. То есть у нас получается так, что эта формула будет следствием
[48:47.280 --> 48:57.040]  теории групп. Семантическим следствием. Потому что, если выполнены аксиомы группы, это мы
[48:57.040 --> 49:02.840]  проверяли, это несложно доказать, что из них будет, как только выполнены аксиомы группы,
[49:02.840 --> 49:08.680]  значит вот это тоже свойство выполнено. Мы проверяли, это все достаточно, просто рассуждения
[49:08.680 --> 49:15.240]  там какие-то нужны. Но тем не менее, мы знаем, что это семантическое следствие. И это частный
[49:15.240 --> 49:19.240]  случай общего понятия. Можно вообще сказать, что вся математика примерно этим и занимается.
[49:19.240 --> 49:25.640]  Какие есть следствия, у каких теорий? Ну, под теориями, я напомню, с точки зрения содержательной
[49:25.640 --> 49:29.960]  математики мы имеем в виду аксиомы. То есть мы задали аксиомы, аксиомы геометрии. Какие мы
[49:29.960 --> 49:36.080]  можем доказать теоремы в геометрии? Но доказать это будет дальше, это будет синтаксическое следствие.
[49:36.080 --> 49:42.440]  Это вот основной вопрос логики, с которого логика стартовала, это как бы вот это неформальное
[49:42.440 --> 49:47.600]  понятие семантического следствия превратить в синтаксическое понятие. Формулы ведь синтаксическое
[49:47.600 --> 49:53.920]  понятие. И мы можем какие-то манипуляции с формулами делать. Например, менять под формулу еще какую-то или
[49:53.920 --> 50:01.200]  еще что-то. И цель состояла в том, чтобы придумать такие правила манипуляций, при которых мы получаем
[50:01.200 --> 50:08.000]  в результате в точности семантические следствия из данного множества формул. И эта цель достижима.
[50:08.000 --> 50:17.000]  Я объясню, правда, очень не сразу, но это вот одна из основных вещей, которые вы должны вынести из
[50:17.000 --> 50:24.240]  курса, что не просто достижима, а даже как она достижима. Но это будет позже. Пока давайте посмотрим
[50:24.240 --> 50:32.440]  на примеры. Ну, теория групп тоже пример, но давайте какой-нибудь. Я хочу сейчас проиллюстрировать
[50:32.440 --> 50:41.040]  одну тонкость, с которой приходится тут мириться из-за наших определений. Давайте рассмотрим такую
[50:41.040 --> 50:57.720]  теорию. Давайте я даже следуя логике, логиком напишу по-уродски. Вот логики очень любят вместо
[50:57.720 --> 51:02.000]  того, чтобы писать обычное математическое обозначение множества через запятую элемент и писать
[51:02.000 --> 51:06.800]  как-то вот так. То есть это на самом деле множество из двух элементов. Логики просто пишут плюс,
[51:06.800 --> 51:17.440]  обозначают и то и то. Ну, так принято. Давайте я сейчас напишу нормально. Я не буду этим злоупотреблять,
[51:17.440 --> 51:22.280]  но в каких-то ситуациях я это буду делать, потому что это настолько стандартно, что очень трудно
[51:22.280 --> 51:34.960]  избежать. Очень трудно отказаться. А формулы сами по себе выглядят вот так. Да, значит,
[51:34.960 --> 51:41.280]  я опять-таки в формулах не пишу скобки, предполагаю, что скобки мы расставляем в соответствии с
[51:41.280 --> 51:48.440]  представлениями о старшинстве. Представление о старшинстве такое, ну кванторы равноправны
[51:48.440 --> 52:00.920]  по старшинству. Они сильнее, чем импликация и эквивалентность, но слабее, чем конъюнкция
[52:00.920 --> 52:07.240]  и дизюнкция. И тем более отрицание. Я не буду этим злоупотреблять, потому что вот если у меня
[52:07.240 --> 52:13.080]  написана формула для любого х, а и б, я буду стараться всегда писать вот так. Вообще иногда
[52:13.080 --> 52:19.680]  буду забывать, потому что я привык к такому порядку, что конъюнкция сильнее, поэтому мы должны
[52:19.680 --> 52:25.000]  вычислить конъюнкцию а и б, и потом уже навесить квантор на то, что получилось. Но я постараюсь
[52:25.000 --> 52:30.360]  скобки ставить в этом случае. А когда скобки не поставлены, это подразумевается, что их можно
[52:30.360 --> 52:45.720]  восстановить. Сейчас я напишу формула. Кто-то уже может быть даже сообразил, почему она называется
[52:45.720 --> 53:08.600]  транс. Не сообразили? Ну тут поскольку импликация, тут я все-таки обязан поставить скобки.
[53:08.600 --> 53:15.160]  Импликация слабее, чем квантор. А это ареф. И тоже кто-то мог бы сообразить. Почему,
[53:15.160 --> 53:20.240]  как вы думаете, первая формула называется транс? Транзитивность. На самом деле,
[53:20.240 --> 53:24.200]  когда мы будем задавать модель для этой теории, нам нужно, у нас вообще только
[53:24.200 --> 53:28.280]  предикатный символ, бинарный, нужно предикатный символ как-то интерпретировать, как бинарные
[53:28.280 --> 53:35.160]  отношения. Ну а что означает тогда вот верхняя форма? Она означает транзитивность этого отношения.
[53:35.160 --> 53:40.920]  Если х и у в отношении, у и з в отношении, то х и з в отношении. Свойство называется транзитивность.
[53:40.920 --> 53:48.200]  А нижнее свойство называется антирефлексивность. Почему? Потому что если х и у в отношении,
[53:48.200 --> 53:56.920]  эта формула говорит нам, что тогда точно неверно, что у и х в отношении. Антисимметричность хорошо,
[53:56.920 --> 54:04.320]  значит. Извините, не хорошо, а вы правы. Антирефлексивность – другое свойство. Спасибо.
[54:04.320 --> 54:10.880]  Значит, антисимметричность, прошу прощения, это я заговорился. Все правильно, это именно как
[54:10.880 --> 54:19.680]  антисимметричность нужно понимать. Антирефлексивность – это что для любого х неверно, что ах. Я извиняюсь,
[54:19.680 --> 54:25.840]  это я действительно перепутал. Ну и какие отношения удовлетворяют свойству транзитивности,
[54:25.840 --> 54:29.960]  антисимметричности. В этих отношениях в математике есть специальное название. Я не знаю,
[54:29.960 --> 54:39.560]  учили ли вас на первом курсе бинарным отношениям. Учили, нет? В общем, это называется строгий частичный
[54:39.560 --> 54:44.960]  порядок. Если у вас есть отношения, которые удовлетворяют этим свойствам, то то есть
[54:44.960 --> 55:02.840]  tau – это теория строгого частичного порядка. А линейный я не случайно обмолвился, потому что
[55:02.840 --> 55:09.080]  теория эта не очень удобная, в ней мало теорем можно доказать и ничего интересного, хотя про
[55:09.080 --> 55:15.400]  частичные порядки можно много чего интересного сказать. Но вот в таком виде, в виде семантических
[55:15.400 --> 55:22.960]  следствий таких формул не так много можем сказать. Почему? Давайте поймем, чем трудность. Важный
[55:22.960 --> 55:30.440]  класс порядка в линейные порядки, когда любая пара элементов сравнима. Как записать условия
[55:30.440 --> 55:46.040]  линейности порядка? Хочется написать что-то такого типа для любого х, для любого у, аух или аху,
[55:46.040 --> 55:54.960]  что элементы сравнимы. Но я думаю, что многие из вас, глядя на эту формулу, уже сообразили,
[55:54.960 --> 56:10.040]  что это так делать не стоит. Какие будут модели у теории T плюс вот эта формула? То есть такие
[56:10.040 --> 56:18.000]  отношения, для которых выполнена и транзитивность, и антисимметричность, и вот это вот свойство
[56:18.000 --> 56:42.600]  линейности. Нет. Какие модели? Назовите хотя бы одну для примера. Нет. Моделей у такой теории
[56:42.600 --> 56:54.000]  просто нет. Такая теория не совместна. Смотрите почему. Потому что, в частности,
[56:54.000 --> 56:59.240]  я когда оцениваю эту формулу, я ее должен оценивать, придавая х и у одинаковые значения. Там же стоит
[56:59.240 --> 57:03.880]  для любого х и для любого у. Значит у нас в оценке этой формулы возникнет такая оценка
[57:03.880 --> 57:09.800]  переменных, когда х и у оцениваются одинаково. Но тогда смотрите, что здесь написано. Здесь написано
[57:09.800 --> 57:21.720]  AXX следует не AXX. А здесь написано AXX или AXX. Ну, AXX или AXX это понятное дело просто AXX. А что
[57:21.720 --> 57:26.920]  написано здесь? AXX следует не AXX. Это на самом деле логически, как ни трудно видеть, просто не
[57:26.920 --> 57:33.800]  AXX. То есть получается так, что вот эти две формулы при такой оценке приобретают обязательно разные
[57:33.800 --> 57:39.840]  логические значения. Поэтому модели просто нет. Ну и после этого уже ничего интересного сказать
[57:39.840 --> 57:48.380]  нельзя. Значит нам нужно выкрутиться. Вот свойство линейности, оно в математике записывается немножко
[57:48.380 --> 58:02.640]  иначе, более хитро. Для любого х, для любого у. Из того, что х не равно у, следует, ну вот что. То есть
[58:02.640 --> 58:14.880]  любая пара разных элементов сравнима. Вот тогда все в порядке. Тогда проблем не будет у нас. Любое
[58:14.880 --> 58:19.360]  отношение линейного порядка, скажем, действительные числа со строгим неравенством, как вот мне
[58:19.360 --> 58:24.560]  предлагали, оно уже будет удовлетворять этому. Оно является отношением строгого порядка и будет
[58:24.560 --> 58:28.840]  удовлетворять этому свойству, потому что любые два разных действительных числа вы можете сравнить.
[58:28.840 --> 58:37.240]  Или одно больше, или другое больше. Возникает другая трудность. У нас в формуле появилось что? Еще
[58:37.240 --> 58:47.560]  один предикат. И теперь другая проблема. Я могу этот предикат интерпретировать как угодно. Например,
[58:47.560 --> 58:57.080]  как пустое множество. И тогда моделями теории t плюс вот эта формула lin будут вообще все строгие
[58:57.160 --> 59:04.000]  частичные порядки. Потому что если это пустое множество, предикат всегда истинный, мы просто...
[59:04.000 --> 59:12.720]  Сейчас, секунду. Наоборот, нужно, чтобы он был всегда ложный. А он будет всегда ложный, потому что,
[59:12.720 --> 59:27.320]  ну да, естественно, как бы вы... А нет, то есть нам нужно, чтобы предикат неравенства был пустым,
[59:27.320 --> 59:32.240]  значит все элементы равны. Тогда вот это вот всегда ложно, и эта формула всегда будет оцениваться
[59:32.240 --> 59:40.520]  истинной. Это некоторая проблема, которая мешает, вообще говоря, в нашем формализме. У нее есть
[59:40.520 --> 59:47.360]  некоторое стандартное решение. Я, наверное, сегодня расскажу только кусочек, а подробнее расскажу,
[59:47.360 --> 59:54.400]  когда потребуются детали. Кусочек состоит в следующем. Часто рассматриваются не просто модели,
[59:54.400 --> 59:59.000]  я даже это не буду писать, для нас это будет немножко вспомогательным понятием. Не просто
[59:59.000 --> 01:00:03.400]  модели теории рассматриваются, а то, что называется нормальные модели. Нормальная модель это вот что
[01:00:03.400 --> 01:00:08.320]  такое. У нас в сигнатуре теории выделяется бинарный предикатный символ, который мы считаем
[01:00:08.320 --> 01:00:16.600]  равенством. Он обычно и обозначается знаком равенства. И нормальная модель, когда символ
[01:00:16.600 --> 01:00:21.040]  равенства предикатный, интерпретируется как именно равенство в модели, то есть как бинарный
[01:00:21.040 --> 01:00:26.400]  предикат равенства. И тогда у нас вот проблем не возникает. Если я говорю про нормальную модель
[01:00:26.400 --> 01:00:33.080]  теории t плюс лин, это в точности линейные порядки. То есть нормальные модели все такие. Но
[01:00:33.080 --> 01:00:44.040]  вторая сторона этого вопроса, что на уровне модели я всегда могу сказать, что этот выделенный символ
[01:00:44.040 --> 01:00:50.360]  я интерпретирую как равенство. Но мне может захотеться сами формулы подкрутить, чтобы, раз уж я
[01:00:50.360 --> 01:00:54.200]  ввел равенство, чтобы у меня не было сомнений, что этот символ нужно интерпретировать как
[01:00:54.200 --> 01:01:00.280]  равенство. Для этого есть некоторый специальный набор формул, которые добавляются в теорию с
[01:01:00.280 --> 01:01:07.360]  равенством. И это понятно, что это свойство равенства. Отношение эквивалентности, рефлексивность,
[01:01:07.360 --> 01:01:12.600]  что x равно x. Симметричность x равно y следует y равно x. Ну и транзитивность та же самая.
[01:01:12.600 --> 01:01:18.360]  Кроме того, нам нужно еще убедиться, что все остальные функции предиката уважают это равенство.
[01:01:18.360 --> 01:01:25.800]  Что если вы в предикат подставляете равные значения, скажем, a от x1 и y1 и a от x2 и y2. Если x1
[01:01:25.800 --> 01:01:32.920]  равен x2 и y1 равен y2, у вас должно получаться одинаковое значение. Вот нужно для каждого
[01:01:32.920 --> 01:01:37.680]  символа и сигнатуры добавить еще вот такие формулы согласования. Тогда получается то,
[01:01:37.680 --> 01:01:43.800]  что называется теория с равенством. И в сущности, за исключением несущественной подробности,
[01:01:43.800 --> 01:01:48.480]  это практически у теории с равенством и будут модели нормальными, только нужно взять отношение
[01:01:48.480 --> 01:01:52.840]  эквивалентности. Вот у нас формально определено отношение эквивалентности, нужно взять классы
[01:01:52.840 --> 01:01:58.000]  эквивалентности. Мне это будет нужно в очень специальном случае, я поэтому подробно на этом
[01:01:58.000 --> 01:02:03.040]  останавливаться не буду. Можно было бы сразу перейти к нормальным моделям, считая, что у нас
[01:02:03.040 --> 01:02:07.760]  всегда есть сигнатуры равенства, всегда мы его интерпретируем как равенство, но это создает
[01:02:07.760 --> 01:02:12.720]  другие неудобства. Неудобства, связанные с рассуждениями по индукции и так далее,
[01:02:12.720 --> 01:02:19.320]  вот этот более свободный синтаксис, он позволяет легче простраивать доказательства, а с равенством
[01:02:19.320 --> 01:02:25.640]  рассуждения могут оказаться более сложными. Поэтому я по умолчанию буду считать, что у нас
[01:02:25.640 --> 01:02:31.200]  модели общие, а если я буду говорить о нормальных моделях, я буду прям так это специально оговаривать,
[01:02:31.200 --> 01:02:36.640]  имейте в виду. Ну и тем более о теориях с равенством, там я буду просто аккуратно прям выписывать
[01:02:36.640 --> 01:02:45.720]  все эти свойства. Вот это такая особенность с моделями и вот мы более-менее сейчас показали,
[01:02:45.720 --> 01:02:53.240]  что всю математику можно в принципе себе мыслить как игру, как изучение семантических
[01:02:53.240 --> 01:02:58.600]  следствий с теорией, осталось только понять, почему у нас все-таки формализм первого порядка
[01:02:58.600 --> 01:03:03.880]  очень ограничен. В прошлый раз мы обсуждали, что у нас в математике бывают такие индуктивные
[01:03:03.880 --> 01:03:09.000]  определения, как я давал определение целого числа, используя сигнатуру алгебритарского,
[01:03:09.000 --> 01:03:16.080]  там было индуктивное определение. Ну и формулы мы определяем индуктивно, не стесняясь. Бывает
[01:03:16.080 --> 01:03:20.880]  много чего и возникает вопрос, почему собственно мы считаем, что формализм первого порядка такой
[01:03:20.880 --> 01:03:27.320]  уж удобный. Еще один пример, когда он неудобен, когда вы изучаете анализ, там проблема в том,
[01:03:27.320 --> 01:03:33.240]  что наш формализм первого порядка, он бестиповый, то есть все переменные, они одного уровня, они
[01:03:33.240 --> 01:03:38.320]  принадлежат просто носителю модели. А в анализе страшно неудобно, потому что вы говорите о числах и
[01:03:38.320 --> 01:03:44.680]  о функциях. И получается так, что нужно либо переходить к формулам второго порядка, разрешать
[01:03:44.680 --> 01:03:54.680]  кванторы по функциям. Для любой функции счет выполняется. Либо, чтобы сохранить первый порядок,
[01:03:54.680 --> 01:04:02.720]  нужно ввести в качестве носителя модели такое противоестественное явление, как действительные
[01:04:02.720 --> 01:04:09.960]  числа и функции на действительных числах, и ввести еще такой вот предикат тип, предикат число,
[01:04:09.960 --> 01:04:14.680]  который примененный к их говорит, что он истинный, если это число, а если это функция, то он ложный.
[01:04:14.680 --> 01:04:22.160]  И тогда все можно записать, не вводя предикатов по функциям, но это очень громоздко. Почему же я так
[01:04:22.160 --> 01:04:27.400]  уверен, что всю математику, тем не менее, можно выразить логикой первого порядка. Дело в том,
[01:04:27.400 --> 01:04:36.360]  что это некоторая общая догма, в которую все верят, что всю математику можно выразить в
[01:04:36.360 --> 01:04:42.720]  теории множества. Множество, я напомню так, если неформально, это просто совокупность элементов
[01:04:42.720 --> 01:04:48.440]  какой-то природы. Множество равны, если в них ходят одни и те же элементы, ничего больше нет. И
[01:04:48.440 --> 01:04:57.800]  оказывается, это люди долго к этому шли, но смогли всю математику простроить из множества. Значит,
[01:04:57.800 --> 01:05:05.000]  тут я всегда делаю оговорку, связанную вот с чем, что сто с лишним лет назад математики были очень
[01:05:05.000 --> 01:05:11.560]  озабочены корректностью формализма, и действительно пересказывали на формальном уровне практически все
[01:05:11.560 --> 01:05:19.200]  новые результаты. И это все получалось. А потом оторопь от того, что в основаниях математики
[01:05:19.200 --> 01:05:25.920]  обнаружились проблемы, прошла, выросло новое поколение математиков, и оно стало больше
[01:05:25.920 --> 01:05:31.600]  интересоваться интересными приложениями физики и так далее, а основания как-то отошли на второй
[01:05:31.600 --> 01:05:37.760]  план. И с тех пор прошло уже лет 70, по меньшей мере, то есть уже не одно поколение несколько
[01:05:37.760 --> 01:05:44.680]  сменилось, и доказано, что сто тысяч теорем, я думаю, это довольно точная отсылка. И конечно,
[01:05:44.680 --> 01:05:48.480]  в доказательствах этих теорем математики не стесняются, они используют средства,
[01:05:48.480 --> 01:05:55.800]  какие только могут. И верно ли, что любую доказательство любой теоремы можем пересказать
[01:05:55.800 --> 01:06:01.320]  в теории множества, сейчас это отчасти вопрос веры, потому что для каждой теоремы, которую
[01:06:01.320 --> 01:06:11.120]  доказало человечество, это не проделано. Это могло бы быть проделано, если бы научились боты,
[01:06:11.120 --> 01:06:17.480]  которые выдают себя за искусственный интеллект, научились бы не писать политические заметки,
[01:06:17.480 --> 01:06:22.280]  а читать математические статьи и писать формальные доказательства по ним. В общем-то,
[01:06:22.280 --> 01:06:26.120]  дело-то нехитрое, на самом деле, математические статьи и без того довольно формально написаны.
[01:06:26.120 --> 01:06:30.800]  Казалось бы, это не должно быть такой неподъемной работой, но вот эта цель,
[01:06:30.800 --> 01:06:35.040]  которую, в принципе, по моим оценкам, мощности компьютера хватало бы для достижения этой цели
[01:06:35.040 --> 01:06:41.560]  где-то в начале 21 века, то есть в тысячу раз меньше, чем есть сейчас. Но эта цель сейчас
[01:06:41.560 --> 01:06:48.020]  не достигнута, я подозреваю, еще в течение 20 лет не будет достигнута. А статьи из-за политиков
[01:06:48.020 --> 01:06:56.180]  писать будут это, конечно, но это просто задача немножко разной, трудность. Вот,
[01:06:56.180 --> 01:07:05.180]  так давайте все-таки я объясню, на чем зиждется наша уверенность. Нам нужен всего один предикатный
[01:07:05.180 --> 01:07:12.580]  бинарный символ. Чтобы говорить о множествах, как ни странно, у нас сигнатура будет примитивнейшая,
[01:07:12.580 --> 01:07:17.340]  просто один предикатный символ. Без предикатных символов нельзя, я вот уже стер, вот остались
[01:07:17.340 --> 01:07:21.620]  правила оценки. Видно, что чтобы была формула, нужно, чтобы хотя бы один предикатный символ был,
[01:07:21.620 --> 01:07:26.820]  иначе у нас нет атомарной формулы, ничего не построено. Так вот, теория множества мы будем
[01:07:26.820 --> 01:07:30.980]  объяснять, используя всего-навсего один предикатный символ. Понимаем мы его так,
[01:07:30.980 --> 01:07:37.660]  x принадлежит y, то есть x является элементом y. Ну, с помощью этого предикатного символа можно
[01:07:37.660 --> 01:07:42.980]  определять много других предикатов, используя правила первого порядка. Например, что значит,
[01:07:42.980 --> 01:07:51.780]  что x под множество y. Ну, мы знаем, что это такое, что для любого z из того, что z входит в x,
[01:07:51.780 --> 01:08:00.780]  следует, что z входит в y. Согласно, да, вот как мы определяем под множество, вот так и определяем,
[01:08:00.780 --> 01:08:08.220]  что каждый элемент, который входит в x, входит в y. Ну, а что такое равенство? У нас были проблемы
[01:08:08.380 --> 01:08:14.860]  с равенством, тут проблема решается очень просто. Это по определению означает, так мы множество не
[01:08:14.860 --> 01:08:22.740]  формально определяли, что x содержится в y и y содержится в x. Ну, формулы первого порядка.
[01:08:22.740 --> 01:08:30.980]  Ну, пока мы недалеко ушли, давайте определим еще какую-нибудь вещь. Скажем, я хочу определить,
[01:08:30.980 --> 01:08:38.740]  что множество x всего один элемент. Обычно такие множества называются синглитоны. Как это сделать?
[01:08:38.740 --> 01:08:46.260]  Ну, давайте попробуем. Для этого надо написать какую-нибудь формулу, где параметром является x,
[01:08:46.260 --> 01:08:57.980]  но с какими-то переменными. Значит, что для любого y. Не так. Существует такой y, что, во-первых,
[01:08:57.980 --> 01:09:17.100]  y входит в x. И для любого z, из того, что z входит в x, следует, что z равняется y. Согласно. Как
[01:09:17.100 --> 01:09:20.660]  определить, что множество ровно один элемент? Вот мы говорим, что такой элемент есть в этом
[01:09:20.660 --> 01:09:25.140]  множестве элемента, оно не пустое. Пустое множество тоже определить легко. Что значит,
[01:09:25.140 --> 01:09:35.220]  что пустое множество? Это по определению означает, что для любого x неверно, что x принадлежит пусто.
[01:09:35.220 --> 01:09:41.300]  Это и все. А тут оно не пустое, хотя бы один элемент есть. Дальше мы добавляем условия,
[01:09:41.300 --> 01:09:45.180]  что других нет, что если я взял какой-то другой элемент, то он принадлежит множеству,
[01:09:45.180 --> 01:09:58.220]  то он с x совпадает. Следующий факт, не факт, а предикат, который хорошо бы выразить, это что в
[01:09:58.220 --> 01:10:06.780]  множестве два элемента. Ну, я думаю, я даже не буду сейчас писать. Я думаю, что всем понятно,
[01:10:06.780 --> 01:10:11.660]  как такую формулу написать. Ну, вот здесь надо заменить. Существует y и существует,
[01:10:11.660 --> 01:10:20.540]  не знаю, v такие, что y принадлежит x, v принадлежит x, y не равно v. И для любого z, если z принадлежит x,
[01:10:20.540 --> 01:10:28.980]  ну, дизьюнция или z равен y или z равен v. В общем, такую формулу написать можно. Ну,
[01:10:28.980 --> 01:10:38.220]  и там что три элемента, в общем, любое конечное число элементов мы написать можем. Но этого пока
[01:10:38.220 --> 01:10:47.340]  мало. Значит, решающий шаг, решающий шаг состоит в том, что нам нужно определить, что такое упорядоченная
[01:10:47.340 --> 01:10:55.060]  пара. Множество, они не упорядоченные, там вот они определяются в точности своими элементами. А
[01:10:55.060 --> 01:11:01.740]  нам в определениях очень часто бывает, можно говорить о последовательностях и вот как минимум
[01:11:01.740 --> 01:11:06.860]  в упорядоченных парах. Ну, если вы вспомните, вам почти заведомо вводили понятие Декартова
[01:11:06.860 --> 01:11:11.620]  произведения множества. Оно определяется как множество упорядоченных пар. А что такое упорядоченная
[01:11:11.620 --> 01:11:18.060]  пара? Как ее выразить? Если мы все хотим построить из множества, мы должны как-то уметь выражать
[01:11:18.060 --> 01:11:29.620]  упорядоченную пару из множества. Ну, и я сейчас напишу содержательное определение. Оно не единственно
[01:11:29.620 --> 01:11:35.380]  возможное, но вот одно из стандартных упорядоченных пар по Куратовскому называется. Упорядоченная пара
[01:11:35.380 --> 01:11:42.900]  называется множество, в которое входит в качестве элементов только множество, содержащее ровно один
[01:11:42.900 --> 01:11:50.580]  элемент х и множество, которое содержит х и у. На самом деле, сколько элементов в таком множестве,
[01:11:50.580 --> 01:12:03.620]  это еще вопрос. И обязательно, может быть один, если у равняется х. Потому что если у равняется х,
[01:12:03.620 --> 01:12:09.540]  вот это множество, это множество, это одно и то же. В перечислении сколько мы не перечислим. Ясно,
[01:12:09.540 --> 01:12:15.340]  что это определение в первом порядке переписывается. То есть мы пишем, во-первых, что это множество
[01:12:15.340 --> 01:12:23.900]  содержит два элемента, а дальше мы пишем, что это вот синг и содержит именно х, а это вот мы
[01:12:23.900 --> 01:12:32.620]  пишем без условия, что х не равен у, пишем формулу для пары. То есть это все записывается и
[01:12:32.620 --> 01:12:39.500]  получается длинная формула, но которая задает упорядоченную пару. Почему я так сражаюсь столько
[01:12:39.500 --> 01:12:44.380]  времени с упорядоченной парой? Потому что я не случайно упоминал про Декартово произведение.
[01:12:44.380 --> 01:12:47.980]  Теперь, имея упорядоченную пару, мы можем определить, что такое Декартово произведение множество.
[01:12:47.980 --> 01:12:57.260]  Х Декартово на у, нам нужно определить, что значит, что z какой-то принадлежит Декартово
[01:12:57.260 --> 01:13:01.820]  произведению. З принадлежит х умножить на у, если существует у принадлежащая х,
[01:13:01.820 --> 01:13:10.180]  в принадлежащий у такое, что х является упорядоченной парой у в. Определили. А в
[01:13:10.180 --> 01:13:15.220]  частности Декартово произведение множество позволяет нам определить понятие функции. Я не знаю,
[01:13:15.220 --> 01:13:21.260]  рассказывали ли вам про это в прошлом году, но должны были по идее, что функция такой,
[01:13:21.260 --> 01:13:28.420]  это фактический график функции, но с точки зрения теории множества, это и есть функция. Функция
[01:13:28.420 --> 01:13:35.740]  это множество таких упорядоченных пар и х и у, что каждым х отвечает не более одного у. Ну,
[01:13:35.740 --> 01:13:42.540]  а имея функции, мы уже можем много чего сделать. Можем, например, определить, что такое инъекция,
[01:13:42.540 --> 01:13:47.700]  что такое сюръекция, что такое биекция. Наконец, мы можем определить бесконечное множество. Потому что
[01:13:48.340 --> 01:13:59.100]  бесконечестный множие является обеим. И это самова, равномощная данным. Равномощная
[01:13:59.100 --> 01:14:04.020]  существует биекция. Что такое биекция, мы мы определить можем. Значит, у нас появляется
[01:14:04.020 --> 01:14:08.400]  понятие бесконечного множства, появляется понятие конечного множца. Но, чтоб развивать
[01:14:08.400 --> 01:14:14.880]  математику содержательную, нам вообще-то надо не столько бесконечный множ puff, а сколько прямо
[01:14:14.880 --> 01:14:19.500]  честно натуральные числа. Потому что это в 19 веке еще стало
[01:14:19.500 --> 01:14:21.940]  известно, что, если у нас есть понятие натурального
[01:14:21.940 --> 01:14:25.620]  числа, дальше математики умеют выстраивать всю свою
[01:14:25.620 --> 01:14:30.780]  науку. Определить целые числа, как в школе это
[01:14:30.780 --> 01:14:32.980]  делается, потом определить рациональные числа, это
[01:14:32.980 --> 01:14:35.860]  тоже делается в школе уже не настолько чисто, потом
[01:14:35.860 --> 01:14:37.780]  определить действительные числа, в школе это делается
[01:14:37.780 --> 01:14:40.840]  совсем не часто, ну может быть вас на анализе на первом
[01:14:40.840 --> 01:14:43.100]  курсе научили это делать часто, ну если не научили,
[01:14:43.100 --> 01:14:44.440]  Не то чтобы безумно сложно.
[01:14:45.700 --> 01:14:47.980]  Есть понятие додакиндово сечение,
[01:14:47.980 --> 01:14:49.540]  есть понятие бесконечная двоичная дробь,
[01:14:49.540 --> 01:14:52.580]  то есть есть много способов выстроить теорию
[01:14:52.580 --> 01:14:54.320]  действительного числа, если у вас есть
[01:14:54.320 --> 01:14:55.880]  рациональные числа.
[01:14:55.880 --> 01:15:00.080]  Ну и более сложные объекты из этого
[01:15:00.080 --> 01:15:02.020]  можно строить, ну и произвольное множество
[01:15:02.020 --> 01:15:02.920]  можно строить.
[01:15:02.920 --> 01:15:04.680]  Для алгебры скорее нужны произвольные множества.
[01:15:04.680 --> 01:15:06.520]  Ну там операции, ну опять-таки если
[01:15:06.520 --> 01:15:07.920]  возьмем алгебру, что там нужно?
[01:15:07.920 --> 01:15:10.520]  Нужны операции, нужно уметь объяснять
[01:15:10.520 --> 01:15:11.820]  свойства операции, то есть видно,
[01:15:11.820 --> 01:15:16.220]  что формулы первого порядка, если уж мы можем определить функции, должно хватить, чтобы те же
[01:15:16.220 --> 01:15:22.540]  аксемумы груб задать. А натуральные числа, их можно по-разному определять. Когда появляется
[01:15:22.540 --> 01:15:27.300]  конечное множество, уже можно пытаться определить количество элементов в нем. Удобнее всего это
[01:15:27.300 --> 01:15:35.900]  сделать, задав прям натуральный ряд. Натуральный ряд в теории множества обычно задают вот так.
[01:15:35.900 --> 01:15:47.220]  Вот смотрите, это число 0, это число 1, это число 2. Как, если у нас есть множество,
[01:15:47.220 --> 01:15:52.820]  задающее число n, построить множество, задающее число n плюс 1? Нужно взять множество,
[01:15:52.820 --> 01:15:59.540]  отвечающее числу n и добавить в него в качестве элемента само это множество. Ну 3 я сейчас так
[01:15:59.540 --> 01:16:08.180]  напишу. У нас есть 2. Чтобы задать 3, я беру множество, задающее 2 и добавляю в качестве
[01:16:08.180 --> 01:16:15.300]  элемента само это множество. Ну и понятно, что так можно продолжать неограниченно долго. Получаются
[01:16:15.300 --> 01:16:24.740]  натуральные числа. Дальше можно считать, что элемент этого множества, это можно определить с
[01:16:24.740 --> 01:16:30.820]  некоторым трудом, но можно. Элемент этого множества кодирует натуральное число. И чтобы говорить о
[01:16:30.820 --> 01:16:36.300]  конечном множестве какого-то размера, мы говорим, что есть биекция вот с этим фиксированным множеством,
[01:16:36.300 --> 01:16:43.060]  которое мы определили. То, что вы там написали 1, 2, 3, это мощности множества. Ну это и мощности
[01:16:43.060 --> 01:16:48.140]  множества. Это на самом деле просто множество, которое отвечает натуральным числам. Формальная
[01:16:48.140 --> 01:16:52.580]  теория множества, не при всех подходах, но при некоторых. Под натуральным числом понимается
[01:16:52.580 --> 01:17:04.140]  множество вот такого вида. У нас же есть только предикатный символ, как откуда взять натуральное
[01:17:04.140 --> 01:17:08.780]  число. Ну вот пустое множество я определил. А дальше каждый вот этот переход, он определяется
[01:17:08.780 --> 01:17:13.460]  формулой первого порядка. Потому что, что я сказал, естественно определяется. Там еще нужны некоторые
[01:17:13.460 --> 01:17:19.380]  свойства, чтобы этот процесс был именно однозначный, чтобы у нас продолжение было однозначно. Но это все
[01:17:19.380 --> 01:17:25.860]  делается, это можно аккуратно сделать. Никаких сложностей с этим нет, если у нас есть понятие
[01:17:25.860 --> 01:17:35.340]  функции. Ну вот, у меня осталось буквально три минуты, я хочу немножко вас разочаровать. Так
[01:17:35.340 --> 01:17:39.740]  получается все красиво, мы всю математику теорию множества вложили. А давайте зададимся вопросом.
[01:17:39.740 --> 01:17:46.300]  Да, значит, про что я не сказал и не буду говорить. Свойства множества можно описать тоже как теорию
[01:17:46.300 --> 01:17:50.940]  первого порядка. То есть написать множество, определить множество формул первого порядка,
[01:17:50.940 --> 01:17:56.420]  которые задают вот аксиомы теории множества. Ну там есть разные аксиомы, в частности вот то,
[01:17:56.420 --> 01:18:01.420]  что я использовал, что экстенсиональности, что множество равны тогда и только тогда, когда у
[01:18:01.420 --> 01:18:07.660]  них одинаковые элементы. Есть более сложные аксиомы. В общем, это называется, их несколько
[01:18:07.660 --> 01:18:15.180]  вариантов, но самый стандартный называется ZFC. И там, ну вы можете в википедии посмотреть или в
[01:18:15.180 --> 01:18:23.620]  каких-нибудь книжках под названием теория множества. Есть списки этих аксиом. Там некоторые аксиомы такие,
[01:18:23.620 --> 01:18:28.020]  что не сразу поймешь, почему они нужны, но они действительно нужны. Без них не удается ничего
[01:18:28.020 --> 01:18:35.060]  доказывать. А эти аксиомы, они существенны тем, что все свойства, которые мы знаем про множество,
[01:18:35.060 --> 01:18:39.420]  там вообще говорят доказать можно. То есть поэтому получается так, что все, что мы можем доказать
[01:18:39.420 --> 01:18:46.460]  математике, можем доказать ZFC. Значит ZFC – неоднородное обозначение. Z и F – это фамилии,
[01:18:46.460 --> 01:18:53.660]  это Цермелла и Френкель. Два математика. А C – это не фамилия. Дело в том, что среди аксиом,
[01:18:53.660 --> 01:18:58.700]  это примерно как в геометрии, среди аксиома есть очень аксиома, которая у всех вызывала раздражение,
[01:18:58.700 --> 01:19:06.220]  аксиома выбора. Значит, часть аксиом, теория множества говорит о том, как можно строить множество из
[01:19:06.220 --> 01:19:12.540]  уже имеющихся. Например, если у вас есть множество и есть какая-то формула первого порядка,
[01:19:12.540 --> 01:19:17.780]  но в сигнатуре множества, то она может выделить те элементы из данного множества, которые
[01:19:17.780 --> 01:19:22.300]  удовлетворяют этой формуле. Ну, формула с одним параметром. То есть такое определение через
[01:19:22.300 --> 01:19:28.580]  свойства. Но есть еще одно определение, которое такое, что если у вас есть семейство множеств,
[01:19:28.580 --> 01:19:32.740]  это тоже можно аккуратно определить, что такое, вы можете построить множество,
[01:19:32.740 --> 01:19:38.700]  выбрав по одному элементу из каждого семейства. Ну, как наглядно это представляет так. Представьте,
[01:19:38.700 --> 01:19:44.820]  что у вас стоят подносы с кучей печеньек. И вот вы можете выбрать из каждого подноса по одной
[01:19:44.820 --> 01:19:50.100]  печеньке, образовать новое множество. Но очень невинные аксиомы, печеньки-то точно с подноса
[01:19:50.100 --> 01:19:55.660]  собрать можно, это все понимают. Но из этой аксиомы следуют очень странные выводы. В ZFC можно
[01:19:55.660 --> 01:20:02.180]  доказывать очень неприятные с точки зрения нашей интуиции вещи. Сейчас уже закончилось,
[01:20:02.180 --> 01:20:07.860]  я последнее что скажу. Можно, например, доказать, что шар трехмерный, можно разбить на несколько
[01:20:07.860 --> 01:20:16.580]  частей пять, что ли. Так чтобы, по-моему, пять. У вас восемь получилось? Посмотрите книжку Яченко,
[01:20:16.580 --> 01:20:24.820]  по-моему, он объясняет, как пять сделать. Значит, так их повернуть, чтобы сложить шар вдвое
[01:20:24.820 --> 01:20:32.100]  большего диаметра. То есть решим продовольственную проблему человечеству. Взяли клубень картофельный,
[01:20:32.100 --> 01:20:39.380]  разрезали на пять частей и сложили два таких же. Ну потом можно это повторять сколько нужно. Вот,
[01:20:39.380 --> 01:20:44.500]  то есть это, конечно, выглядит неправдоподобно и противоречит нашей интуиции, но тем не менее,
[01:20:44.500 --> 01:20:51.260]  если вы признаете аксиомы ZFC, там это доказуемо. Вот, поэтому C всегда выделяют. Иногда рассматривают
[01:20:51.260 --> 01:20:57.220]  ZF, это без аксиома выбора. Там можно много тоже доказать чего, но не все. Иногда аксиомы выбора
[01:20:57.220 --> 01:21:03.460]  заменяют на не менее странные аксиомы, которые с аксиомой выбора не согласуются, и у них тоже есть
[01:21:03.460 --> 01:21:09.100]  какие-то приятные следствия и неприятные следствия. В общем, но про формальную теорию множества я буду
[01:21:09.100 --> 01:21:14.660]  говорить сильно позже и не очень подробно. Это все-таки для начального курса слишком сложный предмет,
[01:21:14.660 --> 01:21:20.180]  то есть я даже список аксиомов не буду выписывать, уж тем более не буду пытаться объяснять, как из них
[01:21:20.180 --> 01:21:24.660]  все доказывается. Ну, вы можете взять какую-нибудь старую книжку, например, Куротовского теории
[01:21:24.660 --> 01:21:31.980]  множества или какие-то более новые. В принципе, сейчас перевели какие-то книжки хорошие. Я так даже
[01:21:31.980 --> 01:21:36.740]  не посоветую, но я читал в свое время Куротовского. Ну, занудное чтение в какой-то момент просто
[01:21:36.740 --> 01:21:40.260]  становится скучно, потому что начинаешь понимать... Кстати, в Мендельсоне, насколько я помню,
[01:21:40.260 --> 01:21:44.540]  который у нас в списке литературы, там формальная теория множества до какого-то предела развита.
[01:21:44.540 --> 01:21:51.620]  Обычно скучно становится раньше, чем заканчивается этот начальный уровень, потому что становится понятно,
[01:21:51.660 --> 01:21:56.020]  ну да, так вот все можно доказать, но вот мучиться с формальными доказательствами становится уже не
[01:21:56.020 --> 01:22:02.820]  интересно. Когда становится ясно, что да, все наши неформальные рассуждения вот такими трюками можно
[01:22:02.820 --> 01:22:05.580]  воспроизвести. Ну хорошо, на сегодня все тогда.
