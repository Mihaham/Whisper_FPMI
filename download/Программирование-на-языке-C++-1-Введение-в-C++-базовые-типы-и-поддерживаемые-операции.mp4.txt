[00:00.000 --> 00:05.000]  Фи-шна-шна-пи-на-пи-шна-пи-шна
[00:05.000 --> 00:08.000]  Фи-шна-шна-пи-на-пи-шна-пи
[00:08.000 --> 00:11.000]  Фи-шна-шна-пи-на-пи-шна-пи
[00:11.000 --> 00:14.000]  Фи-шна-шна-пи-на-пи-шна-пи
[00:14.000 --> 00:17.000]  Фи-шна-шна-пи-на-пи-шна-пи
[00:17.000 --> 00:20.000]  Фи-шна-шна-пи-на-пи-шна-пи
[00:20.000 --> 00:23.000]  Фи-шна-шна-пи-на-пи-шна-пи
[00:23.000 --> 00:26.000]  Фи-шна-шна-пи-на-пи-шна-пи
[00:26.000 --> 00:29.000]  Фи-шна-шна-пи-на-пи-шна-пи
[00:29.000 --> 00:32.000]  Фи-шна-шна-пи-на-пи-шна-пи
[00:32.000 --> 00:35.000]  Фи-шна-шна-пи-на-пи
[00:35.000 --> 00:38.000]  Фи-шна-шна-пи-на-пи
[00:38.000 --> 00:41.000]  Фи-шна-шна-пи-на-пи
[00:59.000 --> 01:08.760]  можно и лично. В общем, как меня найти в телеграмме, вы знаете. У нас годовой курс
[01:08.760 --> 01:17.120]  программированный C++. В первом семестре у нас будет зачет, во втором семестре у вас будет
[01:17.120 --> 01:33.520]  экзамен. Зачет будет устроен примерно так, что... Зачет будет так выглядеть в первом
[01:33.520 --> 01:44.920]  семестре. Примерно 60 процентов вашей оценки это задача. Примерно 30 процентов вашей оценки
[01:44.920 --> 01:57.800]  это будет... Даже не так, наверное. Я бы сказал, где-то 65 процентов вашей оценки будут задачи,
[01:57.800 --> 02:14.280]  35 процентов вашей оценки это будет теор-зачет в конце, а еще 10 процентов вашей оценки это будет
[02:14.280 --> 02:22.200]  бонус от семинариста. Семинарист вам может иногда будет давать какие-то свои мелкие задачки,
[02:22.200 --> 02:31.840]  или, возможно, за хорошую работу на семинарах вам начистится какой-то бонус. В общем, бонус.
[02:31.840 --> 02:46.160]  Почему суммарно 110 процентов? Ну, потому что, чтобы набрать отл 10, вам можно в чем-то немножечко
[02:46.160 --> 02:53.720]  продолбаться. Если бы суммарно было 100 процентов, то набрать 10 было бы слишком сложно, а так это не
[02:53.720 --> 03:03.560]  настолько сложно. Хотя, что может быть. Ну, а во втором семестре у нас будет экзамен, и там будут другие
[03:03.560 --> 03:11.000]  правила, про них уже весной расскажу. Экзамен будет годовой. Ну, курс, наверное, вас и так запугали,
[03:11.000 --> 03:19.480]  что курс довольно сложный, материалов очень много, экзамен тоже довольно сложный. Короче,
[03:19.480 --> 03:29.360]  вот это придется усиленно. И еще одна из проблем этого курса, в отличие от курса алгоритмов,
[03:29.360 --> 03:35.800]  например, который начинается, так сказать, вместо карьеры, резко поехали. Наш курс, он очень
[03:35.800 --> 03:41.440]  коварный, потому что начинается он очень легко. И вторая лекция не сложная, и третья лекция не
[03:41.440 --> 03:47.240]  сложная, и вы такие, что тут все просто. И, короче, вы такие, думаете, генсилизируете, ну ладно,
[03:48.200 --> 03:52.680]  а потом вы выясняете, что оказывается, на самом деле, все было сложно, просто сложность,
[03:52.680 --> 03:59.880]  она растет вот так, и она как бы каждый год вот так возрастает. И поэтому, если вам первые четыре
[03:59.880 --> 04:06.280]  раза кажется, что все легко, то это обман, и на самом деле дальше будет только хуже с каждым разом. Короче,
[04:06.280 --> 04:15.080]  не поддавайте обманщему впечатлению, и не забивайте в середине. Вот, сейчас я поговорю
[04:15.080 --> 04:25.320]  некоторое количество времени про какие-то вводные вещи, типа я поговорю общие слова о языке C++,
[04:25.320 --> 04:32.360]  и почему он так устроен, а потом, и почему мы его замечаем, а потом начну уже содержать для
[04:32.360 --> 04:41.880]  участия. Вот, значит, ведение, пролог, я бы сказал. Ну, язык программирования C++, вы, наверное,
[04:42.200 --> 04:49.760]  большинство из вас на нем уже умеет писать, вот, в какой-то мере. Как вы знаете, он произошел
[04:49.760 --> 05:00.360]  от языка C, и это все где-то происходило в годах 80-х, был такой язык программирования C, вот,
[05:00.360 --> 05:07.600]  и в нем еще тогда не было объектно-оментированного программирования, не было, значит, всяких там
[05:07.600 --> 05:14.560]  классов, ну, вообще, все было очень примитивно, были только функции, сырая работа с памятью, вот,
[05:14.560 --> 05:21.600]  программы тогда были маленькие, большие проекты особо, мало кто писал, вот, я, к стыду своему,
[05:21.600 --> 05:28.000]  не помню в каком году, но, в общем, когда-то человек, которого зовут Бьерн Страуструк, мы его
[05:28.000 --> 05:35.080]  будем называть в курсе не иначе как создатель, придумал язык C++ на основе языка C, так что
[05:35.080 --> 05:39.640]  обратная совместимость почти поддержана, то есть почти любая программа, которую вы пишете на C,
[05:39.640 --> 05:47.080]  будет верна и на C++ за редким исключением, но это исключение там какое-то детальное,
[05:47.080 --> 05:51.920]  ну, какое-то техническое, мы даже не будем такие программы рассматривать, в общем, можно с
[05:51.920 --> 05:57.840]  достаточной долей точности считать, что если что-то вы на C написали, то оно и на C++, правильно,
[05:57.840 --> 06:05.280]  аналогично будет работать, вот, я бы нарисовал такую картинку, вот, если это язык C и все его
[06:05.280 --> 06:16.840]  возможности, то язык C++ это примерно вот, чтобы вы понимали примерно соотношение объема того,
[06:16.840 --> 06:22.040]  что есть в этих языках, вот, если вы знаете язык C, ну, на самом деле, возможности языка C мы с
[06:22.040 --> 06:27.320]  вами пройдем примерно так разно за первые там три недели, условно, и весь оставший год будем
[06:27.320 --> 06:35.360]  говорить о том, что появилось в языке C++ по сравнению с C. Количество всяких фичей и возможностей,
[06:35.360 --> 06:40.160]  которые современный язык C++ предоставляет, просто огромно, просто колоссально, и оно настолько
[06:40.160 --> 06:47.160]  колоссально, что уже ни один человек в мире не помнит всю спецификацию языка C++ наизусть
[06:47.160 --> 06:53.640]  полностью даже сам создатель. Это просто невозможно, вот. Существует такой документ,
[06:53.640 --> 07:00.480]  который я вам сейчас покажу, который называется международный стандарт языка C++, вот, я вам
[07:00.480 --> 07:10.800]  открыл версию 2020 года, это такой документ, в котором, как вы видите, 1841 страница мелкого
[07:10.800 --> 07:16.000]  английского текста, это формальное описание, ну, вот, я не знаю, кто-нибудь из вас когда-нибудь читал,
[07:16.000 --> 07:21.040]  там, какой-нибудь, не знаю, налоговый кодекс Российской Федерации, вот, примерно такого же уровня текст,
[07:21.040 --> 07:28.480]  абсолютно формальный, очень мелкий, очень такой строго формализованный, ни в коем случае нельзя
[07:28.480 --> 07:33.040]  воспринимать как учебник какой, допустим, C++, этот документ написан скорее для разработчиков
[07:33.040 --> 07:38.160]  компиляторов, а также для тех, кто, в общем, ну, как справочник он скорее написан, здесь
[07:38.160 --> 07:43.880]  формализовано, полностью описано все возможности. Я вам, например, открою какую-нибудь, значит,
[07:43.880 --> 07:51.240]  статью, ну, вот, я не знаю, например, давайте я вам открою, вот, страницу 347, вот, параграф 13.2,
[07:51.240 --> 07:58.840]  template parameters, и вот, пожалуйста, the sequence, вот, template parameter, и поехали, значит, вот, что
[07:58.840 --> 08:06.760]  бывает, вот, какие бывают, значит, template parameters, вот, что такое type constraint, значит, вот,
[08:06.760 --> 08:15.200]  формальное определение, вот, значит, ну, я думаю, вы поняли примерно стиль того, в котором этот
[08:15.200 --> 08:24.560]  документ написан. Тут есть примеры, тут есть какие-то, значит, определения, в общем, 1800 страниц
[08:24.560 --> 08:32.400]  вот такого текста, это современный язык C++. Конечно, мы с вами постараемся более-менее охватить
[08:32.400 --> 08:39.680]  поверхностное, все то, что, ну, большую часть глав этого документа, но, разумеется, конца этого года вы
[08:39.680 --> 08:45.800]  все еще не будете знать язык C++ полностью, и я его, конечно, не знаю полностью, ну, никто его не знает
[08:45.800 --> 08:54.560]  полностью, вот. Тем не менее, язык C++ выбран нами как главный язык для изучения на первом курсе,
[08:54.560 --> 08:59.400]  потому что есть такое поверье, что если вы уже на C++ пробовать умеете, то дальше вам все будет легко.
[08:59.400 --> 09:06.080]  Ну, действительно, на примере языка C++ можно показать большинство концептов современного
[09:06.080 --> 09:13.280]  программирования, вот, переход с других языков программирования на C++ довольно сложный, а C++ на
[09:13.280 --> 09:20.400]  другие языки кажется проще, потому что когда вы после C++ учите другие языки, вам это кажется так,
[09:20.400 --> 09:27.320]  а, ну, вот, эта штука как C++ только чуть-чуть по-другому, и все. Почти любой язык программирования
[09:27.320 --> 09:34.640]  современный можно так изучить, просто зная C++, и даже если вы какие-нибудь вакансии будете смотреть
[09:34.640 --> 09:40.600]  потом, например, я не знаю, вакансии на расте, зачастую бывает так, что в объявлении просто на
[09:40.600 --> 09:46.320]  работу написано, ну, мы ожидаем, что вы знаете раст, но если знаете C++, то тоже подойдет. Вот
[09:46.320 --> 09:50.640]  эта вот фраза, если вы знаете C++, то тоже подойдет, ее всегда очень приятно читать, потому что понимаешь,
[09:50.640 --> 09:58.720]  ну, ты знаешь, это универсальный язык, к которой подходит много ничего. У языка C++ есть несколько
[09:58.720 --> 10:09.020]  версий, давайте я вам нарисую последовательность версий, а хотя даже я, наверное, на предыдущем
[10:09.020 --> 10:17.040]  слайде останусь. Значит, изначальная версия языка C++ называлась C++98, это был такой первый
[10:17.040 --> 10:22.720]  исторический вот этот стандарт, который был издан в 98 году, потом он был несколько доработан,
[10:22.720 --> 10:34.560]  улучшен и стал называться C++03, все это по годам, вот, потом через 8 лет издали версию языка,
[10:34.560 --> 10:42.840]  которая называется C++11, с тех пор новые версии стали издаваться раз 3 года, после C++11 был
[10:42.840 --> 10:55.960]  C++14, после C++14 был C++17, после C++17 был C++20 и после него был C++23, которые издали только в этом
[10:55.960 --> 11:05.200]  году. То, что я вам открыл это C++20 и на самом деле, ну да, после C++23 будет C++26, как вы можете
[11:05.200 --> 11:14.440]  догадаться. Вот, я несколько прокомментирую вот эту историю. Мы с вами будем в основном пользоваться
[11:14.440 --> 11:20.840]  вот этой версией, и я сейчас вам объясню почему. На самом деле, если кто-то из вас сейчас думает,
[11:20.840 --> 11:29.600]  что мы такие несовременные, на 3 года отстаём от трендов, это неправда. На самом деле,
[11:29.600 --> 11:34.880]  мы очень как раз современные. C++20 это, пожалуй, самая современная версия,
[11:34.880 --> 11:42.440]  которой сейчас люди пользуются. C++23 не пользуются в мире ещё, наверное, почти никто. Это даже не в России
[11:42.440 --> 11:48.600]  мало кто пользуется, почти никто, а в России уж и подавно. Дело в том, что с момента выхода этого
[11:48.600 --> 11:55.400]  стандарта проходит где-то года два, прежде чем компиляторы научатся его поддерживать. C++20
[11:55.400 --> 12:00.560]  ещё не целиком поддерживается компиляторами, если что. Вот, мы с вами даже в этом году, в прошлом
[12:00.560 --> 12:04.680]  году и позапрошлом постоянно такое было, а в этом году мы будем с вами постоянно сталкиваться,
[12:04.680 --> 12:10.280]  ну иногда всё ещё будем сталкиваться с ситуацией, что эта фича вот уже три года как добавлена в язык,
[12:10.280 --> 12:14.920]  но компиляторы всё ещё не научились нормально с ней работать, и есть некоторые тонкости,
[12:14.920 --> 12:20.400]  что вот тут вот это не до конца имплементировано. Вот, но с тех пор как компиляторы научаются
[12:20.400 --> 12:25.400]  поддерживать, ещё проходят года два-три, пока сообщество научается этим пользоваться. Ну то есть
[12:25.400 --> 12:33.040]  сейчас я бы сказал, что большая часть, ну так, наверное, в основном все пользуются сейчас C++17
[12:33.040 --> 12:39.600]  в индустрии. На C++20 более-менее вот современные компании переходят, там какие-нибудь флагманы
[12:39.600 --> 12:48.560]  отечественной IT-разработки, вот они пользуются C++20. На C++20 ещё не все перешли, а C++23 ещё перешёл.
[12:48.560 --> 12:55.880]  На самом деле, большая часть того, что я буду рассказывать, она актуальна для всех версий C++,
[12:55.880 --> 13:03.920]  и разница между вот этими версиями, она у нас во втором семестре только проявится. То есть мы с
[13:03.920 --> 13:09.440]  вами будем примерно идти, можно сказать, примерно в хронологическом порядке, то есть первый
[13:09.440 --> 13:15.720]  семестр мы с вами будем изучать в основном вещи, которые были ещё до 2011 года актуальны. Вот,
[13:15.720 --> 13:20.880]  почти весь второй семестр мы будем с вами изучать версии, которые после 2011 года появились.
[13:20.880 --> 13:29.000]  Вообще C++11 это очень важная версия, это такая, я бы сказал, рубежная версия, ну прошло уже лет
[13:29.000 --> 13:35.560]  перед ней. C++11 по сравнению с предыдущей версией был очень сильным расширением языка, ну я бы
[13:35.560 --> 13:42.280]  примерно вот так нарисовал, если нарисовать круги, то вот обычный C++, там C++03, это примерно,
[13:42.280 --> 13:51.720]  я не знаю, вот столько, по сравнению с C. C++11 это, я не знаю, примерно вот такой круг, ну и дальше
[13:51.720 --> 13:58.480]  маленькие расширения появляются, там C++14, это ещё чуть небольшой круг вокруг него и так далее.
[13:58.480 --> 14:07.080]  То есть новые версии, они всё расширяют, расширяют множество возможностей языка, и тем самым он становится
[14:07.080 --> 14:16.520]  всё более и более необъятным, и выучить его целиком становится всё сложнее и сложнее. Вот. Ну последнее,
[14:16.520 --> 14:24.480]  наверное, что я скажу про, а не, не последнее, я ещё пару вещей скажу. Вот, мне очень нравится такая
[14:24.480 --> 14:37.040]  метафора, сравнение C++ с питоном, метафора связана с рестораном. Вот, как можно фигурально
[14:37.040 --> 14:43.600]  описать, чем C++ от питона отличается. Вот, когда вы приходите в ресторан, у вас есть меню и там
[14:43.600 --> 14:48.560]  перечислены блюда, которые вам могут приготовить. Если вы пробуете на питоне, то вы, по сути,
[14:48.560 --> 14:57.800]  делаете так, вы приходите и у вас там готовые как бы реализованные средства под всё. А бывает так,
[14:57.800 --> 15:03.600]  ну то есть не бывает, а представьте, что вы пришли в ресторан, а вместо блюд в меню вам просто
[15:03.600 --> 15:09.880]  перечислен полный список ингредиентов на кухне, хранящихся, и вы целый мисс бумаги у вас пишите,
[15:09.880 --> 15:16.560]  как хотите, рецепт какой угодно приготовим. Вот, понятно, что во втором случае вы приготовить можете
[15:16.560 --> 15:21.600]  довольно странные вещи, которые бы на нормальном ресторане вам не сделали. Но с другой стороны,
[15:21.600 --> 15:25.760]  даже чтобы сделать какую-то простую вещь, вам потребуется больше текста написать,
[15:25.760 --> 15:30.480]  сильнее подумать, чем если бы вы были в обычном ресторане. Вот эта метафора, на мой взгляд,
[15:30.480 --> 15:35.880]  идеально описывается между питоном и плюсами. Плюсы — это язык, в котором у вас просто почти
[15:35.880 --> 15:41.280]  полная свобода, вот у вас белый лист и просто уйма того, что вы можете сделать, и надо всё
[15:41.280 --> 15:45.400]  аккуратно прописывать, в случай не допустить ошибок, если там что-нибудь вы неаккуратно пишете,
[15:45.400 --> 15:50.360]  у вас и сломается. На питоне и на более простых языках за вас всё сделано, только пользуйтесь
[15:50.360 --> 15:56.280]  готовым набором возможностей. Вот, это объясняет, почему плюсы довольно эффективны, если их
[15:56.280 --> 16:01.080]  правильно использовать и очень опасны, если использовать их неправильно. На плюсах пишутся
[16:01.080 --> 16:07.480]  обычно очень крупные проекты, такие как Яндекс, Яндекс на большей части написан на плюсах, большая
[16:07.480 --> 16:15.160]  часть сервисов Яндекса — поиск, почта, карты, такси, Яндекс диск, что ещё, музыка, большая часть этого
[16:15.160 --> 16:20.840]  написана на плюсах. В ВК много чего написано на плюсах, Телеграм почти полностью написан на плюсах,
[16:20.840 --> 16:27.560]  или вообще полностью. В Гугле и Фейсбуке тоже аналогично, многие части написаны на плюсах. Многие
[16:27.560 --> 16:32.840]  игры написаны на плюсах, особенно те, которые требуют большое количество ресурсов компьютера.
[16:32.840 --> 16:37.760]  Операционные системы написаны на плюсах, такие как Windows и MacOS, они написаны не полностью,
[16:37.760 --> 16:44.520]  но частично на плюсах. На смеси C и плюсов они написаны, ну и C sharp немного, в случае Windows.
[16:44.520 --> 16:53.960]  И ещё на плюсах пишутся биржевое программное обеспечение, ну мост биржа написано на плюсах,
[16:53.960 --> 17:02.280]  сервер мост биржа на плюсах крутится. И криптовалюта, например биткоин, написано на плюсах. Ну и всякие
[17:02.280 --> 17:09.680]  трейдинговые конторы тоже на плюсах пишут, которые с биржей взаимодействуют. Короче,
[17:09.680 --> 17:14.040]  область применения очень широкая, много всяких научных вещей написано на плюсах,
[17:14.040 --> 17:20.360]  плюсы используются, насколько я знаю, физиками для расчётов каких-то научных, тоже в силу своей
[17:20.360 --> 17:30.400]  низкого уровневости эффективности. Короче, вот эти плюсы не прогадай. Вот. Ну и я вам покажу ещё две
[17:30.400 --> 17:38.680]  полезных ссылки, даже три. Вот это так называемый рейтинг языков программирования TIOBE, пожалуй,
[17:38.680 --> 17:47.000]  наиболее известный рейтинг языков программирования. Вот по состоянию 2023 года у нас сейчас самые
[17:47.000 --> 17:53.200]  популярные языки программирования, согласно этому рейтингу, как вы видите, Python, C++ и Java. Ну в общем-то,
[17:53.200 --> 17:58.880]  это и будут те языки, которые вам предстоит изучать. Python поднялся на первое место только в этом году,
[17:58.880 --> 18:03.280]  он очень популярен за счёт изменения в машинном обучении, а также за счёт того, что низкий
[18:03.280 --> 18:09.160]  порог входа. Ну а вот C и плюсы, те языки, которые имеют высокий порог входа, применяются на того,
[18:09.160 --> 18:17.680]  что я сказал, и вот их нам с вами предстоит изучать весь первый курс. Следующая полезная ссылка – это
[18:17.680 --> 18:29.280]  CPP Reference. Это такой сайт, это такая википедия о языке C++. Вот если у вас, если, значит, стандарт – это
[18:29.280 --> 18:34.040]  полностью формализованный документ, по которому невозможно учиться, его невозможно читать,
[18:34.040 --> 18:40.000]  просто только если вам нужно какую-то вот очень глубокую деталь выяснить, то CPP Reference – это такая
[18:40.000 --> 18:48.640]  википедия, по сути, которая вам в более читаемом виде излагает возможности каких-то фичей. Ну,
[18:48.640 --> 18:53.440]  например, вот вы хотите узнать, что такое Вектор, вы открываете, и тут объяснено, что такое Вектор,
[18:53.440 --> 19:00.160]  и тут написано, значит, какие у него есть общие слова о том, что он умеет, и дальше вот какие у него
[19:00.160 --> 19:08.520]  есть методы, какие функции есть. Ну, например, вот как работает Вектор, там, не знаю, оператор
[19:08.520 --> 19:14.400]  квадратной скобочки в Векторе. Ну вот, пожалуйста, вам здесь написано, что умеет оператор квадратной
[19:14.400 --> 19:22.520]  скобочки в Векторе, как он работает, и пример. Очень удобно также здесь то, что про каждую фичу
[19:22.520 --> 19:30.080]  написано, как она с входом версии менялась, то есть, вот видите, до C++20 было так, а начиная с C++20
[19:30.080 --> 19:39.200]  стало так. В чем разница? Ну, вот слово context добавилось, чтобы это не значило. И так про все
[19:39.200 --> 19:46.000]  здесь написано, то есть, про некоторые вещи, может, и прям целую историю, там, до C++11 так, C++17 так,
[19:46.000 --> 19:50.400]  и так далее. В стандарте, конечно, вы такого не увидите, потому что в стандарте фиксируется версия
[19:50.400 --> 19:57.960]  для кого-то. Вот. Я рекомендую вам именно этот сайт для того, чтобы, ну, так, на начальных кварах
[19:57.960 --> 20:06.080]  что-то узнавать по плюсы, причем рекомендую английскую версию in.sik.com. Есть и русская версия,
[20:06.080 --> 20:12.800]  но она раза в три меньше информации содержит, поэтому, короче, все вот эти английские и читаете
[20:12.800 --> 20:19.200]  англоязычные источники информации в интернете. Ну и сейчас я вам сообщу самое главное знание,
[20:19.200 --> 20:27.200]  которое вы должны запомнить с этой лекции. Вообще, если вы запомните единственный факт этой лекции,
[20:27.200 --> 20:32.360]  а все остальные забудете, то пусть это будет он. Есть такой замечательный сайт, называется Stack Overflow.
[20:32.360 --> 20:40.040]  Когда вы не знаете чего-то, когда у вас что-то не работает, какой-то баг, и вы не знаете,
[20:40.040 --> 20:48.040]  как его чинить, значит, вообще у вас есть любой вопрос о программировании, вашим источником ответа
[20:48.040 --> 20:52.200]  на вопрос должен быть этот сайт. Ну, вашим источником ответа на вопрос должен быть Google,
[20:52.200 --> 20:58.120]  конечно, в первую очередь, или Яндекс, кто там что любит. Вы открываете Google, вбиваете свой
[20:58.120 --> 21:03.600]  вопрос, желательно, на английском, и с вероятностью 90% вы найдете ответ на этом сайте. Этот сайт построен
[21:03.600 --> 21:08.720]  как вопросно-ответная система, то есть это такой форум, где люди просто задают вопрос типа,
[21:08.720 --> 21:14.800]  ой, у меня баг, что же мне делать? И люди в ответ пишут, что же это значит и что ему делать,
[21:14.800 --> 21:24.680]  но, разумеется, все по-английски. Вот, я вам гарантирую, что вот 99% вопросов, которые у вас будут
[21:24.680 --> 21:30.240]  возникать по плюсам в течение этого семестра, да и 90% вопросов, которые вы найдете в течение этого
[21:30.240 --> 21:38.000]  года, уже содержат ответы на этом сайте. Поэтому, если вы хотите написать в чат, а что значит эта
[21:38.000 --> 21:44.760]  ошибка, то задумайтесь. Наверное, вы не первый, с этой ошибкой, и, наверное, ответ уже есть в интернете.
[21:44.760 --> 21:52.240]  Вы, конечно, можете написать в чат, но по секрету вам скажу, старший разработчик отличается от Джуна тем,
[21:52.240 --> 21:58.120]  что он умеет искать решение проблем самостоятельно, и если вы научитесь гуглить и пользоваться сайтом
[21:58.120 --> 22:03.880]  Stack Overflow, прежде чем напрягать других людей, это будет огромный плюс вам в карму. Ну, не только в
[22:03.880 --> 22:08.760]  учебе, а вообще в работе, вообще в жизни. Если у вас есть ошибка, постарайтесь, в первую очередь,
[22:08.760 --> 22:19.840]  найти ее на этом сайте. Ну, или в гугле на этом сайте найти перепись, потом пишите в чат. Наверное,
[22:19.840 --> 22:30.640]  это все, что касается вводной части. Дальше можно перейти к неводной части, но неводная часть все равно
[22:30.640 --> 22:39.840]  будет несколько вводная, потому что сейчас я начну первую главу моего представления,
[22:39.840 --> 22:48.200]  которая называется «Введение в C++». Я для удобства, по традиции, буду делить материал на главы,
[22:48.200 --> 22:56.200]  а внутри глав на параграфы. Мне кажется, так удобнее структурировать. И первая глава называется
[22:56.200 --> 23:07.880]  «Введение». Как ни странно. Я скажу, что первая глава называется «Introduction C++»,
[23:07.880 --> 23:30.080]  и первый параграф будет называться, значит, параграф 1.1, у меня будет называться, ну,
[23:30.080 --> 23:42.360]  компилятор и первая программа. На самом деле этот пункт вам, скорее всего, уже изложили на семинарах,
[23:42.360 --> 23:49.240]  не так ли? Ну, у вас у всех или почти у всех уже был первый семинар. Задача первого семинара была
[23:49.240 --> 23:59.560]  то, чтобы вы все из вас научились запускать команду и строчку, выполнять базовые команды и компилировать
[23:59.560 --> 24:11.280]  простейшую программу на плюсах. Я очень коротко повторю, вкратце, быстро напомню, как выглядит
[24:11.280 --> 24:18.320]  простейшая программа на плюсах и как вообще она запускается. Я сейчас нахожусь в терминале
[24:18.320 --> 24:24.760]  линукса. Вам, наверное, всем сказали, что мы настоятельно рекомендуем установить что-то
[24:24.760 --> 24:30.800]  линуксподобное на свой комп. MacOS, в принципе, подойдет, потому что там все почти так же,
[24:30.800 --> 24:40.360]  с точки зрения терминала и, значит, команд в нем. Вот, если у вас винда, то, возможно, вам подойдет,
[24:40.360 --> 24:52.560]  там, значит, VSL, так называемая, да, значит, Windows Subsystem for Linux, вот, но не то, чтобы винда это
[24:52.560 --> 24:59.680]  что-то, за что мы будем вас наказывать, нет, конечно, если вам по какой-то причине очень нравится винда,
[24:59.680 --> 25:06.240]  можете продолжать и пользоваться, но просто, так сказать, дружеский совет состоит в том, что чем
[25:06.240 --> 25:11.920]  раньше вы привыкете к линуксу, тем лучше. Вот прямо сейчас, вот прямо вот в ближайший, не знаю, месяц,
[25:11.920 --> 25:17.600]  вы вообще не умрете от того, что у вас линукс, а не винда, а не линукс, и в ближайшие два месяца, но вам
[25:17.600 --> 25:22.400]  может будет зачет посложнее сдавать, потому что вам придется там, у вас на компе это не будет
[25:22.400 --> 25:27.000]  просто воспроизводиться, вам зачет в декабре будет сдавать очень неудобно под виндой, но тем
[25:27.000 --> 25:34.800]  не менее вы выживете и с виндой. Другой вопрос, что вам же лучше этим к линуксу начать привыкать
[25:34.800 --> 25:40.560]  раньше, и чем раньше вы к нему привыкнете, тем легче он потом будет и на втором курсе, когда
[25:40.560 --> 25:47.240]  линукс уже непосредственно будет нужен, на втором курсе месяц, он будет посвящен линуксу, и на работе,
[25:47.240 --> 25:50.800]  если вы придете на работу, вам, вероятно, тоже надо будет иметь пользу целиться. Короче, чем раньше
[25:50.800 --> 25:55.440]  начнете привыкать, вам же лучше, поэтому рекомендую начать привыкать уже сейчас, чтобы через полгода
[25:55.440 --> 26:00.200]  для вас было естественным все эти команды, и на втором курсе, тем более, чтобы вы свободно с командой
[26:00.200 --> 26:07.280]  с такой работой. Вот, ну, значит, я нахожусь вот в этой директории CEP 2023 внутри моей домашней
[26:07.280 --> 26:17.720]  директории, я могу посмотреть полный адрес этой директории командой ПВД, я могу перейти в другую
[26:17.720 --> 26:22.560]  директорию команды ЦД, я это все очень быстро проговариваю, потому что вам это на семинаре,
[26:22.560 --> 26:28.760]  скорее всего, рассказывали, правда? Вот, я могу использовать команду ЦД, change директория, для того,
[26:28.800 --> 26:35.600]  чтобы ходить по директориям, вот, например, могу перейти на директорию на уровень верх, вот так, вот,
[26:35.600 --> 26:43.160]  могу использовать команду ЦД минус, чтобы вернуться туда, где я был до этого, очень полезна команда,
[26:43.160 --> 26:53.240]  может быть, вам про нее не рассказали, рекомендую, очень удобно. Ну, назад, просто, туда, где вы были до этого.
[26:53.240 --> 27:04.280]  Две точки это директория над моей, это как бы кнопка вверх, а минус это назад, вот, это полезно.
[27:04.280 --> 27:09.440]  Извините, нам сказали, что ЦД минус один раз только работает. Это правда, только один раз работает,
[27:09.440 --> 27:15.640]  к сожалению. Несколько раз в подряд не получится, будете ходить между двумя последними. Вот, ну,
[27:15.640 --> 27:21.560]  если вам хочется ходить много раз назад вперед, то есть такие специальные команды ПушД и ПопД,
[27:21.560 --> 27:28.320]  можете погуглить про них, я сейчас не буду про них рассказывать, в общем, если интересно, погуглить.
[27:28.320 --> 27:36.800]  ЦД без параметров — это возвращение в домашнюю директорию. Вот, также есть команда, да, ну,
[27:36.800 --> 27:44.400]  также есть, значит, абсолютная адреса, slash в линуксе обозначает корень всей файловой системы,
[27:44.400 --> 27:50.400]  вот, я могу перейти в него. У меня есть команда ls от слова list, которая мне показывает список,
[27:50.400 --> 27:56.560]  что есть текущая директория, где я сейчас нахожусь, вот, причем у меня синим цветом изображены папки,
[27:56.560 --> 28:03.160]  ну, или другие директории. Голубым цветом у меня изображены ссылки, ну, файлы, которые являются
[28:03.160 --> 28:11.440]  ерунками в терминах Windows, в терминах Linux, это ссылки на другие файлы. Вот, я могу также написать ls
[28:11.440 --> 28:18.720]  minus l, чтобы отобразить информацию подробно о файлах, в которых текущая директория содержится. Вот,
[28:18.720 --> 28:25.880]  здесь перечислены права доступа к файлу, кто является владельцем файла, размер файла и дата
[28:25.880 --> 28:37.800]  последнего изменения. Вот, значит, ls — это чтобы отображать, какие файлы у меня есть, ну и, да и все,
[28:37.800 --> 28:42.920]  наверное, что мне сейчас больше ничего особо не потребуется. Значит, вот, я возвращаюсь в папочку
[28:42.920 --> 28:51.520]  cd2023. Вот, я хочу сейчас написать, скомпилировать и запустить простейшую программу на плюсах. На самом
[28:51.520 --> 28:57.720]  деле, она у меня уже написана, вот, я ее подготовил, программы, да, я буду называть согласно,
[28:57.720 --> 29:03.840]  нумеровать согласно пунктам нашего изложения, вот, один, знак подчеркнение 1, это значит программа,
[29:03.840 --> 29:09.480]  которая будет соответствовать первому параграмму первой главы. Вот, чтобы написать простейшую программу,
[29:09.480 --> 29:18.640]  мне пригодится... ладно, нет, про текстовый редактор я позже расскажу. На самом деле у меня
[29:18.640 --> 29:24.240]  программа уже написана, я вот ее заранее заготовил, вот такая простейшая программа. Я вывел просто
[29:24.240 --> 29:30.600]  содержимое этого файла с помощью команды cat. Про нее вам тоже рассказывали, да, в линуксе cat — это значит
[29:30.600 --> 29:38.440]  вывести содержимое некро, значит, кошечку позвать надо. Вообще, в линуксе названия команд порой очень
[29:38.440 --> 29:47.080]  забавные, я даже не знаю, там, в общем, иногда они бывают очень смешные и делают совсем не то,
[29:47.080 --> 29:56.680]  что вы ожидаете, исходя из названия, вот, например, там, не знаю, команда kill забавная,
[29:56.680 --> 30:02.760]  послать сигнал в процесс. Ну вот, знаете, такие названия, они исторически сложились, но они порой
[30:02.760 --> 30:12.360]  очень странные. Ну вот, что делает эта программа? Ну, как вы, наверное, понимаете, эта программа, она
[30:12.360 --> 30:23.520]  вводит в клавиатуру число и выводит его же увеличенное на пять. Вот, здесь у нас первой
[30:23.520 --> 30:29.080]  строчкой написано include eostream, это так называемая директива при процессора, которая говорит о том,
[30:29.080 --> 30:37.520]  что мы хотим подключить заголовочный файл eostream к нашей программе, то есть мы хотим
[30:37.520 --> 30:41.680]  воспользоваться той частью стандартной библиотеки, которая содержит средство стандартного
[30:41.680 --> 30:47.960]  ввода-вывода, ну, input-output-stream, мы хотим как бы подключить потоки ввода-вывода, чтобы можно было
[30:47.960 --> 30:53.560]  пользоваться вводом-выводом к консолям нашей программы. Если бы я не написал include eostream, то вот
[30:53.560 --> 31:00.800]  это вот бы у меня не работало. std-in и std-out были бы не определены, потому что они как раз определены вот
[31:00.800 --> 31:09.480]  здесь. У вас, конечно, может возникнуть вопрос, а что конкретно означает вот это include eostream,
[31:09.480 --> 31:15.480]  а что именно написано в этом файле include eostream. Мы сейчас не будем в этом углубляться, сейчас наша цель
[31:15.480 --> 31:19.640]  это быстро научиться писать программы и там познакомиться с базовыми возможностями языка,
[31:19.640 --> 31:27.480]  поэтому что конкретно делает include и что именно написано в файле eostream, мы пока опустим это,
[31:27.480 --> 31:33.360]  будем воспринимать как некоторые заклинания, которые необходимы, чтобы работали потоки ввода-вывода.
[31:33.360 --> 31:42.560]  Дальше у нас есть функция main, которая традиционно имеет возвращаемый тип int, ничего не принимает,
[31:42.560 --> 31:50.160]  и вот внутри этой функции мы, собственно, и пишем код, который хотим, чтобы исполнялся. Main это
[31:50.160 --> 31:58.760]  такое вот название, которое обязано быть в каждой программе у функции, если вы хотите, чтобы с нее
[31:58.760 --> 32:06.120]  программа начиналась. Main это захардкоженное название, которое требуется от функции,
[32:06.120 --> 32:13.160]  чтобы она была точкой входа в программу. Main, в принципе, при некоторых условиях, иногда возвращать
[32:13.160 --> 32:18.080]  имя int, кажется, и она может тогда что-то принимать, но мы сейчас опять не будем про это говорить, это все
[32:18.080 --> 32:22.680]  тонкости, в которые углубляться мы когда-нибудь потом начнем, а пока что мы это опять воспринимаем как
[32:22.680 --> 32:27.120]  заклинание, если вы не понимаете, что такое int, main, вот это все, ну просто воспринимаем как заклинание,
[32:27.120 --> 32:33.000]  надо это писать и все. А, собственно, код, который будет выполняться, уже мы начинаем писать внутри
[32:33.000 --> 32:41.800]  Main. Ну, собственно, что здесь написано, мы объявили переменную X, ввели ее с консоли с помощью CIN,
[32:41.800 --> 32:48.800]  вот CIN это такой как бы поток стандартного ввода, с помощью вот такой операции из него, как бы,
[32:48.800 --> 32:56.920]  можно вводить переменные, а CAU это поток вывода, на который можно что-то выводить. Теперь я хочу
[32:56.920 --> 33:05.320]  программу скомпилировать, и чтобы ее скомпилировать, мне нужно воспользоваться компилятором. Да,
[33:05.320 --> 33:12.760]  компилятор, которым я обычно буду пользоваться, TG++, есть и другие компиляторы, например,
[33:12.760 --> 33:22.440]  C-Lang, а еще MSWC, это, пожалуй, три основных компилятора, которые есть для языка C++ на данный момент,
[33:22.440 --> 33:31.560]  вот, мы в основном будем пользоваться G++ и C-Lang, у них, кстати, открытый исходный код,
[33:31.560 --> 33:38.280]  вы можете прямо найти в интернете код компиляторов, и код стандарта библиотеки
[33:38.280 --> 33:42.240]  тоже можете найти, как реализован, вот, но мы сейчас опять будем просто пользоваться
[33:42.240 --> 33:50.720]  черным ящиком, я пишу G++ и название своей программы, и она успешно компилируется,
[33:50.720 --> 33:58.000]  вот, ничего не выявилось, это значит, что не произошло никаких ошибок, ну и хорошо. Я могу
[33:58.000 --> 34:04.080]  снова посмотреть, что у меня есть в директории, и увидю, что появился файл a.out, ну вот, по некоторому
[34:04.080 --> 34:09.800]  соглашению, опять, я воздержусь в комментариях, почему так, но вот почему-то, если вы компилируете
[34:09.800 --> 34:16.640]  свой файл, то по умолчанию, результат компиляции приобретает имя a.out, в принципе, я могу явно
[34:16.640 --> 34:23.040]  попросить, чтобы было имя другим, например, я могу попросить b.out, ну я вообще могу как угодно
[34:23.040 --> 34:29.720]  назвать, не знаю, вот так, для этого я должен написать "-o", от слова output, и какое-то имя,
[34:29.720 --> 34:38.560]  и теперь у меня скомпилируется эта программа, файл, который будет называться вот так, но мне
[34:38.560 --> 34:43.280]  это будет точно никогда не нужно, я буду просто, у меня стандартное имя, короче, будет устраивать,
[34:43.280 --> 34:49.920]  вот, я удалил выезжний файл, команда rm удаляет файл, remove, вот, отлично, теперь у меня есть этот
[34:49.920 --> 34:55.880]  файл, и его я могу запустить уже, это уже исполняемая программа, вот, c++, в отличие от питона, это
[34:55.880 --> 35:01.480]  компилируемый язык, как вы, наверное, знаете, языки программирования бывают компилируемые и
[35:01.480 --> 35:08.440]  интерпретируемые, что такое компилируемый язык, это язык, что такое, чтобы запустить программу,
[35:08.440 --> 35:14.240]  написанную на этом языке, нужно сначала взять целиком исходный код этой программы, и проделать над
[35:14.240 --> 35:20.160]  ним некоторую операцию компиляции, которая превращает исходный код в исполняемый файл, и вот уже
[35:20.160 --> 35:26.280]  исполняемый файл можно запускать, этим c++ отличается от интерпретируемых языков, например питона, где,
[35:26.280 --> 35:31.640]  если у вас есть файл с расширением файла, вы можете его исполнять построчно, вам не нужно превращать
[35:31.640 --> 35:37.720]  файл с кодом на питоне в какой-то специальный файл, в динарном, ну, с какой-то другим кодом, чтобы
[35:37.720 --> 35:41.920]  его исполнять, нет, вы можете исполнять просто файл на питоне, как он есть, как он написан строчкой за
[35:41.920 --> 35:49.640]  строчкой, файл на плюсах, вы так исполнять не можете, ну, если только вы не занимаетесь дебатом,
[35:49.640 --> 35:55.400]  отладкой специально, специальные утилиты, которые позволяют построчно выполнять, но стандартно вы
[35:55.400 --> 36:03.800]  должны собрать из c++ кода исполняемый файл, и вот его уже исполнять, я могу написать cat a.out и
[36:03.800 --> 36:15.560]  увидеть кучу какой-то белеберды, вот, да, a.out так исполняемый файл, вот, если я попрошу вывести
[36:15.560 --> 36:21.360]  содержимое файла a.out на экран, то я увижу, что там куча какой-то белеберды непонятны, это потому,
[36:21.360 --> 36:27.800]  что это файл с бинарным кодом, то есть это уже не человекочитаемый код, это бинарный код,
[36:27.800 --> 36:33.280]  который понязан процессору, но тут какие-то значки, какие-то символы, на самом деле там просто какие-то
[36:33.280 --> 36:40.000]  вот непонятные рандомные символы, но в бинарном представлении это инструкции, понятные процессором
[36:40.000 --> 36:45.080]  для исполнения, понятные центральным процессором, чтобы он исполнял свой саммерный инструкции,
[36:45.080 --> 36:50.360]  тут есть какая-то дополнительная техническая информация, какие-то там слова, но вообще это
[36:50.360 --> 36:57.320]  как бы бинарный код, поэтому неудивительно, что файл a.out не читает, в отличие от файла 1.cpp,
[36:57.320 --> 37:05.320]  вот, ну чтобы его запустить, мне нужно писать .slash a.out, вам наверное рассказывали, почему я должен
[37:05.320 --> 37:14.880]  писать .slash a.out, рассказывали, чтобы запустить какую-то программу, я обычно просто пишу ее название,
[37:14.880 --> 37:23.800]  если я так напишу, мне скажут command not found, почему, потому что по умолчанию программы для
[37:23.800 --> 37:30.000]  исполнения ищутся в стандартных директориях, где хранятся исполняемые программы, а не в моей
[37:30.000 --> 37:40.440]  текущей директории, конкретно вот есть такая системная переменная path, в которой перечислены
[37:40.440 --> 37:46.720]  директории, в которых ищутся программы для исполнения по умолчанию, значит, я сейчас написал,
[37:46.720 --> 37:52.520]  ну опять-таки вам, я надеюсь на семинаре про это рассказали, но если не рассказали, вам расскажут,
[37:52.520 --> 37:57.560]  попросите семинариста, чтобы он пояснил поподробнее, есть системная переменная,
[37:57.560 --> 38:01.760]  так называемая path, которая вот содержит список адресов и директорий, в которых ищутся программы
[38:01.760 --> 38:06.920]  для исполнения по умолчанию, команда echo, это команда, которая позволяет вывести на экран
[38:06.920 --> 38:12.640]  значение переменной, либо какое-то сообщение, например, я могу сказать hello, выведите просто hello,
[38:12.640 --> 38:19.680]  а если я пишу dollar, то он как бы пытается взять система, прям операционно-системистская переменная path
[38:19.680 --> 38:28.600]  и в ней хранится вот это, и вот если бы моя программа a.out лежала где-то в одной
[38:28.600 --> 38:34.400]  директории, тут они двоеточем разделены, то я бы мог ее запустить без указаний откуда,
[38:34.400 --> 38:38.840]  но поскольку она лежит в моей текущей директории, мне нужно явно указать сколько
[38:38.840 --> 38:45.680]  директорий я выпускаю, и точка обозначает текущую директорию, вот две точки обозначает директория
[38:45.680 --> 38:51.800]  над моей, на уровне вверх, а одна точка обозначает текущую директорию, поэтому чтобы мне указать,
[38:51.800 --> 39:01.480]  из какой директории я выпускаю, я пишу точка slash a.out, ну вот и запутился, ввожу 5, вводится 10,
[39:01.480 --> 39:13.920]  ввожу 3, выводится 8, прекрасно. Можно просто еще? Да. Path, это что такое? Path это системная
[39:13.920 --> 39:19.560]  переменная, ну вот в операционной системе, как и в программах, есть некоторые переменные, вот,
[39:19.560 --> 39:24.400]  и в этой переменной содержится строка текстов, в которых перечислены адреса директории,
[39:24.400 --> 39:30.840]  разделенные двоеточем, и эти адреса обозначают директории, в которых ищутся исполняемые файлы
[39:30.840 --> 39:38.200]  по умолчанию. Ну, например, я могу вот написать ls, вот тут у меня есть usr local bin, вот я могу
[39:38.200 --> 39:45.320]  написать, например, ls usr local bin, чтобы посмотреть все, что лежит в этой директории, там почти ничего
[39:45.320 --> 39:50.560]  не лежит, ага, только мои вкаджеры чек не лежат, ну хорошо, давайте я какую-нибудь другую директорию
[39:50.560 --> 39:56.960]  попрошу, ну просто usr bin, например, там лежит куча исполняемых файлов, то есть это как бы директория,
[39:56.960 --> 40:03.400]  в которой лежат исполняемые файлы по умолчанию, вот, программы ищутся в ней, если вы по умолчанию
[40:03.400 --> 40:12.400]  запускаете, если бы я вот этот файл a.out положил в одну из этих директорий, то я бы мог писать
[40:12.400 --> 40:21.520]  просто a.out, он был запущен, нашелся, мне бы не приходилось директории явно управлять. Ну, кажется,
[40:21.520 --> 40:28.160]  в принципе, это все, что я даже хотел рассказать про компиляцию запуск простейшей программы на
[40:28.160 --> 40:36.960]  плюсах, ну, наверное, пожалуй, пара вещей, которые я добавлю, это некоторые параметры компиляции
[40:36.960 --> 40:44.440]  полезные, да, во-первых, у компилятора какого языка программирования есть версии, вот, я могу
[40:44.440 --> 40:52.600]  написать g++-v, и тем самым я попрошу g++ сообщить мне некоторую информацию о себе, да, вообще,
[40:52.600 --> 41:00.120]  там, довольно часто бывает так, что параметр –v, ну, он либо означает version, либо означает
[41:00.120 --> 41:05.720]  the ghost, что означает многословный, если вы добавляете параметр –v в какой-нибудь
[41:05.720 --> 41:10.720]  команде, зачастую это заставляет ее вывести побольше текста, пояснить, что происходит,
[41:10.720 --> 41:21.040]  g++-v сообщить информацию о g++, о моем текущем, вот, и здесь много чего написано, вот, тут написано,
[41:21.040 --> 41:27.240]  как он сконфигурирован, значит, под какую платформу, там, еще что-то, вот, что интересно,
[41:27.240 --> 41:38.840]  gcc version 9.4.0, скобочка к убунту 9.4.0 под убунту 20.04, вот здесь написано, какая версия компилятора 9.4.0,
[41:38.840 --> 41:44.680]  это довольно старая версия, а современная версия уже, по-моему, 12-ая последняя, или 12-ая,
[41:44.680 --> 41:52.040]  я не помню, может, 14-ая, вот, но не надо путать версию g++ с версией языка, это разная совершенно
[41:52.040 --> 41:59.920]  вещь, вы можете думать, что версия g++ 20-ая, значит, вам g++ 20-ой нужен, нет, неправда, вот,
[41:59.920 --> 42:09.720]  у меня есть еще g++ 11-ый, и он, ну, у меня просто установлено разные, g++ здесь, вот, есть 9-ый, есть 11-ый,
[42:09.720 --> 42:17.720]  вот, g++ 11-ый спокойно справляется компилировать gcc g++ 20-ый, вот, g++ 9-ый в меньшей степени поддерживает,
[42:17.720 --> 42:25.440]  gcc 20-ый, если вообще поддерживает, ну, короче, просто имейте в виду, что версия компилятора это не версия
[42:25.440 --> 42:33.000]  языка, они разные, и вы можете открыть сайт gcc.gnu.org, и там будет написано про каждую версию gcc, g++,
[42:33.000 --> 42:39.880]  что он уже поддерживает из стандартов c++ каких, ну, вот, g++ 11-ого нам для почти всех нужд хватит,
[42:39.880 --> 42:50.640]  c++ 20-ого он почти полностью поддерживает, 11-ая версия g++ нам достаточно почти для всех целей, вот,
[42:50.640 --> 42:55.640]  так что можете пользоваться нейтам, если вдруг будет чего-то не хватать, мы там отдельно.
[42:55.640 --> 43:12.720]  У нас в контесте, по-моему, будет 14-я версия силенга стоять, так что ориентируйтесь на это, вот, ну, в контесте,
[43:12.840 --> 43:26.560]  нам задачу давать надо будет, версия силенга, наверное, 14-ая, но опять-таки имейте в виду, что это никак не связано с версией языка,
[43:26.560 --> 43:32.760]  14-ая версия силенга это не значит, что 14-ая версия плюсов, там 20-ая, помните, версия плюсов, но версия просто
[43:32.760 --> 43:40.080]  имена компилятора 14-ая, еще версии у стандартной библиотеки разные бывают, и они тоже там номерация
[43:40.080 --> 43:50.880]  отличается, в общем, запутаться есть много возможностей, вот, я могу g++ явно указать, в какой версии c++ я хочу компилировать,
[43:50.880 --> 44:01.200]  вот, по умолчанию, кажется, он у меня сейчас компилирует версии, я даже не знаю в какой, ну,
[44:01.200 --> 44:11.960]  неважно, вот, я уверен, что в, что меньше, чем 20-ый, вот g++ 9-ый, g++ 9-ый по умолчанию компилирует, скорее всего,
[44:11.960 --> 44:21.120]  либо в 14-ой, либо в 17-ой версии, g++ 11-ый, наверное, по умолчанию компилирует в 17-ой версии, я могу явно попросить его компилировать в другой версии языка,
[44:21.120 --> 44:31.920]  для этого мне нужен параметр, минус std равно c++ и какая версия, например, 20-ый, вот, я могу явно попросить
[44:31.920 --> 44:40.680]  компилировать мою программу в версии языка c++ 20-ый, вот, а вас, кстати, учили пользоваться vim'ом,
[44:40.680 --> 44:47.640]  прекрасно, да, ну, сейчас мне потребуется открыть vim, чтобы отредактировать файл,
[44:47.640 --> 44:56.880]  да, значит, ну, я сейчас чуть-чуть хочу поменять свою программу, чтобы проиллюстрировать разницу
[44:56.880 --> 45:03.960]  версий языка, вот, чтобы редактировать файлы из консоли, ну, я, конечно, могу, в Ubuntu есть там
[45:03.960 --> 45:10.680]  текстовый редактор графическим, графическим интерфейсом, я, в принципе, могу и си-лайн какой-нибудь
[45:10.680 --> 45:18.120]  установить сюда и в нем писать, но я, в основном, буду все делать из консоли, но мне так нравится,
[45:18.120 --> 45:23.240]  заодно вас буду мотивировать забота с консоль, потому что, когда вы пробуете из консоли, вы
[45:23.240 --> 45:31.360]  выглядите крутым, вот, на самом деле, уметь пробовать из консоли полезно, уметь редактировать файлы из
[45:31.360 --> 45:38.680]  консоли тоже полезно, потому что, когда вы, например, ну, опять-таки, вы приходите на работу, я не знаю там,
[45:38.680 --> 45:44.400]  я привожу примеры из Яндекса, потому что я дольше всего работал в Яндексе, но если вы придете в какое-нибудь
[45:44.400 --> 45:49.480]  другое место и вам нужно зайти на какой-нибудь удаленный сервер и на нем что-нибудь отредактировать,
[45:49.480 --> 45:54.800]  то у вас, конечно же, нет графической оболочки, вы просто заходите на удаленный сервер через консоль,
[45:54.800 --> 46:00.000]  и вот у вас консоль, вы находитесь на удаленном сервере, не знаю, на серваке какого-нибудь Яндекса,
[46:00.000 --> 46:05.680]  ВК, не знаю, какого-нибудь банка, и вам нужно там что-то сделать, как вы будете это делать, вам нужно
[46:05.680 --> 46:12.120]  уметь из консоли что-то, ну, файлы редактировать, и поэтому вам полезно уметь пользоваться текстом
[46:12.120 --> 46:18.080]  редактором из консоли. Ну вот, пожалуй, самый крутой текстовый редактор, который существует в консоли,
[46:18.080 --> 46:27.360]  это ВИМ, его крутость вы пока в скорейшем состоянии оценить, но, если что, ВИМ, так же, как и язык C++,
[46:27.360 --> 46:35.200]  можно изучать целый год и до сих пор не знаю, и все еще не знать всех его возможностей. В интернете есть
[46:35.200 --> 46:50.560]  целый обучающий курс по ВИМу, можно там семестровый курс по ВИМу почитать. В чем именно крутость ВИМа как текстовый редактор,
[46:50.560 --> 46:56.160]  или почему мы из консоли хотим научиться пользоваться? Потому что, вот еще раз, вот я
[46:56.160 --> 47:04.040]  работаю на работе, у меня есть, не знаю, вот сервера Яндекса, они стоят там в дапп-центре, где-нибудь там,
[47:04.040 --> 47:12.360]  вот, не знаю, во Владимирской области, и вы должны зайти на этот сервер, на удаленный, и на нем что-то
[47:12.360 --> 47:20.600]  сделать. Например, у вас там крутится бэкэнд, не знаю, Яндекс.Такси, и вот вы обнаружили, что там байки какие-то,
[47:20.600 --> 47:26.400]  Яндекс.Такси сломалась, залогала, или там, я не знаю, Яндекс.Музыка. Вот вы зашли на сервер, где работает
[47:26.400 --> 47:32.080]  непосредственно программа, которая отвечает пользовательные запросы, и поняли, что что-то не так работает,
[47:32.080 --> 47:39.240]  и вам нужно из консоли суметь это починить. А как вы это будете делать? Вы же удаленно зашли, у вас же
[47:39.240 --> 47:44.880]  нет графического интерфейса, и вам нужно текстовые файлы какие-то отредактировать, например, и что вы будете делать?
[47:44.880 --> 47:56.440]  Да, 2 гигабайтные текстовые файлы с логами всего того, что происходило на сервере за день. Вам, конечно,
[47:56.440 --> 48:01.640]  удобнее будет перекинуть себя на комп, отредактировать у себя, потом закинуться обратно. Нет, лучше
[48:01.640 --> 48:06.400]  редактировать прямо там. Вот, короче, из консоли полезно увидеть пользователь с текстовым редактором.
[48:06.400 --> 48:16.000]  Чем крут ВИМ? ВИМ, по сути, это тоже среда программирования. Короче, профи по ВИМу, они умеют
[48:16.000 --> 48:21.160]  прямо в ВИМе писать скрипты, которые текст редактировать, вы можете прямо в ВИМе, там, я не знаю,
[48:21.160 --> 48:27.800]  написать скрипт, который бы ваш текст обработал каким-то очень сложным образом, там какой-нибудь
[48:27.800 --> 48:33.360]  алгоритм обработки вашего текста бы сделал прямо внутри текстового редактора. Вот, мало
[48:33.360 --> 48:37.360]  какие текстовые редакторы умеют так много, как ВИМ в плане обработки текста, но главное,
[48:37.360 --> 48:43.180]  этим надо уметь пользоваться. Ну, по ходу дела вы увидите, что умеет ВИМ, я думаю, по мере
[48:43.180 --> 48:50.280]  того, как мы им пользуемся. Вот, я открыл, значит, твой файл. Самое главное знание про ВИМ какое?
[48:50.280 --> 48:55.440]  Как выйти из ВИМа. Как выйти из ВИМа, да, потому что есть анекдот, мой знакомый пользовался ВИМом
[48:55.440 --> 49:03.160]  20 лет, потому что не знает, перед ним выйти. Как выйти из ВИМа? Двоеточие Q, воскресательный знак Enter.
[49:03.160 --> 49:12.640]  Да, но это выход без сохранения изменений. Чтобы выйти с сохранением изменений, двоеточие WQ Enter.
[49:12.640 --> 49:22.000]  Если вы ничего не меняли, то можно просто написать двоеточие Q Enter, и вы выйдете. Двоеточие что? X.
[49:22.000 --> 49:33.440]  Я такого не знаю. Двоеточие WQ Enter. Двоеточие WQ, да. Прикольно, ну вот вживи, как учись. Нет, я сразу говорю,
[49:33.440 --> 49:42.640]  что я ВИМ плохо знаю. Как и плюсы. Да. Каждый год узнаешь что-то новое. Чего?
[49:42.640 --> 49:49.960]  Еще раз сохранение. Да, WQ. Ну вам это на семинарах расскажут, это сейчас не тема лекции, это вы там на семинарах разберетесь.
[49:49.960 --> 49:57.160]  Так, окей. Значит, чтобы начать твой текст, нажимаю клавишу I, и теперь могу редактировать текст.
[49:57.160 --> 50:06.480]  Можно еще вопрос? Да. А пишет ВИМ не найден, его надо написать вии? Да, сюда отсюда. Да, ты можешь написать вии,
[50:06.480 --> 50:21.040]  а если у тебя не найден ВИМ, у тебя челкунта или что? Я просто не знаю. Ну если у тебя он не установлен, то надо установить. Судо, аптенстал, там. ВИМ. Чего? Манжара.
[50:21.040 --> 50:34.800]  У него манжара. Это что? Это дистрибутник. Я не знаю. Ну короче, теперь надо тебе его установить. Но скорее всего у тебя должен быть ВИМ, а не ВИМ.
[50:34.800 --> 50:46.840]  В общем, это неважно. Сейчас это не тема пары, тема рассказать о основном программе на плюсах, поэтому ВИМ это такое. Про ВИМ вы на семинарах поговорите.
[50:46.840 --> 51:00.400]  Вот, ну давайте я что-нибудь такое напишу, но я не знаю там. Ну вот, например, вот есть такой задаловочный файл с ВИМ,
[51:00.400 --> 51:13.200]  на первом мне пришедшего в голову, который только 720 появился. И вот я, значит, давайте попробую скомпилировать свой файл сейчас.
[51:13.200 --> 51:24.080]  И вдруг обнаруживается, что нет такого. Почему? Ну потому что версия языка не та. Я даже с G plus 11 скорее всего не смогу это скомпилировать. А нет, смог.
[51:24.080 --> 51:35.520]  Ну вот если я G plus плюсу явно скажу, скорее всего это не сработает, потому что G plus plus 9 еще не умеется, G plus plus 20. Да, к сожалению.
[51:35.520 --> 51:44.800]  Ну я могу какую-нибудь другую, наверное, использовать штуку. Ну вот, например, есть такой еще замечательный задаловочный файл VARIA.
[51:44.800 --> 51:55.120]  Вот он с G plus 17 появился. Неважно абсолютно, что это. Я просто вам показываю пример того, как вот я сейчас компилирую, а блин, задаловочный файл у меня не работает.
[51:55.120 --> 52:06.240]  Ну, что-то пример мне не дается раз за разом. Что-то что-то не так. Ну он не должен был скомпилироваться. Ну да, да. Ну...
[52:06.240 --> 52:15.360]  Ну поставьте версию там с G plus плюс 9. Ну хорошо, давайте я напишу минус с T D равно с G plus. Ну просто загаловочный файл это есть, в самом-то и дело.
[52:15.360 --> 52:22.480]  Ну вот если я напишу так, то все равно работает, потому что загаловочный файл есть. Ну давайте я попробую этот VARIA здесь создать.
[52:22.960 --> 52:46.960]  Ой, господи, что я пишу из GUT-а? Вот я пишу STD VARIAN от INV. Ну и если я сейчас скомпилирую, то вот это он уже не сможет сделать, потому что загаловочный файл хоть и есть у меня в файловой системе, но сам VARIAN это не член STD, если я компилирую без версии C plus 17.
[52:46.960 --> 53:00.000]  Вот видите, написано STD VARIAN, Available from C plus 17 onwards. Ну если я попрошу минус с T D равно с C plus 17, то все работает. То есть я могу явно указать вещь в языках, которые я компилирую.
[53:07.520 --> 53:13.040]  Наверное, это все, что я расскажу сейчас про компилятор и компиляцию.
[53:13.120 --> 53:33.120]  Витя, может, вопрос? А чтобы запускать с командой STD, типа вот мы отредактировали его и нажали GEPTPS 1.1.1.1.cpp. Это значит, ну когда мы сделали GEPTPS 1.1.1.cpp, это типа мы сделали так, чтобы все изменения произошли, или что?
[53:33.200 --> 53:40.480]  GEPTPS 1.1.1.cpp, это значит, я взял вот этот файл 1.1.1.cpp и превратил его в исполняемый файл.
[53:40.480 --> 53:44.960]  Да, и после этого уже можно что угодно вводить и он будет выводить?
[53:44.960 --> 53:49.120]  После этого я могу запускать в исполняемый файл, и будет омоценная программа.
[53:49.120 --> 53:54.880]  А, сейчас, то есть, типа, написать название исполняемого файла, потом входные данные?
[53:55.640 --> 54:05.760]  Ну, не обязательно входные данные, у тебя может и не быть входных данных, просто когда я запускаю a.out, запускается вот эта программа, да, которая вводит X, а потом выводит XQS 5.
[54:05.760 --> 54:09.760]  Ну, еще-то какой-то variant создается, но это неважно, что он не выводит.
[54:09.760 --> 54:11.760]  А, то есть, это просто сама программа.
[54:11.760 --> 54:13.760]  a.out, запуск самой программы, которую я написал.
[54:13.760 --> 54:15.760]  Конечно, я же про это говорил.
[54:15.760 --> 54:21.760]  Так, окей, на этом закончилось знакомство с компиляторами первой программы.
[54:22.640 --> 54:30.640]  Так, следующий пункт нашей программы это основные типы и операции над ними.
[54:30.640 --> 54:38.640]  Вообще, зря я закрыл зум, потому что белая доска-то мне сейчас все-таки нужна, потому что я начал ее рисовать.
[54:38.640 --> 54:46.640]  Сейчас я буду снова рисовать, и это будет параграф 1.2.
[54:46.640 --> 54:48.640]  Ой-ой-ой-ой-ой.
[54:52.640 --> 55:10.640]  Значит, параграф 1.2, ну, скажем так, базовые типы и поддерживаемая операция.
[55:11.520 --> 55:29.520]  Я пишу по-английски, по привычке, потому что, ну, вся информация, которую вы будете гуглить, скорее всего, будет на английском, и чтобы привыкать к терминологии, мне кажется, полезнее на английском.
[55:30.400 --> 55:40.400]  Итак, как вы, наверное, знаете, а может, вы не знаете, C++ это язык с статической типизацией.
[55:40.400 --> 55:46.400]  Что такое статическая типизация? Ну, какая еще бывает типизация?
[55:46.400 --> 55:48.400]  Динамическая.
[55:48.400 --> 55:50.400]  Да, еще была динамическая типизация.
[55:50.400 --> 55:54.400]  Еще вообще бывает, что нет типизации, но это вообще приемлемо.
[55:55.280 --> 55:59.280]  Значит, пример языка с динамической типизацией, это, например, что?
[55:59.280 --> 56:01.280]  Питон.
[56:01.280 --> 56:03.280]  Да, опять питон. Вот.
[56:03.280 --> 56:05.280]  Ну, что такое динамическая типизация?
[56:05.280 --> 56:09.280]  Это когда типы переменных меняются по ходу выполнения программы.
[56:09.280 --> 56:15.280]  Вот в питоне вы написали x равно 5, а потом внезапно взяли и написали x равно abcde.
[56:15.280 --> 56:17.280]  То есть x был int целым числом, стал строкой.
[56:17.280 --> 56:19.280]  Нормально, бывает.
[56:19.280 --> 56:21.280]  Потом x опять стал чем-то другим.
[56:22.160 --> 56:26.160]  То есть прям по ходу выполнения программы тип переменной меняется.
[56:26.160 --> 56:28.160]  Это называется динамическая типизация.
[56:28.160 --> 56:30.160]  Типы определяются в рантайме.
[56:30.160 --> 56:32.160]  В рантайме, то есть во время выполнения.
[56:32.160 --> 56:38.160]  Вопреки этому статическая типизация означает, что в момент компиляции программы,
[56:38.160 --> 56:42.160]  уже на момент, когда исполненный файл создан, типы всех переменных известны,
[56:42.160 --> 56:46.160]  и в ходе выполнения программы они не могут меняться.
[56:46.160 --> 56:48.160]  Вот.
[56:49.040 --> 56:53.040]  Это одно из важных знаний про язык C++,
[56:53.040 --> 56:59.040]  которое может, скажем так, в трудные, темные времена
[56:59.040 --> 57:05.040]  спасти вас от заблуждения, от неверного пути.
[57:05.040 --> 57:09.040]  Запомните раз и навсегда, что типы переменных C++
[57:09.040 --> 57:13.040]  никогда, ни при каких обстоятельствах в ходе выполнения программы не меняются.
[57:13.040 --> 57:17.040]  Конечно, вы можете создать другую переменную,
[57:17.920 --> 57:19.920]  которая называется так же, при некоторых обстоятельствах,
[57:19.920 --> 57:21.920]  и это будут две разных переменных с именем X.
[57:21.920 --> 57:23.920]  Одна будет им, другая будет строкой.
[57:23.920 --> 57:25.920]  Но это все еще означает, что если какая-то
[57:25.920 --> 57:27.920]  переменная начальна была интом,
[57:27.920 --> 57:29.920]  она не может стать строкой по ходу выполнения программы.
[57:29.920 --> 57:33.920]  Во втором семестре у вас может возникнуть обманчивое ощущение,
[57:33.920 --> 57:35.920]  что это все-таки не так,
[57:35.920 --> 57:37.920]  а что типы переменных удалось поменять в рантайме.
[57:37.920 --> 57:39.920]  Нет, это обман были.
[57:39.920 --> 57:43.920]  Значит, несмотря на то, что я вас буду пытаться обмануть в какой-то момент,
[57:43.920 --> 57:45.920]  не верьте,
[57:46.800 --> 57:48.800]  типы переменных не могут меняться в ходе выполнения программы.
[57:48.800 --> 57:52.800]  В какой-то момент это нам пригодится.
[57:52.800 --> 57:54.800]  Так вот, статическая типизация.
[57:54.800 --> 57:56.800]  Типы переменных раз мы всегда обманулины
[57:56.800 --> 57:58.800]  в момент, когда программа
[57:58.800 --> 58:00.800]  перед запуском программы.
[58:00.800 --> 58:02.800]  Вообще, понятия статические и динамические,
[58:02.800 --> 58:04.800]  они будут очень часто в нашем курсе встречаться,
[58:04.800 --> 58:06.800]  несколько раз будут встречаться,
[58:06.800 --> 58:08.800]  этот первый раз.
[58:08.800 --> 58:10.800]  Статический означает такой,
[58:10.800 --> 58:12.800]  который на этапе компиляции происходит,
[58:12.800 --> 58:14.800]  или известный этап компиляции.
[58:15.680 --> 58:17.680]  А динамический, который в ходе выполнения происходит,
[58:17.680 --> 58:19.680]  или что-то с ним случается.
[58:21.680 --> 58:23.680]  Пока что у нас только типизация статическая и динамическая бывает,
[58:23.680 --> 58:25.680]  потом будет еще что-то, кое-что.
[58:25.680 --> 58:27.680]  Еще много чего.
[58:27.680 --> 58:29.680]  Ну хорошо, вот я научился объявлять
[58:29.680 --> 58:31.680]  переменные там.
[58:33.680 --> 58:35.680]  И типа INC,
[58:35.680 --> 58:37.680]  и, значит, вонить-вонить на экран.
[58:37.680 --> 58:39.680]  Давайте поговорим о том,
[58:39.680 --> 58:41.680]  о какие еще были типы.
[58:41.680 --> 58:43.680]  Ну, наверное,
[58:44.560 --> 58:46.560]  первая, это
[58:46.560 --> 58:48.560]  целочисленные типы.
[58:54.560 --> 58:56.560]  Integral types.
[58:56.560 --> 58:58.560]  Целочисленные типы,
[58:58.560 --> 59:00.560]  это типы, которые позволяют хранить целые числа.
[59:00.560 --> 59:02.560]  Самый распространенный тип,
[59:02.560 --> 59:04.560]  самый базовый, я бы сказал,
[59:04.560 --> 59:06.560]  который мы будем всегда пользоваться,
[59:06.560 --> 59:08.560]  и в большинстве примеров он встречается,
[59:08.560 --> 59:10.560]  это INT.
[59:10.560 --> 59:12.560]  Но кроме INT, еще какие есть целочисленные типы?
[59:13.440 --> 59:15.440]  Еще есть LONG,
[59:15.440 --> 59:17.440]  еще есть LONG-LONG.
[59:21.440 --> 59:23.440]  Вот.
[59:23.440 --> 59:25.440]  Давайте сначала вот про эти поговорим.
[59:25.440 --> 59:27.440]  Чем они отличаются?
[59:27.440 --> 59:29.440]  Они отличаются диапазоном значений,
[59:29.440 --> 59:31.440]  которые в них можно хранить.
[59:31.440 --> 59:33.440]  INC, как правило, позволяет хранить
[59:33.440 --> 59:35.440]  два представной степени возможного значения.
[59:37.440 --> 59:39.440]  Это не документировано сандартом,
[59:39.440 --> 59:41.440]  сандартом документировано,
[59:41.440 --> 59:43.440]  потому что INC хранит как минимум
[59:43.440 --> 59:45.440]  два шестнадцатой степени значений.
[59:45.440 --> 59:47.440]  Но на практике почти везде, почти всегда,
[59:47.440 --> 59:49.440]  вот если вы будете запускать программу на плюсах,
[59:49.440 --> 59:51.440]  я уверен, что почти у всех из вас
[59:51.440 --> 59:53.440]  на компе будет выясняться,
[59:53.440 --> 59:55.440]  что INC размером 4 байта.
[59:55.440 --> 59:57.440]  То есть возможных значений в нем 2 в 32 степени.
[59:59.440 --> 01:00:01.440]  Вот INC это 4 байта.
[01:00:01.440 --> 01:00:03.440]  И в примерах, которые мы будем разбирать,
[01:00:03.440 --> 01:00:05.440]  я всегда буду считать,
[01:00:05.440 --> 01:00:07.440]  что INC это 4 байта.
[01:00:07.440 --> 01:00:09.440]  Хотя он может быть и другого размера,
[01:00:09.440 --> 01:00:11.440]  но, как правило, он 4 байта,
[01:00:11.440 --> 01:00:13.440]  я буду это считать в дальнейшем, что это там.
[01:00:13.440 --> 01:00:15.440]  Шорт это, опять-таки,
[01:00:15.440 --> 01:00:17.440]  как правило, 2 байта.
[01:00:17.440 --> 01:00:19.440]  Лонг-лонг, как правило,
[01:00:19.440 --> 01:00:21.440]  8 байтов.
[01:00:21.440 --> 01:00:23.440]  Типом лонг мы никогда не будем
[01:00:23.440 --> 01:00:25.440]  пользоваться, потому что он
[01:00:25.440 --> 01:00:27.440]  то ли 4 байта, то ли 8, непонятное.
[01:00:27.440 --> 01:00:29.440]  По-разному бывает, смотря,
[01:00:29.440 --> 01:00:31.440]  где вы работаете, на каком компе,
[01:00:31.440 --> 01:00:33.440]  на какой машине, с каким компилятором.
[01:00:33.440 --> 01:00:35.440]  Нам, для наших примеров,
[01:00:35.440 --> 01:00:37.440]  мы будем использовать обычно либо INC, либо
[01:00:37.440 --> 01:00:39.440]  INC. То есть INC, если нужно
[01:00:39.440 --> 01:00:41.440]  4-байтное число, лонг-лонг, если 8 байтов.
[01:00:41.440 --> 01:00:43.440]  Что значит 4 байта?
[01:00:43.440 --> 01:00:45.440]  Ну, то есть 32 бита, то есть 2 в 32 значений.
[01:00:45.440 --> 01:00:47.440]  Вот.
[01:00:47.440 --> 01:00:49.440]  2 в 32 это значит, что мы можем хранить числа
[01:00:49.440 --> 01:00:51.440]  от минус 2 в 31
[01:00:51.440 --> 01:00:53.440]  до
[01:00:53.440 --> 01:00:55.440]  2 в 31 минус 1,
[01:00:55.440 --> 01:00:57.440]  включительно.
[01:00:57.440 --> 01:00:59.440]  Да?
[01:00:59.440 --> 01:01:01.440]  Ну, 8 байт, соответственно, означает,
[01:01:01.440 --> 01:01:03.440]  что мы можем хранить числа от минус
[01:01:03.440 --> 01:01:05.440]  2 в 63 до 2 в 63 минус 1.
[01:01:05.440 --> 01:01:07.440]  Ой.
[01:01:09.440 --> 01:01:11.440]  Это что я сделал?
[01:01:15.440 --> 01:01:17.440]  Подождите, пожалуйста.
[01:01:19.440 --> 01:01:21.440]  До 2 в 63 минус 1.
[01:01:21.440 --> 01:01:23.440]  Я куда-то не туда нажал.
[01:01:23.440 --> 01:01:25.440]  А, я нажал ваус-шер
[01:01:25.440 --> 01:01:27.440]  вместо того, чтобы на руку нажать.
[01:01:27.440 --> 01:01:29.440]  Вот.
[01:01:29.440 --> 01:01:31.440]  2 в 31 минус 1 это
[01:01:31.440 --> 01:01:33.440]  сколько кто помнит?
[01:01:33.440 --> 01:01:35.440]  Вот это.
[01:01:35.440 --> 01:01:37.440]  Число чему равно?
[01:01:37.440 --> 01:01:39.440]  Два на десять девятнадцатый,
[01:01:39.440 --> 01:01:41.440]  примерно.
[01:01:41.440 --> 01:01:43.440]  Да нет, два в тридцать... Максин,
[01:01:43.440 --> 01:01:45.440]  максимальное значение имта в плюсах какое?
[01:01:45.440 --> 01:01:47.440]  А.
[01:01:47.440 --> 01:01:49.440]  Два миллиарда
[01:01:49.440 --> 01:01:51.440]  сто сорок семь миллионов
[01:01:51.440 --> 01:01:53.440]  четыреста восемьдесят три
[01:01:53.440 --> 01:01:55.440]  тысяча шестьсот сорок семь.
[01:01:55.440 --> 01:01:57.440]  Не то, чтобы я вас
[01:01:57.440 --> 01:01:59.440]  просил помнить это наизусть,
[01:01:59.440 --> 01:02:01.440]  но это полезно помнить,
[01:02:01.440 --> 01:02:03.440]  потому что
[01:02:03.440 --> 01:02:05.440]  полезно помнить хотя бы примерный порядок величины.
[01:02:05.440 --> 01:02:07.440]  Это два миллиарда с чем-то.
[01:02:07.440 --> 01:02:09.440]  Два миллиарда и сто сорок семь миллионов.
[01:02:09.440 --> 01:02:11.440]  Кстати, это простое число
[01:02:11.440 --> 01:02:13.440]  еще добавлено. Всему очень удобно.
[01:02:15.440 --> 01:02:17.440]  Полезный факт.
[01:02:17.440 --> 01:02:19.440]  Или бесполезный, не знаю.
[01:02:19.440 --> 01:02:21.440]  Вот. Почему полезно
[01:02:21.440 --> 01:02:23.440]  помнить, какое максимальное значение может
[01:02:23.440 --> 01:02:25.440]  хранить им? Да чтобы переполнение не происходило.
[01:02:25.440 --> 01:02:27.440]  Когда вы пишете программу, вы держите в уме,
[01:02:27.440 --> 01:02:29.440]  что им примерно два миллиарда
[01:02:29.440 --> 01:02:31.440]  сто миллионов может хранить, а если у вас
[01:02:31.440 --> 01:02:33.440]  число больше, то у вас переполнение будет.
[01:02:33.440 --> 01:02:35.440]  Вот.
[01:02:35.440 --> 01:02:37.440]  С переполнением
[01:02:37.440 --> 01:02:39.440]  Intouch четыребайтного связано много
[01:02:39.440 --> 01:02:41.440]  интересных историй, много
[01:02:41.440 --> 01:02:43.440]  в
[01:02:43.440 --> 01:02:45.440]  программировании, вообще в мире
[01:02:45.440 --> 01:02:47.440]  программирования есть немов,
[01:02:47.440 --> 01:02:49.440]  связанных с переполнением.
[01:02:49.440 --> 01:02:51.440]  Вот. Наверное, такая
[01:02:51.440 --> 01:02:53.440]  самая яркая вещь,
[01:02:53.440 --> 01:02:55.440]  самая яркая явление,
[01:02:55.440 --> 01:02:57.440]  о котором даже есть статья на Википедии,
[01:02:57.440 --> 01:02:59.440]  это так называемая проблема
[01:02:59.440 --> 01:03:01.440]  2038 года.
[01:03:01.440 --> 01:03:03.440]  Знаете,
[01:03:03.440 --> 01:03:05.440]  какая проблема 2038 года?
[01:03:05.440 --> 01:03:07.440]  Да.
[01:03:07.440 --> 01:03:09.440]  Это
[01:03:09.440 --> 01:03:11.440]  ситуация,
[01:03:11.440 --> 01:03:13.440]  19 варианта 2038 года
[01:03:13.440 --> 01:03:15.440]  наступит момент, когда
[01:03:15.440 --> 01:03:17.440]  юниксовое время
[01:03:17.440 --> 01:03:19.440]  переполнится. Дело в том, что
[01:03:19.440 --> 01:03:21.440]  в юникс-системах, в линуксе,
[01:03:21.440 --> 01:03:23.440]  в мак-аси и вообще во всех
[01:03:23.440 --> 01:03:25.440]  большинстве операционных систем,
[01:03:25.440 --> 01:03:27.440]  ну там, я не знаю
[01:03:27.440 --> 01:03:29.440]  как везде, но вообще в компьютерном мире
[01:03:29.440 --> 01:03:31.440]  принято считать время как количество секунд,
[01:03:31.440 --> 01:03:33.440]  прошедшее от 1 января
[01:03:33.440 --> 01:03:35.440]  еще 1970 года.
[01:03:35.440 --> 01:03:37.440]  По иронии судьбы, как раз
[01:03:37.440 --> 01:03:39.440]  Линус Торвальдс родился за три дня до этого,
[01:03:39.440 --> 01:03:41.440]  так что можно считать, что все мы считаем
[01:03:41.440 --> 01:03:43.440]  время как количество секунд от его
[01:03:43.440 --> 01:03:45.440]  рождения. Вот.
[01:03:45.440 --> 01:03:47.440]  Но в 19 января 2038
[01:03:47.440 --> 01:03:49.440]  года их станет больше, чем вот это
[01:03:49.440 --> 01:03:51.440]  число, и
[01:03:51.440 --> 01:03:53.440]  все, кто не перейдут на 64 бит
[01:03:53.440 --> 01:03:55.440]  формат хранения времени, схватят переполнение
[01:03:55.440 --> 01:03:57.440]  и все часы, когда компьютерные
[01:03:57.440 --> 01:03:59.440]  уйдут с ума и вернутся
[01:03:59.440 --> 01:04:01.440]  в 20-й век. Вот это называется проблемой
[01:04:01.440 --> 01:04:03.440]  на 2038 года. Вот.
[01:04:03.440 --> 01:04:05.440]  К этому времени всем надо успеть перестроиться
[01:04:05.440 --> 01:04:07.440]  на 64-битный формат хранения времени.
[01:04:07.440 --> 01:04:09.440]  Другая интересная
[01:04:09.440 --> 01:04:11.440]  вещь, которую я люблю упоминать, связанная
[01:04:11.440 --> 01:04:13.440]  с Максом Том, это
[01:04:13.440 --> 01:04:15.440]  такая, что
[01:04:15.440 --> 01:04:17.440]  вот если вы в ВК
[01:04:17.440 --> 01:04:19.440]  много переписывались
[01:04:19.440 --> 01:04:21.440]  когда-нибудь, вы, возможно, замечали,
[01:04:21.440 --> 01:04:23.440]  как тут выглядит адресная строка, там,
[01:04:23.440 --> 01:04:25.440]  когда вы как-нибудь пишите сообщение, у вас там адрес
[01:04:25.440 --> 01:04:27.440]  nuk.com, slash, im, знак вопроса
[01:04:27.440 --> 01:04:29.440]  sam равно, а дальше
[01:04:29.440 --> 01:04:31.440]  ID-шник пользователя. Ну, это когда
[01:04:31.440 --> 01:04:33.440]  вы чат с пользователем открываете.
[01:04:33.440 --> 01:04:35.440]  И вы могли заметить, что если вы переписываетесь
[01:04:35.440 --> 01:04:37.440]  например, с сообществом,
[01:04:37.440 --> 01:04:39.440]  то там написан не ID-шник сообщества, а
[01:04:39.440 --> 01:04:41.440]  2 блярда плюс ID-шник сообщества.
[01:04:41.440 --> 01:04:43.440]  Вот. Или
[01:04:43.440 --> 01:04:45.440]  или когда вы с группой
[01:04:45.440 --> 01:04:47.440]  переписываетесь, по-моему, вот ID-шник
[01:04:47.440 --> 01:04:49.440]  ну, чата,
[01:04:49.440 --> 01:04:51.440]  то ли ID-шник чата,
[01:04:51.440 --> 01:04:53.440]  то ли ID-шник переписывается
[01:04:53.440 --> 01:04:55.440]  сообществом, вы считаете как 2 блярда
[01:04:55.440 --> 01:04:57.440]  плюс ID-шник соответствующий.
[01:04:57.440 --> 01:04:59.440]  Почему так? Ну, потому что вот им нужно было
[01:04:59.440 --> 01:05:01.440]  как-то отделить ID-шники
[01:05:01.440 --> 01:05:03.440]  юзеров от ID-шники не-юзеров.
[01:05:03.440 --> 01:05:05.440]  И что они придумали? Они не придумали ничего
[01:05:05.440 --> 01:05:07.440]  лучше, чем 2 блярда, давайте. Почему 2 блярда?
[01:05:07.440 --> 01:05:09.440]  Ну, потому что, чтобы Максин продолжал
[01:05:09.440 --> 01:05:11.440]  влезать, ну, как бы чтобы точно противник.
[01:05:11.440 --> 01:05:13.440]  Вот. Это довольно забавно, мне кажется.
[01:05:15.440 --> 01:05:17.440]  Вот. Ну, шор хранит
[01:05:17.440 --> 01:05:19.440]  до 32 767.
[01:05:19.440 --> 01:05:21.440]  Ну, вы уже
[01:05:21.440 --> 01:05:23.440]  слишком молоды, чтобы такое знать,
[01:05:23.440 --> 01:05:25.440]  но вот в мои времена, когда я был
[01:05:25.440 --> 01:05:27.440]  когда мне было 10 лет, у меня была игра
[01:05:27.440 --> 01:05:29.440]  Герои Меча и Магии, там максимальное число
[01:05:29.440 --> 01:05:31.440]  существ в отряде было идет 32 767.
[01:05:31.440 --> 01:05:33.440]  Вот.
[01:05:33.440 --> 01:05:35.440]  С чего бы это, думал я,
[01:05:35.440 --> 01:05:37.440]  но потом я подрос и понял.
[01:05:37.440 --> 01:05:39.440]  Потому что
[01:05:39.440 --> 01:05:41.440]  это Макс число, которое в Губайке
[01:05:41.440 --> 01:05:43.440]  не знает.
[01:05:43.440 --> 01:05:45.440]  Ну, хорошо. Наряду с этими
[01:05:45.440 --> 01:05:47.440]  типами есть еще unsigned их версии,
[01:05:47.440 --> 01:05:49.440]  то есть можно их сделать беззнаковыми.
[01:05:49.440 --> 01:05:51.440]  Можно
[01:05:51.440 --> 01:05:53.440]  попросить так называемого unsigned int,
[01:05:53.440 --> 01:05:55.440]  то есть int, в котором нет
[01:05:55.440 --> 01:05:57.440]  знака. Тогда он будет уметь хранить
[01:05:57.440 --> 01:05:59.440]  числа от 0 до 2
[01:05:59.440 --> 01:06:01.440]  в 32 минус 1.
[01:06:01.440 --> 01:06:03.440]  Соответственно.
[01:06:03.440 --> 01:06:05.440]  Unsigned можно сделать любой из этих,
[01:06:05.440 --> 01:06:07.440]  то есть можно сделать unsigned int, unsigned long, unsigned long
[01:06:07.440 --> 01:06:09.440]  и так далее.
[01:06:09.440 --> 01:06:11.440]  Можно
[01:06:11.440 --> 01:06:13.440]  даже не дописать int,
[01:06:13.440 --> 01:06:15.440]  а просто написать unsigned.
[01:06:15.440 --> 01:06:17.440]  Если вы просто написали unsigned, не уточнили что-то,
[01:06:17.440 --> 01:06:19.440]  вы читаете, что вы просили unsigned int.
[01:06:21.440 --> 01:06:23.440]  Кроме того,
[01:06:23.440 --> 01:06:25.440]  есть
[01:06:25.440 --> 01:06:27.440]  типы с фиксированной
[01:06:27.440 --> 01:06:29.440]  шириной, о которых полезно знать.
[01:06:29.440 --> 01:06:31.440]  Это
[01:06:31.440 --> 01:06:33.440]  int 8, знак подчеркивания
[01:06:33.440 --> 01:06:35.440]  t, int 16,
[01:06:35.440 --> 01:06:37.440]  знак подчеркивания t,
[01:06:37.440 --> 01:06:39.440]  int 32, знак подчеркивания t,
[01:06:39.440 --> 01:06:41.440]  int 64, знак подчеркивания t.
[01:06:43.440 --> 01:06:45.440]  Сейчас объясню.
[01:06:45.440 --> 01:06:47.440]  Это типы с фиксированной шириной.
[01:06:47.440 --> 01:06:49.440]  Что значит с фиксированной шириной?
[01:06:49.440 --> 01:06:51.440]  Гарантируется, что их размер ровно такой.
[01:06:51.440 --> 01:06:53.440]  Ну, например, int 32t
[01:06:53.440 --> 01:06:55.440]  гарантируется, что это ровно 4 байка,
[01:06:55.440 --> 01:06:57.440]  то есть ровно 2 в 32 возможных значений.
[01:06:57.440 --> 01:06:59.440]  Зачем это надо? Потому что проинт
[01:06:59.440 --> 01:07:01.440]  не гарантируется.
[01:07:01.440 --> 01:07:03.440]  Если вам в какой-то ситуации нужно, чтобы
[01:07:03.440 --> 01:07:05.440]  вы были уверены, что
[01:07:05.440 --> 01:07:07.440]  примерно занимает ровно 4 байка,
[01:07:07.440 --> 01:07:09.440]  то вы можете написать int 32t,
[01:07:09.440 --> 01:07:11.440]  чтобы быть уверенны, что там ровно столько.
[01:07:11.440 --> 01:07:13.440]  Вот. Иногда это бывает нужно,
[01:07:13.440 --> 01:07:15.440]  например, когда вы строго соблюдаете
[01:07:15.440 --> 01:07:17.440]  какой-нибудь формат данных, вам нужно там
[01:07:17.440 --> 01:07:19.440]  ну, вы какие-нибудь там данные
[01:07:19.440 --> 01:07:21.440]  куски передаете в каком-нибудь определенном
[01:07:21.440 --> 01:07:23.440]  строму формате или, не знаю, там с какой-нибудь графикой
[01:07:23.440 --> 01:07:25.440]  работаете, у вас там поля должны быть фиксированной ширины.
[01:07:25.440 --> 01:07:27.440]  Ну, тогда используйте переменные
[01:07:27.440 --> 01:07:29.440]  фиксированной ширины.
[01:07:29.440 --> 01:07:31.440]  У них также есть беззнаковые версии.
[01:07:31.440 --> 01:07:33.440]  uint 8t,
[01:07:33.440 --> 01:07:35.440]  uint 16t, uint 32t,
[01:07:35.440 --> 01:07:37.440]  uint 64t,
[01:07:37.440 --> 01:07:39.440]  u от слова unsigned.
[01:07:39.440 --> 01:07:41.440]  То есть uint 32t
[01:07:41.440 --> 01:07:43.440]  это тип, который хранит
[01:07:43.440 --> 01:07:45.440]  гарантированно от 0 до 2 в 32-1.
[01:07:49.440 --> 01:07:51.440]  Еще есть такой тип,
[01:07:51.440 --> 01:07:53.440]  называется size t.
[01:07:53.440 --> 01:07:55.440]  Нам с ним довольно часто
[01:07:55.440 --> 01:07:57.440]  придется сталкиваться.
[01:07:57.440 --> 01:07:59.440]  Это тип, который, как правило,
[01:07:59.440 --> 01:08:01.440]  эквивалентен
[01:08:01.440 --> 01:08:03.440]  типу unsigned long и long,
[01:08:03.440 --> 01:08:05.440]  может быть unsigned long,
[01:08:05.440 --> 01:08:07.440]  может быть unsigned int, не знаю.
[01:08:07.440 --> 01:08:09.440]  Но смысл в чем?
[01:08:09.440 --> 01:08:11.440]  Это такой тип, который
[01:08:11.440 --> 01:08:13.440]  используется для хранения
[01:08:13.440 --> 01:08:15.440]  числа,
[01:08:15.440 --> 01:08:17.440]  применяемого для индексации.
[01:08:17.440 --> 01:08:19.440]  Вот, когда у вас есть какой-то массив,
[01:08:19.440 --> 01:08:21.440]  здесь же все знают,
[01:08:21.440 --> 01:08:23.440]  что такой массив, да?
[01:08:23.440 --> 01:08:25.440]  Это хорошо.
[01:08:25.440 --> 01:08:27.440]  Ну, вообще, так неправильно
[01:08:27.440 --> 01:08:29.440]  спрашивать? Вообще, да,
[01:08:29.440 --> 01:08:31.440]  когда лекто спрашивают, здесь все знают,
[01:08:31.440 --> 01:08:33.440]  что это такое, он как-нибудь подразумевает ответ
[01:08:33.440 --> 01:08:35.440]  да и не хочет тратить время на адмиссию.
[01:08:35.440 --> 01:08:37.440]  Да, это лайфхак.
[01:08:37.440 --> 01:08:39.440]  Если вы хотите проверить,
[01:08:39.440 --> 01:08:41.440]  действительно знают люди,
[01:08:41.440 --> 01:08:43.440]  то вопрос будет по-другому.
[01:08:43.440 --> 01:08:45.440]  Короче, да, я думаю,
[01:08:45.440 --> 01:08:47.440]  что все знают, что такой массив
[01:08:47.440 --> 01:08:49.440]  из школьной программы.
[01:08:49.440 --> 01:08:51.440]  Когда вы обращаетесь по индексу в массив,
[01:08:51.440 --> 01:08:53.440]  то ожидается, что индекс
[01:08:53.440 --> 01:08:55.440]  будет...
[01:08:55.440 --> 01:08:57.440]  индекс, как правило,
[01:08:57.440 --> 01:08:59.440]  ожидается именно size t.
[01:08:59.440 --> 01:09:01.440]  Например, когда вы в vector,
[01:09:01.440 --> 01:09:03.440]  в std vector обращаетесь по индексу
[01:09:03.440 --> 01:09:05.440]  там индекс именно типа size t ожидается.
[01:09:05.440 --> 01:09:07.440]  Size t это тип
[01:09:07.440 --> 01:09:09.440]  достаточный для хранения индекса,
[01:09:09.440 --> 01:09:11.440]  который позволяет проиндексировать
[01:09:11.440 --> 01:09:13.440]  любую ячейку оперативной памяти.
[01:09:13.440 --> 01:09:15.440]  Он может не совпадать с unsigned int
[01:09:15.440 --> 01:09:17.440]  или unsigned longlong,
[01:09:17.440 --> 01:09:19.440]  в зависимости от того, как много у вас адресное пространство,
[01:09:19.440 --> 01:09:21.440]  сколько большое.
[01:09:21.440 --> 01:09:23.440]  Но вот чтобы индексировать, чтобы гарантировать,
[01:09:23.440 --> 01:09:25.440]  что вам достаточно ячеек проиндексировать всю память,
[01:09:25.440 --> 01:09:27.440]  предменяется такой тип.
[01:09:27.440 --> 01:09:29.440]  Может быть больше longlong?
[01:09:29.440 --> 01:09:31.440]  Думаю, что нет,
[01:09:31.440 --> 01:09:33.440]  потому что
[01:09:33.440 --> 01:09:35.440]  больше чем 64-битная память
[01:09:35.440 --> 01:09:37.440]  как-то я не уверен,
[01:09:37.440 --> 01:09:39.440]  что бывает.
[01:09:39.440 --> 01:09:41.440]  Ну, как-то даже на четвертой памяти
[01:09:41.440 --> 01:09:43.440]  мне кажется, столько и нет.
[01:09:43.440 --> 01:09:45.440]  Это где сколько памяти-то бывает?
[01:09:45.440 --> 01:09:47.440]  Я не знаю, ну, короче, вряд ли.
[01:09:47.440 --> 01:09:49.440]  Я не встречал.
[01:09:49.440 --> 01:09:55.440]  Size t это как правило unsigned longlong,
[01:09:55.440 --> 01:09:57.440]  возможно это unsigned int,
[01:09:57.440 --> 01:09:59.440]  вот, зависит от того,
[01:09:59.440 --> 01:10:01.440]  сколько памяти у вас, вот говоря.
[01:10:01.440 --> 01:10:03.440]  То есть это беззнаковый тип,
[01:10:03.440 --> 01:10:05.440]  размер которого зависит от того,
[01:10:05.440 --> 01:10:07.440]  как много памяти вы можете проиндексировать.
[01:10:09.440 --> 01:10:11.440]  Но я их буду использовать
[01:10:11.440 --> 01:10:13.440]  с unsigned int в перемешку
[01:10:13.440 --> 01:10:15.440]  с unsigned longlong,
[01:10:15.440 --> 01:10:17.440]  то есть разница
[01:10:17.440 --> 01:10:19.440]  не особо чувствуется.
[01:10:19.440 --> 01:10:21.440]  Можете считать, что это unsigned longlong
[01:10:21.440 --> 01:10:23.440]  или что это unsigned int,
[01:10:23.440 --> 01:10:25.440]  для наших целей это будет без разницы.
[01:10:25.440 --> 01:10:27.440]  Вот.
[01:10:27.440 --> 01:10:29.440]  Еще есть такой замечательный тип char.
[01:10:35.440 --> 01:10:37.440]  Это тип,
[01:10:37.440 --> 01:10:39.440]  который позволяет хранить символы.
[01:10:39.440 --> 01:10:41.440]  Но на самом деле
[01:10:41.440 --> 01:10:43.440]  это тоже целочисленный тип.
[01:10:43.440 --> 01:10:45.440]  По сути char это тип,
[01:10:45.440 --> 01:10:47.440]  в котором вы храните 1-байковое число.
[01:10:47.440 --> 01:10:49.440]  Char от слова character, символ.
[01:10:49.440 --> 01:10:51.440]  Ну, буква одна
[01:10:51.440 --> 01:10:53.440]  может в нем храниться.
[01:10:53.440 --> 01:10:55.440]  Вот.
[01:10:55.440 --> 01:10:57.440]  Особенность этого типа в том,
[01:10:57.440 --> 01:10:59.440]  что если вы переменную типа char выводите на консоль,
[01:10:59.440 --> 01:11:01.440]  то вам выводится именно
[01:11:01.440 --> 01:11:03.440]  символ с этим кодом,
[01:11:03.440 --> 01:11:05.440]  а не само это число.
[01:11:05.440 --> 01:11:07.440]  Но вы же понимаете, что у всех символов
[01:11:07.440 --> 01:11:09.440]  есть коды,
[01:11:09.440 --> 01:11:11.440]  и когда вы имеете дело
[01:11:11.440 --> 01:11:13.440]  с каким-то символом,
[01:11:13.440 --> 01:11:15.440]  программа его воспринимает как 1-байковое число.
[01:11:15.440 --> 01:11:17.440]  Просто если вы его выводите на консоль,
[01:11:17.440 --> 01:11:19.440]  вам выводится не это число,
[01:11:19.440 --> 01:11:21.440]  а символ соответствующего кода.
[01:11:21.440 --> 01:11:23.440]  Вот.
[01:11:23.440 --> 01:11:25.440]  Но на самом деле это тоже целочисленный тип,
[01:11:25.440 --> 01:11:27.440]  и тип char, как и им,
[01:11:27.440 --> 01:11:29.440]  поддерживает все арифметические операции.
[01:11:29.440 --> 01:11:31.440]  То есть можно складывать char и друг с другом умножать,
[01:11:31.440 --> 01:11:33.440]  char и друг на другу делить и так далее.
[01:11:33.440 --> 01:11:35.440]  То есть это целочисленный тип,
[01:11:35.440 --> 01:11:37.440]  полноценный, просто 1-байковый.
[01:11:37.440 --> 01:11:39.440]  Как правило, 1-байковый.
[01:11:39.440 --> 01:11:41.440]  Ну, можно с достаточно
[01:11:41.440 --> 01:11:43.440]  уверенностью утверждать, что он 1-байковый.
[01:11:43.440 --> 01:11:45.440]  К char, также как и другим
[01:11:45.440 --> 01:11:47.440]  целочисленным типом, применима приставка unsigned.
[01:11:47.440 --> 01:11:49.440]  Вы можете попросить unsigned char.
[01:11:49.440 --> 01:11:51.440]  Дело в том, что заранее неизвестно char,
[01:11:51.440 --> 01:11:53.440]  если вы написали, это будет signed или unsigned.
[01:11:53.440 --> 01:11:55.440]  Это недокументировано.
[01:11:55.440 --> 01:11:57.440]  Вам может быть нужен unsigned
[01:11:57.440 --> 01:11:59.440]  char.
[01:11:59.440 --> 01:12:01.440]  Вы, может быть, хотите, чтобы гарантированный тип
[01:12:01.440 --> 01:12:03.440]  хранил в 0,255
[01:12:03.440 --> 01:12:05.440]  это значение.
[01:12:05.440 --> 01:12:07.440]  Тогда вы можете попросить unsigned char, чтобы быть уверенным,
[01:12:07.440 --> 01:12:09.440]  что у вас беззнаковый char.
[01:12:09.440 --> 01:12:11.440]  Вы можете явно
[01:12:11.440 --> 01:12:13.440]  написать signed
[01:12:13.440 --> 01:12:15.440]  char,
[01:12:15.440 --> 01:12:17.440]  и тем самым явно попросить, чтобы он был
[01:12:17.440 --> 01:12:19.440]  беззнаковый.
[01:12:19.440 --> 01:12:21.440]  Тогда он будет хранить от минус 128 до 127.
[01:12:21.440 --> 01:12:23.440]  Еще раз повторяю, char
[01:12:23.440 --> 01:12:25.440]  это, по сути, тоже целое число,
[01:12:25.440 --> 01:12:27.440]  1-байковое. Просто, особенность его в том,
[01:12:27.440 --> 01:12:29.440]  что, когда вы его на консоль выводите,
[01:12:29.440 --> 01:12:31.440]  оно превращается в символ, соответственно.
[01:12:31.440 --> 01:12:33.440]  Вот и все. А так, вся рифутическая операция
[01:12:33.440 --> 01:12:35.440]  к нему применима.
[01:12:35.440 --> 01:12:37.440]  Ну, еще есть тип bool.
[01:12:37.440 --> 01:12:39.440]  Я здесь же про него расскажу.
[01:12:39.440 --> 01:12:41.440]  Это тип, который
[01:12:41.440 --> 01:12:43.440]  позволяет вам хранить
[01:12:43.440 --> 01:12:45.440]  логические значения.
[01:12:45.440 --> 01:12:47.440]  True или false?
[01:12:47.440 --> 01:12:49.440]  Вот.
[01:12:49.440 --> 01:12:51.440]  Этот тип
[01:12:51.440 --> 01:12:53.440]  занимает памяти, сколько?
[01:12:53.440 --> 01:12:55.440]  1-байк.
[01:12:55.440 --> 01:12:57.440]  1-байк.
[01:12:57.440 --> 01:12:59.440]  Кто-то может подумать, что 1-бит,
[01:12:59.440 --> 01:13:01.440]  но нет, 1-байк.
[01:13:01.440 --> 01:13:03.440]  Почему 1-байк, а не бит?
[01:13:03.440 --> 01:13:05.440]  Казалось бы, чтобы хранить bool,
[01:13:05.440 --> 01:13:07.440]  требуется всего лишь ноль или единичка и одно значение.
[01:13:07.440 --> 01:13:09.440]  Дело в том, что в языке C++
[01:13:09.440 --> 01:13:11.440]  у всех переменных должны быть
[01:13:11.440 --> 01:13:13.440]  разные ячейки памяти, а ячейки памяти
[01:13:13.440 --> 01:13:15.440]  индексируются байками, а не битами.
[01:13:15.440 --> 01:13:17.440]  Нельзя положить две переменных
[01:13:17.440 --> 01:13:19.440]  в одну и ту же ячейку.
[01:13:19.440 --> 01:13:21.440]  Поэтому если вы заводите переменные типа bool,
[01:13:21.440 --> 01:13:23.440]  то одна ячейка памяти у вас все равно истращена.
[01:13:23.440 --> 01:13:25.440]  1-байк он занимает, а не 1-байк.
[01:13:25.440 --> 01:13:27.440]  Правда, если вы заводите вектор из boolei,
[01:13:27.440 --> 01:13:29.440]  то, значит, такой вектор,
[01:13:29.440 --> 01:13:31.440]  в этом случае boolei будут упакованы
[01:13:31.440 --> 01:13:33.440]  по 8-байк.
[01:13:33.440 --> 01:13:35.440]  Про вектор мы попозже поговорим.
[01:13:35.440 --> 01:13:37.440]  Значит, bool позволяет
[01:13:37.440 --> 01:13:39.440]  нам хранить логическое значение.
[01:13:39.440 --> 01:13:41.440]  Соответственно, к boolei применима операция
[01:13:41.440 --> 01:13:43.440]  логическая и, логическая или,
[01:13:47.440 --> 01:13:49.440]  логическая не,
[01:13:51.440 --> 01:13:53.440]  отрицание bool.
[01:13:53.440 --> 01:13:55.440]  Также bool не явно конвертируется в int
[01:13:55.440 --> 01:13:57.440]  и обратно. То есть из bool
[01:13:57.440 --> 01:13:59.440]  можно не явно получить целое число,
[01:13:59.440 --> 01:14:01.440]  и наоборот.
[01:14:01.440 --> 01:14:03.440]  А как bool превращается в int?
[01:14:03.440 --> 01:14:05.440]  Если у вас true, то это считается единицей,
[01:14:05.440 --> 01:14:07.440]  если это false, то это считается ложью.
[01:14:07.440 --> 01:14:09.440]  Вот, то это считается нулем.
[01:14:09.440 --> 01:14:11.440]  То есть, например,
[01:14:11.440 --> 01:14:13.440]  если у вас есть bool,
[01:14:13.440 --> 01:14:15.440]  ну вот пример,
[01:14:15.440 --> 01:14:17.440]  допустим, у вас есть bool,
[01:14:17.440 --> 01:14:19.440]  b равно true,
[01:14:19.440 --> 01:14:21.440]  да,
[01:14:21.440 --> 01:14:23.440]  и вы написали,
[01:14:23.440 --> 01:14:25.440]  ну там,
[01:14:25.440 --> 01:14:27.440]  вы все аут вылили
[01:14:27.440 --> 01:14:29.440]  5 плюс b,
[01:14:31.440 --> 01:14:33.440]  ну посмотрите,
[01:14:33.440 --> 01:14:35.440]  все аут,
[01:14:35.440 --> 01:14:37.440]  то выведется 6,
[01:14:37.440 --> 01:14:39.440]  потому что b
[01:14:39.440 --> 01:14:41.440]  не явно превратится в 1.
[01:14:41.440 --> 01:14:43.440]  Это будет неявная конверсия bool.
[01:14:45.440 --> 01:14:47.440]  Обратно, если у вас есть int,
[01:14:47.440 --> 01:14:49.440]  а требуется bool, то произойдет
[01:14:49.440 --> 01:14:51.440]  неявная конверсия, по правилу,
[01:14:51.440 --> 01:14:53.440]  все, что не ноль считается истиной,
[01:14:53.440 --> 01:14:55.440]  а ноль считается ложью.
[01:14:55.440 --> 01:14:57.440]  То есть если вы пишете if
[01:14:57.440 --> 01:14:59.440]  и под if пишете int,
[01:14:59.440 --> 01:15:01.440]  например, не знаю,
[01:15:01.440 --> 01:15:03.440]  минус 3,
[01:15:03.440 --> 01:15:05.440]  что-то сделать, да,
[01:15:05.440 --> 01:15:07.440]  то минус 3 считается истиной,
[01:15:07.440 --> 01:15:09.440]  потому что это не ноль.
[01:15:09.440 --> 01:15:11.440]  И не явно превратится в bool, по такому правилу.
[01:15:13.440 --> 01:15:15.440]  Так, это были целочисленные типы.
[01:15:17.440 --> 01:15:19.440]  Ну, видимо,
[01:15:19.440 --> 01:15:21.440]  последнее, о чем я успею сегодня рассказать,
[01:15:21.440 --> 01:15:23.440]  это типы с плавающей точкой.
[01:15:23.440 --> 01:15:25.440]  Вторая часть,
[01:15:25.440 --> 01:15:27.440]  вторая, значит,
[01:15:27.440 --> 01:15:29.440]  второй пункт,
[01:15:29.440 --> 01:15:31.440]  здесь это floating point times.
[01:15:33.440 --> 01:15:35.440]  Типы, позволяющие
[01:15:35.440 --> 01:15:37.440]  хранить дробные числа.
[01:15:39.440 --> 01:15:41.440]  Их в основном три,
[01:15:41.440 --> 01:15:43.440]  это float, double
[01:15:45.440 --> 01:15:47.440]  и long double.
[01:15:55.440 --> 01:15:57.440]  Это типы, позволяющие
[01:15:57.440 --> 01:15:59.440]  хранить дробные значения.
[01:15:59.440 --> 01:16:01.440]  Ну, здесь, наверное, стоит сказать о том,
[01:16:01.440 --> 01:16:03.440]  а как вообще можно представлять
[01:16:03.440 --> 01:16:05.440]  в памяти дробные значения.
[01:16:05.440 --> 01:16:07.440]  Вот, когда у вас хранится
[01:16:07.440 --> 01:16:09.440]  дробное число, оно же должно
[01:16:09.440 --> 01:16:11.440]  в двоичном коде как хранить,
[01:16:11.440 --> 01:16:13.440]  как это вообще работает?
[01:16:13.440 --> 01:16:15.440]  Ну,
[01:16:15.440 --> 01:16:17.440]  дробные числа,
[01:16:17.440 --> 01:16:19.440]  как правило, вообще,
[01:16:19.440 --> 01:16:21.440]  почему они называются floating point?
[01:16:21.440 --> 01:16:23.440]  Плавающая точка. Float — это плавать.
[01:16:23.440 --> 01:16:25.440]  Почему он так называется?
[01:16:25.440 --> 01:16:27.440]  Потому что они хранятся
[01:16:27.440 --> 01:16:29.440]  в формате
[01:16:29.440 --> 01:16:31.440]  мантиса плюс экспонента.
[01:16:31.440 --> 01:16:33.440]  У вас есть как бы мантиса,
[01:16:33.440 --> 01:16:35.440]  обозначающая значащие цифры.
[01:16:35.440 --> 01:16:37.440]  Экспонента обозначает на два,
[01:16:37.440 --> 01:16:39.440]  в какой степени надо домновить значащие цифры,
[01:16:39.440 --> 01:16:41.440]  чтобы получить нужное число.
[01:16:41.440 --> 01:16:43.440]  А еще есть бит, отвечающий за знак.
[01:16:43.440 --> 01:16:45.440]  Ну, подобно тому, как в физике у вас,
[01:16:45.440 --> 01:16:47.440]  я не знаю, может быть,
[01:16:47.440 --> 01:16:49.440]  1 из 63 умножить на 10 минус 3.
[01:16:49.440 --> 01:16:51.440]  Да, ну, аналогия с физикой.
[01:16:51.440 --> 01:16:53.440]  Вот это называется мантиса,
[01:16:53.440 --> 01:16:55.440]  а вот это называется экспонента.
[01:16:55.440 --> 01:16:57.440]  То же самое в программировании.
[01:16:57.440 --> 01:16:59.440]  Мантисовое значение числа представляется
[01:16:59.440 --> 01:17:01.440]  вот в такой форме.
[01:17:01.440 --> 01:17:03.440]  Только вместо 10 минус 3 у вас 2.
[01:17:03.440 --> 01:17:05.440]  Ну, основание стимучления — 2.
[01:17:05.440 --> 01:17:07.440]  То есть, когда у вас кодируется
[01:17:07.440 --> 01:17:09.440]  дробное число, оно примерно
[01:17:09.440 --> 01:17:11.440]  так устроено.
[01:17:11.440 --> 01:17:13.440]  У вас один бит отвечает за его знак.
[01:17:15.440 --> 01:17:17.440]  Дальше какое-то количество бит
[01:17:17.440 --> 01:17:19.440]  отвечает за мантису.
[01:17:21.440 --> 01:17:23.440]  То есть, ну, просто это биты,
[01:17:23.440 --> 01:17:25.440]  кодирующие значащие цифры,
[01:17:25.440 --> 01:17:27.440]  чтобы это не значило.
[01:17:27.440 --> 01:17:29.440]  Ну, просто сколько-то, не знаю.
[01:17:29.440 --> 01:17:31.440]  315.
[01:17:31.440 --> 01:17:33.440]  А дальше у вас есть экспонента,
[01:17:33.440 --> 01:17:35.440]  который обозначает степень двойки,
[01:17:37.440 --> 01:17:39.440]  на которую нужно домножить
[01:17:39.440 --> 01:17:41.440]  вот это вот число, закодированное
[01:17:41.440 --> 01:17:43.440]  вот этими битами, чтобы получить нужное.
[01:17:43.440 --> 01:17:45.440]  Например, я могу здесь закодировать
[01:17:45.440 --> 01:17:47.440]  315 битами двоичными,
[01:17:47.440 --> 01:17:49.440]  а здесь закодировать
[01:17:49.440 --> 01:17:51.440]  минус 5.
[01:17:51.440 --> 01:17:53.440]  Тогда это будет число, обозначающее
[01:17:53.440 --> 01:17:55.440]  12 на 2 в минус 5, ну, условно.
[01:17:55.440 --> 01:17:57.440]  Понятно, что там не совсем так,
[01:17:57.440 --> 01:17:59.440]  но идейно так-то хранится.
[01:17:59.440 --> 01:18:01.440]  А еще вот этот бит отвечает за знак.
[01:18:01.440 --> 01:18:03.440]  Вот примерно так хранятся
[01:18:03.440 --> 01:18:05.440]  дробные числа. Понятно?
[01:18:05.440 --> 01:18:07.440]  Соответственно...
[01:18:07.440 --> 01:18:09.440]  Чего-чего?
[01:18:09.440 --> 01:18:11.440]  Ну, умножаем или делим?
[01:18:11.440 --> 01:18:13.440]  Здесь может быть как половительная степень,
[01:18:13.440 --> 01:18:15.440]  тогда отрицательная.
[01:18:15.440 --> 01:18:17.440]  Вот.
[01:18:17.440 --> 01:18:19.440]  Соответственно,
[01:18:19.440 --> 01:18:21.440]  float,
[01:18:21.440 --> 01:18:23.440]  сокращение от слова floating,
[01:18:23.440 --> 01:18:25.440]  это тип, который
[01:18:25.440 --> 01:18:27.440]  как правило, хранит
[01:18:27.440 --> 01:18:29.440]  4-байтное дробное число,
[01:18:29.440 --> 01:18:31.440]  то есть в нем
[01:18:31.440 --> 01:18:33.440]  количество бит, отведенных по мантису и на экспоненту,
[01:18:33.440 --> 01:18:35.440]  ну, 4 байта, это значит 32 бита,
[01:18:35.440 --> 01:18:37.440]  и я боюсь соврать,
[01:18:37.440 --> 01:18:39.440]  я не помню,
[01:18:39.440 --> 01:18:41.440]  но по-моему, что-то типа там,
[01:18:41.440 --> 01:18:43.440]  ну,
[01:18:43.440 --> 01:18:45.440]  не знаю, условно,
[01:18:45.440 --> 01:18:47.440]  19 бит отведено под мантису
[01:18:47.440 --> 01:18:49.440]  и 11 под экспоненту.
[01:18:49.440 --> 01:18:51.440]  Какое? Я не помню.
[01:18:51.440 --> 01:18:53.440]  Я, честно, не помню, это не очень важно,
[01:18:53.440 --> 01:18:55.440]  но вот примерно, то есть у вас 32 бита
[01:18:55.440 --> 01:18:57.440]  всего, да, в 4 байках,
[01:18:57.440 --> 01:18:59.440]  значит, и в них сколько-то отведено под мантису
[01:18:59.440 --> 01:19:01.440]  и сколько-то под экспонент.
[01:19:01.440 --> 01:19:03.440]  Окей? Вот.
[01:19:03.440 --> 01:19:05.440]  Double это дробное число, которое, как правило,
[01:19:05.440 --> 01:19:07.440]  занимает вот один байт,
[01:19:07.440 --> 01:19:09.440]  и в примерах мы будем, как правило,
[01:19:09.440 --> 01:19:11.440]  в дробных числах они используют в формате double.
[01:19:11.440 --> 01:19:13.440]  Вот.
[01:19:13.440 --> 01:19:15.440]  Почему называется double?
[01:19:15.440 --> 01:19:17.440]  Потому что двойной относительно float.
[01:19:17.440 --> 01:19:19.440]  Двойная точность по сравнению с float.
[01:19:19.440 --> 01:19:21.440]  Long double это
[01:19:21.440 --> 01:19:23.440]  еще более широкий тип,
[01:19:23.440 --> 01:19:25.440]  как правило, он занимает 16 байков,
[01:19:25.440 --> 01:19:27.440]  хотя, может, где-то и вольсы, то есть позволяет
[01:19:27.440 --> 01:19:29.440]  еще больше точностью дробные числа представлять.
[01:19:29.440 --> 01:19:31.440]  Понятно, что
[01:19:31.440 --> 01:19:33.440]  эти типы не позволяют вам абсолютно точно
[01:19:33.440 --> 01:19:35.440]  представлять дробные числа. Если у вас число
[01:19:35.440 --> 01:19:37.440]  в боечной системе непредставимо,
[01:19:37.440 --> 01:19:39.440]  то у вас будет некоторое приближение к нему.
[01:19:41.440 --> 01:19:43.440]  Понятно также, что,
[01:19:43.440 --> 01:19:45.440]  значит,
[01:19:47.440 --> 01:19:49.440]  если у вас
[01:19:49.440 --> 01:19:51.440]  число по модулю большое,
[01:19:51.440 --> 01:19:53.440]  то вариативность минимум становится.
[01:19:53.440 --> 01:19:55.440]  Вот обратите внимание,
[01:19:55.440 --> 01:19:57.440]  какое следствие из-за того, что числа
[01:19:57.440 --> 01:19:59.440]  так хранятся. Если у вас
[01:19:59.440 --> 01:20:01.440]  число по модулю маленькое, близкое к нулю,
[01:20:01.440 --> 01:20:03.440]  не знаю, одна миллионная,
[01:20:03.440 --> 01:20:05.440]  вы можете его закодировать
[01:20:05.440 --> 01:20:07.440]  в таком представлении. Вам надо просто написать
[01:20:07.440 --> 01:20:09.440]  один и экспонент минус шесть,
[01:20:09.440 --> 01:20:11.440]  условно.
[01:20:11.440 --> 01:20:13.440]  Но если у вас число
[01:20:13.440 --> 01:20:15.440]  очень большое по модулю,
[01:20:15.440 --> 01:20:17.440]  например, миллион целых, одна миллионная,
[01:20:17.440 --> 01:20:19.440]  такое число вы уже не представите
[01:20:19.440 --> 01:20:21.440]  в виде
[01:20:21.440 --> 01:20:23.440]  флот и в виде даббл тоже не представите,
[01:20:23.440 --> 01:20:25.440]  потому что вам бита на мантису не хватит
[01:20:25.440 --> 01:20:27.440]  просто. Чем больше
[01:20:27.440 --> 01:20:29.440]  по модулю ваше число,
[01:20:29.440 --> 01:20:31.440]  тем шире
[01:20:31.440 --> 01:20:33.440]  шапка.
[01:20:33.440 --> 01:20:35.440]  В диапазоне от нуля до единицы
[01:20:35.440 --> 01:20:37.440]  вы очень много чисел можете закодировать, а в диапазоне
[01:20:37.440 --> 01:20:39.440]  от миллиона до миллиона одного
[01:20:39.440 --> 01:20:41.440]  вы очень мало или почти ничего
[01:20:41.440 --> 01:20:43.440]  не можете закодировать, потому что
[01:20:43.440 --> 01:20:45.440]  на мантису уже потрачено тем, чтобы написать число
[01:20:45.440 --> 01:20:47.440]  миллион. Понятно? Вот это
[01:20:47.440 --> 01:20:49.440]  побочный эффект. Но полезное
[01:20:49.440 --> 01:20:51.440]  свойство даббла заключается в том, что
[01:20:51.440 --> 01:20:53.440]  все, что представимо интом, представимо дабблом
[01:20:53.440 --> 01:20:55.440]  без потери точности. Это полезный
[01:20:55.440 --> 01:20:57.440]  факт, который
[01:20:57.440 --> 01:20:59.440]  часто пригодается. Если у вас что-то
[01:20:59.440 --> 01:21:01.440]  влезает в инт, то оно и в даббл тоже
[01:21:01.440 --> 01:21:03.440]  влезает. Без потери точности.
[01:21:03.440 --> 01:21:05.440]  Целые числа кодируются без потери точности
[01:21:05.440 --> 01:21:07.440]  дабблом, в рамках которого
[01:21:07.440 --> 01:21:09.440]  влезает.
[01:21:09.440 --> 01:21:11.440]  Вот.
[01:21:11.440 --> 01:21:13.440]  Вот это то, что касается
[01:21:13.440 --> 01:21:15.440]  чисел с плавающей точкой.
[01:21:17.440 --> 01:21:19.440]  Ну, понятно также, что числа
[01:21:19.440 --> 01:21:21.440]  давайте в последнее скажу, что числа
[01:21:21.440 --> 01:21:23.440]  могут неявно конвертироваться
[01:21:23.440 --> 01:21:25.440]  из
[01:21:25.440 --> 01:21:27.440]  целых в дробные и обратные.
[01:21:27.440 --> 01:21:29.440]  То есть, например, если вы написали
[01:21:29.440 --> 01:21:31.440]  там
[01:21:33.440 --> 01:21:35.440]  понятно, что
[01:21:35.440 --> 01:21:37.440]  если вы написали какой-нибудь
[01:21:37.440 --> 01:21:39.440]  int х равно там
[01:21:39.440 --> 01:21:41.440]  и написали
[01:21:41.440 --> 01:21:43.440]  даббл
[01:21:43.440 --> 01:21:45.440]  д равно х,
[01:21:45.440 --> 01:21:47.440]  то
[01:21:47.440 --> 01:21:49.440]  без проблем произойдет конверсия.
[01:21:49.440 --> 01:21:51.440]  Но вы должны понимать, что в этот момент происходит именно
[01:21:51.440 --> 01:21:53.440]  конверсия, потому что int
[01:21:53.440 --> 01:21:55.440]  это одно представление числа, это просто
[01:21:55.440 --> 01:21:57.440]  целочисленные литы, а перевести его в даббл
[01:21:57.440 --> 01:21:59.440]  это нужно вот этому антисуэкспоненту вычислить.
[01:21:59.440 --> 01:22:01.440]  Происходит неявная конверсия в этот момент,
[01:22:01.440 --> 01:22:03.440]  но она происходит без потери точности.
[01:22:03.440 --> 01:22:05.440]  Но бывает конверсии
[01:22:05.440 --> 01:22:07.440]  в обратную сторону, если
[01:22:07.440 --> 01:22:09.440]  я написал там даббл д равно 3.14
[01:22:11.440 --> 01:22:13.440]  а потом сказал х равно д,
[01:22:13.440 --> 01:22:15.440]  то
[01:22:15.440 --> 01:22:17.440]  произойдет конверсия в обратную сторону
[01:22:17.440 --> 01:22:19.440]  с потерей дробной части.
[01:22:19.440 --> 01:22:21.440]  То есть int присвоится даббл,
[01:22:21.440 --> 01:22:23.440]  но поскольку переменной
[01:22:23.440 --> 01:22:25.440]  своих менять не могут,
[01:22:25.440 --> 01:22:27.440]  х станет равным просто 3.
[01:22:27.440 --> 01:22:29.440]  Просто от даббла трешется дробная часть.
[01:22:29.440 --> 01:22:31.440]  Это не округление, это именно отрезание
[01:22:31.440 --> 01:22:33.440]  дробной части. Если у вас было бы 39,
[01:22:33.440 --> 01:22:35.440]  то будет
[01:22:35.440 --> 01:22:37.440]  снова 3 все равно.
[01:22:37.440 --> 01:22:39.440]  А если отрицательная, то
[01:22:39.440 --> 01:22:41.440]  Ой!
[01:22:41.440 --> 01:22:43.440]  Не знаю, не помню.
[01:22:43.440 --> 01:22:45.440]  На самом деле лучше
[01:22:45.440 --> 01:22:47.440]  так не делать просто.
[01:22:47.440 --> 01:22:49.440]  Неявные конверсии они
[01:22:51.440 --> 01:22:53.440]  в настоящем коде не рекомендуются
[01:22:53.440 --> 01:22:55.440]  и более того
[01:22:55.440 --> 01:22:57.440]  хорошие компиляторы выдадут вам
[01:22:57.440 --> 01:22:59.440]  предупреждение, если вы делаете неявную
[01:22:59.440 --> 01:23:01.440]  конверсию из даббла выдают, потому что
[01:23:01.440 --> 01:23:03.440]  это специальная ошибка в коде.
[01:23:03.440 --> 01:23:05.440]  Я не помню правил неявной конверсии
[01:23:05.440 --> 01:23:07.440]  по причине того, что
[01:23:07.440 --> 01:23:09.440]  их вообще лучше избегать.
[01:23:09.440 --> 01:23:11.440]  Когда Страустро
[01:23:11.440 --> 01:23:13.440]  поспросили несколько лет назад,
[01:23:13.440 --> 01:23:15.440]  что бы он сделал по-другому,
[01:23:15.440 --> 01:23:17.440]  если бы сейчас разрабатывали язык с
[01:23:17.440 --> 01:23:19.440]  пятипустью заново, он сказал что
[01:23:19.440 --> 01:23:21.440]  он бы запретил неявные конверсии,
[01:23:21.440 --> 01:23:23.440]  потому что они порождают очень много
[01:23:23.440 --> 01:23:25.440]  ошибок, которые очень трудно отлавливать
[01:23:25.440 --> 01:23:27.440]  из-за того, что вы одно число
[01:23:27.440 --> 01:23:29.440]  сконвертируете в другое незаметно,
[01:23:29.440 --> 01:23:31.440]  у вас что-нибудь сломалось.
[01:23:31.440 --> 01:23:33.440]  Ну, наверное, это все, что я сегодня
[01:23:33.440 --> 01:23:35.440]  успел рассказать.
