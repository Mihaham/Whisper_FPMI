[00:00.000 --> 00:10.080]  Так, ну и тема сегодняшнего занятия, последнее в этом модуле, это Extended Berkeley Packet Filter.
[00:10.080 --> 00:18.800]  Достаточно короткая тема, потому что тут в основном будут всякие экзамплы, ковыряться по
[00:18.800 --> 00:24.280]  чужим экзамплам, все детально разберется, смысла никакого нет, можно посмотреть только самое
[00:24.280 --> 00:31.120]  основное, типовое. Что это за технология такая? Это линукс-специфичная технология,
[00:31.120 --> 00:39.360]  которая была отобавлена, начала разрабатываться в 2013 году и распространялся в 2016 году,
[00:39.360 --> 00:47.360]  когда попала в основную ветку Linux и в основные мейнстритные дистрибутивы. Разработана она в
[00:47.360 --> 00:51.160]  экстремистской организации, деятельность которой запрещена на территории Российской Федерации,
[00:51.800 --> 00:58.280]  поэтому никаких ссылок не будет, никакого цитирования тоже не будет, это все запрещено
[00:58.280 --> 01:07.000]  теперь законом. Ну и небольшая отсылка о том, что такое классический Berkeley Packet Filter. Все-таки
[01:07.000 --> 01:11.840]  название Extended подразумевает, что это расширение чего-то уже существующего. В прошлый раз я вам
[01:11.840 --> 01:19.040]  уже показывал, как делать простые фильтры для того, чтобы фильтровать некоторый контент,
[01:19.040 --> 01:25.480]  как работает классический Berkeley Packet Filter. Он принимает некоторый сетевой пакет,
[01:25.480 --> 01:32.240]  соответственно лезет в различные составляющие сетевого пакета и в зависимости от того,
[01:32.240 --> 01:41.760]  подходит нам пакет либо не подходит, он его либо принимает, либо не принимает. В чем особенность
[01:41.760 --> 01:49.080]  реализации Berkeley Packet Filter? Особенность реализации в том, что вам не приходится гонять
[01:49.080 --> 01:55.920]  данные между пространством ядра и пространством пользователя. Весь код у вас, вот эта маленькая
[01:55.920 --> 02:03.880]  программка, написанная на псевдо языке какого-то ассемблера, она выполняется на самом деле в ядре.
[02:03.880 --> 02:10.360]  И что это за код ассемблер такой? Это ассемблер специально для виртуальной машины, которая
[02:10.360 --> 02:18.160]  существует внутри ядра. Понятно, что если вы можете загрузить какую-то произвольную программу в ядро,
[02:18.160 --> 02:24.880]  это очень опасно, поскольку ядро очень чувствительная штуковина, и если у вас
[02:24.880 --> 02:28.640]  грохается какой-то обычный пользовательский процесс, то ничего страшного не происходит.
[02:28.640 --> 02:34.680]  Но грохнулся процесс, и грохнулся, взяли, перезапустили. Если у вас что-то произошло не так в ядре,
[02:34.680 --> 02:41.640]  то у вас как минимум нарушена целостность всей системы, система скомпрометирована. Это очень
[02:41.640 --> 02:49.360]  нехорошо, поэтому не любой код можно загрузить и выполнить. Есть такая программа под названием
[02:49.360 --> 02:54.560]  верификатор. То есть, прежде чем выполнить произвольную программу в ядре, нужно удостовериться,
[02:54.560 --> 03:01.160]  что эта программа действительно не приведет никаким печальным последствиям, поэтому на
[03:01.160 --> 03:05.600]  исходный код программы накладываются дополнительные ограничения. И только в том случае,
[03:05.600 --> 03:12.120]  если программа считается безопасной с точки зрения верификатора, тогда ее можно выполнять.
[03:12.120 --> 03:18.400]  У любой программы, хоть на классическом BPF, хоть на экстене BPF, поэтому есть ограничение на
[03:18.400 --> 03:23.720]  количество инструкций, чтобы программа выполнялась не очень долго. Во-вторых,
[03:23.720 --> 03:30.560]  для того чтобы предотвратить долгое выполнение программы и зависание в принципе, у нас запрещены
[03:30.560 --> 03:39.840]  джампы, условные либо безусловные, на инструкции, которые были до этого. То есть, мы в принципе
[03:39.840 --> 03:49.640]  никак не можем реализовать никакие циклы. Теперь расширенный BPF. Это все было про классику,
[03:49.640 --> 03:59.200]  есть некоторый байт код, который выполняется. Что такое экстенит BPF? Вроде как общая идея точно
[03:59.200 --> 04:06.400]  такая же, как у классического BPF, но при этом это совершенно другая подсистема,
[04:06.400 --> 04:12.520]  которая в том числе позволяет делать just-in-time компиляцию в нативный код. Инструкции точно
[04:12.520 --> 04:20.800]  также аж 4-убитные, но это совершенно другой ортоканальный набор инструкций. То есть, вы
[04:20.800 --> 04:27.720]  можете скомпилировать программу сначала в байт код для eBPF, дальше загрузить ядро. Если у вас
[04:27.720 --> 04:36.320]  ядро выполняется на архитектуре x8664, то этот код будет транслирован в нативный машинный код.
[04:36.320 --> 04:41.640]  Насчет ARM я так и не нашел информации, будет ли он транслироваться или нет. Возможно, уже сделали
[04:41.640 --> 04:52.640]  поддержку в свежих версиях ядра. Ну и этот код уже дальше выполняется. В чем ключевая фича
[04:52.640 --> 05:00.920]  extended BPF по сравнению с классическим BPF? Если мы можем выполнять любой код где-то на уровне ядра,
[05:00.920 --> 05:07.400]  то это совершенно не обязательно может быть предназначено для того, чтобы фильтровать сетевые
[05:07.400 --> 05:13.960]  пакеты. Ведь в ядре есть много других событий, операции ввода-вывода, системные вызовы,
[05:13.960 --> 05:19.680]  ну и просто выполнение каких-то программ, которые можно трассировать. Таким образом,
[05:19.720 --> 05:28.320]  кроме как сетевая фильтрация, у нас инструмент по названию пакетный фильтр может быть пригоден
[05:28.320 --> 05:34.240]  для большего количества разных интересных применений. Какие могут быть применения?
[05:34.240 --> 05:42.880]  Ну понятно, что есть фильтрация сетевых пакетов. Кроме того, вы можете выполнять анализ
[05:42.880 --> 05:49.360]  производительности. Вы можете навешивать разные дополнительные функции на уже выполняющийся
[05:49.360 --> 05:55.800]  код в программе. Причем не обязательно программу запускать, может быть что-то запущенное, просто
[05:55.800 --> 06:03.760]  сайди чего вы знаете. Можете навешивать разные обработчики, связанные с определенными системными
[06:03.760 --> 06:08.360]  вызовами. И не только с системой вызовами, вообще на самом деле на любые функции внутри ядра.
[06:08.360 --> 06:16.880]  Ну и для чего это может быть использовано? В том числе, например, для мониторинга различных
[06:16.880 --> 06:23.200]  системных вызовов. Но тут есть некоторые ограничения на тему того, как вы можете их
[06:23.200 --> 06:31.480]  фильтровать. Тем не менее, есть хороший пример применения разных технологий по изоляции, в том
[06:31.480 --> 06:40.280]  числе Extended BPF, где пакет-фильтр используется для мониторинга стенных вызовов, но не для
[06:40.280 --> 06:47.400]  их модификации. Фреймворк от Гугла под названием NSGL. Да, Google пока еще не запрещенная организация
[06:47.400 --> 06:55.960]  на текущий день, поэтому это название употреблять можно. Так, ну вот в классическом Berkeley
[06:55.960 --> 07:01.800]  пакет-фильтре вы могли написать какую-то последовательность инструкций, дальше ее загрузить,
[07:01.800 --> 07:09.280]  верифицировать и запустить. Либо вы могли написать текст на ассемблере, скомпилировать
[07:09.280 --> 07:13.680]  соответственно в последовательности инструкций, которые дальше вкомпилировать внутри вашей
[07:13.680 --> 07:21.680]  программы и запустить. А с Extended BPF, поскольку программы сложнее могут быть, на ассемблере
[07:21.680 --> 07:26.640]  особо много не напишешь. И хочется все-таки иметь возможность писать их на чем-то высокоуровневом,
[07:26.640 --> 07:34.840]  например на языке C, на языке C++, на языке Rust, если вы знаете язык Rust. В общем, на любом языке,
[07:34.840 --> 07:40.480]  который поддерживается фреймворком LLVM. В прошлом году вы были первокурсниками,
[07:40.480 --> 07:47.040]  у вас был курс весной под названием технологии программирования, помните такой? Вам про LLVM
[07:47.040 --> 08:03.680]  что-нибудь рассказывали? Так, хорошо, LLVM я вам тоже покажу. Итак, давайте рассмотрим пример,
[08:03.680 --> 08:13.560]  совершенно бесполезный программ. Бесполезный, потому что наша цель это скомпилировать и загрузить,
[08:13.560 --> 08:23.320]  поэтому программа выглядит очень тривиальным образом, она просто существует. Наша задача вот
[08:23.320 --> 08:32.520]  это вот программа, кстати, видно что-нибудь на проекторе. Теронный фон, говорите, будет лучше,
[08:32.520 --> 09:00.120]  давайте попробуем. Так, лучше.
[09:02.520 --> 09:23.400]  Отключить подсветку цветов, да? Так. Ладно, тогда отказываемся от текстовых редакторов. Итак,
[09:23.400 --> 09:29.760]  вот самая дурацкая тривиальная программа, которая не делает ничего. Методически эта программа
[09:29.760 --> 09:37.640]  полезна тем, что нам нужно иметь возможность ее хотя бы как-то загрузить, верифицировать,
[09:37.640 --> 09:43.840]  то есть прежде чем загрузить, нам нужно ее скомпилировать, потом загрузить, прогнать
[09:43.840 --> 09:49.240]  через верификатор, убедить, что программа действительно работает, и если все хорошо,
[09:49.240 --> 09:59.440]  значит мы молодцы. Так, делается это, ладно, вместо EMX можно попробовать VI, может цвета будут такие.
[09:59.440 --> 10:09.520]  Ужасные. Так, теперь программа, которая все это делает. Основана она на системном вызове,
[10:09.520 --> 10:17.440]  который называется BPF. Есть системные вызовы, которые в качестве перерыва аргумента принимают
[10:17.440 --> 10:23.560]  какую-то целочисленную команду и какие-то аргументы, которые могут быть совершенно разнообразны в
[10:23.560 --> 10:30.560]  зависимости от команды. Примеры таких системных вызовов это File Control, IO Control, ну и вот один из них еще это
[10:30.560 --> 10:37.440]  системный вызов BPF, который один системный вызов имеет огромное количество всякой разной
[10:37.440 --> 10:41.320]  функциональности в зависимости от того, что вы передадите в качестве первого аргумента.
[10:41.320 --> 10:47.200]  Соответственно у него могут быть аргументы это присоединить какую-то программу загруженную к
[10:47.200 --> 10:54.520]  какому-то событию, загрузить программу, ну и так далее. Итак, вот у нас есть системный вызов BPF,
[10:54.520 --> 11:03.280]  прокручиваем ман страницу до того, что связано со словом luat. Эта команда означает загрузить какую-то
[11:03.280 --> 11:11.680]  программу и программа представляется в виде последовательности команд, которые представляются
[11:11.760 --> 11:19.800]  тоже некоторые структуры. Каждая команда имеет у нас, так это у нас, это шестичерубитное значение,
[11:19.800 --> 11:27.880]  которое в свою очередь тоже может делиться на разные кусочки под названием обход команды,
[11:27.880 --> 11:35.720]  аргумент команды и так далее. Это все закодировано некоторым образом и нам нужно сначала превратить
[11:35.720 --> 11:40.560]  какую-то произвольную программку, написанную на высокого уровня языке программирования,
[11:40.560 --> 11:54.120]  в последовательстве шестичерубитных инструкций, которые имеют тип данных, структ BPF.
[11:54.120 --> 12:09.360]  Так, это VI, как его терпеть не могу. ВИМ это не VI. Ладно,
[12:09.360 --> 12:17.840]  видно что-нибудь. Ладно, будем тогда пользоваться самым дурацким текстовым редактором,
[12:17.840 --> 12:32.040]  потому что он совершенно не функциональный. Итак, есть структура BPF INST, на самом деле каждый
[12:32.040 --> 12:40.160]  элемент структуры это просто какое-то 8-байтное число 64 бита. Наша задача прочитать набор инструкций,
[12:40.160 --> 12:50.280]  затем используя команду системы вызов BPF. Обратите внимание, что BPF вызывается не в виде BPF,
[12:50.280 --> 12:58.640]  как это написано в мане. В мане у нас есть какая-то настоящая сигнализация. Для его использования
[12:58.640 --> 13:06.680]  нужно использовать функцию Cisco. Где вы еще такое встречали раньше? Слова FUTEX, помните?
[13:10.280 --> 13:18.360]  Так вот, да. Есть некоторые системные вызовы, которые честно реализованы в виде системных вызовов.
[13:18.360 --> 13:25.760]  Они имеют ман страницы, которые написаны C-шными сигнатурами, но на самом деле в стандартной C
[13:25.760 --> 13:31.480]  библиотеке нет поддержки некоторых системных вызовов. То есть нужно их запускать ручкой.
[13:31.480 --> 13:47.800]  Про BPF возможно тоже. FUTEX написано в самом начале. Может быть когда-нибудь в глипси библиотеке после
[13:47.800 --> 13:56.240]  окончательной стабилизации функционала BPF все-таки добавит честную поддержку. Но на самом деле почему
[13:56.240 --> 14:01.440]  этой поддержки нет? Точно так же, как нет поддержки для FUTEX. Потому что FUTEX на самом деле
[14:01.440 --> 14:07.920]  вручную никто не использует. Обычно есть MUTEX, который в свою очередь использует FUTEX. MUTEX уже реализован
[14:07.920 --> 14:14.680]  в стандартной библиотеке. Пожалуйста, пользуйтесь MUTEX. Зачем вам FUTEX? То же самое с BPF. То, что я вам
[14:14.680 --> 14:19.200]  сейчас показываю, это просто некоторый ресерч, чтобы вам показать, как устроено все изнутри,
[14:19.200 --> 14:25.160]  какая на самом деле за этим кроется боль, чтобы вы это прочувствовали и больше никогда этим не
[14:25.160 --> 14:30.680]  пользовались. Итак, нам нужно подготовить некоторую программу в виде последовательности
[14:30.680 --> 14:41.600]  64-битных инструкций. Затем с помощью системного вызова CIS BPF и команды BPF LoadProc загрузить эту
[14:41.600 --> 14:50.200]  программу. Самое ключевое здесь это подготовить тот набор данных, ту последовательность 4-битных
[14:50.200 --> 14:56.080]  инструкций, которые нужно загрузить. Итак, у нас есть некоторая программа. Что мы сделаем в первую
[14:56.080 --> 15:12.480]  очередь? Итак, давайте посмотрим на этот слайд. У нас есть исходник. Нам нужно его сконвертировать
[15:12.480 --> 15:20.440]  в bytecode LLVM, который вы знаете с первого курса. Дальше bytecode LLVM может быть загружен уже в ядро
[15:20.440 --> 15:27.440]  с помощью механизма E-BPF, а затем ядро имеет право скомпилировать этот код в машинный код и
[15:27.440 --> 15:34.000]  выполнять уже машинный код. Достаточно сложная конструкция, но есть одно маленькое преимущество,
[15:34.000 --> 15:41.880]  что этот код E-BPF является портируемым и независимым от конкретной платформы. В отличие,
[15:41.880 --> 15:49.320]  кстати, от LLVM, LLVM штука не очень портируемая на самом деле. Итак, как нам превратить программу
[15:49.320 --> 15:55.880]  на выскоренном языке программирования bytecode LLVM? Если у вас программа на C или на C++,
[15:55.880 --> 16:02.120]  есть замечательный компилятор по названию C-Lang с опцией minus hemit LLVM.
[16:02.120 --> 16:17.080]  Опция minus C означает, что нужно сгенерировать какой-то файл, не доводя его до готовой программы,
[16:17.080 --> 16:27.440]  которую можно запустить. Дальше наша исходная программа. На выходе мы получаем файл
[16:27.440 --> 16:40.720]  BPF.BC. Это обычный бинарный файл, который содержит bytecode LLVM. Что мы можем с этим
[16:40.720 --> 16:49.600]  bytecode сделать? Мы можем превратить его в текстовое представление и посмотреть на нашу программу.
[16:49.600 --> 17:04.320]  LLVM.dis нам породил файл BPFProgram.ll, который уже является текстовым, а не бинарным.
[17:04.320 --> 17:13.360]  И между текстом файлом LLVM и bytecode LLVM существует строгое соответствие. Это
[17:13.360 --> 17:21.120]  некоторый ассемблерный код. Вот наша функция, сам BPFProgram, которая выделяет на стеке
[17:21.120 --> 17:33.680]  какой-то указатель, сохраняет там что-то, отбрасывает и возвращает 300 бит на значение 0.
[17:33.680 --> 17:46.080]  Вот это называется функция LLVM. Синтаксически немножко похожа на код на языке Ic. На самом
[17:46.080 --> 17:51.840]  деле, это не структурированный язык программирования. Здесь нет никаких ветвлений,
[17:51.840 --> 17:59.120]  здесь нет никаких циклов. Есть только наборы инструкции, записанные в чуть более человеческом
[17:59.120 --> 18:06.000]  виде, чем программа на языке Ic. Тоже самое можете проделать с абсолютно любой программой,
[18:06.000 --> 18:14.200]  получить некоторый текст, дальше его скомпилировать обратно в bytecode либо сразу в машинный код.
[18:14.200 --> 18:22.400]  Почему я говорю, что вот это представление не совсем партируемое? С одной стороны, у нас тут
[18:22.400 --> 18:28.760]  нет никаких регистров, поэтому мы можем компилировать эту программу под разные
[18:28.760 --> 18:36.880]  архитектуры процессоров. Здесь вы можете использовать какие-то виртуальные регистры,
[18:36.880 --> 18:44.760]  вот процент 2, процент 0 и так далее. Если у вас количество регистров на реальной машине больше
[18:44.760 --> 18:50.800]  либо равно, чем количество виртуальных регистров, то при компиляции в машинный код будет отображение
[18:50.800 --> 18:56.800]  на реальные регистры. Если у вас регистров меньше, например, 300-убитная архитектура x86,
[18:56.800 --> 19:03.920]  значит память у вас будет периодически использоваться на стеке. Тут у нас полная абстракция. Код,
[19:03.920 --> 19:10.840]  тем не менее, не партируемый, поскольку он скомпилирован в данном случае селанг 11 версии,
[19:10.840 --> 19:21.960]  компилятор 10 версии не скомпилирует. Компилятор селанг какой-нибудь 12-13 или что там самое
[19:21.960 --> 19:31.440]  последнее, не факт, что скомпилирует. Может 14-я. В чем проблема внутреннего представления LLV?
[19:31.440 --> 19:36.600]  Оно не стандартизовано и меняется от версии к версии. Сейчас уже, конечно, в меньшей степени,
[19:36.600 --> 19:41.960]  чем по сравнению с тем, что было лет пять назад, но все равно никто вам не гарантирует,
[19:41.960 --> 19:47.400]  что вот это представление хоть в текстовом, хоть в бинарном виде можно будет скомпилировать где-то
[19:47.400 --> 19:55.000]  еще. Поэтому мы про него забываем. Оно нам не подходит. Нам нужно превратить эту программу во что-то
[19:55.000 --> 20:04.280]  другое. Как потом из бинарной программы превратить что-то? Вот у вас есть bytecode LLV,
[20:04.280 --> 20:10.800]  неважно текстовое представление, либо бинарное. Но опять же, если вы селангу
[20:10.800 --> 20:19.920]  скормите какой-то файл, который заканчивается на .ll или .bc, то на выходе получите
[20:19.920 --> 20:37.760]  уже обычный объектный файл, скомпилированный для текущей архитектуры. Либо можно сразу указать,
[20:37.760 --> 20:46.600]  не генерируя промежуточные стадии, селанг вместо имитл.lvm, target и какая-нибудь другая
[20:46.600 --> 20:56.400]  архитектура отличная от текущей. Например, target BPF. Можно оставить имитл.lvm, получим то же
[20:56.400 --> 21:06.200]  самое. Либо сразу все скомпилировать, в том числе можем пропустить промежуточные стадии генерации
[21:06.200 --> 21:15.720]  .llvm bytecode, скомпилировать все из исходной программы и получаем некоторый бинарный файл,
[21:15.720 --> 21:24.280]  который скомпилирован для другой архитектуры, не текущей. У вас, наверное, это x86, у меня на этом
[21:24.280 --> 21:33.480]  конкретном компьютере это ARM 64. Получаем на выходе какой-то бинарный файл по названию BPF program.o.
[21:33.480 --> 21:42.880]  Что мы можем посмотреть? Поскольку это объектный файл, то мы можем посмотреть об gdump'ом что-нибудь.
[21:42.880 --> 21:52.040]  Так, обычного gdump'а нам тут не поможет. Can't disassemble for architecture unknown. Это gdump' идет из
[21:52.040 --> 22:07.920]  поставки GCC. Ну ладно, lvm gdump' в этом плане чуть более умный. И у нас есть какая-то программа,
[22:07.920 --> 22:19.040]  где-то есть секция текста, которая содержит метку сам BPF program, которая транслируется в какие-то
[22:19.040 --> 22:27.400]  8-байтные инструкции. В данном случае их всего три штуки. Это что-то там записать в регистр r1,
[22:27.400 --> 22:35.200]  дальше непонятно. А, ну это, видимо, неоптимизированный код, поэтому он аргумент записал в r1. Дальше в регистр
[22:35.200 --> 22:44.200]  r0 записываем значение 0, ну код возврата, и exit из функции. Это нереальный assembler,
[22:44.200 --> 22:53.280]  не assembler x86, не assembler arm, а assembler bytecode виртуальной машины BPF, который этот код
[22:53.280 --> 23:00.200]  может загрузить прямо в ядро. Так, ладно, нам нужно загрузить вот эту вот последовательность
[23:00.200 --> 23:08.160]  команд. Что мы можем сделать? Мы можем взять вот эти значения, считать их 4-битными константами,
[23:08.160 --> 23:20.200]  захардкодить массив из трех элементов и получить нормальный BPF программу. Слишком сложно, да? Зачем
[23:20.200 --> 23:26.520]  такое извращение? Давайте все-таки немножко автоматизируем наш процесс по извлечению вот
[23:26.520 --> 23:35.160]  этих вот байтиков. Хотя бы если мы получим какой-то бинарный файл, мы можем этот файл бинарный
[23:35.160 --> 23:42.920]  прочитать и дальше сделать что-то человеческое с ним, например, считать у BPF программой и загрузить.
[23:42.920 --> 23:50.640]  Так, как мы можем выделить какую-то часть из объектного файла? Ну, во-первых, у нас тут есть
[23:50.640 --> 24:04.480]  разные секции. Давайте сделаем некоторые фильтры. Опция "-j", и название секции отобразит нам только
[24:04.480 --> 24:12.520]  секции с определенным названием. То есть мы уже уменьшили количество данных, и если мы команду
[24:12.520 --> 24:22.320]  llvm-obj-dump поменяем на команду llvm-obj-copy, то мы можем скопировать что-то из одного объектного файла
[24:22.320 --> 24:32.280]  в другой. Все то же самое без префикса llvm будет работать с обычными объектными файлами для вашей
[24:32.280 --> 24:40.520]  родной архитектуры. Так, ну и при копировании мы можем указать формат данных, в котором нам нужно
[24:40.520 --> 24:49.440]  сохранить определенный участок нашего бинарного файла. Если мы напишем binary, то формат файла
[24:49.440 --> 25:00.720]  подразумевается обычный plain binary без всяких заголовков. Так, binary, ну и выходной файл какой-нибудь,
[25:00.840 --> 25:14.440]  pf-program, пусть будет просто bin. Получаем на выходе файл размером 24 байта. Вроде правильно,
[25:14.440 --> 25:21.120]  три инструкции по 8 байт в каждой. И что в себе содержит этот файл, мы можем посмотреть,
[25:21.120 --> 25:32.720]  например, хэкс дампом. Видим что-то похожее с точностью до того, что хэкс дамп разворачивает
[25:32.720 --> 25:38.880]  все слова те же самые байтики, что и в дезасимблированном выводе нашей программы.
[25:38.880 --> 25:46.400]  Так, ладно, получили такую программу, теперь мы можем этот файл бинарный открыть обычным
[25:46.400 --> 25:53.040]  системам вызовом read, прочитать, определить количество инструкции, три штуки, дальше заполнить
[25:53.040 --> 26:02.920]  аргумент для системного вызова bpf и выполнить системный вызов bpf для того, чтобы загрузить
[26:02.920 --> 26:20.680]  какую-то программу. Этим мы сейчас и займемся. Тут нам уже неважно си ланг, gcc, разницы абсолютно
[26:20.680 --> 26:33.920]  никакой. Компилируем, запускаем программу, которая загружает за хардкоженное название файла,
[26:33.920 --> 26:42.940]  которое мы сейчас сгенерируем, ppfprogram.bin. Так, и получаем ошибку. Бабах, оперейшин от
[26:42.940 --> 26:51.180]  пермитит. Потому что надо внимательно читать ман страницу на bpf, и тут где-то прописано,
[26:51.180 --> 27:04.740]  что нам нужно иметь некоторые capability с под названием cap sysadmin. Точнее, тут есть уточнение
[27:04.740 --> 27:11.420]  в notes, что начиная с версии 4.4 ядра, непривилегированные пользователи могут некоторые
[27:11.420 --> 27:20.820]  программы загружать без повышенных привилегий. То есть я могу просто написать судо. Хорошая идея.
[27:20.820 --> 27:32.660]  Ввести пароль, стать рутом. Все, программа честно загрузилась, программа пустая,
[27:32.660 --> 27:35.220]  поэтому не делать ничего. Но хотя бы никакой ошибки у нас не появилось.
[27:35.220 --> 27:50.220]  Чем плох подход через судо, или просто сразу стать рутом и запускать весь подрута. Но это небезопасно.
[27:50.220 --> 27:57.460]  Ваша программа может выполнить все что угодно. Нам нужно локально поднять привилегии. Как это сделать?
[27:57.460 --> 28:04.220]  Вспоминаем Linux Capabilities. Нам нужно иметь capability cap sysadmin для того, чтобы использовать
[28:04.220 --> 28:16.740]  стены вызов BPF. Для этого мы можем вызвать один раз с правами рута такую программу как setcap,
[28:16.740 --> 28:26.980]  прописать требуемые права и проставляем флаги для capability sysadmin. Какие нужно
[28:26.980 --> 28:35.780]  проставить флаги? Давайте вспоминаем. Это вы уже должны знать, чтобы выполнить
[28:35.780 --> 28:48.500]  стены вызов BPF один раз. Во-первых, он должен быть permissive. Логично. А еще он должен быть эффективным.
[28:48.500 --> 29:00.220]  И имя файла, на котором мы поставили право. Все, теперь без судо запускаем. Все хорошо, все замечательно.
[29:01.180 --> 29:09.700]  Что означают флаги P и E? В контроле нужно повторить вопрос. Не все на него правильно отвечают,
[29:09.700 --> 29:19.180]  может хоть выучите. P понятно, это permissive разрешить. А эффективность нам зачем нужна?
[29:19.180 --> 29:32.740]  И зачем нам не нужна inheritance? Так, ладно. Это вопрос на самостоятельное изучение. Надо
[29:32.740 --> 29:39.540]  добавить в контрольную. Продублировать еще раз. В каком ситуации у нас может пойти что-то не так,
[29:39.540 --> 29:47.180]  несмотря на наличие прав? Все, эту программу я скомпилировал, не трогаю. Я не трогаю даже файл для
[29:47.180 --> 30:01.740]  того, чтобы у него сохранились расширенные атрибуты. Вот эта все, теперь строчка, хранится в расширенных
[30:01.740 --> 30:08.500]  атрибутах файла BPF loader. Если я файл перекомпедирую или что-то с ним сделаю, расширенные атрибуты у меня
[30:08.500 --> 30:17.460]  пропадут. Мне надо будет делать операцию ситкеп еще раз. Я немножко поиздеваюсь над исходной
[30:17.460 --> 30:30.580]  программой, написанной на языке C, и добавлю way, к Z я не люблю nano. В айлтру ничего не делать,
[30:30.580 --> 30:40.580]  хорошая программа. Программа плохая, но с формальной точки зрения это корректная программа. Почему она
[30:40.580 --> 30:48.820]  корректная? Потому что баланс кобочек соблюден, никаких новых неизвестных имен у нас нет, никакой
[30:48.820 --> 30:56.580]  симатической ошибки тут с точки зрения компилятора тоже не видно. Хорошая программа. Так, хорошо,
[30:56.580 --> 31:15.820]  что же такое, файл, x, теперь C lang, target, BPF, скомпилировать, файл BPF program.c, скомпилировали,
[31:15.820 --> 31:26.780]  после этого делаем копию BPF program и пытаемся этот файл теперь запустить еще раз. Запускаем,
[31:26.780 --> 31:42.740]  получаем бабах. Бабах, почему бабах? Еще раз, вот программа, которую мы скомпилировали,
[31:43.140 --> 31:53.500]  и теперь на стадии загрузки BPF мы ее загрузить не можем. У нас есть cycle while,
[31:53.500 --> 32:02.740]  который превращается в инструкцию jump на строчку назад. Go to, program, counter,
[32:02.740 --> 32:10.340]  minus 1. Поэтому здесь потенциально возможна ситуация, когда программа никогда не остановится,
[32:10.340 --> 32:19.540]  и верификатор тупо формально эту программу не разрешает нам загрузить. Иногда все-таки в BPF
[32:19.540 --> 32:25.500]  программах бывает полезно иметь какие-то циклы. Если циклы вы никак не можете сделать,
[32:25.500 --> 32:37.740]  ну это грустно. Как с этим бороться? На стадии компиляции есть такая опция an-f unroll-loops,
[32:37.740 --> 32:48.820]  но помогает не всегда. Что делает опция unroll-loops? Она старается развернуть все циклы,
[32:48.820 --> 32:53.420]  если это возможно. Что значит развернуть циклы? Если у вас встречается какой-то цикл,
[32:53.420 --> 33:01.100]  то компилятор, при условии, что цикл, количество итераций цикла известно на стадии компиляции,
[33:01.100 --> 33:08.460]  делает большой код, повторяя каждый раз, каждую итерацию цикла. Вот такие программы верификатор
[33:08.460 --> 33:15.020]  пропустит, но в данном случае нам это не помогло, потому что цикл while true бесконечный,
[33:15.020 --> 33:20.940]  количество итераций на стадии компиляции нам в общем случае не известно, и компилятор
[33:21.100 --> 33:31.260]  оптимизацию применить не сможет. Естественно, если мы повторим еще раз копирование,
[33:31.260 --> 33:39.780]  повторим запуск, ничего не помогает. Просто так взять, запустить произвольный код в ядре,
[33:39.780 --> 33:46.540]  вы все равно не сможете. Давайте сделаем эту программку чуть более полезной,
[33:46.540 --> 33:57.300]  например, чтобы она умела что-то делать. Вот чтобы сделать эту программу чуть более полезной,
[33:57.300 --> 34:05.460]  вот пример программы, которая запускается перед запуском какой-то функции, и что так говорит. Что
[34:05.460 --> 34:10.500]  можно на самом деле использовать внутри программ, которая выполняется внутри ядра? Внутри ядра вы
[34:10.500 --> 34:15.820]  не можете использовать стандартную seed библиотеку, вы не можете использовать произвольные системные
[34:15.820 --> 34:25.620]  вызовы. Вы можете использовать только какое-то ограниченное количество функций, которые доступны из
[34:25.620 --> 34:34.500]  контекста BPF. Полный перечень всех этих функций перечислен в седьмом разделе мана BPF Helpers.
[34:34.500 --> 34:41.820]  Так, закрываем man на BPF, надеюсь, он нам больше не пригодится, а вот BPF Helpers. Это список всех
[34:41.820 --> 34:49.700]  функций для текущей версии ядра, которые можно использовать. Функций на самом деле достаточно много,
[34:49.700 --> 35:01.020]  и вы можете делать разные полезные программы. Например, вы можете что-то выводить на экран того
[35:01.020 --> 35:07.580]  логика, который у вас выполняет трассировку перерез программы. Примерно, вы можете выяснить
[35:07.580 --> 35:17.780]  процесс ID и какая-то программа, которая у вас выполняет некоторый код. Давайте
[35:17.780 --> 35:25.340]  скомпилируем теперь и загрузим некоторую программу. Эта программа находится так, выглядит следующим
[35:25.340 --> 35:41.660]  образом. Вот простенькая программа, написана на языке C. Давайте попробуем сделать такой же трюк.
[35:41.660 --> 35:54.220]  Target BPF, только скомпилировать, получить объектный файл, и вот эта вот функция. И тут получаем
[35:54.620 --> 36:04.860]  сколько ошибок. В самом деле, здесь нам что не хватает с точки зрения компилятора языка C,
[36:04.860 --> 36:11.180]  чтобы программа была корректной. Нам не хватают какие-то заголовочные файлы, где их искать.
[36:11.180 --> 36:20.300]  Если подключим какие-то заголовочные файлы, в которых объявлены типа данных U64, функции BPF,
[36:20.540 --> 36:28.620]  из принт K, что еще не хватает структ PT-REX, тогда, казалось бы, все хорошо, все замечательно.
[36:28.620 --> 36:36.700]  Слинковать мы это не сможем, хотя бы сможем скомпилировать. Где искать заголовочный файл,
[36:36.700 --> 36:44.420]  на самом деле ответ не очевиден. Можно взять исходники ядра и надергать заголовочный файл из
[36:44.420 --> 36:51.820]  исходников ядра. Затем все это скомпилировать, ну и получить какую-то программу, хорошо,
[36:51.820 --> 37:00.860]  станет немножко лучше. Вручную это можно сделать, но жутко неудобно, трудозатратно. И одна из причин,
[37:00.860 --> 37:07.820]  почему все-таки система вызов BPF не имеет сишной оболочки. Потому что это не очень осмысленно,
[37:07.820 --> 37:15.620]  никто вручную для BPF не пишет. Есть высокоуровневые фреймворки, есть библиотека ЛИП-BPF для
[37:15.620 --> 37:25.260]  использования высокоуровневого образа этого системного вызова. Есть еще боевоскоронний способ.
[37:25.260 --> 37:45.220]  Так, apothecary search. Есть пакет под названием BPF compiler collection,
[37:45.220 --> 37:53.860]  реализованный для языка питон, как ни странно. Поэтому мы можем взять питон,
[37:53.860 --> 38:06.220]  что-нибудь наклепать даже в терминале и загрузить нашу BPF программу. Итак, давайте сделаем следующую
[38:06.220 --> 38:12.460]  функциональность. У нас есть какая-то произвольная программа, в которой выполняется какая-то
[38:12.460 --> 38:18.540]  произвольная функция. Может выполняться в произвольном моменте времени. И наша задача
[38:18.540 --> 38:26.540]  отловить все ситуации, когда мы вызываем какую-то произвольную функцию, используя механизм extended
[38:26.540 --> 38:36.980]  BPF. Сначала нам нужна какая-то программа, которая что-то делает. Программа, программа, программа тоже
[38:36.980 --> 38:45.980]  тупая, тривиальная. Выглядит следующим образом. Функция main, которая сообщает свой пит,
[38:45.980 --> 38:52.460]  чтобы мы могли к чему-то подключиться. Дальше на каждое нажатие клавиши ввод просто вызывает
[38:52.460 --> 38:59.140]  некоторую функцию, и эту ситуацию нам нужно уметь отловить. Программа совершенно дурацкая,
[38:59.140 --> 39:06.860]  учебная. В реальной жизни, на самом деле, вам может понадобится поставить трассировку на уже
[39:06.860 --> 39:12.940]  работающий код для совершенно произвольной программы. И то, что вам сейчас показывал в
[39:12.940 --> 39:20.180]  качестве модельной ситуации, на самом деле можно применять на практике. Какая-то программа у нас
[39:20.180 --> 39:27.940]  скомпилирована, исполняемый файл сам программ. Соответственно, в этом сам программ, в таблице
[39:27.940 --> 39:39.940]  символов, можно найти какую-то функцию, которая называется some function, находится в секции текста.
[39:39.940 --> 39:46.580]  Ладно, запустим нашу программу, сам программ. Вот она работает, вот на каждое нажатие клавиши
[39:46.580 --> 39:53.140]  ввод говорит I'm some function, которая вызывает функцию some function. Программа уже работает,
[39:53.140 --> 40:05.140]  я ее не запускаю. Ну и задача использовать инструменты BPF. Для этого понадобится Python.
[40:05.140 --> 40:17.220]  Итак, from bcc, вот ссылочка, iuether.org, не знаю, что за организация, но она не запрещена,
[40:17.220 --> 40:26.580]  поскольку не является экстремисткой. Итак, from bcc, import, что-нибудь, достаточно только BPF.
[40:26.580 --> 40:43.940]  Так, дальше у меня есть некоторый файл, который находится в файле trace some function. Вот
[40:43.940 --> 40:50.420]  некоторые программы написаны на языке C, которые нужно скомпилировать в код BPF и загрузить.
[40:50.420 --> 41:01.700]  И желательно сделать это с минимальными телодвижениями. Окей, мы просто берем этот текст программы.
[41:01.700 --> 41:09.700]  Как нам прочитать текст программы? Очень просто. Мы вызываем функцию... Да, сейчас я показываю
[41:09.700 --> 41:15.300]  некоторый код, который на самом деле не является чистым кодом с точки зрения языка Python,
[41:15.300 --> 41:22.620]  просто по той причине, что я это набираю в терминале и хочу минимизировать количество нажатия на кнопочки.
[41:22.620 --> 41:31.340]  Итак, open, естественно, писать inline это очень плохо. Лучше, конечно, писать в конструкции viz,
[41:31.340 --> 41:47.900]  open, sf, дальше какие-то блоки. Так, trace some function. По цветам, кстати, видно что-нибудь?
[41:47.900 --> 41:58.060]  По идее должно быть. Так, trace some function. Читаем, тут же открыли файл, прочитали,
[41:58.060 --> 42:07.500]  и скормили. Все, в некотором BPF. Вот мы создали некоторую программу BPF, которая успешно скомпилировалась.
[42:07.500 --> 42:20.220]  Давайте смоделируем ситуацию, когда программа у нас не скомпилируется, потому что всякое в жизни
[42:20.380 --> 42:31.020]  бывает. Например, вот у вас программа, которая, во-первых, она компилируется. Давайте сделаем что-нибудь
[42:31.020 --> 42:42.780]  противное, например, она не может компилироваться. В этом случае получаем ошибку компиляции именно
[42:42.780 --> 42:50.100]  при попытке создать объект BPF из некоторого нелегального текста. Так, что мы еще можем сделать?
[42:50.100 --> 43:01.780]  Мы можем программу сделать корректной с точки зрения синдекса EGSI, но содержащую некорректный код,
[43:01.780 --> 43:14.700]  поскольку эта программа содержит бесконечный цикл. Она хотя бы скомпилировалась, но где-то на дальнейшем
[43:14.700 --> 43:19.580]  шаге. Ладно, мы скомпилировали программу, которая содержит цикл while true. Сейчас мы
[43:19.580 --> 43:27.420]  запихаем в ядро. Давайте попробуем что-то с этим сделать. У нас есть некоторая программа,
[43:27.420 --> 43:34.180]  которой мы хотим прикрутить трассировку вызова функций. Более того, эта программа у нас уже работает,
[43:34.180 --> 43:49.740]  мы знаем ее процесс ID. Прикрепляем теперь код, который мы загрузили в ядро, точнее тут отложенная
[43:49.740 --> 44:02.380]  загрузка в ядро в этом фреймворке. И нам нужно подключиться к некоторой функции, а чтобы знать
[44:02.380 --> 44:09.380]  некоторые функции, нам нужно загрузить эту функцию из... нам нужно знать адрес этой функции,
[44:09.380 --> 44:14.260]  чтобы знать адрес функции, нам нужно посмотреть на объектный файл. Поэтому нам нужно все-таки
[44:14.260 --> 44:29.980]  скормить этот файл. Так, мы находимся где... рановато я начал что-то писать. Надо еще написать
[44:29.980 --> 44:48.860]  import OS, gcvd. Так, имя программы. Соответственно, это... берем текущий каталог, slash, sum,
[44:48.860 --> 45:04.460]  программ. Так, что нам нужно знать еще? Нам нужно знать название функции,
[45:04.460 --> 45:23.460]  которые мы хотим подключиться. Я забыл название, поэтому... подсмотрю в исходном файле. Название
[45:23.460 --> 45:34.140]  функции было sum func. Точнее, тут не важно, что за программа, это может быть произвольный символ.
[45:34.140 --> 45:50.460]  Так, ну и теперь прикрепляем нашу загруженную программу, используя функции. Так, name. Это
[45:50.460 --> 46:02.300]  название программы, чтобы выяснить адрес. Так, символ. Это название функции. Так, что еще нам
[46:02.300 --> 46:14.020]  нужно знать? Нам нужно знать процесс ID. И у нас есть некоторая программа, которая может содержать
[46:14.020 --> 46:25.060]  несколько функций в одном исходном тексте. Соответственно, нужно еще указать, какую именно функцию мы
[46:25.060 --> 46:34.540]  используем. Так, вроде ничего не забыл. Вот здесь вот происходит как раз ошибка, что на уровне ядра мы не
[46:34.540 --> 46:44.460]  можем загрузить программу BPF. Здесь на питоне мы получаем ошибку, инвалид-аргумент. Прям в точности,
[46:44.460 --> 46:52.180]  что нам выдал системный вызов P-error. Если более детально разбираться, а что у нас произошло,
[46:52.180 --> 47:03.660]  а произошло у нас вот что. Go to PC-1. Так делать нехорошо. Ну ладно, давайте мы берем все-таки вот эту
[47:03.660 --> 47:09.460]  каку. Оставим честную программу, которая гарантированно завершается за фиксированное время.
[47:09.460 --> 47:18.820]  Чем нравится консольный питон, вы можете стрелочками вверх-вниз. Только это IPython,
[47:19.380 --> 47:26.820]  повторить все итерации заново. Все, мы теперь честно загрузили программу, скомпилировали ее
[47:26.820 --> 47:36.860]  в нативный код уже внутри ядра и подключили к событию под названием вызов какой-то функции по
[47:36.860 --> 47:43.940]  определенному адресу для процесса с указанным процессом ID. Ну окей, давайте теперь смотреть,
[47:43.940 --> 47:56.180]  что у нас происходит. Ага, происходит у нас permission denied. Почему? Ну потому что у нас есть
[47:56.180 --> 48:03.980]  куча разных процессов. Как-то очень странно разрешать произвольному процессу. Вот так взять
[48:03.980 --> 48:13.300]  просто и подключиться к другому процессу. Посмотреть, что он там вытворяет. Так делать
[48:13.300 --> 48:20.860]  нехорошо. Что для этого нужно, чтобы иметь такую возможность? Нам нужны права бога. В принципе,
[48:20.860 --> 48:29.100]  можно навешать на питон кучу разных capabilities, но зачем произвольному интерпретатору питон?
[48:29.100 --> 48:38.340]  Давайте один раз безопаснее как раз запустить что-то из подрута. Так, ладно, повторяем всю
[48:38.340 --> 49:07.540]  эту итерацию. From VCC import BPF. Загружаем программу. Trace some func. BPF attach
[49:07.540 --> 49:28.740]  view probe к файлу. Так. Приходится, к сожалению, повторять некоторые действия. Some program,
[49:28.740 --> 49:54.340]  symbol some func и fname trace some func. И process ID, самое последнее, вот этот вот. Так, подключили.
[49:54.340 --> 50:05.740]  Ну и смотрим, что у нас происходит. Так, ладно. Понял, что в нашей программе вызов
[50:05.740 --> 50:12.180]  функции происходит каждый раз, когда нажимаем кнопочку вот. Нажимаем. И, честно, для произвольного
[50:12.180 --> 50:20.900]  процесса получаем вывод о том, что у нас есть вызов какой-то функции. В принципе,
[50:20.900 --> 50:29.140]  вот это можно сделать и отладчиком ГДБ, но чем плохо отладчик ГДБ? Он каждый раз должен
[50:29.140 --> 50:36.300]  остановить программу, должен посылать сигналы разрешения на продолжить выполнение. Это работает
[50:36.300 --> 50:43.660]  медленно. BPF, в отличие от отладчика, работает прямо в ядре и генерирует какие-то новые события,
[50:43.660 --> 50:54.660]  за которыми мы теперь можем наблюдать. Так, что мы можем делать? Вот я сейчас набирал
[50:54.660 --> 51:04.740]  загадочные слова по названиям uProp после слова attach. У нас есть разные виды функций. Это функции,
[51:04.740 --> 51:12.340]  которые реализованы в пространстве пользователя, то есть выполняются в юзерленде процесса. Здесь
[51:12.340 --> 51:18.100]  можем наблюдать за событиями входа в функцию, за событиями завершения работы функции. Кстати,
[51:18.100 --> 51:25.780]  для чего это может быть полезно? Например, измерить время выполнения функций. То же самое
[51:25.780 --> 51:33.180]  можно сделать на уровне функции ядра. В чем принципиальная разница? Функции ядра все-таки это
[51:33.180 --> 51:43.380]  более чувствительная штуковина. И здесь мы для юзерленд знаем текущий процесс ID,
[51:43.380 --> 51:50.340]  для функций ядра нам придется разбираться самостоятельно. Еще один use case, для чего нам
[51:50.340 --> 52:01.460]  может понадобиться трассировка входа в функцию и выхода из функции. Это, например, запомнить время,
[52:01.460 --> 52:07.220]  когда мы начали выполнять какую-то функцию и посмотреть на время, когда мы закончили выполнять
[52:07.220 --> 52:15.420]  функцию. Для чего? Чтобы вычесть из одного другое и тем самым узнать время выполнения функции. Для этого
[52:15.420 --> 52:22.740]  нам нужно где-то хранить промежуточные значения. Поскольку у нас события возникают в произвольный
[52:22.740 --> 52:28.980]  момент времени, они должны быть самодостаточными, то просто взять и завести какую-то глобальную
[52:28.980 --> 52:34.660]  переменную, у вас уже не получится. У вас все-таки код должен быть самодостаточным. Если я попытаюсь,
[52:34.660 --> 52:40.940]  или вы попытаетесь скомпилировать код, который содержит обращение к статическим переменным,
[52:40.940 --> 52:47.820]  то у вас этот код будет отвергнут на стадии загрузки, он не будет валидным. Единственный
[52:47.820 --> 52:53.940]  способ использовать что-то для перистензийного хранения, это использовать механизм по названиям
[52:53.940 --> 53:01.100]  BPF maps. Название на самом деле не очень удачное, это обобщение для всех любых произвольных контейнеров.
[53:01.100 --> 53:08.700]  Это могут быть не только словари, так слово map соответствует в английском языке, но также произвольные
[53:08.700 --> 53:15.540]  массивы, произвольные таблицы. Просто исторически называется слово maps. Как сделать
[53:15.540 --> 53:32.140]  замер времени работы какой-то функции. Следующий пример, это уже две функции. Одна функция выполняется
[53:32.140 --> 53:39.780]  в начале выполнения, другая в конце. В начале выполнения мы берем текущее время выполнения и
[53:39.780 --> 53:46.860]  сохраняем в некоторую хэш таблицу, в некоторый словарь, используя в качестве ключа процесс ID.
[53:46.860 --> 54:00.220]  При завершении работы функции мы берем текущее время, вытаскиваем из словаря значение по ключу
[54:00.220 --> 54:08.300]  процесс ID, вычисляем значение и тем самым мы знаем, как долго выполнялась наша функция. Для этого нам
[54:08.300 --> 54:13.580]  требуется некоторая структура данных под названием BPF hash, которая хранит промежуточный результат.
[54:13.580 --> 54:28.740]  Давайте сделаем теперь то же самое. Загрузим теперь код из этого файла.
[54:28.740 --> 54:56.420]  Делаем теперь два пробочка событий. AtachuProp. Нам нужна функция,
[54:56.820 --> 55:10.980]  которая выполняется в самом начале. Функция называется startTracing.
[55:10.980 --> 55:24.900]  Просоединили и еще нам нужна функция на конец трассировки.
[55:24.900 --> 55:43.820]  Теперь наблюдаем. Несколько нажатик клавиш. Время работы каждой функции варьируется,
[55:43.820 --> 55:50.660]  поскольку это астрономическое время. Оно всегда может быть разным и зависит от кучи разных условий.
[55:50.660 --> 56:05.060]  Что еще можно полезного извлечь с помощью Berkeley Packet Filter.
[56:05.060 --> 56:16.260]  Код хороший, потому что проверяет все возможные ошибки. В начале момента времени, когда мы заходим в
[56:16.260 --> 56:23.500]  функцию, мы в некоторую hash таблицу добавляем значение с ключом protos ID. В общем случае,
[56:23.500 --> 56:32.980]  мы могли этого и не делать. Что произойдет, если я не буду делать проверку, если у нас значение в словаре
[56:32.980 --> 56:38.180]  или нет. Казалось бы, это должна быть ошибка выполнения, в том случае, если мы действительно не
[56:38.180 --> 56:45.060]  вызвали startTracing. Если вызвали, хорошо, если не вызвали, ну какое-то ОБ. Так вот, на самом деле,
[56:45.060 --> 56:51.380]  с точки зрения верификатора BPF, программа, для которой не будет существовать вот такого кода,
[56:51.380 --> 56:59.100]  она будет некорректной. То есть верификатор, штука достаточно умная, он видит, что мы делаем
[56:59.100 --> 57:06.460]  обращение какому-то глобальному словарю, возможно, мы не получим корректный результат. Если вы не
[57:06.460 --> 57:12.260]  обрабатываете ошибки, и верификатор это видит, что вы не обработали случаи отсутствия элемента,
[57:12.260 --> 57:18.620]  то он скажет ай-ай-ай, так нельзя, и откажется загружать некорректную программу в ядро операционной
[57:18.620 --> 57:32.900]  системы. Еще из полезных штук, мы можем отлавливать разные системные вызовы. Вот это уже огонь штука.
[57:32.900 --> 57:44.500]  Системные вызовы, для чего нам может понадобиться отлавливать. Пример, что на низком уровне ловить
[57:44.500 --> 57:53.100]  все то, что реализовано даже не на уровне стандартной символиотеки, в том числе с использованием
[57:53.100 --> 57:58.340]  каких-нибудь изколов, программ, написанных на ассемблере и так далее. Настанавливаю программу,
[57:58.340 --> 58:03.180]  которая мне уже не нужна. Останавливаю трассировщик, который уже тоже не нужен.
[58:03.180 --> 58:16.660]  Пример программы не нужен, потому что у меня есть интерпретатор Bash, который просто работает,
[58:16.660 --> 58:28.900]  и можно навесить трассировку на какую-нибудь функцию, которую Bash заведомо может выполнить,
[58:28.900 --> 58:41.940]  например, системный вызов exec. Итак, программа, которая это делает. Система вызов exec
[58:41.940 --> 58:53.780]  просто проверяет, что если мы выполняемся из программы под званием Bash, тогда говорим,
[58:53.780 --> 58:59.540]  что Bash пытается сделать exec. Если нет, сразу сделаем return null. Никого не смущает такая
[58:59.540 --> 59:07.940]  конструкция для проверки совпадения строк. Сравниваем нулевой символ, первый символ, второй,
[59:07.940 --> 59:13.660]  третий. Как бы вы в реальной жизни не поступили, вы бы, наверное, написали сравнение двух строк.
[59:13.660 --> 59:24.500]  Оператор 2 равно на C++, хорошо, функция str на Cmp на языке C. Почему я не могу это использовать?
[59:24.500 --> 59:31.660]  Потому что у нас нет стандартной библиотеки. Извините, приплыли. Поэтому приходится немножко
[59:31.660 --> 59:54.100]  извращаться. Здесь программу перезагрузить. Файл назывался trace his call. Загружаем и
[59:54.260 --> 01:00:07.260]  подключаем к событиям ядра. Что подключиться к событиям ядра? Тут есть одна хитрость,
[01:00:07.260 --> 01:00:15.820]  а именно события. Это вызов какой-то функции ядра. Какая функция ядра отвечает за то,
[01:00:15.820 --> 01:00:29.980]  чтобы вызвать систему вызов exec ve? Если вы скажете, что функция называется sys exec ve,
[01:00:29.980 --> 01:00:41.220]  возможно, вы будете правы на архитектуре x86, но не на архитектуре ARM. Поэтому здесь
[01:00:41.220 --> 01:00:58.140]  придется применить некоторую дополнительную магию. Get syscallfname exec ve. Прицепляем функцию,
[01:00:58.140 --> 01:01:08.520]  которая называется в этом файле trace exec ve, которая просто проверяет, запущена она из баша. Если из
[01:01:08.520 --> 01:01:19.640]  баша, то говоришь, что баш попытался сделать exec. Если нет, ничего не делает. Анк known
[01:01:19.640 --> 01:01:32.840]  программ trace exec. Удачно подцепились. Давайте понаблюдаем за тем, что происходит. Откуда я
[01:01:32.840 --> 01:01:41.540]  могу запустить новый процесс с помощью exec? Например, я могу запустить minet commander.
[01:01:41.540 --> 01:01:50.940]  Ой, по глазам бьет. Синий цвет ужасный, дефолтный. Тем не менее, запуск minet commander это уже системный
[01:01:50.940 --> 01:01:59.420]  вызов exec. Как я могу выяснить, а что за параметры системы вызова exec? Давайте уберу это синий.
[01:01:59.420 --> 01:02:10.000]  У меня есть некоторый набор регистров. Соответственно, есть указатель. Я могу вытащить
[01:02:10.000 --> 01:02:17.720]  вовсе не строку. По указателю я не могу вытащить строку, не используя никаких специальных функций.
[01:02:17.720 --> 01:02:30.160]  Что такое системный вызов? Системный вызов – это переключение процессора в режим ядра. Соответственно,
[01:02:30.160 --> 01:02:34.480]  данные у вас где-то там остались в пространстве пользователя. Их нужно предварительно скопировать
[01:02:34.480 --> 01:02:40.880]  куда-нибудь к себе на стэк поближе. В принципе, можно сделать все что угодно и достучаться до
[01:02:40.880 --> 01:02:50.160]  любых параметров вашего системного вызова. В некоторых ситуациях вы можете захотеть не выполнять
[01:02:50.160 --> 01:02:56.640]  какой-то системный вызов при выполнении определенных условий. Например, команда ls – хорошая команда,
[01:02:56.640 --> 01:03:05.120]  хорошая безопасная. Команда rm – если вам не нравится, почему вам может не нравиться команда rm?
[01:03:05.120 --> 01:03:14.880]  Или rm с некоторыми опциями? Наверное, потому что rm-rf-slash писать нехорошо. Вы хотите сделать
[01:03:14.880 --> 01:03:21.840]  свою систему более безопасной и запретить запуске таких команд, в принципе, неважно,
[01:03:21.840 --> 01:03:27.560]  как вы их запускаете. Из Basha, из программы на C, или написанная программа на Assembler,
[01:03:28.520 --> 01:03:42.880]  вы хотите просто жестко запретить все подряд. На этот случай открываем наш bpf-helpers. Там есть
[01:03:42.880 --> 01:03:48.720]  такая замечательная функция под названием bpf-override-return.
[01:03:48.720 --> 01:04:02.520]  f-override-return, которая немедленно завершает системный вызов с некоторым
[01:04:02.520 --> 01:04:08.520]  переопределенным кодом возврата. Классная фича. Как мы можем эту факт теперь использовать?
[01:04:08.520 --> 01:04:17.920]  Мы можем взять теперь и запретить выполнять системный вызов, сразу вернуть код возврата 1 вместо 0.
[01:04:17.920 --> 01:04:26.560]  Есть система вызова exec. Хорошая идея. Почему опасно? Естественно, по-хорошему надо сделать
[01:04:26.560 --> 01:04:33.120]  проверки, что у вас команда такая. Это будет много кодов из-за таких особенностей. В принципе,
[01:04:33.120 --> 01:04:45.440]  это возможно, наверное. Давайте скомпилируем. Что случилось? Наверное, где-то...
[01:04:47.920 --> 01:05:08.680]  Так, почему перемешать Deny? Потому что backup как-то болтается.
[01:05:17.920 --> 01:05:34.360]  Так, trace искал подчеркнение 1, который в случае, если стема вызова выполняется программой
[01:05:34.360 --> 01:05:42.160]  под названием bash, выводит, что bash попытался выполнить стемный вызов exec и выполняется
[01:05:42.720 --> 01:05:48.320]  кодом возврата 1 вместо того, чтобы реально выполнить какой-то стемный вызов. Просто мы фильтруем и все.
[01:05:48.320 --> 01:06:03.680]  Так, ладно. Давайте загрузим эту нашу программку. Trace is called 1. Загрузилось. Подключаем. Получаем
[01:06:03.680 --> 01:06:11.720]  какую-то ошибку. Ошибка-то, ладно. Мы можем посмотреть лог. И вот в логе тут интересная фича
[01:06:11.720 --> 01:06:19.680]  написана. Программа у нас скомпилировалась, честно. Получили bytecode BPF. Если мы программу
[01:06:19.680 --> 01:06:27.320]  смогли скомпилировать, это означает, что все-таки мы не опечатались названием функции и с ее сигнатурой.
[01:06:27.320 --> 01:06:35.560]  Но на стадии верификации получаем вот такую интересную ошибку. unknown func BPF overwrite return.
[01:06:35.560 --> 01:06:43.400]  Это означает, что функция может либо присутствовать вашей системе, либо не присутствовать. От чего это
[01:06:43.400 --> 01:06:52.840]  зависит? Это зависит на самом деле от вашего ядра операционной системы. И даже нет версии. От того,
[01:06:52.840 --> 01:07:00.200]  как ваш ядро скомпилировано. Понятно, что если мы будем разрешать любому процессу произвольно
[01:07:00.200 --> 01:07:05.640]  вмешиваться, вытворять все что угодно. Наверное, есть какие-то use-кейсы, когда это полезно,
[01:07:05.640 --> 01:07:11.160]  но по умолчанию это, наверное, все-таки не очень безопасно. Поэтому по умолчанию возможность
[01:07:11.160 --> 01:07:19.640]  модификации результатов системных вызовов у нас запрещена. И вообще, механизм BPF по умолчанию
[01:07:19.640 --> 01:07:28.520]  работает со всеми данными только в режиме read only. Он не может подменить данные системных вызовов,
[01:07:28.520 --> 01:07:36.320]  то есть значение регистров, еще что-нибудь. Он не может подменять код возврата из системных вызовов.
[01:07:36.320 --> 01:07:44.240]  Как это поправить? На самом деле поправить это можно, если внимательно почитать MAN на эту функцию.
[01:07:44.240 --> 01:07:55.000]  Вот есть такой конфиг в ядре. Давайте его проверим. Конфигурация, с которой собрано текущее ядро,
[01:07:55.000 --> 01:08:06.960]  находится обычно в файле slash-boot, slash-config и название версии через defis, текущая версия ядра.
[01:08:06.960 --> 01:08:16.960]  Если вы давно пользуетесь системой, у вас там может быть несколько ядер, но uname-r позволит вам вернуть
[01:08:16.960 --> 01:08:27.360]  нужное ядро. Вот куча конфигов. Грепаем нужную нам строчку. Получаем, что в нашем ядре действительно
[01:08:27.360 --> 01:08:44.200]  BPF отключена возможность подменять результаты системных вызовов. Ладно, заходим в исходники ядра,
[01:08:44.200 --> 01:09:08.760]  make, menu, config. Экран слишком маленький для меню конфига. Ничего вам от него не напоминает.
[01:09:08.760 --> 01:09:19.280]  Собирали когда-нибудь ядро ручками? Ладно, самое время научиться. Make, menu, config. Дальше вы
[01:09:19.280 --> 01:09:29.240]  долго упорно лазите по конфигу ядра. На самом деле очень залипательная штука. Нам нужен кернел-хакинг,
[01:09:29.240 --> 01:09:36.440]  наверное. Кернел-хакинг, а может не кернел-хакинг, где-то в другом, кернел-дебаггин-энструментс.
[01:09:36.440 --> 01:09:42.760]  Нет, не кернел-дебаггин-эн инструментс. Короче, можно порыться по менюшке. Еще можно
[01:09:42.760 --> 01:09:53.400]  найти нужный вам файл под названием kconfig. После того, как он был со... Нет, не kconfig.
[01:09:53.400 --> 01:10:14.720]  Тежа конфигурация хранит. Точка конфиг. И прописать нужные вам параметры прямо сюда.
[01:10:14.720 --> 01:10:31.040]  Прописать. Кто любит редактор NaNo? Как там поиск реализован? В подсказке есть только replace.
[01:10:31.040 --> 01:10:47.480]  Так, ищем вот эту вот bpf-kprobe. Not found. Ладно, тупо вставим куда-нибудь.
[01:10:47.480 --> 01:11:00.760]  config bpf-kprobe override. Так, вроде не опечатывался. В всякий случай сделал копипасту.
[01:11:00.760 --> 01:11:14.000]  Так, сохраняем, выходим. Ну и дальше собираем ядро. Ладно, на этом пару можно закончить. Ядро будет
[01:11:14.000 --> 01:11:21.040]  собираться очень долго. Но у меня не с нуля, но я уже начинал это делать, но все равно это будет
[01:11:21.040 --> 01:11:28.240]  долго. В общем, давайте резюмируем, что такое bpf, для чего он нужен. Bpf прикольная штука,
[01:11:28.240 --> 01:11:33.840]  если вы можете подсматривать в произвольной функции, в произвольной процессе. Если вы
[01:11:33.840 --> 01:11:40.360]  можете подсматривать в произвольной функции на уровне ядра, вы можете фильтровать какие-то
[01:11:40.360 --> 01:11:48.360]  пакеты. Что вы можете из этого сделать, используя такой базовый инструментарий? Вы можете сказать
[01:11:48.360 --> 01:11:53.680]  все что угодно про любую программу. Дальше возможно использовать какие-то сторонние инструменты,
[01:11:53.680 --> 01:12:00.760]  обычный системный вызыв Kill, Petrace, заниматься чем-то остальным. Вот я уже давал ссылку на
[01:12:00.760 --> 01:12:09.040]  гугловский репозиторий по названию NSJL. Если вы увлекаетесь безопасностью или прочими с
[01:12:09.040 --> 01:12:14.360]  анбоксингами, посмотрите, прикольная штука. Вот он как раз использует в том числе eBPF,
[01:12:14.360 --> 01:12:20.920]  чтобы мониторить, что в системе происходит. Но фильтрация, естественно, уже другим способом.
[01:12:20.920 --> 01:12:30.160]  Так, ну и если вы видите какую-то картинку на экране, то значит лекция закончилась,
[01:12:30.160 --> 01:12:39.320]  я не буду писать подпись, что это нарисовано и что нейросетка взяла за основу. Ну да,
[01:12:39.320 --> 01:12:44.160]  у нас законы такие, что не все теперь можно писать. Ладно, на этом все.
