[00:00.000 --> 00:12.880]  Начало, ну да, это будет пункт 14.6, кажется, нашей программы, да, потому что 45 это была реализация
[00:12.880 --> 00:29.320]  function. Значит, std вариант и его реализация. Сейчас будет весело. Ну, это повеселее, чем function
[00:29.960 --> 00:36.120]  Зачем он нужен-то? Сейчас, подожди, сейчас мы посмотрим, как его используют.
[00:36.120 --> 00:56.920]  У нас был union до этого. Вот, и мы поняли, что union позволяет хранить несколько объектов на одном
[00:56.920 --> 01:06.160]  и том же участке памяти, вероятно, меняя один на другой. Вот, ну, вариант это более умный union,
[01:06.160 --> 01:12.640]  по сути. Ну, то есть, это такой тип, который позволяет вам хранить одно из перечисленного,
[01:12.640 --> 01:22.240]  и при этом он безопасен в том смысле, что вы, вы либо правильно обратитесь к нему,
[01:22.240 --> 01:35.680]  либо уж у вас исключение выйдет. Конечно, если ты, мы в прошлый раз видели, что у нас был union
[01:35.680 --> 01:42.760]  с int, мы начали ему строку присваивать, и было secul. Значит, вариант появился только c++17,
[01:42.760 --> 01:54.760]  и там, ну, нет, в принципе, не было больших препятствий, чтобы он появился раньше. Мы
[01:54.760 --> 01:59.800]  прямо будем использовать некоторые фишки c++17 в его реализации. Ну, вот, ну, давайте,
[01:59.800 --> 02:10.120]  для примера я что-нибудь заведу, int, запятая double, запятая std string. Вот, вот я завел вариант.
[02:10.120 --> 02:19.840]  Так, сейчас я сразу же буду это пытаться компилировать.
[02:19.840 --> 02:40.880]  Не, не, не, мы стараемся переходить на c++20. Вот, ну да, конструктор по умолчанию сработал,
[02:40.880 --> 02:46.120]  это значит, что он принципизировал первый, скорее всего. Но я могу написать вот так,
[02:46.120 --> 02:56.200]  потому что я не помню наизусть, что он делает, я же вас тоже не заставляю помнить, как конструкторе
[02:56.200 --> 03:05.520]  что делает. Вот, ну, я могу пронициализировать его любым типом из перечисленных. Вот,
[03:05.520 --> 03:09.520]  могу пронициализировать его пятеркой, тогда в нем будет храниться им. В том числе,
[03:09.520 --> 03:15.800]  можно пронициализировать его abc и потом что-нибудь еще, и оно само сотрется. Да, да. Вот, ну,
[03:15.800 --> 03:22.160]  давайте, я попробую обратиться к тому, что в нем лежит. Вот, я могу сказать, чтобы обратиться
[03:22.160 --> 03:38.480]  к варианту, есть функция get, std get. Ну, как с tuple? Есть get по типу и get по индексу. Нет,
[03:38.560 --> 03:44.720]  разные функции, одна для tuple, другая для варианта. Но для варианта, как мы делаем? Я говорю,
[03:44.720 --> 04:00.760]  get int от v. Ну, давайте, я попрошу вывести, что будет. Мне сейчас выведут 5. Вот, но если я
[04:00.760 --> 04:10.720]  попробую сделать get не от int, а от, скажем, чего-нибудь другого, от double, например. Сейчас
[04:10.720 --> 04:19.960]  будет exception, потому что там не double на самом деле. Вот, exception, badVariant, access. WrongIndexForVariant.
[04:19.960 --> 04:28.000]  Ну, ладно, я могу положить туда что-нибудь другое, например, строку.
[04:28.000 --> 04:48.640]  Чудесным образом вариант поймет, что ему подходят, ну вот, что из трех возможных вариантов,
[04:48.640 --> 04:54.360]  что он мог бы проницилизировать, самый подходящий это проницилизировать строку. По сути, здесь
[04:54.360 --> 05:00.280]  применяются те же правила, которые при разрешении перегрузки применяются. А у него,
[05:00.280 --> 05:07.080]  он сейчас звездочка справа, а надо выбрать, что это такое, int, double или std string. Ну вот,
[05:07.080 --> 05:14.840]  он выберет std string, так что теперь там будет std string. Разумеется, я могу после этого сказать там,
[05:14.840 --> 05:24.760]  не знаю, что-нибудь еще, там 3.0, и он выберет значит double. Вот давайте я, кстати, нет, если я так
[05:24.760 --> 05:32.280]  напишу, то это будет непонятно. Сейчас, как бы мне сделать? Давайте я скажу, что у меня не double,
[05:32.280 --> 05:37.560]  а float, но я сейчас классический пример хочу с неоднозначностью. То есть, если вот я ему скажу,
[05:37.560 --> 05:46.360]  у него там тип float, а я ему попробую double прислоить. Вот. Вероятно, он сейчас скажет,
[05:46.360 --> 06:03.240]  что неоднозначность очень всё понятно, конечно, да. Ну, это ce или это? Ce, конечно, да. Ну,
[06:03.240 --> 06:15.120]  возможно, ce-lang что-нибудь более приятное скажет. Vibe overloaded. Да, ну, значит, не получается.
[06:24.920 --> 06:30.920]  Да, ну, в общем, не смог он. Видимо, по какой-то другой причине, но так или иначе не смог.
[06:30.920 --> 06:40.760]  Вот. Ну, вот если я ему бы сказал здесь double, а попробовал присвоить float,
[06:40.760 --> 06:49.400]  то сейчас-то он, наверное, смог, я надеюсь. Да, вот так вот. Ну, там, на самом деле, просто у него
[06:49.400 --> 06:54.920]  налевешено шаблонных всяких enable fov и прочего, что-то включает, если там не может,
[06:55.920 --> 07:01.400]  но по сути, это работает при разрешении перегрузки. Вот сейчас он double содержит.
[07:01.400 --> 07:11.920]  Есть ещё такая функция holds alternative. Сейчас, как это мы не говорим,
[07:11.920 --> 07:20.920]  я немного вперёд забежал и сделаю стд вариант. Давайте посмотрим на preference.
[07:20.920 --> 07:30.520]  Значит, вот такая функция holds alternative. Она просто позволяет вам проверить, правда ли,
[07:30.520 --> 07:43.240]  вариант содержит то, что вы думаете. Верно ли, что он держит что-то похожее на double? Нет,
[07:43.240 --> 07:50.840]  верно ли, он держит либо int, либо double, либо string. Одно из трёх. Это буль, который вперёд, правда,
[07:50.840 --> 08:04.840]  потому что он double держит? Да, да, да. Почему alternative? Ну, потому что... Ну, стд holds звучало бы, как будто не очевидно, что это именно варианты можно применить.
[08:04.840 --> 08:15.840]  Ну, и вот такая, что он назвает. Какой из альтернатив сейчас имеет место? Альтернативы три, но сейчас будет один,
[08:15.840 --> 08:30.840]  то есть это пронициализировалось double. Он решил, что это double. Если бы я так сделал, то, разумеется, был бы false, потому что в нём лежала бы строка.
[08:30.840 --> 08:43.840]  Ну, и я могу легко, значит, забрать у него строку. Кстати, я могу вот что сделать. Я могу сказать std get, но я тебе скажу,
[08:43.840 --> 09:02.840]  автор s равно std get от std string от std move от v. Как мы любим. Вот, что произойдёт? Ну, он заберёт у него строку, просто move нет из варианта строку,
[09:02.840 --> 09:17.840]  в варианте останется пустая строка, а у нас будет настоящая строка. То есть это будет std get. Да, get он перегружен для lvalue, lvalue как полагается.
[09:17.840 --> 09:32.840]  То есть, если мы вызываемся от lvalue ссылки на вариант, он возвращает нам, ну, возвращает нам немножко странный тип варианта,
[09:32.840 --> 09:43.840]  не важно, что это такое, но для нас важно, что он, по сути, возвращает нам ссылку на t и lvalue ссылку. Значит, мы её скопируем, если будем так инициализировать.
[09:43.840 --> 09:52.840]  А вот если мы от lvalue варианта вызвались, то он вернёт нам lvalue ссылку. Соответственно, мы сейчас соберём у него строку, и можно проверить, что...
[09:52.840 --> 10:09.840]  Ну, давайте я проверю std seout s.length и ещё проверю std get, std string. Вот, v.length.
[10:09.840 --> 10:23.840]  А, правда ли, что мы можем выяснить? А в temp test это нормальный ловень? Нет, потому что lvalue есть ссылка. В смысле, если std loop есть, вот просто at temp test, то это даёт нам ссылку на его string.
[10:23.840 --> 10:32.840]  Да, если бы мы его сделали, а потом поменяли бы string на что-то другое, всё сломалось бы. Боюсь, что нет, потому что мы получили std вариант альтернатив.
[10:33.840 --> 10:37.840]  Скорее всего, вариант альтернатив хранит именно тип просто.
[10:37.840 --> 10:44.840]  Хранит, то он хранит, только... 100. А, вариант альтернатив t. Да-да-да, всё нормально, всё нормально было бы, всё нормально.
[10:44.840 --> 10:51.840]  Вариант альтернатив t – это type name, вариант альтернатив type, а type там прописан так, как надо, очевидно. То есть это должно нормально работать.
[10:51.840 --> 11:05.840]  Давайте проверим, что всё правильно, как я и думал. Вот, 5, 0, 5, 0. А, ну да, то есть я забрал у него 5, 0, это и раньше было, я забрал у него строку.
[11:05.840 --> 11:14.840]  Вот, теперь моя строка имеет длину 5, а та строка, которая в варианте лежит, имеет длину 0, потому что из неё будет.
[11:15.840 --> 11:26.840]  Вот. Ну, в общем-то... Можно ли хранить ссылку на объект, который там лежит? Можно, она сломается, когда ты поменяешь тип, видимо.
[11:26.840 --> 11:37.840]  Ну да. Логично. И вернётся в нормальный стандарт. Что если я в качестве альтернатива хранил вариант, у которого удалён move-оператор? Это будет...
[11:37.840 --> 11:44.840]  Не, ничего, если ты... В смысле, RG. Ну, если я пытаюсь его move-нуть, он же не сможет понять, что это ошибка компиляции.
[11:44.840 --> 11:47.840]  Ещё раз. Не сможет понять.
[11:47.840 --> 11:54.840]  Если у меня одним из вариантов структура, у которой запрещен move-ующий оператор. А я написал вот такую строчку.
[11:54.840 --> 12:03.840]  Да. Он просто пойдёт... Он должен отстанцировать шаблон, и в момент отстанцирования увидит, что нету оператора. Конечно же, это будет C, а не RG.
[12:03.840 --> 12:09.840]  Потому что он уже знает, что я к стрингу пытаюсь отставать.
[12:09.840 --> 12:14.840]  Да, потому что вот здесь ты делаешь к стрингу от V.
[12:14.840 --> 12:19.840]  А почему это будет C? Если же нет move-а конструктора, то конструктор копирования будет.
[12:19.840 --> 12:23.840]  Если написать равно нелит, то он скажет, что нет.
[12:23.840 --> 12:24.840]  Да, хорошо.
[12:24.840 --> 12:30.840]  Если написать равно нелит, то это будет C. Ну да, понятно, если у вас нет move-а, но есть копия, а про move ничего нет, то это копирование.
[12:31.840 --> 12:36.840]  Нет, понятно, что это всё C. Такие вещи – это всегда ошибки компиляции. Такие вещи не бывают в runtime. Ошибками не победают.
[12:36.840 --> 12:38.840]  Повторить какие вещи.
[12:38.840 --> 12:39.840]  Какие вещи?
[12:39.840 --> 12:40.840]  Ну...
[12:40.840 --> 12:41.840]  Что мы обсуждаем?
[12:41.840 --> 12:42.840]  Непонятно.
[12:42.840 --> 12:47.840]  Когда нету какого-то методового типа? Когда какой-то метод удалён?
[12:47.840 --> 12:50.840]  Он же формально удалён не у V, а у...
[12:50.840 --> 12:56.840]  У объекта. Это не важно. Не может вообще...
[12:56.840 --> 13:06.840]  В какой бы ситуации вы ни находились, чтобы вы не писали на плюсах, если у какого-то типа отсутствует какой-то метод, то это может привести либо к CE, либо...
[13:06.840 --> 13:10.840]  Ни к чему не привести. Не может отсутствия метода привести к RE.
[13:10.840 --> 13:18.840]  Отсутствие неличи методов – это compile-time понятие. В runtime-е не бывает такого, что что-то пошло не так, за то, что метода нет.
[13:18.840 --> 13:19.840]  Окей.
[13:19.840 --> 13:26.840]  Ну разве только это если pure-virtual-function-call, который лучше не вспоминать.
[13:26.840 --> 13:30.840]  Вот. Вы помните, что как pure-virtual-call?
[13:30.840 --> 13:33.840]  Помню, что как pure-virtual-call, как его позвать не помню.
[13:33.840 --> 13:35.840]  Ну ладно, не важно.
[13:35.840 --> 13:42.840]  Ну там типа прикол в том, что ты можешь описать определение этой индивидуальной функции и потом...
[13:42.840 --> 13:47.840]  Ну не важно. В общем, так. Ещё одна вещь, которую можно делать с вариантом... Да, ну...
[13:47.840 --> 14:02.840]  То есть, чё самое интересное про вариант? Он каким-то чудом, когда мы его инициализируем, он выбирает, какой из типов сейчас мы создали.
[14:02.840 --> 14:10.840]  Когда мы делаем ему присваивание, он удаляет правильно тот тип, который в нём сейчас лежит и...
[14:10.840 --> 14:11.840]  Конструирует.
[14:11.840 --> 14:14.840]  Конструирует новый, опять правильно выбирает каким-то образом...
[14:14.840 --> 14:15.840]  А если там...
[14:15.840 --> 14:17.840]  Какой тип мы сейчас у него создали?
[14:17.840 --> 14:21.840]  Если мы присваиваем такой, что он сейчас, он же не будет конструировать заново, он именно скопирует.
[14:21.840 --> 14:23.840]  Да, он присвоит, да.
[14:24.840 --> 14:25.840]  Удаляет.
[14:25.840 --> 14:28.840]  Сделает правильно всё.
[14:28.840 --> 14:30.840]  В смысле, он не будет уничтожать?
[14:30.840 --> 14:33.840]  Да, он... Ну как и есть.
[14:33.840 --> 14:35.840]  Он...
[14:36.840 --> 14:40.840]  Всё сделает, как будто там лежит реально строка просто.
[14:40.840 --> 14:43.840]  Да, как будто он просто тоже тип.
[14:43.840 --> 14:45.840]  А вот...
[14:47.840 --> 14:49.840]  Бла-бла-бла-бла-бла...
[14:49.840 --> 14:51.840]  Да, если...
[14:51.840 --> 14:56.840]  Ну, тут ещё есть случаи, когда у него ничего не лежит.
[14:56.840 --> 14:58.840]  Value is by exception.
[14:58.840 --> 15:05.840]  Это если вы пытались в него что-то сконструировать, а оно бросилось в включение и получилось, что в варианте ничего.
[15:05.840 --> 15:08.840]  Тогда он называется Value is by exception.
[15:08.840 --> 15:10.840]  Вот. Ну вот если...
[15:10.840 --> 15:13.840]  Бла-бла-бла... Короче, если правый...
[15:13.840 --> 15:20.840]  У правого такая же интернатива, как и у левого, то присваивает просто значение.
[15:20.840 --> 15:26.840]  А если выбраться в исключение, то он не становится value-less, а просто...
[15:26.840 --> 15:28.840]  Value зависит от...
[15:28.840 --> 15:30.840]  Ну, в общем, сложно.
[15:32.840 --> 15:34.840]  Давайте ещё одну интересную...
[15:34.840 --> 15:38.840]  Понятно, что когда он уничтожается, всё в конце правильно очищается.
[15:38.840 --> 15:42.840]  Ещё можно делать get по индексу, а не только по типу.
[15:42.840 --> 15:46.840]  Ну, как гостиупло, в принципе, get.
[15:46.840 --> 15:48.840]  Get по индексу.
[15:48.840 --> 15:50.840]  Size t.
[15:50.840 --> 15:52.840]  А...
[15:52.840 --> 15:55.840]  Значит, как это работает?
[15:55.840 --> 16:01.840]  Ну, просто вы говорите, я хочу взять и по альтернативу нумеровать с нуля.
[16:01.840 --> 16:06.840]  Аналогично, если вы не отгадали, то будет исключение вам.
[16:06.840 --> 16:12.840]  Вот. И что ещё есть интересного, это функция visit.
[16:12.840 --> 16:16.840]  Вот сейчас я сделаю, конечно, интересное дело.
[16:16.840 --> 16:19.840]  Смотрите, вот давайте я так поступлю.
[16:19.840 --> 16:22.840]  Вот давайте я заведу вектор вариантов.
[16:22.840 --> 16:29.840]  Давайте я скажу, что вот этот вариант, на самом деле, это у меня такой тип.
[16:29.840 --> 16:31.840]  Вариант t.
[16:31.840 --> 16:33.840]  Это вот такая вещь.
[16:33.840 --> 16:37.840]  А почему, кстати, get holds the iterative?
[16:37.840 --> 16:39.840]  Почему это всё внешние функции?
[16:39.840 --> 16:41.840]  Я чего-то не понимаю.
[16:41.840 --> 16:46.840]  Почему это не методы?
[16:46.840 --> 16:49.840]  Ну да, ну это типа очень странно.
[16:49.840 --> 16:55.840]  Почему не в.get, а из td.get, а из td.get?
[16:55.840 --> 16:59.840]  Не могу сходу ответить.
[16:59.840 --> 17:01.840]  Наверное...
[17:01.840 --> 17:05.840]  Синтексичнее тоже вполне возможно будет делать.
[17:05.840 --> 17:12.840]  Я думаю, что есть какая-то причина, но вот сейчас я её не могу назвать.
[17:12.840 --> 17:18.840]  Мне кажется, что там какие-то проблемы в реализации этого звала.
[17:18.840 --> 17:25.840]  Можно погуглить, а может быть, мы это позже поймём.
[17:25.840 --> 17:30.840]  Может быть, там была какая-то проблема, но я сейчас не могу моментально ответить.
[17:30.840 --> 17:34.840]  А может и нет, может, почему-то решили, что так лучше.
[17:34.840 --> 17:36.840]  Да.
[17:36.840 --> 17:38.840]  Сдвизит.
[17:38.840 --> 17:40.840]  Сдвизит.
[17:40.840 --> 17:44.840]  Так вот, смотрите, давайте я возьму sd-вектор из вариантов.
[17:48.840 --> 17:52.840]  Придётся мне назвать его vec от 5.
[17:52.840 --> 18:09.840]  И скажу, что vec0 это 4, vec1 это abc, vec2 это 3.0, vec3 это...
[18:09.840 --> 18:14.840]  Вообще, зачем я так делаю? Я же могу сказать вот так, я могу сказать, что это vec
[18:14.840 --> 18:16.840]  и пронициализировать следующим образом.
[18:16.840 --> 18:25.840]  3, abc, 5.0, abcde и ещё что-нибудь.
[18:25.840 --> 18:27.840]  Минус один.
[18:27.840 --> 18:29.840]  Что-то уже интересно.
[18:29.840 --> 18:31.840]  Упадёт.
[18:31.840 --> 18:33.840]  Может, double?
[18:37.840 --> 18:39.840]  Нет вектора.
[18:40.840 --> 18:46.840]  А, ну написано, потому что иначе пришлось бы писать x.template в мембрге.
[18:46.840 --> 18:50.840]  Ну да, да, да, да.
[18:50.840 --> 18:52.840]  Логично, логично.
[18:52.840 --> 18:54.840]  Да, это правда.
[18:54.840 --> 18:56.840]  А почему пришло это?
[18:56.840 --> 18:58.840]  Да у нас шаблоны нет.
[18:58.840 --> 19:00.840]  Потому что нет, это шаблоны.
[19:00.840 --> 19:05.840]  У него было бы можно знать, если оператор меньше, против этой штуки.
[19:05.840 --> 19:07.840]  Класс.
[19:08.840 --> 19:10.840]  Да, да.
[19:12.840 --> 19:14.840]  А в чём у нас CE там было?
[19:14.840 --> 19:16.840]  Никакого CE, просто вектор забыл заявить.
[19:16.840 --> 19:19.840]  Всё нормально, он создал вот такой вектор из вариантов.
[19:19.840 --> 19:21.840]  Смотрите, как классно.
[19:21.840 --> 19:26.840]  У нас вектор из пяти вариантов, и в каждом варианте разные типы.
[19:26.840 --> 19:28.840]  Теперь я хочу сделать следующее.
[19:28.840 --> 19:38.840]  Я хочу вывести все эти варианты.
[19:38.840 --> 19:43.840]  То есть я хочу сейчас написать такой цикл и сказать,
[19:43.840 --> 19:47.840]  для каждого элемента варианта вывести его сяут.
[19:47.840 --> 19:49.840]  Просто вывести.
[19:50.840 --> 19:52.840]  Не поможет.
[19:52.840 --> 19:54.840]  Во-первых, так совсем не...
[19:54.840 --> 19:56.840]  А во-вторых, будет это вариант.
[19:56.840 --> 19:57.840]  Всё нормально.
[19:57.840 --> 19:59.840]  Но цялость у него не определён?
[19:59.840 --> 20:00.840]  Или определён?
[20:00.840 --> 20:02.840]  У варианта нет, конечно.
[20:02.840 --> 20:04.840]  Мне можно сказать get от...
[20:04.840 --> 20:06.840]  Но надо понять от чего каждый раз.
[20:06.840 --> 20:08.840]  А, ну вот, собственно, и visit, да?
[20:08.840 --> 20:12.840]  Значит, visit это такая штука, которая позволяет вам взять
[20:12.840 --> 20:17.840]  и для данного варианта выполнить одним функцию.
[20:17.840 --> 20:19.840]  Ну вот, а...
[20:19.840 --> 20:23.840]  Смотрите, давайте я напишу for.
[20:23.840 --> 20:28.840]  Ух, ну, напишу for констафта в векторе.
[20:28.840 --> 20:30.840]  Я сделаю следующее.
[20:30.840 --> 20:32.840]  std visit.
[20:37.840 --> 20:39.840]  std visit.
[20:42.840 --> 20:44.840]  Значит, вариант.
[20:44.840 --> 20:48.840]  А дальше функцию, которую я хочу применить.
[20:48.840 --> 20:51.840]  Ну, как я это сделаю?
[20:51.840 --> 20:52.840]  Да.
[20:52.840 --> 20:55.840]  Я просто напишу обобщенную лямину.
[20:57.840 --> 20:59.840]  И что она будет делать?
[20:59.840 --> 21:02.840]  Она будет делать std seout x.
[21:11.840 --> 21:12.840]  Что?
[21:12.840 --> 21:14.840]  Ну...
[21:14.840 --> 21:16.840]  Мы же ничего не сделали.
[21:16.840 --> 21:17.840]  Как ничего не сделали?
[21:17.840 --> 21:19.840]  Я просто вывел все элементы варианта.
[21:19.840 --> 21:20.840]  А что?
[21:20.840 --> 21:21.840]  Ну типа...
[21:21.840 --> 21:23.840]  Мы же ничего дополнительного не сделали.
[21:23.840 --> 21:26.840]  Мы опять сказали авто, и теперь это работает.
[21:26.840 --> 21:30.840]  Один раз не войти, а второй раз сказать авто-авто.
[21:30.840 --> 21:31.840]  Так а как тебе вы...
[21:31.840 --> 21:35.840]  Тебе хочется для всех элементов варианта сделать одно и то же действие?
[21:35.840 --> 21:36.840]  Ну, у всех оно разное.
[21:36.840 --> 21:38.840]  Я про то, что авто...
[21:38.840 --> 21:40.840]  Не очевидно, почему авто разгадывает.
[21:40.840 --> 21:41.840]  Да, стоп.
[21:41.840 --> 21:43.840]  Как авто вариантом лежит.
[21:43.840 --> 21:46.840]  Так, потому что visit так устроен.
[21:46.840 --> 21:49.840]  Ну, функция visit, она принимает...
[21:49.840 --> 21:50.840]  Визит.
[21:50.840 --> 21:52.840]  Он принимает первым аргумент варианта,
[21:52.840 --> 21:54.840]  а вторым аргументом функцию,
[21:54.840 --> 21:56.840]  которая...
[21:56.840 --> 21:57.840]  Шаблон функции.
[21:57.840 --> 22:02.840]  Да, которая должна уметь обрабатывать все типы, которые в варианте.
[22:02.840 --> 22:03.840]  Давайте...
[22:03.840 --> 22:05.840]  Невидно шаблонные, не перегруженные?
[22:05.840 --> 22:06.840]  Нет, можно перегруженные.
[22:06.840 --> 22:08.840]  Давайте посмотрим на visit.
[22:08.840 --> 22:10.840]  То есть главное, чтобы она была на все типы?
[22:10.840 --> 22:13.840]  А я перепутал только порядок.
[22:13.840 --> 22:15.840]  Значит, сначала функция, потом вариант.
[22:16.840 --> 22:18.840]  Я не знаю.
[22:19.840 --> 22:20.840]  Вот смотрите.
[22:20.840 --> 22:22.840]  Есть первым параметром визитера,
[22:22.840 --> 22:23.840]  вторым параметром...
[22:23.840 --> 22:25.840]  А еще переменная число вариантов.
[22:25.840 --> 22:28.840]  То есть, на самом деле, я мог написать CD-визит без цикла.
[22:28.840 --> 22:31.840]  Вот это все и элементы вектора подряд.
[22:31.840 --> 22:33.840]  Ну, вы не знаете, сколько элементов вектора?
[22:33.840 --> 22:35.840]  V0 запятая, V1 запятая, V...
[22:35.840 --> 22:37.840]  А, нет, нет, нет.
[22:39.840 --> 22:41.840]  Интеллектуально.
[22:41.840 --> 22:42.840]  Вот.
[22:42.840 --> 22:43.840]  Что она делает?
[22:43.840 --> 22:47.840]  Она просто берет вот этот визитер,
[22:47.840 --> 22:54.840]  применяет ко всем элементам варианта.
[22:54.840 --> 22:56.840]  То есть, я беру stdinvoke,
[22:56.840 --> 22:59.840]  ну, потому что это же может быть и указатель на член.
[22:59.840 --> 23:01.840]  За что?
[23:01.840 --> 23:03.840]  Да, берет этот визитер
[23:03.840 --> 23:10.840]  и берет stdget от из.
[23:10.840 --> 23:12.840]  А что такое из?
[23:12.840 --> 23:14.840]  Сейчас, может быть...
[23:14.840 --> 23:16.840]  Кажется, не один указатель.
[23:16.840 --> 23:18.840]  Не знаю.
[23:18.840 --> 23:20.840]  Ну, если есть из, значит будет...
[23:20.840 --> 23:21.840]  Из.
[23:21.840 --> 23:24.840]  Это stdforward, вариант basis, vax, index.
[23:24.840 --> 23:26.840]  Реально.
[23:28.840 --> 23:31.840]  Ну, every type is variant basis.
[23:31.840 --> 23:33.840]  Это, значит...
[23:37.840 --> 23:39.840]  Да.
[23:39.840 --> 23:41.840]  Кстати, основной вариант только тесно.
[23:41.840 --> 23:43.840]  Честный тип должен создаваться, да?
[23:43.840 --> 23:45.840]  Что такое чистый тип?
[23:45.840 --> 23:47.840]  В смысле, можно ли отсылок?
[23:47.840 --> 23:49.840]  Нет, ну можно не туда что-нибудь положить.
[23:49.840 --> 23:51.840]  Указатель, конечно, можно.
[23:51.840 --> 23:54.840]  Вот с константами и сосылками будут приколы.
[23:54.840 --> 23:56.840]  Но константу тоже можно.
[23:56.840 --> 23:58.840]  Вот ссылку уже проблематично.
[23:58.840 --> 24:02.840]  Ну, в плане 20 часов можно или просто нереально?
[24:02.840 --> 24:05.840]  Не могу сходу сказать.
[24:05.840 --> 24:07.840]  Может быть, что нереально.
[24:10.840 --> 24:12.840]  Ну, вот тут есть примеры.
[24:12.840 --> 24:14.840]  Ну, давайте я...
[24:14.840 --> 24:16.840]  Давайте, во-первых, проверим, что это работает.
[24:16.840 --> 24:18.840]  Более плохо.
[24:20.840 --> 24:22.840]  Действительно все...
[24:22.840 --> 24:24.840]  Да.
[24:24.840 --> 24:26.840]  Как это работает?
[24:26.840 --> 24:28.840]  Непонятно.
[24:28.840 --> 24:30.840]  Еще раз вопрос.
[24:30.840 --> 24:32.840]  Эта шаблонная функция должна уметь принимать все аргументы...
[24:32.840 --> 24:34.840]  Все оперативные варианты, да.
[24:34.840 --> 24:36.840]  Ну да.
[24:36.840 --> 24:38.840]  Вот там есть более странные примеры еще.
[24:38.840 --> 24:40.840]  Там не лежит.
[24:40.840 --> 24:42.840]  Давайте посмотрим действительно вот эти примеры.
[24:42.840 --> 24:44.840]  Тут есть поинтереснее.
[24:46.840 --> 24:48.840]  Во-первых, ну вот этот вот...
[24:48.840 --> 24:50.840]  Вот это примитивный пример, который мы только...
[24:50.840 --> 24:52.840]  СТД визит, вот по сути то, что я сейчас сделал.
[24:52.840 --> 24:54.840]  У меня есть вектор из разных штук.
[24:54.840 --> 24:58.840]  И я каждый из них вывел просто.
[24:58.840 --> 25:02.840]  Я мог бы, например, сделать так.
[25:02.840 --> 25:04.840]  Взял и удвоил их все.
[25:04.840 --> 25:06.840]  Да, ну то есть, смотрите, я такое говорю.
[25:06.840 --> 25:08.840]  Вот давайте я скажу...
[25:08.840 --> 25:10.840]  Ух!
[25:12.840 --> 25:14.840]  СТД вектор.
[25:14.840 --> 25:16.840]  Ну давайте я скажу авто...
[25:16.840 --> 25:18.840]  Я не знаю, авто.
[25:18.840 --> 25:20.840]  Век два равно век.
[25:20.840 --> 25:22.840]  И теперь век два.
[25:24.840 --> 25:26.840]  Век два.
[25:26.840 --> 25:28.840]  Век два.
[25:28.840 --> 25:30.840]  Век два.
[25:30.840 --> 25:32.840]  Век два.
[25:32.840 --> 25:34.840]  Плохо.
[25:34.840 --> 25:36.840]  СТД векто.
[25:36.840 --> 25:38.840]  Вариант Т.
[25:38.840 --> 25:40.840]  А почему?
[25:40.840 --> 25:42.840]  Век два.
[25:42.840 --> 25:44.840]  А как я?
[25:44.840 --> 25:46.840]  Мне надо положить в него.
[25:46.840 --> 25:48.840]  Век два.
[25:48.840 --> 25:50.840]  Сейчас сделаем плейсбек.
[25:50.840 --> 25:52.840]  Что?
[25:52.840 --> 25:54.840]  А вот что.
[25:54.840 --> 25:56.840]  СТД визит.
[25:58.840 --> 26:00.840]  СТД визит.
[26:02.840 --> 26:04.840]  Вот.
[26:04.840 --> 26:06.840]  Такой вещи.
[26:06.840 --> 26:08.840]  Авто двойной персант Х.
[26:08.840 --> 26:10.840]  Стрелочка.
[26:10.840 --> 26:12.840]  Вариант Т.
[26:12.840 --> 26:14.840]  Фигурная скобочка открылась.
[26:14.840 --> 26:16.840]  Ретерн.
[26:16.840 --> 26:18.840]  Х плюс Х.
[26:18.840 --> 26:20.840]  Запятая.
[26:20.840 --> 26:22.840]  В.
[26:22.840 --> 26:24.840]  О.
[26:24.840 --> 26:26.840]  Авто двойной персанты это же универсальная ссылка.
[26:26.840 --> 26:28.840]  Универсальная ссылка, да.
[26:28.840 --> 26:30.840]  Смотрите, что я сделал.
[26:30.840 --> 26:32.840]  В.
[26:32.840 --> 26:34.840]  Из первого вектора.
[26:34.840 --> 26:36.840]  Посетил соответствующий вариант.
[26:36.840 --> 26:38.840]  С такой функцией.
[26:38.840 --> 26:40.840]  Которая принимает абы что.
[26:40.840 --> 26:42.840]  А возвращает снова вариант.
[26:42.840 --> 26:44.840]  Пронициализированный.
[26:44.840 --> 26:46.840]  Удвоенным значением.
[26:46.840 --> 26:48.840]  Который лежал в старом варианте.
[26:48.840 --> 26:50.840]  Теперь я могу вот этот цикл.
[26:50.840 --> 26:52.840]  Взять и скопировать.
[26:52.840 --> 26:54.840]  Только теперь уже буду идти
[26:54.840 --> 26:56.840]  Поверх два.
[26:56.840 --> 26:58.840]  И давайте проверим, что просто все
[26:58.840 --> 27:00.840]  Применится
[27:02.840 --> 27:04.840]  Удваивание.
[27:08.840 --> 27:10.840]  Я новую строку выведу.
[27:10.840 --> 27:12.840]  Давайте посмотрим.
[27:14.840 --> 27:16.840]  Действительно.
[27:16.840 --> 27:18.840]  Получилось.
[27:20.840 --> 27:22.840]  Вот.
[27:22.840 --> 27:24.840]  Никто еще никогда так не радовался,
[27:24.840 --> 27:26.840]  что у него получилось сложить два объекта.
[27:26.840 --> 27:28.840]  Зачем мы принимаем
[27:28.840 --> 27:30.840]  так универсальные ссылки?
[27:30.840 --> 27:32.840]  Почему не конст?
[27:32.840 --> 27:34.840]  Чтобы можно было теоретически туда
[27:34.840 --> 27:36.840]  подставить временки варианта.
[27:36.840 --> 27:38.840]  Ну да, типа...
[27:38.840 --> 27:40.840]  Конст аута имперсан принимает
[27:40.840 --> 27:42.840]  все что угодно, а аута...
[27:42.840 --> 27:44.840]  Сейчас, это все нормально?
[27:44.840 --> 27:46.840]  Вдруг он его убьет?
[27:46.840 --> 27:48.840]  Нет, нет, он не убьет.
[27:48.840 --> 27:50.840]  Ну, смотри.
[27:50.840 --> 27:52.840]  Да, ну, если...
[27:52.840 --> 27:54.840]  Да, поскольку я здесь
[27:54.840 --> 27:56.840]  V передаю, а не std move от V,
[27:56.840 --> 27:58.840]  то у меня все равно
[27:58.840 --> 28:00.840]  копируется все.
[28:00.840 --> 28:02.840]  Вот если бы я std move от V передавал,
[28:02.840 --> 28:04.840]  то он бы ему отдал бы этот X
[28:04.840 --> 28:06.840]  move'ом.
[28:06.840 --> 28:08.840]  И что он тогда делал с X plus X?
[28:08.840 --> 28:10.840]  В смысле? В чем проблема?
[28:10.840 --> 28:12.840]  X plus X понятно, что делал.
[28:12.840 --> 28:14.840]  Просто вариант бы потерял.
[28:14.840 --> 28:16.840]  Ну давайте я продемонстрирую
[28:16.840 --> 28:18.840]  std move.
[28:18.840 --> 28:20.840]  Что происходит?
[28:20.840 --> 28:22.840]  Можно?
[28:22.840 --> 28:24.840]  Сейчас, ну, visit просто
[28:24.840 --> 28:26.840]  в функцию свою
[28:26.840 --> 28:28.840]  забирает
[28:28.840 --> 28:30.840]  аргумент по R-value ссылке.
[28:30.840 --> 28:32.840]  Ну, то есть, move'ет его из варианта.
[28:32.840 --> 28:34.840]  То есть, вариант опять пустой остается.
[28:34.840 --> 28:36.840]  В плане, если я посылаю,
[28:36.840 --> 28:38.840]  видал, что никому не случилось.
[28:38.840 --> 28:40.840]  По R-value ссылке.
[28:40.840 --> 28:42.840]  По R-value ссылке.
[28:42.840 --> 28:44.840]  Ну, случается, что X plus X
[28:44.840 --> 28:46.840]  что это будет?
[28:46.840 --> 28:48.840]  В плане... Вызывается...
[28:48.840 --> 28:50.840]  от каждого...
[28:50.840 --> 28:52.840]  от соответствующей штуки,
[28:52.840 --> 28:54.840]  которая в варианте лежит.
[28:54.840 --> 28:56.840]  С правильным типом.
[28:56.840 --> 28:58.840]  Она от R-value ссылки.
[28:58.840 --> 29:00.840]  Если в момент
[29:00.840 --> 29:02.840]  передачи
[29:02.840 --> 29:04.840]  в этот визитор,
[29:04.840 --> 29:06.840]  ты заберешь
[29:06.840 --> 29:08.840]  у варианта этот X.
[29:08.840 --> 29:10.840]  Почему?
[29:10.840 --> 29:12.840]  Вы думаете, что это инициализация параметров?
[29:12.840 --> 29:14.840]  Это X от V просто происходит.
[29:14.840 --> 29:16.840]  Ну, все, X...
[29:16.840 --> 29:18.840]  А от того, что в V лежит,
[29:18.840 --> 29:20.840]  с правильным подставленным.
[29:20.840 --> 29:22.840]  А у X-value ссылку не принимаете?
[29:22.840 --> 29:24.840]  Конечно, поэтому она и не универсальна.
[29:24.840 --> 29:26.840]  Я знаю, она не принимает X-value выражение
[29:26.840 --> 29:28.840]  и вместо auto-амперсанда
[29:28.840 --> 29:30.840]  будет стоять поста.
[29:30.840 --> 29:32.840]  Ну...
[29:32.840 --> 29:34.840]  Числи тип без ссылок.
[29:34.840 --> 29:36.840]  Ну...
[29:36.840 --> 29:38.840]  Ну что?
[29:38.840 --> 29:40.840]  Ну тип выведется как
[29:40.840 --> 29:42.840]  тип без амперсанда, да, а у X-value
[29:42.840 --> 29:44.840]  тип с двумя амперсандами.
[29:44.840 --> 29:46.840]  Ну...
[29:46.840 --> 29:48.840]  Вывод типов работает, да.
[29:48.840 --> 29:50.840]  То есть он замувает
[29:50.840 --> 29:52.840]  непосредственно то, что лежит.
[29:52.840 --> 29:54.840]  Да, то, что лежит.
[29:54.840 --> 29:56.840]  Ну давайте, я не знаю, давайте...
[29:56.840 --> 29:58.840]  Вот сейчас еще раз
[29:58.840 --> 30:00.840]  проверим, что...
[30:00.840 --> 30:02.840]  Зачем ему, если
[30:02.840 --> 30:04.840]  агумент функции, это всего лишь ссылка?
[30:04.840 --> 30:06.840]  Нелогично.
[30:06.840 --> 30:08.840]  В смысле?
[30:08.840 --> 30:10.840]  Мы хотим, чтобы объект забрался.
[30:10.840 --> 30:12.840]  Так, давай это сделать.
[30:12.840 --> 30:14.840]  Давай еще раз.
[30:14.840 --> 30:16.840]  Вот то, что auto-амперсанда X.
[30:16.840 --> 30:18.840]  Это R-value ссылка.
[30:18.840 --> 30:20.840]  Ну...
[30:20.840 --> 30:22.840]  Забирает объект.
[30:22.840 --> 30:24.840]  Она может его забрать.
[30:24.840 --> 30:26.840]  Она заберет его, когда ты что-то будешь использовать с ней.
[30:26.840 --> 30:28.840]  То есть она заберет, если мы
[30:28.840 --> 30:30.840]  создадим что-то от него.
[30:30.840 --> 30:32.840]  Она бы забрала что-нибудь,
[30:32.840 --> 30:34.840]  если бы там было написано after X просто.
[30:34.840 --> 30:36.840]  Вроде бы
[30:36.840 --> 30:38.840]  сейчас X
[30:38.840 --> 30:40.840]  сейчас vector 1 не будет пустым.
[30:40.840 --> 30:42.840]  Вот в этом, видимо, утверждение.
[30:42.840 --> 30:44.840]  Я не уверен, я не буду переразить язык.
[30:44.840 --> 30:46.840]  Так.
[30:46.840 --> 30:48.840]  Но он будет из пустых строк, по идее.
[30:48.840 --> 30:50.840]  Нет, мы, кстати, мы же у него ничего не забрали.
[30:50.840 --> 30:52.840]  Из пустых чисел строк.
[30:52.840 --> 30:54.840]  Почему?
[30:58.840 --> 31:00.840]  Именно в данном примере.
[31:00.840 --> 31:02.840]  Из-за того, что вы сделали X плюс X.
[31:02.840 --> 31:04.840]  А, господи, у меня здесь V
[31:04.840 --> 31:06.840]  const auto, а не просто auto.
[31:06.840 --> 31:08.840]  Да, это жестко.
[31:08.840 --> 31:10.840]  А вот теперь должно сработать.
[31:10.840 --> 31:12.840]  А, почему не сработало?
[31:12.840 --> 31:14.840]  Ну, const объекты, если мувнут, то ничего не будет.
[31:14.840 --> 31:16.840]  А, потому что здесь должно быть
[31:16.840 --> 31:18.840]  auto member sender. Вот, наверное, почему.
[31:18.840 --> 31:20.840]  Так. Почему?
[31:20.840 --> 31:22.840]  Нет, да, это уже неправда.
[31:22.840 --> 31:24.840]  Это не должно ни на что повлиять.
[31:26.840 --> 31:28.840]  Так кажется, что он не забирает ничего.
[31:28.840 --> 31:30.840]  А зачем ему сейчас забирать?
[31:30.840 --> 31:32.840]  А в какой момент он, чтобы забрать, должен быть
[31:32.840 --> 31:34.840]  выдвинут конструктор копирования или оператор
[31:34.840 --> 31:36.840]  мувающий оператор.
[31:36.840 --> 31:38.840]  Он не выяснил ни разу.
[31:38.840 --> 31:40.840]  Появляется тим, для которого мы можем сделать такую перегрузку,
[31:40.840 --> 31:42.840]  которая забирает все данные.
[31:42.840 --> 31:44.840]  Все.
[31:44.840 --> 31:46.840]  Но сама по себе эта рисунка ничего не трогает.
[31:46.840 --> 31:48.840]  Она просто тим.
[31:50.840 --> 31:52.840]  Вот, если бы мы возвращали
[31:52.840 --> 31:54.840]  рейтсер на CDMove от X
[31:54.840 --> 31:56.840]  внутрь ляма, то CDMove мы забрали.
[31:56.840 --> 31:58.840]  Да, мы забрали, потому что
[31:58.840 --> 32:00.840]  CDMove принимает по ссылке,
[32:00.840 --> 32:02.840]  значит, нужно было бы...
[32:02.840 --> 32:04.840]  ...
[32:04.840 --> 32:06.840]  ...
[32:06.840 --> 32:08.840]  Можно вне этого места...
[32:08.840 --> 32:10.840]  Да!
[32:10.840 --> 32:12.840]  Да, я понял.
[32:12.840 --> 32:14.840]  Да, я был неправ, значит.
[32:14.840 --> 32:16.840]  Вот, надо, если нужно, писать.
[32:16.840 --> 32:18.840]  Ну, давайте вот так и сделаем.
[32:18.840 --> 32:20.840]  Забрали.
[32:20.840 --> 32:22.840]  Вот сейчас все правильно.
[32:22.840 --> 32:24.840]  Вот сейчас все так.
[32:24.840 --> 32:26.840]  Забрал пять, оставил пять.
[32:28.840 --> 32:30.840]  Все было прав, я был неправ.
[32:30.840 --> 32:32.840]  Ну, теперь понятно, что произошло?
[32:32.840 --> 32:34.840]  Господи, я понимаю, вы понимаете,
[32:34.840 --> 32:36.840]  я так разговариваю.
[32:36.840 --> 32:38.840]  Мы едем, мы едем, мы едем.
[32:38.840 --> 32:40.840]  Сейчас, а почему, если мы там напишем const auto,
[32:40.840 --> 32:42.840]  то не будет работать?
[32:42.840 --> 32:44.840]  Потому что, если ты зваешь move, это const объекта,
[32:44.840 --> 32:46.840]  я вас регулировал с каким-то чудом.
[32:46.840 --> 32:48.840]  Нет, просто если ты move,
[32:48.840 --> 32:50.840]  вызываешь const объекта, он не будет работать.
[32:50.840 --> 32:52.840]  Это нет перегрузки
[32:52.840 --> 32:54.840]  mov для const объекта.
[32:54.840 --> 32:56.840]  Это-то ладно, а почему
[32:56.840 --> 32:58.840]  вообще auto два амперсанта
[32:58.840 --> 33:00.840]  компилируется в плане...
[33:00.840 --> 33:02.840]  Почему, как он принимает по универсальной ссылке
[33:02.840 --> 33:04.840]  без const константную штуку?
[33:04.840 --> 33:06.840]  Что-что-что?
[33:06.840 --> 33:08.840]  Рекол в том, что два амперсанта ему конфликт
[33:08.840 --> 33:10.840]  на const reply.
[33:10.840 --> 33:12.840]  Так, подожди, auto двумя амперсант,
[33:12.840 --> 33:14.840]  auto const туда подставляется.
[33:14.840 --> 33:16.840]  Конечно.
[33:16.840 --> 33:18.840]  const не отбрасывается при выводе, типа.
[33:18.840 --> 33:20.840]  Рекол еще там.
[33:20.840 --> 33:22.840]  Тут, скажи, не в том, что ссылки,
[33:22.840 --> 33:24.840]  а в будущем const reply они отдельно работают.
[33:24.840 --> 33:26.840]  Да-да-да-да.
[33:26.840 --> 33:28.840]  С const здесь не получится,
[33:28.840 --> 33:30.840]  потому что этот move, он дает
[33:30.840 --> 33:32.840]  const value ссылку, вот этот stdmove
[33:32.840 --> 33:34.840]  от v дает мне const value ссылку,
[33:34.840 --> 33:36.840]  и это не дает
[33:36.840 --> 33:38.840]  возможности, ну, то есть здесь я получаю
[33:38.840 --> 33:40.840]  const там...
[33:42.840 --> 33:44.840]  const что?
[33:44.840 --> 33:46.840]  const какой-то
[33:46.840 --> 33:48.840]  тип два амперсанта, но move
[33:48.840 --> 33:50.840]  не может работать как move,
[33:50.840 --> 33:52.840]  когда он его возвращает.
[33:52.840 --> 33:54.840]  Так, ну ладно,
[33:54.840 --> 33:56.840]  короче, кто понял,
[33:56.840 --> 33:58.840]  тот молодец.
[33:58.840 --> 34:00.840]  Вот сейчас
[34:00.840 --> 34:02.840]  внутри этого
[34:02.840 --> 34:04.840]  visit, auto два амперсанта
[34:04.840 --> 34:06.840]  и x,
[34:06.840 --> 34:08.840]  x будет иметь тип
[34:08.840 --> 34:10.840]  string или string два амперсанта?
[34:10.840 --> 34:12.840]  String два амперсанта, конечно.
[34:12.840 --> 34:14.840]  Тут либо кланк сошел в сумму,
[34:14.840 --> 34:16.840]  либо мы чего-то не понимаем, в общем,
[34:16.840 --> 34:18.840]  если бы возвращать x плюс x, у нас ничего не работало, да?
[34:18.840 --> 34:20.840]  В смысле, не работало?
[34:20.840 --> 34:22.840]  Ну, он бы не муялся, а если
[34:22.840 --> 34:24.840]  return x, не stdmove от x, а просто x,
[34:24.840 --> 34:26.840]  он бы не обмувывается, почему?
[34:26.840 --> 34:28.840]  Кланк не понимает
[34:28.840 --> 34:30.840]  мусьманчику. Нет.
[34:32.840 --> 34:34.840]  Если здесь убрать, stdmove от x,
[34:34.840 --> 34:36.840]  return.
[34:42.840 --> 34:44.840]  Давайте посмотрим.
[34:44.840 --> 34:46.840]  Ну потому что возвращаемый тип, это просто
[34:46.840 --> 34:48.840]  принимаемый тип.
[34:48.840 --> 34:50.840]  Можно просто его это...
[34:50.840 --> 34:52.840]  Ну, давайте подумаем.
[34:52.840 --> 34:54.840]  Возвращаемый тип, это просто вариант.
[34:54.840 --> 34:56.840]  То есть он создает вариант от x.
[34:56.840 --> 34:58.840]  А x это ребелью.
[34:58.840 --> 35:00.840]  А x это лвл, да.
[35:00.840 --> 35:02.840]  А на g-press плюс 11 у меня
[35:02.840 --> 35:04.840]  stdmove. Я не знаю, что это значит.
[35:04.840 --> 35:06.840]  Секунду, в плане x...
[35:06.840 --> 35:08.840]  А 11 вообще есть?
[35:08.840 --> 35:10.840]  Чего вот x это лвл?
[35:10.840 --> 35:12.840]  Вас интересно видеть?
[35:12.840 --> 35:14.840]  x это не лвл.
[35:14.840 --> 35:16.840]  Вот здесь...
[35:16.840 --> 35:18.840]  Х это лвл.
[35:18.840 --> 35:20.840]  В плане выражения, да.
[35:20.840 --> 35:22.840]  Да, он должен вернуть вариант
[35:22.840 --> 35:24.840]  t, созданный от x.
[35:24.840 --> 35:26.840]  Где x это лвл, давайте запустим.
[35:26.840 --> 35:28.840]  Интересно.
[35:28.840 --> 35:30.840]  А, стоп, это силенг. Я сейчас с силенгом
[35:30.840 --> 35:32.840]  это подъехал. Силенгом, да.
[35:32.840 --> 35:34.840]  Нет, не мувает.
[35:34.840 --> 35:36.840]  Кланк не мувает. А у меня мувает.
[35:36.840 --> 35:38.840]  У тебя кланк? У меня кланк.
[35:38.840 --> 35:40.840]  Сейчас, может я чуть не правильно
[35:40.840 --> 35:42.840]  писал? Может у тебя
[35:42.840 --> 35:44.840]  Силенг 12.
[35:44.840 --> 35:46.840]  У меня 13.
[35:46.840 --> 35:48.840]  Давай...
[35:48.840 --> 35:50.840]  Интересно.
[35:50.840 --> 35:52.840]  Так, давайте г плюс плюсом еще проверим.
[35:52.840 --> 35:54.840]  Там минус 11, ну или просто.
[35:54.840 --> 35:56.840]  Да, ой, не то.
[35:56.840 --> 35:58.840]  Тоже не мувает.
[35:58.840 --> 36:00.840]  Сейчас я буду код сравнить.
[36:00.840 --> 36:02.840]  Ну короче, я буду считать, что
[36:02.840 --> 36:04.840]  все правильно и пойду дальше.
[36:06.840 --> 36:08.840]  Видимо, мне повезло.
[36:08.840 --> 36:10.840]  Не буду думать тогда.
[36:10.840 --> 36:12.840]  Ну давайте, давайте.
[36:12.840 --> 36:14.840]  А вот есть ли?
[36:14.840 --> 36:16.840]  Вот внутри его функции есть разница?
[36:16.840 --> 36:18.840]  Что нам дали?
[36:18.840 --> 36:20.840]  Стринг? А, нет, есть, конечно,
[36:20.840 --> 36:22.840]  разница.
[36:22.840 --> 36:24.840]  Сейчас, секунду, а он
[36:24.840 --> 36:26.840]  смувал только...
[36:26.840 --> 36:28.840]  Последней строчкой, что он там
[36:28.840 --> 36:30.840]  у нас стоит? Внизу еще в коль написано
[36:30.840 --> 36:32.840]  века просто. Век 2.
[36:32.840 --> 36:34.840]  И века, и 2, и еще века, да?
[36:34.840 --> 36:36.840]  Она просто...
[36:36.840 --> 36:38.840]  То есть, вот внутри тебя этой функции
[36:38.840 --> 36:40.840]  мы могли написать
[36:40.840 --> 36:42.840]  х равно 17.
[36:42.840 --> 36:44.840]  Если бы это была функция
[36:44.840 --> 36:46.840]  чисто только для стреков,
[36:46.840 --> 36:48.840]  то мы могли написать х равно 17,
[36:48.840 --> 36:50.840]  и это поменяло бы В.
[36:50.840 --> 36:52.840]  Нет.
[36:52.840 --> 36:54.840]  Что?!
[36:54.840 --> 36:56.840]  Нет, сейчас, ну ты же по ссылке принял х,
[36:56.840 --> 36:58.840]  ну да.
[36:58.840 --> 37:00.840]  Я же фактически вот здесь принял
[37:00.840 --> 37:02.840]  х, это ссылка, я получил
[37:02.840 --> 37:04.840]  ссылку на то самое, что в варианте лежит.
[37:08.840 --> 37:10.840]  Ну, давайте я скажу,
[37:10.840 --> 37:12.840]  например, х...
[37:12.840 --> 37:14.840]  Сейчас, нет, я все, я теперь стал понимать.
[37:14.840 --> 37:16.840]  Потому что я все понимаю.
[37:16.840 --> 37:18.840]  Я ничего не понимаю, почему это авто,
[37:18.840 --> 37:20.840]  это... Давайте я вот здесь вот скажу,
[37:20.840 --> 37:22.840]  например, х плюс равно х.
[37:22.840 --> 37:24.840]  Ну, такая...
[37:24.840 --> 37:26.840]  Да.
[37:26.840 --> 37:28.840]  Ну, еще раз, х плюс равно х.
[37:28.840 --> 37:30.840]  Это, вроде, для всех типов подходит.
[37:30.840 --> 37:32.840]  Не подумай, персонаж.
[37:32.840 --> 37:34.840]  Не подумай, персонаж, не подумай.
[37:34.840 --> 37:36.840]  Да, неважно, можно
[37:36.840 --> 37:38.840]  не вплетать сюда мупсимантику, пожалуйста.
[37:38.840 --> 37:40.840]  Можно не вплетать сюда мупсимантику,
[37:40.840 --> 37:42.840]  пожалуйста. Я хочу понять
[37:42.840 --> 37:44.840]  варианта не мупсимантики.
[37:44.840 --> 37:46.840]  Нет.
[37:46.840 --> 37:48.840]  Мы вон там уже
[37:48.840 --> 37:50.840]  задались вопросом,
[37:50.840 --> 37:52.840]  представим мупсимантику, я ничего не понял.
[37:52.840 --> 37:54.840]  Я же не возвращаюсь наружу,
[37:54.840 --> 37:56.840]  не мупуя его.
[37:56.840 --> 37:58.840]  Я не собираюсь забирать, я просто меняю
[37:58.840 --> 38:00.840]  самым быстрым, как я получил вариант,
[38:00.840 --> 38:02.840]  по какой ссылке.
[38:06.840 --> 38:08.840]  Таким образом, у меня
[38:08.840 --> 38:10.840]  х это
[38:10.840 --> 38:12.840]  2k, а не вариант.
[38:12.840 --> 38:14.840]  Потому что видит, ну, видит это дело,
[38:14.840 --> 38:16.840]  он передает
[38:16.840 --> 38:18.840]  лямбда функцию. Все, у меня удвоились
[38:18.840 --> 38:20.840]  все, вроде, все удвоилось.
[38:20.840 --> 38:22.840]  В первом век я во втором все пустил.
[38:22.840 --> 38:24.840]  А, и это антайм-штук вообще, хорошо. Так, господа
[38:24.840 --> 38:26.840]  хорошие, давайте
[38:26.840 --> 38:28.840]  пойдем дальше, и
[38:28.840 --> 38:30.840]  мы, это все, это все замечательно,
[38:30.840 --> 38:32.840]  но наша цель сегодня
[38:32.840 --> 38:34.840]  это реализовать еще.
[38:34.840 --> 38:36.840]  Ну, не видит,
[38:36.840 --> 38:38.840]  видит мы сегодня не реализуем.
[38:38.840 --> 38:40.840]  Завтра, может, реализуем.
[38:40.840 --> 38:42.840]  А вот основную идею
[38:42.840 --> 38:44.840]  варианта, хочется
[38:44.840 --> 38:46.840]  понять реализацию ее.
[38:46.840 --> 38:48.840]  То есть, мы хотим,
[38:48.840 --> 38:50.840]  ну, вообще, интересные
[38:50.840 --> 38:52.840]  примеры, вот с видитом еще есть,
[38:52.840 --> 38:54.840]  вот, например,
[38:56.840 --> 38:58.840]  короче, сами посмотрите на них, они
[38:58.840 --> 39:00.840]  очень великолепные, но
[39:00.840 --> 39:02.840]  сейчас не будет.
[39:02.840 --> 39:04.840]  Вот, давайте попробуем
[39:04.840 --> 39:06.840]  реализовать вариант.
[39:10.840 --> 39:12.840]  Вот.
[39:14.840 --> 39:16.840]  Я для
[39:16.840 --> 39:18.840]  этого, наверное, закомментирую все вот.
[39:18.840 --> 39:20.840]  То есть, нормально нам что надо сделать?
[39:20.840 --> 39:22.840]  Нам просто надо юниор сделать так, чтобы
[39:22.840 --> 39:24.840]  обращались в угол.
[39:24.840 --> 39:26.840]  У вас тут был пробок.
[39:26.840 --> 39:28.840]  Значит, вот это
[39:28.840 --> 39:30.840]  я закомментирую.
[39:30.840 --> 39:32.840]  Так.
[39:32.840 --> 39:34.840]  Так.
[39:40.840 --> 39:42.840]  Сейчас я буду реализовывать
[39:42.840 --> 39:44.840]  вариант.
[39:46.840 --> 39:48.840]  И я,
[39:48.840 --> 39:50.840]  ну, давайте, действительно,
[39:50.840 --> 39:52.840]  вот, что-нибудь.
[39:52.840 --> 39:54.840]  Нет, нет,
[39:54.840 --> 39:56.840]  пока без оптимизации.
[39:56.840 --> 39:58.840]  Просто вот, что мы хотим,
[39:58.840 --> 40:00.840]  что мы хотим, чтобы было.
[40:02.840 --> 40:04.840]  Какой вариант?
[40:04.840 --> 40:06.840]  Он написан с кучей оптимизацией,
[40:06.840 --> 40:08.840]  только не очень понятно, что здесь имеется
[40:08.840 --> 40:10.840]  в виду под small object optimization действительно,
[40:10.840 --> 40:12.840]  потому что все хранится на стейке,
[40:12.840 --> 40:14.840]  видит так, а не на куче.
[40:14.840 --> 40:16.840]  Значит, вот у меня будет
[40:16.840 --> 40:18.840]  type name types, их много.
[40:18.840 --> 40:20.840]  Мне нужно первыми эти выделять.
[40:20.840 --> 40:22.840]  Сейчас подумаем, сейчас может
[40:22.840 --> 40:24.840]  и понадобится.
[40:24.840 --> 40:26.840]  Давайте посмотрим.
[40:26.840 --> 40:28.840]  Что будет внутри?
[40:30.840 --> 40:32.840]  Storage на или...
[40:32.840 --> 40:34.840]  Ну, что-то такое.
[40:34.840 --> 40:36.840]  Ну, есть
[40:36.840 --> 40:38.840]  два варианта. Можно
[40:38.840 --> 40:40.840]  массив чаров,
[40:40.840 --> 40:42.840]  как мы любим.
[40:42.840 --> 40:44.840]  А можно...
[40:44.840 --> 40:46.840]  А какой у него размер будет?
[40:46.840 --> 40:48.840]  И как мы будем
[40:48.840 --> 40:50.840]  понимать, кто там лежит?
[40:50.840 --> 40:52.840]  Ну, это...
[40:52.840 --> 40:54.840]  Это не очень приятно.
[40:54.840 --> 40:56.840]  В общем, можно сделать
[40:56.840 --> 40:58.840]  чисто на storage,
[40:58.840 --> 41:00.840]  чисто на storage
[41:00.840 --> 41:02.840]  без union.
[41:02.840 --> 41:04.840]  Но мне больше нравится с union.
[41:04.840 --> 41:06.840]  Мне кажется, так оно
[41:06.840 --> 41:08.840]  как-то элегантнее смотрится.
[41:10.840 --> 41:12.840]  Но если вы хотите
[41:12.840 --> 41:14.840]  реализовывать через
[41:14.840 --> 41:16.840]  массив чаров,
[41:16.840 --> 41:18.840]  пожалуйста, можете так реализовывать.
[41:18.840 --> 41:20.840]  Здесь бы все работало.
[41:20.840 --> 41:22.840]  Но в STL
[41:22.840 --> 41:24.840]  реализовано через union.
[41:24.840 --> 41:26.840]  Вот этой...
[41:26.840 --> 41:28.840]  Вот у меня открыт
[41:28.840 --> 41:30.840]  ST вариант, собственно, variadic union.
[41:30.840 --> 41:32.840]  Так что я вас не обманываю.
[41:32.840 --> 41:34.840]  Ну, вот это то, что мы сейчас напишем.
[41:34.840 --> 41:36.840]  А что такое variadic union?
[41:36.840 --> 41:38.840]  Самый способ
[41:38.840 --> 41:40.840]  union запихнуть все types.
[41:40.840 --> 41:42.840]  Type name
[41:42.840 --> 41:44.840]  head. Вот тут уже мне потребуется
[41:44.840 --> 41:46.840]  head и tail.
[41:46.840 --> 41:48.840]  Tail.
[41:48.840 --> 41:50.840]  Union.
[41:50.840 --> 41:52.840]  Variadic union.
[41:54.840 --> 41:56.840]  Правильно?
[41:56.840 --> 41:58.840]  Нет, там tab несколько.
[41:58.840 --> 42:00.840]  Что? Variatic.
[42:00.840 --> 42:02.840]  Variadic.
[42:06.840 --> 42:08.840]  Что в нем будет лежать?
[42:08.840 --> 42:10.840]  Ну, в нем будет head
[42:10.840 --> 42:12.840]  и еще что?
[42:12.840 --> 42:14.840]  И еще union.
[42:16.840 --> 42:18.840]  От всего остального.
[42:18.840 --> 42:20.840]  Ваня, это сразу вопрос.
[42:20.840 --> 42:21.840]  Мы же тут
[42:21.840 --> 42:23.840]  тупо создадим кучу типов.
[42:23.840 --> 42:25.840]  Ну.
[42:25.840 --> 42:27.840]  Идея в том, что у тебя все лежало
[42:27.840 --> 42:29.840]  на дридаш-пакете.
[42:29.840 --> 42:31.840]  Вот оно и лежит на дридаш-пакете.
[42:31.840 --> 42:33.840]  Это шаблонный union.
[42:33.840 --> 42:35.840]  Шаблонный union, конечно.
[42:35.840 --> 42:37.840]  Разрыв, разрыв.
[42:37.840 --> 42:39.840]  Конечно, шаблонный union.
[42:39.840 --> 42:41.840]  В прошлый раз я даже про него говорил.
[42:41.840 --> 42:43.840]  Вкратце. Да, но мне нужен
[42:43.840 --> 42:45.840]  это... Чего не хватает?
[42:45.840 --> 42:47.840]  Зачем мы его внутренним типом делать?
[42:47.840 --> 42:49.840]  Зачем мы его внутренним типом делать?
[42:49.840 --> 42:51.840]  Чтоб не мешался во внешнюю
[42:51.840 --> 42:53.840]  мирию или...
[42:53.840 --> 42:55.840]  Ну да. Вопрос.
[42:55.840 --> 42:57.840]  Почему это будет так работать?
[42:57.840 --> 42:59.840]  Типа union внутри union?
[42:59.840 --> 43:01.840]  Ну да. На одной и той же памяти
[43:01.840 --> 43:03.840]  лежит либо первый тип,
[43:03.840 --> 43:05.840]  либо union из остальных типов.
[43:05.840 --> 43:07.840]  Но union из остальных типов, соответственно...
[43:07.840 --> 43:09.840]  Так.
[43:09.840 --> 43:11.840]  А чего не хватает-то, очевидно, еще?
[43:11.840 --> 43:13.840]  Здесь.
[43:13.840 --> 43:15.840]  Сейчас CE будет такой.
[43:15.840 --> 43:17.840]  Если это так, попробуй стабилизировать.
[43:17.840 --> 43:19.840]  Ну хотел бы, наверное, объект.
[43:19.840 --> 43:21.840]  Да, мы все отцепилируем, чтобы не подставить.
[43:21.840 --> 43:23.840]  Нет, не хватает базы.
[43:23.840 --> 43:25.840]  В смысле, это база хранили.
[43:25.840 --> 43:27.840]  Но нужно специализовывать вовно.
[43:27.840 --> 43:29.840]  Union пустой.
[43:29.840 --> 43:31.840]  После, наверное. Да.
[43:31.840 --> 43:33.840]  Темплей.
[43:37.840 --> 43:39.840]  Давайте от одного, давайте от одного.
[43:43.840 --> 43:45.840]  Одного менее приятно.
[43:45.840 --> 43:47.840]  Разве? Созвать пустой union?
[43:51.840 --> 43:53.840]  Темплей.
[43:53.840 --> 43:55.840]  Ну, может, type name T.
[43:55.840 --> 43:57.840]  Давайте так, union.
[44:01.840 --> 44:03.840]  Так, нет.
[44:03.840 --> 44:05.840]  Какая-то неудача мне не нравится,
[44:05.840 --> 44:07.840]  потому что она отличается.
[44:07.840 --> 44:09.840]  Сейчас, мне нужен темплей.
[44:09.840 --> 44:11.840]  Type name T.
[44:11.840 --> 44:13.840]  От одного.
[44:15.840 --> 44:17.840]  Да, конечно.
[44:25.840 --> 44:27.840]  Ну, давайте сделаем union от одного типа, ладно.
[44:27.840 --> 44:29.840]  Кстати, у нас все скопилируется,
[44:29.840 --> 44:31.840]  потому что надо сначала его инстанцировать.
[44:31.840 --> 44:33.840]  Ну, понятно, да. Он инстанцировал меня в мейне.
[44:33.840 --> 44:35.840]  Ага.
[44:37.840 --> 44:39.840]  My вариант.
[44:39.840 --> 44:41.840]  Ну, локатор, потому что динамическая память не выделяется.
[44:45.840 --> 44:47.840]  Нет, может, конечно, было бы прикрутить локатор,
[44:47.840 --> 44:49.840]  чтобы констракт и дестрой делался правильно.
[44:51.840 --> 44:53.840]  Но мы не будем.
[44:55.840 --> 44:57.840]  А у standard variant есть локатор или что?
[44:57.840 --> 44:59.840]  Нет, конечно, нет.
[44:59.840 --> 45:01.840]  Это вообще не нормально было.
[45:01.840 --> 45:03.840]  У standard variant есть quanti-chart,
[45:03.840 --> 45:05.840]  который реализовал свой standard variant
[45:05.840 --> 45:07.840]  и лучше, чем standard variant, на 20% еще поддерживает локатор.
[45:07.840 --> 45:09.840]  Мы же в чеченой специализации должны писать
[45:09.840 --> 45:11.840]  variadic-union и треугольные скобочки.
[45:13.840 --> 45:15.840]  Ага.
[45:15.840 --> 45:17.840]  Нет, от пустого же, наверное.
[45:17.840 --> 45:19.840]  А вот от пустого ты пустой union создаешь?
[45:19.840 --> 45:21.840]  Нет, давайте...
[45:21.840 --> 45:23.840]  Чего пустой union?
[45:23.840 --> 45:25.840]  А если пустой union есть?
[45:25.840 --> 45:27.840]  Почему нет?
[45:27.840 --> 45:29.840]  Да, пустой union просто.
[45:29.840 --> 45:31.840]  Сейчас я немножечко переживаю
[45:31.840 --> 45:33.840]  насчет синтеза.
[45:33.840 --> 45:35.840]  Ну, так, у меня чего?
[45:35.840 --> 45:37.840]  Ну, и мне нужно в поля чуть положить.
[45:37.840 --> 45:39.840]  В поля варианта, собственно, я кладу что?
[45:39.840 --> 45:41.840]  Variadic union.
[45:41.840 --> 45:43.840]  Variadic union.
[45:43.840 --> 45:45.840]  От моих типов.
[45:47.840 --> 45:49.840]  Правильно, что мы пока что умеем, значит...
[45:49.840 --> 45:51.840]  Только дышать.
[45:51.840 --> 45:53.840]  Нет, мы умеем делать
[45:53.840 --> 45:55.840]  SD-variant ничего.
[45:57.840 --> 45:59.840]  Ну, понятно, что
[45:59.840 --> 46:01.840]  под вариантом оно еще не понравилось.
[46:01.840 --> 46:03.840]  Кажется, пустой нельзя.
[46:05.840 --> 46:07.840]  Wrong number of tablet arguments.
[46:09.840 --> 46:11.840]  Ну, да, это вероятно.
[46:11.840 --> 46:13.840]  Одного получается?
[46:13.840 --> 46:15.840]  Ну, плохо имплементация языков пасты.
[46:17.840 --> 46:19.840]  Кажется.
[46:21.840 --> 46:23.840]  Почему пасты?
[46:23.840 --> 46:25.840]  Нужно будет что-то сделать вот здесь
[46:25.840 --> 46:27.840]  и что-то сделать в этом месте.
[46:27.840 --> 46:29.840]  Ну, да.
[46:29.840 --> 46:31.840]  Нужно будет что-то сделать вот здесь
[46:31.840 --> 46:33.840]  и что-то сделать вот здесь.
[46:33.840 --> 46:35.840]  Нужно с хедом делать то же самое, что здесь, с последним элементом.
[46:35.840 --> 46:37.840]  Если мы что-то
[46:37.840 --> 46:39.840]  будем делать.
[46:39.840 --> 46:41.840]  Хотя...
[46:41.840 --> 46:43.840]  Да, ему не нравится, что я внутри класса
[46:43.840 --> 46:45.840]  определяю специализацию. Ну, давайте вынесем из класса.
[46:45.840 --> 46:47.840]  А что?
[46:47.840 --> 46:49.840]  А я... В смысле, если один сделать,
[46:49.840 --> 46:51.840]  то все нормально, все работает.
[46:53.840 --> 46:55.840]  А почему ты говорил, что один
[46:55.840 --> 46:57.840]  неприятно?
[46:57.840 --> 46:59.840]  А если делать копии пасты?
[46:59.840 --> 47:01.840]  Кажется. Я пока не уверен,
[47:01.840 --> 47:03.840]  что мы там вообще писать собираемся.
[47:03.840 --> 47:05.840]  Типа, можно ли обратиться к хеду,
[47:05.840 --> 47:07.840]  если у тебя
[47:07.840 --> 47:09.840]  или это, либо в реакцию?
[47:09.840 --> 47:11.840]  Вроде можно.
[47:15.840 --> 47:17.840]  Так, а я хочу... Недовольный человек.
[47:17.840 --> 47:19.840]  Верно.
[47:21.840 --> 47:23.840]  А, блин.
[47:23.840 --> 47:25.840]  Что ж такое?
[47:27.840 --> 47:29.840]  Недовольные скобочки
[47:29.840 --> 47:31.840]  не нужны.
[47:31.840 --> 47:33.840]  Может быть, тоже такие
[47:33.840 --> 47:35.840]  негеточие?
[47:35.840 --> 47:37.840]  Пустой дайдней?
[47:37.840 --> 47:39.840]  Ну, а почему бы нет? Негеточие повторится хоть.
[47:39.840 --> 47:41.840]  Оно, типа, будет менее приоритетным,
[47:41.840 --> 47:43.840]  поэтому сработает.
[47:43.840 --> 47:45.840]  Тут уже бред.
[47:47.840 --> 47:49.840]  Двойная.
[47:49.840 --> 47:51.840]  Ладно.
[47:53.840 --> 47:55.840]  Можете...
[47:55.840 --> 47:57.840]  Жестко подберегись к тебе.
[47:59.840 --> 48:01.840]  О, Конст-Каст.
[48:01.840 --> 48:03.840]  Ну, весело.
[48:05.840 --> 48:07.840]  Конст-Каст воет звездочки?
[48:07.840 --> 48:09.840]  От Конст воет звездочки.
[48:11.840 --> 48:13.840]  Мой воздух никому нельзя трогать.
[48:13.840 --> 48:15.840]  Не, кстати, Каст и Конст-Каст воет звездочки.
[48:15.840 --> 48:17.840]  Никто не смеет трогать
[48:17.840 --> 48:19.840]  мой воздух.
[48:19.840 --> 48:21.840]  В смысле пустоту?
[48:21.840 --> 48:23.840]  Я даже почтил бы, да.
[48:23.840 --> 48:25.840]  А, вообще, не надо никаким
[48:25.840 --> 48:27.840]  головы скобочек, просто вот так.
[48:29.840 --> 48:31.840]  Легко.
[48:31.840 --> 48:33.840]  А, ну да.
[48:33.840 --> 48:35.840]  Логично.
[48:35.840 --> 48:37.840]  Вот это более частный случай,
[48:37.840 --> 48:39.840]  чем это.
[48:39.840 --> 48:41.840]  Первое более частный случай, чем второе.
[48:41.840 --> 48:43.840]  Поэтому, на самом деле, наоборот
[48:43.840 --> 48:45.840]  должно... они в обратном порядке
[48:45.840 --> 48:47.840]  должны идти.
[48:47.840 --> 48:49.840]  В порядке влияет.
[48:49.840 --> 48:51.840]  Во! Это общая версия,
[48:51.840 --> 48:53.840]  а эта версия,
[48:53.840 --> 48:55.840]  может, кстати, порядок не влияет,
[48:55.840 --> 48:57.840]  но я лучше напишу на всякий случай,
[48:57.840 --> 48:59.840]  что вот так точно заработает.
[48:59.840 --> 49:01.840]  Это более общая версия,
[49:01.840 --> 49:03.840]  это более частная версия, понимаете?
[49:03.840 --> 49:05.840]  Поэтому
[49:05.840 --> 49:07.840]  в случае, когда есть хотя бы один шаблонный
[49:07.840 --> 49:09.840]  аргумент, он будет
[49:09.840 --> 49:11.840]  выбирать.
[49:13.840 --> 49:15.840]  Что?
[49:15.840 --> 49:17.840]  Он больше не будет
[49:17.840 --> 49:19.840]  выбирать.
[49:23.840 --> 49:25.840]  Я запрещаю вам выбирать.
[49:27.840 --> 49:29.840]  Иронка?
[49:31.840 --> 49:33.840]  Мне нужно написать
[49:33.840 --> 49:35.840]  здесь, что это специализация.
[49:39.840 --> 49:41.840]  О, ну теперь-то наконец-то
[49:41.840 --> 49:43.840]  заработает, я еще надеюсь.
[49:43.840 --> 49:45.840]  Справить.
[49:49.840 --> 49:51.840]  Так, окей, ладно.
[49:51.840 --> 49:53.840]  Значит, это Юнион. Мы его храним в полях.
[49:53.840 --> 49:55.840]  Один вопросик.
[49:55.840 --> 49:57.840]  Если у меня есть
[49:57.840 --> 49:59.840]  вариантик Юнион,
[49:59.840 --> 50:01.840]  и я такой, точка хет,
[50:01.840 --> 50:03.840]  и он такой, нет его,
[50:03.840 --> 50:05.840]  я общий вариант.
[50:07.840 --> 50:09.840]  Нормально, что у нас бывает хет,
[50:09.840 --> 50:11.840]  а бывает не хет?
[50:11.840 --> 50:13.840]  Так мы будем специализировать
[50:13.840 --> 50:15.840]  какие-то методы только для 2 Юниона,
[50:15.840 --> 50:17.840]  и все.
[50:19.840 --> 50:21.840]  Сейчас.
[50:21.840 --> 50:23.840]  Если у тебя так случится, что ты
[50:23.840 --> 50:25.840]  к пустому Юниона обращаешь,
[50:25.840 --> 50:27.840]  то это будет CE, действительно.
[50:27.840 --> 50:29.840]  Но это же в Compile Time все будет разрешаться.
[50:29.840 --> 50:31.840]  То есть ты никогда к пустому Юнион не будешь хет просить.
[50:31.840 --> 50:33.840]  Если мы проинстанцируемся хоть
[50:33.840 --> 50:35.840]  со скольки-нибудь типами,
[50:35.840 --> 50:37.840]  ты уже можешь хет написать,
[50:37.840 --> 50:39.840]  потому что это будет та версия,
[50:39.840 --> 50:41.840]  которая проверяется.
[50:41.840 --> 50:43.840]  В N запрещается
[50:43.840 --> 50:45.840]  создавать себе от 0 типов.
[50:45.840 --> 50:47.840]  Правильно делает.
[50:49.840 --> 50:51.840]  Так, давайте
[50:51.840 --> 50:53.840]  что-нибудь еще
[50:53.840 --> 50:55.840]  реализуем, например,
[50:55.840 --> 50:57.840]  ГЭТ.
[50:57.840 --> 50:59.840]  Как реализовать ГЭТ?
[50:59.840 --> 51:01.840]  ГЭТ это самое простое.
[51:01.840 --> 51:03.840]  Как реализовать ГЭТ?
[51:05.840 --> 51:07.840]  По интексу, надеюсь.
[51:07.840 --> 51:09.840]  По интексу, да.
[51:09.840 --> 51:11.840]  Ну можно по интексу, по типу.
[51:11.840 --> 51:13.840]  Без разницы.
[51:13.840 --> 51:15.840]  Надо просто эпоксильно посмотреть,
[51:15.840 --> 51:17.840]  пока у нас не спалет CE.
[51:17.840 --> 51:19.840]  Значит, template sizeTn
[51:19.840 --> 51:21.840]  и
[51:21.840 --> 51:23.840]  ну давайте, ладно, напишу sizeTindex.
[51:23.840 --> 51:25.840]  Мы его тоже делаем внешней функцией.
[51:25.840 --> 51:27.840]  И typeName, ну это и есть внешний, да.
[51:27.840 --> 51:29.840]  typeNameT это то,
[51:29.840 --> 51:31.840]  что вернется нам,
[51:31.840 --> 51:33.840]  и typeNameноготочие types
[51:33.840 --> 51:35.840]  это типы, которые варианты.
[51:35.840 --> 51:37.840]  Т, амперсант, ГЭТ.
[51:37.840 --> 51:39.840]  Ну тут нужно
[51:39.840 --> 51:41.840]  4 версии.
[51:41.840 --> 51:43.840]  Т, амперсант, конст, амперсант,
[51:43.840 --> 51:45.840]  Т2, амперсант, конст, Т2, амперсант.
[51:45.840 --> 51:47.840]  Это просто независимо
[51:47.840 --> 51:49.840]  свойства конст
[51:49.840 --> 51:51.840]  и свойства
[51:51.840 --> 51:53.840]  2 амперсанта сочетаются.
[51:55.840 --> 51:57.840]  Нет, ну я тебе писал уже
[51:57.840 --> 51:59.840]  сюда LL и что там такое.
[51:59.840 --> 52:01.840]  Нет, свойства, просто
[52:01.840 --> 52:03.840]  формально все свойства конст
[52:03.840 --> 52:05.840]  и все свойства
[52:05.840 --> 52:07.840]  LL и ссылки меняются одновременно.
[52:07.840 --> 52:09.840]  Вот и все.
[52:09.840 --> 52:11.840]  Значит, мы что принимаем?
[52:11.840 --> 52:13.840]  Мы принимаем...
[52:13.840 --> 52:15.840]  Ну да.
[52:15.840 --> 52:17.840]  Ну да,
[52:17.840 --> 52:19.840]  ну она просто...
[52:19.840 --> 52:21.840]  Типа она просто в губу идет и что?
[52:21.840 --> 52:23.840]  Нет, у меня можно взять
[52:23.840 --> 52:25.840]  поле.
[52:25.840 --> 52:27.840]  Не, Маня,
[52:27.840 --> 52:29.840]  ты переводишь поле, она все равно просто будет...
[52:29.840 --> 52:31.840]  Так, вот я
[52:31.840 --> 52:33.840]  говорю, вот я взял Get
[52:33.840 --> 52:35.840]  и хочу вернуть
[52:35.840 --> 52:37.840]  T по индексу, индекс.
[52:37.840 --> 52:39.840]  Че мне надо здесь
[52:39.840 --> 52:41.840]  написать?
[52:41.840 --> 52:43.840]  А почему остальные
[52:43.840 --> 52:45.840]  даем к шаблонной кон...
[52:45.840 --> 52:47.840]  они его выведут сами?
[52:47.840 --> 52:49.840]  Ну конечно.
[52:49.840 --> 52:51.840]  Ну вариант же от каких-то типов.
[52:51.840 --> 52:53.840]  Не, я про T, это что?
[52:53.840 --> 52:55.840]  Это то, что мы вернем, да.
[52:55.840 --> 52:57.840]  То, что мы вернем, компилятор
[52:57.840 --> 52:59.840]  сейчас выведет, потому что я же напишу
[52:59.840 --> 53:01.840]  компилятор, что-то.
[53:01.840 --> 53:03.840]  Вот индекс нам придется
[53:03.840 --> 53:05.840]  передавать, а T он
[53:05.840 --> 53:07.840]  увидит.
[53:07.840 --> 53:09.840]  Тоже выведет, конечно.
[53:09.840 --> 53:11.840]  Но я же о конкретном варианте
[53:11.840 --> 53:13.840]  буду звать.
[53:13.840 --> 53:15.840]  Как мы будем
[53:15.840 --> 53:17.840]  понимать?
[53:17.840 --> 53:19.840]  Вот и вопрос, как мы сейчас будем понимать?
[53:19.840 --> 53:21.840]  Вот что нам нужно здесь написать?
[53:21.840 --> 53:23.840]  Нам нужна специализация для первого совпадающего...
[53:23.840 --> 53:25.840]  А, нет, это не то.
[53:25.840 --> 53:27.840]  На самом деле нам
[53:27.840 --> 53:29.840]  надо просто хранить в варианте...
[53:31.840 --> 53:33.840]  А какой индекс у нас?
[53:33.840 --> 53:35.840]  В смысле?
[53:35.840 --> 53:37.840]  Не понял. В смысле?
[53:37.840 --> 53:39.840]  В варианте
[53:39.840 --> 53:41.840]  буду помнить число, какая из
[53:41.840 --> 53:43.840]  альтернатив сейчас... Сейчас жива.
[53:43.840 --> 53:45.840]  А для гета нам не нужно?
[53:45.840 --> 53:47.840]  Что? Зачем нам это для гета?
[53:47.840 --> 53:49.840]  Нам это не нужно.
[53:49.840 --> 53:51.840]  А, для гета?
[53:51.840 --> 53:53.840]  А очень просто, я сейчас просто
[53:53.840 --> 53:55.840]  поспроверю, правда ли мой...
[53:55.840 --> 53:57.840]  Я сейчас напишу, если
[53:57.840 --> 53:59.840]  индекс,
[53:59.840 --> 54:01.840]  но это должна быть функция друг.
[54:01.840 --> 54:03.840]  Понятно.
[54:03.840 --> 54:05.840]  Я в чем проблема
[54:05.840 --> 54:07.840]  не хранить эту штуку вообще?
[54:07.840 --> 54:09.840]  Ну а как?
[54:09.840 --> 54:11.840]  Если сделаешь без нее, молодец.
[54:11.840 --> 54:13.840]  Если мы сравним нулю, ну,
[54:13.840 --> 54:15.840]  нуля почитаться туда, да?
[54:15.840 --> 54:17.840]  Нам нужно проверить, что мы
[54:17.840 --> 54:19.840]  правильно идем. Как ты поймешь, что ты
[54:19.840 --> 54:21.840]  дошел до нужного типа?
[54:21.840 --> 54:23.840]  Не-не-не.
[54:23.840 --> 54:25.840]  Если у тебя нету в варианте
[54:25.840 --> 54:27.840]  поля, который говорит, какой у тебя сейчас
[54:27.840 --> 54:29.840]  индекс. Мы сейчас по индекс
[54:29.840 --> 54:31.840]  уходим, по сайсте. Это мы поймем.
[54:31.840 --> 54:33.840]  Мы поймем, что мы дошли, но мы не поймем
[54:33.840 --> 54:35.840]  правды или что сейчас вариант...
[54:35.840 --> 54:37.840]  Так в этом и вопрос, да.
[54:37.840 --> 54:39.840]  Нужно, короче, исключение выкинуть, если мы...
[54:39.840 --> 54:41.840]  Если мы дошли...
[54:41.840 --> 54:43.840]  Мы же не должны делать
[54:43.840 --> 54:45.840]  get убейку. Мы должны ему кинуть
[54:45.840 --> 54:47.840]  exception, если он не обгадал
[54:47.840 --> 54:49.840]  номер.
[54:49.840 --> 54:51.840]  Иначе мы ничего не выиграем.
[54:51.840 --> 54:53.840]  Нет.
[54:53.840 --> 54:55.840]  Если сейчас активный тип,
[54:55.840 --> 54:57.840]  не тот, которого он попросил.
[54:59.840 --> 55:01.840]  Поэтому нам надо проверить,
[55:01.840 --> 55:03.840]  правда ли... Так, значит, что я сейчас написал?
[55:03.840 --> 55:05.840]  Friends здесь надо сказать.
[55:09.840 --> 55:11.840]  А если
[55:11.840 --> 55:13.840]  v.index
[55:13.840 --> 55:15.840]  не равно
[55:15.840 --> 55:17.840]  вот этот индекс,
[55:17.840 --> 55:19.840]  причем я не могу тут написать и в
[55:19.840 --> 55:21.840]  деспорте, потому что
[55:21.840 --> 55:23.840]  index это runtime вещь,
[55:23.840 --> 55:25.840]  index маленькая,
[55:25.840 --> 55:27.840]  то, значит, throw
[55:29.840 --> 55:31.840]  std, bet,
[55:31.840 --> 55:33.840]  variant,
[55:33.840 --> 55:35.840]  access.
[55:39.840 --> 55:41.840]  Вот.
[55:41.840 --> 55:43.840]  А, иначе, что сделать?
[55:43.840 --> 55:45.840]  Return, что?
[55:45.840 --> 55:47.840]  Get, index-1.
[55:49.840 --> 55:51.840]  Ну...
[55:51.840 --> 55:53.840]  Ну,
[55:53.840 --> 55:55.840]  здесь надо бы
[55:55.840 --> 55:57.840]  в самом...
[55:57.840 --> 55:59.840]  Вот тут
[55:59.840 --> 56:01.840]  я не хочу здесь рекурсию организовывать,
[56:01.840 --> 56:03.840]  потому что рекурсию надо организовать вот здесь.
[56:03.840 --> 56:05.840]  В самом
[56:05.840 --> 56:07.840]  union-е давайте
[56:07.840 --> 56:09.840]  напишем функцию, которая делает...
[56:09.840 --> 56:11.840]  Во-первых, нам понадобится функция get,
[56:11.840 --> 56:13.840]  ну а потом нам еще понадобится функция put,
[56:13.840 --> 56:15.840]  как мы вскоре выяснили.
[56:15.840 --> 56:17.840]  Давайте напишем функцию get в union-е.
[56:17.840 --> 56:19.840]  Metamget, который
[56:19.840 --> 56:21.840]  как раз
[56:21.840 --> 56:23.840]  ну вот
[56:23.840 --> 56:25.840]  у этого union-а просит
[56:25.840 --> 56:27.840]  соответствующий тип, то есть
[56:29.840 --> 56:31.840]  это будет
[56:31.840 --> 56:33.840]  шаблонная функция
[56:33.840 --> 56:35.840]  опять,
[56:35.840 --> 56:37.840]  template, type name,
[56:37.840 --> 56:39.840]  size t,
[56:39.840 --> 56:41.840]  index,
[56:41.840 --> 56:43.840]  type name,
[56:43.840 --> 56:45.840]  t,
[56:45.840 --> 56:47.840]  t,
[56:47.840 --> 56:49.840]  versant,
[56:49.840 --> 56:51.840]  get,
[56:51.840 --> 56:53.840]  on,
[56:53.840 --> 56:55.840]  ничего,
[56:55.840 --> 56:57.840]  без параметров.
[56:57.840 --> 56:59.840]  И что она будет делать?
[56:59.840 --> 57:01.840]  Ну, если
[57:01.840 --> 57:03.840]  if constexpr index 0,
[57:03.840 --> 57:05.840]  возвращаем hat.
[57:05.840 --> 57:07.840]  Да, if constexpr,
[57:07.840 --> 57:09.840]  уже здесь можно constexpr,
[57:09.840 --> 57:11.840]  if constexpr index
[57:11.840 --> 57:13.840]  равно 0,
[57:13.840 --> 57:15.840]  то
[57:15.840 --> 57:17.840]  return hat,
[57:19.840 --> 57:21.840]  а иначе
[57:23.840 --> 57:25.840]  тут вот я должен else писать,
[57:25.840 --> 57:27.840]  потому что у меня есть constexpr.
[57:27.840 --> 57:29.840]  tail.get
[57:29.840 --> 57:31.840]  return
[57:31.840 --> 57:33.840]  tail.get
[57:33.840 --> 57:35.840]  и вот тут мне
[57:35.840 --> 57:37.840]  надо писать template,
[57:37.840 --> 57:39.840]  потому что
[57:39.840 --> 57:41.840]  это зависимое имя,
[57:41.840 --> 57:43.840]  иначе они будут неоднозначны,
[57:43.840 --> 57:45.840]  с оператором меньше.
[57:45.840 --> 57:47.840]  template.get,
[57:47.840 --> 57:49.840]  index,
[57:49.840 --> 57:51.840]  minus 1,
[57:51.840 --> 57:53.840]  нахрена?
[57:53.840 --> 57:55.840]  куда передаём?
[57:55.840 --> 57:57.840]  в get
[57:57.840 --> 57:59.840]  потому что он должен понимать,
[57:59.840 --> 58:01.840]  что возвращается, иначе не сможем написать
[58:01.840 --> 58:03.840]  возвращаемый тип.
[58:03.840 --> 58:05.840]  Ну, template я не передаю
[58:05.840 --> 58:07.840]  в качестве параметра, я просто
[58:07.840 --> 58:09.840]  t он восстанавливает.
[58:09.840 --> 58:11.840]  Да, и он восстанавливает.
[58:11.840 --> 58:13.840]  Чем повреждут t & %?
[58:13.840 --> 58:15.840]  А где?
[58:15.840 --> 58:17.840]  Вместо t & %?
[58:17.840 --> 58:19.840]  Да.
[58:19.840 --> 58:21.840]  Кажется, что да.
[58:21.840 --> 58:23.840]  Кажется, что так должно работать.
[58:23.840 --> 58:25.840]  Расход поменьше.
[58:25.840 --> 58:27.840]  Да, действительно.
[58:27.840 --> 58:29.840]  Одновременно их.
[58:29.840 --> 58:31.840]  Это нормально?
[58:31.840 --> 58:33.840]  Кажется, должно работать.
[58:33.840 --> 58:35.840]  У нас сейчас шаблонный тип,
[58:35.840 --> 58:37.840]  у которого есть шаблонный union,
[58:37.840 --> 58:39.840]  у которого шаблонный метод.
[58:39.840 --> 58:41.840]  Ну, авто анкерсант
[58:41.840 --> 58:43.840]  так же как и t,
[58:43.840 --> 58:45.840]  анкерсант это нормально.
[58:45.840 --> 58:47.840]  Вот, хорошо, теперь мы можем...
[58:47.840 --> 58:49.840]  А, теперь у нас...
[58:49.840 --> 58:51.840]  А если мы попросили get
[58:51.840 --> 58:53.840]  от больше, чем
[58:53.840 --> 58:55.840]  pro было?
[58:55.840 --> 58:57.840]  Что здесь должно произойти?
[58:57.840 --> 58:59.840]  No such index.
[58:59.840 --> 59:01.840]  А как мы это поймём?
[59:01.840 --> 59:03.840]  Стоп, а почему pro вообще?
[59:03.840 --> 59:05.840]  А, потому что мы не можем...
[59:05.840 --> 59:07.840]  Что?
[59:07.840 --> 59:09.840]  У нас нет функции get, которая берёт
[59:09.840 --> 59:11.840]  индекс переменной.
[59:11.840 --> 59:13.840]  Нет, индекс только
[59:13.840 --> 59:15.840]  compound time может быть.
[59:15.840 --> 59:17.840]  Тогда можно не pro, а просто ce, всё нормально.
[59:17.840 --> 59:19.840]  Ну, значит, что-то не дойдёт.
[59:19.840 --> 59:21.840]  Если может ce, то можно...
[59:21.840 --> 59:23.840]  Он же сам сюда не придёт.
[59:23.840 --> 59:25.840]  Мы хотим ce, ce это лучше, чем re.
[59:25.840 --> 59:27.840]  Чё мы должны...
[59:27.840 --> 59:29.840]  Мы пустом union не говорим.
[59:29.840 --> 59:31.840]  Делить.
[59:31.840 --> 59:33.840]  Афа...
[59:33.840 --> 59:35.840]  Чего-чего-чего?
[59:35.840 --> 59:37.840]  Я вообще не показал, зачем...
[59:37.840 --> 59:39.840]  Ну, по ощущениям как...
[59:39.840 --> 59:41.840]  В варианте grand они не после
[59:41.840 --> 59:43.840]  такой числики созданы.
[59:43.840 --> 59:45.840]  В варианте grand.
[59:45.840 --> 59:47.840]  Вариант ради чего?
[59:47.840 --> 59:49.840]  Мы пока вообще не говорили о чём.
[59:49.840 --> 59:51.840]  То есть кажется, что он
[59:51.840 --> 59:53.840]  создан для более хитрых вещей,
[59:53.840 --> 59:55.840]  и нам всё открыто.
[59:55.840 --> 59:57.840]  Он создан для того,
[59:57.840 --> 59:59.840]  чтобы ты мог хранить
[59:59.840 --> 01:00:01.840]  одно из нескольких,
[01:00:01.840 --> 01:00:03.840]  чтобы у тебя не автоматически
[01:00:03.840 --> 01:00:05.840]  бы оно освобождалось, подчищалось правильно,
[01:00:05.840 --> 01:00:07.840]  когда ты меняешь одно на другое.
[01:00:07.840 --> 01:00:09.840]  Чтобы у тебя не было ub,
[01:00:09.840 --> 01:00:11.840]  когда ты прислаиваешь.
[01:00:11.840 --> 01:00:13.840]  Была строка, а стала int.
[01:00:13.840 --> 01:00:15.840]  Илья, пусть у меня
[01:00:15.840 --> 01:00:17.840]  вариант
[01:00:17.840 --> 01:00:19.840]  от четырёх аргументов.
[01:00:19.840 --> 01:00:21.840]  Я передал ему пять
[01:00:21.840 --> 01:00:23.840]  число. Вот что он сейчас
[01:00:23.840 --> 01:00:25.840]  пытается сделать.
[01:00:25.840 --> 01:00:27.840]  Он такой... Констекс продали,
[01:00:27.840 --> 01:00:29.840]  проверили, что не то, перешли,
[01:00:29.840 --> 01:00:31.840]  опачки, нету гет.
[01:00:31.840 --> 01:00:33.840]  Да, но вот мы придём сюда...
[01:00:33.840 --> 01:00:35.840]  Если он не писать,
[01:00:35.840 --> 01:00:37.840]  то он туда придёт и такой
[01:00:37.840 --> 01:00:39.840]  гет нету, CE.
[01:00:39.840 --> 01:00:41.840]  Мы же этого хотим.
[01:00:41.840 --> 01:00:43.840]  Ну, я думаю, что мы всё-таки хотим
[01:00:43.840 --> 01:00:45.840]  не совсем этого, мы хотим, наверное,
[01:00:45.840 --> 01:00:47.840]  чтобы он сказал что-то более умное, чем...
[01:00:47.840 --> 01:00:49.840]  Нужно вызвать CE с комментарием.
[01:00:49.840 --> 01:00:51.840]  Я хочу RE явно.
[01:00:51.840 --> 01:00:53.840]  Например, кстати,
[01:00:53.840 --> 01:00:55.840]  кассёр сейчас напишем.
[01:00:55.840 --> 01:00:57.840]  Да, сойдёт.
[01:00:57.840 --> 01:00:59.840]  И дальше такая вот чисто пас.
[01:00:59.840 --> 01:01:01.840]  Нет, нет, нет.
[01:01:19.840 --> 01:01:21.840]  Саня, а почему тебе никто не написал
[01:01:21.840 --> 01:01:23.840]  паксер, который будет
[01:01:23.840 --> 01:01:25.840]  вот эти ошибки, которые загоняешь и смотришь?
[01:01:25.840 --> 01:01:27.840]  Что это вообще значит?
[01:01:27.840 --> 01:01:29.840]  Перевод спрессованный.
[01:01:29.840 --> 01:01:31.840]  Такое есть.
[01:01:31.840 --> 01:01:33.840]  А почему нас это предоучили?
[01:01:33.840 --> 01:01:35.840]  Чтоб ты учился
[01:01:35.840 --> 01:01:37.840]  говорить с компилятором на ты.
[01:01:37.840 --> 01:01:39.840]  Я не хочу!
[01:01:39.840 --> 01:01:41.840]  Так вот, удаляем, давайте.
[01:01:41.840 --> 01:01:43.840]  Стартуем.
[01:01:45.840 --> 01:01:47.840]  Саня, а можно напомнить, пожалуйста,
[01:01:47.840 --> 01:01:49.840]  ещё зачем нам
[01:01:49.840 --> 01:01:51.840]  этот гарантий клюня, который...
[01:01:51.840 --> 01:01:53.840]  Зачем дарить? Вы же хотели
[01:01:53.840 --> 01:01:55.840]  оставить? Вы хотели
[01:01:55.840 --> 01:01:57.840]  оставить всё?
[01:01:59.840 --> 01:02:01.840]  Тут непонятно,
[01:02:01.840 --> 01:02:03.840]  когда что такое будет
[01:02:03.840 --> 01:02:05.840]  автоамперсант.
[01:02:09.840 --> 01:02:11.840]  А он и так был непонятным.
[01:02:13.840 --> 01:02:15.840]  Красивый комментарий.
[01:02:15.840 --> 01:02:17.840]  О, секунду, а почему void?
[01:02:17.840 --> 01:02:19.840]  Почему нельзя оттать на EPR?
[01:02:19.840 --> 01:02:21.840]  Просто статик сёрта.
[01:02:21.840 --> 01:02:23.840]  Ошибка к пиляции
[01:02:23.840 --> 01:02:25.840]  будет в момент, когда мы попытаемся
[01:02:25.840 --> 01:02:27.840]  его вернуть, разве нет, до того,
[01:02:27.840 --> 01:02:29.840]  как мы дойдём до статика сёрта.
[01:02:29.840 --> 01:02:31.840]  Ошибка к пиляции будет в момент,
[01:02:31.840 --> 01:02:33.840]  когда мы напишем return
[01:02:33.840 --> 01:02:35.840]  раньше, чем мы дойдём до статика сёрта.
[01:02:35.840 --> 01:02:37.840]  Потому что мы там пишем return tail.
[01:02:37.840 --> 01:02:39.840]  Так стоит get.
[01:02:39.840 --> 01:02:41.840]  Он просто не инстанцирует
[01:02:41.840 --> 01:02:43.840]  этот get. Если он дойдёт
[01:02:43.840 --> 01:02:45.840]  до инстанцирования этого get,
[01:02:45.840 --> 01:02:47.840]  то он сделает все get.
[01:02:47.840 --> 01:02:49.840]  Но если ему не придётся
[01:02:49.840 --> 01:02:51.840]  инстанцировать, то все get не нужно быть.
[01:02:51.840 --> 01:02:53.840]  Сейчас он всё равно ничего не скомплирует,
[01:02:53.840 --> 01:02:55.840]  потому что у нас много ещё проблем.
[01:02:55.840 --> 01:02:57.840]  Можно просто закомментировать весь main
[01:02:57.840 --> 01:02:59.840]  пока что, чтобы не мешало.
[01:02:59.840 --> 01:03:01.840]  А зачем нам писать более общий
[01:03:01.840 --> 01:03:03.840]  вариант кину на свёклу?
[01:03:05.840 --> 01:03:07.840]  Чтобы специализация была ниже,
[01:03:07.840 --> 01:03:09.840]  чем объявление.
[01:03:09.840 --> 01:03:11.840]  Это же специализация.
[01:03:19.840 --> 01:03:21.840]  Они достаточно крутые, шаблонные
[01:03:21.840 --> 01:03:23.840]  метрогамисты, чтобы понять,
[01:03:23.840 --> 01:03:25.840]  в каком порядке он будет падать.
[01:03:27.840 --> 01:03:29.840]  Давай просто int возвращай и всё.
[01:03:29.840 --> 01:03:31.840]  Ну, это как-то уж совсем.
[01:03:31.840 --> 01:03:33.840]  Лучше a хорошо.
[01:03:33.840 --> 01:03:35.840]  А void-impercent же корректная запись?
[01:03:35.840 --> 01:03:37.840]  Я не написал void-impercent.
[01:03:37.840 --> 01:03:39.840]  Нет, он попытается, он выведет,
[01:03:39.840 --> 01:03:41.840]  что ему вернули void, и такой
[01:03:41.840 --> 01:03:43.840]  void-impercent get.
[01:03:43.840 --> 01:03:45.840]  Да, это некорректно.
[01:03:45.840 --> 01:03:47.840]  Вот есть void?
[01:03:47.840 --> 01:03:49.840]  Нет, лучше у меня есть void-impercent.
[01:03:49.840 --> 01:03:51.840]  Чёрт с ним.
[01:03:51.840 --> 01:03:53.840]  Не знаю, что угодно здесь будет.
[01:03:53.840 --> 01:03:55.840]  Туду.
[01:03:57.840 --> 01:03:59.840]  Давайте
[01:03:59.840 --> 01:04:01.840]  согласен, что-нибудь более
[01:04:01.840 --> 01:04:03.840]  серьёзное реализуем.
[01:04:03.840 --> 01:04:05.840]  Вот, например, как...
[01:04:05.840 --> 01:04:07.840]  А, вот здесь return что надо написать?
[01:04:09.840 --> 01:04:11.840]  О, get.
[01:04:11.840 --> 01:04:13.840]  Ну, return storage.get.
[01:04:13.840 --> 01:04:15.840]  Вот index вот этот.
[01:04:15.840 --> 01:04:17.840]  Ну и, собственно, всё.
[01:04:17.840 --> 01:04:19.840]  Правда?
[01:04:19.840 --> 01:04:21.840]  Говорит, нас интересовало позже,
[01:04:21.840 --> 01:04:23.840]  чем тот, что...
[01:04:23.840 --> 01:04:25.840]  Вот.
[01:04:25.840 --> 01:04:27.840]  Значит, мы...
[01:04:27.840 --> 01:04:29.840]  Ну, в общем-то, вот, да.
[01:04:29.840 --> 01:04:31.840]  Мы здесь тоже вроде можем
[01:04:31.840 --> 01:04:33.840]  t убрать.
[01:04:33.840 --> 01:04:35.840]  По кайфу.
[01:04:35.840 --> 01:04:37.840]  Просто автоинтерсант?
[01:04:37.840 --> 01:04:39.840]  Ну, наверное, тоже можем, по правду.
[01:04:39.840 --> 01:04:41.840]  Так.
[01:04:41.840 --> 01:04:43.840]  Так, хорошо.
[01:04:47.840 --> 01:04:49.840]  Ну, как
[01:04:49.840 --> 01:04:51.840]  делать get по типу,
[01:04:51.840 --> 01:04:53.840]  а не по индексу?
[01:04:53.840 --> 01:04:55.840]  Ещё лучше.
[01:04:55.840 --> 01:04:57.840]  Это return v.storage.get.
[01:04:57.840 --> 01:04:59.840]  Да, v.storage.get.
[01:04:59.840 --> 01:05:01.840]  Как делать
[01:05:01.840 --> 01:05:03.840]  get по типу теперь?
[01:05:03.840 --> 01:05:05.840]  Давайте будем хранить.
[01:05:05.840 --> 01:05:07.840]  Понятное дело.
[01:05:07.840 --> 01:05:09.840]  Что за вопрос?
[01:05:09.840 --> 01:05:11.840]  Точно автоинтерсант?
[01:05:11.840 --> 01:05:13.840]  То есть мы в этом хейдинге
[01:05:13.840 --> 01:05:15.840]  как-нибудь опять...
[01:05:15.840 --> 01:05:17.840]  Хотя нет.
[01:05:17.840 --> 01:05:19.840]  Не, мы хотим ссылку
[01:05:19.840 --> 01:05:21.840]  именно на то, что там лежит.
[01:05:21.840 --> 01:05:23.840]  Именно объект. Этот автоинтерсант будет
[01:05:23.840 --> 01:05:25.840]  ровно тем типом, который ты дал
[01:05:25.840 --> 01:05:27.840]  варианту в начале.
[01:05:27.840 --> 01:05:29.840]  Чтоб ты ему не дал в начале, он его и вернёт.
[01:05:31.840 --> 01:05:33.840]  По крайней мере.
[01:05:33.840 --> 01:05:35.840]  Да, как делать
[01:05:35.840 --> 01:05:37.840]  get по типу?
[01:05:37.840 --> 01:05:39.840]  Вот задача предыдущая.
[01:05:39.840 --> 01:05:41.840]  Напишем пояс по типу индекса,
[01:05:41.840 --> 01:05:43.840]  а потом вернём по индексу.
[01:05:43.840 --> 01:05:45.840]  По типу индекса.
[01:05:45.840 --> 01:05:47.840]  Да, нам надо просто сделать get
[01:05:49.840 --> 01:05:51.840]  по такой...
[01:05:51.840 --> 01:05:53.840]  Ну, нам нужна вспомогательная...
[01:05:53.840 --> 01:05:55.840]  Нам нужна такая метафункция.
[01:05:55.840 --> 01:05:57.840]  get index by type.
[01:06:03.840 --> 01:06:05.840]  от
[01:06:05.840 --> 01:06:07.840]  где?
[01:06:07.840 --> 01:06:09.840]  types
[01:06:11.840 --> 01:06:13.840]  2.2.value
[01:06:13.840 --> 01:06:15.840]  Можно в стиле STL
[01:06:15.840 --> 01:06:17.840]  написать get index by type v.
[01:06:21.840 --> 01:06:23.840]  от
[01:06:23.840 --> 01:06:25.840]  v
[01:06:25.840 --> 01:06:27.840]  а
[01:06:27.840 --> 01:06:29.840]  как это будет работать, если у нас
[01:06:29.840 --> 01:06:31.840]  индекс будет...
[01:06:31.840 --> 01:06:33.840]  Давайте
[01:06:33.840 --> 01:06:35.840]  напишем метафункцию
[01:06:35.840 --> 01:06:37.840]  get index by type.
[01:06:37.840 --> 01:06:39.840]  get index by type
[01:06:39.840 --> 01:06:41.840]  это будет
[01:06:41.840 --> 01:06:43.840]  структура
[01:06:45.840 --> 01:06:47.840]  значит
[01:06:47.840 --> 01:06:49.840]  template, type name
[01:06:49.840 --> 01:06:51.840]  type name
[01:06:51.840 --> 01:06:53.840]  types
[01:06:53.840 --> 01:06:55.840]  структура
[01:06:57.840 --> 01:06:59.840]  get index by type
[01:07:05.840 --> 01:07:07.840]  static const
[01:07:07.840 --> 01:07:09.840]  size t
[01:07:09.840 --> 01:07:11.840]  индекс равно
[01:07:11.840 --> 01:07:13.840]  value
[01:07:13.840 --> 01:07:15.840]  равно чему?
[01:07:19.840 --> 01:07:21.840]  Тут надо
[01:07:21.840 --> 01:07:23.840]  опять с head и с tail
[01:07:23.840 --> 01:07:25.840]  Нет, это общая.
[01:07:25.840 --> 01:07:27.840]  Ну, общую, значит, я выше напишу.
[01:07:27.840 --> 01:07:29.840]  Что, да?
[01:07:29.840 --> 01:07:31.840]  Значит, основная какая?
[01:07:31.840 --> 01:07:33.840]  Если t это head,
[01:07:33.840 --> 01:07:35.840]  то, значит, это 0.
[01:07:37.840 --> 01:07:39.840]  А иначе это
[01:07:39.840 --> 01:07:41.840]  get index by type от
[01:07:41.840 --> 01:07:43.840]  t tail
[01:07:43.840 --> 01:07:45.840]  плюс 1, правильно?
[01:07:45.840 --> 01:07:47.840]  А нужно написать const export
[01:07:47.840 --> 01:07:49.840]  size t?
[01:07:49.840 --> 01:07:51.840]  Ну, не обязательно,
[01:07:51.840 --> 01:07:53.840]  поскольку мы еще не проходили,
[01:07:53.840 --> 01:07:55.840]  я не пишу. Но оно и так будет работать без него.
[01:07:55.840 --> 01:07:57.840]  Кого?
[01:07:57.840 --> 01:07:59.840]  Статик const export?
[01:07:59.840 --> 01:08:01.840]  Ну, еще
[01:08:01.840 --> 01:08:03.840]  писать const export, но оно
[01:08:03.840 --> 01:08:05.840]  и так будет работать.
[01:08:05.840 --> 01:08:07.840]  Почти без разницы.
[01:08:07.840 --> 01:08:09.840]  Статик const всегда const export?
[01:08:09.840 --> 01:08:11.840]  Ну, да.
[01:08:11.840 --> 01:08:13.840]  Потому что это одинаково будет.
[01:08:15.840 --> 01:08:17.840]  Вот.
[01:08:17.840 --> 01:08:19.840]  В,
[01:08:19.840 --> 01:08:21.840]  t, head.
[01:08:21.840 --> 01:08:23.840]  Вопросик, так сказать.
[01:08:23.840 --> 01:08:25.840]  Знак вопроса.
[01:08:25.840 --> 01:08:27.840]  А почему не const export?
[01:08:27.840 --> 01:08:29.840]  Знак вопроса и так const export?
[01:08:29.840 --> 01:08:31.840]  Ну, как? Это все в compile time.
[01:08:31.840 --> 01:08:33.840]  Статик const size t,
[01:08:33.840 --> 01:08:35.840]  его в compile time надо проницилизировать.
[01:08:35.840 --> 01:08:37.840]  Значит, он будет вот это все вычитать в compile time.
[01:08:37.840 --> 01:08:39.840]  Мы так проверку на простоту пытаемся
[01:08:39.840 --> 01:08:41.840]  вычислить.
[01:08:41.840 --> 01:08:43.840]  Conditional оно
[01:08:43.840 --> 01:08:45.840]  для типов.
[01:08:45.840 --> 01:08:47.840]  Условия тип, другой тип.
[01:08:47.840 --> 01:08:49.840]  А тут число должно быть.
[01:08:51.840 --> 01:08:53.840]  Тогда что?
[01:08:53.840 --> 01:08:55.840]  Тогда ноль. А иначе что?
[01:08:57.840 --> 01:08:59.840]  Yet index by type
[01:09:01.840 --> 01:09:03.840]  от
[01:09:03.840 --> 01:09:05.840]  tail
[01:09:07.840 --> 01:09:09.840]  value
[01:09:09.840 --> 01:09:11.840]  плюс один.
[01:09:11.840 --> 01:09:13.840]  Чего не хватает?
[01:09:13.840 --> 01:09:15.840]  Не хватает
[01:09:15.840 --> 01:09:17.840]  для обычно конца рекурсии
[01:09:17.840 --> 01:09:19.840]  template type name t
[01:09:19.840 --> 01:09:21.840]  и type name arcs, к сожалению,
[01:09:21.840 --> 01:09:23.840]  придется, потому что type name многоточие
[01:09:23.840 --> 01:09:25.840]  arcs
[01:09:25.840 --> 01:09:27.840]  type name многоточие
[01:09:27.840 --> 01:09:29.840]  types
[01:09:29.840 --> 01:09:31.840]  struct
[01:09:31.840 --> 01:09:33.840]  Иначе это не будет специализацией.
[01:09:33.840 --> 01:09:35.840]  Можно слово types не писать?
[01:09:35.840 --> 01:09:37.840]  Да.
[01:09:41.840 --> 01:09:43.840]  А
[01:09:45.840 --> 01:09:47.840]  что я здесь напишу?
[01:09:49.840 --> 01:09:51.840]  Если у меня
[01:09:51.840 --> 01:09:53.840]  оказалось, что я дошел
[01:09:53.840 --> 01:09:55.840]  до сюда, то что мне надо написать?
[01:09:55.840 --> 01:09:57.840]  Ничего.
[01:09:57.840 --> 01:09:59.840]  Кажется...
[01:09:59.840 --> 01:10:01.840]  Не, ну какой-то value здесь должно быть.
[01:10:01.840 --> 01:10:03.840]  Можно какой-то
[01:10:03.840 --> 01:10:05.840]  минус один.
[01:10:05.840 --> 01:10:07.840]  Ну, стандартная реализация
[01:10:07.840 --> 01:10:09.840]  она просто...
[01:10:09.840 --> 01:10:11.840]  Ну, тут я
[01:10:11.840 --> 01:10:13.840]  верну просто ноль,
[01:10:13.840 --> 01:10:15.840]  и там
[01:10:15.840 --> 01:10:17.840]  в итоге у меня получится n.
[01:10:17.840 --> 01:10:19.840]  Ну, то есть получится
[01:10:19.840 --> 01:10:21.840]  index, которого нет.
[01:10:21.840 --> 01:10:23.840]  Это логично.
[01:10:23.840 --> 01:10:25.840]  Я как бы
[01:10:25.840 --> 01:10:27.840]  возвращаю n
[01:10:27.840 --> 01:10:29.840]  в по сути.
[01:10:29.840 --> 01:10:31.840]  Возвращаю index после последнего.
[01:10:31.840 --> 01:10:33.840]  А почему статикасер?
[01:10:33.840 --> 01:10:35.840]  Статикасер где написать?
[01:10:35.840 --> 01:10:37.840]  Рано статикасер?
[01:10:37.840 --> 01:10:39.840]  Рано статикасер?
[01:10:39.840 --> 01:10:41.840]  Нет.
[01:10:41.840 --> 01:10:43.840]  Если мы попросили...
[01:10:43.840 --> 01:10:45.840]  Если напишешь
[01:10:45.840 --> 01:10:47.840]  статикасер в теле этого класса,
[01:10:47.840 --> 01:10:49.840]  то я боюсь, что он сработает
[01:10:49.840 --> 01:10:51.840]  без инстанцилирования даже.
[01:10:51.840 --> 01:10:53.840]  В смысле?
[01:10:53.840 --> 01:10:55.840]  Можно писать статикасер в ней методов?
[01:10:55.840 --> 01:10:57.840]  Нет, обязательно. Здесь я как раз не вижу
[01:10:57.840 --> 01:10:59.840]  повода на CE.
[01:10:59.840 --> 01:11:01.840]  Мы попросили тип, которого
[01:11:01.840 --> 01:11:03.840]  среди данного списка типов нет.
[01:11:03.840 --> 01:11:05.840]  И мы на этапе компиляции
[01:11:05.840 --> 01:11:07.840]  понимаем, что это так произошло.
[01:11:07.840 --> 01:11:09.840]  Мы вернем n.
[01:11:09.840 --> 01:11:11.840]  Я возвращаю номер, который больше,
[01:11:11.840 --> 01:11:13.840]  чем размер списка типов.
[01:11:13.840 --> 01:11:15.840]  Ошибка и так будет на этапе компиляции потом.
[01:11:15.840 --> 01:11:17.840]  Она просто не здесь вызовется, а там, где попросят...
[01:11:17.840 --> 01:11:19.840]  GetIndexByType
[01:11:19.840 --> 01:11:21.840]  по сути тебе говорит, он находит
[01:11:21.840 --> 01:11:23.840]  или возвращает n.
[01:11:23.840 --> 01:11:25.840]  Да.
[01:11:25.840 --> 01:11:27.840]  Было бы странно, если бы метафункция приводила
[01:11:27.840 --> 01:11:29.840]  к ошибке компиляции.
[01:11:29.840 --> 01:11:31.840]  Она либо находит и говорит index, либо говорит нет его.
[01:11:31.840 --> 01:11:33.840]  Не падает, а говорит, что его нет.
[01:11:33.840 --> 01:11:35.840]  Смысл вернуть n в том,
[01:11:35.840 --> 01:11:37.840]  что ты как бы возвращаешь
[01:11:37.840 --> 01:11:39.840]  ответ, что нет его.
[01:11:39.840 --> 01:11:41.840]  Вот.
[01:11:41.840 --> 01:11:43.840]  А здесь надо написать t,
[01:11:43.840 --> 01:11:45.840]  запятая head,
[01:11:45.840 --> 01:11:47.840]  запятая tail на доточке.
[01:11:47.840 --> 01:11:49.840]  Кажется вот так, иначе это не будет
[01:11:49.840 --> 01:11:51.840]  по связавшему, правда?
[01:11:51.840 --> 01:11:53.840]  Вот. И что дальше?
[01:11:53.840 --> 01:11:55.840]  Нужно еще
[01:11:55.840 --> 01:11:57.840]  GetIndexByType
[01:11:57.840 --> 01:11:59.840]  определить.
[01:11:59.840 --> 01:12:01.840]  Ну да.
[01:12:01.840 --> 01:12:03.840]  GetTypeName
[01:12:03.840 --> 01:12:05.840]  что угодно.
[01:12:13.840 --> 01:12:15.840]  Static...
[01:12:15.840 --> 01:12:17.840]  не статик...
[01:12:17.840 --> 01:12:19.840]  const...
[01:12:19.840 --> 01:12:21.840]  джузинг?
[01:12:21.840 --> 01:12:23.840]  constexpr, sizeT
[01:12:23.840 --> 01:12:25.840]  constexpr значит константа времени компиляции.
[01:12:25.840 --> 01:12:27.840]  sizeT
[01:12:27.840 --> 01:12:29.840]  get
[01:12:29.840 --> 01:12:31.840]  index
[01:12:31.840 --> 01:12:33.840]  by type
[01:12:33.840 --> 01:12:35.840]  v
[01:12:35.840 --> 01:12:37.840]  равно
[01:12:37.840 --> 01:12:39.840]  get index
[01:12:39.840 --> 01:12:41.840]  by type port types
[01:12:41.840 --> 01:12:43.840]  многоточие value.
[01:12:43.840 --> 01:12:45.840]  Вот.
[01:12:45.840 --> 01:12:47.840]  Ну и теперь просто, если мы хотим
[01:12:47.840 --> 01:12:49.840]  сделать get по типу,
[01:12:49.840 --> 01:12:51.840]  ну вот все у нас написано.
[01:12:53.840 --> 01:12:55.840]  А, это get по индексу и по типу?
[01:12:55.840 --> 01:12:57.840]  Да, это get по индексу и get по типу.
[01:12:57.840 --> 01:12:59.840]  Get по типу, мы селили get по индексу.
[01:13:03.840 --> 01:13:05.840]  GetIndexByType?
[01:13:19.840 --> 01:13:21.840]  Вот.
[01:13:21.840 --> 01:13:23.840]  Теперь самое интересное.
[01:13:23.840 --> 01:13:25.840]  Ну мы написали get.
[01:13:25.840 --> 01:13:27.840]  Но это не интересно тоже.
[01:13:27.840 --> 01:13:29.840]  Понятно, как написать hold за интернете.
[01:13:29.840 --> 01:13:31.840]  Типа, что get возвращает...
[01:13:31.840 --> 01:13:33.840]  Get не кинул.
[01:13:33.840 --> 01:13:35.840]  Фактически.
[01:13:35.840 --> 01:13:37.840]  Ну нет, через исключение...
[01:13:37.840 --> 01:13:39.840]  Это медленно, но можно их
[01:13:39.840 --> 01:13:41.840]  переписать.
[01:13:41.840 --> 01:13:43.840]  Ну просто ту же самую рекурсию.
[01:13:43.840 --> 01:13:45.840]  Только, ну что, я просто
[01:13:45.840 --> 01:13:47.840]  разматываю, проверяю,
[01:13:47.840 --> 01:13:49.840]  что...
[01:13:49.840 --> 01:13:51.840]  Ну, мне, наверное,
[01:13:51.840 --> 01:13:53.840]  надо будет сделать наоборот еще
[01:13:53.840 --> 01:13:55.840]  GetIndexByIndex.
[01:13:55.840 --> 01:13:57.840]  То есть, мне говорят...
[01:13:57.840 --> 01:13:59.840]  Сейчас, почему нет взять что-то...
[01:13:59.840 --> 01:14:01.840]  Меня спрашивают, правда ли hold за
[01:14:01.840 --> 01:14:03.840]  интернете в такой-то тип?
[01:14:03.840 --> 01:14:05.840]  Я понимаю, какой индекс у этого типа.
[01:14:05.840 --> 01:14:07.840]  Через ту же метафункцию getIndexByType.
[01:14:07.840 --> 01:14:09.840]  И разматываю рекурсию, пока...
[01:14:09.840 --> 01:14:11.840]  Зачем разматывать? Можно проверить, что
[01:14:11.840 --> 01:14:13.840]  в этой точке индексовый индекс.
[01:14:13.840 --> 01:14:15.840]  Даже проще.
[01:14:15.840 --> 01:14:17.840]  И просто проверяю, что индекс
[01:14:17.840 --> 01:14:19.840]  в моем варианте, это вот тот самый
[01:14:19.840 --> 01:14:21.840]  getIndexByType. Все.
[01:14:21.840 --> 01:14:23.840]  Это не интересно.
[01:14:23.840 --> 01:14:25.840]  Самое интересное. Конструкторы.
[01:14:25.840 --> 01:14:27.840]  Как
[01:14:27.840 --> 01:14:29.840]  создаваться в всей этой моде?
[01:14:29.840 --> 01:14:31.840]  Мы пока написали классные вспыхательные функции,
[01:14:31.840 --> 01:14:33.840]  но мы не написали самого главного.
[01:14:33.840 --> 01:14:35.840]  Как конструк... У вас
[01:14:35.840 --> 01:14:37.840]  следующая пара во сколько начинается? Уже начинается?
[01:14:37.840 --> 01:14:39.840]  У кого-то она вообще есть?
[01:14:39.840 --> 01:14:41.840]  Да, у всех есть.
[01:14:41.840 --> 01:14:43.840]  Ну, вообще-то 16.55
[01:14:43.840 --> 01:14:45.840]  по расписанию DNS.
[01:14:45.840 --> 01:14:47.840]  Ого.
[01:14:47.840 --> 01:14:49.840]  А можно вопрос?
[01:14:49.840 --> 01:14:51.840]  У меня лично...
[01:14:51.840 --> 01:14:53.840]  Это статик ассорт в IDQ не...
[01:14:53.840 --> 01:14:55.840]  Ну, там, пустой.
[01:14:55.840 --> 01:14:57.840]  Он падает автоматически.
[01:14:57.840 --> 01:14:59.840]  Все равно падает.
[01:14:59.840 --> 01:15:01.840]  Что с этим делать?
[01:15:01.840 --> 01:15:03.840]  Вот думали пока.
[01:15:03.840 --> 01:15:05.840]  Вот он и мне упал, поэтому я его
[01:15:05.840 --> 01:15:07.840]  закомментировал.
[01:15:07.840 --> 01:15:09.840]  Типа NABL?
[01:15:09.840 --> 01:15:11.840]  Не, а проблема ли у нас
[01:15:11.840 --> 01:15:13.840]  не в случае?
[01:15:13.840 --> 01:15:15.840]  Не особо.
[01:15:15.840 --> 01:15:17.840]  Я вообще, ребята, простой, вижу статик
[01:15:17.840 --> 01:15:19.840]  ассорт.
[01:15:19.840 --> 01:15:21.840]  Ну...
[01:15:25.840 --> 01:15:27.840]  Почему он его инстанцирует?
[01:15:27.840 --> 01:15:29.840]  А он не имеет права?
[01:15:29.840 --> 01:15:31.840]  А почему должен?
[01:15:31.840 --> 01:15:33.840]  Нет, статик ассорт фолс он просто может
[01:15:33.840 --> 01:15:35.840]  проинстанцировать... Я думаю, что надо просто
[01:15:35.840 --> 01:15:37.840]  делать статик ассорт, зависимый от индекса.
[01:15:37.840 --> 01:15:39.840]  Тогда он не сможет его проинстанцировать,
[01:15:39.840 --> 01:15:41.840]  пока индекс не будет подставлен.
[01:15:41.840 --> 01:15:43.840]  Вот. Но просто статик ассорт фолс
[01:15:43.840 --> 01:15:45.840]  компилятор сразу видит.
[01:15:45.840 --> 01:15:47.840]  Я просто простой.
[01:15:47.840 --> 01:15:49.840]  Просто когда ты пишешь статик ассорт,
[01:15:49.840 --> 01:15:51.840]  фолс это, вероятно, означает, что ты хочешь,
[01:15:51.840 --> 01:15:53.840]  чтобы было в ЦЕ гарантировано.
[01:15:53.840 --> 01:15:55.840]  Вот.
[01:15:55.840 --> 01:15:57.840]  Вероятно.
[01:15:57.840 --> 01:15:59.840]  Да.
[01:15:59.840 --> 01:16:01.840]  Очень жалко, что конструкторы
[01:16:01.840 --> 01:16:03.840]  не отсубили.
[01:16:03.840 --> 01:16:05.840]  Давайте пока хотя бы идею,
[01:16:05.840 --> 01:16:07.840]  а как реализовать конструкторы?
[01:16:07.840 --> 01:16:09.840]  Мне надо, чтобы у него...
[01:16:09.840 --> 01:16:11.840]  Поддержать муфтемантику.
[01:16:11.840 --> 01:16:13.840]  Да подожди ты с муфтемантикой со своей
[01:16:13.840 --> 01:16:15.840]  она не моя.
[01:16:15.840 --> 01:16:17.840]  Везде теперь будущего спиннажера.
[01:16:17.840 --> 01:16:19.840]  У нас другая уже, другие проблемы, новые.
[01:16:19.840 --> 01:16:21.840]  Нам нужно, чтобы вариант
[01:16:21.840 --> 01:16:23.840]  умел конструироваться
[01:16:23.840 --> 01:16:25.840]  от всех типов,
[01:16:25.840 --> 01:16:27.840]  которые
[01:16:27.840 --> 01:16:29.840]  перечислены в этом
[01:16:29.840 --> 01:16:31.840]  types. Не только.
[01:16:31.840 --> 01:16:33.840]  И не только, причем от них, да.
[01:16:33.840 --> 01:16:35.840]  И не только их наследников.
[01:16:35.840 --> 01:16:37.840]  Надо, чтобы
[01:16:37.840 --> 01:16:39.840]  вариант умел
[01:16:39.840 --> 01:16:41.840]  выбирать. Вот его
[01:16:41.840 --> 01:16:43.840]  конструили от какого-то типа, а он такой
[01:16:43.840 --> 01:16:45.840]  а какой из вот этих вот типов
[01:16:45.840 --> 01:16:47.840]  лучше всего подходит?
[01:16:47.840 --> 01:16:49.840]  И его вот нужно
[01:16:49.840 --> 01:16:51.840]  И если какие-то подходят от
[01:16:51.840 --> 01:16:53.840]  одинаковых хорошо, то еще и выкинутся.
[01:16:53.840 --> 01:16:55.840]  А если какие-то подходят от одинаковых хорошо, то ЦЕ должно быть.
[01:16:55.840 --> 01:16:57.840]  Мы от флопа
[01:16:57.840 --> 01:16:59.840]  даббл конструировать умеем.
[01:16:59.840 --> 01:17:01.840]  Спокойно.
[01:17:01.840 --> 01:17:03.840]  И он передал, что вот мы такие
[01:17:03.840 --> 01:17:05.840]  расширения здесь надо как-то
[01:17:05.840 --> 01:17:07.840]  воспользоваться стандаками.
[01:17:07.840 --> 01:17:09.840]  Хотелось бы чем-нибудь STD
[01:17:09.840 --> 01:17:11.840]  Сделай, пожалуйста.
[01:17:15.840 --> 01:17:17.840]  Надо все так, чтобы это было
[01:17:17.840 --> 01:17:19.840]  разрешение на перегрузку
[01:17:19.840 --> 01:17:21.840]  разных конструктов.
[01:17:21.840 --> 01:17:23.840]  Может быть, я не знаю,
[01:17:23.840 --> 01:17:25.840]  определить внутри варианта
[01:17:25.840 --> 01:17:27.840]  конструктора,
[01:17:27.840 --> 01:17:29.840]  чтобы все конструк...
[01:17:29.840 --> 01:17:31.840]  Сейчас.
[01:17:31.840 --> 01:17:33.840]  Понятно, что уже шаблонный
[01:17:33.840 --> 01:17:35.840]  конструктор от чего угодно.
[01:17:35.840 --> 01:17:37.840]  Да. Внутри.
[01:17:37.840 --> 01:17:39.840]  Попутаться, типа, сконструировать надо все
[01:17:39.840 --> 01:17:41.840]  и в таком счетчик вести,
[01:17:41.840 --> 01:17:43.840]  типа, удалось или нет, у нас чрезвычайно
[01:17:43.840 --> 01:17:45.840]  очень дико. Нет, ну не так надо.
[01:17:47.840 --> 01:17:49.840]  Что происходит?
[01:17:51.840 --> 01:17:53.840]  Вариант Helper
[01:17:53.840 --> 01:17:55.840]  Вариант конструктор Helper
[01:17:57.840 --> 01:17:59.840]  А, я видел где-то это по поводу сочетания.
[01:18:01.840 --> 01:18:03.840]  Это что?
[01:18:03.840 --> 01:18:05.840]  Это базоварианта.
[01:18:05.840 --> 01:18:07.840]  База. Это база, ребята.
[01:18:09.840 --> 01:18:11.840]  Смотрите.
[01:18:13.840 --> 01:18:15.840]  Я сейчас скажу,
[01:18:15.840 --> 01:18:17.840]  что мой вариант
[01:18:17.840 --> 01:18:19.840]  это
[01:18:19.840 --> 01:18:21.840]  приватный
[01:18:25.840 --> 01:18:27.840]  приватный наследник.
[01:18:29.840 --> 01:18:31.840]  Наверное, все-таки назовут не вариант
[01:18:31.840 --> 01:18:33.840]  base, а вариант
[01:18:33.840 --> 01:18:35.840]  choice.
[01:18:37.840 --> 01:18:39.840]  Вариант Alternative.
[01:18:39.840 --> 01:18:41.840]  Ну хорошо, вариант Alternative.
[01:18:41.840 --> 01:18:43.840]  Вариант Alternative
[01:18:47.840 --> 01:18:49.840]  Вариант Alternative.
[01:18:49.840 --> 01:18:51.840]  И до этого просто
[01:18:51.840 --> 01:18:53.840]  нереально догадаться. От чего?
[01:18:53.840 --> 01:18:55.840]  От следующего.
[01:18:55.840 --> 01:18:57.840]  Что это что?
[01:18:57.840 --> 01:18:59.840]  Мне здесь надо
[01:18:59.840 --> 01:19:01.840]  написать вот что.
[01:19:01.840 --> 01:19:03.840]  Types
[01:19:03.840 --> 01:19:05.840]  многоточие
[01:19:05.840 --> 01:19:07.840]  многоточие
[01:19:13.840 --> 01:19:15.840]  У меня будет наследников
[01:19:15.840 --> 01:19:17.840]  родителей столько, сколько
[01:19:17.840 --> 01:19:19.840]  типов в пакете.
[01:19:19.840 --> 01:19:21.840]  Как это партится?
[01:19:21.840 --> 01:19:23.840]  У меня остается
[01:19:23.840 --> 01:19:25.840]  вот это многоточие, оно
[01:19:25.840 --> 01:19:27.840]  привязывается к вот этому и распаковывается
[01:19:27.840 --> 01:19:29.840]  тут, а вот это многоточие
[01:19:29.840 --> 01:19:31.840]  считает мне через запятую наследников.
[01:19:31.840 --> 01:19:33.840]  Ну то есть у нас будет вариант Alternative
[01:19:33.840 --> 01:19:35.840]  с каждым типом.
[01:19:35.840 --> 01:19:37.840]  Types одинаковые.
[01:19:39.840 --> 01:19:41.840]  И каждому из этих вариантов Alternative
[01:19:41.840 --> 01:19:43.840]  я создам конструктор
[01:19:43.840 --> 01:19:45.840]  от соответствующего Types.
[01:19:45.840 --> 01:19:47.840]  А потом здесь пишу using
[01:19:47.840 --> 01:19:49.840]  все эти конструкторы.
[01:19:49.840 --> 01:19:51.840]  template, все эти конструкторы.
[01:19:51.840 --> 01:19:53.840]  Нет!
[01:19:53.840 --> 01:19:55.840]  Нет!
[01:19:57.840 --> 01:19:59.840]  Нет!
[01:20:01.840 --> 01:20:03.840]  Сейчас, а как эти конструкторы будут работать?
[01:20:03.840 --> 01:20:05.840]  Как эти конструкторы, что они будут
[01:20:05.840 --> 01:20:07.840]  построировать?
[01:20:07.840 --> 01:20:09.840]  Type name
[01:20:13.840 --> 01:20:15.840]  Types, using
[01:20:15.840 --> 01:20:17.840]  вариант
[01:20:23.840 --> 01:20:25.840]  Alternative
[01:20:25.840 --> 01:20:27.840]  Вот эти два типа
[01:20:27.840 --> 01:20:29.840]  и вот TS
[01:20:29.840 --> 01:20:31.840]  там точка они
[01:20:31.840 --> 01:20:33.840]  затекаются.
[01:20:33.840 --> 01:20:35.840]  Нет, Types многоточие
[01:20:35.840 --> 01:20:37.840]  2.2.
[01:20:37.840 --> 01:20:39.840]  вариант
[01:20:39.840 --> 01:20:41.840]  Alternative
[01:20:41.840 --> 01:20:43.840]  и все.
[01:20:45.840 --> 01:20:47.840]  Что, кучку так?
[01:20:47.840 --> 01:20:49.840]  Так нет, это неправильный синтакс
[01:20:49.840 --> 01:20:51.840]  Type name T просто, разве нет?
[01:20:51.840 --> 01:20:53.840]  Нет, для каждого это должно быть.
[01:20:53.840 --> 01:20:55.840]  Для каждого
[01:20:55.840 --> 01:20:57.840]  наш родитель, а наши родители это вариант
[01:20:57.840 --> 01:20:59.840]  Alternative типы.
[01:20:59.840 --> 01:21:01.840]  Но они проинциализированы чем-то, что?
[01:21:01.840 --> 01:21:03.840]  Сейчас.
[01:21:03.840 --> 01:21:05.840]  Мы хотим использовать все их вот так.
[01:21:05.840 --> 01:21:07.840]  Мы хотим
[01:21:07.840 --> 01:21:09.840]  все их конструкторы использовать.
[01:21:09.840 --> 01:21:11.840]  Я че это?
[01:21:11.840 --> 01:21:13.840]  Не знаю, либо
[01:21:13.840 --> 01:21:15.840]  как они могут это консервировать?
[01:21:15.840 --> 01:21:17.840]  Так, кажется, что
[01:21:17.840 --> 01:21:19.840]  мне вообще не нужно здесь было писать
[01:21:19.840 --> 01:21:21.840]  темплей, а нужно было написать вот так.
[01:21:21.840 --> 01:21:23.840]  Нет.
[01:21:23.840 --> 01:21:25.840]  Yes.
[01:21:25.840 --> 01:21:27.840]  Yes.
[01:21:27.840 --> 01:21:29.840]  Так, вопрос.
[01:21:29.840 --> 01:21:31.840]  Как эти конструкторы
[01:21:31.840 --> 01:21:33.840]  к нашему сториджу имеют отношение?
[01:21:33.840 --> 01:21:35.840]  Они же
[01:21:35.840 --> 01:21:37.840]  вообще не могут наш сторидж
[01:21:37.840 --> 01:21:39.840]  конструировать.
[01:21:39.840 --> 01:21:41.840]  Сейчас смогут.
[01:21:41.840 --> 01:21:43.840]  Смотрите.
[01:21:43.840 --> 01:21:45.840]  Это же конструкторы вариант Alternative.
[01:21:45.840 --> 01:21:47.840]  Это приватные штуки.
[01:21:47.840 --> 01:21:49.840]  СФТП, по сути.
[01:21:49.840 --> 01:21:51.840]  Heuristic Recurrent Template Pattern. Кто помнит, что это такое?
[01:21:51.840 --> 01:21:53.840]  Я наследуюсь
[01:21:53.840 --> 01:21:55.840]  от некой штуки,
[01:21:55.840 --> 01:21:57.840]  которая на самом деле
[01:21:57.840 --> 01:21:59.840]  знает, что она сама
[01:21:59.840 --> 01:22:01.840]  по себе никогда не существует.
[01:22:01.840 --> 01:22:03.840]  И этот вариант
[01:22:03.840 --> 01:22:05.840]  Alternative знаешь, что на самом деле
[01:22:05.840 --> 01:22:07.840]  он всегда вариант.
[01:22:07.840 --> 01:22:09.840]  Он
[01:22:09.840 --> 01:22:11.840]  будет
[01:22:11.840 --> 01:22:13.840]  знать, что
[01:22:13.840 --> 01:22:15.840]  на самом деле
[01:22:17.840 --> 01:22:19.840]  у него
[01:22:19.840 --> 01:22:21.840]  есть сын,
[01:22:21.840 --> 01:22:23.840]  которого зовут вариант.
[01:22:23.840 --> 01:22:25.840]  Только мне
[01:22:25.840 --> 01:22:27.840]  предварительно нужно объявить
[01:22:31.840 --> 01:22:33.840]  вариант, потому что иначе
[01:22:33.840 --> 01:22:35.840]  он. Нет, понятно.
[01:22:35.840 --> 01:22:37.840]  Вот.
[01:22:37.840 --> 01:22:39.840]  Вот этот вот будет
[01:22:39.840 --> 01:22:41.840]  его сыном.
[01:22:41.840 --> 01:22:43.840]  И
[01:22:43.840 --> 01:22:45.840]  что будет
[01:22:45.840 --> 01:22:47.840]  делать
[01:22:47.840 --> 01:22:49.840]  эта сволочь? Она будет
[01:22:49.840 --> 01:22:51.840]  создаваться уметь от
[01:22:51.840 --> 01:22:53.840]  соответствующего Т?
[01:22:59.840 --> 01:23:01.840]  И что будет делать
[01:23:01.840 --> 01:23:03.840]  она?
[01:23:03.840 --> 01:23:05.840]  Она будет брать, делать
[01:23:05.840 --> 01:23:07.840]  статикаст себя.
[01:23:07.840 --> 01:23:09.840]  Дирайв.
[01:23:11.840 --> 01:23:13.840]  И туда в сторидж писать
[01:23:13.840 --> 01:23:15.840]  в нею типа Т.
[01:23:15.840 --> 01:23:17.840]  А почему
[01:23:17.840 --> 01:23:19.840]  он только должен?
[01:23:19.840 --> 01:23:21.840]  Статикаст наследнику.
[01:23:21.840 --> 01:23:23.840]  Да, если ты наследник.
[01:23:23.840 --> 01:23:25.840]  А почему
[01:23:25.840 --> 01:23:27.840]  мы больше принимаем только 100%
[01:23:27.840 --> 01:23:29.840]  value?
[01:23:29.840 --> 01:23:31.840]  Ну, это потому, что остальное потом сами
[01:23:31.840 --> 01:23:33.840]  допишется. Ещё нужно с мулом правильно.
[01:23:33.840 --> 01:23:35.840]  Так нет, мы разве не должны
[01:23:35.840 --> 01:23:37.840]  любой конструктур каждого из типов
[01:23:37.840 --> 01:23:39.840]  наших внутренних? Или только сами типы?
[01:23:39.840 --> 01:23:41.840]  Нет-нет-нет. Вариант Alternative
[01:23:41.840 --> 01:23:43.840]  соответствующий типу Т.
[01:23:43.840 --> 01:23:45.840]  Для всех Т.
[01:23:45.840 --> 01:23:47.840]  У меня будет столько конструкторов,
[01:23:47.840 --> 01:23:49.840]  сколько вариантов.
[01:23:49.840 --> 01:23:51.840]  Нет-нет-нет. Почему, например, если у нас есть сложный тип,
[01:23:51.840 --> 01:23:53.840]  который умеет конструироваться, ну, у него конструктор,
[01:23:53.840 --> 01:23:55.840]  принимать 5 аргументов, почему мы не можем написать...
[01:23:55.840 --> 01:23:57.840]  Ну, он implicit нас конструирует.
[01:23:57.840 --> 01:23:59.840]  Если у него explicit конструктор,
[01:23:59.840 --> 01:24:01.840]  то тебе всё равно будет explicit конструировать.
[01:24:01.840 --> 01:24:03.840]  Окей, всё нормально.
[01:24:03.840 --> 01:24:05.840]  Нет-нет-нет. Если у тебя...
[01:24:05.840 --> 01:24:07.840]  Ты не можешь конструировать
[01:24:07.840 --> 01:24:09.840]  вариант от
[01:24:09.840 --> 01:24:11.840]  Этого же другое, это in-place надо тогда делать.
[01:24:11.840 --> 01:24:13.840]  Ты можешь вариант прислать
[01:24:13.840 --> 01:24:15.840]  объект одного из типов,
[01:24:15.840 --> 01:24:17.840]  которым ты послал конструкцию.
[01:24:17.840 --> 01:24:19.840]  Так вот, я скажу Static Cast
[01:24:21.840 --> 01:24:23.840]  к Дирай в Тайперсанду, к Дирай в Зёрдочке.
[01:24:23.840 --> 01:24:25.840]  Всё, ладно, надо заканчивать.
[01:24:25.840 --> 01:24:27.840]  Реинтерпрет.
[01:24:27.840 --> 01:24:29.840]  От Vis. Нет, Static.
[01:24:29.840 --> 01:24:31.840]  Мне не нужен реинтерпрет, потому что я
[01:24:31.840 --> 01:24:33.840]  кастуюсь к своему сыну.
[01:24:33.840 --> 01:24:35.840]  Это безопасно.
[01:24:35.840 --> 01:24:37.840]  Может быть с тем же...
[01:24:37.840 --> 01:24:39.840]  Да, есть.
[01:24:39.840 --> 01:24:41.840]  Реинтерпрет может
[01:24:41.840 --> 01:24:43.840]  действовать неправильно.
[01:24:43.840 --> 01:24:45.840]  Да, потому что у нас же множество расследования.
[01:24:45.840 --> 01:24:47.840]  Это нормально?
[01:24:47.840 --> 01:24:49.840]  Ну, у нас не пустые, поэтому...
[01:24:49.840 --> 01:24:51.840]  Почему-то наш неправильно действует.
[01:24:51.840 --> 01:24:53.840]  Ну, здесь не может...
[01:24:53.840 --> 01:24:55.840]  Зачем писать реинтерпрет, если и Static
[01:24:55.840 --> 01:24:57.840]  сделает то же самое?
[01:24:57.840 --> 01:24:59.840]  Реинтерпрет это
[01:24:59.840 --> 01:25:01.840]  тяжёлое оружие.
[01:25:01.840 --> 01:25:03.840]  Зачем Static сделать то же самое
[01:25:03.840 --> 01:25:05.840]  и правильно, гарантированно, даже если
[01:25:05.840 --> 01:25:07.840]  не так с реинтерпретом?
[01:25:07.840 --> 01:25:09.840]  Static as derived Vis.
[01:25:09.840 --> 01:25:11.840]  Стрелочка что? Storage.
[01:25:11.840 --> 01:25:13.840]  В смысле?
[01:25:13.840 --> 01:25:15.840]  Static настолько же безопасный,
[01:25:15.840 --> 01:25:17.840]  насколько реинтерпрет.
[01:25:17.840 --> 01:25:19.840]  Да какая разница?
[01:25:19.840 --> 01:25:21.840]  Нет, не настолько же безопасный.
[01:25:21.840 --> 01:25:23.840]  Static проверяет, он
[01:25:23.840 --> 01:25:25.840]  делает правильные сдвиги, если вдруг они
[01:25:25.840 --> 01:25:27.840]  будут нужны и так далее.
[01:25:27.840 --> 01:25:29.840]  Хороший тон пользу Static, когда им нужно именно Static
[01:25:29.840 --> 01:25:31.840]  в этом идее.
[01:25:31.840 --> 01:25:33.840]  Static, например,
[01:25:33.840 --> 01:25:35.840]  сделает правильный сдвиг, если надо.
[01:25:35.840 --> 01:25:37.840]  Static, например, проверит
[01:25:37.840 --> 01:25:39.840]  приватность, если ты её случайно
[01:25:39.840 --> 01:25:41.840]  нарушил.
[01:25:41.840 --> 01:25:43.840]  Так вот.
[01:25:43.840 --> 01:25:45.840]  Ну, так вот, точка storage.
[01:25:45.840 --> 01:25:47.840]  А, кстати, а как можно
[01:25:47.840 --> 01:25:49.840]  делать Static as, если он private наследник?
[01:25:49.840 --> 01:25:51.840]  Он сам разве знает,
[01:25:51.840 --> 01:25:53.840]  что от него наследуется?
[01:25:55.840 --> 01:25:57.840]  Static as знает ли, что это
[01:25:57.840 --> 01:25:59.840]  наследование? Правильно, он не знает.
[01:25:59.840 --> 01:26:01.840]  Вариант alternative не знает,
[01:26:01.840 --> 01:26:03.840]  что вариант является
[01:26:03.840 --> 01:26:05.840]  наследником варианта alternative.
[01:26:05.840 --> 01:26:07.840]  Поэтому вариант должен сделать другом
[01:26:07.840 --> 01:26:09.840]  вариант alternative.
[01:26:09.840 --> 01:26:11.840]  Это правильно.
[01:26:11.840 --> 01:26:13.840]  Сейчас вариант alternative, сейчас компилятор
[01:26:13.840 --> 01:26:15.840]  заугается, скажет, что
[01:26:15.840 --> 01:26:17.840]  Static as не может кастовать,
[01:26:17.840 --> 01:26:19.840]  потому что вариант alternative
[01:26:19.840 --> 01:26:21.840]  не...
[01:26:21.840 --> 01:26:23.840]  Потому что вариант,
[01:26:23.840 --> 01:26:25.840]  это приватный наследник варианта alternative,
[01:26:25.840 --> 01:26:27.840]  и никто, включая самого вариант
[01:26:27.840 --> 01:26:29.840]  alternative, не должен знать о том, что вариант
[01:26:29.840 --> 01:26:31.840]  его наследник.
[01:26:31.840 --> 01:26:33.840]  Но мы сейчас
[01:26:33.840 --> 01:26:35.840]  в варианте напишем, что вариант alternative
[01:26:35.840 --> 01:26:37.840]  это друг, и вариант alternative будет знать,
[01:26:37.840 --> 01:26:39.840]  что вариант его наследника Static as будет работать.
[01:26:41.840 --> 01:26:43.840]  Вот, а что надо
[01:26:43.840 --> 01:26:45.840]  сделать? Static as дыря вис
[01:26:45.840 --> 01:26:47.840]  storage что?
[01:26:47.840 --> 01:26:49.840]  Там будет template put at value.
[01:26:49.840 --> 01:26:51.840]  Да, да, да, да.
[01:26:51.840 --> 01:26:53.840]  Нам нужен метод
[01:26:53.840 --> 01:26:55.840]  в storage ещё сделать put, я как говорил.
[01:26:55.840 --> 01:26:57.840]  Нам нужно сделать метод put
[01:26:59.840 --> 01:27:01.840]  template
[01:27:03.840 --> 01:27:05.840]  от t
[01:27:05.840 --> 01:27:07.840]  value.
[01:27:07.840 --> 01:27:09.840]  Ну а метод put надо реализовать.
[01:27:11.840 --> 01:27:13.840]  Там налогет, видимо.
[01:27:13.840 --> 01:27:15.840]  Ну да, то же самое, что и с get,
[01:27:15.840 --> 01:27:17.840]  там только put.
[01:27:17.840 --> 01:27:19.840]  Ну всё на сегодня, ладно, давайте уже.
