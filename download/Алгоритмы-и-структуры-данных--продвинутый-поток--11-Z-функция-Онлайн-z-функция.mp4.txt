[00:00.000 --> 00:11.000]  Итак, в прошлый раз мы обсуждали префикс функции, сегодня мы попробуем обсудить еще одну маленькую функцию.
[00:11.000 --> 00:17.000]  Еще один способ, как найти подстроку в строке за линейное время, напомню, что мы ищем.
[00:17.000 --> 00:22.000]  Собственно, шаблон P pattern в тексте T.
[00:22.000 --> 00:28.000]  Ну, еще один красивый способ как это можно сделать, это Z функция.
[00:28.000 --> 00:30.000]  Ну, определение здесь такое.
[00:30.000 --> 00:34.000]  На этот раз давайте скажем, что S у нас в ноль индексации.
[00:38.000 --> 00:42.000]  И введем такое понятие, как Z.
[00:42.000 --> 00:48.000]  Ну, вот тут очень интересно, то есть, формально говоря, оно водится и от нуля тоже часто.
[00:50.000 --> 00:56.000]  И, ну вот, то есть оно, соответственно, да, это тоже целое неприцательное число.
[00:56.000 --> 01:04.000]  То есть, точнее массив целых неотрицательных чисел, где Z и T равно максимальное такое L,
[01:04.000 --> 01:18.000]  что, значит, префикс длины L равен подстроке длины L, заканчивающейся, начинающейся, это важно.
[01:20.000 --> 01:24.000]  Да, вот чем хорошо писать на полу интервалов, это сразу хорошо.
[01:24.000 --> 01:28.000]  Ну, да, здесь пока, в общем-то, определение простое.
[01:32.000 --> 01:36.000]  Ну вот, возникает естественный такой вопрос.
[01:36.000 --> 01:39.000]  Действительно, как же ее найти?
[01:46.000 --> 01:48.000]  Ну, а главное зачем?
[01:48.000 --> 01:51.000]  Ну, в отличие от префикс функции, это действительно сложно.
[01:51.000 --> 01:54.000]  Можем быть, действительно, что-то придумать.
[01:54.000 --> 01:59.000]  Ну, хотя самое простое, если мы эту Z-функцию откуда-то с небес по факцию достаем,
[01:59.000 --> 02:05.000]  то тут применяется такой классический такой метод поиска подстроке в строке
[02:05.000 --> 02:11.000]  насчитать Z-функцию для строки P$T.
[02:13.000 --> 02:17.000]  Ну, или в других переводах P$T.
[02:18.000 --> 02:21.000]  Что такое диезик или доллар?
[02:21.000 --> 02:26.000]  Это какой-нибудь символ, которого нет ни в строке P, ни в строке T.
[02:28.000 --> 02:34.000]  Очевидно, что если посчитать такую Z-функцию, стреляя подобного рода строки,
[02:34.000 --> 02:39.000]  то легко заметить, что в какой-нибудь позиции,
[02:39.000 --> 02:42.000]  то есть, допустим, если вот это нарисовать вот таким вот образом,
[02:44.000 --> 02:50.000]  то в какой-нибудь, в этом символе строки T начинается вхождение строки P,
[02:50.000 --> 02:54.000]  тогда и только тогда, когда ZPT равно mod P.
[02:54.000 --> 02:58.000]  Причем диезик обеспечивает, что будет именно равно, а не больше либо равно,
[02:58.000 --> 03:00.000]  если у вас тут диезика нет.
[03:01.000 --> 03:06.000]  Ну, думаю, тут нот. Думается, тут идея достаточно простая.
[03:07.000 --> 03:11.000]  Вот. Ну, а что же нас теперь интересует?
[03:12.000 --> 03:16.000]  Что же нас теперь интересует? Как же эту Z-функцию найти?
[03:18.000 --> 03:23.000]  Ну, в общем-то, метод здесь достаточно простой.
[03:23.000 --> 03:26.000]  Значит, как же его здесь искать?
[03:27.000 --> 03:33.000]  Ну, во-первых, конечно, да, самое тупое, что можно найти, это, конечно, что Z от нуля равно чему?
[03:34.000 --> 03:36.000]  Ну, обычно длина строки.
[03:36.000 --> 03:41.000]  Ну, по такому определению, это просто действительно длина строки, и, в общем-то, это очевидно.
[03:42.000 --> 03:46.000]  Но настолько же очевидно, настолько и тривиально, и, в общем-то, не интересует.
[03:46.000 --> 03:51.000]  Потому что в некоторых версиях, собственно, Z от нуля не определяют вообще, ну, просто в силу неинформативности.
[03:52.000 --> 03:53.000]  Значит, это лишь штука.
[03:53.000 --> 04:07.000]  А вот все остальные Z от одного Dn-1, они ищутся, ну, вот, оказывается, весьма, ну, то есть весьма таким простым образом.
[04:07.000 --> 04:10.000]  Значит, каким же образом они ищутся.
[04:11.000 --> 04:14.000]  Вот. Они, в общем-то, ищутся очень просто.
[04:16.000 --> 04:19.000]  Значит, поехали. Ну, вот, каким образом.
[04:19.000 --> 04:21.000]  Значит, ну, идея такая.
[04:21.000 --> 04:23.000]  То есть мы будем идти по строке.
[04:24.000 --> 04:25.000]  Вот идти по этой строке S.
[04:25.000 --> 04:26.000]  Честно идти, идти, идти.
[04:26.000 --> 04:31.000]  И, честно, ну, там, после нулевого элемента, честно Z насчитывать, насчитывать, насчитывать.
[04:33.000 --> 04:38.000]  И вот, допустим, мы добрались до этого символа, хотим посчитать цветы, которые все предыдущие насчитали.
[04:41.000 --> 04:42.000]  И тогда идея такая.
[04:43.000 --> 04:49.000]  Вот у нас же были вот эти Z, которые находили какие-то подстроки, которые равны префиксу.
[04:52.000 --> 05:02.000]  Так вот, давайте найдем такую из этих подстрок, которая, внимание, заканчивается позже всех.
[05:05.000 --> 05:07.000]  Заканчивается позже всех.
[05:13.000 --> 05:18.000]  Ну, в общем-то, если вы там затытое поддерживаете, то, в общем-то, поддерживать эту штуку тоже не сложно.
[05:19.000 --> 05:22.000]  Понятно, то есть L будет равно argmax.
[05:24.000 --> 05:28.000]  Соответственно, там J плюс Z житого.
[05:32.000 --> 05:37.000]  Ну, вот, соответственно, J плюс Z житого, значит, один меньше ребрем.
[05:37.000 --> 05:38.000]  J меньше.
[05:43.000 --> 05:52.000]  Вот, легко. Ну, если мы сейчас с помощью его ZI напишем, то, собственно, поддерживать и поддержать это L будет уже не сложно.
[05:53.000 --> 05:55.000]  Ну, тем более, как мы это будем делать?
[05:56.000 --> 06:06.000]  Ну, самый тупой способ говорить, но первый такой тупой случай говорит, что если совершенно случайно оказалось, что эти L и L плюс ZI вот тут,
[06:06.000 --> 06:28.000]  они заканчиваются, то есть L плюс ZI вот тут не проявляет этого символа, его не покрывая, то здесь мы тогда насчитываем Z от I в тупую.
[06:36.000 --> 06:38.000]  Вот такая вот приятная вещь.
[06:46.000 --> 06:48.000]  Вот давайте, прям совсем с тупой.
[06:50.000 --> 07:04.000]  Но может так случиться, что действительно, скорее всего, пока не психологически так кажется, так случится, что L и L плюс ZI на самом деле L плюс ZI будет чисто больше, чем I.
[07:04.000 --> 07:06.000]  Но что это означает?
[07:07.000 --> 07:21.000]  На самом деле это означает, что эта строка является префиксом, и это означает, что, в принципе, мы с точки зрения Z кое-что про нее уже знаем.
[07:21.000 --> 07:23.000]  Ведь действительно, давайте заметим.
[07:24.000 --> 07:26.000]  Давайте вот возьмем и заметим.
[07:27.000 --> 07:43.000]  То есть раз вот эта строка равна префиксу, то в принципе вот эта подстрока, начиная с этого символа вот по этому, она равна вот какой-то вот этой подстроке.
[07:43.000 --> 07:46.000]  Вот, кстати, как вы думаете, где начинается эта подстрока?
[07:46.000 --> 07:48.000]  I минус L.
[07:48.000 --> 07:51.000]  Да, совершенно верно. Она начинается в позиции I минус L.
[07:52.000 --> 08:11.000]  Вот, мы заметим, так как вот, то есть про эту подстроку мы что-то знаем, но тогда получается, ну, интересный факт, что если мы хотим понять, что вот начинается этого символа, сколько символов будут совпадать с префиксом, то, в общем-то, первые несколько мы можем уже сказать, то есть говорить то же самое, что и про I минус L.
[08:11.000 --> 08:15.000]  Но Z от I минус L мы уже знаем.
[08:15.000 --> 08:36.000]  И тогда, получается, по Z минус L мы без труда можем понять, дойдем ли мы хотя бы вот до этой границы или нет. То есть более точно оказалось, то есть в случае 2a, например, говорит, что если оказалось, что Z минус L оказался строго меньше, чем сколько?
[08:36.000 --> 08:38.000]  R минус, получается.
[08:38.000 --> 08:41.000]  Ну да, мы R не вводили.
[08:41.000 --> 08:45.000]  Да, в классических интерпретациях R, но вот как мы обошли.
[08:45.000 --> 08:50.000]  Да, вот длина этой строки действительно равна L плюс Z от L минус I.
[08:50.000 --> 09:00.000]  Вот. То есть если оказалось, что Z от этой штуки не доходит до этой границы, то есть тогда мы можем гарантировать следующее.
[09:00.000 --> 09:06.000]  Вот здесь есть совпадение.
[09:06.000 --> 09:11.000]  А следующий символ не совпадает.
[09:11.000 --> 09:17.000]  Но при этом заметим, что здесь эта строка тоже, получается, совпадает, а здесь тот же самый.
[09:17.000 --> 09:20.000]  С этим совпадает, следовательно, с этим не совпадает.
[09:21.000 --> 09:30.000]  Следовательно, из этого мы выводим, что Z от T тупо равно Z от I минус I.
[09:33.000 --> 09:36.000]  Ну и второй случай.
[09:36.000 --> 09:43.000]  Оказалось, что Z от I минус L больше либо равен, чем L плюс Z от L минус I.
[09:43.000 --> 09:47.000]  И вот здесь, конечно, очень легко сделать одну маленькую багу.
[09:47.000 --> 09:57.000]  Очень хочется соблазнительно сказать, что давайте скажем, что Z от T тоже все равно равно Z от I минус L, уж как минимум точно.
[09:57.000 --> 10:00.000]  Вот. Потому что, ну, как бы, ну, что ж их от I?
[10:00.000 --> 10:03.000]  Тут обычно алгоритм говорит следующее.
[10:03.000 --> 10:05.000]  То есть вот правильно написать его так.
[10:05.000 --> 10:16.000]  Действительно, что Z от T равно, теперь пишем, L плюс Z от L минус I далее в тупую.
[10:16.000 --> 10:19.000]  Что мы подразумеваем под словосочетанием «далее в тупую».
[10:19.000 --> 10:25.000]  То есть мы говорим, что мы точно знаем, что Z от I теперь не меньше, чем столько.
[10:25.000 --> 10:32.000]  Ну ведь, действительно, раз Z функция здесь, раз тут совпало с префиксом такое количество элементов,
[10:32.000 --> 10:38.000]  то, конечно, мы понимаем, что раз вот эта строчка равна вот этой, то получается она тоже совпадает с префиксом.
[10:38.000 --> 10:45.000]  Вот. Поэтому мы точно знаем, что Z от I это как минимум длина этой строчки, но может быть больше.
[10:45.000 --> 10:47.000]  И это мы уже узнаем в тупую.
[10:47.000 --> 10:52.000]  Ну здесь, конечно, да, очень иногда хочется, особенно в каком-то олимпиадном замоте, действительно, скопировать,
[10:52.000 --> 10:57.000]  прямо написать Z от I равно Z от I минус I далее в тупую, или что-то еще в этом роде.
[10:57.000 --> 11:00.000]  Но, боже вас упаси, так делают.
[11:00.000 --> 11:05.000]  То есть как минимум с точки зрения доказательства это неправда, потому что мы только вот про эти части,
[11:05.000 --> 11:11.000]  про эти вот строки знаем, что они равны, а вот хотя бы равен вот этот символ и вот этот.
[11:11.000 --> 11:13.000]  Что мы не знаем, то и не знаем.
[11:16.000 --> 11:20.000]  Вот. Поэтому, действительно, не получится.
[11:20.000 --> 11:23.000]  Действительно, у нас так делать.
[11:23.000 --> 11:33.000]  Так что, ну вот. Ну вот. Ну отсюда, в общем-то, и получается. Действительно такая.
[11:35.000 --> 11:36.000]  Вот.
[11:38.000 --> 11:40.000]  Так. Ну что? Ну вот.
[11:40.000 --> 11:44.000]  Ну таким образом получается, что вот Z-функцию вот таким вот образом нашли.
[11:44.000 --> 11:48.000]  Ну и здесь мы доказали, что эта Z-функция работает.
[11:48.000 --> 11:51.000]  Логично, да? Видно, да?
[11:51.000 --> 11:56.000]  Вот. Остается только мелкий простой вопрос.
[11:56.000 --> 11:58.000]  А почему она за лигию работает?
[11:58.000 --> 12:02.000]  Каждый шаг насчет тупую увеличивает правую границу максимально.
[12:02.000 --> 12:04.000]  Да, совершенно верно. Здесь идея простая.
[12:04.000 --> 12:08.000]  То есть заметим, что каждый шаг в тупую, потом в перспективе вот эта вот L плюс ZL,
[12:08.000 --> 12:11.000]  эту правую границу нам увеличит. Действительно.
[12:11.000 --> 12:15.000]  Ну и здесь, особенно это хорошо видно для нашего случая 2b,
[12:15.000 --> 12:19.000]  когда мы говорим, что Z-функция дошла до границы, а дальше мы ее будем двигать прямо в тупую.
[12:19.000 --> 12:21.000]  Каждый шаг на единичку.
[12:21.000 --> 12:25.000]  Вот. Ну в случае 2a просто там граница не поменялась, все за вот единицы.
[12:25.000 --> 12:31.000]  Ну а здесь, действительно, граница уже будет начинаться в I и идти правее-правее-правее.
[12:31.000 --> 12:36.000]  Да. Здесь такой, может, одно из самых наглядных доказательств того, что это зайгнет.
[12:36.000 --> 12:39.000]  То есть там вот префикс функции, это может быть там иногда неочевидно.
[12:39.000 --> 12:41.000]  В общем, зависит от интерпретации.
[12:41.000 --> 12:44.000]  Ну вот, здесь получается хорошо.
[12:44.000 --> 12:45.000]  Да.
[12:45.000 --> 12:48.000]  Действительно. Вот такая вот получается хорошая.
[12:49.000 --> 12:50.000]  Да.
[12:50.000 --> 12:53.000]  Но возникает, правда, действительно, да.
[12:54.000 --> 12:56.000]  Действительно, итак.
[12:56.000 --> 13:03.000]  Так что, таким образом, да, Z-функция действительно окажется действительно хорошей, красивой вещью.
[13:04.000 --> 13:08.000]  Вот. Ну, в общем, вот.
[13:08.000 --> 13:14.000]  Причем, на самом деле, как показывает практика, сама Z-функция может очень много чего уметь.
[13:14.000 --> 13:16.000]  Собственно, и сама по себе.
[13:18.000 --> 13:19.000]  Вот.
[13:21.000 --> 13:22.000]  Вот.
[13:22.000 --> 13:24.000]  Но давайте вот для начала.
[13:24.000 --> 13:26.000]  Действительно, хочется, конечно, первое.
[13:26.000 --> 13:29.000]  В префикс функции было такое преимущество вот по дополнительной памяти.
[13:29.000 --> 13:35.000]  Понимаете, что префикс функции могла использовать дополнительную память не от P плюс T, а только от P.
[13:39.000 --> 13:42.000]  Вот возникает тогда такой естественный вопрос.
[13:44.000 --> 13:50.000]  А не божим ли бы обойтись дополнительной памятью от P при вычислении Z-функции, когда еще по строку строке.
[13:59.000 --> 14:12.000]  Наверное, можно пытаться только хранить максимальную правую, ну, левую правую границу.
[14:12.000 --> 14:13.000]  Вот.
[14:13.000 --> 14:15.000]  Ну, то есть вот эти L и L плюс Z.
[14:15.000 --> 14:16.000]  Ну, в общем-то.
[14:16.000 --> 14:17.000]  И только их меняет.
[14:17.000 --> 14:18.000]  Ну, да.
[14:18.000 --> 14:19.000]  В общем-то, да.
[14:19.000 --> 14:20.000]  Действительно.
[14:20.000 --> 14:26.000]  Можно заметить, что, если мы будем считать тут Z-функцию, то диезер гарантирует нам, что если там больше тут ничего не произойдет.
[14:27.000 --> 14:29.000]  Ну, то есть, конечно, тут Z будет ноль.
[14:29.000 --> 14:34.000]  И более того, он гарантирует, что все там левые эти правые границы закончатся где-то на диезе.
[14:34.000 --> 14:37.000]  Может быть, ну, там непосредственно перед диезе.
[14:37.000 --> 14:38.000]  Вот.
[14:38.000 --> 14:39.000]  Но, действительно.
[14:39.000 --> 14:45.000]  Но тогда, когда мы будем насчитывать, скажем, эту функцию здесь, то заметим, что хранить каждое конкретное значение нам уже не нужно.
[14:45.000 --> 14:48.000]  Потому что здесь Z будет не более чем P.
[14:48.000 --> 14:59.000]  Получается, вот, когда в этом алгоритме отсылки будут только, вот, там могут быть отсылки только где-то вот к Z-м уже, соответственно, где-то уже в P.
[14:59.000 --> 15:03.000]  Поэтому, на самом деле, то есть, опять же, как префикс функции, в общем-то.
[15:03.000 --> 15:06.000]  То есть, делаем абсолютно то же самое, только конкретные Z-ки не храним.
[15:06.000 --> 15:09.000]  Просто, если очередная Z-ка, ну, там.
[15:09.000 --> 15:15.000]  То есть, храним, конечно, вот эти вот максимальные L, соответствующие L плюс Z, или это вы храним.
[15:15.000 --> 15:16.000]  Ну, вот.
[15:16.000 --> 15:17.000]  Ну, вот.
[15:17.000 --> 15:22.000]  Ну, а дальше просто каждую Z-ку честно вычисляем и говорим, что если она оказалась в модуле P, значит, ура, вхождения нашли.
[15:22.000 --> 15:23.000]  Нет?
[15:25.000 --> 15:26.000]  Да.
[15:27.000 --> 15:33.000]  Но, правда, действительно, у этого алгоритма, конечно, есть один еще маленький недостаток.
[15:36.000 --> 15:38.000]  Какой маленький недостаток у него есть?
[15:38.000 --> 15:41.000]  Что этот алгоритм, конечно, не совсем онлайн.
[15:41.000 --> 15:44.000]  Что префикс функции был еще одно преимущество.
[15:44.000 --> 15:51.000]  То есть, можно было, ну, то есть, он, в принципе, работает по принципу, а вот, что, как бы, вот, гастротина считали,
[15:51.000 --> 15:58.000]  теперь добавили один символ, его и там, в идеале, там, амортизировано за O от единицы, действительно, что-то досчитая.
[15:58.000 --> 16:03.000]  А если насчитать автомат префикс функции, то даже и в честных получалось.
[16:03.000 --> 16:06.000]  Ну, правда, это, конечно, работает, только если у нас стал ставить констант.
[16:06.000 --> 16:08.000]  Впрочем, чаще всего это так.
[16:09.000 --> 16:10.000]  Вот.
[16:11.000 --> 16:14.000]  Сперва, действительно, хочется даже прям чуть-чуть подумать на эту тему.
[16:16.000 --> 16:22.000]  Действительно. А вот, действительно, можно ли было бы, действительно, насчитывать Z функцию в некотором плане онлайне?
[16:24.000 --> 16:25.000]  Суждается, что можно.
[16:25.000 --> 16:28.000]  Да. Прям, то, правда, не за O от единицы, да?
[16:28.000 --> 16:35.000]  Ну, в смысле, как бы, понятно, что каждый символ может быть за O от единицы, но учетно O от единицы.
[16:36.000 --> 16:38.000]  Ага. Учетно O от единицы, да.
[16:38.000 --> 16:40.000]  В общем, там, на самом деле, просто алгоритм.
[16:41.000 --> 16:42.000]  Вот.
[16:43.000 --> 16:44.000]  Я не знаю, я мог бы попробовать раскрыть.
[16:44.000 --> 16:45.000]  Не, погоди, погоди, сейчас.
[16:45.000 --> 16:46.000]  Что-то?
[16:46.000 --> 16:53.000]  В смысле, что, ну, как префикс функции, у нас же каждый символ может быть за сколько угодно, но если всю строку добавили, то суммарно O от единицы на символ.
[16:53.000 --> 16:54.000]  Ну, понятно.
[16:54.000 --> 16:55.000]  То то же самое.
[16:55.000 --> 16:56.000]  Ну, я понял, я понял.
[16:56.000 --> 16:57.000]  Сейчас.
[16:58.000 --> 16:59.000]  Ну, да.
[16:59.000 --> 17:01.000]  Нет, ну, давайте даже интрига.
[17:01.000 --> 17:03.000]  А ну-ка, давай попробуй.
[17:03.000 --> 17:04.000]  Даже интересно.
[17:04.000 --> 17:05.000]  Так.
[17:05.000 --> 17:06.000]  Так.
[17:06.000 --> 17:07.000]  Ну, я на этом то, сколько угодно.
[17:07.000 --> 17:08.000]  Да, конечно.
[17:08.000 --> 17:09.000]  Да.
[17:14.000 --> 17:15.000]  Вот.
[17:15.000 --> 17:16.000]  В чем будет основная идея?
[17:16.000 --> 17:17.000]  Вот, допустим, у нас есть...
[17:17.000 --> 17:18.000]  Так.
[17:18.000 --> 17:20.000]  Ну, давай сфагулируем тогда максимально четко.
[17:20.000 --> 17:21.000]  А что мы сейчас...
[17:21.000 --> 17:22.000]  Что мы хотим?
[17:22.000 --> 17:23.000]  Что мы хотим?
[17:23.000 --> 17:26.000]  Мы хотим уметь добавлять символ в конец строки.
[17:26.000 --> 17:27.000]  Да.
[17:27.000 --> 17:28.000]  Ну, pushback.
[17:28.000 --> 17:29.000]  Да.
[17:29.000 --> 17:32.000]  Вот, символ C.
[17:32.000 --> 17:35.000]  И хотим узнать Z и T.
[17:35.000 --> 17:38.000]  Ну, дается I, мы хотим узнать Z и T.
[17:38.000 --> 17:39.000]  Что там?
[17:39.000 --> 17:40.000]  Запросы, как раз, да.
[17:40.000 --> 17:41.000]  Да.
[17:41.000 --> 17:44.000]  Вот эти мы можем делать за от единицы строго, то есть, не удивительно.
[17:44.000 --> 17:45.000]  That-functions?
[17:45.000 --> 17:46.000]  Да.
[17:46.000 --> 17:47.000]  Да, моя запунция говорит.
[17:47.000 --> 17:50.000]  Вот эти от единицы в среднем, ну, то есть, учетно.
[17:50.000 --> 17:54.000]  Вот эти от единицы в среднем, ну, то есть, учетно.
[17:54.000 --> 17:55.000]  Так.
[17:55.000 --> 18:03.800]  То есть, по сути, аналогично, как у нас коррекция функции, и так умеем делать.
[18:03.800 --> 18:07.800]  Вот. Какая основная идея нашего алгоритма?
[18:07.800 --> 18:12.800]  Значит, ну вот пусть у нас есть текущий предыдущий строки.
[18:12.800 --> 18:16.800]  Вот. И вот мы к нему нападаемся 2700.
[18:16.800 --> 18:23.800]  Значит, мы будем поддерживать минимальную такую позицию и, не нулевую причем,
[18:23.800 --> 18:27.800]  что суббикс в начале ИС падает соответствующим предыдущим строкам.
[18:27.800 --> 18:31.800]  Ну, то есть, что как бы И плюс затытое равно текущей длине строки.
[18:38.800 --> 18:48.800]  Вот. Ну, как бы несложно понять, что когда мы будем делать новый символ, эта позиция будет только не убывать.
[18:48.800 --> 18:50.800]  Вот.
[18:50.800 --> 18:52.800]  Первый вопрос.
[18:52.800 --> 18:55.800]  Первый вопрос. Ну, давайте дальше посмотрим так.
[18:55.800 --> 18:58.800]  Вот у нас есть текущий СКС, есть вот этот символ И, да?
[18:58.800 --> 19:03.800]  Заметим, что тогда Z функция для предыдущих символов уже почти однозначна и меняться не может,
[19:03.800 --> 19:09.800]  потому что их как бы, ну как бы, постройка сначала дней до конца текущей строки уже не дойдет.
[19:09.800 --> 19:14.800]  Вот. И говорим, что тогда мы для всех предыдущих Z уже начитали к этому моменту.
[19:15.800 --> 19:21.800]  Вот. Как тогда посчитать, ну как всегда отвечать на второй запрос?
[19:21.800 --> 19:27.800]  Ну, то есть, если нам дается позиция меньше, чем И, то просто отвечаем Z функцию в этой позиции.
[19:27.800 --> 19:30.800]  А если хотя бы И, ну вот тут какая-нибудь позиция G.
[19:30.800 --> 19:34.800]  Ну, в целом понятно, отвечаем, значит...
[19:34.800 --> 19:40.800]  Ну, то есть, мы уже понимаем, что Z функция с началом G такая же, как G минусы,
[19:40.800 --> 19:44.800]  ну с учетом того, что она там не больше, чем оставшийся субекс.
[19:44.800 --> 19:47.800]  Да, но это может все еще быть больше, чем И.
[19:47.800 --> 19:51.800]  Да. Ну, и то же самое не больше, чем G минус 2.
[19:54.800 --> 19:59.800]  Если у нас G минусы все еще хотя бы И, то мы можем еще раз почистить их.
[19:59.800 --> 20:02.800]  Ну, в общем, мы можем взять G по модуле И просто.
[20:02.800 --> 20:08.800]  Сейчас, сейчас, сейчас. Покажи G минусы, я понял.
[20:08.800 --> 20:19.800]  Ну, то есть, мы понимаем, что ZGT на самом деле это минимум из ZG минусы и...
[20:19.800 --> 20:21.800]  Ой, так уже минусы, я не знаю.
[20:21.800 --> 20:29.800]  ...G минусы и модуля С минус G, да, без минусы единицы, да.
[20:29.800 --> 20:33.800]  Ну, вот. Ну, а это можно логично расписать как минимум из ZG минус 2И,
[20:33.800 --> 20:36.800]  ну и там чего-то большего, что уже можно не учитывать.
[20:36.800 --> 20:48.800]  То есть, аналогично получаем, что это минимум из ZG по модуле И и S минус G.
[20:50.800 --> 20:57.800]  Таким образом, мы научились заутентицем восстанавливать любое имя Z функции, если потребуется.
[20:58.800 --> 21:01.800]  Как добавить теперь символ C в конец?
[21:01.800 --> 21:02.800]  Ну, очень просто.
[21:02.800 --> 21:05.800]  Вот у нас есть текущая наша позиция и добавляем C.
[21:05.800 --> 21:10.800]  Смотрим, правда ли, что если мы добавим C, то и все еще остается...
[21:10.800 --> 21:12.800]  Ну, у нее Z функция все еще максимально возможна.
[21:12.800 --> 21:18.800]  То есть, правда ли, что там вот этот символ C совпадает с символом, ну, типа на I или V?
[21:19.800 --> 21:25.800]  Если совпадают, то мы просто дописываем C в конец, оставляем и на месте, и все отлично.
[21:25.800 --> 21:32.800]  Иначе мы говорим, что, ну, теперь значение Z функции V точно такое, вот S минус I, модула S минус I,
[21:32.800 --> 21:34.800]  а из двигаем на единицу.
[21:34.800 --> 21:37.800]  Вот, и теперь проверяем для нее то же самое.
[21:37.800 --> 21:42.800]  Ну, то есть, как это, как бы, чуть более аккуратно?
[21:42.800 --> 21:45.800]  Ну, вот, значит...
[21:47.800 --> 21:48.800]  Давайте так скажем.
[21:48.800 --> 21:53.800]  А что, ну, посмотри, самый тупой алгоритм, который тут предлагается, давайте просто идти.
[21:53.800 --> 21:57.800]  Ну, в смысле, нет, это вроде, идейно, мне кажется, должно уже понятно быть.
[21:57.800 --> 22:02.800]  Ну, нет, идея такая понятна, что мы Z функцию, мы можем просто идти теперь просто и слева,
[22:02.800 --> 22:05.800]  и смотреть, у кого Z функция дальше дойдет до S, и делать тоже...
[22:05.800 --> 22:11.800]  Да, мы можем теперь идти, вот, начиная с C вправо, и вот, ну, вот, допустим, мы сейчас на элементе тоже как раз G, да?
[22:11.800 --> 22:18.800]  Мы знаем, что, как бы, текущая джит функция, мы можем через Z G минусы предрексировать, потому что она уже точно посчитана.
[22:18.800 --> 22:19.800]  Ну, да.
[22:19.800 --> 22:23.800]  Если она доходит до конца строки, то проверяйся, что Z G...
[22:23.800 --> 22:25.800]  Ну, да, да, да, да, да.
[22:25.800 --> 22:27.800]  Вот так просто.
[22:27.800 --> 22:28.800]  Ага.
[22:28.800 --> 22:29.800]  Так, классно.
[22:29.800 --> 22:31.800]  Так, есть ли какие-то вопросы?
[22:32.800 --> 22:33.800]  Да, вначале.
[22:33.800 --> 22:34.800]  Есть ли какие-то вопросы?
[22:34.800 --> 22:36.800]  Да.
[22:36.800 --> 22:38.800]  Да, так.
[22:38.800 --> 22:40.800]  Как говорится, там просто никто в прямом эфире не слушает.
[22:40.800 --> 22:41.800]  Нет, послушаю.
[22:41.800 --> 22:42.800]  Ну, понятно.
[22:42.800 --> 22:45.800]  Так, ну, все-таки нет, реально, все понятно?
[22:45.800 --> 22:48.800]  Или требуется что-то уточнить?
[22:49.800 --> 22:51.800]  есть ли уже вольт?
[22:51.800 --> 22:54.800]  наверное не сомневаюсь, что это надо аккуратно написать
[22:54.800 --> 22:56.800]  потому что, например
[22:56.800 --> 22:59.800]  нам нужно понять, чем приносить и в начале
[22:59.800 --> 23:02.800]  то есть, что лучше всего приносить не 0 и 1
[23:02.800 --> 23:05.800]  и понятно, чтобы аккуратно не обрабатывать
[23:05.800 --> 23:07.800]  по случаю первых символов в строку
[23:07.800 --> 23:09.800]  ну там, то есть
[23:09.800 --> 23:12.800]  у меня есть даже какое-то подобие кода
[23:12.800 --> 23:14.800]  не, ну понятно
[23:14.800 --> 23:16.800]  ну можно, не, ну не вот это
[23:16.800 --> 23:18.800]  когда один символ, как бы более-менее все понятно
[23:18.800 --> 23:20.800]  ну да, когда второй, нормально
[23:20.800 --> 23:22.800]  вот, да, спасибо, огромное
[23:22.800 --> 23:24.800]  ну пожалуйста, так, ну да, это красиво
[23:24.800 --> 23:26.800]  так, ну что
[23:26.800 --> 23:28.800]  нет, так, господа, так это
[23:28.800 --> 23:30.800]  тестим аудиторию, так
[23:30.800 --> 23:32.800]  требуется ли это там повторить
[23:32.800 --> 23:34.800]  или осветить какие-то моменты
[23:34.800 --> 23:36.800]  давайте еще раз
[23:36.800 --> 23:38.800]  так, сейчас проверим, собственно, насколько это
[23:38.800 --> 23:40.800]  понял я
[23:40.800 --> 23:42.800]  сейчас я попробую это все
[23:42.800 --> 23:44.800]  да, с третьей написать заново
[23:44.800 --> 23:46.800]  ну вдруг меня, я не знаю
[23:46.800 --> 23:48.800]  да, так, смотрите
[23:48.800 --> 23:50.800]  итак
[23:54.800 --> 23:56.800]  так
[23:56.800 --> 23:58.800]  я в группу скину код
[23:58.800 --> 24:00.800]  этой функции
[24:00.800 --> 24:02.800]  хорошо, итак, поехали
[24:02.800 --> 24:04.800]  итак, значит, что мы еще раз хотим
[24:04.800 --> 24:06.800]  значит, мы хотим насчитывать
[24:06.800 --> 24:08.800]  эту функцию в некотором смысле
[24:08.800 --> 24:10.800]  в онлайне, что это означает
[24:10.800 --> 24:12.800]  это означает, что у нас есть
[24:12.800 --> 24:14.800]  строка S
[24:14.800 --> 24:16.800]  в ноль аддексации, естественно
[24:16.800 --> 24:18.800]  и мы выполняем к этой строке
[24:18.800 --> 24:20.800]  два типа запроса
[24:20.800 --> 24:22.800]  первый тип запроса
[24:22.800 --> 24:24.800]  приписать
[24:24.800 --> 24:26.800]  в строке S новый символ
[24:26.800 --> 24:28.800]  C какой-то, но новый не в смысле
[24:28.800 --> 24:30.800]  что его там, такого символа больше нет
[24:30.800 --> 24:32.800]  просто вот, вот, глянить строк на один
[24:32.800 --> 24:34.800]  вот, и
[24:34.800 --> 24:36.800]  второе, что-то второе нужно сделать
[24:36.800 --> 24:38.800]  что нужно сделать
[24:38.800 --> 24:40.800]  это, конечно же
[24:40.800 --> 24:42.800]  то есть, действительно
[24:42.800 --> 24:44.800]  найти z от i
[24:44.800 --> 24:46.800]  для
[24:46.800 --> 24:48.800]  некоторого
[24:48.800 --> 24:50.800]  значит
[24:50.800 --> 24:52.800]  i, который лежит
[24:52.800 --> 24:54.800]  на полной интервале
[24:54.800 --> 24:56.800]  глядя
[24:58.800 --> 25:00.800]  значит, мы ставим на то
[25:00.800 --> 25:02.800]  мы ставим на то, что
[25:02.800 --> 25:04.800]  ну, как и в префикс функции
[25:04.800 --> 25:06.800]  мы ставим, то есть, заметим, что
[25:06.800 --> 25:08.800]  как и в префикс функции мы ставим на то, что
[25:08.800 --> 25:10.800]  zi-то мы будем определять
[25:10.800 --> 25:12.800]  даже честно
[25:14.800 --> 25:16.800]  вот
[25:20.800 --> 25:22.800]  и от единицы учет
[25:24.800 --> 25:26.800]  вот
[25:26.800 --> 25:28.800]  кое-что мы будем делать
[25:28.800 --> 25:30.800]  в общем-то, можно заметить, что для префикс функции
[25:30.800 --> 25:32.800]  у нас происходило то же самое, правда
[25:32.800 --> 25:34.800]  ну, потому что префикс функции честно насчитывалась
[25:34.800 --> 25:36.800]  ну, слава богу, она
[25:36.800 --> 25:38.800]  каждая префикс функция зависит только от того, что
[25:38.800 --> 25:40.800]  с левой и никак не зависит от того, что с правой
[25:40.800 --> 25:42.800]  ну, как вы помните, когда мы приписываем
[25:42.800 --> 25:44.800]  новый символ c, то мы там скакали
[25:44.800 --> 25:46.800]  что-то там по i, p от i, p от p
[25:46.800 --> 25:48.800]  помните, да, поэтому получались
[25:48.800 --> 25:50.800]  на самом деле, получались ровно такие же асимтуицы
[25:52.800 --> 25:54.800]  но в z от i
[25:54.800 --> 25:56.800]  в z от i, на самом деле
[25:56.800 --> 25:58.800]  действительно
[25:58.800 --> 26:00.800]  оказывается, тоже можно
[26:00.800 --> 26:02.800]  так делать, но чуть-чуть-чуть более
[26:02.800 --> 26:04.800]  хитрый очень сильно
[26:04.800 --> 26:06.800]  а именно
[26:06.800 --> 26:08.800]  значит, что мы будем делать
[26:08.800 --> 26:10.800]  мы будем пытаться
[26:10.800 --> 26:12.800]  значит, вариант будет следующий
[26:12.800 --> 26:14.800]  в каждый момент времени
[26:14.800 --> 26:16.800]  мы будем пытаться
[26:16.800 --> 26:18.800]  хранить
[26:18.800 --> 26:20.800]  давайте еще какую-нибудь маркеру возьмем для этого
[26:20.800 --> 26:22.800]  значит, полк разума
[26:22.800 --> 26:24.800]  давайте побольше нарисую
[26:26.800 --> 26:28.800]  значит, для текущей строки s
[26:28.800 --> 26:30.800]  мы будем
[26:30.800 --> 26:32.800]  хранить некое
[26:32.800 --> 26:34.800]  мистическое
[26:36.800 --> 26:38.800]  я очень хочу
[26:38.800 --> 26:40.800]  достать именно красной марки
[26:40.800 --> 26:42.800]  я не знаю
[26:42.800 --> 26:44.800]  почему
[26:44.800 --> 26:46.800]  я не знаю
[26:46.800 --> 26:48.800]  почему-то у нас позавчера
[26:48.800 --> 26:50.800]  фибоначевый кучевый текал красный указатель
[26:50.800 --> 26:52.800]  и вот так удобно было
[26:52.800 --> 26:54.800]  называть, как и называть красный указатель
[26:56.800 --> 26:58.800]  так вот
[26:58.800 --> 27:00.800]  мы хотим находить
[27:02.800 --> 27:04.800]  значит, вот такое вот число
[27:04.800 --> 27:06.800]  ну будем его называть
[27:06.800 --> 27:08.800]  допустим
[27:08.800 --> 27:10.800]  поз
[27:10.800 --> 27:12.800]  давайте поз
[27:12.800 --> 27:14.800]  поз
[27:14.800 --> 27:16.800]  это будет такое
[27:16.800 --> 27:18.800]  минимальное
[27:18.800 --> 27:20.800]  допустим l больше нуля
[27:20.800 --> 27:22.800]  такое, что
[27:22.800 --> 27:24.800]  l плюс z от l
[27:24.800 --> 27:26.800]  равно модуль s
[27:30.800 --> 27:32.800]  вот
[27:32.800 --> 27:34.800]  первая позиция
[27:34.800 --> 27:36.800]  на которой
[27:36.800 --> 27:38.800]  z функция
[27:38.800 --> 27:40.800]  честно доходит
[27:40.800 --> 27:42.800]  до конца
[27:48.800 --> 27:50.800]  вот
[27:50.800 --> 27:52.800]  ну и соответственно
[27:52.800 --> 27:54.800]  видимо оговоримся, что или конечно же
[27:54.800 --> 27:56.800]  модуль s, если такого нет
[28:02.800 --> 28:04.800]  уговоримся
[28:04.800 --> 28:06.800]  может так случится
[28:06.800 --> 28:08.800]  легко пристепелек
[28:14.800 --> 28:16.800]  и будем
[28:16.800 --> 28:18.800]  хранить такой инвариант
[28:24.800 --> 28:26.800]  значит, инвариант будет говорить
[28:26.800 --> 28:28.800]  что
[28:28.800 --> 28:30.800]  называется
[28:30.800 --> 28:40.800]  Ну вот, z от нуля до поз включительно, нот насчитана и сохранена в явном виде.
[28:40.800 --> 28:45.800]  Ну, представьте, для поз значение не финальное.
[28:45.800 --> 28:47.800]  Ну ладно, хорошо.
[28:47.800 --> 28:48.800]  Для поз не включится.
[28:48.800 --> 28:55.800]  Ладно, хорошо. Сохранено в явном виде.
[28:55.800 --> 29:00.800]  Давайте вот так попробуем.
[29:00.800 --> 29:06.800]  Ну действительно, почему мы именно вот до поз не включить?
[29:06.800 --> 29:20.800]  Потому что заметим, что если у всех этих товарищей действительно z какие-то поменьше, они до конца не доходят, вот так, вот так, что-нибудь еще,
[29:20.800 --> 29:29.800]  то тогда заметим, что эти z-ки уже финальные и не поменяются уже никогда, потому что сравнения облубаются раньше, чем заканчивается даже уже строка.
[29:29.800 --> 29:33.800]  Поэтому эти z-ки можно сравнить.
[29:33.800 --> 29:38.800]  Вот.
[29:38.800 --> 29:42.800]  Вот, ну теперь вытекает мистическая нота.
[29:42.800 --> 29:44.800]  Значит, как же нам теперь искать?
[29:44.800 --> 29:46.800]  Значит, как искать zi?
[29:46.800 --> 29:51.800]  Значит, когда мы ищем теперь zi, получается следующее.
[29:51.800 --> 29:53.800]  Значит, ну вот.
[29:53.800 --> 29:56.800]  То есть действительно, как теперь насчитать zi?
[29:56.800 --> 29:58.800]  Насчитать его очень просто.
[29:58.800 --> 30:10.800]  Значит, ну во-первых, если оказалось, что i меньше, даже меньше либо равно, чем поз, допустим, да,
[30:10.800 --> 30:17.800]  то тогда просто к этому массиву отсылаемся.
[30:17.800 --> 30:19.800]  Ну, видимо, меньше, что не важно.
[30:19.800 --> 30:20.800]  Вот.
[30:20.800 --> 30:22.800]  Ну, можно написать меньше, хорошо.
[30:22.800 --> 30:24.800]  Ну, можно написать меньше, можно...
[30:24.800 --> 30:32.800]  Ну, ладно, давайте отдельно этот случай поразбираем, кстати, потому что он на самом деле определенно интересный, можете им идти отдельно.
[30:32.800 --> 30:33.800]  Вот.
[30:33.800 --> 30:41.800]  Ну, если, давайте скажем, значит, i равно поз, то ответ, ну, понятно какой.
[30:41.800 --> 30:43.800]  Модули с минус поз.
[30:43.800 --> 30:46.800]  Этому уже точно знаем.
[30:46.800 --> 30:58.800]  Если же i больше поз, то мистическое утверждение.
[30:58.800 --> 31:06.800]  Значит, z от i минус поз.
[31:06.800 --> 31:08.800]  Скорее всего, z от i равно минимум.
[31:08.800 --> 31:10.800]  Ну, да, да, да, да, да.
[31:10.800 --> 31:12.800]  Сейчас формируем правильно.
[31:12.800 --> 31:14.800]  Сейчас формируем правильно.
[31:14.800 --> 31:24.800]  Тогда оказывается, что z и t равно z от i...
[31:24.800 --> 31:26.800]  Значит, да, вру.
[31:26.800 --> 31:28.800]  Значит, очень аккуратно, да.
[31:28.800 --> 31:34.800]  Минимум из, значит, z...
[31:34.800 --> 31:36.800]  От i минус поз.
[31:36.800 --> 31:38.800]  Да, i минус поз и...
[31:38.800 --> 31:39.800]  Модуля с минусом.
[31:39.800 --> 31:41.800]  Ну, да, модуля с минусом.
[31:41.800 --> 31:43.800]  Вот так оказывается.
[31:43.800 --> 31:47.800]  А, ну, правильнее, конечно, еще...
[31:47.800 --> 31:51.800]  Раз уж поз у нас красный указатель,
[31:51.800 --> 31:53.800]  так давайте его красным описать.
[31:58.800 --> 32:01.800]  Ну, вот, начиним вот, собственно, ключевое утверждение.
[32:01.800 --> 32:03.800]  Почему это так?
[32:03.800 --> 32:05.800]  Почему же это так?
[32:05.800 --> 32:09.800]  Причина, в общем-то, очень проста.
[32:09.800 --> 32:11.800]  Действительно.
[32:11.800 --> 32:13.800]  То есть здесь рассуждение прям практически то же самое.
[32:13.800 --> 32:16.800]  Вот, допустим, у нас есть вот этот вот мистический поз.
[32:16.800 --> 32:19.800]  И мы пытаемся насчитать...
[32:24.800 --> 32:28.800]  Ну, допустим, вот i находится где-нибудь вот здесь.
[32:29.800 --> 32:31.800]  Я тут подальше где-нибудь рисую.
[32:34.800 --> 32:37.800]  Ну и что теперь можно заметить?
[32:37.800 --> 32:41.800]  Можно заметить, что раз вот эта вот строка теперь...
[32:44.800 --> 32:47.800]  Она совпадает с вот этой строкой,
[32:47.800 --> 32:49.800]  которая начинается...
[32:49.800 --> 32:51.800]  Какой позиции?
[32:51.800 --> 32:52.800]  Минус поз.
[32:52.800 --> 32:55.800]  Ну, начинается она ровно в позиции, раз вот тут поз и,
[32:55.800 --> 32:57.800]  поз соответственно в позиции и минус поз.
[33:00.800 --> 33:01.800]  Вот.
[33:01.800 --> 33:05.800]  И в результате рассуждения абсолютно аналогичная, собственно,
[33:05.800 --> 33:07.800]  в этом пункте, который у нас тут был.
[33:07.800 --> 33:12.800]  То есть, если оказалось, что z и минус поз оказалось меньше,
[33:12.800 --> 33:14.800]  чем вот эта вот длина этой строки,
[33:14.800 --> 33:17.800]  то есть вот как-то вот до сюда z-ка доходит, допустим, да,
[33:17.800 --> 33:21.800]  то, соответственно, тут потом тут x, тут y, тут x, то тут тоже y.
[33:21.800 --> 33:25.800]  И оказывается, что z функцию тут можно прям скриппать.
[33:25.800 --> 33:29.800]  Ну, а если z-ка оказалось больше, значит, вот эта вот строчка
[33:29.800 --> 33:32.800]  совпадает, соответственно, с вот этой строчкой.
[33:32.800 --> 33:34.800]  И тогда можно действительно писать,
[33:34.800 --> 33:38.800]  что это минимум из вот этой z-ки и ноты, и вот этой штуки.
[33:38.800 --> 33:40.800]  Вот такое простое доказательство.
[33:41.800 --> 33:43.800]  Да, вот это понятно?
[33:45.800 --> 33:46.800]  Совсем.
[33:46.800 --> 33:47.800]  Так.
[33:47.800 --> 33:48.800]  Где?
[33:48.800 --> 33:49.800]  Что?
[33:49.800 --> 33:51.800]  А почему у нас может быть x- и?
[33:52.800 --> 33:54.800]  Потому что может так случиться,
[33:54.800 --> 33:58.800]  что реальная z-ка вот в этом месте окажется сильно больше.
[33:58.800 --> 34:00.800]  А, все понятно.
[34:00.800 --> 34:01.800]  Это второй случай.
[34:01.800 --> 34:03.800]  Пусть оно окажется вот так.
[34:04.800 --> 34:06.800]  Тогда мы знаем, что здесь тогда действительно
[34:06.800 --> 34:09.800]  налицо вот такое совпадение, но только до сюда.
[34:09.800 --> 34:11.800]  Дальше просто символов нет.
[34:11.800 --> 34:13.800]  Поэтому пишем минимум.
[34:14.800 --> 34:15.800]  Вот.
[34:17.800 --> 34:22.800]  Ну, на самом деле, нот, ну, здесь получается следствие,
[34:22.800 --> 34:25.800]  которое надо, правда, очень-очень...
[34:25.800 --> 34:28.800]  Ну, правда, да, следствие здесь очень простое.
[34:30.800 --> 34:33.800]  То есть, на самом деле, следствие, что, опять же, если,
[34:33.800 --> 34:36.800]  ну вот, то есть z-i-t равно, на самом деле,
[34:36.800 --> 34:42.800]  минимуму из z от i процент пост
[34:44.800 --> 34:46.800]  и модуль s минус i.
[34:47.800 --> 34:49.800]  Самое главное, что это верно для всех i.
[34:50.800 --> 34:51.800]  Ну, да.
[34:51.800 --> 34:52.800]  Ну, для всех i...
[34:52.800 --> 34:54.800]  Ну, на самом деле, да.
[34:54.800 --> 34:55.800]  Ну, если мы еще...
[34:55.800 --> 34:58.800]  Да, если мы возьмем i меньше постов, то это х х тоже верно.
[34:58.800 --> 35:00.800]  Ну, то есть, надо, правда, сказать, что z нулевой это там
[35:00.800 --> 35:03.800]  либо модуляция, либо бесконечность, чтобы это...
[35:03.800 --> 35:05.800]  Сейчас, хотя нет, хотя нет, хотя тебе нет.
[35:05.800 --> 35:06.800]  Не совсем так.
[35:07.800 --> 35:08.800]  А хотя...
[35:08.800 --> 35:10.800]  А, нет, ну, это правда, да, потому что...
[35:11.800 --> 35:12.800]  Нет, ну, да, да, да.
[35:12.800 --> 35:14.800]  Это как бы всегда верно, потому что z-i-t
[35:14.800 --> 35:16.800]  по-любому не превосходит вот этой штуке.
[35:17.800 --> 35:19.800]  Да, если и меньше, чем пост.
[35:19.800 --> 35:21.800]  Ну, ладно, самое смешное, да, самый интересный случай.
[35:22.800 --> 35:25.800]  А что делать, если и делится на пост?
[35:26.800 --> 35:28.800]  Ну, ничего страшного, на самом деле.
[35:28.800 --> 35:31.800]  Если и делится на пост, то как бы это...
[35:33.800 --> 35:35.800]  Нет, на самом деле, давайте этот случай
[35:35.800 --> 35:38.800]  и когда и делится на пост, рассмотрим по трубке.
[35:38.800 --> 35:40.800]  Это на самом деле очень интересный,
[35:40.800 --> 35:42.800]  очень такой интересный случай,
[35:42.800 --> 35:45.800]  который нам периодически может пригождаться.
[35:45.800 --> 35:47.800]  Потому что дело вот в чем.
[35:49.800 --> 35:51.800]  Ну, вот, то есть, действительно,
[35:51.800 --> 35:53.800]  что означает, на самом деле...
[35:53.800 --> 35:55.800]  Что означает, что у нас, оказывается,
[35:55.800 --> 35:58.800]  вот эта строка равна вот этой.
[36:00.800 --> 36:02.800]  Вообще говоря, это означает маленький приятный факт.
[36:02.800 --> 36:06.800]  Это означает, что наша строка постпериодична.
[36:08.800 --> 36:10.800]  Ну, потому что это означает, что для любого
[36:10.800 --> 36:12.800]  достаточно адекватного g,
[36:12.800 --> 36:17.800]  s от g равно s от g плюс пост.
[36:19.800 --> 36:20.800]  Вот.
[36:21.800 --> 36:22.800]  Да, обратите внимание.
[36:22.800 --> 36:25.800]  Конечно же, длина строки не обязана делиться на пост.
[36:25.800 --> 36:27.800]  То есть, ну, там типичный пример, например,
[36:27.800 --> 36:32.800]  какой-нибудь a, b, c, a, b, c, a, b, c, a, b.
[36:34.800 --> 36:37.800]  Вот, допустим, здесь пост равен 3 Ом.
[36:38.800 --> 36:40.800]  И, действительно, строка 3 периодична.
[36:40.800 --> 36:43.800]  То есть, любые два символа на расстоянии 3 совпадают.
[36:43.800 --> 36:46.800]  Ну, легко убедиться, что, что, действительно,
[36:46.800 --> 36:49.800]  строка постпериодична, то есть, вот в этом смысле
[36:49.800 --> 36:50.800]  этого определения, тогда и только тогда,
[36:50.800 --> 36:53.800]  когда у него этот пост дотягивается до конца.
[36:54.800 --> 36:55.800]  Вот.
[36:57.800 --> 36:58.800]  Да, вот.
[36:58.800 --> 37:00.800]  А, на самом деле, что касается самого поза,
[37:00.800 --> 37:04.800]  как такой, на самом деле, минимальной такой величины,
[37:04.800 --> 37:05.800]  которая дотягивается до конца,
[37:05.800 --> 37:09.800]  то, на самом деле, как бы, в некоторых статьях,
[37:09.800 --> 37:12.800]  это вообще там для этого отдельное определение находится.
[37:13.800 --> 37:17.800]  Ну, кстати, про этот пост можно еще приятную штуку сказать.
[37:18.800 --> 37:21.800]  Вот, кстати, давайте маленькое приятное упражнение на понимание.
[37:22.800 --> 37:23.800]  Чему равен пост?
[37:24.800 --> 37:27.800]  Есть нод в терминологии префикс функции.
[37:32.800 --> 37:34.800]  Ну, это, по сути, модуль С...
[37:34.800 --> 37:35.800]  Что?
[37:35.800 --> 37:36.800]  Все строки?
[37:36.800 --> 37:40.800]  Нет, это модуль С минус префикс функции от всех, от последнего элемента.
[37:40.800 --> 37:42.800]  Да, на самом деле обратите внимание, да.
[37:42.800 --> 37:44.800]  Еще маленький приятный факт, что пост, на самом деле,
[37:44.800 --> 37:48.800]  равен модуль С минус пи от...
[37:48.800 --> 37:50.800]  Ну, соответственно, модуль С минус один.
[37:50.800 --> 37:51.800]  Ну, раз...
[37:52.800 --> 37:54.800]  Потому что обратите внимание,
[37:54.800 --> 37:57.800]  что это, фактически, максимальный собственный суффикс,
[37:57.800 --> 37:59.800]  который совпадает с префиксом.
[38:00.800 --> 38:04.800]  То есть, мы, по сути, храним значение префикс функции
[38:04.800 --> 38:06.800]  и по нему как-то восстанавливаем эту функцию.
[38:07.800 --> 38:08.800]  Нет, ну, не совсем.
[38:08.800 --> 38:09.800]  Ну, не совсем.
[38:09.800 --> 38:10.800]  То есть, в принципе, да.
[38:10.800 --> 38:11.800]  То есть, на самом деле, так.
[38:11.800 --> 38:13.800]  Мы в явном виде храним...
[38:13.800 --> 38:15.800]  То есть, ну, по факту, мы в явном виде храним
[38:15.800 --> 38:17.800]  префикс функцию в конце, по большому счету.
[38:19.800 --> 38:20.800]  В общем-то, да.
[38:21.800 --> 38:24.800]  И фактически, наверное, можно даже примерно прикинуть,
[38:24.800 --> 38:27.800]  что, в общем-то, примерно этим мы, в общем-то, и занимаемся.
[38:28.800 --> 38:29.800]  Вот.
[38:30.800 --> 38:31.800]  Ну, теперь тогда...
[38:31.800 --> 38:32.800]  Ну, вот.
[38:32.800 --> 38:34.800]  Так вот, я действительно к чему?
[38:34.800 --> 38:36.800]  То есть, поэтому неудивительно оказывается,
[38:36.800 --> 38:38.800]  что если вот и делятся на пост,
[38:38.800 --> 38:41.800]  ну, на самом деле, заметить можно утверждать и следующее.
[38:41.800 --> 38:42.800]  Вот.
[38:42.800 --> 38:43.800]  Давайте задумаемся, вот над чем.
[38:44.800 --> 38:45.800]  Ну, вот.
[38:45.800 --> 38:46.800]  Внимание, вопрос.
[38:46.800 --> 38:50.800]  Какие еще строки будут дошадить до конца?
[38:57.800 --> 38:58.800]  Вот.
[38:58.800 --> 38:59.800]  Ладно.
[38:59.800 --> 39:00.800]  Я сейчас переформулирую это.
[39:00.800 --> 39:02.800]  Может быть, даже удобно переформулировать
[39:02.800 --> 39:03.800]  в терминах префикс функции.
[39:05.800 --> 39:06.800]  Очень хочется это сформулировать,
[39:06.800 --> 39:10.800]  потому что раз уж тут зашла речь, то нельзя не отметить.
[39:11.800 --> 39:13.800]  Там делится у маленького приятного свойства.
[39:14.800 --> 39:15.800]  Так.
[39:16.800 --> 39:17.800]  Так.
[39:18.800 --> 39:19.800]  Ага.
[39:21.800 --> 39:22.800]  Ну, вот.
[39:22.800 --> 39:23.800]  Значит, смотри.
[39:24.800 --> 39:25.800]  Прижила-была.
[39:25.800 --> 39:26.800]  Сейчас вот абстражно.
[39:26.800 --> 39:27.800]  Строка С.
[39:29.800 --> 39:32.800]  То есть, давайте на этот раз, давайте для удобства,
[39:33.800 --> 39:36.800]  может быть, в один индексации рассмотрим, хотя по барабану, в общем.
[39:37.800 --> 39:38.800]  Смотрите.
[39:41.800 --> 39:43.800]  Значит, я очень хочу рассмотреть вот что.
[39:43.800 --> 39:49.800]  Допустим, вот эта вот строка имеет длину P от S.
[39:56.800 --> 39:57.800]  Понятно, да?
[40:01.800 --> 40:02.800]  Вот.
[40:04.800 --> 40:05.800]  Ну, вот.
[40:05.800 --> 40:07.800]  И теперь возникает следующий вопрос.
[40:07.800 --> 40:10.800]  Я хочу рассмотреть вот эту всеми любимую последовательность.
[40:10.800 --> 40:11.800]  П от P от modulus.
[40:12.800 --> 40:15.800]  P от P от modulus.
[40:18.800 --> 40:19.800]  Ну и так далее.
[40:21.800 --> 40:24.800]  Ну, она может быть, конечно, очень большой длиной.
[40:24.800 --> 40:25.800]  Понятно, да?
[40:26.800 --> 40:27.800]  Вот.
[40:30.800 --> 40:31.800]  Ну, вот.
[40:31.800 --> 40:32.800]  Ну, на самом деле,
[40:33.800 --> 40:35.800]  на самом деле оказывается, что ее можно,
[40:35.800 --> 40:38.800]  на самом деле представить не обязательно за линию,
[40:38.800 --> 40:40.800]  но в более компактном виде.
[40:41.800 --> 40:42.800]  Так что, смотрите.
[40:43.800 --> 40:45.800]  Нет, давайте, оказывается, нам, возможно, пришло время,
[40:45.800 --> 40:49.800]  на всякий случай, ввести еще такое красивое понятие, как
[40:52.800 --> 40:55.800]  удивительно, как shift с индексом S.
[40:57.800 --> 40:58.800]  Вот давайте так.
[40:58.800 --> 41:02.800]  В терминологии вот статьи, которые мы сегодня, по крайней мере, начнем изучать,
[41:02.800 --> 41:04.800]  будет понятие такой массив.
[41:04.800 --> 41:06.800]  Значит, такой вот тоже массив.
[41:06.800 --> 41:07.800]  Shift.
[41:09.800 --> 41:11.800]  Значит, S от одного до N.
[41:11.800 --> 41:14.800]  И shift S от, допустим, Итого.
[41:17.800 --> 41:19.800]  Он равен как раз вот
[41:21.800 --> 41:23.800]  действительно минимальному такому
[41:26.800 --> 41:27.800]  урону.
[41:29.800 --> 41:30.800]  Да.
[41:30.800 --> 41:31.800]  То есть, да.
[41:32.800 --> 41:33.800]  Минимальному такому L,
[41:35.800 --> 41:38.800]  что, действительно, S от L плюс 1 до I,
[41:38.800 --> 41:40.800]  ну, раз уж в один индексации,
[41:40.800 --> 41:44.800]  равна S от 1 и минус I.
[41:50.800 --> 41:54.800]  Ну, короче говоря, минимальный, ну, то есть, так, можно сказать,
[41:54.800 --> 41:57.800]  минимальный период этого префекса строки S.
[41:58.800 --> 41:59.800]  По большому счету.
[42:00.800 --> 42:01.800]  Понимаете, да?
[42:02.800 --> 42:03.800]  Ну, ладно.
[42:03.800 --> 42:04.800]  Давайте.
[42:04.800 --> 42:07.800]  Конечно, L больше 0 нас интересует, конечно.
[42:11.800 --> 42:13.800]  А то мы могли бы сказать, для L равно 0, это верно.
[42:13.800 --> 42:14.800]  Ну, интересно.
[42:16.800 --> 42:17.800]  Вот.
[42:17.800 --> 42:20.800]  Ну, одновременно, просто он же shift, он же это, он же минимальный период.
[42:20.800 --> 42:23.800]  Ну, просто иногда полезно смотреть именно на него,
[42:23.800 --> 42:26.800]  потому что понятно, что он тождественно равен, как мы уже догадываемся,
[42:26.800 --> 42:30.800]  просто I минус префикс функции, правда?
[42:33.800 --> 42:34.800]  Согласны?
[42:34.800 --> 42:36.800]  Ну, в один индексации, конечно.
[42:37.800 --> 42:38.800]  Так вот.
[42:44.800 --> 42:45.800]  Можно теперь заметить.
[42:46.800 --> 42:47.800]  Так вот.
[42:47.800 --> 42:55.800]  Вот в терминах shift на самом деле есть мистическое утверждение.
[42:57.800 --> 43:00.800]  На самом деле мистическое утверждение звучит так.
[43:01.800 --> 43:03.800]  В общем, я его сформулирую так.
[43:03.800 --> 43:05.800]  Значит, вот утверждение.
[43:06.800 --> 43:10.800]  Если этот shift достаточно мал,
[43:11.800 --> 43:19.800]  то есть если shift, допустим, S от модуль S меньше,
[43:20.800 --> 43:22.800]  вот чуть позже поймем, чего,
[43:27.800 --> 43:44.800]  то я утверждаю, что на самом деле shift от P от S
[43:49.800 --> 43:53.800]  равен, собственно, исходному шифту от S.
[43:56.800 --> 44:09.800]  Да, замудренное, конечно, утверждение получилось,
[44:10.800 --> 44:12.800]  но хочу я сказать следующее.
[44:13.800 --> 44:15.800]  То есть, смотрите, что такое shift?
[44:15.800 --> 44:17.800]  Shift – это вот эта штука, да?
[44:18.800 --> 44:20.800]  Вот это вот shift.
[44:22.800 --> 44:25.800]  Так вот, я утверждаю, что если вот этот shift достаточно мал,
[44:25.800 --> 44:28.800]  то когда вы тут скопнете на P от P от S,
[44:39.800 --> 44:41.800]  то оказывается,
[44:46.800 --> 44:49.800]  что вот этот скачок тоже будет shift.
[44:56.800 --> 44:59.800]  Вот я утверждаю, что он в точности им.
[45:00.800 --> 45:02.800]  Осталось только выяснить.
[45:03.800 --> 45:05.800]  Ну вот, и в общем-то и дальше некоторое время,
[45:05.800 --> 45:08.800]  то есть на самом деле отсюда будет следовать, что дальше тоже будет,
[45:08.800 --> 45:11.800]  то есть скачки shift, shift, shift и так далее,
[45:11.800 --> 45:13.800]  ну и до некоторых моментов.
[45:15.800 --> 45:19.800]  Но давайте поймем, откуда же я это утверждение вообще взял?
[45:20.800 --> 45:24.800]  Ну, как мне понятно, что вот если мы завернем еще на shift,
[45:24.800 --> 45:26.800]  то такой суффикс будет префиксом.
[45:26.800 --> 45:29.800]  Да, ну во-первых, заметим, что строка shift периодично, да?
[45:31.800 --> 45:34.800]  Поэтому получается автоматически, что действительно,
[45:34.800 --> 45:36.800]  вот эта строка, конечно же, там, вот действительно,
[45:36.800 --> 45:39.800]  аналогичной вот этой вот строке, естественно, равна.
[45:40.800 --> 45:43.800]  Вот этой вот, в смысле, с shift.
[45:48.800 --> 45:52.800]  То есть, получается, что строка длины вот этой P от…
[45:53.800 --> 45:57.800]  То есть, получается, вот эта вот строка длины P от S минус shift,
[45:57.800 --> 45:59.800]  это кандидат в P от P от S.
[46:01.800 --> 46:03.800]  Но возникает естественный вопрос.
[46:05.800 --> 46:06.800]  А чего не больше?
[46:09.800 --> 46:13.800]  Вдруг окажется, что мы возьмем какой-нибудь,
[46:14.800 --> 46:16.800]  какой-нибудь максимально яркий маркер,
[46:18.800 --> 46:20.800]  например, черный,
[46:20.800 --> 46:22.800]  и вдруг совершенно случайно окажется,
[46:22.800 --> 46:28.800]  что на самом деле еще вот эта строка внезапно оказалась равна вот этой.
[46:30.800 --> 46:32.800]  И она же, конечно же, вот этой.
[46:35.800 --> 46:36.800]  Вдруг такое окажется?
[46:37.800 --> 46:40.800]  И вот эту вот длину, допустим, назовем,
[46:41.800 --> 46:43.800]  какую-нибудь A, вдруг так окажется?
[46:50.800 --> 46:53.800]  Ну, с другой стороны, что тогда можно сказать?
[46:54.800 --> 46:58.800]  У нас в нашей строке есть два периода, вовсе, которые,
[46:59.800 --> 47:02.800]  ну, как бы, близкие, значит, не один, ну, как бы, не один, как-то огромный,
[47:02.800 --> 47:05.800]  но я думаю, что можно противоречить того, что shift минимальный.
[47:06.800 --> 47:09.800]  Ну, нет, ну как минимальный?
[47:09.800 --> 47:13.800]  Ну, тут, да, то есть, в принципе, да, заметим, что из этого, на самом деле,
[47:13.800 --> 47:15.800]  мы не можем сказать, что shift минимальный,
[47:15.800 --> 47:17.800]  что префикс функции здесь была посчитана неправильно.
[47:18.800 --> 47:20.800]  А каким же образом мы можем это сделать?
[47:21.800 --> 47:26.800]  Ну, что мы знаем? Что мы знаем, что если у нас, ну, типа S E равно S E плюс shift, да?
[47:27.800 --> 47:29.800]  А еще мы знаем, что S E равно S E плюс L,
[47:30.800 --> 47:33.800]  теперь. Ну, где ли вот этот больше shift?
[47:34.800 --> 47:39.800]  Так, давайте, я попробую это, наверное, более, ну, в общем,
[47:39.800 --> 47:41.800]  аккуратно нарисовать еще.
[47:42.800 --> 47:45.800]  Так, давайте, я даже что-то больше нарисую.
[47:46.800 --> 47:49.800]  Тут нам, прям, вот, нужна, прям, вот, хорошая иллюстрация.
[47:50.800 --> 47:54.800]  Да, то есть, если у нас есть, то есть, давайте посмотрим.
[47:55.800 --> 47:57.800]  То есть, если у нас произошло так, что вот тут у нас, действительно,
[47:58.800 --> 48:00.800]  произошел вот этот shift и вот это равенство,
[48:01.800 --> 48:04.800]  то, на самом деле, как бы, мы не можем сказать, что shift минимальный,
[48:04.800 --> 48:07.800]  что вот тут у нас, действительно, произошел вот этот shift и вот это равенство,
[48:08.800 --> 48:10.800]  то, на самом деле, как у нас строчка вообще устроена?
[48:11.800 --> 48:14.800]  Оно устроено так, что вот есть вот этот вот блок по шифту,
[48:15.800 --> 48:18.800]  и, на самом деле, заметим, что строчка дальше устроена так.
[48:19.800 --> 48:29.800]  То есть, у нас тут вот блок, блок, блок, блок, блок, блок, блок,
[48:29.800 --> 48:33.800]  блок и в конце огрызов.
[48:37.800 --> 48:39.800]  То есть, на самом деле, заметим, что эти строчки абсолютно одинаковые,
[48:40.800 --> 48:42.800]  а это префикс, это одинаковый стройки.
[48:43.800 --> 48:44.800]  Вот, понимаете, да?
[48:45.800 --> 48:46.800]  Понимаете?
[48:47.800 --> 48:48.800]  Да, нет, наверное.
[48:49.800 --> 48:50.800]  Отлично.
[48:51.800 --> 48:57.800]  Вот, то есть, получается, что вот это вот равно, получается, вот, тому же самому сдвинутому нашу.
[48:57.800 --> 48:58.800]  Вот.
[49:02.800 --> 49:03.800]  Окей.
[49:04.800 --> 49:12.800]  Да, ровно, из этой же картинки абсолютно же следует, что тогда вот эта вот штука автоматически равна вот этой вот, ну, посмотри.
[49:13.800 --> 49:14.800]  Видно?
[49:15.800 --> 49:18.800]  Теперь давайте предположим, что что-то пошло не так.
[49:19.800 --> 49:20.800]  Ну, вот.
[49:21.800 --> 49:32.800]  И выяснилось, что, оказывается, можно еще, то есть, для шифта тут, то есть, префикс функцию найти чуть больше, чем, чем вот это вот.
[49:33.800 --> 49:36.800]  То есть, оказывается, что у нас равенство оказалось вот какое-то вот такое.
[49:37.800 --> 49:42.800]  То есть, вот это вот оказалось равно, что-то вот тут еще.
[49:42.800 --> 49:43.800]  Вот.
[49:44.800 --> 49:47.800]  То есть, равно и этому, и автоматически там где-то вот это.
[49:48.800 --> 49:49.800]  Да?
[49:49.800 --> 49:51.800]  Вот так, ну если сдвинуть, ну вот.
[49:52.800 --> 49:53.800]  Да, получается вот так.
[49:54.800 --> 49:57.800]  Чуть меньше сдвинули, наверное, но то ли досюда там где-то, то ли досюда.
[49:58.800 --> 49:59.800]  Тогда что вообще получается?
[50:00.800 --> 50:01.800]  Ну.
[50:02.800 --> 50:06.800]  Давайте, если вот попробовать действительно поизраться так, то да.
[50:07.800 --> 50:11.800]  То есть, если у нас тут сдвиг на L, то вообще можно заметить, что вот этот префикс, допустим, вот этот, вот этот вот.
[50:12.800 --> 50:18.680]  разбился она, то есть этот shift допустим разбился на допустим на вот этот вот x и y, правда?
[50:18.680 --> 50:28.880]  Ну то есть в принципе можно заметить на самом деле, ну можно на самом деле пытаться вот так вот
[50:28.880 --> 50:41.160]  нарисовать, да, чтобы везде x и y допустим, x и y, вот x и y, и тут вот так, где-то тут у нас,
[50:41.160 --> 50:50.280]  так, ну и тут на самом деле где-то вот, непонятно где x и y, ну вот, ну еще кончик непонятно там,
[50:51.280 --> 51:06.920]  но и тут заметим, что у нас имеет место x и y, вот, вот, и так, но что мы тогда знаем? То есть смотрите,
[51:06.920 --> 51:12.760]  что мы знаем? Мы знаем, то есть если shift достаточно маленький, достаточно где-то маленький,
[51:12.760 --> 51:20.240]  то мы знаем, то с одной стороны мы знаем, что вот эта строка равна вот этой, но с другой стороны
[51:20.240 --> 51:25.760]  раз мы еще вот это знаем, то получается, что очень интересно, что вот x и y на самом деле равен y и x,
[51:25.760 --> 51:35.840]  то есть вот такое мистическое свойство, x и y равен y и x, понимаете, да? А что это вообще значит? А
[51:35.840 --> 51:43.360]  значит вообще интересная вещь, что если я вот эти две строки удвиню влево на x и y, то как бы эта
[51:43.360 --> 51:58.000]  строка увеличится на x и y, а эта увеличится на y и x, то тоже самое, понимаете, да? Вот эти две черные,
[51:58.000 --> 52:04.960]  видите? Вот у нас тут есть вот эти две черные спряты, которые равны, да? А давайте удлиним влево на длину
[52:04.960 --> 52:21.000]  и x плюс y. Это одна удлиниться на, получается, x и y, а другая удлиниться на y и x, что, как мы выяснили,
[52:21.000 --> 52:28.960]  одно и то же. Вот тогда получается, что мы неправильно считали префикс функцию для глобальной строки.
[52:28.960 --> 52:46.000]  Получается, если shift достаточно мало, то вот впечатлительно видно на люксу. А теперь внимание,
[52:46.000 --> 52:55.760]  вопрос. Как вы думаете, что я должен написать в утверждении, чтобы вот это рассуждение про
[53:25.760 --> 53:37.520]  если shift не больше, чем треть слиной строки, то это точно достаточно. Так, треть. Нет, нужна ли нам именно треть?
[53:37.520 --> 53:47.240]  Нет, ну давайте подумаем, чем мы вообще пользовались? По большому счету, по-моему,
[53:47.240 --> 53:53.640]  мы в явном виде воспользовались только тем, что у нас вот этих блоков как минимум два, правда?
[53:53.640 --> 54:02.640]  То есть мы воспользовались тем, что у нас есть вот этот блок и вот этот блок. По большой нот.
[54:02.640 --> 54:13.960]  Ещё мы где-то сказали, что x, y, y, x. Хотя да, где мы этим воспользовались? Ну, где мы воспользовались тем,
[54:13.960 --> 54:33.200]  что x, y, y, y, x? Откуда мы это выкручивали? Из того, что там начинается новая строка,
[54:33.200 --> 54:46.760]  которая как бы лучше, да, вот из y, она предлевается ещё хотя бы на, то есть хотя бы на x. Ну да, по большому счету, да, поэтому...
[54:46.760 --> 54:58.800]  Ну да, правда, тут возникает вопрос, действительно. Ну да, получается, при таком доказательстве,
[54:58.800 --> 55:13.160]  получается маленькая приятная вещь. Ну вот, не знаю, но третья получается всё-таки. Ну да. Так, ну допустим,
[55:13.160 --> 55:21.840]  если shift, можно сформулировать действительно утверждение о том, что модуле 9 НАТО. Так.
[55:28.800 --> 55:43.640]  Теперь давайте, ну вот. Ну, у меня почему-то жуткое подозрение, что можно и надо.
[55:43.640 --> 55:57.560]  Давайте попробуем. Давайте-ка попробуем вот что сделать. Давайте попробуем рассмотреть
[55:57.560 --> 56:04.320]  случаи, когда у нас блоков. Вот давайте рассмотрим. Ну, а первое, давайте, давайте вот посмотрим.
[56:04.320 --> 56:08.960]  Действительно, можно ли требовать, что действительно таких блоков у нас хотя бы три? То есть,
[56:08.960 --> 56:14.440]  нельзя ли потребовать, что у нас вот этих блоков хотя бы два? Давайте проводить.
[56:14.440 --> 56:24.640]  Будем проводить красивый научный работа. Ну нет, нет, нельзя. Прям пример есть?
[56:24.640 --> 56:34.920]  Давайте возьмём. Вот у нас есть. Давайте предположим, что у нас есть блок, блок и префект.
[56:34.920 --> 56:50.000]  Shift, shift и что-то ещё. Так. Теперь возникает вопрос. Предположим, что у нас неожиданно
[56:50.000 --> 57:11.560]  вот тут оказался X и Y. И вот это вот оказывается равно. Ладно, не вот это. Вот это. Ну, в смысле, вот такому.
[57:11.560 --> 57:16.320]  У нас же игроке так определялся, что вот эта строка начиналась с него.
[57:16.320 --> 57:31.600]  Да, да, да. Хорошо. Да, это, наверное, надо поменьше. Вот так вот нарисуем. А, ну если это блок устраивался,
[57:31.600 --> 57:39.880]  то и вот. Вот тогда, действительно, что у нас получается? Мы же знаем вот что. То есть, я утверждаю,
[57:39.880 --> 57:48.160]  что, ну то есть, так как у нас вот это вот равно вот этому напоминаем, да, вот, например, вот такое,
[57:48.160 --> 57:59.360]  то можно это как-то сдвинуть. То есть, видим, что у нас тут, действительно, на лицо, действительно, сдвиг игрока.
[57:59.360 --> 58:08.080]  То есть, по крайней мере, можно точно утверждать следующее. Что, с одной стороны, это X и Y,
[58:08.080 --> 58:14.320]  но с другой стороны, смотрите внимательно, по крайней мере, мы точно знаем, что, ну раз вот эта
[58:14.320 --> 58:20.480]  строка по факту совпадает с префиксом, да, обратите внимание, то тогда получается, вот эта строка начинается с игрока.
[58:31.280 --> 58:32.280]  Это с одной стороны.
[58:32.280 --> 58:43.560]  Это уж с игрока точно. А вот что тут будет идти дальше? Будет обязательно дальше идти здесь X?
[58:43.560 --> 59:05.520]  Полое ощущение, что идти там дальше. Но почему?
[59:13.560 --> 59:36.520]  Давайте так, ну если у нас, ну не знаю, например, для нас таки ровно два шип, то это неверное, что ли, там, примеры есть.
[59:37.480 --> 59:40.480]  Если для нас таки ровно два шип, то, очевидно, не подойдет.
[59:40.480 --> 59:54.480]  Да, ну действительно, если тут прям пусто, то, действительно, можно привести, действительно, к примеру, строку АВА-АВА.
[59:54.480 --> 59:57.480]  Да, например.
[59:57.480 --> 01:00:05.480]  Ну да, то есть, заметим, что совсем мало не получится. То есть, действительно, на лицо видим, что здесь шифт равен 3,
[01:00:06.440 --> 01:00:09.440]  а вот в этой строке шифт уже, наверное, равен чуть меньше.
[01:00:09.440 --> 01:00:12.440]  Да, действительно, действительно.
[01:00:30.440 --> 01:00:32.440]  Такого не хватает, интересно.
[01:00:33.400 --> 01:00:39.400]  А приписать, интересно, один символ, то можно, чтобы это было адекватно?
[01:00:39.400 --> 01:00:43.400]  То есть, если тут ровно, то не получается.
[01:00:43.400 --> 01:00:48.400]  А если написать вот так?
[01:00:48.400 --> 01:00:51.400]  Если один символ написать консульту, то тоже не получается.
[01:00:51.400 --> 01:00:52.400]  Тоже не получается.
[01:00:52.400 --> 01:00:55.400]  Ну вот в данном случае, ну вот этот пример не подходит.
[01:00:55.400 --> 01:00:56.400]  А какой?
[01:00:57.320 --> 01:01:00.320]  Нужно Б, каждый раз, два раза было. Не по одной, а по две.
[01:01:12.320 --> 01:01:14.320]  Если мы допишем консульту Б?
[01:01:14.320 --> 01:01:16.320]  Нет, если мы допишем консульту Б, то там шифт будет уже не 4.
[01:01:16.320 --> 01:01:17.320]  Будет не 4?
[01:01:17.320 --> 01:01:18.320]  Конечно.
[01:01:18.320 --> 01:01:19.320]  Почему?
[01:01:19.320 --> 01:01:49.320]  Ну, потому что тут АБАБ, а тут АБААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААА
[01:01:49.320 --> 01:01:57.240]  Да, вот так странно, что, действительно, если это символ-нот, то если символ есть, то, как бы
[01:01:57.240 --> 01:02:03.280]  А, можно, например, АА БАААААаАААААААААА АА в конце еще
[01:02:03.440 --> 01:02:09.540]  АА БАААААААААА ААБААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААА
[01:02:09.540 --> 01:02:15.900]  тут шифт вот такой да действительно обратить внимание тут шифт 5 а в этой
[01:02:15.900 --> 01:02:31.660]  строке шифт уже 2 4 ну в смысле 4 ну что ж действительно да получается что
[01:02:31.660 --> 01:02:38.460]  действительно границу мы нашли точно воду лес делить на 3
[01:02:40.540 --> 01:02:45.540]  вот действительно
[01:02:49.540 --> 01:02:54.540]  да действительно есть такое маленькое приятное свойство
[01:02:54.540 --> 01:03:10.540]  ну что но действительно но тем не менее на самом деле утверждение оказывается
[01:03:10.540 --> 01:03:16.860]  достаточно красиво на самом деле с точки зрения префикс функция но означает
[01:03:16.860 --> 01:03:22.540]  следующее что если префикс функция как бы меньше строки всего лишь на треть
[01:03:22.540 --> 01:03:27.900]  обратите внимание пока она меньше на 3 то некоторое время префикс функции
[01:03:27.900 --> 01:03:32.700]  образуют такую убывающую арифметическую прогрессию правда причем обратите
[01:03:32.700 --> 01:03:37.580]  внимание то есть если у нас эта прогрессия идет там допустим шагом и
[01:03:37.580 --> 01:03:44.420]  то есть там с-э и с-2 и так далее то она будет идти до тех пор пока тут оставшаяся
[01:03:44.420 --> 01:03:58.340]  длина не станет меньше чем строго меньше чем 3 и только после того как
[01:03:58.340 --> 01:04:03.300]  действительно она будет 3 и только после этого мы можем утверждать что этот
[01:04:03.300 --> 01:04:10.500]  шифт неожиданно уменьшится в принципе возникает тогда получается что
[01:04:10.500 --> 01:04:13.860]  последовательность префикс функций может быть представлена как таки
[01:04:13.860 --> 01:04:17.620]  последовательность арифметических прогрессий где количество этих
[01:04:17.620 --> 01:04:22.340]  арифметических прогрессий получается не превосходит чего
[01:04:34.900 --> 01:04:39.420]  ну вот ну получается логарифма ведь действительно если взять прям целую
[01:04:39.420 --> 01:04:44.220]  арифметическую прогрессию правда то мы можем заметить что когда но вот что
[01:04:44.220 --> 01:04:48.060]  сколько не было шаров а как минимум в полтора раза строчка уменьшится правда
[01:04:48.060 --> 01:04:52.740]  а это не дает нам в этот способ как раз логарифм устанавливать
[01:04:52.740 --> 01:05:01.420]  считать сейчас префикс функцию да ну если у нас всех бы значений нужно
[01:05:01.420 --> 01:05:12.460]  перебирать как-то там какая проблема там ну как арифметическая прогрессия это
[01:05:12.460 --> 01:05:16.060]  конечно да но просто там как бы в дереве при фиксунце в эту арифметическую
[01:05:16.060 --> 01:05:21.100]  прогрессию еще могут лезать поэтому совсем просто наверное не получится хотя
[01:05:21.100 --> 01:05:25.340]  наверное да быстро скорее всего в эту сторону
[01:05:25.340 --> 01:05:30.860]  там вроде как раз рассказали там были были про периоды нет про периода ну то есть
[01:05:30.860 --> 01:05:35.480]  когда рассказывали как раз о ток не да да да да нет ну понятно какие-то
[01:05:35.480 --> 01:05:39.260]  свойства да ну и действительно давайте ладно нет а давайте ладно раз уж пошла
[01:05:39.260 --> 01:05:43.180]  такая раз у нас сегодня такой по-моему сегодня получился такой тип и получается
[01:05:43.180 --> 01:05:51.420]  такой типичный семинар на самом деле где мы тут больше думаем чем читаем да ну
[01:05:51.540 --> 01:05:57.700]  прежде чем вот это стереть мы только да он это что-то не доделали
[01:05:57.700 --> 01:06:01.800]  а на самом деле это делали мы просто отдельно рассмотрели случаи когда и делится
[01:06:01.800 --> 01:06:05.440]  на пост и просто рассмотрели про периодичность мы не обсудили заново
[01:06:05.440 --> 01:06:13.460]  добавление символов а ой ой ой ой ой ой кошмар так да отматываем да прямо
[01:06:13.460 --> 01:06:18.260]  по ремонтаже там уже какой-то все типа да тут тут мы прервались продолжение будет
[01:06:18.260 --> 01:06:26.300]  через 37 да но действительно давайте смотри вот там эти формулы мы поверили
[01:06:26.300 --> 01:06:29.220]  конечно мы занимались тем что вот когда и делится на пост мы начали
[01:06:29.220 --> 01:06:33.020]  рассматривать интересный случай и заметили что в принципе если пост
[01:06:33.020 --> 01:06:37.780]  достаточно мало то можно даже даже предсказать чему будет равен следующий
[01:06:37.780 --> 01:06:44.900]  пост в случае чего но вот но в общем это и не важно тоже ладно с этим то мы
[01:06:44.900 --> 01:06:48.340]  поняли остается только один маленький вопрос хорошо за это мы научились
[01:06:48.340 --> 01:06:53.380]  считать причем честно вот а теперь мы с кайта просто как же этот символ
[01:06:53.380 --> 01:06:59.180]  приписывать но здесь уже на самом деле никаких проблем особо нет потому что
[01:06:59.180 --> 01:07:05.260]  как вы как вы знаете за функцию для строки с мы насчитывать уже умеем за от
[01:07:05.260 --> 01:07:09.940]  единицы поэтому можем просто начинать способ вот проверить вот пост подходит
[01:07:09.940 --> 01:07:13.820]  ли нам и нет как проверить мы знаем что как бы до конца строки с у него под строка
[01:07:13.820 --> 01:07:19.100]  доходит и возникает вопрос следующий символ равен этому ц если равен то в
[01:07:19.100 --> 01:07:24.860]  общем-то пост никуда девать не надо за 1 если нет то значит пост двигаем на
[01:07:24.860 --> 01:07:28.020]  единичку остается только понять верно ли что вот этот под строка равна
[01:07:28.020 --> 01:07:32.780]  префикс как-то проверить ну заметим что за эту функцию от пост плюс один ну
[01:07:32.780 --> 01:07:37.220]  в предположении что этого символа ц нет мы вычислить можем правда быть только
[01:07:38.220 --> 01:07:47.500]  за вот единицы вот как мы уже поняли то есть дальше то есть дальше тут ну то
[01:07:47.500 --> 01:07:51.060]  есть получается как мы тут неожиданно доказали на самом деле то есть на самом
[01:07:51.060 --> 01:07:54.620]  деле начинает с этого места то есть тут просто это за функция в строке с идет
[01:07:54.620 --> 01:07:59.180]  тупого периода у нас такая с периодом пост такая последовательности период мы
[01:07:59.180 --> 01:08:04.260]  знаем ну ладно не совсем период период там поможет для того что она обрубается
[01:08:04.900 --> 01:08:16.900]  вот но это не важно то есть важно что мы знаем но важно что в любом случае главное
[01:08:16.900 --> 01:08:20.820]  что мы их знаем и главное теперь можем проверять если z функция до сюда до
[01:08:20.820 --> 01:08:24.940]  езда же не доходит до конца то ее проверять бессмысленно а если доходит то
[01:08:24.940 --> 01:08:28.500]  значит проверяем нельзя лишь у и носим 한번 в цель этот пост будет просто
[01:08:28.500 --> 01:08:31.540]  сдвигаться сдвигаться сдвигаться сдвигаться но и сдвигаем до тех пор пока
[01:08:31.540 --> 01:08:37.300]  очередной пост продлить не удастся. И получается, ну фактически получается метод двух указателей.
[01:08:37.300 --> 01:08:44.260]  Такой классический метод двух указателей. Вот амортизирован, это получается за от 1.
[01:08:44.260 --> 01:08:53.620]  Вот. Ну на самом деле, да, можно на самом деле задуматься, то есть про такую отдельную фишку
[01:08:53.620 --> 01:08:59.460]  действительно нельзя ли как эту учетную стоимость изменить на, может быть, чуть
[01:08:59.460 --> 01:09:06.980]  более худшую, но честно. Вроде как из-за функции можно будет создавать префикс функцию,
[01:09:06.980 --> 01:09:13.220]  поэтому тогда мы вам префикс функцию тоже научим даже. Ну да. Кажется, что эта функция так не прокачивается.
[01:09:13.220 --> 01:09:26.580]  Сейчас. Ну так сказать. Нет, ну почему? Нет, ну смотрите, ну дело в том, что как бы, ну тут,
[01:09:26.580 --> 01:09:31.940]  конечно, идея может быть уже в том, что вот исходя из этого утверждения, мы на самом деле можем
[01:09:31.940 --> 01:09:37.940]  знать, как устроены на самом деле все эти подходящие посты в принципе. Они устроены как красивые
[01:09:37.940 --> 01:09:43.780]  арифметические прогрессии. Ну вот такого-то момента, да. Да. И действительно, идея может заключаться в том,
[01:09:43.780 --> 01:09:51.060]  что для каждой, допустим, для каждой, допустим, этой арифметической прогрессии, допустим, мы,
[01:09:51.060 --> 01:09:56.500]  честно, храним все символы, которые нефть теоретически можно применить.
[01:09:56.500 --> 01:10:04.420]  Нет, хотя, ну вот. Хотя нет, ну там будут, конечно, всякие подлямки, конечно, неприятные. Потому что когда мы
[01:10:04.420 --> 01:10:09.860]  перемещаемся к следующему, как там следующие символы считать? Так что да, не так просто. Поэтому
[01:10:09.860 --> 01:10:19.500]  лучше начнем с префикс. Вот. А вот этому алгоритму вопроса есть? Нету? Хорошо. Значит, тогда вот что.
[01:10:19.500 --> 01:10:33.500]  Ну вот. Тогда действительно последнее, что мы сейчас делаем, тогда перед переживом. Далее, ну вот. То есть действительно,
[01:10:33.500 --> 01:10:39.860]  последнее, что хочется, это задуматься вот над каким вопросом. Раз мы уже поняли, что префикс
[01:10:39.860 --> 01:10:44.700]  функция действительно обладает вот такими скачками действительно арифметической прогрессии,
[01:10:44.700 --> 01:10:50.540]  то действительно нельзя ли вычислять новую префикс функцию с добавлением нового символа каким-нибудь
[01:10:50.540 --> 01:10:57.420]  красивым и учетным образом. То есть красивым и неучетным образом. И оказывается маленькая приятная
[01:10:57.420 --> 01:11:04.260]  вещь. Ведь действительно. Итак, вот давайте внимание еще раз, что мы хотим. Вот хотим мы строку s,
[01:11:04.260 --> 01:11:11.260]  мы хотим вычитать у нее префикс функцию, но при этом, когда добавляется символ c, мы хотим эту
[01:11:11.260 --> 01:11:18.580]  префикс функцию тоже вычислять, но при этом желательно за от какой-нибудь адекватное время, но что важно,
[01:11:18.580 --> 01:11:30.620]  честно. Без вот этой амортизации. Так что это можно сделать. Ну на самом деле, давайте подумаем вот о чем.
[01:11:30.620 --> 01:11:43.180]  Заметим, что можно на самом деле, если у нас s равно, как всегда, с от одного до модуля с какого-нибудь,
[01:11:43.180 --> 01:11:49.980]  то есть в один адекват, то что мы делаем? То как мы обычно вычисляем вот эту вот префикс функцию?
[01:11:49.980 --> 01:12:03.660]  Обычно мы скачем, да, то есть там код что-то в духе там for, там действительно g равно p от там бывшего
[01:12:03.660 --> 01:12:14.500]  модуля s, g больше нуля, g равно p от g. Если там совершенно случайно оказалось, что s g плюс первое
[01:12:14.500 --> 01:12:23.380]  равно s, равно вот этому новому символу c, то значит p от вот этот модули s плюс 1 оказывается теперь равно.
[01:12:23.380 --> 01:12:38.780]  Равно теперь получается g плюс 1 и соответственно бряк. Было дело, да, помните? Было дело?
[01:12:38.780 --> 01:12:53.620]  Там была префикс функция. Префикс функции такое было когда-нибудь? Так вот, теперь возникает вопрос.
[01:12:53.620 --> 01:13:00.060]  Очень хочется, что мы знаем, что учетная стоимость работы этого кода от единицы, ну там можно как-нибудь с
[01:13:00.060 --> 01:13:06.020]  монетками писать, а мы хотим в честную. Ну вообразить себе теперь это можно следующее. Ну во-первых,
[01:13:06.020 --> 01:13:14.380]  заметим, но заметить можно следующее. Давайте нарисуем, на самом деле, то есть раз уж мы в прошлый
[01:13:14.380 --> 01:13:22.540]  раз ввели автомат префикс функции, то неплохо бы ввести дерево префикс функции. Вот давайте просто так
[01:13:22.540 --> 01:13:29.860]  и введем. То есть у нас будет действительно тоже в дереве вершины 0, 1, 2 и так далее модуль s,
[01:13:29.860 --> 01:13:39.900]  вершины с каждым новым c будут добавляться и из каждой вершины и у нас будет ввести ребро в петлю.
[01:13:39.900 --> 01:13:52.460]  Вот как-то вот так это будет. Такое деревце какое-то. Ладно, оно конечно не абсолютно
[01:13:52.460 --> 01:13:59.320]  рандомное дерево, да. Мы конечно знаем, что это дерево будет спорним в 0. В нуле как-то вот так это
[01:13:59.320 --> 01:14:04.780]  будет может быть. Какие-то деревья могут быть. Что на этих деревьях может произойти?
[01:14:04.780 --> 01:14:15.100]  Вот. Ну теперь по большому счету. Ну вот, то есть по большому счету теперь что у нас? Когда у нас
[01:14:15.100 --> 01:14:21.780]  приходит новая вершина, новая вершина с номером модула s плюс 1, то что мы пытаемся сделать? Мы
[01:14:21.780 --> 01:14:28.380]  пытаемся взять вершину с номером модула s и прогуливаться по этому дереву до тех пор,
[01:14:28.380 --> 01:14:35.340]  пока справа от очередной позиции соответствующей вершине окажется новый символ c, правда? Понимаете,
[01:14:35.340 --> 01:14:44.380]  да? Но как мы уже поумним, да, у нас имеет место фактически функция go от вот этой вот позиции,
[01:14:44.380 --> 01:14:52.660]  ну там по смысле и она же это, то есть от и и вот этого символа c. У нас есть функция go, правда?
[01:14:52.660 --> 01:14:59.060]  Понимаете, автомат у нас, в общем-то автомат у нас за счет чего работал? Автомат у нас работал за
[01:14:59.060 --> 01:15:07.060]  счет того, что мы как бы для каждого и для каждого c заранее преднасчитывали, собственно, если мы
[01:15:07.060 --> 01:15:16.300]  будем из этой вершины пытаться искать проход по символу c, где мы его найдем, правда? Это работало по
[01:15:16.300 --> 01:15:24.140]  принципу, что, ну то есть работало, что отсюда следовало, что если автомат, если это у нас конечная,
[01:15:24.140 --> 01:15:28.500]  конечная штука, то в общем-то вот в терминах дерева можно сказать, что как бы докуда нам
[01:15:28.500 --> 01:15:34.900]  надо подняться, чтобы тут по символу c пройти было можно, правда? Понятно, что я говорю?
[01:15:34.900 --> 01:15:49.020]  Или уже мух настал? Ну это когда автомат, но просто фишка, просто ради чего мы вообще все это делаем?
[01:15:49.020 --> 01:15:54.180]  Ну, например, хотелось показать дерево, а вдруг теперь мне сказать такая идея, а как бы это делать,
[01:15:54.180 --> 01:16:02.580]  если размер алфавита не равен вот этой вот констанции? Ведь заметим, что префикс функции
[01:16:02.580 --> 01:16:07.940]  сам вообще работает, даже если вам там подсовывают абсолютно произвольные числа или, знаете,
[01:16:07.940 --> 01:16:14.220]  еще как бывает, произвольные камешки, которые между собой умеют, ну там, в худшем случае,
[01:16:14.220 --> 01:16:19.140]  если они умеют сравниваться только на равно и не равно, то я боюсь, конечно, вы без этого,
[01:16:19.140 --> 01:16:30.500]  если только на равно и не равно, то возможно мы тут ничего и не выбираем. Вот, ну либо там,
[01:16:30.500 --> 01:16:37.500]  ну вот. Но с другой стороны, значит, полный автомат, просто в чем проблема? Проблема в том,
[01:16:37.500 --> 01:16:42.780]  что полный автомат мы таким образом не построим, ну или построим, но за неудобоваримую для нас ассоциацию.
[01:16:42.780 --> 01:16:53.780]  Вот, но возникает такой действительно естественный вопрос. Вот, а можно было бы сделать действительно
[01:16:53.780 --> 01:17:02.580]  что-нибудь, можно ли бы сделать что-нибудь, чтобы находить действительно, где этот символ
[01:17:02.580 --> 01:17:08.740]  впервые встретится вот на вершине, за куть хотя бы удобоваримой симпульте. Правда, у меня есть
[01:17:08.740 --> 01:17:19.140]  такое неожиданное решение. Если мы верим в персистентный сет или персистентный мап,
[01:17:19.140 --> 01:17:30.180]  то смотрите какая идея. Вот, идея такая. Допустим, мы вот для этой вершины у нас есть, для вот этой
[01:17:30.180 --> 01:17:35.300]  вершины у нас есть мапчик, который для каждой чиселки скажет, где тут у нас ближайшая вершина,
[01:17:35.300 --> 01:17:42.340]  чтобы по этой вершине можно пройти. А теперь заметим, что вот для этой вершины мапчик должен
[01:17:42.340 --> 01:17:47.420]  отличаться только, ну по сути в то, что мы должны добавить, что переход по символу, который идет
[01:17:47.420 --> 01:17:52.420]  сразу после нее, он, собственно, другейший. Логично, да?
[01:18:06.420 --> 01:18:15.620]  Ну, смотрите, значит, мы хотим в каждой вершине хранить такой мап, где по каждой, вот допустим у нас
[01:18:15.620 --> 01:18:22.300]  эта вершина В, и хранить в мапчик, который по символу С сопоставляет, ну то, что мы называем
[01:18:22.300 --> 01:18:29.060]  Go от ВС. Правда? А теперь смотрим, вот рассмотрим вот эту вершину, у которой предиксун идёт сюда.
[01:18:29.060 --> 01:18:34.420]  Как устроен этот переход, да? То есть Go устроена так, что если конкретно из этой позиции можно по
[01:18:34.420 --> 01:18:42.540]  символу пройти, то мы прям в ней и проходим. А если нет, то мы тогда идем сюда, и по сути,
[01:18:42.540 --> 01:18:50.460]  вот в этом мапе уже ответы еще, правда? Получается, мап вот этой вершины отличается от мапы этой вершины,
[01:18:50.460 --> 01:18:57.940]  но там буквально в одной позиции. То есть надо посмотреть символ, который идет после этой вершины,
[01:18:57.940 --> 01:19:06.620]  и, собственно, его либо заменить, ну либо добавить, если его там в мапе не было, правда? Ну и все. Тогда
[01:19:06.620 --> 01:19:12.500]  получается идея, давайте хранить. Ну тогда... Может быть даже персистентный не мап, а персистентный массив.
[01:19:12.500 --> 01:19:23.700]  Ну, в смысле, просто одинаково... Не, ну как... Не, ну, поедете, массив, поедете, мап, потому что у нас,
[01:19:23.700 --> 01:19:27.940]  вот эти фиселки же произвольные, то есть если вы, конечно, заранее сожмете координаты, то, конечно,
[01:19:27.940 --> 01:19:34.780]  можно и персистентный массив, да. Но если не сожмете, то лучше уж там, лучше воображать себе нашу любимую
[01:19:34.780 --> 01:19:44.740]  персистентную авею. Ну, не дикотечку уже, да. Вот дикотечку мы не любим, она вероятностная, да. Ой, хотя, может быть,
[01:19:44.740 --> 01:19:48.860]  будто у нас вероятностная алгоритма, мы ее не полюбим. Но, в принципе, вот персистентный... Получается,
[01:19:48.860 --> 01:19:55.620]  что, по крайней мере, с помощью персистентного дерева, действительно, о от лог-рифма вполне
[01:19:55.620 --> 01:20:01.780]  можно. Правда, здесь есть маленькая оговорка, прежде чем опустить вас, скажу. То есть здесь мы в явном
[01:20:01.780 --> 01:20:07.060]  виде воспользовались тем, что символы можно не просто сравнивать на равно и неравно, а еще их
[01:20:07.060 --> 01:20:15.540]  можно сравнивать на то, кто меньше, кто больше. Ну, формально говоря, если вы умеете строить
[01:20:15.540 --> 01:20:23.500]  персистентную хэштаблицел, ну, там, с этими вашими руполок единицы, да, то, в принципе, в принципе...
[01:20:23.500 --> 01:20:29.220]  На другой деле, на практике нам же символы должны как-то, ну, как-то подавать на ввод, да, и они должны,
[01:20:29.220 --> 01:20:35.860]  ну, не знаю, иметь хоть что-то, номера или как-то... Ну да, по большому счету, да. Ну, тут вопрос как бы,
[01:20:35.860 --> 01:20:40.020]  да, в идеале, конечно, символы нам по-любому выдаются как последовательность битых, можно связывать
[01:20:40.020 --> 01:20:45.100]  хотя бы как последовательность битых. Другой вопрос, что, как бы, тогда придется сравнивать за о, от
[01:20:45.100 --> 01:20:51.620]  количества этих бит, а мало ли, как они вам поддаются. Хотя, с другой стороны, конечно, строка из алфавита,
[01:20:51.620 --> 01:20:56.700]  там, каждый символ, которого является каким-то вот этим вот экзотическим забубенным, этой шнуром...
[01:20:56.700 --> 01:21:04.700]  Ну, просто логарифм у нас и, ну, не знаю, делоплод увеличивается, ну, понятно, зависит от шнуров бит, так что можно себе позволить добавить.
[01:21:04.700 --> 01:21:11.940]  Ну, если, ну, наверное, ну, там, да, ну, да, получается, вот за логарифм можно, да, ну, я не знаю, вот интересно,
[01:21:11.940 --> 01:21:19.980]  можно ли обойтись без персистентных это, то есть как бы, то есть без персистентного чего-нибудь, но за логарифм,
[01:21:19.980 --> 01:21:24.580]  получается, можно где-то, а на той лекции прям так предлагалось пользоваться, это персистентный
[01:21:24.580 --> 01:21:32.580]  деструктур, или оно, или там всё-таки это умные, там, собственно, достаточно умные учёные умеют обходиться без этой чёрной модели.
[01:21:32.580 --> 01:21:40.380]  Ну, вот, то есть, не знаю, может, они там действительно пользуются тем, что есть
[01:21:40.380 --> 01:21:48.460]  арифметические прогрессии с ними, красиво можно работать. Ну, впрочем, ну, конечно.
[01:21:48.460 --> 01:21:56.620]  Ну, что ж, кажется, ну, да, пожалуй, пришло время сделать переговор.
