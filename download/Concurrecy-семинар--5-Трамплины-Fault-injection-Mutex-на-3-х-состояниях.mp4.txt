[00:00.000 --> 00:10.720]  Какой у нас план на сегодня? В прошлый раз я вам хотел рассказать про санитайзеры и
[00:10.720 --> 00:17.760]  про тестирование в нашем курсе. Рассказал только про санитайзеры, да? Было такое? Вот. А про
[00:17.760 --> 00:27.480]  fault injection я не рассказал вам ничего. Но я все еще хочу. А кроме этого я хочу еще,
[00:27.480 --> 00:35.800]  наверное, рассказать про то, как устроен хорошее решение Mutex, которое самостоятельно не придумать,
[00:35.800 --> 00:42.680]  а вот разобрать можно. И я хотел бы, наверное, это совсем бонусный уровень, я хотел бы рассказать
[00:42.680 --> 00:48.040]  про то, как устроен кондвар настоящий. Вот вы там написали какое-то поделие из четырех строчек,
[00:48.040 --> 00:53.840]  а настоящий кондвар выглядит очень сложно, он выглядит миллион раз сложнее, чем ваш. Вот. Ну и
[00:53.840 --> 00:58.840]  может быть и не место здесь, может быть в шале нужно рассказывать. Но если время останется,
[00:58.840 --> 01:04.720]  то я попробую. Но может быть у вас просто есть свои собственные вопросы и вам нет дела до Mutex
[01:04.720 --> 01:12.600]  и кондвара, а у вас какая-то более насущная потребность имеется прямо сейчас. Все понятно пока,
[01:12.600 --> 01:33.840]  да? Никаких вопросов нет. Да, конечно. Что такое трампин, спрашиваешь ты,
[01:33.840 --> 01:42.520]  так завалированно. Идея простая. Давай мы найдем репозиторий какой-нибудь, где трампин нужен,
[01:42.520 --> 02:02.760]  и посмотрим на него. Вообще мы же, наверное... Как переводится это слово?
[02:02.760 --> 02:21.560]  Это не трампин, это батут. Вот так вот. Но меня уже не изменить, поэтому я буду говорить
[02:21.560 --> 02:29.920]  трампин. Итак, в чем идея? У нас есть нечто под названием execution-context. Какая-то штуковина,
[02:29.920 --> 02:41.760]  которая помогает нам... Давайте мы обновим execution-context. Потому что кажется,
[02:41.760 --> 02:49.080]  он претерпел некоторые изменения. Вот так-то лучше. Нам видно или покрупнее сделать? И возможно,
[02:49.080 --> 03:04.440]  нужно сделать менее ярко и менее ярко. Нет, не работает. Станет лучше? Лучше? Лучше, да. А так уже уже?
[03:04.440 --> 03:20.280]  Или все еще лучше? Вот где-то здесь. И сделаем так, чтобы поменьше информации врезало на экран.
[03:20.280 --> 03:30.640]  Итак, я напомню, о чем был execution-context. Это контекст исполнения. То есть состояние
[03:30.640 --> 03:36.960]  исполнения. У исполнения есть некоторые структуры, необходимые ему. Есть call stack, есть таблица
[03:36.960 --> 03:44.440]  страницы процесса. А есть состояние, которое на процессоре, на ядре сейчас. Это stack pointer,
[03:44.440 --> 03:51.680]  это instruction pointer, это какие-то регистры, которые исполнение сейчас использует. И мы пишем какой-то
[03:51.680 --> 03:56.440]  код, который это исполнение переключает на другое исполнение. Мы сохраняем в смене
[03:57.040 --> 04:03.600]  текущий контекст. Вот текущее состояние на процессоре. Вот этот объект. И активируем контекст,
[04:03.600 --> 04:12.640]  ранее сохраненный или ранее сконструированный с помощью метода setup. И активируем контекст,
[04:12.640 --> 04:20.840]  который был ранее сохранен в свечту или сконструирован в методе setup. Это, собственно,
[04:20.840 --> 04:24.920]  механизм переключения контекста. Мы разбирали, какой он устроен. Потому что на stack сохраняются
[04:24.920 --> 04:31.680]  содержимые регистров. Потом при активации мы попаем со stack. Instruction pointer сохраняется с
[04:31.680 --> 04:37.240]  помощью инструкции call red и активируется с помощью red. Но это все, мы, надеюсь, в какой-то степени
[04:37.240 --> 04:45.600]  помним. А теперь ограниченный случай. Он начинается с того, что мы вообще должны сконструировать
[04:45.600 --> 04:49.600]  некоторый контекст, на который мы переключимся первый раз. Вот если мы смотрим на fiber,
[04:49.600 --> 04:54.400]  то как там устроено переключение контекста? Планировщик запускается. Давайте пойдем в пример.
[04:54.400 --> 05:03.040]  Планировщик запускается. Говорит run. В нем говорит run loop. В нем берет первый fiber,
[05:03.040 --> 05:10.040]  который мы вот здесь вот создали, и активирует его. Вот первое переключение в этом примере,
[05:10.040 --> 05:16.160]  вообще в любом примере с fiber, это переключение из контекста потока, в котором выполняется
[05:16.160 --> 05:25.280]  run loop планировщика, в контекст fiber. И вот этот контекст fiber он еще ни разу не был... Он активируется
[05:25.280 --> 05:33.200]  первый раз. Он никогда еще не был на процессоре, этот fiber. Так что чтобы этот fiber запустился,
[05:33.200 --> 05:40.800]  для него нужно контекст сконструировать вручную. Для этого мы вот где-то здесь говорим setup
[05:40.800 --> 05:48.640]  контекст. И о чем эта процедура? О том, что вот нужно инициализировать исполнение руками.
[05:48.640 --> 05:55.680]  Нужно что сделать? Подготовить stack для этого исполнения так, чтобы переключившись в него
[05:55.680 --> 06:23.120]  в методе свечту. Давайте мы посмотрим людьми картинку. Ну что ж, надеюсь. Нет, все, мы потеряли
[06:23.120 --> 06:37.000]  Silavin так бездарно. Во-первых, они ее продлили, во-вторых, причем здесь лицензия? Он просто тормозит.
[06:37.000 --> 06:45.840]  Вот, мы должны подготовить контекст fiber, который еще ни разу не исполнялся к такому,
[06:46.320 --> 06:55.400]  контекст вот этого вот fiber к такому виду, где лежит stack pointer, который указывает на верхушку stack
[06:55.400 --> 07:02.560]  fiber, на котором лежат регистры, лежит адрес возврата, вот вся эта история. Вот, и когда мы активируем
[07:02.560 --> 07:11.160]  этот контекст fiber, мы должны вот попнуть регистры со stack, сказать нет и оказаться где-то. Где мы
[07:11.160 --> 07:19.240]  хотим оказаться? У нас есть некоторый пользовательский код, который хочет fiber исполнять
[07:19.240 --> 07:27.880]  собственно его тело. Но мы не можем позволить себе начать исполнение fiber с исполнения сразу кода
[07:27.880 --> 07:36.000]  пользователя. Почему? Потому что этот код рано или поздно завершится, функция идет до конца. В конце
[07:36.000 --> 07:41.280]  этой функции конкаплятор расположит инструкцию red и процессор, увидев инструкцию red, должен
[07:41.280 --> 07:48.240]  опнуться stack, адрес возврата. Но никакого адреса возврата нет, потому что мы и так до дня stack
[07:48.240 --> 08:00.840]  находимся, мы с этого исполнения не начали. Вот, поэтому мы над function пользователя помещаем
[08:00.840 --> 08:11.520]  служебную процедуру. Давайте мы запустим пример с fiber и это вот этот пример. Здесь уже
[08:11.520 --> 08:15.320]  breakpoint стоит какой-нибудь и мы запустим и посмотрим.
[08:30.840 --> 08:51.280]  Вот, где-то внизу находится служебная процедура, которая называется run. На дне еще что-то есть в
[08:51.280 --> 08:58.280]  стеке. Некоторая магия, но вот она нас сейчас, наверное, не интересует. Главное, что код пользователя,
[08:58.280 --> 09:06.320]  завернутый вот в эту вот unique function, ну не важно, контейнер с type array же некоторый, для
[09:06.320 --> 09:16.200]  произвольных лямп, вот мы этот код вызываем из-за отдельного метода, который нужен для того,
[09:16.200 --> 09:23.160]  чтобы из него не возвращаться. Вот мы не можем не вернуться из метода пользователя, потому что не
[09:23.160 --> 09:30.440]  мы там код написали, но мы над этим вызовом разместили свой вызов, который вызовет код пользователя,
[09:30.440 --> 09:40.160]  а потом скажет, но он все еще говорит switch to, а мог бы сказать exit to, по нынешним временам требуется.
[09:40.160 --> 09:48.040]  Вот он зайдет сюда и никогда больше отсюда не вернется. Исполнение этой функции, оно до этой
[09:48.040 --> 09:56.560]  точки не дойдет, потому что здесь вообще написано board. Мы зайдем в этот вызов и выйдем из него один
[09:56.560 --> 10:01.440]  раз по планировщике, а вот из самого вызова terminate мы не вернемся уже никогда. Ну потому
[10:01.440 --> 10:04.920]  что мы не можем туда вернуться, потому что здесь будет написана инструкция редкая, которая пробьет
[10:04.920 --> 10:09.520]  одно стека. Мы не хотим, чтобы это произошло.
[10:09.520 --> 10:25.760]  Не пустой. Ну вот тут какие-то, не знаю, естественно, тут локальные перемены.
[10:25.760 --> 10:27.920]  Тут локальных переменных нет, по счастью, но могли бы быть.
[10:27.920 --> 10:32.080]  В чем проблема?
[10:32.080 --> 10:40.520]  Когда ты отдаешь память локатору, она тоже не пустая. Как может память быть пустой на бурбайт?
[10:40.520 --> 10:42.520]  У них есть какие-то значения?
[10:42.520 --> 10:48.320]  Так, а в чем вопрос?
[10:48.320 --> 10:52.760]  Что значит почистить стэк?
[10:52.760 --> 10:59.800]  Стэк это память. Что такое пустая память?
[10:59.800 --> 11:07.840]  Что такое память? Память это диапазон адресов, виртуальная память. Что такое пустая память и не пустая память?
[11:07.840 --> 11:11.480]  Что значит почистить память? Занурить ее?
[11:11.480 --> 11:18.000]  Так, и что?
[11:18.000 --> 11:28.440]  Когда ты говоришь дырит, когда у тебя строчка разрушается и в деструкторе память отдается
[11:28.480 --> 11:32.480]  что с ней делается?
[11:32.480 --> 11:34.480]  Она зануряется как-то?
[11:34.480 --> 11:38.480]  Да все равно локатор, что там в памяти находится.
[11:38.480 --> 11:42.480]  Я просто не понимаю, какую проблему мы решаем?
[11:42.480 --> 11:46.480]  Ты хочешь что-то сделать, но ты не можешь мне объяснить, зачем ты этого хочешь?
[11:46.480 --> 11:49.480]  С какой проблемой ты столкнулся? Какая у тебя потребность есть?
[11:49.480 --> 11:51.480]  Какую задачу ты решаешь?
[11:51.480 --> 11:53.480]  Не совсем понятно.
[11:53.520 --> 12:05.520]  Когда мы сдаем стэк в курантине, там в стэке хранится указатель на сам стэк и наконец его, да?
[12:05.520 --> 12:11.520]  Сейчас. Про какой код ты говоришь?
[12:11.520 --> 12:21.520]  Ну, когда что-то не пишется, нам нужно печатать на работе.
[12:21.560 --> 12:25.560]  Возможно, так.
[12:25.560 --> 12:31.560]  Вот карутина, вот ее реализация, которую нужно чем-то заполнить.
[12:31.560 --> 12:35.560]  Ну, ей нужен стэк, да.
[12:35.560 --> 12:41.560]  Это диапазон памяти, в которой карутина будет хранить код стэк свой.
[12:41.560 --> 12:45.560]  А вот в этой хранитель только два указательного начала и конец, да?
[12:45.560 --> 12:47.560]  Это просто диапазон памяти.
[12:47.600 --> 12:49.600]  А, то есть...
[12:49.600 --> 12:55.600]  А когда он работает на стэк, он умеет свои там указательные, что он куда-то написал?
[12:55.600 --> 12:58.600]  Я не очень понимаю. Вот это, мне кажется, путаешь.
[12:58.600 --> 13:01.600]  Мы на первом семинаре говорили, что такое callstack?
[13:01.600 --> 13:03.600]  Просто область памяти.
[13:03.600 --> 13:04.600]  Ну да.
[13:04.600 --> 13:08.600]  Вот она никакая не специальная, просто кусочек памяти.
[13:08.600 --> 13:15.600]  И процессор рассчитывает, что в этой памяти, в этом диапазоне лежат не какие-то произвольные данные,
[13:15.640 --> 13:19.640]  адреса возврата, аргументы, функции, там, локальные переменные,
[13:19.640 --> 13:23.640]  и процессор хранит stackpointer на вершины этого стэка.
[13:23.640 --> 13:27.640]  Но просто процессор так использует эту память.
[13:27.640 --> 13:30.640]  Ну вот, mutable memview — это описание диапазона памяти,
[13:30.640 --> 13:32.640]  которая будет использована для callstack.
[13:32.640 --> 13:36.640]  Instruction stackpointer, который будет сохраняться в контексте,
[13:36.640 --> 13:38.640]  но это вот stackpointer.
[13:38.640 --> 13:40.640]  Но это вот разные вещи.
[13:40.640 --> 13:43.640]  Но я все еще не понимаю...
[13:43.680 --> 13:47.680]  А как процессор понимает, где он сейчас stackpointer?
[13:47.680 --> 13:50.680]  Ну stackpointer у него есть.
[13:50.680 --> 13:53.680]  Мы же вот смотрим stackpointer.
[13:53.680 --> 13:55.680]  Ну да.
[13:55.680 --> 13:58.680]  Это первый семинар.
[13:58.680 --> 14:01.680]  Нужно посмотреть первый семинар.
[14:01.680 --> 14:03.680]  Разобраться, как устроен процессор.
[14:03.680 --> 14:05.680]  Или это...
[14:05.680 --> 14:08.680]  Я просто не понимаю, в чем вопрос, если честно.
[14:08.680 --> 14:11.680]  Как работает callstack в процессоре, это вот...
[14:11.680 --> 14:14.680]  Как работает callstack, мы вроде бы уже говорили.
[14:14.680 --> 14:16.680]  Повторять, наверное, уже поздно,
[14:16.680 --> 14:19.680]  потому что мы столько раз с этим пользовались.
[14:19.680 --> 14:21.680]  Или нет?
[14:21.680 --> 14:25.680]  Просто если не понятно, то, наверное, вообще ничего не понятно.
[14:25.680 --> 14:28.680]  Если не имеет смысла.
[14:28.680 --> 14:30.680]  Поговорите со мной.
[14:30.680 --> 14:32.680]  Ну я просто...
[14:32.680 --> 14:35.680]  Конкретная часть...
[14:35.680 --> 14:37.680]  Сначала казалось, что stackpointer,
[14:37.680 --> 14:40.680]  он указывает до начала stack.
[14:40.680 --> 14:42.680]  Это регистр процессора.
[14:42.680 --> 14:44.680]  РСП.
[14:44.680 --> 14:46.680]  Он указывает, понятно, куда.
[14:46.680 --> 14:49.680]  Он указывает на вершину stack.
[14:49.680 --> 14:51.680]  Ну и тут ничего не меняется.
[14:51.680 --> 14:53.680]  Тут вообще нет никакого РСП.
[14:53.680 --> 14:55.680]  РСП — это деталь реализации execution context.
[14:55.680 --> 14:57.680]  А это просто область памяти.
[14:57.680 --> 15:00.680]  За исполнение отвечает вот этот execution context.
[15:00.680 --> 15:02.680]  Этот тема.
[15:10.680 --> 15:12.680]  Где?
[15:12.680 --> 15:15.680]  За исполнение отвечает execution context.
[15:15.680 --> 15:18.680]  Но вот ему, чтобы сконструировать новое исполнение,
[15:18.680 --> 15:20.680]  нужно подготовить callstack
[15:20.680 --> 15:23.680]  и указать, с чего начнется исполнение.
[15:23.680 --> 15:27.680]  Мы говорим, что если мы вручную изготовили
[15:27.680 --> 15:29.680]  вот этот context,
[15:29.680 --> 15:31.680]  то при переключении на него
[15:31.680 --> 15:34.680]  начнется исполнение виртуального метода run
[15:34.680 --> 15:37.680]  у этого самого трамплина батута
[15:37.680 --> 15:39.680]  на вот этом стеке,
[15:39.680 --> 15:41.680]  который будет храниться здесь,
[15:41.680 --> 15:43.680]  в этой области памяти.
[15:45.680 --> 15:47.680]  Вот как именно реализована эта функция.
[15:47.680 --> 15:49.680]  Ну в какой-то степени можно не думать.
[15:51.680 --> 15:53.680]  В какой-то степени можно не думать.
[15:54.680 --> 15:56.680]  Впрочем, можно и посмотреть.
[15:56.680 --> 15:58.680]  Я, кажется, немного переписал ее
[15:58.680 --> 16:00.680]  и стало понятнее,
[16:00.680 --> 16:02.680]  потому что она стала на ассемблере
[16:02.680 --> 16:04.680]  и код стал гораздо короче.
[16:06.680 --> 16:08.680]  Есть переключение стеков,
[16:08.680 --> 16:10.680]  а есть подготовка стеков.
[16:12.680 --> 16:14.680]  Мы выравниваем стек по 16 байт
[16:14.680 --> 16:16.680]  от некоторых требований процессора.
[16:16.680 --> 16:18.680]  Потом мы кладем аргумент
[16:18.680 --> 16:20.680]  по интерно-трамплин,
[16:20.680 --> 16:22.680]  потом мы говорим, что
[16:22.680 --> 16:24.680]  адрес возврата будет
[16:24.680 --> 16:26.680]  адрес специальной
[16:26.680 --> 16:28.680]  функции,
[16:28.680 --> 16:30.680]  вот такой вот.
[16:30.680 --> 16:32.680]  А она уже
[16:32.680 --> 16:34.680]  через седьмой аргумент,
[16:34.680 --> 16:36.680]  просто поколен convention со стека,
[16:36.680 --> 16:38.680]  возьмет pointer на трамплин
[16:38.680 --> 16:40.680]  и запустит метод run.
[16:40.680 --> 16:42.680]  И вот ровно эту функцию
[16:42.680 --> 16:44.680]  мы на дне кулстека здесь и видим.
[16:44.680 --> 16:46.680]  Вот с нее все начинается.
[16:46.680 --> 16:48.680]  Она вызывает...
[16:48.680 --> 16:50.680]  Тут некоторое проксирование есть,
[16:50.680 --> 16:52.680]  в конце концов вызывает трамплин run
[16:52.680 --> 16:54.680]  и получается fiber run, который
[16:54.680 --> 16:56.680]  реализует этот интерфейс.
[16:58.680 --> 17:00.680]  То есть это точка входа некоторая,
[17:00.680 --> 17:02.680]  универсальная, и этот run
[17:02.680 --> 17:04.680]  должен еще обеспечивать...
[17:06.680 --> 17:08.680]  Гарантирует то, что этот run
[17:08.680 --> 17:10.680]  не завершится как функция,
[17:10.680 --> 17:12.680]  то есть мы из этого вызова run
[17:12.680 --> 17:14.680]  никогда не вернемся. Если мы вернемся,
[17:14.680 --> 17:16.680]  то будет беда.
[17:22.680 --> 17:24.680]  Вот.
[17:24.680 --> 17:26.680]  Ну а РСП,
[17:26.680 --> 17:28.680]  как устроено исполнение на процессоре,
[17:28.680 --> 17:30.680]  это первый семинар. Вот там мы говорили,
[17:30.680 --> 17:32.680]  что нужно процессор, он двигается там
[17:32.680 --> 17:34.680]  по вызовам функций, он использует кулстек.
[17:34.680 --> 17:36.680]  Вот. Но
[17:36.680 --> 17:38.680]  здесь,
[17:38.680 --> 17:40.680]  вот в этом коде,
[17:42.680 --> 17:44.680]  это не то чтобы прям вот...
[17:44.680 --> 17:46.680]  Это не кулстек, это просто память,
[17:46.680 --> 17:48.680]  это ресурс, которым используется
[17:48.680 --> 17:50.680]  картина с программой.
[17:50.680 --> 17:52.680]  Вот про ресурсы речь.
[17:52.680 --> 17:54.680]  Вот это про ресурсы,
[17:54.680 --> 17:56.680]  а вот execution-контекст,
[17:56.680 --> 17:58.680]  которого здесь нет, который есть здесь,
[17:58.680 --> 18:00.680]  это про исполнение.
[18:00.680 --> 18:02.680]  Ну вот так вот обязанности поделены, довольно
[18:02.680 --> 18:04.680]  логично. Есть ресурсы, есть
[18:04.680 --> 18:06.680]  исполнение, это разные классы,
[18:06.680 --> 18:08.680]  разные...
[18:08.680 --> 18:10.680]  разные сущности в коде.
[18:10.680 --> 18:12.680]  Трамплин.
[18:12.680 --> 18:14.680]  Трамплин — это интерфейс,
[18:14.680 --> 18:16.680]  через который
[18:16.680 --> 18:18.680]  ты...
[18:18.680 --> 18:20.680]  Трамплин
[18:20.680 --> 18:22.680]  он объявлен для
[18:22.680 --> 18:24.680]  всяких контекстов, потому что он про контекст
[18:24.680 --> 18:26.680]  исполнения. Вот трамплин — это код,
[18:26.680 --> 18:28.680]  с которого начинается исполнение
[18:28.680 --> 18:30.680]  инициализированное вручную на
[18:30.680 --> 18:32.680]  каком-то отдельном кулстеке.
[18:34.680 --> 18:36.680]  Вот.
[18:36.680 --> 18:38.680]  Вот.
[18:38.680 --> 18:40.680]  Вот это интерфейс.
[18:40.680 --> 18:42.680]  Кто-то, кто хочет
[18:42.680 --> 18:44.680]  реализовать какую-то исполняемую сущность,
[18:44.680 --> 18:46.680]  наследуется от этого
[18:46.680 --> 18:48.680]  интерфейса, реализует метод run
[18:48.680 --> 18:50.680]  и должен в конце позвать
[18:50.680 --> 18:52.680]  exit2, чтобы выйти навсегда
[18:52.680 --> 18:54.680]  из этого исполнения
[18:54.680 --> 18:56.680]  и не разрушить стэк.
[19:00.680 --> 19:02.680]  Вот. Тут из изменений есть
[19:02.680 --> 19:04.680]  одно неприятное, потому что тут
[19:04.680 --> 19:06.680]  некоторые нарушилось
[19:06.680 --> 19:08.680]  и
[19:08.680 --> 19:10.680]  появился еще один граничный случай.
[19:10.680 --> 19:12.680]  Он появился, потому что санитайзеры
[19:12.680 --> 19:14.680]  требуют специальных аннотаций при
[19:14.680 --> 19:16.680]  приключении контекста. Ну, короче, чтобы код
[19:16.680 --> 19:18.680]  работал с санитайзерами еще,
[19:18.680 --> 19:20.680]  нужно отдельно-частно
[19:20.680 --> 19:22.680]  случивать, к сожалению.
[19:24.680 --> 19:26.680]  То есть он никакой
[19:26.680 --> 19:28.680]  нового смысл для нас
[19:28.680 --> 19:30.680]  не несет. Это просто
[19:30.680 --> 19:32.680]  последнее переключение контекста, выделенное
[19:32.680 --> 19:34.680]  в отдельный метод.
[19:34.680 --> 19:36.680]  Это очень частая ситуация, когда
[19:36.680 --> 19:38.680]  логически вам не нужно его
[19:38.680 --> 19:40.680]  выделять, а
[19:40.680 --> 19:42.680]  инженерная реальность устроена так, что иногда
[19:42.680 --> 19:44.680]  нужно.
[19:48.680 --> 19:50.680]  Что-нибудь еще?
[20:00.680 --> 20:02.680]  Смотри.
[20:02.680 --> 20:04.680]  Вот не надо так рассуждать.
[20:04.680 --> 20:06.680]  Вот зачем я что-то делаю,
[20:06.680 --> 20:08.680]  спрашиваешь ты.
[20:08.680 --> 20:10.680]  Если тебе не зачем
[20:10.680 --> 20:12.680]  делать, не делай.
[20:12.680 --> 20:14.680]  Это вот кажется...
[20:14.680 --> 20:16.680]  Вот ты смотришь на код, да?
[20:16.680 --> 20:18.680]  В чем начинается хорошем коду от плохого? В хорошем коде делать только
[20:18.680 --> 20:20.680]  то, что нужно.
[20:20.680 --> 20:22.680]  Вот если тебе не нужно, не делай.
[20:22.680 --> 20:24.680]  Давай так договоримся.
[20:24.680 --> 20:26.680]  Это же задел в задачи
[20:26.680 --> 20:28.680]  просто на светлое будущее. Вот кто-то может быть
[20:28.680 --> 20:30.680]  где-то, когда-нибудь из вас
[20:30.680 --> 20:32.680]  думает, как сделать хорошо и сделает.
[20:32.680 --> 20:34.680]  И в задаче есть заготовка для того,
[20:34.680 --> 20:36.680]  чтобы весь остальной код
[20:36.680 --> 20:38.680]  переписывать не пришлось бы.
[20:38.680 --> 20:40.680]  То есть ты переписал бы threadpool по-новому,
[20:40.680 --> 20:42.680]  а весь остальный код продолжил бы работать
[20:42.680 --> 20:44.680]  без изменений практически.
[20:44.680 --> 20:46.680]  И там и тесты не разломались бы.
[20:46.680 --> 20:48.680]  Но если тебе это сейчас не нужно,
[20:48.680 --> 20:50.680]  ты не понимаешь как, это сложная задача
[20:50.680 --> 20:52.680]  вообще-то, то
[20:52.680 --> 20:54.680]  можно об этом не беспокоиться.
[20:54.680 --> 20:56.680]  То есть ты не должен в принципе в курсе делать чего-то, что ты не понимаешь
[20:56.680 --> 20:58.680]  зачем ты делаешь.
[20:58.680 --> 21:00.680]  Если тебя что-то требует,
[21:00.680 --> 21:02.680]  то, в смысле
[21:02.680 --> 21:04.680]  требует непонятного, то спроси.
[21:04.680 --> 21:06.680]  А если тебе не отвечу, зачем?
[21:06.680 --> 21:08.680]  Потому что в условии задачи написано немного.
[21:08.680 --> 21:10.680]  И если понятно, то понятно.
[21:10.680 --> 21:12.680]  Если не понятно, то однажды я объясню.
[21:12.680 --> 21:14.680]  Когда потребуется.
[21:14.680 --> 21:16.680]  Когда в этом необходимость
[21:16.680 --> 21:18.680]  появится.
[21:18.680 --> 21:20.680]  Пока не требуется.
[21:20.680 --> 21:22.680]  Так что ты можешь об этом думать
[21:22.680 --> 21:24.680]  в фоне, но
[21:24.680 --> 21:26.680]  делать эту задачу совершенно необязательно.
[21:26.680 --> 21:28.680]  Потому, что
[21:28.680 --> 21:30.680]  если уж делать,
[21:30.680 --> 21:32.680]  делать очень хорошо нужно.
[21:32.680 --> 21:34.680]  Иначе код испортится.
[21:34.680 --> 21:36.680]  Нужно так, чтобы он и лучше стал,
[21:36.680 --> 21:38.680]  и такой же симпатичный.
[21:38.680 --> 21:40.680]  Задача кажется написана,
[21:40.680 --> 21:42.680]  чтобы аллокации не было в коде.
[21:42.680 --> 21:44.680]  Если Fiber позовет
[21:44.680 --> 21:46.680]  100-500 раз yield
[21:46.680 --> 21:48.680]  в хорошей реализации,
[21:48.680 --> 21:50.680]  то в хорошей реализации будет ноль аллокаций
[21:50.680 --> 21:52.680]  дополнительных.
[21:52.680 --> 21:54.680]  Ноль упрощений к аллокатору.
[21:54.680 --> 21:56.680]  Это очень тонкие штуки.
[21:56.680 --> 21:58.680]  Конституирование STD-фанкшн это аллокация.
[21:58.680 --> 22:00.680]  Вы же писали STD-фанкшн,
[22:00.680 --> 22:02.680]  я, кажется, вас спрашивал.
[22:02.680 --> 22:04.680]  Не все.
[22:06.680 --> 22:08.680]  Значит, не у всех будет
[22:08.680 --> 22:10.680]  аллокация, видимо.
[22:10.680 --> 22:12.680]  Это объяснить очень легко.
[22:14.680 --> 22:16.680]  Мне кажется, я говорил в прошлый раз,
[22:16.680 --> 22:18.680]  вы же не можете вектор лямбды положить разный?
[22:18.680 --> 22:20.680]  Потому, что это разные анонимные классы,
[22:20.680 --> 22:22.680]  разные типы просто.
[22:22.680 --> 22:24.680]  Это называется type array.
[22:24.680 --> 22:26.680]  Тип стирается.
[22:26.680 --> 22:28.680]  У вас было много анонимных, неизвестных типов,
[22:28.680 --> 22:30.680]  а стало много STD-фанкшн одинаковых.
[22:30.680 --> 22:32.680]  Так что, когда вы заворачиваете
[22:32.680 --> 22:34.680]  лямбду в фанкшн,
[22:34.680 --> 22:36.680]  то вы делаете потенциальную аллокацию.
[22:36.680 --> 22:38.680]  Когда вы кладете что-то в вектор,
[22:38.680 --> 22:40.680]  вы делаете потенциальную аллокацию.
[22:44.680 --> 22:46.680]  У вас StartPool делает и то, и другое сейчас.
[22:48.680 --> 22:50.680]  Кладет STD-фанкшн в контейнер.
[22:50.680 --> 22:52.680]  И вот он уже сделал две аллокации.
[22:54.680 --> 22:56.680]  Можно сделать ноль аллокаций.
[22:58.680 --> 23:00.680]  Это требует некоторого размышления,
[23:00.680 --> 23:02.680]  как устроен STD-фанкшн,
[23:02.680 --> 23:04.680]  как вообще type array устроено.
[23:04.680 --> 23:06.680]  Короче, это требует некоторого инженерного опыта,
[23:06.680 --> 23:08.680]  которого у нас, возможно, нет,
[23:08.680 --> 23:10.680]  поэтому мы сейчас об этом не очень сильно
[23:10.680 --> 23:12.680]  обеспокоимся.
[23:12.680 --> 23:14.680]  Задачи это не требуется.
[23:14.680 --> 23:16.680]  Гораздо полезнее, мне кажется,
[23:16.680 --> 23:18.680]  задача из чего-то лишнего
[23:18.680 --> 23:20.680]  сделать вот этот самый процессор,
[23:20.680 --> 23:22.680]  который генератор.
[23:22.680 --> 23:24.680]  В этом гораздо больше пользы,
[23:24.680 --> 23:26.680]  потому что это можно сделать сейчас
[23:26.680 --> 23:28.680]  на нашем текущем уровне,
[23:28.680 --> 23:30.680]  и кажется, что довольно полезный навык
[23:30.680 --> 23:32.680]  понимать, как из корутина делать
[23:32.680 --> 23:34.680]  генераторы, итераторы,
[23:34.680 --> 23:36.680]  все вот это.
[23:36.680 --> 23:38.680]  Я бы посвятил время, в первую очередь,
[23:38.680 --> 23:40.680]  вот этой штуке.
[23:40.680 --> 23:42.680]  Что?
[23:42.680 --> 23:44.680]  Зачем я писать без корутина,
[23:44.680 --> 23:46.680]  когда задачи корутина просят написать
[23:46.680 --> 23:48.680]  с помощью корутина процессор
[23:48.680 --> 23:50.680]  и налег?
[23:50.680 --> 23:52.680]  Нет, это...
[23:52.680 --> 23:54.680]  Ну и более того,
[23:54.680 --> 23:56.680]  он находится в директоре...
[23:56.680 --> 23:58.680]  Короче, тут много указаний,
[23:58.680 --> 24:00.680]  прямых вообще,
[24:00.680 --> 24:02.680]  что корутина нужна, конечно.
[24:02.680 --> 24:04.680]  Да, действительно.
[24:04.680 --> 24:06.680]  Что еще? В чатике я не отвечаю
[24:06.680 --> 24:08.680]  человеку, а давно хочу.
[24:08.680 --> 24:10.680]  Он написал, что он взял
[24:10.680 --> 24:12.680]  свой минуток секунд вар,
[24:12.680 --> 24:14.680]  положил их в threadpool,
[24:14.680 --> 24:16.680]  и threadpool прошел.
[24:16.680 --> 24:18.680]  В смысле, он работает.
[24:18.680 --> 24:20.680]  Это довольно приятно.
[24:20.680 --> 24:22.680]  Так вот, я предлагаю...
[24:22.680 --> 24:24.680]  Я не знаю, чем это кончится,
[24:24.680 --> 24:26.680]  может быть, это плохая идея,
[24:26.680 --> 24:28.680]  потому что не испробована еще.
[24:28.680 --> 24:30.680]  Ну вот, если вам
[24:30.680 --> 24:32.680]  прям нечем заняться,
[24:32.680 --> 24:34.680]  то вы можете в файберах
[24:34.680 --> 24:36.680]  завести директорию...
[24:36.680 --> 24:38.680]  Вы не видите ее, да, наверное?
[24:38.680 --> 24:40.680]  Да, и сложить туда
[24:40.680 --> 24:42.680]  ваш минуток секунд вар,
[24:42.680 --> 24:44.680]  и дальше
[24:44.680 --> 24:46.680]  с ним жить.
[24:48.680 --> 24:50.680]  Что?
[24:54.680 --> 24:56.680]  Ну то есть, вот ты пишешь код...
[25:02.680 --> 25:04.680]  Ну, сейчас.
[25:04.680 --> 25:06.680]  Речь про то, что ты можешь
[25:06.680 --> 25:08.680]  накапливать решения в задачах
[25:08.680 --> 25:10.680]  таким образом.
[25:10.680 --> 25:12.680]  Это, с одной стороны, забавно,
[25:12.680 --> 25:14.680]  поэтому я предлагаю кому-нибудь это попробовать,
[25:14.680 --> 25:16.680]  но, наверное, не всем.
[25:16.680 --> 25:18.680]  А с другой стороны, это немного опасно,
[25:18.680 --> 25:20.680]  потому что раньше у вас был
[25:20.680 --> 25:22.680]  Mutex, аннотированный для fault injection,
[25:22.680 --> 25:24.680]  чтобы
[25:24.680 --> 25:26.680]  ломаться в тестах,
[25:26.680 --> 25:28.680]  а теперь у вас Mutex из Futex,
[25:28.680 --> 25:30.680]  который аннотирован для fault injection.
[25:30.680 --> 25:32.680]  И в итоге fault injection работает чуть хуже,
[25:32.680 --> 25:34.680]  потому что вокруг него больше работы
[25:34.680 --> 25:36.680]  лишней происходит.
[25:36.680 --> 25:38.680]  Так что
[25:38.680 --> 25:40.680]  может быть это повлияет на тесты,
[25:40.680 --> 25:42.680]  а может быть fault injection настолько хорош,
[25:42.680 --> 25:44.680]  что в тестах по-прежнему будут все хорошо работать.
[25:44.680 --> 25:46.680]  Я вот скорее во второе верю.
[25:46.680 --> 25:48.680]  Но кто-то может попробовать, и в любом случае
[25:48.680 --> 25:50.680]  это будет забавно, когда
[25:50.680 --> 25:52.680]  файберы будут накапливаться, расти,
[25:52.680 --> 25:54.680]  и все это будет из одного атомика
[25:54.680 --> 25:56.680]  по-прежнему.
[25:56.680 --> 25:58.680]  Кажется, что это наша цель, которую я...
[25:58.680 --> 26:00.680]  Одна из наших целей, которую я озвучивал
[26:00.680 --> 26:02.680]  на первом занятии.
[26:06.680 --> 26:08.680]  Вероятно, завтра у нас появятся две большие задачи.
[26:08.680 --> 26:10.680]  Нет, одна большая задача.
[26:10.680 --> 26:12.680]  Про
[26:12.680 --> 26:14.680]  эхо.
[26:14.680 --> 26:16.680]  Про то, чтобы написать эхосервер
[26:16.680 --> 26:18.680]  с помощью файберов, которые реализованы
[26:18.680 --> 26:20.680]  с помощью ASIO.
[26:20.680 --> 26:22.680]  Ну, это вторая половина пред
[26:22.680 --> 26:24.680]  последней лекции.
[26:24.680 --> 26:26.680]  А в...
[26:26.680 --> 26:28.680]  А через две недели у нас...
[26:28.680 --> 26:30.680]  Короче, ладно, не буду показывать.
[26:30.680 --> 26:32.680]  Так что, пожалуйста, файберы не откладывайте.
[26:32.680 --> 26:34.680]  Вот уже неделя прошла,
[26:34.680 --> 26:36.680]  полторы недели уже прошли.
[26:36.680 --> 26:38.680]  Осталось немного времени.
[26:40.680 --> 26:42.680]  Хоть кода там и немного, но подумать нужно
[26:42.680 --> 26:44.680]  основательно, чтобы была польза.
[26:46.680 --> 26:48.680]  Ладно, что-нибудь еще?
[26:48.680 --> 26:50.680]  Попросы какие-нибудь?
[26:50.680 --> 26:52.680]  По поводу Q,
[26:52.680 --> 26:54.680]  короче,
[26:54.680 --> 26:56.680]  не надо было
[26:56.680 --> 26:58.680]  в общем,
[26:58.680 --> 27:00.680]  в спинлоговом месте,
[27:00.680 --> 27:02.680]  чтобы ждать, чтобы там указать
[27:02.680 --> 27:04.680]  появился хороший.
[27:04.680 --> 27:06.680]  Ты про спинлог, который
[27:06.680 --> 27:08.680]  с протоколом куберетности кашей?
[27:08.680 --> 27:10.680]  Да.
[27:10.680 --> 27:12.680]  Там, короче,
[27:12.680 --> 27:14.680]  я проверил,
[27:14.680 --> 27:16.680]  если вот этот вот спинлог, который
[27:16.680 --> 27:18.680]  ну, там надо будет ждать,
[27:18.680 --> 27:20.680]  чтобы указатель поставился.
[27:20.680 --> 27:22.680]  Да.
[27:22.680 --> 27:24.680]  Или просто крутиться
[27:24.680 --> 27:26.680]  на процессоре,
[27:26.680 --> 27:28.680]  или ставить какую-то штуку,
[27:28.680 --> 27:30.680]  наверное, одинаково на этой,
[27:30.680 --> 27:32.680]  ну, на системе
[27:32.680 --> 27:34.680]  тестирующей.
[27:34.680 --> 27:36.680]  А она у меня на компьютере получается быстрее,
[27:36.680 --> 27:38.680]  если он просто будет крутиться на процессоре.
[27:38.680 --> 27:40.680]  Наверное, связано именно с реализацией
[27:40.680 --> 27:42.680]  спинлога, который...
[27:42.680 --> 27:44.680]  Смотри,
[27:46.680 --> 27:48.680]  анализ производительности
[27:48.680 --> 27:50.680]  это очень-очень-очень сложно.
[27:50.680 --> 27:52.680]  У меня есть какой-то тест, и на нем как-то работает.
[27:52.680 --> 27:54.680]  И я делаю из этого какие-то
[27:54.680 --> 27:56.680]  далеко идущие выводы. Нет.
[27:56.680 --> 27:58.680]  Так делать не нужно.
[27:58.680 --> 28:00.680]  У тебя есть... Во-первых, ты вообще
[28:00.680 --> 28:02.680]  не бенчмаркаешь, ты запускаешь стресс-тест.
[28:02.680 --> 28:04.680]  Стресс-тест... Ну, я в чате кому-то отвечал,
[28:04.680 --> 28:06.680]  пожалуйста, вот запомните это.
[28:06.680 --> 28:08.680]  Бенчмарки — это отдельная история.
[28:08.680 --> 28:10.680]  Это только ревизная сборка, разумеется.
[28:10.680 --> 28:12.680]  Это минимальный оверхед.
[28:12.680 --> 28:14.680]  Это очень разумный сценарий,
[28:14.680 --> 28:16.680]  который тестируется. Ты можешь построить
[28:16.680 --> 28:18.680]  бенчмарк, который тестирует
[28:18.680 --> 28:20.680]  какой-то абсолютно синтетический сценарий, который
[28:20.680 --> 28:22.680]  у тебя в коде не возникает.
[28:22.680 --> 28:24.680]  Тут очень сильно зависит от того,
[28:24.680 --> 28:26.680]  сколько в критической секции обращений к памяти,
[28:26.680 --> 28:28.680]  насколько она большая, что делают потоки
[28:28.680 --> 28:30.680]  между секциями, насколько там большой зазор.
[28:30.680 --> 28:32.680]  Вот, бенчмаркать
[28:32.680 --> 28:34.680]  такие отдельные синтетические кусочки
[28:34.680 --> 28:36.680]  кода — это
[28:36.680 --> 28:38.680]  в целом не очень полезно, это опасно,
[28:38.680 --> 28:40.680]  потому что ты можешь оптимизировать их
[28:40.680 --> 28:42.680]  вместо того, чтобы оптимизировать
[28:42.680 --> 28:44.680]  свое реальное приложение.
[28:44.680 --> 28:46.680]  Поэтому вот
[28:46.680 --> 28:48.680]  смотреть на стресс-тесты на время точно
[28:48.680 --> 28:50.680]  не нужно, они вообще не об этом, они не подходят.
[28:50.680 --> 28:52.680]  И нужно смотреть,
[28:52.680 --> 28:54.680]  если ты хочешь действительно сравнить
[28:54.680 --> 28:56.680]  что-то, нужно сравнить на какое-то
[28:56.680 --> 28:58.680]  смотреть на какую-то разумность
[28:58.680 --> 29:00.680]  сценарий их использования. Кроме того,
[29:00.680 --> 29:02.680]  код, который
[29:02.680 --> 29:04.680]  спинлок, который в задаче,
[29:04.680 --> 29:06.680]  в этой маленькой, будет
[29:06.680 --> 29:08.680]  работать лучше,
[29:08.680 --> 29:10.680]  он не про то, чтобы он работал быстрее
[29:10.680 --> 29:12.680]  всегда, он про то, чтобы он лучше
[29:12.680 --> 29:14.680]  масштабировался. То есть у нас лекция была про то,
[29:14.680 --> 29:16.680]  что у нас число ядер растет
[29:16.680 --> 29:18.680]  и между ними больше коммуникации
[29:18.680 --> 29:20.680]  появляется.
[29:20.680 --> 29:22.680]  И этот спинлок
[29:22.680 --> 29:24.680]  он про то, что с ростом
[29:24.680 --> 29:26.680]  числа ядер
[29:26.680 --> 29:28.680]  у тебя замедление от этой
[29:28.680 --> 29:30.680]  синхронизации внутри спинлока будет ниже
[29:30.680 --> 29:32.680]  и замедляться
[29:32.680 --> 29:34.680]  будет медленнее. Будет, конечно, замедляться,
[29:34.680 --> 29:36.680]  потому что есть верховетная синхронизация,
[29:36.680 --> 29:38.680]  ты за это плачешь неизбежно,
[29:38.680 --> 29:40.680]  но замедление будет меньше.
[29:40.680 --> 29:42.680]  И для того, чтобы увидеть,
[29:42.680 --> 29:44.680]  что работает действительно хорошо,
[29:44.680 --> 29:46.680]  нужно зайти на какой-нибудь рабочий сервер,
[29:46.680 --> 29:48.680]  где 16 или 32 или 64 ядра
[29:48.680 --> 29:50.680]  и там уже сравнивать.
[29:50.680 --> 29:52.680]  На четырех ядрах ты там ничего
[29:52.680 --> 29:54.680]  не увидишь. Там просто оверхед от сложности
[29:54.680 --> 29:56.680]  спинлока будет пожирать весь выигрыш
[29:56.680 --> 29:58.680]  от конкретности кэшей.
[29:58.680 --> 30:00.680]  Так что на четырех ядрах
[30:00.680 --> 30:02.680]  я не думаю, что можно что-то...
[30:02.680 --> 30:04.680]  В общем,
[30:04.680 --> 30:06.680]  нужна большая машина и нужен специальный
[30:06.680 --> 30:08.680]  бенчмарк, нужна релизная сборка, и вот тогда
[30:08.680 --> 30:10.680]  можно будет сравнить.
[30:10.680 --> 30:12.680]  Вот я предлагал кому-нибудь
[30:12.680 --> 30:14.680]  из семинаристов
[30:14.680 --> 30:16.680]  на Демидрису я предлагал пойти на большую машинку
[30:16.680 --> 30:18.680]  тестировать, может быть.
[30:18.680 --> 30:20.680]  Если его упросить, он это сделает.
[30:20.680 --> 30:22.680]  И что-нибудь нам нарисует,
[30:22.680 --> 30:24.680]  какие цифры. Давайте его попросим.
[30:24.680 --> 30:26.680]  Да, я спешу и...
[30:30.680 --> 30:32.680]  Он нам это сделает.
[30:36.680 --> 30:38.680]  Ещё вопрос.
[30:38.680 --> 30:40.680]  Просто задают вопросы два человека, остальные.
[30:40.680 --> 30:42.680]  Всё понимают?
[30:42.680 --> 30:44.680]  Ничего не понимают. Как мне им помочь?
[30:44.680 --> 30:46.680]  Что они здесь делают?
[30:46.680 --> 30:48.680]  Скорее мотивация такая, что
[30:48.680 --> 30:50.680]  семинары, которые, ну вот, например,
[30:50.680 --> 30:52.680]  можно задавать вопросы по старому материалу,
[30:52.680 --> 30:54.680]  их можно пересмотреть, а если задавать вопрос,
[30:54.680 --> 30:56.680]  в моём семинаре как бы немножечко не случится.
[30:56.680 --> 30:58.680]  В плане, вы не расскажете больше,
[30:58.680 --> 31:00.680]  чем могли бы. Ну я вот сейчас что-то рассказываю
[31:00.680 --> 31:02.680]  или я ничего нового не рассказываю, да?
[31:02.680 --> 31:04.680]  Ну хорошо, хватит от
[31:04.680 --> 31:06.680]  отвечать на вопросы, ни к чему.
[31:06.680 --> 31:08.680]  Покончим с этой ерундой?
[31:08.680 --> 31:10.680]  Ну всё, я тебя услышал.
[31:12.680 --> 31:14.680]  Тогда поговорим про fault injection.
[31:16.680 --> 31:18.680]  Как работают тесты
[31:18.680 --> 31:20.680]  в нашем коде?
[31:20.680 --> 31:22.680]  Ну я уже говорил, что мы запускаем
[31:22.680 --> 31:24.680]  тесты с санитайзерами для того,
[31:24.680 --> 31:26.680]  чтобы через обращение
[31:26.680 --> 31:28.680]  к памяти разломанной находить
[31:28.680 --> 31:30.680]  косты нашей синхронизации.
[31:30.680 --> 31:32.680]  Мы запускаем стресс санитайзером
[31:32.680 --> 31:34.680]  решения, собираем и запускаем,
[31:34.680 --> 31:36.680]  чтобы находить
[31:36.680 --> 31:38.680]  датарейсы,
[31:38.680 --> 31:40.680]  определения которых мы даже не понимаем
[31:40.680 --> 31:42.680]  до сих пор, что печально.
[31:42.680 --> 31:44.680]  И это мы починим в ближайшие выходные.
[31:46.680 --> 31:48.680]  Но вот и thread санитайзер,
[31:48.680 --> 31:50.680]  и address санитайзер, и вообще
[31:50.680 --> 31:52.680]  любой санитайзер отличает то,
[31:52.680 --> 31:54.680]  что они проверяют не программу,
[31:54.680 --> 31:56.680]  они проверяют конкретное
[31:56.680 --> 31:58.680]  исполнение.
[31:58.680 --> 32:00.680]  Ну это такой оракул, которому мы даем исполнение,
[32:00.680 --> 32:02.680]  которое вот на процессоре реализуется.
[32:02.680 --> 32:04.680]  А этот оракул, вот там, не знаю, моделирует
[32:04.680 --> 32:06.680]  happens before, мы этого не знаем вообще,
[32:06.680 --> 32:08.680]  моделирует там
[32:08.680 --> 32:10.680]  локатор, запоминает, что алоцировано,
[32:10.680 --> 32:12.680]  что нет, там ловит ошибки обращения
[32:12.680 --> 32:14.680]  к памяти, смотрит на конкретное
[32:14.680 --> 32:16.680]  исполнение. И у
[32:16.680 --> 32:18.680]  этого подхода есть, разумеется, есть
[32:18.680 --> 32:20.680]  такое очевидное ограничение, что если в
[32:20.680 --> 32:22.680]  исполнении в конкретном ошибке не проявилось,
[32:22.680 --> 32:24.680]  то санитайзер вам ничего не скажет.
[32:24.680 --> 32:26.680]  Если он говорит, что ошибка нашлась,
[32:26.680 --> 32:28.680]  то он ее нашел, он ее предъявляет, пишет
[32:28.680 --> 32:30.680]  отчет, и вы знаете, что у вас проблемы.
[32:30.680 --> 32:32.680]  Если санитайзер вам ничего не говорит,
[32:32.680 --> 32:34.680]  программа успешно завершается, успешно
[32:34.680 --> 32:36.680]  работает, то, видимо,
[32:36.680 --> 32:38.680]  ну как вы это делаете, что с вами все хорошо?
[32:38.680 --> 32:40.680]  А может быть, вам просто очень везет?
[32:40.680 --> 32:42.680]  Ну или скажем, вам
[32:42.680 --> 32:44.680]  пока везет, потому что
[32:44.680 --> 32:46.680]  проблема редкая и просто не воспроизводится.
[32:46.680 --> 32:48.680]  Вот скажем,
[32:50.680 --> 32:52.680]  я, скорее всего, вам
[32:52.680 --> 32:54.680]  однажды расскажу, когда у нас будет тема
[32:54.680 --> 32:56.680]  про лог-фри, про лог-фри-алокатор,
[32:56.680 --> 32:58.680]  который и в Яндексе давно-давно написали,
[32:58.680 --> 33:00.680]  и потом, спустя, кажется,
[33:00.680 --> 33:02.680]  даже годы
[33:02.680 --> 33:04.680]  нашли в нем баг, который проявлялся,
[33:04.680 --> 33:06.680]  когда у вас там машина с
[33:06.680 --> 33:08.680]  6400 ядрами, и вот где-то очень
[33:08.680 --> 33:10.680]  редко, вот она там работает 24 на 7,
[33:10.680 --> 33:12.680]  там алоцирует-делоцирует постоянно,
[33:12.680 --> 33:14.680]  и вот иногда очень редко что-то
[33:14.680 --> 33:16.680]  ломалось, потому что в лог-фри-алокаторе
[33:16.680 --> 33:18.680]  был очень хитрый баг.
[33:18.680 --> 33:20.680]  Это было супер-редко и супер-редко
[33:20.680 --> 33:22.680]  проявлялось.
[33:22.680 --> 33:24.680]  Так вот, о чем мы сейчас
[33:24.680 --> 33:26.680]  говорим? Мы хотим
[33:26.680 --> 33:28.680]  каким-то образом подействовать на
[33:28.680 --> 33:30.680]  исполнение программы так,
[33:30.680 --> 33:32.680]  чтобы из нее вываливались
[33:32.680 --> 33:34.680]  ошибки, чтобы
[33:34.680 --> 33:36.680]  ошибки случались, а дальше
[33:36.680 --> 33:38.680]  санитайзер их обнаружит.
[33:38.680 --> 33:40.680]  Ну, либо санитайзер их обнаружит, либо, скажем,
[33:40.680 --> 33:42.680]  какой-то ассерт у нас поломается.
[33:42.680 --> 33:44.680]  То есть мы пишем, что
[33:44.680 --> 33:46.680]  между мьютокс-лог и мьютокс-анлог должен
[33:46.680 --> 33:48.680]  находиться один поток. Там увеличиваем счетчик,
[33:48.680 --> 33:50.680]  смотрим, если он был равен единице уже до инкримента,
[33:50.680 --> 33:52.680]  значит все, мы нарушили знаменитые исключения.
[33:52.680 --> 33:54.680]  Ну вот, то есть чтобы
[33:54.680 --> 33:56.680]  ломались ассерты в тестах, чтобы
[33:56.680 --> 33:58.680]  санитайзер обнаруживал ошибки,
[33:58.680 --> 34:00.680]  адрес LITRED, нужно, чтобы исполнение
[34:00.680 --> 34:02.680]  было более интересным,
[34:02.680 --> 34:04.680]  скажем так.
[34:04.680 --> 34:06.680]  Ну, о чем идет речь? О том, что у нас
[34:06.680 --> 34:08.680]  есть тест, там есть...
[34:08.680 --> 34:10.680]  Мы говорим про многопоточное исполнение,
[34:10.680 --> 34:12.680]  оно недетерминированное.
[34:12.680 --> 34:14.680]  И оно может пойти очень разными
[34:14.680 --> 34:16.680]  траекториями. И как можно
[34:16.680 --> 34:18.680]  все эти исполнения разом
[34:18.680 --> 34:20.680]  представить? Можно представить себе
[34:20.680 --> 34:22.680]  их в виде графа, где каждая
[34:22.680 --> 34:24.680]  вершина – это моментальное состояние мира,
[34:24.680 --> 34:26.680]  такой снимок, снэпшот,
[34:26.680 --> 34:28.680]  который состоит из
[34:28.680 --> 34:30.680]  состояния кучи разделения памяти
[34:30.680 --> 34:32.680]  и содержимого стэков.
[34:32.680 --> 34:34.680]  То есть мы как будто бы фотографируем процессор, память
[34:34.680 --> 34:36.680]  и у нас получается такое моментальное состояние.
[34:36.680 --> 34:38.680]  Это вершина графа.
[34:38.680 --> 34:40.680]  И можно из этой вершины
[34:40.680 --> 34:42.680]  пойти в разные стороны, можно сделать
[34:42.680 --> 34:44.680]  хоть одним потоком, другим, третьим и так далее.
[34:48.680 --> 34:50.680]  Программа правильная, если
[34:50.680 --> 34:52.680]  она...
[34:52.680 --> 34:54.680]  Есть два типа свойств – safety и liveness.
[34:54.680 --> 34:56.680]  Взаимное исключение, скажем,
[34:56.680 --> 34:58.680]  это safety свойства, что никогда
[34:58.680 --> 35:00.680]  не происходит ничего плохого.
[35:00.680 --> 35:02.680]  Очень неформально говорить. Так вот, это свойство
[35:02.680 --> 35:04.680]  в том, что в каждой вершине такого графа
[35:04.680 --> 35:06.680]  свойство выполняется. В каждой вершине
[35:06.680 --> 35:08.680]  такого графа нет двух потоков, которые находятся
[35:08.680 --> 35:10.680]  между узами lock и unlock.
[35:10.680 --> 35:12.680]  Мы бы хотели это проверить.
[35:14.680 --> 35:16.680]  Мы пишем какой-то стресс-тест.
[35:16.680 --> 35:18.680]  Что такое стресс-тест? Мы берем,
[35:18.680 --> 35:20.680]  запускаем сколько-то потоков,
[35:20.680 --> 35:22.680]  какое-то интересное число n.
[35:22.680 --> 35:24.680]  И дальше они
[35:24.680 --> 35:26.680]  в цикле вызывают lock-unlock,
[35:28.680 --> 35:30.680]  а внутри написано sort. Внутри не больше
[35:30.680 --> 35:32.680]  одного потока.
[35:32.680 --> 35:34.680]  И на что мы надеемся?
[35:34.680 --> 35:36.680]  Видимо, мы обойдем много
[35:36.680 --> 35:38.680]  состояния этого исполнения,
[35:38.680 --> 35:40.680]  много вершин графа мы обойдем.
[35:42.680 --> 35:44.680]  Тут проблемы две. Во-первых, граф
[35:44.680 --> 35:46.680]  очень большой.
[35:46.680 --> 35:48.680]  Если у вас 10 потоков,
[35:48.680 --> 35:50.680]  то с ростом числа потоков,
[35:50.680 --> 35:52.680]  количество состояния растет экспоненциально,
[35:52.680 --> 35:54.680]  потому что у вас все интерливинги получаются,
[35:54.680 --> 35:56.680]  все переключения.
[35:56.680 --> 35:58.680]  Вторая проблема в том, что планировщик
[35:58.680 --> 36:00.680]  операционной системы
[36:00.680 --> 36:02.680]  не то чтобы сильно потоки перемешивать.
[36:02.680 --> 36:04.680]  У него же нет такой цели. У него есть цель
[36:04.680 --> 36:06.680]  противоположная, чтобы все спокойно исполнялись.
[36:06.680 --> 36:08.680]  Так что исполнится один поток некоторое время,
[36:08.680 --> 36:10.680]  потом исполнится другой поток некоторое время.
[36:10.680 --> 36:12.680]  Переключения редкие.
[36:12.680 --> 36:14.680]  А баги сложные. Появляются тогда,
[36:14.680 --> 36:16.680]  когда у вас буквально потоки делают по одному ходу
[36:16.680 --> 36:18.680]  и так очередуются постоянно.
[36:20.680 --> 36:22.680]  Две проблемы. Число состояния слишком большое
[36:22.680 --> 36:24.680]  и планировщик
[36:24.680 --> 36:26.680]  не перемешивает потоки достаточно
[36:26.680 --> 36:28.680]  хорошо для вашего стресс-теста
[36:28.680 --> 36:30.680]  и для санитайзера.
[36:30.680 --> 36:32.680]  Как мы боремся с этими проблемами?
[36:32.680 --> 36:34.680]  Во-первых, с числом состояния
[36:34.680 --> 36:36.680]  мы не боремся особо.
[36:36.680 --> 36:38.680]  Мы говорим, что мы просто не пишем стресс-тесты,
[36:38.680 --> 36:40.680]  где у нас 100 потоков.
[36:40.680 --> 36:42.680]  Потому что
[36:42.680 --> 36:44.680]  вот так устроена Вселенная.
[36:44.680 --> 36:46.680]  Это нельзя доказать,
[36:46.680 --> 36:48.680]  но можно просто в это поверить.
[36:48.680 --> 36:50.680]  Все сложные баги,
[36:50.680 --> 36:52.680]  связанные с конкурентностью,
[36:52.680 --> 36:54.680]  с чередованием,
[36:54.680 --> 36:56.680]  и в потоках,
[36:56.680 --> 36:58.680]  и в распределенных системах,
[36:58.680 --> 37:00.680]  это одинаково справедливо.
[37:00.680 --> 37:02.680]  Все сложные баги можно смоделировать
[37:02.680 --> 37:04.680]  на очень небольшом количестве участников.
[37:04.680 --> 37:06.680]  Такое свойство Вселенной.
[37:06.680 --> 37:08.680]  Трех потоков достаточно для того,
[37:08.680 --> 37:10.680]  чтобы смоделировать любой возможный баг, кажется.
[37:10.680 --> 37:12.680]  Трех-четырех максимум.
[37:12.680 --> 37:14.680]  Двух иногда достаточно.
[37:14.680 --> 37:16.680]  Задача LifeLog. Вы построили LifeLog
[37:16.680 --> 37:18.680]  из двух потоков.
[37:18.680 --> 37:20.680]  Любые контры примера, которые вы строите,
[37:20.680 --> 37:22.680]  можно построить для трех потоков во всех задачах.
[37:24.680 --> 37:26.680]  Потому что это продакшн,
[37:26.680 --> 37:28.680]  и там нет fault injection в продакшне, разумеется.
[37:30.680 --> 37:32.680]  Совсем другая ситуация.
[37:32.680 --> 37:34.680]  Я не про то сейчас говорю,
[37:34.680 --> 37:36.680]  продакшн это не тестирование,
[37:36.680 --> 37:38.680]  это разные вещи.
[37:38.680 --> 37:40.680]  Если мы целенаправленно что-то тестируем,
[37:40.680 --> 37:42.680]  то во-первых, нам не нужно иметь
[37:42.680 --> 37:44.680]  много потоков,
[37:44.680 --> 37:46.680]  поэтому в тестах везде их единицы.
[37:46.680 --> 37:48.680]  Два, три, пять максимум.
[37:48.680 --> 37:50.680]  А во-вторых,
[37:50.680 --> 37:52.680]  чтобы получить большее
[37:52.680 --> 37:54.680]  покрытие графа
[37:54.680 --> 37:56.680]  состояний исполнения,
[37:56.680 --> 38:00.680]  нужно каким-то образом воздействовать
[38:00.680 --> 38:02.680]  на планировщика.
[38:02.680 --> 38:04.680]  И вот техника называется fault injection.
[38:04.680 --> 38:06.680]  Недрение сбоев.
[38:06.680 --> 38:08.680]  Мы не просто
[38:08.680 --> 38:10.680]  исполняем стресс тест,
[38:10.680 --> 38:14.680]  мы внедряем в него сбои
[38:14.680 --> 38:16.680]  и смотрим, как наш код реагирует
[38:16.680 --> 38:18.680]  на эти сбои.
[38:18.680 --> 38:20.680]  Но проще объяснить
[38:20.680 --> 38:22.680]  на распределенных системах.
[38:22.680 --> 38:24.680]  У вас есть распределенная система,
[38:24.680 --> 38:26.680]  хотя вы про это мало что знаете.
[38:26.680 --> 38:28.680]  Там есть отдельные узлы,
[38:28.680 --> 38:30.680]  они общаются, передачи сообщений,
[38:30.680 --> 38:32.680]  и система должна быть надежной
[38:32.680 --> 38:34.680]  в том смысле, что она должна переживать
[38:34.680 --> 38:36.680]  узлов.
[38:36.680 --> 38:38.680]  Зачем система распределенная?
[38:38.680 --> 38:40.680]  Затем, что одна машина может отказать,
[38:40.680 --> 38:42.680]  это неизбежно, машины ненадежные.
[38:42.680 --> 38:44.680]  Но пользователь ничего не заметит.
[38:44.680 --> 38:46.680]  И как можно проверить,
[38:46.680 --> 38:48.680]  что система надежная?
[38:48.680 --> 38:50.680]  Можно дать на нее нагрузку
[38:50.680 --> 38:52.680]  и ждать год.
[38:52.680 --> 38:54.680]  За год у вас сломается 100 дисков,
[38:54.680 --> 38:56.680]  у вас машина тысячу раз перезагрузится.
[38:56.680 --> 38:58.680]  А что вы можете сделать иначе?
[38:58.680 --> 39:00.680]  Вы можете построить
[39:00.680 --> 39:02.680]  некоторые тестовые окружения,
[39:02.680 --> 39:04.680]  выпустить узлы вашей системы, дать на нее нагрузку,
[39:04.680 --> 39:06.680]  и просто ходить
[39:06.680 --> 39:08.680]  и нажимать на кнопки Restart.
[39:10.680 --> 39:12.680]  Вытаскивать из машины диски на ходу.
[39:12.680 --> 39:14.680]  Выдергивать провода.
[39:14.680 --> 39:16.680]  И система,
[39:16.680 --> 39:18.680]  если вы выдерживаете все провода,
[39:18.680 --> 39:20.680]  система не будет работать.
[39:20.680 --> 39:22.680]  Но если вы
[39:22.680 --> 39:24.680]  выдергиваете поочередно,
[39:24.680 --> 39:26.680]  сломали одну машину,
[39:26.680 --> 39:28.680]  потом включили обратно, сломали другую машину,
[39:28.680 --> 39:30.680]  это бы и без вас произошло
[39:30.680 --> 39:32.680]  просто за очень большое время.
[39:32.680 --> 39:34.680]  А вы это время зажали.
[39:34.680 --> 39:36.680]  Вы делаете это сами.
[39:36.680 --> 39:38.680]  Вы внедряете сбои и рассчитываете,
[39:38.680 --> 39:40.680]  что ваша программа по-прежнему продолжит работать.
[39:40.680 --> 39:42.680]  В смысле, что ваша распределенная система
[39:42.680 --> 39:44.680]  по-прежнему продолжит работать
[39:44.680 --> 39:46.680]  и отвечать пользователю там без ошибок,
[39:46.680 --> 39:48.680]  чтобы это не значило.
[39:48.680 --> 39:50.680]  Вот идея Фолтин Джекшена.
[39:50.680 --> 39:52.680]  И в курсе про распределенная система
[39:52.680 --> 39:54.680]  мы только так жить и будем.
[39:54.680 --> 39:56.680]  В нашем курсе
[39:56.680 --> 39:58.680]  Фолтин Джекшен выглядит так.
[39:58.680 --> 40:00.680]  Сбои, которые должна
[40:00.680 --> 40:02.680]  переживать ваша программа,
[40:02.680 --> 40:04.680]  это переключение и пауза поток.
[40:06.680 --> 40:08.680]  Вот если вы берете,
[40:08.680 --> 40:10.680]  вы пишете два атомика подряд,
[40:12.680 --> 40:14.680]  в смысле две операции на атомика подряд,
[40:14.680 --> 40:16.680]  не знаю, Store, там уходит Load,
[40:16.680 --> 40:18.680]  то
[40:18.680 --> 40:20.680]  внутри...
[40:20.680 --> 40:22.680]  А что я рассказываю? Давайте я покажу.
[40:24.680 --> 40:26.680]  Смотрите, вот вы пишете
[40:26.680 --> 40:28.680]  какой-то код.
[40:30.680 --> 40:32.680]  И нам хочется внедрять
[40:32.680 --> 40:34.680]  в этот код сбои.
[40:34.680 --> 40:36.680]  Еще
[40:36.680 --> 40:38.680]  некоторое такое свойство природы,
[40:38.680 --> 40:40.680]  что
[40:40.680 --> 40:42.680]  в коде, где нет гонок,
[40:42.680 --> 40:44.680]  переключение потоков
[40:44.680 --> 40:46.680]  не нужно внедрять везде.
[40:46.680 --> 40:48.680]  Достаточно переключить потоки в точках,
[40:48.680 --> 40:50.680]  где потоки обращаются к приметилописно-хронизации,
[40:50.680 --> 40:52.680]  где они общаются друг с другом.
[40:52.680 --> 40:54.680]  Вот, ровно поэтому
[40:54.680 --> 40:56.680]  в этом коде мы используем не стд-атомик,
[40:56.680 --> 40:58.680]  не стд-мьютакс, не стд-кондвар,
[40:58.680 --> 41:00.680]  а свои собственные обертки,
[41:00.680 --> 41:02.680]  и вот при обращении к ним
[41:02.680 --> 41:04.680]  внедряются сбои,
[41:04.680 --> 41:06.680]  то есть переключаются...
[41:06.680 --> 41:08.680]  потоки переключаются друг на друга.
[41:08.680 --> 41:10.680]  И это происходит гораздо чаще, чем
[41:10.680 --> 41:12.680]  они переключались бы в
[41:12.680 --> 41:14.680]  обычном планировщике, планировщике
[41:14.680 --> 41:16.680]  операционной системы.
[41:16.680 --> 41:18.680]  На самом деле сложнее, конечно,
[41:18.680 --> 41:20.680]  в библиотеке тут есть много
[41:20.680 --> 41:22.680]  много слоев.
[41:22.680 --> 41:24.680]  Вот есть слой фасад,
[41:24.680 --> 41:26.680]  с которым вы работаете.
[41:26.680 --> 41:28.680]  Тут лежит
[41:28.680 --> 41:30.680]  некоторое объявление атомика.
[41:30.680 --> 41:32.680]  На самом деле атомиков здесь два лежит.
[41:32.680 --> 41:34.680]  В случае сборки с файберами,
[41:34.680 --> 41:36.680]  в случае сборки с потоками.
[41:36.680 --> 41:38.680]  Ну, давайте я пока расскажу
[41:38.680 --> 41:40.680]  только про потоки,
[41:40.680 --> 41:42.680]  а потом объясню, зачем файберы нужны.
[41:44.680 --> 41:46.680]  Вот если вы собираете
[41:46.680 --> 41:48.680]  код
[41:48.680 --> 41:50.680]  с
[41:50.680 --> 41:52.680]  в релизе
[41:52.680 --> 41:54.680]  и без fault injection,
[41:54.680 --> 41:56.680]  код, который мы написали в курсе,
[41:56.680 --> 41:58.680]  то, скажем, Mutex
[41:58.680 --> 42:00.680]  превращается просто
[42:00.680 --> 42:02.680]  в STD Mutex.
[42:02.680 --> 42:04.680]  То есть тут обычный Mutex, никакого оверхеда нет.
[42:04.680 --> 42:06.680]  Если же
[42:06.680 --> 42:08.680]  вы
[42:08.680 --> 42:10.680]  в сборке устанавливаете
[42:10.680 --> 42:12.680]  флажок
[42:12.680 --> 42:14.680]  fault, давайте это
[42:14.680 --> 42:16.680]  сделаем сейчас.
[42:16.680 --> 42:18.680]  Активировалась другая ветка.
[42:18.680 --> 42:20.680]  И теперь ваш
[42:20.680 --> 42:22.680]  Twistas Delight Mutex
[42:22.680 --> 42:24.680]  type alias другой.
[42:24.680 --> 42:26.680]  Это некоторые faulty Mutex.
[42:26.680 --> 42:28.680]  И чем этот faulty Mutex занимается?
[42:28.680 --> 42:30.680]  В методе lock
[42:30.680 --> 42:32.680]  у него есть реализация
[42:32.680 --> 42:34.680]  и у него
[42:34.680 --> 42:36.680]  вызывает в конце метода lock.
[42:36.680 --> 42:38.680]  Но
[42:38.680 --> 42:40.680]  перед локом и после лока
[42:40.680 --> 42:42.680]  стоит вызов InjectFault,
[42:42.680 --> 42:44.680]  который внедряет сбой.
[42:44.680 --> 42:46.680]  InjectFault вызывает
[42:46.680 --> 42:48.680]  некоторого adversary, злоумышленника,
[42:48.680 --> 42:50.680]  который решает, когда же потоки
[42:50.680 --> 42:52.680]  нужно переключать.
[42:52.680 --> 42:54.680]  И вызывает у него fault.
[42:54.680 --> 42:56.680]  И дефолтная реализация этого
[42:56.680 --> 42:58.680]  adversary, она
[42:58.680 --> 43:00.680]  иногда
[43:00.680 --> 43:02.680]  переключает потоки.
[43:02.680 --> 43:04.680]  Иногда вызывает yield по некоторому хитрому
[43:04.680 --> 43:06.680]  правилу, который
[43:06.680 --> 43:08.680]  магически работает и вытрясает
[43:08.680 --> 43:10.680]  из вашего кода бага.
[43:10.680 --> 43:12.680]  Эта стратегия внедрения сбоев,
[43:12.680 --> 43:14.680]  она помещает в ваше
[43:14.680 --> 43:16.680]  исполнение больше переключения контекста,
[43:16.680 --> 43:18.680]  больше переключения потоков.
[43:18.680 --> 43:20.680]  И в результате мы увеличиваем таким образом
[43:20.680 --> 43:22.680]  покрытие графов в состоянии стресс-теста.
[43:24.680 --> 43:26.680]  А значит, ломается больше ассертов,
[43:26.680 --> 43:28.680]  выпадает больше датарейсов, выпадает больше
[43:28.680 --> 43:30.680]  user-free и подобных вещей.
[43:34.680 --> 43:36.680]  Итак, для fault injection
[43:36.680 --> 43:38.680]  обернуты все примитивы, которые мы
[43:38.680 --> 43:40.680]  используем.
[43:40.680 --> 43:42.680]  Fetch эту атомику
[43:42.680 --> 43:44.680]  до и после injectFault.
[43:44.680 --> 43:46.680]  CompareExchangeWig
[43:46.680 --> 43:48.680]  где он?
[43:48.680 --> 43:50.680]  Написан вот так вот.
[43:52.680 --> 43:54.680]  Иногда говорим false просто
[43:54.680 --> 43:56.680]  потому что. Почему бы и нет?
[43:56.680 --> 43:58.680]  Можем позволить себе это по семантике.
[43:58.680 --> 44:00.680]  Вот это
[44:00.680 --> 44:02.680]  следующий слой в библиотеке,
[44:02.680 --> 44:04.680]  то есть мы можем использовать std.mutex,
[44:04.680 --> 44:06.680]  а можем его обернуть,
[44:06.680 --> 44:08.680]  ну, std.atomic можем его обернуть в такую
[44:08.680 --> 44:10.680]  штуку. Или мы можем
[44:10.680 --> 44:12.680]  взять std.mutex
[44:12.680 --> 44:14.680]  и обернуть его вот
[44:14.680 --> 44:16.680]  нет, не здесь.
[44:20.680 --> 44:22.680]  Вот в такую штуку.
[44:24.680 --> 44:26.680]  Это следующий
[44:26.680 --> 44:28.680]  уровень библиотеки.
[44:30.680 --> 44:32.680]  А под ним еще
[44:32.680 --> 44:34.680]  один слой есть, а именно
[44:34.680 --> 44:36.680]  он здесь называется strand
[44:36.680 --> 44:38.680]  или виртуальный поток.
[44:38.680 --> 44:40.680]  То есть мы, когда
[44:40.680 --> 44:42.680]  внедряем сбой, мы переключаем потоки.
[44:42.680 --> 44:44.680]  Ну, точнее мы переключаем не потоки,
[44:44.680 --> 44:46.680]  а некоторые вот штуки, которые исполняются,
[44:46.680 --> 44:48.680]  которые похожи на потоки.
[44:48.680 --> 44:50.680]  И вот эти
[44:50.680 --> 44:52.680]  потоки как будто бы
[44:52.680 --> 44:54.680]  они могут
[44:54.680 --> 44:56.680]  быть потоками и std.red могут быть.
[44:56.680 --> 44:58.680]  А могут быть и не
[44:58.680 --> 45:00.680]  std.red. Давайте я покажу
[45:00.680 --> 45:02.680]  где они
[45:02.680 --> 45:04.680]  объявляются.
[45:04.680 --> 45:06.680]  Ну, наверное, здесь, да.
[45:06.680 --> 45:08.680]  Вот этот strand
[45:08.680 --> 45:10.680]  thread может быть thread,
[45:10.680 --> 45:12.680]  а может быть, может быть
[45:12.680 --> 45:14.680]  std.red по умолчанию.
[45:14.680 --> 45:16.680]  А может быть
[45:16.680 --> 45:18.680]  штукой, которая
[45:18.680 --> 45:20.680]  маскируется по thread, то есть файбером.
[45:22.680 --> 45:24.680]  Нет, не почему, а зачем.
[45:26.680 --> 45:28.680]  Затем чтобы
[45:28.680 --> 45:30.680]  моделировать потоки
[45:30.680 --> 45:32.680]  под файберами, в смысле
[45:32.680 --> 45:34.680]  пускать тесты, где каждый поток
[45:34.680 --> 45:36.680]  это файбер, потому что, во-первых,
[45:36.680 --> 45:38.680]  ну, это даже где-то там написано.
[45:40.680 --> 45:42.680]  Ну, во-первых, файберы работают
[45:42.680 --> 45:44.680]  быстрее, их быстрее переключать,
[45:44.680 --> 45:46.680]  значит в единицу времени у нас
[45:46.680 --> 45:48.680]  будет больше, мы
[45:48.680 --> 45:50.680]  переберем больше исполнений.
[45:50.680 --> 45:52.680]  Еще одно свойство, очень важное,
[45:52.680 --> 45:54.680]  очень удобное в тестировании,
[45:54.680 --> 45:56.680]  это детерминизм.
[45:56.680 --> 45:58.680]  Вот с потоками это
[45:58.680 --> 46:00.680]  еще ладно, а вот с распределенными системами
[46:00.680 --> 46:02.680]  с детерминизмом тестировать просто
[46:02.680 --> 46:04.680]  в миллион раз лучше.
[46:04.680 --> 46:06.680]  Это то, чего люди решены
[46:06.680 --> 46:08.680]  на планете в большинстве своем,
[46:08.680 --> 46:10.680]  а мы осенью будем этим пользоваться, и это прекрасно.
[46:10.680 --> 46:12.680]  Так делает очень мало кто на свете,
[46:12.680 --> 46:14.680]  это очень сложно, но
[46:14.680 --> 46:16.680]  с детерминизмом тестировать конкурентные баги,
[46:16.680 --> 46:18.680]  отлаживать их гораздо проще,
[46:18.680 --> 46:20.680]  но вы понимаете почему.
[46:20.680 --> 46:22.680]  Тест, ну,
[46:22.680 --> 46:24.680]  смотри, у тебя баги недетерминированные
[46:24.680 --> 46:26.680]  по своей природе, вот как сложится исполнение,
[46:26.680 --> 46:28.680]  оно выпадет или не выпадет.
[46:28.680 --> 46:30.680]  А исполнение под файберами
[46:30.680 --> 46:32.680]  там нет недетерминизма.
[46:32.680 --> 46:34.680]  Там все в одном потоке,
[46:34.680 --> 46:36.680]  и передача управления кооперативная.
[46:36.680 --> 46:38.680]  Вот если мы инициализируем
[46:38.680 --> 46:40.680]  адверсари некоторым Сидом,
[46:40.680 --> 46:42.680]  одним и тем же, то он будет
[46:42.680 --> 46:44.680]  генерировать одну и ту же череду
[46:44.680 --> 46:46.680]  сбоев, переключений,
[46:46.680 --> 46:48.680]  и это все детерминированно исполнено с под файберами.
[46:50.680 --> 46:52.680]  И тест будет работать у тебя
[46:52.680 --> 46:54.680]  так же, как и любой другой машине,
[46:54.680 --> 46:56.680]  и ты можешь его просто по шагам воспроизвести.
[46:56.680 --> 46:58.680]  Здесь мы этого не делаем, а вообще можно.
[46:58.680 --> 47:00.680]  Осенью будем.
[47:00.680 --> 47:02.680]  Это огромный бонус для тестов,
[47:02.680 --> 47:04.680]  недетерминированные тесты это всегда очень плохо.
[47:06.680 --> 47:08.680]  Кроме того,
[47:08.680 --> 47:10.680]  ну, там есть детектор дедлоков еще заодно,
[47:10.680 --> 47:12.680]  но вот еще одно
[47:12.680 --> 47:14.680]  приятное свойство, которое мы получаем
[47:14.680 --> 47:16.680]  именно используя файберы,
[47:16.680 --> 47:18.680]  мы полагаемся теперь на планировщик
[47:18.680 --> 47:20.680]  не операционной системы, а свой собственный.
[47:22.680 --> 47:24.680]  И почему это удобно?
[47:24.680 --> 47:26.680]  Почему это нам что-то дает новое?
[47:26.680 --> 47:28.680]  Когда мы говорим
[47:28.680 --> 47:30.680]  yield в исполнении с потоками,
[47:30.680 --> 47:32.680]  то что мы делаем? Мы ставим поток
[47:32.680 --> 47:34.680]  в конец очередной исполнения.
[47:34.680 --> 47:36.680]  Когда же
[47:36.680 --> 47:38.680]  мы для файберов
[47:38.680 --> 47:40.680]  говорим yield,
[47:40.680 --> 47:42.680]  то происходит нечто
[47:42.680 --> 47:44.680]  более сложное, потому что
[47:44.680 --> 47:46.680]  планировщик, когда
[47:46.680 --> 47:48.680]  выбирает очередной файбер для исполнения,
[47:48.680 --> 47:50.680]  он просто берет случайный.
[47:50.680 --> 47:52.680]  То есть мы, моделируя код
[47:52.680 --> 47:54.680]  под файберами, еще перемешиваем очереди
[47:54.680 --> 47:56.680]  ожидания в мьютоксах, в кондварах
[47:56.680 --> 47:58.680]  и очередь
[47:58.680 --> 48:00.680]  рангью в планировщики.
[48:00.680 --> 48:02.680]  Это вот
[48:02.680 --> 48:04.680]  еще больше перемешивания, которое нам недоступно,
[48:04.680 --> 48:06.680]  когда мы работаем с
[48:06.680 --> 48:08.680]  тредами из планировщика
[48:08.680 --> 48:10.680]  в операционной системы.
[48:10.680 --> 48:12.680]  И эта комбинация
[48:12.680 --> 48:14.680]  из всех этих режимов,
[48:14.680 --> 48:16.680]  то есть в итоге
[48:16.680 --> 48:18.680]  что мы получаем в библиотеке?
[48:18.680 --> 48:20.680]  Мы получаем довольно много режимов сборки,
[48:20.680 --> 48:22.680]  мы выбираем код по 100-500 раз.
[48:22.680 --> 48:24.680]  У нас есть 3 направления,
[48:24.680 --> 48:26.680]  в которых мы можем что-то варьировать.
[48:26.680 --> 48:28.680]  У нас есть исполнение под тредами
[48:28.680 --> 48:30.680]  или под файберами,
[48:30.680 --> 48:32.680]  мы выбираем что-то, у нас есть
[48:32.680 --> 48:34.680]  разные санитайзеры, тред-санитайзеры,
[48:34.680 --> 48:36.680]  адлес-санитайзеры, и у нас есть fault injection.
[48:36.680 --> 48:38.680]  И мы разные варианты можем комбинировать,
[48:38.680 --> 48:40.680]  и каждый вариант по своему разуму.
[48:44.680 --> 48:46.680]  То есть он какой-то класс багов старается поймать.
[48:46.680 --> 48:48.680]  Идея fault injection такая,
[48:48.680 --> 48:50.680]  что мы внедряем в исполнение сбоя
[48:50.680 --> 48:52.680]  в нашем случае для переключения,
[48:52.680 --> 48:54.680]  и за счет этого увеличиваем
[48:54.680 --> 48:56.680]  покрытие графа состояния стресс-теста.
[48:56.680 --> 48:58.680]  Поэтому в нем проявляется
[48:58.680 --> 49:00.680]  больше ошибок, и они детектятся
[49:00.680 --> 49:02.680]  ассертами
[49:02.680 --> 49:04.680]  тред-санитайзером и адлес-санитайзером.
[49:06.680 --> 49:08.680]  То есть fault injection и санитайзер
[49:08.680 --> 49:10.680]  работают в комбинации.
[49:12.680 --> 49:14.680]  Fault injection помогает санитайзерам.
[49:18.680 --> 49:20.680]  Преимущество файбера,
[49:20.680 --> 49:22.680]  по тому, что вы сказали,
[49:22.680 --> 49:24.680]  почему она может потребоваться тестировать
[49:24.680 --> 49:26.680]  именно на файберах?
[49:26.680 --> 49:28.680]  Потому что это все-таки некоторое упрощение реальности.
[49:28.680 --> 49:30.680]  У тебя настоящие труды параллельные,
[49:30.680 --> 49:32.680]  а файберы не параллельные.
[49:32.680 --> 49:34.680]  И вот, скажем, data-rays,
[49:34.680 --> 49:36.680]  они проявляются именно
[49:36.680 --> 49:38.680]  на потоках нужно тестировать,
[49:38.680 --> 49:40.680]  а не на файберах.
[49:40.680 --> 49:42.680]  То есть ты получаешь преимущество,
[49:42.680 --> 49:44.680]  но с другой стороны теряешь физическую
[49:44.680 --> 49:46.680]  параллельность. Это потоки
[49:46.680 --> 49:48.680]  настоящие параллельные все-таки,
[49:48.680 --> 49:50.680]  и об этом иногда нужно думать.
[49:54.680 --> 49:56.680]  Ну что скажете, есть вопросы или нет?
[49:56.680 --> 49:58.680]  Вот fault injection,
[49:58.680 --> 50:00.680]  смотрите,
[50:00.680 --> 50:02.680]  вряд ли
[50:02.680 --> 50:04.680]  этому, мне кажется,
[50:04.680 --> 50:06.680]  почти не учат, а мне кажется,
[50:06.680 --> 50:08.680]  что это суперважно.
[50:08.680 --> 50:10.680]  Вот без хороших тестов писать сложные системы невозможно,
[50:10.680 --> 50:12.680]  и без хороших тестов невозможно
[50:12.680 --> 50:14.680]  писать системы
[50:14.680 --> 50:16.680]  многопоточные и распределенные особенно.
[50:18.680 --> 50:20.680]  Потому что баги у них не детерминированные,
[50:20.680 --> 50:22.680]  и никакими простыми тестами они не ловятся.
[50:22.680 --> 50:24.680]  Вот. А с другой стороны,
[50:24.680 --> 50:26.680]  это такие компоненты инфраструктуры,
[50:26.680 --> 50:28.680]  на которых вот как бы все остальное,
[50:28.680 --> 50:30.680]  весь остальной мир строится.
[50:30.680 --> 50:32.680]  Вот вы пишете старт-ап,
[50:32.680 --> 50:34.680]  где там, не знаю, вы
[50:34.680 --> 50:36.680]  подбираете котят пользователям.
[50:36.680 --> 50:38.680]  Вот. Ну и как бы все здорово,
[50:38.680 --> 50:40.680]  но под капотом там какая-то база данных лежит,
[50:40.680 --> 50:42.680]  и под капотом какое-то облако.
[50:42.680 --> 50:44.680]  И облака и база данных,
[50:44.680 --> 50:46.680]  вот на них живет, в общем-то, весь бизнес.
[50:46.680 --> 50:48.680]  И если там будут ошибки,
[50:48.680 --> 50:50.680]  это будет очень печально для всех.
[50:50.680 --> 50:52.680]  А сам кот в этих базах данных
[50:52.680 --> 50:54.680]  и в этих облаках, он очень сложный,
[50:54.680 --> 50:56.680]  очень распределенный, очень конкурентный,
[50:56.680 --> 50:58.680]  и тестировать
[50:58.680 --> 51:00.680]  его нужно вот каким-то
[51:00.680 --> 51:02.680]  специальными, особенными инструментами.
[51:04.680 --> 51:06.680]  Вас это почти не касается на учебе,
[51:06.680 --> 51:08.680]  потому что вы отправляете, вы нажимаете
[51:08.680 --> 51:10.680]  какую-то магическую кнопку, и вот кот работает.
[51:10.680 --> 51:12.680]  Но если вы пишете большой проект,
[51:12.680 --> 51:14.680]  то вам просто необходимо с самого начала
[51:14.680 --> 51:16.680]  подумать, как вы будете его тестировать.
[51:16.680 --> 51:18.680]  И, скажем, вот для курс
[51:18.680 --> 51:20.680]  распределенных систем я реализую некоторое
[51:20.680 --> 51:22.680]  идеальное видение мира, как это должно быть.
[51:22.680 --> 51:24.680]  Так делают, кажется, только в Apple
[51:24.680 --> 51:26.680]  и только в одном месте.
[51:26.680 --> 51:28.680]  И делают в Amazon, в ВВС.
[51:28.680 --> 51:30.680]  Там тоже исповедуют
[51:30.680 --> 51:32.680]  такой подход с fault injection
[51:32.680 --> 51:34.680]  и с тестированием, как бы с дизайном,
[51:34.680 --> 51:36.680]  который основан на тестировании с самого начала.
[51:40.680 --> 51:42.680]  Ну, в общем,
[51:42.680 --> 51:44.680]  об этом нужно думать
[51:44.680 --> 51:46.680]  с самого начала,
[51:46.680 --> 51:48.680]  когда вы пишете код.
[51:48.680 --> 51:50.680]  И вот фреймворк, который мы пишем,
[51:50.680 --> 51:52.680]  который будет использоваться осенью,
[51:52.680 --> 51:54.680]  он написан поверх твиста,
[51:54.680 --> 51:56.680]  потому что, я не знаю,
[51:56.680 --> 51:58.680]  как писать сложный конкурентный код,
[51:58.680 --> 52:00.680]  не умею его тестировать.
[52:00.680 --> 52:02.680]  Я самому себе доверяю, но проверяю.
[52:02.680 --> 52:04.680]  Не доверяю.
[52:04.680 --> 52:06.680]  Примерно понимаю, что это правильно,
[52:06.680 --> 52:08.680]  но как мне убедиться? Я должен написать инструмент,
[52:08.680 --> 52:10.680]  чтобы это делать.
[52:10.680 --> 52:12.680]  Как делают люди,
[52:12.680 --> 52:14.680]  не знаю, в продакшене, на работе,
[52:14.680 --> 52:16.680]  как они пишут код и просто
[52:16.680 --> 52:18.680]  проверяют его глазами,
[52:18.680 --> 52:20.680]  непонятно.
[52:20.680 --> 52:22.680]  Вот, скажем,
[52:22.680 --> 52:24.680]  я вам не успею рассказать уже без шансов, конечно,
[52:24.680 --> 52:26.680]  но вот
[52:26.680 --> 52:28.680]  я хотел вам показать
[52:28.680 --> 52:30.680]  реализацию кондвара
[52:30.680 --> 52:32.680]  в питредах.
[52:32.680 --> 52:34.680]  И, ну, вот, смотрите, вы же писали
[52:34.680 --> 52:36.680]  какой-то уже код на атомиках.
[52:36.680 --> 52:38.680]  И вы понимаете, что если там один атомик,
[52:38.680 --> 52:40.680]  то это простое решение. А если там два атомика,
[52:40.680 --> 52:42.680]  то уже вот сильно сложнее. Если три атомика,
[52:42.680 --> 52:44.680]  то, кажется, такого даже не бывало.
[52:44.680 --> 52:46.680]  Но нужно представить себе больше интерливингов.
[52:46.680 --> 52:48.680]  Вот в питредном кондваре,
[52:48.680 --> 52:50.680]  который вот std-кондвар
[52:50.680 --> 52:52.680]  под линуксом,
[52:52.680 --> 52:54.680]  там атомика примерно дюжина,
[52:54.680 --> 52:56.680]  и вот код на них он занимает,
[52:56.680 --> 52:58.680]  ну, тут комментариев много,
[52:58.680 --> 53:00.680]  но код из десяти строчек
[53:00.680 --> 53:02.680]  в экспоненту сложнее,
[53:02.680 --> 53:04.680]  чем код из трех строчек,
[53:04.680 --> 53:06.680]  а здесь их, там, не знаю, несколько десятков,
[53:06.680 --> 53:08.680]  вот именно содержательных строчек.
[53:08.680 --> 53:10.680]  Как автор...
[53:10.680 --> 53:12.680]  Я верю, что автор очень умный.
[53:12.680 --> 53:14.680]  То есть я читаю комментарии, читаю...
[53:14.680 --> 53:16.680]  Он очень умный, он все понимает, он очень аккуратен.
[53:16.680 --> 53:18.680]  Но вот это, в конце концов,
[53:18.680 --> 53:20.680]  человек, и
[53:20.680 --> 53:22.680]  как бы он написал код,
[53:22.680 --> 53:24.680]  он даже может быть очень умным
[53:24.680 --> 53:26.680]  и знать, что он работает, но это
[53:26.680 --> 53:28.680]  бас-фактор некоторый.
[53:28.680 --> 53:30.680]  Вот, если этот человек уйдет с проекта,
[53:30.680 --> 53:32.680]  то кто будет поддерживать этот код?
[53:32.680 --> 53:34.680]  Может быть, его и не нужно рефакторить дальше,
[53:34.680 --> 53:36.680]  но все равно это очень сложно.
[53:36.680 --> 53:38.680]  Вот хорошо бы, чтобы можно было
[53:38.680 --> 53:40.680]  опираться на инструменты.
[53:40.680 --> 53:42.680]  Как люди обходятся без них,
[53:42.680 --> 53:44.680]  я плохо понимаю, честно говоря,
[53:44.680 --> 53:46.680]  поэтому я вот за то, чтобы с самого начала,
[53:46.680 --> 53:48.680]  если вы пишете многопоточный код,
[53:48.680 --> 53:50.680]  чтобы у вас были инструменты,
[53:50.680 --> 53:52.680]  чтобы его тестировать.
[53:52.680 --> 53:54.680]  Я об этом еще расскажу чуть позже,
[53:54.680 --> 53:56.680]  сильно позже, в лекции про планировщик,
[53:56.680 --> 53:58.680]  когда
[53:58.680 --> 54:00.680]  в языке Rust вы, наверное, про него
[54:00.680 --> 54:02.680]  слышали, писали
[54:02.680 --> 54:04.680]  новый рантайм для асинхронности
[54:04.680 --> 54:06.680]  планировщик в Токио,
[54:06.680 --> 54:08.680]  то перед тем, как его написать, написали сначала инструмент,
[54:08.680 --> 54:10.680]  который перебирает в нем все исполнения.
[54:10.680 --> 54:12.680]  А только потом написали планировщик уже,
[54:12.680 --> 54:14.680]  потому что иначе непонятно, как этот код тестировать.
[54:14.680 --> 54:16.680]  Он очень сложный, на нем будет очень многое
[54:16.680 --> 54:18.680]  завязано, к нему будет очень многое зависеть.
[54:18.680 --> 54:20.680]  Он должен быть абсолютно надежным.
[54:20.680 --> 54:22.680]  Вот человеку мы здесь не доверяем.
[54:22.680 --> 54:24.680]  Человек не переберет в голове все вот эти там
[54:24.680 --> 54:26.680]  сотни, тысячи состояния
[54:26.680 --> 54:28.680]  исполнения.
[54:28.680 --> 54:30.680]  Вот мы тоже не перебираем, но мы
[54:30.680 --> 54:32.680]  увеличиваем покрытие. В идеале
[54:32.680 --> 54:34.680]  есть другая крайность,
[54:34.680 --> 54:36.680]  когда мы прямо перебираем все
[54:36.680 --> 54:38.680]  исполнения. Так, в принципе, тоже можно сделать.
[54:38.680 --> 54:40.680]  В курсе это однажды появится, то есть можно
[54:40.680 --> 54:42.680]  написать тест на C++
[54:42.680 --> 54:44.680]  и просто перебирать все его исполнения
[54:44.680 --> 54:46.680]  очень хитрым образом.
[54:46.680 --> 54:48.680]  В принципе, пример даже
[54:48.680 --> 54:50.680]  у меня в
[54:50.680 --> 54:52.680]  на GitLab можно найти Маша Фяфанова, студентка
[54:52.680 --> 54:54.680]  два года назад писала такой перебор.
[54:54.680 --> 54:56.680]  Вот, он работает.
[54:58.680 --> 55:00.680]  И это будет как бы еще один
[55:00.680 --> 55:02.680]  бэкэнд для
[55:02.680 --> 55:04.680]  фреймворка
[55:04.680 --> 55:06.680]  Twist в идеале.
[55:08.680 --> 55:10.680]  Ну что, наверное, внушил
[55:10.680 --> 55:12.680]  у вас эту мысль.
[55:14.680 --> 55:16.680]  Понятно ли, зачем мы
[55:16.680 --> 55:18.680]  тестируем код по несколько раз, если
[55:18.680 --> 55:20.680]  запускаем те же тесты по несколько раз,
[55:20.680 --> 55:22.680]  и зачем мы пишем все вот эти странные
[55:22.680 --> 55:24.680]  штуки вместо STD?
[55:24.680 --> 55:26.680]  Должно быть понятно, где нужно их писать,
[55:26.680 --> 55:28.680]  где нет. Вот нам нужно подменять только
[55:28.680 --> 55:30.680]  примитивы синхронизации, где потоки общаются
[55:30.680 --> 55:32.680]  друг с другом, потому что вот в этих местах
[55:32.680 --> 55:34.680]  переключения дают какой-то эффект интересный.
[55:34.680 --> 55:36.680]  Во всех остальных местах нам этого не нужно.
[55:38.680 --> 55:40.680]  Ну и вот еще одно ограничение,
[55:40.680 --> 55:42.680]  которое из нашего фреймворка следует.
[55:44.680 --> 55:46.680]  Вы его видели уже в задаче
[55:46.680 --> 55:48.680]  RotRedPool, и давайте я просто
[55:48.680 --> 55:50.680]  в документации это еще раз покажу.
[55:52.680 --> 55:54.680]  Мы не можем использовать примитивы,
[55:54.680 --> 55:56.680]  которые как-то завязаны на триды.
[55:56.680 --> 55:58.680]  Вот мы не можем использовать
[55:58.680 --> 56:00.680]  ThreadAtomicMute и Second War,
[56:00.680 --> 56:02.680]  потому что для файберов должна быть
[56:02.680 --> 56:04.680]  своя реализация. А кроме того, мы
[56:04.680 --> 56:06.680]  еще лишаемся ThreadLocale.
[56:08.680 --> 56:10.680]  Вот мы его заменяем таким классом.
[56:10.680 --> 56:12.680]  Сильно не похоже на ThreadLocale
[56:12.680 --> 56:14.680]  ключевое слово,
[56:14.680 --> 56:16.680]  но с семантикой его остается
[56:16.680 --> 56:18.680]  такое же.
[56:20.680 --> 56:22.680]  Кстати, ThreadLocale вас не удивил, да?
[56:22.680 --> 56:24.680]  Ничего необычного.
[56:26.680 --> 56:28.680]  Немного необычного.
[56:28.680 --> 56:30.680]  Но это такой целый
[56:30.680 --> 56:32.680]  как бы класс переменных, у вас есть локальные
[56:32.680 --> 56:34.680]  переменные, которые у каждого потока свои,
[56:34.680 --> 56:36.680]  у вас есть глобальные переменные, которые у всех потоков общие.
[56:36.680 --> 56:38.680]  А у вас есть ThreadLocальные, которые с одной стороны
[56:38.680 --> 56:40.680]  глобальные и к ним можно обращаться всем.
[56:40.680 --> 56:42.680]  А с другой стороны, это вот
[56:42.680 --> 56:44.680]  логически одна переменная, у которой много значений
[56:44.680 --> 56:46.680]  у каждого потока свое.
[56:46.680 --> 56:48.680]  Вот это такое
[56:48.680 --> 56:50.680]  довольно уникальная штука,
[56:50.680 --> 56:54.680]  не выражающиеся через другие.
[56:58.680 --> 57:01.680]  Если вы пишете файберы, то вы, в принципе, могли бы прикинуть,
[57:01.680 --> 57:04.680]  как такая штука могла бы работать.
[57:06.680 --> 57:10.680]  Могли бы сами написать при желании.
[57:10.680 --> 57:13.680]  Можно так даже сделать.
[57:13.680 --> 57:16.680]  Когда-нибудь.
[57:16.680 --> 57:18.680]  Но правда, если вы пишете файберы сейчас в задачах,
[57:18.680 --> 57:22.680]  то вы способны придумать реализацию такого объекта.
[57:24.680 --> 57:27.680]  И вот так вы сможете понять, как именно он устроен.
[57:27.680 --> 57:30.680]  Самый честный способ.
[57:33.680 --> 57:37.680]  Ну что, если с фолтинжекшеном покончили,
[57:39.680 --> 57:43.680]  то давайте я расскажу про задачу Mutex.
[57:44.680 --> 57:47.680]  Я вам в чате писал, что вы можете пойти по ссылкам,
[57:47.680 --> 57:51.680]  открыть ссылку с каким-то кодом, переписать его,
[57:51.680 --> 57:54.680]  а я у вас в его сотрудно-защите.
[57:54.680 --> 57:57.680]  Я так даже у кого-то сделал в прошлый раз.
[57:57.680 --> 58:01.680]  Ну, я следую своим обещаниям, все нормально.
[58:01.680 --> 58:03.680]  Я так делал не потому, что я вредный,
[58:03.680 --> 58:05.680]  ну, то есть не только поэтому,
[58:05.680 --> 58:09.680]  а потому что этот код...
[58:09.680 --> 58:11.680]  Знания цены, когда вы сами к ним пришли,
[58:11.680 --> 58:13.680]  а вот просто какой-то готовый рецепт с интернета
[58:13.680 --> 58:15.680]  вас ничему не научит,
[58:15.680 --> 58:17.680]  вы его, возможно, не поймете.
[58:19.680 --> 58:21.680]  Тем не менее, это решение Mutex,
[58:21.680 --> 58:23.680]  которое получше, чем у вас,
[58:23.680 --> 58:25.680]  потому что, ну, что вы написали?
[58:25.680 --> 58:27.680]  Сначала вы пишете...
[58:27.680 --> 58:29.680]  А можно даже код показать, наверное, да?
[58:32.680 --> 58:34.680]  Задача...
[58:36.680 --> 58:38.680]  Mutex, Mutex.
[58:38.680 --> 58:40.680]  А тут решение написано уже.
[58:40.680 --> 58:42.680]  Вы с этого начинаете, да?
[58:42.680 --> 58:44.680]  Вот вы пишете сначала какой-то спинлог,
[58:44.680 --> 58:46.680]  потому что покрутиться вы засыпаете.
[58:46.680 --> 58:48.680]  А потом вам говорят в защите,
[58:48.680 --> 58:50.680]  или вы прошли внимательные условия,
[58:50.680 --> 58:52.680]  что не нужно звать wake1 каждый раз в анлоке,
[58:52.680 --> 58:54.680]  когда Mutex свободен.
[58:54.680 --> 58:56.680]  Поэтому вы добавляете сюда еще счетчик.
[58:56.680 --> 58:58.680]  И вот если счетчик больше нуря,
[58:58.680 --> 59:00.680]  то, значит, нужно позвать wake1,
[59:00.680 --> 59:02.680]  чтобы разбудить спящий поток.
[59:06.680 --> 59:08.680]  Вот решение, которое...
[59:10.680 --> 59:12.680]  Смотрите, это статью читать особо не нужно,
[59:12.680 --> 59:14.680]  потому что, во-первых,
[59:14.680 --> 59:16.680]  для того чтобы понять, что такое Mutex,
[59:16.680 --> 59:18.680]  лучше прочесть комментарий из ядра,
[59:18.680 --> 59:20.680]  а чтобы понять, что такое Mutex,
[59:20.680 --> 59:22.680]  лучше прочесть статью, откуда автор скопировал это решение,
[59:22.680 --> 59:24.680]  не понимая его,
[59:24.680 --> 59:26.680]  потому что он даже не исправил метатонлог,
[59:26.680 --> 59:28.680]  который можно было проще написать.
[59:28.680 --> 59:30.680]  А эта реализация, она из довольно старой статьи,
[59:30.680 --> 59:32.680]  одного из мейнтрейнеров ядра,
[59:32.680 --> 59:34.680]  в Linux,
[59:34.680 --> 59:36.680]  который называется Mutex и хитрые.
[59:36.680 --> 59:38.680]  И вот там он пытается убедить вас,
[59:38.680 --> 59:40.680]  что Mutex довольно сложные в обращении,
[59:40.680 --> 59:42.680]  и пишет там сначала простой Mutex,
[59:42.680 --> 59:44.680]  потом Mutex получше,
[59:44.680 --> 59:46.680]  а потом Mutex совсем получше.
[59:48.680 --> 59:50.680]  В статье была реализация
[59:50.680 --> 59:52.680]  вторая, получше.
[59:52.680 --> 59:54.680]  В чем ее цель?
[59:54.680 --> 59:56.680]  В том, чтобы
[59:56.680 --> 59:58.680]  немного сэкономить
[59:58.680 --> 01:00:00.680]  в ситуации, когда contention нет.
[01:00:00.680 --> 01:00:02.680]  То есть, у вас есть Mutex,
[01:00:02.680 --> 01:00:04.680]  за него никто не соревнуется,
[01:00:04.680 --> 01:00:06.680]  его захватывает только один поток,
[01:00:06.680 --> 01:00:08.680]  и захват должен происходить
[01:00:08.680 --> 01:00:10.680]  как можно быстрее.
[01:00:10.680 --> 01:00:12.680]  Вот в нашей реализации,
[01:00:12.680 --> 01:00:14.680]  на быстром пути,
[01:00:14.680 --> 01:00:16.680]  когда Mutex свободен,
[01:00:16.680 --> 01:00:18.680]  две атомарные операции.
[01:00:18.680 --> 01:00:20.680]  Increment счетчика и Exchange
[01:00:20.680 --> 01:00:22.680]  на флажке.
[01:00:22.680 --> 01:00:24.680]  Вот автор хочет добиться того,
[01:00:24.680 --> 01:00:26.680]  чтобы, когда Mutex свободен был,
[01:00:26.680 --> 01:00:28.680]  то его захват требовал бы
[01:00:28.680 --> 01:00:30.680]  одной атомарной операции.
[01:00:30.680 --> 01:00:32.680]  Для этого
[01:00:32.680 --> 01:00:34.680]  автор схлопывает
[01:00:34.680 --> 01:00:36.680]  флажок плюс счетчик
[01:00:36.680 --> 01:00:38.680]  в одну переменную
[01:00:38.680 --> 01:00:40.680]  с тремя состояниями.
[01:00:40.680 --> 01:00:42.680]  Ноль, один на два.
[01:00:42.680 --> 01:00:44.680]  Ноль.
[01:00:44.680 --> 01:00:46.680]  Lock свободен.
[01:00:46.680 --> 01:00:48.680]  Один. Lock захвачен. Mutex захвачен.
[01:00:48.680 --> 01:00:50.680]  И конкурентов нет.
[01:00:50.680 --> 01:00:52.680]  Два. Mutex захвачен.
[01:00:52.680 --> 01:00:54.680]  И при этом есть потоки, которые ждут освобождения.
[01:00:54.680 --> 01:00:56.680]  Тут очевидно,
[01:00:56.680 --> 01:00:58.680]  происходит какая-то потеря информации,
[01:00:58.680 --> 01:01:00.680]  потому что раньше мы знали количество,
[01:01:00.680 --> 01:01:02.680]  а теперь мы знаем, что больше нуля.
[01:01:02.680 --> 01:01:04.680]  И это некоторую сложность добавляет.
[01:01:04.680 --> 01:01:06.680]  Но на быстром пути
[01:01:06.680 --> 01:01:08.680]  вот такие три состояния
[01:01:08.680 --> 01:01:10.680]  позволяют нам сэкономить
[01:01:10.680 --> 01:01:12.680]  на операциях над атомиками.
[01:01:12.680 --> 01:01:14.680]  Каким образом?
[01:01:14.680 --> 01:01:16.680]  Вот поток приходит в лог
[01:01:16.680 --> 01:01:18.680]  и, смотрите, тут замечание
[01:01:18.680 --> 01:01:20.680]  техническое.
[01:01:20.680 --> 01:01:22.680]  Тут не атомарная операция,
[01:01:22.680 --> 01:01:24.680]  в смысле не SD-атомики, тут некоторые псевдокод.
[01:01:24.680 --> 01:01:26.680]  И вот atomic-dec, atomic-inc
[01:01:26.680 --> 01:01:28.680]  это fetch-add, fetch-sub.
[01:01:28.680 --> 01:01:30.680]  Fetch-sub, fetch-add.
[01:01:30.680 --> 01:01:32.680]  Compare-exchange
[01:01:32.680 --> 01:01:34.680]  вот такая штука,
[01:01:34.680 --> 01:01:36.680]  такая функция.
[01:01:36.680 --> 01:01:38.680]  Это как compare-exchange над атомиками,
[01:01:38.680 --> 01:01:40.680]  но немного по-другому.
[01:01:40.680 --> 01:01:42.680]  Потому что compare-exchange
[01:01:42.680 --> 01:01:44.680]  в атомиках возвращает вам true,
[01:01:44.680 --> 01:01:46.680]  если успех false, если не успех.
[01:01:46.680 --> 01:01:48.680]  А в этой реализации
[01:01:48.680 --> 01:01:50.680]  вам возвращают просто старое значение.
[01:01:50.680 --> 01:01:52.680]  Потому что вы сами разберетесь
[01:01:52.680 --> 01:01:54.680]  успех или неуспех.
[01:01:54.680 --> 01:01:56.680]  Если вам вернули ноль, значит успех,
[01:01:56.680 --> 01:01:58.680]  если вернули не ноль, значит не успех.
[01:01:58.680 --> 01:02:00.680]  Как устроен вызов лог?
[01:02:00.680 --> 01:02:02.680]  Мы говорим compare-exchange и пытаемся
[01:02:02.680 --> 01:02:04.680]  поменять состояние спинлока,
[01:02:04.680 --> 01:02:06.680]  состояние мютокса с 0 на 1.
[01:02:06.680 --> 01:02:08.680]  Если это получилось,
[01:02:08.680 --> 01:02:10.680]  то все, конец.
[01:02:10.680 --> 01:02:12.680]  Лог захвачен, можно идти дальше.
[01:02:12.680 --> 01:02:14.680]  Одна атомарная операция.
[01:02:14.680 --> 01:02:16.680]  Если же лог не захвачен,
[01:02:16.680 --> 01:02:18.680]  то,
[01:02:18.680 --> 01:02:20.680]  видимо, поток, который
[01:02:20.680 --> 01:02:22.680]  провалил этот касс, должен
[01:02:22.680 --> 01:02:24.680]  уснуть в ожидании, что лог
[01:02:24.680 --> 01:02:26.680]  освободят.
[01:02:26.680 --> 01:02:28.680]  Потому что у него есть фьютекс вейт.
[01:02:28.680 --> 01:02:30.680]  Но перед этим
[01:02:30.680 --> 01:02:32.680]  он должен переключить
[01:02:32.680 --> 01:02:34.680]  состояние мютокса из 1 в 2,
[01:02:34.680 --> 01:02:36.680]  чтобы поток, который
[01:02:36.680 --> 01:02:38.680]  освобождал мютокс потом,
[01:02:38.680 --> 01:02:40.680]  нас разбудил.
[01:02:40.680 --> 01:02:42.680]  Поэтому мы делаем compare-exchange
[01:02:42.680 --> 01:02:44.680]  мы перед фьютекс вейтом
[01:02:44.680 --> 01:02:46.680]  делаем compare-exchange
[01:02:46.680 --> 01:02:48.680]  из 1 в 2.
[01:02:48.680 --> 01:02:50.680]  Но либо не делаем, если мы видим,
[01:02:50.680 --> 01:02:52.680]  что там уже 2 было.
[01:02:52.680 --> 01:02:54.680]  Тогда просто засыпаем
[01:02:54.680 --> 01:02:56.680]  и ожидаем, что там 2.
[01:02:56.680 --> 01:02:58.680]  То есть мы спим на 2 только.
[01:02:58.680 --> 01:03:00.680]  Что мы делаем в анлоке?
[01:03:00.680 --> 01:03:02.680]  В анлоке написано какое-то дичное,
[01:03:02.680 --> 01:03:04.680]  мой вкус.
[01:03:04.680 --> 01:03:06.680]  Какова цель анлока?
[01:03:06.680 --> 01:03:08.680]  Сбросить состояние мютокса в ноль,
[01:03:08.680 --> 01:03:10.680]  во-первых.
[01:03:10.680 --> 01:03:12.680]  А во-вторых, если были
[01:03:12.680 --> 01:03:14.680]  ждущие потоки, то один из них разбудить.
[01:03:14.680 --> 01:03:16.680]  Автор делает очень странно.
[01:03:16.680 --> 01:03:18.680]  Он делает декремент
[01:03:18.680 --> 01:03:20.680]  атомарный.
[01:03:20.680 --> 01:03:22.680]  И если он получил...
[01:03:22.680 --> 01:03:24.680]  А что он может увидеть в декременте?
[01:03:24.680 --> 01:03:26.680]  Либо 1, либо 2.
[01:03:26.680 --> 01:03:28.680]  Если он увидел 2,
[01:03:28.680 --> 01:03:30.680]  то он делает
[01:03:30.680 --> 01:03:32.680]  фьютекс вейк.
[01:03:32.680 --> 01:03:34.680]  Если он увидел 1, то он уменьшил
[01:03:34.680 --> 01:03:36.680]  из 0 из 1 в 0,
[01:03:36.680 --> 01:03:38.680]  то он ничего не делает.
[01:03:38.680 --> 01:03:40.680]  Потому что вот всё.
[01:03:42.680 --> 01:03:44.680]  Я тоже спрашиваю себя
[01:03:44.680 --> 01:03:46.680]  и не нахожу ответа.
[01:03:46.680 --> 01:03:48.680]  Конечно же, то, что он хочет сделать,
[01:03:48.680 --> 01:03:50.680]  описывается так.
[01:03:50.680 --> 01:03:52.680]  И если эксчейнч 0 равен 2,
[01:03:52.680 --> 01:03:54.680]  то фьютекс вейк.
[01:03:54.680 --> 01:03:56.680]  Это гораздо проще,
[01:03:56.680 --> 01:03:58.680]  потому что между этой строчкой и этой
[01:03:58.680 --> 01:04:00.680]  может много чего произойти сложного.
[01:04:00.680 --> 01:04:02.680]  А в эксчейнче уже не может.
[01:04:02.680 --> 01:04:04.680]  Да, этот код нужно стереть
[01:04:04.680 --> 01:04:06.680]  и написать здесь
[01:04:06.680 --> 01:04:08.680]  если эксчейнч 0 равен 2,
[01:04:08.680 --> 01:04:10.680]  то фьютекс вейк.
[01:04:10.680 --> 01:04:12.680]  Это код здорового человека.
[01:04:12.680 --> 01:04:14.680]  Ты просто доверяешь коду из интернета.
[01:04:14.680 --> 01:04:16.680]  Ты для этого и учишься,
[01:04:16.680 --> 01:04:18.680]  чтобы не доверять коду из интернета.
[01:04:18.680 --> 01:04:20.680]  В интернет может написать любой человек.
[01:04:20.680 --> 01:04:22.680]  Понимаешь? Никто его не остановит.
[01:04:22.680 --> 01:04:24.680]  Он завел себе блог и пишет в интернет.
[01:04:24.680 --> 01:04:26.680]  Поэтому ты должна очень аккуратно
[01:04:26.680 --> 01:04:28.680]  фильтровать то, что ты читаешь.
[01:04:28.680 --> 01:04:30.680]  Даже если пишут очень умные, казалось бы,
[01:04:30.680 --> 01:04:32.680]  люди. У него была какая-то причина
[01:04:32.680 --> 01:04:34.680]  так написать, наверное, но
[01:04:34.680 --> 01:04:36.680]  это не может быть.
[01:04:36.680 --> 01:04:38.680]  Это не может быть.
[01:04:38.680 --> 01:04:40.680]  Это не может быть.
[01:04:40.680 --> 01:04:42.680]  У него была какая-то причина так написать,
[01:04:42.680 --> 01:04:44.680]  наверное, но
[01:04:44.680 --> 01:04:46.680]  здравый смысл подсказывает,
[01:04:46.680 --> 01:04:48.680]  что нет.
[01:04:48.680 --> 01:04:50.680]  Но сложность не в этом.
[01:04:50.680 --> 01:04:52.680]  Сложность здесь.
[01:04:52.680 --> 01:04:54.680]  Если нас разбудили,
[01:04:54.680 --> 01:04:56.680]  то мы хотим захватить
[01:04:56.680 --> 01:04:58.680]  мьютекс.
[01:04:58.680 --> 01:05:00.680]  И кажется, что мы хотим.
[01:05:00.680 --> 01:05:02.680]  Если лог свободен,
[01:05:02.680 --> 01:05:04.680]  то перевести его в один занят.
[01:05:04.680 --> 01:05:06.680]  А если лог занят,
[01:05:06.680 --> 01:05:08.680]  то перевести в двойку и заснуть.
[01:05:08.680 --> 01:05:10.680]  Но поток действует уже не так.
[01:05:10.680 --> 01:05:12.680]  Если он проснулся
[01:05:12.680 --> 01:05:14.680]  после фьютексвейта,
[01:05:14.680 --> 01:05:16.680]  то после этого он
[01:05:16.680 --> 01:05:18.680]  пытается захватить лог
[01:05:18.680 --> 01:05:20.680]  сразу, переводя его в двойку.
[01:05:20.680 --> 01:05:22.680]  Он не пытается
[01:05:22.680 --> 01:05:24.680]  сделать перевод в один.
[01:05:24.680 --> 01:05:26.680]  Если вы напишете здесь один, то код сломается.
[01:05:26.680 --> 01:05:28.680]  Но если вы любопытны,
[01:05:28.680 --> 01:05:30.680]  то если вы писали такой код,
[01:05:30.680 --> 01:05:32.680]  то замените здесь 2 на 1
[01:05:32.680 --> 01:05:34.680]  и код повиснет.
[01:05:34.680 --> 01:05:36.680]  И вот здесь
[01:05:36.680 --> 01:05:38.680]  вся сложность задачи кроется.
[01:05:38.680 --> 01:05:40.680]  Потому что смотрите, какая история.
[01:05:40.680 --> 01:05:42.680]  Вот было у вас
[01:05:42.680 --> 01:05:44.680]  три потока.
[01:05:44.680 --> 01:05:46.680]  Пришел первый поток,
[01:05:46.680 --> 01:05:48.680]  перевел лог из нуля в один,
[01:05:48.680 --> 01:05:50.680]  прошел в критическую секцию.
[01:05:50.680 --> 01:05:52.680]  Пришел второй поток,
[01:05:52.680 --> 01:05:54.680]  он этот каст провалил,
[01:05:54.680 --> 01:05:56.680]  сделал этот каст,
[01:05:56.680 --> 01:05:58.680]  перевел лог в двойку и уснул.
[01:05:58.680 --> 01:06:00.680]  Потом пришел третий поток,
[01:06:00.680 --> 01:06:02.680]  провалил этот компер-эксчейнч,
[01:06:02.680 --> 01:06:04.680]  увидел двойку и сразу уснул.
[01:06:04.680 --> 01:06:06.680]  И вот состояние лока 2,
[01:06:06.680 --> 01:06:08.680]  два потока спят,
[01:06:08.680 --> 01:06:10.680]  или там три потока спят,
[01:06:10.680 --> 01:06:12.680]  неважно.
[01:06:12.680 --> 01:06:14.680]  Один поток в секции.
[01:06:14.680 --> 01:06:16.680]  Пока все, как мы ожидали.
[01:06:16.680 --> 01:06:18.680]  Когда начнутся не тривиальные вещи.
[01:06:18.680 --> 01:06:20.680]  Предположим, первый поток, который
[01:06:20.680 --> 01:06:22.680]  захватил мютекс,
[01:06:22.680 --> 01:06:24.680]  делает анлог.
[01:06:24.680 --> 01:06:26.680]  И чем он занимается?
[01:06:26.680 --> 01:06:28.680]  Он
[01:06:28.680 --> 01:06:30.680]  сбрасывает
[01:06:30.680 --> 01:06:32.680]  двойку в ноль.
[01:06:32.680 --> 01:06:34.680]  И поскольку там
[01:06:34.680 --> 01:06:36.680]  была двойка, он будет
[01:06:36.680 --> 01:06:38.680]  одного из спящих.
[01:06:38.680 --> 01:06:40.680]  Пока все идет нормально.
[01:06:40.680 --> 01:06:42.680]  А теперь представим, что
[01:06:42.680 --> 01:06:44.680]  у нас было три спящих потока,
[01:06:44.680 --> 01:06:46.680]  и один из них проснулся,
[01:06:46.680 --> 01:06:48.680]  увидел в спинлоке ноль,
[01:06:48.680 --> 01:06:50.680]  увидел в ячейке ноль,
[01:06:50.680 --> 01:06:52.680]  и захватил ее в единицу.
[01:06:52.680 --> 01:06:54.680]  Все, беда,
[01:06:54.680 --> 01:06:56.680]  потому что после этого он отпустит лог
[01:06:56.680 --> 01:06:58.680]  и никого не разбудит.
[01:06:58.680 --> 01:07:00.680]  А два потока так останутся спать.
[01:07:00.680 --> 01:07:02.680]  В чем идея?
[01:07:02.680 --> 01:07:04.680]  В том, что мы теряем информацию.
[01:07:04.680 --> 01:07:06.680]  У нас раньше был счетчик,
[01:07:06.680 --> 01:07:08.680]  а теперь у нас просто двойка.
[01:07:08.680 --> 01:07:10.680]  За этой двойкой скрывается
[01:07:10.680 --> 01:07:12.680]  предвольное количество ждущих потоков.
[01:07:12.680 --> 01:07:14.680]  И мы в анлог ее сбрасываем всегда.
[01:07:16.680 --> 01:07:18.680]  Вот мы теряем эту двойку.
[01:07:18.680 --> 01:07:20.680]  Но
[01:07:20.680 --> 01:07:22.680]  если поток уснул
[01:07:22.680 --> 01:07:24.680]  вот здесь вот,
[01:07:24.680 --> 01:07:26.680]  то о чем
[01:07:26.680 --> 01:07:28.680]  это говорить?
[01:07:28.680 --> 01:07:30.680]  Он стал
[01:07:30.680 --> 01:07:32.680]  свидетелем двойки.
[01:07:32.680 --> 01:07:34.680]  Вот он либо сам туда ее написал,
[01:07:34.680 --> 01:07:36.680]  либо прочитал.
[01:07:36.680 --> 01:07:38.680]  Это означает, что есть группа потоков,
[01:07:38.680 --> 01:07:40.680]  которая ждет мютокса.
[01:07:40.680 --> 01:07:42.680]  И нужно как-то гарантировать,
[01:07:42.680 --> 01:07:44.680]  что каждый из этих потоков проснется.
[01:07:46.680 --> 01:07:48.680]  Поэтому он поступает
[01:07:48.680 --> 01:07:50.680]  консервативно. Он не знает,
[01:07:50.680 --> 01:07:52.680]  если другие ждущие, кроме него,
[01:07:52.680 --> 01:07:54.680]  сколько их там будет.
[01:07:54.680 --> 01:07:56.680]  Поэтому он
[01:07:56.680 --> 01:07:58.680]  двойку дальше сохраняет, поддерживает.
[01:08:00.680 --> 01:08:02.680]  То есть он, просыпаясь,
[01:08:02.680 --> 01:08:04.680]  захватывает лог с двойкой,
[01:08:04.680 --> 01:08:06.680]  чтобы после выхода в анлоге
[01:08:06.680 --> 01:08:08.680]  другой поток,
[01:08:08.680 --> 01:08:10.680]  который потенциально был с ним в группе
[01:08:10.680 --> 01:08:12.680]  ожиданий, разбудить.
[01:08:14.680 --> 01:08:16.680]  Понятная идея.
[01:08:16.680 --> 01:08:18.680]  То есть они друг про друга не знают,
[01:08:18.680 --> 01:08:20.680]  но поскольку их может быть больше,
[01:08:20.680 --> 01:08:22.680]  чем один, то они помогают друг другу
[01:08:22.680 --> 01:08:24.680]  таким образом.
[01:08:24.680 --> 01:08:26.680]  Вся сложность это реализации
[01:08:26.680 --> 01:08:28.680]  в таком сценарии.
[01:08:28.680 --> 01:08:30.680]  И с кода это, конечно, плохо читается.
[01:08:38.680 --> 01:08:40.680]  Что скажете?
[01:08:42.680 --> 01:08:44.680]  Понятно или нет?
[01:08:44.680 --> 01:08:46.680]  Почему здесь именно двойка?
[01:08:48.680 --> 01:08:50.680]  Мы оказались в группе ждущих потоков,
[01:08:50.680 --> 01:08:52.680]  мы не знаем, сколько нас всего,
[01:08:52.680 --> 01:08:54.680]  мы не считаем это число,
[01:08:54.680 --> 01:08:56.680]  поэтому мы просто говорим,
[01:08:56.680 --> 01:08:58.680]  что каждый поток, который проснулся
[01:08:58.680 --> 01:09:00.680]  из этой группы, разбудит еще один поток.
[01:09:00.680 --> 01:09:02.680]  Этот поток есть или нет,
[01:09:02.680 --> 01:09:04.680]  мы не знаем.
[01:09:04.680 --> 01:09:06.680]  То есть если, скажем, у нас было два потока,
[01:09:06.680 --> 01:09:08.680]  один проснул, а другой прошел,
[01:09:08.680 --> 01:09:10.680]  то проснувшийся
[01:09:10.680 --> 01:09:12.680]  поток, который проснулся,
[01:09:12.680 --> 01:09:14.680]  сделает лишний вейк,
[01:09:14.680 --> 01:09:16.680]  потому что он не знает, что больше никого нет.
[01:09:16.680 --> 01:09:18.680]  Но если бы у кого-то был,
[01:09:18.680 --> 01:09:20.680]  то этот другой бы проснулся.
[01:09:22.680 --> 01:09:24.680]  Вот такие пироги.
[01:09:26.680 --> 01:09:28.680]  Понятно.
[01:09:30.680 --> 01:09:32.680]  Смотрите, что может быть.
[01:09:32.680 --> 01:09:34.680]  Мютекс был захвачен,
[01:09:34.680 --> 01:09:36.680]  два потока спали,
[01:09:36.680 --> 01:09:38.680]  потом мы в анлоке один поток разбудили,
[01:09:38.680 --> 01:09:40.680]  сбросили в ноль,
[01:09:40.680 --> 01:09:42.680]  а перед тем, как он проснулся,
[01:09:42.680 --> 01:09:44.680]  вклинился другой поток,
[01:09:44.680 --> 01:09:46.680]  он увидел ноль при входе, записал единицу,
[01:09:46.680 --> 01:09:48.680]  на выходе никого не разбудил.
[01:09:48.680 --> 01:09:50.680]  Но тот поток, который проснулся раньше,
[01:09:50.680 --> 01:09:52.680]  после этого запишет.
[01:09:52.680 --> 01:09:54.680]  Вот эти двойки хитро потом проявляются,
[01:09:54.680 --> 01:09:56.680]  и вейки зовутся.
[01:09:58.680 --> 01:10:00.680]  Мы гарантируем такой вариант,
[01:10:00.680 --> 01:10:02.680]  что на каждый вейд в будущем
[01:10:02.680 --> 01:10:04.680]  будет вызван вейк.
[01:10:04.680 --> 01:10:06.680]  Все. Зачем я все это рассказывал,
[01:10:06.680 --> 01:10:08.680]  когда можно было так сказать?
[01:10:08.680 --> 01:10:10.680]  Блестящее объяснение.
[01:10:10.680 --> 01:10:12.680]  Вот, да, этим все объясняется.
[01:10:12.680 --> 01:10:14.680]  На каждый вейд мы просто вызываем в будущем вейк.
[01:10:16.680 --> 01:10:18.680]  Так что дедлога быть не может.
[01:10:20.680 --> 01:10:22.680]  Пожалуйста, производите.
[01:10:22.680 --> 01:10:25.680]  Просто что небольшой крайний вейд в будущем
[01:10:25.680 --> 01:10:27.680]  сможет...
[01:10:27.680 --> 01:10:29.680]  Ну, два тамарных...
[01:10:29.680 --> 01:10:31.680]  Две тамарных операции против одной тамарной операции.
[01:10:31.680 --> 01:10:33.680]  Ну, при этом мы в...
[01:10:33.680 --> 01:10:36.680]  На логии, по поводу личного вращения в твоего,
[01:10:36.680 --> 01:10:38.680]  как бы...
[01:10:38.680 --> 01:10:40.680]  Еще раз, мы оптимизируем сценарий,
[01:10:40.680 --> 01:10:42.680]  где контеншн нет,
[01:10:42.680 --> 01:10:44.680]  где лог берут не очень часто.
[01:10:44.680 --> 01:10:46.680]  А, ну, все хорошо.
[01:10:46.680 --> 01:10:48.680]  Вот. А когда контеншн есть,
[01:10:48.680 --> 01:10:50.680]  то эта реализация работает
[01:10:50.680 --> 01:10:52.680]  одинаково плохо...
[01:10:52.680 --> 01:10:54.680]  Ну, в смысле, одинаково с твоей реализацией.
[01:10:54.680 --> 01:10:56.680]  То есть она деградирует до твоей,
[01:10:56.680 --> 01:10:58.680]  но в некотором случае она работает быстрее.
[01:10:58.680 --> 01:11:00.680]  Но в некоторых разумных сценариях она работает быстрее.
[01:11:00.680 --> 01:11:02.680]  Вот.
[01:11:02.680 --> 01:11:04.680]  А поскольку мьютекс — это такая универсальная штука,
[01:11:04.680 --> 01:11:06.680]  то лучше один раз постараться
[01:11:06.680 --> 01:11:08.680]  сделать ее максимально...
[01:11:08.680 --> 01:11:10.680]  максимально эффективной.
[01:11:12.680 --> 01:11:14.680]  Вот тут один человек постарался
[01:11:14.680 --> 01:11:16.680]  на всю жизнь для всех,
[01:11:16.680 --> 01:11:18.680]  но это разумно в таких местах.
[01:11:24.680 --> 01:11:26.680]  Ну что, у нас закончилось время,
[01:11:26.680 --> 01:11:28.680]  наверное, да, Ирия?
[01:11:28.680 --> 01:11:30.680]  Пятьнадцать минут еще?
[01:11:30.680 --> 01:11:32.680]  Не может быть.
[01:11:32.680 --> 01:11:34.680]  Подождем.
[01:11:36.680 --> 01:11:38.680]  Сколько проспецов осталось,
[01:11:38.680 --> 01:11:40.680]  объясните мне?
[01:11:40.680 --> 01:11:42.680]  Три минуты.
[01:11:42.680 --> 01:11:44.680]  Не пятнадцать.
[01:11:44.680 --> 01:11:46.680]  Я просто ничего нового не начну,
[01:11:46.680 --> 01:11:48.680]  я могу на какие-то вопросы,
[01:11:48.680 --> 01:11:50.680]  может быть, ответить еще,
[01:11:50.680 --> 01:11:52.680]  если они вот возникли по пути или...
[01:11:52.680 --> 01:11:54.680]  Просто не знаю, что можно было
[01:11:54.680 --> 01:11:56.680]  за три минуты вернуть такого.
[01:12:00.680 --> 01:12:02.680]  Есть у вас идеи?
[01:12:06.680 --> 01:12:08.680]  Ну ладно, тогда на сегодня все.
[01:12:08.680 --> 01:12:10.680]  Спасибо.
[01:12:10.680 --> 01:12:12.680]  Хорошо.
[01:12:30.680 --> 01:12:32.680]  Послушайте, там не сложно.
[01:12:34.680 --> 01:12:36.680]  Что человек делает?
[01:12:36.680 --> 01:12:38.680]  Рассуждения простые.
[01:12:38.680 --> 01:12:40.680]  Это решение с флажком и счетчиком.
[01:12:40.680 --> 01:12:42.680]  Оно практически неизбежно.
[01:12:42.680 --> 01:12:44.680]  Если ты решила оптимизировать
[01:12:44.680 --> 01:12:46.680]  быстрый случай, когда контеншина нет,
[01:12:46.680 --> 01:12:48.680]  то у тебя такое решение рождается
[01:12:48.680 --> 01:12:50.680]  просто на автомате.
[01:12:50.680 --> 01:12:52.680]  А дальше ты на него смотришь и думаешь,
[01:12:52.680 --> 01:12:54.680]  ага, я хочу один атомик,
[01:12:54.680 --> 01:12:56.680]  но одну атомарную операцию вместо двух.
[01:12:56.680 --> 01:12:58.680]  Видимо, я хочу склеить
[01:12:58.680 --> 01:13:00.680]  флажок и счетчик.
[01:13:04.680 --> 01:13:06.680]  И тут-то можно было бы склеить
[01:13:06.680 --> 01:13:08.680]  флажок и счетчик, если ты умная.
[01:13:12.680 --> 01:13:14.680]  А мы это не разобрали.
[01:13:14.680 --> 01:13:16.680]  Вот на что можно было
[01:13:16.680 --> 01:13:18.680]  потратить три минуты.
[01:13:18.680 --> 01:13:20.680]  А почему экономия
[01:13:20.680 --> 01:13:22.680]  атомарной операции
[01:13:22.680 --> 01:13:24.680]  дает такую большую оптимизацию?
[01:13:24.680 --> 01:13:26.680]  Дело не в том, что она дает
[01:13:26.680 --> 01:13:28.680]  очень большую оптимизацию,
[01:13:28.680 --> 01:13:30.680]  а в том, что
[01:13:30.680 --> 01:13:32.680]  доля
[01:13:36.680 --> 01:13:38.680]  время, которое ты потратишь на лишнюю оптимизацию
[01:13:38.680 --> 01:13:40.680]  в Mutex, в твоей программе может быть очень
[01:13:40.680 --> 01:13:42.680]  ничтожным.
[01:13:42.680 --> 01:13:44.680]  Но с точки зрения Mutex это ускорение в два раза.
[01:13:46.680 --> 01:13:48.680]  Короче, разные ситуации бывают.
[01:13:48.680 --> 01:13:50.680]  Вот скажем, если ты придешь
[01:13:50.680 --> 01:13:52.680]  к МС Яндекс и сэкономишь там себе
[01:13:52.680 --> 01:13:54.680]  какую-нибудь
[01:13:54.680 --> 01:13:56.680]  одну десятую процента производительности,
[01:13:56.680 --> 01:13:58.680]  то ты сэкономишь себе
[01:13:58.680 --> 01:14:00.680]  ну, ты очень много денег сэкономишь,
[01:14:00.680 --> 01:14:02.680]  потому что одна десятая производительность
[01:14:02.680 --> 01:14:04.680]  процента — это огромное количество машин
[01:14:04.680 --> 01:14:06.680]  или сотни, которые стоят
[01:14:06.680 --> 01:14:08.680]  многие-многие тысячи долларов.
[01:14:08.680 --> 01:14:10.680]  Поэтому, если ты можешь в одном месте что-то ускорить в два раза,
[01:14:10.680 --> 01:14:12.680]  то почему бы это не сделать?
[01:14:12.680 --> 01:14:14.680]  Выиграть от этой программы или нет
[01:14:14.680 --> 01:14:16.680]  в какой-то степени — это уже второстепенный вопрос.
[01:14:16.680 --> 01:14:18.680]  Просто компонент настолько базовый,
[01:14:18.680 --> 01:14:20.680]  что он должен работать быстро.
[01:14:20.680 --> 01:14:22.680]  Да, он...
[01:14:22.680 --> 01:14:24.680]  То есть ты же не пишешь
[01:14:24.680 --> 01:14:26.680]  какую-то библиотепу, которую там будет использовать
[01:14:26.680 --> 01:14:28.680]  в твоем проекте только. Ты пишешь Mutex,
[01:14:28.680 --> 01:14:30.680]  который для всего кодовного и поточного в мире,
[01:14:30.680 --> 01:14:32.680]  поэтому разумно в него вложиться
[01:14:32.680 --> 01:14:34.680]  очень хорошо.
[01:14:34.680 --> 01:14:36.680]  Может быть, на тебе это не сильно повлияет,
[01:14:36.680 --> 01:14:38.680]  но
[01:14:38.680 --> 01:14:40.680]  ты же...
[01:14:40.680 --> 01:14:42.680]  Тут смотри, overhead,
[01:14:42.680 --> 01:14:44.680]  ты обмениваешь
[01:14:44.680 --> 01:14:46.680]  когнитивный overhead
[01:14:46.680 --> 01:14:48.680]  на...
[01:14:48.680 --> 01:14:50.680]  Что ты на что меняешь?
[01:14:50.680 --> 01:14:52.680]  У тебя может быть когнитивная сложность
[01:14:52.680 --> 01:14:54.680]  в смысле overhead реализации
[01:14:54.680 --> 01:14:56.680]  во времени работы.
[01:14:56.680 --> 01:14:58.680]  И ты говоришь, я готов в одном месте потратить
[01:14:58.680 --> 01:15:00.680]  больше мозгов одного человека,
[01:15:00.680 --> 01:15:02.680]  а я могу экономить процессорное время
[01:15:02.680 --> 01:15:04.680]  очень многих.
[01:15:04.680 --> 01:15:06.680]  Вот если ты пишешь код
[01:15:06.680 --> 01:15:08.680]  на работе в рамках проекта,
[01:15:08.680 --> 01:15:10.680]  на котором работает 10 человек,
[01:15:10.680 --> 01:15:12.680]  то разумно экономить именно когнитивный overhead
[01:15:12.680 --> 01:15:14.680]  читателя твоих коллег,
[01:15:14.680 --> 01:15:16.680]  а не ускорить кто-то в десять раз
[01:15:16.680 --> 01:15:18.680]  и делать код нечитаемым.
[01:15:18.680 --> 01:15:20.680]  Тут какой-то разумный тридог нужно искать.
[01:15:22.680 --> 01:15:24.680]  Да.
[01:15:24.680 --> 01:15:26.680]  Спасибо.
[01:15:26.680 --> 01:15:28.680]  Там же используется...
[01:15:28.680 --> 01:15:30.680]  Там используется атомик.
[01:15:30.680 --> 01:15:32.680]  У него не три возможности значения,
[01:15:32.680 --> 01:15:34.680]  а больше. Почему не всем со сдвигом?
[01:15:34.680 --> 01:15:36.680]  Да. Да.
[01:15:36.680 --> 01:15:38.680]  Именно про это я не рассказал.
[01:15:38.680 --> 01:15:40.680]  Ты можешь написать со сдвигом.
[01:15:40.680 --> 01:15:42.680]  Это гораздо проще.
[01:15:42.680 --> 01:15:44.680]  То есть ты можешь склеить...
[01:15:44.680 --> 01:15:46.680]  Это был второй вопрос,
[01:15:46.680 --> 01:15:48.680]  кроме эксчейнджа, с которым я сидела
[01:15:48.680 --> 01:15:50.680]  над этой статьей. Я просто
[01:15:50.680 --> 01:15:52.680]  смотрю и не понимаю.
[01:15:52.680 --> 01:15:54.680]  Да.
[01:15:54.680 --> 01:15:56.680]  Ну вот.
[01:15:56.680 --> 01:15:58.680]  А напиши в чат, что
[01:15:58.680 --> 01:16:00.680]  можно же просто с эксчейнджем сделать,
[01:16:00.680 --> 01:16:02.680]  со сдвигом сделать. Так и напиши.
[01:16:02.680 --> 01:16:04.680]  Мне кажется,
[01:16:04.680 --> 01:16:06.680]  что никто никогда такой код не пишет.
[01:16:06.680 --> 01:16:08.680]  Почему-то.
[01:16:08.680 --> 01:16:10.680]  Ну да, ты делаешь...
[01:16:10.680 --> 01:16:12.680]  Я не пишу, потому что я думаю, что его написал человек
[01:16:12.680 --> 01:16:14.680]  не меня, если бы просто и всего прав.
[01:16:14.680 --> 01:16:16.680]  Ну, у него были причины некоторые такой код
[01:16:16.680 --> 01:16:18.680]  писать? Не знаю.
[01:16:18.680 --> 01:16:20.680]  В общем, в этом кондваре, который...
[01:16:20.680 --> 01:16:22.680]  Смотри, давайте сразу покажу.
[01:16:22.680 --> 01:16:24.680]  В этом кондваре такой трюк используется
[01:16:24.680 --> 01:16:26.680]  очень часто. Кондвар вейт,
[01:16:26.680 --> 01:16:28.680]  битред кондвейт
[01:16:28.680 --> 01:16:30.680]  с этого начинается. Мы добавляем двойку,
[01:16:30.680 --> 01:16:32.680]  потому что в младшем битике что-то написано.
[01:16:32.680 --> 01:16:34.680]  Да, я читала.
[01:16:34.680 --> 01:16:36.680]  А, ну вот ты там подсмотрела эту идею, да?
[01:16:36.680 --> 01:16:38.680]  Нет. Сама придумала? Нет, я не понимала.
[01:16:38.680 --> 01:16:40.680]  Ну,
[01:16:40.680 --> 01:16:42.680]  чтобы
[01:16:42.680 --> 01:16:44.680]  этот код понять, нужно...
[01:16:44.680 --> 01:16:46.680]  Я сначала объясню, когда этот код читать, потом мы
[01:16:46.680 --> 01:16:48.680]  его почитаем по мере возможностей. А может быть, не будем даже
[01:16:48.680 --> 01:16:50.680]  если время пока нет.
[01:16:50.680 --> 01:16:52.680]  Но идея общая, ты можешь
[01:16:52.680 --> 01:16:54.680]  написать, да, ты в локе
[01:16:54.680 --> 01:16:56.680]  ты делаешь, что...
[01:16:58.680 --> 01:17:00.680]  или нет.
[01:17:00.680 --> 01:17:02.680]  Так не можешь там сделать.
[01:17:04.680 --> 01:17:06.680]  Ну, ты можешь консервативно добавлять
[01:17:08.680 --> 01:17:10.680]  переворачивать...
[01:17:12.680 --> 01:17:14.680]  Что хочешь сделать в локе, если ты мержишь счетчик
[01:17:14.680 --> 01:17:16.680]  и
[01:17:16.680 --> 01:17:18.680]  счетчик и флажок? Ты
[01:17:18.680 --> 01:17:20.680]  пытаешься переключить сначала из 0 в 1?
[01:17:20.680 --> 01:17:22.680]  Нет, ты должна делать фетчат какой-то, да?
[01:17:22.680 --> 01:17:24.680]  Да.
[01:17:24.680 --> 01:17:26.680]  Ты делаешь фетч...
[01:17:26.680 --> 01:17:28.680]  Нет, подожди, что ты делаешь в локе?
[01:17:28.680 --> 01:17:30.680]  Как ты хочешь одной этамарной операции?
[01:17:32.680 --> 01:17:34.680]  Ну, там будет цикл,
[01:17:34.680 --> 01:17:36.680]  ты прочтешь...
[01:17:36.680 --> 01:17:38.680]  Заифать как-то двое?
[01:17:38.680 --> 01:17:40.680]  Нет, там не ифа нужно писать, там нужно while писать.
[01:17:40.680 --> 01:17:42.680]  Ты пишешь while, читаешь значение атомика
[01:17:42.680 --> 01:17:44.680]  и если там
[01:17:44.680 --> 01:17:46.680]  если старший, младший битик в енице,
[01:17:46.680 --> 01:17:48.680]  то ты делаешь плюс два. Ты делаешь
[01:17:48.680 --> 01:17:50.680]  camperexchange плюс два. Там аккуратно
[01:17:50.680 --> 01:17:52.680]  нужно.
[01:17:52.680 --> 01:17:54.680]  А если там младший бит ноль,
[01:17:54.680 --> 01:17:56.680]  ты делаешь camperexchange, переворачиваешь
[01:17:56.680 --> 01:17:58.680]  фечку 41, делаешь.
[01:17:58.680 --> 01:18:00.680]  Это делать нужно в цикле, потому что
[01:18:00.680 --> 01:18:02.680]  ты не можешь гарантировать, что...
[01:18:02.680 --> 01:18:04.680]  Ты не можешь заранее сделать или то, или то.
[01:18:04.680 --> 01:18:06.680]  Тебе нужно сначала посмотреть, что там лежит, а потом
[01:18:06.680 --> 01:18:08.680]  сделать. Но между тем,
[01:18:08.680 --> 01:18:10.680]  ты посмотришь и сделаешь, может все измениться,
[01:18:10.680 --> 01:18:12.680]  поэтому тебе нужен цикл с кассом.
[01:18:12.680 --> 01:18:14.680]  Но на быстром пути, когда...
[01:18:14.680 --> 01:18:16.680]  И ты уже поиграла, потому что
[01:18:16.680 --> 01:18:18.680]  ты сделал сначала чтение, а потом
[01:18:18.680 --> 01:18:20.680]  camperexchange.
[01:18:20.680 --> 01:18:22.680]  Чтение оно дешевле
[01:18:22.680 --> 01:18:24.680]  все равно будет, чем...
[01:18:24.680 --> 01:18:26.680]  Вилот, я думаю, что он все уничтожит.
[01:18:26.680 --> 01:18:28.680]  Нет, вилот нормально,
[01:18:28.680 --> 01:18:30.680]  но любой лукфри, это лукфри
[01:18:30.680 --> 01:18:32.680]  решение, оно так и пишется.
[01:18:32.680 --> 01:18:34.680]  Но вот в этом коде
[01:18:34.680 --> 01:18:36.680]  я не знаю,
[01:18:36.680 --> 01:18:38.680]  что...
[01:18:38.680 --> 01:18:40.680]  В этом коде этого
[01:18:40.680 --> 01:18:42.680]  оверхеда на быстром пути нет,
[01:18:42.680 --> 01:18:44.680]  но есть вот лишний
[01:18:44.680 --> 01:18:46.680]  лишний вейк.
[01:18:46.680 --> 01:18:48.680]  На каждую группу потоков, которые
[01:18:48.680 --> 01:18:50.680]  ждут, лишний вейк делается.
[01:18:50.680 --> 01:18:52.680]  Вот если у тебя Newton все время загружен,
[01:18:52.680 --> 01:18:54.680]  то лишних вейков не бывает, потому что все
[01:18:54.680 --> 01:18:56.680]  полезные. А если
[01:18:56.680 --> 01:18:58.680]  лук вообще все время пустой стоит, то тоже
[01:18:58.680 --> 01:19:00.680]  лишних вейков не бывает.
[01:19:00.680 --> 01:19:02.680]  Так что эта реализация
[01:19:02.680 --> 01:19:04.680]  получается...
[01:19:04.680 --> 01:19:06.680]  Я бы сказал, что она
[01:19:06.680 --> 01:19:08.680]  все-таки лучше,
[01:19:08.680 --> 01:19:10.680]  чем идея с упаковкой счетчика.
[01:19:14.680 --> 01:19:16.680]  Да, но почти ничего. Тебе все равно нужно делать
[01:19:16.680 --> 01:19:18.680]  чтение. Вот если придумать реализацию,
[01:19:18.680 --> 01:19:20.680]  где ты делаешь одну атомарную операцию
[01:19:20.680 --> 01:19:22.680]  с этим счетчиком плюс битиком,
[01:19:22.680 --> 01:19:24.680]  а точно нельзя? Наверное, можно.
[01:19:24.680 --> 01:19:26.680]  Если у тебя битик стоит
[01:19:26.680 --> 01:19:28.680]  младший, ты должна сделать...
[01:19:28.680 --> 01:19:30.680]  Ты должна быть счетчик,
[01:19:30.680 --> 01:19:32.680]  а бит оставить, да?
[01:19:34.680 --> 01:19:36.680]  Нужно подумать.
[01:19:36.680 --> 01:19:38.680]  Мне кажется, что это делается.
[01:19:38.680 --> 01:19:40.680]  Ты можешь сделать за одну операцию или то, или другое.
[01:19:40.680 --> 01:19:42.680]  Или младший бит в ноль.
[01:19:42.680 --> 01:19:44.680]  Я думаю, что чтение должно делать.
[01:19:44.680 --> 01:19:46.680]  Почему эксчейнч?
[01:19:46.680 --> 01:19:48.680]  Эксчейнч точно не подойдет,
[01:19:48.680 --> 01:19:50.680]  потому что тебе нужно
[01:19:50.680 --> 01:19:52.680]  модифицировать значение.
[01:19:52.680 --> 01:19:54.680]  Ты хочешь либо младший бит
[01:19:54.680 --> 01:19:56.680]  поставить, если он стоял в ноль.
[01:19:56.680 --> 01:19:58.680]  Если ноль...
