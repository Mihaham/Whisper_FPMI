[00:00.000 --> 00:15.180]  значит начнем мы с твитера Зверовича, потому что очень интересная новость. в ситлес плюс 23
[00:15.180 --> 00:24.440]  добавили принт, представляете? и суммарно теперь hello world на плюсах выглядит читаемо,
[00:24.440 --> 00:30.920]  и человек, пришедший из другого языка, теперь не будет шокирован тем, что вообще происходит
[00:30.920 --> 00:42.080]  с этими саутами, стрелками и хэштег инклюдами. ну и да, мы достигли уровня читаемости, который был
[00:42.080 --> 00:52.720]  у сии 30 лет назад. ладно, не 30-60. но тем не менее, и этот принт, собственно, поддерживает такое же
[00:52.720 --> 01:01.240]  форматирование, если суффикс f дописать как принт f сей, только типа безопасно и ближе к питону.
[01:01.240 --> 01:10.240]  если вы про формат слышали, оно поддерживается. вот так что благие вести, товарищи. года через
[01:10.240 --> 01:20.560]  два мы все так будем писать. а сегодня мы будем говорить про ranges. это такая новая классная
[01:20.560 --> 01:28.800]  библиотека, можно сказать, которая теперь включена в стандартную. и стандартную библиотеку
[01:28.800 --> 01:37.080]  ranges пытаются подружить, еще долго будут пытаться, но идти она все будет очень тяжело, потому что
[01:37.080 --> 01:49.400]  legacy. а цель всего этого предприятия это писать на плюсах код примерно как на питоне, хаскеле,
[01:49.400 --> 01:59.320]  скале или f шарпе. собственно, еще можно сравнить со стримапи в джаве или с теми же стримами на си шарпе.
[02:03.320 --> 02:12.280]  ну, практика показала, что всякие простые задачи гораздо приятнее решать писа как там, а не вот как
[02:12.280 --> 02:22.320]  у нас в плюсах принято повсюду кидать какие-то лютые итераторы, типа даже std sort, там два итератора,
[02:22.320 --> 02:33.360]  их нужно сохранить, их нужно передать. если мы там делаем какую-нибудь remove if, то нам еще
[02:33.360 --> 02:40.920]  один итератор вернут и с ним тоже что-то надо делать. очень сложно, для обобщенного кода подходит,
[02:40.920 --> 02:45.680]  когда на практике нужно просто взять и решить простую задачу, ну просто отвратительно. и
[02:45.680 --> 02:56.920]  ranges это проблемы решают, поэтому мы хотим их изучить, это а. а b это то, что ranges это очень
[02:56.920 --> 03:02.960]  мощное с точки зрения метапрограммирования библиотека. собственно, почему оно в этот курс хорошо
[03:02.960 --> 03:10.800]  вписывается? ну, мы уже много раз упоминали, мне кажется, ranges, да, и когда про неблоиды говорили
[03:10.800 --> 03:22.880]  и прочие штуки. собственно, автор вот этой штуки, он написал Unifex, который я уже упоминал, и вся эта
[03:22.880 --> 03:34.720]  движуха, она так попахивает postmodern c++, когда уже просто сдались и начали пытаться выжить
[03:34.720 --> 03:41.720]  производительность вот просто всеми инструментами c++, не страшаясь сложного кода, каких-то шаблонов
[03:41.720 --> 03:52.920]  диких, язык abused просто по максимуму. как-то так. ну, давайте для начала вспомним. так, давайте
[03:52.920 --> 04:01.800]  я только чатик открою на втором экране. конечно, да, Ниблер не один писал. и Unifex, и ranges, это все,
[04:01.800 --> 04:09.120]  конечно, комьюнити-эфорт, но он такой евангелист что ли. когда речь идет о этих библиотеках,
[04:09.120 --> 04:21.920]  я почему-то только о нем думаю, а все остальные постольку поскольку. да, вспоминаем, когда мы
[04:21.920 --> 04:29.480]  про концепты говорили еще в самом начале в стандартной библиотеке, мы вот такие вот штуки видели
[04:29.480 --> 04:36.160]  movable, copyable, semi-regular, regular. про них мы не забываем, они повсюду используются, конечно,
[04:36.160 --> 04:43.440]  во всех других концептах, которых в ренджах полно. movable, все, что похоже на Unique PTR. а,
[04:43.440 --> 04:56.600]  вопрос, видите ли вы мой курсор? да. о, кайф. copyable, ну, что-то, что можно и мувать, и копировать,
[04:56.600 --> 05:04.640]  но обычно вот только copyable классов особо не встречается. они обычно semi-regular все-таки,
[05:04.640 --> 05:10.920]  это значит, что можно еще по дефолту конструировать. и самый приятный тип,
[05:10.920 --> 05:19.040]  или это категория типов, это regular, который copyable, movable, можно сравнивать и можно
[05:19.040 --> 05:24.560]  по дефолту конструировать. то есть ведут себя по сути как встроенные типы, и среди них такой
[05:24.560 --> 05:33.720]  самый явный представитель это shared pointer. окей, ranges. ну, на самом деле не ranges, а для начала
[05:33.720 --> 05:44.960]  итераторы. все строится очень постепенно из кучи этажей, такая лютая башня. и начнем с самого
[05:44.960 --> 05:52.920]  фундамента. вот концепт wickly incrementable. да, итераторы теперь тоже все об концептчины,
[05:52.920 --> 06:00.480]  мы про это чуть-чуть говорили. я, если честно, забыл сколько и насколько глубоко, поэтому повторим
[06:00.480 --> 06:09.880]  на всякий случай. вот тут не требуется заметь и regular, но все равно требуется дефолтное
[06:09.880 --> 06:20.760]  конструирование и movable. но то есть на unique ptr похоже. требуется некоторый тип difference tag,
[06:20.760 --> 06:26.320]  который вычисляется, конечно же, по еще одной сложной схеме через итератор traits и прочие
[06:26.320 --> 06:35.960]  штуки. хотя на самом деле это не совсем правда, но об этом попозже. да, и требуется чтобы этот
[06:35.960 --> 06:46.760]  тип был каким-то знаковым числом, и это не только встроенные знаковые числа на самом деле. сейчас
[06:46.760 --> 06:56.760]  про это скажу. или прямо сейчас. а, да, я забыл, как у меня устроены слайды. классно. так, ладно.
[06:56.760 --> 07:08.680]  вот, подробнее про то, как это difference tag все-таки устроено внутри. таких helper-типов в библиотеке
[07:08.680 --> 07:17.280]  много, поэтому хоть про один из них проговорим, как оно устроено. оно использует два разных трейта.
[07:17.280 --> 07:25.920]  во-первых, итератор traits, во-вторых, incrementable traits, потому что это более слабое понятие,
[07:25.920 --> 07:31.800]  нежели итератор. заметьте, тут нигде разыминований не требуется. соответственно,
[07:32.640 --> 07:43.000]  вот все такие шаблоны, итер дифференс т, для incrementable traits это все, а вот для самих
[07:43.000 --> 07:52.440]  итератор traits там есть еще value type, reference type, pointer type и прочие штуки. они все идут
[07:54.720 --> 08:00.400]  очень хитрым путем. сначала пытаются в самом типе итератора найти type def или using,
[08:00.400 --> 08:10.120]  нет, наоборот. сначала пытаются внутри самого трейта найти, если есть специализация, потом
[08:10.120 --> 08:18.160]  внутри типа, и наконец просто взять и вычислить, прям выражение бахнуть, какое мы хотим в итоге
[08:18.160 --> 08:25.400]  иметь, и посмотреть, какой тип получится. ну вот почему-то они решили добавлять знаковость,
[08:25.400 --> 08:35.840]  а не требовать ее изначально. ну ничего. signed integral like это все встроенные типы,
[08:35.840 --> 08:43.640]  знаковые, и внезапно расширение системы. вот такую штуку, возможно, на каком-нибудь
[08:43.640 --> 08:52.440]  окосе видели. это расширение компиляторов на армах и интелах присутствует для 128-битной
[08:52.440 --> 09:00.920]  целочисленной арифметики. и вот теоретически разность итераторов может быть м 128 и. тому
[09:00.920 --> 09:11.880]  это нужно я честно не знаю, но решили для общности вот так сделать. вот и наконец так назад или не
[09:11.880 --> 09:23.680]  назад. да, конечно, если он incrementable, то можно его incrementить в две стороны, но заметьте,
[09:23.680 --> 09:32.840]  что префиксный increment требует, чтобы получилась ссылка на собственный итератор в результате,
[09:32.840 --> 09:38.400]  а вот от постфиксного increment ничего не требует. я предполагаю, что вы помните,
[09:38.400 --> 09:44.160]  чем префиксный и постфиксный increment отличаются. ну и конечно есть некоторые
[09:44.160 --> 09:52.080]  семантические требования для моделирования, что они всегда префиксный и постфиксный одинаково
[09:52.080 --> 09:58.320]  определены, то есть либо оба определены для конкретного значения итератора, либо оба не
[09:58.320 --> 10:07.320]  определены. оба advance i, но что это значит, это, конечно, вопрос. скорее всего, в дебриах стандарт
[10:07.320 --> 10:15.840]  есть определение. ну и что после префиксного increment нам возвращают не копию, а именно тот
[10:15.840 --> 10:23.000]  же объект. то есть это прям зашито в требования строго. вот почему weakly incrementable, а не просто
[10:23.000 --> 10:33.160]  incrementable? тут как раз подчеркнуто, выделено, то почему. именно потому, что мы не требуем,
[10:33.160 --> 10:44.280]  чтобы постфиксный increment хоть что-то вообще возвращал, а также еще не требуется equality
[10:44.280 --> 10:54.560]  preservation, я надеюсь вы помните, что это, сохранение равенства при использовании функции. кто может
[10:54.560 --> 11:06.440]  предположить, зачем вообще такой концепт может быть нужен? почему для некоторых типов итераторов
[11:06.440 --> 11:16.880]  у нас может не быть возможности постфиксный increment реализовать? типа того, а куда делось,
[11:16.880 --> 11:25.560]  ладно, кажется я потерял слайд. ну ладно. да, input итераторы и прочие штуки, которые читают из
[11:25.560 --> 11:33.120]  ниоткуда. примеров еще, наверное, можно придумать, но вот раз уж я не выписывал, я из головы со вчерашнего
[11:33.120 --> 11:40.880]  дня уже не вспомню. ну ладно. ну раз есть weakly, значит есть и просто incrementable. и вот тут уже
[11:40.880 --> 11:49.240]  требуется регулярность внезапно. то есть weakly incrementable даже не требует, чтобы можно было их
[11:49.240 --> 11:55.080]  сравнивать. и для input итераторов это вполне естественно, потому что, ну как вы сравните input
[11:55.080 --> 12:02.360]  итератор, который просто читает из какого-нибудь потока данные, их нельзя сравнить. как только вы
[12:02.360 --> 12:10.320]  с него что-то прочитали, все, те старые данные пропали из потока, новые как бы вам прислали. ну и
[12:10.320 --> 12:20.560]  копировать тоже немного странно, потому что скопировав вы, возможно, ожидаете, что они будут
[12:20.560 --> 12:27.240]  одинаковые данные вам отдавать. это вполне естественное ожидание. но это, скорее всего, не так будет
[12:27.240 --> 12:35.320]  для итератора, который читает из потока. имея две копии, вы, скорее всего, будете прочитав из одного,
[12:35.320 --> 12:42.160]  просто читать из этого потока натурально. и как бы последовательность значений, задаваемых этими
[12:42.160 --> 12:47.360]  итераторами, она будет разная в зависимости от того, в каком порядке вы из них читаете. но это,
[12:47.360 --> 12:56.720]  конечно, странно, поэтому копируемость не требуется. вот и еще добавляется, собственно, вот эта
[12:56.720 --> 13:04.600]  вот штука, что все-таки постфиксный работает, как мы привыкли, и возвращает старое значение. ну и
[13:04.600 --> 13:14.200]  возвращается quality preservation. опять же, почему и quality preservation не требовался? ну, во-первых,
[13:14.200 --> 13:19.400]  даже знака равенства нет. соответственно, какой quality preservation? но если слово equality
[13:19.400 --> 13:30.440]  воспринимать, как мы в прошлый раз обсуждали, неотличимое, то это вполне будет нарушаться,
[13:30.760 --> 13:37.920]  потому что имея два итератора на input stream, один из них увеличив, потом второй из них увеличив,
[13:37.920 --> 13:46.400]  они как бы в разном состоянии технически будут. и вообще непонятно даже, что такое состояние,
[13:46.400 --> 13:52.040]  это состояние потока или чего. так что, чтобы от таких вопросов не думать,
[13:52.040 --> 14:00.120]  quality preservation выпилен для вывекли, здесь он впилен. вот, ну, я думаю, уже чувствуется,
[14:00.120 --> 14:06.560]  насколько тут все глубоко и насколько много мелких деталей, кубиков, из которых все в итоге строится,
[14:06.560 --> 14:16.040]  но это только начало. насчет моделирования wikli-incrementable. вот, насчет вопроса,
[14:16.040 --> 14:22.680]  ну типа, что такое advance. обратим внимание на то, что у нас здесь требование на i посильнее,
[14:22.680 --> 14:29.400]  здесь требуется не wikli-incrementable, а сразу incrementable. это хорошее замечание. в каком-то смысле
[14:29.400 --> 14:37.160]  у нас и после того выражения, и после того, как бы и у нас куда-то сдвинут дальше. потому что по
[14:37.160 --> 14:44.040]  дефолту это делает, видимо, только первое выражение, а с incrementable еще и второе. по-моему так.
[14:44.040 --> 14:54.640]  сейчас я пытаюсь сообразить, почему они именно так сформулировали, но очень странная формулировка,
[14:54.640 --> 15:03.320]  но поверим умным вядям, что они перебрали много контрпримеров и решили, что вот именно так лучше
[15:03.320 --> 15:09.440]  всего. к сожалению, эти контрпримеры очень тяжело гуглиться. я на многие вопросы, которые у меня самого
[15:09.440 --> 15:15.640]  собственно с прошлого раза, когда я работал в RNG остались, ответы такие нашел на всяких stack
[15:15.640 --> 15:24.600]  workflow, но как бы вопросы неисчерпываемы здесь. сначала и до конца изучить, почему этот дизайн
[15:24.600 --> 15:32.760]  вот такой, это сложно. на практике надо поиспользовать, возможно в итоге будет понятно.
[15:32.760 --> 15:41.720]  то есть как бы библиотека молодая, мало использования, ну и мы в итоге увидим, почему даже несмотря на
[15:41.720 --> 15:50.080]  добавление в C++20 использования RNG пока мало, но в будущем их будет больше, материалов будет больше,
[15:50.080 --> 15:56.520]  я думаю мы как бы поймем всю мудрость древних постепенно, либо всю глупость и потом будем
[15:56.520 --> 16:05.640]  менять стандарт. ну тут уж как пойдет. да, а семантические требования на incrementable вот такие,
[16:05.640 --> 16:16.920]  ну то есть тут буквально говорят, что a++ постфиксный, он должен вернуть такую же штуку,
[16:16.920 --> 16:25.680]  как и была a, да, то есть не такую же в смысле адреса, как было вот здесь для префиксного,
[16:25.680 --> 16:41.120]  а такую же в смысле равенства. ну это тоже достаточно странное условие, как бы очевидно,
[16:41.120 --> 16:46.760]  что для всех хороших итераторов оно выполняется, потому что что мы здесь делали, мы увеличили
[16:46.760 --> 16:55.880]  a, а потом все эти скобочки, благодаря оператору запятая, превращаются в просто a, но вот с другой
[16:55.880 --> 17:03.480]  стороны мы сделали plus plus b, то есть как бы имеется в виду, что то, что вернулось до постфиксного
[17:03.480 --> 17:19.680]  increment, оно равно b, а то, что после получилось, оно равно следующему за b. вот, но очень хитрые
[17:19.680 --> 17:28.760]  детали, непонятно почему именно так и думаю никогда не поймем. ну ладно. вот, наконец-то самое
[17:28.760 --> 17:37.680]  главное, что здесь вообще есть, это input or output итератор. заметьте, он именно weakly incrementable,
[17:37.680 --> 17:47.760]  и его можно разыменовать. и тут опять используются вот эти наши любимые костыли, когда в стандарте
[17:47.760 --> 17:55.000]  пишут не концепт новый, а просто пишут комментарий exposition only, и такой концепт есть, но как бы его
[17:55.000 --> 18:00.880]  нету, то есть концепт, который не обязательно предоставлять стандартной библиотеке пользователю,
[18:00.880 --> 18:08.840]  но в побочных концептах он встречается, поэтому он как бы вот есть. и да, теперь вот этот концепт
[18:08.840 --> 18:15.880]  input or output итератора, вот он называется итератором. все, что его удовлетворяет итератор, все, что не
[18:15.880 --> 18:23.800]  удовлетворяет не итератор. и собственно, как эта штука реализована, ну вот как-то так,
[18:23.800 --> 18:31.680]  можно навесить имперсант. заметьте, что просто t-амперсант вписать вот сюда в концепт,
[18:31.680 --> 18:38.080]  то есть написать type name t-амперсант нельзя, потому что так парсер работает, из-за этого вот такой вот
[18:38.080 --> 18:46.120]  костыль. назовите хотя бы один тип, для которого вот это вот не скомпилируется.
[18:46.120 --> 19:04.760]  void? void, а еще я придумать не смог. там возможно функции? нет, по-моему нет, потому что понятие
[19:04.760 --> 19:11.720]  ссылка на функцию в стандарте есть. там ссылка. да, именно не указатель на функцию, а ссылка на
[19:11.720 --> 19:22.240]  функцию. и добавление ссылок к ссылкам не приводит к никакому новому результату. возможно. нет,
[19:22.240 --> 19:31.280]  с массивами это работает. ну вот непонятно, зачем так сделано, но будем считать, что это просто от
[19:31.280 --> 19:42.160]  void предостережения. и тут дальше сразу появляется такое семейство концептов, которые из префиксы
[19:42.160 --> 19:47.960]  indirectly начинаются. вот тут я два привел, которые нам понадобятся сразу дальше, но на самом деле их
[19:47.960 --> 19:56.480]  там миллион. и все эти концепты обобщают указатели в каком-то смысле. вот примерно в том же смысле,
[19:56.480 --> 20:05.560]  как итераторы обобщают указатели. ну итератор у какого-нибудь вектора, он умеет массу всего.
[20:05.560 --> 20:17.360]  и существенно то, что он имеет, когда мы, например, имеем дело с итератором на вектор
[20:17.360 --> 20:29.800]  булов. мы помним, что он возвращает в раппер. и в коде обобщенным хотелось бы уметь делать
[20:29.800 --> 20:41.000]  std swap от разыменования двух итераторов на вектор була. и прочие хитрые вещи. читать результат,
[20:41.000 --> 20:48.960]  писать результат. и очень многие вещи, которые мы после разыменования итераторов делаем,
[20:48.960 --> 20:53.600]  они могут работать нетривиально, потому что разыменование может возвращать в раппер.
[20:53.600 --> 21:03.080]  поэтому напихали вот таких indirectly концептов. indirectly readable говорит о том, что для какого-то
[21:03.080 --> 21:11.640]  t, вот этот итератор и, его тип похож на t звездочка тем, что из него можно читать. то есть вы можете
[21:11.640 --> 21:19.400]  присвоить переменные и результат разыменования, грубо говоря. а writable наоборот, что вот тут уже
[21:19.400 --> 21:26.960]  для какого-то конкретного t, который нужно указать в шаблоне, и похож на т звездочка тем, что у него
[21:26.960 --> 21:33.360]  можно писать. то есть написать звездочка итератор равно и какое-то значение типа t.
[21:33.360 --> 21:44.800]  почему я не привел код? потому что он какой-то настолько дикий, что даже я сдался. вот если
[21:44.800 --> 21:54.160]  интересно, почитайте сами. да, и это дебри. но, к сожалению, в обобщенном коде без этого никак.
[21:54.160 --> 22:07.320]  да, и раз есть input or output, то должны быть input и output итераторы. и input итератор
[22:07.320 --> 22:15.120]  это input or output итератор, который indirectly readable, у которого есть вот такая странная штука,
[22:15.120 --> 22:22.200]  о которой собственно сейчас поговорим прямо сразу. что это за итер концепт? но это опять
[22:22.200 --> 22:29.360]  exposition only. и он идет по вот такой сложной цепочке определения, откуда взять этот тип.
[22:29.360 --> 22:36.360]  во-первых, из трейтов категория, нет, итератор концепт пытается достать, потом итератор категория,
[22:36.360 --> 22:44.040]  ну и в процессе, как и для любых других вещей, доставаемых из итератор trades, идет сам класс.
[22:44.040 --> 22:51.000]  и если все не получилось, то он говорит random access iterator, random access iterator tag.
[22:51.000 --> 22:56.680]  соответственно, про итератор теги, возможно, вы уже слышали, если нет, сейчас услышите,
[22:56.680 --> 23:04.680]  это такие пометочки, кто каким итератором является. и почему так сложно, почему есть концепт, есть
[23:04.680 --> 23:12.200]  категория, я не нашел здравого объяснения, но, насколько я понял, это такой хитрый костыль для
[23:12.200 --> 23:20.760]  миграции legacy, потому что то, как работают вот эти теги, оно чуть-чуть поменялось в c++20,
[23:20.760 --> 23:30.680]  и поэтому нужна возможность зауверрайдить старые итератор трейтсы. ну, например,
[23:30.680 --> 23:36.960]  вы используете библиотеку, написанную на c++17, там куча итераторов, просто масса,
[23:36.960 --> 23:42.840]  авторы библиотеки долго и упорно будут переписывать на c++20, но как бы это время,
[23:42.840 --> 23:48.560]  а вам нужно использовать уже сейчас. и вот чтобы у вас не возникло лютых проблем с использованием
[23:48.560 --> 23:57.160]  стандартных алгоритмов, вы можете сами как-то перекостылять итератор концепт, не трогая итератора
[23:57.160 --> 24:05.720]  категории, и оно как бы возьмет приоритет над старым итератор тегом, который использовался,
[24:05.720 --> 24:14.800]  вот, и соответственно, тут требуется, чтобы этот итератор тег можно было достать, да, то есть,
[24:14.800 --> 24:19.720]  вообще говоря, это итератор теги, но в новом стандарте решили их называть итератор концепты,
[24:19.720 --> 24:25.880]  чтобы отличить от старой системы тегов, потому что они чуть-чуть отличаются вот совсем на писечку,
[24:25.880 --> 24:33.760]  и да, это очень смущает, потому что вот у нас вот это концепт для итератора, это итератор концепт,
[24:33.760 --> 24:42.280]  просто медаль за нейминг, и соответственно требуют, чтобы этот тег, который мы получили каким-то
[24:42.280 --> 24:57.560]  образом, наследовался от итератор тега. Так, соответственно, итератор теги, как они устроены?
[24:57.560 --> 25:07.200]  Их много, и они делают иерархию, соответственно, разбираясь с пользуем, в этой иерархии должно
[25:07.200 --> 25:15.920]  быть наследование, а input-output ничего не наследует, то есть, для простого итератора нет никакого тега,
[25:15.920 --> 25:26.040]  input-output, но мы сейчас увидим почему. forward-iterator-tag наследует только input-iterator-tag внезапно,
[25:26.040 --> 25:34.360]  а bidirectional-iterator-tag, forward, random access bidirectional, ну, в общем, стандартная.
[25:34.360 --> 25:42.080]  мы должны были уже все это видеть, если писали что-нибудь на estay или более-менее крупное,
[25:42.080 --> 25:51.960]  а новое здесь contiguous-iterator-tag. Теперь можно помечать, что итератор указывает на память,
[25:51.960 --> 26:00.440]  лежащую подряд, ну, то есть, из стд-вектора, стд-рэй и прочие вещи. Это нужно, чтобы отличать,
[26:00.440 --> 26:08.240]  например, дек от вектора, потому что дек, формально говоря, тоже random access, но не за от единицы,
[26:08.240 --> 26:16.640]  ну, или просто может быть какая-нибудь хитрая структура данных, которая у вас как бы random access,
[26:16.640 --> 26:26.000]  какой пример, декортово дерево по неявному ключу, вот, но в памяти элементы лежат непоследовательно,
[26:26.000 --> 26:35.720]  и для некоторых алгоритмов важно это знать, соответственно, новый тег. Вот, и теперь посмотрим
[26:35.720 --> 26:49.560]  на output. Output это input or output, indirectly writable, все ожидаемо, ну, и какое-то условие на то,
[26:49.560 --> 27:00.520]  что можно действительно записать со знаком равенства, а притратор теги ничего, то есть,
[27:00.520 --> 27:07.040]  здесь мы требовали, чтобы через itr-концепт можно было достать тег, и он наследовал input
[27:07.040 --> 27:16.720]  iterator тег в input iterator, а в output iterator ничего не требуем. Внезапно, да, и обоснование тому,
[27:16.720 --> 27:26.480]  почему оно так работает, да, оно хитрое, тут все упирается в то, как работают алгоритмы, в то,
[27:26.480 --> 27:33.880]  как мы их хотим писать. В ходе выполнения алгоритма какого-то мы часто хотим попробовать
[27:33.880 --> 27:47.520]  запгрейдить итератор, то есть, например, sort, мы можем сортировать любые контейнеры,
[27:47.520 --> 27:54.520]  предоставляющие bidirectional-утератор на самом деле, да, не zyne-login, но можем. Вопрос,
[27:54.520 --> 28:01.440]  почему библиотеки бы не предоставлять такую возможность? Тогда нам нужна кастомизация этого
[28:01.440 --> 28:08.160]  алгоритма, которое смотрит, ну да, сам алгоритм как бы принимает по bidirectional концепту,
[28:08.160 --> 28:16.240]  да, для них, конечно, тоже есть концепт, и нам внутри алгоритма нужно посмотреть,
[28:16.240 --> 28:25.520]  является ли этот итератор на самом деле random access или даже contiguous. Если является,
[28:25.520 --> 28:36.000]  то более эффективную реализацию zyne-login запустить, если нет, то как бы за квадрат. И все это в
[28:36.000 --> 28:42.360]  compile-time, конечно. И вот вся эта система тегов, она с единственной целью задумана вот с этой,
[28:42.360 --> 28:51.280]  в алгоритме, понимать, насколько силен итератор. И по дефолту мы считаем, что итератор у нас
[28:51.280 --> 28:55.960]  random access tag. Это подвязывается с тем, что вот тот хитрый концепт по дефолту возвращает random
[28:55.960 --> 29:06.000]  access. А дальше теги делятся как бы на несколько типов. Вот input forward и bidirectional теги,
[29:06.000 --> 29:15.480]  это такая отписка от функционала. То есть мы явно говорим компилятору, что этот итератор не
[29:15.480 --> 29:21.000]  настолько крутой, как ты по дефолту думал. Он не умеет random access, он там только bidirectional,
[29:21.000 --> 29:30.040]  или вообще только input. И зачем нужны, собственно, эти теги? Затем, что по синтаксису, то есть как-то
[29:30.040 --> 29:39.680]  концептами это прописать и задетекстить невозможно. Мы не можем понять, умеет ли итератор в random
[29:39.680 --> 29:45.760]  access чисто вот какими-то синтаксическими выражениями. Не можем понять, имеет ли он bidirectional.
[29:45.760 --> 29:52.840]  Ну то есть попытаться-то можно, но выйдет плохо. Поэтому сделана такая система, где вы явно
[29:52.840 --> 29:59.600]  указываете, что нет, этот итератор в random access не умеет. Contiguous итератор — это наоборот
[29:59.600 --> 30:05.440]  подписка на дополнительный функционал. И вот ее мы вообще совершенно точно никак по синтаксису не
[30:05.440 --> 30:11.440]  можем понять. Невозможно отличить чисто синтаксически contiguous от random access итератора.
[30:11.440 --> 30:18.640]  Зато семантика отличается. Можно как-то ускорять, можно как-то optimize, какие-нибудь
[30:18.640 --> 30:26.960]  хитрости использовать. Поэтому есть тег, который вы можете явно в своем итераторе указать,
[30:26.960 --> 30:32.000]  и возможно получать более эффективную имплементацию алгоритмов от компилятора.
[30:32.000 --> 30:44.120]  Например, есть output итератор tag, и он не нужен по двум причинам. Первая причина — что output
[30:44.120 --> 30:50.240]  итератора можно детектить по синтаксису весьма успешно. Вот этой конструкции, которая здесь requires,
[30:50.240 --> 31:02.160]  что увеличенный там разыминованный указатель, в него можно записать t. И на практике, как оказалось,
[31:04.160 --> 31:11.080]  не бывает таких алгоритмов, которые хотят взять output итератор, а потом посмотреть,
[31:11.080 --> 31:17.400]  он является ли он более сильным. Это вообще очень редкая ситуация, чтобы у вас output итератор
[31:17.400 --> 31:25.520]  являлся random access или еще чем-то другим. Фактически нонсенс. Я даже не могу придумать примера,
[31:25.520 --> 31:31.360]  когда output итератор является чем-то кроме output итератора. Вся его идея — это в том,
[31:31.360 --> 31:38.000]  что в него можно только записать и увеличить. Все, больше ничего. Это чем-то даже поток напоминает,
[31:38.000 --> 31:44.480]  больше, чем итератор. Поэтому нужды всей этой системе для него нет, для консистентности тег,
[31:44.480 --> 31:50.800]  конечно, добавили, но по факту он не используется. Так что вот так. Возможно,
[31:50.800 --> 32:02.080]  скоро задеприкейтит и отпилит этот тег, но посмотрим. Дальше новый кусочек. Давайте поймем,
[32:02.080 --> 32:07.520]  все ли понятно на данный момент. Или нам нужно что-то обсудить.
[32:07.520 --> 32:19.480]  Прошу прощения. Думаю, в микрофон очень сильно отдаются звуки телефона.
[32:19.480 --> 32:36.000]  Видимо, вопросов нет. Андрей скинул что-то. О, интересно. Тут показано на трейдах,
[32:36.000 --> 32:40.360]  но я в качестве эксперимента написал трейд со слайда addRFT, поставил туда
[32:40.360 --> 32:48.920]  квалифайд функцию, и да, оно не собралось. Я просто набрал там c++ examples of non-referenceable
[32:48.920 --> 33:00.760]  types и вторая ссылка это вот это. Но я это предположил, что это они, когда решил трейд почитать,
[33:00.760 --> 33:06.640]  соответствующий addRValueReference, addRValueReference. Там вот как раз указаны вот такие веселые типы,
[33:06.640 --> 33:13.960]  что кажется для них это нормально не работает. Ну да, это закономерно. Я просто пытался по своему
[33:13.960 --> 33:18.720]  концепту гуглить где-то объяснение, мотивировки его всего, а не по кусочкам. Наверное, в этом моя
[33:18.720 --> 33:26.520]  ошибка, поэтому я ничего не нашел. Но да, весьма закономерно, что такие штуки не могут быть еще и
[33:26.520 --> 33:36.360]  со ссылкой. Ну вообще, тут встает огромный вопрос, а что это вообще такое за тип и зачем он нужен?
[33:36.360 --> 33:47.920]  Но об этом мы в следующий раз с вами поговорим. Ну да, забавно. Ну вот опять же, как бы сложности в
[33:47.920 --> 33:53.240]  стандарт это привнесло, вот это хитрое требование. А на деле защитило нас от чего? От того, чтобы мы
[33:53.240 --> 33:59.040]  такие типы не возвращали из функций. Извините, а где мы вообще их возьмем, инстанция таких типов?
[33:59.040 --> 34:07.480]  Это вообще как? Ну то есть какая-то война с мельницами, если честно, в некоторых местах, в ranges,
[34:07.480 --> 34:19.200]  но в целом достаточно бодро. Так, вернемся и продолжим к следующей штуке новой. Помимо итераторов
[34:19.200 --> 34:30.800]  у нас теперь есть сентинелы. Они похожи на итераторы, но они не то же самое, что итераторы. И сентинелы
[34:30.800 --> 34:38.080]  у нас определяются для конкретных типов итераторов. То есть концепт этот от двух штук,
[34:38.080 --> 34:45.120]  S это сам сентинел, а E это соответствующий ему итератор. Все сентинелы обязаны быть сами
[34:45.120 --> 34:55.600]  регулярными, обязаны как бы быть, да, наоборот, соответствующий им итератор обязан быть input
[34:55.600 --> 35:02.920]  or output итератором. То есть максимально слабое требование, что еще может быть. И вот такой хитрый
[35:02.920 --> 35:09.800]  концепт Weakly, Quality Comparable With, который просто значит, что эти два товарища можно сравнивать,
[35:09.800 --> 35:21.000]  и equality preservation не требуется. Да, черт, я зря нажил стрелочку. Я хотел у вас спросить, как вы
[35:21.000 --> 35:26.920]  думаете, зачем это нужно? Что-то, что не является итератором, очень близко к ним и можно сравнивать
[35:26.920 --> 35:33.440]  с итераторами. Ну вот да, это как бы обобщение идеи, а когда надо остановиться. Да, это обобщение идеи
[35:33.440 --> 35:40.680]  того, что End возвращает итератор. Теперь End у нас возвращает не итератор, в общем случае. Begin
[35:40.680 --> 35:54.680]  все еще итератор, End сентинел. И нужно это вот зачем, собственно. Представьте input stream. Мы
[35:54.680 --> 36:04.160]  хотим его представить как range. Ну мы пока еще не говорили, что такое range, но просто логично,
[36:04.160 --> 36:11.280]  даже вот просто сев подумав, логично предположить, что это пара итератор на начало, итератор на конец.
[36:11.280 --> 36:22.920]  Но в таком случае, как мы последовательность чисел, введенных с input stream, пока получается,
[36:22.920 --> 36:34.480]  обозначим за range. У нас же не может быть итератора на конец input stream. Ну точнее может быть,
[36:34.480 --> 36:49.640]  именно в случае input stream, но тут стоит упомянуть еще другую штуку. Вот те из вас, кто решал вторую
[36:49.640 --> 36:55.400]  домашку, возможно, прочувствовали, как прикольно уметь работать с бесконечными последовательностями.
[36:55.400 --> 37:05.800]  И range, они таки поддерживают бесконечные последовательности. И в том числе для этого
[37:05.800 --> 37:17.080]  конец range может быть вообще какого-то другого типа, не итератора. Есть просто тип, который в
[37:17.080 --> 37:25.320]  стандарте обозначает как бы недостижимый сентинел. И ровно этот тип используется для бесконечных
[37:25.320 --> 37:36.440]  ранжей. Например, может быть range на все натуральные числа. Вот, то есть теперь range это не пара двух
[37:36.440 --> 37:42.160]  итераторов, а пара все-таки итератора и сентинела, будем считать. Но об всем этом будет еще подробнее
[37:42.160 --> 37:48.760]  дальше. А пока просто запомнили, что сентинела есть, на них требования весьма естественные,
[37:48.760 --> 37:56.920]  можно сравнивать с итераторами. Дальше нам нужно ввести странное определение. Оно в стандарте
[37:56.920 --> 38:03.000]  называется range, но это не тот же range, про который говорят, когда называют само это библиотеку ranges.
[38:03.000 --> 38:09.960]  Это некоторый более математический термин в стандарте, используемый как вспомогательный.
[38:09.960 --> 38:17.360]  Давайте его, по примеру, прошлого года называть диапазоном, а вот настоящий range уже range.
[38:17.360 --> 38:26.680]  И диапазон это пара из итератора и сентинела, для которых, если они не равны, то обязательно
[38:26.680 --> 38:37.040]  итератор валидный, то есть его можно разменовать. И увеличив этот итератор, мы вновь получим range,
[38:37.040 --> 38:46.680]  то есть диапазон, прошу прощения. То есть такое рекурсивное определение. Тоже вполне естественно
[38:46.680 --> 38:52.360]  уже начинает попахивать математической логикой и прочими штуками, или даже какой-то алгеброй,
[38:52.360 --> 39:03.560]  но вот так. И дальше есть уточнение этого понятия, валидный диапазон, ну просто конечный. То есть
[39:03.560 --> 39:14.080]  делая оператор плюс плюс, мы за конечное количество шагов дойдем до конца. Да, я тут не посмотрел,
[39:14.080 --> 39:22.900]  но кажется, что вот этот и в начале, ну да, это input-output, ослабить это нельзя, input-output-
[39:22.900 --> 39:34.060]  итератор. Вот, как-то так. И все, мы готовы более полезные итераторы определять. Forward
[39:34.060 --> 39:41.420]  итератор. Ну для каких структур данных forward итератор используется, кто напомнит?
[39:41.420 --> 39:50.900]  Односвязный список. Да, односвязный список. Ну и многие его расширения. Могут быть какие-нибудь
[39:50.900 --> 39:58.540]  конечные автоматы, по которым вы можете по ссылкам ходить вперед, а назад не можете. Да,
[39:58.540 --> 40:03.580]  если кто-нибудь суф-автомат писал, думаю, представляет примерно о чем я. Ну или там суфиксное
[40:03.580 --> 40:12.020]  дерево даже. Там тоже есть эти ссылки forward. Вот, соответственно, конечно forward итератор это
[40:12.020 --> 40:23.660]  тоже input итератор. Читать мы из него можем. Тег мы требуем. Уже обсудили, что необходимо уметь
[40:23.660 --> 40:32.740]  детектить, возможно ли расширить input до forward в алгоритмах. И тут наконец-то появляется
[40:32.740 --> 40:38.260]  incrementable, про который мы в самом начале сказали. То есть, что input, что input-output,
[40:38.260 --> 40:44.980]  они все были weakly incrementable. Да, теперь уже нормально incrementable. И более того,
[40:44.980 --> 40:56.420]  мы сразу требуем, чтобы он был с Sentinel-ом сам для себя. Ну а почему с Sentinel-ом сам для
[40:56.420 --> 41:04.340]  себя этого точно сказать нельзя, так не задумавшись, не приходит в голову причин, почему нельзя было
[41:04.340 --> 41:09.660]  расширить понятие Sentinel и на forward итератора. Но вот это как бы намекает на то, что они живут
[41:09.660 --> 41:22.980]  только как бы в мире input и output итератора. Да, но на самом деле Sentinel-4 вот в данном случае,
[41:22.980 --> 41:30.340]  если внимательно посмотреть на определение, фактически схлопывается в regular i из-за того,
[41:30.340 --> 41:35.060]  что мы двои указали. И то, что здесь именно Sentinel-4 указали, а не regular,
[41:35.060 --> 41:44.620]  это скорее про семантические требования, а не про то, что в концепте на самом деле написано.
[41:44.620 --> 41:59.140]  Ну и да, имея хоть какой-то простецкий... ладно, не имея. Порядок слайдов немножко не лучший.
[41:59.140 --> 42:11.340]  Определим range наконец-то. Range это пара. Ну, вернее нет, но да, но сам концепт выглядит как
[42:11.340 --> 42:19.460]  требование, чтобы ranges begin и ranges end компилировались для l-value ссылок на этот тип.
[42:19.460 --> 42:29.940]  Более того, equality preservation здесь требуется только для итераторов хотя бы настолько
[42:29.940 --> 42:36.540]  сильных, насколько forward итератор. То есть input и output итераторы не обязаны equality
[42:36.540 --> 42:47.980]  preservation делать. И вот то, в каком смысле range это пара итераторов, это мы увидим дальше.
[42:47.980 --> 43:02.020]  Бла-бла-бла-бла-бла. Range begin, range end, первый bullet point, это диапазон, то есть вот то
[43:02.020 --> 43:10.420]  математическое определение, которое мы раньше давали. А также второй bullet point. Begin-end
[43:10.420 --> 43:16.540]  амортизировано за от единицы вычисляются, что нам позволяет грубо говоря говорить о том,
[43:16.540 --> 43:24.820]  что сам тип удовлетворяющий концепту range внутри себя как бы хранит эти begin-end итераторы,
[43:24.820 --> 43:32.580]  но нам их не дает, пока мы не попросим. Вот в таком смысле оно как бы является парой итераторов
[43:32.580 --> 43:39.860]  на начало и конец. Но заметьте, что end возвращает все-таки sentinel, потому что мы в определении
[43:39.860 --> 43:48.980]  диапазона говорили про sentinel. Амортизация это тут на самом деле очень важный момент,
[43:49.460 --> 44:00.140]  без него бы ничего не работало, на удивление, и чуть попозже мы про это увидим. Да, и собственно
[44:00.140 --> 44:06.460]  вот требования на equality preservation, про которые я уже сказал. Причем оно только на begin,
[44:06.460 --> 44:22.100]  что если честно немного странно. Ну да ладно. Да, заметьте, begin-end должны не модифицировать тип,
[44:22.100 --> 44:30.300]  ну объект, у которого мы вызываем. Почему здесь именно не модифицировать сказали, а не то,
[44:30.300 --> 44:35.380]  что они const, потому что, как мы знаем, стандартные библиотеки begin-end бывают
[44:35.380 --> 44:40.820]  константные и неконстантные, бывают константные и неконстантные итераторы. И тут имеется в виду,
[44:40.820 --> 44:50.140]  что они именно с точки зрения внешнего мира наш контейнер никак не поменяли. А что означает,
[44:50.140 --> 44:56.940]  что какой-то cache mutable внутри контейнера, они вполне себе могут обновлять до тех пор,
[44:56.940 --> 45:08.740]  пока этот cache никак не виден изнутри. А как-то так. И собственно, когда... не так. Что вообще значит
[45:08.740 --> 45:16.380]  ranges begin? Ну это не bloid опять, на самом-то деле. Точка кастомизации не bloid, как угодно можно
[45:16.380 --> 45:25.540]  называть. И в каком порядке оно пытается найти дефолтные какие-то реализации? Во-первых,
[45:25.540 --> 45:39.180]  вот такое выражение. Это для каких типов нужно? Кто-нибудь? Массивы? Да, сишные массивы именно,
[45:39.180 --> 45:52.740]  то есть не стдр, а просто какая-нибудь у квадратные скобочки. Okay, forward. Ну это на самом деле,
[45:53.140 --> 45:57.980]  мне кажется, надо было бы выпилить со слайдов, чтобы не так подробно было. Ну в общем,
[45:57.980 --> 46:07.060]  member begin. То есть на экземпляре t можно вызвать begin, и он вернет input-output и тератор. Тогда
[46:07.060 --> 46:16.660]  его и будут использовать. И ADL, свободная функция begin глобального namespace. Ну собственно,
[46:16.660 --> 46:21.740]  не bloid, про них мы уже говорили достаточно. И тоже input-output обязаны вернуть.
[46:21.740 --> 46:32.700]  Okay, end тоже самое, но вместо прибавления нуля, чтобы как бы... Да, насчет этого прибавления нуля
[46:32.700 --> 46:39.500]  вот никто не переспросил, почему так надо, а не просто t использовать. А надо так вот почему. У
[46:39.500 --> 46:46.820]  квадратные скобки это как бы не тератор. Вот у звездочка это и тератор. И когда мы к у квадратной
[46:46.820 --> 46:54.580]  скобке прибавим 0 или int, мы как раз получим у звездочка, то есть указательное начало массива.
[46:54.580 --> 47:03.220]  Очень тонкая разница, но вот в legacy приходится с ним мириться. Вот, а в случае end нам нужно
[47:03.220 --> 47:09.420]  прибавить размер t, и вот это вот такая сложная штука, которая умеет в compile-time
[47:09.420 --> 47:16.620]  определять размеры C-шных массивов, если они фиксированного размера. Вы, наверное,
[47:16.620 --> 47:26.420]  знаете, что в аргументы функции можно принимать у и в квадратных скобках указывать размер. А вы
[47:26.420 --> 47:35.540]  знаете, что это делает на самом деле? Какой на самом деле будет как бы тип у этой переменной
[47:35.540 --> 47:40.500]  с точки зрения всего кода? Если вы вот здесь в аргументе, вместо t напишите u в
[47:40.500 --> 47:55.180]  квадратных скобках в скобках 32 или 42. Дикей t, нет? У массива известного размера это разве дикей?
[47:55.180 --> 48:02.940]  Да, массивы и без размера и с указанным размером, когда находятся в аргументах, они в итоге дикеются
[48:02.940 --> 48:07.980]  в указателях и ведут себя абсолютно так же, как указатели. Ну а тут ссылка, да, поэтому...
[48:07.980 --> 48:15.580]  Ну это... И поэтому это все читает и фиксит. Это вроде да, это фиксит. А так да, согласен,
[48:15.580 --> 48:20.620]  если по значению указывать, то действительно все дикеются. Да, но даже если бы оно было не по
[48:20.620 --> 48:27.860]  ссылке, несмотря на то, что сама t, когда мы ее будем использовать, будет выглядеть как
[48:27.860 --> 48:39.340]  указатель. Если бы мы вот в качестве типа указали явно массив с фиксированным размером с помощью
[48:39.340 --> 48:44.380]  хитрой шаблонной магии, которую вы все должны уметь писать уже, мы можем таки вычислить размер
[48:44.380 --> 48:49.980]  этого массива, то есть узнать, что в квадратных скобках было написано. А так как тут по ссылке
[48:49.980 --> 48:55.760]  принимается, у нас после вывода типов все еще останется число в квадратных скобках. И вот
[48:55.760 --> 49:02.680]  собственно с помощью этого шаблончика мы узнаем, какой размер там был указан. Вот,
[49:02.680 --> 49:12.960]  и вторая разница это что требуется, чтобы возвращал Sentinel for итератор. Да, итератор t соответственно
[49:12.960 --> 49:22.440]  вам возвращает то, что вернул Бобедин. Ну наверное чуть более хитрее, но в целом так. Ну и да,
[49:22.440 --> 49:32.880]  это тоже не Bloit, тоже ADL, тоже можно кастомизировать через всяких friend'ов или глобальные функции. Вот,
[49:32.880 --> 49:40.340]  но в придачу к ренджам идет такое понятие как Vue и очень долгое время шли споры о том,
[49:40.340 --> 49:46.440]  что такое Rends, что такое Vue. В итоге еще третью сущность придумали и четвертую, про которую
[49:46.440 --> 50:00.200]  у нас под конец будет. Но мотивировка станет скоро понятна. Vue это тоже Rends, movable. Давайте вернемся
[50:00.200 --> 50:06.720]  на слайд с ренджем и вспомним, что там никаких вообще требований на копируемость, movability нету.
[50:06.720 --> 50:14.520]  То есть какой-нибудь контейнер, который содержит в себе стдр и мютекс, это вполне нормальный рендж.
[50:14.520 --> 50:24.600]  То есть они могут быть даже в памяти запиненными. А в Vue уже movable, default initializable и вот есть
[50:24.600 --> 50:37.440]  такой некий шаблон enable Vue. Ну можно догадаться, что это механизм наподобие итераторов, который
[50:37.440 --> 50:43.040]  просит явно подписываться, наподобие итератор тегов, который просит явно подписываться на то,
[50:43.040 --> 50:52.040]  что да, я являюсь Vue. Пожалуйста, считай меня Vue. Иначе у нас Vue станет очень-очень много чего и кажется,
[50:52.040 --> 51:03.440]  мы этого не хотим. Вот, из семантических требований. Все зовут единица. И, соответственно,
[51:03.440 --> 51:12.680]  да, просто все зовут единица. Да, все эти сложные слова просто говорят, если определено,
[51:12.680 --> 51:24.760]  то зовут единица. Да, и собственно про enable Vue. Есть такая штука Vue Base и enable Vue требует,
[51:24.760 --> 51:31.280]  чтобы мы либо отнаследовались от нее, либо отнаследовались от хитрых штуки,
[51:31.280 --> 51:37.640]  называемые Vue интерфейсом. Но нам с нашей высокой башней должно быть уже легко и просто понять,
[51:37.640 --> 51:44.400]  что это. Это CRTP родитель для удобства. Мы для итераторов такое вроде смотрели,
[51:44.400 --> 51:52.640]  а теперь есть такое для Vue. Он требует определить begin-end и предоставляет кучу всяких полезных штук,
[51:52.640 --> 52:00.840]  но, конечно, в зависимости от того, удовлетворены ли соответствующие концепты для итератора,
[52:00.840 --> 52:06.200]  который вернул begin-end. Ну, предположите, какой концепт требуется выполнять,
[52:06.200 --> 52:10.200]  чтобы empty и делающий то же самое оператор был был определен.
[52:10.200 --> 52:31.920]  Ни у кого нет предположений. Еще раз, какой концепт нужно? Да, вот Vue interface этот CRTP
[52:31.920 --> 52:40.000]  родитель для Vue. В нем написаны вот эти методы, которые выражены через begin-end.
[52:40.000 --> 52:50.960]  А, ну тогда кажется, нам просто ренджа хватает? Нет. RendsH только предоставляет вам begin-end.
[52:50.960 --> 52:56.080]  Ну а если, естественно, begin-end и итератор, а end-end это sentinel для него, тогда...
[52:56.080 --> 52:58.720]  Да, и требования нам нужно именно на эти типы наложить.
[52:58.720 --> 53:05.200]  А концепт RendsH это не требует? Да, концепт RendsH, давай еще раз посмотрим на него,
[53:05.200 --> 53:09.760]  чтобы точно понять. Концепт RendsH это вас требует только двух вещей,
[53:09.760 --> 53:14.480]  чтобы begin-end компилировались. А begin-end компилируется в случае,
[53:14.480 --> 53:17.120]  если они не удовлетворяют требованиям на итератора sentinel?
[53:17.120 --> 53:27.280]  Сейчас, где это у нас было, input-output-iterator и sentinel-for, да? Вот.
[53:27.280 --> 53:34.480]  Позволяет ли нам понять empty или не empty вот эти две штуки?
[53:34.480 --> 53:47.480]  Да, позволяет. Давай продолжим бегать по презентации, чтобы мы явно поняли.
[53:47.480 --> 53:50.320]  Хорошо. Вот.
[53:50.320 --> 53:56.880]  Winkly-incrementable. Winkly-incrementable оператор равно не предоставляет.
[53:56.880 --> 54:00.560]  Как мы сравним begin-end? Хорошо, пойдем посмотрим на sentinel.
[54:00.560 --> 54:09.800]  Ну, sentinel, sentinel, да. Типа, какой же он тогда sentinel для него,
[54:09.800 --> 54:13.800]  если он не сравнивается с ним? Так, а где же, где же, где же?
[54:13.800 --> 54:23.280]  Ладно, да, sentinel действительно определяет, да, что его может сравнивать с итератором.
[54:23.280 --> 54:29.320]  Что-то я не вижу пока ограничений. Ладно, я сейчас сам тогда гляну.
[54:29.320 --> 54:34.640]  Давай глянем вместе. Хорошо.
[54:34.640 --> 54:43.320]  New interface. Я решил не выписывать, потому что их там много, но на всякий случай давайте
[54:43.320 --> 54:50.040]  посмотрим, потому что мне казалось, что я запомнил. Да, внезапно требуется forward range.
[54:50.040 --> 55:01.080]  Наверное, потому что иначе дёргать empty как-то страшно.
[55:01.080 --> 55:12.600]  Ну да, это в каком-то смысле не имеет смысла, да, потому что у нас бывают бесконечные ренджи
[55:12.600 --> 55:18.800]  и проверять, что nemt или nemt, это с одной стороны странно, с другой стороны, а чего бы нет.
[55:18.800 --> 55:24.400]  В Haskell так делают и никто не страдает. Так, бесконечность или дело? Да.
[55:24.400 --> 55:32.480]  Сейчас, ещё раз, ты хочешь сказать, что forward range требует валид range для моделинга?
[55:32.480 --> 55:37.920]  Вообще не должен, конечно. Что-то вот как-то.
[55:37.920 --> 55:48.160]  У forward range не обязан быть итератором. Для этого есть отдельный концепт.
[55:48.160 --> 55:50.920]  Давай посмотрим.
[55:50.920 --> 56:02.880]  Но при этом никто не говорит, что sentinel у forward range может быть какой угодно,
[56:02.880 --> 56:06.200]  если он является sentinel для этого итератора.
[56:06.200 --> 56:10.240]  Ещё раз, тут говорилось forward range, а не forward iterator.
[56:10.240 --> 56:12.720]  Forward range. Что такое forward range?
[56:12.720 --> 56:18.360]  Получается range, у которого итератор литовыряет forward iterator.
[56:18.360 --> 56:24.200]  Ого, такой концепт есть. Прикольно.
[56:24.200 --> 56:26.880]  Ну, там вообще у нас все виды концепта есть.
[56:26.880 --> 56:31.440]  Ну, вообще да, их там настолько много, что все их вообще никак не как-то подпихнуть.
[56:31.960 --> 56:34.160]  Ну да, окей.
[56:34.160 --> 56:38.800]  Но тем не менее, кто ж гарантирует, что...
[56:38.800 --> 56:40.880]  Вернее, наоборот.
[56:40.880 --> 56:43.560]  Ну, forward range требует, чтобы forward iterator.
[56:43.560 --> 56:47.120]  Forward iterator требует, чтобы sentinel...
[56:47.120 --> 56:49.560]  Чтобы он сам себе был sentinel, да.
[56:49.560 --> 56:52.560]  А, хотя это не требует, чтобы end возвращал i.
[56:52.560 --> 56:55.680]  Да, именно. Я об этом.
[56:55.680 --> 57:00.280]  Блин, патологический случай какой-то. Это точно так задумано?
[57:00.280 --> 57:01.960]  Ну, по-моему, нормальный случай.
[57:01.960 --> 57:04.440]  Например, раньше возвращающие все натуральные числа,
[57:04.440 --> 57:08.440]  а он вообще отсветлене random access, но он еще и бесконечный.
[57:08.440 --> 57:09.480]  Да.
[57:09.480 --> 57:13.600]  Так что тут на самом деле можно так хорошо подумать.
[57:13.600 --> 57:16.720]  Зачем мы тогда требуем, чтобы он был sentinel самому себе?
[57:16.720 --> 57:17.560]  Для сравнивания...
[57:17.560 --> 57:21.480]  Мы требуем, видимо, чтобы у нас поддиапазоны были нормальные какие-то.
[57:21.480 --> 57:24.680]  Чтобы они вообще были и были какие-то адекватные.
[57:24.680 --> 57:27.600]  Поддиапазон должен быть range.
[57:27.600 --> 57:29.360]  Кстати, хорошая идея.
[57:29.360 --> 57:33.400]  Потому что на input range поддиапазон нельзя строить.
[57:33.400 --> 57:34.440]  Это вообще бред полный.
[57:34.440 --> 57:36.440]  А вот на forward вообще на кофе.
[57:36.440 --> 57:37.640]  Это очень хорошая мысль.
[57:37.640 --> 57:42.640]  Вероятно, именно в этом дело еще бы они в стандарте писали эти мотивировки.
[57:42.640 --> 57:45.320]  Ну, вот это хорошая мысль, чтобы они это писали.
[57:45.320 --> 57:49.600]  Да, но кажется, они боятся вносить ненормативные заметки.
[57:49.600 --> 57:52.680]  Ну, вот я их за это немножко хейчу, если честно.
[57:52.680 --> 57:58.040]  Пусть тогда сделают приложение к стандарту и туда впишут вообще сколько могут.
[57:58.080 --> 58:01.080]  Это хорошая мысль, только приложение к стандарту уже четыре.
[58:01.080 --> 58:02.640]  Пятая.
[58:02.640 --> 58:03.880]  Отлично.
[58:03.880 --> 58:08.040]  Ну, во всяком случае есть на самом деле...
[58:08.040 --> 58:09.320]  Хотя ладно, нет.
[58:09.320 --> 58:13.480]  Всю эту мотивировку, скорее всего, можно найти только в mailing-листах и на GitHub.
[58:13.480 --> 58:14.880]  Нет.
[58:14.880 --> 58:17.080]  Так что, да, беда.
[58:17.080 --> 58:19.280]  Окей, а с чего мы начали?
[58:19.280 --> 58:20.760]  Начали мы с обсуждения того...
[58:20.760 --> 58:27.760]  Да, почему не имеет смысл empty для не forward?
[58:27.760 --> 58:30.760]  Ну, непонятно, если честно.
[58:30.760 --> 58:32.080]  Ну да, что-то как-то...
[58:32.080 --> 58:34.400]  И мне показалось, что это очевидно.
[58:34.400 --> 58:40.400]  Но если задуматься, это действительно вообще непонятно, почему мы не можем проверить...
[58:40.400 --> 58:42.640]  Хотя, что значит input?
[58:42.640 --> 58:49.320]  Вот range, который из input-атератора читает, что для него значит быть пустым?
[58:49.320 --> 58:52.640]  Мы не можем проверить, пустой ли он, пока его не увеличим.
[58:52.640 --> 58:55.880]  Правда ведь?
[58:55.880 --> 58:58.040]  То есть, несмотря на то, что мы сравним...
[58:58.040 --> 59:00.480]  Вот, кажется, в чем дело.
[59:00.480 --> 59:08.240]  Оператор равенства для Sentinel-ов не обязан вообще говорить true когда-либо.
[59:08.240 --> 59:11.800]  Даже если...
[59:15.960 --> 59:19.960]  Вернее, так.
[59:20.040 --> 59:27.280]  Кстати, вот ты, кажется, верно, мы сейчас сказали, что, возможно, если у нас range не является forward range,
[59:27.280 --> 59:30.880]  как, например, там представление стрима, то...
[59:30.880 --> 59:35.400]  Ну да, действительно, попытки проинкрементировать мы ничего особо сказать не можем, поэтому...
[59:35.400 --> 59:36.680]  Да, пока мы не заинкрементироваем...
[59:36.680 --> 59:41.600]  То есть, это проверка, она не может нам сказать ничего полезного, в общем-то.
[59:41.600 --> 59:45.160]  Да, если она говорит false, то это ничего не означает.
[59:45.160 --> 59:47.200]  Да, он может быть true, да.
[59:47.200 --> 59:49.080]  Поэтому, видимо, такое требование.
[59:49.080 --> 59:54.640]  Вот, ну ладно, давайте уже дальше чуть побыстрее побежим, чтобы не умереть.
[59:54.640 --> 59:56.920]  Data, contiguous.
[59:56.920 --> 01:00:03.080]  Да, мы ожидаем увидеть точка data, которая возвращает указатель на начало последовательной памяти у...
[01:00:03.080 --> 01:00:06.720]  Ну, контейнеров с последовательной памятью, да.
[01:00:06.720 --> 01:00:12.160]  Vector, array и прочие штуки, похожие на них.
[01:00:12.160 --> 01:00:15.600]  Size требует, скорее всего, forward.
[01:00:15.600 --> 01:00:17.600]  Но это не точно.
[01:00:19.280 --> 01:00:20.960]  Вернемся сюда.
[01:00:20.960 --> 01:00:22.960]  Да, он действительно требует forward.
[01:00:22.960 --> 01:00:26.880]  Потому что в forward мы таки можем взять, поинкрементить.
[01:00:26.880 --> 01:00:29.840]  Ну, для начала скопировать, потом поинкрементить, дойти...
[01:00:29.840 --> 01:00:32.520]  Ну вот, там еще одно требование.
[01:00:32.520 --> 01:00:33.200]  Где?
[01:00:33.200 --> 01:00:35.200]  Принять, пожалуйста.
[01:00:37.000 --> 01:00:37.680]  Да.
[01:00:37.680 --> 01:00:43.360]  Это очень важно, иначе size не константная, а это, ну, какая-то плохая вьюха.
[01:00:43.360 --> 01:00:47.600]  Да, тут есть еще вот такой механизм, но...
[01:00:47.600 --> 01:00:54.120]  Мы и так очень глубоко сейчас углубимся, если мы вот еще сюда полезем, то это будет больно.
[01:00:54.120 --> 01:00:55.960]  Но тут что тут предлагают?
[01:00:55.960 --> 01:01:02.840]  Тут предлагают почитать, и есть возможность явно запретить это дело.
[01:01:02.840 --> 01:01:03.800]  Хм...
[01:01:03.800 --> 01:01:05.400]  Ну, окей.
[01:01:05.400 --> 01:01:12.360]  То есть, кажется, даже для forward-детераторов мы все равно должны уметь за вот единицы все это делать, да.
[01:01:12.360 --> 01:01:23.280]  То есть, наличие вот этого точка size в вьюхе, оно как бы подразумевает, что это такой size, который вот за вот единицы взяли и получили.
[01:01:23.280 --> 01:01:28.440]  А не сложный алгоритм, который посчитает, пошагает и что-то поделает.
[01:01:28.440 --> 01:01:30.440]  Ну, окей.
[01:01:34.720 --> 01:01:39.440]  Да, front и back это, скорее всего, random access.
[01:01:39.440 --> 01:01:41.440]  Нет, bidirectional.
[01:01:41.600 --> 01:01:45.800]  Потому что нам для back-а нужно шагнуть назад от sentinel.
[01:01:45.800 --> 01:01:49.240]  Ну вот да, а для front-а кажется не важно.
[01:01:49.240 --> 01:01:50.520]  Да, именно так.
[01:01:50.520 --> 01:01:54.920]  Да, для front-а действительно не важно forward.
[01:01:54.920 --> 01:01:58.480]  Ну и квадратные скобки random access.
[01:01:58.480 --> 01:01:59.240]  Окей.
[01:01:59.240 --> 01:02:08.440]  А, там вот про back как раз в требовании на back упоминается вот common range, как раз без которого, в принципе, на самом деле почти ничего нельзя сделать.
[01:02:08.440 --> 01:02:10.440]  Какой ужас.
[01:02:11.440 --> 01:02:17.440]  А, про то, что они совпадают, да?
[01:02:19.440 --> 01:02:21.440]  Да, я об этом.
[01:02:21.440 --> 01:02:22.440]  Окей, окей.
[01:02:22.440 --> 01:02:33.440]  Ну, я в других местах это не особо видел, так что про заявление, что почти ничего нельзя сделать, кажется оно сейчас опровергнется в походу дела лекции.
[01:02:33.440 --> 01:02:38.440]  Так, когда мы будем делать перерыв?
[01:02:39.440 --> 01:02:46.440]  Да, сейчас закончим про view here и, наверное, будет перерыв.
[01:02:46.440 --> 01:02:53.440]  Так вот, вопрос. Из всего вышесказанного, как вы считаете, где здесь view, а где здесь не view?
[01:02:53.440 --> 01:02:58.440]  Было бы круто, если бы кто-нибудь, кроме Андрея, ответил, потому что он точно знает.
[01:02:58.440 --> 01:03:13.440]  Никто не хочет отвечать. Так, почему у меня А? Вот так вот. Окей.
[01:03:17.440 --> 01:03:20.440]  Я могу тыкнуть пальцем в небо.
[01:03:20.440 --> 01:03:21.440]  Тыкай.
[01:03:21.440 --> 01:03:24.440]  Вот. Span, string view.
[01:03:24.440 --> 01:03:33.440]  Именно так. И именно на них построена вся идея view. Все view и чем-то похожи на них.
[01:03:33.440 --> 01:03:38.440]  Это не владеющие ссылки на range, по сути.
[01:03:38.440 --> 01:03:45.440]  Так же, как у вас есть unique pointer и есть просто указатель.
[01:03:45.440 --> 01:03:52.440]  Unique pointer владеет памятью, а указатель не владеет, он только указывает.
[01:03:52.440 --> 01:04:03.440]  Так же и в ranges. Range владеет памятью, а view только указывает на память некоторого диапазона.
[01:04:03.440 --> 01:04:13.440]  И так как, когда речь идет о парах итераторов, гораздо сложнее вообще определить, что значит владеть, а что значит не владеть,
[01:04:13.440 --> 01:04:18.440]  приходится вот такие танцы с бубном и сложную архитектуру строить.
[01:04:18.440 --> 01:04:20.440]  Ну, по-другому никак.
[01:04:20.440 --> 01:04:24.440]  Да, если про Span кто не знает, это самая простая view.
[01:04:24.440 --> 01:04:29.440]  Вот это уже точно пара, указатель на начало и размер.
[01:04:29.440 --> 01:04:35.440]  Очень удобно, чтобы описывать под массивы.
[01:04:35.440 --> 01:04:45.440]  То есть, или даже больше, принимать какой-то список или массив в какую-либо функцию.
[01:04:45.440 --> 01:04:53.440]  Вот если вы в своем коде, когда вам нужно там список имен каких-нибудь получить, например,
[01:04:53.440 --> 01:04:58.440]  используете vector std string, то вы крайне неправы.
[01:04:58.440 --> 01:05:08.440]  Потому что надо вам использовать span из string view или char звездочка в зависимости от ситуации и того, что вы дальше собрались делать.
[01:05:08.440 --> 01:05:11.440]  В идеале, конечно, span от string view.
[01:05:11.440 --> 01:05:20.440]  span может иметь статический размер, что примечательно, то есть как std array указанный в compile time, а может динамический.
[01:05:20.440 --> 01:05:23.440]  Там, соответственно, две специализации.
[01:05:23.440 --> 01:05:31.440]  И в чем профит, собственно, именно принимать span от string view, ну или вообще в чем сам span?
[01:05:31.440 --> 01:05:38.440]  В том, что вы тогда туда можете засунуть и vector, и array, и вообще любой другой контейнер, который последовательно хранит данные,
[01:05:38.440 --> 01:05:47.440]  который вам, возможно, прислала какая-то сишная библиотека, и не придется лишние выделения делать памяти.
[01:05:47.440 --> 01:05:52.440]  Зачем нам лишний раз выделять память, если она уже есть?
[01:05:52.440 --> 01:06:01.440]  Передача каких-нибудь векторов по ссылке, именно это подразумевает, что если у вас какой-то другой контейнер, извините, вам придется выделять лишнюю память.
[01:06:01.440 --> 01:06:04.440]  Так что эту штуку рекомендую.
[01:06:04.440 --> 01:06:08.440]  Используйте.
[01:06:08.440 --> 01:06:20.440]  Сейчас, насчет спана, насчет сравнения, ну там vector string против span string view, но, по-моему, они ж так просто, один на другой так просто не заменяется.
[01:06:20.440 --> 01:06:24.440]  Да, один на другой просто не заменяется.
[01:06:24.440 --> 01:06:27.440]  Но тут, да, более все сложно.
[01:06:27.440 --> 01:06:30.440]  Я объединил две мысли в одну.
[01:06:30.440 --> 01:06:31.440]  Да, и стало грустно.
[01:06:31.440 --> 01:06:33.440]  Мысли отдельные.
[01:06:33.440 --> 01:06:38.440]  Вектор по ссылке не передавайте, используйте span.
[01:06:38.440 --> 01:06:40.440]  И другая мысль.
[01:06:40.440 --> 01:06:45.440]  Стринги по ссылке не передавайте, используйте string view.
[01:06:45.440 --> 01:06:47.440]  Его просто копировать нужно.
[01:06:47.440 --> 01:06:49.440]  Это очень маленький тип.
[01:06:49.440 --> 01:06:52.440]  span вообще 4 байта может быть.
[01:06:52.440 --> 01:06:55.440]  Ну, в худшем случае 16.
[01:06:55.440 --> 01:06:59.440]  string view примерно так же.
[01:06:59.440 --> 01:07:06.440]  Вот, и да, почему забиндить vector string off на span string view не получится?
[01:07:06.440 --> 01:07:11.440]  Ну, вот так работают плюсы, к сожалению.
[01:07:11.440 --> 01:07:21.440]  То есть, вероятно, если у вас как бы подразумевается, что вы передаете именно стринги внутрь,
[01:07:21.440 --> 01:07:28.440]  то вам нужен span string off, скорее всего.
[01:07:28.440 --> 01:07:40.440]  Ну, вот мне при работе с Vulkan часто были нужны spans на char const звездочка const.
[01:07:40.440 --> 01:07:45.440]  То есть, spans из константных указателей на константные чары.
[01:07:45.440 --> 01:07:47.440]  Вот так вот.
[01:07:47.440 --> 01:07:54.440]  Это сишная API Vulkan, поэтому там приходится как бы с такими вещами сталкиваться.
[01:07:54.440 --> 01:08:04.440]  И когда хочешь все это как-то более-менее обернуть в плюсовый код, span очень помогает.
[01:08:04.440 --> 01:08:07.440]  Как-то так.
[01:08:07.440 --> 01:08:13.440]  Дальше у нас, собственно, как работать с этими концептами.
[01:08:13.440 --> 01:08:20.440]  Откуда вообще экземпляры, даже не так, откуда хотя бы типы удовлетворяющие им получить какие-нибудь интересные.
[01:08:20.440 --> 01:08:22.440]  Отчего можно добиться всем этим?
[01:08:22.440 --> 01:08:30.440]  Но перед этим мы делаем перерыв до 18.25.
[01:08:30.440 --> 01:08:38.440]  Прежде чем мы уйдем на перерыв, вот ты упомянул уже что-то там про common range.
[01:08:38.440 --> 01:08:43.440]  Я сказал, что без common range там особо ничего сделать не получится, в случае с back'ом.
[01:08:43.440 --> 01:08:49.440]  Там прикол с тем, что оказывается в определении bidirectional range вообще никак не констраинится с sentinel.
[01:08:49.440 --> 01:08:54.440]  То есть там опять же констраинится только итератор, что он должен быть bidirectional.
[01:08:54.440 --> 01:08:59.440]  Поэтому чтобы из-за константа делать back, нам нужно чтобы у нас sentinel был этим же итератором.
[01:08:59.440 --> 01:09:01.440]  Иначе, кажется, мы ничего не можем сделать.
[01:09:01.440 --> 01:09:03.440]  Закономерно.
[01:09:03.440 --> 01:09:08.440]  Какой-то интересный прикол, что нереально sentinel не констраинит, и надо каждый раз самому разбираться.
[01:09:08.440 --> 01:09:13.440]  Нет, не нужно каждый раз самому разбираться.
[01:09:13.440 --> 01:09:21.440]  У тебя почти во всех вещах, которые мы дальше будем обсуждать, там нет нужды с back'ом ничего делать, то есть send'ом.
[01:09:21.440 --> 01:09:23.440]  Там это тоже хватает.
[01:09:23.440 --> 01:09:30.440]  То есть не нужно зазря больше требований, чем по факту нужно требовать.
[01:09:30.440 --> 01:09:32.440]  Да, это верно.
[01:09:32.440 --> 01:09:39.440]  Единственное, что я могу упомянуть тут, это reverse.
[01:09:39.440 --> 01:09:47.440]  Да, если вы хотите зареверсить range, то, конечно, вам придется как бы менять местами, грубо говоря, begin и end.
[01:09:47.440 --> 01:09:50.440]  И это потребует все-таки вот этого common.
[01:09:50.440 --> 01:09:52.440]  И bidirectional, соответственно.
[01:09:52.440 --> 01:09:53.440]  И bidirectional, да.
[01:09:53.440 --> 01:09:57.440]  Все остальное вполне без этого живет, все эти концепции.
[01:09:57.440 --> 01:10:05.440]  Но там не упоминается просто этот шаблон, так что я даже так краем глазом его видел и особо не смотрел, что там.
[01:10:05.440 --> 01:10:07.440]  Ну ладно, разобрались. Теперь точно вернемся.
[01:10:07.440 --> 01:10:08.440]  Перерыв.
[01:10:12.440 --> 01:10:21.440]  Впереди самая сладкая, если мы более-менее поняли и переварили весь этот зоопарк концептов.
[01:10:21.440 --> 01:10:33.440]  Да, концепты для random access, bidirectional и прочих мы не смотрели, но они достаточно ожидаемы.
[01:10:34.440 --> 01:10:38.440]  То есть если мы все-таки посмотрим, несмотря на то, что их не вставил.
[01:10:45.440 --> 01:10:48.440]  Выглядят они ровно так, как вы бы и ожидали.
[01:10:48.440 --> 01:10:58.440]  Всякие увеличения, сравнения и прочие штуки.
[01:10:58.440 --> 01:11:06.440]  Можете почитать сами более внимательно, но если мы туда закопаемся, то мы вообще ничего не успеем.
[01:11:06.440 --> 01:11:08.440]  Поэтому идем дальше.
[01:11:08.440 --> 01:11:10.440]  Factory для ренджей.
[01:11:10.440 --> 01:11:22.440]  Это такой набор функций, классов и прочих штук, которые призваны доставать откуда-то вам ренджи, а если быть точнее, вьюхи.
[01:11:22.440 --> 01:11:26.440]  И первое factory это mtview.
[01:11:26.440 --> 01:11:32.440]  Да, дальше везде на слайдере мы увидим ренджеры.
[01:11:32.440 --> 01:11:36.440]  Если вы не знали, так можно на плюсах писать.
[01:11:36.440 --> 01:11:40.440]  То есть это как using, только для namespace.
[01:11:40.440 --> 01:11:42.440]  Очень удобно.
[01:11:42.440 --> 01:11:52.440]  Прямо как в Python, импорт нампай snp можно так же теперь.
[01:11:52.440 --> 01:11:56.440]  Я не помню, когда это добавили, но это очень удобно.
[01:11:56.440 --> 01:11:58.440]  Так вот, mtview.
[01:11:58.440 --> 01:12:00.440]  Ну, не о чем говорить.
[01:12:00.440 --> 01:12:04.440]  Это вьюха, которая просто empty.
[01:12:04.440 --> 01:12:08.440]  Так же, как и пустое множество, ровно одно и никакими свойствами оно не обладает.
[01:12:08.440 --> 01:12:12.440]  Или наоборот, всеми свойствами обладает.
[01:12:12.440 --> 01:12:16.440]  mtview, вот он можно использовать, если вдруг где-то нужно.
[01:12:16.440 --> 01:12:22.440]  SingleView – это вьюха на один элемент, который этот элемент в себе хранит.
[01:12:22.440 --> 01:12:26.440]  Конечно, там этот элемент должен всем требованиям, что вью – сам.
[01:12:26.440 --> 01:12:30.440]  А вью – это вью, который в себе хранит.
[01:12:30.440 --> 01:12:34.440]  А вью – это вью, который в себе хранит.
[01:12:34.440 --> 01:12:38.440]  Это вью, который в себе хранит.
[01:12:38.440 --> 01:12:42.440]  Конечно, там этот элемент должен всем требованиям, что вью – сам.
[01:12:42.440 --> 01:12:44.440]  Удовлетворять.
[01:12:44.440 --> 01:12:48.440]  То есть movable быть, default initializable, скорее всего.
[01:12:48.440 --> 01:12:54.440]  Ну и да, он, возможно, будет копироваться.
[01:12:54.440 --> 01:13:00.440]  Так что на сильно жирные объекты лучше не создавать SingleView.
[01:13:00.440 --> 01:13:06.440]  Ну и почему все требования на вьюху?
[01:13:06.440 --> 01:13:08.440]  Все операции заод единиц.
[01:13:08.440 --> 01:13:10.440]  Копирование, move, деструкторы, конструкторы.
[01:13:10.440 --> 01:13:16.440]  Потому что n считается именно размер вью.
[01:13:16.440 --> 01:13:22.440]  Несмотря на то, что в общем случае для вью нельзя определить понятие размер.
[01:13:22.440 --> 01:13:24.440]  Классно, да?
[01:13:24.440 --> 01:13:32.440]  Ну, наверное, как-то можно математически извернуться, и в стандарте это делается.
[01:13:32.440 --> 01:13:38.440]  Но понятно, что имеется в виду, так что не будем формализма даряться.
[01:13:38.440 --> 01:13:42.440]  Элемент 1, соответственно, все зовут единицы.
[01:13:42.440 --> 01:13:48.440]  И тут хочу упомянуть такую штуку, как inplace.
[01:13:48.440 --> 01:13:56.440]  Inplace не помню, когда добавили, но тоже очень полезная вещь.
[01:13:56.440 --> 01:13:58.440]  Встречается редко, а странно.
[01:13:58.440 --> 01:14:06.440]  Это такой тег, который позволяет выбрать один из конструкторов какого-то класса с конкретным смыслом.
[01:14:06.440 --> 01:14:12.440]  Со смыслом сконструируй именно там, где ты собираешься хранить.
[01:14:12.440 --> 01:14:16.440]  Где это может быть полезно?
[01:14:16.440 --> 01:14:22.440]  Например, у вас есть optional, и вы хотите optional mutex.
[01:14:22.440 --> 01:14:32.440]  Вы не можете mutex не мувать, не копировать, и по ссылке на mutex конструировать optional от mutex не получится.
[01:14:32.440 --> 01:14:34.440]  Соответственно, вам нужно как-то...
[01:14:34.440 --> 01:14:37.440]  Ну, у mutex нет параметров конструктора.
[01:14:37.440 --> 01:14:39.440]  Это, конечно, плохой пример.
[01:14:39.440 --> 01:14:41.440]  Какой-нибудь atomic.
[01:14:41.440 --> 01:14:44.440]  Хочется конкретное значение проинцидизировать его.
[01:14:45.440 --> 01:14:47.440]  И вот тут inplace пригождается.
[01:14:47.440 --> 01:14:59.440]  Он говорит, что single view выберет тот конструктор, который к std string передаст следующий аргумент.
[01:14:59.440 --> 01:15:03.440]  И это есть очень у многих классов теперь.
[01:15:03.440 --> 01:15:07.440]  Возможно, вас когда-нибудь это спасет, когда вы будете биться головой об стенку,
[01:15:07.440 --> 01:15:15.440]  пытаясь понять, как этот чертов конструктор сконструировать, контейнер сконструировать.
[01:15:15.440 --> 01:15:19.440]  Вот, ну, как-то так.
[01:15:19.440 --> 01:15:21.440]  Yota.
[01:15:21.440 --> 01:15:29.440]  Насчет того, как это произносить, русский вариант это все-таки yota, потому что имеется в виду греческая буква алфавита.
[01:15:29.440 --> 01:15:32.440]  По-английски ayota.
[01:15:32.440 --> 01:15:36.440]  Ай читается именно как ay.
[01:15:36.440 --> 01:15:41.440]  И выдает она то же самое, что range в питоне.
[01:15:41.440 --> 01:15:45.440]  Вот функция именно range.
[01:15:45.440 --> 01:15:49.440]  Или x-range, если у вас старый питон.
[01:15:49.440 --> 01:15:55.440]  То есть интервал отчисел, но не включая последнее, что более математично и логично.
[01:15:55.440 --> 01:15:59.440]  И почему вообще эта штука называется yota?
[01:15:59.440 --> 01:16:02.440]  Был когда-то такой язык APL.
[01:16:02.440 --> 01:16:05.440]  Может вы о нем слышали, может нет.
[01:16:05.440 --> 01:16:12.440]  И в те времена, когда его разрабатывали, компьютер это был mainframe,
[01:16:12.440 --> 01:16:21.440]  а терминал это был такой стол с печатной машинкой электронной, встроенной в него.
[01:16:21.440 --> 01:16:28.440]  И скорость передачи от mainframe к терминалу информации была очень низкой.
[01:16:28.440 --> 01:16:33.440]  Поэтому важно было как-то сэкономить на количество символов,
[01:16:33.440 --> 01:16:38.440]  которые используются, на количество текста, который программа занимает.
[01:16:38.440 --> 01:16:43.440]  Наоборот, из-за скорости, на количество текста было важно сэкономить.
[01:16:43.440 --> 01:16:50.440]  А из-за того, что печатные машинки, вот эти все-таки, ну они механические были, они на бумаге вам код печатали.
[01:16:50.440 --> 01:16:52.440]  Представляете?
[01:16:52.440 --> 01:16:56.440]  Нужно было экономить количество печатающих головок.
[01:16:56.440 --> 01:17:00.440]  Поэтому язык APL использовал лютый набор символов.
[01:17:00.440 --> 01:17:07.440]  И у них кода тогда не было, но вот они там были, греческие буквы разные, хитрые закорючки, квадратики, кружочки.
[01:17:07.440 --> 01:17:12.440]  В общем, код на APL выглядит просто бомбезно.
[01:17:12.440 --> 01:17:23.440]  И именно оттуда пошла вот эта традиция обозначать range из последовательно идущих чиселок целых греческой буквы йота.
[01:17:23.440 --> 01:17:27.440]  Там прям была реальная буква йота, которая прям печаталась на бумаге.
[01:17:27.440 --> 01:17:30.440]  Так что да, the more you know.
[01:17:30.440 --> 01:17:35.440]  И, как уже обещалось, он может быть бесконечным.
[01:17:35.440 --> 01:17:40.440]  Это view на все натуральные числа.
[01:17:40.440 --> 01:17:48.440]  И тут как раз играет вот это вот вся, все эти требования на асимптотику от единицы.
[01:17:48.440 --> 01:17:58.440]  Несмотря на то, что это view как бы смотрит на бесконечное количество данных,
[01:17:58.440 --> 01:18:00.440]  она ленивая.
[01:18:00.440 --> 01:18:04.440]  Так же, как у вас во второй домашке все было ленивое.
[01:18:04.440 --> 01:18:09.440]  Только во второй домашке все делалось через списки, а здесь через итераторы.
[01:18:09.440 --> 01:18:15.440]  И просто begin от йоты будет вам последовательно выдавать целые числа,
[01:18:15.440 --> 01:18:19.440]  помня внутри, на каком он по номеру сейчас числе.
[01:18:19.440 --> 01:18:23.440]  Это чем-то напоминает генераторы из питона в том числе.
[01:18:23.440 --> 01:18:29.440]  Да, соответственно вопрос, что такое end?
[01:18:29.440 --> 01:18:32.440]  Ну, это какой-то sentinel.
[01:18:32.440 --> 01:18:38.440]  Как уже было анонсировано, это специальный тип или специальное значение из стандарта.
[01:18:38.440 --> 01:18:40.440]  Unreachable sentinel.
[01:18:40.440 --> 01:18:47.440]  Его можно и нужно использовать для бесконечных ранжей.
[01:18:47.440 --> 01:18:50.440]  Так, да, я что-то забыл.
[01:18:50.440 --> 01:18:56.440]  У нас есть человек, который хочет рассказать доклад.
[01:18:56.440 --> 01:19:03.440]  Я думаю, да. Думаю, мы сейчас ускоримся и под конец можем прослушать докладик.
[01:19:03.440 --> 01:19:07.440]  Вот, unreachable sentinel.
[01:19:07.440 --> 01:19:12.440]  Ну и если посмотреть на там требования к этой йоте,
[01:19:12.440 --> 01:19:20.440]  от того, что мы будем, собственно, выдавать из нее,
[01:19:20.440 --> 01:19:23.440]  как раз внезапно требуется weekly incrementable.
[01:19:23.440 --> 01:19:25.440]  То есть это не только числа.
[01:19:25.440 --> 01:19:29.440]  Там может быть вообще что угодно, в том числе другие итераторы.
[01:19:29.440 --> 01:19:33.440]  И тут у вас сразу должно заиграть воображение о том,
[01:19:33.440 --> 01:19:41.440]  как можно функцию emits или tails из первой домашки реализовать.
[01:19:41.440 --> 01:19:44.440]  Ну ладно.
[01:19:44.440 --> 01:19:51.440]  Ну и можно свой на самом деле sentinel указать в шаблонном параметре, если вам так хочется.
[01:19:51.440 --> 01:20:00.440]  Ну и тут немножко странно все это сделано.
[01:20:00.440 --> 01:20:08.440]  То есть sentinel указывается для самого типа, который эта йота будет выдавать, то есть для int.
[01:20:08.440 --> 01:20:16.440]  И unreachable sentinel выдает при сравнении false вообще для любого типа, поэтому оно все работает.
[01:20:16.440 --> 01:20:22.440]  То есть формально int это как бы не особый итератор, но он таки weekly incrementable,
[01:20:22.440 --> 01:20:26.440]  а unreachable sentinel таки sentinel.
[01:20:26.440 --> 01:20:31.440]  Но вот потребовать sentinel for вот здесь мы как бы не можем и не хотим.
[01:20:31.440 --> 01:20:34.440]  Вам может показаться, что этот дизайн странный.
[01:20:34.440 --> 01:20:36.440]  Мне тоже так кажется.
[01:20:36.440 --> 01:20:38.440]  Но в этом определенно есть смысл.
[01:20:38.440 --> 01:20:46.440]  И, наверное, в будущем мы увидим хитрые извращения с йотой и поймем, зачем так сделано.
[01:20:46.440 --> 01:20:50.440]  Да.
[01:20:50.440 --> 01:20:54.440]  IStreamView. Вот оно.
[01:20:54.440 --> 01:21:01.440]  Как уже много раз упоминалось, это вьюха на последовательность объектов какого-то типа,
[01:21:01.440 --> 01:21:10.440]  которые надо явно указать, читаемых из стандартного потока ввода или другого какого-то потока.
[01:21:10.440 --> 01:21:15.440]  И вот здесь пример того, насколько все это кайфово может выглядеть.
[01:21:15.440 --> 01:21:18.440]  Делается IStreamStream.
[01:21:18.440 --> 01:21:20.440]  Туда записаны флоты.
[01:21:20.440 --> 01:21:24.440]  То есть это просто поток, который выдает данные из строки.
[01:21:24.440 --> 01:21:31.440]  Флоты записаны здесь через разные символы пробела.
[01:21:31.440 --> 01:21:35.440]  И мы делаем IStreamView.
[01:21:35.440 --> 01:21:46.440]  И внутри он, собственно, читает эти флоты через обычный оператор с двигом влево или вправо, наоборот, вправо.
[01:21:46.440 --> 01:21:50.440]  А дальше можно завязать вот такую смешную функцию,
[01:21:50.440 --> 01:21:55.440]  которая все данные из этого ренджа откопирует в какой-то другой итератор.
[01:21:55.440 --> 01:22:00.440]  Я думаю, в стандартной библиотеке эту функцию уже видели.
[01:22:00.440 --> 01:22:09.440]  И таким образом в три строчки мы, если не хотели вот это создавать и просто читать из CIN,
[01:22:09.440 --> 01:22:13.440]  то вообще в две, а не в три,
[01:22:13.440 --> 01:22:17.440]  считали данные, разделили их и вывели через другой сепаратор.
[01:22:17.440 --> 01:22:21.440]  По-моему, это достаточно красиво.
[01:22:21.440 --> 01:22:23.440]  Но едем дальше.
[01:22:23.440 --> 01:22:28.440]  Помимо factory, которые вам делают вьюхи откуда-то,
[01:22:28.440 --> 01:22:33.440]  есть так называемые адаптеры, которые одну вьюху превращают в другую.
[01:22:33.440 --> 01:22:40.440]  Вот это основной костяк того, что вообще есть в ренджерс и почему ренджерс это круто.
[01:22:40.440 --> 01:22:48.440]  Даже по названию вы можете, я думаю, уже догадаться, что все они делают.
[01:22:48.440 --> 01:22:52.440]  И важный момент, что все они это делают лениво.
[01:22:52.440 --> 01:22:59.440]  То есть все эти вещи все еще работают на бесконечных списках.
[01:22:59.440 --> 01:23:01.440]  Но помимо...
[01:23:01.440 --> 01:23:09.440]  Ну вот все вот эти штуки они лежат в ренджерс или в поднаймспейсе.
[01:23:09.440 --> 01:23:11.440]  Сейчас точно не скажу.
[01:23:11.440 --> 01:23:13.440]  Но это все классы.
[01:23:13.440 --> 01:23:17.440]  То есть это классы, которые вы можете сконструировать в другой вьюхе.
[01:23:17.440 --> 01:23:22.440]  И это будет как бы оберточка.
[01:23:22.440 --> 01:23:24.440]  Да, если да ренджерс вьюс все-таки лежит.
[01:23:24.440 --> 01:23:26.440]  Да, правильно.
[01:23:26.440 --> 01:23:29.440]  Но их использовать не рекомендуется.
[01:23:29.440 --> 01:23:32.440]  К каждому такому...
[01:23:36.440 --> 01:23:41.440]  Да, к каждому такому типу прилагается еще несколько очень похожих штук.
[01:23:41.440 --> 01:23:44.440]  Назовем их так.
[01:23:44.440 --> 01:23:46.440]  Вот здесь, кажется, Ви должно быть.
[01:23:46.440 --> 01:23:50.440]  Да, потому что... Нет, не Ви. Да.
[01:23:50.440 --> 01:23:52.440]  Вьюс должно вот здесь быть вписано.
[01:23:52.440 --> 01:23:55.440]  Ну да ладно. Возможно, оно и через просто ренджерс работает.
[01:23:55.440 --> 01:23:57.440]  Кажется, это inline namespace.
[01:23:57.440 --> 01:24:00.440]  А, вот так. Окей.
[01:24:00.440 --> 01:24:04.440]  Да, соответственно, должно и так работать. Окей.
[01:24:08.440 --> 01:24:10.440]  Так вот, на примере фильтра.
[01:24:10.440 --> 01:24:12.440]  Фильтр вью классу.
[01:24:12.440 --> 01:24:17.440]  Прилагается неблоид фильтр.
[01:24:19.440 --> 01:24:21.440]  Который работает точно так же.
[01:24:21.440 --> 01:24:24.440]  Но сейчас увидим в чем хитрость.
[01:24:24.440 --> 01:24:32.440]  Другая штука, которая вот сложно сказать, что это, скорее всего, просто функция.
[01:24:32.440 --> 01:24:41.440]  Фильтр, которая коррирует все эти штуки, если вы такое слово знаете из функционального программирования.
[01:24:41.440 --> 01:24:46.440]  Но попросту говоря, вместо того, чтобы все аргументы принимать через запятую,
[01:24:47.440 --> 01:24:56.440]  вот эти штуки принимают по одному аргументу и возвращают другую функцию, которая принимает следующий аргумент.
[01:24:56.440 --> 01:24:59.440]  То есть синтаксис вызова вот такой.
[01:24:59.440 --> 01:25:02.440]  В отдельных скобочках каждый раз новый аргумент указывать.
[01:25:02.440 --> 01:25:09.440]  А нужно это все затем, чтобы уметь делать вот так.
[01:25:09.440 --> 01:25:16.440]  Если вы программируете на Fsharp или Haskell или Scully тоже, вам сейчас должно быть очень радостно.
[01:25:16.440 --> 01:25:20.440]  Вот это, ну, собственно, из Bash вам это, скорее всего, будет знакомо.
[01:25:20.440 --> 01:25:22.440]  Вот Bash точно все должны знать.
[01:25:22.440 --> 01:25:24.440]  Это pipe.
[01:25:24.440 --> 01:25:27.440]  Он данные, которые написаны слева,
[01:25:27.440 --> 01:25:32.440]  пайпает в программу, которая лежит справа, грубо говоря.
[01:25:32.440 --> 01:25:38.440]  То есть вместо того, чтобы писать вот так, вы можете написать range, pipe, filter predicate.
[01:25:38.440 --> 01:25:41.440]  А потом опять pipe что-то.
[01:25:41.440 --> 01:25:43.440]  И еще pipe что-то.
[01:25:43.440 --> 01:25:45.440]  И таким образом делать цепочки.
[01:25:45.440 --> 01:25:47.440]  Вот.
[01:25:47.440 --> 01:25:51.440]  Но вот эта штука по науке на самом деле называется range adapter object.
[01:25:51.440 --> 01:25:56.440]  Даже не customization point object, а именно range adapter object.
[01:25:56.440 --> 01:26:04.440]  Они не все предоставляют возможности, как у customization point object.
[01:26:04.440 --> 01:26:06.440]  То есть не все их можно кастомизировать.
[01:26:06.440 --> 01:26:12.440]  Но по большей части можно, потому что некоторые ренджи, некоторые бьюхи
[01:26:12.440 --> 01:26:16.440]  можно более оптимально фильтровать или какие-то другие действия с ними делать.
[01:26:16.440 --> 01:26:18.440]  Вот.
[01:26:18.440 --> 01:26:21.440]  А нижние штуки называются range adapter closure.
[01:26:21.440 --> 01:26:25.440]  Как-то так.
[01:26:25.440 --> 01:26:27.440]  Вот.
[01:26:27.440 --> 01:26:32.440]  И утверждается, что в целом и общем все вот эти вот действия, они будут эквивалентны.
[01:26:32.440 --> 01:26:35.440]  Которые вы можете сделать.
[01:26:35.440 --> 01:26:38.440]  На самом деле эквивалентны с какой точки зрения?
[01:26:38.440 --> 01:26:40.440]  С точки зрения результата.
[01:26:40.440 --> 01:26:46.440]  Потому что если вы напрямую сконструируете класс соответствующего адаптера,
[01:26:46.440 --> 01:26:53.440]  то вот эти кастомизации через Nebloid, просто фильтр,
[01:26:53.440 --> 01:26:56.440]  эти кастомизации не будут сделаны.
[01:26:56.440 --> 01:26:59.440]  Соответственно у вас может производительность снизиться
[01:26:59.440 --> 01:27:03.440]  из-за того, чтобы более специализированные алгоритмы не использовались.
[01:27:03.440 --> 01:27:06.440]  Ну, в идеале, конечно, пайпы.
[01:27:06.440 --> 01:27:08.440]  Пайпы это теперь мечта.
[01:27:08.440 --> 01:27:11.440]  Мы все теперь используем пайпы.
[01:27:11.440 --> 01:27:13.440]  Да, так что напрямую класс не конструируйте.
[01:27:13.440 --> 01:27:17.440]  Используйте свободные функции.
[01:27:17.440 --> 01:27:27.440]  Окей.
[01:27:27.440 --> 01:27:29.440]  Пример с этими пайпами.
[01:27:29.440 --> 01:27:33.440]  Взяли все числа от 0 до бесконечности.
[01:27:33.440 --> 01:27:39.440]  Пофильтровали по модулю 3, чтобы был не 0.
[01:27:39.440 --> 01:27:43.440]  А дальше взяли и возвели в квадрат.
[01:27:43.440 --> 01:27:50.440]  А потом дропнули префикс, который меньше 20.
[01:27:50.440 --> 01:27:54.440]  То есть пока числа меньше 20, выкидываем их из префикса.
[01:27:54.440 --> 01:27:57.440]  И выводим результат.
[01:27:57.440 --> 01:27:59.440]  Ну, вернее, не весь.
[01:27:59.440 --> 01:28:02.440]  Если бы мы здесь убрали вот эту штучку,
[01:28:02.440 --> 01:28:06.440]  то мы бы тут в вечном цикле застряли.
[01:28:06.440 --> 01:28:11.440]  А так мы взяли только первые пять.
[01:28:11.440 --> 01:28:15.440]  И получили ровно то, что ожидали.
[01:28:15.440 --> 01:28:17.440]  Можно сказать, что это прекрасно.
[01:28:17.440 --> 01:28:20.440]  Погоду портит только одно.
[01:28:20.440 --> 01:28:25.440]  Вот буквы, начиная отсюда и заканчивая вот сюда,
[01:28:25.440 --> 01:28:28.440]  они не имеют отношения к делу.
[01:28:28.440 --> 01:28:30.440]  Это тупой boilerplate.
[01:28:30.440 --> 01:28:35.440]  Копипаста на трех строчках абсолютно одинаковая.
[01:28:35.440 --> 01:28:41.440]  Ну, сделать с этим, кроме как macros, ничего нельзя.
[01:28:41.440 --> 01:28:45.440]  Ждем, пока кто-нибудь сильные стойки
[01:28:45.440 --> 01:28:48.440]  и протолкнет через комитет стандартизации
[01:28:48.440 --> 01:28:51.440]  какой-нибудь краткий синтаксис.
[01:28:51.440 --> 01:28:53.440]  Потому что, если вы в Haskell посмотрите,
[01:28:53.440 --> 01:28:57.440]  там это выглядит просто как
[01:29:00.440 --> 01:29:04.440]  backslash x, стрелочка и вот это.
[01:29:04.440 --> 01:29:07.440]  То есть гораздо меньше символов.
[01:29:07.440 --> 01:29:10.440]  А в случае возведения в квадрат еще лучше.
[01:29:10.440 --> 01:29:15.440]  В круглых скобках звездочка, звездочка, два.
[01:29:15.440 --> 01:29:17.440]  Все.
[01:29:17.440 --> 01:29:19.440]  И это сразу работает как функция
[01:29:19.440 --> 01:29:20.440]  возведения в квадрат.
[01:29:20.440 --> 01:29:22.440]  Тоже самое с меньше 20.
[01:29:22.440 --> 01:29:24.440]  В круглых скобках меньше 20.
[01:29:24.440 --> 01:29:27.440]  И, конечно, без такого сахара
[01:29:27.440 --> 01:29:29.440]  все еще не очень удобно пользоваться
[01:29:29.440 --> 01:29:31.440]  вот этой мишенерией.
[01:29:31.440 --> 01:29:34.440]  Очень ждем сахара, чтоб код был маленьким,
[01:29:34.440 --> 01:29:36.440]  понятным и не стеной.
[01:29:38.440 --> 01:29:40.440]  Вот.
[01:29:40.440 --> 01:29:44.440]  Да, взяв побольше, получим побольше.
[01:29:44.440 --> 01:29:48.440]  При этом все вычисления, они будут откладываться
[01:29:48.440 --> 01:29:51.440]  до момента, когда вот этот цикл for
[01:29:51.440 --> 01:29:53.440]  соберется инкрементить итератор,
[01:29:53.440 --> 01:29:55.440]  который внутри него сидит.
[01:29:57.440 --> 01:30:00.440]  Вот когда мы инкрементим, вот тогда
[01:30:00.440 --> 01:30:02.440]  начнет вся эта цепочка срабатывать.
[01:30:02.440 --> 01:30:05.440]  Filter, transform, drop while.
[01:30:07.440 --> 01:30:09.440]  Да.
[01:30:10.440 --> 01:30:15.440]  И кажется более того, в юхе почти, наверное,
[01:30:15.440 --> 01:30:19.440]  кэшируют результаты, поэтому когда мы
[01:30:19.440 --> 01:30:21.440]  опять запустимся, оно будет работать
[01:30:21.440 --> 01:30:23.440]  чуть быстрее, скорее всего.
[01:30:23.440 --> 01:30:25.440]  Это зависит от имплементации.
[01:30:26.440 --> 01:30:28.440]  Но, кажется, в стандарте ничего не запрещает
[01:30:28.440 --> 01:30:29.440]  это кэшировать.
[01:30:29.440 --> 01:30:31.440]  А некоторые кэширования...
[01:30:31.440 --> 01:30:33.440]  Кажется, там есть некоторые запреты,
[01:30:33.440 --> 01:30:35.440]  поскольку в юхе, вроде, должны быть там
[01:30:35.440 --> 01:30:37.440]  за константу копируемыми.
[01:30:43.440 --> 01:30:44.440]  Можно дропать кэш?
[01:30:44.440 --> 01:30:46.440]  Копировать, да.
[01:30:46.440 --> 01:30:48.440]  То есть это никто не запрещает.
[01:30:49.440 --> 01:30:51.440]  Ну да, мысль про дроп кэша, конечно, интересная,
[01:30:51.440 --> 01:30:54.440]  но надо читать тогда какой-нибудь Lipsy++.
[01:30:54.440 --> 01:30:56.440]  Там кэшей не так много.
[01:30:57.440 --> 01:30:59.440]  Мы сейчас увидим еще про кэши,
[01:30:59.440 --> 01:31:00.440]  это тема бодрая.
[01:31:00.440 --> 01:31:02.440]  А, собственно, кажется...
[01:31:04.440 --> 01:31:06.440]  Нет, не прямо сейчас, чуть попозже.
[01:31:06.440 --> 01:31:08.440]  Так, что мы здесь делаем?
[01:31:08.440 --> 01:31:11.440]  Мы берем вектор, мы его фильтруем
[01:31:11.440 --> 01:31:16.440]  по нечетным и проверяем, range ли это.
[01:31:19.440 --> 01:31:21.440]  Собственно, пока мы проверяем сам вектор.
[01:31:21.440 --> 01:31:23.440]  Вектор от range.
[01:31:23.440 --> 01:31:25.440]  Вопрос.
[01:31:28.440 --> 01:31:30.440]  Ну, вроде, да.
[01:31:30.440 --> 01:31:31.440]  Да.
[01:31:31.440 --> 01:31:33.440]  А в юхе?
[01:31:37.440 --> 01:31:39.440]  Кажется, нет.
[01:31:39.440 --> 01:31:41.440]  Нет.
[01:31:41.440 --> 01:31:43.440]  Вопрос, почему?
[01:31:49.440 --> 01:31:51.440]  Ну, он за константу не копируется.
[01:31:51.440 --> 01:31:53.440]  Ну, это да.
[01:31:53.440 --> 01:31:55.440]  Почему его не сделали в юхе?
[01:31:55.440 --> 01:31:57.440]  Но с точки зрения концепта,
[01:31:57.440 --> 01:31:59.440]  почему вот концепт вью провалился?
[01:31:59.440 --> 01:32:01.440]  Потому что мы помним,
[01:32:01.440 --> 01:32:03.440]  что на вьюху нужно явно подписаться.
[01:32:03.440 --> 01:32:05.440]  То есть явно сказать,
[01:32:05.440 --> 01:32:07.440]  я хочу быть вьюхой.
[01:32:07.440 --> 01:32:09.440]  Отнаследовавшись от интерфейса
[01:32:09.440 --> 01:32:11.440]  либо от viewbase.
[01:32:11.440 --> 01:32:13.440]  Вот, вектор этого не делает.
[01:32:13.440 --> 01:32:15.440]  Почему он этого не делает?
[01:32:15.440 --> 01:32:17.440]  Потому что не за константу
[01:32:17.440 --> 01:32:19.440]  и не за копирование и прочей штуки.
[01:32:19.440 --> 01:32:21.440]  Хотя нет.
[01:32:23.440 --> 01:32:25.440]  Ну, вот, конечно, за константу.
[01:32:27.440 --> 01:32:29.440]  А вот копирование уже нет.
[01:32:29.440 --> 01:32:31.440]  Да, копирование не за константу
[01:32:31.440 --> 01:32:33.440]  и деструктор
[01:32:33.440 --> 01:32:35.440]  не за константу.
[01:32:35.440 --> 01:32:37.440]  Нет, деструктор за константу.
[01:32:37.440 --> 01:32:39.440]  Да, не за константу.
[01:32:39.440 --> 01:32:41.440]  Да.
[01:32:41.440 --> 01:32:43.440]  Да.
[01:32:43.440 --> 01:32:45.440]  Ой.
[01:32:45.440 --> 01:33:13.160]  а odd это range, да, а view, по-моему да, ну конечно, мы же говорили, что полное название класса,
[01:33:13.160 --> 01:33:18.960]  который вернется отсюда, это фильтр подчеркивания view, то есть все эти адаптеры, они являются вьюхами,
[01:33:18.960 --> 01:33:29.480]  вообще говоря. Вдезапный флешбек к какой по номеру домашки, четвертой, наверное, да, четвертой,
[01:33:29.480 --> 01:33:38.840]  этот код распечатает нам название типа, если вы решали домашку, вы понимаете как, если нет,
[01:33:38.840 --> 01:33:47.160]  pretty function подробно выведет название текущей функции, когда мы вызовем эту функцию от
[01:33:47.160 --> 01:33:57.040]  какого-то значения, в тип a выведется тип этого значения, и при полном выведении типа текущей
[01:33:57.040 --> 01:34:03.400]  функции, название текущей функции, шаблонные аргументы тоже полностью выведутся, поэтому,
[01:34:03.400 --> 01:34:12.840]  если мы вырежем какой-то префикс и какой-то конец из того, что pretty function вернул,
[01:34:12.840 --> 01:34:21.880]  мы получим только название типа a, текстовое. Конечно, оно зависит от платформы, но это хоть
[01:34:21.880 --> 01:34:29.880]  что-то, вот, хин для тех, кто еще не начал четвертую домашку делать, хотя пора уже. Вот, и теперь мы
[01:34:29.880 --> 01:34:42.640]  с помощью этой функции посмотрим на odd, какой у него тип, а вот такой, filter view от ref view от
[01:34:42.640 --> 01:34:49.680]  вектора, ну и лямбды, которую мы использовали для того, чтобы фильтровать, то есть, заметьте,
[01:34:49.680 --> 01:34:58.120]  все в compile-time хранится, все типы сохранены, никакого op, никакого type-raiser, ничего, все
[01:34:58.120 --> 01:35:10.360]  очень строго, и это общий подход всей библиотеки ranges. Если вам нужно type-raiser, явно скажите об этом,
[01:35:10.360 --> 01:35:18.200]  и вообще вот такой весь подход postmodern C++, не важно, что у вас три-охотажные шаблонные ошибки,
[01:35:18.200 --> 01:35:23.720]  не важно, что там типы такие, что просто сердечный приступ схватит, главное, что это работает
[01:35:23.720 --> 01:35:35.360]  оптимально по памяти и времени, если вы хотите забить и сделать медленней, пожалуйста, anyunique мы
[01:35:35.360 --> 01:35:41.680]  долго и упорно пытались разобрать, возможно, не поняли в итоге, но для view, как вы понимаете,
[01:35:41.680 --> 01:35:49.400]  тоже можно написать аналог anyunique, anyview в стандарте пока его нет, и что-то не торопится
[01:35:49.400 --> 01:35:57.360]  добавлять, что самое странное, но когда-нибудь, когда-нибудь, возможно, просто будет anyunique,
[01:35:57.360 --> 01:36:05.920]  на который сделают alias для view, возможно, из-за того, что одно другое дублирует, решили как бы не
[01:36:05.920 --> 01:36:13.800]  добавлять вперед паровозом, вот, но тут есть странная штука refview, которую мы пока не видели,
[01:36:13.800 --> 01:36:25.400]  которая нам пока не понятна, да, ну, скоро еще посмотрим на нее, пока придемся к этому примеру и
[01:36:25.400 --> 01:36:35.440]  чуть его поменяем, мы добавили const перед вектором, вопрос, будет ли он range и view или view?
[01:36:43.800 --> 01:37:00.560]  на range все еще будет, куда он денется? а view? кажется, все еще нет, конечно, ничего не изменилось,
[01:37:00.560 --> 01:37:10.280]  он все еще не подписывался на быть view, не наследует ни viewbase, ни view interface, ну,
[01:37:10.280 --> 01:37:18.040]  а в константной range это вполне обыденное, ничего плохого, а вот теперь вот так вот,
[01:37:18.040 --> 01:37:26.480]  теперь константным стало view, причем вот это вот filter view, а вектор теперь обычный,
[01:37:26.480 --> 01:37:32.880]  вопрос, будет ли эта штука range и будет ли view?
[01:37:40.280 --> 01:37:51.480]  range она, наверное, все еще будет, так,
[01:37:58.320 --> 01:38:08.320]  да, наверное, и view и будет, просто не мутаблюем, ну, это вообще-то, интересно, а почему?
[01:38:08.320 --> 01:38:20.880]  ага, и тут мы подходим к вопросу cache, помните требование на симпнотику begin?
[01:38:22.880 --> 01:38:31.520]  я обратил внимание, что там амортизированная от единицы, а теперь представьте, мы потеряли
[01:38:31.520 --> 01:38:41.520]  амортизацию на первом? если вы хотите отформировать все натуральные числа, делится на миллион,
[01:38:41.520 --> 01:38:55.720]  первое число, которое делится на миллион, оно не очень близко, ну ладно, не очень хороший пример,
[01:38:55.720 --> 01:39:08.840]  наверное, более, просто хотим отфильтровать какие-то числа по делящимся на два,
[01:39:08.840 --> 01:39:20.400]  что будет begin у такого фильтра view? первое число, делящееся на два, но это первое число,
[01:39:20.400 --> 01:39:25.880]  делящееся на два, может быть в любой позиции в массиве, как в самом начале, так и в самом конце,
[01:39:25.880 --> 01:39:35.200]  если оно в самом конце, то увеличивая размер массива, а симптотика begin очевидно становится от n,
[01:39:35.200 --> 01:39:46.880]  беда, но нам позволено амортизировать, поэтому мы можем сохранить, закышировать эту начальную
[01:39:46.880 --> 01:39:55.240]  позицию первое число, удовлетворяющую предикату, скорее всего, оно будет закышировано в момент
[01:39:55.240 --> 01:40:02.040]  первого запуска begin, но может и в конструкторе, я не знаю детали имплементации, но тем не менее,
[01:40:02.040 --> 01:40:11.840]  как только мы его уже закышировали, мы вот эти n монет и тратили, а дальше мы только по одной
[01:40:11.840 --> 01:40:20.840]  монете будем тратить, то есть за счет амортизации как раз и получается, что ура от единицы,
[01:40:20.840 --> 01:40:27.800]  только первая операция будет занимать от n, последующие сколько угодно операции от единицы,
[01:40:27.800 --> 01:40:38.080]  честно, ну и да, мутабельным этот фильтр не пометили, поэтому как только мы помещаем фильтр view
[01:40:38.080 --> 01:40:46.200]  как const, мы не можем в этот кэш писать и читать, и мы проиграли, почему его не пометили мутабельным,
[01:40:46.200 --> 01:40:51.760]  я не знаю, вероятно, тоже какие-то проблемы вылезают, надо почитать код библиотека,
[01:40:51.760 --> 01:41:02.800]  да, если чуть подробнее разбираться, мы хотим, чтобы были begin end, а у фильтра view begin end
[01:41:02.800 --> 01:41:09.960]  константных нет, то есть вот именно эта ошибка компиляции у нас будет на деле, вот и помимо
[01:41:09.960 --> 01:41:17.720]  фильтра view есть еще несколько таких штук, кто-нибудь сможет объяснить, почему они тоже, вернее так,
[01:41:17.720 --> 01:41:29.320]  давайте почему drop while может такую же проблему испытывать? ну drop while очень похож на фильтр,
[01:41:30.200 --> 01:41:34.800]  ну да, нам нужно первый элемент как-то найти, мы собрались из начала выкидывать,
[01:41:34.800 --> 01:41:41.280]  пока предикат верен, та же ситуация, что в фильтре, а вот drop view со звездочкой,
[01:41:41.280 --> 01:41:47.800]  в каких случаях const drop view не view?
[01:41:59.560 --> 01:42:06.880]  наверное, это зависит от итераторов, вернее, их категорий, у того, что откуда мы drop-ы,
[01:42:08.880 --> 01:42:15.680]  давайте подумаем, можем ли мы от единицы легко и просто drop-нуть первые десять элементов,
[01:42:15.680 --> 01:42:33.880]  вернее, не так, первые n пополам элементов, вот тогда точно все строго, конечно, не можем,
[01:42:33.880 --> 01:42:39.280]  да, n зависит от n, соответственно, если мы собрались drop-ать первые n пополам элементов,
[01:42:39.280 --> 01:42:49.360]  то мы проиграли, это делается за от n, и нам нужно кашировать, но если у нас random access
[01:42:49.360 --> 01:42:58.600]  итератор, то мы можем его взять и сдвинуть, наверное, пополам за от единицы, да, то есть тут не
[01:42:58.600 --> 01:43:03.520]  нужно просматривать каждый элемент, чтобы понять, можем ли ему drop-нуть или нет, когда у нас слабый
[01:43:03.520 --> 01:43:10.920]  итератор, мы обязаны по одному разу incrementить, incrementить, incrementить, когда random access взяли
[01:43:10.920 --> 01:43:23.720]  хоп и дошли, как-то так, теперь небольшой сюрприз о том, как это работает в итоге, что выведется,
[01:43:33.520 --> 01:43:40.560]  предположение,
[01:43:47.680 --> 01:43:55.000]  если это конкурится, то кажется, первый элемент вектор будет перезаписан, а нет, сейчас,
[01:43:55.000 --> 01:44:07.360]  еще не первый, а второй тогда, нет, ну что мы тут делаем, мы взяли вектор с вот таким
[01:44:07.360 --> 01:44:14.480]  контентом, мы отфильтровали только те элементы, которые нечетные, и уже после того, как создали
[01:44:14.480 --> 01:44:24.080]  вьюху, а вот это собственно и дает ответ на вопрос, а в какой момент каширование происходит,
[01:44:24.080 --> 01:44:32.320]  ну да, каширование происходит все-таки в момент первого бигина, возможно это implementation
[01:44:32.320 --> 01:44:40.720]  defined, а возможно нет, тут немножко все, что произошло, ну смотри, при создании фильтр вью,
[01:44:40.720 --> 01:44:46.400]  ничего не произошло, вообще ничего, ну понятно, а при первом вызове бигина, оно нашло первый
[01:44:46.400 --> 01:44:54.480]  нечетный в векторе, фильтр вью по ссылке вектора хранит, да, это вью, соответственно,
[01:44:54.480 --> 01:45:06.360]  изменив этот вектор, результат вьюхи тоже изменился, да, а если вот так, выведется ли пятерка в самом
[01:45:06.360 --> 01:45:15.560]  начале или нет, не выведется, потому что каширование произошло теперь вот здесь,
[01:45:15.560 --> 01:45:26.680]  где первый раз бигин вызвался, то есть тени вьюхи это side-effect, как с этим мирить,
[01:45:26.680 --> 01:45:33.960]  звучит как волатайл, да, немножечко, как с этим мириться и как с этим жить, я не уверен, я не знаю,
[01:45:33.960 --> 01:45:39.880]  хорошо ли это или плохо или норма это, но непонятно, как изменить дизайн библиотеки,
[01:45:39.880 --> 01:45:51.560]  чтобы стало лучше, так что да, запомните, что лучше не мутировать ваш контейнер, пока у вас
[01:45:51.560 --> 01:45:57.360]  хотя бы одна вьюха на него есть, потому что вообще говоря, есть такое понятие, как инвалидация
[01:45:57.360 --> 01:46:04.840]  из итераторов, да, помним о нем, если мы вектор что-то запушбечим, итераторы могут инвалидироваться,
[01:46:04.840 --> 01:46:10.280]  если он увеличил свой размер, вьюхи состоят из итераторов, вьюхи тоже инвалидируются,
[01:46:10.280 --> 01:46:24.080]  но когда мы пишем именно что-то в контейнер, они добавляем, то есть как бы мы содержимое
[01:46:24.080 --> 01:46:31.160]  контейнера меняем, а не его самого, вроде как ничего не инвалидируется, но при этом результат
[01:46:31.160 --> 01:46:44.760]  начинает меняться, и вот это как бы так типа, ну странно немножко, ну ладно, view, take view,
[01:46:44.760 --> 01:46:55.320]  я забыл, что я на этом моменте хотел сказать, давайте просто посмотрим, как работают вообще
[01:46:55.320 --> 01:47:02.320]  эти классы в вьюхи, адаптеры, шаблонный аргумент view наследует view interface по CRTP,
[01:47:02.320 --> 01:47:13.920]  и да, ну имеет какой-то конструктор от того, что им требуется, а, нет, я все еще не вспомнил,
[01:47:13.920 --> 01:47:25.320]  что хотел сказать, да, я хотел вернуться к, помните, у нас там некоторый ref view был,
[01:47:25.320 --> 01:47:33.000]  когда мы выводили тип того, что получилось при фильтрации вектора, там был не просто filter view
[01:47:33.000 --> 01:47:41.520]  от вектора, а filter view от reference view, или что-то такое ref view, от вектора, вот откуда взялся этот
[01:47:41.520 --> 01:47:49.800]  промежуточный ref view, если во всех этих вьюхах, да, take пример, ну в фильтре так же, во всех
[01:47:49.800 --> 01:47:58.640]  из них принимаются именно вьюха, а мы передали вектор, и с одной стороны, как-то кажется,
[01:47:58.640 --> 01:48:03.720]  что должна была быть ошибка, вектор же не является вьюхой, но с другой стороны,
[01:48:03.720 --> 01:48:07.760]  там волшебным образом получился ref view, как это могло произойти?
[01:48:07.760 --> 01:48:15.640]  ну кто-то за нас сделал вьюху. ну как она могла здесь появиться сама?
[01:48:15.640 --> 01:48:24.320]  какая-то новая языковая фишка 17-х плюсов помогла. а, понятно, дедакшн гайды. да,
[01:48:24.320 --> 01:48:34.960]  именно так, да, сейчас, что, да, а, тут все это дальше показывается, я что-то сбил все совсем,
[01:48:34.960 --> 01:48:43.640]  да, собственно, вызвали take view, посмотрели что внутри, а там ref view, и да, ответ дедакшн гайды,
[01:48:43.640 --> 01:48:54.800]  написано такое дедакшн гайд, если нам на обход пришел range, то считаем, что наш шаблонный аргумент
[01:48:54.800 --> 01:49:07.000]  это некоторый alt, то есть еще не ref view внезапно. вопрос, а вот так она сработает тогда, по логике,
[01:49:07.000 --> 01:49:11.840]  пока мы не узнали, как это работает внутри вот этот alt, мы можем пока только догадки строить,
[01:49:11.840 --> 01:49:20.640]  должно ли вообще такое компилиться? используйте здравый смысл.
[01:49:20.640 --> 01:49:28.680]  это будет view, которая будет неволидна уже после создания своего, или что?
[01:49:28.680 --> 01:49:34.280]  ну, если бы это компилировалось, то да, но, конечно, это не должно компилироваться,
[01:49:34.280 --> 01:49:39.540]  мы не хотим такие ошибки глупые, мы хотим вообще это запретить на уровне вот в момент
[01:49:39.540 --> 01:49:45.960]  компиляции, проверить и не дать выстрелить себе в ногу, это тоже один из девизов postmodern c++,
[01:49:45.960 --> 01:49:53.400]  что все проверить на этапе компиляции и чтобы никаких сегментейшн фолтов желательно хотелось бы.
[01:49:53.400 --> 01:50:01.760]  вот, ну и создав временный вектор и записав его в вьюху, или создав вьюху на него,
[01:50:01.760 --> 01:50:09.880]  что вообще могло получиться? вьюха не владеет памятью, а вектор временный, и он удалится,
[01:50:09.880 --> 01:50:14.320]  кто будет владеть памятью? непонятно. соответственно, это не должно компилироваться,
[01:50:14.320 --> 01:50:22.080]  но здесь, заметьте, универсальная ссылка. то бишь, сорвали это, все еще будет нормально работать,
[01:50:22.080 --> 01:50:29.600]  и в alt передастся rvalue. и, ну, вот в таком случае ситуация точно такая же.
[01:50:29.600 --> 01:50:49.600]  окей, а как это вообще работает с alt? alt это alias, оно принимает некоторый range,
[01:50:49.600 --> 01:50:56.440]  но не просто, а viewable range. то есть, далеко не для всех ранжей это пройдет.
[01:50:56.440 --> 01:51:06.520]  сейчас увидим почему. ну и да, оно вызывает функцию all, но эта функция не настоящая,
[01:51:06.520 --> 01:51:16.120]  она как бы опять волшебная, если мне память не изменяет. она опять работает вот по вот этим
[01:51:16.120 --> 01:51:23.360]  приоритетам. пытаемся, то не получилось, все не получилось, третье. если нам уже вьюху прислали,
[01:51:23.360 --> 01:51:31.320]  то ничего делать не надо, просто берем эту вьюху и используем. ну, убрав с нее всякие ссылки и прочую
[01:51:31.320 --> 01:51:41.760]  фигню. а если же прислали что-то другое, то мы сначала попробуем сконструировать refview,
[01:51:41.760 --> 01:51:51.400]  тот самый, для векторов он получился, помните? а если и это не вышло, то subrange. и тут придется
[01:51:51.400 --> 01:51:59.840]  еще накидать концептов. да, меня самого смущает эта обилие. очень мало примеров,
[01:51:59.840 --> 01:52:06.280]  где вот эта вот тонкая кастомизация действительно нужна. слишком мало. но да ладно. borrowed range
[01:52:06.280 --> 01:52:15.480]  это range, который либо lvalue-reference, то есть какая-нибудь lvalue-ссылка на вектор вполне
[01:52:15.480 --> 01:52:25.120]  подходит. либо должна быть пометка enable borrowed range. но эта пометка уже делается не
[01:52:25.120 --> 01:52:33.040]  через наследование, через специализацию гуля. почему? ну потому. консистентность это не одна
[01:52:33.040 --> 01:52:41.440]  из ярких сторон стандартной библиотеки. ну да ладно. и viewable range, который мы видели,
[01:52:41.440 --> 01:52:50.000]  вот этот all t, он хочет viewable range. и viewable range это range, который либо borrowed range,
[01:52:50.000 --> 01:52:59.000]  который мы только что увидели, либо view. да, то есть непонятно зачем еще раз требовать,
[01:52:59.000 --> 01:53:09.080]  что это range, но видимо это чтобы ошибки концептов были более понятны. ну в случае с view и все
[01:53:09.080 --> 01:53:15.320]  понятно, надо только понять, зачем еще приносить вот этот странный borrowed range. какие вообще use
[01:53:15.320 --> 01:53:26.360]  кейсы? ну use case вполне понятен. мы его уже видели для lvalue-reference, по крайней мере. да, и в итоге
[01:53:26.360 --> 01:53:33.440]  оно все получается так. и когда мы просто создали переменную вектора vv и передали ее в фильтр,
[01:53:33.440 --> 01:53:42.400]  вот эта vv, это lvalue ссылка на вектор. она подходит под borrowed range, потому что является lvalue
[01:53:42.400 --> 01:53:53.640]  ссылкой на range. и все попадает в wall и все нормально. но дальше оно почему-то попадает в reference view и
[01:53:53.640 --> 01:54:00.480]  надо для этого посмотреть, чтобы понять почему на сам класс. выглядит страшно? знаю. давайте по
[01:54:00.480 --> 01:54:09.880]  порядку. сверху вниз, во-первых, оно принимает range и требует, чтобы это был некоторый объектный
[01:54:09.880 --> 01:54:18.680]  тип. ну это так уже, типа проверка на адекватность происходящего. самое главное в конструкторе,
[01:54:18.680 --> 01:54:29.880]  а не в самом классе. здесь требуется different from refview t, то есть t, который не является другим
[01:54:29.880 --> 01:54:40.520]  refview. ну это такая защита от клупа и рекурсии. и чтобы конструктор копирования все-таки именно
[01:54:40.520 --> 01:54:53.200]  он вызывался, а не вот эта штука. а требуется convertible2 для r, который у нас основной. то есть
[01:54:53.200 --> 01:55:02.200]  если там t это lvalue ссылка на вектор, как у нас было, то таки да, convertible2 t r% будет работать,
[01:55:02.200 --> 01:55:08.640]  потому что t это вектор m%, r будет вектор, ну и мы один и тот же тип подставили. а дальше
[01:55:08.640 --> 01:55:17.320]  странный костылек. есть такая функция fun, которая принимает только lvalue ссылку и требуется,
[01:55:17.320 --> 01:55:28.760]  чтобы ее можно было вызвать от t. то есть чтобы t было некоторым подобием lvalue ссылки, в каком-то
[01:55:28.760 --> 01:55:37.720]  смысле. в более каком-то широком, чем convertible2 или более узком. похоже на референс врата.
[01:55:37.720 --> 01:55:45.320]  возможно речь идет о нем, возможно речь идет о каких-нибудь более сложных умных указателях,
[01:55:45.320 --> 01:55:52.480]  но так конечно не догадаешься без объяснений. но суть всего происходящего в том, что это
[01:55:52.480 --> 01:56:03.720]  reference, lvalue reference на range, reference view, ссылка на range. и фактически единственный такой нормальный
[01:56:03.720 --> 01:56:10.360]  use case для этого, это когда у вас есть range, он не вьюха, и вы lvalue ссылку на него передали
[01:56:10.360 --> 01:56:14.560]  в какой-нибудь адаптер или еще куда-нибудь. тогда у вас волшебным образом возникнет вот
[01:56:14.560 --> 01:56:22.280]  эта прослойчка для того, чтобы адаптеры можно было писать однородно, всегда зная, что в них
[01:56:22.280 --> 01:56:28.080]  приходит вьюха, не задумываясь о том, что может прийти вьюха, а может не вьюха, и тогда там чуть
[01:56:28.080 --> 01:56:34.760]  по-другому придется специализировать. и это упрощает код. это удобно. это вот одна из таких
[01:56:34.760 --> 01:56:41.440]  дизайнерских решений в этой библиотеке, которая мне кажется прям вот отличная. без него пришлось
[01:56:41.440 --> 01:56:52.120]  быть тяжко. вот как-то так. но есть еще subrange, и это какой-то костыль, если честно. ну давайте
[01:56:52.120 --> 01:56:59.320]  посмотрим. у самого класса subrange есть два шаблонных параметра сверху. на самом деле еще больше,
[01:56:59.320 --> 01:57:09.640]  но там дебри, лютые дебри. это итератор и сентинел. вроде все просто. и первый из двух конструкторов
[01:57:09.640 --> 01:57:22.960]  он как раз от этого итератора конструируется, и от сентинела. но там немножко хитрый концепт
[01:57:22.960 --> 01:57:28.000]  есть, который там что-то подменит. ну в общем, вот где-то и точа, туда лучше не лезть. и
[01:57:28.000 --> 01:57:43.160]  зачем этот первый конструктор нужен? вот для этой штуки. кажется, что только для нее. когда-нибудь
[01:57:43.160 --> 01:57:51.880]  использовали такую функцию. а, то multimap. да, здесь должен был быть multimap. ну какие-нибудь задачки
[01:57:51.880 --> 01:58:01.040]  олимпиадные решали? решали же олимпиадные задачки какие-нибудь там equal range? нет? по-быстренькому
[01:58:01.040 --> 01:58:11.240]  залогорифм что-нибудь найти? кажется, что дальше в overbound редко что нужно. ну бывало, мне кажется,
[01:58:11.240 --> 01:58:19.120]  у меня такое. странно, что вас нет. ну ладно. мне кажется, один из немногих, кто на олимпиадах
[01:58:19.120 --> 01:58:28.520]  hostile активно, очень активно пользовал. я пытался. это мне не помогло, но... я вроде тоже пробовал. мне
[01:58:28.520 --> 01:58:36.520]  это правда в итоге тоже не очень помогло. я так и не понял, почему. грустная судьба наша. но да,
[01:58:36.520 --> 01:58:42.840]  он возвращает пару итераторов multimap, который указывает на начало отрезка, где начинаются
[01:58:42.840 --> 01:58:50.400]  элементы с равными ключами и его конец. и как бы как это запихнуть в какую-то view? какое это вообще
[01:58:50.400 --> 01:58:57.800]  будет view? вот решили, что вот этот. subrange. то есть как бы референс view не особо подходит,
[01:58:57.800 --> 01:59:06.760]  а вот subrange как раз. std-span, если вы его помните, он тоже не подходит. std-span для последовательных,
[01:59:06.760 --> 01:59:15.520]  последовательной памяти. а вот это как бы обобщение std-span для каких-то непоследовательных штук,
[01:59:15.520 --> 01:59:21.160]  для каких-то деревьев, грубо говоря. но вот второй конструктор нам более интересен,
[01:59:21.160 --> 01:59:27.320]  потому что, как мы видели, all функция именно его использует. именно второй конструктор.
[01:59:27.320 --> 01:59:43.160]  и получается такая ситуация, что мы какой-то адаптер делаем от expression. и expression как бы
[01:59:43.160 --> 01:59:51.800]  там не subrange, если subrange это тривиально, а в итоге все равно получился subrange внутри view,
[01:59:51.800 --> 01:59:59.800]  а не ref view. вот вопрос, когда такое еще может происходить? кто-нибудь догадается, какие есть
[01:59:59.800 --> 02:00:07.200]  кейсы, когда мы как бы хотим какой-то контейнер засунуть в адаптеры, но при этом нам не хватает вот
[02:00:07.200 --> 02:00:25.720]  этой штуки? я думаю, вы не догадаетесь, потому что это вообще типа ужас. это допоминалка. в последнюю
[02:00:25.720 --> 02:00:30.920]  очередь subrange. соответственно нам нужно, чтобы это была не view и все, что в ref view нарушалось.
[02:00:30.920 --> 02:00:44.120]  то есть это было как бы не lvalue, не lvalue ссылка на контейнер. и внезапно, что хотел сказать,
[02:00:46.120 --> 02:00:48.560]  я забыл, что я хотел сказать на этом слайде, если честно.
[02:00:48.560 --> 02:01:02.320]  давайте просто на него посмотрим. такой код. попытались взять begin от rvalue ссылки на какой-то
[02:01:02.320 --> 02:01:17.760]  вектор. и про требования к begin. все очень запутано. мы возвращаемся к вопросу про enable borrow
[02:01:17.760 --> 02:01:26.400]  range. и вот и вообще borrow range, что это и зачем это? вот если штука не помечена явно как borrow
[02:01:26.400 --> 02:01:37.440]  range, то rvalue ссылки что-то в begin к last нельзя. соответственно подразумевается, что если мы
[02:01:37.440 --> 02:01:47.160]  что-то пометим как borrow range, то можно. кстати, для std begin и std end это не так, так что теперь
[02:01:47.160 --> 02:01:52.200]  нужно использовать range с begin, если вы хотите, чтобы ваш код нормально работает, обобщенный.
[02:01:52.200 --> 02:02:00.320]  вот и собственно не буду томить, я не знаю, как к этому нормально подвести, я просто типа
[02:02:00.320 --> 02:02:08.200]  нагуглил и понял, что это что-то жесть. мне на borrow range кажется идея на это же range такой,
[02:02:08.200 --> 02:02:13.160]  что он пробрасывает lifetime дальше. сейчас скажу да про borrow range, ну в принципе так,
[02:02:13.160 --> 02:02:18.600]  но конкретные примеры. да, наверное слайды чуть не в том порядке поставил, черт, ладно.
[02:02:18.600 --> 02:02:25.880]  короче, можно сделать такую штуку, сделать вектор, который не вектор, а внутри себя хранит shared
[02:02:25.880 --> 02:02:34.960]  указатель на вектор. то есть такой shared вектор. в чем его проблема? почему он не вью?
[02:02:34.960 --> 02:02:46.920]  со сколько у него работает деструктор? вот если у нас уже остался последний такой
[02:02:46.920 --> 02:02:53.320]  shared вектор и мы его удаляем, кажется за ootn, правда ведь? нам же нужно удалить как бы то,
[02:02:53.320 --> 02:03:04.360]  что по shared pointer лежит. вот так что да, ootn соответственно не вью, а range он как бы спокойно
[02:03:04.360 --> 02:03:14.360]  является. и более того, мы этот range можем спокойно копировать. то есть копируя его,
[02:03:14.360 --> 02:03:23.880]  мы как бы не копируем содержимое. такая странная ситуация. и мы спокойно можем взять и мувнуть его
[02:03:23.880 --> 02:03:32.720]  в std begin или мувнуть его в какой-нибудь адаптер. и это ничего нам не сломает. и вот именно для
[02:03:32.720 --> 02:03:43.040]  такого случая, кажется, будут subrange. другой пример это span, у которого статический размер. у него
[02:03:46.240 --> 02:03:47.240]  что с ним не так?
[02:03:53.240 --> 02:03:56.640]  помогите мне, почему span от in42 не будет вью?
[02:04:03.720 --> 02:04:11.120]  стоп, а span без фиксированного размера был вью? да. вот кстати это не было уточнено,
[02:04:11.120 --> 02:04:19.160]  там над давним давно на слайде. окей, сейчас подумаем. а окей, ладно, да span просто без фиксированного
[02:04:19.160 --> 02:04:24.640]  размера это таки вью. то есть с этим все нормально. как только вы статический размер оббиваете,
[02:04:24.640 --> 02:04:25.720]  почему-то все ломается.
[02:04:32.720 --> 02:04:43.520]  ну, казалось бы, что в себе span статического размера хранит.
[02:04:43.520 --> 02:04:54.560]  указатель и все. да, соответственно, копировать, сравнивать, все вообще прекрасно можно.
[02:04:54.560 --> 02:05:07.680]  ну, конечно, да. ну, знаете, что у меня очень плохая память, так что мы откроем все-таки
[02:05:07.680 --> 02:05:18.960]  concept view, потому что вдруг что-то не так скажу или не так вспомню. movable, movable-leon, да, movable,
[02:05:18.960 --> 02:05:32.960]  range-leon. ну, вроде range, а не contiguous. но в goodbolt я это вбивал, а это не работало.
[02:05:32.960 --> 02:05:45.960]  ну, вот это уже тонкий аргумент. да, нет, давайте так. ты же с транка собирал? да, с транк.
[02:05:45.960 --> 02:06:00.840]  покажи ниже, там были какие-то... да, вьюховано.
[02:06:00.840 --> 02:06:18.560]  да, как так? с утра не было, с вечера стало. что это такое?
[02:06:18.560 --> 02:06:26.200]  так, проверяем.
[02:06:48.560 --> 02:07:12.760]  ага. а, я все попутал, кажется. что? что происходит?
[02:07:12.760 --> 02:07:28.960]  нет, да, он действительно вьюха. ух, нормально выпиливается. да, странно, слушайте, странно, нет, еще раз, что?
[02:07:42.760 --> 02:08:09.880]  очень странно. я отчетливо помню, как я с утра это перепроверял. ладно, окей, в общем, да, кажется,
[02:08:09.880 --> 02:08:18.520]  единственное наше, наш контрпример, это вот такая фига тени и какой-нибудь экзотический вью, у которого нет какого-нибудь
[02:08:18.520 --> 02:08:27.600]  оператора присваивания или чего-нибудь такого. но это, конечно, дичь. вряд ли такое часто в природе
[02:08:27.600 --> 02:08:36.360]  встречается. так, нам осталось совсем чуть-чуть, и скоро мы перейдем к докладу. да, но мораль вот в чем,
[02:08:36.360 --> 02:08:44.560]  что BORUT RANGE это как бы range на итераторы, которого можно оставлять ссылки даже когда он удален.
[02:08:44.560 --> 02:08:55.120]  ну, судя сами, итераторы себе оставлять. да, и сами итераторы, я что-то не то сказал. то есть как бы сами
[02:08:55.120 --> 02:09:03.160]  итераторы не протухают, когда BORUT RANGE умер. то есть это похоже на вьюху тем, что оно как бы не
[02:09:03.160 --> 02:09:09.240]  владеет, а только ссылается на кого-то другого. но при этом всех остальных требований о вьюхах нету.
[02:09:09.240 --> 02:09:16.920]  то есть это может быть очень жирная штука внутри. и там асимптотики вообще любые, кажется. и каких-то
[02:09:16.920 --> 02:09:23.320]  там операций даже может не быть. да, копирование, мува, прочих вещей. то есть для вьюх все эти
[02:09:23.320 --> 02:09:29.760]  операции хочется иметь, чтобы с ними работать регулярно как-то, да, в обобщенном коде. соответственно,
[02:09:29.760 --> 02:09:35.840]  такие вот экзотические кейсы, которые все же могут быть, они оформлены вот сюда отдельно. BORUT RANGE.
[02:09:35.840 --> 02:09:46.280]  вот. ну, как-то так. последний пунктик. это новое алгоритмы классное. наверное сейчас без
[02:09:46.280 --> 02:09:55.000]  прерыва уже придется, так что держимся. в стд с незапамятных времен есть алгоритмы. они обычно
[02:09:55.000 --> 02:10:01.240]  выглядят вот так. если там еще второй какой-нибудь интервал принимается, то еще два итератора. но это
[02:10:01.240 --> 02:10:09.320]  конечно дичь. надо вот так. и теперь так можно. более того, некоторые алгоритмы за стд RANGE
[02:10:09.320 --> 02:10:26.480]  прокачали. например, рассмотрим вот такой вектор из пар. в каком-то смысле flatmap очень кэшлокальный,
[02:10:26.480 --> 02:10:34.120]  очень классный. а мы хотим отсортировать его по value. хотя, конечно, было бы логичнее поиди,
[02:10:34.120 --> 02:10:45.520]  но ладно. и внезапно это можно сделать вот так. поменитируем немножко над этим. мы просто вкинули
[02:10:45.520 --> 02:10:55.560]  вектор в sort. второй аргумент – это компаратор. мы его по дефолту оставили, не поменяли. а теперь
[02:10:55.560 --> 02:11:03.600]  есть какой-то третий аргумент, в который мы передали ссылку на val. что мы там просили передать?
[02:11:03.600 --> 02:11:13.400]  указатель на член класса. я заговариваюсь под вечер. а теперь таким образом это проектор?
[02:11:13.400 --> 02:11:22.680]  именно так. и напечатает это то, что мы ожидаем. foreach тоже есть, кстати. это чуть более удобно,
[02:11:22.680 --> 02:11:35.800]  чем begin и end писать. если поиди, то будет отсорчено поиди. я думаю, ничего удивительного. да,
[02:11:35.800 --> 02:11:42.880]  это действительно проектор. по умолчанию onIdentity, а компаратор у нас по умолчанию less. соответственно,
[02:11:42.880 --> 02:11:51.760]  std less или std identity. я думаю, про std less вы слышали, а std identity – это функция, которая возвращает
[02:11:51.760 --> 02:12:00.440]  свой аргумент без изменений. и тут, конечно же, есть концепт, который проверяет, что сортировочка
[02:12:00.440 --> 02:12:07.760]  сработает в compile time. но смысл проекции в том, что мы с компаратором будем сравнивать не сами
[02:12:07.760 --> 02:12:20.320]  элементы, а какие-то их части. и проектор, вообще говоря, это, наверное, какая-нибудь функция будет
[02:12:20.320 --> 02:12:26.480]  или что-нибудь вроде того. но внезапно можно и ссылку в указатель на член класса передать.
[02:12:26.480 --> 02:12:32.160]  и почему так можно и как это вообще работает чуть более подробно в концепте sortable указано.
[02:12:32.160 --> 02:12:45.720]  и сюда мы что вкидываем? итератор нашего range, компаратор и проекцию. здесь есть некоторый
[02:12:45.720 --> 02:12:54.360]  permutable и это требование на итератор. и вот там появляется этот зоопарк из indirectly,
[02:12:54.360 --> 02:13:00.160]  что-то там. я не помню, я вставил с этим слайд? да, я вставил. просто чтобы этот зоопарк вам
[02:13:00.160 --> 02:13:05.480]  показать хоть раз. почти на любое действие, которое вы можете совершить с результатом,
[02:13:05.480 --> 02:13:13.560]  полученным из итератора, есть концепт indirectly. то есть концепт swapable есть, есть indirectly
[02:13:13.560 --> 02:13:19.880]  swapable. концепт movable есть, есть indirectly movable, но еще там storable. то есть да,
[02:13:19.880 --> 02:13:25.960]  это немножко дичь. в общем, это минимальные необходимые требования, чтобы хотя бы за
[02:13:25.960 --> 02:13:33.600]  квадрат сортировку можно было сделать. и вот он здесь как раз forward iterator. теперь про indirect
[02:13:33.600 --> 02:13:42.920]  streak week order. это мы, кажется, в прошлый раз обсуждали, да? ну, по крайней мере, streak week,
[02:13:42.920 --> 02:13:52.720]  нет, или когда-то совсем давно. но имеется в виду, короче, что сравнивать можно. причем,
[02:13:52.720 --> 02:14:01.200]  про что мы говорим сравнивать можно? можно с помощью R сравнивать классы, которые получаются
[02:14:01.200 --> 02:14:08.520]  в результате projected IP. ну и indirect, опять этот зоопарк, имеется в виду, что через итератор не
[02:14:08.520 --> 02:14:17.240]  напрямую. то есть операции R можно сравнивать то, что вернут итераторы из второго аргумента. и вот
[02:14:17.240 --> 02:14:29.920]  projected нам тоже как бы итератор вернет. а какой вот такой... да, это, короче, структурка, которая
[02:14:29.920 --> 02:14:36.400]  вообще нигде в коде не используется, а только вот в этом концепте. и у нее оператор заменования
[02:14:36.400 --> 02:14:47.720]  возвращает indirect result t. ну, вторая штука, это неинтересно. а вот этот indirect result t это
[02:14:47.720 --> 02:14:53.760]  то же самое, что result t, то есть результат применения функции, функции prodge, к итератору,
[02:14:53.760 --> 02:15:01.720]  ну или к значению, но так как indirect к итератору. да, заметьте, выше есть indirectly readable,
[02:15:01.720 --> 02:15:12.680]  indirectly regular, unary, invocable, то есть вообще жуть. все indirectly. вот, ну и в итоге внутри этого
[02:15:12.680 --> 02:15:22.400]  indirectly result t мы делаем invoke result t от itr-reference, то есть в ev засовываем результат. а в std-invoke
[02:15:22.400 --> 02:15:33.360]  появилась новая строчка, которая говорит, что на ссылке на структурку, ссылку на ее член класса
[02:15:33.360 --> 02:15:43.160]  можно использовать как функцию и возвращать ссылку на сам этот член. прикольно, да? сколько
[02:15:43.160 --> 02:15:50.400]  слоев нужно пройти, чтобы докопаться до истины. вот, но все эти... это было из 17-х плюсов изначально,
[02:15:50.400 --> 02:15:56.080]  то есть, возможно, это была заготовка или так решили, что почему... это заготовка была, да,
[02:15:56.080 --> 02:16:04.520]  потому что это не использовалось, насколько я помню, в библиотеке. понятно. вот, ну вообще все эти
[02:16:04.520 --> 02:16:11.440]  мысли про indirectly то, indirectly все наталкивают на то, что нам бы хотелось бы уметь в концепты
[02:16:11.440 --> 02:16:17.600]  принимать другие концепты, чтобы indirectly это был такой описательный концепт, внутри которого
[02:16:17.600 --> 02:16:24.200]  любой другой концепт можно засунуть. но, к сожалению, мы живем в несовершенном мире, и это появится
[02:16:24.200 --> 02:16:34.440]  не раньше, чем через 10 лет. вот, напоследок, что будет дальше? ну, то есть, с плюс 23. добавят
[02:16:34.440 --> 02:16:43.200]  то, чего очень сильно не хватает, если честно. зипы, денумирейты, грубай, флатмэп, который другой
[02:16:43.200 --> 02:16:57.800]  флатмэп, который монодический флатмэп, по сути, это concatenate для большинства структур. да, но не
[02:16:57.800 --> 02:17:06.080]  суть важна. нет, это не просто concatenate, это map и потом concatenate или transform, а потом concatenate.
[02:17:06.080 --> 02:17:15.960]  chunk, slide, stride – это штуки, которые позволяют бегущим окном идти, разбить на куски фиксированного
[02:17:15.960 --> 02:17:21.800]  размера. chunk – это куски фиксированного размера, slide – это бегущее окно, и stride – это пропускать
[02:17:21.800 --> 02:17:27.280]  некоторые элементы. то есть, там каждый пятый элемент взять. Cartesian product – это декартовое
[02:17:27.280 --> 02:17:34.600]  произведение. тоже пока нет, тоже хочется. ну, фолды, сканы вы писали даже сами, думаю, понимаете,
[02:17:34.600 --> 02:17:39.760]  о чем речь. вот. и все это очень хочется, но, к сожалению, это не успели в 20-е пропихнуть,
[02:17:39.760 --> 02:17:45.600]  поэтому в 23-е сейчас активно пропихивают. прям каждый день приходит письма, что то пропихнулось,
[02:17:45.600 --> 02:17:51.640]  все пропихнулось. ну, я не особо точно слежу, кто конкретно, просто вижу письмо, что пропихнули
[02:17:51.640 --> 02:18:01.040]  очередную функцию с хаскеля, и прям сердечко радуется. вот. так что, да, когда-нибудь писать
[02:18:01.040 --> 02:18:06.480]  на ренджах, будет вообще супер-кайф, и уже сейчас можно писать на них достаточно приятно,
[02:18:06.480 --> 02:18:17.360]  но не до конца. и, ну, небольшой пример кода. если вы не знаете, есть такое мероприятие Advent of Code.
[02:18:17.360 --> 02:18:27.160]  это такая традиция, то ли перед рождеством, то ли перед новым годом на западе каждый день делают
[02:18:27.160 --> 02:18:36.160]  что-то. там отрывают из календаря что-то, листочек, или там открывают какую-нибудь коробку с игрушкой,
[02:18:36.160 --> 02:18:41.640]  а вот программисты придумали каждый день решать олимпиадную задачу, но они рассчитаны
[02:18:41.640 --> 02:18:48.480]  типа совсем на несоображающих ребят, но по сложности возрастают со временем, так что бывает
[02:18:48.480 --> 02:18:54.640]  что-то интересное под конец. но тут задача первая нас интересует. да, это не то, это не то,
[02:18:54.640 --> 02:19:01.400]  это первое, вот первое. совсем простая задача. дана последовательность чисел, нужно посчитать,
[02:19:01.400 --> 02:19:09.440]  сколько раз следующее число увеличилось по сравнению с предыдущим. да, то есть там 199,
[02:19:09.440 --> 02:19:15.040]  предыдущего вообще нет, 200 увеличилось, 8 увеличилось, 10 увеличилось, 200 уменьшилось,
[02:19:15.040 --> 02:19:26.320]  не считаем. ну и ответ 7. как это на рейнджах написать? ну сделаем вектор, чтобы в нем данные
[02:19:26.320 --> 02:19:32.760]  хранить, потому что если мы этого не сделаем, у нас будут те самые проблемы с тем, что айстрим вью
[02:19:32.760 --> 02:19:38.440]  и вообще эти импл-утераторы работают немножко больно. их там нельзя копировать, нельзя два
[02:19:38.440 --> 02:19:46.440]  раза читать, будет что-то странное. поэтому вот так, через алгоритм копия, backinserter запихнули
[02:19:46.440 --> 02:19:57.040]  все в input. потом надо решить задачу. возьмем input и возьмем input с дропнутым первым элементом.
[02:19:57.040 --> 02:20:06.120]  сделаем операцию zip with. это такой zip, который не просто зипает, а еще и применяет некоторую
[02:20:06.120 --> 02:20:15.720]  функцию к каждой паре. и вот эта функция в нашем случае это оператор less. стд less, то есть оператор
[02:20:15.720 --> 02:20:24.480]  меньше. таким образом получается на выходе вот этого всего у нас последовательность булей. true там,
[02:20:24.480 --> 02:20:34.720]  где следующий элемент был сейчас, вот это less than вот это, то есть предыдущий элемент был меньше
[02:20:34.720 --> 02:20:43.120]  следующего. то есть true ровно на тех позициях, где мы увеличились. и размер этого массива,
[02:20:43.120 --> 02:20:51.960]  грубо говоря, range, он будет n-1 по сравнению с n, потому что я дропнул здесь один, и у последнего
[02:20:51.960 --> 02:21:00.120]  элемента вот этого аргумента не будет пары, и zip просто его отбросит. ну и дальше используется
[02:21:00.120 --> 02:21:04.720]  алгоритм count, который подсчитывает количество true. наверное, это можно было сделать проще,
[02:21:04.720 --> 02:21:11.080]  но мне почему-то первое, что в голову пришло и скомпилировалось, это count. и это таки действительно
[02:21:11.080 --> 02:21:24.160]  работает. я вбил пример оттуда тестовой, удалим там последнее число, оно полагает и изменится на 6.
[02:21:24.160 --> 02:21:29.840]  вот я думал с вами порешать еще немножко этих задачек, но мы тогда не успеем послушать
[02:21:29.840 --> 02:21:40.480]  доклад, поэтому передаю слово Денису. я могу в принципе не очень долго рассказывать.
[02:21:40.480 --> 02:21:52.240]  у тебя 20 минут, так что да. у меня нельзя демонстрацию включить. сейчас, секундочку,
[02:21:52.240 --> 02:22:01.840]  я отмечу галочкой. вот, можешь запускать.
[02:22:01.840 --> 02:22:20.720]  окей, какая вообще тема? мы посмотрим на обработку, ну короче, на ошибки, на то,
[02:22:20.720 --> 02:22:29.600]  как создаются и обрабатываются ошибки в MongoDB. вот, и почему это вообще может быть нам интересно
[02:22:29.600 --> 02:22:38.760]  с точки зрения в принципе метапрограммирования. в общем, MongoDB это такая база данных на SQL,
[02:22:38.760 --> 02:22:49.360]  довольно популярная, и она написана на плюсах. соответственно, можно посмотреть код и можно
[02:22:49.360 --> 02:22:57.120]  посмотреть на интересующие нас вещи в плане метапроги. в общем, тут на самом деле в широком
[02:22:57.120 --> 02:23:05.040]  смысле метапроги, тут довольно еще много всяких прикольных вещей. нас, видимо, подразумевалось,
[02:23:05.040 --> 02:23:11.640]  что я расскажу конкретно про одну вещь, сейчас ее тогда покажу сразу. в общем, внутри базы данных
[02:23:11.640 --> 02:23:20.040]  есть некоторые исключения, которые там кидаются при разных ошибках. у этих исключений бывает что?
[02:23:20.040 --> 02:23:28.320]  вот какой-то пример, наследуется исключение от std-exception, также переопределяется там вот,
[02:23:28.320 --> 02:23:39.120]  который есть у std-exception, там получается какая-то причина, мы получаем ее некоторую, и в общем-то
[02:23:39.120 --> 02:23:44.440]  выводим. вот, это как бы то, что мы наследуем отсюда. и дальше добавляются еще некоторые вещи,
[02:23:44.440 --> 02:23:53.320]  которые тоже могут быть интересны нам, например, там стерилизация какая-то, типа получить код
[02:23:53.320 --> 02:24:01.360]  ошибки, который мы уже получаем из внутренней структурки статуса. в общем-то, добавить какой-то
[02:24:01.360 --> 02:24:07.680]  контекст, добавить еще какую-то стрингу, которая дополнительное описание какое-то нам дает.
[02:24:07.680 --> 02:24:20.240]  еще вот тут интересно есть, мы как-то, видимо, хотим брать и присваивать наши exception, как бы
[02:24:20.240 --> 02:24:26.600]  разбивать их на какие-то категории exception. вот, и вот эта штука, она наталкивает на мысль то,
[02:24:26.600 --> 02:24:32.920]  что мы так можем делать, потому что мы можем проверить, как бы, подходит ли нам, ну короче,
[02:24:32.920 --> 02:24:42.360]  являемся ли мы какой-то какой-то категории. вот, как-то так. ну еще здесь есть некоторые вещи
[02:24:42.360 --> 02:24:45.760]  связанные с тем, что мы дополнительно какую-то информацию можем передавать. в принципе,
[02:24:45.760 --> 02:24:53.160]  я потом про это могу что-то сказать тоже. вот, значит, есть получается exception, какая-то их,
[02:24:53.160 --> 02:24:59.160]  видимо, иерархия будет, потому что это подразумеваться будет каким-то базовым классом. а дальше еще они
[02:24:59.160 --> 02:25:05.880]  разбиваются на некоторые категории. окей, смотрим дальше. есть самая базовая вещь, просто
[02:25:05.880 --> 02:25:10.800]  assertion exception, которая, вот, мы там можем, получается, в exception это передать, как бы,
[02:25:10.800 --> 02:25:20.000]  какую-то строку, какую-то даже дополнительную информацию, какой-то код ошибки. вот, ну как бы,
[02:25:20.000 --> 02:25:25.640]  вообще обычно для каких-то таких обыденных целей нам это и нужно, больше, в принципе, ничего и не
[02:25:25.640 --> 02:25:32.760]  нужно. если мы хотим еще на категории разбивать, то дальше начинается какая-то работа. пока что
[02:25:32.760 --> 02:25:41.240]  просто assertion exception, кажется, ничего особенного. а теперь уже начинаются некоторые exception для
[02:25:41.240 --> 02:25:50.160]  категорий, и сейчас будет происходить что-то похожее на генерацию иерархий, которая была на третьей
[02:25:50.160 --> 02:25:58.160]  лекции, если я ошибаюсь. вот, третья лекция. давайте посмотрим на код, что там примерно было. напомню,
[02:25:58.160 --> 02:26:05.120]  там основная идея была в том, что вот у нас есть какой-то event set, и мы делаем множество
[02:26:05.120 --> 02:26:14.800]  наследования от абстрактных хендлеров. каждая у нас такая структурка, она шаблонная, и здесь у нас
[02:26:14.800 --> 02:26:20.520]  внутри лежит виртуальная функция, и вот мы, значит, хотим так взять и сделать такой интерфейс.
[02:26:20.520 --> 02:26:27.480]  проблема была в том, что мы решали, что у нас там виртуальная функция не может быть шаблонной. вот,
[02:26:27.480 --> 02:26:33.200]  дальше мы еще каким-то образом брали и через intermediate, если кто помнит, делали конкретные event
[02:26:33.200 --> 02:26:45.680]  set. здесь это даже не понадобится, то есть здесь сделано немножко проще. вот, окей, что дальше
[02:26:45.680 --> 02:26:51.160]  происходит у нас? возвращаемся сюда. значит, есть db exception, есть assertion exception. от них виртуально
[02:26:51.160 --> 02:26:59.320]  наследуется exception для конкретной категории шаблонной. вот, пока что ладно, пока что просто
[02:26:59.320 --> 02:27:07.960]  виртуально наследуется, ничего особенного, потом будет понятно, зачем виртуален. и дальше
[02:27:07.960 --> 02:27:17.320]  начинается nmspace, в котором происходит метапрограммирование. давайте я, наверное, просто покажу,
[02:27:17.320 --> 02:27:27.600]  чего мы хотим достичь, чтобы потом было понятно. ну, в общем, мы просто хотим брать и иметь такой
[02:27:27.600 --> 02:27:40.360]  exception for для некоторого error-кода, который дальше сможет
[02:27:40.360 --> 02:27:59.000]  создаваться от некоторых разных каких-то категорий. наверное, звучит не очень убедительно. я покажу
[02:27:59.000 --> 02:28:08.560]  тогда сразу dispatcher, который здесь вызывается. вот его объявление. в чем смысл? нам передается код
[02:28:08.560 --> 02:28:16.720]  и дальше передается какое-то переменное количество категорий. на самом деле, вот здесь
[02:28:16.720 --> 02:28:26.400]  передается нам, получается, некоторый type-list на самом деле. сейчас я покажу, где он. может
[02:28:26.400 --> 02:28:36.560]  встречаться нам. ну, чтобы вы поверили, что это type-list. там чуть пониже в специализации был категории
[02:28:36.560 --> 02:28:47.040]  list. мне кажется, тебе он нужен. если ты вернешься к dispatcher, да, вот ты указываешь на default
[02:28:47.040 --> 02:29:02.120]  сейчас. это default. да, ты вот про это всё понял, да. да, вот. в таком файле со странным разрешением,
[02:29:02.120 --> 02:29:14.120]  странным кодом с процентами, с этими долларами находится... так, а ты не разобрал, почему доллары
[02:29:14.120 --> 02:29:19.400]  и такие странные штуки? не-не-не. ну, в смысле, это дальше код-генерация там просто. а, окей, хорошо.
[02:29:19.400 --> 02:29:33.320]  вот. в общем, получается, что здесь объявляется list из категорий и в дальнейшем сюда будут
[02:29:33.320 --> 02:29:41.840]  подставляться некоторые типы через код-генерацию. в общем-то, вот. то есть, это, короче, считается,
[02:29:41.840 --> 02:29:51.240]  что просто type-list из категорий. вот. теперь, что происходит в этом dispatcher? то есть, нам
[02:29:51.240 --> 02:29:55.360]  передают какой-то код, нам передают какие-то категории. если никаких категорий нам не передали,
[02:29:55.360 --> 02:30:06.960]  то мы говорим ok через conditional. значит, мы просто exception for implementation, код ошибки и мы assertion
[02:30:06.960 --> 02:30:12.400]  exception. что это значит? ну ладно, окей. если нам передали какие-то категории, то вот здесь
[02:30:12.400 --> 02:30:24.240]  получается у нас такой же как бы exception for нескольких категорий. вот этот. который
[02:30:24.240 --> 02:30:35.720]  абстракт, там виртуально наследовался от... получается assertion exception. вот. окей. давайте
[02:30:35.720 --> 02:30:44.560]  посмотрим тогда на что такое вот эта штука. вот она здесь написана. и это получается event set,
[02:30:44.560 --> 02:30:56.320]  если смотреть на предыдущий код, который был на семинале. абстракт event set. вот. в чем заключается
[02:30:56.320 --> 02:31:00.360]  идея здесь? в том, что мы также просто берем публично наследуемся от переменного количества
[02:31:00.360 --> 02:31:10.920]  bases, которые являются сами exception for категории от какой-то категории. можно я тебя немного
[02:31:10.920 --> 02:31:21.920]  перебью? ты сказал, что это абстракт set. это скорее concrete set, чтобы людей не запутать. то есть в качестве
[02:31:21.920 --> 02:31:32.960]  абстракт set у нас служит assertion exception. то есть assertion exception это такая базовая штука,
[02:31:32.960 --> 02:31:41.760]  которая одна. и она определяет какие-то виртуальные функции. а вот это exception for
[02:31:41.760 --> 02:31:50.800]  impulse оно несколькими образом эти функции переопределяет. я имел в виду в плане схемы
[02:31:50.800 --> 02:31:56.600]  наследования похожим. да, тут скорее так. у нас получается, что assertion exception нам дает...
[02:31:56.600 --> 02:32:09.520]  да, что-то зуму плохо. ладно, я хотел сказать, что эта схема очень похожа на то, что мы с
[02:32:09.520 --> 02:32:16.920]  Intermediate делали. и мы даже в конце чуть про это говорили, но так уже вскользь. и потом Андрей
[02:32:16.920 --> 02:32:22.280]  вроде скинул работающее решение. вместо вот этих интермидиатов действительно можно виртуальное
[02:32:22.280 --> 02:32:28.440]  наследование использовать, чтобы несколько переопределяющих классов подпихнуть в иерархию.
[02:32:28.440 --> 02:32:35.320]  ее можно раскрутить, а можно горизонтально сделать через виртуальное. окей, да, кажется в записи это
[02:32:35.320 --> 02:32:46.920]  просто нет. а, беда, ладно. что вы именно, про замену линейной иерархии на скеттер? да, потому что я
[02:32:46.920 --> 02:32:51.200]  рабочий код скинул уже там после семинары. да, мы там совсем вскользь упоминали, а потом...
[02:32:51.200 --> 02:33:02.040]  окей, получается просто такая схема, что вот мы взяли, наследовались от dbException, и у нас
[02:33:02.040 --> 02:33:09.480]  получился AssertionException. а дальше у нас через виртуальное наследование конкретная категория
[02:33:09.480 --> 02:33:22.360]  наследуется от AssertionException. и здесь exception for implementation он принимает в себя, получается,
[02:33:22.360 --> 02:33:28.820]  список basis, то есть список категорий, которым соответствует этот код. и, в общем-то, от них
[02:33:28.820 --> 02:33:40.060]  наследуется. вот, от вот таких вещей там с конкретной категорией. в чем большой смысл всего этого?
[02:33:40.060 --> 02:33:48.020]  у нас же здесь вроде как не фабрика там, все такое. мы хотим просто ловить по, как бы, ну, конкретно
[02:33:48.020 --> 02:33:58.900]  писать кэтчи по, получается, категории. то есть в этой ветке кэтча мы хотим ловить конкретную
[02:33:58.900 --> 02:34:08.020]  категорию ошибки. вот, и таким образом у нас это получится сделать. ну, как-то так. то есть вот это
[02:34:08.020 --> 02:34:12.940]  как бы мотивация того вообще, зачем мы этим занимаемся. и, в общем-то, такая вот реализация,
[02:34:12.940 --> 02:34:21.020]  которая очень похожа на то, что было на семинаре. ну, получается, даже совсем похожа по схеме
[02:34:21.020 --> 02:34:32.140]  наследования на исправленный код. отмечу, что человек, который... да, мне кажется Zoom глушит
[02:34:32.140 --> 02:34:38.140]  меня, когда ты говоришь, так что да. отмечу, что человек, который, собственно, написал этот код,
[02:34:38.140 --> 02:34:42.860]  сам это называет генерацией иерархии, как в Александреску, так что да, это ровно оно.
[02:34:42.860 --> 02:34:56.580]  ладно, вот это, что касается этих иерархий, теперь, не знаю, вот, как бы, если есть, что добавить,
[02:34:56.580 --> 02:35:04.300]  Ром, добавь, потому что конкретно дальше про иерархии я не знаю, что сказать. то есть какие-то
[02:35:04.300 --> 02:35:11.300]  применения может, не знаю, как бы, если ты знаешь. то есть в этом файлике, как бы, вот,
[02:35:11.300 --> 02:35:17.620]  определяется такая вещь, понятно, зачем нужна, дальше есть какие-то еще более тонкие вещи внутри.
[02:35:17.620 --> 02:35:27.220]  как бы, можно, в принципе, ну, я могу что-то сказать, могу, в принципе, остановиться. ну, в принципе,
[02:35:27.220 --> 02:35:31.660]  10 минут у тебя еще есть, так что ты можешь продолжить про что-то интересное, но основной
[02:35:31.660 --> 02:35:38.540]  поинт, да, что мы хотим в кетче уметь конкретную категорию просто указать и по ней отловить,
[02:35:38.540 --> 02:35:46.460]  но иногда в коде все равно приходится ловить любой exception, и из-за этого и приходится такую вот
[02:35:46.460 --> 02:35:56.500]  diamond наследование делать, да, ромбовидное, а генерация иерархии сюда приплывает немножко из
[02:35:56.500 --> 02:36:03.100]  другой мотивации на самом деле, да, казалось бы, зачем все эти тайп-листы и хитрости? за тем,
[02:36:03.100 --> 02:36:09.340]  что база данных штука очень сложная и категории ошибок может быть много, они могут появляться,
[02:36:09.340 --> 02:36:18.220]  исчезать, и хочется все это как-то автоматизировано делать, а не руками подкостыливать новые наследники
[02:36:18.220 --> 02:36:26.820]  в эту иерархию, ну или новые промежуточные классы для категорий, поэтому они, ну как бы
[02:36:26.820 --> 02:36:35.260]  взвесив свои требования, видимо бизнес даже требования, поняли, что они хотят уметь в файлике
[02:36:35.260 --> 02:36:45.940]  буквально указывать список категорий, и даже по-моему сами exception, вот эти input тоже вроде
[02:36:45.940 --> 02:36:52.020]  как код генится, это то, что в этот курс не влезло, но когда-нибудь обязательно влезет,
[02:36:52.020 --> 02:36:59.500]  когда остальный материал начнет читаться более-более хорошо, тоже считается метапрогой,
[02:36:59.500 --> 02:37:07.620]  генерация кода на C++ как текста из-за ну просто каких-то конфигов, это часто применяется
[02:37:07.620 --> 02:37:13.740]  на практике, как бы не казалось, что ну это какое-то типа пошлое на уровне макросов,
[02:37:13.740 --> 02:37:24.700]  код ген, но тем не менее на практике это реально часто используется, и они генерят по конфигу
[02:37:24.700 --> 02:37:33.420]  категории в этом type list, они генерят по конфигу сами exception или state, и для них скорее что-нибудь такое,
[02:37:33.420 --> 02:37:40.220]  и таким образом могут очень легко жонглировать этими штуками, когда нужно что-то изменить,
[02:37:40.220 --> 02:37:49.260]  и код на плюсах вообще не трогают, что приятно. Ну да, в общем-то вот я открыл, если там видно,
[02:37:49.260 --> 02:37:55.900]  получается на демонстрации, тот файлик, который содержит в себе error categories,
[02:37:55.900 --> 02:38:03.620]  for impulse, ну в общем type list тот самый, он на самом деле генерируется, там код генерации есть,
[02:38:03.620 --> 02:38:14.500]  на типа вот это вот разрешение, точнее TPL, это какой-то пич, пишенный, я так понял, парсер,
[02:38:14.500 --> 02:38:19.260]  который может взять, ну там какой-то есть синдекс для того, для установки этих вещей,
[02:38:19.260 --> 02:38:29.460]  вот, на какие-нибудь места вот по типу вот таких, вот, и здесь написаны какие-то ifs и даже fors,
[02:38:29.460 --> 02:38:37.820]  вот, то есть, например, for, error code для кодов, а эти коды, я так понимаю, берутся вот отсюда,
[02:38:37.820 --> 02:38:47.660]  вот, где есть получается имя кода и его номер, в общем-то, то есть, он такой,
[02:38:47.660 --> 02:38:54.260]  довольно большой файлик, чтобы все ручками писать, вот, а есть еще категории, ошибок,
[02:38:54.260 --> 02:39:02.060]  тоже написаны в этой штуке, потому что, опять же, мы берем и делаем код генерацию здесь,
[02:39:02.060 --> 02:39:14.980]  вот, как-то так, еще не знаю, что упомянуть, но вот иногда, наверное, хочется брать и добавлять
[02:39:14.980 --> 02:39:23.220]  к ошибкам какие-то джейсоны, для этого есть тоже внутри там получается, есть класт статус,
[02:39:23.220 --> 02:39:29.940]  в котором внутри есть какие-то вещи, связанные типа с этими штуками, потому что здесь вот какие-то
[02:39:29.940 --> 02:39:36.140]  так, ладно, тут точно где-то было, что принимается себе парсер, который, по сути,
[02:39:36.140 --> 02:39:44.860]  является, вот, принимает себя, получается, бинарный, ну, я не знаю, как это читается,
[02:39:44.860 --> 02:39:49.780]  короче, бинарный джейсон, скажем так, вот, то есть, к ошибкам еще можно какие-то такие штуки
[02:39:49.780 --> 02:39:57.940]  прилеплять, есть внутри каждого exception статус, статус это такая вот штука, которая там может
[02:39:57.940 --> 02:40:03.380]  быть окей, может быть не окей, здесь, наверное, ничего особенного не происходит, просто какие-то
[02:40:03.380 --> 02:40:10.140]  в плане интересного, потому что здесь просто создается террор кода и от причины, в общем-то,
[02:40:10.140 --> 02:40:19.300]  этот статус, который там вот здесь может быть создаваться от какой-то штуки reason, шаблонный,
[02:40:19.300 --> 02:40:24.540]  главное, чтобы она, типа, была constructable, ну, точнее, string был constructable от этого reason,
[02:40:24.540 --> 02:40:32.660]  вот, тогда все будет хорошо у нас, вот, довольно гибкая система в этом плане, и вот сюда можно
[02:40:32.660 --> 02:40:38.900]  прилеплять какие-то контексты, которые, типа, дают просто, на самом деле, позволяют, типа, вот,
[02:40:38.900 --> 02:40:47.300]  какие-то штуки делать cost-buy, то есть, цепочку делать даже из причин, типа, того, почему мы,
[02:40:47.300 --> 02:40:55.460]  собственно говоря, упали, вот, ну, тут тоже код генерации, вот, есть код генерации часть на
[02:40:55.460 --> 02:41:09.260]  питоне, написано, просто я обнаружил, в принципе, есть еще куча макросов, какие-то макросы используют
[02:41:09.260 --> 02:41:13.980]  тоже, опять же, для код генерации, то есть, здесь прямо вообще набор, типа, код генерации разными
[02:41:13.980 --> 02:41:31.980]  способами используется, вот, и, наверное, примерно все, то есть, тут как-то нет такой штуки, как вот
[02:41:31.980 --> 02:41:36.420]  обсуждалось на семинаре, что, возможно, нужно какие-то концепты, которые проверяют то, что у нас там
[02:41:36.420 --> 02:41:41.620]  фабрика чему-то удовлетворяет конкретно, вот, здесь единственное, что я, как бы, искал и нашел,
[02:41:41.620 --> 02:41:47.380]  это то, что они тут зачем-то, ну, не зачем-то, а, короче, берут свой шерп ПТР, пишут, и вот им нужны
[02:41:47.380 --> 02:41:55.620]  какие-то концепты тоже, здесь интересные, которые вот как-то так реализуются по странам, ну,
[02:41:55.620 --> 02:42:00.620]  видимо, потому что тогда еще на тот момент не было концептов, вот, ну, в принципе, у меня все.
[02:42:00.620 --> 02:42:06.220]  Ну, насчет концептов рискну предположить, что у них в зависимости от флагов компиляторы либо
[02:42:06.220 --> 02:42:13.340]  используются нормальные концепты, либо макросами подкостыливаются какие-нибудь enable issues, такое
[02:42:13.340 --> 02:42:24.180]  встречается в Unifex. Так, что-то еще хотел сказать, вот, про концепты для factory, про то, что она
[02:42:24.180 --> 02:42:34.700]  адекватно конструируется, ну, да, на практике нет сильных причин очень сильно констраинить
[02:42:34.700 --> 02:42:41.620]  какие-то внутренние инфраструктурные вещи, потому что ошибки компиляции в них происходят редко,
[02:42:41.620 --> 02:42:48.020]  и от того, что мы потратим время на добавление концептов, мы ничего не выиграем, когда мы что-нибудь
[02:42:48.020 --> 02:42:54.380]  сломаем, да, ну, потому что мы никогда не ломаем, и эти концепты нам не помогут дебажить какую-то
[02:42:54.380 --> 02:42:59.980]  лютую ошибку компиляции, вот, ну, и этот код, кажется, не очень часто у них меняется, опять же, да, он
[02:42:59.980 --> 02:43:12.220]  инфраструктурный, он уже написан, и вряд ли кто-то осмелится лезть в такие дебри. Ну, да, в общем-то,
[02:43:12.220 --> 02:43:18.300]  специально написан такой код, чтобы туда как раз не лезть. Да, именно так, так что да, насчет того,
[02:43:18.300 --> 02:43:24.860]  где писать концепты, а где не писать, это всегда вопрос, мы на этом курсе писали их гораздо больше,
[02:43:24.860 --> 02:43:31.780]  чем, вообще говоря, может на практике понадобится, чтобы как-то привыкнуть в любой ситуации,
[02:43:31.780 --> 02:43:39.860]  придумать, как всё-таки это нормально законстрейнить. То есть, бывают какие-то ситуации,
[02:43:39.860 --> 02:43:47.220]  где так сходу и не поймёшь, нужна какая-то практика. Но окей, если ни у кого никаких вопросов нет,
[02:43:47.220 --> 02:43:52.740]  то мы можем заканчивать и расходиться.
