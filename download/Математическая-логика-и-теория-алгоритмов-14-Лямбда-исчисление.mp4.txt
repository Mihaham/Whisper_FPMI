[00:00.000 --> 00:07.760]  Значит, вот эта вот тема последняя, она немножко
[00:07.760 --> 00:08.760]  особняком стоит.
[00:08.760 --> 00:19.680]  Значит, что я вкратце расскажу так, а у присутствующих
[00:19.680 --> 00:22.840]  здесь, у кого-то это было уже на семинарах лямбда
[00:22.840 --> 00:26.640]  исчисления или никого не было, у кого-то было.
[00:26.640 --> 00:33.840]  Хорошо, ну ладно, значит, я постараюсь так аккуратно
[00:33.840 --> 00:36.040]  изложить основные вещи.
[00:36.040 --> 00:46.720]  Значит, ну, во-первых, про что это вообще?
[00:46.720 --> 00:47.720]  Лямбда исчисления.
[00:47.720 --> 00:55.340]  Значит, ну, это некоторый другой способ посмотреть
[00:55.340 --> 00:58.060]  на то, что такое вычислимость, ну, и сформулируешь, что
[00:58.060 --> 00:59.060]  такое вычислимость.
[00:59.060 --> 01:03.140]  Соответственно, тут парадигма такая, что все есть функция.
[01:03.140 --> 01:07.020]  Значит, все есть функция.
[01:07.020 --> 01:17.180]  Значит, и здесь основная форма записи, вот так вот
[01:17.180 --> 01:21.020]  выглядит, лямбда х точка какой-то п.
[01:21.740 --> 01:26.620]  И толкуется это так, что объект p интерпретируется,
[01:26.620 --> 01:28.380]  понимается как функция от х.
[01:28.380 --> 01:34.420]  Значит, вот это вот p, давайте я напишу рассмотренное.
[01:34.420 --> 01:41.420]  Значит, как функция от х.
[01:41.420 --> 01:49.540]  То есть, например, ну, может быть, написано что-то вроде
[01:49.540 --> 01:54.940]  лямбда х точка х плюс у, но это означает, что выражение
[01:54.940 --> 01:58.460]  х плюс у понимается как функция от х, то есть х это
[01:58.460 --> 01:59.460]  аргумент, а у это параметр.
[01:59.460 --> 02:08.060]  Так, ну вот, значит, ну и тут вводится некоторая
[02:08.060 --> 02:18.620]  функция, которая при правильном понимании дает некоторую
[02:18.620 --> 02:19.620]  модель вычислений.
[02:19.620 --> 02:27.060]  Так, хорошо, значит, давайте будем в этом разбираться.
[02:27.060 --> 02:36.580]  Начнем мы, как всегда, с синтаксиса, синтаксис
[02:36.620 --> 02:37.620]  лямбда исчисления.
[02:37.620 --> 02:44.660]  Это правило обстроения тернов.
[02:44.660 --> 02:53.020]  Правило обстроения тернов.
[02:53.020 --> 02:55.380]  Ой, так.
[03:06.580 --> 03:14.700]  Так, значит, правило обстроения термов, но их называют там
[03:14.700 --> 03:15.700]  лямбда термы.
[03:15.700 --> 03:25.540]  Значит, первое правило базовое, базовое это, что отдельная
[03:25.540 --> 03:33.180]  переменная это терм, значит, эксперименная, следовательно,
[03:33.180 --> 03:38.340]  х это терм, но иногда пишет лямбда терм.
[03:38.340 --> 03:43.940]  Вот, значит, второе правило называется конкатинация.
[03:43.940 --> 04:00.020]  Конкатинация, то если p и q термы, то тогда, соответственно,
[04:00.020 --> 04:03.020]  p и q это тоже термы.
[04:03.020 --> 04:06.020]  Значит, они все лямбда термы, я просто, чтобы быстрее
[04:06.020 --> 04:10.740]  пропускаю букву, значит, интерпретация здесь такая.
[04:10.740 --> 04:19.940]  Значит, интерпретация, что вот это вот p, q, но это как
[04:19.940 --> 04:34.620]  бы функция p, в которую поставлена q, функция p, примененная q.
[04:35.620 --> 04:42.060]  Вот, значит, и третья это лямбда абстракция, это
[04:42.060 --> 04:45.460]  как раз вот такой уражение с лямбды получается.
[04:45.460 --> 04:58.540]  Значит, лямбда абстракция, то если эксперименная, а
[04:58.740 --> 05:14.580]  p это терм, ну и таким образом, как у нас уже было сформано
[05:14.580 --> 05:18.500]  в разного вида, получается построение объекта, которое
[05:18.500 --> 05:19.500]  называется лямбда термами.
[05:19.500 --> 05:23.300]  Значит, теперь тут, как всегда, много скобок получается,
[05:23.300 --> 05:26.900]  и чтобы все скобки не писать, вводят соглашение.
[05:26.900 --> 05:29.500]  Сокращение.
[05:29.500 --> 05:41.180]  Так, значит, во-первых, если скобок вообще не поставлено,
[05:41.180 --> 05:43.660]  то они ставят слева направо.
[05:43.660 --> 05:50.940]  То есть, вот эта штука, это вот, так, сначала p, q, потом r,
[05:50.940 --> 05:52.740]  значит, потом s.
[05:52.740 --> 06:04.420]  Так, значит, дальше, если написано лямбда х.пq, то это
[06:04.420 --> 06:09.660]  будет полностью вот такая штука, лямбда х.пq, в скобках,
[06:09.660 --> 06:16.020]  и это не то же самое, что лямбда х.п, а потом q.
[06:16.020 --> 06:21.340]  Тут понятно, что очень много способов протолкать скобок
[06:21.340 --> 06:25.300]  есть, и чем длиннее, тем больше.
[06:25.300 --> 06:27.060]  Используется вот такой вот вариант всегда.
[06:27.060 --> 06:32.620]  Вот, ну и здесь, соответственно, ну тоже, если здесь будет
[06:32.620 --> 06:37.520]  больше там pq и rs, то тоже это все будет сначала в скобке
[06:37.520 --> 06:39.340]  заключено и еще разобрано как-то так.
[06:39.340 --> 06:45.980]  Вот, а лямбда, соответственно, как бы, ну, на все распространяется
[06:45.980 --> 06:46.980]  после точки.
[06:46.980 --> 06:49.060]  Да, вот в этом включается соглашение.
[06:49.060 --> 06:58.020]  Вот, и еще есть такое сокращение, вот такое вот, то после лямбды
[06:58.020 --> 06:59.220]  может быть много переменных.
[06:59.220 --> 07:07.380]  Значит, лямбда х.з.п, значит, это понимается так, лямбда
[07:07.380 --> 07:14.020]  х.лямбда у.лямбда з.п.
[07:14.020 --> 07:20.660]  То есть, если после лямбды сразу много переменных,
[07:20.660 --> 07:23.860]  значит, то это вот так вот.
[07:23.860 --> 07:28.540]  Вот, хорошо, значит, дальше, как обычно бывает, значит,
[07:28.540 --> 07:31.020]  вхождение переменных бывает свободное и связанное.
[07:31.020 --> 07:47.780]  Вхождение переменных, значит, свободное и связанное.
[07:47.780 --> 07:59.700]  Вот, ну, например, если написано, скажем, лямбда х.xy, то тогда
[07:59.780 --> 08:08.980]  получается, что вхождение х.а связанное, значит, вхождение
[08:08.980 --> 08:09.980]  у свободное.
[08:09.980 --> 08:22.820]  Ну, правила, как обычно, то есть, каждый лямбда квантор
[08:22.820 --> 08:26.180]  связывает все переменные, которые там после точки возникают.
[08:26.180 --> 08:39.100]  Так, хорошо, значит, теперь есть типичное преобразование
[08:39.100 --> 08:51.180]  тоже все еще синтоксическое, синтоксическое преобразование.
[08:51.180 --> 08:56.780]  Значит, первое называется альфаконверсия.
[08:56.780 --> 09:06.220]  Это можно в кавычках, в принципе, можно и без кавычек
[09:06.220 --> 09:09.180]  понимать как замена связанной переменной.
[09:09.180 --> 09:28.020]  Значит, общие правила такое, значит, лямбда х.п преобразуется,
[09:28.020 --> 09:35.380]  скажем, лямбда у.п, значит, а здесь у вместо х.
[09:35.380 --> 09:50.500]  То есть, вот эта вот штука, это установка у вместо х.п.
[09:50.500 --> 09:57.300]  Вот, значит, при этом это может быть во всей формуле
[09:57.300 --> 09:58.820]  или в какой-то подформуле.
[09:58.820 --> 10:13.140]  То есть, вот это во всей формуле или подформуле.
[10:13.140 --> 10:26.940]  Так, хорошо, значит, есть некоторые ограничения.
[10:27.340 --> 10:31.940]  Нужно, чтобы не возникало проблем с именованием переменных.
[10:31.940 --> 10:35.700]  Значит, тут может быть две проблемы.
[10:35.700 --> 10:40.900]  Одна проблема, что старая свободная применная могла
[10:40.900 --> 10:43.500]  подпасть под действие нового квантора.
[10:43.500 --> 10:50.740]  Вторая проблема, что под действие старого квантора
[10:50.740 --> 10:55.500]  подпала новая переименованная переменная.
[10:55.500 --> 11:06.180]  Значит, некорректная замена.
[11:06.180 --> 11:12.980]  Значит, первый вариант, ну, например, сам простой, вот так.
[11:12.980 --> 11:18.980]  Вот лямбда х.ху переименовали в лямбда у.у.
[11:18.980 --> 11:21.220]  Значит, так делать нельзя.
[11:21.220 --> 11:25.460]  Вот почему?
[11:25.460 --> 11:30.740]  Потому что вот эта старая переменная у подпала под действие нового квантора.
[11:30.740 --> 11:36.260]  А как правильно?
[11:36.260 --> 11:39.940]  Ну, любую другую переменную можно взять.
[11:39.940 --> 11:44.980]  То есть, можно, например, написать лямбда т.у.
[11:44.980 --> 11:48.460]  Так будет корректно.
[11:48.460 --> 11:53.340]  Так, значит, это первый вариант некорректной замены.
[11:53.340 --> 11:56.260]  И еще второй вариант, где, наоборот.
[11:56.260 --> 11:57.980]  В первом варианте у нас что получилось?
[11:57.980 --> 12:00.900]  Старая переменная подпала под действие нового квантора,
[12:00.900 --> 12:02.300]  лямбда квантора.
[12:02.300 --> 12:06.060]  Другой вариант, что, наоборот, новая переменная подпала
[12:06.060 --> 12:08.300]  под действие старого квантора.
[12:08.300 --> 12:13.180]  Ну, раз есть переменованный квантор и еще старый,
[12:13.180 --> 12:14.580]  значит, их минимум два должно быть.
[12:14.580 --> 12:23.040]  вот ну например давайте только так особо не путаться я вот такой вот так
[12:23.040 --> 12:33.840]  значит лямбда икс точка икс а тут например лямбда игрек точка икс игрек
[12:33.840 --> 12:42.440]  вот и я тут тоже значит икс переменную в игрек
[12:42.440 --> 12:55.040]  значит лямбда игрек точка игрек тут лямбда игрек точка игрек игрек
[12:55.040 --> 13:01.360]  значит так тоже нельзя
[13:01.360 --> 13:09.400]  потому что значит что произошло произошло что вот это вот старая
[13:09.400 --> 13:17.080]  сейчас нет новая переменная да значит смотрите тут как было было что вот этот
[13:17.080 --> 13:25.040]  вот икс вязан вот этим вот квантором а так в принципе может сказать что
[13:25.040 --> 13:28.000]  проблем в том что здесь лямбда икс здесь лямбда игрек но нет такой
[13:28.000 --> 13:31.880]  проблемы нет это мы не запрещаем может быть по одной и той же переменной мы и
[13:31.880 --> 13:37.000]  в логике это не запрещали и в лямбде тоже не запрещаем вот но проблема в том что
[13:37.000 --> 13:44.280]  теперь переменная этом месте вязывается вот этим квантором и поэтому смысл
[13:44.280 --> 13:49.880]  поменялся вот значит так нельзя делать ну опять же на любую другую переменную
[13:49.880 --> 13:57.360]  можно заменять да то есть можно написать скажем лямбда т точка т лямбда игрек
[13:57.360 --> 14:10.160]  точка т игрек ну вот хорошо зачем нужна альфа конверсия но затем что если есть
[14:10.160 --> 14:15.440]  какой-то другой конфликт имен то можно его разрешить ну при помощи
[14:15.440 --> 14:21.520]  переименование переменной да мы ее где-нибудь переименовали за счет этого может
[14:21.520 --> 14:26.120]  быть может получиться что какой-то другой другой преобразование возможно
[14:26.120 --> 14:35.920]  вот так так у меня номерасы одинаково дать это в кружочке будет
[14:36.880 --> 14:45.320]  вот второе прообразование что это бета редукция
[14:49.520 --> 14:55.040]  это вообще есть как бы основная вещь в лямбда исчисления это раз есть
[14:55.040 --> 15:05.080]  применение функции к аргументу значит прообразование следующее тут
[15:05.080 --> 15:10.680]  лямбда их с точка п я вот здесь именно так стоят скобки на сначала лямбда их с
[15:10.680 --> 15:18.240]  точка п а потом какой-то кум вот соответственно тут будет преобразование
[15:18.240 --> 15:22.320]  в п а тут вместо икс
[15:31.040 --> 15:41.080]  вот ну тоже бывают проблемы значит про значит тут второй проблемы не возникнет
[15:41.080 --> 15:47.360]  потому что те кванторы которые внутри ку они только внутри ку и будут действовать да и
[15:47.360 --> 15:53.080]  ни на что в некую не повлияют но первая проблема может возникнуть да свободной
[15:53.080 --> 15:59.440]  переменной иску может попасть под действие квантора и спа значит здесь
[15:59.440 --> 16:12.800]  значит некорректный переход да и опять же это может быть тоже такая замена может
[16:12.800 --> 16:16.200]  быть во всей формуле лифт под формуле на те тоже напишу
[16:16.200 --> 16:26.440]  по всей формуле или под или под формуле
[16:26.440 --> 16:32.640]  так но некорректный переход
[16:32.640 --> 16:49.040]  ну например прям с этим можно с этим же термом можно куда-то некорректный переход
[16:49.640 --> 16:56.960]  у лямбда и икс лямбда икс точка икс значит а здесь лямбда и дик точка и к с игрек
[16:56.960 --> 17:07.900]  значит и потом еще и грек значит если на шарики лямбда здесь снимается то есть
[17:07.900 --> 17:11.960]  лямбда икс исчезает но если механически заменить то получится и гре к
[17:11.960 --> 17:25.960]  здесь лямбда y точка yy вот ну и опять же получается так нельзя потому что ну вот этот x он связывал
[17:25.960 --> 17:33.440]  с этим значит был вообще свободный кроме внешнего квантора этот x ничем не связан а когда мы его
[17:33.440 --> 17:40.920]  заменили на y то получилось что он связан вот этим квантором вот так как же правильно так
[17:40.920 --> 17:44.960]  давайте я вот здесь вот запишу чтобы не разрывать значит так нельзя как можно
[17:44.960 --> 18:02.040]  так это экран опять начал гудеть значит надо сначала применить альф конверсию причем здесь
[18:02.040 --> 18:14.840]  вот внутри да значит именно под формуле да значит например значит лямбда x точка x а тут лямбда z
[18:14.840 --> 18:29.480]  точка x z и потом y это переход по альфы конверсия и после этого можно уже x заменять на y
[18:29.480 --> 18:42.680]  и получится y тут лямбда z точка y вот и получается что тот квантор который нам мешал
[18:42.680 --> 18:52.760]  я переименовал из y z теперь он нам не мешает вот то есть тут сначала альфа потом бета
[18:52.760 --> 18:56.320]  так
[19:06.680 --> 19:19.440]  гудит а не за это на микрофоне слышно это другого нет ну ладно тогда сейчас давайте
[19:19.560 --> 19:20.400]  храню на всякий случай
[19:20.400 --> 19:49.040]  так хорошо
[19:50.400 --> 20:05.880]  значит то теперь с этим можно делать ну а есть такая общая теория про равенство лямбда термов
[20:05.880 --> 20:19.320]  значит определение а ну кстати сейчас давайте сначала прежде чем определение тверждение
[20:19.320 --> 20:34.840]  тверждение такое что если из п можно по альфы конверсии перейти в ку то иску можно
[20:34.840 --> 20:40.400]  по альфы конверсии перейти в п то есть альф конверсии обратимо да что если мы
[20:41.120 --> 20:43.920]  переносим обратно переносим в одну сторону тогда можно перенести обратно rock
[20:44.080 --> 20:45.360] iga
[20:45.520 --> 20:49.200]  в
[20:49.700 --> 20:53.000]  былоexpensive не будет доказывать а потому что формально нужно определить что
[20:53.000 --> 20:58.160]  такое корректный переход как ты там по индукция иcentrically как будто корректно
[20:58.160 --> 21:02.360]  то другую тоже корректно да то есть если в одну сторону взять имен нет
[21:02.360 --> 21:07.860]  другую тоже нет482 это довольно понятноن и duckt VIPs
[21:07.860 --> 21:14.760]  очень простое, ну, как бы не очень сложное, но не очень короткое. Вот так что давайте мы его
[21:14.760 --> 21:30.860]  пропустим. Вот теперь дальше, значит, определение. Значит, равенство лямбда термов,
[21:31.860 --> 21:36.700]  значит, это симметричное,
[21:36.700 --> 22:00.300]  значит, симметричное и транзитивное замыкание, да, значит, отношений
[22:00.300 --> 22:14.260]  P переходит по Альф конверсии в Q e P переходит по B reduction в Q. Вот, то есть что это значит?
[22:14.260 --> 22:19.900]  На начале, что если мы перешли по Альф конверсии, то термы равны, если мы перешли по B reduct, то термы
[22:19.900 --> 22:27.120]  равны, причем или если мы в обратную сторону перешли по B reduct, то термы тоже равны,
[22:27.120 --> 22:33.820]  если у вас есть такие цепочки то они тоже равны значит иначе говоря что это означает
[22:33.820 --> 22:37.460]  значит иначе говоря
[22:37.460 --> 22:51.640]  p равно q если верно следующее значит если существует p 0 равная p дальше p 1 p 2 и
[22:51.640 --> 22:59.720]  так далее p k t равная q так а вот тут я давайте графическое равенство буду
[22:59.720 --> 23:05.680]  использовать чтобы отличать от этого значит равны этому разной записи но
[23:05.680 --> 23:10.880]  значит одно и то же а графическое значит рампасимально равны вот значит
[23:11.040 --> 23:29.640]  что так дать я вот так нарисую значит из п 0 а тут будет такая двойная стрелочка значит
[23:29.640 --> 23:48.720]  п 1 п 2 значит п 3 и 4 и так далее да значит и здесь значит пк пк минус 2 пк минус 1
[23:48.720 --> 23:58.480]  значит где двойная стрелочка означает цепочку альфа или бета альф конвейс или бета редукции
[23:58.480 --> 24:12.000]  поитая двойная стрелка пожитая да это означает что цепочка в одну сторону
[24:12.000 --> 24:25.720]  значит поитая альфа пожитая и поитая бета пожитая вот
[24:25.720 --> 24:42.280]  так хорошо значит наверное понятно да определение
[24:42.280 --> 24:55.680]  хорошо значит дальше есть такое еще очень важное определение определение что терм
[24:55.680 --> 25:14.000]  значит терм п находится в нормальной форме значит если к нему нельзя применить бета
[25:14.000 --> 25:24.640]  редукцию даже после какого-то числа альф конверсии если к нему нельзя применить
[25:24.640 --> 25:45.040]  это редукцию даже после даже после нескольких альфы конверсии
[25:45.040 --> 25:55.800]  вот тут пример как раз был на предыдущем слайде да то есть вот здесь вот смотрите вот
[25:55.800 --> 26:04.320]  к этому терму нельзя принять бета редукцию потому что будет конфликт имен но если сначала сделать
[26:04.320 --> 26:09.400]  альф конверсию тогда можно поэтому этот терм еще не в нормальной форме вот это уже в нормальной
[26:09.400 --> 26:17.960]  форме вот значит нормальная форма не всегда существует значит есть простейший пример
[26:17.960 --> 26:35.640]  пример терма без нормальной формы значит это значит амега значит который выглядит вот так вот
[26:35.640 --> 26:47.800]  лямбда x точка xx тут лямбда x точка xx значит смотрите как это вообще работает ну значит
[26:47.800 --> 26:58.600]  смотрите тут как бы вот это вот часть это там лямбда x точка п а вот эта часть это есть соответственно
[26:58.600 --> 27:09.960]  вот это вот ку подставляется вместо вот этих х то есть это вот сюда вот и вот сюда вот отображает
[27:09.960 --> 27:23.880]  а лямбда исчезает да то есть получается что значит по бета редукции он приходит в ку ку вот но и
[27:23.880 --> 27:33.840]  значит он сам себя переходит то есть вот это лямбда убирается ку вместо x получается ку ку но это
[27:33.840 --> 27:51.400]  и есть он сам вот ну соответственно это будет бесконечно происходить начнем нормальной формы
[27:51.400 --> 27:59.320]  нету так значит дальше возникает вопрос о единственной о единственности нормальной
[27:59.320 --> 28:09.080]  формы и тут есть такая теорема чорча россера значит о рамбическом свойствия
[28:15.800 --> 28:16.600]  значит из нее
[28:16.600 --> 28:35.000]  в некотором смысле следует единственно нормально форм так о чем так этот шум тоже не слышно
[28:35.000 --> 28:47.240]  ничего себе значит теорем чорча россера без доказательства у нас то что она тоже
[28:47.240 --> 28:54.880]  не очень сложная но довольно такая муторная так значит теорем чорча россера вот такая
[28:54.880 --> 29:08.160]  значит смотрите пусть из термопэя можно прийти рядом преобразований в термку
[29:08.160 --> 29:21.720]  ну только альфа и бета да без без обратных и также из п можно прийти в терм эр значит
[29:21.720 --> 29:36.840]  тогда существует т значит такое что иску можно перейти в т и из эр можно перейти в
[29:36.840 --> 29:48.040]  т то есть это как бы такое замыкание ромба да значит из п мы пришли в ку из п мы пришли в
[29:48.040 --> 29:58.440]  эр значит и это означает что здесь можно достроить этот ромб ну что собственно ромб и получился
[30:05.560 --> 30:12.240]  так хорошо значит какие следствия из этой теоремы
[30:12.240 --> 30:18.360]  значит следствие 1
[30:18.360 --> 30:27.360]  значит следствие 1 это упрощенное определение равенства
[30:27.360 --> 30:41.760]  упрощенное определение равенства значит п равно ку если существует
[30:41.760 --> 30:49.120]  эр значит такое что п преобразуется в эр и ку преобразуется в эр
[30:49.120 --> 31:01.000]  вот но это следует из того что вот вот в этой картинке да у нас как бы много таких уголков и
[31:01.000 --> 31:06.760]  мы сначала вот этот вот ромбик достроили потом вот этот дробник достроили и так далее и у нас
[31:06.760 --> 31:11.840]  там на единицу меньше вершин внизу и дальше еще достраиваем и в итоге такой большой трюгончик
[31:11.840 --> 31:28.360]  получается давайте я так условно нарисую да у нас была такая картина дальше получается вот
[31:28.360 --> 31:39.480]  такая картина на единицу меньше там дальше еще на единицу меньше вот и в итоге получается
[31:39.800 --> 31:47.920]  одна тут вершинка но и если мы по сторонам этой воронки пройдем то как раз придем в эту одну
[31:47.920 --> 31:58.360]  вершину то есть тут получается вот так вот да и вот так вот вот
[32:09.080 --> 32:13.480]  так хорошо следствие 1 а следствие 2 это единственная нормальная форма
[32:17.920 --> 32:32.400]  но можно это по-разному формулировать он пер так что если п равно и оба
[32:32.400 --> 32:44.760]  п ку в нормальной форме то тогда они отличаются только альфа конверсии да то есть п можно
[32:44.760 --> 32:54.640]  по альфа конверсия прийти в ку можно формулировать так что значит нормальная
[32:54.640 --> 33:00.920]  форма единственная с точностью с точностью до альфы конверсия вот так но наказательство
[33:00.920 --> 33:18.360]  следующее доказательства значит мы применяем да значит применять сначала следствие 1
[33:18.360 --> 33:31.200]  значит последствию 1 мы получаем что из п и с ку есть преобразование какой-то
[33:31.200 --> 33:38.240]  р вот при этом поскольку п это нормальная форма то здесь только альфа
[33:38.240 --> 33:56.320]  только альфа так как п это нормальная форма и здесь тоже только альфа только альфа так как
[33:56.320 --> 34:03.760]  у это нормальная форма вот ну а дальше получается что альфа обратимо значит в
[34:03.760 --> 34:18.080]  обратную сторону тоже можно что альфа обратимо и тогда получается что и из r тоже можно попасть
[34:18.080 --> 34:24.280]  только по альфе ну а тогда и с п в ку тоже
[34:24.280 --> 34:47.160]  так ну что насколько
[34:47.160 --> 34:51.880]  понятно это рассуждение
[34:54.280 --> 35:06.520]  ну ладно значит это вот это в общем основной результат про именно синтаксис да без без
[35:06.520 --> 35:14.640]  какой-то без какой-либо семантики значит оставшуюся лекцию говорим про различную
[35:14.640 --> 35:23.360]  семантику то могут означать эти самые лямбда записи но в принципе что угодно на то есть
[35:23.360 --> 35:28.120]  ими можно кодировать любую информацию ну который вообще кодируется натуральными числами или словами
[35:28.120 --> 35:40.640]  вот значит тут есть такое важное понятие комбинатор значит комбинатор это замкнутый
[35:40.640 --> 35:50.880]  замкнутый лямбда терм но то есть там нет свободных переменных да по каждой переменной стоит лямбда
[35:51.280 --> 36:02.280]  вот значит и при помощи комбинаторов можно как бы моделировать вычисления в разных областях
[36:02.280 --> 36:13.880]  дискретной математики при помощи комбинаторов
[36:19.000 --> 36:28.800]  значит можно моделировать вычисления ну или вообще по-другому скажу можно моделировать
[36:28.800 --> 36:31.920]  математические структуры
[36:31.920 --> 37:01.560]  значит но например например булева логика значит а что значит моделируем что вообще хотим
[37:01.560 --> 37:11.280]  значит пример это булева логика
[37:11.280 --> 37:26.600]  значит мы здесь хотим построить значит хотим построить комбинаторы для истины
[37:26.600 --> 37:38.360]  лжи и логических операций значит здесь нужно построить значит комбинаторы
[37:42.360 --> 37:51.000]  ну смотрите лямбда здесь как квантор соответственно квантор может связывать
[37:51.560 --> 37:55.960]  а замкнутый означает что нет свободных переменных да то есть все связаны все связаны
[37:55.960 --> 38:03.520]  дайте здесь и пишу значит без свободных переменных
[38:03.520 --> 38:16.600]  значит нужно построить комбинаторы true false там or and и так далее значит так чтобы они
[38:16.600 --> 38:30.680]  работали также как соответствующие функции значит так что например or true false равняется true
[38:30.680 --> 38:47.960]  да или and false true равняется false ну и так далее на чтобы таблица истинности повторялась через вот это
[38:47.960 --> 38:53.240]  равенство которое понимается как равенство лямбда термов который мы вот только что определили
[38:53.240 --> 39:06.440]  вот значит это можно делать разными способами но один из классических способов такой так
[39:06.440 --> 39:07.800]  значит смотрите false
[39:18.960 --> 39:34.320]  так значит false будет значит лямбда xy точка y true это лямбда xy точка x
[39:34.320 --> 39:42.520]  значит но дальше для логической операции уже возможно разные варианты да например or
[39:42.520 --> 39:52.000]  можно вот так вот значит лямбда x значит точка x
[39:52.000 --> 40:09.040]  ой так два аргумента должно быть лямбда xy лямбда xy точка x дальше true и дальше y
[40:09.040 --> 40:21.280]  значит как это понимается то если x истина то дизюнкция истина если x сложно то дизюнкция
[40:21.280 --> 40:27.760]  такая же как y вот а почему это так работает ну давайте посмотрим вот прямо аккуратно
[40:27.760 --> 40:47.680]  посчитаем значит или or true false or true false значит это будет так и давайте я еще раскрою
[40:47.680 --> 40:57.680]  сокращение значит лямбда x вынесу отдельно дальше плывет лямбда лямбда y точка x true y
[40:57.680 --> 41:10.680]  так значит дальше и дальше false так и давайте еще вот эти скобки тоже поставлю чтобы было
[41:10.680 --> 41:16.680]  понятно как это работает до один раз значит после этого смотрите что получается получается
[41:16.680 --> 41:23.000]  что я сначала внутри вот этой скобки делаю бета редукцию и вот это тру подставляю вместо x
[41:23.000 --> 41:42.880]  значит получается что здесь будет лямбда y true true y и потом еще false дальше это будет теперь
[41:42.880 --> 41:55.720]  false вместо y будет true true false true true false теперь я беру определение true это лямбда xy
[41:55.720 --> 42:13.240]  точка x лямбда xy точка x true false вот ну и здесь давайте я тоже в два шага напишу сначала
[42:13.240 --> 42:24.240]  вместо x подставляю получается лямбда y точка true false ну и потом как бы это false можно просто
[42:24.240 --> 42:29.880]  стереть да и формального поставить вместо y но игрек и там нету поэтому он просто пропадает
[42:29.880 --> 42:41.280]  а получается равно тру ну вот вот такое пробзание на самом деле можно за два шага не делать да
[42:41.280 --> 42:48.600]  можно как бы сразу такую двойную бета редукцию да что тру вместо x а false вместо y вот и здесь
[42:48.600 --> 42:58.040]  тоже да тоже тру вместо x вот это да вот этот тру вместо x вот это точнее вот этот тру вместо
[42:58.040 --> 43:10.360]  x false вместо y ну вот значит есть еще другой вариант
[43:10.360 --> 43:14.960]  значит
[43:25.960 --> 43:31.000]  другой вариант or не используя вообще константы
[43:31.000 --> 43:48.640]  другой вариант or равняется лямбда x y точка x x y на что если x истинно то дизюнкса равна
[43:48.640 --> 43:59.760]  x истине если x ложен то дизюнкса равна соответственно y вот значит соответственно
[43:59.760 --> 44:15.840]  ent получается значит лямбда x y точка x y false на то есть если x истинно то конъюнкса равна y
[44:15.840 --> 44:30.720]  если сложить конъюнкса ложна значит ну или второй вариант лямбда x y точка x y так если
[44:30.720 --> 44:45.840]  x ложна то конъюнкса равна x вот ну например нот тоже есть разные варианты но сам простой
[44:45.840 --> 45:01.080]  будет такой значит лямбда x точка x пол стру а то есть если x истинно то нот x ложна ну и наоборот
[45:01.080 --> 45:17.120]  так ну вот значит это логические операции ну чего понятно так хорошо начну и дальше
[45:17.120 --> 45:22.840]  следующий пример предметной области это натуральные числа
[45:22.840 --> 45:34.280]  натуральные числа нумерал и черча
[45:34.280 --> 45:57.440]  так значит я давайте буду обозначать числами подчеркнутыми значит 0 подчеркнутая значит это
[45:57.440 --> 46:06.320]  будет ну на самом то же самое что false значит только чуть-чуть традиционно по-другому
[46:06.320 --> 46:20.840]  обозначается лямбда fx точка x значит один подчеркнутая и это лямбда fx точка fx дальше
[46:20.840 --> 46:28.840]  два подчеркнутая тоже не то же самое что true значит один это уже свой номерал 2 это
[46:28.840 --> 46:38.080]  лямбда fx f от fx и вот здесь очень важно скобки поставить да потому что по умолчанию скобки
[46:38.080 --> 46:53.560]  другие значит 3 номерал 3 это лямбда fx точка f от f от fx вот ну и так далее и так далее и так
[46:53.560 --> 47:07.520]  далее с номерал n значит это лямбда fx точка f от f и так далее вот f от fx где соответственно
[47:07.520 --> 47:20.640]  вот это вот получается n штук значит как значит номерал смотреть ну может на них смотреть так
[47:20.640 --> 47:31.840]  что вообще тут же как бы два аргумента f и x но вот f это как бы первый аргумент и можно
[47:31.840 --> 47:39.120]  сказать что как бы функция f переходит вот с такую вот функцию ну а что это такое это как бы такая
[47:39.120 --> 47:47.840]  n n и итерация вот но вот так это и надо понимать да что n и номерал черча переводят любую функцию
[47:47.840 --> 47:58.560]  n извините любую функция f в n и итерацию f в том числе нулевой нулевой как бы x это такая
[47:58.560 --> 48:06.960]  нулевая итерация да что тождественная функция да это как бы нулевая итерация любое да значит
[48:06.960 --> 48:19.680]  тут все на месте да тут f переходит в f вот ну а дальше получается вот эти итерации вот хорошо
[48:19.800 --> 48:29.640]  соответственно значит возникает вопрос как значит как тут арифметику выражать
[48:37.920 --> 48:43.320]  вот так значит какие какие будут вопросы
[48:49.760 --> 48:54.000]  значит как выражать арифметические действия
[48:54.000 --> 49:06.920]  значит а именно какие арифметические действия нас будут интересовать значит во-первых
[49:06.920 --> 49:20.880]  прибавление единицы до инкримент значит инкримент это прибавление единицы дальше
[49:20.880 --> 49:35.120]  положение умножение значит дальше так я с вами словами напишу сравнение на то
[49:35.120 --> 49:41.640]  что сравнений бывает много разных там равны неравны и больше меньше там равно нулю не равно нулю и так далее
[49:41.640 --> 49:59.320]  вот значит сравнение дальше декремент вычитание единицы но тут он понимается как значит декремент
[49:59.320 --> 50:11.240]  это будет максимум из n минус 1 и 0 на то есть такой целочисленный вычитание если уже 0 то
[50:11.240 --> 50:23.800]  вычитание ничего не дает если не 0 то это вычитание 1 значит декремент значит дальше вычитание вот и
[50:23.800 --> 50:36.200]  деление вот то есть четыре базы характеристики арифметических действиях ну и всякие вокруг так
[50:36.200 --> 50:50.280]  но что-то из этого мы сейчас изучим так хорошо значит вверх инкримент так значит
[50:50.280 --> 50:56.720]  инкримент будет вот так вот выглядеть но опять же есть самые разные способы собственно и
[50:56.720 --> 51:05.200]  думералы не только черча бывают но вот самое простое значит инкримент вот так вот смотрите
[51:05.200 --> 51:25.880]  внимание лямбда nfx значит а тот будет f вот nfx вот значит почему это так работает ну
[51:25.880 --> 51:34.680]  давайте прям на примере какого-нибудь скажем инкриментируем двойку значит инкримент двойки
[51:34.680 --> 51:47.040]  это что такое что мы вместо n сюда поставим двойку лямбда fx точка f от 2 fx так теперь двойку
[51:47.040 --> 51:54.960]  расписываем по определению но давайте другими буквами да не fx а же y значит здесь будет лямда
[51:55.040 --> 52:09.280]  fx точка f значит здесь будет лямда же y точка же от же игрек значит еще тут скобки нужные и тут
[52:09.400 --> 52:21.560]  вот значит дальше получается что вот это вот f подставляется вот сюда вот и вот сюда вот
[52:21.560 --> 52:34.200]  значит ax подставляется вот сюда соответственно получается что это равняется значит еф вот
[52:34.200 --> 52:42.180]  это вот остается, ну а дальше получается, а сейчас и лямбда fx остается, лямбда fx никуда не
[52:42.180 --> 52:48.940]  девается, за этим мы его здесь написали, чтобы он никогда не делась, лямбда fx остается, f
[52:48.940 --> 52:55.180]  остается, и потом вот эти лямбда исчезают, а вот эти заменяются, как раз f от fx получается,
[52:55.180 --> 53:03.660]  вот то есть это 3, ну и так со всеми остальными тоже получится,
[53:03.660 --> 53:16.540]  да, собственно, неважно сколько раз здесь повторяется g, вот это f будет увеличивать на
[53:16.540 --> 53:26.860]  единицу, вот, значит вот так работает инкримент, так, значит, теперь положение,
[53:26.860 --> 53:31.380]  так, ну, сложение можно двумя способами делать,
[53:31.380 --> 53:47.540]  во-первых, сложение это итерированный инкримент, ну, а то есть можно сказать,
[53:47.540 --> 54:05.540]  что прибавить m к n это m раз прибавить единицу к n, сложение, значит, вариант один,
[54:05.540 --> 54:26.820]  значит, вариант один, написать следующее, лямбда mn точка m inc n, то есть m раз инкриментировали n,
[54:26.820 --> 54:38.340]  ну, а вариант два, это использовать похожую конструкцию, значит, вариант два, вот так,
[54:38.340 --> 54:53.340]  вот, лямбда mn fx точка mf от nfx, вот, ну и тут в целом такая же выкалка получается,
[54:53.340 --> 54:59.020]  так что я повторять не буду, но здесь как бы кроме вот этого, здесь еще тоже вот это m
[54:59.020 --> 55:06.500]  появляется, и тут получится, что сначала f подставляется вместо вот той функции, а вместо
[55:06.500 --> 55:13.220]  x, который там, вот эта вот штука подставляется тоже с замененными f, ну и получается, что сначала
[55:13.220 --> 55:24.620]  снаружи m раз f, потом внутри n раз f и всего m плюс m раз, понятно, так, хорошо, но, в общем,
[55:24.620 --> 55:48.500]  похожим образом, значит, похожим образом умножение, значит, умножение, вот так,
[55:48.500 --> 56:07.940]  вот смотрите, лямбда mn fx точка m, а потом nfx, вот, но я сейчас не буду расписывать подробно,
[56:07.940 --> 56:13.740]  почему это работает, но идея в следующем, да, что вот в m там повторяется много раз функции,
[56:13.740 --> 56:22.020]  каждый раз эту функцию мы заменяем на nf, вот, то есть каждую из m мы заменили на nf, и всего,
[56:22.020 --> 56:35.940]  значит, у нас mn раз будет f применяться, так, ну примерно понятно, да, вот, значит, еще есть возведение
[56:35.940 --> 56:52.380]  степень, проще всего выглядит, значит, но сложнее всего доказывается, лямбда mn fx, а тут будет вообще
[56:52.380 --> 57:03.020]  без скобок, но в другую сторону nmfx, вот, то есть, значит, это будет степень, именно m в степени n,
[57:03.020 --> 57:13.580]  вот, но это я сейчас не буду говорить подробно, почему так, проще всего взять маленький mn,
[57:13.580 --> 57:19.980]  скажем, 2 и 3, и в одном порядке, в другом порядке посмотреть, что будет происходить, ну и там станет
[57:19.980 --> 57:34.340]  понятно, почему это экспонент, так, хорошо, значит, дальше следующая вещь, это сравнение с нулем,
[57:34.340 --> 57:40.340]  да, то есть там не совсем такое, как я написал, сначала сравнение с нулем, потом вычитание,
[57:40.340 --> 57:45.420]  а потом сравнение любое, вот, ну, собственно, понятно, как это вычитание, да, кстати,
[57:45.420 --> 57:56.260]  вычитание, давайте я вернусь сюда и допишу, что вычитание же тоже такое со срезкой, да, значит,
[57:56.260 --> 58:08.140]  то есть sub mn, это будет максимум из m-n и 0, да, то есть, если мы вычитаем слишком много,
[58:08.140 --> 58:17.780]  то результат 0, вот, ну и тогда понятно, как сравнение делать из вычитания, да, что m меньше
[58:17.780 --> 58:23.420]  либо равно, чем n, тогда, только тогда, когда такое вычитание равно нулю, а то есть главное
[58:23.420 --> 58:35.740]  научиться с нулем сравнивать, так, ну, хорошо, значит, как выглядит сравнение с нулем,
[58:35.740 --> 58:40.980]  сравнение с нулем,
[58:40.980 --> 58:49.140]  значит, из 0
[58:55.140 --> 58:57.700]  будет идти так, значит,
[58:57.700 --> 59:05.180]  лямда n, а тут будет, ой, сейчас, нет,
[59:05.980 --> 59:16.340]  лямда n точка n, значит, лямда x точка false и дальше true,
[59:16.340 --> 59:23.660]  вот такая штука, значит, почему она работает,
[59:23.660 --> 59:35.740]  значит, ну, смотрите, значит, из 0 с нулем, но это получается 0,
[59:35.740 --> 59:40.220]  последняясь вместо n, значит, будет 0, потом лямда x точка false,
[59:40.220 --> 59:50.500]  так, из точки, потом true, ну и у нуля тоже как бы два аргумента, соответственно,
[59:50.500 --> 59:57.740]  стоит только второй из них, а второй как раз здесь true, поэтому будет будет true,
[59:57.740 --> 01:00:07.300]  вот, хорошо, значит, дальше, если мы сюда берем какое-то что-то инкрементированное,
[01:00:07.300 --> 01:00:15.700]  значит, 0, n плюс 1, значит, n плюс 1 будет выглядеть так,
[01:00:15.700 --> 01:00:24.220]  значит, будет лямда f, ой, лямда fx, лямда fx точка f, ну и дальше что-то, на самом деле неважно,
[01:00:24.220 --> 01:00:33.140]  что, те остальные n раз там будет, f и потом x, так, значит, такая штука, потом лямда x точка false,
[01:00:33.140 --> 01:00:44.420]  значит, потом true, дальше, смотрите, вот это вот все, значит, лямда x точка false,
[01:00:44.420 --> 01:00:55.140]  оно подставится вот сюда, вот вместо этого f, значит, поэтому здесь получится
[01:00:55.140 --> 01:01:10.140]  лямда x точка false, ну и тут что-то, это что-то уже другое будет, но неважно, что, потому что тут
[01:01:10.140 --> 01:01:15.100]  просто x нету, и поэтому неважно, что он поставит вместо x, результатом будет false,
[01:01:15.100 --> 01:01:26.580]  в общем, действительно получается, что поставили 0, получили true, поставили не 0, получили false,
[01:01:26.580 --> 01:01:40.180]  так, хорошо, значит, теперь декремент, вычитание единицы,
[01:01:56.580 --> 01:02:18.660]  значит, это так называемый трюк к линии, значит, трюк к линии заключается в следующем,
[01:02:18.660 --> 01:02:34.140]  значит, смотрите, рассмотрим такое преобразование, значит, пара x и y,
[01:02:34.140 --> 01:02:47.900]  значит, переходят в f от x и x, что будет, если мы будем интерировать такое преобразование,
[01:02:47.900 --> 01:03:05.980]  значит, но если мы начнем x, x, значит, то тогда будет f от x, x, потом f от f от x, f от x,
[01:03:05.980 --> 01:03:20.500]  значит, и так далее, и после одного шага получится f в n и от x, fn-1 от x,
[01:03:20.500 --> 01:03:43.420]  вот, и идея декремента такая, значит, идея самого трюка, что нужно сделать 1 раз такое
[01:03:43.420 --> 01:03:55.340]  преобразование, взять второй элемент пары, значит, идея, что сделать преобразование n раз,
[01:03:55.340 --> 01:04:11.020]  взять второй элемент пары, вот, но чтобы это работало, нужно вообще уметь, иметь какие-то
[01:04:11.020 --> 01:04:35.180]  комбинаторы для работы с парами, значит, нужны комбинаторы для работы парами упорядочными,
[01:04:35.180 --> 01:04:52.380]  да, то есть должно быть что-то вроде того, что left от pair x и y, это должно быть x, да,
[01:04:52.380 --> 01:05:15.820]  right от pair x и y, значит, это y, вот, ну и на самом деле такие комбинаторы строятся на базе
[01:05:16.300 --> 01:05:23.140]  логических функций, значит, комбинаторы пары,
[01:05:23.140 --> 01:05:51.300]  значит, pair это лямбда xyp.pxy, значит, дальше left это лямбда p,
[01:05:51.300 --> 01:06:15.340]  п.птру и right это лямбда п.пф, значит, почему это работает, ну, смотрите, что такое будет пары xy,
[01:06:15.340 --> 01:06:29.540]  да, значит, pair xy, это будет, ну, без лямбда, да, это будет просто без xay в лямбдах, лямбда p.pxy,
[01:06:29.540 --> 01:06:48.140]  а, например, left от pair xy, значит, смотрите, в left у меня вот здесь вот p, то есть вместо p
[01:06:48.140 --> 01:07:02.780]  нужно вот это подставить, лямбда p.pxy и дальше true, теперь еще одна бета-редукция, что мы вот
[01:07:02.780 --> 01:07:13.460]  это true вместо p подставляем, то есть получается true xy, ну а true xy это x, это мы уже изучали,
[01:07:13.460 --> 01:07:18.660]  вот, ну и справа часть точно так же получается,
[01:07:30.900 --> 01:07:42.460]  да, хорошо, значит, как теперь это все реализовать, если у нас уже есть функция для работы с парами,
[01:07:42.460 --> 01:07:54.140]  так, значит, смотрите, еще сюда иду, тут на самом деле под спудной есть преобразование функции f,
[01:07:54.140 --> 01:08:02.380]  вот такую вот функцию, и нужно сначала это преобразование как-то записать, а потом его
[01:08:02.380 --> 01:08:09.060]  использовать, так, сейчас уже будет немножко сложнее, чем все предыдущее, сейчас, а на семинарах
[01:08:09.060 --> 01:08:23.980]  это кто-нибудь доходил, а в одной группе доходили, да, ну да, ну хорошо, ну, значит, там все понятно,
[01:08:23.980 --> 01:08:43.780]  там в основной программе дальше мы и не идем, ну ладно, сейчас я 2 минуты запишу и немножко
[01:08:43.780 --> 01:08:50.300]  про неподвижную точку поговорим, так, значит, смотрите, возится такая вспомогательная функция,
[01:08:50.780 --> 01:08:55.540]  значит, decrement function,
[01:08:55.540 --> 01:09:15.500]  значит, которая будет вот так вот выглядеть, значит, лямбда fp, точка pair,
[01:09:15.500 --> 01:09:34.940]  значит, здесь будет f от left p, значит, и дальше left p,
[01:09:34.940 --> 01:09:45.180]  вот, то здесь понимается, значит, п понимается как пара, а f, то есть это, собственно говоря,
[01:09:45.180 --> 01:09:54.580]  следующее, это функция берет f и берет исходную пару xy и делает из этого пару f от xx,
[01:09:54.580 --> 01:10:07.140]  значит, поэтому здесь f от left p, значит, здесь left p, вот, хорошо, значит, как теперь ее использовать,
[01:10:07.140 --> 01:10:30.020]  так, значит, теперь deck, значит, deck будет выглядеть так, значит, лямбда nfx, значит, точка
[01:10:30.020 --> 01:10:58.420]  right, значит, дальше будет n раз мы применили deck fn, f, так, и вот так вот, наверное,
[01:10:58.420 --> 01:11:08.860]  что это deck fn, f это же функция от пары, то есть мы n раз итерируем вот это преобразование,
[01:11:08.860 --> 01:11:22.900]  значит, да, еще с чем начинаем, пара из xx, значит, пара xx, так, и теперь вот эту скобку закрываем,
[01:11:22.900 --> 01:11:29.700]  так, ну и вроде, да, вроде скобки никакие не забытые, вроде, должно быть правильно,
[01:11:29.700 --> 01:11:39.300]  смотрите, как это понимать, вот, мы взяли такое преобразование, так, давайте тут какие-то
[01:11:39.300 --> 01:11:50.180]  комментарии напишу, значит, вот это вот сейчас, нет, сначала вот эта вот штука, это что, значит,
[01:11:50.180 --> 01:12:03.340]  xy преобразуется в f от xx, значит, соответственно, вот эта вот штука, когда бы n раз итерируем,
[01:12:03.340 --> 01:12:15.020]  то это получается, то xy преобразуется в fn от x, да, и fn-1 от x,
[01:12:20.540 --> 01:12:30.340]  соответственно, вот эта штука, это просто пара xx, значит, так получается, когда мы вот эту, вот это
[01:12:30.340 --> 01:12:36.020]  преобразование применили вот к этому аргументу, то мы, собственно, получили тоже здесь право написано,
[01:12:36.020 --> 01:12:48.140]  значит, здесь будет f в n и от x, f в n-1 от x, вот, ну а потом мы взяли правую часть,
[01:12:48.140 --> 01:12:59.980]  значит, правая часть, значит, получается fn-1 от x, а потом еще и лямбда fx добавили,
[01:12:59.980 --> 01:13:11.500]  и это как раз получается fn-1 нумерал, да, если я это тоже допишу, да, значит, вот с этим вместе
[01:13:11.500 --> 01:13:25.020]  получается n-1 нумерал, вот, ну вот, значит, так вычитается единица, ну а дальше что-нибудь
[01:13:25.020 --> 01:13:33.940]  еще вычитается просто итерированием, да, то есть дальше можно написать, что, значит, sub это будет
[01:13:33.940 --> 01:13:48.140]  лямбда mn точка здесь, значит, n раз применили декремент m, вот, ну и дальше, например, можно
[01:13:48.140 --> 01:14:05.380]  сравнение greater equal, да, больше либо равно, значит, тут будет лямбда mn точка из 0, значит,
[01:14:05.380 --> 01:14:10.340]  а тут будет sub, только не перепутать какой порядок, если m больше либо равно n, то нужно
[01:14:10.340 --> 01:14:26.940]  из m вычитать, да, то есть тут будет sub nm, вот, ну хорошо, значит, остается рекурсивное
[01:14:26.940 --> 01:14:32.660]  программирование, да, и неподвижная точка, да, есть какие-нибудь вопросы, вот, по обсуждениям,
[01:14:32.660 --> 01:14:37.700]  хорошо, значит, рекурсивное программирование, значит, конечно, отделить рекурсии это
[01:14:37.700 --> 01:14:45.540]  немножко странно, да, и так вообще не делают, вот, но, в принципе, не запрещено, да, то есть, ну,
[01:14:45.540 --> 01:14:55.380]  значит, я буду иметь тут целочисленное деление, да, значит, целая часть m делить на n, значит,
[01:14:55.380 --> 01:15:04.300]  это будет следующее, значит, это будет 0, если m меньше n, да, кстати, а как строго неравенство
[01:15:04.300 --> 01:15:09.100]  получить, ну, просто отрицание противоположного нестрогого, да, отрицание у нас есть,
[01:15:09.100 --> 01:15:15.700]  соответственно, нестрого есть, значит, строгое тоже есть, значит, целая часть m делить на n,
[01:15:15.700 --> 01:15:29.660]  это 0, если m меньше n, либо, значит, инкремент от целой части m-m делить на n, значит, если m
[01:15:29.660 --> 01:15:43.100]  больше либо равно m, так, значит, еще, кстати, заметьте, что нам отдельного оператора if даже
[01:15:43.100 --> 01:15:50.820]  не нужно, да, потому что наши логические значения не сами работают как тернарный оператор, да,
[01:15:50.820 --> 01:15:56.180]  то есть, вот, если истина, то берется второе значение, если ложь, то берется третье значение,
[01:15:56.180 --> 01:16:08.860]  вот, так, ну и получается, например, можно так написать, значит, можно вот то же самое,
[01:16:08.860 --> 01:16:23.780]  значит, записать, тогда я тебе через номерал напишу, div mn, значит, это так,
[01:16:23.780 --> 01:16:40.580]  давайте я прям помею местами, чтобы je использовать, значит, je mn, дальше будет ink,
[01:16:40.580 --> 01:17:03.060]  значит, increment от div от sub mn и n, так, и increment закрыть, ну а иначе просто 0,
[01:17:03.060 --> 01:17:17.740]  вот так вот, вот, и что здесь получается, получается что-то вроде уравнения, да, что у нас
[01:17:17.740 --> 01:17:25.660]  слева и справа есть как бы неизвестный комбинатор div, да, значит, вот он есть здесь, и вот он есть
[01:17:25.660 --> 01:17:39.900]  здесь, значит, и получается, что это уравнение на div, и соответственно нужно найти его корень,
[01:17:39.900 --> 01:17:45.780]  вот, ну, можно говорить тернах корня, а можно говорить тернах неподвижной точки,
[01:17:45.780 --> 01:17:57.500]  значит, тернах неподвижной точки, получается, что у нас есть преобразование, которое берет
[01:17:57.500 --> 01:18:07.740]  произвольную функцию и ее как бы сюда подставляет и получает новую функцию, вот, и div это ее неподвижная
[01:18:07.740 --> 01:18:20.140]  точка, его неподвижная точка, значит, или это div, это неподвижная точка
[01:18:20.140 --> 01:18:47.620]  преобразования, так, ну я не буду там переписывать, так, значит, как это дальше делается, но в духе
[01:18:47.620 --> 01:18:54.940]  преобразования, значит, можно div там fn, смогательная функция для div, значит, это будет
[01:18:54.940 --> 01:19:04.020]  выглядеть так, значит, лямбда gmn, значит, я от нумералов перехожу к переменным, значит, дальше
[01:19:04.020 --> 01:19:21.060]  как там, как там, да, значит, gmn, значит, дальше инкремент от div, ой да, правильно, да,
[01:19:21.060 --> 01:19:39.700]  значит, инкремент aj от submn, значит, дальше n, так, и ноль, вот, не, ну да, собственно,
[01:19:39.700 --> 01:19:47.300]  можно сказать, что вот как раз у этого преобразования div должен быть неподвижной точкой, вот, то есть мы
[01:19:47.300 --> 01:20:10.940]  хотим, чтобы было следующее, значит, хотим, чтобы div равнялся, значит, div fn div, вот, ну и есть
[01:20:10.940 --> 01:20:28.580]  общий метод, значит, и y-комбинатор, значит, существует общий метод поиска неподвижных точек,
[01:20:28.580 --> 01:20:50.460]  значит, это специальный y-комбинатор, значит, y-комбинатор такой, что для любого f выполнено,
[01:20:50.460 --> 01:21:12.860]  что yf равняется f от yf, но есть разные y-комбинаторы, вот, ну, например, вот такой вот подходит,
[01:21:12.860 --> 01:21:40.140]  значит, пример y-комбинатора, так, ну, например, вот так вот, значит,
[01:21:40.140 --> 01:21:51.220]  лямбда xy точка y от xxy, и еще раз повторяем то же самое, да, то есть y равняется вот
[01:21:51.220 --> 01:22:12.100]  это сам на себя, лямбда xy точка y xxy, вот, значит, тогда смотрите, чему это работает, так, yf, значит,
[01:22:12.100 --> 01:22:28.500]  это лямбда xy точка y от xxy, значит, лямбда xy точка y от xxy, и f, значит, здесь получается, что вот это
[01:22:28.500 --> 01:22:38.740]  вот должно быть подставлено вместо x, да, вот сюда вот, и вот сюда вот, а вот это должно быть
[01:22:38.740 --> 01:22:51.300]  поставлено вместо y, а вот сюда вот, и вот сюда вот, ну, и как раз то же самое получится, значит,
[01:22:51.300 --> 01:23:18.580]  лямбда xy точка y от xxy, значит, лямбда xy точка y от xxy, так, и еще f,
[01:23:18.580 --> 01:23:32.140]  ну, а здесь как раз y получился, то есть это f от yf, вот, ну и, соответственно, вот этот метод
[01:23:32.140 --> 01:23:40.380]  позволяет любую рекурсивную функцию вычислять, то есть сначала записать рекурсивную формулу,
[01:23:40.380 --> 01:23:48.420]  что функция вычисляется через саму себя, каким-то базовым случаем, вот, потом составить вот такое
[01:23:48.420 --> 01:23:54.980]  преобразование, да, значит, такое рекуррентное преобразование, и потом применить y комбинатор,
[01:23:54.980 --> 01:24:06.260]  и как раз будет неподвижная точка. Это мы так определяем, значит, смотрите, откуда оно взялось,
[01:24:06.260 --> 01:24:20.700]  вот здесь вот я вот это div заменил на j, как бы на аргумент, и дальше смотрите, вот если, если я вот
[01:24:20.700 --> 01:24:31.340]  сюда вот еще как бы применю kmn, да, то слева будет как раз divmn, а справа будет как раз вот это
[01:24:31.340 --> 01:24:38.140]  выражение, да, потому что вот эта вот функция g заменится на div, ну а mn заменится как бы на
[01:24:38.140 --> 01:24:48.620]  номерал mn, вот, поэтому, но вот из этого соотношения следует то, что нам нужно, да, если мы левую правую
[01:24:48.620 --> 01:24:54.540]  часть вычислим на паре mn, то будет ровно то, что нам нужно, значит, если мы добьемся, что выполнено
[01:24:54.540 --> 01:25:03.300]  вот это, то выполнено не то, что нам нужно, и значит, это будет нужный, нужный этот самый комбинатор,
[01:25:03.300 --> 01:25:16.260]  ну вот, так, ну вот, значит, это такие самые-самые основные вещи про лямбда исчисления, значит,
[01:25:16.260 --> 01:25:22.820]  там можно, например, какие-то более сложные вещи делать, есть свой аналог проблемы остановки,
[01:25:22.820 --> 01:25:29.760]  значит, а именно нельзя написать лямбда комбинатор, который будет по другим лямбда комбинатором
[01:25:29.760 --> 01:25:35.020]  определять, есть ли у них нормальная форма, да, вместо проблем остановки будет сочетание нормальной
[01:25:35.020 --> 01:25:47.500]  формы, вот, но и в целом получается теория эквивалентной теории вычислимости классической, вот, но не настолько
[01:25:47.500 --> 01:25:54.620]  широко распространенной, но тем не менее многие идеи отсюда используются в функциональном
[01:25:54.620 --> 01:26:02.420]  программировании и соответствующих языках типа хаскела, собственно, хаскел карри это один из
[01:26:02.420 --> 01:26:09.980]  главных создателей этой теории, вот, в честь него даже два языка программирования есть язык хаскела,
[01:26:09.980 --> 01:26:21.220]  а есть язык карри. Всё, я думаю, на этом всё, спасибо за внимание, значит, некоторое количество задач
[01:26:21.220 --> 01:26:28.260]  уже выдано, значит, будет еще последний зачетный листочек в ближайшее время, его можно будет сдавать
[01:26:28.260 --> 01:26:33.820]  до, ну, практически до экзамена, минус время на проверку, то есть экзамен минус два дня,
[01:26:33.820 --> 01:26:43.180]  вот, спасибо, что ходили и слушали, надеюсь, было интересно, ну и до встречи на других курсах,
[01:26:43.180 --> 01:26:45.740]  до свидания.
