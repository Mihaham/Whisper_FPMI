[00:00.000 --> 00:17.240]  что добрый вечер давайте начинать сегодня у нас будет тема про минимальные астовы в графе
[00:30.000 --> 00:32.120]  по-английски это называется минимум спеннен трис
[00:44.120 --> 00:46.560]  ну соответственно аббревиатура мст
[00:46.560 --> 00:58.440]  вот ну давайте считать что мы живем в неориентированном взвешенном графе то есть
[00:58.840 --> 01:05.560]  ребра не ориентированными но взвешеным у каждого ребра есть стоимость мы хотим
[01:05.560 --> 01:12.440]  давай считать что граф связный мы хотим выбрать наименьшее по стоимости под множество
[01:12.440 --> 01:19.040]  ребер так чтобы вот если оставить только выбранные ребра граф остался связным то есть
[01:19.040 --> 01:24.120]  мы хотим как бы оставить как можно меньше ребер как потратил как можно меньше суммарную
[01:24.120 --> 01:28.400]  стоимость, чтобы граф не потерял свою связанность. Ну, грубо говоря, у вас есть там какая-то
[01:28.400 --> 01:35.320]  транспортная карта, вершины это города, а ребра это дороги. Вы хотите какие-то дороги как бы
[01:35.320 --> 01:40.080]  построить так, чтобы из любого города можно было добраться до любого другого, чтобы граф был
[01:40.080 --> 01:46.280]  связанный, но при этом не очень много денег потратить. Вот, собственно, вот такую задачу будем
[01:46.280 --> 01:55.920]  сегодня решать. Давайте определение в формальную виду. Значит, пусть g это какой-то граф,
[01:55.920 --> 02:10.200]  тогда h, у которого множество вершин это v', а множество ребер это e', называется под графом g,
[02:10.520 --> 02:22.580]  если v' это под множество v, а e' это под множество e. Под граф g, если v' это под множество v,
[02:22.580 --> 02:28.840]  а e' это под множество e. Под граф это когда мы оставили только какие-то вершины или какие-то
[02:28.840 --> 02:38.240]  ребра. Любое под множество вершин, любое под множество ребер. Дальше, если v' в точности
[02:38.240 --> 02:43.120]  совпадает с v, то есть мы не удаляли вершины, а могли удалять только ребра, то есть у нас все
[02:43.120 --> 02:48.600]  вершины сохранились в этом подграфе, могли только какие-то ребра пропасть в e'. Тогда h называется
[02:48.600 --> 03:01.160]  остовным подграфом. h – остовный подграф g. Если вы вершины не удаляли, удаляли только ребра,
[03:01.160 --> 03:11.360]  то это остовный подграф. Ну и если v' равно v и h – это дерево, то h называется остовным деревом.
[03:11.360 --> 03:29.520]  h – это дерево, то h – это остовное дерево g. Ну и, соответственно, наша задача – найти
[03:29.520 --> 03:36.480]  остовное дерево, суммарный вес ребер, в котором минимально возможен. То есть задача такая,
[03:36.480 --> 03:40.840]  что у нас есть граф с еще какой-то весовой функцией на ребрах, то есть ребра взвешенные,
[03:40.840 --> 03:46.360]  и мы хотим найти какое-то остовное дерево, у которого суммарный вес всех ребер минимально
[03:46.360 --> 04:02.400]  возможен. Ну, соответственно, задача – найти остовное дерево минимального веса. Вот,
[04:02.400 --> 04:31.000]  такую задачу сегодня будем решать. Так, хорошо. Ну, чтобы жилось хорошо, мне нужна
[04:31.000 --> 04:45.080]  будет лемма о безопасном ребре. Она говорит о том, как можно, собственно, строить это вот остовное
[04:45.080 --> 04:49.280]  дерево минимальное итеративно. Значит, у меня все алгоритмы будут примерно такие. Давайте найдем
[04:49.280 --> 04:55.200]  какое-нибудь ребро, добавим его в остов. Давайте найдем следующее ребро, добавим его в наше остовное
[04:55.200 --> 04:59.640]  дерево и так далее. Будем там по одному или какими-то группками добавлять вот эти вот оптимальные
[04:59.640 --> 05:05.280]  ребра в остов, пока не получится остовное дерево, то есть граф, который связывает все вершины. Вот,
[05:05.280 --> 05:08.520]  ну и, собственно, лемма о безопасном ребре говорит, какие именно ребра нам можно добавлять.
[05:08.520 --> 05:21.860]  Значит, ну пусть g – это граф, не буду писать, пусть s – это, так сейчас скажу, ну да, остовный под
[05:21.860 --> 05:35.780]  граф g, остовный под граф g, являющийся под множеством какого-то минимального остова. Давайте под графом
[05:35.780 --> 05:55.060]  напишу под графом какого-то минимального остовного дерева. Пусть c – это какая-то из компонент
[05:55.060 --> 06:09.620]  связанности внутри s. Значит, какая-то компонента связанности в s. Значит, ну картинку давайте
[06:09.620 --> 06:15.300]  сразу нарисую. Вот у меня есть граф g, в нем выбрано s, который является под множеством
[06:15.300 --> 06:19.860]  минимального остова. Да, ну раз минимальный остов – это дерево, то понятно, что под граф
[06:20.860 --> 06:27.340]  какой-то кусок несколько несвязанных деревьев. То есть у меня все s распадается на какие-то
[06:27.340 --> 06:34.180]  вот такие вот облачка, в каждой компоненте у меня дерево, потому что дерево вообще-то граф
[06:34.180 --> 06:38.860]  без циклов. Понятно, что если я рассмотрю под граф, у меня тоже будет граф без циклов. Вот,
[06:38.860 --> 06:43.260]  поэтому вот этот s ведет себя как-то вот так. Это какие-то такие несвязанные компоненты,
[06:43.260 --> 06:47.940]  внутри каждой компоненты какое-то дерево. Пусть c – это произвольная из этих компонент
[06:47.940 --> 06:56.620]  связанности, скажем вот это вот. Тогда пусть e – это самая дешевая из всех ребер, которая
[06:56.620 --> 07:02.020]  соединяет c со всем остальным. То есть я рассматриваю все ребра, выходящие из этого c, во внешность
[07:02.020 --> 07:07.340]  вот этой компоненты. То есть я перебираю все вот эти вот ребра, да, выбираю из них самые дешевые,
[07:07.340 --> 07:30.420]  пусть это e. Пусть e – самое дешевое ребро между c и, ну, всем без c, между c и v без c. Тогда я
[07:30.420 --> 07:38.100]  утверждаю, что это ребро можно добавить смело в s. То есть если я вот это вот e добавлю в s,
[07:38.100 --> 07:45.340]  то у меня по-прежнему получится под множество минимального стола. Значит, тогда s плюс e тоже
[07:45.340 --> 07:49.900]  под множество какого-то минимального стола, тоже под граф какого-то минимального стола.
[07:49.900 --> 08:06.220]  Вот. Ну, то есть буквально, если у меня было какое-то вот такое состояние моих деревьев,
[08:06.220 --> 08:10.820]  я взял самое дешевое ребро, торчащее из одного из них, добавил его в s, соответственно, у меня
[08:10.820 --> 08:15.900]  тогда две компоненты склеились. Вот эти две компоненты склеились. Ну, я утверждаю, что так
[08:15.900 --> 08:20.060]  можно делать. То есть если я раньше был гарантированно под множеством mst, то после
[08:20.060 --> 08:24.340]  добавления вот этого e – безопасного ребра, самого дешевого ребра, торчащего из данной
[08:24.340 --> 08:31.780]  компоненты, я по-прежнему буду под множеством какого-то минимального стола. Так, ну, доказательство
[08:31.780 --> 08:43.260]  вроде нехитрое. Давайте я обзову концы вот этого ребра как u и v. Значит, пусть e соединяет вершины
[08:43.260 --> 08:57.420]  u и v. Вот. Вопрос какой-то нет? Хорошо. Ну, оно гарантированно ведет в другую компоненту,
[08:57.420 --> 09:03.900]  потому что у меня весь граф g распадается на компоненты связанности по вот этим вот ребрам из
[09:03.900 --> 09:10.060]  s. Соответственно, у меня все кластеризовалось на такие облачка. Вот я рассматриваю самый дешевый,
[09:10.060 --> 09:17.340]  торчащий из этого облачка. Он куда-то торчит в одной из других облачков. Вот. Ну, значит,
[09:17.340 --> 09:23.940]  давайте скажем следующее. Пусть t – это вот тот самый миностов, который является над графом s.
[09:23.940 --> 09:37.580]  mst такое, что s вложено в t. Вот этот вот самый миностов из условия. Ну, если s плюс e тоже вложено
[09:37.580 --> 09:47.180]  в t, то доказывать нечего. Да, ну, потому что вот это является подножие минимального
[09:47.180 --> 09:51.300]  остова, а мы ровно это и хотим доказать. Что s плюс e тоже под граф какого-то минимального
[09:51.300 --> 09:58.300]  остова. Если того же самого, то все вообще хорошо. Теперь пусть не так. Пусть вот это вот ребро e не
[09:58.300 --> 10:07.020]  входит в t. Вот. Ну, что это значит? t же у нас все равно остовное дерево, правильно? Значит,
[10:07.020 --> 10:11.660]  в частности, вот эти вот вершинки u и v каким-то образом в графе t связаны. Напоминаю, t – это
[10:11.660 --> 10:17.980]  какое-то минимальное остовное дерево, содержащее s. u и v – какие-то две вершины графа. Понятное
[10:17.980 --> 10:22.620]  дело, что в дереве они должны быть связаны каким-то путем. Ну, потому что у меня остовное дерево
[10:22.620 --> 10:26.700]  соединяет вообще все вершинки, да, обеспечивает связанность всего графа. Значит, в частности,
[10:26.780 --> 10:33.940]  в t есть какой-то путь между u и v. Давайте его как-то нарисуем. Ну, что-то такое. Вот этот вот путь,
[10:33.940 --> 10:41.740]  соединяющий u и v в дереве t. Вот. Ну, понятно, что в какой-то момент он должен выйти из вот
[10:41.740 --> 10:47.580]  этого вот облачка, из этой компонента c. Давайте я это ребро назову e штрих. То есть, еще раз,
[10:47.580 --> 10:53.220]  я рассматриваю путь из u и v по дереву t. Понятно, что поскольку u и v находятся в разных облачках
[10:53.220 --> 10:57.340]  относительно s, то значит, когда-то этот путь впервые выходит из этого облачка c. Вот из
[10:57.340 --> 11:02.580]  этого облачка когда-то выходит. Ну, получается, ребро e штрих. Понятно тогда, что вес ребра e
[11:02.580 --> 11:08.380]  штрих больше, чем e. Ну, по условию, потому что e минимальное. Тогда я мог бы просто e штрих удалить,
[11:08.380 --> 11:13.740]  добавить e и получить остов меньшего веса. То есть, я связанность не потеряю, потому что я по факту
[11:13.740 --> 11:19.460]  на цикле одно ребро удалил, другое добавил, а вес уменьшил. Ну, все, значит, тогда, ну,
[11:19.460 --> 11:28.940]  противоречие в каком-то смысле. Вот, теперь давайте это запишем. Рассмотрим путь между u и v
[11:28.940 --> 11:50.500]  в дереве t. Пусть e штрих это первое ребро в этом пути, выходящее из c. Первое ребро в этом пути,
[11:50.500 --> 12:07.420]  выходящее из c. Вот, ну, тогда его вес больше либо равен, чем вес e, по предположению. Ну, потому
[12:07.420 --> 12:12.940]  что e это самое дешевое вообще из всех ребер, выходящих из c. Вот, ну и тогда, если просто на
[12:12.940 --> 12:21.340]  этом пути e штрих удалить, а e добавить, то у меня останется связанный граф, вот, и при этом его вес
[12:21.340 --> 12:28.980]  не уменьшится. Значит, тогда, если я рассмотрю такой граф t без e штриха, но с e, то есть, я вот
[12:28.980 --> 12:35.700]  это удаляю, а это добавляю. Тогда эта штука, это тоже будет остовное дерево, вес которого не больше,
[12:35.700 --> 12:53.140]  чем вес t. Тоже остовное дерево, вес которого не больше, чем вес дерева t, потому что я выкинул
[12:53.140 --> 12:58.900]  одно ребро и добавил другое, но вес добавленного меньше либо равен, чем вес удаленного. Вот, ну,
[12:58.900 --> 13:18.340]  значит, просто s плюс e это под граф вот этого нового дерева. Это тоже мст. Конец. Понятно?
[13:18.340 --> 13:30.980]  Ну, хорошо. Ну, собственно, вот основная лемма такая. Дальше можно всякими разными способами
[13:30.980 --> 13:35.180]  ее применять, получать несколько разных алгоритмов, которые, собственно, получают
[13:35.180 --> 13:43.740]  минимальный остов. Ну, давайте с самого простого начнем. Называется алгоритм Прима. Что он делает?
[13:43.740 --> 13:50.500]  Он сначала берет одну вершину, просто первую, скажем, и находит самое дешевое ребро, торчащее
[13:50.500 --> 13:56.660]  из нее. Ну, куда-то вот сюда. Давайте скажем, что это вершина номер два. Вот это самое дешевое
[13:56.660 --> 14:04.380]  ребро, торчащее из вершины 1. Теперь он берет это ребро в миностов и ищет опять самое дешевое
[14:04.380 --> 14:10.780]  ребро, торчащее из вот этого вот во внешность. Ну, пусть там это вот такое ребро. Дальше говорит,
[14:10.800 --> 14:16.100]  что это тоже ребро в миностове и вот это вот все теперь наше текущее множество. Опять рассматриваем
[14:16.100 --> 14:21.780]  самое дешевое ребро, торчащее из этого облачка во вне. Например, что-нибудь вот такое и добавляем
[14:21.780 --> 14:26.520]  опять это ребро множество, ну, и так далее. Просто каждый раз у нас есть какое-то текущее состояние
[14:26.520 --> 14:31.900]  миностова. Я каждый раз рассматриваю самое дешевое ребро из него торчащее. Собственно, как вот здесь
[14:31.900 --> 14:36.420]  было это вот наше текущее множество. Я расс lutrin самый дешевый ребро и добавляю его просто в
[14:36.420 --> 14:43.220]  и так по одному ребру добавляю добавляю пока весь граф не исчерпаю вот ну формально давайте
[14:43.220 --> 14:49.740]  напишу скажем что пусть скажем ци 1 это просто множество из первой вершинки да дальше в цикле
[14:49.740 --> 14:58.100]  от 2 до n пусть е это самый дешевый ребро между ци и всем остальным
[14:58.100 --> 15:17.060]  точнее между ци минус первым и всем остальным ну и просто напишу что ци это это предыдущие да плюс
[15:17.060 --> 15:23.020]  вот это новое ребро е то есть я просто одно ребро добавляю и получаю но как бы ну больше больше
[15:23.020 --> 15:38.220]  под граф минус 100 вот нормально ну вот собственно корректность непосредственно следует из лемы
[15:38.220 --> 15:43.060]  безопасном ребре потому что изначально понятное дело пустой граф граф без ребер является под множеством
[15:44.060 --> 15:48.860]  дальше я каждый раз добавляю одно из безопасных ребер то есть я имею вот эту вот текущую компоненту
[15:48.860 --> 15:53.860]  связанности ци рассматриваю самый дешево торчащий из нее ребро и добавляю в минус 100 добавляю в
[15:53.860 --> 15:57.940]  текущие в текущие ци так можно делать по лемме значит в конце получится правильный минус 100 ну
[15:57.940 --> 16:03.300]  то есть по факту просто можно жадно действовать да выбирать каждый раз самое дешевое ребро вот и
[16:03.300 --> 16:08.980]  тогда получится в конце то что нужно так значит теперь как это реализовать за сколько это можно
[16:08.980 --> 16:17.420]  сделать но смотрите можно это сделать просто за н в квадрате а если для каждой вершины давайте
[16:17.420 --> 16:23.620]  вот так вот что-то сделаю пусть это вот мой текущая ци это вот я хочу для каждой вершины поддерживать
[16:23.620 --> 16:31.460]  самое дешевое из ребер торчащих вот как бы между в и ци это то есть давайте я заведу массив д от
[16:31.460 --> 16:41.940]  в который должен хранить вес самого дешевого из вот этих вот ребер самое дешевое из этих ребер
[16:41.940 --> 16:54.140]  вот тогда что происходит ну во первых мне нужно находить как раз вот самое дешевое
[16:54.140 --> 16:58.900]  ребро между циитом и всем всем остальным отец просто линийное время вот этот вот шаг я
[16:58.900 --> 17:03.740]  могу сделать за линией на время просто пройтись по всем вершинам и выбрав минимально д от в то есть
[17:03.740 --> 17:09.700]  для каждой вершины хранится самое дешевое ребро в ци это в текущая ц я пробегаюсь по всем вершинам
[17:09.700 --> 17:16.300]  вне ци и выбираю самое маленькое д от в работать за линию вот ну и дальше мне нужно что мне нужно
[17:16.300 --> 17:21.700]  вот этот ребро который я получил нужно его добавить ну то есть я скажем понял что вот
[17:21.700 --> 17:28.100]  этот самый дешево интересующий мне ребро я хочу добавить его в ци и т в текущем множество ц вот
[17:28.100 --> 17:32.340]  ну и тогда у меня д все пересчитаются потому что у меня ц изменилась множество ц изменилась
[17:32.340 --> 17:43.140]  мне нужно все остальные д пересчитать для каждой вы храню такое число теперь чтобы взять посмотри
[17:43.140 --> 17:47.460]  вот этот вот шаг да пусть я самый дешевый ребро бла бла бла я за линийное время просто
[17:47.460 --> 17:55.940]  прохожу по всем вершинам вне текущего ц и выбираю ту из них в который д от в минимально возможно да
[17:55.940 --> 17:59.780]  но вот вот я хочу еще поддерживать массив д от в чтобы эффективно реагировать алгоритм я
[17:59.780 --> 18:04.500]  буду поддерживать массив д от в для каждой вершинки значит тогда вот это могу сделать за линию просто
[18:04.500 --> 18:10.980]  пройтись по массиву дальше у меня изменяется ц значит у меня изменяется д потому что у меня
[18:10.980 --> 18:15.620]  добавилось какое-то ребро и скажем для какой-то еще вершинки x у меня возможно появилось новое
[18:15.620 --> 18:21.740]  самое дешевое ребро ведущие вот сюда вот ну нужно просто это это обработать значит в момент когда
[18:21.740 --> 18:27.020]  в добавляется к ц вот сюда вот оно вливается мне нужно по факту перебрать все возможные ребра
[18:27.020 --> 18:32.940]  исходящие из в и обновить для них для них дежки то есть вот в этот момент времени да чтобы обновить
[18:32.940 --> 18:40.100]  д мне нужно рассмотреть все ребра из в в икс для каждого икса и обновить д от икс через вес этого
[18:40.100 --> 18:51.620]  ребра так давайте что-то напишем для всех ребер в запятая икс д от икс равно минимум из
[18:51.620 --> 19:06.740]  того что там и так лежала и собственно вес этого ребра почему ну еще раз да вот у меня было
[19:06.820 --> 19:12.340]  маленькое ce и я для каждой вашинки x наш замали дешевые с月 вот этих вот ребер между ц и
[19:12.340 --> 19:17.100]  x теперь у меня ц Bluetooth и расс�вилась на одну вершинку в соответственно для появилось novo
[19:17.100 --> 19:22.340]  ребро между к стоTheyutа вот сей компонент 이 целый появилось одно новое ребро икс в на все остальные
[19:22.340 --> 19:27.060]  учтены у меня появилось только одно икс в но вот я его учитываю я перuned я рассматриваю
[19:27.060 --> 19:31.660]  все возможные вершины соединенные с v и для них обновляю д это PDF с потому что для них появилось
[19:31.660 --> 19:40.700]  снова ребро, я обновляю dx через вес этого ребра. Так, нормально? Вот, хорошо. Ну все, тогда это работает
[19:40.700 --> 19:47.300]  именно что за n квадрат, потому что я n раз выбираю минимум в массиве за n, и еще суммарно у меня есть
[19:47.300 --> 19:53.740]  цикл по всем ребрам. То есть вот этот цикл суммарно пройдет все ребра, ну там по два раза получается,
[19:53.740 --> 20:00.580]  каждый ребро будет учтено два раза, потому что vx и xv. То есть формально это n квадрат плюс m, но я, как
[20:00.580 --> 20:04.900]  обычно, считаю, что m не больше чем n квадрат, кратных ребр нету, поэтому точка будет просто
[20:04.900 --> 20:16.620]  квадратична. Так, хорошо. Смотрите, потому что у меня вот этот кусочек кода еще тоже появляется,
[20:16.620 --> 20:25.860]  и это я делаю для каждой вершины v. Чтобы поддерживать корректные дешки, мне нужно каждый раз,
[20:25.860 --> 20:30.100]  когда v добавляется сюда, мне нужно пробежаться по всем вот этим вот ребрам и обновить d от x.
[20:30.100 --> 20:37.740]  Это работает за степень вершины v. Вот, и это я делаю для каждой вершины, потому что, ну,
[20:37.740 --> 20:43.580]  у меня же все вершины рано или поздно добавятся в c. Вот, я их по одной добавляю, значит, суммарно
[20:43.580 --> 20:59.340]  вот весь этот цикл работает за от m, потому что каждый ребро просмотрится. Так, ну и дальше,
[20:59.340 --> 21:06.660]  как обычно, также как у нас когда-то уже было, можно это соптимизировать. Можно задуматься на
[21:06.660 --> 21:12.540]  тем, что именно нам нужно от вот этой структурки d, какие операции мы в ней делаем, и понять,
[21:12.540 --> 21:33.060]  что это может делать быстрее, чем за квадрат. Вот, ну, а что именно мы делаем? По факту,
[21:33.060 --> 21:43.540]  мы n раз достаем минимум просто, и m раз делаем декриски. Значит, это куча. Мы хотим n раз делать
[21:43.540 --> 21:50.580]  экстракт мин, потому что мы хотим как раз найти вершину v с минимальным значением d от v, это в
[21:50.580 --> 22:01.220]  точность извлечения минимума. Вот, и m раз мы делаем декриски, потому что d от x может только
[22:01.220 --> 22:05.460]  уменьшаться. Если мы проследим за историей изменения конкретного d от x, оно может только
[22:05.460 --> 22:10.580]  уменьшаться, потому что там берется минимум всегда. Значит, это куча, да, можно просто написать
[22:10.580 --> 22:18.740]  обычную кучу. Вот, и если у нас будет бинарная куча, то мы немедленно получаем m лог n асимптотику,
[22:18.740 --> 22:27.500]  да, это бинарная куча. Вот, а если мы напишем кучу фибоначи, у нас опять получится m плюс n лог n.
[22:27.500 --> 22:39.060]  Вот, такие асимптотики ровно у нас были в декстре. Тоже там квадрат был наивная реализация,
[22:39.060 --> 22:45.820]  и дальше с бинарной кучей m лог n с кучей фибоначи m плюс n лог n. Прям асимптотики ровно такие же
[22:45.820 --> 22:51.500]  как в декстре, ну, потому что как бы синтаксички мы делаем одно и то же. Мы храним какой-то массив
[22:51.500 --> 22:57.740]  чисел, да, вот эти вот д, только здесь d у меня это самое дешевое ребро, а в декстре был, ну, как бы
[22:57.740 --> 23:05.780]  минимальный, минимальный из путей до вершинки, да, то есть сумма длин ребер от единички до v. Вот,
[23:05.780 --> 23:10.620]  ну, и они тоже могут только уменьшаться, и нам нужно n раз вывлекать минимум. Поэтому что в декстре,
[23:10.620 --> 23:28.900]  что в приме, получается те же самые симптотики. Так, вопросы, может? Хорошо. Хорошо, значит,
[23:28.900 --> 23:39.780]  тогда с прием разобрались, идем дальше. Следующий у нас алгоритм Крускала. Алгоритм Крускала.
[23:39.780 --> 23:48.900]  Он работает следующим образом. Во-первых, давайте отсортируем все ребра в порядке возрастания весов.
[23:48.900 --> 23:57.660]  Вот, прямо с самого начала отсортируем все ребра в порядке возрастания веса.
[23:57.660 --> 24:14.220]  Вот, а дальше просто давайте пойдем по ним в этом порядке, будем их рассматривать в этом порядке,
[24:14.220 --> 24:24.460]  и брать те, которые есть смысл брать. А это именно те, которые не образуют циклов. Да, ну, то есть
[24:24.460 --> 24:28.580]  понятно, как бы, если я там добавляю какое-то ребро, и оно образует цикл, то оно бессмысленно,
[24:28.580 --> 24:32.100]  его в миностове точно как бы, ну, его можно выкинуть из миностова, потому что циклы в
[24:32.100 --> 24:38.580]  миностове отсутствуют. Вот, но если оно цикла не образует, да, с уже взятыми, тогда я его беру.
[24:38.580 --> 24:50.340]  В этом порядке рассматриваем ребра. В этом порядке рассматриваем ребра. Берем те,
[24:50.460 --> 24:53.700]  которые не добавляют циклов.
[24:53.700 --> 25:12.340]  Так, примерчику не давайте.
[25:20.340 --> 25:33.740]  Да, нормально. Ну, давайте так вот, пусть числа это веса, ребер, пусть они все различные. Вот,
[25:33.740 --> 25:38.140]  понятно, значит, первый шаг тогда это просто сортировка, ну, понятно, да, сначала вот это,
[25:38.140 --> 25:42.540]  потом вот это, вот это, вот это, вот это, вот это. Вот, теперь давайте их рассматривать в этом порядке,
[25:42.540 --> 25:47.140]  брать или не брать, в зависимости того, дают они цикл или нет. Ну, первое ребро однозначно берем,
[25:47.180 --> 25:50.700]  считаем, что пока что вообще ничего не взято, миностов у нас пустой,
[25:50.700 --> 25:55.040]  мы по одному туда добавляем те ребра, которые не образуют циклов. Пока что весь граф пустой,
[25:55.040 --> 25:59.620]  я вот эту дничку беру, потому что она соединяет две вершины, которые пока что никак не соединены.
[25:59.620 --> 26:05.260]  Дальше, ребро веса два, оно тоже, цикла не образует вместе с уже взятым ребром,
[26:05.260 --> 26:09.660]  оно соединяет две вершинки, как бы, которые пока что еще не соединены, я его тоже добавляю.
[26:09.660 --> 26:15.820]  Вот, а ребро веса три я уже не беру, потому что оно цикл образует, с уже взятыми. Сейчас
[26:15.820 --> 26:22.600]  я его просто скипаю. Дальше, ребро веса 4 я добавляю, потому что цикла не образуется, 5 я
[26:22.600 --> 26:27.780]  добавляю, потому что цикла не образуется, а 6 уже игнорирую, потому что иначе был бы такой цикл
[26:27.780 --> 26:33.700]  дыны 4. Я это ребро тоже скипаю. Ну и все, просто вот в этом порядке прохожу и беру только те,
[26:33.700 --> 26:42.780]  которые циклов не добавляют. Вот, ну хорошо, начну сортировка. Понятно, состровать мы умеем,
[26:42.780 --> 26:48.940]  и вот нам нужно как-то научиться эффективно проверять, не добавляет ли данное конкретное
[26:48.940 --> 26:56.620]  ребро цикла вот в тот граф, который у нас пока что имеется. Вот, для этого нам нужна будет новая
[26:56.620 --> 26:59.820]  структура данных, которая называется «система непересекающих множеств».
[27:12.780 --> 27:24.020]  СНМ сокращённо. Это очень простая структура. Она хранит в себе несколько элементов, которые как-то
[27:24.020 --> 27:27.860]  разбиты на какие-то группы, на какие-то множества, на непересекающие множества. Ну вот пусть там одно
[27:27.860 --> 27:34.380]  множество, другое, третье, четвёртое. Все элементы разбиты на непересекающие множества. И к этим
[27:34.380 --> 27:41.940]  множествам поступают два типа запросов. Во-первых, это unite. Это запрос объединения двух множеств. Давайте
[27:41.940 --> 27:47.900]  не буду пока что писать «у-ве», просто unite двух множеств. Скажу так, слить два множества в одно.
[27:47.900 --> 28:00.780]  Слить два данных множества в одно. Скажем, вот эти два склеить и вместо вот этих двух дезинктных
[28:00.780 --> 28:08.260]  множеств нарисовать одно большое равное их объединению. Это одна из операций. Вторая операция. Давайте
[28:08.380 --> 28:19.180]  пишу как бы ее check. Проверить, лежат ли два данных элемента в одном множестве или нет. То есть в запросе
[28:19.180 --> 28:26.660]  дается две вершины «у-ве» на два элемента каких-то множеств. Надо сказать, они в одном множестве или нет.
[28:26.660 --> 28:52.660]  Проверить, лежат ли два данных элемента в одном множестве. Вот, это именно то, что нам нужно. Вот
[28:53.500 --> 28:59.240]  вот эти множество это текущие компоненты связности в текущем графе. То есть изначально у
[28:59.240 --> 29:03.720]  меня каждая вершинка в отдельной компоненте, каждая сама по себе, такая изолированная
[29:03.720 --> 29:08.640]  вершинка. Дальше я добавляю ребра и тем самым провожу ребра между разными компонентами.
[29:08.640 --> 29:14.220]  Тогда, понятно дело, у меня компоненты связности склеиваются. Если я провожу
[29:14.220 --> 29:18.620]  ребра между разными компонентами, то у меня эти две компоненты обееединяются, как раз unite происходит.
[29:18.620 --> 29:25.940]  И я так делаю, я добавляю вот эти ребра только как раз в случае, если они не образуют цикла,
[29:25.940 --> 29:31.020]  то есть если эти вершинки пришли из разных компонент связанности, потому что будь они в одной
[29:31.020 --> 29:36.540]  компоненте, они и так уже связаны, и если я между ними добавлю ребро, у меня получится цикл внутри
[29:36.540 --> 29:42.260]  этой компоненты, я его не должен брать, я его скипаю. А вот если они в разных, тогда я должен их слить.
[29:42.260 --> 29:49.020]  Значит вот ровно такой синтаксис мне и нужен. Мне нужно, чтобы я умел быстро сливать множество
[29:49.020 --> 29:55.020]  по двум каким-то данным точкам, умел быстро проявлять в одной компоненте точки или не в одной.
[29:55.020 --> 30:05.460]  А если я вот это научусь быстро делать, тогда вот эту штуку я тоже умею делать. Понятно? Хорошо.
[30:12.260 --> 30:36.020]  Так, значит теперь, когда мы свели задачу непосредственно к тому, что написано на второй
[30:36.020 --> 30:41.500]  доске, конкретно какие-то запросы к СНМ, давайте временно вообще абстрагируемся от всего,
[30:41.500 --> 30:46.620]  что было до этого, давайте забудем про то, что здесь были какие-то ребра, что там какой-то граф,
[30:46.620 --> 30:51.140]  какие-то ребра, давайте про это забудем совсем. И я сейчас буду водить новые ребра, новые графы,
[30:51.140 --> 30:56.340]  поэтому вот все, что было до этого, нам будет только мешать, давайте забудем. Вот конкретно вот на
[30:56.340 --> 31:04.540]  этой задаче давайте сфокусируемся. Так вот, я буду каждое из этих множеств представлять в виде
[31:04.540 --> 31:11.460]  корневого дерева. Вот каждое множество, вот все точки, лежащие в одном множестве, я буду
[31:11.460 --> 31:16.420]  представлять вот в таком вот виде. Там будет какой-то корень, какой-то представитель, корень
[31:16.420 --> 31:23.140]  этого множества, и какое-то дерево с корнем, собственно, в этой вершинке. Ну вот что-то такое.
[31:23.140 --> 31:35.100]  Это вот типичная структура, отвечающая одному конкретному множеству. То есть я внутри каждого
[31:35.100 --> 31:41.220]  множества еще сам по своему усмотрению выбираю какое-то вот такое корневое дерево. Хранить его
[31:41.220 --> 31:47.700]  очень просто, нужно просто у каждой вершинки хранить родителя. То есть у каждой вершинки будет
[31:47.700 --> 31:52.140]  указатель на того, кто является родителем в дереве, у него тоже указатель на родителя, у него
[31:52.140 --> 31:57.380]  указатель на родителя. Ну а у корня будет какая-то пометка типа там, я корень, у меня нет родителя.
[31:57.380 --> 32:05.100]  Давайте я это назову как-нибудь простенько, что вот есть вершинка В, у него родитель П от В. Соответственно,
[32:05.100 --> 32:14.140]  П от В равно минус 1 в случае, когда В корень. Значит, П от В равно минус 1, если только если В корень
[32:14.140 --> 32:26.780]  своего дерева. В корень своего дерева. Вот. Ну это просто как бы я вот говорю, что я буду все множества
[32:26.780 --> 32:31.500]  хранить в таком виде. Тогда, смотрите, например, процедуру check сделать очень просто. Чтобы
[32:31.500 --> 32:35.860]  проверить, лежат ли две вершины в одном множестве, можно просто подниматься по вот этим стрелкам,
[32:35.860 --> 32:40.460]  пока я не дойду до корней, потом нужно будет просто проверить корни у меня совпали или нет. Потому
[32:40.460 --> 32:43.820]  что будь они в одном множестве, они придут обязательно в один корень. Если они в разных
[32:43.820 --> 32:48.020]  множествах, то они обязательно придут в разные корни. Процедура check делается очень просто. Я из
[32:48.020 --> 32:54.940]  вершинки поднимаюсь вплоть до корня и затем сравниваю одинаковый корень или нет. Давайте
[32:54.940 --> 33:00.340]  напишем процедурку, которая из вершинки поднимается до корни и возвращает корень. Я это назову int get.
[33:00.340 --> 33:17.500]  От вершинки v работает так. Если мы уже пришли в корень, то можно просто вернуть v. Вот. А иначе
[33:17.500 --> 33:24.780]  нужно подняться в родителя и от него тоже запуститься рекурсирным get. Return get от p от v.
[33:30.340 --> 33:35.260]  Это просто процедура, которая поднимается по p-шкам вплоть до корня и возвращает корень.
[33:35.260 --> 33:43.180]  Ну тогда check тривиален. Я от обеих вершин получаю get и затем сравниваю корни, они одинаковые или нет.
[33:43.180 --> 33:49.380]  Вот теперь давайте с unite разберемся. То есть check мы вроде как проговорили,
[33:49.380 --> 33:54.940]  теперь как делать unite. Ну вот представьте, меня просят слить два дерева, одно другое. Каждый
[33:54.940 --> 34:02.500]  из них представлен в каком-то таком виде. Я их хочу слить. Понятно, что поскольку я пока что никак не
[34:02.500 --> 34:07.300]  специфицировал структуру вот этого дерева, я и собственное обеднение тоже могу делать как угодно.
[34:07.300 --> 34:13.900]  Вот здесь как раз тут важно, что я абстрагируюсь от исходной задачи и я не обязан проводить
[34:13.900 --> 34:18.900]  обязательно ребро между u и v. Вот если мне сказали unite, то есть проведи ребро между u и v. Я же не
[34:18.900 --> 34:24.740]  обязан ровно такое ребро провести. Я обязан просто эти две компоненты слить. Ну давайте тогда возьмем
[34:24.740 --> 34:30.580]  одно дерево, другое дерево и как-нибудь одно к другому удобно для нас приподвесим. Вот давайте
[34:30.580 --> 34:37.380]  я нарисую так. Вот одно дерево, вот другое. Они были заданы какими-то своими представителями вот этим
[34:37.380 --> 34:45.660]  и вот этим. Я поднялся до корня в обоих деревьях. Ну и давайте просто для простоты подвесим одно
[34:45.660 --> 34:51.860]  из них к корню другого. То есть просто вот такое ребро проведем еще. Скажем, что родителем одного
[34:51.860 --> 34:56.820]  дерева является корень другого. Вот и все. То есть я не буду там подвешивать куда-то вот сюда вот
[34:56.820 --> 35:02.580]  вовнутрь. Я просто корню подвешиваю, чтобы не париться и все. Ну как? Чтобы париться, ну неважно.
[35:02.580 --> 35:12.500]  Проще было просто vq подвесить. Ну неважно. Буду корень корню подвешивать. Вот. Ну сделаю это
[35:12.500 --> 35:18.900]  чуть-чуть умно. Я буду подвешивать меньше дерева к большему. Значит у меня понятно оба дерева имеют
[35:18.900 --> 35:23.500]  какой-то размер. Просто по количеству вершин. Давайте я буду всегда из вот этих двух деревьев
[35:23.500 --> 35:28.980]  выбирать то, которое имеет меньшее число вершин и меньшее подвешивать к большему. Тогда у меня будет
[35:28.980 --> 35:34.780]  выполняться вариант, что при как бы при подъеме по ребру вверх, у меня размер текущего по дереву
[35:34.780 --> 35:38.660]  будет хотя бы в два раза каждый раз увеличиваться. Потому что если это число меньше чем это,
[35:38.660 --> 35:44.660]  меньшее равно чем это, то суммарный объем вот этого дерева по отношению ко всему объединению он не
[35:44.660 --> 35:49.700]  больше половинки. Вот. И тогда будет выполнено удобное свойство, что при подъеме в родителя у
[35:49.700 --> 35:54.740]  меня текущий размер по дереву увеличится хотя бы вдвое. Ну и тогда в частности значит, что глубина
[35:54.740 --> 35:59.420]  будет маленькая. Потому что если я каждый раз при подъеме увеличу по дереву вдвое, то значит глубина
[35:59.420 --> 36:06.420]  максимально грифмическая. А значит вот эта штука тоже быстро работает. Вот. Ну давайте напишем наконец
[36:06.420 --> 36:20.820]  Unite. Значит Unite принимает две вершинки. Сначала поднимается в корне обоих деревьев. Пусть У это
[36:20.820 --> 36:34.180]  гетатУ, В это гетатВ. Дальше. Ну я хочу сделать так, чтобы к У подвешивалась В. Поэтому скажем так,
[36:34.180 --> 36:42.900]  если размер первого дерева меньше размера второго, то я их свопну местами. Ну тогда я просто свопну.
[36:42.900 --> 36:50.940]  Вот. Где size это количество вершин в поддереве. Вот. Сколько здесь суммарный вершин и сколько здесь
[36:50.940 --> 36:57.180]  суммарный вершин. Значит я их свопнул так, чтобы У была больше. Ну и все. Дальше просто говорю,
[36:57.180 --> 37:27.020]  что В это сын У. Это делается вот так. Конец. Так. Ну вроде все. Да,
[37:27.020 --> 37:32.940]  значит теперь смотрите, еще раз давайте проговорю, что за счет того, что я каждый раз подвешиваю только
[37:32.940 --> 37:39.300]  меньше к большему, у меня размер по дереву при подъеме до родителя всегда увеличивается хотя бы
[37:39.300 --> 37:47.540]  вдвое. Значит у меня глубина всех деревьев максимум логерифмическая. Глубина всех деревьев
[37:47.540 --> 37:58.380]  всегда не больше, чем двойственный логерифм Н. Так как, ну давайте я вот так вот напишу,
[37:58.380 --> 38:07.460]  для любой вершины размер поддерева с корнем в П от В хотя бы в два раза больше размера под
[38:07.460 --> 38:13.860]  дерева с корнем В. Вот у меня есть какая-то В. Есть и размер ее по дереву, есть родители, соответственно,
[38:13.980 --> 38:19.300]  вот это вот под дерева с корнем в П от В. Размер вот этот хотя бы вдвое больше, чем размер вот этот.
[38:19.300 --> 38:25.060]  Значит глубина логерифмическая, потому что каждый подъем хотя бы вдвое увеличивает текущий
[38:25.060 --> 38:30.340]  размер под деревом. Все. Значит отсюда получается немедленно, что гет работает за логерифм,
[38:30.340 --> 38:36.900]  потому что здесь просто прыжки по перам там пока я не даду до корня. Это работает не больше,
[38:36.900 --> 38:40.740]  чем глубина. Ну и здесь тоже понятно логерифмическое время работы, потому что у меня два гета,
[38:40.860 --> 38:49.300]  а дальше просто одно ребро провожу за вот единицы. Поэтому юнайт тоже работает за логерифм. Ну вот.
[38:49.300 --> 38:58.700]  Ну значит СНМ мы вот в каком-то приближении реализовали. Так, хорошо. Ну давайте скажу,
[38:58.700 --> 39:09.140]  что вот это вот то, что я здесь написал, называется ивристика по рангу. Ивристика по рангу. Вот это
[39:09.140 --> 39:14.020]  значит, что как раз я меньше подливаю к большему. Меньше дерево всегда снизу подсоединяется к
[39:14.020 --> 39:19.060]  большему. Вот. И получается, что если реализовать вот эту вот одну простую ивристику, то у меня все
[39:19.060 --> 39:23.660]  процедуры работают за логерифм. Вот. Есть вторая ивристика, с которой еще лучше время работы
[39:23.660 --> 39:46.660]  получается. Называется ивристика сжатия путей. Так. Вторая называется ивристика сжатия путей.
[39:53.660 --> 40:03.500]  Вот. Это следующая идея. Смотрите, опять же. Я волен вот с этими деревьями располагаться,
[40:03.500 --> 40:08.780]  распоряжаться плюс-минус как мне угодно. Мне главное, чтобы как бы корни сохранялись. То есть,
[40:08.780 --> 40:15.580]  что если две вершины в одном дереве, то у них корни одинаковые. Вот. И более-менее все. Тогда
[40:15.580 --> 40:19.580]  давайте сделаем следующую оптимизацию. Вот. Пусть в какой-то момент времени я вызвал гет от В и,
[40:19.620 --> 40:23.380]  скажем, очень долго шел. Поднимался в родители, поднимался в родителя, поднимался в родителя,
[40:23.380 --> 40:30.100]  поднимался в родителя и так далее. Пока не дошел до корня. Но тогда, смотрите, в принципе,
[40:30.100 --> 40:35.800]  я же могу просто сохранить, что вот эта вот В является, ну как бы, я знаю корня у них у всех. Я
[40:35.800 --> 40:42.660]  у всех вот этих промежуток вершинок понял, кто является корнем. Тогда давайте, чтобы в будущем
[40:42.660 --> 40:48.100]  для всех этих вершин не подниматься по этому пути много раз и как бы переделать то же самое, то же
[40:48.100 --> 40:51.820]  те же самые действия, давайте просто их все переподвесим непосредственно к корню.
[40:51.820 --> 40:55.180]  Понятно, что у меня дерево от этого сохранится, корень не изменится, размер не
[40:55.180 --> 40:59.260]  изменится, но зато я себе на будущее сэкономил какие-то действия. Если мне в
[40:59.260 --> 41:02.740]  будущем нужно будет опять получить гет от Вэй или скажем гет вот от этого чувака,
[41:02.740 --> 41:07.420]  мне не нужно будет весь этот путь заново проходить. Поэтому я просто возьму все эти
[41:07.420 --> 41:10.660]  ребра удалю и заменю вот на такие.
[41:11.340 --> 41:14.340]  Все.
[41:14.980 --> 41:18.820]  Значит, с размерами ничего не поменяется, потому что размеры по деревьям не
[41:18.820 --> 41:22.620]  изменились. Врестика по рангу по-прежнему работает так же, как раньше.
[41:22.620 --> 41:28.020]  Корни как были, так и сохранились. Все, что я сделал по факту, это дерево сделал
[41:28.020 --> 41:31.780]  менее глубоким. То есть я вот такой длинный путь сжал, то есть у меня теперь по
[41:31.780 --> 41:35.020]  факту будет вот такое вот дерево просто. Вот вместо такого пути у меня будет куча
[41:35.020 --> 41:40.940]  кучи сыновей у корня. Но понимаешь, что это хорошо. Тогда мне в будущем при гете
[41:40.940 --> 41:49.180]  нужно будет меньше проходить ребр. Так, ну можно не буду это писать. То есть тут
[41:49.180 --> 41:55.340]  надо вставить примерно следующее. Если я у вершинки В получил корень, то
[41:55.340 --> 42:00.020]  нужно просто П от В поменять на вот этот вот корень. То есть на корень дерева.
[42:00.020 --> 42:03.500]  Вместо старого П от В, вместо старого родителя записать то, что вот здесь
[42:03.580 --> 42:08.260]  из рекурсии вернулось. И эта же рекурсия вот для всех этих ошибок тоже изменит.
[42:08.260 --> 42:19.740]  Ну смотрите, справедливое замечание. Давайте так, надо проговорить, спасибо.
[42:19.740 --> 42:29.740]  Сайз будет корректен для всех корней. То есть да, на самом деле действительно размер вот этих
[42:29.980 --> 42:36.780]  дерев меняется. Но мне нигде не нужны сайзы никого кроме корней. Не нужны сайзы только корней. Потому
[42:36.780 --> 42:42.660]  что вот здесь вот я в юнайте сначала поднимаюсь до корней. И по факту для евристики, по рангу мне
[42:42.660 --> 42:47.980]  нужно только чтобы размеры корней были правильно посчитаны. Ну а размеры корней у меня в такой
[42:47.980 --> 42:54.260]  процедуре не меняются, поэтому такой код тоже будет корректен. Ну да, давайте это пропишем.
[42:54.260 --> 43:06.020]  Это наверно стоит подчеркнуть. То есть вообще говоря, вообще говоря, сайз перестает быть
[43:06.020 --> 43:20.700]  корректен для вершин на этом пути. Корректен для вершин на пути. Но сайз от корней сохраняется.
[43:20.700 --> 43:33.260]  Но сайз от корня всегда корректен. А мне только это и нужно.
[43:33.260 --> 43:53.900]  Вот. Ну хорошо. Да, да. Так, ну и дальше есть картиорема про время работы этого безобразия.
[43:53.900 --> 44:01.660]  Сейчас ее напишу. Значит, определение. Есть такая функция Акермана, которая предается следующим
[44:01.660 --> 44:08.580]  образом. Если m, n это целые нетрицательные числа, то функция Акермана от m, n определяется так.
[44:08.580 --> 44:25.260]  Это n плюс 1, если m равно нулю. А от m минус 1, 1 если m положительно, а n ноль. Вот. И а от
[44:25.260 --> 44:49.700]  m минус 1, а от m n минус 1, если оба положительно. Вот это функция Акермана. Вот. Ну можете на досуге
[44:49.700 --> 44:54.540]  посмотреть значение или просто самостоятельно попробовать по рекурсии, по рекурсентной форме
[44:54.540 --> 45:02.220]  просто понять какие там получаются значения. Но мораль такая, что, например, А4,4 уже супергигантская.
[45:02.220 --> 45:11.900]  То есть это очень-очень-очень быстро растущая функция. Здесь будет 2 в степени, 2 в степени 65536
[45:11.900 --> 45:23.340]  минус 3. Ну это прям вообще какой-то космос просто, а не число. Просто очень много. Вот. Это какая-то
[45:23.340 --> 45:34.980]  быстро растущая функция. И вот оказывается, что если скомбинировать обе юристики, юристику по рангу
[45:34.980 --> 45:42.500]  и сжатие путей, то все будет учетно работать за обратную функцию Акермана. То есть, соответственно,
[45:42.500 --> 45:48.820]  к такой функции я могу определить обратную функцию Акермана. Давайте скажем А от k. Это минимальная
[45:48.820 --> 46:00.100]  такой натуральная n, что АНН хотя бы k. Вот. Тогда теорема, которую я когда-то умел доказывать,
[46:00.100 --> 46:15.500]  но разучился, что учетно все операции работают за обратную Акерману. Так. Ну да. Теорема
[46:15.500 --> 46:38.260]  unite и get при комбинации двух евристик работают за учетную альфа от n.
[46:38.260 --> 46:56.460]  Вот. Ну понятно, если функция А, функция Акермана растет очень быстро, а4,4 уже какое-то просто там
[46:56.460 --> 47:02.820]  огромное число, то обратная к ней, наоборот, очень медленно растет. И в частности альфа от вот этого
[47:02.820 --> 47:08.700]  числа будет 4 всего лишь. Ну, значит, для всех меньших тоже будет еще меньше. Вот. Значит,
[47:08.700 --> 47:13.020]  по факту здесь стоит что-то очень медленно растущее. Ну, то есть, формально А это, вообще говоря,
[47:13.020 --> 47:17.180]  растущая функция. Значит, альфа тоже будет растущая функция. Здесь написано какая-то растущая функция,
[47:17.180 --> 47:22.700]  но очень-очень-очень медленно растущая. И для всех адекватных входов, для всех адекватных n,
[47:22.700 --> 47:28.860]  это штука просто не больше чем 4, грубо говоря. Вот. То есть, ну, вообще говоря, получается,
[47:29.580 --> 47:36.140]  формально это какая-то растущая функция, да, но на самом деле, ну, там есть какая-то константа,
[47:36.140 --> 47:42.020]  конечно, вот в этом о большом зашитое. Но, вообще говоря, альфа всегда не больше чем 4,
[47:42.020 --> 47:53.660]  на всех реальных примерах. Ну вот. Так. Что-то перерыв, кстати, забыл сделать. Давайте
[47:53.740 --> 48:05.740]  сейчас перерыв. Так, давайте дальше. Давайте вернемся к алгоритму Крускала, померим,
[48:05.740 --> 48:14.060]  за сколько он работает, с учетом вот сформулированной теоремы. Значит, напоминаю, да, Крускал, вот он у
[48:14.060 --> 48:18.540]  нас написан, я его тут оставил. Во-первых, мы сортируем все ребра в порядке возрастания веса.
[48:18.540 --> 48:27.300]  Ну, в общем случае это работает за m log m. Сортировка работает за m log m. Вот. А дальше у меня
[48:27.300 --> 48:38.340]  m действий, да, я рассматриваю все m ребер, с каждым делаю какие-то действия. Либо, ну, то есть,
[48:38.340 --> 48:44.700]  я в любом случае запускаю гет от обоих концов ребра. Если геты у них разные, то я их юнайчу. Вот.
[48:44.700 --> 48:49.180]  Ну, в любом случае на каждое ребро у меня приходится максимум там три действия примерно, да, три
[48:49.180 --> 48:56.020]  вызова запроса к СНМ. Вот. Каждый работает за обратного кирмана. Получается, что суммарно весь второй
[48:56.020 --> 49:05.020]  шаг работает за что-то типа m на альфа от n. Потому что с каждым ребром как раз вот на каждый ребро
[49:05.020 --> 49:09.220]  примерно столько времени уходит. Ну и как раз там вот, там была звездочка, то есть это учетное
[49:09.220 --> 49:13.780]  время работы, да, то есть, суммарно, если сделать столько-то запросов, то суммарное время будет вот
[49:13.780 --> 49:19.860]  таким. Как раз звездочка пропадает. Амортизация. Вообще откуда амортизация, кстати, да? Ну,
[49:19.860 --> 49:25.340]  например, если бы у меня было что-то такое, если бы я подвесил вот это сюда, потом вот это сюда,
[49:25.340 --> 49:30.900]  потом вот это сюда и так далее, то есть, если бы я вот такой длинный путь один с другим присоединял,
[49:30.900 --> 49:36.140]  то да, то есть, просто вот это подвесил сюда, это сюда, это сюда и так далее. Вот. Тогда, как бы,
[49:36.140 --> 49:40.700]  в принципе, все это выполнялось за одно действие, но потом, когда я вызываю, скажем, гет вот отсюда,
[49:40.700 --> 49:46.340]  у меня я по всему вот этом пути долго прохожусь. То есть, как обычно, у меня каждая конкретная
[49:46.340 --> 49:51.740]  операция может работать долго, то есть, это работает за, ну, за линейное время от числа предыдущих
[49:51.740 --> 49:57.300]  подвешиваний. Но, с другой стороны, если я все вот эти пути потом сокращу, то мне потом не
[49:57.300 --> 50:01.660]  придется делать заново. И в будущем мне будет проще. То есть, как обычно, если я делаю одну тяжелую,
[50:01.660 --> 50:07.340]  то мне когда-то раньше или позже будет легче. Вот. Ну и как раз амортизация у меня уходит после
[50:07.340 --> 50:13.620]  суммирования, остается здесь m на α от l. Вот. То есть, вообще говоря, крускал работает за сумму вот
[50:13.620 --> 50:20.860]  этих вот величин. Ну и здесь можно еще сказать следующее. То есть, крускал на самом деле особенно
[50:20.860 --> 50:27.100]  полезен, если у вас первый шаг делается как-то просто. То есть, если вдруг волшебным образом у вас
[50:27.100 --> 50:31.380]  изначально и так все ребра даны в порядке возрастания, ну вот, возможно у вас такая чудесная задача,
[50:31.380 --> 50:37.500]  что ребра на входе посорчены. Либо, скажем, все весоребер маленькие целые числа и можно их
[50:37.500 --> 50:42.740]  подсортировать подсчетом. Вместо обычной сортировки за m log m можно запустить сортировку подсчетом за m
[50:42.740 --> 50:49.380]  плюс w, максимальный вес. И это тоже будет работать там сильно быстрее. Будет что-то порядка от m,
[50:49.380 --> 50:53.980]  если сортировка подсчетом, и еще потом m на α. То есть, это примерно линейное время от m,
[50:53.980 --> 51:03.180]  если весоребер маленький. Вот, ну а в общем случае m log m плюс вот это вот. Так, хорошо.
[51:03.180 --> 51:10.700]  Тогда идем дальше. Следующий алгоритм – алгоритм Барувки.
[51:10.700 --> 51:26.580]  Ну еще раз, на каждое ребро, что я делаю с ребром? Я сначала вызываю геты от концов,
[51:26.580 --> 51:35.980]  гет одного, гет от другого. Затем, если они различны, то я юнайчу. Ну то есть еще раз,
[51:35.980 --> 51:41.340]  что я делаю с каждым конкретным ребром? Увы. Я сначала проверяю, не лежат ли они и так уже в одной
[51:41.340 --> 51:48.020]  компоненте. Если не лежат, то я их объединяю. Вот как раз три. Гет, гет, потом юнайт.
[51:48.020 --> 51:58.420]  Вот. Итак, следующий алгоритм – алгоритм Барувки. Тоже решает задачу у меня в 100,
[51:58.420 --> 52:08.500]  но и вот еще с третьей стороны, третьим способом. Это как раз, кажется, хронологически самый первый
[52:08.500 --> 52:14.500]  придуманный алгоритм. Не то что он самый полезный, но есть пара задач, где без него не получается.
[52:14.500 --> 52:24.860]  Поэтому кое-где нужен. Итак, значит, идея следующая. Давайте мы опять у нас будет
[52:24.860 --> 52:30.180]  итеративный алгоритм. Изначально считаем, что минус 100 в пустой. Будем туда как-то по очереди
[52:30.180 --> 52:36.340]  добавлять ребра. На первом шаге давайте для каждой вершины определим самое дешевое исходящее из нее
[52:36.340 --> 53:01.980]  ребро. Для каждой вершины В определим самое дешевое исходящее из нее ребро. Вот. То есть каждая
[53:01.980 --> 53:07.740]  вершина мне дала какое-то ребро. Теперь давайте все вот эти вот выделенные ребра с копом все вместе
[53:07.740 --> 53:14.620]  добавим в минус 100. Вот все вот эти ребра, которые я выделил, то есть, ну, примерно N ребер, на самом
[53:14.620 --> 53:18.540]  деле N пополам, но не важно. Вот все эти ребра, которые я выделил для каждой вершины, я с копом
[53:18.540 --> 53:28.300]  добавляю в минус 100, сжимаю компоненты и запускаю заново первый шаг, пока у меня граф не сожмется
[53:28.300 --> 53:39.020]  до одной вершинки. Значит, все выбранные ребра, все выбранные ребра добавить в минус 100,
[53:39.020 --> 53:48.740]  добавить в минус 100, выделить и сжать компоненты связности.
[53:59.140 --> 54:06.700]  Вот. Ну и запустить заново первый шаг на вот новом сжатом графе. Запустить рекурсивно первый шаг.
[54:06.700 --> 54:33.020]  Ну примерчик, давайте быстренько нарисую. Значит, что-нибудь такое. Значит, вот пусть, пусть такой
[54:33.020 --> 54:38.380]  граф, пусть для вершин выделены следующие ребра. Для этого, для этой вершины выделено это ребро,
[54:38.380 --> 54:43.420]  скажем, для этой вершины выделено вот это ребро, для этой вершины выделено, ну, скажем, вот это вот
[54:43.420 --> 54:47.420]  ребро. То есть, может быть, такое, что ребро выделено, ну, как бы выбрано для обоих концов этого ребра.
[54:47.420 --> 54:54.860]  Дальше, для этого, скажем, выделено вот это, для этого вот это, для этого, скажем, вот это, для этого вот это.
[54:54.860 --> 55:12.540]  Давайте еще что-нибудь нарисую. Вот так. Да, нормально. Вот. Теперь у меня получились какие-то
[55:12.540 --> 55:21.260]  ребра. Да, я сжимаю вот эти вот компоненты связности одна другая. И запускаю, то есть, я сжал
[55:22.100 --> 55:25.620]  компоненты. Теперь у меня вот эта вот все одна большая новая толстая вершинка. Вот это все одна большая новая
[55:25.620 --> 55:30.220]  вершинка. И я теперь оставляю ребра между как бы между вершинами. Вот все, что было вот между этими
[55:30.220 --> 55:36.580]  долями, да, как бы вот эти, вот все ребра, да. Все вот эти ребра, и так далее. Ну, понятно, я из них выбираю
[55:36.580 --> 55:43.180]  самое дешевое. Понятно, потому что если у меня есть несколько ребер между вершинами, то из них,
[55:43.180 --> 55:48.780]  понятно, есть смысл выбрать только самое дешевое. А если есть несколько ребр разных весов, то мне
[55:48.780 --> 55:52.780]  только самое дешёвое интересует. Вот я из них выбираю самое дешёвое, и у меня получается
[55:52.780 --> 55:57.780]  новый граф, у меня новый граф такой, левая вершинка, правая вершинка, между ними одно ребро.
[55:57.780 --> 56:01.780]  И вот на этом графе я рекурсивно запускаю первый шаг.
[56:01.780 --> 56:05.780]  Ну пока, соответственно, у меня всё в одну большую компоненту не склеится.
[56:05.780 --> 56:14.780]  И так делаю много-много раз, пока не получится, ну пока весь граф не свяжется в одну большую вершинку.
[56:14.780 --> 56:19.780]  Так. Ну вот, такой алгоритм.
[56:22.780 --> 56:26.780]  Значит, тут уже доказательства поинтеллектуальнее будут.
[56:29.780 --> 56:35.780]  Первое, что нужно сказать, это следующее.
[56:35.780 --> 56:39.780]  Мне нужно доказать, что вот эти вот ребра, которые я выбираю на каждом шаге,
[56:39.780 --> 56:43.780]  что они как минимум не образуют циклов. То есть вот те ребра, которые я выбираю,
[56:43.780 --> 56:48.780]  они как минимум должны быть ациклические, что не должно появляться циклов.
[56:48.780 --> 56:51.780]  Вот. Это чинится только следующим образом.
[56:51.780 --> 56:57.780]  Значит, чтобы не было циклов, нужно сделать следующее.
[57:00.780 --> 57:05.780]  Нужно чуть-чуть специфицировать, как именно я выбираю самое дешёвое ребро, торчащее из вершинки.
[57:05.780 --> 57:10.780]  А именно нужно сказать так. Если есть несколько ребер одинакового минимального веса,
[57:10.780 --> 57:14.780]  то из них нужно выбрать ребро с минимальным номером.
[57:14.780 --> 57:18.780]  То есть если из вершинки есть несколько ребер одного и того же минимального веса,
[57:18.780 --> 57:23.780]  то мне нужно сказать, какой конкретно я из них выбираю. Давайте выбирать ребро минимального веса.
[57:23.780 --> 57:31.780]  Значит, если из вершины торчит несколько ребер одного и того же минимального веса,
[57:31.780 --> 57:46.500]  несколько ребер минимального веса, выбираем из них ребро
[57:46.500 --> 57:47.500]  с минимальным номером.
[57:47.500 --> 57:52.620]  Ну, то есть, я считаю, что у меня еще все ребра как-то
[57:52.620 --> 57:55.180]  занумерованы, да, первые, вторые, третьи, и так далее,
[57:55.180 --> 57:56.180]  МТ.
[57:56.180 --> 57:57.660]  И вот просто, если веса одинаковые, то я сравню по номеру.
