[00:00.000 --> 00:12.480]  Я напомню, на чем мы остановились. Мы рассмотрели две формальные системы.
[00:12.480 --> 00:19.960]  Исчисление-высказывание и исчисление-предикатов. Обе они имитируют обычное математическое
[00:19.960 --> 00:27.920]  рассуждение. Исчисление-высказывание формализует тавтологии. То есть формула является тавтологией
[00:27.920 --> 00:33.080]  тогда и только тогда, когда она выводима. Исчисление-высказывание аналогично. Исчисление-предикатов
[00:33.080 --> 00:38.160]  формализует общезначимые формулы. Формула общезначима, если ее можно вывести в исчисление
[00:38.160 --> 00:45.440]  предикатов. Я уже про это говорил, по крайней мере в прошлый раз точно. Но сейчас я это хочу
[00:45.440 --> 00:55.760]  подробнее объяснить, что выбор формальной системы, он в общем-то не единственный. В сущности,
[00:55.760 --> 01:01.960]  вот эти классические системы возникли потому, что основная цель была формализовать математику,
[01:01.960 --> 01:07.560]  и люди выделяли самые базовые шаги математического рассуждения. Но с другой стороны,
[01:07.560 --> 01:12.040]  если задача ставится так, что нужно как-то проверить, что формула тавтология или формула
[01:12.040 --> 01:21.920]  общезначимая, такого ограничения нет. Плюс эти шаги, которые фиксируются в этих исчислениях,
[01:21.920 --> 01:28.840]  они удобны с человеческой точки зрения. А если, например, проверку делает компьютер,
[01:28.840 --> 01:34.200]  то можно делать и какие-то другие шаги. Если они достаточно эффективны, то какая, в общем-то,
[01:34.200 --> 01:41.320]  разница? Они могут более сложно определяться. Но разницы большой нет. И из вот этих всех
[01:41.320 --> 01:59.960]  наблюдений возникло понятие системы доказательств. Что это такое? Это алгоритм,
[01:59.960 --> 02:13.840]  который берет пару. Можно считать, что это двоичные строки, тексты или что-нибудь такое.
[02:13.840 --> 02:29.160]  Ф я условно буду называть формула. Формула, утверждение, неважно. А П доказательства. И у
[02:29.160 --> 02:38.600]  нас есть какое-то хорошее множество формул. Я тоже кавычки поставлю. Ну, скажем, тавтологии или
[02:38.600 --> 02:45.080]  общезначимые формулы. Но, в принципе, может быть и что-то другое. И от системы доказательств для
[02:45.080 --> 02:57.960]  этого множества требуется следующее. Алгоритм читает эту пару и выясняет, верно ли, что вот
[02:57.960 --> 03:04.440]  это вот П является доказательством в некотором смысле этой формулы Ф. И должно выполняться такие
[03:04.440 --> 03:14.520]  условия корректности. Алгоритм признает, что это П, это корректное доказательство Ф. Или не признает.
[03:14.520 --> 03:25.560]  И условия корректности должно быть таким. Если формула принадлежит вот этому множеству
[03:25.560 --> 03:32.120]  хороших формул, то существует такое доказательство, что алгоритм признает,
[03:32.120 --> 03:39.120]  что это доказательство формулы. То есть, для каждой хорошей формулы доказательства есть. А если
[03:39.120 --> 03:50.560]  формула плохая, то для любого доказательства алгоритм его отвергнет для этой формулы,
[03:50.560 --> 03:56.480]  то есть посмотрев на что-то, что пытаются ему продать в качестве доказательства,
[03:56.480 --> 04:00.360]  алгоритм говорит нет, для этой формулы это не доказательство. То есть вот такая корректность.
[04:00.360 --> 04:06.920]  Ну видно, что исчисление-высказывание и исчисление предикатов удовлетворяют этим условиям, что у нас
[04:06.920 --> 04:10.680]  в данном случае будет f и p. Ну допустим, для исчисления-высказывания я буду говорить,
[04:10.680 --> 04:19.000]  для исчисления предикатов аналогично. f это запись, двоичная запись бульевой формулы. Что такое p?
[04:19.000 --> 04:26.560]  p это вывод в исчислении-высказывание, то есть последовательность формул,
[04:26.560 --> 04:35.120]  которая содержит нашу и каждая формула обоснована. Что делает алгоритм? Алгоритм делает очень простую
[04:35.120 --> 04:39.840]  вещь. Он смотрит, во-первых проверяет, что это действительно корректный вывод. То есть про каждую
[04:39.840 --> 04:44.760]  формулу ему нужно понять, является ли она аксиомой. Мы обсуждали, что это легко сделать алгоритмически.
[04:44.760 --> 04:49.480]  А если аксиомой не является, ему нужно перебрать все пары предыдущих формул и посмотреть, можно ли
[04:49.480 --> 04:58.080]  эту получить с помощью modus ponensis предыдущим. Но это тоже перебор предыдущего отрезка доказательств,
[04:58.080 --> 05:03.440]  он не очень длинный, поэтому алгоритм эффективный. Эффективный это работает за полиномиальное время
[05:03.440 --> 05:08.960]  от длины входа. Длиной входа в данном случае является вся пара. Доказательство само по себе
[05:08.960 --> 05:17.960]  может быть длинным. Вот это называется система доказательств. И если действительно интересоваться
[05:17.960 --> 05:23.160]  какими-то компьютерными приложениями, то есть компьютерной проверкой тавтологичности, то нет
[05:23.160 --> 05:28.880]  никакой нужды останавливаться именно на нашей формальной системе, это исчисление, высказывание.
[05:28.880 --> 05:35.360]  Можно придумать что-то еще. И таких систем придумано много. Я расскажу об одной самой,
[05:35.360 --> 05:40.600]  по-видимому важной на самом деле, за исключением вот этих вот классических, которые мы сказали,
[05:40.600 --> 05:47.120]  они тоже очень важны. И рассказ опять-таки разобьется на две части. Вначале я объясню,
[05:47.120 --> 05:52.360]  как это работает в случае булевых формул, даже в начале чуть более узком случае, потом булевые
[05:52.360 --> 05:58.800]  формулы, а потом уже объясню, как это применять к логике первого порядка. Так же, как в сущности у
[05:58.800 --> 06:04.040]  нас было, исчисление, высказывание такой небольшой кусочек исчисления предикатов, который работает
[06:04.040 --> 06:11.560]  только с булевыми формулами, и с ним легче разобраться, чем с исчислением предикатов. Я напомню,
[06:11.560 --> 06:15.760]  что полноту исчисления предикатов я доказывать не стал, сославшись на то, что технически это
[06:15.760 --> 06:21.360]  довольно трудно. Это действительно труднее, чем то, что мы проделывали, хотя следует тем же самым
[06:21.360 --> 06:28.720]  идеям. Так вот, окажется, что та система, которую я сейчас введу, она дает возможность доказывать
[06:28.720 --> 06:34.480]  теоремы корректности полноты для логики первого порядка довольно быстро. То есть самая трудная
[06:34.480 --> 06:39.440]  часть сегодня будет относиться к булевым формулам. К логике первого порядка надо будет
[06:39.440 --> 06:44.400]  разные преобразования делать, но по модуле этих преобразований все на самом деле очень несложно.
[06:44.400 --> 06:50.720]  Там есть только одна идея, быть может шокирующая, но она такая в логике всегда, то есть это, как не
[06:50.720 --> 06:58.400]  доказывая, она возникает. Но про это в следующий раз. Итак, давайте рассмотрим систему доказательств
[06:58.400 --> 07:11.280]  основанная на правилах, на правиле резолюции. Что это такое? Это такое правило. Если у нас есть две
[07:11.280 --> 07:24.800]  формулы A или B и не A или C, мы можем вывести B или C. Ну, как вы уже должны были осознать, вот эти
[07:24.800 --> 07:30.960]  правила вывода, они основываются на каких-то семантических следствиях. Мы хотим, чтобы вывод
[07:30.960 --> 07:37.200]  сохранял хорошие свойства формул, и семантическое следствие в данном случае очень простое. Если у
[07:37.200 --> 07:46.720]  меня есть две вот такие булевые формулы, то из них семантически следует B или C. В частности,
[07:46.720 --> 07:52.600]  если это тавтология, это тоже будет тавтология. Если эти формулы истины на каком-то наборе
[07:52.600 --> 07:57.600]  при значении переменных, это тоже будет истина. Почему? Ну, это очень легко увидеть. Смотрите,
[07:57.600 --> 08:09.760]  A и не A, они могут быть одновременно истинны. То есть на любом наборе при любых значениях
[08:09.760 --> 08:17.600]  переменных одна из этих формул ложна. Если ложна, скажем, не A, а вот такая дизюнция истина,
[08:17.600 --> 08:25.600]  значит C истина. Если ложна A, а вся вот такая дизюнция истина, значит B истина. Таким образом,
[08:25.600 --> 08:30.920]  у нас есть два случая, и в каждом из них или B или C истина, ну и значит B или C обязательно истина в
[08:30.920 --> 08:39.840]  обоих случаях. То есть очень простой такой вывод. То есть само по себе правило сомнению не подвергает,
[08:39.840 --> 08:45.520]  но давайте разберемся, как его применять. Оно уже выглядит не похоже на наши обычные рассуждения,
[08:45.520 --> 08:52.400]  и нужно вначале придумать, для чего такое правило удобно использовать. Ну, первое наблюдение
[08:52.400 --> 09:07.640]  состоит в том, что удобно использовать для того, что называется дизюнкты. Это дизюнкции литералов.
[09:15.520 --> 09:21.920]  То есть не произвольные формулы, а дизюнкции литералов, переменных или отрицаний. Ну почему?
[09:21.920 --> 09:28.160]  Потому что тогда мы видим, что у нас сохраняется это свойство. В принципе, резолюции можно применять
[09:28.160 --> 09:32.920]  к более сложным формулам, и даже на самом деле такие системы рассматриваются, но я их касаться
[09:32.920 --> 09:41.040]  не буду. Они более сложные, и нам они не потребуются. Это первое наблюдение. То есть,
[09:41.680 --> 09:49.240]  исходно резолюции хорошо бы применять к наборам дизюнктов. Я чуть позже скажу, каким именно наборам,
[09:49.240 --> 09:55.760]  но это просто наблюдение из самого вида формул, которые входят в правила резолюции, как-то так
[09:55.760 --> 10:04.040]  сразу становится ясным. Второе наблюдение, еще более важное. С помощью правил резолюции удобно
[10:04.040 --> 10:10.480]  не доказывать, а опровергать. Опровергать что? Выполнимость некоторых наборов дизюнктов. Вот давайте
[10:10.480 --> 10:21.360]  я рассмотрю пример. Наверное, здесь поместится. Давайте возьмем дизюнкты A или B, не A или B,
[10:21.360 --> 10:34.960]  A или не B, не A или не B. Я думаю, что всем понятно, что это множество дизюнктов несовместно. Почему?
[10:34.960 --> 10:42.320]  Потому что каждый из этих дизюнктов обращается в ноль ровно в одной точке. Этот ноль-ноль, этот в один
[10:42.320 --> 10:46.920]  ноль и так далее. Но все четыре возможных значения переменных этими четырьмя дизюнктами покрыты.
[10:46.920 --> 10:52.480]  Как бы вы ни присвоили значения A и B, один из этих дизюнктов будет нулем. А теперь смотрите,
[10:52.480 --> 10:58.680]  как можно с помощью правила резолюции это обосновать. Давайте возьмем вот эти два дизюнкта и применим
[10:58.680 --> 11:07.480]  правила резолюции. Ну тут формально написано B или C, но мы знаем, что B или B это то же самое,
[11:07.480 --> 11:13.880]  что B. Давайте применим здесь правила резолюции опять по переменной A. Получим не B, точно таким
[11:13.880 --> 11:20.280]  же рассуждением. Теперь один маленький трюк. Правила резолюции буквально этого не содержит,
[11:20.280 --> 11:29.360]  но никто ж нам не запретит написать вот так. Дизюнкция с ложью. Если мы берем какое-то утверждение и
[11:29.360 --> 11:33.840]  дизюнкция с тождественной ложью, а это то же самое утверждение, потому что если вы ставите в
[11:33.840 --> 11:38.600]  дизюнкцию тождественную ложную утверждение, ничего не меняется. Но теперь форма позволяет применить
[11:38.600 --> 11:47.800]  правила резолюции уже по переменной B. И мы выводим ложь. То есть получается так, у нас есть дизюнкты,
[11:47.800 --> 11:53.800]  мы применяем правила резолюции, выводим новые дизюнкты и заканчиваем тем, что выводим тождеост
[11:53.800 --> 12:01.720]  наложенный дизюнкт. Я его еще буду называть пустым, сейчас объясню почему. И это означает, что исходное
[12:01.720 --> 12:09.320]  множество несовместно, потому что вот посмотрите на это семантическое утверждение. Если есть
[12:09.320 --> 12:16.080]  выполняющий набор для этих дизюнктов, то в силу вот этого семантического следствия он же будет
[12:16.080 --> 12:22.240]  выполняющим набором для этого дизюнкта, для этого и для этого. Ну а для лжи выполняющего набора нет,
[12:22.240 --> 12:28.640]  значит его нет и для исходного множества дизюнктов. Таким образом наша формальная система будет устроена
[12:28.640 --> 12:39.160]  немножко не похоже на то, что было раньше. У нас теперь будет не доказательство, а опровержение. Ну и
[12:39.160 --> 12:45.640]  давайте теперь ее будем строить. Прежде чем ее строить, давайте договоримся вот о чем.
[12:45.640 --> 13:05.640]  Есть такие очевидные наблюдения за дизюнкциями. Если я беру дизюнкцию А или А, это то же самое,
[13:05.800 --> 13:13.440]  а я это уже использовал. Если я беру дизюнкцию А и истины, это истина. Если я беру дизюнкцию А или
[13:13.440 --> 13:23.080]  не А, это тоже всегда истина. Такие очевидные тавтологии. Поэтому, вообще говоря, в дизюнкте не
[13:23.080 --> 13:31.720]  имеет смысла повторять литералы в силу вот этой тавтологии. Если какой-то из литералов обратился
[13:31.720 --> 13:39.160]  в истину, то весь дизюнкт обращается в истину. Если в дизюнкте встретилось два противоположных
[13:39.160 --> 13:45.680]  литерала, переменная и ее отрицание, то это дизюнкт истины. И если мы получили истинный дизюнк,
[13:45.680 --> 13:49.280]  то он нам становится бесполезен, потому что никакому противоречию мы используем,
[13:49.280 --> 13:56.080]  то естественно, истинный дизюнкт не придет. Поэтому дизюнктом теперь я буду называть вот такой
[13:56.200 --> 14:20.080]  стандартный дизюнкт. Это по определению множества литералов без пар. То есть каждый литерал ходит не
[14:20.080 --> 14:25.240]  больше одного раза. Порядок литералов тоже не важен. Дизюнкты же, мы помним, что коммутативно,
[14:25.240 --> 14:31.320]  поэтому в каком порядке записаны дизюнкты не важно. И нету противоположных литералов,
[14:31.320 --> 14:35.920]  потому что тогда дизюнкт дождется истинной, нам это не интересно. То есть вот такие стандартные
[14:35.920 --> 14:53.200]  дизюнкты. И правила теперь, резолюции, я сформулирую чуть жестче. Ну, пока я написал
[14:53.200 --> 15:00.240]  резолюцию по переменной, но я требую, чтобы результат тоже был стандартным дизюнктом.
[15:00.240 --> 15:12.520]  Ну а что скажете вы делать, если у нас написано что-нибудь такого типа. Формально мы можем
[15:12.520 --> 15:22.680]  применить резолюции по x и получим не y или y. Это не стандартный дизюнкт. Вот удобно считать,
[15:22.680 --> 15:28.840]  что в этом случае правило резолюции просто неприменимо. Это же легко определяемый случай,
[15:28.840 --> 15:34.360]  он бесполезен. Неприменимо не в том смысле, что что-то плохое случится, а просто бесполезно.
[15:34.360 --> 15:42.360]  Но мы увидим дождец на истинной дизюнкте, он нам никак не поможет дальше. Поэтому формальную
[15:42.360 --> 16:05.240]  систему, которую я назову исчислением резолюции. Сокращенно буду писать и r. Она устроена так,
[16:06.240 --> 16:22.360]  формулой в ней это стандартные дизюнкты. И есть ровно одно это вот правило резолюции. Важно,
[16:22.360 --> 16:28.320]  чтобы их дизюнкция была стандартной. То есть как в моем примере, смотрите, это конечно и это,
[16:28.320 --> 16:32.680]  и это стандартные дизюнкты, а когда мы применяем резолюцию, у нас получается уже не стандартные.
[16:32.680 --> 16:42.960]  То есть мы просто говорим, что правило неприменимо к таким дизюнктам и всё. Это же нас не сильно волнует.
[16:42.960 --> 16:54.520]  Ну хорошо, как устроено исчисление резолюции? Мы говорим, что из множества гамма это множество
[16:54.520 --> 17:11.480]  дизюнктов. И мы говорим, что из него синтоксически в исчислянии резолюции следует дизюнкт D,
[17:11.480 --> 17:30.280]  если существует резолютивный вывод. Что это такое? А это последовательность дизюнктов.
[17:30.280 --> 17:38.400]  Без ограничения общности можно считать, что последний как раз D. И что должно выполняться?
[17:38.400 --> 17:43.680]  Как обычно, когда мы говорим о выводе, нам нужны какие-то обоснования. Обоснования двух типов.
[17:43.680 --> 17:50.440]  Первое обоснование DIT, то есть это для любого I должно одно из двух выполняться. DIT принадлежит
[17:50.440 --> 17:58.200]  вот этому множеству гамма, не формул дизюнктов, из которых мы выводим. А второе обоснование
[17:58.200 --> 18:07.960]  применимо правилой резолюции, то есть DIT получается с помощью правила резолюции из какого-то
[18:07.960 --> 18:19.400]  DIT DIT, где jk меньше i. Ну и вот видно, как это должно выглядеть. Значит, у нас должно получаться так,
[18:19.400 --> 18:30.640]  что DIT должно иметь вид какой-то переменной x или DIT, какой-то еще хвостик. DIT должно иметь
[18:30.640 --> 18:40.560]  вид не x или какой-то другой хвостик. Тут индексы различают. И наш дизюнк DIT это как раз дизюнция
[18:40.560 --> 18:49.160]  этих вот остатков. В этом случае мы говорим, что дизюнк DIT и получается применением правил
[18:49.160 --> 19:08.160]  резолюции к двум предыдущим. Важным частным случаем является опровержение. Я это буду обозначать
[19:08.160 --> 19:15.860]  вот так. Я вот вел специальное обозначение для лжи. Так удобно. Ну и в этой науке так принято. Что
[19:15.860 --> 19:20.820]  такое опровержение? Опровержение это вывод пустого дизюнка. Я вот здесь сказал, что дизюнк стандартный,
[19:20.820 --> 19:39.420]  а что такое пустой? Это просто-напросто пустое множество литералов. Ну вы скажете, с чего вдруг
[19:39.420 --> 19:47.940]  я его пустое множество литералов отождествляю с тождественной ложью. Ну смотрите, чтобы дизюнция
[19:47.940 --> 19:54.660]  была истинной, нужно чтобы один из ее членов был истинной. То есть правило такое, существует
[19:54.660 --> 19:59.580]  член дизюнции, который истинный. Если мы берем квантор существования по пустому множеству,
[19:59.580 --> 20:03.300]  он всегда ложный. Потому что в пустом множестве вообще элементов нет, поэтому там точно не
[20:03.300 --> 20:12.940]  существует такого элемента. Ну значит ложное. То есть вот такое немножко иезуитское объяснение,
[20:12.940 --> 20:19.380]  но оно формально правильное. Ну и содержательно вот на этом же примере видно было, что нам так и надо
[20:19.380 --> 20:34.260]  рассуждать. Хорошо, значит опровержение это вывод пустого дизюнкта. Просто по определению. А
[20:34.260 --> 20:45.740]  опровержение чего? Давайте подумаем. Ну вот тут я пример сейчас как раз стираю, и из него в общем-то
[20:46.340 --> 20:55.680]  опровержение чего? Мы высказываем утверждение, что множество вот этих дизюнктов совместно, и если
[20:55.680 --> 21:00.640]  нам удалось увести пустой дизюнкт, то этот вывод опровергает это утверждение. То есть это
[21:00.640 --> 21:05.600]  утверждение заведомо ложным. Потому что мы доказываем, что оно не совместно. То есть это
[21:05.600 --> 21:12.660]  доказательство не совместности множество дизюнктов или опровержение утверждения совместности.
[21:12.660 --> 21:18.420]  совместности. Принято называть опровержением, чтобы подчеркнуть разницу между этими типами
[21:18.420 --> 21:41.700]  формальных систем. Ну и основная теорема. Звучит очень просто. Я ее сейчас формально запишу,
[21:42.340 --> 21:48.540]  перескажу словами, что это означает. Смотрите, что означает, что из множество Disjunct Mutta
[21:48.540 --> 21:54.260]  семантически следует пустое? Это означает, что множество несовместно. Пустой Disjunct ложен на
[21:54.260 --> 21:58.980]  любом наборе значений перименных. Если бы существовал выполняющий набор для гамма,
[21:58.980 --> 22:04.960]  то тогда бы мы точно могли сказать, что пустой Disjunct не следует из этого множества. А если
[22:04.960 --> 22:08.520]  следует, значит, что на любом наборе значений переменных
[22:08.520 --> 22:14.160]  хотя бы один дизъюнкт из гамма ложен. А это вот наш
[22:14.160 --> 22:17.520]  вывод опровержения. То есть опровержение существует
[22:17.520 --> 22:23.840]  тогда и только тогда, когда множество дизъюнктов несовместно.
[22:23.840 --> 22:27.880]  Ну и как обычно, эта равносильность разбивается на два утверждения.
[22:28.080 --> 22:39.320]  Корректность. Если мы что-то вывели, если мы вывели не что-то, а пустой дизъюнкт,
[22:39.320 --> 22:49.480]  то тогда это множество несовместно. Ну, можно рассуждать по-всякому.
[22:49.480 --> 22:58.960]  Проще всего написать контрапозицию. Значит, контрапозиция будет выглядеть как?
[22:58.960 --> 23:14.680]  Если гамма совместна, то тогда из такого гамма нельзя вывести пустой дизъюнкт резолюциями.
[23:14.680 --> 23:20.680]  То есть, если семантически не следует пустой дизъюнкт, то и нельзя вывести.
[23:20.680 --> 23:30.840]  Доказательство в эту сторону получается проще. Давайте подумаем, как это доказательство записать.
[23:30.840 --> 23:40.600]  Ну, как обычно, индукция, вот у нас есть определение резолютивного вывода,
[23:40.680 --> 23:46.280]  нам нужно делать индукцию по набору значений переменных. Я не случайно переформулировал это вот так,
[23:46.280 --> 23:52.720]  потому что нам это альфа понадобится. Я хочу по индукции доказать, что если у нас есть вот это вот,
[23:52.720 --> 24:02.760]  это резолютивный вывод из гамма, то на наборе значений переменных альфа, значит гамма от альфы,
[24:02.760 --> 24:08.320]  я считаю, все дизъюнкты истины, то тогда и все дизъюнкты, которые мы выводим, тоже истины.
[24:08.320 --> 24:13.240]  И этого достаточно, чтобы утверждать, что мы не можем вывести пустой дизъюнкт,
[24:13.240 --> 24:19.360]  потому что пустой дизъюнкт должен быть ложным. Ну, а доказательство индукции по длине вывода.
[24:19.360 --> 24:26.000]  База индукции понятна какая. Первый дизъюнкт в нашем выводе, безусловно, должен принадлежать
[24:26.000 --> 24:31.280]  множеству гамма, потому что правила резолюции применима только если есть хотя бы две формулы
[24:31.280 --> 24:41.040]  перед этим. Значит, по условию такой дизъюнкт истинный. Ну, то же самое, если мы берем какой-то
[24:41.040 --> 24:47.800]  шах, теперь шах индукции, без ограничения общности, вот это самое t. Допустим, для всех выводов,
[24:47.800 --> 24:59.360]  короче, t мы это уже умеем доказывать. Значит, все вот эти вот предыдущие дизъюнкты, все истины,
[24:59.360 --> 25:08.040]  по предположению индукции. И нам нужно доказать истинность последнего дизъюнкта. Ну, если он
[25:08.040 --> 25:12.640]  принадлежит гамма, то опять-таки проблем нет. Осталось понять, что будет, если мы применяем
[25:12.640 --> 25:21.720]  правила резолюции. Ну, давайте смотреть. Вот мы применяем правила резолюции, эти два дизъюнкта
[25:21.720 --> 25:28.000]  истины на альфа по предположению индукции. И тогда мы знаем, мы же проверили семантическое вот это
[25:28.160 --> 25:37.960]  следствие. Тогда мы знаем, что то, что мы получаем по правилу резолюции, тоже истинно. Если это истинно,
[25:37.960 --> 25:46.800]  то и это истинно. Ну, вот, в общем-то, и все. На этом доказательство закончено. То есть, ну,
[25:46.800 --> 25:53.440]  тут еще раз видна вот эта идея, что обычно доказательство корректности проще. Не всегда,
[25:53.440 --> 25:59.280]  я знаю примеры формальных систем, мне о них рассказывали, где удивительным образом полнота
[25:59.280 --> 26:04.480]  доказывается легко, а корректность это трудная задача, которую люди долго решали. Так тоже
[26:04.480 --> 26:11.120]  бывает. Но это редкость, это скорее экзотика. Обычно у нас мы придумываем формальную систему и
[26:11.120 --> 26:14.760]  стараемся придумать, ну, вспомните, как я вводил резолюцию, я тут же сразу проверил,
[26:14.760 --> 26:20.080]  что семантические следствия выполняются. Ну, именно для того, чтобы не иметь проблем с этим
[26:20.080 --> 26:26.600]  правилом, что если эти формулы истинны, то и это истинно. Мне с самого начала этого хотелось,
[26:26.600 --> 26:34.160]  я с самого начала проверил, что это так. Но полнота с полнотой, как обычно, сложнее.
[26:51.080 --> 26:59.680]  Но не так, чтобы уж совсем сложно. Значит, для полноты мне нужно доказать в обратную сторону. Давайте
[26:59.680 --> 27:05.480]  где-нибудь здесь предварительные логические преобразования напишу. Значит, полнота означает,
[27:05.480 --> 27:29.040]  что если у нас множество несовместно, то оно выводится в исчислении резолюции. Ну, из него,
[27:29.040 --> 27:33.000]  оно проявляется в исчислении резолюции, извините, а проявляется, можно вывести пустой дезюмп.
[27:33.000 --> 27:43.920]  Ну и опять-таки удобно использовать контрапозицию и доказывать, что если не выводится пустой
[27:43.920 --> 27:56.880]  дезюмп, то тогда гамма совместно. Существует набор значений переменных, которые выполняют все
[27:56.880 --> 28:03.920]  дезюмпы. Но это привычное нам рассуждение, когда мы доказывали полноту для исчисления
[28:03.920 --> 28:09.240]  высказываний, было то же самое. Мы предполагали, что нельзя вывести противоречие, тогда можно
[28:09.240 --> 28:15.400]  построить выполняющий набор. Здесь похожая ситуация, здесь противоречием будет пустой дезюмп,
[28:15.400 --> 28:24.080]  играть роль противоречия. И вот если его вывести нельзя, говорим мы, ну тогда должен существовать
[28:24.080 --> 28:31.080]  выполняющий набор. Вот это надо проверить. Это посложнее, потому что теперь мы уже возможности
[28:31.080 --> 28:39.120]  засунуть в определение, нужное нам утверждение потеряли, у нас уже все определения зафиксированы и
[28:39.120 --> 28:52.080]  нужно какое-то рассуждение. Но давайте подумаем, как рассуждать в этом случае. Первая идея состоит
[28:52.080 --> 28:59.160]  вот в чем. Идея пополнения. Я напомню, что когда мы обсуждали исчисление высказываний, то мы тоже,
[28:59.160 --> 29:05.760]  когда доказывали, что непротиворечиваяся равносили на совместности, мы брали непротиворечивое
[29:05.760 --> 29:10.200]  множество формул и пополняли его, потому что с пополненным проще рассуждать. Здесь то же самое.
[29:10.200 --> 29:30.920]  Давайте возьмем множество форм, дизъюнкта в данном случае, таких, что они выводятся из гамма. По
[29:30.920 --> 29:41.480]  нашему условию пустой дизъюнкт этого множества не принадлежит. То есть просто включаем в это множество
[29:41.480 --> 29:47.600]  все-все дизъюнкты, которые мы можем вывести. Вот тут самое время сказать, мне дальше это будет важно,
[29:47.600 --> 29:55.120]  что множество гамма, я про это нигде до сих пор не говорил, но вы можете проверить. Множество гамма
[29:55.120 --> 30:01.720]  не обязано быть конечным, оно может быть бесконечным. Рассуждения никакие пока не испортились,
[30:01.720 --> 30:12.440]  ну потому что тут, когда мы доказывали корректность, ну что там, ну все истины, ну да, все истины. Ничего не
[30:12.440 --> 30:20.400]  портится от того, что этих всех бесконечно много. Сейчас мне важно, что хотя множество может быть
[30:20.400 --> 30:33.100]  бесконечным, множество переменных счетно. Я его могу пронумеровать. Если не счетно, вот буквально
[30:33.100 --> 30:37.120]  такое рассуждение, как я привожу, не годится, там его нужно модифицировать, это возможно, но
[30:37.120 --> 30:43.760]  давайте не будем заморачиваться. Счетного множества переменных уже довольно многом, нам его хватало
[30:43.760 --> 30:52.680]  все время, непонятно почему, ну на самом деле понятно, но у нас до этого дело не дойдет. До
[30:52.680 --> 31:04.200]  не счетных множеств переменных мы не доберемся, нам хватит счетных. И теперь я хочу сделать такую
[31:04.200 --> 31:21.040]  вещь. Я хочу вот это множество гамма штрих разбить в объединение непересекающихся, разбить это
[31:21.040 --> 31:26.440]  означает представить множество в виде объединения непересекающихся множества. Из чего состоят эти
[31:26.440 --> 31:41.440]  множества? Это множество таких дезъемков, которые принадлежат нашему гамма штрих и содержат литерал
[31:41.440 --> 31:55.520]  для хк, то есть либо хк, либо или, словами надо писать, иначе возникнет проблема, то есть содержит
[31:55.520 --> 32:06.720]  или хк, или отрицание хк и не содержит хк при и больше к. То есть вот такое вот множество. Ну
[32:06.720 --> 32:11.800]  то есть берем дезъюнкт, смотрим какая переменная, какой самый большой номер переменной в этом
[32:11.800 --> 32:18.880]  дезюнкте. Вот это и есть то хк, которому принадлежит это множество. То есть каждый дезюнкт попадает ровно
[32:18.880 --> 32:24.560]  в одно из таких множеств. Вообще не обязательно из гамма штриха, просто любой дезюнкт. Ну потому
[32:24.560 --> 32:31.800]  что дезюнкт содержит конечное число литералов, все мы их считаем, что у нас переменные перенумерованы,
[32:31.800 --> 32:43.560]  поэтому мы смотрим, просто находим максимальный индекс и вот его и записываем. Что? Да, может
[32:43.560 --> 32:54.400]  содержаться, а, не содержит литерала, нет. Спасибо. Нет, нет, не содержит литерал. Значит, спасибо за
[32:54.400 --> 32:59.080]  объяснение. На словах я сказал удачнее, просто каждым дезюнкту можно поставить максимальный
[32:59.080 --> 33:05.400]  номер переменной, который в него входит. Вот это и есть то самое. Не хотелось просто эту функцию
[33:05.400 --> 33:16.840]  как-то еще определять. И мы будем, план такой, мы будем доказывать по шагам индукции пока, будем
[33:16.840 --> 33:32.200]  доказывать, что все дезюнкты из гамма-катова истины. Но истины где? Заметьте, что я пока не назвал
[33:32.200 --> 33:44.480]  выполняющий набор. Это нехорошо. Давайте я его назову. Так, только у меня вот как-то все слегка
[33:44.480 --> 33:50.520]  сбилось. Как вы думаете, можно стереть определение резолютивного вывода? Мне кажется да, потому что,
[33:50.520 --> 33:55.360]  ну, я его постоянно буду повторять, то есть резолютивный вывод применение правил резолюции. В общем,
[33:55.360 --> 34:04.600]  тут доска занята, но ничего очень умного тут не написано. Я не хочу далеко от этой части доски
[34:04.600 --> 34:11.240]  отходить. Про системы доказательств можно было бы и стереть, они у нас появятся, но уже конкретные.
[34:11.240 --> 34:21.320]  Хорошо, значит, как мы будем строить набор альфа? Значит, альфа строится опять-таки по индукции.
[34:21.320 --> 34:50.040]  Альфа-ката равняется нулю, если все из того, что D принадлежит гамма-катому,
[34:50.040 --> 35:18.080]  следует, что D на наборе значений предыдущих и нулю равен единице. Ну, то есть, как это объяснить
[35:18.080 --> 35:24.440]  словами? Мы хотим подобрать выполняющий набор. Вот мы предполагаем, что мы уже преуспели на
[35:24.440 --> 35:30.360]  предыдущих шагах. Нам нужно выбрать значение катой переменной. Ну и мы смотрим на дизъюнты,
[35:30.360 --> 35:36.840]  которые содержат кату и переменную как самую старшую. У нас есть желание поставить ноль.
[35:36.840 --> 35:42.960]  Если получилось, мы ставим ноль, и заметьте, что тогда мы добились своей цели, потому что если
[35:42.960 --> 35:48.560]  для гамма-катого равно единице, тут сейчас нужно представлять, что я потом буду все доказывать по
[35:48.560 --> 35:55.400]  индукции. Я предполагаю, что предыдущие альфа-иты гарантируют нам истинность всех дизъюнтов с
[35:55.400 --> 36:04.160]  меньшими номерами. Ну и тогда и все, и делать вроде бы ничего не нужно. Но может же, конечно,
[36:04.160 --> 36:15.240]  быть так, что какой-то из дизъюнтов, тем не менее, обращается на таком наборе в ноль.
[36:15.240 --> 36:26.120]  Тогда говорим мы нет, ну ноль мы присвоить не можем, у нас не все гамма-каты будут истинны. Ладно,
[36:26.120 --> 36:31.720]  говорим, мы присвоим тогда единицу. То есть мы присваиваем ноль, если сохраняется вот этот
[36:31.720 --> 36:38.680]  наш вариант, за который мы следим. Все дизъюнты истины. Если он нарушается, мы присваиваем единицу.
[36:38.680 --> 36:48.840]  И все, что я хочу доказать по индукции, что все гамма-иты истины. Заметьте, что у меня тут в этом
[36:48.840 --> 36:54.000]  определении нет базы, но на самом деле вот это вот применимо, и когда предыдущих значений
[36:54.000 --> 36:59.320]  переменных нет. Как присвоить значение альфа-1? Если у нас есть дизъюнт, сейчас мне база все равно
[36:59.320 --> 37:04.280]  понадобится, давайте посмотрим из чего может состоять гамма-1. Заметьте, что поскольку не
[37:04.280 --> 37:10.720]  выводится пустой дизъюнт, хотя бы одна переменная есть в каждом нашем дизъюнте. Вот это то место,
[37:10.720 --> 37:16.280]  где используется то, что не выводится пустой дизъюнт, больше оно нигде не используется. Как может
[37:16.280 --> 37:31.360]  быть устроена гамма-1? Ну это или переменная х1, или ее отрицание. Смотрите, какие-то переменные
[37:31.360 --> 37:36.320]  должны быть, переменная х1 обязательно должна быть. У нас нет другого стандартного дизъюнта,
[37:36.320 --> 37:40.880]  то есть переменные с большими номерами входить не могут, то есть этот дизъюнт может содержать
[37:40.880 --> 37:46.120]  только х1. Ну вот что за стандартный дизъюнт, который содержит х1? Ну либо переменная, либо отрицание.
[37:46.120 --> 37:56.000]  Теперь давайте посмотрим, как мы присваиваем значение альфа-1. В этом случае, если я подставлю
[37:56.000 --> 38:01.040]  вместо х1 ноль, что у меня получится? У меня получится, что есть дизъюнт, который вращается
[38:01.040 --> 38:12.640]  в ноль. Значит альфа-1 должен равняться единице. А в этом случае такого дизъюнта нет. Тут самое
[38:12.640 --> 38:22.640]  время спросить, а почему я не рассматриваю случаи, когда гамма-1 содержит оба таких дизъюнта? Это
[38:22.640 --> 38:28.240]  бы создало для меня большие трудности, потому что ни одно из двух правил применить было бы нельзя.
[38:28.240 --> 38:40.640]  Что? Нет, а это смотрите, вот гамма это множество стандартных дизъюнтов. Существенно, что вот это
[38:40.640 --> 38:46.960]  стандартный, вот это стандартный. Нет, тут надо другое использовать. Смотрите, свойства полноты
[38:46.960 --> 38:52.840]  нашего множества. Мы добавили все, что можно вывести из исходного множества гамма. Но если мы
[38:52.840 --> 38:59.840]  можем вывести х1 и вывести не х1, мы можем вывести пустой дизъюнт, применив правила резолюции.
[38:59.840 --> 39:22.640]  Поэтому вот такой случай он невозможен. Ну смотрите, вот применение правила резолюции,
[39:22.640 --> 39:27.760]  вот один стандартный дизъюнт, вот другой, вот третий. Это пустое множество дизъюнтов.
[39:27.760 --> 39:36.960]  Но мы взяли одно множество, куда входит х и еще что-то. Другое множество, куда входит не х и
[39:36.960 --> 39:44.360]  еще что-то. В данном случае это что-то пустое множество. И взяли объединение этих чего-то. Но
[39:44.360 --> 40:03.960]  объединение двух пустых множеств это пустое множество. Я не дизъюнт записываю, это я записываю множество
[40:03.960 --> 40:10.920]  дизъюнтов. Если у нас есть х1 и есть не х1, то из этих двух дизъюнтов мы можем вывести пустой.
[40:10.920 --> 40:19.360]  Так, ну прозвенел звонок на перерыв. Давайте сейчас прервемся. В общем-то место достаточно
[40:19.360 --> 40:23.760]  удачно. Я надеюсь, что с базой стало понятно. Вот этот вот тонкий момент, на который нужно
[40:23.760 --> 40:29.960]  обратить внимание, что оба дизъюнта в гамма-1 входить не могут, потому что иначе бы выводилось пустое.
[40:29.960 --> 40:47.000]  Ничего. Брать формулы дизъюнта из гамма и применять резолюции.
[40:47.000 --> 41:00.400]  Чтобы проверять тавтологичность формулы, я буду брать отрицание и проверять,
[41:00.400 --> 41:05.480]  что отрицание невыполнимо. Но теперь мне нужно как-то по формуле,
[41:05.480 --> 41:26.880]  это вот булева формула, построить КНФ так, чтобы А выполнимо было равносильно тому,
[41:26.880 --> 41:35.200]  что это КНФ выполнимо. У вас в курсе алгоритмов уже должны были возникнуть свадимости,
[41:35.200 --> 41:42.640]  правильно я понимаю? Не? Не было еще свадимости? Ну должны быть. Хорошо,
[41:42.640 --> 41:47.240]  значит я тогда буду первый, кто вам про эту идею скажет. В общем, это и называется свадимость,
[41:47.240 --> 41:52.280]  одной задачей к другой. Мы хотим проверять выполнимость булевых формул, а вместо этого
[41:52.280 --> 41:57.920]  будем проверять выполнимость КНФ, и нам нужно какое-то преобразование. Для текущего курса
[41:57.920 --> 42:02.920]  алгоритмов, для моего курса логики, на самом деле не очень важно, насколько сложное это преобразование,
[42:02.920 --> 42:09.760]  лишь бы оно реализовывалось алгоритмом. Но вот эта вот идея системы недоказательства, она возникла в
[42:09.760 --> 42:15.640]  рамках теоретической информатики, где интересуется все-таки эффективностью процедур. Поэтому мы хотим,
[42:15.640 --> 42:21.880]  чтобы эта свадимость была полинамеральной, чтобы по формуле за полинамеральное время мы
[42:21.880 --> 42:30.040]  строили соответствующую КНФ. Почему это существенно? Потому что один простой способ построить КНФ по
[42:30.040 --> 42:49.760]  формуле. Вы должны знать, вас должны были учить на первом курсе того, что называется, ну вот собственно
[42:49.760 --> 42:55.200]  КНФ и ДНФ, словам вот этим. И один из основных фактов, что любая булева функция представляется в
[42:55.200 --> 42:59.920]  виде ДНФ, но и представляется в виде КНФ. Вот то, что я написал, это представление в виде КНФ. Мы
[42:59.920 --> 43:07.600]  должны взять конъюнцию по нулям функции, таких вот дисъюнктов, куда входят все переменные, либо
[43:07.600 --> 43:14.120]  позитивно, либо негативно, в зависимости от того, какое значение принимает соответствующая переменная.
[43:14.120 --> 43:22.440]  И все было бы хорошо, то есть мы просто вот по любой формуле можем написать такое представление,
[43:22.440 --> 43:27.680]  но есть проблема. Проблема состоит в том, что вот эта КНФ, она называется совершенная КНФ,
[43:27.680 --> 43:33.280]  она очень длинная может быть, потому что конъюнция берется по всем нулям. Вот представьте, что у вас
[43:33.280 --> 43:40.080]  переменных много и нулей много, точек, в которых значение формулы ноль. Тогда у вас там будет,
[43:40.080 --> 43:44.920]  ну вообще говоря, экспоненциально много членов, всего значений 2 в степени N, если на число
[43:44.920 --> 43:50.760]  переменных возможных значений. И вот у вас там даже до двух степени N может дойти вот эта
[43:50.760 --> 43:57.600]  совершенная КНФ. Поэтому буквально вот такое вот преобразование нас не устраивает. Нам нужно
[43:57.600 --> 44:02.000]  что-то более хитрое, и это хитрое существует. Вот эта свадимость, которую я вам сейчас рассказываю,
[44:02.000 --> 44:08.200]  она в следующем семестре все равно понадобится, потому что через нее в общем-то все равно все
[44:08.200 --> 44:15.160]  проходит. То есть там, когда вы будете изучать то, что называется НП полнота, там почти всегда в
[44:15.160 --> 44:20.280]  начале возникают произвольные булевые функции, потом из них надо сделать КНФ, а из КНФ уже
[44:20.280 --> 44:26.360]  можно там все что угодно делать. Там получается такая сложная ветвящаяся иерархия, в общем,
[44:26.360 --> 44:30.520]  я про это говорить не буду, но вот эта свадимость в том или ином виде вам понадобится. Может быть
[44:30.520 --> 44:36.840]  вам в следующем семестре расскажут ее немножко иначе. Как ее собираюсь рассказывать я? Я собираюсь
[44:36.840 --> 44:52.120]  поступить просто. Я хочу посмотреть на дерево формулы. Напоминаю еще раз, что я все время предполагаю,
[44:52.120 --> 44:58.680]  мы это несколько раз обсуждали, не сказать что в каких-то деталях реализации, но мы обсуждали,
[44:58.680 --> 45:03.640]  что существует эффективный алгоритм, который строит дерево разбора формулы. И вот я теперь
[45:03.800 --> 45:18.120]  хочу для каждой подформулы, я хочу записать, вести дополнительную переменную. Значит у меня будут
[45:18.120 --> 45:32.200]  переменные, дополнительные ZB, B подформула. То есть вот эта вот КНФ, она не будет равносильно
[45:32.200 --> 45:38.600]  А, у нее даже будет другое множество переменных, но выполнимость будет равносильна. То есть мы
[45:38.600 --> 45:45.280]  ослабляем условия, вот тут просто получается КНФ, которая равносильно исходной формуле, а тут у нас
[45:45.280 --> 45:51.880]  равносильности не получится, но получится зато КНФ, выполнимость которой равносильно выполнимости
[45:51.880 --> 46:00.160]  исходной. И как я эту КНФ буду строить? Я для каждого узла дерева разбора формулы запишу такие
[46:03.080 --> 46:13.520]  КНФ. Допустим у меня B это отрицание C, тогда я запишу, оказывается плохое место на доске,
[46:13.520 --> 46:34.520]  если B это скажем дезъемцы, я должен написать ZB равносильно ZC или ZD, ну и так далее. Значит
[46:34.520 --> 46:46.680]  если B это, давайте вот я импликацию напишу, как самую важную для нас случай. То есть смотрите,
[46:46.680 --> 46:55.400]  почему я говорю КНФ? Выписывая какие-то формулы, которые КНФ не являются. Но что мы про эти формулы
[46:55.400 --> 46:59.920]  видим? Мы видим, что в них ходят всего три переменные. Это такие условия согласования.
[47:00.480 --> 47:07.760]  Вспомогательная переменная ZB должна быть равна, а ведь когда эквивалентность, этот вот вixo,
[47:07.760 --> 47:14.760]  это значок эквивалентности, когда эквивалентность истины, когда обе части одинаковы, равны. Поэтому
[47:14.760 --> 47:21.220]  значение форму вспомогательной переменный ZB, должно быть отрицанием значения вспомогательной
[47:21.220 --> 47:29.640]  переменной З c, чтобы вот такое выражение было истинным. Это вспомогательные переменные
[47:29.640 --> 47:33.760]  присвоенные узлам дерева разбора, под формулой, то
[47:33.760 --> 47:37.080]  есть у нас вот здесь переменные, давайте я как-нибудь сразу
[47:37.080 --> 47:40.220]  напишу, тут у нас будут переменные x, а тут у нас
[47:40.220 --> 47:46.760]  будут переменные x и z, то есть я добавлю переменные,
[47:46.760 --> 47:51.120]  за счет этого мне станет легче строить KNF, она будет
[47:51.120 --> 47:52.120]  короче.
[47:52.120 --> 47:55.160]  И смотрите, все KNF, которые я здесь выписал, я не выписал
[47:55.160 --> 47:58.480]  только для конъюнкции, ну точно так же как для дезюнкции,
[47:58.480 --> 48:02.040]  в них ходят либо две переменных, либо три переменного.
[48:02.040 --> 48:06.640]  Поэтому если я буду выписывать совершенную KNF для этих формул,
[48:06.640 --> 48:11.640]  в ней будет не больше 8 членов, а на самом деле даже не 8,
[48:11.640 --> 48:16.440]  они больше 4, потому что сколько нулей у таких формул
[48:16.440 --> 48:17.440]  очень легко посчитать.
[48:17.440 --> 48:23.080]  Ну пусть даже 8, это нам не важно, у нас есть какая-то
[48:23.080 --> 48:29.700]  формула, и мы выписали для каждого узла дерево
[48:29.700 --> 48:34.240]  разбора, мы выписали KNF длины там не больше 8, ну значит
[48:34.240 --> 48:38.480]  у нас получилась KNF, длина которой тоже не более чем
[48:38.480 --> 48:41.080]  8 раз больше, чем длина исходной формулы.
[48:41.080 --> 48:44.680]  Но это еще не все, нам еще нужно добавить, вот ко
[48:44.680 --> 48:50.120]  всем этим KNF нам еще нужно добавить вот такой вот дезюнк
[48:50.120 --> 48:58.520]  ZA, вот это вот и будет KNF, которую я хочу построить.
[49:14.680 --> 49:19.080]  Ну и теперь осталось только доказать, что построение
[49:19.080 --> 49:22.040]  эффективное, я думаю, вопросов особо не вызывает, потому
[49:22.040 --> 49:25.440]  что в сущности все что нужно построить дерево разбора
[49:25.440 --> 49:28.960]  и по дереву разбора выписать вот эти вот KNF, но это очень
[49:28.960 --> 49:31.680]  легко, то есть для каждого из случаев мы можем заранее
[49:31.680 --> 49:34.160]  просто написать соответствующий KNF, просто подставлять там
[49:34.160 --> 49:39.440]  нужные переменные, это ясно, что это не сложно.
[49:39.440 --> 49:45.320]  Давайте предположим, что у нас исходная формула
[49:45.320 --> 49:49.080]  на каком-то наборе значений переменных истина, то есть
[49:49.080 --> 49:50.080]  она выполнима.
[49:50.080 --> 49:54.520]  Я утверждаю тогда, что вот это KNF, истина на таком
[49:54.520 --> 50:02.960]  наборе значений переменных, альфа, бета, где бета для
[50:02.960 --> 50:09.760]  подформулы B, это просто-напросто значение подформулы B на
[50:09.760 --> 50:10.760]  наборе альфа.
[50:10.760 --> 50:16.340]  Давайте я это скажу неформально, потому что формально тут
[50:16.340 --> 50:19.000]  получается какое-то переливание из пустого порожня, ее трудно
[50:19.000 --> 50:20.000]  понять.
[50:20.000 --> 50:22.720]  Значит, я предполагаю, что сама формула A выполнима,
[50:22.720 --> 50:26.240]  я утверждаю, что вот эта вспомогательная KNF тоже
[50:26.240 --> 50:27.240]  будет выполнима.
[50:27.240 --> 50:29.360]  На каком наборе значений переменных?
[50:29.360 --> 50:32.760]  Ну, к сам присвоим те же самые значения, а что присвоит
[50:32.760 --> 50:33.760]  Z?
[50:33.760 --> 50:36.280]  Ну, легко догадаться, что нужно просто взять Иксы,
[50:36.280 --> 50:40.440]  вот тут у нас значения известных, переменных, и просто вычислить
[50:40.440 --> 50:44.960]  значения всех под формул.
[50:44.960 --> 50:48.520]  Для каждой подформулы значение будет единице, потому что
[50:48.520 --> 50:49.520]  A единица.
[50:49.520 --> 50:52.640]  А что будет для вот этих вспомогательных KNF?
[50:52.640 --> 50:56.400]  А смотрите, это же просто правило вычисления значения
[50:56.400 --> 50:58.520]  формулы по значениям под формулу.
[50:58.520 --> 51:02.680]  Если мы вычисли уже вот эти вот значения в точке
[51:02.680 --> 51:06.240]  альфа, то вот это значение определяется ровно такой
[51:06.240 --> 51:07.240]  же формулой.
[51:07.240 --> 51:12.600]  То есть, раз мы присваиваем по нашему правилу вычисления
[51:12.600 --> 51:14.720]  значения, все вот эти вот эквивалентности будут
[51:14.720 --> 51:15.720]  выполняться.
[51:15.720 --> 51:17.600]  Они, собственно, про это и говорят.
[51:17.600 --> 51:19.600]  Вот эти вот эквивалентности говорят, что мы корректно
[51:19.600 --> 51:23.800]  вычислили значения под формулы B по значениям, входящих
[51:23.800 --> 51:26.440]  под формулы C и D, из которых она составлена.
[51:26.440 --> 51:30.320]  Ну и все.
[51:30.320 --> 51:32.120]  Давайте теперь в другую сторону посмотрим.
[51:32.120 --> 51:39.320]  Допустим, на каком-то наборе у нас KNF истинно.
[51:39.320 --> 51:44.000]  Ну, я буду утверждать, что тогда наша формула должна
[51:44.000 --> 51:48.120]  быть истинна на ограничении, то есть забывая про переменные
[51:48.120 --> 51:49.120]  бета.
[51:49.120 --> 51:51.040]  Ну, давайте смотреть.
[51:51.040 --> 51:53.280]  Опять-таки индукции по разбору формулы будем
[51:53.280 --> 52:05.160]  доказывать, что если все члены, все дизъюнкты нашей
[52:05.160 --> 52:10.360]  KNF истинны, то тогда значения соответствующих вот этих
[52:10.360 --> 52:13.840]  вот переменных, они должны быть ровно значениями
[52:13.840 --> 52:16.680]  соответствующие под формулы на наборе альфа.
[52:16.680 --> 52:20.800]  Ну, это, очевидно, для базы индукции, то есть для переменных.
[52:20.800 --> 52:24.840]  Ну, для переменных деваться некуда, они принимают ровно
[52:24.840 --> 52:26.720]  те значения, которые нужны.
[52:26.720 --> 52:29.400]  А дальше нужно сделать шах индукции, ну шах индукции
[52:29.400 --> 52:32.280]  делается очень просто, если у нас вот есть, давайте
[52:32.280 --> 52:39.560]  я, у нас несколько случаев, но чтобы не мучиться я рассмотрю
[52:39.560 --> 52:43.840]  один, скажем, с импликацией, а дальше все аналогично.
[52:43.840 --> 52:48.080]  Допустим, мы уже доказали для меньших формул, что
[52:48.080 --> 52:56.200]  ЗС равняется С от альфа и ЗД равняется С от альфа,
[52:56.200 --> 52:59.200]  Д от альфа.
[52:59.200 --> 53:03.480]  Ну, тогда, смотрите, раз у нас KNF вот эта истина,
[53:03.480 --> 53:08.560]  у нас есть соответствующая истина, вот такое вот высказывание,
[53:08.560 --> 53:16.680]  ЗС, О, ЗБ, равносильно ЗС следует ЗД.
[53:16.680 --> 53:24.600]  Ну и чему равняется значение под формулой B на наборе
[53:24.600 --> 53:25.600]  альфа?
[53:25.600 --> 53:30.400]  Просто по определению это С от альфа следует Д от
[53:30.400 --> 53:33.440]  альфа, по предположению индукции то же самое, что
[53:33.440 --> 53:39.880]  ЗС следует ЗД, и вот это истина, ну раз это истина,
[53:39.880 --> 53:44.760]  значит ЗБ должно равняться вот этому вот самому значению,
[53:44.760 --> 53:53.680]  ну и тем самым ЗБ будет равняться значению под формулой B на
[53:53.680 --> 53:54.680]  наборе альфа.
[53:54.680 --> 53:57.600]  То есть опять-таки ничего удивительного нет, поскольку
[53:57.600 --> 54:01.320]  мы фактически задали, вот это KNF задает правило
[54:01.320 --> 54:05.960]  вычисления значения под формулу, по предыдущему,
[54:05.960 --> 54:09.160]  ну и ясно, что если мы все предыдущие вычислили
[54:09.160 --> 54:12.320]  правильно, то у нас нет никакой возможности уклониться
[54:12.320 --> 54:15.440]  от того, чтобы правильно вычислить следующее значение,
[54:15.440 --> 54:19.640]  потому что это функция, а тут стоит эквивалентность,
[54:19.640 --> 54:23.600]  у нас вот эта переменная, она должна равняться значению
[54:23.600 --> 54:24.600]  вот этого выражения.
[54:24.600 --> 54:30.400]  Ну если там не импликация, а любая другая связка, рассуждение
[54:30.400 --> 54:36.360]  абсолютно такое же, потому что от него ничего не зависит.
[54:36.360 --> 54:40.960]  Вот таким вот образом мы получаем равносильность,
[54:40.960 --> 54:41.960]  вот эту свадимость.
[54:41.960 --> 54:47.960]  И теперь самое время вернуться к самому началу, я обещал
[54:47.960 --> 54:50.400]  систему доказательств, как теперь устроена система
[54:50.400 --> 54:51.400]  доказательств.
[54:51.400 --> 55:04.520]  Вот у нас есть формула, ну булева формула давайте
[55:04.520 --> 55:07.960]  считать, что будет тогда для нее доказательством.
[55:07.960 --> 55:13.240]  Будет такой список, во-первых отрицание формулы, во-вторых
[55:14.240 --> 55:23.640]  которая построена по отрицанию, в-третьих, вот это вот резолютивный
[55:23.640 --> 55:40.960]  вывод, противоречие из конъюнктов, из дизюнктов, прошу прощения,
[55:41.040 --> 55:52.000]  вот такой список, можно сказать, формулы, он и будет доказательством
[55:52.000 --> 55:53.000]  тавтологичности.
[55:53.000 --> 55:54.000]  Почему?
[55:54.000 --> 55:58.480]  Потому что, смотрите, если такой список существует,
[55:58.480 --> 56:03.960]  пусть ему нашелся корректность, ну тогда вот это резолютивный
[56:03.960 --> 56:09.280]  вывод показывает, что КНФ, из которого делается этот
[56:09.280 --> 56:14.560]  вывод, невыполнимо, сводимость наша говорит, что тогда отрицание
[56:14.560 --> 56:20.080]  F невыполнимо, значит F тавтология, и наоборот, предположим,
[56:20.080 --> 56:26.880]  что F нет тавтологии, тогда отрицание F выполнимо, тогда
[56:26.880 --> 56:30.480]  выполнимо и соответствующая КНФ, которую мы сейчас построили,
[56:30.480 --> 56:34.500]  ну тогда какой бы вы резолютивный вывод не написали, где-то
[56:34.500 --> 56:37.120]  должна быть ошибка, то есть пустого дизюнкта вы не
[56:37.120 --> 56:39.880]  получите по корректности исчисления резолюции.
[56:39.880 --> 56:40.880]  Вот, собственно, и все.
[56:40.880 --> 56:44.160]  Вот такая вот система доказательств.
[56:44.160 --> 56:47.280]  Она выглядит сложнее, чем исчисление высказываний.
[56:47.280 --> 56:48.280]  Почему?
[56:48.280 --> 56:51.120]  Потому что мы отказались от идеи моделировать человеческое
[56:51.120 --> 56:52.120]  рассуждение.
[56:52.120 --> 56:53.480]  Люди так не рассуждают.
[56:53.480 --> 56:58.600]  Люди не строят вот эту КНФ по отрицанию какого-то
[56:58.600 --> 56:59.600]  утверждения.
[56:59.600 --> 57:00.600]  Это довольно безумное занятие.
[57:01.600 --> 57:07.120]  Но если говорить о компьютерах, то есть очевидный плюс
[57:07.120 --> 57:09.600]  у резолюции перед исчислением высказываний.
[57:09.600 --> 57:12.520]  Вот в исчислении высказываний, если вам дана формула, вы
[57:12.520 --> 57:13.840]  хотите построить ее вывод.
[57:13.840 --> 57:14.840]  Есть такая проблема.
[57:14.840 --> 57:16.240]  С чего этот вывод начинать?
[57:16.240 --> 57:20.000]  Ну для конкретных формул я вам говорил разные добрые
[57:20.000 --> 57:23.080]  идеи, с чего стоит начинать, но это конкретная короткая
[57:23.080 --> 57:25.360]  формула, а записана длинная формула, про которую ничего
[57:25.360 --> 57:26.360]  не понятно.
[57:26.360 --> 57:27.360]  С чего начинать?
[57:27.360 --> 57:28.360]  Неясно.
[57:28.360 --> 57:33.360]  А здесь у нас же дизъюнктов вообще конечное количество.
[57:33.360 --> 57:35.520]  Поэтому здесь, если не заботиться об эффективности, можно
[57:35.520 --> 57:37.360]  вообще начинать чего угодно.
[57:37.360 --> 57:39.920]  Вот есть у нас набор дизъюнктов.
[57:39.920 --> 57:42.600]  Давайте искать пару, к которым можно применить
[57:42.600 --> 57:43.600]  резолюцию.
[57:43.600 --> 57:44.600]  Применим резолюцию.
[57:44.600 --> 57:46.880]  Дальше у нас набор увеличился на единицу.
[57:46.880 --> 57:48.840]  Опять смотрим, можно ли применить резолюцию.
[57:48.840 --> 57:51.200]  Если можем, применяем и расширяем набор.
[57:51.200 --> 57:53.480]  В какой-то момент окажется, что мы уже ничего нового
[57:53.480 --> 57:54.480]  построить не можем.
[57:54.480 --> 57:56.720]  Применение резолюции дает только те дизъюнкты, которые
[57:56.720 --> 57:57.720]  так уже есть.
[57:57.720 --> 58:02.880]  В этот момент мы говорим, все, множество совместно,
[58:02.880 --> 58:05.320]  потому что пустого мы уже не выведем.
[58:05.320 --> 58:07.960]  А если появился пустой, мы говорим, отлично, оно
[58:07.960 --> 58:10.120]  несовместно, мы доказали, вывели пустой дизъюнкт.
[58:10.120 --> 58:15.400]  То есть в этом смысле исчисление резолюции, оно и было придумано
[58:15.400 --> 58:18.320]  в конце 50-х годов, когда люди стали задумываться
[58:18.320 --> 58:20.800]  об автоматизации доказательств.
[58:20.800 --> 58:24.320]  Потому что здесь вроде бы, ну тогда они очень заботились
[58:24.400 --> 58:26.760]  о том, что может получиться очень длинно.
[58:26.760 --> 58:30.000]  Это странная вещь, но когда компьютеры были очень слабыми,
[58:30.000 --> 58:36.280]  8 килобайт было пределом мечтаний, люди легко рассуждали,
[58:36.280 --> 58:38.600]  ну давайте будем перебирать все наборы значения тысячи
[58:38.600 --> 58:39.600]  переменных.
[58:39.600 --> 58:40.600]  Это никого не смущало.
[58:40.600 --> 58:43.440]  А сейчас как-то люди начинают писать в репи, ну да, вот
[58:43.440 --> 58:47.360]  от тысячи не перебирать, от 500 может быть.
[58:47.360 --> 58:49.320]  А тогда как-то это никого не волновало.
[58:49.320 --> 58:53.600]  Потому что это все было так в общих рассуждениях.
[58:53.600 --> 58:58.040]  Но тем не менее, идея оказалась очень правильной.
[58:58.040 --> 59:03.880]  И вот за остаток лекции я хочу объяснить, уже практически
[59:03.880 --> 59:06.560]  ничего не доказывая, просто рассказать, это полезно
[59:06.560 --> 59:11.480]  понимать, соотношение между исчислением высказываний
[59:11.480 --> 59:12.840]  и исчислением резолюции.
[59:12.840 --> 59:16.080]  Вот у нас есть система доказательств, построенная на резолюциях,
[59:16.080 --> 59:17.880]  есть система доказательств, построенная на исчислении
[59:17.880 --> 59:18.880]  высказываний.
[59:18.880 --> 59:22.840]  Ну лучше в каком смысле?
[59:22.840 --> 59:24.400]  Обычно сравнивают по длине доказательств.
[59:24.400 --> 59:28.160]  Если есть доказательства в одной системе, насколько
[59:28.160 --> 59:29.920]  длинным или коротким может быть доказательство
[59:29.920 --> 59:30.920]  в другой системе.
[59:30.920 --> 59:34.800]  Так вот, с такой теоретической точки зрения, исчисление
[59:34.800 --> 59:35.800]  высказываний намного лучше.
[59:35.800 --> 59:40.920]  По резолютивному выводу мы можем построить доказательство
[59:40.920 --> 59:43.800]  f в исчислении высказываний, которое будет иметь полинамеральную
[59:43.800 --> 59:44.800]  длину.
[59:44.800 --> 59:46.800]  Ну даже, по-моему, линейную.
[59:47.120 --> 59:49.880]  И, в общем-то, идея более-менее понятная, потому что мы,
[59:49.880 --> 59:51.720]  конечно, можем вывести то, что у нас используются
[59:51.720 --> 59:54.640]  правила резолюции, но мы можем вывести соответствующую
[59:54.640 --> 59:58.600]  тавтологию, что из конъюнции двух таких формул, импликация
[59:58.600 --> 01:00:01.640]  значит то, что получается в выводе.
[01:00:01.640 --> 01:00:05.440]  Вот этот переход мы тоже можем обосновать, более-менее,
[01:00:05.440 --> 01:00:08.920]  построив доказательства равносильности и выполнимости.
[01:00:08.920 --> 01:00:11.760]  Это надо подумать, как правильно сделать, но, в принципе,
[01:00:11.760 --> 01:00:12.760]  возможно.
[01:00:12.760 --> 01:00:17.400]  Тогда получится, что мы, если у нас есть вывод пустого
[01:00:17.400 --> 01:00:22.320]  дизъюнкта, мы как бы из отрицания f получаем противоречие.
[01:00:22.320 --> 01:00:26.200]  А вы помните, когда я доказывал теорему о полноте, это наш
[01:00:26.200 --> 01:00:27.200]  основной прием.
[01:00:27.200 --> 01:00:29.760]  Если мы хотим доказать f, давайте из отрицания f выведем
[01:00:29.760 --> 01:00:33.240]  противоречие, тогда, пользуясь средством исчисления высказаний,
[01:00:33.240 --> 01:00:35.960]  в два шага получим доказательство нашей формулы.
[01:00:35.960 --> 01:00:39.760]  Вот примерно такая идея, ее, конечно, нужно оформлять,
[01:00:39.760 --> 01:00:42.880]  там все шаги делаются, по-моему, все-таки квадратичная
[01:00:42.880 --> 01:00:46.120]  будет свадебность, я погорячился, что линейная, но неважно.
[01:00:46.120 --> 01:00:48.520]  Подробности я рассказывать как раз не хочу, желающие
[01:00:48.520 --> 01:00:50.960]  могут подумать, как это сделать, это интересно,
[01:00:50.960 --> 01:00:53.120]  но так технически не совсем просто.
[01:00:53.120 --> 01:00:56.680]  То есть, казалось бы, исчисления в высказывании намного
[01:00:56.680 --> 01:01:02.360]  лучше, но на самом деле исчисления в высказывании
[01:01:02.360 --> 01:01:05.040]  в реальных программах, которые проверяют автологии,
[01:01:05.040 --> 01:01:06.040]  не используются.
[01:01:06.040 --> 01:01:09.320]  Я не знаю таких программ, и непонятно, как их писать.
[01:01:09.480 --> 01:01:12.760]  А исчисления резолюции используются, и используются настолько
[01:01:12.760 --> 01:01:15.800]  эффективно, что в последние годы полно публикаций
[01:01:15.800 --> 01:01:16.800]  такого вида.
[01:01:16.800 --> 01:01:18.680]  Вот есть какая-то комбинаторная задача, сложная, которую
[01:01:18.680 --> 01:01:19.680]  непонятно, как решать.
[01:01:19.680 --> 01:01:24.120]  И человек пишет, ну мы же знаем, что выполнимость
[01:01:24.120 --> 01:01:28.280]  KNF проверяется легко, давайте нашу задачу сведем к выполнимости
[01:01:28.280 --> 01:01:31.680]  KNF и проверим выполнимость KNF.
[01:01:31.680 --> 01:01:34.560]  При том, что все знают, это пишут люди, естественно,
[01:01:34.560 --> 01:01:36.880]  достаточно грамотные, все знают, что в теоретической
[01:01:36.880 --> 01:01:39.160]  точки зрения выполнимость KNF трудная задача.
[01:01:39.160 --> 01:01:44.000]  И на самом деле исчисление резолюции не только в этом
[01:01:44.000 --> 01:01:46.920]  смысле слабее, но еще вот в каком смысле.
[01:01:46.920 --> 01:01:50.080]  Для исчисления в высказывании мы не знаем тавтологии,
[01:01:50.080 --> 01:01:52.360]  которые доказываются только очень длинно.
[01:01:52.360 --> 01:01:53.840]  Мы просто не знаем.
[01:01:53.840 --> 01:01:55.400]  Может их и нет.
[01:01:55.400 --> 01:01:56.400]  Никто не знает.
[01:01:56.400 --> 01:01:58.440]  А для исчисления резолюции такие тавтологии можно
[01:01:58.440 --> 01:01:59.440]  написать.
[01:01:59.440 --> 01:02:02.640]  Вот можно написать тавтологию, у которой любое опровержение
[01:02:02.640 --> 01:02:05.800]  резолюциями будет экспоненциально длинным.
[01:02:05.800 --> 01:02:10.560]  При этом, как экспоненциально, два в степени корень издлина
[01:02:10.560 --> 01:02:11.560]  формулы.
[01:02:11.560 --> 01:02:14.800]  Не длина формулы, а корень издлина формулы, но все
[01:02:14.800 --> 01:02:15.800]  равно экспоненциально.
[01:02:15.800 --> 01:02:19.120]  При этом вывод в исчисление высказываний для этой тавтологии
[01:02:19.120 --> 01:02:21.120]  на самом деле короткий, полиномиальный.
[01:02:21.120 --> 01:02:23.680]  Это тоже можно доказать.
[01:02:23.680 --> 01:02:26.640]  Поэтому в теоретической точке зрения исчисление
[01:02:26.640 --> 01:02:29.240]  высказываний намного сильнее, это все знают, все так и пишут
[01:02:29.240 --> 01:02:30.240]  во всех статьях.
[01:02:30.240 --> 01:02:34.000]  Но в других статьях пишут, что мы знаем, что проверять
[01:02:34.000 --> 01:02:37.040]  легко выполнимость КНФ.
[01:02:37.040 --> 01:02:41.160]  И это не то, что там, это просто в моей практике тоже
[01:02:41.160 --> 01:02:42.160]  был такой случай.
[01:02:42.160 --> 01:02:44.000]  У меня был студент, который решал задачу из теории
[01:02:44.000 --> 01:02:45.000]  игр.
[01:02:45.000 --> 01:02:47.600]  Мне нужно было делать довольно сложный перебор комбинаторный.
[01:02:47.600 --> 01:02:48.600]  Он написал программу.
[01:02:48.600 --> 01:02:51.640]  Но там заведомо перебор был большой, было ясно с
[01:02:51.640 --> 01:02:52.640]  самого начала.
[01:02:52.640 --> 01:02:54.920]  Но оно у него работало совсем медленно, там нужно было
[01:02:54.920 --> 01:02:56.800]  для разных графов делать, ну вот он там буквально с
[01:02:56.800 --> 01:02:59.760]  графами с 5 вершинами, с 6 вершинами, с 6 уже не мог
[01:02:59.760 --> 01:03:00.760]  справиться.
[01:03:01.000 --> 01:03:06.680]  И тут он вспомнил, как ни странно, что ему рассказывали
[01:03:06.680 --> 01:03:10.000]  про исчисление резолюции на втором курсе.
[01:03:10.000 --> 01:03:14.680]  Он обрадовался, посмотрел сети, нашел программу, которая
[01:03:14.680 --> 01:03:17.360]  проверяет выполнимость КНФ, запустил ее и все стало
[01:03:17.360 --> 01:03:19.240]  работать 600 раз быстрее.
[01:03:19.240 --> 01:03:21.720]  То есть то, что у него требовало там нескольких дней, буквально
[01:03:21.720 --> 01:03:24.160]  в минуты у него просто вычисляло.
[01:03:24.160 --> 01:03:27.960]  И далеко он конечно не ушел, там на графах с 7 вершинами
[01:03:27.960 --> 01:03:30.600]  все равно это все перестало работать.
[01:03:30.600 --> 01:03:33.160]  Потому что там действительно очень большие объемы, там
[01:03:33.160 --> 01:03:34.160]  уже ничего не спасает.
[01:03:34.160 --> 01:03:39.200]  Но тем не менее, как такое вообще возможно?
[01:03:39.200 --> 01:03:41.800]  Это животрепещий вопрос.
[01:03:41.800 --> 01:03:45.600]  То есть есть два вопроса, в которых теоретическая
[01:03:45.600 --> 01:03:49.080]  информатика, теория, она полностью проигрывает
[01:03:49.080 --> 01:03:51.960]  практики и пока не очень понятно, как с этим быть.
[01:03:51.960 --> 01:03:56.920]  Это вот во-первых проверка выполнимости КНФ, а второе,
[01:03:56.920 --> 01:03:59.440]  но это вы все знаете, это вот эти нейронные сети,
[01:03:59.760 --> 01:04:02.760]  которые по непонятным причинам что-то хорошее делают, хотя
[01:04:02.760 --> 01:04:05.760]  не должны.
[01:04:05.760 --> 01:04:09.440]  Нет никаких оснований считать, что в многомерном пространстве
[01:04:09.440 --> 01:04:13.440]  так уж градиентные методы могут дать хоть что-то полезное.
[01:04:13.440 --> 01:04:14.440]  Но дают.
[01:04:14.440 --> 01:04:15.440]  Почему?
[01:04:15.440 --> 01:04:16.440]  Неясно.
[01:04:16.440 --> 01:04:18.560]  У нас нет теоретических средств для ответа ни
[01:04:18.560 --> 01:04:21.840]  на один, ни на другой вопрос.
[01:04:21.840 --> 01:04:24.200]  Откуда взялись хорошие программы, откуда взялись нейронные
[01:04:24.200 --> 01:04:27.600]  сети, я думаю вы отчасти представляете, но откуда
[01:04:27.600 --> 01:04:30.760]  взялись хорошие программы для выполнимости КНФ, я вам
[01:04:30.760 --> 01:04:31.760]  сейчас расскажу.
[01:04:31.760 --> 01:04:32.760]  У меня еще пять минут есть.
[01:04:32.760 --> 01:04:37.440]  Эксплуатировалась очень простая идея, что люди любят
[01:04:37.440 --> 01:04:38.440]  соревноваться.
[01:04:38.440 --> 01:04:43.360]  Двадцать лет назад начаты были чемпионаты SAT-солверов,
[01:04:43.360 --> 01:04:45.360]  то есть программ, которые проверяют выполнимость
[01:04:45.360 --> 01:04:46.360]  КНФ.
[01:04:46.360 --> 01:04:51.840]  То есть собираются люди, выдают исходный код на Си,
[01:04:51.840 --> 01:04:52.840]  скажем.
[01:04:52.840 --> 01:04:55.160]  Я не помню, сейчас может быть это изменилось, в начале
[01:04:55.160 --> 01:04:57.760]  это было Си, и по-моему Си плюс плюс разрешалось.
[01:04:57.760 --> 01:05:01.360]  В общем какие-то ограничения, чтобы у организаторов есть
[01:05:01.360 --> 01:05:03.640]  совершенно конкретные трансляторы, они используют один и тот
[01:05:03.640 --> 01:05:07.800]  же транслятор для любого кода, формулы описываются
[01:05:07.800 --> 01:05:10.600]  некоторым стандартным образом, это организаторы тоже объявляют,
[01:05:10.600 --> 01:05:14.000]  что это формат задания формул, и дальше запускается
[01:05:14.000 --> 01:05:16.440]  он на одном и том же компьютере, то есть соревнования именно
[01:05:16.440 --> 01:05:19.800]  алгоритмов, то есть железо абсолютно одно и то же.
[01:05:19.800 --> 01:05:25.080]  Ну и кто быстрее, разные виды, как в лёгкой атлетике
[01:05:25.080 --> 01:05:27.480]  есть разные виды, и тут тоже есть разные виды.
[01:05:27.480 --> 01:05:30.840]  На случайный КНФ, на КНФ, которые получаются вот такой
[01:05:30.840 --> 01:05:33.040]  сводимостью, то есть берём какую-нибудь булевую формулу
[01:05:33.040 --> 01:05:36.400]  замысловатую, сводим и смотрим, что там получается.
[01:05:36.400 --> 01:05:39.700]  На КНФ, которые приходят из индустрии, это уже в более
[01:05:39.700 --> 01:05:44.200]  поздние годы, коммерческие люди этим заинтересовались,
[01:05:44.200 --> 01:05:46.200]  и они стали для соревнований просто выдавать, то есть
[01:05:46.200 --> 01:05:49.840]  у них есть какая-то может быть даже секретная вещь,
[01:05:49.840 --> 01:05:51.840]  которую они хотят проверить, но когда это превращается
[01:05:51.840 --> 01:05:54.200]  в КНФ, восстановить, что там было в начале достаточно
[01:05:54.200 --> 01:05:55.200]  сложно.
[01:05:55.200 --> 01:05:57.600]  Вы же понимаете, перенумеровать какой-нибудь случайной
[01:05:57.600 --> 01:06:00.800]  перестановкой, перенумеровать переменной, кто там разберётся,
[01:06:00.800 --> 01:06:01.800]  о чём вообще речь.
[01:06:01.800 --> 01:06:06.520]  Какая-то длинная там с миллионом переменных формулы.
[01:06:06.520 --> 01:06:10.760]  Ну опять-таки соревнования на тех КНФ, про которые
[01:06:10.760 --> 01:06:13.600]  люди умеют доказывать, что резолюции работают плохо.
[01:06:13.600 --> 01:06:15.080]  Вот в общем много.
[01:06:15.080 --> 01:06:20.640]  Вы можете найти сайты этих чемпионатов и посмотреть.
[01:06:20.640 --> 01:06:23.720]  И поскольку это происходит 20 лет, а люди всегда, когда
[01:06:23.800 --> 01:06:26.800]  хотят выигрывать, эти программы бешено совершенствовались.
[01:06:26.800 --> 01:06:29.880]  Вот мой студент использовал чемпионскую программу 2014
[01:06:29.880 --> 01:06:32.680]  года, это было года три назад, и она уже работала очень
[01:06:32.680 --> 01:06:33.680]  хорошо.
[01:06:33.680 --> 01:06:36.480]  Просто более поздние программы, они уже не открыты, они
[01:06:36.480 --> 01:06:38.320]  представят коммерческий интерес, их просто так
[01:06:38.320 --> 01:06:42.800]  не выдают, то есть можно купить их, но тогда они не
[01:06:42.800 --> 01:06:43.800]  так дёшево стоят.
[01:06:43.800 --> 01:06:46.280]  Ну и в общем неудивительно, потому что сил вложено
[01:06:46.280 --> 01:06:48.280]  в создание этих программ огромное количество, это
[01:06:48.280 --> 01:06:51.120]  как любой вид спорта, чтобы становиться чемпионом,
[01:06:51.200 --> 01:06:54.280]  нужно прикладывать огромное количество усилий, тренироваться,
[01:06:54.280 --> 01:06:57.880]  что-то делать, но что существенно, у меня осталось буквально
[01:06:57.880 --> 01:07:01.120]  две минуты, в основе практически всех этих программ лежат
[01:07:01.120 --> 01:07:05.400]  резолюции, точнее комбинация резолюций и очень примитивная
[01:07:05.400 --> 01:07:07.640]  идея частичного разбора переменных.
[01:07:07.640 --> 01:07:10.840]  Вот смотрите, у нас есть набор переменных, давайте
[01:07:10.840 --> 01:07:14.040]  разбирать по первой переменной, х1 равно нулю и х1 равно
[01:07:14.040 --> 01:07:18.400]  единице, подставим, что-то у КНФ уйдёт, потому что
[01:07:18.400 --> 01:07:25.720]  если х1 равно нулю и входит х1, то просто вычёркиваем
[01:07:25.720 --> 01:07:29.600]  этот литерал, а если не х1, то этот литерал единичный,
[01:07:29.600 --> 01:07:34.480]  мы прям весь дизюнкт вычёркиваем, то есть КНФ так слегка
[01:07:34.480 --> 01:07:37.240]  упрощается, мы так разбираем, разбираем, получается
[01:07:37.240 --> 01:07:41.080]  такое дерево разбора, что существенно, что когда
[01:07:41.080 --> 01:07:43.680]  происходит рекурсивный возврат, как в моём доказательстве
[01:07:43.680 --> 01:07:47.560]  полноты, если мы уже разобрали одну ветку и другую ветку
[01:07:47.560 --> 01:07:52.440]  и пришли, что они невыполнимы, мы можем найти, применить
[01:07:52.440 --> 01:07:56.840]  резолюцию, мы можем вывести новый дизюнкт, то есть получается
[01:07:56.840 --> 01:07:59.720]  так, что такой комбинированный алгоритм, мы делаем разбор
[01:07:59.720 --> 01:08:02.760]  частичный, каждый раз, когда делается рекурсивный
[01:08:02.760 --> 01:08:06.280]  возврат, мы добавляем дизюнкты, соответственно, у нас больше
[01:08:06.280 --> 01:08:12.080]  проблем, то есть у нас ветвление чаще обрывается, чаще происходит
[01:08:12.080 --> 01:08:14.320]  рекурсивный возврат, больше дизюнктов, то есть такой
[01:08:15.160 --> 01:08:19.200]  бутстрепен, и эта идея удивительно хорошо работает, понятно,
[01:08:19.200 --> 01:08:22.040]  что в чемпионских программах есть ещё и много чего, но
[01:08:22.040 --> 01:08:25.920]  вот эта идея есть всегда, с неё всегда начинают, скажем,
[01:08:25.920 --> 01:08:29.080]  на случайных КНФ она сама по себе очень хорошо работает,
[01:08:29.080 --> 01:08:33.840]  как ни странно, но на не случайных надо что-то делать, в последние
[01:08:33.840 --> 01:08:37.120]  годы уже нейронные сети там запускают, то есть вот программа
[01:08:37.120 --> 01:08:40.480]  работает-работает, там же очень много свободы, у нас
[01:08:40.480 --> 01:08:43.120]  выбор переменной, очередной для ветвления, он ничем не
[01:08:43.120 --> 01:08:47.360]  ограничен, и вот сеть изучает, как она ветвилась, насколько
[01:08:47.360 --> 01:08:50.720]  удачно получалась, и на этом сама обучается, прям на
[01:08:50.720 --> 01:08:54.480]  собственной работе, и говорят, что вот чемпионские программы
[01:08:54.480 --> 01:08:57.440]  на этом что-то выигрывают, вот современно уже последних лет,
[01:08:57.440 --> 01:09:01.840]  ну вот примерно так, то есть удивительным образом
[01:09:01.840 --> 01:09:08.120]  в решении задачи выполнимости помогла не наука, а неистребимое
[01:09:08.120 --> 01:09:12.720]  желание людей побеждать соревнований, ну вот на сегодня
[01:09:12.720 --> 01:09:13.600]  всё.
