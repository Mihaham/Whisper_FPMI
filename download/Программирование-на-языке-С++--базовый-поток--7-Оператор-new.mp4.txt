[00:00.000 --> 00:07.000]  Но прежде чем мы к этому разговору перейдем, как
[00:07.000 --> 00:11.600]  обычно, по традиции, давайте я вас о задачу или поднимем
[00:11.600 --> 00:14.760]  некоторую проблему, которую, к сожалению, вот теми средствами
[00:14.760 --> 00:17.880]  все еще, все еще теми средствами, которые мы с вами изучаем-изучаем,
[00:17.880 --> 00:20.200]  а у нас решить не получается.
[00:20.200 --> 00:25.640]  Значит, проблема следующая, давайте вспомним ваше текущее
[00:25.640 --> 00:28.160]  домашнее задание, в котором вам нужно реализовать
[00:28.160 --> 00:30.600]  класс String.
[00:30.600 --> 00:34.760]  Вот класс String реализован с помощью динамически расширяющегося
[00:34.760 --> 00:35.760]  массива.
[00:35.760 --> 00:37.400]  Соответственно, давайте я напомню, к чему идея.
[00:37.400 --> 00:40.120]  Идея в том, что у нас есть некоторый выделенный кусок
[00:40.120 --> 00:45.400]  памяти, который имеет, который занимает capacity-byte в памяти,
[00:45.400 --> 00:47.960]  но при этом реально в памяти хранится, но при этом реально
[00:47.960 --> 00:52.000]  в памяти, ну точнее в качестве полезных элементов строки
[00:52.000 --> 00:55.160]  хранится всего сайз элементов, да, вот последний, но завершающий
[00:55.160 --> 00:56.160]  нулевой символ.
[00:56.160 --> 00:57.160]  Ну для чего это делается?
[00:57.160 --> 00:59.800]  Для того, чтобы при расширении строки, при добавлении символа
[00:59.800 --> 01:02.400]  в конец или просто-напросто при конконтинации двух строк
[01:02.400 --> 01:04.560]  нам не пришлось заново перевыделять память, да, то
[01:04.560 --> 01:07.800]  есть мы вот этот вот самый гэп между capacity и size, то
[01:07.800 --> 01:09.560]  есть вот это вот дополнительное пространство можем заполнять
[01:09.560 --> 01:11.880]  бесплатно, да, просто-напросто добавляя очередные элементы.
[01:11.880 --> 01:12.880]  Вот.
[01:12.880 --> 01:15.360]  Ну и, собственно, давайте рассмотрим какой-нибудь
[01:15.360 --> 01:17.360]  из методов стринга, ну, например, метод resize.
[01:17.360 --> 01:19.080]  Как реализовать метод resize для стринги?
[01:19.080 --> 01:21.320]  Ну давайте для простоты предполагать, что resize не
[01:21.320 --> 01:24.100]  выходит, то есть при изменении размера строки мы не будем
[01:24.100 --> 01:26.640]  выходить за границы capacity, да, мы не будем выходить за
[01:27.040 --> 01:28.160]  размеры реально выделенной памяти.
[01:28.160 --> 01:30.860]  Ну, соответственно, смотрите, что нужно сделатьЧтобы
[01:30.860 --> 01:32.040]  уменьшить размер до двух?
[01:32.040 --> 01:34.520]  Ну кажется что нужно сделать всего два действия, да?
[01:34.520 --> 01:37.840]  Во-первых, нужно size уменьшить до двух, то есть просто
[01:37.840 --> 01:39.320]  сказать, что теперь мы храним всего два элемента.
[01:39.320 --> 01:40.700]  И плюс еще какое действие?
[01:40.700 --> 01:42.560]  Ну да, записать вот здесь вот качество последнего
[01:42.560 --> 01:45.200]  символа нулевой символ, сказать что вот строка заканчивается
[01:45.200 --> 01:46.200]  здесь.
[01:46.200 --> 01:47.580]  knocked по сути всего, да, по сути за два действия
[01:47.580 --> 01:49.200]  мы уменьшили размер строки.
[01:49.200 --> 01:50.200]  Окей.
[01:50.200 --> 01:51.200]  Что нужно сделать чтобы увеличить размер строки?
[01:51.200 --> 01:54.400]  Ну, соответственно, то же самое, да, то есть грубо
[01:54.400 --> 01:59.040]  мы говорим, что size теперь у нас вот такой, ну и в конце
[01:59.040 --> 02:00.160]  мы добавляем нулевой символ.
[02:00.160 --> 02:07.200]  То есть кажется, что изменение размера в рамках capacity занимает
[02:07.200 --> 02:08.200]  константное время.
[02:08.200 --> 02:09.200]  Ну почему?
[02:09.200 --> 02:10.880]  Потому что достаточно всего лишь изменить значение
[02:10.880 --> 02:15.160]  poli-size и выставить нулевой символ туда, куда надо.
[02:15.160 --> 02:21.160]  Хорошо, давайте теперь рассмотрим класс std-вектор.
[02:21.160 --> 02:25.960]  По сути std-вектор это есть не что иное, как динамический
[02:25.960 --> 02:28.880]  массив, который тоже может там динамически расширяться,
[02:28.880 --> 02:30.480]  в котором можно добавлять элементы, ну и так далее
[02:30.480 --> 02:31.480]  и так далее.
[02:31.480 --> 02:33.240]  Ну и в целом как бы вектор реализован точно так же
[02:33.240 --> 02:36.400]  как и string, то есть по сути у него тоже есть выделенная
[02:36.400 --> 02:41.080]  память размера capacity и есть такая характеристика
[02:41.080 --> 02:44.720]  как size, то есть сколько элементов массива реально используется,
[02:44.720 --> 02:47.040]  сколько объектами реально заполнен мой массив.
[02:47.040 --> 02:50.360]  Ну и кажется, что история тут точно такая же, как
[02:50.360 --> 02:51.360]  в случае string.
[02:51.360 --> 02:53.640]  То есть если я вызываю метод resize, то к чему должен приводить
[02:53.640 --> 02:54.640]  resize.
[02:54.640 --> 02:56.160]  Но если мы уменьшаем размер, то я просто-напросто меняю
[02:56.160 --> 02:58.960]  значение poli-size на нужное мне, при этом так как в векторе
[02:58.960 --> 03:01.000]  нет никакого нулевого символа, ну нулевого символа заполнять
[03:01.000 --> 03:02.000]  не нужно.
[03:02.000 --> 03:03.520]  И то же самое происходит при расширении вектора.
[03:03.520 --> 03:06.080]  Скажем, если мне нужно увеличить вектор до какой-то
[03:06.080 --> 03:11.440]  величины, я просто-напросто беру size, увеличу вот такой
[03:11.440 --> 03:12.440]  до нужной позиции и все.
[03:12.440 --> 03:15.440]  В чем проблема?
[03:15.440 --> 03:18.440]  Почему на самом деле вектор вот таким вот образом реализовывает
[03:18.440 --> 03:20.400]  не так эффективно, как string?
[03:20.400 --> 03:22.280]  В чем у вектора может быть проблема?
[03:22.280 --> 03:24.800]  Проблема может быть в следующем.
[03:24.800 --> 03:26.400]  Смотрите, давайте я скажу, что это вектор не просто
[03:26.400 --> 03:28.400]  вектор, а это вектор строк.
[03:28.400 --> 03:31.400]  Вектор ваших string-ов.
[03:31.400 --> 03:33.000]  Что пройдет тогда?
[03:33.000 --> 03:35.040]  Вот представьте себе, что у меня изначально вот такой
[03:35.040 --> 03:39.080]  размер, и я уменьшаю размер там допустим до двух.
[03:39.080 --> 03:42.280]  Ну по сути, по сути, что я делаю, по сути я говорю
[03:42.280 --> 03:43.280]  что.
[03:43.280 --> 03:45.680]  В чем потенциальная проблема такого подхода?
[03:45.680 --> 03:48.400]  Да, представьте себе, что у меня на самом деле изначально
[03:48.400 --> 03:51.080]  размер, изначально размер size был равен ну не знаю там
[03:51.080 --> 03:52.080]  тысяче.
[03:52.080 --> 03:53.080]  Да?
[03:53.080 --> 03:55.400]  И при этом каждая строка содержала ну не знаю там
[03:55.400 --> 03:57.840]  порядка там десятки, ну там десятки или сотни тысяч
[03:57.840 --> 03:58.840]  символов.
[03:58.840 --> 03:59.840]  Окей?
[03:59.840 --> 04:00.840]  Вот.
[04:00.840 --> 04:02.160]  Что произошло, когда вы сделали size равным думам?
[04:02.160 --> 04:04.120]  Ну когда вы сделали size равным думам, вы предполагаете
[04:04.120 --> 04:08.280]  что, ну хорошо, вот я забуду про остальные там 998 строк,
[04:08.280 --> 04:11.120]  да, и буду пользоваться только первыми двумя.
[04:11.120 --> 04:12.840]  Но при этом реально в памяти что происходит?
[04:12.840 --> 04:16.320]  Ну реально-то в памяти все эти строки, они остались,
[04:16.320 --> 04:17.320]  да?
[04:18.120 --> 04:21.260]  То есть реально в памяти эти строки хранят свою память,
[04:21.260 --> 04:23.120]  реально эти строки указывают на свою динамическую память,
[04:23.120 --> 04:24.120]  да?
[04:24.120 --> 04:26.140]  То есть реально эти строки занимают большое количество
[04:26.140 --> 04:27.680]  ресурсов на вашей системе.
[04:27.680 --> 04:28.680]  Понятно?
[04:28.680 --> 04:31.620]  Поэтому чего бы на самом деле хотелось в отличие от
[04:31.620 --> 04:32.620]  стринок?
[04:32.620 --> 04:33.620]  Почему у стринка нет такой проблемы?
[04:33.620 --> 04:34.980]  Ну у стринка нет такой проблемы потому что стринг
[04:34.980 --> 04:37.320]  خранит массив символов, там на каждый символ там
[04:37.320 --> 04:39.640]  тратится буквально один байт, поэтому ничего страшного
[04:39.640 --> 04:40.640]  нет.
[04:40.640 --> 04:41.640]  Ну как бы, если я выделал память в капologue, то меньше
[04:41.640 --> 04:43.280]  чем в капальцете памяти, то не потрачу, вот.
[04:43.280 --> 04:45.800]  Тут же есть проблема в том, что каждый из этих объектов
[04:45.800 --> 04:50.600]  потенциально может быть очень большим, да, и он может занимать свои ресурсы в
[04:50.600 --> 04:54.720]  памяти. Поэтому чего бы хотелось? Ну, скорее всего, хотелось бы следующего
[04:54.720 --> 04:58.800]  поведения, что когда я уменьшаю размер вектора, я бы хотел, чтобы реально все эти
[04:58.800 --> 05:03.120]  объекты были уничтожены. Ну, допустим, для каждого из этих элементов был вызов
[05:03.120 --> 05:06.920]  метод clear. То есть, представьте, что если для каждой строки я вызову метод clear, то тогда
[05:06.920 --> 05:10.160]  если эти строки были большие, то тогда, соответственно, большого объема памяти у меня
[05:10.160 --> 05:15.480]  тратиться теперь не будет. Согласны? Вот. Возникает вопрос, а можно ли сделать так,
[05:15.480 --> 05:20.680]  чтобы, допустим, вот, смотрите, у меня выделен какой-то динамический массив, можно ли
[05:20.680 --> 05:24.200]  сделать так, чтобы были уничтожены только вот эти объекты, а нужны мне объекты,
[05:24.200 --> 05:29.240]  остались в памяти. Вот. Можно так сделать или нет, мы пока не знаем. Ну, я надеюсь,
[05:29.240 --> 05:36.280]  сегодня с этим разберемся. В общем, это первая проблема. Понятно, да? Вторая
[05:36.280 --> 05:41.040]  проблема. Давайте вернемся к тому, что обсуждали последние два занятия, именно
[05:41.040 --> 05:52.520]  к методу emplaceback. Я напомню, что у вектора есть метод emplaceback, который принимает
[05:52.520 --> 06:02.040]  параметры конструктора, с которым нужно создать новый элемент внутри вектора. И
[06:02.040 --> 06:07.160]  давайте подумаем, как его можно реализовать. То есть, смотрите, что мы поняли? Мы, на самом
[06:07.160 --> 06:10.120]  деле, поняли, что emplaceback может принимать произвольное количество параметров, потому что
[06:10.440 --> 06:13.680]  мы заранее не знаем, сколько параметров конструктора, какими параметрами конструктора
[06:13.680 --> 06:18.920]  мы должны создать объект внутри вектора. Мы поняли, что аргумент Aloj нужно передать по
[06:18.920 --> 06:21.720]  универсальной ссылке, потому что какие-то аргументы мы хотим передать по ссылке.
[06:21.720 --> 06:24.840]  И аргументы мы хотим передать по правой ссылке. И универс분сет dragging позволяет нам
[06:24.840 --> 06:29.240]  добиться целого. Давайте подумаем, что нужно сделать. Давайте я опущу момент с
[06:29.240 --> 06:31.640]  реаллокации. Понятно, что вот, при необходимости...
[06:36.780 --> 06:38.680]  происходит какая-то реаллокация. Если вдруг мне памяти не хватает,
[06:38.680 --> 06:42.200]  не хватает. Я должен выделить кусок большего размера и, соответственно, работать уже с ним.
[06:42.200 --> 06:46.720]  Давайте с момента опустим. Давайте перейдем к моменту вставки элемента в массив.
[06:46.720 --> 06:52.080]  Как отсчетить вставку элемента в массив с вот такими параметрами конструктора?
[06:52.080 --> 06:59.160]  Давайте я предложу свое решение. Вот у меня есть некоторый массив,
[06:59.160 --> 07:07.720]  буфер. И я в ячейку size записываю вот такую величину.
[07:15.720 --> 07:17.320]  Ну и тут еще делаю плюс-плюс.
[07:24.320 --> 07:29.080]  Как вам такое решение? Ну, смотрите, если у меня изначально размер вектора был
[07:29.080 --> 07:34.960]  равен size, то при добавлении нового элемента я добавляю в ячейку под номером size новый объект.
[07:34.960 --> 07:40.440]  То есть вот я тут создаю объект, записываю его вот сюда, ну и затем увеличиваю размер вектора на
[07:40.440 --> 07:42.880]  единицу. Что не так в предложенном решении?
[07:42.880 --> 07:53.440]  Да, смотрите, первая проблема в чем? Чего мы хотели? В чем смысл emplaceback?
[07:53.440 --> 07:58.600]  Смысл emplaceback? Создать объект сразу же в нужном месте в памяти, так?
[07:58.600 --> 08:08.880]  А что тут за операция используется? Да, это присваивание, согласны? Это не конструктор, это
[08:08.880 --> 08:15.680]  присваивание. То есть я сначала создаю объект, а потом вызываю присваивание вот в эту ячейку в памяти.
[08:15.680 --> 08:20.480]  Понятно? От проблемы я не избавился. То есть я напомню, что emplaceback нужен был для того,
[08:20.480 --> 08:25.000]  чтобы мы могли избавиться от лишнего перемещения и лишнего копирования. Вот тут от лишнего
[08:25.000 --> 08:28.480]  перемещения и копирования мы не избавляемся. Да, почему? Потому что тут мы создаем временный
[08:28.480 --> 08:31.680]  объект, а потом его либо копируем, либо перемещаем в эту ячейку. Ну, зависит от того,
[08:31.680 --> 08:39.800]  есть ли у меня у класса T перемещающий присваивание или нет. Согласны? Вот, то есть я не решил ту
[08:39.800 --> 08:44.600]  проблему, которую ставил изначально. Я бы хотел, чтобы этот объект сразу же оказался в этой ячейке,
[08:44.600 --> 08:50.480]  а не посредством присваивания какого-то. Понятно? То есть вот смотрите, вот тут чего бы я хотел. Я бы
[08:50.480 --> 08:54.840]  хотел каждую отдельную ячейку удалять по отдельности. А вот тут я бы хотел каждую отдельную ячейку
[08:54.840 --> 09:01.320]  создавать тоже по отдельности. Понятно? Но пока такого я делать не могу. Хорошо. На самом деле,
[09:01.320 --> 09:11.400]  это не все проблемы. Какая-то еще проблема есть. Да. В каком плане уничтожение мусора?
[09:11.400 --> 09:20.880]  Понятное дело, если есть такая ячейка, то предполагаю, что там хранится какой-то
[09:20.880 --> 09:27.160]  корректный объект. Но тут другой вопрос, что у элемента может не быть конструктор по умолчанию,
[09:27.160 --> 09:31.840]  поэтому непонятно, как мы изначально вообще этот объект создали. Давайте предположим,
[09:31.840 --> 09:36.000]  что там конструктор по умолчанию есть, и присваивание тоже работает корректно,
[09:36.000 --> 09:41.040]  то есть присваивание все очищает. Давайте вспомним прошлое занятие. Что тут не хватает?
[09:41.040 --> 09:51.720]  СТД forward. Смотрите, у меня вот этот конструктор T, вот когда я ему передаю ARX. ARX это переменные.
[09:51.720 --> 09:57.840]  Когда я передаю переменные, что я передаю? Я всегда передаю lvalue. Чего бы я хотел? Я бы хотел,
[09:57.840 --> 10:01.880]  чтобы если меня в качестве какого-то аргумента передали lvalue, я хотел бы и дальше передать
[10:01.880 --> 10:05.360]  lvalue. А если меня в качестве какого-то аргумента передали rvalue, я бы хотел и дальше передать
[10:05.360 --> 10:12.440]  rvalue. То есть, точнее, STD move вот этого аргумента. Как мне этого достичь? Используйте STD forward.
[10:12.440 --> 10:19.160]  То есть, так как я принял тут все по универсальной ссылке, то и дальше я должен передавать с помощью
[10:19.160 --> 10:32.040]  STD forward, чтобы сохранить категорию значения, которое передавалось мне сюда. ARX, в круглых скобках,
[10:32.040 --> 10:48.440]  ARX и многоточие. Проблема обрисована. Непонятно, как удалять отдельные ячейки массива не удаляя
[10:48.440 --> 10:53.400]  весь массив целиком. И непонятно, как создать элемент в ячейке массива, не создавая там массив
[10:53.400 --> 10:58.160]  целиком. Понятно? То есть, можно ли работать с отдельными ячейками массива и создавать и удалять
[10:58.160 --> 11:11.800]  объекты посредством конструкторов и деструкторов. Давайте пойдем к достижению этого
[11:11.800 --> 11:19.400]  результата. Для начала давайте посмотрим на несколько демонстраций, просто чтобы понять,
[11:19.400 --> 11:23.400]  как удосовериться, что все понимают, как работает vector. Первая демонстрация очень
[11:23.400 --> 11:28.520]  простая. Тут просто нам демонстрируется какая-то самая разница между size и capacity. Не знаю,
[11:28.520 --> 11:47.440]  стоит на ней долго задерживаться или нет, но давайте. Да, давайте. Нормально? Ну, окей.
[11:47.440 --> 12:04.760]  Так, запустим программу. Видим, что вместимость и размер вектора не одно и то же. То есть,
[12:04.760 --> 12:08.200]  когда я добавляю элементы в вектор, у меня размер всегда увеличивается на единицу. То есть,
[12:08.200 --> 12:12.480]  я добавляю новый элемент, новый элемент, новый элемент. Но при этом вместимость в вектор растет
[12:12.480 --> 12:16.920]  нелинейным образом. Вместимость всегда больше равна, чем размер вектора. Мы видим,
[12:17.040 --> 12:23.840]  что тут на 8 вставок всего 4 переведеления памяти. Как правило, вместимость вектора
[12:23.840 --> 12:29.840]  увеличивается в полтора-два раза, чтобы прошло достаточное время между двумя последовательными
[12:29.840 --> 12:38.760]  переведелениями памяти. Следующая демонстрация про резеров, про разницу между resize и резер.
[12:38.760 --> 12:43.520]  Напомню, что resize меняет сам размер вектора. Размер вектора именно в том смысле,
[12:44.440 --> 12:49.200]  количество элементов, в котором в нем реально хранится. Я хочу сказать, что в векторе теперь
[12:49.200 --> 12:53.080]  хранится 100 элементов или векторе хранится 5 элементов. А резерв управляет непосредственно
[12:53.080 --> 12:58.680]  хранилищем вектора. То есть, сколько элементов потенциально может вместить вектор без переведеления
[12:58.680 --> 13:03.520]  памяти. Трюк заключается в том, чтобы, если вдруг вам заранее известно количество элементов,
[13:03.520 --> 13:08.240]  которое будет храниться в векторе. Классическая история, когда вы создаете пустой вектор,
[13:08.240 --> 13:13.480]  а потом просто в цикле заполняете его с помощью pushback. Понятное дело, что pushback в амортизованном
[13:13.480 --> 13:19.120]  смысле работает за отъязнице. Этот цикл отработает за линейное время, все хорошо. Но если вы заранее
[13:19.120 --> 13:23.680]  знаете, что у вас в векторе будет храниться n элементов, возникает вопрос, зачем вам лишнее
[13:23.680 --> 13:27.200]  переведеление памяти. Мы уже с вами понимаем, что если мы добавляем элементы в вектор, то в какой-то
[13:27.200 --> 13:31.640]  момент вектор переполнится, и он перевыделит память, и будет дальше стрелять элементы.
[13:32.640 --> 13:37.000]  Чтобы не происходило лишних переведелений памяти, мы можем с их экономить с помощью операции
[13:37.000 --> 13:42.760]  резеров. Мы говорим, давайте сначала зарезервируем память под хранение n элементов, а уже потом будем
[13:42.760 --> 13:49.680]  эти самые элементы вставлять в вектор. Тут демонстрация, которая проверяет время работы
[13:49.680 --> 13:55.080]  двух функций. Первая функция работает без использования резерва, вторая функция вставляет
[13:55.080 --> 14:00.640]  n элементов с использованием резерва. Сначала я делаю резерв, а потом же вставляю n элементов.
[14:00.640 --> 14:06.400]  Давайте посмотрим, к чему это приведет.
[14:06.400 --> 14:34.160]  Видно, что в целом с резервом программа работает примерно в полтора-два раза быстрее, чем без использования резерва.
[14:34.160 --> 14:42.640]  Резерв на самом деле в полтора-два раза увеличивает скорость программы, потому что при переведении
[14:42.640 --> 14:47.240]  памяти вектору необходимо брать все элементы и перекопировать их в новый буфер. Но это требует
[14:47.240 --> 14:55.760]  примерно в два раза больше времени, чем без использования перелокации памяти. Поэтому стоит
[14:55.760 --> 15:02.560]  активно пользоваться резервом, это ваш друг. Традиционно я показываю некоторый анекдот,
[15:02.560 --> 15:10.480]  который я видел достаточно давно. Когда-то давно, когда мне еще было время смотреть на
[15:10.480 --> 15:22.080]  работы студентов, я заметил одну вещь. Вот такая реализация вставки элементов вектор. Что тут
[15:22.080 --> 15:27.640]  происходит? Содается пустой вектор, а дальше в цикле резервируется память под vsize плюс один
[15:27.640 --> 15:33.240]  элемент, и дальше вставляется элемент один. Что этим кодом хотел сказать студент? Перед тем,
[15:33.240 --> 15:37.080]  как вставить элемент, мне нужно гарантировать, что перед вставкой нового элемента мне будет
[15:37.080 --> 15:42.160]  достаточно памяти, чтобы его вставлять. Поэтому строчка v.reserve vsize плюс один выглядит довольно
[15:42.160 --> 15:47.240]  таки разумно. Давайте я скажу вектор сначала убедить, что тебе хватит памяти для хранения
[15:47.240 --> 15:51.600]  size плюс одного элемента, а потом этот элемент вставь. Но в чем тут проблема?
[15:51.600 --> 16:00.240]  Да, проблема в том, что если изначально у вектора была вместимость 0, путем вызова
[16:00.240 --> 16:05.160]  reserve 0 плюс 1, он выделил память для одного элемента. Потом при вставке второго элемента выделил
[16:05.160 --> 16:09.600]  память для двух элементов, дальше для трех, для четырех, для пяти и так далее. То есть на самом
[16:09.600 --> 16:20.600]  ли вместо ускорения получается значительная просадка. Давайте уменьшим количество данных,
[16:20.600 --> 16:35.000]  и запустим. В общем видно, что с резервом и без резервов все отработал, например,
[16:35.000 --> 16:42.160]  за 100 тысячные доли секунды. Слабая реализация отработала за 10 тысячные доли, но если увеличить
[16:42.160 --> 16:52.560]  данные, то разница будет еще более заметна. Тоже какие-то доли секунды по сравнению с уже сотыми
[16:52.560 --> 16:59.960]  долями секунды. Необходимо понимать, как устроена динамическая реаллокация, как устроен
[16:59.960 --> 17:07.560]  резерв, чтобы не выпускать таких проблем. В общем, если вы не знаете, как пользоваться резервом,
[17:07.560 --> 17:14.840]  то лучше довериться вектору, и он самостоятельно все сделает. Ну и наконец последний пункт, который уже
[17:14.840 --> 17:19.040]  непосредственно связан с тем, что мы только что обсуждали. Как раз какие-то самые разницы между
[17:19.040 --> 17:27.520]  резервом и resize. Напомню про что мы говорили. На самом деле resize вектора устроен не совсем так,
[17:27.520 --> 17:32.280]  точнее совсем не так, как resize для строки. Для resize строки вам достаточно всего лишь поменять
[17:32.280 --> 17:37.280]  значение поля в строке. То есть сказать, что size равен сотне или там size равен двум, и так далее.
[17:37.280 --> 17:42.080]  Для вектор это не так, потому что потенциально, если вы будете поступать таким образом, у вас
[17:42.080 --> 17:47.440]  потенциально в памяти будут висеть какие-то большие куски памяти, большие объекты, которые будут
[17:47.440 --> 17:54.480]  занимать большое место и тратить ресурсы вашей системы. Поэтому на самом деле resize выполняет
[17:54.480 --> 18:12.400]  не тривиальную работу. Давайте на нее посмотрим. В чем состоит демонстрация? У меня есть
[18:12.400 --> 18:16.600]  некоторая структура или класс, которая умеет сообщать о том, когда он создается и когда он
[18:16.600 --> 18:21.200]  удаляется. То есть при вызове конструктора по умолчанию вызывается, ну печатается на экран
[18:21.200 --> 18:25.480]  конструктора, при вызове деструктора печатается на экран destroy. То есть при создании объекта,
[18:25.480 --> 18:30.000]  то есть объекты сообщают о том, когда они созданы, когда они были созданы, когда они были уничтожены.
[18:30.000 --> 18:34.080]  Дальше у меня есть вектор, и соответственно с вектором я совершаю буквально четыре операции.
[18:34.080 --> 18:38.440]  Первая операция – это операция reserve. То есть я говорю вектор и зарядирую память под хранение 100
[18:38.440 --> 18:44.440]  элементов. Дальше скажу вектору сделай resize на 5 элементов, то есть добавь 5 элементов вектор,
[18:44.440 --> 18:49.320]  потом скажу вектору избавься от последних трех элементов, ну и в конце скажу вектор очистить свою
[18:49.320 --> 18:59.680]  память. Давайте посмотрим, к чему это все привело. Давайте наблюдать забавные вещи. Смотрите,
[18:59.680 --> 19:05.880]  когда я сделал reserve 100, что произошло? После вызова reserve 100 реально не было создано ни одного
[19:05.880 --> 19:15.600]  объекта типа S. Понятно? То есть я вызвал reserve 100, но при этом реально было создано 0 объектов. То есть
[19:15.600 --> 19:23.880]  что произошло? Память была выделена, но объектов никаких в векторе создана не было. То есть reserve
[19:23.880 --> 19:29.920]  реально управляет только памятью, но не созданием самих объектов. Поэтому когда вы делаете reserve,
[19:29.920 --> 19:33.680]  создание никаких объектов на самом деле не происходит. Reserve выделяет просто-напросто память,
[19:33.680 --> 19:37.320]  ну вот просто-напросто нужное количество байт, чтобы можно было сохранить нужные элементы.
[19:37.320 --> 19:42.880]  Что происходит дальше? Дальше вызываю resize от 5. После вызова resize от 5, вот только после этого,
[19:43.560 --> 19:48.520]  как я сказал, что вектор должен хранить 5 реальных объектов, начинаются создаваться те самые объекты
[19:48.520 --> 19:56.920]  на нужных участках памяти. Вот сейчас все были вызваны 5 конструкторов по умолчанию. Вот что
[19:56.920 --> 20:01.000]  произошло после того, как вызвали resize 2? Смотрите, опять же, я напоминаю, что если бы мы работали
[20:01.000 --> 20:05.920]  в парадигме строки, то нам было достаточно просто-напросто ставить равно 0 и все. И здесь же,
[20:05.920 --> 20:12.240]  помимо того, что size выставляется в значении равном 2, вызываются 3 деструктора. То есть
[20:12.240 --> 20:19.040]  ненужные элементы удаляются. Этот элемент удалился, этот и этот. То есть в векторе реально хранится
[20:19.040 --> 20:23.880]  ровно два объекта. Ну и, понятное дело, после вызова метода clear остальные элементы тоже
[20:23.880 --> 20:34.640]  уничтожаются. Ну и собственно наша цель на сегодня научиться этим самым трюкам, научиться делать так,
[20:34.640 --> 20:40.680]  чтобы в той памяти, которую вы выделили, можно было отдельно удалять элементы, отдельно создавать
[20:40.680 --> 20:52.240]  элементы. В общем, вручную управлять временем жизни объектов. Есть ли вопросы по демонстрациям?
[20:52.240 --> 21:07.040]  Окей, тогда давайте начнем. Первый вопрос на ваших экранах. Вам представлены три операции или три
[21:07.040 --> 21:19.000]  выражения? newt, newt.xy, newt.n. Кто делает эти три операции? Давайте начнем с первой. Вот я вызываю newt.
[21:19.000 --> 21:32.400]  Что при этом происходит в вашей программе? Так, создается объект. А где он создается? Так, ну смотрите,
[21:32.400 --> 21:37.960]  чтобы у меня была динамическая память, нужно, чтобы ее мне кто-то отдал. Да? Откуда она у меня
[21:37.960 --> 21:49.000]  берется? Ну, то есть смотрите, что на самом деле делает newt? newt делает две вещи. Первое,
[21:49.000 --> 22:01.040]  запрашивает операционную систему и динамическую память, так? То есть выделяем память. Все.
[22:01.160 --> 22:13.360]  Операционная система или мой менеджер памяти мне выдал size of tab by памяти. То есть он сказал,
[22:13.360 --> 22:19.200]  вот это моя память, но в ней пока ничего не лежит. Просто в ней заполнен какой-то мусор. Хорошо,
[22:19.200 --> 22:34.200]  что происходит дальше? Да, дальше создается t по умолчанию. То есть тут создается объект
[22:34.200 --> 22:40.400]  с пустыми круглыми скобками. Вот. Окей. Теперь вторая строчка отличается от первой.
[22:40.400 --> 22:55.160]  New t xy делает ровно то же самое, но только во втором пункте создается t с параметром x и y.
[22:55.160 --> 23:01.000]  Согласны? То есть разница между первой и второй строчки заключается всего лишь в том, что в первом
[23:01.000 --> 23:04.880]  случае создается t по умолчанию, во втором случае создается t с параметром x и y. При этом первый
[23:04.880 --> 23:10.480]  пункт остается неизменным. То есть программе обязательно нужно выделить память для хранения
[23:10.480 --> 23:24.920]  вот этого самого объекта. Так, ну и наконец третий пункт. Так. Да. То есть выделяется память для
[23:24.920 --> 23:40.840]  хранения n элементов типа t. Вот size of t x n. Затем вызывается n конструкторов по умолчанию. Вот. То
[23:40.840 --> 23:48.520]  есть вызов выражения new неизбежно приводит всегда к двум вещам. Первое это выделение памяти,
[23:48.520 --> 23:54.400]  второе это вызов конструкторов. Окей? Так. Тут может возникнуть следующий вопрос. Смотрите,
[23:54.400 --> 24:04.920]  когда я делаю резер, вот я делаю v точка. Резер 100. Ну смотрите, вектор же тоже выделяет память,
[24:04.920 --> 24:10.480]  так? Но при этом помните прошлую демонстрацию. Что мы видели? Мы видели, что при вызове резер
[24:10.480 --> 24:17.840]  ни одного конструктора вызова не было. То есть как будто второй пункт пропускается. Как так? В общем,
[24:17.840 --> 24:26.120]  как непонятно. Ну будем разбираться. В общем, вызов стандартного выражения new приводит к тому,
[24:26.120 --> 24:29.960]  что у вас выделяется память, а потом по этой памяти создается объект, ну или несколько объектов,
[24:29.960 --> 24:36.080]  в зависимости от того, какую версию new с квадратными скобками или без квадратных скобок вы вызываете.
[24:36.080 --> 24:40.880]  Вот. Соответственно, тут возникают два вопроса. То есть так как new обязательно приводит к вот этим
[24:40.880 --> 24:45.000]  двум пунктам, собственно, вопросы следующие. А можно ли выполнить только первый пункт без второго?
[24:45.000 --> 24:49.680]  Можно ли как вектор просто выделить память, но при этом не создавать там никаких объектов? Ну и наконец
[24:49.680 --> 24:53.920]  второй вопрос. А вот допустим, у меня откуда-то память есть. Ну вот откуда-то. Просто спустилось
[24:53.920 --> 25:03.120]  небес. Можно ли вот в этой памяти создать какой-то объект t? Какой я хочу? Так. Собственно, давайте
[25:03.120 --> 25:08.880]  разбираться с этими вопросами и ответим на первый из них. Можно ли выделить память,
[25:08.880 --> 25:21.560]  не создавая там никакого объекта? Ответ да, но с некоторыми нюансами. Давайте пойдем в
[25:21.560 --> 25:28.840]  хронологическом порядке. Значит, давайте вспомним язык c. Вот. Точнее сделаем небольшой обзор язык
[25:28.840 --> 25:36.200]  c. Вот. Понимаете, в языке c нет никаких операций new и delete. Вот. В языке c для выделения памяти
[25:36.200 --> 25:49.600]  используется функция, которая называется stdmalloc. А для очищения памяти используется функция stdfree.
[25:49.600 --> 25:55.200]  Вот. В чем особенность этих функций? Особенность функции stdmalloc заключается в том, что эта
[25:55.200 --> 26:01.640]  функция тупо выделяет память в том объеме, который вам нужно. То есть stdmalloc это функция,
[26:01.640 --> 26:06.240]  которая принимает на вход количество байт, которое нужно выделить в памяти. Вот. При этом эта
[26:06.240 --> 26:09.640]  память просто, при этом эта память, ну, собственно, является просто, например, с некоторым набором байт,
[26:09.640 --> 26:16.400]  которая ничем изначально не заполнена. Вот. То есть stdmalloc, на самом деле, абсолютно ничего не знает
[26:16.400 --> 26:22.680]  про типы, которые вы будете хранить по этому месту в памяти. Вот. Поэтому ответ на вопрос, можно ли
[26:22.680 --> 26:28.640]  просто-напросто выделить память, не создавая никаких объектов, ответ на этот вопрос утвердительный.
[26:28.640 --> 26:33.440]  Ну, например, про использование функции stdmalloc. Вот. Ну и, соответственно, есть функция stdfree,
[26:33.440 --> 26:38.720]  которая вызывается по указателю, для которого вы изначально вызывали malloc. Ну и, соответственно,
[26:38.720 --> 26:46.640]  он ощущает, ощущает эту самую память. Вот. У malloc есть проблема. Ну и, собственно, одна из, одна из
[26:46.640 --> 26:50.000]  проблем, как раз таки, заключается в том, что stdmalloc ничего не знает про типы данных. Да, вообще,
[26:50.000 --> 26:53.840]  то есть, когда вы говорите, что нужно выделить какую-то память, stdmalloc возвращает вам указатель
[26:53.840 --> 26:57.360]  на бой. Ну потому что он не знает, что вы там будете хранить. Поэтому, если вдруг, там, вы по этому
[26:57.360 --> 27:01.040]  адмису памяти захотите хранить int, то прежде чем использовать эту память, вам нужно сделать,
[27:01.040 --> 27:06.720]  грубо говоря, static cast вот этой самой памяти к int указателю. Вот. Ну и плюс, на самом деле, malloc
[27:06.720 --> 27:11.040]  очень хорошо дружатся new и derit, но можно считать, что они просто-напросто используют, в общем,
[27:11.040 --> 27:16.040]  они используют разные стратегии выделения памяти, и поэтому смешивать их там с C++ стилем
[27:16.040 --> 27:21.080]  выделения памяти не стоит. Это вот чистый экскурсс историю. Значит, вопрос следующий. Можно ли добиться
[27:21.080 --> 27:28.200]  примерно того же, что и malloc и free в языке C++? То есть используя чистый инструмент C++. Значит, ответ
[27:28.200 --> 27:34.120]  тоже да. Значит, можно сделать следующим образом. Ну, смотрите, что мы знаем? Мы знаем, что когда я
[27:35.080 --> 27:42.400]  выделяю память с помощью new, у меня выделяется память и создается объект по умолчанию. Вот. Ну,
[27:42.400 --> 27:47.320]  собственно, вопрос, можно ли просто выделить память, не создавая никакого объекта? Ну, давайте применим
[27:47.320 --> 27:53.920]  следующий трюк. Давайте просто-напросто выделим память и будем выделять ее не как память для
[27:53.920 --> 27:59.920]  конкретного объекта, а будем выделять память, допустим, для char. Ну, char не занимает один byte,
[27:59.920 --> 28:04.240]  поэтому сколько чаров я выделю, столько byte там будет храниться вот в этом месте памяти. Или,
[28:04.240 --> 28:09.160]  собственно, в языке, ну, в стандарте языка C++17 появился такой тип, как std byte. Ну, std byte,
[28:09.160 --> 28:13.800]  на самом деле, это просто-напросто, по-моему, псевдоним для char или unsan char. Ну, в общем,
[28:13.800 --> 28:19.120]  так или иначе, std byte хранит в себе всего лишь один byte, поэтому, если я выделяю массив из size2t
[28:19.120 --> 28:23.720]  byte, то как раз-таки у меня выделится память для хранения одного элемента типа T. Ну, или если
[28:23.720 --> 28:28.280]  я выделю память для хранения size2t умножить на n byte, у меня будет достаточно памяти для хранения n
[28:28.280 --> 28:32.120]  элементов типа T. Ну, в общем, так или иначе, трюк заключается в следующем. Давайте я просто-напросто
[28:32.120 --> 28:37.080]  выделю массив из char или массив из byte, и вот этот массив byte буду использовать в дальнейшем как
[28:37.080 --> 28:43.520]  там массив для хранения объектов типа T. Понятно? То есть, если я выделю память для хранения массива
[28:43.520 --> 28:50.480]  byte или для хранения массива char, то я всего лишь выделю память, а потом уже в дальнейшем по этому
[28:50.480 --> 28:57.400]  месту в памяти могу создать какой-нибудь объект. Окей? Вот. В чем проблема такого подхода? Ну,
[28:57.400 --> 29:03.040]  проблема такого подхода масса, и на самом деле такой подход на практике не используется. Почему?
[29:03.040 --> 29:09.080]  Потому что, по следующим причинам, когда вы вызываете new std byte от чего-то, а понятное дело,
[29:09.080 --> 29:15.200]  что new возвращает вам указатель на, собственно, std byte или new возвращает указатель на char. Вот.
[29:15.200 --> 29:19.880]  Чтобы получить из этого указателя указатель на нужный вам тип, ну, в частности, тут приводится
[29:19.880 --> 29:24.520]  все указатель на void, вы должны применить к нему статикаст или какой-нибудь другой каст,
[29:24.520 --> 29:29.880]  который вам нужен. Вот. Это первая проблема. Вторая же проблема заключается в следующем. Смотрите,
[29:29.880 --> 29:33.680]  мы с вами говорили о том, что для любой памяти, которая выделена с помощью new, нужно вызвать
[29:33.680 --> 29:38.720]  соответствующий delete. Вот. Поэтому, если вы выделяли память с помощью new std byte и так далее,
[29:38.720 --> 29:45.200]  то вам нужно очистить память тоже с помощью delete. Вот. Но проблема тут заключается в следующем.
[29:45.200 --> 29:54.360]  В delete вы обязаны подать указатель именно того типа, который выделяли с помощью new. Ну,
[29:54.360 --> 30:05.520]  пример. Вот. Допустим, вы выделили память new a. Но при этом сохранили указатель на a. Давайте тут
[30:05.520 --> 30:26.520]  какой-нибудь статикаст. Я скастовал это все, допустим, к моему указателю. Вот. А потом пишу
[30:26.520 --> 30:37.480]  delete p. В чем тут проблема? Проблема в том, что new на самом деле выделал память для хранения
[30:37.480 --> 30:44.240]  элементов типа a. Вот. И new ему как-то сохранить эту информацию для того, что, например, потом delete
[30:44.240 --> 30:49.440]  было понятно, а сколько byte нужно удалять, что какой объект нужно удалять и так далее. Ну,
[30:49.440 --> 30:58.200]  а если вы в delete подойдите к указателю p, который на самом деле имеет тип 8 с звездой, то у delete
[30:58.200 --> 31:03.840]  будет практически ноль шансов понять, что на самом деле по этому указателю лежит объект a. Понятно?
[31:03.840 --> 31:09.520]  То есть delete на самом деле опирается на тип самого указателя, которого вы удаляете. Если delete
[31:09.520 --> 31:13.320]  видит перед собой указатель на a, тогда он будет удалять этот объект как объект типа a. Если он
[31:13.320 --> 31:19.120]  перед собой видит указатель на b, тогда он будет удалять этот указатель как объект типа b и так
[31:19.120 --> 31:25.200]  далее. Вот. Поэтому если вы изначально выделяете память с помощью new std byte и так далее, то и удаляете
[31:25.200 --> 31:30.000]  указатель вам тоже нужно как указатель на std byte. Вот. Поэтому перед тем, как делать delete, вам
[31:30.000 --> 31:38.640]  необходимо будет сделать кстати cast std byte со звездой от там single или от array. Понятно? Вот. То есть
[31:38.640 --> 31:43.280]  один из входных путей, один из входных путей, то есть как выделить память, но не создавать при этом
[31:43.480 --> 31:51.560]  объекта, это использовать new от там стимульного типа, то есть char или new от std byte. Но при
[31:51.560 --> 31:56.080]  этом у этого есть много недостатков и на самом деле такой подход тоже никак не используется. Вот.
[31:56.080 --> 32:07.680]  Какой подход используется на самом деле? Давайте познакомимся с функцией оператор new. Значит,
[32:07.680 --> 32:21.960]  в gt++ есть функция, которая называется оператор new. Вот именно оператор new в два слова. Вот.
[32:21.960 --> 32:30.200]  Что это за функция? Оператор new ведет себя похожим образом, как и домолог. Оператор new в качестве
[32:30.200 --> 32:36.560]  своего аргумента принимает количество byte, которое нужно выделить и по которому нужно получить
[32:36.560 --> 32:44.880]  указатель. Окей? То есть если мне нужно выделить память достаточную для хранения size of t byte,
[32:44.880 --> 32:49.760]  то я вызываю оператор new от size of t. Если мне нужно выделить количество byte достаточно для
[32:49.760 --> 32:54.760]  хранения n элементов типа t, то я вызываю оператор new с size of t умножить на n. Вот. При этом оператор
[32:54.760 --> 33:06.800]  new возвращает void со звездой, принимает size of t и количество byte, которое нужно выделить. Вот.
[33:06.800 --> 33:20.600]  Окей. Значит, у оператора new есть антипод, который называется оператор delete. Это тоже функция. Эта
[33:20.600 --> 33:26.040]  функция является в некотором смысле аналоговым функциям SD-free. Оператор delete принимает указатель,
[33:26.040 --> 33:37.640]  ранее выделенный с помощью оператора new, ну и выполняет очищение памяти. Вот. В чем особенность
[33:37.640 --> 33:41.520]  этих функций? В чем особенность функции оператор new и оператор delete? В чем преимущество перед
[33:41.520 --> 33:46.880]  stmolok и stfree? Несмотря на то, что они по синтаксису очень сильно похожи, то есть stmolok и std и
[33:46.880 --> 33:51.360]  оператор new принимают количество byte, которое нужно выделить, stdfree и оператор delete принимают
[33:51.360 --> 33:57.200]  указатель, который нужно очистить. Вот. Оператор new и оператор delete максимально согласованы с
[33:57.200 --> 34:03.440]  обычными выражениями new и delete, которые приняты в UTS++. Они настолько согласованы, что на самом деле,
[34:03.440 --> 34:13.040]  когда вы вызываете new, когда вы вызываете new от t, выделение памяти, вот этот самый первый шаг,
[34:13.040 --> 34:22.320]  происходит как раз таки с помощью вот этой самой функции оператор new. Вот. То есть на самом деле,
[34:22.320 --> 34:29.160]  на самом деле, давайте еще раз повторю, когда вы вызываете new t, ну там допустим какие-то параметры x и y,
[34:29.160 --> 34:36.040]  первым делом компилятор вызывает вот эту функцию. Первым делом компилятор вызывает функцию оператор
[34:36.040 --> 34:41.640]  new, которая выделяет столько byte сколько вам нужно и возвращает указатель на эту самую динамическую
[34:41.640 --> 34:50.160]  память. Окей? Вот. То есть мораль. Выделение памяти происходит с помощью специальной функции,
[34:50.160 --> 34:56.320]  которая называется оператор new. Вот. Поэтому если вам необходимо выделить память, не создавая объект,
[34:56.320 --> 35:03.120]  то вы можете вызвать функцию оператор new и вы получите тот эффект, который вы хотите. То есть
[35:03.120 --> 35:10.080]  без создания какого-либо объекта, просто нам выделится нужное количество byte. Вот. Окей. Так.
[35:10.080 --> 35:17.440]  Кажется, мы не поговорили про delete. Давайте исправимся. Про него тоже скажем несколько слов.
[35:17.440 --> 35:33.600]  Что происходит, когда я вызываю delete p? Да. Первым шагом вызывается инструктор,
[35:33.600 --> 35:51.360]  а вторым шагом освобождается память. Ну и давайте ли полноты пропишем, что происходит,
[35:51.360 --> 36:11.920]  когда я вызываю delete с квадратными скобками. Ну, на первом шаге вызывается n деструкторов,
[36:11.920 --> 36:25.520]  и во втором шаге освобождается память. Так вот освобождение памяти происходит с помощью функции
[36:25.520 --> 36:37.400]  оператор delete. Вот. То есть на самом деле под капотом, когда вы вызываете выражение new,
[36:37.400 --> 36:44.120]  первым делом вызывается функция оператор new. Когда вы вызываете delete, первым делом вызывается
[36:44.120 --> 36:50.960]  деструктор, а потом вызывается функция оператор delete. Понятно? Вот. Если вам не нужно вызова
[36:50.960 --> 36:55.560]  конструктора или если вам не нужно вызова деструктора, вы можете просто вызывать оператор delete или
[36:55.560 --> 37:07.160]  оператор new. Окей? Сам по себе оператор delete просто-напросто освобождает память. Ну, когда вы
[37:07.160 --> 37:11.680]  вызываете new, вам операционная система выделяет память искучен, то есть как, скажем, свободную
[37:11.680 --> 37:17.560]  память, которая есть в системе. Вот. А оператор delete эту память возвращает обратно. Говорит,
[37:17.560 --> 37:34.920]  что все, эта память ей не нужна. Окей? Так. Есть ли вопросы? Окей. Так. Ну, собственно, да. По аналогии
[37:34.920 --> 37:38.840]  с функциями оператор new и оператор delete, есть также функция оператор new с квадратными скобками и
[37:38.840 --> 37:44.320]  оператор delete с квадратными скобками. Ну, я надеюсь, вы понимаете, что соответствующие функции вызывают,
[37:44.320 --> 37:54.680]  когда вы вызываете new с квадратными скобками, когда вызываете new takes p от n,
[37:54.680 --> 38:03.480]  и когда вызываете delete с квадратными скобками nodep. Вот. То есть, когда вызываете u без
[38:03.480 --> 38:08.120]  квадратных скобок, то вызывается функция оператора new без квадратных скобок, а когда вызываете
[38:08.120 --> 38:11.680]  u с квадратными скобками, вызывается функция оператора new с gelatinous скобками. Ну, и
[38:11.680 --> 38:14.020]  Та же самая социальность с оператором delete.
[38:14.020 --> 38:18.820]  Тут может быть один вопрос, а зачем вообще нужны две версии функции?
[38:18.820 --> 38:25.320]  Зачем нужна версия оператора new с квадратными скобками, зачем нужна версия new без квадратных скобок?
[38:25.320 --> 38:34.080]  Идея заключается в том, что вот этому delete, когда он будет вызван,
[38:34.080 --> 38:38.080]  ему нужна какая-то информация о том, а сколько элементов на самом деле там хранится под указателем,
[38:38.080 --> 38:40.080]  то есть сколько деструкторов ему вызывать.
[38:40.080 --> 38:45.080]  И на самом деле оператор new с квадратными скобками выделяет не ровно n byte,
[38:45.080 --> 38:50.080]  а выделяет чуть больше памяти для того, чтобы оператору delete было понятно,
[38:50.080 --> 38:52.080]  сколько потом деструкторов нужно будет вызывать.
[38:52.080 --> 38:58.080]  Но это чисто деталь реализации, это деталь компиляторов,
[38:58.080 --> 39:04.080]  которая зависит от конкретной реализации, то есть не документирована стандартом.
[39:04.080 --> 39:09.080]  В общем, важно понимать то, что при вызове обычного new вызывается функция оператора new
[39:09.080 --> 39:13.080]  без квадратных скобок, а при вызове new с квадратными скобками вызывается new с квадратными скобками.
[39:13.080 --> 39:15.080]  Та же самая история с delete.
[39:15.080 --> 39:17.080]  Окей?
[39:17.080 --> 39:19.080]  Да.
[39:25.080 --> 39:29.080]  Нет, у меня кажется, да, тут есть демонстрация, давайте посмотрим.
[39:29.080 --> 39:31.080]  Так.
[39:31.080 --> 39:37.080]  Вот, смотрите, тут демонстрация, я выделяю память с помощью new,
[39:37.080 --> 39:42.080]  вот, и дальше делаю вещь, которую на самом деле с C++ делать нельзя,
[39:42.080 --> 39:47.080]  ну в смысле по стандарту, вот, но я рискнул, вот, и все получилось.
[39:47.080 --> 39:52.080]  В общем, в некоторых реализациях, то есть большинство реализаций компиляторов с C++,
[39:52.080 --> 39:56.080]  они хранят вот эту самую информацию о том, сколько элементов было выделено с помощью new
[39:56.080 --> 39:59.080]  в ячейке, которая находится позади от массива.
[39:59.080 --> 40:06.080]  То есть, например, когда вы вызываете new t от n,
[40:06.080 --> 40:09.080]  а что при этом происходит?
[40:09.080 --> 40:14.080]  Выделяется память для хранения n элементов, но на самом деле, на самом деле выделяется не...
[40:14.080 --> 40:17.080]  Ну на самом деле выделяется не только эта память,
[40:17.080 --> 40:23.080]  на самом деле выделяется памяти на 8 байт больше, чем вам нужно, вот,
[40:23.080 --> 40:26.080]  а что хранится вот в этих дополнительных 8 байтах?
[40:26.080 --> 40:29.080]  Вот в этих дополнительных 8 байтах кратк pays хранится информация о том,
[40:29.080 --> 40:31.080]  колька элементов у вас было выделено.
[40:31.080 --> 40:33.080]  То есть, тут на самом деле хранится вот это самое число n, вот,
[40:33.080 --> 40:38.520]  new возвращает вам указатель вот на эту ячейку памяти, то есть new с квадратными скобками
[40:38.520 --> 40:42.920]  выделяет вам памяти на 8 и больше, возвращает указатель вот на начало вот этого куска кода,
[40:42.920 --> 40:48.320]  а потом когда вы вызываете delete, delete уже смотрит вот сюда, понимая сколько элементов тут на самом
[40:48.320 --> 40:54.920]  деле находится и для всех них вызывает деструктор, вот дальше эта память само ощущает, окей, ну давайте
[40:54.920 --> 41:00.000]  заглянем, посмотрим так ли это, ну вот я собственно выделяю память с помощью new с квадратными скобками,
[41:00.000 --> 41:11.600]  вот 6969 элементов, вот и соответственно затем кастует указатель к sizeT и говорю, что считай, что этот
[41:11.600 --> 41:18.600]  массив содержит sizeT, содержит элементы типа sizeT и посмотри на один шаг назад, какой там
[41:18.600 --> 41:30.920]  элемент хранится, это new delete, вот, ну собственно вот то самое число, если я это число буду менять,
[41:30.920 --> 41:39.840]  ну там назовите кое-нибудь, чтобы не было 37, спасибо пацанной человек, так, значит g++,
[41:39.840 --> 41:44.920]  ну вот собственно 37, то есть на самом деле new с квадратными скобками сохраняет дополнительную
[41:44.920 --> 41:49.160]  информацию, вот именно поэтому оператор new и оператор delete имеет две формы, то есть обычный
[41:49.160 --> 41:53.240]  оператор new, он эту информацию не сохраняет, оператор new с квадратными скобками, он там еще
[41:53.240 --> 41:57.200]  дополнительно сохраняет информацию о том, сколько элементов потом нужно будет удалить, ну это просто
[41:57.200 --> 42:09.520]  для функционирования там корректного удаления с помощью delete, окей, так, давайте пойдем дальше,
[42:09.520 --> 42:22.400]  теперь несколько откровений, на самом деле c++ существует не одна функция оператора new,
[42:22.400 --> 42:32.800]  на самом деле их несколько, вот, значит вот это самая стандартная форма выражения new, ну вы
[42:32.800 --> 42:37.400]  просто пишете new, дальше справа указываете объект, который нужно создать и он выделяется
[42:37.400 --> 42:45.120]  памяти, он создается, вот, но на самом деле new можно вызвать кучей разных способов, ну и соответственно
[42:45.120 --> 42:49.760]  для каждого new есть соответствующая функция оператор new, в частности, ну вот, собственно первая,
[42:49.760 --> 42:54.200]  самая первая версия оператора new, это там стандартная классическая форма new, которая, ну
[42:54.200 --> 42:58.640]  которая вызывается, когда вы используете обычный new стипом, да, то есть он просто принимает количество
[42:58.640 --> 43:03.800]  байт, которое нужно выделить, вот, ну и выделяет ровно такое же количество байт, вот, вторая форма
[43:03.800 --> 43:08.280]  оператора new принимает дополнительный параметр std off-road t, что это за параметр? Это параметр,
[43:08.280 --> 43:11.840]  который говорит просто наоборот о том, что данная операция new не должна бросать исключений,
[43:11.840 --> 43:19.720]  ну, строго говоря, про бросание исключений мы с вами не говорили, но наверняка вы, может, не сталкивались,
[43:19.720 --> 43:23.640]  но по крайней мере слышали, что произойдет, если вы попытаетесь выделить памяти больше, чем есть
[43:23.640 --> 43:33.360]  у вас в системе. То есть, когда, допустим, вы выделяете new t от, ну там, не знаю, и куча куча куча нулей, вот,
[43:33.360 --> 43:37.400]  ну возникает вопрос, что должно происходить, если new не может выделить нужное количество памяти.
[43:37.400 --> 43:43.240]  Ну, в этом случае ваши программы, скорее всего, падали, и там на экране вы видели что-то типа std
[43:43.240 --> 43:49.680]  battle log, вот, значит, это называется исключением, про исключение мы еще в рамках нашего курса поговорим,
[43:49.680 --> 43:56.640]  вот. Что означает этот параметр std null throw? std null throw говорит о том, что если вдруг у вас память,
[43:56.640 --> 44:01.440]  если вдруг операция new завершится неуспешно, то есть, если вдруг new не сможет выделить столько
[44:01.440 --> 44:07.520]  памяти, сколько вы попросили, вот этот new не должен бросить исключения, а он должен вернуть null ptr, понятно?
[44:07.520 --> 44:24.360]  Вот, то есть, если я вызываю то же самое, но вот в таком формате new std null throw, вот, то в случае,
[44:24.360 --> 44:29.240]  то в случае, если вам, если у вас на системе не хватит памяти, в общем, у вас программа не будет
[44:29.240 --> 44:33.320]  памяти, она просто будет возвращать нулевой указатель, вот, но тогда вам просто достаточно будет
[44:33.320 --> 44:48.280]  проверить, если p null ptr, то значит, не хватило памяти, и так далее, вот. Теперь смотрите, что это такое,
[44:48.280 --> 44:54.280]  что это такой синтаксис? new, дальше круглые скобки и так далее, посмотрите, в общем случае история такая,
[44:54.280 --> 45:15.120]  если я пишу new a, b, c, потом t, x, y, z, это означает следующее, первый шаг, вызвать пункцию оператор new
[45:15.120 --> 45:34.800]  с параметрами size of t, a, b, c. В общем, история следующая, на самом деле new может принимать дополнительные
[45:34.800 --> 45:40.160]  параметры, вот, и эти дополнительные параметры как раз такие будут переданы функцию оператор new,
[45:40.160 --> 45:45.760]  понятно? То есть, например, вот самая первая версия функции оператор new, она не принимает никаких
[45:45.760 --> 45:51.440]  параметров, но это, собственно, наша самая старая классическая форма вызова new, вот, то есть вызова
[45:51.440 --> 45:56.160]  new без параметров вызывается первая версия функции оператор new, которая просто принимает размер
[45:56.160 --> 46:00.800]  памяти, которую нужно выделить, вот. Вторая версия оператор new принимает один дополнительный
[46:00.800 --> 46:06.720]  параметр, вот он std not throw, да, вот то, что написано на самом верху, вот на той доске, я передаю параметр
[46:06.720 --> 46:11.760]  std not throw, и, собственно, этот параметр передается вот вторым аргументом в оператор new, вот. И,
[46:11.760 --> 46:16.120]  наконец, третья версия оператора, на самом деле, очень много, в общем, самый популярный из них мы
[46:16.120 --> 46:27.480]  перечисли здесь, третья версия, которая перечислена, она имеет такую форму. Она нам еще сегодня
[46:27.480 --> 46:45.160]  понадобится. Смотрите, если я напишу вот так, new, какой-то указатель ptr tx y, то вот эта версия
[46:45.160 --> 47:03.360]  new вызовет первая функцию оператор new от size of t и r, ну а второе, как мы с вами знаем, вызовет
[47:03.360 --> 47:14.480]  конструктор tx y. Так вот, в чем особенность вот этой самой операции new, которая принимает указатель.
[47:14.480 --> 47:24.940]  Ее особенность заключается в том, что она не выделяет память. Вот эта версия функции оператора new
[47:24.940 --> 47:30.940]  не выделяет память. Еще раз, вот первая версия оператора new выделяет count by памяти. Вторая версия
[47:30.940 --> 47:38.640]  оператора new выделяет count by памяти. Третья версия операции new не выделяет память. Все, что она делает,
[47:38.640 --> 47:43.960]  это возвращает второй указатель в качестве ответа. То есть, по сути, когда я пишу вот так, я говорю,
[47:43.960 --> 47:50.520]  не выделяй память, а просто в качестве результатов верни вот этот указатель.
[47:50.520 --> 47:56.360]  Понятно? Может показаться странным, зачем вообще такая штука нужна, но на самом деле она нам
[47:56.360 --> 48:01.000]  очень сильно понадобится буквально через несколько минут, окей? Вот, давайте
[48:01.000 --> 48:07.600]  резюмируем. Операцию new, точнее выражение new на самом деле можно вызывать с
[48:07.600 --> 48:10.520]  параметрами в круглоскопках. И вот эти параметры в круглоскопке, они будут
[48:10.520 --> 48:15.360]  передаваться в соответствующую функцию оператора new, в которую в качестве первого
[48:15.360 --> 48:19.320]  аргумента передается размер вот этого типа t, а в качестве остальных
[48:19.320 --> 48:35.000]  параметров передаются те параметры, которые передали вот сюда, окей. Нет, ну
[48:35.000 --> 48:39.400]  смотрите, как происходит, когда вы вызываете new от ABC,
[48:39.400 --> 48:44.160]  компилятор просто-напросто это переводит в следующий код. Он вызывает оператор new и
[48:44.160 --> 48:47.120]  дальше передает в качестве первого параметра size of t, а в качестве следующего
[48:47.120 --> 48:50.320]  параметра вот эти параметры. А дальше происходит обычный выбор
[48:50.320 --> 48:53.640]  перегрузки функции. То есть можно сказать, что вот эти вот функции оператора new, они
[48:53.640 --> 48:57.240]  перегружены. То есть в C++ существует много-много-много версий вот этой
[48:57.240 --> 48:59.880]  функции оператора new. И происходит обычный выбор
[48:59.880 --> 49:02.480]  перегрузки.
[49:07.480 --> 49:14.160]  Он скастуется, любой указатель может быть, короче, есть, короче,
[49:14.160 --> 49:18.840]  любой указатель не явно приводится к указателю вот этой звездой.
[49:18.840 --> 49:25.840]  А, то есть, получается, у нас будет вот ABC, где-то у нас получается какой-то доказатель,
[49:25.840 --> 49:31.960]  он сразу скастуется без указатель. Нет-нет-нет. Нет. Ну, смотрите, скорее всего, если вы
[49:31.960 --> 49:35.040]  передаете просто произвольный набор параметров, то у вас будет ошибка
[49:35.040 --> 49:37.720]  компилятора, потому что компилятор скажет, что, ну, я не знаю, потому что у меня нет
[49:37.720 --> 49:41.120]  такой версии оператора new, которая бы принимала эти три аргумента. Тут важно,
[49:41.120 --> 49:47.360]  чтобы существовала версия функции оператора new, которая
[49:47.360 --> 49:53.280]  может принимать эти три аргумента. Еще раз, у вас в стандартной библиотеке есть
[49:53.280 --> 49:57.280]  некоторый набор вот таких вот функций, которые принимает просто count, которые принимает
[49:57.280 --> 50:01.360]  count.unlpro, которые принимает count.ptr, которые принимает count.
[50:01.360 --> 50:05.120]  и размер выравнивания, и так далее, и так далее. И вот, в зависимости от того, что вы
[50:05.120 --> 50:09.160]  передали сюда, будет выбираться следующая версия функции оператора new. Если то, что вы
[50:09.160 --> 50:12.160]  передали сюда не матчится ни с одним оператором new, то он скажет, что, ну, я
[50:12.160 --> 50:26.240]  такого new не знаю. Вот. Сейчас. Вопрос. Какой из? Вот этот? Смотрите, вот этот оператор new
[50:26.240 --> 50:37.960]  это функция. Вот функция, которая называется оператор new. Вот. Вот это new. Это выражение new.
[50:37.960 --> 50:47.920]  Да, это выражение new, которое использует ключевое слово new. Вот. И, собственно, вот это выражение new, оно
[50:47.920 --> 50:54.040]  приводит к тому, что вызывается функция оператора new и вызывается конструктор. То есть, функция оператора
[50:54.040 --> 51:04.880]  new является частью выражения new. Да, выражение new возвращает указатель на t. Оператор new
[51:04.880 --> 51:15.960]  возвращает указатель. Да. Нет, оператор delete. В оператор delete вы не можете передать количество
[51:15.960 --> 51:20.440]  байт, ну, сейчас, точнее так. На самом деле, оператор delete, ну, есть версия оператора delete, которая
[51:20.440 --> 51:24.280]  принимает количество байт, но скорее, ну, стандартный оператор delete, вашу просьбу скорее всего
[51:24.280 --> 51:29.680]  проигнорирует. Вот. Потому что, если память была выделена куском размером n byte, то именно
[51:29.680 --> 51:33.920]  куском размера n byte она и будет удалена. То есть, частично освободить память нельзя. Вот. Если вы
[52:03.920 --> 52:09.600]  выделите память, вот этот ptr, это просто, короче, вот эту версию вы говорите следующее, что давай-ка
[52:09.600 --> 52:16.040]  всех обманем и выделять память на самом деле не будем, но вместо выделенной памяти вернем ptr. Вот. То
[52:16.040 --> 52:20.880]  есть, вот эта версия new памяти не выделяет. Она лишь возвращает вот этот указатель, который был
[52:20.880 --> 52:26.160]  переносит сюда. Точнее, вот эта версия оператора new, она памяти не выделяет, лишь возвращает нужный
[52:26.160 --> 52:55.080]  указатель. Так. Да. Сейчас еще раз. Какой сценарий давайте установим? Типа, я пишу new tn,
[52:55.080 --> 53:09.560]  так? Ну, в смысле вы про то, что если вот эта вот память, в которой хранится вот эта штука,
[53:09.560 --> 53:18.880]  если ее изменить, то все будет плохо. Нет, нет, естественно ошибки не будут. То, что я показал,
[53:18.880 --> 53:23.480]  то, что у вас там выделяется память, но на самом деле там за этой памятью там находится что-то,
[53:23.480 --> 53:29.480]  это на самом деле я рассказал по секрету и вы этого знать не должны. То есть, эту информацию на
[53:29.480 --> 53:33.480]  практике использовать никак нельзя. Это просто я показал прикольчик такой. Вот. В общем, вот так
[53:33.480 --> 53:39.520]  реализовано. Вот так получилось. На самом деле с точки зрения C++ то, что вам вернул new, ровно
[53:39.520 --> 53:43.240]  этот указатель, ровно эту память, вы имеете право использовать. Если вы пойдете куда-то назад,
[53:43.240 --> 53:47.840]  undefinedBehaviour. Если вы идете куда-то за границу массива, тоже undefinedBehaviour. Все,
[53:47.840 --> 53:56.120]  что можете делать, это пользоваться только вот этой вот памятью. Вот. Окей? Ну и изменять,
[53:56.120 --> 54:01.560]  естественно, тоже нельзя. Ну то есть, скорее всего, у вас получится, но на практике скорее всего это
[54:01.560 --> 54:06.880]  приведет к тому, что действительно у вас там вызовутся не все деструкторы. Вот. Но вообще это
[54:06.880 --> 54:10.160]  неопределенное поведение, то есть произойти может вообще все что угодно. В том числе и,
[54:10.160 --> 54:17.240]  ну, кстати, ошибка меряется тоже вполне может быть, хотя очень маловероятно. Так. Есть еще вопросы?
[54:17.240 --> 54:34.000]  Да. Так нет. Так какая разница? Язык C++, ну, как бы, смотрите, вот, опять же, константы существуют
[54:34.000 --> 54:40.360]  только в вашем воображении и в воображении языка C++. Вот. В самой памяти, в самой памяти как таковых
[54:40.360 --> 54:45.200]  констант нет. Ну, в смысле, понятное дело, есть там отдельные секции, но вот если вы, если вы
[54:45.200 --> 54:49.880]  работаете просто над сырой памятью, то там констант нет. Вот. То, что мы называем константными
[54:49.880 --> 54:53.320]  переменными, это, на самом деле, константы с точки зрения самого языка. То есть, сам язык запрещает
[54:53.320 --> 54:58.880]  вам их изменять. Вот. Но если вдруг у вас каким-то образом получилось скастовать, ну, у нас, например,
[54:58.880 --> 55:04.480]  есть такая операция, как ConstCast. Вот. ConstCast говорит, сними константность с этого указателя.
[55:04.480 --> 55:09.880]  Вот. Если вы, например, сделаете ConstCast, то вполне себе вы можете эту память изменять, и все. Как бы,
[55:09.880 --> 55:13.960]  эта память выделена вашей программой, и вы, в принципе, вольны с ней делать все что угодно.
[55:13.960 --> 55:24.000]  Идем дальше. Так. Давайте пару слайдов пропустим, оставим наконец. Давайте перейдем к сути. Смотрите,
[55:24.000 --> 55:30.240]  что мы научились. Давайте небольшое резюме первой части. Значит, что мы поняли? Мы поняли,
[55:30.240 --> 55:42.440]  что когда мы называем... Вот таким образом, у меня происходит две вещи. Давайте даже... Ну, ладно,
[55:42.440 --> 55:53.760]  пусть так. А у меня происходит две вещи. Первое. Вызывается функция operator.mu от size of t. Давайте
[55:53.760 --> 56:05.080]  с size of t. Что делает функция operator.new? Просто выделяет память. Просто выделяет
[56:05.080 --> 56:11.040]  память достаточно для хранения вот этого объекта. Что происходит дальше? Вот по этому месту памяти,
[56:11.040 --> 56:20.080]  которая была выделена, вот в том месте памяти, создается объект txy. Понятно, да? Обычный вызов
[56:20.080 --> 56:24.640]  new приводит к вызову функоператор.new и вызову деструктора вот именно в том месте
[56:24.640 --> 56:38.160]  памяти, который был выделен до этого. Почему приводит deleteptr? Первое. Deleteptr приводит к вызову
[56:38.160 --> 56:45.520]  деструктора t. Да? Сначала удаляется объект t, который находится вот по этому указателю,
[56:45.520 --> 56:57.600]  а потом вызывается функция operator.delete. И вот эта функция operator.delete просто-напросто
[56:57.600 --> 57:02.320]  очищает память, которая была там. Ну, очищает в том смысле, что возвращает память, возвращает
[57:02.320 --> 57:11.040]  ресурсы обратно на персонной системе. Хорошо. Давайте вспомним, ну, вообще говоря, чего мы хотели.
[57:11.040 --> 57:16.760]  Смотрите, когда я вызываю new, у меня происходит выделение памяти и вызов конструктора. Когда
[57:16.760 --> 57:21.480]  вызывают delete, у меня происходит вызов деструктора и очищение памяти. А к чему я на самом деле
[57:21.480 --> 57:27.920]  стремился изначально? Изначально я стремился к тому, чтобы вот эти вот действия, вот эти действия,
[57:27.920 --> 57:34.440]  делать отдельно друг от друга. То есть я не хочу одновременно и выделять память и создавать
[57:34.440 --> 57:39.360]  объект. Я хочу просто либо выделить память, либо просто потом когда-нибудь создать объект.
[57:39.360 --> 57:44.920]  Вот. Как это можно сделать? Ну, смотрите, на самом деле на первый вопрос мы с вами опетили. Что нужно
[57:44.920 --> 57:50.600]  сделать, если я хочу просто-напросто выделить память без создания какого-то объекта? Просто вызвать
[57:50.600 --> 57:59.840]  operator.new. Да? operator.new. Вот. Если я хочу просто выделить память, я использую функцию operator.new.
[57:59.840 --> 58:07.040]  Хорошо. Теперь второй вопрос. Допустим, у меня уже есть какая-то память. Вот.
[58:10.360 --> 58:20.520]  Вот. Откуда-то мне известно, что есть указатель на память, которая может в себя вместить объект
[58:20.520 --> 58:25.920]  типа T. Вопрос. Как вот конкретно вот в этом месте, вот конкретно вот в этой памяти создать объект?
[58:25.920 --> 58:38.560]  Неправильный ответ. Вопрос. Почему ответ неправильный? Да, потому что тут создание объекта,
[58:38.560 --> 58:43.320]  а потом созданный объект временный либо копируется, либо перемещается сюда. Да? Это первая
[58:43.320 --> 58:49.000]  причина. Вторая причина состоит в следующем. А кто вообще говоря сказал, что раздоминованный
[58:49.000 --> 58:54.000]  патериал это корректный объект? А что если там хранится просто какой-то мусор? Тогда вы просто
[58:54.000 --> 59:00.600]  кому-то мусору применяете операцию присваивания. Это неопределенное поведение. Понятно? Мне хочется
[59:00.600 --> 59:05.880]  сказать, создай объект не временный, а создай объект вот именно тут. То есть вот-вот-вот у меня есть
[59:05.880 --> 59:15.040]  место. Вот именно тут сделай мне объект. Вопрос. Как это сделать? Что-то типа статик-каст, элемент.
[59:15.040 --> 59:25.520]  Ну нет, статик-каст там использоваться не будет. Давайте я переформулирую задачу. В общем, изначально
[59:25.520 --> 59:29.320]  задача была такая. У меня есть указатель на какую-то память, и мне нужно просто в этом месте память
[59:29.320 --> 59:40.120]  создать какой-то объект. Вот. Задача такая. Вопрос. Как мне создать объект в памяти, но при этом
[59:40.120 --> 59:50.680]  не выделять под этот объект память? Вот. Помните, я говорил, что вот эта версия оператора new нам
[59:50.680 --> 59:58.360]  пригодится? Вот она нам пригодилась. Напомню, эта версия функции оператора new, она уже принимает
[59:58.400 --> 01:00:03.480]  готовый указатель и не выделяет никакой памяти. Она просто говорит, хорошо, я возьму этот указатель и
[01:00:03.480 --> 01:00:13.760]  буду считать, что вот этот указатель именно я и выделила. То есть, если у меня есть указатель на
[01:00:13.760 --> 01:00:26.640]  какую-то память, в которую я хочу создать объект, мне достаточно вызвать вот такую операцию new ptr txy.
[01:00:26.640 --> 01:00:34.960]  Почему это сработает? Давайте так. Это чисто выделение памяти, это чисто создание объекта.
[01:00:34.960 --> 01:00:43.480]  Вопрос, почему это сработает так, как надо. Давайте по шагам разберемся. С чего приводит вызов
[01:00:43.480 --> 01:00:48.920]  выражение new? Вызов выражения new всегда приводит к вот этим двум вещам. Давайте посмотрим.
[01:00:48.920 --> 01:01:00.960]  Первое, что будет вызвано, будет вызвано оператор new с параметрами size of t и вторым
[01:01:00.960 --> 01:01:08.520]  аргументом ptr. Так, а что это такая за функция? А вот она. Эта функция оператора new принимает
[01:01:08.520 --> 01:01:12.520]  первым аргументом размер, а вторым аргументом указатель, который нужно подсунуть вместо
[01:01:12.520 --> 01:01:17.600]  выделения памяти. То есть, вот эта версия оператора new, она как реализована? Она просто реализована
[01:01:17.600 --> 01:01:26.680]  как return ptr. Все. То есть, она притворила, что что-то выделила и вернула мне вот этот ptr,
[01:01:26.680 --> 01:01:32.200]  который я ей сам и передал. Вот, окей? И что происходит дальше? А дальше по этому
[01:01:32.200 --> 01:01:37.040]  вместо памяти вызывается конструктор txy. Но так как первый пункт ничего не делает, по сути,
[01:01:37.040 --> 01:01:47.480]  то у меня остается просто создание конструктора, вызов конструктора. Понятно? Есть ли вопрос?
[01:01:47.480 --> 01:01:56.520]  Давайте резюмируем совсем коротко. Вот, если нужно просто выделить память без создания объекта,
[01:01:56.520 --> 01:02:04.320]  я использую оператор new. Если мне нужно просто создать объект в нужном месте в памяти, вот я
[01:02:04.320 --> 01:02:09.480]  хочу сказать, что вот-вот тут, вот именно тут, создай объект. Я использую такую версию выражения
[01:02:09.480 --> 01:02:21.080]  new. Окей? Теперь давайте то же самое, но с delete. Да, давайте то же самое, но с delete. Что нужно
[01:02:21.080 --> 01:02:24.840]  сделать, чтобы просто очистить? Вот, допустим, у меня есть указатель на какую-то память, вот,
[01:02:24.840 --> 01:02:29.280]  динамическую. Что мне нужно сделать, чтобы просто ее очистить, но без вызова деструктора? Допустим,
[01:02:29.280 --> 01:02:36.600]  деструктор там уже был вызван. Как просто очистить кусок памяти, на который указывает ptr? Да,
[01:02:36.600 --> 01:02:47.680]  просто вызываю функцию оператор delete от ptr. Хорошо, теперь, допустим, у меня есть указатель ptr,
[01:02:49.680 --> 01:02:57.520]  который указывает на какой-то объекте pt. Как мне вызвать деструктор без очищения памяти? То
[01:02:57.520 --> 01:03:04.920]  есть сказать, что все, вот уничтожь там объект, но при этом память оставь за мной. Нет, если я
[01:03:05.400 --> 01:03:12.120]  сделаю delete ptr, то он и вызывает деструктор, и очистит память, а я хочу просто вызвать
[01:03:12.120 --> 01:03:19.800]  деструктор. Как мне просто вызвать деструктор? Ответ – просто вызвать деструктор. ptr, стрелочка,
[01:03:19.800 --> 01:03:27.640]  вот. Ну деструктор – это же метод, я же могу его вызвать. Вот. Вот это, собственно, тот самый
[01:03:27.640 --> 01:03:31.200]  единственный случай, про который мы говорили, когда вызывать деструктор вручную осмысленно.
[01:03:31.200 --> 01:03:36.040]  Вот. То есть, если у вас есть указатель динамическую память, и вы хотите этот элемент удалить,
[01:03:36.040 --> 01:03:41.880]  но при этом память не освобождать, вот, только в этом случае можно вручную вызвать деструктор. Вот.
[01:03:41.880 --> 01:03:50.540]  Ну, смотрите, если этот объект указывает на какую-то другую динамическую память, то да,
[01:03:50.540 --> 01:03:54.680]  эта динамическая память освободится, но при этом та память, в которой лежит сам объект t, не удалится.
[01:03:54.680 --> 01:04:05.320]  А, ну, в общем, нет, если t – это какой-то int, то, естественно, деструктору у int нет. То есть,
[01:04:05.320 --> 01:04:11.760]  написать int вот так нельзя. Вот. То есть, естественно, предполагается, что t – это какой-то класс. Вот. Да,
[01:04:11.760 --> 01:04:16.280]  еще один момент. Из этого правила есть исключение. Если у вас функция шаблонная, то есть, если это t –
[01:04:16.280 --> 01:04:20.600]  параметр шаблона, то вот так тоже делать можно. То есть, когда вы будете вызывать, то есть,
[01:04:20.600 --> 01:04:23.840]  когда вместо параметра t будет подставляться int, там, чарн или какой-то примитивный тип,
[01:04:23.840 --> 01:04:31.400]  то ошибка эмпляться не будет. Окей? Вот. Смотрите, в чем была, в чем проблема. Вот,
[01:04:31.400 --> 01:04:41.840]  допустим, у меня хранится в памяти int. Да. Вот. Написать вот так ptr-стрелочка int. Я не могу. Ну,
[01:04:41.840 --> 01:04:47.360]  потому что у int нет деструктора. Это не класс. Да. Вот. Ну, поэтому для примитивных типов вызывать
[01:04:47.360 --> 01:04:51.560]  деструктор не имеет смысла. Ну, у примитивных типов нет деструктора. То есть, эта память либо
[01:04:51.560 --> 01:04:56.880]  просто освобождается, либо просто выделяется. Вот. Но что может произойти? Представить себе
[01:04:56.880 --> 01:05:14.680]  такую ситуацию. Вот я пишу шаблонную функцию destroy. Вот. Я пишу шаблонную функцию destroy,
[01:05:14.680 --> 01:05:24.880]  куда просто вызывает деструктор. p-стрелочка tilde t. Вот. Что произойдет, если я в эту функцию
[01:05:24.880 --> 01:05:30.720]  destroy передам int? Понимаете, если я в нее передам int, то вроде как возникнет p tilde int. То есть,
[01:05:30.720 --> 01:05:35.600]  я как бы вызову деструктор у int. Вот. Но вот для шаблонов есть исключение. Вот в шаблонах так
[01:05:35.600 --> 01:05:40.360]  делать можно. Потому что если при постановке шаблонов, то есть если при постановке t равной int,
[01:05:40.360 --> 01:05:46.160]  компилятор заметит, что тут вызывается деструктор line down, он просто эту строчку выкинет.
[01:05:46.160 --> 01:05:52.640]  Вот. Окей? То есть, вот тут ошибки не будет. Но вот просто так, вот просто без шаблона написать
[01:05:52.640 --> 01:05:57.880]  вот так, нельзя. Если вот эта штука вызывает, если вот эта штука возникает при постановке
[01:05:57.880 --> 01:06:17.400]  шаблонов, то окей, компилятор с этим справится. Так, есть ли еще вопрос? Хорошо. Да, естественно. Вот.
[01:06:17.400 --> 01:06:27.080]  Да, вот если вы либо после этого, либо после этого еще напишете delete ptr, то вы проиграли. Вот.
[01:06:27.080 --> 01:06:33.440]  Потому что delete ptr снова вызовет вот эти две штуки. Ну, смотрите, если вы сначала
[01:06:33.440 --> 01:06:37.920]  сделаете оператор delete, а потом вызовете delete ptr, тогда у вас будет double free. Ну, типа вы будете
[01:06:37.920 --> 01:06:43.200]  вызывать очистку памяти по памяти, которая уже очищена. Вот. Или если вы вызовете delete ptr после
[01:06:43.200 --> 01:06:46.760]  того, как вызвали деструктор, то delete ptr снова попытается вызвать деструктора, это уже будет
[01:06:46.760 --> 01:06:51.400]  второй вызов деструктора по ударенному объекту. Ну, что тоже неопределенное поведение. Вот. Поэтому,
[01:06:51.400 --> 01:06:56.720]  если вы управляете памятью и временем жизни объекта вручную, то обычный delete new использовать
[01:06:56.720 --> 01:07:22.960]  уже нельзя. Да. Да. Да, более того, delete. Можно вызывать только по тому указателю,
[01:07:22.960 --> 01:07:28.640]  который ранее был получен с помощью вызова new. И оператор delete тоже можно вызывать только по тому
[01:07:28.640 --> 01:07:33.280]  указателю, который был получен ранее с помощью оператора new. Вот. А еще такой момент. Ну, он на
[01:07:33.280 --> 01:07:38.840]  слайде, по-моему, есть, но давайте я явно пропишу. Смотрите, вот. Если вы, допустим, написали вот так.
[01:07:38.840 --> 01:07:55.320]  Ну, как-то after p равно оператор new от, ну давайте size of t. А потом написали new p. Кстати,
[01:07:55.320 --> 01:08:16.400]  можно написать вот так. А потом написали delete от p. Вот так делать нельзя, потому что формально вы
[01:08:16.400 --> 01:08:24.320]  выделяли память и уничтожаете ее разными способами. Окей? То есть delete вот такой. Можно вызвать только
[01:08:24.320 --> 01:08:29.000]  для указателя, который был выделен с помощью такого new. И оператор delete вот этот можно вызвать
[01:08:29.000 --> 01:08:33.320]  только для указателя, который был выделен с помощью оператора new вот так. Окей? То есть тут
[01:08:33.320 --> 01:08:50.720]  соответствие должно сохраняться тоже. Понятно? Да. Не, это неопределенное поведение. Так. Да,
[01:08:50.720 --> 01:08:56.560]  собственно, я не сказал, но вот эта форма new, вот эта форма new, которая только создает объект,
[01:08:56.560 --> 01:09:00.840]  но не выделяет память, называется placement new. Ну, placement – размещение, да, то есть размещающая
[01:09:00.840 --> 01:09:04.280]  форма new. Ну, почему размещающая? Потому что она просто берет объект и размещает его в нужном месте
[01:09:04.280 --> 01:09:09.440]  памяти. Ну, на самом деле, placement new называют вообще все версии new, которые не стандартные, но, в общем,
[01:09:09.440 --> 01:09:16.160]  как правило, placement new называет вот только такую версию. Так, давайте вопросы на понимание. Вот,
[01:09:16.160 --> 01:09:22.080]  смотрите, у меня есть два примера. Первый пример такой. Я выделяю обычный массив на стеке, обычный
[01:09:22.080 --> 01:09:29.160]  массив byte размера size of t, и дальше по этому месту памяти вызываю new. То есть просто в этом
[01:09:29.160 --> 01:09:35.200]  массиве располагаю объект типа t. Вот. И второй пример. Я выделяю память с помощью функции оператора
[01:09:35.200 --> 01:09:42.000]  new и по этому месту памяти создаю объект типа t. Вопрос следующий. Ну, про второй случай мы уже
[01:09:42.000 --> 01:09:47.480]  поговорили. Если вы создали объект с помощью оператора new и размещающей формы new, то очищаем
[01:09:47.480 --> 01:09:52.320]  память с помощью деструктора и оператора delete. Вот. Меня больше интересует первый вопрос. Вот, смотрите,
[01:09:52.320 --> 01:09:58.160]  у меня объект располагается на стеке. То есть вот у меня массив создан на стеке. Вот. И я в этом
[01:09:58.160 --> 01:10:03.600]  массиве задаю объект. Вопрос. Нужен ли как-то особенному образом сожрать этот объект, или так,
[01:10:03.600 --> 01:10:19.200]  он хранится на стеке, все для него вызовется корректно? Как вы думаете? Почему? Да, смотрите,
[01:10:19.200 --> 01:10:25.160]  в чем тут проблема? Несмотря на то, что массив object выделен на стеке, если массив выделен на стеке,
[01:10:25.160 --> 01:10:30.480]  то вроде как delete для него вызывать не надо. Тут возникает следующая проблема. То есть сам массив
[01:10:30.480 --> 01:10:35.240]  действительно выделен на стеке. Но компилятор-то думает, что внутри него хранится массив byte,
[01:10:35.240 --> 01:10:41.680]  и поэтому уничтожать он его будет именно как массив byte. То есть как бы, представьте, что вам
[01:10:41.680 --> 01:10:48.840]  дан массив размера 16 байт, и вы говорите, что вот этот массив хранится 16 чаров. А потом вы выходите
[01:10:48.840 --> 01:10:53.040]  из мейна и говорите, ой, а там же хранится мой класс, который занимает 16 байт на самом деле. Ну,
[01:10:53.040 --> 01:10:58.400]  естественно компилятор такой подставы не ожидает. Вот. Поэтому если вы что-то вручную создали, если вы
[01:10:58.400 --> 01:11:03.720]  вручную создали что-то с помощью new, вот такого, то вы должны это что-то вручную тоже удалить с
[01:11:03.720 --> 01:11:21.760]  помощью вот такого деструктора. Окей? Да. Нет, а по дочисткой памяти я понимаю, вот память,
[01:11:21.760 --> 01:11:26.400]  которую выделила мне операционная система после new. Я эту же память иду и возвращаю ей. Вот.
[01:11:26.400 --> 01:11:35.960]  Там вызываем деструктор, просто уничтожается объект. Нет, если этот объект хранил указательно
[01:11:35.960 --> 01:11:40.480]  какую-то выделенную память, то он эту память освободит. Но сама память, в которой находится сам объект,
[01:11:40.480 --> 01:11:50.400]  она не удалится. Вот. Вот. Поэтому, ну, как я уже сказал, в первом случае достаточно просто вызвать
[01:11:50.400 --> 01:11:53.760]  деструктор. Ну, то есть вы вызовете деструктор, то есть удалится объект, который лежал вот в этом
[01:11:53.760 --> 01:11:57.680]  месте в памяти, а сама память освободится автоматически так, как она хранится на стеке. Вот. А тут,
[01:11:57.680 --> 01:12:02.880]  так как мы птр выделяли с помощью функции оператора new, то мы должны ее освободить с
[01:12:02.880 --> 01:12:06.240]  помощью функции оператора delete. Но, правда, перед этим, понятное дело, нужно вызвать деструктор.
[01:12:06.240 --> 01:12:14.640]  Нужно вызвать деструктор. Окей? То есть, вот по сути, вот то, что написано здесь, это то,
[01:12:14.640 --> 01:12:20.880]  что происходит под капотом при вызове вот такого new и при вызове вот такого delete. Просто я это
[01:12:20.880 --> 01:12:25.480]  сейчас делал вручную, и в целом я могу эти два процесса, ну, вот эти два процесса и вот эти два
[01:12:25.480 --> 01:12:30.920]  процесса развести по времени. В один момент времени я могу выделить память, а потом через какое-то
[01:12:30.920 --> 01:12:35.040]  время могу заходить создать объект. И потом я могу в какой-то момент времени удалить объект, и потом
[01:12:35.040 --> 01:12:40.400]  там через какое-то количество операций освободить память. Окей? New и delete это делает одновременно,
[01:12:40.400 --> 01:12:56.080]  то есть, ну, атомарно одной операцией. Окей? Нормально? Да. Ну, нет, атомарно имеет в виду, что мы как,
[01:12:56.080 --> 01:13:01.040]  собственно, вот наш последовательный код туда вмешаться не может. Вот, ну, есть там несколько потоков,
[01:13:01.040 --> 01:13:12.880]  то, естественно, может. Окей. Так, ну и теперь давайте поближе к практике. Собственно, вернемся к
[01:13:12.880 --> 01:13:18.560]  проблеме, которую обсуждали в том начале. Вот у нас есть вектор. Как мы с вами увидели, у вектора есть
[01:13:18.560 --> 01:13:29.920]  несколько приколов. Первый прикол связан с тем, что когда я вызываю v.reserve от сотни, у меня не
[01:13:29.920 --> 01:13:42.000]  вызывает ни одного конструктора. Что при этом происходит внутри вектора? Как у вектора получается
[01:13:42.000 --> 01:13:48.320]  выделить память, но при этом не создавать никаких объектов? Да, вызвать оператор, вызвать функцию оператор
[01:13:48.320 --> 01:14:04.560]  new. То есть он выделяет оператор new от size of t умножить на 100. Вот. Теперь я после вызвания этого
[01:14:04.560 --> 01:14:14.760]  резерв... Говорю, допустим, v.resize3. Что происходит векторе? Как вектор удается вот по этой памяти,
[01:14:14.760 --> 01:14:18.160]  которая у него, которая у него уже ранее была выделена, как ему удается вот в этих чейках
[01:14:18.160 --> 01:14:24.320]  памяти создать три объекта? С помощью placement new. Да, то есть по сути там написано следующее for
[01:14:24.320 --> 01:14:44.120]  int i равно 0, i меньше 3, плюс-плюс i. И дальше я говорю new buffer plus i, ну и создаю t по умолчанию.
[01:14:44.120 --> 01:14:50.920]  Вот. То есть я говорю, что в ячейке памяти buffer plus i, ну буфер это начало массива,
[01:14:50.920 --> 01:14:58.680]  плюс и это и та ячейка массива, вот в этой ячейке памяти нужно создать t по умолчанию. Вот ровно то,
[01:14:58.680 --> 01:15:04.560]  что написано сверху. То есть как выделить, то есть вопрос, как выделить капасити памяти,
[01:15:04.560 --> 01:15:11.120]  но при этом создать size объектов? Вот как. Я создаю буфер с помощью оператора new, а потом в цикле
[01:15:11.120 --> 01:15:15.000]  просто создаю нужное количество объектов. Вот. И получается, что память у меня выделена
[01:15:15.000 --> 01:15:20.440]  под капасити объектов, но при этом количество реально созданных объектов равно size. Вот. Но
[01:15:20.440 --> 01:15:26.760]  и аналогично при удалении. Что делать, если у меня в массиве реально создана size объектов,
[01:15:26.760 --> 01:15:31.440]  но при этом память выделена под капасити? Ну, собственно, я вот в цикле удаляю эти самые
[01:15:31.440 --> 01:15:35.760]  size объектов, то есть для каждого элемента вызываю деструктор. Вот. А потом просто вызываю оператор
[01:15:35.760 --> 01:15:43.440]  delete и очищаю ту самую память, на которую указывает буфер. Вот. Окей? Да.
[01:15:43.440 --> 01:15:56.760]  Ну, чтобы выделить память, нам же нужно выделить память для хранения капасити элементов. Ну, тут
[01:15:56.760 --> 01:16:01.920]  скорее вопрос про то, как сделать так, чтобы у меня было выделено памяти для хранения капасити
[01:16:01.920 --> 01:16:10.480]  объектов, но при этом реально было заполнено только size из них? Если я сделаю вот так,
[01:16:10.480 --> 01:16:20.120]  если делаю new t от capacity, то у меня будет выделена память под капасити элементов,
[01:16:20.120 --> 01:16:24.320]  но при этом каждый элемент будет создан с помощью конструктора по умолчанию. А я хочу, чтобы были
[01:16:24.320 --> 01:16:32.960]  созданы не все элементы, а только size из них первые. Так, а разница большая, потому что сам
[01:16:32.960 --> 01:16:38.280]  элемент типа t, но представьте себе, что каждый элемент типа t хранит указатель еще на какую-то
[01:16:38.280 --> 01:16:44.760]  выделенную память. Ну или так. Представьте себе, что создание элемента t занимает очень много
[01:16:44.760 --> 01:16:49.880]  времени. Но тогда я не хочу тратить лишнее время на создание объектов, которые мне пока не нужны.
[01:16:49.880 --> 01:17:06.840]  Вот. На самом деле, тут есть еще другой момент. Смотрите. Представьте себе, что у типа t
[01:17:06.840 --> 01:17:24.440]  нет конструктора по умолчанию. Что тогда? Что произойдет, если у меня у t не будет конструктора
[01:17:24.440 --> 01:17:35.800]  по умолчанию? Тогда я просто не смогу выделять вот такую память. Вот вы не задумывались, что для тех
[01:17:35.800 --> 01:17:40.760]  классов, вот вы написали класс, и у класса нет конструктора по умолчанию. Вопрос. Как создать
[01:17:40.760 --> 01:17:47.160]  массив из элементов этого типа? Ну кажется, что никак. Почему? Потому что если вы вызываете вот
[01:17:47.160 --> 01:17:52.760]  такой вот new, то этот new, еще раз напомню, он приводит к тому, что выделяется память, а потом
[01:17:52.760 --> 01:17:59.080]  вызывается конструктор по умолчанию. Вот если у t нет конструктора по умолчанию, то у вас в принципе
[01:17:59.080 --> 01:18:09.000]  не получится выделить массив из этих элементов. Вот. Но с помощью вот этого разделения мы можем
[01:18:09.000 --> 01:18:19.840]  это устроить. Как? Я могу сначала создать эту память. Оператор new, ну опять же, size of t умножить на n,
[01:18:19.840 --> 01:18:30.160]  а потом в цикле for int i равно нулю, и меньше n, плюс плюс i, и допустим каждый элемент
[01:18:30.160 --> 01:18:40.560]  написать new p, ну и создать его с помощью какого-то параметра, например t от i. То есть допустим,
[01:18:40.560 --> 01:18:43.720]  у меня нет конструктора по умолчанию, но есть конструктор целого числа. Вот. Таким образом,
[01:18:43.720 --> 01:18:50.520]  я смогу создать, так только p плюс i. Таким образом, я могу создать каждый элемент, не имея на руках
[01:18:50.520 --> 01:19:09.560]  конструктора по умолчанию. Вот. Так, еще вопросы. Что произошло? Закончилась лекция, а тут, смотрите,
[01:19:09.560 --> 01:19:15.760]  у нас у t нет конструктора по умолчанию. Что произойдет, если я попытаюсь создать массив
[01:19:15.760 --> 01:19:22.040]  элементов, у которого нет конструктора по умолчанию? Ну, ошибка эмпиляции, потому что при вызове такой
[01:19:22.040 --> 01:19:26.520]  операции new выделяется память, и плюс каждый элемент создается по умолчанию. То есть я утверждаю,
[01:19:26.520 --> 01:19:30.120]  что если у вас нет конструкции по умолчанию, то вы не сможете создать массив из этих элементов. Вот
[01:19:30.120 --> 01:19:35.000]  так. Но что я могу сделать? Я могу сначала выделить память, но выделение памяти не вызывает
[01:19:35.000 --> 01:19:39.880]  конструктора. А потом каждый элемент создать так, как мне нужно. Ну, в частности, например,
[01:19:39.880 --> 01:19:48.000]  создать элемент с помощью конструктора одного аргумента. А вектор, ну, смотри, у вектора есть,
[01:19:48.000 --> 01:19:52.320]  напомню, два конструктора. У вектора есть конструктора, который принимает n, который работает так,
[01:19:52.320 --> 01:19:56.840]  как написано слева. А есть конструктор, который принимает n, ну, и какое-то начальное значение,
[01:19:56.840 --> 01:20:02.960]  например, t в единицах. Вот. И вот в этом случае вектор просто-напросто вызовет вторую версию. И
[01:20:03.680 --> 01:20:13.440]  создает все элементы не по умолчанию. Пока нет. Нет, да, на самом деле там естественно есть обработка
[01:20:13.440 --> 01:20:23.360]  исключений, но resize он не noexcept, pushback тоже не noexcept, но они обладают некоторой гарантией
[01:20:23.360 --> 01:20:32.480]  безопасности. Да, ну, собственно, вот последний слайд. Мы пытались реализовать emplaceback. Напомню,
[01:20:32.480 --> 01:20:37.800]  как мы это с вами пытались сделать. Мы с вами написали что-то наподобие такого.
[01:20:37.800 --> 01:20:54.960]  Booper от i равно t от std forward arcs. Вот. Мы сказали, что так делать нельзя,
[01:20:54.960 --> 01:21:00.960]  что так делать нельзя, потому что тут используется создание объекта и плюс присваивание. Вопрос,
[01:21:01.040 --> 01:21:05.360]  как реализовать emplaceback так, чтобы элемент с этими параметрами конструктов был создан в
[01:21:05.360 --> 01:21:11.280]  нужном месте? Очень просто. Используем вот эту версию операции new. Напишем new
[01:21:11.280 --> 01:21:18.720]  booper plus i. То есть я говорю, что на i-те ячейки массива, на которой указывает booper,
[01:21:18.720 --> 01:21:23.640]  нужно создать вот такой объект. t, ну и дальше-дальше и так далее. Вот то, что написано здесь.
[01:21:23.640 --> 01:21:33.000]  Окей? Всё, вот таким образом я за одну операцию, я в одну операцию сразу же
[01:21:33.000 --> 01:21:36.120]  создаю объект в нужном месте памяти, а именно на i-те ячейки.
[01:21:36.120 --> 01:21:43.120]  Окей? Всё, тогда на сегодня закончили. Всем спасибо.
