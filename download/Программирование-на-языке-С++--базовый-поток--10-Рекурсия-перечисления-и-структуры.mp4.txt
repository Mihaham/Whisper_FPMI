[00:00.000 --> 00:17.760]  Лекция номер 10. И мы с вами приступаем к, у нас будет несколько тем, первая рекурсия.
[00:17.760 --> 00:30.120]  Так что такое вообще рекурсивный какой-то объект? Вообще встречались ли вы с рекурсией
[00:30.120 --> 00:37.400]  в жизни? Наверняка вас вы слышали или видели какие-то примеры рекурсии. Давайте в жизни,
[00:37.400 --> 00:49.400]  что-нибудь из жизни. Ну, жизнь физтеха, понятно, сразу с факториала, окей. Давайте тогда что-нибудь
[00:49.400 --> 00:56.040]  простое, например, попроще факториала. Рекурсивное определение натурального числа. Ноль, ну,
[00:56.040 --> 01:01.480]  мы программисты, и у нас на нас большое влияние, как вы знаете, американская поэтому и математика,
[01:01.480 --> 01:06.040]  их стандарты. Ноль, это у нас там и остатки отрицательные и так далее. Ноль, это натуральное
[01:06.040 --> 01:16.240]  число. Если число, значит, как дальше мне можно определить рекурсивно на следующее натуральное число?
[01:16.240 --> 01:29.240]  Ну, например, и мы с вами можем много разных примеров проводить, но вы правильно сказали,
[01:29.240 --> 01:36.440]  факториал, один из таких классических примеров, у нас есть некая формула рекуррентная, где мы
[01:36.440 --> 01:41.840]  факториал определяем через факториал же. Но рекурсивно называется функция, которая вызывает
[01:41.840 --> 01:49.600]  саму себя. Вот вы, допустим, как обычно я спрашиваю для того, чтобы вы думали, вы, допустим, находится на
[01:49.600 --> 01:56.680]  экзамене, и у вас, как всегда, неудачный экзоминатор, который задает подлые вопросы с подковыркой. Он,
[01:56.680 --> 02:01.040]  то есть, знает, что, может, вопрос некорректен или еще что-то и смотрит на вашу реакцию. Вот,
[02:01.040 --> 02:10.840]  например, вы, вас как зовут, молодой человек? Егор. Гор просто. Хорошо, Гор. Вы сидите на экзамене и
[02:10.840 --> 02:16.920]  вам говорят, вот я напишу сейчас функцию. Экзоминатор говорит, я сейчас напишу функцию. Он еще не написал,
[02:16.920 --> 02:22.240]  но вот напишет. Это какая-то, знаешь, ставка вслепую. Значит, он пишет, он скажет, я сейчас напишу
[02:22.240 --> 02:28.680]  функцию. И, посмотрев на эту функцию, вы, Гор, сможете сказать, рекурсивная эта функция или нет? Что вы
[02:28.680 --> 02:38.240]  должны ответить экзоминатору? Да, сможете ли вы с уверенностью, да, 100% сказать, рекурсивная эта
[02:38.240 --> 02:46.880]  функция или нет, если он вам напишет сейчас функцию и покажет ее? Совершенно правильно. Вот вы бы
[02:46.880 --> 02:53.160]  сдали, потому что мы не всегда видим с вами рекурсию просто по одной функции. Бывает самый простой способ,
[02:53.160 --> 03:03.200]  прямая рекурсия, когда функция вызывает сама себя. Я где-то видел, причем чуть ли не в детском
[03:03.200 --> 03:09.040]  учебнике, определение, мне очень понравилось, но, видимо, учебник не очень хорошо редактировался,
[03:09.040 --> 03:13.920]  где детям рассказывали про рекурсию, рассказывали, но это червяк, который ест сам себя. Это, конечно,
[03:14.160 --> 03:19.920]  наверное, червяки едят сам себя, они не специалист биологии, но, наверное, детскую психику такое
[03:19.920 --> 03:25.600]  определение повреждает. Поэтому даже мы с вами не будем об этом думать. То есть это прямая рекурсия.
[03:25.600 --> 03:33.840]  Косвенная рекурсия — это когда, например, функция A вызывает функцию B, а функция B вызывает функцию A.
[03:33.840 --> 03:39.480]  И просто посмотрев на функцию A, мы не можем сказать, вот эту функцию B, которая вызовется,
[03:39.480 --> 03:46.400]  она вызовет ее или нет. И рекурсивные функции на самом деле надо знать, когда использовать,
[03:46.400 --> 04:00.360]  потому что рекурсия иногда это очень удобно и очень полезно, и вы не можете очень кратко и просто
[04:00.360 --> 04:04.880]  написать какие-то вещи. Мы будем часто, например, их использовать, когда программируем деревья,
[04:04.880 --> 04:11.240]  когда программируем разные алгоритмы на графах, например, DFS. И там действительно без рекурсии можно
[04:11.240 --> 04:17.960]  это было бы писать, но вам бы пришлось затрачивать слишком большие дополнительные усилия. А есть
[04:17.960 --> 04:24.400]  примеры, когда рекурсию не надо использовать. И, например, на собеседованиях там в Яндекс и в другие
[04:24.400 --> 04:31.320]  крутые компании часто спрашивают даже вопрос с подковыркой, а напиши такую программу рекурсивно,
[04:31.320 --> 04:37.600]  и ты понимаешь, что. И вот тут сейчас мы давайте сначала посмотрим на самый первый пример с
[04:37.600 --> 04:43.920]  факториалом. Факториал обычно во всех учебниках действительно классический, такая штука,
[04:43.920 --> 04:51.840]  на которой показывается пример рекурсии. Ну давайте, чтобы не выделяться из серой массы
[04:51.840 --> 04:58.840]  тех, кто программирует на C++ первую рекурсивную программу, тоже напишем факториал. Пусть у нас
[04:58.840 --> 05:11.880]  будет некий int. Ну можно long. Сейчас давайте, наверное, даже все-таки напишем, в зависимости от, понятно,
[05:11.880 --> 05:19.400]  где-то это будет совпадать. Ну так красивее хоть будет long. Давайте напишем. Пусть у меня будет
[05:19.400 --> 05:23.960]  какая-то функция факт, которая возвращает long, принимает long and, собственно, факториал,
[05:23.960 --> 05:33.560]  который мы хотим посчитать. Каким образом она это будет у нас с вами делать? Если у нас n или 0
[05:33.560 --> 05:48.480]  или 1, то плохой стиль возвращаем 1. А иначе, во всех остальных случаях, когда мы не вернулись,
[05:48.480 --> 06:04.640]  значит, мы просто вернем следующее выражение. n умножить на факториал n-1. Это корректная функция.
[06:04.640 --> 06:11.520]  Она считает факториал и вызывает, собственно, саму себя. Вот у нас здесь явно есть прямая
[06:11.520 --> 06:20.520]  рекурсия. Вы видите, что у нас из функций вызывается функция. Тут самый червяк. Можно же было,
[06:20.520 --> 06:28.920]  можно было бы написать все это одной строчкой. Да, можно написать, например, вторую версию этой
[06:28.920 --> 06:36.920]  программы, воспользовавшись нашими знаниями. И давайте так и сделаем. Без if это напишем,
[06:36.920 --> 06:45.840]  а просто сразу сделаем return. Заменим просто наш условный оператор тернарной операции,
[06:45.840 --> 06:55.040]  который у нас c++ есть. Если n больше 1, тогда мы вернем значение выражения n умножить на факториал
[06:55.040 --> 07:05.200]  n-1, а иначе мы с вами вернем просто единичку, что является значением факториала при n меньшем
[07:05.200 --> 07:23.760]  либо равном 1. Теперь, как вообще это чудо работает? Прежде всего, надо понять, что когда
[07:23.760 --> 07:34.040]  происходит первый вызов функций. Допустим, в main где-нибудь мы вызываем этот факториал от 5. У нас
[07:34.040 --> 07:43.560]  есть stack и все вызовы этих функций, те данные, которые хранятся в этих функциях, они хранятся
[07:43.560 --> 07:52.000]  на stack. Мы это уже с вами много раз смотрели. Вот у нас идет вызов функции факт с параметром 5.
[07:52.000 --> 07:57.720]  Что такое n? Это некий параметр, который передается по значению. Это локальная
[07:57.720 --> 08:07.880]  переменная. То же самое, что если бы мы внутри функции объявили int n, то есть мы с вами получаем
[08:07.880 --> 08:14.400]  первый вызов f от 5. Фактически у нас на stack сейчас объявляется локальная некая переменная n,
[08:14.400 --> 08:21.280]  значение которой равно 5. Кроме того, что у нас объявляется переменная, помните я рассказывал,
[08:21.280 --> 08:28.720]  что для того, чтобы вызывать функцию, еще хранится служебная информация, потому что никаких секретов не
[08:28.720 --> 08:36.120]  происходит. Вызов функции это просто переход на какую-то строчку кода. У процессора есть некие
[08:36.120 --> 08:42.320]  команды, например там call или jump, в зависимости от ассемблера языка. Тем не менее, неважно. Важно,
[08:42.320 --> 08:48.280]  что он просто безусловно переходит, как вот то слово, которое мы не называем с вами, и потом
[08:48.280 --> 08:52.240]  возвращается. Чтобы ему вернуться, ему надо помнить, куда вернуться, то есть хранится некий
[08:52.240 --> 08:58.440]  адрес возврата. То есть у нас есть некий адрес возврата, который неявно записывается тоже в stack,
[08:58.440 --> 09:04.800]  плюс некий контекст процессора, регистры, которые были на этот момент, чтобы когда мы вернулись,
[09:04.800 --> 09:11.640]  да, все было как вот так. Вот я отвернулся к доске, вы тут все взяли, я повернулся назад,
[09:11.640 --> 09:16.960]  все положили как было, никто ничего не заметил. Я могу продолжать лекцию, как и было. Также и
[09:16.960 --> 09:21.040]  программа, она должна вернуться в точку, откуда вызвали функцию, и ничего не должно измениться,
[09:21.040 --> 09:26.680]  ничего не должно сбиться от того, что там кто-то что-то поработал, ей затер. Вот это хранится,
[09:26.680 --> 09:33.880]  и теперь идет у нас с вами здесь if, если это не выполняется, выполняется эта строчка, идет вызов,
[09:33.880 --> 09:41.200]  что мы возвращаем значение 5, мы должны вернуть, чтобы функция закончилась, она должна свою последнюю
[09:41.200 --> 09:46.560]  строчку отработать, вот она ее отрабатывает, она считает значение выражения 5 умножить на
[09:46.560 --> 09:54.640]  факториал от 4, и в этот момент она еще не закончилась, потому что она должна вызвать функцию
[09:54.640 --> 10:00.320]  факториал от 4 для того, чтобы закончить свою работу, и факториал от 4 у нас выполняется,
[10:00.320 --> 10:08.600]  вызывается, и в стеке ниже теперь для нее все. Сначала локальная переменная n равно 4,
[10:08.600 --> 10:15.960]  теперь вот этот адрес, теперь вот эти служебные еще дополнительные информации, то есть обратите
[10:15.960 --> 10:22.680]  внимание, как у нас стек растет при вызове рекурсивном, и здесь тоже самое, 4 умножить на
[10:22.680 --> 10:35.080]  факториал от 3, идет вызов факториал от 3, этот ждет закончания вычления выражения, чтобы закончиться,
[10:35.080 --> 10:39.160]  выражение у нас как бы не вычислилось здесь тоже, поэтому для того чтобы вычислить выражение
[10:39.160 --> 10:44.080]  вызываем это, и вот у нас каждый новый вызов, это фактически вся вот эта служебная информация,
[10:44.080 --> 10:51.480]  плюс локальные переменные в памяти n равно 3, и мы хотим с вами 3 умножить на факториал от 2,
[10:51.480 --> 11:02.920]  факториал от 2, то же самое n равно 2, некая информация 2 умножить на факториал от 1,
[11:02.920 --> 11:09.040]  и вот здесь наконец произойдет чудо, вызовется функция факториал от 1,
[11:09.040 --> 11:15.360]  в которой будет у меня n равно 1, будет еще служебная информация, вот эта строчка сработает,
[11:15.360 --> 11:23.800]  и мы закончим вот эту функцию по этой строчке, вот это место, и оно вернется нам единичка,
[11:23.800 --> 11:28.880]  вот это место, где заканчивается рекурсия очень важно, потому что если у вас нет места,
[11:28.880 --> 11:34.520]  которая заканчивает рекурсию, то она у вас будет бесконечной, но писать бесконечные программы
[11:34.520 --> 11:38.720]  не надо большого ума иметь, можно цикл написать бесконечным, можно рекурсию бесконечную,
[11:38.720 --> 11:43.760]  здесь просто проблема, что она не только не закончится, она рано или поздно переполнит стэк,
[11:43.760 --> 11:53.000]  потому что у вас есть стэк, и глубина рекурсии, на нашей терминологии глубина, это как раз сколько
[11:53.000 --> 11:59.080]  вызовов мы максимально делаем, то есть у вас какая максимальная глубина рекурсии,
[11:59.080 --> 12:03.960]  но вот от какого параметра можете вызвать максимум, по условию вот столько вы можете
[12:03.960 --> 12:09.840]  этих вызовов получить, и надо посмотреть, влезают ли они у вас в стэк, потому что кроме самих
[12:09.840 --> 12:15.800]  локальных перемен, у вас есть служебная информация, но тем не менее, если вызовов много,
[12:15.800 --> 12:23.160]  эти мегабайты там 1, 2, 4 у вас забьются, и это легко почитать, кроме того, если не дай бог вы
[12:23.160 --> 12:27.800]  какой-нибудь массив объявляете внутри функции рекурсивной, но она забьется намного быстрее,
[12:27.800 --> 12:32.480]  если большие там структуры, которые локальные будут объявляться, поэтому переполнить стэк
[12:32.480 --> 12:37.200]  большого ума не надо, у вас будет стэк оверфлоу, это такое есть выражение культовое, даже есть
[12:37.200 --> 12:43.000]  некие сайты типа стэк оверфлоу, поэтому, может вы слышали, есть такой форум стэк оверфлоу,
[12:43.000 --> 12:51.000]  поэтому это как раз про переполнение стэка, например, рекурсии, ну и здесь мы возвращаем эту
[12:51.000 --> 12:56.160]  единичку, единичка заканчивает вычисление функции, потому что ей вернули значение,
[12:56.160 --> 13:02.080]  получается двоечка, двойка является результатом вычисления функции, функция сворачивается,
[13:02.080 --> 13:10.480]  возвращается сюда значение 2, то есть эта из стэка у нас уже удалилась, здесь у нас 6,
[13:10.480 --> 13:15.800]  мы возвращаем 6 и как помираем, потому что мы вернули и функция закончилась, все,
[13:15.800 --> 13:22.320]  стэк в данном случае указатель подвинул вверх и эта память будет затерта, физически там никто
[13:22.320 --> 13:26.880]  с отбойным молотком не приходит и не перетирает эти ячейки, их просто затрут, когда они в следующий
[13:26.880 --> 13:35.640]  раз понадобятся, 4 там на 6, 24 мы с вами получили, тоже закончили, здесь там 120 мы получили и
[13:35.640 --> 13:41.720]  вернули эти 120 в основную программу, вот мы так 120 получили, когда мы в одну сторону развернулись,
[13:41.720 --> 13:54.000]  в другую свернулись, хорошо, теперь давайте вот тот самый подлый пример, когда на собеседонах
[13:54.000 --> 14:05.360]  спрашивают, а этот пример является классическим примером в любой книге вообще, если вы, значит,
[14:05.360 --> 14:13.720]  загуглите, посмотрите или даже я помню статью какую-то читал на хабре, где было написано писать
[14:13.720 --> 14:21.440]  вот это рекурсивно, это хуже чем топить щенков там в речке, когда у нас, я считаю, что как бы это
[14:21.440 --> 14:28.120]  ужасно, кто так пишет и вот если кто-то так напишет вообще и мы увидим, это вот знаете,
[14:28.120 --> 14:34.840]  считается просто вот не знаю, очень плохой стиль, вот очень плохой, как будто вы там матом ругаетесь,
[14:34.840 --> 14:41.200]  когда пишете, это вот на уровне вот этих четырех букв, которые нам нельзя произносить, и так это числа
[14:41.200 --> 14:48.480]  фибоначи, и так все вы знаете числа фибоначи, у вас есть нулевой, первый элемент, допустим,
[14:48.480 --> 14:54.880]  они равные единице, каждый последующий элемент определяется по формуле, как два предыдущих,
[14:54.880 --> 15:01.760]  числа фибоначи тоже быстро растут, наверняка те, кто в школе занимались олимпиадной математикой,
[15:01.760 --> 15:07.360]  знает явную формулу для очистки фибоначи, степенную, через золотое сечение, может быть,
[15:07.360 --> 15:12.040]  это не наша как бы в любом случае программа, это школьные такие штуки, но если вам интересно,
[15:12.040 --> 15:18.600]  можете википедию прочитать про числа фибоначи и их историю, почему они в природе имеют большое
[15:18.600 --> 15:25.560]  значение, что наше тело подчиняется во многом, в том числе этим законам, там пропорции там,
[15:25.560 --> 15:32.800]  я не помню, от груди до ступни и от головы там до ступни, это вот там золотое сечение, вот и рука
[15:32.800 --> 15:39.680]  там у нас по такому принципу, и вообще мы с вами ходячие числа фибоначи, но сейчас на программирование
[15:39.680 --> 15:47.480]  мы просто хотим с вами написать рекурсивную программу, ведь это же так очевидно, посмотрите,
[15:47.480 --> 15:53.000]  это же напрашивается рекурсия, и мы просто, ну давайте напишем, вот у нас функция некая,
[15:53.000 --> 16:02.360]  она принимает у нас значение вот этого числа и то же самое вот по такому же образцу,
[16:02.360 --> 16:13.960]  что нам изобретать, вот если n меньше либо равно 1, давайте вернем 1, а иначе сделаем вот этот
[16:13.960 --> 16:26.520]  вызов, что f значит ретурн, и здесь просто явно напишем вот эту формулу, f от n минус 1,
[16:26.520 --> 16:33.560]  плюс f от n минус 2, то есть взяли, написали, очень легко, красиво, и вот ты в Яндексе
[16:33.560 --> 16:38.720]  собеседуешься, написал, и тебе говорят, все, не прошел, почему? Вот давайте посмотрим, почему
[16:38.720 --> 16:43.520]  факториалом еще можно, хотя тоже ничего умного не было писать, факториал рекурсии, когда там
[16:43.520 --> 16:50.600]  нужен просто цикл и переменная, и памяти там будет требоваться меньше, и операции будет меньше
[16:50.600 --> 16:58.280]  на копирование дополнительной информации, потому что, я надеюсь, вы уже способны к 10 лекции написать
[16:58.280 --> 17:04.160]  факториал без рекурсия просто циклом, правда ведь? Накапливая как бы счетчик, правда? Вот,
[17:04.160 --> 17:11.120]  но хотя бы этот еще пример, он хорошо понятен, и мы его именно как учебный пример используем,
[17:11.120 --> 17:15.760]  хотя смысла писать здесь рекурсию на факториале не было, а здесь не то, что смысла писать нет,
[17:15.760 --> 17:23.680]  это просто убивает все, почему? Ну, давайте посмотрим, допустим, вызвал числа Fibonacci от 5,
[17:23.680 --> 17:28.480]  запустил эту функцию f с параметром 5, что получается? У меня здесь это не срабатывает,
[17:28.480 --> 17:37.760]  и у меня идет вызов 4, и он пока не закончился, потому что до этого второе слагаемое не
[17:37.760 --> 17:44.680]  посчитается, пока первое не посчитается, правда? 4 у меня это 3, соответственно, 3 у меня это 2,
[17:44.680 --> 17:52.080]  2-1 здесь я закончил, значит, после этого у меня здесь второе будет слагаемое, и снова 2,
[17:52.080 --> 17:59.480]  теперь у меня будет снова 3, и вот это все под дерево, сейчас мне придется, так, простите,
[17:59.480 --> 18:07.440]  да, здесь я перестарался, это все под дерево, 3 у меня будет небольшое вот это поддеревание,
[18:07.440 --> 18:18.200]  так, стоп, да, с счета я запутался, небольшое вот это под дерево у нас будет с вами дублироваться,
[18:18.200 --> 18:26.840]  вот у нас 2, здесь 2, теперь 5 это 4 плюс 3, соответственно, вот это 3, это вот это под дерево,
[18:26.840 --> 18:34.280]  сейчас мне придется его заново с вами переписать, 2 и 1 это 1 и 0, ну вроде как не так страшно,
[18:34.280 --> 18:39.920]  но допустим, у меня был бы вызов от 6, тогда что у меня происходит? 6 это 5 плюс 4, и тогда вот
[18:39.920 --> 18:46.440]  это все штука после того, как посчиталось, здесь начнем сочетаться заново, то есть 4 это 3 и 2,
[18:46.440 --> 18:56.240]  3 это 2 и 1, 2 это 1 и 0, 2 это 1 и 0, и если бы это было, например, 7, то это было бы 6,
[18:56.240 --> 19:03.080]  и 5, а 5 это уже вот это все, и вы видите, что стек-то здесь как раз не переполнится,
[19:03.080 --> 19:09.560]  у нас нет проблемы со стеком, его глубина небольшая, вот глубина стека, у нас проблема будет другая,
[19:09.560 --> 19:16.760]  здесь у вас не глубина, а ширина, что значит ширина, время выполнения, потому что вы одно и
[19:16.760 --> 19:24.760]  то же значение считаете много раз, пересчитываете его, и фактически, если посмотреть на сложность
[19:24.760 --> 19:30.280]  алгоритма, она экспоненциальная, вы учили сложности, и знаете, что экспоненциальная сложность
[19:30.280 --> 19:40.900]  тому большую, потому что при увеличении, это легко доказать, при увеличении n на 1,
[19:40.900 --> 19:50.440]  у меня сложность растет в два раза, потому что у меня сразу две ветки, и здесь вы будете там
[19:50.440 --> 19:57.280]  считать 4 часа или там сколько-то часов, значение равное 30, именно из-за сложности,
[19:57.280 --> 20:02.560]  потому что у вас линейная, обычная программа посчитала бы это циклом, просто берете две
[20:02.560 --> 20:09.520]  переменные, сдвигаете и складываете, вам не нужно ничего, а здесь вы сделаете вместо линейной
[20:09.520 --> 20:17.880]  сложности, вместо o от n, n переносите в степень, ну и все, и вы убиваете себя, и это ужасно,
[20:17.880 --> 20:23.160]  потому что это вы не понимаете тогда базовых принципов алгоритмов, что такое сложность, и вам
[20:23.160 --> 20:27.600]  кажется, что вообще эффективность не нужна, если вы так пишете, то что будет с вами дальше, как вы
[20:27.600 --> 20:33.760]  будете программировать, будете там, не знаю, эстер и лен писать в каждый фор, внутрь по пять раз,
[20:33.760 --> 20:39.080]  в выражениях эстер и лен, плюс эстер и лен, плюс два эстер и лена, еще давайте одним эстер и леном это
[20:39.080 --> 20:46.720]  все загоним, вот, и после этого у вас вот примерно таких программистов боятся и в нормальной it компании не
[20:46.720 --> 20:56.000]  берут, но если вас вдруг попросят написать рекурсивные фибоначи, бывает таки, я знаю подло интервью и
[20:56.000 --> 21:04.240]  видел я разные вопросы, много наших пусняков работает по всех it компаниях мира, и они рассказывают,
[21:04.240 --> 21:09.600]  человек там спрашивают, когда там в гугле они проходят собеседование, когда ты пишешь и какой-то
[21:09.600 --> 21:13.360]  индус тебя собеседует, ну как правило там очень много просто индусов, которые тоже крутые
[21:13.360 --> 21:18.280]  программисты как русские, он тебе дает код, он дает тебе задачу, смотрит как ты кодишь, причем не что-то там
[21:18.280 --> 21:24.320]  супер сложное, да, там может быть бин поиск, еще какие-то вещи, сортировочка, и в том числе могут
[21:24.320 --> 21:32.440]  попросить написать фибоначи рекурсивно, это задание с ловушкой, они надеются, что вы это понимаете,
[21:32.440 --> 21:38.480]  напишете по-другому, можно написать рекурсивно с помощью дополнительного параметра за нормальную
[21:38.480 --> 21:45.520]  сложность линейную, но это будет такая задачка на подумать для тех, кому интересно, а теперь
[21:45.520 --> 21:53.880]  последнее, что я хочу сказать про рекурсию, как вы думаете, если задачи, вообще можно ли обойтись
[21:53.880 --> 21:59.320]  без рекурсии, или вот бывает момент, когда без рекурсии вообще никак, вот вы в футболочке МФТИ,
[21:59.320 --> 22:11.360]  скажите, да, в черный, а что нам дает, давайте попробуем докопаться до принципа вообще,
[22:11.360 --> 22:19.520]  что нам дает рекурсия, что она такого делает, делает ли она что-то, что мы с вами не можем сделать
[22:19.520 --> 22:27.800]  сами, ведь если мы перейдем на уровень ниже, а мы с вами программисты C++ уже довольно программируем
[22:27.800 --> 22:33.720]  на низком уровне, да, мы понятны, что это спецукороний язык, но, тем не менее, это не питоны,
[22:33.720 --> 22:42.800]  не какой-нибудь скриптовой ноукод, тем не менее, мы что делаем в рекурсии, что дает рекурсия
[22:42.800 --> 22:50.040]  такого нашей программе, первое это цикл, почему, потому что она повторяет какие-то действия,
[22:50.040 --> 22:55.480]  это можно повторение реализовать циклом, но это не только цикл, что она еще добавляет,
[22:55.480 --> 23:01.640]  вот если посмотреть на вот то, что выписывал в стеке про factorial, что она добавила к этому циклу вызовов,
[23:01.640 --> 23:12.880]  да, ответите, да, на каждый вызов была переменная, это что, если все эти переменные объединить,
[23:12.880 --> 23:19.000]  это массив, то есть фактически рекурсия это стек плюс массив какой-то, то есть этот стек
[23:19.000 --> 23:23.640]  можно просто самим промоделировать, взять массив, туда все это нужный момент записывать,
[23:23.920 --> 23:27.360]  и поэтому все можно решить, конечно же, без рекурсии, потому что она не дает ничего нового,
[23:27.360 --> 23:31.360]  она просто автоматически делает массив, который на стеке создается во время этих вызовов,
[23:31.360 --> 23:36.720]  если мы, слепок, это не все понимают, но это кстати очень классно, если вы это сразу поймете,
[23:36.720 --> 23:40.760]  для вас рекурсия не будет какой-то такой загадкой, то есть слепок, если мы в стеке возьмем в текущий
[23:40.760 --> 23:44.600]  момент времени, это тот массив, который она автоматически создала, ну там может быть
[23:44.600 --> 23:48.920]  разный массив, не обязательно однотипный, у вас могут быть разные переменные,
[23:48.920 --> 23:54.120]  то есть там несколько массивов или массив-структур, а второй это цикл, который она вам организовывает,
[23:54.120 --> 24:00.440]  поэтому массив плюс цикл вам решает проблему, и тот же DFS мы можем написать как рекурсивно,
[24:00.440 --> 24:05.560]  так и не рекурсивно, то есть поэтому просто рекурсивно это будет проще за счет того,
[24:05.560 --> 24:09.440]  что часть работы за вас сделает компилятор, в частности автоматически в нужный момент
[24:09.440 --> 24:18.360]  организует вам хранение данных. Это все про рекурсию, и мы с вами сделаем небольшой
[24:18.360 --> 24:28.120]  прерыв 5 минуток, и после этого перейдем к новой нашей теме перечисления. Мы переходим
[24:28.120 --> 24:41.080]  к новым таким пользовательским типам данных, которые нам позволяют конструировать более
[24:41.080 --> 24:49.080]  сложные объекты. Синтаксис перечисления следующие, ену, перечисления еще были и в C,
[24:49.080 --> 25:03.280]  C++ просто немножечко их усовершенствовал, но они у нас были очень давно, имя типа и список
[25:03.280 --> 25:21.040]  целочисленных констант. Писок целочисленных констант. Иногда нам требуется с вами работать
[25:21.040 --> 25:27.960]  с константами, когда их некоторое ограниченное количество, например, мы хотим с вами возначить
[25:27.960 --> 25:34.960]  север, юг, запад, восток, дни, недели, еще что-то, и хотим это сделать константами. Чтобы подчеркнуть,
[25:34.960 --> 25:39.360]  что эти константы принадлежат какой-то одной сущности к одному типу данных, мы можем эти
[25:39.360 --> 25:43.520]  константы сделать типом перечисления, объявить их в нем. Тогда компилятор поможет вам контролировать
[25:43.520 --> 25:51.240]  типы, чтобы вы там не ошиблись, и кроме севера, запада, юга и востока использовали еще что-то
[25:51.240 --> 25:58.840]  несуществующего часть света, пятое измерение. Поэтому в этом случае вам компилятор опять же
[25:58.840 --> 26:10.160]  будет в помощь. Ну давайте на примере это покажем и объявим перечисления дни недели. То есть я хочу
[26:10.160 --> 26:17.760]  сделать константы, которые будут у меня обозначать дни недели, и объявлю перечисления, которые будут
[26:17.760 --> 26:32.400]  иметь ими типа days of week, дни недели. А сами константы будут иметь значения, которые мы с вами
[26:32.400 --> 26:47.320]  сейчас напишем, и имена этих констант будет днями недели. Потому что мы с вами как бы должны
[26:47.320 --> 26:53.240]  привыкнуть, что в программировании все на американский манер. У них дни недели тоже начинаются
[26:53.240 --> 26:59.720]  в воскресенье, потому что все языки у нас создавались. Большое влияние культурное США есть
[26:59.720 --> 27:13.360]  в программировании, вот так скажем. Вот, я честно не слышал, что вы сказали, но давайте к перечислению.
[27:13.360 --> 27:21.720]  Какие значения получат эти константы? На самом деле по умолчанию все понятно
[27:21.720 --> 27:28.200]  нумируется с нуля. Это будет 0, это 1, 2, 3, 4, 5, 6. То есть от нуля до 6 у вас получат значение дни
[27:28.200 --> 27:34.280]  недели. Таким мы не явно это сделали, мы это могли бы сделать явно. В следующем примере напишу,
[27:34.280 --> 27:39.760]  как это будет. Но здесь, когда вы не даете никакие значения константам, они всегда целочисленные,
[27:39.760 --> 27:44.960]  в перечислении у вас всегда только целочисленные константы, это их имена, и по умолчанию дается
[27:44.960 --> 27:48.840]  с нуля и следующая на единицу больше. Примерно как наше рекурсивное определение только что было для
[27:48.840 --> 27:59.560]  натуральных чисел. Опять же влияние США, что они с нуля. Значит int main. Теперь, когда у нас есть вот
[27:59.560 --> 28:04.280]  этот тип, можно объявлять переменные этого типа. Мы взяли с вами, сконструировали новый тип,
[28:04.280 --> 28:12.920]  новый тип данных, days of week. На прошлой лекции мы уже с вами делали новые типы с помощью TypeDev.
[28:12.920 --> 28:19.320]  Помните, для того чтобы простить себе жизнь, и существующие какие-то типы присваивали им
[28:19.320 --> 28:24.920]  новые имя. Так и здесь мы создали новый тип, тип называется days of week, и можно создать переменные
[28:24.920 --> 28:33.480]  этого типа D1, D2. Что хорошего, теперь компилятор будет контролировать, что D1 и D2 это переменные,
[28:33.480 --> 28:38.920]  которые можно присвоить только вот из этого набора, и не даст вам присвоить ничего другого.
[28:38.920 --> 28:48.160]  То есть, если я хочу что-то присвоить D1, то я должен написать имя какой-то константы,
[28:48.160 --> 28:55.600]  которые здесь есть. Я даже не могу написать там равно пяти, он не даст компилировать. D2.
[28:55.600 --> 29:09.520]  Пусть у меня будет это понедельник, а это четверг. Вот я объявил. Теперь я могу делать некие
[29:09.520 --> 29:15.400]  арифметические операции между ними. Например, я могу ввести переменную int, которая посчитает
[29:15.400 --> 29:21.780]  difference между ними, разницу, и вычесть одно из другого. Вот в этом случае при, там мы можем
[29:21.780 --> 29:28.900]  применять те же операции, которые допустимы к целочисленным переменным, и здесь произойдет
[29:28.900 --> 29:36.580]  неявное преобразование в int в этот момент. То есть из int в перечлении нельзя, из перечления в int
[29:36.580 --> 29:45.380]  можно. Результат будет 3. То есть значение этой константы, оно у вас подставится, у вас была
[29:45.380 --> 29:55.200]  эта единичка, это была четверка, 4-1, 3, и в этой переменной будет 3. Можем сравнивать,
[29:55.200 --> 30:06.560]  например, написать, если первый день меньше второго дня. То же самое, у вас будет сравниваться их
[30:06.560 --> 30:15.840]  целочисленные значения. Ну и дальше там что-то. То есть можно такие вещи писать, там cout,
[30:15.840 --> 30:30.760]  какое-нибудь сообщение. Перечисления имеют недостатки. В частности, если вы попробуете
[30:30.760 --> 30:39.280]  вывести его на экран, то есть напечатаете d1, то вы не получите красивое мандой на экране. Вы
[30:39.280 --> 30:43.240]  получите значение этой константы. То есть опять же будет неявное преобразование в int. Это очевидно
[30:43.240 --> 30:51.800]  почему. Это лишь имя, это имя константы. У нас некие имена в скомпилированном коде не хранятся. Ведь
[30:51.800 --> 30:58.720]  когда мы пишем программу, мы называем переменные. Можем назвать переменную i, можно написать
[30:58.720 --> 31:08.640]  горшок, а можно написать какое-нибудь очень длинное, длинное, длинное слово или несколько слов. Например,
[31:08.640 --> 31:16.040]  одно слово несколько раз, которое вот сейчас прозвучало, 20 раз через знак подчеркивания. И вы
[31:16.040 --> 31:21.680]  тем самым думаете, что компилятор будет каждую эту переменную хранить в памяти на ее имя. Зачем
[31:21.680 --> 31:27.520]  она ему нужна? Он, собственно, для этого компилирует, чтобы ваш бред привести в обычный машинный код.
[31:27.520 --> 31:32.120]  Там просто будет адрес того, где это хранится. Никаких имен там не будет. Там будут адреса и
[31:32.120 --> 31:37.480]  обращения к этим адресам. Поэтому понятно, что здесь имена это для вас, чтобы вы лучше читали код.
[31:37.480 --> 31:44.800]  Ему не нужны никакие имена, ему нужны цифры, адреса и так далее. Поэтому именно так оно и
[31:44.800 --> 31:50.680]  рабосмещение, оно именно так и работает. Поэтому он знает, где это хранится, и знает, чему оно равно.
[31:50.680 --> 31:56.360]  Так, а вот эта проверка, которая здесь, почему вы можете спросить, вот здесь же он знает,
[31:56.360 --> 32:00.520]  потому что это на этапе компилианции узнает. Когда он скомпилировал все, а вашей программе забыли,
[32:00.520 --> 32:04.720]  есть машинный код, который ничего не знал, как его создали, и он уже выполняется. Вот, собственно,
[32:04.720 --> 32:17.320]  задача компилятора. С вашего языка она… Да. Ну, это проблема, потому что у нас нет явного
[32:17.320 --> 32:24.000]  преобразования, вы не можете ввести. Вы можете только задать. И вот сейчас еще важный момент,
[32:24.200 --> 32:31.080]  как их задавать нестандартно. Смотрите, сейчас я сделаю перечисление, которого не будет имя типа,
[32:31.080 --> 32:43.040]  мы можем также сделать, но в нем будут только некие константы. Все, мы закончили вообще эту
[32:43.040 --> 32:55.560]  штуку, все закрыли и забыли, и сделали какую-то константу, например, и начали прямо присваивать
[32:55.560 --> 33:08.800]  значения. Это можно делать, можете сами присваивать значения. Какой-то момент вам надоело
[33:08.800 --> 33:18.680]  присваивать значения, тогда следующее значение будет плюс один от предыдущего. Можно даже
[33:18.680 --> 33:25.800]  выражение здесь писать, например, ten plus forty, fifty равно ten plus forty. Я могу даже дальше пойти,
[33:25.800 --> 33:31.680]  чем в этом примере. Можно заново начать, можно сделать там три, и после этого, если вы не напишете,
[33:31.680 --> 33:35.840]  будет четыре по умолчанию, то есть он будет приводить единичку к последней, но это так никто
[33:35.840 --> 33:41.080]  не делает, потому что хорошо бы вам по возрастанию их писать, чтобы потом код было удобно читать.
[33:41.080 --> 33:47.320]  Если вам совсем интересно, даже можно делать одинаковые константы, то есть разные имена на одно
[33:47.320 --> 33:52.200]  значение. Такое может понадобиться, может, у вас там есть синонимы для пятерки, вы хотите,
[33:52.200 --> 33:59.040]  чтобы так и так можно было. То есть это тоже будет работать. Какие еще вообще есть разумные
[33:59.040 --> 34:12.960]  примеры перечисления? Ну, например, перечисления, можно сделать переключатель. У вас выключено это
[34:12.960 --> 34:23.400]  нолик, включено это один, и ну это как бы логично, но просто чтобы 0,1 написать, вы можете более красивые
[34:23.400 --> 34:30.240]  константы себе ввести, и компилятор будет контролировать, что у вас именно они используются в нужном
[34:30.240 --> 34:37.200]  типе данных. Например, еще может быть какое-нибудь там перечисление, относящееся обязательно к одной
[34:37.200 --> 34:45.720]  сущности должно быть, например, по времени. Вы знаете, что в стране, которую я упомянул, есть такая
[34:45.720 --> 34:53.880]  система времени, связанная с меридианом и mpm, и вот такое перечисление. Не только 24-часовая,
[34:53.880 --> 35:01.240]  но и 12-часовая там система принята. Нет, я написал с большой буквы, просто, наверное, плохо видно,
[35:01.240 --> 35:11.560]  простите. С большой буквы да, потому что это уже другое. Так, ну а перечисления, вообще чем
[35:11.560 --> 35:17.840]  перечисления, если еще посмотреть, отличаются тента? Вообще, зачем они нам нужны, почему нельзя
[35:17.840 --> 35:23.960]  просто интом все делать? Во-первых, да, у них есть некая общая сущность, во-вторых, их немного,
[35:23.960 --> 35:34.400]  вот, например, я не знаю, север-юг, запад-восток. Вот у вас четыре каких-то объекта, из них можно
[35:34.400 --> 35:40.480]  сделать хорошо перечисления, потому что их ограниченное количество, они имеют какой-то смысл,
[35:40.480 --> 35:47.200]  их понятно как назвать, и нужно контролировать. Когда же объектов у вас много, например, не знаю,
[35:47.200 --> 35:54.520]  какие-то игроки выиграют игру, их пронумеровали до 456, и тогда, конечно, не надо делать такое
[35:54.520 --> 36:02.000]  перечисление, потому что, ну, вам, во-первых, у них нет имен, вот есть такая игра, был недавно
[36:02.000 --> 36:07.480]  сериал, там у игроков не было имена, вы не можете сделать перечисления, если их сделали, если у вас
[36:07.480 --> 36:11.760]  объекты не имеют имен, это явный пример, когда перечисления неприменимы, потому что здесь у вас
[36:11.760 --> 36:22.160]  север-запад, восток-юг, можно написать там south, да, north и так далее, west-east, а здесь у вас,
[36:22.160 --> 36:25.080]  если только номера, вы не можете сделать перечисления, это первое, когда вы не можете
[36:25.080 --> 36:31.360]  делать перечисления, второе, даже если вы узнаете имена персонажей в этом сериале, все 456,
[36:31.360 --> 36:37.560]  то вы все равно не можете их сделать перечисления, потому что это очень странное будет перечисление
[36:37.560 --> 36:43.080]  с таким количеством значений, поэтому вы должны использовать всегда в программировании принцип
[36:43.080 --> 36:51.480]  разумности, у вас не должно быть кода, который невозможно легко прочитать, читать 456 констант
[36:51.480 --> 36:58.880]  очень неудобно, вот, поэтому ограничивайтесь там, не знаю, 12-15, но это, наверное, совсем максимум,
[36:58.880 --> 37:03.400]  которые можно для перечисления брать, а лучше вот такие простые примеры, которые у нас были там
[37:03.400 --> 37:09.560]  дни недели и так далее. При перечислении всё, и переходим к нашей следующей теме, структуры.
[37:16.080 --> 37:23.880]  Структуры появились в языке C, но C++ их сильно преобразил, тем не менее, начнём с базовой идеи,
[37:24.200 --> 37:32.680]  зачем структуры появились у нас в языке C. У нас были массивы, массив хранит информацию о
[37:32.680 --> 37:37.560]  нескольких объектах, о нескольких каких-то свойствах объекта, но массив имеет главное
[37:37.560 --> 37:42.600]  свойство, какое, что все элементы должны быть одного типа, вот если мы захотим, например,
[37:42.600 --> 37:49.760]  представить элемент «студент», у вас есть параметры разного типа, вот, например, я не знаю, вот вы,
[37:49.760 --> 37:56.680]  в красной футболке, да, вот вы, да, вот вы, вы студент, у вас есть имя, как вас зовут? Артём,
[37:56.680 --> 38:02.920]  это какой тип данных, Артём, ваше имя? Чар-звёздочка, что за чар, у вас имя за одну букву, что ли?
[38:02.920 --> 38:16.120]  Чар-звёздочка, значит, давайте какой-нибудь интовский, вот ваш рост, 175, хорошо, стипендия,
[38:16.120 --> 38:21.520]  это, наверное, long-double, я думаю, что поместилось, это фистех, поэтому здесь самые большие стипендии,
[38:21.520 --> 38:29.120]  вот, то есть мы видим, что у Артёма, как минимум, мы уже нашли чар-звёздочку, уже инт, уже даббл,
[38:29.120 --> 38:37.680]  если поискать в закромах, то можно, наверное, все типы придумать, да, сколько там зубов у Артёма,
[38:37.680 --> 38:45.120]  я не знаю, и так далее, чтобы описать сущность «студент», и в этом случае массив для Артёма не
[38:45.120 --> 38:49.520]  подойдёт, потому что имя это, например, чар-звёздочка, а размер во стипендии это long-double,
[38:49.520 --> 38:56.440]  и нам, что ты загрустил, Артём, вспомнил про стипендию, ничего страшного, у тебя будет повышенное,
[38:56.440 --> 39:08.800]  сдашь на все пятёрки первую сессию, я уверен, вот, хорошо, Артём, сравним после сессии, будет ли у
[39:08.800 --> 39:21.720]  тебя средний балл 5 или выше? Вот, значит, я думаю, что, соответственно, структуры появились как раз для
[39:21.720 --> 39:27.400]  хранения информации разного типа в одном таком объекте, где у нас есть некая физическая сущность,
[39:27.400 --> 39:33.600]  мы хотим описать её свойства, например, не знаю, вот телевизор у него, есть там длина диагонали,
[39:33.600 --> 39:42.440]  есть цвет, есть цена, есть ещё страна выпуска, и всё это данные разного типа, а я не хочу хранить это
[39:42.440 --> 39:46.200]  в разных переменах, хочу в одной переменной телевизор, для этого и придумали структуры,
[39:46.200 --> 39:56.120]  они изначально все такими и родились, и объявляются структуры, следующим образом мы пишем стракт,
[39:56.120 --> 40:09.880]  после этого имя типа, фигурная скобка, и объявляются поля структуры, каждое поле имеет какой-то тип,
[40:09.880 --> 40:16.560]  вот как я на примере про Артёма или телевизор рассказывал, тип элемент 1, и это у нас какой-то
[40:16.560 --> 40:27.080]  тип 2, это вот второе поле, да, какое-то имя переменной, элемент 2 и так далее, может быть у нас много
[40:27.080 --> 40:34.760]  разных типов, несколько элементов могут иметь один и тот же тип, закрывается фигурная скобочка,
[40:34.760 --> 40:44.560]  здесь необычная, дальше у нас, может быть вы не привыкли ещё, есть возможность описать этого,
[40:44.560 --> 40:52.720]  мы завели тип и сразу создать переменные этого типа, то есть я могу здесь написать список
[40:52.720 --> 41:03.040]  описателей, у меня это называется формально, он не обязателен, поэтому он квадрат на скобках,
[41:03.040 --> 41:12.880]  и здесь у нас могут быть переменные, указатели или массивы, переменные, указатели или массивы,
[41:12.880 --> 41:22.080]  и точка запятой ставится, и вот это вынос мозга, особенно там, потому что мы иногда не можем
[41:22.080 --> 41:28.120]  не писать список описателей, опустить его, и тогда будет тот случай, когда после фигурной скобки
[41:28.120 --> 41:32.080]  ставится точка запятой, она обязательно, если вы не поставили, потому что вот строчка у вас начинается,
[41:32.080 --> 41:38.840]  и надо закончить, и у вас не скомпилируется, вот эту точку запятой не забываем никогда ставить,
[41:38.840 --> 41:43.320]  давайте напишем структуру студент, про которую я рассказывал,
[41:43.320 --> 42:11.520]  пусть у меня будет некий массив piu,
[42:11.520 --> 42:27.240]  из 30 букв, я думаю, нам хватит, если нет, расширим, например, у вас может быть какой-то
[42:27.240 --> 42:37.120]  int, номер, там, не знаю, ну, там, рост, там, hate, то, что мы говорили, и стипендия, да, у нас,
[42:37.120 --> 42:43.800]  double, давайте, ладно, спустимся с небес на землю, double хватит, я думаю, вот, double,
[42:43.800 --> 42:54.880]  там, salary, зарплата, да, и все, мы закрыли с вами структуру, и теперь я могу создать сразу,
[42:54.880 --> 43:06.640]  просто объекты, которые я упомянул, то есть, я могу сделать, например, массив, там, вот наша fpmi,
[43:06.640 --> 43:19.320]  нет, не fpmi, у нас есть базовый поток fpmi, f-p-m-i, базовый, видите, bmf, в общем, вот это,
[43:19.320 --> 43:26.480]  и сразу создать сколько нас, там, 120 человек, вот я создаю сразу 120 Артемов, 120 таких структур
[43:26.480 --> 43:32.640]  мы создали, куда мы сможем записывать про каждого данные, можно при указатель,
[43:32.640 --> 43:41.760]  pointer на нашего студента, вот, собственно, пример этого синтаксиса, который был,
[43:41.760 --> 43:55.440]  мы могли с вами не писать, не список описать или опустить его, вы успели это переписать,
[43:55.440 --> 44:07.280]  я могу здесь стереть, да, Артем, вы руку подняли, ладно, мы могли здесь не писать,
[44:07.280 --> 44:11.760]  а поставить точку запятой, тогда бы я просто объявил тип, а, да, я, конечно, тупо сделал,
[44:11.760 --> 44:19.120]  я сказал, вы успели, вы сказали, нет, а я стер, и, простите, я просто хотел, я боюсь, чтобы все успеть,
[44:19.120 --> 44:28.600]  я поэтому спросить должен, да, мнение спросил, мнение профсоюзного комитета студента пустяно,
[44:28.600 --> 44:38.720]  поэтому, вот, значит, поэтому отчисляем, значит, мы можем не писать здесь никакие описатели,
[44:38.720 --> 44:43.680]  то есть не делать никакие переменные, никакие массивы, никакие указатели, а у нас теперь есть
[44:43.680 --> 44:47.880]  новый тип, мы можем просто объявлять ниже в любом месте переменные этого типа, то есть,
[44:47.880 --> 44:51.800]  как обычно, ind, например, пишем ind, какая-то переменная, так и здесь я могу написать,
[44:51.800 --> 45:01.760]  вот это наша bfpmi, тот же самый массив от 120, например, сделать и указатель, то есть,
[45:01.760 --> 45:06.320]  не обязательно объявлять там сразу, вы можете объявить это потом, потому что тип у вас уже есть,
[45:06.320 --> 45:16.440]  вот этот тип student, здесь у вас тот же самый тип student, мало того, можно это стереть? Хорошо,
[45:16.520 --> 45:21.120]  вы уже научены, да, поэтому, когда в следующий раз спросите, вы всё равно, зачем говорить,
[45:21.120 --> 45:30.400]  да, нет, всё равно я сотру, я справлюсь, можно здесь сразу, например, объявить ещё один пример
[45:30.400 --> 45:38.280]  какого-то студента и задать ему начальное значение, например, Артём, так его и назвали,
[45:38.280 --> 45:47.400]  с большой буквы, вот, и Артём равен, и в фигурных скобках, так как мы обычно инициализировали,
[45:47.400 --> 45:52.920]  например, массивы, мы сейчас проинциализируем Артёма, разные поля через запятую, значит,
[45:52.920 --> 46:06.800]  его фио, там Иванов, его фамилия, допустим, его рост 1,775 и его стипендия, сейчас мы напишем,
[46:06.800 --> 46:18.400]  55 678 рублей 91 копейка, вот, значит, Артём, наверное, межнар у нас, поэтому у него повышенная стипендия, так,
[46:18.400 --> 46:37.840]  а мысли без точки вообще, да, сейчас мы будем, теперь как проинциализировать массивы структур,
[46:37.840 --> 46:45.920]  давайте запишем маленький подпункт, инициализация массивов структур,
[46:49.400 --> 47:02.400]  пусть у меня есть некая структура, которая, например, содержит в себе значение комплексного числа,
[47:02.400 --> 47:19.640]  в ней есть два поля типа float, real и im, я сразу же, где объявил новый тип, сейчас конструирую массив этого
[47:19.640 --> 47:28.160]  типа и назову его compel, это будет двумерная матрица из комплексных чисел, размера 2 на 3,
[47:28.160 --> 47:40.280]  как мне его проинциализировать, также ставлю здесь фигурную скобку, теперь по строкам и
[47:40.280 --> 47:46.160]  каждый элемент структуры еще в своей фигурной скобке, поэтому здесь получается три фигурные
[47:46.160 --> 47:53.760]  открывающие скобки подряд, потому что первый элемент 1 1 это вот как раз структура, каждый
[47:53.760 --> 47:58.880]  элемент структуры это элемент массива, то есть это первая строка, стоящая из трех у нас столбцов,
[47:58.880 --> 48:05.440]  допустим они все одинаковые, и закрываю первую строку, ставлю также запятую и
[48:05.440 --> 48:16.800]  инициализирую теперь вторую строку аналогичным образом, вот я инициализирую многомерный массив,
[48:16.800 --> 48:23.000]  и когда я закончил, я закрываю теперь фигурную скобку для начальной инициализации, ставлю точку
[48:23.400 --> 48:43.320]  вот у нас как это получилось, теперь как получить то, как хотите, во-первых, это не важно,
[48:43.320 --> 48:50.840]  хотите как напишите, я же говорю, всегда тип данных, как я хочу, если это не ключевое слово,
[48:51.080 --> 49:01.920]  если я копирую одну структуру в другую, то есть если я присвоил, если я хочу скопировать одну
[49:01.920 --> 49:06.600]  структуру в другую одного типа, я могу просто их присвоить, например, если у меня есть два элемента,
[49:06.600 --> 49:18.200]  Артем и гор, если я хочу скопировать они одного типа student, если присваиваю Артем гору,
[49:18.280 --> 49:24.760]  то просто все поля скопируются из того, от чего мы присваиваем, тому,
[49:24.760 --> 49:31.840]  что мы присваиваем, то есть происходит элементное копирование при присваивании двух структур,
[49:31.840 --> 49:38.720]  но они должны быть одного типа, теперь давайте запишем маленький подзаголовочек доступ к полям структур,
[49:48.200 --> 50:02.080]  да, этот тип и есть тип структуры, да, итак, у нас есть операция точка с помощью этой операции,
[50:02.080 --> 50:08.920]  она у нас даже была в списке фриоритетов, мы можем с вами получать доступ к поле структуры,
[50:08.920 --> 50:15.000]  так называемой операции выбора, например, если у нас есть структура Артем, Артем,
[50:15.000 --> 50:22.840]  прости, что сегодня все примеры на тебе, то мы можем поставить точку и,
[50:22.840 --> 50:37.080]  например, обратиться его фамилии, либо, если это какой-то массив, вот, например,
[50:37.080 --> 50:44.200]  у нас был компл, мы можем также через элементы массива обращаться, более интересно,
[50:44.200 --> 50:52.920]  что бывает, если у нас с вами есть указатель, давайте вот здесь, помним, что у нас было недавно
[50:52.920 --> 51:08.200]  написано, где, например, я объявил некую, где я объявил некую перемену, являющуюся указателем
[51:08.200 --> 51:23.080]  на эту структуру, это PS. Как мне сейчас обратиться к полю фио от указателя на структуру? Стандартным,
[51:23.080 --> 51:32.760]  старым, добрым C, я должен что сделать? Если это у меня указатель, я должен его разыменовать,
[51:32.760 --> 51:41.760]  правильно? Как мы разыменовываем указатель? Какой амперсант? Теперь скобочка мне нужна,
[51:41.760 --> 51:46.320]  поскольку там приоритеты, у нас еще сейчас сломаются, если мы ее не поставим, чтобы точка
[51:46.320 --> 51:52.640]  не перетянула и взять точку, вот что было, то из этого сделали все плюс-плюс, поняли,
[51:52.640 --> 51:57.520]  что это так часто нужно, сделали специальную операцию, которая называется стрелочка,
[51:57.520 --> 52:04.240]  мы можем теперь написать PS, стрелочка, которая просто пишется как минус и знак больше,
[52:04.240 --> 52:19.360]  и, например, доступ к полю селари и присвоили что-то там, здесь тоже Иванов, вот так мы можем с вами
[52:19.360 --> 52:28.360]  получать доступ к элементам структуры по старому и по новому, и последнее, что я хотел сказать,
[52:28.360 --> 52:38.200]  это структуры на самом деле в C были именно тем, что я рассказал, но без стрелочки, стрелочка это
[52:38.200 --> 52:45.920]  уже C++-ная штука, которые позволяли нам работать с элементами, объединять элементы разного типа
[52:45.920 --> 52:52.640]  в один тип, C++ объектно-ориентированный язык, и главная сущность здесь классы,
[52:52.640 --> 52:55.480]  у вас вообще будет целый курс, который называется объектно-ориентированное программирование
[52:55.480 --> 53:02.680]  в целый второй семестр, и классы это не только данные, но и некие действия над этими данными,
[53:02.680 --> 53:10.040]  именно методы, и поэтому у нас есть класс, который фактически является продолжением структуры,
[53:10.040 --> 53:15.680]  но в новом синтезе C++ в структуре можно все делать то же самое, там тоже можно писать методы,
[53:15.760 --> 53:22.280]  фактически вы можете делать не класс, а структуру, но есть некие отличия, и эти отличия, самое главное,
[53:22.280 --> 53:28.320]  которое вы должны знать, кроме там есть еще элемент с наследованием, заключается в том,
[53:28.320 --> 53:35.800]  что если в классах по умолчанию все поля закрытые, а здесь все поля открытые, главное,
[53:35.800 --> 53:39.240]  что мы должны понять, что здесь все поля открытые, к ним может каждый обращаться,
[53:39.240 --> 53:45.200]  и извне вот я вот такое могу делать, потому что в C++, если бы такое написал, поле было бы закрытое,
[53:45.200 --> 53:50.440]  я бы не смог обратиться к внутренностям, если бы я не открыл специальным образом это поле или
[53:50.440 --> 53:55.520]  не сделал через специальный метод, а здесь у меня все открытое. Все, на этом наша лекция закончена,
[53:55.520 --> 53:57.160]  и мы с вами увидимся через неделю.
