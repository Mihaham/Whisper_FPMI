[00:00.000 --> 00:09.600]  Так, ну что, у нас все еще потоки.
[00:09.600 --> 00:16.080]  Давайте пример задачки рассмотрим.
[00:16.080 --> 00:18.360]  На самом деле это просто поиск максимального прочесания
[00:18.360 --> 00:32.320]  в вдвудольном графе.
[00:32.320 --> 00:34.680]  Как можно ее решать с помощью потока?
[00:34.680 --> 00:39.440]  Это было у всех на семинарах или нет?
[00:39.440 --> 00:40.600]  Хорошо.
[00:40.600 --> 00:42.240]  Значит,
[00:42.240 --> 00:44.040]  делаем следующее. Ну вот есть у нас
[00:44.040 --> 00:45.400]  стандартный вдвудольный граф.
[00:45.400 --> 00:48.240]  Два множества вершин LR.
[00:48.240 --> 00:49.960]  Давайте я сделаю следующее. Я веду
[00:49.960 --> 00:53.320]  фиктивные новые вершинки S и T,
[00:53.320 --> 00:55.800]  не принадлежащие ни одной из долей.
[00:55.800 --> 00:57.320]  Проведу из S
[00:57.320 --> 00:59.520]  ребра единичной пропускной способности
[00:59.520 --> 01:01.320]  во все вершины левой доли,
[01:01.320 --> 01:03.240]  и наоборот из всех вершин правой доли
[01:03.240 --> 01:08.000]  проведу единичные ребра в T.
[01:08.000 --> 01:10.080]  А ребра между долями я ориентирую
[01:10.080 --> 01:11.680]  слева направо и тоже сделаю единичные
[01:11.680 --> 01:13.760]  копасти. То есть все ребра графа
[01:13.760 --> 01:15.360]  вдвудольного, которые у нас здесь были,
[01:15.360 --> 01:17.160]  я просто ориентирую слева направо так же,
[01:17.160 --> 01:18.600]  как они были раньше,
[01:18.600 --> 01:20.640]  и назначаю им копасти 1.
[01:20.640 --> 01:21.880]  То есть здесь все такие же ребра,
[01:21.880 --> 01:23.640]  какие были в исходном графе.
[01:23.640 --> 01:25.440]  И вот я утверждаю, что поток в такой сети
[01:25.440 --> 01:27.120]  в точности по размеру равен максимальному
[01:27.120 --> 01:28.240]  просочетанию.
[01:28.240 --> 01:31.000]  Более того, любой поток здесь
[01:31.000 --> 01:32.640]  и любое просочетание в исходном
[01:32.640 --> 01:34.400]  графе, они в каком-то смысле друг другу
[01:34.400 --> 01:36.680]  соответствуют.
[01:36.680 --> 01:40.720]  Значит, любое просочетание
[01:40.720 --> 01:43.000]  соответствует какому-то потоку.
[01:43.040 --> 01:44.840]  Значит, максимальное просочетание будет
[01:44.840 --> 01:46.680]  соответствовать максимальному потоку.
[01:46.680 --> 01:48.280]  Соответственно, очень простое.
[01:48.280 --> 01:50.080]  Смотрите, как вообще здесь устроен
[01:50.080 --> 01:51.360]  поток в этой сети.
[01:51.360 --> 01:53.680]  Поскольку у меня граф на самом деле
[01:53.680 --> 01:55.760]  ациклический,
[01:55.760 --> 01:57.560]  ориентированный ациклический граф,
[01:57.560 --> 01:59.520]  якобы все ребра слева направо,
[01:59.520 --> 02:00.720]  поэтому
[02:00.720 --> 02:02.880]  поток он всегда распадается на
[02:02.880 --> 02:05.880]  несколько путей, вот таких вот из S в L,
[02:05.880 --> 02:08.320]  потом в R, потом в T. То есть любой путь,
[02:08.320 --> 02:10.560]  который задействуется в потоке, он какой-то такой.
[02:10.560 --> 02:11.720]  То есть дошли до сюда,
[02:11.720 --> 02:14.320]  потом взяли ребро
[02:14.320 --> 02:16.120]  исходного графа, поместились сюда,
[02:16.120 --> 02:18.400]  и дальше уже в T
[02:18.400 --> 02:20.880]  потекла т-нечка потока.
[02:20.880 --> 02:23.320]  Ну и при этом, понятное дело, что все вот эти
[02:23.320 --> 02:25.640]  вот пути из трех ребер, они не пересекаются
[02:25.640 --> 02:27.720]  вообще, ну кроме S и T,
[02:27.720 --> 02:29.480]  потому что вот этих вот ребер копасть
[02:29.480 --> 02:32.200]  единичка. То есть мы не можем как-нибудь
[02:32.200 --> 02:33.880]  попасть вот сюда вот два раза в одну
[02:33.880 --> 02:34.720]  ту же вершину,
[02:34.720 --> 02:36.480]  или как-нибудь вот сюда вот мы не можем попасть,
[02:36.480 --> 02:38.160]  потому что отсюда мы никак не можем
[02:38.160 --> 02:40.120]  уйти, кроме как используя это ребро.
[02:40.200 --> 02:42.400]  Поэтому все вершины, которые мы используем,
[02:42.400 --> 02:44.400]  за исключением крайних S и T,
[02:44.400 --> 02:46.400]  они у нас используют по одному разу.
[02:46.400 --> 02:48.680]  Но поэтому используемые вот здесь
[02:48.680 --> 02:51.000]  вот по центру ребра, это по рассочетанию обязательно.
[02:51.000 --> 02:52.680]  Потому что те ребра, которые я задействую,
[02:52.680 --> 02:54.000]  по которым я пускаю поток,
[02:54.000 --> 02:56.120]  они все попарно имеют различные концы.
[02:56.120 --> 02:58.160]  То есть скажем вот такой путь.
[03:02.160 --> 03:03.720]  Ну и еще какой-нибудь. Они все имеют попарно
[03:03.720 --> 03:05.000]  различные концы.
[03:05.000 --> 03:07.800]  Значит поток имеет всегда размер
[03:07.800 --> 03:09.120]  такой же, как по рассочетанию,
[03:09.120 --> 03:12.120]  которое он образует вот здесь вот между дарами.
[03:12.120 --> 03:16.120]  Ну, поэтому максимальный поток – это просто максимальное просчитание в этом графе.
[03:16.120 --> 03:18.120]  Окей?
[03:18.120 --> 03:22.120]  Ну и тогда, если мы применим к этой сети какой-нибудь хороший алгоритм,
[03:22.120 --> 03:25.120]  например, алгоритм Динница, и как-нибудь хорошо его оценим,
[03:25.120 --> 03:30.120]  то мы получим крутую симптотику на то, за сколько можно находить максимальное просчитание.
[03:30.120 --> 03:35.120]  Ну вот давайте показаново просто оцениваем, давайте почитаем потенциал в этой сети.
[03:35.120 --> 03:39.120]  Значит, у СТ потенциал нулевой, потому что в С ничего не входит, в Т ничего не выходит,
[03:39.120 --> 03:44.120]  а у всех этих вершин потенциал единичка на самом деле,
[03:44.120 --> 04:03.120]  потому что здесь у этих вершин входящая капасти 1, а у этих вершин исходящая
[04:03.120 --> 04:07.360]  Итерацией, мы знаем по первой теории Микарзановой,
[04:07.360 --> 04:13.800]  итерацией в алгоритме единица будет от корни из В.
[04:13.800 --> 04:17.360]  Но поскольку сеть еще единичная, а мы в прошлый раз замечали,
[04:17.360 --> 04:19.760]  что на единичной сети одна итерация работает за от
[04:19.760 --> 04:26.280]  Е.
[04:26.280 --> 04:37.760]  Следовательно, каждая итерация работает за от Е.
[04:37.760 --> 04:44.800]  Мы все перемножаем, получаем асимптотику е корни из В.
[04:44.800 --> 04:47.720]  За столько мы умеем находить Макс парсуэль в индуарном
[04:47.720 --> 04:48.720]  графе.
[04:48.720 --> 04:59.280]  Это называется алгоритм Хобкрафта Карпа.
[04:59.280 --> 05:01.600]  Собственно, алгоритм просто построить такую сеть, запустить
[05:01.600 --> 05:02.600]  на ней алгоритм единица.
[05:02.600 --> 05:03.600]  Очень просто.
[05:03.600 --> 05:04.600]  Здесь не единица.
[05:04.600 --> 05:08.400]  Если аккуратно оценить, то получается вот такая
[05:08.400 --> 05:09.400]  асимптотика.
[05:09.400 --> 05:11.440]  Это, как всегда, оценка сверху.
[05:11.440 --> 05:15.560]  Возможно, он еще быстрее что-нибудь найдет.
[05:16.400 --> 05:23.760]  Ну хорошо, тогда идем дальше.
[05:23.760 --> 05:27.320]  Следующий сюжет – это глобальный минимальный разрез и алгоритм
[05:27.320 --> 05:28.320]  Шторвагнера.
[05:28.320 --> 05:46.240]  Это поиск минимального глобального разреза.
[05:46.240 --> 05:47.240]  Шторвагнера.
[05:47.240 --> 05:48.240]  Ну это фамилия.
[05:48.240 --> 05:49.240]  А, предыдущий.
[05:49.240 --> 05:50.240]  А, предыдущий.
[05:50.240 --> 05:51.240]  Хобкрафт Карп.
[05:51.240 --> 05:52.240]  Карп.
[05:52.240 --> 05:53.240]  Карп.
[05:54.160 --> 05:55.160]  Карп.
[05:55.160 --> 05:56.160]  Карп.
[05:56.160 --> 05:57.160]  Такой же, как Эдманс Карп.
[05:57.160 --> 05:58.160]  Только Хобкрафт Карп.
[05:58.160 --> 05:59.160]  Вот.
[05:59.160 --> 06:09.480]  Следующий алгоритм – это поиск минимального глобального
[06:09.480 --> 06:11.480]  разреза в неориентированном графе.
[06:11.480 --> 06:13.680]  Ну неориентированном на самом деле для удобства.
[06:13.680 --> 06:15.160]  Там вроде не сильно важно, что он ориентированный
[06:15.160 --> 06:16.160]  или нет.
[06:16.160 --> 06:18.040]  Ну давайте я для простоты считаю, что он неориентированный.
[06:18.040 --> 06:19.040]  Вот.
[06:19.040 --> 06:22.160]  Чуть как минимальный глобальный разрез.
[06:22.240 --> 06:25.440]  Смотрите, у нас раньше тоже были разрезы, но они были
[06:25.440 --> 06:27.440]  в каком-то смысле чуть-чуть зафиксированными.
[06:27.440 --> 06:30.160]  У нас всегда были выделены S маленькая и T маленькая.
[06:30.160 --> 06:32.400]  Я всегда говорю, что разрез – это такое разбиение всех
[06:32.400 --> 06:35.000]  вышин на два множества, что S маленько в S большом,
[06:35.000 --> 06:36.400]  а T маленько в T большом.
[06:36.400 --> 06:40.880]  Да, значит, напоминаю, разрез в обычном понимании – это
[06:40.880 --> 06:45.280]  когда у меня фиксированы какие-то вершинки, и дизинктное
[06:45.280 --> 06:47.400]  объединение наших множеств – это все вершины.
[06:47.400 --> 06:48.400]  Вот.
[06:48.400 --> 06:51.920]  Значит, когда я говорю глобальный разрез, я отказываюсь вот
[06:51.920 --> 06:52.920]  от этих двух требований.
[06:52.920 --> 06:55.200]  То есть я отказываюсь от того, что какие-то вершины
[06:55.200 --> 06:56.200]  где-то фиксированы.
[06:56.200 --> 06:59.640]  Мне нужно просто среди всех возможных разбиений V на
[06:59.640 --> 07:00.640]  два множества.
[07:00.640 --> 07:04.560]  Ну, видимо, надо потребовать не пустоту, да, потому что
[07:04.560 --> 07:06.920]  если возьму все вершины, то это будет неинтересно.
[07:06.920 --> 07:08.400]  Мне нужно просто сказать, что они не пустые.
[07:08.400 --> 07:09.400]  Вот.
[07:09.400 --> 07:14.320]  Чтобы хоть какие-то вершины в них лежали.
[07:14.320 --> 07:19.120]  И, как всегда, мне нужно посчитать сумму capacity всех
[07:19.120 --> 07:22.960]  ребер между долями, то есть из S в T, и в данном случае
[07:22.960 --> 07:23.960]  минимизировать ее.
[07:23.960 --> 07:24.960]  Да.
[07:24.960 --> 07:25.960]  Не ориентированным графе.
[07:25.960 --> 07:26.960]  Не ориентированным графе, да.
[07:26.960 --> 07:27.960]  Вот.
[07:27.960 --> 07:33.720]  Значит, ну понятно, да, вот этот, собственно, глобальный
[07:33.720 --> 07:36.720]  разрез.
[07:36.720 --> 07:37.720]  Глобальный разрез.
[07:37.720 --> 07:38.720]  Вот.
[07:38.720 --> 07:42.040]  И давайте я еще для удобства введу такое обозначение,
[07:42.040 --> 07:45.240]  которое я уже когда-то использовал, ну еще раз могу написать.
[07:45.360 --> 07:52.400]  Значит, если A и B это произвольное подношение множество вершин,
[07:52.400 --> 07:59.480]  то через C от A в B я буду обозначать сумму capacity текущих
[07:59.480 --> 08:04.480]  из A в B.
[08:04.480 --> 08:07.360]  Потому что это я говорил, что в обычном разрезе у меня
[08:07.360 --> 08:09.240]  фиксированы какие-то старты конец.
[08:09.240 --> 08:10.960]  А здесь я отказываюсь от этого требования, перехожу
[08:10.960 --> 08:12.560]  к глобальному разрезу, у меня нет фиксированных
[08:12.560 --> 08:13.560]  вершин.
[08:13.560 --> 08:14.560]  Вершина S маленькая, t маленькая.
[08:14.560 --> 08:22.760]  Значит, что такое C от A в B, это просто сумма по всем
[08:22.760 --> 08:27.360]  возможным парам у из A в из B, capacity у в.
[08:27.360 --> 08:30.880]  Ну, то есть, в нашем случае вот здесь вот все вот эти
[08:30.880 --> 08:33.440]  ребра, да, это как раз ребра пересекающий разрез, и
[08:33.440 --> 08:36.400]  мне нужно минимизировать вот в таких вот условиях
[08:37.400 --> 08:38.400]  CST.
[08:38.400 --> 08:45.760]  Значит, предложите мне, пожалуйста, какой-нибудь алгоритм решения
[08:45.760 --> 08:46.760]  такой задачи.
[08:46.760 --> 08:58.280]  Вы умеете, не позволяйтесь.
[08:58.280 --> 08:59.280]  Какое угодно.
[08:59.280 --> 09:02.440]  Хорошо, полинамиальный.
[09:02.440 --> 09:06.360]  Да, конечно.
[09:06.360 --> 09:10.400]  Я вот единственное, что мне мешает, то что я не знаю,
[09:10.400 --> 09:11.760]  между какими вершинами это разрез.
[09:11.760 --> 09:14.320]  Между каким S маленькая, t маленькая, это разрез.
[09:14.320 --> 09:15.320]  Давайте их все переберем.
[09:15.320 --> 09:18.120]  Давайте насильно скажем, что S маленькая в S большом,
[09:18.120 --> 09:19.120]  t маленькая в T большом.
[09:19.120 --> 09:20.880]  Какую-то пару переберу.
[09:20.880 --> 09:22.880]  А дальше мы уже умеем искать минимальный разрез между
[09:22.880 --> 09:23.880]  парой вершин.
[09:23.880 --> 09:25.040]  Мы знаем, что минимальный разрез – это всегда максимальный
[09:25.040 --> 09:26.040]  поток.
[09:26.040 --> 09:28.720]  Теорема Форда Фалкерсона говорит, что min-cut – это всегда
[09:28.720 --> 09:29.720]  max-flow.
[09:30.200 --> 09:33.320]  Давайте просто переберем вот эти две вершины С и Т,
[09:33.320 --> 09:34.880]  и там найдем максимальный поток.
[09:34.880 --> 09:36.560]  Благо максимальный поток мы умеем искать достаточно
[09:36.560 --> 09:37.560]  быстро.
[09:37.560 --> 09:40.520]  Ну и перебирая все С и Т, мы найдем минимальный разрез
[09:40.520 --> 09:41.520]  в частности.
[09:41.520 --> 09:46.280]  Можно делать так, но это будет, конечно, дольше, чем
[09:46.280 --> 09:47.280]  Шторвагнер.
[09:47.280 --> 09:50.680]  Давайте опишем алгоритм.
[09:50.680 --> 09:55.200]  Что он делает?
[09:55.200 --> 09:57.920]  Он делает следующее.
[09:58.600 --> 10:02.240]  Он хочет занумерать все вершины в каком-то порядке.
[10:02.240 --> 10:05.680]  Это будет у меня нумерация вершин.
[10:05.680 --> 10:14.520]  Ну и для удобства я ввожу обозначение, что а большое
[10:14.520 --> 10:17.320]  итое – это множество всех вершин с первой по итою.
[10:17.320 --> 10:23.320]  Так вот, как работает алгоритм?
[10:23.320 --> 10:25.840]  Он в качестве а1 выбирает произвольную вершину.
[10:25.840 --> 10:27.560]  Ну, например, давайте я скажу, что просто первая
[10:27.560 --> 10:28.560]  вершина.
[10:28.560 --> 10:29.560]  На самом деле произвольная.
[10:29.560 --> 10:31.360]  Произвольная вершина.
[10:31.360 --> 10:37.520]  А дальше, на каждом следующем шаге, на каждом шаге и,
[10:37.520 --> 10:42.680]  начиная со второго, аитое – это такая вершина, которая
[10:42.680 --> 10:45.680]  со всеми предыдущими наиболее связана.
[10:45.680 --> 10:50.280]  То есть сумма всех ребер, исходящих из аи и ведущих
[10:50.280 --> 10:53.040]  в предыдущие построенные вершины, то есть а1 и так
[10:53.040 --> 10:55.040]  далее, аи-1.
[10:55.040 --> 10:56.040]  Максимально возможно.
[10:56.040 --> 10:59.600]  То есть я складываю все вот эти вот capacity и выбираю
[10:59.600 --> 11:01.920]  такой аи, чтобы сумма всех этих capacity была максимальна.
[11:01.920 --> 11:05.760]  Это множество, это все предыдущие выбранные вершины, то есть
[11:05.760 --> 11:09.680]  на самом деле просто а и-1, а там как раз содержатся
[11:09.680 --> 11:11.680]  все первые и-1 вершин.
[11:11.680 --> 11:14.160]  Ну а условие того, что мне нужна максимальная capacity
[11:14.160 --> 11:17.040]  суммарной вот здесь, я могу написать так.
[11:17.040 --> 11:24.040]  Формально аи – это argmaximum по всем вершинам v, не лежащим
[11:24.040 --> 11:32.640]  в аи-1, величина, ну я не буду говорить разрез, я скажу,
[11:32.640 --> 11:35.280]  что просто величина вот такой вот пары, где v отдельно
[11:35.280 --> 11:37.560]  и аи-1 во второй доле лежит.
[11:37.560 --> 11:45.320]  То есть у меня v – это вот та самая вершина аи, то есть
[11:45.320 --> 11:48.280]  я перебираю все v, ищу максимально возможное значение вот этой
[11:48.280 --> 11:52.160]  вот величины в одной доле v, вот она, а в другой доле
[11:52.160 --> 11:53.160]  все множество аи-1.
[11:53.280 --> 11:56.280]  Я считаю суммарную capacity всех этих ребер, как раз
[11:56.280 --> 11:59.760]  c от пары – это вот в точности сумма всех таких capacity, и
[11:59.760 --> 12:01.800]  мне нужен максимум по всем возможным вершинкам, не
[12:01.800 --> 12:03.960]  лежащим в множестве уже взятых.
[12:03.960 --> 12:06.280]  Вот, и так делаю для любого и.
[12:06.280 --> 12:07.280]  Вот.
[12:07.280 --> 12:14.520]  Начну делаю, ну пока что-то сделал, вроде какой-то простой
[12:14.520 --> 12:15.520]  рифметическая операция.
[12:15.520 --> 12:22.760]  Ну вот, оказывается, что, давайте так напишем, а
[12:23.360 --> 12:44.920]  оказывается, что c между an и an-1 равно, ну давайте
[12:44.920 --> 12:47.840]  я вот так вольно достаточно напишу, словами расшифрую
[12:47.920 --> 12:51.480]  что я имею в виду, равно mincut между an-1 и an.
[12:51.480 --> 12:57.720]  Значит, что такое mincut между двумя вершинами?
[12:57.720 --> 13:02.920]  Это вот в точности величина минимального разреза, такого
[13:02.920 --> 13:05.560]  что одна вершина в одной доле, другая вершина в другой
[13:05.560 --> 13:07.160]  доле, или иными сторонами, ну это максимальный поток
[13:07.160 --> 13:08.160]  между вершинами.
[13:08.160 --> 13:11.520]  Мы знаем, что mincut – это всегда maxflow, поэтому я могу
[13:11.520 --> 13:17.360]  здесь переписать это как maxflow между an-1 и an, ну это
[13:17.880 --> 13:19.400]  мне соображение не нужно, просто переформулировка
[13:19.400 --> 13:20.400]  более удобная.
[13:20.400 --> 13:21.400]  Вот.
[13:21.400 --> 13:23.920]  Значит, я утверждаю, что если таким образом выбирать
[13:23.920 --> 13:26.320]  вершины, каждый раз вершины максимально связаны со
[13:26.320 --> 13:30.200]  всем предыдущими, то вот последние две вершины,
[13:30.200 --> 13:32.680]  которые я рассмотрю, которые я добавлю в нашем порядке,
[13:32.680 --> 13:37.360]  an-1 и an, на самом деле я найду минимальный разрез между
[13:37.360 --> 13:42.200]  ними в виде, когда у меня an отдельно, а все другие
[13:42.200 --> 13:43.200]  во второй доле.
[13:43.200 --> 13:44.680]  Ну, соответственно, здесь в частности будет лежать
[13:44.800 --> 13:45.800]  вот это вот an-1.
[13:45.800 --> 13:46.800]  Вот.
[13:46.800 --> 13:49.880]  Это мы докажем чуть позже.
[13:49.880 --> 13:50.880]  Давайте пока об это поверим.
[13:50.880 --> 13:55.080]  Значит, ну смотрите, если это верно, то получается,
[13:55.080 --> 13:58.200]  мы за один проход нашего алгоритма нашли минимальный
[13:58.200 --> 14:00.080]  разрез между какими-то двумя вершинами.
[14:00.080 --> 14:01.880]  Ну вот там, какими-то конкретными.
[14:01.880 --> 14:03.840]  На самом деле мы не можем сказать, какие, видимо, это
[14:03.840 --> 14:05.920]  вершины, но вот какими-то, главное, что это какие-то
[14:05.920 --> 14:06.920]  вершины.
[14:06.920 --> 14:09.320]  А теперь смотрите, а как выглядит настоящий минимальный
[14:09.320 --> 14:10.320]  глобальный разрез?
[14:10.320 --> 14:11.640]  Вот mincut во всем графе.
[14:11.640 --> 14:20.040]  Понятно, что он либо разделяет эти две вершины в разные
[14:20.040 --> 14:22.640]  доли, либо они в одной доле.
[14:22.640 --> 14:25.040]  Смотрите, но если он разделяет их, то это и есть минимальный
[14:25.040 --> 14:28.920]  разрез, потому что если настоящий mincut их разделяет
[14:28.920 --> 14:34.280]  в разные доли, вот если настоящий mincut так выглядит,
[14:34.280 --> 14:36.400]  то вот это и есть настоящий mincut, глобальный mincut.
[14:36.400 --> 14:39.040]  Ну, потому что мы и так знаем, что они в разных долях.
[14:39.080 --> 14:41.960]  Собственно, мы как раз минимизируем разрез между ними.
[14:41.960 --> 14:45.080]  Вот, значит, либо это уже минимальный разрез, либо
[14:45.080 --> 14:47.600]  нужно рассмотреть случаи, когда они лежат в одной
[14:47.600 --> 14:48.600]  доле.
[14:48.600 --> 14:52.800]  То есть в настоящем разрезе минимальном an и an-1 находятся
[14:52.800 --> 14:53.800]  в одной доле.
[14:53.800 --> 14:57.720]  И есть какая-то еще другая доля, которая их не содержит.
[14:57.720 --> 15:00.680]  Вот, но если так, то смотрите, мне осталось разобрать
[15:00.680 --> 15:03.280]  случаи, когда они в одной доле.
[15:03.280 --> 15:06.320]  Давайте тогда их склею и буду считать за одну
[15:06.320 --> 15:08.000]  вершину, потому что если я заведомо знаю, что они
[15:08.000 --> 15:10.360]  в одной доле, я могу на самом деле считать, что
[15:10.360 --> 15:12.680]  это просто одна вершина, и все ребра, которые из них
[15:12.680 --> 15:16.680]  исходили, ну, поместить как бы, как бы их склеить,
[15:16.680 --> 15:19.240]  все равно ребро между ними все равно в разрезе не участвует,
[15:19.240 --> 15:22.120]  я могу их склеить и все вот эти вот ребра тоже склеить.
[15:22.120 --> 15:25.400]  Например, если у меня было какое-нибудь ребро, давайте
[15:25.400 --> 15:26.400]  нарисую что-нибудь.
[15:26.400 --> 15:30.800]  Если у меня были вот такие вот ребра, ведущие в одну
[15:30.800 --> 15:34.400]  и ту же вершину, то после склейки у меня будет ребро
[15:34.400 --> 15:37.760]  с капастью x плюс y, ну, буквально склеиваю
[15:37.760 --> 15:39.640]  все ребра просто, да, суммируя капасть.
[15:39.640 --> 15:40.640]  Вот.
[15:40.640 --> 15:46.040]  Поэтому, да, еще раз, смотрите, либо мы уже поняли, что
[15:46.040 --> 15:48.680]  это мы и так нашли минимальный разрез глобальный, либо
[15:48.680 --> 15:51.840]  мне нужно склеить наши две вершины и заново запустить
[15:51.840 --> 15:52.840]  на самом деле Шторвагнера.
[15:52.840 --> 15:56.480]  То есть мы либо нашли какой-то менткат, на самом деле глобальный
[15:56.480 --> 15:58.880]  менткат, либо мы точно знаем, что в глобальном менткате
[15:58.880 --> 16:00.120]  эти две вершины склеены.
[16:00.120 --> 16:02.960]  Ну, давайте их склеим и запустим все то же самое.
[16:02.960 --> 16:07.680]  То есть последний шаг, это мы склеиваем, склеиваем
[16:07.680 --> 16:12.560]  AN и AN-1, ну и, соответственно, рекурсивно запускаем алгоритм.
[16:12.560 --> 16:22.560]  На последнем шаге, скажем, когда останется всего две
[16:22.560 --> 16:24.640]  вершины, мы точно знаем, как выглядит глобальный
[16:24.640 --> 16:26.560]  минимальный разрез, потому что когда две вершины, у
[16:26.560 --> 16:30.520]  нас всего один разрез, одна в одной доле, другая в другой.
[16:30.520 --> 16:35.960]  Да, значит, выход из рекурсии, когда осталось две вершины,
[16:36.120 --> 16:38.920]  тогда уже понятно, что величина разреза – это просто
[16:38.920 --> 16:39.920]  капасти этого ребра.
[16:39.920 --> 16:46.120]  Так, понятно, что произошло.
[16:46.120 --> 16:52.520]  Ну окей, значит, смотрите, давайте сначала я про симптотику
[16:52.520 --> 16:57.120]  скажу, а симптотика, я тоже, здесь будет просто кубическая,
[16:57.120 --> 16:59.680]  а симптотика будет N-куб.
[16:59.680 --> 17:01.480]  Суммарно всего этого безобразия будет N-куб.
[17:01.480 --> 17:05.320]  Ну потому что, смотрите, вот здесь вот, когда на каждом
[17:05.400 --> 17:06.920]  шаге я выбираю вершину максимально связанную
[17:06.920 --> 17:10.160]  с предыдущими, это что-то очень похоже на dx или на
[17:10.160 --> 17:11.160]  prima.
[17:11.160 --> 17:14.040]  На каждом шаге мы выбираем вершину наиболее, ну там
[17:14.040 --> 17:17.120]  было наименее, с наименьшим весом, тут с наибольшим
[17:17.120 --> 17:19.840]  суммарным весом до всех остальных вершин, которые
[17:19.840 --> 17:20.840]  выбраны.
[17:20.840 --> 17:22.160]  Ну, собственно, по тем же причинам это все можно
[17:22.160 --> 17:23.160]  за квадрат написать.
[17:23.160 --> 17:27.040]  Я могу просто для каждой вершины V хранить вот эту
[17:27.040 --> 17:29.680]  величину, то есть сумму capacity в уже рассмотренные
[17:29.680 --> 17:30.680]  вершины.
[17:30.680 --> 17:32.600]  Когда очередная вершина рассматривается, добавляется
[17:33.080 --> 17:34.080]  в нашу нумерацию.
[17:34.080 --> 17:35.960]  Я просто рассматриваю все исходящие из нее ребра
[17:35.960 --> 17:39.280]  и увеличиваю величину для всех, ну, короче, для всех
[17:39.280 --> 17:40.280]  соседей.
[17:40.280 --> 17:41.280]  Вот.
[17:41.280 --> 17:44.320]  Поэтому, суммарно, вот одна итерация, вот это вот
[17:44.320 --> 17:47.160]  все, вот этот вот цикл, на вот этот вот цикл, его
[17:47.160 --> 17:50.120]  можно реализовать за квадрат, потому что по факту это
[17:50.120 --> 17:51.120]  что-то очень похоже на dx-ру.
[17:51.120 --> 17:52.120]  Вот.
[17:52.120 --> 17:55.480]  То есть, если постараться, можно было бы, наверное,
[17:55.480 --> 17:59.480]  за m log n это сделать, но обычно штурвагнер на полных,
[17:59.480 --> 18:02.800]  ну, там, на близких полных графах используется, поэтому
[18:02.800 --> 18:03.800]  здесь лучше квадрат обычно.
[18:03.800 --> 18:04.800]  Вот.
[18:04.800 --> 18:07.600]  Ну и так n раз, потому что у меня рекурсия, на рекурсированном
[18:07.600 --> 18:09.720]  шаге у меня две вершины склеиваются, значит у меня глубина рекурсии
[18:09.720 --> 18:10.720]  будет n.
[18:10.720 --> 18:11.720]  Отсюда n куб.
[18:11.720 --> 18:34.200]  Так, значит, теперь, чтобы совсем победить, осталось
[18:34.200 --> 18:38.400]  доказать вот то утверждение, что разрез, находимый между
[18:38.400 --> 18:40.920]  последними двумя вершинами, равен разрезу в случае,
[18:40.920 --> 18:43.360]  а а n отдельно, а все остальные в другой доль.
[18:43.360 --> 18:44.360]  Вот.
[18:44.360 --> 18:47.360]  Ну, давайте это будем доказывать.
[18:47.360 --> 18:49.600]  Для этого давайте рассмотрим какой-то конкретный разрез.
[18:49.600 --> 18:56.960]  Рассмотрим, ну, точнее, произвольный, да, ну, какой-то зафиксированный
[18:56.960 --> 19:10.280]  произвольный разрез st между а n и а n-1.
[19:10.280 --> 19:16.720]  И мы хотим доказать, что его величина больше равна
[19:16.720 --> 19:17.720]  чем то, что мы нашли.
[19:17.720 --> 19:26.800]  То есть я утверждаю, что вот это вот, это минимальный
[19:26.800 --> 19:30.080]  разрез между двумя вершинами, я говорю, чтобы это доказать,
[19:30.080 --> 19:32.520]  давайте рассмотрим произвольный разрез между ними и докажу,
[19:32.520 --> 19:34.480]  что его капасти больше равна, чем то, что я пытаюсь
[19:34.480 --> 19:35.480]  доказать, что это минимум.
[19:35.680 --> 19:37.600]  Это как раз значит, что это, это минимальный разрез.
[19:37.600 --> 19:47.000]  Так, хорошо, значит, для этого мне нужно будет сделать
[19:47.000 --> 19:48.000]  следующее.
[19:48.000 --> 19:49.000]  Лемма.
[19:49.000 --> 19:54.880]  Вот разрез st у меня зафиксирован, какой-то конкретный разрез
[19:54.880 --> 19:55.880]  я хочу доказать.
[19:55.880 --> 19:56.880]  Лемма.
[19:57.280 --> 20:12.800]  Значит, будем называть вершину i, точнее a i, вершину a i активной,
[20:12.800 --> 20:19.920]  если, если она и предыдущая к ней, то есть a i и a i-1, лежат
[20:19.920 --> 20:24.360]  в разных долях st, то есть одна в s, другая в t.
[20:24.840 --> 20:32.480]  Я не умею записывать лучше, чем вот так, если a i в s а
[20:32.480 --> 20:42.600]  а i-1 в t или a i в t а i-1 в s, то есть она активна, если
[20:42.600 --> 20:45.520]  она другая по сравнению с предыдущей, вот если по
[20:45.520 --> 20:47.760]  сравнению с предыдущей, они в разных долях, либо
[20:47.760 --> 20:49.760]  st, либо t s.
[20:50.160 --> 20:58.680]  Так вот тогда, утверждает Лемма, ну, собственно, вот
[20:58.680 --> 21:03.160]  похоже здесь неравенство будет, сейчас я его зафиксирую,
[21:03.160 --> 21:08.200]  значит, c a i, a i-1 меньше либо равно, чем сужение разреза
[21:08.200 --> 21:12.200]  st на множество a i.
[21:20.200 --> 21:26.200]  Так, пока вроде не обманываю.
[21:26.200 --> 21:34.200]  Зачем это надо, давайте потом, давайте докажем сначала.
[21:34.200 --> 21:38.920]  Доказательство, доказательство я буду проводить индукцией
[21:38.920 --> 21:40.320]  по активным вершинам.
[21:40.320 --> 21:48.840]  Индукция по активным вершинам.
[21:48.920 --> 21:54.920]  Ну, давайте рассмотрим первую активную вершину.
[21:54.920 --> 21:58.200]  Что значит, там что-нибудь ажи, пусть ажи это первая
[21:58.200 --> 22:02.360]  активная, пусть ажи это первая активная.
[22:02.360 --> 22:10.120]  Что значит первая активная, значит все предыдущие скажем
[22:10.120 --> 22:13.960]  в s, а она в t, то есть она отличается от всех остальных.
[22:13.960 --> 22:16.280]  Вот первые переключения из одной доли в другую
[22:16.280 --> 22:17.280]  происходят в точке ажи.
[22:17.720 --> 22:19.720]  Что значит, что все предыдущие в одной доле, а ажи в другой.
[22:19.720 --> 22:22.920]  Ну, то есть, например, это выглядит как-то так, а1
[22:22.920 --> 22:30.920]  и так далее, а, ж-1, все лежали в s, а ажи лежит в t.
[22:30.920 --> 22:36.440]  Ну, или наоборот, но это неважно, у меня ас и т всегда
[22:36.440 --> 22:39.040]  взаимозаменяемым, потому что граф неориентированной
[22:39.040 --> 22:42.280]  капасти, от этого не меняется, поэтому давайте я так нарисую.
[22:42.280 --> 22:46.280]  Вот, давайте попытаемся понять, что здесь написано.
[22:46.280 --> 22:51.800]  Значит, я вместо аи подставляю ажи, и на самом деле в обоих
[22:51.800 --> 22:53.520]  частях этого неравенства написана просто величина
[22:53.520 --> 22:56.480]  этого разреза, потому что у меня справа лежит только
[22:56.480 --> 23:00.640]  ажи, а слева все остальные, поэтому то, что написано
[23:00.640 --> 23:03.320]  здесь, это сумма всех робер пересекающих разрез.
[23:03.320 --> 23:08.800]  Да, у меня ажи здесь, а большое, ж-1, это все вот здесь, поэтому
[23:08.800 --> 23:11.520]  слева написана величина этого разреза, ну и справа
[23:11.520 --> 23:15.000]  то же самое, потому что когда я сужаю s до ажи, то есть пересекаю
[23:15.000 --> 23:18.040]  s с ажи, получается как раз вот эти вершины, когда я пересекаю
[23:18.040 --> 23:21.400]  t с ажи, получается только одна вершина ажи, значит здесь
[23:21.400 --> 23:24.360]  тоже написана величина этого же разреза, поэтому в базе
[23:24.360 --> 23:27.760]  у меня даже получается равенство, не неравенство, а даже равенство.
[23:41.520 --> 23:58.000]  Ну переход, давайте рассмотрим две последовательно активные
[23:58.000 --> 24:02.400]  вершины, скажем ау это активная, потом несколько ау плюс
[24:02.400 --> 24:05.000]  1, ау плюс 2 и так далее не активная, а следующая активная
[24:05.000 --> 24:16.480]  это ав, пусть ау, ав две последовательные активные
[24:16.480 --> 24:41.760]  вершины, между ними активных нет. Так, картинка, давайте
[24:41.760 --> 24:44.520]  я опять буду считать, что ау лежит в с большом, ав лежит
[24:44.560 --> 24:53.280]  в т большом, значит я нарисую такую картинку, двухступенчатую,
[24:53.280 --> 24:59.320]  это у меня будет с пересечь с ав, это t пересечь с ав,
[24:59.320 --> 25:07.480]  это с пересечь с ау, это t пересечь с ау. Так вот,
[25:07.480 --> 25:13.000]  я говорю, что ау лежит вот здесь вот, дальше, поскольку
[25:13.000 --> 25:16.400]  у меня промежуточные между ними, ау плюс 1, ау плюс
[25:16.400 --> 25:18.920]  2 и так далее, не активные, то получается, что по сравнению
[25:18.920 --> 25:22.320]  с предыдущей не происходит переключение в другую долю,
[25:22.320 --> 25:24.720]  значит они все вот здесь же, но поскольку они уже
[25:24.720 --> 25:29.880]  вылезают за ау, то они вот здесь находятся, ау плюс
[25:29.880 --> 25:34.320]  1 и так далее, ав минус 1, вот они все вот здесь, в той
[25:34.320 --> 25:38.360]  же доле, что и ау, потому что они не активные, а ав
[25:38.440 --> 25:45.360]  активная, значит она в другой доле, она вот здесь вот,
[25:45.360 --> 25:47.440]  можно нарисовать такую картинку еще раз в предположении,
[25:47.440 --> 25:56.920]  что ау маленькое лежит в с большом. Так, ну и давайте
[25:56.920 --> 26:00.200]  попробуем написать, что такое, вот то, что меня там пытаются
[26:00.280 --> 26:10.400]  попросить оценить, с между ав и ав минус 1. Я разобью
[26:10.400 --> 26:18.400]  сейчас второе множество на два подмножества. Так,
[26:18.400 --> 26:25.400]  чтобы не ошибиться, я спешу. Да, ау минус 1, хорошо.
[26:25.400 --> 26:40.920]  Значит, равенство тривиально, оно просто, ну из определения
[26:40.920 --> 26:43.400]  следует, что я могу второе множество разбить на два
[26:43.400 --> 26:46.400]  подмножества, ау минус 1 и дополнение до него, то
[26:46.400 --> 26:50.400]  ау минус 1 без ау минус 1. Понятно тогда, что при суммировании
[26:50.400 --> 26:52.400]  у меня в точности получится вот эта вот ночь, потому
[26:52.400 --> 26:55.400]  что я в серебре учту как раз. Так, ну и давайте теперь
[26:55.400 --> 26:58.400]  с этим возиться. Вот первая слагаемая довольно простая.
[26:58.400 --> 27:06.400]  Я утверждаю, что эта штука не больше, чем вот такая
[27:06.400 --> 27:20.400]  штука. Скажите мне, почему? Что ав, ну капасити между
[27:20.400 --> 27:23.400]  а маленьким в и вот этим множеством не превосходит
[27:23.400 --> 27:26.400]  не больше, чем увеличена между ау и этим множеством.
[27:26.400 --> 27:30.400]  Для этого надо вспомнить, в каком порядке мы вершины
[27:30.400 --> 27:51.400]  выбираем. Ну конечно, да, да, просто по определению.
[27:51.400 --> 27:55.400]  Мы вот на этом шаге, на утром шаге, мы выбрали эту вершину
[27:55.400 --> 27:57.400]  так, чтобы эта штука была максимально среди всех
[27:57.400 --> 28:00.400]  возможных вершин вот здесь вот. Поэтому если я заменю
[28:00.400 --> 28:04.400]  это на что-то другое, то я могу только ухудшить вот
[28:04.400 --> 28:07.400]  эту суммарную величину этого разреза, просто по определению.
[28:07.400 --> 28:14.400]  По выбору, напишу так, по выбору ау. Вот, это, наверное,
[28:14.400 --> 28:17.400]  простое. Но более того, я могу сказать, что по индукции,
[28:17.400 --> 28:20.400]  по предположению индукции, давайте я вот здесь лучше
[28:20.400 --> 28:26.400]  подпишу, да, по выбору ау, но еще по предположению
[28:26.400 --> 28:30.400]  индукции, поскольку ау у меня же активная, да, а я знаю,
[28:30.400 --> 28:35.400]  как можно оценить c между ау и ау-1. Это сужение разреза
[28:35.400 --> 28:41.400]  st на ау. Поэтому здесь я могу оценить сверху, как cs пересечь
[28:41.400 --> 28:46.400]  с ау, t пересечь с ау. Вот, это просто предположение
[28:46.400 --> 28:51.400]  индукции. По предположению индукции, потому что ау
[28:51.400 --> 28:54.400]  активная, значит, я могу это написать неравенственно,
[28:54.400 --> 29:01.400]  по предположению. Вот. Ну а что здесь? Нужна доска.
[29:15.400 --> 29:18.400]  Значит, здесь я уже второе слагаемое, можно оценить
[29:18.400 --> 29:30.400]  сверху так. Ау? Что-что? Ладно. Смотрите, мы уже почти
[29:30.400 --> 29:33.400]  получили то, что нужно в правой части, только здесь
[29:33.400 --> 29:35.400]  должно быть ав вместо ау. Но давайте покажем, что
[29:35.400 --> 29:39.400]  эта штука меньше равна, чем s пересечь с ав, t пересечь
[29:39.400 --> 29:46.400]  с ав, минус c, s пересечь с ау, t пересечь с ау. Если
[29:46.400 --> 29:48.400]  я это покажу, то я победил, потому что у меня вот эти
[29:48.400 --> 29:50.400]  штуки сократятся друг с дружкой. Получится, что
[29:50.400 --> 29:53.400]  то, что мне нужно, меньше равно, чем то, что мне нужно.
[29:57.400 --> 30:01.400]  Почему вот это верно? Почему вот эта штука меньше
[30:01.400 --> 30:05.400]  равна такой разности? Ну, тут нужна картинка и фантазия.
[30:05.400 --> 30:08.400]  Значит, давайте я перепишу вот этот неравенственный,
[30:08.400 --> 30:10.400]  который последний хочу доказать. Давайте я перепишу,
[30:10.400 --> 30:15.400]  перенеся вот эту штуку налево. Так. То есть я хочу
[30:15.400 --> 30:22.400]  показать следующее. Хочу, что c, s суженное на ау, t суженное
[30:22.400 --> 30:28.400]  на ау, плюс какая-то странная шняга между одной вершинкой
[30:28.400 --> 30:38.400]  и ав-1 без ау-1, меньше либо равна, чем весь разрез
[30:38.400 --> 30:44.400]  на ав. Вот. Хочу такое доказать. Ну, давайте просто посмотрим
[30:44.400 --> 30:47.400]  на картинку, поймем, что это очевидно. Смотрите, что
[30:47.400 --> 30:59.400]  такое вот это вот слагаемое? Это все вот это вот в точности.
[30:59.400 --> 31:03.400]  Это ребра между ав и всеми вершинками, которые лежат
[31:03.400 --> 31:06.400]  вот здесь вот. То есть в большом облочке, но не в маленьком.
[31:06.400 --> 31:09.400]  Потому что вот оно ав, вот они все в точности, а
[31:09.400 --> 31:14.400]  большой в а-1 без ау-1. А, пардон, еще вот такое ребро, да?
[31:14.400 --> 31:17.400]  Да, потому что там без ау-1, значит это тоже учитывается.
[31:17.400 --> 31:21.400]  Вот. Хорошо. Значит второе слагаемое. Первое слагаемое
[31:21.400 --> 31:24.400]  это суммарное capacity между вот этим маленьким кружечком
[31:24.400 --> 31:28.400]  и этим маленьким кружечком. Давайте другой цвет. Это все
[31:28.400 --> 31:37.400]  вот это вот. Ну понятно, что сумма это не больше, чем
[31:37.400 --> 31:41.400]  настоящий разрез между сав, ну точнее вот этим вот
[31:41.400 --> 31:43.400]  с пересечь сав и т пересечь сав. Потому что еще
[31:43.400 --> 31:46.400]  кейма и ребра, например, не учли. Ну, например, вот
[31:46.400 --> 31:50.400]  такие и вот такие. Поскольку у меня все не отрицательно.
[31:50.400 --> 31:52.400]  Да, я забыл сказать, что ну как бы в графах всегда
[31:52.400 --> 31:54.400]  подразумевается, что сто capacity не отрицательные.
[31:54.400 --> 31:57.400]  И поскольку я здесь какие-то capacity только не доучел,
[31:57.400 --> 31:59.400]  то значит, понятное дело, я получил в сумме не больше,
[31:59.400 --> 32:01.400]  чем величина разреза, потому что просто какие-то ребра
[32:01.400 --> 32:07.400]  не учил. Все, очевидно. Значит, повторю. Если у меня вот
[32:07.400 --> 32:09.400]  то доказано, а мы только что это на картинке доказали,
[32:09.400 --> 32:11.400]  то у меня есть вот это неравенство просто перенесением там
[32:11.400 --> 32:15.400]  и новослагаемое направо. Дальше вот эти два сократятся.
[32:15.400 --> 32:20.400]  И у меня получится требуемое неравенство, что разрез
[32:20.400 --> 32:24.400]  между активной вершиной и всеми предыдущими не превосходит
[32:24.400 --> 32:31.400]  сужение нашего разреза на АВ. Вот, немедленно получается отсюда.
[32:37.400 --> 32:40.400]  Вот, значит, лему мы доказали. Для всех активных вершин мы такое
[32:40.400 --> 32:44.400]  неравенство можем написать. Ну а теперь смотрите, на самом деле
[32:44.400 --> 32:48.400]  понятно, что АН всегда активная. Значит, лему мы доказали.
[32:49.400 --> 32:57.400]  Продолжаем. АН всегда активная. Ну почему? Потому что мы знаем,
[32:57.400 --> 33:01.400]  что АН и АН-1 в разных долях. Просто потому что С и Т это
[33:01.400 --> 33:04.400]  разрез между ними. Значит, они обязаны быть в разных долях.
[33:04.400 --> 33:09.400]  Потому что у меня АН, скажем, в Т, а АН-1 в С. Значит, эта
[33:09.400 --> 33:13.400]  штука активная. Поэтому я могу для вершины АН написать условия
[33:13.400 --> 33:16.400]  моей леммы, точнее утверждение леммы. Ну давайте его и напишем.
[33:25.400 --> 33:35.400]  По лемме. Ну извините, это просто ЦСТ. Потому что АН-то все вершины.
[33:35.400 --> 33:46.400]  Ну, еще раз, там неважно. То есть либо так, либо, как обычно, в С.
[33:46.400 --> 33:49.400]  Это неважно. Ну вообще я могу потребовать, чтобы вот эта
[33:49.400 --> 33:53.400]  штука лежала в Т, а эта в С. Но неважно. Для этого констатства
[33:53.400 --> 33:56.400]  неважно. То есть я знаю, что у меня С и Т это разрез между
[33:56.400 --> 33:59.400]  ними. А какой разрез между ними? Значит, они в разных
[33:59.400 --> 34:01.400]  долях. Поэтому либо это, либо это. Значит, она активная
[34:01.400 --> 34:03.400]  просто по определению. Ну вот, вроде все доказали. Вопросики?
[34:31.400 --> 34:39.400]  Здесь, как это часто бывает, доказательства сложнее гораздо алгоритма.
[34:39.400 --> 34:42.400]  Алгоритм очень простой. Там написано что-то типа DX.
[34:42.400 --> 34:46.400]  Порядок выбора всех вершин. И оказывается, что на последнем шаге,
[34:46.400 --> 34:48.400]  вот по вот этому, то, что мы сейчас делали, да, по лемме,
[34:48.400 --> 34:51.400]  на последнем шаге мы находим MENCAT между двумя вершинами.
[34:51.400 --> 34:54.400]  Между последней и предпоследней. И тогда либо это MENCAT настоящий
[34:54.400 --> 34:57.400]  глобальный, либо их можно склеить и искать MENCAT в новом графе,
[34:57.400 --> 35:01.400]  когда они уже склеены и находятся в одной доле. Вот смысл такой.
[35:01.400 --> 35:06.400]  Так, хорошо, хорошо. Значит, тогда с такими потоками мы
[35:06.400 --> 35:10.400]  разобрались. Давайте перейдем к потокам минимальной стоимости.
[35:10.400 --> 35:14.400]  Потоки минимальной стоимости.
[35:27.400 --> 35:32.400]  Задача. Получается, на самом деле, естественным обобщением
[35:32.400 --> 35:38.400]  обычная задача про потоки, когда мы добавляем какой-то штраф,
[35:38.400 --> 35:41.400]  какую-то уплату, какую-то стоимость за то, чтобы передать
[35:41.400 --> 35:45.400]  сколько потока по ребру. Вот если у меня раньше на ребре
[35:45.400 --> 35:50.400]  было написано только CAPACITY C, на сколько максимум поток
[35:50.400 --> 35:53.400]  я могу протолкнуть, то теперь появляется новая характеристика
[35:53.400 --> 35:59.400]  COST. Это стоимость протолкивания единицы потока. Сколько стоит
[35:59.400 --> 36:02.400]  протолкнуть единицу потоку по этому ребру. Ну там, например,
[36:02.400 --> 36:06.400]  если у вас есть какая-то сеть нефтепроводов, то это стоимость
[36:06.400 --> 36:12.400]  какой-нибудь налог, налог за то, что вы передаете сколько-то
[36:12.400 --> 36:17.400]  водички по трубе. И если вы пускаете здесь, давайте напишем,
[36:17.400 --> 36:27.400]  что это пропускная способность, это стоимость ребра. Вот если
[36:27.400 --> 36:31.400]  вы пускаете здесь поток f, то, соответственно, суммарный
[36:31.400 --> 36:38.400]  штраф равен, ну по этому ребру, это f на COST. То есть сколько
[36:38.400 --> 36:41.400]  единиц потока вы пустили умножить на стоимость за единицу
[36:41.400 --> 36:47.400]  потока. Собственно, стоимость за единицу потока. И ваша цель
[36:47.400 --> 36:55.400]  это минимизировать просто по всем ребрам f на COST. То есть если
[36:55.400 --> 36:58.400]  мы пустили какой-то конкретный поток, его стоимость это просто
[36:58.400 --> 37:03.400]  сумма по всем ребрам f на COST. Вот. И мы хотим, чтобы на благо
[37:03.400 --> 37:05.400]  можно меньше. Понятно, что естественно требовать, чтобы
[37:05.400 --> 37:09.400]  стоимость была поменьше. Ну и, соответственно, здесь есть две
[37:09.400 --> 37:19.400]  задачи практически идентичные. Min-Cost-Caflow. Это когда мы хотим
[37:19.400 --> 37:23.400]  найти поток величины ровно k, и при этом его сделать
[37:23.400 --> 37:25.400]  минимальной стоимости. То есть мы хотим, чтобы величина
[37:25.400 --> 37:29.400]  потока была в точности k, и при этом нужно минимизировать
[37:29.400 --> 37:39.400]  стоимость. При этом минимизировать стоимость. Либо просто
[37:39.400 --> 37:49.400]  Min-Cost-Max-Flow. Это когда величина потока максимальна. Давайте
[37:49.400 --> 37:53.400]  напишу так. Величина потока максимальна, и при этом условие
[37:53.400 --> 38:00.400]  минимальная стоимость имеет. При этом минимальная стоимость.
[38:00.400 --> 38:04.400]  То есть среди всех потоков вот такой величины максимальной
[38:04.400 --> 38:07.400]  или вот такой величины в точности k, мне нужно выбрать поток,
[38:07.400 --> 38:10.400]  который имеет минимальную стоимость. Скажем, вот, столько
[38:10.400 --> 38:13.400]  это потока я хочу передать. Вопрос, сколько мне придется
[38:13.400 --> 38:15.400]  потратить денег, чтобы это сделать? Какую минимальную
[38:15.400 --> 38:22.400]  стоимость мне нужно потратить, чтобы это сделать? Давайте
[38:22.400 --> 38:28.400]  перерыв чуть пораньше сделаем, потом продолжим. Давайте
[38:28.400 --> 38:32.400]  дальше. Смотрите, вот мы сформулировали две задачки.
[38:32.400 --> 38:36.400]  Главное, это то, как считается величина потока. Очень
[38:36.400 --> 38:39.400]  просто. За каждую единицу потока мы платим какой-то штраф.
[38:39.400 --> 38:43.400]  Теперь, смотрите, так же, как в обычных алгоритмах для
[38:43.400 --> 38:46.400]  поиска просто максимального потока мне понадобится
[38:46.400 --> 38:50.400]  ввести обратные ребра, чтобы в каком-то смысле уметь
[38:50.400 --> 38:53.400]  отменять поток текущий по ребру. То есть если у
[38:53.400 --> 38:57.400]  меня есть какое-то прямое ребро с данными характеристиками
[38:57.400 --> 39:02.400]  C и Kost, то я сразу к нему в пару добавляю обратное.
[39:02.400 --> 39:04.400]  С какими характеристиками? Ну, в капальстве такой же будет
[39:04.400 --> 39:07.400]  ноль, как обычно. По обратному ребру как бы не должно
[39:07.400 --> 39:12.400]  утечь потока. Но кост здесь будет отрицательный,
[39:12.400 --> 39:16.400]  минус кост. Ну, точнее, противоположный по знаку,
[39:16.400 --> 39:20.400]  минус кост. Это вот как раз тот же самый смысл, что я
[39:20.400 --> 39:23.400]  отменяю единицу потока текущую по ребру. Потому что
[39:23.400 --> 39:26.400]  если раньше у меня здесь текла единица, я платил за нее
[39:26.400 --> 39:29.400]  кост, а после этого я опускаю единицу по обратному ребру,
[39:29.400 --> 39:33.400]  как бы отменяя ее, и добавляю к ответу минус кост. Это
[39:33.400 --> 39:36.400]  как раз то самое. Я отменяю тот кост, тот штраф, который
[39:36.400 --> 39:38.400]  я заплатил за проход по этому ребру, потому что этот
[39:38.400 --> 39:41.400]  поток отменился по обратному. Поэтому как раз
[39:41.400 --> 39:44.400]  введение обратного ребра с противоположной стоимостью
[39:44.400 --> 39:47.400]  делает ровно то, что мы хотим, позволяет нам отменять
[39:47.400 --> 39:49.400]  поток текущий по ребру. И, соответственно, возвращать
[39:49.400 --> 39:52.400]  тот штраф, который мы уплатили за вот эту единицу
[39:52.400 --> 39:58.400]  потока. Ну вот. Все, значит, сеть построена, обратные
[39:58.400 --> 40:01.400]  ребра у меня появились, и на самом деле алгоритм тогда
[40:01.400 --> 40:03.400]  будет вот такой вот. Давайте вот эту штуку я нарисую.
[40:03.400 --> 40:06.400]  Как работает алгоритм поиска минимального потока
[40:06.400 --> 40:10.400]  величины k. Очень просто. Я буду каждый раз в
[40:10.400 --> 40:13.400]  остаточной сети искать просто кратчайший путь из
[40:13.400 --> 40:18.400]  s в t. Ну, поскольку у меня здесь есть отрицательные
[40:18.400 --> 40:21.400]  ребра, то форд Белманом. Я буду искать кратчайший
[40:21.400 --> 40:24.400]  путь из s в t и пускать по нему единицу потока. Итак,
[40:24.400 --> 40:31.400]  k раз. Потому что если здесь было
[40:31.400 --> 40:34.400]  капасти c, то здесь капасти 0. Я не хочу, чтобы какой-то
[40:34.400 --> 40:38.400]  содержательный поток тек по обратному ребру. Итак,
[40:38.400 --> 40:45.400]  k раз. Я как-нибудь, например, с помощью форда Белмана
[40:45.400 --> 40:51.400]  нахожу кратчайший путь в остаточной сети. Найти
[40:51.400 --> 40:59.400]  кратчайший путь в gf. Ну и проталкиваю по нему единицу
[40:59.400 --> 41:14.400]  потока. Протолкнуть по нему единицу потока. Все, вот
[41:14.400 --> 41:18.400]  такой-то по алгоритму. Ну, собственно, это практически
[41:18.400 --> 41:20.400]  то же самое, что, например, Эдман Скарп. Потому что
[41:20.400 --> 41:23.400]  Эдман Скарп просто многократно находит кратчайший путь
[41:23.400 --> 41:26.400]  в остаточной сети и пускает по нему поток, какой может.
[41:26.400 --> 41:28.400]  Ну, здесь единственное, как бы, мне нужно искать кратчайший
[41:28.400 --> 41:32.400]  путь не по, ну не как bfs в неориентированном графе, а
[41:32.400 --> 41:34.400]  как форт Белман, потому что в графе у меня, сори, в
[41:34.400 --> 41:36.400]  невзвешенном графе, извините, я говорился. Эдман Скарп
[41:36.400 --> 41:39.400]  работает как в невзвешенном графе, там bfs, а здесь, поскольку
[41:39.400 --> 41:42.400]  у меня ребра взвешенные, то мне нужен форт Белман. Ну
[41:42.400 --> 41:46.400]  или там что-нибудь типа того. Но смысл основной вот
[41:46.400 --> 41:55.400]  ровно такой. Да. Может, да. В смысле, по два ребра
[41:55.400 --> 42:01.400]  взвешенные в каждую. Ну, вот такое может быть. Да,
[42:01.400 --> 42:06.400]  это не страшно. Да, это не страшно. Это, конечно, может
[42:06.400 --> 42:10.400]  быть такое. То есть у нас может быть, что из u вв есть
[42:10.400 --> 42:12.400]  несколько ребр, из v ву есть несколько ребр, и каждому
[42:12.400 --> 42:14.400]  строится обратно, и, короче, число ребра 2, то есть там
[42:14.400 --> 42:17.400]  их может быть много, но это ничему нам, короче, не
[42:17.400 --> 42:23.400]  мешает никак. Вот. Значит, давайте попытаемся доказать,
[42:23.400 --> 42:28.400]  что это корректно. Для этого опять нужна лемма. Лемма.
[42:28.400 --> 42:32.400]  Значит, пусть две леммы мне нужно. Давайте первая
[42:32.400 --> 42:41.400]  лемма о декомпозиции потока. В этот раз мне придется
[42:41.400 --> 42:53.400]  сформулировать. Пусть f это поток в сетеже, значит,
[42:53.400 --> 42:56.400]  тогда его можно представить как сумму путей из s в t и
[42:56.400 --> 43:04.400]  сумму нескольких циклов. Давайте я полностью напишу
[43:04.400 --> 43:20.400]  g s t k, g s t c. Можно представить как сумму путей из s в t и
[43:20.400 --> 43:32.400]  циклов. Вот. Ну, что это значит? Это значит, что любой
[43:32.400 --> 43:37.400]  путь, любой поток на самом деле, это совокупность
[43:37.400 --> 43:44.400]  нескольких путей и, возможно, нескольких висящих в воздухе
[43:44.400 --> 43:51.400]  циклов. Ну, с путями все понятно, собственно, то как у
[43:51.400 --> 43:56.400]  меня водичка течет из s в t, а циклы возникают, ну,
[43:56.400 --> 44:00.400]  потому что они могут быть. Например, смотрите, если
[44:00.400 --> 44:02.400]  я опускаю по вот такому циклическому маршруту единичку
[44:02.400 --> 44:04.400]  потока, то, в принципе, это ничему не противоречит.
[44:04.400 --> 44:07.400]  У меня вода здесь нигде не накапливается, она постоянно
[44:07.400 --> 44:10.400]  течет, то есть у меня вполне, скажем, третье свойство
[44:10.400 --> 44:12.400]  потока, что втекает столько же, сколько вытекает. Если
[44:12.400 --> 44:14.400]  здесь везде капаси хотя бы один, то, значит, поток не
[44:14.400 --> 44:17.400]  происходит в капасите, но антисимметричность, понятно,
[44:17.400 --> 44:19.400]  что там, ну, просто по-противоложному, течет минус
[44:19.400 --> 44:21.400]  один. Поэтому, в принципе, циклы возможны, и вот это
[44:21.400 --> 44:25.400]  надо проговорить, что в разбиении, в декомпозиции
[44:25.400 --> 44:28.400]  потока на пути, возможно, еще появляются циклы, но они
[44:28.400 --> 44:31.400]  вот такие вот, как бы, просто там циркуляция какая-то,
[44:31.400 --> 44:33.400]  она ничего не добавляет содержательного к потоку
[44:33.400 --> 44:36.400]  из С в Т, но она вот возможна, какие-то такие циклы могут
[44:36.400 --> 44:40.400]  появляться. Так, ну, доказательства давайте очень кратенько
[44:40.400 --> 44:45.400]  что-нибудь скажу. Вот давайте посмотрим, существует
[44:45.400 --> 44:48.400]  ли из С какое-то исходящее ребро с положительным потоком?
[44:48.400 --> 44:54.400]  Правда ли, что здесь F больше нуля? Но если больше нуля,
[44:54.400 --> 44:56.400]  вот давайте возьмем какое-то такое ребро, давайте единицу
[44:56.400 --> 44:59.400]  здесь пропустим, вот здесь течет единица. Дальше встанем
[44:59.400 --> 45:03.400]  сюда. По закону сохранения потока, у меня эта единица
[45:03.400 --> 45:05.400]  потока должна откуда-то вытечь, то есть не может быть
[45:05.400 --> 45:07.400]  такого, что здесь нет ни одного исходящего ребра с
[45:07.400 --> 45:11.400]  положительным потоком, да, потому что иначе у меня было,
[45:11.400 --> 45:13.400]  ну, как бы, что-то входит, но ничего не выходит. Значит,
[45:13.400 --> 45:16.400]  куда-то это опять ведет, опять можно найти ребро хотя
[45:16.400 --> 45:20.400]  бы с единичным потоком. Дальше делаем то же самое, тогда
[45:20.400 --> 45:23.400]  мы рано или поздно придем в Т, и вот, пожалуйста, мы
[45:23.400 --> 45:29.400]  нашли какой-то путь. Либо рано или поздно мы зациклимся,
[45:29.400 --> 45:35.400]  значит, мы нашли, например, вот такой вот цикл. Вот.
[45:35.400 --> 45:38.400]  Ну и так просто делаем, пока есть хотя бы одно ребро
[45:38.400 --> 45:43.400]  с положительным потоком. Вот. То есть я просто встал
[45:43.400 --> 45:46.400]  в С, иду-иду-иду по ребрам с положительным потоком,
[45:46.400 --> 45:49.400]  рано или поздно, либо пришел в Т, тогда я отчленил
[45:49.400 --> 45:52.400]  какой-то путь. Да, либо рано или поздно я зациклился,
[45:52.400 --> 45:55.400]  значит, я нашел цикл, и вот здесь вот опять-таки могу
[45:55.400 --> 45:59.400]  здесь делать минус один и решать задачу уже для как бы
[45:59.400 --> 46:03.400]  меньшего суммарно текущего потока. Вот. Значит,
[46:03.400 --> 46:05.400]  это мы разобрались с С, мы так исчерпали все исходящие
[46:05.400 --> 46:07.400]  ребра из С с положительным потоком. Если остальские
[46:07.400 --> 46:11.400]  другие вершины с положительным потоком, то, ну, опять, если
[46:11.400 --> 46:15.400]  я нахожу что-то положительное, то я пускаю дничку, и так
[46:15.400 --> 46:19.400]  рано или поздно я обязательно зациклюсь. Ну и, собственно,
[46:19.400 --> 46:23.400]  вот я очередной цикл отрезал. Ну, короче, просто встали
[46:23.400 --> 46:25.400]  и идем, просто смотрим, куда идет поток, мы рано или поздно
[46:25.400 --> 46:29.400]  либо из Т вытечем, либо зациклимся. Поэтому все у нас
[46:29.400 --> 46:36.400]  либо пути, либо циклы. Профит. Окей? Это вроде вот совсем
[46:36.400 --> 46:40.400]  на пальцах можно понять. Теперь вторая, собственно,
[46:40.400 --> 46:43.400]  лемма, которая нам нужна для доказательств корректности,
[46:43.400 --> 46:53.400]  такая. Пусть f это некий поток величины k в g. Некий поток
[46:53.400 --> 47:14.400]  величины k в сети g. Тогда f является минкосткофло, если
[47:14.400 --> 47:20.400]  и только если в остаточной сети gf нет циклов отрицательного
[47:20.400 --> 47:26.400]  веса. Нет циклов? Ну, давайте нанесем отрицательные
[47:26.400 --> 47:39.400]  стоимости. То есть по факту мы можем доказать критерии
[47:39.400 --> 47:42.400]  того, что поток является минимальным. Поток является
[47:42.400 --> 47:46.400]  минимальным потоком вот той самой величины k. Поток
[47:46.400 --> 47:48.400]  является минимальным потоком величины k, если и только
[47:48.400 --> 47:52.400]  если в остаточной сети gf нет циклов отрицательного
[47:52.400 --> 47:56.400]  веса, нет циклов отрицательных стоимости. Пока я ничего
[47:56.400 --> 47:59.400]  не говорю про это. Без относительно исходного графа вот это
[47:59.400 --> 48:09.400]  всегда верно. Доказательства. Ну, в одну сторону вроде
[48:09.400 --> 48:15.400]  понятно. Слева направо уже понятно. Потому что если
[48:15.400 --> 48:19.400]  вдруг f это минимальный поток, но в остаточности есть цикл
[48:19.400 --> 48:22.400]  отрицательной стоимости, давайте я по этому циклу пущу
[48:22.400 --> 48:25.400]  днику потока, стоимость уменьшится. А потому что
[48:25.400 --> 48:27.400]  величина потока не изменилась, потому что у меня циркуляция
[48:27.400 --> 48:31.400]  всего лишь, само k не изменилось, и при этом добавилась
[48:31.400 --> 48:33.400]  отрицательная стоимость. Значит поток уменьшился по
[48:33.400 --> 48:41.400]  стоимости. Так как можно добавить поток по циклу?
[48:49.400 --> 48:52.400]  А это неважно. У нас в определении нигде не написано, и собственно
[48:52.400 --> 48:54.400]  вот здесь в виде композиции потока нам никто не запрещает
[48:54.400 --> 48:57.400]  иметь вот такие странные просто кружочки где-то в воздухе
[48:57.400 --> 49:02.400]  витающее. Такое вполне валидно по определению.
[49:10.400 --> 49:14.400]  Так, обратно чуть похитрее.
[49:14.400 --> 49:20.400]  Давайте обратно от противного. От противного.
[49:20.400 --> 49:24.400]  Значит пусть в gf нет отрицательных циклов, но при этом f не
[49:24.400 --> 49:36.400]  минимальный. Пусть в gf нет отрицательных циклов, но f не
[49:36.400 --> 49:42.400]  минимальный. Не минимальный.
[49:42.400 --> 49:44.400]  Давайте тогда рассмотрим настоящий минимальный поток
[49:44.400 --> 49:51.400]  в величины k. Пусть f звездочка это тот самый минкост
[49:51.400 --> 49:58.400]  ковлоу. То есть пусть f не настоящий, а в величины
[49:58.400 --> 50:02.400]  k настоящий. На поток минимальной стоимости в величины
[50:02.400 --> 50:09.400]  k. Дальше рассмотрим следующую странную штуку. Мы введем
[50:09.400 --> 50:14.400]  поток равный разности потоков f звездочка минус f.
[50:14.400 --> 50:17.400]  То есть просто на каждом ребре я посчитаю, вот если у меня
[50:17.400 --> 50:21.400]  f звездочка тек такой-то поток, f тек такой-то поток, я их вычитаю
[50:21.400 --> 50:28.400]  и говорю, что теперь по этому ребру течет просто их разность.
[50:28.400 --> 50:34.400]  Ещё раз? А что значит ребра нет? У нас сеть-то одинаковая.
[50:34.400 --> 50:41.400]  f звездочка на каждом ребре определён. У нас определение
[50:41.400 --> 50:44.400]  потока, что это функция из множества ребер, в целое число.
[50:44.400 --> 50:47.400]  Поэтому это для каждой ребре определено. Возможно она 0,
[50:47.400 --> 50:50.400]  просто не течёт потока, но тогда здесь 0 написано.
[50:50.400 --> 50:58.400]  Я утверждаю, что это поток в сети gf.
[50:58.400 --> 51:01.400]  Почему? Давайте докажем. Давайте просто по определению
[51:01.400 --> 51:05.400]  покажем, что этот поток, давайте уточним, что здесь просто
[51:05.400 --> 51:09.400]  порёберно я беру и вычитаю. На каждом ребре у меня величина
[51:09.400 --> 51:14.400]  потока равна разности вот этих двух штук для любого ребра E.
[51:14.400 --> 51:18.400]  Я утверждаю, что такая штука это поток в gf.
[51:18.400 --> 51:21.400]  Почему? Давайте вспомним определение потока и все
[51:21.400 --> 51:26.400]  тарисовости проверим. Во-первых, мне нужно, чтобы поток не
[51:26.400 --> 51:32.400]  происходил к апассити. Что такое E? Давайте перепишу, что
[51:32.400 --> 51:38.400]  f звездочка от E минус f от E. Дальше, поскольку f звездочка
[51:38.400 --> 51:42.400]  это поток в исходной сети, то f звездочка ограничена
[51:42.400 --> 51:47.400]  капасситию, а минус f от E я так и перепишу. На раз
[51:47.400 --> 51:51.400]  звездочка потока, то звездочка ограничена капасситию.
[51:51.400 --> 51:55.400]  Но это в точности остаточная capacity ребра E. То есть это
[51:55.400 --> 52:01.400]  capacity ребра E в сети gf. То, что мы хотим.
[52:01.400 --> 52:05.400]  Второе, антисимметричность. Ну, вроде совсем тривиально.
[52:05.400 --> 52:10.400]  Если я рассмотрю g на ребре УВ... Ой, даже писать лень.
[52:10.400 --> 52:18.400]  Ну давайте уж напишем. Вот. Поскольку f и f звездочка это
[52:18.400 --> 52:22.400]  потоки, то они антисимметричны, поэтому после свопа
[52:22.400 --> 52:29.400]  аргументов у меня минус вылезет за скобку.
[52:29.400 --> 52:33.400]  Но это просто по определению минус g от ВЛ.
[52:33.400 --> 52:37.400]  Поэтому антисимметричность тоже есть. g от УВ равно минус g от ВУ.
[52:37.400 --> 52:41.400]  Ну и третье, сохранение потока. Ну тоже, наверное, очевидно.
[52:41.400 --> 52:45.400]  Я не буду это расписывать. Если я рассмотрю произвольную вершину
[52:45.400 --> 52:51.400]  отличную от старта и финиша, то что такое сохранение потока?
[52:51.400 --> 52:55.400]  Давайте на пальцах я это покажу. Сохранение потока это когда втекает
[52:55.400 --> 52:59.400]  столько, сколько вытекает. Ну смотрите, понятно, что если в В
[52:59.400 --> 53:02.400]  с помощью потока f звездочка втекло сколько-то и вытекло сколько-то,
[53:02.400 --> 53:06.400]  то суммарный баланс звездочки это 0. То же самое относительно f.
[53:06.400 --> 53:09.400]  Сколько-то втекло, сколько-то вытекло, суммарный баланс 0.
[53:09.400 --> 53:13.400]  Но теперь если я вычту 0 из 0, получится 0. Потому что у меня
[53:13.400 --> 53:17.400]  на каждом ребре будет написана какая-то разность, но если я должен
[53:17.400 --> 53:20.400]  просуммировать буду, когда я суммирую вот эти вот жешки, я суммирую f-ки
[53:20.400 --> 53:24.400]  и вычитаю сумму вот этих f-ок. Но если это 0 и это 0, то получается, что сумма
[53:24.400 --> 53:28.400]  тоже будет нулевая. Поэтому сохранение потока тоже будет.
[53:28.400 --> 53:32.400]  Нормально расписать, просто по определению, что такое поток, как бы
[53:32.400 --> 53:36.400]  вот сумма вот этих штук, расписать, что g это f, f звездочка минус f,
[53:36.400 --> 53:40.400]  но каждый из них распадается в 0 и получается 0-0.
[53:40.400 --> 53:44.400]  Вот, поэтому реально поток.
[53:44.400 --> 53:48.400]  Зачем это нам нужно?
[53:48.400 --> 53:52.400]  А какой величины этот поток?
[53:52.400 --> 53:56.400]  Загадка.
[53:56.400 --> 54:00.400]  Было два потока величины k, мы их вычули, что получилось.
[54:00.400 --> 54:04.400]  Какой величины, какой поток мы получили?
[54:04.400 --> 54:08.400]  Наверное, 0 раз k минус k.
[54:16.400 --> 54:20.400]  Значит, более того, это не просто какой-то поток, но поток величины 0.
[54:20.400 --> 54:24.400]  Потому что величина потока
[54:24.400 --> 54:28.400]  это сумма f-ок, исходящих из старта.
[54:28.400 --> 54:32.400]  Вот у меня есть старт, мне нужно просуммировать все потоки, выходящие отсюда.
[54:32.400 --> 54:36.400]  Но смотрите, если я знаю, что сумма f звездочек это k,
[54:36.400 --> 54:40.400]  вот на этих ребрах сумма звездочка это k, потому что f звездочка – это поток величины k.
[54:40.400 --> 54:44.400]  Я знаю, что сумма f-ок это k, потому что f – это тоже поток величины k.
[54:44.400 --> 54:48.400]  Теперь, если я их все вычту, из каждой f звездочки вычту f,
[54:48.400 --> 54:54.580]  ших равна нулю. Суммарно известно, ничего не вытекает. Поэтому это не просто какой-то
[54:54.580 --> 55:01.720]  поток, это поток величины ноль. А значит, по леммио декомпозиции потока, g на самом
[55:01.720 --> 55:05.820]  деле просто представляет собой объединение нескольких циклов. Потому что раз это поток
[55:05.820 --> 55:09.680]  величины ноль, то путей в нем нет. Наличие пути означало бы, что по нему течет
[55:09.680 --> 55:14.180]  единичка потока, значит там хотя бы единица величина будет. Значит, по леммио
[55:14.180 --> 55:24.400]  предыдущей g это так называемая циркуляция. Значит, раз g поток
[55:24.400 --> 55:36.940]  величины ноль, то g это циркуляция. То есть, распадается в сумму циклов.
[55:36.940 --> 55:52.660]  И это, напоминаю, все происходит в остаточной сети gf. Не в исходной сети, а вот в остаточной, в gf.
[55:52.660 --> 55:59.000]  Потому что вот здесь вот я когда доказывал, что поток не больше чем capacity, вот это g не
[55:59.000 --> 56:03.880]  больше чем c, cf. Здесь важно, что именно остаточная capacity, потому что с обычной
[56:03.880 --> 56:07.960]  capacity я бы такого не мог доказать. То есть, я не всегда верно, что уже меньше чем c,
[56:07.960 --> 56:13.320]  если вычесть f, которое могло быть отрицательным, то получится как раз верное уже неравенство.
[56:13.320 --> 56:24.580]  Так, ну и чего? И мы же знаем на самом деле, что стоимость f звездочки, давайте я обозначу
[56:25.300 --> 56:31.780]  кост от потока, это его суммарная стоимость, суммарная стоимость потока.
[56:31.780 --> 56:47.860]  Тогда мы знаем, что кост от f больше, чем кост от f звездочка. Мы знаем по линейности, что кост от g
[56:47.860 --> 57:02.300]  это кост от f звездочка минус кост от f, значит это меньше нуля. То есть, мы получили циркуляцию
[57:02.300 --> 57:08.300]  отрицательной стоимости, а циркуляция это набор нескольких циклов. А раз набор нескольких циклов
[57:08.300 --> 57:11.700]  суммарно имеет отрицательную стоимость, то по крайней мере один цикл там отрицательный.
[57:11.700 --> 57:31.420]  Значит, по крайней мере один отрицательный цикл есть в gf, есть противоречие, мы предположим, что их нету.
[57:42.260 --> 57:42.780]  Ну как?
[57:52.780 --> 57:59.460]  Так, вроде доказали. Мы доказали критерий минимальной стоимости конкретного потока.
[57:59.460 --> 58:06.580]  Поток является потоком минимальной стоимости, если в осадочной сети относительно него нету отрицательных циклов.
[58:06.580 --> 58:16.300]  Тогда. Значит, тогда, тогда, тогда. Что мы теперь можем сказать?
[58:16.300 --> 58:38.860]  Давайте утверждение. Пусть в исходной сети g нет циклов отрицательного веса.
[58:46.860 --> 58:53.500]  Нет циклов отрицательного веса. И давайте мы запустим вот тот наш алгоритм тупой,
[58:53.500 --> 58:56.220]  который просто многократно находит кратчайший путь, и пускает там в единичку потока.
[58:56.220 --> 59:03.340]  Вот давайте мы его запустим на несколько терраций. Давайте на одну.
[59:03.380 --> 59:16.540]  Давайте на одну. Пусть p это кратчайший путь в g, ну естественно, из s в t.
[59:16.540 --> 59:22.820]  Ну и соответственно поток f пускает по нему единицу потока.
[59:23.300 --> 59:30.860]  f поток величины 1 вдоль этого пути, величины 1 вдоль этого пути.
[59:30.860 --> 59:42.300]  Тогда утверждается в gf тоже нет отрицательных циклов.
[59:42.300 --> 59:57.580]  Тоже нет отрицательных циклов. А значит, полемия f это минимальный поток величины 1.
[59:57.580 --> 01:00:05.260]  Итак, еще раз утверждение. Предположим, что изначально в самой сети g,
[01:00:05.260 --> 01:00:09.780]  которая нам на вход подается, вот пусть в ней изначально нет циклов отрицательного веса.
[01:00:09.780 --> 01:00:17.180]  И давайте мы найдем кратчайший путь из s в t, пусть это путь p. Мы по нему проталкиваем единицу потока,
[01:00:17.180 --> 01:00:24.340]  то есть f это просто единица потока вдоль этого пути p. Тогда оказывается, что если я построю
[01:00:24.340 --> 01:00:29.140]  остаточную сеть gf, то в ней тоже отрицательных циклов не будет. И если мы это докажем,
[01:00:29.140 --> 01:00:34.180]  то получается, что проталкивание единицы потока по кратчайшему пути нам не порождает отрицательных
[01:00:34.180 --> 01:00:38.900]  циклов. То есть если я пустил единицу, циклов нет отрицательных, опять пустил единицу,
[01:00:38.900 --> 01:00:42.700]  опять циклов нет отрицательных, по этому утверждению. И так многократно повторяя,
[01:00:42.700 --> 01:00:46.780]  у меня на каждом шаге получается, что в остаточной сети не будет циклов отрицательного веса.
[01:00:46.780 --> 01:00:50.980]  Ну а раз их нет, то по олемме мы каждый раз будем получать минимальный поток,
[01:00:50.980 --> 01:00:57.540]  минимальный стоимость, поток минимальной стоимости данной величины. Вот доказательства.
[01:00:57.540 --> 01:01:18.500]  Ну, наверное, от противного опять. Пусть они появились, пусть в gf появился какой-то
[01:01:18.500 --> 01:01:37.860]  отрицательный цикл. Отрицательный цикл с. Так.
[01:01:49.460 --> 01:01:53.060]  Давайте я тогда нарисую, что происходило. Вот смотрите, у меня был какой-то кратчайший
[01:01:53.060 --> 01:02:00.500]  путь из s в t, это был путь p. После перехода к остаточной сети, после перехода к gf,
[01:02:00.500 --> 01:02:04.180]  что происходит? Ну, возможно, появляются какие-то отрицательные ребра. Сорри,
[01:02:04.180 --> 01:02:10.820]  обратные ребра. Да, появляются обратные ребра. Ну, то есть они как бы и так были,
[01:02:10.820 --> 01:02:13.420]  но в остаточной сети они появляются в том смысле, чтобы по ним положительная
[01:02:13.420 --> 01:02:18.540]  копасть остается. Потому что я считаю, что ребра нулевой копасти я игнорирую, не учитываю
[01:02:18.540 --> 01:02:25.660]  во всех этих обсуждениях как бы нет нулевых копасти. Так вот, и здесь появился отрицательный
[01:02:25.660 --> 01:02:30.740]  цикл. Ну, видимо, он тогда вынужден хотя бы одной из этих ребр задействовать, потому что
[01:02:30.740 --> 01:02:35.020]  иначе он был бы и в исходном графе, получили бы противоречие. Ну, давайте как-нибудь я его
[01:02:35.020 --> 01:02:41.660]  нарисую. Что-нибудь. Он на самом деле довольно мерзко может выглядеть. Давайте я что-нибудь
[01:02:41.780 --> 01:02:53.300]  достаточно мерзко нарисую. Вот так вот. Нет, ладно, мне лень. Какой такой цикл? Пусть будет такой цикл.
[01:02:53.300 --> 01:03:05.300]  Это цикл с отрицательным весом. Тогда давайте рассмотрим поток P плюс C. Вот на этой картинке
[01:03:05.300 --> 01:03:10.940]  что такое P плюс C? Это вот здесь нужно единичку отменить, а вот здесь единичку пропустить.
[01:03:10.940 --> 01:03:21.180]  Получается, что P плюс C это вот такой вот какой-то путь из С в Т. То есть, если я складываю
[01:03:21.180 --> 01:03:26.940]  единицу потока здесь и единицу потока текущую по этому циклу, то у меня на общих ребрах поток
[01:03:26.940 --> 01:03:36.140]  отменяется как бы, зато вот эти вот ребра включаются в наш путь. Что получается? Получается,
[01:03:36.140 --> 01:03:43.980]  что вот этот поток P плюс C это на самом деле поток величины 1 в исходной сети. Поток величины 1 в G.
[01:03:43.980 --> 01:03:51.060]  Ну, понятное дело, что его величина не изменилась, потому что это поток величины 1, а это поток
[01:03:51.060 --> 01:03:56.420]  величины 0. В сумме идет 1. Ну и почему это поток в сети G? Ну, потому что как раз вот эти вот обратные
[01:03:56.420 --> 01:04:01.460]  ребра, если тут и появлялись, то они сократились, потому что тут один и здесь один. Поэтому обратные
[01:04:01.460 --> 01:04:08.900]  ребра как бы как раз исчезли. Вот. Хорошо, но мы знаем, что по лемме декомпозиции потока поток
[01:04:08.900 --> 01:04:14.420]  величины 1 это путь плюс, возможно, несколько циклов. То есть, на самом деле, P плюс C у меня картинка
[01:04:14.420 --> 01:04:20.100]  такая хорошая получилась, что у меня просто путь. Но в общем случае, это путь какой-то там кривой и,
[01:04:20.100 --> 01:04:27.380]  возможно, несколько циклов. То есть, если здесь C как-нибудь более мерзко бы выглядел, у меня,
[01:04:27.380 --> 01:04:33.300]  возможно, было бы такое, что после суммирования с П-шкой какие-то ребра аннигилируют и у меня,
[01:04:33.300 --> 01:04:40.900]  соответственно, могли бы возникнуть какие-то такие циклы в висящем воздухе. Но зато, смотрите,
[01:04:40.900 --> 01:04:47.300]  я знаю, что поскольку все происходит в сети G в изначальной сети, я знаю, что в ней отрицательных
[01:04:47.300 --> 01:04:55.580]  циклов нету, поэтому стоимости всех вот этих товарищей не отрицательны. А здесь стоимость этой
[01:04:55.580 --> 01:05:02.100]  штуки хотя бы такая же, как стоимость у P. Ну просто потому, что P это был кратчайший путь из С в Т в
[01:05:02.100 --> 01:05:06.860]  исходном графе. А это какой-то путь из С в Т в исходном графе. Значит, его стоимость может быть только
[01:05:06.860 --> 01:05:16.220]  больше равна, чем стоимость P, так как P кратчайший. Ну и значит, мы получили, что суммарная стоимость
[01:05:16.220 --> 01:05:23.860]  нашего потока P плюс С больше или равна стоимости P, потому что все циклы у меня не отрицательные,
[01:05:23.860 --> 01:05:30.620]  а этот путь имеет вес хотя бы такой же, как у P. Поэтому мы получили такое неравенство. Но это
[01:05:30.620 --> 01:05:47.420]  противоречит тому, что кост С отрицательна. Потому что стоимость у меня, понятное дело,
[01:05:47.420 --> 01:05:58.580]  линейная по потоку, а суммирование потоков должно дать сумму стоимости. Противоречие.
[01:05:58.580 --> 01:06:07.580]  Вот. Ну все, мы доказали, что отрицательных циклов не возникают. То есть, если их не было изначально,
[01:06:07.580 --> 01:06:15.380]  то их никогда и не возникнет. Поэтому корректно работает наш алгоритм, который я в самом начале
[01:06:15.380 --> 01:06:21.380]  заявил. Если в исходной сети нет отрицательных циклов, я просто многократно нахожу в остаточной
[01:06:21.380 --> 01:06:26.660]  сети кратчайший путь с помощью Форда Белманна, например, пропускаю по нему единицу потока и
[01:06:26.660 --> 01:06:31.620]  перестраиваю остаточную сеть. Отрицательных циклов никогда не появляется, поэтому Фор Белманн
[01:06:31.620 --> 01:06:37.260]  всегда за 1-1 итерацию найдет нормальный кратчайший путь, и по нему можно будет пускать потоки. Все будет
[01:06:37.260 --> 01:06:57.780]  хорошо. Вот. Давайте зафиксируем, что асимптотика у меня будет, видимо, к на ve, потому что я вот столько
[01:06:57.780 --> 01:07:11.180]  раз запускаю Форда Белманна. Просто Фор Белманн. Вот. Ну а корректность следует из-за того, что вот мы
[01:07:11.180 --> 01:07:16.860]  сейчас все доказали. Так, в принципе, это уже достаточно хорошо. К раз пустить Фор Белманна,
[01:07:16.860 --> 01:07:23.500]  это уже достаточно хорошо. Но, на самом деле, можно эту штуку ускорить. Можно использовать так
[01:07:23.500 --> 01:07:33.740]  называемые потенциалы Джонсона. И вместо Фор Белманна пускать дэйкстру, которая работает быстрее.
[01:07:33.740 --> 01:07:50.380]  Так, сейчас будет магия арифметическая. Смотрите, в чем проблема дэйкстры по сравнению с Фор Белманном?
[01:07:50.380 --> 01:07:57.940]  В том, что она не умеет работать с отрезательными ребрами. В каком смысле проблема и у Фор Белманна,
[01:07:57.940 --> 01:08:02.740]  и у дэйкстра. Но мы сказали, что их нет. Мы считаем, что их в исходности нет. Они не появляются,
[01:08:02.740 --> 01:08:07.940]  поэтому отрезательных циклов нет. Давайте забыли про них. Понятное дело, что бывают отрезательные
[01:08:07.940 --> 01:08:12.980]  ребра. Когда я ввожу у каждого ребра обратное, у него будет противоположная стоимость, поэтому там
[01:08:12.980 --> 01:08:18.620]  явно одно из них отрицательно. Вот. Дэйкстр с ними не умеет работать. Так вот, давайте сделаем что-нибудь,
[01:08:18.620 --> 01:08:23.620]  какую-нибудь магию, чтобы все веса стали не отрицательными. И тогда уже можно будет пускать дэйкстру.
[01:08:23.620 --> 01:08:32.900]  Для этого мы хотим придумать какую-нибудь такую функцию, которая каждой вершине сопоставляет число.
[01:08:32.900 --> 01:08:46.900]  И тогда стоимость каждого ребра у В преобразуется в стоимость потенциала Фи, с учетом потенциала
[01:08:46.900 --> 01:08:56.460]  Фи следующим образом. Значит, это будет кост плюс потенциал начала минус потенциал конца. Вот просто
[01:08:56.460 --> 01:09:01.500]  если было ребро, то давайте мы добавим к его стоимости Фи от начала минус Фи от конца. Это будет у
[01:09:01.500 --> 01:09:09.900]  меня новая весовая функция, новая функция стоимости. Чем хорошо такое преобразование? Оно хорошо тем,
[01:09:09.900 --> 01:09:15.980]  что оно сохраняет кратчайшие пути. Потому что, смотри, давайте я рассмотрю произвольный путь. Вот
[01:09:15.980 --> 01:09:23.940]  какой-то путь. Давайте из х в у. Что меняется с его стоимостью после перехода к вот этим вот новым
[01:09:23.940 --> 01:09:33.980]  стоимостим? От коста к кост Фи. Ну понятно, смотрите, у меня стоимость этого ребра меняется на Фи от х
[01:09:33.980 --> 01:09:39.860]  минус Фи от вот этой вершинки, там не знаю, z. Стоимость этого ребра меняется на плюс Фи от z,
[01:09:39.860 --> 01:09:46.060]  минус Фи вот этой вот A. Потом будет плюс Фи от A минус Фи от B минус Фи от B плюс Фи от C. Ну и так
[01:09:46.060 --> 01:09:52.100]  далее, получается, что все вот эти промежу 중요ны потенциалы умрут. И останется только плюс Фи
[01:09:52.100 --> 01:10:00.920]  от x минус Фи от y. То есть новая потенциальная стоимость пути p, это его изначальная стоимость
[01:10:00.920 --> 01:10:06.340]  в исходном графе. Плюс потенциал начала пути минус потенциал конца пути Фи от x минус Фи
[01:10:06.340 --> 01:10:14.340]  Ну а поскольку у меня x и y так фиксированы, если я ищу пути из x в y, то у меня эта штука какая-то константа,
[01:10:14.340 --> 01:10:22.340]  а значит у меня все пути предсказуемо изменили свою стоимость. Каждый путь изменил стоимость на константу,
[01:10:22.340 --> 01:10:27.340]  которая не зависит от самого пути, а зависит только от начала и конца, но они у меня считаются фиксированы.
[01:10:27.340 --> 01:10:30.340]  Пути у меня между одной и другой вершиной.
[01:10:31.340 --> 01:10:38.340]  Значит в частности сохранятся кратчайшие пути, но раз сохранятся кратчайшие пути, то значит Dextra
[01:10:38.340 --> 01:10:43.340]  сможет находить кратчайшие пути в том графе, потому что Dextra ищет кратчайшие пути,
[01:10:43.340 --> 01:10:48.340]  значит это будет кратчайшие пути и в обычной вот этой вот стоимостьной функции кост.
[01:10:48.340 --> 01:10:53.340]  Мне осталось потребовать, чтобы эта штука была не отрицательна, и тогда я смогу применять Dextra.
[01:11:00.340 --> 01:11:16.340]  Добьемся мы этого очень простым трюком. Мы потребуем, чтобы потенциал каждой вершины в точности совпадал с расстоянием от s до нее.
[01:11:16.340 --> 01:11:27.340]  Потенциал равен расстоянию. Почему тогда будет верно, что все косты не отрицательны?
[01:11:27.340 --> 01:11:35.340]  Вот эти вот новые, почему кост Фи для ОВ больше равно нуля?
[01:11:35.340 --> 01:11:38.340]  Ну на самом деле просто по неравенству треугольника.
[01:11:38.340 --> 01:11:47.340]  Потому что что такое кост Фи? Это кост ребра плюс начало, минус конец.
[01:11:47.340 --> 01:11:59.340]  Потенциал это расстояние от s до них.
[01:11:59.340 --> 01:12:06.340]  Смотрите, вот здесь вот написано расстояние от s до u плюс стоимость этого ребра.
[01:12:06.340 --> 01:12:10.340]  А там написано минус расстояние от s до v.
[01:12:10.340 --> 01:12:14.340]  Понятное дело, что расстояние от s до v не больше, чем вот эта вот сумма.
[01:12:14.340 --> 01:12:25.340]  Давайте напишем, что расстояние от s до v не больше, чем дист su плюс кост v.
[01:12:25.340 --> 01:12:30.340]  Ну значит вот эта вот слагаемая, точнее вычитаемое не больше, чем уменьшаемое.
[01:12:30.340 --> 01:12:37.340]  Поэтому это больше сумма. Профит. Просто не нравится треугольника.
[01:12:37.340 --> 01:12:42.340]  Ну давайте пытаться поддерживать. Если у меня это выполняется, то можно пускать dx у Ранифорд Белмана.
[01:12:42.340 --> 01:12:45.340]  Потому что у меня все косты стали не отрицательными.
[01:12:45.340 --> 01:12:58.340]  Хорошо.
[01:12:58.340 --> 01:13:07.340]  Давайте поймем, что происходит, если опускаю dx тогда.
[01:13:07.340 --> 01:13:12.340]  Ну хорошо. Тогда как у меня будет выглядеть алгоритм на самом деле?
[01:13:12.340 --> 01:13:16.340]  Понятное дело, что мне нужно вначале хотя бы один раз Форд Белмана пустить.
[01:13:16.340 --> 01:13:20.340]  Потому что мне же нужно откуда-то дисты взять. Для потенциала мне нужны дисты.
[01:13:20.340 --> 01:13:23.340]  Но в исходной сети есть отрицательные ребра.
[01:13:23.340 --> 01:13:26.340]  И ничего лучше, чем Форд Белмана, вот здесь пока не получится.
[01:13:26.340 --> 01:13:28.340]  То есть один раз его нужно запустить.
[01:13:28.340 --> 01:13:30.340]  То есть один раз я запускаю Форд Белмана.
[01:13:30.340 --> 01:13:35.340]  Один раз.
[01:13:35.340 --> 01:13:39.340]  Чтобы посчитать дисты, а значит потенциалы изначальные.
[01:13:39.340 --> 01:13:42.340]  Потом дальше. Смотрите.
[01:13:42.340 --> 01:13:45.340]  Вот если я один раз его пустил, пересчитал потенциал и пересчитал косты все.
[01:13:45.340 --> 01:13:47.340]  Кост с индексом Фи стали.
[01:13:47.340 --> 01:13:53.340]  Тогда вот в этой новой стоимостьной функции кост Фи,
[01:13:53.340 --> 01:13:57.340]  если я рассмотрю кратчайший путь из S в T,
[01:13:57.340 --> 01:14:00.340]  он на самом деле имеет нулевой вес.
[01:14:00.340 --> 01:14:03.340]  Все вот эти косты будут нулевые.
[01:14:03.340 --> 01:14:06.340]  В кост Фи, в новой стоимостьной функции.
[01:14:06.340 --> 01:14:09.340]  Ну потому что все эти ребра лежат на кратчайшем пути из S в T.
[01:14:09.340 --> 01:14:14.340]  А значит вот здесь вот неравенство треугольника, везде строгое равенство будет.
[01:14:14.340 --> 01:14:17.340]  Раз это кратчайший путь, то все эти ребра лежат на кратчайшем пути.
[01:14:17.340 --> 01:14:19.340]  А значит здесь не такая картинка, а вот такая.
[01:14:19.340 --> 01:14:22.340]  Сначала вот S до U, потом с помощью ребра до V.
[01:14:22.340 --> 01:14:26.340]  Поэтому здесь на самом деле все будут равенства.
[01:14:26.340 --> 01:14:30.340]  И кратчайший путь будет иметь вес с точностью 0.
[01:14:30.340 --> 01:14:35.340]  То есть я буду пускать поток по пути стоимости 0.
[01:14:35.340 --> 01:14:38.340]  Но когда я пускаю здесь поток величины 1,
[01:14:38.340 --> 01:14:43.340]  у меня возникают обратные ребра.
[01:14:43.340 --> 01:14:50.340]  Но они сейчас тоже имеют нулевой вес.
[01:14:50.340 --> 01:14:54.340]  Потому что стоимости обратных ребров обратно.
[01:14:54.340 --> 01:14:57.340]  И это сохраняется даже после навешивания потенциала,
[01:14:57.340 --> 01:15:00.340]  потому что здесь они поменяются местами, поменяются знаками,
[01:15:00.340 --> 01:15:03.340]  и как раз все сохранится, останутся нули.
[01:15:03.340 --> 01:15:07.340]  То есть при введении обратных ребров они тоже будут иметь нулевой вес.
[01:15:07.340 --> 01:15:10.340]  А значит отрицательных стоимости не появятся.
[01:15:10.340 --> 01:15:14.340]  Единственное, что может сломаться, это вот это вот может нарушиться.
[01:15:14.340 --> 01:15:17.340]  Потому что у меня появляются какие-то ребра,
[01:15:17.340 --> 01:15:20.340]  какие-то возможно исчезают, если ребро насыщается.
[01:15:20.340 --> 01:15:25.340]  Значит вот это вот уже меняется.
[01:15:25.340 --> 01:15:27.340]  Давайте их пересчитаем просто.
[01:15:27.340 --> 01:15:31.340]  Благо отрицательных ребров не появился, а значит можно пускать dx.
[01:15:31.340 --> 01:15:33.340]  Еще раз, да?
[01:15:33.340 --> 01:15:34.340]  Какая тогда схема?
[01:15:34.340 --> 01:15:37.340]  Я один раз пересчитал потенциал в самом начале с помощью Форд Белмана.
[01:15:37.340 --> 01:15:40.340]  Затем, чтобы найти кратчайший путь,
[01:15:40.340 --> 01:15:44.340]  мне нужно просто найти путь по ребрам нулевого веса из ft.
[01:15:44.340 --> 01:15:47.340]  Я пускаю здесь единицу потока, у меня появляются обратные ребра,
[01:15:47.340 --> 01:15:50.340]  а здесь пускаю dx и пересчитываю потенциал.
[01:15:50.340 --> 01:15:52.340]  Потому что здесь уже можно пускать dx,
[01:15:52.340 --> 01:15:54.340]  потому что нету отрицательных ребер.
[01:15:54.340 --> 01:15:57.340]  Но потенциал придется изменить, потому что у меня изменился граф.
[01:15:57.340 --> 01:16:00.340]  А значит вот эти вот штуки могли измениться.
[01:16:00.340 --> 01:16:03.340]  Ну а потенциал можно изменить просто зная вот эти дисты.
[01:16:03.340 --> 01:16:07.340]  Я их знаю с помощью dx и просто пересчитываю потенциал.
[01:16:07.340 --> 01:16:08.340]  Вот.
[01:16:08.340 --> 01:16:10.340]  Все, значит алгоритм будет такой.
[01:16:10.340 --> 01:16:15.340]  Давайте я такой супер псевдокод напишу.
[01:16:15.340 --> 01:16:22.340]  Мне нужна процедура применить потенциал фи.
[01:16:22.340 --> 01:16:26.340]  Это вот как раз вот это преобразование, переход от кост к кост фи.
[01:16:26.340 --> 01:16:35.340]  Для любого ребра я его стоимость изменяю на фи от у минус фи от в.
[01:16:35.340 --> 01:16:45.340]  Меняю стоимость вот как раз так, как потенциал предписывает.
[01:16:45.340 --> 01:16:49.340]  Дальше.
[01:16:49.340 --> 01:16:56.340]  Изначально я говорю, что пусть фи это Форд Белман
[01:16:56.340 --> 01:17:02.340]  в нашем графе и применяю этот потенциал.
[01:17:02.340 --> 01:17:07.340]  Затем карас.
[01:17:07.340 --> 01:17:12.340]  Нахожу кратчайший путь, пуская по нему единицу потока.
[01:17:12.340 --> 01:17:22.340]  Найти и пустить единицу потока по кратчайшему пути.
[01:17:22.340 --> 01:17:26.340]  Затем считаю dx.
[01:17:32.340 --> 01:17:36.340]  Потому что все веса не отрицательны.
[01:17:36.340 --> 01:17:41.340]  Я могу пустить dx и опять применяю потенциал.
[01:17:41.340 --> 01:17:45.340]  Потому что я хочу, чтобы у меня выполнялось вот это вот соотношение.
[01:17:45.340 --> 01:17:49.340]  Если я просто его прибавлю, если я потенциал пси прибавлю к изначальному потенциалу фи,
[01:17:49.340 --> 01:17:53.340]  то у меня перестроится граф, перестроятся все стоимости, но опять сохранится вот это вот свойство.
[01:17:53.340 --> 01:17:58.340]  Потому что если в этой сети все выполнялось, то мне нужно просто применить новый потенциал пси,
[01:17:58.340 --> 01:18:04.340]  чтобы опять все стало выполняться в новом графе после пускания единицы потока.
[01:18:04.340 --> 01:18:09.340]  Ну и тогда асимптотика будет уже что? Уже будет v на e,
[01:18:09.340 --> 01:18:17.340]  плюс карас dx, ну dx там e лог v, например.
[01:18:17.340 --> 01:18:23.340]  Вот. Уже поприятнее.
[01:18:23.340 --> 01:18:25.340]  Все, спасибо.
