[00:00.000 --> 00:12.320]  0-knowledge proofs
[00:12.320 --> 00:31.200]  так ну а что вам рассказали может делать выжимку что может рассказать что и что вы из этого
[00:31.200 --> 00:41.480]  поняли значит сейчас историю про бабу вам рассказывали с пещерой да хорошо а про графы
[00:41.480 --> 01:01.920]  из морфизма так да это мне виталий писал что он там запутался и вы как-то не возвращались потом
[01:01.920 --> 01:28.840]  вам рассказывали так ну ладно что она наверное начнем значит на самом деле это вот это нулевое
[01:28.840 --> 01:33.800]  разглашение такой зонтичный термин да то есть есть несколько разных моделей которые называются
[01:33.800 --> 01:41.640]  как раз доказательства с нулевым разглашением и возможно загвоздка стояла в том что из морфизм
[01:41.640 --> 01:48.680]  графов и судовку относятся к разным понятиям и возможно была проблема в том что одно понятие
[01:48.680 --> 01:57.200]  пытались применить в другой ситуации да и она там не работала вот значит соответственно есть значит
[01:57.200 --> 02:07.520]  минимум три значит три варианта значит одно называется совершенно нулевое разглашение
[02:07.520 --> 02:23.320]  perfect 0-knowledge совершенно нулевое разглашение perfect 0-knowledge значит второй вариант называется
[02:23.320 --> 02:28.120]  статистически нулевое разглашение соответственно statistical 0-knowledge
[02:28.120 --> 02:41.400]  сзк и третий вариант это вычислитель нулевое разглашение
[02:41.400 --> 02:57.880]  это сзк значит computational 0-knowledge вот ну и мог быть еще всякие мелкие вариации но вот это
[02:57.880 --> 03:04.920]  три основных на самом деле прям основные это верхняя и нижняя вот а статистическая да с ним
[03:04.920 --> 03:15.360]  есть определение но так как-то про него мало чего известно что нет просто статистикал мало чего
[03:15.360 --> 03:27.840]  известно c это computational 0-knowledge соответственно из морфизм графов или например квадратичный
[03:27.840 --> 03:37.800]  вычет лежат верхней части в пзк вот а всякие нп полные задачи лежат в нижней части сзк ну и на
[03:37.800 --> 03:46.160]  самом деле там даже все и пи лежит вот но это уже не очень простая теорема вот с нп полными попроще
[03:46.300 --> 03:57.000]  вот хорошо значит чём идея в чём ваше парадигме нулевого разглашения как бы что означает что
[03:57.000 --> 04:08.560]  как бы собеседник ничего не узнал ну что hassle ничего ещё и узнал нечуновую не узнал а что значит
[04:08.560 --> 04:15.060]  что ничо нового не узнал чтобы все что узнал он и так знал но все-таки что это точно значат
[04:15.060 --> 04:21.620]  Да, кажется, что это некоторое противоречие с тем, что все-таки задача решена.
[04:21.620 --> 04:24.620]  Но он, как минимум, узнал, что мы че-то знаем.
[04:24.620 --> 04:34.620]  Ну да, значит, конечно, решение задачи он должен узнать.
[04:34.620 --> 04:44.620]  То есть если он раньше не знал, там, из-за мощного графа или нет, то теперь, соответственно, он это как бы должен узнать.
[04:45.180 --> 04:56.180]  На самом деле мы вообще вот это вот требование неразглашения будем накладывать только на тот случай, когда прувер честный и утверждение верное.
[04:56.180 --> 05:03.180]  Ну и при условии, что утверждение верное, информация о том, что оно верное, ничего не дает.
[05:03.740 --> 05:07.740]  Соответственно, в чем как бы загвоздка?
[05:07.740 --> 05:15.740]  Что нужно убедиться, что прувер знает доказательства, но при этом как-то не понять ничего про само доказательство.
[05:15.740 --> 05:23.740]  Да, и вот это вот некоторые противоречивые требования, которые как раз приводят к тому, что эта теория нетривиальная.
[05:24.300 --> 05:36.300]  При этом это вполне прикладной вопрос применительно к крипто-графическим задачам, например, к задачам аутентификации.
[05:36.300 --> 05:44.300]  Когда есть логин-пароль, и нужно как бы доказать, что знаешь пароль, но так, чтобы он не утек к кому-то еще.
[05:44.300 --> 05:52.300]  Ну и вот если система построена на нулевом разглашении, то он как бы не должен утечь математически.
[05:52.860 --> 06:00.860]  Есть такая фишинговая атака, что жертвы присылают ссылку на мошеннический сайт, который притворяется настоящим.
[06:00.860 --> 06:08.860]  И, соответственно, жертвы на этом мошенническом сайте вводят свои логин-пароль, и те, кто этот сайт сделал или узнают эти логин-пароль,
[06:08.860 --> 06:14.860]  потом идут на настоящий сайт, и там крадут деньги или узнают личную переписку.
[06:15.420 --> 06:23.420]  Если логин устроен на базе нулевого разглашения, то она в принципе невозможна.
[06:23.420 --> 06:31.420]  То есть жертва может зайти на этот сайт и даже введет там логин-пароль, но при этом хозяева сайта не узнают эти логин-пароль.
[06:31.420 --> 06:39.420]  То есть хозяева даже смогут проверить, что жертва знает логин-пароль, но сами узнать не смогут.
[06:39.980 --> 06:45.980]  Ну, конечно, есть какая-то вопроса, почему, собственно, все логины так не делают.
[06:45.980 --> 06:49.980]  Но там есть некоторые технические проблемы, связанные со скоростью работы и так далее.
[06:49.980 --> 06:55.980]  То есть теоретически это все хорошо работает за поллиминальное время, но фактически это поллиминальное время,
[06:55.980 --> 07:03.980]  это какие-нибудь секунды, получается, как минимум. Логин за 10 секунд, это уже не очень хорошо.
[07:04.540 --> 07:08.540]  Желательно, чтобы было за полсекунды максимум.
[07:12.540 --> 07:18.540]  Ну и, возможно, опять же какие-то аппаратные требования на клиентской стороне,
[07:18.540 --> 07:26.540]  потому что тут клиент в роли прувера выступает, поэтому нагруженные вычисления на стороне клиента получаются.
[07:27.100 --> 07:29.100]  Вот.
[07:33.100 --> 07:41.100]  Ну да, а как бы вообще, как бы один из, одна из современных пародий, чтобы все нагружные вычисления
[07:41.100 --> 07:47.100]  нужно, наоборот, на серфи приносить, там будет, ну, какой-нибудь облака, пластырь и так далее.
[07:47.100 --> 07:49.100]  Клиентский устройство прийти не очень сложно.
[07:49.660 --> 07:51.660]  Вот.
[07:51.660 --> 07:55.660]  Поэтому это такое, более-менее нишеное решение получается,
[07:55.660 --> 08:01.660]  что там, где клиент может быть высоко нагруженным, и там, где не важно задержать 10 секунд,
[08:01.660 --> 08:05.660]  там можно делать логин или разглашение.
[08:07.660 --> 08:09.660]  Вот, так.
[08:09.660 --> 08:11.660]  Хорошо.
[08:11.660 --> 08:13.660]  Значит, теперь определение.
[08:14.220 --> 08:18.220]  Ну, давайте, там, рисуем картинку, ну, верификатор.
[08:18.220 --> 08:24.220]  Значит, вот они как-то так друг с другом общаются.
[08:24.220 --> 08:30.220]  И в итоге, во-первых, верификатор должен сказать правильно.
[08:30.220 --> 08:34.220]  Да, на самом деле, я вот говорил, что нагруженные вычисления, на самом деле,
[08:34.220 --> 08:40.220]  часто все-таки это не очень сложные вычисления, не нужно, там, господи, слово, задачи решать,
[08:40.780 --> 08:44.780]  а нужно просто дать секрет, и над этим секретом какие-то вычисления очень сложно проживать.
[08:48.780 --> 08:50.780]  Вот.
[08:50.780 --> 08:52.780]  Хорошо.
[08:52.780 --> 08:54.780]  Соответственно, что знает верификатор?
[08:54.780 --> 08:58.780]  Ну, как бы, как нужно определить, что знает верификатор?
[08:58.780 --> 09:02.780]  Во-первых, он знает себя исключительно или так?
[09:03.340 --> 09:05.340]  Вот.
[09:05.340 --> 09:11.340]  Ну, и во-вторых, он знает все сообщения, которые он прислал целым.
[09:15.340 --> 09:29.260]  И, значит, соответственно, в данном случае может иметь смысл говорить про веря
[09:29.740 --> 09:35.740]  Верификатор тоже может использовать случайные биты, и у верификатора вот так вверх тоже случайно.
[09:35.740 --> 09:41.740]  Совершенно получается, ну, некоторое, такая большая случайная величина,
[09:41.740 --> 09:47.740]  которая стоит из вот этого вверх и всех, соответственно, вот этих сообщений.
[09:47.740 --> 09:53.740]  И, получается, верификатор как бы узнала одну реализацию этой случайной величины.
[09:54.220 --> 09:58.220]  То есть верификатор не прямо какое-то знание получил,
[09:58.220 --> 10:08.220]  а получил какое-то сообщение, которое является одной реализацией случайной величины, ну, с каким-то распределением.
[10:08.220 --> 10:10.220]  Что это значит?
[10:10.220 --> 10:12.220]  Да?
[10:12.220 --> 10:14.220]  В каком смысле реализация?
[10:14.220 --> 10:16.220]  Ну, чтобы реализация случайной величины.
[10:16.220 --> 10:20.220]  Ну, просто какая-то строка, которая случайно с таким распределилась.
[10:20.220 --> 10:22.220]  Случайная величина – это ее сно.
[10:22.700 --> 10:24.700]  Нет, случайная величина – это не ее сно.
[10:24.700 --> 10:26.700]  А это все, что верификатор знал.
[10:26.700 --> 10:28.700]  То есть его собственное случение.
[10:28.700 --> 10:30.700]  Биты, которые равномерно распределены.
[10:30.700 --> 10:34.700]  И плюс еще все сообщения откроют.
[10:34.700 --> 10:36.700]  Ну, и совпадные иски еще.
[10:36.700 --> 10:38.700]  Да?
[10:38.700 --> 10:40.700]  То есть совпадные дамы.
[10:44.700 --> 10:48.700]  Соответственно, ну, можно сказать, что для разных исков разное случение величины.
[10:49.180 --> 10:51.180]  Ну, это для разных сообщений тоже.
[10:51.180 --> 10:53.180]  Еще?
[10:53.180 --> 10:55.180]  Ну, там же сообщения тоже будут разные при разных.
[10:55.180 --> 10:57.180]  Ну, в смысле, М1.
[10:57.180 --> 11:01.180]  Нет, сообщения – это часть уже, часть реализации случайной величины.
[11:01.180 --> 11:03.180]  А вот X можно считать параметром.
[11:05.180 --> 11:07.180]  А случайная величина – это сам делу?
[11:07.180 --> 11:09.180]  Как?
[11:09.180 --> 11:11.180]  Ну, значит, смотрите.
[11:11.180 --> 11:13.180]  Еще раз.
[11:13.180 --> 11:15.180]  У нас есть...
[11:15.180 --> 11:17.180]  Да.
[11:17.660 --> 11:19.660]  Данные, пишущие в педали.
[11:19.660 --> 11:21.660]  Значит, это...
[11:27.660 --> 11:29.660]  Это понятительный спаст данный.
[11:29.660 --> 11:31.660]  И пианский флешбеки.
[11:33.660 --> 11:35.660]  Значит, это ве и пе.
[11:35.660 --> 11:39.660]  Это, значит, то, что верификатор видит в ходе общения с кодом.
[11:40.140 --> 11:42.140]  Ну, значит, можно...
[11:42.140 --> 11:44.140]  А, ну, это все же включено.
[11:44.140 --> 11:46.140]  Значит, это X входный данный.
[11:46.140 --> 11:48.140]  То есть как узнает.
[11:48.140 --> 11:50.140]  Это, например, это его случайные пинты.
[11:50.140 --> 11:52.140]  Да, значит, которые...
[11:54.140 --> 11:56.140]  Ну, в принципе, в предписном смысле определены.
[11:58.140 --> 12:00.140]  Вот.
[12:00.140 --> 12:02.140]  И это...
[12:02.140 --> 12:04.140]  Так, дайте я слова ему напишу.
[12:04.140 --> 12:06.140]  Значит, сообщение кодом.
[12:06.620 --> 12:08.620]  Сообщение кодом.
[12:10.620 --> 12:12.620]  Сообщение кодом.
[12:12.620 --> 12:14.620]  Значит, которые, конечно...
[12:16.620 --> 12:18.620]  Сообщения кодом определяются,
[12:18.620 --> 12:20.620]  во-первых, и к сону,
[12:20.620 --> 12:22.620]  которую кто же получает.
[12:22.620 --> 12:24.620]  Во-вторых, теми сообщениями,
[12:24.620 --> 12:26.620]  которые ему верификатор посылает
[12:26.620 --> 12:28.620]  и который свою очередь заедет в этот цирк
[12:28.620 --> 12:30.620]  и предыдущих сообщений.
[12:30.620 --> 12:32.620]  И потенциально еще
[12:32.620 --> 12:34.620]  случайными пинтами,
[12:34.620 --> 12:36.620]  которые сам Крувер использует.
[12:36.620 --> 12:38.620]  Ну, вот как с формальной точки зрения
[12:38.620 --> 12:40.620]  мы нормально задаем, ну, протокол
[12:40.620 --> 12:42.620]  общениями?
[12:42.620 --> 12:44.620]  Не, ну, протокол как раньше,
[12:44.620 --> 12:46.620]  да, что...
[12:46.620 --> 12:48.620]  Ну, если он не сказал, что
[12:48.620 --> 12:50.620]  от Крувер первым посылает,
[12:50.620 --> 12:52.620]  то у Крувера есть какое-то сообщение
[12:52.620 --> 12:54.620]  от X и его, ну, может быть, его секрет
[12:54.620 --> 12:56.620]  и его случайные пинты.
[12:56.620 --> 12:58.620]  Нет, ну, в смысле, это функция от протокола.
[12:58.620 --> 13:00.620]  Ну, от вью
[13:00.620 --> 13:02.620]  ВП. Как бы, а протокол
[13:02.620 --> 13:04.620]  это что-то, что тоже зависит.
[13:04.620 --> 13:06.620]  Так, значит, смотрите.
[13:06.620 --> 13:08.620]  Когда у нас был просто ай-пинит,
[13:08.620 --> 13:10.620]  то протокол определялся самим
[13:10.620 --> 13:12.620]  верификатором. То есть можно было
[13:12.620 --> 13:14.620]  сказать, что протокол — это функция,
[13:14.620 --> 13:16.620]  которая переводит предыдущий диалог
[13:16.620 --> 13:18.620]  в сообщение
[13:18.620 --> 13:20.620]  в новом сообщении верификатора.
[13:20.620 --> 13:22.620]  Вот. Здесь уже
[13:22.620 --> 13:24.620]  важно
[13:24.620 --> 13:26.620]  здесь уже важны обе стороны.
[13:26.620 --> 13:28.620]  То есть, тут есть
[13:28.620 --> 13:30.620]  предписанное поведение Крувера
[13:30.620 --> 13:32.620]  предписанное поведение верификатора.
[13:32.620 --> 13:34.620]  То есть, здесь мы протокол
[13:34.620 --> 13:36.620]  будем называть ПАМ
[13:36.620 --> 13:38.620]  из алгоритма
[13:38.620 --> 13:40.620]  для Крувера и алгоритма
[13:40.620 --> 13:42.620]  для верификатора. То есть, мы подозреваем,
[13:42.620 --> 13:44.620]  что у нас есть, грубо говоря, набор функций для каждой
[13:44.620 --> 13:46.620]  итерации, в смысле, для каждого.
[13:46.620 --> 13:48.620]  Ну, конечно, да. Можешь сказать, что это одна функция
[13:48.620 --> 13:50.620]  и получает весь предыдущий диалог и возвращает
[13:50.620 --> 13:52.620]  новое сообщение. И еще иметь доступ
[13:52.620 --> 13:54.620]  в случайный вид. Ну, по сути, две функции
[13:54.620 --> 13:56.620]  ВП и В.
[13:56.620 --> 13:58.620]  Что? Верификатор и
[13:58.620 --> 14:00.620]  Крувера. Ну, типа того, да.
[14:02.620 --> 14:04.620]  Весь протокол это
[14:06.620 --> 14:08.620]  ПАМ
[14:08.620 --> 14:10.620]  грубо говоря, верификатор.
[14:10.620 --> 14:12.620]  То есть, еще раз, верификатор получает весь предыдущий
[14:12.620 --> 14:14.620]  диалог. Вход
[14:14.620 --> 14:16.620]  X и свои случайные биты.
[14:16.620 --> 14:18.620]  А просьба получает весь предыдущий
[14:18.620 --> 14:20.620]  диалог. Вход X, секрет
[14:20.620 --> 14:22.620]  свой.
[14:22.620 --> 14:24.620]  Возможно.
[14:24.620 --> 14:26.620]  И еще свои случайные биты.
[14:26.620 --> 14:28.620]  А секрет это что?
[14:28.620 --> 14:30.620]  Ну, секрет это, может быть,
[14:30.620 --> 14:32.620]  что, например,
[14:32.620 --> 14:34.620]  X это
[14:34.620 --> 14:36.620]  какое-нибудь уравнение, а секрет это его решение.
[14:36.620 --> 14:38.620]  Не там X это хэрс значение,
[14:38.620 --> 14:40.620]  а секрет это
[14:40.620 --> 14:42.620]  прообраз этого хэрс значения.
[14:42.620 --> 14:44.620]  И там X это пары графов,
[14:44.620 --> 14:46.620]  а секрет это измахлость
[14:46.620 --> 14:48.620]  назначение.
[14:48.620 --> 14:50.620]  И как формально сфонолировать
[14:50.620 --> 14:52.620]  то, что у нас не произошло разложение?
[14:52.620 --> 14:54.620]  Что не произошло?
[14:54.620 --> 14:56.620]  А, нет, это сейчас.
[14:56.620 --> 14:58.620]  Окей, да.
[14:58.620 --> 15:00.620]  Вот как раз к этому подход.
[15:00.620 --> 15:02.620]  Wait.
[15:08.620 --> 15:10.620]  Так, давайте вот
[15:10.620 --> 15:12.620]  что. Тут еще, как
[15:12.620 --> 15:14.620]  аргумент, я напишу X.
[15:14.620 --> 15:16.620]  Да, мы постараемся, но ничего страшного.
[15:18.620 --> 15:20.620]  Вот. Значит, продигма
[15:20.620 --> 15:22.620]  такая, что
[15:22.620 --> 15:24.620]  которая для всех трех вариантов
[15:24.620 --> 15:26.620]  годится,
[15:28.620 --> 15:30.620]  что верификатор
[15:32.620 --> 15:34.620]  может
[15:34.620 --> 15:36.620]  сгенерировать
[15:36.620 --> 15:38.620]  случайную величину, которая
[15:38.620 --> 15:40.620]  похожа на...
[15:40.620 --> 15:42.620]  А, сейчас, давайте
[15:42.620 --> 15:44.620]  вспомните, еще
[15:44.620 --> 15:46.620]  одна важная вариация, это
[15:46.620 --> 15:48.620]  как бы с честным верификатором
[15:48.620 --> 15:50.620]  или с нечестным верификатором.
[15:52.620 --> 15:54.620]  Ну, не может быть отношения для честных
[15:54.620 --> 15:56.620]  верификаторов.
[15:56.620 --> 15:58.620]  Не может быть отношения
[15:58.620 --> 16:00.620]  для
[16:00.620 --> 16:02.620]  верификаторов.
[16:02.620 --> 16:04.620]  А если верификатор несчастный, он сам ничего не знает,
[16:04.620 --> 16:06.620]  как он может с каторой пройтись?
[16:08.620 --> 16:10.620]  Не, не, сейчас. Смотрите.
[16:10.620 --> 16:12.620]  Я сглашу, и должен пройтись.
[16:12.620 --> 16:14.620]  Разглашает он не сглашает
[16:14.620 --> 16:16.620]  пройтись. Что такое нечестный верификатор?
[16:16.620 --> 16:18.620]  Ну, сейчас это скажу.
[16:18.620 --> 16:20.620]  Это
[16:20.620 --> 16:22.620]  то, что вы отмечаете.
[16:24.620 --> 16:26.620]  Значит, смотрите.
[16:26.620 --> 16:28.620]  Идея с этим сайтом,
[16:28.620 --> 16:30.620]  с фальшивым сайтом,
[16:30.620 --> 16:32.620]  который для фельдшнеговой атаки сделана.
[16:34.620 --> 16:36.620]  Этот фальшивый логин может быть
[16:36.620 --> 16:38.620]  сделан как обычный логин,
[16:38.620 --> 16:40.620]  с тем самым алгоритмом.
[16:40.620 --> 16:42.620]  Но, в принципе, он может
[16:42.620 --> 16:44.620]  что-то другое делать.
[16:44.620 --> 16:46.620]  То есть, вот этот логин может быть
[16:46.620 --> 16:48.620]  ко мне
[16:48.620 --> 16:50.620]  каким-то взаимодействием
[16:50.620 --> 16:52.620]  последователенным.
[16:54.620 --> 16:56.620]  Что какие-то там челленджи
[16:56.620 --> 16:58.620]  задают клиенту, он их как-то
[16:58.620 --> 17:00.620]  отличает, но так.
[17:00.620 --> 17:02.620]  Значит, он честный верификатор.
[17:02.620 --> 17:04.620]  Это что сайт нечестный, но
[17:06.620 --> 17:08.620]  ведет себя
[17:08.620 --> 17:10.620]  так же, как настоящий сайт.
[17:10.620 --> 17:12.620]  Тот же самый алгоритм выполняет.
[17:14.620 --> 17:16.620]  А мошеннический сайт,
[17:16.620 --> 17:18.620]  он еще алгоритм может уменять.
[17:24.620 --> 17:26.620]  Ну, что?
[17:26.620 --> 17:28.620]  Понятно, да?
[17:28.620 --> 17:30.620]  То есть, прувер должен понять,
[17:30.620 --> 17:32.620]  что из него все-таки пытаются что-то
[17:32.620 --> 17:34.620]  выключить? Ну, должен, не должен,
[17:34.620 --> 17:36.620]  это так непонятно. Ну, какие-то сообщения
[17:36.620 --> 17:38.620]  приходят, могли бы и настоящий сайт тоже
[17:38.620 --> 17:40.620]  прийти.
[17:40.620 --> 17:42.620]  В том, как
[17:42.620 --> 17:44.620]  эти сообщения
[17:44.620 --> 17:46.620]  получаются.
[17:46.620 --> 17:48.620]  Значит, нуль может быть честно,
[17:48.620 --> 17:50.620]  верификатор.
[17:50.620 --> 17:52.620]  И это вот что,
[17:52.620 --> 17:54.620]  ну,
[17:54.620 --> 17:56.620]  существует
[17:56.620 --> 17:58.620]  алгоритм
[17:58.620 --> 18:00.620]  вероятно
[18:00.620 --> 18:02.620]  вероятно
[18:04.620 --> 18:06.620]  с предназначением
[18:06.620 --> 18:08.620]  м
[18:08.620 --> 18:10.620]  значит, так,
[18:10.620 --> 18:12.620]  что м от х
[18:14.620 --> 18:16.620]  похоже
[18:18.620 --> 18:20.620]  на
[18:20.620 --> 18:22.620]  соответственно,
[18:28.620 --> 18:30.620]  вот. И вот эти три
[18:30.620 --> 18:32.620]  три пыта
[18:32.620 --> 18:34.620]  различаются тем, что означает
[18:34.620 --> 18:36.620]  вот это похоже.
[18:36.620 --> 18:38.620]  Вот это похоже, можно разные способы
[18:38.620 --> 18:40.620]  определять, вот три пыта.
[18:40.620 --> 18:42.620]  Я не очень понимаю, так обобщить,
[18:42.620 --> 18:44.620]  ну, в смысле, как
[18:44.620 --> 18:46.620]  сформулировать понятие честности адекватно.
[18:46.620 --> 18:48.620]  Вот, что здесь ве.
[18:48.620 --> 18:50.620]  То, что здесь ве,
[18:50.620 --> 18:52.620]  это означает честно, что
[18:52.620 --> 18:54.620]  сообщение верификатора
[18:54.620 --> 18:56.620]  вычисляется ровно по тем алгоритмам,
[18:56.620 --> 18:58.620]  как ее предписывают.
[18:58.620 --> 19:00.620]  А прувер знает функцию
[19:00.620 --> 19:02.620]  верификатора?
[19:02.620 --> 19:04.620]  Ну, протокол знает, конечно.
[19:04.620 --> 19:06.620]  То есть, короче, прувер знает,
[19:06.620 --> 19:08.620]  по какому алгоритму действует верификатор.
[19:08.620 --> 19:10.620]  Да, по какому алгоритму должен действовать верификатор.
[19:10.620 --> 19:12.620]  Если верификатор нарушает свой алгоритм,
[19:12.620 --> 19:14.620]  то как бы он не честен становится.
[19:14.620 --> 19:16.620]  Но прувер это может не понять,
[19:16.620 --> 19:18.620]  но он как бы...
[19:18.620 --> 19:20.620]  Да, но он не честен.
[19:20.620 --> 19:22.620]  То есть, типа, не зная секрет,
[19:22.620 --> 19:24.620]  можно проимулировать тот же самый диалог.
[19:24.620 --> 19:26.620]  Вот в этом смысле.
[19:26.620 --> 19:28.620]  Ну, ну, тип того, да.
[19:30.620 --> 19:32.620]  В смысле?
[19:32.620 --> 19:34.620]  Это является семинаром,
[19:34.620 --> 19:36.620]  который я тоже не понял.
[19:36.620 --> 19:38.620]  Ну, сейчас разберемся.
[19:38.620 --> 19:40.620]  Сейчас разберемся.
[19:40.620 --> 19:42.620]  Есть еще, значит, воля сильная
[19:42.620 --> 19:44.620]  для производа верификатора.
[19:48.620 --> 19:50.620]  Для производа машины...
[19:52.620 --> 19:54.620]  Для производа верификатора.
[20:00.620 --> 20:02.620]  То есть, это означает, что
[20:02.620 --> 20:04.620]  в любом воздушном
[20:04.620 --> 20:06.620]  существует время созрения
[20:06.620 --> 20:08.620]  верификатора.
[20:08.620 --> 20:10.620]  Значит, такое, что я взял здесь 5х,
[20:12.620 --> 20:14.620]  похоже
[20:16.620 --> 20:18.620]  на А, вот, С, на В.
[20:20.620 --> 20:22.620]  Здесь тоже самое П, а здесь и на С.
[20:26.620 --> 20:28.620]  То есть, что не только диалог честных верификаторов
[20:28.620 --> 20:30.620]  можно смоделировать,
[20:30.620 --> 20:32.620]  симулировать,
[20:32.620 --> 20:34.620]  но и вообще и много.
[20:34.620 --> 20:36.620]  Конечно, здесь он не совсем любой,
[20:36.620 --> 20:38.620]  да, любые, там, премиады, вероятности,
[20:38.620 --> 20:40.620]  да, ну, и я в задержке что-то нанесу.
[20:42.620 --> 20:44.620]  Сейчас, честность это свойство верификатора?
[20:44.620 --> 20:46.620]  В данном случае, да.
[20:46.620 --> 20:48.620]  Ага, это то, что он не отклоняется
[20:48.620 --> 20:50.620]  от какого-то фиксированного заранее протокола,
[20:50.620 --> 20:52.620]  как в там, какая-то функция, которая там в какой-то язык задает?
[20:52.620 --> 20:54.620]  Ну, да.
[20:58.620 --> 21:00.620]  Сейчас, а возведочка здесь честная,
[21:00.620 --> 21:02.620]  или вот, ну, по-принему?
[21:02.620 --> 21:04.620]  Ну, честная-то вот.
[21:04.620 --> 21:06.620]  А высотодочка любой поединяет.
[21:06.620 --> 21:08.620]  Ну, то есть, у нас, по сути, просто два типа
[21:08.620 --> 21:10.620]  нулевых разношений.
[21:10.620 --> 21:12.620]  Ну, да. Вот, для честных вообще универсальный.
[21:12.620 --> 21:14.620]  Да, то есть, какой-то, значит,
[21:14.620 --> 21:16.620]  какой-то протокол может соответствовать
[21:16.620 --> 21:18.620]  верхнему требованию, но не соответствовать нижнему.
[21:18.620 --> 21:20.620]  Ясно, что наоборот очевиден.
[21:20.620 --> 21:22.620]  Верно даже есть, что
[21:22.620 --> 21:24.620]  для любого высотодочка в том числе
[21:24.620 --> 21:26.620]  высотодочка равномерная.
[21:28.620 --> 21:30.620]  Так, хорошо.
[21:30.620 --> 21:32.620]  Ну, вот, давайте разбираться,
[21:32.620 --> 21:34.620]  что, значит, похоже.
[21:34.620 --> 21:36.620]  Сейчас, а M, это вот
[21:36.620 --> 21:38.620]  в аналоге с этим, это что?
[21:38.620 --> 21:40.620]  Что еще раз? M, ну,
[21:40.620 --> 21:42.620]  вероятно, если M, это
[21:42.620 --> 21:44.620]  ну, MXX, да.
[21:44.620 --> 21:46.620]  Просто, просто какой-то алгоритм.
[21:46.620 --> 21:48.620]  Ну, что
[21:48.620 --> 21:50.620]  все, что
[21:50.620 --> 21:52.620]  увидел верификатор в ходе
[21:52.620 --> 21:54.620]  общения, он мог
[21:54.620 --> 21:56.620]  возгенерировать сам, запустив
[21:56.620 --> 21:58.620]  вот этот симулятор.
[21:58.620 --> 22:00.620]  В смысле, имея секрет
[22:00.620 --> 22:02.620]  или не имея? У него есть
[22:02.620 --> 22:04.620]  вот эта функция
[22:04.620 --> 22:06.620]  прувера, у верификатора
[22:06.620 --> 22:08.620]  в свою очередь есть функция прувера.
[22:08.620 --> 22:10.620]  И он может как бы использовать
[22:10.620 --> 22:12.620]  эту функцию. Нет, конечно,
[22:12.620 --> 22:14.620]  такое может как по программу здесь
[22:14.620 --> 22:16.620]  использоваться, но это не секрет.
[22:16.620 --> 22:18.620]  Да, то есть он как
[22:18.620 --> 22:20.620]  и он может сгенерировать с помощью этой функции,
[22:20.620 --> 22:22.620]  точнее, он может сгенерировать такое
[22:22.620 --> 22:24.620]  взаимодействие, что там выполняется,
[22:24.620 --> 22:26.620]  что корректно действует и функция
[22:26.620 --> 22:28.620]  верификатора и функция прувера каждый раз,
[22:28.620 --> 22:30.620]  как бы, да?
[22:30.620 --> 22:32.620]  Ну, грубо говоря, да.
[22:32.620 --> 22:34.620]  Функция прувера зависит от секрета.
[22:34.620 --> 22:36.620]  Ну, вот он как бы может
[22:36.620 --> 22:38.620]  сгенерировать, видимо, такой диалог,
[22:38.620 --> 22:40.620]  где функция прувера
[22:40.620 --> 22:42.620]  будет давать...
[22:42.620 --> 22:44.620]  Конечно, если он генерировал все
[22:44.620 --> 22:46.620]  сообщения прувера, то свои он тоже может
[22:46.620 --> 22:48.620]  генерировать, потому что
[22:48.620 --> 22:50.620]  автоматически определяется
[22:50.620 --> 22:52.620]  случайный вид и не сообщение прувера.
[22:52.620 --> 22:54.620]  Сейчас, M это просто протокол
[22:54.620 --> 22:56.620]  в нашем факте.
[22:56.620 --> 22:58.620]  M это алгоритм даже.
[22:58.620 --> 23:00.620]  Ну, алгоритм, который эмулирует протоколом,
[23:00.620 --> 23:02.620]  типа для payback.
[23:02.620 --> 23:04.620]  Ну, можно так сказать, да.
[23:04.620 --> 23:06.620]  Но только при данном секрете.
[23:06.620 --> 23:08.620]  Да, F знает секрет, а M не знает секрет.
[23:08.620 --> 23:10.620]  Ну, ему он передается как параметр, разве нет?
[23:10.620 --> 23:12.620]  Нет, только X передается.
[23:12.620 --> 23:14.620]  А X это...
[23:14.620 --> 23:16.620]  Ну, грубо говоря, он знает, конечно, значение,
[23:16.620 --> 23:18.620]  но не знает, от какой строки
[23:18.620 --> 23:20.620]  это, конечно, значение, а кувер знает.
[23:20.620 --> 23:22.620]  А что в нашем случае
[23:22.620 --> 23:24.620]  в нашем случае X это просто
[23:24.620 --> 23:26.620]  что-то, что надо...
[23:26.620 --> 23:28.620]  Сейчас, давайте теперь на графов.
[23:28.620 --> 23:30.620]  X это параграфов, а секрет прувера
[23:30.620 --> 23:32.620]  это изомофизм между ними.
[23:32.620 --> 23:34.620]  И тогда, в случае, что он
[23:34.620 --> 23:36.620]  не знает изомофизма, можно
[23:36.620 --> 23:38.620]  сгенерировать диалог,
[23:38.620 --> 23:40.620]  который будет похож на настоящий, который
[23:40.620 --> 23:42.620]  ввелся с прувером, который знает
[23:42.620 --> 23:44.620]  изомофизм.
[23:44.620 --> 23:46.620]  Ну, просто не до конца понятно,
[23:46.620 --> 23:48.620]  что мы подразумеваем
[23:48.620 --> 23:50.620]  под секретом. Ну, как бы...
[23:50.620 --> 23:52.620]  Не очень понятно, что мы подразумеваем под секретом
[23:52.620 --> 23:54.620]  и что мы здесь, как бы, скрываем, и в какой функции
[23:54.620 --> 23:56.620]  это лежит условно.
[23:56.620 --> 23:58.620]  Сейчас, давайте, смотрите. На самом деле, вот это
[23:58.620 --> 24:00.620]  определение, оно вообще
[24:00.620 --> 24:02.620]  не зависит от того, что мы называем секретом.
[24:04.620 --> 24:06.620]  Да, как бы, в чем бы не замечался
[24:06.620 --> 24:08.620]  секрет,
[24:08.620 --> 24:10.620]  если
[24:10.620 --> 24:12.620]  как бы все, что узнали,
[24:12.620 --> 24:14.620]  общаясь,
[24:14.620 --> 24:16.620]  у которого есть секрет,
[24:16.620 --> 24:18.620]  можно, не зная секретов,
[24:18.620 --> 24:20.620]  не разглашать.
[24:20.620 --> 24:22.620]  Если можно сгенерировать...
[24:22.620 --> 24:24.620]  Что значит сгенерировать?
[24:24.620 --> 24:26.620]  Ну, вот это, видимо, и значит m от x.
[24:28.620 --> 24:30.620]  Вот x и x
[24:30.620 --> 24:32.620]  это общий вход.
[24:32.620 --> 24:34.620]  У прувера может какой-то свой вход, который я
[24:34.620 --> 24:36.620]  называю секретом.
[24:38.620 --> 24:40.620]  Ну, в смысле, не очень понятно, в чем разница
[24:40.620 --> 24:42.620]  между функцией, которые знаете,
[24:42.620 --> 24:44.620]  между той, которой...
[24:44.620 --> 24:46.620]  Мы хотим убедиться, что прувер умеет вычислять некоторую функцию,
[24:46.620 --> 24:48.620]  какую-то неизвестную.
[24:48.620 --> 24:50.620]  Верификатору, наверное, известную,
[24:50.620 --> 24:52.620]  но...
[24:52.620 --> 24:54.620]  Нет, сейчас. Какую функцию?
[24:56.620 --> 24:58.620]  Которую его сообщение вычисляет?
[24:58.620 --> 25:00.620]  Которая уточняет,
[25:00.620 --> 25:02.620]  принадлежит там что-то в языку или не принадлежит.
[25:02.620 --> 25:04.620]  Ну, в смысле.
[25:04.620 --> 25:06.620]  Пароль верный, либо...
[25:06.620 --> 25:08.620]  Сейчас.
[25:10.620 --> 25:12.620]  Не очень понятно, что такое m,
[25:12.620 --> 25:14.620]  вообще, глобально, по идее.
[25:16.620 --> 25:18.620]  Это алгоритм, который создан для того, чтобы
[25:18.620 --> 25:20.620]  уметь вычислять правду,
[25:20.620 --> 25:22.620]  что то, что нам вернул p, это верное значение.
[25:22.620 --> 25:24.620]  Ну, смотрите, пусть это
[25:24.620 --> 25:26.620]  один пароль,
[25:26.620 --> 25:28.620]  x это х-начение от пароля,
[25:28.620 --> 25:30.620]  а b и свой пароль.
[25:32.620 --> 25:34.620]  Вот, значит,
[25:34.620 --> 25:36.620]  смотрите, если...
[25:46.620 --> 25:48.620]  Сейчас.
[25:48.620 --> 25:50.620]  Значит, чтобы назначать, что...
[25:52.620 --> 25:54.620]  Ну, например,
[25:54.620 --> 25:56.620]  что такое там простая атака?
[25:56.620 --> 25:58.620]  Простая атака, это, например, чтобы
[25:58.620 --> 26:00.620]  угнали х-начение
[26:00.620 --> 26:02.620]  и анализируя саму х-начение,
[26:02.620 --> 26:04.620]  смогли как-то залогиваться.
[26:04.620 --> 26:06.620]  Если такая атака успешна,
[26:06.620 --> 26:08.620]  то значит, что х-функция плохая,
[26:08.620 --> 26:10.620]  там в графике ровно m и b.
[26:12.620 --> 26:14.620]  И поэтому, соответственно, ничего не получится.
[26:14.620 --> 26:16.620]  Ну, и что это в терминах наших,
[26:16.620 --> 26:18.620]  ну, в терминах m?
[26:18.620 --> 26:20.620]  Не, подождите, это вообще парольный стиль.
[26:20.620 --> 26:22.620]  Хорошо.
[26:22.620 --> 26:24.620]  То есть идея такая, что
[26:24.620 --> 26:26.620]  если только на базе х-начения
[26:26.620 --> 26:28.620]  можно взломать
[26:28.620 --> 26:30.620]  логин, то это значит,
[26:30.620 --> 26:32.620]  что система плохая, независимо от
[26:32.620 --> 26:34.620]  разглашения, а просто на самом себе плохая,
[26:34.620 --> 26:36.620]  что там секрет на самом деле нет.
[26:38.620 --> 26:40.620]  Вот, теперь, соответственно,
[26:40.620 --> 26:42.620]  пусть у нас
[26:42.620 --> 26:44.620]  теперь мошенник смог
[26:44.620 --> 26:46.620]  пообщаться
[26:46.620 --> 26:48.620]  с клиентом, у которого есть
[26:48.620 --> 26:50.620]  пароль, и
[26:50.620 --> 26:52.620]  после этого смог залогиваться назад.
[26:52.620 --> 26:54.620]  Но тогда
[26:54.620 --> 26:56.620]  он мог бы, значит,
[26:56.620 --> 26:58.620]  пообщавшись с клиентом, он узнал
[26:58.620 --> 27:00.620]  это въем.
[27:00.620 --> 27:02.620]  Вот. Но если есть
[27:02.620 --> 27:04.620]  вот такой вот термин,
[27:04.620 --> 27:06.620]  то вместо того, чтобы делать вообще
[27:06.620 --> 27:08.620]  общаться с клиентом, он мог бы запустить этот термин.
[27:08.620 --> 27:10.620]  И используя ту же самую информацию
[27:10.620 --> 27:12.620]  тоже залогивится сайта.
[27:12.620 --> 27:14.620]  Но это бы и получилось,
[27:14.620 --> 27:16.620]  что зная только х-начения, он смог
[27:16.620 --> 27:18.620]  залогиваться назад.
[27:18.620 --> 27:20.620]  Ну тогда, окей,
[27:20.620 --> 27:22.620]  я, наверное, более меняю. То есть, грубо говоря,
[27:22.620 --> 27:24.620]  тогда, видимо, нулевое разглашение
[27:24.620 --> 27:26.620]  такого, что такого m не осуществует.
[27:26.620 --> 27:28.620]  Нет, наоборот.
[27:28.620 --> 27:30.620]  Наоборот, такое не осуществует.
[27:30.620 --> 27:32.620]  Все, что можно узнать, общаясь
[27:32.620 --> 27:34.620]  с тем, кто знает секрет,
[27:34.620 --> 27:36.620]  можно узнать
[27:36.620 --> 27:38.620]  вообще, можно знать и не зная секрета,
[27:38.620 --> 27:40.620]  а просто зная x.
[27:40.620 --> 27:42.620]  Вот. И если тогда
[27:42.620 --> 27:44.620]  свободу взломать, значит вообще система плохая.
[27:44.620 --> 27:46.620]  Не то, что там разглашение, а то, что она надежная.
[27:46.620 --> 27:48.620]  Так. Да.
[27:48.620 --> 27:50.620]  Я правильно понимаю, что нулевое разглашение
[27:50.620 --> 27:52.620]  это свойство протокола.
[27:52.620 --> 27:54.620]  Ну, например, если у нас в протоколе
[27:54.620 --> 27:56.620]  у функции верификатора есть
[27:56.620 --> 27:58.620]  вопрос сообщения it и bit ответа,
[27:58.620 --> 28:00.620]  то он уже точно
[28:00.620 --> 28:02.620]  не может никогда ставить
[28:02.620 --> 28:04.620]  нулевым разглашением, например.
[28:06.620 --> 28:08.620]  Ну, типа, если, да,
[28:08.620 --> 28:10.620]  да, да, да, то есть даже если один символ
[28:10.620 --> 28:12.620]  пароля разглашается, то это уже не...
[28:12.620 --> 28:14.620]  Да, то есть я про то, что
[28:14.620 --> 28:16.620]  ну, короче, верификатор
[28:16.620 --> 28:18.620]  тоже должен выбирать какую-то функцию
[28:18.620 --> 28:20.620]  специальную, иначе
[28:20.620 --> 28:22.620]  для этой функции для любого прувера
[28:22.620 --> 28:24.620]  может не существовать не нулевого
[28:24.620 --> 28:26.620]  разглашения.
[28:26.620 --> 28:28.620]  Короче, не для любой
[28:28.620 --> 28:30.620]  функции верификатора есть прувер,
[28:30.620 --> 28:32.620]  который делает не нулевое разглашение,
[28:32.620 --> 28:34.620]  а нулевое разглашение.
[28:34.620 --> 28:36.620]  Даже что
[28:36.620 --> 28:38.620]  вы знаете о функции верификатора?
[28:38.620 --> 28:40.620]  Ну, у нас есть алгоритм, по которому
[28:40.620 --> 28:42.620]  действует верификатор.
[28:42.620 --> 28:44.620]  Например, допустим, в этом алгоритме есть
[28:44.620 --> 28:46.620]  вопрос сообщения it и bit ответа.
[28:46.620 --> 28:48.620]  Да.
[28:48.620 --> 28:50.620]  Тогда утвердается, что
[28:50.620 --> 28:52.620]  что бы ни делал прувер, у нас уже точно
[28:52.620 --> 28:54.620]  не будет нулевой разглашением.
[28:54.620 --> 28:56.620]  Не, ну даже типа его не обязано,
[28:56.620 --> 28:58.620]  но это вопрос вообще честно.
[28:58.620 --> 29:00.620]  Не, ну
[29:00.620 --> 29:02.620]  при представстве, что
[29:02.620 --> 29:04.620]  угадать логите, вам говорят, скажите
[29:04.620 --> 29:06.620]  первый символ вашего пароля.
[29:08.620 --> 29:10.620]  Ну слушай, ну это же изначально
[29:10.620 --> 29:12.620]  в протоколе.
[29:12.620 --> 29:14.620]  Ну если еще верификатор говорит,
[29:14.620 --> 29:16.620]  что если ему ответили на этот вопрос
[29:16.620 --> 29:18.620]  неправильно, то он говорит что false,
[29:20.620 --> 29:22.620]  тогда поедень не будет.
[29:22.620 --> 29:24.620]  Что?
[29:24.620 --> 29:26.620]  Сейчас, ну не знаю.
[29:26.620 --> 29:28.620]  Ну ладно.
[29:28.620 --> 29:30.620]  В смысле, это вызывает трудности
[29:30.620 --> 29:32.620]  из-за того, что у нас есть
[29:32.620 --> 29:34.620]  какой-то протокол, и мы
[29:34.620 --> 29:36.620]  по протоколу хотим уметь что-то восстанавливать,
[29:36.620 --> 29:38.620]  грубо говоря.
[29:38.620 --> 29:40.620]  Что восстанавливать?
[29:40.620 --> 29:42.620]  Ну, как раз то, что мы еще не обсудили,
[29:42.620 --> 29:44.620]  mAx похоже на view.
[29:44.620 --> 29:46.620]  Давайте mAx похоже на view,
[29:46.620 --> 29:48.620]  а он похоже на секрет.
[29:48.620 --> 29:50.620]  Ну, да.
[29:50.620 --> 29:52.620]  Бывает нечестный прувер,
[29:52.620 --> 29:54.620]  потому что не хотим.
[29:54.620 --> 29:56.620]  Нет, значит, сейчас
[29:56.620 --> 29:58.620]  смотрите, что это
[29:58.620 --> 30:00.620]  какие-то определения.
[30:00.620 --> 30:02.620]  Что такое?
[30:08.620 --> 30:10.620]  Значит, это план
[30:10.620 --> 30:12.620]  языков,
[30:12.620 --> 30:14.620]  план языков,
[30:14.620 --> 30:16.620]  ады которых
[30:20.620 --> 30:22.620]  существует пара p-r-r,
[30:22.620 --> 30:24.620]  значит, такая, что
[30:28.620 --> 30:30.620]  первое,
[30:30.620 --> 30:32.620]  первое, если x лежит в влаге,
[30:32.620 --> 30:34.620]  то
[30:34.620 --> 30:36.620]  значит, это будет view, а есть еще
[30:36.620 --> 30:38.620]  ответ верификатора.
[30:38.620 --> 30:40.620]  То есть, если x лежит в влаге, то
[30:40.620 --> 30:42.620]  вероятность того, что
[30:42.620 --> 30:44.620]  верификатор, общаясь именно
[30:44.620 --> 30:46.620]  с этим прувером на ходе x,
[30:46.620 --> 30:48.620]  выдаст
[30:48.620 --> 30:50.620]  yes,
[30:50.620 --> 30:52.620]  это будет больше, чем
[30:52.620 --> 30:54.620]  верить.
[30:54.620 --> 30:56.620]  Что, собственно,
[30:56.620 --> 30:58.620]  доказывается, что если лежит в влаге,
[30:58.620 --> 31:00.620]  то прувер так же.
[31:00.620 --> 31:02.620]  Значит, второе,
[31:02.620 --> 31:04.620]  что если не лежит в влаге,
[31:04.620 --> 31:06.620]  то не только этот прувер,
[31:06.620 --> 31:08.620]  а какой-то другой прувер,
[31:08.620 --> 31:10.620]  значит, для любого пациента,
[31:10.620 --> 31:12.620]  вероятность того,
[31:12.620 --> 31:14.620]  что верификатор, честный верификатор,
[31:14.620 --> 31:16.620]  общаясь нечестным прувером
[31:16.620 --> 31:18.620]  на ходе x,
[31:18.620 --> 31:20.620]  выдаст ответ
[31:20.620 --> 31:22.620]  yes, это будет меньше, чем
[31:22.620 --> 31:24.620]  верить.
[31:24.620 --> 31:26.620]  Вот, и третье, собственно,
[31:26.620 --> 31:28.620]  любое разглашение. Давайте я
[31:28.620 --> 31:30.620]  теперь за информатами тебе похоже
[31:30.620 --> 31:32.620]  распишу точно, что это означает
[31:32.620 --> 31:34.620]  этот тип. Но
[31:34.620 --> 31:36.620]  в втором варианте, да, сразу для
[31:36.620 --> 31:38.620]  производства верификатора.
[31:38.620 --> 31:40.620]  Так, значит, это
[31:40.620 --> 31:42.620]  во-первых, только для того, чтобы
[31:42.620 --> 31:44.620]  когда x лежит в ваге, то есть
[31:44.620 --> 31:46.620]  нас отрезует на тебе только честный
[31:46.620 --> 31:48.620]  верификат. Правильно нужно это
[31:48.620 --> 31:50.620]  доказывать, да?
[31:50.620 --> 31:52.620]  Нам не нужно случайно любитую функцию m
[31:52.620 --> 31:54.620]  еще засунуть, как вот?
[31:54.620 --> 31:56.620]  Ну, это же, опять же,
[31:56.620 --> 31:58.620]  так и вначале не есть.
[31:58.620 --> 32:00.620]  В смысле, те же самые имеют следы,
[32:00.620 --> 32:02.620]  которые были на протоколе.
[32:02.620 --> 32:04.620]  Ну, это уж он сам разберет,
[32:04.620 --> 32:06.620]  просто использовать.
[32:06.620 --> 32:08.620]  Да, прувер уже не знает случайно
[32:08.620 --> 32:10.620]  любитый верификат.
[32:10.620 --> 32:12.620]  Так, значит, третья верификатор
[32:12.620 --> 32:14.620]  лежит в ваге.
[32:14.620 --> 32:16.620]  Ну, тогда, значит, смотрите,
[32:16.620 --> 32:18.620]  то, что точно плевишь, значит, я думаю, что
[32:18.620 --> 32:20.620]  в КПФ они похожи.
[32:20.620 --> 32:22.620]  Значит, у любого
[32:22.620 --> 32:24.620]  в это звездочкой
[32:24.620 --> 32:26.620]  существует m со звездочкой,
[32:26.620 --> 32:28.620]  значит,
[32:28.620 --> 32:30.620]  а m со звездочкой,
[32:30.620 --> 32:32.620]  значит, отображает
[32:32.620 --> 32:34.620]  м со звездочкой
[32:34.620 --> 32:36.620]  в
[32:36.620 --> 32:38.620]  м со звездочкой
[32:38.620 --> 32:40.620]  еще вместе с любым машинником.
[32:40.620 --> 32:42.620]  Да, то есть есть
[32:42.620 --> 32:44.620]  возможность
[32:44.620 --> 32:46.620]  выдать ошибку,
[32:46.620 --> 32:48.620]  что там не получилось.
[32:48.620 --> 32:50.620]  Да, не получилось
[32:50.620 --> 32:52.620]  иммунитировать.
[32:52.620 --> 32:54.620]  Вот.
[32:54.620 --> 32:56.620]  Значит, с двумя условиями
[32:56.620 --> 32:58.620]  первое условие
[32:58.620 --> 33:00.620]  вероятность
[33:00.620 --> 33:02.620]  того, что
[33:02.620 --> 33:04.620]  m отыскывал ошибку
[33:04.620 --> 33:06.620]  будет не больше
[33:06.620 --> 33:08.620]  одной в каждой.
[33:08.620 --> 33:10.620]  Да, то есть в звездочке
[33:10.620 --> 33:12.620]  связь с 50% или больше
[33:12.620 --> 33:14.620]  что-то удалось генерируется.
[33:16.620 --> 33:18.620]  Вот.
[33:18.620 --> 33:20.620]  А второе условное
[33:20.620 --> 33:22.620]  распределение
[33:22.620 --> 33:24.620]  условное
[33:24.620 --> 33:26.620]  распределение
[33:26.620 --> 33:28.620]  ой, m со звездочкой.
[33:28.620 --> 33:30.620]  Да.
[33:30.620 --> 33:32.620]  Значит, условное
[33:32.620 --> 33:34.620]  распределение
[33:34.620 --> 33:36.620]  m со звездочкой
[33:36.620 --> 33:38.620]  м со звездочкой от х
[33:38.620 --> 33:40.620]  условно на то, что
[33:40.620 --> 33:42.620]  учились об этом.
[33:44.620 --> 33:46.620]  Значит, вот это условное распределение
[33:46.620 --> 33:48.620]  ровно такое же.
[33:50.620 --> 33:52.620]  Значит, такое же
[33:52.620 --> 33:54.620]  как
[33:56.620 --> 33:58.620]  и распределение
[34:00.620 --> 34:02.620]  m
[34:02.620 --> 34:05.160]  отыск acquaint
[34:16.620 --> 34:18.620]  Можете 1981 разобрать
[34:18.620 --> 34:20.620]  пример, почему, вот, если мы сообщаем
[34:20.620 --> 34:22.620]  первую букву пароля в прыгере, ну,
[34:22.620 --> 34:24.620]  в каком-то протоколе, то
[34:24.620 --> 34:26.620]  эта штука будет
[34:26.620 --> 34:28.620]  не удовлетворять б�� updating.
[34:28.620 --> 34:30.620]  Ну, тогда
[34:32.620 --> 34:44.620]  В этом хилу в том числе будет первая буква породы.
[34:44.620 --> 34:53.620]  Соответственно, вот этот М со звездочкой должен получить хэш значения и из этого хэш значения выудить первую букву породы.
[34:53.620 --> 35:00.620]  Но если хэш функция плохая, то это предположительно сложная задача и, соответственно, грядский алгоритм не решается.
[35:00.620 --> 35:06.620]  В смысле выудить по хэшу первую букву породы? В смысле...
[35:06.620 --> 35:10.620]  Сейчас М должен выудить по хэшу первую букву породы.
[35:10.620 --> 35:13.620]  Ну хэш значения. Да.
[35:13.620 --> 35:24.620]  Нет, это положение, что хэш значения называется надежной, если по хэш значению нельзя конкретный вид агумента рассчитать.
[35:24.620 --> 35:27.620]  Ну да.
[35:27.620 --> 35:36.620]  Соответственно, если эта хэш функция надежная, то тогда этот М со звездочкой не сможет первый вид угадать.
[35:36.620 --> 35:39.620]  А если в протоколе он запрашивается, то в объем он будет.
[35:39.620 --> 35:45.620]  Нам нужно куда-то зашить еще сам секрет.
[35:45.620 --> 35:49.620]  В плане, мы пока можем выдавать произвольную букву вместо первой буквы пароля.
[35:49.620 --> 35:57.620]  И пока нас не проверяют на то, что эта буква совпадает с первой буквой секрета, проблем нет, кажется.
[35:57.620 --> 35:59.620]  Нет, а что значит не проверяют?
[35:59.620 --> 36:01.620]  Вот данный вопрос.
[36:01.620 --> 36:11.620]  Это как-то все зашитывает скорее в определение b, что вот этот хим он должен быть связан с х.
[36:11.620 --> 36:16.620]  То есть в случае, если хэш функция надежная, то эта штука все еще с нулевым разглашением.
[36:16.620 --> 36:18.620]  А если хэш функция надежная при вычислении?
[36:18.620 --> 36:22.620]  Нет, у нас просто М не вычислим.
[36:22.620 --> 36:26.620]  М такой не будет, если хэш функция.
[36:26.620 --> 36:30.620]  Слушайте, давайте может для графов разберемся.
[36:30.620 --> 36:34.620]  А П это у нас вообще что угодно.
[36:34.620 --> 36:36.620]  Вообще говоря, что угодно.
[36:36.620 --> 36:38.620]  Ну и поэтому он знаете.
[36:38.620 --> 36:43.620]  Да, то есть П может быть даже не вычисленным функцией.
[36:43.620 --> 36:53.620]  Но, как правило, П будет наоборот поднимен алгоритмом, который получает дополнительно какой-то секрет, который связан с х.
[36:53.620 --> 37:01.620]  Тут в определении нет никаких химных окончаний.
[37:01.620 --> 37:08.620]  Сейчас, здесь мы подразумеваем, что В это минимальный алгоритм, и со звездочек тоже.
[37:08.620 --> 37:10.620]  Восемьдесят сеточек.
[37:10.620 --> 37:12.620]  Уже любое?
[37:12.620 --> 37:15.620]  А какое со звездочек любое вообще?
[37:15.620 --> 37:17.620]  Ну как бы не ехать в жизнь.
[37:17.620 --> 37:19.620]  Да, да, да.
[37:19.620 --> 37:21.620]  Не со звездочек.
[37:21.620 --> 37:25.620]  Не с каким ресурсом, не надежным способом докидать неверное движение.
[37:25.620 --> 37:27.620]  Так, давайте играть.
[37:27.620 --> 37:29.620]  Майма.
[37:35.620 --> 37:37.620]  Сезонограда.
[37:37.620 --> 37:39.620]  Да.
[37:39.620 --> 37:56.620]  Так, значит, с изомофизмом графом получается что?
[37:56.620 --> 37:58.620]  Что есть два графа.
[37:58.620 --> 38:00.620]  Уже один.
[38:00.620 --> 38:02.620]  Они изомофизмные.
[38:02.620 --> 38:04.620]  И Прувер знает изомофизм.
[38:04.620 --> 38:06.620]  Верификатор не знает.
[38:06.620 --> 38:15.620]  И при этом Прувер должен доказать, что соответственно он знает изомофизм.
[38:15.620 --> 38:18.620]  Что знает изомофизм, или что они изомофизм?
[38:18.620 --> 38:25.620]  Ну, значит, там у нас есть еще подобность, которая называется Zerinov's proof of knowledge.
[38:25.620 --> 38:29.620]  И там как-то они что означают, что он знает изомофизм?
[38:29.620 --> 38:32.620]  Ну, там как раз какие-то ограничения.
[38:32.620 --> 38:37.620]  То есть это фактическая верификаторная аллария, на которой дополнительный вход.
[38:37.620 --> 38:39.620]  Получается, это как-то связано с общим входом.
[38:39.620 --> 38:41.620]  Вот это вот и все.
[38:41.620 --> 38:44.620]  Вот, в этом нам не будет есть.
[38:46.620 --> 38:48.620]  Так, значит, что тут получается?
[38:48.620 --> 38:50.620]  X.
[38:50.620 --> 38:55.620]  Значит, X это пара из Zerinov's proof of knowledge.
[38:55.620 --> 38:59.620]  Значит, это соответственно есть phi.
[39:02.620 --> 39:05.620]  Ну, вот я так напишу.
[39:05.620 --> 39:09.620]  Который же ноль переводит G1 это изомофизм.
[39:12.620 --> 39:18.620]  Вот, значит, соответственно, значит, есть Прувер, есть верификатор.
[39:18.620 --> 39:26.620]  Значит, X получает они оба, а дополнительно Прувер еще phi получает.
[39:27.620 --> 39:29.620]  Вот.
[39:30.620 --> 39:32.620]  Верификатор случайно обитая.
[39:32.620 --> 39:36.620]  Ну, и Прувер тоже в своей случае обитает, получается.
[39:42.620 --> 39:45.620]  Так, хорошо, значит, теперь как?
[39:47.620 --> 39:49.620]  Как это устроено?
[39:49.620 --> 39:54.620]  Значит, Прувер выбирает случайную перестановку.
[39:54.620 --> 39:59.620]  Да, конечно, уже Mg1 одинаково число вершин, значит, это неинтересно.
[39:59.620 --> 40:02.620]  Значит, у них поем вершин.
[40:03.620 --> 40:10.620]  Дальше Прувер выбирает случайную перестановку sigma.
[40:12.620 --> 40:19.620]  И вычисляет аш, который будет в sigma от g1.
[40:20.620 --> 40:23.620]  И эта аша продает верификату.
[40:26.620 --> 40:31.620]  Значит, после этого верификат выбирает случайное b.
[40:33.620 --> 40:43.620]  Да, случайное bx, b и отправляет его в Прувер.
[40:44.620 --> 40:49.620]  Вот, значит, после этого Прувер вычисляет переставку tau,
[40:49.620 --> 40:55.620]  значит, которая будет равна sigma, если b равен x,
[40:55.620 --> 41:00.620]  или sigma в пополице spi, если b равен u.
[41:02.620 --> 41:07.620]  И, соответственно, вот эту tau отравляет верификатор.
[41:07.620 --> 41:11.620]  Значит, после этого верификатор возвращает ответ,
[41:11.620 --> 41:17.620]  значит, если tau от json b равен x,
[41:17.620 --> 41:21.620]  ну и, соответственно, no иначе.
[41:26.620 --> 41:29.620]  Вот так только таково.
[41:31.620 --> 41:33.620]  Так, давайте про 1 и 2 поговорим.
[41:33.620 --> 41:36.620]  1 и 2 легко обсудить.
[41:36.620 --> 41:39.620]  Хотя там есть один тонкий вопрос.
[41:39.620 --> 41:43.620]  Сейчас, слева у вас Прувер, справа верификат.
[41:43.620 --> 41:46.620]  Да, слева у вас Прувер, справа верификат.
[41:46.620 --> 41:48.620]  Случайно перестановку.
[41:49.620 --> 41:51.620]  И у того и другого есть случайное?
[41:51.620 --> 41:54.620]  Сейчас, а мы доказываем не изоморфизм?
[41:54.620 --> 41:56.620]  Изоморфизм доказываем.
[42:00.620 --> 42:04.620]  А, да, да, да, не, я просто подумал, что, ну да, да, да.
[42:07.620 --> 42:12.620]  Да, значит, изоморфизм, чтобы РП было, да, точно,
[42:12.620 --> 42:15.620]  было считать, что Прувер ограничен.
[42:15.620 --> 42:18.620]  Так, хорошо.
[42:18.620 --> 42:22.620]  Значит, первое свойство, что если они изоморфинальные,
[42:22.620 --> 42:25.620]  и на самом деле у другого есть изоморфизм,
[42:25.620 --> 42:27.620]  то ну просто все пройдет, да.
[42:27.620 --> 42:30.620]  А что такое tau?
[42:30.620 --> 42:33.620]  Tau перестановка, которая, как бы,
[42:33.620 --> 42:37.620]  правильного Прувера должна вот так начисляться.
[42:37.620 --> 42:40.620]  А вообще она может быть другой перестановкой.
[42:40.620 --> 42:42.620]  Или даже с его сообщением, да,
[42:42.620 --> 42:44.620]  но нужно как-то любое сообщение
[42:44.620 --> 42:46.620]  поддержать перестановку.
[42:46.620 --> 42:48.620]  И пусть, конечно, не декодируется перестановка,
[42:48.620 --> 42:50.620]  то, значит, сразу нет.
[42:56.620 --> 42:59.620]  Хорошо, значит, пока Прувер, если Прувер честный,
[42:59.620 --> 43:02.620]  то ну просто будет либо sigma g1,
[43:02.620 --> 43:04.620]  который будет равняться h,
[43:04.620 --> 43:06.620]  либо sigma от phi от g0,
[43:06.620 --> 43:08.620]  поскольку phi от g0 это g1,
[43:08.620 --> 43:10.620]  от sigma от g1 это h,
[43:10.620 --> 43:12.620]  то тоже это будет Прувер честный,
[43:12.620 --> 43:14.620]  то это РП точно будет.
[43:17.620 --> 43:21.620]  Так, теперь, если на самом деле они не изоморфинальные...
[43:21.620 --> 43:24.620]  Сейчас это равенство как равенство графов?
[43:24.620 --> 43:26.620]  Равенство графов, да.
[43:26.620 --> 43:28.620]  Равенство графов поэкадексированных, да?
[43:28.620 --> 43:30.620]  Поэкадексированных, окей.
[43:30.620 --> 43:32.620]  Ну что, просто...
[43:32.620 --> 43:34.620]  Ну, если походу там не надо вычислять изоморфизм...
[43:34.620 --> 43:36.620]  Не надо вычислять изоморфизм, да,
[43:36.620 --> 43:38.620]  равенство графов как равенство, понимаешь?
[43:38.620 --> 43:40.620]  Те же самые хорошие насыденные...
[43:43.620 --> 43:47.620]  Ну вот, значит, если на самом деле изоморфизма нету,
[43:47.620 --> 43:50.620]  и нет никакого phi у P со слёдочкой,
[43:50.620 --> 43:53.620]  а просто он пытается обмануть филификатора,
[43:53.620 --> 43:55.620]  то дело в следующем вот.
[43:55.620 --> 43:58.620]  Каким образом не вычислялась вот этаж,
[43:58.620 --> 44:01.620]  то максимум для одного вито
[44:01.620 --> 44:06.620]  будет перестановка, для которого это трудно.
[44:08.620 --> 44:10.620]  Вот, может быть, вообще не для одного,
[44:10.620 --> 44:12.620]  может быть, только для одного.
[44:12.620 --> 44:14.620]  Для этого сразу не может быть тогда не быть поизоморфин.
[44:14.620 --> 44:17.620]  Ну, в связи со слёдочкой доктора или ревинкратор
[44:17.620 --> 44:19.620]  запросит как раз тот граф,
[44:19.620 --> 44:21.620]  у которого перестановки нет.
[44:21.620 --> 44:24.620]  И тогда, чтобы здесь не прислал пуэр,
[44:24.620 --> 44:26.620]  это будет опровергано.
[44:27.620 --> 44:29.620]  Ну, соответственно, получается,
[44:29.620 --> 44:32.620]  что сразу одна-вторая, это будет отвергаться.
[44:32.620 --> 44:34.620]  А тонкий момент, который я анонсировал,
[44:34.620 --> 44:37.620]  это, что здесь у меня одна-треть,
[44:37.620 --> 44:39.620]  да, а получается одна-вторая.
[44:39.620 --> 44:42.620]  Соответственно, нужна где-то партификация,
[44:42.620 --> 44:44.620]  и при этом нужно, чтобы у тебя осталось третье свойство,
[44:44.620 --> 44:46.620]  но вообще ещё не обсуждать.
[44:46.620 --> 44:49.620]  Ну, вот это давайте оставим как тонкий момент.
[44:49.620 --> 44:50.620]  Какое? Третье?
[44:50.620 --> 44:52.620]  Нет, не третье свойство, а то, что
[44:52.620 --> 44:54.620]  на третье можно понизить
[44:54.620 --> 44:56.620]  и не потерять при этом третье свойство.
[44:56.620 --> 44:58.620]  Там есть свои тонкости.
[45:02.620 --> 45:04.620]  Но, на самом деле, сейчас тонкости там такие,
[45:04.620 --> 45:08.620]  что если повторять последовательно,
[45:09.620 --> 45:11.620]  ну, если повторять последовательно,
[45:11.620 --> 45:13.620]  то будет у вас всё то же самое.
[45:13.620 --> 45:15.620]  Обычная партификация, да,
[45:15.620 --> 45:17.620]  что можно повторить два раза подряд.
[45:17.620 --> 45:20.620]  Вот, но это увеличивает шалуранку.
[45:20.620 --> 45:22.620]  Ну, два раза.
[45:22.620 --> 45:24.620]  Вот, если третью два раза,
[45:24.620 --> 45:28.620]  если там одна отдельная власть абонента,
[45:28.620 --> 45:29.620]  вен раз.
[45:29.620 --> 45:31.620]  Ну, это поленок.
[45:31.620 --> 45:33.620]  Вот.
[45:33.620 --> 45:35.620]  А ещё есть теорема,
[45:35.620 --> 45:37.620]  потому что параллельное повторение
[45:37.620 --> 45:40.620]  тоже не улучшает,
[45:42.620 --> 45:44.620]  ну, не нарушает его улучшение.
[45:44.620 --> 45:46.620]  Это сложная теорема.
[45:47.620 --> 45:50.620]  Простая интуиция не работает.
[45:52.620 --> 45:54.620]  И там даже больше, что раз повторять,
[45:54.620 --> 45:57.620]  потому что вы получите то же самое снижение.
[46:00.620 --> 46:02.620]  А статьи на эту тему пишутся формально
[46:02.620 --> 46:04.620]  или не очень?
[46:04.620 --> 46:06.620]  Хорошо.
[46:10.620 --> 46:12.620]  Вот, так, хорошо.
[46:12.620 --> 46:14.620]  Значит, ну теперь давайте от этого
[46:14.620 --> 46:16.620]  облашения.
[46:18.620 --> 46:20.620]  Значит, смотрите, что, собственно,
[46:20.620 --> 46:22.620]  видят линфикаты.
[46:22.620 --> 46:24.620]  Да, значит, цена Х,
[46:24.620 --> 46:26.620]  он видит
[46:26.620 --> 46:28.620]  свои случайные биты,
[46:30.620 --> 46:32.620]  он видит граф, который я ему прислал,
[46:32.620 --> 46:34.620]  и он видит так.
[46:34.620 --> 46:36.620]  Так, давайте, наверное, всё-таки
[46:36.620 --> 46:38.620]  Х не буду дублировать.
[46:38.620 --> 46:40.620]  Да, значит, вот это зимой.
[46:41.620 --> 46:43.620]  Значит, ВС с бёдрышкой,
[46:43.620 --> 46:45.620]  вообще, из куера,
[46:45.620 --> 46:47.620]  на ТХ.
[46:47.620 --> 46:49.620]  А где ещё раз тут фигурирует сам
[46:49.620 --> 46:51.620]  сертификат?
[46:51.620 --> 46:53.620]  Вот ФИ.
[46:53.620 --> 46:55.620]  Ну, не сертификат, а...
[46:55.620 --> 46:57.620]  Нет, это ФИ.
[46:57.620 --> 46:59.620]  Нет, тактику П.
[46:59.620 --> 47:01.620]  Шиф, тактику П.
[47:01.620 --> 47:03.620]  Ну, куер использует ФИ
[47:03.620 --> 47:05.620]  и вычисляет таз.
[47:07.620 --> 47:09.620]  Значит, это будет случайная битая,
[47:09.620 --> 47:11.620]  или битая...
[47:13.620 --> 47:15.620]  А, сейчас, то есть вот там
[47:15.620 --> 47:17.620]  мы выбираем не только М, а на самом деле
[47:17.620 --> 47:19.620]  мы ещё ФИ выбираем какое-то, или нет?
[47:19.620 --> 47:21.620]  В смысле, где мы выбираем?
[47:21.620 --> 47:23.620]  Вот тогда мы говорим, что
[47:23.620 --> 47:25.620]  в милевое разрушение существует М звёздочка,
[47:27.620 --> 47:29.620]  правда ли, что мы там же выбираем ещё
[47:29.620 --> 47:31.620]  какой-то ФИ?
[47:31.620 --> 47:33.620]  Где? Нет.
[47:33.620 --> 47:35.620]  Ну, значит, откуда мы берём ФИ?
[47:35.620 --> 47:37.620]  Подождите, ФИ я откуда не берём?
[47:37.620 --> 47:39.620]  Тут вовремя нет ФИ.
[47:39.620 --> 47:41.620]  Нужно ТАУ.
[47:43.620 --> 47:45.620]  А, ну для П нужно.
[47:47.620 --> 47:49.620]  А, П тут вообще нету.
[47:49.620 --> 47:51.620]  В смысле, ФИ у нас вшитов в ТАУ всё.
[47:53.620 --> 47:55.620]  Мы его используем.
[47:55.620 --> 47:57.620]  Но это оно в честном приколе вшитов в ТАУ.
[47:57.620 --> 47:59.620]  А в нечестном его вообще нету.
[47:59.620 --> 48:01.620]  Так, хорошо.
[48:17.620 --> 48:19.620]  Значит, смотрите, во-первых, давайте
[48:19.620 --> 48:21.620]  для честного индификатора
[48:29.620 --> 48:31.620]  Дальше для честного индификатора.
[48:35.620 --> 48:37.620]  Значит, честный индификатор
[48:37.620 --> 48:39.620]  делает следующее.
[48:43.620 --> 48:45.620]  Значит, он
[48:45.620 --> 48:47.620]  да, то есть
[48:47.620 --> 48:49.620]  что делает МНХ?
[48:51.620 --> 48:53.620]  Значит, он выбирает
[48:53.620 --> 48:55.620]  один из двух графов случайно.
[48:55.620 --> 48:57.620]  Значит, играет
[48:59.620 --> 49:01.620]  случайно
[49:01.620 --> 49:03.620]  гид С.
[49:05.620 --> 49:07.620]  Значит, который
[49:07.620 --> 49:09.620]  0,1.
[49:11.620 --> 49:13.620]  И, так,
[49:13.620 --> 49:15.620]  вот, давайте я
[49:15.620 --> 49:17.620]  там Ц,
[49:17.620 --> 49:19.620]  то есть либо ТАУ, либо ТАУ-1,
[49:19.620 --> 49:21.620]  который зафиксирует приставку.
[49:21.620 --> 49:23.620]  Зафиксирует приставку.
[49:25.620 --> 49:27.620]  Вот.
[49:27.620 --> 49:29.620]  Соответственно, вычисляет
[49:29.620 --> 49:31.620]  ПАШ.
[49:33.620 --> 49:35.620]  ПАШ, который будет
[49:37.620 --> 49:39.620]  значит, Ц,
[49:39.620 --> 49:41.620]  Ж, Ц.
[49:45.620 --> 49:47.620]  Вот.
[49:47.620 --> 49:49.620]  Значит, вверх он и так
[49:49.620 --> 49:51.620]  случайно выбирает.
[49:53.620 --> 49:55.620]  Значит,
[49:55.620 --> 49:57.620]  например, случайно намерно.
[49:59.620 --> 50:01.620]  Вот.
[50:01.620 --> 50:03.620]  Значит, ну и дальше
[50:05.620 --> 50:07.620]  значит, дальше теперь В берется,
[50:07.620 --> 50:09.620]  ну, может быть, чтобы просто один из этих битов.
[50:09.620 --> 50:11.620]  Вот. И если оказалось, что
[50:11.620 --> 50:13.620]  В равно Ц,
[50:13.620 --> 50:15.620]  значит, если В равно Ц,
[50:15.620 --> 50:17.620]  то он возвращает
[50:19.620 --> 50:21.620]  коберостройку
[50:21.620 --> 50:23.620]  из В, А,
[50:23.620 --> 50:25.620]  и ТАУ.
[50:27.620 --> 50:29.620]  Вот. А если бы
[50:29.620 --> 50:31.620]  не ровно Ц,
[50:31.620 --> 50:33.620]  то больше не получилось.
[50:33.620 --> 50:35.620]  Знаете, не получилась симуляция
[50:35.620 --> 50:37.620]  и возвращает
[50:39.620 --> 50:41.620]  АШ.
[50:49.620 --> 50:51.620]  А, ну с Б остается ПАШ,
[50:51.620 --> 50:53.620]  поэтому мы его не можем заранее угадать, да?
[50:53.620 --> 50:55.620]  Ну, да.
[50:57.620 --> 50:59.620]  Нет, ну в данном случае
[51:05.620 --> 51:07.620]  А, для честного, может быть,
[51:07.620 --> 51:09.620]  может даже вообще 100%, но
[51:09.620 --> 51:11.620]  да, если верификатор честный,
[51:13.620 --> 51:15.620]  то можно прямо взять
[51:15.620 --> 51:17.620]  В из Р, и именно для этого
[51:17.620 --> 51:19.620]  так даже ключ получается.
[51:19.620 --> 51:21.620]  Не получится просто Р
[51:23.620 --> 51:25.620]  Мы Аш генерируем по
[51:25.620 --> 51:27.620]  Б, что ли.
[51:27.620 --> 51:29.620]  В смысле, мы
[51:29.620 --> 51:31.620]  в АПЦ, если его заменить на Б,
[51:31.620 --> 51:33.620]  то мы поэтому Б сгенерируем АШ,
[51:33.620 --> 51:35.620]  а потом нам нужно как бы по вот этому
[51:35.620 --> 51:37.620]  АШ сгенерируем. И это уже
[51:37.620 --> 51:39.620]  для нечестного верификатора.
[51:39.620 --> 51:41.620]  Ну, вон там у нас
[51:41.620 --> 51:43.620]  А, в смысле у нас, а, в нашем верификаторе
[51:43.620 --> 51:45.620]  у нас Б не зависит от АШ, да?
[51:45.620 --> 51:47.620]  У честного да.
[51:47.620 --> 51:49.620]  А у нечестного может зависеть.
[51:51.620 --> 51:53.620]  Да, то есть вот
[51:53.620 --> 51:55.620]  значит тем со звездочкой
[51:55.620 --> 51:57.620]  АПЦ, да,
[51:57.620 --> 51:59.620]  что получается анонично,
[51:59.620 --> 52:01.620]  вот.
[52:01.620 --> 52:03.620]  Но теперь Б
[52:03.620 --> 52:05.620]  да,
[52:05.620 --> 52:07.620]  анонично, но
[52:07.620 --> 52:09.620]  Б это будет как бы
[52:09.620 --> 52:11.620]  В со звездочкой, вот и
[52:11.620 --> 52:13.620]  АПЦ.
[52:15.620 --> 52:17.620]  Да, то есть Б
[52:17.620 --> 52:19.620]  не случайно зависит, а
[52:19.620 --> 52:21.620]  АПЦ зависит.
[52:21.620 --> 52:23.620]  Вот.
[52:25.620 --> 52:27.620]  Ну, а дальше точно так же.
[52:31.620 --> 52:33.620]  Дальше аналогично.
[52:33.620 --> 52:35.620]  Ну,
[52:35.620 --> 52:37.620]  значит, смотрите, теперь тут что нужно
[52:37.620 --> 52:39.620]  доказывать?
[52:39.620 --> 52:41.620]  Ну, нужно доказывать, что тут
[52:41.620 --> 52:43.620]  В со звездочке
[52:43.620 --> 52:45.620]  ничего не сможет
[52:45.620 --> 52:47.620]  сделать.
[52:47.620 --> 52:49.620]  Ну и тут мы опять углубляемся
[52:49.620 --> 52:51.620]  в действии
[52:51.620 --> 52:53.620]  группы на множестве.
[52:55.620 --> 52:57.620]  Да, то есть тут
[52:57.620 --> 52:59.620]  значит история такая,
[52:59.620 --> 53:01.620]  что поскольку вообще действуют
[53:01.620 --> 53:03.620]  в положении, что они заморфаны,
[53:03.620 --> 53:05.620]  да, то значит
[53:05.620 --> 53:07.620]  группа
[53:07.620 --> 53:09.620]  не группа, в смысле
[53:09.620 --> 53:11.620]  семейство телеграфка, которая заморфана, же ноль,
[53:11.620 --> 53:13.620]  и семейство телеграфка, которая заморфана, же один,
[53:13.620 --> 53:15.620]  это одно и то же семейство.
[53:15.620 --> 53:17.620]  И, соответственно, если мы берем
[53:17.620 --> 53:19.620]  вот,
[53:19.620 --> 53:21.620]  здесь, значит, если мы берем
[53:21.620 --> 53:23.620]  С равным внуку, то аж распространено равномерно
[53:23.620 --> 53:25.620]  среди этого семейства. Если берем С
[53:25.620 --> 53:27.620]  равномерно ниже, то аж распространено
[53:27.620 --> 53:29.620]  равномерно для этого семейства.
[53:31.620 --> 53:33.620]  Вот, а после
[53:33.620 --> 53:35.620]  этого,
[53:35.620 --> 53:37.620]  то есть условно на то, что аж
[53:37.620 --> 53:39.620]  получился таким,
[53:39.620 --> 53:41.620]  что С равномерно более 1,
[53:41.620 --> 53:43.620]  а В
[53:43.620 --> 53:45.620]  получается каким-то конкретным
[53:45.620 --> 53:47.620]  для этого аж.
[53:47.620 --> 53:49.620]  Ну, то есть когда случается, если
[53:49.620 --> 53:51.620]  С равномерно на 2 и В совпадется,
[53:51.620 --> 53:53.620]  то С равномерно на 3 и В совпадется.
[53:55.620 --> 53:57.620]  А В как раз получается на 2
[53:57.620 --> 53:59.620]  или получается на 2?
[53:59.620 --> 54:01.620]  Понял вопрос.
[54:01.620 --> 54:03.620]  Как-то странно получается, что
[54:03.620 --> 54:05.620]  если мы там 1-2, у нас 2-3 заменим,
[54:05.620 --> 54:07.620]  у нас как будто нет,
[54:07.620 --> 54:09.620]  то это критически меняется.
[54:09.620 --> 54:11.620]  Сейчас, какое это такое?
[54:11.620 --> 54:13.620]  Вот вероятность того, что
[54:13.620 --> 54:15.620]  мы все-таки нашли,
[54:15.620 --> 54:17.620]  что симуляция получилась,
[54:17.620 --> 54:19.620]  ну, не на 1-3, а на 2-3 заменим,
[54:19.620 --> 54:21.620]  например.
[54:21.620 --> 54:23.620]  А, нет, симу...
[54:23.620 --> 54:25.620]  А, вот сейчас, вот это
[54:25.620 --> 54:27.620]  вот вторая. Да, вот ее,
[54:27.620 --> 54:29.620]  если мы на 2-3 заменим, то вот это
[54:29.620 --> 54:31.620]  алгоритм уже не работает? Да нет,
[54:31.620 --> 54:33.620]  тут как раз простая партификация. Или а,
[54:33.620 --> 54:35.620]  а она подкручивается, да? Да,
[54:35.620 --> 54:37.620]  то есть если можно просто
[54:37.620 --> 54:39.620]  то же самое воспустить в новый раз
[54:39.620 --> 54:41.620]  и взять первую успешную,
[54:41.620 --> 54:43.620]  первую успешную генерацию,
[54:43.620 --> 54:45.620]  как раз эта 1-2 в Prabhupati
[54:45.620 --> 54:47.620]  очень легко
[54:47.620 --> 54:49.620]  делается.
[54:49.620 --> 54:51.620]  Нужно спустить в новый раз, взять
[54:51.620 --> 54:53.620]  первую успешную
[54:53.620 --> 54:55.620]  симуляцию.
[54:55.620 --> 54:57.620]  Тогда бы то же самое
[54:57.620 --> 54:59.620]  распределение.
[54:59.620 --> 55:01.620]  Потому что надо сказать, что такой второй распределение,
[55:01.620 --> 55:03.620]  потом еще на 1-4, точно такое же распределение.
[55:03.620 --> 55:07.620]  Да, в смысле, когда бэннер на C, мы не обязаны что-то сразу возвращать.
[55:07.620 --> 55:12.620]  Да, да, да. Когда бэннер на C, мы можем еще раз все то же самое запустить.
[55:12.620 --> 55:20.620]  Видимо, интуитивный смысл M такой, что это какой-то обманщик, который позволяет обмануть мошенника в том плане, чтобы предъявить такое же...
[55:20.620 --> 55:23.620]  Ну, в смысле, грубо говоря, если у нас есть какой-то верификат, который ведет себя по-другому,
[55:23.620 --> 55:41.620]  мы для него умеем предъявлять некоторый прудер, условно, который, на самом деле, сгенерирует те же самые данные по слитичным свойствам, что и что он увидит для какого-нибудь адекватного хода.
[55:41.620 --> 55:48.620]  Ну, более-менее, да, но только отличие в том, что, в отличие от круглого, этот симулятор, наверное, обращает ошибку.
[55:48.620 --> 55:55.620]  Ну, да. Если бы он никогда не возвращался, он сам бы пройти.
[56:08.620 --> 56:09.620]  Так, вуа.
[56:19.620 --> 56:26.620]  Значит, смотрите, если вообще отказаться по родной ошибке, то, вроде, нет никаких примеров, только такой.
[56:26.620 --> 56:28.620]  Сейчас, а можно пока третий доску не стирать?
[56:28.620 --> 56:29.620]  Да.
[56:29.620 --> 56:30.620]  А четвертый?
[56:30.620 --> 56:31.620]  Можно.
[56:31.620 --> 56:35.620]  Как шахмак.
[56:35.620 --> 56:38.620]  Ну, четвертый пример, а на третий академик.
[56:45.620 --> 56:46.620]  Я пишу.
[56:48.620 --> 57:04.620]  Так, значит, дальше, уже мало времени остается, да, значит, дальше вот остаются другие два варианта, S и ZK, и CZK.
[57:04.620 --> 57:09.620]  Значит, дальше, сначала вот к S разберемся.
[57:09.620 --> 57:19.620]  Так, значит, есть такое понятие, техническое расстояние.
[57:19.620 --> 57:21.620]  В неркотичайном смысле.
[57:21.620 --> 57:35.620]  Так, оно является так.
[57:35.620 --> 57:39.620]  Расстояние между RL и DL.
[57:39.620 --> 57:44.620]  Значит, на самом деле это не случайно величины, а то, что называется вариантовые ансамбли.
[57:44.620 --> 57:51.620]  То есть набор случайных величин, парадоксированные разными названиями числами.
[57:51.620 --> 57:58.620]  Да, вообще английский язык известен тем, что там группы животных называются разными странными словами.
[57:58.620 --> 58:01.620]  Да, эти всякие вот там, там, бунт, стадо, и так далее.
[58:01.620 --> 58:03.620]  Там для каждого вида есть какие-то странные слова, которые...
[58:03.620 --> 58:04.620]  Ну, у нас тоже.
[58:04.620 --> 58:06.620]  Это бунт, стадо, стая.
[58:06.620 --> 58:09.620]  Не, ну стадо, стая, это все-таки у них нет своего значения.
[58:09.620 --> 58:14.620]  А там что-то парладно там кого-то.
[58:14.620 --> 58:19.620]  Ансамбль-кандидат.
[58:19.620 --> 58:21.620]  Вот, и вот это немножко перешло.
[58:21.620 --> 58:25.620]  То есть вот здесь называется ансамбль, а еще бывает там батарея тестов.
[58:25.620 --> 58:29.620]  Ну, вот так вот.
[58:29.620 --> 58:31.620]  На борт этот ученый называется батареей.
[58:31.620 --> 58:35.620]  Альгалатская вторая разница.
[58:35.620 --> 58:36.620]  Вот.
[58:36.620 --> 58:45.620]  Там хотя бы в средние века просто кто-то пошутил, и как-то это помялося.
[58:45.620 --> 58:49.620]  Вот, хорошо.
[58:49.620 --> 58:51.620]  Стадо стояния.
[58:51.620 --> 58:58.620]  Вот есть там, есть ансамбль случайных величин.
[58:58.620 --> 59:03.620]  Значит, это вот что такое.
[59:03.620 --> 59:05.620]  Значит, это случайные величины.
[59:05.620 --> 59:09.620]  То есть тут именинское то, что все слова длины N получают какую-то вероятность,
[59:09.620 --> 59:13.620]  так что они всю выдают единицу, и каждую не отрезают.
[59:13.620 --> 59:17.620]  То есть это фактически стахотический яд в длину 2 степени N.
[59:17.620 --> 59:22.620]  Но дальше у каждого отдельного элемента, то есть событий, есть вероятность.
[59:22.620 --> 59:26.620]  И у каждого событий, то есть множество тоже есть вероятность.
[59:26.620 --> 59:32.620]  Соответственно, вот это расстояние, это максимум по всем событиям,
[59:32.620 --> 59:38.620]  модуля радности, вероятность того, что N попало в N,
[59:38.620 --> 59:44.620]  и вероятность того, что B N попало в С.
[59:44.620 --> 59:57.620]  То есть это как бы максимальное различие между тем, как эти распределения оценивают вероятность этого события.
[59:57.620 --> 01:00:04.620]  Теория, что это, на самом деле, одна-вторая, вот там вот стояние.
[01:00:04.620 --> 01:00:08.620]  То есть это одна-вторая, сумма просто пошла так сам.
[01:00:08.620 --> 01:00:15.620]  А тут будет модуль радости, вероятность того, что N попало в N,
[01:00:15.620 --> 01:00:25.620]  и минус вероятность того, что B N попало в N.
[01:00:25.620 --> 01:00:30.620]  Так, ну это я, наверное, заходю как задачу, чтобы это попало в N.
[01:00:30.620 --> 01:00:33.620]  По всем самодлижающим S?
[01:00:33.620 --> 01:00:41.620]  Нет, значит, это FN или BN, N, C, Z.
[01:00:41.620 --> 01:00:44.620]  А ИГО?
[01:00:44.620 --> 01:00:47.620]  Сумма по всем самодлижающим S или нет?
[01:00:47.620 --> 01:00:49.620]  Нет, ну даже нет.
[01:00:49.620 --> 01:00:51.620]  Это связано примерно.
[01:00:51.620 --> 01:00:53.620]  Ну хорошо.
[01:00:53.620 --> 01:00:55.620]  А ИГО?
[01:00:55.620 --> 01:00:57.620]  А X?
[01:00:57.620 --> 01:00:59.620]  Это ИГО.
[01:01:04.620 --> 01:01:06.620]  А, что?
[01:01:06.620 --> 01:01:08.620]  Да ладно.
[01:01:08.620 --> 01:01:11.620]  BN это событие, а X это элементарное событие в теории вероятности.
[01:01:11.620 --> 01:01:15.620]  Так, ладно, это я не даю сейчас прокусить, почему это равняется.
[01:01:15.620 --> 01:01:18.620]  Да, это вообще не по сложности задачи, да.
[01:01:18.620 --> 01:01:21.620]  Кому-то какой-то объясню еще сегодня.
[01:01:21.620 --> 01:01:23.620]  Или теорируем.
[01:01:23.620 --> 01:01:26.620]  Так, хорошо.
[01:01:26.620 --> 01:01:30.620]  Знать не дается на пределение.
[01:01:30.620 --> 01:01:36.620]  Это FN и BN статистически другие.
[01:01:39.620 --> 01:01:43.620]  А вот это уже поделительная сложность.
[01:01:43.620 --> 01:01:45.620]  Синтетическое определение.
[01:01:45.620 --> 01:01:52.620]  Значит, если для любого пленного существует какой-то индекс,
[01:01:52.620 --> 01:01:57.620]  что для любого созданного индекса,
[01:01:57.620 --> 01:02:03.620]  значит, вот это расстояние от AFN до BFN
[01:02:03.620 --> 01:02:07.620]  будет меньше всего выхода в плену.
[01:02:09.620 --> 01:02:13.620]  Вот, здесь уже получается важно, что это не одна лично,
[01:02:13.620 --> 01:02:16.620]  не одна пара личных, а два отца плен.
[01:02:16.620 --> 01:02:19.620]  И, соответственно, для любого пленника стремиться к нулю
[01:02:19.620 --> 01:02:22.620]  быстрее любого обратно в плену.
[01:02:23.620 --> 01:02:25.620]  Так.
[01:02:25.620 --> 01:02:27.620]  Понятно?
[01:02:27.620 --> 01:02:29.620]  Понятно.
[01:02:29.620 --> 01:02:33.620]  То есть они как бы не одинаковые.
[01:02:33.620 --> 01:02:36.620]  Чем больше, тем они ближе друг другу.
[01:02:36.620 --> 01:02:38.620]  Вот.
[01:02:38.620 --> 01:02:41.620]  Ну и тогда, соответственно, SZK,
[01:02:41.620 --> 01:02:44.620]  вот это вот третье свойство
[01:02:44.620 --> 01:02:46.620]  заменяется на то,
[01:02:46.620 --> 01:02:48.620]  что просто МСЗО очень рядных,
[01:02:48.620 --> 01:02:50.620]  статистически без кок, вот это вот.
[01:02:51.620 --> 01:02:53.620]  И мы запрещаем неправильный ответ,
[01:02:53.620 --> 01:02:55.620]  что они симулируют плен.
[01:02:55.620 --> 01:02:57.620]  Да, то есть мы запрещаем ответ,
[01:02:57.620 --> 01:03:00.620]  что не получилось, но разрешаем неправильный ответ
[01:03:00.620 --> 01:03:02.620]  с большой вероятностью.
[01:03:03.620 --> 01:03:07.620]  Значит, SZK, начиная с любого отца плен,
[01:03:07.620 --> 01:03:09.620]  существует так собранный плен.
[01:03:09.620 --> 01:03:12.620]  Такой, что им создаст реакцию.
[01:03:12.620 --> 01:03:14.620]  SZK,
[01:03:14.620 --> 01:03:16.620]  и
[01:03:18.620 --> 01:03:20.620]  с большой вероятностью P,
[01:03:20.620 --> 01:03:22.620]  SZK,
[01:03:22.620 --> 01:03:24.620]  статистически близко.
[01:03:29.620 --> 01:03:32.620]  А тут вместо M, код X, а это?
[01:03:32.620 --> 01:03:34.620]  Вместо M, надинается.
[01:03:36.620 --> 01:03:37.620]  Вот.
[01:03:37.620 --> 01:03:39.620]  Нет, конечно, тут в правильном порядке СЕКВАТ
[01:03:39.620 --> 01:03:41.620]  предоставить только в отдельную задачу.
[01:03:42.620 --> 01:03:43.620]  Э-э-э...
[01:03:51.620 --> 01:03:52.620]  Э-э-э...
[01:03:52.620 --> 01:03:54.620]  Ну, чатки.
[01:03:54.620 --> 01:03:56.620]  Годикатера на меня, да, значит.
[01:03:57.620 --> 01:04:00.620]  Вот этот B-созвездочек работает с сексами убойтленные,
[01:04:00.620 --> 01:04:02.620]  M-созвездочек работает с сексами убойтленные.
[01:04:03.620 --> 01:04:05.620]  И соответственно для всех,
[01:04:07.620 --> 01:04:11.620]  значит, для всех лицов получаются две вот обзорвенеченные.
[01:04:12.620 --> 01:04:13.620]  И это должно быть так.
[01:04:13.620 --> 01:04:16.620]  А, ну тут как бы добавлять еще один квантор, да,
[01:04:16.620 --> 01:04:17.620]  для любого лица,
[01:04:17.620 --> 01:04:19.620]  у которого глина M,
[01:04:19.620 --> 01:04:21.620]  да, для любого лица, у которого глина M,
[01:04:21.620 --> 01:04:23.620]  будет вот это расстояние меньше,
[01:04:23.620 --> 01:04:25.620]  чем этот обладный квантор.
[01:04:30.620 --> 01:04:31.620]  Вот.
[01:04:34.620 --> 01:04:36.620]  Значит, утверждение,
[01:04:36.620 --> 01:04:39.620]  что PZK можно в SZK
[01:04:42.620 --> 01:04:43.620]  Почему?
[01:04:43.620 --> 01:04:45.620]  Ну, потому что как раз
[01:04:45.620 --> 01:04:47.620]  можно N раз повторить вот это вот,
[01:04:47.620 --> 01:04:49.620]  взять первое попавшееся,
[01:04:49.620 --> 01:04:50.620]  не первое попавшееся,
[01:04:50.620 --> 01:04:51.620]  первое сработавшееся.
[01:04:51.620 --> 01:04:53.620]  Соответственно будет специально управлять,
[01:04:53.620 --> 01:04:55.620]  что N раз у нас работает.
[01:04:55.620 --> 01:04:57.620]  Но в этом случае мы вернемся только по умолчанию.
[01:04:57.620 --> 01:04:59.620]  И это как раз, да,
[01:04:59.620 --> 01:05:01.620]  статустоимие нуля в одной из моментов.
[01:05:06.620 --> 01:05:07.620]  Понятная идея?
[01:05:07.620 --> 01:05:08.620]  Да.
[01:05:08.620 --> 01:05:09.620]  Еще раз.
[01:05:09.620 --> 01:05:10.620]  Значит еще раз.
[01:05:10.620 --> 01:05:11.620]  Вот смотрите, сначала
[01:05:11.620 --> 01:05:12.620]  распускай в первый раз,
[01:05:12.620 --> 01:05:14.620]  у нас половина распространства
[01:05:14.620 --> 01:05:15.620]  про Houston распределения
[01:05:15.620 --> 01:05:16.620]  на половине ничего.
[01:05:16.620 --> 01:05:18.620]  А то он опускаем еще раз.
[01:05:18.620 --> 01:05:19.620]  Первый раз еще на половине оттавшегося,
[01:05:19.620 --> 01:05:20.620]  тоже про Houston распределение,
[01:05:20.620 --> 01:05:21.620]  а на половине ничего.
[01:05:21.620 --> 01:05:23.620]  Так делаем N раз,
[01:05:23.620 --> 01:05:29.620]  и оттас Diaz специально маленький
[01:05:29.620 --> 01:05:30.620]  оттас в 비 Effects пространство,
[01:05:30.620 --> 01:05:31.620]  где ничего
[01:05:31.620 --> 01:05:32.620]  и все остальное,
[01:05:32.620 --> 01:05:33.620]  где про Houston распределение.
[01:05:33.620 --> 01:05:34.620]  И теперь мы вместо ничего
[01:05:34.620 --> 01:05:36.620]  возвращаем что попало,
[01:05:36.620 --> 01:05:44.620]  Возвращаем, что попало, и это чуть-чуть сдвигает распределение, так что расстояние как раз этими специальными моментами получается.
[01:05:44.620 --> 01:05:46.620]  Хорошо, помахаем.
[01:05:46.620 --> 01:05:54.620]  Вот. Так, хорошо.
[01:05:54.620 --> 01:05:58.620]  Так, что, первый или третий?
[01:05:58.620 --> 01:06:00.620]  Первый, да?
[01:06:00.620 --> 01:06:02.620]  Первый, да?
[01:06:02.620 --> 01:06:04.620]  Хорошо.
[01:06:04.620 --> 01:06:06.620]  Вот.
[01:06:06.620 --> 01:06:08.620]  Вот.
[01:06:08.620 --> 01:06:10.620]  Вот.
[01:06:10.620 --> 01:06:12.620]  Вот.
[01:06:12.620 --> 01:06:14.620]  Вот.
[01:06:14.620 --> 01:06:16.620]  Вот.
[01:06:16.620 --> 01:06:18.620]  Вот.
[01:06:18.620 --> 01:06:20.620]  Вот.
[01:06:20.620 --> 01:06:22.620]  Вот.
[01:06:44.620 --> 01:06:46.620]  Значит, дальше есть понятие,
[01:06:46.620 --> 01:06:48.620]  кроме статистической близости,
[01:06:48.620 --> 01:06:50.620]  еще есть
[01:06:50.620 --> 01:06:52.620]  вещественные отличия,
[01:06:52.620 --> 01:06:54.620]  тоже Депрегнан Канханович.
[01:06:58.620 --> 01:07:00.620]  Просто вещественные отличия.
[01:07:00.620 --> 01:07:02.620]  Вот. На самом деле, значит, смотрите,
[01:07:02.620 --> 01:07:04.620]  вот это вот,
[01:07:04.620 --> 01:07:06.620]  вот это вот свойство,
[01:07:06.620 --> 01:07:08.620]  значит, события,
[01:07:08.620 --> 01:07:10.620]  можно переформировать по-другому.
[01:07:12.620 --> 01:07:14.620]  Значит, переформировка
[01:07:14.620 --> 01:07:16.620]  переформировка
[01:07:20.620 --> 01:07:22.620]  переформировка
[01:07:24.620 --> 01:07:26.620]  статистической близости.
[01:07:28.620 --> 01:07:30.620]  Значит,
[01:07:30.620 --> 01:07:32.620]  для любой функции,
[01:07:32.620 --> 01:07:34.620]  ну, значит, для любого семейства функций,
[01:07:36.620 --> 01:07:38.620]  значит, ТМ,
[01:07:38.620 --> 01:07:40.620]  значит, ТМ подражает
[01:07:40.620 --> 01:07:42.620]  0.1 степени,
[01:07:42.620 --> 01:07:44.620]  0.1, 0.1.
[01:07:46.620 --> 01:07:48.620]  Значит, дальше получается
[01:07:48.620 --> 01:07:50.620]  и так же для любого
[01:07:50.620 --> 01:07:52.620]  атоминома, существует
[01:07:52.620 --> 01:07:54.620]  генбольской, для любого генбольского
[01:07:54.620 --> 01:07:56.620]  атоминома,
[01:07:56.620 --> 01:07:58.620]  значит, ну, разности, вероятность
[01:07:58.620 --> 01:08:00.620]  того, что
[01:08:00.620 --> 01:08:02.620]  ТН, а вот АТ,
[01:08:02.620 --> 01:08:04.620]  1,
[01:08:04.620 --> 01:08:06.620]  минус, вероятность того,
[01:08:06.620 --> 01:08:08.620]  что ТН, АТ,
[01:08:08.620 --> 01:08:10.620]  1,
[01:08:10.620 --> 01:08:12.620]  это будет меньше, чем 1,5.
[01:08:14.620 --> 01:08:16.620]  И это, в отличие, тоже самое,
[01:08:16.620 --> 01:08:18.620]  но я как бы перешел от
[01:08:18.620 --> 01:08:20.620]  множества его характерических функций.
[01:08:20.620 --> 01:08:22.620]  То есть, вот этот
[01:08:22.620 --> 01:08:24.620]  ТН, это будет
[01:08:24.620 --> 01:08:26.620]  характерическая функция, да, УС,
[01:08:26.620 --> 01:08:28.620]  которая это, вот, АТ,
[01:08:28.620 --> 01:08:30.620]  от слова тест, как раз, как раз у батареи тестов.
[01:08:30.620 --> 01:08:32.620]  Да, вот тут
[01:08:32.620 --> 01:08:34.620]  мы берем в качестве батареи, мы берем все тесты
[01:08:34.620 --> 01:08:36.620]  вообще, все, все
[01:08:36.620 --> 01:08:38.620]  продикаты.
[01:08:38.620 --> 01:08:40.620]  Вот, значит
[01:08:40.620 --> 01:08:42.620]  на этом может оказаться так,
[01:08:42.620 --> 01:08:44.620]  что этот тест, он пытается сказать,
[01:08:44.620 --> 01:08:46.620]  вы дали ему Альфа,
[01:08:46.620 --> 01:08:48.620]  ли дали ему Бету.
[01:08:48.620 --> 01:08:50.620]  Да, и, например, то, что он сказал, Енису,
[01:08:50.620 --> 01:08:52.620]  то что он шл Ladadie, мы интерпретируем как то,
[01:08:52.620 --> 01:08:54.620]  что он сказал, что мы懍iet.
[01:08:54.620 --> 01:08:56.620]  Ну вот, и получается, что то, что
[01:08:56.620 --> 01:08:58.620]  на Айте сказал, что мы risk Allest
[01:08:58.620 --> 01:09:00.620]  и то что он на Бете сказал, что мы н Messiah,
[01:09:00.620 --> 01:09:02.620]  примерно не имеет этой.
[01:09:02.620 --> 01:09:04.620]  Вот, так вот, puzzите меня,
[01:09:04.620 --> 01:09:06.620]  отличительupa в том, что мы…
[01:09:06.620 --> 01:09:10.620]  Тесты вообще берем, а только предымянные.
[01:09:13.620 --> 01:09:18.620]  Значит, нашлительная отличенность полностью аналогична.
[01:09:22.620 --> 01:09:31.620]  Но стандартный подход, что ТН лежит в СЛДШ-поле.
[01:09:32.620 --> 01:09:37.620]  Тесты задаются схемой терминального развития.
[01:09:40.620 --> 01:09:46.620]  Можно еще ограничить и рассмотреть только алгоритмы, но прям детерминированные.
[01:09:47.620 --> 01:09:49.620]  Потому что...
[01:09:49.620 --> 01:09:51.620]  Странно, что, говорят, тест...
[01:09:51.620 --> 01:09:55.620]  Тест случайности, чтобы он сам появлялся, это было бы странно.
[01:09:55.620 --> 01:09:59.620]  Потому что нужно дать себе случайности, чтобы не сорвать фильм.
[01:10:01.620 --> 01:10:03.620]  Вот.
[01:10:05.620 --> 01:10:07.620]  Хорошо, в общем, будем вот такое вот.
[01:10:07.620 --> 01:10:09.620]  Да, вот такое вот.
[01:10:09.620 --> 01:10:15.620]  Вот такое поделение использовать, чтобы тест сдается схемой терминального развития.
[01:10:17.620 --> 01:10:18.620]  Вот.
[01:10:18.620 --> 01:10:26.620]  Ну и СЗК тоже будет аналогично, только учителем не отличилось место статистической выставки.
[01:10:27.620 --> 01:10:29.620]  Значит, СЗК...
[01:10:29.620 --> 01:10:31.620]  Да, аналог.
[01:10:33.620 --> 01:10:40.620]  СЗК для вычислительной отличимости...
[01:10:44.620 --> 01:10:46.620]  Место...
[01:10:48.620 --> 01:10:50.620]  По статистическому.
[01:10:59.620 --> 01:11:00.620]  Так.
[01:11:00.620 --> 01:11:02.620]  Ну вот такое определение...
[01:11:02.620 --> 01:11:04.620]  Ну, может быть, оно не совсем понятое.
[01:11:04.620 --> 01:11:06.620]  То есть, смотрите, что на них получается.
[01:11:06.620 --> 01:11:11.620]  Почему это вообще либо хорошо...
[01:11:12.620 --> 01:11:20.620]  Ну, смотрите, пусть у нас взломщик может сгенерировать что-то вычислительно неотличимое
[01:11:20.620 --> 01:11:24.620]  к тому, что он узнает ходе общения с честным другом.
[01:11:25.620 --> 01:11:29.620]  И потом это смог как-то использовать.
[01:11:29.620 --> 01:11:38.620]  Но, смотрите, то, как использует этот взломщик, это по нашему предложению как раз будет пыленомиальным алгоритмом.
[01:11:38.620 --> 01:11:41.620]  Да, потому что взломщик не специально и все сможет заломать.
[01:11:41.620 --> 01:11:45.620]  Мы защищаемся только от пыленомиального взломщика.
[01:11:45.620 --> 01:11:48.620]  Но, возможно, именно вот такого СПСД шпуля,
[01:11:48.620 --> 01:11:54.620]  это иммунилирует то, что он может спаять конкретную схему для конкретных длинных ключах.
[01:11:55.620 --> 01:11:58.620]  Поэтому это может быть не неравномерным алгоритмом.
[01:12:02.620 --> 01:12:08.620]  Соответственно, если это взломщик привел к какому-то успеху,
[01:12:09.620 --> 01:12:13.620]  то тогда саму эту схему можно считать тестом.
[01:12:14.620 --> 01:12:18.620]  Ну и тогда даже и наоборот.
[01:12:18.620 --> 01:12:24.620]  Если взломщик пообщался с честным клиентом и после этого смог взломать,
[01:12:24.620 --> 01:12:28.620]  то точно так же он мог пообщаться с этим симулятором.
[01:12:29.620 --> 01:12:33.620]  И поскольку симулятор неотличим,
[01:12:33.620 --> 01:12:37.620]  то вот эта простая процедура, которую использует взломщик,
[01:12:37.620 --> 01:12:41.620]  должна с той же вероятностью взломать схему,
[01:12:41.620 --> 01:12:44.620]  но и значит по схему не надежная.
[01:12:50.620 --> 01:12:54.620]  Так, ну теперь как это еще связано с судок и всем тут еще?
[01:12:56.620 --> 01:13:02.620]  Значит, здесь ключович, который мы будем на крипто-карте покорить,
[01:13:02.620 --> 01:13:05.620]  это для такого приятного.
[01:13:07.620 --> 01:13:09.620]  Это для такого приятного.
[01:13:17.620 --> 01:13:19.620]  Значит, тут есть...
[01:13:23.620 --> 01:13:25.620]  Значит, нет, кажется...
[01:13:29.620 --> 01:13:31.620]  Перезагрузка 1.
[01:13:33.620 --> 01:13:35.620]  И по нему делается...
[01:13:37.620 --> 01:13:39.620]  Значит, величину.
[01:13:39.620 --> 01:13:41.620]  C это...
[01:13:41.620 --> 01:13:43.620]  Значит, C это слово commitment.
[01:13:43.620 --> 01:13:45.620]  Привязка...
[01:13:48.620 --> 01:13:50.620]  Ага, это такой...
[01:13:53.620 --> 01:13:56.620]  Значит, какие здесь требования?
[01:13:56.620 --> 01:13:59.620]  Ну, первая вероятность, что все будет предъявлено.
[01:14:02.620 --> 01:14:04.620]  Значит, дальше...
[01:14:08.620 --> 01:14:10.620]  Значит, первая...
[01:14:11.620 --> 01:14:14.620]  А, ну первая, это как бы корректность.
[01:14:18.620 --> 01:14:23.620]  Сейчас, ну дальше есть как бы процедура раскрытия.
[01:14:26.620 --> 01:14:29.620]  Значит, корректность.
[01:14:32.620 --> 01:14:35.620]  Давайте я эту опенку напишу, как бы открыли шкатулку.
[01:14:35.620 --> 01:14:41.620]  Но, значит, open от C от B и K от B нам дает уже...
[01:14:43.620 --> 01:14:45.620]  Да, будет именно...
[01:14:45.620 --> 01:14:47.620]  Именно то, что было изначально.
[01:14:49.620 --> 01:14:51.620]  Так, значит, второй неположенец.
[01:14:54.620 --> 01:14:56.620]  Сейчас, это вообще что?
[01:14:56.620 --> 01:14:58.620]  Что?
[01:14:58.620 --> 01:15:00.620]  Open это...
[01:15:00.620 --> 01:15:02.620]  Ну, как есть и вкусы.
[01:15:02.620 --> 01:15:04.620]  Одна из запечатываний, это как бы звание B,
[01:15:04.620 --> 01:15:06.620]  в пару, вероятность.
[01:15:06.620 --> 01:15:08.620]  Это либо вероятностный алгоритм,
[01:15:08.620 --> 01:15:10.620]  либо даже интерактивный протокол.
[01:15:10.620 --> 01:15:13.620]  В общем, по итогу получается C и K.
[01:15:13.620 --> 01:15:16.620]  А open это витаминировано уже в цели.
[01:15:18.620 --> 01:15:20.620]  И еще, у нас сейчас глобальная концепция такая.
[01:15:20.620 --> 01:15:22.620]  Мы хотим...
[01:15:22.620 --> 01:15:24.620]  Я обидел, что это был предъявлено.
[01:15:25.620 --> 01:15:27.620]  Значит, вот следы двух частей.
[01:15:27.620 --> 01:15:29.620]  Первая часть – это генерация привязки ключа.
[01:15:29.620 --> 01:15:32.620]  А вторая часть – это открытие.
[01:15:33.620 --> 01:15:35.620]  Ну, окей.
[01:15:35.620 --> 01:15:37.620]  Да.
[01:15:37.620 --> 01:15:40.620]  Как бы вот эта C – это такая закрытая шкатулка,
[01:15:40.620 --> 01:15:42.620]  в которой лежит вит.
[01:15:42.620 --> 01:15:44.620]  А K – это ключ.
[01:15:44.620 --> 01:15:46.620]  Соответственно, нужно, чтобы, когда правильный ключ
[01:15:46.620 --> 01:15:48.620]  в шкатулке приложили,
[01:15:48.620 --> 01:15:50.620]  то, соответственно,
[01:15:50.620 --> 01:15:52.620]  тот вит, который там есть, и возник.
[01:15:53.620 --> 01:15:55.620]  То есть существует такой open, что...
[01:15:55.620 --> 01:15:57.620]  Ну, это все вместе, да?
[01:15:57.620 --> 01:15:59.620]  Это все часть протокола.
[01:15:59.620 --> 01:16:01.620]  Часть протокола.
[01:16:01.620 --> 01:16:03.620]  Значит, непрозрачность как раз связана
[01:16:03.620 --> 01:16:05.620]  с этой самой...
[01:16:05.620 --> 01:16:07.620]  с неотвечимостью.
[01:16:07.620 --> 01:16:09.620]  Значит, C от 0
[01:16:09.620 --> 01:16:11.620]  вышли неотвечимо.
[01:16:15.620 --> 01:16:17.620]  Вот C от 1.
[01:16:21.620 --> 01:16:23.620]  Вот. И третья – неподменяемость.
[01:16:23.620 --> 01:16:25.620]  Неподменяемость.
[01:16:29.620 --> 01:16:31.620]  Неподменяемость
[01:16:31.620 --> 01:16:33.620]  значит, не существует
[01:16:33.620 --> 01:16:35.620]  таких
[01:16:35.620 --> 01:16:37.620]  C
[01:16:37.620 --> 01:16:39.620]  ко 0, ко 1.
[01:16:39.620 --> 01:16:41.620]  Значит, таких, что...
[01:16:41.620 --> 01:16:43.620]  Да, open может не быть 0,
[01:16:43.620 --> 01:16:45.620]  1 или аж...
[01:16:45.620 --> 01:16:47.620]  Да, что вручники дашут.
[01:16:47.620 --> 01:16:49.620]  Не существует C ко 0, ко 1.
[01:16:49.620 --> 01:16:51.620]  Таких, что
[01:16:51.620 --> 01:16:53.620]  open
[01:16:53.620 --> 01:16:55.620]  от C ко 0
[01:16:55.620 --> 01:16:57.620]  равно 0 и, соответственно,
[01:16:57.620 --> 01:16:59.620]  open
[01:16:59.620 --> 01:17:01.620]  от C ко 1
[01:17:01.620 --> 01:17:03.620]  равно 0.
[01:17:09.620 --> 01:17:11.620]  Вот.
[01:17:11.620 --> 01:17:13.620]  Значит, дальше получается, что вот эти протоколы
[01:17:13.620 --> 01:17:15.620]  они позволяют... Ну, это как бы для одного витра
[01:17:15.620 --> 01:17:17.620]  написано.
[01:17:17.620 --> 01:17:19.620]  Можно как бы каждый витр по отдельности упаковать вот так вот.
[01:17:21.620 --> 01:17:23.620]  Вот. Ну, дальше...
[01:17:23.620 --> 01:17:25.620]  Сейчас. На судоку немножко сложнее.
[01:17:25.620 --> 01:17:27.620]  Что такое ко 0, ко 1?
[01:17:27.620 --> 01:17:29.620]  Скробки какие?
[01:17:29.620 --> 01:17:31.620]  В плане...
[01:17:31.620 --> 01:17:33.620]  Ключи.
[01:17:33.620 --> 01:17:35.620]  В плане...
[01:17:35.620 --> 01:17:37.620]  Не существует C ко 0, ко 0,
[01:17:37.620 --> 01:17:39.620]  ко 1, ко 1. То есть мы говорим, что для каждого
[01:17:39.620 --> 01:17:41.620]  комплектного C... Не может быть такой шкатулки,
[01:17:41.620 --> 01:17:43.620]  что и есть два ключа,
[01:17:43.620 --> 01:17:45.620]  и если есть один ключ, то будет 0, а с другой
[01:17:45.620 --> 01:17:47.620]  будет один. Ну да, то есть...
[01:17:47.620 --> 01:17:49.620]  Да, что либо ключ там лежит, либо ключ
[01:17:49.620 --> 01:17:51.620]  там лежит.
[01:17:51.620 --> 01:17:53.620]  Жесть.
[01:17:53.620 --> 01:17:55.620]  Шкатулка, это, видимо,
[01:17:55.620 --> 01:17:57.620]  какой-то кодированный.
[01:17:57.620 --> 01:17:59.620]  Что? Шкатулка, это просто какой-то кодированный.
[01:17:59.620 --> 01:18:01.620]  Мы как-то закодировали наш бит,
[01:18:01.620 --> 01:18:03.620]  так что его можно открыть, видимо, только...
[01:18:03.620 --> 01:18:05.620]  Ну, тех того, да.
[01:18:05.620 --> 01:18:07.620]  Сейчас...
[01:18:07.620 --> 01:18:09.620]  А, почему...
[01:18:09.620 --> 01:18:11.620]  Почему
[01:18:11.620 --> 01:18:13.620]  мы не можем просто сказать, что ко 0, ко 1? Это просто наши ключи.
[01:18:13.620 --> 01:18:15.620]  Может, надо сказать, что ко 0, ко 1
[01:18:15.620 --> 01:18:17.620]  не равно
[01:18:17.620 --> 01:18:19.620]  Сейчас что?
[01:18:19.620 --> 01:18:21.620]  Не, не, сейчас, если
[01:18:21.620 --> 01:18:23.620]  если такая B, то будет
[01:18:23.620 --> 01:18:25.620]  именно B.
[01:18:25.620 --> 01:18:27.620]  А, может, чтобы другое значение нельзя.
[01:18:29.620 --> 01:18:31.620]  В плане мы говорим, что для данной привязки
[01:18:31.620 --> 01:18:33.620]  нету какого-то... для любого
[01:18:33.620 --> 01:18:35.620]  ключа выдаст либо
[01:18:35.620 --> 01:18:37.620]  тоже B, либо ошибку. Да-да-да.
[01:18:37.620 --> 01:18:39.620]  А для каких-то других привязок
[01:18:39.620 --> 01:18:41.620]  мы говорим, что...
[01:18:41.620 --> 01:18:43.620]  Это вообще для любой привязки.
[01:18:43.620 --> 01:18:45.620]  Ну...
[01:18:47.620 --> 01:18:49.620]  Ну, да.
[01:18:51.620 --> 01:18:53.620]  То есть тут, значит, опять потом
[01:18:53.620 --> 01:18:55.620]  используется, да, значит, что
[01:18:55.620 --> 01:18:57.620]  прувер, он, например,
[01:18:57.620 --> 01:18:59.620]  ну, дай себе
[01:18:59.620 --> 01:19:01.620]  три раскраски. Так, я, наверное, уже
[01:19:01.620 --> 01:19:03.620]  не буду рисовать, уже вообще время закончилось, но вкратце
[01:19:03.620 --> 01:19:05.620]  я расскажу. Три раскраски — это
[01:19:05.620 --> 01:19:07.620]  проще, чем судорогу, но это тоже другая задача.
[01:19:07.620 --> 01:19:09.620]  Значит, значит, прувер
[01:19:09.620 --> 01:19:11.620]  знает три раскраски.
[01:19:11.620 --> 01:19:13.620]  Дальше
[01:19:13.620 --> 01:19:15.620]  он случайным образом
[01:19:15.620 --> 01:19:17.620]  представляет цвета.
[01:19:17.620 --> 01:19:19.620]  Да, получается, он представляет три раскраски.
[01:19:19.620 --> 01:19:21.620]  Вот.
[01:19:21.620 --> 01:19:23.620]  И дальше на каждый цвет нам два бита,
[01:19:23.620 --> 01:19:25.620]  и с каждым битом он вот это вот поделывает.
[01:19:25.620 --> 01:19:27.620]  То есть он сам, значит,
[01:19:27.620 --> 01:19:29.620]  знаете, он сам запускает
[01:19:29.620 --> 01:19:31.620]  генерацию привязки
[01:19:31.620 --> 01:19:33.620]  и ключа.
[01:19:33.620 --> 01:19:35.620]  И все привязки, но без ключей,
[01:19:35.620 --> 01:19:37.620]  да, все привязки
[01:19:37.620 --> 01:19:39.620]  посылает верификатом.
[01:19:39.620 --> 01:19:41.620]  То есть, смотрите, что, что это, наверное, произошло?
[01:19:41.620 --> 01:19:43.620]  В этот момент произошло
[01:19:43.620 --> 01:19:45.620]  из-за непрозрачности
[01:19:45.620 --> 01:19:47.620]  верификатор ничего не знает, что там в привязке
[01:19:47.620 --> 01:19:49.620]  лежит.
[01:19:49.620 --> 01:19:51.620]  А другое, что из-за непобменяемости,
[01:19:51.620 --> 01:19:53.620]  уже на следующих этапах
[01:19:53.620 --> 01:19:55.620]  прувер либо посылает
[01:19:55.620 --> 01:19:57.620]  ключ подходящий, там уже он
[01:19:57.620 --> 01:19:59.620]  то, к чему он привязался, ну, либо
[01:19:59.620 --> 01:20:01.620]  он посылает ключ неподходящий, и тогда
[01:20:01.620 --> 01:20:03.620]  верификатор не принял.
[01:20:03.620 --> 01:20:05.620]  То есть, вот,
[01:20:05.620 --> 01:20:07.620]  вот, хорошо, значит,
[01:20:07.620 --> 01:20:09.620]  после этого
[01:20:09.620 --> 01:20:11.620]  верификатор просит раскрыть,
[01:20:11.620 --> 01:20:13.620]  выпирает случайное вебро,
[01:20:13.620 --> 01:20:15.620]  и просит раскрыть привязки
[01:20:15.620 --> 01:20:17.620]  к цветам концов
[01:20:17.620 --> 01:20:19.620]  этого вебра.
[01:20:19.620 --> 01:20:21.620]  И только для них
[01:20:21.620 --> 01:20:23.620]  прувер посылает ключи.
[01:20:23.620 --> 01:20:25.620]  Вот эти вот.
[01:20:25.620 --> 01:20:27.620]  Ну, вот,
[01:20:27.620 --> 01:20:29.620]  вот,
[01:20:29.620 --> 01:20:31.620]  вот,
[01:20:31.620 --> 01:20:33.620]  вот,
[01:20:33.620 --> 01:20:35.620]  вот эти вот.
[01:20:35.620 --> 01:20:37.620]  Да, то есть, как
[01:20:37.620 --> 01:20:39.620]  там две вершины, по два бита,
[01:20:39.620 --> 01:20:41.620]  четыре ключа посылают.
[01:20:41.620 --> 01:20:43.620]  Вот, верификатор раскрывает
[01:20:43.620 --> 01:20:45.620]  и проверяет, что там цвета корректная.
[01:20:45.620 --> 01:20:47.620]  Прикольно.
[01:20:47.620 --> 01:20:49.620]  Вот, а что получается?
[01:20:49.620 --> 01:20:51.620]  Слушайте, а мы пользуемся тем, что такая функция есть, да?
[01:20:51.620 --> 01:20:53.620]  Ну, это предположение,
[01:20:53.620 --> 01:20:55.620]  там дальше есть, это
[01:20:55.620 --> 01:20:57.620]  на квитографию будем изучать.
[01:20:57.620 --> 01:20:59.620]  Ну, реально, если есть одностронняя функция,
[01:20:59.620 --> 01:21:01.620]  то есть и вот такое.
[01:21:01.620 --> 01:21:03.620]  И это прям, почти теорема.
[01:21:03.620 --> 01:21:05.620]  Ну, это теорема, которую мы почти докажем.
[01:21:05.620 --> 01:21:07.620]  В курсе квитографии.
[01:21:07.620 --> 01:21:09.620]  Вот.
[01:21:09.620 --> 01:21:11.620]  А безнутроей функции вообще
[01:21:11.620 --> 01:21:13.620]  квитографии нету.
[01:21:13.620 --> 01:21:15.620]  Вот.
[01:21:15.620 --> 01:21:17.620]  Смотрите, если
[01:21:17.620 --> 01:21:19.620]  раскраска правильная,
[01:21:19.620 --> 01:21:21.620]  то там все будет нормально, все пройдет.
[01:21:21.620 --> 01:21:23.620]  Если
[01:21:23.620 --> 01:21:25.620]  раскраски нету,
[01:21:25.620 --> 01:21:27.620]  то к чему бы пружину привязался,
[01:21:27.620 --> 01:21:29.620]  где-то какая-то ошибка будет.
[01:21:29.620 --> 01:21:31.620]  Либо там негрехный цвет, либо два одинаковых.
[01:21:31.620 --> 01:21:33.620]  Да, в общем, хотя бы на том рябле будет ошибка.
[01:21:33.620 --> 01:21:35.620]  Какую-то вероятность.
[01:21:35.620 --> 01:21:37.620]  Есть вероятность, что один липучной ребер
[01:21:37.620 --> 01:21:39.620]  нарисовка твёрдой этой ребро запустит.
[01:21:39.620 --> 01:21:41.620]  Ну и после этого
[01:21:41.620 --> 01:21:43.620]  либо круг пришёт в честные ключи
[01:21:43.620 --> 01:21:45.620]  и, соответственно, нарисовка
[01:21:45.620 --> 01:21:47.620]  сменит ошибку, либо круг пришёт в неподходящие ключи
[01:21:47.620 --> 01:21:49.620]  и, соответственно,
[01:21:49.620 --> 01:21:51.620]  пускать хорошее истошит.
[01:21:51.620 --> 01:21:53.620]  Вот, вот получается разрыв,
[01:21:53.620 --> 01:21:55.620]  между единицей и единицей мимо за ним
[01:21:55.620 --> 01:21:57.620]  будет ключной ребер, который потом можно
[01:21:57.620 --> 01:21:59.620]  наносить.
[01:21:59.620 --> 01:22:01.620]  Вот.
[01:22:01.620 --> 01:22:03.620]  Откуда нулевое разглашение?
[01:22:03.620 --> 01:22:05.620]  А как раз от перекраски.
[01:22:05.620 --> 01:22:07.620]  Да, от того, что мы случайно образно перекрасили
[01:22:07.620 --> 01:22:09.620]  и тогда у нас ребро
[01:22:09.620 --> 01:22:11.620]  имело два разных цвета
[01:22:11.620 --> 01:22:13.620]  при случайной перекраске
[01:22:13.620 --> 01:22:15.620]  это просто случайная пара различных цветов.
[01:22:19.620 --> 01:22:21.620]  Понятно. Шесть перестанововых цветов
[01:22:21.620 --> 01:22:23.620]  и, соответственно, шесть вариантов
[01:22:23.620 --> 01:22:25.620]  разных цветов
[01:22:25.620 --> 01:22:27.620]  у конца ребра
[01:22:27.620 --> 01:22:29.620]  и как раз разделяет на одно FD будет.
[01:22:29.620 --> 01:22:31.620]  Вот.
[01:22:31.620 --> 01:22:33.620]  Ну и интуитивно
[01:22:33.620 --> 01:22:35.620]  всё, что узнал эфикатор
[01:22:35.620 --> 01:22:37.620]  это он узнал случайную перекраску одного ребра
[01:22:37.620 --> 01:22:39.620]  который разноцветный
[01:22:39.620 --> 01:22:41.620]  но это он и сам может его выкручивать.
[01:22:43.620 --> 01:22:45.620]  Вот такая FD, а дальше там
[01:22:45.620 --> 01:22:47.620]  формально нужно доказывать
[01:22:47.620 --> 01:22:49.620]  как бы сопрягать вот это вот с тем определением
[01:22:49.620 --> 01:22:51.620]  и ещё доказывать
[01:22:51.620 --> 01:22:53.620]  что в повторении тоже ничего не испортится.
[01:22:57.620 --> 01:22:59.620]  Вот.
[01:23:01.620 --> 01:23:03.620]  Ничего.
[01:23:03.620 --> 01:23:05.620]  Да. Но нам ровно этого не хватало
[01:23:05.620 --> 01:23:07.620]  в суть.
[01:23:07.620 --> 01:23:09.620]  В смысле на семинаре нам не хватало
[01:23:09.620 --> 01:23:11.620]  как раз гарантии, что он не под...
[01:23:11.620 --> 01:23:13.620]  Ну то есть мы предложили поставить стол
[01:23:13.620 --> 01:23:15.620]  и положить карточки
[01:23:15.620 --> 01:23:17.620]  в рубашки вверх.
[01:23:17.620 --> 01:23:19.620]  Потом он идёт и потом ему просят
[01:23:19.620 --> 01:23:21.620]  типа открыть карточки.
[01:23:21.620 --> 01:23:23.620]  Вот.
[01:23:23.620 --> 01:23:25.620]  Да, но важна ещё случайная
[01:23:25.620 --> 01:23:27.620]  пристановка.
[01:23:27.620 --> 01:23:29.620]  Ну да, ну в плане, короче, что он видит
[01:23:29.620 --> 01:23:31.620]  что между процессом он не подменяет
[01:23:31.620 --> 01:23:33.620]  никак карточки.
[01:23:33.620 --> 01:23:35.620]  Но так бы нам нужно было это смоделировать
[01:23:35.620 --> 01:23:37.620]  по сети условно.
[01:23:37.620 --> 01:23:39.620]  А тут это оно есть.
[01:23:39.620 --> 01:23:41.620]  Да, да, это вот оно есть.
[01:23:43.620 --> 01:23:45.620]  Так, ну всё, видимо.
[01:23:45.620 --> 01:23:47.620]  Спасибо.
[01:23:47.620 --> 01:23:49.620]  Всё, спасибо.
[01:23:49.620 --> 01:23:51.620]  Что хотите.
[01:23:55.620 --> 01:23:57.620]  Так, а что у вас остается экзамен?
[01:23:57.620 --> 01:23:59.620]  Есть.
[01:23:59.620 --> 01:24:01.620]  До следующего года.
